{"ver":"0.1","info":{"id":"ldcSR7","date":"1458713180","viewed":2705,"name":"Sunset Breaking Wave","username":"hsiangyun","description":"Modeling the breaking wave.","likes":58,"published":1,"flags":0,"usePreview":1,"tags":["wave","sunset","cloud","water","ocean","sky","breakingwave"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Hsiang Yun, 2016 \n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n/**********************************************\n\nModeling the breaking wave based on Seascape & Cloud\n\nReferences: \n\tSeascape : https://www.shadertoy.com/view/Ms2SD1\n   \tCloud: https://www.shadertoy.com/view/XslGRr\n\n\n***********************************************/\n\n\n/************************************\n\t\t\tConstants\n************************************/\n#define RENDER_SKY\n#define RENDER_OCEAN\n#define RENDER_SPRAY\n\n// WaterBomb may cause crashes on Chrome/AMD (but works well on Firefox/AMD)\n#define RENDER_WATERBOMB   \n\nconst float PI = 3.1415926;\nconst float PI2 = PI *2.0; \n\nvec3 sundir = normalize(vec3 ( -1.0,0.1,0.0));\nvec3 haloclr1 = vec3(254.,201.,59.)/255.;\nvec3 haloclr2 = vec3(253.,158.,45.)/255.;\n\n\n\n/************************************\n\t\t Math \n************************************/\n\nvec2 rot (vec2 p, float a) \n{ float s = sin(a); float c = cos(a); return mat2(c,s,-s,c) * p; }\n\n\n// by iq\nfloat noise(in vec3 v)\n{\n\tvec3 p = floor(v);\n    vec3 f = fract(v);\n\tf = f*f*(3.-2.*f);\n\tvec2 uv = (p.xy+vec2(37.,17.)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+.5)/256., 0.).yx;\n\treturn mix(rg.x, rg.y, f.z);\n} \n\nvec3 random3f( vec3 p )\n{\n\treturn textureLod( iChannel0, (p.xy + vec2(3.0,1.0)*p.z+0.5)/256.0, 0.0 ).xyz;\n}\n\n// by iq\nvec3 voronoi( in vec3 x )\n{\n    vec3 p = floor( x );\n    vec3 f = fract( x );\n\n\tfloat id = 0.0;\n    vec2 res = vec2( 100.0 );\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 b = vec3( float(i), float(j), float(k) );\n        vec3 r = vec3( b ) - f + random3f( p + b );\n        float d = dot( r, r );\n\n        if( d < res.x )\n        {\n\t\t\tid = dot( p+b, vec3(1.0,57.0,113.0 ) );\n            res = vec2( d, res.x );\t\t\t\n        }\n        else if( d < res.y )\n        {\n            res.y = d;\n        }\n    }\n    return vec3( sqrt( res ), abs(id) );\n}\n\n/************************************\n\t\tsun & sky & clouds\n************************************/\n\nfloat grow( float x, float bias, float k ) \n{\n    return 1.0- exp(-abs(x-bias)*k);\n}\nfloat fbmCloud ( vec3 p ) \n{\n    float a = 0.5;\n    p *= 0.5;\n    p.x += iTime*0.5;\n    p.y += iTime*0.2;\n    float f = 1.0;\n    float v = 0.0;\n    for ( int i = 0 ; i < 5 ; ++i)\n    {\n        v += a* noise ( p*f ) ;\n        a *= 0.5 ;\n        f *= 2.;\n    }\n    v = max(0.0, v - 0.5);\n    return v;\n}\n\nfloat calcDomeRay( vec3 ro, vec3 rd, out vec3 domePos)\n{\n    float r = 500.0; // skydome radius\n    float h = 30.0;   // sky height \n    vec3 o = ro ;\t\t\n    vec3 p = o;  p.y -= r - h; // p : skydome center;\n    float a = dot(rd,rd);\n    vec3 op = 2.0*o-p;\n    float b = dot(op, rd);\n    float c = dot(op,op) - r*r;\n    float bac = b*b-a*c;\n    float t = -1.0;\n    if ( bac > 0.0 )\n    {\n        t = (-b +sqrt(bac)) / a;\n    }\n    if ( t < 0.0 ) t = -1.0;\n    domePos = ro + rd*t;\n    return t;\n}\n\nvec3 renderCloud ( vec3 ro, vec3 rd, vec3 bg)\n{\n    float sundot = clamp(dot(sundir, rd),0.,1.);\n    vec3 halo1 = haloclr1 * pow ( sundot, 50.0);\n    vec3 halo2 = haloclr2 * pow ( sundot, 20.0);\n   \t// cloud\n    vec4 sum = vec4(bg, 0.0);\n    vec3 domePos;\n    float domeT;\n    if ( rd.y > -0.1 )\n    {\n        float domeT = calcDomeRay(ro,rd,domePos);\n    \tif ( domeT > -0.5 ) \n    \t{\n        \tfloat t = 0.0;\n            for ( int i = 0 ;i < 4 ; ++i)\n            {\n                vec3 pos = domePos + rd * t ;\n                float ratio = 0.2;\n                float d1 = fbmCloud ( pos*ratio);;\n                float d2 = fbmCloud ( (pos*ratio + sundir*1.0 ) ) ;\n               \n                float dif = clamp(d1-d2,0.0,1.0);\n                // diff lighting\n                vec4 clr = vec4(vec3(0.3),0.0) + vec4(haloclr2 *dif *5.0, d1);\n                clr.rgb += halo2*5.0 + halo1 *2.0 ;\t\t\t\t// hack\n                clr.w *=  exp ( -distance(domePos, ro)*.025);\t// hack\n                clr.rgb = clr.rgb * clr.a;\n                sum = sum + clr * ( 1.0-sum.a);\n                \n                t += 1.0;\n            }\n        }\n    }\n    return sum.rgb;\n}\n\nvec3 renderAtmosphere (vec3 rd)\n{\n    vec3 atm = vec3(0.0);\n    float ry = max(0.0,rd.y);\n    atm.r = mix(0.25, 0., grow(ry, 0.0, 5.0));\n  \tatm.g = mix(0.06,0., grow(ry, 0.1, 0.5));\n   \tatm.b = mix(0.,0.3, grow(ry, 0., 0.5));\n    return atm;\n}\n\nvec3 renderSky( vec3 rd)\n{\n    // sun \n    float sundot = clamp(dot(sundir, rd),0.,1.);\n    vec3 core = vec3(1.) * pow(sundot,250.0);\n   \n    vec3 halo1 = haloclr1 * pow ( sundot, 50.0);\n    vec3 halo2 = haloclr2 * pow ( sundot, 20.0);\n    vec3 sun = core + halo1 *0.5 + halo2 *0.9 ;\n  \n    // atm \n    vec3 atm = renderAtmosphere ( rd);\n    return sun + atm;\n}\n\n\nvec3 renderSkyCloudDome ( vec3 ro, vec3 rd )\n{\n\tvec3 sky = renderSky(rd);\n    vec3 cloud = renderCloud( ro, rd, sky );\n    return cloud;\n}\n\n\n\n/************************************\n\t\t\t\tOcean \n************************************/\n\n// by TDM\nmat2 octave_m = mat2(1.6,1.2,-1.2,1.6);\n\nfloat sea_octave(vec2 uv, float choppy) {\n    uv += noise(uv.xyx + uv.xyy);        \n    vec2 wv = 1.0-abs(sin(uv));\n    vec2 swv = abs(cos(uv));    \n    wv = mix(wv,swv,wv);\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\nfloat sea_height( vec3 p)\n{\n    float freq = 0.4;\n    float amp = 0.1;\n    float choppy = 5.0;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    float sea_time = iTime * 0.8;\n    float d, h = 0.0;    \n    for(int i = 0; i < 3; i++) {        \n    \td = sea_octave((uv+sea_time)*freq,choppy);\n    \td += sea_octave((uv-sea_time)*freq,choppy);\n        h += d * amp;        \n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return h;\n}\n\n\n/************************************\n\t\t   Breaking Wave \n************************************/\n\nfloat impulse (float x, float c, float w)\n{\n    float d = abs(x-c);\n    if ( d > w ) return 0.0;\n    return 1.0 - smoothstep(0.0,1.0, d/w);\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat hfWave ( float x, vec3 kSpike )\n{\n    float cos_h = kSpike.x * ( cos ( PI * x  ) *0.5 +0.5 ) ;\n    float spike_h = kSpike.y *pow(abs(1.0-abs(x)), 5.5* kSpike.z ) ;\n    return cos_h + spike_h;\n}\n\nvec2 dfWave ( vec3 q, vec2 o, float kRot, vec3 kSpike)\n{  \n    vec2 p = q.xy;\n    if ( dot(p,p) > 1.0) return vec2(p.y,1.0);\n    float r = length(p); \n    p = rot ( p-o, kRot * 0.5 *PI *r  ) + o;\n    \n    // (height, distance to center)\n    return  vec2(p.y - (hfWave(p.x, kSpike) ),p.x);    \n}\n\nvec2 calcLip (vec2 o, float kRot, vec3 kSpike) \n{\n    vec2 lip = vec2(0.0, hfWave(0.0, kSpike )); \n    float r = length(lip);\n    return rot ( lip -o , -kRot * 0.5 *PI * r ) + o; \n}\n\nvoid bwaveParams ( float t, float life, out vec2 o, out vec3 kSpike, out float kRot )\n{\n \tt *= 5.0 * life; \n    o = vec2(0.0); // rotation pivot\n    if ( t < 1.0 ) // forming\n    {\n        kSpike = vec3(0.2*t, 0.0,1.0);\n        kRot = 0.0;\n    }\n    else if ( t < 2.0 ) // breaking \n    {\n        t = t - 1.0;\n        kSpike = vec3(0.2, 0.8*pow(t,1.5),1.0);\n\t    kRot = pow(t,0.5);\n    }\n    else if ( t < 5.0 ) // fallback\n    {        \n        t = t - 2.0; t /= 3.0;\n        o = vec2(-.8,-1.) *t;\n        float t2 = 1.0- t;\n        kSpike = vec3(0.2*t2, 0.8*t2, t2) ;\n\t    kRot = 0.9 + 0.1*(1.0-t);\n        if ( t > 0.5 ) kRot = 0.95 * (1.0- ( t -0.5) *2.0); \n    }\n}\n\nvec2 calcLipAnim ( vec2 ph ) \n{\n    vec2 o; vec3 kSpike; float kRot;\n    bwaveParams ( ph.x, ph.y, o, kSpike, kRot);\n    return calcLip ( o, kRot, kSpike  );\n}\n\nvec3 dfWaveAnim ( vec3 q, float sea_h, vec2 phase )\n{\n\t// height-based wave \n    q.y -= sea_h;\n    // breaking wave \n    vec2 o; vec3 kSpike; float kRot;\n    float spikePhase = 1.0;\n    \n    bwaveParams ( phase.x, phase.y, o, kSpike, kRot);    \n    vec2 d1 = dfWave(q, o, kRot*spikePhase, kSpike*spikePhase);\n    vec2 d2 = dfWave(q, o, 0.0, vec3(kSpike.x*spikePhase,.0,.0));\n    float d = mix( max ( d1.x,d2.x), min(d1.x,d2.x), smoothstep(-1.0,1.0, q.x ) ) ;    \n    float ws = d1.y;\n    // cylinder is for accelerating ray tracing\n    q.y *= 2.5;\n    float bound = sdCylinder(q.xzy,vec2(1.5,4.0));\n    \n    return vec3(d, ws, bound);\n}\nconst float WaveTimeMax = 6.0;\nconst vec3 WaveOffset = vec3(2.8,0.0,0.0);\n\nfloat getWaveTime()\n{\n   // return mod(iTime + 2.5,WaveTimeMax);\n    return iTime;\n}\n\n// todo try composing linear piecewise function \n// and use modf() to periodilize it \n///\n\nconst float d1 = 4.0;\nconst float d2 = 2.0;\nconst float d3 = 3.0;\nconst float totalPhaseTime = d1 + d2 + d3;\n\nvec3 getPhaseDispInX(float t)\n{\n   /*\n       life ph = 0 -> no wave, 1 -> full wave\n\n       (1) (2)   (3) \n\t      /\\\n\t     /  \\\n        /    \\________\n\n       (1) wave forming ( moving forward)  [6 sec\n       (2) wave disappearing ( movng forward)  [6 sec\n       (3) wave roll back to origin [3 sec( moving back hiddenly to make animation periodically)\n\n    */    \n    \n    float px; // phase x\n    float dx; // disp x \n    float d1 = 4.0;\n    float d2 = 2.0;\n    float d3 = 3.0;\n    float t1 = d1;\n    float t2 = t1 + d2;\n    float t3 = t2 + d3;\n\n    float tmod = mod(t, totalPhaseTime ) ;\n    if ( tmod <= t1 )\n    {\n        px = tmod / d1 ;\n        dx = tmod;\n    }\n    else if ( tmod <= t2)\n    {\n        px =  1.0 - (tmod - t1) / d2 ;\n        dx = tmod;\n    }\n    else if ( tmod <= t3)\n    {\n        px = 0.0;\n        dx = mix( t2, 0.0 , (tmod - t2) / d3 ); \n    }\n    //px = 1.0;\n    return vec3(px,dx*0.8, t3);\n    \n}\n\nvec2 getPhase(vec3 p, float t)\n{\n    float w = 10.0;  // wave front length \n    vec3 params = getPhaseDispInX(t);\n    \n    // make wavefront have different phases along z-dir \n    //float zt = mod(t, WaveTimeMax*2.0);\n\tfloat zt = mod(t, params.z) *1.5;\n    \n    float zDirPh = clamp(p.z + zt, 0.0, w) / w ; \n    \n    float xDirPh = params.x;\n \n    //float lifePh =  clamp(sin(t / WaveTimeMax * PI * 0.3), 0.0, 0.5) *2.0 ;\n    \n    \n    return vec2(zDirPh, xDirPh);\n}\n\nvoid waveFrontDistort( inout vec3 p, float inSign )   \n{\n    // scale wave height\n    p.y *= 0.65;\n    \n    // distort wave front line \n    p.x -= inSign * (sin(2.0*p.z)*0.2 + cos(10.0*p.z)* 0.05);\n    \n    // offset \n    p += inSign * WaveOffset;\n    \n}\n\nvoid waveMoveForward( inout vec3 p, in float t, float inSign)\n{\n    float shake = max(0.0,sin(t / WaveTimeMax * PI*0.5))*3.0;\n    \n    float xDisp = getPhaseDispInX(t).y;\n    p.x -= inSign * xDisp ;  // moving for1ward\n   \n}\n\nvec3 getLipPos (in vec3 p, out vec2 phase) // p should be on the straight line\n{\n    vec3 lip = vec3(0.0);\n    float t = getWaveTime();\n    waveFrontDistort(lip, -1.0);\n    waveMoveForward(lip, t, -1.0f);\n    \n   \tphase = getPhase(p,t) ;\n    \n    lip.xy  += calcLipAnim ( phase ) ;\n    \n    return lip;\n}\n\n// ws : wave coordinate s :   0 : center, -1 : backface, \n// bd : wave bounding cylinder\n// ph : wave phase\n// return : ( d, ws, bd, ph ) ;\n\n\nconst float kSeaHeight = 1.0;\nvec4 mapWave(vec3 p, out vec2 ph )\n{\n    float t = getWaveTime();\n    \n    waveFrontDistort(p, 1.0);\n    \n   \tph = getPhase(p,t) ;\n    \n   \tfloat sea_h = sea_height ( p ) *  kSeaHeight;\n    \n    waveMoveForward( p, t, 1.0 );\n  \n    vec3 df = dfWaveAnim ( p,sea_h, ph);\n    return vec4(df.x, df.y, df.z, ph); \n}\n\nvec4 mapWave(vec3 p )\n{\n    vec2 ph;\n    return mapWave(p, ph);\n}\n\nfloat mapWaveCheap(vec3 p)\n{\n    float t = getWaveTime();\n   \twaveFrontDistort(p, 1.0);\n   \tvec2 ph = getPhase(p,t) ;\n    // skip sea height field \n   \tfloat sea_h = 0.0;\n    waveMoveForward( p, t, 1.0 );\n    vec3 df = dfWaveAnim ( p,sea_h, ph);\n    return df.z;\n}\n\nvec3 normalWave( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.01, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    mapWave(pos+eps.xyy).x - mapWave(pos-eps.xyy).x,\n\t    mapWave(pos+eps.yxy).x - mapWave(pos-eps.yxy).x,\n\t    mapWave(pos+eps.yyx).x - mapWave(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat traceWaveBound ( in vec3 ro, in vec3 rd)\n{\n    float tmin = 1.0 ;\n    float tmax = 50.0;\n    \n\tfloat precis = 0.01;\n    float t = tmin;\n    float d = 0.0;\n\n    for( int i=0; i<16; i++ )\n    {\n\t    d = mapWaveCheap( ro+rd*t );\n    \n        if( d <precis || t>tmax ) break;   \n       \tt += d ;\n    }\n    if( t>tmax ) t=-1.0;\n    return t;\n}\n\n\nvec4 traceWave( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0 ;\n    float tmax = 50.0;\n    \n\tfloat precis = 0.01;\n    float t = tmin;\n    float d = 0.0;\n    float ws = 0.0; // wave coordinates\n    vec2 ph = vec2(0,0); // wave phase\n    float bd = 0.0; // wave bounding cylinder df\n    \n    float tb = traceWaveBound(ro,rd);\n    \n    // the distance field of breaking wave is distorted severely, \n    // so we need more iterations and smaller marching steps \n    for( int i=0; i<128; i++ )\n    {\n\t    vec4 hit = mapWave( ro+rd*t, ph );\n        d = hit.x; ws = hit.y; bd = hit.z;\n        \n        if( d <precis || t>tmax ) break;\n        #if 0\n        t += (bd > 0.0 )? d *0.3 : d*0.1;\n        #else\n        if ( tb > -0.5) \n           t += ( bd > 0.0 )? d *0.5 : d *0.1;\n\t    else\n           t += d;\n        #endif \n    }\n\n    if( t>tmax ) t=-1.0;\n    return vec4( t, ws, ph.x, ph.y );\n}\n\nvec3 renderOcean ( vec3 p, vec3 nml, vec3 lig, vec3 rd, float d, float ws, vec2 phase, vec3 sky)\n{ \n    vec3 ligclr = haloclr1 *0.1;\n    vec3 rfl = reflect ( rd, nml ) ;\n    float dif = clamp( dot(nml,lig), 0.0, 1.0);\n    float spe = pow(clamp( dot(rfl,lig), 0.0, 1.0), 16.0);\n    float fre = pow(clamp(1.0+dot(nml,rd),0.0,1.0), 5.0 ) ;\n    float fre2 = pow(clamp(1.0+dot(nml,rd),0.0,1.0), 3.0) *0.7;\n    float ligdot = pow(clamp(dot(rfl,sundir),0.0,1.0),50.0);\n    float t = phase.x;\n    \n    vec3 sss = sky * pow(1.0- clamp(abs(ws),0.0,1.0), 8.0 )  ;\n    float k = pow(impulse(t, 0.8, 1.0),1.5);\n    sss = sss * smoothstep(1.0,0.5, t) * k;\n    sss *= phase.y;\n\n    vec3 rflclr = (renderSky ( rfl ) *0.2) +  (ligdot * haloclr1 *2.0) ;\n    vec3 rfrclr = (dif + spe + fre ) * ligclr * vec3(0.0,0.25,0.3) + sss;\n        \n\tvec3 ocean = mix(rfrclr, rflclr, fre2);\n  \tvec3 fog = sky;\n    return mix( ocean, fog , 1.0-exp( -0.002*d*d ) );\n}\n\n\n\n/************************************\n\t\t\tLip Spray\n************************************/\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\nfloat fbmSpray ( in vec3 p)\n{\n    float ret = 0.0;\n    float amp = 1.0;\n    float frq = 1.0;\n    p.y -= iTime*2.0;\n    p.x -= iTime*1.0;\n    ret +=  abs(amp * noise((p*frq ))) ; frq *= 2.7; amp *= 0.51;\n    ret +=  abs(amp * noise((p*frq ))) ; frq *= 2.0; amp *= 0.49;    \n    ret +=  abs(amp * noise((p*frq ))) ; frq *= 2.0; amp *= 0.49;    \n    //ret +=  abs(amp * noise((p*frq ))) ; frq *= 2.0; amp *= 0.49;    \n    return ret;\n}\n\nfloat sdSprayBound ( vec3 p ) \n{\n    float w = 0.3;\n    float h = 1.0;\n    \n \tvec3 bias = vec3(fbmSpray( p+vec3(128.0,17.0,13.0)),\n                     fbmSpray(p),\n                     fbmSpray(p+vec3(17.0,37.0,43.0)));    \n\n    vec2 phase;\n    vec3 lip = getLipPos (p,phase);\n\tfloat k = p.y-lip.y; \n    lip.y += 0.15;\n    p -= lip;\n    p.y -= h - 0.05 ;\n    p += bias * smoothstep(0.0,2.0,k)*2.; \n    \n    return sdBox ( p, vec3 ( w, h, 10.0));\n}\n\n\nfloat sprayVol ( vec3 p)\n{\n    if ( sdSprayBound(p) < 0.0 ) \n    {\n        float d = smoothstep ( 1.0,0.0, abs(p.z));\n        vec2 phase;\n        \n        vec3 lip = getLipPos (p, phase);\n        float zPhase = phase.x;\n        \n        lip.y += 0.2;\n        float lipk = smoothstep(0.1,1.0,lip.y);\n        // the closer the lip, the denser the fog\n        float k = exp( -abs(p.y - lip.y) *5.0);\n        float v = mix(0.0,20.0,k) ;\n        \n        zPhase = clamp(zPhase,0.0,1.0) * phase.y;\n        \n        // around the breaking phase        \n        float s = smoothstep( 1.0,0.0, abs(zPhase - 0.38));\n      \n        s = pow (s , 40.0);\n       \n        float opa = v * s ;\n      \n       \treturn opa;\n \n    }\n    return 0.0;\n    \n}\n\nfloat traceSprayVol ( vec3 ro, vec3 rd, float depth)\n{\n    const int nSteps = 8;\n    float dt = depth / float(nSteps);\n    float t = 0.0;\n    float opa = 0.0;\n    float sum = 0.0;\n    for ( int i = 0 ;i < nSteps ; ++i)\n    {\n        float d = sprayVol ( ro + rd *t ) ;\n       \tsum += -t *d* dt;\n        t += dt;\n    }\n    opa = 1.0 - exp(sum);\n    return opa;\n}\n\nfloat traceSpray( vec3 ro, vec3 rd )\n{\n    const float eps = 0.05;\n    const float tmin = 0.0;\n    const float tmax = 100.0;\n    float t = tmin;\n    float d = tmax;\n    const int steps = 16;\n    for ( int i = 0 ; i < steps ; ++i)\n    {\n        d = sdSprayBound(ro + t * rd);\n        if ( d < eps || t > tmax) break;\n        t += d * mix ( 0.5, 1.0, float(i)/float(steps));\n        \n    }    \n    if ( t < tmax) return t;\n    return -1.0;\n}\n\nvec3 renderSpray (in vec3 ro, in vec3 rd , float spray_t, float ocean_t)\n{\n    vec3 clr = vec3(0.0);\n    float t = spray_t;\n    if ( t > -0.5)\n    {\n        vec3 fp = ro + rd *t ;\n        vec3 ro2 = fp + rd* 5.0;\n        float t2 = traceSpray ( ro2 , -rd ) ;\n        \n        // the spray is above the ocean\n        t2 = t + 5.0 -t2;        \n        //float depth = 5.0-t2;\n        \n        vec3 bp = ro + rd *t2;\n        if ( ocean_t < t2 && ocean_t > -0.5) \n        {\n\t\t\tbp = ro + rd * ocean_t;\n        }\n        \n        float depth = length( fp -bp);\n        \n        if ( t2 > -0.5)\n        {\n\t        float op = traceSprayVol ( ro+rd*t, rd, depth);\n        \tclr = vec3(op);\n        }\n    }\n    return clr;\n}\n\n/************************************\n\t\t\tWater Bomb\n************************************/\n\n\n\nfloat fbm ( vec3 p)\n{\n    float f;    \n\tvec3 q = p;                       - vec3(0.0,1.0,0.0)*iTime;;\n    f  = 0.50000*noise( q ); q = q*2.02 - vec3(0.0,1.0,0.0)*iTime;\n    f += 0.25000*noise( q ); q = q*2.03 - vec3(0.0,1.0,0.0)*iTime;\n    f += 0.12500*noise( q ); q = q*2.01 - vec3(0.0,1.0,0.0)*iTime;\n    f += 0.06250*noise( q ); q = q*2.02 - vec3(0.0,1.0,0.0)*iTime;\n    f += 0.03125*noise( q );    \n    return f;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat waterBombZBegin()\n{\n    return 3.2 - mod(getWaveTime(), totalPhaseTime);\n}\n\nfloat sdWaterBomb ( vec3 p)\n{\n    // align with the lip\n    vec2 phase;\n    vec3 lip = getLipPos (p,phase); \n    lip.y = max(lip.y,0.0);\n\tp -= lip;   \n    float pz = waterBombZBegin(); // begin explosion\n        \n    // distort\n    float len = 8.0;\n    float r =  0.8* sqrt(smoothstep(len+pz, pz, p.z));\n    p.y -= 0.5;\n    vec3 q = p;\n    q.x += iTime*2.0;\n    r -= voronoi ( q * 2.0 ).x *0.3;\n    p.y += fbm(q) *0.5;\n    \n    return sdCapsule (p, vec3(0.0,0.0,pz), vec3(0.0,0.0,len + pz), r * phase.y * phase.y);\n\n}\n\nfloat sdWaterBombCheap ( vec3 p)\n{\n    // align with the lip\n    vec2 phase;\n    vec3 lip = getLipPos (p,phase); \n\tp -= lip;    \n\n     // distort \n    float len = 8.0 * phase.y;\n    float r = 1. *.8;\n    p.y -= 0.5;\n    vec3 q = p;\n    q.x += iTime*2.0;\n    // r -= voronoi ( q * 2.0 ).x *0.3;\n    p.y += fbm(q) *0.5;\n    p.x += pow ( clamp(p.y,0.0,1.0),2.0)*1.0;\n    \n    float pz = waterBombZBegin() ;\n    \n    return sdCapsule (p, vec3(0.0,0.0,pz), vec3(0.0,0.0,len + pz), r );\n}\n\n\nfloat waterBombVol ( vec3 o)\n{\n    return smoothstep(1.5,0.0,o.y)*20.0;  \n}\n\nvec3 waterBombNormal( in vec3 p )\n{\n\tvec3 e = vec3( 0.001, 0.0, 0.0 );\n\tvec3 n = vec3(sdWaterBombCheap(p+e.xyy) - sdWaterBombCheap(p-e.xyy),\n                  sdWaterBombCheap(p+e.yxy) - sdWaterBombCheap(p-e.yxy), \n                  sdWaterBombCheap(p+e.yyx) - sdWaterBombCheap(p-e.yyx) );\n\treturn normalize(n);\n}\nvec4 traceWaterBombVol ( vec3 ro, vec3 rd, float depth)\n{\n    \n    const int nSteps = 4;\n    float dt = depth / float(nSteps);\n    float t = 0.0;\n    vec3 clr = vec3(0.0);\n    float sigma = 0.0;\n    \n    for ( int i = 0 ;i < nSteps ; ++i)\n    {\n        vec3 p = ro + rd * t ;\n        float d = waterBombVol ( p ) ;\n        sigma += -t * d * dt ;\n        t += dt;\n    }\n    \n    float opacity = 1.0 - exp(sigma);\n    vec3 sunlgt = normalize(vec3(1.0));\n\tvec3 n = waterBombNormal ( ro ) ;\n    float nl = clamp ( dot(n,sunlgt),0.0,1.0);\n    opacity = mix ( opacity * nl , opacity, 0.8);\n    \n    float pre = fbm (100.0*(ro + vec3(0.0,-iTime*2.0,0.0)))*2.0;\n    pre -= fbm ( 1.0*(ro + vec3(0.0,-iTime*1.0,0.0)));\n    \n    float splash =  mix( pre, 1.0, opacity);\n    splash = clamp ( splash - 0.1, 0.0,1.0) *1.2;    \n    opacity *= splash;\n        \n    return vec4(vec3(opacity), opacity);\n}\n\nfloat traceWaterBomb( vec3 ro, vec3 rd )\n{\n    const float eps = 0.01;\n    const float tmin = 0.0;\n    const float tmax = 100.0;\n    float t = tmin;\n    float d = tmax;\n    const int steps = 128;\n    // trace surface \n    for ( int i = 0 ; i < steps ; ++i)\n    {\n        d = sdWaterBomb(ro + t * rd);\n        if ( d < eps || t > tmax) break; \n        t += d * mix ( 0.5, 1.0, float(i)/float(steps));\n    }    \n    if ( t < tmax) return t;\n    return -1.0;\n}\n\nvec4 renderWaterBomb (in vec3 ro, in vec3 rd, in float ocean_t )\n{\n    vec4 clr = vec4(0.0);\n    float t = traceWaterBomb(ro,rd) ;\n    if ( t > -0.5)\n    {\n        vec3 fp = ro + rd *t ;\n        vec3 ro2 = fp + rd*10.0;\n        float t2 = traceWaterBomb ( ro2 , -rd ) ;\n        t2 = t + 10.0 - t2;\n        vec3 bp = ro + rd *t2;\n        \n        if ( t2 > ocean_t && ocean_t > 0.0 )\n        {\n            bp = ro + rd * ocean_t;\n        }\n        float depth = length( fp -bp);\n        \n        \n        if ( t2 > -0.5)\n        {\n\t        clr = traceWaterBombVol ( ro+rd*t, rd, depth);\n            //clr = vec4(1.0);\n        }\n    }\n    return clr;\n}\n\n\n\n\n/************************************\n\t\t\tRender\n************************************/\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 clr = vec3(0.0);\n    \n    #ifdef RENDER_SKY\n    \tclr = renderSkyCloudDome(ro,rd);\n    #endif \n    \n    float ot = -0.5;\n    float ws = 0.0;  \n    vec2 ph = vec2(0.0);\n    float t = 0.0;\n    \n    #ifdef RENDER_OCEAN    \n    {\n        vec4 hit = traceWave(ro,rd);\n        ot = hit.x;\n\t\tws = hit.y;\n        ph = hit.zw;\n    \tif( ot > -0.5 )\n    \t{\n        \tvec3 pos = ro + ot *rd;\n            vec3 nor = normalWave( pos );\n            clr = renderOcean (pos, nor, sundir, rd, ot, ws, ph, clr );   \n        }\n    }\n    #endif\n    \n    #ifdef RENDER_SPRAY\n    t = traceSpray( ro, rd) ;\n    if ( t > -0.5 && (t < ot || ot <0.0))\n    {\n        vec3 tho = renderSpray ( ro, rd, t, ot);\n        //  don't render the lip spary in front of the breaking wave\n        if ( ws < 0.0 || ws >= 1.0) \n        {            \n            clr = mix(clr, vec3(0.5)+haloclr1, tho) ;\n\t    }\n    }\n\t#endif\n\n    #ifdef RENDER_WATERBOMB\n    t = traceWaterBomb ( ro, rd ) ;\n    if ( t > -0.5 && (t < ot || ot < 0.0) )\n    {\n        vec4 col4 = renderWaterBomb(ro,rd, ot);\n        clr = mix ( clr, vec3(0.15)+haloclr1, min(col4.a,1.0));\n        \n    }\n    #endif\n    \n    return clr;\n\t\n}\n\n\nmat3 camera( in vec3 pos, in vec3 lookat, float roll)\n{\n    vec3 z = normalize(lookat- pos);\n    vec3 x = vec3(sin(roll),cos(roll),0.0);  x = cross( z, x ) ;\n    vec3 y = cross(x,z);\n    return mat3(x, y, z ) ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n    vec3 off = vec3(0.0,0.0,0.0);\n    float my = 0.6;\n    float mx = 0.95;\n    if ( iMouse.z > 0.0 )\n    {\n     \tmy = mix(0.35,0.75, mo.y);\n    \tmx = mix(0.9, 1.0,  mo.x);\n    }\n\tvec3 ro = off + vec3( -0.5+3.5*cos(PI2 *mx), 0.0 + 2.0*my, 0.5 + 3.5*sin(PI2 *mx) );\n\tvec3 ta = off + vec3( 0.0, 1.0,0.0 );\n    mat3 ca = camera( ro, ta, 0.0 );\n\tvec3 rd = ca * normalize( vec3(p.xy,2.0) );\n    vec3 col = render( ro, rd );\n\tcol = pow( col, vec3(0.4545) );\n    fragColor=vec4( col, 1.0 );\n}\n\n\n\n","name":"Image","description":"","type":"image"}]}