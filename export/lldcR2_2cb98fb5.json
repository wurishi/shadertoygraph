{"ver":"0.1","info":{"id":"lldcR2","date":"1533982636","viewed":172,"name":"Diablo orb","username":"Ion824","description":"My fork of an existing shader(author below) for reproducing diablo 3 wizard's arcane energy orb.\nAuthor's version here: https://www.shadertoy.com/view/llcSRf","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["ball","orb","multitexture","diablo","arcane","wizard"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define e 2.71\nstruct Orb{\n    float value;\n    vec2 center;\n    float radius;\n    vec3 colour0;\n    vec3 colour1;\n    vec3 colour2;\n};\n    \nstruct Light{\n\tvec3 pos;\n};\n    \n// Returns the intensity for the uv.\n// Is only non-zero if the uv is in the \"filled\" part of the ball.\n// We fake a fluid really poorly by basing the intensity off a noise function\n// when we're really close to the top of the filled bit.\nfloat isColoured(in vec2 uv, in Orb orb){\n    float orbBottom = orb.center.y - orb.radius;\n    float level = orbBottom + orb.value * orb.radius * 2.;\n    \n    if (distance(uv,orb.center) < orb.radius && (uv.y < level)) {\n        if (uv.y / level > .99){\n        \tfloat textVar = texture(iChannel0, uv).x;\n            if (textVar < .3){\n                return 0.;\n            }\n            return textVar;\n        }\n\t\treturn 1.;\n    }\n\treturn 0.;\n}\n    \n// Figures out the colour for the thing\nvec3 getColour(in vec2 uv, in Orb orb){\n    vec3 colour = vec3(0.);\n    float borderDist = orb.radius - distance(uv, orb.center);\n    float intensity = isColoured(uv, orb);\n\tif (intensity != 0.){\n        // Fill that ball up homie\n    \t//colour = vec3(orb.colour * intensity);\n        // Apply a texture to the ball\n        // Do some proper uv mapping: \n        // https://en.wikipedia.org/wiki/UV_mapping#Finding_UV_on_a_sphere\n        vec2 distFromCent = uv - orb.center;\n        float uvHeight = exp(sqrt(orb.radius - (pow(distFromCent.x,2.) + pow(distFromCent.y,2.))) \n            / orb.radius) / exp(1.);\n        vec3 d = normalize(vec3(orb.center, 0.) - vec3(uv, uvHeight));        \n        float u = (.5 + atan(d.z, d.x)\n            \t\t\t/ (2. * 3.14159)) / orb.radius / .5;\n        float v = (.5 - asin(d.y) / 3.14159) / orb.radius / .5;\n        //colour = vec3((u * 0.1 + fract(iTime *.05))/2.0, 0.0, (v * 0.1  + fract(iTime * .03))/2.0);\n        //colour *= vec3(texture(iChannel1, vec2(u + fract(iTime *.05),\n        //                                         v + fract(iTime * .03))).x)\n        //    \t\t* 2.15;\n        //colour = vec3(1.0, 1.0, 1.0);\n        colour = vec3(texture(iChannel1, vec2(u + fract(iTime * .001),\n                                                 v + fract(iTime * .04))).x) * orb.colour0\n            \t\t* 1.0;\n        colour += vec3(texture(iChannel1, vec2(u * 1.3 + fract(iTime * .013),\n                                                 v * 1.7 + fract(iTime * .023))).x) * orb.colour1\n            \t\t* 1.2;\n        colour += vec3(texture(iChannel1, vec2(u * 0.7 + fract(iTime * .005),\n                                                 v * 0.3 + fract(iTime * .008))).x) * orb.colour2\n            \t\t* 0.9;\n        /*colour += vec3(texture(iChannel0, vec2(u * 10.2 + fract(iTime * .135),\n                                                 v * 10.1 + fract(iTime * .218))).x) * vec3(1.0, 1.0, 1.0) * intensity\n            \t\t* 0.2;*/\n       \tcolour *= intensity;\n        // Add some sort of shadow to the coloured bit\n        // TODO: apply some highlight repsonsiveness\n        colour /= pow(2.71, orb.radius * .06 / borderDist);\n    }\n    \n    return colour;\n}\n\n// Add in a bevelled border\nvec3 applyBorder(in vec2 uv, in Orb orb, vec3 currentColour){\n    vec3 colour = currentColour;\n    float borderDist = orb.radius - distance(uv, orb.center);\n\t// Add in a bevelled border\n    if (abs(borderDist) < .005) {\n        colour = vec3(0.3,0.3,0.3);\n        colour += vec3(.7 - abs(borderDist)/.005) * .25;\n    }\n    return colour;\n}\n\n// Apply a specular highlight\n// https://en.wikibooks.org/wiki/GLSL_Programming/GLUT/Specular_Highlights\nvec3 applyHighlight(in vec2 uv, in Orb orb, in Light light, in vec3 eye){\n    vec3 colour = vec3(0.);\n    if (distance(orb.center, uv) >= orb.radius){\n        return colour;\n     }\n    \n    vec2 distFromCent = uv - orb.center;    \n    float uvHeight = sqrt(orb.radius - (pow(distFromCent.x,2.) + pow(distFromCent.y,2.)));\n    vec3 uvw = vec3(uv, uvHeight);\n    vec3 normal = normalize(vec3(uv, uvHeight) - vec3(orb.center, 0.));\n    //return normal;\n    vec3 orbToLight = normalize(light.pos - vec3(orb.center, 0.));\n    \n    return vec3(pow(dot(reflect(normalize(uvw - light.pos),\n                                normal),\n                        normalize(eye - uvw)),\n                    55.));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv0 = fragCoord.xy / iResolution.xy;\n    vec2 uv = fragCoord.xy / iResolution.x;\n    vec3 view = vec3(0., 0., 10.);\n    fragColor = texture(iChannel1, uv0);\n    //fragColor = vec4(0.);\n    \n    Light l1 = Light(vec3(0.5,.7, 1.));\n    // Set up the two orbs\n    vec2 center = vec2(.25, .3);\n    Orb health = Orb(1.0,//abs(sin(iTime * .45)),\n                     center,\n                     .2,\n                     vec3(.57, 0., 0.),\n                     vec3(.57, 0., 0.69),\n                     vec3(.17, 0.2, 0.71));\n    \n    center = vec2(.75, .3);\n    Orb mana = Orb(1.0,//abs(cos(iTime * .15))+ .01,\n                   center,\n                   .2,\n                   vec3(0., 0.3, .57),\n                   vec3(.57, 0., 0.69),\n                   vec3(.17, 0.2, 0.71));\n    \n    // Colour the first orb\n    //vec3 highLightValue = applyHighlight(uv, health, l1, view);\n    \n    vec3 redOrb = vec3(getColour(uv, health));\n    if (redOrb.x > 0.0){\n        fragColor = vec4(redOrb, 1.);\n        \n    }\n     \n    //fragColor = vec4(applyBorder(uv, health, fragColor.xyz), 1.);        \n    //if (highLightValue.x > 0.){\n    //\tfragColor += vec4(highLightValue, 1.);\n    //}\n\t\n    \n    // Colour the second orb\n    //highLightValue = applyHighlight(uv, mana, l1, view);\n    vec3 blueOrb = vec3(getColour(uv, mana));\n    if (blueOrb.z > 0.0){\n        fragColor = vec4(blueOrb, 1.);        \n    }\n    \n    //fragColor = vec4(applyBorder(uv, mana, fragColor.xyz), 1.);        \n    //if (highLightValue.x > 0.){\n    //\tfragColor += vec4(highLightValue, 1.);\n    //}\n    \n}","name":"Image","description":"","type":"image"}]}