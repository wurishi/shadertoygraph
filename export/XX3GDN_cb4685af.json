{"ver":"0.1","info":{"id":"XX3GDN","date":"1716470426","viewed":99,"name":"sRGB to linear conversions","username":"jmpep","description":" This shader showcases how to handle gamma. It showcases the techniques in \n https://chilliant.blogspot.com/2012/08/srgb-approximations-for-hlsl.html.\n\nSee the comment at the top for its interpretation. Click to see the absolute error.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["gamma","linear","srgb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n This shader showcases how to handle gamma. It showcases the techniques in \n https://chilliant.blogspot.com/2012/08/srgb-approximations-for-hlsl.html\n\n First row is just ignoring it and computing the gradient in sRGB space.\n Second row is using simple sqrt and squaring to convert to/from sRGB space.\n Third row is using pow to perform the conversions. Note that a gamma of 2.233333\n is used instead of the typical 2.2 because it gives a better approximation.\n Fourth row is using better approximations.\n The fifth row uses the official transformations.\n \n Click to see the absolute error (10x) between the resulting gradient and the \n correct gradient.\n \n */\n \n#define ANIMATE 1\n\nvec3 srgb_to_linear_approx(vec3 srgb) {\n    return srgb * (srgb * (srgb * 0.305306011 + 0.682171111) + 0.012522878);\n}\n\nvec3 linear_to_srgb_approx(vec3 lin) {\n    return max(1.055 * pow(lin, vec3(0.416666667)) - 0.055, vec3(0.0));\n}\n\nvec3 srgb_to_linear_official(vec3 srgb) {\n  vec3 lin;\n  lin.x = (srgb.x <= 0.04045) ? srgb.x / 12.92 : pow((srgb.x + 0.055) / 1.055, 2.4);\n  lin.y = (srgb.y <= 0.04045) ? srgb.y / 12.92 : pow((srgb.y + 0.055) / 1.055, 2.4);\n  lin.z = (srgb.z <= 0.04045) ? srgb.z / 12.92 : pow((srgb.z + 0.055) / 1.055, 2.4);\n  return lin;\n}\n\nvec3 linear_to_srgb_official(vec3 lin) {\n    vec3 srgb;\n    srgb.x = (lin.x <= 0.0031308) ? srgb.x = lin.x * 12.92 : 1.055 * pow(lin.x, 1.0 / 2.4) - 0.055;    \n    srgb.y = (lin.y <= 0.0031308) ? srgb.y = lin.y * 12.92 : 1.055 * pow(lin.y, 1.0 / 2.4) - 0.055;    \n    srgb.z = (lin.z <= 0.0031308) ? srgb.z = lin.z * 12.92 : 1.055 * pow(lin.z, 1.0 / 2.4) - 0.055;    \n    return srgb;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // end-points\n#if ANIMATE    \n    vec3 color0 = vec3(1.0, 0.0, 0.5 + 0.5 * sin(6.28 * iTime / 10.0));\n    vec3 color1 = vec3(0.0, 1.0, 0.5 + 0.5 * sin(8.28 * iTime / 10.0));\n#else\n    vec3 color0 = vec3(1.0, 0.0, 0.000);\n    vec3 color1 = vec3(0.0, 1.0, 0.081);\n#endif\n\n    // incorrect gradient\n    vec3 mix_in_srgb = mix(color0, color1, uv.x);\n    vec3 mix_in_linear_sqrt = sqrt(mix((color0 * color0), (color1 * color1), uv.x));\n    vec3 mix_in_linear_pow = pow(mix(pow(color0, vec3(2.233333333)), pow(color1, vec3(2.233333333)), uv.x), vec3(0.44776119409));\n    vec3 mix_in_linear_good = linear_to_srgb_approx(mix(srgb_to_linear_approx(color0), srgb_to_linear_approx(color1), uv.x));\n    vec3 mix_in_linear_official = linear_to_srgb_official(mix(srgb_to_linear_official(color0), srgb_to_linear_official(color1), uv.x));\n\n    // select the color\n    vec3 col = mix_in_srgb;\n    if (uv.y < 4.0/5.0) col = mix_in_linear_sqrt;\n    if (uv.y < 3.0/5.0) col = mix_in_linear_pow;\n    if (uv.y < 2.0/5.0) col = mix_in_linear_good;\n    if (uv.y < 1.0/5.0) col = mix_in_linear_official;\n\n    if (iMouse.z > 0.0) {\n        col = 10.0 * abs(col - mix_in_linear_official);\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}