{"ver":"0.1","info":{"id":"3sc3zH","date":"1567721895","viewed":88,"name":"Indian Flag ~ pbakshi","username":"pbakshi","description":"Added the chakra. If anyone has a better solution, comment below!","likes":2,"published":1,"flags":64,"usePreview":0,"tags":["flags","india"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4tXGDB","filepath":"https://soundcloud.com/prashanth-1/sare-jahan-se-acha-15-aug","previewfilepath":"https://soundcloud.com/prashanth-1/sare-jahan-se-acha-15-aug","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define S(a, b, c) smoothstep(a, b, c)\n#define PI 3.14159\n\nvec3 sfdLine(float left, float right, float blur, float axis){\n\treturn vec3(S(left - blur, left, axis) - S(right, right + blur, axis));\n}\n\nvec3 sfdRect(vec2 uv, vec2 topLeft, vec2 bottomRight, float blur){\n\treturn sfdLine(topLeft.x, bottomRight.x, blur, uv.x) * sfdLine(bottomRight.y, topLeft.y, blur, uv.y);\n}\n\nvec2 rotatez(vec2 vector, float angle){\n\tfloat firstComp = vector.x*cos(angle) - vector.y*sin(angle);\n    float secondComp = vector.x*sin(angle) + vector.y*cos(angle);\n    \n    return vec2(firstComp, secondComp);\n}\n\n//new version circle\nfloat circle(vec2 pt, vec2 centre, float radius){\n    \n    vec2 d = pt - centre;\n\treturn (dot(d, d) - radius*radius <= 0.0 ? 1.0 : 0.0);\n}\n\n\n//new chakra function\nvec3 chakra(vec2 pt){\n\n    float pix = 1.0/iResolution.y;\n    \n\tvec3 circles = vec3(\n          circle(pt, vec2(0.0, 0.0), 0.35) //out of big circle\n        - circle(pt, vec2(0.0, 0.0), 0.32) //in of big circle\n        + circle(pt, vec2(0.0, 0.0), 0.05) //smallest circle\n        + circle(pt, vec2(0.0, 0.0), 0.07) //out of mid circle\n        - circle(pt, vec2(0.0, 0.0), 0.06) //in of mid circle\n        );\n    \n    vec3 spokes;\n    for(float i=0.0; i<24.0; i+=1.0){\n    \tspokes = sfdRect(rotatez(vec2(pt), i * 15.0*(PI/180.0)), vec2(-0.01, 0.30), vec2(0.01, 0.085), 0.001);\n        if(spokes == vec3(1.0, 1.0, 1.0))\n            break;\n    }\n    \n    return circles + spokes;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 R = iResolution.xy;\n    vec2 uv = fragCoord/R;\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    \n    \n    //making the 3 colors of flag\n    \t\t  //first color mix                           second color mix                      third color mix\n    color.r += 1.0 * (step(0.7, uv.y) - step(1.0, uv.y)) + (step(0.3, uv.y) - step(0.7, uv.y)) + 0.0 * (step(0.0, uv.y) - step(0.3, uv.y));\n    \n\tcolor.g += 0.6 * (step(0.7, uv.y) - step(1.0, uv.y)) + (step(0.3, uv.y) - step(0.7, uv.y)) + 0.3 * (step(0.0, uv.y) - step(0.3, uv.y));\n\t\n    color.b += 0.2 * (step(0.7, uv.y) - step(1.0, uv.y)) + (step(0.3, uv.y) - step(0.7, uv.y)) + 0.0 * (step(0.0, uv.y) - step(0.3, uv.y));\n    \n    \n    uv = (2.0 * fragCoord - R) / R.y;\n    \n    \n    //for the chakra\n    vec3 chp = chakra(uv);\n     \n    color = mix(color, vec3(0.0, 0.0, 1.0), chp);\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}