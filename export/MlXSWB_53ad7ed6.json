{"ver":"0.1","info":{"id":"MlXSWB","date":"1439567311","viewed":171,"name":"workthrough","username":"ericrius1","description":"ds","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["testing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"\nvec3 g_eye = vec3(0.0, 1.0, -2.0);\nvec3 g_camUp = vec3(0.0, 1.0, 0.0);\nvec3 g_camRight = vec3(1.0, 0.0, 0.0); \n\nconst float g_focalLength = 1.97; // Distance between the eye and the image plane\nconst float g_zNear = 0.0; // Near clip depth\nconst float g_zFar = 25.0; // Far clip depth\nconst int g_rmSteps = 64; // Max raymarch steps\nconst float g_rmEpsilon = 0.001; // Surface threshold\nconst vec4 g_skyColor = vec4(0.31, 0.47, 0.67, 1.0);\nconst vec4 g_ambient = vec4(0.15, 0.2, 0.32, 1.0);\n\nfloat sdSphere(vec3 p, float radius)\n{\n  return length(p) - radius;\n}\n\n//Marches along a ray using the distance field, until an intersection is found\n//i: iteration count\n//t: distance traveled along ray\n\nvoid raymarch(vec3 ro, vec3 rd, out int i, out float t) {\n  t = 0.0;\n  for(int j = 0; j < g_rmSteps; ++j) {\n    vec3 p = ro + rd * t;\n    float d = sdSphere(p, 0.25);\n    if(d < g_rmEpsilon || t > g_zFar) \n    {\n      i = j;\n      break;\n    }\n    t += d;\n  }\n}\n\n//Computes the color corresponding to the ray intersection point (if any)\nvec4 computeColor(vec3 ro, vec3 rd)\n{\n  float t0; //distance traveled by ray\n  int i = 0; //iteration count\n  raymarch(ro, rd, i, t0);\n\n  vec3 p; //Surface point\n  float t; //distance traveled by ray from eye\n\n  if(i < g_rmSteps && t0 >= g_zNear && t0 <= g_zFar) // Raymarching hit a surface\n  {\n    t = t0;\n    p = ro + rd * t0;\n  }\n  else \n  {\n    return g_skyColor;\n  }\n\n  vec4 color = vec4(1.0, 0.0, 1.0, 1.0);\n  return color;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n  float u = fragCoord.x * 2.0 / iResolution.x - 1.0;\n  float v = fragCoord.y * 2.0 / iResolution.y - 1.0;\n  vec3 g_camForward = cross(g_camRight, g_camUp);\n    \n  float aspectRatio = iResolution.x / iResolution.y;\n\n  vec3 ro = g_eye;\n  vec3 rd = normalize(g_camForward * g_focalLength + g_camRight * u * aspectRatio + g_camUp * v);\n  vec4 color = computeColor(ro, rd);\n  fragColor = vec4(color.xyz, 1.0);\n\n}","name":"","description":"","type":"image"}]}