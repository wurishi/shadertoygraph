{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":2,"type":"buffer","id":"4sXGR8","filepath":"/media/previz/buffer02.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":3,"type":"buffer","id":"XdfGR8","filepath":"/media/previz/buffer03.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// Mix \"Oasis - Acute Ang Cells Voro III\" by Chimel. https://shadertoy.com/view/McVfDh\n// 2024-12-12 18:53:23\n// Mixed with \"Voronoi points sim\" by wyatt. https://shadertoy.com/view/MfKfz1\n// 2024-12-12 18:54:34\n\n\n// Constants\n#define EPSILON 1e-4\nconst float EDGE_THICKNESS = 0.006;\nconst float EDGE_SOFTNESS = 0.7;\n\nconst vec3 CELL_COLORS[4] = vec3[4](\n    vec3(0.000,0.616,1.000),    // Blue (0 acute angles)\n    vec3(1.000,0.682,0.000),    // Yellow (1 acute angle)\n    vec3(1.000,0.533,0.000),    // Orange (2 acute angles)\n    vec3(1.000,0.400,0.000)     // Red (3 or more acute angles)\n);\n\nMain {\n    vec4 b = B(U);\n    vec4 c = C(U);\n    vec4 d = D(U);\n    \n    vec4 q1 = A(b.xy);\n    vec4 q2 = A(c.xy);\n    vec4 q3 = A(d.xy);\n    \n    // Find vertices of the Voronoi cell\n    vec2[8] vertices;\n    int vertexCount = 0;\n    \n    // Use perpendicular bisectors to find vertices\n    for (float x = -2.; x <= 2.; x++)\n    for (float y = -2.; y <= 2.; y++) {\n        vec4 _b = B(U+vec2(x,y));\n        vec4 _c = C(U+vec2(x,y));\n        vec4 _q1 = A(_b.xy);\n        vec4 _q2 = A(_c.xy);\n        \n        vec2 mid = 0.5 * (_q1.xy + _q2.xy);\n        if (length(_q1.xy - _q2.xy) > EPSILON && \n            length(U - mid) < length(U - q1.xy) + 0.1) {\n            if (vertexCount < 8) {\n                vertices[vertexCount++] = mid;\n            }\n        }\n    }\n    \n    // Sort vertices\n    for (int i = 0; i < vertexCount - 1; i++) {\n        for (int j = i + 1; j < vertexCount; j++) {\n            float angle_i = atan(vertices[i].y - q1.xy.y, vertices[i].x - q1.xy.x);\n            float angle_j = atan(vertices[j].y - q1.xy.y, vertices[j].x - q1.xy.x);\n            if (angle_j < angle_i) {\n                vec2 temp = vertices[i];\n                vertices[i] = vertices[j];\n                vertices[j] = temp;\n            }\n        }\n    }\n    \n    // Count acute angles\n    int acuteCount = 0;\n    for (int i = 0; i < vertexCount; i++) {\n        vec2 prev = vertices[(i + vertexCount - 1) % vertexCount];\n        vec2 curr = vertices[i];\n        vec2 next = vertices[(i + 1) % vertexCount];\n        \n        vec2 v1 = normalize(prev - curr);\n        vec2 v2 = normalize(next - curr);\n        float angle = acos(clamp(dot(v1, v2), -1.0, 1.0));\n        \n        if (angle < 1.5708) acuteCount++;\n    }\n    \n    // Color based on acute angles\n    vec3 color = CELL_COLORS[min(acuteCount, 3)];\n    \n    // Edge rendering\n    float edgeDist = 1.0;\n    for (int i = 0; i < vertexCount; i++) {\n        vec2 v1 = vertices[i];\n        vec2 v2 = vertices[(i + 1) % vertexCount];\n        vec2 edge = v2 - v1;\n        vec2 toPixel = U - v1;\n        float edgeLen = dot(edge, edge);\n        if (edgeLen > EPSILON) {\n            float t = clamp(dot(toPixel, edge) / edgeLen, 0.0, 1.0);\n            edgeDist = min(edgeDist, length(U - (v1 + t * edge)) / EDGE_THICKNESS);\n        }\n    }\n    \n    // Edge blending\n    color = mix(vec3(0.2), color, smoothstep(0.0, EDGE_SOFTNESS, edgeDist));\n    \n    // Add dots at acute angles\n    for (int i = 0; i < vertexCount; i++) {\n        vec2 prev = vertices[(i + vertexCount - 1) % vertexCount];\n        vec2 curr = vertices[i];\n        vec2 next = vertices[(i + 1) % vertexCount];\n        \n        vec2 v1 = normalize(prev - curr);\n        vec2 v2 = normalize(next - curr);\n        float angle = acos(clamp(dot(v1, v2), -1.0, 1.0));\n        \n        if (angle < 1.5708) {\n            float dotDist = length(U - curr) / (EDGE_THICKNESS * 8.0);\n            if (dotDist < 1.0) {\n                color = mix(color, vec3(1.0), smoothstep(1.0, 0.0, dotDist));\n            }\n        }\n    }\n    \n    Q = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"#define R iResolution.xy\n#define Main void mainImage(out vec4 Q, in vec2 U)\n#define A(U) texelFetch(iChannel0,ivec2(U),0)\n#define B(U) texelFetch(iChannel1,ivec2(U),0)\n#define C(U) texelFetch(iChannel2,ivec2(U),0)\n#define D(U) texelFetch(iChannel3,ivec2(U),0)\n\n// Perpendicular Bisector\nfloat P(vec2 p, vec2 a, vec2 b) {\n    vec2 m = 0.5*(a+b); // midpoint\n    if (length(a-b)<1e-3) return 1e3; // ignore self\n    return abs(dot(p-m,b-m)/dot(b-m,b-m)); // projection\n}\n\n// Line\nfloat L(vec2 p, vec2 a, vec2 b) {\n    if (length(a-b)<1e-3) return 1e3; // ignore self\n    return length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n}\n\n// Circumcenter\nvec2 cc(vec2 a, vec2 b, vec2 c) {\n    vec2 ab = 0.5*(a+b), ac = 0.5*(a+c);\n    float m1 = (a.x-b.x)/(b.y-a.y), m2 = (a.x-c.x)/(c.y-a.y);\n    float b1 = ab.y-m1*ab.x, b2 = ac.y-m2*ac.x;\n    float x = (b1-b2)/(m2-m1);\n    vec2 m = vec2(x,m1*x+b1);\n    if (length(m)>0.) return m;\n    return vec2(0);\n}\n\n// Triangle\nfloat T(vec2 U, vec2 a, vec2 aa, vec2 aaa) {\n    vec2 m = cc(a,aa,aaa);\n    float v = length(a-m), w = length(U-m);\n    return w;\n}\n\nbool inside(vec2 m, vec2 a, vec2 b, vec2 c) {\n    float cross1 = (b.x - a.x) * (m.y - a.y) - (b.y - a.y) * (m.x - a.x);\n    float cross2 = (c.x - b.x) * (m.y - b.y) - (c.y - b.y) * (m.x - b.x);\n    float cross3 = (a.x - c.x) * (m.y - c.y) - (a.y - c.y) * (m.x - c.x);\n    \n    bool hasSameSign = (cross1 >= 0.0 && cross2 >= 0.0 && cross3 >= 0.0) ||\n                       (cross1 <= 0.0 && cross2 <= 0.0 && cross3 <= 0.0);\n    \n    return hasSameSign;\n}","name":"Common","description":"","type":"common"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":2,"type":"buffer","id":"4sXGR8","filepath":"/media/previz/buffer02.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// Buffer A\nvec2 F(vec2 a, vec2 b) {\n    vec2 r = b-a;\n    float l = length(r);\n    // Increased spacing between points\n    if (length(a)>1. && length(b)>0. && l>2.) // Changed from l>1. to l>2.\n        return 1e-2*(r/l/l-(a.x/R.x+b.x/R.x)*10.*r/l/l/l); // Reduced force multiplier from 20 to 10\n    return vec2(0);\n}\n\nMain {\n    // Increased spacing in grid\n    if (length(U-(floor(U.xy/20.)*20.+.5))>0.) discard;  // Changed from 10 to 20\n    Q = A(U);\n    vec2 f = vec2(0);\n    \n    // Increased neighborhood search range\n    for (float x = -3.; x<=3.; x++)  // Changed from ±2 to ±3\n    for (float y = -3.; y<=3.; y++) \n    {\n        vec4 _b = B(Q.xy+vec2(x,y));\n        vec4 _c = C(Q.xy+vec2(x,y));\n        vec4 _q1 = A(_b.xy);\n        vec4 _q2 = A(_c.xy);\n        f += F(_q1.xy,_q2.xy);\n    }\n    \n    Q.zw += f;\n    Q.xy += f + Q.zw;\n    \n    if (iFrame < 1) {\n        // Initialize points with larger spacing\n        Q.xy = (floor(U.xy/20.)*20.);  // Changed from 10 to 20\n        Q.zw = vec2(0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"outputs":[{"channel":0,"id":"XsXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"Main {\n    Q = B(U);\n    vec4 b = B(U);\n    vec4 q1 = A(b.xy);\n    vec4 q2 = A(Q.xy);\n    \n    for (float x = -2.; x<=2.; x++)\n    for (float y = -2.; y<=2.; y++) {\n        vec4 _Q = B(U+vec2(x,y));\n        vec4 _b = B(U+vec2(x,y));\n        vec4 _q1 = A(_b.xy);\n        vec4 _q2 = A(_Q.xy);\n        \n        if (length(q1.xy-q2.xy)==0. ||\n            P(U,q1.xy,q2.xy) > P(U,q1.xy,_q2.xy) ) {\n            q2 = _q2;\n            Q = _Q;\n        }\n        \n        if (length(q1.xy-q2.xy)==0. ||\n            P(U,q1.xy,q2.xy) > P(U,q1.xy,_q1.xy) ) {\n            q2 = _q1;\n            Q = _b;\n        }\n    }\n    \n    if (iFrame < 1) {\n        Q.xy = U;\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"outputs":[{"channel":0,"id":"4sXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":2,"type":"buffer","id":"4sXGR8","filepath":"/media/previz/buffer02.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// Buffer D\nMain {\n    Q = D(U);\n    vec4 b = B(U);\n    vec4 c = C(U);\n    vec4 q1 = A(b.xy);\n    vec4 q2 = A(c.xy);\n    vec4 q3 = A(Q.xy);\n    \n    for (float x = -2.; x<=2.; x++)\n    for (float y = -2.; y<=2.; y++) {\n        vec4 _Q = D(U+vec2(x,y));\n        vec4 _b = B(U+vec2(x,y));\n        vec4 _c = C(U+vec2(x,y));\n        vec4 _q1 = A(_b.xy);\n        vec4 _q2 = A(_c.xy);\n        vec4 _q3 = A(_Q.xy);\n        \n        if (length(q1.xy-q3.xy)==0. ||\n            length(q2.xy-q3.xy)==0. ||\n            T(U,q1.xy,q2.xy,q3.xy) > T(U,q1.xy,q2.xy,_q3.xy) ) {\n            q3 = _q3;\n            Q = _Q;\n        }\n        \n        if (length(q1.xy-q3.xy)==0. ||\n            length(q2.xy-q3.xy)==0. ||\n            T(U,q1.xy,q2.xy,q3.xy) > T(U,q1.xy,q2.xy,_q2.xy) ) {\n            q3 = _q2;\n            Q = _c;\n        }\n        \n        if (length(q1.xy-q3.xy)==0. ||\n            length(q2.xy-q3.xy)==0. ||\n            T(U,q1.xy,q2.xy,q3.xy) > T(U,q1.xy,q2.xy,_q1.xy) ) {\n            q3 = _q1;\n            Q = _b;\n        }\n    }\n    \n    if (iFrame < 1) {\n        Q.xy = U;\n    }\n}","name":"Buffer C","description":"","type":"buffer"},{"outputs":[{"channel":0,"id":"XdfGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":2,"type":"buffer","id":"4sXGR8","filepath":"/media/previz/buffer02.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":3,"type":"buffer","id":"XdfGR8","filepath":"/media/previz/buffer03.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// Buffer D: Find third closest for triangle formation\nMain {\n    Q = D(U);\n    vec4 b = B(U);\n    vec4 c = C(U);\n    vec4 q1 = A(b.xy);\n    vec4 q2 = A(c.xy);\n    vec4 q3 = A(Q.xy);\n    \n    for (float x = -2.; x <= 2.; x++)\n    for (float y = -2.; y <= 2.; y++) {\n        vec4 _Q = D(U+vec2(x,y));\n        vec4 _q = A(_Q.xy);\n        \n        if (_Q.xy != b.xy && _Q.xy != c.xy && length(U-_q.xy) < length(U-q3.xy)) {\n            q3 = _q;\n            Q = _Q;\n        }\n    }\n    \n    if (iFrame < 1) Q.xy = U;\n}","name":"Buffer D","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"4cGBWW","date":"1734027417","viewed":32,"name":"CMB - Acute Angles Voronoi","username":"Chimel","description":"Acute angles coloring Voronoi cells:\n• acute angles are white.\n• Based on N° of interior acute angles (1, 2, 3) the Voro cells are yellow to orange.\n• Blue Voro cells have no acute angles.\n\nMixed with Wyatt's Voronoi points sim to scale it up!","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["voronoi","acute"],"hasliked":0,"parentid":"","parentname":""}}