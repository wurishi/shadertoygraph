{"ver":"0.1","info":{"id":"DlyGRh","date":"1683498668","viewed":95,"name":"Rendering_Exp","username":"Gvskumar","description":"rengering the world with raymarcing technique","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Signed distance fields\n//float mapSphere( vec3 p)\n//{    \n  //  return length(p) - 0.225; // Just spheres.\n//}\n\nuniform sampler2D tex; // Texture to use\n\nfloat mapSphere(vec3 p)\n{\n    float distance = length(p) - 0.225; // Distance to sphere\n    vec2 uv = vec2(distance, 0.5); // Map distance to normalized texture coordinate\n    vec4 texColor = texture(tex, uv); // Look up color value in texture\n    float texValue = (texColor.r + texColor.g + texColor.b) / 3.0; // Convert color to grayscale value\n    float textureScale = 1.0; // Scale factor for texture\n    float texDist = (distance + textureScale * texValue) * 0.5; // Combine distance and texture\n    return texDist;\n}\n\n\nfloat mapCube(vec3 p)\n{\n    float distance = max(p.x, max(p.y, p.z)) - 0.25 + dot(p, p) * 0.5; // Distance to cube\n    vec2 uv = vec2(p.x, p.y); // Map x and y coordinates to normalized texture coordinates\n    vec4 texColor = texture(tex, uv); // Look up color value in texture\n    float texValue = (texColor.r + texColor.g + texColor.b) / 3.0; // Convert color to grayscale value\n    float textureScale = 5.0; // Scale factor for texture\n    float texDist = (distance + textureScale * texValue) * 0.5; // Combine distance and texture\n    return texDist;\n}\n\nfloat myTorus(vec3 p, float r, float t) {\n    vec2 q = vec2(length(p.xz) - r, p.y);\n    return length(q) - t;\n}\n#define FAR 30.\n\n// Returns the signed distance to the nearest surface from the given point.\nfloat map(vec3 p)\n{\n    \n    \n   // Random displacement applied to the input point.\n    float n = sin(dot(floor(p), vec3(27, 113, 57)));\n    vec3 rnd = fract(vec3(2097152, 262144, 32768)*n)*.16 - .08;\n    p = fract(p + rnd) - .5;\n    \n    // Map to the surface of the sphere and cube, and blend between them using a sine wave.\n    p = abs(p); \n    float c1 = mapSphere(p);\n    float c2 = mapCube(p);\n    float majorRadius = 0.2;\n    float tubeRadius = 0.09;\n    float c3 = myTorus(p, majorRadius, tubeRadius);\n    float cf = sin(iTime)*0.5+0.5;\n    //return mix(c2,c1,cf);\n    return mix(mix(c3,c2,cf),mix(c2,c1,cf),cf);\n}\n\n// Performs ray marching to trace the path of a ray through the scene.\nfloat trace(vec3 ro, vec3 rd)\n{\n    float t = 0., d;\n    \n    // Iterate until the maximum number of steps is reached, or until the distance to the nearest surface is below a threshold.\n    for (int i = 0; i < 96; i++){\n        d = map(ro + rd*t);\n        if(abs(d) < .001 || t > FAR) break;        \n        t += d * .75;\n    }\n    \n    return t;\n}\n\n// Similar to trace, but uses a smaller step size for more accuracy when calculating reflections.\nfloat traceRef(vec3 ro, vec3 rd)\n{   \n    float t = 0., d;\n    \n    for (int i = 0; i < 48; i++){\n        d = map(ro + rd*t);\n        if(abs(d) < .002 || t > FAR) break;\n        t += d;\n    }\n    \n    return t;\n}\n\n\nfloat softShadow(vec3 ro, vec3 lp, float k){\n    // Define maximum number of iterations for shadow rays.\n    const int maxIterationsShad = 24; \n    // Define step distance between shadow rays.\n    float stepDist = max(length(lp - ro) / float(maxIterationsShad), 0.001);\n    // Initialize variables for distance and shadow factor.\n    float dist = 0.002;\n    float shade = 1.0;\n    // Normalize direction ray.\n    vec3 rd = normalize(lp - ro);\n    // Loop over shadow rays.\n    for (int i = 0; i < maxIterationsShad; i++) {\n        // Calculate distance to closest surface along the shadow ray.\n        float h = map(ro + rd * dist);\n        // Update shadow factor based on distance and shadow bias.\n        shade = min(shade, smoothstep(0.0, 1.0, k * h / dist));\n        // Update distance to next shadow ray based on distance to closest surface.\n        dist += clamp(h, 0.02, 0.25);\n        // Break loop if distance to closest surface is less than zero or greater than the distance to the light source.\n        if (h < 0.0 || dist > length(lp - ro)) {\n            break;\n        }\n    }\n    // Add bias to shadow factor and clamp between 0 and 1.\n    return min(max(shade, 0.0) + 0.25, 1.0); \n}\n\nvec3 getNormal(in vec3 p) {\n    const vec2 e = vec2(.001, 0);\n    float dx = map(p + e.xyy) - map(p - e.xyy);\n    float dy = map(p + e.yxy) - map(p - e.yxy);\n    float dz = map(p + e.yyx) - map(p - e.yyx);\n    return normalize(vec3(dx, dy, dz));\n}\n\nvec3 getObjectColor(vec3 p){\n    \n    // \"floor(p)\" is analogous to a unique ID - based on position.\n    vec3 ip = floor(p);\n    \n    // Unique random cell number.\n    float rnd = fract(sin(dot(ip, vec3(27.17, 112.61, 57.53)))*43758.5453);\n    \n    // Color up the objects in a cubic checkered arrangement using a subtle version\n    // of IQ's palette formula.\n    vec3 col;\n    \n    if (fract(dot(ip, vec3(.5))) > .001) {\n        col = vec3(1., 1., 0.); // skyblue\n    } else {\n        col = vec3(1.0, 0.7, 0.9); // pink\n    }\n    \n    // Reverse the RGB channels on some of the objects, for a bit of variance.\n    if(fract(rnd*1183.5437 + .42)>.65) col = col.zyx;\n    \n    return col;\n    \n}\n\nvec3 doColor(in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, float t){\n    \n    // Calculate the light direction vector and its distance from the surface.\n    vec3 ld = lp - sp;\n    float lDist = max(length(ld), .001);\n    \n    // Normalize the light direction vector.\n    ld /= lDist;\n    \n    // Calculate the attenuation factor based on the light distance.\n    float atten = 1. / (1. + lDist*.2 + lDist*lDist*.1);\n    \n    // Calculate the diffuse term.\n    float diff = max(dot(sn, ld), 0.);\n    \n    // Calculate the specular term.\n    float spec = pow(max(dot(reflect(-ld, sn), -rd), 0.), 8.);\n    \n    // Get the color of the object at the current position.\n    vec3 objCol = getObjectColor(sp);\n    \n    // Combine the diffuse and specular terms to produce the final scene color.\n    vec3 sceneCol = (objCol*(diff + .15) + vec3(1., .6, .2)*spec*2.)*atten;\n    \n    // Calculate the fog factor based on the distance from the camera.\n    float fogF = smoothstep(0., .95, t/FAR);\n    \n    // Apply the background fog to the scene color.\n    sceneCol = mix(sceneCol, vec3(0), fogF); \n\n    // Return the final scene color.\n    return sceneCol;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5) / iResolution.y;\n\n    vec3 rd = normalize(vec3(uv, 1));\n    \n    float cs = cos(iTime * .10), si = sin(iTime * .10);\n    rd.xy = mat2(cs, si, -si, cs)*rd.xy;\n    rd.xz = mat2(cs, si, -si, cs)*rd.xz;\n    \n\n    vec3 ro = vec3(0, 0, iTime*1.5);\n    \n    vec3 lp = ro + vec3(0, 1, -.5);\n    \n    float t = trace(ro, rd);\n    \n    ro += rd*t;\n\n    vec3 sn = getNormal(ro);\n    \n    vec3 sceneColor = doColor(ro, rd, sn, lp, t);\n    \n    float sh = softShadow(ro +  sn*.0015, lp, 16.);\n    \n    rd = reflect(rd, sn);\n    \n    t = traceRef(ro +  sn*.003, rd);\n\n    ro += rd*t;\n   \n    sn = getNormal(ro);\n    \n    sceneColor += doColor(ro, rd, sn, lp, t)*.35;\n    // Other combinations... depending what you're trying to achieve.\n    //sceneColor = sceneColor*.7 + doColor(ro, rd, sn, lp, t)*.5;\n    \n    sceneColor *= sh;\n    \n    \n\tfragColor = vec4(sqrt(clamp(sceneColor, 0., 1.)), 1);\n}","name":"Image","description":"","type":"image"}]}