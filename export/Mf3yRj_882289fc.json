{"ver":"0.1","info":{"id":"Mf3yRj","date":"1730867608","viewed":45,"name":"Pixelated ball","username":"RobertBanks","description":"Pixel ball","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sphere","ball","learning"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005;\nconst float PI = 3.14159265;\n\nfloat sdSphere(vec3 p)\n{\n  float T = .5*cos(iTime+p.z)+.5;\n  float n = 100.*iMouse.x/iResolution.x+5.;\n  float X = atan(p.z,p.x);\n  float Y = atan(length(p.xz),p.y);\n  float A = cos(X-(2.*PI/n)*floor(n*X/(2.*PI))-(PI/n));\n  float B = cos(Y-(2.*PI/n)*floor(n*Y/(2.*PI))-(PI/n));\n  return (length(p)-2./(T*(A+B)+(1.-T)*2.))/5.;\n}\n\nfloat sdFloor(vec3 p) {\n  return p.y + 2.;\n}\n\nfloat scene(vec3 p) {\n  float co = min(sdSphere(p), sdFloor(p));\n  return co;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  float d; // distance ray has travelled\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    d = scene(p);\n    depth += d;\n    if (d < PRECISION || depth > MAX_DIST) break;\n  }\n\n  d = depth;\n\n  return d;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * scene(p + e.xyy) +\n      e.yyx * scene(p + e.yyx) +\n      e.yxy * scene(p + e.yxy) +\n      e.xxx * scene(p + e.xxx));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec3 backgroundColor = vec3(0);\n\n  vec3 col = vec3(0);\n  vec3 ro = vec3(0, 0, 4); // ray origin that represents camera position\n  vec3 rd = normalize(vec3(uv, -1)); // ray direction\n\n  float sd = rayMarch(ro, rd); // signed distance value to closest object\n\n  if (sd > MAX_DIST) {\n    col = backgroundColor; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * sd; // point discovered from ray marching\n    vec3 normal = calcNormal(p); // surface normal\n\n    vec3 lightPosition = vec3(3.*cos(iTime), 2, 4.);\n    vec3 lightDirection = normalize(lightPosition - p);\n\n    float dif = clamp(dot(normal, lightDirection), 0., 1.); // diffuse reflection clamped between zero and one\n\n    vec3 newRayOrigin = p + normal * PRECISION * 2.;\n    float shadowRayLength = rayMarch(newRayOrigin, lightDirection);\n    if (shadowRayLength < length(lightPosition - newRayOrigin)) dif *= .4;\n\n    col = vec3(dif);\n  }\n\n  fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}