{"ver":"0.1","info":{"id":"MXcGz4","date":"1716337677","viewed":122,"name":"Slowest Ray Tracing Engine","username":"zubairali","description":"...............","likes":2,"published":1,"flags":32,"usePreview":1,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //seed+=uint(iTime*278849.0);\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 pixel = texture(iChannel0,uv);\n\n\n    fragColor = pixel;\n    \n    //fragColor = vec4(CalculateRayCollision(ray).material.color,1);\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n\nconst int MaxBounceCount=10;\n//////////////////////////////////////////////////////////////////////\nuint seed = 0u;\nvoid hash(){\n    seed ^= 2747636419u;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n}\nfloat random(){\n    hash();\n    return float(seed)/4294967295.0;\n}\n\n/////////////////////////////////////////////////////////////////////\n\n\n////////////ENVIRONMENT////////////////////\n\n//vec3 SkyColorHorizon = vec3(0.57,0.69,0.83);\nvec3 SkyColorHorizon = vec3(0.8);\n\nvec3 SkyColorZenith = vec3(0.57,0.69,0.83);\nvec3 GroundColor = vec3(0.65, 0.55, 0.47);\n\nfloat SunFocus = 0.1;\nfloat SunIntensity =0.1;\nvec3 SunLightDirection = vec3(1,0,0);\n\n/////////////////////////////////////////////\n\n\nfloat RandomValueNormalDistribution()\n{\n    float theta = 2.0*3.1415926*random();\n    float rho = sqrt(-2.0*log(random()));\n    return rho * cos(theta);\n}\n\nvec3 RandomDirection(){\n    float x = RandomValueNormalDistribution();\n    float y = RandomValueNormalDistribution();\n    float z = RandomValueNormalDistribution();\n    return normalize(vec3(x,y,z));\n\n}\n\nvec3 RandomHemisphereDirection(vec3 normal){\n    vec3 dir = RandomDirection();\n    return dir * sign(dot(normal,dir));\n}\n\nstruct RayTracingMaterial{\n    vec3 color;\n    vec3 emissionColor;\n    float emissionStrength;\n    float smoothness;\n    float specularityProbabity;\n}  DefaultRayTracingMaterial ;\n\n#define INIT_RayTracingMaterial(X) DefaultRayTracingMaterial X = {vec3(1),vec3(0),0.0,0.0,0.0}\n\nstruct Sphere{\n    vec3 position;\n    float radius;\n    RayTracingMaterial material;\n};\n\nstruct Triangle {\n    vec3 posA;\n    vec3 posB;\n    vec3 posC;\n    vec3 normalA;\n    vec3 normalB;\n    vec3 normalC;\n\n    RayTracingMaterial material;\n};\n\nstruct Ray{\n    vec3 origin;\n    vec3 dir;\n};\n\nstruct HitInfo{\n    bool didHit;\n    float dst;\n    vec3 hitPoint;\n    vec3 normal;\n    RayTracingMaterial material;\n};\n\n///*\nSphere spheres[]= Sphere[6](\n\n   \n    Sphere(vec3(100,100,500),100.0,RayTracingMaterial(vec3(1),vec3(0,0,0),0.0,1.0,1.0)),\n    Sphere(vec3(300,100,500),100.0,RayTracingMaterial(vec3(1,1,1),vec3(0,0,0),0.0,1.0,1.0)),\n    Sphere(vec3(400,-5000,500),5000.0,RayTracingMaterial(vec3(1),vec3(0),0.0,0.0,0.0)),\n    Sphere(vec3(600,100,500),100.0,RayTracingMaterial(vec3(0,0,1),vec3(0,0,0),0.0,0.1,0.0)),\n    Sphere(vec3(400,225,500),800.0,RayTracingMaterial(vec3(1,1,1),vec3(0,0,0),0.0,0.0,0.0)),\n        Sphere(vec3(400,1000,500),600.0,RayTracingMaterial(vec3(1,1,1),vec3(1),1.0,0.0,0.0))\n\n\n\n);\n\nvec3 p1=vec3(100,40,30);\n/*\nTriangle triangles[] = Triangle[1] (\n    Triangle(vec3(100,40,30),vec3(300,40,100),vec3(500,40,20),vec3(0,1,0),vec3(0,1,0),vec3(0,1,0),RayTracingMaterial(vec3(1,0,0),vec3(1,1,1),5.0,0.0,0.0))\n\n);\n*/\n\nconst int numOfCubes=7;\nfloat indexx = 0.0;\nTriangle triangles[numOfCubes*12];\n\nvoid createCube(vec3 min, vec3 max, RayTracingMaterial material) {\n\n    // Define the 8 vertices of the cube\n    vec3 v0 = vec3(min.x, min.y, min.z);\n    vec3 v1 = vec3(max.x, min.y, min.z);\n    vec3 v2 = vec3(max.x, max.y, min.z);\n    vec3 v3 = vec3(min.x, max.y, min.z);\n    vec3 v4 = vec3(min.x, min.y, max.z);\n    vec3 v5 = vec3(max.x, min.y, max.z);\n    vec3 v6 = vec3(max.x, max.y, max.z);\n    vec3 v7 = vec3(min.x, max.y, max.z);\n\n    // Define normals for each face of the cube\n    vec3 nx = vec3(-1, 0, 0);\n    vec3 px = vec3(1, 0, 0);\n    vec3 ny = vec3(0, -1, 0);\n    vec3 py = vec3(0, 1, 0);\n    vec3 nz = vec3(0, 0, -1);\n    vec3 pz = vec3(0, 0, 1);\n\n    // Front face (z = max.z)\n    triangles[int(indexx)+0] = Triangle(v4, v5, v6, pz, pz, pz, material);\n    triangles[int(indexx)+1] = Triangle(v4, v6, v7, pz, pz, pz, material);\n\n    // Back face (z = min.z)\n    triangles[int(indexx)+2] = Triangle(v0, v3, v2, nz, nz, nz, material);\n    triangles[int(indexx)+3] = Triangle(v0, v2, v1, nz, nz, nz, material);\n\n    // Left face (x = min.x)\n    triangles[int(indexx)+4] = Triangle(v0, v4, v7, nx, nx, nx, material);\n    triangles[int(indexx)+5] = Triangle(v0, v7, v3, nx, nx, nx, material);\n\n    // Right face (x = max.x)\n    triangles[int(indexx)+6] = Triangle(v1, v2, v6, px, px, px, material);\n    triangles[int(indexx)+7] = Triangle(v1, v6, v5, px, px, px, material);\n\n    // Bottom face (y = min.y)\n    triangles[int(indexx)+8] = Triangle(v0, v1, v5, ny, ny, ny, material);\n    triangles[int(indexx)+9] = Triangle(v0, v5, v4, ny, ny, ny, material);\n\n    // Top face (y = max.y)\n    triangles[int(indexx)+10] = Triangle(v3, v7, v6, py, py, py, material);\n    triangles[int(indexx)+11] = Triangle(v3, v6, v2, py, py, py, material);\n    indexx+=12.0;\n    if (indexx>=float(numOfCubes*12)){\n        indexx=0.0;\n    }\n    \n}\n\n//*/\n/*\nSphere spheres[]= Sphere[1](Sphere(vec3(100,1000,500),400.0,RayTracingMaterial(vec3(0.8,0,0),vec3(1,1,1),50.0,0.0,0.0))\n);\n*/\n\n\n\n\nvec3 GetEnvironmentLight(Ray ray){\n    \n    float skyGradientT = pow(smoothstep(0.0,0.4,ray.dir.y),0.35);\n    vec3 skyGradient = mix(SkyColorHorizon,SkyColorZenith,skyGradientT);\n    float sun = pow(max(0.0,dot(ray.dir,-SunLightDirection)),SunFocus)*SunIntensity;\n    \n    float groundToSkyT = smoothstep(-0.01,0.0,ray.dir.y);\n    float sunMask = float(groundToSkyT>=1.0);\n    return mix(GroundColor,skyGradient,groundToSkyT) + sun * sunMask;\n    \n}\n\n\nHitInfo RaySphere(Ray ray,Sphere sphere){\n    HitInfo hitInfo = HitInfo(false,0.0,vec3(0,0,0),vec3(0,0,0),RayTracingMaterial(vec3(0),vec3(0,0,0),0.0,0.0,0.0));\n    vec3 offsetRayOrigin = ray.origin - sphere.position;\n    \n    float a = dot(ray.dir,ray.dir);\n    float b = 2.0 * dot(offsetRayOrigin,ray.dir);\n    float c = dot(offsetRayOrigin,offsetRayOrigin) - sphere.radius*sphere.radius;\n    \n    float discriminant = b*b-4.0*a*c;\n    \n    if (discriminant>=0.0){\n    \n        float dst = (-b - sqrt(discriminant))/(2.0*a);\n        \n        if (dst>=0.0){\n            hitInfo.didHit = true;\n            hitInfo.dst = dst;\n            hitInfo.hitPoint = ray.origin + ray.dir * dst;\n            hitInfo.normal = normalize(hitInfo.hitPoint - sphere.position);\n        }\n    }\n    \n    \n    \n    return hitInfo;\n\n}\n\nHitInfo RayTriangle( Ray ray,  Triangle tri) \n{ \n    vec3 edgeAB = tri.posB - tri.posA;\n    vec3 edgeAC = tri.posC - tri.posA;\n    vec3 normalVector = cross(edgeAB, edgeAC);\n    \n    float det = dot(ray.dir, normalVector);\n    if (abs(det) < 1e-6) {\n        // Ray is parallel to the triangle plane\n        return HitInfo(false,0.0, vec3(0), vec3(0),RayTracingMaterial(vec3(0),vec3(0,0,0),0.0,0.0,0.0));\n    }\n    \n    float invDet = 1.0 / det;\n    vec3 ao = ray.origin - tri.posA;\n    float u = dot(ray.dir, cross(ao, edgeAC)) * invDet;\n    if (u < 0.0 || u > 1.0) {\n        // Intersection point is outside of the triangle\n                return HitInfo(false,0.0, vec3(0), vec3(0),RayTracingMaterial(vec3(0),vec3(0,0,0),0.0,0.0,0.0));\n    }\n\n    float v = dot(ray.dir, cross(edgeAB, ao)) * invDet;\n    if (v < 0.0 || u + v > 1.0) {\n        // Intersection point is outside of the triangle\n                return HitInfo(false,0.0, vec3(0), vec3(0),RayTracingMaterial(vec3(0),vec3(0,0,0),0.0,0.0,0.0));\n    }\n    \n    float dst = dot(ao, normalVector) * invDet;\n    if (dst < 0.0) {\n        // Intersection point is behind the ray origin\n                return HitInfo(false,0.0, vec3(0), vec3(0),RayTracingMaterial(vec3(0),vec3(0,0,0),0.0,0.0,0.0));\n    }\n\n    // Calculate the barycentric coordinates\n    float w = 1.0 - u - v;\n\n    // Compute the intersection point and normal\n    vec3 hitPoint = ray.origin + ray.dir * dst;\n    vec3 interpolatedNormal = normalize(tri.normalA * w + tri.normalB * u + tri.normalC * v);\n    return HitInfo(true,dst, hitPoint, interpolatedNormal,tri.material);\n}\n/*\nHitInfo RayTriangle(Ray ray, Triangle tri) \n{ \n    vec3 edgeAB = tri.posB - tri.posA;\n    vec3 edgeAC = tri.posC - tri.posA;\n    vec3 normalVector = cross (edgeAB, edgeAC);\n    vec3 ao = ray.origin - tri.posA;\n    vec3 dao = cross(ao, ray.dir);\n    float determinantt = -dot(ray.dir, normalVector);\n    float invDet = 1.0 / determinantt;\n    // Calculate dst to triangle & barycentric coordinates of intersection point \n    float dst = dot(ao, normalVector) * invDet;\n    float u = dot(edgeAC, dao) * invDet;\n    float v = -dot(edgeAB, dao) * invDet;\n    float w = 1.0 - u - v;\n    HitInfo hitInfo;\n    hitInfo.didHit = determinantt >= 0.000001 && dst >= 0.0 && u >= 0.0 && v >= 0.0 && w >= 0.0;\n    hitInfo.hitPoint = ray.origin+ray.dir * dst;\n    hitInfo.normal = normalize(tri.normalA * w + tri.normalB * u + tri.normalC * v);\n    hitInfo.dst = dst;\n    return hitInfo; \n}*/\n\n\nHitInfo CalculateRayCollision(Ray ray){\n    \n    HitInfo closestHit = HitInfo(false,0.0,vec3(0,0,0),vec3(0,0,0),RayTracingMaterial(vec3(0),vec3(0),0.0,0.0,0.0));\n\n\n    closestHit.dst =  intBitsToFloat(2139095039);\n    \n    for (int i = 0; i < spheres.length(); i++){\n    \n    \n        Sphere sphere = spheres[i];\n        HitInfo hitInfo = RaySphere(ray,sphere);\n        \n        if (hitInfo.didHit && hitInfo.dst < closestHit.dst){\n        \n        closestHit = hitInfo;\n        closestHit.material = sphere.material;\n        \n        }\n    \n    }\n    \n    for (int i = 0; i < triangles.length(); i++){\n    \n    \n        Triangle triangle = triangles[i];\n        HitInfo hitInfo = RayTriangle(ray,triangle);\n        \n        if (hitInfo.didHit && hitInfo.dst < closestHit.dst){\n        \n        closestHit = hitInfo;\n        closestHit.material = triangle.material;\n        \n        }\n    \n    }\n    \n    \n    \n    return closestHit;\n\n}\n\nvec3 Trace(Ray ray){\n    \n\n    vec3 incomingLight = vec3(0);\n    vec3 rayColor = vec3(1);\n    for (int i=0;i <= MaxBounceCount; i++){\n        HitInfo hitInfo = CalculateRayCollision(ray);\n        RayTracingMaterial material = hitInfo.material;\n        if (hitInfo.didHit){\n        \n            ray.origin = hitInfo.hitPoint;\n            vec3 diffuseDir = normalize(hitInfo.normal + RandomDirection());\n            vec3 specularDir = reflect(ray.dir,hitInfo.normal);\n            \n            bool isSpecularBounce = material.specularityProbabity >= random();\n            ray.dir = mix(diffuseDir,specularDir,material.smoothness * float(isSpecularBounce));\n            \n            vec3 emittedLight = material.emissionColor*material.emissionStrength;\n            incomingLight += emittedLight * rayColor;\n            rayColor *= material.color;\n        }\n        else{\n            //incomingLight += GetEnvironmentLight(ray)*rayColor;\n            break;\n        }\n    \n    }\n    return incomingLight;\n    \n    \n}\n\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec2 Screen = vec2(800,450);\nvec3 cameraPosition = vec3(400,225,-800);\nvec3 cameraRotation = vec3(0,0,0);\nfloat cameraFov = 10.0;\nfloat cameraNearClipPlane = 5.0;\nint NumRayPerPixel = 20;\nvoid initRandomGenerator(vec2 fragCoord){\n    seed = uint(fragCoord.y*iResolution.x + fragCoord.x)+uint(iFrame)*uint(iResolution.x)*uint(iResolution.y);\n}\nbool notcreated=true;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n    {\n    if (notcreated){\n    createCube(vec3(-200,0,-50),vec3(1000,10,800),RayTracingMaterial(vec3(0.7,0.1,0.1),vec3(0,0,0),0.0,1.0,0.0));\n    createCube(vec3(-200,10,-50),vec3(0,1000,800),RayTracingMaterial(vec3(1),vec3(0.8,0,0),0.0,1.0,0.0));\n    createCube(vec3(800,10,-50),vec3(1000,1000,800),RayTracingMaterial(vec3(1),vec3(0,0.8,0),0.0,1.0,0.0));\n    createCube(vec3(-200,800,-50),vec3(1000,1000,800),RayTracingMaterial(vec3(1),vec3(0,0,0.8),0.0,1.0,0.0));\n    createCube(vec3(-200,0,800),vec3(1000,1000,1000),RayTracingMaterial(vec3(1),vec3(0,0,0),0.0,1.0,0.0));\n    createCube(vec3(-200,0,-50),vec3(1000,1000,-10),RayTracingMaterial(vec3(1),vec3(0,0,0),0.0,1.0,0.0));\n\n    createCube(vec3(300,750,300),vec3(600,790,500),RayTracingMaterial(vec3(1),vec3(1,1,1),2.0,0.0,0.0));\n    notcreated=false;\n    }\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    initRandomGenerator(fragCoord);\n    //seed+=uint(iTime*278849.0);\n    //vec2 uv = fragCoord/iResolution.xy;\n    vec3 rayPosition = vec3(uv.x*Screen.x,uv.y*Screen.y,0);\n    vec3 direction=(rayPosition-cameraPosition);\n    Ray ray = Ray(rayPosition,direction);\n    \n    vec3 totalIncomingLight = vec3(0);\n    \n    for (int rayIndex=0; rayIndex<NumRayPerPixel;rayIndex++){\n        totalIncomingLight += Trace(ray);\n    }\n    \n    \n    vec3 pixelCol = totalIncomingLight / float(NumRayPerPixel);\n    vec4 oldRender = texture(iChannel0,uv);\n    vec4 newRender = vec4(pixelCol,1.0);\n    \n    float weight = 1.0/(float(iFrame) +1.0);\n    vec4 avarage = oldRender * (1.0-weight) + newRender * weight;\n    fragColor = avarage;\n}","name":"Buffer A","description":"","type":"buffer"}]}