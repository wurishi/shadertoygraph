{"ver":"0.1","info":{"id":"Nsy3D1","date":"1633871996","viewed":516,"name":"Voropoints 4","username":"spalmer","description":"fork of fork of [url]https://shadertoy.com/view/WdXcRN[/url], this time simplified using only 4-neighbor lists.\nvoronoi particle tracking info: [url]https://shadertoyunofficial.wordpress.com/2021/03/09/advanced-tricks[/url]","likes":28,"published":1,"flags":32,"usePreview":1,"tags":["voronoi","particles","neighbors"],"hasliked":0,"parentid":"WsScW3","parentname":"Voropoints 3"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// used this toy to debug some stuff about Voropoints 3\n// even simpler fork of https://shadertoy.com/view/WsScW3\n// this time with only 4 nearest neighbor tracking\n// fork simplifying https://shadertoy.com/view/WdXcRN\n// see also https://shadertoy.com/view/WltSz7\n// idea goes all the way back to stb's https://shadertoy.com/view/4sK3WK\n\n// use of only 4 neighbors per cell should be fine so long\n// as the cells are fairly small relative to the particles\n// but necessitates integrating neighbor lists of nearby cells\n\n#define BufferA iChannel0\n#define BufASize ivec2(iChannelResolution[0].xy)\n\n// beware dangling else issues; use {} just in case, requires do to allow trailing semicolon\n#define DR(_od, _oc, _oi, _nd, _nc, _ni) \\\ndo { float _Nd = (_nd); \\\n    if ((_od) <= 0. ? (_Nd <= 0. && (_ni) < (_oi)) : _Nd < (_od)) { \\\n        _od = _Nd; _oc = (_nc); _oi = (_ni); \\\n    } \\\n} while(false)\n    \nvec3 dotcolor(int id)\n{\n\tconst float phi = .5/(sqrt(5.)+1.);\n    ivec2 c = id2coord(id);\n    int i = c.x, j = c.y;\n\treturn sin(\n        vec3(0,2,4)+2.*pi\n               * float(id) / float(totalshapes)\n              ) * .5 + .5;\n} // * phi\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    vec2 R = iResolution.xy\n    , Q = StoQ(p, R)\n//    , m = StoQ(iMouse.xy, R)\n//    , mo = iMouse.z < 0. ? m : StoQ(iMouse.zw, R)\n    // Q coordinates are -1..1 vertically, -1.778..1.778 horizontally, usually\n    // q coordinates are 0..(boxW,boxH)-1\n    // not centered, not a big deal.  partially due to buffer sizes not being factors of aspect ratio.\n    , q = QtoWorld(Q);\n    ivec2 iq = ivec2(q);\n    float nearest = 9e9; int ni = -1;\n    vec3 col = vec3(1);\n  #if 0\n    // debug the nearby neighbor field as colored lines to the nearest objects\n    ivec4 neighbors;\n    vec4 npack = texelFetch(BufferA, iq, 0);\n    neighbors = unpackNeighbors(npack);\n    for (int i = NPC+IZERO; i-- > 0; ) {\n        int nn = neighbors[i];\n        if (uint(nn) >= uint(totalshapes))\n            continue;\n        ivec2 c = id2coord(nn);\n        Object o = loadObject(BufferA, c);\n        vec3 albedo = dotcolor(nn);\n        //albedo = vec3(abs(cos(iTime*40.)),0,0), ll *= .25; //\n        float ll = .45;\n        float scl = radius*.75; // leave room for lines\n        vec2 co = vec2(iq)+.5 \n        , lo = co + .02 * sin(vec2(.5*pi,0)+2.*pi*float(i)/float(NPC)) // wiggle spread keeps lines from hiding behind one another so much\n        , op = o.p - co;\n        op = co + (length(op) > ll ? ll*normalize(o.p - lo) : op);\n        float ld = dseg(q, op, lo) - .02;\n    //    if (nn == 0 && iq != ivec2(0)) ld = 9e9; // why do I do this to myself?  I hunted this crap for days...\n        float sd; // signed distance to shape from q\n        sd = dshape((q - o.p)/scl) * scl;\n        sd = abs(sd - .25) - .02;\n        sd = min(sd, ld);\n\t\tDR(nearest, col, ni, sd, albedo, nn);\n    }\n  #elif 0\n    // debug the nearby neighbor field as colors\n    col = texelFetch(BufferA, ivec2(q), 0).rgb //texture(BufferA, q / iChannelResolution[0].xy).rgb //\n    \t/ float(totalshapes);\n    nearest = -1.;\n  #elif 1\n    // check neighbors of nearby cells, scan 1 cell away like I do in BufferA\n    // drawing 16 neighbors gets REALLY slow in full-screen\n    // drawing 8 neighbors seems sufficient to eliminate flickering\n    // but is still a little slow in full-screen\n    // drawing less than 8 neighbors occasionally flickers!\n    int ns[NNS], nc;\n    getShapeNeighbors(BufferA, q, -1, IZERO, ns, nc);\n    for (int i = min(8,nc); i-- > 0; ) {\n        int nn = ns[i];\n        ivec2 c = id2coord(nn);\n        Object o = loadObject(BufferA, c);\n        vec3 albedo = dotcolor(nn);\n        float scl = radius,\n        // signed distance to shape from q\n        sd = dshape((q - o.p)/scl) * scl;\n\t\tDR(nearest, col, ni, sd, albedo, nn);\n    }\n  #elif 1\n    // only check the nearest shapes according to the neighbor buffer here\n    // slightly flickers occasionally, not checking enough neighbors for the\n    // size of object vs cell size\n    ivec4 neighbors;\n    vec4 npack = texelFetch(BufferA, iq, 0);\n    neighbors = unpackNeighbors(npack);\n    for (int i = NPC + IZERO; i-- > 0; ) {\n        int nn = neighbors[i];\n        ivec2 c = id2coord(nn);\n        Object o = loadObject(BufferA, c);\n        vec3 albedo = dotcolor(nn);\n        float scl = radius;\n        float sd; // signed distance to shape from q\n        sd = dshape((q - o.p)/scl) * scl;\n\t\tDR(nearest, col, ni, sd, albedo, nn);\n    }\n  #else\n    // brute force draw all shapes; slow.\n    for (int i = totalshapes + IZERO; i-- > 0; ) {\n        ivec2 c = id2coord(i);\n        Object o = loadObject(BufferA, c);\n        vec3 albedo = dotcolor(i);\n        float scl = radius;\n        float sd; // signed distance to shape from q\n        sd = dshape((q - o.p)/scl) * scl;\n\t\tDR(nearest, col, ni, sd, albedo, i);\n    }\n  #endif\n    float cov = clamp(.5 - iResolution.y/float(boxH)*nearest, 0., 1.); //1.; //\n    float checker = float((iq.x^iq.y)&1); //.5; //\n    col = mix(vec3(.47 + .06 * checker), col, cov);\n    if (any(greaterThanEqual(iq, ivec2(boxW, boxH)))) col *= 0.; // out of bounds of grid\n    col = pow(col, vec3(1.0/2.2)); // gamma correct to sRGB\n\to = vec4(col, 1);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define IZERO min(iFrame, 0)\n// \"constant\" uniform prevents loop unrolling\n\n// FIXME compile time is pretty brutal with high totalshapes\n// like 20* gets really bad... idk why,\n// nothing should be bruteforcing over all cells or shapes anymore\n// have it working up to 18* currently!\n// testing w less to see if it fixes the thumbnail issue\n// nope! still busted.  must be either...\n// iChannelResolution[0] != iResolution\n// or something about iTimeDelta perhaps\nconst int boxW = 22*16; //7; //5; //3; //32; //64; //128; //256; //320;\nconst int boxH = 22*9; //4; //3; //2; //18; //36; //72; //144; //180;\nconst float radius = 1.1; //.75; //.4; //.498; //.33; //.5; // of all balls\nconst int shaperows = int(float(boxH) / 2. / radius);\nconst int shapesperrow = int(float(boxW) / 3. / radius);\nconst int NPC = 4; // neighbors per cell\nconst int totalshapes = shapesperrow*shaperows;\nconst ivec2 shapePosVelOffset = ivec2(0,boxH);\nconst float pi = 3.1415927;\n\n\n\n// the shapes go in the space left over after\n// reserving a zone for the playfield nearest-points buffer\n\nconst int\n  rNear    = 0 // basically 1/4 buffer used for voronoi nearest lists, (region 0)\n, rPosVel  = 1 // 1/4 used for the shape locations and velocities (region 1)\n;\n\nivec3 region(ivec2 q)\n{\n    ivec2 b = ivec2(boxW,boxH);\n    bvec2 c = lessThanEqual(b, q);\n    int r = 0;\n    if (c.x) { r += 1; q.x -= boxW; }\n    if (c.y) { r += 2; q.y -= boxH; }\n    if (any(lessThanEqual(b, q))) r += 4; // unused part of buffer\n    return ivec3(q, r);\n}\n\nint subregion(ivec2 q)\n{\n    q %= ivec2(boxW, boxH);\n    return q.y * shapesperrow + q.x;\n}\n\nbool idValid(int i)\n{\n    return uint(i) < uint(totalshapes);\n}\n\nint coord2id(ivec2 c)\n{\n    if (uint(c.x) >= uint(shapesperrow)) return -1; //totalshapes;\n    return c.x + c.y * shapesperrow;\n}\n\nivec2 id2coord(int id)\n{\n    return ivec2(id % shapesperrow, id / shapesperrow);\n}\n\nvec4 packNeighbors(ivec4 n)\n{\n    return vec4(n) + 1e-7;\n//    vec4 packed;\n//    for (int i = NPC; i-- > 0; )\n//        packed[i] = float(n[i]);\n//    return packed;\n}\n\nivec4 unpackNeighbors(vec4 packed)\n{\n    return ivec4(packed);\n//    ivec4 n;\n//    for (int i = NPC; i-- > 0; )\n//        n[i] = int(packed[i]);\n//    return n;\n}\n\n//    const ivec2 sr = ivec2(shapesperrow, shaperows);\n// FIXME r is always (BoxW, BoxH) - in fact that was the very bug I wound up hunting for weeks or more!  argh!\nivec4 loadNeighbors(sampler2D ch, ivec2 q) //, ivec2 r)\n{\n    const ivec2 r = ivec2(boxW, boxH);\n\tq = clamp(q, ivec2(0), r-1);\n\tvec4 np = texelFetch(ch, q, 0);\n    return unpackNeighbors(np);\n}\n\nstruct Object\n{\n    vec2 p;\n    vec2 v;\n};\n//    float r; // rotation in turns\n//    float z; // size,scale - always 1\n//    int k; // kind of shape - always a ball\n//    int _; // nothing, yet\n//    vec4 c; // color\n\nObject invalidObject()\n{\n    return Object(vec2(9e9), vec2(0));\n}\n    \nObject loadObject(sampler2D buf, ivec2 c)\n{\n    if (any(lessThan(uvec2(shapesperrow,shaperows), uvec2(c))))\n        return invalidObject();\n    Object o;\n    vec4 v0 = texelFetch(buf, c + ivec2(boxW,0), 0);\n    o.p = v0.xy; o.v = v0.zw;\n    return o; //Object(v0.xy, v0.zw);\n}\n    //vec4 v1 = texelFetch(buf, c + ivec2(0,boxH), 0);\n    //vec4 v2 = texelFetch(buf, c + ivec2(boxW,boxH), 0);\n    //o.r = v1.x; o.z = v1.y; o.k = int(v1.z);\n    //o.c = v2;\n\nObject loadObject(sampler2D buf, int id)\n{\n// if (!idValid(id)) return Object(vec2(9e9), vec2(0));\n    return loadObject(buf, id2coord(id));\n}\n\n// we could avoid all this division by radius btw.\n\n// signed distance\nfloat dball(vec2 p)\n{\n    return length(p) - 1.;\n}\n\nfloat dseg(vec2 p, vec2 a, vec2 b)\n{\n    p -= a; b -= a;\n    return length(p - b*clamp(dot(p,b)/dot(b,b), 0., 1.));\n}\n\nfloat dshape(vec2 q)\n{\n    return dball(q);\n}\n\n// FIXME why bother with Q at all, just go to world\nvec2 StoQ(vec2 s, vec2 r)\n{\n\treturn (2. * s - r) / r.y;\n}\n// Q is signed, aspect-corrected, -1..1 space (goes past 1 on sides)\n// centers a unit circle in the window.\n// World is 0,0 .. boxW-1,boxH-1 grid\nvec2 QtoWorld(vec2 q)\n{\n    return (q + vec2(1.778,1)) * .5 * float(boxH-0); // main buffer scale, offset\n}\n\n/*\nvoid insert6(inout int ns[6], inout float ds[6], int n, float d)\n{\n    if (!idValid(n)) //uint(n) >= uint(totalshapes))\n        return; // bogus\n    for (int i = 0; i < 6; ++i) //+IZERO\n        if (ns[i] == n)\n            return; // already in list! don't add again\n    for (int i = 0+IZERO; i < 6; ++i) {\n        //if (ns[i] == n) break; //return; // already in list! don't add again\n        if (d >= ds[i]) continue;\n        // push rest down\n        for (int j = 6; --j > i;) {\n            ds[j] = ds[j-1]; \n            ns[j] = ns[j-1];\n        }\n        // and insert here\n        ds[i] = d;\n        ns[i] = n;\n        break;\n    }\n}\n*/\n\n// closest 8 seems to be sufficient to track things without flickering\nconst int NNS = 8; //16; //\n// probably up to the nearest 7 is as many as makes sense in 2D,\n// 8 tops, past that we're wasting our time anyway\n// maybe 12 in 3D? so for 3D you'd want to use 16 probably.\n\nvoid InsertNoDuplicate(inout int ns[NNS], inout int count, int n)\n{\n    if (count >= NNS) //ns.length()) //\n        return; // full\n    if (!idValid(n)) //uint(n) >= uint(totalshapes))\n        return; // bogus\n    for (int i = count/*+IZERO*/; i-- > 0; ) {\n        if (ns[i] == n)\n            return; // duplicate\n    }\n    ns[count++] = n;\n}\n\n// the right way seems to be to iterate over all cells\n// that overlap this shape, and test against all of their nearests\n// so need some nested loop\n// for now just check all the neighbors of our cell 1 unit away\n// first gather a list of all the unique neighbors,\n// then just iterate over the list once.\nvoid getShapeNeighbors(sampler2D ch, vec2 p, int self, int zero, out int ns[NNS], out int nc)\n{\n    nc = zero; //0; // init anti-duplication list\n    ivec2 ip = ivec2(p); //ivec2(floor(p)); //\n    // depends on size of objects vs. size of cell; rn 2 works and 1 doesn't!\n    // 2 still has some weirdly non-physical behaviors on huge stacks, so use 3\n    const int scan = 2; //3; //1; //0; //\n    for (int j = scan+zero; j-- > 0; )\n    for (int i = scan+zero; i-- > 0; ) {\n        ivec4 neighbors = loadNeighbors(ch, ip-1+ivec2(i,j));\n        for (int h = NPC+zero; h-- > 0; ) {\n            int nn = neighbors[h];\n            if (nn == self) continue; // avoid putting self in list            \n            InsertNoDuplicate(ns, nc, nn); // track & skip duplicates\n        }\n    }\n}\n    //nc = min(NNS, totalshapes-1); int j = 0; for (int i = totalshapes; i-- > 0; ) if (i != self) ns[j++] = i; // HACK be very careful not to include ourself!\n    //int ns[6]; float ds[6];\n    //for (int i = 6; i-- > 0; ) ns[i] = -1, ds[i] = 3.4e38;\n//    for (int i = NNS; i-- > 0; ) ns[i] = -1; // unnecessary but why not\n//    for (int j = 5+zero; j-- > 0; )\n//    for (int i = 5+zero; i-- > 0; ) {\n//        ivec4 neighbors = loadNeighbors(ch, ip-2+ivec2(i,j)); //, sr);\n            // yeah but we don't want to have to load them again later!  either cache the relevant data too or change so just eliminates duplicates\n            //float d = distance(po, p);\n            //Insert6(ns, ds, nn, d);    \n\nvoid insertNeighbor(int zero, inout ivec4 ns, inout vec4 ds, int n, float d)\n{\n    if (!idValid(n)) //uint(n) >= uint(totalshapes))\n        return; // bogus\n    for (int i = 0; i < NPC; ++i) \n        if (ns[i] == n)\n            return; // already in list! don't add again\n    for (int i = 0/*zero*/; i < NPC; ++i) {\n        if (d >= ds[i]) continue;\n        // push rest down\n        for (int j = NPC; --j > i;) {\n            ds[j] = ds[j-1]; \n            ns[j] = ns[j-1];\n        }\n        // and insert here\n        ds[i] = d;\n        ns[i] = n;\n        break;\n    }\n}\n    // FIXME don't bother loading and unpacking if new id is already in the list?\n        // insertion sort new id into list based on distance\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define BufferA iChannel0\n\n\n// FIXME naming conventions\nvec2 pstart(ivec2 q) // in world neighbor grid coords\n{\n    return vec2(q * 2 + 1) * 1.02 * radius; // + vec2(7,4);\n}\n\nvec2 world2pstart(ivec2 q)\n{\n    return ((vec2(q) + .5) / radius / 1.02 - 1.) / 2.;\n}\n\n// deduce nearest neighbors at init time\nivec4 cleverInitNeighbors(ivec2 q)\n{\n    const int ts = totalshapes, spr = shapesperrow;\n    vec2 f = world2pstart(q);\n    int sid = coord2id(ivec2(f));\n    ivec4 o = ivec4(sid); // set all 4 to the same neighbor id for now;\n    o += ivec4(-1, 1, -spr, spr); // the 4 immediate neighbors\n    return o; // hey this works pretty well!! nice!\n}\n/* // old \n// bruteforce nearest neighbors at init time, very slow to compile for some reason, would think it would simply execute slowly...\nivec4 bruteForceInitNeighbors(ivec2 q)\n{\n    vec2 p = vec2(q) + .5; // from center of cell\n    vec2 p0 = pstart(ivec2(0));\n    float d0 = 3.4e38; //distance(p, p0); //\n    int i0 = totalshapes; //-1; //0; //\n    vec4 ds = vec4(d0);\n    ivec4 ns = ivec4(i0);\n    for (int j = 0+IZERO; j < shaperows; ++j) {\n\t for (int i = 0+IZERO; i < shapesperrow; ++i) {\n        ivec2 c = ivec2(i,j);\n        vec2 po = pstart(c);\n        int id = coord2id(c);\n        float scl = radius;\n        float sd = dshape((p - po) / scl) * scl; // signed distance to shape from p\n        insertNeighbor(ns, ds, id, sd);\n     }\n    }\n    return ns;\n}*/\n// either way works, doesn't matter\n//    for (int j = IZERO + shaperows; j-- > 0; ) {\n//\t for (int i = IZERO + shapesperrow; i-- > 0; ) {\n    //ns = ivec4(coord2id(q)); // HACK test\n\nbool init(out vec4 o, ivec2 q, ivec3 r)\n{\n    // this HACK seems to fix thumbnail\n    if (iFrame > 2) { //if (iFrame != 0) { //\n        o = texelFetch(BufferA, q, 0);\n        return false;\n    }\n    switch (r.z) {\n        case rNear:\n            //ivec4 ns = bruteForceInitNeighbors(r.xy); // slow compile time\n            ivec4 ns = cleverInitNeighbors(r.xy);\n            //ivec4 ns = ivec4(-1);\n            o = packNeighbors(ns);\n         \tbreak; // they'll mix themselves up as updates occur\n        case rPosVel:\n        \to.xy = pstart(r.xy);\n        \to.x += o.y * .01; // misalign slightly\n        \to.zw = sin(2.*o.xy + o.yx) * 5.25;\n        \tbreak;\n    }\n    return true;\n}\n\n// made more relative so can use same fn for other objects and walls\n// d is actually the distance to overlap along pn, dot product already done by caller\n// relmass is our mass divided by total mass\nbool bounce(inout vec2 p, inout vec2 v, vec2 pn, float d, float relmass)\n{\n    bool r = d < 0.;\n    if (r) {\n        float omrm = (1.-relmass);\n        p -= pn * d * omrm;\n        float nv = dot(pn, v);\n        if (nv < 0.) { // moving closer?\n            const float crest = .96; //.2; // // FIXME gaining energy due to fraction overstep handling; don't be too bouncy!\n            float boing = (1. + crest) * omrm; //1.98; //1.+crest; //\n        \tv -= boing * pn * nv;\n        }\n    }\n    return r;\n}\n\nbool bouncewall(inout vec2 p, inout vec2 v, vec2 pn, float pd)\n{\n    float d = dot(p, pn) - pd;\n    return bounce(p, v, pn, d, 0.);\n}\n\nvoid bounceWalls(inout vec2 p, inout vec2 v, float r)\n{\n    bouncewall(p, v, vec2(0, 1), r);\n    bouncewall(p, v, vec2(-1,0), r-float(boxW));\n    bouncewall(p, v, vec2(1, 0), r);\n    bouncewall(p, v, vec2(0,-1), r-float(boxH));\n}\n\nvoid motion(inout vec4 o, ivec2 q)\n{\n    int id = coord2id(q); // which shape is moving?\n    vec2 p = o.xy, v = o.zw;\n    float dt = clamp(iTimeDelta, 1./144., 1./30.);\n    //dt *= .25; // SLOMO for debugging\n    float r = radius; //texelFetch(BufferA, q + ivec2(0, boxH), 0).y; // obtain Object.z size from quadrant 2 // HACK all objects same size\n    if (iMouse.z > 0.5) {\n        vec2 mb = QtoWorld(StoQ(abs(iMouse.xy), iResolution.xy))\n        , d = mb - p;\n        v += d * exp2(-.06 * dot(d,d)) * dt * 50.; // spring force from mouse to nearby shapes\n    }\n  #if 1\n    // new, integrate prior ball-ball collide\n    vec2 f = vec2(0, -9.9);  // gravity force // TODO * mass\n    v += f * dt;\n    v *= exp2(-.005*dt); // damping\n    p += v * dt;\n    bounceWalls(p, v, r); // collide with walls before neighbors just in case\n  #endif\n    int ns[NNS], nc;\n    getShapeNeighbors(BufferA, p, id, IZERO, ns, nc); // do not include ourself!\n    // collide with neighbors, nearest first\n    for (int i = 0; i < nc; ++i) {\n        int nn = ns[i];\n        Object k = loadObject(BufferA, nn); //id2coord(nn));\n        vec2 po = k.p; float ro = radius; //o.z;\n        vec2 rd = normalize(p - po);\n        float dr = distance(p, po) //dot(p, rd) //\n            - r - ro;\n        const float relvelhack = .9; // try it as 1.!! or... 0.5 ?!?\n        vec2 rv = relvelhack * k.v;\n        v -= rv; // make relative vel\n        bounce(p, v, rd, dr, .5);\n        v += rv;\n    }\n  #if 0\n    bounceWalls(p, v, r); // collide with walls after neighbors just in case got pushed into a wall?\n    // old, integrate after ball-ball collide\n    vec2 f = vec2(0, -9.9);  // gravity force // TODO * mass\n    v += f * dt;\n    v *= exp2(-.005*dt); // damping\n    p += v * dt;\n  #endif\n    bounceWalls(p, v, r); // collide with walls again prior to storage\n    o = vec4(p, v);        \t\n}\n    // should iterate in the correct order (nearest first) - doesn't matter\n     //for (int i = nc; i-- > 0; ) { // nearest last - same problems\n        //if (!idValid(nn)) //uint(nn) >= uint(totalshapes)) //nn == -1) \n        //    continue; // should not be possible for invalid entries to get into the list!\n        //if (nn == id) continue; // don't collide w/ self!  but id should have been removed from the list...\n    // FIXME constantly goes off when page first loaded prior to first click in window!  drat\n//    if (iMouse.w >= 0.)\n//        v += sin(vec2(0,11)+ 40.*iTime)*7. + vec2(0,13); // bump\n\n    // either we must integrate all forward first or none of them.\n    // none is far easier to get to happen!\n    //ivec2 ip = ivec2(floor(p));\n    // probably looks slightly invalid and probably need to draw *prior* positions now...\n    // anyway they're stored all integrated and ready to be collided\n        // probably shouldn't use same bounce fn as walls anyway\n        // since this is a pixel shader, we're really limited in what we can do\n        // regarding updating multiple objects state at once;\n        // it all happens in one tick, the relative order of each update \n        // doesn't matter; objects' state spans more than one pixel and \n        // everything must be updated in sync, but the double buffering helps.\n        // So the pixels aren't really fighting with each other, but\n        // they must all be updated in concert, with forces balancing.\n        // which is really hard to pull off in one pass consistently!\n// proper collision will probably require some extra buffer step\n// where contacts are identified first then forces applied bidirectionally in next pass\n\nvec4 distanceNeighbors(ivec2 q, ivec4 ns)\n{\n    vec4 ds;\n    vec2 p = vec2(q) + .5;\n    for (int i = IZERO+NPC; i-- > 0; ) {\n        if (!idValid(ns[i])) { ds[i] = 3.4e38; continue; } // skip bad ids\n        ivec2 c = id2coord(ns[i]);\n        Object o = loadObject(BufferA, c);\n        vec2 local = p - o.p;\n        float sd = dshape(local);\n        ds[i] = sd;\n    }\n    return ds;\n}\n\nvoid mergeNeighbors(ivec2 q, inout ivec4 ns, inout vec4 ds, ivec4 xs)\n{\n    vec4 xd = distanceNeighbors(q, xs);\n    for (int i = IZERO+NPC; i-- > 0; )\n        insertNeighbor(IZERO, ns, ds, xs[i], xd[i]);\n}\n\nivec4 mixNeighbors(ivec2 q)\n{\n    vec4 npack = texelFetch(BufferA, q, 0);\n    ivec4 ns = unpackNeighbors(npack); // start w old neighbors\n    ivec4 nnext = ivec4(-1);\n    vec4 ds = distanceNeighbors(q, ns);\n    npack = texelFetch(BufferA, q + ivec2(1,0), 0);\n    nnext = unpackNeighbors(npack);\n    mergeNeighbors(q, ns, ds, nnext);\n    npack = texelFetch(BufferA, q + ivec2(0,1), 0);\n    nnext = unpackNeighbors(npack);\n    mergeNeighbors(q, ns, ds, nnext);\n    npack = texelFetch(BufferA, q - ivec2(1,0), 0);\n    nnext = unpackNeighbors(npack);\n    mergeNeighbors(q, ns, ds, nnext);\n    npack = texelFetch(BufferA, q - ivec2(0,1), 0);\n    nnext = unpackNeighbors(npack);\n    mergeNeighbors(q, ns, ds, nnext);\n    // if one gets lost temporarily,\n    // this kludge usually rescues them eventually.\n   #if 1\n    // merge some random id's in case some objects got lost\n    for (int j = IZERO+4; j-- > 0; ) nnext[j] = (j + ((iFrame & 255)<<3))%totalshapes;\n    mergeNeighbors(q, ns, ds, nnext);\n   #endif\n    // objects can still become \"lost\"\n    // where no cells include as neighbor,\n    // if too many objects can fit into one cell.\n    return ns;\n}\n\nvoid updateNeighbors(inout vec4 o, ivec2 q)\n{\n    ivec4 ns;\n    ns = mixNeighbors(q);\n    o = packNeighbors(ns);\n}\n\nvoid tick(inout vec4 o, ivec2 q, ivec3 r)\n{\n    switch (r.z) {\n        case rNear:\n        \tupdateNeighbors(o, r.xy);\n        \tbreak;\n        case rPosVel:\n        \tmotion(o, r.xy);\n        \tbreak;\n    }\n}\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    ivec2 q = ivec2(p);\n    ivec3 r = region(q);\n    if (init(o, q, r)) return;\n    tick(o, q, r);\n}\n\n\n//void mergeNeighbors1(ns, ds, sd, id)\n//{\n//    insertNeighbor(ns, ds, id, sd);\n//}\n\n // hope you don't ever need this\n/*\nivec4 bruteForceNeighbors(ivec2 q, vec2 p)\n{\n    // bruteforce nearest neighbors\n    vec4 ds = vec4(9e9); ivec4 ns = ivec4(-1);\n    //vec4 npack = texelFetch(BufferA, q, 0); //loadNeighbors(BufferA, q);\n    // just let it insert them all, at least the order will be correct\n    for (int j = 0; j < shaperows; ++j) {\n\t for (int i = 0; i < shapesperrow; ++i) {\n        int id = coord2id(ivec2(i,j));\n        Object o = loadObject(BufferA, ivec2(i,j));\n        float scl = radius;\n        float sd; // signed distance to shape from q\n        sd = dshape((p - o.p)/scl) * scl;\n        insertNeighbor(ns, ds, id, sd);\n     }\n    }\n    return ns;\n}\n*/ //int sid = coord2id(r.xy); //r.x + shapesperrow*r.y; //\n    //o = vec4(0);\n    //const float phi = (sqrt(5.) + 1.)/2.;\n    //vec3 rnd = sin(vec3(sid + ivec3(0,2,4)) * phi * 32.1);\n    //int ts = totalshapes, spr = shapesperrow;\n        \t//o.zw = vec2(0);\n            // I have never gotten this initialized correctly w/o brute force\n        //\to = vec4(sid, -1,-1,-1);\n    //    \tsid = (r.y * shaperows / boxH) * spr + r.x * spr / boxW;\n    //        o = vec4(sid); // set all 4 to the same neighbor id for now;\n    //    \to += vec4(-1, 1, -spr, spr); // the 4 immediate neighbors\n    //    //\to = mod(o, float(ts));\n    //    \to = max(o, vec4(0));\n    //    \to = min(o, vec4(ts-1));\n        //    ns = ivec4(0,1,2,3);\n  /*\n    // a spring force instead of actual collision\n    ivec2 sr = ivec2(shapesperrow, shaperows);\n    ivec4 neighbors = loadNeighbors(BufferA, q, sr);\n    for (int i = IZERO+NPC; i-- > 0; ) {\n        int nn = neighbors[i];\n        if (nn == id) continue; // don't push self!\n        Object o = loadObject(BufferA, id2coord(nn));\n        vec2 po = o.p; float ro = radius;\n        vec2 rd = normalize(p - po);\n        //if (dot(v, rd) <= 0.) break;\n        float dr = distance(p, po) //dot(p, rd) //\n            - r - ro;\n        float K = 5.5;\n        v -= K * min(dr, 0.) * rd; // one-sided springs, no \"pull\" force, for fakie collision\n        // but since it's undamped etc. it's unstable as heck.  I'm only using simple Euler integration.\n    }\n  */\n\n/*void rotion(inout vec4 o, ivec2 q)\n{\n    float r = o.x, s = o.y; int k = int(o.z);\n    float dt = iTimeDelta;\n    // will probably need to do all the physics in this thread too, but only output orientation\n    // for now they just constantly don't rotate\n    //o.x = fract(o.x + .05*dt);\n}*/\n\n// had further plans, once:\n//const ivec2 shapeOriAvelSizeOffset = ivec2(boxW,0);\n//const ivec2 shapeAlbedoOffset = ivec2(boxW,boxH);\n//, rOriSize = 2 // 1/4 used for the shape orientations and angular velocities, size, and shape (region 2)\n//, rColor   = 3 // and 1/4 used for material albedo and something else (region 3)\n    //    case rOriSize:\n    //    \trotion(o, r.xy); //o.x = 0.; // HACK no rotation\n    //    \tbreak;\n    //    case rColor:\n    //    \tbreak;\n    \n    //    case rOriSize:\n    //    \to.x = rnd.x;\n    //    \to.y = rnd.y*.125+.375;\n    //    \to.z = float(int(3.*(rnd.x-rnd.y)) & 3);\n    //    \tbreak; // zw? TODO\n    //    case rColor:\n    //   \to.rgb = .5 + .5*cos(float(sid)+vec3(0,2,4));\n    //    \to.a = 1.; // TODO\n    //    \tbreak;\n","name":"Buffer A","description":"","type":"buffer"}]}