{"ver":"0.1","info":{"id":"ttXXzB","date":"1563368186","viewed":298,"name":" Submarine Binoculars","username":"96logda","description":"Converted one of my older version of my water shader with a \"submarine binoculars\" from glslsandbox to shadertoy.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["circles","grid","sea","lines","water","vignette","rain","submarinebinoculars","binoculars"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Copyright (c) 2019-06-23 - 2019-07-17 by Angelo Logahd\n//Portfolio: https://angelologahd.wixsite.com/portfolio\n\n//Copyright (c) 2019-06-23 - 2019-07-04 by Angelo Logahd\n//My orginal version:\n//http://glslsandbox.com/e#55788.7\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nconst float PI\t \t\t\t\t\t\t= 3.1415;\nfloat EPSILON_NRM\t\t\t\t\t\t= 0.001;\n\nconst vec3 up \t\t\t\t\t\t\t= vec3(0.0, 1.0, 0.0);\n\n#define true  \t\t\t\t\t\t\t1\n#define false \t\t\t\t\t\t\t0\n\n#define saturate(x)\t\t\t\t\t\tclamp(x, 0.0, 1.0)\n#define mul3x(x) \t\t\t\t\t\tx * x * x\n#define dot2(x)\t\t\t\t\t\t\tdot(x, x)\n\n#define SIMULATE \t\t\t\t\t\t0\n#define SIMULATE2x\t\t\t\t\t\t1\n#define SIMULATE3x\t\t\t\t\t\t2\n#define SIMULATE4x\t\t\t\t\t\t3\n#define SIMULATE5x\t\t\t\t\t\t4\n#define PAUSED\t\t\t\t\t\t\t5\n#define SLOW_MOTION\t\t\t\t\t\t6\n\n#define WAVES_WATER\t\t\t\t\t\t0\n#define CALM_WATER\t\t\t\t\t\t1\n\n#define SIMULATE_MODE\t\t\t\t\tSIMULATE\n#define WATER_TYPE\t\t\t\t\t\tCALM_WATER\n#define RAINBOW_WATER\t\t\t\t\tfalse\n#define FANTASY_WATER_PATH\t\t\t\tfalse\n#define FLIP_WATER_AND_SKY\t\t\t\tfalse\n#define DAY_AND_NIGHT\t\t\t\t\tfalse\n#define SUN_LIGHT\t\t\t\t\t\ttrue\n\n//...........................................................\n//\t\t\tWeathers\n//...........................................................\n#define\tRAIN\t\t\t\t\t\t\ttrue\n#define RAINBOW\t\t\t\t\t\t\tfalse\n#define STAR_SKY\t\t\t\t\t\tfalse\n\n#if RAINBOW\n#define RAINBOW_START_Y\t\t\t\t\t0.0\n\nconst float RAINBOW_BRIGHTNESS  \t\t= 1.0;\nconst float RAINBOW_INTENSITY   \t\t= 0.30;\nconst vec3  RAINBOW_COLOR_RANGE \t\t= vec3(50.0, 53.0, 56.0);  // Note: The color range are described in degrees.\nvec3 RAINBOW_POS\t\t\t\t\t\t= vec3(4.5, 0.0, 0.5);\nvec3 RAINBOW_DIR \t\t\t\t\t\t= vec3(-0.2, -0.1, 0.0);\n\t\nvec3 rainbow_pos;\nvec3 rainbow_camera_dir;\nvec3 rainbow_up; \nvec3 rainbow_vertical;\nvec3 rainbow_w;\n#endif\n\n#if STAR_SKY\nconst float STAR_THRESHOLD\t\t\t\t= 0.98;\n#endif\n//...........................................................\n\n//...........................................................\n//\t\t\tPost Processing\n//...........................................................\n#define APPLY_LUMINANCE\t\t\t\t\ttrue\n#define APPLY_TONEMAP\t\t\t\t\ttrue\n#define APPLY_GAMMA_CORRECTION\t\t\ttrue\n\nconst float INTENSITY\t\t\t\t\t= 1.2;\nconst float CONTRAST\t\t\t\t\t= 1.0;\n\n#if APPLY_TONEMAP\n\n#define LINEAR_TONEMAP\t\t\t\t\t0\n#define EXPONENTIAL_TONEMAP\t\t\t\t1\n#define REINHARD_TONEMAP\t\t\t\t2\n#define FILMIC_TONEMAP\t\t\t\t\t3\n\n#define TONEMAP_TYPE\t\t\t\t\tFILMIC_TONEMAP\t\t\n \n#if TONEMAP_TYPE == LINEAR_TONEMAP\nconst float TONEMAP_EXPOSURE\t\t\t= 0.5;\n#endif\n#if TONEMAP_TYPE == EXPONENTIAL_TONEMAP\nconst float TONEMAP_EXPOSURE\t\t\t= 0.5;\n#endif\n#if TONEMAP_TYPE == REINHARD_TONEMAP\nconst float TONEMAP_EXPOSURE\t\t\t= 0.5;\n#endif\n#if TONEMAP_TYPE == FILMIC_TONEMAP\n//https://www.slideshare.net/ozlael/hable-john-uncharted2-hdr-lighting\n//http://filmicworlds.com/blog/filmic-tonemapping-operators/\n\n//Uncharted2Tonemap:\n//Orginal Values:\n//A = 0.22\n//B = 0.30\n//C = 0.10\n//D = 0.20\n//E = 0.02\n//F = 0.30\n//W = 11.2\n\nfloat A = 0.15;\nfloat B = 0.50;\nfloat C = 0.10;\nfloat D = 0.20;\nfloat E = 0.02;\nfloat F = 0.30;\nfloat W = 11.2;\n\nconst float TONEMAP_EXPOSURE\t\t\t= 1.5;\nconst float TONEMAP_EXPOSURE_BIAS \t\t= 2.0;\n#endif\n\n#endif\n\n//...........................................................\n//\t\t\tFilters\n//...........................................................\n#define VIGNETTE_FILTER\t\t\t\t\ttrue\n#define SEPIA_FILTER\t\t\t\t\tfalse\n\n#if VIGNETTE_FILTER\nconst vec3  VIGNETTE_COLOR \t\t\t\t= vec3(1.0, 1.3, 0.4);\nconst float VIGNETTE_ZOOM  \t\t\t\t= 1.0; //2.5 -> full image \nconst float VIGNETTE_EXPOSURE \t\t\t= 0.1;\n#endif\n\n#if SEPIA_FILTER\nconst vec3  SEPIA_COLOR \t\t\t\t= vec3(1.9, 0.8, 0.6);\nconst float SEPIA_INTENSITY \t\t\t= 0.2;\n#endif\n//...........................................................\t\n\n#if APPLY_GAMMA_CORRECTION\nconst float GAMMA\t\t\t\t\t\t= 2.2;\n#endif\n//...........................................................\n\n//Day and night properties\n#if DAY_AND_NIGHT\n#define DAY_AND_NIGHT_TIME\t\t\t\t0.1\n#define DAY_AND_NIGHT_MIN_BRIGHTNESS\t0.2\n#define DAY_AND_NIGHT_MAX_BRIGHTNESS\t1.0\n#endif\n\n//Sun light properties\n#if SUN_LIGHT\nvec3  SEA_SUN_DIRECTION\t\t        \t= vec3(0.0, -1.0, -0.5);\nvec3  SEA_SUN_COLOR     \t\t\t\t= vec3(1.0, 1.0, 1.0);\nfloat SEA_SUN_DIFFUSE  \t\t\t\t\t= 0.65; \nvec3  SEA_SUN_SPECULAR      \t\t\t= vec3(0.65);\n#endif\n\n//Geometry / Fragment properties\nconst int SEA_GEOMETRY_ITERATIONS   \t= 8;\nconst int SEA_FRAGMENT_ITERATIONS   \t= 10;\n\n// sea base properties\nconst vec3  SEA_BASE_COLOR \t\t\t\t= vec3(0.15, 0.19, 0.25);\nconst vec3  SEA_WATER_COLOR \t\t\t= vec3(0.1, 0.1, 0.15);\nconst vec3  SEA_ORI\t\t\t\t\t\t= vec3(0.0, 3.5, 0.0);\t\t\nconst float SEA_HEIGHT    \t\t\t\t= 1.0;\nconst float SEA_SPEED     \t\t\t\t= 3.0;\nconst float SEA_FREQ      \t\t\t\t= 0.1;\nconst float SEA_GEOMETRY_FREQ_MUL\t\t= 1.9;\nconst float SEA_GEOMETRY_AMPLITUDE_MUL \t= 0.22;\nconst float SEA_FREQ_MUL  \t\t\t\t= 2.0;\nconst float SEA_AMPLITUDE_MUL \t\t\t= 0.22;\nconst float SEA_REFRACTION_MUL_VALUE\t= 0.12;\nconst float SEA_ATTENUATION             = 0.001;\nconst float SEA_ATTENUATION_MUL_FACTOR  = 0.18;\nconst float SEA_CHOPPY    \t\t\t\t= 5.9;\nconst float SEA_CHOPPY_MIX_VALUE\t\t= 1.0;\nconst float SEA_CHOPPY_MIX_FACTOR\t\t= 0.4;\n\n// sea heightmap\nconst int HEIGHTMAP_NUM_STEPS     \t\t= 20;\n\n// sea direction\nconst float SEA_DIR_Z_SCALE \t\t\t= 0.02;\n\n//.................................................\n// \t\tPBR properties\n//.................................................\n#define FRESNEL_DEFAULT_FORMULA\t\t\t0\n#define FRESNEL_SCHLICK_FORMULA\t\t\t1\n\n#define FRESNEL_FORMULA\t\t\t\t\tFRESNEL_DEFAULT_FORMULA\n\nconst float SEA_SPECULAR_FACTOR\t\t\t= 60.0;\nconst float FRESNEL_POW_FACTOR\t\t\t= 3.0;\nconst float DIFFUSE_POW_FACTOR\t\t\t= 80.0;\n\n//.................................................\n//\t\t\tMaterials\n//.................................................\n\nstruct Material\n{\n    float fR0;\n    float fSmoothFactor;\n};\n\n//.................................................\n//\t\t       Sea Material\n#if FRESNEL_FORMULA == FRESNEL_SCHLICK_FORMULA\nconst float SEA_R0\t\t \t\t\t= 0.01;\nconst float SEA_SMOOTH_FACTOR \t\t= 0.1;\n#elif FRESNEL_FORMULA == FRESNEL_DEFAULT_FORMULA\nconst float SEA_SMOOTH_FACTOR \t\t= 0.65;\n#endif\n//.................................................\n\n//.................................................\n\n//.................................................\n\nconst float SEA_PAUSED_SPEED\t\t\t= 0.0;\nconst float SEA_SLOWMOTION_SPEED        = 0.5;\n\n#if RAINBOW_WATER\nconst float RAINBOW_WATER_SATURATION\t= 0.35;\nconst float RAINBOW_WATER_LIGHTNESS\t\t= 0.1;\nconst float RAINBOW_WATER_SPEED \t\t= 0.1;\n#endif\n\n#if FANTASY_WATER_PATH\nconst float UV_START_X\t\t\t\t\t= -5.0;\nconst float UV_END_X\t\t\t\t\t=  5.0;\n#endif\n\nmat2 octave_matrix \t\t\t\t\t\t= mat2(1.6, 1.2, -1.2, 1.6);\n\nfloat SEA_CURRENT_TIME\t\t\t\t\t= 0.0;\n\n//Color mixing\nconst float SMOOTH_MIX_Y\t\t\t\t= -0.5; \nconst float MIX_SEA_AND_SKY_FACTOR\t\t= 0.11;\nconst vec3  COLOR_GRADING\t\t\t\t= vec3(0.0, 0.0, 0.0);\n\n//..................................................................\n//\t\t\t\tFog\n//..................................................................\n#define ALWAYS_FOG\t\t\t\t\t\t0\n#define NEVER_FOG\t\t\t\t\t\t1\n//#define CAN_BE_FOGGY\n\n#define FOG_MODE\t\t\t\t\t\tNEVER_FOG\nconst vec3  FOG_COLOR  \t\t\t\t\t= vec3(0.15, 0.15, 0.15);\nconst float FOG_START \t\t\t\t\t= 0.04;\nconst float FOG_END \t\t\t\t\t= 500.0;\nconst float FOG_DENSITY \t\t\t\t= 0.2;\n//..................................................................\n\n\nvec3 hsv(float hue, float saturation, float value)\n{\n    vec4 t = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(vec3(hue) + t.xyz) * 6.0 - vec3(t.w));\n    return value * mix(vec3(t.x), clamp(p - vec3(t.x), 0.0, 1.0), saturation);\n}\n\nfloat rand(float n)\n{\n    return fract(sin(n) * 43758.5453123);\n}\n\nfloat hash(vec2 p)\n{\t\n    return rand(dot(p, vec2(12.9898, 78.233)));\n}\n\nvec2 _smoothstep(in vec2 p)\n{\n    vec2 f = fract(p);\n    return f * f * (3.0 - 2.0 * f);\n}\n\nvec3 _smoothstep(in vec3 p)\n{\n     return p * p * 3.0 - 2.0 * mul3x(p);\n}\n\nfloat noise(in vec2 p) \n{\n    vec2 i = floor(p);\t\n    vec2 sp = _smoothstep(p);\n    return -1.0 + 2.0 * mix(mix(hash(i + vec2(0.0, 0.0)), \n                                hash(i + vec2(1.0, 0.0)), sp.x),\n                            mix(hash(i + vec2(0.0, 1.0)), \n                                hash(i + vec2(1.0, 1.0)), sp.x), sp.y);\n}\n\nfloat GetFragLuminance(vec3 fragColor)\n{\n    return dot(fragColor, vec3(0.3, 0.59, 0.11));\n}\n\nfloat d2y(float d)\n{\n    return 1.0 / (0.01 + d);\n}\n\t\nfloat circle(vec2 p, float r, float zoom)\n{\n    float d = distance(r, 0.45 * zoom);\n    return d2y(1000.0 * d);\n}\n\nbool line(vec2 uv, vec2 from, vec2 to)\n{\n    return uv.x >= from.x && uv.x <= to.x && \n\t   uv.y >= from.y && uv.y <= to.y;\n}\n\nfloat grid(vec2 p, float y, const float e)\n{\n    float a = 0.5;\n    float res = 14.98;\n    vec2 f = fract(p * res);\n    f = step(e, f);\t\n    return a * y * f.x * f.y;\n}\n\nvec3 sky(vec3 p) \n{\n    p.y = max(p.y, 0.0);\n    vec3 ret;\n    ret.x = pow(1.0 - p.y, 3.3) * 0.8;\n    ret.y = 1.0 - p.y;\n    ret.z = 1.8;\n    return ret;\n}\n\nfloat sea_octave(vec2 uv, float choppy) \n{\t\n    #if WATER_TYPE == WAVES_WATER \n    uv += noise(uv);\n    vec2 wv = 1.0 - abs(sin(uv));   \n    wv = mix(wv, abs(cos(uv)), wv);\n    return pow(1.0 - pow(wv.x * wv.y, 0.65), choppy);\n    #elif WATER_TYPE == CALM_WATER\n    //Author: Angelo Logahd \n    //2019-06-29\n    float noise = noise(uv);\n    float x = cos(noise);\n    float y = sin(noise);\n    return pow(pow(abs(x * y), 0.65), choppy);\n    #endif\n}\n\nfloat sea_geometry_map(vec3 p) \n{\n    #if WATER_TYPE == WAVES_WATER\n    vec2 uv = p.xz * vec2(0.85, 1.0);\n\t\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    \n    float d = 0.0;\n    float h = 0.0;    \n    for (int i = 0; i < SEA_GEOMETRY_ITERATIONS; ++i) \n    {   \n\t\t#if FANTASY_WATER_PATH\n\t   \tif (uv.x > UV_START_X && uv.x < UV_END_X)\n\t   \t{\n\t\t\tcontinue;\n\t   \t}\n\t\t#endif\n\n    \td =  sea_octave((uv + SEA_CURRENT_TIME) * freq, choppy);\n    \td += sea_octave((uv - SEA_CURRENT_TIME) * freq, choppy);\n        h += d * amp; \n\t    \n\t\tfreq *= SEA_GEOMETRY_FREQ_MUL; \n\t\tamp  *= SEA_GEOMETRY_AMPLITUDE_MUL;\n\t    \n        choppy = mix(choppy, SEA_CHOPPY_MIX_VALUE, SEA_CHOPPY_MIX_FACTOR);\n\t    \n\t\tuv *= octave_matrix; \n    }\n    return p.y - h;\n    #else\n    return p.y;\n    #endif\n}\n\nfloat sea_fragment_map(vec3 p) \n{\n    vec2 uv = p.xz * vec2(0.85, 1.0); \n    \n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;  \n    float choppy = SEA_CHOPPY;\n\t\n    float d = 0.0;\n    float h = 0.0;    \n    for(int i = 0; i < SEA_FRAGMENT_ITERATIONS; ++i) \n    {\t    \n    \td =  sea_octave((uv + SEA_CURRENT_TIME) * freq, choppy);\n\t\td += sea_octave((uv - SEA_CURRENT_TIME) * freq, choppy); \n\t\th += d * amp;\n\t\n\t\tfreq *= SEA_FREQ_MUL; \n\t\tamp  *= SEA_AMPLITUDE_MUL;\n\t\n\t\tchoppy = mix(choppy, SEA_CHOPPY_MIX_VALUE, SEA_CHOPPY_MIX_FACTOR);\n\t\n\t\tuv *= octave_matrix;\n    }\n    return p.y - h;\n}\n\nvec3 diffuse(vec3 normal, vec3 light, float powFactor) \n{\n    float diffuse = pow(dot(normal, light) * 0.4 + 0.6, powFactor);\n    return vec3(diffuse);\n}\n\nvec3 normal(vec3 p, vec3 dist) \n{\n    float eps = dot2(dist) * EPSILON_NRM;\n    vec3 n;\n    n.y = sea_fragment_map(p); \n    n = vec3(sea_fragment_map(vec3(p.x + eps, p.y, p.z)) - n.y,\n\t     \t sea_fragment_map(vec3(p.x, p.y, p.z + eps)) - n.y,\n\t     \t eps);\n    return normalize(n);\n}\n\nvec3 specular(vec3 eye, vec3 normal, vec3 light) \n{    \n    float nrm = (SEA_SPECULAR_FACTOR + 8.0) / (PI * 8.0);\n    float specular = pow(max(dot(reflect(eye, normal), light), 0.0), SEA_SPECULAR_FACTOR) * nrm;\n    return vec3(specular);\n}\n\nfloat Schlick(const in vec3 vHalf, const in vec3 eye, const in Material mat)\n{\n    float fDot = dot(vHalf, -eye);\n    fDot = clamp((1.0 - fDot), 0.0, 1.0);\n    float fDotPow = pow(fDot, FRESNEL_POW_FACTOR);\n    return mat.fR0 + (1.0 - mat.fR0) * fDotPow * mat.fSmoothFactor;\n}\n\nfloat fresnel(const in vec3 normal, const in vec3 eye, const in vec3 diffuse, const in vec3 specular, const in Material mat)\n{\n    vec3 vReflect = reflect(eye, normal);\n    vec3 vHalf = normalize(vReflect + -eye);\n    float fFresnel = Schlick(vHalf, eye, mat);\n    return mix(diffuse, specular, fFresnel).x;\n}\n\nfloat fresnel(const in vec3 normal, const in vec3 eye, const in Material mat) \n{  \n    float fresnel = 1.0 - max(dot(normal, -eye), 0.0);\n    fresnel = pow(fresnel, FRESNEL_POW_FACTOR) * mat.fSmoothFactor;\n    return fresnel;\n}\n\nvec3 sea(const in vec3 p, const in vec3 lightDir, const in vec3 eye, Material mat) \n{\n    vec3 dist = p - SEA_ORI;  \n    vec3 normal = normal(p, dist);\n    vec3 diffuse = diffuse(normal, lightDir, DIFFUSE_POW_FACTOR);\n    vec3 specular = specular(normal, lightDir, -eye);\n\t\n    #if FRESNEL_FORMULA == FRESNEL_DEFAULT_FORMULA\n    float fresnel = fresnel(normal, eye, mat);\n    #elif FRESNEL_FORMULA == FRESNEL_SCHLICK_FORMULA\n    float fresnel = fresnel(normal, eye, diffuse, specular, mat);\n    #endif\n    \n    vec3 reflected = sky(reflect(eye, normal));    \n    vec3 refracted = SEA_BASE_COLOR + diffuse * SEA_WATER_COLOR * SEA_REFRACTION_MUL_VALUE; // * -fresnel; \n    \n    vec3 color = mix(refracted, reflected, fresnel);\n    \n    float atten = max(0.0, 1.0 - dot2(dist) * SEA_ATTENUATION) * SEA_ATTENUATION_MUL_FACTOR;\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * atten;\n    \n    color += specular;\n    \n    #if SUN_LIGHT\n    vec3 sunDiffuseColor = max(dot(SEA_SUN_DIRECTION, normal), 0.0) * SEA_SUN_COLOR * SEA_SUN_DIFFUSE;\n    vec3 reflection = normalize(reflect(-SEA_SUN_DIRECTION, normal));\n    float direction = max(0.0, dot(eye, reflection));\n    vec3 sunSpecular = direction * SEA_SUN_COLOR * SEA_SUN_SPECULAR;\n    color = color + sunDiffuseColor + sunSpecular;\n    #endif\n    \n    #if RAINBOW_WATER\n    color += hsv((p.z * 0.3) - time * RAINBOW_WATER_SPEED, RAINBOW_WATER_SATURATION, RAINBOW_WATER_LIGHTNESS);\n    #endif\n    \n    return color;\n}\n\nvec3 seaHeightMap(vec3 dir) \n{\n    vec3 p = vec3(0.0);\n    float x = 1000.0;\n\t\n    if (sea_geometry_map(SEA_ORI + dir * x) > 0.0)\n    {\n\t\treturn p;\n    }\n    \n    float mid = 0.0;\n    float m = 0.0;\n    float heightMiddle = 0.0;\n    for(int i = 0; i < HEIGHTMAP_NUM_STEPS; ++i) \n    {\n\t\tmid = mix(m, x, 0.5); \n        p = SEA_ORI + dir * mid;                   \n    \theightMiddle = sea_geometry_map(p);\n\t\tif (heightMiddle < 0.0) \n\t\t{\n            x = mid;\n        } \n\t\telse \n\t\t{\n            m = mid;\n        }\n    }\n\t\n    return p;\n}\n\nvec3 fog(vec3 sceneColor, float dist)\n{\n    vec3 fragRGB = sceneColor;\n    const float FogEnd   = FOG_END;\n    const float FogStart = FOG_START;\n    float distanceF = (FogEnd - dist) / (FogEnd - FogStart);\n    float fogAmount = saturate(1.0 - exp(-distanceF * FOG_DENSITY));\n    return mix(fragRGB, FOG_COLOR, fogAmount);\n}\n\nfloat rainHash(float p)\n{\n    vec2 p2 = fract(vec2(p) * vec2(0.16632, 0.17369));\n    p2 += dot(p2.xy, p2.yx + 19.19);\n    return fract(p2.x * p2.y);\n}\n\nfloat rainNoise(in vec2 x)\n{\n    vec2 p = floor(x);\n    vec2 f = _smoothstep(x);\n    float n = p.x + p.y * 57.0;\n    return mix(mix(rainHash(n +  0.0), rainHash(n +  1.0), f.x),\n               mix(rainHash(n + 57.0), rainHash(n + 58.0), f.x), f.y);\n}\n\nfloat rain(vec2 uv, vec2 xy)\n{\t\n    float travelTime = (iTime * 0.7) + 0.1;\n\t\n    float x1 = (0.5 + xy.x + 1.0) * 0.3;\n    float y1 = 0.01;\n    float x2 = travelTime * 0.5 + xy.x * 0.2;\n    float y2 = travelTime * 0.2;\n\t\n    vec2 st = uv * vec2(x1, y1) + vec2(x2, y2);\n    \n    float rain = 0.1;\n    float f = rainNoise(st * 200.5) * rainNoise(st * 125.5);  \n    f = clamp(pow(abs(f), 20.0) * 1.5 * (rain * rain * 125.0), 0.0, 0.1);\n    return f;\n}\n\n#if RAINBOW\nvec3 rainbowColor(in vec3 ray_dir) \n{ \n    RAINBOW_DIR = normalize(RAINBOW_DIR);   \n\t\t\n    float theta = degrees(acos(dot(RAINBOW_DIR, ray_dir)));\n    vec3 nd = clamp(1.0 - abs((RAINBOW_COLOR_RANGE - theta) * 0.2), 0.0, 1.0);\n    vec3 color = smoothstep(nd) * RAINBOW_INTENSITY;\n    \n    return color * max((RAINBOW_BRIGHTNESS - 0.75) * 1.5, 0.0);\n}\n\nvoid rainbowSetup()\n{\n    rainbow_pos =  RAINBOW_POS;\n    rainbow_w   = -normalize(-rainbow_pos);\n    rainbow_up  =  normalize(cross(rainbow_w, up));\n    rainbow_vertical = normalize(cross(rainbow_up, rainbow_w));\n}\n\nvec3 rainbow()\n{\n     vec2 uv = gl_FragCoord.xy / resolution.xy;\n     vec2 p = (-1.0 + 2.0 * uv) * vec2(resolution.x / resolution.y, 1.0);\n\n     vec3 color = vec3(0.0);\n     if (p.y >= RAINBOW_START_Y)\n     {\n         vec2 uv = gl_FragCoord.xy / resolution.xy;\n\t\n    \t rainbowSetup();\n\n     \t vec3 dir = normalize(vec3(p, 0.0) - vec3(0.0, 0.0, -1.5));\n     \t vec3 wdDir = normalize(dir.x * rainbow_up + dir.y * rainbow_vertical - dir.z * rainbow_w);\n\t     \n         color += rainbowColor(wdDir);\n     }\t\n     return clamp(color, 0.0, 1.0);  \n}\n#endif\n\n//.......................................................................................\n//\t\t\t\t\tNight weathers\n//.......................................................................................\n#if STAR_SKY\nfloat starHash(float n) \n{\n    return fract((1.0 + cos(n)) * 15.92653) * 1.8;\n}\n\nvec3 star(in vec2 uv) \n{\n    vec2 p = uv * 0.02; //To avoid flickering\n    if (p.y > 0.001)\n    {\n\t\tfloat starValue = fract(starHash(p.x * 37.0) + starHash(p.y * 80.0));\n\t\tif (starValue > STAR_THRESHOLD) \n\t\t{\n\t    \tvec3 starColor = vec3(pow((starValue - STAR_THRESHOLD) / 0.02, 25.0));\n\t    \treturn starColor * 0.3; // * (1.0 - brightness);\n\t\t}  \n    }\n    return vec3(0.0);\n}\n#endif\n//.......................................................................................\n\n#if TONEMAP_TYPE == FILMIC_TONEMAP\nvec3 Uncharted2Tonemap(vec3 x)\n{\n   return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\n}\n#endif\n\nvec3 Tonemap(vec3 color)\n{\n    #if TONEMAP_TYPE == LINEAR_TONEMAP\n    color *= vec3(TONEMAP_EXPOSURE);\n    #endif\n    #if TONEMAP_TYPE == EXPONENTIAL_TONEMAP\n    color = 1.0 - exp2(-color * TONEMAP_EXPOSURE);\n    #endif\n    #if TONEMAP_TYPE == REINHARD_TONEMAP\n    color *= TONEMAP_EXPOSURE;\n    color = color / (1.0 + color);\n    #endif\n    #if TONEMAP_TYPE == FILMIC_TONEMAP    \n    color *= TONEMAP_EXPOSURE;\n    vec3 tonemapedColor = Uncharted2Tonemap(TONEMAP_EXPOSURE_BIAS * color);\n    vec3 whiteScale = 1.0 / Uncharted2Tonemap(vec3(W));\n    color = tonemapedColor * whiteScale;\n    #endif\n   \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\t\n    vec2 xy = fragCoord.xy / iResolution.xy;\n\t\n    float intensity = INTENSITY;\n    #if DAY_AND_NIGHT\n    \tintensity *= clamp(sin(time * DAY_AND_NIGHT_TIME) + DAY_AND_NIGHT_MIN_BRIGHTNESS, \n\t\t\t   DAY_AND_NIGHT_MIN_BRIGHTNESS, \n\t\t\t   DAY_AND_NIGHT_MAX_BRIGHTNESS);\n    #endif\n\t\n    EPSILON_NRM = 0.5 / iResolution.x;\n\t\n    #if SIMULATE_MODE == SIMULATE\n\tSEA_CURRENT_TIME = iTime * SEA_SPEED;\n    #elif SIMULATE_MODE == SIMULATE2x\n\tSEA_CURRENT_TIME = iTime * SEA_SPEED * 2.0;\n    #elif SIMULATE_MODE == SIMULATE3x\n\tSEA_CURRENT_TIME = iTime * SEA_SPEED * 3.0;\n    #elif SIMULATE_MODE == SIMULATE4x\n\tSEA_CURRENT_TIME = iTime * SEA_SPEED * 4.0;\n    #elif SIMULATE_MODE == SIMULATE5x\n\tSEA_CURRENT_TIME = iTime * SEA_SPEED * 4.0;\n    #elif SIMULATE_MODE == PAUSED\n\tSEA_CURRENT_TIME = 0.0;\n    #elif SIMULATE_MODE == SLOW_MOTION\n\tSEA_CURRENT_TIME = iTime * SEA_SLOWMOTION_SPEED;\n    #endif\n \n    #if FLIP_WATER_AND_SKY\n    vec3 dir = normalize(vec3(-uv.xy, -1.0));\n    #else\n    vec3 dir = normalize(vec3(uv.xy, -1.0));\n    #endif\n    dir.z += length(uv) * SEA_DIR_Z_SCALE;\n    dir = normalize(dir);\n    \n    Material mat;\n    #if FRESNEL_FORMULA == FRESNEL_SCHLICK_FORMULA\n    mat.fR0 = SEA_R0;\n    #endif\n    mat.fSmoothFactor = SEA_SMOOTH_FACTOR;\n\t\n    vec3 p = seaHeightMap(dir);\n    vec3 lightDir = vec3(0.0, -1.0, 0.0);\n    \n    float smothMixFactor = pow(smoothstep(0.0, SMOOTH_MIX_Y, dir.y), MIX_SEA_AND_SKY_FACTOR);\n    \n    vec3 sky = sky(dir);\n    vec3 sea = sea(p, lightDir, dir, mat);\n\n    vec3 color = mix(sky, sea, smothMixFactor); \n    \n    #if FOG_MODE != NEVER_FOG\n    color = fog(color, dir.z);\n    #endif\n    \n    #if RAIN\n    vec3 rainColor = vec3(1.0, 1.0, 1.0) * 1.5;\n    float rainFactor = rain(uv, xy);\n    color = mix(color, rainColor, rainFactor);\n    #endif\n    \n    color = color * intensity + COLOR_GRADING;\n\n    #if STAR_SKY\n    color += star(uv);\n    #endif\n    \n    #if RAINBOW\n    color += rainbow();\n    #endif\n\t\n    color = color * CONTRAST + 0.5 - CONTRAST * 0.5;\n\t\n    float dc = length(uv) * 0.5;\n\t\n    vec3 circCol = 1.0 * vec3(0.2, 0.9, 0.7);\n\n    float y = 0.0;\n    y += 0.2;\n    y += circle(uv, dc, 1.0);\n    y += circle(uv, dc, 0.5);\n    y += circle(uv, dc, 0.2);\n    y += grid(uv, y, 0.9);\n    y += grid(uv, y, 0.1);\t\n\t\n    color += circCol * sqrt(pow(y, 1.5));\n\t\n    if (line(uv, vec2(-0.005, -1.0), vec2(0.0015, 1.0)) ||\n        line(uv, vec2(-2.0, -0.005), vec2(2.0, 0.0015)))\n    {\n\t\tcolor = vec3(0.0, 0.2, 0.0);\n    }\n\t\n    #if APPLY_LUMINANCE\n    float luminance = GetFragLuminance(color);\n    luminance = saturate(luminance);\n    vec3 resLuminance = vec3(length(color.r * luminance), \n\t\t\t     length(color.g * luminance), \n\t\t\t     length(color.b * luminance));\n\n    color.rgb = resLuminance;\n    #endif\n\t\n    #if SEPIA_FILTER\n    float greyScale = GetFragLuminance(color);\n    color = greyScale * SEPIA_COLOR * SEPIA_INTENSITY;\n    #endif\n\t\n    #if VIGNETTE_FILTER\n    color *= vec3(VIGNETTE_COLOR) * saturate(1.0 - length(uv / VIGNETTE_ZOOM)) * VIGNETTE_EXPOSURE;\n    #endif\n\t\n    #if APPLY_TONEMAP\n    color = Tonemap(color);\n    #endif\n\t\n    #if APPLY_GAMMA_CORRECTION\n    color = pow(color, vec3(1.0 / GAMMA));\n    #endif\n\t\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}