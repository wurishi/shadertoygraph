{"ver":"0.1","info":{"id":"l3SSRV","date":"1710863549","viewed":190,"name":"switch panel","username":"mrEscen","description":"Switch panel with no purpose.\nkey A & S to toggle switches.\n","likes":20,"published":1,"flags":16,"usePreview":1,"tags":["panel","switch","toggle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"////////////////////////////////////////////////////////////////\n// Edwin de Jong 2024\n////////////////////////////////////////////////////////////////\n// References\n// Distance functions & structure based on Inigo Quilez's (iq) shaders & functions https://iquilezles.org/\n// Ray marcher inspired by iq's work and The Art of Code's work (https://www.shadertoy.com/view/XlGBW3)\n\n#define KEY_A 65\n#define KEY_S 83\n\n#define MAX_STEPS 350\n#define SURF_DIST 0.0001\n#define MAX_DIST 100.0\n#define PI 3.141592653592\n#define TAU 6.283185307185\n#define LIPSCHITZ 0.5\n#define DTR PI/180.0\n\n#define OBJECTS 2\n\n/*#define n1 0x22FF;\n#define n9 0x0281;\n#define n0 0x1177;\n#define n6 0x11EE;\n#define n3 0x11FE;\n#define n8 0x2206;\n\n#define A 0x119F;\n#define B 0x927E;\n#define C 0x007E;\n#define D 0x44E7;\n#define E 0x107E;\n#define F 0x101E;\n#define G 0x807E;\n#define H 0x1199;\n#define I 0x4466;\n#define J 0x4436;\n#define K 0x9218;\n#define L 0x0078;\n#define M 0x0A99;\n#define N 0x8899;\n#define O 0x00FF;\n#define P 0x111F;\n#define Q 0x80FF;\n#define R 0x911F;\n#define S 0x8866;\n#define T 0x4406;\n#define U 0x00F9;\n#define V 0x2218;\n#define W 0xA099;\n#define X 0xAA00;\n#define Y 0x4A00;\n#define Z 0x2266;\n#define s_dot     0;\n#define s_minus   0x1100;\n#define s_plus    0x5500;\n#define s_greater 0x2800;\n#define s_less    0x8200;\n#define s_sqrt    0x0C02;*/\n\nbool KeyDown(in int key){\n\treturn texelFetch(iChannel0, ivec2(key, 2), 0).x > 0.0;\n}\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n//https://www.shadertoy.com/view/XfjXzd\nconst vec2 ch_size  = vec2(13.1, 13.1);      // character size (X,Y)\nconst vec2 ch_space =  vec2(-0.13, 0.50);    // character distance Vector(X,Y)\nconst vec2 ch_start = vec2 (-0.13 , -2.);    // start position\nvec2 ch_pos   = vec2 (0.0, 0.0);       // character position(X,Y)\nvec2 uv1;\n\nstruct sdObject\n{\n    bool switched;\n    int index;\n};\n    \nsdObject sdObjects[OBJECTS];  \n////////////////////////////////////////////////////////////////\n// Signed Distance Functions\n////////////////////////////////////////////////////////////////\n// Main reference: https://iquilezles.org/articles/distfunctions/\n\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b + r;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  // sampling independent computations (only depend on shape)\n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n\n  // sampling dependant computations\n  vec2 q = vec2( length(p.xz), p.y );\n  float k = dot(q,vec2(-b,a));\n  if( k<0.0 ) return length(q) - r1;\n  if( k>a*h ) return length(q-vec2(0.0,h)) - r2;\n  return dot(q, vec2(a,b) ) - r1;\n}\n\n////////////////////////////////////////////////////////////////\n// SDF Operations\n////////////////////////////////////////////////////////////////\n\nfloat opUnion(float d1, float d2 ) { return min(d1,d2); }\n\nfloat opSubtraction(float d1, float d2) {\n    //NOTE: Flipped order because it makes more sense to me\n    return max(-d2, d1);\n}\n\n////////////////////////////////////////////////////////////////\n// Rotations\n////////////////////////////////////////////////////////////////\n\nvec3 rotX(vec3 p, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat3 m = mat3(\n        1., 0., 0.,\n        0., c, -s,\n        0., s, c\n        );\n    return m * p;\n}\n\nvec3 rotY(vec3 p, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat3 m = mat3(\n        c, 0., s,\n        0., 1., 0.,\n        -s, 0., c\n        );\n    return m * p;\n}\n\nvec3 rotZ(vec3 p, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat3 m = mat3(\n        c, -s, 0.,\n        s, c, 0.,\n        0., 0., 1.\n        );\n    return m * p;\n}\n\nvec3 orbitControls(vec3 po) {\n    vec2 m = (vec2(iMouse.x, iMouse.y) / iResolution.xy) + 0.5;\n    vec3 p = po;\n    p = rotY(po, -m.x*TAU);\n    p = rotX(p, m.y*PI + PI);\n    return p;\n}\nmat2 r2d(float t){\n  float c=cos(t),s=sin(t);\n  return mat2(c,s,-s,c);\n}\n\n////////////////////////////////////////////////////////////////\n// 7 & 16 Segment  Functions  //https://www.shadertoy.com/view/XfjXzd\n////////////////////////////////////////////////////////////////\n\nvec2 tl = vec2(-.5,  1); // top    left  corner\nvec2 tr = vec2( .5,  1); // top    right corner\nvec2 ml = vec2(-.5,  0); // mid    left  corner\nvec2 mr = vec2( .5,  0); // mid    right corner\nvec2 bl = vec2(-.5, -1); // bottom left  corner\nvec2 br = vec2( .5, -1); // bottom right corner\n\nconst int encoding[10] = int[] (119, 18, 93, 91, 58, 107, 111, 82, 127, 123);\n\nfloat Manhattan( vec2 v )\n{\n    return abs(v.x) + abs(v.y);\n}\n\nint Encode( int n )\n{   \n    n = int(mod(float(n), 10.0));\n    return encoding[n];\n}\n\nfloat Line( vec2 a, vec2 b, vec2 p )\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float t = clamp(dot(pa, ba)/dot(ba,ba), 0.11, .89);\n    return smoothstep(.1, .09, Manhattan(pa - ba*t));\n}\nfloat SegDisp( int key, vec2 p )\n{\n    float r = 0.0;\n    if ((key & 64) == 64) { r += Line(tl, tr, p);}\n    if ((key & 32) == 32) { r += Line(tl, ml, p);}\n    if ((key & 16) == 16) { r += Line(tr, mr, p);}\n    if ((key & 8 ) == 8 ) { r += Line(ml, mr, p);}\n    if ((key & 4 ) == 4 ) { r += Line(ml, bl, p);}\n    if ((key & 2 ) == 2 ) { r += Line(mr, br, p);}\n    if ((key & 1 ) == 1 ) { r += Line(bl, br, p);}\n    return r;\n}\nfloat dseg(vec2 p0, vec2 p1, vec2 p)\n{\n    vec2 dir = normalize(p1 - p0);\n    vec2 cp = (uv1 - ch_pos - p0) * mat2(dir.x, dir.y,-dir.y, dir.x);\n    return distance(cp, clamp(cp, vec2(0), vec2(distance(p0, p1), 0)));  \n}\n\nbool bit(int n, int b)\n{\n    return (n/b)*2!=n/(b/2);\n}\n\nfloat ddigit(int n, vec2 p)\n{\n    float v = 1e6;\n    vec2 cp = p - ch_pos;\n    float r = 0.0;\n    if (n == 0)         r +=  Line(vec2(-0.405, -1.000), vec2(-0.500, -1.000),p);\n    if (bit(n,  2))     r +=  Line(vec2( 0.500,  0.063), vec2( 0.500,  0.937),p);\n    if (bit(n,  4))     r +=  Line(vec2( 0.438,  1.000), vec2( 0.063,  1.000),p);\n    if (bit(n,  8))     r +=  Line(vec2(-0.063,  1.000), vec2(-0.438,  1.000),p);\n    if (bit(n,  16))    r +=  Line(vec2(-0.500,  0.937), vec2(-0.500,  0.062),p);\n    if (bit(n,  32))    r +=  Line(vec2(-0.500, -0.063), vec2(-0.500, -0.938),p);\n    if (bit(n,  64))    r +=  Line(vec2(-0.438, -1.000), vec2(-0.063, -1.000),p);\n    if (bit(n,  128))   r +=  Line(vec2( 0.063, -1.000), vec2( 0.438, -1.000),p);\n    if (bit(n,  256))   r +=  Line(vec2( 0.500, -0.938), vec2( 0.500, -0.063),p);\n    if (bit(n,  512))   r +=  Line(vec2( 0.063,  0.000), vec2( 0.438, -0.000),p);\n    if (bit(n,  1024))  r +=  Line(vec2( 0.063,  0.063), vec2( 0.438,  0.938),p);\n    if (bit(n,  2048))  r +=  Line(vec2( 0.0,  0.063), vec2( 0.000,  0.937),p);\n    if (bit(n,  4096))  r +=  Line(vec2(-0.063,  0.063), vec2(-0.438,  0.938),p);\n    if (bit(n,  8192))  r +=  Line(vec2(-0.438,  0.000), vec2(-0.063, -0.000),p);\n    if (bit(n,  16384)) r +=  Line(vec2(-0.063, -0.063), vec2(-0.438, -0.938),p);\n    if (bit(n,  32768)) r +=  Line(vec2( 0.000, -0.938), vec2( 0.000, -0.063),p);\n    if (bit(n,  65536)) r +=  Line(vec2( 0.063, -0.063), vec2( 0.438, -0.938),p);\n    ch_pos.x += ch_space.x;\n\n    return r;\n}\n\n////////////////////////////////////////////////////////////////\n// Ray Marching Functions\n////////////////////////////////////////////////////////////////\n\nvec2 map(vec3 po) { \n    vec3 p;\n    if(iMouse.z > 0.){\n        p = orbitControls(po);\n    }else{\n        p = rotY(po, .25 * sin(1.25*iTime));\n    }\n    \n    // front panel\n    float height = 0.3;\n    vec2 res=vec2(12,12); \n    float panel = sdRoundBox(rotX(p-vec3(0.,height,0.09),-90.*DTR),vec3(2.1,0.05,0.85),0.03);\n    if (panel < res.x) {res.y = 1.;};\n    res.x = panel;\n\n    // front panel outline\n    float d = sdRoundBox(p-vec3(0.,height,0.09),vec3(1.75,0.75,0.2),0.03);\n    res.y = mix ( 4.0, res.y, smoothstep(0.001,.0024,abs(d*0.1)));\n\n    // 7 segment display\n    float Segbox1 = sdRoundBox(rotX(p-vec3(-1.0,height+0.44,0.0),-90.*DTR),vec3(0.55,0.05,0.22),0.013);\n    if (Segbox1 < res.x) {res.y = 2.;};\n    res.x = opUnion(res.x, Segbox1);\n    \n    float SegboxIN = sdRoundBox(rotX(p-vec3(-1.0,height+0.44,0.0),-90.*DTR),vec3(0.53,0.05,0.20),0.013);\n    res.y = mix ( 5.0, res.y, smoothstep(0.001,.0024,abs(SegboxIN)));\n    if(sdObjects[0].switched ){\n        float di = 0.0;\n        float n = mod(iTime, 10000.0);\n        di += SegDisp(Encode(int(mod(n/1000.0, 10.0))), (p.xy+vec2(1.38, -0.74))*6.5);\n        di += SegDisp(Encode(int(mod(n/100.0, 10.0))), (p.xy+vec2(1.13, -0.74))*6.5);\n        di += SegDisp(Encode(int(mod(n/10.0 , 10.0))), (p.xy+vec2(0.88, -0.74))*6.5);\n        di += SegDisp(Encode(int(mod(n/1.0  , 10.0))), (p.xy+vec2(0.63, -0.74))*6.5);\n        di = smoothstep(0., 1.0, di);\n        res.y = mix ( 4.0, res.y, 1.0-di);\n    }\n\n    // knob\n    vec3 pt=p-vec3(1.,height,0.0);\n    float metal=2.0+step(length(pt.xy),.165);\n    float wave=metal*sin(length(pt.xy)*500.)/2000.;\n    float d2=length(pt.xy)-.25-.05*pt.z-.01*cos(18.*atan(pt.y,pt.x));\n    d2=max(d2,abs(pt.z)-.4-wave);\n    \n    // knob metal isolation\n    float d2c=length(pt.xy)-.31;\n    d2c=max(d2c,abs(pt.z)-.39);\n    float hole1=length(pt.xy)-.167;\n    d2c=min(d2c,hole1);\n    d2=max(d2,d2c);\n    \n    // knob foot\n    float d2b=length(pt.xy)-.31+.05*pt.z;\n    d2b=max(d2b,abs(pt.z)-.04);\n    d2=min(d2,d2b);\n    \n    if (d2 < res.x) {res.y = 2.;};\n    if(d2+0.4<res.x){res.y = metal;}\n    res.x = opUnion(res.x, d2);\n\n    // switches\n    for (int i = 0; i < OBJECTS; ++i){\n      float d=1.0;\n  \n      vec3 pt=p-vec3(-1.+float(i),height,0.0);\n      vec3 p1=p-vec3(-1.+float(i),height,0.0);\n \n      float hole=length(p1.xy)-.1;\n      d=max(d,-hole);\n      \n      float d2=length(p1.xy)-.13;// extra ring\n      d2=max(d2,abs(p1.z)-.11);\n      \n      pt.xy*=r2d(float(i)*0.4);\n      float d3=abs(pt.y)-.2;\n      pt.xy*=r2d(PI/3.*2.);\n      d3=max(d3,abs(pt.y)-.2);\n      pt.xy*=r2d(PI/3.*2.);\n      d3=max(d3,abs(pt.y)-.2);\n      d3=max(d3,abs(p1.z)-.03);\n\n      d2=min(d2,d3);\n      d2 += sdRoundedCylinder(rotX(p1,-90.*DTR),0.08,0.035,0.07);\n      d2=min(d2,d3);\n      d2=max(d2,-hole);\n      res.x=max(res.x,-hole);\n      float angle=-105.;\n      if(sdObjects[i].switched ) angle=-73.;\n \n      float d4 = sdRoundCone(rotX(p1,angle*DTR),0.06,0.09,0.5);\n      d2=min(d2,d4);\n      if (d2 < res.x) {res.y = 10.+float(i);};\n      res.x = opUnion(res.x, d2);\n   }\n   \n   // buttons\n   for(int i=0;i<3;i++){\n       float button = sdRoundBox(rotX(p-vec3(-1.+float(i),height-0.5,0.0),-90.*DTR),vec3(0.3,0.05,0.15),0.03);\n       if (button < res.x) {res.y = 2.;};\n       res.x = opUnion(res.x, button);  \n   }\n   \n   // button 16 segments text\n   float dd = 1e6;\n   for (int i = 0; i < OBJECTS; ++i){\n       if(i==0)ch_pos = vec2(1.05, 0.2);\n       if(i==1)ch_pos = vec2(0.1, 0.2);\n       if(!sdObjects[i].switched ){\n            dd = ddigit(0x00FF,(p.xy+vec2(ch_pos))*13.1);\n            dd += ddigit(0x101E,(p.xy+vec2(ch_pos))*13.1);\n            dd += ddigit(0x101E,(p.xy+vec2(ch_pos))*13.1);\n       res.y = mix ( 4.0, res.y, 1.0-dd);\n       }else{\n            dd = ddigit(0x00FF,(p.xy+vec2(ch_pos))*ch_size.y);\n            dd += ddigit(0x8899,(p.xy+vec2(ch_pos))*ch_size.y);\n       res.y = mix ( 4.0, res.y, 1.0-dd);\n       }\n    }\n    // panel box\n    float box = sdRoundBox(rotX(p-vec3(0.,height,0.64),-90.*DTR),vec3(1.8,0.5,0.8),0.05);\n    if (box < res.x) {res.y = 2.;};\n    res.x = opUnion(res.x, box);\n    \n    return res;\n}\n\nvec3 rayMarch(vec3 ro, vec3 rd) {\n    float d = 0.0;\n    float mat = 1.0;\n    float minDist = MAX_DIST;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        if (i >= MAX_STEPS ) break;\n        vec3 p = ro + rd * d;\n        vec2 ds = map(p);\n        d += LIPSCHITZ * ds.x;\n        mat = ds.y;\n        minDist = min(minDist, ds.x);\n        if (d >= MAX_DIST || ds.x < SURF_DIST) break;\n    }\n    return vec3(d, mat, minDist);\n}\n\nvec3 gradient(vec3 p) {\n    float epsilon = 0.0001;\n    vec3 dx = vec3(epsilon, 0., 0.0);\n    vec3 dy = vec3(0., epsilon, 0.0);\n    vec3 dz = vec3(0., 0.0, epsilon);\n\n    float ddx = map(p + dx).x - map(p - dx).x;\n    float ddy = map(p + dy).x - map(p - dy).x;\n    float ddz = map(p + dz).x - map(p - dz).x;\n    \n    return normalize(vec3(ddx, ddy, ddz));\n}\n\nvec3 rayDirection(vec2 p, vec3 ro, vec3 rt) {\n\n    // screen orientation\n    vec3 vup = vec3(0., 1.0, 0.0);\n    float aspectRatio = iResolution.x / iResolution.y;\n\n    vec3 vw = normalize(ro - rt);\n    vec3 vu = normalize(cross(vup, vw));\n    vec3 vv = cross(vw, vu);\n    float theta = radians(40.); // half FOV\n    float viewport_height = 2. * tan(theta);\n    float viewport_width = aspectRatio * viewport_height;\n    vec3 horizontal = -viewport_width * vu;\n    vec3 vertical = viewport_height * vv;\n    float focus_dist = length(ro - rt);\n    vec3 center = ro - vw * focus_dist;\n    vec3 rd = center + p.x * horizontal + p.y * vertical - ro;\n    return normalize(rd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = ((fragCoord / iResolution.xy - 0.5) * 2.0); // normalizing\n    vec2 aspect = iResolution.xy / iResolution.y;\n    uv1 = ( gl_FragCoord.xy / iResolution.y ) - aspect / 2.0;\n    uv1 *= 40.0 ;     //  set zoom size\n    \n    for (int i = 0; i < OBJECTS; ++i){\n        bool val = true;\n        if(KeyDown(KEY_A) && i==0){val=false;};\n        if(KeyDown(KEY_S) && i==1){val=false;};\n        sdObjects[i] = sdObject(bool(val) , i);\n    }\n    // Ray Marching\n    vec3 rt = vec3(0., 0.2, 0.);\n    vec3 ro = vec3(5., 3., -10.0);\n\n    vec3 rd = rayDirection(uv, ro, rt);\n    vec3 d = rayMarch(ro, rd);\n    \n    // Trace from cursor\n    vec2 m = (2.*iMouse.xy - iResolution.xy) / iResolution.xy;\n    vec3 rdm = rayDirection(m, ro, rt);\n    vec3 dm = rayMarch(ro, rdm);\n    \n    // Background\n    float v = length(uv) * .75;\n    fragColor = vec4(0.1,0.7,1.,1.);\n    fragColor += vec4(mix(0.2, 0.4, smoothstep(0.0, 1.0, uv.y)));\n    fragColor += vec4(mix(0.2, 0.4, smoothstep(0.0, 1.0, uv.x)));\n    \n    vec3 color;\n    float id = d.y;\n    \n    if (d.x <= 100.0) {\n        vec3 p = ro + rd * d.x;\n        vec3 p1 = ro * rd ;\n        vec3 N1 = gradient(p);\n        float light1 = dot(N1, normalize(vec3(1, 1,-1)))*.5+.5;\n        float light2 = dot(N1, normalize(vec3(-1, 1,-1)))*.5+.5;\n        vec3 illumination = 0.5 * vec3(light1) + 0.5 * vec3(light2);\n\n        color = vec3(150., 150., 150.) / 255.;\n        vec3 colormat1 = vec3(1.0,1.0,0.0);\n        vec3 colormat2 =  vec3(0.038,0.048,0.0);\n        vec3 highlight = color * vec3(1.5,1.5,1.);\n        float specm = 0.25;\n        if (id == -1.0) color = vec3(0., 0., 0.);\n        if (id == 1.0 ){ specm = 0.09;};\n        if (id == 2.0 ){ color = colormat2;specm = 0.01;};\n        if (id == 4.0 ){ color = colormat1;specm = 0.01;};\n        if (id == 5.0 ){ color = vec3(.8, 0.1, 0.2);specm = 0.5;};\n        if (id == 6.0 ){ color = vec3(2.0, 2.1, 2.2);specm = 0.5;};\n        if (id == 10.0 ||id == 11.0||id == 12.0 ){\n\n            vec3 basecol=vec3(.2);\n            vec3 speccol=vec3(1.8);\n            float  specpow=7.;\n            float ndelta=3E-2;\n            vec3 n = vec3(0.4,1,0);\n            vec3 v=-rd;\n            vec3 l=normalize(vec3(1,1,-5));\n            vec3 h=normalize(l+v);\n            float dotnl=max(0.,dot(N1,l));\n            float dotnh=max(0.,dot(N1,h));\n\n            vec3 diff=basecol/PI;\n            vec3 spec=speccol*pow(dotnh,specpow);\n            color =dotnl*(diff+spec);\n            color=pow(color,vec3(.4545));\n            color=smoothstep(vec3(0,-.1,-.2),vec3(1,1.1,1.2),color);\n         }\n         if (iMouse.z > 0.) {\n            if (id == 10.0 && dm.y == 10.) {color = highlight;};\n            if (id == 11.0 && dm.y == 11.) {color = highlight;};\n         }\n         \n        color *= illumination; \n\n        // Specular highlights\n        vec3 R1 = reflect(normalize(vec3(1.,0.,0.)), N1);\n        vec3 specular = vec3(1.0) * pow(max(dot(R1, rd), 0.0), 30.);\n        color += specular * specm;\n        \n        // fake fresnel\n        float nDotV = dot(N1, rd) + 1.;\n        color += nDotV * nDotV * 0.45;\n        \n        fragColor = vec4(color, 1.0); \n    }\n \n}","name":"Image","description":"","type":"image"}]}