{"ver":"0.1","info":{"id":"Wl3fW4","date":"1612704722","viewed":131,"name":"Omg it's infinite cubes","username":"VinesOfCode","description":"and they're rotating.\n\nLearning shader programming and playing around with raymarching.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","reflection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":" /*\n    Raymarching with rounded cubes to illustrate\n    - infinite number of objects because it's not necessary to model the \n      scene with all objects per loops but use distance to nearest object instead. \n    - roundness of cubes edges comes with almost zero cost.\n    - reflection\n    \n    For nicer visuals:\n    - cube rotation!\n    - shift of the object coordinates (with y-shift dependent on x)\n    - object density on y axis decreased by factor\n    - 3d checker pattern (needs to take into account the shift)\n    - color cycling\n    - camera angle and camera zoom cycling\n    - simple and unrealistic diffuse lighting with squaring for more contrast\n    Due to shifting and rotation, its not straight forward to get the nearest object,\n    instead of caculating correctly, the effect of potential error is mitigated\n    by a factor on the ray marching step distance, unless close enough\n*/\n\n#define maxSteps 50.   // max raymarching steps\n#define maxRayLen 50.  // max raymarching ray lenght \n#define reflections 2  // max number of reflections\n#define eps 0.001      // 'very' small number, 'almost' zero\n#define PI 3.1416128\n#define yStep 1.4      // factor for y-axis steps\n#define yLevel0 -2.    // max y level with objects (pre shift), nothing above, but camera above\n#define waves 0.4      // factor on sinus for y-shift\n#define v3null vec3(0., 0., 0.)\n#define cubeSize      0.12 * vec3(1., 1., 1.) \n#define cubeRoundness 0.07\n#define lightPos vec3(-3.,5.,-1.) // diffuse light\n\n/* return 'integer' index for y with 0 at yLevel0, \n   called roundY because round gives the index for x / z */\nfloat roundY(float y)\n{\n    return round((y - yLevel0) / yStep);\n}\n\n/* y value of closest y level (with integer index) */\nfloat roundedY(float y)\n{\n    return yLevel0 + (roundY(y) * yStep );\n}\n\nvec3 rotX(vec3 coord, vec3 center, float phi)\n{\n    return vec3(\n        coord.x,\n        center.y +(coord.y - center.y)*cos(phi)\n                 -(coord.z - center.z)*sin(phi),\n        \n        center.z +(coord.y - center.y)*sin(phi)\n                 +(coord.z - center.z)*cos(phi));\n}\n\nvec3 rotZ(vec3 coord, vec3 center, float phi)\n{   // = rotX(coord.zxy , center, phi).yzx;\n    return vec3(\n        center.x +(coord.x - center.x)*cos(phi)\n                 -(coord.y - center.y)*sin(phi),\n        center.y +(coord.x - center.x)*sin(phi)\n                 +(coord.y - center.y)*cos(phi),\n        coord.z);\n}\n\nvec3 rotY(vec3 coord, vec3 center, float phi)\n{\n    return vec3(\n        center.x +(coord.x - center.x)*cos(phi)\n                 -(coord.z - center.z)*sin(phi),\n        coord.y,\n        center.z +(coord.x - center.x)*sin(phi)\n                 +(coord.z - center.z)*cos(phi));\n}\n\n/* time and location dependent shift */\nvec3 getShift (vec3 p) \n{\n    float xIndex = round(p.x);\n    return vec3(\n            sin(iTime * .4) * 3., \n            sin(xIndex + iTime) * waves, // y-shift depends on xIndex\n            -iTime * 2.);\n}\n\n/* get original point from shifted (inverse of getShift) */\nvec3 getPFromShifted (vec3 p) \n{\n    float xShift   = sin(iTime * .4) * 3.;\n    float oriX = p.x - xShift;\n    float xIndex = round(oriX);\n    return vec3(\n            oriX, \n            p.y - sin(xIndex + iTime) * waves,\n            p.z + iTime * 2.);\n}\n\n/* distance from box at <0,0,0> with border size b per axis */\nfloat distBox(vec3 p, vec3 b )\n{\n    return length(max(abs(p) - b, 0.0));\n}\n\n/* distance from rotating rounded cube, center 0,0,0 \n    obj center is only for pos/index dependent rotation */\nfloat distObject(vec3 p, vec3 objCenter) {\n    vec3 pRot = rotX(\n            rotY(p, v3null, iTime + 0.2 * objCenter.z), \n            v3null, iTime * .5);\n    return distBox (pRot, cubeSize) - cubeRoundness; \n}\n\n/* distance from close object in relevant layer\n   it is based on rounding position to index, close is not closest, but not too bad */\nfloat distObjLayers(vec3 p) {\n    vec3 o = getPFromShifted(p); // calculating distance to shifted object, o is the corresponding unshifted position\n    vec3 c = vec3(round(o.x), roundedY(o.y), round(o.z)); // original unshifted center (xyz-index)\n    if (c.y  > yLevel0 + eps) c.y = yLevel0; // nothing above us\n    return distObject(o - c, c);\n}\n\n\nfloat distBigObject(vec3 p) {\n    vec3 pos = vec3(2.,1.5,1.5);\n    float d1 = distBox(rotY(rotX(p, pos, 0.3+sin(iTime*0.5)*0.4), pos, iTime) - pos, vec3(1.,1.,1.)*1.1) ;\n    return d1 -0.02;\n}\n\nvec2 normCoord(vec2 coord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv  = coord/iResolution.xy;\n    //Shift to center\n    uv.xy -= vec2(.5, .5);\n\t//Rescale axis\n    uv.x *= iResolution.x/iResolution.y;\n    return uv * 2.; // y: [-1 : +1]\n}\n\n\n\n/* ~ distance of point to scene */\nfloat dist(vec3 p) {\n    return min(distObjLayers(p), distBigObject(p));\n}\n\n/* normal vector to scene */\nvec3 distNorm (vec3 p)\n{\n    float d = dist(p);\n    \n    vec3 n  = vec3(d - dist(p-vec3(eps, 0.,  0. )),\n                   d - dist(p-vec3(0.,  eps, 0. )),\n                   d - dist(p-vec3(0.,  0.,  eps)));\n    return normalize(n);\n}\n\nstruct Hit \n{\n    vec3 p; // point on surface\n    vec3 n; // normal vector (normalized)\n    float l; // ray length\n    int nSteps;\n};\n\n\n/* dot product of normalized light vector and scene normal vector */\nfloat diffuseLight (Hit h)\n{\n    return dot(h.n, normalize(lightPos - h.p));\n}\n\n/* raymarching, return hit position, normal and ray lenght */\nHit rayMarch(vec3 p0, vec3 normRayDir)\n{\n    vec3  p      = p0;\n    float d      = dist(p);\n    float rayLen = 0.;\n    int n = 0;\n    for (float i = 0.; i < maxSteps; i++)\n    {\n        d = dist(p);\n        d = (d > 0.1) ? d *.8 : d; // above dist 0.1, scale step down because dist can give a distance to the not closest bust quite close object\n        p += normRayDir * d;\n        rayLen += d;\n        if ( rayLen > maxRayLen || d < 0.005)\n            break;\n        n++;\n    }\n    return Hit(p, distNorm(p), rayLen, n);\n}\n\n/* return color for a hit on object */ \nvec3 getColor(Hit h) \n{    \n    float b = diffuseLight(h) * smoothstep(11., 0.5, h.l + 0.2);\n    b +=.25; // brightness\n    b *= b;  // drama\n    if (h.p.y > yLevel0 +1.+waves)\n        return vec3(1., 1., 1.) *.9*b;\n    \n    vec3 pOri = getPFromShifted(h.p); // object colors based on xyz-index, need original position \n\n    float fCont =  mod(pOri.x + pOri.z + (yLevel0 + pOri.y) / yStep, 2.);\n    float fDisc =  mod(round(pOri.x) + round(pOri.z) + roundY(pOri.y), 2.);\n    float checker = 0.; //fCont;//fDisc;\n    \n    return vec3(b * fDisc , b*(0.5+0.5*abs(sin(iTime+checker*PI *0.5))), b*(0.5+0.5*abs(cos(iTime+checker*PI*0.5))));\n}\n\n/* return normalized reflection vector of r, n is normal of reflecting surface*/\nvec3 getReflectionRay(vec3 n, vec3 r) {\n    return r - 2. * dot(r, n) * n;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2  uv   = normCoord(fragCoord);\n\n    // Camera setup\n    float angX = .7 + sin(iTime) * 0.2;  // camera rotation X - time dependent\n    float angZ = sin(iTime * 0.3) * 0.4; // camera rotation Z - time dependent\n    vec3  cam  = rotZ(rotX(vec3 (0., 1., -5.), v3null, angX), v3null, angZ);\n    float cs   = 2.5 + sin(iTime * 0.3) * 1.3; // camera zoom (time dependent)\n    vec3  rayDir     = rotZ(rotX(cs * vec3(uv.x, uv.y, 0.),v3null, angX), v3null, angZ) - cam;\n    vec3  p    = cam + rayDir * 0.5; // image plane can intersect with objects, goingonly 0.5 times ray dir helps\n    \n    // Ray marching\n    rayDir = normalize(rayDir);\n    Hit  h   = rayMarch(p, rayDir);\n    vec3 col = getColor(h);\n    \n    // Reflections\n    float b = length(col); \n    for (int i = 0; i < reflections && h.l < maxRayLen; i++)\n    {\n        vec3 rayDir = getReflectionRay(h.n, rayDir);\n        h = rayMarch(h.p+ 0.1*rayDir, rayDir);\n        col += b * (1./(1.+h.l)) *min(getColor(h), vec3(1.,1.,1.));\n        col = min(col, vec3(1., 1., 1.));\n        b*=length(col);\n    }\n    \n    fragColor = vec4(col, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}