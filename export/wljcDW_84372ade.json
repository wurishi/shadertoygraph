{"ver":"0.1","info":{"id":"wljcDW","date":"1594470544","viewed":184,"name":"Raymarched 3D Voronoi","username":"bekorn","description":"Both sample the same voronoi pattern. Left side is distance to center, right side is distance to edge. \n\nDeveloped at https://www.twitch.tv/bekorn\n\nIf you have any ideas for optimization, I would be glad to hear them ^^","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 3D Voronoi without Raymarching:\n// https://www.shadertoy.com/view/tlScWy\n\n// To visualize raymarch step count\n#define DEBUG_\n\nfloat GetDist(vec3 p)\n{\n    float dist = MAX_DIST;\n\n    //\tLeft side, center distance\n    {\n        vec3 c = vec3(-1.1, 0, 1);\n        float sphere_dist = SphereDist(p, c, 1.);\n        float inner_sphere_dist = SphereDist(p, c, 0.92);\n        float hollow_sphere_dist = max(sphere_dist, -inner_sphere_dist);\n\n        // optimization\n        if (hollow_sphere_dist <= MIN_DIST * 2.)\n        {\n            float voronoi_scale = cos(iTime / 6.) * 5. + 2.;\n            vec3 voronoi_color; // not used\n            float voronoi_dist = VoronoiDist(p * voronoi_scale, 0.4, voronoi_color);\n            voronoi_dist /= voronoi_scale;\n\n            dist = min(dist, max(voronoi_dist, hollow_sphere_dist));\n        }\n        else\n        {\n            dist = min(dist, hollow_sphere_dist);\n        }\n    }\n    \n    //\tRight side, edge distance\n    {\n        vec3 c = vec3(1.1, 0, 1);\n        float sphere_dist = SphereDist(p, c, 1.);\n        float inner_sphere_dist = SphereDist(p, c, 0.92);\n        float hollow_sphere_dist = max(sphere_dist, -inner_sphere_dist);\n        \n        // optimization\n        if (hollow_sphere_dist <= MIN_DIST * 2.)\n        {\n            float voronoi_scale = cos(iTime / 6.) * 5. + 2.;\n            vec3 voronoi_color; // not used\n            float voronoi_dist = VoronoiEdgeDist(p * voronoi_scale, 0.08, voronoi_color);\n            voronoi_dist /= voronoi_scale;\n\n            dist = min(dist, max(voronoi_dist, hollow_sphere_dist));\n        }\n        else\n        {\n            dist = min(dist, hollow_sphere_dist);\n        }\n    }\n    \n    return dist;\n}\n\nvec3 GetColor(vec3 p)\n{\n    vec3 color;\n    \n    float voronoi_scale = cos(iTime / 6.) * 5. + 2.;\n    VoronoiDist(p * voronoi_scale, 0., color);\n    \n    return color;\n}\n\nvec3 GetNormal(vec3 p)\n{\n    vec2 delta = vec2(MIN_DIST, 0.);\n    \n    float dist = GetDist(p);\n    \n    vec3 n = dist - vec3(\n        GetDist(p - delta.xyy),\n        GetDist(p - delta.yxy),\n        GetDist(p - delta.yyx)\n    );\n    \n    return normalize(n);\n}\n\nfloat RayMarchDist(vec3 ray_origin, vec3 ray_dir)\n{\n    float dist = 0.;\n    \n    for (int i=0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ray_origin + ray_dir * dist;\n        \n        float nearest = GetDist(p);\n        \n        if (nearest < MIN_DIST)\n            break;\n        \n        dist += nearest;\n        \n        if (dist > MAX_DIST)\n            break;\n    }\n    \n    return dist;\n}\n\nfloat RayMarchStepCount(vec3 ray_origin, vec3 ray_dir)\n{\n    float dist = 0.;\n    \n    int i;\n    for (i=0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ray_origin + ray_dir * dist;\n        \n        float nearest = GetDist(p);\n        \n        if (nearest < MIN_DIST)\n            break;\n        \n        dist += nearest;\n        \n        if (dist > MAX_DIST)\n            break;\n    }\n    \n    return float(i);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy / 2.) / iResolution.y;\n    vec2 normalized_mouse = iMouse.xy / iResolution.xy - 0.5;\n    \n\tvec3 color;\n    \n    vec3 ray_origin = vec3(0, 0, -2);\n    vec3 ray_dir = normalize(vec3(uv.x, uv.y, 1));\n        \n#ifdef DEBUG\n    float _stepCount = RayMarchStepCount(ray_origin, ray_dir);\n\n    const vec4 _low = vec4(0, 1, 0, 1);\n    const vec4 _mid = vec4(0, 0, 1, 1);\n    const vec4 _high = vec4(1, 0, 0, 1);\n\n    const float _MAX_STEPS_LOW  = float(MAX_STEPS) / 16.;\n    const float _MAX_STEPS_MID  = float(MAX_STEPS) / 4.;\n    const float _MAX_STEPS_HIGH = float(MAX_STEPS);\n\n    if (_stepCount < _MAX_STEPS_LOW)\n        fragColor = mix(vec4(0), _low, _stepCount / _MAX_STEPS_LOW);\n    else if (_stepCount < _MAX_STEPS_MID)\n        fragColor = mix(_low, _mid, (_stepCount - _MAX_STEPS_LOW) / (_MAX_STEPS_MID - _MAX_STEPS_LOW));\n    else\n        fragColor = mix(_mid, _high, (_stepCount - _MAX_STEPS_MID) / (_MAX_STEPS_HIGH - _MAX_STEPS_MID));\n\n    return;\n#endif\n\n\tfloat dist = RayMarchDist(ray_origin, ray_dir);\n    \n    if (dist > MAX_DIST)\n    {\n        color = vec3(1, 1, 0.4);\n    }\n    else\n    {\n        vec3 light_p = vec3(0, 2, -4);\n        \n        vec3 p = ray_origin + ray_dir * dist;\n    \tvec3 n = GetNormal(p);\n        vec3 surface_color = GetColor(p);\n        \n        vec3 to_light = normalize(light_p - p);\n        color = (dot(n, to_light) + 0.2) * surface_color * 1.1;\n        \n        //\tsimple fog, puts contrast between front and back\n        color *= smoothstep(5., 2.3, dist);\n    }\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MAX_STEPS 128\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n\nvec3 R33(vec3 p)\n{\n\tvec4 a = fract(p.xzyx * vec4(123.34, 234.34, 345.65, 987.54));\n    a += dot(a, a + 34.45);\n    return fract(vec3(a.x * a.w, a.y * a.z, a.z * a.w));\n}\n\nfloat SphereDist(vec3 p, vec3 c, float r)\n{\n    return length(p - c) - r;\n}\n\n// https://youtu.be/l-07BXzNdPw, Voronoi Explained! - The Art of Code\nfloat VoronoiDist(vec3 p, float threshold, out vec3 color)\n{\n    float min_dist = MAX_DIST;\n        \n    vec3 local_p = fract(p); // range [0., +1.]\n    \n    for(int x = -1; x <= 1; x++)\n        for(int y = -1; y <= 1; y++)\n            for(int z = -1; z <= 1; z++)\n            {\n                vec3 offset = vec3(x, y, z);\n                vec3 id = floor(offset + p);\n\n                vec3 local_center = R33(id);\n                vec3 center = id + local_center;\n                \n                float dist = length(p - center);\n                \n                if (dist < min_dist)\n                {\n                    min_dist = dist;\n                    color = R33(id);\n                }\n            }\n    \n    return min_dist - threshold;\n}\n\n// https://github.com/blender/blender/blob/2d1cce8331f3ecdfb8cb0c651e111ffac5dc7153/intern/cycles/kernel/shaders/node_voronoi_texture.osl\nfloat VoronoiEdgeDist(vec3 p, float threshold, out vec3 color)\n{\n    vec3 local_p = fract(p); // range [0., +1.]\n    \n  \tvec3 vector_to_closest;\n    float min_dist = MAX_DIST;\n    \n    for (int x = -1; x <= 1; x++)\n        for (int y = -1; y <= 1; y++)\n            for (int z = -1; z <= 1; z++)\n            {\n                vec3 offset = vec3(x, y, z);\n                vec3 id = floor(offset + p);\n\n                vec3 local_center = R33(id);\n                vec3 center = id + local_center;\n\n                vec3 point_to_center = center - p;\n                float dist = length(point_to_center);\n\n                if (dist < min_dist)\n                {\n                    min_dist = dist;\n                    color = R33(id);\n                    vector_to_closest = point_to_center;\n                }\n            }\n\n    \n    min_dist = MAX_DIST;\n    \n    for (int x = -1; x <= 1; x++)\n        for (int y = -1; y <= 1; y++)\n            for (int z = -1; z <= 1; z++)\n            {\n                vec3 offset = vec3(x, y, z);\n                vec3 id = floor(offset + p);\n                \n                vec3 local_center = R33(id);\n                vec3 center = id + local_center;\n                \n                vec3 point_to_center = center - p;\n\n                vec3 perpendicularToEdge = point_to_center - vector_to_closest;\n                \n                if (length(perpendicularToEdge) < 0.01)\n                    continue;\n\n                float distanceToEdge = dot(\n                    (vector_to_closest + point_to_center) / 2.0,\n                    normalize(perpendicularToEdge)\n                );\n                \n                min_dist = min(min_dist, distanceToEdge);\n            }\n\n    return min_dist - threshold;\n}\n","name":"Common","description":"","type":"common"}]}