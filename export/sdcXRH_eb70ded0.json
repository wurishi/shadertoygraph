{"ver":"0.1","info":{"id":"sdcXRH","date":"1632598830","viewed":383,"name":"Volumetric rain","username":"sergei_am","description":"Ray-marched rain volume + water puddles","likes":16,"published":1,"flags":32,"usePreview":0,"tags":["rain","volumetrics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int\tNUM_PLANES = 32;\nconst vec3\tRAIN_COLOR = vec3(0.6,0.8,1.0);\nconst vec2  RAIN_WIND_SPEED = vec2(-0.5, -0.8);\nconst vec4  RAIN_PARAMS = vec4(1.6, 0.05, 0.8, 4.0);\nconst float RAIN_OPACITY = 1.55;\n\nconst float CAMERA_RADIUS = 30.0;\nconst float CAMERA_SPEED = 0.2;\nconst float CAMERA_HEIGHT = 12.0;\n\n\n\n\nfloat sample_rain(in float u, in float v, in float scaling, in vec4 uvParams, in float noise, in vec2 pos_xz)\n{\n    u *= uvParams.x;\n    v *= uvParams.y;\n    \n    v += fract(noise*193.324121)*0.3455;\n    \n    u *= scaling;\n    v *= scaling;\n    v += iTime*uvParams.z;\n\n\tfloat tex = texture(iChannel0, vec2(u, v)).x;\n    tex = pow( tex, uvParams.w);\n    \n    float ws_noise = sin(pos_xz.x / 1.1) * sin(pos_xz.y / 1.1) * 0.001;\n    float wind = texture(iChannel0, vec2(u*0.005, v*0.2 + 10.2*ws_noise)).x;\n    wind = pow(wind, 6.0);\n    tex *= wind;\n    \n    ws_noise = sin(pos_xz.x / 6.1) * sin(pos_xz.y / 6.1) * 0.001;\n    wind = texture(iChannel0, vec2(u*0.001, v*0.02 + 3.2*ws_noise)).x;\n    wind = pow(wind, 6.0);\n    tex *= 0.7*wind + 0.3;\n   \n    return tex;\n}\n\nfloat fade(float x, float dist)\n{\n    //return 1.0* min( dist*0.5, 1.0);\n    //return x;\n    return pow( x, 0.5 ) * min( dist*0.5, 1.0);\n}\n\nfloat noise(float x)\n{\n    return 1.0 + sin(floor(x - 0.1)*4.0)*0.224;\n}\n\nfloat trace_rain_volume(in vec3 eye, in vec3 ray, in float cell_size, in vec4 uvParams, in float max_dist )\n{\n    //eye.xz += RAIN_WIND_SPEED * iTime;\n    \n    vec3 aray = abs(ray);\n\tvec3 eye_pos = eye * (1.0 / cell_size);\n    vec3 pos = eye_pos;\n   \n\tfloat dist = 0.0;\n    float rain = 0.0;\n    float scaling = 1.0;\n    \n    // raycast through unit-sized 3d grid, intersecting XY and ZY planes\n    for( int i=0; i<NUM_PLANES; ++i )\n    {\n        if(length(pos - eye_pos)*cell_size > max_dist) break;\n    \n        float fx = fract(pos.x);\n        float fz = fract(pos.z);\n        \n        if(ray.x > 0.0) fx = 1.0 - fx;\n        if(ray.z > 0.0) fz = 1.0 - fz;\n        \n        if( fx * aray.z > fz * aray.x)  // fx / fz > |ray.x| / |ray.z| -> ray is intersecting X axis\n        {\n            dist += fz;\n            pos += vec3( ray.xy * fz / aray.z, ray.z * (fz + 0.001) / aray.z);\n     \t\train += (1.0-rain)*sample_rain(pos.x, pos.y, scaling, uvParams, pos.z, pos.xz) * fade(min(aray.x, aray.z), dist);\n        }\n        else\n        {\n            dist += fx;\n            pos += vec3( ray.x * (fx + 0.001) / aray.x, ray.yz * fx / aray.x );\n            rain += (1.0-rain)*sample_rain(pos.z, pos.y, scaling, uvParams, pos.x, pos.xz) * fade(min(aray.x, aray.z), dist);\n        }\n        scaling *= 1.0;\n    }\n    return rain;\n}\n\nvec2 rotate( vec2 v, float angle )\n{\n    float s = sin( angle * 6.2830 / 180.0 );\n    float c = cos( angle * 6.2830 / 180.0 );\n    return vec2( v.x*c - v.y*s, v.x*s + v.y*c );\n}\n\nfloat sdf_scene( vec3 pos )\n{\n    float h = sin(pos.x / 2.0)*sin(pos.z / 2.0)*2.0;\n    h += sin(pos.x / 5.13)*sin(pos.z / 4.73)*3.2;\n    h += sin(pos.x / 0.6)*sin(pos.z / 0.78)*0.3;\n    \n    h = max( h, -1.0 );\n    \n    return pos.y - h;\n}\n\nvec3 scene( vec3 eye, vec3 dir, out vec3 N )\n{\n    float t = 0.0;\n    for(int i=0; i<120; ++i )\n    {\n        float d = sdf_scene(eye + dir * t);\n        if(abs(d) < 0.5 ) break;\n        t += d*0.2;\n    }\n    \n    vec3 hit = eye + dir * t;\n    \n    float d = sdf_scene(hit);\n    \n    float ns = 0.1;\n    \n    N = vec3(ns,0,0) * (sdf_scene(hit + vec3(ns,0,0)) - d);\n    N += vec3(0,ns,0) * (sdf_scene(hit + vec3(0,ns,0)) - d);\n    N += vec3(0,0,ns) * (sdf_scene(hit + vec3(0,0,ns)) - d);\n    N += vec3(0,0,-ns) * (sdf_scene(hit + vec3(0,0,-ns)) - d);\n    N += vec3(0,-ns,0) * (sdf_scene(hit + vec3(0,-ns,0)) - d);\n    N += vec3(-ns,0,0) * (sdf_scene(hit + vec3(-ns,0,0)) - d);\n    \n    N = normalize(N);\n    \n    return eye + dir*t;\n}\n\nfloat detail( float x, float y)\n{\n    return texture(iChannel0, vec2(x,y)).x*0.5 + 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 eye = vec3(cos(iTime*CAMERA_SPEED)*CAMERA_RADIUS*0.3, CAMERA_HEIGHT, sin(iTime*CAMERA_SPEED)*CAMERA_RADIUS);\n    vec3 dir = vec3(uv.x - 0.5, uv.y - 0.5, 1.0 );\n    \n    dir.yz = rotate( dir.yz, 10.0 + 6.0*sin(iTime/10.0) );\n    dir.xz = rotate( dir.xz, 30.0 + 6.0*sin(iTime/5.0) );\n    \n    vec3 N;\n    vec3 hit = scene( eye, dir, N );\n    \n    float depth = length(hit - eye);\n    \n    vec3 tilt_eye = eye;\n    vec3 tilt_dir = dir;\n    \n    tilt_eye.zy = rotate(tilt_eye.zy, 15.0);\n    tilt_dir.zy = rotate(tilt_dir.zy, 15.0);\n    \n    \n    float r = trace_rain_volume(tilt_eye, tilt_dir, 1.0, RAIN_PARAMS, length(hit - eye));\n    \n    vec3 L = vec3(0.55,0.45,0.25);\n    \n    vec3 Lighting = vec3(0.4, 0.6, 1.0);\n    \n    float LightingPower = max( (abs(sin(iTime/2.0)) - 0.998), 0.0 ) * 300.0;\n    LightingPower += max( (abs(sin(iTime/2.37)) - 0.998), 0.0 ) * 300.0;\n    LightingPower += max( (abs(sin(iTime/2.67)) - 0.996), 0.0 ) * 300.0;\n    \n    vec3 ground_color = mix( vec3(0.4,0.1, 0.0), vec3(1.5, 1.1, 0.1), (3.0 + hit.y) / 6.0 );\n    \n    vec2 water_uv = vec2(fract(hit.x/10.0), fract(hit.z/10.0));\n    \n    vec3 col = ground_color * L * max( 0.0, dot( N, normalize(vec3(1.0, 3.0, -1.0))));\n    \n    col *= detail(hit.x, hit.z);\n    \n    float ripple = texture(iChannel1, water_uv).x;\n    vec3 water = vec3(ripple*0.4, ripple*0.6, ripple);\n    \n    col = mix( col, water, max(-hit.y, 0.0));\n    \n    col += Lighting * LightingPower * max(0.0, dot(N, vec3(1.0, 1.0, 1.0)));\n    \n    col = mix(vec3(0.5,0.6,0.7), col, exp(-length(hit - eye)*0.03));\n    \n    col += vec3(0.5, 0.7, 1.0) * min(r*RAIN_OPACITY, RAIN_OPACITY);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float h = texture(iChannel0, uv).x;\n    \n    float noise = sin( uv.x * 34.23 + iTime*11.12 ) * sin( uv.y * 26.45 - iTime * 53.45);\n    noise *= sin( uv.y * 53.0 + iTime*10.77) * sin( uv.x * 24.0 - iTime*43.23);\n    noise = min( max( noise - 0.96, 0.0 ) * 200.0, 1.0 );\n    \n    h += noise;\n    \n    fragColor = vec4(h, h, h, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 su = vec2(1.0 / iResolution.x, 0.0);\n    vec2 sv = vec2(0.0, 1.0/iResolution.y);\n    \n    float avg_h = (\n        texture(iChannel0, uv + su).x +\n        texture(iChannel0, uv + sv).x +\n        texture(iChannel0, uv - su).x +\n        texture(iChannel0, uv - sv).x\n    ) * 0.25;\n    \n    float h = texture(iChannel0, uv).x;\n    \n    float v = (texture(iChannel1, uv).x - 0.5) * 2.0;\n    \n    float next = v + (avg_h - h)*0.99;\n    \n    next = next*0.5 + 0.5;\n    \n    if(next < 0.01 ) next = 0.5;\n     \n    fragColor = vec4(next, next, next, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 su = vec2(1.0 / iResolution.x, 0.0);\n    vec2 sv = vec2(0.0, 1.0/iResolution.y);\n    \n    float f = (\n        texture(iChannel0, uv + su).x +\n        texture(iChannel0, uv + sv).x +\n        texture(iChannel0, uv - su).x +\n        texture(iChannel0, uv - sv).x\n    ) * 0.25;\n    \n    float h = texture(iChannel0, uv).x;\n    float v = (texture(iChannel1, uv).x - 0.5)*2.0;\n    \n    h += v;\n    \n    h = mix( h, 0.5, 0.02 );\n    \n    fragColor = vec4(h, h, h, 1.0);\n}","name":"Buffer C","description":"","type":"buffer"}]}