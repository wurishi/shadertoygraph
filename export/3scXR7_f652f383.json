{"ver":"0.1","info":{"id":"3scXR7","date":"1571682630","viewed":498,"name":"Exoplanets","username":"mhnewman","description":"Tour a series of procedurally generated exoplanets.\nFast enough for FULLSCREEN!","likes":29,"published":1,"flags":0,"usePreview":0,"tags":["procedural","planets","saturn","jupiter","uranus","exoplanets","moons"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const bool GO_CRAZY = false;\n\nconst float tau = 6.283185;\n\nfloat hash1(float p) {\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash1(float p, float q) {\n    vec3 p3  = fract(vec3(p, q, p) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash2(float p) {\n    vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hash2(float p, float q) {\n    vec3 p3 = fract(vec3(p, q, p) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 hash3(float p) {\n    vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec3 hash3(vec3 p3) {\n    p3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec4 hash4(float p) {\n    vec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);    \n}\n\nfloat noise1(float p) {\n    float i = floor(p);\n    float f = fract(p);\n    float u = f * f * (3.0 - 2.0 * f);\n    return 1.0 - 2.0 * mix(hash1(i), hash1(i + 1.0), u);\n}\n\nvec3 noise3(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return 1.0 - 2.0 * mix(mix(mix(hash3(i + vec3(0.0, 0.0, 0.0)), \n                                   hash3(i + vec3(1.0, 0.0, 0.0)), u.x),\n                               mix(hash3(i + vec3(0.0, 1.0, 0.0)), \n                                   hash3(i + vec3(1.0, 1.0, 0.0)), u.x), u.y),\n                           mix(mix(hash3(i + vec3(0.0, 0.0, 1.0)), \n                                   hash3(i + vec3(1.0, 0.0, 1.0)), u.x),\n                               mix(hash3(i + vec3(0.0, 1.0, 1.0)), \n                                   hash3(i + vec3(1.0, 1.0, 1.0)), u.x), u.y), u.z);\n}\n\nfloat fbm1(float p) {\n    float f = noise1(p); p = 2.0 * p;\n    f += 0.5 * noise1(p); p = 2.0 * p;\n    f += 0.25 * noise1(p); p = 2.0 * p;\n    f += 0.125 * noise1(p); p = 2.0 * p;\n    f += 0.0625 * noise1(p);\n    return f / 1.9375;\n}\n\nconst mat3 m = mat3( 0.51162, -1.54702,  1.15972,\n                    -1.70666, -0.92510, -0.48114,\n                     0.90858, -0.86654, -1.55678);\n\nvec3 fbm3(vec3 p) {\n    vec3 f = noise3(p); p = m * p;\n    f += 0.5 * noise3(p); p = m * p;\n    f += 0.25 * noise3(p); p = m * p;\n    f += 0.125 * noise3(p); p = m * p;\n    f += 0.0625 * noise3(p);\n    return f / 1.9375;\n}\n\nvec3 uniform3(float seed) {\n    vec2 hash = hash2(seed);\n    float x = 2.0 * hash.x - 1.0;\n    float r = sqrt(1.0 - x * x);\n    float t = tau * hash.y;\n    return vec3(x, r * sin(t), r * cos(t));\n}\n\nvec3 hsv(float hue, float sat, float val) {\n    return (val) * (vec3(1.0 - (sat)) + (sat) * (0.5 + 0.5 * cos(6.2831853 * (vec3(hue) + vec3(0.0, 0.33, 0.67)))));\n}\n\nvec4 newMoon(float moonCount, vec3 pole, float seed, float moon) {\n    vec3 pos = uniform3(seed);\n    pos -= 0.75 * pole * dot(pole, pos);\n    pos = normalize(pos);\n    pos *= 1.5 + 2.0 * hash1(seed + 0.001);\n    pos *= step(moon, moonCount);\n    float r = 0.02 + 0.1 * pow(hash1(seed + 0.002), 6.0);\n    return vec4(pos, r);\n}\n\n#define hitMoon(moon, seed) { \\\n    vec3 v = eye - moon.xyz; \\\n    float b = dot(v, ray); \\\n    float c = dot(v, v) - moon.w * moon.w; \\\n    float h = b * b - c; \\\n    float mHit = step(0.0, h); \\\n    h = max(h, 0.0); \\\n    float mDepth = -b - sqrt(h); \\\n    vec3 p = eye + mDepth * ray; \\\n    vec3 mNorm = normalize(p - moon.xyz); \\\n    mHit *= step(mDepth, moonDepth); \\\n    moonDepth = mix(moonDepth, mDepth, mHit); \\\n    moonNorm = mix(moonNorm, mNorm, mHit); \\\n    moonSeed = mix(moonSeed, seed, mHit); \\\n}\n\nfloat moonShadow(vec3 pos, vec4 moon, vec3 dir) {\n    vec3 p = pos - moon.xyz;\n\tfloat m = dot(p, dir);\n    float n = dot(p, p);\n    return step(step(m, 0.0) * moon.w * moon.w, n - m * m);\n}\n\nfloat ring(vec3 pos, vec3 dir, vec3 pole, float seed, out float d, out float r, out vec3 q) {\n    vec2 bounds = 1.4 * hash2(seed + 0.9) + vec2(1.1, 1.6);\n    \n    d = dot(-pos, pole) / dot(dir, pole);\n    q = pos + d * dir;\n    r = length(q);\n    \n    float a = smoothstep(bounds.x, bounds.x + 0.1, r) * smoothstep(bounds.y, bounds.y - 0.1, r);\n    a *= smoothstep(-0.5, 1.0, fbm1(6.0 * (r + 3.0 * seed)));\n    return clamp(a, 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float t = 0.25 * iTime;\n    float seed = floor(t) + 1.0;\n    \n    vec3 center = vec3(0.0);\n    float s = 2.0 * fract(t) - 1.0;\n    float powS = s * s;\n    powS = powS * powS;\n    powS = powS * powS;\n    powS = powS * powS;    \n    center += s * powS * vec3(1.0, 3.0, 0.0);\n    vec3 eye = center + vec3(0.0, -5.0, 0.0) + fract(t) * vec3(1.0, 1.0, 0.0);\n    float zoom = 3.0;\n    \n    vec3 forward = normalize(center - eye);\n    vec3 right = normalize(cross(forward, vec3(0.0, 0.0, 1.0)));\n    vec3 up = cross(right, forward);\n    vec2 xy = 2.0 * fragCoord - iResolution.xy;\n    vec3 ray = normalize(xy.x * right + xy.y * up + zoom * forward * iResolution.y);\n    \n    vec3 light = uniform3(seed);\n    vec3 pole = uniform3(seed + 0.1);\n    if (GO_CRAZY || iMouse.z > 0.0)\n        seed += 0.123 * floor(3.0 * iTime);\n    float dist = 1.0 + 1.2 * hash1(seed);\n    eye *= dist;\n\n    vec2 bandHash = hash2(seed + 0.2);\n    float bandScale = 1.0 + 6.0 * bandHash.x;\n    float bandTurbulence = 0.1 * pow(bandHash.y, 2.0);\n    \n    vec4 planetHash = hash4(seed + 0.3);\n    vec3 planetColor = hsv(planetHash.x, 0.5, 0.5 + 0.2 * planetHash.y);\n    vec3 planetMinorX = hsv(planetHash.x, 0.3, 0.5 + 0.2 * planetHash.y + 0.3 * planetHash.w) - planetColor;\n    vec3 planetMinorY = hsv(planetHash.x + 0.4 * planetHash.z, 0.5, 0.5 + 0.2 * planetHash.y) - planetColor;\n    vec3 planetMinorZ = hsv(planetHash.x + 0.4 * planetHash.z, 0.3, 0.5 + 0.2 * planetHash.y - 0.4 * planetHash.w) - planetColor;\n    \n    vec3 ringHash = hash3(seed + 0.4);\n    vec3 ringColor = hsv(ringHash.x, 0.2, 0.5 + 0.2 * ringHash.y);\n    vec3 ringMinor = hsv(ringHash.x + 0.3 * ringHash.z, 0.2, 0.7 + 0.2 * ringHash.y) - ringColor;\n    \n    float moonCount = hash1(seed + 0.5) * 8.0 - 2.0;    \n    \n    vec4 moon1 = newMoon(moonCount, pole, seed + 0.01, 0.0);\n    vec4 moon2 = newMoon(moonCount, pole, seed + 0.02, 1.0);\n    vec4 moon3 = newMoon(moonCount, pole, seed + 0.03, 2.0);\n    vec4 moon4 = newMoon(moonCount, pole, seed + 0.04, 3.0);\n    vec4 moon5 = newMoon(moonCount, pole, seed + 0.05, 4.0);\n    vec4 moon6 = newMoon(moonCount, pole, seed + 0.06, 5.0);\n    \n    float b = dot(eye, ray);\n    float c = dot(eye, eye) - 1.0;\n    float h = b * b - c;\n    float hit = step(0.0, h);\n    h = max(h, 0.0);\n    float depth = -b - sqrt(h);\n    vec3 pos = eye + depth * ray;\n    \n    vec3 poleX = normalize(cross(pole, vec3(0.0, 0.0, 1.0)));\n    vec3 poleY = cross(pole, poleX);\n    mat3 rot = inverse(mat3(pole, poleX, poleY));\n    \n    vec3 p = rot * pos;\n    //p.x = asin(p.x); // Latitude bands\n    p += bandTurbulence * fbm3(10.0 * p);\n    \n    vec3 bands = fbm3(bandScale * vec3(1.0, 0.05, 0.05) * p + seed);\n    vec3 color = planetColor;\n    color += planetMinorX * bands.x;\n    color += planetMinorY * bands.y;\n    color += planetMinorZ * bands.z;\n    \n    float moonDepth = 2.0 * depth;\n    vec3 moonNorm = vec3(0.0);\n    float moonSeed = 0.0;\n    hitMoon(moon1, 1.0);\n    hitMoon(moon2, 2.0);\n    hitMoon(moon3, 3.0);\n    hitMoon(moon4, 4.0);\n    hitMoon(moon5, 5.0);\n    hitMoon(moon6, 6.0);\n    float moonHit = 1.0 - step(depth, moonDepth) * hit;\n\n    vec3 moonPos = eye + moonDepth * ray;\n    \n    vec3 moonColor = fbm3(10.0 * moonPos);\n    float moonSat = 0.4 * hash1(seed + 0.123 * moonSeed) + 0.2 * moonColor.x;\n    moonColor = hsv(hash1(seed + 0.321 * moonSeed) + 0.2 * moonColor.y, moonSat, 0.4 + 0.7 * moonColor.z);\n    \n    pos = mix(pos, moonPos, moonHit);\n    color = mix(color, moonColor, moonHit);\n    depth = mix(depth, moonDepth, moonHit);\n    vec3 norm = mix(pos, moonNorm, moonHit);\n    hit = 1.0 - (1.0 - hit) * (1.0 - moonHit);\n    \n    float illumination = max(dot(norm, light), 0.0);\n\n    float m = dot(pos, light);\n    float n = dot(pos, pos);\n    illumination *= step(step(m, 0.0), n - m * m);\n    \n    illumination *= moonShadow(pos, moon1, light);\n    illumination *= moonShadow(pos, moon2, light);\n    illumination *= moonShadow(pos, moon3, light);\n    illumination *= moonShadow(pos, moon4, light);\n    illumination *= moonShadow(pos, moon5, light);\n    illumination *= moonShadow(pos, moon6, light);\n\n    float d, r;\n    vec3 q;\n    float ringShadow = ring(pos, light, pole, seed, d, r, q);\n    illumination *= 1.0 - ringShadow * step(0.0, d);\n\n    color *= hit * illumination;\n    \n    float ringAlpha = ring(eye, ray, pole, seed, d, r, q);\n    float ringLight = 0.5 + 0.5 * abs(dot(pole, light));\n    \n    m = dot(q, light);\n    n = dot(q, q);\n    ringLight *= step(step(m, 0.0), n - m * m);\n    \n    ringLight *= moonShadow(q, moon1, light);\n    ringLight *= moonShadow(q, moon2, light);\n    ringLight *= moonShadow(q, moon3, light);\n    ringLight *= moonShadow(q, moon4, light);\n    ringLight *= moonShadow(q, moon5, light);\n    ringLight *= moonShadow(q, moon6, light);\n    \n    ringColor += ringMinor * fbm1(15.0 * (r + 3.0 * seed));\n    ringColor *= ringLight;\n    \n    color = mix(color, ringColor, step(hit * d, depth) * ringAlpha);\n    \n    color *= 2.0;\n    float flare = max(0.0, dot(ray, light));\n    color += pow(flare, 10.0);\n    \n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}