{"ver":"0.1","info":{"id":"ddcyD8","date":"1694983221","viewed":70,"name":"Approximate Optimal Transport","username":"chronos","description":"Just a hand tuned algo based on gradient descent. Looks looks like it manages to approximate optimal transport at least somewhat decently :)","likes":2,"published":1,"flags":32,"usePreview":1,"tags":["visualization","1d","algorithm","transport","probability","optimal","distributions","wasserstein"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 color = vec3(0);\n    \n    color = texelFetch(iChannel0, ivec2(fragCoord.xy)/4, 0).rgb;\n\n    fragColor = vec4(pow(color, vec3(1./2.2)),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n\n Computing the Wasserstein Distance (or Wasserstein Metric)\n \n Consider two (1D in this case) distributions: A, B\n \n The transport plan (or coupling) T, is a (2D) distribution\n which minimizes the total transport cost, C, of the pushforward map.\n \n Here, the transport cost is simply the Euclidean distance ( squared ? )\n\n The distributions A and B integrate to 1\n The transport plan T must integrate to 1\n \n*/\nconst float size = 100.;\n\nfloat get(float i, float j)\n{\n    return texelFetch(iChannel0, ivec2(i, j), 0).r;\n}\n\nfloat getA(float i)\n{\n    float weight = 0.;\n    for(float j = 0.; j < size; j++) { weight += texelFetch(iChannel1, ivec2(j, 512),0).r; }\n    \n    return texelFetch(iChannel1, ivec2(i, 512),0).r / weight;\n}\n\nfloat getB(float i)\n{\n    float weight = 0.;\n    for(float j = 0.; j < size; j++) { weight += texelFetch(iChannel1, ivec2(j, 512),0).b; }\n    \n    return texelFetch(iChannel1, ivec2(i, 512),0).b / weight;\n}\n\nfloat get_prev_mass(float y)\n{\n    float mass = 0.;\n    for(float i = 0.; i < size; i++) { mass += getA(i) * get(i, y); }\n    return mass;\n}\n\nfloat get_A_gradient(float x, float y)\n{\n    float sum = 0.;\n    for(float i = 0.; i < size; i++)\n    {\n        sum += getB(i) * get(x, i);\n    }\n    float deviation = sum - getA(x);\n    \n    float grad = 2. * getB(y) * deviation;\n    \n    return grad;\n}\n\nfloat get_B_gradient(float x, float y)\n{\n    float sum = 0.;\n    for(float i = 0.; i < size; i++)\n    {\n        sum += getA(i) * get(i, y);\n    }\n    float deviation = sum - getB(y);\n    \n    float grad = 2. * getA(x) * deviation;\n    \n    return grad;\n}\n\nfloat cost(float x, float y)\n{\n    return abs(x - (size-y));\n}\nconst float PI = 3.14159;\nfloat gaussian(float mean, float std, float x)\n{\n    return (1./ (std * sqrt(2. * PI))) * exp(-0.5 * pow((x-mean) / std, 2.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float x = floor(fragCoord.x);\n    float y = floor(fragCoord.y);\n    float Cost = abs(y - x) / size;\n    \n    float InitialTransport = x - (size-y) == 0. ? 1. : 0.;\n    InitialTransport = gaussian(0., 3., cost(x,y));\n\n    float Transport = InitialTransport;\n    \n    fragColor = vec4(0.0,0.0,0.0,1.0);\n    \n     float dt = 100. * min(float(iFrame) / 60., 50.);\n    if(iFrame > 2)\n    {\n        Transport = get(x,y);\n        \n        // if misses target, then change\n        float B_gradient = get_B_gradient(x, y);\n        float A_gradient = get_A_gradient(x, y);\n        Transport -= pow((cost(x,y)/size), 2.) * .1; \n\n        Transport -= gaussian(0., 7., cost(x,y)) * (A_gradient + B_gradient) * dt;\n              \n        // Currently the same as clamp(Transport, 0., 1.);      \n              \n        // if negative, then increase\n        Transport -= 1.0 * min(0., Transport);\n        \n        // if greater than one, then decrease\n        Transport += 1.0 * min(0., 1.-Transport);\n    }\n    \n    // inside square\n    if(fragCoord.x < size && fragCoord.y < size)\n        fragColor = vec4(clamp(vec3(Transport, 0. , -Transport), 0., 1.),1.0);\n        \n    float A = 25. * getA(x);\n    float B = 25. * getB(y);\n        \n    // top\n    if(x < size && y >= size)\n    {\n        fragColor.rgb += smoothstep(0.011, 0.010, abs((y - size)/size - A));\n        fragColor.rgb += 0.25*smoothstep(0.011, 0.010, (y - size)/size - A);\n        \n        // Compute transported mass\n        \n        float mass = 0.;\n        for(float i = 0.; i < size; i++)\n        {\n            mass += getB(i) * get(x, i);\n        }\n        mass *= 25.;\n        \n        fragColor.rgb += vec3(0,1,0) * .5 * smoothstep(0.011, 0.010, abs((y - size)/size - mass));\n        fragColor.rgb += vec3(0,1,0) * 0.125*smoothstep(0.011, 0.010, (y - size)/size - mass);\n    \n    }\n    \n    // right side \n    if(x >= size && y < size)\n    {\n        fragColor.rgb += smoothstep(0.011, 0.010, abs((x - size)/size - B));\n        fragColor.rgb += 0.25*smoothstep(0.011, 0.010, (x - size)/size - B);\n        \n        // Compute transported mass\n        \n        float mass = 0.;\n        for(float i = 0.; i < size; i++)\n        {\n            mass += getA(i) * get(i, y);\n        }\n        mass *= 25.;\n\n        fragColor.rgb += vec3(1,0,0) * .5 * smoothstep(0.011, 0.010, abs((x - size)/size - mass));\n        fragColor.rgb += vec3(1,0,0) * 0.125*smoothstep(0.011, 0.010, (x - size)/size - mass);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}