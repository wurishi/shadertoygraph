{"ver":"0.1","info":{"id":"cdXXDn","date":"1668691561","viewed":114,"name":"Fungus looking for jelly V3","username":"murf","description":"Looking much nicer now imo, closer to what I'd expect. I love the waves and how they converge into steady circular ones as the food is eaten (I watched 1000s until all the food was eaten lol)","likes":6,"published":1,"flags":48,"usePreview":0,"tags":["eating","fungus"],"hasliked":0,"parentid":"mslSRN","parentname":"Fungus looking for jelly V2"},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;    \n    vec4 res = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec4 bk = texture(iChannel1, uv);\n    vec4 col;\n    \n    col = mix(bk,vec4(0,res.y,res.z,1),0.5);\n    if(res.x==2.) col = mix(vec4(1,0,0,1),bk,0.4);\n    \n    fragColor = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PULSE\n\nconst float pSigAm = 120.; \nconst float nestSz = 16.;\nconst float siginc = 0.05;\nconst float sigr = 2.;\n\nfloat rand(vec2 c){\n\treturn fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise(vec2 p, float freq ){\n\tfloat unit = iResolution.x/freq;\n\tvec2 ij = floor(p/unit);\n\tvec2 xy = mod(p,unit)/unit;\n\t//xy = 3.*xy*xy-2.*xy*xy*xy;\n\txy = .5*(1.-cos(M_PI*xy));\n\tfloat a = rand((ij+vec2(0.,0.)));\n\tfloat b = rand((ij+vec2(1.,0.)));\n\tfloat c = rand((ij+vec2(0.,1.)));\n\tfloat d = rand((ij+vec2(1.,1.)));\n\tfloat x1 = mix(a, b, xy.x);\n\tfloat x2 = mix(c, d, xy.x);\n\treturn mix(x1, x2, xy.y);\n}\n\nfloat pNoise(vec2 p, int res){\n\tfloat persistance = .5;\n\tfloat n = 0.;\n\tfloat normK = 0.;\n\tfloat f = 4.;\n\tfloat amp = 1.;\n\tint iCount = 0;\n\tfor (int i = 0; i<50; i++){\n\t\tn+=amp*noise(p, f);\n\t\tf*=2.;\n\t\tnormK+=amp;\n\t\tamp*=persistance;\n\t\tif (iCount == res) break;\n\t\tiCount++;\n\t}\n\tfloat nf = n/normK;\n\treturn nf*nf*nf*nf;\n}\n\nfloat hash13(vec3 p3) \n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nivec2 snap2axis(vec2 dir)\n{\n    if(abs(dir.x) > abs(dir.y))    \n        return dir.x < 0.0 ? ivec2(-1.0,0.0) : ivec2(1.0,0.0);\n    else\n        return dir.y < 0.0 ? ivec2(0.0,-1.0) : ivec2(0.0,1.0);    \n}\n\nvec2 rand_dir(vec2 seed)\n{\n    vec2 total; float i=1., t=0.;\n    for(; i<=2.; i++)\n    {\n        float f = i*8.;\n        float hash = 2.0*M_PI*hash13(vec3(ivec2(seed/vec2(f)),float(iFrame)/f));\n        vec2 randDir = vec2(cos(hash),sin(hash));//*vec2(i);\n        total += randDir;\n        t++;\n    }\n    \n    total/=vec2(i/t);\n    total = vec2(snap2axis(total));\n    return total;\n}\n\nvec2 real_dir(vec2 seed)\n{\n    if(seed.x<=0.) return vec2(1,0);\n    if(seed.y<=0.) return vec2(0,1);\n    if(seed.x>=iResolution.x-1.) return vec2(-1,0);\n    if(seed.y>=iResolution.y-1.) return vec2(0,-1);\n    return rand_dir(seed);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 seed = fragCoord;\n    vec4 last = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    //hasFood, patrolSig, foodSig, isActive\n    vec4 state = vec4(last.x==2.?2.:0.,\n                      max(0., last.y-1.0/pSigAm),\n                      max(0., last.z-1.0/pSigAm),\n                      0); \n    \n    if(iFrame==0 || keyPressed(82,iChannel1) > 0.5)\n    {\n        /*float h = hash13(vec3(fragCoord,iFrame));\n        if(h>0.999) state = vec4(1,last.y,last.z,0);*/\n        \n        float n = pNoise(seed, int(iResolution.y));\n        if(n<0.02) state = vec4(2,0,0,0);\n        \n        if(last.x==1. || length(fragCoord-0.64*iResolution.xy)<=nestSz) \n            state = vec4(1,1,last.z,0);\n    }\n    \n    if(iFrame%2==0)\n    {\n        float n = pNoise(seed, int(iResolution.y));\n        if(n<0.02 && last.x==2.) state = vec4(2,state.yz,0);\n        \n        if(last.x==1. || length(fragCoord-0.64*iResolution.xy)<=nestSz) \n            state = vec4(1,state.yz,0);\n    }\n    \n    //else\n    {\n        float h = pNoise(seed, int(iResolution.y));\n        //if(h<0.005) state = vec4(2,0,0,0);\n        \n        for(float i=0.0; i<2.0; i+=0.5)\n        {\n            ivec2 off = ivec2(cos(i*M_PI),sin(i*M_PI));\n            ivec2 nseed = ivec2(fragCoord)+off;\n            vec4 neibr = texelFetch(iChannel0, nseed, 0);\n            vec2 randDir = real_dir(vec2(nseed));\n            \n            if(last.x==0./*||last.x==1.||last.x==3.*/) { //if this is empty (0)\n                if(neibr.x==1.) { //has active neighbour (1|3)                    \n                    if((last.z>neibr.z /*&& last.y<neibr.y*/) || off==-ivec2(randDir)){ //try make this active (1)\n                        state = vec4(1,max(sigr,last.y+siginc)/sigr,last.z,0); break; \n                    }\n                }\n                else if(neibr.x==3.) { \n                    if((last.y>neibr.y /*&& last.z<neibr.z*/) || off==-ivec2(randDir)) { //try make this full (3)\n                        state = vec4(3,last.y,max(sigr,last.z+siginc)/sigr,0); break; \n                    }\n                }\n            }\n            \n            if(last.x==1.) { //has food neighbour (2)                \n                if(neibr.x==2.) { //make this full (3)                    \n                    state = vec4(0,last.y,max(sigr,last.z+siginc)/sigr,0); break;\n                }\n            }\n            \n            else if(last.x==2.) { //else this is food (2)                \n                if(neibr.x==1.){ //has active neighbour (1)                    \n                    state = vec4(3,last.y,max(sigr,last.z+siginc)/sigr,0); break; //make this empty (0)\n                }\n            }\n            else if(last.x==3.){ //has active neighbour (1) {    \n                if(length(fragCoord-0.64*iResolution.xy)<=nestSz) {\n                    state = vec4(1,max(sigr,last.y+siginc)/sigr,last.z,0); break; //make this empty (0)\n                }\n            }\n        }\n        \n    }    \n    \n    fragColor = vec4(state);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define M_PI 3.1415926535897932384626433832795\n\nfloat keyPressed(int keyCode, sampler2D ch) \n{ return texture(ch, vec2((float(keyCode) + 0.5) / 256., .5/3.)).r; }","name":"Common","description":"","type":"common"}]}