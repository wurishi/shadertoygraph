{"ver":"0.1","info":{"id":"ftB3WK","date":"1624734088","viewed":150,"name":"Nyan Tunnel","username":"konidia","description":"Too lazy for ray stuff, so I might as well use cheap tricks.\n\nApparently, this shader can create optical illusion.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["tunnel","nyan","infinite","lazy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define FIELD_OF_VIEW 90.\n#define TUNNEL_RADIUS 5.0\n#define NYAN_SPEED 1\n#define RAINBOW_SPEED 1\n\n#define PI 3.141592654\n\n#define EPSILON 0.0001\n\n// https://www.shadertoy.com/view/WsGXDh\nvec3 hsbl(in float h, in float s, in float b) {\n    const vec3 ch[7] = vec3[7](\n        vec3(1., 0., 0.),\n        vec3(1., 1., 0.),\n        vec3(0., 1., 0.),\n        vec3(0., 1., 1.),\n        vec3(0., 0., 1.),\n        vec3(1., 0., 1.),\n        vec3(1., 0., 0.)\n    );\n    float h6 = h*6.;\n    int h6i = int(h6);\n    return mix(vec3(0.),mix(vec3(1.),mix(ch[h6i],ch[h6i+1],fract(h6)),s),b);\n}\n\n// https://www.shadertoy.com/view/lsS3WV\nvec4 nyan(vec2 uv, float frame) {\n\tframe = mod(frame, 6.0);\n\tuv.x = (uv.x + frame)*240.0/256.0/6.0;\n\treturn textureLod(iChannel0, uv, 0.);\n}\n\nvec4 fragCoordTofragColor(in vec2 fragCoord) {\n    // pixel coordinates\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv*2.-1.;\n    uv.y *= iResolution.y/iResolution.x;\n    \n    // perceived radius of a circle in cylinder\n    float r = length(uv)*TUNNEL_RADIUS;\n    r = r == 0. ? 0.00001 : r;\n    \n    // base distance\n    float bd = TUNNEL_RADIUS/tan(radians(FIELD_OF_VIEW/2.));\n    \n    // distance (based on perceived radius)\n    // r = TUNNEL_RADIUS <-> d = bd\n    float d = bd * TUNNEL_RADIUS/r;\n    \n    // angle of current pixel\n    float angle = atan(uv.y, uv.x)/(PI*2.);\n    angle = angle < 0. ? (atan(-uv.y, -uv.x) + PI)/(PI*2.) : angle;\n    \n    // vars for nyan cat texture\n    vec2 nyanshift = vec2(floor(d + iTime)*0.5, 0.);\n    vec2 nyanmove = vec2(-iTime*float(NYAN_SPEED), d + iTime);\n    vec2 nyanuv = fract(vec2(angle*6.*TUNNEL_RADIUS, 0) + nyanshift + nyanmove);\n    float frame = floor(iTime*12.0);\n    \n    // Output to screen\n    vec4 nyancol = nyan(nyanuv, frame);\n    vec4 rainbow = vec4(hsbl(\n        fract(floor((angle-iTime*1./24.*float(RAINBOW_SPEED)-floor(d + iTime)*1.)*20.)/20.), \n        sin(floor(d + iTime)/2.)*0.25 + 0.75,\n        1.\n    ), 1.);\n    vec4 fragColor = nyancol.a == 0. ? rainbow : nyancol;\n    \n    return fragColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float samplePerAxis = 2.;\n    float samplePerPixel = samplePerAxis * samplePerAxis;\n\n    fragColor = vec4(0);\n    for (float i = 0.; i < samplePerAxis; i += 1.) {\n        for (float j = 0.; j < samplePerAxis; j += 1.) {\n            vec2 currCoord = fragCoord + vec2(i, j)/samplePerPixel;\n            fragColor += fragCoordTofragColor(currCoord)/samplePerPixel;\n        }\n    }\n    fragColor.w = 1.0;\n}","name":"Image","description":"","type":"image"}]}