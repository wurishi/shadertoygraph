{"ver":"0.1","info":{"id":"WlBGzV","date":"1560182724","viewed":619,"name":"Dags raymarched terrain test 1","username":"dagbrynildsentholander","description":"simple raymarching scene, pretty straight forward rendering. Inspired by Inigo Quilez. Put together in about 3 hours.\n\nUpdate(2019-06-11)\nIncreased height of terrain, modified fov.","likes":10,"published":3,"flags":0,"usePreview":0,"tags":["raymarching","terrain","space"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// By Dag Brynildsen Tholander 2019 06 10\n\nvec3 lightDir = vec3(1.,1.,1.);\nvec3 lightColor = vec3(1,.8,.75);\n\nfloat noise(vec2 p)\n{\n    return fract(sin(p.x*12.+p.y*525.)*1256.);\n}\n\nfloat smoothNoise(vec2 p)\n{\n    vec2 id = floor(p*1.);\n    vec2 ld = fract(p*1.);\n    ld = ld*ld*(3.-2.*ld);\n    float bl = noise(id);\n    float br = noise(id+vec2(1., 0.));\n    float b = mix(bl, br, ld.x);\n        \n    float tl = noise(id+vec2(0., 1.));\n    float tr = noise(id+vec2(1., 1.));\n    float t = mix(tl, tr, ld.x);\n    \n    float bt = mix(b, t, ld.y);\n    \n    return bt;\n}\n\nfloat map(vec3 p)\n{\n    float a = p.y/1.3;\n    p+=vec3(cos(a), 0, sin(a)); // achieves the effect of 3d noise by morphing the 2d noise\n    float base = 0.;\n    base+=1.15*pow(smoothNoise(p.xz/30.), .5);\n    base+=.25*pow(smoothNoise(p.xz/10.), 3.);\n    base+=.125*pow(smoothNoise(p.xz/5.), 3.);\n    base+=.02*pow(smoothNoise(p.xz), 2.);\n    base+=.005*smoothNoise(p.xz*3.);\n    return base*30.-p.y*1.3; // as suggested by Dave_Hoskins\n}\n\nvec3 normal(vec3 p)\n{\n\tfloat delta = 0.01;\n    vec3 x = vec3 (delta, 0.00, 0.00);\n\tvec3 y = vec3 (0.00, delta, 0.00);\n\tvec3 z = vec3 (0.00, 0.00, delta);\n    \n    float val = map(p);\n    vec3 grad = vec3(val - map(p - x), val - map(p - y), val - map(p - z));\n    return -normalize(grad);\n}\n\nfloat ray(vec3 ro, vec3 rd, float minD, float maxD, float stepsize)\n{\n    float t = minD;\n    float lastVal;\n    \n    while(t < maxD)\n    {\n        vec3 p = ro+rd*t;\n        float val = map(p);\n\n        if(val>0.)\n            return t-(abs(val)/(abs(val)+abs(lastVal)))*stepsize; // my way of doing a linear interpolation to get closest to the 'terrain'\n        \n        t+=stepsize;\n        stepsize*=1.01; // increase stepsize with distance, increases performance but causes artifacts and errors\n        lastVal = val;\n    }\n    return t;\n}\n\nvec3 lighting(vec3 n, vec3 ambientLight)\n{\n    return  max(dot(normalize(lightDir), n), 0.0) * lightColor * 1. +ambientLight;\n}\n\nvec3 fog(vec3 rgb, vec3 rd, float dist, float maxDist)\n{\n    vec3 fogColor = mix(vec3(.4,.4,.7), vec3(0), rd.y*1.2);\n    fogColor += vec3(.3,.2,.2)*pow(1.-abs(rd.y), 6.);\n    fogColor+=.75*lightColor*pow(clamp(dot(normalize(rd), normalize(lightDir)), 0., 1.),5.);\n\tif(dist>maxDist-0.5)\n    {\n        fogColor+= lightColor*pow(clamp(dot(normalize(rd), normalize(lightDir)), 0., 1.),500.);\n    }\n    return mix(rgb, fogColor, dist/maxDist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    // cam setup\n    vec3 camRot = vec3(0, iTime/10., 0.);\n    vec3 camDir = vec3(sin(camRot.y), 0, cos(camRot.y));\n    vec3 camRight = cross(camDir, vec3(0,1.,0));\n    vec3 camPos = vec3(0., 30., iTime);\n\n    vec3 rayDir = camDir + camRight*2.5*(uv.x-0.5)+ vec3(0,1.,0)*2.5*(uv.y-0.5); // changes were made kind of as suggested by Shane\n    float viewDist = 100.;\n    \n\t// raymarching\n\tfloat rayResult = ray(camPos, rayDir, 0.5, viewDist, 0.06);\n    vec3 hitPoint = rayResult*rayDir+camPos;\n    \n    // Triplanar texturing\n    \n    vec3 n = normal(camPos+rayDir*rayResult);\n    float xAlpha = pow(abs(n.x), 3.);\n    float yAlpha = pow(abs(n.y), 5.);\n    float zAlpha = pow(abs(n.z), 3.);\n    vec3 terrainColor = vec3(0);\n    terrainColor += texture(iChannel0, vec2(hitPoint.z, hitPoint.y)/3.).xyz*xAlpha;\n    terrainColor += texture(iChannel1, vec2(hitPoint.x, hitPoint.z)/3.).xyz*yAlpha;\n    terrainColor += texture(iChannel0, vec2(hitPoint.x, hitPoint.y)/3.).xyz*zAlpha;\n    \n    // Final color\n    vec3 col = fog(lighting(n, vec3(.1,.1,.1)).xyz*terrainColor, rayDir,rayResult,viewDist);\n    \n    //col = vec3(smoothNoise(uv)); visualize noise\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}