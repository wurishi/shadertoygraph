{"ver":"0.1","info":{"id":"MtjSzt","date":"1445972695","viewed":1353,"name":"WaterRipples","username":"jt","description":"Water ripples (currently using dispersion-function by FabriceNeyret2 - see comments).","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["waves","ripples","water"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// Water-Ripples - written by Jakob Thomsen\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat zoom = 20.0;\n\nvec2 refl2(vec2 v)\n{\n    return abs(2.0 * fract(v * 0.5) - 1.0);\n}\n\nfloat sech(float v)\n{\n    return 2.0 / (exp(v) + exp(-v));\n}\n\nfloat ease(float v)\n{\n    return (0.5 - 0.5 * cos(v * 2.0 * 3.1415926));\n}\n\nfloat easeout(float v)\n{\n    return (0.5 + 0.5 * cos(fract(v) * 3.1415926));\n}\n\nfloat wave(float x, float k, float c, float t)\n{\n    float X = x - c * t;\n    return sin(k * X) * exp(-X * X);\n}\n\nfloat dispersion(float d, float t) // testing FabriceNeyret2's waves dispersion function (source: https://www.shadertoy.com/view/MtBSDG)\n{\n    float A = 0.8;\n    float sum = 0.0;\n    for (float k = 1.0; k < 10.0; k++)\n    {\n        sum += A * wave(abs(d), k, sqrt(k), t) / k; // dispertion for capillary waves\n        //sum += A * wave(abs(d), k, 1.0 / sqrt(k), t) / k;// dispertion for gravity waves\n    }\n    \n    //return sum; // 1d function\n    return sum / d; // correct 2d function (\"1/r\")\n}\n\nfloat ripple(vec2 seed, vec2 pos) // NOTE: seed must be in [0..127]\n{\n    float period = 20.0;\n    //vec2 src = vec2(float(perm[seed]) / 255.0, float(perm[seed + 128]) / 255.0);\n    vec2 src = texture(iChannel0, seed).xy;\n    float offset = texture(iChannel0, seed).z;\n    float localtime = iTime / period + offset;\n    src = refl2(src + floor(localtime) * texture(iChannel0, seed).zw); // change source-position\n    float d = zoom * length(pos - src);\n    float t = fract(localtime) * period;\n    float v = 5.0 * dispersion(d * 5.0, t) / d;\n    v *= easeout(t / period);\n    return v;\n}\n/*\nfloat ripple(vec2 seed, vec2 pos) // NOTE: seed must be in [0..127]\n{\n    float period = 10.0;\n    //vec2 src = vec2(float(perm[seed]) / 255.0, float(perm[seed + 128]) / 255.0);\n    vec2 src = texture(iChannel0, seed).xy;\n    float offset = texture(iChannel0, seed).z;\n    float localtime = iTime / period + offset;\n    src = refl2(src + floor(localtime) * texture(iChannel0, seed).zw); // change source-position\n    float d = zoom * length(pos - src);\n    float t = fract(localtime) * period;\n    float v = sech((-t + d) / 2.5 * 2.0 * 3.1415926) * sin(2.0 * (-iTime + d) * 2.0 * 3.1415926);\n    v *= exp(-pow(d / 5.0, 2.0)) * easeout(t / period);\n    return v;\n}\n*/\nfloat ripples(vec2 pos)\n{\n    float h = 0.0;\n    h += ripple(vec2(0.0, 0.0), pos);\n\n    h += ripple(vec2(0.0, 0.25), pos);\n    h += ripple(vec2(0.25, 0.25), pos);\n    h += ripple(vec2(0.25, 0.0), pos);\n\n    h += ripple(vec2(0.0, 0.5), pos);\n    h += ripple(vec2(0.25, 0.5), pos);\n    h += ripple(vec2(0.5, 0.5), pos);\n    h += ripple(vec2(0.5, 0.25), pos);\n    h += ripple(vec2(0.5, 0.0), pos);\n\n    return h / 9.0;\n\n//    h += ripple(vec2(0.0, 0.75), pos);\n//    h += ripple(vec2(0.25, 0.75), pos);\n//    h += ripple(vec2(0.5, 0.75), pos);\n//    h += ripple(vec2(0.75, 0.75), pos);\n//    h += ripple(vec2(0.75, 0.5), pos);\n//    h += ripple(vec2(0.75, 0.25), pos);\n//    h += ripple(vec2(0.75, 0.0), pos);\n//\n//    return h / 16.0;\n}\n\nfloat checker2(vec2 pos)\n{\n    return step((fract(pos.x) - 0.5) * (fract(pos.y) - 0.5), 0.0);\n}\n\nvec3 ripples_normal(vec2 pos)\n{\n    float d = 0.001;\n    return normalize(vec3(\n        ripples(pos - vec2(d, 0.0)) - ripples(pos + vec2(d, 0.0)),\n        ripples(pos - vec2(0.0, d)) - ripples(pos + vec2(0.0, d)),\n        d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //float w = 0.5 + 0.5 * ripple(fragCoord.xy / iResolution.xy.xy);\n    //float w = 0.5 + 0.5 * ripples(fragCoord.xy / iResolution.xy.xy);\n    //w = 1.0 - pow(1.0 - 2.0 * w, 5.0);\n    vec3 n = ripples_normal(fragCoord.xy / iResolution.xy);\n    //float w = checker2(10.0 * fragCoord.xy / iResolution.xy + 10.0 * grad);\n    vec3 w = texture(iChannel1, fragCoord.xy / iResolution.xy + n.xy).rgb;\n    float specular = pow(abs(dot(n, normalize(vec3(1.0, 1.0, 1.0)))), 10.0);\n    fragColor = vec4(w + vec3(specular), 1.0);\n}\n","name":"","description":"","type":"image"}]}