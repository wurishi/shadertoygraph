{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"/* Compiled with Shaderforth: https://github.com/daeken/Shaderforth\nimport[ noise ]\n\n:globals\n\t@vec3 uniform =iResolution\n\t@float uniform =iTime\n;\n\n:m time iTime ;\n\niResolution frag->position 1000 / =p\n:m light [ 0.87 0.64 0.25 ] ;\n:m dark [ 0.41 0.22 0.02 ] ;\n: val ( p:vec2 level:float -> float )\n\t&pnoise-2d p gradient abs\n;\n$[1:16:1] !size =>t /{ ( x ) 2 x ** p * x + [ time .1337 * sin time .0879 * sin ] p+ x val } \\+ t / =v\ndark light v abs 0 1 clamp mix ->fragcolor\n*/\n\nvec4 pnoise_permute(vec4 x) {\n\treturn mod((x * 34. + 1.) * x, 289.);\n}\nfloat pnoise_2d(vec2 v) {\n\tvec4 Pi = mod(floor(v.xyxy) + vec4(0., 0., 1., 1.), 289.);\n\tvec4 Pf = fract(v.xyxy) - vec4(0., 0., 1., 1.);\n\tvec4 i = pnoise_permute(pnoise_permute(Pi.xzxz) + Pi.yyww);\n\tvec4 gx = fract(i * .024390) * 2. - 1.;\n\tvec4 gy = abs(gx) - .5;\n\tgx = gx - floor(gx + .5);\n\tvec2 g00 = vec2(gx.x, gy.x);\n\tvec2 g10 = vec2(gx.y, gy.y);\n\tvec2 g01 = vec2(gx.z, gy.z);\n\tvec2 g11 = vec2(gx.w, gy.w);\n\tvec4 norm = 1.79284291400159 - .85373472095314 * vec4(length(g00), length(g01), length(g10), length(g11));\n\tvec2 fade_xy = Pf.xy * Pf.xy * Pf.xy * ((Pf.xy * 6. - 15.) * Pf.xy + 10.);\n\tvec2 n_x = mix(vec2(dot(g00 * norm.x, Pf.xy), dot(g01 * norm.y, Pf.xw)), vec2(dot(g10 * norm.z, Pf.zy), dot(g11 * norm.w, Pf.zw)), fade_xy.x);\n\treturn mix(n_x.x, n_x.y, fade_xy.y) * 2.3;\n}\nfloat val(vec2 p, float level) {\n\tvec2 h = vec2(.00001, 0.);\n\treturn abs(pnoise_2d(p) / abs(length(vec2(pnoise_2d(p + h) - pnoise_2d(p - h), pnoise_2d(p + h.yx) - pnoise_2d(p - h.yx)) / (2. * h.x))));\n}\nvec2 polar_cart(vec2 p) {\n\treturn vec2(cos(p.x), sin(p.x)) * p.y;\n}\nvec2 cart_polar(vec2 p) {\n\treturn vec2(atan(p.y, p.x), length(p));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p = (fragCoord.xy / iResolution.xy * 2. - 1.) * vec2(iResolution.x / iResolution.y, 1.) / 1000.;\n\tfloat v = (val(polar_cart(cart_polar(2. * p + 1.) + vec2(sin(iTime * .1337), sin(iTime * .0879))), 1.) + val(polar_cart(cart_polar(4. * p + 2.) + vec2(sin(iTime * .1337), sin(iTime * .0879))), 2.) + val(polar_cart(cart_polar(8. * p + 3.) + vec2(sin(iTime * .1337), sin(iTime * .0879))), 3.) + val(polar_cart(cart_polar(16. * p + 4.) + vec2(sin(iTime * .1337), sin(iTime * .0879))), 4.) + val(polar_cart(cart_polar(32. * p + 5.) + vec2(sin(iTime * .1337), sin(iTime * .0879))), 5.) + val(polar_cart(cart_polar(64. * p + 6.) + vec2(sin(iTime * .1337), sin(iTime * .0879))), 6.) + val(polar_cart(cart_polar(128. * p + 7.) + vec2(sin(iTime * .1337), sin(iTime * .0879))), 7.) + val(polar_cart(cart_polar(256. * p + 8.) + vec2(sin(iTime * .1337), sin(iTime * .0879))), 8.) + val(polar_cart(cart_polar(512. * p + 9.) + vec2(sin(iTime * .1337), sin(iTime * .0879))), 9.) + val(polar_cart(cart_polar(1024. * p + 10.) + vec2(sin(iTime * .1337), sin(iTime * .0879))), 10.) + val(polar_cart(cart_polar(2048. * p + 11.) + vec2(sin(iTime * .1337), sin(iTime * .0879))), 11.) + val(polar_cart(cart_polar(4096. * p + 12.) + vec2(sin(iTime * .1337), sin(iTime * .0879))), 12.) + val(polar_cart(cart_polar(8192. * p + 13.) + vec2(sin(iTime * .1337), sin(iTime * .0879))), 13.) + val(polar_cart(cart_polar(16384. * p + 14.) + vec2(sin(iTime * .1337), sin(iTime * .0879))), 14.) + val(polar_cart(cart_polar(32768. * p + 15.) + vec2(sin(iTime * .1337), sin(iTime * .0879))), 15.)) / 15.;\n\tfragColor = vec4(mix(vec3(.41, .22, .02), vec3(.87, .64, .25), clamp(abs(v), 0., 1.)), 1.);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MsBXDy","date":"1415478302","viewed":613,"name":"Gold","username":"daeken","description":"A little experiment with various levels of noise.","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["noise","shaderforth"],"hasliked":0,"parentid":"","parentname":""}}