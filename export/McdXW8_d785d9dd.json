{"ver":"0.1","info":{"id":"McdXW8","date":"1713883509","viewed":25,"name":"Fork Basic RT with acc render","username":"Cesium_137","description":"Added accumulative rendering","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"lfc3Dl","parentname":"Basic RT 2"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float KEY_SPACE = 32.5/256.0;\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Material\n{\n    vec3 albedo;\n    float roughness;\n    float emissionPower;\n};\nMaterial materials[5];\n\nstruct Sphere\n{\n    vec3 position;\n    float radius;\n    int materialIndex;\n};\n\nstruct HitPayload\n{\n    float hitDistance;\n    vec3 position;\n    vec3 normal;\n    int objectIndex;\n};\nSphere spheres[5];\n\nfloat random(vec2 seed)\n{\n    return fract(sin(dot(seed, vec2(64.25375463, 23.27536534))) * 43758.5453123);\n}\n\nvoid Hit(out HitPayload payload, inout Ray ray, in float hitDistance, in int objectIndex)\n{\n    payload = HitPayload(hitDistance, vec3(0.0), vec3(0.0), objectIndex);\n    \n    vec3 origin = ray.origin - spheres[objectIndex].position;\n    payload.position = origin + hitDistance * ray.direction;\n    payload.normal = normalize(payload.position);\n    payload.position += spheres[objectIndex].position;\n}\n\nvoid Miss(out HitPayload payload)\n{\n    payload = HitPayload(-1.0, vec3(-1.0), vec3(-1.0), -1);\n}\n\nvoid TraceRay(inout HitPayload payload, in Ray ray)\n{\n    float hitDistance = 3.402823466e+38;\n    int closest = -1;\n    for (int i = 0; i < spheres.length(); i++)\n    {\n        vec3 origin = ray.origin - spheres[i].position;\n        \n        float a = dot(ray.direction, ray.direction);\n        float b = 2.0 * dot(origin, ray.direction);\n        float c = dot(origin, origin) - spheres[i].radius * spheres[i].radius;\n        \n        float dis = b * b - 4.0f * a * c;\n        if (dis < 0.0) continue;\n        \n        float t = (-b - sqrt(dis)) / (2.0 * a);\n        if (t > 0.0 && t < hitDistance)\n        {\n            closest = i;\n            hitDistance = t;\n        }\n    }\n    \n    if (closest < 0)\n        Miss(payload);\n    else\n        Hit(payload, ray, hitDistance, closest);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n    uv.y *= (iResolution.y / iResolution.x);\n    \n    spheres[0] = Sphere(vec3(0.0, -50.5, 0.0), 50.0, 0);\n    spheres[1] = Sphere(vec3(1.0, 2.5, -1.0), 1.0, 1);\n    spheres[2] = Sphere(vec3(-1.5, -0.3, 5.0), 0.5, 2);\n    spheres[3] = Sphere(vec3(-0.0, -0.1, 4.0), 0.6, 3);\n    spheres[4] = Sphere(vec3(-2.5, 0.0, 2.5), 0.65, 4);\n    materials[0] = Material(vec3(0.0, 0.8, 0.8), 2.5, 0.0);\n    materials[1] = Material(vec3(0.7, 0.5, 0.2), 0.8, 150.0);\n    materials[2] = Material(vec3(1.0, 0.6, 0.1), 0.8, 0.0);\n    materials[3] = Material(vec3(0.9, 0.1, 0.2), 0.8, 0.0);\n    materials[4] = Material(vec3(0.2, 1.0, 0.3), 0.1, 0.0);\n    vec3 cameraPos = vec3(0.0, 1, 10.0);\n    \n    int bounces = 8;\n    \n    vec3 light = vec3(0.0);\n\tvec3 contribution = vec3(1.0);\n    \n    Ray ray = Ray(cameraPos, vec3(uv.x, uv.y, -1.0));\n\n    for (int i = 0; i < bounces; i++)\n    {\n        HitPayload hit;\n        TraceRay(hit, ray);\n\n        if (hit.hitDistance < 0.0)\n        {\n            light += vec3(0.8, 0.9, 1.2) * contribution;\n            break;\n        }\n\n        Sphere sphere = spheres[hit.objectIndex];\n        Material material = materials[sphere.materialIndex];\n\n        contribution *= material.albedo;\n        light += material.albedo * material.emissionPower * contribution;\n\n        ray.origin = hit.position + hit.normal * 0.0001;\n        vec2 seed = uv * iTime;\n        vec3 rand = vec3(random(seed) * 2.0 - 1.0, random(seed * 1.01) * 2.0 - 1.0, random(seed * 2.02) * 2.0 - 1.0);\n        ray.direction = reflect(ray.direction, normalize(hit.normal + material.roughness * rand)) + normalize(hit.normal + material.roughness * rand) / 2.0;\n    }\n    \n    bool spacePressed = (texture(iChannel1, vec2(KEY_SPACE,0.25)).x > 0.1);\n    vec3 color = clamp(vec3(light), vec3(0.0), vec3(1.0));\n    vec4 lastFrameColor = texture(iChannel0, fragCoord / iResolution.xy);\n    float blend = (lastFrameColor.a == 0.0f || spacePressed) ? 1.0 : 1.0 / (1.0 + (1.0 / lastFrameColor.a));\n    color = mix(lastFrameColor.rgb, color, blend);\n    \n    fragColor = vec4(color,blend);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}