{"ver":"0.1","info":{"id":"X3G3DG","date":"1718128186","viewed":118,"name":"Mobile buffer bug+workaround","username":"ukeshet","description":"Buffer fetch (texture/texelFetch) seems broken on mobile (generally+presently).\nThis shows the bug (non-yellow squares on mobile) + workaround (Encode/Decode).\nProof: fixed shaders now work on mobile, e.g. [url]https://www.shadertoy.com/view/4XGGRV[/url]","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["texture","bug","buffer","texelfetch","workaround"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Buffer fetch (tecture/texelFetch) bug: works on desktop, fails on mobile\n// (probably because some extensions for webGL2 are not always available or \n// fully implemented, according to @FabriceNeyret2). The problem does not \n// depend of choice of texture/texelFetch, Buffer A/B/C/D, int/uint, etc.\n// \n// Bug: incorrect fetch (rendering squares green/red and not yellow) on mobile.\n// Partial workaround: keeping bit b30=1 ensures b13..b26 transferred correctly.\n// Proof: b30=1 (column 2) protects the white rectangle (no red/green squares).\n// Full workaround: transfer all bits using this b13..b26 window (see Common). \n//\n// This shader repeats identical bit opertaions, once for variable i in Image \n// (shown green), and once for an identical variable i fetched from Buffer A \n// (in red). The result should align everywhere (so, yellow), which is indeed the \n// case on a desktop, but not on any of the iphone and android phones tested.\n// The white rectangle shows that b30=1 protects b13..b26; rows 13/26 (from the\n// bottom) verify this using up/down counters within these 14 bits.  \n//\n// By ukeshet for ICP course.\n//\n// Update (see comments): the workaround solves the problem on various modern \n// Android phones. But on iPhone 12 and maybe also 15, this shader (and also \n// https://www.shadertoy.com/view/WscyRM) suggets that buffers are too broken, \n// and no similar workaround seems possible.\n\n\n#define w .15\n#define w2 .2\n\n// Same behavior for texelFetch (L1) and texture (switch to L2 to verify):\n#define L1 texelFetch(iChannel0, ivec2(U), 0)\n#define L2 texture(iChannel0, U/R.xy)\n\n\nvoid mainImage(out vec4 O, in vec2 U)\n{\n    // red = i is defind here; green = i is fetched from buffer A.\n    O = vec4( (FromFloat(L1.x)       >> int(32.-U.x*32./R.x)) & mask, \n              (FromFloat(ToFloat(i)) >> int(32.-U.x*32./R.x)) & mask, \n               0, 1 );\n    // For full symmetry, I convert i to float and then back. \n    // This is unnecessary, and in any case makes no difference.\n\n    // Add blue boundaries:\n    if (fract(U.x*32./R.x)<w || fract(U.y*32./R.y)<w2) {\n        O.z=1.;\n        // Add white boundaries for protected rectangle:\n        if (inQ(5.,U.x*32./R.x,19.+w)) { \n            if (inQ(13.,U.y*32./R.y,13.+w) || inQ(27.-w,U.y*32./R.y,27.+w))  \n                O=vec4(1);\n            if (!inQ(5.+w,U.x*32./R.x,19.) && inQ(13.,U.y*32./R.y,27.+w))  \n                O=vec4(1);\n    }}\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"precision highp int;\nprecision highp float;\n// The above don't seem to make any difference.\n\n#define R iResolution\n#define t iTime\n#define inQ(a,b,c) (a<b && b<c)\n\n// For some reason, bit b30=1 guarantees b13..b26 transferred correctly:\n#define Protect  0x40000000 \n\n/*\n// The problem doesn't depend on type, simply using uint won't help.\n// uint version:\n#define ProtectU 0x40000000u \n#define i ( (!inQ(13.,U.y*32./R.y,27.) || inQ(14.,U.y*32./R.y,26.))? \\\n             ((1u<<int(U.y*32./R.y)) | ProtectU) : \\\n              (U.y*32./R.y<14.) ? \\\n                  (ProtectU + uint(t)*8192u) : \\\n                  (ProtectU + 0x04000000u - uint(t)*8192u) )\n#define ToFloat uintBitsToFloat\n#define FromFloat floatBitsToUint\n#define mask 1u\n*/\n\n// int version:\n#define i ( (!inQ(13.,U.y*32./R.y,27.) || inQ(14.,U.y*32./R.y,26.))? \\\n             ((1<<int(U.y*32./R.y)) | Protect) : \\\n              (U.y*32./R.y<14.) ? \\\n                  (Protect + int(t)*8192) : \\\n                  (Protect + 0x04000000 - int(t)*8192) )\n#define ToFloat intBitsToFloat\n#define FromFloat floatBitsToInt\n#define mask 1\n\n// ----------------------------------------------------------------------\n// Workaround:\n// Keeping b30=1 protects the transfer of bits b13..b26.\n// So, split the 32 bits among the different vec4 components of fragColor.\n// Here we use v.x for b27..b31, v.y for b13..b26, and v.z for b0..b12\n// (we also use v.w for the full b0..b31, but that won't help on mobile):\n// ----------------------------------------------------------------------\n#define I2F(j) intBitsToFloat(j|0x40000000) // Protecting bit 30 required.\n#define Encode(i) vec4( I2F(i>>14 & 0x0003E000), \\\n                        I2F(i&0x07FFE000), \\\n                        I2F(i<<13 & 0x03FFE000), \\\n                        intBitsToFloat(i) )\n#define Decode(v)  ((floatBitsToInt(v.x)<<14) & 0xF8000000) \\\n                      | (floatBitsToInt(v.y) & 0x07FFE000) \\\n                      | ((floatBitsToInt(v.z)>>13) & 0x00001FFF)  \n// ----------------------------------------------------------------------\n// For Encoed/Decode usage examples, see \n// Hough transform - https://www.shadertoy.com/view/X3VGzG\n// Hough transform 2 - https://www.shadertoy.com/view/4XG3RK\n// Hough transform 3 - https://www.shadertoy.com/view/4XGGRV\n// ----------------------------------------------------------------------\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Makes no difference if we use Buffer A, B, C, or D.\n\nvoid mainImage(out vec4 O, in vec2 U)\n{\n    O = vec4(ToFloat(i));   \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Makes no difference if we use Buffer A, B, C, or D.\n\nvoid mainImage(out vec4 O, in vec2 U)\n{\n    O = vec4(ToFloat(i));   \n}","name":"Buffer B","description":"","type":"buffer"}]}