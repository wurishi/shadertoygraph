{"ver":"0.1","info":{"id":"lfKyWV","date":"1732431603","viewed":25,"name":"infinity?","username":"congodin","description":"f","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["f"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 128\n#define MAX_DIST 50.0\n#define SURF_DIST 0.001\n#define MAX_BOUNCES 8\n\nstruct Hit {\n    float dist;\n    vec3 emissive;\n    bool isLight;\n    bool isFrame;\n};\n\n// Room and grid settings\nconst float ROOM_SIZE = 4.0;\nconst float GRID_SIZE = 2.0;\nconst float FRAME_THICKNESS = 0.04;\n\n// Light settings\nconst float LIGHT_SPACING = 0.2;\nconst float LIGHT_SIZE = 0.02;\nconst float LIGHT_INTENSITY = 4.0;\nconst float AMBIENT_LIGHT = 0.1;\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n// Grid pattern for mirror frames\nfloat gridPattern(vec3 p) {\n    vec3 gp = mod(p + 0.5 * GRID_SIZE, GRID_SIZE) - 0.5 * GRID_SIZE;\n    float frames = min(min(abs(gp.x), abs(gp.y)), abs(gp.z));\n    return step(frames, FRAME_THICKNESS);\n}\n\nfloat hash11(float p) {\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec3 hash31(vec3 p3) {\n    p3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz + 33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n// Get light color based on position\nvec3 getLightColor(vec3 p) {\n    float n = fract(sin(dot(floor(p), vec3(12.9898, 78.233, 45.164))) * 43758.5453);\n    \n    // Warmer, more balanced color palette\n    vec3 red = vec3(1.0, 0.3, 0.2) * 1.8;\n    vec3 blue = vec3(0.2, 0.4, 1.0) * 1.5;\n    vec3 gold = vec3(1.0, 0.9, 0.6) * 1.6;\n    \n    float t = fract(n * 3.0 + iTime * 0.1);\n    vec3 color;\n    if(t < 0.33) color = red;\n    else if(t < 0.66) color = blue;\n    else color = gold;\n    \n    float twinkle = 0.85 + 0.15 * sin(iTime * 2.0 + n * 6.28);\n    return color * twinkle * LIGHT_INTENSITY;\n}\n\n// Map function combining room, frames, and lights\nHit map(vec3 p) {\n    Hit hit;\n    hit.dist = MAX_DIST;\n    hit.emissive = vec3(0.0);\n    hit.isLight = false;\n    hit.isFrame = false;\n    \n    // Room bounds - NOT negated here\n    float room = sdBox(p, vec3(ROOM_SIZE));\n    float frames = gridPattern(p);\n    \n    // Light strings\n    vec3 lightGrid = floor(p / LIGHT_SPACING) * LIGHT_SPACING;\n    float minLightDist = MAX_DIST;\n    vec3 lightEmissive = vec3(0.0);\n    \n    // Optimized light distribution\n    vec3 localP = mod(p + 0.5 * LIGHT_SPACING, LIGHT_SPACING) - 0.5 * LIGHT_SPACING;\n    vec3 baseP = p - localP;\n    \n    for(float x = -1.0; x <= 1.0; x += 1.0) {\n        for(float z = -1.0; z <= 1.0; z += 1.0) {\n            for(float y = -1.0; y <= 1.0; y += 1.0) {\n                vec3 lightPos = baseP + vec3(x, y, z) * LIGHT_SPACING;\n                if(abs(lightPos.x) > ROOM_SIZE || \n                   abs(lightPos.y) > ROOM_SIZE || \n                   abs(lightPos.z) > ROOM_SIZE) continue;\n                \n                float d = length(p - lightPos) - LIGHT_SIZE;\n                if(d < minLightDist) {\n                    minLightDist = d;\n                    lightEmissive = getLightColor(lightPos);\n                }\n            }\n        }\n    }\n    \n    // Combine geometries correctly\n    hit.dist = min(-room, minLightDist);  // Negate room here\n    if(frames > 0.5) {\n        float wallDist = abs(room);\n        if(wallDist < FRAME_THICKNESS * 2.0) {\n            hit.isFrame = true;\n            hit.dist = minLightDist;\n        }\n    }\n    \n    if(minLightDist < SURF_DIST) {\n        hit.isLight = true;\n        hit.emissive = lightEmissive;\n    }\n    \n    return hit;\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(0.001, 0.0);\n    vec3 n = vec3(\n        map(p + e.xyy).dist - map(p - e.xyy).dist,\n        map(p + e.yxy).dist - map(p - e.yxy).dist,\n        map(p + e.yyx).dist - map(p - e.yyx).dist\n    );\n    return normalize(n);\n}\n\nvec3 trace(vec3 ro, vec3 rd) {\n    vec3 col = vec3(0.0);\n    vec3 contribution = vec3(1.0);\n    \n    for(int bounce = 0; bounce < MAX_BOUNCES; bounce++) {\n        vec3 p = ro;\n        float t = 0.0;\n        Hit hit;\n        \n        for(int i = 0; i < MAX_STEPS; i++) {\n            p = ro + rd * t;\n            hit = map(p);\n            if(abs(hit.dist) < SURF_DIST || t > MAX_DIST) break;\n            t += hit.dist;\n        }\n        \n        // Add ambient light contribution\n        col += contribution * vec3(AMBIENT_LIGHT);\n        \n        if(hit.isLight) {\n            col += contribution * hit.emissive;\n            break;\n        }\n        \n        if(hit.isFrame) {\n            col += contribution * vec3(0.05);\n            break;\n        }\n        \n        if(t < MAX_DIST) {\n            vec3 n = getNormal(p);\n            float fresnel = 0.98 + 0.02 * pow(1.0 - max(dot(-rd, n), 0.0), 5.0);\n            contribution *= fresnel * vec3(0.995);\n            \n            ro = p + n * 0.002;\n            rd = reflect(rd, n);\n            rd = normalize(rd + vec3(0.001) * (hash31(p) - 0.5));\n        } else {\n            break;\n        }\n        \n        // Russian roulette termination\n        float p_continue = max(max(contribution.x, contribution.y), contribution.z);\n        if(bounce > 3 && p_continue < 0.2) {\n            if(hash11(float(bounce)) > p_continue) break;\n            contribution /= p_continue;\n        }\n    }\n    \n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Camera\n    float t = iTime * 0.15;\n    vec3 ro = vec3(cos(t) * 3.5, 2.0 + sin(t * 0.5), sin(t) * 3.5);\n    vec3 lookAt = vec3(0.0, 0.0, 0.0);\n    \n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    vec3 rd = normalize(forward + right * uv.x + up * uv.y);\n    \n    // Render\n    vec3 col = trace(ro, rd);\n    \n    // Tone mapping and color grading\n    col = col / (vec3(0.8) + col);\n    col = pow(col, vec3(0.6));\n    \n    // Bloom\n    float brightness = dot(col, vec3(0.2126, 0.7152, 0.0722));\n    col += col * smoothstep(0.6, 0.9, brightness) * 0.4;\n    \n    // Final color adjustment\n    col = mix(col, col * vec3(1.02, 1.0, 0.98), 0.3);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}