{"ver":"0.1","info":{"id":"3tK3Dw","date":"1579250572","viewed":510,"name":"Riemann Sphere.","username":"Logos","description":"Little Riemann sphere.","likes":23,"published":1,"flags":0,"usePreview":0,"tags":["sdf","sphere","ao","riemann"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Robert Śmietana (Logos) - 17.01.2020\n// Bielsko-Biała, Poland, UE, Earth, Sol, Milky Way, Local Group, Laniakea :)\n\n// AO based on https://www.shadertoy.com/view/XlXyD4\n\n\n//--- program parameters ---/\n\nconst int   aoIter    = 12;\nconst float aoDist    = 0.207;\nconst float aoPower   = 2.0;\n\nconst int   marchIter = 70;\nconst float marchDist = 30.0;\nconst float epsilon   = 0.0001;\n\nvec3        InvCenter = vec3(0, 1, 0);\nfloat       InvRadius = 2.0;\n\n\n//--- ambient occlusion directions ---//\n\nconst vec3 aoDir[12] = vec3[12]\n(\n\tvec3(0.357407, 0.357407, 0.862856),\n\tvec3(0.357407, 0.862856, 0.357407),\n\tvec3(0.862856, 0.357407, 0.357407),\n\tvec3(-0.357407, 0.357407, 0.862856),\n\tvec3(-0.357407, 0.862856, 0.357407),\n\tvec3(-0.862856, 0.357407, 0.357407),\n\tvec3(0.357407, -0.357407, 0.862856),\n\tvec3(0.357407, -0.862856, 0.357407),\n\tvec3(0.862856, -0.357407, 0.357407),\n\tvec3(-0.357407, -0.357407, 0.862856),\n\tvec3(-0.357407, -0.862856, 0.357407),\n\tvec3(-0.862856, -0.357407, 0.357407)\n);\n\n\n//--- SDF related functions ---//\n\nfloat iDE(vec3 z)\n{\n\tvec2 e = z.xz;\n\n\tfloat d = sdeHexagonField(e, vec2(0.0), 12.0 + 7.0*sin(0.541*iTime), 0.95);\n\td = max(d, abs(z.y) - 0.1);\n\treturn d;\n}\n\nfloat scene(vec3 p)\n{\n    p = p.xzy;\n\tvec3 ori = p;\n    \n    p = rotate_x(p, sin(iTime));\n    p = rotate_z(p, sin(0.66*iTime));\n    \n    p -= vec3(0.0, 1.0, 0.0);\n\tfloat r = length(p);\n\tfloat r2 = r * r;\n\tp = (InvRadius / r2) * p + InvCenter;\n\tfloat d = iDE(p);\n\td = r2 * d / (InvRadius + r * d);\n\t\t\n\treturn min(ori.y + 1.0, 0.8 * max(-d, length(ori) - 1.0));\n}\n\nvec3 getColor(vec3 p)\n{\n    p = p.xzy;\n    \n    if (p.y < -0.99)\n    {\n\t    p.z -= 3.1415926535*0.25*sin(iTime);\n        p.x += 3.1415926535*0.25*sin(0.66*iTime);\n\n        float d = sdeHexagonField(p.xz, vec2(0.0), 1.0, 0.8);\n        if (d < 0.1) return vec3(1.0);\n        return vec3(0.8);\n    }\n    \n    return vec3(0.8 + 0.2*sin(0.5647*iTime), 1.0, 0.9);\n}\n\nfloat march(vec3 eye, vec3 dir)\n{\n    float depth = 0.0;\n    for (int i = 0; i < marchIter; ++i)\n    {\n        float dist = scene(eye + depth * dir);\n        depth += dist;\n        \n        if (dist < epsilon || depth >= marchDist)\n\t\t\tbreak;\n    }\n    return depth;\n}\n\nfloat ao(vec3 p, vec3 n)\n{\n    float dist = aoDist;\n    float occ = 1.0;\n    for (int i = 0; i < aoIter; ++i)\n    {\n        occ = min(occ, scene(p + dist * n) / dist);\n        dist *= aoPower;\n    }\n    occ = max(occ, 0.0);\n    return occ;\n}\n\nvec3 normal(vec3 p)\n{\n    return normalize(vec3(\n        scene(vec3(p.x + epsilon, p.y, p.z)) - scene(vec3(p.x - epsilon, p.y, p.z)),\n        scene(vec3(p.x, p.y + epsilon, p.z)) - scene(vec3(p.x, p.y - epsilon, p.z)),\n        scene(vec3(p.x, p.y, p.z + epsilon)) - scene(vec3(p.x, p.y, p.z - epsilon))\n    ));\n}\n\nvec3 ray(float fieldOfView, vec2 size, vec2 fragCoord, vec2 of)\n{\n    vec2 xy = fragCoord + of - size / 2.0;\n    float z = fieldOfView * size.y;\n    \n    return normalize(vec3(xy, -z));\n}\n\n\n//--- set this carefully, not more tham 12 ---//\n\n#define SAMPLE_COUNT 5\n\n\n//--- auxiliary functions ---//\n\nfloat hash(float seed) { return fract(sin(seed)*43758.5453); }\n\n\n//--- main ---//\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 final_color = vec3(0.0);\n    \n    for (int i = 0; i < SAMPLE_COUNT; i++)\n    {\n\t\tfloat sa = hash( dot( fragCoord, vec2(12.9898, 78.233) ) + 3213.1*float(i) );\n\t    vec2 of = -0.5 + vec2( hash(sa+13.271), hash(sa+63.216) );\n        \n        vec3 dir = ray(2.5, iResolution.xy, fragCoord, of);\n\n        vec3 eye = vec3(6.5*cos(0.1*iTime), 6.5*sin(0.1*iTime), 2.34 + 0.5 * sin(0.45*iTime));\n        vec3 center = vec3(0.0, 0.0, 0.0);\n\n        mat3 mat = viewMatrix(center - eye, vec3(0.0, 0.0, 1.0));\n        dir = mat * dir;\n\n        float depth = march(eye, dir);\n        if (depth >= marchDist - epsilon) { fragColor = vec4(1.0); return; }\n\n        vec3 p = eye + depth * dir;\n        vec3 n = normal(p);\n\n        mat = alignMatrix(n);\n        float col = 0.0;\n        for (int i = 0; i < aoIter; ++i)\n        {\n            vec3 m = mat * aoDir[i];\n            col += ao(p, m) * (0.5 + 0.5 * dot(m, vec3(0.0, 0.0, 1.0)));\n        }\n\n        vec3 color = getColor(p);\n        final_color += color * vec3(pow(0.26 * col, 0.7)); \n    }\n\n    fragColor = vec4(final_color / float(SAMPLE_COUNT), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//--- distance fields ---//\n\nfloat sdeHexagonField(vec2 P, vec2 C, float Z, float f)\n{\n\tP -= C;\n\tP *= Z;\n\tP.x *= 0.8660254037844386;\n\n\tvec2 P0 = mod(P, vec2(3.0, 2.0));\n\tvec2 P1 = abs(P0 - vec2(1.5, 1.0));\n\tvec2 P2 = abs(P1 - vec2(1.5, 1.0));\n\t\n\tfloat d1 = max(P1.x + 0.5 * P1.y, P1.y);\n\tfloat d2 = max(P2.x + 0.5 * P2.y, P2.y);\n\n\treturn (min(d1, d2) - f) / Z;\n}\n\n\n//--- matrix operations ---//\n\nmat3 viewMatrix(vec3 dir, vec3 up)\n{\n    vec3 f = normalize(dir);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nmat3 alignMatrix(vec3 dir)\n{\n    vec3 f = normalize(dir);\n    vec3 s = normalize(cross(f, vec3(0.48, 0.6, 0.64)));\n    vec3 u = cross(s, f);\n    return mat3(u, s, f);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_z(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, -sa, +.0,\n\t\t+sa, +ca, +.0,\n\t\t+.0, +.0, +1.0);\n}\n","name":"Common","description":"","type":"common"}]}