{"ver":"0.1","info":{"id":"csd3RX","date":"1678301391","viewed":533,"name":"ROCK ELEMENTAL","username":"alro","description":"The \"Adventurer's Guide to Survival\" chapter on rock elementals consists of two paragraphs on pickaxes and dynamite followed by twenty pages on escaping a cave system under duress. The book has never been out of print.","likes":53,"published":1,"flags":32,"usePreview":1,"tags":["procedural","3d","animation","metal","material","pbr","rock","stone","gold"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n    Exploring rock modelling and texturing. Use mouse to move camera.\n    See BufferB for details\n    \n    Ocean elemental: https://www.shadertoy.com/view/NdS3zK\n    Magma elemental: https://www.shadertoy.com/view/sdBGWh\n    Rock elemental: https://www.shadertoy.com/view/csd3RX\n\n*/\n\n\nconst vec3 DETAIL_SCALE = vec3(0.5);\nconst vec3 BLENDING_SHARPNESS = vec3(10.0);\nconst float DETAIL_HEIGHT = 0.02;\nconst float GOLD_DEPTH = 0.02625;\n\nconst float SHADOW_SHARPNESS = 8.0;\n\nconst float EPSILON = 1e-3;\nconst float MIN_DIST = 0.01;\nconst int MAX_STEPS = 64;\nconst float MAX_DIST = 8.0;\n\nconst vec3 modelOffset = vec3(0,0.5,0);\n\n#define CORE 0\n#define HEAD 1\n#define HANDS 2\n#define MIDDLE 3\n#define BOTTOM 4\n\n//---------------------------- Camera -----------------------------\n\nvec3 rayDirection(float fieldOfView, vec2 fragCoord) {\n    vec2 xy = fragCoord - iResolution.xy / 2.0;\n    float z = (0.5 * iResolution.y) / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n// https://www.geertarien.com/blog/2017/07/30/breakdown-of-the-lookAt-function-in-OpenGL/\nmat3 lookAt(vec3 camera, vec3 at, vec3 up){\n  vec3 zaxis = normalize(at-camera);    \n  vec3 xaxis = normalize(cross(zaxis, up));\n  vec3 yaxis = cross(xaxis, zaxis);\n\n  return mat3(xaxis, yaxis, -zaxis);\n}\n\n//----------------------------- Rotations -----------------------------\n\nvec3 rotate(vec3 p, vec4 q){\n  return 2.0 * cross(q.xyz, p * q.w + cross(q.xyz, p)) + p;\n}\nvec3 rotateX(vec3 p, float angle){\n    return rotate(p, vec4(sin(angle/2.0), 0.0, 0.0, cos(angle/2.0)));\n}\nvec3 rotateY(vec3 p, float angle){\n\treturn rotate(p, vec4(0.0, sin(angle/2.0), 0.0, cos(angle/2.0)));\n}\nvec3 rotateZ(vec3 p, float angle){\n\treturn rotate(p, vec4(0.0, 0.0, sin(angle), cos(angle)));\n}\n\n//---------------------------- Operations -----------------------------\n\nfloat smoothSub( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\n// https://iquilezles.org/articles/smin\nfloat smoothMin(float a, float b, float k){\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\n//---------------------- Distance functions ----------------------\n//https://iquilezles.org/articles/distfunctions/\n\nfloat sdBox( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sphereSDF(vec3 p, float radius) {\n    return length(p) - radius;\n}\n\nfloat sdRoundCone( vec3 p, float r1, float r2, float h ){\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdCylinder( vec3 p, vec3 c ){\n  return length(p.xz-c.xy)-c.z;\n}\n\n//-------------------------- AABB -------------------------\n\n// Only evaluate the distance function when near a feature or when looking at it.\n// This improves performance as we skip complex distance calculations for many pixels.\n\n// https://gist.github.com/DomNomNom/46bb1ce47f68d255fd5d\n// Compute the near and far intersections using the slab method.\n// No intersection if tNear > tFar.\nvec2 intersectAABB(vec3 rayOrigin, vec3 rayDir, vec3 boxMin, vec3 boxMax) {\n    vec3 tMin = (boxMin - rayOrigin) / rayDir;\n    vec3 tMax = (boxMax - rayOrigin) / rayDir;\n    vec3 t1 = min(tMin, tMax);\n    vec3 t2 = max(tMin, tMax);\n    float tNear = max(max(t1.x, t1.y), t1.z);\n    float tFar = min(min(t2.x, t2.y), t2.z);\n    return vec2(tNear, tFar);\n}\n\nbool insideAABB(vec3 p, vec3 boxMin, vec3 boxMax){\n    float eps = 1e-4;\n\treturn  (p.x > boxMin.x-eps) && (p.y > boxMin.y-eps) && (p.z > boxMin.z-eps) && \n\t\t\t(p.x < boxMax.x+eps) && (p.y < boxMax.y+eps) && (p.z < boxMax.z+eps);\n}\n\nbool testAABB(vec3 org, vec3 dir, vec3 boxMin, vec3 boxMax){\n\tvec2 intersections = intersectAABB(org, dir, boxMin, boxMax);\n\t\n    if(insideAABB(org, boxMin, boxMax)){\n        intersections.x = 1e-4;\n    }\n    \n    return intersections.x > 0.0 && (intersections.x < intersections.y);\n}\n\n\n//------------------------- Geometry -------------------------\n\nvec3 getCoreRotation(vec3 p){\n    p = rotateX(p, 0.03*cos(0.5*iTime)*PI);\n    return p;\n}\nvec3 getCoreInverseRotation(vec3 p){\n    p = rotateX(p, -0.03*cos(0.5*iTime)*PI);\n    return p;\n}\n\nvec3 getCoreOffset(vec3 p){\n    p -= modelOffset;\n    p.y += 0.05*cos(iTime);\n    return p;\n}\n\nvec3 getHeadOffset(vec3 p){\n    p -= modelOffset;\n    p.y += 0.025*cos(2.0*iTime);\n    return p;\n}\n\nvec3 getHandRotation(vec3 p){\n    p = rotateY(p, 0.01*sin(iTime)*PI);\n    p = rotateX(p, 0.01*cos(iTime)*PI);\n    return p;\n}\n\nvec3 getHandInverseRotation(vec3 p){\n    p = rotateX(p, -0.01*cos(iTime)*PI);\n    p = rotateY(p, -0.01*sin(iTime)*PI);\n    return p;\n}\n\nvec3 getHandOffset(vec3 p){\n    p -= modelOffset;\n    p.y += 1.0+0.05*sin(2.0*iTime);\n    return p;\n}\n\nvec3 getMiddleOffset(vec3 p){\n    p.x += 0.15*sin(iTime);\n    p.z += 0.15*cos(iTime);\n    p.y += 1.0+0.035*sin(2.0*iTime);\n    return p;\n}\n\nvec3 getMiddleRotation(vec3 p){\n    p = rotateY(p, 0.075*iTime*PI);\n    p = rotateX(p, 0.15*iTime*PI);\n    return p;\n}\n\nvec3 getMiddleInverseRotation(vec3 p){\n    p = rotateX(p, -0.15*iTime*PI);\n    p = rotateY(p, -0.075*iTime*PI);\n    return p;\n}\n\nvec3 getBottomOffset(vec3 p){\n    p.x += 0.1*sin(PI*0.5-iTime);\n    p.z += 0.1*cos(PI*0.5-iTime);\n    p.y += 1.55+0.025*sin(-2.0*iTime);\n    return p;\n}\n\nvec3 getBottomRotation(vec3 p){\n    p = rotateY(p, 0.05*iTime*PI);\n    p = rotateX(p, 0.1*iTime*PI);\n    return p;\n}\n\nvec3 getBottomInverseRotation(vec3 p){\n    p = rotateX(p, -0.1*iTime*PI);\n    p = rotateY(p, -0.05*iTime*PI);\n    return p;\n}\n\nfloat getHandSDF(vec3 p){\n\n    // Round cone carved by boxes and planes\n\n    vec3 q = p;\n    float dist = sdRoundCone(q, 0.5, 0.7, 0.4);\n\n    float smoothness = 0.03;\n    \n    q = p;\n    q = rotateY(q, 0.5*PI);\n    dist = smoothSub(-sdBox(q, vec3(0.25, 2.0, 1.5)), dist, smoothness);\n    \n    q = p;\n    q = rotateY(q, 0.35*PI);\n    dist = smoothSub(-sdBox(q, vec3(0.25, 2.0, 1.5)), dist, smoothness);\n    \n    // Fists\n    q = p;\n    q.y += 0.1;\n    q.z += 0.3;\n    q = rotateY(q, 0.45*PI);\n    q = rotateZ(q, 0.3*PI);\n    dist = smoothMin(sdRoundBox(q, vec3(0.2, 0.1, 0.3), 0.1), dist, 0.1);\n    \n    q = p;\n    q.y -= 0.3;\n    q = rotateY(q, -0.15*PI);\n    dist = smoothSub(-sdBox(q, vec3(0.45, 0.7, 1.5)), dist, smoothness);\n    \n    q = p;\n    q.y -= 0.3;\n    q = rotateZ(q, -0.1*PI);\n    dist = smoothSub(-sdBox(q, vec3(0.5, 0.7, 1.5)), dist, smoothness);\n    \n    q = p;\n    q.z -= 0.5;\n    q = rotateX(q, -0.2*PI);\n    q = rotateY(q, -0.05*PI);\n    dist = smoothSub(sdBox(q, vec3(1.5, 1.7, 0.25)), dist, smoothness);\n\n    return dist;\n}\n\nfloat getHeadSDF(vec3 p){\n\n    // Main shape is a round box\n    vec3 q = p;\n    q.y += 0.02;\n    q = rotateX(q, 0.03*PI);\n    float dist = sdRoundBox(q, vec3(0.275, 0.2, 0.45), 0.05);\n\n    float smoothness = 0.03;\n    \n    // Carve sphere\n    q = p;\n    dist = smoothSub(-sphereSDF(q, 0.35), dist, smoothness);\n    \n    // Carve back of head away from body\n    q = p;\n    q.x -= 0.3;\n    dist = smoothSub(-sphereSDF(q, 0.5), dist, smoothness);\n\n    // Two cylinders for eyes\n    q = p;\n    float size = q.z > 0.0 ? 0.055 : 0.07;\n    q.y += 0.1;\n    q.z = abs(q.z);\n    q = rotateY(q, -0.5*PI);\n    q = rotateX(q, -0.5*PI);\n    dist = smoothSub(sdCylinder(q, vec3(-0.175, 0.0, size)), dist, 0.03);\n\n    return dist;\n}\n\nfloat getCoreSDF(vec3 p){\n\n    vec3 q = p;\n    float dist = sphereSDF(q, 1.0);\n\n    float smoothness = 0.03;\n\n    // Carve away several planes using wide boxes\n    // -------------------------------------------\n    q = p;\n    q = rotateY(q, 0.2*PI);\n    q = rotateZ(q, -0.1*PI);\n    dist = smoothSub(-sdBox(q, vec3(0.7, 2.0, 1.5)), dist, smoothness);\n\n    q = p;\n    q = rotateY(q, 0.25*PI);\n    q = rotateZ(q, 0.1*PI);\n    dist = smoothSub(-sdBox(q, vec3(0.75, 2.0, 1.5)), dist, smoothness);\n\n    q = p;\n    q = rotateY(q, -0.75*PI);\n    q = rotateY(q, -0.5*PI);\n    dist = smoothSub(-sdBox(q, vec3(0.75, 2.0, 1.5)), dist, smoothness);\n\n    q = p;\n    q = rotateY(q, 0.5*PI);\n    dist = smoothSub(-sdBox(q, vec3(0.8, 2.0, 1.5)), dist, smoothness);\n\n    q = p;\n    q = rotateY(q, 0.7*PI);\n    q = rotateZ(q, 0.35*PI);\n    dist = smoothSub(-sdBox(q, vec3(0.8, 2.0, 1.5)), dist, smoothness);\n\n    // -------------------------------------------\n\n    // Hollow for head\n    q = p;\n    q.x -= 1.6;\n    q.y += 0.3;\n    dist = smoothSub(sphereSDF(q, 1.0), dist, 0.05);\n    \n    return dist;\n}\n\nfloat getMiddleSDF(vec3 p){\n    vec3 q = p;\n    float dist = sdRoundBox(q, vec3(0.175), 0.03);\n    \n    \n    float smoothness = 0.02;\n    // Carve away several planes using wide boxes\n    // -------------------------------------------\n    q = p;\n    q = rotateZ(q, -0.3*PI);\n    dist = smoothSub(-sdBox(q, vec3(0.175, 2.0, 1.5)), dist, smoothness);\n    \n    q = p;\n    q = rotateY(q, 0.5*PI);\n    q = rotateZ(q, 0.4*PI);\n    dist = smoothSub(-sdBox(q, vec3(0.175, 2.0, 1.5)), dist, smoothness);\n\n    q = p;\n    q = rotateY(q, -0.25*PI);\n    q = rotateZ(q, 0.35*PI);\n    dist = smoothSub(-sdBox(q, vec3(0.175, 2.0, 1.5)), dist, smoothness);\n    \n    // -------------------------------------------\n    return dist;\n}\n\nfloat getBottomSDF(vec3 p){\n    vec3 q = p;\n    float dist = sdRoundBox(q, vec3(0.1), 0.03);\n    \n    \n    float smoothness = 0.02;\n    // Carve away several planes using wide boxes\n    // -------------------------------------------\n    q = p;\n    q = rotateY(q, 0.5*PI);\n    q = rotateZ(q, -0.3*PI);\n    dist = smoothSub(-sdBox(q, vec3(0.1, 2.0, 1.5)), dist, smoothness);\n    \n    q = p;\n    q = rotateY(q, -0.25*PI);\n    q = rotateZ(q, 0.7*PI);\n    dist = smoothSub(-sdBox(q, vec3(0.1, 2.0, 1.5)), dist, smoothness);\n    \n    // -------------------------------------------\n    return dist;\n}\n\nfloat getSDF(vec3 p, vec3 dir, out int partID){\n\n    float dist = 1e5;\n    vec3 q = p;\n    \n    float previousDist = dist;\n    partID = -1;\n    \n    // Core body\n    if(testAABB(p, dir, vec3(-1.1, -1.2, -0.9) + modelOffset, \n                        vec3(0.9, 1.1, 0.9) + modelOffset)){\n        vec3 q = p;\n        q = getCoreOffset(q);\n        q = getCoreRotation(q);\n        dist = min(getCoreSDF(q), dist);\n        \n        if(previousDist > dist){\n            previousDist = dist;\n            partID = CORE;\n        }\n    }\n    \n    // Head    \n    if(testAABB(p, dir, vec3(0.6, -0.55, -0.4)  + modelOffset, \n                        vec3(1.3, 0.1, 0.4) + modelOffset)){\n        q = p;\n        q.x -= 0.9;\n        q.y += 0.2;\n        q = getHeadOffset(q);\n        dist = min(getHeadSDF(q), dist);\n        if(previousDist > dist){\n            previousDist = dist;\n            partID = HEAD;\n        }\n    }\n    \n    // Hands\n    if(testAABB(p, dir, vec3(-0.3, -1.6, 0.6) + modelOffset, \n                        vec3(1.1, 0.1, 1.75) + modelOffset) ||\n       testAABB(p, dir, vec3(-0.3, -1.6, -1.75) + modelOffset, \n                        vec3(1.1, 0.1, -0.6) + modelOffset)){\n \n        q = p;\n        q = getHandOffset(q);\n        q = getHandRotation(q);\n        q.z = abs(q.z);\n        q.z -= 1.3;\n        q.x -= 0.5;\n\n        q = rotateZ(q, -0.05*PI);\n        q = rotateY(q, -0.15*PI);\n        q = rotateX(q, 0.05*PI);\n\n        dist = min(getHandSDF(q), dist);\n\n        if(previousDist > dist){\n            previousDist = dist;\n            partID = HANDS;\n        }\n    }\n    \n    // Middle\n    if(testAABB(p, dir, vec3(-0.6, -1.9, -0.6) + modelOffset,\n                        vec3(0.6, -1.0, 0.6) + modelOffset)){\n        q = p;\n        q = getMiddleOffset(q);\n        q = getMiddleRotation(q);\n        dist = min(getMiddleSDF(q), dist);\n        \n        if(previousDist > dist){\n            previousDist = dist;\n            partID = MIDDLE;\n        }\n    }\n    \n    // Bottom\n    if(testAABB(p, dir, vec3(-0.5, -2.3, -0.5) + modelOffset, \n                        vec3(0.5, -1.7, 0.5) + modelOffset)){\n        q = p;\n        q = getBottomOffset(q);\n        q = getBottomRotation(q);\n        dist = min(getBottomSDF(q), dist);\n       \n        if(previousDist > dist){\n            previousDist = dist;\n            partID = BOTTOM;\n        }\n    }\n\n    return dist;\n}\n\nfloat distanceToScene(vec3 cameraPos, vec3 rayDir, float start, float end, out int partID) {\n\t\n    float depth = start;\n    \n    float dist;\n    \n    for (int i = ZERO; i < MAX_STEPS; i++){\n\n        dist = getSDF(cameraPos + depth * rayDir, rayDir, partID);\n\n        if (dist < EPSILON){ return depth; }\n\n        depth += dist;\n\n        if (depth >= end){ return end; }\n    }\n    \n    return depth;\n}\n\n// Tetrahedral normal technique with a loop to avoid inlining getSDF()\n// This should improve compilation times\n// https://iquilezles.org/articles/normalsSDF\nvec3 getNormal(vec3 p, vec3 dir){\n    vec3 n = vec3(0.0);\n    int id;\n    for(int i = ZERO; i < 4; i++){\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*getSDF(p+e*EPSILON, dir, id);\n    }\n    return normalize(n);\n}\n\nvec4 getTexture(vec2 uv){\n    return texture(iChannel1, uv);\n}\n\nvec4 getTriplanar(vec3 position, vec3 normal){\n    vec4 xaxis = getTexture(DETAIL_SCALE.x*(position.zy));\n    vec4 yaxis = getTexture(DETAIL_SCALE.y*(position.zx));\n    vec4 zaxis = getTexture(DETAIL_SCALE.z*(position.xy));\n\n    vec3 blending = abs(normal);\n\tblending = normalize(max(blending, 0.00001));\n    blending = pow(blending, BLENDING_SHARPNESS);\n\tfloat b = (blending.x + blending.y + blending.z);\n\tblending /= b;\n\n    return\txaxis * blending.x + \n       \t\tyaxis * blending.y + \n        \tzaxis * blending.z;\n}\n\n\n\n// Return the position of p extruded in the normal direction by normal map\nvec3 getDetailExtrusion(vec3 p, vec3 normal){\n\n    // Get rock and seam height texture\n    vec2 data = getTriplanar(p, normal).rg;\n    \n    // Add crevices for gold seam\n    float detail = DETAIL_HEIGHT * data.r - GOLD_DEPTH * smoothstep(0.5, 1.0, data.g);\n    \n    return p + detail * normal;\n}\n\n// Return the normal direction after applying a normal map\nvec3 getDetailNormal(vec3 p, vec3 normal){\n    vec3 tangent;\n    vec3 bitangent;\n    // Construct orthogonal directions tangent and bitangent to sample detail gradient in\n    pixarONB(normal, tangent, bitangent);\n    \n    tangent = normalize(tangent);\n    bitangent = normalize(bitangent);\n    \n    float EPS = 1e-3;\n    vec3 delTangent = \tgetDetailExtrusion(p + tangent * EPS, normal) - \n        \t\t\t\tgetDetailExtrusion(p - tangent * EPS, normal);\n    \n    vec3 delBitangent = getDetailExtrusion(p + bitangent * EPS, normal) - \n        \t\t\t\tgetDetailExtrusion(p - bitangent * EPS, normal);\n    \n    return normalize(cross(delTangent, delBitangent));\n}\n\n//---------------------------- Material ----------------------------\n\nvec3 getAlbedo(float h, float m){\n    //Grey based on heightmap\n    vec3 base = mix(0.125 * vec3(0.75), 0.15 * vec3(1.5), smoothstep(0.15, 1.0, h));\n    //Add reddish spots\n    vec3 tint = clamp(base * 0.5 * vec3(1, 0.5, 0.3), 0.0, 1.0);\n    return base = mix(base, tint, smoothstep(0.45, 0.75, m));\n}\n\nfloat getMetalness(float h){\n    return smoothstep(0.6, 0.7, h);\n}\n\nfloat getRoughness(float h){\n    return mix(0.4, 0.9, smoothstep(0.8, 0.2, h));\n}\n\n//---------------------------- PBR ----------------------------\n\n// Trowbridge-Reitz\nfloat distribution(vec3 n, vec3 h, float roughness){\n    float a_2 = roughness * roughness;\n\treturn a_2/(PI * pow(pow(dot_c(n, h), 2.0) * (a_2 - 1.0) + 1.0, 2.0));\n}\n\n// GGX and Schlick-Beckmann\nfloat geometry(float cosTheta, float k){\n\treturn (cosTheta) / (cosTheta * (1.0 - k) + k);\n}\n\nfloat smiths(float NdotV, float NdotL, float roughness){\n    float k = pow(roughness + 1.0, 2.0) / 8.0; \n\treturn geometry(NdotV, k) * geometry(NdotL, k);\n}\n\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness){\n    return F0 + (max(vec3(1.0-roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n// Cook-Torrance BRDF\nvec3 BRDF(vec3 p, vec3 n, vec3 viewDir, vec3 lightDir, vec3 albedo, float metalness, \n            float roughness, vec3 F0){\n            \n    vec3 h = normalize(viewDir + lightDir);\n    float cosTheta = dot_c(h, viewDir);\n    \n    // Lambertian diffuse reflectance\n    vec3 diffuse = albedo / PI;\n    \n    // Normal distribution\n    // What fraction of microfacets are aligned in the correct direction\n    float D;\n\n    // Fresnel term\n    // How reflective are the microfacets viewed from the current angle\n    vec3 F = fresnelSchlickRoughness(cosTheta, F0, roughness);\n\n    // Geometry term\n    // What fraction of the microfacets are lit and visible\n    float G;\n    \n    // Visibility term. \n    // In Filament it combines the geometry term and the denominator\n    float V;\n    \n    float NdotL = dot_c(lightDir, n);\n    float NdotV = dot_c(viewDir, n);\n    \n    D = distribution(n, h, roughness);\n    G = smiths(NdotV, NdotL, roughness);\n    V = G / max(0.0001, (4.0 * NdotV * NdotL));\n        \n    // Specular reflectance\n    vec3 specular = D * F * V;\n    \n    // Combine diffuse and specular\n    vec3 kD = (1.0 - F) * (1.0 - metalness);\n    return kD * diffuse + specular;\n}\n\n\n//---------------------------- Shadows ----------------------------\n\n// https://iquilezles.org/articles/rmshadows\nfloat softShadow(vec3 pos, vec3 rayDir, float start, float end, float k ){\n    float res = 1.0;\n    float depth = start;\n    int id;\n    for(int counter = ZERO; counter < 32; counter++){\n        float dist = getSDF(pos + rayDir * depth, rayDir, id);\n        if( abs(dist) < EPSILON){ return 0.0; }       \n        if( depth > end){ break; }\n        res = min(res, k*dist/depth);\n        depth += dist;\n    }\n    return res;\n}\n\n//---------------------------- Lighting ----------------------------\n\nvec3 getLightPosition(int i){\n\n    float offset = -1.0;\n\n    if(i == 0){\n        return vec3(30.0*cos(offset+0.2), 8.0, -30.0*sin(offset+0.2)); \n    }\n    return vec3(20.0*cos(3.2+offset), 1.0,  -20.0*sin(3.2+offset));\n}\n\nvec3 getEnvironment(vec3 rayDir){\n    return mix(0.5*vec3(0.5, 0.3, 0.1), vec3(0.09, 0.35, 0.81), 0.5+0.5*rayDir.y);\n}\n\nvec3 getAmbientLight(vec3 normal){\n    vec3 gradient = mix(vec3(0.15), vec3(2), 0.5+0.5*normal.y);\n    return 1.0*mix(gradient, 4.0*getEnvironment(normal), 0.15);\n}\n\nvec3 getIrradiance(vec3 p, vec3 rayDir, vec3 geoNormal, int partID){\n    vec3 I = vec3(0);\n    vec3 radiance = vec3(0);\n    vec3 lightDir = vec3(0);\n    vec3 vectorToLight = vec3(0);\n    \n    // While lighting uses the actual point in space, texturing requires the \n    // position relative to the shape so that it's unaffected by transformation.\n    // To undo translation and rotation points are offset and rotated while normals are \n    // only rotated. We obtain object space coordinates and normal\n    vec3 textureP = p;\n    vec3 textureNormal = geoNormal;\n    \n    switch(partID){\n        case CORE: \n            textureP = getCoreOffset(p);\n            textureP = getCoreRotation(textureP);\n            textureNormal = getCoreRotation(geoNormal);\n            break;\n        case HEAD: textureP = getHeadOffset(p); break;\n        case HANDS:\n            textureP = getHandOffset(p);\n            textureP = getHandRotation(textureP);\n            textureNormal = getHandRotation(geoNormal);\n            break;\n        case MIDDLE: \n            textureP = getMiddleOffset(p);\n            textureP = getMiddleRotation(textureP);\n            textureNormal = getMiddleRotation(geoNormal);\n            break;\n        case BOTTOM: \n            textureP = getBottomOffset(p);\n            textureP = getBottomRotation(textureP);\n            textureNormal = getBottomRotation(geoNormal);\n            break;\n    }\n    \n    // The detail normal is sampled in object space and then rotated to world-space\n    // for shading\n    vec3 n = getDetailNormal(textureP, textureNormal);\n    \n    switch(partID){\n    case CORE:\n        n = getCoreInverseRotation(n);\n        break;\n    case HANDS:\n        n = getHandInverseRotation(n);\n        break;\n    case MIDDLE:\n        n = getMiddleInverseRotation(n);\n        break;\n    case BOTTOM:\n        n = getBottomInverseRotation(n);\n        break;\n    }\n    \n    \n    vec4 data = getTriplanar(textureP, textureNormal);\n    float h = data.r;\n    float ao = data.a;\n    \n    vec3 albedo = getAlbedo(data.r, data.b);\n    \n    // Add bright ridges\n    albedo += albedo * mix(0.0, 0.35, smoothstep(0.2, 1.5, ao));\n    // Add dark crevices\n    albedo *= mix(0.95, 1.0, smoothstep(0.25, 0.5, ao));\n\n    float metalness = getMetalness(data.g);\n    float roughness = getRoughness(h);\n    roughness = mix(roughness, 0.1, metalness);\n\n    // Index of refraction for common dielectrics. Corresponds to f0 0.04\n    const float IOR = 1.5;\n\n    // Reflectance of the surface when looking straight at it along the negative normal\n    vec3 F0 = vec3(pow(IOR - 1.0, 2.0) / pow(IOR + 1.0, 2.0));\n    \n    // Metal uses gold reflectance\n    F0 = mix(F0, vec3(1.022, 0.782, 0.344), metalness);\n    \n    // Find direct lighting for all sources\n    for(int i = ZERO; i < 2; i++){\n        \n        vec3 position = getLightPosition(i);\n        vectorToLight = position - p;\n        lightDir = normalize(vectorToLight);\n        radiance = i == 0 ? 3.0 * vec3(1.0, 0.95, 0.9) : 1.5 * vec3(0.45, 0.75, 1.0);\n        \n        float shadow = softShadow(p + n * EPSILON * 2.0, lightDir, MIN_DIST, \n                                                        MAX_DIST, SHADOW_SHARPNESS);\n                                  \n        I +=  shadow \n            * BRDF(p, n, -rayDir, lightDir, albedo, metalness, roughness, F0) \n            * radiance \n            * dot_c(n, lightDir);\n    }\n\n    \n    // Use simple gradient for diffuse ambient light\n    vec3 F = fresnelSchlickRoughness(dot_c(n, -rayDir), F0, roughness);\n\tvec3 kD = (1.0 - F) * (1.0 - metalness);\n\tvec3 irradiance = getAmbientLight(n);\n\tvec3 diffuse    = irradiance * albedo / PI;\n\n    // Use low LOD of cubemap for specular ambient\n    vec3 env = mix(0.5 * getEnvironment(reflect(rayDir, n)), \n               0.225 * textureLod(iChannel2, normalize(reflect(rayDir, n)), 4.0).rgb, 1.0);\n    vec3 specular = env * F;\n    \n\tvec3 ambient  = kD * diffuse + specular;\n    \n    // Add dark crevices for occlusion\n    ambient *= mix(0.9, 1.0, smoothstep(0.25, 0.5, ao));\n    \n    // Combine direct and ambient lighting\n    return ambient + I;\n}\n\n//-------------------------- Tonemap and render -------------------------\n\n// https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x){\n    return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n\t//----------------- Define a camera -----------------\n    \n    vec3 rayDir = rayDirection(60.0, fragCoord);\n\n    vec3 cameraPos = texelFetch(iChannel0, ivec2(0.5, 1.5), 0).xyz;\n    vec3 targetDir = -cameraPos;\n    vec3 up = vec3(0.0, 1.0, 0.0);\n\n    // Get the view matrix from the camera orientation.\n    mat3 viewMatrix = lookAt(cameraPos, targetDir, up);\n\n    // Transform the ray to point in the correct direction.\n    rayDir = normalize(viewMatrix * rayDir);\n\n    //---------------------------------------------------\n\n    vec3 p = vec3(0);\n    vec3 col = vec3(0);\n    \n    // Keep track which part we render\n    int partID = -1;\n    float t = distanceToScene(cameraPos, rayDir, MIN_DIST, MAX_DIST, partID);\n    \n    if(t < MAX_DIST){\n        p = cameraPos + rayDir * t;\n        vec3 normal = getNormal(p, rayDir);\n        col = getIrradiance(p, rayDir, normal, partID);\n    } else {\n        col = 0.05 * getEnvironment(rayDir);\n    }\n    \n    col = ACESFilm(col);\n    col = gamma(col);\n    \n    // Height map\n    //col = texture(iChannel1, fragCoord/iResolution.xy).rrr;\n    \n    // Occlusion map\n    //col = texture(iChannel1, fragCoord/iResolution.xy).aaa;\n        \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\n    Copyright (c) 2023 al-ro\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the \"Software\"), to deal\n    in the Software without restriction, including without limitation the rights\n    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all\n    copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n    SOFTWARE.\n*/\n\n#define PI 3.14159\n#define TWO_PI (2.0 * PI)\n#define HALF_PI (0.5 * PI)\n\n#define GAMMA 2.2\n#define INV_GAMMA (1.0/GAMMA)\n\n//  Variable iterator initializer to stop loop unrolling\n#define ZERO (min(iFrame,0))\n\n// Minimum dot product value\nconst float minDot = 1e-3;\n\n// Clamped dot product\nfloat dot_c(vec3 a, vec3 b){\n\treturn max(dot(a, b), minDot);\n}\n\n// Get orthonormal basis from surface normal\n// https://graphics.pixar.com/library/OrthonormalB/paper.pdf\nvoid pixarONB(vec3 n, out vec3 b1, out vec3 b2){\n\tfloat sign_ = n.z >= 0.0 ? 1.0 : -1.0;\n\tfloat a = -1.0 / (sign_ + n.z);\n\tfloat b = n.x * n.y * a;\n\tb1 = vec3(1.0 + sign_ * n.x * n.x * a, sign_ * b, -sign_ * n.x);\n\tb2 = vec3(b, sign_ + n.y * n.y * a, -n.y);\n}\n\nvec3 gamma(vec3 col){\n\treturn pow(col, vec3(INV_GAMMA));\n}\n\nfloat saturate(float x){\n    return max(0.0, min(x, 1.0));\n}\n\nfloat remap(float x, float low1, float high1, float low2, float high2){\n\treturn low2 + (x - low1) * (high2 - low2) / (high1 - low1);\n}\n\n// Debug code\n/*\n    if(showAABB){\n        // Core\n        if(testAABB(cameraPos, rayDir, vec3(-1.1, -1.2, -0.9) + modelOffset, \n                                       vec3(0.9, 1.1, 0.9) + modelOffset)){\n            col += 0.1*vec3(1,0,0);\n        }\n        \n        // Head\n        if(testAABB(cameraPos, rayDir, vec3(0.6, -0.55, -0.4)  + modelOffset, \n                                       vec3(1.3, 0.1, 0.4) + modelOffset)){\n            col += 0.1*vec3(0,1,0);\n        }\n\n        // Hands\n        if(testAABB(cameraPos, rayDir, vec3(-0.3, -1.6, 0.6) + modelOffset, \n                                       vec3(1.1, 0.1, 1.75) + modelOffset) ||\n           testAABB(cameraPos, rayDir, vec3(-0.3, -1.6, -1.75) + modelOffset, \n                                       vec3(1.1, 0.1, -0.6) + modelOffset)){\n           col += 0.1*vec3(0,0,1);\n        }\n        \n        // Middle\n        if(testAABB(cameraPos, rayDir, vec3(-0.6, -1.9, -0.6) + modelOffset, \n                                       vec3(0.6, -1.0, 0.6) + modelOffset)){\n            col += 0.1*vec3(0,1,1);\n        }\n        \n        // Bottom\n        if(testAABB(cameraPos, rayDir, vec3(-0.5, -2.2, -0.5) + modelOffset, \n                                       vec3(0.5, -1.7, 0.5) + modelOffset)){\n            col += 0.1*vec3(1,0,1);\n        }\n    }\n    \n    if(partID == 0){\n        col = vec3(1,0,0);\n    }\n    \n    if(partID == 1){\n        col = vec3(0,1,0);\n    }\n    \n    if(partID == 2){\n        col = vec3(0,0,1);\n    }\n    \n    if(partID == 3){\n        col = vec3(0,1,1);\n    }\n    \n    if(partID == 4){\n        col = vec3(1,0,1);\n    }\n     */ ","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Track mouse movement and resolution change between frames and set camera position.\n\n#define CAMERA_DIST 3.5\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // Work with just the first four pixels.\n    if((fragCoord.x == 0.5) && (fragCoord.y < 4.0)){\n        \n        vec4 oldData = texelFetch(iChannel0, ivec2(0.5), 0).xyzw;\n\n        vec2 oldPolarAngles = oldData.xy;\n        vec2 oldMouse = oldData.zw;\n\n        vec2 polarAngles = vec2(0);\n        vec2 mouse = iMouse.xy / iResolution.xy; \n        \n        // Stop camera going directly above and below\n        float angleEps = 0.01;\n\n        float mouseDownLastFrame = texelFetch(iChannel0, ivec2(0.5, 3.5), 0).x;\n        \n        // If mouse button is down and was down last frame.\n        if(iMouse.z > 0.0 && mouseDownLastFrame > 0.0){\n            \n            // Difference between mouse position last frame and now.\n            vec2 mouseMove = mouse - oldMouse;\n            polarAngles = oldPolarAngles + vec2(5.0, 3.0) * mouseMove;\n            \n        }else{\n            polarAngles = oldPolarAngles;\n        }\n        \n        polarAngles.x = mod(polarAngles.x, 2.0 * PI - angleEps);\n        polarAngles.y = min(PI - angleEps, max(angleEps, polarAngles.y));\n\n        // Store mouse data in the first pixel of Buffer A.\n        if(fragCoord == vec2(0.5, 0.5)){\n            // Set value at first frames.\n            if(iFrame < 10){\n                polarAngles = vec2(2.9, 1.7);\n                mouse = vec2(0);\n            }\n            \n            fragColor = vec4(polarAngles, mouse);\n        }\n\n        // Store camera position in the second pixel of Buffer A.\n        if(fragCoord == vec2(0.5, 1.5)){\n            // Cartesian direction from polar coordinates.\n            vec3 cameraPos = normalize(vec3(-cos(polarAngles.x) * sin(polarAngles.y), \n                                             cos(polarAngles.y), \n                                            -sin(polarAngles.x) * sin(polarAngles.y)));\n\n            fragColor = vec4(CAMERA_DIST * cameraPos, 1.0);\n        }\n        \n        // Store resolution change data in the third pixel of Buffer A.\n        if(fragCoord == vec2(0.5, 2.5)){\n            float resolutionChangeFlag = 0.0;\n            // The resolution last frame.\n            vec2 oldResolution = texelFetch(iChannel0, ivec2(0.5, 2.5), 0).yz;\n            \n            if(iResolution.xy != oldResolution){\n            \tresolutionChangeFlag = 1.0;\n            }\n            \n        \tfragColor = vec4(resolutionChangeFlag, iResolution.xy, 1.0);\n        }\n           \n        // Store whether the mouse button is down in the fourth pixel of Buffer A\n        if(fragCoord == vec2(0.5, 3.5)){\n            if(iMouse.z > 0.0){\n            \tfragColor = vec4(vec3(1.0), 1.0);\n            }else{\n            \tfragColor = vec4(vec3(0.0), 1.0);\n            }\n        }\n        \n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*\n    Rock material using tiled splatting and noise layering\n    \n    Inspired by:\n    https://www.shadertoy.com/view/XdcfDf\n    https://www.shadertoy.com/view/ls3fzj\n    https://www.youtube.com/watch?v=kh3aAHKsjqY\n    \n    We want to create a height map that looks like a realistc rock formation.\n    This raises a deceptively simple question - what do rocks look like?\n    This is impossible to answer as there are many different kinds of rock. One description\n    is perhaps that a rock's look is mostly decided by its shape and roughness. Rocks can also\n    exhibit high frequency colour variation but the same is true for sand etc. However, when \n    shaped in an uncommon way, rock can cease to look like rock. For extreme examples consider\n    marble sculptures and the walls of Antelope Canyon. \n    \n    Let's take the stereotypical rock to look like rough granite or limestone. The structure\n    is a mixture of different crystalline materials. When the surface is damaged, whole chips\n    are ejected and other regions remain sticking out. This creates a varying landscape of \n    dips, furrows and peaks. The borders of these areas are abrupt, reflecting the scale\n    of the material heterogeneity. The surface can also be affected by water erosion, ice \n    expansion and biological processes. This leads to deeper cracks and fractures.\n    \n    We start by creating a field of regular polygon height maps (triangles in this shader). \n    These are rotated, scaled, stretched and smudged to introduce randomness. The field is\n    then carved with slashes and high-frequency dips and raises from a stepped gradient\n    noise field. The sharpness of the cuts and peaks controls how granular the material will \n    look with sharper cuts looking more rocky and smoother variation resembling dirt or mud.\n    \n    We store the maximum height of the overlapping carved polygons but any way of mixing is \n    valid. The idea is that we end up with a height field that looks layered and randomly \n    varied. In the next pass we layer the texture multiple times like an FBM. We also detect\n    how much of a texel is surrounded by higher regions. This information is used for ambient\n    occlusion and ridge highlighting when we shade the material. Using simple height based\n    colouring and roughness calculations leads to a convincing rock look even with a simple\n    greyscale gradient.\n    \n    All of the above lacks any real citation but the target for a good rock look seems to be\n    a multi-frequency layered height field of irregular sharp variations.\n\n    \n*/\n\nmat2 rotate(float angle){\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, -s, s, c);\n}\n\n//https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * 0.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 modulo(vec2 m, float n){\n  return mod(mod(m, n) + n, n);\n}\n\nvec2 hash(vec2 p, float m){\n    p = modulo(p, m);\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(0.1031, 0.1030, 0.0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return 2.0 * fract((p3.xx+p3.yz)*p3.zy) - 1.0;\n}\n\n// 5th order polynomial interpolation\nvec2 fade(vec2 t){\n    return (t * t * t) * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\nfloat gradientNoise(vec2 p, float m){\n\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\t\n\tvec2 u = fade(f);\n    \n    /*\n        For 1D, the gradient of slope g at vertex u has the form h(x) = g * (x - u), \n        where u is an integer and g is in [-1, 1].\n        This is the equation for a line with slope g which intersects the x-axis at u.\n        For N dimensional noise, use dot product instead of multiplication, and do \n        component-wise interpolation. For 2D, bilinear. For 3D, trilinear.\n    */\n    return  mix( mix( dot( hash( i + vec2(0.0,0.0), m ), f - vec2(0.0,0.0) ), \n                      dot( hash( i + vec2(1.0,0.0), m ), f - vec2(1.0,0.0) ), u.x),\n                 mix( dot( hash( i + vec2(0.0,1.0), m ), f - vec2(0.0,1.0) ), \n                      dot( hash( i + vec2(1.0,1.0), m ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nvec2 getGradient(vec2 uv, float scale){\n    const float eps = 1e-1;\n    return (vec2(gradientNoise(uv + vec2(-eps, 0.0), scale) - \n                 gradientNoise(uv + vec2(eps, 0.0), scale),\n                 gradientNoise(uv + vec2(0.0, -eps), scale) - \n                 gradientNoise(uv + vec2(0.0, eps), scale)));\n}\n\nfloat fbm(vec2 pos, float scale, int N){\n    float res = 0.0;\n    float freq = 1.0;\n    float amp = 1.0;\n    float weight = 0.0;\n    \n    for(int i = 0; i < N; i++){\n        res += gradientNoise(freq*pos, scale) * amp;\n        weight += amp;\n        freq *= 2.0;\n        amp *= 0.75;\n    }\n    return res/weight;\n}\n\n// https://www.shadertoy.com/view/7tSXzt\n// Signed distance to a regular n-gon\nfloat sdNGon(vec2 p, float r ){\n    float an = 6.2831853/float(3); // <---- Side count\n    float he = r*tan(0.5*an);\n    \n    p = -p.yx;\n    float bn = an*floor((atan(p.y,p.x)+0.5*an)/an);\n    vec2  cs = vec2(cos(bn),sin(bn));\n    p = mat2(cs.x,-cs.y,cs.y,cs.x)*p;\n\n    return length(p-vec2(r,clamp(p.y,-he,he)))*sign(p.x-r);\n}\n\n// Normalised internal distance of a polygon with radius 3\nfloat getHeight(vec2 uv){\n    return -sdNGon(uv, 3.0) / 3.0;\n}\n\nvec3 getHeightFromTexture(vec2 uv){\n            vec3 h = vec3(0);\n            float w = 1.0;\n            float sum = 0.0;\n            for(float i = float(ZERO); i < 3.0; i++){\n                // This should not be textureLod() but Windows does aggressive prefetching\n                // which means that we pay the texture read cost every frame, even when we \n                // do not enter this function. \n                // Using a variable LOD stops the compiler from guessing wrong.\n                h += w * textureLod(iChannel0, pow(2.0, i) * uv, float(ZERO)).rgb;\n                sum += w;\n                w *= 0.5;\n            }\n            \n            return h / sum;\n}\n\n// Get something like an occlusion map by finding how much of a texture point\n// is surrounded by higher parts.\nfloat getAO(vec2 uv){\n    \n    float h = getHeightFromTexture(uv).r;\n    \n    float del = 0.1;\n    float height = 0.0;\n    float eps = 3e-3;\n    float count = 0.0;\n    float iterations = 0.0;\n    for(float i = float(ZERO); i < TWO_PI; i += del){\n        float hh = getHeightFromTexture(uv + eps * vec2(cos(i), sin(i))).r;\n        if(hh > h){\n            count++;\n        }\n        iterations++;\n    }\n    count /= iterations;\n    \n    return 1.0 - count;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    bool needsSecondPass = texelFetch(iChannel0, ivec2(0.5, 0.5), 0).r > 0.0;\n    bool resolutionChanged = texelFetch(iChannel1, ivec2(0.5, 2.5), 0).r > 0.0;\n\n    if(iFrame == 0 || resolutionChanged){\n\n        float scale = 8.0;\n\n        float h = -1e5;\n        float noiseScale = 3.0;\n\n        // Work in cells and consider surrounding ones as we shift shapes around randomly.\n        for(float i = -5.0; i <= 5.0; i += 1.0){\n            for(float j = -5.0; j <= 5.0; j += 1.0){\n                // The cell UV used for the polygon shapes\n                vec2 uv = fragCoord/iResolution.xy;\n                vec2 cell = mod(floor(uv * scale) - vec2(i, j), scale);\n                uv = fract(uv * scale) + vec2(i, j);\n\n                // Random offset based on cell\n                uv -= hash12(cell);\n                \n                // Rotate based on cell\n                mat2 m = rotate(TWO_PI * hash12(cell));\n                uv = m * uv;\n\n                // The UV used for noise based on the cell uv but not stretched or smudged\n                vec2 noiseUV = noiseScale * uv;\n\n                // Stretch shape in one direction\n                uv.y *= mix(0.5, 2.0, hash12(cell));\n\n                // Smudge base shape based on noise gradient\n                vec2 grad = getGradient(noiseUV, 32.0);\n                grad *= normalize(grad);\n                uv += 0.25 * grad;\n                // Offset some more for fun\n                uv += 0.5;\n                \n                // Get polygon distance as height\n                float newHeight = getHeight(uv);\n\n                // Slashes\n                newHeight -= 32.0 * pow(max(0.0, (gradientNoise(noiseUV * vec2(1.0, 0.05) +\n                             0.1 * sin(vec2(2.0 * noiseUV.y, 0.0)), 1000.0))), 4.0);\n                // Raised areas\n                newHeight += 0.2 * smoothstep(0.1, 0.3, abs(fbm(0.35 * noiseUV, 1000.0, 4)));\n                // Sunken areas\n                newHeight -= 0.5 * smoothstep(0.1, 0.25, abs(fbm(0.25 * noiseUV, 1000.0, 4)));\n                \n                // Record larger value\n                h = max(h, newHeight);\n                \n            }\n        }\n        \n        // Remap values to be in [0-1]\n        h = saturate(remap(h, 0.6, 1.0, 0.0, 1.0));\n        \n        // Output to screen\n        fragColor = vec4(vec3(h), 0.0);\n        \n        // Green channel will hold simple noise texture for gold seams\n        fragColor.g = 0.5+0.5*fbm(12.0*fragCoord/iResolution.xy, 12.0, 3);\n\n        // Blue channnel will hold simple noise texture for colour variation\n        fragColor.b = 0.5+0.5*fbm(16.0*fragCoord/iResolution.xy, 16.0, 3);\n        \n        // Call second pass\n        if(ivec2(fragCoord.xy) == ivec2(0.5, 0.5)){\n            fragColor.r = 1.0;\n        }\n        \n    }else if(iFrame == 1 || needsSecondPass){\n        vec2 uv = fragCoord/iResolution.xy;\n        \n        // Layer the results of the previous pass multiple times and find occlusion\n        fragColor = vec4(getHeightFromTexture(uv), getAO(uv));\n        \n        // Adjust gold seam texture to be sharper\n        fragColor.g = 2.0 * pow(fragColor.g, 2.0);\n        \n        // Do not call second pass again\n        if(ivec2(fragCoord.xy) == ivec2(0.5, 0.5)){\n            fragColor.r = 0.0;\n        }\n    }else{\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n    }\n}","name":"Buffer B","description":"","type":"buffer"}]}