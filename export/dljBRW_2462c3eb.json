{"ver":"0.1","info":{"id":"dljBRW","date":"1695805644","viewed":31,"name":"Fork SIGGRAPH RT Class3 Triangle","username":"zadiemla","description":"Ray Sphere intersection for class 3","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["intersection","class3","rayshpere"],"hasliked":0,"parentid":"ml2Bzh","parentname":"Fork SIGGRAPH RT Class 3"},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float seed = 0.0;\n\nvec3 bgColor = vec3(0, 1, 1);\n\n// random number between 0 and 1\nfloat random() {\n    return fract(sin(seed++)*43758.5453123);\n}\n\nstruct Light {\n    vec3 location;\n    vec3 color;\n};\n\n// Sphere is defined by a center and radius and material: color\nstruct Sphere {\n\tfloat radius;\n\tvec3 center;\n    vec3 color;\n};\n\n// Triangle is defined by its three vertices\nstruct Triangle {\n    vec3 vertexA;\n    vec3 vertexB;\n    vec3 vertexC;\n    vec3 color;\n};\n\n// Ray is define by an origin point and a direction vector\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct TriangleHitRecord {\n    float t;\n    Triangle hitTriangle;\n};\n\nstruct SphereHitRecord {\n    float t;\n    Sphere hitSphere;\n};\n\nSphere spheres[4];\nLight lights[1];\nTriangle triangles[1];\n    \n// Intersection code for Ray-Sphere    \nSphereHitRecord raySphereIntersect(in Ray ray) {\n\n    float t = 1000000.0; // initialize to a large number\n    Sphere hitSphere = spheres[0];\n    for (int i = 0; i < spheres.length(); i++)\n    {\n        Sphere sphere = spheres[i];\n        vec3 rayToSphere = ray.origin - sphere.center;\n        float b = dot(rayToSphere, ray.direction);\n        float c = dot(rayToSphere, rayToSphere) - (sphere.radius * sphere.radius);\n        float disc = b*b - c;\n        if (disc > 0.0) {\n            float candidateT = -b - sqrt(disc);\n            if (candidateT > 0.00001 && candidateT < t)\n            {\n                t = candidateT;\n                hitSphere = spheres[i];\n                continue;\n            }\n            /*\n            if (t > 0.00001) {\n                return t;\n            }\n            */\n            candidateT = -b + sqrt(disc);\n            if (candidateT > 0.00001 && candidateT < t)\n            {\n                t = candidateT;\n                hitSphere = spheres[i];\n                continue;\n            }\n            /*\n            if (t > 0.00001) {\n                return t;\n            }  \n            */\n        }\n    }\n    return SphereHitRecord(t, hitSphere);\n\n    /*\n    vec3 rayToSphere = ray.origin - sphere.center;\n    float b = dot(rayToSphere, ray.direction);\n    float c = dot(rayToSphere, rayToSphere) - (sphere.radius * sphere.radius);\n\tfloat disc = b*b - c;\n    float t = 1000000.0; // initialize to a large number\n    if (disc > 0.0) {\n        t = -b - sqrt(disc);\n        if (t > 0.00001) {\n            return t;\n        }\n        t = -b + sqrt(disc);\n        if (t > 0.00001) {\n            return t;\n        }  \n    }\n    return t;\n    */\n}\n\n// Intersection code for Ray-Triangle \nTriangleHitRecord rayTriangleIntersect(in Ray ray) {\n    float EPSILON = 0.0000001;\n    Triangle triangle = triangles[0];\n    TriangleHitRecord record = TriangleHitRecord(1000000.0, triangle);\n    \n    vec3 edge1 = triangle.vertexB - triangle.vertexA;\n    vec3 edge2 = triangle.vertexC - triangle.vertexA;\n    vec3 h = cross(ray.direction, edge2);\n    float a = dot(edge1, h);\n\n    if (a > -EPSILON && a < EPSILON)\n        return record;    // This ray is parallel to this triangle.\n\n    float f = 1.0 / a;\n    vec3 s = ray.origin - triangle.vertexA;\n    float u = f * dot(s, h);\n\n    if (u < 0.0 || u > 1.0)\n        return record;\n\n    vec3 q = cross(s, edge1);\n    float v = f * dot(ray.direction, q);\n\n    if (v < 0.0 || u + v > 1.0)\n        return record;\n\n    // At this stage we can compute t to find out where the intersection point is on the line.\n    float t = f * dot(edge2, q);\n    if (t > EPSILON) // ray intersection\n    {\n       record.t = t;\n    }\n    // If not, then this means that there is a line intersection but not a ray intersection\n    return record;\n}\n\nvoid makeScene(int f) {\n    spheres[0] = Sphere(1.5, vec3(0.5, 0, -6), vec3(1, 1, 0));\n    spheres[1] = Sphere(0.8, vec3(0, 0, -4), vec3(0,1,0));\n    spheres[2] = Sphere(0.1, vec3(-0.5,0,-2), vec3(1,0,0));\n    spheres[3] = Sphere(4.0, vec3(0,-3,-10), vec3(0,1,1));\n    lights[0] = Light(vec3(sin(float(f)/50.0), 0.0, 0.0), vec3(1,1,1));\n    triangles[0] = Triangle(vec3(-0.5, -0.5, -2), vec3(0.5, -0.5, -2), vec3(0, 0.5, -2), vec3(1,1,0));\n}\n\nint numSamples = 100;\n\n\n/* The main entry point:\n   * This is called for every pixel on the screen \n*/\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n   \n   // fragCoord ranges from \n   //   in x: 0.5 to iResolution.x-0.5\n   //   in y: 0.5 to iResolution.y-0.5\n   // pixel (0,0) is at the bottom left corner\n   \n   makeScene(iFrame);\n   \n   vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n   \n   float screenDepth = -2.0;\n   \n   float width = iResolution.x;\n   float height = iResolution.y; \n   \n   vec3 samp = vec3(0, 0, 0);\n   seed = 0.0;\n   for (int i=0; i<numSamples; i++) {\n       float x = fragCoord.x + random() - 0.5;\n       float y = fragCoord.y + random() - 0.5;\n       \n   \n       // map (0.5, w-0.5) to (-1, 1)\n       // and (0.5, h-0.5) to (-1, 1)\n       x = (x/width)*2.0 - 1.0;\n       y = (y/height)*2.0 - 1.0;\n       \n       // account for the non-square window\n       float aspectRatio = width/height;\n       y = y/aspectRatio;\n       \n       vec3 rayDirection = normalize(vec3(x, y, screenDepth));\n       \n       Ray ray = Ray(rayOrigin, rayDirection);\n       \n       // SphereHitRecord record = raySphereIntersect(ray);\n       TriangleHitRecord record = rayTriangleIntersect(ray);\n       /*\n       if (record.t < 1000000.0) {\n           vec3 hit = ray.origin + record.t*ray.direction;\n           vec3 norm = normalize(hit - record.hitSphere.center);\n           vec3 hitPointToLight = normalize(lights[0].location - hit);\n           float angle = dot(hitPointToLight, norm);\n           float u = asin(norm.x)/3.14 + 0.5;\n           float v = asin(norm.y)/3.14 + 0.5;\n           record.hitSphere.color = record.hitSphere.color * texture(iChannel0, vec2(u,v)).xyz;\n           samp = samp + abs(angle)*record.hitSphere.color;\n       } \n       */\n       if (record.t < 1000000.0) {\n           vec3 hit = ray.origin + record.t*ray.direction;\n           vec3 triangleCentroid = vec3((record.hitTriangle.vertexA.x + record.hitTriangle.vertexB.x + record.hitTriangle.vertexC.x) / 3.0,\n                                        (record.hitTriangle.vertexA.y + record.hitTriangle.vertexB.y + record.hitTriangle.vertexC.y) / 3.0,\n                                        (record.hitTriangle.vertexA.z + record.hitTriangle.vertexB.z + record.hitTriangle.vertexC.z) / 3.0);\n           vec3 norm = normalize(hit - triangleCentroid);\n           vec3 hitPointToLight = normalize(lights[0].location - hit);\n           float angle = dot(hitPointToLight, norm);\n           // float u = asin(norm.x)/3.14 + 0.5;\n           // float v = asin(norm.y)/3.14 + 0.5;\n           // record.hitTriangle.color = record.hitTriangle.color * texture(iChannel0, vec2(u,v)).xyz;\n           samp = samp + abs(angle)*record.hitTriangle.color;\n       } \n   }\n   fragColor = vec4(samp/float(numSamples), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}