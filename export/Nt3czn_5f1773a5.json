{"ver":"0.1","info":{"id":"Nt3czn","date":"1659072638","viewed":161,"name":"Hex Grid (Xtro)","username":"Xtro","description":"Simplified version of https://www.shadertoy.com/view/wtdSzX","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["grid","hex"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Simplified and modified version of https://www.shadertoy.com/view/wtdSzX\n\n// I needed to convert UV data to the integer coordinates of the hexes originating from the top left corner of\n// the screen so I modified the original getHex function a little bit.\n\nconst vec2 sqr3 = vec2(1, 1.7320508); // Y value is the square root of 3.\nconst float horizontalHexCount = 16.; // How many hexes we want to place into the full image horizontally.\n\nvec4 getHex(vec2 p)\n{    \n    p.y = 1. - p.y; // Up is 0 and bottom is 1 because the top-left hex coordinates is (0, 0).\n    \n    p *= horizontalHexCount; \n    // After this placement of N number of hexes horizontally, the magic numbers we use below are in integer hex coordinates.\n    // 1 is 1 hex and .5 is half hex.\n\n    p.y -= sqr3.y/3.; // We shift the vertical index by One Third of Square Root of 3 to make the top tip of the first hex touch the top of the screen.  \n    p.x -= .5; // We shift the horizontal index left by half a hex because we want a full hex on (0, 0) coordinate rather than a half hex.\n\n// vvv  This part is from the original shader.\n    vec4 hC = floor(vec4(p, p - vec2(.5, 1))/sqr3.xyxy) + .5;\n    \n    vec4 h = vec4(p - hC.xy*sqr3, p - (hC.zw + .5)*sqr3);\n    \n    vec4 result = dot(h.xy, h.xy) < dot(h.zw, h.zw) \n        ? vec4(h.xy, hC.x - 1., hC.y) \n        : vec4(h.zw, hC.z, hC.w + .5);\n// ^^^\n\n    result.z += .5; // We revert the left shift we did earlier to get integer indexes like 1, 2, 3 instead of 1.5, 2.5, 3.5.\n    \n    // I don't know about the math used above but for some reason it returns the vertical hex indexes as half numbers like .5, 1, 1.5, 2 and so on.\n    // We need to double them to get integer indexes like 1, 2, 3, 4.\n    result.w *= 2.; \n\n    return result;\n}\n\n// This function was called as \"hex\" in the original shader but I can't understand why because it's used to get the distance so I name it accordingly.\nfloat getDistanceFromHexCenter(vec4 hex)\n{    \n    vec2 p = abs(hex.xy);\n    \n    return 2. * max(dot(p, sqr3*.5), p.x);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.x; // Spread the full UV range (0 to 1) to width of the screen.\n    // Uncomment this line to see the UV spread.\n    //fragColor = vec4(uv, 0, 1); return;\n    \n    vec4 hex = getHex(uv); // Convert UV to hex info.\n    \n    float d = getDistanceFromHexCenter(hex);\n\n    vec3 color = vec3(smoothstep(.99, .96, d));\n    \n    fragColor = vec4(color, 1);    \n}","name":"Image","description":"","type":"image"}]}