{"ver":"0.1","info":{"id":"slXXRl","date":"1626287715","viewed":89,"name":"pretty warm up","username":"nicholasSanguine","description":"Little bit of extra work making a split circle of our desired color otherwise showing the background color. Later on I will be choosing two effects I like to put in the respective opposing corners of the circles. Those who see this feel free to vote.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["wip","psychedelic","barreldistortion","derusting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iChannelResolution[0].xy;\n    vec2 uvTwo = fragCoord / iChannelResolution[1].xy;\n    vec2 uvThree = fragCoord / iChannelResolution[2].xy;\n    vec4 imageOne =texture(iChannel0, uv);\n    vec4 imageTwo =texture(iChannel1, uvTwo);\n    vec4 imageThree =texture(iChannel2, uvThree);\n    \n    fragColor = imageOne;\n    fragColor = imageTwo;\n    fragColor = imageThree;\n    fragColor = imageTwo * imageThree;\n//    fragColor = imageThree;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec3 hashedWave(vec2 rg, float time, float magnitude, float b)\n{\n    vec3 result;\n    result = vec3(cos(time * rg * magnitude),b);\n    return result;\n}\n//given our passed vec2 in [-1,+1] space we bring it to [0,+1] space and translate to color for our purposes\n\nvec2 barrelDistortion(vec2 loc, float magnitude, float radius)\n{\n    float theta = atan(loc.y,loc.x);\n    radius = pow(radius, magnitude);\n    loc.x = radius * cos(theta);\n    loc.y = radius * sin(theta);\n    \n    return 0.5 * (loc + 1.0);\n}\n\n//Transfer relative position (x or y coord) with the given axis (x or y) \n//relative to axis itself if you want down the middle pass in .5, .25 for quarter of the screen, etc.\n//Multiplication costs less to do then division is why we do this.\nbool splitScreen(float relativePos, float axisSplit, float sectionSplit)\n{\n    return (relativePos < axisSplit * sectionSplit);\n}\n\n//Currently displays desired color if you are within the circle & in the top right or top left of the circle\n//More to come with tinkering with this function.\nvec4 drawSplitCircle(vec2 loc, vec2 center , float radius, vec4 currentCol, vec4 desiredColOne, vec4 desiredColTwo)\n{\n//efficient drawing of circle instead of using float dist = length(loc - center);\n// if(dist <= radius)  \n    vec2 diff = loc - center;\n\n    if (dot(diff,diff) <= radius * radius)\n       {\n       //if left side of the screen\n           if(splitScreen(loc.x, center.x, 1.0))\n                {\n                    //if bottom left of the screen\n                    if(splitScreen(loc.y, center.y, 1.0))\n                        return desiredColOne;\n                    //if top left\n                    else\n                        return desiredColOne * (vec4(1.0,0.0,1.0,1.0) * vec4(loc.y, 0.0, loc.x,1.0));\n                }\n                //if right side\n           if(!splitScreen(loc.x, center.x, 1.0))\n               {\n                   //if top right\n                   if(!splitScreen(loc.y, center.y, 1.0))\n                   {\n                       return desiredColTwo;\n                   }\n                   else\n                   //if bottom right\n                   return desiredColTwo * vec4(0.0,1.0,0.0,1.0);\n               }\n        }\n    return currentCol * vec4(0.92,0.92,0.92,1.0);\n}\n\n// calcViewport: calculate the viewing plane (viewport) coordinate\n//    viewport:       output viewing plane coordinate\n//    ndc:            output normalized device coordinate\n//    uv:             output screen-space coordinate\n//    aspect:         output aspect ratio of screen\n//    resolutionInv:  output reciprocal of resolution\n//    viewportHeight: input height of viewing plane\n//    fragCoord:      input coordinate of current fragment (in pixels)\n//    resolution:     input resolution of screen (in pixels)\nvoid calcViewport(out vec2 viewport, out vec2 ndc, out vec2 uv,\n                  out float aspect, out vec2 resolutionInv,\n                  in float viewportHeight, in vec2 fragCoord, in vec2 resolution)\n{\n    // inverse (reciprocal) resolution = 1 / resolution\n    resolutionInv = 1.0 / resolution;\n    \n    // aspect ratio = screen width / screen height\n    aspect = resolution.x * resolutionInv.y;\n\n    // uv = screen-space coordinate = [0, 1) = coord / resolution\n    uv = fragCoord * resolutionInv;\n\n    // ndc = normalized device coordinate = [-1, +1) = uv*2 - 1\n    ndc = uv * 2.0 - 1.0;\n\n    // viewport: x = [-aspect*h/2, +aspect*h/2), y = [-h/2, +h/2)\n    viewport = ndc * (vec2(aspect, 1.0) * (viewportHeight * 0.5));\n}\n//turning this into a float hit\nfloat hitSphere(in vec4 rayDirection, in vec4 rayOrigin, float radius, vec3 center)\n{\n    vec3 dist = rayOrigin.xyz - center;\n    float a = dot(rayDirection, rayDirection);\n    float half_b = dot(dist, rayDirection.xyz);\n    float c = dot(dist,dist) - radius * radius;\n    float doesHit = half_b * half_b - a * c;\n    \n    if(doesHit < 0.0)\n    {\n        return -1.0;\n    }\n    else\n    {\n        return (-half_b - sqrt(doesHit) / a);\n    }\n}\n\n\n\n//closest to making a class we will get with GLSL\n\nstruct sRay\n{\n    vec4 origin;\n    vec4 direction;\n\n};\n\n//initialize our ray struct\nsRay newRay(in vec3 origin, in vec3 direction)\n{\n    sRay ray;\n    ray.origin = vec4(origin, 1.0);\n    ray.direction = vec4(direction, 0.0);\n    return ray;\n}\n\n//calculate a point along a ray and return it.\nvec4 atRay(float distAlongRay, sRay ray)\n{\n    return ray.origin + distAlongRay * ray.direction;\n}\n\n// calcRay: calculate the ray direction and origin for the current pixel\n//    rayDirection: output direction of ray from origin\n//    rayOrigin:    output origin point of ray\n//    viewport:     input viewing plane coordinate (use above function to calculate)\n//    focalLength:  input distance to viewing plane\nvoid calcRay(out sRay ray, in vec2 viewport, in float focalLength)\n{\n    ray = newRay(vec3(0.0), vec3(viewport, -focalLength));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coord with respect to one dimension to avoid ellipses.\n    vec2 uv = fragCoord/iResolution.yy;\n    //hard coded center for my screen\n    vec2 centerScreen = vec2(.89,0.5);\n    float radius = cos(iTime *  .25);\n    float magnitude = cos(iTime);\n    //due to our changing circle being from a cos wave it dips into the negatives once in a while\n    //these if statements are how I decided to correct for it.\n    vec3 colorPosLeft = hashedWave(uv.yx, iTime, 3.0, 0.5);\n    vec3 colorPosRight = hashedWave(uv,iTime,3.0, 0.25 );\n    const float maxRadius = .25;\n    if (radius >= maxRadius)\n    {\n        radius = maxRadius;\n    }\n    if(radius <= -maxRadius)\n    {\n        radius = -maxRadius;\n    }\n//    float radius = .25;\n    vec4 desiredCol = vec4(hashedWave(uv / vec2(0.92,0.92), iTime, 2.5, .8), 1.0);\n    vec4 circleFinalCol;\n    \n\n    vec3 splitCol;\n    vec3 tempCol = vec3(uv, .25);\n    //Need to make a function that splits the screen at some point\n    if(splitScreen(fragCoord.x, iResolution.x , 0.5))\n    {\n        fragColor = vec4(vec3(colorPosLeft * tempCol), 1.0);\n    }\n    else\n    {\n    //moving box creation with the current effects being primarily blue scale. Wait long enough you will see the cos ripple.\n        fragColor = vec4(colorPosRight / tempCol, 1.0);\n    }\n    //calculated at the end so we can see the circle.\n    circleFinalCol = vec4(drawSplitCircle(uv, centerScreen, radius, fragColor, desiredCol, vec4(colorPosLeft, 1.0)));\n    fragColor = circleFinalCol;\n    //using barrelDistortion as a color alteration passing uv and swizzled uv.\n    fragColor +=vec4(barrelDistortion(uv,magnitude, radius),0.0,1.0);\n//    fragColor -= vec4(barrelDistortion(uv.yx, magnitude,radius),0.0,1.0);\n//  fragColor *= vec4(barrelDistortion(uv.xy, magnitude,radius),0.0,1.0);\n//    fragColor /= vec4(barrelDistortion(uv.yx, magnitude,radius),0.0,1.0);\n//    fragColor = mix(circleFinalCol,vec4(barrelDistortion(uv.yx, magnitude,radius), 0.0,1.0), 0.5f);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec4 sobelOperator(vec4 image)\n{\n    \n    return vec4(1.0,1.0,1.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iChannelResolution[0].xy;\n/*SOBEL OPERATOR ONE\n    |+1 0 -1|\n    |+2 0 -2|\n    |+1 0 -1|\n*/\n    float a = 1.0;\n    float b = 2.0;\n    mat3 sobelOne = mat3( a, 0.0, -a,\n                          b, 0.0, -b,\n                          a, 0.0, -a );\n    vec4 currentImage = texture(iChannel0, uv); \n    fragColor = vec4(currentImage.xyz * sobelOne, 1.0); \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"vec4 sobelOperator(vec4 image)\n{\n    return vec4(0.,0.,0.,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n vec2 uv = fragCoord / iChannelResolution[0].xy;\n\n/*SOBEL OPERATOR TWO\n    |+1 +2  +1|\n    | 0  0  0 |\n    |-1 -2  -1|\n\n*/\n    float a = 1.0;\n    float b = 2.0;\n    mat3 sobelTwo = mat3(  a,   b,   a,\n                         0.0, 0.0, 0.0,\n                          -a,  -b, -a );\n    vec4 currentImage = texture(iChannel0, uv); \n    fragColor = vec4(currentImage.xyz * sobelTwo, 1.0); \n}","name":"Buffer C","description":"","type":"buffer"}]}