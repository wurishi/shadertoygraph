{"ver":"0.1","info":{"id":"lXffz7","date":"1728170198","viewed":57,"name":"Dat Nya","username":"trancor","description":"D'oh da dee da d'oh d'oh\nD'oh da dee da d'oh","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["nyan","animation","cat","frames"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// -- -- -- -- -- -- -- -- -- --\n//  Kevin Edzenga, Oct. 2024\n//    gh: ProcStack\n// -- -- -- -- -- -- -- -- -- --\n// -- -- --\n// --\n\n// CLICK THE CAT   .w,\n//   *~,.+^=_=`,^~[]ⁿ·ⁿ\n\n// -- -- -- -- -- --\n\n// Buffer A - Star Burst & Background\n// Buffer B - Rainbow Trail\n\n// -- -- -- -- -- --\n\n#define NYAN_SIZE .125\n#define NYAN_FPS_MULT 2.5\n\n#define TRAIL_HEIGHT .08\n#define TRAIL_OFFSET vec2(-0.055,-0.002)\n\n#define RAINBOW_RATE 2.5\n#define RAINBOW_FREQ 25.0\n#define RAINBOW_DANCE_OFFSET 4.0\n\n// -- -- --\n\n// `HOP_ANIM_PERC` is 0-1% in the 6 frame animation when Hop happens\n// `HOP_ANIM_SCALE` is the lead up/out frames from HOP_ANIM_PERC\n//   ```hopOffset = max(0.0,1.0-abs(animPerc - HOP_ANIM_PERC)*HOP_ANIM_SCALE)```\n#define HOP_ANIM_PERC .1\n#define HOP_ANIM_SCALE 2.5\n#define HOP_HEIGHT 0.025\n\n// -- -- -- -- -- --\n\n#define FRAME_COUNT 6.0\n#define FRAME_COUNT_A 7.0\n#define FRAME_COUNT_N 5.0\n#define FRAME_RATIO (1.0/FRAME_COUNT_N)\n\n#define EPSILON 0.0001\n\n\n// -- -- -- -- -- -- -- -- --\n// -- -- -- -- -- -- -- -- --\n// -- -- -- -- -- -- -- -- --\n\n\n// Draw Nyan Cat with given size at location\nvec4 drawNyanCat( vec2 baseUv, vec2 nyanCentroid, vec2 size ){\n\n    vec2 nyanUv = baseUv;\n    \n    // Min Max in U\n    vec2 minMax = vec2( nyanCentroid.x - size.x, nyanCentroid.x + size.x );\n    nyanUv.x = (nyanUv.x - minMax.x) / (minMax.y-minMax.x);\n    // Min Max in V\n    minMax = vec2( nyanCentroid.y - size.y, nyanCentroid.y + size.y );\n    nyanUv.y = (nyanUv.y - minMax.x) / (minMax.y-minMax.x);\n\n    // Draw mask to keep thing clean and purdy\n    vec2 drawMaskUV = step( abs(nyanUv-.5), vec2(.5, .5) );\n    float drawMask = drawMaskUV.x*drawMaskUV.y;\n    \n    // Nyan Frame Read -\n    // `nyanCentroid.y` is frame randomization\n    float frameOffset = mod(iTime*NYAN_FPS_MULT ,1.0);\n    float animPerc = floor( frameOffset * FRAME_COUNT ) * FRAME_RATIO;\n    frameOffset = ( 1.0 / (FRAME_COUNT+.35) ) * floor( frameOffset*FRAME_COUNT );\n   \n    \n    // Add a pep to that step!\n    //  Since there is no hop in the animation on ShaderToy\n    //    But there is a hop in the original Nyan Cat\n    float hopOffset = max(0.0,1.0-abs(animPerc - HOP_ANIM_PERC)*HOP_ANIM_SCALE);\n    nyanUv.y -= hopOffset * HOP_HEIGHT;\n    // Add hop as a counter wiggle to give some anticipation & reprieve\n    nyanUv.x += hopOffset * HOP_HEIGHT;\n    \n    float uVal = frameOffset + nyanUv.x/FRAME_COUNT_A;\n    nyanUv = vec2( uVal, nyanUv.y );\n    vec4 nyanCat = texture(iChannel0, nyanUv);\n    \n    nyanCat*=drawMask;\n    return nyanCat;\n    \n}\n\n// Helper script to merge Nyan Cat draws\nvec4 compNyanCat( vec2 uv, vec2 nyanCentroid, vec2 nyanSize ){\n    vec4 curNyan = drawNyanCat( uv, nyanCentroid, nyanSize );\n    return curNyan * curNyan.a;\n}\n\n\n\n// -- -- -- --\n\n\n\n// Draw Rainbow Trail with given thickness at location\nvec4 drawNyanRainbowTrail( vec2 baseUv, vec2 nyanCentroid, float height, float danceDist ){\n\n    // nyanCentroid\n    float time = iTime*RAINBOW_RATE;\n    vec2 nyanUv = baseUv;\n    float flipShift = fract( nyanCentroid.y + time );\n    flipShift = (step( .5, flipShift )*2.0 - 1.0);\n    \n    // Multiplier is trail dance frquency\n    // Frequency mult is trail dance offset\n    \n    float segment = mod(floor((nyanCentroid.x-nyanUv.x+flipShift)*RAINBOW_FREQ), 2.0) * flipShift;\n    \n    //float segment = abs(mod(((nyanCentroid.x-nyanUv.x + flipShift)*RAINBOW_FREQ), 2.0)-1.0);\n    //float canMove = step( .1, abs(segment-.5) );\n    //segment = ((segment-.5) * 4.0) * canMove ; // 4.0 to fit -1 to 1\n    //segment = mix( -step( segment, 0.0 ),  step( 0.0, segment ),  step( 0.0, segment-.1 ) );\n    //segment *= canMove;\n    \n    nyanUv.y += segment*danceDist ;\n\n    \n    // Min Max in U\n    vec2 minMax = vec2( 0.0, nyanCentroid.x  );\n    nyanUv.x = (nyanUv.x - minMax.x) / (minMax.y-minMax.x);\n    // Min Max in V\n    minMax = vec2( nyanCentroid.y - height, nyanCentroid.y + height );\n    nyanUv.y = (nyanUv.y - minMax.x) / (minMax.y-minMax.x);\n\n    // Draw mask to keep thing clean and purdy\n    vec2 drawMaskUV = step( abs(nyanUv-.5), vec2(.5, .5) );\n    float drawMask = drawMaskUV.x*drawMaskUV.y;\n    vec4 rainbowTrail = texture(iChannel2, nyanUv);\n    \n    rainbowTrail.a *= drawMask;\n    //rainbowTrail.rgb = vec3(segment);\n    \n    return rainbowTrail;\n    \n}\n\n\n\n\n// -- -- -- -- -- -- -- -- --\n// -- -- -- -- -- -- -- -- --\n// -- -- -- -- -- -- -- -- --\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixelSize = 1.0/iResolution.xy;\n    vec2 uv = fragCoord.xy * pixelSize;\n\n    float time = iTime*18.0;\n    float modTime = mod(iTime,1.0);\n    float ftime = max(0.00001, fract(time*.007));\n\n    float mouseDown = step(0.01,iMouse.z);\n\n    // -- -- --\n    // Nyan Backdrop\n    vec3 nyanBg = texture(iChannel1, uv).xyz;\n\n    float resRatio = (pixelSize.y / pixelSize.x)*.5+.5;\n    vec2 nyanSize = vec2(1.0,resRatio)*NYAN_SIZE;\n    float trailDanceDist = pixelSize.y*RAINBOW_DANCE_OFFSET*(iResolution.x*0.001); \n\n    // Nyan Variables\n    vec2 nyanCentroid =  vec2( .5, .5 ); // Center of screen\n\n    // Blend centroid to mouse location on screen, if clicking\n    nyanCentroid = mix( nyanCentroid, iMouse.xy*pixelSize, mouseDown);\n    \n    // -- -- --\n    \n    // Warp DRIVE!\n    //   Click dat nyan cat, that!\n    \n    // Add the warp effects of ludacris speeds!\n    float warpDriveX = max(EPSILON, uv.x+(sin(uv.y*cos(uv.x)+uv.x+time*.225)*.1+.1));\n    float warpDriveY = max(EPSILON, uv.y-(sin(uv.x*cos(uv.x)+uv.y+time*.15)*.1));\n    float warpDist = max(0.0, .5-max(0.0, 1.0-length( nyanCentroid - uv )))+.5;\n    \n    // Make everything go warp speed\n    uv = mix( uv, vec2(warpDriveX, warpDriveY), mouseDown*warpDist );\n    \n    // Magic Number Warp!\n    //   Just messin around to add some fun to nyan cats size and tail movement\n    float magicWarp =  (sin(uv.y+uv.x+time*.1)*.025 - .015) * mouseDown;\n    \n    // Magic numbers to move nyan cat in Z ( size of nyan )\n    nyanSize += magicWarp;\n    \n    // Magic numbers to change nyan tail\n    float trailHeight = TRAIL_HEIGHT;\n    vec2 trailOffset = TRAIL_OFFSET;\n    trailHeight += magicWarp*.75;\n    trailOffset.x -= magicWarp;\n    \n    trailDanceDist = trailDanceDist * (1.0+magicWarp*10.0*mouseDown);\n    \n    // -- -- --\n    \n    // Build Nyan Cat\n    vec4 nyanCd = compNyanCat( uv, nyanCentroid, nyanSize );\n    \n    // Build Nyan Tail\n    vec4 rainbowTrailCd = drawNyanRainbowTrail( uv, nyanCentroid+trailOffset, trailHeight, trailDanceDist );\n    rainbowTrailCd = rainbowTrailCd * rainbowTrailCd.a;\n    \n    \n    // -- -- -- --\n    // Final out color\n    vec3 outCd = mix( nyanBg, rainbowTrailCd.xyz, max(0.0,rainbowTrailCd.a- nyanBg.r) );\n    outCd = mix( outCd, nyanCd.xyz, nyanCd.a );\n    \n    \n    // Star Burst Background Buffer\n    //outCd.rgb = texture(iChannel1, uv).xyz;\n    \n    // Rainbow Buffer\n    //outCd.rgb = texture(iChannel2, uv).xyz;\n\n\n    // Output to screen\n    fragColor = vec4(outCd,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//  Star Burst Generation\n//\n//  The star burst animations are in this buffer\n//\n//  Drive \"pixel\" animations based on the pixel information in iChannel0\n//\n//  Huh?\n//  If the pixel is bright enough in `iChannel0`, make that a `burst location`\n//    Have near by pixels find that same `burst location` pixel\n//  Their distance is used as their frame of animation in `starBurstAnim`\n//  If a pixel is two pixels away,\n//    It will light up when ever this variable tells it to-\n//     `starBurstAnim[ FRAME_NUMBER ].XYZW -> Y == 2 Pixels from Burst`\n//    The diagonal bursts frames are a special case though.\n\n\n\n// -- -- -- \n\n// Burst frame rate\n#define FPS 12.0\n\n// Burst scroll rate\n#define SCROLE_RATE .235\n\n// Size of bursts on screen, lower is larger; Default .45\n#define BURST_SCALE .45\n\n// Offset starting frame of bursts; higher is better; Default is 40.37\n#define BURST_NOISE_SCALE 40.37\n\n// Dat sky blue\n#define BG_COLOR vec3( 0.0470588235294118, 0.2588235294117647, 0.4666666666666667)\n\n// -- -- -- \n\n// Animation Frames\n//   Pixel Distance Lookup from Burst Spawn location,\n//     Correlates to entry in vec4 -\n//       `starBurstAnim[#].xyzw` -> [0.0,1.0,2.0,3.0] pixel distance from burst origin\n//   Where each vec4 component is the alpha multiplier for each pixel\n// (Working with what I got...)\n//\nfloat starBurstFrameCount = 5.0;\nfloat starBurstDiagnalFrame = 4.0;\nvec4 starBurstAnim[6] = vec4[6](\n        vec4( 1.0, .0, .0, .0 ),\n        vec4( .0, 1.0, .0, .0 ),\n        vec4( .0, 1.0, 1.0, .0 ),\n        vec4( 1.0, .0, 1.0, 1.0 ),\n        vec4( .0, .0, .0, 1.0 ), // Diagnials need to draw on this frame\n        vec4( .0, .0, .0, 1.0 )\n    );\n\n\n// -- -- -- \n\n\n\n// Check if UV is texture Burst Spawn location\nfloat getSpawnLocationValue( vec2 checkUv ){\n\n    vec3 outCd = texture(iChannel0, checkUv).xyz;\n    // This vec3 is used to check if the sampled color is a Burst Source\n    //   If the dot product value is above the last step value below, .9985\n    vec3 randomCdDotVec = normalize(vec3(1.0,.00,.20 ));\n    float starDot = 1.0 - max(0.0, dot( normalize(outCd), randomCdDotVec ));\n    \n    starDot = 1.0 - (1.0-starDot)*(1.0-starDot);\n    starDot *= step(.999, starDot);\n    \n    return starDot;\n}\n\n\n//  Run texture lookups to find near by Burst Spawn locations\nvoid checkBurstDistances( vec2 baseUv, vec2 txRes,\n                          inout vec2 burstSpawnUv,\n                          inout vec4 linearAnimFrames, inout float hasDiagnalAnim ){\n    vec2 curUv;\n    float curCheck;\n    vec4 outVal = vec4(0.0,0.0,0.0,0.0); // x - Linear Check Value | y - Diagnal Check Value\n    float outDiag = 0.0;\n    vec2 outSpawnUv = vec2(0.0,0.0);\n    \n    vec2 txCheckRes =  txRes ;\n    \n    // Its late, I'll optimize later\n    curUv = baseUv;\n    curCheck = getSpawnLocationValue( curUv );\n    outSpawnUv = mix( outSpawnUv, curUv, curCheck );\n    outVal.x = max(outVal.x, curCheck);\n    // -- \n    curUv = fract( baseUv + txCheckRes * vec2( 1.0, 0.0 ) );\n    curCheck = getSpawnLocationValue( curUv );\n    outSpawnUv = mix( outSpawnUv, curUv, curCheck );\n    outVal.y = max(outVal.y, curCheck );\n    curUv = fract( baseUv + txCheckRes * vec2( -1.0, 0.0 ) );\n    curCheck = getSpawnLocationValue( curUv );\n    outSpawnUv = mix( outSpawnUv, curUv, curCheck );\n    outVal.y = max(outVal.y, curCheck );\n    curUv = fract( baseUv + txCheckRes * vec2( 0.0, 1.0 ) );\n    curCheck = getSpawnLocationValue( curUv );\n    outSpawnUv = mix( outSpawnUv, curUv, curCheck );\n    outVal.y = max(outVal.y, curCheck );\n    curUv = fract( baseUv + txCheckRes * vec2( 0.0, -1.0 ) );\n    curCheck = getSpawnLocationValue( curUv );\n    outSpawnUv = mix( outSpawnUv, curUv, curCheck );\n    outVal.y = max(outVal.y, curCheck );\n    // -- \n    curUv = fract( baseUv + txCheckRes * vec2( 2.0, 0.0 ) );\n    curCheck = getSpawnLocationValue( curUv );\n    outSpawnUv = mix( outSpawnUv, curUv, curCheck );\n    outVal.z = max(outVal.z, curCheck );\n    curUv = fract( baseUv + txCheckRes * vec2( -2.0, 0.0 ) );\n    curCheck = getSpawnLocationValue( curUv );\n    outSpawnUv = mix( outSpawnUv, curUv, curCheck );\n    outVal.z = max(outVal.z, curCheck );\n    curUv = fract( baseUv + txCheckRes * vec2( 0.0, 2.0 ) );\n    curCheck = getSpawnLocationValue( curUv );\n    outSpawnUv = mix( outSpawnUv, curUv, curCheck );\n    outVal.z = max(outVal.z, curCheck );\n    curUv = fract( baseUv + txCheckRes * vec2( 0.0, -2.0 ) );\n    curCheck = getSpawnLocationValue( curUv );\n    outSpawnUv = mix( outSpawnUv, curUv, curCheck );\n    outVal.z = max(outVal.z, curCheck );\n    // -- \n    curUv = fract( baseUv + txCheckRes * vec2( 3.0, 0.0 ) );\n    curCheck = getSpawnLocationValue( curUv );\n    outSpawnUv = mix( outSpawnUv, curUv, curCheck );\n    outVal.w = max(outVal.w, curCheck );\n    curUv = fract( baseUv + txCheckRes * vec2( -3.0, 0.0 ) );\n    curCheck = getSpawnLocationValue( curUv );\n    outSpawnUv = mix( outSpawnUv, curUv, curCheck );\n    outVal.w = max(outVal.w, curCheck );\n    curUv = fract( baseUv + txCheckRes * vec2( 0.0, 3.0 ) );\n    curCheck = getSpawnLocationValue( curUv );\n    outSpawnUv = mix( outSpawnUv, curUv, curCheck );\n    outVal.w = max(outVal.w, curCheck );\n    curUv = fract( baseUv + txCheckRes * vec2( 0.0, -3.0 ) );\n    curCheck = getSpawnLocationValue( curUv );\n    outSpawnUv = mix( outSpawnUv, curUv, curCheck );\n    outVal.w = max(outVal.w, curCheck );\n    // -- \n    \n    \n    \n    // -- \n    // Diagnals\n    curUv = fract( baseUv + txCheckRes * vec2( 2.0, 2.0 ) );\n    curCheck = getSpawnLocationValue( curUv );\n    outSpawnUv = mix( outSpawnUv, curUv, curCheck );\n    outDiag = max(outDiag, curCheck );\n    curUv = fract( baseUv + txCheckRes * vec2( -2.0, 2.0 ) );\n    curCheck = getSpawnLocationValue( curUv );\n    outSpawnUv = mix( outSpawnUv, curUv, curCheck );\n    outDiag = max(outDiag, curCheck );\n    curUv = fract( baseUv + txCheckRes * vec2( -2.0, -2.0 ) );\n    curCheck = getSpawnLocationValue( curUv );\n    outSpawnUv = mix( outSpawnUv, curUv, curCheck );\n    outDiag = max(outDiag, curCheck );\n    curUv = fract( baseUv + txCheckRes * vec2( 2.0, -2.0 ) );\n    curCheck = getSpawnLocationValue( curUv );\n    outSpawnUv = mix( outSpawnUv, curUv, curCheck );\n    outDiag = max(outDiag, curCheck );\n    // -- \n\n    // -- \n \n    burstSpawnUv = outSpawnUv;\n    \n    linearAnimFrames = outVal;\n    hasDiagnalAnim = outDiag;\n \n \n}\n\n\n\n// -- -- -- -- -- -- -- -- -- -- --\n// -- -- -- -- -- -- -- -- -- -- --\n// -- -- -- -- -- -- -- -- -- -- --\n\n#define EPSILON 0.0001\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scrollTime = iTime*SCROLE_RATE;\n    float fpsTime = iTime*FPS;\n    \n    vec2 uvRatio = 1.0/iResolution.xy;\n    float pxlRatio = uvRatio.y/uvRatio.x;\n    vec2 baseUv = fragCoord * uvRatio;\n    vec2 curUv = baseUv*vec2(pxlRatio,1.0)*BURST_SCALE;\n    curUv.y -= .5;\n    \n    float mouseDown = step(0.01,iMouse.z);\n    \n    float time = iTime*5.1;\n    float warpDriveX = max(EPSILON, curUv.x*.3+time*.1+(sin(curUv.y*cos(curUv.x)*10.0+curUv.x+time*.5)*.1+.1));\n    float warpDriveY = max(EPSILON, curUv.y*0.10-(sin(curUv.x*cos(curUv.x)*3.0+curUv.y+time*.75)*.1+.1));\n\n    \n    // -- -- -- \n    \n    // Warp Drive Effects\n    \n    \n    float magicWarp =  (sin(curUv.y+curUv.x+iTime*1.8)*.5+.5) * mouseDown;\n    \n    vec2 mousePos = iMouse.xy*uvRatio;\n    float mouseOffset = curUv.x-(sin(curUv.y*cos(curUv.x)+curUv.x+iTime*18.0*.225+.8));\n    \n    float mouseOffsetY = (sin(curUv.x*cos(curUv.x)+curUv.y+iTime*18.0*.15)*.1);\n    mousePos.x+=mouseOffset*.05;\n    mousePos.y+=mouseOffsetY*.1;\n    mousePos = mix( vec2(.5), mousePos, mouseDown);\n    \n    vec3 bgCd = BG_COLOR;\n    vec2 mouseDelta = baseUv-mousePos;\n    mouseDelta.x-=.5;\n    float deltaLength = length(mouseDelta);\n    float edgeVal = max(0.0,dot(vec2(-1.0+abs(mouseDelta.y)*1.5,0.0),mouseDelta.xy)*max(0.0,-mouseDelta.x));\n    edgeVal *= 1.0 + magicWarp*0.20;\n    \n    vec3 bgCdEdge = BG_COLOR + BG_COLOR*edgeVal;\n    bgCd = mix( bgCd, bgCdEdge, mouseDown );\n    \n    curUv +=  (vec2(warpDriveX+edgeVal*2.0, warpDriveY)*mouseDown * (edgeVal*.002+.998))*.2;\n    \n    // -- -- --\n    \n    curUv.x = fract( curUv.x + scrollTime );\n    curUv.y += .5;\n    \n    vec3 outCd;\n    \n    \n    // -- -- --\n    \n    //  Check distance to Burst Spawn locations\n    \n    vec3 noiseRes = iChannelResolution[0];\n    vec2 noiseRatio = 1.0/noiseRes.xy;\n    \n    vec2 burstSpawnUv = vec2(0.0,0.0);\n    vec4 linearAnimFrames = vec4( 0.0, 0.0, 0.0, 0.0 );\n    float hasDiagnalAnim = 0.0;\n    \n    curUv.xy = floor(curUv.xy*noiseRes.x)*noiseRatio.x;\n    checkBurstDistances( curUv, noiseRatio, burstSpawnUv, linearAnimFrames, hasDiagnalAnim );\n    burstSpawnUv*=BURST_NOISE_SCALE;\n    \n    // -- -- --\n    \n    \n    //  Get current animation frame\n    \n    float burstOffsetU = burstSpawnUv.x * starBurstFrameCount*4.0;\n    float curFrameFloat = mod(floor(fpsTime + burstOffsetU ),starBurstFrameCount);\n    \n    int curFrame = int( curFrameFloat );\n    \n    vec4 animFrame = starBurstAnim[curFrame];\n    \n    float burstValue = length(linearAnimFrames * animFrame);\n    \n    // The diagonal pixels need to light up\n    float diagnalBurstFrameValue = (1.0-step(0.5, abs(starBurstDiagnalFrame - curFrameFloat)));\n    burstValue = max( burstValue, diagnalBurstFrameValue * hasDiagnalAnim );\n    \n    // Blend in the background\n    outCd = mix( bgCd, vec3(1.0,1.0,1.0), burstValue);\n    //outCd = vec3(edgeVal);\n    fragColor = vec4(outCd,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Nyan Cat's Rainbow Trail Base Texture\n// \n// Cycle the colors when you click\n\nfloat rainbowColorCount = 6.0;\nvec3 rainbowColors[6] = vec3[6](\n        vec3(1.00, 0.17, 0.05),\n        vec3(1.00, 0.66, 0.02),\n        vec3(1.00, 0.96, 0.0),\n        vec3(0.19, 0.92, .02),\n        vec3(0.01, 0.64, 1.00),\n        vec3(0.47, 0.34, 1.00)\n    );\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 baseUv = fragCoord / iResolution.xy;\n    \n    \n    vec4 outCd = vec4( 1.0, 1.0, 1.0, 1.0);\n    \n    float vFitted = (1.0-baseUv.y);\n    \n    int targetColorId = int( vFitted*rainbowColorCount);\n    vec3 targetColor = rainbowColors[ targetColorId ];\n    \n    \n    // -- -- --\n    \n    // Add in some WARP DRIVE!\n    \n    float targetColorIdf =  floor(-iTime*1.12*rainbowColorCount) + float(targetColorId);\n    int targetColorIdB =  int(mod(targetColorIdf-1.0, rainbowColorCount));\n    targetColorId =  int(mod(targetColorIdf, rainbowColorCount));\n    vec3 warpDriveCd = rainbowColors[ targetColorId ];\n    vec3 warpDriveCdB = rainbowColors[ targetColorIdB ];\n    float time = mod(iTime*0.5,3.14159265358979323); \n    baseUv = 1.0-baseUv;\n    float warpMix = clamp(sin(baseUv.y*20.5+cos(time*1.8+baseUv.y)*(15.0*baseUv.x+1.0)\n                        +time*(cos(-baseUv.y*10.5+baseUv.x*30.02*sin(baseUv.x+time*.21+10.0))*.002+1.99))\n                        *2.0+.5,0.0,1.0);\n    warpDriveCd = mix( warpDriveCd, warpDriveCdB, warpMix );\n    \n    targetColor = mix( targetColor, warpDriveCd, step(0.01,iMouse.z) );\n    \n    // -- -- --\n    \n    \n    outCd.rgb = targetColor;\n    \n    \n    fragColor = outCd;\n}","name":"Buffer B","description":"","type":"buffer"}]}