{"ver":"0.1","info":{"id":"slByW3","date":"1657835541","viewed":149,"name":"Winter Timelapse","username":"Langwedocjusz","description":"Currently changing resolution requires restarting timer to get erosion to work. With lower resolutions (sub 1200x675) erosion starts looking visibly worse. There may be ways to mitigate this, but I haven't tried yet.","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","terrain","procedual"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Buffer A: Base heightmap + erosion\n//Buffer B: The rest\n\n//Possible TO-DO list:\n//Fix resolution related issues\n//Trees?\n//Aurora borealis!\n//More physical sky?\n//Nicer clouds (maybe Perlin-Worley atlas)?\n//Post-processing?\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = texture(iChannel0, uv).rgb;    \n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.1415926535\n#define SQRT2 1.4142135624\n\n#define rgb(x,y,z) vec3(x,y,z)/255.0\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n\nfloat lerp(float a, float b, float t) {\n    t = saturate(t);\n    return (1.0-t)*a + t*b;\n}\n\nvec3 lerp(vec3 a, vec3 b, float t) {\n    t = saturate(t);\n    return (1.0-t)*a + t*b;\n}\n\nfloat sgn(float x) {return float(x>0.0) - float(x<0.0);}\n\n#define MOD3 vec3(443.8975,397.2973, 491.1871)\nfloat hash12_nosine(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash12(vec2 p) {\n\treturn 2.0*fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)-1.0;   \n}\n\nfloat noise(vec2 p) {\n    vec2 id = floor(p);\n    vec2 u = fract(p);\n    \n    float a = hash12(id + vec2(0,0));\n    float b = hash12(id + vec2(1,0));\n    float c = hash12(id + vec2(0,1));\n    float d = hash12(id + vec2(1,1));\n    \n    u = u*u*u*(u*(6.0*u-15.0)+10.0);\n    \n    float k0 = a;\n    float k1 = b-a;\n    float k2 = c-a;\n    float k3 = a-b-c+d;\n    \n    return 0.5 + 0.5*(k0 + k1*u.x + k2*u.y + k3*u.x*u.y);     \n}\n\n//https://iquilezles.org/articles/fbm/\nfloat fbm(vec2 p, int octaves) {\n    const float scale_y = 1.0;\n    const float scale_xz = 0.25;\n    const mat2 rot = mat2(0.8, 0.6, -0.6, 0.8);\n    \n    p *= scale_xz;\n\n    float res = 0.0;\n    mat2 M = mat2(1.0);\n    \n    float A = 1.0, a = 1.0;\n    \n    for (int i=1; i<=octaves; i++) {\n        res += A*noise(a*M*p);\n        \n        a *= 2.0;\n        A *= 0.5;\n        M *= rot;\n    }\n    \n    return scale_y*res;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//====LANDSCAPE====================================\n//r - lod0 height, g - lod0 water level, b - lod1 height, a - lod1 water level\n\nfloat heightmap(vec2 uv) {\n    const float base_scale = 10.0;\n    const int octaves = 16;\n    \n    float dist2 = dot(uv,uv);\n    \n    //base noise\n    float height = fbm(base_scale*uv, octaves);\n    \n    //room for the lake\n    height = lerp(0.0, height, 0.9*dist2);\n    \n    //lake itself\n    height = lerp(-0.1, height, 4.0*dist2);\n    \n    return height;\n}\n\nvec2 lod_heightmap(vec2 uv) {\n    vec2 res = vec2(0.0);\n    \n    //Store lods in different channels. 0.5 would be the \"correct\" scale for lod1,\n    //but distant erosion looks nicer with 0.25\n    res.x = heightmap(1.0*uv);\n    res.y = 0.25 * heightmap(2.0*uv);\n    \n    return res;\n}\n\n//====EROSION====================================================================\n//Based on \"poor hydraulic erosion\" by stb: https://www.shadertoy.com/view/XsKGWG\n//It's run for two lod levels at the same time, with different parameters\n\n#define EROSION_STEPS 25\n\n#define EROSION_FAC_0 0.003\n#define WATER_IN_0 0.111\n#define WATER_OUT_0 0.083\n#define SMOOTH_FAC_0 0.001\n#define COLAPSE_FAC_0 0.111\n#define RAIN_FAC_0 4. / 65535.\n\n#define EROSION_FAC_1 0.0015\n#define WATER_IN_1 0.015\n#define WATER_OUT_1 0.010\n#define SMOOTH_FAC_1 0.001\n#define COLAPSE_FAC_1 0.02\n#define RAIN_FAC_1 1. / 65535.\n\n#define t2D(x, y) texture(iChannel0, fract(uv-vec2(x, y)/res))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 res = iResolution.xy;\n    vec2 uv = fragCoord / iResolution.xy;\n\n    //fetch previous resolution\n    vec3 prev_res = texelFetch(iChannel0, ivec2(0), 0).gba;\n\n    vec4 buf[9];\n    buf[0] = t2D(0.,  0.);\n    buf[1] = t2D(1.,  0.);\n    buf[2] = t2D(-1., 0.);\n    buf[3] = t2D(0.,  1.);\n    buf[4] = t2D(0., -1.);\n    buf[5] = t2D(1.,  1.);\n    buf[6] = t2D(-1., 1.);\n    buf[7] = t2D(1., -1.);\n    buf[8] = t2D(-1.,-1.);\n\n    vec2 lhc = buf[0].rg;  // land height (this cell)\n    vec2 wvc = buf[0].ba;  // water volume (this cell)\n    vec2 whc = wvc + lhc;  // water height (this cell)\n\n    // land height & water volume (outputs)\n    vec2 lh, wv;\n\n    //Generate base heightmap once per resolution change\n    if (iFrame<1 || prev_res != iResolution) {    \n        lh = lod_heightmap(uv);\n        wv = vec2(0.0);\n        \n        fragColor = vec4(lh, wv);\n        \n        if (ivec2(fragCoord) == ivec2(0)) fragColor.gba = iResolution;\n    }\n    \n    //Simulate erosion\n    else {\n        lh = buf[0].rg;\n        wv = buf[0].ba;\n        \n        if (iFrame < EROSION_STEPS) {\n            for(int i=1; i<9; i++) {\n                vec2 lhi = buf[i].rg;  // land height (neighboring cell)\n                vec2 wvi = buf[i].ba;  // water volume (neighboring cell)\n                vec2 whi = wvi + lhi; // water height (neighboring cell)\n                vec2 wslope = whi - whc; // water slope\n                vec2 lslope = lhi - lhc; // land slope\n            \n                // normalize corner weights for slopes\n                if(i>4) {\n                    wslope /= SQRT2;\n                    lslope /= SQRT2;\n                }\n            \n                //====SIMULATION FOR LOD 0================================================\n                if(wvc.x > 0.0 && wslope.x < 0.0) {\n                \n                    // give water\n                    wv.x += WATER_IN_0 * wslope.x;\n                \n                    // basic erosion\n                    lh.x += EROSION_FAC_0 * wslope.x;\n                }\n                \n                if(wvi.x >0.0 && wslope.x >0.0) {\n                \n                    // take water (currently less than it should, to help keep water from sticking to slopes)\n                    wv.x += WATER_OUT_0 * wslope.x;\n                \n                    // basic erosion\n                    lh.x -= EROSION_FAC_0 * wslope.x;\n                }\n                \n                // give & take land base on water slope (help smooth things out)\n                lh.x += SMOOTH_FAC_0 * wslope.x;\n                \n                // collapse steep land slopes (loss only)(helps widen gullies)\n                float threshold0 = 0.002;\n                \n                if(lslope.x < -threshold0 -.004*hash12_nosine(uv))\n                    lh.x += COLAPSE_FAC_0 * lslope.x;\n                \n                //====THE SAME THING FOR LOD 1======================================================\n                if(wvc.y > 0.0 && wslope.y < 0.0) {\n                \n                    wv.y += WATER_IN_1 * wslope.y;\n\n                    lh.y += EROSION_FAC_1 * wslope.y;\n                }\n            \n                if(wvi.y >0.0 && wslope.y >0.0) {\n                    wv.y += WATER_OUT_1 * wslope.y;\n                \n                    lh.y -= EROSION_FAC_1 * wslope.y;\n                }\n            \n                lh.y += SMOOTH_FAC_1 * wslope.y;\n               \n                float threshold1 = 0.002;\n               \n                if(lslope.y < -threshold1-.004*hash12_nosine(uv))\n                    lh.y += COLAPSE_FAC_1 * lslope.y;\n            }\n        \n            //===='rain'==========================================================\n            if(hash12_nosine(mod(uv+iTime/100., 100.))>.5) {\n                wv.x += RAIN_FAC_0;\n                wv.y += RAIN_FAC_1;\n            }\n            \n            // evaporation\n            wv *= 0.98;\n            \n            //Kill erosion near the border, since hacking >> actually considering boundary conditions\n            const float edge_size = 0.02;\n            #define SMOOTH_EDGE(x) smoothstep(1.0-edge_size, 1.0, x)\n            float edge = max( max(SMOOTH_EDGE(      uv.x), SMOOTH_EDGE(      uv.y)),\n                              max(SMOOTH_EDGE(1.0 - uv.x), SMOOTH_EDGE(1.0 - uv.y)) );\n            \n            lh.x += edge * (lhc.x - lh.x); \n        }\n        \n        fragColor = vec4(lh, wv);\n        \n        if (ivec2(fragCoord) == ivec2(0)) fragColor.gba = prev_res;\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define MAX_HEIGHT 0.6\n#define MAX_DIST 10.0\n\nconst float clouds_bottom = 0.18, clouds_top = 0.23;\n\nbool intersectXZPlane(vec3 org, vec3 dir, inout float dist, float height, float orientation) {\n    const float epsilon = 0.000001;\n    \n    vec3 normal = sgn(orientation) * vec3(0.0, 1.0, 0.0);\n\n    float denom = dot(-normal, dir);\n    \n    if (denom > epsilon) { \n        dist = dot(vec3(0.0, height, 0.0) - org, -normal) / denom; \n        return (dist >= 0.0); \n    } \n    \n    else {\n        dist = MAX_DIST;\n        return false; \n    }\n    \n}\n\nvec3 get_sun() {\n    vec3 dir = vec3(1.0, 0.0, 0.0);\n    float th = 0.5*iTime, s = sin(th), c = cos(th);\n    dir.xy *= mat2(c, s, -s, c);\n    return dir;\n}\n\n//====Volumetric Clouds============================================================\n\n//From method 1 in https://www.shadertoy.com/view/XslGRr\nfloat noise_3d(vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n    \n    vec2 uv = (p.xy+vec2(37.0,239.0)*p.z) + f.xy;\n    vec2 rg = textureLod(iChannel1,(uv+0.5)/256.0,0.0).yx;\n\treturn mix( rg.x, rg.y, f.z )*2.0-1.0;\n}\n\n//https://iquilezles.org/articles/fbm\nfloat fbm_3d(in vec3 x, int octaves) {\n    const float H = 1.0;\n    \n    float G = exp2(-H);\n    \n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    \n    vec3 flow = 0.05*iTime*vec3(1.0, 0.0, -1.66);\n    \n    for(int i=0; i<octaves; i++) {\n        t += (i>0) ? a*noise_3d(f *(x-flow))\n                   : a*noise_3d(f * x);\n        f *= 2.0;\n        a *= G;\n    }\n    \n    return t;\n}\n\nfloat DensityMap(vec3 point, int octaves) {    \n    vec3 offset = 0.025*iTime*vec3(1.0, 0.0, -1.66);\n    return 0.4*fbm_3d(10.0*(point-offset), octaves) + 0.05;\n}\n\nfloat NormalizedDensity(vec3 point, int octaves) {   \n    float d = DensityMap(point, octaves);\n    bool inside = d < 0.0;\n    return inside ? min(-d, 1.0) : 0.0;\n}\n\nvec3 VolumetricMarch(vec3 org, vec3 dir, float opaque_depth, inout float visibility) {\n    const int volume_march_steps = 20;\n    const int volume_shadow_steps = 10;\n    const float march_max_dist = 4.0;\n    const int octaves = 8;\n\n    const float albedo = 0.95, absorbance = 25.0;\n    const vec3 ambient = vec3(0.3);\n    \n    vec3 color = vec3(0.0);\n    visibility = 1.0;\n    \n    float volume_depth;\n    intersectXZPlane(org, dir, volume_depth, clouds_bottom, -1.0);\n    \n    if (volume_depth >= march_max_dist) return color;\n    \n    volume_depth -= 0.02;\n    \n    float max_depth;\n    intersectXZPlane(org, dir, max_depth, clouds_top, -1.0);\n    \n    float step_size = (max_depth - volume_depth)/float(volume_march_steps);\n    \n    for(int i = 0; i < volume_march_steps; i++) {\n        volume_depth += step_size;\n        \n        if(volume_depth > opaque_depth) break;\n\t\n        vec3 pos = org + volume_depth*dir;\n        bool inVolume = DensityMap(pos, octaves) < 0.0f;\n        \n        if(inVolume) {\n            float prev_visiblity = visibility;\n            visibility *= exp(-absorbance*NormalizedDensity(pos, octaves)*step_size);\n            \n            float absorption = prev_visiblity - visibility;\n            \n            //Lighting:\n            vec3 light_dir = get_sun();\n            vec3 light_col = vec3(saturate(dot(light_dir, vec3(0.0, 1.0, 0.0))));\n                \n            float light_vis = 1.0;\n            float ldist = 0.0, light_dist;\n            intersectXZPlane(org, dir, light_dist, clouds_top, -1.0);\n            \n            float lstep_size = light_dist/float(volume_shadow_steps);\n            \n            //Self shadowing:\n            for (int k=0; k<volume_shadow_steps; k++) {\n                ldist += lstep_size;\n                if (ldist > march_max_dist) break;\n                \n                vec3 lpos = pos + ldist * light_dir;\n                if (DensityMap(lpos, octaves) < 0.0 )\n                    light_vis *= exp(-absorbance*NormalizedDensity(lpos, octaves)*step_size);\n            }\n                \n            color += absorption * albedo * light_vis * light_col;\n            color += absorption * albedo * ambient;\n        }\n    }\n    \n    return color;\n}\n\n//====Reading heightmap from Buffer A and raymarching it===============\n\nfloat terrain(vec2 uv) {\n    const float xz_scale = 1.33;\n    const float y_scale = 0.2;\n    \n    uv = xz_scale * uv;\n    \n    int lod_lvl = int(max(uv.x, uv.y)); //Currently we only have [0,1]\n    \n    if (uv.x < 0.0 || uv.y < 0.0 || lod_lvl > 1)\n        return 0.0;\n        \n    else {\n        vec2 selector = vec2(lod_lvl == 0, lod_lvl == 1);\n        \n        vec2 xz_scales = vec2(1.0, 0.5);\n        vec2 y_scales = vec2(1.0, 4.0);\n        \n        vec2 tex = dot(selector, y_scales) * texture(iChannel0, dot(selector, xz_scales) * uv).rg;\n        \n        return y_scale * dot(tex, selector);\n    }\n    \n}\n\n//Raymarching terrain with step size proportional to height,\n//as seen in \"Elevated\": https://www.shadertoy.com/view/MdX3Rr\nfloat terrain_dist(vec3 org, vec3 dir) {\n    const int max_steps = 256;\n    const float exit_bias = 0.0015;\n    const float step_mult = 0.4;\n    \n    float t = 0.01;\n\n    for (int i=0; i<max_steps; i++) {\n        vec3 p = org + t*dir;\n        \n        if (p.y > MAX_HEIGHT)\n            return MAX_DIST;\n        \n        float h = p.y - terrain(p.xz);\n        \n        if (abs(h) < exit_bias*t || t > MAX_DIST)\n            return t;\n        \n        t += step_mult * h;\n    }\n    \n    return MAX_DIST;\n}\n\nvec3 terrain_norm(vec3 pos, float t) {\n    const float eps = 0.001;\n    vec2 h = vec2(eps*t, 0.0);\n    \n    return normalize( vec3( \n        terrain(pos.xz-h.xy) - terrain(pos.xz+h.xy),\n        2.0*h.x,\n        terrain(pos.xz-h.yx) - terrain(pos.xz+h.yx)\n    ) );\n}\n\nvec3 terrain_albedo(vec3 point, vec3 norm) {\n    float cutoff = 0.75 - 0.75*point.y;\n    float slope = smoothstep(cutoff, cutoff+0.1, (dot(norm, vec3(0.0, 1.0, 0.0))) );\n    return vec3(0.3 + 0.6 * slope);\n}\n\n//Soft shadows technique: https://iquilezles.org/articles/rmshadows\nfloat terrain_shadow(vec3 org, vec3 dir, float dist) {\n    const int shadow_steps = 80;\n    \n    float min_step = clamp(0.01*dist, 0.005, 0.5);\n    \n    float res = 1.0;\n    float t = 0.001;\n    \n    for (int i=0; i<shadow_steps; i++) {\n        vec3 p = org + t*dir;\n        float h = p.y - terrain(p.xz);\n        \n        res = min(res, 16.0 * h/t);\n        t += max(min_step, h);\n        \n        if (res<0.001 || p.y > 2.0) break;\n    }\n    \n    //Cloud shadows\n    vec3 sun_dir = get_sun();\n    float t_in, t_out;\n    \n    intersectXZPlane(org, sun_dir, t_in, clouds_bottom, -1.0);\n    intersectXZPlane(org, sun_dir, t_out, clouds_top, -1.0);\n    \n    vec3 sample_point = org + 0.5*(t_in + t_out)*sun_dir;\n    float density = NormalizedDensity(sample_point, 2);\n    \n    res -= 0.5*density;\n    \n    return saturate(res);\n}\n\nvec3 draw_terrain(vec3 point, vec3 dir, float dist) {\n    vec3 l_dir = get_sun();\n    \n    vec3 norm = terrain_norm(point, dist);\n        \n    float dif = 0.9*saturate(dot(l_dir, norm)); \n    \n    vec3 R = reflect(l_dir, norm);\n    float spec = 0.4 * pow(saturate(dot(dir, R)), 5.0);\n    \n    float amb = 0.1;\n    \n    float shadow = terrain_shadow(point, l_dir, dist);\n    \n    return (shadow*(dif + spec) + amb) * terrain_albedo(point, norm);\n}\n\n//=================================================================================\n\n//Beer-lambert fog, assuming density changes with altitude as a square:\nfloat linear_fog(vec3 org, vec3 dir, float terrain_dist) {\n    const float rho_0 = 5.0, a = 100.0;\n    \n    float t_0 = (sqrt(rho_0/a) - org.y)/(dir.y);\n    float T = min(terrain_dist, abs(t_0));\n    \n    return 8.0*exp(-(rho_0 - a*org.y*org.y)*T + a*org.y*dir.y*T*T + 0.33*a*dir.y*dir.y*T*T*T);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //Camera setup\n    vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n    \n    const float cam_fov_deg = 45.0;\n    const float cam_dist = 1.0/tan(cam_fov_deg * 0.5 * PI / 180.0);\n    \n    vec3 org = vec3(0.0, 0.01*3.04, 0.0);\n    vec3 dir = normalize(vec3(uv, cam_dist));\n    \n    float th = 0.031, s = sin(th), c = cos(th);\n    dir.yz *= mat2(c, s, -s, c);\n    dir.xz *= mat2(1.0, 1.0, -1.0, 1.0)/SQRT2;\n    \n    vec3 col = vec3(0.0);\n    \n    //Initial raymarch\n    float dist = terrain_dist(org, dir);\n    \n    //Detect lake\n    float lake_dist;\n    bool lake = intersectXZPlane(org, dir, lake_dist, 0.0, 1.0) && (lake_dist < dist);\n    \n    //Possibly raymarch again, after reflection\n    if (lake) {\n        org = org + lake_dist*dir;\n        dir.y *= -1.0;\n        dist = terrain_dist(org, dir);\n    }\n    \n    vec3 sun_dir = get_sun();\n    float sky = 0.5 * saturate(dot(sun_dir, vec3(0.0, 1.0, 0.0)));\n    \n    //Draw landscape\n    if (dist < MAX_DIST) {\n        vec3 point = org + dist*dir;\n            \n        col = draw_terrain(point, dir, dist);\n        \n        if (lake) col *= 0.85;\n        \n        //Fog\n        col = lerp(vec3(1.33*sky+0.1), col, linear_fog(org, dir, dist));\n    }\n    \n    //Draw sky\n    else {\n        float theta = acos(dir.z) + + 0.5*iTime, phi = atan(dir.y/dir.z);\n        vec2 ts = vec2(phi, theta);\n        float cutoff = 1.5;\n        float stars = 0.5 * smoothstep(cutoff, cutoff+0.1, fbm(1000.0*ts, 4));\n        \n        col = vec3(max(sky, stars));\n    }\n    \n    //Draw Clouds\n    float vis = 1.0;\n    vec3 volume_col = VolumetricMarch(org, dir, dist, vis);\n    col = min(volume_col, 1.0f) + vis * col;\n    \n    fragColor = vec4(col,1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}