{"ver":"0.1","info":{"id":"ld3fRH","date":"1524032322","viewed":272,"name":"Mandelbrot set Streamline","username":"rory618","description":"Patterns should start to emerge after about 10 seconds","likes":14,"published":1,"flags":48,"usePreview":0,"tags":["mandelbrot","greyscale","stochastic","streamline","routing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 o, in vec2 i )\n{\n    vec2 uv = i/R.xy;\n    o = exp(-vec4(length(texture(iChannel0, uv).xy*R.xy-i)/30.));\n    o =pow(texture(iChannel0,uv),vec4(.6))/3./(pow(textureLod(iChannel1,vec2(uv),8.),vec4(.6)));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R iResolution\n#define F iFrame\n#define PI 2.*asin(1.)\n#define E exp(1.)\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\nfloat s = 15.;\t//search radius\nfloat v = 4.;   //increase for fewer particles drawn better. Decrease all the way to 1 for iResolution.x*iResolution.y total number of particles\nint i1 = 50;    //number of iterations for fisrt and second drawing/search stages\nint i2 = 50;\t//more runs slower, but the particles are more visible\n\n\n//some complex functions\nvec2 cis(float t){\n    return cos(t - vec2(0,PI/2.));\n}\nvec2 cexp(vec2 z) {\n    return exp(z.x)*cis(z.y);\n}\nvec2 clog(vec2 z) {\n    return vec2(log(length(z)),atan(z.y,z.x));\n}\n/*\nSummary:\nCalculate many thousand paths along a vector field based on the mandelbrot set, as they move through the vector field\ntheir location is drawn as points and accumulated to slowly produce an image of all the paths.\n*/\n\n\n\n/*\nRendering particles:\nThe overall idea of the algorithm is that particles are simulated at a random constant x,y location, and in order to\nbe drawn they have to 'move' to the pixels they are affecting. Doing this in one pass is really slow because you\nwould have to test every particle to see if it affects the pixel being drawn. Instead the process can be split into \ntwo parts. One literally brings a particle ~90% of the way to its location. Then the next layer need only look in nearby\nlocations to draw every particle that might be visible in that pixel. Everything is done randomly so that with the right\nparameters there will be a very high probability that the resulting image will have all the particles drawn.\n*/","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Store all the particles here\nvoid mainImage( out vec4 o, in vec2 i )\n{\n    vec2 uv = i/R.xy;\n    vec4 r = hash44(vec4(floor(i/v),F,0));//Make a random seed based on the location and frame.\n    \t\t\t\t\t\t\t\t\t//Some particles are redundant (from dividing by v) so that they will have a better probability of being drawn\n    o = texture(iChannel0,uv);\n    //store particle xy, optional zw for color or velocity\n    if(iFrame<3){//randomly init particle position\n        o.xy = r.xy;\n    }//mandelbrot space transform\n    vec2 c = (o.xy-vec2(.65,.5))*R.xy/2e2;\n    vec2 z = clog(c);//z is really log(z), so z_0 is undefined and z_1=log(c)\n    float j = 0.0;\n    for(j = 0.0;  j < 7.; j++) \n        z = 2.*z + clog(vec2(1,0)+cexp(clog(c)-2.*z));//Iterate log form mandelbrot \n        //twist, normalize, and return to z from log(z)\n    z = cexp(vec2(1.,z.y+1.3));\n    \n    //March the stremline ahead or backwards, based on a new random seed that is constant over time\n    o.xy += z*.00001*sign(hash44(vec4(floor(i/v),0,0)).x-.5);\n    \n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//This is the first pass of the rendering/search\n\nvoid mainImage( out vec4 o, in vec2 i )\n{\n    o = vec4(0);\n    for(int a = 0; a < i1; a++){\n        vec4 r = hash44(vec4(i,F,a));//randomly read points from buffer A\n        vec4 p = texture(iChannel0,r.xy);\n        float l = length(p.xy*R.xy-i);\n        if(l < length(o.xy*R.xy-i)){//save only the closest to this pixel\n            o = p;\n        }\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 o, in vec2 i )\n{\n    vec2 uv = i/R.xy;\n    o = texture(iChannel1,uv);\n    for(int a = 0; a < i1; a++){\n        vec4 r = hash44(vec4(i,F,a));//Transform this uniform random into a normal distribution\n        r.z = sqrt(-2.*log(r.z));\n        r.w *= 6.28318;\n        r.zw = r.z*vec2(cos(r.w),sin(r.w))*s;\n        vec4 p = texture(iChannel0,(i+r.xy)/R.xy);//sample random nearby points\n        o += 1./(1.+exp(4.*length(p.xy*R.xy-i))); //add a gaussian to the accumulated image from the particle \n    }\n    if ( texture( iChannel2, vec2(82.5/256.0,0.25) ).x > .5) {\n        o *= 0.;\n    }\n}","name":"Buffer C","description":"","type":"buffer"}]}