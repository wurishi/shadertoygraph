{"ver":"0.1","info":{"id":"NtcyW4","date":"1659762935","viewed":181,"name":"Reflection Study","username":"otaviolobato","description":"I'm studying phong reflection and cubemaps.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["reflection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define TAU 6.283185\n#define PI 3.141592\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n   \n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n\n    \n    vec2 u = f*f*(3.0-2.0*f);\n    \n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n\n\n\nvec4 sdBox(vec3 p, vec3 b, vec3 col){\n  vec3 q = abs(p) - b;\n  float d = length(max(q, .0)) + min(max(q.x, max(q.y, q.z)), 0.);\n  return vec4(d, col);\n}\n\nfloat sdBox(vec2 p, vec2 b){\n  vec2 q = abs(p) - b;\n  float d =  length(max(q, .0)) + min(max(q.x,q.y), 0.);\n  return d;\n}\n\nvec4 sdSphere(vec3 p , float r, vec3 col){\n  float d = length(p) - r;\n  return vec4(d, col);\n}\n\nvec4 opRepLim(vec3 p, float c, vec3 l){\n  vec3 q = p-c*clamp(floor((p/c)+.5), -l, l);\n  return sdSphere(q, .55, vec3(1., 1., 1.));\n}\n\nvec4 smoothIntersection(vec4 d1,vec4 d2, float k) {\n  vec4 h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n  return mix( d2, d1, h.x ) - k*h.x*(1.0-h.x);\n}\n\n\nvec4 noised(vec3 p, vec3 col){\n  p*=noise(p.xy)*10.;\n  float d = dot(sin(p), cos(p.zxy))/150. ;\n  return vec4(d, col);\n}\n\n\n\nvec4 sdScene(vec3 p){\n  vec4 box = sdBox(p, vec3(3.3), vec3(2.5, 2.5, 0.));\n  float box2d = length(vec2(sdBox(p.xy, vec2(5., 0.)), p.z));\n  float box2d2 = length(vec2(sdBox(p.xy, vec2(0., 5.)), p.z));\n   float box2d3 = length(vec2(sdBox(p.xy, vec2(5., 5.)), p.z));\n  \n  vec4 nsed = noised(p, vec3(1., 1., 1.))-0.000005;\n  \n  vec4 spheres = opRepLim(p,.3, vec3(1.)+3.8);\n  vec4 un = smoothIntersection(box, spheres, 3.);\n  \n vec4 d = max(un, box);\n \n  d = max(un-.1, nsed);\nd = min(d, box2d-0.5);\nd = min(d, box2d2-0.5);\nd = min(d, box2d3-0.5);\nd = max(d, nsed);\n\n  \n    \n  \n\n  \n  return d;\n}\n\n\n\n \nvec4 rayMarch(vec3 ro, vec3 rd) {\n  float depth = 0.;\n     vec4 d;\n    for(int i = 0; i < 255; i++){\n      vec3 p = ro + rd * depth;\n       d = sdScene(p);\n      depth += d.x;\n      if(d.x < 0.001 || depth > 100.) break;\n    }\n  vec3 col = vec3(d.yzw);\n  return vec4(depth, col);\n  \n  \n}\n\nvec3 calcNormal(vec3 p){\n  vec2 e = vec2(1., -1.)*0.00005;\n  return normalize(\n  e.xyy * sdScene(p + e.xyy).x + \n  e.yyx * sdScene(p + e.yyx).x +\n  e.yxy * sdScene(p + e.yxy).x +\n  e.xxx * sdScene(p + e.xxx).x\n  \n  );\n}\n\n\n\nmat3 camera(vec3 cameraPos, vec3 laP) {\n\tvec3 cd = normalize(laP - cameraPos); \n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd)); \n\tvec3 cu = normalize(cross(cd, cr)); \n\treturn mat3(-cr, cu, -cd);\n}\n\n\nvec3 phongReflection(vec3 lightDir, float lightIntensity, vec3 rd, vec3 normal) {\n  vec3 cubemapReflectionColor = texture(iChannel1, reflect(rd, normal)).rgb;\n\n  vec3 K_a = 1.5 * vec3(1.) * cubemapReflectionColor; \n  vec3 K_d = vec3(1);\n  vec3 K_s = vec3(1);\n  float alpha = 50.;\n\n  float diffuse = clamp(dot(lightDir, normal), 0., 1.);\n  float specular = pow(clamp(dot(reflect(lightDir, normal), -rd), 0., 1.), alpha);\n\n  return lightIntensity * (K_a + K_d * diffuse + K_s * specular);\n}\nmat2 rot2D(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy)/iResolution.y;\n\n  vec3 col = vec3(0.);\n  vec2 myMouse = iMouse.xy/iResolution.xy;\n  if (myMouse == vec2(0.0)) myMouse = vec2(0.5); \n  \n  vec3 lp = vec3(0);\n  vec3 ro = vec3(0, 0, 15);\n  ro.yz *= rot2D(mix(-PI/2., PI/2., myMouse.y));\n  ro.xz *= rot2D(mix(-PI, PI, myMouse.x));\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1));\n  vec4 d = rayMarch(ro, rd);\n  vec3 p = ro + rd * d.x;\n  \n  if(d.x > 100.) {\n  \n\n  \n  \n    col = texture(iChannel1, rd).rgb;\n  } else {\n    vec3 lightPosition = vec3(1., 5., 6.);\n    vec3 lightDirection = normalize(lightPosition - p);\n    vec3 normal = calcNormal(p);\n    float dif = clamp(dot(normal, lightDirection), 0.3, 1.);\n    \n    col = vec3(dif)*d.yzw*phongReflection(lightDirection, 1.,normal, rd);\n  } \n    \n  \n  fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}