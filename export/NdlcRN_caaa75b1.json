{"ver":"0.1","info":{"id":"NdlcRN","date":"1641805411","viewed":112,"name":"Fourier Series_","username":"Envy24","description":"Source: https://www.youtube.com/watch?v=9nAsn2iQLDU","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["fourier","series"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                       iResolution\n#define AR                     ( R.x / R.y )                      // Aspect ratio (AR > 1.0).\n#define CENTER_NDC(SC)         ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n\n#define TAU                     6.2831853071795862\n#define PI                      3.1415926535897932\n#define FAR                     9e30\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = CENTER_NDC(SC) * 4.0;\n  \n    float minDist = FAR;\n    float pointsPerFrame = 500.;\n    float tStep = PI / pointsPerFrame;\n    vec2 P = vec2(0.0);\n    \n    /* Static points */\n    for (float p = 0.; p <= pointsPerFrame; p+= 1.)\n    {\n        vec2 _P = calculateFourierSeries(p * tStep);\n        \n        float dist = distance(_P, NDC);\n        minDist = min(minDist, dist);\n        \n        P = \n            minDist == dist ?\n                _P :\n                P;\n    }\n    /* Static points */\n    \n    /* Moving points */\n    for (float m = 0.; m <= 12.; m += 1.0)\n    {\n        vec2 _P = calculateFourierSeries2(mod(iTime*0.1, PI), m);\n        float dist = distance(_P, NDC);\n        minDist = min(minDist, dist);\n\n        P = \n            minDist == dist ?\n                _P :\n                P;    \n    }\n    /* Moving points */\n    \n    float r = 0.03;\n    float AA = 0.04;\n    \n    \n    float gray = circleSDSDF(NDC, P, r, AA);\n    //float sd = distance(NDC, P);\n    //float gray = (sd - 0.15 + (1.0 + sin(iTime)) * 0.05)/fwidth(sd);\n    //float gray = abs(sd - 0.15 + (1.0 + sin(iTime)) * 0.05)/fwidth(sd);\n    //float gray = abs(fract(sd) - 0.15 + (1.0 + sin(iTime)) * 0.05)/fwidth(sd);\n\n    O = vec4(gray);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float circleSDSDF(\n    in vec2 S,           // sample coordinates\n    in vec2 C,           // circle center\n    in float r,          // circle radius\n    in float smoothness) // AA parameter\n{\n    // Sample coordinates relative to circle center.\n    float _x = S.x - C.x; float _y = S.y - C.y;\n    \n    // Signed distance of squares.\n    float sds = _x * _x + _y *_y - r * r;\n    \n    float ss = smoothness * smoothness;\n    \n    // Smoothstep interpolation.\n    return smoothstep(-ss, ss, sds);\n    //return smoothstep(-ss, ss, sds * sds); // outline\n}\n\nvec2 calculateFourierSeries(in float t)\n{\n    // This coefficients defines Fourier Series.\n    const float a[12] = float[]( 2.,2.,-4.,10.,20.,10.,12.,6.,2.,30.,10.,10. );\n    const float count = 12.;\n    \n    vec2 result = vec2(0.0);\n\n    for (float c = 0.; c < count; c+=1.)  \n    {\n        result.x += sin(a[int(c)]*t) / (c + 1.);\n        result.y += cos(a[int(c)]*t) / (c + 1.);\n    }\n\n    return result;\n}\n\nvec2 calculateFourierSeries2(in float t, in float count)\n{\n    // This coefficients defines Fourier Series.\n    const float a[12] = float[]( 2.,2.,-4.,10.,20.,10.,12.,6.,2.,30.,10.,10. );\n    float _count = clamp(1.0, 12.0, count);\n    \n    vec2 result = vec2(0.0);\n\n    for (float c = 0.; c < _count; c+=1.)  \n    {\n        result.x += sin(a[int(c)]*t) / (c + 1.);\n        result.y += cos(a[int(c)]*t) / (c + 1.);\n    }\n\n    return \n        count == 0.0 ? vec2(0.0) : result;\n}","name":"Common","description":"","type":"common"}]}