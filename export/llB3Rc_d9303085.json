{"ver":"0.1","info":{"id":"llB3Rc","date":"1433708685","viewed":521,"name":"Heavy","username":"huwb","description":"Light travelling sloooooooow. The slider controls how much time passes as the photons fly (inverse speed). This trivial addition to raymarching leads to some really weird and wonderful effects, such as the nice inherent doppler effect on the motion.","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["light","doppler","relativity","timeofflight"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// the core technique here is a simple extension of raymarching - instead of the render\n// time being a fixed global constant, it is advanced as rays are marched through the scene.\n\n// this produces some interesting phenomena:\n// * distorted shape of both spheres\n// * doppler effect on vertical oscillation of orbiting sphere\n// * propogation of light from src->surface->camera evident as light changes intensity\n// * light propagation also evident in shadows, causing weird lava lamp effects\n\n// the orbiting sphere appears broken up or sliced at slow photon speeds because the\n// sphere is moving away from the ray and the raymarch struggles to catch it. there\n// may be elegant ways to inform the raymarch of the motion in the scene so that the\n// step size takes motion into account, but i couldnt think of an elegant and general\n// solution.\n// EDIT: over relaxation should help convergence in theory but i havent tried it:\n// http://erleuchtet.org/~cupe/permanent/enhanced_sphere_tracing.pdf\n// https://www.shadertoy.com/view/ldSSDV\n\n// disable this if the framerate is low\n#define MOTIONBLUR\n\n#define MOUSEX (iMouse.x/iResolution.x)\n#define MOUSEY (iMouse.y/iResolution.y)\n#define PI (3.14159265)\n#define TWOPI (2.*PI)\n#define FLOORY -3.\n#define ZFAR 1000.\n\n// vol texture\nfloat checker( vec3 pos, float scale );\n\n// time it takes a photon to travel 1m. easier to deal with than light speed.\nfloat light_time_per_m()\n{\n    return (iMouse.z > 0.) ? (min(1.,max((MOUSEY-0.25)/0.7,0.))*0.06) : (sin(iTime*.25)*.5+.5)*.06 ;\n}\n\n// light pos\nvec3 light( float t )\n{\n    return vec3(2.,3.5*sin(4.*t),2.);\n}\nfloat lightI( float t )\n{\n    // fade light when close to floor to avoid harsh pop\n    return clamp((light(t).y-FLOORY)/2.,0.,1.);\n}\n\n// scene\nfloat sdf( vec3 pos, float t, out vec4 objPos )\n{\n    float d = ZFAR;\n    \n    float r = 1.;\n\n    float stepR = 1.;\n    \n    vec3 c1 = vec3(.0,-0.5,0.);\n    float d1 = stepR * length(pos-c1) - r;\n    if( d1 < d )\n    {\n        objPos.xyz = c1;\n        objPos.w = 1.;\n        d = d1;\n    }\n    \n    vec3 c2 = vec3(5.*cos(2.*t), sin(8.*t), 5.*sin(2.*t));\n    float d2 = stepR * length(pos-c2) - r;\n    if( d2 < d )\n    {\n        objPos.xyz = c2;\n        objPos.w = 1.;\n        d = d2;\n    }\n\n    vec3 c3 = vec3(0.,FLOORY,0.);\n    vec3 n3 = vec3(0.,1.,0.);\n    float d3 = abs(dot(pos-c3,n3));\n    if( d3 < d )\n    {\n        objPos.xyz = c3;\n        objPos.w = 5.;\n        d = d3;\n    }\n    \n    return d;\n}\nvec3 normal( vec3 pos, float t )\n{\n    vec2 dd = vec2(0.01,0.);\n    vec4 c;\n    return normalize(\n        vec3(sdf(pos+dd.xyy,t,c), sdf(pos+dd.yxy,t,c), sdf(pos+dd.yyx,t,c) ) - vec3(sdf(pos,t,c))\n                    );\n}\n\n// 4D raymarch\nfloat raymarch( vec3 o, vec3 target, float start_time, float timeDir, out vec4 objPos )\n{\n    objPos = vec4(0.,0.,0.,1.);\n    vec3 delta = target - o;\n    float dist = length( delta );\n   \n    vec3 d = delta / dist;\n    \n    float eps = 0.001;\n    \n    float x = 0.;\n    float t = start_time;\n    \n    for( int i = 0; i < 150; i++ )\n    {\n        float dx = sdf( o + x * d, t, objPos );\n        \n        if( abs(dx) < eps )\n        {\n            return x;\n        }\n\n        dx *= .7;\n        x += dx;\n        if( x >= dist )\n            break;\n        \n        // progress time as ray advances to simulate flight time of photon\n        t += timeDir * light_time_per_m() * dx;\n    }\n    \n    return ZFAR;\n}\nfloat raymarch_againstphotons( vec3 o, vec3 target, float start_time, out vec4 objPos )\n{\n    return raymarch( o, target, start_time, -1., objPos );\n}\nfloat raymarch_withphotons( vec3 o, vec3 target, float start_time, out vec4 objPos )\n{\n    return raymarch( o, target, start_time, 1., objPos );\n}\n\n// given a surface position and time - when would a photon have set off from\n// the light to arrive at the surface? not straightforward for a moving light\nfloat lightPhotonStartTime( vec3 finalPos, float finalTime )\n{\n    float startTime = finalTime;\n    \n    // my old friend FPI\n    for( int i = 0; i < 3; i++ )\n    {\n        startTime = finalTime - light_time_per_m() * length( light( startTime ) - finalPos );\n    }\n    \n    return startTime;\n}\n\nvec3 render( vec3 o, vec3 d, float ti )\n{\n    vec4 objPos;\n\tfloat geom = raymarch_againstphotons( o, o + ZFAR * d, ti, objPos );\n    \n    vec3 amb = vec3(1.,0.9,0.8) * .3;\n    \n    if( geom == ZFAR )\n        return amb * .5;\n    \n    float geomT = ti - geom * light_time_per_m();\n    \n    vec3 pt = o + geom * d;\n    vec3 n = normal( pt, geomT );\n    vec3 col = amb * checker(pt-objPos.xyz,objPos.w);\n    \n    // raymarch from light to surface for shadow\n    float lightT = lightPhotonStartTime( pt, geomT );\n    float lenToLight = length(light(lightT) - pt);\n    \n    vec4 dummy;\n    float lightGeom = raymarch_withphotons( light(lightT), pt, lightT, dummy );\n    if( lightGeom > lenToLight-.1 )\n    {\n        vec3 lightDir = normalize( light(lightT) - pt );\n        col = (amb + lightI(lightT)*vec3(.7) * clamp(dot( n, lightDir ), 0., 1.)) * checker(pt-objPos.xyz,objPos.w);\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy) * 2. - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n    float fov = .5;\n    uv *= fov;\n    \n    // cam setup\n    float r = 15.;\n    vec3 o = vec3( r*cos(MOUSEX*TWOPI*1.5), 0., r*sin(MOUSEX*TWOPI*1.5) );\n    vec3 d = normalize(-o);\n    vec3 ri = vec3( -sin(MOUSEX*TWOPI*1.5), 0., cos(MOUSEX*TWOPI*1.5) );\n    d += uv.x * ri + uv.y * vec3(0.,1.,0.);\n    d = normalize(d);\n    \n   \tfragColor = vec4(.0);\n    \n    // shoot 5 rays for some brute force MB\n   \tfragColor += vec4(render(o,d,iTime), 1.);\n    \n    #ifdef MOTIONBLUR\n   \tfragColor += vec4(render(o,d,iTime-0.006), 1.);\n   \tfragColor += vec4(render(o,d,iTime-0.003), 1.);\n   \tfragColor += vec4(render(o,d,iTime+0.003), 1.);\n   \tfragColor += vec4(render(o,d,iTime+0.006), 1.);\n    fragColor /= 5.;\n    #endif\n    \n    // finally blend in slider\n    float tpm = light_time_per_m();\n\tvec2 uvs = (fragCoord.xy / iResolution.xy);\n    if( uvs.x == clamp(uvs.x,0.06,0.09) )\n    {\n        float lw = 2./iResolution.x;\n        float alpha = smoothstep( 0.075-lw,0.075, uvs.x ) - smoothstep( 0.075,0.075+lw, uvs.x );\n        alpha *= smoothstep(0.25-lw,0.25,uvs.y) - smoothstep(0.948,0.95,uvs.y);\n        float sliderHeight = 0.25 + 0.7*tpm/0.06;\n        float sliderR = 0.02;\n        float r = length((uvs-vec2(0.075,sliderHeight))/vec2(iResolution.y/iResolution.x,1.));\n        float sliderAlpha = smoothstep(sliderR-lw*1.5,sliderR,r) - smoothstep(sliderR,sliderR+lw*1.5,r);\n        alpha = .5*max(alpha, sliderAlpha );\n\t    fragColor.xyz = mix( fragColor.xyz, vec3(1.), alpha );\n    }\n}\n\nfloat checker( vec3 pos, float scale )\n{\n    float mi = .9;\n    float ma = 1.;\n    \n    pos /= scale;\n    \n    bool greater = abs(fract(pos.x)) > 0.5;\n    \n    if( abs(fract(pos.z)) > 0.5 )\n        greater = !greater;\n    if( abs(fract(pos.y)) > 0.5 )\n        greater = !greater;\n    \n    return greater ? ma : mi;\n}\n","name":"","description":"","type":"image"}]}