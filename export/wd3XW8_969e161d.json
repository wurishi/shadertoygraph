{"ver":"0.1","info":{"id":"wd3XW8","date":"1571855685","viewed":89,"name":"2.2 Igloo","username":"JHL","description":"A lovely igloo","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926535897932384626433832795\n#define RENDER_DEPTH 800\n#define CLOSE_ENOUGH 0.00001\n\n#define GRADIENT(pt, func) vec3( \\\n    func(vec3(pt.x + 0.0001, pt.y, pt.z)) - func(vec3(pt.x - 0.0001, pt.y, pt.z)), \\\n    func(vec3(pt.x, pt.y + 0.0001, pt.z)) - func(vec3(pt.x, pt.y - 0.0001, pt.z)), \\\n    func(vec3(pt.x, pt.y, pt.z + 0.0001)) - func(vec3(pt.x, pt.y, pt.z - 0.0001)))\n        \n\n//Array of lights in our scene\nconst vec3 LIGHT_POS[] = vec3[](vec3(5.0));\n\n//---------------------------------------------------------------------------------------\n// Transformations, twisting and merging\n//---------------------------------------------------------------------------------------\n\nmat4 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(c, s, 0, 0),\n        vec4(-s, c, 0, 0),\n        vec4(0, 0, 1.0, 0),\n        vec4(0, 0, 0, 1.0)\n    );\n}\n\nmat4 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(c, 0, s, 0),\n        vec4(0.0, 1.0, 0, 0),\n        vec4(-s, 0, c, 0),\n        vec4(0, 0, 0, 1.0)\n    );\n}\n\nfloat smin(float a, float b){\n    float k = 0.2;\n    float h = clamp((0.5 + 0.5 * (b - a) / k), 0.0, 1.0);\n    return mix(b,a,h) - k * h * (1.0-h);\n}\n\n//---------------------------------------------------------------------------------------\n// Signed Distance Functions\n//---------------------------------------------------------------------------------------\n\nfloat sphere(vec3 pt, float r) {\n    return length(pt) - r;\n}\n\nfloat semisphere(vec3 pt, float r){\n    if (pt.y < 0.0) return 1.0;\n    else return length(pt) - r;\n}\n\nfloat box(vec3 pt, vec3 dim){\n  vec3 d = abs(pt) - dim; // dimensions\n  float val = min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n  return val;\n}\n\nfloat cylinder(vec3 pt, float r, float h){\n    if(pt.y < 0.0 || pt.y > h) return 1.0;\n    else return length(pt.xz) - r;\n}\n\nfloat scene(vec3 pt) {\n    return max(smin(smin(\n        \t\tsemisphere(pt - vec3(0,-1,0), 5.0),\n               \tcylinder(pt - vec3(4.5,-1.0,0), 1.0, 2.0)),\n                semisphere(pt - vec3(4.5,1,0), 1.0)),\n               \t-box(pt - vec3(5,0,0), vec3(5,1,0.7))\n              );\n}\n\n//---------------------------------------------------------------------------------------\n// Auxiliary helper functions\n//---------------------------------------------------------------------------------------\n\nvec3 getNormal(vec3 pt) {\n    return normalize(GRADIENT(pt, scene));\n}\n\n//---------------------------------------------------------------------------------------\n// Illumination and Shading\n//---------------------------------------------------------------------------------------\n\nfloat shade(vec3 eye, vec3 pt, vec3 n) {\n    float val = 0.0;\n\n    //Ambient Lighting\n    val += 0.2;\n\n    //Cast ray towards our light sources and add it to the illumination depending\n    //on the angle with the normal to the surface\n    for (int i = 0; i < LIGHT_POS.length(); i++) {\n        vec3 l = normalize(LIGHT_POS[i] - pt); \n        val += max(dot(n, l), 0.0);\n    }\n\n    return val;\n}\n\nvec3 illuminate(vec3 camPos, vec3 rayDir, vec3 pt) {\n    vec3 c, n;\n    //Using the SDF normal approximation\n    n = getNormal(pt);\n\t\n    //Everything is white\n    c = vec3(1.0);\n    return shade(camPos, pt, n) * c ;\n}\n\n//---------------------------------------------------------------------------------------\n// Ray Marching Algorithm\n//---------------------------------------------------------------------------------------\n\nvec3 castRay(vec3 camPos, vec3 rayDir) {\n    //Using the ray marching approach\n    int step = 0;\n    float t = 0.0;\n    \n    for (float d = 1000.0; step < RENDER_DEPTH && abs(d) > CLOSE_ENOUGH; t += abs(d)) {\n        d = scene(camPos + t * rayDir)/2.0;\n        step++;\n    }\n    \n    if (step == RENDER_DEPTH) {\n        return vec3(0.0, 0.0, 0.0); //getBackground(rayDir);\n    } else {\n        return illuminate(camPos, rayDir, camPos + t * rayDir);\n    }\n}\n\n//---------------------------------------------------------------------------------------\n// Set-up\n//---------------------------------------------------------------------------------------\n\nmat3 setCamera(in vec3 origin, in vec3 target, float rotation) {\n    //The direction in which the camera is pointing\n    vec3 forward = normalize(target - origin);\n    vec3 orientation = vec3(sin(rotation), cos(rotation), 0.0);\n    vec3 left = normalize(cross(forward, orientation));\n    vec3 up = normalize(cross(left, forward));\n    return mat3(left, up, forward);\n}\n\n//---------------------------------------------------------------------------------------\n// Output\n//---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //Normalize the 2d coordinates [-1, 1]\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    \n    //Fix the x axis to original resolution\n    p.x *= iResolution.x / iResolution.y;\n    \n    //Setting the camera - origin, lookat\n    vec3 origin = vec3(10.0*sin(iTime), 1.8, 10.0*cos(iTime));\n    vec3 look = vec3(0.0);\n    \n    \n    mat3 camera = setCamera(origin, look, 0.0);\n    vec3 direction = camera * normalize(vec3(p.xy, 2.0));\n    \n    vec3 color = castRay(origin, direction);\n    \n    fragColor = vec4(color, 0.0);\n}","name":"Image","description":"","type":"image"}]}