{"ver":"0.1","info":{"id":"MdXBD2","date":"1498124597","viewed":168,"name":"027 lib DA7 enveloping","username":"ollj","description":"This is a mix of\n 021 , my big collection\n 027, automatic differentiation\n\"enveloping\" , smoothstep()-like curves\n\nthis is a library, lacking the demo part (disabled for now)\nhow many shaders do have a commentary index?","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["derivative","envelope","alpha","arithmetic","mercury","composition","hgsdf","differential","automaticdifferentiation","calculus","lisp"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":" //https://en.wikipedia.org/wiki/Alpha_compositing\n vec4 aOverB(vec4 a,vec4 b){a.xyz*=a.w;b.xyz*=b.w;return vec4(a+b*(1.-a));}\n //vec2 aOverB(vec2 a,vec2 b){a.x*=a.y;b.x  *=b.y;return vec2(a+b*(1.-a));}\n //not sure if correct, but looks useful.\n vec4 aXorB(vec4 a,vec4 b){a.xyz*=a.w;b.xyz*=b.w;return vec4(a*(1.-b)+b*(1.-a));}\n //vec2 aXorB(vec2 a,vec2 b){a.x*=a.y;b.x  *=b.y;return vec2(a*(1.-b)+b*(1.-a));}\n #define ssb2(a,b) smoothstep(a,-a,b)\n #define ssb(b) smoothstep(blur,-blur,b)\n\nvoid mainImage(out vec4 o,in vec2 u){\n //u/=4.;\n vec4 a=texture(iChannel0,u/iResolution.xy);\n vec4 b=texture(iChannel1,u/iResolution.xy);\n //a.w*=.5;\n o=aOverB(a,b);\n //o=a;\n}\n/*All the stuff is in the BufA tab because \"Image\" can not be read from\nReading from past self is kind essential for recursion.\n*/","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//camera IO\n//parents:\n// https://www.shadertoy.com/view/ldByDw\n// https://www.shadertoy.com/view/4lVXRm\n// Created by genis sole - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.\n\n\n/*\nangular momentum , my arch nemesis.\n\nwith 6 keyboard inputs, i can modify the the spin around 3 axes.\nI want this to be a single axis, but 3d rotation is not commutative.\nthis is where i keep failing, by wanting something impossible.\n\nhow about a different approach.\ninput sets a vector, \nvector gets projected on plane by making length=1.\ncomparing with vec3(1,0,0), we have an axis and an angle.\nnope is silly.\n\nhow about another approach.\nimagine a boat on a sphere. it has position and direction.\ninput modifies boat position and direction. [ud+lr] and rotate on sphere plane.\nsomehow that modifies a cameras momentum.\nboat position sets axis. what seets angle?\n\nhow about i just find out how others did it, and copy that?\nits an old problem and noone seems to bother.\ndescent \"solves\" it with mat4 arrays, which is just slow in modern opengl.\nits not using quaternions, but the mat4 equivalences, \n- and that removes all the advantages of quaternions over axisangle!\n\ndescent sure does not deal with textures that display differentials \nof automatic differentiation.\n\n\ni have a direction vector, that is rotated b a quaternion, \nthat part is VERY simple.\n\nthe tricky part is to define the quaternion.\nand noone bothers to explain that one?\n\noh right. hitting 2 or 3 axial jeys at once means a different axis. \ni forgot that simple thing\nthen i just modify a quaternion by that input.\n\nyeah hat should do the trick!\n\nlist of quaternions:\n- finalSum = r(changePerFrame,finalSum)  //rotate finalsum by changeperframe\n//- changePerFrame.w*=friction\n- changePerFrame=r(keySum,changePerFrame) //rotate chanbeperframe by keyinout\n\nfor a pseido-analog accelleration:\n- the longer a key is held down, the faster you go..\n- i used to have a working derivative acellerating model:\n- - this shader is not that...\n- - while (button down) directly adjust speed.\n- - - from speed, position was modified.\n- - - then speed got diminished by friction.\n\nlets do it for rotation.\n\n6 keys set rotation speed.\nholding multiple at once will set a diagonal axis.\ni see how that can get \"spinning wildly\" rather quickly.\nbut that is likely not a big problem, and more of a feature?\n\nlooks like i want a  type of friction that diminishes angular momentum ;)\njust to make digital rotation more analogous.\n\nbottom line, i must make a \"generate axis\"\nand with mouse inpput for rotation, that axis is already fuzzy.\nbut i did that before.\n\nmy unresolved problem was most likely just the lerping between rotations.\n\ni am currently in one rotation,\nand holding down another button lers me into aother rotation?\nnaah!\n\n\ncan i even have 2 spins at once, or does that always condense to a single spin?\nfourier and spirographs show overtone fun.\nhow is that with 3d rotations?\ni safely assume they all come down to a single axisangle!!\n\n\nimagine conservation of angular momentum.\nyou have gyroscopes spin and hold you in position.\nyour input just modifies those.\n\nin the end i modify 3 axisangle rotations NO, \nthen order of inpout matters, and it should not!\n\nimagine you 6 keys control jet engines, true angular momentum.\njet engines are not instantly fullpower, \nthey have \"engine speeds\" that your inoput modifies.\n\nto simplify, we have 3 dualDirection jet engines.\ntheir offset is the same (unit circle distance)\n\n\nhow does one sum up 3 non-colinea engines, this is m simple question!\n\nwell, it must be relative to the center of masas, for once!\n\nit involves some simple dot() cross() stuff, \n... measuring an angular force in a 90deg angle to a center of mass.\n\n---------\n\ni got a new epiphany.\n\nimagine a single axisangle rotation, it is diaonal ot reference frame.\nit splits in 2 axisangle rotations that move apart will their axes are perpendicular\nthey started as compound average.\nwhat acis and spin they drift to sets all the symmetry.\nwhat angle they start with sets their spin ratios.\nthis is the unification i long for?\nyes, it should be as simple as (3d) trigonometry.\nand i can imagine a 2d case, considdering 2 axisangle rotations with coplanar axes.\n\nhis is the analogous to moving, or pulling something. at 2 angles.\ntheir sideways forces cancel each other out (no faster diagonal movements)\n\nall that \"spin\" does is doing it with an offset from the center of mass.\n\nthis is equal to a tuf of war, where the rope goes around a sphere!\nand where there are 3 non-coplanar ropes.\nthe 3 ropes are identical to a singular \"tilted\" rope.\nmultiple ropes do not meet in the same point, but they in the same circle!\nits not their axes that average out. its their \"rope circles\". \n\nwell both are equal, so theres my insecirit gone!\n\n\n*/\n\n//#define SkipThis\n#ifdef SkipThis\nvoid mainImage(out vec4 o,in vec2 i){o=vec4(0);}\n#else\n\n/*\nstart.const.IO.Camera\n*/\n//shared address pointers to buffer camera data\n#define store(p,v) if(all(equal(U,p+.5)))O=v\n#define load(P) texture(iChannel1, (P + 0.5) / iChannelResolution[1].xy, -100.0)\nconst vec2 MEMORY_BOUNDARY=vec2(4,3);\nconst vec2 POSITION=vec2(1,0);\nconst vec2 VMOUSE  =vec2(1,1);\nconst vec2 PMOUSE  =vec2(2,1);\nconst vec2 TARGET  =vec2(0,2);\nconst vec2 RESOLUTION=vec2(3,1);\n\n/*\nend__.const.IO.Camera\nstart.IO.Camera\n*/\n\n#define key(K)  step(0.5, texture( iChannel0, vec2(K, 1.0/6.0) ).x)\n\n// Keyboard constants definition\n//#define l(a,b) a=(float(b+64)+.5)/256.\n#define _BSP   -57\n#define _SP    -33\n#define _LEFT  -28\n#define _UP    -27\n#define _RIGHT -26\n#define _DOWN  -25\n#define _COMMA 124\n#define _PER   125\n#define _a 0\n#define _b 1\n#define _c 2\n#define _d 3\n#define _e 4\n#define _f 5\n#define _g 6\n#define _h 7\n#define _i 8\n#define _j 9\n#define _k 10\n#define _l 11\n#define _m 12\n#define _n 13\n#define _o 14\n#define _p 15\n#define _q 16\n#define _r 17\n#define _s 18\n#define _t 19\n#define _u 20\n#define _v 21\n#define _w 22\n#define _x 23\n#define _y 24\n#define _z 25\n#define k(a) key(((float(a+65)+.5)/255.))\n/*usage:\nfloat a= k(_a);\nfloat b= k(1);//alternatively\n*/\n\n//key binds and constains\nvec3 constrainDiagonal(vec3 r){return (r==vec3(0))?r:normalize(r);}\n#define arrows +vec3(k(_RIGHT)-k(_LEFT),k(_UP)-k(_DOWN),k(_SP)-k(_COMMA))\n#define esdf   +vec3(k(_f    )-k(_s   ),k(_e )-k(_d   ),k(_r )-k(_w   ))\n#define wasd   +vec3(k(_d    )-k(_a   ),k(_w )-k(_s   ),k(_e )-k(_q   ))\nvec3 KeyboardInput(){vec3 r= \n +arrows\n +esdf\n//+esdf\n//above=key binginds | below = constrain sum and diagonal movement.\n ;return clamp(constrainDiagonal(r),vec3(-1),vec3(1));;}\n\n//quaternions q()<->creation r()<->rotaition\n//normalize quaternion: true for quaternions <-> nornamoze(q)=q/length(q)==q/length(q*q)=q/dot(q,q)\nvec4 q(vec4 q){return q/dot(q,q);}\n//above is faster alternative to [normalize(q)] that only works for SOME situatinons;\n//return quaternin of [axis]&{angle] rotation\nvec4 q(vec3 axis,float angle){angle*=.5;return q(vec4(axis*sin(angle),cos(angle)));}\n//return [r]rotation, rotated by [b] //use like matrix multiplication\nvec4 r(vec4 b,vec4 r){return q(vec4(b.w*r.xyz+r.w*b.xyz+cross(b.xyz,r.xyz),b.w*r.w-dot(b.xyz,r.xyz)));}\n//return [r]vector, rotated by [b] //use like matrix multiplication\nvec3 r(vec4 b,vec3 r){vec3 t=2.*cross(b.xyz, r);return r+b.w*t+cross(b.xyz,t);}\n//from  https://www.shadertoy.com/view/lstSRM\n\nvec3 CameraDirInput(vec2 p){vec2 m=p/iResolution.x;m.y=-m.y;\n vec2 s=sin(m),c=cos(m);\n //yay, more shitty euler rotation!!!\n mat3 rotX=mat3(1,0,0,0,c.y,s.y,0,-s.y,c.y);\n mat3 rotY=mat3(cos(m.x),0.,-s.x,0,1,0,s.x,0,c.x);\n return rotY*(rotX*KeyboardInput().xzy);\n }\n//lets try quaternion fun:\n//vec3 CameraDirInput(vec4 q){return r(q,KeyboardInput());}\n//movement.constain\n//void Collision(vec3 prev,inout vec3 p){if(p.y<1.)p=vec3(prev.xz,max(1.0,prev.y)).xzy;}\n\nvoid mainImage(out vec4 O,in vec2 U){   \n if(any(greaterThan(U,MEMORY_BOUNDARY))){\n  O=vec4(0);\n return;\n }\n O=load(U-.5);\n vec2 re=load(RESOLUTION).xy;\n store(RESOLUTION, vec4(iResolution.xy, 0.0, 0.0));\n if(iTime==0.||iFrame==0||any(notEqual(iResolution.xy,re))){\n  //init|reset\n  store(POSITION, vec4(0,2,0,0));\n  store(TARGET, vec4(0,2,0,0));\n  store(VMOUSE, vec4(0));\n  store(PMOUSE, vec4(0));\n return;}\n //load\n vec3 target  =load(TARGET).xyz;   \n vec3 position=load(POSITION).xyz;\n vec2 pm      =load(PMOUSE).xy;\n vec3 vm      =load(VMOUSE).xyz;\n //move\n vec3 ptarget=target;\n target+=CameraDirInput(vm.xy)*iTimeDelta*5.;\n //Collision(ptarget, target);\n //store\n store(TARGET,vec4(target,0));\n position+=(target-position)*iTimeDelta*5.; \n store(POSITION,vec4(position,0));\n if(any(greaterThan(iMouse.zw,vec2(0)))){\n     //this {}bracket is mandatory!\n  store(VMOUSE, vec4(pm+(iMouse.zw-iMouse.xy),1,0));\n }else if(vm.z!=0.)store(PMOUSE,vec4(vm.xy,0,0));\n}\n#endif","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/* start.init.mutable \nself: https://www.shadertoy.com/view/MdXBD2\nself: 027.v23\n\niChannel0->cam input\niChannel1->sdf glyphs (ascii, 16 glyphs per line first 32 are wildcard symbols)\niChannel2->rgba noise\niChannel3->Keyboard In\n*/\n\n //define what time is, how (fast) it changes or it if is paused at any value.\n #define time iTime\n //#define time .5\n //-> [time dimension becomes spatial]\n\n //Here ends the bad habbit of; starting to count at 1! Start counting at 0!:\n\n #define eps 2e-2\n //epsilon for raymarching, is as heuristic as root solving\n\n //#define SuperPrim\n //optionally show superprim \n //== https://www.shadertoy.com/results?query=superprim\n #define IterRm 64\n //max raymarch iterations|steps\n \n #define IterSh 16\n //softshadow iterations\n \n #define ReciprocalAbsLipschitz .99\n //if(lipschitzConstant>1., distance is overestimated.\n //multiplying by ReciprocalAbsLipschitz is a \n //... lazy fix for that is scaling stepDistance*=ReciprocalAbsLipschitz\n //higher precision with a smaller ReciprocalAbsLipschitz AND epsilon=0.\n //meaning, a surface will NEVER really be reached.\n //maybe todo: eps=log(eps*b)*a\n\n //increasing epsilon with distance can speed up convergence, distorts space.\n //#define dynamicEps\n\n #define camLens 2.\n #define camRoll 0.\n //camera lens and roll for camera projection matrix (is not a quaternion camera)\n #define frame(u) camLens*(u-.5*iResolution.xy)/iResolution.y   \n //grid thickness\n #define thick .2\n //line thickness (it does nice tangential lines for the first derivative visualisazion, \n //... by using the analytic second derivative)\n\n/*\nend__.init.mutable \nstart.init.index\n*//*\nTo jump to a chapter press shift+f\n... and enter \"start.index\", or any other listed \"start.subroutine\" or \"end__.this\"\n\nindex of chapters, implement self, extend previous chapters:\n.\n.init.mutable       ,modes, set before compile time\n.init.index         ,self\n.init.intro         ,summary, family history\n.const.arithmetic   ,arithmetic constants\n.const.struct       ,structure avoids informal fallacies\n.const.comm         ,communication constants, to read from other buffers.                    \n.\n.common             ,general common shorthands\n.branchless         ,for longer pipelines, if(within hardware limits)better performance\n.text               ,buffered-sdf-glyph functions\n.solve.les          ,solve linear equation system\n.solve.root         ,solve roots\n.differentiation    ,automatic differentiation, chain_rule\n.\n.transform.hash     ,hash transform\n.transform.noise    ,pseudo random, pseudo quantum\n.transform.gradient ,transform color space\n.transform.common   ,transform coordinate (geography, complex planar)\n.ray.trace          ,raytrace (equivalent to solve.les)\n.ray.march          ,raymarch (equivalent to solve.root), often with orbitals\n.ray.march.sub      ,...atomic shape\n.ray.march.main     ,...2nd order merge and recursion\n.\n.demo               ,still a fuzzy mess\n.main               ,still a fuzzy mess\n.main2              ,still a fuzzy mess\n.dump               ,unsorted\n.memo               ,misc hyperlink\n.license            ,authorship\n\nchapters should end with a demo[ChapterName](){} function\n*//*\nend__.init.index\nstart.init.intro\n*//*\n\nThis is a merger of 2 large collections of algebra and logic, \nalways incomplete or inconsistent.\n\n\nbuffA used to be 026 automatic differentiation\nhttps://www.shadertoy.com/view/MsffRs\nto be mixed with BuffB\nbuffB, 021-collection\n\nall in one shader, to use the same \"automatic differentiation\" library.\nthis needs a view that shows all in one, possibly over time, if only to debug.\n\n021 family tree:\nhttps://www.shadertoy.com/view/lsSyRd   =021\nhttps://www.shadertoy.com/view/XsBczV   =parent\nhttps://www.shadertoy.com/view/ldByDw   =granddad\n\n021, look at all the curve, math\nmy big collection, before switching to automatic differentiation\n\nrexture reading functions exist as unused wrapper aliases.\niChannel0 is self\niChannel1 is font texture\n\ntutorializing webgl fragment shader collection for shadertoy\nthis dives DEEP into irrational complex rotation matrix math.\n\nit also has ability to display glyphs, floats\n(though i might have broken that ones spacing)\n\n026 family tree\nparent     : https://www.shadertoy.com/view/MsffRs\ngrandparent: https://www.shadertoy.com/view/XdXfRl (v025)\nv026 just adds minor things\n\n\"024 Derivative Arithmetic >3\" are a variant of\n https://www.shadertoy.com/view/XdfBzj\n\"023 Derivative Arithmetic  3\" with one core change:\n\"023 Derivative Arithmetic  3\" uses vectors and matrices (and a struct for a mat43)\n\"024 Derivative Arithmetic >3\" use different structure, to differentiate 2 arithmetics.\nExplicit structure adds  symmetry, making things simpler.\nExplicit structure confuses, mostly due to its atomic defines, and counting from 0.\nExplicit structure creates \"permutation hell\", as usual.\nExplicit structure does not slow down performance.\n\nThis defines implicit 3d Surfaces, or 2d curves, \n... with ChainRule automatic differentiation Arithmetic, \nThis inevitably makes you write in prefixNotation, like Lisp source code.\nsurely this would look much better in Lisp than in Webgl\nStill waiting for the Lisp gpu API, and openCL or CUDA are not my thing!\n... there is \"harlan\" for inspiration, but it is a 2007 non-api thing...\n\n\"024 Derivative Arithmetic 5\" has 4 modes (patchwork):\nto be used in 3d, 2d and 1d.\n\n\"024 Derivative Arithmetic 4\" possibly fixed the modulo function's errors?\n\ngeneral automatic differentiation is:\n-based on    : https://www.shadertoy.com/view/4dVGzw\n-inspired by : https://www.shadertoy.com/view/Mdl3Ws \n-explained at: http://blog.demofox.org/2014/12/30/dual-numbers-automatic-differentiation/\n-wiki        : https://en.m.wikipedia.org/wiki/Automatic_differentiation\n-summary:    : https://www.reddit.com/r/math/comments/68st6p/the_wikipedia_article_on_automatic/\n\ndad: https://www.shadertoy.com/view/4dVGzw\nbut with swiveled parameters:\ndad: has .xyz as Dfdx() Dfdx() Dfdz(), via automatic differentiation\nollj has .d   as Dfdx() Dfdx() Dfdz(), via automatic differentiation +structure\n\nbrother: https://www.shadertoy.com/view/XlV3Dy\nbrother: Has the goursat_surface, C0-discontinuous isosurface example\nTHIS has derivative arithmetic fields of hg_sdf:\n  mercury.sexy/hg_sdf/\nBut where a hg_sdf_function returns the distance to point [p].\nTHIS returns distance to point [p] as .x \n...and N_first_derivatives along N_domains as .d\n...for point [p]\n\nsister: https://www.shadertoy.com/view/MsXBRB\nfocuses on simpler implicit surfaces, is a nicer more constrained introduction.\n\n/*\nend__.init.intro\nstart.const.struct\n*/\n//structs are more a namespace issue and less of a mathematic fundament as the above\n//enforcing sctructs makes it harder to confuse things for other things.\n//important for raytracing, analysis, automatic differentiation\nstruct plane  {vec3 n;float d;}Mplane;//plane normal && DISTANCE <- NormalForm (is not the HNF !)\nstruct quat   {vec3 i;float r;}Mquat;//quaternion; axis.ijk && Angle\nstruct rotaAA {vec3 a;float r;}MrotaAA;//AxisAngleRotation; axis.xyz && Angle.w\nstruct sphere {vec3 c;float r;}Msphere;//sphere; center.xyz && radius.w\nstruct ray    {vec3 o;vec3  d;}Mray;//ray; origin && direction\n//todo, rotate plane and points by things.\n#define m3 mat4\n#define m2 mat3\n#define m1 mat2\n//the below is basically an [m0]==[m]\n#define v3 vec4\n#define v2 vec3\n#define v1 vec2\n#define v0 float\n//dual number arithmetic structure:\nstruct d {v0 x;v0 d;};//+gradient on 1 domain , is a vec2\nstruct d1{v0 x;v1 d;};//+gradient on 2 domains, is a vec3\nstruct d2{v0 x;v2 d;};//+gradient on 3 domains, is a vec4\n//substiduting \"d0\" to \"d\" is worth it here.\n//above namespaces must be short, try not to confuse a [type] with a [label|pointer].\n//short defines tend to kill compatibility. make no single character defines!\n   \n/*todo, ipmplemnt tripple number arithmetic structure, \n//...for second derivaive automatic differentiation:\n//for all the fun that comes with precise double integrals?\nstruct d22{v0 x;v2 d;v2 d1};//d==1stDerivatives==gradient; d1=2ndDerivatives==Curvature\nstruct d11{v0 x;v1 d;v1 d1};\nstruct d00{v0 x;v  d;v  d1};//substituting d00 to something shorter? bad idea!\n*/\n\n//Explicit structure [.x] utilizes simple (non complex number) arithmetic as you know it.\n//Explicit structure [.d] calculates the first derivative as a byproduct, for each domain.\n//...using the chain rule  https://en.wikipedia.org/wiki/Chain_rule\n//ALL functions get a \"*d\" added to it, wrapping them in this new namespace.\n//By differetiating by type, automatic differentiation includes non-automadic arithmetic.\n//v1 addd(v1 a,v1 b){return a+b;}\n//\n//This inlcusion should enable you do #define a distance field\n//...and that will define it for derivative arithmethic AND non derivative arithmetic.\n//...and you neet to say goodbye to the infix_notation with \"+-*/%^\" operands.\n//and replace it with a proper prefix_notation, like writing in Lisp.:\n//  https://en.wikipedia.org/wiki/Polish_notation\n//a+b*pow(c,d) \n//becomes\n//addd(a,muld(b,powd(c,d)))\n//\n//The \"art\" here is to define an implicit isosurface\n//  https://en.wikipedia.org/wiki/Implicit_surface\n//  https://en.wikipedia.org/wiki/Isosurface\n//...as a(n extended) distance_field equivalent with Arithmetic that\n//...automatically calculate its first derivatives for any point (without multisampling)\n//An overview of that is best explained in\n//  https://www.youtube.com/watch?v=qb40J4N1fa4\n//That way you get all the Contour lines, gradients, normals...\n//  https://en.wikipedia.org/wiki/Contour_line\n//  https://en.wikipedia.org/wiki/Gradient\n//  https://en.wikipedia.org/wiki/Surface_normal\n//...along all the domains (dimensions) of a surface\n//  https://en.wikipedia.org/wiki/Surface_%28topology%29\n//...very cheaply, because the contour is orthoogonal to the gradient.\n//\n// This requires a [Derivative Arithmetic] set for [Automatic Differentiation].\n// Derivative arithmetic [DA] is great for\n//- more precise surface normals and curvature. (better normals on corners)\n//- more precise anti-alasing\n//- faster better estimated gradient|contour calculation. (2d ellypse. metaballs)\n//- -https://en.wikipedia.org/wiki/Contour_integration\n//- Fluid dynamics, pressure waves (With a buffer over time)\n//- EM-fields: https://en.wikipedia.org/wiki/Surface_integral\n//- all that is in the todo list, at the bottom of this file\n//- https://en.wikipedia.org/wiki/Smoothness\n//- shapes with functions that that lack C0-continuity but have C1-continuity.\n//\n//All common arithmetic namespaces get a \"*d\" suffix added for [DA].\n//That \"*d\" means \"also calculate first derivatives for all the domains\".\n\n//filling lists with zeroes (seems to make more sese than filling them with (a);\nv1 v0tv1(v0 a){return v1(a,0);}\nv2 v0tv2(v0 a){return v2(a,0,0);}\nv3 v0tv3(v0 a){return v3(a,0,0,0);}\nv2 v1tv2(v1 a){return v2(a,0);}//what to put in .z here? .x or .y or.0?\nd  v0td0(v0 a){return d (a,0.);}\nd1 v0td1(v0 a){return d1(a,v1(0));}\nd2 v0td2(v0 a){return d2(a,v2(0));}\n//filling gradient with zeroes to include more domains.\nd1 d0td1(d  a){return d1(a.x,v0tv1(a.d));}\nd2 d0td2(d  a){return d2(a.x,v0tv2(a.d));}\nd2 d1td2(d1 a){return d2(a.x,v1tv2(a.d));}\n//there is an intuitive problem for the above, for 2 different easily mistaken cases:\n//- A 2d gradient has NULL differential along +1 additional domain.\n//- A vector gets all components scaled when multiplying a vector by a float.\n\n//The 3 (or 2) dimensions|domains \n//...are resolved with [struct DAmN{}] and [da_domain(vN  p)]:\n//where N=number of domains, range [0..3]\nstruct DAm2{d2 x;d2 y;d2 z;};//for 3 domains (density/distance field)\nDAm2 da_domain(v2 p){return DAm2(d2(p.x,v2(1,0,0)),\n                                 d2(p.y,v2(0,1,0)),\n                                 d2(p.z,v2(0,0,1)));}\nstruct DAm1{d1 x;d1 y;};//for 2 domains (heightmap, isoline, contour)\n//https://en.wikipedia.org/wiki/Contour_line\nDAm1 da_domain(v1 p){return DAm1(d1(p.x,v1(1,0)),\n                                 d1(p.y,v1(0,1)));}\nstruct DAm0{d x;};//for 1 domain (linear equation)\nDAm0 da_domain(v0 p){return DAm0(d (p  ,   1.));}\n//I will likely replace these with mat4, mat3 mat2.\n//Not sure yet, but it would make things simpler.\n/*\nend__.const.struct\nstart.const.arithmetic ----do not change this \"const\" section---\n*/\n\n/*\nWorld famous irrational numbers:\nDifferent definitions can change performance and precision.\nAll irrationals are infinite recursive fractions like a=1/n+(a), \n... with a sequence for every n being set by a defined series.\nThey can be approximated by iterating trough the infinite series.\nThose with larger divisors are approximated faster->\"less irrational\"\nphi-1=1/phi has the smallest divisor [1], approximates slowest->\"most irrational\"\n\nhttps://www.youtube.com/watch?v=CaasbfdJdJg\n//todo, function that gives dividend and divisor of irrationals after n-ierations\n\neul=limes of f(x)=pow(1+1/x,x)\npow(e,n)=firstDerivativeOf(pow(e,n));\neul=base for [log()] as the inverse of [pow(e,x)] so that\n... log(pow(eul,x))==x==pow(eul,log(x)); for [x>0]\n#define eul exp(9999999.)/*16bit float has 7 significant decimal bits, keeping this \"approximately precise\"*/\n//#define eul exp(1./0.) /*the exp() function approaches e for infinite x*/\n#define eul 2.61803398875\n//eul is not as awesome here, wait till I include advanced \"derivative arithmetic\"\n//\n////integerSquareroot/integer -> RootUnity:  https://en.wikipedia.org/wiki/Root_of_unity\n////With more n-gons this section boils down to more constants of \n////  https://en.wikipedia.org/wiki/Exact_trigonometric_constants\n//\n//generally: most simple fractions are not good enough approximations:\n//eg: 22/7 is not a precise enough approximation for a rotation by pi\n//... when you use polar coordinates.\n//\n//sqrt(2.)=1.4142135623730950488016887242097=\n//...pow(2.,1./2.)= ; https://en.wikipedia.org/wiki/Square_root_of_2#Properties_of_the_square_root_of_two\n//#define p22 sqrt(2.)\n//eightRotation.y=eightRotation.x=cos(pi4)=sin(pi4)=\n//...pow(2.,1./2.)/2=sqrt(2.)/2.=p22/2.=1./p22 =sqrt(0.5)==0.70710678118654752440084436210485\n#define p222 sqrt(0.5) \n//(pow(2.,1./2.)*.5*.5)).5/p22\n#define p224 (p222*.5)\n//incircleHexagonTotalHeight=\n//pow(3.,1./2.)= 97./56. =1.73205080756887729352744634150587236694280525381038062805580=\n#define p32 sqrt(3.)\n//\"inCircleHexagonTotalHeight\"=\"equilateralTriangle.y\"=\"hexagon.y\"=sixth.y\"=.5=\"trivial\" || \"hexagon.x\"=\"sixth.x\"=\"tricky\"=\n//pow(3.,1./2.)/2.= 97./112. =\"sixth.x\"=\"hexagon.x\"=sin(asin(1.)*2./3.)=sin(acos(-1.)/3.)=.866=\n#define p322 (p32/2.)\n//pow(3.,1./2.)/3.= 97./168. =.57735026919=\"useful for hexagonal scaling?\"\n#define p323 (p32/3.)\n//\n//\"goldenRatio\"=phi+1=Phi :where: 1/phi=phi-1 && 1/Phi=Phi-1\n//https://en.wikipedia.org/wiki/Golden_ratio\n#define phi (sqrt(5.)*.5-.5)\n//goldenRatio is great fun with fract(), good for hashes.\n#define Phi (sqrt(5.)*.5+.5)\n//\"silverRatio\"=  https://en.wikipedia.org/wiki/Silver_ratio\n#define Phis (sqrt(2.)+1)\n//\n//pi8=pi/4  pi2=pi/2 : pi=3.14 _: tau=pi*2 \n#define pi12 asin(.5)     /*twelvth rotation asin(.5)*6./acos(-1.)=1.*/\n#define pi4  asin( 0.)*.5 /*eight   rotation cos(pi4)==sin(pi4)*/\n#define pi2  acos( 0.)    /*quater  rotation=asin(1.)*/\n#define pi   acos(-1.)    /*half    rotation=3.14*/\n//#define tau pi*2.       /*full    rotation=6.28*/\n#define tau 6.283185307179586476925286766559\n//substituring [pi] by [tau/2] can make things simpler (and more precise with floats)\n/*\nend__.const.arithmetic\nstart.const.comm\n*/\n#define chank iChannel3\n//get .xyz of U\n#define texU() texture(iChannel0,vec2(U)+.5).xyz\n#define texp(p) texture(iChannel0,p+.5).xyz\n#define tex(a,b) texture(a,b))\n#define pushing .2\n#define once .5\n#define toggle .7\n#define key(a,b) (tex(chank,vec2((.5+a)/256.),b).x >0.)\n//bool keyAtoggle=key(128,toggle);\n//Note that you NEVER need to write in other shaders\n//and you ONLY need good use of memory and timeouts to simulate \"patience\".\n/*\nend__.const.comm\nend.const.comm\nstart.const.IO.Camera\n*/\n//shared address pointers to buffer camera data\n//#define store(p,v) if(all(equal(In,p+.5)))Out=v\n//reminder to debug below line is likely true:\n// iChannelResolution[0].xy != iChannelResolution[1].xy\n//do not assume \"==\" EVER to be true!\n#define load(P) texture(iChannel0, (P + 0.5) / iChannelResolution[0].xy, -100.0)\n//#define key(K)  step(0.5, texture( iChannel0, vec2(K, 1.0/6.0) ).x)\n\nconst vec2 MEMORY_BOUNDARY=vec2(4,3);\nconst vec2 POSITION=vec2(1,0);\nconst vec2 VMOUSE  =vec2(1,1);\nconst vec2 PMOUSE  =vec2(2,1);\nconst vec2 TARGET  =vec2(0,2);\nconst vec2 RESOLUTION=vec2(3,1);\n\n/*\nend__.const.IO.Camera\n//\n//ALL parts of the above text (that are used by the functions below)\n//...should be equal for all buffers (that load data from each other)\n//\nstart.camera\n*/\n//defining camera functions has high priority, to avoid an existentialist crisis.\n/*\nfor the record i am NOT happy with any camera that is not a quaternion camera...\n... and for thesake of simpicity and performance, \n... I am \"almost just fine\" with an eul rotation camera.\nThis totally has everything to to with my \n... constant failures on implementing a quaternion camera.\n*/\n#define camPos    vec3(0,4,-4)\n#define camTarget vec3(0)\n#define upDir     vec3(0,1,0)\n//return direction of ray, set by [p]PositionOnScreen and camera data.\n//[o]canPos [t]camTarget [u]upDirection (sets angle)\nvec3 CamCross(vec2 p,vec3 o,vec3 t,vec3 u){vec3\n d=normalize(t-o),r=normalize(cross(u,d)),\n Up=p.y*cross(d,r);r*=p.x*iResolution.x/iResolution.y;\nreturn normalize(((o+d+r+Up)*.86)-(camPos));}\n//shit cam uses too many cross() and normalize()\n\n#define r2s(r) mat2(sin(r+vec4(1,0,0,-1)*asin(1.)))\n//testable in https://www.shadertoy.com/view/MtKGWD\n\n//this sucks so much.\n//it takes an idiot to use euler for 3d rotation.\n//it takes a retard to not define .y as \"up\", in 2d and 3d.\n//CamEul() was made by a retard.\nvec3 CamEul(in vec2 p,vec2 m,out vec3 o){m.y=-m.y;\n float a=1./max(iResolution.x, iResolution.y);\n vec3 d=normalize(vec3((p-iResolution.xy*.5)*a,.5));\n mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n d =rotY*(rotX*d);\n return normalize(d);}\n/*\nend__.camera\nstart.common\n*/\n//iou, merge this down below arithmetic.differentiation...\n#define dd(p) dot(p,p)\n#define sat(a) clamp(a,0.,1.)\n//This lets you derive over up to 3 dimensions at once OR seperately, \n//...using very self-similar dual-function variants:\n//#define pow2d(a) d2(muld(a.x,a.x),muld(a,2.))\n/*\nend__.common\nstart.branchless\n*/\n//these branchless comparators compare [c] with [0.0] to return [a]==true or [b]==false;\n#define step2 step(c,0.)+step(0.,c)-1.)\n//above is based on   https://www.reddit.com/r/askmath/comments/6aag2g/simplifying_stepa00step00a/\n//(a> 0)?b:c\n#define greater(a,b,c)   mix(a,b,step(c,0.))\n//(a< 0)?b:c\n#define less(a,b,c)      mix(a,b,step(0.,c))\n//(a==0)?b:c\n#define equals(a,b,c)    mix(b,a,step2\n//(a!=0)?b:c\n#define unequal(a,b,c)   mix(a,b,step2\n//(a>=0)?b:c  \"unless   \"=not less   ==greater OR equal\n#define unless(a,b,c)    mix(b,a,step(0.,c))\n//(a<=0)?b:c  \"ungreater\"=not greater==less    OR equal\n#define ungreater(a,b,c) mix(b,a,step(c,0.))\n// https://www.shadertoy.com/view/XssfRf\n/*\nend__.branchless\nstart.text\n*/\n\n#define S(a) c+=char(p,a);p.x-=1.;\n#define _ p.x-=1.;\n#define _note  10\n#define _star  28\n#define _smily 29\n#define _exc   33\n#define _add   43\n#define _comma 44\n#define _sub   45 \n#define _dot   46\n#define _slash 47 \n#define _ddot 58\n#define _sc   59\n#define _less 60\n#define _eq   61\n#define _gr   62\n#define _qm   63\n#define _at   64\n#define _0 48\n#define _1 49\n#define _2 50\n#define _3 51\n#define _4 52\n#define _5 53\n#define _6 54\n#define _7 55\n#define _8 56\n#define _9 57\n#define _A 65\n#define _B 66\n#define _C 67\n#define _D 68\n#define _E 69\n#define _F 70\n#define _G 71\n#define _H 72\n#define _I 73\n#define _J 74\n#define _K 75\n#define _L 76\n#define _M 77\n#define _N 78\n#define _O 79\n#define _P 80\n#define _Q 81\n#define _R 82\n#define _S 83\n#define _T 84\n#define _U 85\n#define _V 86\n#define _W 87\n#define _X 88\n#define _Y 89\n#define _Z 90\n#define _a 97\n#define _b 98\n#define _c 99\n#define _d 100\n#define _e 101\n#define _f 102\n#define _g 103\n#define _h 104\n#define _i 105\n#define _j 106\n#define _k 107\n#define _l 108\n#define _m 109\n#define _n 110\n#define _o 111\n#define _p 112\n#define _q 113\n#define _r 114\n#define _s 115\n#define _t 116\n#define _u 117\n#define _v 118\n#define _w 119\n#define _x 120\n#define _y 121\n#define _z 122\n\nfloat char(v1 p,int c){return any(lessThan(vec4(p,1,1),vec4(0,0,p)))? \n 0.:texture(iChannel0,.0625*(p+vec2(c-c/16*16,15-c/16))).x;}\n//draw line segment from A to B\n//float drawSegment(v1 A,v1 B, float r){vec2 g=B-A,h=uv-A;\n// float d=length(h-g*clamp(dot(g,h)/dot(g,g),0.,1.));\n// return smoothstep(r, 0.5*r, d);}\n//display [f]fraction with [d]leadingZeros \nvoid SetTextPosition(out vec2 p,v0 x,v0 y){  //x=line, y=column\n //p=10.0*uv;\n p.x=p.x+17.-x;\n p.y=p.y-9.4+y;}\nfloat drawFract(inout vec2 p,int d,v0 f){float c=0.; \n f=fract(f)*10.;for(int i=1;i<60;i++){\n  c+=char(p,48+int(f));p.x+1.;d--;f=fract(f)*10.;if(d<=0||f==0.)break;\n }p.x+float(d);return c;}\nfloat drawFract(v1 p,int d){return drawFract(p,d,0.);}\n//draw [v]int with a minimum # of [m]glyphs\nfloat drawInt(inout vec2 p,int v,int m){float c=0.;if(v<0){v=-v; \n  if(m<1)m=1;else m--;_sub;}\n int f=v,d=1;for(int n=0;n<10;n++){f/=10;if(f==0)break;d++;}// get number of digits\n d=max(m,d);p.x-=float(d);\n for(int n=1;n<11;n++){p.x+=1.;c += char(p,48+(v-((v/=10)*10)));if(n>=d)break;} \n p.x-=float(d);return c;}\nfloat drawInt(v1 p,int v){return drawInt(p,v,1);}\n\n//display [v]float with [p]decimalPrecision and [m]maxDigits\nfloat drawFloat(inout vec2 p,v0 v,int q,int m){float c=0.;\n p.x-=float(m);\n if (v<0.){c=char(p,45);v=-v;}p.x-=1.; //write \"-\"\n c+=drawInt(p,int(v),1);    //write floor()                                           \n c+=char(p,46);p.x-=1.;      //write \".\"\n c+=drawFract(p,0,fract(v));//write fract() \n return c;}//shorter defaults:\nfloat drawFloat(inout vec2 p,v0 v)      {return drawFloat(p,v,2,5);} \nfloat drawFloat(inout vec2 p,v0 v,int q){return drawFloat(p,v,q,2);} \n//display stuffs:\nfloat WriteInteger(inout vec2 p,const in int v){float c=0.;\n c=drawInt(p,v);p.x-=1.;return c;}\nfloat WriteDate(inout vec2 p){float c=0.;\n c+=drawInt(p,int(iDate.x));    _sub;\n c+=drawInt(p,int(iDate.y +1.));_sub;\n c+=drawInt(p,int(iDate.z));return c;}\nfloat WriteTime(inout vec2 p){float c=0.;\n c+=drawInt(p,int(mod(iDate.w/3600.,24.)));  _ddot;\n c+=drawInt(p,int(mod(iDate.w/60.  ,60.)),2);_ddot;\n c+=drawInt(p,int(mod(iDate.w      ,60.)),2);return c;}\nfloat WriteFPS(inout vec2 p){float c=0.;//float fps=(1./iTimeDelta+.5);\n c+=drawFloat(p,iFrameRate);S(_f) S(_p) S(_s) \n return c;}//https://www.shadertoy.com/view/lsKGWV\nvec3 WriteMousePos(inout vec2 p,v0 t,v1 m){vec3 c=vec3(0);\n int digits=3;\n float r=iResolution.x/200.;\n //if(iMouse.z>0.)dotColor=mpColor;// print dot at mPos.xy \n float s=length(m-p)-r;\n //vColor+=mix(vec3(0),dotColor,(1.-clamp(s,0.,1.)));\n SetTextPosition(p,1.,t);// print first mouse value\n //drawColor = mxColor;// print mouse position\n if(t==7.){c+=drawFloat(p,m.x,6,3);p.x-=1.;c+=drawFloat(p,m.y,6,3);\n }else{    c+=drawInt(p,int(m.x)) ;p.x-=1.;c+=drawInt(p,int(m.y));return c;}}\n//\"show\"= [value to display]:\nconst float show=pi;//tsn(1.);//-.6e-4;//-0.00006;//-0.00000000000000006;//\n//const float small=0.;\nconst float small=0.;//exp2(-63.);//a small offset to show more decimals on smaller values.\n//display a value with up to 60 decimal points\nconst float show60=  show-small;\n//display a value with 4 decimals, rounded AFTER the 4th\nconst float show4 =  show-small;// -200.09906;\n//reasonable float precision\n//these values take float16 precision errors into account:\n//exp2(-126.0)== smallest positive 16 bit float exp2(-127.0)->0\nconst float showSmall=exp2(-126.);//planck length 16 bit float, scales exponentially.\n\nfloat textDemo(in vec2 p){float c=0.;\n SetTextPosition(p,1.,12.);\n c+=drawInt(p,123, 8);   \n c+=drawInt(p,-1234567890);// right now !!!\n _ c+=drawInt(p,0);                \n _ c+=drawInt(p,-1);                \n _ c+=drawFloat(p,-123.456);     // right now !!!\n SetTextPosition(p,1.,13.);\n _ c+=drawInt(p,-123, 8);   \n _ c+=drawInt(p,1234567890,11);\n _ c+=drawFloat(p,0.0,0,0);\n _ c+=drawFloat(p,1.0,0,0);\n _ c+=drawFloat(p,654.321);      // nearly right\n _ c+=drawFloat(p,999.9, 1);\n _ c+=drawFloat(p,pow(10., 3.),1);   \n _ c+=drawFloat(p,pow(10., 6.),1);   \n SetTextPosition(p,1.,14.);c+=drawFloat(p,showSmall,60);\n SetTextPosition(p,1.,15.);c+=drawFloat(p,show60,60);\n SetTextPosition(p,1.,16.);c+=drawFloat(p,show4+sign(show4)*.5*pow(10.,-4.),4);\n return c;}\n/*\nend__.text\nstart.solve.les\n*/\n\n//return ifb(a,b,c); is identical to if(a<0.){return b;}else{return c;} but branchless:\n#define ifb(a,b,c) (b+(c-b)*step(a,0.))\n//branchless code -> longer pipelines on newer hardware -> likely better performance.\n//branchless code -> +1add +1mult, even slower on older hardware.\n//branchless code -> b & c are both calculated and substracted.\n//... this can cause extra calculations and more rounding errors. as only one difference of b and c matters.\n\n//a lot of things solve efficiently with inverse(m) of matrix [m].\n//m*inverse(m)=mat3(1)=mat2(1,0,0,0,1,0,0,0,1);\n//if(determinant(m)==0)matrix is its own inverse (matrix changes nothing);\n//calculaitng an inverse is tricky in higher dimensions.\n//due to division of: inverse(m)==adjugate(m)/determinant(m)\n//... we seperate adjugate(m) and determinant(m) for higher precision.\n\n//in mat2 this is simple:\n//[mat2 determinant() in 2 other types]=det()=determinant()\nfloat det(mat2 a){return determinant(a);}\nfloat det(mat3 a){return determinant(a);}//shorthand avoids reserved namespace\nfloat det(v1 a,v1 b){return det(mat2(a,b));}//return a.x*b.y-b.x*a.y;)\nfloat det(v0 a[2],v0 b[2]){return det(mat2(a[0],a[1],b[0],b[1]));}//return a[0]*b[1]-b[0]*a[1];)\nfloat det(v0 a[3],v0 b[3],v0 c[3]){return det(mat3(a[0],a[1],a[2],b[0],b[1],b[2],c[0],c[1],c[2]));}\n\n//return inverse of m, multiplied by its determinant(m)\nmat2 adjugate(mat2 m){vec4 n=vec4(m);return mat2(n.w,-n.yz,n.a);}\n //return mat2(m[1][1],-m[1][0],-m[0][1],m[0][0]);\n//https://www.mathsisfun.com/algebra/matrix-inverse.html\n\n#define skipli for(int i=0;i<e;i++){r[i+int(step(s-float(i),0.))]=a[i];}return r;}\n#define skipl2 a[3],v0 s){int e=a.length()-1\n#define skipl3 a[4],v0 s){int e=a.length()-1\n//mat3 adjugate gets trickier:\n//return sublist of a, without entry number#[skip]\nint  [2] lSkipI2(int skipl2,      r[2];skipli\nfloat[2] lSkipF2(v0  skipl2;float r[2];skipli\nint  [3] lSkipI3(int skipl3,      r[3];skipli\nfloat[3] lSkipF3(v0  skipl3;float r[3];skipli\nmat3 adjugate(mat3 m){mat3 r=mat3(0);\n for(int i=0;i<4;i++){for (int j=0;j<4;i++){//[s=] is similar to my sgn() function\n   float s=-2.*fract((float(i+j)*.5));//s=sign of checkerboardMatrix at m[i][j]\n// https://www.mathsisfun.com/algebra/matrix-inverse-minors-cofactors-adjugate.html\n   int co[3]=int[3](0,1,2),c2[2]=lSkipI2(co,float(i)),nullth=c2[0],first =c2[1];\n   //above calculates that .y parameter are NOT skipped.\n   //a is the LEFTMOST sub-column //b is the RIGHTMOST sub-column\n   float a[2]=lSkipF2(float[3](m[0][nullth],m[1][nullth],m[2][nullth]),float(j));\n   float b[2]=lSkipF2(float[3](m[0][first],m[1][first],m[2][first]),float(j));\n   r[i][j]=s*det(a,b);//det(aa,bb)==entry[i][j] of \"matrix of minors\"\n }}return transpose(r);}\n//adjugate functions are more likely full of typos than not.\nmat4 adjugate(mat4 m){mat4 r=mat4(0);\n for(int i=0;i<5;i++){for (int j=0;j<5;i++){\n   float s=-2.*fract((float(i+j)*.5));\n   int co[4]=int[4](0,1,2,3),c2[3]=lSkipI3(co,float(i)),nullth=c2[0],first =c2[1],second=c2[2];\n   //above calculates that .y parameter are NOT skipped.\n   float a[3]=lSkipF3(float[4](m[0][nullth],m[1][nullth],m[2][nullth],m[3][nullth]),float(j));\n   float b[3]=lSkipF3(float[4](m[0][first ],m[1][first ],m[2][first ],m[3][first ]),float(j));\n   float c[3]=lSkipF3(float[4](m[0][second],m[1][second],m[2][second],m[3][second]),float(j));\n   r[i][j]=s*det(a,b,c);}}return transpose(r);}\n\n//return vec3(a,b,c) that makes all input equations true.\n//p contains \"solutions\", one side of the equation\n//x,y,z store factors on the other side of the equations:\n//1=2*a+3*b+4*c -> p.x=1; a=vec3(2,3,4)\n//5=6*a+7*b+8*c -> p.y=5; b=vec3(6,7,8)\n#define sr if(determinant(m)==0.)return p;return inverse(m)*p;}\nvec2 solve(v1 p,v1 x,v1 y){mat2 m=transpose(mat2(x,y));sr\nvec3 solve(v2 p,v2 x,v2 y,v2 z){mat3 m=transpose(mat3(x,y,z));sr\nvec4 solve(v3 p,v3 x,v3 y,v3 z,v3 w){mat4 m=transpose(mat4(x,y,z,w));sr\n//opengl goes ColumnsBeforeLines: check (determinant(m)!=0) before solvem() \n#define solvem(p,m) (inverse(m)*p)\n//https://www.mathsisfun.com/algebra/systems-linear-equations-matrices.html\n\n    \n//IOU gaussian Elimination\nmat2 GaussianElimination(mat2 m){return mat2(0);}\nmat3 GaussianElimination(mat3 m){return mat3(0);}\nmat4 GaussianElimination(mat4 m){return mat4(0);}\n\n/*\nend__.solve.les\nstart.solve.root\n*/\n//i owe you, root solving.\n/*\nend__.solve.root\nstart.differentiation\n*/\n#define pow2d(a) muld(a,a)\n//above pow2() is very special and simple derivative arithmetic \n//... that should tell you what is going on with all the other \n//... dual number arithmetic functions below.\n//operations with only 1 input parameter are the simplest.\n\n//special case of component wise multiplication, special because a.x==1:\nd  cmd(d a,v0 b){return d (a.x,a.d*b);}\nd1 cmd(d a,v1 b){return d1(a.x,a.d*b);}\nd2 cmd(d a,v2 b){return d2(a.x,a.d*b);}\n//#define rmd {return cmd\nd  absd(v0 a){return   d(abs (a  ),sign(a  ));}\nd  absd(d  a){return cmd(absd(a.x),a.d);}//d (abs(a.x),sign(a.x)*a.d);}\nd1 absd(d1 a){return cmd(absd(a.x),a.d);}//d1(abs(a.x),sign(a.x)*a.d);}\nd2 absd(d2 a){return cmd(absd(a.x),a.d);}//d2(abs(a.x),sign(a.x)*a.d);}\n\nd  sind(v0 a){return d (sin(a  ),cos(a  ));}\nd  sind(d  a){return d (sin(a.x),cos(a.x)*a.d);}\nd1 sind(d1 a){return d1(sin(a.x),cos(a.x)*a.d);}\nd2 sind(d2 a){return d2(sin(a.x),cos(a.x)*a.d);}\nd  cosd(v0 a){return d (cos(a  ),-sin(a  ));}\nd  cosd(d  a){return d (cos(a.x),-sin(a.x)*a.d);}\nd1 cosd(d1 a){return d1(cos(a.x),-sin(a.x)*a.d);}\nd2 cosd(d2 a){return d2(cos(a.x),-sin(a.x)*a.d);}\nd  logd(d  a){return d (log(a.x),a.d/a.x);}\nd1 logd(d1 a){return d1(log(a.x),a.d/a.x);}\nd2 logd(d2 a){return d2(log(a.x),a.d/a.x);}\nd  expd(d  a){v0 x=exp(a.x);return d (x,x*a.d);}\nd1 expd(d1 a){v0 x=exp(a.x);return d1(x,x*a.d);}\nd2 expd(d2 a){v0 x=exp(a.x);return d2(x,x*a.d);}\n//sqrt() and divisions require a worksave reciprocal operator:\nv0 rec(float a){return (a==0.)?a:1./a;}//return [1/a] , work safe\n//single parameter operations are MUCH simpler here:\nd  sqrtd(d  a){v0 q=sqrt(a.x);return d (q,.5*rec(q)*a.d);}\nd1 sqrtd(d1 a){v0 q=sqrt(a.x);return d1(q,.5*rec(q)*a.d);}\nd2 sqrtd(d2 a){v0 q=sqrt(a.x);return d2(q,.5*rec(q)*a.d);}\n//        pow (x,y) exp (     log (x)*y )//wait till we define muld()\n//#define powd(x,y) expd(muld(logd(x),x))//wait till we define muld()\n\n//i am not too sure about my implementation on fractd();\n//the hell, just use modd() instead, modd() has VERY nice first derivatives!\n//reminder that the fract function's first derivative has a \"kick\" on (mod(a,1)==0.0)\nv0 djum(v0 a){return mix(a,-1.,step(fract(a),0.)*step(0.,fract(a)));}\nv1 djum(v1 a){return v1(djum(a.x),djum(a.y));}\nv2 djum(v2 a){return v2(djum(a.x),djum(a.y),djum(a.z));}\n//i should definitely define this by fract, and not by floor.\n//because fm-modulation taught me that i need fract() a lot more than floor()\nd2 fractd(d2 a){return d2(floor(a.x),djum(a.d));}\nd1 fractd(d1 a){return d1(floor(a.x),djum(a.d));}\nd  fractd(d  a){return d (floor(a.x),djum(a.d));}\n//very slightly lower precision? rarely relevant. fract() has great precision on float!\n#define floord(a) subd(a,fractd(a))\n\n//derivatives of functions with 2 input parameters are trickier:\n//  https://en.wikipedia.org/wiki/Multivariable_calculus\n//There are exponential many permutations of modd() mixd() mind()\n\n//modd ideally should be replaced by fractd(), but that adds 1dvd() and 1muld()\n//... but chain rule division (reciprocal product rule) on a custom type is so bad.\n//... that for derivative arithmetic, modd(a,b) outperforms muld(fractd(divd(a,b)),b)\n//v4 modd(v4 a,v4 b){return v4(mod(a.x,b.x),mod(a.yzw,1.));}\n//v4 modd(v4 a,v1 b){return v4(mod(a.x,b  ),mod(a.yzw,1.));}\n//v4 modd(v1 a,v4 b){return v4(mod(a  ,b.x),0,0,0        );}\n//#define modo(a,b) fract(a/b)*b /*what mod(a,b) actually does*/\n#define may fract(a.d));}\n#define maz mod(a.x,b),may\n#define mab mod(a.x,b.x)\nd2 modd(d2 a,v0 b){return d2(maz\nd1 modd(d1 a,v0 b){return d1(maz\nd  modd(d  a,v0 b){return d (maz\nd  modd(d  a,d  b){return d (mab,may\nd2 modd(d2 a,d  b){return d2(mab,may\nd2 modd(d2 a,d2 b){return d2(mab,may\nd2 modd(d2 a,d1 b){return d2(mab,may\nd2 modd(d  a,d2 b){return d2(mab,v2(0));}\nd2 modd(d1 a,d2 b){return d2(mab,v2(0));}\nd2 modd(v0 a,d2 b){return d2(mod(a,b.x),v2(0));}\nd1 modd(v0 a,d1 b){return d1(mod(a,b.x),v1(0));}\nd  modd(v0 a,d  b){return d (mod(a,b.x),   0.);}\n//mmixd is subroutine for mind(), which is used as branch. mix(n1,n2,step(m,0.))\nv0 mixd(v0 a,v0 b,v0 c){return mix(a,b,c);}\nv1 mixd(v1 a,v1 b,v0 c){return mix(a,b,c);}\nv2 mixd(v2 a,v2 b,v0 c){return mix(a,b,c);}\nv3 mixd(v3 a,v3 b,v0 c){return mix(a,b,c);}\n//v1 mixd(v0 a,v1 b,v0 c){return mix(v0tv1(a),b,c);} oh my permutations...\nd  mixd(d  a,d  b,v0 c){return d (mix(a.x,b.x,c),mix(a.d,b.d,c));}\nd1 mixd(d1 a,d1 b,v0 c){return d1(mix(a.x,b.x,c),mix(a.d,b.d,c));}\nd2 mixd(d2 a,d2 b,v0 c){return d2(mix(a.x,b.x,c),mix(a.d,b.d,c));}\nd1 mixd(d  a,d1 b,v0 c){return mixd(d0td1(a),b,c);}\nd2 mixd(d  a,d2 b,v0 c){return mixd(d0td2(a),b,c);}\nd2 mixd(d1 a,d2 b,v0 c){return mixd(d1td2(a),b,c);}\nd1 mixd(d1 a,d  b,v0 c){return mixd(a,d0td1(b),c);}\nd2 mixd(d2 a,d1 b,v0 c){return mixd(a,d1td2(b),c);}\nd2 mixd(d2 a,d  b,v0 c){return mixd(a,d0td2(b),c);}\n//the return of Fortran's \"XIF(m,n1,n2)===(m==0)?n1:n2===mix(n1,n2,step(m,0.)*step(0.,m))\n//ecept it compares if (a.x>b.x)\n#define min1 {return mixd(b,a,step(a.x,b.x));}\n#define min3 {return mind(b,a);}\n//I define mind() and -maxd(-,-) instead of maxd() and -mind(-,-)\n//because min() is far more common than max(), for z-buffering.\nd2 mind(d2 a,d2 b)min1\nd2 mind(d1 a,d2 b)min1\nd2 mind(d  a,d2 b)min1\nd2 mind(d2 a,d1 b)min1\nd2 mind(d2 a,d  b)min1\nd1 mind(d1 a,d1 b)min1\nd1 mind(d  a,d1 b)min1\nd  mind(d  a,d  b)min1\nd2 mind(v0 a,d2 b){return mixd(v0td2(a),b,step(b.x,a));}\nd2 mind(d2 a,v0 b){return mixd(v0td2(b),a,step(a.x,b));}\nd1 mind(v0 a,d1 b){return mind(v0td1(a),b);}\nd  mind(v0 a,d  b){return mind(v0td0(a),b);}\nd  mind(v0 a,v0 b){return v0td0(min(a,b));}\nd1 mind(d1 a,d  b)min3\nd1 mind(d1 a,v0 b)min3\nd  mind(d  a,v0 b)min3\n//negation identity: max(a,b)=-min(-a,-b), requires struct negation\nd2 negd(d2 a){return d2(-a.x,-a.d);}\nd1 negd(d1 a){return d1(-a.x,-a.d);}\nd  negd(d  a){return d (-a.x,-a.d);}\nv0 negd(v0 a){return -a;}\n#define maxd(a,b) negd(mind(negd(a),negd(b)))\n//3-domain matrix tripples:\nDAm2 maxdm(DAm2 a,v2 p){\n return DAm2(maxd(a.x,p.x),maxd(a.y,p.y),maxd(a.z,p.z));}\nDAm2 mindm(DAm2 a,v2 p){\n return DAm2(mind(a.x,p.x),mind(a.y,p.y),mind(a.z,p.z));}\nDAm2 maxdm(DAm2 a,v0 p){return maxdm(a,v2(p));}\nDAm2 mindm(DAm2 a,v0 p){return mindm(a,v2(p));}//needed for fast clamping\nd2 maxdm(d2 a,d2 b,d2 c){return maxd(maxd(a,b),c);}\nd2 maxdm(DAm2 a){return maxdm(a.x,a.y,a.z);}\n\n/*\nv4 subd(v4 a,v4 b){return a-b;}\nv4 subd(v4 a,v1 b){return v4(a.x-b  , a.yzw);}\nv4 subd(v1 a,v4 b){return v4(a  -b.x,-b.yzw);}\nv4 addd(v4 a,v4 b){return a+b;}\nv4 addd(v4 a,v1 b){return subd(a,-b);}//addition as invrse substraction\nv4 addd(v1 a,v4 b){return subd(a,-b);}\n*/\n//substraction is simple, because \"differentiation equals integration\"\n//  https://en.wikipedia.org/wiki/Cauchy_integral_formula\n//...making the implementation of the chain rule much simpler for:\n//  https://en.wikipedia.org/wiki/Translation_(geometry)\nd2 subd(d2 a,d2 b){return d2(a.x-b.x,a.d-b.d);}//3d translation\nd1 subd(d1 a,d1 b){return d1(a.x-b.x,a.d-b.d);}//2d translation\nd  subd(d  a,d  b){return d (a.x-b.x,a.d-b.d);}//1d translation\nd2 subd(d2 a,v0 b){return d2(a.x-b  ,a.d);}\nd2 subd(d2 a,d  b){return d2(a.x-b.x,a.d);}\nd2 subd(d2 a,d1 b){return d2(a.x-b.x,a.d);}\nd1 subd(d1 a,v0 b){return d1(a.x-b  ,a.d);}\nd1 subd(d1 a,d  b){return d1(a.x-b.x,a.d);}\nd  subd(d  a,v0 b){return d (a.x-b  ,a.d);}                           \nd2 subd(v0 a,d2 b){return d2(a  -b.x,-b.d);}\nd2 subd(d  a,d2 b){return d2(a.x-b.x,-b.d);}\nd2 subd(v3 a,d2 b){return d2(a.x-b.x,-b.d);}\nd1 subd(v0 a,d1 b){return d1(a  -b.x,-b.d);}\nd1 subd(d  a,d1 b){return d1(a.x-b.x,-b.d);}\nd  subd(v0 a,d  b){return d (a  -b.x,-b.d);}\n//glide-translations along multiple domains:\nDAm2 subd(DAm2 p,v2 s){return DAm2(subd(p.x,s.x),\n                                   subd(p.y,s.y),\n                                   subd(p.z,s.z));}\nDAm1 subd(DAm1 p,v1 s){return DAm1(subd(p.x,s.x),\n                                   subd(p.y,s.y));}\nDAm0 subd(DAm0 p,v0 s){return DAm0(subd(p.x,s));}\n//subd(absd(p),s) equals a translation away from the origin by [s]\n//... AND mirroring at origin, via abs() \n//... so it it clamps a an implicit surface to a limited \"thickness\"\n//(in 3 domains),also translating its first derivatives.\nd2 subdabsd(d2 p,float s){return subd(absd(p),s);}\nd1 subdabsd(d1 p,float s){return subd(absd(p),s);}\nd  subdabsd(d  p,float s){return subd(absd(p),s);}\nDAm2 subdabsd(DAm2 p,v2 s){return DAm2(subdabsd(p.x,s.x),\n                                       subdabsd(p.y,s.y),\n                                       subdabsd(p.z,s.z));}\nDAm1 subdabsd(DAm1 p,v1 s){return DAm1(subdabsd(p.x,s.x),\n                                       subdabsd(p.y,s.y));}\nDAm0 subdabsd(DAm0 p,v0 s){return DAm0(subdabsd(p.x,s));}\n//addition is negated substraction.\n#define addd(a,b) subd(a,negd(b))\n#define adddabsd(a,b) subdabsd(a,negd(b))\n\n//automatic_differentiation_multiplication applies the product rule within the chain rule\n//  https://en.wikipedia.org/wiki/Product_rule\n/*\nv4 muld(v4 a,v4 b){return v4(a.x*b.x,a.yzw*b.w+a.x*b.yzw);}\nv4 muld(v4 a,v1 b){return a*b;}\nv4 muld(v1 a,v4 b){return a*b;}\nv4 divd(v4 a,v4 b){return v4(a.x/b.x,(a.yzw*b.x-a.x*b.yzw)/(b.x*b.x));}\nv4 divd(v4 a,v1 b){return a/b;}\nv4 divd(v1 a,v4 b){return v4(a/b.x,(-a*b.yzw)/(b.x*b.x));} \n*/\n#define atb a.x*b,a.d*b);}\n#define mdb b){return muld(b,a);}\nd2 muld(d2 a,v0 b){return d2(atb\nd1 muld(d1 a,v0 b){return d1(atb\nd  muld(d  a,v0 b){return d (atb\nd2 muld(v0 a,d2 mdb //mdb is the commutative inverse of the 3 above ones\nd1 muld(v0 a,d1 mdb\nd  muld(v0 a,d  mdb//scalar multiplication is tautological product_rule.\nd2 muld(d2 a,d2 b){return d2(a.x*b.x,a.d*b.x+a.x*b.d);}\nd1 muld(d1 a,d1 b){return d1(a.x*b.x,a.d*b.x+a.x*b.d);}\nd  muld(d  a,d  b){return d (a.x*b.x,a.d*b.x+a.x*b.d);}\nd1 muld(d  a,d1 b){return d1(a.x*b.x,a.d*b.x+a.x*b.d);}\nd1 muld(d1 a,d  b){return d1(a.x*b.x,a.d*b.x+a.x*b.d);}\n//d2 muld(d2 a,d1 b){return d2(a.x*b.x,a.d*b.x+a.x*b.d);}//nonsense?\nd2 muld(d2 a,d  b){return d2(a.x*b.x,a.d*b.x+a.x*b.d);}\n//d2 muld(d1 a,d2 b){return d2(a.x*b.x,a.d*b.x+a.x*b.d);}//nonsense?\nd2 muld(d  a,d2 b){return d2(a.x*b.x,a.d*b.x+a.x*b.d);}\nDAm2 muld(DAm2 p,v2 s){return DAm2(muld(p.x,s.x),\n                                         muld(p.y,s.y),\n                                         muld(p.z,s.z));}\nDAm1 muld(DAm1 p,v1  s){return DAm1(muld(p.x,s.x),\n                                         muld(p.y,s.y));}\nDAm0 muld(DAm0 p,v0 s){return DAm0(muld(p.x,s));}\n//reciprocal derivatives are most confusing.\n#define atc a.x/b,a.d/b);}\nd2 divd(d2 a,v0 b){return d2(atc\nd1 divd(d1 a,v0 b){return d1(atc\nd  divd(d  a,v0 b){return d (atc//inverse scalar multiplication is a tautolotgy.\n#define bxx /(b.x*b.x));}\nd2 divd(v0 a,d2 b){return d2(a  /b.x,(-a  *b.d)bxx\nd2 divd(d  a,d2 b){return d2(a.x/b.x,(-a.x*b.d)bxx\nd2 divd(d1 a,d2 b){return d2(a.x/b.x,(-a.x*b.d)bxx\nd2 divd(d2 a,d2 b){return d2(a.x/b.x,(a.d*b.x-a.x*b.d)bxx\n//d2 divd(d2 a,d1 b){return d2(a.x/b.x,(a.d*b.x-a.x*b.d)bxx//nonsense?\n//d2 divd(d2 a,d  b){return d2(a.x/b.x,(a.d*b.x-a.x*b.d)bxx//nonsense?\n//All exponential functions utilize their Base_E_identity:\n//...which is still not efficient, but comes doen to O(exp(n*log(n)))\n//      pow (x,y)==exp(     log (x)*y )//baseE exponential and logarythmic functions.\n#define powd(x,y) expd(muld(logd(x),x))\n\n//It gets trickier with functions that take up to 3 parameters:, applying the\n//  https://en.wikipedia.org/wiki/Triple_product_rule\n//Euclidean distance (pythagorean theorem) with first derivatives:\n#define v0q v0 q=length(v1(x.x,y.x))\n#define ll2 q,(x.d*x.x+y.d*y.x)*rec(q));}\nd  lengthd(d  x,d  y){v0q;return d (ll2\nd1 lengthd(d1 x,d1 y){v0q;return d1(ll2\nd2 lengthd(d2 x,d2 y){v0q;return d2(ll2\nd  lengthd(v0 u){return absd(u);}//1*1 domains, (distance on a line)\nd1 lengthd(v1 u){return lengthd(v0td1(u.x),v0td1(u.y));}\nd1 lengthd2(DAm1 u){return lengthd(u.x,u.y);}//2*2domains (distance on a plane in 2d)\nd2 lengthd2(DAm2 u){return lengthd(u.x,u.y);}//2*3domains (distance on a plane in 3d)\n//above is planar length 2 input parameters. below is 3d length.\nd2 lengthd(d2 x,d2 y,d2 z){float q=length(v2(x.x,y.x,z.x));\n return d2(q,(x.d*x.x+y.d*y.x+z.d*z.x)*rec(q));}\nd2 lengthd(DAm2 u){return lengthd(u.x,u.y,u.z);}//3*3domains (3d euclidean distance)\nd2 lengthd(v2 u){return lengthd(v0td2(u.x),v0td2(u.y),v0td2(u.z));}\n//the utility of a length() function is clear.\n//atan2() is a bit tricky, thankfully commonly only defined for vec2.\nv0 atand(v0 a){return atan(a);}//atan(x/y) has limited range and is non branching.\n//wrapping for namespace sake, for automatic differentiation:\n//first defivative of f(x)=atan(x) is f(x)=1/x*x+1\nd2 atand(d2 a){\n    float b=atan(a.x);\n    d2 e=pow2d(a);\n    e=addd(e,1.);\n    e=divd(1.,e);\n    //e=divd(1.,addd(pow2d(a),1.));\n    return d2(b,e.d);}\n\n//todo, copy\n//https://www.shadertoy.com/view/MdsBRX\n                                    \n//expliicit atan2() //https://en.wikipedia.org/wiki/Atan2\nv0 atand(v0 x,v0 y){//return atan(y,x);//2 branches, goes full circle.\n if(x >0.)return atan(y/x);\n if(y >0.)return  pi*.5-atan(x/y);\n if(0.>y )return -pi*.5-atan(x/y);\n if(0.>x )return  pi   +atan(y/x);\n return 0.;\n}\nv0 atand(v1 a){return atand(a.y,a.x);}\n//but that means it only cares for 2 domains?\nd1 atand(d1 a,d1 b){return a;\n}\n\n//and then it gets more and more tricky: \n// Chain rule Derivative of dot() appears tricky: this should work, untested:\nd2 dotd(DAm2 a, DAm2 b){d2 t0=muld(a.x,b.x),t1=muld(a.y,b.y),t2=muld(a.z,b.z); \n return addd(addd(t0,t1),t2);}\n\n//using the above, we define distance functions \n//...that automatically also return the gradient at [p].\n//the gradient is multiple first derivatives along multiple domains\n//... like Dfdx() and Dfdy(), and we also have Dfdz()...\n//... except much cheaper, due to many things canceling out each other.\n//This makes surfaces that are C0-discontinuous, like y=fract(x), \n//...at least have their first derivate calculated continuously,\n//... as long as they are C1-continuous,\n//which can be useful for raymarching:\n                 \n/*\nend__.differentiation\nstart.transform.hash\n*/\n//---------------- \"h[*]\"\n\n//hashes are better when they are pseudoRandom, with an unpredictable seed-stream.\n\n//hashes take the namespace \"h[*]\"\n//hashes project one set (of numbers) to another (smaller) set (of numbers).\n//a more constant input part of a hash is called \"seed\". \n//seeds can be constant or streamed video or audio, to include change over time.\n//\n//hashes include sin() or fract() as final operation and approximate irrational \n//...numbers within that to more evenly distribute the result of any non-seed-input.\n//Simplest most evenly distributing most predictable hash, plants love it:\n#define dhPhi(seed,a) (fract(seed*a*Phi))\nfloat hPhi(v0 a){return dhPhi(1.,a);}\n//above is used by plants, below is better for type int due to smaller intDivisions\n#define dhphi(seed,a) (a*fract(seed*phi))\nfloat hphi(v0 a){return dhPhi(1.,a);}\n//But you want the results of consecutive hashes to be good pseudo-randoms-values.\n//\n//A hash reduces information, if only by rounding.\n//A hashes result can be spread over more output dimensions than its input dimensions.\n//this does not create information out of thin air, but can give the illusion of that.\n\n//return float range [0..1] from uint[n] : by Hugo Elias:\nfloat hash(uint n){n=(n<<13U)^n;n=n*(n*n*15731U+789221U)+1376312589U;\n //return 1.-float(n&0x7fffffffU)/float(0x7fffffff);}//older approach from https://iquilezles.org/articles/sfrand\n return uintBitsToFloat((n>>9U)|0x3f800000U)-1.0;}\n\n/*\nend__.transform.hash\nstart.transform.hull\n*/\n//smoothstep like curves\nfloat s0(float a,float t){return step(fract(t),a);}//step\nfloat s1(float a){return sat(a);}//diagonal\nfloat ss(float a,float b, float c){return smoothstep(c,b,a);}//smoothsep\nfloat ss(float a){return ss(a,0.,1.);}//smoothsep\nfloat co(float a){return cos(sat(a)*pi)*-.5+.5;}//cos(), VERY much like ss, but better derivatives!\n\n//i find no way to have smin make sense in this context.\nfloat smin0(float a,float b,float k){//1.-fract(k)\n float h=sat(.5+.5*(b-a)/k);return mix(b,a,h)-k*h*(1.-h);}\nfloat smin0(float k){return smin0(0.,1.,k);}\n\n//todo, tangential wiring stuffs.\n//2 parameters set 2 circle radii that sum up to <=1. and a tangent is spun between the 2.\n\n#define ac(n) if((a&n)>0)\n#define arrLen 16\nfloat array1(vec2 u,int a){//binary branching tree:\n float t=iTime;\n    ac(8){ac(4){ac(2){ac(1){return s0(u.x,t);\n                      }else{return s0(u.x,t);\n               }}else{ac(1){return s0(u.x,t);\n                      }else{return s0(u.x,t);\n        }}}else{ac(2){ac(1){return s0(u.x,t);\n                      }else{return s0(u.x,t);\n               }}else{ac(1){return s0(u.x,t);\n                      }else{return s0(u.x,t);\n }}}}else{ac(4){ac(2){ac(1){return s0(u.x,t);\n                      }else{return s0(u.x,t);\n               }}else{ac(1){return 5.;\n                      }else{return 4.;\n        }}}else{ac(2){ac(1){return s1(u.x);\n                      }else{return co(u.x);\n               }}else{ac(1){return ss(u.x);//smootStep\n                      }else{return s0(u.x,t);\n }}}}\n return 0.;}\n\nfloat array1mix(vec2 u,float a){\n    int b=int(floor(a));\n int c=(b+1)%arrLen;\n return mix(array1(u,b),array1(u,c),fract(a));}\n/*\n vec3 r=vec3(0);\n r.x=array1mix(u,iTime)-u.y;\n r.x=ss(.1,-.1,abs(r.x));\n*/\n/*\nend__.transform.hull\nstart.transform.gradient\n*/\nfloat vmax(v1 p){return max(p.x,p.y);}\nfloat vmax(v2 p){return max(vmax(p.xy),p.z);}\nfloat vmax(v3 p){return max(vmax(p.xy),vmax(p.zw));}\nfloat vmin(v1 p){return min(p.x,p.y);}\nfloat vmin(v2 p){return min(vmin(p.xy),p.z);}\nfloat vmin(v3 p){return min(vmin(p.xy),vmin(p.zw));}\nfloat vsum(v1 p){return p.x+p.y;}\nfloat vsum(v2 p){return vsum(p.xy)+p.z;}\nfloat vsum(v3 p){return vsum(p.xy)+vsum(p.zw);}\nvec2  vpow(v1 a,v0 n){return pow(a,vec2(n));}\nvec3  vpow(v2 a,v0 n){return pow(a,vec3(n));}\nvec4  vpow(v3 a,v0 n){return pow(a,vec4(n));}\n\n#define saturate(x) (clamp(x,0.,1.))\n//IUO all the nice 3d gradients.\n\n//return fully saturated hue.rgb of [h]; 0=1=red, 1/3=green, 2/3=blue \nvec3 hue(v0 h){return clamp(abs(mod(h*6.+vec3(0,4,2),6.)-3.)-1.,0.,1.);}\n//return color.rgb of c.xyz .x=hue .y=saturation .z=variance       \nvec3 hsv2rgb(v2 c){return c.z*mix(vec3(1),hue(c.x),c.y);}\n//return color.rgb of c.xyz .x=hue .y=saturation .z=lightness\nvec3 hsl2rgb(v2 c){return c.z+c.y*(hue(c.x)-.5)*(1.-abs(2.*c.z-1.));}\n//https://www.shadertoy.com/view/lsS3Wc\nvec3 rgb2hsv(v2 c){vec4 k=vec4(0,-1,2,-3)/3.,\n p=mix(vec4(c.zy,k.wz),vec4(c.yz, k.xy),(c.z<c.y)?1.:0.),\n q=mix(vec4(p.xyw,c.x),vec4(c.x, p.yzx),(p.x<c.x)?1.:0.);\n float d=q.x-min(q.w,q.y);\n return vec3(abs(q.z+(q.w- q.y)/(6.*d+eps)),d/(q.x+eps),q.x);}\nvec3 rgb2hsl(v2 c){float n=vmin(c),m=vmax(c);\n vec3 a=step(c.grr,c.rgb)*step(c.bbg,c.rgb),\n h=a*(vec3(0,2,4)+(c.gbr-c.brg)/(m-n + eps))/6.;\n return vec3(fract(1.+vsum(h)),//H\n    (m-n)/(1.-abs(n+m-1.)+eps),//S\n   (n+m)*.5 );}                //L\n//return blackbodyColor of temperature in kelvin (without HDR intensity)\n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\nvec3 blackbody(v0 Temp){\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) return col*Temp/1000.;\n   \treturn col;}\n//to be replaced by\nvec3 blackbody2(v0 k){float p=pow(k,-3./2.),\n g=0.;//green is approximated in 2 ways, depending on k.\n if(k>6500.)g=138e3*p+.721;else g=.39*log(k)-2.45;\n vec3 c=saturate(vec3(22e4*p+.58,g,.76*log(k)-5.68));\n //if(k<1e3)return c*k*.001;//extra black.\n return c;}\n\n//returns most unique color (hue) from any n=whole signed value.\nvec3 nThColor(float n){\n float h=hphi(n);\n return hue(h);}\n/*\nend__.transform.gradient\nstart.transform.noise\n*/\n//IOU - pseudoRandom stuffs.\nfloat noise( in vec2 x ){\n    ivec2 p = ivec2(floor(x));\n    vec2 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tivec2 uv = p.xy;\n\tfloat rgA=texelFetch(iChannel2,(uv+ivec2(0,0))&255, 0 ).x;\n    float rgB=texelFetch(iChannel2,(uv+ivec2(1,0))&255, 0 ).x;\n    float rgC=texelFetch(iChannel2,(uv+ivec2(0,1))&255, 0 ).x;\n    float rgD=texelFetch(iChannel2,(uv+ivec2(1,1))&255, 0 ).x;\n    return mix(mix(rgA,rgB,f.x),mix(rgC,rgD,f.x),f.y);}\nfloat noise(in vec3 x ){\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel1, (uv+0.5)/256.0, 0.0).yx;\n\treturn mix( rg.x, rg.y, f.z );}\n                              \n//return [n]iterations of fractall brownian motion.\nfloat fbm(in vec3 p,float n){\n float r=0.;\n for(float i=0.;i<1024.;i=i*2.){\n  r+=noise(p*i)/i;\n  if(n<0.)break;\n  n--;\n }return n;}\n\n//\"noise\" comes down to being a smoothenedHash==HashesNthDerivative\n\n//simple fast smooth noise, uses texture2D() as seed.\n/*float nC(in vec3 x){vec3 p=floor(x),f=fract(x);f=f*f*(3.-2.*f);\t\n vec2 rg=texture2D(iChannel0,((p.xy+vec2(37.,17.)*p.z)+f.xy+.5)/256.,-100.).yx;\n return mix(rg.x,rg.y,f.z);}/**/\n\n/*\nvec2 M;\nvec4 noise(v1 u){u=mod(u,M.x)+M.y; // mod() avoids grid glitch\n u-=.5;return vec4(hash(uint(u.x+iResolution.x*u.y)));}\n\n\n#define V(i,j)  noise(u+vec2(i,j))\nvec4 bluenoise(v1 u){//U=floor(U/8.); \n vec4 n=8./9.*noise(u)-1./9.*(V(-1,-1)+V(0,-1)+V(1,-1)+V(-1,0)+V(1,0)+V(-1,1)+V(0,1)+V(1,1));  \n return n*2.+.5;}   // or *1 to avoid saturation at the price of low contrast\n//https://www.shadertoy.com/view/XdScRt\n*/\n\n/*\nend__.transform.noise\nstart.transform.common\n*/\n//transform.2d:\n//2d rotation r=3.14 -> half rotation roundrclockwise\n#define r2d(r) mat2(cos(r),-sin(r),sin(r),cos(r))\n//return matrix of complex multiplication of [a] by [b]\n#define cmul(a,b) mat2(a,-a.y,a.x)*b\n//return matrix of complex division       of [a] by [b]\n#define cdiv(a,b) a*mat2(b,-b.y,b.x)/dot(b,b)\n\n//transform.3d\n//return vector [p] rotated by angle [r] around axis [a]\n#define raa(p,a,r) (cos(r)*v+sin(r)*cross(a,v)+(1.-cos(r))*dot(a*p)*a)\n\n/*\nend__.transform.common\nstart.ray.trace\n*/\n//raytracing returns intersection points||distances\n//which comes down to solving a 2nd to 6th degree spline\n//for all the points where f(x)=0, with 0 to 6 solutions for 6th gegree splines.\n//Raytacing is useful to calculate bounding shapes for raymarching\n\n//raytracing an elypsoid\n\n//[h.xyz],[h.w]=paneNormal,paneDistanceToVec3(0)\n//[o],[d]=TayOrigin,RayDirection\n//return distance along ray to intersection of plane along ray \nfloat gPRxZ(plane p,ray r){return -((dot(p.n,r.o)+p.d)/(dot(p.n,r.d)));}\n#define PlaneRayDistance(p,r) gPRxZ(p,r)\n//return intersection of ray[r] anf plane[p]\nvec3 gPRdV(plane p,ray r){return r.d*gPRxZ(p,r);}\n#define PlaneRayIntersection(p,r) gPRdV(p,r)\n\nvec3 RayTraceDemo(plane p,ray r){\n float d=PlaneRayDistance(p,r);//ditance=distanceOnRayToPlane\n vec3 c=r.d*fract(d)*pow(d,-.3);//color=fades to black with distance\n vec3 Out=c;\n return Out;}\n\n//#if DemoNum == DemoRaymarch\n//[o]=rayOrgin [d]RayDirection, sets up a planeto collide ray with.\nvec3 RayTraceDemoScene(v2 o,v2 d){\n plane p=plane(vec3(0,1,0),1.);\n ray r=ray(o,d);\n vec3 Out=RayTraceDemo(p,r);\n return Out;\n}\n//#endif\n\n//return vector that points from point[p] to nearest place on plane[h]\nvec3 gPXdV(plane h,v2 p){\n return -(dot(h.n,p)+h.d)*h.n;}\n/*\nend__.ray.trace\nstart.ray.march.sub\n*/                                \n\n//raymarching subroutines are distanceField and distanceBound functions.\n//both functions return a distance to the surface of a defined shape.\n//distanceField should return exact euclidean distance.\n//distanceBound can returns a larger distance than that\n//both never return a shorter distance than euclidean distance.\n//but if you bend space, overestimating distances happens easily.\n//...and you \"hit the ground\" sooner than expected,\n//...leading to \"vanishing surfaces\"\n// the compound of all distance estimations is a \"distance field\":\n                                               \n//primarily sorted by number of highest input dimension.\n//secondarily sorted by types; [distance],[transform],[compound]_\n//[distance] =d*  =return float distance of input parameters, 0th parameter is a point.\n//[transform]=p*  =return transformed [p], like; p=matrix*p;\n//            pM* =return #'s of the modulo tile, while inout transforming p;\n//[compound] =fOp*=return distance to booleanIsh-Volume of 2 distances.\n//functions used to be defines, but some can not be anymore, due to structure.\n//1to4d\n#define ml(a,l) max(a,length(l))\n//fBoxCheap() extrudes to box : fBox() extrudes to ROUNDED box\n\n//https://iquilezles.org/articles/distfunctions\n#define lengthN(a,e) pow(vsum(vpow(a,e)),1./e)\n//#define length8(a) pow((pow(a,vec2(8.)),vec2(1./8.)))\n//1d.p*         == simple linear algebra: y=f(x);\nfloat pSgn(float x){return step(x,0.)*2.-1.;}//return (x<0)?-1:1;\n//hull-curves with descriptive names: p[-1..1] r[0..1] -> .y[0..1]\n//https://www.shadertoy.com/view/lsscR2\n//#define powm(a) (1.-pow(a))\n#define fpr float p,float r){return\n/*\nfloat pTongueButt     (fpr 1.-pow(       abs(p)       ,r);}\nfloat pTongueIncube   (fpr 1.-pow(max(0.,abs(p)*2.-1.),r);}\nfloat pTongueSinButt  (fpr 1.-pow(abs(sin(pi2*p)),r);}\nfloat pSinSphereOncube(fpr pow(    cos(pi2*p)           ,r);}\nfloat pTentDomeOncube (fpr pow(min(cos(pi2*p),1.-abs(p)),r);}\n//below function is parametric composition of abive.\nfloat pUber(float p,v0 r,v0 one,v0 m){\n float c=cos(pi2*p);\n float inf=1.;//not sure if this should be 1,2,10 or LargestFloat\n inf=mix(inf,1.-abs(p),m);\n float a=pow(min(c,inf),r);\n return mix(a,1.-a,one);}\n/*\n//tent-shaped hull curves\n    vec2 u = fragCoord.xy / iResolution.xy;\n\t//u.x = (u.x - 0.5) * 2.0;\n    u.x*=iResolution.x/ iResolution.y;\n    u.x-=1.;\n    float a = (0.5 + 0.5 * sin(iTime)) * 5.5;\n    //a=.5;\n    float r=pTongueButt(u.x,a);\n    float g=pTongueIncube(u.x,a);\n    float b=pTongueSinButt(u.x,a);\n    float y=pSinSphereOncube(u.x,a);\n    float p=pTentDomeOncube(u.x,a);\n    //col.r +=fract(r -uv.y);\n    //col.g +=fract(g -uv.y);\n    //col.b +=fract(b -uv.y);\n    //col.rg+=fract(y-uv.y);\n    //col.rb+=fract(p-uv.y);\n    col+=vec3(fract(mix(p,g,.5)-uv.y));\n*/\n\n// convert distance to alpha for nice \"logarytmhic glow\"\nfloat pToa(float d,float a){a=1./a;\n return clamp(a/(clamp(d,a,1.)),0.,1.);}\n//usage as in https://www.shadertoy.com/view/XtjGzt\n//c=mix(c,vec4(1,.5,0),.7 *pToa(distance,60.));\n//iq curves: https://iquilezles.org/articles/functions\n//cubic curve that skips y=0. f(0)=n; for range n>y>m the cuve is cubic.\nfloat almostIdentity(float x,float m,float n){\n if(x>m )return x;//above m, f(x) is linear.\n x/=m;return((2.*n-m)*x+2.*m-3.*n)*x*x+n;}\n//slowly decaying \"ping\". maximum is f(1/k)=1;\nfloat impulse(float x,float k){float h=k*x;return h*exp(1.-h);}\n//interval [-w,w] local maximum at f(0);\n//bellShaped Gaussian-like =smoothstep(c-w,c,x)-smoothstep(c,c+w,x)\nfloat cubicPulse(float x,float c,float w){x=abs(x-c);\n if(x>w)return 0.;x/=w;return 1.0f - x*x*(3.0f-2.0f*x);}\n//e=exponent, k=scaling.y, for large [k,e] approaches step(x,1)\nfloat expStep(float x,float k,float e ){\n return exp(-k*pow(x,e));}\n//parabolic projection for x[0..1]\n//parabola(0)=parabola(1)=0,and parabola(.5)=1\nfloat parabola(float x,float k){\n return pow(4.*x*(1.-x),k);}\n//f(k)=maximum, gives shapes of wigs, eyes, leafs.\nfloat pcurve(float x,float a,float b,float k){\n return pow(x,a)*pow(1.-x,b)*k;}\nfloat pcurve(float x,float a,float b){\n return pcurve(x,a,b,(pow(a+b,a+b)/(pow(a,a)*pow(b,b))));}\n\nvec4 demo1dp(vec2 p){\n p*=10.;\n //p.y=pow(p.y,1.);    \n vec2 f=fract(p);\n f*=f*f;float grid=.5*(f.x+f.y);//lazy grid\n vec3 c=vec3(1.)+grid;\n c*=nThColor(floor(p.x)+floor(p.y)*phi*9999.);\n return vec4(c,1.);\n}\n//#define fSphereS(p,r)  (length(p)-r) //this is a silly dumb define\n\n//1d pM*\n#define am(a,b) (abs(a)-b)\n#define pmm p*=mod(c,2.)*2.-1.;return c;}\n#define pm c=floor((p/s)+.5);p=(fract((p/s)+.5)-.5)*s;return c;}\nfloat pMod1(inout float p,float s){p/=s;\n float c=floor((p)+.5);p=(fract(p+.5)-.5)*s;return c;}\nd2 pMod1(d2 p,v0 s){p=divd(p,s);\n //vec4 c=floord4(p);//c=subd(c,.5);//float c=floor((p)+.5);\n p=addd(p,.5);p=fractd(p);p=subd(p,.5);p=muld(p,s);//p=(fract(p+.5)-.5)*s;\n return p;}\nfloat pModMirror1(inout float p,v0 s){float c=pMod1(p,s);pmm\nfloat pModSingle1(inout float p,v0 s){float c=floor((p/s)+.5);if(p>=0.)p=(fract((p/s)+.5)-.5)*s;return c;}\nfloat pModInterval1(inout float p,v0 s,v0 b,v0 x){float c=pMod1(p,s);\n if(c>x){p+=s*(c-x);c=x;}if(c<b){p+=s*(c-b);c=b;}return c;}\nfloat pModPolar(inout vec2 p,v0 t){float g=tau/t,a=atan(p.y,p.x)+g*.5,r=length(p),c=floor(a/g);a=mod(a,g)-g*.5;p=vec2(cos(a),sin(a))*r;if(abs(c)>=t*.5)c=abs(c);return c;}\nfloat pMirror(inout float p,v0 d){float s=(p<0.)?-1.:1.;//s=step(p,0.)*2.-1.;\n p=am(p,d);return s;}\nfloat pReflect(inout vec3 p,v2 n,v0 o){float t=dot(p,n)+o;if(t<0.){p=p-(t+t)*n;}return (t<0.)?-1.:1.;}\n//bend around point that is offset -20. on the p.y axis.\nvec3 pCheapBend(v2 p){return vec3(r2d(20.*p.y)*p.xy,p.z);}\n//ztwist p around p,y axis.\nvec3 pTwist(v2 p ){return vec3(r2d(20.*p.y)*p.xz,p.y);}\nvoid pR(inout vec2 p,v0 r){p=cos(r)*p+sin(r)*vec2(p.y,-p.x);} \n//eight-rotation (45/360)\nvoid pR45(inout vec2 p){p=(p+vec2(p.y,-p.x))*p222;}\n\n//2d.f\n//#define fBoxCheapS(p,b) vmax(am(p,b) //this is a silly dumb define!\n//vmm(a) equals fBoxCheapS(a,0), as suffix.\n#define vmm(a) vmax(abs(a));\nfloat fBox2(v1 p,v1 b){vec2 q,d=am(p,b);//fBox2()=ROUNDED box,different in 3d and 2d.\n return length(max(d,0.))+vmm(p)} \n//egg= weighted ellipse -> \"Cartesian Oval\" //.z=weightFactor\nfloat fEllipseW(v1 p,v2 a,v2 b,v0 r){\n return length(p-a.xy)*a.z+length(p-b.xy)*b.z-r;}\n//https://www.shadertoy.com/view/lld3DS\nfloat fNgon(in vec2 p,v0 N){p=p*2.-1.;//centring\n float a=atan(p.x,p.y);//a=atan(p.x/p.y);//fast mirrored\n return cos(floor(.5+a*N/tau)*tau/N-a)*length(p);  \n return cos(floor(.5+a*N/tau)*tau/N-a)*dot(p,p); \n return cos(floor(.5+a*N/tau)*tau/N-a)*dot(p,p)*length(p);\n}//https://www.shadertoy.com/view/4ldXDn\n//squircle  http://en.wikipedia.org/wiki/Squircle\nfloat sdSquircle(v1 p, float r, float w){p=abs(p);\n return vsum(pow(p,vec2(w)))-pow(r,w);}\n#define vas vec2(0.,asin(1.))\n//return signed distance of [p] to a line that goes trough [a] and is orthogonal to a line trough [a] and [b].\nfloat sdline(v1 p,v1 a,v1 b){vec2 c=b-a;\n vec2 m=vec2(sin(atan(c.x,c.y)+vas));return dot(p,m)-dot(a,m);}\n//...rotate p around (h.z,0,0) by -quaterRotation-atan(b.x,b.y) and only return .y\nfloat q(v1 p,v2 h,v1 b){return dot(p+vec2(-h.z,0),sin(atan(-b.y/b.x)+vas))-h.y;}\n//return circle-circle-intersection.x; r.x=circle.left.radius;r.y=circle.right.radius;r.z=circles-centers.distance\nfloat cci(v2 r){float d=r.z*2.;r*=r;return(r.x-r.y+r.z)/d;}\n//return distace of p to 2 circles and their tangents.\n//h.xy=circle radii; h.z distance.x between sphere centers  \n//h.x>=h.y>0.0 ! h.z>=h.x-h.y, else there is no tangent\nfloat TangentCapsule(v1 p,v2 h){h.x=max(h.x,h.y);//cheap constrain\n #define ib ifb(-sdline(p,a\n p.y=abs(p.y);float s=h.x-h.y,i=cci(vec3(s,vec2(h.z*.5)));//h.x>h.y!\n vec2 a=vec2(i,sqrt(s*s-i*i)),b=vec2(h.z,0)-a;\n float e=length(p-vec2(h.z,0))-h.y,f=length(p)-h.x,g=ib+b,a-b),e,q(p,h,b));\n return ib,a+b),f,g);}//https://www.shadertoy.com/view/4sBcWh\n#define lvmm(a,b) return length(max(a,0.))+vmm(b)}\nfloat fCorner(vec2 p){lvmm(p,p)\nfloat fDisc(v2 p,v0 r){\n float l=length(p.xz)-r;return l<0.?abs(p.y):length(vec2(p.y,l));}\n//2d.pM*\nvec2 pMod2(inout vec2 p,v1 s){vec2 pm\nvec2 pModMirror1(inout vec2 p,v1 s){vec2 c=pMod2(p,s);pmm\nvec2 pModGrid2(inout vec2 p,v1 size){\n vec2 c=floor((p+size*.5)/size);\n p=mod(p+size*.5,size)-size*.5;\n p*=mod(c,2.)*2.-vec2(1);p-=size*.5;\n if(p.x>p.y)p.xy=p.yx;return floor(c*.5);}\nvec2 pMirrorOctant (inout vec2 p,v1 dist){\n vec2 s=vec2((p.x<0.)?-1.:1.,(p.y<0.)?-1.:1.);\n pMirror(p.x,dist.x);pMirror(p.y,dist.y);if(p.y>p.x)p.xy=p.yx;return s;}                    \n//3d.f\n//[n]planeNormal [d]=planeDistanceToVecN(0) (aka. hessian normal form)\n#define fPlane(p,n,d) (dot(p,n)+d)\n#define pa in vec3 p,in vec3 a\n#define pab pa,in vec3 b                                     \n#define pr in vec3 p,in float r\nfloat fBox(pa){vec3 q,d=am(p,a);//fBox()=ROUNDED box,different in 3d and 2d.\n return length(max(d,0.))+vmax(min(d,0.));}\n//return distance to box size (s),\n//... corners extrude, keeping all agngles, underestimating distances.\n\n//#define fBoxCheapS(p,b) vmax(am(p,b) //this is a silly dumb define!\nfloat fBoxCheap(v2 p,v2 b){\n v2 q=abs(p);q=q-p;//mirror clamp\n return vmax(q);}       //max(max(q.x,q.y),q.z);}\nd2 fBoxCheap(DAm2 p,v2 s){\n DAm2 u=subdabsd(p,s);//mirror clamp\n return maxdm(u);}  \n//return distance to box size (s), corners extrude to rounded spheres.\n/*\nfloat fBox(vec3 p,vec3 s){//this is a decomposition\n v2 d=abs(p)-s;//mirror clamp\n v0 a=length(max(d,0.));//rounded corners\n v2 q=min(d,0.);//clamp\n v0 b=max(max(q.x,q.y),q.z);//keep largest of 3\n return a+b;}//add //hg_sdf*/\nd2 fBox(DAm2 p,v2 s){//v3 s=v3(1.5,.5,1.5);\n DAm2 d=subdabsd(p,s);//mirror clamp\n d2 a=lengthd(maxdm(d,0.));//rounded corners\n DAm2 q=mindm(d,0.);//clamp\n d2 b=maxdm(q);//keep largest of 3\n return addd(a,b);}//add\n\nvec2 eA=normalize(vec2(eul, 1.));\nvec2 eB=normalize(vec2(1.,Phi));\nfloat fBlob(v2 p){p=abs(p);//no clue\n if(p.x<max(p.y,p.z))p=p.yzx;if(p.x<max(p.y,p.z))p=p.yzx;\n float l=length(p),b=max(max(max(dot(p,vec3(p323)),dot(p.xz,eA)),dot(p.yx,eB)),dot(p.xz,eB));\n return l-1.5-.15*cos(min(sqrt(1.01-b/l)*4.*pi,pi));}\nfloat fCylinder(pr,v0 h){//extrudes to cylinder\n return max(length(p.xz)-r,am(p.y,h));}\nfloat fLineSegment(pab){vec3 c=b-a;float t=clamp(dot(p-a,c)/dot(c,c),0.,1.);return length(c*t+a-p);}\n//lineSegment() has other input values than fCapsule()\nfloat fCapsule(pab,v0 r){return fLineSegment(p,a,b)-r;}\n//above is smarter reuse of code\nfloat fCapsule(pr,v0 c){\n return mix(length(p.xz)-r,length(vec3(p.x,am(p.y,c),p.z))-r,step(c,abs(p.y)));}\nfloat fTorus(pr,v0 c){//r and i input positions swapped!\n return length(vec2(length(p.xz)-r,p.y))-c;}\n//fCircle() is a torus were r sets both radii. is 1sub less\nfloat fCircle(vec3 p,float r){return length(vec2(p.y,length(p.xz)-r));}\n//https://iquilezles.org/articles/distfunctions\n#define hm1 vec3 p,v1 h){vec3 q=abs(p);return max(q.y-h.y,max(q.x*p322\nfloat fTriPrism           (hm1+p.z*.5,-p.z)-h.x*.5);}\nfloat fHexagonCircumcircle(hm1+q.z*.5, q.z)-h.x);}\nfloat fHexagonIncircle(v2 p,v1 h){return fHexagonCircumcircle(p,vec2(h.x*p322,h.y));}\nfloat fCone(pr,v0 h){\n vec2 t,m,q=vec2(length(p.xz),p.y);t=q-vec2(0.,h);m=normalize(vec2(h,r));\n float j=dot(t,vec2(m.y,-m.x)),d=max(dot(t,m),-q.y);\n if(q.y>h&&j<0.)d=ml(d,t);\n if(q.x>r&&j>length(vec2(h,r)))d=ml(d,q-vec2(r,0.));return d;}\nfloat fEllipsoid(in vec3 p,in vec3 r){\n return (length(p/r)-1.)*vmin(r);}\n//euclidean distance(a,b)=length(a-b) has exponent[n]=[2]; here [n] can be other EVEN number exponents.\nfloat fTorusN2( vec3 p,vec2 t,float n){\n return lengthN(vec2(length(p.xz)-t.x,p.y),n)-t.y;}\nfloat fTorus82(v2 p,v1 t){return fTorusN2(p,t,8.);}\nfloat fTorusNN(v2 p,v1 t,v0 n1,v0 n2){\n vec2 q=vec2(lengthN(p.xz,n1)-t.x,p.y);return lengthN(q,n2)-t.y;}\nfloat fUnterprim(v2 p,v3 s,v2 r,v1 ba,v0 sz2){\n vec3 d=abs(p)-s.xyz;float q=length(max(d.xy,0.))+min(0.,max(d.x,d.y))-r.x;\n #ifndef CONVEX    \n q=abs(q)-s.w;\n #endif    \n vec2 px=vec2(q,p.z-s.z),\n diag=px-vec2(r.z,sz2)*clamp(dot(px,ba),0.,1.),\n h0=vec2(max(q - r.z,0.0),p.z + s.z),\n h1=vec2(max(q,0.0),p.z-s.z);\n return sqrt(min(dot(diag,diag),min(dot(h0,h0),dot(h1,h1))))\n  *sign(max(dot(px,vec2(-ba.y,ba.x)),d.z))-r.y;}\n//https://www.shadertoy.com/view/MsVGWG\n//[s]=width,height,depth,thickness\n//[r]=xy corner radius,zCornerRadius,bottomRadiusOffset\nfloat fUberprim(vec3 p, vec4 s, vec3 r){//these operations can be precomputed\n s.xy-=r.x;\n #ifdef CONVEX  \n r.x-=r.y;\n #else\n r.x-=s.w;s.w-=r.y;\n #endif\n s.z-=r.y;vec2 ba=vec2(r.z,-2.*s.z);return fUnterprim(p,s,r,ba/dd(ba),ba.y);}\nfloat fUcube    (v2 p){return fUberprim(p,vec4(1),vec3(0));}\nfloat fUcylinder(v2 p){return fUberprim(p,vec4(1)          ,vec3(1,0,0));}\nfloat fUcone    (v2 p){return fUberprim(p,vec4(0,0,1  ,1  ),vec3(0,0  ,1));}\nfloat fUpill    (v2 p){return fUberprim(p,vec4(1,1,2  ,1  ),vec3(1,1  ,0));}\nfloat fUsphere  (v2 p){return fUberprim(p,vec4(1          ),vec3(1,1  ,0));}\nfloat fUpellet  (v2 p){return fUberprim(p,vec4(1,1,.25,1  ),vec3(1,.25,0));}\nfloat fUtorus   (v2 p){return fUberprim(p,vec4(1,1,.25,.25),vec3(1,.25,0));}\nfloat fUpipe    (v2 p){return fUberprim(p,vec4(1          ),vec3(1,.1 ,0));}\nfloat fUcorridor(v2 p){return fUberprim(p,vec4(1,1,1  ,.25),vec3(1,.1 ,0));}\n//3d.pM*\n//quaternions q()<->creation r()<->rotaition\n//normalize quaternion: true for quaternions <-> nornamoze(q)=q/length(q)==q/length(q*q)=q/dot(q,q)\nvec4 q(vec4 q){return q/dot(q,q);}\n//above is faster alternative to [normalize(q)] that only works for SOME situatinons;\n//return quaternin of [axis]&{angle] rotation\nvec4 q(vec3 axis,float angle){angle*=.5;return q(vec4(axis*sin(angle),cos(angle)));}\n//return [r]rotation, rotated by [b] //use like matrix multiplication\nvec4 r(vec4 b,vec4 r){return q(vec4(b.w*r.xyz+r.w*b.xyz+cross(b.xyz,r.xyz),b.w*r.w-dot(b.xyz,r.xyz)));}\n//return [r]vector, rotated by [b] //use like matrix multiplication\nvec3 r(vec4 b,vec3 r){vec3 t=2.*cross(b.xyz, r);return r+b.w*t+cross(b.xyz,t);}\n//from  https://www.shadertoy.com/view/lstSRM\n                      \n//return s3d sinusoidial \"blob_displacement\" of [p].\n#define pBlob(p) (sin(p.x)*sin(p.y)*sin(p.z))\nvec3 pMod3(inout vec3 p,vec3 s){vec3 pm\n//1d.fOp* take 2 distances (a,b) + parameters ([r][ra][rb]=radii,[n]=NumberOfThings)\n//*union*     ==a || b, volumetric union        == both volumes together\n//*intersect* ==a && b, volumetric intersection == only the shared volume\n//*difference*==a &&!b, volumetric difference   == volumeA-VolumeB\n//\n//*Chamfer ==diagonal cut\n//*Round   ==negative cylinder cut          \n//*Columns ==positive cylinder cut\n//*Stairs  ==stair cut\n//*Soft    ==cubic \"melt\"\n#define ac4(b) (a-b)*p222)\n#define mac4(a,b) max(a,ac4(b)\nfloat fOpUnionChamfer       (float a,float b,float r){\n return min(min(a,b),ac4(r+b);}\nfloat fOpIntersectionChamfer(v0 a,v0 b,v0 r){\n return mac4(max(a,b),-b);}\n#define fOpDifferenceChamfer(a,b,r) fOpIntersectionChamfer(a,-b,r)\n\nfloat fOpUnionRound(float a,float b,float r){\n vec2 u=max(vec2(r-a,r-b),0.);return max(r,min(a,b))-length(u);}     \nd2 fOpUnionRound(d2 a,d2 b,v0 r){\n d2 x=subd(r,a);x=maxd(x,0.);\n d2 y=subd(r,b);y=maxd(y,0.);x=lengthd(x,y);\n d2 m=mind(a,b);m=maxd(r,m);return subd(m,x);}\n//does not seem to have good lipschitz.\nfloat fOpIntersectionRound(float a,float b,float r){\n  vec2 u=max(vec2(r+a,r+b),0.);return min(-r,max(a,b))+length(u);}\nd2 fOpIntersectionRound(d2 a, d2 b,float r){\n d2 x=addd(r,a);x=maxd(x,0.);\n d2 y=addd(r,b);y=maxd(y,0.);x=lengthd(x,y);\n d2 m=maxd(a,b);m=mind(-r,m);return addd(m,x);}\n#define fOpDifferenceRound(a,b,r) fOpIntersectionRound(a,negd(b),r)  \n//#if (domains>1)\n /*\n vec2 pR45(vec2 p){return (p+vec2(p.y,-p.x))*sqrt(.5);}\n mat4 pR45(mat4 p){float s=sqrt(.5);\n  p[0]=addd(p[1],p[0]);p[0]=muld(p[0],s);\n  p[1]=subd(p[1],p[0]);p[1]=muld(p[0],s);return p;}\n                              \n //commented out, because it apperrs broken:\n //my fract() <- mod() is likely nonsense!\n //float fOpDifferenceColumns _M(-1.)\n //                             p.y+=c;p.x-=0.70710678118*(r+c);if(mod(n,2.)==1.)p.y+=c;pMod1(p.y,c*2.);return-min(min(max(-length(p)+c,p.x),a),b);}\n //#define fOpIntersectionColumns(a,b,r,n) fOpDifferenceColumns(a-b,r,n)\n /*\n //unknown error\n float fOpUnionColumns(float a, float b, float r, float n) { \n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n\t\tpR45(p);\n\t\tp.x -= sqrt(2.)/2.*r;\n\t\tp.x += columnradius*sqrt(2.);\n\t\tif (mod(n,2.) == 1.) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\t// At this point, we have turned 45 degrees and moved at a point on the\n\t\t// diagonal that we want to place the columns on.\n\t\t// Now, repeat the domain along this direction and place a circle.\n\t\tpMod1(p.y, columnradius*2.);\n\t\tfloat result = length(p) - columnradius;\n\t\tresult = min(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn min(result, b);\n\t} else {\n\t\treturn min(a, b);\n\t}\n }\n v4 fOpUnionColumns(v4 a, v4 b, float r, float n) {\n  if(a.x<r&&b.x<r){\n   mat4 p=mat4(a,b,0,0,0,0,0,0,0,0);\n   float columnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n   p=pR45(p);\n   p[0]=subd(p[0],sqrt(2.)/2.*r);\n   p[0]=addd(p[0],columnradius*sqrt(2.));\n   if (mod(n,2.) == 1.) {\n    p[1]=addd(p[1],columnradius);\n   }\n   p[1]=pMod1(p[1],columnradius*2.);\n   vec4 r=lengthd(p[0],p[1]);\n   r=subd(r,columnradius);\n   r=mind(r,p[0]);\n   r=mind(r,a);\n   r=mind(r,b);\n   return r;\n  }\n  return mind(a,b);\n }\n */\n                             \n                             /*\n //also fails\n // The \"Stairs\" flavour produces n-1 steps of a staircase:\n // much less stupid version by paniq\n float fOpUnionStairs(float a, float b, float r, float n) {\n     float s=r/n; \n     b=b-r; \n     float d=b-a+s;\n     d=mod(d,2.*s);\n     d=d-s;\n     d=abs(d);\n     d=b+a+d;\n     d=d*.5;      \n     return min(min(a,b),d);\n }\n v4 fOpUnionStairs(v4 a, v4 b, float r, float n) {\n     float s=r/n;\n     b=subd(b,r);\n     a=subd(b,a);\n     a=addd(a,s);//float d=b-a+s;\n     vec4 d=modd(a,2.*s);//d=mod(d,2.*s);\n     d=subd(d,s);\n     d=absd(d);\n     d=addd(a,d);\n     d=addd(b,d);\n     d=muld(d,.5);  \n     d=mind(d,a);\n     d=mind(d,b);\n     return d;\n\t return min(min(a,b),d);\n }\n\n // We can just call Union since stairs are symmetric.\n float fOpIntersectionStairs(float a, float b, float r, float n) {\n     return -fOpUnionStairs(-a, -b, r, n);\n }\n\n float fOpDifferenceStairs(float a, float b, float r, float n) {\n     return -fOpUnionStairs(-a, b, r, n);\n }\n */\n#define eM(S) (v0 a,v0 b,v0 r,v0 n){float c,m=min(a,b);if(a>r||b>r)return S*m;vec2 p=vec2(a,b);c=r*1.41421356237/(n*2.-0.58578643762);pR45(p);\nfloat SfOpUnionColumns eM(1.)p.x+=p222*(-r)+p222*(c*2.);\n if(mod(n,2.)==1.)p.y+=c;pMod1(p.y,c*2.);\n return min(min(min(length(p)-c,p.x),a),b);}\nfloat SfOpDifferenceColumns eM(-1.)p.y+=c;p.x-=p222*(r+c);\n if(mod(n,2.)==1.)p.y+=c;pMod1(p.y,c*2.);\n return-min(min(max(-length(p)+c,p.x),a),b);}\n#define SfOpIntersectionColumns(a,b,r,n) fOpDifferenceColumns(a-b,r,n)\nfloat SfOpUnionStairs(v0 a,v0 b,v0 r,v0 n){\n float s=r/n;float u=b-r;\n return min(min(a,b),.5*(u+a+abs(mod(u-a+s,2.*s)-s)));}\n#define SfOpIntersectionStairs(a,b,r,n) -fOpUnionStairs(-a,-b,r,n)\n#define SfOpDifferenceStairs(a,b,r,n) -fOpUnionStairs(-a,b,r,n)\n//a smoother fOpUnionRound(), by MediaMolecule, from Alex Evans' siggraph slides\nfloat fOpUnionSoft(v0 a,v0 b,v0 r){float e=max(r-abs(a-b),0.);return min(a,b)-e*e*.25/r;}\n//cylindical pipe that runs along the intersection.\nfloat fOpPipe(v0 a,v0 b,v0 r){return length(vec2(a,b))-r;}\n//// first object gets a v-shaped engraving where it intersect the second\nfloat fOpEngrave(v0 a,v0 b,v0 r){return max(a,(a+r-abs(b))*sqrt(.5));}\n// first object gets a U-shaped capenter-style groove cut out\nfloat fOpGroove(v0 a,v0 b,v0 ra,v0 rb){return max(a,min(a+ra,rb-abs(b)));}\n// first object gets a capenter-style tongue attached (negative groove)\nfloat fOpTongue(v0 a,v0 b,v0 ra,v0 rb){return min(a,max(a-ra,abs(b)-rb));}\n//metabally union of 7: //https://www.shadertoy.com/view/Xls3R7\nfloat fOpBlob7(v0 d1,v0 d2,v0 d3,v0 d4,v0 d5,v0 d6,v0 d7){float k=-2.;\n return -log(exp(k*d1)+exp(k*d2)+exp(k*d3)+exp(k*d4)+exp(k*d5)+exp(k*d6)+exp(k*d7))/-k;}\n//use cases for hg_sdf distancefunctions\nfloat hg_sdf_demo(v2 p){\n float t=sin(time)*.01+.02;\n mat2 m=r2d(time*.1);//rotation.2d\n //rotate world==rotate camera\n //p.yz*=m;p.xy*=m;//uses same 2d rotation 2x on different axes\n \n\n  //pMirrorOctant(p.xy,vec2(1.,1.));\n  //pModMirror1(p.x,.5);  \n  //pModMirror1(p.y,.5);\n  //pModMirror1(p.z,.5);\n  //m=r2d(time*.5);//rotation.2d\n  //rotate within tile-grid\n  //p.yz*=m;p.xy*=m;//uses same 2d rotation 2x on different axes\n\n  p-=vec3(0,0,4);\n  p*=2.;\n  p=p.zxy; \n  m=r2d(time*.2);\n  p.yz*=m;p.xz*=m;//uses same 2d rotation 2x on different axes\n  return fUberprim(p,vec4(0,4,2,0)*.2,vec3(-2,1.5,1.5));\n  return fUcorridor(p)-t*20.;\n  return fUcylinder(p)-t*20.;\n  return fUpipe(p)-t*20.;//rounded cylinder\n  return fUtorus(p)-t*20.;\n  return fUpellet(p)-t*20.;\n  return fUsphere(p)-t*20.;\n  return fUpill(p)-t*20.;\n  return fUcone(p)-t*20.;\n  return fUcylinder(p)-t*20.;\n  return fUcube(p)-t*20.;\n  \n  //return fdEllipsoid(p,vec3(1,2,3)*.05);\n  //return fPlane(p,vec3(2,2,0),1.);\n  float roundedSquareFrame=fTorusNN(p,vec2(.1,.0),4.,2.)-t;\n  float wheel             =fTorusN2(p,vec2(.1,.01),4.)-t;\n  //return wheel;\n  //return roundedSquareFrame;\n  float sphere  =length(p)-.08;\n  float cone    =fCone  (p,.02,.06)-t;\n//float circle  =fCircle(p,.05    )-t;//torus with less params\n  float torus   =fTorus (p.yxz,.03,.08)-t;\n//float disc    =fDisc  (p,.01    )-t;\n  float hex     =fHexagonCircumcircle(p,vec2(0.06,0.05))-t;\n  float triprism=fTriPrism(p,vec2(.1,.02))-t;\n  //  return triprism;\n  //return fHexagonIncircle(p,vec2(0.05,0.01))-t;\n//float capsule =fCapsule(p,.02,.04)-t;\n//float cylinder=fCylinder(p,.05,.02)-t;\n//float blob    =fBlob(p*.1); //???\n\n  //return sphere;\n  \n  float box     =fBox(p,vec3(.05))-t;\n//float bxcheap =fBoxCheap(p,vec3(.05))-.01;\n//float sphere  =length(p)-.1;\n  //return fOpIntersectionChamfer(box-.02,torus-.02,1.07);\n  //return fOpUnionSoft(torus,hex,.02);\n  //return fOpUnionColumns(torus,hex,.03,6.);\n  //return fOpUnionStairs(torus,hex,.03,6.);\n  //return fOpEngrave(hex,torus,.03);\n  //return fOpGroove(hex,torus,.03,0.04)-.01;\n  return fOpPipe(hex,torus,.03)+.01;\n  return hex;\n}\n\n\n\n//return distance of [p] to closest surface, defined by function.\nfloat df2(vec3 p){\n  #ifdef hgSdf\n  vec3 h=p; h.z-=.1;h.x-=.1;return hg_sdf_demo(h);\n  #endif\n  p=fract(p);\n  float t=time*.1;\n  float k=20.*(sin(t*5.)*.5+.9);//blobbyness\n  return length(p*1.-0.5)-.2+.1*pBlob(k*p);}\nvec3 Gradient(vec3 p,float d){vec2 e=vec2(.001,0);p*=99.;\n return (vec3(df2(p+e.xyy),df2(p+e.yxy),df2(p+e.yyx))*99.-d)/e.x;}\nvec3 Normal(vec3 p){vec2 e=vec2(.01,0);return normalize(vec3(\n df2(p+e.xyy)-df2(p-e.xyy),df2(p+e.yxy)-df2(p-e.yxy),df2(p+e.yyx)-df2(p-e.yyx)));}\nvec3 Normal2(vec3 p){if(df2(p)<.03)return Normal(p);return vec3(0);}\n\n/*\nend__.ray.march.sub\nstart.ray.march.main\n*/\n//this was a older idea for nice cheap \"celshading\" it works, but is tricky to translate.\n//rm3 does 2*df2() per IterRm, but the loop unrolls to less code.\nvoid rm3(vec3 o,vec3 r,inout float t,inout float t2){for(int i=0;i<IterRm;++i){\n  float d2=df2(o+r*t2);\n  if(d2>eps)t2+=d2*.5;\n  float d=df2(o+r*t);\n  t+=d*.5;\n  #ifdef dynamicEps\n  d=pow(d,pow(t,.5));\n  #endif\n  if(d<eps*.05)break;\n }}//calculating 2 distances at once is useful to:\n//- better visualite a distance field. -> analyze errors in the df easier.\n//- - it basically visualizes ONE first derivative!!!\n//- - as a transparent cartoon outline\n\n            \n//Below are translations of the hg_sdf library\n//...to use the above Derivative Arithmetic\n//...serving as examples. on how to translate between 2 arithmetics.\n\n//return distance to unit sphere\nd2 fSphere(DAm2 p){d2 q=lengthd(p.x,p.y,p.z);return subd(q,1.);;}\n//return distance to infinite line segment\nd2 fRay(DAm2 p){p.x.x=mix(0.,p.x.x,step(p.x.x,0.));\n d2 q=lengthd(p.x,p.y,p.z);return subd(q,1.);}//this might be \"broken\" now.\n//fRay() was an error that I chose to keep.\n            \n//A more readable version of a very parametric implicit surface.\n//...that does not look as much like LISP code, but at its core is just like that.\n//One operation per line keeps it BASIC and modifiable.\nd2 sdSuperprim(DAm2 p, v3 s,vec2 r) {\n //vec2 r=vec2(.2,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 dx,dy,dz,d,e,f,q,a,b,c;\n //dy=vec4(0);dz=vec4(0);d=vec4(0);\n //e=vec4(0);f=vec4(0);q=vec4(0);\n //a=vec4(0);b=vec4(0);c=vec4(0);\n d2 dx=subdabsd(p.x,s.x);\n d2 dy=subdabsd(p.y,s.y);\n d2 dz=subdabsd(p.z,s.z);\n \n d2 d=addd(dx,r.x);d=maxd(d,0.);\n d2 e=addd(dy,r.x);e=maxd(e,0.);\n d2 q=lengthd(d,e);\n d2 f=maxd(dx,dy);f=mind(-r.x,f);\n \n q=addd(q,f);\n q=addd(q,s.w);\n q=absd(q);\n q=subd(q,s.w);\n ///return...\n d2 a=addd(q ,r.y);a=maxd(a,0.);    \n d2 b=addd(dz,r.y);b=maxd(b,0.);a=lengthd(a,b);\n d2 c=mind(-r.y,maxd(q,dz));c=addd(a,c);\n return c;}\n\n//getfactor() cycles trough example input parameters for sdSuperprim() \n#define SHAPE_COUNT 10.0\nvoid getfactor (int i,out vec4 s,out vec2 r){\n       if(i==0){s=vec4(1)           ;r=vec2(0)     ;//cube\n }else if(i==1){s=vec4(vec3(1),.25) ;r=vec2(0)     ;//corridor\n }else if(i==2){s=vec4(vec3(1),.25) ;r=vec2(1)     ;//pipe\n }else if(i==3){s=vec4(1)           ;r=vec2(1,0)   ;//cylinder\n }else if(i==4){s=vec4(1,1,2,1)     ;r=vec2(1)     ;//pill\n }else if(i==5){s=vec4(1)           ;r=vec2(1)     ;//sphere\n }else if(i==6){s=vec4(1,1,.25,1)   ;r=vec2(1,.25) ;//pellet\n }else if(i==7){s=vec4(1,1,.25,.25) ;r=vec2(1,.25) ;//torus\n }else if(i==8){s=vec4(2,.5,.25,.25);r=vec2(.5,.25);//sausage mouth\n }else if(i==9){s=vec4(.7,1,1,.25)  ;r=vec2(.125)  ;//beveled O\n}}//  https://www.shadertoy.com/results?query=superprim\n\n/*\nend__.ray.march.main\nstart.demo\n*/\n\n/*\nvec4 demo0(vec2 u){\n vec3 o=vec3(0,0,-.2);//ray.Origin\n vec3 r=normalize(vec3(u,1));//ray.Direction\n mat2 m=r2d(time*.2);//rotation.2d\n r.yz*=m;r.xy*=m;//uses same 2d rotation 2x on different axes\n \n // Out=vec4( RayTraceDemoScene(o,r),1);return;\n  vec3 p;//point were a surface was hit\n  float t=0.,t2=0.;\n  rm3(o,r,t,t2);\n  int DemoNum=1;\n  if (DemoNum == 1){\n   //p=mix((o+r*t2),Normal2(o+r*t)*.5+.5,1.0);\n   //p=Gradient((o+r*t2),.01)*.5+.5;\n    p=Normal2(o+r*t)*.5+.5;\n  }else{\n   p=o+r*t2;\n   p=fract(p)*mod(p,3.)*t2*t2/(t*t*t);\n  }\n  //p=vec3(fract(t),fract(t2),0.);\n\n    \n  //mixing demos:\n    \n\n //STATIC-Image Zenos-Paradox of Achilles-Tortoise multipass :\n vec3 pp=texture(iChannel0,U/iResolution.xy).rgb*float(iFrame);\n //Out=vec4((pp+p*.5)/float(iFrame+1),1);\n //every extra frame has a diminishing impact, approaching null.\n    \n //gamma correction\n p=pow(p,vec3(1.075));\n return vec4((p)*.5,1);\n}\n/**/\n\n\n //demo playground for boolean unions of implicit surfaces.\n d2 aBool(DAm2 p){\n  d2 box=fBoxCheap(p,vec3(1));\n  p=subd(p,vec3(-1,1,1));//p.x=addd(p.x,1.);p.y=subd(p.y,1.);p.z=subd(p.z,1.);\n  d2 box2=fBox(p,vec3(1));\n  //return mind(box,box2);//(box or     box2)\n  //return maxd(box,box2);//(box and     box2)\n  //return maxd(box,-box2);//(box and not box2)\n  return fOpUnionRound(box,box2,1.);\n  //return fOpIntersectionRound(box,box2,.3);\n  //return fOpDifferenceRound(box,box2,.5);\n  //return box;\n }\n \n //set camera position & target\n void setCam(out vec3 o,out vec3 i,v0 t,v0 m){\n  o=vec3(4.*sin(t),m*9.-2.,4.*cos(t));i=vec3(0);}\n\n struct DAMValue{d2 d;float m;};//to paint the gradient on a plane.\n DAMValue min2(DAMValue a, DAMValue b){if(a.d.x>b.d.x)return b;return a;}\n DAMValue planeD(DAm2 p){return DAMValue(addd(p.y,1.),1.);}\n //DAMValue add_plane(DAVec3 p,DAMValue m){return min2(plane(p),m);}\n \n  #define ss01(a) smoothstep(0.,1.,a) \n  #define imsc(a) int(mod(a,SHAPE_COUNT))\n  //return distance to surface of DistanceField\n DAMValue df(DAm2 p){d2 r;\n  #ifndef SuperPrim\n   //simpler more static parametric surfaces:\n   r=aBool(p);\n   //r=fSphere(p);\n   //r=fBox(p,vec3(1));\n   //r=fBoxCheap(p,vec3(1));\n   float holesize=mix(.6,5.,sin(iTime*3.)*.5+.5);\n   d2 s=fSphere(muld(p,vec3(holesize)));r=maxd(r,negd(s));\n   //scaling by holesize is bad for lipschitz constant.\n  #else\n   //superprim() is a very parametric implicit surface.\n   float t=iTime,u=ss01(ss01(fract(t)));\n   vec4 a,b;vec2 c,d;\n   getfactor(imsc(t   ),a,c);\n   getfactor(imsc(t+1.),b,d);\n   DAm2 q=DAm2(p.y,p.z,p.x);\n   if(iMouse.z>.5){\n    vec2 m=iMouse.xy/iResolution.xy;\n    r=sdSuperprim(q,vec4(vec3(1.0),mix(a.x,b.x,u)),m);\n   }else\n    r=sdSuperprim(q,mix(a,b,u),mix(c,d,u));\n  #endif\n   //return DAMValue(r,0.);\n   return min2(planeD(p),DAMValue(r,0.));}\n \n //return distance & materialID\n vec2 dm(v2 p){DAMValue d=df(da_domain(p));return vec2(d.d.x,d.m);}\n //return material at p with normal n\n vec4 material(v2 p,v2 n ){d2 d=df(da_domain(vec3(p.x,0.,p.z))).d;\n  return mix(vec4(n*.5+.5,.1)\n            ,vec4(d.d*.5 +.5,.0)*abs(mod(d.x,.1)/.1-.5)\n            ,sat(dm(p).y));} //texture mix, treats .y as height.\n/*\nend__.demo\nstart.main\n*/\n //return soft shadow of light source at [o], \n //... with light direction [i] pointing from [o] to surface point [p]\n float shadow(v2 o,v2 i){\n  const float a=32.;//shadow hardnes\n  float r=1.,h =1.,t=.0005;//t=(self)intersection avoidance distance\n  for(int j=0;j<IterSh;j++){\n   h=dm(o+i*t).x;\n   r=min(r,h*a/t);\n   t+=clamp(h,.02,2.);}//limit max and min stepping distances\n  return clamp(r,0.,1.);}\n //  iquilezles.org/articles/rmshadows\n\n //return p, modified by light , shadow, envMap...\n v2 light(vec3 p,vec3 n,vec3 i,float d,vec4 m){\n  v2 l=normalize(v2(1.,.7,.9));//light direction\n  v0 o=max(0.,dot(n,l)),\n  c=max(0.,dot(n,normalize(l-i))),\n  s;if(c>.01)s=shadow(p+.01*n,l); \n  const v2 LigCol=vec3(1.);//light color\n  v2 r=m.rgb*(LigCol+o*vec3(.8,.7,.6)*s*3.+vec3(.2,.3,.3));  \n  r+=s*c*pow(o,40.);//specular\n  //r+=m.x*texture(iChannel0, reflect(i,n)).rgb;//environment map\n  r*=exp(-.01*d*d);//fog  \n  return r;}\n //return distance along ray (raymarch till surface)\n float rm(v2 o,v2 i){\n  const float m=20.;//distance.Max\n  float e=.0,h=e,t=0.;//intersection.precission\n  for(int j=0;j<IterRm;j++){\n   if(h<e)break;if(t>m)return -1.;\n           //wait a moment, do i not have the lipschitz for the point\n      //or at least 3 for 3 domains of the point\n      //by using [DA]?\n      //i mean, i could really insert this here, right?\n      //and substitute ReciprocalAbsLipschitz with \"1/da_length(dm(o+i*t).yzw)\"\n   //i am pretty sure that i am missing a dotproduct here\n   //the gradient must be dorproducted onto the ray direction?\n   vec3 p=o+i*t;\n   DAMValue s=df(da_domain(p));\n   float r=ReciprocalAbsLipschitz;\n   //r=1./length(dot(s.d.yzw,i));//overwriting with a VERY LOCAL lipschitz constant\n      //its not a good estimate, but it is a LOT better?\n      //nah it totally fails for concave isosurfaces.\n   h=s.d.x*r;t+=h;}return t;}\n\n  //return camera matrix\n  mat3 calcLookAtMatrix(in vec3 o,in vec3 i,in float r ){\n   vec3 w=normalize(i-o);vec3 u=normalize(cross(w,vec3(sin(r),cos(r),0.)) );\n   return mat3(u,normalize(cross(u,w)),w);} \n\n //return surface normal\n vec3 getN(in vec3 p){DAMValue d=df(da_domain(p));return d.d.d;}\n //d.d.d stores the first derivatives on the 3 domains, (is also an awesopme pointer label)\n //this is equivalent to the gradient at p.\n //If (p is near a surface) the gradient is a surface normal\n //d.d.* addresses a vec4. where *.yzw==gradient\n //d.m.* addresses a material\n//#elif (domains==1||domains==3)\n //is a lot like \n //  https://www.shadertoy.com/view/XdffzB\n                                  \n d getd(v0 u){\n  //function must be defined in prefix-notation;\n  //  https://en.wikipedia.org/wiki/Polish_notation  \n  //return absd(u);//f(x)=abs(x)  //first derivative of abs(x) is always a good start\n  //return sind(u);//f(x)=sin(x) //cos(x) as first derivative of sin(x)\n  return addd(absd(u),sind(u));//f(x) = abs(x)+sin(x) = add(abs(x),sin(x))\n }\n//#elif (domains==0)\n //this mode may insist on using a second domain as deltaTime or deltaMultipleFunctions?\n //so, it basically comes down to Fourier Transform.\n //otherwise one domain of screenspace gets wasted.\n//#endif \n\n//domain independent algebra:\n//return color corrected r\nvec3 ff_filmic_gamma3(vec3 r){vec3 x=max(vec3(0),r-.004);\n return (x*(x*6.2+.5))/(x*(x*6.2+1.7)+.06);}     \n\n //https://en.wikipedia.org/wiki/Alpha_compositing\n vec4 aOverB(vec4 a,vec4 b){a.xyz*=a.w;b.xyz*=b.w;return vec4(a+b*(1.-a));}\n //vec2 aOverB(vec2 a,vec2 b){a.x*=a.y;b.x  *=b.y;return vec2(a+b*(1.-a));}\n //not sure if correct, but looks useful.\n vec4 aXorB(vec4 a,vec4 b){a.xyz*=a.w;b.xyz*=b.w;return vec4(a*(1.-b)+b*(1.-a));}\n //vec2 aXorB(vec2 a,vec2 b){a.x*=a.y;b.x  *=b.y;return vec2(a*(1.-b)+b*(1.-a));}\n #define ssb2(a,b) smoothstep(a,-a,b)\n #define ssb(b) smoothstep(blur,-blur,b)\n                                    \n//2d domain space parent: https://www.shadertoy.com/view/XdffzB\n v0 elliEyesS(v1 u,v1 m,v0 h){\n  m*=9.;m=abs(m);m=1./m;\n  //https://www.shadertoy.com/view/MdfGWn    (derivative ellipse approximation)\n  //... coverted to derivative arithmetic. \n  //it think it can be more than a approximation, by using more than 1 domain.\n  //but how?\n  DAm1 f=da_domain(u);\n  f=muld(f,m);\n  f.x=lengthd2(f);//so, we completely distegard one of 2 domains here?\n  //like we project doen to -1 dimension within a torus, 2 times?\n  //above (and below) line is like u.x=length(u)-1;\n  //i am pretty sure, utilizing the other domain will fix a lot of stuff!\n  f.x=subd(f.x,1.);\n     \n  //#define FilledEllipse\n  //#ifndef FilledEllipse\n  // f.x=absd(f.x);//makes ellipse ring instead of filled ellipse\n  //#endif\n  float outlineThickness=iResolution.y*.5;\n  float i=length(vec2(f.x.d.x,f.x.d.y)*outlineThickness);\n  //this looks kina nead like \"Fxdx()\", but it is more misleading than anything?\n  float ellipseBorderThickness=\n     //if(any(lessThan(m,vec2(.9))))ellipseBorderThickness=0.;\n      14./iResolution.y;\n     //(sin(iTime)*.5+.5)*9.;//=0.01;\n//float r=1.-f.x.x;\n  return  ssb2(ellipseBorderThickness,f.x.x*iResolution.y/i);\n}\nvec4 in3d(vec2 u,vec3 o,vec3 d){\n float t=rm(o,d);//Distance.raymarched\n vec3 c=vec3(0);\n if(t>-.5){\n  vec3 p=o+t*d,n=getN(p); //position & normal\n  vec4 m=material(p,n);   //material\n  c=light(p,n,d,t,m);}    //light\n c=ff_filmic_gamma3(c*.6);//gamma\n //c=pow( clamp(col,0.0,1.0), vec3(0.4545) );\n return vec4(c,1.);}\n//demo listings:\nvec4 in3d(vec2 u){\n u=(-iResolution.xy+2.*u.xy)/iResolution.y;\n vec2 m=iMouse.xy/iResolution.xy;  //mouse\n vec3 o,i;\n setCam(o,i,iTime,m.y+.2);//camMovement\n vec3 d=normalize(calcLookAtMatrix(o,i,camRoll)*vec3(u.xy,camLens));//ray.direction\n return in3d(u,o,d);}\n\n\nv3 elliEyes(v1 u,v0 h,v0 g){\n vec2 m=frame(iMouse.xy);\n vec2 d=vec2(.1);\n d=min(d,abs(m));\n float a=elliEyesS(u,abs(m)+d,h)-elliEyesS(u,abs(m)-d,h);\n //v3 yellow =v3(v2(1,1,0),r);\n //v3 yellow =v3(v2(1,1,0),ssb(1.-r*iResolution.y/i));\n v0 blur=20./max(iResolution.y,1.);\n v3 yellow =v3(v2(1,1,0),.5-ssb(a));\n v3 cyan   =v3(v2(0,1,1),ssb(g));\n //float b=0.;//no magenta here//v3 magenta=v3(v2(1,0,1),ssb(b));\n //this is very identical to substracting stretched circles. silly dumb!\n //horizontal and vertical are correct. only all the diagonals suck!\n //i am pretty sure the solution to this includes fract() of that other isoline thing.\n //nope, there just the fundamental difference between a distance field and a scaled sphere.\n //just need that carthesian to ellyptic transform. and quess what. its not a closed form!\n return aOverB(yellow,cyan);}\n\n v3 linearGraph(v1 u,v0 h,v0 g){\n  d d=getd(u.x);\n  //float div=sqrt(1.+p.y*p.y);\n  v0 r=abs(d.x-u.y)/(sqrt(1.+d.d*d.d))-thick;    \n  d=getd(u.x);\n  //no analytical 2nd derivative, so this one sucks a bit\n  v0 b=abs(d.d-u.y)/(sqrt(1.+d.d*d.d))-thick;\n  //this does not work for scaled p, is far from being user friendly\n  v0 blur=20./max(iResolution.y,1.);\n  v3 yellow =v3(v2(1,1,0),ssb(r));\n  v3 cyan   =v3(v2(0,1,1),ssb(g));\n  v3 magenta=v3(v2(1,0,1),ssb(b));\n  return aOverB(aOverB(yellow,magenta),cyan);}\n \n v3 in2d(vec2 u){\n  u=frame(u); \n  u*=9.;\n  v1 f=abs(fract(u));//green carthesian grid   \n  float h=abs(fract(length(u)+thick)-thick);//green polar circles\n  v0 g=min(min(f.x,f.y),h);\n  return elliEyes(u,h,g);\n  return linearGraph(u,h,g);\n }\n//#elif (domains==0)\n v3 in1d(v1 u){\n  return v3(0);}\n//#endif \n\n#define KeyIn\n#define domains 3\nvoid mainImage( out vec4 O,in vec2 U ){\n  \n //if(U.x>20.){\n // //O=vec4(1);\n//  O=vec4(load(VMOUSE).xyz,.1);return;\n// }\n vec2 u=frame(U);\n vec3 move;\n //#ifdef KeyIn\n/* if(U.y<30.){//buffer area\n  if(iTime==0.)O=vec4(0);//clear init\n  //u.x+=.5;\n  //float s=length(u-p.xy);\n  //s=fract(s+p.z*.1);   \n  #define frictionM 0.995\n  vec3 pos=texp(vec2(0));\n  if(U.y<30.){\n   if(U.x<30.){\n    #define keyp(a) (texture(iChannel3,vec2((.5+float(a))/256.),.7).x)\n    vec3 p=vec3(0);\n    p.x+=keyp(_F)-keyp(_S);\n    p.y+=keyp(_E)-keyp(_D);\n    p.z+=keyp(_Q)-keyp(_A);\n    O=vec4(texp(-U)+p,1.);//store key //no clue why it is -U, but hey, it works\n   }\n   if(U.x>30.&&U.x<60.){\n    O=vec4(texp(-U),1.);\n   }\n  }\n  //if(keyp(_E)>0.)O=vec4(1);\n return;\n }//screen area*/\n  //#endif\n \n vec3 RayPos=load(POSITION).xyz;//load camera position rom buffer\n vec3 RayDir=vec3(0);\n RayPos=vec3(RayPos.x,-RayPos.z,RayPos.y);//simple 90 rotation\n vec2 mmm=load(VMOUSE).xy/iResolution.xy;\n    //eul cam just sucks!\n    //i should store a quaternion.\n RayDir=CamEul(U,mmm,RayPos);//rotate camera direction.\n    \n /*if(U.x<20.){\n     vec2 ass=mmm/iResolution.x;\n   O=vec4(RayDir,1.);\n     O=vec4(ass,1,1);\n     return;\n }*/\n    \n    \n #ifdef DrunkenQuatenrion\n //vec3()<- angle , the other parameter is the AXIS.\n vec4 q1=q(vec3(1,0,0),sin(iTime)*.1);\n vec4 q2=q(vec3(0,0,1),cos(iTime)*.1);\n //you should avoid rotating a point by a quaternion as much as possible!!!\n //and instead rotate quaternions by quaternions first\n //d=r(q1,d);//rotate [d]vector by [q]quaternion.\n //d=r(q2,d);//rotate [d]vector by [q]quaternion.\n //above code rotates a point by 2 quaternions\n //d=r(q2,d); is computationally more complex, because it contains cross(cross))\n //q1=r(q2,q1) only does 1dot() 1cross) \n //below code rotates ine quaternion b the o ther frrst.\n q1=r(q2,q1);//rotate q1 by q2, right-entian, like matrix multiplicaition\n RayDir=r(q1,RayDir);//and then rotates the point by the rotated rotation \n #endif\n RayPos+=vec3(0,0,-5);//camera position offset to better fit the distanceField\n RayDir=vec3(RayDir.x,-RayDir.z,RayDir.y);//simpe 90deg rotation\n  vec4 r;\n  #if (domains==3)  \n   //this is not 4d, it is 2d overlayed on top of 3d.\n   r=aOverB(in2d(U),in3d(U,RayPos,RayDir));\n   //O=vec4(mix(ass.xyz,poo.xyz,ass.w),1.);}\n  #elif (domains==2)\n   r=in3d(U,RayPos,RayDir));\n  #elif (domains==1)\n   r=in2d(U);\n  #elif (domains==0)\n   r=in1d(U);\n  #endif \n  O=r;}\n\n//my todo_list;\n//todo, find aliases for common operations, and debug them.\n//I suspect that modulo and 2d rotation seem buggy.\n//\n//todo, merge with hg_sdf, full set\n//to have hg_sdf with first derivatives, in 2 or 3 domains.\n//it already poited at my lack of competence to substitute correctly\n//-> lots of small errors.\n//\n//done, looking good enough:\n//\n//fSphere()\n//fRay() (infinite line segment with radius 1)\n//fBox()\n//fBoxCheap()\n//\n//mind() maxd() unions of 2 distance fields (Boolean AND, boolean OR)\n//fOpUnionRound()\n//fOpIntersectionRound()\n//fOpDifferenceRound()\n//\n//I failed at:\n//fOp*Columns\n//fOP*Staircase\n//\n//\n//todo pModd() , will likely hint me at how to fix stuff.\n//\n//todo: include complex plane transformation math of\n//  https://www.shadertoy.com/view/ls2cDt\n//for anything \"Cauchy\"\n//  https://en.wikipedia.org/wiki/Complex_analysis\n//  https://en.wikipedia.org/wiki/Augustin-Louis_Cauchy\n//\n//todo, antialiasing, merger with: https://www.shadertoy.com/view/MdXczr\n//\n//todo, curvature stuff, because I want a minimal surface !\n\n//every \"thing\" has a \"demo\" function that returns a vec4()\nvoid mainImage2(out vec4 Out,in vec2 In){\n vec2 u=In.xy/iResolution.xy-.5;\n u.x*=iResolution.x/iResolution.y;\n\n //vec4 d1dp=demo1dp(u);\n //Out=mix(demo0(u),demo1dp(u),sin(time)*.4+.5);\n \n    \n //dependant multipass\n //from https://www.shadertoy.com/view/XdjyDw\n float convergeSpeed=0.2;//set blur amount\n convergeSpeed=length(u)*.25;//blurry peripheral vision.\n //example for dependant convergeSpeed.\n //float DeltaV=-iMouse.z;\n //convergeSpeed-=DeltaV>0.||iFrame< 20?.4:.996;\n //haing the above -=y makes it visualize delta of movvement.\n if(iFrame<=1)convergeSpeed=0.;\n Out.rgb = mix(Out.rgb, texture(iChannel0, In/iResolution.xy).rgb, convergeSpeed);\n if(iFrame>1)convergeSpeed=0.;\n Out.rgb = mix(Out.rgb, texture(iChannel0, In/iResolution.xy).rgb, convergeSpeed);\n\n /**/\n}\n\n/*\nend__.main2\nstart.dump\n*/\n\n//the i am tired dump:\n            \n//todo, i actually need a linear equation solver up to 6th gedree curves?\n//for many things, but mostly just to raytrace.\n//for that i need my decent 2d canvvas\n\n//pow(x,y)  -> exp(log(x)*y);\n//pow(2,y) <-> pow2(y);\n\n//return signed atan(p)\nfloat atanS(v1 p){\n return sign(p.x)*atan(p.y,p.x);}\n//return [0..pi*2] instead of atan(p.y,p.x) range[0..pi] (unsigned)\nfloat atanTau(v1 p){\n if (p.x< 0.) return acos(-1.)-atan(p.x,-p.y);\n return atan(p.x,p.y);}\n\n/*\nmultisamplig gradient\n//return gradient for position [p], by 4*Sampling the 2d_distance_field f();\nvec2 grad(in vec2 p){vec2 h=vec2(.01,.0);return vec2(f(p+h.xy)-f(p-h.xy),f(p+h.yx)-f(p-h.yx))/(2.*h.x);}\n//grad() is ALMOST the 2d equivalent to getting a 3d normal vector of a 3d distance Field.\n\n//return smoothstep()_contour for point x of distanceField f() \nfloat color( in vec2 x ){vec2  g=grad(x);float v=f(x),d=abs(v)/length(g);\n //return fract(d*9.);\n return smoothstep(.19,.20,d);}\n*/\n\n/*\nend__.dump\nstart.memo\n\nhttps://en.wikipedia.org/wiki/Contour_line\nhttps://en.wikipedia.org/wiki/Isosurface\nlink surface nets to distance fields.\n\n//what i still have never done:\nhttps://en.wikipedia.org/wiki/Volume_ray_casting\n\n//optimizing\nhttps://en.wikipedia.org/wiki/Volume_rendering#Optimization_techniques\n\nsyntax:\nhttps://www.khronos.org/opengl/wiki/Data_Type_(GLSL)#Arrays\nconst float array[3] = float[3](2.5, 7.0, 1.5);\n\n*//*\nend__.memo\nstart.license\n*//*\n\nIf your license includes allcaps, you may aswell \nuse comic sans and papyrus typefaces to appear more serious,\nand I will abreviate your silly licince texts \nwithin your licence to remove the allcaps. deal with it, cry baby:\n\nThe MIT License, Copyright  2017 Inigo Quilez\nPermission is hereby granted,for free,to do whatever with this,\nas long as you include this abbreviation of an allcaps text \nabout claiming to have null liability or varanty, \nwhich is the most a dumb way to write a licence.\nbecause as above, you already wrote \"do whatever AND also include this\"\nso I just modify [this null reliability clause] \nas part of [doing whatver with this text].\nIf you hurt yourself or your property its not my fault, duuuh!\n*//*           \nend__.license\n*/\n\n/*\ntodo, reserve some small pixels for vec3 data. make alpha 100%.\nthis is a \"top level branch\" with a 1 frame delay.\n//first load cam pos, then compute pixel, then store cam pos.\n\nthen use that tu buffer camera position,movement,direction,momentum.\nshould be ble to load a campos.xyz and a camdir.xyz\n*/","name":"Buf B","description":"","type":"buffer"}]}