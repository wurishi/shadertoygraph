{"ver":"0.1","info":{"id":"XfjcW1","date":"1722265246","viewed":66,"name":"canine+sound","username":"jorge2017a2","description":"canine+sound","likes":10,"published":1,"flags":8,"usePreview":0,"tags":["2d","sound","canine","ssaw"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//por jorge2017a2\n//canine+sound\n//---24-jul-2024--\n\n//referencia\n//https://iquilezles.org/articles/distfunctions2d\n///\n//lluvia //https://www.shadertoy.com/view/XclcDX //by GregRostami\n\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n\n#define S(d,b) smoothstep(antialiasing(1.5),0. , d - (b) )\n#define S2(d,b) smoothstep(8.0*antialiasing(1.5),0.,d - (b) )\n#define S3(d,b) smoothstep(1.0/antialiasing(2.5),0. , d - (b) )  //antes\n\n\n#define PI     3.14159265\n#define TWO_PI 6.28318530\n\nfloat Sdf_I(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat Sdf_U(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat Sdf_D(float distA, float distB)\n\t{ return max(distA, -distB);}\n\nvec3 DFB(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S3( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0),S3(abs( distObj)-0.005,0.0));\n  return colOut;\n}\n\n\nvec3 DFS(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S( distObj,0.0)); return colOut;\n  return colOut;\n}\n\n\n///oneshade    \nvec2 Rotate(in vec2 p, in vec2 o, in float r) \n{   float c = cos(r), s = sin(r);\n    return (p - o) * mat2(c, -s, s, c) + o;\n}\n\nvec3 canino(vec2 p,vec3 colout)\n{ vec2 A,B,med,pr;\nfloat dfin;\nfloat r1,ang,he;\n\nA=vec2(0.3123288,0.4739726);\nmed=vec2(0.1205479,0.06986301);\nfloat d1=sdBox(p-A,med);\n\n\nA=vec2(0.1369863,0.4219178);\nmed=vec2(0.05342466,0.01917808);\nfloat d2=sdBox(p-A,med);\n\nA=vec2(0.1287671,0.4027397);\nr1=0.03835616;\nfloat d3=sdCircle(p-A,r1);\n\nA=vec2(0.1616438,0.4219178);\nmed=vec2(0.03424658,0.01917808);\nfloat d4=sdBox(p-A,med);\n\nA=vec2(0.3616438,0.4219178);\nmed=vec2(0.06712329,0.01917808);\nfloat d5=sdBox(p-A,med);\n\nA=vec2(0.3938356,0.39027397); //modificado\nmed=vec2(0.04383562,0.03991781);  //modificado\n\nang=180.* PI/180.0;\npr = Rotate(p-A, med/2.0, ang);\nfloat d6=sdTriangleIsosceles(pr,med);\n\nA=vec2(0.4,0.4575343);\nmed=vec2(0.0369863,0.05068493);\nfloat d7=sdBox(p-A,med);\n\nA=vec2(0.3342466,0.4027397);\nr1=0.03561644;\nfloat d8=sdCircle(p-A,r1);\n\n\nA=vec2(0.3661644,0.480685);\nmed=vec2(0.03294521,0.039781);\n\nfloat d9=sdTriangleIsosceles(p-A,med);\n\n\nA=vec2(0.3863014,0.4219178);\nmed=vec2(0.04931507,0.01917808);\nfloat d10=sdBox(p-A,med);\n\n///-----------------\nA=vec2(0.2157895,0.60105263);\nmed=vec2(0.0694737,0.035368421);\n\nhe=5.263158E-02;\nfloat d11= sdTrapezoid(p-A, med.x, med.y, he);\n\nA=vec2(0.2526316,0.6031579);\nmed=vec2(0.0368421,0.05);\nfloat d12=sdBox(p-A,med);\n\nA=vec2(0.2,0.5978947);\nmed=vec2(0.1110526,0.0168421);\n\nhe=0.055;\nfloat d13= sdTrapezoid(p-A, med.x, med.y, he);\n\nA=vec2(0.0605084211,0.5205263);\nmed=vec2(0.05589474,0.07510526);\n\nang=180.0 * PI / 180.0;\npr = Rotate(p-A, med/2.0, ang);\nfloat d14=sdTriangleIsosceles(pr,med);\n\nA=vec2(0.1601579,0.60031579);\nmed=vec2(0.05131579,0.05531579);\nfloat d15=sdBox(p-A,med);\n\nA=vec2(0.111579,0.59531579);  \nmed=vec2(0.02763158,0.02978947);\n\nang=135.0 * PI / 180.0;\npr = Rotate(p-A, med/2.0, ang);\nfloat d16=sdTriangleIsosceles(pr,med);\n\nA=vec2(0.1815789,0.6236842);\nr1=0.00789474;\nfloat d17=sdCircle(p-A,r1);\n\nA=vec2(0.25,0.525078948);\nmed=vec2(0.0340963158,0.03798947);\nfloat d18=sdTriangleIsosceles(p-A,med);\n\nA=vec2(0.1578947,0.5736842);\nB=vec2(0.1473684,0.5631579);\nfloat d19=sdSegment(p,A,B);\n\n\nA=vec2(0.4368421,0.5289474);\nmed=vec2(0.051026316,0.01368421);\n\nhe=1.578947E-02;\nang=90.000 * PI / 180.0;\npr = Rotate(p-A, med/2.0, ang);\nfloat d20=sdTrapezoid(pr,med.x, med.y, he);\n\nA=vec2(0.39999095,0.607158);\nmed=vec2(0.02505263,0.0284211);\nfloat d21=sdTriangleIsosceles(p-A,med);\n\n\n\n\nA=vec2(0.4263158,0.59026316);\nmed=vec2(0.03505263,0.01184211);\nang=45.000 * PI / 180.0;\npr = Rotate(p-A, med/2.0, ang);\nfloat d22=sdBox(pr,med);\n\n\n///---------------\nfloat d101=d1;\nd101=Sdf_D(d101,d6);\nfloat d102=Sdf_U(d3,d4);\nfloat d103=Sdf_I(d2,d102);\nfloat d104=Sdf_D(d5,d6);\nfloat d105=Sdf_U(d8,d10); //105 box ch con circulo //d7=box\nfloat d106=Sdf_I(d104,d105);\nfloat d107=Sdf_D(d7,d9);\n\nd107=Sdf_D(d107,d6);\nd107=Sdf_U(d107,d106);\n\n\nvec3 c1=vec3(0.76,0.549,0.4);\nvec3 c2=vec3(0.466,0.2627,0.0274);\n\ncolout= DFB(c1, colout,d101); //cuerpo\ncolout= DFB(c1, colout,d103); //pata frente\ncolout= DFB(c1, colout,d106);\ncolout= DFB(c1, colout,d107); //pata atras\n\nfloat d108=Sdf_I(d11,d12); //oreja\nd108=Sdf_U(d108,d18);\n\nfloat d109=Sdf_D(d13,d14);//cabeza\nd109=Sdf_I(d109,d15);\n\nfloat d110=Sdf_U(d20,d22);\nd110=Sdf_U(d110,d21);\n\ncolout= DFB(c2, colout,d108); //oreja\ncolout= DFB(c1, colout,d109); //cabeza\ncolout= DFB(vec3(0.0,0.0,0.0), colout,d16); //nariz\ncolout= DFB(vec3(0.0,0.0,0.0), colout,d17); //ojo\ncolout= DFB(vec3(0.0,0.0,0.0), colout,d19); //boca\n\ncolout= DFB(c1, colout,d110); //cola\n    return colout;\n}\n\n//https://www.shadertoy.com/view/XclcDX //by GregRostami\nvec4 lluvia(vec4 o, vec2 q)\n{   o = vec4( iResolution*5.0, fract(tan(q*3.)) );\n    o += -o.a * 20. / (mod(o.a * (-o.y) * (iTime+2.5), o.x) - q.y)*2.0 - o; \n    \n    return o;    \n}\n\nvec3 monte(vec2 p, vec3 colout, vec2 FC)\n{\n    \n    float t=iTime;\n    \n    float d1=p.y+0.5*sin(10.88+p.x+2.0*sin(p.x)+2.*cos(p.x*2.0))-1.17;\n    colout= DFB(vec3(0.0,0.5,0.0), colout, d1); \n    vec4 frag;\n    vec3 col2=lluvia(frag,FC-vec2(0.0,1.0)).xyz;\n    colout= DFB(col2, colout, (-p.y-d1+0.75)); \n    return colout;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 FC )\n{   vec2 uv = ( 2. * FC - iResolution.xy ) / iResolution.y;\n    uv-=vec2(-1.75,-0.9);\n    float esc=0.5;\n    uv*=esc;\n    vec2 uv0=uv;\n   \n    vec3 col;\n    col=monte(uv*2.0,col,FC);\n    \n    \n    vec3 col3 = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    col=(col-col3);\n    \n    \n    uv.x-=0.3;\n    uv.y+=0.2;\n    col=canino(uv-vec2(0.6,0.0),col);\n    col=canino(vec2(-uv.x, uv.y)+vec2(0.6,0.0),col);\n    \n    col=pow(col,vec3(1.0/2.2));\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//iq\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n\n\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n\n\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);  }\n\n\n\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r;}\n\n\n\nfloat divf(float a, float b)\n{\n    //evita crash por 1/0.0 =Infinito=error, en compilar\n    if(b==0.0)\n    {b=0.00001;}\n    return a/b;\n}\n\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{  vec2 pa = p-a, ba = b-a;\n    float h = clamp( divf( dot(pa,ba),dot(ba,ba)), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[],"code":"///---por jorge2017a2\n//referencia el grupo de shadertoy\n\n#define PI acos(-1.)\n#define PIH (PI * .5)\n#define TAU (PI * 2.)\n\nfloat pi = 3.14159265359;\nfloat tau = 2.0 * 3.14156592;\n\nfloat note( float n ) { return 440.0 * pow( 2.0, ( n-49.0) / 12.0 ); }\n\nvec2 ssaw(float t, float f) {\n    float m = fract(t * f);\n    vec2 s = vec2(\n        m + fract(t * f * 1.015) + 0.5 * fract(t * f * 0.98),\n        m + fract(t * f * 0.985) + 0.5 * fract(t * f * 1.02)\n    );\n    s *= 0.5;\n    return s;\n}\n\nfloat amplitudeEnvelope(float time) {\n    float attack = 0.05;  // Shorter attack time for smoother transitions\n    float sustain = 1.0;\n    float release = 0.05;  // Shorter release time for smoother transitions\n    float sustainTime = 0.4;  // Adjusted to fit within the note duration\n\n    float envelope = smoothstep(0.0, attack, time);\n\n    if (time > attack && time < attack + sustainTime) {\n        envelope = sustain;\n    }\n\n    if (time > attack + sustainTime) {\n        envelope = sustain * smoothstep(attack + sustainTime + release, attack + sustainTime, time);\n    }\n\n    return envelope;\n}\n\nfloat melody01(float time) {\n    float notes[] = float[](56.0, 59.0, 23.0, 59.0, 57.0, 57.0, 56.0, 56.0, 54.0, 54.0, 23.0, 59.0);\n    int numNotes = 12;\n    \n    float noteDuration = 0.5;  // Duration of each note in seconds\n    float melodyLength = float(numNotes) * noteDuration;\n    \n    // Wrap time to stay within the length of the melody\n    float wrappedTime = mod(time, melodyLength);\n    \n    int index = int(floor(wrappedTime / noteDuration));\n    return notes[index];\n}\n\nvec2 mainSound(int samp, float time) {\n    float noteDuration = 0.5;  // Duration of each note in seconds\n    float currentNote = melody01(time);\n    float nextNote = melody01(time + noteDuration);  // Get the next note for crossfade\n    float freqCurrent = note(currentNote);\n    float freqNext = note(nextNote);\n\n    float vari = 1.0;\n    float t2 = time * vari;\n\n    vec2 superSawWaveCurrent = ssaw(t2, freqCurrent);\n    vec2 superSawWaveNext = ssaw(t2, freqNext);\n\n    // Calculate the crossfade factor\n    float crossfadeFactor = smoothstep(0.0, 1.0, fract(time / noteDuration));\n\n    // Apply the crossfade between the current and next notes\n    vec2 superSawWave = mix(superSawWaveCurrent, superSawWaveNext, crossfadeFactor);\n\n    float elapsedTime = mod(time, noteDuration);\n    float amplitude = amplitudeEnvelope(elapsedTime);  // Ensure envelope cycles correctly\n    superSawWave *= amplitude;\n\n    return superSawWave;\n}\n","name":"Sound","description":"","type":"sound"}]}