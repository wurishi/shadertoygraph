{"ver":"0.1","info":{"id":"wslBDM","date":"1588482039","viewed":277,"name":"Day13: Cubic Bezier Patches","username":"fluxatron","description":"Why does it run so bad? :'(\n\nIncreasing NUM_VERTS exponentially increases compile and frame time. And it's worse on even numbers of verts...\n\nImproved perf here: https://www.shadertoy.com/view/wslBDM\n","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["bezier","cubic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define DIM_VERTS 3\n\n#define MAX_STEPS 50\n#define MAX_DIST 50.0\n#define SURFACE_DIST 0.005\n\n// TYPES ///////////////////////////////////////////////////////////////////////////////////////////////////\n\nstruct Tri\n{\n    vec3 a, b, c;\n};\n\nstruct Ray\n{\n    vec3 Origin;\n    vec3 Direction;\n};\n/*struct Material\n{\n    vec3 Color;\n};\n*/\nstruct Light\n{\n    vec3 Pos;\n    vec3 Color;\n    float Intensity;\n};\n    \nstruct Hit\n{\n    float Dist;\n    vec3 Color;\n};\n\nstruct BezierControl\n{\n    vec2 Vertex; // Position of vertex\n    vec2 Handle; // Vector defining handle direction and length\n};\n    \n    \n// DATA ///////////////////////////////////////////////////////////////////////////////////////////////////\n    \nconst int DIM_SEGS = DIM_VERTS-1;\n\nconst int NUM_SEGS = DIM_SEGS*DIM_SEGS;\nconst int NUM_TRIS = DIM_SEGS*DIM_SEGS*2;\nconst int NUM_VERTS = DIM_VERTS*DIM_VERTS;\n\nTri[NUM_TRIS] _tris;\nvec3[NUM_VERTS] _vertices;\n\n\n// ACES Tonemap: https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl ////////////////////////////////////\nconst mat3 ACESInputMat  = mat3(0.59719, 0.07600, 0.02840,    0.35458, 0.90834, 0.13383,    0.04823, 0.01566, 0.83777);\nconst mat3 ACESOutputMat = mat3(1.60475, -0.10208, -0.00327, -0.53108, 1.10813, -0.07276,  -0.07367, -0.00605,  1.07602);\nvec3 RRTAndODTFit(vec3 v) { return (v * (v + 0.0245786) - 0.000090537) / (v * (0.983729 * v + 0.4329510) + 0.238081); }\nvec3 ACESFitted(vec3 color) { return clamp(ACESOutputMat * RRTAndODTFit(ACESInputMat * color), 0.0, 1.0); }\n\n    \n// SHAPES ////////////////////////////////////////////////////////////////////////////////////////////////\n\n// udTriangle - https://iquilezles.org/articles/distfunctions\nfloat dot2( vec3 v ) { return dot(v,v); }\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nvec2 SampleBezier(vec2 a, vec2 b, vec2 c, vec2 d, float t)\n{\n    // First degree\n    vec2 p11 = mix(a, b, t);\n    vec2 p12 = mix(b, c, t);\n    vec2 p13 = mix(c, d, t);\n\n    // Second degree\n    vec2 p21 = mix(p11, p12, t);\n    vec2 p22 = mix(p12, p13, t);\n\n    // Third degree\n    return mix(p21, p22, t);\n}\n\n\n// SCENE ///////////////////////////////////////////////////////////////////////////////////////////////////\nHit GetDist(vec3 p)\n{\n    Hit closest; // TODO try combining vec4(color, dist) and see if mix speeds up intersections\n    closest.Dist = 999999.;\n    closest.Color = vec3(1);\n    \n    float dist = 999999.;\n    \n    // Tri surface\n    {\n        const vec3 col = vec3(1);\n        for (int i = 0; i < NUM_TRIS; i++)\n        {\n            dist = udTriangle(p, _tris[i].a, _tris[i].b, _tris[i].c) - 0.01;\n            if (dist < closest.Dist)\n            {\n                closest.Dist = dist;\n                closest.Color = col;\n            }\n        }\n    }\n    \n    \n    // Vertices\n    {\n        const vec3 col = vec3(1);\n        for (int i = 0; i < NUM_VERTS; i++)\n        {\n            dist = length(p-_vertices[i]) - 0.03;\n            if (dist < closest.Dist)\n            {\n                closest.Dist = dist;\n                closest.Color = col;\n            }\n        }\n    }\n   \n    \n    // Plane\n    {\n        vec3 col = vec3(.5,.5,.5);\n        dist = p.y+0.5; // ground at y=0\n\t\tif (dist < closest.Dist)\n        {\n            closest.Dist = dist;\n            closest.Color = col;\n        }\n    }\n    \n    return closest;\n}\n\nvec3 GetNormal(vec3 p)\n{\n    float d = GetDist(p).Dist;\n    float offset = 0.01;\n    vec3 n = d - vec3(\n        GetDist(p - vec3(offset,0,0)).Dist,\n        GetDist(p - vec3(0,offset,0)).Dist,\n        GetDist(p - vec3(0,0,offset)).Dist\n        );\n    \n    return normalize(n);\n}\n\nHit RayMarch(Ray r)\n{\n    Hit lastHit;\n    float totalDist = 0.0;\n    \n    for (int i=0; i<MAX_STEPS; i++)\n    {\n        vec3 p = r.Origin + totalDist*r.Direction;\n        lastHit = GetDist(p);\n        totalDist += lastHit.Dist;\n        \n        if (totalDist < SURFACE_DIST || totalDist > MAX_DIST) \n            break;\n    }\n    \n    lastHit.Dist = totalDist;\n    \n    return lastHit;\n}\n\nvec3 GetLight(vec3 p, Light light)\n{\n    vec3 PL = light.Pos-p;\n    float PLLen = length(PL);\n    \n    vec3 lightNormal = PL/PLLen;\n    vec3 surfNormal = GetNormal(p);\n    \n    // Light\n    float strength = clamp(dot(surfNormal, lightNormal), 0., 1.);\n    float attenuation = 1. / max(PLLen*PLLen, 0.001);\n\n    // Shadow\n    Ray shadow;\n    shadow.Origin = p + surfNormal*SURFACE_DIST*2.;\n    shadow.Direction = lightNormal;\n    if(RayMarch(shadow).Dist < PLLen) strength = 0.0;\n    \n    return light.Intensity * light.Color * strength * attenuation;\n}\n\nmat3 RotateXZ(float rad)\n{\n    float cosr = cos(rad);\n    float sinr = sin(rad);\n    return mat3(\n        cosr,  0,  sinr,\n        0,     1,  0,\n        -sinr, 0,  cosr);\n}\n\n\n// MAIN ////////////////////////////////////////////////////////////////////////////////////////////////////\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.yy; // map to center:(0, 0), topright:(aspect/2, 0.5)\n    \n    // Camera\n    Ray r;\n    r.Origin = vec3(0, 1.3, -3.1);\n    r.Direction = normalize(vec3(uv.x, uv.y-0.7, 1.5));\n    \n    \n    // Build scene\n    {\n        mat3 R = RotateXZ(iTime*0.2);\n        \n\t\tBezierControl seg1a = BezierControl(vec2(-1, 0), vec2(-.3,-0.7) + vec2(0, 0.2*sin(iTime+1.))); \n        BezierControl seg1b = BezierControl(vec2(1,  0), vec2(.3, -.3) + vec2(0, 0.2*cos(iTime+1.)));\n        \n        BezierControl seg2a = BezierControl(vec2(-1, 0), vec2(-.5,-.2) + vec2(0, 0.2*sin(iTime))); \n        BezierControl seg2b = BezierControl(vec2(1,  0), vec2(.5, -.2) + vec2(0, 0.2*cos(iTime)));\n        \n        // Verts\n        int index = 0;\n        for (int z = 0; z < DIM_VERTS; z++)\n        {\n            float v = float(z)/float(DIM_VERTS-1);\n\t\t\tv = v*2. - 1.; // transform to [-1,1]\n            \n            for (int x = 0; x < DIM_VERTS; x++)\n            {\n                float u = float(x)/float(DIM_VERTS-1);\n                vec2 u0 = SampleBezier(seg1a.Vertex, seg1a.Handle, seg1b.Handle, seg1b.Vertex, u);\n                vec2 u1 = SampleBezier(seg2a.Vertex, seg2a.Handle, seg2b.Handle, seg2b.Vertex, u);\n\n                vec2 xy = mix(u0, u1, v) + vec2(0,.35);\n \t\t\t\t_vertices[index++] = R*vec3(xy, v);\n            }\n        }\n        \n        // Tris\n        {\n\t\t\tfor (int i = 0; i < NUM_TRIS; i+=2)\n            {\n                //int i = 1;\n                int baseIndex = i/2;\n                int base = (baseIndex/DIM_SEGS)*DIM_VERTS + baseIndex%DIM_SEGS;\n                vec3 a = _vertices[base];\n                vec3 b = _vertices[base + 1];\n                vec3 c = _vertices[base + DIM_VERTS + 1];\n                vec3 d = _vertices[base + DIM_VERTS];\n\n                _tris[i] = Tri(a,b,c);\n                _tris[i+1] = Tri(c,d,a);\n            }\n        }\n    }\n   \n    \n    // Hit scene\n    Hit hit = RayMarch(r);\n    vec3 p = r.Origin + r.Direction*hit.Dist; // intersection point\n    \n    \n    // Direct Light\n    vec3 directLight = vec3(0);\n    {\n        Light l1;\n        l1.Pos = vec3(0, 2, 0) + 5.0;// * vec3(0.5*sin(iTime), 1.0, 0.5*cos(iTime));\n        l1.Color = vec3(1.0,0.5,0.4);\n        l1.Intensity = 50.0;\n\n        /*Light l2;\n        l2.Pos = vec3(5, 5, -5);\n        l2.Color = vec3(1.0,0.7,0.5);\n        l2.Intensity = 0.5;*/\n\n        directLight += hit.Color * GetLight(p, l1);\n    \t//directLight += GetLight(p, l2);\n    }\n    \n    \n    // Ambient Light\n    vec3 ambient = hit.Color * 0.8*vec3(0.02,0.02,0.08);\n    \n    \n    // Compose colour\n    vec3 col = ambient + vec3(directLight);\n    \n    \n    // Post\n    col *= 1.0; // exposure bias\n  \tcol = ACESFitted(col); // tonemap \n   \tcol = pow(col, vec3(1.0/2.2)); // gamma\n\n    \n\tfragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}