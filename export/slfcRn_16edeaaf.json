{"ver":"0.1","info":{"id":"slfcRn","date":"1647424699","viewed":2190,"name":"mount grids primitive sdf3frame","username":"cxm","description":"mount grids primitive sdf3frame","likes":5,"published":3,"flags":0,"usePreview":0,"tags":["grid","cineshader"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat opRep( in vec3 p, in vec3 c, float df )\n{\n    vec3 q = mod(p+0.5*c,c )-0.5*c;\n    return sdBoxFrame( q, vec3( .1 * cos( df * .1 ) ), .01 + sin( df * .2 ) * .01 );\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y + .1;\n}\n\nvec3 rX(in vec3 p, float a) {\n\tfloat c,s;vec3 q=p;\n\tc = cos(a); s = sin(a);\n\treturn vec3(p.x, c * q.y - s * q.z, s * q.y + c * q.z);\n}\n\nvec3 rY(in vec3 p, float a) {\n\tfloat c,s;vec3 q=p;\n\tc = cos(a); s = sin(a);\n\treturn vec3(c * q.x + s * q.z, p.y, -s * q.x + c * q.z);\n}\n\nfloat map(in vec3 p) {\n\n    vec2 res = vec2(sdPlane(p), 1.0);\n    \n    float rotX = iTime * 2. + p.x * .2;\n    float rotY = iTime * 2. + p.z * .2;\n    \n    p.y += cos( iTime * .1 ) * .5;\n    \n    vec3 p2 = rY(rX(p, rotX), rotY);\n    \n    \n    float d = opRep( p + p2 * .05, vec3( .1 ), .1 );\n    \n    // smooth min\n    float a = res.x;\n    float b = d;\n    // blending power : 0. to 1.\n    float k = .5;\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n\n    res = vec2(mix( b, a, h ) - k*h*(1.0-h), 3.0);\n    \n    \n    return res.x;\n}\n\n//\n// Calculate the normal by taking the central differences on the distance field.\n//\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005;\n    return normalize(\n        e.xyy * map(p + e.xyy) +\n        e.yyx * map(p + e.yyx) +\n        e.yxy * map(p + e.yxy) +\n        e.xxx * map(p + e.xxx));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n\n    vec2 q = (fragCoord.xy - .5 * iResolution.xy ) / iResolution.y;\n\n    float an = iTime * .1;\n\tvec3 ro = vec3( sin( an ), 2., cos( an ) );\n    vec3 ta = vec3( 0.0, 0.0, 0.5 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( q.x*uu + q.y*vv + 1.5*ww );\n\n\n    // March the distance field until a surface is hit.\n    float h, t = 1.;\n    for (int i = 0; i < 32; i++) {\n        h = map(ro + rd * t);\n        t += h;\n        if (h < 0.01) break;\n    }\n\n    if (h < 0.01) {\n        vec3 p = ro + rd * t;\n        vec3 normal = calcNormal(p);\n        vec3 light = vec3(0, 2, 0);\n        \n        // Calculate diffuse lighting by taking the dot product of \n        // the light direction (light-p) and the normal.\n        float dif = clamp(dot(normal, normalize(light - p)), 0., 1.);\n\t\t\n        // Multiply by light intensity (5) and divide by the square\n        // of the distance to the light.\n        dif *= 5. / dot(light - p, light - p);\n        \n        \n        fragColor = vec4(vec3(pow(dif, 0.9)), 1);     // Gamma correction\n    } else {\n        fragColor = vec4( vec3( .1 ), 1. );\n    }\n}","name":"Image","description":"","type":"image"}]}