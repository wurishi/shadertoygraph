{"ver":"0.1","info":{"id":"lsjyzK","date":"1493036085","viewed":202,"name":"IIS 3D Compound Parabolic Ex","username":"soma_arc","description":"Render the orbit of spheres with Iterated Inversion System.\nCompound Parabolic Generator.\nParallel Translation + Rotation","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","sphere","kleiniangroups"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nCreated by soma_arc - 2017\nThis work is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported.\n*/\n\n// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(vec2 co, float sampleIndex) {\n\tvec2 seed = co * (sampleIndex + 1.0);\n\tseed+=vec2(-1,1);\n\t// implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n\treturn vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                 fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\n\nvec3 sphereInvert(vec3 pos, vec4 sphere){\n\tvec3 diff = pos - sphere.xyz;\n    float d = length(diff);\n\treturn (diff * sphere.w * sphere.w)/(d * d) + sphere.xyz;\n}\n\nconst float EPSILON = 0.0001;\nconst float PI = 3.14159265;\nconst float PI_2 = 3.14159265 / 2.;\n\nvec3 calcRay (const vec3 eye, const vec3 target, const vec3 up, const float fov,\n              const float width, const float height, const vec2 coord){\n  float imagePlane = (height * .5) / tan(fov * .5);\n  vec3 v = normalize(target - eye);\n  vec3 xaxis = normalize(cross(v, up));\n  vec3 yaxis =  normalize(cross(v, xaxis));\n  vec3 center = v * imagePlane;\n  vec3 origin = center - (xaxis * (width  *.5)) - (yaxis * (height * .5));\n  return normalize(origin + (xaxis * coord.x) + (yaxis * (height - coord.y)));\n}\n\nconst vec4 K = vec4(1.0, .666666, .333333, 3.0);\nvec3 hsv2rgb(float h, float s, float v){\n  vec3 p = abs(fract(vec3(h) + K.xyz) * 6.0 - K.www);\n  return v * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), s);\n}\n\nbool intersectBox(vec3 rayOrg, vec3 rayDir, vec3 boxMin, vec3 boxMax,\n                  out float hit0, out float hit1, out bool inBox) {\n\tfloat t0 = -1000000.0, t1 = 1000000.0;\n    hit0 = t0;\n    hit1 = t1;\n    inBox = false;\n    vec3 tNear = (boxMin - rayOrg) / rayDir;\n    vec3 tFar  = (boxMax - rayOrg) / rayDir;\n    \n    if (tNear.x > tFar.x) {\n        float tmp = tNear.x;\n        tNear.x = tFar.x;\n        tFar.x = tmp;\n    }\n    \n    t0 = max(tNear.x, t0);\n    t1 = min(tFar.x, t1);\n\n    \n    if (tNear.y > tFar.y) {\n        float tmp = tNear.y;\n        tNear.y = tFar.y;\n        tFar.y = tmp;\n    }\n    t0 = max(tNear.y, t0);\n    t1 = min(tFar.y, t1);\n\n    if (tNear.z > tFar.z) {\n        float tmp = tNear.z;\n        tNear.z = tFar.z;\n        tFar.z = tmp;\n    }\n    t0 = max(tNear.z, t0);\n    t1 = min(tFar.z, t1);\n\n    if (t0 <= t1 && 0. < t1) {\n        if(t0 < 0.) inBox = true;\n        hit0 = t0;\n        hit1 = t1;\n        return true;\n    }\n    return false;\n}\n\nbool intersectPlane(vec3 rayOrigin, vec3 rayDir, int objId,\n                    vec3 center, float size, mat3 rotation,\n                    inout int hitObjId,\n                    inout float minDist, inout vec3 normal, inout vec3 col) {\n    vec3 n = rotation * vec3(0, 0, 1);\n    vec3 xAxis = rotation * vec3(1, 0, 0);\n    vec3 yAxis = rotation * vec3(0, 1, 0);\n    float d = -dot(center, n);\n    float v = dot(n, rayDir);\n    float t = -(dot(n, rayOrigin) + d) / v;\n    if(0.001 < t && t < minDist){\n        vec3 p = rayOrigin + t * rayDir;\n        float hSize = size * .5;\n        float x = dot(p - center, xAxis);\n        float y = dot(p - center, yAxis);\n        if(-hSize <= x && x <= hSize &&\n           -hSize <= y && y <= hSize ){\n            if((-hSize <= x && x <= hSize &&\n               -hSize/4. <= y && y <= hSize/4.) ||\n              (-hSize/4. <= x && x <= hSize/4. &&\n               -hSize <= y && y <= hSize)){\n            \tcol = vec3(1);\n            }else{\n            \tcol = vec3(0);\n            }\n\t\t\tminDist = t;\n            normal = n;\n            hitObjId = objId;\n            return true;\n        }\n    }\n    return false;\n}\n\nconst vec4 baseSphere = vec4(0, 0, 0, 125);\nconst vec4 s1 = vec4(300, 300, 0, 300);\nconst vec4 s2 = vec4(300, -300, 0, 300);\nconst vec4 s3 = vec4(-300, 300, 0, 300);\nconst vec4 s4 = vec4(-300, -300, 0, 300);\nconst vec4 s5 = vec4(0, 0, 424.26, 300);\nconst vec4 s6 = vec4(0, 0, -424.26, 300);\nconst float s1r2 = s1.w * s1.w;\nconst float s2r2 = s2.w * s2.w;\nconst float s3r2 = s3.w * s3.w;\nconst float s4r2 = s4.w * s4.w;\nconst float s5r2 = s5.w * s5.w;\nconst float s6r2 = s6.w * s6.w;\n\n// (zPos, distance, twist, size)\nvec4 planes;\n\nconst int MAX_KLEIN_ITARATION = 8;\nfloat distIIS(vec3 pos, out float loopNum){\n    pos -= vec3(0, 0, 0);\n  \tfloat dr = 1.;\n  \tbool loopEnd = true;\n  \tfloat scalingFactor= 0.2;\n  \tloopNum = 0.;\n  \tfor(int i = 0 ; i < MAX_KLEIN_ITARATION ; i++){\n  \t\tloopEnd = true;\n    \t\n        if(pos.z < -planes.x || planes.x < pos.z){\n        \tpos.z += planes.x;\n            float nn = abs(floor(pos.z/(planes.y)));\n        \tloopNum += nn;\n            pos.z = mod(pos.z, planes.y);\n        \tpos.z -= planes.x;\n            \n            float theta = -(planes.z * nn);\n            float cosTheta = cos(theta);\n            float sinTheta = sin(theta);\n            mat3 m = mat3(cosTheta, -sinTheta, 0,\n                          sinTheta, cosTheta, 0,\n                           0, 0, 1);\n            pos = m * pos;\n        }\n            \n        if(distance(pos, s1.xyz) < s1.w){\n            vec3 diff = (pos - s1.xyz);\n      \t\tdr *= s1r2 / dot(diff, diff);\n      \t\tpos = sphereInvert(pos, s1);\n      \t\tloopEnd = false;\n      \t\tloopNum++;\n        }else if(distance(pos, s2.xyz) < s2.w){\n            vec3 diff = (pos - s2.xyz);\n      \t\tdr *= s2r2 / dot(diff, diff);\n      \t\tpos = sphereInvert(pos, s2);\n      \t\tloopEnd = false;\n      \t\tloopNum++;\n        }else if(distance(pos, s3.xyz) < s3.w){\n            vec3 diff = (pos - s3.xyz);\n      \t\tdr *= s3r2 / dot(diff, diff);\n      \t\tpos = sphereInvert(pos, s3);\n      \t\tloopEnd = false;\n      \t\tloopNum++;\n        }else if(distance(pos, s4.xyz) < s4.w){\n            vec3 diff = (pos - s4.xyz);\n      \t\tdr *= s4r2 / dot(diff, diff);\n      \t\tpos = sphereInvert(pos, s4);\n      \t\tloopEnd = false;\n      \t\tloopNum++;\n        }else if(distance(pos, s5.xyz) < s5.w){\n            vec3 diff = (pos - s5.xyz);\n      \t\tdr *= s5r2 / dot(diff, diff);\n      \t\tpos = sphereInvert(pos, s5);\n      \t\tloopEnd = false;\n      \t\tloopNum++;\n        }else if(distance(pos, s6.xyz) < s6.w){\n            vec3 diff = (pos - s6.xyz);\n      \t\tdr *= s6r2 / dot(diff, diff);\n      \t\tpos = sphereInvert(pos, s6);\n      \t\tloopEnd = false;\n      \t\tloopNum++;\n        }\n        \n    \tif(loopEnd == true) break;\n    }\n\n    return (distance(pos, baseSphere.xyz) - baseSphere.w) / abs(dr) * scalingFactor;\n}\n\nvec3 getNormal(const vec3 p){\n\tconst vec2 d = vec2(1., 0.);\n    float loopNum;\n\treturn normalize(vec3(distIIS(p + d.xyy, loopNum) - distIIS(p - d.xyy, loopNum),\n                          distIIS(p + d.yxy, loopNum) - distIIS(p - d.yxy, loopNum),\n                          distIIS(p + d.yyx, loopNum) - distIIS(p - d.yyx, loopNum)));\n}\n\n\nconst vec3 LIGHT_DIR = normalize(vec3(1, 1, 0));\n\nint MAX_MARCH = 500;\nvec3 calcColor(float time, vec3 eye, vec3 rayDir){\n  \tvec3 l = vec3(0);\n\n    vec3 rayPos = eye;\n    float dist;\n    float rayLength = 0.;\n    bool hit = false;\n    float loopNum;\n    \n    float t0, t1;\n    bool inBox;\n    float bboxSize = 500.;\n    vec3 bboxMin = vec3(-bboxSize, -bboxSize, -90000);\n    vec3 bboxMax = vec3(bboxSize, bboxSize, 90000);\n    \n    bool hitBBox = intersectBox(eye, rayDir, bboxMin, bboxMax, t0, t1, inBox);\n    \n    vec3 normal;\n    mat3 rotation = mat3(1, 0, 0,\n                     0, 1, 0,\n                     0, 0, 1);\n    \n    float cosTheta = cos(planes.z);\n    float sinTheta = sin(planes.z);\n    mat3 twist = mat3(cosTheta, -sinTheta, 0,\n                      sinTheta, cosTheta, 0,\n                      0, 0, 1);\n    float minDist = 99999999.;\n    int objId = -1;\n    vec3 pCol = vec3(0);\n    intersectPlane(eye, rayDir, 1, vec3(0, 0, planes.x), planes.w,\n                   rotation, objId, minDist, normal, pCol);\n    intersectPlane(eye, rayDir, 1, vec3(0, 0, -planes.x), planes.w,\n                   rotation * twist, objId, minDist, normal, pCol);\n    if(hitBBox == false && objId == -1) return vec3(0);\n\n    \n    if(!inBox){\n    \trayLength = t0;\n        rayPos = eye + rayDir * rayLength;\n    }\n    t1 = min(t1, minDist);\n    int marchNum = 0;\n    for(int i = 0 ; i < MAX_MARCH ; i++) {\n        if(rayLength > t1) break;\n        marchNum = i;\n    \tdist = distIIS(rayPos, loopNum);\n        \n        rayLength += dist;\n        rayPos = eye + rayDir * rayLength;\n        if(dist < 0.08){\n            hit = true;\n            break;\n        }\n    }\n    \n    if(hit || objId != -1){\n        vec3 mCol;\n        if(!hit){\n        \tmCol = mix(vec3(0, 0, 7), vec3(1), pCol.x);\n        }else{\n        \tif(loopNum == 0.)\n        \t\tmCol = hsv2rgb(0.33, 1., .77);\n    \t\telse\n        \t\tmCol = hsv2rgb(0.0 + loopNum * 0.1 , 1., 1.);\n        \tnormal = getNormal(rayPos);\n        }\n        const vec3 AMBIENT_FACTOR = vec3(.1);\n        vec3 diffuse =  clamp(dot(normal, LIGHT_DIR), 0., 1.) * mCol;\n    \tvec3 ambient = mCol * AMBIENT_FACTOR;\n        l += ambient + diffuse;\n    }\n    \n  \treturn l.rgb;\n}\n\nconst float DISPLAY_GAMMA_COEFF = 1. / 2.2;\nvec3 gammaCorrect(vec3 rgb) {\n  return vec3((min(pow(rgb.r, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.g, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.b, DISPLAY_GAMMA_COEFF), 1.)));\n}\n\n\n//w: start time\n//s: duration\nfloat scene(in float t, in float w, in float s){\n    return clamp(t - w, 0.0, s) / s;  \n}\n\n\nfloat expEasingIn(float t){\n    return pow( 2., 13. * (t - 1.) );\n}\nfloat expEasingOut(float t) {\n\treturn -pow( 2., -10. * t) + 1.;\n}\n\nfloat circEasingInOut(float t){\n\tt /= .5;\n\tif (t < 1.) return -.5 * (sqrt(1. - t*t) - 1.);\n\tt -= 2.;\n\treturn .5 * (sqrt(1. - t*t) + 1.);\n}\n\nconst vec3 up = vec3(0, 1, 0);\nfloat fov = radians(60.);\nconst float SAMPLE_NUM = 1.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    float r = 800.;\n    float t = mod(iTime, PI * 12.) * .5;\n    \n    //planes = vec4(posZ, distance, twist, size);\n    planes.x = 350. + 80. * sin(iTime);\n    planes.y = 2. * planes.x;\n    planes.z = (PI/2.) * sin(iTime);\n    planes.w = 800.;\n    vec3 center = vec3(0, 0, 0);\n    vec3 target = vec3(0, 0, 1000. * cos(t ));\n    /*\n    vec3 eye = vec3(500. * sin(iTime) , r * cos(iTime), \n                    300. * cos(iTime) ) + center;\n\n    \teye = vec3(600. * sin(t), 300. * cos(t), \n                   0. * cos(t) ) + center;\n\t*/\n    vec3 eye;\n    float start = PI;\n    float dur = 1.;\n    eye = mix(vec3(1200, 700, 0), vec3(500, 400, 300), \n             (scene(t, start, dur)));\n    planes.w = mix(800., 1., scene(t, start, dur));\n\n    start += dur + PI;\n    dur = 3.;\n\teye = mix(eye, vec3(500, 400, 1200), \n             scene(t, start, dur));\n\n    start += dur + PI;\n  \teye = mix(eye, vec3(1200, 700, 0), \n             scene(t, start, dur));\n    planes.w = mix(planes.w, 800.,\n                  scene(t, start, dur));\n\n    vec3 sum = vec3(0);\n    \n  \tfor(float i = 0. ; i < SAMPLE_NUM ; i++){\n    \tvec2 coordOffset = rand2n(gl_FragCoord.xy, i);\n    \tvec3 ray = calcRay(eye, target, up, fov,\n        \t               iResolution.x, iResolution.y,\n            \t           gl_FragCoord.xy + coordOffset);\n          \n    \tsum += calcColor(t, eye, ray);\n\t}\n\tvec3 col = (sum/SAMPLE_NUM);\n\n\tfragColor = vec4(gammaCorrect(col), 1.);\n}","name":"Image","description":"","type":"image"}]}