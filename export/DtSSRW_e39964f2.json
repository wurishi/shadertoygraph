{"ver":"0.1","info":{"id":"DtSSRW","date":"1675841040","viewed":219,"name":"Recursive RayTracer - Da Revenge","username":"foodini","description":"Third attempt at faking recursion and object-orientation/polymorphism in GLSL.... which lacks these almost crucial features. See top-of-file comments for details. IF ANYTHING IS MISSING FROM THE TODO LIST, LEAVE A COMMENT!!!","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["refraction","raytrace","recursion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nOkay, there's still a lot to do, but this gets the proof-of-concept out of the way.\n\nFirst, the checklist of what works;\n* \"Recursive\" ray tracing.\n* Reflection and refraction of nested objects. This only works if the interior\n  objects' indices of refraction are specified relative to their parent. A sphere\n  of ior 1.8 inside a 1.5 is specified with an ior of 1.8/1.5.\n* \"Barf-o-morphism\" I want to just keep a list of objects, each of which knows its\n  type. You just write the intersection function for an object type (and, \n  eventually, provide texturing info) and you don't have to think about anything else.\n* Fresnel reflection. Glass objects don't _just_ refract. Some of the light that\n  hits the glass surface is reflected. It's a complicated interaction that involves\n  the polarization of light and it's not worth getting into here. Frankly, I can't\n  even say I barely understand it. I'm operating on faith here.\n\n\nGLSL has no recursion. \"Recursive\" ray-tracers generally work by replacing a ray,\nwhen it hits a refractive surface, with one ray that goes through the object surface\nand one that reflects off of it. These two rays are computed by a self call to a \ntrace() function... which you can't do in glsl.\n\nInstead, I just have a list of unprocessed rays. Each ray knows how much of the final\ncolor it contributes. For example, if a ray passes through a filter, the ray that\ncomes out the other side knows that whatever it hits in the end, only a fraction of\nthe surface's color will be used for the pixel color. Each time a ray hits a filter\nof any kind, new rays are generated with more and more attenuation.\n\nI have no idea how to explain this properly. It's too late at night for that. Hit me\nup in the comments and I'll try to make sense of it. In the meantime, enjoy the todo\nlist:\n\n\nTODO: \n* I want to get transmissive attenuation working. Glass isn't transparent. It\n  slightly impedes photons as they pass through. I want blue glass and red glass\n  and grey glass.\n* Add lighting and visible lights. This is easy, easy stuff.\n* Add shadows. This is easy, but I'm going to skip it to go straight to attempting....\n* Caustics? This is not, by any measure, even remotely easy. As I write this comment,\n  the scene is entirely static, so I could accumulate a lightmap texture over hundreds\n  of frames and produce a good caustic. I'm wondering if I can do something in real\n  time with some dynamic geometry.\n  \n  It can't be entirely insane. The scene here is (at the time of writing) throwing\n  nine rays per pixel for antialiasing. I don't need more than 4 unless depth-of-field\n  is on. If the texture to which I render the caustic is about the same size as the\n  screen and I throw about 4-9 rays per lightmap pixel, my rendering time will roughly\n  double. (I may turn off Fresnel reflection for caustics.)\n* Frequency-based refraction? This would cost a fortune. A ray would have to encode\n  more than r,g,b, it would have to encode a gamut of frequencies in the visible spectrum.\n  Each refraction would generate one new rays FOR EACH FREQUENCY instead of just 1-2.\n* Depth of Field is currently not working because my random function is generating the\n  same rays repeatedly and not blurring the background.\n* I want to be apply any texture to any object. This may not be possible in the long\n  run, but a sphere, a plane, and an isomorph should all be refractable, perlin-able,\n  etc.\n* Add perlin textures, bump mapping, normal mapping. \n* Video textures?\n* More interesting objects. Geometric, parametric, and...? Possibly terrain, though \n  that's a stretch. Isomorphs (blobs) definitely. Doing blobs means supporting just\n  about any raymarched geometry which provides a lot of options, but is insanely\n  expensive.\n* CONSTRUCTIVE SOLID GEOMETRY!\n* Subsurface scattering? Just shoot me.\n*/\n\nstruct Object {\n    int   type;\n    vec3  vec3_prop_0;\n    \n    float float_prop_0;\n    \n    int   texture_index;\n};\n\nstruct Texture {\n    int   texture_type;  // REFLECT, REFRACT, MAND, etc.\n    vec3  reflective_attenuation;    // reflective attenuation\n    float ior;\n};\n\nconst int max_objects = 10;\nint constructed_obj_count = 0;\nObject objects[max_objects];\n\nconst int max_textures = 10;\nint constructed_texture_count = 0;\nTexture textures[max_textures];\n\n// For Spheres:\nconst int SPHERE_TYPE = 0;\n#define sphere_pos             vec3_prop_0\n#define sphere_radius          float_prop_0\n\n// For Planes:\nconst int PLANE_TYPE = 1;\n#define plane_normal           vec3_prop_0\n#define plane_displacement     float_prop_0\n\nconst int REFLECT = 0;\nconst int REFRACT = 1;\nconst int MAND    = 2;\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nconst float PI = 3.1415926538;\nconst float EULER = 2.71828183;\nint rand_seed = 2987492621;\n// THIS SUCKS and is making antialiasing terrible.\nfloat rand(in vec2 co){\n    int chaos = int(co.x * 867530.9 * (PI + iTime) + co.y * 555236.8 * (EULER + iTime));\n    rand_seed += chaos;\n    rand_seed *= 1664525;\n    rand_seed += 1013904223;\n    return abs(float(rand_seed) / float(2147483647));\n}\n\nfloat sphere_dist(in Object sphere, in Ray ray) {\n    vec3 OC = sphere.sphere_pos - ray.origin;\n    float len_OC_squared = dot(OC, OC);\n    float r_squared = sphere.sphere_radius*sphere.sphere_radius;\n    float Tca;\n    float Tca_squared;\n    float Thc_squared;\n    \n    Tca = dot(OC, ray.dir);\n\n    // Is the ray origin outside the sphere?\n    if(len_OC_squared >= r_squared) {\n        // Does the ray point away from the sphere?\n        if(Tca < 0.0) {\n            return -1.0;\n        } else {\n            Tca_squared = Tca * Tca;\n            Thc_squared = r_squared - len_OC_squared + Tca_squared;\n        }\n        // Does the ray miss the sphere?\n        if(Thc_squared < 0.0)\n            return -1.0;\n        return Tca - sqrt(Thc_squared);\n    } else {\n        Tca_squared = Tca * Tca;\n        Thc_squared = r_squared - len_OC_squared + Tca_squared;\n        return Tca + sqrt(Thc_squared);\n    }\n}\n\nfloat plane_dist(in Object plane, in Ray ray) {\n    float Vprd = dot(plane.plane_normal, ray.dir);\n    float Vpro = -(dot(plane.plane_normal, ray.origin) + plane.plane_displacement);\n    float t = Vpro / Vprd;\n    if(t>0.0)\n        return t;\n    return -1.0;\n}\n\nfloat dist_to_obj(Object obj, in Ray ray) {\n    if(obj.type == SPHERE_TYPE) {\n        return sphere_dist(obj, ray);\n    } \n    if(obj.type == PLANE_TYPE) {\n        return plane_dist(obj, ray);     \n    }\n}\n\nvec3 mand(in vec3 p) {\n    //return vec3(0.5);\n    //return grid(p);\n\n    //mandel (&intersect, raycolor, .003, 0.14707684544406, 0.651762543252595, \"blues.map\");\n    //void mandel (Point3 *p, col color, double scale, double ztrans, double xtrans, char *filename)\n    vec2 c = vec2(p.x, p.z) * 0.003;// * (0.0005 + pow(sin(iTime/15.0), 2.0));\n    c += vec2(0.1382309, 0.643002);\n    vec2 z = c;\n    vec2 zn;\n    \n    for(float i=0.; i<500.; i++) {\n        if(dot(zn,zn) >= 4.0) {\n            float d = i + 1. - log(log(length(zn)))/log(2.);\n            return vec3(\n                (1.0+sin((iTime*5. + d)/17.))/2.0,\n                (1.0+cos((iTime*7. + d)/13.))/2.0,\n                (1.0+sin((iTime*11. + d)/11.))/2.0\n                );\n        } else {\n            zn = mat2(zn,-zn.y,zn.x) * zn + c;\n    \t\tz = zn;\n        }\n    }\n    return vec3(0.0);\n}\n\nstruct RayContext {\n    Ray ray;\n    vec3 contribution;\n};\nconst int max_contexts = 10;\nint num_contexts = 0;\nRayContext contexts[max_contexts];\n\nbool push(in Ray ray, in vec3 contribution) {\n    if(num_contexts == max_contexts)\n        return false;\n    \n    contexts[num_contexts].ray = ray;\n    contexts[num_contexts].contribution = contribution;\n    num_contexts++;\n    \n    return true;\n}\n\nbool pop(out Ray ray, out vec3 transmissive_attenuation, out vec3 contribution) {\n    if(num_contexts == 0)\n        return false;\n    \n    num_contexts--;\n    ray = contexts[num_contexts].ray;\n    contribution = contexts[num_contexts].contribution;\n    \n    return true;\n}\n\n// Returns a normal that points toward the ray source. Reflection, refraction, and lighting all\n// depend upon this assumption. Refraction requires that we know if we're entering or exiting\n// the object, so we return that information as well.\n// TODO: save the dot product by taking a bool that tells the function whether or not it's needed.\nvec3 get_normal(in Object object, in vec3 ray_dir, in vec3 intersect_point, out bool incident_upon_exterior) {\n    vec3 normal;\n    \n    if(object.type == SPHERE_TYPE) {\n        normal = normalize(intersect_point - object.sphere_pos);\n    } else {\n        normal = object.plane_normal;\n    }\n    incident_upon_exterior = (dot(ray_dir, normal) < 0.0);\n    if(!incident_upon_exterior)\n        normal = -normal;\n    \n    return normal;\n}\n\nfloat max_vec3(in vec3 i) {\n    return max(max(i.x, i.y), i.z);\n}\n\n// Fresnel is very costly to compute. I should just replace this with a cheap approximation.\n// https://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-to-shading/reflection-refraction-fresnel.html\nfloat fresnel_reflection_fraction(in vec3 ray_dir, in vec3 normal, in float ior) {\n    //return false;\n    \n    float cosi = dot(ray_dir, normal);\n    float etai;\n    float etat;\n    if (cosi < 0.0) {\n        etai = 1.0;\n        etat = ior;\n    } else {\n        etai = ior;\n        etai = 1.0;\n    }\n    \n    float sint = etai / etat * sqrt(max(0.0, 1.0 - cosi * cosi));\n    if(sint >= 1.0)\n        return 1.0;\n    \n    float cost = sqrt(max(0.0, 1.0 - sint * sint));\n    cosi = abs(cosi);\n    float Rs = ((etat * cosi) - (etai * cost)) / ((etat * cosi) + (etai * cost));\n    float Rp = ((etai * cosi) - (etat * cost)) / ((etai * cosi) + (etat * cost));\n    \n    return (Rs * Rs + Rp * Rp) / 2.0;\n}\n\nvoid push_reflection_ray(Ray ray, vec3 normal, vec3 intersect_point, vec3 contribution) {\n    if(max_vec3(contribution) > 0.005) {\n        Ray new_ray;\n        new_ray.dir = reflect(ray.dir, normal); // _SHOULDN'T_ need normalizing.....\n        new_ray.origin = intersect_point + normal * 0.001;\n        push(new_ray, contribution);\n    }\n}\n\nvoid push_refraction_ray(\n        Ray ray, vec3 normal, vec3 intersect_point, vec3 contribution, float ior) {\n    float eta = 1.0/ior;\n    if(max_vec3(contribution) > 0.005) {\n        Ray new_ray;\n        new_ray.dir = refract(ray.dir, normal, eta); // _SHOULDN'T_ need normalizing.....\n        if(dot(new_ray.dir, new_ray.dir) == 0.0) {\n            // This is the \"total internal reflection\" case. glsl reflect() returns a zero vector for\n            // this situation, so we have to make it ourselves:\n            push_reflection_ray(ray, normal, intersect_point, contribution);\n        } else {\n            new_ray.origin = intersect_point - normal * 0.001;\n            push(new_ray, contribution);\n        }\n    }\n}\n\nvec3 process_texture(in Object nearest, in Ray ray, in float nearest_dist, vec3 current_contribution) {\n    vec3 intersect_point;\n    \n    Texture object_texture = textures[nearest.texture_index];\n    \n    if(nearest.type != -1) {\n        intersect_point = ray.origin + ray.dir * nearest_dist;\n    } else {\n        //nothing hit\n        float sky_blue = ray.dir.y;\n        float sky_rg = pow(sky_blue, 3.0);\n        return vec3(sky_rg, sky_rg, sky_blue);\n    }\n\n    bool incident_upon_exterior = true;\n    vec3 normal = get_normal(nearest, ray.dir, intersect_point, incident_upon_exterior);\n\n    if(object_texture.texture_type == MAND) {\n        return mand(intersect_point);\n    } else if(object_texture.texture_type == REFLECT) {\n        push_reflection_ray(\n            ray, normal, intersect_point, current_contribution * object_texture.reflective_attenuation);\n    } else if (object_texture.texture_type == REFRACT) {\n        float ior = object_texture.ior;\n        if(!incident_upon_exterior)\n            ior = 1.0/ior;\n        float reflection_fraction = fresnel_reflection_fraction(ray.dir, normal, ior);\n        //if(intersect_point.z > 0.0)\n        //    return vec3(reflection_fraction);\n        if(reflection_fraction > 0.002) {\n            vec3 reflection_contribution = \n                reflection_fraction * current_contribution * object_texture.reflective_attenuation;\n            push_reflection_ray(ray, normal, intersect_point, reflection_contribution);\n        } \n        // NOTE!!! We're currently not doing any transmissive attenuation, so you could infinitely\n        //         recurse here.\n        reflection_fraction = 0.0;\n        if(reflection_fraction < 0.998) {\n            vec3 refraction_contribution = (1.0 - reflection_fraction) * current_contribution;\n            push_refraction_ray(ray, normal, intersect_point, refraction_contribution, ior);\n        }\n    }\n    \n    return vec3(0.0);\n}\n\nvec3 trace() {\n    //TODO: track the index so you do less unnecessary copying?\n    Object nearest;\n    float nearest_dist = 1e10;\n    int nearest_index;\n    \n    bool traversed;\n    \n    Ray ray;\n    vec3 transmission;    \n    vec3 current_contribution = vec3(1.0);\n\n    vec3 accumulated_texture = vec3(0.0);\n    \n    int ray_count = 0;\n\n    while(pop(ray, transmission, current_contribution)) {\n        nearest.type = -1;\n        nearest_index = -1;\n        \n        for(int obj_index=0; obj_index<=constructed_obj_count; obj_index++) {\n            float dist = dist_to_obj(objects[obj_index], ray);\n            if(dist > 0.0) {\n                if(nearest.type == -1 || dist < nearest_dist) {\n                    nearest = objects[obj_index];\n                    nearest_dist = dist;\n                    nearest_index = obj_index;\n                }\n            }\n        }\n\n        accumulated_texture += current_contribution * process_texture(\n            nearest, ray, nearest_dist, current_contribution);\n        \n        // REMEMBER that the max ray count is no the max recursion depth, but the max number of\n        // rays tested for a single pixel. Two nested spheres can requrie 50 or more at current\n        // limits.\n        if(++ray_count == 25)\n            return accumulated_texture;\n    }\n\n    return accumulated_texture;\n}\n\n// WARNING! The argument names here are being affected by the preprocessor, so you may\n//          get compile errors that reference \"float_prop_0\", etc.\nvoid add_sphere(in vec3 sphere_pos, in float sphere_radius, in int texture_index) {\n    if(constructed_obj_count == max_objects)\n        return;\n        \n    objects[constructed_obj_count].type = SPHERE_TYPE;\n    objects[constructed_obj_count].sphere_pos = sphere_pos;\n    objects[constructed_obj_count].sphere_radius = sphere_radius;\n    objects[constructed_obj_count].texture_index = texture_index;\n    constructed_obj_count++;\n}\n\n// WARNING! The argument names here are being affected by the preprocessor, so you may\n//          get compile errors that reference \"float_prop_0\", etc.\nvoid add_plane(in vec3 plane_normal, in float plane_displacement, in int texture_index) {\n    if(constructed_obj_count == max_objects)\n        return;\n        \n    objects[constructed_obj_count].type = PLANE_TYPE;\n    objects[constructed_obj_count].plane_normal = plane_normal;\n    objects[constructed_obj_count].plane_displacement = plane_displacement;\n    objects[constructed_obj_count].texture_index = texture_index;\n    constructed_obj_count++;\n}\n\n// Make a set of texture functinos that don't take all args\nint add_texture(in int texture_type, in vec3 reflective_attenuation, in float ior) {\n    textures[constructed_texture_count].texture_type = texture_type;\n    textures[constructed_texture_count].reflective_attenuation = reflective_attenuation;\n    textures[constructed_texture_count].ior = ior;\n    return constructed_texture_count++;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    int large_sphere_tex_index = add_texture(REFRACT, vec3(0.7), 1.5);\n    int small_sparse_sphere_tex_index = add_texture(REFRACT, vec3(0.98), 0.8/1.5);\n    int small_dense_sphere_tex_index = add_texture(REFRACT, vec3(0.98), 1.5/1.8);\n    int mandelbrot_tex_index = add_texture(MAND, vec3(0.0), 0.0);\n\n    add_sphere(vec3( 0.0,  0.0,  0.0),  1.0,  large_sphere_tex_index);\n    //add_sphere(vec3( 1.0,  0.0,  0.0),  1.0,  large_sphere_tex_index);\n    \n    \n    add_sphere(vec3(-0.51, 0.0,  0.0),  0.25, small_dense_sphere_tex_index);\n    add_sphere(vec3( 0.51, 0.0,  0.0),  0.25, small_dense_sphere_tex_index);\n    add_sphere(vec3( 0.0,  0.0,  0.51), 0.25, small_sparse_sphere_tex_index);\n    add_sphere(vec3( 0.0,  0.0, -0.51), 0.25, small_sparse_sphere_tex_index);\n    add_sphere(vec3( 0.0,  0.51, 0.0),  0.25, small_sparse_sphere_tex_index);\n    add_sphere(vec3( 0.0, -0.51, 0.0),  0.25, small_sparse_sphere_tex_index);\n    \n    add_sphere(vec3( 0.0,  0.0,  0.0),  0.25, small_sparse_sphere_tex_index);\n    \n    \n\n    add_plane( vec3( 0.0,  1.0, 0.0), 2.0, mandelbrot_tex_index);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 screen_space = uv * 2.0 - 1.0;\n    screen_space.x *= (iResolution.x/iResolution.y);\n\n    float cos2 = cos(iTime/4.0);\n    \n    vec3 cam_position = vec3(3.3 * sin(iTime/2.0), 1.3 + 1.5 * sin(iTime/10.0), 3.3 * cos(iTime/2.0));\n    //cam_position = vec3(-3.0, 1.0, -3.0);\n    \n    float dist_to_pix_plane = 3.0;\n    float pix_plane_height = 2.0;\n    vec3 cam_look_at = vec3(0.0);\n    vec3 cam_look_dir = dist_to_pix_plane * normalize(cam_look_at - cam_position);\n    \n    vec3 right = cross(vec3(0.0, 1.0, 0.0), cam_look_dir);\n    right = (pix_plane_height / 2.0) * normalize(right);\n    vec3 up = cross(cam_look_dir, right);\n    up = (pix_plane_height / 2.0) * normalize(up);\n    \n    vec3 pixel_width = right/iResolution.x;\n    vec3 pixel_height = up/iResolution.y;\n    \n    // You can get away with an aa level of 4ish if you turn off depth-of-field. Once\n    // I have lighting working, the DOF effect won't be so impactful and can be turned\n    // down.\n    float antialias_level = 9.0;\n    float depth_of_field_intensity = 15.0;\n    \n    \n    vec3 out_color = vec3(0.0);\n    Ray ray;\n    for(float aa=0.0; aa<antialias_level; aa+=1.0) {\n        vec3 ray_screen_isect_point = cam_position + cam_look_dir + \n            (screen_space.x * right) + (screen_space.y * up);\n        \n        ray_screen_isect_point += pixel_width * (rand(uv*(aa+1.0) * 2.0 - 1.0));\n        ray_screen_isect_point += pixel_height * (rand(uv*(aa+1.5) * 2.0 - 1.0));\n\n        ray.origin = cam_position;\n        if(depth_of_field_intensity > 0.0) {\n            ray.origin += depth_of_field_intensity * pixel_width * (rand(uv*(aa+1.0) * 2.0 - 1.0));\n            ray.origin += depth_of_field_intensity * pixel_height * (rand(uv*(aa+1.0) * 2.0 - 1.0));                 \n        }\n\n        ray.dir = normalize(ray_screen_isect_point - ray.origin);\n\n        push(ray, vec3(1.0));\n        out_color += trace();\n    }\n    out_color /= float(antialias_level);\n\n\n    // do a bit of fake gamma correcting as we output:\n    fragColor = vec4(\n        pow(out_color.x, 0.7),\n        pow(out_color.y, 0.7),\n        pow(out_color.z, 0.7),\n        1.0);\n}","name":"Image","description":"","type":"image"}]}