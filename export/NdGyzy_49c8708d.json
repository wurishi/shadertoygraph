{"ver":"0.1","info":{"id":"NdGyzy","date":"1655042847","viewed":35,"name":"circle thing 1.1","username":"chungaloid","description":"i saw this concept somewhere else but i can't find it. consider this idea plagiarised. obviously i did it better though","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["parametric"],"hasliked":0,"parentid":"7dVyWz","parentname":"circle thing 1"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\nconst float masterCircles = 6.;\n\n\nvec2 map(float t, vec2 gridCoord) {\n    vec2 p = vec2(cos(gridCoord.x*t), sin(gridCoord.y*t));\n    p.x *= clamp(50.*gridCoord.x, 0., 1.); // set x=0 for left master column (otherwise x=1, which is not centred)\n    return p;\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat segmentDist( in vec2 p, in vec2 a, in vec2 b ) // stolen\n{\n\tvec2 pa = p - a, ba = b - a;\n\treturn dot2( pa - ba*clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 ) );\n}\nfloat gridDist(vec2 point, vec2 gridOrigin, float cellWidth, float borderWidth) {\n    vec2 q = mod(point - gridOrigin,  cellWidth);\n    return min(q.x, q.y) - borderWidth;\n}\n\n// stolen\n// splits the parametric curve into line segments and finds the min distance between the point and each\n// thanks for the descriptive variable names mr quilez it really helped me understand what this code was doing yes i know it helps compile time but it doesn't really actually matter here\n// jk thanks for the code <3\nfloat curveDist(vec2 localCoord, vec2 gridCoord, float trailHeadT, float trailLength, bool onlyTrail)\n{\n    int segments = onlyTrail? 50 : 200;\n    \n    float segLength = (onlyTrail? -trailLength : 2.*PI*masterCircles)/float(segments);\n\tfloat t = trailHeadT;//0.0;\n     \n    vec2 segStart = map(t, gridCoord);\n    \n    float minDist = dot2(localCoord - segStart);\n    \n    t += segLength;\n    for( int i=0; i < segments; i++ )\n    {\n        vec2 segEnd = map(t, gridCoord);\n        \n        float segDist = segmentDist(localCoord, segStart, segEnd);\n        minDist = min( minDist, segDist );\n        \n\t\tt += segLength;\n        segStart = segEnd;\n\t}\n    \n\treturn sqrt(minDist);\n}\n\n\nbool vec2Eq(vec2 a, vec2 b, float tol) {\n    return abs(a.x - b.x) < tol && abs(a.y - b.y) < tol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv =  (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    vec2 mouse = (-iResolution.xy + 2.0*iMouse.xy)/iResolution.y;\n\n    vec3 col = vec3(0.);\n    \n    \n    float gridBorder = 0.013; //0.08 * (cos(iTime)+1.);\n    float cellWidth = (2. - gridBorder) / (1. + masterCircles);\n    float gd = gridDist(uv, vec2(-1., -1.), cellWidth, gridBorder);\n    \n    #if 1\n    if (gd <= 0. && uv.x <= 1. && uv.x >= -1.)\n        col = vec3(0.5);\n    \n    // stronger border for master circles\n    if (gd <= 0. && (\n           (uv.x <= -1. + cellWidth + gridBorder && uv.x >= -1.) ||\n           (uv.y >= 1. - cellWidth - gridBorder && uv.x >= -1. && uv.x <= 1.)\n       ))\n        col = vec3(1.); \n        \n    #endif\n       \n       \n    vec2 gridCoord0 = ((masterCircles+1.) / (2. - gridBorder)) * (uv - vec2(-1., 1.)) + vec2(0., 1.);\n    vec2 gridCoord = vec2(1., -1.)*floor(gridCoord0)/masterCircles; // (0,0) is top left; (1, 1) is bottom right\n    \n    \n    vec2 localCoord = (mod(uv - vec2(-1., 1.), cellWidth) - vec2(gridBorder, 0.))/(cellWidth-gridBorder);//normalised from 0 to 1 for each cell\n    localCoord = 2.*localCoord - vec2(1.);// transform to normalised between -1 and 1\n    \n    \n    \n    if (abs(uv.x) <= 1.) {\n        float time = 2.*PI*iTime;\n    \n        vec2 coord = 1.5 * localCoord;\n        \n        const float radius = 0.1;\n        const float falloff = 50.;\n        \n        float trailDist = curveDist(coord, gridCoord, time, min(time, 1.75*PI), true);        \n        float trailColAlpha = clamp(-falloff*(trailDist-radius), 0., 1.);\n        vec3 trailCol = vec3(trailColAlpha);\n        \n        vec3 curveCol = vec3(0.);\n        if (trailColAlpha < 0.1) {\n            float curveDist = curveDist(coord, gridCoord, 0., 0., false);        \n            float curveColAlpha = clamp(-falloff*(curveDist-radius), 0., 1.);\n            curveCol = vec3(0.3*curveColAlpha);\n        }        \n        \n        float circleDist = length(map(time, gridCoord) - coord);\n        float circleColAlpha = clamp(-falloff*(circleDist-2.*radius), 0., 1.);\n        vec3 circleCol = circleColAlpha*vec3(\n            clamp(100.*gridCoord.x, 0., 1.), \n            0.9 * clamp(100.*gridCoord.y, 0., 1.), \n            0.5);\n        \n        col += (curveCol+trailCol)*(1.-circleColAlpha) + circleCol;\n            \n        col *= clamp(-50.*min(gridCoord.x, gridCoord.y)+1., 0.95, 1.); // make non-master cells slightly darker\n    }\n    \n    \n    \n    //if (length(mouse - uv) <= 0.2) \n    //    col = vec3(0., 1., 0.);\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}