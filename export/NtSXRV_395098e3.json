{"ver":"0.1","info":{"id":"NtSXRV","date":"1628021152","viewed":98,"name":"Raycasted Forest Test","username":"Koulatko","description":"Testing intersections against a large grid of randomly offset objects using bounding volumes. Somewhat similar to one-point-per-cell voronoi.\n\nWASD + space + shift + F to move\nMouse to rotate","likes":5,"published":1,"flags":48,"usePreview":0,"tags":["procedural","3d","forest","learning"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec3 triplanar(sampler2D tex, vec3 p, vec3 d){\n    vec3 X = texture(tex, p.yz).xyz;\n    vec3 Y = texture(tex, p.xz).xyz;\n    vec3 Z = texture(tex, p.xy).xyz;\n    \n    vec3 w = abs(d);\n    w /= dot(w, vec3(1.0));\n    \n    return w.x*X + w.y*Y + w.z*Z;\n    \n    return mat3(X,Y,Z)*w;\n}\n\n\nvec4 ray_grid(vec3 ro, vec3 rd, out int obj_id){\n    const float epsilon = 0.0001;\n    float depth = 0.0;\n    float stepsize = 1.0;\n    //Could use some optimization\n    for(int i = 0; i < 50; i++){\n        vec3 p = fract(ro + (depth)*rd);\n        vec3 F = floor(ro + depth*rd);\n        \n        if(length(F.xy) < 36.0){\n        \n            vec4 hash = hash42(F.xy);\n            float rad = 0.2 + 0.15*hash.w*hash.z;\n\n            vec3 in_cell = rad+(1.0-2.0*rad)*hash.xyz;\n\n            in_cell.z = 1.0+sqrt(1600.0-dot(F.xy, F.xy));\n\n            vec4 h;\n            vec4 h1;\n            int obj_id_tmp;\n            h1 = ray_sphere(ro-vec3(F.xy, 0.0)-in_cell, rd, rad);\n            if(h1.w > 0.0 && (h1.w < h.w || h.w <= 0.0)){\n                h = h1;\n                obj_id_tmp = 1;\n            }\n            \n            h1 = ray_cylinder(ro-vec3(F.xy, 0.0), rd, in_cell-vec3(0.0, 0.0, 3.0), in_cell, rad/4.0);\n            if(h1.w > 0.0 && (h1.w < h.w || h.w <= 0.0)){\n                h = h1;\n                obj_id_tmp = 2;\n            }\n            \n            if(h.w > 0.0){obj_id = obj_id_tmp; return h;};\n        \n        }\n        vec3 o = 1.0 - max(vec3(0.0), sign(-rd));\n        float q1 = min(\n            -(p.x-o.x)/rd.x,\n            -(p.y-o.y)/rd.y\n            );\n        \n        depth += q1+epsilon;\n    }\n    return vec4(0.0);\n}\n\nvec4 ray_scene(vec3 ro, vec3 rd, out int obj_id, out vec3 N){\n    vec4 h;\n    vec4 h1;\n    ro /= 2.0;\n    h1 = ray_grid(ro, rd, obj_id);\n    if(h1.w > 0.0 && (h1.w < h.w || h.w <= 0.0)){\n        h = h1;\n    }\n    \n    h1 = ray_sphere(ro, rd, 40.0);\n    if(h1.w > 0.0 && (h1.w < h.w || h.w <= 0.0)){\n        h = h1;\n        obj_id = 3;\n    }\n    h.w *= 2.0;\n    N = h.xyz;\n    return h;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 ss = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    vec3 ro = texelFetch(iChannel3, ivec2(0,0), 0).xyz;\n    \n    vec4 camera_angle_texel = texelFetch(iChannel3, ivec2(1,0), 0);\n    float pitch = camera_angle_texel.y;\n    float yaw = camera_angle_texel.x;\n    \n    vec3 right = vec3(sin(yaw), -cos(yaw), 0.0);\n    vec3 up = vec3(-cos(yaw)*sin(pitch), -sin(yaw)*sin(pitch), cos(pitch));\n    vec3 forward = vec3(cos(yaw)*cos(pitch), sin(yaw)*cos(pitch), sin(pitch));\n\n    vec3 rd = normalize(right*ss.x + up*ss.y + forward);\n    \n    vec3 lin;\n    \n    int obj_id;\n    vec3 N;\n    vec4 h1 = ray_scene(ro, rd, obj_id, N);\n    \n    if(h1.w > 0.0){\n        vec3 diff;\n        if(obj_id == 1) diff = vec3(0.0, 0.6, 0.0);\n        if(obj_id == 2) diff = vec3(0.5, 0.25, 0.0);\n        if(obj_id == 3) diff = vec3(0.1, 0.05, 0.0);\n       \n        vec3 illum;\n        vec3 L = vec3(1.0, 1.0, 1.0);\n        L = normalize(L);\n        \n        int trashi;\n        vec3 trash3;\n        vec4 shadow_cast = ray_scene(ro+h1.w*rd+0.001*N, L, trashi, trash3);\n        if(shadow_cast.w <= 0.0){\n            illum += vec3(1.5, 1.4, 1.3)*max(0.0, dot(N, L));\n        }\n        illum += vec3(0.1, 0.15, 0.2);\n        \n        lin = illum*diff;\n    }\n    \n    lin = mix(lin, vec3(0.4, 0.6, 0.9), h1.w <= 0.0 ? vec3(1.0) : vec3(1.0)-exp(-0.1*vec3(0.4, 0.5, 0.6)*h1.w));\n    \n    vec3 col = pow(lin, vec3(1.0/2.2));\n    \n    fragColor = vec4(col,1.0);\n    \n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = 3.14159265358;\n\n//WASD+space+shift+F to move\n//Mouse to rotate camera\n\n\nvec4 ray_plane(vec3 ro, vec3 rd, vec4 plane){\n    float a = dot(plane.xyz, rd);\n    float b = dot(plane.xyz, ro) - plane.w;\n    return vec4(plane.xyz, max(0.0, -b/a));\n}\nvec4 ray_sphere(vec3 ro, vec3 rd, float R){\n    float d = dot(-ro, rd);\n    vec3 p = ro+d*rd;\n    float s = R*R-dot(p, p);\n    if(s < 0.0) return vec4(-1.0);\n    float o = sqrt(s);\n    float t = d - o;\n    return vec4(normalize(ro+t*rd), t);\n}\nvec4 ray_box(vec3 ro, vec3 rd, vec3 A, vec3 B){\n    vec3 sgn = max(vec3(0.0), sign(rd));\n    vec3 cN = mix(B, A, sgn);\n    vec3 cF = mix(A, B, sgn);\n    vec3 qA = (cN-ro)/rd;\n    vec3 qB = (cF-ro)/rd;\n    float tN = max(qA.x, max(qA.y, qA.z));\n    float tF = min(qB.x, min(qB.y, qB.z));\n    if(tN > tF) return vec4(-1.0);\n    float t = tN > 0.0 ? tN : tF;\n    vec3 nrm = sign(rd)*vec3(\n    qA.x == tN ? 1.0 : 0.0,\n    qA.y == tN ? 1.0 : 0.0,\n    qA.z == tN ? 1.0 : 0.0\n    );\n    return vec4(nrm, t);\n}\n\n\n\n\n\n\n\n//Credit to Inigo Quilez (https://iquilezles.org/articles/intersectors)\nvec4 ray_cylinder( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, float ra ){\n    vec3 ca = pb-pa;\n    vec3 oc = ro-pa;\n    float caca = dot(ca,ca);\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    float a = caca - card*card;\n    float b = caca*dot( oc, rd) - caoc*card;\n    float c = caca*dot( oc, oc) - caoc*caoc - ra*ra*caca;\n    float h = b*b - a*c;\n    if( h<0.0 ) return vec4(-1.0); //no intersection\n    h = sqrt(h);\n    float t = (-b-h)/a;\n    // body\n    float y = caoc + t*card;\n    if( y>0.0 && y<caca ) return vec4( (oc+t*rd-ca*y/caca)/ra, t );\n    // caps\n    t = (((y<0.0)?0.0:caca) - caoc)/card;\n    if( abs(b+a*t)<h ) return vec4( ca*sign(y)/caca, t );\n    return vec4(-1.0); //no intersection\n}\n\n\n\n\n\n\n\n\n\n\n\n// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    //W = 87\n    //S = 83\n    //D = 68\n    //A = 65\n    //space = 32\n    //shift = 16\n    \n    //0,0 = camera pos\n    //1,0 = camera_euler\n    //2,0 and 2,1 = temporary variable for camera rotation\n    bool is_start = iFrame == 0;\n    \n    ivec2 fc = ivec2(fragCoord);\n    vec4 cv = texelFetch(iChannel0, fc, 0);\n    vec4 nv = cv;\n    if(fc == ivec2(0,0)){ //Camera motion\n    \n        if(is_start){\n            fragColor = vec4(2.0, 0.0, 80.5, 0.0);\n            return;\n        }\n        \n        vec4 camera_angle_texel = texelFetch(iChannel0, ivec2(1,0), 0);\n        float pitch = camera_angle_texel.y;\n        float yaw = camera_angle_texel.x;\n        \n        vec3 off;\n        \n        float W = texelFetch(iChannel1, ivec2(87, 0), 0).x;\n        float S = texelFetch(iChannel1, ivec2(83, 0), 0).x;\n        float A = texelFetch(iChannel1, ivec2(65, 0), 0).x;\n        float D = texelFetch(iChannel1, ivec2(68, 0), 0).x;\n        float space = texelFetch(iChannel1, ivec2(32, 0), 0).x;\n        float shift = texelFetch(iChannel1, ivec2(16, 0), 0).x;\n        \n        float F = texelFetch(iChannel1, ivec2(70, 0), 0).x;\n        \n        vec3 hor_forward = vec3(cos(yaw), sin(yaw), 0.0); \n        vec3 hor_right = vec3(sin(yaw), -cos(yaw), 0.0);\n        \n        float spd = 2.0;\n        if(F > 0.0) spd *= 2.0;\n        if(W > 0.0){\n            nv.xyz += spd*iTimeDelta*hor_forward;\n        }\n        if(S > 0.0){\n           nv.xyz -= spd*iTimeDelta*hor_forward;\n        }\n        if(A > 0.0){\n            nv.xyz -= spd*iTimeDelta*hor_right;\n        }\n        if(D > 0.0){\n            nv.xyz += spd*iTimeDelta*hor_right;\n        }\n        if(space > 0.0){\n            nv.z += spd*iTimeDelta;\n        }\n        if(shift > 0.0){\n            nv.z -= spd*iTimeDelta;\n        }\n        \n        if(nv.z-sqrt(6400.0-dot(nv.xy,nv.xy)) < 0.5){ //Crude collision\n            nv.z = 0.5+sqrt(6400.0-dot(nv.xy,nv.xy));\n        }\n        \n    }\n    \n    //0 - increment per-frame, smoother\n    //1 - increment relative to last click, time-stable but stutters\n    \n    int mouse_mode = 0;\n    \n    \n    if(fc == ivec2(1,0)){\n        if(is_start){\n            fragColor = vec4(-0.3, 0.0, 0.0, 0.0);\n            return;\n        }\n        vec4 old_mouse = texelFetch(iChannel0, ivec2(2,0), 0);\n        vec4 anchor = texelFetch(iChannel0, ivec2(2,1), 0);\n        \n        if(old_mouse.z > 0.0){\n            if(mouse_mode == 0){\n                nv.xy = cv.xy - 1.5*vec2(1.0,-1.0)*(iMouse.xy - old_mouse.xy)/iResolution.y;\n                nv.x = mod(nv.x, 2.0*PI);\n                nv.y = clamp(nv.y, -0.5*PI, 0.5*PI);\n            }\n            if(mouse_mode == 1){\n                nv.xy = anchor.xy + 0.01*vec2(-1.0, 1.0)*(iMouse.xy - old_mouse.xy);\n            }\n            \n        }\n        \n    }\n    if(fc == ivec2(2,0)){\n        if(mouse_mode == 0){\n            nv = iMouse;\n        }\n        if(mouse_mode == 1){\n            if(iMouse.z != cv.z) nv = iMouse;\n        }\n    }\n    if(fc == ivec2(2,1)){\n        if(mouse_mode == 1){\n            vec4 old_mouse = texelFetch(iChannel0, ivec2(2,0), 0);\n            if(iMouse.z != old_mouse.z) nv = texelFetch(iChannel0, ivec2(1,0), 0);\n        }\n    }\n    \n    fragColor = nv;\n    \n    \n}\n\n\n\n\n\n\n","name":"Buffer D","description":"","type":"buffer"}]}