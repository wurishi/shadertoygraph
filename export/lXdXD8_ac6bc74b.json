{"ver":"0.1","info":{"id":"lXdXD8","date":"1718979987","viewed":38,"name":"amoeba - space","username":"Kenzodabarra","description":"on objkt","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["space","amoeba"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// space, amoeba \n// 06-21-2024\n// \n//\n//uniform samplerCube iChannel0; // Texture/sampler for cubemap\n\nconst float u_power = 4.0;\nconst float u_colore1 = 0.9;\nconst float u_colore2 = 0.0;\nconst float u_colore3 = 0.2;\n\nconst int maxIterations = 8;\nconst int maxIterationsRM = 100;\nconst float minDistance = 0.01;\nconst float maxDistance = 100.0;\nconst float voxelSize = 0.000001; // Size of each voxel\n\nvec3 colorGradient(float t) {\n    return vec3(sin(t * 0.3), sin(t * 0.5), sin(t * 0.7));\n}\n\n// Function for calculating Perlin noise in 3D\nfloat noise(vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f * f * (3.0 - 2.0 * f);\n\n    float n = p.x + p.y * 157.0 + 113.0 * p.z;\n    return mix(\n        mix(\n            mix(fract(sin(n) * 43758.5453),\n                fract(sin(n + 1.0) * 43758.5453), f.x),\n            mix(fract(sin(n + 157.0) * 43758.5453),\n                fract(sin(n + 158.0) * 43758.5453), f.x),\n            f.y\n        ),\n        mix(\n            mix(fract(sin(n + 113.0) * 43758.5453),\n                fract(sin(n + 114.0) * 43758.5453), f.x),\n            mix(fract(sin(n + 270.0) * 43758.5453),\n                fract(sin(n + 271.0) * 43758.5453), f.x),\n            f.y\n        ),\n        f.z\n    );\n}\n\nvec3 carraraMarbleTexture(vec3 pos) {\n    vec3 noiseInput = vec3(iTime * 0.1); \n    vec3 cp = vec3(\n        1.5 * noise(noiseInput + vec3(0.0)),\n        1.5 * noise(noiseInput + vec3(1.0)),\n        1.5 * noise(noiseInput + vec3(4.0))\n    );\n    float veins = noise(pos * length(cp));\n    float veinPattern = smoothstep(0.9, 0.7, veins) * sin(pos.z * 10.0 + veins * 5.0);\n    float veinDetail = noise(vec3(pos.xy * 2.0, pos.z * 50.0)) * 0.5;\n    veinPattern += veinDetail;\n    vec3 baseColor1 = vec3(u_colore1, u_colore2, u_colore3);\n    vec3 baseColor2 = vec3(u_colore2, u_colore3, u_colore1);\n    vec3 baseColor3 = vec3(u_colore3, u_colore1, u_colore2);\n    vec3 baseColor4 = vec3(u_colore1, u_colore1, u_colore3);\n    vec3 baseColor5 = vec3(u_colore2, u_colore2, u_colore2);\n    vec3 marbleColor = mix(baseColor1, baseColor2, smoothstep(0.0, 0.2, veinPattern));\n    marbleColor = mix(marbleColor, baseColor3, smoothstep(0.2, 0.4, veinPattern));\n    marbleColor = mix(marbleColor, baseColor4, smoothstep(0.4, 0.6, veinPattern));\n    marbleColor = mix(marbleColor, baseColor5, smoothstep(0.6, 0.8, veinPattern));\n    float detailNoise = noise(pos * 50.0) * 0.1;\n    marbleColor += detailNoise;\n    return marbleColor;\n}\n\n// Function for calculating the modified Mandelbulb with the Julia set\nfloat mandelbulbJulia(vec3 z, vec3 c) {\n    vec3 p = z;\n    float dr = 1.0;\n    float r = 0.0;\n\n    for (int i = 0; i < maxIterations; i++) {\n        r = length(p);\n        if (r > maxDistance) break;\n\n        // Convert to spherical coordinates\n        float theta = acos(p.z / r);\n        float phi = atan(p.y, p.x);\n\n        // Modify the Mandelbulb to generate a mountainous terrain with the Julia set\n        float power = u_power; // Control the \"mountainous\" and complexity\n        float zr = pow(r, power);\n        theta *= power;\n        phi *= power;\n        p = vec3(\n            zr * sin(theta) * cos(phi),\n            zr * sin(theta) * sin(phi),\n            zr * cos(theta)\n        ) + c;\n\n        dr = power * pow(r, power - 1.0) * dr + 1.0;\n    }\n\n    float distance = 1.5 * log(r) * r / dr;\n    return distance;\n}\n\n// Function for ray marching with voxelization for mountainous terrain\nfloat rayMarch(vec3 ro, vec3 rd, vec3 c) {\n    float d = 0.0;\n    for (int i = 0; i < maxIterationsRM; i++) {\n        vec3 p = ro + rd * d;\n\n        // Quantize the space into voxels\n        p = floor(p / voxelSize) * voxelSize;\n\n        // Calculate the distance from the origin using the modified Mandelbulb with the Julia set\n        float distance = mandelbulbJulia(p, c);\n\n        // Update the accumulated distance\n        d += distance;\n\n        // Break the ray marching if we are close enough to the surface\n        if (distance < minDistance || d > maxDistance) break;\n    }\n    return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    // Calculate the position of the orbiting camera\n    float cameraRadius = 1.3;\n    float cameraSpeed = 0.1;\n    float angle = iTime * cameraSpeed;\n    vec3 noiseInput = vec3(iTime * cameraSpeed); \n    vec3 cameraPos = vec3(\n        1.5 * noise(noiseInput + vec3(0.0)),\n        1.5 * noise(noiseInput + vec3(1.0)),\n        1.8 * noise(noiseInput + vec3(4.0))\n    );\n    vec3 cameraTarget = vec3(0.0, 0.0, 0.0);\n    vec3 cameraUp = vec3(0.0, 1.0, 0.0);\n\n    // Calculate the ray direction\n    vec3 forward = normalize(cameraTarget - cameraPos);\n    vec3 right = normalize(cross(forward, cameraUp));\n    vec3 up = cross(right, forward);\n    vec3 rayDir = normalize(forward + uv.x * right + uv.y * up);\n\n    // Constant for the Julia set\n    vec3 c = vec3(sin(angle), 0.0, cos(angle));\n\n    // Apply ray marching to get the distance from the surface\n    float distance = rayMarch(cameraPos, rayDir, c);\n\n    // Calculate the color based on the distance\n    vec3 color = vec3(0.0);\n    if (distance < maxDistance) {\n        // Calculate the intersection point of the ray\n        vec3 p = cameraPos + rayDir * distance;\n\n        // Calculate the normal to the fractal at the intersection point\n        vec3 normal = normalize(vec3(\n            mandelbulbJulia(p + vec3(minDistance, 0.0, 0.0), c) - mandelbulbJulia(p - vec3(minDistance, 0.0, 0.0), c),\n            mandelbulbJulia(p + vec3(0.0, minDistance, 0.0), c) - mandelbulbJulia(p - vec3(0.0, minDistance, 0.0), c),\n            mandelbulbJulia(p + vec3(0.0, 0.0, minDistance), c) - mandelbulbJulia(p - vec3(0.0, 0.0, minDistance), c)\n        ));\n\n        // Define materials and lighting\n        vec3 oro = vec3(1.0, 0.843, 0.0);\n        vec3 argento = vec3(0.8);\n        vec3 lightDir = normalize(vec3(sin(iTime), cos(iTime), 0.5 * sin(iTime)));\n        float diffuse = max(dot(normal, lightDir), 0.0);\n        vec3 diffuseColor = colorGradient(iTime * 0.1 + length(p)) * diffuse;\n\n        vec3 viewDir = normalize(cameraPos - p);\n        vec3 reflectionDir = reflect(-lightDir, normal);\n        float specular = pow(max(dot(viewDir, reflectionDir), 0.0), length(cameraPos));\n        vec3 specularColor = argento * specular;\n        vec3 carrara = carraraMarbleTexture(p);\n        vec3 color1 = carrara;\n        vec3 color2 = diffuseColor + specularColor;\n        color = mix(color1, color2, cameraPos);\n\n        // Add reflection using the cubemap\n        vec3 reflectedColor = texture(iChannel0, reflectionDir).rgb * 0.5;\n        color += reflectedColor;\n    }\n\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}