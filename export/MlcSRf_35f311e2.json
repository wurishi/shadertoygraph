{"ver":"0.1","info":{"id":"MlcSRf","date":"1480847429","viewed":386,"name":"voxel tracing 3D texture test","username":"SudoNhim","description":"it works using dark magics :)\n\nBasically I'm encoding the terrain as a 32 block high 3D texture, using the 32 bits from each RGBA pixel. The next step is to exploit this to do much more expensive terrain than I would be able to do on the fly.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159\n\n#define VOXEL_ERROR -2\n#define VOXEL_UNRESOLVED -1\n#define VOXEL_NONE  0\n#define VOXEL_WATER 1\n#define VOXEL_SAND  2\n#define VOXEL_EARTH 3\n#define VOXEL_STONE 4\n#define VOXEL_GRASS 5\n\n#define MAP_SIZE 256.0\n\n#define WATER_HEIGHT 2\n\n#define SUN_DIRECTION normalize(vec3(0.4, 0.6, 0.7))\n\nstruct VoxelHit\n{\n    ivec3 mapPos;    // world coords\n    int terrainType; // terrain type\n    vec2 volAccum;   // sum of (fog, water) along the ray path\n    vec3 hitRel;     // position of intersect relative to center of voxel\n    vec3 hitNormal;  // surface normal at intersect\n    float weight;    // contribution to the ray (fractional values come from anti-aliasing)\n};\n\nstruct VoxelMarchResult\n{\n    // we store the first two intersects for two purposes:\n    // 1) it allows the first voxel hit to be non-cube shaped (e.g. rounded edges)\n    // 2) it allows cheap anti-aliasing\n    VoxelHit first;\n    VoxelHit second;\n};\n\n// from https://www.shadertoy.com/view/4sfGzS\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n    vec2 uv = p.xy + f.xy;\n\tvec2 rg = vec2(texture( iChannel0, (uv+vec2(37.0,17.0)*p.z+0.5)/256.0, -100.0 ).x,\n                   texture( iChannel0, (uv+vec2(37.0,17.0)*(p.z+1.0)+0.5)/256.0, -100.0 ).x );\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nbool isBitSet(const vec4 data, int bit)\n{\n    int i = bit/8; \n    float fval;\n    if (i==0) fval = data[0];\n    else if (i== 1) fval = data[1]; // there must be a better way ;_;\n    else if (i== 2) fval = data[2];\n    else if (i== 3) fval = data[3];\n    int val = int(fval*255.0 + 0.5);\n    int p = int(pow(2.0, float(bit-i*8)));\n    return 2*(val/p/2) != val/p;\n}\n\n// isTerrainAt checks the bitmap for occupancy, cheaper than getTerrainTypeAt\nbool isTerrainAt(ivec3 ip)\n{ \n    if (ip.y < 0) ip.y = 0;\n    \n    // Map to volume on 2D texture\n    vec2 texelSize = 1.0 / iResolution.xy;\n    vec2 uv = (vec2(ip.xz*2+1)) * texelSize;\n    vec4 val = texture(iChannel2, uv);\n    return isBitSet(val, ip.y);\n}\n\nvec2 getOcclusionsAt(ivec3 ip)\n{\n    if (ip.y < 2) return vec2(0.0, 1.0);\n    else return vec2(0.0);\n    //float cloudiness = noise(vec3(ip)/8.0);\n    //return vec2(smoothstep(0.6, 0.7, cloudiness)*0.3 + 0.1, 0.0);\n}\n\nint getTerrainTypeAt(ivec3 ip)\n{  \n    if (ip.y < 0) ip.y = 0;\n    \n    // so this is like, grabbing the texture as a heightmap and\n    // then like twisting it in random directions as it goes up\n    // umm...\n    vec3 p = vec3(vec3(ip) + 0.5);\n    float theta = noise(p / 16.0) * PI * 2.0;\n    vec2 disp = vec2(cos(theta), sin(theta)) * p.y;\n    vec3 terr = texture(iChannel1, (p.xz + disp) / MAP_SIZE).rgb;\n\n    bvec3 contains = lessThanEqual(vec3(0.0), (terr - p.y/16.0));\n    \n    if (contains.x && contains.y && !contains.z) return VOXEL_SAND;\n    else if (contains.x && contains.z) return VOXEL_GRASS;\n    else if (contains.y && contains.z && !contains.x) return VOXEL_STONE;\n    else if (contains.x || contains.y || contains.z) return VOXEL_EARTH;\n\n    return VOXEL_NONE; \n}\n\nfloat dfVoxel(vec3 p, int terrainType)\n{\n    float r = 0.1;\n    if (terrainType == VOXEL_WATER) r = 0.0;\n    return length(max(abs(p)-vec3(0.5-r),0.0))-r;\n}\n\nvec3 nrmVoxel(vec3 p, int terrainType) \n{\n    vec2 dd = vec2(0.001,0.0);\n    float base = dfVoxel(p, terrainType);\n    return normalize(vec3(\n        dfVoxel(p+dd.xyy, terrainType) - base,\n        dfVoxel(p+dd.yxy, terrainType) - base,\n        dfVoxel(p+dd.yyx, terrainType) - base\n    ));\n}\n\nVoxelMarchResult voxelMarch(vec3 ro, vec3 rd) \n{\n    ivec3 mapPos = ivec3(floor(ro));\n    vec3 deltaDist = abs(vec3(length(rd)) / rd);\n    ivec3 rayStep = ivec3(sign(rd));\n    vec3 sideDist = (sign(rd) * (vec3(mapPos) - ro) + (sign(rd) * 0.5) + 0.5) * deltaDist; \n    vec2 volAccum = vec2(0.0);\n    float prevDist = 0.0;\n    \n    VoxelMarchResult result = VoxelMarchResult(\n        VoxelHit(ivec3(0), VOXEL_NONE, vec2(0.0), vec3(0.0), vec3(0.0), 0.0),\n        VoxelHit(ivec3(0), VOXEL_NONE, vec2(0.0), vec3(0.0), vec3(0.0), 0.0)\n        );\n\t\n    for (int i = 0; i < 128; i++) {\n\n        // water intersection\n        if (mapPos.y <= WATER_HEIGHT)\n        \tif (result.first.terrainType == VOXEL_NONE)\n            \tresult.first = VoxelHit(mapPos, VOXEL_WATER, volAccum, vec3(0.0), vec3(0.0), 0.0);\n        \telse\n            \tresult.second = VoxelHit(mapPos, VOXEL_WATER, volAccum, vec3(0.0), vec3(0.0), 0.0);\n        \n        // terrain intersection\n        if (isTerrainAt(mapPos)) {\n            VoxelHit newVoxelHit = VoxelHit(mapPos, getTerrainTypeAt(mapPos), volAccum, vec3(0.0), vec3(0.0), 0.0);\n            if (result.first.terrainType == 0) {\n                result.first = newVoxelHit;\n            } else {\n                result.second = newVoxelHit;\n                break; // two intersections, stop stepping!\n            }\n        }\n        \n        float newDist = min( sideDist.x, min(sideDist.y, sideDist.z ));\n\n        // accumulate occlusions\n        vec2 occlusions = getOcclusionsAt(mapPos);\n        volAccum += occlusions * (newDist - prevDist);\n        prevDist = newDist;\n        \n        // march forward to next position\n        \n        vec3 mi = step( sideDist.xyz, sideDist.yzx ); \n        vec3 mm = mi*(1.0-mi.zxy);\n        sideDist += mm * vec3(rayStep) / rd;\n        mapPos += ivec3(mm)*rayStep;\n    }\n    \n    // last result should always have max fog if did not intersect\n    if (result.second.terrainType == VOXEL_NONE)\n    \tresult.second.volAccum = volAccum;\n    \n    // if there was no intersection at all, set accumulated fog on first hit and return\n    if (result.first.terrainType == VOXEL_NONE) {\n        result.first.volAccum = volAccum;\n        result.first.weight = 1.0;\n        return result;\n    }\n\n    // distance march to intersect first voxel\n    vec3 hitVoxelCenter = vec3(result.first.mapPos) + 0.5;\n    vec3 cubeIntersect = (hitVoxelCenter - ro - 0.5*sign(rd))/rd;\n    float dist = max(cubeIntersect.x, max(cubeIntersect.y, cubeIntersect.z));\n    float diff; float mindiff = 1.0; float finaldist = 0.0;\n    for (int i=0; i<8; i++) {\n        vec3 p = ro + rd * dist;\n        diff = dfVoxel(p - hitVoxelCenter, result.first.terrainType);\n        if (diff < mindiff) {\n            mindiff = diff;\n            finaldist = dist;\n        }\n        dist += diff; \n    }\n    \n    float pixSizeApprox = 2.0/iResolution.x * finaldist; // the FOV is actually about 1 radian :)\n    result.first.weight = smoothstep(pixSizeApprox, 0.0, mindiff - 0.01); // anti-alias blend\n    result.first.hitRel = ro + rd * finaldist - hitVoxelCenter;\n    result.first.hitNormal = nrmVoxel(result.first.hitRel, result.first.terrainType);\n    \n    // if it was water, adjust weight for surface reflection\n    if (result.first.terrainType == VOXEL_WATER) result.first.weight = 0.5;\n    \n    // do a cube intersection for the second voxel\n    hitVoxelCenter = vec3(result.second.mapPos) + 0.5;\n    cubeIntersect = (hitVoxelCenter - ro - 0.5*sign(rd))/rd;\n    dist = max(cubeIntersect.x, max(cubeIntersect.y, cubeIntersect.z));\n    result.second.hitRel = ro + rd * dist - hitVoxelCenter;\n    \n    // attempt to improve a little with distance marching\n    for (int i=0; i<4; i++) {\n        vec3 p = ro + rd * dist;\n        diff = dfVoxel(p - hitVoxelCenter, result.first.terrainType);\n        dist += diff; \n    }\n    if (diff < 0.05) result.second.hitRel = ro + rd * dist - hitVoxelCenter;\n    \n    result.second.weight = 1.0 - result.first.weight;\n    result.second.hitNormal = nrmVoxel(result.second.hitRel, result.second.terrainType);\n    \n    return result;\n}\n\nfloat marchShadowCheck(VoxelHit hit)\n{\n    vec3 ro = hit.hitRel + vec3(hit.mapPos) + 0.5;\n    vec3 rd = SUN_DIRECTION;\n    ro += rd*0.11;\n    \n    ivec3 mapPos = ivec3(floor(ro));\n    vec3 deltaDist = abs(vec3(length(rd)) / rd);\n    ivec3 rayStep = ivec3(sign(rd));\n    vec3 sideDist = (sign(rd) * (vec3(mapPos) - ro) + (sign(rd) * 0.5) + 0.5) * deltaDist; \n\tfloat fogAccum = 0.0;\n    float prevDist = 0.0;\n    \n    for (int i = 0; i < 16; i++) {\n        \n        // if intersected, finish\n        if (isTerrainAt(mapPos)) {\n            return 1.0;\n        }\n\n        // march forward to next position\n        float newDist = min( sideDist.x, min(sideDist.y, sideDist.z ));\n        vec3 mi = step( sideDist.xyz, sideDist.yzx ); \n        vec3 mm = mi*(1.0-mi.zxy);\n        sideDist += mm * vec3(rayStep) / rd;\n        mapPos += ivec3(mm)*rayStep;\n        \n        // accumulate fog\n        vec2 occlusions = getOcclusionsAt(mapPos);\n        fogAccum += occlusions.x * (newDist - prevDist);\n        prevDist = newDist;\n    }\n    \n    // no intersection\n    return fogAccum / 5.0;\n}\n\nfloat calcAmbientOcclusion(VoxelHit hit)\n{\n    float ambientOcc = 0.0;\n    \n    // for each of the 28 voxels surrounding the hit voxel\n    for (int i=-1; i<=1; i++) for (int j=-1; j<=1; j++) for (int k=-1; k<=1; k++) {\n        if (i == 0 && j == 0 && k == 0) continue; // skip the hit voxel\n        ivec3 offset = ivec3(i, j, k);\n        // TODO: find some way to skip these voxels\n        // if (dot(hit.hitRel, vec3(offset)) < 0.0) continue; \n        \n        int terrainType=VOXEL_STONE;\n        if (isTerrainAt(hit.mapPos + offset)) {\n            \n            // use the distance from just above the intersection to estimate occlusion\n            float dist = dfVoxel(hit.hitRel + hit.hitNormal*0.5 - vec3(offset), terrainType);\n            ambientOcc += smoothstep(1.0, 0.0, dist);\n        }\n    }\n    \n    return ambientOcc / 8.0;\n}\n\nvec3 doColoring(VoxelHit hit, vec3 rd)\n{   \n    // global position for non-repeating noise\n    vec3 hitGlobal = vec3(hit.mapPos) + hit.hitRel + 0.5;\n    float f1 = noise(hitGlobal*19.0);\n    float f2 = noise(hitGlobal*33.0);\n    float f3 = noise(hitGlobal*71.0);\n    \n    vec3 color = vec3(0.0);\n    if (hit.terrainType == VOXEL_WATER) {\n        color = vec3(0.4, 0.4, 0.8) * (0.8 + f1*0.1 + f2*0.05 + f3*0.05);\n    } else if (hit.terrainType == VOXEL_EARTH) {\n        color = vec3(1.0, 0.7, 0.3) * (f1*0.13 + f2*0.13 + f3*0.1 + 0.3);\n    } else if (hit.terrainType == VOXEL_SAND) {\n        color = vec3(1.0, 1.0, 0.6) * (f1*0.07 + f2*0.07 + f3*0.2 + 0.5);\n    } else if (hit.terrainType == VOXEL_STONE) {\n        color = vec3(0.5) * (f1*0.3 + f2*0.1 + 0.6);\n    } else if (hit.terrainType == VOXEL_GRASS) {\n        color = vec3(0.3, 0.7, 0.4) * (f1*0.1 + f3*0.1 + 0.6);\n    } else if (hit.terrainType == VOXEL_ERROR) {\n        color = vec3(1.0, 0.0, 1.0);\n    }  else if (hit.terrainType == VOXEL_NONE) {\n        color = vec3(0.8, 0.8, 0.6);\n        color += vec3(5.0, 3.0, 0.0)*pow(max(dot(rd, SUN_DIRECTION), 0.0), 128.0);\n    }\n    \n    float shadow = min(marchShadowCheck(hit), 1.0);\n    float ambient = 1.0 - calcAmbientOcclusion(hit);\n    float diffuse = max(dot(SUN_DIRECTION, hit.hitNormal), 0.0);\n    diffuse = diffuse*(1.0-shadow);\n    \n    color *= diffuse * 0.6 + ambient * 0.4;\n    \n    vec2 occlusions = smoothstep(vec2(0.0), vec2(10.0, 3.0), hit.volAccum);\n    color = mix(color, vec3(0.3, 0.3, 0.5), occlusions.y); // water\n    color = mix(color, vec3(0.6), occlusions.x);           // cloud\n    \n    // blend with other intersection. will be fractional when anti-aliasing or underwater\n    color *= hit.weight;\n    \n    return color;\n}\n\n\nVoxelHit marchReflection(VoxelHit hit, vec3 prevrd)\n{\n    vec3 ro = hit.hitRel + vec3(hit.mapPos) + 0.5;\n    vec3 rd = reflect(prevrd, hit.hitNormal);\n    ro += 0.01*rd;\n    \n    ivec3 mapPos = ivec3(floor(ro));\n    vec3 deltaDist = abs(vec3(length(rd)) / rd);\n    ivec3 rayStep = ivec3(sign(rd));\n    vec3 sideDist = (sign(rd) * (vec3(mapPos) - ro) + (sign(rd) * 0.5) + 0.5) * deltaDist; \n    vec2 volAccum = hit.volAccum;\n    float prevDist = 0.0;\n    VoxelHit result = VoxelHit(ivec3(0), VOXEL_NONE, vec2(0.0), vec3(0.0), vec3(0.0), 0.0);\n\t\n    for (int i = 0; i < 16; i++) {\n\n        // if intersected, finish\n        if (isTerrainAt(mapPos)) {\n            result = VoxelHit(mapPos, getTerrainTypeAt(mapPos), volAccum, vec3(0.0), vec3(0.0), 1.0);\n            break;\n        }\n        \n        float newDist = min( sideDist.x, min(sideDist.y, sideDist.z ));\n        \n        // accumulate occlusions\n        vec2 occlusions = getOcclusionsAt(mapPos);\n        volAccum += occlusions * (newDist - prevDist);\n        prevDist = newDist;\n\n        // march forward to next position\n        \n        vec3 mi = step( sideDist.xyz, sideDist.yzx ); \n        vec3 mm = mi*(1.0-mi.zxy);\n        sideDist += mm * vec3(rayStep) / rd;\n        mapPos += ivec3(mm)*rayStep;\n    }\n    \n    if (result.terrainType != VOXEL_NONE) {\n        vec3 hitVoxelCenter = vec3(mapPos) + 0.5;\n        vec3 cubeIntersect = (hitVoxelCenter - ro - 0.5*sign(rd))/rd;\n        float dist = max(cubeIntersect.x, max(cubeIntersect.y, cubeIntersect.z));\n        result.hitRel = ro + rd * dist - hitVoxelCenter;\n        result.hitNormal = nrmVoxel(result.hitRel, result.terrainType);\n        return result;\n    }\n    \n    // no intersection\n    return VoxelHit(mapPos, VOXEL_NONE, volAccum, vec3(0.0), vec3(0.0), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iMouse.z > 0.0 && fragCoord.x < MAP_SIZE && fragCoord.y < MAP_SIZE) {\n        fragColor = texture(iChannel2, fragCoord/iResolution.xy);\n        return;\n    }\n    \n    // camera stolen from Shane :) https://www.shadertoy.com/view/ll2SRy\n\tvec2 uv = (fragCoord - iResolution.xy*.5 )/iResolution.y;\n    vec3 rd = normalize(vec3(uv, (1.-dot(uv, uv)*.5)*.5));\n    vec3 ro = vec3(MAP_SIZE/2.0 + 32.0*sin(iTime*0.1), 14., MAP_SIZE/2.0 + 32.0*cos(iTime*0.1));\n    float t = sin(iTime * 0.2) + noise(ro/32.0);\n    ro.y += 4.0*t;\n\tfloat cs = cos( t ), si = sin( t );\n    rd.yz = mat2(cs, si,-si, cs)*rd.yz;\n    rd.xz = mat2(cs, si,-si, cs)*rd.xz;\n    \n    // voxel march into the scene storing up to four intersections\n    VoxelMarchResult result = voxelMarch(ro, rd);\n    \n    // if first intersection is with water surface, march reflection\n    if (result.first.terrainType == VOXEL_WATER) {\n        result.first = marchReflection(result.first, rd);\n        result.first.weight = 0.5;\n        result.second.weight = 1.0 - result.first.weight;\n    }\n    \n    // color\n    vec3 color1 = doColoring(result.first, rd);\n    vec3 color2 = doColoring(result.second, rd);\n    vec3 color = color1 + color2;\n    \n\tfragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.14159\n\n#define VOXEL_ERROR -2\n#define VOXEL_UNRESOLVED -1\n#define VOXEL_NONE  0\n#define VOXEL_WATER 1\n#define VOXEL_SAND  2\n#define VOXEL_EARTH 3\n#define VOXEL_STONE 4\n#define VOXEL_GRASS 5\n#define VOXEL_WOOD  6\n#define VOXEL_LEAVES 7\n\n#define MAP_SIZE 256.0\n\n// IQ's value noise from https://www.shadertoy.com/view/4sfGzS\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n    vec2 uv = p.xy + f.xy;\n\tvec2 rg = vec2(texture( iChannel0, (uv+vec2(37.0,17.0)*p.z+0.5)/256.0, -100.0 ).x,\n                   texture( iChannel0, (uv+vec2(37.0,17.0)*(p.z+1.0)+0.5)/256.0, -100.0 ).x );\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nint terrainGetTree(vec3 p)\n{\n    ivec3 ip = ivec3(p + 0.5);\n    \n    int height = 16;\n    int leafHeight = 7;\n    \n    // trunk\n    if (ip.x == 0 && ip.z == 0 && ip.y < height) return VOXEL_WOOD;\n    \n    // leaves\n    float rp = length(vec2(ip.xz));\n    float rl = sqrt(float(height - ip.y));\n    if (ip.y >= leafHeight && ip.y <= height && rp <= rl) return VOXEL_LEAVES;\n    \n    return VOXEL_NONE;\n}\n\n\nint getTerrainTypeAt(ivec3 ip)\n{  \n    if (ip.y < 0) return VOXEL_STONE;\n    \n    // so this is like, grabbing the texture as a heightmap and\n    // then like twisting it in random directions as it goes up\n    // umm...\n    vec3 p = vec3(vec3(ip) + 0.5);\n    float theta = noise(p / 16.0) * PI * 2.0;\n    vec2 disp = vec2(cos(theta), sin(theta)) * p.y;\n    vec3 terr = texture(iChannel1, (p.xz + disp) / float(MAP_SIZE)).rgb;\n\n    bvec3 contains = lessThanEqual(vec3(0.0), (terr - p.y/16.0));\n    if (contains.x && contains.y && !contains.z) return VOXEL_SAND;\n    else if (contains.x && contains.z) return VOXEL_GRASS;\n    else if (contains.y && contains.z && !contains.x) return VOXEL_STONE;\n    else if (contains.x || contains.y || contains.z) return VOXEL_EARTH;\n    \n    return VOXEL_NONE;\n}\n\nbool isFilled(vec3 p)\n{\n    return getTerrainTypeAt(ivec3(p)) != VOXEL_NONE;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Optimization. Skip generation once we are up and running\n    if (iTime > 0.5) {\n        fragColor = texture(iChannel2, fragCoord/iResolution.xy);\n        return;\n    }\n        \n    fragColor = vec4(0.0);\n        \n    const float ext = float(MAP_SIZE);\n    vec2 p = fragCoord/2.0;\n    p = mod(p, 2.0*ext);\n    \n    // create fragColor like a 32-bit bitset ;-)\n    ivec4 vals = ivec4(0);\n    for (int j=0; j<4; j++) for (int i=7; i>=0; i--) {\n        vals[j] *= 2;\n        if (isFilled(vec3(p.x, float(j*8+i), p.y))) vals[j] += 1;\n    }\n    fragColor = vec4(vals)/255.0;\n}","name":"Buf A","description":"","type":"buffer"}]}