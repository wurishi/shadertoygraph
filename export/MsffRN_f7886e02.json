{"ver":"0.1","info":{"id":"MsffRN","date":"1495095309","viewed":283,"name":"Kaleidoscopic Hyperbolic ","username":"decrooks","description":"kaleidoscopic pattern from hyperbolic disk","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["kaleidoscope","pattern","hyperbolic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by David Crooks\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define TWO_PI 6.283185\n#define PI 3.14159265359\n\nstruct Circle {\n    float radius;\n    vec2 center;\n};\n\nconst int numCircles = 3;\nCircle circles[3];\n\n\n/*\n\tOrthoganl Circles represent strait line in hyperbolic space.\n\t\n\tsee http://mathworld.wolfram.com/PoincareHyperbolicDisk.html.\n\n*/\nCircle orthogonalCircle(float theta1,float theta2) {\n    \n    float theta = 0.5*(theta1 + theta2);\n    float dTheta = 0.5*(theta1 - theta2);\n    \n    float r = abs(tan(dTheta));\n   //  float r = 0.5;\n    float R = 1.0/cos(dTheta);\n    \n    vec2 center = vec2(R*cos(theta),R*sin(theta));\n    \n    return Circle(r,center);\n}\n\n\n\n\nvoid createCircles() {\n\n    float t = 0.5 - 0.5*cos(iTime);\n\n  \tfloat theta = TWO_PI/3.0;\n   \n    \n    float dTheta = 2.43 + 0.152*t;\n    \n\t//for(int i;i<numCircles  )\n    circles[0] = orthogonalCircle(0.0,dTheta);\n    circles[1] = orthogonalCircle(theta,theta + dTheta);\n    circles[2] = orthogonalCircle(2.0*theta,2.0*theta +  dTheta);\n}\n\nfloat arcosh(float x) {\n    return log(x + sqrt(x*x - 1.0));\n}\n\nfloat hyperbolicDist(vec2 p, vec2 q){\n    return arcosh(1. + 2.*dot(p-q,p-q) / ((1. - dot(p,p))*(1. - dot(q,q))) );\n}\n\nbool circleContains(vec2 p, Circle c) { \n   return distance(c.center,p) < c.radius;  \n}\n\n\n/*\n\tCircle inversion exchanges the inside with the outside of a circle.\n\tReflections in hyperbolic space.\n*/\nvec2 circleInverse(vec2 p, Circle c){\n    p -= c.center;\n\treturn p  * c.radius * c.radius / dot(p,p) + c.center;\n    \n}\n\nbool isEven(int i){\n    \n    return mod(float(i),2.0) == 0.0;\n  //  return i%2 == 0;\n    \n}\n\n/*\n\tIterated Inversion System \n    see this paper http://archive.bridgesmathart.org/2016/bridges2016-367.pdf\n    and this shader https://www.shadertoy.com/view/XsVXzW by soma_arc.\n\n\tThis algorythim for draws tileings on the poncaire disk model of hyperbolic space.\n\t\n\tOur array of circles represent the reflections that generate the tiling.\n\tWe repeatedly invert the point in each of the circles and keep track of the total number of inversions.\n\n*/\n\nvec3 iteratedInversion(vec2 p) {\n    \n\n    int count = 0;\n    bool flag = true;\n    \n    for(int i=0; i<100; i++) {\n        \n        flag = true;\n        \n        \n        for(int j = 0; j<numCircles; j++) {\n            Circle c = circles[j];\n\n            if(circleContains(p, c)) {\n                \n                p = circleInverse(p,c);\n                flag = false;\n                count++;  \n                \n        \t} \n            \n        }\n        \n        if(flag) {\n           break;\n        }\n        \n    }\n    \n    \n     return vec3(p,isEven(count));  \n   \n    \n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n\tcreateCircles();\n    \n    vec2 uv = 2.0*(fragCoord - 0.5*iResolution.xy) / iResolution.y;\n    \n  \n    vec3 p = iteratedInversion(uv);\n    // float r = length(p);  //distance(p\n    float r = hyperbolicDist(p.xy,vec2(0.0));\n    float theta = atan(p.x,p.y);\n    float h = 0.66*sin(30.0*r + iTime) + 0.335*sin(3.0*theta) ;\n    float g =  0.33*sin(5.0*r + iTime) + 0.666*sin(3.0*theta) ;\n    float c =  0.5+0.5*h;\n    fragColor = vec4(0.5*h,0.5*h*p.z,g,1.0);\n   \n}","name":"Image","description":"","type":"image"}]}