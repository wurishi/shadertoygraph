{"ver":"0.1","info":{"id":"cslXRX","date":"1669324074","viewed":200,"name":"Wythoff-Constructed Weaves","username":"fizzer","description":"I took the non-snub tilings from my [url=https://www.shadertoy.com/view/3tyXWw]uniform tilings[/url] shader and came up with a way to draw splines in the fundamental region (two variants) to create weaves. Clickdrag to select tiling and scroll vertically.","likes":33,"published":1,"flags":0,"usePreview":0,"tags":["2d","spiral","bump","weave","wythoff"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This is really only a first attempt, and I'm sure it can be developed further to get \"true\" weavings\n// based on all of the uniform tilings.\n\nconst float pi = acos(-1.);\n\n// From IQ: https://www.shadertoy.com/view/MlKcDD\n// signed distance to a quadratic bezier\nfloat sdBezier(vec2 pos, vec2 A, vec2 B, vec2 C)\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n\n    float res = 0.0;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if(h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = uv.x + uv.y - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 1 root\n        vec2 qos = d + (c + b*t)*t;\n        res = length(qos);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = vec3(m + m, -n - m, n - m) * z - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 3 roots\n        vec2 qos = d + (c + b*t.x)*t.x;\n        float dis = dot(qos,qos);\n\n        res = dis;\n\n        qos = d + (c + b*t.y)*t.y;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n\n        qos = d + (c + b*t.z)*t.z;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n\n        res = sqrt( res );\n    }\n\n    return res;\n}\n\nvec3 draw(vec3 b, vec2 uv, vec2 ca, vec2 cb, vec2 cc, float f, mat2 nmat)\n{\n    float d = sdBezier(uv, ca, cb, cc);\n    vec2 eps = vec2(1. / 256.,0);\n    vec3 n = normalize(vec3(sdBezier(uv + eps.xy, ca, cb, cc) - d,\n                            sdBezier(uv + eps.yx, ca, cb, cc) - d,\n                            eps.x));\n  \n    n.xy = nmat * n.xy;\n  \n    vec3 c = vec3(n.x * .4 + .5) + smoothstep(.65, .8, n.y + n.x * .5) * .5;\n    \n    d /= 4.;\n    f /= 4. * 2.0;\n    \n    float n0 = 0.04;\n    float n1 = 0.03;\n    float n2 = 0.025;\n    \n    return mix(mix(mix(b * smoothstep(0.032, .07, d), vec3(.8,.7,.2), 1. - smoothstep(n0 - f, n0 + f, d)),\n                               vec3(0), 1. - smoothstep(n1 - f, n1 + f, d)),\n                               c, 1. - smoothstep(n2 - f, n2 + f, d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\n    uv *= 5.;\n    uv.x += iTime / 4.;\n    uv.y += iMouse.y / iResolution.y * 8.;\n\n    float bgx = (uv.x + uv.y) * 8.1;\n    float bgf = max(abs(dFdx(bgx)), abs(dFdy(bgx)));\n    // Background pattern\n    vec3 col = mix(vec3(.7), vec3(.4), smoothstep(-bgf, +bgf, abs(fract(bgx) - .5) - .1)) / 5.;\n    \n    // https://en.wikipedia.org/wiki/Wythoff_symbol\n    // wythoff_symbol.w indicates the position of the vertical bar in the symbol\n    ivec4 wythoff_symbol;\n\n    float md = 1. / 6. * iResolution.x;\n    float tiling_index;\n\n    // https://en.wikipedia.org/wiki/List_of_Euclidean_uniform_tilings\n    // Select tiling via mouse X position\n    if(iMouse.x < md * 1.)\n    {\n        wythoff_symbol = ivec4(3, 6, 2, 2); // 3.4.6.4\n        tiling_index = 0.;\n    }\n    else if(iMouse.x < md * 2.)\n    {\n        wythoff_symbol = ivec4(2, 4, 4, 3); // 4.8.8 (Wikipedia suggests 2 | 4 4 but that is surely incorrect..)\n        tiling_index = 1.;\n    }\n    else if(iMouse.x < md * 3.)\n    {\n        wythoff_symbol = ivec4(3, 3, 3, 3); // 6.6.6\n        tiling_index = 2.;\n    }\n    else if(iMouse.x < md * 4.)\n    {\n        wythoff_symbol = ivec4(2, 6, 3, 1); // 3.6.3.6\n        tiling_index = 3.;\n    }\n    else if(iMouse.x < md * 5.)\n    {\n        wythoff_symbol = ivec4(2, 3, 6, 2); // 3.12.12\n        tiling_index = 4.;\n    }\n    else if(iMouse.x < md * 6.)\n    {\n        wythoff_symbol = ivec4(4, 2, 4, 1); // 4.4.4.4\n        tiling_index = 6.;\n    }\n\n\n    vec3 angles = vec3(pi) / vec3(wythoff_symbol.xyz);\n    vec3 sins = sin(angles);\n\n    // Law of sines (c is defined to be 1.0)\n    float a = sins.x / sins.z;\n    float b = sins.y / sins.z;\n\n    // Triangle corners\n    vec2 ta = vec2(0, 0);\n    vec2 tb = vec2(1, 0);\n    vec2 tc = vec2(cos(angles.x), sin(angles.x)) * b;\n\n    float sinzx = sin(angles.z + angles.x);\n\n    // Triangle edge planes\n    vec3 dirs[3] = vec3[3](vec3(-sin(angles.x), cos(angles.x), 0.), vec3(0., -1., 0.),\n                           vec3(sinzx, -cos(angles.z + angles.x), sinzx));\n\n    int reflcount = 0;\n    \n    // A rough approach to finding a translational symmetry that works.\n    // There is probably a better way.\n    vec2 period = vec2((max(max(ta.x, tb.x), tc.x) - min(min(ta.x, tb.x), tc.x)) * 6.,\n                        (max(max(ta.y, tb.y), tc.y) - min(min(ta.y, tb.y), tc.y)) *\n                        ((tiling_index == 3.) ? 6. : 8.) );\n                        \n    uv = mod(uv, period) - period / 2.;\n\n    // This matrix represents the (non-translational) transformation from local fundamental region to \n    // the base UV coordinate system.\n    mat2 nmat = mat2(1);\n\n    // This is not the fastest way, but it certainly is the simplest.\n    for(int i = 0; i < 16; ++i)\n    {\n        int j = 0;\n        while(j < 3)\n        {\n            vec2 dir = dirs[j].xy;\n            float d = dot(uv, dir) - dirs[j].z;             \n            if(d > 0.)\n            {\n                // Reflect\n                uv -= dir * d * 2.;\n                nmat = nmat * mat2(dir, vec2(-dir.y, dir.x)) * mat2(vec2(-1, 0), vec2(0, 1)) *\n                        transpose(mat2(dir, vec2(-dir.y, dir.x)));\n                ++reflcount;\n                break;\n            }\n            ++j;\n        }\n        if(j == 3)\n            break;\n    }\n\n    // Reflections of fundamental region corners in opposite edges. This essentially gives\n    // the corners of neighbouring triangles. \n    vec2 qa = tc - dirs[1].xy * 2.0 * dot(dirs[1].xy, tc - ta);\n    vec2 qb = tb - dirs[0].xy * 2.0 * dot(dirs[0].xy, tb - ta);\n\n    float f = max(length(dFdx(uv)), length(dFdy(uv)));\n    \n    if((reflcount & 1) == 0)\n    {\n        col = draw(col, uv, tb, ta, tc, f, nmat);\n        col = draw(col, uv, tc, ta, qb, f, nmat);\n    }\n    else\n    {\n        col = draw(col, uv, tb, ta, tc, f, nmat);\n        col = draw(col, uv, tb, ta, qa, f, nmat);\n    }    \n    \n    \n    fragColor = vec4(pow(clamp(col, 0., 1.), vec3(1. / 2.2)), 1.0);\n}","name":"Image","description":"","type":"image"}]}