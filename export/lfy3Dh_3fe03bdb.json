{"ver":"0.1","info":{"id":"lfy3Dh","date":"1712773521","viewed":33,"name":"Utility functions","username":"julcasans","description":"Results from Julian Puppo shader class ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["utility"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159235659\n#define TWO_PI PI*2.0\n\nfloat plot(vec2 st, float pct){\n  return  smoothstep( pct-0.02, pct, st.y) -\n          smoothstep( pct, pct+0.02, st.y);\n}\n\nvec3 rgb2hsb( in vec3 c ){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz),\n                 vec4(c.gb, K.xy),\n                 step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r),\n                 vec4(c.r, p.yzx),\n                 step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)),\n                d / (q.x + e),\n                q.x);\n}\n\nfloat circle(vec2 uv, vec2 p, float s, float d) {\n    p = p - uv;\n    float r = length(p);\n    float e = 1.0 - smoothstep(s, s+d, r);\n    return e;\n}\n\nfloat poly(vec2 uv, vec2 p, float s, float dif, int N, float a) {\n    // remap the space to -1.0 to 1.0\n    vec2 st = p - uv;\n    // angle and radius from the current pixel\n    float a2 = atan(st.x, st.y) + a;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(0.5+a2/r) * r - a2) * length(st);\n    float e = 1.0 - smoothstep(s, dif, d);\n    return e;\n}\n\n//  Function from IÃ±igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nmat2 rotate2d(float _angle) {\n    return mat2(cos(_angle), -sin(_angle), \n                sin(_angle), cos(_angle));\n}\n\nmat2 scale(vec2 _scale) {\n    return mat2(_scale.x, 0.0, 0.0, _scale);\n}\n\nvec2 rotate2D(vec2 _st, float _angle) {\n    _st -= 0.5;\n    _st = mat2(cos(_angle), -sin(_angle),\n                sin(_angle), cos(_angle)) * _st;\n    _st += 0.5;\n    return _st;\n}\n\nvec2 scale(vec2 uv, vec2 _sc) {\n    uv -= vec2(0.5);\n    uv = uv * mat2(_sc.x, 0.0,\n                   0.0, _sc.y);\n    uv += vec2(0.5);\n    \n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float fix = iResolution.x/iResolution.y;\n    uv.x *= fix;\n\n    //uv = fract(uv*5.0);\n\n    vec2 p = vec2(0.5) - uv;\n    float r = length(p);\n    float a = atan(p.x, p.y);\n    \n    //float e = fract(sin(uv.x * 3.0 * 50.0 + sin(uv.y * 20.0 + iTime))); \n\n    vec2 uv2 = (scale(uv*5.0, vec2(sin(iTime*0.21)*0.5+0.9)));\n    uv = (scale(uv*5.0, vec2(sin(iTime*.21)*0.55+0.69)));\n    uv2 = scale(uv2, vec2(.95));\n    \n    uv = fract(vec2(uv.x*.5 - iTime, uv.y*0.7));\n    uv2 = fract(vec2(uv2.x*.5 - iTime, uv2.y*0.7));\n\n    float e1 = poly(uv2, vec2(0.5), 0.2, 0.2, 3, iTime * 0.51);\n    float e2 = circle(fract(uv * 5.0), vec2(0.5), 0.1, 0.3);\n   \n    //vec3 col = vec3(e);\n    vec4 col1 = vec4(.60, 0.2, 0.4, 0.6);\n    vec4 col2 = vec4(0.5, 0.8, 0.9, 1.0);\n    vec4 col = e1*col1 + e2*col2;\n    // Output to screen\n    fragColor = col;\n}","name":"Image","description":"","type":"image"}]}