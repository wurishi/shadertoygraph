{"ver":"0.1","info":{"id":"ds3SWM","date":"1703711842","viewed":10,"name":"Fluid Sim Attempt 2","username":"Warren","description":"Fluid Sim Attempt 2","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["fluid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel0, uv); // density\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void addDensity(in vec2 uv, in vec2 mouseUV, inout vec4 fragColor) {\n    float radius = 0.05;\n    float dist = distance(uv, mouseUV);\n\n    if (dist < radius) {\n        vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n        fragColor += vec4(col, 1.0);\n    }\n}\n\nvoid diffuseDensity(in sampler2D buffer, in vec2 uv, in float diffRate, inout vec4 fragColor) {\n    vec2 tex_offset = 1.0 / iResolution.xy;\n    vec3 sum = vec3(0.0);\n\n    sum += texture(buffer, uv + vec2(-tex_offset.x, 0.0)).rgb;\n    sum += texture(buffer, uv + vec2(tex_offset.x, 0.0)).rgb;\n    sum += texture(buffer, uv + vec2(0.0, -tex_offset.y)).rgb;\n    sum += texture(buffer, uv + vec2(0.0, tex_offset.y)).rgb;\n\n    fragColor.rgb = (fragColor.rgb + diffRate * sum) / (1.0 + 4.0 * diffRate);\n}\n\nvoid advectDensity(in sampler2D buffer, in vec2 uv, in vec2 velocity, in float dt, inout vec4 fragColor) {\n    vec2 tex_offset = 1.0 / iResolution.xy;\n    vec2 backPosition = uv - dt * velocity;\n    vec3 advectedDensity = texture(buffer, backPosition).rgb;\n    fragColor.rgb = mix(fragColor.rgb, advectedDensity, 0.8);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 prevState = texture(iChannel0, uv);\n\n    if (iMouse.z > 0.0) { // Clicking\n        vec2 mouseUV = iMouse.xy / iResolution.xy;\n        vec2 prevMouseUV = abs(iMouse.zw) / iResolution.xy;\n        addDensity(uv, mouseUV, prevState);\n    }\n    \n    diffuseDensity(iChannel0, uv, 0.25, prevState);\n    vec2 velocity = (abs(texture(iChannel1, uv)) * 5.0).xy;\n    advectDensity(iChannel0, uv, velocity, 0.1, prevState);\n\n    fragColor = prevState;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"mat3 m = mat3( 0.00,  0.90,  0.60,\n              -0.90,  0.36, -0.48,\n              -0.60, -0.48,  0.34 );\n\nfloat hash21(vec2 p)\n{\t\n    float h = dot(p,vec2(127.1,311.7));\n    return -1.0 + 2.0*fract(sin(h)*43758.5453123);\n}\nvec2 hash22(vec2 p)\n{\n    p = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)));\n    return -1.0 + 2.0 * fract(sin(p)*43758.5453123);\n}\n\nvec3 hash33( vec3 p )\n{\t\n    #if 0\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\t#else\n    \tp = m*p;\n    #endif\n\treturn -1.+2.*fract(sin(p)*43758.5453123);\n}\n\nfloat hash31(vec3 p)\n{\t\n    #if 0\n    p = m*p;\n    #endif\n\tfloat h =  dot(p,vec3(127.1,311.7, 74.7));\n    return -1.+2.*fract(sin(h)*43758.5453123);\n}\n\n//2d traditional gradient noise\nfloat noise_perlin(vec2 p)\n{\n\tvec2 ni = floor(p);\n    vec2 nf = fract(p);\n    \n    vec2 w = nf*nf*(3.-2.*nf);\n    \n    float f1 = dot(hash22(ni),nf);\n    float f2 = dot(hash22(ni+vec2(1.,0.)),nf-vec2(1.,0.));\n    float f3 = dot(hash22(ni+vec2(1.,1.)),nf-vec2(1.,1.));\n    float f4 = dot(hash22(ni+vec2(0.,1.)),nf-vec2(0.,1.));\n    \n    float f12 = mix(f1,f2,w.x);\n    \n    float f34 = mix(f4,f3,w.x);\n    \n    float f=mix(f12,f34,w.y);\n    \n    return f;\n    \n}\n//3d traditional gradient noise\nfloat noise_perlin1(vec3 p)\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\t\n    vec2 zo = vec2(0.,1.);\n    float f000 = dot(hash33(i),f-zo.xxx);\n    float f010 = dot(hash33(i+zo.yxx),f-zo.yxx);\n    float f001 = dot(hash33(i+zo.xyx),f-zo.xyx);\n    float f011 = dot(hash33(i+zo.yyx),f-zo.yyx);\n    \n    float hx1 = mix(f000,f010,u.x);\n    float hx2 = mix(f001,f011,u.x);\n    float hy1 = mix(hx1,hx2,u.y);\n    \n    float f100 = dot(hash33(i+zo.xxy),f-zo.xxy);\n    float f110 = dot(hash33(i+zo.yxy),f-zo.yxy);\n    float f101 = dot(hash33(i+zo.xyy),f-zo.xyy);\n    float f111 = dot(hash33(i+zo.yyy),f-zo.yyy);\n    \n    hx1 = mix(f100,f110,u.x);\n    hx2 = mix(f101,f111,u.x);\n    float hy2 = mix(hx1,hx2,u.y);\n    \n    float h = mix(hy1,hy2,u.z);\n    \t\n    return h;\n}\n\n//2d traditional value noise\nfloat noise_value( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash21( i + vec2(0.0,0.0) ), \n                     hash21( i + vec2(1.0,0.0) ), u.x),\n                mix( hash21( i + vec2(0.0,1.0) ), \n                     hash21( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n//3d traditional value noise\nfloat noise_value1( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\t\n    vec2 zo = vec2(0.,1.);\n    float f000 = hash31(i);\n    float f010 = hash31(i+zo.yxx);\n    float f001 = hash31(i+zo.xyx);\n    float f011 = hash31(i+zo.yyx);\n    \n    float hx1 = mix(f000,f010,u.x);\n    float hx2 = mix(f001,f011,u.x);\n    float hy1 = mix(hx1,hx2,u.y);\n    \n    float f100 = hash31(i+zo.xxy);\n    float f110 = hash31(i+zo.yxy);\n    float f101 = hash31(i+zo.xyy);\n    float f111 = hash31(i+zo.yyy);\n    \n    \n     hx1 = mix(f100,f110,u.x);\n     hx2 = mix(f101,f111,u.x);\n    float hy2 = mix(hx1,hx2,u.y);\n    \n    float h = mix(hy1,hy2,u.z);\n    \t\n    return h;\n}\n\n// shadertoy's 3d noise\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel0, (uv+ 0.5)/256.0).yx;\n\treturn mix( rg.x, rg.y, f.z )*2.-1.;\n}\n//-------------------------------------------------------------------------------------\n//fbm 2d traditional gradient noise\nfloat map5_perlin(vec2 p)  \n{\t\n    float r = 0.;\n    float s = 1.;\n    float f = 1.;\n    \n    float w = 0.;\n    for(int i = 0;i < 5;i++){\n        r += s*noise_perlin(p*f); w += s;\n        s /= 2.;\n        f *= 2.;\n    }\n    return r/w;\n}\n//fbm 3d traditional gradient noise\nfloat map5_perlin1(vec3 p)  \n{\t\n    float r = 0.;\n    float s = 1.;\n    float f = 1.;\n    \n    float w = 0.;\n    for(int i = 0;i < 5;i++){\n        r += s*noise_perlin1(p*f); w += s;\n        s /= 2.;\n        f *= 2.;\n    }\n    return r/w;\n}\n//fbm 2d traditional value noise\nfloat map5_value(vec2 p)\n{\n\tfloat r = 0.;\n    float s = 1.;\n    float f = 1.;\n    \n    float w = 0.;\n    for(int i = 0;i < 5;i++){\n        r += s*noise_value(p*f); w += s;\n        s /= 2.;\n        f *= 2.;\n    }\n    return r/w;\n}\n//fbm 3d traditional value noise\nfloat map5_value1(vec3 p)\n{\n\tfloat r = 0.;\n    float s = 1.;\n    float f = 1.;\n    \n    float w = 0.;\n    for(int i = 0;i < 5;i++){\n        r += s*noise_value1(p*f); w += s;\n        s /= 2.;\n        f *= 2.;\n    }\n    return r/w;\n}\nvec2 screen2world(in vec2 fragCoord)\n{\n    return (2.0*fragCoord.xy - iResolution.xy)/iResolution.y;\n}\n\nvec2 fractalNoise2d(vec2 p, float t, float scale)\n{\n    return vec2(map5_value1(vec3(p*scale, t)), \n                map5_value1(vec3(p*scale+ vec2(100.0*scale), t)));   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = screen2world(fragCoord);\n    fragColor = -vec4(fractalNoise2d(pos, 0.0, 10.0)*0.01, 0.0, 0.0);\n}\n","name":"Buffer B","description":"","type":"buffer"}]}