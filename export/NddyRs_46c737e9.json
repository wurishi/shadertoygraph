{"ver":"0.1","info":{"id":"NddyRs","date":"1654013907","viewed":178,"name":"Maxwell Absorbing Boundary","username":"Amirk","description":"\"Perfectly absorbing boundary\" can be used to model waves escaping to infinity. Here it is implemented in x-axis (y-axis is periodic). The absorbing region (shaded darker) is anisotropic in a precise way to absorb all wavelengths. ","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["refraction","maxwell","electrodynamics"],"hasliked":0,"parentid":"fsccRX","parentname":"Maxwell 2D Plane wave"},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col=vec3(0);\n\n    float ez = texture(iChannel0,uv).r*200.;\n   // float HX= 0. texture(iChannel0,uv).g*40.;\n   // float HY= 0.texture(iChannel0,uv).b*40.;\n    \n   // float energy=0.5*(er*EZ*EZ+(HX*HX+HY*HY)/ur); //energy in the field\n   \n\n    col= color(1.51*ez)/(er*(1.+.3*sx(uv.x))*0.5);\n    \n    //draw obstacles:\n    uv = (fragCoord)/iResolution.y;\n    ObstacleLayer(uv,numLayers);\n    //draw obstacles:\n    col/=(er+1.)*.3;\n\n\n\n    // Output to screen\n    fragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//this Buffer updates magnetic field H with curls of E with buffer B\n\nivec2 per(int px, int py){\n  ivec2 r = ivec2(iResolution.xy);\n  ivec2 p=ivec2(px,py);\n  \n  return p = (p+r) % r; \n}\n\n    //We store Ez as col.r and Hx,Hy as col.g, col.b\n\nfloat Ez(int i, int j){\n    return texelFetch(iChannel0, per(i,j),0).r;\n}\nfloat Hx(int i, int j){\n    return texelFetch(iChannel0, per(i,j),0).g;\n}\nfloat Hy(int i, int j){\n    return texelFetch(iChannel0, per(i,j),0).b;\n}\n\n\nvoid ECurls(int i,int j){\n     ExCurl=  (Ez(i,j+1)-Ez(i,j))/dz;\n     EyCurl= -(Ez(i+1,j)-Ez(i,j))/dz;\n}\n\n//this integrated curl term is needed for perfectly absorbing boundary:\nvoid IntegrateExCurl(int i,int j){\n    if(iFrame<2000) \n        IntegratedExCurl= ExCurl+100000000.*texelFetch(iChannel1,ivec2(i,j),0).a;\n     else //to avoid numerical instability we cut it of after some time:\n         IntegratedExCurl=0.;\n     \n}\n\nvoid updateH(int i,int j){\n    float x =float(i)/iResolution.x;\n    HX=Hx(i,j) + mHx2(x)* ExCurl+ mHx3(x)*IntegratedExCurl;\n    HY=mHy1(x)*Hy(i,j) + mHy2(x)* EyCurl;\n}\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    vec3 col = vec3(0);\n    \n    int i=int(fragCoord.x);\n    int j=int(fragCoord.y);\n    \n    float t=dt*float(iFrame);\n    \n    //define smooth obstacle:\n    vec2 uv = (fragCoord)/iResolution.y;\n    ObstacleLayer(uv,numLayers);\n\n    \n    EZ=Ez(i,j);\n  \n    ECurls(i,j);\n    //for the absorbing boundary:\n    IntegrateExCurl(i,j);\n\n    //\"Totalfield-Scatteredfield method:\n    //creating a plane wave by modifying the curl:\n    if(i==sourceLoc-1) EyCurl += Esource(t)/dz; \n    \n    //update H:\n    updateH(i,j);\n    \n    \n    //store fields in color channels:\n    col.rgb=vec3(EZ,HX,HY);\n    \n    \n    fragColor = vec4(col,.000000001*IntegratedExCurl);\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":" //speed of light c:\n const float  c = 1.; \n //grid cell size:\n const float dz= 0.1;\n //permittivity of free space:\n const float e0=1.;\n //relative permittivity:\n float er = 1.0;\n //relative permeability:\n float ur = 1.0;\n //timestep is chosen so that one grid cell is traversed in excatly two time steps. \n //First time step is to update H, the second to update E.\n #define dt dz/(2.0*c)\n //some precalculations:\n  \n #define sourceLoc int(iResolution.x/4.)\n \n //smoothing factor of the obstacle boundary:\n float boundaryThickness=.05;\n float erObs=3.;\n float urObs=5.; \n int numLayers=2;\n\n\n\nfloat EX,EY,EZ,DZ, HX, HY,ExCurl,EyCurl,HzCurl, IntegratedExCurl;\n\n\nfloat sx(float x){\n    //absorbing boundary width scale:\n    float bndWidth=0.30;\n    //return e0*(smoothstep(bndWidth,0.0,x*x)+smoothstep(bndWidth,0.,(1.-x)*(1.-x)))/(8.*dt);\n    float f=4./(bndWidth*bndWidth*bndWidth);\n    return max(0.,f*(bndWidth-x)*(bndWidth-x)*(bndWidth-x))\n    +max(0.,f*(bndWidth-(1.-x))*(bndWidth-(1.-x))*(bndWidth-(1.-x)));\n    }\n\n\n//float mHx0(int i){return 1./dt;} \n//float mHx1(int i){return 1.;} \nfloat mHx2(float i){return -c*dt/ur;} \nfloat mHx3(float i){return -c*dt*dt*sx(i)/e0;} \n\nfloat mHy0(float i){return 1./dt+sx(i)/(2.*e0);} \nfloat mHy1(float i){return (2.*e0-sx(i)*dt)/(2.*e0+sx(i)*dt);} \nfloat mHy2(float i){return -c*2.*dt*e0/(2.*e0+sx(i)*dt)/ur;} \n\n//float mDz0(int i){return 1./dt+sx(i)/(2.*e0);} \nfloat mDz1(float i){return 1.;} \nfloat mDz2(float i){return c*2.*dt*e0/(2.*e0+sx(i)*dt);}\n\n//float mEz1() {return 1./er;}\n\n\n//a gaussian pulse, E term:\nfloat Esource(float time){ \n        return .001*exp(-(time-dt*100.0)*(time-dt*100.0)*2.);\n}\n//a gaussian pulse, H term:\nfloat Hsource(float time){ \n       //there is this phase shift in H wave, since H field \"lives time dt/2 ahead\" of E field.\n       float phase =dz/(2.*c)+dt/2.;\n       float amp=-1.; //-sqrt(er/ur);\n        \n       return .001*amp*exp(-(time-dt*100.0+phase)*(time-dt*100.0+phase)*2.); \n}\n\nfloat Obstacle(vec2 uv){\n\n float d= length(uv);\n    \n    float m =  smoothstep(0.5,0.5-boundaryThickness,d); // 0.01/(d*d);\n    \n    uv*=3.;\n    \n    m*=smoothstep(1.,.5,d);\n    return m;\n}\n\nvoid ObstacleLayer(vec2 uv, int numLayers){\n\n     uv*=5.;\n\n    vec2 gv= fract(uv)-0.5;         \n    float obstacle=Obstacle(gv);\n           \n    er+=(erObs-er)*obstacle*step(float(numLayers)+1.,uv.x)*(1.-step(1.+2.*float(numLayers),uv.x));\n    ur+=(urObs-ur)*obstacle*step(float(numLayers)+1.,uv.x)*(1.-step(1.+2.*float(numLayers),uv.x));\n    \n}\n\nvec3 color(float t)\n{\n vec3 col;\n col.r = 0.5-0.5*cos(2.*3.1416*(1.5*t+1.9));\n col.g = 0.5-0.5*cos(2.*3.1416*(.9*t+.15));\n col.b = 0.5-0.5*cos(2.*3.1416*(1.7*t+.2));\n return col;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//this Buffer updates electric field E with curls of H using buffer A\n\n\n//periodic boundary:\n ivec2 per(int px, int py){\n  ivec2 r = ivec2(iResolution.xy);\n  ivec2 p=ivec2(px,py);\n  \n  return p = (p+r) % r; \n}\n\n\n    //We store Ez as col.r and Hx,Hy as col.g, col.b\n\nfloat Ez(int i, int j){ \n    return texelFetch(iChannel0, per(i,j),0).r;\n}\n\nfloat Hx(int i, int j){\n    return texelFetch(iChannel0, per(i,j),0).g;\n}\n\nfloat Hy(int i, int j){\n    return texelFetch(iChannel0, per(i,j),0).b;\n}\n\n\n\nvoid HzCurls(int i,int j){\n     HzCurl=((Hy(i,j)-Hy(i-1,j))-(Hx(i,j)-Hx(i,j-1)))/dz;\n}\n\nvoid updateD(int i,int j){\n    float x= float(i)/iResolution.x;\n    DZ=mDz1(x)*Ez(i,j)*er + mDz2(x)* HzCurl;\n}\n\nvoid updateE(){\n    EZ= DZ / er;\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec3 col = vec3(0);\n    \n    int i=int(fragCoord.x);\n    int j=int(fragCoord.y);\n    \n    float t=dt*float(iFrame);\n    \n    //define smooth obstacle:\n    vec2 uv = (fragCoord)/iResolution.y;\n    ObstacleLayer(uv,numLayers);\n    \n    HzCurls(i,j);    \n    //\"Totalfield-Scatteredfield method:\n    //input source plane wave by modifying the curl:\n    if(i==sourceLoc) HzCurl -= Hsource(t)/dz; \n    \n    //update E:\n    updateD(i,j);\n    updateE();    \n    \n    HX=Hx(i,j);\n    HY=Hy(i,j);\n    \n    //store fields in color channels:\n    col.rgb=vec3(EZ,HX,HY);\n    fragColor = vec4(col,1.);\n}","name":"Buffer B","description":"","type":"buffer"}]}