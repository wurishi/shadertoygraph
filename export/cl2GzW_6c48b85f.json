{"ver":"0.1","info":{"id":"cl2GzW","date":"1672946183","viewed":70,"name":"Genuary 2023 Day 2","username":"qw","description":"definitely not done in \"10 minutes\", sorry not sorry :D\nLine segments attached to each other, with some incremental rotations, only drawing some.\nDrawn to a buffer, to additively stamp new frames on top of the previous one and then fade out.\n","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["genuary","genuary2"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float line_segment(in vec2 p, in vec2 a, in vec2 b) {\n\tvec2 ba = b - a;\n\tvec2 pa = p - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n\treturn length(pa - h * ba);\n}\n\nstruct Line\n{\n    vec2 start;\n    vec2 end;\n    float speed;\n};\n\nLine InitLine( vec2 start, vec2 end, float speed)\n{\n    Line line;\n    line.start = start;\n    line.end = end;\n    line.speed = speed;\n    return line;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 pos = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.);\n\n    int LineCount = 7;\n    Line lines[7];\n    lines[0] = InitLine(vec2(0.), vec2(0.), 1.);\n    lines[1] = InitLine(vec2(0.), vec2(0.), 1.2);\n    lines[2] = InitLine(vec2(0.), vec2(0.), 0.84);\n    lines[3] = InitLine(vec2(0.), vec2(0.), 1.423);\n    lines[4] = InitLine(vec2(0.), vec2(0.), 0.941);\n    lines[5] = InitLine(vec2(0.), vec2(0.), 0.89);\n    lines[6] = InitLine(vec2(0.), vec2(0.), 1.);\n    \n    \n    float thickness = 0.01f;\n    float pixelWidth = 1.5/iResolution.y;\n\n    \n    for( int i = 0; i < LineCount; ++i)\n    {\n        if( i > 0)\n        {\n            lines[i].start = lines[i-1].end;\n            lines[i].end = lines[i].start + \n                vec2( cos((float(i)*45.f)+iTime * lines[i].speed),\n                      sin((float(i)*32.8f)+iTime* lines[i].speed) ) * 0.15f;\n        }\n    }\n    \n    \n    \n    int drawLineIndex = 2;\n    float d1 = smoothstep(pixelWidth, 0.f, \n                            line_segment(pos, lines[drawLineIndex].start, lines[drawLineIndex].end) - thickness) \n                - smoothstep(pixelWidth, 0.f, line_segment(pos, lines[drawLineIndex].start, lines[drawLineIndex].end) - thickness*.8);\n \n    drawLineIndex = 4;\n    float d2 = smoothstep(pixelWidth, 0.f, \n                            line_segment(pos, lines[drawLineIndex].start, lines[drawLineIndex].end) - thickness) \n                - smoothstep(pixelWidth, 0.f, line_segment(pos, lines[drawLineIndex].start, lines[drawLineIndex].end) - thickness*.8);\n    \n    \n    drawLineIndex = 6;\n    float d3 = smoothstep(pixelWidth, 0.f, \n                            line_segment(pos, lines[drawLineIndex].start, lines[drawLineIndex].end) - thickness) \n                - smoothstep(pixelWidth, 0.f, line_segment(pos, lines[drawLineIndex].start, lines[drawLineIndex].end) - thickness*.8);\n    \n    \n    vec3 d1Col = d1 * vec3( .5 + ((sin(iTime) * 0.5) + 0.5) * 0.3,.5, abs( cos(iTime) ) * .3);\n    vec3 d2Col = d2 * vec3(.5 + ((cos(iTime) * 0.5) + 0.5) * 0.3,.4,.7);\n    vec3 d3Col = d3 * vec3(.1, .5 + ((sin(iTime) * 0.5) + 0.5) * 0.3, .3 + ((cos(iTime)*.5)+.5) *.3);\n    \n    col = max(d1Col,max(d2Col,d3Col));\n    \n    \n   // Output to screen\n    fragColor = vec4(col,1.0);\n\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 prevFragColor = texture(iChannel0, uv);\n\n    float fadeSpeed = 0.5f;\n    fragColor = max(prevFragColor - vec4(iTimeDelta * fadeSpeed) , fragColor);\n\n}\n\n\n\n","name":"Buffer A","description":"","type":"buffer"}]}