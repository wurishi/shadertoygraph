{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"const float MAX_TRACE_DISTANCE = 10.0;             // max trace distance\nconst float INTERSECTION_PRECISION = 0.0001;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 100;\nconst float PI = 3.14159;\n\nconst int lightNum = 10;\nvec3 lightPos[ lightNum ];\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n    \n\treturn (d1.x<d2.x) ? d1 : d2;\n    \n}\n\n\nvec2 centerSphere( vec3 pos , float time ){\n    return vec2( sin(iTime + cos( pos.x * 2. ) + sin( pos.y )+ cos( pos.z * .59))*.1 + length( pos ) - .8 , 0. );\n}\n\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 pos ){  \n    \n   \t//vec2 res = vec2( (abs(sin( pos.x * pos.y * pos.z  * 10.)) * 1.9 ) + length( pos ) - 1., 0.0 );\n  \n    vec2 res = centerSphere( pos , iTime );\n    \n    //vec2 res = vec2( length( pos ) - .6  , 0. );\n    \n    for( int i = 0; i < lightNum; i++ ){\n     \n        float d = length( pos - lightPos[i] );\n        vec2 res2 =vec2( d - (pow(((sin(float( i) + 10.*sin( iTime ))) / float(lightNum)) , 2.) * 10.5 + .3) , 1. ); \n        res = opU( res ,  res2 );\n        \n    }\n    \n\n    \n   \treturn res;\n    \n}\n\n\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 0.3 + 1.0*mouseX;\n\tcamPos = vec3(3.5*sin(an),cos( time * .1 ),3.5*cos(an));\n    camTar = vec3(sin( time * .1) ,0.0,0.0);\n}\n\n\n\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos ){\n    \n\tvec3 eps = vec3( 0.01, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\n\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd ){\n\n    \n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n\t   \tvec2 m = map( ro+rd*t );\n        h = m.x;\n        t += h;\n        id = m.y;\n        \n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec2( res , id );\n    \n   \n}\n\n\nvec3 lightCol( vec3 pos , vec3 nor , vec3 lig , vec3 eye ){\n  \n    vec3 col;\n    \n\n \tvec3 light = normalize( lig - pos );\n \tfloat lightLength = length( lig - pos );\n    vec3 refl = reflect( light , nor );\n\n    float lightMatch = max( 0. , dot( light  , nor ));\n\n    float reflMatch =  max( 0. , dot( eye , refl) );\n\n\n\n    vec3 lamb = pow( lightMatch,3.) *  vec3( 1. , .3 , .1 );\n    vec3 spec = pow( reflMatch , 20. ) *  vec3( 1. , .5 , .0 ) ;\n\n    col = spec + lamb;\n\n\treturn col;\n    \n    \n}\n\nvec3 doBackground( vec3 rd , vec3 ogRD ){\n \n    vec3 col = vec3(0.);\n    col = pow( max( 0. , dot( ogRD , rd )) , 100.)* vec3( 1. , .6 , .2 );; \n    col +=pow( max( 0. , dot( vec3( 0. , 0. , 1. ) , rd )) , 10.)* vec3( 1. , .5 , .2 );\n    col +=pow( max( 0. , dot( normalize(vec3( 1. , 1. , -1. )) , rd )) , 10.)* vec3( 1. , .5 , .2 );   \n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n   \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    m.x = sin( iTime * .1 );\n    \n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m.x );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    vec3 ogRD = normalize( camMat * vec3(0. , 0.,2.0) );\n    \n       \t    \n    for( int i = 0; i < lightNum; i++ ){\n     \n        float x = 1.5 * cos( (float(i) / float( lightNum ) ) * 2. * PI );\n        float z = 1.5 * sin( (float(i) / float( lightNum )  ) * 2. * PI );\n        float y = 1. * cos( (float(i) / float( lightNum ) ) * 8. * PI );\n        lightPos[i] = vec3( x  , y , z );\n        \n    }\n    \n    vec2 res = calcIntersection( ro , rd  );\n    \n    vec3 col = vec3( 0. , 0. , 0. ); \n    \n        // If we have hit something lets get real!\n    if( res.y > -.5 ){\n            \n        vec3 pos = ro + rd * res.x;\n        vec3 nor = calcNormal( pos );\n            \n\n        float eyeMatch = max( 0. , dot( -nor , rd ));\n\t\tvec3 rim  = pow( (1.-eyeMatch) , 3. ) * vec3( 1. , .5 , .2 );// * ( nor * .5 + .5 );\n\n\n\n        \n        vec3 refl = normalize( reflect( rd , nor ));\n        vec3 sta2 = pos + (refl * .001 );\n        vec2 res2 = calcIntersection( sta2 , refl );\n\n        if( res2.y > -.5 ){\n\n\n            vec3 p2 = pos + refl * res2.x;\n            vec3 n2 = calcNormal( p2 );\n            \n            //col = n2 * .5  + .5;\n            for( int i =0; i < lightNum; i++ ){  \n                col +=  lightCol( sta2 , n2 , lightPos[i] , refl );  \n            }\n            \n            \n            float eyeMatch = max( 0. , dot( -n2 , refl ));\n\t\t\tvec3 rim  = pow( (1.-eyeMatch) , 3. ) * vec3( 1. , .5 , .2 );\n            if( res2.y < .5 ){\n                \n                col = rim;\n                \n                \n            }\n            \n          \n\n        }else{\n\n            for( int i =0; i < lightNum; i++ ){  \n                col +=  lightCol( pos , nor , lightPos[i] , rd );  \n            }\n\n            col += rim;\n            \n            if( res.y < .5 ){\n                \n                col = rim;\n                \n                \n            }\n\n        }\n\n\n\n        \n    }else{\n    \tcol = doBackground(rd , ogRD);  \n    }\n    \n    // apply gamma correction\n    col = pow( col, vec3(0.4545) );\n\n    fragColor = vec4( col , 1. );\n    \n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XlXGRf","date":"1423753544","viewed":305,"name":"SHADE A DAY ( 2 / 12 / 2015 )","username":"cabbibo","description":"continuing on the path of gold","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raytrace","reflections"],"hasliked":0,"parentid":"","parentname":""}}