{"ver":"0.1","info":{"id":"tltXWS","date":"1581637376","viewed":120,"name":"Wedge Editor","username":"spalmer","description":"simple interactive test rig for 3 consecutive point signed vertex/edge distance function;\ngot tired of [url]https://shadertoy.com/view/wtcXWH[/url] spinning so much and only being able to edit one point there.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["distance","editor","vertex"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// fixing and reducing https://shadertoy.com/view/4tsSRr which only handled convex\n// more interactive than https://shadertoy.com/view/wtcXWH\n// iq also did https://shadertoy.com/view/wldXWB for convex cases\n\n// reset after clicking the mouse if there's a problem when first loaded FIXME\n\n// the original sdTriangle had MIT license.\n// but these seem more closely related now to sdWedge\n// which he posted without any explicit license,\n// so is just CCA - so these can just be CCA also.\n\n\n// partial seg2 - dir from closest point on seg\nvec2 rseg(vec2 v, vec2 e)\n{\n    return v - e*clamp(dot(v,e)/dot(e,e), 0., 1.);\n}\n\n// perp dot product\nfloat pdot(vec2 a, vec2 b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\n#if 1\n// trying again, starting from iq's last suggestion, \n// where he inlined rseg\n// as his setup is much cleaner than mine by now\nfloat triwedge3iqsp2(vec2 b, vec2 c, vec2 a, vec2 q)\n{\n    q -= c, a -= c, b -= c;\n    float qq = dot(q,q);\n    float qa = dot(q,a);\n    float qb = dot(q,b);\n    float aa = dot(a,a);\n    float bb = dot(b,b);    \n    float h1 = clamp(qa/aa, 0.0, 1.0);\n    float h2 = clamp(qb/bb, 0.0, 1.0);\n    // this d was coming out slightly less than 0.0, causing problems!\n    float d = max(0., qq + min(\n        h1*(h1*aa - 2.0*qa),\n        h2*(h2*bb - 2.0*qb)));\n    float q1 = pdot(q,a)\n        , q2 = pdot(b,q)\n        , qs = pdot(a,b);\n\tfloat t = qs >= 0. ? max(q1,q2) : min(q1,q2);\n    return sqrt(d) * ((t>=0.0) ? 1.0 : -1.0);\n}\n#endif\n\n// apparently GLES sign(denormalized) isn't reliable!\n\n\n// similar but copied iq's setup, made branchless,\n// took more of his advice; iq should be credited here too.\nfloat triwedge3sp2(vec2 a, vec2 c, vec2 b, vec2 q)\n{\n    q -= c; a -= c; b -= c;\n    vec2  o1 = rseg(q, a)\n\t\t, o2 = rseg(q, b);\n    float d = sqrt(min(dot(o1, o1), dot(o2, o2)));\n    bool  q1 = pdot(q, a) >= 0.\n        , q2 = pdot(b, q) >= 0.\n        , qs = pdot(b, a) >= 0.;\n    return (q1 && q2) || (q1 && !qs) || (q2 && !qs)\n        ? -d : d;\n}\n\n\n\n// \"standard\" sdf gradient debugging    \nvec3 DebugSDF(float d)\n{\n    vec3 col = vec3(1) - sign(d)*vec3(.1,.5,.9);\n\tcol *= 1. - exp(-2.*abs(d));\n\tcol *= .8 + .2*cos(120.*d);\n    return mix(col, vec3(1), 1.-smoothstep(.0,.02,abs(d))); // white at zero\n}\n\nvoid mainImage(out vec4 c, vec2 p)\n{\n\tvec2 R = iResolution.xy;\n\n\tvec2 v1 = texelFetch(iChannel0, ivec2(0,0), 0).xy;\n\tvec2 v2 = texelFetch(iChannel0, ivec2(1,0), 0).xy;\n\tvec2 v3 = texelFetch(iChannel0, ivec2(2,0), 0).xy;\n\n\tfloat d = \n      triwedge3iqsp2  // cool\n//      triwedge3sp2 // works and isn't terrible\n        (v1, v2, v3, p);\n\n    d /= 128.; // making up for fact that all points are in screen pixels here\n\n    c.rgb = DebugSDF(d); // colorize - orange is positive\n    \n  #if 1\n    // special for this test, show colored dots at the points\n    // must be able to see the points to grab them!\n    float pd = 3.4e38, d0; vec3 pc = vec3(1);\n    // too many sqrts but whatevs\n    if ((d0 = distance(v1, p)) < pd) { pd = d0; pc = vec3(1,0,0); }\n    if ((d0 = distance(v2, p)) < pd) { pd = d0; pc = vec3(0,1,0); }\n    if ((d0 = distance(v3, p)) < pd) { pd = d0; pc = vec3(0,0,1); }\n    c.rgb += pc * exp2(-.5*pd);\n  #endif\n    // also helps understand the order/winding\n    \n\tc.rgb = pow(c.rgb, vec3(.4545)); // gamma-corrected \n\tc.a = 1.;\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// 3 point editor using mouse\n\nvoid mainImage(out vec4 c, vec2 p)\n{\n    ivec2 q = ivec2(p);\n    if (iFrame < 2) {\n        c = vec4(0);\n        if (q.y == 0)\n            if (q.x < 3) {\n    \t\t#if 1\n                // collinear test case for ollj scenario\n    \t\t\tc.xy = vec2(p.x * -.3 + .95, .5)*iResolution.xy;\n    \t\t#else\n                // V shape\n       \t\t\tc.xy = ((cos(vec2(0,1.57) - float(q.x) * 1.5)*.5 + vec2(1.8,1.))/2.) * iResolution.y;\n    \t\t#endif                \n            }\n    } else {\n\t    c = texelFetch(iChannel0, q, 0);\n\t    if (q.y == 0) {\n\t        if (q.x < 3) {\n\t            if (iMouse.z >= 0.) {\n\t\t            vec2 m = iMouse.xy;\n\t                int iclosest = -1;\n\t                float dclosest = 3.4e38;\n\t                for (int i = 0; i < 3; ++i) {\n\t                    float d = distance(m, texelFetch(iChannel0, ivec2(i,0),0).xy);\n\t                    if (d < dclosest) {\n\t                        dclosest = d;\n\t                        iclosest = i;\n\t                    }\n\t                }\n                    // the right way would be, what, to store the closest index on mouse down?\n                    // maybe just take closest one, no matter how far\n\t                if (iclosest == q.x) {\n\t                    c.xy = m; // drag\n\t                }\n\t            }\n\t        }\n\t    }\n    }\n}\n\n","name":"Buffer A","description":"","type":"buffer"}]}