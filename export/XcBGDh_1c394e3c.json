{"ver":"0.1","info":{"id":"XcBGDh","date":"1704126188","viewed":34,"name":"Screensaver madness","username":"wassilyevich","description":"Further experimentation on the raymarching tutorial by Kishimisu.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n\n#define M_PI 3.1415926535897932384626433832795\n\n\n\n// cosine based palette, 4 vec3 params\nvec3 palette( in float t)\n{\n    vec3 a = vec3(0.8, 0.5, 0.4);\n    vec3 b = vec3(0.2, 0.4, 0.2);\n    vec3 c = vec3(2.0, 1.0, 1.0);\n    vec3 d = vec3(1.+sin(iTime*0.1), 1.+sin(iTime*0.1), 1.+sin(iTime*0.1));\n\n    // vec3 d = vec3(0.00, 0.25, 0.25);\n    // vec3 a = vec3(0.138, -0.162, 0.208);\n    // vec3 b = vec3(1.128, 1.098, 0.538);\n    // vec3 c = vec3(-0.432, 0.528, 0.678);\n    // vec3 d = vec3(-0.782,-2.363, -2.477);\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\n// SDF of a sphere\nfloat sdSphere(vec3 p, float s){\n    return length(p) - s; // with s the radius of the sphere, and p the position of the center of the sphere\n}\n\n\n\n// SDF of an octahedron\nfloat sdOctahedron( vec3 p, float s )\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\n// Smooth minimum\nfloat smin(float a,float b,float k){\n    float h = max(k-abs(a-b),0.)/k;\n    return min(a,b) - h*h*h*k*(1.0/6.0);\n}\n\n// Rodrigues rotation\nvec3 rot3D(vec3 p, vec3 axis, float angle){\n    return mix(dot(axis,p) * axis, p, cos(angle)) + cross(axis,p) * sin(angle);\n}\n\n// 2D rotation\nmat2 rot2D(float angle){\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c,-s,s,c);\n}\n\n\n// Distance to the scene (function)\nfloat map(vec3 p){\n    vec3 q = p;\n    float mult = 0.5+(0.25*sin(iTime*0.1));\n    q = mod(q,mult) - mult/2.;   \n    float sphere = sdSphere(q,0.01*mult);\n    \n\n    // Space repetition\n    p.z+= iTime*0.1;\n    float time = 0.1;\n    float scale = abs(sin(iTime*time));\n    vec2 disp = vec2(sin(0.1*iTime),sin(0.2*iTime+1.));\n    p.xy = fract(p.xy) -0.5;\n    p.xy*=rot2D(iTime*0.5*sin(iTime*0.0005));\n    p.z = mod(p.z,0.5)-0.250;\n\n\n    float box = sdOctahedron(p*scale,0.2)/scale;\n\n    \n\n    return smin(box,sphere,0.6+(0.5*sin(iTime*0.05)));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n\n    // INITIALIZATION\n    \n    vec3 ro = vec3(0,0,-3);                     // ray origin\n    vec3 rd = normalize(vec3(uv*abs(1.1-sin(iTime*0.03)),1));            // ray direction\n    vec3 col = vec3(0);                         // final pixel color\n\n    float t = 0.;                                // total distance travelled\n\n\n    \n\n    // RAYMARCHING\n    int i;\n    for(i=0;i<80; i++){\n        vec3 p = ro + rd*t;                         // position along the ray\n        p.xy *= rot2D(t*0.1);\n        p.x += cos(t+iTime*0.4)*(0.25*sin(iTime*0.2));\n        p.y += sin(t+iTime*0.2)*0.1;\n        float d = map(p);                           // current distance to the scene\n\n       t+=d;                                       // step where the ray is marched\n\n       if(d < 0.001 || t > 100.) break;\n\n    }\n\n    // COLORING\n    // for(int j=0;j<4;j++){\n    //     t = sin(t);\n    // }\n    float dd = length(uv) * exp(-length(uv));\n    dd = dd*sin(t + (0.2*sin(iTime*0.01))*iTime);\n    dd = abs(dd);\n    dd = pow(0.1/dd,1.2);\n    col = palette(0.05*t + float(i)*0.002);                                    // Coloring based on the travelled distance\n    vec3 finalColor = vec3(0);\n    finalColor = col*dd + 0.5*abs(col*sin(iTime*0.05));\n\n\n    fragColor = vec4(finalColor,1);\n}","name":"Image","description":"","type":"image"}]}