{"ver":"0.1","info":{"id":"3lcGzN","date":"1576052571","viewed":91,"name":"Simple3D_Ellipse","username":"lypion","description":"ray tracing, ellipse intersection, Blinn-Phong lighting","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n---Base---\n\tThis one is created base one Simple 3D_sphere: https://www.shadertoy.com/view/wsGSDG\n\n---Main Content\n\tBesides base content, it also include:\n\t1. How to draw a ellipse based on a unit sphere using transforming matrices\n*/\n\n#define LIGHT_AMBIENT vec3(0.5)\n\nstruct Ellipse\n{\n\tvec3 position;\n    //The x, y, z length of the ellipse\n    vec3 scale;\n    //The x,y,z-axis rotation \n    vec3 rotation;\n    Material material;\n};\n\n//All objects is defined in its self space\nPlane plane = Plane(vec3(0.0), normalize(vec3(0.0, 1.0, 0.0)), Material(vec3(0.2), vec3(0.9), vec3(0.2), 4.0));\nEllipse ellipse = Ellipse(vec3(0.), vec3(4., 2., 2.), vec3(0.), Material(vec3(0.2), vec3(0.8, 0.2, 0.6), vec3(0.2), 4.0));\n\n//We can get an ellipse by translating, rotating, nonuniform-scaling\n//an unit sphere positioned at the origin point \nmat4 CalSphereToEllipseTransMatrix(Ellipse ellipse)\n{\n\tmat4 scale = Scale(ellipse.scale);\n    mat4 rotation = Rotate(ellipse.rotation);\n    mat4 translate = Translate(ellipse.position);\n    return translate * rotation * scale;\n}\n\n//Or we can just use inverse function\nmat4 CalEllipseToSphereTransMatrix(Ellipse ellipse)\n{\n\tmat4 inverseScale = Scale(1. / ellipse.scale);\n    mat4 inverseRotate = Rotate(-1. * ellipse.rotation);\n    mat4 inverseTrans = Translate(-ellipse.position);\n    return inverseScale * inverseRotate * inverseTrans;\n}\n\nbool IsIntersectWithEllipse(Ray ray, Ellipse ellipse)\n{\n    mat4 inverseMat = CalEllipseToSphereTransMatrix(ellipse); \n    vec3 origin = vec3(inverseMat * vec4(ray.origin, 1.));\n    vec3 direction = normalize(vec3(inverseMat * vec4(ray.direction, 0.)));\n    Ray newRay = Ray(origin, direction, ray.tMIN, ray.tMAX);\n    Sphere unitSphere = Sphere(vec3(0.), ellipse.material, 1.);\n\treturn IsIntersectWithSphere(newRay, unitSphere);\n}\n\nIntersection IntersectWithSphereFirst(Intersection intersection, Sphere sphere)\n{\n\tvec3 temp = intersection.ray.origin - sphere.position;\n    float a = dot(intersection.ray.direction, intersection.ray.direction);\n    float b = dot(intersection.ray.direction, temp);\n    float c = dot(temp, temp) - sphere.radius * sphere.radius;\n    float delta = b * b - a * c;\n    \n    if(delta > 0.00001)\n    {\n    \tfloat sqrtDelta = sqrt(delta);\n    \tfloat t1 = (-b + sqrtDelta) / a;\n        float t2 = (-b - sqrtDelta) / a;\n        \n        if(t2 > intersection.ray.tMIN && t2 < intersection.t)\n        {\n            vec3 point = intersection.ray.origin + intersection.ray.direction * t2;\n            vec3 normal = CalSphereNormal(sphere, point);\n        \tintersection.t = t2;\n            intersection.color = sphere.material;\n            intersection.normal = normal;\n            intersection.hasIntersect = true;\n        }        \t\n        else if(t1 > intersection.ray.tMIN && t1 < intersection.t)\n        {\n            vec3 point = intersection.ray.origin + intersection.ray.direction * t1;\n            vec3 normal = CalSphereNormal(sphere, point);\n        \tintersection.t = t1;\n            intersection.color = sphere.material;\n            intersection.normal = normal;\n            intersection.hasIntersect = true;\n        }        \t\n    }\n    return intersection;\n}\n\n\nIntersection IntersectWithPlaneFirst(Intersection intersection, Plane plane)\n{\n\tfloat denominator = dot(intersection.ray.direction, plane.normal);\n\tif(abs(denominator) < 0.00001)\n        return intersection; \n    \n    float t = dot((plane.point - intersection.ray.origin), plane.normal) / denominator;\n    if(t > intersection.ray.tMIN && t < intersection.ray.tMAX && t < intersection.t)\n    {\n    \tintersection.t = t;\n        intersection.color = plane.material;\n        intersection.normal = plane.normal;\n        intersection.hasIntersect = true;\n    } \n    return intersection;\n}\n\n//When we check whether a ray intersects with a ellipse, we tranform the ray using the\n//inverse matrix which transform the unit sphere to the ellipse.\n//The t value remains the same when we use a new ray to intersect with the unit sphere.\n//There is a pitfall that we should NOT normalize the new direction, because we want to keep \n//the scale remain same.\nIntersection IntersectionWithEllipseFirst(Intersection intersection, Ellipse ellipse)\n{\n    mat4 inverseMat = CalEllipseToSphereTransMatrix(ellipse);    \n    vec3 origin = vec3(inverseMat * vec4(intersection.ray.origin, 1.));\n    vec3 direction = vec3(inverseMat * vec4(intersection.ray.direction, 0.));\n    Ray newRay = Ray(origin, direction, intersection.ray.tMIN, intersection.ray.tMAX);\n\tIntersection newIntersection = Intersection(newRay, intersection.color, intersection.normal, intersection.t, false);\n    Sphere unitSphere = Sphere(vec3(0.), ellipse.material, 1.);\n    newIntersection = IntersectWithSphereFirst(newIntersection, unitSphere);\n    if(true == newIntersection.hasIntersect)\n        return newIntersection;\n    else\n        return intersection;\n}\n\nRay GenerateRay(Camera camera, vec2 uv)\n{\n\tuv -= vec2(0.5);\n    float halfHeight = tan(camera.fov / 2.0) * camera.frustum.nearestPlane;\n    float halfWidth = halfHeight / camera.aspectRatio;\n    vec3 pixelInViewSpace = vec3(0.0, 0.0, -camera.frustum.nearestPlane) + \n                 \t\t\tvec3(2.0 * uv.x * halfWidth * camera.aspectRatio * camera.aspectRatio, 0.0, 0.0) + \n                 \t\t\tvec3(0.0, 2.0 * uv.y * halfHeight, 0.0);\n    return Ray(vec3(0.0), normalize(pixelInViewSpace), RAY_MIN, RAY_MAX);\n}\n\n\nvec3 ShadowTest(Intersection intersection, vec3 lightDirect)\n{\n    vec3 point = intersection.ray.origin + intersection.ray.direction * intersection.t;\n\tvec3 newPoint = point - 0.01 * lightDirect;\n    Ray shadowRay = Ray(newPoint, -lightDirect, RAY_MIN, RAY_MAX); \n   \t\n    bool interWithEllipse = IsIntersectWithEllipse(shadowRay, ellipse);    \n \tbool interWithPlane = IsIntersectWithPlane(shadowRay, plane); \n    if(interWithEllipse || interWithPlane) \n    \treturn vec3(0.0);\n    else\n        return vec3(1.0);\n}\n\nvec3 RayTracing(Ray ray, DirectLight directLight, Camera camera)\n{\n    Material defultMat = Material(vec3(1.0), vec3(1.0), vec3(1.0), 0.0);\n    \n\tIntersection intersection = Intersection(ray, defultMat, vec3(1.0, 0.0, 0.0), RAY_MAX, false);\n    intersection = IntersectionWithEllipseFirst(intersection, ellipse);\n    intersection = IntersectWithPlaneFirst(intersection, plane);\n    //The ambient color is added whether or not the ray hits something\n    vec3 color = LIGHT_AMBIENT * intersection.color.ambient;\n    vec3 lightColor;\n    if(intersection.hasIntersect == true)\n    {\n    \tlightColor = CalDirectLight(directLight, intersection, vec3(0.0));\n        lightColor = lightColor * ShadowTest(intersection, directLight.direction);\n        return color + lightColor;\n    }\n    return vec3(1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    Frustum frustum = Frustum(2.0, 100.0);\n\tvec3 cameraPos = vec3(0.0, 2.0, 0.0);\n\tvec3 cameraTar = vec3(0.0, 2.0, -1.);\n\tCamera camera = Camera(cameraPos, cameraTar, vec3(0.0, 1.0, 0.0), frustum, \n                           80.0 / 180.0 * PI, iResolution.x / iResolution.y);\n    \n    //world space postion\n    vec3 ellipsePos = vec3(0.0, 2., -6.0);\n    mat4 ellipseTransform = CalWorld2ViewMatrix(camera) * Translate(ellipsePos);\n    ellipse.position = vec3(ellipseTransform * vec4(ellipse.position, 1.0)); \n    ellipse.rotation = vec3(0., 0., 0.);\n\n    //translate the plane from self space to world space\n    mat4 planeTransform = CalWorld2ViewMatrix(camera); \n    plane.point = (planeTransform * vec4(plane.point, 1.0)).xyz;\n    mat4 normalMat = planeTransform;\n    plane.normal = normalize((normalMat * vec4(plane.normal, 0.0)).xyz);\n    \n    vec3 direction = normalize(vec3(cos(iTime * 0.1) * 10.0, -abs(sin(iTime * 0.1)) * 10.0, cos(iTime * 0.1) * 10.0 - 12.));\n    DirectLight directLight = DirectLight(direction, vec3(1.0));      \n    directLight.direction = vec3(CalWorld2ViewMatrix(camera) * vec4(directLight.direction, 0.0)).xyz;\n    \n    Ray ray = GenerateRay(camera, uv);   \n    vec3 color = RayTracing(ray, directLight, camera);\n\n    fragColor = vec4(color,1.0);    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//The nearest intersect distance\n#define RAY_MIN 0.0001f\n//The farest intersect distance\n#define RAY_MAX 1.0e20f\n\n#define PI 3.1415\n\nstruct Ray\n{\n\tvec3 origin;\n    vec3 direction;\n    float tMIN;\n    float tMAX;       \n};\n    \nstruct DirectLight\n{\n\tvec3 direction;\n\tvec3 color;\n};\n    \nstruct Material\n{\n    vec3 ambient;\n\tvec3 diffuse;\n    vec3 specular;\n    float shininess;\n};\n    \nstruct Intersection\n{\n    Ray ray;\n    Material color;\n    vec3 normal;\n\tfloat t;\n    bool hasIntersect;\n};\n    \nstruct Plane\n{\n\tvec3 point;\n    vec3 normal;\n    Material material;\n};\n    \nstruct Sphere\n{\n\tvec3 position;\n    Material material;\n    float radius;\n};\n   \n\n    \nstruct Frustum\n{\n    //the distance between near plane and camera\n    float nearestPlane;\n    //the distance between far plane and camera\n    float farestPlane;\n};\n    \nstruct Camera\n{\n\tvec3 position;\n    vec3 target;\n    vec3 upGuide;   //the vector used to calculate the coordinate of camera, not the real up vector of camera\n    Frustum frustum;\n    float fov;\n    float aspectRatio;\n};\n\nmat4 Scale(vec3 param)\n{\n\treturn mat4(vec4(param.x, 0.0, 0.0, 0.0),\n                vec4(0.0, param.y, 0.0, 0.0),\n                vec4(0.0, 0.0, param.z, 0.0),\n                vec4(0.0, 0.0, 0.0, 1.0));\n}\n\nmat4 Translate(vec3 param)\n{\n\treturn mat4(vec4(1.0, 0.0, 0.0, 0.0),\n                vec4(0.0, 1.0, 0.0, 0.0),\n                vec4(0.0, 0.0, 1.0, 0.0),\n                vec4(param, 1.0));\n}\n\nmat4 Rotate(vec3 param)\n{\n\tmat4 xMat = mat4(vec4(1.0, 0.0, 0.0, 0.0),\n                     vec4(0.0, cos(param.x), sin(param.x), 0.0),\n                     vec4(0.0, -sin(param.x), cos(param.x), 0.0),\n                     vec4(0.0, 0.0, 0.0, 1.0));\n    mat4 yMat = mat4(vec4(cos(param.y), 0.0, -sin(param.y), 0.0),\n                     vec4(0.0, 1.0, 0.0, 0.0),\n                     vec4(sin(param.y), 0.0, cos(param.y), 0.0),\n                     vec4(0.0, 0.0, 0.0, 1.0));\n    mat4 zMat = mat4(vec4(cos(param.z), sin(param.z), 0.0, 0.0),\n                     vec4(-sin(param.z), cos(param.z), 0.0, 0.0),\n                    vec4(0.0, 0.0, 1.0, 0.0),\n                    vec4(0.0, 0.0, 0.0, 1.0));\n    return zMat * yMat * xMat;\n}\n\nmat4 CalWorld2ViewMatrix(Camera camera)\n{\n\tvec3 zDirec = normalize(camera.position - camera.target);\n    vec3 xDirec = normalize(cross(camera.upGuide, zDirec));\n    vec3 yDirec = cross(zDirec, xDirec);\n    mat4 view2World = mat4(vec4(xDirec, 0.0), \n                           vec4(yDirec, 0.0), \n                           vec4(zDirec, 0.0), \n                           vec4(0.0, 0.0, 0.0, 1.0));\n\t\n    mat4 translateMat = mat4(vec4(1.0, 0.0, 0.0, 0.0), \n                             vec4(0.0, 1.0, 0.0, 0.0), \n                             vec4(0.0, 0.0, 1.0, 0.0), \n                             vec4(-camera.position, 1.0));\n    return transpose(view2World) * translateMat;\n}\n\nmat4 CalView2WorldMatrix(Camera camera)\n{\n\tvec3 zDirec = normalize(camera.position - camera.target);\n    vec3 xDirec = normalize(cross(camera.upGuide, zDirec));\n    vec3 yDirec = cross(zDirec, xDirec);\n    mat4 view2World = mat4(vec4(xDirec, 0.0), \n                           vec4(yDirec, 0.0), \n                           vec4(zDirec, 0.0), \n                           vec4(0.0, 0.0, 0.0, 1.0)); \n    mat4 translateMat = mat4(vec4(1.0, 0.0, 0.0, 0.0), \n                             vec4(0.0, 1.0, 0.0, 0.0), \n                             vec4(0.0, 0.0, 1.0, 0.0), \n                             vec4(camera.position, 1.0));\n    return view2World * translateMat;\n}\n\nvec3 CalSphereNormal(Sphere sphere, vec3 point)\n{\n\treturn normalize(point - sphere.position);\n}\n\nbool IsIntersectWithSphere(Ray ray, Sphere sphere)\n{\n\tvec3 temp = ray.origin - sphere.position;\n    float a = dot(ray.direction, ray.direction);\n    float b = dot(ray.direction, temp);\n    float c = dot(temp, temp) - sphere.radius * sphere.radius;\n    float delta = b * b - a * c;\n    \n    if(delta > 0.00001)\n    {\n        float sqrtDelta = sqrt(delta);\n    \tfloat t1 = (-b + sqrtDelta) / a;\n        float t2 = (-b - sqrtDelta) / a;\n \n        \n        if(t2 > ray.tMIN && t2 < ray.tMAX)\n       \t{\n            return true;\n        }\n        else if(t1 > ray.tMIN && t1 < ray.tMAX)\n        {\n\t\t\treturn true;     \n        }\n    }        \n    return false;\n}\n\nbool IsIntersectWithPlane(Ray ray, Plane plane)\n{\n    float denominator = dot(ray.direction, plane.normal);\n\tif(abs(denominator) < 0.00001)\n        return false;\n    \n    float t = dot((plane.point - ray.origin), plane.normal) / denominator;\n\tif(t > ray.tMIN && t < ray.tMAX)\n        return true;\n    return false;\n}\n\n\n\nvec3 CalDirectLight(DirectLight light, Intersection intersection, vec3 viewPos)\n{   \n    //diffuse\n    float diff = max(0.0, dot(-light.direction, intersection.normal));\n    vec3 diffuse = diff * light.color * intersection.color.diffuse;\n    \n    //specular\n    vec3 viewDirect = normalize(viewPos - (intersection.ray.origin + intersection.t * intersection.ray.direction));\n    vec3 h = normalize(-light.direction + viewDirect);\n    vec3 specular = light.color * intersection.color.specular * pow(max(0.0, dot(intersection.normal, h)), intersection.color.shininess);\n\t\n    return diffuse + specular;\n}\n","name":"Common","description":"","type":"common"}]}