{"ver":"0.1","info":{"id":"XdByzh","date":"1490731034","viewed":524,"name":"ShadowArtefact","username":"mathiassoeholm","description":"I ran into some weird problems with the shadows.\nTry rotating the camera so you are looking straight down.\nI removed as much code as possible, to make it easier to narrow down the issue.\nDoes anyone know what might be wrong? :-)","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymaraching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Soruces:\n// - Quilez:\n// https://iquilezles.org/articles/distfunctions\n// https://iquilezles.org/articles/rmshadows\n// - Other\n// Sample raymarching code: https://www.shadertoy.com/view/XsB3Rm\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\nfloat map(vec3 p)\n{\n    return p.y - sin(p.x);\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    for( float t=mint; t < maxt; )\n    {\n        float h = map(ro + rd*t);\n        if( h<EPSILON )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\nvec3 getRay(vec2 fragCoord, vec2 res, float fieldOfView)\n{\n    // Place (0,0) in center\n    vec2 xy = fragCoord - res/2.0;\n    float z = res.y / tan(radians(fieldOfView)/2.0);\n    \n    return normalize(vec3(xy, -z));\n}\n\nfloat shortestDist(vec3 eye, vec3 direction, float near, float far)\n{\n    float depth = near;\n    \n    for (int i = 0; i < MAX_MARCHING_STEPS; i++)\n    {\n        float distance = map(eye + depth*direction);\n        \n        if(abs(distance) < EPSILON)\n        {\n            return depth;\n        }\n        \n        depth += distance;\n        \n        if(depth >= far)\n        {\n            return far;\n        }\n    }\n    \n    return far;\n}\n\n\nvec3 render(vec3 p, vec3 normal, vec3 eye)\n{\n    vec3 lightDir = normalize(vec3(-1, -0.5, 0.3));\n    float shadow = softshadow(p, -lightDir, EPSILON+0.01, MAX_DIST, 50.0);\n    return vec3(1.0, 1.0, 1.0) * shadow;\n}\n\nvec3 getNormal(vec3 p)\n{ \n    vec3 normalSDF = vec3(\n    \tmap(vec3(p.x + EPSILON, p.y, p.z)) - map(vec3(p.x - EPSILON, p.y, p.z)),\n    \tmap(vec3(p.x, p.y + EPSILON, p.z)) - map(vec3(p.x, p.y - EPSILON, p.z)),\n    \tmap(vec3(p.x, p.y, p.z + EPSILON)) - map(vec3(p.x, p.y, p.z - EPSILON)));\n    \n    return normalize(normalSDF);\n}\n\n// camera rotation : pitch, yaw\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec3 dir = getRay(fragCoord.xy, iResolution.xy, 45.0);\n\tvec3 eye = vec3(0.0, 3.0, 17.0);\n    \n    // Rotate camera\n\tmat3 rot = rotationXY( ( iMouse.xy - iResolution.xy * 0.5 ).yx * vec2( 0.01, -0.01 ) );\n\tdir = rot * dir;\n\teye = rot * eye;\n    \n    float distance = shortestDist(eye, dir, MIN_DIST, MAX_DIST);\n    \n    if(distance > MAX_DIST-EPSILON)\n    {\n        float gradient = fragCoord.y/iResolution.y;\n        vec3 color = (1.0-gradient) * vec3(1.0, 0.5, 0.6) + gradient * vec3(1.0, 0.9, 1.0);\n        fragColor = vec4(color,1.0);\n        return;\n    }\n\t\n    vec3 pos = eye+dir.xyz*distance;\n    vec3 normal = getNormal(pos);\n    \n    fragColor = vec4(render(pos, normal, eye), 1.0);\n}","name":"Image","description":"","type":"image"}]}