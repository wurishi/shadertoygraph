{"ver":"0.1","info":{"id":"DscXRr","date":"1679278811","viewed":105,"name":"Roboto extracted using freetype","username":"ianertson","description":"Used freetype2 and a C program to generate this integer array from the Roboto ttf font.\nCan't get a better resolution than this, I've tried but the shader won't compile when that integer array is too large.\nHave to figure out some way to pack it smaller.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["text","font","roboto"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R (iResolution.xy)\n#define T (iTime)\n\n#define CHAR_WIDTH 9\n#define CHAR_HEIGHT 8\n#define NUM_CHARS 26\n#define FONT_LEN (CHAR_WIDTH * CHAR_HEIGHT * NUM_CHARS)\n\n// extracted using http://freetype.org/\n\n// Pasted the C-code into the \"Common\" tab,\n// in case you want to know how I did it.\nint[FONT_LEN] font = int[FONT_LEN](\n    // A\n    0, 0, 1, 1, 0, 0, 0, 0, 0, \n    0, 0, 1, 1, 0, 0, 0, 0, 0, \n    0, 1, 1, 1, 0, 0, 0, 0, 0, \n    0, 1, 0, 1, 1, 0, 0, 0, 0, \n    0, 1, 1, 1, 1, 0, 0, 0, 0, \n    1, 1, 0, 0, 1, 0, 0, 0, 0, \n    1, 0, 0, 0, 1, 1, 0, 0, 0, \n    0, 0, 0, 0, 0, 0, 0, 0, 0, \n    // B\n    1, 1, 1, 1, 0, 0, 0, 0, 0, \n    1, 0, 0, 1, 0, 0, 0, 0, 0, \n    1, 0, 0, 1, 0, 0, 0, 0, 0, \n    1, 1, 1, 1, 0, 0, 0, 0, 0, \n    1, 0, 0, 1, 0, 0, 0, 0, 0, \n    1, 0, 0, 1, 0, 0, 0, 0, 0, \n    1, 1, 1, 1, 0, 0, 0, 0, 0, \n    0, 0, 0, 0, 0, 0, 0, 0, 0, \n    // C\n    0, 1, 1, 1, 0, 0, 0, 0, 0, \n    1, 1, 0, 1, 1, 0, 0, 0, 0, \n    1, 0, 0, 0, 1, 0, 0, 0, 0, \n    1, 0, 0, 0, 0, 0, 0, 0, 0, \n    1, 0, 0, 0, 1, 0, 0, 0, 0, \n    1, 1, 0, 1, 1, 0, 0, 0, 0, \n    0, 1, 1, 1, 0, 0, 0, 0, 0, \n    0, 0, 0, 0, 0, 0, 0, 0, 0, \n    // D\n    1, 1, 1, 1, 0, 0, 0, 0, 0, \n    1, 0, 0, 1, 1, 0, 0, 0, 0, \n    1, 0, 0, 0, 1, 0, 0, 0, 0, \n    1, 0, 0, 0, 1, 0, 0, 0, 0, \n    1, 0, 0, 0, 1, 0, 0, 0, 0, \n    1, 0, 0, 1, 1, 0, 0, 0, 0, \n    1, 1, 1, 1, 0, 0, 0, 0, 0, \n    0, 0, 0, 0, 0, 0, 0, 0, 0, \n    // E\n    1, 1, 1, 1, 0, 0, 0, 0, 0, \n    1, 0, 0, 0, 0, 0, 0, 0, 0, \n    1, 0, 0, 0, 0, 0, 0, 0, 0, \n    1, 1, 1, 1, 0, 0, 0, 0, 0, \n    1, 0, 0, 0, 0, 0, 0, 0, 0, \n    1, 0, 0, 0, 0, 0, 0, 0, 0, \n    1, 1, 1, 1, 0, 0, 0, 0, 0, \n    0, 0, 0, 0, 0, 0, 0, 0, 0, \n    // F\n    1, 1, 1, 1, 0, 0, 0, 0, 0, \n    1, 0, 0, 0, 0, 0, 0, 0, 0, \n    1, 0, 0, 0, 0, 0, 0, 0, 0, \n    1, 1, 1, 1, 0, 0, 0, 0, 0, \n    1, 0, 0, 0, 0, 0, 0, 0, 0, \n    1, 0, 0, 0, 0, 0, 0, 0, 0, \n    1, 0, 0, 0, 0, 0, 0, 0, 0, \n    0, 0, 0, 0, 0, 0, 0, 0, 0, \n    // G\n    0, 1, 1, 1, 1, 0, 0, 0, 0, \n    1, 1, 0, 0, 1, 0, 0, 0, 0, \n    1, 0, 0, 0, 0, 0, 0, 0, 0, \n    1, 0, 1, 1, 1, 0, 0, 0, 0, \n    1, 0, 0, 0, 1, 0, 0, 0, 0, \n    1, 1, 0, 0, 1, 0, 0, 0, 0, \n    0, 1, 1, 1, 1, 0, 0, 0, 0, \n    0, 0, 0, 0, 0, 0, 0, 0, 0, \n    // H\n    1, 0, 0, 0, 1, 0, 0, 0, 0, \n    1, 0, 0, 0, 1, 0, 0, 0, 0, \n    1, 0, 0, 0, 1, 0, 0, 0, 0, \n    1, 1, 1, 1, 1, 0, 0, 0, 0, \n    1, 0, 0, 0, 1, 0, 0, 0, 0, \n    1, 0, 0, 0, 1, 0, 0, 0, 0, \n    1, 0, 0, 0, 1, 0, 0, 0, 0, \n    0, 0, 0, 0, 0, 0, 0, 0, 0, \n    // I\n    1, 0, 0, 0, 0, 0, 0, 0, 0, \n    1, 0, 0, 0, 0, 0, 0, 0, 0, \n    1, 0, 0, 0, 0, 0, 0, 0, 0, \n    1, 0, 0, 0, 0, 0, 0, 0, 0, \n    1, 0, 0, 0, 0, 0, 0, 0, 0, \n    1, 0, 0, 0, 0, 0, 0, 0, 0, \n    1, 0, 0, 0, 0, 0, 0, 0, 0, \n    0, 0, 0, 0, 0, 0, 0, 0, 0, \n    // J\n    0, 0, 0, 1, 0, 0, 0, 0, 0, \n    0, 0, 0, 1, 0, 0, 0, 0, 0, \n    0, 0, 0, 1, 0, 0, 0, 0, 0, \n    0, 0, 0, 1, 0, 0, 0, 0, 0, \n    0, 0, 0, 1, 0, 0, 0, 0, 0, \n    1, 0, 0, 1, 0, 0, 0, 0, 0, \n    1, 1, 1, 1, 0, 0, 0, 0, 0, \n    0, 0, 0, 0, 0, 0, 0, 0, 0, \n    // K\n    1, 0, 0, 1, 0, 0, 0, 0, 0, \n    1, 0, 1, 1, 0, 0, 0, 0, 0, \n    1, 1, 1, 0, 0, 0, 0, 0, 0, \n    1, 1, 1, 0, 0, 0, 0, 0, 0, \n    1, 0, 1, 0, 0, 0, 0, 0, 0, \n    1, 0, 1, 1, 0, 0, 0, 0, 0, \n    1, 0, 0, 1, 1, 0, 0, 0, 0, \n    0, 0, 0, 0, 0, 0, 0, 0, 0, \n    // L\n    1, 0, 0, 0, 0, 0, 0, 0, 0, \n    1, 0, 0, 0, 0, 0, 0, 0, 0, \n    1, 0, 0, 0, 0, 0, 0, 0, 0, \n    1, 0, 0, 0, 0, 0, 0, 0, 0, \n    1, 0, 0, 0, 0, 0, 0, 0, 0, \n    1, 0, 0, 0, 0, 0, 0, 0, 0, \n    1, 1, 1, 1, 0, 0, 0, 0, 0, \n    0, 0, 0, 0, 0, 0, 0, 0, 0, \n    // M\n    1, 1, 0, 0, 1, 1, 0, 0, 0, \n    1, 1, 0, 0, 1, 1, 0, 0, 0, \n    1, 1, 0, 0, 1, 1, 0, 0, 0, \n    1, 1, 1, 1, 1, 1, 0, 0, 0, \n    1, 0, 1, 1, 0, 1, 0, 0, 0, \n    1, 0, 1, 1, 0, 1, 0, 0, 0, \n    1, 0, 1, 1, 0, 1, 0, 0, 0, \n    0, 0, 0, 0, 0, 0, 0, 0, 0, \n    // N\n    1, 1, 0, 0, 1, 0, 0, 0, 0, \n    1, 1, 0, 0, 1, 0, 0, 0, 0, \n    1, 1, 1, 0, 1, 0, 0, 0, 0, \n    1, 0, 1, 0, 1, 0, 0, 0, 0, \n    1, 0, 1, 1, 1, 0, 0, 0, 0, \n    1, 0, 0, 1, 1, 0, 0, 0, 0, \n    1, 0, 0, 1, 1, 0, 0, 0, 0, \n    0, 0, 0, 0, 0, 0, 0, 0, 0, \n    // O\n    0, 1, 1, 1, 0, 0, 0, 0, 0, \n    1, 1, 0, 1, 1, 0, 0, 0, 0, \n    1, 0, 0, 0, 1, 0, 0, 0, 0, \n    1, 0, 0, 0, 1, 0, 0, 0, 0, \n    1, 0, 0, 0, 1, 0, 0, 0, 0, \n    1, 1, 0, 1, 1, 0, 0, 0, 0, \n    0, 1, 1, 1, 0, 0, 0, 0, 0, \n    0, 0, 0, 0, 0, 0, 0, 0, 0, \n    // P\n    1, 1, 1, 1, 0, 0, 0, 0, 0, \n    1, 0, 0, 1, 1, 0, 0, 0, 0, \n    1, 0, 0, 0, 1, 0, 0, 0, 0, \n    1, 0, 0, 1, 1, 0, 0, 0, 0, \n    1, 1, 1, 1, 0, 0, 0, 0, 0, \n    1, 0, 0, 0, 0, 0, 0, 0, 0, \n    1, 0, 0, 0, 0, 0, 0, 0, 0, \n    0, 0, 0, 0, 0, 0, 0, 0, 0, \n    // Q\n    0, 1, 1, 1, 0, 0, 0, 0, 0, \n    1, 1, 0, 1, 1, 0, 0, 0, 0, \n    1, 0, 0, 0, 1, 0, 0, 0, 0, \n    1, 0, 0, 0, 1, 0, 0, 0, 0, \n    1, 0, 0, 0, 1, 0, 0, 0, 0, \n    1, 1, 0, 1, 1, 0, 0, 0, 0, \n    0, 1, 1, 1, 0, 0, 0, 0, 0, \n    0, 0, 0, 1, 1, 0, 0, 0, 0, \n    // R\n    1, 1, 1, 1, 0, 0, 0, 0, 0, \n    1, 0, 0, 1, 0, 0, 0, 0, 0, \n    1, 0, 0, 1, 0, 0, 0, 0, 0, \n    1, 1, 1, 1, 0, 0, 0, 0, 0, \n    1, 0, 1, 0, 0, 0, 0, 0, 0, \n    1, 0, 1, 1, 0, 0, 0, 0, 0, \n    1, 0, 0, 1, 0, 0, 0, 0, 0, \n    0, 0, 0, 0, 0, 0, 0, 0, 0, \n    // S\n    1, 1, 1, 1, 0, 0, 0, 0, 0, \n    1, 0, 0, 1, 0, 0, 0, 0, 0, \n    1, 1, 0, 0, 0, 0, 0, 0, 0, \n    0, 1, 1, 0, 0, 0, 0, 0, 0, \n    0, 0, 1, 1, 0, 0, 0, 0, 0, \n    1, 0, 0, 1, 0, 0, 0, 0, 0, \n    1, 1, 1, 1, 0, 0, 0, 0, 0, \n    0, 0, 0, 0, 0, 0, 0, 0, 0, \n    // T\n    1, 1, 1, 1, 1, 0, 0, 0, 0, \n    0, 0, 1, 0, 0, 0, 0, 0, 0, \n    0, 0, 1, 0, 0, 0, 0, 0, 0, \n    0, 0, 1, 0, 0, 0, 0, 0, 0, \n    0, 0, 1, 0, 0, 0, 0, 0, 0, \n    0, 0, 1, 0, 0, 0, 0, 0, 0, \n    0, 0, 1, 0, 0, 0, 0, 0, 0, \n    0, 0, 0, 0, 0, 0, 0, 0, 0, \n    // U\n    1, 0, 0, 0, 1, 0, 0, 0, 0, \n    1, 0, 0, 0, 1, 0, 0, 0, 0, \n    1, 0, 0, 0, 1, 0, 0, 0, 0, \n    1, 0, 0, 0, 1, 0, 0, 0, 0, \n    1, 0, 0, 0, 1, 0, 0, 0, 0, \n    1, 0, 0, 0, 1, 0, 0, 0, 0, \n    1, 1, 1, 1, 0, 0, 0, 0, 0, \n    0, 0, 0, 0, 0, 0, 0, 0, 0, \n    // V\n    1, 0, 0, 0, 1, 0, 0, 0, 0, \n    1, 1, 0, 0, 1, 0, 0, 0, 0, \n    0, 1, 0, 1, 1, 0, 0, 0, 0, \n    0, 1, 0, 1, 0, 0, 0, 0, 0, \n    0, 1, 1, 1, 0, 0, 0, 0, 0, \n    0, 1, 1, 1, 0, 0, 0, 0, 0, \n    0, 0, 1, 1, 0, 0, 0, 0, 0, \n    0, 0, 0, 0, 0, 0, 0, 0, 0, \n    // W\n    1, 0, 0, 1, 1, 0, 1, 0, 0, \n    1, 1, 0, 1, 1, 0, 1, 0, 0, \n    1, 1, 1, 1, 1, 0, 1, 0, 0, \n    0, 1, 1, 1, 1, 1, 1, 0, 0, \n    0, 1, 1, 0, 1, 1, 1, 0, 0, \n    0, 1, 1, 0, 1, 1, 0, 0, 0, \n    0, 1, 1, 0, 0, 1, 0, 0, 0, \n    0, 0, 0, 0, 0, 0, 0, 0, 0, \n    // X\n    1, 1, 0, 1, 1, 0, 0, 0, 0, \n    0, 1, 0, 1, 1, 0, 0, 0, 0, \n    0, 1, 1, 1, 0, 0, 0, 0, 0, \n    0, 0, 1, 1, 0, 0, 0, 0, 0, \n    0, 1, 1, 1, 0, 0, 0, 0, 0, \n    0, 1, 0, 1, 1, 0, 0, 0, 0, \n    1, 1, 0, 1, 1, 0, 0, 0, 0, \n    0, 0, 0, 0, 0, 0, 0, 0, 0, \n    // Y\n    1, 1, 0, 1, 1, 0, 0, 0, 0, \n    1, 1, 0, 1, 1, 0, 0, 0, 0, \n    0, 1, 1, 1, 0, 0, 0, 0, 0, \n    0, 1, 1, 1, 0, 0, 0, 0, 0, \n    0, 0, 1, 0, 0, 0, 0, 0, 0, \n    0, 0, 1, 0, 0, 0, 0, 0, 0, \n    0, 0, 1, 0, 0, 0, 0, 0, 0, \n    0, 0, 0, 0, 0, 0, 0, 0, 0, \n    // Z\n    1, 1, 1, 1, 0, 0, 0, 0, 0, \n    0, 0, 1, 1, 0, 0, 0, 0, 0, \n    0, 0, 1, 0, 0, 0, 0, 0, 0, \n    0, 1, 1, 0, 0, 0, 0, 0, 0, \n    0, 1, 0, 0, 0, 0, 0, 0, 0, \n    1, 1, 0, 0, 0, 0, 0, 0, 0, \n    1, 1, 1, 1, 0, 0, 0, 0, 0, \n    0, 0, 0, 0, 0, 0, 0, 0, 0 \n);\n\nint uvidx(in vec2 uv, int c) {\n    uv.y = (float(CHAR_HEIGHT)-uv.y)-0.001;\n    return int((int(uv.y)+(c*CHAR_HEIGHT)) * CHAR_WIDTH + int(uv.x)) % FONT_LEN;\n}\n\nfloat letter(in vec2 uv, in int c) {\n    return float(font[uvidx(uv*vec2(CHAR_WIDTH, CHAR_HEIGHT),c)]);\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = fc/R.y;\n    \n    if (fc.x > R.x/4.3 && fc.y > R.y/2.5) {\n        uv.x -= (R.x/4.3)/R.y;\n        uv.y -= (R.y/2.5)/R.y;\n        vec2 id = floor(uv*6.);\n        vec2 lv = fract(uv*6.);\n\n        int ii = int(id.x);\n        int c = 0;\n\n        switch (ii) {\n            case 0: c = 17; break; // R\n            case 1: c = 14; break; // O\n            case 2: c = 1;  break; // B\n            case 3: c = 14; break; // O\n            case 4: c = 19; break; // T\n            case 5: c = 14; break; // O\n        }\n\n        col += letter(lv, c) * float(id.x < 6.0 && id.y <= 0.);\n    }\n    O = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*#include <freetype/freetype.h>\n#include <freetype2/freetype/freetype.h>\n#include <freetype2/freetype/ftimage.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define FONT_PATH \"/usr/share/fonts/truetype/roboto/unhinted/RobotoTTF/Roboto-Regular.ttf\"\n#define FONT_SIZE 2\n#define FONT_THRESHOLD 0.15f\n\n#ifndef MIN\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n#endif\n\n#ifndef MAX\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n#endif\n\n#define TRUE_TYPE_BITS FT_LOAD_RENDER | FT_LOAD_CROP_BITMAP\n\nint main(int argc, char *argv[]) {\n  FT_Library ft;\n  FT_Face face;\n  int error = FT_Init_FreeType(&ft);\n\n  if (error) {\n    fprintf(stderr, \"Error loading freetype library.\\n\");\n    return 1;\n  }\n\n  error = FT_New_Face(ft, FONT_PATH, 0, &face);\n  if (error) {\n    fprintf(stderr, \"Error reading font `%s`\\n\", FONT_PATH);\n    return 1;\n  }\n\n  FT_Set_Char_Size(face,           \n                   0,              \n                   64 * FONT_SIZE, \n                   300,            \n                   300);           \n\n  if (error) {\n    fprintf(stderr, \"Error setting pixel sizes.\\n\");\n    return 1;\n  }\n\n  int maxw = -1;\n  int maxh = -1;\n\n  // first loop just to compute the max width and max height\n  for (int i = 65; i < 90; i++) {\n    int character = i;\n    int glyph_index = 0;\n    if (!(glyph_index = FT_Get_Char_Index(face, character))) {\n      fprintf(stderr, \"Could not get char index.\\n\");\n      continue;\n    }\n\n    if (FT_Load_Glyph(face, glyph_index, TRUE_TYPE_BITS)) {\n      fprintf(stderr, \"Unable to load glyph `%d`\\n\", i);\n      continue;\n    }\n\n    FT_GlyphSlot g = face->glyph;\n\n    int w = g->bitmap.width; // + (long double)g->advance.x / (long double)64;\n    int h = g->bitmap.rows;  // + (g->bitmap_top);\n\n    maxw = w > maxw ? w : maxw;\n    maxh = h > maxh ? h : maxh;\n  }\n\n  int cols = maxw;\n  int rows = maxh;\n\n  printf(\"#define CHAR_WIDTH %d\\n\", rows);\n  printf(\"#define CHAR_HEIGHT %d\\n\", cols);\n  printf(\"#define NUM_CHARS %d\\n\", 26);\n  printf(\"#define FONT_LEN (CHAR_WIDTH * CHAR_HEIGHT * NUM_CHARS)\\n\");\n\n  printf(\"int[FONT_LEN] font = int[FONT_LEN](\\n\");\n\n  int count = 0;\n  for (int i = 65; i < 91; i++) {\n    int character = i;\n    int glyph_index = 0;\n    if (!(glyph_index = FT_Get_Char_Index(face, character))) {\n      fprintf(stderr, \"Could not get char index.\\n\");\n      continue;\n    }\n\n    if (FT_Load_Glyph(face, glyph_index, TRUE_TYPE_BITS)) {\n      fprintf(stderr, \"Unable to load glyph `%d`\\n\", i);\n      continue;\n    }\n\n    FT_GlyphSlot g = face->glyph;\n\n    printf(\"// %c\\n\", (char)i);\n    int w = g->bitmap.width;\n    int h = g->bitmap.rows;\n\n    for (int x = 0; x < cols; x++) {\n      for (int y = 0; y < rows; y++) {\n        int idx = (MIN(x, h - 1) * w + MIN(y, w - 1));\n        unsigned char *data = (unsigned char *)g->bitmap.buffer;\n        unsigned char px = (x >= h || y >= w) ? 0 : data[idx];\n\n        float s = (float)px;\n        s /= 255.0f;\n\n        // couldn't turn off anti-aliasing, so here's\n        // an ugly hack\n        if ((count + 1) < (cols * rows * 26)) {\n          printf(\"%d, \", (int)(s > FONT_THRESHOLD));\n        } else {\n          printf(\"%d \", (int)(s > FONT_THRESHOLD));\n        }\n        count++;\n      }\n      printf(\"\\n\");\n    }\n  }\n  printf(\");\\n\");\n\n  return 0;\n}\n*/","name":"Common","description":"","type":"common"}]}