{"ver":"0.1","info":{"id":"MXdGD2","date":"1718806410","viewed":81,"name":"Text util for debugging","username":"hasenpfote","description":"I prioritized runtime speed to prevent high GPU load even at high resolutions (1080p in my case).\nThe shader is designed to easily handle various built-in types. However, in the current implementation, some combinations result in longer compile times.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sdf","text","font","debug","outline"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n * Text util for debugging:\n *   - Generates outlines for visibility\n *   - Reduces operations in empty spaces\n *   - Loopless and uniform core logic\n *   - Supports scalar values(uint, int, float), and when needed vector values\n *     with ease\n */\n\n/*\n * TEST_MODE:\n *   0: char\n *   1: scalar value\n *   2: string\n *   3: absolute pos\n *   4: scale, color\n *   5: vector value\n *   6: string with value\n *   7: empty space\n *   8: shader input\n */\n#define TEST_MODE 8\n\n/*\n * BACKGROUND_MODE:\n *   0: solid color\n *   1: gradient\n *   2: texture\n */\n#define BACKGROUND_MODE 1\n\n#if (TEST_MODE == 2)\n\nDEF_STRING32(STRING_LOWERCASE_LETTERS, _STRING_LOWERCASE_LETTERS, int[](_a,_b,_c,_d,_e,_f,_g,_h,_i,_j,_k,_l,_m,_n,_o,_p,_q,_r,_s,_t,_u,_v,_w,_x,_y,_z))\nDEF_STRING32(STRING_UPPERCASE_LETTERS, _STRING_UPPERCASE_LETTERS, int[](_A,_B,_C,_D,_E,_F,_G,_H,_I,_J,_K,_L,_M,_N,_O,_P,_Q,_R,_S,_T,_U,_V,_W,_X,_Y,_Z))\nDEF_STRING16(STRING_DIGITS, _STRING_DIGITS, int[](_0,_1,_2,_3,_4,_5,_6,_7,_8,_9))\nDEF_STRING32(STRING_SYMBOLS, _STRING_SYMBOLS, int[](_SOL,_BSOL,_NUM,_COMMAT,_DOLLAR,_PERCNT,_AMP,_LOWBAR,_AST,_PLUS,_HYPHEN,_EQUALS,_LT,_GT,_LPAR,_RPAR,_LSQB,_RSQB,_LCUB,_RCUB,_VERBAR,_EXCL,_QUEST,_PERIOD,_COMMA,_COLON,_SEMI,_TILDE,_QUOT,_GRAVE,_APOS,_HAT))\n\n#elif (TEST_MODE == 4)\n\nDEF_STRING64(STRING_PANGRAM, _STRING_PANGRAM, int[](_T,_h,_e,_SP,_q,_u,_i,_c,_k,_SP,_b,_r,_o,_w,_n,_SP,_f,_o,_x,_SP,_j,_u,_m,_p,_s,_SP,_o,_v,_e,_r,_SP,_t,_h,_e,_SP,_l,_a,_z,_y,_SP,_d,_o,_g))\n\n#elif (TEST_MODE == 6)\n\nDEF_STRING32_WITH_VALUE_AT_START(STRING_BEFORE_VALUE, _STRING_BEFORE_VALUE, 1, int[](_SP,_a,_t,_SP,_t,_h,_e,_SP,_s,_t,_a,_r,_t,_SP,_w,_i,_t,_h,_SP,_a,_SP,_v,_a,_l,_u,_e))\nDEF_STRING32_WITH_VALUE_AT_END(STRING_AFTER_VALUE, _STRING_AFTER_VALUE, 1, int[](_A,_t,_SP,_t,_h,_e,_SP,_e,_n,_d,_COMMA,_SP,_v,_a,_l,_u,_e,_SP))\nDEF_STRING32_WITH_VALUE(STRING_AROUND_VALUE, _STRING_AROUND_VALUE, 6, 1, int[](_V,_a,_l,_u,_e,_SP,_SP,_i,_s,_SP,_i,_n,_SP,_t,_h,_e,_SP,_m,_i,_d,_d,_l,_e))\n\n#elif (TEST_MODE == 3 || TEST_MODE == 7)\n\nDEF_STRING16(STRING_01, _STRING_01, int[](_H,_e,_l,_l,_o,_COMMA,_SP,_w,_o,_r,_l,_d,_EXCL))\nDEF_STRING16(STRING_02, _STRING_02, int[](_S, _h, _a, _d, _e, _r, _t, _o, _y))\n\n#elif (TEST_MODE == 8)\n\nDEF_STRING16(STRING_I_01, _STRING_I_01, int[](_i, _R, _e, _s, _o, _l, _u, _t, _i, _o, _n, _COLON, _SP))\nDEF_STRING16(STRING_I_02, _STRING_I_02, int[](_i, _T, _i, _m, _e, _COLON, _SP))\nDEF_STRING16(STRING_I_03, _STRING_I_03, int[](_i, _T, _i, _m, _e, _D, _e, _l, _t, _a, _COLON, _SP))\nDEF_STRING16(STRING_I_04, _STRING_I_04, int[](_i, _F, _r, _a, _m, _e, _R, _a, _t, _e, _COLON, _SP))\nDEF_STRING16(STRING_I_05, _STRING_I_05, int[](_i, _F, _r, _a, _m, _e, _COLON, _SP))\nDEF_STRING16(STRING_I_06, _STRING_I_06, int[](_i, _C, _h, _a, _n, _n, _e, _l, _T, _i, _m, _e))\nDEF_STRING32(STRING_I_07, _STRING_I_07, int[](_i, _C, _h, _a, _n, _n, _e, _l, _R, _e, _s, _o, _l, _u, _t, _i, _o, _n))\nDEF_STRING16(STRING_I_08, _STRING_I_08, int[](_i, _M, _o, _u, _s, _e, _COLON, _SP))\nDEF_STRING16(STRING_I_09, _STRING_I_09, int[](_i, _D, _a, _t, _e, _COLON, _SP))\nDEF_STRING16(STRING_I_10, _STRING_I_10, int[](_i, _S, _a, _m, _p, _l, _e, _R, _a, _t, _e, _COLON, _SP))\nDEF_STRING8_WITH_VALUE(STRING_I_11, _STRING_I_11, 1, 1, int[](_SP, _COLON, _SP))\n\n#endif\n\n#if (TEST_MODE == 5 || TEST_MODE == 7 || TEST_MODE == 8)\n// extensions\n\nDEF_TEXT_VEC2_VALUE(vec2)\n\nvoid text_value(in sampler2D sampler, inout TextState ts, in vec2 x, in int min_digits){\n    text_vec_value(sampler, ts, x, min_digits, _COMMA);\n}\n\nDEF_TEXT_VEC3_VALUE(vec3)\n\nvoid text_value(in sampler2D sampler, inout TextState ts, in vec3 x, in int min_digits){\n    text_vec_value(sampler, ts, x, min_digits, _COMMA);\n}\n\nDEF_TEXT_VEC4_VALUE(vec4)\n\nvoid text_value(in sampler2D sampler, inout TextState ts, in vec4 x, in int min_digits){\n    text_vec_value(sampler, ts, x, min_digits, _COMMA);\n}\n\nDEF_TEXT_STRING_WITH_VALUE(3, vec2)\nDEF_TEXT_STRING_WITH_VALUE(5, vec2)\nDEF_TEXT_STRING_WITH_VALUE(9, vec2)\nDEF_TEXT_STRING_WITH_VALUE(17, vec2)\n\nDEF_TEXT_STRING_WITH_VALUE(3, vec3)\nDEF_TEXT_STRING_WITH_VALUE(5, vec3)\nDEF_TEXT_STRING_WITH_VALUE(9, vec3)\nDEF_TEXT_STRING_WITH_VALUE(17, vec3)\n\nDEF_TEXT_STRING_WITH_VALUE(3, vec4)\nDEF_TEXT_STRING_WITH_VALUE(5, vec4)\nDEF_TEXT_STRING_WITH_VALUE(9, vec4)\nDEF_TEXT_STRING_WITH_VALUE(17, vec4)\n\n#endif // (TEST_MODE == 5 || TEST_MODE == 7 || TEST_MODE == 8)\n\n#if 0\nbool text_contains_pos(inout vec2 p, in vec2 hori_offset, in vec2 vert_offset, in float scale, in int num_chars){\n    vec2 size = vec2(float(num_chars) * abs(hori_offset.x + hori_offset.y), vert_offset.x + vert_offset.y) * scale;\n\n    if(p.x < 0. || p.x > size.x || p.y > 1. || p.y < 1. - size.y){\n        text_advance_pos(p, hori_offset, scale, num_chars);\n        return false;\n    }\n    return true;\n}\n#endif\n\nvoid text(in vec2 pos, inout vec3 color){\n#define FONT_SAMPLER iChannel0\n\n    vec2 uv = pos / iResolution.y;\n    TextState ts;\n\n    text_init(ts, iResolution.y);\n\n#if (TEST_MODE == 0)\n    /* char */\n    text_set_pos(ts, uv, vec2(0., 1.));\n\n    text_begin(ts, 1.);\n\n    text_char(FONT_SAMPLER, ts, _H);\n    text_char(FONT_SAMPLER, ts, _e);\n    text_char(FONT_SAMPLER, ts, _l);\n    text_char(FONT_SAMPLER, ts, _l);\n    text_char(FONT_SAMPLER, ts, _o);\n    text_char(FONT_SAMPLER, ts, _COMMA);\n    text_char(FONT_SAMPLER, ts, _SP);\n    text_char(FONT_SAMPLER, ts, _w);\n    text_char(FONT_SAMPLER, ts, _o);\n    text_char(FONT_SAMPLER, ts, _r);\n    text_char(FONT_SAMPLER, ts, _l);\n    text_char(FONT_SAMPLER, ts, _d);\n    text_char(FONT_SAMPLER, ts, _EXCL); text_newline(ts);\n\n    text_end(ts, color);\n\n#elif (TEST_MODE == 1)\n    /* scalar value */\n    text_begin(ts, 1.);\n\n    text_set_pos(ts, uv, vec2(0., 1.));\n    text_value(FONT_SAMPLER, ts,    1u, 1); text_newline(ts);\n    text_value(FONT_SAMPLER, ts,   12u, 2); text_newline(ts);\n    text_value(FONT_SAMPLER, ts,  123u, 3); text_newline(ts);\n    text_value(FONT_SAMPLER, ts, 1234u, 4); text_newline(ts);\n    text_value(FONT_SAMPLER, ts,    1u, 4); text_newline(ts);\n    text_value(FONT_SAMPLER, ts,   12u, 4); text_newline(ts);\n    text_value(FONT_SAMPLER, ts,  123u, 4); text_newline(ts);\n    text_value(FONT_SAMPLER, ts,   12u, 1);\n    text_value(FONT_SAMPLER, ts,   34u, 1); text_newline(ts);\n\n    text_set_pos(ts, uv, vec2(0.2, 1.));\n    text_value(FONT_SAMPLER, ts,    1, 1); text_newline(ts);\n    text_value(FONT_SAMPLER, ts,   12, 2); text_newline(ts);\n    text_value(FONT_SAMPLER, ts,  123, 3); text_newline(ts);\n    text_value(FONT_SAMPLER, ts, 1234, 4); text_newline(ts);\n    text_value(FONT_SAMPLER, ts,    1, 4); text_newline(ts);\n    text_value(FONT_SAMPLER, ts,   12, 4); text_newline(ts);\n    text_value(FONT_SAMPLER, ts,  123, 4); text_newline(ts);\n    text_value(FONT_SAMPLER, ts,   12, 1);\n    text_value(FONT_SAMPLER, ts,   34, 1); text_newline(ts);\n\n    text_set_pos(ts, uv, vec2(0.4, 1.));\n    text_value(FONT_SAMPLER, ts,    -1, 1); text_newline(ts);\n    text_value(FONT_SAMPLER, ts,   -12, 2); text_newline(ts);\n    text_value(FONT_SAMPLER, ts,  -123, 3); text_newline(ts);\n    text_value(FONT_SAMPLER, ts, -1234, 4); text_newline(ts);\n    text_value(FONT_SAMPLER, ts,    -1, 4); text_newline(ts);\n    text_value(FONT_SAMPLER, ts,   -12, 4); text_newline(ts);\n    text_value(FONT_SAMPLER, ts,  -123, 4); text_newline(ts);\n    text_value(FONT_SAMPLER, ts,   -12, 1);\n    text_value(FONT_SAMPLER, ts,   -34, 1); text_newline(ts);\n\n    text_set_pos(ts, uv, vec2(0.65, 1.));\n    text_value(FONT_SAMPLER, ts,    1.2,    1); text_newline(ts);\n    text_value(FONT_SAMPLER, ts,   12.34,   2); text_newline(ts);\n    text_value(FONT_SAMPLER, ts,  123.456,  3); text_newline(ts);\n    text_value(FONT_SAMPLER, ts, 1234.5678, 4); text_newline(ts);\n    text_value(FONT_SAMPLER, ts,    1.2,    4); text_newline(ts);\n    text_value(FONT_SAMPLER, ts,   12.34,   4); text_newline(ts);\n    text_value(FONT_SAMPLER, ts,  123.456,  4); text_newline(ts);\n    text_value(FONT_SAMPLER, ts,    1.2,    1);\n    text_value(FONT_SAMPLER, ts,    3.4,    1); text_newline(ts);\n\n    text_set_pos(ts, uv, vec2(1.0, 1.));\n    text_value(FONT_SAMPLER, ts,    -1.2,    1); text_newline(ts);\n    text_value(FONT_SAMPLER, ts,   -12.34,   2); text_newline(ts);\n    text_value(FONT_SAMPLER, ts,  -123.456,  3); text_newline(ts);\n    text_value(FONT_SAMPLER, ts, -1234.5678, 4); text_newline(ts);\n    text_value(FONT_SAMPLER, ts,    -1.2,    4); text_newline(ts);\n    text_value(FONT_SAMPLER, ts,   -12.34,   4); text_newline(ts);\n    text_value(FONT_SAMPLER, ts,  -123.456,  4); text_newline(ts);\n    text_value(FONT_SAMPLER, ts,    -1.2,    1);\n    text_value(FONT_SAMPLER, ts,    -3.4,    1); text_newline(ts);\n\n    text_end(ts, color);\n\n#elif (TEST_MODE == 2)\n    /* string */\n    text_set_pos(ts, uv, vec2(0.3, 0.65));\n\n    text_begin(ts, 1.);\n\n    text_string(FONT_SAMPLER, ts, STRING_LOWERCASE_LETTERS); text_char(FONT_SAMPLER, ts, _SP);\n    text_substring(FONT_SAMPLER, ts, STRING_DIGITS, 0, 5); text_newline(ts);\n\n    text_string(FONT_SAMPLER, ts, STRING_UPPERCASE_LETTERS); text_char(FONT_SAMPLER, ts, _SP);\n    text_substring(FONT_SAMPLER, ts, STRING_DIGITS, 5, 5); text_newline(ts);\n\n    text_string(FONT_SAMPLER, ts, STRING_SYMBOLS); text_newline(ts);\n\n    text_end(ts, color);\n\n#elif (TEST_MODE == 3)\n    /* absolute pos */\n    vec2 p = vec2(450., 250.)  / iResolution.y;\n\n    text_set_pos(ts, uv, vec2(p.x, 1. - p.y));\n\n    text_begin(ts, 1.);\n\n    text_substring(FONT_SAMPLER, ts, STRING_01, 0, 7);\n    text_char(FONT_SAMPLER, ts, _s);\n    text_substring(FONT_SAMPLER, ts, STRING_02, 1, 5);\n    text_char(FONT_SAMPLER, ts, _SP);\n    text_substring(FONT_SAMPLER, ts, STRING_01, 7, 6);\n\n    text_end(ts, color);\n\n#elif (TEST_MODE == 4)\n    /* scale, color */\n    const float TEXT_SCALES[5] = float[](0.5, 1., 1.5, 2., 2.5);\n    const vec3 TEXT_COLORS[5] = vec3[](vec3(0),vec3(1),vec3(1,0,0),vec3(0,1,0),vec3(0,0,1));\n    const vec3 OUTLINE_COLORS[5] = vec3[](vec3(1),vec3(0),vec3(0,1,1),vec3(1,0,1),vec3(1,1,0));\n\n    text_set_pos(ts, uv, vec2(0., 1.));\n\n    for(int i = 0; i < TEXT_SCALES.length(); i++){\n        text_begin(ts, TEXT_SCALES[i]);\n        text_string(FONT_SAMPLER, ts, STRING_PANGRAM); text_newline(ts);\n        text_end(ts, TEXT_COLORS[i], OUTLINE_COLORS[i], color);\n    }\n\n#elif (TEST_MODE == 5)\n    /*  vector value */\n    const vec2 v2 = vec2(1, 2);\n    const vec3 v3 = vec3(1, 2, 3);\n    const vec4 v4 = vec4(1, 2, 3, 4);\n\n    text_set_pos(ts, uv, vec2(0., 1.));\n\n    text_begin(ts, 1.);\n\n    text_value(FONT_SAMPLER, ts,  v2, 1); text_newline(ts);\n    text_value(FONT_SAMPLER, ts, -v2, 1); text_newline(ts);\n    text_value(FONT_SAMPLER, ts,  v2, 1);\n    text_value(FONT_SAMPLER, ts, -v2, 1); text_newline(ts);\n    text_newline(ts);\n\n    text_value(FONT_SAMPLER, ts,  v3, 1); text_newline(ts);\n    text_value(FONT_SAMPLER, ts, -v3, 1); text_newline(ts);\n    text_value(FONT_SAMPLER, ts,  v3, 1);\n    text_value(FONT_SAMPLER, ts, -v3, 1); text_newline(ts);\n    text_newline(ts);\n\n    text_value(FONT_SAMPLER, ts,  v4, 1); text_newline(ts);\n    text_value(FONT_SAMPLER, ts, -v4, 1); text_newline(ts);\n    text_value(FONT_SAMPLER, ts,  v4, 1);\n    text_value(FONT_SAMPLER, ts, -v4, 1); text_newline(ts);\n    text_newline(ts);\n\n    text_end(ts, color);\n\n#elif (TEST_MODE == 6)\n    /* string with value */\n    text_set_pos(ts, uv, vec2(0., 1.));\n\n    text_begin(ts, 1.);\n\n    text_string(FONT_SAMPLER, ts, STRING_BEFORE_VALUE, 1); text_newline(ts);\n    text_string(FONT_SAMPLER, ts, STRING_AFTER_VALUE, 2); text_newline(ts);\n    text_string(FONT_SAMPLER, ts, STRING_AROUND_VALUE, 3); text_newline(ts);\n\n    text_end(ts, color);\n\n#elif (TEST_MODE == 7)\n    /* empty space */\n    text_set_pos(ts, uv, vec2(0.1, 0.9));\n\n    text_begin(ts, 2.);\n\n    for(int i = 0; i < _STRING_01.length(); i++){\n        text_char(FONT_SAMPLER, ts, _STRING_01[i]);\n    }\n    text_newline(ts);\n\n    text_value(FONT_SAMPLER, ts, 1234u, 1);\n    text_char(FONT_SAMPLER, ts, _SP);\n    text_value(FONT_SAMPLER, ts, -1234, 1);\n    text_char(FONT_SAMPLER, ts, _SP);\n    text_value(FONT_SAMPLER, ts, 123.456, 2);\n    text_newline(ts);\n\n    text_string(FONT_SAMPLER, ts, STRING_02);\n    text_newline(ts);\n\n    text_value(FONT_SAMPLER, ts, vec2(1,2), 1); text_newline(ts);\n    text_value(FONT_SAMPLER, ts, vec3(1,2,3), 1); text_newline(ts);\n    text_value(FONT_SAMPLER, ts, vec4(1,2,3,4), 1); text_newline(ts);\n\n    text_end(ts, color);\n\n    if(ts.dist == FONT_SDF_INITIAL_DISTANCE)\n        color = vec3(0,1,0);\n\n#elif (TEST_MODE == 8)\n    /* shader input */\n#define CRLF text_newline(ts)\n#define C(c) text_char(FONT_SAMPLER, ts, c)\n#define S(s) text_string(FONT_SAMPLER, ts, s)\n#define SX(s, x) text_string(FONT_SAMPLER, ts, s, x)\n#define X(x, d) text_value(FONT_SAMPLER, ts, x, d)\n\n    text_begin(ts, 1.);\n\n    text_set_pos(ts, uv, vec2(0., 1.));\n\n    // 'iResolution: '\n    SX(STRING_I_01, iResolution); CRLF;\n\n    // 'iTime: '\n    SX(STRING_I_02, iTime); CRLF;\n\n    // 'iTimeDelta: '\n    SX(STRING_I_03, iTimeDelta); CRLF;\n\n    // 'iFrameRate: '\n    SX(STRING_I_04, iFrameRate); CRLF;\n\n    // 'iFrame: '\n    SX(STRING_I_05, iFrame); CRLF;\n\n    text_set_pos(ts, uv, vec2(0., 0.67));\n\n    // 'iChannelTime'\n    S(STRING_I_06); CRLF;\n    for(int i = 0; i < 4; i++){\n        SX(STRING_I_11, i); X(iChannelTime[i], 2); CRLF;\n    }\n\n    text_set_pos(ts, uv, vec2(0.55, 0.67));\n\n    // 'iChannelResolution'\n    S(STRING_I_07); CRLF;\n    for(int i = 0; i < 4; i++){\n        SX(STRING_I_11, i); X(iChannelResolution[i], 2); CRLF;\n    }\n\n    text_set_pos(ts, uv, vec2(0., 0.3));\n\n    // 'iMouse: '\n    SX(STRING_I_08, iMouse); CRLF;\n\n    // 'iDate: '\n    S(STRING_I_09);\n        X(int(iDate.x), 1); C(_HYPHEN); X(int(iDate.y) + 1, 2); C(_HYPHEN); X(int(iDate.z), 2); C(_SP);\n        X(int(iDate.w) / 3600, 1); C(_COLON); X(int(iDate.w) / 60 % 60, 1); C(_COLON); X(mod(iDate.w, 60.), 2); CRLF;\n\n    // 'iSampleRate: '\n    S(STRING_I_10); X(int(iSampleRate * 1e-4), 1); X(int(mod(iSampleRate, 1e4)), 1); CRLF;\n\n    text_end(ts, color);\n\n#undef X\n#undef SX\n#undef S\n#undef C\n#undef CRLF\n\n#endif\n\n#undef FONT_SAMPLER\n}\n\n#if(BACKGROUND_MODE == 1)\nvec2 quantize_uniform(in vec2 x, in float quant_level){\n    return floor(x * quant_level) / (quant_level - 1.);\n}\n#endif\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec3 color;\n#if (BACKGROUND_MODE == 0)\n    color = vec3(1.);\n#elif (BACKGROUND_MODE == 1)\n    const float levels = 10.;\n    vec2 uv = fragCoord / (iResolution.xy * vec2(0.5, 1.));\n    vec2 t = quantize_uniform(uv, 10.);\n    color = mix(mix(vec3(0), vec3(1), t.x), mix(vec3(0), vec3(1), t.y), step(0.5 * iResolution.x, fragCoord.x));\n#elif (BACKGROUND_MODE == 2)\n    color = texture(iChannel1, fragCoord / iResolution.xy).rgb;\n    color = srgb_to_linear(color);\n#endif\n\n    text(fragCoord, color);\n\n    color = linear_to_srgb(color);\n    fragColor = vec4(color, 1.);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n//==============================================================================\n\nvec3 srgb_to_linear(in vec3 color){\n    vec3 lo = vec3(color / 12.92);\n    vec3 hi = pow((color + 0.055) / 1.055, vec3(2.4));\n\n    return mix(hi, lo, lessThanEqual(color, vec3(0.04045)));\n}\n\nvec3 linear_to_srgb(in vec3 color){\n    vec3 lo = 12.92 * color;\n    vec3 hi = 1.055 * pow(color, vec3(1./2.4)) - 0.055;\n\n    return mix(hi, lo, lessThanEqual(color, vec3(0.0031308)));\n}\n\n//==============================================================================\n\n#define ENABLE_STRING\n\n// https://dev.w3.org/html5/spec-LC/named-character-references.html\n\n#define _SP     0x20 // ' '\n#define _EXCL   0x21 // '!'\n#define _QUOT   0x22 // '\"'\n#define _NUM    0x23 // '#'\n#define _DOLLAR 0x24 // '$'\n#define _PERCNT 0x25 // '%'\n#define _AMP    0x26 // '&'\n#define _APOS   0x27 // '''\n#define _LPAR   0x28 // '('\n#define _RPAR   0x29 // ')'\n#define _AST    0x2A // '*'\n#define _PLUS   0x2B // '+'\n#define _COMMA  0x2C // ','\n#define _HYPHEN 0x2D // '-'\n#define _PERIOD 0x2E // '.'\n#define _SOL    0x2F // '/'\n#define _0      0x30 // '0'\n#define _1      0x31 // '1'\n#define _2      0x32 // '2'\n#define _3      0x33 // '3'\n#define _4      0x34 // '4'\n#define _5      0x35 // '5'\n#define _6      0x36 // '6'\n#define _7      0x37 // '7'\n#define _8      0x38 // '8'\n#define _9      0x39 // '9'\n#define _COLON  0x3A // ':'\n#define _SEMI   0x3B // ';'\n#define _LT     0x3C // '<'\n#define _EQUALS 0x3D // '='\n#define _GT     0x3E // '>'\n#define _QUEST  0x3F // '?'\n#define _COMMAT 0x40 // '@'\n#define _A      0x41 // 'A'\n#define _B      0x42 // 'B'\n#define _C      0x43 // 'C'\n#define _D      0x44 // 'D'\n#define _E      0x45 // 'E'\n#define _F      0x46 // 'F'\n#define _G      0x47 // 'G'\n#define _H      0x48 // 'H'\n#define _I      0x49 // 'I'\n#define _J      0x4A // 'J'\n#define _K      0x4B // 'K'\n#define _L      0x4C // 'L'\n#define _M      0x4D // 'M'\n#define _N      0x4E // 'N'\n#define _O      0x4F // 'O'\n#define _P      0x50 // 'P'\n#define _Q      0x51 // 'Q'\n#define _R      0x52 // 'R'\n#define _S      0x53 // 'S'\n#define _T      0x54 // 'T'\n#define _U      0x55 // 'U'\n#define _V      0x56 // 'V'\n#define _W      0x57 // 'W'\n#define _X      0x58 // 'X'\n#define _Y      0x59 // 'Y'\n#define _Z      0x5A // 'Z'\n#define _LSQB   0x5B // '['\n#define _BSOL   0x5C // '\\'\n#define _RSQB   0x5D // ']'\n#define _HAT    0x5E // '^'\n#define _LOWBAR 0x5F // '_'\n#define _GRAVE  0x60 // '`'\n#define _a      0x61 // 'a'\n#define _b      0x62 // 'b'\n#define _c      0x63 // 'c'\n#define _d      0x64 // 'd'\n#define _e      0x65 // 'e'\n#define _f      0x66 // 'f'\n#define _g      0x67 // 'g'\n#define _h      0x68 // 'h'\n#define _i      0x69 // 'i'\n#define _j      0x6A // 'j'\n#define _k      0x6B // 'k'\n#define _l      0x6C // 'l'\n#define _m      0x6D // 'm'\n#define _n      0x6E // 'n'\n#define _o      0x6F // 'o'\n#define _p      0x70 // 'p'\n#define _q      0x71 // 'q'\n#define _r      0x72 // 'r'\n#define _s      0x73 // 's'\n#define _t      0x74 // 't'\n#define _u      0x75 // 'u'\n#define _v      0x76 // 'v'\n#define _w      0x77 // 'w'\n#define _x      0x78 // 'x'\n#define _y      0x79 // 'y'\n#define _z      0x7A // 'z'\n#define _LCUB   0x7B // '{'\n#define _VERBAR 0x7C // '|'\n#define _RCUB   0x7D // '}'\n#define _TILDE  0x7E // '~'\n\n/*\n * horizontal\n *\n *   | ML | LSB | Width | RSB | MR |\n *        |<<    Advance    >>|\n *\n *   Advance = LSB + Width + RSB\n *   ML = (CharSize - Width) / 2 - LSB\n *   MR = CharSize - (ML + LSB + Width + RSB)\n *\n * vertical\n *\n *   | LG/2 | MT | Height | MB | LG/2 |\n *\n *   Height = Ascent + Descent\n *   MT = CharSize - (Baseline + Ascent)\n *   MB = CharSize - (MT + Height)\n *\n */\nstruct FontMetrics{\n    // horizontal\n    float advance;\n    float margin_left;\n    float margin_right;\n    // vertical\n    float height;\n    float margin_top;\n    float margin_bottom;\n    float line_gap;\n};\n\nstruct TextState{\n    vec2 hori_offset;\n    vec2 vert_offset;\n    vec2 org;\n    vec2 pos;\n    float dist;\n    float scale;\n    float res_scale;\n};\n\nconst float FONT_TEXTURE_SIZE = 1024.;\nconst float FONT_CHAR_SIZE = 64.;\nconst float FONT_GRID_SIZE = 16.;\n\nconst FontMetrics FONT_METRICS_DEFAULT = FontMetrics(36., 14., 14., 58., 4., 2., 10.);\n\nconst float FONT_SDF_INITIAL_DISTANCE = 1e1;\n\nconst int TEXT_MAX_INT_DIGITS = 4;\nconst int[] TEXT_POW10_TABLE = int[TEXT_MAX_INT_DIGITS + 1](1, 10, 100, 1000, 10000);\nconst int TEXT_MAX_INT_PLACE = TEXT_POW10_TABLE[TEXT_MAX_INT_DIGITS - 1];\n\nconst vec3 TEXT_COLOR_DEFAULT = vec3(1.);\nconst vec3 TEXT_OUTLINE_COLOR_DEFAULT = vec3(0.);\n\nint pop(in uint x){\n    x = (x & 0x55555555u) + ((x >> 1) & 0x55555555u);\n    x = (x & 0x33333333u) + ((x >> 2) & 0x33333333u);\n    x = (x & 0x0F0F0F0Fu) + ((x >> 4) & 0x0F0F0F0Fu);\n    x = (x & 0x00FF00FFu) + ((x >> 8) & 0x00FF00FFu);\n    x = (x & 0x0000FFFFu) + ((x >> 16) & 0x0000FFFFu);\n\n    return int(x);\n}\n\nint nlz(in uint x){\n    x = x | (x >> 1);\n    x = x | (x >> 2);\n    x = x | (x >> 4);\n    x = x | (x >> 8);\n    x = x | (x >> 16);\n\n    return pop(~x);\n}\n\nint log2i(in uint x){\n    return 31 - nlz(x);\n}\n\nfloat font_sdf_char(in sampler2D sampler, in int code, in vec2 char_uv){\n    if(char_uv.x < 0. || char_uv.x > 1. || char_uv.y < 0. || char_uv.y > 1.)\n        return FONT_SDF_INITIAL_DISTANCE;\n\n    const float reciprocal = 1. / FONT_GRID_SIZE;\n\n    /*\n     * (char_uv + vec2(code % 16, 15 - code / 16)) / 16.;\n     */\n    float c = float(code);\n    vec2 uv = char_uv * reciprocal\n                + fract(vec2(c, FONT_GRID_SIZE - 1. - floor(c * reciprocal)) * reciprocal);\n\n    /*\n     *                 boundary\n     *   -0.5 ========== 0.0 ========= +0.5 (distance)\n     *     |<--  Int.  -->|<--  Ext.  -->|\n     */\n    return textureLod(sampler, uv, 0.).a - 0.5;\n}\n\nvoid text_init(out TextState ts, in float base_dim){\n    float ml = FONT_METRICS_DEFAULT.margin_left / FONT_TEXTURE_SIZE;\n    float mt = (FONT_METRICS_DEFAULT.margin_top - 0.5 * FONT_METRICS_DEFAULT.line_gap) / FONT_TEXTURE_SIZE;\n    ts.hori_offset = vec2(ml, -(ml + floor(FONT_METRICS_DEFAULT.advance / FONT_TEXTURE_SIZE * base_dim) / base_dim));\n    ts.vert_offset = vec2(-mt, mt + floor((FONT_METRICS_DEFAULT.height + FONT_METRICS_DEFAULT.line_gap) / FONT_TEXTURE_SIZE * base_dim) / base_dim);\n\n    ts.dist = FONT_SDF_INITIAL_DISTANCE;\n    ts.res_scale = base_dim / FONT_TEXTURE_SIZE;\n}\n\nvec2 text_raw_char_size(in TextState ts){\n    return vec2(abs(ts.hori_offset.x + ts.hori_offset.y),\n                ts.vert_offset.x + ts.vert_offset.y);\n}\n\nvec2 text_char_size(in TextState ts){\n    return text_raw_char_size(ts) * ts.scale;\n}\n\nvoid text_begin(inout TextState ts, in float scale){\n    ts.dist = FONT_SDF_INITIAL_DISTANCE;\n    ts.scale = scale;\n}\n\nvoid text_end(inout TextState ts,\n              in vec3 text_color, in vec3 outline_color, inout vec3 color){\n    // Inversely proportional to the font scale.\n    float scale = ts.res_scale * ts.scale;\n    float f = 1. - exp2(- 1. / (scale * scale));\n\n    /*\n     *        1.5*MID  MID  0.5*MID   0   0.5*MED  MED  1.5*MED\n     * --~-------+------+------+------+------+------+------+------+--~-->\n     *      Font |<<   MIX   >>| OTL. | OTL. |<<   MIX   >>| BG.  |\n     */\n    float max_interior_dist = mix(0.004, 0.010, f);\n    float max_exterior_dist = mix(0.020, 0.050, f);\n\n    vec3 mixed_color = mix(text_color, color, step(0., ts.dist));\n\n    vec3 interior_color = mix(outline_color, mixed_color, smoothstep(0., max_interior_dist, abs(ts.dist) - 0.5 * max_interior_dist));\n    vec3 exterior_color = mix(outline_color, mixed_color, smoothstep(0., max_exterior_dist, ts.dist - 0.5 * max_exterior_dist));\n\n    mixed_color = mix(interior_color, exterior_color, step(0., ts.dist));\n    color = mix(mixed_color, color, step(FONT_SDF_INITIAL_DISTANCE, ts.dist));\n}\n\nvoid text_end(inout TextState ts, inout vec3 color){\n    text_end(ts, TEXT_COLOR_DEFAULT, TEXT_OUTLINE_COLOR_DEFAULT, color);\n}\n\nvoid text_set_pos(inout TextState ts, in vec2 uv, in vec2 x){\n    ts.pos = ts.org = uv - (x - vec2(0., 1.));\n}\n\nvoid text_advance_pos(inout vec2 p, in vec2 offset, in float scale, in int num_chars){\n    p.x += float(num_chars) * (offset.x + offset.y) * scale;\n}\n\nvoid text_newline(inout vec2 p, in vec2 offset, in float scale, in float left){\n    p.x = left;\n    p.y += (offset.x + offset.y) * scale;\n}\n\nvoid text_newline(inout TextState ts){\n    text_newline(ts.pos, ts.vert_offset, ts.scale, ts.org.x);\n}\n\nivec2 text_map_to_index(in vec2 p, in vec2 hori_offset, in vec2 vert_offset, in float scale){\n    return ivec2(floor(p.x / (abs(hori_offset.x + hori_offset.y) * scale)),\n                 floor((1. - p.y) / ((vert_offset.x + vert_offset.y) * scale)));\n}\n\nint text_count_digits(in uint x){\n    x = min(x, uint(TEXT_POW10_TABLE[TEXT_MAX_INT_DIGITS] - 1));\n\n    int y = (9 * log2i(x | 1u)) >> 5;\n\n    return y + int(x > uint(TEXT_POW10_TABLE[y + 1] - 1)) + 1;\n}\n\nint text_count_digits(in uint x, in int min_digits){\n    return max(text_count_digits(x), min_digits);\n}\n\nvoid text_char_internal(in sampler2D sampler, in int code,\n                        inout vec2 p, in vec2 hori_offset, in vec2 vert_offset, in float scale, inout float dist){\n    vec2 q = p + vec2(hori_offset.x, vert_offset.x) * scale;\n\n    float gs = FONT_GRID_SIZE / scale;\n    vec2 char_uv = q * gs;\n    char_uv.y -= gs - 1.;\n\n    dist = min(dist, font_sdf_char(sampler, code, char_uv));\n\n    p.x = q.x + hori_offset.y * scale;\n}\n\nvoid text_char(in sampler2D sampler, inout TextState ts, in int code){\n    ivec2 index = text_map_to_index(ts.pos, ts.hori_offset, ts.vert_offset, ts.scale);\n\n    if(index.x >= 1 || index.y >= 1){\n        text_advance_pos(ts.pos, ts.hori_offset, ts.scale, 1);\n        return;\n    }\n\n    if(index.x < 0 || index.y < 0){\n        return;\n    }\n\n    text_char_internal(sampler, code, ts.pos, ts.hori_offset, ts.vert_offset, ts.scale, ts.dist);\n}\n\nvoid text_value_common(in sampler2D sampler, inout TextState ts,\n                       in int signum, in int i, in int f, in int i_len, in int f_len){\n    int signed_int_len = int(signum < 0) + i_len;\n    int len = signed_int_len + f_len + int(f_len > 0);\n    ivec2 index = text_map_to_index(ts.pos, ts.hori_offset, ts.vert_offset, ts.scale);\n\n    if(index.x >= len || index.y >= 1){\n        text_advance_pos(ts.pos, ts.hori_offset, ts.scale, len);\n        return;\n    }\n\n    if(index.x < 0 || index.y < 0){\n        return;\n    }\n\n    int code;\n\n    if(index.x == 0 && signum < 0){\n        code = 45;\n    }else if(index.x == signed_int_len){\n        code = 46;\n    }else if(index.x < signed_int_len){\n        int place = TEXT_POW10_TABLE[signed_int_len - 1 - index.x];\n        code = 48 + ((i / place) % 10);\n    }else{\n        int place = TEXT_POW10_TABLE[len - 1 - index.x];\n        code = 48 + ((f / place) % 10);\n    }\n\n    text_advance_pos(ts.pos, ts.hori_offset, ts.scale, index.x);\n    text_char_internal(sampler, code, ts.pos, ts.hori_offset, ts.vert_offset, ts.scale, ts.dist);\n}\n\nvoid text_decompose_value(in uint x, in int min_digits,\n                          out int signum, out int i, out int f, out int i_len, out int f_len){\n    signum = int(x > 0u);\n    i = int(x);\n    f = 0;\n    i_len = text_count_digits(x, min_digits);\n    f_len = 0;\n}\n\nvoid text_decompose_value(in int x, in int min_digits,\n                          out int signum, out int i, out int f, out int i_len, out int f_len){\n    signum = sign(x);\n    i = abs(x);\n    f = 0;\n    i_len = text_count_digits(uint(i), min_digits);\n    f_len = 0;\n}\n\nvoid text_decompose_value(in float x, in int min_digits,\n                          out int signum, out int i, out int f, out int i_len, out int f_len){\n    float fx, ix;\n    fx = modf(abs(x), ix);\n    fx = float(TEXT_POW10_TABLE[min_digits]) * fx;\n\n    signum = sign(int(x));\n    i = int(ix);\n    f = int(fx);\n    i_len = text_count_digits(uint(i), 1);\n    f_len = text_count_digits(uint(f), min_digits) * int(min_digits > 0);\n}\n\n#define DEF_TEXT_VALUE(T) \\\n    int text_length_inner(in T x, in int min_digits, \\\n                          out int signum, out int i, out int f, out int i_len, out int f_len){ \\\n        min_digits = min(min_digits, TEXT_MAX_INT_DIGITS); \\\n        text_decompose_value(x, min_digits, signum, i, f, i_len, f_len); \\\n        return int(signum < 0) + i_len + f_len + int(f_len > 0); \\\n    } \\\n    int text_length(in T x, in int min_digits){ \\\n        int signum, i, f, i_len, f_len; \\\n        return text_length_inner(x, min_digits, signum, i, f, i_len, f_len); \\\n    } \\\n    void text_value(in sampler2D sampler, inout TextState ts, in T x, in int min_digits){ \\\n        int signum, i, f, i_len, f_len; \\\n        text_length_inner(x, min_digits, signum, i, f, i_len, f_len); \\\n        text_value_common(sampler, ts, signum, i, f, i_len, f_len); \\\n    }\n\nDEF_TEXT_VALUE(uint)\nDEF_TEXT_VALUE(int)\nDEF_TEXT_VALUE(float)\n\n/*\n * This macro defines text_value functions for vector types.\n * It separates definitions by dimension, such as 2D, 3D, and 4D, to reduce\n * compile time.\n *\n * Usage example:\n *\n *   DEF_TEXT_VEC2_VALUE(uvec2)\n *\n *   void text_value(in sampler2D sampler, inout TextState ts,\n *                   in uvec2 x, in int min_digits){\n *       text_vec_value(sampler, x, min_digits, _COMMA, ts);\n *   }\n *\n *   DEF_TEXT_VEC2_VALUE(ivec2)\n *\n *   void text_value(in sampler2D sampler, inout TextState ts,\n *                   in ivec2 x, in int min_digits){\n *       text_vec_value(sampler, x, min_digits, _COMMA, ts);\n *   }\n *\n *   DEF_TEXT_VEC2_VALUE(vec2)\n *\n *   void text_value(in sampler2D sampler, inout TextState ts,\n *                   in vec2 x, in int min_digits){\n *       text_vec_value(sampler, x, min_digits, _COMMA, ts);\n *   }\n *\n */\n#define DEF_TEXT_VEC2_VALUE(T) \\\n    int text_length_inner(in T x, in int min_digits, \\\n                          out ivec2 signum, out ivec2 i, out ivec2 f, out ivec2 i_len, out ivec2 f_len){ \\\n        min_digits = min(min_digits, TEXT_MAX_INT_DIGITS); \\\n        text_decompose_value(x.x, min_digits, signum.x, i.x, f.x, i_len.x, f_len.x); \\\n        text_decompose_value(x.y, min_digits, signum.y, i.y, f.y, i_len.y, f_len.y); \\\n        ivec2 len = ivec2(lessThan(signum, ivec2(0))) + i_len + ivec2(lessThan(ivec2(0), f_len)) + f_len; \\\n        return 2 - 1 + len.x + len.y; \\\n    } \\\n    int text_length(in T x, in int min_digits){ \\\n        ivec2 signum, i, f, i_len, f_len; \\\n        return text_length_inner(x, min_digits, signum, i, f, i_len, f_len); \\\n    } \\\n    void text_vec_value(in sampler2D sampler, inout TextState ts, in T x, in int min_digits, in int sep){ \\\n        ivec2 signum, i, f, i_len, f_len; \\\n        int total_len = text_length_inner(x, min_digits, signum, i, f, i_len, f_len); \\\n        vec2 size = text_char_size(ts); \\\n        size.x *= float(total_len); \\\n        vec2 p = ts.pos; \\\n        if(p.x < 0. || p.x > size.x || p.y > 1. || p.y < 1. - size.y){ \\\n            text_advance_pos(p, ts.hori_offset, ts.scale, total_len); \\\n            ts.pos = p; \\\n            return; \\\n        } \\\n        text_value_common(sampler, ts, signum.x, i.x, f.x, i_len.x, f_len.x); \\\n        text_char(sampler, ts, sep); \\\n        text_value_common(sampler, ts, signum.y, i.y, f.y, i_len.y, f_len.y); \\\n    }\n\n#define DEF_TEXT_VEC3_VALUE(T) \\\n    int text_length_inner(in T x, in int min_digits, \\\n                          out ivec3 signum, out ivec3 i, out ivec3 f, out ivec3 i_len, out ivec3 f_len){ \\\n        min_digits = min(min_digits, TEXT_MAX_INT_DIGITS); \\\n        text_decompose_value(x.x, min_digits, signum.x, i.x, f.x, i_len.x, f_len.x); \\\n        text_decompose_value(x.y, min_digits, signum.y, i.y, f.y, i_len.y, f_len.y); \\\n        text_decompose_value(x.z, min_digits, signum.z, i.z, f.z, i_len.z, f_len.z); \\\n        ivec3 len = ivec3(lessThan(signum, ivec3(0))) + i_len + ivec3(lessThan(ivec3(0), f_len)) + f_len; \\\n        return 3 - 1 + len.x + len.y + len.z; \\\n    } \\\n    int text_length(in T x, in int min_digits){ \\\n        ivec3 signum, i, f, i_len, f_len; \\\n        return text_length_inner(x, min_digits, signum, i, f, i_len, f_len); \\\n    } \\\n    void text_vec_value(in sampler2D sampler, inout TextState ts, in T x, in int min_digits, in int sep){ \\\n        ivec3 signum, i, f, i_len, f_len; \\\n        int total_len = text_length_inner(x, min_digits, signum, i, f, i_len, f_len); \\\n        vec2 size = text_char_size(ts); \\\n        size.x *= float(total_len); \\\n        vec2 p = ts.pos; \\\n        if(p.x < 0. || p.x > size.x || p.y > 1. || p.y < 1. - size.y){ \\\n            text_advance_pos(p, ts.hori_offset, ts.scale, total_len); \\\n            ts.pos = p; \\\n            return; \\\n        } \\\n        text_value_common(sampler, ts, signum.x, i.x, f.x, i_len.x, f_len.x); \\\n        text_char(sampler, ts, sep); \\\n        text_value_common(sampler, ts, signum.y, i.y, f.y, i_len.y, f_len.y); \\\n        text_char(sampler, ts, sep); \\\n        text_value_common(sampler, ts, signum.z, i.z, f.z, i_len.z, f_len.z); \\\n    }\n\n#define DEF_TEXT_VEC4_VALUE(T) \\\n    int text_length_inner(in T x, in int min_digits, \\\n                          out ivec4 signum, out ivec4 i, out ivec4 f, out ivec4 i_len, out ivec4 f_len){ \\\n        min_digits = min(min_digits, TEXT_MAX_INT_DIGITS); \\\n        text_decompose_value(x.x, min_digits, signum.x, i.x, f.x, i_len.x, f_len.x); \\\n        text_decompose_value(x.y, min_digits, signum.y, i.y, f.y, i_len.y, f_len.y); \\\n        text_decompose_value(x.z, min_digits, signum.z, i.z, f.z, i_len.z, f_len.z); \\\n        text_decompose_value(x.w, min_digits, signum.w, i.w, f.w, i_len.w, f_len.w); \\\n        ivec4 len = ivec4(lessThan(signum, ivec4(0))) + i_len + ivec4(lessThan(ivec4(0), f_len)) + f_len; \\\n        return 4 - 1 + len.x + len.y + len.z + len.w; \\\n    } \\\n    int text_length(in T x, in int min_digits){ \\\n        ivec4 signum, i, f, i_len, f_len; \\\n        return text_length_inner(x, min_digits, signum, i, f, i_len, f_len); \\\n    } \\\n    void text_vec_value(in sampler2D sampler, inout TextState ts, in T x, in int min_digits, in int sep){ \\\n        ivec4 signum, i, f, i_len, f_len; \\\n        int total_len = text_length_inner(x, min_digits, signum, i, f, i_len, f_len); \\\n        vec2 size = text_char_size(ts); \\\n        size.x *= float(total_len); \\\n        vec2 p = ts.pos; \\\n        if(p.x < 0. || p.x > size.x || p.y > 1. || p.y < 1. - size.y){ \\\n            text_advance_pos(p, ts.hori_offset, ts.scale, total_len); \\\n            ts.pos = p; \\\n            return; \\\n        } \\\n        text_value_common(sampler, ts, signum.x, i.x, f.x, i_len.x, f_len.x); \\\n        text_char(sampler, ts, sep); \\\n        text_value_common(sampler, ts, signum.y, i.y, f.y, i_len.y, f_len.y); \\\n        text_char(sampler, ts, sep); \\\n        text_value_common(sampler, ts, signum.z, i.z, f.z, i_len.z, f_len.z); \\\n        text_char(sampler, ts, sep); \\\n        text_value_common(sampler, ts, signum.w, i.w, f.w, i_len.w, f_len.w); \\\n    }\n\n#ifdef ENABLE_STRING\n/*\n * String\n *\n * Inspired by the following work:\n * Mostly-readable text in source - ttg\n * https://www.shadertoy.com/view/Wd2SDt\n */\n\n#define ENCODE_CHARS(a, b, c, d) \\\n    (((a) << 24) | (((b) & 0xFF) << 16) | (((c) & 0xFF) << 8) | ((d) & 0xFF))\n\n#define DECODE_CHARS(x) \\\n    int[4](((x) >> 24) & 0xFF,((x) >> 16) & 0xFF,((x) >> 8) & 0xFF, (x) & 0xFF)\n\n#define ENCODE_STRING_HEADER(f0, f1, f2, f3) \\\n    ENCODE_CHARS(f0, f1, f2, f3)\n\n#define DECODE_STRING_HEADER(header) \\\n    DECODE_CHARS(header)\n\n#define STRING_AT(arr, i) arr[clamp((i), 0, arr.length() - 1)]\n\n#define STRING_ENCODE_CHARS(arr, offs) \\\n    ENCODE_CHARS(STRING_AT(arr, offs + 0), STRING_AT(arr, offs + 1), STRING_AT(arr, offs + 2), STRING_AT(arr, offs + 3))\n\n/*\n * DEF_STRING:\n *   WebGL does not support the token-pasting operator (##), so a temporary\n *   variable must be manually specified.\n *   Let's hope the compiler optimizes away the temporary variable.\n */\n\n// STRING8\n\n#define _DEF_STRING8(var, tmp, f0, f1, f2, f3, arr) \\\n    const int[] tmp = arr; \\\n    const int[] var = int[3](ENCODE_STRING_HEADER(f0, f1, f2, f3), \\\n                             STRING_ENCODE_CHARS(tmp, 0x00), STRING_ENCODE_CHARS(tmp, 0x04));\n\n#define DEF_STRING8_WITH_VALUE(var, tmp, p, d, arr) \\\n    _DEF_STRING8(var, tmp, min(tmp.length(), 8), p, d, 0, arr)\n\n#define DEF_STRING8_WITH_VALUE_AT_START(var, tmp, d, arr) \\\n    DEF_STRING8_WITH_VALUE(var, tmp, 0, d, arr)\n\n#define DEF_STRING8_WITH_VALUE_AT_END(var, tmp, d, arr) \\\n    DEF_STRING8_WITH_VALUE(var, tmp, min(tmp.length(), 8), d, arr)\n\n#define DEF_STRING8(var, tmp, arr) \\\n    DEF_STRING8_WITH_VALUE_AT_END(var, tmp, 1, arr)\n\n// STRING16\n\n#define _DEF_STRING16(var, tmp, f0, f1, f2, f3, arr) \\\n    const int[] tmp = arr; \\\n    const int[] var = int[5](ENCODE_STRING_HEADER(f0, f1, f2, f3), \\\n                             STRING_ENCODE_CHARS(tmp, 0x00), STRING_ENCODE_CHARS(tmp, 0x04), \\\n                             STRING_ENCODE_CHARS(tmp, 0x08), STRING_ENCODE_CHARS(tmp, 0x0C));\n\n#define DEF_STRING16_WITH_VALUE(var, tmp, p, d, arr) \\\n    _DEF_STRING16(var, tmp, min(tmp.length(), 16), p, d, 0, arr)\n\n#define DEF_STRING16_WITH_VALUE_AT_START(var, tmp, d, arr) \\\n    DEF_STRING16_WITH_VALUE(var, tmp, 0, d, arr)\n\n#define DEF_STRING16_WITH_VALUE_AT_END(var, tmp, d, arr) \\\n    DEF_STRING16_WITH_VALUE(var, tmp, min(tmp.length(), 16), d, arr)\n\n#define DEF_STRING16(var, tmp, arr) \\\n    DEF_STRING16_WITH_VALUE_AT_END(var, tmp, 1, arr)\n\n// STRING32\n\n#define _DEF_STRING32(var, tmp, f0, f1, f2, f3, arr) \\\n    const int[] tmp = arr; \\\n    const int[] var = int[9](ENCODE_STRING_HEADER(f0, f1, f2, f3), \\\n                             STRING_ENCODE_CHARS(tmp, 0x00), STRING_ENCODE_CHARS(tmp, 0x04), \\\n                             STRING_ENCODE_CHARS(tmp, 0x08), STRING_ENCODE_CHARS(tmp, 0x0C), \\\n                             STRING_ENCODE_CHARS(tmp, 0x10), STRING_ENCODE_CHARS(tmp, 0x14), \\\n                             STRING_ENCODE_CHARS(tmp, 0x18), STRING_ENCODE_CHARS(tmp, 0x1C));\n\n#define DEF_STRING32_WITH_VALUE(var, tmp, p, d, arr) \\\n    _DEF_STRING32(var, tmp, min(tmp.length(), 32), p, d, 0, arr)\n\n#define DEF_STRING32_WITH_VALUE_AT_START(var, tmp, d, arr) \\\n    DEF_STRING32_WITH_VALUE(var, tmp, 0, d, arr)\n\n#define DEF_STRING32_WITH_VALUE_AT_END(var, tmp, d, arr) \\\n    DEF_STRING32_WITH_VALUE(var, tmp, min(tmp.length(), 32), d, arr)\n\n#define DEF_STRING32(var, tmp, arr) \\\n    DEF_STRING32_WITH_VALUE_AT_END(var, tmp, 1, arr)\n\n// STRING64\n\n#define _DEF_STRING64(var, tmp, f0, f1, f2, f3, arr) \\\n    const int[] tmp = arr; \\\n    const int[] var = int[17](ENCODE_STRING_HEADER(f0, f1, f2, f3), \\\n                              STRING_ENCODE_CHARS(tmp, 0x00), STRING_ENCODE_CHARS(tmp, 0x04), \\\n                              STRING_ENCODE_CHARS(tmp, 0x08), STRING_ENCODE_CHARS(tmp, 0x0C), \\\n                              STRING_ENCODE_CHARS(tmp, 0x10), STRING_ENCODE_CHARS(tmp, 0x14), \\\n                              STRING_ENCODE_CHARS(tmp, 0x18), STRING_ENCODE_CHARS(tmp, 0x1C), \\\n                              STRING_ENCODE_CHARS(tmp, 0x20), STRING_ENCODE_CHARS(tmp, 0x24), \\\n                              STRING_ENCODE_CHARS(tmp, 0x28), STRING_ENCODE_CHARS(tmp, 0x2C), \\\n                              STRING_ENCODE_CHARS(tmp, 0x30), STRING_ENCODE_CHARS(tmp, 0x34), \\\n                              STRING_ENCODE_CHARS(tmp, 0x38), STRING_ENCODE_CHARS(tmp, 0x3C));\n\n#define DEF_STRING64_WITH_VALUE(var, tmp, p, d, arr) \\\n    _DEF_STRING64(var, tmp, min(tmp.length(), 64), p, d, 0, arr)\n\n#define DEF_STRING64_WITH_VALUE_AT_START(var, tmp, d, arr) \\\n    DEF_STRING64_WITH_VALUE(var, tmp, 0, d, arr)\n\n#define DEF_STRING64_WITH_VALUE_AT_END(var, tmp, d, arr) \\\n    DEF_STRING64_WITH_VALUE(var, tmp, min(tmp.length(), 64), d, arr)\n\n#define DEF_STRING64(var, tmp, arr) \\\n    DEF_STRING64_WITH_VALUE_AT_END(var, tmp, 1, arr)\n\n// STRING functions\n\n#define DEF_TEXT_STRING_WITH_VALUE(N, T) \\\n    int text_length(in int[N] string, in T x){ \\\n        return (string[0] >> 24) + text_length(x, (string[0] >> 8) & 0xFF); \\\n    } \\\n    void text_string(in sampler2D sampler, inout TextState ts, in int[N] string, in T x){ \\\n        int[] header = DECODE_STRING_HEADER(string[0]); \\\n        int s_len = header[0]; \\\n        int x_pos = header[1]; \\\n        int min_digits = header[2]; \\\n        if(x_pos == 0){ \\\n            text_value(sampler, ts, x, min_digits); \\\n            text_string(sampler, ts, string); \\\n        }else if(x_pos == s_len){ \\\n            text_string(sampler, ts, string); \\\n            text_value(sampler, ts, x, min_digits); \\\n        }else{ \\\n            text_substring(sampler, ts, string, 0, x_pos); \\\n            text_value(sampler, ts, x, min_digits); \\\n            text_substring(sampler, ts, string, x_pos, s_len - x_pos); \\\n        } \\\n    }\n\n#define DEF_TEXT_STRING(N) \\\n    int text_length(in int[N] string){ \\\n        return string[0] >> 24; \\\n    } \\\n    void text_substring(in sampler2D sampler, inout TextState ts, in int[N] string, in int offset, in int len){ \\\n        ivec2 index = text_map_to_index(ts.pos, ts.hori_offset, ts.vert_offset, ts.scale); \\\n        if(index.x >= len || index.y >= 1){ \\\n            text_advance_pos(ts.pos, ts.hori_offset, ts.scale, len); \\\n            return; \\\n        } \\\n        if(index.x < 0 || index.y < 0){ \\\n            return; \\\n        } \\\n        int offset_index = index.x + offset; \\\n        int code = DECODE_CHARS(string[(offset_index / 4) + 1])[offset_index % 4]; \\\n        text_advance_pos(ts.pos, ts.hori_offset, ts.scale, index.x); \\\n        text_char_internal(sampler, code, ts.pos, ts.hori_offset, ts.vert_offset, ts.scale, ts.dist); \\\n    } \\\n    void text_string(in sampler2D sampler, inout TextState ts, in int[N] string){ \\\n        int[] header = DECODE_STRING_HEADER(string[0]); \\\n        text_substring(sampler, ts, string, 0, header[0]); \\\n    } \\\n    DEF_TEXT_STRING_WITH_VALUE(N, int) \\\n    DEF_TEXT_STRING_WITH_VALUE(N, uint) \\\n    DEF_TEXT_STRING_WITH_VALUE(N, float)\n\nDEF_TEXT_STRING(3)\nDEF_TEXT_STRING(5)\nDEF_TEXT_STRING(9)\nDEF_TEXT_STRING(17)\n\n#endif // ENABLE_STRING\n","name":"Common","description":"","type":"common"}]}