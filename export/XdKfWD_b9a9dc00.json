{"ver":"0.1","info":{"id":"XdKfWD","date":"1528901048","viewed":102,"name":"Graffat on","username":"luutifa","description":"For graffathon 2018","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["finlandsfarjan"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float random (vec2 st) {\n    return fract(sin(dot(st,vec2(12.9898,78.233)))*43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nconst int OCTAVES=5;\nfloat fbm (vec2 st) {\n    float value = 0.0;\n    float amplitude = 0.5;\n    float frequency = 0.;\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\nconst int ITR=50;\nconst float EPS=0.001;\nconst float MAX_T=120.;\n\nint material = 0;\n\nfloat xz_plane(vec3 p) {\n    return p.y;\n}\n\nfloat sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec2 middle_sphere(vec3 p) {\n    //return vec2(sphere(p - vec3(2.8, 2.5, 5.), 1.), 0.);\n    return vec2(sphere(p - vec3(4., 2.5, 4.), 0.8), 0.);\n}\n\nvec2 floor_plane(vec3 p) {\n    vec2 aallot_pos = p.xz*0.5;\n    aallot_pos.x += sin(aallot_pos.y*2.+iTime*0.6)*0.2;\n    return vec2(xz_plane(p - vec3(0., -1., 0.) - fbm(aallot_pos)*0.2 + fbm(aallot_pos+iTime*0.4)*0.2), 1.);\n}\n\nvec2 boat(vec3 p) {\n    float a = 0.6;\n    vec2 base = vec2(sdBox(vec3(p.x * cos(a) - p.z * sin(a), p.y, p.x * sin(a) + p.z * cos(a)) - vec3(-1.5, -1., 3.), vec3(.4, 0.1, 1.)), 2.);\n    vec2 top = vec2(sdBox(vec3(p.x * cos(a) - p.z * sin(a), p.y, p.x * sin(a) +p.z * cos(a)) - vec3(-1.5, -0.9, 3.), vec3(.3, 0.1, 0.8)), 3.);\n    vec2 piippu = vec2(sdBox(vec3(p.x * cos(a) - p.z * sin(a),\n                    p.y,p.x*sin(a)+p.z * cos(a)) - vec3(-1.5, -.7, 2.6), vec3(.06, 0.1,0.2)), 2.);\n    if (base.x < top.x) {\n        return base;\n    } else if (top.x < piippu.x) {\n        return top;\n    } else {\n        return piippu;\n    }\n}\n\nvec2 sdf(vec3 p) {\n    vec2 ms = middle_sphere(p);\n    vec2 fp = floor_plane(p);\n    vec2 bt = boat(p);\n    if (ms.x < fp.x) {\n        return ms;\n    } else if (fp.x < bt.x) {\n        return fp;\n    } else {\n        return bt;\n    }\n}\n\nvec3 march(vec3 cam, vec3 ray) {\n    vec2 dist;\n    float t=0.;\n    for (int i=0; i<ITR; i++) {\n        dist = sdf(cam + ray * t);\n        t += dist.x*1.2;\n        if (dist.x < EPS) {\n            material = int(dist.y);\n            break;\n        }\n        if (t > MAX_T) {\n            material = -1;\n            break;\n        }\n    }\n    return cam + ray * t;\n}\n\nvec3 grad(vec3 p) {\n    vec2 e = vec2(EPS, 0.);\n    return (vec3(sdf(p+e.xyy).x, sdf(p+e.yxy).x, sdf(p+e.yyx).x) - sdf(p).x) / e.x;\n}\n\nvec3 sky(vec3 p) {\n    return mix(vec3(0.2, 0.3, 0.7), vec3(0.3, 0.5, 1.1), p.y/20.);\n}\n\nvec3 shade(vec3 p) {\n    if (p.z > 6.) {\n        return sky(p);\n    }\n    vec3 light = normalize(vec3(0., 0., 1.));\n    vec3 light2 = normalize(vec3(-0.2, -1., 0.2));\n    vec3 normal = normalize(grad(p));\n\n    float l = clamp(dot(-normal, light), 0., 1.);\n    l += clamp(dot(-normal, light2), 0., 1.);\n\n    vec3 color = vec3(1., 1., 0.);\n    float emit = 0.2;\n    if (material == -1) {\n        color = vec3(0.);\n    } else if (material == 1) {\n        color = vec3(0., 0., 1.);\n        l += pow(l, 12.);\n    } else if (material == 2) {\n        color = vec3(1., 0., 0.);\n    } else if (material == 3) {\n        color = vec3(1.);\n    }\n    return vec3(l * (color + emit));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    //vec3 ray = normalize(vec3((v_texpos*vec2(2.*u_aspect_ratio,2.)-vec2(u_aspect_ratio,1.)), 1.));\n    vec3 ray = normalize(vec3(fragCoord/iResolution.yy*2.-1., 1.));\n    vec3 p = march(vec3(sin(iTime*0.3)*0.1, sin(iTime*0.2)*0.1, sin(iTime*0.1)*0.3), ray);\n    vec2 cloudpos = fragCoord/iResolution.xy*10.+vec2(iTime*0.6, 0.);\n    cloudpos.y += sin(cloudpos.x-iTime)*0.2;\n    cloudpos.y += sin(cloudpos.x*4.-iTime*0.3)*0.07;\n    fragColor = vec4(shade(p)+fbm(cloudpos*(sin(cloudpos.x+iTime)*.001+1.))*0.4*cloudpos.y/5., 1.);\n}\n\n","name":"Image","description":"","type":"image"}]}