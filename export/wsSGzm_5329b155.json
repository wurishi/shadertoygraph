{"ver":"0.1","info":{"id":"wsSGzm","date":"1548584236","viewed":68,"name":"RayMarcher-alima","username":"aliman2018","description":"raymarch based shader","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 1000\n#define MAX_DIST 100.\n#define SURF_DIST 0.0001\n#define ROT_SPEED 0.\n\n\nstruct Sphere{\n    vec4 s;\n    vec4 color;\n    float reflectiveness;\n};\n    \nstruct Plane{\n \tvec4 p;\n    vec4 color;\n    float reflectiveness;\n};\n    \nstruct Torus{\n \tvec3 t;\n    vec2 r;\n    vec3 d;\n    vec4 color;\n    float reflectiveness;\n};   \n    \nstruct Cube{\n    vec4 c;\n    vec3 d;\n    vec4 color;\n    float reflectiveness;\n};\nSphere sp = Sphere(vec4(0., 1., -6., 1), vec4(1., 0., 0., 1.), 0.);\nPlane pl = Plane(normalize(vec4(0., 1., 0., 0.)), vec4(1., 1., 0., 0.), 0.);\nTorus tr = Torus(vec3(0., 1., -6.), vec2(1., .4), vec3(0., 1., 0.), vec4(0., 1., 1., 1.), 0.);\nCube cb = Cube(vec4(3, 1, -6, 1), vec3(0, 1, 0), vec4(0, 1, 0, 1), 0.);\n\nfloat sdSphere(vec3 p, Sphere _sp){\n \treturn (length(p-_sp.s.xyz)-_sp.s.w);   \n}\n\nfloat sdPlane(vec3 p, Plane _pl){\n    float d = dot(p, _pl.p.xyz)-_pl.p.w;\n    \n    return d;\n}\n\nfloat sdTorus(vec3 p, Torus _tr){\n    float dxz = length(p.xz-_tr.t.xz)-_tr.r.x;\n    float dxyz = length(vec2(dxz, p.y-_tr.t.y))-_tr.r.y;\n    return dxyz;\n    \n}\n\nfloat sdCube(vec3 p, Cube _cb){\n    vec3 dif = abs(_cb.c.xyz-p);\n    return length(max(vec3(0), dif-_cb.c.w));\n}\n\nfloat sdIntersect(float d1, float d2) {\n    return max(d1, d2);\n}\n\nfloat sdUnion(float d1, float d2){\n    return min(d1, d2);\n}\n\nfloat sdDifference(float d1, float d2){\n    return max(d1, -d2);\n}\nfloat getDist(vec3 p){\n\tfloat sD = sdSphere(p, sp);\n    float pD = sdPlane(p, pl);\n    float tD = sdTorus(p, tr);\n    float cD = sdCube(p, cb);\n    float _min = sD;\n    _min = sdDifference(sD, tD);\n    _min = sdUnion(_min, pD);\n    _min = min(_min, cD);\n    return _min;\n}\n\nfloat rayMarch(vec3 d, vec3 o){\n \tvec3 p = o;\n    float dO = 0.;\n    float dist;\n    for(int i = 0; i < MAX_STEPS; i++){\n        dist = getDist(p);\n    \tdO += dist; \n        p = o + d*dO;\n        if(dO > MAX_DIST || dist < SURF_DIST){\n            break;\n        }\n    }\n\treturn dO;\n}\n\nvec3 getNormal(vec3 p){\n    \n    vec2 dd = vec2(SURF_DIST, 0);\n    float d = getDist(p);\n    float dx = getDist(p-dd.xyy);\n    float dy = getDist(p-dd.yxy);\n    float dz = getDist(p-dd.yyx);\n    return normalize(d-vec3(dx, dy, dz));\n\t\n    \n}\n\nvec4 getCol(vec3 p){\n    float sd = abs(sdSphere(p, sp));\n    float pd = abs(sdPlane(p, pl));\n    float td = abs(sdTorus(p, tr));\n    float cd = sdCube(p, cb);\n    float _min = min(sd, pd);\n    _min = min(_min, td);\n    _min = min(_min, cd);\n    if(_min == sd) return sp.color;\n    if(_min == pd) return pl.color;\n    if(_min == td) return tr.color;\n    if(_min == cd) return cb.color;\n    \n    \n    \n    return vec4(1, 1, 0, 1);\n}\n\nvec4 getLight(vec3 p){\n    vec3 norm = getNormal(p);\n    p += norm*SURF_DIST*2.;\n    vec3 lightPos = vec3(10.*sin(iTime), 7, 10.*cos(iTime));\n    float distToLight = length(p-lightPos);\n    vec3 dirToLight = normalize(lightPos-p);\n    float dist = rayMarch(dirToLight, p);\n    float diff = mix(.1, 1., clamp(dot(dirToLight, norm), 0., 1.));\n    \n    vec4 col = getCol(p);\n    \n    if(dist < distToLight){\n        return col*0.1;\n    }else{\n        return col*diff;\n    }\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y/1.;\n    vec3 camDir = vec3(sin(iTime*ROT_SPEED), 0., -cos(iTime*ROT_SPEED));\n    vec3 camPos = vec3(0, 2, 0.);\n    \n    vec3 px = vec3(-camDir.z, 0, camDir.x)*uv.x;\n    vec3 py = vec3(0, 1, 0)*uv.y;\n    \n    \n    \n    vec3 rD = normalize(camDir+px+py);\n    vec3 rO = camPos;\n    \n    float dist = rayMarch(rD, rO);\n    vec3 p = rO + rD*dist;\n    vec4 col = vec4(0);\n    if(dist < MAX_DIST){\n        col = vec4(getLight(p));\n    }\n\t//col = vec4(vec3(sdCube(p, vec4(-5, 1, -6, 1))/20.), 1.);\n    fragColor = vec4(col);\n}","name":"Image","description":"","type":"image"}]}