{"ver":"0.1","info":{"id":"ddBczG","date":"1687824958","viewed":68,"name":"Ray Marching - Nathan","username":"nathanvmag","description":"Trabalho final Computação Gráfica UFRJ","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURF_DIST 0.01\n#define PI 3.1415925359\n\n// Rotation matrix.\nmat2 Rot (float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nstruct Surface {\n    float sd; \n    vec3 col; \n};\nSurface minWithColor(Surface obj1, Surface obj2) {\n  if (obj2.sd < obj1.sd) return obj2; \n  return obj1;\n}\nSurface maxWithColorDif(Surface obj1, Surface obj2) {\n  obj1.sd*=-1.;\n  if (obj2.sd > obj1.sd) return obj2; \n  return obj1;\n}Surface maxWithColor(Surface obj1, Surface obj2) {\n  \n  if (obj2.sd > obj1.sd) return obj2; \n  return obj1;\n}\n\n\n// SDF of a torus at the origin given its two radius.\nSurface dTorus(vec3 p, vec2 r,vec3 col) {\n    float x = length(p.xz) - r.x;\n    float sd =length(vec2(x, p.y)) - r.y;\n    Surface suf ;\n    suf.col= col/255.;\n    suf.sd= sd;\n    return suf;\n}\n\n// SDF of a box at the origin given its size (width, height and depth).\nSurface dBox(vec3 p, vec3 s,vec3 col) {\n    Surface suf ;\n    suf.col=col/255.;\n    suf.sd= length(max(abs(p) - s, 0.0));\n    return suf;\n}\n\n// SDF of a sphere, given its center and radius.\nSurface dSphere(vec3 p, vec4 s,vec3 col) {\n    Surface suf ;\n    suf.col=col/255.;\n    suf.sd=length(p - s.xyz) - s.w;\n    return suf;\n}\n\n// SDF of a cylinder given a segment and a radius.\nSurface dCylinder(vec3 p, vec3 a, vec3 b, float r,vec3 col) {\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    \n    vec3 c = a + t * ab;\n    \n    float x = length(p - c) - r;\n    float y = (abs(t - 0.5) - 0.5) * length(ab);\n    float e = length(max(vec2(x, y), 0.0));\n    float i = min(max(x, y), 0.0);\n     Surface suf ;\n    suf.col=col/255.;\n    suf.sd= e + i;\n    return suf;\n}\nSurface sdCone( vec3 p, vec2 c, float h,vec3 col )\n{\n \n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n   Surface suf ;\n    suf.col=col/255.;\n    suf.sd= sqrt(d)*sign(s);\n    return suf;\n}\nSurface sdCutSphere( vec3 p, float r, float h,vec3 col )\n{\n  float w = sqrt(r*r-h*h);\n\n  vec2 q = vec2( length(p.xz), p.y );\n  float s = max( (h-r)*q.x*q.x+w*w*(h+r-2.0*q.y), h*q.x-w*q.y );\n   Surface suf ;\n    suf.col=col/255.;\n    suf.sd= (s<0.0) ? length(q)-r :\n         (q.x<w) ? h - q.y     :\n                   length(q-vec2(w,h));\n   return suf;\n}\nSurface sdRoundBox( vec3 p, vec3 b, float r ,vec3 col)\n{\n  vec3 q = abs(p) - b;\n   Surface suf ;\n    suf.col=col/255.;\n    suf.sd= length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n   return suf;\n}\nSurface sdHexPrism( vec3 p, vec2 h ,vec3 col)\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n Surface suf ;\n    suf.col=col/255.;\n    suf.sd= min(max(d.x,d.y),0.0) + length(max(d,0.0));\n return suf;\n}\nSurface sdOctahedron( vec3 p, float s,vec3 col )\n{\nSurface suf ;\n    suf.col=col/255.;\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else{suf.sd= m*0.57735027;return suf;}\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  \n    suf.sd= length(vec3(q.x,q.y-s+k,q.z-k));\n  return suf;\n}\n\n// B + A\nSurface unionSDF (Surface sda, Surface sdb) {\n     return minWithColor(sda, sdb);\n    \n}\n\n// B * A\nSurface intersectionSDF (Surface sda, Surface sdb) {\n     return maxWithColor(sda, sdb);\n}\n\n// B - A\nSurface differenceSDF (Surface sda, Surface sdb) {\n    \n    return maxWithColorDif(sda, sdb);\n    \n}\n\n\n// Blend A and B\nSurface blendSDF(Surface sda, Surface sdb, float k,vec3 col) {\n    float h = clamp(0.5 + 0.5 * (sdb.sd - sda.sd) / k, 0.0, 1.0);\n     Surface suf ;\n    suf.col=col/255.;\n    suf.sd= mix(sdb.sd, sda.sd, h) - k * h * (1.0 - h);\n    return suf;\n}\n\n// Scene SDF: signed distance function.\nSurface getDist(vec3 p) {\n    Surface planeDist;\n    planeDist.sd= p.y;\n    planeDist.col=  vec3(250, 235, 215)/255.;\n    \n    float s = sin(iTime);\n    \n    vec3 baciaPosition= p- vec3(-2.5,1.0,4);\n    vec3 spherePosition= p-vec3(-2.5,1.0,-2);\n    vec3 rosquinhaPosition= p - vec3(-2.6, 1.0, 4.1);\n    vec3 roundBoxPosition = p - vec3(1,0.1,6);\n    vec3 sphere2Position= p-vec3(5.5,3.0,2);\n    vec3 boxPosition = p-vec3(-4,3,10);\n    vec3 hexPosition = p-vec3(-4,3,10);\n    boxPosition.x+=1.5*sin(iTime);\n    vec3 diamondPosition = p-vec3(1.4,1,2);\n    vec3 rosquinhaPosition2= p - vec3(0.8, 2.4, 5);\n    vec3 rosquinhaPosition3= p - vec3(1.3, 2.4, 5);\n    vec3 rosquinhaPosition4= p - vec3(0.3, 2.4, 5);\n    vec3 conePosition = p-vec3(-0.8,1,3.4);\n    vec3 sphere3Position= p-vec3(-0.75,0.1,-2.9);\n\n    \n    Surface sphereBaciaDistance  = dSphere(spherePosition, vec4(0, 0, 6 , 0.55),vec3(244,144,100));\n    baciaPosition.yz*= Rot(120.0);\n    baciaPosition.xy*= (Rot((iTime))); \n    rosquinhaPosition.yz*= Rot(iTime);\n    Surface baciaDistance= sdCutSphere(baciaPosition,0.60,0.02,vec3(244,144,100));\n    Surface rosquinhaDistance= dTorus(rosquinhaPosition, vec2(0.15, 0.08),vec3(250, 50, 233));\n    Surface roundBoxDistance= sdRoundBox(roundBoxPosition,vec3(1,0.1,0.4),0.2,vec3(48, 40, 30)); \n    float displacement = sin(6.0 * p.x) * sin(4.0 * p.y) * sin(8.0 * p.z) * sin(iTime)* 0.15;\n    float displacement2 = sin(70. * p.x)  *  0.01;\n    diamondPosition.xz*=Rot((iTime));\n\n    Surface sphere2Distance  = dSphere(sphere2Position, vec4(0, 0, 6 , 0.55) + displacement,vec3(46, 230, 230));\n\n    Surface BoxDistance= dBox(boxPosition,vec3(0.7,0.7,0.7),vec3(230, 230, 46)); \n    Surface HexDistance= sdHexPrism(hexPosition,vec2(0.73,0.73),vec3(230, 230, 46)); \n    Surface DiamondDistance= sdOctahedron(diamondPosition+ displacement2,0.35,vec3(95, 5, 173)); \n    \n    rosquinhaPosition2.yz*= Rot(1.5708);\n    rosquinhaPosition3.yz*= Rot(1.5708);\n    rosquinhaPosition4.yz*= Rot(1.5708);\n    rosquinhaPosition3.x+= 0.4*sin(iTime);\n    rosquinhaPosition4.x-= 0.4*sin(iTime);\n\n    float displacement3 = sin(5.0 * p.x) * sin(6.0 * p.y) * sin(4.0 * p.z) * sin(iTime)* 0.15;\n\n    Surface rosquinhaDistance2= dTorus(rosquinhaPosition2+displacement3, vec2(0.4, 0.1),vec3(250, 50, 233));\n    Surface rosquinhaDistance3= dTorus(rosquinhaPosition3+displacement, vec2(0.2, 0.1),vec3(250, 50, 233));\n    Surface rosquinhaDistance4= dTorus(rosquinhaPosition4+displacement, vec2(0.2, 0.1),vec3(250, 50, 233));\n    float coneH= 0.8 + 0.25*sin(iTime);\n    Surface coneDistance = sdCone( conePosition,vec2(0.1,0.2),coneH,vec3(66, 135, 245) );\n    Surface sphere3Distance  = dSphere(sphere3Position, vec4(0, 0, 6 , 0.3),vec3(33, 58, 97));\n\n    Surface d = minWithColor( planeDist,differenceSDF(sphereBaciaDistance,baciaDistance));    \n    d= minWithColor(d,rosquinhaDistance);\n    d= minWithColor(d,roundBoxDistance);\n    d= minWithColor(d,sphere2Distance);\n    d= minWithColor(d,DiamondDistance);\n    d= minWithColor(d,differenceSDF(sphere3Distance,coneDistance));\n    \n\n    d= minWithColor(d,differenceSDF (HexDistance,BoxDistance));\n    d= minWithColor(d, blendSDF(blendSDF(rosquinhaDistance2,rosquinhaDistance4,0.1,vec3(250, 50, 233)),rosquinhaDistance3,0.1,vec3(250, 50, 233)));\n    \n\n    const int cilindersCount=3;\n    vec3 cilinders[cilindersCount];\n    Surface cilindersDistances[cilindersCount];\n    vec3 cilindersColors[cilindersCount];\n    cilindersColors[0]=vec3(100,200,30);\n    cilindersColors[1]=vec3(245, 240, 95);\n    cilindersColors[2]=vec3(245, 75, 37);\n    for(int i=0;i<cilindersCount;i++){\n        vec3 position = p- vec3( 0.2+ (0.8 *(float(i))) ,-2.5 +(float(i)*0.11),5.8);  \n        position.yz*= Rot(-30.0);  \n        position.z -= sin(iTime )*( 0.2 + float(i)*0.17) ;\n        cilinders[i]= position;\n        cilindersDistances[i]= dCylinder(cilinders[i],vec3(0, 0.3, 3),vec3(0, 0.3, 2.1),0.2,cilindersColors[i]);\n        d= minWithColor(d,unionSDF(roundBoxDistance, cilindersDistances[i]));\n       }\n    \n  \n    \n    \n    return d;\n}\n\n// Walk through empty spheres until the ray hits an object\n// or is beyond MAX_DIST, meaning no hit. \nSurface rayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.0;\n    Surface suf;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * dO;\n        Surface distsuf= getDist(p);\n        suf.col= distsuf.col;\n        float dS = distsuf.sd;\n        dO += dS;\n        if (dO > MAX_DIST || dS < SURF_DIST) break;\n    }\n    suf.sd= dO;\n    return suf;\n}\n\n// The normal is the gradient of the SDF scalar field at point p.\n// By using finite difference: \n// https://en.wikipedia.org/wiki/Finite_difference#Relation_with_derivatives \nvec3 getNormal(vec3 p) {\n    // arbitrary — should be smaller than any surface detail in your distance function, \n    // but not so small as to get lost in float precision\n    vec2 e = vec2(0.001, 0);\n    \n    vec3 n = \n        vec3(\n        getDist(p + e.xyy).sd,\n        getDist(p + e.yxy).sd,\n        getDist(p + e.yyx).sd) - \n        vec3(\n        getDist(p - e.xyy).sd,\n        getDist(p - e.yxy).sd,\n        getDist(p - e.yyx).sd);\n        \n    return normalize(n);\n}\n\n// Phong illumination model, given a point and camera position.\nfloat getLight(vec3 p, vec3 ro) {\n    vec3 lightPos = vec3(-2, 5, 0);\n    \n    lightPos.xz += vec2(sin(iTime), cos(iTime)) * 1.;\n    \n    vec3 l = normalize(lightPos - p);\n    vec3 n = getNormal(p);\n    vec3 r = reflect(-l,n);\n    \n    // ambient component\n    float amb = 0.1;\n    // ambient reflection coefficient\n    float ka = 1.0;\n    \n    // diffuse component - apply Lambert's cosine law\n    float dif = clamp(dot(n, l), 0.0, 1.0);\n    // diffuse reflection coefficient\n    float kd = 0.8;\n    \n    // specular component\n    float shininess = 200.;\n    vec3 v = normalize(ro-p);\n    float spec = clamp(dot(r, v), 0.0, 1.0);\n    spec = pow(spec,shininess);\n    // specular reflection coefficient\n    float ks = 1.0;\n    \n    // slightly move point p in the direction of the normal,\n    // so the distance is not zero. Otherwise, the first hit \n    // will be at the plane.\n    Surface d = rayMarch(p + 2. * n * SURF_DIST , l);\n    \n    // cast a ray to the light\n    if (d.sd < length(lightPos - p)) {\n        // point in the shadow\n        dif *= 0.1;\n        spec *= 0.5;\n    }\n    \n    // ambient + diffuse + specular components\n    return ka * amb + kd * dif + ks * spec;\n}\n\n// Fragment shader.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    // camera position\n    vec3 ro = vec3(0, 2, 0);\n    \n    // projection plane z = 1\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    // Rotate camera down about the x-axis\n    rd.yz *= Rot(PI * 10. / 180.); \n    \n    Surface d = rayMarch(ro, rd);\n    \n    // point hit by the ray\n    vec3 p = ro + rd * d.sd;\n    \n    // illumination at point p\n    float light_intensity = getLight(p, ro);\n    \n    // dark grey\n    // vec3 background_color = vec3(.2, .2, .2);\n    vec3 background_color = texture(iChannel0, uv*vec2(1.,2.)).rgb;\n    \n    // Antique White color #FAEBD7\n    vec3 surface_color = vec3(250, 235, 215) / 255.;\n    \n    // pixel color\n    vec3 color;\n    \n    if (d.sd < MAX_DIST) \n        // modulate surface color by the light intensity\n        color = d.col * vec3(light_intensity);\n    else \n        color = background_color;\n\n    // output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}