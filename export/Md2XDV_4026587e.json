{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"// Created by Sebastien Durand - 2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// To understand what it is, look at part \"Where is the Inside?\" at url:\n// http://eusebeia.dyndns.org/4d/vis/09-interp-1\n\n// less calcul and loop \n#define FAST \n\n//  0 nothing, 1 Cubinder, 2 Duo-Cylinder, 3 3-Sphere, 4 Tesseract,\n#define SHAPE 1\n\nconst float RAYON = .02;\nconst vec3 C1 = vec3(.2,.9,1), C2 = vec3(1,.3,.5);  // Colors for w coord\nconst vec3 E = vec3(0,.001,0); // epsilon\n\nvec3 L = normalize(vec3(.6, .7, .5)); // light\n\nmat4 B;\nfloat WCurrent;\n\n#ifdef FAST\nvec4 v0000,v1000,v0100,v0010,v0001,v1100,v1010,v1001;\n#endif\n\nfloat hash(in float x) {\n    return fract(sin(x * 171.2972) * 18267.978 + 31.287);\n}\n\nvec3 dmin(in vec3 v1, in vec3 v2) {\n    return v1.x<v2.x ? v1 : v2;\n}\n\nvec4 mv4D;\n\n// From 4D to 3D \nvec3 line4D(in vec3 p, vec4 p1, vec4 dp) {\n    p1+=mv4D;\n    //dp+=mv4D;\n \tvec3 pa = p-p1.xyz, ba = dp.xyz;\n    float k = clamp(dot(pa,ba)/dot(ba,ba),0., 1.);\n    return vec3(length(pa - ba*k) - RAYON ,k, p1.w +k*dp.w);\n}\n\n#ifdef FAST\n// FASTER like this but uggly and not working in firefox\nvec3 sdTesserac(in vec3 p) {\n     \n\tvec3 d;    \n        d = // 000\n            dmin(line4D(p, v0000, B[3]),\n\t\t\tdmin(line4D(p, v0000, B[2]),\n\t\t    dmin(line4D(p, v0000, B[1]), \n                 line4D(p, v0000, B[0]))));\n        d = dmin(d, // 100\n            dmin(line4D(p, v1000, B[3]),\n\t\t\tdmin(line4D(p, v1000, B[2]),\n\t\t    dmin(line4D(p, v1000, B[1]), \n                 line4D(p, v0100, B[0])))));\n        d = dmin(d, // 010\n            dmin(line4D(p, v0100, B[3]),\n\t\t\tdmin(line4D(p, v0100, B[2]),\n\t\t    dmin(line4D(p, v0010, B[1]), \n                 line4D(p, v0010, B[0])))));\n        d = dmin(d, // 110\n            dmin(line4D(p, v1100, B[3]),\n\t\t\tdmin(line4D(p, v1100, B[2]),\n\t\t    dmin(line4D(p, v1010, B[1]), \n                 line4D(p,-v1001, B[0])))));\n        d = dmin(d, // 001\n            dmin(line4D(p, v0010, B[3]),\n\t\t\tdmin(line4D(p, v0001, B[2]),\n\t\t    dmin(line4D(p, v0001, B[1]), \n                 line4D(p, v0001, B[0])))));\n        d = dmin(d, // 101\n            dmin(line4D(p, v1010, B[3]),\n\t\t\tdmin(line4D(p, v1001, B[2]),\n\t\t    dmin(line4D(p, v1001, B[1]), \n                 line4D(p,-v1010, B[0])))));\n        d = dmin(d, // 011\n            dmin(line4D(p,-v1001, B[3]),\n\t\t\tdmin(line4D(p,-v1010, B[2]),\n\t\t    dmin(line4D(p,-v1100, B[1]), \n                 line4D(p,-v1100, B[0])))));\n        d = dmin(d, // 111\n            dmin(line4D(p,-v0001, B[3]),\n\t\t\tdmin(line4D(p,-v0010, B[2]),\n\t\t    dmin(line4D(p,-v0100, B[1]), \n                 line4D(p,-v1000, B[0])))));    \n\treturn d;\n}\n#else\n// Tesserac projection (smartest but loop make it a little bit slower)\nvec3 sdTesserac(in vec3 p) {\n\tvec3 d = vec3(100.,-1.,0.);\n\tvec4 k = vec4(-.5);    \n\t// Simple initialisation of the 32 Edges of tesserac \n\tfor (int i=0; i<8; i++) {\n\t\tk.x = mod(float(i),2.)-.5; k.y = mod(float(i/2),2.)-.5; k.z = mod(float(i/4),2.)-.5; \n        d = dmin(d,\n            dmin(line4D(p, B*k    ,  B[3]),\n\t\t\tdmin(line4D(p, B*k.xywz, B[2]),\n\t\t    dmin(line4D(p, B*k.xwyz, B[1]), \n                 line4D(p, B*k.wxyz, B[0])))));\n\t}\n\treturn d;\n} \n#endif\n\n// 4D box => Tesserac\nfloat sdBox(in vec4 p, in vec4 b) {\n  vec4 d = abs(p) - b;\n  return min(max(d.x,max(d.y,max(d.z,d.w))),0.) + length(max(d,0.));\n}\n\n// 3-sphere (4d hypersphere)\nfloat sdSphere( vec4 p, float s ) {\n    return length(p)-s;\n}\n\n// http://eusebeia.dyndns.org/4d/cubinder\nfloat sdCubinder(vec4 p, vec3 rh1h2) {\n\tvec3 d = abs(vec3(length(p.xz), p.y, p.w)) - rh1h2;\n\treturn min(max(d.x,max(d.y,d.z)),0.) + length(max(d,0.));\n}\n\n// http://eusebeia.dyndns.org/4d/duocylinder\nfloat sdDuoCylinder( vec4 p, vec2 r1r2) {\n  vec2 d = abs(vec2(length(p.xz),length(p.yw))) - r1r2;\n  return min(max(d.x,d.y),0.) + length(max(d,0.));\n}\n\n\n// x: distance, y : distance on segment, z : 4th dimension coord\nvec3 map(vec3 p) {\n    //p*=2.;\n  //  vec3 d1 = vec3(1000);\n  //  for (int u=0; u<4; u++) {\n  //  \tmv4D = B[u]; //vec4(1,0,0,0);\n//\t    d1 = dmin(d1,sdTesserac(p));\n //       mv4D = -B[u]; //vec4(1,0,0,0);\n//\t    d1 = dmin(d1,sdTesserac(p));\n//    }\n    mv4D = vec4(0);\n    return dmin(sdTesserac(p), vec3(\n#if SHAPE==0\n        999.,\n#elif SHAPE==1\n        sdCubinder(vec4(p,WCurrent)*B, vec3(.5-RAYON*.5)),\n#elif SHAPE==2 \n        sdDuoCylinder(vec4(p,WCurrent)*B, vec2(.5-RAYON*.5)),\n#elif SHAPE==3\n        sdSphere(vec4(p,WCurrent)*B, .5),\n#else        \n        sdBox(vec4(p,WCurrent)*B, vec4(.5-RAYON*.5)),\n#endif\n        -.1, WCurrent));\n}\n\n// Classical AO calculation\nfloat calcAO(in vec3 pos, in vec3 nor) {\n    float hr=.01, ao=.0, sca=1.;\n    for(int aoi=0; aoi<5; aoi++) {\n        ao += -(map(nor * hr + pos).x-hr)*sca;\n        sca *= .7;\n        hr += .05;\n    }\n    return clamp(1.-4.*ao, 0., 1.);\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, float k ) {\n    float res=1., t=.02, h=1.;\n    for(int i=0; i<38; i++ ) {\n        h = map(ro + rd*t).x;\n        res = min( res, k*h/t );\n\t\tt += clamp( h, .015, 1. );\n\t\tif( h<0.012 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvec3 normal(in vec3 p, in vec3 ray, in float t) {\n   // vec2 e = vec2(E.y, -E.y); \n   // return normalize(e.xyy * map(p + e.xyy).x + e.yyx * map(p + e.yyx).x + e.yxy * map(p + e.yxy).x + e.xxx * map(p + e.xxx).x);;\n\tfloat pitch = .2 * t / iResolution.x;\n    \n\tvec2 d = vec2(-1,1) * pitch;\n\n\tvec3 p0 = p+d.xxx; // tetrahedral offsets\n\tvec3 p1 = p+d.xyy;\n\tvec3 p2 = p+d.yxy;\n\tvec3 p3 = p+d.yyx;\n\t\n\tfloat f0 = map(p0).x;\n\tfloat f1 = map(p1).x;\n\tfloat f2 = map(p2).x;\n\tfloat f3 = map(p3).x;\n\t\n\tvec3 grad = p0*f0+p1*f1+p2*f2+p3*f3 - p*(f0+f1+f2+f3);\n\t//return normalize(grad);\t\n    // prevent normals pointing away from camera (caused by precision errors)\n\treturn normalize(grad - max(.0,dot (grad,ray ))*ray);\n}\n\n\n// Classical 3D to 2D rendering loop\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec4 mouse = iMouse.xwzy;\n\n\t// Configure camera\n\tvec2 r = iResolution.xy, \n         m = mouse.xy/r, \n         q = fragCoord.xy/r.xy, \n         p =q+q-1.;\n\tp.x *= r.x/r.y;\n    \n\tfloat j=.032, s=1., h = .1;\n\n    \n    WCurrent = clamp(2.*(mouse.w/iResolution.y)-1.,-.5,.7);\n\tvec3 c = vec3(.22,.26,.28);\n    float k = 0.;\n\n\t// Ray marching\n\n    if (q.x>.95) {\n        float w = 2.*(fragCoord.y/iResolution.y)-1.;\n        c = mix(C1,C2, .5+1.2*w);\n        k=1.-smoothstep(abs(w-WCurrent),-.003,.003);\n        \n    } else if (length(q-.5)<.4) {\n        \n        float hs = hash(4.+floor(10.+.15*iTime));\n\t\tfloat time = 1.*(15.+.5*iTime * hs + 10.2*hash(hs)); //+ .08*hash(iTime);;\n \n        // Rotation Matrix to apply to 4D objects\n        float aaa = 10.+time*1.4, bbb = 11.+time*1.65, ccc = 11.+time*1.32;\n        float c1 = cos(aaa), s1 = sin(aaa), \n              c2 = cos(bbb), s2 = sin(bbb), \n              c3 = cos(ccc), s3 = sin(ccc);\t\n        \n        B = mat4(c2,  s2*s3,   0, -s2*c3,   \n      \t\t\t  0,  c1*c3, -s1,  c1*s3,\n      \t\t\t  0,  c3*s1,  c1,  s1*s3,\n       \t\t\t s2, -c2*s3,   0,  c2*c3);\n#ifdef FAST\n    \tv0000 = B*vec4(-.5,-.5,-.5,-.5);\n    \tv1000 = B*vec4( .5,-.5,-.5,-.5);\n    \tv0100 = B*vec4(-.5, .5,-.5,-.5);\n    \tv0010 = B*vec4(-.5,-.5, .5,-.5);\n    \tv0001 = B*vec4(-.5,-.5,-.5, .5);\n    \tv1100 = B*vec4( .5, .5,-.5,-.5);\n    \tv1010 = B*vec4( .5,-.5, .5,-.5);\n    \tv1001 = B*vec4( .5,-.5,-.5, .5);\n#endif\n       \tvec3 res,\n            o = 3.*normalize(vec3(cos(time+4.*m.x), c1, s1*sin(time+4.*m.x))),\n             w = normalize(-o),\n        \t u = normalize(cross(w, vec3(0,1,0))), v = cross(u, w),\n         \t d = normalize(p.x * u + p.y * v + w+w), n, x;\n\n\t\tfloat t=0.;\n        \n        for(int i=0;i<56;i++) { \n            if (h<.003 || t>4.) break;\n            t += h = map(o+d*t).x;\n        }\n        // Rendering    \n        if (h <= .003) {\n            x = o + t * d;\n            res = map(x);\n            n = normal(x, d,t);\n\n            // Calculate Shadows\n          //  s = softshadow(x, L, 32.); // faster with soft shadow but need to find good params \n            float h;\n            for(int i=0;i<30;i++){\n                h = map(x+L*j).x;\n                j += clamp( h, .032, 1. );\n               \ts = min(s, h/j);\n             \tif(j>7.|| h<.001) break;\n            } \n            float ao= calcAO(x, n);\n            // Teserac color\n            vec3 co = (mod(res.y,.25)>.1?.7:1.) * mix(C1,C2, .5+1.2*res.z); \n            co*=ao;\n            if (res.y >= 0.)  k=1.-smoothstep(abs(res.z-WCurrent),-.002,.002);\n            // Shading\n            c = mix(c, mix(sqrt((clamp(3.*s,0.,1.)+.3)*co), vec3(pow(max(dot(reflect(L,n),d),0.),99.)),.4),2.*dot(n,-d));\n        } \n    }\n    \n\tvec4 col = vec4(c+vec3(2,2,.8)*k,1);\n   \n    if (q.x<.95) {\n    \tcol *= pow(16.0*q.x*q.y*(1.-q.x)*(1.-q.y),.3);\n    }\n    \n    fragColor = col;\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Md2XDV","date":"1416262577","viewed":2770,"name":"Tesseract Wireframe vs 3D slice","username":"iapafoto","description":"[Mouse] Y pos => the w coord part of 4D tesserac which is a 3D shape :)  (3D slice of the 4D shape) \nPause anim to understand !  :)  Color indicates location in 4th dimension (w coord)\n#define to change SHAPE to test it with other 4D classical geometries","likes":64,"published":1,"flags":0,"usePreview":0,"tags":["wireframe","4d","slice","tesseract","hypercube"],"hasliked":0,"parentid":"","parentname":""}}