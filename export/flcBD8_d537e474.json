{"ver":"0.1","info":{"id":"flcBD8","date":"1694505996","viewed":76,"name":"WoS GBC Solver","username":"Reynolds","description":"Solving generalized barycentric coordinates using very janky implementation of Walk on Spheres.","likes":3,"published":1,"flags":48,"usePreview":0,"tags":["barycentric","harmonic","coordinate","gbc","wos","walkonspheres","generalizedbarycentriccoordinates"],"hasliked":0,"parentid":"wlyczh","parentname":"GBC solver"},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdSegment(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p-a, ba = b-a;\n    float A = dot(pa,ba)/dot(ba,ba);\n    float h = clamp( A, 0.0, 1.0 );\n\n    return length( pa - ba*h);\n}\n\nfloat sdScene(vec2 p) {\n\n    vec2 A = vec2(0.25, 0.25);\n    vec2 B = vec2(0.75, 0.25);\n    vec2 C = vec2(0.75, 0.75);\n    vec2 D = vec2(0.55, 0.75);\n    vec2 E = vec2(0.55, 0.45);\n    vec2 F = vec2(0.35, 0.45);\n    vec2 G = vec2(0.35, 0.75);\n    vec2 H = vec2(0.25, 0.75);\n\n    float d = sdSegment(p, A, B);\n    d = min(d, sdSegment(p, B, C));\n    d = min(d, sdSegment(p, C, D));\n    d = min(d, sdSegment(p, D, E));\n    d = min(d, sdSegment(p, E, F));\n    d = min(d, sdSegment(p, F, G));\n    d = min(d, sdSegment(p, G, H));\n    d = min(d, sdSegment(p, H, A));\n    \n    return d;\n}\n\nvec3 cMap(float u) {\n    u = floor(u * 20.0) / 20.0;\n\n    vec3 A = mix(vec3(0.0, 0.0, 1.0), 1.5*vec3(0.0, 1.0, 0.0), u);\n    vec3 B = mix(1.5*vec3(0.0, 1.0, 0.0), vec3(1.0, 0.0, 0.0), u);\n    return mix(A, B, u);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 col = texture(iChannel0, uv);\n    \n    vec3 C = cMap(col.x);\n    \n    if(sdScene(uv) < 0.002) {\n        fragColor = vec4(1.0);\n    } else {\n        fragColor = vec4( C, 1.0);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define coord 4\n#define iterations 64\n#define steps 32\n#define eps 0.001\n\nvec2 sdSegment(vec2 p, vec2 a, vec2 b, int i)\n{\n    vec2 pa = p-a, ba = b-a;\n    float A = dot(pa,ba)/dot(ba,ba);\n    float h = clamp( A, 0.0, 1.0 );\n    vec2 n = vec2(-ba.y, ba.x);\n    vec3 coords;\n    float tt = fract(iTime/2.0);\n    int q = int(floor(iTime/2.0));\n    int r = q + 1;\n    \n    float B = clamp(dot(pa, normalize(ba)) / length(ba), 0.0,1.0);\n\n    float c = 0.0;\n    if(i == coord) {\n        c = B;\n    } else if( (i-1 + 8) % 8 == coord) {\n        c = 1.0 - B;\n    }\n\n    return vec2(length( pa - ba*h), c);\n}\n\nvec2 minA(vec2 d, vec2 e) {\n    return mix(d, e, float(d.x > e.x));\n}\n\n//I don't remember where I got this from.\nfloat hash(vec2 p)\n{\n    // Two typical hashes...\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 sdScene(vec2 p) {\n\n    vec2 A = vec2(0.25, 0.25);\n    vec2 B = vec2(0.75, 0.25);\n    vec2 C = vec2(0.75, 0.75);\n    vec2 D = vec2(0.55, 0.75);\n    vec2 E = vec2(0.55, 0.45);\n    vec2 F = vec2(0.35, 0.45);\n    vec2 G = vec2(0.35, 0.75);\n    vec2 H = vec2(0.25, 0.75);\n\n    vec2 d = sdSegment(p, A, B, 0);\n    d = minA(d, sdSegment(p, B, C, 1));\n    d = minA(d, sdSegment(p, C, D, 2));\n    d = minA(d, sdSegment(p, D, E, 3));\n    d = minA(d, sdSegment(p, E, F, 4));\n    d = minA(d, sdSegment(p, F, G, 5));\n    d = minA(d, sdSegment(p, G, H, 6));\n    d = minA(d, sdSegment(p, H, A, 7));\n   \n    return d;\n}\n\nfloat c_pi = 3.14159;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float c = 0.0;\n    \n    for(int j = 0; j < iterations; ++j) {\n    \n        vec2 sol;\n        vec2 x = uv;\n        \n        for(int i = 0; i < steps; ++i) {\n        \n            sol = sdScene(x);\n            if(sol.x < eps)\n                 break;\n                 \n            float angle = hash(x.xy * iTime) * 2.0 * c_pi;\n            vec2 direction = vec2(cos(angle), sin(angle));\n\n            x = x + direction * sol.x;\n        }\n        \n        c += sol.y;\n    }\n    \n    //stole this part from demofox https://www.shadertoy.com/view/wtSyWm\n    bool spacePressed = (texture(iChannel1, vec2(32.5/256.0, 0.25)).x > 0.1);  \n    \n    vec4 colA = texture(iChannel0, uv);\n    float blend = (iFrame < 2 || spacePressed) ? 1.0 : 1.0 / (1.0 + (1.0 / colA.a));\n    \n    vec3 thisCol = vec3(c/float(iterations));\n    \n    vec3 newColor = mix(colA.rgb, thisCol, blend);\n    \n    fragColor = vec4(newColor, blend);\n}","name":"Buffer B","description":"","type":"buffer"}]}