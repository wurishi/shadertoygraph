{"ver":"0.1","info":{"id":"MlG3zW","date":"1473450143","viewed":391,"name":"Reflective kifs","username":"stduhpf","description":"A basic kaleidoscopic fractal with some reflections.\nYou can play with the rotation axis and the shape in the defines.","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["3d","fractal","reflections"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define fr_it 8\n\n#define axis vec3(2,1,.0)\n\n#define mainshape vec3(.2)\n\n#define scaling vec3(2)\n\n#define cubesize .05\n\n#define speed .2\n\n#define camera_distance 2.\n#define pseudo_fov .75\n#define viewdist 5.\n\n#define prec .00001\n#define raymaxit 200\n\n#define use_ao\n//#define show_ao\n\nmat3 r(float a, vec3 m)\n{\n    m= normalize(m);\n    float c = cos(a),s=sin(a);\n    return mat3(c+(1.-c)*m.x*m.x,\n                (1.-c)*m.x*m.y-s*m.z,\n                (1.-c)*m.x*m.z+s*m.y,\n                (1.-c)*m.x*m.y+s*m.z,\n                c+(1.-c)*m.y*m.y,\n                (1.-c)*m.y*m.z-s*m.x,\n                (1.-c)*m.x*m.z-s*m.y,\n                (1.-c)*m.y*m.z+s*m.x,\n                c+(1.-c)*m.z*m.z);\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nvec2 map(vec3 p)\n{\n    float t = iTime*speed;\n    vec3 m =axis;\n    vec3 s =mainshape;\n    mat3 rot=r(t,m);\n    for(int i =0;i<fr_it;i++)\n    {\n        p= abs(p)-s;\n        p*=rot;\n        s/=scaling;\n      }\n return vec2(udBox(p,vec3(cubesize)),1) ;    \n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(.001,0);\n    vec3 n=  vec3 (map(p+e.xyy).x-map(p-e.xyy).x,map(p+e.yxy).x-map(p-e.yxy).x,map(p+e.yyx).x-map(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec4 intersect(vec3 ro, vec3 rd,float n)\n{\n    float f=0.;\n    float t = 0.;\n    float g=0.;\n    float d = 0.;\n    bool hit = true;\n    for(int i = 0; i <raymaxit; i++)\n    {\n        vec2 h = map(ro+f*rd);\n            if(h.x<prec)\n            {\n                hit=false;\n                vec3 n = normal(ro+f*rd);\n                ro = ro+(f-g)*rd;\n                rd = reflect(rd,n);\n                f=0.;\n            }\n               \tif(t > n)\n           break;\n        g=h.x;\n            f+=g;\n        t+=g;\n        if (hit)d=f;\n    }\n    return vec4(d,rd);\n}\n\n\n\n\nfloat ao(vec3 p, vec3 n,float d)\n{\n    float h = map(p+d*n).x;\n    return d/(d+(d-h));\n}\n\n\n\n\nvoid mainImage( out vec4 fcol, in vec2 fragCoord )\n{\t\n    vec2 uv = fragCoord.xy / iResolution.x- vec2(.5,.5+(iResolution.y-iResolution.x)/(2.*iResolution.x));\n    vec2 mse =iMouse.xy/iResolution.x-vec2(.5,.5+(iResolution.y-iResolution.x)/(2.*iResolution.x));\n    mse*=8.;\n    if(iMouse.xy==vec2(0))\n        mse*=0.;\nmat3 rdroty = mat3(1,0,0,0,cos(mse.y),sin(mse.y),0,-sin(mse.y),cos(mse.y));\nmat3 rdrotx = mat3(cos(mse.x),0,sin(mse.x),0,1,0,-sin(mse.x),0,cos(mse.x));\n\n    vec3 ro = vec3(0,0,-camera_distance)*rdroty*rdrotx;\n    vec3 rd = normalize(vec3(uv,pseudo_fov))*rdroty*rdrotx;\n    float m =1.;\n    vec4 i = intersect(ro,rd,viewdist);\n    \n    #ifdef use_ao\n    if(i.x<viewdist)\n    {\n    vec3 pos = ro+i.x*rd;\n    vec3 nor = normal(pos); \n    float amb =ao(pos,nor,.03);//cheap fake ambiant occlusion\n        m=amb;\n    }\n    #endif\n    rd = i.gba;\n   \n    vec3 col = m*texture(iChannel0,-rd).rgb;\n #ifdef show_ao\n    col = vec3(m);\n    #endif\n    fcol = vec4(col,m);\n}","name":"Image","description":"","type":"image"}]}