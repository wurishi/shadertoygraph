{"ver":"0.1","info":{"id":"cdXGD2","date":"1666790596","viewed":188,"name":"Raytracing - Mouse click test","username":"bittermandel","description":"Raytracer with mouse click intersection working","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_FLOAT 1e5\n#define SAMPLES_PER_PIXEL 100.\n\nvec3 rayColor(Ray ray)\n{\n    vec3 unitDirection = normalize(ray.direction);\n    \n    float t = 0.5 * (unitDirection.y + 1.0);\n    \n    return (1.0 - t) * vec3(1.0) + t*vec3(0.5, 0.7, 1.0);\n}\n\nbool raycast(const in Ray r, inout Hit h, inout Sphere[2] spheres)\n{\n    bool didHit = false;\n    float t_max = MAX_FLOAT;\n    \n    didHit = hit(r, spheres[1], 0.00001, t_max, h) || didHit;\n    if (didHit)\n    {\n        float t_max = h.t;\n    }\n    didHit = hit(r, spheres[0], 0.00001, t_max, h) || didHit;\n    \n    return didHit;\n}\n\nbool raycastIndex(const in Ray r, out int index, inout Hit h, inout Sphere[2] spheres)\n{\n    bool didHit = false;\n    float t_max = MAX_FLOAT;\n    \n    bool sphere2Hit = hit(r, spheres[1], 0.00001, t_max, h) || didHit;\n    if (sphere2Hit)\n    {\n        float t_max = h.t;\n        index = 1;\n        didHit = true;\n    }\n    bool sphere1Hit = hit(r, spheres[0], 0.00001, t_max, h);\n    if (sphere1Hit)\n    {\n        float t_max = h.t;\n        index = 0;\n        didHit = true;\n    }\n    \n    return didHit;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    Camera camera = makeCamera(iResolution);\n\n    vec3 col;\n    \n    Sphere spheres[] = Sphere[](\n        Sphere(vec3(0.0 + sin(iTime), 0.0, -1.0), 0.5, vec3(1.0, 0.0, 0.0)),\n        Sphere(vec3(0.0, -100.5, -1.0), 100.0, vec3(0.0, 1.0, 0.0))\n    );\n    \n    if (iMouse.z>0.0)\n    {\n   \n        Ray r = Ray(camera.origin, normalize(camera.lowerLeftCorner + m.x * camera.horizontal + m.y * camera.vertical - camera.origin));\n        Hit h;\n        \n        int index;\n        bool didHit = raycastIndex(r, index, h, spheres);\n\n        // Output to screen\n        if (didHit)\n        {\n            spheres[index].color = vec3(1.0, 1.0, 1.0);\n        }\n    }\n\n    for (float s = 0.0; s < SAMPLES_PER_PIXEL; ++s)\n    {\n        Ray r = Ray(camera.origin, normalize(camera.lowerLeftCorner + uv.x * camera.horizontal + uv.y * camera.vertical - camera.origin));\n\n        Hit h;\n\n        bool didHit = raycast(r, h, spheres);\n\n\n        // Output to screen\n        if (didHit)\n        {\n            col += h.color;\n        }\n        else\n        {\n            col += rayColor(r);\n        }\n    }\n    \n    float scale = 1.0 / SAMPLES_PER_PIXEL;\n    col = col * scale;\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.1415926535897932385\n// Î¦ = Golden Ratio\n#define PHI 1.61803398874989484820459\n#define TAU 2. * PI\n\nfloat g_seed = 0.25;\n\n// UTILS\nfloat random (vec2 st) {\n     return fract(tan(distance(st*PHI, st)*g_seed)*st.x);\n}\n\nvec2 random2(float seed){\n  return vec2(\n    random(vec2(seed-1.23, (seed+3.1)* 3.2)),\n    random(vec2(seed+12.678, seed - 5.8324))\n    );\n}\n\nvec3 random3(float seed){\n  return vec3(\n    random(vec2(seed-0.678, seed-0.123)),\n    random(vec2(seed-0.3, seed+0.56)),\n    random(vec2(seed+0.1234, seed-0.523))\n    );\n}\n\nvec3 randomInUnitSphere( float seed) {\n  vec2 tp = random2(seed);\n  float theta = tp.x * TAU;\n  float phi = tp.y * TAU;\n  vec3 p = vec3(sin(theta) * cos(phi), sin(theta)*sin(phi), cos(theta));\n\n  return normalize(p);\n}\n\nvec3 random_unit(float seed){\n    vec2 rand = random2(seed);\n    float a = rand.x * TAU;\n    float z = (2. * rand.y) - 1.;\n    float r = sqrt(1. - z*z);\n    return vec3(r*cos(a), r*sin(a), z);\n}\n\n\n// RAY\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nvec3 rayAt(Ray ray, float t)\n{\n    return ray.origin + t*ray.direction;\n}\n\n// CAMERA\n\nstruct Camera {\n    vec3 origin, lowerLeftCorner, horizontal, vertical;\n};\n\nCamera makeCamera(vec3 iResolution)\n{\n    float h = 2.0;\n    float aspectRatio = iResolution.x / iResolution.y;\n    float w = h * aspectRatio;\n\n    vec3 origin = vec3(0);    \n    \n    vec3 horizontal = vec3(w, 0, 0);\n    vec3 vertical = vec3(0, h, 0);\n    \n    vec3 lowerLeftCorner = origin - horizontal/2.0 - vertical/2.0 - vec3(0.0, 0.0, 1.0);\n\n    return Camera(origin, lowerLeftCorner, horizontal, vertical);\n}\n\n// GEOMETRY\n\nstruct Sphere\n{\n    vec3 center;\n    float radius;\n    vec3 color;\n};\n\n// INTERSECTIONS\n\nstruct Hit\n{\n    float t;\n    vec3 point;\n    vec3 normal;\n    bool frontFace;\n    vec3 color;\n};\n\nbool hit(Ray r, Sphere sphere, float t_min, float t_max, inout Hit rec)\n{\n    vec3 oc = r.origin - sphere.center;\n\n    float halfB = dot(oc, r.direction);\n    float c = dot(oc, oc) - sphere.radius*sphere.radius;\n\n    float discriminant = halfB*halfB - c;\n    \n    if (discriminant < 0.0)\n    {\n        return false;\n    }\n\n    float sqrtd = sqrt(discriminant);\n    \n    float t1 = -halfB - sqrtd;\n    float t2 = -halfB + sqrtd;\n    \n    float t = t1 < 0.001 ? t2 : t1;\n    if (t < t_min || t > t_max)\n    {\n        return false;\n    }\n\n    vec3 p = rayAt(r, t);\n        \n    vec3 normal = p - sphere.center;\n\n    bool frontFace = dot(r.direction, normal) > 0.0;\n\n    normal = frontFace ? -normal : normal;\n    normal /= sphere.radius;\n    \n    rec = Hit(t, p, normal, frontFace, sphere.color);\n    \n    return true;\n}\n","name":"Common","description":"","type":"common"}]}