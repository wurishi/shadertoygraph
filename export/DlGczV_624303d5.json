{"ver":"0.1","info":{"id":"DlGczV","date":"1700425101","viewed":113,"name":"Ocean with Perlin Noise 2D","username":"SBYAgent","description":"~3","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["2d","perlinnoise","ocean"],"hasliked":0,"parentid":"dlVyDm","parentname":"Precise Perlin Noise"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 light = normalize(vec3(.6, .6, .2)); //Light Position/Vector\n\nconst vec3 shade = vec3 (0.2,0.4,0.65); //Initial color\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n//Calculating approximate normal vector, treating texel value as Z coordinate\n    float tex = texelFetch(iChannel0, ivec2(fragCoord), 0).x;\n    vec3 normal = normalize(cross(\n        vec3(1., 0., (texelFetchOffset(iChannel0, ivec2(fragCoord), 0, ivec2(1, 0)).x-tex)*50.),\n        vec3(0., 1., (texelFetchOffset(iChannel0, ivec2(fragCoord), 0, ivec2(0, 1)).x-tex)*50.)));\n//Calculating shadows and flares (a lot of weights and mixing to beautify result)\n    float LambertianDiff = mix(.63, .98, (dot(light, normal))*.9);\n    float Specular = mix(0., 1., dot(normalize(light+normalize(vec3(.5,.5,2.)-vec3(uv,tex))), normal));\n    \n    fragColor = vec4(shade*LambertianDiff+vec3(1.)*10.*max(0.,Specular-.95), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float speed = 2.4;\nconst vec2 OctN = vec2(3., 16.); //Lowest and Highest Octave\n\n//Hashing Function, returns vector\nvec2 HashVec (vec2 d){\n    return sin(58322.51*sin(vec2(dot(d+.01, vec2(123.4,234.5)),dot(d+.01, vec2(234.5,345.6))))+iTime*speed);\n}\n//Generates 1 Octave of Perlin Noise\nfloat Octave (vec2 uv, float GridSize){\n    vec2 GridUv = fract(uv*GridSize);\n    vec2 CellId = floor(uv*GridSize);\n    vec2 SmoothUv = smoothstep(0., 1., GridUv);\n//\n    return mix(mix(dot(HashVec(CellId + vec2(0., 0.)) ,GridUv - vec2(0., 0.)),\n                   dot(HashVec(CellId + vec2(1., 0.)) ,GridUv - vec2(1., 0.)), SmoothUv.x),\n               mix(dot(HashVec(CellId + vec2(0., 1.)) ,GridUv - vec2(0., 1.)),\n                   dot(HashVec(CellId + vec2(1., 1.)) ,GridUv - vec2(1., 1.)), SmoothUv.x),SmoothUv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float grad = 0.;\n    float i=1.;\n    for (i=OctN.x; i<=OctN.y; i++){\n        grad += (Octave(uv,pow(2., i))+0.5)/pow(2.,1.+i-OctN.x);\n    }\n\n    fragColor = vec4(grad, 0., 0., 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}