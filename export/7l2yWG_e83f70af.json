{"ver":"0.1","info":{"id":"7l2yWG","date":"1650217432","viewed":87,"name":"Sphere Raymarching 1","username":"TeamwinFTW","description":"First test in raymarching","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Z resolution and length\n\n#define STEPLENGTH 0.002\n#define VIEWDISTANCE 1.0\n\n#define BRIGHTNESS 15.0\n\n//Interpolation used when blending between cell corners\nfloat sineint (float x){\n\n   float sineval = (0.5+cos(x*3.14159)*0.5);\n   float floatval = 1.0-x;\n   float mixfac = 1.0;\n   \n   //return sineval,*mixfac + floatval*(1.0-mixfac);\n   return pow(1.0-x,1.3);\n\n}\n//Pseudo-RNG used to determine values at set points\nfloat PRNG2d(vec2 coord,float seed){\n\n    seed = mod(seed+ 0.01,100.0);\n    seed = seed/20.0;\n    coord = mod(coord,1000.0);\n    float x = mod(pow(coord.x,1.541523) * 0.1588235 + seed/20.65546689 + pow(coord.y * seed/8.51325,1.563) * 5.55464, 0.2)/0.2;\n    x = clamp(x,0.0,1.0);\n    x = mod(coord.x * 1.365448 * (seed/5.23648564) + coord.y * 2.21658+ x*2.05213,x)/x;\n    x = clamp(x,0.0,1.0);\n    x = mod(pow (coord.y + coord.x+2.5248,x)*20.0,1.0);\n    \n    return x;\n}\n\nfloat Noise(vec2 InputCoord, float seed, float scale)\n{\n\n    InputCoord = InputCoord*scale;\n    \n    //Cell corner positions\n    vec2 cor1 = vec2(floor(InputCoord.x),floor(InputCoord.y));\n    vec2 cor2 = vec2(ceil(InputCoord.x),floor(InputCoord.y));\n    vec2 cor3 = vec2(floor(InputCoord.x),ceil(InputCoord.y));\n    vec2 cor4 = vec2(ceil(InputCoord.x),ceil(InputCoord.y));\n    //Distances to Cell corners\n    float dist1 = distance(InputCoord,cor1);\n    float dist2 = distance(InputCoord,cor2);\n    float dist3 = distance(InputCoord,cor3);\n    float dist4 = distance(InputCoord,cor4);\n    //Values of cell corners\n    float val1 = PRNG2d(cor1,seed);\n    float val2 = PRNG2d(cor2,seed);\n    float val3 = PRNG2d(cor3,seed);\n    float val4 = PRNG2d(cor4,seed);\n    //Absolute weight of corners based on proximity \n    float weight1 = sineint(clamp(dist1,0.0,1.0));\n    float weight2 = sineint(clamp(dist2,0.0,1.0));\n    float weight3 = sineint(clamp(dist3,0.0,1.0));\n    float weight4 = sineint(clamp(dist4,0.0,1.0));\n    \n    //Factor used to trim weights to add to 1.0\n    float TrimFactor = 1.0/(weight1 + weight2 + weight3 + weight4);\n    //TrimFactor = 1.0;\n    float value = val1*weight1*TrimFactor + val2*weight2*TrimFactor + val3*weight3*TrimFactor + val4*weight4*TrimFactor;\n    return value;   \n}\n\nvec3 SphereNormal (vec3 InputCoord, vec3 ObjectCoord, float Radius){\n    \n    float dist = distance(InputCoord,ObjectCoord);\n    float iscollided = float(dist < Radius);\n    vec3 norm = normalize(InputCoord-ObjectCoord);\n    \n    return vec3(norm*iscollided);\n\n}\nvec3 BevelCube (vec3 InputCoord, vec3 ObjectCoord, float size, float bevel){\n    \n    float beveledsize = size*0.5-bevel;\n    vec3 localcoord = InputCoord - ObjectCoord;\n    vec3 clampedcoord = clamp(localcoord,-1.0*beveledsize,beveledsize);\n    float dist = distance(clampedcoord, localcoord);\n    vec3 norm = normalize(localcoord-clampedcoord+ vec3(0.0,0.01,0.0));\n    \n    return (norm) * float(dist<=bevel);\n\n}\nvec3 lighting(vec3 normals, vec3 lightdir, vec3 color, float roughness)\n{\n    vec3 Output = color;\n    vec3 reflecVec = reflect(vec3(0.0,0.0,1.0),normals);\n    lightdir = normalize(lightdir)*float(lightdir!=vec3(0.0,0.0,0.0));\n    \n    Output = color*dot(normals,lightdir)*roughness;\n    Output += (1.0-roughness)* pow(clamp(dot(lightdir,reflecVec),0.0,1.0),1.0/roughness);\n    \n    return max(Output,0.0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 evenUV = uv*2.0-1.0;\n    \n    evenUV = vec2(evenUV.x*(iResolution.x/iResolution.y),evenUV.y);\n    \n    float zdepth = 0.0;\n    \n    vec3 SphereCoord = vec3(0.0,0.0,0.6);\n    \n    vec3 norm = vec3(0.0,0.0,0.0);\n    float i;\n    for (i=0.0 ; i<(float(VIEWDISTANCE) / STEPLENGTH);i++){\n        \n        norm = norm + vec3(zdepth==0.0)*(BevelCube(vec3(evenUV,i*STEPLENGTH),SphereCoord,1.0,abs(sin(iTime*0.5)/4.0)));\n            \n        zdepth = zdepth + (float(norm!=vec3(0.0,0.0,0.0))*i*STEPLENGTH*float(zdepth==0.0));\n        \n        \n    }\n    //norm = normalize(vec3(0.0,0.0,-0.1));\n    vec3 col;\n    vec3 color = vec3(0.5,1.0,1.0);\n    vec2 evenMouse = iMouse.xy*2.0/iResolution.xy-1.0;\n    color = vec3(Noise(evenMouse,1.0,4.0),Noise(evenMouse,2.0,4.0),Noise(evenMouse,3.0,4.0));\n    color = color*BRIGHTNESS;\n    vec3 lightdir = normalize(vec3(evenMouse,distance(evenMouse,vec2(0.0))-0.4));\n    col = (vec3(0.1)+lighting(norm,lightdir,color,0.1))*float(zdepth!=0.0) ;\n    //+ float(zdepth==0.0)*(Noise(vec2(evenUV.y,evenUV.x*0.03),6.0,8.0)*0.8)*vec3(0.8,1.0,1.0);\n    \n    //col = SphereNormal(vec3(evenUV,iTime),SphereCoord,0.5);\n    //fragColor = vec4(reflect(vec3(0.0,0.0,1.0),norm),1.0);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}