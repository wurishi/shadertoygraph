{"ver":"0.1","info":{"id":"cdsGD4","date":"1666160052","viewed":163,"name":"3D Quadratic Bezier w/ Normals 2","username":"myth0genesis","description":"Just adapting iq's Quadratic Bezier - gradient 2D [url]https://www.shadertoy.com/view/DdlGD8[/url] to 3D. My deepest apologies to him for not having faith in his massive intellect :)","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","ray","raymarch","raymarched","bezier","normals","marching","curve","normal","quadratic","analytic","march","marched"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// All credit due to iq https://www.shadertoy.com/view/DdlGD8\n// I took the liberty of making it branchless\n// and extending it to 3D\n#define AA 2\n\nconst int maxstps = 100;\nconst float maxdst = 100.0;\nconst float mindst = 0.001;\nconst float pi = 3.1415927410125732421875;\nconst float tau = 6.283185482025146484375;\nconst float i3 = 1.0 / 3.0;\nconst float sqrt3 = sqrt(3.0);\n\n// res.x = distance\n// res.yzw = xyz normals\nvec4 sdBezier( in vec3 pos, in vec3 A, in vec3 B, in vec3 C ) {\n    vec3 a = B - A;\n    vec3 b = A - 2.0 * B + C;\n    vec3 c = a * 2.0;\n    vec3 d = A - pos;\n    \n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a, b);\n    float ky = kk * (2.0 * dot(a, a) + dot(d, b)) * i3;\n    float kz = kk * dot(d, a);\n    \n    float p  = ky - kx * kx;\n    float q  = kx * (2.0 * kx * kx - 3.0 * ky) + kz;\n    float p3 = p * p * p;\n    float h  = q * q + 4.0 * p3;\n    bool tsth = h >= 0.0;\n    h = sqrt(h);\n    float k = p3 / q;\n    bool tstp = abs(p) < 0.01;\n    vec2 x = float(!tstp) * (vec2(h, -h) - q) * 0.5 + float(tstp) * vec2(k, -k - q);\n    vec2 uv = sign(x) * pow(abs(x), vec2(i3));\n    float t1 = clamp(uv.x + uv.y - kx, 0.0, 1.0);\n    vec3  qv3 = d + (c + b * t1) * t1;\n    float z = sqrt(-p);\n    float v = acos(q / (p * z * 2.0)) * i3;\n    float m = cos(v);\n    float n = sin(v) * sqrt3;\n    vec2 t2 = clamp(vec2(m + m, -n - m) * z - kx, 0.0, 1.0);\n    vec3  qx = d + (c + b * t2.x) * t2.x;\n    float dx = dot(qx, qx);\n    vec3  qy = d + (c + b * t2.y) * t2.y;\n    float dy = dot(qy, qy);\n    bool tstdxy = dx < dy;\n    vec4 res = float(tsth) * vec4(dot(qv3, qv3), qv3)\n        + float(!tsth) * (float(tstdxy) * vec4(dx, qx) + float(!tstdxy) * vec4(dy, qy));\n    \n    res.x = sqrt(res.x);\n    res.yzw /= -res.x;\n    \n    return res;\n}\n\nvec4 map(vec3 pos) {\n    vec3 f = vec3(1.2133, 1.4763, 1.0);\n    vec3 offs = vec3(0.1, 2.5, 3.7);\n    vec3 amp = vec3(3.0, 3.1, 2.9);\n    vec3 a = vec3(-4.5, 0.0, 0.0);\n    vec3 b = sin(iTime * f + offs) * amp;\n    vec3 c = vec3(4.5, 0.0, 0.0);\n    \n    vec4 d = sdBezier(pos, a, b, c);\n    d.x -= 0.5;\n    return d;\n}\n\nmat2 rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s,\n                s,  c);\n}\n\nvec4 rayMarch(vec3 ro, vec3 rd) {\n\tfloat dO = 0.0;\n    vec4 res;\n    \n    for(int i = 0; i < maxstps; i++) {\n    \tvec3 p = ro + rd * dO;\n        res = map(p);\n        float dS = res.x;\n        dO += dS;\n        if(dO > maxdst || abs(dS) < mindst) break;\n    }\n    \n    return vec4(dO, res.yzw);\n}\n\nvec3 getRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3\n        f = normalize(l - p),\n        r = normalize(cross(vec3(0.0, 1.0, 0.0), f)),\n        u = cross(f, r),\n        c = f * z,\n        i = c + uv.x * r + uv.y * u;\n    return normalize(i);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 m = iMouse.xy / iResolution.xy;\n    \n    vec3 ro = vec3(0.0, 3.0, -7.0);\n    ro.yz *= rot(-m.y * pi * 0.9 + 1.0);\n    ro.xz *= rot(-m.x * tau);\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    \n    for(int x = 0; x < AA; x++) {\n        for(int y = 0; y < AA; y++) {\n            vec2 offs = vec2(x, y)/float(AA) -.5;    \n            vec2 uv = (fragCoord + offs - 0.5 * iResolution.xy) / iResolution.y;\n            vec3 rd = getRayDir(uv, ro, vec3(0.0, 0.0, 0.0), 1.0);\n            \n            vec4 res = rayMarch(ro, rd);\n            \n            if(res.x < maxdst) {\n                vec3 p = ro + rd * res.x;\n                vec3 n1 = res.yzw;\n                vec3 n = n1;\n                \n                float dif = dot(n, normalize(vec3(1.0, 2.0, 3.0))) * 0.5 + 0.5;\n                col += vec3(dif) * vec3(0.4, 0.0, 0.8);\n            }\n        }\n    }\n    \n    col /= float(AA * AA);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}