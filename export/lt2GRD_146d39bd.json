{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// Lighting is done by Spherical Harmonics:\n// This one is a cheap variant presented in 2001 by Ravi Ramamoorthi\n// and Pat Hanrahan: http://graphics.stanford.edu/papers/envmap/\n// http://graphics.stanford.edu/papers/envmap/envmap.pdf\n// There's a C program (prefilter.c) provided to compute spherical harmonic\n// coefficients from light probe images (in the floating point format).\n// I used pvalue tool from Radiance package on my Ubuntu system to convert\n// angular light probe images in HDR format to floating point format with\n// the following command:\n// $ pvalue -df -H -h grace_probe.hdr > grace_probe.float\n// I then have slightly modified prefilter.c to output values with a factor\n// applied to have coefficients in a correct range (I used a factor of 0.315),\n// and ran the following command:\n// $ ./prefilter grace_probe.float 1000\n// You can read too the Orange Book, chapter 12.3 (OpenGL Shading Language\n// by Randi J. Rost), it has been very useful.\n\nstruct SHCoefficients {\n    vec3 l00, l1m1, l10, l11, l2m2, l2m1, l20, l21, l22;\n};\n\n// These constants have been calculated with a light probe from this website:\n// http://www.pauldebevec.com/Probes/\n// The light probe image used is Grace Cathedral.\nconst SHCoefficients grace = SHCoefficients(\n    vec3( 0.7953949,  0.4405923,  0.5459412 ),\n    vec3( 0.3981450,  0.3526911,  0.6097158 ),\n    vec3(-0.3424573, -0.1838151, -0.2715583 ),\n    vec3(-0.2944621, -0.0560606,  0.0095193 ),\n    vec3(-0.1123051, -0.0513088, -0.1232869 ),\n    vec3(-0.2645007, -0.2257996, -0.4785847 ),\n    vec3(-0.1569444, -0.0954703, -0.1485053 ),\n    vec3( 0.5646247,  0.2161586,  0.1402643 ),\n    vec3( 0.2137442, -0.0547578, -0.3061700 )\n);\n\nvec3 calcIrradiance(vec3 nor) {\n    const SHCoefficients c = grace;\n    const float c1 = 0.429043;\n    const float c2 = 0.511664;\n    const float c3 = 0.743125;\n    const float c4 = 0.886227;\n    const float c5 = 0.247708;\n    return (\n        c1 * c.l22 * (nor.x * nor.x - nor.y * nor.y) +\n        c3 * c.l20 * nor.z * nor.z +\n        c4 * c.l00 -\n        c5 * c.l20 +\n        2.0 * c1 * c.l2m2 * nor.x * nor.y +\n        2.0 * c1 * c.l21  * nor.x * nor.z +\n        2.0 * c1 * c.l2m1 * nor.y * nor.z +\n        2.0 * c2 * c.l11  * nor.x +\n        2.0 * c2 * c.l1m1 * nor.y +\n        2.0 * c2 * c.l10  * nor.z\n    );\n}\n\nvec3 spherePos = vec3(0.0, 1.0, 0.0);\nvec3 planePos = vec3(0.0, 0.05, 0.0);\nfloat sphereRadius = 1.0;\n\nfloat raytracePlane(in vec3 ro, in vec3 rd, float tmin, float tmax) {\n    vec3 p = ro - planePos;\n    float t = -p.y / rd.y;\n    if (t > tmin && t < tmax) {\n        return t;\n    }\n    return -1.0;\n}\n\nfloat raytraceSphere(in vec3 ro, in vec3 rd, float tmin, float tmax, float r) {\n    vec3 ce = ro - spherePos;\n    float b = dot(rd, ce);\n    float c = dot(ce, ce) - r * r;\n    float t = b * b - c;\n    if (t > tmin) {\n        t = -b - sqrt(t);\n        if (t < tmax)\n            return t;\n        }\n    return -1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n    vec3 eye = vec3(0.0, 2.0, 3.0);\n    vec2 rot = 6.2831 * (vec2(0.6 + iTime * 0.25, sin(iTime * 0.5) * 0.06) + vec2(1.0, 0.0) * (iMouse.xy - iResolution.xy * 0.25) / iResolution.x);\n    eye.yz = cos(rot.y) * eye.yz + sin(rot.y) * eye.zy * vec2(-1.0, 1.0);\n    eye.xz = cos(rot.x) * eye.xz + sin(rot.x) * eye.zx * vec2(1.0, -1.0);\n\n    vec3 ro = eye;\n    vec3 ta = vec3(0.0, 1.0, 0.0);\n\n    vec3 cw = normalize(ta - ro);\n    vec3 cu = normalize(cross(vec3(0.0, 1.0, 0.0), cw));\n    vec3 cv = normalize(cross(cw, cu));\n    mat3 cam = mat3(cu, cv, cw);\n\n    vec3 rd = cam * normalize(vec3(p.xy, 1.0));   \n\n    vec3 col = vec3(0.0);\n    vec3 nor;\n    float occ = 1.0;\n\n    float tmin = 0.1;\n    float tmax = 50.0;\n\n    // raytrace the plane\n    float tpla = raytracePlane(ro, rd, tmin, tmax);\n    if (tpla > tmin) {\n        vec3 ppos = ro + rd * tpla;\n        nor = normalize(vec3(0.0, 1.0, 0.0) + ppos);\n        vec3 d = spherePos - ppos;\n        float l = length(d);\n        occ = 1.0 - (dot(nor, d / l) * (sphereRadius * sphereRadius) / (l * l));\n    }\n\n    // raytrace the sphere\n    float tsph = raytraceSphere(ro, rd, tmin, tmax, sphereRadius);\n    if (tsph > tmin) {\n        vec3 spos = ro + rd * tsph;\n        nor = normalize(spos - spherePos);\n        occ = 0.5 + 0.5 * nor.y;\n    }\n\n    if (tpla > tmin || tsph > tmin) {\n        col = calcIrradiance(nor) * occ;\n\n        // distant fog if we don't hit the sphere\n        if (tsph < tmin) {\n            col = mix(col, vec3(0.0), 1.0 - exp(-0.001 * tpla * tpla));\n        }\n    }\n\n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lt2GRD","date":"1427388542","viewed":3852,"name":"Spherical Harmonics lighting","username":"jimmikaelkael","description":"Just testing cheap spherical harmonics lighting from Ravi Ramamoorthi and Pat Hanrahan. Their formula uses only 9 coefficients to compute irradiance.","likes":35,"published":1,"flags":0,"usePreview":0,"tags":["lighting","spherical","harmonics"],"hasliked":0,"parentid":"","parentname":""}}