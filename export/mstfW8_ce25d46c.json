{"ver":"0.1","info":{"id":"mstfW8","date":"1697162973","viewed":42,"name":"Rasterized line","username":"dimitr","description":"Line segment rasterization","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["dda","canvas"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // output\n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 lineColor = vec4(1.0f, 0.0f, 0.0f, 1.0f);\n    vec4 mouseColor = vec4(0.0f, 0.8f, 0.2f, 1.0f);\n    vec4 circleColor = vec4(0.3f, 0.0f, 0.7f, 1.0f);   \n   \n    vec4 pixelCell = getCell(fragCoord);\n    vec4 mouseCell = getCell(iMouse.xy);\n    vec4 originCell = getCell(iResolution.xy * 0.5f);\n       \n    float insideCell = isCellPixel(fragCoord);\n    float insideLine = isLinePixel(fragCoord, originCell.xy, mouseCell.xy);\n    float underMouse = isUnderMouse(fragCoord, iMouse.xy);\n    vec4 bgColor = insideCell * CANVAS_COLOR + (1.0f - insideCell) * GAP_COLOR;   \n    vec4 lineFilledColor = insideLine * lineColor;\n    bgColor *= (1.0f - insideLine);\n    lineFilledColor *= (1.0f - underMouse);\n    vec4 finalColor = bgColor + lineFilledColor + underMouse * mouseColor;\n    fragColor = finalColor * insideCell + (1.0f - insideCell) * GAP_COLOR;\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"vec4 CANVAS_COLOR = vec4(0.4f, 0.4f, 0.4f, 1.0f);\nvec2 CELL_SIZE = vec2(10.0f, 10.0f);\n\nvec4 GAP_COLOR = vec4(0.0f, 0.0f, 0.0f, 1.0f);\nvec2 GAP_SIZE = vec2(1.0f, 1.0f);\n\nvec4 DRAW_COLOR = vec4(0.0f, 0.8f, 0.2f, 1.0f);\n\nfloat vecEqual(vec2 v0, vec2 v1)\n{\n    vec2 v = v1 - v0;\n    float vDist = dot(v, v);\n    return float(vDist < 0.01f);\n}\n\nvec4 getCell( vec2 pixelFragCoord )\n{\n    vec2 fullCell = CELL_SIZE + GAP_SIZE;\n    vec2 cellIdx = floor(pixelFragCoord / fullCell);\n    vec4 cellBounds = vec4(0.0f, 0.0f, 1.0f, 1.0f); // just spaceholder\n    cellBounds.x = cellIdx.x * fullCell.x;\n    cellBounds.y = cellIdx.y * fullCell.y;\n    cellBounds.z = cellBounds.x + fullCell.x;\n    cellBounds.w = cellBounds.y + fullCell.y;\n    return cellBounds;\n}\n\nfloat isCellPixel( vec2 pixelFragCoord )\n{\n    vec4 cell = getCell(pixelFragCoord);\n    float insideCell = float(!(pixelFragCoord.x >= cell.z - GAP_SIZE.x || pixelFragCoord.y >= cell.w - GAP_SIZE.y));\n    return insideCell;\n}\n\nfloat isUnderMouse( vec2 pixelFragCoord, vec2 mousePixelCoord )\n{\n    vec4 pixelCell = getCell(pixelFragCoord);\n    vec4 mouseCell = getCell(mousePixelCoord);\n    return vecEqual(pixelCell.xy, mouseCell.xy) * isCellPixel(pixelFragCoord);\n}\n\nvec4 getCanvasColor( vec2 pixelFragCoord ) \n{\n    float insideCell = isCellPixel(pixelFragCoord);\n    return CANVAS_COLOR * insideCell + GAP_COLOR * (1.0f - insideCell);\n}\n\nvec4 getDrawnColor ( vec2 pixelFragCoord, vec2 mousePixelCoord )\n{\n    float insideCell = isCellPixel(pixelFragCoord);\n    float underMouse = isUnderMouse(pixelFragCoord, mousePixelCoord);\n    vec4 drawnColor = insideCell * (underMouse * DRAW_COLOR + (1.0f - underMouse) * CANVAS_COLOR) + (1.0f - insideCell) * GAP_COLOR;\n    return drawnColor;\n}\n\nfloat isLinePixel (vec2 pixelFragCoord, vec2 startCell, vec2 stopCell)\n{\n    // DDA\n    vec4 pixelCell = getCell(pixelFragCoord);\n    vec2 cellCenter = pixelCell.xy + CELL_SIZE * 0.5f;\n    vec2 v = (stopCell - startCell) / (CELL_SIZE + GAP_SIZE);\n    vec2 startCenter = startCell + CELL_SIZE * 0.5f;\n    vec2 stopCenter = stopCell + CELL_SIZE * 0.5f;\n    float insideLine = 0.0f;\n    vec2 enlargedStep = CELL_SIZE + GAP_SIZE;\n\n    if (abs(v.x) < 0.001f && abs(v.y) < 0.001f)\n    {\n        // just point\n        return vecEqual(pixelCell.xy, startCell);\n    }\n    if (abs(v.x) > abs(v.y))\n    {\n        // use tanQ\n        float tanQ = v.y / v.x;\n        float steps = floor(abs(v.x));\n        float stepSign = v.x / abs(v.x);\n        for (float i = 0.0f; i < steps + 0.001f; i += 1.0f)\n        {\n            float curX = i * enlargedStep.x * stepSign - GAP_SIZE.x * stepSign;\n            float curY = curX * tanQ;\n            vec2 curCoord = vec2(startCenter.x + curX, startCenter.y + curY);\n            vec4 curCell = getCell(curCoord);\n            insideLine += vecEqual(curCell.xy, pixelCell.xy);\n        }\n    }\n    else {\n        // use cotanQ\n        float cotanQ = v.x / v.y;\n        float steps = floor(abs(v.y));\n        float stepSign = v.y / abs(v.y);\n        for (float i = 0.0f; i < steps + 0.001f; i += 1.0f)\n        {\n            float curY = i * enlargedStep.y * stepSign - GAP_SIZE.y * stepSign;\n            float curX = curY * cotanQ;\n            vec2 curCoord = vec2(startCenter.x + curX, startCenter.y + curY);\n            vec4 curCell = getCell(curCoord);\n            insideLine += vecEqual(curCell.xy, pixelCell.xy);\n        }\n    }\n    return insideLine;\n}\n","name":"Common","description":"","type":"common"}]}