{"ver":"0.1","info":{"id":"ltscW8","date":"1504661698","viewed":755,"name":"Basic Raymarching - Viroids","username":"CaliCoastReplay","description":"Using my raymarcher on the viroid from :  http://www.michaelwalczyk.com/blog/2017/5/25/ray-marching .  Looks like plastic blood proteins.  My method seems to be useful for shiny materials.  EDIT:  Added colored lights!","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","abstract"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Learning from : http://www.michaelwalczyk.com/blog/2017/5/25/ray-marching\n\n//Contains some experimental terms to simulate global illumination\n//on backside of object via a variation\n//on specular highlights, and the use of Fresnel terms\n//for both light and shadow on the outside of objects.\n\n//Comments encouraged - code will be commented for teaching purposes soon.\n\n//--CaliCoastReplay\n\n//Returns the distance from a world point to a sphere defined by a center and radius.\n//Used in this example to \"map the world\" by returning distances to the viroid forms\n//from points along the marched rays.\nfloat distance_from_sphere(in vec3 world_point, in vec3 sphere_center, float radius)\n{\n    return length(world_point - sphere_center) - radius;\n}\n\n\t\n//Polynomial smooth minimum by Inigo Quilez.\n//Used in this case to \"join\" the two viroids into a metaball - a normal minimum would return\n//unjoined surface data.\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n//Distance to the closest world object from a given point p along the raymarcher.  \n//Used in this example to \"map the world\" - see above.\nfloat distance_to_closest_object(in vec3 p)\n{\n    \n    float sphere_0 = distance_from_sphere(p, vec3(-0.5 + cos(iTime), -0.5+cos(iTime), sin(iTime)), 2.0);    \n    float sphere_1= distance_from_sphere(p, vec3(.5+ sin(iTime), 0.5 + sin(iTime), cos(iTime)), 2.0);\n    \n    float displacement0 = sin(-3.0  * p.x) * sin(1.5 *  p.y) * sin(2.0 * p.z) * 0.25;\n    float displacement1 = cos(3.0 *   p.x) * cos(1.5 *  p.y) * cos(2.0 * p.z) * 0.5;\n\n    return smin(sphere_0 + displacement0, sphere_1 + displacement1, .7);\n   // return smin(sphere_0, sphere_1, .7);  //switch with this for simple spheres instead\n}\n\n//Estimates the normal vector (the vector perpendicular to the surface) at any given world point\n//representing a surface.  Should only be used at world points representing collisions.  Samples\n//the world at six more points bounding the world point along the three primary world axes (x, y, \n//and z) and then uses that data to estimate the normal there.\nvec3 calculate_normal(in vec3 world_point)\n{\n    const vec3 small_step = vec3(0.0025, 0.0, 0.0);\n\n    float gradient_x = distance_to_closest_object(world_point + small_step.xyy)\n        - distance_to_closest_object(world_point - small_step.xyy);\n    float gradient_y = distance_to_closest_object(world_point + small_step.yxy) \n        - distance_to_closest_object(world_point - small_step.yxy);\n    float gradient_z = distance_to_closest_object(world_point + small_step.yyx) \n        - distance_to_closest_object(world_point - small_step.yyx);\n\n    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\n\n    return normalize(normal);\n}\n\n//The actual raymarcher.  \"Marches\" a ray along a direction vector, starting at an eye/camera\n//point, by adding that direction vector to the origin, and repeating that until it either\n//hits something, travels a certain number of steps, or reaches a maximum distance.  If it hits\n//a surface, it calculates the surface normal at that point, and uses that normal to calculate\n//the lighting according to a modified Phong shading model.\nvec4 ray_march(in vec3 ray_origin, in vec3 ray_direction)\n{\n    float total_distance_traveled = 0.0;\n    const int NUMBER_OF_STEPS = 64;\n    const float MINIMUM_HIT_DISTANCE = 0.001;\n    const float MAXIMUM_TRACE_DISTANCE = 1000.0;\n\n    for (int i = 0; i < NUMBER_OF_STEPS; ++i)\n    {\n        vec3 current_position = ray_origin + total_distance_traveled * ray_direction;\n\t\tfloat distance_to_closest = distance_to_closest_object(current_position);\n        if (distance_to_closest < MINIMUM_HIT_DISTANCE) \n        {\n            vec3 normal = calculate_normal(current_position);\n            \n            vec3 light_positions[3];\n            light_positions[0] = vec3(1.0+sin(iTime)*5.0, -3.0+3.0*cos(iTime/3.0), 4.0 + 1.0 *sin(iTime/5.0));\n            light_positions[1] = vec3(1.0-sin(iTime/2.0)*2.0, -1.0-cos(iTime/2.0), 7.0 + 1.0 -sin(iTime/4.0));\n            light_positions[2] = vec3(2.0-sin(iTime/2.0)*2.0, -5.0-sin(iTime/4.0), 2.0 + 1.0 -sin(iTime/1.0));\n            vec3 light_intensities[3];\n            light_intensities[0] = vec3(0.8, 0.4, 0.4);\n            light_intensities[1] = vec3(0.04, 0.9, 0.2);\n            light_intensities[2] = vec3(0.1, 0.2, 0.8);\n            vec3 direction_to_view = normalize(current_position - ray_origin);float fresnel_base = 1.0 + dot(direction_to_view, normal);\n            float fresnel_intensity = 0.04*pow(fresnel_base, 2.0);\n            float fresnel_shadowing = pow(fresnel_base, 8.0);            \n            float fresnel_supershadowing = pow(fresnel_base, 40.0);      \n            float fresnel_antialiasing = 4.0*pow(fresnel_base, 8.0);\n            float attenuation =  pow(total_distance_traveled,2.0)/150.0;\n            \n            vec3 col = vec3(0.0);\n            \n            for (int j = 0; j < 3; j++)\n            {\n                vec3 direction_to_light = normalize(current_position - light_positions[j]);\n                vec3 light_reflection_unit_vector =\n                \t reflect(direction_to_light ,normal);                \n\n                float diffuse_intensity = 0.6*pow(max(0.0, dot(normal, direction_to_light)),5.0);            \n                float ambient_intensity = 0.2;            \n                float specular_intensity = \n                    1.15* pow(clamp(dot(direction_to_view, light_reflection_unit_vector), 0.0,1.0), 90.0);\n                float backlight_specular_intensity =             \n                    0.01* pow(clamp(dot(direction_to_light, light_reflection_unit_vector),0.0,1.0), 3.0); \n                \n                \n            \tvec3 colFromLight = vec3(0.0);\n                colFromLight += vec3(0.89, 0.35, 0.15) * diffuse_intensity;\n                colFromLight += vec3(0.3, 0.1, 0.1) * ambient_intensity;\n                colFromLight += vec3(1.0) * specular_intensity;            \n                colFromLight += vec3(1.0,0.5,0.5) * backlight_specular_intensity;            \n                colFromLight += vec3(1.0, 0.1, 0.2) * fresnel_intensity;\n                colFromLight -= vec3(0.0, 1.0, 1.0) * fresnel_shadowing ;\n                colFromLight -= vec3(0.0, 1.0, 1.0) * fresnel_supershadowing ;\n                colFromLight += vec3(.3, 0.1, 0.1) - attenuation ; \n               //\tcolFromLight *= 1.6;\n               // colFromLight *= sqrt(light_intensities[j]);\n                col += colFromLight;\n            }\n            return vec4(col, 1.0-fresnel_antialiasing);\n        }\n\n        if (total_distance_traveled > MAXIMUM_TRACE_DISTANCE)\n        {\n            break;\n        }\n        total_distance_traveled += distance_to_closest;\n    }\n    return vec4(0.0);\n}\n\n//The final image shader, taking in the screen coordinate and outputting color.  \n//Uses an eye (camera) position as the ray origin, then uses a look-at point\n//and a camera projection matrix to find the ray direction corresponding to the\n//screen coordinate.  Passes that ro/rd to the raymarcher to get the color at that point.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (-iResolution.xy + 2.0*fragCoord) / iResolution.y;\n\n     // camera movement\t\n\tfloat time_factor = 0.5*iTime;\n\tvec3 camera_position = vec3( 7.0*cos(time_factor), 0.4, 7.0*sin(time_factor));\n    vec3 ray_origin = camera_position;    \n    vec3 look_at = vec3( 0.0, sin(time_factor), 0.0 );\n    // camera matrix\n    vec3 ww = normalize( look_at - ray_origin );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 ray_direction = normalize( uv.x*uu + uv.y*vv + 1.5*ww );\n    \n    vec4 shaded_color = ray_march(ray_origin, ray_direction);\n\n    fragColor = vec4(shaded_color);\n}","name":"Image","description":"","type":"image"}]}