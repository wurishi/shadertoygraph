{"ver":"0.1","info":{"id":"WdjXzh","date":"1553016482","viewed":150,"name":"Doctor, I Think I Have Gyroids","username":"bignobody","description":"First experiments with the Gyroid equation: cos X * sin Y + cos Y * sin Z + cos z * sin X = 0\nThanks to BigWIngs for suggesting it (and for your awesome ArtOfCode videos, they're pretty great!), and to iq and Jamie Wong.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","gyroid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 64\n#define EPSILON 0.001\n#define MAX_DIST 500.0\n\nfloat gyroid(vec3 p )\n{\n\tfloat g = cos(p.x) * sin(p.y) + cos(p.y) * sin(p.z) + cos(p.z) * sin(p.x);\n    return length(normalize(p)*g);\n\n// I also got some interesting results by making a vector from the component parts of the Gyroid equation:\n//\tvec3 g = normalize(vec3(cos(p.x) * sin(p.y), cos(p.y) * sin(p.z), cos(p.z) * sin(p.x)));\n//\treturn cos(length(g));\t\n//return (sqrt(p.x+g.y*p.y+g.x));\n\t//return atan(p.x+g.y,p.y+g.x);\n\t//return distance(p,g);\n    //return length(cross(p,g));\n\t//return length(sqrt(cross(p,g)));\n}\n\nfloat sceneSDF(vec3 p)\n{\n    return gyroid(p);\n}\n\nfloat distToSurface( vec3 eye, vec3 dir, float startDist, float endDist )\n{\n\tfloat depth = startDist;\n\tfor (int i = 0; i < MAX_STEPS; i++) \n    {\n    \tfloat dist = sceneSDF(eye + depth * dir);\n    \tif (dist < EPSILON) \n        {\n        // We're inside the scene surface!\n        return depth;\n    \t}\n    \t// Move along the view ray\n    \tdepth += dist;\n\n    \tif (depth >= MAX_DIST) \n        {\n        \t// Gone too far; give up\n        \treturn endDist;\n    \t}\n    }\n    return endDist;\n}\n\nvec3 estimateNormal(vec3 p) \n{\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord/iResolution.xy)* 2.0 - 1.0;\n\tuv.x *= iResolution.x/iResolution.y;\n\n    // camera setup and ray cast\n    float zoom = 0.45;\n    float ext = iTime * 0.6;\n    vec3 lookAt = vec3(0.0,0.5,0.0);\n    vec3 camOrigin = vec3(10.0 * cos(iTime * 0.1)+ext,6.5 * cos(iTime * 0.5)+4.2+ext,-10.0 * sin(iTime * 0.1)+ext);\n\tvec3 forwardVec = normalize(lookAt - camOrigin);\n    vec3 rightVec = normalize(cross(vec3(0.0,1.0,0.0),forwardVec));\n    vec3 upVec = cross(forwardVec,rightVec);\n    \n    vec3 centerVec = camOrigin + forwardVec * zoom;\n    vec3 intersectVec = centerVec + uv.x * rightVec + uv.y * upVec;\n    vec3 rayDirection = normalize(intersectVec - camOrigin);\n\n    float d = distToSurface(camOrigin,rayDirection, 0.0,MAX_DIST);\n\tvec3 g = estimateNormal(camOrigin + rayDirection * d);\n    d = d/length(g);\n  \tvec3 p = camOrigin + rayDirection * d;\n  \n   \t\n    if (d > MAX_DIST-EPSILON)\n    {\n     \t// no hit\n        fragColor = vec4(0.0,0.0,0.0,0.0);\n        return;\n    }\n    vec3 col = vec3(clamp(d,0.0,0.9))*(g);\n\n    fragColor = vec4(col,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}