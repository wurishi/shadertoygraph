{"ver":"0.1","info":{"id":"7dySzz","date":"1634243087","viewed":250,"name":"Swollen Kirby","username":"Devskil","description":"Well that's Kirby !","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","sdf","animation","kirby"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Using code from IQ\n//https://iquilezles.org/articles/distfunctions\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 20.0;\nconst float PRECISION = 0.001;\nconst float PI = 3.14159265359;\n\nvec3 white = vec3(1.);\nvec3 black = vec3(.0);\nvec3 grey = vec3(.6);\nvec3 weights_col = vec3(.2, .2, .2);\nvec3 pink = vec3(1., .71, .76);\nvec3 blush_col = vec3(.99, .5, .65);\nvec3 shoes_col = vec3(.87, .02, .35);\nvec3 blue = vec3(.0, .0, 1.);\n\nstruct Surface {\n    float sd;\n    vec3 col;\n};\n\nmat3 rotateX(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(\n        vec3(1., 0., 0.),\n        vec3(0., c, -s),\n        vec3(0., s, c)\n    );\n}\n\nmat3 rotateY(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(\n        vec3(c, 0., -s),\n        vec3(0., 1., 0.),\n        vec3(s, 0., c)\n    );\n}\n\nmat3 rotateZ(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(\n        vec3(c, -s, 0.),\n        vec3(s, c, 0.),\n        vec3(0., 0., 1.)\n    );\n}\n\n//operator\nSurface unionOp(Surface s1, Surface s2) {\n    if(s1.sd < s2.sd) {\n        return s1;\n    } else {\n        return s2;\n    }\n}\n\nSurface intersection(Surface s1, Surface s2) {\n    if(s1.sd < s2.sd) {\n        return s2;\n    } else {\n        return s1;\n    }\n}\n\nSurface smoothUnion(Surface a, Surface b, float k ) {\n    float h = clamp( 0.5 + 0.5 * (b.sd - a.sd) / k, 0.0, 1.0 );\n    vec3 col = mix( b.col, a.col, h ) - k * h * (1.0 - h);\n    return Surface(mix( b.sd, a.sd, h ) - k * h * (1.0 - h), col);\n}\n\nSurface ssubstract(Surface a, Surface b, float k ) {\n    float h = clamp( 0.5 - 0.5 * (b.sd + a.sd) / k, 0.0, 1.0 );\n    vec3 col = mix( b.col, a.col, h ) - k * h * (1.0 - h);\n    return Surface(mix( b.sd, -a.sd, h ) + k * h * (1.0 - h), col);\n}\n\n//sdf\n\nSurface sdSphere(vec3 p, float r, vec3 col) {\n    float d = length(p) - r;\n    return Surface(d, col);\n}\n\nSurface sdEllipsoid( vec3 p, vec3 r, vec3 col) {\n  float k0 = length(p / r);\n  float k1 = length(p / (r * r));\n  return Surface(k0 * (k0 - 1.0) / k1, col);\n}\n\nSurface sdFloor(vec3 p, vec3 col) {\n    return Surface(p.y, col);\n}\n\nSurface sdVerticalCapsule( vec3 p, float h, float r, vec3 col)\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return Surface(length( p ) - r, col);\n}\n\nSurface sdRoundCone( vec3 p, float r1, float r2, float h, vec3 col) {\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 )return Surface(length(q) - r1, col);\n  if( k > a*h ) return Surface(length(q-vec2(0.0,h)) - r2, col);\n        \n  return Surface(dot(q, vec2(a,b) ) - r1, col);\n}\n\nSurface sdBox( vec3 p, vec3 b , vec3 col) {\n  vec3 q = abs(p) - b;\n  return Surface(length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0), col);\n}\n\nSurface sdCylinder( vec3 p, float h, float r, vec3 col) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h, r);\n  return Surface(min(max(d.x,d.y), 0.0) + length(max(d,0.0)), col);\n}\n\nSurface bar(vec3 p, vec3 repulsor, float k) {\n    //repulsor to bend the bar\n    p = p - normalize(p - repulsor) * k;\n    Surface bar = sdCylinder((p - vec3(0., -2.7, .3)) * rotateZ(1.5708), .08, 4., white);\n    return bar;\n}\n\n\nSurface arms(vec3 p, Surface modele, bool flex) {\n    vec3 pbiceps = p;\n    float wave = .5 +.35 * sin(iTime * 3.);\n    pbiceps.y += 1.;\n    pbiceps.y *= 1.+.1 * wave;\n    pbiceps.y -= 1.;\n    pbiceps.xz *= 1.-.1 * wave;\n\n    vec3 pforearm = p;\n    pforearm.x += 1.4;\n    pforearm.z += 1.1;\n    pforearm.y += 1.25;\n    pforearm *= 1.+.1 * -wave;\n    pforearm -= 1.2;\n\n    //arms\n    Surface shoulderL = sdSphere((pbiceps - vec3(.5, .5, -.25)), .6, pink);\n    Surface armL = sdVerticalCapsule((pbiceps - vec3(.5, 0.5, -.35)) * rotateZ(90.), 1.5, .45, pink);\n    Surface biceps = sdEllipsoid((pbiceps - vec3(1.5, .35, -.25)) * rotateZ(10.), vec3(.6, .45, .45), pink);\n    Surface triceps = sdEllipsoid((pbiceps - vec3(1.25, -.35, -.25)) * rotateY(6.) * rotateZ(10.), vec3(.5, .25, .25), pink);\n    Surface arm = smoothUnion(shoulderL, armL, .25);\n    arm = smoothUnion(biceps, arm, .1);\n    arm = smoothUnion(arm, triceps, .5);\n\n    Surface elbow = sdEllipsoid((p - vec3(2.0, -.35, -.25)) * rotateY(6.) * rotateZ(10.), vec3(.65, .5, .5), pink);\n    Surface elbow2 = sdEllipsoid((pforearm - vec3(2.35, -.65, -.25)) * rotateY(6.) * rotateZ(10.), vec3(.45, .3, .3), pink);\n    arm = smoothUnion(arm, elbow, .2);\n    arm = smoothUnion(arm, elbow2, .2);\n\n    Surface forearmL = sdEllipsoid((pforearm - vec3(2.5, 0.2, -.05)) * rotateX(-60.) /* rotateZ(-wave)*/, vec3(.5, 1.2, .45), pink);\n    Surface hand;\n    if(flex)\n        hand = sdRoundCone((pforearm - vec3(2.5, 1., .25)) * rotateX(50.) * rotateZ(87.), .25, .5, .5, pink);\n    else {\n         hand = sdRoundCone((pforearm - vec3(2.5, 1., .25)) * rotateX(50.) * rotateZ(0./*87.*/), .25, .5, .5, pink);\n         Surface thumb = sdEllipsoid((pforearm  - vec3(2.1, 1.4, .8)) * rotateY(-1.3), vec3(.3, .15, .15), pink);\n         hand = smoothUnion(hand, thumb, .2);\n    }\n    forearmL = smoothUnion(hand, forearmL, .1);\n    arm = smoothUnion(arm, forearmL, .1);\n    modele = smoothUnion(arm, modele, .1);\n\n    return modele;\n}\n\nSurface weights(vec3 p, Surface modele) {\n    float wave = .5 +.35 * sin(iTime * 3.);\n    p.x += 1.4;\n    p.z += 1.1;\n    p.y += 1.25;\n    p.xzy *= 1.+.1 * -wave;\n    p.xzy -= 1.2;\n\n    Surface bar = bar(p, vec3(0., -5.5, .0), 4.5);\n\n    vec3 op = p;\n    op.x = abs(op.x);\n    Surface weight1 = sdCylinder((op - vec3(5.45, .6, .65)) * rotateZ(1.8), 1.9, .4, weights_col);\n    Surface weight_sub = sdCylinder((op - vec3(5., .7, .65)) * rotateZ(1.8), 1., .2, grey);\n    Surface security1 = sdCylinder((op - vec3(5., .8, .65)) * rotateZ(1.8), .3, .2, grey);\n    weight1 = ssubstract(weight_sub, weight1, .1);\n    weight1 = unionOp(weight1, security1);\n    Surface weight2 = sdCylinder((op - vec3(6., .4, .65)) * rotateZ(1.8), 1.7, .2, weights_col);\n    Surface weight3 = sdCylinder((op - vec3(6.35, .3, .65)) * rotateZ(1.8), 1.3, .15, weights_col);\n    Surface weight_sub2 = sdCylinder((op - vec3(6.5, .25, .65)) * rotateZ(1.8), .5, .15, grey);\n    Surface security = sdCylinder((op - vec3(6.5, .25, .65)) * rotateZ(1.8), .25, .15, grey);\n    weight3 = ssubstract(weight_sub2, weight3, .1);\n    Surface weights = unionOp(weight1, weight2);\n    weights = unionOp(weights, weight3);\n    weights = unionOp(weights, security);\n    bar = unionOp(bar, weights);\n\n    modele = ssubstract(bar, modele, .2);\n    modele = unionOp(bar, modele);\n    return modele;\n}\n\nSurface legs(vec3 p, Surface modele) {\n    //thigh\n    Surface thigh = sdRoundCone((p - vec3(0.5, -2.1, .0)) * rotateZ(6.2), .5, .7, .9, pink);\n    Surface leg = smoothUnion(thigh, modele, .4);\n    modele = unionOp(leg, modele);\n    Surface quadri = sdEllipsoid((p - vec3(.75, -1.5, .2)) * rotateZ(50.3) * rotateX(50.05), vec3(.5, .9, .6), pink);\n    Surface isq = sdEllipsoid((p - vec3(.35, -1.5, .35)) * rotateZ(50.2) * rotateX(50.05), vec3(.45, .9, .4), pink);\n    Surface m = unionOp(quadri, isq);\n    modele = smoothUnion(m, modele, .1);\n    //Knee\n    Surface knee = sdRoundCone((p - vec3(0.65, -2.6, .05)) * rotateZ(6.2), .4, .4, .2, pink);\n    modele = smoothUnion(knee, modele, .1);\n    Surface knee_cap = sdRoundCone((p - vec3(0.7, -2.7, .35)) * rotateZ(6.2) * rotateX(50.5), .15, .3, .3, pink);\n    modele = smoothUnion(knee_cap, modele, .05);\n    //calf\n    Surface calf = sdRoundCone((p - vec3(0.65, -3.9, .0)) * rotateZ(6.2), .3, .5, .8, pink);\n    modele = smoothUnion(calf, modele, .2);\n\n    return modele;\n}\n\nSurface eyes(vec3 p, Surface modele) {\n    p.y *= 1./ smoothstep(.0,.15,abs(sin(iTime)));\n    Surface eyeL = sdEllipsoid((p - vec3(-.3, 0.5, 1.3)) * rotateX(6.6), vec3(.13, .43, .1), black);\n    Surface pupL = sdEllipsoid((p - vec3(-.3, 0.7, 1.3)) * rotateX(6.7), vec3(.08, .14, .05), white);\n    eyeL = ssubstract(pupL, eyeL, .1);\n    eyeL = unionOp(eyeL, pupL);\n    Surface blueL = sdEllipsoid((p - vec3(-.3, 0.3, 1.42)) * rotateX(6.5), vec3(.08, .17, .05), blue);\n    Surface subblue = sdEllipsoid((p - vec3(-.3, 0.4, 1.4)) * rotateX(6.5), vec3(.08, .17, .1), blue);\n    blueL = unionOp(blueL, subblue);\n    blueL = ssubstract(subblue, blueL, .01);\n    eyeL = unionOp(eyeL, blueL);\n    modele = ssubstract(eyeL, modele, .1);\n    modele = unionOp(eyeL, modele);\n    return modele;\n}\n\nSurface kirby(vec3 p, bool flex) {\n    vec3 op = p;\n    vec3 pbody = p;\n    float wave = .5 + .35 * sin(iTime * 3.);\n    pbody.y += 1.;\n    pbody.y *= 1. + .1 * wave;\n    pbody.y -= 1.;\n    pbody *= 1.-.1 * wave;\n\n    //body\n    Surface body = sdSphere(pbody, 1.5, pink);\n\n    //butt\n    op = pbody;\n    op.x = abs(p.x) -.9;\n    Surface butt = sdSphere(op - vec3(-.45, -1.35, -.45), .6, pink);\n    Surface modele = smoothUnion(body, butt, .3);\n\n    //eyes\n    op = pbody;\n    op.x = abs(op.x) -.6;\n    modele = eyes(op, modele);\n\n    //blush\n    op = pbody;\n    op.x = abs(op.x) - 1.5;\n    Surface blush = sdEllipsoid((op - vec3(-.75, -.0, 1.25)) * rotateY(.55), vec3(.15, .05, .05), blush_col);\n    modele = ssubstract(blush, modele, .1);\n    modele = smoothUnion(modele, blush, .1);\n    //mouth\n    Surface mouth = sdEllipsoid((pbody - vec3(.0, .75, 1.3)), vec3(.6, 1.2, .5), pink);\n    Surface box_mouth= sdBox((pbody - vec3(.0, 0.95, 1.3)), vec3(.8, 1., .65), shoes_col);\n    mouth = ssubstract(box_mouth, mouth, .5);\n    modele = ssubstract(mouth, modele, .1);\n    Surface mouthes = sdRoundCone((pbody - vec3(0.0, -.5, 1.5)) * rotateX(50.5), .15, .3, .3, black);\n    mouth = unionOp(box_mouth, mouth);    \n    //arms\n    op = p;\n    op.x = abs(op.x) - .8;\n    modele = arms(op - vec3(0., -.1, 0.2), modele, flex);\n    //legs\n    op = p;\n    op.x = abs(op.x) - .2;\n    modele = legs(op - vec3(0., -.2, 0.), modele);\n    //shoes\n    op = p;\n    op.x = abs(op.x) - 2.15;\n    Surface shoeL = sdEllipsoid((op - vec3(-1.1, -5.1, .3)) * rotateY(10.), vec3(.6, 1., 1.), shoes_col);\n    Surface box= sdBox((op - vec3(-1.1, -5.5, .3)) * rotateY(10.), vec3(.5, .6, 1.), shoes_col);\n    shoeL = ssubstract(box, shoeL, .3);\n    modele = smoothUnion(shoeL, modele, .1);\n    //weights\n    if(!flex)\n        modele = weights(p - vec3(.0, .0, .1), modele);\n\n    return modele;\n}\n\nSurface sdScene(vec3 p) {\n    //change false by true if you want to see kirby flex without the weights\n    Surface kirby = kirby(p, false);\n    Surface floor = sdFloor(p - vec3(.0, -5., .0), grey * 1.3);\n    return unionOp(kirby, floor);\n}\n\nvec3 computeNormal(vec3 p) {\n    float e = 0.0005;\n    return normalize(vec3(\n        sdScene(vec3(p.x + e, p.y, p.z)).sd - sdScene(vec3(p.x - e, p.y, p.z)).sd,\n        sdScene(vec3(p.x, p.y + e, p.z)).sd - sdScene(vec3(p.x, p.y - e, p.z)).sd,\n        sdScene(vec3(p.x, p.y, p.z + e)).sd - sdScene(vec3(p.x, p.y, p.z - e)).sd\n    ));\n}\n\nSurface rayMarching(vec3 ro, vec3 rd, float start, float end) {\n    float depth = start;\n    Surface co;\n    const int step = 255;\n    for(int i = 0; i < MAX_MARCHING_STEPS; ++i) {\n        vec3 p = ro + depth * rd;\n        co = sdScene(p);\n        depth += co.sd;\n        if(co.sd < PRECISION || depth > end)\n            break;\n    }\n    co.sd = depth;\n    return co;\n}\n\nvec3 blinn_phong(vec3 lightDirection, vec3 normal, vec3 rd) {\n    vec3 lightColor = vec3 (1.,1.,1.);\n    //ambient\n    float ka = .4;\n    vec3 ia = lightColor;\n    vec3 ambient = ia * ka;\n\n    //diffuse\n    float kd = .5;\n    vec3 id = lightColor;\n    float diff = clamp(dot(lightDirection, normal), 0., 1.);\n    vec3 diffuse = kd * diff * id;\n\n    //specular\n    float ks = .5;\n    vec3 is = lightColor;\n    float alpha = 10.;\n    float dotRV = clamp(dot(reflect(-lightDirection, normal), -rd), 0., 1.);\n    vec3 specular = ks * pow(dotRV, alpha) * is;\n\n    return ambient + diffuse + specular;\n}\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv =  (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    vec3 backgroundColor = vec3(0.6);\n    vec2 mouseUV = iMouse.xy / iResolution.xy;\n  \n    if (mouseUV == vec2(0.0)) \n        mouseUV = vec2(0.5);\n\n    vec3 col = vec3(0.);\n    vec3 ro = vec3(0., -1., 6.5);\n    vec3 lp = vec3(0);\n\n    //camera\n    float cameraRadius = 2.;\n    ro.yz = ro.yz * cameraRadius * rotate2d(mix(-PI/2., PI/20., mouseUV.y));\n    ro.xz = ro.xz * rotate2d(mix(-PI, PI, mouseUV.x)) + vec2(lp.x, lp.z);\n    vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1));\n\n    Surface co = rayMarching(ro, rd, MIN_DIST, MAX_DIST);\n    if(co.sd > MAX_DIST) {\n        col = backgroundColor;\n    } else {\n        vec3 p = ro + co.sd * rd;\n        vec3 normal = computeNormal(p);\n\n        //light\n        vec3 lightPosition = vec3(0., 2., 3.);\n        vec3 lightDirection = normalize(lightPosition - p);\n        col = co.col * blinn_phong(lightDirection, normal, rd) + backgroundColor * .2;\n    }\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}