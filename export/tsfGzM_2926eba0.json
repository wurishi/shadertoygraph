{"ver":"0.1","info":{"id":"tsfGzM","date":"1545406291","viewed":402,"name":"Temporal chromab","username":"mensab","description":"Attempt at replicating the motion blur / chromatic abberation effect in Quite's demo Utul (https://www.youtube.com/watch?v=rP0adYqrVIU). Applied it to a simple raymarched cube that does some flying around. Probably needs some more work.","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","motionblur","effect","chromaticabberation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MIN_DIST .2\n#define MAX_DIST 20.\n#define MAX_MARCHING_STEPS 100\n#define EPS .001\n\nfloat box(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n  \treturn min(max(d.x, max(d.y, d.z)), 0.) + length(max(d, 0.));\n}\n\nfloat scene(vec3 p, float t) {\n    //  rotate + bob around\n    p += vec3(cos(2. * t), sin(.5 * t), sin(t));\n    float theta = .9 * t;\n    mat4 rot = mat4(cos(theta), 0., sin(theta), 0.,\n                    0., 1., 0., 0.,\n                    -sin(theta), 0., cos(theta), 0.,\n                    0., 0., 0., 1.);\n    p = vec3(rot * vec4(p, 0.));\n    \n    return box(p, vec3(.5));\n}\n\n//  simple raymarcher\nfloat raymarch(vec3 cam_pos, vec3 march_dir, float t) {\n    float depth = MIN_DIST;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = scene(cam_pos + depth * march_dir, t);\n        if (dist < EPS) {\n            return depth;\n        }\n        depth += dist;\n        if (depth >= MAX_DIST) {\n            return MAX_DIST;\n        }\n    }\n    return MAX_DIST;\n}\n\nvec3 cam_dir(float fov, vec2 uv) {\n    vec2 xy = (uv * iResolution.xy) - iResolution.xy / 2.0;\n    float z = iResolution.y / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n//  image to apply effect on\nvec3 render(vec2 uv, float t) {\n    vec3 pos = vec3(0., 0., 3.);\n    vec3 dir = cam_dir(90., uv);\n    float dist = raymarch(pos, dir, t);\n    \n    float v = 1. - (dist / MAX_DIST);\n    return vec3(ceil(v));\n}\n\n//  apply effect\nvec3 render_iter(vec2 uv, float t)\n{\n    //  params\n    float iters = 10.;\n    float dt = .005;\n    \n    vec3 acc = vec3(0.);\n    for (float i = 0.; i < iters; i++) {\n        //  offset render time for each color channel\n        acc.r += render(uv, t + i * dt).r;\n        acc.g += render(uv, t + 2. * i * dt).g;\n        acc.b += render(uv, t + 3. * i * dt).b;\n    }\n\treturn acc / iters;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = vec4(render_iter(uv, iTime), 1.);\n}","name":"Image","description":"","type":"image"}]}