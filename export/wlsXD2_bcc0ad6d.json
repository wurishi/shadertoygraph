{"ver":"0.1","info":{"id":"wlsXD2","date":"1565100915","viewed":192,"name":"Keep up little square","username":"104","description":"I think we're lost","likes":20,"published":1,"flags":0,"usePreview":0,"tags":["legday"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float xscale = .25;\nconst float yscale = .2;\nconst float xspeed = 1.0;\nconst float timeMult = .17;\nconst float sluggishness = 10.;\nconst float camShakiness = 0.05;\nconst float camZoom = 0.1;\n\n//---------------------------------------------\n\nconst float PI = atan(1.)*4.;\nconst float PI2 = PI*2.;\n\nvec3 hash32(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat dtoa(float d, float amount){\n    return 1. / clamp(d*amount, 1., amount);\n}\nfloat sdSquare(vec2 p, vec2 pos, vec2 origin, float a, float s) {\n\tvec2 d = abs(((p-pos) * mat2(cos(a), sin(a), -sin(a), cos(a))) - origin) - s;\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// returns { x:orig, y:height, z:position 0-1 within this cell }\nvec3 cell(float x) {\n    float pos = fract(x/xscale);\n    float orig = (x/xscale-pos)*xscale;\n    float h = hash32(vec2(orig)).r;\n    return vec3(orig, h * yscale, pos);\n}\n\nvoid scene(out vec4 o, vec2 N, vec2 uv, float t, float xpos, float xcam) {\n    vec3 sqCellPrev = cell(xpos-xscale);\n    \n    // ground\n    vec3 bigCellThis = cell(uv.x);\n    vec3 bigCellNext = cell(uv.x + xscale);\n    float bigHeightThis = mix(bigCellThis.y, bigCellNext.y, bigCellThis.z);// terrain height\n    float sd = uv.y - bigHeightThis;\n\n    // walking square; interpolate between positions\n    float sdsq = 1e7;\n    vec3 sqCellThis = cell(xpos);\n    vec3 sqCellNext = cell(xpos+xscale);\n    float aThis = atan(sqCellPrev.y - sqCellThis.y, sqCellPrev.x - sqCellThis.x);\n    float aNext = atan(sqCellThis.y - sqCellNext.y, sqCellThis.x - sqCellNext.x) - PI*.5;\n    if(aNext > aThis+PI) aNext -= PI2;\n    if(aNext < aThis-PI) aNext += PI2;\n\n    float szThis = distance(sqCellPrev.xy, sqCellThis.xy);\n    float szNext = distance(sqCellThis.xy, sqCellNext.xy);\n\n    float asq = mix(aThis, aNext, pow(sqCellNext.z, sluggishness));\n    float sz = mix(szThis, szNext, pow(sqCellNext.z, sluggishness));\n    sdsq = sdSquare(uv,\n                                  vec2(sqCellThis.x, sqCellThis.y),\n                                  vec2(-sz*.5,sz*.5), asq+PI, sz*.5);\n\n    // parallax bg\n    o=vec4(0);\n    vec2 uvtemp =uv;\n    for (float i = 1.; i <= 9.; ++i) {\n        uvtemp.x -= xpos;\n        uvtemp*=vec2(2.,1.8);\n        //uvtemp *= 2.;\n        uvtemp.y -= .3;\n        uvtemp.x += xpos + 1e3;\n        vec3 cellThis = cell(uvtemp.x);\n        vec3 cellNext = cell(uvtemp.x + xscale);\n        float heightThis = mix(cellThis.y, cellNext.y, cellThis.z);\n        float sd = uvtemp.y - heightThis;\n        o.rgb = max(o.rgb, dtoa(sd,1e4)*.2/i);\n        \n        float amt = 25.+heightThis*500.;\n        //amt = 1000./((uvtemp.y)*100.);\n      \to.rgb = max(o.rgb, dtoa(abs(sd)+.01,amt)*.4/i);\n    }\n    o +=vec4(.8-uv.y*1.1);\n    o.g *= o.r;\n    o.r *=.6;\n    o.b += N.y;\n\n    // square\n    float alphasq = dtoa(sdsq, 1000.);\n    o.rgb = mix(o.rgb, vec3(.9,.1,.1), alphasq);\n    \n    // ground\n    float alphagr = dtoa(sd, 300.);\n    o.rgb = mix(o.rgb, vec3(1), alphagr);\n    \n    // snow\n    float amt = 25.+bigHeightThis*500.;\n    alphagr = dtoa(abs(sd+.01), amt);\n    o.rgb = mix(o.rgb, vec3(.8,.9,1), alphagr);\n}\n\nvoid mainImage( out vec4 o, vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy-.5;\n    vec2 N = uv;\n    uv.x *= iResolution.x / iResolution.y;\n    float t = iTime*timeMult;\n    float xpos = t*xspeed;\n    float xcam = sin(t)*sin(t*9.)*camShakiness;// shaky cam\n    uv *=.7+sin(t*2.)*camZoom;//zoomy cam\n    uv.x += xpos + xcam;\n\tuv.y += .3;\n\n    // calc scene twice & motion blur\n    vec3 sqCellPrev = cell(xpos-xscale);\n    float bounce = abs(sin(sqCellPrev.z*26.))*pow(1.-sqCellPrev.z, 7.) * .03;\n    uv.y += bounce;\n    scene(o, N, uv, t, xpos, xcam);\n    uv.y -= bounce;\n    vec4 o2;\n    scene(o2, N, uv, t, xpos, xcam);\n    o = mix(o2, o, .5);\n    \n    o.b *= .9;\n    o.rgb += (hash32(fragCoord+iTime)-.5)*.08;\n    o *= 1.1-dot(N,N);\n    o=clamp(o,0.,1.);\n    o.a = 1.;\n}\n\n","name":"Image","description":"","type":"image"}]}