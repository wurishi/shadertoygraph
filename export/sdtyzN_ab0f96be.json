{"ver":"0.1","info":{"id":"sdtyzN","date":"1653598256","viewed":92,"name":"Koch Snowflake Spiral","username":"MikSu","description":"I saw [url=https://www.youtube.com/watch?v=fjXj6asQSEk]GoldPlatedGoof's Youtube video[/url], where he showed a way to transform images into logarithmic spirals and I wanted to combine that with fractals.","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["fractal","complexanalysis"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Note: you can adjust some parameters in the 'Common' tab\n\nconst mat2 P = mat2(\n    FLAKES*sqrt(3.)/(2.*PI), -FLAKES/(2.*PI),\n    FLAKES/(2.*PI), FLAKES*sqrt(3.)/(2.*PI)\n);\n\nvec2 tile( vec2 v ) {\n    vec2 r;\n    float m = mod(v.x, 2.0);\n    r.x = mod(m, 1.0);\n    if(m <= 1.) {\n        r.y = mod(v.y, sqrt(3.)*2./3.);\n    } else {\n        r.y = mod(v.y + sqrt(3.)/3., sqrt(3.)*2./3.);\n    }\n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates\n    vec2 uv = fragCoord/iResolution.y;\n    uv -= iResolution.xy/(2.*iResolution.y);\n    \n    // Get polar coordinate representation\n    vec2 pol = vec2(length(uv), atan(uv.y, uv.x));\n    // Calculate a zoom factor\n    float z;\n#if ROTATE\n        z = mod(ZOOM*iTime, 2.*sqrt(3.)/3.);\n#else\n        z = mod(ZOOM*iTime, 2.*sqrt(3.)*PI/(3.*FLAKES));\n#endif\n    // Apply complex logarithm with a zoom factor\n    // followed by a linear transformation\n    vec2 tr;\n#if ROTATE\n        tr = P*vec2(log(pol.x), pol.y) - vec2(0., z);\n#else\n        tr = P*vec2(z+log(pol.x), pol.y);\n#endif\n    // Apply tiling\n    tr = tile(tr);\n    \n    // Use the generated Koch Snowflake texture to get colour, and\n    // apply mipmap sampling with radially increasing resolution\n    // to avoid aliasing artifacts.\n    fragColor = textureLod(iChannel0,\n                           vec2(tr.y*iResolution.y/iResolution.x, tr.x),\n                           -log(pol.x));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const vec2[] vs = vec2[](vec2(0., sqrt(3.)/2.), vec2(1., sqrt(3.)/2.), vec2(.5, 0.));\nconst mat2 rot = mat2(\n    cos(PI/3.), sin(PI/3.),\n    -sin(PI/3.), cos(PI/3.)\n);\n\nbool tri( vec2 v, vec2 p, vec2 d ) {\n    v = v - p;\n    vec2 n = vec2(-d.y, d.x);\n    if(dot(v, n) < 0.) {return false;}\n    if(dot(v, rot*n) > 0.) {return false;}\n    v = v - d;\n    d = rot*(rot*d);\n    n = vec2(-d.y, d.x);\n    if(dot(v, n) < 0.) {return false;}\n    return true;\n}\n\nbool kochFlake ( vec2 v ) {\n    vec2 tri_pos = vs[0];\n    vec2 tri_dir = vs[2] - vs[0];\n    // Check if v is in the first triangle\n    if(tri(v, tri_pos, tri_dir)){return true;}\n    int path;\n    for(int i = 0; i < 3; i++) {\n        // Check the three sides of the first triangle separately\n        for(int j = 0; j < ITER; j++) {\n            for(int k = 0; k < 1<<(2*j); k++) {\n                // The digits of k define a path through the side\n                path = k;\n                tri_pos = vs[i];\n                if(i == 2) {tri_dir = vs[0] - vs[2];} else {tri_dir = vs[i+1] - vs[i];}\n                for(int l = 0; l < j; l++) {\n                    // Read the digits and construct vectors following the path\n                    tri_dir /= 3.;\n                    switch(path&3) {\n                        case 0:\n                            break;\n                        case 1:\n                            tri_pos += tri_dir;\n                            tri_dir /= 2.;\n                            tri_dir += vec2(-sqrt(3.)*tri_dir.y, sqrt(3.)*tri_dir.x);\n                            break;\n                        case 2:\n                            tri_pos += 2.*tri_dir;\n                            tri_dir /= 2.;\n                            tri_dir -= vec2(-sqrt(3.)*tri_dir.y, sqrt(3.)*tri_dir.x);\n                            tri_pos -= tri_dir;\n                            break;\n                        case 3:\n                            tri_pos += 2.*tri_dir;\n                            break;\n                    }\n                    path = path >> 2;\n                }\n                tri_dir /= 3.;\n                tri_pos += tri_dir;\n                // Finally check if v is in the triangle at the end of the path\n                if(tri(v, tri_pos, tri_dir)) {return true;}\n            }\n        }\n    }\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv;\n    if(iFrame == 0) {\n        // Generate one Koch Snowflake on the first frame\n        uv = fragCoord/iResolution.y;\n        fragColor = kochFlake(vec2(uv.y, uv.x)) ? prim : sec;\n    } else {\n        // Keep the generated flake in the buffer\n        uv = fragCoord/iResolution.xy;\n        fragColor = texture(iChannel0, uv);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/*\n  These values determine the iteration\n  of the Koch snowflakes, their number\n  and the zoom rate. There are also two\n  modes: zoom with rotate and without.\n*/\n#define ITER 5\n#define FLAKES 4.\n#define ZOOM .2\n#define ROTATE 1\n\n// Primary and secondary colors\nconst vec4 prim = vec4(0., 0.6, 0.97, 1.);\nconst vec4 sec = vec4(0., 0.2, 0.35, 1.);\n\n\n#define PI 3.14159265358979323846","name":"Common","description":"","type":"common"}]}