{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"// Kind of SDF to render based on selection from the GUI\n#define KIND_TORUS 0\n#define KIND_CUBES 1\n#define KIND_FRACTAL1 2\n#define KIND_FRACTAL2 3\n#define KIND 2\n\nvec3 palette (float t) \n{\n    vec3 a = vec3(0.5, 0.5, 0.5);    \n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263, 0.416, 0.557);\n\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\n\nmat2 rotate_2d(float angle)\n{\n    return \n        mat2(\n            cos(angle), -sin(angle),\n            sin(angle), cos(angle)\n        );\n}\n\nfloat fractal(vec3 p0) \n{\n    vec4 p = vec4(p0, 1.0);\n    for(int i = 0; i < 8; i++)\n    {\n        p.xyz = mod(p.xyz - 1.0, 2.0) - 1.0;\n        p *= 1.4 / dot(p.xyz, p.xyz);\n    }\n    return (length(p.xz / p.w ) * 0.25);\n}\n\nfloat fractal2(vec3 p) \n{\n    p.xz = fract(p.xz) - 0.5;\n    float k = 1.0;\n    float s = 0.0;\n\n    for (int i = 0; i < 8 ; i++) \n    {\n        s = 2.0 / clamp(dot(p, p * (sin(iTime) + 1.5) / 2.0), 0.1, 1.0);\n        p = abs(p) * s - vec3(0.5, 3.0, 0.5);\n        k *= s;\n    }\n    return length(p) / k - 0.001;\n}\n\n// Adapted from fractal By yonatan\n#define PI 3.14159\nfloat fractal4( vec3 p)\n{\n    float y;\n    float s;\n    float e;\n    p += vec3(1.0);\n    y = p.y * 0.1 - 0.3;\n    s  = 9.0;\n    for (int j = 0; j++ < 9; p /= max(e, 0.001)) \n    {\n        p = mod(p - 1.0,2.0) - 1.0;\n        p.zx *= rotate_2d (PI / 4.0);\n        e = dot(p, p) * (0.6 + y);\n        s /= max(e, 0.0001);\n    }\n    return e= sqrt(e) / s * 2.0;\n}\n\n\nfloat sd_torus(vec3 p, float r)\n{\n    return length(vec2(p.y, length(p.xz) - r));\n}\n\nfloat sd_spehere(vec3 p, float size)\n{\n    return length(p) - size;\n \n}\n\nfloat sd_box(vec3 p, vec3 size)\n{\n    vec3 d = abs(p) - size;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat map_fracatals(in vec3 p) \n{\n    // Move the camera in a circle\n    p.y += sin(iTime);\n    p.x += cos(iTime);\n    \n    p.y += 1.0;\n\n    // Rotate  the fracal\n    //p.xy *= rotate_2d(sin(iTime) / 2.0 );\n    //p.xy *= rotate_2d(cos(iTime) / 2.0 );\n\n\n    // return KIND == KIND_FRACTAL1 ? fracal(p) : fracal2(p);\n\n    return fractal4(p);\n    if (KIND == KIND_FRACTAL1) \n    {\n        return fractal(p);\n    }\n    else if (KIND == KIND_FRACTAL2) \n    {\n        return fractal2(p);\n    }\n}\n\nfloat map_primatives(in vec3 p) \n{\n    // Move the camera in a circle\n    // p.y += sin(time);\n    // p.x += cos(time);\n\n    // Rotate the cubes\n    p.xy *= rotate_2d((iTime) / 64.0 );\n    p.xy *= rotate_2d((iTime) / 64.0 );\n\n    // Create an infinite field of cubes\n    p.xy = fract(p.xy) - 0.5;\n    p.z = mod(p.z, 0.5) - 0.25;\n\n    if (KIND == KIND_CUBES) \n    {\n        return sd_box(p, vec3(0.1));\n    }\n    else if (KIND == KIND_TORUS) \n    {\n        return sd_torus(p, 0.25);\n    }\n    return 0.0;\n}\n\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ///////////\n    // Setup //\n    ///////////\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n\n    // Ray origin point \n    vec3 ro = vec3(0, 1, -3);\n    \n    // Ray direction\n    float fov = 1.25;//0.8;\n    vec3 rd = normalize(vec3(uv * fov, 1));\n    \n    /*\n    // Mouse input\n    vec2 mouse = (iMouse.xy * 2. - iResolution.xy) / iResolution.y;\n    \n    // Mouse rotation around the Y axis (up/down)\n    ro.yz *= rotate_2d(-mouse.y);    \n    rd.yz *= rotate_2d(-mouse.y);\n    \n    // Mouse rotation around the Y axis (left/right)\n    ro.xz *= rotate_2d(-mouse.x);    \n    rd.xz *= rotate_2d(-mouse.x);\n    */\n    \n    // Distance of travel\n    float t = 0.25;\n    \n    /////////////////\n    // Raymarching //\n    /////////////////\n    // The current point in 3D space along rd\n    int i = 0;\n    for (i = 0; i < 80; i++) \n    {\n        vec3 ray_position = ro + rd * t;\n        \n        // Spiral the ray around the Z-axis the further it is from the origin point\n        \n        ray_position.xy *= rotate_2d(t * 0.2);\n\n        \n        // Continuously move the camera forwards\n        ray_position.z += iTime * 0.5;\n        \n        // Wiggle the ray up and down\n        //p.y += sin(t);\n\n        \n        // Get the nearest signed-distance field distance\n        float dist = 0.0;\n        switch(KIND)\n        {\n            case KIND_TORUS:\n            case KIND_CUBES:\n                dist = map_primatives(ray_position);\n                break;\n\n            case KIND_FRACTAL1:\n            case KIND_FRACTAL2:\n                dist = map_fracatals(ray_position);\n                break;\n\n        }\n    \n        t += dist;\n        \n        // Exit early if the ray gets too close to the object, or if the travel distance is over 100\n        if (dist < 0.001 || t > 100.0) \n        {\n            break;\n        }\n    }\n    \n    vec3 colour = palette(t * 0.05 + (float(i) / 80.0));\n\n\n    // Output to screen\n    fragColor = vec4(colour, 1.0);\n}\n\n\n\n/*\n\n// Rodrigues rotation forumla\nvec3 rotate_3d(vec3 p, vec3 axis, float angle)\n{\n    return mix(dot(axis, p) * axis, p, cos(angle)) + cross(axis, p) * sin(angle);\n}\n\n\n// Returns the distance to the nearest object from the given vector\nfloat map(vec3 p) \n{\n    // Note: The transform of a given object in sdf is the same as moving the ray in\n    // the oppisite direction, so moving the sphere right 3 units is the same\n    // as offsetting the ray position to the LEFT\n    vec3 spere_position = vec3(3, 0, -1);// * sin(iTime);\n    float sphere = sd_sphere(p - spere_position, 1.0);\n    \n    // Infinite cubes\n    vec3 q = fract(p) - 0.5;\n    \n    // Create a copy of the input p to rotate the box around\n    vec3 copy_p = q;\n    \n    // Rotate around the z axis\n    copy_p.xy *= rotate_2d(iTime); \n    \n    // Rotate around the \n    copy_p.zx *= rotate_2d(iTime);\n\n    \n    float box = sd_box(copy_p, vec3(0.1));\n    \n    float ground = p.y + .75;\n    \n    return min(ground, min(box, sphere));\n}\n*/","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"McKfD3","date":"1734615805","viewed":114,"name":"Spiral Cubes","username":"Hopson","description":"From this tutorial https://www.youtube.com/watch?v=khblXafu7iA","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","cubes"],"hasliked":0,"parentid":"","parentname":""}}