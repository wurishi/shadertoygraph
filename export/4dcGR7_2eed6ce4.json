{"ver":"0.1","info":{"id":"4dcGR7","date":"1448528293","viewed":217,"name":"randomcolors","username":"jt","description":"Generate random colors for debugging-purposes.\nThe goal is to create different, highly saturated random colors for a wide range of seed-values.\nNo patterns should appear when the scale is any value from 0.00001 to 100000.0","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["colors","random","debug"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"#define pi 3.1415926\n\n#define mirror(v) abs(2. * fract(v / 2.) - 1.)\n\n//#define rainbow(value)  .5 + .5 * cos(6.3 * (value + vec4(0,1,2,0) / 3.))\n\n// approximation of sine to avoid platform-dependent random-generator problems\n//#define sine(v) sign(.5-fract(v))*(1.-pow(abs(2. * fract(v*2.) - 1.),1.75+v-v))\n\nfloat sine(float v)\n{\n    return sign(.5-fract(v*.5))*(1.-pow(abs(2. * fract(v) - 1.),1.75));\n}\n\nvec2 sine2(vec2 v)\n{\n    return sign(.5-fract(v*.5))*(1.-pow(abs(2. * fract(v) - 1.),vec2(1.75)));\n}\n\nvec3 sine3(vec3 v)\n{\n    return sign(.5-fract(v*.5))*(1.-pow(abs(2. * fract(v) - 1.),vec3(1.75)));\n}\n\nfloat tri(float v) // triangular-\"wave\"\n{\n    return 2.*abs(2. * fract(v-.25) - 1.)-1.;\n}\n\nvec2 tri2(vec2 v) // triangular-\"wave\"\n{\n    return 2.*abs(2. * fract(v-.25) - 1.)-1.;\n}\n\nvec3 tri2(vec3 v) // triangular-\"wave\"\n{\n    return 2.*abs(2. * fract(v-.25) - 1.)-1.;\n}\n\nvec3 rainbow(float value)\n{\n    //return .5 + .5 * cos(6.3 * (value + vec3(0,1,2) / 3.));\n    //return .5 + .5 * sine(2.*(.25 + value + vec3(0,1,2) / 3.));\n    return .5 + .5 * sine3(2.*(.25 + value + vec3(0,1,2) / 3.));\n    //vec3 m = mirror(value + vec3(0,1,2) / 3.);\n    //return m * m;\n}\n\n/*\nvec3 rainbow(float value)\n{\n    vec3 color;\n    \n    color.r = 0.5 + 0.5 * cos(pi * 2.0 * (value + 0.0 / 3.0));\n    color.g = 0.5 + 0.5 * cos(pi * 2.0 * (value + 1.0 / 3.0));\n    color.b = 0.5 + 0.5 * cos(pi * 2.0 * (value + 2.0 / 3.0));\n    \n    return color;\n}\n*/\n/*\n// iq's hash function from https://www.shadertoy.com/view/MslGD8\n//vec2 hash( vec2 p ) { p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))); return fract(sin(p)*18.5453); }\n// adjusted for single input\n//vec2 hash(float q) { vec2 p = vec2(q); p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))); return fract(sin(p)*18.5453); }\n// XXX should be equivalent to original but produces different colors XXX\nvec2 hash(float p) // simplified for single input\n{\n    return fract(sin(p * vec2(438.8, 452.8)) * 18.5453);\n}\n\n// rand-function found online\nfloat rand(vec2 seed) // 0..1\n{\n    return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n*/\nfloat rnd(float p) // combines hash with rand\n{\n    return fract(sin(dot(fract(sin(p * vec2(438.8, 452.8)) * 18.5453), vec2(12.9898, 78.233))) * 43758.5453);\n    //return fract(sine(dot(fract(sine2(p * vec2(139.7, 144.13)) * 18.5453), vec2(4.1348, 24.9023))) * 43758.5453);\n    //return fract(tri(dot(fract(tri2(p * vec2(139.7, 144.13)) * 18.5453), vec2(4.1348, 24.9023))) * 43758.5453);\n}\n\n// suggested by ollj\n#define aperiodicFullySaturatet(scale, time) normalize(s*cos(t*vec3(1.,sqrt(5.)*.5+vec2(.5,-.5))))\n\nvec3 debugcolors(float value)\n{\n    //return rainbow(10.0 * value * (1.0 + sqrt(5.0)) / 2.0);\n    //return rainbow(rand(vec2(value)));\n    return rainbow(rnd(value));\n    //return rainbow(fract(sin(value*17.)*1e4));\n    //return .5 + .5 * cos(6.3 * (fract(sin(value)*1e4) + vec3(0,1,2)/3.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(rainbow(uv.x),1.0);\n    //return;\n    //fragColor = .5 + .5 * cos(6.3 * (fract(sin(0.0001*uv.x)*1e4) + vec4(0,1,2,0)/3.));\n    fragColor =\n        mix(\n    \t\tmix(\n                // colors should look random over a wide range of scales...\n    \t\t\tvec4(debugcolors(uv.x),1.0),\n                // ...very small...\n                vec4(debugcolors(uv.x * 0.00001),1.0),\n                vec4(step(0.25, uv.y))\n               ),\n            mix(\n                // ...very large...\n                vec4(debugcolors(uv.x * 100000.0),1.0),\n                //vec4(debugcolors(uv.x * 10000.0),1.0), // on some computers only a smaller range works\n    \t\t\t// ...even when combining small with large values\n    \t\t\tvec4(debugcolors(exp2(-1. + 24.0 * (2.0 * uv.x - 1.0))),1.0),\n                //vec4(debugcolors(exp2(-6. + 22.0 * (2.0 * uv.x - 1.0))),1.0), // on some computers only a smaller range works\n                vec4(step(0.75, uv.y))\n               ),\n            vec4(step(0.5, uv.y))\n           );\n}\n","name":"Image","description":"","type":"image"}]}