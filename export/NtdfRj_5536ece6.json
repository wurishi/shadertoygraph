{"ver":"0.1","info":{"id":"NtdfRj","date":"1663342455","viewed":412,"name":"gabor texture","username":"Mistajolly","description":"Shadertoy version of Blender gabor texture based on https://developer.blender.org/D3495","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["gabor"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Shader Toy version of https://developer.blender.org/D3495 */\n\n#define M_PI 3.14159265358979\n#define M_2PI 6.28384\n\n\n/* ShaderToy */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\nfloat t = iTime * 1.0;\nfloat t8 = iTime * 8.0;\n \nfloat dim = min(iResolution.x, iResolution.y);\nfloat mx = iMouse.x/dim * 4.0;\nfloat my = iMouse.y/dim * 4.0;\n\nfloat gy = (fragCoord.y)/iResolution.y;\n\nif (iMouse.xy==vec2(0)){\n mx = 1.0;\n my = 1.0;\n}\n\nvec3 p=vec3(fragCoord,t8);\nvec3 direction = vec3(1.0,1.0,0.0);\nfloat scale=0.015;\nfloat bandwidth=gy*2.0;\nfloat impulses=0.4;\nfloat frequency=8.0+mx;\nfloat phase=0.0;\nfloat variance=mx; //rotational variance\nfloat rotation=0.0;\nint kernel=0; //0-gabor,1-cross,2=ring,3=square,4=test\nint anisotropic=0; //0-iso,1-aniso,2=hybrid\nint periodic=0;\nint seed=0;\nfloat detail = 0.5;\nfloat z_variance = 0.0;\nfloat lacunarity = 2.0;\nfloat roughness = 1.0;\nfloat falloff = 1.0;\n\n//tiled\nkernel=int((fragCoord.x*5.0)/iResolution.x); //0-gabor,1-cross,2=ring,3=square,4=phasor\n\n\nfloat randomness = 1.0; //cell randomness\nfloat weight = 0.0; //phase randomness\n                                  \nfloat v = gabor_noise(p,\n                    direction,\n                    scale,\n                    detail,\n                    bandwidth,\n                    impulses,\n                    frequency,\n                    lacunarity,\n                    roughness,\n                    phase,\n                    weight,\n                    randomness,\n                    z_variance,\n                    rotation,\n                    variance,\n                    falloff,\n                    kernel,\n                    anisotropic,                    \n                    periodic);\n\n\n// hard mix\n/*v = v *2.0-1.0;\nv = abs(v);*/\n\nfragColor = vec4(v,v,v,1.0);\n\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define M_PI 3.14159265358979\n#define M_2PI 6.28384\n\n/* Gabor Noise\n *\n * Based on: https://developer.blender.org/D287 and Musgrave as template\n * For further details of Gabor Noise Method please see: (broken) http://www.gabornoise.com/\n *\n * Adapted from Open Shading Language\n * Copyright (c) 2009-2010 Sony Pictures Imageworks Inc., et al.\n * All Rights Reserved.\n */\n\n#ifndef M_LN2\n#  define M_LN2 0.6931471805599453\n#endif\n#ifndef M_EPI\n#  define M_EPI 0.0432139182637722\n#endif\n\nint gabor_cellhash(int cell[3], int seed)\n{\n#define rot(x, k) (((x) << (k)) | ((x) >> (32 - (k))))\n#define final(a, b, c) \\\n  { \\\n    c ^= b; \\\n    c -= rot(b, 14); \\\n    a ^= c; \\\n    a -= rot(c, 11); \\\n    b ^= a; \\\n    b -= rot(a, 25); \\\n    c ^= b; \\\n    c -= rot(b, 16); \\\n    a ^= c; \\\n    a -= rot(c, 4); \\\n    b ^= a; \\\n    b -= rot(a, 14); \\\n    c ^= b; \\\n    c -= rot(b, 24); \\\n  }\n#define mix(a, b, c) \\\n  { \\\n    a -= c; \\\n    a ^= rot(c, 4); \\\n    c += b; \\\n    b -= a; \\\n    b ^= rot(a, 6); \\\n    a += c; \\\n    c -= b; \\\n    c ^= rot(b, 8); \\\n    b += a; \\\n    a -= c; \\\n    a ^= rot(c, 16); \\\n    c += b; \\\n    b -= a; \\\n    b ^= rot(a, 19); \\\n    a += c; \\\n    c -= b; \\\n    c ^= rot(b, 4); \\\n    b += a; \\\n  }\n\n  int a, b, c;\n  a = 1867964294;\n  b = 1867964294;\n  c = 1867964294;\n\n  a += cell[0];\n  b += cell[1];\n  c += cell[2];\n  mix(a, b, c);\n  a += seed;\n  final(a, b, c);\n\n  return c;\n\n#undef rot\n#undef mix\n#undef final\n}\n\nint gabor_rng_seed(vec3 cell, int seed)\n{\n  int icell[3];\n  icell[0] = int(floor(cell[0]));\n  icell[1] = int(floor(cell[1]));\n  icell[2] = int(floor(cell[2]));\n  int chash = gabor_cellhash(icell, seed);\n  if (chash == 0)\n    chash = 1;\n  return chash * 1519588931;\n}\n\nfloat gabor_rng_uniform(inout int rng)\n{\n  float int_max_inv = 1.0 / 2147483647.0;\n  float res = float(rng) * int_max_inv * 0.5 + 0.5;\n  rng *= 1519588931;\n  return res;\n}\n\nint gabor_rng_poisson(inout int rng, float mean)\n{\n  if (mean >= 1.0) {\n    return int(mean);\n  }\n  float g = exp(-mean);\n  int em = 0;\n  float t = gabor_rng_uniform(rng);\n  while (t > g) {\n    ++em;\n    t *= gabor_rng_uniform(rng);\n  }\n  return em;\n}\n\nstruct GaborParams {\n  float detail;\n  float variance;\n  float z_variance;\n  float weight;\n  float randomness;\n  float impulses;\n  float frequency;\n  float lacunarity;\n  float roughness;\n  float phase;\n  float rotation;\n  float radius;\n  float bandwidth;\n  float falloff;\n  int periodic;\n  int kernel;\n  int anisotropic;\n  vec3 direction;\n};\n\nvec3 gabor_kernel(GaborParams gp, float freq, vec3 omega, float phi, vec3 position, float g)\n{\n  float h;\n  if (gp.kernel == 5) { /* TEST */\n    h = cos(freq * dot(omega, position) + phi) + cos(freq * dot(omega, position.yxz) + phi);\n    h *= 0.5;}\n  else if (gp.kernel == 4) { /* SHD_GABOR_KERNEL_PHASOR */\n    float phase = freq * dot(omega, position) + phi;\n    return g * vec3(cos(phase), sin(phase), 0.0);\n  }\n  else if (gp.kernel == 3) { /* SHD_GABOR_KERNEL_SQUARE */\n    h = cos(freq * dot(omega, position) + phi) + cos(freq * dot(omega, position.yxz) + phi);\n  }\n  else if (gp.kernel == 2) { /* SHD_GABOR_KERNEL_CROSS */\n    h = cos(freq * length(position * omega) + phi);\n  }\n  else if (gp.kernel == 1) { /* SHD_GABOR_KERNEL_RING */\n    h = cos(freq * dot(position, omega) + phi) - cos(freq * length(position) + phi);\n  }\n  else {  // SHD_GABOR_KERNEL_GABOR\n    h = cos(freq * dot(omega, position) + phi);\n  }\n\n  return vec3(g * h);\n}\n\nGaborParams gabor_sample(GaborParams gp,\n                         float orand,\n                         float orand2,\n                         float frand,\n                         float prand,\n                         inout vec3 omega,\n                         out float phi)\n{\n  float pvar = mix(0.0, prand * 2.0 - 1.0, gp.weight);\n  phi = M_2PI * pvar + gp.phase;\n\n  float ovar = M_PI * (orand * 2.0 - 1.0);\n  float omega_t = ovar * gp.variance - gp.rotation;\n\n  if (gp.anisotropic == 1) { /* ANISO */\n    omega = normalize(gp.direction);\n  }\n  else if (gp.anisotropic == 2) { /* HYBRID */\n    float sin_omega_t = sin(omega_t);\n    float cos_omega_t = cos(omega_t);\n    omega = length(gp.direction) * vec3(cos_omega_t, sin_omega_t, 0.0);\n  }\n  else { /* ISO */\n    float cos_omega_p = 1.0 - 2.0 * orand2;\n    float sin_omega_p = sqrt(1.0 - cos_omega_p * cos_omega_p);\n    float sin_omega_t = sin(omega_t);\n    float cos_omega_t = cos(omega_t);\n    omega = normalize(vec3(cos_omega_t * sin_omega_p, sin_omega_t * sin_omega_p, cos_omega_p));\n  }\n  return gp;  // workaround gpu_codegen parser\n}\n\nvec3 gabor_fractal(\n    GaborParams gp, float frand, float dv, inout vec3 omega, float phi, vec3 kernel_position)\n{\n  float freq = gp.frequency;\n  vec3 sum = vec3(0.0);\n  float g = (1.0 + M_EPI) * (exp(-M_PI * gp.bandwidth * gp.bandwidth * dv) - M_EPI);\n  float amp = 1.0;\n  float maxamp = 0.0;\n  float octaves = clamp(gp.detail, 0.0, 15.0);\n  int n = int(octaves);\n  for (int i = 0; i <= n; i++) {\n    vec3 t = gabor_kernel(gp, freq, omega, phi, kernel_position, g);\n    sum += t * amp;\n    amp *= clamp(gp.roughness, 0.0, 2.0);\n    maxamp += amp;\n    freq *= gp.lacunarity;\n  }\n  float rmd = octaves - floor(octaves);\n  if (rmd > 0.0) {\n    vec3 t = gabor_kernel(gp, freq, omega, phi, kernel_position, g);\n    vec3 sum2 = sum + t * amp;\n    sum /= maxamp;\n    sum2 /= maxamp + amp;\n    return (1.0 - rmd) * sum + rmd * sum2;\n  }\n  else {\n    return sum / maxamp;\n  }\n}\n\nvec3 gabor_cell_3d(GaborParams gp, vec3 cell, vec3 cell_position)\n{\n  int rng = gabor_rng_seed(cell, 0);\n  int num_impulses = gabor_rng_poisson(rng, gp.impulses);\n  vec3 sum = vec3(0.0);\n  for (int i = 0; i < num_impulses; ++i) {\n    float xrand = gabor_rng_uniform(rng);\n    float yrand = gabor_rng_uniform(rng);\n    float zrand = gabor_rng_uniform(rng);\n    xrand = mix(0.0, xrand, gp.randomness);\n    yrand = mix(0.0, yrand, gp.randomness);\n    zrand = mix(0.0, zrand, gp.randomness);\n\n    vec3 kernel_position = (cell_position - vec3(xrand, yrand, zrand)) * gp.radius;\n\n    float dv = dot(kernel_position, kernel_position);\n    float orand = gabor_rng_uniform(rng);\n    float prand = gabor_rng_uniform(rng);\n    float frand = gabor_rng_uniform(rng);\n    float orand2 = gabor_rng_uniform(rng);\n\n    if (dv < gp.radius * gp.radius * gp.falloff) {\n      vec3 omega;\n      float phi;\n\n      gabor_sample(gp, orand, orand2, frand, prand, omega, phi);\n\n      sum += gabor_fractal(gp, frand, dv, omega, phi, kernel_position);\n    }\n  }\n  return sum;\n}\n\nfloat gabor_wrap(float s, float p)\n{\n  return (p != 0.0) ? s - p * floor(s / p) : 0.0;\n}\n\nfloat gabor_grid_3d(GaborParams gp, vec3 p, float scale)\n{\n  vec3 coords = p * scale;\n  vec3 position = floor(coords);\n  vec3 local_position = coords - position;\n\n  vec3 sum = vec3(0.0);\n  for (int k = -1; k <= 1; k++) {\n    for (int j = -1; j <= 1; j++) {\n      for (int i = -1; i <= 1; i++) {\n        vec3 cell_offset = vec3(i, j, k);\n\n        vec3 Pr = (vec3(i > 0, j > 0, k > 0) - local_position) * cell_offset;\n        if (dot(Pr, Pr) >= 1.0) {\n          continue;\n        }\n\n        vec3 cell = position + cell_offset;\n        vec3 cell_position = local_position - cell_offset;\n\n        if (gp.periodic == 1) {\n          cell.x = gabor_wrap(cell.x, scale);\n          cell.y = gabor_wrap(cell.y, scale);\n          cell.z = gabor_wrap(cell.z, scale);\n        }\n\n        sum += gabor_cell_3d(gp, cell, cell_position);\n      }\n    }\n  }\n  if (gp.kernel == 4) { /* SHD_GABOR_KERNEL_PHASOR */\n    float pn = atan(sum.y, sum.x);\n    return pn * gp.radius;\n  }\n  else {\n    return sum.x * gp.radius;\n  }\n}\n\nGaborParams gabor_parameters(vec3 direction,\n                             float detail,\n                             float bandwidth,\n                             float impulses,\n                             float frequency,\n                             float lacunarity,\n                             float roughness,\n                             float phase,\n                             float weight,\n                             float randomness,\n                             float z_variance,\n                             float rotation,\n                             float variance,\n                             float falloff,\n                             int kernel,\n                             int anisotropic,\n                             int periodic)\n{\n  GaborParams gp;\n\n  gp.periodic = periodic;\n  gp.variance = variance;\n  gp.z_variance = z_variance;\n  gp.lacunarity = lacunarity;\n  gp.roughness = roughness;\n  gp.anisotropic = anisotropic;\n  gp.kernel = kernel;\n  gp.direction = direction;\n  gp.phase = phase;\n  gp.rotation = rotation;\n  gp.detail = detail;\n  gp.impulses = clamp(impulses, 0.0001, 32.0);\n  gp.weight = weight;\n  gp.randomness = randomness;\n  gp.falloff = falloff;\n\n  float sqrt_pi_over_ln2 = sqrt(M_PI / M_LN2);\n  float bandwidth_pow = exp2(bandwidth);\n  gp.bandwidth = ((bandwidth_pow - 1.0) / (bandwidth_pow + 1.0)) * sqrt_pi_over_ln2;\n  gp.radius = 1.0 / gp.bandwidth;\n  gp.frequency = frequency * gp.bandwidth;\n  return gp;\n}\n\nfloat gabor_noise(vec3 p,\n                  vec3 direction,\n                  float scale,\n                  float detail,\n                  float bandwidth,\n                  float impulses,\n                  float frequency,\n                  float lacunarity,\n                  float roughness,\n                  float phase,\n                  float weight,\n                  float randomness,\n                  float z_variance,\n                  float rotation,\n                  float variance,\n                  float falloff,\n                  int kernel,\n                  int anisotropic,\n                  int periodic)\n{\n  if (impulses == 0.0) {\n    return 0.5;\n  }\n\n  GaborParams gp;\n  gp = gabor_parameters(direction,\n                        detail,\n                        bandwidth,\n                        impulses,\n                        frequency,\n                        lacunarity,\n                        roughness,\n                        phase,\n                        weight,\n                        randomness,\n                        z_variance,\n                        rotation,\n                        variance,\n                        falloff,\n                        kernel,\n                        anisotropic,\n                        periodic);\n\n  return min(max(gabor_grid_3d(gp, p, scale) * 0.5 + 0.5, 0.0), 1.0);\n}\n","name":"Common","description":"","type":"common"}]}