{"ver":"0.1","info":{"id":"cdtcz4","date":"1694787212","viewed":69,"name":"Cellular Eye","username":"granitoale","description":"Exercising on cellular noise and warping ","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["noise","eye","random","cellularnoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x = uv.x*1.5-.25;\n\n    uv = rotate2d(rotate2d(uv,PI*0.5),vnoise(uv+iTime*0.2)*0.3);\n\n    //Polar coordinates, tiling\n    vec2 uScale = vec2(5.,25.);\n    vec2 puv = c2p(uv);\n    puv.x = (sin(puv.x*PI*2.));\n    puv.y = 2.*abs(puv.y*2.-1.);\n    puv *= uScale;\n    \n    vec2 ipuv = floor(puv);\n    vec2 fpuv = fract(puv);\n\n    float d = 1.;\n    vec2 pp = vec2(0.);\n    \n    for(int a = -1; a <= 1; a++){\n        for(int r = -1; r <= 1; r++){\n            \n            vec2 ne = vec2(float(r),float(a));\n            pp = random2(ipuv+1.5+ne);\n            pp.x *= valueNoise(pp+iTime);\n            d = min(d,distance(pp+ne,fpuv));\n        }\n    }\n\n\n    float cdf = distance(uv,vec2(0.5))*2.;\n    float iris = valueNoise(vec2(0.345,2.343)+iTime)*0.1;\n    vec3 color = vec3(smoothstep(0.05,1.-vnoise(vec2(12.1,3.44)+iTime)*0.5,d))*\n                (1.-vec3(smoothstep(0.75,.9,cdf)))*\n                vec3(smoothstep(.05+iris,.25+iris*2.,cdf));\n    uv += valueNoise(uv+iTime*0.1)*0.2;\n    color += vec3(fbm(uv*5.))*vec3(smoothstep(0.2,3.,cdf));\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265359\n#define TWO_PI PI*2.\n/*--------------------------------------------------------\nConversion from cartesian to polar (2D) and from polar to\ncartesian (2D)\n--------------------------------------------------------*/\nvec2 c2p(vec2 xy){\n    vec2 pos = vec2(0.5)-xy;\n    return vec2(length(pos)*2.0,atan(pos.y,pos.x)/(2.*PI)+.5);\n}\nvec2 p2c(vec2 ra){\n    return vec2(ra.x*cos(ra.y*2.*PI),ra.x*sin(ra.y*2.*PI))+vec2(0.5);\n}\n/*--------------------------------------------------------\nRandom\n--------------------------------------------------------*/\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n/*--------------------------------------------------------\nRotate 2D space\n--------------------------------------------------------*/\nvec2 rotate2d(vec2 st,float a){\n    //move space to vec2(0.0);\n    st -= vec2(0.5);\n    st = mat2(cos(a),-sin(a),sin(a),cos(a))*st;\n    //go back to normal space with center in vec2(0.5)\n    st += vec2(0.5);\n    return st;\n}\n/*--------------------------------------------------------\nValue Noise by Inigo Quilez\n--------------------------------------------------------*/\nfloat hash( in ivec2 p ){\n    // 2D -> 1D\n    int n = p.x*3 + p.y*113;\n    // 1D hash by Hugo Elias\n    n = (n << 13) ^ n;\n    n = n * (n * n * 15731 + 789221) + 1376312589;\n    return -1.0+2.0*float( n & 0x0fffffff)/float(0x0fffffff);\n}\nfloat vnoise( in vec2 p ){\n    ivec2 i = ivec2(floor(p));\n    vec2 f = fract(p);\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);   \n    return mix( mix( hash( i + ivec2(0,0) ), \n                     hash( i + ivec2(1,0) ), u.x),\n                mix( hash( i + ivec2(0,1) ), \n                     hash( i + ivec2(1,1) ), u.x), u.y);\n}\nfloat valueNoise(vec2 uv){\n    float f = vnoise(uv);\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    f  = 0.5000*vnoise( uv ); uv = m*uv;\n    f += 0.2500*vnoise( uv ); uv = m*uv;\n    f += 0.1250*vnoise( uv ); uv = m*uv;\n    f += 0.0625*vnoise( uv ); uv = m*uv;\n    f = .5+.5*f;\n    return f;\n}\n/*--------------------------------------------------------\nSigned Noise by Ian McEwan, Ashima Arts\n--------------------------------------------------------*/\n// Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n/*--------------------------------------------------------\nfBm\n--------------------------------------------------------*/\n#define OCTAVES 4\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 2.;\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * abs(snoise(st));\n        st *= frequency;\n        amplitude *= .5;\n    }\n    return value;\n}","name":"Common","description":"","type":"common"}]}