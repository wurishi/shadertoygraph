{"ver":"0.1","info":{"id":"lXtGzS","date":"1716740921","viewed":102,"name":"2D kinetic gas","username":"minh","description":"This work is based on Molecular Dynamics from dr2, with additional coloring and information about system kinematic statistics. This simulation also replaces collision forces with softer, finite ones to improve stability.","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["particles","dynamics","multipass"],"hasliked":0,"parentid":"4dG3RW","parentname":"Molecular Dynamics"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// \"2D kinetic gas\" by minh - 2024, adapted from\n// \"Molecular Dynamics\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\nSimple but inefficient MD program for 2D soft disks. The algorithm\nparallelizes but is useless for large systems.\n\nStoring non-pixel data in textures follows iq's approach.\n\nSince the refresh rate is limited to 60 fps, doing multiple compute steps \nbetween display updates improves performance. Pixel-based rendering of \nlarge numbers of disks is also time consuming. \n\nMouse click restarts run.\n*/\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\n//const float txRow = 64.;\n\n\nvec4 Loadv4 (int idVar)\n{\n    float fi = float (idVar);\n    return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n        txSize);\n}\n\n\n\n//const int nMolEdge = 10;\n//const int nMol = nMolEdge * nMolEdge;\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 col;\n    vec2 uv, ut, q;\n    float bFac, dMin, b, KE, KEn, L, idx;\n    float[nbins] spectrum;\n    int nmin = 0;\n\n    uv = 2. * fragCoord / iResolution.xy - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    ut = abs (uv) - vec2 (1.);\n    b = max (ut.x, ut.y);\n    ut = abs (ut);\n    if (b > 0.003) col = vec3 (0.82);\n    else if (b < 0. && min (ut.x, ut.y) < 0.01) col = vec3 (0.3, 0.3, 1.);\n    else {\n        bFac = Loadv4 (nMol).y;\n        q = 0.5 * (bFac * float (nMolEdge) + 0.5) * uv;\n        dMin = 1000.;\n        KE = 0.;\n        for (int n = 0; n < nMol; n ++) {\n            //dMin = min (dMin, length (q - Loadv4 (n).xy));\n            L = length (q - Loadv4 (n).xy);\n            nmin = L < dMin ? n : nmin;\n            dMin = min(dMin, L);\n            KEn = .5*dot(Loadv4(n).zw,Loadv4(n).zw);\n            KE += KEn;\n            idx = clamp(KEn/(KEavg*speclim),0.,1.);\n            spectrum[int(float(nbins-1)*idx)] += 1.;\n        }\n        KE = KE/float(nMol);\n        col = mix (vec3 (0.05),  vec3(0.3) + 0.2*vec3 (1., 1., 0.5)*pow(length(Loadv4(nmin).zw/initVel),2.), 1. - smoothstep (0.4, 0.5, dMin));\n        uv = fragCoord / iResolution.xy;\n        //coordinate adjustment\n        float xoff = max(1.-iResolution.y/iResolution.x,0.)*.5;\n        float yoff = max(1.-iResolution.x/iResolution.y,0.)*.5;\n        float xwidth = 1. - 2.*xoff;\n        float ywidth = 1. - 2.*yoff;\n        float KEnorm = KE/KEavg;\n        float posy = (uv.y - yoff)/ywidth;\n        float posx = (uv.x - xoff)/xwidth;\n        //drawing the spectrum\n        int binx = int(floor(posx*float(nbins)));\n        if (binx < nbins) {\n            col = posy < specHeight*spectrum[binx]/float(nMol)*float(nbins)? mix(col,vec3(0,1,1),specOpacity) : col;\n        }\n        //comparison to theoretical formula\n        if (posy/specHeight < exp(-posx*speclim)*speclim) {\n            col = mix(col,vec3(1,1,0),specOpacity);\n        }\n        //drawing the kinematic bar\n        if (uv.y - yoff < barHeight*ywidth && barVisible) {\n            if (uv.x - xoff < KEnorm*barWidth*xwidth) {\n                col = vec3(.1, 0.9, .0);\n            }\n        }\n    }\n    fragColor = vec4 (col, 1.);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// \"2D kinetic gas\" by minh - 2024, adapted from\n// \"Molecular Dynamics\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n#define mPtr iMouse\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\n//const float txRow = 64.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  float fi = float (idVar);\n  vec2 d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n\n//const int nMolEdge = 10;\n//const int nMol = nMolEdge * nMolEdge;\nfloat bFac;\n\nvec4 Step (int mId)\n{\n  vec4 p, pp;\n  vec2 dr, f;\n  float rr, rri, rri3, rCut, rrCut, bLen, dt;\n  float s;\n  f = vec2 (0.);\n  p = Loadv4 (mId);\n  //rCut = pow (2., 1./6.);\n  rCut = 1.;\n  rrCut = rCut * rCut;\n  for (int n = 0; n < nMol; n ++) {\n    pp = Loadv4 (n);\n    dr = p.xy - pp.xy;\n    rr = dot (dr, dr);\n    if (n != mId && rr < rrCut) {\n      rri = 1. / rr;\n      rri3 = rri * rri * rri;\n      //f += 48. * rri3 * (rri3 - 0.5) * rri * dr;\n    }\n    // \"softer\" but less prone to instability\n    f += 1000.*dr*((rrCut-rr)+abs(rrCut-rr))/2.;\n  }\n  bLen = bFac * float (nMolEdge);\n  dr = 0.5 * (bLen + rCut) - abs (p.xy);\n  if (dr.x < rCut) {\n    if (p.x > 0.) dr.x = - dr.x;\n    rri = 1. / (dr.x * dr.x);\n    rri3 = rri * rri * rri;\n    //f.x += 48. * rri3 * (rri3 - 0.5) * rri * dr.x;\n    f.x += 200.*(sign(bLen+rCut-2.*p.x)-sign(bLen+rCut+2.*p.x))*(rCut+dr.x)*sign(dr.x)/2.;\n  }\n  if (dr.y < rCut) {\n    if (p.y > 0.) dr.y = - dr.y;\n    rri = 1. / (dr.y * dr.y);\n    rri3 = rri * rri * rri;\n    //f.y += 48. * rri3 * (rri3 - 0.5) * rri * dr.y;\n    f.y += 200.*(sign(bLen+rCut-2.*p.y)-sign(bLen+rCut+2.*p.y))*(rCut+dr.y)*sign(dr.y)/2.;\n  }\n  dt = deltat;\n  f.y += g;\n  p.zw += dt * f;\n  p.xy += dt * p.zw;\n  return p;\n}\n\nvec4 Init (int mId)\n{\n  vec4 p;\n  float x, y, t, vel;\n  const float pi = 3.14159;\n  y = float (mId / nMolEdge);\n  x = float (mId) - float (nMolEdge) * y;\n  t = 0.25 * (2. * mod (y, 2.) - 1.);\n  p.xy = (vec2 (x + t, y) - 0.5 * float (nMolEdge - 1))/pow(initDensity,0.5);\n  t = 2. * pi * Hashff (float (mId));\n  vel = initVel;\n  p.zw = vel * vec2 (cos (t), sin (t));\n  return p;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat, p;\n  int mId;\n  vec2 kv = floor (fragCoord);\n  mId = int (kv.x + txRow * kv.y);\n  if (kv.x >= txRow || mId > nMol) discard;\n  if (iFrame <= 5) {\n    bFac = 1.0/pow(density,0.5);\n    stDat = vec4 (0., bFac, 0., 0.);\n    if (mId < nMol) p = Init (mId);\n  } else {\n    stDat = Loadv4 (nMol);\n    ++ stDat.x;\n    bFac = stDat.y;\n    if (mId < nMol) p = Step (mId);\n    if (mPtr.z > 0. && stDat.x > 50.) {\n      stDat.x = 0.;\n      p = Init (mId);\n    }\n  }\n  Savev4 (mId, ((mId < nMol) ? p : stDat), fragColor, fragCoord);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// \"2D kinetic gas\" by minh - 2024, adapted from\n// \"Molecular Dynamics\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported Licensecons\n// configuration constants are moved here for convenience\nconst float cHashM = 43758.54;\nconst int nMolEdge = 30;\nconst int nMol = nMolEdge*nMolEdge;\nconst float txRow = float(nMolEdge);\nconst float deltat = 0.002;// simulation time step, smaller is more stable but slowlier\nconst float density = 0.2; // <= 1\nconst float initDensity = .5; //>= density and <= 1, for simulating free expansion\nconst float initVel = 20.; // high speed can lead to instability;\nconst float KEavg = .5*initVel*initVel; //average kinematic energy\nconst float g = 0.0; //gravitational acceleration, optional\nconst float barHeight = .02;//kinetic energy bar height, normalized\nconst float barWidth = .5; //bar width at expected value, normalized\nconst bool barVisible = true;\nconst int nbins = 30; //n.o. bins for kinetic energy spectrum\nconst float speclim = 4.;// mean normalized\nconst float specHeight = .2;\nconst float specOpacity = 0.25;","name":"Common","description":"","type":"common"}]}