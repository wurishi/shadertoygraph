{"ver":"0.1","info":{"id":"4dcBDH","date":"1525203704","viewed":537,"name":"Superellipsoid","username":"Holeum","description":"Superellipsoid formula visualization (convex case). Surface color based on Gaussian curvature.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","reflection","refraction","superformula","curvature","superellipse","superquadric","supershape","superellipsoid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n  Written by Ivan Shevchenko\n  \n  Superellipsoid with refraction in Cornell Box: https://www.shadertoy.com/view/7sSXRR\n*/\n\n\n#define M_PI 3.1415926535\n#define M_EPSILON 0.0001\n\n#define MAXIters 24\n#define InitialStepFactor 1.0 / 128.0\n#define SKYColor vec3(0.85, 1.05, 1.20)\n#define FOGColor vec3(0.70, 0.80, 1.00)\n\n\n// ------------------ Miscellaneous ----------------------\nfloat deg2rad(float deg)\n{\n    return(deg * M_PI / 180.0);\n}\n\nfloat infinite2Unit(float x)\n{\n    x = abs(x);\n    return(sqrt(x / (1.0 + x)));\n}\n\n// Viridis approximation - https://www.shadertoy.com/view/XtGGzG\nvec3 plasmaQuintic(float x)\n{\n\tvec4 x1 = vec4( 1.0, x, x * x, x * x * x ); // 1 x x2 x3\n\tvec4 x2 = x1 * x1.w * x; // x4 x5 x6 x7\n\treturn vec3(\n\t\tdot( x1.xyzw, vec4( +0.063861086, +1.992659096, -1.023901152, -0.490832805 ) ) + dot( x2.xy, vec2( +1.308442123, -0.914547012 ) ),\n\t\tdot( x1.xyzw, vec4( +0.049718590, -0.791144343, +2.892305078, +0.811726816 ) ) + dot( x2.xy, vec2( -4.686502417, +2.717794514 ) ),\n\t\tdot( x1.xyzw, vec4( +0.513275779, +1.580255060, -5.164414457, +4.559573646 ) ) + dot( x2.xy, vec2( -1.916810682, +0.570638854 ) ) );\n}\n\n// Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\n\nvec3 Linear2sRGB(const vec3 linear)\n{\n    return pow(linear, vec3(1.0 / 2.2));\n}\n// ------------------ Miscellaneous ----------------------\n\n\n// ------------------ BLAS/LAPACK elements ----------------------\nmat4 QuaternionToMatrix(vec4 q)\n{\n    mat4 m1 = mat4( q.w,  q.z, -q.y, q.x,\n                   -q.z,  q.w,  q.x, q.y,\n                    q.y, -q.x,  q.w, q.z,\n                   -q.x, -q.y, -q.z, q.w);\n\n    mat4 m2 = mat4( q.w,  q.z, -q.y, -q.x,\n                   -q.z,  q.w,  q.x, -q.y,\n                    q.y, -q.x,  q.w, -q.z,\n                    q.x,  q.y,  q.z,  q.w);\n\n    mat4 m = m1 * m2;\n\n    return(m);\n}\n\nmat4 AxisAngleToMatrix(vec3 axis, float angle)\n{\n    float s = sin(angle / 2.0);\n    float c = cos(angle / 2.0);\n\n    vec4 q = vec4(s, s, s, c);\n    q.x *= axis.x;\n    q.y *= axis.y;\n    q.z *= axis.z;\n\n    mat4 m = QuaternionToMatrix(q);\n    return(m);\n}\n\n// pitch (attitude) - rotation around X-axis\n// yaw (heading)    - rotation around Y-axis\n// roll (bank)      - rotation around Z-axis\nmat4 EulerToMatrix(float pitch, float yaw, float roll)\n{\n    // The definition can be found in glm/gtc/quaternion.hpp\n    vec3 c = vec3(cos(pitch / 2.0), cos(yaw / 2.0), cos(roll / 2.0));\n    vec3 s = vec3(sin(pitch / 2.0), sin(yaw / 2.0), sin(roll / 2.0));\n\n    vec4 q = vec4(0.0);\n\n    // XYZ ordering\n    q.x = s.x * c.y * c.z - c.x * s.y * s.z;\n    q.y = c.x * s.y * c.z + s.x * c.y * s.z;\n    q.z = c.x * c.y * s.z - s.x * s.y * c.z;\n    q.w = c.x * c.y * c.z + s.x * s.y * s.z;\n\n    //q = normalize(q);\n    mat4 m = QuaternionToMatrix(q);\n    return(m);\n}\n// ------------------ BLAS/LAPACK elements ----------------------\n\n\n// ------------------ Ray ------------------\nstruct Ray\n{\n\tvec3 Origin;\n\tvec3 Direction;\n};\n\nRay rayConstruct(vec2 uv, mat4 invProj, mat4 invView)\n{\n    // Ray in screen space\n    vec2 sXY = 2.0 * uv - 1.0;\n    vec4 sP0 = vec4(sXY, -1.0, 1.0);\n    vec4 sP1 = vec4(sXY,  1.0, 1.0);\n\n    // Ray in world space\n    vec4 wP0 = invProj * sP0; wP0 /= wP0.w;\n    vec4 wP1 = invProj * sP1; wP1 /= wP1.w;\n   \n    wP0 = invView * wP0;\n    wP1 = invView * wP1;\n    \n    Ray ray = Ray(invView[3].xyz, normalize(wP1.xyz - wP0.xyz));\n    return(ray);\n}\n// ------------------ Ray ------------------\n\n\n// ------------------ Plane ------------------\nstruct Plane\n{\n\tvec3 M;\n\tvec3 Normal;\n};\n\nPlane planeConstruct(vec3 point, vec3 normal)\n{\n    Plane pl;\n    pl.M = point;\n    pl.Normal = normal;\n   \n    return(pl);\n}\n\nbool planeIntersect(Plane pl, Ray ray)\n{\n    float denom = dot(ray.Direction, pl.Normal);\n    if(abs(denom) < M_EPSILON)\n    {\n        return(false);\n    }\n\n    float t = dot((pl.M - ray.Origin), pl.Normal) / denom;\n    if(t < 0.0)\n    {\n        return(false);\n    }\n\n    return(true);\n}\n\nbool planeIntersect(Plane pl, Ray ray, out vec3 ipos, out vec3 norm)\n{\n    float denom = dot(ray.Direction, pl.Normal);\n    if(abs(denom) < M_EPSILON)\n    {\n        return(false);\n    }\n\n    float t = dot((pl.M - ray.Origin), pl.Normal) / denom;\n    if(t < 0.0)\n    {\n        return(false);\n    }\n\n    ipos = ray.Origin + t * ray.Direction;\n    norm = pl.Normal;\n\n    return(true);\n}\n// ------------------ Plane ------------------\n\n\n// ------------------ Superellipsoid ------------------\nstruct Superellipsoid\n{\n\tvec3 Center;\n\tvec3 Radius;\n    vec2 Exponent;\n    mat3 Orientation;\n};\n\nSuperellipsoid superellipsoidConstruct(vec3 pos, vec3 radius)\n{\n    vec3 arg = 0.5 + 0.5 * sin(vec3(iTime) / vec3(2.0, 4.0, 3.0));\n    \n    // 0.1 - near to square form, 2.00 - diamond form\n    vec2 e = mix(vec2(0.1), vec2(2.0), arg.xy);\n    \n    vec3 axis0 = vec3(1.0, 0.0, 0.0);\n    vec3 axis1 = vec3(0.0, 1.0, 1.0);\n    vec3 axis2 = vec3(0.0, 0.0, 1.0);\n    vec3 axis = mix(axis0, mix(axis1, axis2, max(0.0, 2.0 * arg.z - 1.0)), min(1.0, 2.0 * arg.z));\n    mat4 o = AxisAngleToMatrix(normalize(axis), deg2rad(360.0 * mod(0.05 * iTime, 1.0)));\n    \n    Superellipsoid se;\n    se.Center = pos;\n    se.Radius = radius;\n    se.Exponent = e;\n    se.Orientation = mat3(o);\n    \n    return(se);\n}\n\n// Superellipsoid Inside-Outside Function\nfloat superellipsoidIOF(vec3 pos, vec3 dir, float t, Superellipsoid se)\n{\n    vec3 e = vec3(vec2(1.0) / se.Exponent.xy, se.Exponent.x / se.Exponent.y);\n    vec3 invr = vec3(1.0) / se.Radius;\n    vec3 p = pos + t * dir;\n\n    vec3 A = p * invr;\n    vec3 B = pow(A * A, e.xxy);\n    float E = B.x + B.y;\n    float F = pow(E, e.z);\n    float P = F + B.z;\n\n    float K = P - 1.0;\n    return(K);\n}\n\nvec3 superellipsoidNormal(vec3 p, Superellipsoid se)\n{\n    vec3 e = vec3(vec2(1.0) / se.Exponent.xy, se.Exponent.x / se.Exponent.y);\n    vec3 g = 2.0 * e;\n    vec3 invr = vec3(1.0) / se.Radius;\n\n    vec3 A = p * invr;\n    vec3 B = pow(A * A, e.xxy);\n    vec3 C = B / A;\n\n    float E = B.x + B.y;\n    float F = pow(E, e.z);\n    float G = e.z * (F / E);\n\n    vec3 n = g.xxy * C * invr;\n    n.xy *= G;\n\n    n = normalize(n);\n    return(n);\n}\n\n// Ron Goldman \"Curvature formulas for implicit curves and surfaces\"\nfloat superellipsoidGaussianCurvature(Superellipsoid se, vec3 pos)\n{\n    vec3 e = vec3(vec2(1.0) / se.Exponent.xy, se.Exponent.x / se.Exponent.y);\n    vec3 invr = vec3(1.0) / se.Radius;\n    \n    vec3 p = (pos - se.Center) * se.Orientation;\n    \n    vec3 A = p * invr;\n    vec3 B = pow(A * A, e.xxy);\n    float E = B.x + B.y;\n    float F = pow(E, e.z);\n    float P = F + B.z;\n\n    float Fx = e.z * (F / E) * (2.0 * e.x * (B.x / A.x) * invr.x);\n    float Fy = e.z * (F / E) * (2.0 * e.x * (B.y / A.y) * invr.y);\n    float Fz = 2.0 * e.y * (B.z / A.z) * invr.z;\n\n    float Fxx = Fx * (e.z - 1.0) * (1.0 / E) * (2.0 * e.x * (B.x / A.x) * invr.x) + Fx * (2.0 * e.x - 1.0) * (1.0 / A.x) * invr.x;\n    float Fyy = Fy * (e.z - 1.0) * (1.0 / E) * (2.0 * e.x * (B.y / A.y) * invr.y) + Fy * (2.0 * e.x - 1.0) * (1.0 / A.y) * invr.y;\n    float Fzz = Fz * (2.0 * e.y - 1.0) * (1.0 / A.z) * invr.z;\n\n    float Fyx = Fx * (e.z - 1.0) * (1.0 / E) * (2.0 * e.x * (B.y / A.y) * invr.y);\n    float Fxy = Fyx;\n\n    float Fxz = 0.0;\n    float Fzx = 0.0;\n\n    float Fyz = 0.0;\n    float Fzy = 0.0;\n    \n    vec3 nf = vec3(Fx, Fy, Fz);\n    mat3 hs = mat3(vec3(Fyy * Fzz - Fyz * Fzy, Fxz * Fzy - Fxy * Fzz, Fxy * Fyz - Fxz * Fyy),\n                   vec3(Fyz * Fzx - Fyx * Fzz, Fxx * Fzz - Fxz * Fzx, Fyx * Fxz - Fxx * Fyz),\n                   vec3(Fyx * Fzy - Fyy * Fzx, Fxy * Fzx - Fxx * Fzy, Fxx * Fyy - Fxy * Fyx));\n    \n    float D = dot(nf, nf);\n    float Kg = dot(nf, hs * nf) / (D * D);\n\n    return(Kg);   \n}\n\nbool superellipsoidIntersect(Superellipsoid se, Ray ray, float tolerance)\n{\n    // OBB -> AABB\n    vec3 vmin = -se.Radius;\n    vec3 vmax =  se.Radius;\n\n    // Ray vs OBB -> Ray vs AABB\n    mat3 invm = transpose(se.Orientation);\n    vec3 pos = invm * (ray.Origin - se.Center);\n    vec3 dir = invm * ray.Direction;\n    \n    // Hit points with AABB\n    vec3 v1 = (vmin - pos) / dir;\n    vec3 v2 = (vmax - pos) / dir;\n    vec3 n = min(v1, v2);\n    vec3 f = max(v1, v2);\n\n    float tn = max(n.x, max(n.y, n.z));\n    float tf = min(f.x, min(f.y, f.z));\n    if(tf < 0.0 || tn > tf)\n    {\n        return(false);\n    }\n    \n    // Iterative proceduare of finding intersection point with superellipsoid    \n    float dt = InitialStepFactor * (tf - tn);\n    float t0 = tn - 2.0 * dt;\n    float t1 = tn - dt;\n\n    // secant method of root refinement\n    float S0 = superellipsoidIOF(pos, dir, t0, se);\n    float S1 = superellipsoidIOF(pos, dir, t1, se);\n\n    bool success = false;\n    for(int i = 0; i < MAXIters; i++)\n    {\n        float t = t0 - S0 * (t1 - t0) / (S1 - S0);\n\n        t0 = t1;\n        t1 = t;\n\n        S0 = S1;\n        S1 = superellipsoidIOF(pos, dir, t1, se);\n\n        float t_error = abs(t1 - t0) / max(10.0 * tolerance, max(t0, t1));\n        float s_error = S1 * S1;\n        if(t_error < tolerance && s_error < tolerance)\n        {\n            success = true;\n            break;\n        }\n    }    \n    return(success);\n}\n\nbool superellipsoidIntersect(Superellipsoid se, Ray ray, float tolerance, out vec3 ipos, out vec3 norm)\n{\n    // OBB -> AABB\n    vec3 vmin = -se.Radius;\n    vec3 vmax =  se.Radius;\n\n    // Ray vs OBB -> Ray vs AABB\n    mat3 invm = transpose(se.Orientation);\n    vec3 pos = invm * (ray.Origin - se.Center);\n    vec3 dir = invm * ray.Direction;\n    \n    // Hit points with AABB\n    vec3 v1 = (vmin - pos) / dir;\n    vec3 v2 = (vmax - pos) / dir;\n    vec3 n = min(v1, v2);\n    vec3 f = max(v1, v2);\n\n    float tn = max(n.x, max(n.y, n.z));\n    float tf = min(f.x, min(f.y, f.z));\n    if(tf < 0.0 || tn > tf)\n    {\n        return(false);\n    }\n    \n    // Iterative proceduare of finding intersection point with superellipsoid\n    float dt = InitialStepFactor * (tf - tn);\n    float t0 = tn - 2.0 * dt;\n    float t1 = tn - dt;\n\n    // secant method of root refinement\n    float S0 = superellipsoidIOF(pos, dir, t0, se);\n    float S1 = superellipsoidIOF(pos, dir, t1, se);\n\n    bool success = false;\n    for(int i = 0; i < MAXIters; i++)\n    {\n        float t = t0 - S0 * (t1 - t0) / (S1 - S0);\n\n        t0 = t1;\n        t1 = t;\n\n        S0 = S1;\n        S1 = superellipsoidIOF(pos, dir, t1, se);\n\n        float t_error = abs(t1 - t0) / max(10.0 * tolerance, max(t0, t1));\n        float s_error = S1 * S1;\n        if(t_error < tolerance && s_error < tolerance)\n        {\n            success = true;\n        \n            vec3 lpos = pos + t1 * dir;\n            norm = superellipsoidNormal(lpos, se);\n            ipos = se.Orientation * lpos + se.Center;\n            norm = se.Orientation * norm;\n            break;\n        }\n    }\n\n    return(success);\n}\n// ------------------ Superellipsoid ------------------\n\n\n// ------------------ Camera ----------------------\nstruct Camera\n{\n    mat4 invProj;\n    mat4 invView;\n};\n\nCamera cameraConstruct(float fovy, float aspect, float near, float far)\n{\n    fovy = deg2rad(fovy);\n\n    Camera camera;\n    camera.invView = mat4(1.0);\n\n    float d = 1.0 / tan(0.5 * fovy);\n    camera.invProj = mat4(aspect / d, 0.0,      0.0, 0.0,\n                          0.0,   1.0 / d,  0.0, 0.0,\n                          0.0,   0.0,      0.0, (near - far) / (2.0 * near * far),\n                          0.0,   0.0,     -1.0, (near + far) / (2.0 * near * far));\n\n    return(camera);\n}\n\nvoid cameraSetOrientation(inout Camera camera, float pitch, float yaw, float roll)\n{\n    pitch = deg2rad(pitch);\n    yaw = deg2rad(yaw);\n    roll = deg2rad(roll);\n    \n    mat4 m = camera.invView;\n    camera.invView = EulerToMatrix(pitch, yaw, roll);\n    camera.invView[3] = m[3];\n}\n\nvoid cameraSetPosition(inout Camera camera, vec3 origin)\n{\n    camera.invView[3] = vec4(origin, 1.0);\n}\n\nRay cameraGetRay(Camera camera, vec2 uv)\n{\n    Ray ray = rayConstruct(uv, camera.invProj, camera.invView);\n    return(ray);\n}\n// ------------------ Camera ----------------------\n\n\n// ------------------ Lighting ------------------\nstruct Light\n{\n\tvec3 Color;\n\tvec3 Position;\n\tvec3 Direction;\n};\n\nLight constructLight(vec3 c, vec3 o, float theta, float phi)\n{\n    // https://en.wikipedia.org/wiki/Spherical_coordinate_system\n    float ct = cos(theta);\n    float st = sin(theta);\n\n    float cp = cos(phi);\n    float sp = sin(phi);\n    \n    float r = 1.0;\n    float x = r * st * cp;\n    float y = r * st * sp;\n    float z = r * ct;\n\n    Light l;\n    l.Color = c;\n\tl.Position = o;\n\tl.Direction = vec3(x, y, z);\n    \n    return(l);\n}\n\n// Ashikhmin Shirley 2000 (isotropic case)\nvec3 calculateLighting(vec3 I, vec3 L, vec3 V, vec3 N, float Rd, float Rs, float exponent)\n{\n    vec3 H = normalize(L + V);\n    float HdotV = dot(H, V);\n    float NdotH = dot(N, H);\n    float NdotV = dot(N, V);\n    float NdotL = dot(N, L);\n\n    float rho_d = 28.0 / (23.0 * M_PI) * Rd * (1.0 - pow(1.0 - NdotV / 2.0, 5.0)) * (1.0 - pow(1.0 - NdotL / 2.0, 5.0));\n    rho_d *= (1.0 - Rs); // coupled diffuse\n\n    float F = Rs + (1.0 - Rs) * pow(1.0 - HdotV, 5.0);\n    float rho_s = ((exponent + 1.0) / (8.0 * M_PI)) * F * pow(max(NdotH, 0.0), exponent) / (HdotV * max(NdotV, NdotL));\n\n    vec3 brightness = max(0.0, NdotL) * I * (rho_d + rho_s);\n    return(brightness);\n}\n\nfloat calcShadowAttenuation(vec3 ipoint, Light dl, Superellipsoid se)\n{\n    Ray ray = Ray(ipoint, dl.Direction);\n    bool isIntersect = superellipsoidIntersect(se, ray, 1.0e-06);\n    \n    return((isIntersect)? 0.25: 1.0);\n}\n// ------------------ Lighting ------------------\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 P = vec3(0.0, 0.0, 0.0); // default viewer position\n    float aspect = iResolution.x / iResolution.y;\n    float near = 0.1;\n    float far = 32.0;\n\n    Camera camera = cameraConstruct(45.0, aspect, near, far);\n    cameraSetOrientation(camera, 0.0, 0.0, 0.0);\n    cameraSetPosition(camera, P);\n\n    vec2 uv = fragCoord / iResolution.xy;\n    Ray ray = cameraGetRay(camera, uv);\n\n    // scene rendering\n    vec3 pos = vec3(0.0, 1.0, 0.0);\n    vec3 normal = vec3(0.0, -1.0, 0.0);\n    Plane spl = planeConstruct(pos, normal); // sky plane\n\n    pos = vec3(0.0, -1.0, 0.0);\n    normal = vec3(0.0, 1.0, 0.0);\n    Plane gpl = planeConstruct(pos, normal); // ground plane\n\n    pos = vec3(0.0, 0.0, -2.5);\n    vec3 radius = vec3(1.0 / 3.0, 1.0 / 3.0, 1.0 / 2.0);\n    Superellipsoid se = superellipsoidConstruct(pos, radius); // object\n\n    vec3 ipoint = ray.Direction * far;\n    vec3 color = SKYColor + ray.Direction.y * 0.72;\n    \n    Light sun;\n    sun.Color = 1.85 * vec3(1.0, 1.0, 1.0);\n    sun.Direction = normalize(vec3(0.5, 0.5, 1.0));\n\n    // ray vs superellipsoid\n    normal = vec3(0.0);\n    bool isIntersect = superellipsoidIntersect(se, ray, 1.0e-06, ipoint, normal);\n    if(isIntersect)\n    {\n        float gc = superellipsoidGaussianCurvature(se, ipoint);\n        vec3 albedo = plasmaQuintic(infinite2Unit(gc));\n\n        // account sun lighting \n        vec3 brightness = calculateLighting(sun.Color, sun.Direction, -ray.Direction, normal, 1.0, 0.25, 128.0);\n\n        Ray ray2 = Ray(ipoint, reflect(ray.Direction, normal));\n        vec3 ipoint2 = vec3(0.0);\n        vec3 normal2 = vec3(0.0);\n\n        // account sky plane lighting \n        isIntersect = planeIntersect(spl, ray2, ipoint2, normal2);\n        if(isIntersect)\n        {\n            brightness += calculateLighting(SKYColor, -spl.Normal, ray2.Direction, normal, 1.0, 0.25, 32.0);\n        }\n\n        // account ground plane lighting (used fake ground colour)\n        isIntersect = planeIntersect(gpl, ray2, ipoint2, normal2);\n        if(isIntersect)\n        {\n            float f = mod(floor(6.0 * ipoint2.z) + floor(6.0 * ipoint2.x), 2.0);\n            vec3 GNDColor = 0.4 + f * vec3(0.6);\n            brightness += calculateLighting(SKYColor * GNDColor, -gpl.Normal, ray2.Direction, normal, 1.0, 0.25, 32.0);\n        }\n\n        color = albedo * brightness;\n    }\n    else\n    {\n        //ray vs ground plane\n        isIntersect = planeIntersect(gpl, ray, ipoint, normal);\n        if(isIntersect)\n        {\n            // account sun lighting \n            vec3 brightness = calculateLighting(sun.Color, sun.Direction, -ray.Direction, normal, 1.0, 0.0, 32.0);\n\n            // account sky plane lighting \n            brightness += calculateLighting(SKYColor, -spl.Normal, -ray.Direction, normal, 1.0, 0.0, 32.0);\n\n            // calculate albedo of ground plane\n            float f = mod(floor(6.0 * ipoint.z) + floor(6.0 * ipoint.x), 2.0);\n            vec3 albedo = 0.4 + f * vec3(0.6);\n\n            color = albedo * brightness;\n\n            // shadow\n            float attenuation = calcShadowAttenuation(ipoint, sun, se);\n            color *= attenuation;\n        }\n    }\n\n    // Tone mapping\n    color = ACESFilm(color);\n    \n    // Exponential distance fog\n    float distance = length(ipoint - P);\n    color = mix(color, 0.85 * FOGColor, 1.0 - exp2(-0.0055 * distance * distance));\n\n    // Gamma correction\n    color = Linear2sRGB(color);\n\n    float vignette = pow(32.0 * uv.x * uv.y * (1.0 - uv.x) * (1.0 - uv.y), 0.05);\n    fragColor = vec4(color * vignette, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}