{"ver":"0.1","info":{"id":"llGSzV","date":"1485036651","viewed":142,"name":"First-Order Slope Field Grapher","username":"4onen","description":"A first order slope field drawing toy.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["functions","slopefield","firstorder"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n#define FUNCTION -x/y\n\n#define MIN_X -10.0\n#define MAX_X 10.0\n#define STEP_X 0.5\n\n#define MIN_Y -10.0\n#define MAX_Y 10.0\n#define STEP_Y 0.5\n\n\n#define eps 0.2\n#define PI 3.14159265358979323846264338\n\nfloat axes(in vec2 uv){\n    uv = abs(uv);\n    \n    float epsx = eps*(abs(MIN_X)+abs(MAX_X))/25.0;\n    float epsy = eps*(abs(MIN_Y)+abs(MAX_Y))/25.0;\n    \n    float x = 1.0-smoothstep(0.0,epsx,uv.x+uv.x);\n    float y = 1.0-smoothstep(0.0,epsy,uv.y+uv.y);\n    \n    return max(x,y);\n}\n\nvec2 localify(vec2 vec){\n    vec += 0.5*vec2(STEP_X,STEP_Y);\n    return vec2\n        (mod(vec.x,STEP_X)-0.5*STEP_X\n        ,mod(vec.y,STEP_Y)-0.5*STEP_Y\n        );\n}\n\nvec4 adjustCoordSystem(vec2 uv){\n    vec2 local = localify(uv);\n    uv += 0.5*vec2(STEP_X,STEP_Y);\n    uv.x = floor((uv.x)/STEP_X)*STEP_X;\n    uv.y = floor((uv.y)/STEP_Y)*STEP_Y;\n    \n    return vec4(uv,local);\n}\n\n/*\nfloat lineDraw(vec4 adjusted){\n    if(length(adjusted.wz)>length(vec2(STEP_X,STEP_Y))/4.0) return 0.0;\n    \n    float x = adjusted.x;\n    float y = adjusted.y;\n    float m = (FUNCTION);\n    \n    float line = 1.0-smoothstep\n                  (0.1\n                  ,eps*clamp((abs(m)),0.75,1000000000000000000000000.0)\n                  ,abs(adjusted.w-adjusted.z*m)*3.0\n                  );\n    return line;\n}\n//*/\n\n\nfloat lineDraw(vec4 adjusted){\n    if(length(adjusted.wz)>length(vec2(STEP_X,STEP_Y))/3.0) return 0.0;\n    \n    float x = adjusted.x;\n    float y = adjusted.y;\n    float z = adjusted.z;\n    float w = adjusted.w;\n    float m = clamp(FUNCTION,-1000000.0/eps,1000000.0/eps);\n    \n    float c = y-m*x;\n    \n    float intersectX = (m*w+z)/(m*m+1.0);\n    vec2 intersect = vec2(intersectX, m*intersectX);\n    \n    float d = length(localify(adjusted.zw-intersect));\n    \n    float line = 1.0-smoothstep(eps/6.0,eps/4.0,d);\n    \n    return line;\n}//*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x *= abs(MIN_X)+abs(MAX_X);\n    uv.x += MIN_X;\n    uv.y *= abs(MIN_Y)+abs(MAX_Y);\n    uv.y += MIN_Y;\n    \n    vec3 ret = vec3(0.0);\n    \n    const vec3 gridCol = vec3(0.4);\n    const vec3 axesCol = vec3(0.7,0.2,0.2);\n    const vec3 lineCol = vec3(0.1,0.1,1.0);\n    \n    \n    \n    vec4 adjusted = adjustCoordSystem(uv);\n    \n    ret = mix(ret, gridCol, axes(adjusted.wz));\n    \n    ret = mix(ret, axesCol, axes(uv));\n    \n    ret = mix(ret, lineCol, lineDraw(adjusted));\n    \n\tfragColor = vec4(ret,1.0);\n}","name":"Image","description":"","type":"image"}]}