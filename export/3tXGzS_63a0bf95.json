{"ver":"0.1","info":{"id":"3tXGzS","date":"1556628986","viewed":320,"name":"Rolling Regular Polygons","username":"tpfto","description":"A regular polygon can be rolled on a road composed of pieces of catenaries. See [url=https://momath.org/16-square-wheeled-trike-3/]here[/url] for a real-life demo.","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["2d","math","geometry"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Rolling a regular polygon on piecewise catenary roads, adapted from Hall and Wagon; https://doi.org/10.2307/2691240\n// plotter forked from https://www.shadertoy.com/view/4tB3WV\n\n// number of polygon sides\n#define NGON 4\n\n// some constants\n#define PI 3.14159265359\n\n// dark and light colors from Solarized (https://ethanschoonover.com/solarized/)\n#define DARK vec3(0., 0.169, 0.212)\n#define LIGHT vec3(0.992, 0.965, 0.89)\n#define GRAY vec3(0.396, 0.482, 0.514)\n\n// Solarized \"accent colors\"\n#define MAGENTA vec3(0.827, 0.212, 0.51)\n#define BLUE vec3(0.149, 0.545, 0.824)\n#define GREEN vec3(0.522, 0.6, 0.)\n\n// comment out to switch to light mode\n#define DARK_MODE\n\n// XY range of the display.\n#define DISP_SCALE 3.\n\n// Line thickness (in pixels).\n#define LINE_SIZE 2.\n\nconst vec2 GRADH = vec2(0.01, 0.);\n\n// central difference\n#define GRAD(f, p) (0.5 * vec2(f(p - GRADH.xy) - f(p + GRADH.xy), f(p - GRADH.yx) - f(p + GRADH.yx)) / GRADH.xx)\n\n// PLOT(Function, Color, Destination, Screen Position)\n#define PLOT(f, c, d, p) d = mix(c, d, smoothstep(0.0, (LINE_SIZE / iResolution.y * DISP_SCALE), abs(f(p)) / length(GRAD(f, p))))\n\n// utility function\n#define cis(a) vec2( cos(a), sin(a) )\n\n// for drawing points and lines\n\n#define drawPrimitive(p, c, d) d = mix(c, d, p)\n\nfloat SEGMENT(vec2 a, vec2 b, vec2 p)\n{\n    vec2 pa = p - a, ba = b - a;\n    return smoothstep(0., (LINE_SIZE / iResolution.y * DISP_SCALE), length(pa - ba * clamp( dot(pa, ba)/dot(ba, ba), 0., 1. )));\n}\n\nfloat POINT(vec2 pt, vec2 p)\n{\n    float psize = 2.5, sc = DISP_SCALE/iResolution.y;\n    return smoothstep(0., 1.1 * sc, distance(pt, p) - psize * sc);\n}\n\n// functions for rolling a regular polygon\n\n#define ANG PI/float(NGON)\n#define APO cos(ANG) // apothem of regular polygon\n#define HA asinh(tan(ANG)) // half the period of the road\n#define PR 1.0/(HA * APO)\n#define SA 0.5 * PI - ANG\n\nfloat theta(float x)\n{   \n      return -atan(sinh((mod(1. + PR * x, 2.) - 1.) * HA)) - SA;\n}\n\nfloat Road(vec2 p)\n{       \n      return p.y + APO * cosh(HA * (mod(1. + PR * p.x, 2.) - 1.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 aspect = iResolution.xy / iResolution.y;\n\tvec2 uv = ( fragCoord.xy / iResolution.y ) - 0.5 * aspect;\n\tuv *= DISP_SCALE;\n\t\n    // draw horizontal axis to highlight rolling polygon's center\n    float ax = smoothstep(0., (3. / iResolution.y) * DISP_SCALE, abs(uv.y));\n    \n    vec3 col = vec3(1.);\n    #ifdef DARK_MODE\n    col = mix(GRAY, DARK, ax);\n    #else\n    col = mix(GRAY, LIGHT, ax);\n    #endif\n\n    // show catenary road\n    PLOT(Road, BLUE, col, uv);\n\n    // roll the polygon\n    float mul = HA * floor((0.5 * aspect.x/HA) * DISP_SCALE) + 2. * DISP_SCALE;\n    vec2 p = vec2(mul * mod(iTime/mul - 0.5, 1.) - 0.5 * mul, 0.);\n    float th = theta(p.x);\n    \n    for (int j = 0; j < NGON; j++) drawPrimitive(SEGMENT(p + cis(2. * ANG * float(j) + th), p + cis(2. * ANG * float(j + 1) + th), uv), GREEN, col);\n    \n    // show polygon's center\n    drawPrimitive(POINT(p, uv), MAGENTA, col);\n\t\n\tfragColor = vec4( col, 1. );\n}","name":"Image","description":"","type":"image"}]}