{"ver":"0.1","info":{"id":"ctVBzt","date":"1702901464","viewed":171,"name":"Return of the blob","username":"_pwd_","description":"Stylized Diorama.","likes":10,"published":1,"flags":96,"usePreview":1,"tags":["raymarching","animation","blob","stylized","diorama"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"lsd3RX","filepath":"https://soundcloud.com/colourfultheory/pacman-theme-song-trap-remix","previewfilepath":"https://soundcloud.com/colourfultheory/pacman-theme-song-trap-remix","type":"musicstream","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n//\n//\n// Return of the blob \n//\n// Short before upcoming xmas I decided to start a little diorama-series as practise and finger exercise. \n// More to come the next weeks.\n//\n//\n//\n// This shader shall exist in its/this form on shadertoy.com only \n// You shall not use this shader in any commercial or non-commercial product, website or project. \n// This shader is not for sale nor can´t be minted (ecofriendly or not) as NFT\n//\n//\n// // As part of a diorama series...\n//\n// https://www.shadertoy.com/view/DlKBDh\n//\n//\n//\n//\n//\n//\n//\n//\n// Related examples\n//\n// IQ´s article for sure\n// https://iquilezles.org/articles/distfunctions/\n//  \n//\n//\n\n\nvec3 bloomTile(float lod, vec2 offset, vec2 uv)\n{\n    return textureLod(iChannel1, uv * exp2(-lod) + offset, 0.0).rgb;\n}\n\nvec3 getBloom(vec2 uv)\n{\n    vec3 blur = vec3(0.0);\n    vec2 lOffsetFix = vec2(0.00025, 0.0005);\n    blur = pow(bloomTile(2., vec2(0.0, 0.0) + lOffsetFix, uv),vec3(2.2))       \t   \t+ blur;\n    blur = pow(bloomTile(3., vec2(0.3, 0.0) + lOffsetFix, uv),vec3(2.2)) * 1.3        + blur;\n    blur = pow(bloomTile(4., vec2(0.0, 0.3) + lOffsetFix, uv),vec3(2.2)) * 1.6        + blur;\n    blur = pow(bloomTile(5., vec2(0.1, 0.3) + lOffsetFix, uv),vec3(2.2)) * 1.9 \t   \t+ blur;\n    blur = pow(bloomTile(6., vec2(0.2, 0.3) + lOffsetFix, uv),vec3(2.2)) * 2.2 \t   \t+ blur;\n\n    return blur * BLOOM_RANGE;\n}\n\nvec3 aces_tonemap(vec3 color){\t\n\tmat3 m1 = mat3(\n        0.59719, 0.07600, 0.02840,\n        0.35458, 0.90834, 0.13383,\n        0.04823, 0.01566, 0.83777\n\t);\n\tmat3 m2 = mat3(\n        1.60475, -0.10208, -0.00327,\n        -0.53108,  1.10813, -0.07276,\n        -0.07367, -0.00605,  1.07602\n\t);\n\tvec3 v = m1 * color;    \n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\treturn pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));\t\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    \n    vec4 col = texture(iChannel0, uv);\n    col.rgb += getBloom(uv);\n    col.rgb = aces_tonemap(col.rgb);\n    \n    fragColor = vec4(col.rgb, 1.0);\n}\n/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\t\n    vec2 p = (fragCoord*1.5-iResolution.xy)/iResolution.y;\n    p.y -= 0.35;\n    p.x -= 0.45;\n    float camTime = iTime;\n    float time = iTime;\n\n    \n    vec4 col = texture(iChannel0, uv);\n    col.rgb = aces_tonemap(col.rgb);\n\n\n    fragColor = vec4(col.rgb, 1.0);\n}*/","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//////////////////////////////////////////////////////////////////////////////////////\n// defines & constants\n//////////////////////////////////////////////////////////////////////////////////////\n\n//Bloom\n#define BLOOM_SIZE (0.5)\n#define BLOOM_THRESHOLD (1.01)\n#define BLOOM_RANGE (0.3)\n#define BLOOM_FRAME_BLEND (0.2)\n\n//utility defines\n#define ZERO   (min(1,0))\n#define X_AXIS vec3(1,0,0)\n#define Y_AXIS vec3(0,1,0)\n#define Z_AXIS vec3(0,0,1)\n\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (sqrt(5)*0.5 + 0.5)\n\n// Materials\n#define MAT_WOOD  101\n#define MAT_LEAFS 102\n#define MAT_UNDERWATER 301\n#define MAT_PLANT 701\n#define MAT_STONE 801\n\n#define MAT_GROUNDPLATE 203\n#define MAT_CHARACTERBASE 204\n#define MAT_REFLSPHERE 205\n#define MAT_ROCKFORMATION 206\n#define MAT_COIL 207\n#define MAT_SLIMER 208\n#define MAT_EYE 209\n#define MAT_EYE_PUPIL 210\n#define MAT_CLOUDS 211\n#define MAT_EYE_MOUTH 212\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n//////////////////////////////////////////////////////////////////////////////////////\n// main raymarching\n//////////////////////////////////////////////////////////////////////////////////////\n// Specular lighting\n\n//////////////////////////////////////////////////////////////////////////////////////\n// utility functions\n//////////////////////////////////////////////////////////////////////////////////////\nvec3 ref;\nmat3 rotation(vec3 axis, float angle)\n{\n    //axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return inverse(mat3(oc * axis.x * axis.x + c, \n                        oc * axis.x * axis.y - axis.z * s,  \n                        oc * axis.z * axis.x + axis.y * s, \n                        oc * axis.x * axis.y + axis.z * s,  \n                        oc * axis.y * axis.y + c,           \n                        oc * axis.y * axis.z - axis.x * s,  \n                        oc * axis.z * axis.x - axis.y * s,  \n                        oc * axis.y * axis.z + axis.x * s,  \n                        oc * axis.z * axis.z + c));\n}\n\nvec3 rotateX(vec3 pos, float alpha) {\n    mat4 trans= mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(alpha), -sin(alpha), 0.0, 0.0, sin(alpha), cos(alpha), 0.0, 0.0, 0.0, 0.0, 1.0);\n    return vec3(trans * vec4(pos, 1.0));\n}\n\n\nvec3 rotateY(vec3 pos, float alpha) {\n    mat4 trans2= mat4(cos(alpha), 0.0, sin(alpha), 0.0, 0.0, 1.0, 0.0, 0.0,-sin(alpha), 0.0, cos(alpha), 0.0, 0.0, 0.0, 0.0, 1.0);\n    return vec3(trans2 * vec4(pos, 1.0));\n}\n\nmat2 rotMat(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2 (c,-s,s,c);\n}\n\n//////////////////////////////////////////////////////////////////////////////////////\n// sdf blend & domain repetition (\n//////////////////////////////////////////////////////////////////////////////////////\n\n//HG\nfloat fOpUnionRound(float a, float b, float r) \n{\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\nfloat pModPolar(inout vec2 p, float repetitions) \n{\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n// Repeat in two dimensions\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n\n// Same, but mirror every second cell so all boundaries match\nvec2 pModMirror2(inout vec2 p, vec2 size) {\n\tvec2 halfsize = size*0.5;\n\tvec2 c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\tp *= mod(c,vec2(2))*2.0 - vec2(1.0);\n\treturn c;\n}\n\nfloat fOpIntersectionRound(float a, float b, float r)\n{\n\tvec2 u = max(vec2(r + a,r + b), vec2(0));\n\treturn min(-r, max (a, b)) + length(u);\n}\n\nfloat fOpDifferenceRound (float a, float b, float r)\n{\n\treturn fOpIntersectionRound(a, -b, r);\n}\n\n//IQ\nfloat opSmoothUnion( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n//IQ\nfloat opSubtraction( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\n// min/max polynomial\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat smax(float a, float b, float k)\n{\n    return smin(a, b, -k);\n}\n\nfloat smoothDiff(float d2, float d1, float k) \n{\n    float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0 );\n    return mix(d2, -d1, h ) + k * h * (1.0 - h);\n}\n\nvec3 opBend(vec3 p, float bend)\n{\n    float c = cos(bend * p.y);\n    float s = sin(bend * p.y);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\nvec3 opRipple(vec3 p)\n{\n\treturn vec3(p.x,p.y+0.01*sin(p.x*16.3+p.z*(2.5 + cos(iTime * 0.6) * 10.0) ),p.z);\t\n}\n\n//////////////////////////////////////////////////////////////////////////////////////\n// basic sdf shapes\n//////////////////////////////////////////////////////////////////////////////////////\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdTorus(vec3 p, vec2 t) \n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdRoundBaseBox( vec3 p, vec3 b, float r )\n{\n    float b1 = sdRoundBox(p,b,r);\n    float b2 = sdRoundBox(p + vec3(-0.08,0.0,0.3),vec3(0.07, 0.005, 0.05),r);\n    \n    return min(b1,b2);\n}\n\nvec3 cellpos;\nvec3 signvec;\nvec3 subpos;\nfloat fsign;\n\nfloat cf(vec3 pos) {\n\t\n\tcellpos=pos-floor(pos);\n\t\n\tsignvec=2.0*step(0.5,cellpos)-1.0;\n\tfsign=signvec.x*signvec.y*signvec.z;\n\t\n\tsubpos=abs(abs(cellpos-0.5)-0.25);\n\t\n\treturn fsign*(max(max(subpos.x,subpos.y),subpos.z)-0.25);\n\t\n}\n\nfloat sdCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n    float x = sqrt( papa - paba*paba*baba );\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\nfloat sdOctogonPrism( in vec3 p, in float r, float h )\n{\n  const vec3 k = vec3(-0.9238795325,   // sqrt(2+sqrt(2))/2 \n                       0.3826834323,   // sqrt(2-sqrt(2))/2\n                       0.4142135623 ); // sqrt(2)-1 \n  // reflections\n  p = abs(p);\n  p.xy -= 2.0*min(dot(vec2( k.x,k.y),p.xy),0.0)*vec2( k.x,k.y);\n  p.xy -= 2.0*min(dot(vec2(-k.x,k.y),p.xy),0.0)*vec2(-k.x,k.y);\n  // polygon side\n  p.xy -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  vec2 d = vec2( length(p.xy)*sign(p.y), p.z-h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdPyramid( in vec3 p, in float h, in float scale )\n{\n    float m2 = h*h + 0.25;\n    \n    // symmetry\n    p.xz = abs(p.xz);\n    p.xz = (p.z>p.x) ? p.zx : p.xz;\n    p.xz -= scale;\n\t\n    // project into face plane (2D)\n    vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n    float s = max(-q.x,0.0);\n    float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n\tfloat b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n    float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n    // recover 3D and scale, and add sign\n    float r = sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n    r += sin(15.*p.x)*sin(10.*p.y + 15.5)*sin(18.*p.z) * 0.04;\n    \n    return r;\n}\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length2(p.xz)-t.x,p.y);\n    return length6(q)-t.y;\n}\n\nfloat sdLink( vec3 p, float le, float r1, float r2 )\n{\n  vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n  return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// sdf shape combinations\n//////////////////////////////////////////////////////////////////////////////////////\n\nfloat gTime = 0.0;\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat teethFormation(vec3 pos)\n{\n    float v = 1e10;\n    vec3 np = opBend(pos, 0.65);\n    vec3 np1 = opBend(pos, 1.15);\n    vec3 np2 = rotateY(opBend(pos, -.55),0.5);\n\n    v = min(v, sdBox(np, vec3(0.0125,0.0115,0.01)));\n    v += sin(30.*pos.x)*sin(30.*pos.y)*sin(30.*pos.z) * 0.01;  \n    return v;\n}\n\nfloat rockFormation(vec3 pos)\n{\n    float v = 1e10;\n    vec3 np = opBend(pos, -0.75);\n    vec3 np1 = opBend(pos, 1.15);\n    vec3 np2 = rotateY(opBend(pos, -.55),0.5);\n\n    v = min(v, sdPyramid(rotateY(np,-0.2) + vec3(0.26, 0.11, -0.17), 1.53, 0.10));\n    v = min(v, sdPyramid(opBend(rotateY(np1 + vec3(0.32, 0.18, 0.09),0.5),0.5), 2.23, 0.13));\n    v = min(v, sdPyramid(np2 + vec3(0.37, 0.21, 0.15), 1.53, 0.1));\n    v = min(v, sdPyramid( opBend(rotateX(np2,-0.1) + vec3(0.56, 0.231, 0.241), -1.48), 1.53, 0.10));\n    \n    v = min(v, sdPyramid(np + vec3(-0.22, 0.13, 0.15), 1.53, 0.10));\n    v = min(v, sdPyramid(np1 + vec3(-0.32, 0.21, 0.09), 1.23, 0.11));\n    v = min(v, sdPyramid(np2 + vec3(-0.37, 0.21, -0.15), 1.53, 0.1));\n    v = min(v, sdPyramid( rotateX(np2,0.1) + vec3(-0.52, 0.131, -0.161), 1.53, 0.10));\n    v = min(v, sdPyramid( pos + vec3(-0.52, 0.331, -0.216), 1.53, 0.10));\n    \n    v = opSubtraction( -v, sdBox( pos + vec3(0.0,-0.465,0.0), vec3(0.60)) );\n    v += sin(30.*pos.x)*sin(30.*pos.y)*sin(30.*pos.z) * 0.01;  \n    return v;\n}\n\nfloat linkage(vec3 pos)\n{\n    float v = 1e10;\n    float v1 = 1e10;\n    float v2 = 1e10;\n    \n    v = min(v, sdLink( opRipple(pos) + vec3(0.12, -0.171, 0.401),0.4, 0.25, 0.018 ));\n    v = opSubtraction( -v, sdBox( pos + vec3(-0.4,-0.265,0.2), vec3(0.30, 0.65,0.30)));\n    \n    v1 = min(v1, sdLink( opRipple(pos) + vec3(0.12, -0.171, 0.401),0.4, 0.25, 0.018 ));\n    v1 = opSubtraction( -v1, sdBox( pos + vec3(0.2,-0.865,0.2), vec3(0.30, 0.65,0.30)));\n    \n    v2 = min(v2, sdLink( opRipple(pos) + vec3(0.258, -0.211, 0.401),0.1, 0.11, 0.018 ));\n    \n    v = min(v, v1);\n    v = min(v, v2);\n    v = opSubtraction( -v, sdBox( pos + vec3(0.0,-0.465,0.0), vec3(0.60)) );\n\n    return v;\n}\n\nfloat coil(vec3 pos)\n{\n    float v = 1e10;\n    \n    v = min(v, sdRoundedCylinder( rotateX(pos + vec3(-0.26, -0.46, 0.35 + sin(gTime) * 0.009),PI * 0.5), 0.10, 0.01, 0.01));\n    v = min(v, sdRoundedCylinder( rotateX(pos + vec3(-0.26, -0.46, 0.33 + cos(gTime) * 0.0089),PI * 0.5), 0.082, 0.01, 0.01));\n    v = min(v, sdRoundedCylinder( rotateX(pos + vec3(-0.26, -0.45, 0.31 + sin(gTime) * 0.009),PI * 0.5), 0.073, 0.01, 0.01));\n    v = min(v, sdTorus88( rotateX(pos,PI * 0.5) + vec3(-0.25, 0.28 + cos(gTime) * 0.015, 0.462),vec2(0.10 ,0.011) ));\n    v = min(v, sdTorus88( rotateX(pos,PI * 0.5) + vec3(-0.25, 0.27 + sin(gTime) * 0.025, 0.460),vec2(0.07 ,0.011) ));\n\n    return v;\n    \n}\n\nfloat g1=0.,g2=0.,g3=0.;\n\nvoid rot(inout vec3 p,vec3 a,float t){\n\ta=normalize(a);\n\tvec3 u=cross(a,p),v=cross(a,u);\n\tp=u*sin(t)+v*cos(t)+a*dot(a,p);   \n}\n\nvoid rot(inout vec2 p,float t){\n    p=p*cos(t)+vec2(-p.y,p.x)*sin(t);\n}\n\n// rewrote 20/12/01\nvoid sFold45(inout vec2 p)\n{\n\tvec2 v=normalize(vec2(1,-1));\n\tfloat g=dot(p,v);\n\tp-=(g-sqrt(g*g+5e-5))*v;\n}\n\nfloat stella(vec3 p, float s)\n{\n    p=sqrt(p*p+0.00005); // https://iquilezles.org/articles/functions\n    sFold45(p.xz);\n\tsFold45(p.yz);    \n    return length(p)-s;\n}\n\n\n#define seed 2576.\n#define hash(p)fract(sin(p*12345.5))\nfloat stellas(vec3 p)\n{\n    p.y -= gTime;\n    float c=5.;\n    vec3 e=floor(p/c);\n    e = sin(11.0*(2.5*e+3.0*e.yzx+1.345)); \n    p-=e*.5;\n    p=mod(p,c)-c*.5;\n    rot(p,hash(e+66.887)-.5,gTime*1.5);\n    float clouds = min(.7,stella(p,.12));\n    return clouds + cf(p) * 0.4;\n}\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rand(float n)\n{\n    return fract(sin(n * 12.9898) * 43758.5453);\n}\n\nvec2 rand2(vec2 p)\n{\n\tfloat r = 523.0*sin(dot(p, vec2(53.3158, 43.6143)));\n\treturn vec2(fract(15.32354 * r), fract(17.25865 * r));\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// main sdf\n//////////////////////////////////////////////////////////////////////////////////////\n\nvec2 map(in vec3 pos)\n{\n    vec3 cp = pos;\n    pos.y = pos.y + sin(gTime) * 0.05;\n    vec2 res = vec2( 1.0, 0.0 );\n    #define opMin(_v, _m)    res = (_v < res.x) ? vec2(_v, _m) : res\n    \n    float bottomGround = sdRoundBox(pos + vec3(0.0, 0.13, 0.0), vec3(0.6, 0.01, 0.6), 0.008) + cf(pos) * 0.1;\n    float characterBase = sdRoundBox(pos + vec3(0.0, 0.0465, -0.1), vec3(0.12, 0.065, 0.10), 0.005);\n    float sphereCharacterBaseBack = sdSphere(pos + vec3(0.0, 0.0465, 0.15), 0.13);\n    float sphereCharacterBaseFront = sdSphere(pos + vec3(-0.08, 0.065, -0.265), 0.055);\n    float sphereStaticRight1 = sdSphere(pos + vec3(-0.21, -0.055 + sin(iTime) * 0.015, 0.025), 0.055);\n    float sphereStaticRight2 = sdSphere(pos + vec3(-0.32, -0.025, -0.045), 0.060);\n    float sphereStaticRight3 = sdSphere(pos + vec3(-0.25, -0.015 + cos(iTime) * 0.03, -0.120), 0.035);\n    float sphereStaticLeft1 = sdSphere(pos + vec3(0.41, -0.555 + sin(iTime) * 0.02, 0.225), 0.155);\n    float frontBase = sdRoundBox(pos + vec3(0.25, 0.095, -0.3), vec3(0.12, 0.055, 0.10), 0.005);\n    float rightBase = sdRoundBox(pos + vec3(-0.23, 0.115,-0.05), vec3(0.10, 0.055, 0.10), 0.005);\n    \n    vec3 prismDomain = rotateX(pos,3.1415 * 0.5);\n    float frontRightPrism = sdOctogonPrism( prismDomain + vec3(-0.40, -0.476,-0.08), 0.081, 0.05 );\n\t\n    \n\n    float rock = rockFormation(pos);\n    float links = linkage(pos);\n    float coil = coil(pos);\n    \n    \n    vec3 pBody = pos + vec3(0.0, -0.18 + sin(iTime) * 0.05, -0.06 );                    \n    pBody.xz *= rotMat(radians(90.));\n    pBody.yz *= rotMat(gTime);\n    \n    float characterBody = sdSphere(opRipple(pBody), 0.125);\n    characterBody += sin(30.*pos.x)*sin(30.*pos.y)*sin(30.*pos.z) * 0.01;  \n\n    vec3 pHead = pos + vec3(0.0, -0.31 + sin(iTime) * 0.05, -0.06 );                    \n    pHead.xz *= rotMat(radians(90.));\n    pHead.yz *= rotMat(gTime);\n\n    float characterHead = sdSphere(opRipple(pHead), 0.065);\n    characterHead += sin(30.*pos.x)*sin(30.*pos.y)*sin(30.*pos.z) * 0.01; \n    \n    float bodyAndHead = opSmoothUnion(characterBody,characterHead,0.05);\n    \n\n\n\n\n    float mouth = sdEllipsoid(pos - vec3(0.18 + sin(iTime) * 0.005, 0.20 + cos(iTime) * 0.005, 0.05), vec3(0.09, 0.08 - cos(iTime) * 0.05, 0.07));\n          mouth -= sin(20.*pos.x)*sin(30.*pos.y)*sin(20.*pos.z) * 0.012;\n    bodyAndHead = fOpDifferenceRound(bodyAndHead, mouth, 0.027);\n    \n    \n\n\n\n    vec3 armSize = vec3 (.0,.18,.1);\n    vec3 handSize = vec3 (.2,.2,.13);          \n    vec3 bodySize = vec3 (.15,0.25,.2);\n    \n    vec3 pShouldR = pos - vec3(bodySize.x+armSize.x-0.15,bodySize.y - 0.025 + sin(iTime) * 0.0001,0.165 - sin(iTime) * 0.002);\n    pShouldR.xz *= rotMat(radians(-143.));\n    pShouldR.yz *= rotMat(radians(40.));\n    pShouldR.yz *= rotMat(-sin(iTime) * 0.25);\n    vec3 pArmR = pShouldR;\n    vec3 pForeR = pShouldR-vec3(0.02,1.*armSize.y-0.11,0.02);\n    pForeR.xz *= rotMat(radians(-90.));\n    pForeR.xy *= rotMat(radians(-20.));\n    pForeR.yz *= rotMat(radians(60.));\n    pForeR.xy *= rotMat(clamp(sin(iTime)*PI/2.,0.,PI/2.));\n    \n    vec3 pHandR1 = pForeR-vec3(0.015,armSize.y-.1215,0.028);\n    vec3 pHandR2 = pForeR-vec3(0.039,armSize.y-.1315,0.028);\n    \n    \n    float armR = sdCapsule( pArmR, vec3(0.0,0.0,0.0), vec3(0.015,0.05,0.015), 0.015 );\n    float foreR = sdCapsule( pForeR, vec3(0.0,0.0,0.0), vec3(0.015,0.02,0.015), 0.015 );\n    foreR += sin(50.*pos.x)*sin(50.*pos.y)*sin(30.*pos.z) * 0.01;  \n    \n    float handR1 = sdSphere(pHandR1, 0.015);\n    float handR2 = sdSphere(pHandR2, 0.015);\n    \n    bodyAndHead = opSmoothUnion(bodyAndHead,armR,0.08);\n    bodyAndHead = opSmoothUnion(bodyAndHead,foreR,0.013);\n    bodyAndHead = opSmoothUnion(bodyAndHead,armR,0.03);\n    bodyAndHead = opSmoothUnion(bodyAndHead,foreR,0.003);    \n\n    \n    vec3 pShouldL = pos - vec3(bodySize.x+armSize.x-0.15,bodySize.y - 0.035 + sin(iTime) * 0.002,-0.050 - sin(iTime) * 0.002);\n    pShouldL.xz *= rotMat(radians(-210.));\n    vec3 pArmL = pShouldL;\n    vec3 pForeL = pShouldL-vec3(0.02,1.*armSize.y-0.11,0.02);\n    pForeL.xz *= rotMat(radians(-210.));\n    pForeL.xy *= rotMat(radians(-60.));\n    //pForeL.yz *= rotMat(radians(60.));\n    pForeL.xy *= rotMat(clamp(sin(iTime)*PI/2.,0.,PI/2.));\n\n\n\n    float armL= sdCapsule( pArmL, vec3(0.0,0.0,0.0), vec3(0.015,0.05,0.015), 0.015 );\n    float foreL= sdCapsule( pForeL, vec3(0.0,0.0,0.0), vec3(0.015,0.02,0.015), 0.015 );\n    foreL += sin(50.*pos.x)*sin(50.*pos.y)*sin(30.*pos.z) * 0.01;  \n\n    \n    vec3 eyeL = pos + vec3(-0.06 + sin(iTime) * 0.01, -0.32 + sin(iTime) * 0.05, -0.04 );                    \n    eyeL.xz *= rotMat(radians(90.));\n    eyeL.yz *= rotMat(gTime);\n\n    float characterEyeL = sdSphere(opRipple(eyeL), 0.015);\n    characterEyeL += sin(10.*pos.x)*sin(60.*pos.y)*sin(10.*pos.z) * 0.01;\n\n    vec3 eyePl = pos + vec3(-0.070 + sin(iTime) * 0.01, -0.32 + sin(iTime) * 0.05, -0.04 );                    \n    eyePl.xz *= rotMat(radians(90.));\n    eyePl.yz *= rotMat(gTime);\n\n    float characterEyePl = sdSphere(opRipple(eyePl), 0.008);\n    characterEyePl += sin(10.*pos.x)*sin(60.*pos.y)*sin(10.*pos.z) * 0.01;\n    \n\n    //vec3 eyeR = pos + vec3(-0.062 + sin(iTime) * 0.009, -0.32 + sin(iTime) * 0.02, -0.085 );\n    vec3 eyeR = pos + vec3(-0.065 + sin(iTime) * 0.02, -0.32 + sin(iTime) * 0.03, -0.073 );  \n    eyeR.xz *= rotMat(radians(90.));\n    eyeR.yz *= rotMat(gTime);\n\n    float characterEyeR = sdSphere(opRipple(eyeR), 0.015);\n    characterEyeR += sin(10.*pos.x)*sin(60.*pos.y)*sin(10.*pos.z) * 0.01;\n \n\n    vec3 eyePr = pos + vec3(-0.079 + sin(iTime) * 0.02, -0.32 + sin(iTime) * 0.03, -0.073 );  \n    eyePr.xz *= rotMat(radians(90.));\n    eyePr.yz *= rotMat(gTime);\n\n    float characterEyePr = sdSphere(opRipple(eyePr), 0.008);\n    characterEyePr += sin(10.*pos.x)*sin(60.*pos.y)*sin(10.*pos.z) * 0.01;\n    \n\n    vec3 inMouth = pos + vec3(-0.085, -0.18 + sin(iTime) * 0.05, -0.06 );                    \n\n    float innerMouth = sdEllipsoid(inMouth, vec3(0.02, 0.05, 0.05));\n    innerMouth += sin(30.*pos.x)*sin(60.*pos.y)*sin(70.*pos.z) * 0.01;\n\n\n    bodyAndHead = opSmoothUnion(bodyAndHead,armL,0.05);\n    bodyAndHead = opSmoothUnion(bodyAndHead,foreL,0.013);\n    bodyAndHead = opSmoothUnion(bodyAndHead,armL,0.03);\n    bodyAndHead = opSmoothUnion(bodyAndHead,foreL,0.003); \n    \n    float s, s1;\n    s = 10000.0;\n    vec3 tempPos1 = pos + vec3(0.18, -0.39, -0.15);\n    \n    for(int i = 0; i < 30; i++)\n\t{\n        vec3 pos1;\n        float ltime = gTime*0.11 + float(i)*120.134;\n\n        float r = rand(float(i)*2.33);\n        float x = 0.035-mod(ltime*(r + 0.5), 0.5);\n\n        float r1 = rand(float(i)*22.33);\n        r1 *= 0.02;\n        \n        float r2 = rand(float(i)*32.33);\n        r2 *= 0.03;        \n\n\n        pos1 = vec3(x, -0.130*mod(float(i), 2.0) - 0.48 + rand(float(i)) * 0.15 + sin(ltime) * 0.25, -0.05*floor(float(i)/6.0) * 0.5/* - 0.42 + rand(float(i)) * 0.5*/);\n        s1 = sdSphere(tempPos1 - pos1, 0.018);\n        if (s1 < s)\n        {\n            s = s1;\n\n        }       \n    }\n    \n    s += sin(30.*pos.x)*sin(30.*pos.y)*sin(30.*pos.z) * 0.01;  \n    s = opSubtraction( -s, sdBox( pos + vec3(0.0,-0.465,0.0), vec3(1.70,0.60,1.70)) );\n     \n    bodyAndHead = fOpUnionRound(bodyAndHead,s,0.115);\n    \n/*\n    vec3 teethL = pos + vec3( -0.090 + sin(iTime) * 0.01, -0.215 + sin(iTime) * 0.05, -0.04 );                    \n    teethL.xz *= rotMat(radians(90.));\n    teethL.yz *= rotMat(radians(16.));\n    float teeth = teethFormation(opRipple(teethL));\n    teeth += sin(20.*pos.x)*sin(60.*pos.y)*sin(10.*pos.z) * 0.01;\n*/\n\n    opMin(bottomGround, MAT_GROUNDPLATE);\n    opMin(characterBase, MAT_CHARACTERBASE);\n    opMin(sphereCharacterBaseBack, MAT_REFLSPHERE);\n    opMin(sphereCharacterBaseFront, MAT_REFLSPHERE);\n    opMin(frontBase, MAT_CHARACTERBASE);\n    opMin(rightBase, MAT_CHARACTERBASE);\n    opMin(sphereStaticRight1, MAT_REFLSPHERE);\n    opMin(sphereStaticRight2, MAT_REFLSPHERE);\n    opMin(sphereStaticRight3, MAT_REFLSPHERE);\n    opMin(sphereStaticLeft1, MAT_REFLSPHERE);\n    opMin(frontRightPrism, MAT_CHARACTERBASE);\n\n    opMin(rock, MAT_ROCKFORMATION);\n    opMin(links, MAT_CHARACTERBASE);\n    opMin(coil, MAT_REFLSPHERE);\n    \n    opMin(bodyAndHead, MAT_SLIMER);\n    opMin(characterEyeL, MAT_EYE);\n    opMin(characterEyePl, MAT_EYE_PUPIL);\n    opMin(characterEyeR, MAT_EYE);\n    opMin(characterEyePr, MAT_EYE_PUPIL);\n    opMin(innerMouth, MAT_EYE_MOUTH);\n\n    float stellas = stellas(pos);\n    opMin(stellas, MAT_CLOUDS);\n    \n    float d, d1;\n    d = 10000.0;\n    vec3 tempPos = pos + vec3(0.18, -0.39, -0.15);\n    \n    for(int i = 0; i < 20; i++)\n\t{\n        vec3 pos1;\n        float ltime = gTime*0.19 + float(i)*120.134;\n\n        float r = rand(float(i)*2.33);\n        float x = 0.9-mod(ltime*(r + 0.5), 1.4);\n\n        float r1 = rand(float(i)*22.33);\n        r1 *= 0.02;\n        \n        float r2 = rand(float(i)*32.33);\n        r2 *= 0.03;        \n\n\n        pos1 = vec3(x, -0.130*mod(float(i), 2.0) - 0.48 + rand(float(i)) * 0.15 + sin(ltime) * 0.25, 0.210*floor(float(i)/12.0) - 0.48 + rand(float(i)) * 0.5);\n        d1 = sdSphere(tempPos - pos1, 0.04);\n        if (d1 < d)\n        {\n            d = d1;\n\n        }       \n    }\n    \n    d += sin(30.*pos.x)*sin(30.*pos.y)*sin(30.*pos.z) * 0.01;  \n    d = opSubtraction( -d, sdBox( pos + vec3(0.0,-0.465,0.0), vec3(1.70,0.60,1.70)) );\n         \n    opMin(d, MAT_REFLSPHERE);\n    \n\n    return res;\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// raymarching softshadows (https://iquilezles.org/articles/rmshadows)\n//////////////////////////////////////////////////////////////////////////////////////\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\n{\n    // bounding volume\n    //float tp = (maxHei-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = tmin;\n    for( int i=ZERO; i<22; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// https://iquilezles.org/articles/normalsSDF\n//////////////////////////////////////////////////////////////////////////////////////\n\nvec3 calcNormal( in vec3 pos )\n{\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n    }\n    return normalize(n);\n#endif    \n}\n\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.00;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\nvec3 calcSkyColor(vec3 aDirection)\n{\n    float t = smoothstep(0.1, 0.6, 0.7f*(aDirection.y + 1.0f));\n    return mix(vec3(1.0f, 0.96f, 0.6f), vec3(0.2f, 0.1f, 1.0f), t);\n}\n\n\n\nfloat ambientLight = 1.0;\nfloat reflectionQuality = 64.0; // Quality of reflections. 48 is good, higher is more costly\n// Diffuse lighting (matId = 0)\nvec3 diffuse(vec3 p, vec3 col, vec3 n)\n{\n    vec3 lightDir = normalize( vec3(-0.5, 1.1, 0.9) );\n    // Then set colour\n    vec3 colour = col.rgb;\n\n    // Then do lighting and shadows\n    colour *= vec3(max(dot(-lightDir.xyz, n), 0.0));\n    \n    // Return the colour\n    return colour;\n}\n\nvec3 reflective(vec3 p, vec3 col, vec3 n, vec3 v)\n{\n    vec3 lightDir = normalize( vec3(-0.5, 1.1, 0.9) );\n    // Set base colour\n    vec3 colour = ambientLight * diffuse(p, col, n);\n    \n    // Reflect the light ray\n    vec3 r = reflect(v, n);\n    vec3 rr = reflect(-lightDir, n);\n    \n    // Specular constant\n    float ks = 0.6;\n    \n    // Calculate specular reflection\n    colour += ks * max(0.0, dot(rr, v));\n    \n    // Reflect the scene\n    float t = 0.0;\n    for (float i = 0.0; i < reflectionQuality; i++)\n    {\n        vec3 q = p + r * (0.2 + t);\n        vec2 m = map(q);\n        vec3 refCol = vec3(m.x, m.y, m.y);\n        \n        if (m.x < 0.001)\n        {\n            vec3 n = calcNormal(q);\n\n            // Diffuse - default\n            refCol = diffuse(p, col, n);\n            \n            // Add the reflected object's colour.\n            colour += (1.0 - ks) * refCol * (1.0 / (1.0 + t * t * 0.1));\n            break;\n        }\n        \n        t += m.x * 0.8;\n    }\n    \n    // Return colour*/\n    return colour;\n}\n\nvec3 cubeColor;\n// Specular lighting\n\n\nvec3 cubeCol;\n\nvec3 useCubemap(vec3 p, vec3 col, vec3 n, vec3 v)\n{\n    vec3 lightDir = normalize( vec3(-0.5, 1.1, 0.9) );\n    // Set base colour\n    vec3 colour = ambientLight * diffuse(p, col, n);\n    \n    // Reflect the light ray\n    vec3 rr = reflect(-lightDir, n);\n    vec3 r = reflect(-v, n);\n    \n    // Specular constant\n    float ks = 1.0;\n    \n    // Calculate specular reflection\n    colour += ks * max(0.0, dot(rr, v));\n    \n    // Calculate cubemap reflection. Invert\n    // the y component because it's wrong. :)\n    colour = ks + texture(iChannel0, vec3(r.x, r.y * 0.75, r.z)).rgb;\n    \n    // Return colour\n    return colour;\n}\n\nvec4 calcColor(int matId, vec3 pos, vec3 normal, float diffuse, float fresnel, vec3 r, vec3 ref)\n{\n    vec4 FinalColor = vec4(0.1, 0.1, 0.1, 1) * diffuse;\n    if(matId == MAT_STONE)\n    {\n        vec3 Stone = vec3(0.35, 0.35, 0.35);\n        vec3 StoneShadow = vec3(0.1, 0.1, 0.2);\n        FinalColor.rgb = mix(StoneShadow, Stone, diffuse);\n        FinalColor.rgb += Stone * fresnel * 0.05;\n    }\n    else if(matId == MAT_GROUNDPLATE)\n    {\n        FinalColor.rgb = mix( vec3(0.59, 0.49, 0.75), vec3(0.62, 0.49, 0.75), diffuse);\n        FinalColor.rgb += vec3(0.76, 0.70, 0.85) * fresnel * 1.8;\n    }\n    else if(matId == MAT_CHARACTERBASE)\n    {\n        FinalColor.rgb = mix( vec3(0.59, 0.49, 0.75), vec3(0.62, 0.49, 0.75), diffuse);\n        FinalColor.rgb += vec3(1.76, 1.70, 1.85) * fresnel * 0.8;      \n    }\n    else if(matId == MAT_COIL)\n    {\n        FinalColor.rgb = mix( vec3(0.89, 0.86, 0.90), vec3(0.85, 0.80, 0.92), diffuse * 0.5);\n        FinalColor.rgb += vec3(0.85, 0.80, 0.92) * fresnel * 1.1;      \n    }\n    else if(matId == MAT_ROCKFORMATION)\n    {\n        FinalColor.rgb = mix( vec3(0.59, 0.49, 0.75), vec3(0.62, 0.49, 0.75), diffuse);\n        FinalColor.rgb += vec3(1.76, 1.70, 1.85) * fresnel * 1.8;    \n    }   \n    else if(matId == MAT_REFLSPHERE)\n    {\n        FinalColor.rgb = mix( vec3(0.59, 0.49, 0.75), vec3(0.62, 0.49, 0.75), diffuse);\n        FinalColor.rgb += vec3(0.76, 0.70, 0.85) * fresnel * 1.5;\n        FinalColor.rgb += 0.5 * reflective(pos, FinalColor.rgb, normal, r);\n        FinalColor.rgb += 0.5 * useCubemap(pos, FinalColor.rgb, normal, r) * 0.55;\n    }    \n    else if(matId == MAT_SLIMER)\n    {\n        FinalColor.rgb = mix( vec3(0.45, 0.95, 0.09), vec3(0.45, 0.82, 0.09),  diffuse * 0.3);\n        FinalColor.rgb +=  vec3(0.45, 0.95, 0.09) * fresnel * 2.5;\n    }  \n    else if(matId == MAT_EYE)\n    {\n        FinalColor.rgb = mix( vec3(3.95,3.95, 0.09), vec3(0.45, 0.82, 0.09),  0.5);\n        FinalColor.rgb +=  vec3(3.95, 3.95, 0.09) * fresnel * 1.5;\n        //FinalColor.rgb = 0.5 * reflective(pos, FinalColor.rgb, normal, r);\n        FinalColor.rgb += 0.5 * useCubemap(pos, FinalColor.rgb, normal, r) * 0.55;\n    }  \n    else if(matId == MAT_EYE_PUPIL)\n    {\n        FinalColor.rgb = mix( vec3(0.95,0.95, 0.09), vec3(0.45, 0.82, 0.09),  0.5);\n        FinalColor.rgb +=  vec3(0.95, 0.95, 0.09) * fresnel * 1.5;\n        FinalColor.rgb = 0.5 * reflective(pos, FinalColor.rgb, normal, r);\n        FinalColor.rgb += 0.5 * useCubemap(pos, FinalColor.rgb, normal, r) * 0.55;\n    }  \n    else if(matId == MAT_EYE_MOUTH)\n    {\n        FinalColor.rgb = mix( vec3(0.95,0.95, 0.09), vec3(0.45, 0.82, 0.09),  0.5);\n        FinalColor.rgb +=  vec3(0.95, 0.95, 0.09) * fresnel * 1.5;\n        FinalColor.rgb = 0.3 * reflective(pos, FinalColor.rgb, normal, r);\n    }         \n    else if(matId == MAT_UNDERWATER)\n    {\n        vec3 Sand = vec3(0.447, 0.447, 0.04);\n        vec3 SandShadow = vec3(0.347, 0.247, 0.02);\n        FinalColor.rgb = mix(vec3(1.9, 1.9, 1.8), vec3(1.8, 1.8, 1.7), diffuse);\n    }\n    else if(matId == MAT_CLOUDS)\n    {\n        FinalColor.rgb = mix( vec3(3.95,3.95, 0.09), vec3(1.45, 1.82, 1.09),  0.5);\n        FinalColor.rgb +=  vec3(3.95, 3.95, 0.09) * fresnel * 1.5;\n        FinalColor.rgb += 0.5 * useCubemap(pos, FinalColor.rgb, normal, r) * 0.55;\n    }\n    \n    return FinalColor;\n}\n\nfloat gt;\nvec3 castRay(vec3 ro, vec3 rd)\n{\n    vec3 res = vec3(0.0, 1e10, 0.0);\n    float tmin = 1.0;\n    float tmax = 20.0;\n    float t = tmin;\n    for( int i=0; i<120 && t<tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec3(t, h.x, h.y); \n            return res;\n        }\n        t += h.x;\n    }\n    \n    gt = t;\n    \n    return res;\n}\n\n\nvec4 render( vec2 uv, in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy )\n{ \n    vec4 finalColor = vec4(calcSkyColor(rd), 0.0);\n    vec3 r = normalize(vec3(uv, 3.14159 * 10.5));\n    vec3 res = castRay(ro,rd);\n    \n    if(res.y < 0.002)\n    {\n        vec3 lightDir = normalize( vec3(-0.5, 1.1, -0.6) );\n        vec3 pos = ro + rd * res.x;\n        vec3 normal = calcNormal(pos);\n        ref = reflect( res, normal );\n        r = normalize(ro-rd);\n        \n        float ao = calcAO(pos, normal);\n        float shadow = calcSoftshadow( pos, lightDir, 0.02, 2.5 );\n        float NdL = clamp( dot( normal, lightDir ), 0.0, 1.0 );\n        float fresnel = pow( clamp(1.0+dot(normal,rd),0.0,1.0), 2.4 );\n        \n        float diffuse  = shadow * NdL * 12.0;\n\n        vec4 color = calcColor(int(res.z), pos, normal, diffuse, fresnel, r, ref) * mix(0.22, 1.0, ao);\n        finalColor = vec4(color.rgb, res.x);\n        finalColor.rgb = finalColor.rgb * 0.4 + 0.6 * finalColor.rgb * calcSkyColor(normal);\n    }\n\n    return finalColor;\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    gTime = float(iTime);\n\n    vec2 mo = iMouse.xy/iResolution.xy;\n    //mo.y += 0.2;\n\tfloat time = 23.5 + iTime*1.5;\n    //float time = 23.5;\n    vec2 xy = fragCoord.xy / iResolution.xy;\n    vec2 uv = (-1.0 + 2.0 * xy) * vec2(iResolution.x/iResolution.y,1.0);\n    \n    // camera\t\n    vec3 ro = vec3( 4.6*cos(0.1*time + 12.0*mo.x),  1.2 + 3.0*mo.y, 4.6*sin(0.1*time + 12.0*mo.x) );\n    vec3 ta = vec3( 0.0, 0.14, 0.0 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n \n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n    // ray direction\n    vec3 rd = ca * normalize( vec3(p,6.0) );\n\n     // ray differentials (NOT USED YET)\n    vec2 px = (-iResolution.xy+2.0*(fragCoord.xy+vec2(1.0,0.0)))/iResolution.y;\n    vec2 py = (-iResolution.xy+2.0*(fragCoord.xy+vec2(0.0,1.0)))/iResolution.y;\n    vec3 rdx = ca * normalize( vec3(px,2.0) );\n    vec3 rdy = ca * normalize( vec3(py,2.0) );\n\n    // render\n    vec4 col = render( p, ro, rd, rdx, rdy );\n    cubeCol = texture(iChannel0, vec3(rd.x, -rd.y, rd.z)).rgb;\n    \n    \n    fragColor = col;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n//////////////////////////////////////////////////////////////////////////////////////\n// pyramid bloom (https://www.shadertoy.com/view/lsBfRc)\n//////////////////////////////////////////////////////////////////////////////////////\n\nvec3 makeBloom(float lod, vec2 offset, vec2 bCoord, vec2 aPixelSize)\n{\n    offset += aPixelSize;\n\n    float lodFactor = exp2(lod);\n\n    vec3 bloom = vec3(0.0);\n    vec2 scale = lodFactor * aPixelSize;\n\n    vec2 coord = (bCoord.xy-offset)*lodFactor;\n    float totalWeight = 0.0;\n\n    if (any(greaterThanEqual(abs(coord - 0.5), scale + 0.5)))\n        return vec3(0.0);\n\n    for (int i = -3; i < 3; i++) \n    {\n        for (int j = -3; j < 3; j++) \n        {\n            float wg = pow(1.0-length(vec2(i,j)) * 0.125, 6.0); //* 0.125, 6.0\n            vec3 lTextureColor = textureLod(iChannel1, vec2(i,j) * scale + lodFactor * aPixelSize + coord, lod).rgb;\n            lTextureColor = (any(greaterThan(lTextureColor, vec3(BLOOM_THRESHOLD)))) ? lTextureColor * BLOOM_SIZE : vec3(0.0);\n            lTextureColor = pow(lTextureColor, vec3(2.2)) * wg;\n            bloom = lTextureColor + bloom;\n\n            totalWeight += wg;\n            \n        }\n    }\n\n    bloom /= totalWeight;\n\n    return bloom;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 pixelSize = 1.0 / iResolution.xy;\n    vec4 lInputColor0 = texture(iChannel0, uv);\n\n    vec3 lBlur  = makeBloom(2., vec2(0.0, 0.0), uv, pixelSize);\n         lBlur += makeBloom(3., vec2(0.3, 0.0), uv, pixelSize);\n         lBlur += makeBloom(4., vec2(0.0, 0.3), uv, pixelSize);\n         lBlur += makeBloom(5., vec2(0.1, 0.3), uv, pixelSize);\n         lBlur += makeBloom(6., vec2(0.2, 0.3), uv, pixelSize);\n\n        vec4 lOutputColor = vec4(clamp(pow(lBlur, vec3(1.0 / 2.2)), vec3(0), vec3(100)), 1.0);\n        fragColor = mix(lInputColor0, lOutputColor, BLOOM_FRAME_BLEND); \n}","name":"Buffer B","description":"","type":"buffer"}]}