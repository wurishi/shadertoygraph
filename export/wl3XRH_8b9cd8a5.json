{"ver":"0.1","info":{"id":"wl3XRH","date":"1582397333","viewed":164,"name":"Sayagata","username":"coposuke","description":"training, 紗綾形","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["pattern","training","japanese"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI     \t\t3.14159265357989\n#define TAU    \t\t(PI * 2)\n#define saturate(v)\t(clamp(v, 0.0, 1.0))\n\n// --------------------------------------------------\n\nconst int pattern[60] = int[](\n    1,0,0,0,0,0,0,0,0,0,\n    1,0,1,1,1,1,1,1,1,0,\n    1,0,0,1,0,1,0,1,0,0,\n    1,0,1,0,0,1,0,0,1,0,\n    1,1,1,1,0,1,0,1,1,1,\n    0,0,0,0,0,1,0,0,0,0\n);\n\nstruct Primitive\n{\n    float type;\n    float dist;\n    vec2 uv;\n};\n\nstruct Geometry\n{\n    float type;\n    vec3 position;\n    vec3 normal;\n    float dist;\n    vec2 uv;\n};\n    \nstruct Material\n{\n    vec3 color;\n};\n    \n// --------------------------------------------------\n\nmat3 rotate(float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m;\n}\n\nfloat hash(vec2 v)\n{\n    return fract(sin(dot(v, vec2(34373.129, 472.445))) * 1933.55);\n}\n\nfloat sdSphere(in vec3 pos)\n{\n    return length(pos) - 0.5;\n}\n\nfloat sdBox(in vec3 pos)\n{\n    vec3 q = abs(pos) - vec3(0.5);\n    return length(max(q, 0.0)) - min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n// --------------------------------------------------\n\nvec2 mapimp(in vec3 rayPos, in vec3 rayDir)\n{\n    vec2 grid = floor(rayPos.xz);\n    float rand = hash(grid);\n    \n    vec2 ptn = vec2(mod(grid.x, 10.0), mod(grid.y, 10.0));\n    ptn.y = 5.0 <= ptn.y ? 10.0 - ptn.y : ptn.y;\n    float up = float(pattern[int(ptn.x + ptn.y * 10.0)]);\n    \n    float seqence =  sin(iTime * 0.5);\n    \n    vec3 localPos = rayPos;\n    localPos.xz = fract(rayPos.xz) - 0.5;\n    localPos.y += (sin(rand * 10.0 + iTime) * 1.0) * smoothstep(-0.3, -1.0, seqence);\n    localPos.y -= up * cos(iTime * 0.5) * smoothstep(-1.0, 0.0, seqence);\n    \n    return vec2(up + 1.0, sdBox(localPos));\n}\n\nPrimitive map(in vec3 rayPos, in vec3 rayDir)\n{\n    vec2 primitive = mapimp(rayPos, rayDir).xy;\n    \n    // anti overshoot grid\n    vec2 gridDist = (step(vec2(0), rayDir.xz) - fract(rayPos.xz)) / rayDir.xz;\n    gridDist.x = min(gridDist.x, gridDist.y) + 1e-4;\n    primitive = gridDist.x < primitive.y ? vec2(0, gridDist.x) : primitive;\n\n    Primitive result;\n    result.type = primitive.x;\n    result.dist = primitive.y;\n    return result;\n}\n\nvec3 computeNormal(in vec3 pos, in vec3 rayDir)\n{\n    vec2 Epsilon = vec2(0.0, 1e-3);\n    return normalize(vec3(\n        map(pos + Epsilon.yxx, rayDir).dist - map(pos - Epsilon.yxx, rayDir).dist,\n        map(pos + Epsilon.xyx, rayDir).dist - map(pos - Epsilon.xyx, rayDir).dist,\n        map(pos + Epsilon.xxy, rayDir).dist - map(pos - Epsilon.xxy, rayDir).dist\n    ));\n}\n\nGeometry raymarch(in vec3 camPos, in vec3 camDir, float start, int steps)\n{\n    Geometry geometry;\n    geometry.type = 0.0;\n    float migration = start;\n    \n    for(int i=0 ; i<steps ; ++i)\n    {\n        Primitive primitive = map(camPos + camDir * migration, camDir);\n        \n        if(primitive.dist < 1e-4)\n        {\n            geometry.type = primitive.type;\n            break;\n        }\n        \n        migration += primitive.dist;\n    }\n    \n    vec3 pos =  camPos + camDir * migration;\n    geometry.position = pos;\n    geometry.normal = computeNormal(pos, camDir);\n    geometry.dist = migration;\n    geometry.uv = abs((1.0 - abs(geometry.normal.xz)) * geometry.position.xz);\n    geometry.uv = vec2(max(geometry.uv.x, geometry.uv.y), geometry.position.y);\n    geometry.uv = mix(geometry.uv, geometry.position.xz, saturate(abs(geometry.normal.y)));\n    geometry.uv *= 0.3;\n    return geometry;\n}\n\nfloat volumetric(in vec3 camPos, in vec3 camDir, in vec3 litDir, float stepLength, float maxLength)\n{\n    float migration = 0.0;\n    float brightness = 0.0;\n    \n    for(int i=0 ; i<50 ; ++i)\n    {\n        migration += stepLength;\n        vec3 pos = camPos + camDir * migration;\n\n        Geometry occlusion = raymarch(pos, -litDir, 0.0, 30);\n        brightness += step(occlusion.type, 1.0) * occlusion.dist * 1e-2 * 4.0 * (1.0 - migration * 1e-2);\n        \n        if(maxLength <= migration)\n            break;\n    }\n    \n    return brightness;\n}\n\nMaterial materialize(in Geometry geometry, in Geometry occlusion, in vec3 litDir, in float volume)\n{\n    Material material;\n    material.color = vec3(0);\n    material.color += float(geometry.type == 1.0) * vec3(1);\n    material.color += float(geometry.type == 2.0) * texture(iChannel0, geometry.uv).rgb;\n    material.color = 1.0 - pow(1.0 - material.color, vec3(3.0));\n    \n    float light = mix(0.0, 1.0, occlusion.dist * 0.5);\n    light = min(light, dot(litDir, geometry.normal));\n    light = clamp(light, 0.2, 1.0);\n    \n    material.color *= light;\n    material.color += light * vec3(0.02,0.03, 0.0);\n    material.color = mix(material.color, vec3(0.0), pow(geometry.dist * 1e-2 * 1.5, 3.0));\n    material.color += volume * vec3(0.017, 0.015, 0.008);\n    \n    return material;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = (fragCoord * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    mat3 camMat = rotate(iTime * 0.1 + PI * 0.75, vec3(0,1,0)) * rotate(PI * 0.25, vec3(1,0,0));\n    vec3 camPos = camMat * vec3(0,0,-20) + vec3(0,3,0);\n    vec3 camDir = normalize(camMat * vec3(uv, 2.0));\n    vec3 litDir = normalize(rotate(iTime * 0.1, vec3(0,1,0)) * vec3(0.5,0.8,0.5));\n    \n    float ortho = smoothstep(0.4, 0.6, cos(iTime * 0.2) * 0.5 + 0.5);\n    camPos += camMat * vec3(uv, 0) * 10.0 * ortho;\n    camDir = mix(camDir, normalize(camMat * vec3(0, 0, 1)), ortho);\n    \n    Geometry geometry = raymarch(camPos, camDir, 0.0, 130);\n    Geometry occlusion = raymarch(geometry.position, litDir, 1e-3, 20);\n    float volume = volumetric(camPos, camDir, litDir, 0.5, 20.0) * (1.0 - ortho);\n    Material material = materialize(geometry, occlusion, litDir, volume);\n\n    fragColor.rgb = material.color;\n    fragColor.a = 1.0;\n}","name":"Image","description":"","type":"image"}]}