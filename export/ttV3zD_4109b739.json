{"ver":"0.1","info":{"id":"ttV3zD","date":"1578451854","viewed":125,"name":"3d ray-ring intersection","username":"16807","description":"Distance field to the CSG intersection of two cylinders. The code provides functions to calculate the distance to any shape formed from constructive solid geometry, and works in both 2d and 3d. Click the screen to rotate.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raycasting","ring","analytic","minimal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define IN(T) in T\n#define INOUT(T) inout T\n#define OUT(T) out T\n#define CONST(T) const T\n#define VAR(T) T\n#define FUNC(T) T\n\n#define PI 3.1415926\n#define CRATER_RADIUS 0.4\n\nFUNC(bool) try_distances_along_line_intersecting_negation(\n    IN(bool) is_intersection1, IN(float) entrance1, IN(float) exit1, \n    IN(bool) is_intersection2, IN(float) entrance2, IN(float) exit2,\n    OUT(float) entrance,\n    OUT(float) exit\n) {\n    if (!is_intersection1)\n    {\n      return false;\n    }\n    entrance = is_intersection2 || entrance1 < entrance2 ? entrance1 : max(exit2,     entrance1);\n    exit     = is_intersection2 || exit1     < exit2     ? exit1     : max(entrance2, exit1    );\n    return !is_intersection2 || entrance1 < entrance2 || exit2 < exit1;\n}\nFUNC(bool) try_distances_along_line_intersecting_intersection(\n    IN(bool) is_intersection1, IN(float) entrance1, IN(float) exit1, \n    IN(bool) is_intersection2, IN(float) entrance2, IN(float) exit2,\n    OUT(float) entrance,\n    OUT(float) exit\n) {\n    entrance = is_intersection1 && is_intersection2 ? max(entrance1, entrance2) : 0.f;\n    exit     = is_intersection1 && is_intersection2 ? min(exit1,     exit2    ) : 0.f;\n    return is_intersection1 && is_intersection2 && entrance < exit;\n}\n\n\nFUNC(float) get_distance_along_3d_line_intersecting_plane(IN(vec3) A0, IN(vec3) A, IN(vec3) B0, IN(vec3) N){\n    return -dot(A0-B0, N) / dot(A,N);\n}\n\nFUNC(bool) try_distances_along_3d_line_intersecting_infinite_cylinder(IN(vec3) A0, IN(vec3) A, IN(vec3) B0, IN(vec3) B, IN(float) r, OUT(float) entrance, OUT(float) exit){\n    // simplify the problem by using a coordinate system based around the line and the tube center\n    // see closest-approach-between-line-and-cylinder-visualized.scad\n    vec3  O = A0 - B0;\n    float BA = dot(B,A);\n    float BO = dot(B,O);\n    float a = 1.0 - BA*BA;\n    float b = dot( O, A ) - BO*BA;\n    float c = dot( O, O ) - BO*BO - r*r;\n    float h = sqrt(max(b*b - a*c,0.f));\n    entrance =(-b+h)/a;\n    exit     =(-b-h)/a;\n    return h>0.0;\n}\nFUNC(bool) try_distances_along_3d_line_intersecting_cylinder(IN(vec3) A0, IN(vec3) A, IN(vec3) B0, IN(vec3) B1, IN(float) r, OUT(float) entrance, OUT(float) exit){\n    vec3 B = normalize(B1-B0);\n    float a1 = get_distance_along_3d_line_intersecting_plane(A0,A,B0,B);\n    float a2 = get_distance_along_3d_line_intersecting_plane(A0,A,B1,B);\n    float a_in  =  min(a1,a2);\n    float a_out =  max(a1,a2);\n    float b_in, b_out; bool b_hits = try_distances_along_3d_line_intersecting_infinite_cylinder(A0,A, B0,B, r, b_in, b_out);\n    float c_in, c_out; bool c_hits = try_distances_along_line_intersecting_intersection(b_hits, b_in, b_out, true, a_in, a_out, c_in, c_out);\n    entrance = max(b_out, min(a1,a2));\n    exit     = min(b_in,  max(a1, a2));\n    return b_hits && entrance < exit;\n}\n\nFUNC(bool) try_distances_along_3d_line_intersecting_ring(IN(vec3) A0, IN(vec3) A, IN(vec3) B0, IN(vec3) B1, IN(float) ro, IN(float) ri, OUT(float) entrance, OUT(float) exit){\n    \n    float a_in, a_out; bool a_hits = try_distances_along_3d_line_intersecting_cylinder(A0, A, B0, B1, ro, a_in, a_out);\n    float b_in, b_out; bool b_hits = try_distances_along_3d_line_intersecting_cylinder(A0, A, B0, B1, ri, b_in, b_out);\n    float c_in, c_out; bool c_hits = try_distances_along_line_intersecting_negation   (a_hits, a_in, a_out, b_hits, b_in, b_out, c_in, c_out);\n    entrance = c_in;\n    exit     = c_out;\n    return c_hits;\n}\n\n\nmat4 get_rotation_matrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mat4  projection_matrix_inverse = (mat4(0.5,0,0,0,0,0.3,0,0,0,0,0,-50,0,0,-1,50));\n    mat4  view_matrix_inverse = (get_rotation_matrix(vec3(0,1,0), iMouse.x * -0.01 + 0.1*iTime) * mat4(0.707, 0, 0.707, 0, 0.235, 0.942, -0.235, 0, -0.666, 0.333, 0.666, 0, -4, 2, 4, 1));\n    float reference_distance = 0.5f;//6.367e6;\n    \n    \n    vec2  screenspace    = fragCoord/iResolution.xy;\n    vec2  clipspace      = 2.0 * screenspace - 1.0;\n    vec3  view_direction = normalize(view_matrix_inverse * projection_matrix_inverse * vec4(clipspace, 1, 1)).xyz;\n    vec3  view_origin    = view_matrix_inverse[3].xyz * reference_distance;\n    \n    float d_in, d_out; bool d_hits = try_distances_along_3d_line_intersecting_ring    (view_origin, view_direction, vec3(-0.2,0,0), vec3(0.1,0,0), 0.7f, 0.5f, d_in, d_out);\n    vec3  color = vec3(0);\n    if (d_hits)\n    {\n        color = vec3(d_in/4.f);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}