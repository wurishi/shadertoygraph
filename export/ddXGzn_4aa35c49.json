{"ver":"0.1","info":{"id":"ddXGzn","date":"1665527851","viewed":112,"name":"Happy Little Accident (automata)","username":"Oneleven","description":"I was trying to come up with rules for some sort of cellular automaton by myself that could eventually produce stable islands, but instead got the opposite.\nCode is an \"if\" nightmare, but I'll keep it.","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["pixel","automata","cellular","automaton","rps","pixelfight"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Hash without Sine by Dave_Hoskins in\n//https://www.shadertoy.com/view/4djSRW\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec3 cell(ivec2 p)\n{\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    return texelFetch(iChannel0, p, 0).rgb;\n}\n\nvec3 contest(ivec2 p)\n{\n    vec3 maxR = vec3(0);\n    vec3 maxG = vec3(0);\n    vec3 maxB = vec3(0);\n\n    for (int y =-1; y < 1; y++)\n        for (int x = -1; x < 1; x++)\n        {\n            vec3 n = cell(ivec2(p.x + x, p.y + y));\n            if (n.r > maxR.r) maxR = n;\n            if (n.g > maxG.g) maxG = n;\n            if (n.b > maxR.b) maxB = n;\n        }\n    \n    float deltaRG = maxR.r - maxG.g;\n    float deltaGB = maxG.g - maxB.b;\n    float deltaBR = maxB.b - maxR.r;\n    \n    if ((deltaRG > deltaGB) && (deltaRG > deltaBR)) return maxR;\n    if ((deltaGB > deltaBR) && (deltaGB > deltaRG)) return maxG;\n    if ((deltaBR > deltaRG) && (deltaBR > deltaGB)) return maxB;\n    return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame <20) \n        {\n            fragColor = vec4(hash32(fragCoord), 1.0);\n            return;\n        }\n        \n    vec3 col = contest(ivec2(fragCoord));\n            \n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}