{"ver":"0.1","info":{"id":"43jGW3","date":"1709071148","viewed":104,"name":"infinite spheres trippy","username":"njberman","description":"nato\n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["thingy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265\n\nfloat sdSphere(vec3 p, vec3 c, float r)\n{\n    return length(p-c) - r;\n}\n\nfloat smin(float a, float b, float k)\n{\n    k *= 1.0;\n    float res = exp2(-a/k) + exp2(-b/k);\n    return -k*log2(res);\n}\n\nfloat sdLineSegment(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = clamp(dot(pa, ba)/dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba*h) - r;\n}\n\n\n// Hash function to generate pseudo-random gradients\nfloat hash(float x) {\n    // This is just a simple hashing function. You can replace it with any other hash function.\n    return fract(sin(x) * 43758.5453);\n}\n\n// Function to generate Perlin noise at a given position (x)\nfloat noise(float x) {\n    // Integer coordinate of the cell containing the point\n    int Xi = int(floor(x));\n    \n    // Get the two corners of the cell\n    float left = float(Xi);\n    float right = float(Xi + 1);\n    \n    // Generate random gradient vectors for each corner\n    float gradientLeft = dot(hash(float(Xi)), x - left);\n    float gradientRight = dot(hash(float(Xi + 1)), x - right);\n    \n    // Interpolate between the gradients\n    float t = smoothstep(0.0, 1.0, fract(x));\n    return mix(gradientLeft, gradientRight, t);\n}\n\n\nfloat map(vec3 p)\n{\n    p += vec3(noise(iTime/5.0)*10.0, noise(iTime/5.0+2338.7)*10.0, iTime);\n    float d1 = sdSphere(mod(p, 1.0), vec3(0.5, 0.5+sin(floor(p.y/1.0)+floor(p.z/1.0)+floor(p.x/1.0)+iTime*10.)*.05, 0.5), 0.15);\n\n    return d1;\n}\n\nvec3 calcNormal(vec3 p)\n{\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(map(p+e.xyy) - map(p-e.xyy),\n                          map(p+e.yxy) - map(p-e.yxy),\n                          map(p+e.yyx) - map(p-e.yyx)));\n}\n\nfloat castRay( in vec3 ro, in vec3 rd )\n{\n    float t = 0.0;\n    int steps;\n    const int MAX = 50;\n    for( steps=0; steps<MAX; steps++ )\n    {\n        vec3 pos = ro + t*rd;\n        float h = map(pos);\n\n        t += h;\n        if( h<0.001 ) break;\n    }\n    \n    return 1.0-float(steps)/float(MAX);\n}\n\n//vec3 normal = calcNormal(h);\n\n//vec3 lightP = vec3(2.0, -5.0, 3.0);\n\n//vec3 dirToLight = normalize(h - lightP);\n\n//float dif = max(0.0, dot(normal, dirToLight));\n\n//return vec3(1.0, 0.0, 0.0) * dif;\n\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr)\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    float an = 10.57*iMouse.x/iResolution.x;\n\n    //vec3 ta = vec3(0.0, 0.2, 0.0);\n    //vec3 ro = ta + vec3( 1.3*cos(an), -0.250, 1.3*sin(an) );\n\n    //mat3 ca = setCamera( ro, ta, 0.0 );\n\n    //vec3 rd = ca * normalize( vec3(uv,1.8) );\n\n    vec3 ro = vec3(0.0, 2.0, 0.0);\n    vec3 rd = normalize(vec3(uv.xy, 1.0));\n    float t = castRay(ro, rd);\n\n    float hue = noise(iTime/5.0)*5.0;//0.5 + 0.5*sin(iTime/2.0);\n    vec3 col = hsv2rgb(vec3(hue, 1.0, t));\n    //vec3 col = vec3(0.5*(sin(iTime)), 0.5*(sin(iTime)+PI/4.0), 0.5*(sin(iTime)+PI/2.0)) * t;\n\n    //if (t < 0.00001)\n    //{\n        //col = vec3(0.5 + 0.5*sin(iTime));\n    //    float hue = noise(iTime/5.0+2338.7)*5.0;//0.5 + 0.5*sin(iTime/2.0);\n    //    col = hsv2rgb(vec3(hue, 1.0, 1.0));\n    //}\n    //col = pow( col, vec3(0.4545) );\n\n    fragColor = vec4(col,1.0);\n}\n\nvoid thing(vec3 rd, vec3 ro, float t)\n{\nvec3 col = vec3(0.4,0.75, 1.0) - 0.7*rd.y;\n    col = mix(col, vec3(0.7, 0.75, 0.8), exp(-10.0*rd.y));\n    if (t > 0.0)\n    {\n        vec3 p = ro + t*rd;\n        vec3 nor = calcNormal(p);\n        \n        vec3 material = vec3(0.18);\n        \n        vec3 sun_dir = normalize(vec3(0.8, 0.4, 0.2));\n        \n        float sun_dif = clamp(dot(nor, sun_dir), 0.0, 1.0);\n        float sun_sha = step(castRay(p+nor*0.001, sun_dir), 0.0);\n        \n        float sky_dif = clamp(0.5 + 0.5*dot(nor, vec3(0.0, 1.0, 0.0)), 0.0, 1.0);\n        \n        float bou_dif = clamp(0.5 + 0.5*dot(nor, vec3(0.0, -1.0, 0.0)), 0.0, 1.0);\n\n\n        col = material*vec3(7.0, 4.5, 3.0)*sun_dif*sun_sha;\n        col += material*vec3(0.5,0.8,0.9)*sky_dif; \n        col += material*vec3(0.7,0.3,0.2)*bou_dif; \n    }\n}","name":"Image","description":"","type":"image"}]}