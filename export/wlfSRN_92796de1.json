{"ver":"0.1","info":{"id":"wlfSRN","date":"1562231567","viewed":196,"name":"SciFi Disjointed Discs","username":"AirAKose","description":"First attempt at a shader to optimize some canvas stuff for a looping web animation. All of the math was already super easy and fit well for a fragment shader","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["simple","beginner","animated","scifi","first","spinningdiscs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.1415926535897932384626433832795;\nconst float PI2 = PI * 2.0;\n\nconst vec3 col = vec3(0,0,0);\n\nstruct CircleData\n{\n    float radius;\n    float thickness;\n    int flags;\n    float flagCount;\n};\n    \nfloat aliasResolution()\n{\n    float res = 1.0 / (0.55 * max(iResolution.x, iResolution.y));\n    return res;\n}\n\nfloat ditherOffset(int index)\n{\n    const float offsets[] = float[](-0.04, 0.02, 0.0, -0.015, 0.05, 0.03);\n    //return float(index-2*0.01)\n    return offsets[index%offsets.length()];\n}\n\nfloat circleFill(float dist, float radius, float thickness)\n{\n    if (dist <= thickness) { return 1.0; }\n    return 0.0;\n}\n\nfloat circleMask(float angle, float dist, int mask, float maskCount)\n{\n    float value = mod(angle + PI, PI2);\n    int pos = int(value / (PI2 / maskCount));\n    return float((mask & (1 << pos)) != 0);\n}\n\nfloat samplePoint(vec2 pt, int index, CircleData entry, float time)\n{\n    float dir = (index%2)==0 ? 1.0 : -1.0;\n    float len = length(pt);\n    float dist = abs(len - entry.radius/2.0);\n    float angle = atan(pt.y, pt.x);\n    float curAngle = angle + (time + (1.0/float(index + 1) * time)) * dir;\n    \n    return circleFill(dist, entry.radius/2.0, entry.thickness/2.0)\n            * circleMask(curAngle, len, entry.flags, entry.flagCount);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 resolution;\n    resolution.x = resolution.y = min(iResolution.x, iResolution.y);\n    vec2 uv = fragCoord/resolution;\n    vec2 coord = uv - vec2(0.5, 0.5) + (((resolution - iResolution.xy)/2.0)/resolution);\n    \n\n    //TODO: Input buffer?\n    CircleData datas[] = CircleData[](\n        CircleData( 0.28,\t0.008, \t0x3636,\t\t16.0 ),\n        CircleData( 0.304,\t0.016, \t0x5555,\t\t16.0 ),\n        CircleData( 0.36,\t0.04,\t0xFCD9,\t\t16.0 ),\n        CircleData( 0.44,\t0.04,\t0xACAC,\t\t8.0  ),\n        CircleData( 0.52,\t0.04,\t0xA6A6,\t\t8.0  ),\n        CircleData( 0.6,\t0.04,\t0x5BAA,\t\t16.0 ),\n        CircleData( 0.68,\t0.04,\t0x18B5,\t\t16.0 ),\n        CircleData( 0.76,\t0.04,\t0xFEFE,\t\t16.0 ),\n        CircleData( 0.88,\t0.08, \t0x5973,\t\t16.0 ),\n        CircleData( 0.98,\t0.02,\t0x155793B1, 32.0 )\n    );\n    \n    float alpha = 0.0;\n    float time = iTime / 8.0;\n    \n    const int SAMPLE_COUNT = 8;\n    for (int i = 0; i < datas.length(); ++i)\n    {\n    \tCircleData entry = datas[i];\n        \n        float accumulated = samplePoint(coord, i, datas[i], time);\n        float total = 0.0;\n        // radial sampling (better results than square at least)\n        for (int j = 0; j < SAMPLE_COUNT; ++j)\n        {\n            float perc = float(j) / float(SAMPLE_COUNT);\n            float turn = perc * PI * 4.0 + PI / 3.0;\n            float x = cos(turn) * perc;\n            float y = sin(turn) * perc;\n            vec2 offset = vec2(x, y);\n            total += samplePoint(coord + (offset * aliasResolution()), i, datas[i], time);\n        }\n        accumulated = total / float(SAMPLE_COUNT);\n        \n        \n        // cumulative so no weird edge artifacts\n        alpha += accumulated;\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0) * clamp(alpha, 0.0, 1.0);\n    \n    float yDither = clamp(uv.y + ditherOffset(int(fragCoord.x + fragCoord.y*8.0)), 0.0, 1.0);\n    vec3 gradient = vec3(0.0, 0.18, 0.25) * yDither + vec3(0.0, 0.09, 0.125) * (1.0-yDither);\n    fragColor += vec4(gradient, 1.0) * (1.0 - fragColor.w);\n}","name":"Image","description":"","type":"image"}]}