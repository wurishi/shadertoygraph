{"ver":"0.1","info":{"id":"stB3RG","date":"1624099915","viewed":48,"name":"FS Strength Randomization","username":"GabrieleGiuseppini","description":"Experiments on the algorithm to randomize strength of structures in Floating Sandbox.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["floatingsandboxperlin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 gradientVectorAt(float ix, float iy) \n{\n    // Deterministic randomness\n    \n    // arg is always positive\n    float arg = (1. + sin(ix * dot(vec2(ix, iy), vec2(12.9898, 78.233)))) * 43758.5453;    \n    float random = arg - floor(arg);\n    return vec2(random);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Pixel coordinates in grid space (from 0 to WIDTH)\n    #define WIDTH 30.\n    #define GRID_SPACING (1./WIDTH)\n    vec2 gridPos = uv / GRID_SPACING;\n    \n    // Coordinates of four cell corners\n    float x0 = floor(gridPos.x);\n    float x1 = x0 + 1.;\n    float y0 = floor(gridPos.y);\n    float y1 = y0 + 1.;\n    \n    // Offset vectors from corners\n    vec2 off00 = gridPos - vec2(x0, y0);\n    vec2 off10 = gridPos - vec2(x1, y0);\n    vec2 off01 = gridPos - vec2(x0, y1);\n    vec2 off11 = gridPos - vec2(x1, y1);\n    \n    // Gradient vectors at four corners\n    vec2 gv00 = gradientVectorAt(x0, y0);\n    vec2 gv10 = gradientVectorAt(x1, y0);\n    vec2 gv01 = gradientVectorAt(x0, y1);\n    vec2 gv11 = gradientVectorAt(x1, y1);\n    \n    // Dot products at each corner\n    float dp00 = dot(off00, gv00);\n    float dp10 = dot(off10, gv10);\n    float dp01 = dot(off01, gv01);\n    float dp11 = dot(off11, gv11);\n    \n    // Interpolate four dot products at this point (using a bilinear)\n    float interpx1 = mix(dp00, dp10, gridPos.x - x0);\n    float interpx2 = mix(dp01, dp11, gridPos.x - x0);\n    float perlin = mix(interpx1, interpx2, gridPos.y - y0);\n    \n    perlin = sqrt(abs(perlin));\n    \n    ////////////////////////////////////////////////////////////////////////\n    \n    float gridDepth = 1.-\n        step(0.02, gridPos.x - x0) * step(0.02, gridPos.y - y0);\n    vec3 col = vec3(mix(perlin, 1., gridDepth));\n    col = vec3(perlin);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}