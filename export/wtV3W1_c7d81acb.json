{"ver":"0.1","info":{"id":"wtV3W1","date":"1578870647","viewed":311,"name":"Pond ripples","username":"vegardno","description":"Simple water ripples effect by modulating the surface normal of a cubemap-reflecting plane.","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["reflection","water","cubemap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat4 rotate(float a, vec3 v)\n{\n    float c = cos(a);\n    vec3 ci = (1. - c) * v;\n    vec3 s = sin(a) * v;\n\n    return mat4(\n        ci.x * v.x + c, ci.x * v.y + s.z, ci.x * v.z - s.y, 0,\n        ci.y * v.x - s.z, ci.y * v.y + c, ci.y * v.z + s.x, 0,\n        ci.z * v.x + s.y, ci.z * v.y - s.x, ci.z * v.z + c, 0,\n        0, 0, 0, 1\n\t);\n}\n\n// http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n// https://www.gamedev.net/forums/topic/497459-distance-from-point-to-plane-along-a-vector/\nvoid intersect_ray_plane(vec3 origin, vec3 direction, vec3 plane_normal, float plane_offset, out float near)\n{\n    float t = -(dot(plane_normal, origin) + plane_offset) / dot(plane_normal, direction);\n    near = t * length(direction);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tmat4 mvp = mat4(1.);\n    mvp *= rotate(radians(10.) * iTime, vec3(0, 1, 0));\n\tmvp *= rotate(radians(10.) * sin(radians(30.) * iTime), vec3(1, 0, 0));\n\n    vec3 eye = (mvp * vec4(0., 1., 0., 1.)).xyz;\n    vec3 dir = (mvp * vec4(rayDirection(90.0, iResolution.xy, fragCoord), 1.)).xyz;\n\n    vec3 hi_rgb = vec3(1.);\n    vec3 lo_rgb = vec3(1.);\n    \n    vec3 normal = vec3(0, 1, 0);\n\n    float near;\n    intersect_ray_plane(eye, dir, normal, 0., near);\n    if (near > 0.) {\n    \tvec3 hit_pos = eye + dir * near;\n\n        // modulate normal based on texture\n\t\tnormal = normalize(normal + .05 * (texture(iChannel1, .08 * hit_pos.xz + .1 * vec2(iTime, 0.)).rgb - .5));\n\n        // reflect\n\t\tdir = reflect(dir, normal);\n\n        // slightly tint the darker tones\n        lo_rgb = vec3(.7, .8, 1.1);\n    }\n\n    vec3 lo_color;\n    vec3 hi_color;\n    {\n    \tvec3 color = texture(iChannel0, dir).rgb;\n    \n    \t// split color into two components based on luminosity\n    \t// modulate each one separately to preserve highlights\n    \tfloat t = smoothstep(.95, 1., dot(vec3(.21, .72, 0.07), color));\n    \tlo_color = (1. - t) * color;\n    \thi_color = t * color;\n    }\n\n    fragColor = vec4(lo_rgb * lo_color + hi_rgb * hi_color, 1.);\n}","name":"Image","description":"","type":"image"}]}