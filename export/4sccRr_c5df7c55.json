{"ver":"0.1","info":{"id":"4sccRr","date":"1517700972","viewed":131,"name":"Mandelbrot Green - Smooth Color ","username":"Alazorth","description":"Identical to Mandelbrot Green but with smooth shading.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["mandelbrot","green","smoothcoloring"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//FRAGMENT SHADER\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n#define MAX_ITER  90\n\n\n\n//GLSL doesn't support while loops on old versions for some reason... ¯\\_(ツ)_/¯\nfloat fMbrot(vec2 c) {   \n    int n = 0;\n    float i = 0.;\n    float l = 0.;\n    vec2 z;\n    float B = 256.;\n    for(i=0.;i<float(MAX_ITER);i++){\n        z = vec2(z.x*z.x - z.y*z.y, 2.*z.x*z.y) + c;\n    \tif(length(z)>2.) break;\n        l += 1.;\n    }\n    //return i;\n\t//float nSmooth = log( 1.)/10.;\n    //float nSmooth = i + 1. - log( log( abs(float(MAX_ITER)) ) )/log(2.);\n    //inigo optimised smooth iteration count\n    \n    //float nSmooth = i - log2(log2(dot(z,z))) + 4.0;\n    float sl = l - log(log(length(z))/log(B))/log(2.0);\n    return sl;                                \n}\n    \n\nint wMbrot(vec2 c) { \n    vec2 zed;\n    zed.x = 0.0;\n    zed.y = 0.0;    \n    int n = 0;\n    //https://www.varsitytutors.com/hotmath/hotmath_help/topics/absolute-value-complex-number\n    while (sqrt(pow(zed.x,2.0) + pow(zed.y,2.0)) <= 2.0 && n < MAX_ITER) { \n        //zed = zed*zed + c;\n        zed = vec2 (pow(zed.x,2.0)-pow(zed.y,2.0),2.0 *zed.x * zed.y);\n    \tzed.x = (zed.x + c.x);\n    \tzed.y = (zed.y + c.y);    \n\t\t//http://mathworld.wolfram.com/ComplexAddition.html        \n\t\tn+=1;\n    }\n    return n;\n}\n\nvec3 trueCmap(float n)\t{  \n    // GLSL has it's own syntax for creating arrays . . .\n    vec3 cMap[7] = vec3[7](vec3(0.,2.,2.), vec3(1.,0.,1.), vec3(0.,0.,1.), vec3(0.,1.,0.), vec3(1.,1.,0.), vec3(1.,0.5,0.), vec3(0.,0.,0.)) ;\n    float quotient = float(cMap.length()) * n / float(MAX_ITER);\n    float lowerIndex = floor(quotient);\n    float upperIndex = ceil(quotient);\n    highp int lIndex = int(lowerIndex);\n    highp int uIndex = int(upperIndex);\n    float fraction = quotient - lowerIndex;\n    vec3 c = cMap[lIndex] + fraction * (cMap[uIndex] - cMap[lIndex]);\n    \n\treturn c;\n}\n\n\nvec4 nmap(float n) {\n\tvec3 colmap;\n    if (float(n) <= float(MAX_ITER)) {\n        float quotient = float(n) / float(MAX_ITER);\n        float color = clamp(quotient,0.,1.);\n        \tif (quotient > 0.5) {\n        \t// Close to the mandelbrot set the color changes from green to white \n \t\t\t\tcolmap = vec3(0.); //(color,1.,color);\n        \t}\n        \telse {\n                colmap = vec3(0.,color,0.);\n            }\n    }\n    return vec4(colmap,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\tfloat aspect = iResolution.y/iResolution.x;\n    vec2 mouseOffset = (iMouse.xy)/iResolution.xy;\n\tvec2 p = uv-mouseOffset;//*2.-1.; // transform uv range(0-1) to be centered and normalized(-1-1)\n\tp.y*=aspect;\n    float n = fMbrot(p*2.); // *2. is the zoom value to create a variable for controlled by GUI    \n    //float fn = smoothColoring(n);\n    //vec4 preColor = nmap(n);\n    vec4 preColor = vec4(trueCmap(n),1.);\n    fragColor = preColor;        \n}","name":"Image","description":"","type":"image"}]}