{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"const int max_iterations = 100;\nconst float stop_threshold = 0.001;\nconst float grad_step = 0.01;\nconst float clip_far = 100.0;\n\nconst vec3 worldUp = vec3( 0, 1, 0 );\nconst vec3 worldRight = vec3( 1, 0, 0 );\nconst vec3 worldForward = vec3( 0, 0, 1 );\n\nconst float PI = 3.14159265359;\nconst float DEGS2RADS = PI / 180.0;\n\nstruct HitInfo\n{\n    float distance;\n    int id;\n};\n\n    \nfloat hash( vec2 p )\n{\n    float h = dot(p,vec2(127.1,311.7));\n    \n    return -1.0 + 2.0*fract(sin(h)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n    \n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat texNoise0( in vec3 x, float lod_bias )\n{   \n    vec3 p = floor( x );\n    vec3 f = fract( x );\n    f = f * f * ( 3.0 - 2.0 * f );\n    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n    vec2 rg = texture( iChannel0, uv*(1./256.0), lod_bias ).yx;\n\n    return mix( rg.x, rg.y, f.z );\n}\n\nfloat texNoise1( in vec3 x, float lod_bias )\n{   \n    vec3 p = floor( x );\n    vec3 f = fract( x );\n    f = f * f * ( 3.0 - 2.0 * f );\n    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n    vec2 rg = texture( iChannel1, uv*(1./256.0), lod_bias ).yx;\n\n    return mix( rg.x, rg.y, f.z );\n}\n\nvec4 BlendUnder(vec4 accum,vec4 col)\n{\n    col = clamp( col, vec4( 0 ), vec4( 1 ) );   \n    accum += vec4( col.rgb * col.a, col.a ) * ( 1.0 - accum.a );   \n    return accum;\n}\n\nfloat sdSphere( vec4 pos, vec4 origin, float r ) \n{\n    return length( pos - origin ) - r;\n}\n\nfloat udBox( vec4 p, vec4 center, vec3 dimensions )\n{\n    p.x = mod( p.x, 4.0 ) - 0.5;\n    return length( max( abs( p - center ).xyz - dimensions, 0.0 ) );\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot( p, n.xyz ) + n.w;\n}\n\n// get distance in the world\nHitInfo dist_field( vec3 pos ) \n{\n    float d0 = sdSphere( vec4( pos, 1 ), vec4( -0.5, 0.0, 3.5, 1 ), 1.0 );\n    float d1 = sdSphere( vec4( pos, 1 ), vec4( 4.5, 0.0, 0.5, 1 ), 1.0 );\n    float dBox = udBox( vec4( pos, 1 ), vec4( 1.5, 0, 1.5, 1 ), vec3( 0.2, 100, 0.2 ) );\n    float dPlane = sdPlane( pos, vec4( 0, 1, 0, 1 ) );\n    \n    float df1 = min( d1, min( dBox, d0 ) );\n    if( dPlane < df1 )\n        return HitInfo( dPlane, 0 );\n    else \n        return HitInfo( df1, 1 );\n}\n\n// get gradient in the world\nvec3 gradient( vec3 pos ) \n{\n    const vec3 dx = vec3( grad_step, 0.0, 0.0 );\n    const vec3 dy = vec3( 0.0, grad_step, 0.0 );\n    const vec3 dz = vec3( 0.0, 0.0, grad_step );\n    return normalize(   vec3(   dist_field( pos + dx ).distance - dist_field( pos - dx ).distance,\n                                dist_field( pos + dy ).distance - dist_field( pos - dy ).distance,\n                                dist_field( pos + dz ).distance - dist_field( pos - dz ).distance ) );\n}\n\nHitInfo rayMarch( vec3 origin, vec3 dir, float farClip )\n{\n    float rayDistance = 0.0;\n    for( int i = 0; i < max_iterations; i++ ) \n    {\n        HitInfo hit = dist_field( origin + dir * rayDistance );\n        float d = hit.distance;\n        if ( d <= stop_threshold )\n            return HitInfo( rayDistance, hit.id );\n  \n        rayDistance += d;\n    }\n    \n    return HitInfo( rayDistance, 0 ); // hack: default material is zero?\n}\n\nfloat softShadowRayMarch( vec3 origin, vec3 dir ) \n{\n    float rayDistance = 0.0;\n    float penumbra = 1.0;\n    for( int i = 0; i < max_iterations; i++ ) \n    {\n        float d = dist_field( origin + dir * rayDistance ).distance;\n        if ( d <= stop_threshold )\n            return 0.0;\n        penumbra = min( penumbra, 15.0 * d / rayDistance );\n        rayDistance += d;\n    }\n    \n    return penumbra;\n}\n\nvec4 rotYZ( vec4 v, float thetaDegs )\n{\n    mat4 m = mat4( 1 );\n    float thetaRads = DEGS2RADS * thetaDegs;\n    m[ 1 ].yz = vec2( cos( thetaRads ), -sin( thetaRads ) );\n    m[ 2 ].yz = vec2( sin( thetaRads ), cos( thetaRads ) );\n\n    return m * v;\n}\n\nvec3 calcLighting( vec3 n, vec3 v, vec3 l )\n{\n    vec3 Cdiff = vec3( 0.9, 0.8, 0.8 );\n    vec3 Cspec = vec3( 0.9, 0.6, 0.5 );\n    vec3 h = ( v + n ) / 2.0;\n    float m = 1.0;\n    vec3 light = ( Cdiff + ( m + 8.0 ) * 0.125 * pow( max( dot( n, h ), 0.0 ), m ) ) * 0.6183 * max( dot( n, l ), 0.0 );\n    \n    // lighting and lightning ===================\n    if( mod( iTime, 5.0 ) > 4.0 )\n        return light * 1.65;\n    else\n        return light;\n}\n\nfloat groundTex( vec3 point, vec2 scale )\n{\n    vec2 uv = point.xz * scale;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    float f  = 0.5000*noise( uv ); uv = m*uv;\n    f += 0.2500*noise( uv ); uv = m*uv;\n    f += 0.1250*noise( uv ); uv = m*uv;\n    f += 0.0625*noise( uv ); uv = m*uv;\n    f = 0.5 + 0.5*f;\n\n    f *= smoothstep( 0.0, 0.005, abs(point.x-0.6) );\n    return f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ar = iResolution.x / iResolution.y;\n    float theta = -31.0;\n    \n    vec2 ndcPoint = vec2( ( fragCoord.x / iResolution.x - 0.5) * ar, fragCoord.y / iResolution.y - 0.5 );\n    vec3 dir = normalize( vec3( ndcPoint, 1) );\n\n    dir = normalize( rotYZ( vec4( dir, 0 ), theta ).xyz );\n    vec3 eye = vec3( 1.5, -10, 1.5 ) - 15.0 * normalize( rotYZ( vec4( worldForward, 1 ), -theta ) ).xyz;\n    eye.y = 2.0;\n\n    HitInfo hit = rayMarch( eye, dir, clip_far );\n    if( hit.distance >= clip_far )\n        discard;\n    \n    float s = 1.0 - hit.distance / clip_far;\n    vec3 point = eye + dir * hit.distance;\n    vec3 lightDir = normalize( vec3( 1, 1, 1 ) );\n    vec3 n = gradient( point );\n\n    s *= softShadowRayMarch( point + lightDir * 0.01, lightDir );\n    \n    // falling rain ===============================================\n    float last_t = 0.;\n    vec4 accum = vec4( 0, 0, 0, 0);\n    for( int i = 0; i < 100; i++ )\n    {                           \n        float t = float( i ) * 0.04;\n\n        vec3 p = eye + t * dir;\n        vec3 uvw = p;\n        uvw.y /= 10.0;\n        uvw.y += iTime;\n        uvw *= 30.0;\n        \n        float dens = pow( texNoise0(uvw,-1000.), 6. + abs( 2. * sin( noise( vec2( iTime, iTime ) ) ) )  );\n        dens -= 0.25;\n        dens *= ( t-last_t )* 1.5;\n        \n        accum = BlendUnder( accum, vec4( 1, 1, 1, dens ) );\n            \n        last_t = t;\n    }\n\n    // rain hitting the ground =============================================\n    vec3 uvw = point;\n    uvw *= 20.0;\n    uvw.y += iTime * 20.0;\n    float dens = texNoise1( uvw, -100.0 );\n    dens = pow( dens, 5. );\n    dens=sin(dens);\n    dens *= 0.4;\n    accum = BlendUnder( accum, vec4( 1, 1, 1, dens ) );\n\n    vec3 col = vec3( 0 );\n\n    // ground plane =====================================\n    if( hit.id == 0)\n    {\n        vec3 light = vec3( s, s, s + 0.1);\n\n        // reflections =====================\n        vec3 r = reflect( dir, normalize( worldUp.xyz + 0.2 * vec3( dens, 0, dens ) ) );\n        hit = rayMarch( point + r * 0.01, r, clip_far );\n        if( hit.distance < clip_far )\n            light *= calcLighting( n, dir, lightDir );\n        \n        float f = groundTex( point, vec2( 0.125, 0.125 ) );\n        \n        light *= f;\n        col = light + vec3( mod( iTime, 5.0 ) > 4.0 ? 0.05 : 0. );\n        col = BlendUnder( accum, vec4( col, 1. ) ).rgb;\n    }\n    else // other objects\n    {\n        // lighting ===================================================\n        col = calcLighting( n, dir, lightDir );\n\n        col.rgb *= s;\n        col += vec3( mod( iTime, 5.0 ) > 4.0 ? 0.05 : 0. );\n        col = BlendUnder( accum, vec4( col, 1. ) ).rgb;\n    }\n\n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MsXXDf","date":"1411141315","viewed":2597,"name":"Dark and Stormy Night","username":"thallippoli","description":"Thanks to @antonalog's rain shader https://www.shadertoy.com/view/4sj3Wc (adapted minus the logarithmic stepping)\nWhat better name for first shadertoy ;)","likes":33,"published":1,"flags":0,"usePreview":0,"tags":["distancefield","rain","wet"],"hasliked":0,"parentid":"","parentname":""}}