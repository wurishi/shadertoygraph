{"ver":"0.1","info":{"id":"WtscDn","date":"1591880406","viewed":134,"name":"Fluid Volume 3D","username":"spalmer","description":"deconstructing one of wyatt's toys","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["fluid","physics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// deconstructing a toy by wyatt https://shadertoy.com/view/ws2fDc\n// went down to 2D at https://shadertoy.com/view/wtlcWr\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nSampler0\n    \nvoid mainImage(out vec4 Q, vec2 u) //Main //\n{\n\tvec3 mi = .5*R3D; // middle of 3d buffer volume\n\tvec3 p = vec3(0,0,-R.y/N);\n\tvec3 d = normalize(vec3((u-.5*R)/R.y,1));\n\t// camera control\n\tvec2 ra = iMouse.z>0.\n\t\t? 6.2*vec2(iMouse.x/R.x, iMouse.y/R.y)\n\t\t: vec2(.2*iTime, .05*iTime);\n\tp.zx *= rot(ra.x);\n\td.zx *= rot(ra.x);\n\tp.yz *= rot(ra.y);\n\td.yz *= rot(ra.y);\n\tQ = vec4(0);\n\tfor (int i = 0; i < 128; ++i) {\n        vec3 o = abs(p)-mi;\n        float m = length(max(o,0.));\n        if (m < .01) { \t\n            vec4 a = 25.*S0(p+mi);\n            float aa = length(a);\n            Q += 6e-3*(1.-exp(-aa))*abs(a);\n            p += d*(.1+exp(-.1*aa*aa));\n           //p = mod(p+mi,R3D)-mi;\n        } else p += d*m;        \n \t}\n    Q = sqrt(Q); // to quasi-sRGB gamut for display\n}\n\n\t//Q = atan(Q)*.8; // wyatt's crazy tone map operator\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define N 10.\n// cannot access uniforms or samplers from Common tab btw\n#define R iResolution.xy\n// 3D resolution\n#define R3D vec3(R/N,N*N)\n#define d2(U) ((U).xy+vec2(mod(floor((U).z),N),floor(floor((U).z)/N))*R/N)\n// converts 2D buffer coordinate u to 3D coord\n#define d3(u) vec3(mod(u,R/N),floor(u/R*N).x+floor(u/R*N).y*N)\n// converts 2D buffer coordinate from Main arg u to 3D coord U\n// it's silly to wrap this with a macro!\n//#define _3D  vec3 U = d3(u)\n\n#define T0(U) texture(iChannel0, d2(U)/R)\n#define T1(U) texture(iChannel1, d2(U)/R)\n\n#define A(U) T0(mod(U,R3D))\n//#define B(U) T1(mod(U,R3D))\n// just defines a sampler function to access the channel easily\n#define Sampler0 vec4 S0(vec3 U) { \\\n\treturn mix(T0(vec3(U.xy,floor(U.z))), \\\n\t           T0(vec3(U.xy, ceil(U.z))), fract(U.z)); \\\n}\n#define Sampler1 vec4 S1(vec3 U) { \\\n\treturn mix(T1(vec3(U.xy,floor(U.z))), \\\n\t           T1(vec3(U.xy, ceil(U.z))), fract(U.z)); \\\n}\n#define Neighborhood vec4 \\\n  f = A(U+vec3(0,0,1)) \\\n, b = A(U-vec3(0,0,1)) \\\n, n = A(U+vec3(0,1,0)) \\\n, s = A(U-vec3(0,1,0)) \\\n, e = A(U+vec3(1,0,0)) \\\n, w = A(U-vec3(1,0,0));\n\n//#define Init  if (iFrame < 1)\n\n// I prefer not to wrap the entry points, it causes too much confusion\n//#define Main void mainImage(out vec4 Q, vec2 u)\n\n/*\n// TODO refactor F to common\n// the uniforms access in Common is fighting me every step of the way\nvoid F(sampler2D ch, vec2 r\n       , vec3 U, vec3 u, vec4 Q\n       , inout vec3 f, inout float m, inout float w, inout float n) \n{\n    // Advect\n    //vec4 a = S0(U+u-A(U+u).xyz);\n    vec4 a = mix(texture(ch, d2(vec3(U.xy,floor(U.z)))/r),\n\t             texture(ch, d2(vec3(U.xy, ceil(U.z)))/r), fract(U.z))\n    u = normalize(u);\n    // gradient of pressure\n    f += u*(a.w-Q.w);\n    // average pressure\n    m += a.w;\n    // divergence of velocity\n    w += dot(u,a.xyz);\n    // number of neighbors sampled\n    ++n;\n}\n*/\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"Sampler0\n    \nvoid F(vec3 U, vec3 u, vec4 Q, inout vec3 f, inout float m, inout float w, inout float n)\n{\n    // Advect\n    vec4 a = S0(U+u-A(U+u).xyz);\n    u = normalize(u);\n    // gradient of pressure\n    f += u*(a.w-Q.w);\n    // average pressure\n    m += a.w;\n    // divergence of velocity\n    w += dot(u,a.xyz);\n    // number of neighbors sampled\n    ++n;\n}\n\nvoid mainImage(out vec4 Q, vec2 u) //Main //\n{\n\tvec3 U = d3(u);\n    Q = S0(U-A(U).xyz);\n    vec3 f = vec3(0);\n    float w = 0.;\n    float m = 0., n = 0.;\n\n    F(U,vec3(0,0, 1),Q,f,m,w,n);\n    F(U,vec3(0,0,-1),Q,f,m,w,n);\n    F(U,vec3(0, 1,0),Q,f,m,w,n);\n    F(U,vec3(0,-1,0),Q,f,m,w,n);\n    F(U,vec3( 1,0,0),Q,f,m,w,n);\n    F(U,vec3(-1,0,0),Q,f,m,w,n);\n\n    f /= n;\n    w /= n;\n    m /= n;\n    Q.w = m - w;\n    Q.xyz -= f;\n}\n\n// output channels seem to be velocity in xyz and pressure in w\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"Sampler0\n    \nvoid F(vec3 U, vec3 u, vec4 Q, inout vec3 f, inout float m, inout float w, inout float n) \n{\n    // Advect\n    vec4 a = S0(U+u-A(U+u).xyz);\n    u = normalize(u);\n    // gradient of pressure\n    f += u*(a.w-Q.w);\n    // average pressure\n    m += a.w;\n    // divergence of velocity\n    w += dot(u,a.xyz);\n    // number of neighbors sampled\n    ++n;\n}\n\nvoid mainImage(out vec4 Q, vec2 u) //Main //\n{\n\tvec3 U = d3(u);\n    Q = S0(U-A(U).xyz);\n    vec3 f = vec3(0);\n    float w = 0.;\n    float m = 0., n = 0.;\n\n    F(U,vec3(0,0, 1),Q,f,m,w,n);\n    F(U,vec3(0,0,-1),Q,f,m,w,n);\n    F(U,vec3(0, 1,0),Q,f,m,w,n);\n    F(U,vec3(0,-1,0),Q,f,m,w,n);\n    F(U,vec3( 1,0,0),Q,f,m,w,n);\n    F(U,vec3(-1,0,0),Q,f,m,w,n);\n\n    f /= n;\n    w /= n;\n    m /= n;\n    Q.w = m - w;\n    Q.xyz -= f;\n}\n\n// output channels seem to be velocity in xyz and pressure in w\n\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"Sampler0\n    \nvoid F(vec3 U, vec3 u, vec4 Q, inout vec3 f, inout float m, inout float w, inout float n)\n{\n    // Advect\n    vec4 a = S0(U+u-A(U+u).xyz);\n    u = normalize(u);\n    // gradient of pressure\n    f += u*(a.w-Q.w);\n    // average pressure\n    m += a.w;\n    // divergence of velocity\n    w += dot(u,a.xyz);\n    // number of neighbors sampled\n    ++n;\n}\n\nvoid mainImage(out vec4 Q, vec2 u) //Main //\n{\n\tvec3 U = d3(u);\n    Q = S0(U-A(U).xyz);\n    vec3 f = vec3(0);\n    float w = 0.;\n    float m = 0., n = 0.;\n\n    F(U,vec3(0,0, 1),Q,f,m,w,n);\n    F(U,vec3(0,0,-1),Q,f,m,w,n);\n    F(U,vec3(0, 1,0),Q,f,m,w,n);\n    F(U,vec3(0,-1,0),Q,f,m,w,n);\n    F(U,vec3( 1,0,0),Q,f,m,w,n);\n    F(U,vec3(-1,0,0),Q,f,m,w,n);\n\n    f /= n;\n    w /= n;\n    m /= n;\n    Q.w = m - w;\n    Q.xyz -= f;\n\n    if (length(U-vec3(0.5,.5,0.9)*R3D) < 5. ) {\n\t\tQ.xyz = vec3(0,0,-.2)*(0.5+0.25*sin(.5*iTime));\n\t}\n    /*\n    if (length(U-vec3(0.51,.9,.5)*R3D) < 4. ) {\n\t\tQ.xyz = vec3(0,-.4,0)*(0.5+0.8*sin(.2*iTime));\n\t}\n    if (length(U-vec3(0.5,.1,.5)*R3D) < 4. ) {\n\t\tQ.xyz = vec3(0,.4,0)*(0.5+0.8*sin(.4*iTime));\n\t}\n\t*/\n    if (U.x<1.||U.y<1.||U.z<1.||R3D.x-U.x<1.||R3D.y-U.y<1.||R3D.z-U.z<2.) Q.xyz *= 0.;\n}\n\n// output channels seem to be velocity in xyz and pressure in w\n\n","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"Sampler0\nSampler1\n    \nvoid mainImage(out vec4 Q, vec2 u) //Main //\n{\n\tvec3 U = d3(u);\n    U -= S1(U).xyz;\n    U -= S1(U).xyz;\n    U -= S1(U).xyz;\n    // look backward 3 iterations, tracing velocity field in reverse   \n    Q = S0(U); // advect color\n    // HEY BTW FIXME\n    // it's silly to have to model the jets in two different buffers\n    // this should be centralized to common somehow\n    // jets reverse direction btw - I tweaked it\n    if (length(U-vec3(0.5,.5,0.9)*R3D) < 3.) {\n        //Q = 0.5+0.25*sin(.1*iTime*vec4(1,2,3,4));\n        Q = vec4(.5, 0., 0., Q.w); //\n    }/* // turned off the other 2 jets\n    if (length(U-vec3(0.51,.1,.5)*R3D) < 3. ) {\n    \tQ = 0.5+0.5*sin(.1*iTime+vec4(4,3,2,1));\n    }\n    if (length(U-vec3(0.5,.9,.5)*R3D) < 3. ) {\n    \tQ = 0.5+0.5*sin(.1*iTime-vec4(4,3,2,1));\n    }*/\n}\n\n// not 100% sure but think this buffer\n// represents the colors of the fluid\n// I believe I could ignore Buffer D \n// and just render the densities in Buffer C directly\n// but then it wouldn't have different colors of fluid!\n// right now I have it hacked to one red jet anyway.\n\n// output channels seem to be color in rgb and density/opacity in alpha\n\n","name":"Buffer D","description":"","type":"buffer"}]}