{"ver":"0.1","info":{"id":"wl2SD1","date":"1565809159","viewed":92,"name":"RayMarching learn #3","username":"dnkorbut","description":"learning lighting","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","lighting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_MARCH 640\n#define MAX_DST 100.\n#define MIN_DST .01\n#define AMBIENT_DST .1\n\n#define OBJ_PLANE .5\n#define OBJ_SPHERE .51\n\n#define OBJECTS 8\n\nmat4 obj[OBJECTS];\n\n// globals\nvec3 p;\nint o;\nfloat deltaDst;\n\nvec3 getNor(int o, vec3 p) {\n    if(obj[o][3][3] < OBJ_SPHERE) {\n        return obj[o][2].xyz;\n    }else{\n    \treturn normalize(p - obj[o][0].xyz);\n    }\n}\n\nfloat getDistance(vec3 p) {\n    float min = 255.;\n    float res;\n    for(int c = 0; c < OBJECTS; c++) {\n        \n        if(obj[c][3][3] < OBJ_SPHERE) {\n            res = abs(p.y - obj[c][0][1]); // plane\n        }else{\n            res = length(p - obj[c][0].xyz) - obj[c][0].w; // sphere\n        }\n        \n        if(min > res) {\n            deltaDst = min - res;\n            min = res;\n            o = c;\n        }\n        \n    }\n    return min;\n}\n\nfloat rayMarch(vec3 start, vec3 dir) {\n    float ret = 0.;\n    int i;\n    float dst;\n    \n    for(i = 0; i < MAX_MARCH; i++) {\n        p = start + dir * ret;\n        dst = getDistance(p);\n        ret += dst;\n        if(ret > MAX_DST || dst < MIN_DST) {\n           break; \n        }\n    }\n    return ret;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\n    // light\n    vec3 light = vec3(sin(iTime) * 10., 6., cos(iTime) * 10. + 10.);\n    vec3 light2 = vec3(sin(iTime + 3.14) * 10., 6., cos(iTime + 3.14) * 10. + 10.);\n    \n    // camera\n    vec3 cam = vec3(0., 1., 0.);\n    vec3 dir = normalize(vec3(uv.x, uv.y, 1.));\n    \n    // objects\n    obj[0][0] = vec4(0., .2, 0., 0.); // infinite plane at zero Y\n    obj[0][1] = vec4(.5, .5, .5, 1.);\n    obj[0][2] = vec4(0., 1., 0., 0.);\n    obj[0][3][3] = OBJ_PLANE;\n    \n    obj[1][0] = vec4(0., 1., 6., 1.); // red sph\n    obj[1][1] = vec4(1., 0., 0., 1.);\n    obj[1][3][3] = OBJ_SPHERE;\n    \n    obj[2][0] = vec4(1.5, 0.8, 6., 0.8); // blue sph\n    obj[2][1] = vec4(0., 0., 1., 1.);\n    obj[2][3][3] = OBJ_SPHERE;\n    \n    obj[3][0] = vec4(-1.5, 0.8, 6., 0.8); // green sph\n    obj[3][1] = vec4(0., 1., 0., 1.);\n    obj[3][3][3] = OBJ_SPHERE;\n    \n    obj[4][0] = vec4(0., .4, 2., .4); // yellow sph\n    obj[4][1] = vec4(1., 1., 0., 1.);\n    obj[4][3][3] = OBJ_SPHERE;\n    \n    obj[5][0] = vec4(1.5, 0.6, 3., 0.6); // magenta sph\n    obj[5][1] = vec4(1., 0., 1., 1.);\n    obj[5][3][3] = OBJ_SPHERE;\n    \n    obj[6][0] = vec4(-1.5, 0.6, 3., 0.6); // cyan sph\n    obj[6][1] = vec4(0., 1., 1., 1.);\n    obj[6][3][3] = OBJ_SPHERE;\n    \n    obj[7][0] = vec4(0., 7., 0., 0.); // infinite plane at 7 Y\n    obj[7][1] = vec4(.5, 1., .5, 1.);\n    obj[7][2] = vec4(0., -1., 0., 0.);\n    obj[7][3][3] = OBJ_PLANE;\n    \n    for(int i = 0; i < OBJECTS; i++) {\n        //obj[i][0].x *= cos(iTime);\n        //obj[i][0].z *= sin(iTime);\n    }\n    \n    float dst = rayMarch(cam, dir);\n    \n    dir = normalize(light - p);\n    vec3 nor = getNor(o, p);\n    \n    vec3 dir2 = normalize(light2 - p);\n    \n    float colMul = clamp(dot(dir, nor), 0.3, 0.5);\n    float colMul2 = clamp(dot(dir2, nor), 0.3, 0.5);\n    float ambient = 1.;\n    \n    if(deltaDst < AMBIENT_DST) {\n        ambient = deltaDst / AMBIENT_DST;\n    }\n    \n    vec4 c = obj[o][1];\n    vec3 collisionP = p;\n    int collisionO = o;\n    \n    float shadow = rayMarch(p + (nor * MIN_DST * 2.), dir);\n    \n    if(shadow < length(light - p)) {\n        colMul *= .9;\n    }\n    \n    \n    shadow = rayMarch(p + (nor * MIN_DST * 2.), dir2);\n    \n    if(shadow < length(light2 - p)) {\n        colMul *= .9;\n    }\n    \n    nor = normalize(reflect(collisionP - cam, nor));\n    if(rayMarch(collisionP + (nor * MIN_DST * 2.), nor) < 10.) {\n    \tc = obj[o][1] + (obj[collisionO][1] * .5);\n    }\n    \n    vec4 c2 = c;\n    c2.rgb *= colMul2;\n    c.rgb *= colMul;\n    \n    fragColor = (c + c2) * ambient;\n}\n","name":"Image","description":"","type":"image"}]}