{"ver":"0.1","info":{"id":"csKfz1","date":"1704205888","viewed":24,"name":"Julia set renderer bc why not","username":"fizzles","description":"Renders julia sets and mandlebrot set if you ask nicely\n\ndon't judge my terrible uncommented code :D\n\nalso has some other complex number functions that partially work from when i was messing around with complex graphs","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["julia"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TAU 6.283185307179586\n#define E 2.718281828459045\n\n\n//returns a vec2 complex number with imaginary part zero\nvec2 absComplex(in vec2 complexZ) {\n    return vec2(length(complexZ),0.0);\n}\n\n//returns a vec2 complex number with imaginary part zero\nvec2 argComplex(in vec2 complexZ) {\n    return vec2(mod(atan(complexZ.y,complexZ.x), TAU),0.0);\n}\n\nvec2 conjComplex(in vec2 complexZ) {\n    return complexZ * vec2(1.0,-1.0);\n}\n\nvec2 multComplex(in vec2 complexA, in vec2 complexB) {\n    return vec2(complexA.x*complexB.x-complexA.y*complexB.y, complexA.x*complexB.y+complexA.y*complexB.x);\n}\n\n#define sqrComplex(complexZ) multComplex(complexZ, complexZ)\n\nvec2 divComplex(in vec2 complexA, in vec2 complexB) {\n    return multComplex(complexA, conjComplex(complexB)) / (complexB.x*complexB.x+complexB.y*complexB.y);\n}\n\nvec2 expComplex(in vec2 complexZ) {\n    return exp(complexZ.x) * vec2(cos(complexZ.y), sin(complexZ.y));\n}\n\nvec2 lnComplex(in vec2 complexZ) {\n    float argZ = argComplex(complexZ).x;\n    float absZ = absComplex(complexZ).x;\n    \n    return vec2(log(absZ), argZ);\n}\n\nvec2 powerComplex(in vec2 complexBase, in vec2 complexExponent) {\n    return expComplex(multComplex(lnComplex(complexBase), complexExponent));\n}\n\nvec2 unitComplex(in vec2 complexZ) {\n    return divComplex(complexZ, absComplex(complexZ));\n}\n\nvec2 zetaComplex(in vec2 complexS, in int prec) {\n/**/\n    if (false && complexS.x > 1.0) {\n        if (complexS.x <= 1.0) {\n            return vec2(0.0);\n        }\n\n\n        vec2 result = vec2(0.0);\n\n        for (vec2 n = vec2(1.0,0.0); int(n.x) <= prec; n += vec2(1.0,0.0)) {\n            result += powerComplex(n, -complexS);\n        }\n\n        return result;\n    } else {\n\n        if (complexS.x <= 0.0) {\n            return vec2(0.0);\n        }\n\n\n        vec2 result = vec2(0.0);\n\n        for (vec2 n = vec2(1.0,0.0); int(n.x) <= prec; n += vec2(1.0,0.0)) {\n            result += powerComplex(n, -complexS) * (mod(n.x,2.0) == 0.0 ? -1.0 : 1.0);\n        }\n\n        return divComplex(result, vec2(1.0,0.0) - powerComplex(vec2(2.0,0.0), vec2(1.0,0.0) - complexS));\n    }/**/\n    \n    /*\n        vec2 result = vec2(0.0);\n\n        for (vec2 n = vec2(1.0,0.0); int(n.x) <= prec; n += vec2(1.0,0.0)) {\n            for (float k = 0.0, k <= n.x)\n            result += powerComplex(n, -complexS) * (mod(n.x,2.0) == 0.0 ? -1.0 : 1.0);\n        }\n\n        return divComplex(result, vec2(1.0,0.0) - powerComplex(vec2(2.0,0.0), vec2(1.0,0.0) - complexS));\n*/\n}\nvec2 zetaComplex(in vec2 complexS) {\n    return zetaComplex(complexS, 10);\n}\n\nvec3 hsl2rgb(in vec3 hsl) {\n    float strongCol = (1.0-abs(2.0*hsl.z - 1.0))*hsl.y;\n    float bleedCol = strongCol*(1.0 - abs(mod(hsl.x/(TAU/6.0), 2.0) - 1.0));\n    float baseLightness = hsl.z - strongCol/2.0;\n    \n    vec3 rgb;\n    \n    //variants\n    if (hsl.x < TAU*1.0/6.0) {\n        rgb = vec3(strongCol, bleedCol, 0.0);\n    } else if (hsl.x < TAU*2.0/6.0) {\n        rgb = vec3(bleedCol, strongCol, 0.0);\n    } else if (hsl.x < TAU*3.0/6.0) {\n        rgb = vec3(0.0, strongCol, bleedCol);\n    } else if (hsl.x < TAU*4.0/6.0) {\n        rgb = vec3(0.0, bleedCol, strongCol);\n    } else if (hsl.x < TAU*5.0/6.0) {\n        rgb = vec3(bleedCol, 0.0, strongCol);\n    } else {\n        rgb = vec3(strongCol, 0.0, bleedCol);\n    }\n    \n    return rgb + vec3(baseLightness);\n}\n\nvec3 complex2rgb(in vec2 complexZ) {\n    //complexZ = multComplex(complexZ,expComplex(vec2(0.0,TAU/3.0)));\n    return vec3(hsl2rgb(vec3(argComplex(complexZ).x,0.5,1.0-pow(2.0,-absComplex(complexZ).x))));\n}\n\n\nvec2 iterFunc(in vec2 complexZ, in vec2 complexC) {\n    \n    return sqrComplex(complexZ) + complexC;\n\n}\n\n\nvec2 complexSigmoid(in vec2 complexZ) {\n    return divComplex(vec2(2.0,0.0),vec2(1.0,0.0)+expComplex(-complexZ/9.99)) - vec2(1.0,0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\n    vec2 uv = fragCoord/iResolution.y;\n    vec2 val = uv;\n    \n    val = (val-vec2(0.5*iResolution.x/iResolution.y,0.5))*6.0;\n    \n    float escaped = -1.0;\n    \n    //vec2 z = vec2(0.0); //mandelbrot\n    vec2 z = val;//julia\n    \n    \n    for (float i = 0.0; i < 200.0; i+=1.0) {\n        \n        //z = iterFunc(z, val); //mandelbrot\n        z = iterFunc(z, vec2(0.5*sin(iTime/2.0),cos(iTime*E/2.0))); //juila\n        \n        if (absComplex(z).x > 2.0) {\n            escaped = i;\n            break;\n        }\n    }\n    \n    \n    if (escaped == -1.0) {\n        fragColor = vec4(0.0,0.0,0.0,1.0);\n    } else {\n        fragColor = vec4(hsl2rgb(vec3(5.0*TAU/6.0, 1.0, complexSigmoid(vec2(escaped,0.0)).x)), 4.0*complexSigmoid(vec2(escaped,0.0)).x);\n    }\n    \n    //fragColor = vec4(complex2rgb(val),1.0);\n    \n}\n\n\n/*\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    vec2 val = uv;\n    val = (val-vec2(0.5*iResolution.x/iResolution.y,0.5))*6.0;\n    \n    vec2 baseVal = val;\n    \n    val = zetaComplex(val,/*int(floor(iTime*60.0))*///10000);\n    //val = unitComplex(val);\n    \n    //fragColor = vec4(multComplex(uv,uv), 0.0, 1.0);\n    //fragColor = vec4(hsl2rgb(vec3(uv.x*TAU,-2.0+iTime/5.0,uv.y)),1.0);\n    //fragColor = vec4(complex2rgb(val),1.0);\n    \n    /*if (mod(baseVal.y,10.0) < 0.1) {\n        fragColor.xyz = vec3(1.0) - fragColor.xyz;\n    } else if (baseVal.x < 0.55 && 0.45 < baseVal.x) {\n        fragColor.xyz = vec3(1.0) - fragColor.xyz;\n    }\n*/\n\n\n","name":"Image","description":"","type":"image"}]}