{"ver":"0.1","info":{"id":"WdlXzr","date":"1550498955","viewed":119,"name":"Orbitando","username":"AdrianPi","description":"Old-school raytracing","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["3d","raytracing","polkadots"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\nThis is public domain. Do what you please with it :)\n\n*/\n\n\nstruct ray_t\n{\n    vec3 pos;\n    vec3 dir;\n    int level;\n    vec4 contrib;\n};\n    \nstruct hit_t\n{\n    float t;\n    vec3 pos;\n    vec3 normal;\n    int mat;\n};\n    \nconst int STANDARD_MATERIAL = 1;\nconst int CHECKER_MATERIAL = 2;\nconst int POLKA_MATERIAL = 3;\n    \nstruct material_t\n{\n    int type;\n    int flags;\n    int attrib0;\n    int attrib1;\n    vec4 ambient;\n    vec4 diffuse;\n    vec4 specular;\n    vec4 emission;\n    vec4 reflection;\n    vec4 transparent;\n};\n    \nconst int SPHERE_PRIMITIVE = 1;\nconst int PLANE_PRIMITIVE = 2;\nconst int RING_PRIMITIVE = 3;\n\nstruct primitive_t\n{\n    int type;\n    int mat;\n    vec3 v0;\n    vec3 v1;\n    vec3 v2;\n};\n    \nconst float PI = 3.1415926535897932384626433832795;\nconst float INFINITE = 1e6;\nconst float EPSILON = 1e-6;\n\nvec3 viewFrom = vec3(0,-1,1);\nvec3 viewAt = vec3(0,0,-1);\nvec3 viewUp = vec3(0,0,1);\nfloat viewFov = 45.0;\n\nvec3 viewDir;\nvec3 viewRight;\nfloat viewTan;\nfloat aspect = 1.33;\nint oversample = 2;\n\nvec4 skyColor = vec4(1,0.5,0,1);\nvec4 horizonColor = vec4(1,0.75,0.25,1);\n\nconst material_t material0 = material_t(STANDARD_MATERIAL,\n                                   0,0,0, \n                                   vec4(1,0,0,1), \n                                   vec4(1,0,0,1), \n                                   vec4(1,1,1,100), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0));\n\nconst material_t material1 = material_t(STANDARD_MATERIAL,\n                                   0,0,0, \n                                   vec4(1,1,1,1), \n                                   vec4(1,1,1,1), \n                                   vec4(1,1,1,100), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0));\n\nconst material_t material2 = material_t(\n    \t\t\t\t\t\t\t   POLKA_MATERIAL,\n    \t\t\t\t\t\t\t   0,0,1, \n                                   vec4(0.5,0.5,0.5,0), \n                                   vec4(0.001,0.001,0.001,0), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0));\n\nconst material_t material3 = material_t(\n    \t\t\t\t\t\t\t   STANDARD_MATERIAL,\n    \t\t\t\t\t\t\t   0,0,0, \n                                   vec4(0,0,0,1), \n                                   vec4(0,0,0,1), \n                                   vec4(1,1,1,50), \n                                   vec4(0,0,0,0), \n                                   vec4(0.2,0.2,0.2,0), \n                                   vec4(0.6,0.6,0.6,1.24));\n\nconst material_t material4 = material_t(\n    \t\t\t\t\t\t\t   STANDARD_MATERIAL,\n    \t\t\t\t\t\t\t   0,0,0, \n                                   vec4(0.3,0.3,0.3,1), \n                                   vec4(0.3,0.3,0.3,1), \n                                   vec4(1,1,1,50), \n                                   vec4(0,0,0,0), \n                                   vec4(0.6,0.6,0.6,0), \n                                   vec4(0,0,0,0));\n\nconst material_t material5 = material_t(\n    \t\t\t\t\t\t\t   STANDARD_MATERIAL,\n    \t\t\t\t\t\t\t   0,0,0, \n                                   vec4(0,0,1,1), \n                                   vec4(0,0,1,1), \n                                   vec4(1,1,1,60), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0));\n\nconst material_t material6 = material_t(\n    \t\t\t\t\t\t\t   STANDARD_MATERIAL,\n    \t\t\t\t\t\t\t   0,0,0, \n                                   vec4(.8,.4,0,1), \n                                   vec4(.8,.4,0,1), \n                                   vec4(0.5,0.5,0.5,30), \n                                   vec4(0,0,0,0), \n                                   vec4(0.1,0.1,0.1,0), \n                                   vec4(0,0,0,0));\n\nmaterial_t materials[7] = material_t[7](material0, material1, material2, material3, material4, material5, material6);\n\n\nconst primitive_t _floor = primitive_t(PLANE_PRIMITIVE, 2, vec3(0, 0, -3), vec3(0, 0, 1), vec3(0,0,0));\nconst primitive_t _sphere = primitive_t(SPHERE_PRIMITIVE, 3, vec3(0, 0, -1), vec3(2, 0, 0), vec3(0,0,0));\nconst primitive_t _sphere2 = primitive_t(SPHERE_PRIMITIVE, 4, vec3(4, 2, -1.5), vec3(1.5, 0, 0), vec3(0,0,0));\nconst primitive_t _sphere3 = primitive_t(SPHERE_PRIMITIVE, 5, vec3(-4, -3, -2), vec3(1, 0, 0), vec3(0,0,0));\nconst primitive_t _sphere4 = primitive_t(SPHERE_PRIMITIVE, 6, vec3(-2, 4, -1.8), vec3(1.2, 0, 0), vec3(0,0,0));\n\nconst int NUM_PRIMS = 5;\n\nprimitive_t prims[NUM_PRIMS] = primitive_t[NUM_PRIMS](_floor, _sphere, _sphere2, _sphere3, _sphere4);\n\nray_t primary_ray(float fx, float fy)\n{\n    ray_t ray;\n    ray.pos = viewFrom;\n    ray.dir = normalize(viewDir + viewRight * fx  * aspect + viewUp * fy);\n    ray.contrib = vec4(1,1,1,1);\n    return ray;\n}\n\nvec4 background(ray_t ray)\n{\n\tfloat t = 1.0 - ray.dir.z * ray.dir.z;\n    t = pow(t, 30.0);\n    return skyColor * (1.0-t) + horizonColor * t;\n}\n\nbool hit_sphere(vec3 center, float radius, int mat, ray_t ray, inout hit_t hit)\n{\n    vec3 q = ray.pos - center;\n    float a = dot(ray.dir, ray.dir);\n    float b = 2.0 * dot(q, ray.dir);\n    float c = dot(q,q) - radius * radius;\n    float d = b * b - 4.0 * a * c;\n    if(d > EPSILON)\n    {\n        float t0 = (-b - sqrt(d)) / (2.0 * a);\n        float t1 = (-b + sqrt(d)) / (2.0 * a);\n\n        float t = INFINITE;\n        \n        if(t1 > EPSILON && t1 < t0)\n        {\n            t = t1;\n        }\n        else            \n        {\n            t = t0;\n        }\n        \n        if(t < EPSILON)\n        {\n            t = INFINITE;\n        }\n        \n        if(t != INFINITE)\n        {\n            hit.t = t;\n            hit.pos = ray.pos + ray.dir * hit.t;\n            hit.normal = normalize(hit.pos - center);\n            hit.mat = mat;\n            return true;\n        }\n    }\n    return false;\n}\n\nbool hit_plane(vec3 p0, vec3 normal, int mat, ray_t ray, inout hit_t hit)\n{\n    float d = dot(normal, ray.dir);\n    if(d > EPSILON || d < -EPSILON)\n    {\n        vec3 q = p0 - ray.pos;\n        float t = dot(q, normal) / d;\n        if(t > EPSILON)\n        {\n            hit.t = t;\n        \thit.pos = ray.pos + ray.dir * t;\n        \thit.normal = normal;\n        \thit.mat = mat;\n        \treturn true;\n        }\n    }\n    return false;\n}\n\nbool hit_ring(vec3 p0, vec3 normal, float r1, float r2, int mat, ray_t ray, inout hit_t hit)\n{\n    float d = dot(normal, ray.dir);\n    if(d > EPSILON || d < -EPSILON)\n    {\n        vec3 q = p0 - ray.pos;\n        float t = dot(q, normal) / d;\n        if(t > EPSILON)\n        {\n            vec3 p = ray.pos + ray.dir * t;\n            vec3 r = p - p0;\n            float e = dot(r, r);\n            if(e < r1*r1 && e > r2*r2)\n            {\n                hit.t = t;\n                hit.pos = p;\n                hit.normal = normal;\n                hit.mat = mat;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nvec4 ambientLight = vec4(0.2, 0.2, 0.1, 1);\nvec3 lightDirection = normalize(vec3(1,1,-1));\n\nray_t rayQueue[16];\nint rayHead = 0;\nint rayTail = 0;\n\nvoid enqueueRay(ray_t ray)\n{\n    if((rayTail+1) % 16 != rayHead)\n    {\n        rayQueue[rayTail] = ray;\n        rayTail++;\n        rayTail %= 16;\n    }\n}\n\nbool dequeueRay(inout ray_t ray)\n{\n    if(rayHead != rayTail)\n    {\n        ray = rayQueue[rayHead];\n        rayHead++;\n        rayHead %= 16;\n        return true;\n    }\n    return false;\n}\n\nvoid resetRayQueue()\n{\n    rayHead = rayTail = 0;\n}\n\nvoid intersect(ray_t ray, inout hit_t hit);\n\n\nvec4 shade_standard(ray_t ray, hit_t hit)\n{\n    if(ray.level >= 6)\n        return vec4(0,0,0,0);\n    \n    vec4 color = materials[hit.mat].ambient * ambientLight;\n    \n    ray_t sray;\n    sray.pos = hit.pos - lightDirection * EPSILON;\n    sray.dir = -lightDirection;\n    hit_t h;\n    intersect(sray, h);\n    if(h.t == INFINITE)\n    {    \n        float d = dot(-lightDirection, hit.normal);\n        d = clamp(d, 0.0, 1.0);\n        color += materials[hit.mat].diffuse * d;\n        vec3 r = reflect(ray.dir, hit.normal);\n        float s = dot(-lightDirection, r);\n        s = clamp(s, 0.0, 1.0);\n        s = pow(s, materials[hit.mat].specular.a);\n        color.rgb += materials[hit.mat].specular.rgb * s;\n    }\n    \n    color.rgb += materials[hit.mat].emission.rgb;\n    \n    vec3 refl = materials[hit.mat].reflection.rgb;\n    if(dot(refl, refl) > 0.0)\n    {\n        ray_t rray;\n        vec3 r = reflect(ray.dir, hit.normal);\n        rray.pos = hit.pos + r * 0.001;\n        rray.dir = r;\n        rray.level = ray.level + 1;\n        rray.contrib = vec4(refl, 1) * ray.contrib;\n        enqueueRay(rray);\n    }\n    \n    vec3 trans = materials[hit.mat].transparent.rgb;\n    if(dot(trans, trans) > 0.0)\n    {\n        float ior = materials[hit.mat].transparent.a;\n        if(dot(ray.dir, hit.normal) < 0.0)\n            ior = 1.0 / ior;\n        \n        ray_t rray;\n        rray.pos = hit.pos + ray.dir * 0.001;\n        rray.dir = refract(ray.dir, hit.normal, ior);\n        rray.level = ray.level + 1;\n        rray.contrib = vec4(trans, 1) * ray.contrib;\n        enqueueRay(rray);\n    }\n    \n    return color;\n}\n\nvec4 shade_checker(ray_t ray, hit_t hit)\n{\n    vec3 p = hit.pos * materials[hit.mat].ambient.xyz\n        + materials[hit.mat].diffuse.xyz;\n\n    int ix = int(floor(p.x)) & 0x01;\n    int iy = int(floor(p.y)) & 0x01;\n    int iz = int(floor(p.z)) & 0x01;\n\n    hit.mat = ((ix ^ iy ^ iz) == 0) ? materials[hit.mat].attrib0 : materials[hit.mat].attrib1;\n\n    return shade_standard(ray, hit);\n}\n\nvec4 shade_polka(ray_t ray, hit_t hit)\n{\n    vec3 p = hit.pos * materials[hit.mat].ambient.xyz\n        + materials[hit.mat].diffuse.xyz;\n\n    int iy = int(floor(p.y)) & 0x01;\n    if((iy & 0x01) == 1)\n        p.x += 0.5;\n\n    vec3 p2 = mod(p, vec3(1.));\n    p2 *= 2.;\n    p2 -= 1.;\n        \n    float d = dot(p2,p2);\n\n    hit.mat = (d < (.666*.666)) ? materials[hit.mat].attrib0 : materials[hit.mat].attrib1;\n\n    return shade_standard(ray, hit);\n}\n\nvec4 shade(ray_t ray, hit_t hit)\n{\n    vec4 color;\n    \n    if(hit.t != INFINITE)\n    {    \n        int type = materials[hit.mat].type;\n\n        if(type == STANDARD_MATERIAL)\n        {\n            color = shade_standard(ray, hit);\n        }\n        else if(type == CHECKER_MATERIAL) \n        {\n            color = shade_checker(ray, hit);\n        }\n        else if(type == POLKA_MATERIAL)\n        {\n            color = shade_polka(ray, hit);\n        }\n        \n        // fog\n\n        float f = (hit.t - 10.0) / (50.0-10.0);\n        f = clamp(f, 0.0, 1.0);\n        color = mix(color, horizonColor, f);\n    }\n    else\n    {\n        color = background(ray);\n    }\n    \n    return color * ray.contrib;\n}\n\nvoid intersect(ray_t ray, inout hit_t hit)\n{\n\thit.t = INFINITE;\n    \n    for(int i = 0; i < NUM_PRIMS; i++)\n    {\n    \thit_t h;\n        int type = prims[i].type;\n        bool result = false;\n        \n        switch(type)\n        {\n        case PLANE_PRIMITIVE:\n            result = hit_plane(prims[i].v0, prims[i].v1, prims[i].mat, ray, h);\n            break;\n        case SPHERE_PRIMITIVE:\n            result = hit_sphere(prims[i].v0, prims[i].v1.x,  prims[i].mat, ray, h);            \n            break;\n        case RING_PRIMITIVE:\n            result = hit_ring(prims[i].v0, prims[i].v1, prims[i].v2.x, prims[i].v2.y, prims[i].mat, ray, h);\n            break;\n        }\n        \n        if(result && h.t < hit.t)\n        {\n            hit = h;\n        }\n    }    \n}\n\nvec4 raytrace(ray_t ray)\n{\n    hit_t hit;\n    \n    intersect(ray, hit);\n    \n    return shade(ray, hit);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    viewFrom = vec3(sin(iTime*.5)*14.0, -cos(iTime*.5)*14.0, 2. + sin(iTime*1.5)*3.);\n    \n    \n    aspect = iResolution.x / iResolution.y;\n    viewTan = tan(((viewFov/180.0)*PI)/2.0);    \n    vec2 uv = fragCoord/iResolution.xy * vec2(2,2) - vec2(1,1);\n    uv *= viewTan;\n    viewDir = normalize(viewAt-viewFrom);\n\tviewRight = cross(viewDir, viewUp);\n    viewUp = cross(viewRight, viewDir);\n    \n    \n    vec4 color = vec4(0,0,0,0);\n    float sx = (1.0 / float(oversample)) / iResolution.x;\n    float sy = (1.0 / float(oversample)) / iResolution.y;\n    \n    for(int i = 0; i < oversample; i++)\n    {\n        for(int j = 0; j < oversample; j++)\n        {\n    \t\tray_t ray = primary_ray(uv.x + float(i) * sx, uv.y + float(j) * sy);\n            resetRayQueue();\n            enqueueRay(ray);\n            \n            while(dequeueRay(ray))\n\t    \t\tcolor += raytrace(ray);\n        }\n    }\n    \n    color /= float(oversample*oversample);\n    fragColor = color;\n}","name":"Image","description":"","type":"image"}]}