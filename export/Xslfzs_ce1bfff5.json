{"ver":"0.1","info":{"id":"Xslfzs","date":"1497605111","viewed":130,"name":"Halls","username":"Tenderz","description":"tests","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["wip"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct ShadingParameters\n{\n    vec3 position;\n    vec3 origin;\n    vec3 direction;\n    vec2 hit;\n    vec2 range;\n    float refl;\n    int depth;\n};\n\nstruct Path\n{\n    vec3 color;\n    vec3 colorMod;\n    float refl;\n    float dist;\n};\n\n// Hue to RGB\nvec3 h2rgb(float h)\n{\n    h = mod(h, 1.0);\n    vec3 c = vec3(\n        abs(h * 6.0 - 3.0) - 1.0,\n        2.0 - abs(h * 6.0 - 2.0),\n        2.0 - abs(h * 6.0 - 4.0)\n    );\n    return clamp(c,0.0,1.0);\n}\n\n// 2D rotate\nvec2 r2(vec2 p, float r)\n{\n    float c = cos(r);\n    float s = sin(r);\n    mat2 m = mat2(c, -s, s, c);\n    return  p * m;\n}\n\nvec2 f(vec3 p);\n\nvec2 trace(vec3 origin, vec3 direction, vec2 range, out vec3 pos)\n{\n    float d = range.x;\n    const float prec = 0.0001;\n    const int steps = 256;\n    for(int i = 0; i < steps; i++)\n    {\n        pos = origin + direction * d;\n        vec2 next = f(pos);\n        if(abs(next.x) < (prec*d))\n        {\n            return vec2(d, next.y);\n        }\n        d += next.x;\n        if(d > range.y)\n            break;\n    }\n    return vec2(range.y, -1.0);\n}\n\nvec3 tonemap(vec3 c)\n{\n    return c * 0.2;\n}\n\nPath shade(inout ShadingParameters params);\n\nvec3 fog(vec3 color, float dist)\n{\n    float r = clamp(dist/(20.0+5.0*cos(iTime*0.1)),0.0,1.0);\n    r = r*r;\n    return color * (1.0-r) + (h2rgb(iTime*0.01) * 2.0 + 5.0) * r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 origin = vec3(0.0+iTime * 0.4,2.5 + cos(iTime*0.5)* 0.1,60.0);\n    vec2 directionXY = (uv.xy * 2.0 - 1.0) * vec2(iResolution.x/iResolution.y, 1.0);\n    vec3 direction = normalize(vec3(directionXY, 2.5));\n    direction.zy = r2(direction.zy, -0.2);\n    direction.xz = r2(direction.xz, iTime*0.1);\n\n    vec3 hitPos;\n    \n    ShadingParameters params;\n    params.refl = 1.0;\n    params.depth = 0;\n    params.range = vec2(2.0,25.0);\n    params.position = origin;\n    params.origin = origin;\n    params.direction = direction;\n    params.hit = vec2(0.0);\n    Path paths[4];\n    int i;\n    for(i = 0; i < 4; i++)\n    {\n        params.hit = trace(params.origin, params.direction, params.range, params.position);\n        paths[i] = shade(params);\n        if(paths[i].refl <= 0.0001)\n            break;\n        params.depth += 1;\n    }\n\n    vec3 finalColor = vec3(0.0);\n    for(;i>= 0; i--)\n    {\n        vec3 cur = paths[i].color;\n        if(i>0)\n            cur *= paths[i-1].colorMod * paths[i-1].refl;\n        finalColor += cur;\n        // Apply fog\n        finalColor = fog(finalColor, paths[i].dist);\n    }\n\n    fragColor = vec4(tonemap(finalColor), 1.0);\n}\n\n// Smooth union\nvec2 sun(vec2 a, vec2 b, float k)\n{\n    float h = clamp(0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return vec2(mix(b.x, a.x, h) - k*h*(1.0-h), h > 0.5 ? a.y : b.y);\n}\n\nfloat sphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat cube(vec3 p, vec3 ext)\n{\n    return max(abs(p.x)-ext.x, max(abs(p.y)-ext.y, abs(p.z)-ext.z));\n}\n\nvec2 un(vec2 a, vec2 b)\n{\n    return a.x < b.x ? a : b;\n}\n\nvec2 ov(vec2 a, vec2 b)\n{\n    return a.x > b.x ? a : b;\n}\n\nvec2 sub(vec2 a, vec2 b)\n{\n    return a.x > -b.x ? a : vec2(-b.x, b.y);\n}\n\nvec2 f(vec3 p)\n{\n    vec2 v = vec2(dot(p, vec3(0.0,1.0,0.0))-cos(p.x)*0.1,6.0); // Floor\n    v = un(v, vec2(dot(p, vec3(0.0,-1.0,0.0))+4.0,6.0)); // Roof\n\n    vec3 boxp = p;\n    boxp.xz = mod(boxp.xz, 8.0)-4.0; // Offset & Loop\n    //boxp.xz = r2(boxp.xz, p.y + floor(p.z)/4.0*-9.4 + floor(p.x)/4*2.3); // Twist\n    vec3 spherep = boxp;\n    spherep.xz *= 1.0;\n    spherep.y -= 2.0;\n    float boxf = cube(boxp, vec3(0.5,4.0,0.5));\n    float spheref = sphere(spherep, 1.25);\n    float spheref1 = sphere(spherep, 0.9 + cos(iTime) * 0.2);\n    vec2 boxInner = vec2(spheref1, 2.0);\n    vec2 boxOuter = sub(vec2(boxf, 1.0), vec2(spheref, 1.0));\n    v = sun(v, un(boxOuter, boxInner), 0.1); // Box\n\n    return v;\n}\n\nvec3 computeNormal(vec3 p)\n{\n    float e = 0.1;\n    vec3 n;\n    n.x = (f(p+vec3(e,0.0,0.0)) - f(p-vec3(e,0.0,0.0))).x;\n    n.y = (f(p+vec3(0.0,e,0.0)) - f(p-vec3(0.0,e,0.0))).x;\n    n.z = (f(p+vec3(0.0,0.0,e)) - f(p-vec3(0.0,0.0,e))).x;\n    return normalize(n);\n}\n\nPath shade(inout ShadingParameters params)\n{\n    Path ret;\n    vec3 normal = computeNormal(params.position);\n    vec3 l = -normalize(vec3(5.0,-10.0,10.0));\n    float nDotL = max(0.0, dot(l,normal));\n\n    vec3 refl = params.direction + normal * dot(normal, -params.direction) * 2.0;\n\n    //vec3 shadowHitPosition;\n    //vec2 shadowHit = trace(params.position-l*0.5, -l, vec2(0.3, 100.0), shadowHitPosition);\n    //nDotL *= clamp(shadowHit.x/20.0, 0.0, 1.0);\n\n    ret.refl = 0.0;\n    ret.color = vec3(0.0);\n    ret.colorMod = vec3(1.0);\n    ret.dist = params.hit.x;\n    float material = params.hit.y;\n    if(material == 1.0)\n    {\n        vec3 b = h2rgb(params.position.x*0.1) * 0.7 + 0.2;\n        ret.color = b * nDotL;\n    }\n    else if(material == 2.0)\n    {\n        if(params.depth == 0)\n        {\n            ret.refl = 1.0;\n            params.origin = params.position;\n            params.direction = refl;\n            params.range = vec2(0.5, 25.0);\n        }\n        vec3 b = h2rgb(params.position.x*0.1) * 0.2 + 0.8;\n        ret.colorMod = b;\n        ret.color = vec3(0.4);\n    }\n    else if(material == 6.0)\n    {\n        ivec2 inCoord = ivec2(floor((params.position.xz+2000.0) * 4.0));\n        inCoord.x %= 2;\n        inCoord.y %= 2;\n        float grid = inCoord.x == inCoord.y ? 1.0 : 0.5;\n\n        vec2 janUv = params.position.xz * 0.1;\n        janUv = mod(janUv, 1.0);\n        vec3 jan = texture(iChannel0, janUv).rgb;\n       \n        vec3 c = vec3(0.7) * nDotL * grid;\n        float blend = min(1.0, (0.5-jan.g) / 0.5);\n        c = mix(c, jan.xyz * 2.0, blend).xyz;\n        ret.color = c;\n    }\n\n    return ret;\n}","name":"Image","description":"","type":"image"}]}