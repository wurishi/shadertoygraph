{"ver":"0.1","info":{"id":"wdS3Wh","date":"1548713969","viewed":636,"name":"[twitch]Water Depth","username":"NuSan","description":"Shader coded live on twitch (https://www.twitch.tv/nusan_fx)\nYou can lower the VOLUMETRIC_STEPS and MARCH_STEPS if too slow","likes":32,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","transparency","volumetric","live","twitch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nShader coded live on twitch (https://www.twitch.tv/nusan_fx)\nYou can lower the VOLUMETRIC_STEPS and MARCH_STEPS if too slow\n\nThe shader was made using Bonzomatic and it's default noise texture, so the result here is not the same.\nYou can find the original shader here: http://lezanu.fr/LiveCode/WaterDepth.glsl\n*/\n\n#define VOLUMETRIC_STEPS 100\n#define MARCH_STEPS 100\n#define time iTime\n\nfloat waterlevel = -2.0;\n\nfloat box(vec3 p, vec3 s) {\n  vec3 ap=abs(p)-s;\n  return length(max(vec3(0), ap)) + min(0.0, max(ap.x,max(ap.y,ap.z)));\n}\n\nfloat sph(vec3 p, float r) {\n  return length(p)-r;\n}\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nvec3 smin(vec3 a, vec3 b, float h) {\n  vec3 k = clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k) - k*(1.0-k)*h;\n}\n\nvec2 smin(vec2 a, vec2 b, float h) {\n  vec2 k = clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k) - k*(1.0-k)*h;\n}\n\nfloat smin(float a, float b, float h) {\n  float k = clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k) - k*(1.0-k)*h;\n}\n\n\nfloat mat = 0.0;\nfloat map(vec3 p) {\n  float t = texture(iChannel0, p.xz*0.015).x*5.0 + 6.0;\n  float terrain = t-p.y;\n  float c = length(p.xz)-0.5;\n  float water = waterlevel+p.y;\n  vec3 rp = p;\n  rp.xz = (fract(rp.xz/15.0-0.5)-0.5)*15.0;\n  vec3 rp2 = p;\n  rp2.xz = (fract(rp2.xz/2.0-0.5)-0.5)*2.0;\n  float b = box(rp-vec3(0,7,0), vec3(3,1,3));\n  b = max(b, -box(rp2-vec3(0,7,0), vec3(0.8,10,0.3)));\n\n  vec3 sp = rp-vec3(0,4,0);\n  for(int i=0; i<2; ++i) {\n    float t1 = float(i)+time;\n    sp -= 0.2+float(i)*0.2;\n    sp.xy *= rot(t1);\n    sp -= 0.1+float(i)*0.1;\n    sp.yz *= rot(t1*0.7);\n    //sp = abs(sp);\n    sp.xz = smin(sp.xz, -sp.xz, -1.5);\n    sp -= 0.3+float(i)*0.3;\n  }\n  \n  float s = sph(sp, 0.5);\n  //s = smin(s, 1.0-p.y, -3.0);\n  float solid=min(b, min(terrain, water));\n  s = max(s,-solid);  \n  mat = s<solid?1.0:0.0;\n  return min(s,solid);\n}\n\nvec3 norm(vec3 p) {\n  vec2 off=vec2(0.1,0);\n  return normalize(map(p)-vec3(map(p-off.xyy),map(p-off.yxy),map(p-off.yyx)));\n}\n\nfloat caustic(vec3 p) {\n  float t = time*0.1;\n  float size = 0.14;\n  float v1 = texture(iChannel0, p.xz*size + t*vec2(1,0)).x;\n  float v2 = texture(iChannel0, p.zx*size*0.7 - t*vec2(0.2,0.6)).x;\n  float v = 0.4-abs(v1-v2);\n  return v;\n}\n\nfloat caustic2(vec3 p) {\n  //return caustic(p);\n  return clamp((caustic(p)-0.035)*1.1,0.0,1.0);\n}\n\nvec3 causticnorm(vec3 p) {\n  vec2 off=vec2(0.04,0);\n  return normalize(vec3(caustic2(p+off.xyy)-caustic2(p-off.xyy), -0.2,caustic2(p+off.yyx)-caustic2(p+off.yyx)));\n}\n\nfloat rnd(vec2 t) {\n  return fract(dot(sin(t*vec2(741.145,565.232) + t.yx*vec2(422.988,567.333)), vec2(7789.532)));\n}\n\nfloat rnd(float t) {\n  return fract(sin(t*478.556)*8522.412);\n}\n\nfloat curve(float t, float d) {\n  float g=t/d;\n  return mix(rnd(floor(g)), rnd(floor(g)+1.0), pow(smoothstep(0.0,1.0,fract(g)), 10.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  float rand = rnd(uv);\n\n  vec3 s = vec3(0,5,-10);\n  float t1 = time*0.2;\n  s.xz *= rot(t1);\n  vec3 t = vec3(-1,0,-0.7);\n  t.xz *= rot(-t1*10.5);\n  t += vec3(-12,0,-10);\n  vec3 cz = normalize(t-s);\n  vec3 cx = normalize(cross(cz, vec3(sin(time)*0.3,1,0)));\n  vec3 cy = normalize(cross(cz, cx));\n  float fov = 0.4;\n  vec3 r = normalize(cx*uv.x + cy*uv.y + cz*fov);\n\n  float t2=time;\n  float flick = 10.0;\n  vec3 light = normalize(vec3(-1.0 + curve(t2, flick*0.3),-1.0 + sin(time)*0.5,-1.0 + curve(t2, flick*0.5)));\n\n  float maxdist = 30.0;\n  vec3 p = s;\n  float dd=0.0;\n  float at;\n  float side = sign(map(p));\n  vec3 n=vec3(0,1,0);\n  float addcol = 0.0;\n  for(int i=0; i<MARCH_STEPS; ++i) {\n    float d = map(p)*side;\n    if(d<0.001) {\n      n = norm(p)*side;\n      if(mat<0.5) break;\n      vec3 h = normalize(light-r);\n      float f = pow(1.0-max(dot(n,-r),0.0),2.0);\n      addcol += pow(max(dot(h,n),0.0),10.0)*f;\n      side = -side;\n      d = 0.01;\n      r=refract(r,n,1.0+side*0.03);\n    }\n    if(dd>maxdist) {\n      dd=maxdist;\n      break;\n    }\n    p+=r*d;\n    dd+=d;\n    at += 0.4;\n  }\n\n  float wat = 0.0;\n  float projground = p.y/(-light.y);\n  float causground = caustic(p + vec3(light.x, 0, light.z)*projground);\n  float diff = causground*5.0+0.3;\n  if(p.y<0.01-waterlevel) {\n    wat = 1.0;\n    n = causticnorm(p);\n    vec3 ref = reflect(r,n);\n    ref.y=-ref.y;\n    diff = pow(max(0.0, dot(ref, light))*1.25,3.0);\n  }  \n\n  float deg = 1.0-clamp(dd/maxdist,0.0,1.0);\n  float fog = clamp(deg*deg*deg*deg,0.0,1.0);\n\n  vec3 col = vec3(0);\n  col += max(0.0, dot(n,light)) * fog;\n\n  int steps=VOLUMETRIC_STEPS;\n  float stepsize = maxdist/float(steps);\n  vec3 vr = r*stepsize;\n  vec3 vp = s + rand*vr;  \n  float prog = rand;\n  float sum = 0.0;\n  for(int i=0; i<steps; ++i) {\n    float proj = vp.y/(-light.y);\n    float caus = caustic(vp + vec3(light.x, 0, light.z)*proj);\n    //caus = 0.15-caus;\n    caus = clamp((caus-0.1)*100.0,0.0,1.0);\n    float fog2 =clamp(1.0-prog/maxdist,0.0,1.0); \n    float fade = min(1.0,pow((dot(normalize(vp-s),light)*0.5+0.5)*1.15,5.0));\n    sum += caus*pow(fog2,0.5)*fade;  \n    vp += vr;\n    prog += stepsize;\n    if(prog>dd) break;\n  }\n\n  col *= diff;\n\n  col += sum*1.9/float(steps)*(1.0+at*0.05);\n  col += addcol;\n\n  col *= vec3(0.3,0.4,0.7)*3.0;\n\n  fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}