{"ver":"0.1","info":{"id":"Msfyzf","date":"1537484707","viewed":467,"name":"Alien Transmission Glitch","username":"airtight","description":"Alien Transmission Glitch","likes":18,"published":1,"flags":32,"usePreview":0,"tags":["glitch","alien"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Glitch Pass\n\nfloat random1d(float n){\n\treturn fract(sin(n) * 43758.5453);\n}\n\nfloat noise1d(float p){\n\tfloat fl = floor(p);\n\tfloat fc = fract(p);\n\treturn mix(random1d(fl), random1d(fl + 1.0), fc);\n}\n\nfloat glitch (vec2 uv, float stripCount, float amount, float maxShift){\n    \n    float speed = 20.0;\n    float t = iTime * speed;\n    float stepT = floor(t); //every second\n    float seed = random1d(stepT); //rand every second\n    \n    //rand y offset\n    uv.y += seed * stripCount;\n    \n    float stripId = floor(uv.y * stripCount) / stripCount;\n    float xOffset = (random1d(stripId)* 2.0 - 1.0) * maxShift ; //-maxShift <-> maxShift\n    \n    // only apply xoffset to small chunks of x range\n    float xn = noise1d(( seed + uv.x + stripId * 20.0 )* stripCount/4. );\n    float showOffset  = step(1.0 - amount ,xn);\n    \n    return showOffset * xOffset;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uvd = uv;\n    \n    //pulsate glitch amount\n    float glitchAmount = sin(iTime* 8.0) /2.0 + 0.5;\n    \n    //spikey noise\n    glitchAmount = smoothstep(0.5,1.,noise1d(iTime*6.0)) * 2.0 + 0.1;\n    \n    //fatty chunks\n    float offset = glitch (uv, 15., 0.2 , 0.1  * glitchAmount);\n    \n    //medium chunks\n    offset += glitch (uv, 50., 0.1, 0.05 * glitchAmount);\n    uvd.x += offset;\n    \n    //small chunks\n    offset += glitch (uv, 150., 0.1, 0.05 * glitchAmount);\n    uvd.x += offset;\n   \n    vec4 col = texture(iChannel0,uvd);\n     \n    //offset entire r channel\n    float channelShiftAmount = 0.01 * glitchAmount;\n    vec2 offsetR = vec2(random1d(iTime), random1d(iTime + 38513.3493)) * channelShiftAmount - channelShiftAmount/2.;\n    vec4 offsetCol = texture(iChannel0,fract(uvd + offsetR));\n    col.r = offsetCol.r;\n    \n    fragColor = col;\n \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//letters adapted from https://github.com/keijiro/ShaderSketches/\n\n#define PI 3.14159265359\n\nfloat random1d(float n){\n\treturn fract(sin(n) * 43758.5453);\n}\n\nfloat noise1d(float p){\n\tfloat fl = floor(p);\n\tfloat fc = fract(p);\n\treturn mix(random1d(fl), random1d(fl + 1.0), fc);\n}\n\nfloat randomRange1d (in float seed, in float min, in float max) {\n\t\treturn min + random1d(seed) * (max - min);\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat letter(vec2 coord, float size)\n{\n    vec2 gp = floor(coord / size * 7.); // global\n    vec2 rp = floor(fract(coord / size) * 7.); // repeated\n\n    vec2 odd = fract(rp * 0.5) * 2.;\n    float rnd = fract(sin(dot(gp, vec2(12.9898, 78.233))) * 43758.5453);\n\n    float c = max(odd.x, odd.y) * step(0.5, rnd); // random lines\n    c += min(odd.x, odd.y); // corder and center points\n\n    c *= rp.x * (6. - rp.x); // cropping\n    c *= rp.y * (6. - rp.y);\n    \n    //hide some columns over time\n    float cuttoff = fract(iTime/6.0) * 0.75 + 0.1;\n    if (random1d(gp.x) > cuttoff) c = 0.;\n    \n    //hide some rows over time\n    cuttoff = fract(iTime) + 0.1;\n    if (random1d(gp.y) > cuttoff) c = 0.;\n\n    return clamp(c, 0., 1.);\n}\n\nvec3 bgCol(){\n    \n\tvec2 uv = gl_FragCoord.xy / iResolution.xy;\n    //spin uv space around 0.5\n    uv -= 0.5;\n    uv = rotate2d( fract(iTime/4.0)*2.0*PI ) * uv;\n    uv += 0.5;\n    //4 corner grad blue/pink\n    return vec3(uv,1.0);    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = gl_FragCoord.xy;\n    coord.x += iResolution.x * 0.04 * iTime; //drift sidewise\n    \n    //randomize zoom\n    float speed = 4.0;\n    float t = iTime * speed;\n    float stepT = floor(t); //every second\n    float size = iResolution.x / randomRange1d(stepT, 3.0, 15.0);\n    float c  = letter(coord, size);\n   \n    fragColor = vec4(bgCol() * c /2.0, 1.0);\n    \n    \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\n//Bloom H pass\n\nconst float blurSize = 1.0/300.0;\nconst float intensity = 1.2;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 sum = vec4(0);\n    vec2 texcoord = fragCoord.xy/iResolution.xy;\n    int j;\n    int i;\n\n    // blur in x\n    // take nine samples, with the distance blurSize between them\n    sum += texture(iChannel0, vec2(texcoord.x - 4.0*blurSize, texcoord.y)) * 0.05;\n    sum += texture(iChannel0, vec2(texcoord.x - 3.0*blurSize, texcoord.y)) * 0.09;\n    sum += texture(iChannel0, vec2(texcoord.x - 2.0*blurSize, texcoord.y)) * 0.12;\n    sum += texture(iChannel0, vec2(texcoord.x - blurSize, texcoord.y)) * 0.15;\n    sum += texture(iChannel0, vec2(texcoord.x, texcoord.y)) * 0.16;\n    sum += texture(iChannel0, vec2(texcoord.x + blurSize, texcoord.y)) * 0.15;\n    sum += texture(iChannel0, vec2(texcoord.x + 2.0*blurSize, texcoord.y)) * 0.12;\n    sum += texture(iChannel0, vec2(texcoord.x + 3.0*blurSize, texcoord.y)) * 0.09;\n    sum += texture(iChannel0, vec2(texcoord.x + 4.0*blurSize, texcoord.y)) * 0.05;\n    \n    vec4 orig = texture(iChannel0, texcoord);\n    fragColor = sum * intensity + orig;\n    \n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\n//Bloom V pass\n\nconst float blurSize = 1.0/300.0;\nconst float intensity = 1.2;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec4 sum = vec4(0);\n\tvec2 texcoord = fragCoord.xy/iResolution.xy;\n\tint j;\n\tint i;\n\n\t// blur in y\n    // take nine samples, with the distance blurSize between them\n    sum += texture(iChannel0, vec2(texcoord.x, texcoord.y - 4.0*blurSize)) * 0.05;\n    sum += texture(iChannel0, vec2(texcoord.x, texcoord.y - 3.0*blurSize)) * 0.09;\n    sum += texture(iChannel0, vec2(texcoord.x, texcoord.y - 2.0*blurSize)) * 0.12;\n    sum += texture(iChannel0, vec2(texcoord.x, texcoord.y - blurSize)) * 0.15;\n    sum += texture(iChannel0, vec2(texcoord.x, texcoord.y)) * 0.16;\n    sum += texture(iChannel0, vec2(texcoord.x, texcoord.y + blurSize)) * 0.15;\n    sum += texture(iChannel0, vec2(texcoord.x, texcoord.y + 2.0*blurSize)) * 0.12;\n    sum += texture(iChannel0, vec2(texcoord.x, texcoord.y + 3.0*blurSize)) * 0.09;\n    sum += texture(iChannel0, vec2(texcoord.x, texcoord.y + 4.0*blurSize)) * 0.05;\n\n    vec4 orig = texture(iChannel0, texcoord);\n    fragColor = sum * intensity + orig;\n    \n}","name":"Buffer D","description":"","type":"buffer"}]}