{"ver":"0.1","info":{"id":"cl2SRK","date":"1727818639","viewed":82,"name":"eyes x 20  [p2]","username":"valalalalala","description":"This is a bit painful to share. I was super not-happy with the proportions and the extremely wrong anatomy. The bizarre flailing and broken feet was a weak walk attempt I never got working >_<\n\nThe next iteration fixed a lot of the anatomical failings...","likes":4,"published":1,"flags":24,"usePreview":0,"tags":["eyes"],"hasliked":0,"parentid":"mlBXDw","parentname":"eyes x 20  [p1]"},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"       ///////////////////////////////////////////////////////////////////\n     //                                                               ////\n    // \"twenty eyes [p2]\"                                            // //\n   //                                                               //  //\n  // working up to the full concept a bit at a time...             //   //\n //                                                               //    //\n///////////////////////////////////////////////////////////////////     //\n//                                                               //    ///\n// Creative Commons Attribution-NonCommercial-ShareAlike         //   //\n// 3.0 Unported License                                          //  //\n//                                                               // //\n// by Val \"valalalalala\" GvM ðŸ’ƒ 2023                             ////\n//                                                               ///\n///////////////////////////////////////////////////////////////////\n\nfloat tTime, bTime, dTime, oTime; // .2, 2x and 4x clocks\nfloat hackx,hacky;\n\n/////////////////////////////////////////////////////////////////////\n\nconst int EYE = 1;\nconst int FACE = 2;\nconst int LIPS = 3;\nconst int LIDS = 4;\nconst int HAIR = 5;\nconst int BODY = 6;\n\n// 10 is fine details like hair variation, freckles, subsurface and iris details\n#define LOD 9\n//#define length langth\n\n/////////////////////////////////////////////////////////////////////\n\nfloat fLineSegment(vec3 p, vec3 a, vec3 b, vec3 r) {\n    vec3 ab = b - a;\n    float t = saturate(dot(p - a, ab) / dot(ab, ab));\n    vec3 o = (ab*t + a);\n    \n    \n    vec3 f = length( o - p ) - r;\n    return min( f.x, min( f.y, f.z ) );\n    \n    \n    vec3 l = vec3(\n        abs( o.x - p.x ) - r.x,\n        abs( o.y - p.y ) - r.y,\n        abs( o.z - p.z ) - r.z\n    );\n    \n    return min( l.x, min( l.y, l.z ) );\n    \n    //return length((ab*t + a) - p) -r;\n}\n\nfloat fLineSegment(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 ab = b - a;\n    float t = saturate(dot(p - a, ab) / dot(ab, ab));\n    return length((ab*t + a) - p) -r;\n}\n\n//based off fLineSegment + madness\nfloat linor(vec3 p, vec3 a, vec3 b, float r1, float r2, float power ) {\n    vec3 ab = b - a;\n    float t = saturate(dot(p - a, ab) / dot(ab, ab));\n    float r = mix( r1, r2,t );// pow( t, power ) );\n    return length((ab*t + a) - p) -r;\n}\nfloat linor(vec3 p, vec3 a, vec3 b, float r1, float r2 ) {\n    return linor( p, a, b, r1, r2, EINS );\n}\n\n// polynomial smooth min (k = 0.1); iq\nfloat smin( float a, float b, float k ){\nif(keyToggle(13,iChannel1)) return min(a,b);\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smin( float a, float b ) {\n    return smin( a, b, .1 );\n}\n\n\nfloat smax(float a, float b, float k){\n\treturn -smin(-a, -b, k);\n}\n\n// https://www.shadertoy.com/view/MltcDB\nfloat ellipsoid(vec3 p, vec3 r){\n    float lg = length(p /(r * r));\n\treturn (length(p / r) - 1.) * (length(p / r)) / lg;\n}\n\nfloat sphere( vec3 p, vec3 center, float radius ) {\n    return length( p - center ) - radius;\n}\n\nvec3 nextJoint( vec3 a, vec3 d, float l ) {\n    return a + l * normalize( d );\n}\n\nfloat limbo( vec3 p, vec3 a, vec3 b, float l, float r ) {\n    return linor( p, a, b, r, r );\n}\n\n/////////////////////////////////////////////////////////////////////\n\nfloat eyeDistance( vec3 p, float pad ) {\n    vec3 center = V000;\n    float ed = 3e3;\n\n    float e = .02;\n    float apart = 5.1;\n    \n    p.y += .044;\n    \n    // hacky rotation\n    p.y -= e * 14.;\n    p.z -= .310 + p.y * .2 - .24 * abs( abs( p.x ) - .07 ); \n\n    vec3 pl = p - x3( apart * e );        \n    vec3 pr = p + x3( apart * e );\n\n    // this will gives 18 of the 20 eyes\n    pl.xy = REPLIM( pl.xy, e * 2.2, vec2(1.),vec2(+1.));\n    pr.xy = REPLIM( pr.xy, e * 2.2, vec2(1.),vec2(+1.));   \n\n    ed = min( ed, sphere( pl, center, e * pad ) );\n    ed = min( ed, sphere( pr, center, e * pad ) );\n    \n    // finally we have 20 eyes to put into our head!\n    p.x = abs( abs( p.x ) - 9.2 * e );\n    p.z += .012;\n    ed = min( ed, sphere( p, center, e * pad ) );\n\n    return ed;\n}\n\nfloat eyeDistance( vec3 p ) {\n    return eyeDistance( p, 1. );\n}\n\nfloat lipDistance( vec3 p, float thickness ) {\n    p.y -= .019;\n    \n    vec3 px = p;\n    px.x = abs( px.x );\n\n    vec3 up = px;\n    up.y += up.x * .22;\n    vec3 dn = px;\n    dn.y -= dn.x * .14;\n\n    float upl = ellipsoid( up - vec3( .014, .064, .248 ), vec3( .032, .019, .04 ) * thickness ); // upper lip\n    float dnl = ellipsoid( dn - vec3( .000, .042, .246 ), vec3( .053, .021, .04 ) * thickness ); // lower lip\n    \n    return smin( upl, dnl, .0047 );\n}\n\nfloat lipDistance( vec3 p ) {\n    return lipDistance( p, 1. );\n}\n\nfloat neckDistance( vec3 p ) {\n    return linor( p, vec3( ZED, .12, -.11 ), vec3( ZED, -.16, -.18 ), .13, .16 );\n    return linor( p, vec3( ZED, .12, -.11 ), vec3( ZED, -.16, -.18 ), .14, .18 );\n}\n\n// huge depth to MltcDB\nfloat faceDistance( vec3 p ) {\n    vec3 px = p; \n    px.x = abs( px.x );\n\n    float d =    sphere( p, vec3( ZED, .34, .01 ), .31 );  // front of head  \n    d = smin( d, sphere( p, vec3( ZED, .342, -.07 ), .33 ), .02 ); // back of head\n    d = smin( d, sphere( p,  vec3( ZED,-.02, .18 ), .03 ), .31 ); // chin\n    d = smin( d, sphere( px, vec3( .155, .14, .18 ), .030 ), .20 ); // cheek\n    d = smin( d, sphere( px, vec3( .12, .1 * .507, .1 * .583 ), .007 ), .16 ); // jaw\n    \n    vec3 e = px; e.x -= .3 * e.y; e.z += .09 * e.y; // rotate a bit\n    d = smin( d, ellipsoid( e - vec3( .24, .21,-.06 ), vec3( .027, .07, .06 ) ), .013 ); // ears    \n    \n    d = smin( d, ellipsoid( p - vec3( ZED, .09, .21 ), vec3( .090, .091, .07) ), .01 ); // mouth barrel    \n    d = smin( d, lipDistance( p, .95 ), .005 ); // bring in lips\n  \n    //d = smin( d, linor( p, vec3( ZED, .41, .27 ), vec3( ZED, .15, .31 ), .021, .033 ), .042 ); // nose\n    float base   = ellipsoid( p - vec3( ZED, .14, .31 ), vec3( .03, .01, .02 ) );\n    float bridge = linor( p, vec3( ZED, .44, .27 ), vec3( ZED, .15, .31 ), .005, .013, 4. );\n    float nose = smin( base, bridge, .042 );\n    d = smin(d, nose, .03 );// nose\n    \n    d = smin( d, linor( px, vec3( .06, .40, .24 ), vec3( .1931, .41, .14 ), .015, .012 ), .1 ); // brows   \n    d = smin( d, neckDistance( p ), .08 ); // neck\n    \n    // eyesockets and blinking\n    float eye = eyeDistance( p, mix( .98, 1., .5 + bTime ) );\n    d = smin( d, eye, .013 );\n    \n    return d;\n}\n\nfloat eyebrowDistance( vec3 p ) {\n    vec3 px = p;\n    px.x = abs( px.x );\n\n    vec3 p1 = vec3( .030, .320, .318 );\n    vec3 p2 = vec3( .056, .333, .321 );\n    vec3 p3 = vec3( .095, .340, .313 );\n    vec3 p4 = vec3( .172, .328, .272 );\n\n    float d1 = linor( px, p1, p2, .008, .006, 1. );\n    float d2 = linor( px, p2, p3, .006, .005, 1. );\n    float d3 = linor( px, p3, p4, .005, .004, 1. );\n\n    return min( d1, min( d2, d3 ) );\n}\n\n// yeah... pony tail for the uber lazy\nfloat hairDistance( vec3 p ) {\n    float eb = eyebrowDistance( p );\n\n    #if LOD >= 10 \n    float t = triangle( 888. * ( p.x + p.y * .3 - abs(p.z) * .2 ) ) ; \n    \n    float h = 1. + t * .001;\n    #else\n        float h = 1.;\n    #endif\n    \n    float h1 = sphere( p, vec3( ZED, .37, -.09 ), .337 * h );\n    float h2 = sphere( p, vec3( ZED, .37, -.02 ), .331 * h );\n    float hr = smin( h1, h2, .02 );\n    \n    float dt = oTime ;//sign( dTime ) * pow( dTime, 2. ) -.;\n    \n    float y = p.y - .55;\n    y = y * y * (3.0 - 2.0 * y) * .3;\n    \n    vec3 bop = vec3( y * dt * .5, p.x * dt * .2, y * dt * .1 );\n    \n    #if LOD >= 10 \n    h = .98 + .02 * abs( triangle( 444. * ( p.x - bop.x ) ) ); \n    #endif\n    \n    float p1 = sphere( p, vec3( ZED, .48, -.48 ) + bop, .12 * h );\n    float p2 = sphere( p, vec3( ZED, .32, -.54 ) + bop, .08 * h );\n    float p3 = sphere( p, vec3( ZED, .18, -.56 ) + bop, .08 * h );\n    float p4 = sphere( p, vec3( ZED, .04, -.54 ) + bop, .07 * h );\n    float p5 = sphere( p, vec3( ZED,-.08, -.52 ) + bop, .06 * h );\n\n    float pn = min( p1, min( p2, min( p3, min( p4, p5 ) ) ) );\n    \n    float pm = .02;\n    pn = smin( p1, smin( p2, smin( p3, smin( p4, p5, pm ), pm ), pm ), pm );\n    \n    hr = min( pn, hr );\n    \n    return min( hr, eb );\n}\n\n// nightmare...\nfloat armDistance( vec3 p, float t, float o ) {\n    float svalue = .02;\n    \n    const float len1 = .9, len2 = .7, len3 = .3;\n    const float r1 = .13, r2 = .09, r3 = .06, r4 = .028;\n\n    float v = abs( t );/// + .01; // ZED weirdness \n    ///t = sign( t ) * v;\n\n#if 1\n    vec3 d1 = norm( .26, -.6          , 1.10 * t + .00 );   \n    vec3 d2 = norm( ZED, .30 * t - .05, 0.10 * v + .05 );\n    vec3 d3 = norm( ZED, .25 * t - .00,  .2 * v );\n#else    \n    // even worse...\n    vec3 d1 = norm( .26, -.9          , .20 * t + .00 );   \n    vec3 d2 = norm( ZED, .4 * t - .2 * v, .4 * v - .2 * t );\n    vec3 d3 = norm( ZED, .25 * t,  .2 * v );\n    mat2 rmat = rotate2dmat( t,  ( .5 * o + .5 ) * .2  );\n    d2 = normalize( vec3( -.05, V101.zy * rmat ) );\n#endif\n    \n    const vec3 a = vec3( .51, .90, -.16 ); \n    vec3 b = a + len1 * d1;\n    vec3 c = b + len2 * d2;\n    vec3 d = c + len3 * d3;\n    \n    float a1 = linor( p, a, b, r1, r2 );\n    float a2 = linor( p, b, c, r2, r3 );\n      \n    // hands are a pita...\n\n    vec3 fn = norm( .1, -d3.z, d3.y );\n    vec3 middle_finger = c + .35 * d3; \n    vec3 mf2 = c + .25 * d3; \n    vec3 thumb = mf2 - fn * .16 *  .2; \n    vec3 pinki = middle_finger + fn * .25 * 1.5;\n\n    float fr = r4 * 1.4;\n    float f1 = fLineSegment( p, c,  mix( thumb, pinki, .0 ), fr * 1.1 );\n    float f2 = fLineSegment( p, c,  mix( thumb, pinki, .3 ), fr );\n    float f3 = fLineSegment( p, c,  mix( thumb, pinki, .4 ), fr );\n    float f4 = fLineSegment( p, c,  mix( thumb, pinki, .5 ), fr );\n    float f5 = fLineSegment( p, c,  mix( thumb, pinki, .6 ), fr );\n    float fm = .01;\n    float fingers = smin( f1, smin( f2, smin( f3, smin( f4, f5, fm ), fm ), fm ), .02 );\n    \n    float a3 = fingers;\n\n    return smin( a1, smin( a2, a3, .01 ), .003 );\n}\n\nfloat legDistance( vec3 p, float t, float o ) {\n    float svalue = .0002;\n    \n    const float len1 = 1.3, len2 = 1.3, len3 = .5;\n    const float r1 = .24, r2 = r1 * .77, r3 = .1, r4 = .05;\n\n    float v = abs( t );/// + .01; // ZED weirdness \n    ///t = sign( t ) * v;\n\n    vec3 d1 = norm( -.05, -1.0, +0.1 );\n    vec3 d2 = norm( -.02, -1.0, -0.1 );\n    vec3 d3 = norm( -.05, -0.1, +1.0 );\n    \n#if 1\n    // this is so bad\n    d1 = normalize(d1 + vec3(.0,   t, -t) * .88);\n    d2 = normalize(d2 + vec3(.0,   t, -t) * 3.3);\n    d3 = normalize(d3 + vec3(.0,   o, -t) );\n#endif\n\n    const vec3 a = vec3( .3, -.80, -.18 ); \n    vec3 b = a + len1 * d1;\n    vec3 c = b + len2 * d2;\n    vec3 d = c + len3 * d3;\n    \n    //const vec3 b = vec3( .30, -.80, -.30 ); \n   // return sphere( p,a, .4);\n   // return sphere( p, c, .1 );\n    \n    float v1 = linor( p, a, b, r1, r2 );\n    float v2 = linor( p, b, c, r2, r3 );\n    float v3 = linor( p, c, d, r3, r4 );\n    \n    return smin( v3, smin( v2, v1, svalue ), svalue );\n\n\n    return 3e3;\n}\n\nfloat bodyDistance( vec3 p ) {    \n    vec3 og = p;\n   \n    float t = sign( oTime ) * ( abs( oTime ) + .01 );\n    float o = sign( dTime ) * ( abs( dTime ) + .01 );\n    float m = mix( o, t, .5 );\n\n    \n    // shoulder wiggle\n    float shoulder_wiggle = .4;\n    p.x -= shoulder_wiggle * og.z * t;\n    p.z += shoulder_wiggle * og.x * t;\n    \n    // bit out of phase\n    vec3 pb = og;\n    pb.x -= shoulder_wiggle * .05 * og.z * m;\n    pb.z += shoulder_wiggle * .05 * og.x * m;\n    pb.x = abs( pb.x );\n\n\n    // hip wiggle \n    float hip_wiggle = .4;\n    vec3 ph = og;\n    ph.x -= hip_wiggle * og.z * o;\n    ph.z += hip_wiggle * og.x * o;\n    \n    vec3 pm = mix( ph, p, .5 );\n    \n    vec3 px = p;\n    px.x = abs( px.x );\n\n    //////////////////////////////////\n\n    // upper torso\n    \n    vec3 q = p; q.z += .10 * ( q.y - .8 ); // tilt forward some\n    float d = ellipsoid( q - vec3( ZED, .78, -.09 ), vec3( .51, .40, .26 ) ); // upper \n    \n    q = p; q.z += .08 * ( q.y - .6 ); // tilt a little less...\n    d = smin( d, ellipsoid( q - vec3( ZED, .40, -.09 ), vec3( .42, .40, .26 ) ), .21 ); // ribcage\n    \n    d = smin( d, neckDistance( og - vec3( ZED, 1.3, .05 ) ), .08 ); // neck\n    d = smin( d, sphere( px, vec3( .41, .94, -.13 ), .15 ), .11 ); // shoulders\n  \n    // arms\n#if 1\n    float am = .04;\n    d = smin( d, armDistance( p, dTime, oTime ), am );\n    d = smin( d, armDistance( p * V101.xzz, oTime, dTime ), am );\n#endif\n\n    float b1 = sphere( px, vec3( .16, .70, .04 ), .10 );\n    float b2 = sphere( px, vec3( .22, .49, .17 ), .20 );\n    d = smin( d, b1, .22 );\n    d = smin( d, b2, .09 );\n\n    d = smin( d, ellipsoid( pm - vec3( ZED, .02, -.04 ), vec3( .33, .24, .19 ) ), .2 ); // mid\n    \n    //float bb = sphere( q, vec3( ZED, -.19, .08 ), .02 * 2. );\n    //d = smin( d , bb, .2 ); // belly button ... not likke this...\n      \n    // lower torso and hips \n    \n    q = ph; q.z -= .02 * ( q.y - .6 ); // tilt back a bit\n    \n    float stomach = ellipsoid( q - vec3( ZED, -.42, -.11 ), vec3( .41, .34, .28 ) );\n    float bb = sphere( q, vec3( ZED, -.19, .10 ), .04 );\n    //stomach = min( stomach, bb );//, .001);\n    d = smin( d, stomach, .17 ); \n    \n    float hips = ellipsoid( q - vec3( ZED, -.72, -.14 ), vec3( .48, .34, .30 ) );\n    d = smin( d, hips, .17 ); \n    \n    // legs\n    \n    q = ph; q.x = abs( q.x );\n    float bt = sphere( q, vec3( .22, -.77, -.33 ), .21 ); // TODO: should be angled ellipsoid..\n    d = smin( d, bt, .2 );\n\n#if 1\n    float lm = .08;\n    d = smin( d, legDistance( ph, dTime, oTime ), lm );\n    d = smin( d, legDistance( ph * V101.xzz, oTime, dTime ), lm );\n#endif\n\n\n    return d;\n}\n\n/////////////////////////////////////////////////////////////////////\n\nMapped mapEyes( vec3 p ) {\n    vec3 center = .0*vec3( tTime, V000.yz );\n    float ed = eyeDistance( p );\n    return Mapped( ed, EYE, center );\n}\n\nMapped mapFace( vec3 p ) {\n    return Mapped( faceDistance( p ), FACE, V000 );\n}\n\nMapped mapLips( vec3 p ) {\n    return Mapped( lipDistance( p ), LIPS, V000 );\n}\n\nMapped mapLids( vec3 p ) {\n    return Mapped( eyeDistance( p, 1.01 * mix( .98, 1., .5 + bTime ) ), LIDS, V000 );\n}\n\nMapped mapHair( vec3 p ) {\n    return Mapped( hairDistance( p ), HAIR, V000 );\n}\n\nMapped mapBody( vec3 p ) {\n    return Mapped( bodyDistance( p ), BODY, V000 );\n}\n\n/////////////////////////////////////////////////////////////////////\n\nMapped map( vec3 p ) {\n    p.y -= .5;\n    vec3 og = p;\n    //return mapBody( og );\n    \n    vec3 nj = p;\n    nj.y -= 1.5;\n\n    // head is up a bit from the neck\n    p = nj;\n\n    p.y += .2;\n    //head sway in time \n    float dt = sign( dTime ) * pow( dTime, 2. );\n    vec3 bop = vec3( .2 * p.y* dt, -.2 * nj.x * dt, dt );\n    p.xy += bop.xy;\n\n    Mapped m = mapEyes( p );\n    Mapped f = mapFace( p );\n    mino( m, f );\n    mino( m, mapLips( p ) );\n    mino( m, mapLids( p ) );\n    mino( m, mapHair( p ) );\n    mino( m, mapBody( og + z3( .05 )) );\n    \n    m.center = bop;\n    return m;\n}\n\nMAP_TIME\n\nvec3 subo( vec3 p ) {\n    // https://www.shadertoy.com/view/MdXSzX\n    #define TRANSMISSION_RANGE_ .15\n    #define TRANSMISSION_RANGE .88\n    vec3 lightDir1 = normalize(vec3(3,1,-2));//normalize( V101.xzx );\n    vec3 lightDir2 = normalize(vec3(-3,1,-2));//normalize( V101.zzx );\n    vec3 lightCol1 = vec3(1.1,1,.9)*1.4;\n    vec3 lightCol2 = vec3(.8,.4,.2)*2.0;\n\n    // And sub surface scattering too! Because, why not?\n    float transmissionRange = TRANSMISSION_RANGE;//iMouse.x/iResolution.x;//distance/10.0; // this really should be constant... right?\n    float transmission1 = map( p + lightDir1*transmissionRange ).depth/transmissionRange;\n    float transmission2 = map( p + lightDir2*transmissionRange ).depth/transmissionRange;\n    vec3 sslight = lightCol1 * smoothstep(0.0,1.0,transmission1) + lightCol2 * smoothstep(0.0,1.0,transmission2);\n    vec3 subsurface = vec3(1,.8,.5) * sslight;\n    return subsurface;\n}\n\nvec3 eyeColor( float radius, float angle, float force ) {    \n    const vec3 iris_middle = vec3( .33, .33, .66 );\n    const vec3 iris_inner = vec3( .66, .33, .88 );\n    const vec3 iris_outer = vec3( .11, ZED, .11 );\n    \n    vec3 color = iris_middle;\n    if ( float( LOD ) + force < 10. ) return color;\n\n    float iR = radius;\n    float iA = angle;\n    \n    float nz = noise(  7.7 * vec2( iR, iA ) );\n    float iT = triangle( 8.8 * ( iA + nz + tTime ) );\n    \n    float iB = mix( pow( 4. * nz , 2. ), iT, iT + nz ); // ridges    \n    \n    float inner = smoothstep(0.1, 0.7, iR);\n    float outer = smoothstep(0.72, 1.05, iR);\n    \n    color = mix( color, iris_outer, outer );\n    color = mix( iris_inner, color, inner );\n    color *= 2.* mix( .33, 1., iB );\n    return color;\n}\n\n// help from https://www.shadertoy.com/view/3t2Szh\nvec3 eyeColor( in Ray ray, in Marched marched, in vec3 n, in vec3 look ) {\n    vec3 p = marched.p;\n    vec3 center = marched.mapped.center;\n\n    // these 3 magic numbers are strongly tied :-/\n    float iris = .95;\n    float pupil = iris * mix( 1.05, 1.04, clamp( tTime, ZED, EINS ) );   \n    \n    vec3 on = normalize( look - center );\n    float angle = dot( n, on );\n    \n    if ( angle < ZED || angle < iris ) return vec3( 2.2 * dot( n, -ray.dir ) );\n    if ( angle > pupil ) return V000;\n    \n    float iR = ( pupil - angle ) / ( pupil - iris );\n    float iA = atan( n.x - on.x, n.y - on.y );\n      \n    return eyeColor( iR, iA, ZED );\n}\n\nvec3 eyes20( in vec2 st ) {\n    INIT_SHADER_ENVIRONMENT(st)\n    \n    tTime = triangle( iTime * .2 );\n    bTime = triangle( iTime * 2. );\n    dTime = triangle( iTime * 4. );\n    oTime = triangle( iTime * 4. + .25 * TAU );\n    \n    dTime = sign( dTime ) * ( .01 + abs( dTime ) );\n    oTime = sign( oTime ) * ( .01 + abs( oTime ) );\n    \n    \nif(keyToggle(32,iChannel1)) oTime = dTime = .01;\n    \n    \n    //dTime = cos( iTime * 4. ), oTime = sin( iTime * 4. );\n    \n    //dTime = .0 * oTime;/// be still\n    \n    hackx = iMouse.x / iResolution.x;\n    hacky = iMouse.y / iResolution.y;\n\n  \n    vec3 color;\n    Ray ray = rayToggle( env, makeRay( env ), iChannel1 );\n    Marched marched = march( ray );\n\n    if ( marched.hit ) {\n        vec3 p = marched.p;\n        vec3 q = p + vec3( marched.mapped.center.xy, ZED );\n        \n        vec3 n = mapNormal( p, marched.depth );\n        float l = dot( n, -ray.dir );\n        \n        switch ( int( marched.mapped.type ) ) {\n            case EYE:\n                color = eyeColor( ray, marched, n, vec3( env.ms, 1. ) );\n                #if LOD >= 11\n                    //n += 3.3 * noise_iq( 3.3 * order( abs( p + tTime ) ).xy );\n\n                    vec3 rDir = reflect( ray.dir, n );\n                    float fresnel = saturate( pow( EINS + l, 5. ) );\n\n                    float subsurface = .11;\n                    float reflection = .33;\n\n                    color = mix( color, subo( p ), subsurface );\n                    color = mix( color, texture( iChannel0, rDir ).rgb, reflection * fresnel );\n                #endif\n                break;\n            case FACE:\n\n                color = vec3( .9, .8, .6 );\n                #if LOD >= 10 \n                    float spk = noise( 88.*( q.xy + q.z * .5 ) );\n                    spk = spk*spk*(3.-2.*spk);\n                    color = mix( color, .77 * color, spk );\n                    color *= l * l;\n                    color = mix( color, subo( p ), .11 );\n                #else\n                    color *= l * l;\n                #endif\n                \n                break;\n            case BODY:\n                color = mix(abs(n) * .66 + .11, vec3(.33), dot(n,vec3(-1.))) * l * l;\n                break;\n            case LIPS:                \n                color = l * l * vec3( .5, .04, .05 );\n                break;\n            case LIDS:\n                color = l * l * l * vec3( .7, .6, .8 );\n                break;\n            case HAIR:\n                color =  l * l * .33 * vec3( .7, .6, .8 );\n                break;\n        }\n   \n        \n    } else {\n        //return vec3( mod( env.uv.y +.8 *.0, .33 ) );\n     \n        float r = length( env.uv );\n        float i = ( r - .22 ) / .77;\n        \n        color = mix( V000, \n            mix( \n                eyeColor( i, atan( env.uv.y, env.uv.x ), 100. ), \n                V101.zzz * 3.3 * invert( r - .44 ),\n                step( .8, r )\n            ),\n            step( .22, r ) \n        ) * .33;\n    }\n    \n    return color;\n}\n\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 result, in vec2 st ){ \n    hackx = iMouse.x / iResolution.x;\n    hacky = iMouse.y / iResolution.y;\n    \n    result = vec4( eyes20( st ), 1. );    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"////////////////////////////////////////////////////////////////////////////////////\n\nconst float TAU = 99733. / 15873., ZED = .0, HALB = .5, EINS = 1., PI  = HALB * TAU;\n\nconst vec3 V101 = vec3( -EINS, ZED, +EINS ), V000 = vec3( ZED );\n\nconst float EPSILON = .001, ZFAR = 199., VIEW_DISTANCE = 8.;//.7;//5.\nconst vec3 MAGIC = vec3( TAU * 3.3, 99.733, 15873. );\n\n////////////////////////////////////////////////////////////////////////////////////\n\nvec2 pixelToUv( vec2 st, vec2 resolution ) {\n    return ( st * 2. - resolution.xy ) / min( resolution.x, resolution.y );\n}\n\nfloat absMod( float f, float m ) {\n    return abs( mod( f, m ) - m *.5 );\n}\n\nfloat scalo( float f, float s ) {\n    return f * s - .5 * s;\n}\n\nfloat invert( float f ) {\n    return 1. - f;\n}\n\nfloat modScale( float f, float s ) {\n    return mod( f, s ) / s;\n}\n\nfloat triangle( float x ) {\n    return 4. * abs( modScale( x, TAU ) - .5 ) -1.;\n}\n\nvec3 x3( float x ) { return vec3( x, V000.yz ); }\nvec3 y3( float y ) { return vec3( ZED, y, ZED ); }\nvec3 z3( float z ) { return vec3( V000.xy, z ); }\n\nvec3 norm( float x, float y, float z ) {\n    return normalize( vec3( x, y, z ) );\n}    \n\n/////////////////////////////////////////////////////////////////////\n\n#define saturate(x) clamp(x, ZED, EINS)\n#define MODO(v,f) ( mod( v + .5 * f, f ) - .5 * f )\n\n// more iq magic...\n#define REPLIM(p,s,limmin,limmax) ((p)- (s)*clamp(round((p)/(s)),-limmin,limmax))\n\n/////////////////////////////////////////////////////////////////////\n\nfloat magicFloat( vec2 uv ) {\n    return dot( uv, MAGIC.xy );\n}\n\n// really a lot like just regular fract based hash :-P\nfloat triangleHash( float f ) {\n    return fract( triangle( f * MAGIC.x ) * f * MAGIC.z * .133 );\n}\n\nfloat triangleHash( vec2 uv ) { \n    return triangleHash( magicFloat( uv ) );\n}\n\n////////////////////////////////////////////////////////////////\n// IQ's https://www.shadertoy.com/view/XdXGW8, gradient - 2D \n\nvec2 hash( in vec2 p ) {\n    return vec2( triangleHash( p.xy ), triangleHash( p.yx ) );\n}\n\nfloat noise_iq( in vec2 p ){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat noise( in vec2 p ) {\n    return noise_iq( p );\n}\n\nvec4 fbm( vec2 uv ) {\n    vec4 f = vec4( noise( uv * 1. ), noise( uv * 2. ), noise( uv * 4. ), .0 );\n    f.w = dot( f.xyz, vec3( 1., .5, .25 ) );\n    return f;\n}\n\n/////////////////////////////////////////////////////////////////////\n\n#define qcos( x ) triangle( x )\n#define qsin( x ) triangle( x + TAU * .25 )\n\nvec2 trig( float angle ) {\n    return vec2( cos( angle ), sin( angle ) );\n}\n\nmat2 rotate2dmat( float c, float s ) {\n    return mat2( c, -s, s, c );\n}\n\nmat2 rotate2d( in float angle ) {\n    vec2 t = trig( angle );\n    return rotate2dmat( t.x, t.y );\n}\n\n// https://suricrasia.online/demoscene/functions/\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\n/////////////////////////////////////////////////////////////////////\n\nvec3 order( vec3 p )  {\n    vec3 q = vec3( min( p.x, min( p.y, p.z ) ), .0, max( p.x, max( p.y, p.z ) ) );\n    q.y = ( p.x + p.y + p.z ) - ( q.x + q.z );\n    return q;  \n}\n\nvec2 order( vec2 p ) {\n    return vec2( min( p.x, p.y ), max( p.x, p.y ) );\n}\n\nfloat langth( vec3 p ) {\n    return dot( order( abs( p ) ), vec3( 0.25, 0.51, 0.79 ) ) * 1.06 + -0.0011;\n    //return dot( order( abs( p ) ), vec3( 0.25, 0.49, 0.74 ) ) * 1.11 + -0.0020;\n    //return dot( order( abs( p ) ), vec3( .2, .4, .9 ) );\n}\n\nfloat langth( vec2 p ) {\n    return dot( order( abs( p ) ), vec2( 0.41, 0.88 ) ) * 1.06 + -0.0004;\n    //return langth( vec3( ZED, p ) );\n}\n\n/////////////////////////////////////////////////////////////////////\n\nbool keyToggle( int key, sampler2D keyboardChannel ) {\n    return .0 < texelFetch( keyboardChannel, ivec2(key,2), 0 ).x;\n}\n\n/////////////////////////////////////////////////////////////////////\n\nconst int MOUSE_UP = -1, MOUSE_DOWN = 1, MOUSE_CLICKED = 2;\n\nstruct ShadEnv {\n    vec3      iResolution;           // viewport resolution (in pixels) \n    float     iTime;                 // shader playback time (in seconds)\n    float     iTimeDelta;            // render time (in seconds)\n    float     iFrameRate;            // shader frame rate\n    int       iFrame;                // shader playback frame\n    float     iChannelTime[4];       // channel playback time (in seconds)\n    vec3      iChannelResolution[4]; // channel resolution (in pixels) \n    vec4      iMouse;                // mouse pixel coords. xy: current (if MLB down), zw: click\n    vec4      iDate;                 // (year, month, day, time in seconds)\n    float     iSampleRate;           // sound sample rate (i.e., 44100)\n    vec2      st;                    // aka fragCoord\n    vec2      uv;\n    vec2      ms;\n    vec2      trigTime;\n    int       mouseStatus;\n    float     pixel1;\n};\n\n#define INIT_SHADER_ENVIRONMENT(st) ShadEnv env = ShadEnv( iResolution, iTime, iTimeDelta, iFrameRate, iFrame, iChannelTime, iChannelResolution, iMouse, iDate, iSampleRate, st, V101.xy, V101.xy, V101.xy, MOUSE_UP, EINS );     init( env ); \n\nvoid init( inout ShadEnv env ) {\n    env.uv = pixelToUv( env.st, env.iResolution.xy );\n    env.trigTime = trig( env.iTime );\n \n    env.mouseStatus = MOUSE_UP + int( 2. * step( 3e-3, env.iMouse.z ) + step( 3e-3, env.iMouse.w ) );\n    env.ms = step( 3e-3, env.iMouse.z + env.iMouse.w ) * (\n        2.*( env.iMouse.xy / env.iResolution.xy - .5 )\n    );\n    \n    env.pixel1 = max( EINS / env.iResolution.x, EINS / env.iResolution.y ); \n}\n\n/////////////////////////////////////////////////////////////////////\n\nstruct Ray { \n    vec3 eye; \n    vec3 dir; \n};\n\nmat3 makeCamera( vec3 a, vec3 b, float roll ) {\n    vec3 up = vec3( trig( roll ).yx, ZED );\n\tvec3 z = normalize( b - a );\n\tvec3 x = normalize( cross( z, up ) );\n\tvec3 y = normalize( cross( x, z ) );\n\treturn mat3( x, y, z );\n}\n\nRay makeRay( in ShadEnv env, float depth ) {\n    vec2 t = trig( env.ms.x * PI );\n    \n    //t=t*.0+1.;\n    vec3 eye = depth * vec3( t.y, sin( env.ms.y * 2.88 ), t.x );\n    const float zoom = .125;//.25;\n    \n    \n    vec3 idk = vec3( env.uv, EINS );\n    vec3 dir = normalize( makeCamera( eye, V000, ZED ) * idk - eye * zoom );;\n\n    return Ray( eye, dir );\n}\n\nRay makeRay( inout ShadEnv env ) {\n    return makeRay( env, VIEW_DISTANCE );\n}\n\n// 1 is front, 2 is left, 3 is top\nRay rayToggle( in ShadEnv env, in Ray ray, in sampler2D keyboardChannel ) {\n    float v = VIEW_DISTANCE;\n    if ( keyToggle( 49, keyboardChannel ) ) {\n        // 1: front\n        env.ms *= .0;\n        ray = makeRay( env, v );\n    } else \n    if ( keyToggle( 50, keyboardChannel ) ) {\n        // 2: left side\n        env.ms = vec2( -.5, .0 );\n        ray = makeRay( env, v );\n    } else \n    if ( keyToggle( 51, keyboardChannel ) ) {\n        // 3: top\n        ray.eye = v * V101.yzy;\n        ray.dir = normalize( vec3( env.uv.x, EINS, -env.uv.y ) - ray.eye );\n    } else\n    if ( keyToggle( 52, keyboardChannel ) ) {\n        // 4: 3 quarter\n        env.ms = vec2( -.25, .12 );\n        ray = makeRay( env, v );\n    } else\n    if ( keyToggle( 53, keyboardChannel ) ) {\n        // 5: back\n        env.ms = vec2( 1., .0 );\n        ray = makeRay( env, v );\n    } else\n    if ( keyToggle( 54, keyboardChannel ) ) {\n        // 6: back 3/4\n        env.ms = vec2( -.75, .1 );\n        ray = makeRay( env, v );\n    } else\n    if ( keyToggle( 55, keyboardChannel ) ) {\n        // 7: right side\n        env.ms = vec2( .5, .0 );\n        ray = makeRay( env, v );\n    }\n    \n    return ray;\n}\n\n/////////////////////////////////////////////////////////////////////\n\nstruct Mapped {\n    float depth;\n    int type;\n    vec3 center; // for eyes\n};\n\nstruct Marched {\n    vec3 p;\n    float depth;\n    bool hit;\n    Mapped mapped;\n};\n\nconst int MARCH_CONTINUE = 0, MARCH_SUCCESS = 1, MARCH_FAILED = 2;\n\n///////////////////////////////////////\n\nMapped newMapped( float depth ) { return Mapped( depth, -1, V000); }\nMapped newMapped() { return newMapped( 3e11 ); }\n\nMarched newMarch( Ray ray ) {\n    return Marched( ray.eye, ZED, false, newMapped( ZED ) );\n}\n\n///////////////////////////////////////\n\nvoid mino( inout Mapped m, in Mapped q ) {\n    if ( q.depth < m.depth ) {\n        m = q;\n    }\n}\n\n///////////////////////////////////////\n\nint _marchStep( in Ray ray, in float side, inout Marched marched, Mapped mapped ) {\n    marched.mapped = mapped;\n    marched.mapped.depth *= side;\n    marched.depth += marched.mapped.depth;\n        \n    if ( abs( marched.mapped.depth ) < EPSILON ) {\n        marched.hit = true;\n        return MARCH_SUCCESS;\n    }\n        \n    if ( marched.depth > ZFAR ) return MARCH_FAILED;\n    \n    marched.p = ray.eye + marched.depth * ray.dir;\n    return MARCH_CONTINUE;\n}\n\nMarched _marchMissed( in Marched marched ) {\n    marched.depth = -abs( marched.depth );\n    return marched;\n}\n\n///////////////////////////////////////\n\nMapped map( vec3 p ); // implement this, then use this macro: MAP_TIME\n\n#define MAP_TIME \\\nfloat mapDepth( vec3 p ) { return map( p ).depth; } \\\nvec3 mapNormal(vec3 p,float d) {\\\n    mat3 k = mat3(p,p,p) - mat3( d * EPSILON ); \\\n    return normalize( mapDepth(p) - vec3( mapDepth(k[0]), mapDepth(k[1]), mapDepth(k[2])) ); \\\n} \\\nvec3 mapNormal(vec3 p) { return mapNormal(p,EPSILON); }\\\nMarched march( in Ray ray, in float side ) { \\\n    Marched marched = newMarch( ray ); \\\n    for( int i = 0 ; i < int( ZFAR ) ; i++ ) { \\\n        switch( _marchStep( ray, side, marched, map( marched.p ) ) ) { \\\n            case MARCH_SUCCESS: return marched; \\\n            case MARCH_FAILED: i = int(ZFAR); \\\n        } \\\n    } \\\n    return _marchMissed( marched ); \\\n} \\\nMarched march( Ray ray ) { return march( ray, EINS ); }\n\n/////////////////////////////////////////////////////////////////////","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[],"code":"vec2 triangle_tone(float frequency, float time) {\n    time = fract(time);\n    float f = TAU * frequency * time;\n    float decay = exp(-6.6*time);\n    float t = mix(triangle(f), triangle(f+.22), fract(f));\n    return vec2(t) * decay;\n}\n\nvec2 mainSound( int samp, float time ) {\n    return .11 * max(vec2(-1.),min(vec2(1.), .0\n        + triangle_tone(222., time * 1.11 - .111)\n        + triangle_tone(333., time * .555 + .010)  \n        + triangle_tone(444., time * .222 + .111)\n        + triangle_tone(666., time * .121 + .222)\n        + triangle_tone(999., time * .060 + .333)\n    ));\n}","name":"Sound","description":"","type":"sound"}]}