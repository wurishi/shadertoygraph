{"ver":"0.1","info":{"id":"st2GzK","date":"1624301303","viewed":80,"name":"Ray Marching / flexible sphere","username":"bugaga777","description":"my first ray marching test","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415\n\nconst float MIN_DIST = 0.;\nconst float MAX_DIST = 100.;\nconst int MAX_MARCHING_STEPS = 250;\nconst float EPSILON = 0.001;\nconst vec3 LIGHT = vec3(5., 10., 20.);\n\nfloat sphereSDF(vec3 point) {\n   vec3 dir = normalize(point);\n   float r = 1.0;\n   r += sin(dir.z * PI * 2. + iTime) / 50.;\n   r += cos(dir.x * PI * 2. - iTime * 2.) / 50.;\n   r += sin(dir.y * PI * 2. + iTime) / 50.;\n   return length(point) - r;\n}\n\nfloat sceneSDF(vec3 point) {\n    return sphereSDF(point);\n}\n\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec3 rayDirection(float fov, vec2 fragCoord, vec2 iResolution) {\n    vec3 ray = vec3(fragCoord - iResolution / 2., .0);\n    ray.z = iResolution.y / tan(fov / 2.);\n    return normalize(vec3(ray.xy, -ray.z));\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec3 eye = vec3(0., 0., 10.);\n  mat4 view_mat = viewMatrix(eye, vec3(.0, .0, .0), vec3(.0, 1., .0));\n  vec3 ray = rayDirection(PI / 4., fragCoord, iResolution.xy);\n  ray = (view_mat * vec4(ray, 1.)).xyz;\n  float dist = shortestDistanceToSurface(eye, ray, MIN_DIST, MAX_DIST);\n  \n  if(dist >= MAX_DIST){\n      fragColor = vec4(.0, .0, .0, 1.);\n      return;\n  }\n  \n  vec3 p = eye + ray * dist;\n  vec3 n = estimateNormal(p);\n  vec3 light_reflect = reflect(-normalize(LIGHT - p), n);\n  vec3 eye_dir = normalize(eye - p);\n  \n  vec3 color = vec3(.5, length(p), .0);\n  color *= max(dot(normalize(LIGHT - p), n),.0); // lambert\n  color += vec3(.8, .8, .8) *  pow(max(dot(light_reflect, eye_dir),.0), 25.); // phong\n  \n  fragColor = vec4(color, 1.); \n}","name":"Image","description":"","type":"image"}]}