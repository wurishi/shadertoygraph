{"ver":"0.1","info":{"id":"mtByWK","date":"1692285810","viewed":28,"name":"Cubic solver (Vieta 2)","username":"Envy24","description":"Cubic solver from this paper:\nhttps://quarticequations.com/Tutorial.pdf\nTest-drive here: https://www.shadertoy.com/view/sd3fzn\nMore solvers: https://www.shadertoy.com/playlist/sfjBz1","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["approximation","solver","cubic","newton","raphson","halley","numeric","secant","regulafalsi"],"hasliked":0,"parentid":"ssKBRD","parentname":"Cubic Solvers"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SCENE_SCALE               ( 2. )\n#define UNIT                      ( (3.0*SCENE_SCALE) / iResolution.y  )\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale + origin;\n}\n\nfloat cubicSDF(vec2 NDC, float a, float b, float c, float d)\n{\n    float df   = NDC.y - (((a * NDC.x  + b) * NDC.x + c) * NDC.x + d),\n          dfdx = (3.0 * a * NDC.x + 2.0 * b) * NDC.x + c;\n    return abs(df) / sqrt(1.0 + dfdx * dfdx);\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, vec2(0), true);\n\n    //float a = 0.8, b = 1.4, c = 0.8, d = 0.1;\n    float Time = iTime;\n    /* Cubic */\n    float a = sinOSC(-1.25, 1.25, Time * 0.15), b = sinOSC( -2.0,  2.0, Time * 0.6), \n          c = sinOSC( -1.0,  1.0, Time * 0.45), d = sinOSC( -1.0,  1.0, Time * 0.25);\n    /* Quadratic *\n    float a =                               0.0, b = sinOSC( -2.0,  2.0, iTime * 0.6), \n          c = sinOSC( -1.0,  1.0, iTime * 0.45), d = sinOSC( -1.0,  1.0, iTime * 0.25);\n    /* Linear *\n    float a =                               0.0, b =                               0.0,\n          c = sinOSC( -1.0,  1.0, iTime * 0.45), d = sinOSC( -1.0,  1.0, iTime * 0.25);\n    /* Identity 0 == 0 *\n    float a =                               0.0, b =                              0.0,\n          c =                               0.0, d =                              0.0;\n    /**/\n\n    // Cauchy's roots bounds.\n    float upper_bound = max(0.0, 1.0 + max(-a/a, max(-b/a, max(-c/a, -d/a))));\n    float lower_bound = max(0.0, 1.0 + max( a/a, max( b/a, max( c/a,  d/a))));\n\n    vec3 color = (NDC.x <= upper_bound && NDC.x >= -lower_bound) ? vec3(.9,.9,.9) : vec3(1.);\n         color = mix( color, vec3(0.8), SMAA(cellsSDF(NDC)) );\n         color = mix( color, vec3(0), SMAA(x_axisSDF(NDC)) );\n         color = mix( color, vec3(0), SMAA(y_axisSDF(NDC)) );\n         color -= SMAA(cubicSDF(NDC, a, b, c, d));\n\n    vec2 roots[3];\n      \n    // Non-numeric solvers.\n    int num = solve_cubic(roots, a, b, c, d);\n    \n    for (int r=0; r < num; ++r) \n    {\n        float x = roots[r].x;\n        color = mix(color, vec3(1, 0, 0), SMAA(diskSDF(NDC, vec2(x, 0.0), 0.03)));\n    }\n\n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float diskSDF(vec2 NDC, vec2 C, float R) { return length(C - NDC)-R; }\nfloat y_axisSDF(vec2 NDC) { return abs(NDC.x); }\nfloat x_axisSDF(vec2 NDC) { return abs(NDC.y); }\nfloat vertical_lineSDF(vec2 NDC, float x0) { return abs(NDC.x-x0); }\nfloat horizontal_lineSDF(vec2 NDC, float y0) { return abs(NDC.y-y0); }\nfloat cellsSDF(vec2 NDC)\n{\n    //NDC *= 2.; // Finer cells\n    NDC = fract(NDC);\n    NDC = fract(min(NDC, 1. - NDC));\n    return\n        min(vertical_lineSDF(NDC, 0.), horizontal_lineSDF(NDC, 0.));\n}\n\n/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\n/*\n    Returns number of real roots.\n*/\nint solveQuadraticForReal(\n    out vec2[2] roots,\n    float a, float b, float c)\n{\n    float discriminant = b * b - 4.0 * a * c,\n          inv_a = 1.0 / (2. * a),\n          sqrt_D = sqrt(discriminant);\n\n    roots[0].x = ( sqrt_D - b) * inv_a;  roots[0].y = 0.0;\n    roots[1].x = (-b - sqrt_D) * inv_a; roots[1].y = 0.0;\n\n    return \n        discriminant < 0.0 ? // No real roots?\n        0 : 2;\n}\n\n// From original paper.\nint solve_cubic2(\n    out vec2 roots[3],\n    float A3,\n    float A2,\n    float A1,\n    float A0)\n{\n    A0 /= A3;\n    A1 /= A3;\n    A2 /= A3;\n    A3 = 1.;\n\n    float q = (A1 / 3.) - (A2 * A2) / 9.,\n           r = (A1 * A2 - 3. * A0) / 6. - (A2 * A2 * A2) / 27.;\n\n    if (r * r + q * q * q > 0.) // One real root?\n    {\n        float A = pow(abs(r) + sqrt(r * r + q * q * q), 1. / 3.),\n               t1 = r >= 0. ? A - q / A : q / A - A;\n\n        float x2 = -t1 / 2. - A2 / 3.,\n               y2 = (sqrt(3.) / 2.) * (A + q / A);\n\n        roots[0] = vec2(t1 - A2 / 3., 0.);\n        roots[1] = vec2(x2, y2);\n        roots[2] = vec2(x2, -y2);\n\n        return 1;\n    }\n    else // Three real roots.\n    {\n        const float PI = 3.141592;\n        float theta = q < 0. ? acos(r / pow(-q, 3. / 2.)) : 0.,\n            phi1 = theta / 3.,\n            phi2 = phi1 - (2. * PI) / 3.,\n            phi3 = phi1 + (2. * PI) / 3.;\n\n        roots[0] = vec2(2. * sqrt(-q) * cos(phi1) - A2 / 3., 0.);\n        roots[1] = vec2(2. * sqrt(-q) * cos(phi2) - A2 / 3., 0.);\n        roots[2] = vec2(2. * sqrt(-q) * cos(phi3) - A2 / 3., 0.);\n        // z0 <= z1 <= z2\n\n        return 3;\n    }\n}\n//\n// Solves cubic polynomial.\n// Returns number of real roots.\n//    if returns 1, then roots[0] is real, other two complex.\n//    if returns 3, then all 3 roots are real and they sorted in descending order.\n//\nint solve_cubic_modified(\n    out vec2 roots[3],\n    float a, float b, float c, float d)\n{\n    // To monic cubic.\n    float inv_a = 1./ a;\n    b *= inv_a; c *= inv_a; d *= inv_a; a = 1.;\n\n    // Helper constants and variables.\n    float TAU = 6.2831853071795862,     // 2. * PI\n          inv3 = 0.33333333333333331,   // 1. / 3.\n          inv9 = 0.11111111111111110,   // 1. / 9.\n          sqrt3 = 1.7320508075688772,   // sqrt(3)\n          g = c * inv3,\n          h = b * inv3;        \n    \n    // Solve depressed cubic.\n    float q = g - (b * b) * inv9,\n          r = ((c * b - 3. * d) * .5 - (b * b * b) * inv9) * inv3,\n          qqq = q*q*q;\n\n    if (r * r + qqq > 0.) // One real root?\n    {\n        float A = pow(abs(r) + sqrt(r * r + qqq), inv3),\n              k = q / A,\n              t1 = r >= 0. ? A - k : k - A;\n\n        float x2 = -t1 * .5 - h,\n              y2 = (sqrt3 * .5) * (A + k);\n\n        roots[0] = vec2(t1 - h, 0.);\n        roots[1] = vec2(x2, y2);\n        roots[2] = vec2(x2, -y2);\n\n        return 1;\n    }\n    \n    // Three real roots.\n    float theta = q < 0. ? acos(r / sqrt(-qqq)) : 0.,\n        phi1 = theta * inv3,\n        phi2 = phi1 - TAU * inv3,\n        phi3 = phi1 + TAU * inv3,\n        n = 2. * sqrt(-q);\n\n    roots[0] = vec2(n * cos(phi1) - h, 0.);\n    roots[1] = vec2(n * cos(phi2) - h, 0.);\n    roots[2] = vec2(n * cos(phi3) - h, 0.);\n    // if idx seq is {0,1,2} ther roots sorted in descending order: z0 >= z1 >= z2\n    // if idx seq is {2,1,0} ther roots sorted in ascending order: z0 <= z1 <= z2\n\n    return 3;\n}\n\n/* \n    Returns number of real roots.       \n*/\nint solve_cubic(\n    inout vec2[3] roots,\n    float a, float b, float c, float d)\n{\n    // Cubic equation?\n    if (a != 0.0)\n    {\n        return solve_cubic_modified(roots, a, b, c, d);\n    }\n    \n    // Quadratic equation?\n    if (b != 0.0)\n    {\n        vec2 roots_[2];\n        int num = solveQuadraticForReal(roots_, b, c, d);\n        roots[0] = roots_[0]; roots[1] = roots_[1];\n        \n        return num;\n    }\n\n    // Linear equation?\n    if (c != 0.0)\n    {\n        // Solve linear equation.\n        roots[0].x = -d/c; roots[0].y = 0.0;\n\n        return 1;\n    }\n\n    // Identity 0 == 0? Infinitely many roots?\n    if (c == 0.0) \n    { \n        // Pick zero root.\n        roots[0].x = 0.0; roots[0].y = 0.0;\n\n        return 1;\n    }\n    \n    return 0;\n}","name":"Common","description":"","type":"common"}]}