{"ver":"0.1","info":{"id":"WtSBRz","date":"1598165317","viewed":381,"name":"reflectbox","username":"Carandiru","description":"Vid Screen shader # .... ....\nabstract thing I saw, recreated","likes":5,"published":3,"flags":32,"usePreview":0,"tags":["reflection","abstract","gif"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// http://bit.ly/supersinfulsilicon\n\n// shader by Jason Tully is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/WtSBRz\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 radius;\n        \n    // Define the bluring radius/strength (direction independant)\n    if (uv.y > SPLIT) {\n    \tradius = vec2(3);\n        \n    }\n    else {\n        \n        uv.x += 0.001f;\n        radius = vec2(5);\n        \n    }\n \n    uv = CRTCurveUV(uv) * 0.5f + 0.5f;\n    \n    // Calculate the value at the corners so that the matrix can be easily inverted\n    float maxi = radius.x*radius.y;\n    // Define the variable which will hold the blured values\n    vec3 blur = vec3(0.0);\n\n    // Define the variable which will be used to normalize the image\n    float sum = 0.0;\n    // The kernel is dynamically created based on the bluring radius\n    for(float v = -radius.x; v<=radius.x; v++){\n        // The pixel weight used by the kernel is defined as: the distance from the kernel origin (0,0)\n        // to the current kernel position, subtracted from the maximum possible distance. This leads\n        // to a gradient from 0% relative weight on the edges to 100% relative weight at the origin of the kernel\n        float weight = abs(maxi - radius.y*v);\n        // The weight is then exponentialized which seams to sleightly maintain more of the origianl detail\n        //weight = pow(weight, 2.0);\n        // The weight is then multiplied by the texture being sampled and added to the overall blurred values\n        vec2 new_uv = uv + vec2(v, radius.y)/iResolution.xy;\n        blur += weight * texture( iChannel2, new_uv ).rgb + 0.25f * (1.0f - uv.y);\n\n\n        // The weight is then added for normalizing purposes\n        sum += weight;\n    }\n\n    // Finally the blurred image is normalized\n    blur /= sum;   \n\n    vec3 color = blur;\n    \n    color.b = color.r * 0.4f;\n    \n    if (uv.y < color.r) {\n        // https://www.shadertoy.com/view/ltVSDG\n        float US1 = sin(fragCoord.y)/2.+.7;\t\t\t\t\t//Screen Stripes\n        vec3 US2;\n        US2.x = sin(20./iResolution.y*fragCoord.y+(2.-.4))/10.+.85;\t//R Chromatic Screen Waves\n        US2.y = US2.z = sin(20./iResolution.y*fragCoord.y+(2.+.4))/10.+.85;\t//B Chromatic Screen Waves\n        vec3 US = US1 * US2;\t\n\n        color *= US * 1.1f;\n    }\n    \n    fragColor = vec4(color.rgb, 1.0f);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define TT (8.0f)\n#define tT (iTime)\n#define tTD (tT*(1.0f/TT))\n#define tTDD (tT*(TT))\n\n#define RECT 0.05f\n#define SPLIT 0.3f\n#define STUTTER (0.0212f * tTD)\n\n// https://www.shadertoy.com/view/3tlfRs - GPU Squares RNG - km\nfloat squares16(in uint ctr, in uint key) {\n    const float two16 = 1.0f/65536.0f;\n\n    uint x, y, z;\n\n    // initialize\n    // ==================================\n    // Weyl sequence vars, y and z\n    y = ctr * key;\n    z = (ctr + uint(1)) * key;\n\n    // init the mixing var, x\n    x = y;\n\n    // begin the mixing rounds\n    // ===================================\n\n    // round 1\n    x = x*x + y; x = (x>>16) | (x<<16);\n\n    // round 2\n    x = x*x + z; x = (x>>16) | (x<<16);\n\n    // round 3\n    x = (x*x + y) >> 16;\n\n    return float(x)*two16;\n}\n\nfloat pixel_id(in vec2 fragCoord, in vec2 res) {\n    return dot(fragCoord.xy,\n               vec2(1, res.x));\n}\n\nfloat filled_rect(vec2 uv, vec2 p0, vec2 p1)\n{\n    float c = 1.0;\n    c *= step(min(p0.x, p1.x), uv.x);\n    c *= (1.0 - step(max(p0.x, p1.x), uv.x));\n   \tc *= step(min(p0.y, p1.y), uv.y);\n    c *= (1.0 - step(max(p0.y, p1.y), uv.y));\n    return clamp(c, 0.0, 1.0);\n}\n\n// https://www.shadertoy.com/view/MttXWl - CRT Effects\nvec2 CRTCurveUV( vec2 uv )\n{\n    uv = uv * 2.0 - 1.0;\n    vec2 offset = abs( uv.yx ) / vec2( 6.0, 4.0 );\n    uv = uv + uv * sqrt(offset * offset * offset) * offset;\n    return(uv);\n}\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float id = pixel_id(fragCoord + (floor(tTD) + 0.0f), iResolution.xy);\n    uint cnt_pixels = uint(iResolution.x * iResolution.y);\n\n    vec4 color;\n    \n    color.r = squares16(uint(id), 0x7fu);\n    color.g = squares16(uint(id), 0x80u);\n    color.b = squares16(uint(id), 0x81u);\n    color.a = squares16(uint(id), 0x82u);\n\n    // Output to screen\n    fragColor = color;\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float id = pixel_id(fragCoord + (ceil(tTD) + 0.0f), iResolution.xy);\n    uint cnt_pixels = uint(iResolution.x * iResolution.y);\n\n    vec4 color;\n    \n    color.r = squares16(uint(id), 0x7fu);\n    color.g = squares16(uint(id), 0x80u);\n    color.b = squares16(uint(id), 0x81u);\n    color.a = squares16(uint(id), 0x82u);\n\n    // Output to screen\n    fragColor = color;\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGzn","filepath":"/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3","previewfilepath":"/media/ap/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3","type":"music","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float stutter = texture(iChannel3, vec2(tTDD)).r;\n    \n    vec4 rand;\n    float scene_max;\n    float scene_min;\n    {\n        vec2 uvP;\n        \n        if (uv.y > SPLIT) {\n            uvP = vec2(uv.x, -uv.y) * RECT;\n            scene_max = 0.0f;\n            scene_min = (0.5f+stutter) * (uv.y) * 2.0;\n        }\n        else {\n            // mirror effect\n            float xoffset = 0.005*cos(iTime*3.0+200.0*uv.y);\n            float yoffset = ((SPLIT - uv.y)/SPLIT) * 0.05*(1.0+cos(iTime*3.0+50.0*uv.y));\n            uvP = vec2(uv.x+xoffset, -(0.6 - uv.y+ yoffset)) * RECT;\n            scene_max = pow(yoffset, 1.21f) * 100.0f;\n            scene_min = 0.025f + yoffset * 100.0f * 0.5f * (0.5f+stutter);\n        }\n        \n    \trand = smoothstep(textureLod(iChannel0, uvP, 0.0f),\n    \t\t\t           textureLod(iChannel1, uvP, 0.0f),\n                           vec4(fract(tTD)));\n    }\n    \n    vec3 color = vec3(0.0f);\n    \n    color.r = filled_rect(uv, rand.xy, rand.zw) - scene_max;\n    color *= scene_min;\n\n    \n    fragColor = vec4(color.rgb, 1.0f);\n}","name":"Buf C","description":"","type":"buffer"}]}