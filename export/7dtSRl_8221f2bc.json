{"ver":"0.1","info":{"id":"7dtSRl","date":"1702868836","viewed":158,"name":"AMD FSR","username":"zpo","description":"实现FSR中的一些步骤","likes":6,"published":1,"flags":32,"usePreview":1,"tags":["postprocess","upsampling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//==============================================================================================================================\n//\n//                                      FSR - [RCAS] ROBUST CONTRAST ADAPTIVE SHARPENING\n//\n//------------------------------------------------------------------------------------------------------------------------------\n\n// This is set at the limit of providing unnatural results for sharpening.\n#define FSR_RCAS_LIMIT (0.25-(1.0/16.0))\n// Sharpness from 0.0 to 2.0 while 0.0 means sharpest.\n#define SHARPNESS 0.25\n\nfloat reverse(float a) { return 1.0 / a; }\n\nfloat saturate(float a) { return min(1.0, max(0.0, a)); }\n\nfloat max3(float a, float b, float c) { return max(a, max(b, c)); }\n\nfloat min3(float a, float b, float c) { return min(a, min(b, c)); }\n\nfloat Luma( vec3 col )\n{\n    // return col.r * 0.299 + col.g * 0.587 + col.b * 0.114;\n    // using Simplest multi-channel approximate luma possible (luma times 2, in 2 FMA/MAD).\n    return col.r * 0.5 + col.g + col.b * 0.5;\n}\n\nvec3 texByFragCoord(vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    return texture(iChannel0, uv).rgb;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // setup\n    float sharpness = exp2(-SHARPNESS);\n\n    // Algorithm uses minimal 3x3 pixel neighborhood.\n    //    b \n    //  d e f\n    //    h\n    vec2 epos = fragCoord.xy;\n    vec2 bpos = epos + vec2( 0.0, 1.0);\n    vec2 dpos = epos + vec2(-1.0, 0.0);\n    vec2 fpos = epos + vec2( 1.0, 0.0);\n    vec2 hpos = epos + vec2( 0.0,-1.0);\n    \n    vec3 e = texByFragCoord(epos);\n    vec3 b = texByFragCoord(bpos);\n    vec3 d = texByFragCoord(dpos);\n    vec3 f = texByFragCoord(fpos);\n    vec3 h = texByFragCoord(hpos);\n    \n    float eL = Luma(e);\n    float bL = Luma(b);\n    float dL = Luma(d);\n    float fL = Luma(f);\n    float hL = Luma(h);\n    \n    // Noise detection.\n    float nz = 0.25 * bL + 0.25 * dL + 0.25 * fL + 0.25 * hL - eL;\n    nz = saturate(abs(nz) * reverse(max3(max3(bL, dL, eL), fL, hL) - min3(min3(bL, dL, eL), fL, hL)));\n    nz = 1.0 - 0.5 * nz;\n    \n    // Visualize Noise detection\n    // fragColor = vec4(nz,nz,nz,1.0);\n    \n    // Min and max of ring.\n    float min4R = min(min3(b.r, d.r, f.r), h.r);\n    float min4G = min(min3(b.g, d.g, f.g), h.g);\n    float min4B = min(min3(b.b, d.b, f.b), h.b);\n    float max4R = max(max3(b.r, d.r, f.r), h.r);\n    float max4G = max(max3(b.g, d.g, f.g), h.g);\n    float max4B = max(max3(b.b, d.b, f.b), h.b);\n    \n    // Immediate constants for peak range.\n    vec2 peakC = vec2(1.0, -1.0*4.0);\n    \n    // Limiters, these need to be high precision RCPs.\n    float hitMinR = min4R * reverse(4.0 * max4R);\n    float hitMinG = min4G * reverse(4.0 * max4G);\n    float hitMinB = min4B * reverse(4.0 * max4B);\n    float hitMaxR = (peakC.x - max4R) * reverse(4.0 * min4R + peakC.y);\n    float hitMaxG = (peakC.x - max4G) * reverse(4.0 * min4G + peakC.y);\n    float hitMaxB = (peakC.x - max4B) * reverse(4.0 * min4B + peakC.y);\n    float lobeR = max(-hitMinR, hitMaxR);\n    float lobeG = max(-hitMinG, hitMaxG);\n    float lobeB = max(-hitMinB, hitMaxB);\n    float lobe = max(-FSR_RCAS_LIMIT, min(max3(lobeR,lobeG,lobeB), 0.0)) * sharpness;\n    \n    // Apply noise removal.\n    lobe *= nz;\n    \n    // Resolve, which needs the medium precision rcp approximation to avoid visible tonality changes.\n    float rcpL = reverse(4.0 * lobe + 1.0);\n    vec3 col = lobe * b + lobe * d + lobe * h + lobe * f + e;\n    col *= rcpL;\n    \n    fragColor = vec4(col, 1.0);\n    \n    // Visualize without RCAS\n    // fragColor = texture(iChannel0, fragCoord.xy / iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//==============================================================================================================================\n//\n//                                        FSR - [EASU] EDGE ADAPTIVE SPATIAL UPSAMPLING\n//\n//------------------------------------------------------------------------------------------------------------------------------\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nconst float inputPixelsX = 1286.0;\nconst float inputPixelsY = 725.0;\nconst float outputPixelsX = 1920.0;\nconst float outputPixelsY = 1080.0;\n\nfloat reverse(float a) { return 1.0 / a; }\n\nfloat saturate(float a) { return min(1.0, max(0.0, a)); }\n\nfloat Luma( vec3 col )\n{\n    // return col.r * 0.299 + col.g * 0.587 + col.b * 0.114;\n    // using Simplest multi-channel approximate luma possible (luma times 2, in 2 FMA/MAD).\n    return col.r * 0.5 + col.g + col.b * 0.5;\n}\n\nvec3 texByFragCoord(vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / vec2(inputPixelsX, inputPixelsY);\n    uv.y = 1.0 - uv.y;\n    return texture(iChannel0, uv).rgb;\n}\n\nvoid FsrEasuSetF(inout vec2 dir, inout float F, vec2 ipos, \n    bool biS, bool biT, bool biU, bool biV, \n    float lA, float lB, float lC, float lD, float lE)\n{\n    //  Compute bilinear weight, x y relative to bottom left origin \n    //  s t\n    //  u v\n    float w = 0.0;\n    if(biS)w=(1.0-ipos.x)*(1.0-ipos.y);\n    if(biT)w=     ipos.x *(1.0-ipos.y);\n    if(biU)w=(1.0-ipos.x)*     ipos.y ;\n    if(biV)w=     ipos.x *     ipos.y ;\n    //    a\n    //  b c d\n    //    e\n    float dc = lD - lC;\n    float cb = lC - lB;\n    float lenX = max(abs(dc), abs(cb));\n    lenX = reverse(lenX);\n    dir.x += (lD - lB) * w;\n    lenX = saturate(abs(lD - lB) * lenX);\n    lenX *= lenX;\n    F += lenX * w;\n    // Repeat for the y axis.\n    float ec = lE - lC;\n    float ca = lC - lA;\n    float lenY = max(abs(ec), abs(ca));\n    lenY = reverse(lenY);\n    dir.y += (lE - lA) * w;\n    lenY = saturate(abs(lE - lA) * lenY);\n    lenY *= lenY;\n    F += lenY * w;\n}\n\nvoid FsrEasuTapF(inout vec3 aC, inout float aW, vec2 offset, vec2 dir, vec2 len, float w, float clp, vec3 col)\n{\n    // Rotate offset by direction.\n    vec2 v;\n    v.x = (offset.x * dir.x) + (offset.y * dir.y);\n    v.y = (offset.x * (-dir.y)) + (offset.y * dir.x);\n    v *= len;\n    // distance^2\n    float d2 = v.x*v.x + v.y*v.y;\n    d2 = min(d2, clp);\n    // Approximation of lancos2\n    // (25/16 * (2/5 * x^2 - 1)^2 - (25/16 - 1)) * (w * x^2 - 1)^2\n    float wB = (2.0 / 5.0) * d2 - 1.0;\n    float wA = w * d2 - 1.0;\n    wB *= wB;\n    wA *= wA;\n    wB = (25.0 / 16.0) * wB - (25.0 / 16.0 - 1.0);\n    float weight = wB * wA;\n    aC += col * weight;\n    aW += weight;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // setup\n    vec4 con0;\n    con0[0] = inputPixelsX * reverse(outputPixelsX);\n    con0[1] = inputPixelsY * reverse(outputPixelsY);\n    con0[2] = reverse(inputPixelsX);\n    con0[3] = reverse(inputPixelsY);\n    \n    //      +---+---+\n    //      | ~ | ~ |\n    //      +---+---+\n    //      | b | c |\n    //  +---+---+---+---+\n    //  | e | f | g | h |\n    //  +---F---+---+---+\n    //  | i | j | k | l |\n    //  +---+---+---+---+\n    //      | n | o |\n    //      +---+---+\n    //      | ~ | ~ |\n    //      +---+---+\n\n\tvec2 pos = fragCoord.xy * con0.xy + vec2(0.5 * con0[0] - 0.5, 0.5 * con0[1] - 0.5);\n    vec2 inner_pos = pos - floor(pos);    // inner position relative to F\n    vec2 fpos = floor(pos) + vec2(0.5, 0.5);   // f\n    vec2 bpos = fpos + vec2(0.0, 1.0);    // b\n    vec2 cpos = fpos + vec2(1.0, 1.0);    // c\n    vec2 epos = fpos + vec2(-1.0, 0.0);   // e\n    vec2 gpos = fpos + vec2(1.0, 0.0);    // g\n    vec2 hpos = fpos + vec2(2.0, 0.0);    // h\n    vec2 ipos = fpos + vec2(-1.0, -1.0);  // i\n    vec2 jpos = fpos + vec2(0.0, -1.0);   // j\n    vec2 kpos = fpos + vec2(1.0, -1.0);   // k\n    vec2 lpos = fpos + vec2(2.0, -1.0);   // l\n    vec2 npos = fpos + vec2(0.0, -2.0);   // n\n    vec2 opos = fpos + vec2(1.0, -2.0);   // o\n    \n    // texture\n    vec3 fcol = texByFragCoord(fpos);\n    vec3 bcol = texByFragCoord(bpos);\n    vec3 ccol = texByFragCoord(cpos);\n    vec3 ecol = texByFragCoord(epos);\n    vec3 gcol = texByFragCoord(gpos);\n    vec3 hcol = texByFragCoord(hpos);\n    vec3 icol = texByFragCoord(ipos);\n    vec3 jcol = texByFragCoord(jpos);\n    vec3 kcol = texByFragCoord(kpos);\n    vec3 lcol = texByFragCoord(lpos);\n    vec3 ncol = texByFragCoord(npos);\n    vec3 ocol = texByFragCoord(opos);\n\n    // luma\n    float fluma = Luma(fcol);\n    float bluma = Luma(bcol);\n    float cluma = Luma(ccol);\n    float eluma = Luma(ecol);\n    float gluma = Luma(gcol);\n    float hluma = Luma(hcol);\n    float iluma = Luma(icol);\n    float jluma = Luma(jcol);\n    float kluma = Luma(kcol);\n    float lluma = Luma(lcol);\n    float nluma = Luma(ncol);\n    float oluma = Luma(ocol);\n    \n    float F = 0.0;\n    vec2 dir = vec2(0.0);\n    \n    // convert origin F to top left\n    inner_pos.y = 1.0 - inner_pos.y;\n    \n    //      +---+---+\n    //      | ~ | ~ |\n    //      +---+---+\n    //      | b | c |\n    //  +---F---+---+---+\n    //  | e | f | g | h |\n    //  +---+---+---+---+\n    //  | i | j | k | l |\n    //  +---+---+---+---+\n    //      | n | o |\n    //      +---+---+\n    //      | ~ | ~ |\n    //      +---+---+\n    \n    FsrEasuSetF(dir, F, inner_pos, true, false, false, false, bluma, eluma, fluma, gluma, jluma);\n    FsrEasuSetF(dir, F, inner_pos, false, true, false, false, cluma, fluma, gluma, hluma, kluma);\n    FsrEasuSetF(dir, F, inner_pos, false, false, true, false, fluma, iluma, jluma, kluma, nluma);\n    FsrEasuSetF(dir, F, inner_pos, false, false, false, true, gluma, jluma, kluma, lluma, oluma);\n    \n    vec2 dir2 = dir * dir;\n    float dirR = dir2.x + dir2.y;\n    bool zro = dirR < (1.0 / 32768.0);\n    dirR = inversesqrt(dirR);\n    dirR = zro? 1.0 : dirR;\n    dir.x = zro? 1.0 : dir.x;\n    dir *= vec2(dirR);\n    \n    F = F * 0.5;\n    F *= F; // Edge feature\n    \n    // Visualize feature\n    // fragColor = vec4(F,F,F,1.0);\n    \n    float stretch = (dir.x * dir.x + dir.y * dir.y) * reverse(max(abs(dir.x), abs(dir.y)));\n    \n    vec2 len2 = vec2(1.0 + (stretch - 1.0) * F, 1.0 - 0.5 * F);\n    \n    float w = 0.5 + ((1.0/4.0-0.04)-0.5)*F;\n    float clp = reverse(w);\n    \n    // clamp by 4 nearest pixels\n    vec3 min4 = min(fcol, min(gcol, min(jcol, kcol)));\n    vec3 max4 = max(fcol, max(gcol, max(jcol, kcol)));\n\n    // Accumulate color and weight\n    vec3 aC = vec3(0.0);\n    float aW = 0.0;\n    \n    FsrEasuTapF(aC, aW, vec2( 0.0,-1.0) - inner_pos, dir, len2, w, clp, bcol);     // b\n    FsrEasuTapF(aC, aW, vec2( 1.0,-1.0) - inner_pos, dir, len2, w, clp, ccol);     // c\n    FsrEasuTapF(aC, aW, vec2(-1.0, 0.0) - inner_pos, dir, len2, w, clp, ecol);     // e\n    FsrEasuTapF(aC, aW, vec2( 0.0, 0.0) - inner_pos, dir, len2, w, clp, fcol);     // f\n    FsrEasuTapF(aC, aW, vec2( 1.0, 0.0) - inner_pos, dir, len2, w, clp, gcol);     // g\n    FsrEasuTapF(aC, aW, vec2( 2.0, 0.0) - inner_pos, dir, len2, w, clp, hcol);     // h\n    FsrEasuTapF(aC, aW, vec2(-1.0, 1.0) - inner_pos, dir, len2, w, clp, icol);     // i\n    FsrEasuTapF(aC, aW, vec2( 0.0, 1.0) - inner_pos, dir, len2, w, clp, jcol);     // j\n    FsrEasuTapF(aC, aW, vec2( 1.0, 1.0) - inner_pos, dir, len2, w, clp, kcol);     // k\n    FsrEasuTapF(aC, aW, vec2( 2.0, 1.0) - inner_pos, dir, len2, w, clp, lcol);     // l\n    FsrEasuTapF(aC, aW, vec2( 0.0, 2.0) - inner_pos, dir, len2, w, clp, ncol);     // n\n    FsrEasuTapF(aC, aW, vec2( 1.0, 2.0) - inner_pos, dir, len2, w, clp, ocol);     // o\n    \n    // Normalize\n    vec3 result = aC / aW;\n \n    result = min(max4, max(min4, result));\n    \n    fragColor = vec4(result, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}