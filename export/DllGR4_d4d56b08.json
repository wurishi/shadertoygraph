{"ver":"0.1","info":{"id":"DllGR4","date":"1671395545","viewed":131,"name":"Geometric ray-sphere ","username":"stduhpf","description":"An alternative formula for computing exact ray-sphere intersection, using geometric intuition instead of the quadratic formula.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raycasting","analytic","geometric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct ray{\n    vec3 o;\n    vec3 d;\n};\n\nstruct sphere{\n    vec3 c;\n    float r;\n};\n\nfloat ray_sphere_intersect(ray r, sphere s){\n    // project sphere center onto ray (to get the point on the ray that is closest to sphere center)\n    vec3 c = s.c-r.o;\n    float d0 = dot(c,r.d); \n    vec3 pc = c-d0*r.d;\n    \n    //calculate square of the distance between the center and the ray\n    float h2 = dot(pc,pc);\n    \n    float r2 = s.r*s.r;\n    \n    if(h2>r2){\n        // if the closest point to the center on the ray is at a distance larger than the radius, then there is no intersection; \n        return -1.;\n    }\n    \n    // get the half arclength of the ray inside the sphere\n    float delta = sqrt(r2-h2);\n    \n    return d0-delta;// the other solution is d0+delta\n}\n\nfloat ray_sphere_intersect_quadratic(ray r, sphere s)\n{\n    // the usual formula, solving the equation ||(r.o+r.d*x -s.c)||²=s.r² \n    // assuming r.d is normalized\n    // it can be rewriten as x² + 2*b*x + c = 0\n    // with b = r.d•(r.o-s.c) and c = (r.o-s.c)•(r.o-s.c)-s.r²\n    // you can see it's the exact same thing as the other function, but written differently (and less intuitive)\n    vec3 p = r.o-s.c;\n    float b = dot(r.d,p);\n    \n    float c = dot(p,p)-s.r*s.r;\n    float d = (b*b-c);\n    if(d<0.)\n        return -1.;\n    return -b-sqrt(d); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n\n    ray r;\n    float k = 0.;//16777250.;\n    r.o = vec3(0,0,k);\n    r.d = normalize(vec3(uv,1.));\n    \n    sphere s;\n    s.c = vec3(0.,0.,k+1.);\n    s.r = .5;\n    \n    float d = ray_sphere_intersect(r,s);\n    \n    fragColor = vec4(0.);\n    if(d<0.)\n    return;\n    \n    vec3 n = normalize(r.o+r.d*d-s.c);\n    // Output to screen\n    fragColor = vec4(sqrt(.01+max(dot(n,normalize(vec3(-1.))),0.)));\n}","name":"Image","description":"","type":"image"}]}