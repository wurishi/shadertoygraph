{"ver":"0.1","info":{"id":"4fXfDn","date":"1723780952","viewed":20,"name":"Slim Shader","username":"jcraw","description":"learning\n","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["smiley"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI     3.14159265\n\nfloat circle(vec2 uv, vec2 pos, float radius, float blur) {  \n    uv -= pos;\n    float d = length(uv);\n    float c = smoothstep(radius, radius - blur, d);\n    \n    if(blur == 0.) {\n        if (d > radius)\n            c = 0.;\n        else\n            c = 1.;\n    }\n          \n    return c;\n}\n\nfloat rectangle(vec2 uv, vec2 pos, float width, float height, float blur) {\n    uv -= pos;\n    float x_step = smoothstep(width/2., width/2. - blur, abs(uv.x));\n    float y_step = smoothstep(height/2., height/2. - blur, abs(uv.y));\n    return x_step * y_step;\n}\n\nfloat overlapThing(vec2 uv, vec2 pos, float width, float height, float blur) {\n    uv -= pos;\n    float x_step = smoothstep(width/2., width/2. - blur, abs(uv.x));\n    float y_step = smoothstep(height/2., height/2. - blur, abs(uv.y));\n    return x_step + y_step;\n}\n\nfloat remapToNormal(float value, float start, float end) {\n    return (value + start) / (start * end);\n}\n\nfloat domainDistortionThing(vec2 uv, vec2 pos, float start_edge,\n    float end_edge, float top_edge, float bottom_edge) {\n    uv -= pos;\n    float width = 2.;\n    float height = .2;\n    float blur = .2 * remapToNormal(uv.x, -.9, .9);\n    \n    float x = uv.x;\n    \n    float m = sin(iTime + (x + .2 )* (PI * 2.)) * .3 ; //(x - .5) * (x + .5);\n   // m = m*m*4.;\n    \n   // m = sin(iTime) * .3;\n    \n    \n    float y = uv.y - m;\n    \n     \n    //float start_edge = -.2;\n    float start_step = smoothstep(start_edge - blur, start_edge + blur, x);\n    \n    //float end_edge = .2;\n    float end_step = smoothstep(end_edge + blur, end_edge - blur, x);\n\n   // float top_edge = .1;\n    float top_step = smoothstep(top_edge + blur, top_edge - blur, y);\n    \n   // float bottom_edge = -.1;\n    float bottom_step = smoothstep(bottom_edge - blur, bottom_edge + blur, y);\n    \n    return start_step * end_step * top_step * bottom_step;\n}\n\n\nfloat smileyFace(vec2 uv, vec2 pos, float size) {\n\n    uv -= pos;\n    uv /= size;\n\n    float mask = circle(uv, vec2(.0, -.0), .4, .05);  // .2 , -.1\n    \n    \n    // left eye\n    mask -= circle(uv * vec2(1., 2.), vec2(-.15, .25), .07, .01);\n    // right eye \n    mask -= circle(uv * vec2(1., 2.), vec2(.15, .25), .07, .01);\n    \n    // mouth\n    mask -= circle(uv, vec2(.0, -.08), .07, .01);\n    mask += circle(uv, vec2(.0, -.05), .09, .01);\n    \n    mask = clamp(mask, 0., 1.);\n    \n    return mask;\n}\n\nvec3 getDebugMaskColor(float mask) {\n    vec3 col = vec3(1.0);\n     if(mask == 1.0)  // red - the mask part to see\n         col = vec3(1., .0, .0);\n     else if(mask == 0.0) // green - will be black background \n            col = vec3(0., 1., 0.);\n     else  // other is blue \n         col = vec3(0., 0., 1.);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 changing_color = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec2 main_uv = vec2(uv.x, uv.y);\n    \n    // time scaling\n    main_uv *= abs(cos(iTime * (2.*PI) / 12.)) * 5.0;\n    \n    main_uv.x += -main_uv.y*.1;  // a bit of skew \n    \n    float m = main_uv.x * main_uv.x;\n    \n\n    float mask = 0.;\n    float smiley = smileyFace(main_uv, vec2(0., 0.), .85 + main_uv.y);\n    float rectangle = rectangle(main_uv, vec2(.0, 0.115), .5, .2 + m, .01);\n    float overlap_rectangle = overlapThing(main_uv, vec2(.0, 0.115), .4, .2, .05);\n    \n    mask += smiley;\n    \n    float mask_time = cos(iTime * (2.*PI) / 4. );\n    float mask_show = smoothstep(-.3, .3, mask_time);\n    float mask_overlap_show = smoothstep(.8, .99, mask_time);\n\n    mask += rectangle * mask_show;\n    mask += overlap_rectangle * mask_overlap_show; \n    \n    mask += domainDistortionThing(uv, vec2(.0, .0) , -1., 1., .1, -.1);\n    mask += domainDistortionThing(-uv, vec2(.0, .0) , -1., 1., .1, -.1);\n    \n    vec3 col = changing_color;\n    col *= mask;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}