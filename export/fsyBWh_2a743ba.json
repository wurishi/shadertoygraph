{"ver":"0.1","info":{"id":"fsyBWh","date":"1658053193","viewed":79,"name":"Bisection Root-Finding Method","username":"Envy24","description":"Based on this shader: https://www.shadertoy.com/view/fsB3Wt\n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["approximation","solver","quadratic","bisection","numeric"],"hasliked":0,"parentid":"ssKfDz","parentname":"Secant Root-Finding Method"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                           iResolution\n#define AR                        ( R.x / R.y )                      // Aspect ratio (AR > 1.0).\n#define TO_CENTERED_NDC(SC)       ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define UNIT                      (  6.0 / R.y  )\n#define SM(x)                     ( smoothstep(UNIT, 0., x) )\n#define LMB_IS_HOLD               ( iMouse.z > 0.0 )\n\nfloat x_axis(vec2 NDC) { return SM(abs(NDC.x)); }\nfloat y_axis(vec2 NDC) { return SM(abs(NDC.y)); }\nfloat draw_func(vec2 NDC, float f, float dfdx)\n{\n    float df   = NDC.y - f;\n    return SM(abs(df) / sqrt(1.0 + dfdx * dfdx));\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = \n        LMB_IS_HOLD ?\n            2.5*TO_CENTERED_NDC(SC-(iMouse.xy-R.xy*0.5)) :\n            2.5*TO_CENTERED_NDC(SC);\n\n    //float a = 1., b = 0., c = -1., d = 0., e = 1., f = -1.;\n    /**/\n    float a = sinOSC(-1.25, 1.25, iTime * 0.15), b = sinOSC( -2.0,  2.0, iTime * 0.6), \n          c = sinOSC( -1.0,  1.0, iTime * 0.45), d = sinOSC( -1.0,  1.0, iTime * 0.25),\n          e = sinOSC( -1.0,  1.0, iTime * 0.17), f = sinOSC( -1.0,  1.0, iTime * 0.07);\n    /**/\n\n/* Algebraic */\n//#define func(x)  ( ((((a * x + b) * x + c) * x + d) * x + e) * x + f )\n//#define deriv(x) ( (((5. * a * x + 4. * b) * x + 3. * c) * x + 2. * d) * x + e )\n//#define func(x)  ( (((a * x + b) * x + c) * x + d) * x + e )\n//#define deriv(x) ( ((4.0 * a * x + 3.0 * b) * x + 2.0 * c) * x + d )\n//#define func(x)  ( ((a * x + b) * x + c) * x + d )\n//#define deriv(x) ( (3.0 * a * x + 2.0 * b) * x + c )\n//#define func(x)  ( (a * x + b) * x + c )\n//#define deriv(x) ( 2. * a * x + b )\n//#define func(x)  ( a * x + b )\n//#define deriv(x) ( 2. * a )\n/* Transcendential. */\n#define func(x)  ( sin(8.*x) )\n#define deriv(x) ( 8.*cos(8.*x) )\n//#define func(x)  ( exp(x) )\n//#define deriv(x) ( exp(x) )\n//#define func(x)  ( log(x) )\n//#define deriv(x) ( 1./x )\n//#define func(x)  ( sqrt(x)-1. )\n//#define deriv(x) ( 1./(2.*sqrt(x)) )\n//#define func(x)  ( abs(x)-1. )\n//#define deriv(x) ( x/abs(x) )\n/* */\n\n    vec3 color = vec3(1.);\n         color -= draw_func(NDC, func(NDC.x), deriv(NDC.x));\n         color -= x_axis(NDC); color -= y_axis(NDC);\n\n    /* Initial approximation. */\n    float xl = sinOSC(-1.5, -4.0, iTime * 0.25), xr = -xl+0.1;\n    color = mix(color, vec3(0, 0, 1), SM(diskSDF_L2(NDC, vec2(xl, 0.0), 0.03)));\n    color = mix(color, vec3(0, 0, 1), SM(diskSDF_L2(NDC, vec2(xr, 0.0), 0.03)));\n    \n    /* First vertical segment */\n    color = mix(color, vec3(0, 1, 0), SM(segmentSDF_L2(NDC, vec2(xl, 0.0), vec2(xl, func(xl)))));\n    color = mix(color, vec3(1, 0, 1), SM(diskSDF_L2(NDC, vec2(xl, func(xl)), 0.03)));\n    color = mix(color, vec3(0, 1, 0), SM(segmentSDF_L2(NDC, vec2(xr, 0.0), vec2(xr, func(xr)))));\n    color = mix(color, vec3(1, 0, 1), SM(diskSDF_L2(NDC, vec2(xr, func(xr)), 0.03)));\n    color = mix(color, vec3(1, 0, 0), SM(segmentSDF_L2(NDC, vec2(xl, func(xl)), vec2(xr, func(xr)))));\n    \n    /* Inlined Bisection Method */\n    const float tolerance = 1e-7; /* Desired precision. */\n\n    float X[2] = float[2]( xl, xr );\n    float F[2] = float[2](\n        func(xl),  // f(xl)\n        func(xr)); // f(xr)\n\n    float y = 0.5;\n    \n    for (int i = 0; (i < 10) && (abs(y) > tolerance); ++i)\n    {\n        // Make step of bisection method.\n        float x = (X[0] + X[1]) * 0.5;\n              y = func(x);\n\n        int w_idx = int(sign(F[0]) != sign(y));\n        \n        F[w_idx] = y; X[w_idx] = x;\n        \n        /* Visualization */\n        color = mix(color, vec3(0, 1, 0), SM(segmentSDF_L2(NDC, vec2(X[0], 0.0), vec2(X[0], func(X[0])))));\n        color = mix(color, vec3(1, 0, 1), SM(diskSDF_L2(NDC, vec2(X[0], func(X[0])), 0.03)));\n        color = mix(color, vec3(0, 1, 0), SM(segmentSDF_L2(NDC, vec2(X[1], 0.0), vec2(X[1], func(X[1])))));\n        color = mix(color, vec3(1, 0, 1), SM(diskSDF_L2(NDC, vec2(X[1], func(X[1])), 0.03)));\n        color = mix(color, vec3(1, 0, 0), SM(segmentSDF_L2(NDC, vec2(X[0], func(X[0])), vec2(X[1], func(X[1])))));\n        /* Visualization */\n    }\n\n    float x = (X[0] + X[1]) * 0.5;\n\n    /* Root */\n    color = mix(color, vec3(1, 0, 0), SM(diskSDF_L2(NDC, vec2(x, 0.0), 0.05)));\n\n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nfloat diskSDF_L2(vec2 NDC, vec2 C, float R)\n{\n    return length(C - NDC)-R;\n}\n\nfloat segmentSDF_L2(\n    in vec2 NDC,\n    in vec2 B,   \n    in vec2 E)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0));\n}","name":"Common","description":"","type":"common"}]}