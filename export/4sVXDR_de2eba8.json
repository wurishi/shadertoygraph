{"ver":"0.1","info":{"id":"4sVXDR","date":"1463818900","viewed":254,"name":"Totalistic Cellular Automata","username":"DiogoCosta","description":"Code based on: https://www.shadertoy.com/view/Xd3GWB\n\nMy first attempt at a shader -- any suggestion is appreciated\n\n\nChange \"num\" on buffer A to change the base rule for the automata.\nMore info can be found in Stephen Wolfram's New Kind of Science.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["2d","automata","cellular","totalistic","parallel","neumann","wolfram"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 t = texture(iChannel0,fragCoord / iResolution.xy);\n    if (t.x == 1.0) {\n        fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n    } else {\n\t\tfragColor = vec4(0.0);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor=texture(iChannel0, fragCoord/iResolution.xy); \n    \n    float num = 12.0;\n    bool rule[10];\n    for(float i=9.0; i>=0.0; i--){\n        if(num >= pow(2.0, i)){ rule[int(i)]=true; num-=pow(2.0, i); }\n        else rule[int(i)]=false;\n    }\n    \n    if((iTime<1.0))\n    {\n        if(abs(fragCoord.x-iResolution.x/2.0)<=1. && abs(fragCoord.y-iResolution.y/2.0)<=0.5) fragColor.x=1.0;\n        else fragColor.x=0.0;\n        //Reworked previous code to show only one pixel... above solution seems simpler, but shows 4 pixels...\n        /*\n\t\tvec2 dst = fragCoord.xy - (iResolution.xy/2.0);\n        vec2 len = abs(dst);\n        bool a = len.x < 0.0 || (dst.x > 0.0 && dst.x < 1.0);\n        bool b = len.y < 0.0 || (dst.y > 0.0 && dst.y < 1.0);\n        bool c = len.x < 1.0 && dst.x >= 0.0;\n        bool d = len.y < 1.0 && dst.y >= 0.0;\n        fragColor.x= (a&&d || b&&c) ? 1.0: 0.0;\n\t\t*/\n    }\n    else if( (iFrame) == iFrame )\n    {\n        \n        \t//Checking neighbourhood\n            vec4 u=vec4(0.0);\n            u+=texture(iChannel0,(fragCoord+vec2( 0.0,-1.0))/iResolution.xy); //bottom\n            u+=texture(iChannel0,(fragCoord+vec2(-1.0, 0.0))/iResolution.xy); //left\n            u+=texture(iChannel0,(fragCoord+vec2( 1.0, 0.0))/iResolution.xy); //right\n            u+=texture(iChannel0,(fragCoord+vec2( 0.0, 1.0))/iResolution.xy); //top\n        \t\n        \t//There might be a more elegant way of doing this, but I'm not used shaders' gymnastics\n        \tif(((u.x==4.0 && rule[8])  || (u.x==3.0 && rule[6]) || (u.x ==2.0 && rule[4]) || (u.x ==1.0 && rule[2]) || (u.x== 0.0 && rule[0])) && fragColor.x==0.0)\n                fragColor.x=1.0;\n            else if (((u.x==4.0 && rule[9])  || (u.x==3.0 && rule[7]) || (u.x==2.0 && rule[5]) || (u.x==1.0 && rule[3]) || (u.x== 0.0 && rule[1]) ) && fragColor.x==1.0)\n                fragColor.x=1.0;\n            else fragColor.x=0.0;\n            \n            //Index can't be variable... can I fix this?    \n            //if(rule[int(u.x*2.0 +fragColor.x)]) fragColor.x=1.0;\n            //else fragColor.x=0.0;\n    }\n}","name":"Buf A","description":"","type":"buffer"}]}