{"ver":"0.1","info":{"id":"mdsGR7","date":"1665901095","viewed":109,"name":"stupid complex ginzburg landau","username":"micahbro","description":"simple finite difference complex ginzburg-landau equation simulator\nbuttons (right to left): toggle button bar, alpha (complex diffusion), beta (complex nonlinear), advective flow (dispersive tho..), magnitude view, noise injection (press & hold), erase","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["diffusion","reactiondiffusion","reaction","spontaneouspattern"],"hasliked":0,"parentid":"tscSDN","parentname":"stupid swift hohenberg"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    configureAndUpdate(iResolution, iChannel3, iMouse, iFrame < 10);\n\n    // Screen coordinates.\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5) / iResolution.y;\n    \n    ivec2 ifc = ivec2(round(fragCoord)); \n    \n    vec2 pq = vec2(texelFetch(iChannel0, ifc, 0));\n    \n    vec3 sceneColor = (vec3(pq[0], pq[1], pq[0] / 10.) * 0.5 + 0.5);\n    \n    if (controls[magCtl].value > 0.) { // plot magnitude (mostly)  \n        float magpq = dot(pq, pq);\n        sceneColor = (vec3(magpq, magpq / 10., pq[0] / 10.) * 0.5 + 0.5);\n    }\n    \n\tfragColor = vec4(clamp(sceneColor, 0., 1.), 1);    \n    \n    vec4 controlColor = texture(CTRL_CHANNEL, fragCoord / vec2(iResolution));\n    fragColor = (1. - controlColor[3]) * fragColor + controlColor[3] * controlColor;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// CGL equation (see e.g. https://codeinthehole.com/tutorial/index.html)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    vec4 mouse = configureAndUpdate(iResolution, iChannel3, iMouse, iFrame < 10);\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5) / iResolution.y;\n    float aspect = float(iResolution.x) / float(iResolution.y);\n    ivec2 ifc = ivec2(round(fragCoord)); \n    \n    vec2 pq = vec2(texelFetch(iChannel0, ifc, 0));\n\n    vec2 pqn = vec2(texelFetch(iChannel0, ifc - ivec2(0,2), 0));\n    vec2 pqs = vec2(texelFetch(iChannel0, ifc + ivec2(0,2), 0));\n    vec2 pqw = vec2(texelFetch(iChannel0, ifc - ivec2(2,0), 0));\n    vec2 pqe = vec2(texelFetch(iChannel0, ifc + ivec2(2,0), 0));\n\n    vec2 pqnw = vec2(texelFetch(iChannel0, ifc - ivec2(2,2), 0));\n    vec2 pqse = vec2(texelFetch(iChannel0, ifc + ivec2(2,2), 0));\n    vec2 pqne = vec2(texelFetch(iChannel0, ifc - ivec2(2,-2), 0));\n    vec2 pqsw = vec2(texelFetch(iChannel0, ifc + ivec2(2,-2), 0));\n    \n    float dt = 0.3;\n    int substeps = 10;\n    float k2 = 2.0; // * (1. - controls[kCtl].value);\n    float alpha = controls[alphaCtl].value * 2.;\n    float beta = 1.0 + controls[betaCtl].value * 2.;\n    float c = controls[cCtl].value;\n\n\n    float dtss = dt / float(substeps);\n    vec2 pqold = pq;\n    vec2 pqnew = pq;\n\n    // substep locally to handle beta more stably; won't help with alpha but that's less of a problem\n    for (int ss = 0; ss < substeps; ss++) {\n    \n        // don't know if this advection term behaves realistically\n        vec2 flux = dtss * abs(c) * ((c > 0. ? pqw : pqe) - pq);\n\n        //float lappq = (pqn + pqs + pqe + pqw - 4. * pq) / 4.;\n        \n        // 9-point laplacian for better isotropy and CFL limit:\n        vec2 lappq = (pqn + pqs + pqe + pqw +\n                       0.25 * (pqnw + pqne + pqsw + pqse)\n                       - 5. * pq) / 6.;\n\n        float pq2 = dot(pq, pq);\n\n        vec2 ipq = vec2(-pq[1], pq[0]);\n        vec2 ilappq = vec2(-lappq[1], lappq[0]);\n\n        pqnew = pq + dtss * (pq + k2 * lappq + alpha * k2 * ilappq - pq2 * pq - beta * pq2 * ipq) + flux;\n        pq = pqnew;\n    }\n    pq = pqold;\n    \n    vec2 mouseDist = abs(fragCoord.xy) - vec2(iMouse);\n    float mouseD = sqrt(dot(mouseDist, mouseDist));\n    if (mouseD <= 8. && mouse[2] > 0.) {\n        pqnew = max(pqnew, 2. * vec2(1. - mouseD / 3., 0.));\n        //pqnew += 4. * vec2(1. - mouseD / 3., 0.);\n    }\n    \n    float crappyHash = mod(float(iFrame) * fragCoord.x * fragCoord.y * 7919., 977.) / 1e3;\n    if (iFrame < 10) {\n        pqnew[0] += crappyHash / 1.e6;\n        \n        // hackery: guess if we're in preview mode and made something more promptly?? (doesn't seem to be working)\n        if (iResolution.x + iResolution.y < 500.) {\n\t        pqnew[0] += crappyHash / 1.e6;\n            pqnew += uv / 1.e6;\n        }\n    }\n    \n    if (controls[randCtl].value > 0.) {\n        pqnew[0] += (crappyHash - 0.5) / 1.e3;\n    }\n    \n    if (controls[resetCtl].value > 0.) {\n        pqnew = vec2(crappyHash / 1.e9 * 10., 0);\n    }\n    \n    fragColor = vec4(pqnew, pq);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// gui pane\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    configureAndUpdate(iResolution, iChannel3, iMouse, iFrame < 10);    \n\n    // hackery: guess if we're in preview mode and show the button bar\n    if (iResolution.x + iResolution.y < 500.) {\n        controls[visControl].value = 1.;\n    }\n    \n    \n    for (int i = 0; i < MAX_CTRLS; i++) {\n        if (i != visControl) {\n            controls[i].visible = controls[visControl].value > 0.;\n            controls[i].enabled = controls[visControl].value > 0.;\n        } else {\n            // Resizes inevitably bork gui state, but at least the toggle should be made visible:\n            controls[i].visible = true;\n            controls[i].enabled = true;\n        }\n    }\n\n    fragColor = renderControls(fragCoord, iMouse);\n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// sh*ttyguikit 0.1.1\n\n#define TOGGLE_BTN_T 1\n#define PUSH_BTN_T 2\n#define SPINNER_T 3\n#define CLICKBOX_T 4\n\n#define MAX_CTRLS 9\n#define CTRL_CHANNEL iChannel3\n#define GRN_MID 0.3\n\nstruct control {\n    int type;\n    vec4 bboxUV;\n    float value; \n    float value2; \n    bool mouseDown;\n    bool visible;\n    bool enabled;\n    float opacity;\n};\n    \n    \ncontrol[MAX_CTRLS] controls;\nint controlCount = 0;\n\nvec3 giResolution;\n\n\nvec2 uvToXY(vec2 uv) {\n    return uv * giResolution.y + giResolution.xy*.5;\n}\n\nvec2 xyToUV(vec2 xy) {\n    return (xy - giResolution.xy*.5) / giResolution.y;\n}\n\nint newControl(int type, vec4 bbox) {\n    controls[controlCount].type = type;\n    controls[controlCount].bboxUV = bbox;\n    controls[controlCount].mouseDown = false;\n    controls[controlCount].visible = true;\n    controls[controlCount].enabled = true;\n    controls[controlCount].opacity = 1.0;\n    return controlCount++;\n}\n\n\nvec4 getControl(int index, sampler2D sampler) {\n    vec4 bbox = controls[index].bboxUV;\n    vec2 midpoint = vec2(bbox[0] + bbox[2], bbox[1] + bbox[3]) * 0.5;\n    ivec2 ixy = ivec2(uvToXY(midpoint));\n    return texelFetch(sampler, ixy, 0);\n}\n\nvoid updateValue2(int index) {\n    int type = controls[index].type;\n    if (type != CLICKBOX_T) {\n    \tcontrols[index].value2 = 1. - controls[index].value;\n    }\n}\n\nvoid updateControls(sampler2D sampler) {\n    for (int i = 0 ; i < controlCount; i++) {\n        vec4 readout = getControl(i, sampler);\n        controls[i].value = readout[2];\n        controls[i].value2 = readout[0];\n        controls[i].mouseDown = readout[1] > GRN_MID;\n        float alphanorm = 1.;\n        if (controls[i].opacity > 0.) {\n            alphanorm = (readout[3] / controls[i].opacity);\n        }\n        controls[i].visible = alphanorm > 0.;\n        controls[i].enabled = alphanorm > .5;        \n        updateValue2(i);\n    }    \n}\n\nfloat getShapeNorm(int type) {\n    if (type == TOGGLE_BTN_T) {\n    \treturn 3.5;\n    } else if (type == PUSH_BTN_T) {\n    \treturn  1.5;\n    } else if (type == CLICKBOX_T) {\n    \treturn  100.;\n    } else {\n    \treturn 2.0;\n    }\n}\n\n// -1 to 1\nvec2 hitCoordsNormalized(int index, vec2 xy) {\n    vec4 bbox = controls[index].bboxUV;\n    vec2 midpoint = vec2(bbox[0] + bbox[2], bbox[1] + bbox[3]) * 0.5;\n    vec2 span = abs(vec2(bbox[0] - bbox[2], bbox[1] - bbox[3]));\n    vec2 uv = xyToUV(xy);\n \n    return (uv - midpoint) / (0.5 * span);\n}\n    \nfloat midpointDistNorm(int index, int type, vec2 xy) {\n    vec2 dr = hitCoordsNormalized(index, xy);\n    //return sqrt(dot(dr, dr));\n    float normpow = getShapeNorm(type);\n    float sumnorm = pow(abs(dr[0]), normpow) + pow(abs(dr[1]), normpow);\n    return pow(sumnorm, 1.0 / normpow);\n}\n\nfloat midpointAngle(int index, vec2 xy) {\n    vec2 dr = hitCoordsNormalized(index, xy);\n    \n    return acos(dr[0] / sqrt(dot(dr, dr))) * sign(dr[1]);\n}\n\nvec2 clickboxCoordsNorm(float value) {\n    return 2. * vec2(fract(value) - 0.5, floor(value) / 500. - 0.5);\n}\n\nfloat normCoordsToClickboxVal(vec2 dr) {\n    return clamp(dr[0] * 0.5 + 0.5, 0., 1.) + round(500. * clamp(dr[1] * 0.5 + 0.5, 0., 1.));\n}\n\nvoid mouseDownEvt(int index, vec4 mouse, int capturedIndex) {\n    //  mouseDown event:\n    switch (controls[index].type) {\n        case PUSH_BTN_T:\n        controls[index].value = 1.;\n        break;\n\n        case TOGGLE_BTN_T:\n        controls[index].value = 1. - controls[index].value;\n        break;\n\n        case CLICKBOX_T:\n\t    vec2 dr = hitCoordsNormalized(index, mouse.xy) / 2.;\n        controls[index].value = normCoordsToClickboxVal(dr);\n        controls[index].value2 = controls[index].value;\n        break;        \n    }\n}\n\nvoid mouseMoveEvt(int index, vec4 mouse, int capturedIndex, bool inBounds) {\n    // mouseMove event:\n    switch (controls[index].type) {\n        case PUSH_BTN_T:\n        controls[index].value = inBounds ? 1. : 0.;\n        break;\n\n        case SPINNER_T:\n        controls[index].value = midpointAngle(index, mouse.xy) / 3.14159;\n        break;\n\n        case CLICKBOX_T:\n\t    vec2 dr = hitCoordsNormalized(index, mouse.xy) / 2.;\n        controls[index].value2 = normCoordsToClickboxVal(dr);\n        break;        \n    }\n}\n\nvoid mouseUpEvt(int index, vec4 mouse, int capturedIndex) {\n    // mouseUp event:\n    switch (controls[index].type) {\n        case PUSH_BTN_T:\n        controls[index].value = 0.;\n        break;\n    }\n}\n\nint typeCheatSheet(int index);\n\nbool handleMouse(int index, vec4 mouse, int capturedIndex) {\n    float dist = midpointDistNorm(index, typeCheatSheet(index), mouse.xy);\n    bool capturable = capturedIndex == index || capturedIndex < 0;\n    if (mouse[2] > 0. && dist < 1. && controls[index].visible) {\n        if (controls[index].enabled && capturable) {\n            if (!controls[index].mouseDown) {\n                controls[index].mouseDown = true;\n\n                mouseDownEvt(index, mouse, capturedIndex);\n            } else {\n            \tmouseMoveEvt(index, mouse, capturedIndex, true);\n        \t}\n        }\n        return true;\n    } else {\n        if (controls[index].mouseDown) {\n            if (mouse[2] <= 0.) {\n                mouseUpEvt(index, mouse, capturedIndex);\n            } else {            \n                mouseMoveEvt(index, mouse, capturedIndex, false);\n            }\n        }        \n        \n        if (capturedIndex != index) {\n            controls[index].mouseDown = false;        \n        }\n        return false;\n    }            \n}\n\nvec4 processMouse(vec4 mouse) {\n    int capturedIndex = -1;\n    if (mouse[2] > 0.) {\n        for (int i = 0 ; i < controlCount; i++) {\n            if (controls[i].mouseDown) {\n                capturedIndex = i;\n            }\n        }\n    }\n    \n    bool handled = false;\n    for (int i = controlCount - 1 ; i >= 0; i--) {\n        handled = handleMouse(i, mouse, capturedIndex);\n        if (handled) {\n            break;\n        }\n    }\n    if (handled || capturedIndex >= 0) {\n        return vec4(mouse.xy, 0., 0.);\n    } else {        \n    \treturn mouse;\n    }\n}\n\nvec4 renderControls(vec2 fragCoord, vec4 mouse) {\n    vec4 pixel = vec4(0.);\n    for (int i = 0 ; i < controlCount; i++) {\n        float dist = midpointDistNorm(i, controls[i].type, fragCoord);\n        float mouseThickAdj = controls[i].mouseDown ? 0.07 : 0.;\n        \n        float alpha = 0.;\n        if (controls[i].visible) {\n            alpha = (controls[i].enabled? 1. : 0.5) * controls[i].opacity;\n        }\n        \n        // special casing handling invisible controls partly overlapping visible ones\n        if (alpha > 0. || pixel[3] <= 0.) {\n            if (dist <= 0.9 - mouseThickAdj) {\n                float mouseColor = GRN_MID + (controls[i].mouseDown ? 0.02 : -0.02);\n                pixel = vec4(controls[i].value2, mouseColor, controls[i].value, alpha);\n\n                if (controls[i].type == SPINNER_T) {\n                    if (dist > 0.5 && \n                        abs(midpointAngle(i, fragCoord) / 3.14159 - controls[i].value) < .1) {\n                        pixel = vec4(0., 0., 0., alpha);\n                    }\n                }\n\n                if (dist > 0.8 - mouseThickAdj - .1) {\n                    float delta = dist - (0.9 - mouseThickAdj);\n                    float blend = exp(-delta * delta * 500.);\n                    pixel = (1. - blend) * pixel * pixel[3] + vec4(0., 0., 0., alpha);\n                    pixel[3] = alpha;\n                }\n                \n            } else if (dist <= 1.1) {                \n                float blend = exp(-(dist - 0.9) * (dist - 0.9) * 100.);\n                if (dist < 0.9) blend = 1.0;\n                pixel = (1. - blend) * pixel + vec4(0., 0., 0., blend * alpha);\n            }            \n        }\n    }    \n    \n    return pixel;    \n}\n\nint visControl;\n//int kCtl;\nint alphaCtl;\nint betaCtl;\nint cCtl;\nint magCtl;\nint randCtl;\nint resetCtl;\n\nvoid defineYourControls()\n{\n    vec2 corner = xyToUV(vec2(giResolution[0], 0.));\n    visControl = newControl(TOGGLE_BTN_T, vec4(corner, corner - vec2(0.05, -0.05)));\n    \n    float pos = corner.x - 0.046;\n    alphaCtl = newControl(SPINNER_T, vec4(pos -= 0.1, -.4, pos + 0.1, -.5));\n    betaCtl = newControl(SPINNER_T, vec4(pos -= 0.1, -.4, pos + 0.1, -.5));\n    cCtl = newControl(SPINNER_T, vec4(pos -= 0.1, -.4, pos + 0.1, -.5));\n//    kCtl = newControl(SPINNER_T, vec4(pos -= 0.1, -.4, pos + 0.1, -.5));\n    magCtl = newControl(TOGGLE_BTN_T, vec4(pos -= 0.1, -.4, pos + 0.1, -.5));\n    randCtl = newControl(PUSH_BTN_T, vec4(pos -= 0.1, -.4, pos + 0.1, -.5));\n    resetCtl = newControl(PUSH_BTN_T, vec4(pos -= 0.1, -.4, pos + 0.1, -.5));\n}\n\n// this function is sadness and kludge but remarkably faster than the obvious thing,\n// at least on my integrated graphics laptop -- perhaps because handleMouse is so serial?\nint typeCheatSheet(int index) {\n\tif (index == randCtl || index == resetCtl) {\n        return PUSH_BTN_T;\n    } else if (index >= alphaCtl && index <= cCtl) {\n        return SPINNER_T;\n    } else {\n        return TOGGLE_BTN_T;\n    }\n}\n\nvoid configure(vec3 res) {\n    giResolution = res;        \n    defineYourControls();\n}\n\nvec4 configureAndUpdate(vec3 res, sampler2D sampler, vec4 mouse, bool init) {\n    configure(res);\n    if (!init) {\n    \tupdateControls(sampler);\n    } else {\n        // Some fun initial values\n        controls[alphaCtl].value = -0.2;    \n    }\n    \n    return processMouse(mouse);\n}","name":"Common","description":"","type":"common"}]}