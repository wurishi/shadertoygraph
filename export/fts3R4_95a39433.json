{"ver":"0.1","info":{"id":"fts3R4","date":"1621631716","viewed":100,"name":"Uncanny Thingy","username":"rimina","description":"I did this shader at my live stream on 22th of May 2021. I wanted to explore how to model with SDFs something more complex than a field of cubes.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["sdfmodelling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Copyright Â© 2021-2022 rimina.\n// All rights to the likeness of the visuals reserved.\n\n// Any individual parts of the code that produces the visuals is\n// available in the public domain or licensed under the MIT license,\n// whichever suits you best under your local legislation.\n\n// This is to say: you can NOT use the code as a whole or the visual\n// output it produces for any purposes without an explicit permission,\n// nor can you remix or adapt the work itself without a permission.*\n// You absolutely CANNOT mint any NFTs based on the Work or part of it.\n// You CAN however use any individual algorithms or parts of the Code\n// for any purpose, commercial or otherwise, without attribution.\n\n// *(In practice, for most reasonable requests, I will gladly grant\n//   any wishes to remix or adapt this work :)).\n\n\nconst float PIXELR = (0.5/1280.0);\nconst float E = 0.001;\nconst float FAR = 60.0;\nconst int STEPS = 64;\n\nconst vec3 FOG_COLOR = vec3(0.08, 0.08, 0.085);\nconst vec3 LIGHT_COLOR = vec3(0.8, 0.5, 0.8);\n\nconst float PI  = 3.14159265;\nconst float PHI = (sqrt(5.0)*0.5 + 0.5);\n\nvec3 glow = vec3(0.0);\n\nstruct Material{\n  vec3 l_col;\n  vec3 s_col;\n  float l_i;\n  float s_i;\n  float shiny;\n};\n\nMaterial getMaterial(){\n  Material m;\n  m.l_col = vec3(0.3, 0.5, 0.9);\n  m.s_col = vec3(0.5, 0.8, 1.0);\n  m.l_i = 0.6;\n  m.s_i = 0.4;\n  m.shiny = 8.0;\n  \n  return m;\n}\n\nMaterial getSkin(){\n  Material m;\n  m.l_col = vec3(0.8, 0.7, 0.4);\n  m.s_col = vec3(0.8, 0.7, 0.4);\n  m.l_i = 0.9;\n  m.s_i = 0.1;\n  m.shiny = 1.0;\n  \n  return m;\n}\n\nMaterial getHair(){\n  Material m;\n  m.l_col = vec3(0.2, 0.7, 0.8);\n  m.s_col = vec3(0.4, 0.8, 0.9);\n  m.l_i = 0.3;\n  m.s_i = 0.7;\n  m.shiny = 30.0;\n  \n  return m;\n}\n\nMaterial getEye(){\n  Material m;\n  m.l_col = vec3(0.1, 0.2, 0.1);\n  m.s_col = vec3(0.2, 0.5, 0.3);\n  m.l_i = 0.2;\n  m.s_i = 0.8;\n  m.shiny = 10.0;\n  \n  return m;\n}\n\nMaterial getLips(){\n  Material m;\n  m.l_col = vec3(3.0, 0.1, 0.6);\n  m.s_col = vec3(8.0, 0.2, 0.8);\n  m.l_i = 0.2;\n  m.s_i = 0.7;\n  m.shiny = 20.0;\n  \n  return m;\n}\n\nMaterial MATERIAL;\n\n//SOME FUNCTIONS FROM HG_SDF\n\n// Sign function that doesn't return 0\nfloat sgn(float x) {\n\treturn (x<0.0)?-1.0:1.0;\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n\treturn dot(p, n) + distanceFromOrigin;\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// Cylinder standing upright on the xz plane\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\n// Capsule: A Cylinder with round caps on both sides\nfloat fCapsule(vec3 p, float r, float c) {\n\treturn mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));\n}\n\n// Cone with correct distances to tip and base circle. Y is up, 0 is in the middle of the base.\nfloat fCone(vec3 p, float radius, float height) {\n\tvec2 q = vec2(length(p.xz), p.y);\n\tvec2 tip = q - vec2(0.0, height);\n\tvec2 mantleDir = normalize(vec2(height, radius));\n\tfloat mantle = dot(tip, mantleDir);\n\tfloat d = max(mantle, -q.y);\n\tfloat projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n\t\n\t// distance to tip\n\tif ((q.y > height) && (projected < 0.0)) {\n\t\td = max(d, length(tip));\n\t}\n\t\n\t// distance to base ring\n\tif ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n\t\td = max(d, length(q - vec2(radius, 0)));\n\t}\n\treturn d;\n}\n\n//https://iquilezles.org/articles/distfunctions\n//https://www.shadertoy.com/view/tdS3DG\nfloat fEllipsoid( vec3 p, vec3 r ){\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a){\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n//https://iquilezles.org/articles/distfunctions\nfloat opSmoothUnion( float d1, float d2, float k ){\n  float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n  return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k ){\n  float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n  return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\n// 3D noise function (IQ)\nfloat noise(vec3 p){\n\tvec3 ip = floor(p);\n    p -= ip;\n    vec3 s = vec3(7.0,157.0,113.0);\n    vec4 h = vec4(0.0, s.yz, s.y+s.z)+dot(ip, s);\n    p = p*p*(3.0-2.0*p);\n    h = mix(fract(sin(h)*43758.5), fract(sin(h+s.x)*43758.5), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\n//SCENE STARTS\n\n\nfloat scene(vec3 p){\n  MATERIAL = getMaterial();\n  \n  vec3 pp = p;\n  \n  float n = noise(p*(sqrt(5.0)*0.5 + 0.5)*2.5+iTime*0.25)*0.15;\n  \n  //HEAD & HAIR\n  vec3 head_offset = vec3(0.0, 1.0, 0.0);\n  float head = fSphere(pp-head_offset, 0.45);\n  \n  pp -= vec3(0.0, 1.1, -0.3);\n  pR(pp.yz, PI*0.25);\n  float hair = fEllipsoid(pp, vec3(0.63, 0.74, 0.4));\n  pp -= vec3(0.0, 0.5, 0.1);\n  pR(pp.yz, -PI*0.1);\n  hair = opSmoothUnion(hair, fEllipsoid(pp-vec3(0.0, 0.0, 0.1), vec3(0.53, 0.2, 0.2)), 0.25);\n  hair -= n;\n  pp = p;\n  \n  //FACE\n  //EYES\n  pp -= vec3(0.0, 0.95, 0.45);\n  pp.x = abs(pp.x)-0.15;\n  float socket = fEllipsoid(pp, vec3(0.05, 0.03, 0.05));\n  float eye = fEllipsoid(pp-vec3(0.0, 0.0, -0.08), vec3(0.05, 0.015, 0.05));\n  head = opSmoothSubtraction(socket, head, 0.09);\n  pp = p;\n  \n  //NOSE\n  pp -= head_offset;\n  float nose = fEllipsoid(pp-vec3(0.0, -0.18, 0.4), vec3(0.03, 0.035, 0.02));\n  head = opSmoothUnion(nose, head, 0.1);\n  pp = p;\n  \n  //LIPS\n  pp -= head_offset;\n  pp.x = abs(pp.x)-0.02;\n  float lips = fEllipsoid(pp-vec3(0.0, -0.27, 0.33), vec3(0.08, 0.06, 0.02));\n  pp = p;\n  \n  //NECK\n  float neck = fCapsule(pp, 0.15, 1.0);\n  head = opSmoothUnion(neck, head, 0.05);\n  \n  \n  //TORSO\n  vec3 torso_offset = vec3(0.0, -0.2, 0.0);\n  float torso = fEllipsoid(pp-torso_offset, vec3(0.65, 0.7, 0.5));\n  torso_offset = vec3(0.0, -1.4, 0.0);\n  torso = opSmoothUnion(torso, fEllipsoid(pp-torso_offset, vec3(0.75, 1.25, 0.66)), 0.05);\n  \n  //SKIRT\n  n = noise(p*3.0 + iTime*0.5)*0.1;\n  vec3 skirt_offset = vec3(0.0, -2.5, 0.0);\n  float skirt = fCone(pp-skirt_offset, 1.2, 2.9);\n  skirt -=n;\n  \n  //SHOULDERS\n  pR(pp.xy, PI*0.5);\n  vec3 shoulder_offset = vec3(0.2, 0.0, 0.0);\n  float shoulders = fCapsule(pp-shoulder_offset, 0.25, 0.54);\n  \n  pp.y = abs(pp.y)-1.0;\n  pR(pp.xy, PI*0.2);\n  \n  //ARMS\n  float arms = fCapsule(pp-vec3(0.01, 0.0, 0.0), 0.19, 0.3);\n  pR(pp.xy, -PI*0.5);\n  pR(pp.yz, -PI*0.2);\n  float hands = fCapsule(pp-vec3(-0.4, -0.5, 0.0), 0.16, 0.4);\n  arms = opSmoothUnion(arms, hands, 0.12);\n  \n  \n  //MATERIALS\n  if((head < torso && head < skirt && head < shoulders && head < arms && head < hair && head < eye && head < lips) ||\n    (arms < head && arms < skirt && arms < shoulders && arms < torso && arms < hair && arms < eye && arms < lips)){\n    MATERIAL = getSkin();\n  }\n  else if(hair < head && hair < torso && hair < skirt && hair < shoulders && hair < arms && hair < eye && hair < lips){\n    MATERIAL = getHair();\n  }\n  else if(eye < head && eye < hair && eye < torso && eye < skirt && eye < shoulders && eye < arms && eye < lips){\n    MATERIAL = getEye();\n  }\n  else if(lips < head && lips < hair && lips < eye && lips < torso && lips < skirt && lips < shoulders && lips < arms){\n    MATERIAL = getLips();\n  }\n  \n  glow += vec3(0.2, 0.8, 0.8) * 0.02 / (0.05 + abs(hair));\n  \n  head = min(head, hair);\n  head = opSmoothUnion(head, eye, 0.02);\n  head = opSmoothUnion(lips, head, 0.01);\n  \n  torso = opSmoothUnion(torso, head, 0.01);\n  torso = opSmoothUnion(torso, skirt, 0.25);\n  torso = opSmoothUnion(torso, shoulders, 0.2);\n  torso = opSmoothUnion(torso, arms, 0.14);\n  \n  return torso;\n}\n\n//SCENE ENDS\n\n//Enhanced sphere tracing algorithm introduced by Mercury\nfloat march(vec3 ro, vec3 rd){\n  float t = E;\n  float d = 0.0;\n\n  float omega = 1.0;//muista testata eri arvoilla! [1,2]\n  float prev_radius = 0.0;\n\n  float candidate_t = t;\n  float candidate_error = 1000.0;\n  float sg = sgn(scene(ro));\n\n  vec3 p = ro;\n\n\tfor(int i = 0; i < STEPS; ++i){\n\t\tfloat sg_radius = sg*scene(p);\n\t\tfloat radius = abs(sg_radius);\n\t\td = sg_radius;\n\t\tbool fail = omega > 1. && (radius+prev_radius) < d;\n\t\tif(fail){\n\t\t\td -= omega * d;\n\t\t\tomega = 1.;\n\t\t}\n\t\telse{\n\t\t\td = sg_radius*omega;\n\t\t}\n\t\tprev_radius = radius;\n\t\tfloat error = radius/t;\n\n\t\tif(!fail && error < candidate_error){\n\t\t\tcandidate_t = t;\n\t\t\tcandidate_error = error;\n\t\t}\n\n\t\tif(!fail && error < PIXELR || t > FAR){\n\t\t\tbreak;\n\t\t}\n\t\tt += d;\n    p = rd*t+ro;\n\t}\n  //discontinuity reduction\n  float er = candidate_error;\n  for(int j = 0; j < 6; ++j){\n    float radius = abs(sg*scene(p));\n    p += rd*(radius-er);\n    t = length(p-ro);\n    er = radius/t;\n\n    if(er < candidate_error){\n      candidate_t = t;\n      candidate_error = er;\n    }\n  }\n\tif(t <= FAR || candidate_error <= PIXELR){\n\t\tt = candidate_t;\n\t}\n\treturn t;\n}\n\nvec3 normals(vec3 p){\n  vec3 eps = vec3(E, 0.0, 0.0);\n  return normalize(vec3(\n    scene(p+eps.xyy) - scene(p-eps.xyy),\n    scene(p+eps.yxy) - scene(p-eps.yxy),\n    scene(p+eps.yyx) - scene(p-eps.yyx)\n  ));\n}\n\n//https://iquilezles.org/articles/fog\nvec3 fog(vec3 col, vec3 p, vec3 ro, vec3 rd, vec3 ld){\n  float dist = length(p-ro);\n\tfloat sunAmount = max( dot(rd, -ld), 0.0 );\n\tfloat fogAmount = 1.0 - exp( -dist*0.07);\n\tvec3  fogColor = mix(FOG_COLOR, LIGHT_COLOR, pow(sunAmount, 8.0));\n  return mix(col, fogColor, fogAmount);\n}\n\nvec3 shade(vec3 p, vec3 rd, vec3 ld){\n  vec3 n = normals(p);\n  \n  float l = max(dot(n, ld), 0.0);\n  float a = max(dot(reflect(ld, n), rd), 0.0);\n  float s = pow(a, MATERIAL.shiny);\n  \n  return l*MATERIAL.l_col*MATERIAL.l_i+s*MATERIAL.s_col*MATERIAL.s_i;\n  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 q = -1.0+2.0*uv;\n    q.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rt = vec3(0.0, -1.0, 0.0);\n\n    vec3 z = normalize(rt-ro);\n    vec3 x = normalize(cross(z, vec3(0.0, 1.0, 0.0)));\n    vec3 y = normalize(cross(x, z));\n\n    vec3 rd = normalize(mat3(x,y,z)*vec3(q, radians(60.0)));\n\n    vec3 col = FOG_COLOR;\n    float t = march(ro, rd);\n    vec3 p = rd*t+ro;\n\n    if(t <= FAR){\n    col += shade(p, rd, -z);\n    }\n\n    col += glow*0.2;\n\n    col = fog(col, p, ro, rd, -z);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}