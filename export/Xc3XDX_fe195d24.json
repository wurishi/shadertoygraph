{"ver":"0.1","info":{"id":"Xc3XDX","date":"1715079562","viewed":72,"name":"teststesteste","username":"gnomesort","description":"lut tonemap tests","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["teststesteste"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nBased on the awesome ACES Color Grading shader (https://www.shadertoy.com/view/Mdfcz7) developed by Mynx. \nI modified it so that in Buf A you can use a custom LUT PNG file. \nIn order to be able to import a custom LUT png to one of the iChannels on Shadertoy you need\nShadertoy Custom Textures Chrome Plugin.\n\nIf you need a custom PNG file there is a sample here: \nhttps://support.lightact-systems.com/wp-content/uploads/2018/06/LUTFromShadertoy.png\n\n\n*/\n\n/*ORIGINAL BELOW*/\n//  Description: Transform input image to linear space and apply the 3D LUT for grading.\n//               Input for the LUT is in ACESproxy space (12bit version).\n//               Works for post-exposure HDR renders, i.e. games with HDR rendering.\n\n#define LUT_SIZE 25.0\n#define LUT_WIDTH (LUT_SIZE * LUT_SIZE)\n#define PI 3.1415926535897932384626433832795\n\nconst float dim = 25.f;\n\nfloat softLightLog(float base, float blend, float center, float depth) {\n    \n    return base - (blend - center) * depth;\n}\n\n\nfloat linear2loga(float x, float a)\n{\n    float res = (log(x + a) - log(a))/(log(1.0 + a) - log(a));\n    //float res = 0.0;\n    return res;\n}\n\n\nfloat loga2linear(float x, float a)\n{\n    return exp(x*(log(x + a) - log(a)) + log(a)) - a;\n}\n\nfloat logc2linear(float x)\n{\n    if (x > 0.1496582)\n        return (exp(((x - 0.385537) / 0.2471896)*2.3025850929940456840179914546844) - 0.052272) / 5.555556;\n    else \n        return (x - 0.092809) / 5.367655;\n}\n\nfloat linear2logc(float x)\n{\n    if (x * 5.367655 + 0.092809 >0.1496582)\n        return 0.2471896 * log(x * 5.555556 + 0.052272) / log(10.0) + 0.385537;\n    else\n        return x * 5.367655 + 0.092809;\n}\n\n\nvec4 lookup_1_0(in vec4 textureColor, in sampler2D lookupTable) {\n    #ifndef LUT_NO_CLAMP\n        textureColor = clamp(textureColor, 0.0, 1.0);\n    #endif\n\n    //mediump float dim = 64.0;\n    mediump float v8 = sqrt(dim);\n    mediump float v63 = dim-1.0;\n    mediump float v0125 = 1.0/v8;\n    mediump float v512 = dim * v8;\n\n    mediump float blueColor = textureColor.b * v63;\n\n    mediump vec2 quad1;\n    quad1.y = floor(floor(blueColor) / v8);\n    quad1.x = floor(blueColor) - (quad1.y * v8);\n\n    mediump vec2 quad2;\n    quad2.y = floor(ceil(blueColor) / v8);\n    quad2.x = ceil(blueColor) - (quad2.y * v8);\n\n    highp vec2 texPos1;\n    texPos1.x = (quad1.x * v0125) + 0.5/v512 + ((v0125 - 1.0/v512) * textureColor.r);\n    texPos1.y = (quad1.y * v0125) + 0.5/v512 + ((v0125 - 1.0/v512) * textureColor.g);\n\n    #ifdef LUT_FLIP_Y\n        texPos1.y = 1.0-texPos1.y;\n    #endif\n\n    highp vec2 texPos2;\n    texPos2.x = (quad2.x * v0125) + 0.5/v512 + ((v0125 - 1.0/v512) * textureColor.r);\n    texPos2.y = (quad2.y * v0125) + 0.5/v512 + ((v0125 - 1.0/v512) * textureColor.g);\n\n    #ifdef LUT_FLIP_Y\n        texPos2.y = 1.0-texPos2.y;\n    #endif\n\n    lowp vec4 newColor1 = texture(lookupTable, texPos1);\n    lowp vec4 newColor2 = texture(lookupTable, texPos2);\n\n    lowp vec4 newColor = mix(newColor1, newColor2, fract(blueColor));\n    return newColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 image = texture(iChannel0, uv);\n    vec4 blend_logc = texture(iChannel2, uv);\n    \n    vec4 scaledLUT=vec4(0.0);\n    \n    if(fragCoord.x < LUT_WIDTH && fragCoord.y < LUT_SIZE){\n      vec2 uv_LUT = fragCoord.xy/vec2(LUT_WIDTH,LUT_SIZE);\n      scaledLUT=texture(iChannel1, uv_LUT);\n    }else{\n        scaledLUT=vec4(0.0);\n    }\n    \n    float a = 0.01;\n    float exposure = 3.0;\n    float depth = 0.5;\n    float center = 0.5;\n  \n    if (fragCoord.x < iMouse.x)\n    {        \n        vec3 image_lin = vec3(logc2linear(image.x),logc2linear(image.y),logc2linear(image.z));\n        \n        image_lin.x = image_lin.x * exposure;\n        image_lin.y = image_lin.y * exposure;\n        image_lin.z = image_lin.z * exposure;\n                \n        vec3 image_loga = vec3(linear2loga(image_lin.x, a),linear2loga(image_lin.y, a),linear2loga(image_lin.z, a));\n        \n        \n        vec3 blend_lin = vec3(logc2linear(blend_logc.x), logc2linear(blend_logc.y), logc2linear(blend_logc.z));\n        vec3 blend_loga = vec3(linear2loga(blend_lin.x, a),linear2loga(blend_lin.y, a),linear2loga(blend_lin.z, a));\n        //vec3 blend_loga = vec3(linear2logc(blend_lin.x),linear2logc(blend_lin.y),linear2logc(blend_lin.z));\n        \n        float lum = blend_loga.r * 0.3 + blend_loga.g * 0.4 + blend_loga.b * 0.3;\n        vec3 tmap_loga = vec3( softLightLog(image_loga.x, lum, center, depth),\n                               softLightLog(image_loga.y, lum, center, depth),\n                               softLightLog(image_loga.z, lum, center, depth) );\n        \n        vec3 tmap_lin = vec3(loga2linear(tmap_loga.x, a), \n                             loga2linear(tmap_loga.y, a), \n                             loga2linear(tmap_loga.z, a));\n        vec3 tmap_logc = vec3(linear2logc(tmap_lin.x), linear2logc(tmap_lin.y), linear2logc(tmap_lin.z));\n        image.xyz = tmap_logc.xyz;\n    } else {\n    }\n    \n    image.xyz = (lookup_1_0(image, iChannel1)).xyz;\n    \n    \n    fragColor = vec4(image.xyz,1.0);\n}","name":"Image","description":"","type":"image"}]}