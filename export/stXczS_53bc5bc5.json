{"ver":"0.1","info":{"id":"stXczS","date":"1648200928","viewed":180,"name":"Halton Sequence-AW","username":"alenwesker","description":"Test halton sequence","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["halton"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define GLSL //If you are using HLSL, just comment this line\n\n#ifdef GLSL\n\n#define float2 vec2\n#define inline \n#define frac fract\n#define static\n#define float_array_begin float[](\n#define float_array_end )\n#define fmod mod\nint ToInt(float f){return int(f);}\n#else\n\n#define float_array_begin {\n#define float_array_end }\n\nint ToInt(float f){return (int)(f);}\n\n#endif\n\n// Jimenez's \"Interleaved Gradient Noise\"\ninline float JimenezNoise( const float2 xyPixelPos )\n{\n\treturn frac( 52.9829189 * frac( dot( xyPixelPos, float2( 0.06711056, 0.00583715 ) ) ) );\n}\n\n\n\nfloat Halton(int b, int i)\n{\n    float r = 0.0;\n    float f = 1.0;\n    while (i > 0) {\n        f = f / float(b);\n        r = r + f * float(i % b);\n        i = int(floor(float(i) / float(b)));\n    }\n    return r;\n}\n\n//To avoid int calculation--which maybe slow on some deprecated hardware, try to generate them in advance with python.\nstatic const float k_HaltonBase2_32[] = float_array_begin\n    0.5f,\n    0.25f,\n    0.75f,\n    0.125f,\n    0.625f,\n    0.375f,\n    0.875f,\n    0.0625f,\n    0.5625f,\n    0.3125f,\n    0.8125f,\n    0.1875f,\n    0.6875f,\n    0.4375f,\n    0.9375f,\n    0.03125f,\n    0.53125f,\n    0.28125f,\n    0.78125f,\n    0.15625f,\n    0.65625f,\n    0.40625f,\n    0.90625f,\n    0.09375f,\n    0.59375f,\n    0.34375f,\n    0.84375f,\n    0.21875f,\n    0.71875f,\n    0.46875f,\n    0.96875f,\n    0.015625\nfloat_array_end;\n\nstatic const float k_HaltonBase3_32[] = float_array_begin\n    0.3333333333333333f,\n    0.6666666666666666f,\n    0.1111111111111111f,\n    0.4444444444444444f,\n    0.7777777777777778f,\n    0.2222222222222222f,\n    0.5555555555555556f,\n    0.8888888888888888f,\n    0.037037037037037035f,\n    0.37037037037037035f,\n    0.7037037037037037f,\n    0.14814814814814814f,\n    0.48148148148148145f,\n    0.8148148148148148f,\n    0.25925925925925924f,\n    0.5925925925925926f,\n    0.9259259259259259f,\n    0.07407407407407407f,\n    0.4074074074074074f,\n    0.7407407407407407f,\n    0.18518518518518517f,\n    0.5185185185185185f,\n    0.8518518518518519f,\n    0.2962962962962963f,\n    0.6296296296296297f,\n    0.9629629629629629f,\n    0.012345679012345678f,\n    0.345679012345679f,\n    0.6790123456790124f,\n    0.12345679012345678f,\n    0.4567901234567901f,\n    0.7901234567901234f\nfloat_array_end;\n\n\nfloat2 Halton2DRandom32(float2 v){\n    float2 index = abs(floor(fmod(v, float2(32.0f, 32.0f))));\n    float r1 = k_HaltonBase2_32[ToInt(index.x)];\n    float r2 = k_HaltonBase3_32[ToInt(index.y)];\n    return float2(r1, r2);\n}\n\n\nfloat2 Halton2DRandom32Jitter(float2 v){\n    \n    float jitter = JimenezNoise(v);\n\n    float2 moded = fmod(v + float2(jitter, jitter), float2(32.0f, 32.0f) );\n    float2 index = abs(floor(moded));\n    \n    float retx = k_HaltonBase2_32[int(index.x)];\n    float rety = k_HaltonBase3_32[int(index.y)];\n    \n    return float2(retx, rety);\n}\n\nfloat2 SimpleCartesian2Polar(float2 c)\n{\n    float2 x=c - float2(-0.2,-0.2); // Move the coord a little to concentrate to a nicer part\n    float radius=length(x);\n    float angle=atan(x.y / x.x);\n    return float2(radius, angle);\n}\n\nfloat2 Halton2DRandom32Polar(float2 v, float2 resolution){\n    \n    float2 polar = SimpleCartesian2Polar(v);\n\n    float2 moded = fmod(polar * resolution.xy, float2(32.0f, 32.0f) );\n    float2 index = abs(floor(moded));\n    \n    float retx = k_HaltonBase2_32[int(index.x)];\n    float rety = k_HaltonBase3_32[int(index.y)];\n    \n    return float2(retx, rety);\n}\n\nfloat2 Halton2DRandom32Blend(float2 v, float2 resolution){\n    return Halton2DRandom32Polar(Halton2DRandom32Jitter(v) * 32.0f, resolution.xy);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 halton = vec2(0.0f,0.0f);\n    if(uv.x < 0.5)\n    {\n        if(uv.y > 0.5)\n            halton = Halton2DRandom32(fragCoord);\n        else\n            halton = Halton2DRandom32Jitter(fragCoord);  //You can see, this one is much better\n    }\n    else\n    {\n        if(uv.y > 0.5)\n            halton = Halton2DRandom32Blend(fragCoord, iResolution.xy);  //Wow, this one is good; percetable patterns gone.\n        else\n            halton = Halton2DRandom32Polar(fragCoord, iResolution.xy);  //This one is weird\n    }\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec3 col = vec3(halton.xy, 0);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}