{"ver":"0.1","info":{"id":"XccfR7","date":"1732844324","viewed":21,"name":"GLSL_TEST9","username":"changlezeng","description":"TEST9","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["test9"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdParallelogram( in vec2 p, float wi, float he, float sk )\n{\n    vec2 e = vec2(sk, he);\n    p = (p.y < 0.0) ? -p : p; // Reflect for symmetry along the X-axis\n    vec2 w = p - e; w.x -= clamp(w.x, -wi, wi);\n    vec2 d = vec2(dot(w, w), -w.y);\n    float s = p.x * e.y - p.y * e.x;\n    p = (s < 0.0) ? -p : p;\n    vec2 v = p - vec2(wi, 0); v -= e * clamp(dot(v, e) / dot(e, e), -1.0, 1.0);\n    d = min(d, vec2(dot(v, v), wi * he - abs(s)));\n    return sqrt(d.x) * sign(-d.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    float t = iTime;\n    \n    // Parameters for the parallelogram\n    float wi = 0.06; // Width\n    float he = 0.1;  // Height\n    float sk = 0.03; // Skew\n    \n    float copies = 200.0; // Number of copies\n    float minDist = 1e5; // Initialize minimum distance\n    float minDist1 = 1e5;\n    \n    for (int i = 0; i < int(copies); i++)\n    {\n        // Offset positions for multiple parallelograms\n        vec2 p = uv - vec2(float(i) * 0.2  - 0.1 * t * 0.5, 0.35);\n        \n        vec2 p1 = uv - vec2(float(i) * 0.2 - 0.1 * t * 0.5 , 0.8);\n        \n        \n        // Calculate distances for both original and mirrored parallelograms\n        float dist1 = sdParallelogram(p, wi, he, sk);\n        float dist2 = sdParallelogram(vec2(p.x,-p.y -0.2), wi, he, sk);\n        float dist3 = sdParallelogram(p1, wi, he, sk);\n        float dist4 = sdParallelogram(vec2(p1.x,-p1.y -0.2), wi, he, sk);\n\n        // Update minimum distance\n        minDist = min(minDist, min(dist1, dist2));\n        minDist1 = min(minDist1, min(dist3, dist4));\n    }\n\n    // Determine color based on minimum distance\n    vec3 col = minDist > 0.0 && minDist1 > 0.0? vec3(t * 0.1, sin(t), t * 0.1) : vec3(t * 0.1);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}