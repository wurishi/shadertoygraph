{"ver":"0.1","info":{"id":"mlBXDd","date":"1676778049","viewed":135,"name":"tetradic_harmony","username":"ford442","description":"from digitonaut\non github","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["glsl"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// --------[ Original ShaderToy begins here ]---------- //\nmat2 rot(float x) {\n    return mat2(cos(x), sin(x), -sin(x), cos(x));\n}\n\nfloat half_tile(vec2 p, float k) {\n    p.x -= 0.5;\n    vec2 a = abs(p);\n    float r1 = max(abs(p.x + 0.5), a.y) - 0.25;\n    float r2 = length(vec2(p.x + 0.5, a.y)) - 0.25;\n    float r = mix(r1, r2, k);\n    vec2 s = (vec2(p.x, a.y) + vec2(0.25, 0.0)) * rot(3.141592 * 0.25);\n    r = min(r, max(abs(s.x - 0.1) - 0.1, abs(s.y) - 0.01));\n    return r;\n}\n\nfloat inner_tile(vec2 p) {\n    p.x -= 0.5;\n    return 0.23 - max(abs(p.x + 0.5), abs(p.y));\n}\n\nfloat tile(vec2 p) {\n    p += vec2(0.5, -0.5);\n    vec2 a = abs(p);\n    float d = max(max(a.x, a.y) - 0.5, 0.48 - max(a.x, a.y));\n    p.x += 0.5;\n    p.y += 0.5;\n\td = min(d, half_tile(p, 0.0));\n    p.x -= 1.0;\n    p.y -= 1.0;\n    p.y = -p.y;\n    p.x = -p.x;\n    d = min(d, half_tile(p, 1.0));\n    return d;\n}\n\nfloat rep_tile(vec2 p) {\n\tfloat d = 1000.0;\n    d = min(d, tile(p));\n    p.x = - p.x;\n    p.y += 1.0;\n    d = min(d, tile(p));\n    return d;\n}\n\nfloat map(vec3 p) {\n\tvec3 a = abs(p);\n    float d = -max(a.x - 2.0, a.y - 1.0);\n    float az = (fract(p.z / 2.0) - 0.5) * 2.0;\n    d = min(d, max(abs(p.x - 1.0), abs(az - 0.25)) - 0.25);\n    d = min(d, max(abs(p.x + 1.0), abs(az + 0.25)) - 0.25);\n    float bz = (fract((p.z + 1.0) / 2.0) - 0.5) * 2.0;\n    d = min(d, max(abs(abs(p.y) - 1.0), abs(bz)) - 0.25);\n    return d;\n}\n\nvec3 normal(vec3 p)\n{\n\tvec3 o = vec3(0.0001, 0.0, 0.0);\n    return normalize(vec3(map(p+o.xyy) - map(p-o.xyy),\n                          map(p+o.yxy) - map(p-o.yxy),\n                          map(p+o.yyx) - map(p-o.yyx)));\n}\n\nfloat trace(vec3 o, vec3 r) {\n    float t = 0.0;\n    for (int i = 0; i < 64; ++i) {\n\t\tt += map(o + r * t) * 0.7;\n    }\n    return t;\n}\n\nfloat thetex(vec2 p, float t) {\n    p *= 4.0;\n    vec2 pa = p - vec2(floor(mod(t, 2.0)), floor(mod(t, 3.0)));\n    pa *= rot(3.141592 * 0.5 * floor(mod(t, 5.0)));\n    vec2 s = mod(floor((pa + vec2(0.0, 3.0)) / 3.0), 2.0) * 2.0 - 1.0;\n    pa = (fract(pa / 3.0) - 0.5) * 3.0;\n    pa *= s.yx;\n\tfloat d = rep_tile(pa);\n    d = min(d, abs(pa.x) - 0.02);\n    d = max(d, 0.0);\n    d = 1.0 / (1.0 + d * d * 10000.0);\n    return d;\n}\n\nfloat vectex(vec3 p, float t) {\n    float r = max(thetex(p.xy, t), thetex(p.xz, t + 1.0));\n    return max(r, thetex(p.yz, t + 2.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 r = normalize(vec3(uv, 1.0 - dot(uv, uv) * 0.2));\n    vec3 o = vec3(0.0, -0.1, 1.0 + iTime + sin(3.41592 * iTime) * 0.12);\n\n    float rt = clamp(fract(iTime), 0.0, 1.0);\n    float rtt = clamp(fract(iTime), 0.0, 1.0);\n    r.yz *= rot(sin(1.0 + iTime + sin(3.41592 * iTime) * 0.12) * 0.12);\n\n    float t = trace(o, r);\n    vec3 w = o + r * t;\n    vec3 n = normal(w);\n    float aoc = map(w + n * 0.3);\n\n    float gt = 0.0;\n\n    vec3 k = vec3(vectex(w, gt)) * vec3(1.0, 1.0, 0.5);\n    \n    vec3 col = vec3(0.0);\n    col += k * 3.0 + (1.0 - k) * vec3(0.0, 0.25, 0.25);\n    col += vec3(1.0, 0.0, 0.0) * abs(n.y);\n    col *= 1.0 / (1.0 + pow(t * 0.4, 4.0));\n    col *= mix(0.1, 1.0, aoc);\n    \n    fragColor = vec4(sqrt(col), 1.0);\n}","name":"Image","description":"","type":"image"}]}