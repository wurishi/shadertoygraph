{"ver":"0.1","info":{"id":"NtB3Wc","date":"1624813357","viewed":144,"name":"Circle Overlap Pattern","username":"DrDesten","description":"Inspired by a video from \"Art of Code\"","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["circles","colorful","trippy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Controls (Play with these)\n//////////////////////////////////////////////////////////////////\n#define PROXIMITY_CHECK 2\n#define GRID_SIZE 35.\n\n#define SPEED 0.3\n#define WAVE_SIZE 3.\n\n#define MAX_RADIUS 1.8\n#define MIN_RADIUS 0.03\n\n#define ROTATION_SPEED .01\n\n\n// Constants\n#define PI 3.14159265359\n\nfloat circle(vec2 p, float r, vec2 c) {\n    vec2 d = p - c;\n    return step(dot(d, d), r*r);\n}\nfloat circle(vec2 p, float r, vec2 c, vec2 px) {\n    vec2 d = p - c;\n    return step(dot(d, d), r*r);\n}\n\nstruct CameraTransform {\n    mat2  rot;\n    float zoom;\n};\n\nCameraTransform calculateCameraTransform( float time ) {\n    float ang = PI * ROTATION_SPEED * time;\n    float s   = sin(ang), c = cos(ang);\n    \n    return CameraTransform(\n        mat2(c, s, -s, c),\n        sin(time * .3) * .2 + 1.\n    );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv  = (fragCoord - iResolution.xy * .5)/iResolution.x;\n    \n    CameraTransform trans = calculateCameraTransform( iTime );\n    float deltaZoom = (\n        calculateCameraTransform(iTime - 0.1).zoom -\n        calculateCameraTransform(iTime + 0.1).zoom\n    ) / 0.2;\n    \n    /* Add Lens Distorsion */ {\n        float mag = length(uv);\n        vec2  dir = normalize(uv);\n        \n        mag -= pow(mag, 2.) * deltaZoom * 10.;\n\n        uv = mag * dir;\n    } //*/\n    \n    uv  = trans.rot * uv;\n    uv *= trans.zoom;\n    \n    vec2 guv = fract(uv * GRID_SIZE) - 0.5;\n    vec2 gid = floor(uv * GRID_SIZE);\n    \n    float sinArgument = iTime * SPEED + length(uv * WAVE_SIZE);\n    float radius      = sin(sinArgument) * .5 + .5;\n    \n    //radius            = fract(sin(sinArgument)); // This creates an interesting Effect\n    \n    radius            = radius * (MAX_RADIUS - MIN_RADIUS) + MIN_RADIUS;\n \n    vec3 col = vec3(0);\n    \n    float circles = 0.;\n    for (int x = -PROXIMITY_CHECK; x <= PROXIMITY_CHECK; x++) {\n        for (int y = -PROXIMITY_CHECK; y <= PROXIMITY_CHECK; y++) {\n            \n            vec2 relativeUV = guv + vec2(x, y);\n            \n            circles += circle(vec2(0), radius, relativeUV);\n        \n        }\n    }\n    \n    vec3 tint = vec3(0.97, 1, 0.9);\n    \n    col.r = mod(circles, 2. ) / 1. * tint.r;\n    col.g = mod(circles, 2.5) / 1. * tint.g;\n    col.b = mod(circles, 3. ) / 1. * tint.b;\n   \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}