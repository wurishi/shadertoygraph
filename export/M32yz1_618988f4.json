{"ver":"0.1","info":{"id":"M32yz1","date":"1727000847","viewed":14,"name":"Another Hexagonal animation","username":"jcponcemath","description":"Trying another animation with hexagons. Not what I was looking for, but I still like it :) ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["animation","hexagons"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Function to convert HSV to RGB\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1, centered at the screen)\n    vec2 uv = ( fragCoord - 0.5 * iResolution.xy ) / iResolution.y;\n    \n    uv *= 65.0;\n    \n    // Parameters for the polar curve\n    float n = 50.0;\n    float k = 2.5;\n    float m = 3.0;\n    float t = iTime*0.025; // Time variable, equivalent to t = [0, 2*pi]\n\n    // Convert from Cartesian to polar coordinates\n    float r = length(uv);                  // Radius\n    float theta = atan(uv.y, uv.x);        // Angle (polar angle)\n    \n    // Initialize the color for combining multiple curves\n    vec3 finalColor = vec3(0.0);\n\n    // Loop over the sequence of curves, with different offsets in `j`\n    for (float j = 1.0; j <= 30.0; j += 1.0) {\n        // Shift the angle by `j * t`\n        float shiftedTheta = theta + j * t;\n\n        // Calculate the polar curve equation for the current `j`\n        float cosPart = pow(cos(m * shiftedTheta / 2.0), n);\n        float sinPart = pow(sin(m * shiftedTheta / 2.0), n);\n        float curve = pow(1.0 / (cosPart + sinPart), 1.0 / (k * n));\n\n        // Define the thickness of the curve line\n        float thickness = 0.3;\n\n        // Check if the current pixel lies on the polar curve\n        float lineColor = smoothstep(thickness, 0.0, abs(r - j * curve)); \n\n        // Assign a unique color for each curve using HSV (Hue varies with `j`)\n        vec3 hsvColor = hsv2rgb(vec3(j / 30.0, 1.0, 1.0)); // Hue changes with `j`\n        \n        // Add the current curve's color contribution\n        finalColor += lineColor * hsvColor;\n    }\n\n    fragColor = vec4(finalColor, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}