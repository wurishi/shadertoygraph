{"ver":"0.1","info":{"id":"stS3Rz","date":"1623212301","viewed":310,"name":"Angle Ruler / Gauge","username":"sketchpunk","description":"Wanted a way to visualize selected angles for a rotation widget I want to make.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["lines","radial"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI          3.14159265359\n#define PI2         6.28318530718\n#define PI2_INV     0.15915494309\n#define DEG2RAD     0.01745329251  // PI / 180\n\nvec2 up_coord( vec2 fragCoord ){\n    vec2 uv = fragCoord / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec2 rtn = uv * 2.0 - 1.0; // Remape to -1, 1\n    //rtn.y = -rtn.y;            // Flip Y, so positive is up\n    return rtn;\n}\n\nfloat sdfSegment( vec2 p, vec2 a, vec2 b ){\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat ring( vec2 coord, float outer, float inner ){ \n    float radius\t= dot( coord, coord );\n    float dxdy \t\t= fwidth( radius );\n    return\tsmoothstep( inner - dxdy, inner + dxdy, radius ) - \n            smoothstep( outer - dxdy, outer + dxdy, radius );\n}\n\n// https://www.shadertoy.com/view/XtXyDn\nfloat arc( vec2 uv, vec2 up, float angle, float radius, float thick ){\n    float hAngle = angle * 0.5;\n\n    // vector from the circle origin to the middle of the arc\n    float c = cos( hAngle );\n    \n    // smoothing perpendicular to the arc\n    float d1 = abs( length( uv ) - radius ) - thick;\n    float w1 = 1.5 * fwidth( d1 ); // proportional to how much d1 change between pixels\n    float s1 = smoothstep( w1 * 0.5, -w1 * 0.5, d1 ); \n\n    // smoothing along the arc\n    float d2 = dot( up, normalize( uv ) ) - c;\n    float w2 = 1.5 * fwidth( d2 ); // proportional to how much d2 changes between pixels\n    float s2 = smoothstep( w2 * 0.5, -w2 * 0.5, d2 ); \n\n    // mix perpendicular and parallel smoothing\n    return s1 * ( 1.0 - s2 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 c_uv = up_coord( fragCoord );\n    \n    //-------------------------------------------\n    // SETUP\n    float inc        = radians( 2.0 );\n    float steps      = PI2 / inc;                       // 36 steps \n    float frag_angle = atan( c_uv.y, c_uv.x );          // Angle of Fragment from Center\n    float grad_angle = fract( frag_angle * PI2_INV );   // 0:360 mapped to 0:1\n\n    float a_step     = steps * grad_angle;              // Divide the Gradient by the number of steps, Gives whole+fract value\n    float grad_step  = fract( a_step );                 // For each angle step, get a 0:1 Mapping\n\n    // Snap Step to next whole number\n    float snap_step  = ( grad_step >= 0.5 )? ceil( a_step ) : floor( a_step ); // round doesn't work\n    float snap_angle = snap_step * inc;   // Get the Center Angle of the Sector\n    vec2 dir         = vec2(              // Compute Direction, Normalized by default\n        cos( snap_angle ),\n        sin( snap_angle )\n    );\n\n    // Set Different Lengths for different increments\n    float len = 0.93;\n    if( mod( snap_step, 5.0 ) <= 0.9999 )  len = 0.87;\n    if( mod( snap_step, 45.0 ) <= 0.9999 ) len = 0.8;\n\n    // Get pixel's distance from Line Segment\n    float thick = 0.002;\n    float d     = sdfSegment( c_uv, dir * len, dir * 1.0 ) - thick;\n\n    float fw = fwidth( c_uv.x );                // Apply Anti-Alias to Lines\n    d = 1.0 - clamp( d / fw, 0.0, 1.0 );\n\n    d *= 1.0 - step( 0.98, length( c_uv ) );    // Mask out any lines outside of ring radius\n\n    //----------------------------------------------\n    // Draw angle 45 to 135\n    float rad_spread = radians( 90.0 ); // Total Angle from Start to finish\n    float rad_center = radians( 90.0 ); // Angle of the center of the arc wanting to draw\n    vec2  rad_dir    = vec2( cos(rad_center), sin(rad_center ) ); // Compute Direction of that center angle\n\n    d = max( d, arc( c_uv, rad_dir, rad_spread, 0.58, 0.42 ) * 0.3 );\n\n    //----------------------------------------------\n    d = max( d, ring( c_uv, 0.98, 0.92 ) );\n    \n    //-------------------------------------------\n    fragColor = vec4( vec3( d ), 1.0 );\n}","name":"Image","description":"","type":"image"}]}