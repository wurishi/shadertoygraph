{"ver":"0.1","info":{"id":"Ddlyzr","date":"1686522650","viewed":83,"name":"Toon HSV Simplify - NatLab","username":"NatShadLab","description":"Simplify the input by converting it into HSV, stepping it, then converting it back to RGB","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["toon","simplify"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n//Toon Simplify Function\nvec3 ToonSimplify( vec3 c, float steps){\n    //Toon Simplify\n    //steps = 3.;\n    \n    vec3 hsvcol = rgb2hsv(c);\n    hsvcol.x = round(hsvcol.x * steps* 2.)/(steps*2.);\n    hsvcol.y = round(hsvcol.y * steps)/steps;\n    hsvcol.z = round(hsvcol.z * steps)/steps;\n    c = hsv2rgb(hsvcol);\n    return c;\n}\n\nvec3 softligth( vec3 x, vec3 y){\n    vec3 result = 2.*x*y + x*x*(1.-2.*y);\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float size = .125;\n    size = 1. - floor(fract(iTime * .5 * size) / size) * size;\n    vec2 uv = floor(fragCoord * size)/ size / iResolution.xy;\n    vec2 uv2 =  ((floor(fragCoord * size)/ size)-iResolution.xy)/iResolution.y;\n    vec2 uvX = uv;\n    vec2 uvY = uv;\n    \n    uvX.x -= 1. / iResolution.y;\n    uvY.y -= 1. / iResolution.y;\n\n    vec3 tex0 = texture(iChannel0, uv).xyz;\n    vec3 tex1 = texture(iChannel0, uvX).xyz;\n    vec3 tex2 = texture(iChannel0, uvY).xyz;\n    \n\n    \n    vec3 nor;\n    nor.x = tex1.x - tex0.x;\n    nor.y = tex2.x - tex0.x;\n    nor.z = pow(1.-((nor.x * nor.x)+(nor.y * nor.y)),.5);\n    nor.xy *= 100.;\n    nor = normalize(nor);\n    \n    \n    //Toon Steps\n    float steps = 8.;\n    //Animate Steps\n    steps = 2. + floor(fract(iTime*.25/steps)*steps);\n    \n    float speed = .0618;\n    float time = ToonSimplify(vec3(iTime * speed), steps).x;\n    \n    //Toon Simplify Normals\n    nor = normalize(ToonSimplify(nor, steps));\n    \n    vec3 normalmap = vec3(.5) * ( vec3(1.) +nor);\n    \n    vec3 curv = texture(iChannel2, uv).xyz;\n    float h = texture(iChannel1, uv2).x;\n    \n    //Toon Simplify Curvature and Height maps\n    curv = ToonSimplify(curv, steps);\n    h = ToonSimplify(vec3(h), steps).x;\n    \n    vec3 cam = vec3(0.,0.,-1.);\n    \n    \n    //BaseColor\n    vec3 col = vec3(0.514,0.820,0.380);\n    col = hsv2rgb(vec3(rgb2hsv(col).x + time, rgb2hsv(col).y, rgb2hsv(col).z));\n    col = mix(1.- col,col * col, h);\n    //col = mix(col * mix(.5,1.,h), vec3(1.), pow(h,1.618));\n    \n    col = mix(col, softligth(col, vec3(sqrt(h))), .618);\n    col = mix(col, softligth(col, vec3(.5+ .5*nor.y)), 1.618); \n    col = mix(col, softligth(col, curv.xyz), 1.618);    \n    float gloss = mix(0., 1.618, clamp(length(col),0.,1.));\n    \n    vec3 dirlight = normalize(vec3(sin(time)*.5,cos(iTime)*.5,2.5));\n    float lightstr = 1.;    \n    float dirdif = pow(clamp(mix(.5,1.,dot(nor, dirlight)),0.,1.),gloss) * lightstr * length(col);\n    float spec = pow(clamp(dot(nor, normalize(mix(cam,dirlight,.5))),0.,1.),gloss) * lightstr *  length(col);\n    \n    float shades = dirdif + spec;\n    \n    \n    //Toon Simplify Colors\n    col = ToonSimplify(col, steps);\n    \n    shades = ToonSimplify(vec3(shades), steps).x;\n    \n    dirdif = ToonSimplify(vec3(dirdif), steps).x;\n    spec = ToonSimplify(vec3(spec), steps).x;\n    \n    vec3 speccol = col * spec;\n    \n    col = mix(col * dirdif + speccol, vec3(1.),clamp(shades-1.,0.,1.));\n    \n    //col = vec3(curv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y;\n    vec3 tex = texture(iChannel1, uv).xyz;\n    \n    fragColor = vec4(tex,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"float HeightMap( vec2 p ){\n\treturn texture(iChannel0, p).x;\n}\nfloat Curve( vec2 p, vec2 o ){\n\tfloat a = HeightMap(p+o);\n\tfloat b = HeightMap(p-o);\n\treturn -a - b;\n}\nfloat CurvatureMap( vec2 p, float r ){\n\tconst float q = 8.0; // sample quality\n\tfloat s = r/q;\n\tfloat H = HeightMap(p)*2.0;\n\tfloat v = 0.0;\n\tvec2 o;\n\tfor( o.x = -q; o.x < q; o.x++ )\n\tfor( o.y = -q; o.y < q; o.y++ ){\n\t\tfloat c = Curve(p, o*s);\n\t\tv += (H + c) * ((r-length(o*s)) / r);\n\t}\n\treturn v/(q*q);\n}\n\nvoid mainImage( out vec4 oFragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y;\n\tfloat c;\n    float s = 4.;\n\tc += CurvatureMap(uv, s/iResolution.y)*8.0; // sharp curvature\n\tc += CurvatureMap(uv, 2.*s/iResolution.y)*4.0; // sharp curvature\n\tc += CurvatureMap(uv, 4.*s/iResolution.y)*2.; // sharp curvature\n    oFragColor.rgb = vec3(.5 + c );\n\toFragColor.a = 1.0;\n}\n","name":"Buffer B","description":"","type":"buffer"}]}