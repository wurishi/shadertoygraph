{"ver":"0.1","info":{"id":"XsjBRm","date":"1547047095","viewed":4182,"name":"Candle Doodle","username":"BigWIngs","description":"Candle flames seem to be all the rage lately. I had this candle doodle lying around from the shadertoy compo two years ago. Code is a mess but I thought it'd make a nice addition to all the flames we are seeing lately.","likes":83,"published":1,"flags":0,"usePreview":0,"tags":["flame","candle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Candle by Martijn Steinrucken aka BigWings - 2019\n// countfrolic@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Code is horrible. This was used as a scratchpad for this effect:\n// https://www.shadertoy.com/view/MsSBD1\n//\n// Use these to change the effect\n\n#define INVERTMOUSE -1.\n\n#define MAX_STEPS 100\n#define MIN_DISTANCE 0.1\n#define MAX_DISTANCE 10.\n#define RAY_PRECISION 0.01\n\n#define S(x,y,z) smoothstep(x,y,z)\n#define B(x,y,z,w) S(x-z, x+z, w)*S(y+z, y-z, w)\n#define sat(x) clamp(x,0.,1.)\n#define SIN(x) sin(x)*.5+.5\n#define CANDLE_HEIGHT 10.\n#define FLAMECOL vec3(.99, .6, .35)\n#define FLAMEBLUE vec3(.1, .1, 1.)\n#define CANDLECOL  vec3(.2, .5, .2)\n\n#define BG_STEPS 20.\n#define BOKEH_SIZE .04\n\n\nconst vec3 lf=vec3(1., 0., 0.);\nconst vec3 up=vec3(0., 1., 0.);\nconst vec3 fw=vec3(0., 0., 1.);\n\nconst float halfpi = 1.570796326794896619;\nconst float pi = 3.141592653589793238;\nconst float twopi = 6.283185307179586;\n\nvec2 m; // mouse\n\nvec3 bg; // global background color\n\nfloat N( float x ) { return fract(sin(x)*5346.1764); }\nfloat N2(float x, float y) { return N(x + y*23414.324); }\nfloat LN(float x) {return mix(N(floor(x)), N(floor(x+1.)), fract(x));}\n\nfloat N21(vec2 p) {\n\tvec3 a = fract(vec3(p.xyx) * vec3(213.897, 653.453, 253.098));\n    a += dot(a, a.yzx + 79.76);\n    return fract((a.x + a.y) * a.z);\n}\n\n\nvec3 N31(float p) {\n    //  3 out, 1 in... DAVE HOSKINS\n   vec3 p3 = fract(vec3(p) * vec3(.1031,.11369,.13787));\n   p3 += dot(p3, p3.yzx + 19.19);\n   return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\n\nstruct ray {\n    vec3 o;\n    vec3 d;\n};\n\nstruct camera {\n    vec3 p;\t\t\t// the position of the camera\n    vec3 forward;\t// the camera forward vector\n    vec3 left;\t\t// the camera left vector\n    vec3 up;\t\t// the camera up vector\n\t\n    vec3 center;\t// the center of the screen, in world coords\n    vec3 i;\t\t\t// where the current ray intersects the screen, in world coords\n    ray ray;\t\t// the current ray: from cam pos, through current uv projected on screen\n    vec3 lookAt;\t// the lookat point\n    float zoom;\t\t// the zoom factor\n};\n\nstruct de {\n    // data type used to pass the various bits of information used to shade a de object\n\tfloat d;\t// distance to the object\n    float b;\t// bump\n    float m; \t// material\n    float f;\t// flame\n    float w;\t// distance to wick\n    float fd;\t// distance to flame\n    float t;\n    float s; // closest flame pass\n    float sd;\n    vec2 uv;\n    // shading parameters\n    vec3 pos;\t\t// the world-space coordinate of the fragment\n    vec3 nor;\t\t// the world-space normal of the fragment\n    float fresnel;\t\n};\n    \nstruct rc {\n    // data type used to handle a repeated coordinate\n\tvec3 id;\t// holds the floor'ed coordinate of each cell. Used to identify the cell.\n    vec3 h;\t\t// half of the size of the cell\n    vec3 p;\t\t// the repeated coordinate\n};\n    \ncamera cam;\n\n\nvoid CameraSetup(vec2 uv, vec3 position, vec3 lookAt, float zoom) {\n\t\n    cam.p = position;\n    cam.lookAt = lookAt;\n    cam.forward = normalize(cam.lookAt-cam.p);\n    cam.left = cross(up, cam.forward);\n    cam.up = cross(cam.forward, cam.left);\n    cam.zoom = zoom;\n    \n    cam.center = cam.p+cam.forward*cam.zoom;\n    cam.i = cam.center+cam.left*uv.x+cam.up*uv.y;\n    \n    cam.ray.o = cam.p;\t\t\t\t\t\t// ray origin = camera position\n    cam.ray.d = normalize(cam.i-cam.p);\t// ray direction is the vector from the cam pos through the point on the imaginary screen\n}\n\nfloat remap01(float a, float b, float t) { return sat(t-a)/(b-a); }\nfloat remap(float a, float b, float c, float d, float t) { return sat((b-a)/(t-a)) * (d-c) +c; }\n\nfloat DistLine(vec3 ro, vec3 rd, vec3 p) {\n\treturn length(cross(p-ro, rd));\n}\n\nvec2 within(vec2 uv, vec4 rect) {\n\treturn (uv-rect.xy)/rect.zw;\n}\n\n// DE functions from IQ\n// https://www.shadertoy.com/view/Xds3zN\n\nvec2 smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return vec2(mix( b, a, h ) - k*h*(1.0-h), h);\n}\n\nvec2 smax( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn vec2(mix( a, b, h ) + k*h*(1.0-h), h);\n}\n\nfloat sdSphere( vec3 p, vec3 pos, float s ) { return length(p-pos)-s; }\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec3 opCheapBend( vec3 p, float strength )\n{\n    float c = cos(strength*p.y);\n    float s = sin(strength*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    return q;\n}\n\n    \nrc Repeat(vec3 pos, vec3 size) {\n\trc o;\n    o.h = size*.5;\t\t\t\t\t\n    o.id = floor(pos/size);\t\t\t// used to give a unique id to each cell\n    o.p = mod(pos, size)-o.h;\n    return o;\n}\n\nfloat CB_Dist(rc q, vec3 rd) {\t\t\t\t\t\t// returns the distance, along the ray, to the next cell boundary\n\t vec3 rC = ((2.*step(0., rd)-1.)*q.h-q.p)/rd;\t// ray to cell boundary\n     return min(min(rC.x, rC.y), rC.z)+.01;\t\t\t// distance to cell just past boundary\n}\n\nvec3 background(vec3 r) {\n\tfloat x = atan(r.x, r.z);\t\t// from -pi to pi\t\n\tfloat y = pi*0.5-acos(r.y);  \t\t// from -1/2pi to 1/2pi\t\t\n    \n    vec3 col = vec3(0.);\n    \n    return col;\n}\n\n// From http://mercury.sexy/hg_sdf\nvec3 pModPolar(inout vec3 p, float repetitions, float fix) {\n\tfloat angle = twopi/repetitions;\n\tfloat a = atan(p.z, p.x) + angle/2.;\n\tfloat r = length(p.xz);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - (angle/2.)*fix;\n\tp = vec3(cos(a)*r, p.y, sin(a)*r);\n\n\treturn p;\n}\n\nde map( vec3 p ) {\n    // returns a vec3 with x = distance, y = bump, z = mat transition w = mat id\n    de o;\n    o.m = 1.;\n    \n    float t = iTime;\n    \n    \n    p.y += (sin(p.x*10.)*sin(p.y*12.))*.01;\n   \tfloat outside = sdCappedCylinder(p+vec3(0., 2., 0.), vec2(.75, 2.))-.1;\n    float inside = sdCappedCylinder(p-vec3(0., 2., 0.), vec2(.45, 2.))-.3;\n    \n    vec2 candle = smax(outside, -inside, .1);\n    \n    vec3 q = p+vec3(0., .15, 0.);\n    q = opCheapBend(q+vec3(0., 0.2, 0.)*0., 1.);\n    \n    float angle = atan(q.x, q.z);\n    \n    q.xz *= 1.-abs(sin(angle*twopi+q.y*40.))*.02*S(.1, .2, q.y);\n    q.xz *= 1.-S(.2, .0, q.y)*.2;\n    float wick = sdCappedCylinder(q+vec3(0., 0.1, 0.), vec2(.01, .7))-.05;\n    \n    vec2 d = smin(candle.x, wick, .2);\n    \n    o.uv = vec2(angle, q.y);\n    o.t = d.y;\n    o.d = d.x*.8;\n    o.w = wick;\n    \n    return o;\n}\n\nde fmap( vec3 p, float n ) {\n    // returns a vec3 with x = distance, y = bump, z = mat transition w = mat id\n    float t = iTime*2.;\n    \n    de o;\n    o.m = 1.;\n    \n    p.z *= 1.5;\n    \n    float spikes = pow(abs(sin(p.x*50.+t*2.)), 5.);\n    spikes *= pow(abs(sin(p.x*-30.+t*1.)), 5.);\n    p.y += spikes*.1*S(1.5, 3., p.y);\n    \n    \n    vec3 q = opCheapBend(p+vec3(0., 0.2, 0.), 1.);\n    \n    float wick = sdCappedCylinder(q+vec3(0., 0.1, 0.), vec2(.01, .7))-.01;\n    float d = wick;\n    float flame = wick;\n    \n    float t2 = t*.2;\n    float top = 2.5-n*n;\n    for(float i=0.; i<1.; i+=1./20.) {\n        \n        float y = mix(.3, top, i);\n        float x = pow(abs(sin(y-t*2.)), 2.)*.1*n*p.y*n*n*n;\n        \n        float size = mix(.1, .05, i*i);\n        float smth = mix(.4, .1, i);\n    \tflame = smin(flame, sdSphere(p, vec3(x-.12, y, .0), size), smth).x;\n    }\n    \n    d = min(d, flame);\n    \n    d = max(d, -sdSphere(p, vec3(-.2, -.5, .0), .5)); \n    o.d = d/1.5;\n    \n    return o;\n    \n}\n\nde castRay( ray r, float n ) {\n    \n    float dmin = 1.0;\n    float dmax = 100.0;\n    \n\tfloat precis = RAY_PRECISION;\n    \n    de o;\n    o.d = dmin;\n    o.m = -1.0;\n    o.w = 1000.;\n    o.s = 1000.;\n    \n    de res;\n    \n    for( int i=0; i<MAX_STEPS; i++ )\n    {\n\t    \n        res = map( r.o+r.d*o.d );\n        if( res.d<precis || o.d>dmax ) break;\n        \n        float d = o.d;\n        float w = o.w;\n        o = res;\n        if(w<o.w) o.w = w;\n        \n        o.d += d;\n    }\n    \n    if( o.d>dmax ) o.m=-1.0;\n    o.s = 1000.;\n    o.fd = 0.;\n    for( int i=0; i<MAX_STEPS; i++ )\n    {\n\t    res = fmap( r.o+r.d*o.fd, n );\n        if( res.d<precis || o.fd>dmax ) break;\n        if(res.d<o.s) {\n            o.s = res.d;\n            o.sd = o.fd;\n        }\n        \n        o.fd += res.d;\n    }\n    \n    if(res.d<precis)\n        o.f=1.;\n    \n    return o;\n}\n\nvec3 Background(ray r) {\n    \n    float t = iTime;\n    \n\tfloat x = atan(r.d.x, r.d.z);\n    float y = dot(vec3(0,1,0), r.d);\n    \n    float d = 4.1;\n        \n    vec2 size = vec2(3);\n    vec2 h = size / 2.;\n    \n    float blur = .3;\n    \n    vec3 col = vec3(0);\n    \n    for(float i=0.; i<BG_STEPS; i++) {\n    \tvec3 p = r.o + r.d*d;\n    \t\t\t\t\t\t\n    \tvec2 id = floor(p.xz/size);\t\t\t\t\t\t\t\t// used to give a unique id to each cell\n   \t\t\n        vec3 q = p;\n        \n        q.xz = mod(p.xz, size)-h;\t\t\t\t\t\t\t\t// make grid of flames\n        \n        vec3 cP = vec3(0, N21(id)*4.-2., 0);\n        \n        float dRayFlame = DistLine(q, r.d, cP);\t\t\t\t\t\t// closest ray, point dist\n        \n        float dOriFlame = d + length(cP-p);\t\t// approximate distance from ray origin to flame \n        float bSize = dRayFlame/dOriFlame;\n        vec3 flame = FLAMECOL;\n        flame *= S(BOKEH_SIZE, BOKEH_SIZE-BOKEH_SIZE*blur, bSize);\n        \n        flame *= 200.;\n        flame /= (dOriFlame*dOriFlame);\n        float flicker = LN(t+id.x*100.+id.y*345.);\n        //flicker = mix(.3, 1., S(.2, .5, flicker));\n        flame *= 1.-flicker*flicker*.7;\n        \n        if(length(id)>2.)\n        col += flame;\n        \n        // step to the next cell\n        vec2 rC = ((2.*step(0., r.d.xz)-1.)*h-q.xz)/r.d.xz;\t\t// ray to cell boundary\n        float dC = min(rC.x, rC.y)+.01;\n        \n        d += dC;\n    }\n    \n    \n    return col;\n}\n\nvec3 calcNormal( de o )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(o.pos+eps.xyy).d - map(o.pos-eps.xyy).d,\n\t    map(o.pos+eps.yxy).d - map(o.pos-eps.yxy).d,\n\t    map(o.pos+eps.yyx).d - map(o.pos-eps.yyx).d );\n\treturn normalize(nor);\n}\n\nvec3 FlameNormal( vec3 p, float n )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    fmap(p+eps.xyy, n).d - fmap(p-eps.xyy, n).d,\n\t    fmap(p+eps.yxy, n).d - fmap(p-eps.yxy, n).d,\n\t    fmap(p+eps.yyx, n).d - fmap(p-eps.yyx, n).d );\n\treturn normalize(nor);\n}\n\nde GetShadingBasics(de o, ray r) {\n    o.pos = r.o + o.d*r.d;\n    o.nor = calcNormal( o );\n    o.fresnel = dot(o.nor, r.d);\n    \n    return o;\n}\n\n\n\nvec4 render( vec2 uv, ray camRay, float n ) {\n    // outputs a color\n    \n    vec3 col = vec3(0.);\n    de o = castRay(camRay, n);\n    col = Background(camRay);\n    \n    if(o.m>0.) {\n        o = GetShadingBasics(o, camRay);\n        vec3 p = o.pos;\n        float angle = atan(p.x, p.z);\n        \n        float inside = S(.9, .5, length(o.pos.xz));\n        float dif = dot(o.nor, camRay.d)*.5+.5;\n        float sss = S((n*n)*.2-1.5, -.0, p.y)*3.;\n        sss += sin(angle*15.)*.05;\n        sss *= (1.-inside);\n        dif = max(dif, sss);\n        \n        col = vec3(.3, .3, .4)*dif;\n        \n        \n        vec3 fv = vec3(0., 3., 0.)-o.pos;\n        float fd = length(fv);\n        float flame = sat(dot(o.nor, fv/fd)/(fd*fd));\n        col += flame*10.*mix(FLAMECOL, vec3(1.), .5);\n        \n        \n        vec3 candleCol = mix(CANDLECOL, vec3(1.), inside);\n       \n        \n        vec3 wickCol = mix(candleCol, vec3(.2), S(.1, .2, o.uv.y));\n        col *= mix(wickCol, candleCol, o.t);\n        \n        col += FLAMECOL*(1.-o.t)*S(.3, .8, o.uv.y)*2.;\n       \n        \n        vec3 r = reflect(camRay.d, o.nor);\n        \n        float ref = sat(dot(r, fv/fd));\n        col += FLAMECOL*2.*pow(ref, inside*50.+4.)*o.t;\n        \n    }\n    \n    if(o.f>0.&&o.fd<o.d) {\n        vec3 p = camRay.o+camRay.d*o.fd;\n        vec3 n = FlameNormal(p, n);\n        float fresnel = sat(dot(n, -camRay.d));\n        float flame = 1.;//fresnel;\n        \n        float wd = DistLine(camRay.o, camRay.d, vec3(-.3, .25, 0.));\n       wd = o.w;\n        \n        flame *= S(-.1, .8, p.y);\n        flame *= mix(1., .1, S(.85, .0, wd)*pow(abs(fresnel), 5.));\n        \n       flame *= S(3.5, 1., p.y);\n       flame *= S(2.5, 2., p.y);\n       \n        float bottomFade = S(.05, .2, p.y);\n        col = mix(col, FLAMECOL*3., flame*fresnel*bottomFade);\n        float blue = S(.4, -.0, p.y);\n       blue *= S(.7, .3, fresnel*fresnel);\n        col += FLAMEBLUE*blue*bottomFade;\n    }\n    \n    vec3 p = camRay.o + camRay.d*o.sd;\n    float y = p.y-1.;\n    float gw = sat(1.-y*y);\n    gw*=gw;\n    float glow = S(.25*gw, 0., o.s)*.5;\n    glow*=glow;\n    //glow *= S(.0, .5, p.y);\n    //glow *= S(2.5, 1., p.y);\n    \n    col = max(col, glow*FLAMECOL);\n\n    \n    return vec4( col, o.m );\n}\n\nvec4 Flame(vec2 uv, vec2 p) {\n    uv.x-=.5;\n    p.x -= .5;\n    \n    vec3 col = vec3(.99, .6, .35);\t// main color\n    vec3 blue =  vec3(.1, .1, 1.);  // flame blue\n    \n    float alpha = 1.;\n    \n    p.x *= S(.0, p.y, uv.y);\n   \n    vec2 top = p;\n    vec2 bottom = vec2(0., .15);\n    float bl = length(bottom-uv);\n    vec2 v = top-bottom;\n    float vl = length(v);\n    v /= vl;\n    \n    float fy = clamp(dot(uv-bottom, v), 0., vl);\n    vec2 cp = bottom + fy * v;\n    \n    float fx = length(cp-uv);\n    fy /= vl;\n    \n    float fw = mix(.13, .03, fy*fy);\n    //fw *= mix(.5, 1., vl);\n    \n    \n    col.b = bl;\n    col.r = fx/fw;\n    col.g = fy;\n    \n    fx /= fw;\n    \n    \n    float d = S(1., .9, fx);\n    \n    //col = vec3(.99, .6, .35)*(1.+fy);\n    \n    col *= d; \n    \n    return vec4(col, alpha);\n}\n\nvoid mainImage( out vec4 o, in vec2 uv )\n{\n    float t = iTime;\n    uv = (2.*uv - (o.xy=iResolution.xy) ) / o.y ;  \t// -1 <> 1\n   \tm = iMouse.xy/iResolution.xy;\t\t\t\t\t// 0 <> 1\n    \n    float turn = (.1-m.x)*twopi+t*twopi/8.;\n    float s = sin(turn);\n    float c = cos(turn);\n    mat3 rotX = mat3(\t  c,  0., s,\n                   \t\t  0., 1., 0.,\n                   \t\t  s,  0., -c);\n    \n    vec3 lookAt = vec3(0., .8, 0.);\n    float dist = 6.;\n    float y = .4;//INVERTMOUSE*dist*sin((m.y*pi));\n    vec3 pos = vec3(0., y, -dist)*rotX;\n   \t\n    CameraSetup(uv, pos, lookAt, 3.);\n    \n    bg = background(cam.ray.d);\n\t\n    t *= twopi;\n    float t2 = t;\n    float n = mix(N(floor(t2)), N(floor(t2+1.)), fract(t2));\n    \n    vec4 info = render(uv, cam.ray, n);\n   \n    \n\n    o = vec4(info.rgb, 1.);\n}","name":"Image","description":"","type":"image"}]}