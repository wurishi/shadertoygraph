{"ver":"0.1","info":{"id":"7dyyWV","date":"1656339889","viewed":184,"name":"Infinibulb","username":"MisterSirCode","description":"Procedural Thin Film Interference. This shader makes use of an modulated mandelbulb world.\n\nTechnique from: https://docs.chaos.com/display/OSLShaders/Thin+Film+Shader\n\nDECENT HARDWARE REQUIRED. Infinite mandelbulbs are not great on weak PCs!","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarch","sdf","mandelbulb","interference","film","infinite","iridescence","thin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ---------------------------------------------------------------------------------------\n//\n//\tCreated by MisterSirCode - 2022\n//\n//  Please enjoy. I tried abstracting as much as possible to make this thing easy to understand.\n//  Raymarcher is in Common\n//\n//  Config:\n\n#define MIN_DIST 3.0\n#define MAX_DIST 50.0\n#define PI 3.1415926535897932384\n\n// ---------------------------------------------------------------------------------------\n\n// Coefficients (Required for thin film)\n\nfloat refs(float n1, float n2, float cosI, float cosT) {\n    return (n1 * cosI - n2 * cosT) / (n1 * cosI + n2 * cosT);\n}\n\nfloat refp(float n1, float n2, float cosI, float cosT) {\n    return (n2 * cosI - n1 * cosT) / (n1 * cosT + n2 * cosI);\n}\n \nfloat trns(float n1, float n2, float cosI, float cosT) {\n    return 2.0 * n1 * cosI / (n1 * cosI + n2 * cosT);\n}\n \nfloat trnp(float n1, float n2, float cosI, float cosT) {\n    return 2.0 * n1 * cosI / (n1 * cosT + n2 * cosI);\n}\n\n// Film\n\nfloat filmLayer(float cos0, float lambda, vec3 layers, float thick) {\n    float n0 = layers.x, n1 = layers.y, n2 = layers.z;\n    float delta = ((n1 > n0) ? 0.0 : PI) + ((n1 > n2) ? 0.0 : PI);\n    \n    float sin1 = pow(n0 / n1, 2.0) * (1.0 - pow(cos0, 2.0));\n    if (sin1 > 1.0) return 1.0;\n    float cos1 = sqrt(1.0 - sin1);\n    \n    float sin2 = pow(n0 / n2, 2.0) * (1.0 - pow(cos0, 2.0));\n    if (sin2 > 1.0) return 1.0;\n    float cos2 = sqrt(1.0 - sin2);\n    \n    float alpha_s = refs(n1, n0, cos1, cos0) * refs(n1, n2, cos1, cos2),\n    alpha_p = refp(n1, n0, cos1, cos0) * refp(n1, n2, cos1, cos2),\n    beta_s = trns(n0, n1, cos0, cos1) * trns(n1, n2, cos1, cos2),\n    beta_p = trnp(n0, n1, cos0, cos1) * trnp(n1, n2, cos1, cos2),   \n    phi = (2.0 * PI / lambda) * (2.0 * n1 * thick * cos1) + delta,\n    ts = pow(beta_s, 2.0) / (pow(alpha_s, 2.0) - 2.0 * alpha_s * cos(phi) + 1.0),\n    tp = pow(beta_p, 2.0) / (pow(alpha_p, 2.0) - 2.0 * alpha_p * cos(phi) + 1.0),\n    beam = (n2 * cos2) / (n0 * cos0),\n    t = beam * (ts + tp) / 2.0;\n    \n    return 1.0 - t;\n}\n\nvec4 thinFilm(vec3 norm, vec3 cam, vec3 lambda, vec3 layers, float thick, float saturation) {\n    float cosDir = dot(normalize(norm), normalize(cam));\n    vec3 filmCol = vec3(filmLayer(cosDir, lambda.x, layers, thick), \n                        filmLayer(cosDir, lambda.y, layers, thick), \n                        filmLayer(cosDir, lambda.z, layers, thick));\n    float hue = RGBtoHSV(filmCol).x;\n    return vec4(hue, HSVtoRGB(vec3(hue, 0.4, 1.0)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    time = iTime;\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    float px = 2.0 / (iResolution.y * 1.5);\n    \n    // Raymarcher\n    \n\tvec3 dir = getDir(45.0, iResolution.xy, fragCoord);\n    float cuTime = iTime / 10.0;\n    vec3 eye = vec3(sin(cuTime) * 6.0, 4.0, cos(cuTime) * 6.0);\n    cameraPos = eye;\n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    vec3 worldDir = viewToWorld * dir;\n    vec4 dist = getDist(eye, worldDir, MIN_DIST, MAX_DIST);\n    if (dist.x > MAX_DIST - 0.00001) { // Draw background\n        fragColor = vec4(0);\n        return;\n    }\n    vec3 pos = eye + dist.x * worldDir;\n    vec3 norm = getNorm(pos);\n    float fresnel = dot(norm, normalize(eye));\n    \n    // Thin Film\n    \n    vec3 lambda = vec3(650.0, 338.0, 475.0); // All the properties can be manipulated for different materials and film types\n    vec3 layers = vec3(1.0, 1.5, 1.0);\n    vec4 film = thinFilm(norm, eye, lambda, layers, 340.0, 0.4); // All you need is the camera position / direction and the normals\n    \n    vec3 cell = floor((pos + 2.0) / 4.0);\n    vec3 tint = hash33(cell);\n    vec3 col = vec3((-dist.r / MAX_DIST + 0.5) * 2.0);\n    \n    float occ = getOcclusion(pos, norm);\n    \n    vec3 final = ((film.gba * 2.0 + tint) / 2.0) * col * occ * 3.0;\n    \n    fragColor = vec4(final, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// ---------------------------------------------------------------------------------------\n//\n//\tCreated by MisterSirCode - 2022\n//\n//  Config:\n\n#define MAX_MARCHING_STEPS 2048\n#define MAX_SHADOW_STEPS 64\n#define MAX_AO_STEPS 32.0\n#define MAX_AO_DIST 0.07\n#define EPSILON 0.00001\n\n// Storage:\n\nfloat time = 0.0;\nvec3 cameraPos;\n\n// ---------------------------------------------------------------------------------------\n\n// Other Stuff\n\nvec4 mandelbulb(vec3 pos, float power, float phase)\n{\n    vec3 w = pos;\n    float m = dot(w,w);\n    vec4 trap = vec4(abs(w),m);\n\tfloat dz = 1.0;\n\tfor( int i = 0; i < 2; i++ )\n    {\n        // dz = 8*z^7*dz\n\t\tdz = power * pow(m, power / 2.0) * dz + 1.0;\n        // z = z^8+c\n        float r = length(w);\n        float b = power * acos(w.y/ r) + phase;\n        float a = power * atan(w.x, w.z);\n        w = pos + pow(r, power) * vec3(sin(b) * sin(a), cos(b), sin(b) * cos(a));\n        trap = min(trap, vec4(abs(w), m));\n        m = dot(w, w);\n\t\tif(m > 256.0)\n            break;\n    }\n    return vec4(0.25 * log(m) * sqrt(m) / dz, trap.yzw);\n}\n\n// Math Stuff\n\nvec3 getHalfpoint(vec3 light, vec3 view) {\n    return normalize(light + view);\n}\n\n\nfloat hash1(float n) {\n    return fract(sin(n) * 43758.5453123);\n}\n\nfloat hash13(vec3 p3) {\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz + 33.33);\n    return fract((p3.xxy + p3.yxx) * p3.zyx);\n}\n\nvec3 forwardSf(float i, float n)  {\n    const float PI  = 3.141592653589793238;\n    const float PHI = 1.618033988749894848;\n    float phi = 2.0 * PI * fract(i / PHI);\n    float zi = 1.0 - (2.0 * i + 1.0) / n;\n    float sinTheta = sqrt(1.0 - zi * zi);\n    return vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, zi);\n}\n\n// SDF Stuff\n\nvec3 opRep(vec3 p, vec3 c) {\n    vec3 q = mod(p + 0.5 * c, c ) - 0.5 * c;\n    return q;\n}\n    \nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n    \nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nvec4 getScene(vec3 pos) {\n    vec3 cell = floor((pos + 2.0) / 4.0);\n    return mandelbulb(opRep(pos, vec3(4.0)), \n                      floor(hash13(cell) * 5.0 + 3.0), \n                      hash13(cell) * 40.0 + ((hash13(cell) / 1.5 + 0.25) * time * 4.0));\n}\n\n// Raymarcher Stuff\n\nfloat getShadow(vec3 pos, vec3 dir, float mint, float tmax) {\n    float res = 1.0;\n    float t = mint;\n    float ph = 1e10;\n    for (int i = 0; i < MAX_SHADOW_STEPS; i++) {\n        float h = getScene(pos + dir * t).x;\n        float y = h * h / (2.0 * ph);\n        float d = sqrt(h * h - y * y);\n        res = min(res, 10.0 * d / max(0.0, t - y));\n        ph = h;\n        t += h;\n        if (res < 0.0001 || t > tmax) break;\n    }\n    res = clamp(res, 0.0, 1.0);\n    return res * res * (3.0 - 2.0 * res);\n}\n\nfloat getOcclusion(vec3 pos, vec3 dir) {\n\tfloat ao = 0.0;\n    for (float i = 0.0; i < MAX_AO_STEPS; i++) {\n        vec3 ap = forwardSf(i, MAX_AO_STEPS);\n        float h = hash1(i);\n\t\tap *= sign(dot(ap, dir)) * h * 0.1;\n        ao += clamp(getScene(pos + dir * 0.01 + ap).x * 3.0, 0.0, 1.0 );\n    }\n\tao /= MAX_AO_STEPS;\n    return clamp(ao * 6.0, 0.0, 1.0);\n}\n\nvec3 getDir(float fov, vec2 size, vec2 fragCoord) {\n    vec2 coord = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fov) / 2.0);\n    return normalize(vec3(coord, -z));\n}\n\nvec3 getNorm(vec3 pos) {\n    vec3 eps = vec3(.001,0.0,0.0);\n    return normalize(vec3(\n    getScene(pos+eps.xyy).x - getScene(pos-eps.xyy).x,\n    getScene(pos+eps.yxy).x - getScene(pos-eps.yxy).x,\n    getScene(pos+eps.yyx).x - getScene(pos-eps.yyx).x));\n}\n\nvec3 getNorm(vec3 pos, float px) {\n    vec2 e = vec2(1.0, -1.0) * 0.5773 * 0.25 * px;\n    return normalize(e.xyy * getScene(pos + e.xyy).x + \n\t\t\t\t\t e.yyx * getScene(pos + e.yyx).x + \n\t\t\t\t\t e.yxy * getScene(pos + e.yxy).x + \n\t\t\t\t\t e.xxx * getScene(pos + e.xxx).x);\n}\n\nvec4 getDist(vec3 eye, vec3 dir, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec4 dist = getScene(eye + depth * dir);\n        if (dist.x < EPSILON)\n\t\t\treturn vec4(depth, dist.yzw);\n        depth += dist.x;\n        if (depth >= end)\n\t\t\treturn vec4(end, dist.yzw);\n    }\n}\n\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\n// Color stuff obtained here: https://www.shadertoy.com/view/4dKcWK\n\nvec3 HUEtoRGB(float hue) {\n    vec3 rgb = abs(hue * 6. - vec3(3, 2, 4)) * vec3(1, -1, -1) + vec3(-1, 2, 2);\n    return clamp(rgb, 0., 1.);\n}\n\nvec3 HSVtoRGB(vec3 hsv) {\n    vec3 rgb = HUEtoRGB(hsv.x);\n    return ((rgb - 1.) * hsv.y + 1.) * hsv.z;\n}\n\nvec3 RGBtoHCV(vec3 rgb) {\n    vec4 p = (rgb.g < rgb.b) ? vec4(rgb.bg, -1., 2. / 3.) : vec4(rgb.gb, 0., -1. / 3.);\n    vec4 q = (rgb.r < p.x) ? vec4(p.xyw, rgb.r) : vec4(rgb.r, p.yzx);\n    float c = q.x - min(q.w, q.y);\n    float h = abs((q.w - q.y) / (6. * c + EPSILON) + q.z);\n    return vec3(h, c, q.x);\n}\n\nvec3 RGBtoHSV(vec3 rgb) {\n    vec3 hcv = RGBtoHCV(rgb);\n    float s = hcv.y / (hcv.z + EPSILON);\n    return vec3(hcv.x, s, hcv.z);\n}\n\n\n","name":"Common","description":"","type":"common"}]}