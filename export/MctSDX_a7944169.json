{"ver":"0.1","info":{"id":"MctSDX","date":"1714561716","viewed":48,"name":"Fork fractal fa sleeplessm 365","username":"sleeplessmonk","description":"copypast","likes":1,"published":1,"flags":4,"usePreview":0,"tags":["fractal","circuit","cyberplant"],"hasliked":0,"parentid":"-1","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGRr","filepath":"/presets/mic.png","previewfilepath":"/presets/mic.png","type":"mic","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R(p,a,r) mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h) (cos((h)*2.3+vec3(12,23,31))*.5+.5)\n#define _PI 3.1415926535897932384626433832795\n\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.8);  // Base color\n    vec3 b = vec3(0.9, 0.6, 0.5);  // Color amplitude variations\n    vec3 c = vec3(1.0, 0.7, 1.3);  // Frequency of the color wave\n    vec3 d = vec3(0.3, 0.2, 0.8);  // Phase shift of the color wave\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvec2 kaleidoscope(vec2 uv, float time, float bass, float treble) {\n    float angle = _PI / 2.0 * (1.0 + sin(time + bass));  // Kaleidoscope angle modulated by bass\n    float segments = 6.0 + 4.0 * treble;  // Number of segments modulated by treble\n    float a = atan(uv.y, uv.x) + time;\n    float r = length(uv);\n    a = mod(a, _PI / segments) * segments;\n    return vec2(cos(a), sin(a)) * r;\n}\n\nvec2 getPixelShift(vec2 center, vec2 pixelpos, float startradius, float size, float shockfactor, in vec2 fragCoord, float pro) {\n    float m_distance = distance(center, pixelpos);\n    if (m_distance > startradius && m_distance < startradius + size) {\n        float sin_dist = sin((m_distance - startradius) / size * _PI) * shockfactor;\n        return (pixelpos - (1.0 - pro) * normalize(pixelpos - center) * sin_dist) / iResolution.xy;\n    } else {\n        return fragCoord.xy / iResolution.xy;\n    }\n}\n\n\nvoid mainImage(out vec4 O, vec2 C) {\n    float bass = texture(iChannel0, vec2(0.01, 0.5)).r; // Low frequencies\n    float treble = texture(iChannel0, vec2(0.2, 0.5)).r; // High frequencies\n\n    vec2 uv = (C - 0.5 * iResolution.xy) / iResolution.y;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Apply the kaleidoscope effect\n    uv = kaleidoscope(uv, iTime, bass, treble);\n\n    // Calculate color\n    vec3 color = vec3(0.0);\n    for (int i = 0; i < 5; ++i) {\n        vec2 p = uv + 0.1 * float(i);\n        float len = length(p);\n        float angle = atan(p.y, p.x);\n        vec3 col = palette(len + angle + iTime * 0.1);\n        color += col / (1.0 + len * 2.0);\n    }\n\n    // Gamma correction\n    color = pow(color, vec3(1.0 / 2.2));\n\n    // Output final color\n    O = vec4(color, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}