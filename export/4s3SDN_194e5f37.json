{"ver":"0.1","info":{"id":"4s3SDN","date":"1459461973","viewed":299,"name":"Retro racetrack","username":"tomkel","description":"silly retro ractrack","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["procedural"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float zigzag( float x )\n{ \n   /* float y = mod(x,3.142 ) / 3.142;\n    if ( y > 0.5 )\n    {\n        return 1.0-(y -0.5)/0.5;\n    }\n    return (y*2.0); */\n    \n    return cos(x);\n}\n\nfloat box( vec3 position, vec3 lengths, vec3 raypos )\n{\n    vec3 p = raypos - position;\n    \n    float d0 = max( p.x - lengths.x, -p.x - lengths.x );\n    float d1 = max( p.y - lengths.y, -p.y - lengths.y );\n    float d2 = max( p.z - lengths.z, -p.z - lengths.z );\n    return vec4( max( d0, max(d1,d2 )), 1.0,0, 0.8).x;\n}\n\nfloat cylinder( vec3 position, vec2 dim, vec3 raypos )\n{\n    vec3 p = raypos - position;\n    return max( length( p.zy ) - dim.x,\n                 max( p.x - dim.y, -p.x - dim.y));\n}\n\n\n\nfloat feature( vec3 position, vec2 dim, vec3 raypos )\n{\n \n   // float zoff = float(int(raypos.z / 10.0));\n    float y = (iTime*100.0);\n    float x = -zigzag( (y+raypos.z)/100.0 )*40.0;\n    \n    position.y -= floor( mod( (raypos.z + y) / 1000.0 , 2.0 )) * 10.0;\n    \n    //roadpos.y += iTime*100.0;\n    //position.x += x; //zigzag( raypos.z/100.0 )*40.0 ;\n    \n    //position.x = x;\n    float c0, c1, c2;\n    {\n    vec3 r = vec3( raypos.x, raypos.y, mod( raypos.z + y + 1000.0, 10.0 ) );\n  //  vec3 r = mod( raypos,10.0 );\n    vec3 p = r - vec3( position.x + x, position.y, position.z  );\n    c0 =  max( length( p.zx ) - dim.x,\n                 max( p.y - dim.y, -p.y - dim.y));\n    }\n    \n     {\n    vec3 r = vec3( raypos.x, raypos.y, mod( raypos.z + 1000.0 + y, 10.0 ) );\n    vec3 p = r - vec3( -position.x + x, position.y, position.z );\n    c1 =  max( length( p.zx ) - dim.x,\n                 max( p.y - dim.y, -p.y - dim.y));\n    }\n    \n    {\n    vec3 r = vec3( raypos.x, raypos.y, mod( raypos.z + 1000.0 + y, 10.0 ) );\n    vec3 p = r - vec3(  x, position.y + dim.y, position.z );\n    c2 =  max( length( p.zy ) - dim.x * 0.5,\n                 max( p.x - 15.0, -p.x - 15.0));\n    }\n    \n    return min( min(c0,c1 ), c2 );\n}\n\n\n\nvec4 road( vec2 roadpos )\n{\n    vec4 surface = vec4( 0.5,0.5,0.5,1.0);\n\n    \n    roadpos.y += iTime*100.0;\n    roadpos.x += zigzag( roadpos.y/100.0 )*40.0 ;\n    vec2 roadabs = abs(roadpos );\n    \n    if ( roadabs.x > 10.0 )\n    {\n    \n        if ( roadabs.x > 12.0)\n        {\n        \tsurface = vec4(0.0,1.0,0.0,1.0 );\n        }\n        else\n        {\n            float fy =  floor( (roadabs.y) / 0.8 );\n            if ( mod( fy, 2.0 ) == 0.0 )\n            {\n            \tsurface = vec4( 1,1,1,1.0);\n            }\n            else\n            {\n                surface = vec4( 1.0,0.0,0.0,1.0);\n            }\n        }\n    }\n    else\n    {\n        if ( roadabs.x < 0.1 )\n        {\n            float fy =  floor( (roadabs.y + 2.0 ) / 4.0 );\n            if ( mod( fy, 2.0 ) == 0.0 )\n            {\n            \tsurface = vec4( 1,1,1,1.0);\n            }\n            else\n            {\n                surface = vec4( 0.5,0.5,0.5,1.0);\n            }\n        }\n        else \n        {\n        \tsurface = vec4( 0.5,0.5,0.5,1.0);\n        }\n    }\n    \n    float fy = floor( roadabs.y / 20.0 );\n    \n    \n    \n    \n    if ( mod( fy, 2.0 ) == 0.0 ) \n    {\n        surface *= 0.8;\n    }\n    \n    return surface;\n     \n}\n\nfloat sphere( vec3 spherepos, float r, vec3 raypos )\n{\n    return distance( spherepos, raypos ) - r;\n}\n\nvec4 getlight( vec3 normal, vec3 position, vec3 lightpos, vec4 lightcolour  )\n{\n    vec4 amb = vec4(0.3,0.3,0.3,1.0);\n    float d = distance( position, lightpos );\n    vec3 n = normalize( position - lightpos );\n    if ( dot( normal, n ) > 0.5 )\n    {\n        return lightcolour + amb;;\n    }\n    else if ( dot( normal, n ) > 0.1 )\n    {\n        return lightcolour * 0.5 + amb;;\n    }\n        \n    return amb;\n    \n}\n\n\nfloat smin( float a,  float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    float blend = -log( res )/k;\n    return blend;\n}\n\n\nfloat sdf( vec3 raypos )\n{\n    float xpos = iMouse.x / iResolution.x - 0.5 ;\n    float y = (iTime-3.0)*100.0;\n    float x = (xpos * 0.0 + zigzag( y/100.0 ))*40.0;\n    //float e = 1.0; //abs( 0.5 + abs( cos( iTime )) * 3.0 ) ;\n    float sdf0 = cylinder( vec3( x, 0.5, 0.0 ), vec2( 0.49,1.3 ), raypos  );\n    float sdf1 = cylinder( vec3( x, 0.5, 2.0 ), vec2( 0.49,1.2 ), raypos  );\n    float sdf2 =  box( vec3( x, 0.7, 1.0 ), vec3( 1.0, 0.5, 1.0), raypos);\n    float sdf3 =  feature( vec3(15.0,0,5.0), vec2(1.0,4.0), raypos );\n\n    return \n        \t min( sdf3, \n                min( sdf2, \n                    min( sdf1, \n                        min( sdf0, min(raypos.y, 20.0-raypos.y )) \n                    )\n                )\n              );\n                    //sphere( vec3( 0,10, 0.0), 2.0, raypos ), e );\n}\n\nvec4 contact( vec3 position, vec3 normal, float scale )\n{\n    float s = sdf( position + normal * scale );\n    \n    if ( s < scale )\n    {\n        return vec4(0.8,0.8,0.8,1.0);\n    }\n    \n    return   vec4(1.0,1.0,1.0,1.0);\n    \n    \n}\n\nvec3 grad( vec3 raypos, float delta )\n{\n    float dx =  sdf( raypos + vec3( delta, 0,0 ) ) - sdf( raypos - vec3( delta,0,0 ) );\n    float dy =  sdf( raypos + vec3( 0, delta,0 ) ) - sdf( raypos - vec3( 0,delta,0 ) );\n    float dz =  sdf( raypos + vec3( 0,0, delta ) ) - sdf( raypos - vec3( 0,0,delta ) );\n    return vec3( dx,dy,dz );\n    //return vec3(0,-1.0,0);\n}\n\nvec4 march( vec3 ray, vec3 origin, float ep, vec2 uv)\n{\n    vec3 p = origin;\n    //int pscale = int(  float(iFrameRate) / 60.0 * 1024.0);\n    for ( int i = 0; i < 256; i++ )\n    {\n       /* if ( i == pscale )\n        {\n            break;\n        } */ \n        float step = sdf(p);\n        if ( step  <  ep )\n        {\n            if ( p.y  > 19.0 )\n            {\n    \t\t\treturn vec4( 0.3,0.3,1.0,1.0) *  ( (uv.y - 0.5) / 0.5  ) + \n                       vec4( 1.0,1.0,1.0,1.0) *  (1.0 - ( (uv.y-0.5) / 0.5  )) ;\n            }\n            else if ( p.y  > ep )\n            {\n            \tvec3 normal = normalize( grad( p, 0.1 ) );\n            \treturn getlight( normal, p,  vec3( 500 ,0,1000 ), vec4(1.0, 1.0, 1.0, 0 ));\n                \t   //getlight( normal, p,  vec3( -100,-100,-100 ), vec4(0.0,1.0,1.0,1.0 )) ;\n            }\n        \t\n            else \n        \t{\n            \treturn road( vec2( p.x, p.z ) ) * contact( p, vec3(0.0,1.0,0.0), 0.25 );\n        \t}\n        }\n        \n        p += ray * step;\n    }\n    \n    if ( ray.y < 0.0 )\n    {\n    \tvec3 h = ray * -origin.y / ray.y + origin;\n \t\treturn road( vec2( h.x, h.z ) ) * contact( p, vec3(0.0,1.0,0.0), 0.25 );\n    }\n    else\n    {\n   \n    return vec4( 0.3,0.3,1.0,1.0) *  ( (uv.y - 0.5) / 0.5  ) + \n           vec4( 1.0,1.0,1.0,1.0) *  (1.0 - ( (uv.y-0.5) / 0.5  )) ; \n    }\n}\n\nvec3 rotatevecY( vec3 vec, float angle )\n{\n    vec3 m0 = vec3( -cos( angle ), 0, sin( angle ));\n    vec3 m1 = vec3( 0            , 1.0,   0      );\n    vec3 m2 = vec3( sin( angle ), 0, cos( angle ) );\n    \n    return vec3(  dot( m0, vec ), dot( m1, vec ), dot( m2, vec )) ;\n} \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    /*if ( uv.y > 0.8 )\n    {\n        fragColor = vec4( 0.3,0.3,1.0,1.0) *  ( (uv.y - 0.5) / 0.5  ) + \n                    vec4( 1.0,1.0,1.0,1.0) *  (1.0 - ( (uv.y-0.5) / 0.5  )) ;\n    }\n    else */ \n    {\n         float aspect = iResolution.y / iResolution.x;\n    \n    \t vec3 origin = vec3(0.0, 2.0,-5.0 );\n    \t vec3 ray = vec3( uv.x - 0.5, (uv.y - 0.5) * aspect, 0.5 );\n    \n        \n        float y = (iTime-0.0)*100.0;\n        float x = zigzag( y/100.0 )*40.0;\n   \n    \tray = rotatevecY( ray, x/80.0 );\n        origin.x += x;\n    \torigin = rotatevecY( origin, 0.0 );\n    \n\t\tfragColor = march( ray, origin, 0.01, uv );\n        \n        //float y = (iTime-0.0)*100.0;\n        //float x = zigzag( y/100.0 )*40.0;\n        \n        //vec2 vp = uv - vec2(0.5,0.5 );\n  \t\t//vec2 rp = vec2( -x + vp.x / -vp.y * 5.0,  5.0 / -vp.y \t);\n        \n\t\t//fragColor = road( rp);\n    }\n}","name":"Image","description":"","type":"image"}]}