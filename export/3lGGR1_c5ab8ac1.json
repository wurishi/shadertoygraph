{"ver":"0.1","info":{"id":"3lGGR1","date":"1578222641","viewed":1091,"name":"Dance Floor","username":"tb","description":"My take on the classic illuminated dance floor.\nIt took an embarassing long time to realise I needed additive blending, not alpha blending, to make the glow.","likes":30,"published":1,"flags":0,"usePreview":0,"tags":["square","glow","vignette"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// from https://shadertoyunofficial.wordpress.com/2019/01/02/programming-tricks-in-shadertoy-glsl/\n#define hash21(p) fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)\n\n// from https://www.shadertoy.com/view/Xt2BDc\n#define hash31(p) fract(sin(dot(p, vec3(17, 1527, 113))) * 43758.5453123)\n\n#define blend(dest, source) dest = mix(dest, vec4(source.rgb, 1.0), source.a);\n#define add(dest, source) dest += source * source.a;\n\nconst float glow_level = 0.7;\nconst float glow_attenuation = 6.0;\nconst float zoom = 2.5;\nconst float tile_radius = 0.45;\nconst float frame_level = 0.05;\nconst float lit_tile_threshold = 0.75;\nconst float unlit_tile_level = 0.15;\n\n// from https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb(in vec3 c)\n{\n    vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n// from https://iquilezles.org/articles/distfunctions2d\nfloat sdBox(in vec2 p, in vec2 b)\n{\n    vec2 d = abs(p) - b;\n    return length(max(d, vec2(0.0))) + min(max(d.x, d.y), 0.0);\n}\n\nvoid get_tile_colour(in vec2 tile_id, out vec3 tile_hsv)\n{\n    // hue\n    tile_hsv.x = hash21(tile_id);\n    // saturation\n    tile_hsv.y = 1.0;\n    // value\n    float modTime = mod(iTime, 100.0);\n    float time = floor(modTime * 2.0);\n    float level = step(lit_tile_threshold, hash31(vec3(tile_id, time)));\n    float lastLevel = step(lit_tile_threshold, hash31(vec3(tile_id, time - 1.0)));\n    level = max(level, lastLevel * (1.0 - fract(modTime * 2.0) * 1.5));\n    tile_hsv.z = level;\n}\n\n#define ADD_GLOW(tile) \\\nget_tile_colour(tile_id + tile, tile_hsv); \\\nadd(fragColor, vec4(hsv2rgb(tile_hsv), pow(1.0 - sdBox(tile - tile_coord, vec2(tile_radius)), glow_attenuation) * glow_level * tile_hsv.z));\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // normalise the coordinates\n    vec2 R = iResolution.xy, U = ((2. * fragCoord.xy) - R) / min(R.x, R.y) * zoom, FU = fract(U);\n\n    // unique ID for the tile\n    vec2 tile_id = floor(U);\n    // local tile coords [-0.5, 0.5]\n    vec2 tile_coord = FU - 0.5;\n    // distance from edge of light\n    float tile_dist = sdBox(tile_coord, vec2(tile_radius));\n\n    // render the frame\n    fragColor = vec4(vec3(frame_level), 1.0);\n\n    // get tile's colour\n    vec3 tile_hsv;\n    get_tile_colour(tile_id, tile_hsv);\n\n    // calculate a vignette to apply to the saturation (from https://www.shadertoy.com/view/lsKSWR)\n    vec2 vignette_coord = FU * (1.0 - FU.yx);\n    float vignette = sqrt(vignette_coord.x * vignette_coord.y * 5.0);\n\n    // render the tile\n    vec3 light_colour = hsv2rgb(vec3(tile_hsv.x, 1.0 - (tile_hsv.z * vignette), max(tile_hsv.z, unlit_tile_level)));\n    blend(fragColor, vec4(light_colour, step(tile_dist, 0.0)));\n    // render the tile's own glow on the frame\n    add(fragColor, vec4(hsv2rgb(tile_hsv), pow(1.0 - max(tile_dist, 0.0), glow_attenuation) * glow_level * tile_hsv.z));\n\n    // get vector to the three nearest neighbours\n    vec2 neighbours = vec2((tile_coord.x < 0.0) ? -1.0 : 1.0, (tile_coord.y < 0.0) ? -1.0 : 1.0);\n    // render the neighbours' glows\n    ADD_GLOW(neighbours)\n    ADD_GLOW(vec2(neighbours.x, 0.0))\n    ADD_GLOW(vec2(0.0, neighbours.y))\n}","name":"Image","description":"","type":"image"}]}