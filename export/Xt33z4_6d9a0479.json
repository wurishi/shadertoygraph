{"ver":"0.1","info":{"id":"Xt33z4","date":"1468083007","viewed":93,"name":"L4 - Gr","username":"bradleygriffith","description":"L4","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["shader"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_ES\nprecision mediump float;\n#endif\n\nfloat normpdf(in float x, in float sigma)\n{\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tvec4 baseSample = texture(iChannel0, uv);\n    vec4 finalColour = vec4(0.0);\n    float onePixel = 1.0 / iResolution.y;\n\n    //declare stuff\n    const int diameter = 17;\n    const int kSize = (diameter - 1) / 2;\n    float kernel[diameter];\n    \n    \n    \n    vec2 stepUV = vec2(0.0);\n    \n    vec4 stepSample = vec4(0.0);\n    vec4 darkestSample = baseSample;\n    \n    float stepDistance = 1.0;\n    float darkestDistance = 0.0;\n\n    vec2 maxDistanceUV = uv + (vec2(0.0, float(kSize) + onePixel) / iResolution.xy);\n    float maxDistance = distance(uv, maxDistanceUV);\n    \n    \n    //create the 1-D kernel\n    float sigma = 7.0;\n    float Z = 0.0;\n    for (int i = 0; i <= kSize; i++) {\n        kernel[kSize + i] = kernel[kSize - i] = normpdf(float(i), sigma);\n    }\n\n    //get the normalization factor (as the gaussian has been clamped)\n    for (int i = 0; i < diameter; i++) {\n        Z += kernel[i];\n    }\n\n    //read out the texels\n    for (int i = -kSize; i <= kSize; i++) {\n        for (int j = -kSize; j <= kSize; j++) {\n            // NOTE FOR NEXT TIME: CHANGE + to - BELOW\n            stepUV = uv + vec2(float(i), float(j)) / iResolution.xy;\n            stepSample = texture(iChannel0, stepUV, 0.0);\n            stepDistance = max(0.0, distance(uv, stepUV));\n            \n\t\t\t\t\n            float stepDarkestSampleWeight = 1.0 - smoothstep(0.0,\n                                                 \tmaxDistance,//distance(circumferenceUV, uv),\n                                                 \tstepDistance);//distance(darkestUV, uv));\n    \t\t\n            vec4 mixedStep = mix(baseSample, stepSample, stepDarkestSampleWeight);\n            \n            \n            if (mixedStep == min(darkestSample, mixedStep) && stepDistance <= maxDistance) { \n                \n\n                if (mixedStep == darkestSample) {\n                    darkestDistance = min(stepDistance, darkestDistance);\n                }\n                else {\n                    darkestDistance = stepDistance;\n                }\n                \n                //darkestUV = stepUV;\n                darkestSample = mixedStep;\n            }\n\n            \n            finalColour += kernel[kSize + j] * kernel[kSize + i] * stepSample;\n        }\n    }\n\t\n    finalColour = vec4(finalColour/(Z*Z));\n    \n    float darkestSampleWeight = 1.0 - smoothstep(0.0, maxDistance, darkestDistance);\n   \tdarkestSampleWeight = smoothstep(0.0, 0.85, darkestSampleWeight);\n    \n    \n    \n\n    float time = iTime / 1.0;\n    float heatDistanceScale = 8.0; // Larger equates to smaller spread\n    \n    \n    // Create heat points\n    // --------------------------------\n    \n    // Define 3 heat points\n    float heatPoint1X = (0.5 + sin(time * 1.05) / 4.0);\n    float heatPoint1Y = (0.5 - cos(time * 2.5) / 4.0);\n    vec2 heatPoint1Uv = vec2(heatPoint1X, heatPoint1Y);\n    \n    float heatPoint2X = (0.5 + sin(time * 1.0) / 4.0);\n    float heatPoint2Y = (0.5 - cos(time * 2.0) / 4.0);\n    vec2 heatPoint2Uv = vec2(heatPoint2X, heatPoint2Y);\n    \n    float heatPoint3X = (0.5 + sin(time * 3.0) / 4.0);\n    float heatPoint3Y = (0.5 - cos(time * 0.5) / 4.0);\n    vec2 heatPoint3Uv = vec2(heatPoint3X, heatPoint3Y);\n    \n    // Calculate distances from current UV and combine\n    float heatPoint1Dist = distance(uv, heatPoint1Uv);\n    float heatPoint2Dist = distance(uv, heatPoint2Uv);\n    float heatPoint3Dist = distance(uv, heatPoint3Uv);\n    float combinedDist = (heatPoint1Dist * heatPoint2Dist * heatPoint3Dist);\n\t\n    // Invert and scale\n    float amount = 1.0 - smoothstep(0.125, 0.625, combinedDist * heatDistanceScale);\n\n    \n    \n    \n    \n    \n    \n    \n    \n   \t//finalColour = mix(finalColour, darkestSample, darkestSampleWeight * amount);// - (0.1 * amount);\n    //finalColour = mix(finalColour, darkestSample, darkestSampleWeight);\n    finalColour = mix(baseSample, darkestSample, darkestSampleWeight * amount);// * amount);\n\n    fragColor = finalColour;\n}","name":"Image","description":"","type":"image"}]}