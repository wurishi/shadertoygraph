{"ver":"0.1","info":{"id":"cdVBWy","date":"1698614248","viewed":254,"name":"Stormring","username":"myth0genesis","description":"This is a synthesis of the knowledge gained from Chris Wallace's wonderful breakdown of volumetric rendering and demofox's blog posts about noise.\nI'm really just trying to learn more about volumetric rendering with this shader.","likes":29,"published":1,"flags":0,"usePreview":1,"tags":["noise","ray","volume","raymarch","cloud","shadow","color","blue","march","gyroid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 2023 myth0genesis\n// Stormring\n// Much of this is derived from Chris Wallace's breakdown of volumetric rendering.\n// https://wallisc.github.io/rendering/2020/05/02/Volumetric-Rendering-Part-1.html\n// Credit also goes to demofox, nimitz, and iq for the other tools and techniques used here.\n\nconst float absrb = 0.5;\nconst float abscut = 0.3;\nconst float attnfac = 1.65;\nconst int maxstpsbnd = 15;\nconst int maxstpsvol = 45;\nconst int maxstpslt = 7;\nconst float ltstplen = 0.75;\nconst float volstplen = 0.65;\nconst float mindst = 0.01;\nconst float maxdstbnd = 100.0;\nconst float i3 = 1.0 / 3.0;\nconst float i23 = 2.0 / 3.0;\nconst float grat = 0.61803400516510009765625;\nconst float itres = 1.0 / 1024.0;\nconst float ltrad = 13.0;\nconst vec3 valb = vec3(0.8);\nconst float pi = 3.1415927410125732421875;\nconst float tau = 6.283185482025146484375;\n\nmat2 rot2D(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s,\n                s,  c);\n}\n\n// I used Chris's color scheme, but changed the light\n// color selection to a case-less version.\nvec3 getLCol(float flidx) {\n    float c0 = cos(tau * flidx * i3);\n    float c1 = cos(tau * (flidx - 1.0) * i3);\n    float c2 = cos(tau * (flidx - 2.0) * i3);\n    return round(vec3(c0, c1, c0 + c2) * 0.5 + 0.5);\n}\n\nvec3 getLPos(float flidx) {\n    float ang = iTime + flidx * pi * i23;\n    return ltrad * vec3(cos(ang), -0.7, sin(ang));\n}\n\n// Credit goes to iq for the SDF here, as always.\n// https://iquilezles.org/articles/distfunctions/\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\n// A simplified 4D version of nimitz's FBM technique\n// along with the borrowed idea of alternating between\n// positive and negative displacement\n// https://www.shadertoy.com/view/3l23Rh\nfloat gyroidFBM4D(vec4 p) {\n    float d = 0.0;\n    p.w += 2.0 * iTime;\n    p *= 0.35;\n    float z = 1.7;\n    float trk = 1.0;\n    float dspAmp = 0.35;\n    for (int i = 0; i < 5; i++) {\n        p += sin(p.zwyx * 0.75 * trk) * dspAmp;\n        d -= abs(dot(cos(p), sin(p.wxyz)) * z);\n        z *= 0.5;\n        trk *= 1.5;\n        p *= 2.0;\n    }\n    return (d * 1.5 * cos(iTime));\n}\n\nfloat map(vec3 p) {\n    p.xz *= rot2D(-iTime);\n    float tor = sdTorus(p, vec2(13.0, 4.0 + 4.0 * cos(iTime + pi)));\n    float dsp = gyroidFBM4D(vec4(p, 0.0));\n    return tor + dsp;\n}\n\n// Since the bounds are marched with a low-precision variable-length raymarcher,\n// I fudged the blue noise ray offset factor here.\nfloat bndMrch(vec3 ro, vec3 rd, float rs) {\n    float dO = 0.0;\n    for (int i = 0; i < maxstpsbnd; i++) {\n        vec3 p = ro + rd * (dO + rs * 3.0);\n        float dS = map(p) * 0.5;\n        if (dO > maxdstbnd || dS < mindst) break;\n        dO += dS;\n    }\n    return dO;\n}\n\nfloat ltMrch(vec3 ro, vec3 rd, float lmt, float rs) {\n    float t = 0.0;\n    float lvis = 1.0;\n    for (int i = 0; i < maxstpslt; i++) {\n        t += ltstplen;\n        if (t > lmt || lvis < abscut) break;\n        vec3 p = ro + (t + rs * ltstplen) * rd;\n        float d = map(p);\n        if (d < 0.0) lvis *= exp(-absrb * ltstplen);\n    }\n    return lvis;\n}\n\nvec3 volMrch(vec3 ro, vec3 rd, vec4 rs) {\n    float ov = 1.0;\n    float vd = bndMrch(ro, rd, rs.x);\n    vec3 vcol = vec3(0.0);\n    for (int i = 0; i < maxstpsvol; i++) {\n        vd += volstplen;\n        vec3 p = ro + (vd + rs.y * volstplen) * rd;\n        if (map(p) < 0.0) {\n            float prov = ov;\n            ov *= exp(-absrb * volstplen);\n            float absmrch = prov - ov;\n            float flidx = 0.0;\n            for (int lidx = 0; lidx < 3; lidx++) {\n                vec3 ldir = getLPos(flidx) - p;\n                float ldst = length(ldir);\n                ldir /= ldst;\n                vec3 lcol = getLCol(flidx) * 17.0 / pow(ldst, attnfac);\n                float lvis = ltMrch(p, ldir, ldst, rs.z);\n                vcol += absmrch * lvis * valb * lcol;\n                flidx++;\n            }\n        }\n    }\n    return vcol;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\tvec2 m = (all(equal(iMouse.xy, vec2(0.0)))) ? (vec2(0.5)) : (-iMouse.xy / iResolution.xy);\n    vec3 ro = vec3(0.0, 0.0, -47.5);\n    mat2 rmxz = rot2D(m.x * tau);\n    mat2 rmyz = rot2D(m.y * tau + pi - 0.45);\n    ro.yz *= rmyz;\n    ro.xz *= rmxz;\n    vec3 rd = normalize(vec3(uv.xy, 1.0));\n    rd.yz *= rmyz;\n    rd.xz *= rmxz;\n\n// I used demofox's method for offsetting rays with golden ratio-animated blue noise.\n// https://www.shadertoy.com/view/WsfBDf\n    vec4 rs = texture(iChannel0, fragCoord * itres);\n    rs = fract(rs + float(iFrame) * grat);\n\n    vec3 col = volMrch(ro, rd, rs);\n    fragColor = vec4(pow(col, vec3(0.4545)), 1.0);\n}","name":"Image","description":"","type":"image"}]}