{"ver":"0.1","info":{"id":"DsdSDr","date":"1679906148","viewed":79,"name":"growing Tree","username":"akissing","description":"A growing tree.\nTakes some time to compile because of the for loop in sceneLeaves, could be optimized...","likes":1,"published":1,"flags":32,"usePreview":1,"tags":["tree"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    \n    vec2 mouseUV = iMouse.xy/iResolution.xy; // Range: <0, 1>\n\n\n\n    vec4 col = texture(iChannel0, uv);\n\n\n    fragColor = vec4(col);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const int MAX_MARCHING_STEPS = 255;\nconst int MAX_SHADOW_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float PI = 3.14159265359;\n\n\n\n\n\n\n// Structs\n// https://inspirnathan.com/posts/57-shadertoy-tutorial-part-11\nstruct Material {\n  vec3 ambientColor; // k_a * i_a\n  vec3 diffuseColor; // k_d * i_d\n  vec3 specularColor; // k_s * i_s\n  float alpha; // shininess\n};\n\n// https://inspirnathan.com/posts/57-shadertoy-tutorial-part-11\nstruct Surface {\n  float d;\n  Material material;\n};\n\n\n\n\n// Materials\nMaterial mGrass() {\n  vec3 aCol = 0.5 * vec3(0.24, 0.45, 0.24);\n  vec3 dCol = 0.1 * vec3(0.24, 0.45, 0.24);\n  vec3 sCol = 0.1 * vec3(1, 1, 1);\n  float a = 8.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial mLightGrass() {\n  vec3 aCol = 0.5 * vec3(0.24, 0.55, 0.24);\n  vec3 dCol = 0.1 * vec3(0.24, 0.55, 0.24);\n  vec3 sCol = 0.1 * vec3(1, 1, 1);\n  float a = 8.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial mIce() {\n  vec3 aCol = 0.4 * vec3(0.6, 0.99, 0.99);\n  vec3 dCol = 0.2 * vec3(0.6, 0.99, 0.99);\n  vec3 sCol = 0.4 * vec3(1, 1, 1);\n  float a = 5.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\n\nMaterial mTreestamp(){\n  vec3 aCol = 0.4 * vec3(0.545, 0.3529, 0.1686);\n  vec3 dCol = 0.1 * vec3(0.545, 0.3529, 0.1686);\n  vec3 sCol = 0.1 * vec3(1, 1, 1);\n  float a = 5.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\n\nMaterial mSun(){\n  vec3 aCol = vec3(0.9921, 0.7215, 0.0745);\n  vec3 dCol = vec3(0.9921, 0.7215, 0.0745);\n  vec3 sCol = vec3(0.9921, 0.7215, 0.0745);\n  float a = 1.;\n  return Material(aCol, dCol, sCol, a);\n}\n\n\nMaterial ground(){\n  vec3 aCol = 0.5 * vec3(0.5, 0.4, 0.3);\n  vec3 dCol = 0.1 * vec3(0.5, 0.4, 0.3);\n  vec3 sCol = 0.1 * vec3(1, 1, 1);\n  float a = 5.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\n\n\n\n\n// Rotation\n// https://inspirnathan.com/posts/57-shadertoy-tutorial-part-11\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\n// https://inspirnathan.com/posts/57-shadertoy-tutorial-part-11\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// https://inspirnathan.com/posts/57-shadertoy-tutorial-part-11\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// https://inspirnathan.com/posts/57-shadertoy-tutorial-part-11\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n// https://inspirnathan.com/posts/57-shadertoy-tutorial-part-11\nmat3 identity() {\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n\n\n// functions\n\n\nSurface minDistanceObj(Surface obj1, Surface obj2) {\n  if (obj2.d < obj1.d) return obj2;\n  return obj1;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\n\n\n\n//Objects\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdSphere(vec3 p, float r, vec3 offset, mat3 transform){\n  float d = length((p-offset*transform))-r;\n  return d;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCappedCone( vec3 p, float h, float r1, float r2, vec3 offset, mat3 transform){\n  vec3 pf = (p-offset) * transform;\n  vec2 q = vec2( length(pf.xz), pf.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  float d = s*sqrt( min(dot2(ca),dot2(cb)) );\n  return d;\n}\n\n\n\n\nfloat sdFloor(vec3 p) {\n  float d = p.y + 1.;\n  return d;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCapsule( vec3 p, float h, float r, vec3 offset, mat3 transform )\n{\n  p = (p - offset) * transform;\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCone( in vec3 p, in vec2 q, vec3 offset, mat3 transform )\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  p = (p - offset) * transform;\n  \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\n\n\n// https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdEllipsoid( in vec3 p, in vec3 c, in vec3 r )\n{\n#if 1\n    return (length( (p-c)/r ) - 1.0) * min(min(r.x,r.y),r.z);\n#else\n    float k0 = length((p-c)/r);\n    float k1 = length((p-c)/(r*r));\n    return k0*(k0-1.0)/k1;\n#endif    \n}\n\n\n\n//complex objects\nfloat grass(vec3 p, vec3 offset, mat3 transform){\n    p = (p - offset) * transform;\n    \n    // wöllbung\n    p.y += 0.2*exp2(-abs(2.9*p.z) );\n    p.y += 0.2*exp2(p.x);\n    \n    //breite\n    float r = 0.25;\n\n    float d = sdEllipsoid( p, vec3(0.0), vec3(2.0,0.25*r,r));\n    \n    float d2 = p.y-0.02; \n    return smax( d, -d2, 0.02 );\n}\n\n\nfloat leaf(vec3 p, vec3 offset, mat3 transform, float size){\n    p = (p - offset) * transform;\n    \n    // wöllbung\n    p.y += 0.4*exp2(-abs(2.9*p.z)) + abs(0.1*p.z);\n    p.x *= 1.;\n\n    //breite\n    float r = 0.75 * size;\n    \n    float d = sdEllipsoid( p, vec3(0.0), vec3(1.0 * size,0.25*r,r));\n    \n    float d2 = p.y-0.02; \n    return smax( d, -d2, 0.02 );\n}\n\n\n\n\n\n\n\n\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n\n\nSurface sceneGrass(vec3 p){\n  \n  Surface obj0 = Surface(sdFloor(p), ground());\n  \n  if(p.y > 2.){\n      return obj0;\n  }\n  \n  int depth = clamp(int(p.x), -16, 50);\n  int width = clamp(int(p.z), -60, 30);\n  \n  \n  float bend = clamp(sin(iTime-p.x/10.), 0., 1.)/5.;\n  if(depth > 30 || width < -40){\n      bend = 0.;\n  }\n  \n\n  \n\n  \n  for(int j = depth-3; j < depth+1; j++){\n      float offX = 0.;\n      float offZ = 0.;\n      for(int i = width-2; i < width+1; i++){\n          offX = texture(iChannel1, vec2(float(i) * 0.02 + 0.2,0.2 + float(j) * 0.02)).r * 2.;\n          offZ = texture(iChannel1, vec2(float(i) * 0.02 + 0.3,0.3 + float(j) * 0.03)).r * 2.;\n\n          Surface obj1 = Surface(grass(p, vec3(float(j)+offX,-0.5,offZ+float(i)), rotateZ(-1.6 + bend)), mGrass());\n          obj0 = minDistanceObj(obj0, obj1);\n      }\n  }\n  return obj0;\n}\n\n\nSurface drawTree(vec3 p, vec3 off, float f, Surface obj0) {\n \n  \n  if(p.x < 8. || p.x > 28. ){\n      return obj0;\n  }\n  if(p.z < -20. || p.z > -2.){\n      return obj0;\n  }\n  if(p.y > 24.){\n      return obj0;\n  }\n  \n  mat3 rotate = rotateY(1.15);\n  p = (p-off)* rotate;\n  \n  \n  Surface Treestamp = Surface(sdCappedCone(p, 1.5 * f, 0.3 * f, 0.25 * f, vec3(0. * f, 0. * f, -3.), identity()), mTreestamp());\n  \n  Surface Branchright1 = Surface(sdCappedCone(p, 0.3 * f, 0.1 * f, 0.02 * f, vec3(0.45 * f, 0.5 * f, -3.), rotateZ(8.)), mTreestamp());\n  Surface Branchright2 = Surface(sdCappedCone(p, 0.4 * f, 0.05 * f, 0.01 * f, vec3(1. * f, 0.54 * f, -3.), rotateZ(981.59)), mTreestamp());\n  \n  Surface Branchleft = Surface(sdCappedCone(p, 0.5 * f, 0.1 * f, 0.01 * f, vec3(-0.65 * f, 0.35 * f, -3.), rotateZ(30.)), mTreestamp());\n  \n  Surface Branchtopright = Surface(sdCappedCone(p, 0.9 * f, 0.2 * f, 0.01 * f, vec3(0.41 * f, 2.1 * f, -3.), rotateZ(0.55)), mTreestamp());\n  \n  Surface Branchmiddleright1 = Surface(sdCappedCone(p, 0.32 * f, 0.15 * f, 0.09 * f, vec3(0.45 * f, 1.3 * f, -3.), rotateZ(1.79)), mTreestamp());\n  Surface Branchmiddleright2 = Surface(sdCappedCone(p, 0.7 * f, 0.095 * f, 0.01 * f, vec3(1.4 * f, 1.45 * f, -3.), rotateZ(1.28)), mTreestamp());\n  \n  Surface Branchtopleft = Surface(sdCappedCone(p, 0.8 * f, 0.2 * f, 0.01 * f, vec3(-0.41 * f, 2.1 * f, -3.), rotateZ(5.75)), mTreestamp());\n  \n  Surface Branchmiddleleft1 = Surface(sdCappedCone(p, 0.36 * f, 0.15 * f, 0.09 * f, vec3(-0.45 * f, 1.2 * f, -3.), rotateZ(4.34)), mTreestamp());\n  Surface Branchmiddleleft2 = Surface(sdCappedCone(p, 0.7 * f, 0.095 * f, 0.01 * f, vec3(-1.3 * f, 1.45 * f, -3.), rotateZ(5.3)), mTreestamp());\n  \n  \n  // Fusing Elements together\n  Surface co = minDistanceObj(Treestamp, Branchright1);\n  co = minDistanceObj(co, Branchright2);\n  co = minDistanceObj(co, Branchleft);\n  co = minDistanceObj(co, Branchtopright);\n  co = minDistanceObj(co, Branchtopleft);\n  co = minDistanceObj(co, Branchmiddleright1);\n  co = minDistanceObj(co, Branchmiddleright2);\n  co = minDistanceObj(co, Branchmiddleleft1);\n  co = minDistanceObj(co, Branchmiddleleft2);\n  \n  \n  return co;\n}\n\n\n\nSurface sceneLeaves(vec3 p, vec3 offset,  Surface obj0, float growth){\n\n  vec3 initP = (p-offset);\n  vec3 off = vec3(0);\n  vec3 rotation = vec3(0);\n  \n  \n  \n  if( p.y < offset.y - 2. || p.y > offset.y + 6. ){\n      return obj0;\n  }\n  if( p.z < offset.z - 10. || p.z > offset.z + 12. ){\n      return obj0;\n  }\n  if (p.x < offset.x - 16. || p.x > offset.x + 6. ){\n      return obj0;\n  }\n\n  \n  offset.y += 3.;\n  offset.z -= 1.;\n  offset.x -= 1.;\n  \n  // check for collision with sphere\n  Surface objTmp = Surface(sdSphere(p, 4.0, offset, identity()), mIce());\n  //return minDistanceObj(obj0, objTmp);\n  if (obj0.d < objTmp.d){\n      return obj0;\n  }\n  \n  int a[5] = int[5](3,6,8,13,17);\n  \n  for(int j = 1; j < 6; j++){\n    float size = growth * pow(1.02,float(j));\n    float numLeaves = float(a[j-1]);\n    p = initP * rotateY(0.2*float(j));\n    float row = 0.02 * float(j);\n    off.y = 6. - float(j)*float(j)*0.21 * 0.5 * size;\n    rotation.z = -0.1 - float(j) * 0.13;\n    float radius = numLeaves/2. - 0.1 * numLeaves;\n    \n      for(int i = 0; i < int(numLeaves); i++){\n          off.x = size * 0.5 * radius * sin((float(i))*(2.*PI)/numLeaves);\n          off.z = size * 0.5 * radius * cos((float(i))*(2.*PI)/numLeaves);\n          rotation.y = -0.5 * PI - float(i)*(2.*PI)/numLeaves;\n              \n\n\n              float column = 0.02 * float(i);\n              float skipLeaf = texture(iChannel0, vec2(row,column)).r;\n\n\n              Surface obj1;\n              if(skipLeaf < 0.6){\n                  obj1 = Surface(leaf(p, off, rotateY(rotation.y) * rotateZ(rotation.z), size), mLightGrass());\n\n              } else {\n                  obj1 = Surface(leaf(p, off, rotateY(rotation.y) * rotateZ(rotation.z), size), mGrass());\n              }\n              obj0 = minDistanceObj(obj0, obj1);\n          }\n          \n  }\n\n  \n  \n  return obj0;\n}\n\n\n// Scene\nSurface sdScene(vec3 p) {\n  \n  Surface obj0 = sceneGrass(p);\n  \n  \n  float growth = iTime * 0.5;\n  if(growth > 6.5){\n      growth = 6.5;\n  }\n\n  obj0 = sceneLeaves(p, vec3(20. , -5. + growth*3.6, -10.25 - growth/1.5), obj0, growth/5.);\n  obj0 = sceneLeaves(p, vec3(24., -5.5 + growth*3.8, -12.0 + growth/1.1), obj0, growth/5.);\n  obj0 = sceneLeaves(p, vec3(20., -5.75 + growth*3.0, -10.5 - growth*1.65), obj0, growth*0.175);\n  obj0 = sceneLeaves(p, vec3(24., -5.5 + growth*2.8, -11.0 + growth*1.5), obj0, growth*0.175);\n  obj0 = sceneLeaves(p, vec3(20., -5.75 + growth*1.8, -10. - growth*1.2), obj0, growth*0.12);\n  obj0 = sceneLeaves(p, vec3(24., -5.5 + growth*1.8, -11.5 + growth*1.2), obj0, growth*0.12);\n  \n  obj0 = minDistanceObj(drawTree(p, vec3(20,0.+growth,-10), growth, obj0), obj0);\n  \n  p = p * rotateY(1.2);\n  Surface Sun = Surface(sdSphere(p, 3.5, vec3(20., 90., -135.), rotateZ(-iTime*0.25)*0.5), mSun());\n  obj0 = minDistanceObj(Sun, obj0);\n \n\n  return obj0;\n}\n\n\n\n\n\n\n// https://inspirnathan.com/posts/52-shadertoy-tutorial-part-6\nvec3 calcNormal(vec3 p) {\n  float e = 0.0005; // epsilon\n  return normalize(vec3(\n    sdScene(vec3(p.x + e, p.y, p.z)).d - sdScene(vec3(p.x - e, p.y, p.z)).d,\n    sdScene(vec3(p.x, p.y + e, p.z)).d - sdScene(vec3(p.x, p.y - e, p.z)).d,\n    sdScene(vec3(p.x, p.y, p.z  + e)).d - sdScene(vec3(p.x, p.y, p.z - e)).d\n  ));\n}\n\n\n\n// Inigo Quilez\n// Shadowmap\nfloat softShadow(vec3 ro, vec3 rd, float mint, float tmax) {\n  float res = 1.0;\n  float t = mint;\n  float h = sdScene(ro + rd * t).d;\n\n  for(int i = 0; i < MAX_SHADOW_MARCHING_STEPS; i++) {\n    res = min(res, 8.0*h/t);\n    t += clamp(h, 0.02, 0.10);\n    if(h < 0.001 || t > tmax) break;\n  }\n\n  return clamp( res, 0.0, 1.0 );\n}\n\n// Lighting\n// https://inspirnathan.com/posts/57-shadertoy-tutorial-part-11\nvec3 phong(vec3 lightDir, vec3 normal, vec3 rd, Material mat) {\n  // ambient\n  vec3 ambient = mat.ambientColor;\n\n  // diffuse\n  float dotLN = clamp(dot(lightDir, normal), 0., 1.);\n  vec3 diffuse = mat.diffuseColor * dotLN;\n\n  // specular\n  float dotRV = clamp(dot(reflect(lightDir, normal), -rd), 0., 1.);\n  vec3 specular = mat.specularColor * pow(dotRV, mat.alpha);\n\n  return ambient + diffuse + specular;\n}\n\n// https://inspirnathan.com/posts/57-shadertoy-tutorial-part-11\nvec3 light(vec3 p, vec3 rd, Surface co){\n    vec3 normal = calcNormal(p);\n\n    // light #1\n    \n    vec3 lightPosition1 = vec3(20,90,-133);\n    lightPosition1 = lightPosition1 * rotateZ(-iTime*0.1)*0.5;\n    vec3 lightDirection1 = normalize(lightPosition1 - p);\n    float lightIntensity1 = 0.5;\n    if (lightPosition1.y < 10.){\n        lightIntensity1 = 0.5-clamp((10.-lightPosition1.y)*0.05, 0., 0.5);\n    }\n\n    // light #2\n    vec3 lightPosition2 = vec3(-20, 5, 8);\n    vec3 lightDirection2 = normalize(lightPosition2 - p);\n    float lightIntensity2 = 0.5;\n    \n    if (lightPosition1.y < 10.){\n        lightIntensity2 = clamp(0.9-clamp((10.-lightPosition1.y)*0.05, 0., 0.5), 0., 0.5);\n    }\n\n    // final color of object\n    vec3 col = lightIntensity1 * phong(lightDirection1, normal, rd, co.material);\n    col += lightIntensity2 * phong(lightDirection2, normal , rd, co.material);\n\n    // add shadows\n    float shadow = clamp(softShadow(p, lightDirection1, 0.0001, 2.5), 0.2, 1.0);\n    float shadow2 = clamp(softShadow(p, lightDirection2, 0.0001, 2.5), 0.2, 1.0);\n\n    shadow *= (1./lightIntensity1);\n    shadow2 *= (1./lightIntensity2);\n    if (shadow > 1.) shadow = 1.;\n    if (shadow2 > 1.) shadow2 = 1.;\n\n    //col *= shadow * shadow2;\n    return col;\n}\n\n\n\n\n\n\n\n\n\n// https://inspirnathan.com/posts/57-shadertoy-tutorial-part-11\nSurface rayMarch(vec3 ro, vec3 rd, float start, float end) {\n  float depth = start;\n  Surface co;\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    co = sdScene(p);\n    depth += co.d;\n    if (co.d < PRECISION || depth > end) break;\n  }\n  co.d = depth;\n  return co;\n}\n\n// https://inspirnathan.com/posts/57-shadertoy-tutorial-part-11\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos); // camera direction\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd)); // camera right\n\tvec3 cu = normalize(cross(cd, cr)); // camera up\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy) / iResolution.y;\n\n\n    \n    vec2 mouseUV = iMouse.xy/iResolution.xy; // Range: <0, 1>\n\n    vec3 lightPosition1 = vec3(20,90,-133);\n    lightPosition1 = lightPosition1 * rotateZ(-iTime*0.25)*0.5;\n    float backgroundIntensity = 1.1;\n    float bI = 1.1;\n    if (lightPosition1.y < 10.){\n        bI -= clamp((10.-lightPosition1.y)*0.05, 0., 0.5) * 1.4;\n    }\n\n    //https://www.shadertoy.com/view/Ms2SD1\n    float e_y = (max(uv.y,0.0)*0.8+0.2)*0.8;\n    vec3 backgroundColor = vec3(pow(1.0-e_y,2.0), 1.0-e_y, 0.6+(1.0-e_y)*0.4) * bI;//1.1;\n    vec3 col = backgroundColor;\n    \n    \n\n    vec3 ro = vec3(-20, 5, 8); // ray origin that represents camera position  \n    vec3 lp = vec3(0, 5, 0); // lookat point (aka camera target)\n\n\n\n    vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n    Surface co = rayMarch(ro, rd, MIN_DIST, MAX_DIST); // distance to sphere\n    \n\n    if (co.d < MAX_DIST) {\n        vec3 p = ro + rd * co.d; // point on sphere we discovered from ray marching\n        \n        col = light(p, rd, co);\n        if ( p.y < 1.2){\n            col = mix(col, backgroundColor, 1.0 - exp(-0.00005 * co.d * co.d * 3.)); // fog\n        }\n        \n    }\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}