{"ver":"0.1","info":{"id":"X3BSWh","date":"1710497557","viewed":32,"name":"SpaceShip's pills","username":"PiouPiou","description":"TP1","likes":1,"published":1,"flags":8,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdTrapezoid( in vec2 p, in vec2 b )\n{\n    vec2 q = abs(p);\n    return max(q.y-b.y,max(q.x*0.57735+p.y*0.57735,-p.y)-b.x*0.57735);\n\n}\n\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx-3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if( h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot2(d + (c + b*t)*t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx,0.0,1.0);\n        res = min( dot2(d+(c+b*t.x)*t.x),\n                   dot2(d+(c+b*t.y)*t.y) );\n        // the third root cannot be the closest\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\n    }\n    return sqrt( res );\n}\n\nfloat opOnionCircle( in vec2 p, in float r1, in float r2)\n{\n  return abs(sdCircle(p,r1)) - r2;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec3 pelette(float t) {\n    vec3 a = vec3(0., 0., 0.);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(.5, .5, .5);\n    vec3 d = vec3(0.263, 0.416, 0.557);\n    \n    return a + 2.*b * cos( 10.28318 * (c * t + d) );\n}\n\nvec3 randomColorButtons(float t, float speed) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263, 0.416, 0.557);\n    \n    return a + 2.*b * cos( (speed+ 5.) * (c * t + d) );\n}\n\nvoid getBackground(out vec3 col, in vec2 uv) { \n    float rX = uv.x * cos(iTime) - uv.y * sin(iTime);\n    float rY = uv.x * sin(iTime) + uv.y * cos(iTime);\n    \n    float scale = 0.5;\n\n    uv += vec2(rX, rY);\n    \n    uv += clamp(sin(scale*iTime) * (1. - cos(scale*iTime)), -0.3, 0.3);\n\n    float d = length(uv);\n    \n    col = pelette(d + scale*iTime);\n    \n    d-= 0.5;\n    \n    d = cos(d*30. - scale*iTime)/30.;\n    d = abs(d);\n    \n    d = 0.005 / d;\n\n    col += d;\n}\n\nvoid getSpaceshipCockpit(inout vec3 col, in vec2 uv)\n{\n    vec3 cockpitColor = vec3(0.1, 0.1, 0.1);\n\n    vec2 boardPosition = uv;\n    boardPosition.y += 0.6;\n    vec2 boardSize = vec2(1., 0.4);\n    vec2 fittedBoardSize = boardSize / iResolution.y;\n    float board = sdTrapezoid(boardPosition, boardSize);\n    vec2 boxPosition = uv;\n    boxPosition.y += 0.7;\n    vec2 boxSize = vec2(iResolution.x, 0.3);\n    float box = sdBox(boxPosition, boxSize);\n    float ship = min(board, box);\n     if (ship < 0.01) {\n         col = cockpitColor;\n    }\n\n    // Create the wings with a bezier curve starting from the top left corner of the screen\n    // And ending at the left bottom corner of the screen\n    vec2 A = vec2(-1.8, 5.);\n    vec2 B = vec2(-0.5, 0.5);\n    vec2 C = vec2(-.45, -1.0);\n    vec2 leftWingPosition = uv;\n    leftWingPosition.y += 0.5;\n    float leftWing = sdBezier(leftWingPosition, A, B, C);\n    if (leftWing < 0.01) {\n        col = cockpitColor;\n    }\n\n    // Create the wings with a bezier curve starting from the top right corner of the screen\n    // And ending at the right bottom corner of the screen\n    A = vec2(1.8, 5.);\n    B = vec2(0.5, 0.5);\n    C = vec2(.45, -1.0);\n    vec2 rightWingPosition = uv;\n    rightWingPosition.y += 0.5;\n    float rightWing = sdBezier(rightWingPosition, A, B, C);\n    if (rightWing < 0.01) {\n        col = cockpitColor;\n    }\n}\n\nvoid getButtons(inout vec3 col, in vec2 center, int numButtons, float buttonSpacing, float timeShift)\n{\n    // Add 6 buttons to the plate\n    \n    float totalWidth = float(numButtons - 1) * buttonSpacing;\n    float startX = -totalWidth / 2.0;\n    \n    for(int i = 0; i < numButtons; i++) {\n        vec2 buttonPosition = center;\n        buttonPosition.x += startX + buttonSpacing * float(i);\n        float button = sdCircle(buttonPosition, 0.02);\n        if (button < 0.01) {\n            // Get random color\n            col = randomColorButtons(iTime + float(i), timeShift);\n        }\n    }\n}\n\nvoid getRadarView(inout vec3 col, in vec2 center, float size)\n{\n    // colors\n    vec3 radarLinesColor = vec3(0.9, 0.9, 0.9);\n    vec3 radarBackgroundColor = vec3(0.1, 0.2, 0.6);\n    vec3 radarBorderColor = vec3(0.0, 0.0, 0.0);\n    vec3 radarRotatingLineColor = vec3(0.4, 1.0, 0.2);\n\n    float thinness = 0.0001;\n\n\n    // Use a cercle to create the borders of the radar\n    vec2 radarBorderPosition = center;\n    float radarBorder = sdCircle(radarBorderPosition, size);\n    if (radarBorder < 0.01) {\n        col = radarBorderColor;\n    }\n\n    // use a cercle for the radar background\n    vec2 radarBackgroundPosition = center;\n    float radarBackground = sdCircle(radarBackgroundPosition, size - 0.015);\n    if (radarBackground < 0.01) {\n        col = radarBackgroundColor;\n    }\n\n    // Use a vertical and horizontal segment to create the cross in the middle of the radar\n    vec2 radarCrossPosition = center;\n    vec2 radarCrossSize1 = vec2(thinness, size - 0.015);\n    float radarCross1 = sdBox(radarCrossPosition, radarCrossSize1);\n    vec2 radarCrossSize2 = vec2(size - 0.015, thinness);\n    float radarCross2 = sdBox(radarCrossPosition, radarCrossSize2);\n    if (radarCross1 < 0.01 || radarCross2 < 0.01) {\n        col = radarLinesColor;\n    }\n\n    // use two thin onioncircle to create the radar circle lines\n    float radarCircle1 = opOnionCircle(center, size - 0.045, thinness);\n    float radarCircle2 = opOnionCircle(center, size - 0.045 - 0.05, thinness);\n    if (radarCircle1 < 0.01 || radarCircle2 < 0.01) {\n        col = radarLinesColor;\n    }\n\n    // Do the rotating line of the radar\n    // Create a line from the center of the radar to the edge of the radar\n    vec2 radarLinePosition = center;\n    vec2 radarLineSize = vec2(thinness, size - 0.015)*0.94;\n\n    // Rotate the line from one edge of the line\n    vec2 rotatedRadarLinePosition = vec2(radarLinePosition.x * cos(iTime) - radarLinePosition.y * sin(iTime), radarLinePosition.x * sin(iTime) + radarLinePosition.y * cos(iTime));\n    float rotatedRadarLine = sdBox(rotatedRadarLinePosition, radarLineSize);\n\n    if (rotatedRadarLine < 0.01) {\n        col = radarRotatingLineColor;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    uv *= 0.7;\n    uv.y -= 0.2;\n    \n    vec3 col;\n    getBackground(col, uv);\n    \n    // Create a basic spaceship cockpit view \n    getSpaceshipCockpit(col, uv);\n\n    // Create a button on the spaceship\n    getButtons(col, vec2(uv.x, uv.y + 0.28), 12, 0.10, 0.0);\n    getButtons(col, vec2(uv.x, uv.y + 0.37), 12, 0.12, 1.5);\n\n    getButtons(col, vec2(uv.x - 0.5, uv.y + 0.57), 6, 0.09, .2);\n    getButtons(col, vec2(uv.x - 0.5, uv.y + 0.67), 6, 0.09, 1.7);\n    getButtons(col, vec2(uv.x + 0.5, uv.y + 0.57), 6, 0.09, .2);\n    getButtons(col, vec2(uv.x + 0.5, uv.y + 0.67), 6, 0.09, 1.7);\n\n    getButtons(col, vec2(uv.x, uv.y + 0.84), 12, 0.11, .4);\n    getButtons(col, vec2(uv.x, uv.y + 0.94), 12, 0.11, 2.1);\n\n    // Create a radar view on the spaceship\n    getRadarView(col, vec2(uv.x, uv.y + 0.62), 0.15);\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Constants\n#define PI 3.14159265359\n\n// Function to generate a sine wave oscillator\nfloat sineWave(float frequency, float time) {\n    return sin(2.0 * PI * frequency * time);\n}\n\n// Function to simulate the Doppler effect\nfloat dopplerEffect(float distance, float velocity, float frequency) {\n    return frequency * (1.0 / (1.0 - (velocity / distance)));\n}\n\nvec2 mainSound(int samp, float time) {\n    // Parameters\n    float wormholeRadius = 10.0; // Radius of the wormhole\n    float playerVelocity = 5.0;  // Velocity of the player\n    float baseFrequency = 100.0; // Base frequency of the rumbling tone\n\n    // Calculate the distance from the player to the wormhole\n    vec2 fragCoord = vec2(0.5, 0.5); // Assuming the sound is centered\n    float distanceToWormhole = length(fragCoord - vec2(0.5, 0.5));\n\n    // Calculate the Doppler-shifted frequency\n    float dopplerFrequency = dopplerEffect(wormholeRadius - distanceToWormhole, playerVelocity, baseFrequency);\n\n    // Generate the rumbling tone using sine wave oscillator\n    float rumblingTone = sineWave(dopplerFrequency, time);\n\n    // Add some randomness to the tone to make it more dynamic\n    float randomFactor = sin(time * 10.0) * 0.1 + 0.9; // Random value between 0.9 and 1.1\n    rumblingTone *= randomFactor;\n\n    // Apply some modulation to create evolving sound\n    float modulationFrequency = 0.5; // Modulation frequency\n    float modulationAmount = 0.5; // Modulation amount\n    float modulation = sin(2.0 * PI * modulationFrequency * time) * modulationAmount;\n    rumblingTone *= (1.0 + modulation);\n\n    // Output the sound (stereo samples)\n    return vec2(rumblingTone * 0.5, rumblingTone * 0.5);\n}\n","name":"Sound","description":"","type":"sound"}]}