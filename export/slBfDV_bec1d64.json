{"ver":"0.1","info":{"id":"slBfDV","date":"1652985812","viewed":607,"name":"ElectronicGems","username":"stephenl7797","description":"The animation from the beginning of the Electronic Gems youtube music channel.\nThings could certainly be done better with better application of planar geometry.\nI'd like to make a version two that makes the effect more volumetric.","likes":34,"published":1,"flags":32,"usePreview":0,"tags":["lines","recreation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.);\n    col = IC0(ivec2(fragCoord)).rgb;\n    \n    // Second pass of bloom\n    /*\n    for (int j=-1; j<1; j++)\n    for (int i=-1; i<1; i++) {\n        vec2 uv1 = (fragCoord + 4.5 * vec2(float(i),float(j))) / R.xy;\n        col += clamp(C0(uv1).rgb-.1, 0.,1.) * .2;\n        //col += sqrt(clamp(C0(uv1).rgb-.2, 0.,1.)) * .1;\n        //col = max(col, C0(uv1).rgb);\n    }\n    col = clamp(col, 0., 1.);\n    */\n    \n    \n    fragColor = vec4(col,1.)  * mix(1.,rand21(.1*fragCoord),.1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n\n#define R iResolution.xy\n#define IR ivec2(iResolution.xy)\n#define C0(uv) texture(iChannel0, (uv))\n#define C1(uv) texture(iChannel1, (uv))\n#define IC0(p) texelFetch(iChannel0, (p), 0)\n#define IC1(p) texelFetch(iChannel1, (p), 0)\n#define IC2(p) texelFetch(iChannel2, (p), 0)\n\n\nfloat rand11(float x) { return fract(337.1*sin(x*22.13+11.2)); }\nfloat rand21(vec2 p) { return fract(\n    337.1*sin(22.3+27.31*p.y+p.x*22.13)); }\nvec2 rand22(vec2 p) { return fract(vec2(\n    337.1*sin(22.3+27.31*p.y+p.x*22.13),\n    437.1*sin(1.7+22.31*p.y+p.x*29.13) )); }\nvec3 rand23(vec2 p) { return fract(vec3(\n    337.1*sin(22.3+27.31*p.y+p.x*22.13),\n    437.1*sin(1.7+22.31*p.y+p.x*29.13),\n    407.1*sin(111.7+12.31*p.y+p.x*19.13) )); }\nvec3 rand33(vec3 p) { return fract(vec3(\n    337.1*sin(22.3+27.31*p.y+p.x*22.13+p.z*19.2),\n    437.1*sin(1.7+22.31*p.y+p.x*29.13+p.z*10.3),\n    407.1*sin(111.7+12.31*p.y+p.x*19.13+p.z*8.2) )); }\n\nfloat distanceToLine(vec3 p1, vec3 p2, vec3 q) {\n    return length(cross(q-p1, q-p2)) / length(p1-p2);\n}\nfloat distanceToLine(vec2 p1, vec2 p2, vec2 q) {\n    return abs((p2.x-p1.x)*(p1.y-q.y) - (p1.x-q.x)*(p2.y-p1.y)) / length(p2-p1);\n}\nfloat distanceToLine(vec2 a, vec2 b, vec2 q, inout vec2 p, inout float t) {\n    t = dot(q-a, normalize(b-a)) / distance(a,b);\n    t = clamp(t, 0., 1.);\n    p = a + t * (b-a);\n    return distance(p,q);\n}\n\nfloat distanceToLineSegment(vec3 a, vec3 b, vec3 q, inout vec3 p, inout float t) {\n    t = dot(q-a, normalize(b-a)) / distance(a,b);\n    t = clamp(t, 0., 1.);\n    p = a + t * (b-a);\n    return distance(p,q);\n}\n\n\nconst float CAM_DIST = 4.;\nconst float FOCAL_COEFF = 1.60;\n\n\nfloat xsect_sphere(vec3 ro, vec3 rd, float radius) {\n    float a = dot(rd,rd);\n    float b = 2. * dot(rd,ro);\n    float c = dot(ro,ro) - radius;\n    float discrim = b*b - 4.*a*c;\n    if (discrim < 0.) return 0.;\n    float t1 = -b + sqrt(b*b - 4.*a*c);\n    float t2 = -b - sqrt(b*b - 4.*a*c);\n    return min(t1,t2) / 2.*a;\n}\n\nvec2 randVor22(vec2 g, float iTime) {\n//g += iTime * .00001;\n//float a = sin(iTime)*.5+.5;\nconst float a = 1.0;\nreturn rand22(g) * a + .5 - .5 * a;\n}\n\n\n\n\nvec2 proj(vec3 p, vec2 focal, float tt) {\n    return p.xy * focal / (p.z - tt);\n}\n\n\n\nfloat hashXY(ivec2 xy, ivec2 ir) {\n    return float(xy.y * ir.x + xy.x);\n}\nivec2 unhashXY(int h, ivec2 ir) {\n    return ivec2(h%ir.x, h/ir.x);\n}\n\n\n\n    \n//float smoo(float v) { return v*v*(3.-2.*v); }\nfloat smoo(float v) { return v; }\nvec3 noise33(vec3 x) {\n    vec3 o = vec3(0.);\n    vec3 fx = floor(x);\n    vec3 lx = fract(x);\n    for (int i=0; i<8; i++) {\n        float dx = (i  ) % 2 == 0 ? 1. : 0.;\n        float dy = (i/2) % 2 == 0 ? 1. : 0.;\n        float dz = (i/4) % 2 == 0 ? 1. : 0.;\n        vec3 v  = rand33(fx + vec3(dx,dy,dz));\n        vec3 d = vec3(dx,dy,dz) * 2. * lx + 1. - lx - vec3(dx,dy,dz);\n        o += smoo(d.x)*smoo(d.y)*smoo(d.z)*v;\n    }\n    return o;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nconst float FOCAL = 1.15;\nfloat doOneLine(vec2 uv, vec3 a, vec3 b) {\n    float f = 0.;\n    vec2 pa = proj(a, vec2(FOCAL), -4.);\n    vec2 pb = proj(b, vec2(FOCAL), -4.);\n    vec2 d;\n    float t;\n    float dd = distanceToLine(pa,pb,uv,d,t);\n    f = exp(-dd*405.);\n    return f;\n}\n\n\n// Make a light-ray like effect for rays passing from origin to\n// the point the pixel projects to on the plane spanning\n// a and b.\nfloat doOneLineGlow(vec2 uv, vec3 a, vec3 b, inout vec3 planePt) {\n    vec3 ctr = vec3(0.,0.,sin(iTime)*2.5).xzy;\n    ctr *= 0.;\n    \n    vec2 pa = proj(a, vec2(FOCAL), -4.);\n    vec2 pb = proj(b, vec2(FOCAL), -4.);\n    vec2 pc;\n    float t;\n    float d = distanceToLine(pa,pb,uv,pc,t);\n    \n    vec4 pi = vec4(0.); // normal+dist\n    pi.xyz = normalize(cross(a-ctr,b-ctr));\n    \n    vec3 ray = normalize(vec3(uv,FOCAL));\n    vec3 eye = vec3(0.,0.,-4.);\n    float den = (dot(pi.xyz,ray));\n\n    vec3 x = eye + ray * -(dot(pi.xyz,eye))/den;\n    \n    // TODO: Should immediately go into 2d mode here.\n    // The solution here is to project on the 3d line, but that isn't as good.\n    if (abs(dot(pi.xyz,ray)) < .04 && d < .005) {\n        // Plane intersection is ill-posed\n        // https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection#In_more_than_two_dimensions\n        vec3 n1 = normalize(b-a), p1 = a;\n        vec3 n2 = ray, p2 = eye;\n        mat3 A = (2.*mat3(1.0) - outerProduct(n1,n1) - outerProduct(n2,n2));\n        x = inverse(A) * (\n            (mat3(1.0) - outerProduct(n1,n1)) * p1 +\n            (mat3(1.0) - outerProduct(n2,n2)) * p2);\n        \n    }\n    planePt = x;\n    \n    vec3 closestPt;\n    float ld = distanceToLineSegment(a,b,x,closestPt,t);\n\n    // Remove portions of the light ray that do not pass through the 3d line.\n    // This is done by rotating a,b, and x to make it a 2d problem,\n    // then using atan to make sure that x is inbetween a and b.\n    // Is there a way without atan?\n    vec3 n = pi.xyz;\n    //mat3 P = mat3(1.0) - outerProduct(n,n); // No need: pts on plane already\n    mat2x3 RR_;\n    RR_[0] = normalize(cross(n,(a+b))); \n    RR_[1] = normalize(cross(n,RR_[0]));\n    mat3x2 RR = transpose(RR_);\n    vec3 ctr1 = ctr;\n    vec2 ta = (RR * (a-ctr1)).xy;\n    vec2 tb = (RR * (b-ctr1)).xy;\n    vec2 tx = (RR * (x-ctr1)).xy;\n    float aa = atan(ta.y,ta.x);\n    float ab = atan(tb.y,tb.x);\n    float ax = atan(tx.y,tx.x);\n    // Exaggerate when viewing ray is aligned with plane direction\n    float f = .25*.7 / (abs(den) + .05);\n    \n    if ((ax < min(aa,ab) || ax > max(aa,ab))) f *= 0.4;\n    // Softer rays\n    float angled = .0;\n    // I am truly stumped on why the rays near vertices are brighter...\n    // But it is in the source material anyway\n    if (ax < min(aa,ab)) angled = max(angled,min(aa,ab) - ax);\n    if (ax > max(aa,ab)) angled = max(angled,ax - max(aa,ab));\n    f *= smoothstep(.06 + .03*(1.+sin(.77*iTime+x.x)), 0.0, abs(angled));\n    if (distance(closestPt,ctr) > distance(x,ctr)) f = 0.;\n    \n    \n    f = f * exp(-distance(vec3(0.,0.,-4.), x)*.1);\n    f = f * exp(-distance(ctr, x)*.6);\n    f = f * exp(-ld);\n    \n    return f;\n}\n\n\nvec3 doLines(vec2 uv) {\n    float f = 0.;\n    \n    float t = iTime * .14;\n    mat3 RR = mat3(\n        vec3(cos(t),0.,sin(t)),\n        vec3(0.,1.,0.),\n        vec3(-sin(t),0.,cos(t)));\n    \n#define DIAMOND\n#ifndef DIAMOND\n    // Basic scene I started with\n    vec3 lines3[] = vec3[6](\n        vec3(-1.,-1.,0.), vec3(-1.,1.,0.),\n        vec3(1.,-1.,0.), vec3(1.,1.,0.),\n        vec3(2.5,-1.,1.), vec3(-0.5,1.,1.)\n    );\n    \n    for (int i=0; i<lines3.length(); i+=2) {\n        f += doOneLine(uv, RR*lines3[i], RR*lines3[i+1]);\n        vec3 pt;\n        f += doOneLineGlow(uv, RR*lines3[i], RR*lines3[i+1],pt)*3.;\n    }\n#else\n\n    // This is bad. I should use a cylindrical mapping here,\n    // but it was easier to modify a spherical one and hack the points after.\n    int indsPerSet[] = int[](\n        // Internal\n        0,1, 0,2,\n        1,3,1,4, 2,4,2,5,\n        3,6,3,4, 4,6,4,7, 5,4,5,7,\n        6,8,7,8\n        // Linking to neighbor\n        // todo\n    );\n    \n    vec2 vertsByInd[] = vec2[](\n        vec2(0.),\n        \n        vec2(-.85,-.65),\n        vec2(.85,-.65),\n        \n        vec2(-1.5,-1.1),\n        vec2(0.,-1.1),\n        vec2(1.5,-1.1),\n        \n        vec2(-.75,-2.),\n        vec2(.75,-2.),\n        \n        vec2(-0.,-4.)\n    );\n    float rMultByInd[] = float[](\n        1.,\n        1.,1.,\n        \n        1.,1.,1.,\n        \n        .475,.475,\n        1.);\n    \n    float lineAmnt = 0.;\n    int nSets = 5;\n    float setStep = 1. / float(nSets);\n    for (int si=0; si<nSets; si++) {\n        for (int ii=0; ii<indsPerSet.length(); ii+=2) {\n            int i = indsPerSet[ii], j = indsPerSet[ii+1];\n            \n            vec2 aa = vertsByInd[i] / vec2(3.*float(nSets),4.), bb = vertsByInd[j] / vec2(3.*float(nSets),4.);\n            aa = 3.141*1.0 * (aa + vec2(float(si)*setStep,0.));\n            bb = 3.141*1.0 * (bb + vec2(float(si)*setStep,0.));\n            aa.x *= 2.;\n            bb.x *= 2.;\n            vec3 a = vec3(cos(aa.x)*sin(aa.y), sin(aa.x)*sin(aa.y), cos(aa.y));\n            vec3 b = vec3(cos(bb.x)*sin(bb.y), sin(bb.x)*sin(bb.y), cos(bb.y));\n            a=a.xzy; b=b.xzy;\n            a.xz *= rMultByInd[i] * 1.5;\n            b.xz *= rMultByInd[j] * 1.5;\n            a.y += -.21;\n            b.y += -.21;\n            float mul = .250;\n            \n            \n            vec3 planePt;\n            float glow = .9*doOneLineGlow(uv, RR*a.xyz, RR*b.xyz, planePt);\n            float mainFlicker = sin(iTime*2.5 - planePt.x*1.5*(.5+sin(float(iTime))*.91)\n                                - planePt.z*.2*(.5+sin(float(iTime))*.41)) * .4 + 1.;\n            mul = exp(-clamp(distance(planePt, vec3(0.,0.,-2.1))-1.5, .7,111099999.)*2.965)*3.1;\n\n            f += glow * pow(mainFlicker,2.) * clamp(mul*4.,0.,1.) * mul*3.;\n            lineAmnt = max(lineAmnt, doOneLine(uv, RR*a.xyz, RR*b.xyz) * mul * (mainFlicker*.7+.5));\n        }\n    }\n    f += lineAmnt*2.2;\n#endif\n    \n    return vec3(f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-R.xy*.5)/R.yy;\n\n    vec3 col = vec3(doLines(uv));\n\n    // chromatic aberration and make a little glitchy\n    if (true) {\n        vec3 scol = vec3(0.);\n        float tt = iTime + uv.x * 9.;\n        mat2 jiggle = pow(sin(tt*.567),3.)*1.7*(sin(tt)*.5+.7)*mat2(cos(tt), sin(tt), -sin(tt)+3.*(1.5+sin(uv.y*(uv.x+.5)*2.)), cos(tt));\n        scol += IC0(ivec2(fragCoord+jiggle*vec2(1.,.5))).rgb*vec3(1.,0.,.2);\n        scol += IC0(ivec2(fragCoord+jiggle*vec2(-.9,.7))).rgb*vec3(0.,.6,.2);\n        scol += IC0(ivec2(fragCoord+jiggle*vec2(.1,-.7))).rgb*vec3(0.,.4,.6);\n        col = mix(col, scol, .6);\n    } else {\n        col = mix(col, IC0(ivec2(fragCoord)).rgb, .6);\n    }\n    \n    // Do bloom\n    col *= .9;\n    for (int j=-1; j<1; j++)\n    for (int i=-1; i<1; i++) {\n        vec2 uv1 = (fragCoord + 1.5 * vec2(float(i),float(j))) / R.xy;\n        col += clamp(C0(uv1).rgb-.1, 0.,1.) * .04;\n    }\n    \n    col = clamp(col, 0., 1.);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}