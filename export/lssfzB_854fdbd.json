{"ver":"0.1","info":{"id":"lssfzB","date":"1496926658","viewed":103,"name":"moving_camera","username":"phuidn","description":"testing a moving camera","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","camera","matrix"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPS (0.0005)\n\nfloat sphereSDF(vec3 point, vec3 centre, float radius)\n{\n \treturn (length(centre - point) - radius);   \n}\n\nfloat cubeSDF(vec3 point, vec3 centre, float side_length)\n{\n    point -= centre;\n    float half_side = side_length * 0.5;\n    \n \treturn max(max(abs(point.x) - half_side, abs(point.y) - half_side),\n               abs(point.z) - half_side);\n}\n\nfloat sceneSDF(vec3 point)\n{\n    float dist;\n    float big_sphere_rad = 0.9,\n          small_sphere_rad = 0.3,\n          sphere_pos = 1.0 + 0.7 * sin(iTime);\n    \n    dist = cubeSDF(point, vec3(0,0,0), 2.0);\n    \n    dist = max(dist, -sphereSDF(point, vec3(sphere_pos,0,0), big_sphere_rad));\n    dist = max(dist, -sphereSDF(point, vec3(-sphere_pos,0,0), big_sphere_rad));\n    dist = max(dist, -sphereSDF(point, vec3(0, sphere_pos,0), big_sphere_rad));\n    dist = max(dist, -sphereSDF(point, vec3(0, -sphere_pos,0), big_sphere_rad));\n    dist = max(dist, -sphereSDF(point, vec3(0, 0, sphere_pos), big_sphere_rad));\n    dist = max(dist, -sphereSDF(point, vec3(0, 0, -sphere_pos), big_sphere_rad));\n\n    dist = min(dist, sphereSDF(point, vec3(sphere_pos,0,0), small_sphere_rad));\n    dist = min(dist, sphereSDF(point, vec3(-sphere_pos,0,0), small_sphere_rad));\n    dist = min(dist, sphereSDF(point, vec3(0, sphere_pos,0), small_sphere_rad));\n    dist = min(dist, sphereSDF(point, vec3(0, -sphere_pos,0), small_sphere_rad));\n    dist = min(dist, sphereSDF(point, vec3(0, 0, sphere_pos), small_sphere_rad));\n    dist = min(dist, sphereSDF(point, vec3(0, 0, -sphere_pos), small_sphere_rad));           \n    \n    return dist;\n}\n\nvec3 normalEstimate(vec3 point)\n{\n    vec3 dx = vec3(EPS, 0, 0),\n         dy = vec3(0, EPS, 0),\n         dz = vec3(0, 0, EPS);\n    \n \treturn normalize(vec3(sceneSDF(point + dx) - sceneSDF(point - dx),\n                          sceneSDF(point + dy) - sceneSDF(point - dy),\n                          sceneSDF(point + dz) - sceneSDF(point - dz)));\n}\n\n\nmat4 transformMat(vec3 position, vec3 lookAt, vec3 up)\n{\n    vec3 z_c = -normalize(lookAt - position),\n         x_c = normalize(cross(up, z_c)),\n         y_c = normalize(cross(z_c, x_c));\n    \n    return mat4( vec4(x_c, 0),\n                 vec4(y_c, 0),\n                 vec4(z_c, 0),\n                 vec4(position, 1) );\n}\n\nvec3 pathVector(float fov_angle, vec2 px_coord, vec3 resolution)\n{\n \tvec2 xy = (px_coord - 0.5 * resolution.xy);\n    float z = -resolution.x / (2.0 * tan(radians(fov_angle) * 0.5));\n\t\n    return normalize(vec3(xy, z));\n}\n\nfloat closestDistance(vec3 camera, vec3 rayVec, float minDist, float maxDist)\n{\n \tfloat dist,\n          totDist = minDist;\n    \n    int max_its = 300;\n    \n    for (int i = 0; i < max_its; i++)\n    {\n    \tdist = sceneSDF(camera + totDist * rayVec);\n        totDist += dist;\n        \n        if (totDist > maxDist)\n        {\n         \treturn maxDist;   \n        }\n        if (dist < EPS)\n        {\n         \treturn totDist;   \n        }\n    }\n    \n    return maxDist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float camera_rad = 6.0,\t\n          x = camera_rad * cos (0.5 * iTime),\n          z = camera_rad * sin (0.5 * iTime),\n          y = 0.0;\n    \n\tvec3 camera_pos =  vec3(x,y,z);\n    vec3 initial_path = pathVector(60.0, fragCoord, iResolution);\n    mat4 camera_to_world = transformMat(camera_pos, vec3(0), vec3(0,1,0));\n    \n    float minDist = 0.1,\n  \t\t  maxDist = 10.0;\n    \n    initial_path = (camera_to_world * vec4(initial_path,0)).xyz;\n    \n    float dist = closestDistance(camera_pos, initial_path, minDist, maxDist);\n    \n    if (dist > maxDist - EPS)\n    {\n     \tfragColor = vec4(0,0,0,0);   \n        return;\n    }\n    \n    vec3 scene_point = camera_pos + dist * initial_path;\n    \n    fragColor = vec4(0.5 * (normalEstimate(scene_point) + 1.0), 1.0);\n    \n\n}\n\n","name":"Image","description":"","type":"image"}]}