{"ver":"0.1","info":{"id":"4djBzR","date":"1499140621","viewed":484,"name":"Inkspot","username":"sparrow","description":"'Larger than life' is a family of cellular automata which includes conway's game of life.\nFor more information, see http://www.csun.edu/~kme52026/thesis.html\n\nThis is LTL Rule 1,3,3,1,9","likes":20,"published":1,"flags":32,"usePreview":0,"tags":["cellularautomata"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    // Moving average is stored in green channel\n    float s = texture(iChannel0, uv).g;\n    float v = 1.0;\n    if (s == 0.0) {\n        v = 0.0;\n    }\n    vec3 purple = vec3(86.0, 20.0, 176.0) / 255.0;\n    vec3 gold = vec3(219.0, 214.0, 92.0) / 255.0;\n\n    vec3 col = smoothstep(gold, purple, vec3(mod(s + 0.5, 1.0))) * v;\n  \tfragColor = vec4(col, 1.0); \n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// http://www.csun.edu/~kme52026/invariant.html\n\nstruct LTLRule {\n    float r;\n    float b1;\n    float b2;\n    float d1;\n    float d2;\n};\n    \n/**\n * Renders initial state on startup or mouse click.\n *\n * Draw a circle at vec2 `pos` with radius `rad` and\n * color `color`.\n */\nvec4 circle(vec2 uv, vec2 pos, float rad, vec3 color) {\n\tfloat d = length(pos - uv) - rad;\n\tfloat t = clamp(d, 0.0, 1.0);\n\treturn vec4(color, 1.0 - t);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // This is LTL rule 1,3,3,1,9\n    // I adjusted the boundaries to be tolerant of floating-point imprecision and\n    // interpolation issues, neighborhood totals are not guaranteed to be exact.\n    const LTLRule rule = LTLRule(1.0, 2.9, 3.1, 0.9, 8.9);\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float total = 0.0;\n    for (float dx = -rule.r; dx <= rule.r; dx++) {\n      for (float dy = -rule.r; dy <= rule.r; dy++) {\n        vec2 txy = mod((fragCoord.xy + vec2(dx,dy)) / iResolution.xy, 1.0);\n        float val = texture(iChannel0, txy).x; \n        total += val;\n      }\n    }\n\n   vec2 stateAndAvg = texture(iChannel0, uv).xy;\n   float s = stateAndAvg.x;\n   float c = s;\n   if (s == 0.0) {\n       if (total >= rule.b1 && total <= rule.b2) {\n           c = 1.0;\n       }\n   } else {\n       if (total < rule.d1 || total > rule.d2) {\n           c = 0.0;\n       }\n   }\n\n   if (iFrame < 20 || iMouse.z > 0.) {\n\t   vec2 center = iResolution.xy * 0.5;\n       vec2 mouse = iMouse.xy;\n       float radius = 30.0;\n       if (iMouse.z > 0.) {\n           radius = max(distance(mouse, center), radius);\n       }\n       // Background layer\n\t   vec4 layer1 = vec4(1.0, 1.0, 1.0, 1.0);\n\t   // Circle\n\t   vec4 layer2 = circle(fragCoord.xy, center, radius, vec3(0.0, 0.0, 0.0));\n\t   // Blend\n\t   fragColor = mix(layer1, layer2, layer2.a);\n   } else {\n      fragColor = vec4(c, mod(stateAndAvg.y + (c / 196.0), 1.0), 0.0, 1.0);\n   }\n}\n","name":"Buf A","description":"","type":"buffer"}]}