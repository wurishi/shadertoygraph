{"ver":"0.1","info":{"id":"fdKfDc","date":"1659461633","viewed":131,"name":"Candy Land","username":"EisernSchild","description":" \"Candy Land [DXR] : Raytraced procedural sweets\"\n https://github.com/EisernSchild/D3D12-Tech-Demo\n    \n It is based on IQs intersectors and his signed distance ellipse function to build a bended, endless cylinder.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Candy Land\n// Copyright (c) 2022 by Denis Reischl\n//\n// SPDX-License-Identifier: MIT\n\n// uses code with following rights :\n// Copyright (c) Microsoft\n// Copyright (c) 2013 Inigo Quilez\n// \n// SPDX-License-Identifier: MIT\n\n/*\n    \n    This is a WebGL conversion of my D3D12/DXR tech demo\n    \"Candy Land [DXR] : Raytraced procedural sweets\".\n    \n    You find the original (c++/hlsl) code on:\n    https://github.com/EisernSchild/D3D12-Tech-Demo\n    \n    It is based on IQs intersectors and his signed distance\n    ellipse function to build a bended, endless cylinder.\n    \n*/\n\n// scene primitives\n#define CandyLoop uint(0)\n#define CandyDrops uint(1)\n#define TaffyCandy uint(2)\n#define Mallow uint(3)\n#define Horizon uint(4)\n\n// ray hit attribute\nstruct PosNorm\n{\n\tvec3 vPosition;\n\tvec3 vNormal;\n    vec2 vColor;\n    uint uPrimI;\n};\n\n// max ray steps\nconst uint uMaxSteps = uint(255);\n// ray min/max distance\nconst float fTMin = 0.f, fTMax = 200.f;\n// adjust raysteps to avoid flaws\nconst float fStepAdjust = .8f;\n// treshold = min factor to provide hit\nconst float fThreshold = 0.00001;\n\n// signed distance functions https://iquilezles.org/articles/distfunctions/\n\n// 2D ellipse\nfloat sdEllipse(vec2 vPos, vec2 vAB)\n{\n\tvec2 pAbs = abs(vPos);\n\tvec2 vABi = 1.0 / vAB;\n\tvec2 vAB2 = vAB * vAB;\n\tvec2 vVe = vABi * vec2(vAB2.x - vAB2.y, vAB2.y - vAB2.x);\n\n\tvec2 vT = vec2(0.70710678118654752, 0.70710678118654752);\n\tfor (int nI = 0; nI < 3; nI++) {\n\t\tvec2 vV = vVe * vT * vT * vT;\n\t\tvec2 vU = normalize(pAbs - vV) * length(vT * vAB - vV);\n\t\tvec2 vW = vABi * (vV + vU);\n\t\tvT = normalize(clamp(vW, 0.0, 1.0));\n\t}\n\n\tvec2 vNextAbs = vT * vAB;\n\tfloat fDis = length(pAbs - vNextAbs);\n\treturn dot(pAbs, pAbs) < dot(vNextAbs, vNextAbs) ? -fDis : fDis;\n}\n\n// bend a cylinder based on tangent distance - bound\nfloat sdCylinderBent(vec3 vPos, vec2 vC, float fR, float fD)\n{\n\t// https://mathworld.wolfram.com/CylindricalSegment.html\n\t//\n\tfloat fA = 2. * fR + sqrt(pow(2. * fR, 2.) + pow(fD, 2.));\n\tfloat fB = 2. * fR;\n\n\treturn sdEllipse(vPos.xy - vC.xy, vec2(fB, fA));\n}\n\n// intersectors https://iquilezles.org/articles/intersectors\n\n// ellipsoid centered at the origin with radii vRad\nfloat iEllipsoid(in vec3 vOri, in vec3 vDir, in vec3 vCen, in vec3 vRad)\n{\n\tvec3 vOc = vOri - vCen;\n\n\tvec3 vOcn = vOc / vRad;\n\tvec3 vRdn = vDir / vRad;\n\n\tfloat fA = dot(vRdn, vRdn);\n\tfloat fB = dot(vOcn, vRdn);\n\tfloat fC = dot(vOcn, vOcn);\n\tfloat fH = fB * fB - fA * (fC - 1.0);\n\tif (fH < 0.0) return -1.0;\n\treturn (-fB - sqrt(fH)) / fA;\n}\n\n// intersect a ray with a rounded box\nfloat iRoundedBox(in vec3 vOri, in vec3 vDir, in vec3 vCen, in vec3 vSize, in float fRad)\n{\n\tvec3 vOc = vOri - vCen;\n\n\t// bounding box\n\tvec3 m = 1.0 / vDir;\n\tvec3 n = m * vOc;\n\tvec3 k = abs(m) * (vSize + fRad);\n\tvec3 t1 = -n - k;\n\tvec3 t2 = -n + k;\n\tfloat tN = max(max(t1.x, t1.y), t1.z);\n\tfloat tF = min(min(t2.x, t2.y), t2.z);\n\tif (tN > tF || tF < 0.0) return -1.0;\n\tfloat t = tN;\n\n\t// convert to first octant\n\tvec3 pos = vOc + t * vDir;\n\tvec3 s = sign(pos);\n\tvOc *= s;\n\tvDir *= s;\n\tpos *= s;\n\n\t// faces\n\tpos -= vSize;\n\tpos = max(pos.xyz, pos.yzx);\n\tif (min(min(pos.x, pos.y), pos.z) < 0.0) return t;\n\n\t// some precomputation\n\tvec3 oc = vOc - vSize;\n\tvec3 dd = vDir * vDir;\n\tvec3 oo = oc * oc;\n\tvec3 od = oc * vDir;\n\tfloat ra2 = fRad * fRad;\n\n\tt = 1e20;\n\n\t// corner\n\t{\n\t\tfloat b = od.x + od.y + od.z;\n\t\tfloat c = oo.x + oo.y + oo.z - ra2;\n\t\tfloat h = b * b - c;\n\t\tif (h > 0.0) t = -b - sqrt(h);\n\t}\n\n\t// edge X\n\t{\n\t\tfloat a = dd.y + dd.z;\n\t\tfloat b = od.y + od.z;\n\t\tfloat c = oo.y + oo.z - ra2;\n\t\tfloat h = b * b - a * c;\n\t\tif (h > 0.0)\n\t\t{\n\t\t\th = (-b - sqrt(h)) / a;\n\t\t\tif (h > 0.0 && h < t && abs(vOc.x + vDir.x * h) < vSize.x) t = h;\n\t\t}\n\t}\n\t// edge Y\n\t{\n\t\tfloat a = dd.z + dd.x;\n\t\tfloat b = od.z + od.x;\n\t\tfloat c = oo.z + oo.x - ra2;\n\t\tfloat h = b * b - a * c;\n\t\tif (h > 0.0)\n\t\t{\n\t\t\th = (-b - sqrt(h)) / a;\n\t\t\tif (h > 0.0 && h < t && abs(vOc.y + vDir.y * h) < vSize.y) t = h;\n\t\t}\n\t}\n\t// edge Z\n\t{\n\t\tfloat a = dd.x + dd.y;\n\t\tfloat b = od.x + od.y;\n\t\tfloat c = oo.x + oo.y - ra2;\n\t\tfloat h = b * b - a * c;\n\t\tif (h > 0.0)\n\t\t{\n\t\t\th = (-b - sqrt(h)) / a;\n\t\t\tif (h > 0.0 && h < t && abs(vOc.z + vDir.z * h) < vSize.z) t = h;\n\t\t}\n\t}\n\n\tif (t > 1e19) t = -1.0;\n\n\treturn t;\n}\n\n// intersect capsule\nfloat iCapsule(in vec3 vOri, in vec3 vDir, in vec3 vCen, in vec3 pa, in vec3 pb, in float r)\n{\n\tvec3 vOc = vOri - vCen;\n\n\tvec3  ba = pb - pa;\n\tvec3  oa = vOc - pa;\n\n\tfloat baba = dot(ba, ba);\n\tfloat bard = dot(ba, vDir);\n\tfloat baoa = dot(ba, oa);\n\tfloat rdoa = dot(vDir, oa);\n\tfloat oaoa = dot(oa, oa);\n\n\tfloat a = baba - bard * bard;\n\tfloat b = baba * rdoa - baoa * bard;\n\tfloat c = baba * oaoa - baoa * baoa - r * r * baba;\n\tfloat h = b * b - a * c;\n\tif (h >= 0.0)\n\t{\n\t\tfloat t = (-b - sqrt(h)) / a;\n\t\tfloat y = baoa + t * bard;\n\t\t// body\n\t\tif (y > 0.0 && y < baba) return t;\n\t\t// caps\n\t\tvec3 oc = (y <= 0.0) ? oa : vOc - pb;\n\t\tb = dot(vDir, oc);\n\t\tc = dot(oc, oc) - r * r;\n\t\th = b * b - c;\n\t\tif (h > 0.0) return -b - sqrt(h);\n\t}\n\treturn -1.0;\n}\n\n// normal function for intersected ellipsoid\nvec3 nEllipsoid(in vec3 vPos, in vec3 vCen, in vec3 vRad)\n{\n\treturn normalize((vPos - vCen) / (vRad * vRad));\n}\n\n// normal of a rounded box\nvec3 nRoundedBox(in vec3 vPos, in vec3 vCen, in vec3 vSiz)\n{\n\tvec3 vPc = vPos - vCen;\n\treturn sign(vPc) * normalize(max(abs(vPc) - vSiz, 0.0));\n}\n\n// normal of a capsule\nvec3 nCapsule(in vec3 vPos, in vec3 vCen, in vec3 a, in vec3 b, in float r)\n{\n\tvec3 vPc = vPos - vCen;\n\tvec3  ba = b - a;\n\tvec3  pa = vPc - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn (pa - h * ba) / r;\n}\n\n// circular repitition, moved to and shifted within aa bounding box \nfloat iCircularEllipsoids(in vec3 vOri, in vec3 vDir, in float fRad, in float fSpc, out vec3 vNormal, out vec2 vIdH, in float fTime)\n{\n\tfloat fThit = -1.f;\n\tint nRad = int(fRad);\n\t\n\t// loop through grid int2(2*Rad, 2*Rad) \n\tfor (int nJ = -nRad; nJ <= nRad; nJ++)\n\t\tfor (int nI = -nRad; nI <= nRad; nI++)\n\t\t{\n\t\t\t// is in radius ?\n\t\t\tvec2 vId = vec2(nI, nJ);\n\t\t\tif (dot(vId, vId) <= fRad * fRad)\n\t\t\t{\n\t\t\t\t// shift origin\n\t\t\t\tvec3 vQ = vOri - fSpc * vec3(vId.x, 0.f, vId.y);\n\n\t\t\t\t// rotate and lift ellipsoid\n\t\t\t\tfloat fC = sqrt(dot(vId, vId));\n\t\t\t\tvec3 vRad = (fC < (fRad * .33)) ? vec3(1.f, 1.5f, 1.f) : (fC < (fRad * .66)) ? vec3(1.5f, 1.f, 1.f) : vec3(1.f, 1.f, 1.5f);\n\t\t\t\tvRad *= fSpc * .08f;\n\t\t\t\tvec3 vPosE = vec3(12.f, 1.5f + fC * sin(fTime * fC) * .2f, -32.f);\n\n\t\t\t\t// ellipsoid intersection ?\n\t\t\t\tfloat fH1 = iEllipsoid(vQ, vDir, vPosE, vRad);\n\t\t\t\tif (fH1 >= 0.f)\n\t\t\t\t{\n\t\t\t\t\t// set nearest hit\n\t\t\t\t\tfThit = (fThit >= 0.f) ? min(fThit, fH1) : fH1;\n\n\t\t\t\t\t// nearest == current ?\n\t\t\t\t\tif (fThit == fH1)\n\t\t\t\t\t{\n\t\t\t\t\t\tvec3 vPosition = vQ + fThit * vDir;\n\t\t\t\t\t\tvNormal = nEllipsoid(vPosition, vPosE, vRad);\n\t\t\t\t\t\tvIdH = vId;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\treturn fThit;\n}\n\n// function to bend the cylinder\nfloat fc(float fX) { return sin(fX * .8) * .9 + 3. +cos(fX * .3); }\n\n// blanket function to wrap any heightmap by tangent\nvec4 modBlanket(float fX, float fR)\n{\n\t// get height by function\n\tfloat fH = fc(fX);\n\n\t// get function point by x axis\n\tvec2 vA = vec2(fX, fH);\n\n\t// get tangent normalized\n\tvec2 vTng = normalize(vec2(fX + .1, fc(fX + .1)) - vec2(fX - .1, fc(fX - .1)));\n\n\t// get normal normalized (rotate tangent 90 deg counter clockwise)\n\tvec2 vNrm = vec2(-vTng.y, vTng.x);\n\n\t// add radius to function point\n\tvec2 vB = vA + vNrm * fR;\n\n\t// calculate length of tangent (-tan(asin(normal x))\n\tfloat fTngL = fR * -tan(asin(vNrm.x));\n\n\treturn vec4(fH, abs(fTngL), vNrm);\n}\n\n// scene (all primitives distance)\nfloat sdScene(vec3 vPos, out uint uIx) \n{\n    // align on x axist (xyz -> zyx)\n    float fD = vPos.x;\n    float fR = 0.2;\n    vec4 vB = modBlanket(fD, fR);\n\n    return sdCylinderBent(vPos.zyx, vec2(0., vB.x), fR, vB.y);\n}\n\n// get normal for hit\nvec3 sdCalculateNormal(in vec3 vPos)\n{\n    uint uIx;\n    vec2 vE = vec2(1.0, -1.0) * 0.5773 * 0.0001;\n    return normalize(\n        vE.xyy * sdScene(vPos + vE.xyy, uIx) +\n        vE.yyx * sdScene(vPos + vE.yyx, uIx) +\n        vE.yxy * sdScene(vPos + vE.yxy, uIx) +\n        vE.xxx * sdScene(vPos + vE.xxx, uIx));\n}\n\n// Volume Ray Casting (Ray Marching) - Microsoft method\nbool vrc(in vec3 vOri, in vec3 vDir, out float fThit, out PosNorm sAttr)\n{\n\tfloat fT = fTMin;\n\tfloat fStep = sdScene(vOri, sAttr.uPrimI) * fStepAdjust;\n\tvec3 vPos = vOri;\n\n\t// march through the space\n\tuint uI = uint(0);\n\twhile (uI++ < uMaxSteps && fT <= fTMax)\n\t{\n        // perform step\n\t\tvPos += fStep * vDir;\n\t\tfloat fDist = sdScene(vPos, sAttr.uPrimI);\n\n\t\t// intersection ?\n\t\tif (fDist <= fThreshold * fT)\n\t\t{\n            // is valid ?\n\t\t\tif (fT < fTMax)\n\t\t\t{\n                vec3 vNormal = sdCalculateNormal(vPos);\n\t\t\t\tfThit = fT;\n\t\t\t\tsAttr.vPosition = vPos;\n\t\t\t\tsAttr.vNormal = vNormal;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// raymarch step\n\t\tfStep = fStepAdjust * fDist;\n\t\tfT += fStep;\n\t}\n\treturn false;\n}\n\n// transform a ray based on screen position, camera position and inverse wvp matrix - Microsoft method\nvoid transform_ray(in uvec2 sIndex, in vec2 sScreenSz, in vec4 vCamPos, in mat4x4 sWVPrInv,\n\tout vec3 vOrigin, out vec3 vDirection)\n{\n\t// center in the middle of the pixel, get screen position\n\tvec2 vXy = vec2(sIndex.xy) + 0.5f;\n\tvec2 vUv = vXy / sScreenSz.xy * 2.0 - 1.0;\n\t\n\t// unproject by inverse wvp\n\tvec4 vWorld = vec4(vUv, 0, 1) * sWVPrInv;\n\n\tvWorld.xyz /= vWorld.w;\n\tvOrigin = vCamPos.xyz;\n\tvDirection = normalize(vWorld.xyz - vOrigin);\n}\n\n// lighting \nvec3 SceneLighting(in vec3 vPos, in vec3 vRayDir, in vec3 vLitPos,\n\tin vec3 vNorm,\n\tin vec3 cMaterial,\n\tin bool bTranslucent,\n\tin float fAmbient,\n\tin float fSpecularPow,\n\tin float fSpecularAdj,\n\tin vec3 cLight,\n\tin vec3 vLight)\n{\n\t// get distance, reflection\n\tfloat fDist = length(vLitPos - vPos);\n\tvec3 vRef = normalize(reflect(vRayDir, vNorm));\n\n\t// calculate fresnel, specular factors\n\tfloat fFresnel = max(dot(vNorm, -vRayDir), 0.0);\n\tfFresnel = pow(fFresnel, .3) * 1.1;\n\tfloat fSpecular = max(dot(vRef, vLight), 0.0);\n\n\t// do lighting.. inverse normal for translucent primitives\n\tvec3 cLit = cMaterial * 0.5f;\n\tcLit = mix(cLit, cMaterial * max(dot(vNorm, vLight), fAmbient), min(fFresnel, 1.0));\n\tif (bTranslucent)\n\t\tcLit = mix(cLit, cMaterial * max(dot(-vNorm, vLight), fAmbient), .2f);\n\tcLit += cLight * pow(fSpecular, fSpecularPow) * fSpecularAdj;\n\tcLit = clamp(cLit, 0.f, 1.f);\n\t\n\treturn cLit;\n}\n\n// get position on ground plane\nvec3 GroundLitPos(in vec3 vPos, in vec3 vRayDir)\n{\n\t// get lit position\n\tfloat fD = -vPos.y / vRayDir.y;\n\treturn vec3(vPos.x + vRayDir.x * fD, 0.0, vPos.z + vRayDir.z * fD);\n}\n\n// checkers, hexagonal (not optimized !!)\nfloat checkers_hex(in vec2 vPt, in vec2 vDpdx, in vec2 vDpdy )\n{\n    // filter kernel\n    vec2 vW = abs(vDpdx) + abs(vDpdy) + 0.001;\n    // integral\n    float fIn = (HexGrid(vPt + .5 * vW) + HexGrid(vPt - .5 * vW)) * .5f;\n    \n    return mix(smoothstep(.6, .65, fIn), fIn, length(vW));\n}\n\n// https://www.shadertoy.com/view/XtByRz\nvec3 CandySpiral(vec2 vPos, float fTime, float fSpirals, float fSize)\n{\n\t// distance fom center, angle from center\n\tfloat d = length(vPos) * fSize;\n\tfloat a = atan(vPos.x, vPos.y) / 3.141592 * fSpirals;\n\n\t// spirals !!\n\tfloat v = fract(d + a - fTime);\n\n\treturn\n\t\tv < .25 ? vec3(.67f, .85f, .8f) :\n\t\tv>.5 && v < .75 ? vec3(.94f, .71f, .71f)  :\n\t\tvec3(1., 1., 1.);\n}\n\n// simple floor (little dents)\nfloat SimpleFloor(vec2 vPos)\n{\n\tfloat fH = 1.0;\n\tfH -= (max(sin(vPos.x * .5 + PI * .5) + cos(vPos.y * .5 - PI * 2.), 1.25) - 2.0) * 0.25;\n\treturn fH;\n}\n\n// simple floor (little dents)\nvec3 SimpleFloorNorm(vec2 vPos, float fStep)\n{\n\t// get floor square\n\tvec2 vPosOff = vec2(vPos.x - fStep, vPos.y);\n\tfloat fL = SimpleFloor(vPosOff);\n\n\tvPosOff = vec2(vPos.x + fStep, vPos.y);\n\tfloat fR = SimpleFloor(vPosOff);\n\n\tvPosOff = vec2(vPos.x, vPos.y - fStep);\n\tfloat fU = SimpleFloor(vPosOff);\n\n\tvPosOff = vec2(vPos.x, vPos.y + fStep);\n\tfloat fD = SimpleFloor(vPosOff);\n\n\t// calculate normal\n\tvec3 vTangent = vec3(2.0, fR - fL, 0.0);\n\tvec3 vBitangent = vec3(0.0, fD - fU, 2.0);\n\treturn normalize(cross(vTangent, vBitangent));\n}\n\n// simple camera helper\nvec3 cam(float fTime, vec2 fXZ_Off, float fY_Max)\n{\n    return vec3(sin(fTime * .3f) * fXZ_Off.x, \n        min(2.5f + sin(fTime * .5f) * 2.f, fY_Max), \n        cos(fTime * .3f) * fXZ_Off.y) +\n        vec3(10.f, 0.f, -20.f);\n}\n\n// trace ray, either using intersectors (drops, taffy, mallow) or raymarch (candy loop)\nvoid trace(in vec3 vOri, in vec3 vDir, out PosNorm sAttr, out float fThit)\n{\n    // CandyDrops\n    {\n        // render a circle of candies\n        float fT = iCircularEllipsoids(vOri, vDir, 3.f, 2.5f, sAttr.vNormal, sAttr.vColor, iTime);\n        if (fT > fTMin && fT <= fTMax)\n        {\n            // normal already set\n            fThit = fT;\n            sAttr.vPosition = vOri + fThit * vDir;\n            sAttr.vColor = clamp(sAttr.vColor, vec2(.8, .8), vec2(1., 1.));\n            sAttr.uPrimI = CandyDrops;\n        }\n    }\n    // TaffyCandy\n    {\n        // render a rounded box\n        vec3 vCen = vec3(6.f, .32f, -16.f);\n        vec3 vBoxSz = vec3(8.f, .1f, .75f);\n        float fT = iRoundedBox(vOri, vDir, vCen, vBoxSz, 0.2f);\n        if (fT > fTMin && fT <= fTMax && (fT < fThit || fThit == 0.f))\n        {\n            // set pos, normal, set uv as color\n            fThit = fT;\n            sAttr.vPosition = vOri + fThit * vDir;\n            sAttr.vColor = abs(sAttr.vPosition.xz + vCen.xz * .5f);\n            sAttr.vNormal = nRoundedBox(sAttr.vPosition, vCen, vBoxSz);\n            sAttr.uPrimI = TaffyCandy;\n        }\n    }\n    // Mallow\n    {\n        // render a capsule\n        const vec3 vCen = vec3(22.f, 2.f, -18.f);\n        const vec3 vBoxSz = vec3(8.f, .1f, .75f);\n        const vec3 vA = vec3(-1., 0., 0.);\n        const vec3 vB = vec3(1., 0., 0.);\n        const float fR = 2.;\n        float fT = iCapsule(vOri, vDir, vCen, vA, vB, fR);\n        if (fT > fTMin && fT <= fTMax && (fT < fThit || fThit == 0.f))\n        {\n            // set pos, normal, set uv as color\n            fThit = fT;\n            sAttr.vPosition = vOri + fThit * vDir;\n            sAttr.vColor = abs(sAttr.vPosition.xz + vCen.xz * .5f);\n            sAttr.vNormal = nCapsule(sAttr.vPosition, vCen, vA, vB, fR);\n            sAttr.uPrimI = Mallow;\n        }\n    }\n    // CandyLoop\n    if (fThit <= fTMin)\n    {\n        if (vrc(vOri, vDir, fThit, sAttr))\n            sAttr.uPrimI = CandyLoop;\n    }\n    // horizon / ground\n    if (fThit <= fTMin)\n    {\n        sAttr.uPrimI = Horizon;\n        sAttr.vNormal = vec3(0.f, 1.f, 0.f);\n        sAttr.vPosition = GroundLitPos(vOri, vDir);\n        if (vDir.y <= 0.0)\n            fThit = length(sAttr.vPosition - vOri);\n    }\n    \n}\n\nvoid mainImage( out vec4 cOut, in vec2 vXY )\n{\n    // get current camera position and lookat matrix\n    vec4 vCamPos = vec4(cam(iTime, vec2(30.f, 10.f), 20.f), 0.f);\n    mat4x4 avLookAt = LookAtLH(vCamPos.xyz, cam(iTime + .7f, vec2(20.f, 8.f), 3.f), vec3(0.f, 1.f, 0.f));\n  \n    // get projection matrix\n    mat4x4 avProj = PerspectiveLH(vec2(radians(90.), radians(60.)), vec2(1., 1000.));\n    \n    // get ray\n    vec3 vOri, vDir;\n    transform_ray(uvec2(vXY), iResolution.xy, \n        vCamPos, inverse(avLookAt * avProj), vOri, vDir);\n    \n    // raytracing hit depth and attributes\n    float fThit = 0.f;\n    PosNorm sAttr;\n    \n    // trace the ray (base fragment)\n    trace(vOri, vDir, sAttr, fThit);\n    \n    // which primitive was hit by ray ?\n    switch (sAttr.uPrimI) \n    {\n        case CandyLoop:\n        {\n            // colored endless cylinder\n            float fX = sAttr.vPosition.x;\n            float fZ = sAttr.vPosition.z;\n            vec3 cCandy = vec3(\n                max(.7f, sin(fX * .3f) * .5f + .5f),\n                max(.6f, cos(fX * .2f) * .5f + .5f),\n                max(.5f, sin(fX * .55f) * .5f + .5f)\n                );\n            cCandy = mix(cCandy.zxy, cCandy, step(.5, fract(fX + fZ)));\n            cOut = vec4(SceneLighting(\n                vCamPos.xyz,\n                vDir,\n                sAttr.vPosition,\n                sAttr.vNormal,\n                cCandy,\n                true, \n                .3f,\n                220.f,\n                1.f, \n                vec3(.9f, .8f, .7f),\n                normalize(vec3(-.4f, .2f, -.3f))\n                ), 1.f);\n        }\n        break;        \n        case CandyDrops:\n        // candy drops\n        cOut = vec4(SceneLighting(\n            vCamPos.xyz, \n            vDir, \n            sAttr.vPosition,\n            sAttr.vNormal, \n            vec3(1.f, sAttr.vColor), \n            true, \n            .3f,\n            220.f,\n            1.f, \n            vec3(.9f, .8f, .7f),\n            normalize(vec3(-.4f, .2f, -.3f))\n            ), 1.f);\n        break;\n        case TaffyCandy:\n        {\n            // taffy candy bar\n\t\t\tvec3 vCol = (mod(sAttr.vColor.y + sin(sAttr.vColor.x) * .2f, .8f) > .4f) ? vec3(1., .9, .8) : vec3(.8, .5, .2);\n\t\t\tvec3 vNormal = normalize(sAttr.vNormal + vec3(sin(sAttr.vColor.x * 20.f) * .05f, 0.f, cos(sAttr.vColor.y * 20.f) * .05f));\n\n\t\t\t// fade out normals\n\t\t\tfloat fRayDist = length(sAttr.vPosition - vCamPos.xyz);\n\t\t\tfloat fFadeOff = clamp(fRayDist * .06f, 0.f, 1.f);\n\t\t\tvNormal = normalize(mix(vNormal, sAttr.vNormal, fFadeOff));\n\n\t\t\tcOut = vec4(SceneLighting(\n                vCamPos.xyz, \n                vDir, \n                sAttr.vPosition,\n                vNormal,\n                vCol,\n                false,\n                .3f,\n                10.f,\n                1.f, \n                vec3(.9f, .8f, .7f),\n                normalize(vec3(-.4f, .2f, -.3f))),\n                1.f);\n        }\n        break;\n        case Mallow:\n        {\n            // marsh mallow cube\n\t\t\tfloat fStep = sAttr.vPosition.y + sin(sAttr.vPosition.x * 10.f) * .1f + sin(sAttr.vPosition.z * 10.f) * .1f;\n\t\t\tvec3 vCol = (fStep < 1.) ? vec3(1., 1., 1.) :\n\t\t\t\t(fStep < 2.) ? mix(vec3(1., .5, .5), vec3(1., .8, .8), smoothstep(0.0f, 0.2f, fract(fStep))) :\n\t\t\t\t(fStep < 3.) ? mix(vec3(.8, 1., 1.), vec3(.5, 1., 1.), smoothstep(0.8f, 1.0f, fract(fStep))) : vec3(1., 1., 1.);\n\n\t\t\tcOut = vec4(SceneLighting(\n                vCamPos.xyz, \n                vDir, \n                sAttr.vPosition, \n                sAttr.vNormal, \n                vCol,\n                false,\n                .4f,\n                10.f,\n                .2f,\n                vec3(.9f, .8f, .7f),\n                normalize(vec3(-.4f, .2f, -.3f))),\n                1.f);\n        }\n        break;\n        case Horizon:\n        {\n            float fGradient = abs(vDir.y);\n            vec3 cLight = vec3(.9f, .8f, .7f);\n            vec3 vLight = normalize(vec3(-.4f, .2f, -.3f));\n            vec3 cSky = vec3(1.0f, .4f, 0.f);\n    \n            // draw horizon\n            if (vDir.y > 0.0)\n            {\n                // cOut = mix(vec4(.0, .0, 1., 1.), vec4(.5, .6, .8, 1.), 1. - vDir.y);\n                \n                // render horizon\n                cOut = mix(vec4(.8, .6, .5, 1.), vec4(cSky, 1.f), smoothstep(.01f, .1f, fGradient));\n\n                // render a sun\n                float fSun = max(dot(vDir, vLight), 0.0);\n                cOut += vec4(cLight, 0.f) * pow(fSun, 100.0) * 2.f;\n                cOut = clamp(cOut, 0.f, 1.f);\n            }\n            else\n            {\n                // render checkers TODO !! fix dFdx/dFdy interpolation\n                // float fCh = checkers_hex(sAttr.vPosition.xz, dFdx(sAttr.vPosition.xz), dFdy(sAttr.vPosition.xz));\n                float fCh = checkers_hex(sAttr.vPosition.xz, vec2(fThit * .002f), vec2(fThit * .002f));\n                vec3 cCandy = mix(CandySpiral(sAttr.vPosition.xz, iTime * .18f, .5f, .05f), vec3(.9, .8, .7), fCh);\n\n                // get little dents\n                vec3 vNormal = -SimpleFloorNorm(sAttr.vPosition.xz * 100.f, .5f);\n                \n                // get shadow\n                float fThisSh = 0.f;\n                bool bShadow = false;\n                PosNorm sAttrSh;\n                trace(sAttr.vPosition, normalize(vec3(-.4f, .2f, -.3f)), sAttrSh, fThisSh);\n                if (fThisSh > fTMin)\n                {\n                    bShadow = true;\n                    cCandy *= .8f + clamp(fThisSh * .02, .0, .15);\n                }\n                \n                // fade out normals\n                float fFadeOff = clamp(fThisSh * .06f, 0.f, 1.f);\n                vNormal = normalize(mix(vNormal, vec3(0.f, 1.f, 0.f), fFadeOff));\n                                \n                // get reflection ray\n                vec3 vRef = normalize(reflect(vDir, vNormal));\n                float fThisRf = 0.f;\n                PosNorm sAttrRf;\n                trace(sAttr.vPosition, vRef, sAttrRf, fThisRf);\n                \n\n                // reflect by sky color or dark gray\n                vec3 cRef = cSky;\n                if (fThisRf > fTMin) cRef = vec3(.3f, .3f, .3f);\n                cCandy = mix(cCandy, cRef, bShadow ? 0.4f : 0.2f);\n                \n                // apply lighting\n                cOut.xyz = SceneLighting(\n                    vCamPos.xyz, \n                    vDir, \n                    sAttr.vPosition,\n                    vNormal, \n                    cCandy, \n                    false, \n                    .8f,\n                    220.f,\n                    1.f, \n                    bShadow ? vec3(.0f, .0f, .0f) : vec3(.9f, .8f, .9f),\n                    normalize(vec3(-.4f, .2f, -.3f))\n                );\n                \n                // blend with horizon to avoid flaws   \n                cOut = mix(cOut, vec4(.8, .6, .5, 1.), clamp(fThit * .008f, 0., 1.));\n            }\n            break;\n        }\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// EisernSchild 3D library\n// Copyright (c) 2022 by Denis Reischl\n//\n// SPDX-License-Identifier: MIT\n\n// Math Library #####################################################\n\n#define PI 3.141592654f\n\n// Orthographic projection : ba = (b.an)an\nvec2 ortho_proj(vec2 vA, vec2 vB)\n{\n    vec2 vAn = normalize(vA);\n    return dot(vB, vAn) * vAn;\n}\n\n// rotate 2D\nvec2 rotate(vec2 vV, float fA) \n{\n\tfloat fS = sin(fA);\n\tfloat fC = cos(fA);\n\tmat2 mR = mat2(fC, -fS, fS, fC);\n\treturn mR * vV;\n}\n\n// Hex Grid Library #####################################################\n\nconst vec2 vNext = vec2( 1.5f / sqrt(3.f), 1.5f );\nconst float fTD = length(vNext);\n\n/// Cartesian to hex coordinates\nvec2 HexUV(vec2 vXy)\n{\n\t// hex coords       (u, v) = (          .5 * x + .5 * y,        y ) \n\t// hex coord scaled (u, v) = ((sqrt(3.f) * x + y) / 3.f, y / 1.5f )\n\treturn vec2( (sqrt(3.f) * vXy.x + vXy.y) / 3.f, vXy.y / 1.5f );\n}\n\n/// Hex to cartesian coordinates\nvec2 HexXY(vec2 vUv)\n{\n\t// get cartesian coords\n\treturn vec2( (vUv.x * 3.f - vUv.y * 1.5f) / sqrt(3.f), vUv.y * 1.5f );\n}\n\n// provide hex grid\nfloat HexGrid(vec2 vPt)\n{\n    // get approx. hexagonal center coords\n    vec2 vUvC = round(HexUV(vPt));\n        \n    // get approx. cartesian hex center\n    vec2 vPtC = HexXY(vUvC);\n    \n    // get local coords absolut, adjust x\n    vec2 vPtLc = abs(vPt - vPtC);\n    if (vPtLc.x > (fTD * .5)) vPtLc.x = fTD - vPtLc.x;\n    \n    // project point on constant tile vector\n    vec2 vPtN = ortho_proj(vNext, vPtLc);\n    \n    // get distance, adjust again\n    float fD = max(vPtLc.x, length(vPtN));\n    if (fD > (fTD * .5)) fD = fTD - fD;\n    \n    return fD;\n}\n\n// Transform Library #####################################################\n\n// provide a lookat matrix\nmat4x4 LookAtLH(vec3 vCam, vec3 vTar, vec3 vUp)\n{\n    mat4x4 avLookAt;\n    vec3 vZ = normalize(vTar - vCam);\n    vec3 vX = normalize(cross(vUp, vZ));\n    vec3 vY = cross(vZ, vX);\n       \n    avLookAt = \n    mat4x4(\n        vec4(1., 0., 0., -vCam.x),\n        vec4(0., 1., 0., -vCam.y),\n        vec4(0., 0., 1., -vCam.z),\n        vec4(0., 0., 0., 1.)\n    ) *\n    mat4x4(\n        vec4(vX.x, vX.y, vX.z, 0.),\n        vec4(vY.x, vY.y, vY.z, 0.),\n        vec4(vZ.x, vZ.y, vZ.z, 0.),\n        vec4(0., 0., 0., 1.)\n    );\n    \n    return avLookAt;\n}\n\n// provide a perspective projection matrix\nmat4x4 PerspectiveLH(vec2 vFov, vec2 vZnf)\n{\n    float fW = tan(vFov.x*0.5),\n          fH = tan(vFov.y*0.5);\n    \n    mat4x4 avProj = mat4x4( 0.0 );\n    avProj[0][0] = 2. * vZnf.x / fW;\n    avProj[1][1] = 2. * vZnf.x / fH;\n    avProj[2][2] = vZnf.y / (vZnf.y - vZnf.x);\n    avProj[3][2] = 1.;\n    avProj[2][3] = vZnf.x*vZnf.y/(vZnf.x - vZnf.y);\n    \n    return avProj;\n    \n}","name":"Common","description":"","type":"common"}]}