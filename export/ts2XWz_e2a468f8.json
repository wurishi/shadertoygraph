{"ver":"0.1","info":{"id":"ts2XWz","date":"1553511751","viewed":343,"name":"Dart-Throwing with Minkowski Sum","username":"fizzer","description":"Here's another dart-throwing example, this time mixing different shapes together while still using a single feedback buffer (containing 3 distance fields representing Minkowski sums).","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["packing","filling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Note: Click LMB to reset.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{       \n    int shape_type = int(texelFetch(iChannel0, ivec2(fragCoord.xy), 0).a);\n    \n    fragColor.rgb = vec3(1.);\n    \n    switch(shape_type)\n    {\n        case 1: // Circle\n        \tfragColor.rgb = vec3(1., .45, .45);\n        \tbreak;\n\n        case 2: // Square\n        \tfragColor.rgb = vec3(.45, 1., .45);\n        \tbreak;\n\n        case 3: // Cross\n        \tfragColor.rgb = vec3(.45, .45, 1.);\n        \tbreak;\n\t}\n    \n    // Gamma correction.\n    fragColor.rgb = pow(clamp(fragColor.rgb, 0., 1.), vec3(1. / 2.2));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float pi = 3.1415926535898797323;\n\n// https://www.shadertoy.com/view/4djSRW\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat sdRect(vec2 p, vec2 c, vec2 r)\n{\n    return length(max(abs(p - c) - r, 0.)) + min(0., max(abs(p.y - c.y) - r.y, abs(p.x - c.x) - r.x));\n}\n\nfloat sdCross(vec2 p, vec2 c, float r, vec2 e)\n{\n    return min(sdRect(p, c, vec2(r, r * .25) + e), sdRect(p, c, vec2(r * .25, r) + e));\n}\n\nfloat sdCross(vec2 p, vec2 c, float r)\n{\n    return sdCross(p, c, r, vec2(0));\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// This buffer maintains 3 signed distance fields, one for each shape type.\n// The distance fields represent the Minkowski sum sof the current collidable objects with\n// each of the shape types. This allows a collision query with any of the shapes to be reduced\n// to a point query on the matching distance field.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame == 0 || iMouse.z > 0.)\n    {\n        // Reset.\n        fragColor.rgb = vec3(1e7);\n        fragColor.a = 0.;\n        return;\n    }\n    \n    // Read in the previous data.\n    vec2 p = fragCoord.xy / iResolution.xy;\n    vec4 prev_p = textureLod(iChannel0, p, 0.);\n    \n    fragColor = prev_p;\n\n    // Apply aspect correction.\n    p.x *= iResolution.x / iResolution.y;\n\n    // Random position.\n    int seed = iFrame + (int(iDate.z * 6000. + iDate.w * 100.) % 199);\n    vec2 c = hash21(float(seed));\n\n    int shape_type = int(hash21(float(iFrame * 3)) * 2.999);\n    \n    vec4 prev_c = textureLod(iChannel0, c, 0.);\n\n    float prev_d = prev_c[shape_type];\n    \n    // Apply aspect correction.\n    c.x *= iResolution.x / iResolution.y;\n   \n    float r = 0.04, d = 1e4;\n\n    switch(shape_type)\n    {\n        default:\n        case 0: // Circle\n        \td = distance(c, p) - r;\n        \tbreak;\n\n        case 1: // Square\n\t\t\td = sdRect(p, c, vec2(r));\n        \tbreak;\n\n        case 2: // Cross\n\t\t\td = sdCross(p, c, r);\n        \tbreak;\n\t}\n    \n    float margin = 2e-3;\n\n    // Check if the shape is valid by comparing it to the distance field.\n    if(prev_d > 0. + margin)\n    {\n        if(d < 0.)\n            fragColor.a = float(shape_type + 1); // Write out shape ID.\n\n        switch(shape_type)\n        {\n            default:\n            case 0: // Circle\n            \t// F' = F + Circle x Circle\n                fragColor.r = min(fragColor.r, d - r);\n            \t// F' = F + Square x Circle\n                fragColor.g = min(fragColor.g, sdRect(p, c, vec2(r)) - r);\n             \t// F' = F + Cross  x Circle\n                fragColor.b = min(fragColor.b, sdCross(p, c, r) - r);\n                break;\n\n            case 1: // Square\n            \t// F' = F + Circle x Square\n                fragColor.r = min(fragColor.r, d - r);\n            \t// F' = F + Square x Square\n                fragColor.g = min(fragColor.g, sdRect(p, c, vec2(r) * 2.));\n            \t// F' = F + Cross  x Square\n                fragColor.b = min(fragColor.b, sdCross(p, c, r, vec2(r)));\n                break;\n\n            case 2: // Cross\n            \t// F' = F + Circle x Cross\n                fragColor.r = min(fragColor.r, d - r);\n            \t// F' = F + Square x Cross\n                fragColor.g = min(fragColor.g, sdCross(p, c, r, vec2(r)));\n            \t// F' = F + Cross  x Cross\n                fragColor.b = min(fragColor.b, min(sdCross(p, c, r, vec2(r, r * .25)),\n                                                  sdCross(p, c, r, vec2(r * .25, r))));\n                break;\n        }\n     }\n\n}","name":"Buffer A","description":"","type":"buffer"}]}