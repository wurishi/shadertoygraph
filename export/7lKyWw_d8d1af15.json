{"ver":"0.1","info":{"id":"7lKyWw","date":"1717603715","viewed":48,"name":"DEATH SHADER (death note remake)","username":"valena","description":"Resently I was watching the Death note series and thought... Why not implement this intro as a shader? :) ","likes":1,"published":1,"flags":64,"usePreview":0,"tags":["lightning"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"lt2Xzw","filepath":"https://soundcloud.com/trolebi/death-note-opening-2","previewfilepath":"https://soundcloud.com/trolebi/death-note-opening-2","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat hash11(float p)\n{\n    return length(hash22(vec2(p)));\n}\n\nmat2 rmatrix(float a)    //Rotation matrix;\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\n\treturn mat2(c, -s, s, c);\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat S(float x)\n{\n\treturn (3.0 * x * x - 2.0 * x * x * x);\n}\n\nfloat noise(vec2 pos)\n{\n\tfloat a = rand(vec2(floor(pos.x), floor(pos.y)));\n\tfloat b = rand(vec2(ceil(pos.x), floor(pos.y)));\n\tfloat c = rand(vec2(floor(pos.x), ceil(pos.y)));\n\tfloat d = rand(vec2(ceil(pos.x), ceil(pos.y)));\n\n\tfloat s1 = S(pos.x - floor(pos.x));\n\tfloat s2 = S(pos.y - floor(pos.y));\n\n\tfloat f = a + \n\t\t\t  (b - a) * s1 +\n\t\t\t  (c - a) * s2 +\n\t\t\t  (a - b - c + d) * s1 * s2;\n\treturn (f);\n}\n\nfloat onoise(in vec2 pos)\n{\n\tfloat n = 10.0;\n\tfloat delta = 3.1415 / 6.0;\n\tfloat sum = 0.0;\n\tfloat power = 0.5;\n\n\tfor (float i = 0.0; i < n; i++)\n\t{\n\t\tsum += noise(rmatrix(delta * i) * pos) * power;\n\t\tpower *= 0.35;\n\t\tpos *= 1.9;\n\t}\n\treturn sum;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat smin( float a, float b, float k )\n{\n    a = pow( a, k ); b = pow( b, k );\n    return pow( (a*b)/(a+b), 1.0/k );\n}\n\nvec3 getLightning(vec2 uv, float r)\n{\n    vec3 col = vec3(0.0);\n    \n    //uv *= rmatrix(PI / 2.0);\n    \n    uv.y -= PI / 2.0;\n    \n    uv *= vec2(2.0);\n\n    vec2 luv = vec2(fract(uv.x), uv.y + 0.5);\n    vec2 lid = vec2(floor(uv.x), r);\n    \n    vec2 dp1 = hash22(lid - vec2(1.0, 0.0)) - vec2(1.0, 0.0);\n    vec2 dp2 = hash22(lid);\n    vec2 dp3 = hash22(lid + vec2(1.0, 0.0)) + vec2(1.0, 0.0);\n    \n    float dist1 = length(sdSegment(luv, dp1, dp2));\n    float dist2 = length(sdSegment(luv, dp2, dp3));\n    \n    //float dist = smin(dist1, dist2, 1.0);\n    float dist = min(dist1, dist2);\n    //dist = smin(dist1, dist2, 1.0);\n    \n    float r1 = atan(0.02 / uv.x);\n    float r2 = atan(3.5 / uv.x);\n    \n    //r1 = 0.05;\n    //r2 = 1.5;\n    \n    col = mix(col, vec3(0.5, 0.5, 1.0), pow(1.0 - clamp(dist, 0.0, r2) / r2, 2.0));\n    \n    col = mix(col, vec3(1.0), step(dist, r1));\n    \n    return (col);\n}\n\nvec3 getLightnings(vec2 uv)\n{\n    vec3 col = vec3(0.0);\n    float sec_num = 16.0;\n    \n    for (float i = 0.0; i < sec_num; i++)\n    {\n        float delta = hash11(floor(iTime / 0.35) * (i + 1.0)) * PI / 4.0;\n        float an = 2.0 * PI / sec_num * i + delta;\n        \n        vec2 puv = vec2(length(uv), mod(atan(uv.y, uv.x) + an, 2.0 * PI));\n\n        col += getLightning(puv, hash11(floor(iTime * 80.0) * (i + 1.0)));\n    }\n    return col;\n}\n\nvec3 getPlasma(vec2 uv, float t)\n{\n    float n = pow(onoise(uv * 2.0 - vec2(100.5 * iTime, 0.0)), 1.0) * 6.0;\n    //n = 1.0;\n    float l = length(uv) / max(1.0, 7.0 - t * 5.0);\n    \n    return vec3(n * max(0.0, pow(1.0 - l, 3.0)));\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat getBorders(vec2 uv, float t)\n{\n    float t0 = 9.0;\n    float t1 = 10.8;\n    \n    float h1 = 0.3;\n    \n    float h = 1.0 - min(1.0, max(0.0, t - t0) / (t1 - t0));\n    \n    float a = iResolution.x / iResolution.y;\n    \n    vec2 p = vec2(a + h1, 1.0 + h1);\n    vec2 s = vec2(a - h, 1.0 - h);\n    \n    \n    uv = abs(uv);\n    \n    float dist = sdBox(uv - p, s);\n    \n    \n    \n    return 1.0 - clamp(dist, 0.0, 0.03) / 0.03;\n}\n\nvec3 printChar(vec2 uv, int n, vec3 col)\n{\n    vec2 pos = vec2(n % 16, 15 - n / 16);\n    \n    \n    if (uv.x > 1.0 || uv.y > 1.0)\n        return col;\n    \n    float a = 0.5;\n    uv.x = (uv.x + a) / (1.0 + 2.0 * a);\n    \n    \n    vec2 picuv = (pos + uv) * (10.0 / 160.0);\n    \n    float ncol = texture(iChannel1, picuv).x;\n    col = mix(col, vec3(0.0), ncol);\n    \n    return col;\n}\n\nvec3 printText(vec2 uv, vec3 col)\n{\n    int letters[] = int[](68, 69, 65, 84, 72, 127, 78, 79, 84, 69);\n    \n    float lw = 1.0 / float(letters.length());\n    \n    vec3 ncol = col;\n    \n    vec2 p = vec2(-0.3, 0.0);\n    vec2 s =  vec2(3.0, 0.7);\n    \n    //float t = max(0.0, 1.0 - (iTime - 8.0));\n    float t = exp(-3.0 * max(0.0, (iTime - 9.0))) * (1.0 - (iTime - 9.0));\n    \n    uv .y -= max(0.0, t * 4.0);\n    \n    uv /= (1.0 + max(0.0, 48.0 * t));\n    \n    vec2 uv1 = ((uv - p) + s / 2.0) / s;\n    \n    if (uv1.x < 0.0 || uv1.x > 1.0 || uv1.y < 0.0 || uv1.y > 1.0)\n        return (col);\n        \n    int id = int(uv1.x / lw);\n    vec2 puv = vec2(fract(uv1.x / lw) / 1.0, uv1.y);\n    \n    ncol = printChar(puv, letters[id], ncol);\n    \n    return ncol;\n}\n\nvec3 voronoi( vec2 u )  // returns len + id\n{\n    float ofs = .5;\n    vec2 iu = floor(u);\n    vec2 v;\n    \n\tfloat m = 1e9;\n    float d;\n    \n    \n    for( int k=0; k < 25; k++ ) {\n        vec2  p = iu + vec2(k%5-2,k/5-2);\n        vec2 o = ( -ofs + (1.+2.*ofs) * hash22(p) );\n        vec2 r = p - u + o;\n            \n      \t     \n\t\td = dot(r,r);\n        if( d < m ) m = d, v = r;\n    }\n\n    return vec3( m, v+u );\n}\n\nvec3 crackAnim(vec2 uv, float t)\n{\n    \n    float vor = voronoi(uv * 3.0).r * t;\n    float br = pow(t, 5.0);\n    float total = vor + br;\n    \n    return vec3(total);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.y * 2.0 - vec2(iResolution.x / iResolution.y, 1.0);\n    \n    //uv = floor(uv * 40.0) / 40.0;\n    \n    uv -= vec2(0.3, 0.0);\n    \n    vec3 col = vec3(232.0, 7.0, 52.0) / 255.0;\n    \n    float crackPeriod = 0.3;\n    \n    if (iTime >= 7.0)\n    {\n        col += getLightnings(uv);\n        col += getPlasma(uv, iTime - 7.0);\n        col  = printText(uv, col);\n    }\n    else if (iTime >= 7.0 - crackPeriod)\n    {\n        col = crackAnim(uv, (iTime - 7.0 + crackPeriod) / crackPeriod);\n    }\n    else\n        col = vec3(0.0);\n    \n    \n    col = mix(col, vec3(0.0, 0.0, 0.0), getBorders(uv, iTime));\n    \n    //col = vec3(1.0);\n    \n    \n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}