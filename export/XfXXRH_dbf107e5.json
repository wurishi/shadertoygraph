{"ver":"0.1","info":{"id":"XfXXRH","date":"1705060683","viewed":171,"name":"魔方Rubik's 2","username":"shadertoyjiang","description":"Rubik's cube\nClick on the right hand side to show individual Rubik's Cubes","likes":13,"published":1,"flags":8,"usePreview":0,"tags":["mouse","cube","magic","rubiks"],"hasliked":0,"parentid":"4cXSz8","parentname":"魔方Rubik's cube"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//     创作时间：2024年01月10日 23时32分38秒\n\n//         名称：魔方\n\n// \n\n// 模板创造时间：(17:38 2024-1-10)\n\n// 2024-1-13 注： 模方不能存储矩阵（动作），但可存储颜色（状态）。\n//               因为不同小块有不同的动作路径，而矩阵的数据是确定的，只能代表同一路个径，所以矩阵只能一个接一个的算。耗时间，不耗内存\n// 色块可以存储，但不同魔方的色块都要存储，改变状态只需一次动作，所以不耗时间，但耗内存\n\n//#define OnlyBig\n\n// 0327 注，替代分支\n\nbool OnlyBig2;\n\n\n\nfloat PI = 3.1415926535897932384626;\n\n\nfloat smin(float a, float b, float k){ float h =clamp( .5*(a-b)/k+.5,  0.,1.); return mix(a,b,h)-k*h*(1.-h);} // 同时存在，交界处粘连， 多项式平滑\n\nfloat smax(float a, float b, float k){ return smin(a, b,-k);} // 相交，取公共部分\n\nfloat ssub(float a, float b, float k){ return smin(a,-b,-k);} // 抠去\n\nmat3  rot3(vec3 n, float a){ n=normalize(n); float x=n.x, y=n.y, z=n.z, s=sin(a), c=cos(a), e=1.-c; return mat3(e*x*x+c, e*x*y+s*z, e*x*z-s*y, e*y*x-s*z, e*y*y+c, e*y*z+s*x, e*z*x+s*y, e*z*y-s*x, e*z*z+c);}\n\n\nmat3 publicMmtr,mtr6[27];\n\nvec4 clr;\n\nfloat objind,time;\n\nbool err;\n\n\n\n// hash by   Dave_Hoskins\n// https://www.shadertoy.com/view/4djSRW\nvec4 rnd_(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n/*\n// 获取随机数\nvec4 rnd_00(float ind)\n{\n        float Rx = iResolution.x,\n        \n              x = mod(ind,Rx),\n              \n              y = floor(ind/Rx);\n              \n        return texelFetch(iChannel0, ivec2(x,y),0);\n}*/\n\n/*\nvec3 rxyzf(vec3 p, vec3 n, float theta)\n{\n        // p在n的方向上长度大于0.5旋转\n        \n        \n        theta*=step(.5,  length( max(p*n,0.)  ));\n        \n        return p*rot3(n,theta);\n\n        \n\n        /*\n        int i,j=-1;\n        \n        // 查找非零轴\n        for(i=0;i<3;i++)\n        \n            if(abs(n[i])>0.)j=i;\n            \n        // 分层\n        if(abs(p[j])>.5 && p[j]*n[j]>0.)\n        \n            p*=rot3(n,theta);\n            \n        return p;\n        * /\n}*/\n\n\n/*\nint idn(vec3 n)\n{\n     if(abs(n.x)+abs(n.y)+abs(n.z) != 1.)err=true;\n     \n     //n=vec3(-.1,0,0);\n     \n     ///if(abs(length(n)-1.)>.1)err=true;\n     ivec3 m = ivec3( round(n));\n     \n     m = (m+1);//*abs(m);\n     //if(abs(m.x)+abs(m.y)+abs(m.z) != 1)err=true;\n     \n     return m.x + m.y*3 + m.z * 9;  \n     /*\n     if(m.x==0)return 0;\n     if(m.x==1)return 1;\n     if(m.y==0)return 2;\n     if(m.y==1)return 3;\n     if(m.z==0)return 4;\n     if(m.z==1)return 5;* /\n}\n     \n*/\n     \n     \n     \n\n\nvec3 rxyz(vec3 p)\n{\n        vec3 n;\n        \n        float t = (sin((time+objind*13.4567)*.2+11.)*.5+.5)*12., // 复原次数\n              it = floor(t),\n              ft=min(fract(t)*1.2, 1.);\n        \n        vec4 rnd;\n        \n        float theta;\n        \n        int i;        \n        \n        // 六个面，每个面2个位置，如果预存12个矩阵，可以快些\n        for(float j=it;j>0.;j--)\n        {\n               rnd=rnd_(j*33.55+objind*133.5332);\n               \n               n*=0.;\n               \n               vec2 f = sign(step(.5,rnd.xw)*2.-1.);\n               \n               i = int(rnd.y*213.44643346)%3;\n               \n               n[i]=f.x; // 一个控制轴指向，一个角度正负，可以合并\n               \n               float lfrt=length(step(.5,  p*n)); //  0,1 p在n的方向上长度大于0.5的部分可以旋转\n               \n               n *= f.y; // 角度反向相当于轴反向\n               \n               //if(lfrt>.5)\n               //if(it==it){\n           \n                     theta = PI/2.;\n                       \n                                                               \n                     if(j==it)\n                         theta*=ft;\n                     \n                     //p = rxyzf(p, n, theta  );  \n                     //p*=rot3(n,theta* step(.5,  length( max(p*n,0.) )));\n                     \n                     //if(j==it)\n                     \n                         p*=rot3(n,theta*lfrt);\n                  \n                //}else{ //p*=mtr6[idn(n)];}\n                     //if(lfrt>.5)\n                     //p*=rot3(n,PI/2.);}\n                     //p*=mtr6[idn(n)];}\n            \n               \n               \n        }\n             \n        return p;        \n}\n\n\n// 场景\n\nfloat rubik(vec3 p)\n{\n        p *= publicMmtr;\n        //float tt = iTime + objind*123.456 ;       \n        //p *= rot3(vec3(cos(tt*.07),sin(tt*.03),sin(tt*.05)),tt*.1*cos(objind*123.654));     \n        \n        //if(p.y<.5) p = rot3(vec3(0,-1,0),iTime) * p;\n        // 需要分成两部分，不然有斑纹，因为旋转错开过后，不是真实距离\n        //if(p.x<.5) p *= rot3(vec3(-1,0,0),PI/2.);\n\n        p = rxyz(p);\n\n        vec3 o = abs(p), q , i;\n\n        float d1,d2,d3, c;\n\n        // 中心球，防止光线对穿\n        d1 = length(p)-1.42; \n\n        // 魔方体\n        i = round(o - max(o-1., 0.)) * sign(p);\n\n        d2 = length(max(abs(p-i)-.3, 0.))-.19;\n                \n        // o 与最靠近p中最长分量的坐标轴 共线。\n        c = max(o.x,max(o.y,o.z));\n\n        q = sign(p) * (1. - sign(abs( o - c )));\n       \n        // 色斑块\n        o = p - i - q * .25;\n\n        d3 = length(max(abs(o)-.26, 0.)) - .05;\n\n        // 颜色\n        if(objind>0.)  q *= publicMmtr * (1.+fract(objind*123.3567)); // 变色\n        \n        clr = d3 < d2 \n\n            ? 1.1-vec4(q*.5+.5,1)\n\n            : vec4(1.3)-fract(objind*233.34234);\n\n            ;\n                            \n        return min(d1,smin(d2,d3,.05));\n}\n\n\n\nfloat di(vec3 p,float db)\n{\n\n        float a=-4.,  d1 = p.y-a;\n        \n        if(d1<db)db=d1,clr=vec4(1),objind=1.;\n        \n        /*\n        float r = length(p.xz)*.8 ;      \n        float d2 =   length( vec2( r- min(round(r),12.),p.y-a-.1) )-.1;        \n        d2 = smin(d2,d1,.1);                \n        if(d2<db)db=d2,clr=vec4(1),objind=1.;\n        */\n        \n        \n        return db;\n}\n\n\nfloat sence(vec3 p)\n{\n        #ifdef OnlyBig\n           return rubik(p);\n        #endif\n        \n        if(OnlyBig2==true)return rubik(p);\n        \n        float d1,d2;\n        vec4 clf;\n        \n        p -= vec3(0,0,35);  // 总体距离\n        \n        p *= rot3(vec3(1,0,0), -.5); // 总体倾角\n        \n        vec3 q=p;\n        \n    if(length(p)<12.)\n    {\n        \n        p *= rot3(vec3(0,1,0), time*-.3); // 环状旋转\n        \n        \n        \n        //d1= rubik(p*.3);  clf=clr;\n        p *=.3;\n        objind=0.;\n    }\n    else\n    {\n        \n        \n        p *= rot3(vec3(0,1,0), time*.1); // 环状旋转\n        \n        \n        float fen =13.,\n              a=atan(p.z,  p.x)/PI*.5+.5,\n              ia = floor(a*fen),\n              fa = fract(a*fen),\n              ga = (fa-.5)/fen*2.*PI,\n              rxz = length(p.xz);\n              \n        objind = ia+5.;\n        \n        p.xz = rxz*vec2(cos(ga),sin(ga));\n        \n        p.x-= 15.; // 环状分布半径\n     }\n     \n     \n     //float bxl = length( max(abs(p)-1.7 ,0.))-.001;\n     float bxl = length(p)-3.;\n     \n     if(bxl>0.)d2 =bxl +.5; else //包围盒\n        \n          d2 = rubik(p);\n     \n     // 竖线\n     //if(objind>0.) {        d1 =max(length(p)-4.05, max( length(p.xz)-2.8, 4.-length(p)));   if(d1<d2)clr=vec4(.85),objind=1.; d2=smin(d1,d2,.1); }\n     \n     //d1 = q.y+4.; \n     d2=di(p, d2);\n     \n           \n     \n     return d2;\n     \n     \n     //if(abs(bxl)<.5)clr+=.05;\n         \n     //return min(d2,bxl);\n}\n\n\n\nvoid mainImage(out vec4 O, in vec2 v)\n\n{\n        time=iTime-11.;\n\n        OnlyBig2 = iMouse.x > iResolution.x*.5 ? true : false;\n        \n        //for(int i;i<8;i++)mtr6[i]=rot3(vec3(1),0.);\n        /*\n        for(int k=-1;k<2;k+=2)\n        for(int j=-1;j<2;j+=2)\n        for(int i=-1;i<2;i+=2)\n        {\n               vec3 n = vec3(i,j,k);\n               if(abs(i)+abs(j)+abs(k)==1)mtr6[idn(n)]=rot3(n,PI/2.);\n               \n        }*/\n        \n        \n        publicMmtr = rot3(vec3(cos(time*.07),sin(time*.03),sin(time*.05)),time*.1);\n\n        float d,t,m0=1e-2;\n\n        vec2 R = iResolution.xy, u =1.2*(v+v-R)/min(R.y,R.x);\n        \n        //u.x=clamp(u.x,-1.3,1.3);\n        //u.y=clamp(u.y,-1.,1.);\n        \n        O = vec4(.8);\n        if((abs(u.x)>1.3) || (abs(u.y)>1.))return;\n\n        vec3 o = vec3(0,0,-8),\n\n             sun = normalize(vec3(-1,2,-3)),\n\n             r=normalize(vec3(u,3.)),\n\n             e= vec3(0,m0*.1,0),\n\n             n;\n\n        vec4 bk=O=.5*normalize(vec4(8,7,5,1)); // 背景\n\n        for(int i;i++<200 && t < 150.;)\n\n        {\n                //d = sence(o + r * t);\n                d = sence(o += r*d* .5);\n\n                if(d<m0) \n\n                {\n\n                        //o = o + r*(t-m0-m0);// m0 可以存一个历史 d  正方体内部的法线是不正确的\n\n                        n = normalize(  vec3(sence(o+e.yxx),sence(o+e),sence(o+e.xxy))- d);\n                                                                                        //sence(o) );\n                                     // - vec3(sence(o-e.yxx),sence(o-e),sence(o-e.xxy)));\n\n\n                        //O = O*0. + dot(sun , n )*.5+.5; // 伪光照。\n\n                        float dt = max(0., dot(sun ,n));\n\n                        if(i<200)\n\n                        {\n\n                                O = clr * (.5 - .08 * dt);\n\n                                O += pow(dt, 200.)*.8;\n                                \n                                if(objind> 0.)O= mix(O,bk,clamp((15./35.*cos(.5)-(o.z-35.)/20.)* 7.    , -.5  ,3. ));\n                                //if(objind==1.)O= mix(O,bk,clamp((15./35.*cos(.5)-(o.z-35.)/20.)* 8.    , -1.  ,3. ));\n\n\n                        }\n\n                        break;\n\n                }\n\n                t+=d*.5;\n\n        }\n        \n        if(err)O=vec4(1,0,0,0);\n\n}\n\n\n\n\n     ","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\nvec2 mainSound( int i, float t )\n{    \n    return vec2( i+i/2 & i-i/3 >> 10 & 255 )- 1.;      \n    //return vec2( i>>8 & i)-1.;\n    //return vec2(0);\n    //return vec2((i>>8 & i<<3)|(i>>8 >> i<<5))-1.;\n}\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n    \n    \n    \n\n\n","name":"Sound","description":"","type":"sound"}]}