{"ver":"0.1","info":{"id":"NtGfR3","date":"1664889288","viewed":70,"name":"animation perline noise","username":"seu_yy","description":"noise","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 hashOld33( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn fract(sin(p)*43758.5453123);\n}\n\nvec3 hash33(vec3 p)\n{\n\tp = fract(p * vec3(.1031,.11369,.13787));\n    p += dot(p, p.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p.x + p.y)*p.z, (p.x+p.z)*p.y, (p.y+p.z)*p.x));\n}\n\nvec3 random3(vec3 p)\n{\n    return hash33(p);\n}\n\nfloat bilinear(vec4 data, float w_u, float w_v)\n{\n    return mix(\n                mix(data.x,data.y,w_u),\n                mix(data.z,data.w,w_u),\n                w_v);\n}\n\nfloat trilinear(vec4 bottom, vec4 up, vec3 w)\n{\n    return mix(\n                bilinear(bottom,w.x,w.y),\n                bilinear(up,w.x,w.y),\n                w.z);\n}\n\nfloat perline_noise(vec3 uv,float lattice)\n{\n    vec3 pi = floor(uv);\n    vec3 pf = uv-pi;\n    pi = mod(pi,lattice);\n    vec3 weight = pf*pf*pf*(6.0*pf*pf-15.0*pf+10.0);\n    //vec3 weight = pf * pf * (3.0 - 2.0 * pf);\n    \n    vec4 up = vec4(\n        dot(random3(pi + vec3(0.0,0.0,1.0)),pf-vec3(0.0,0.0,1.0)),\n        dot(random3(pi + vec3(1.0,0.0,1.0)),pf-vec3(1.0,0.0,1.0)),\n        dot(random3(pi + vec3(0.0,1.0,1.0)),pf-vec3(0.0,1.0,1.0)),\n        dot(random3(pi + vec3(1.0,1.0,1.0)),pf-vec3(1.0,1.0,1.0))\n    );\n    \n    vec4 bottom = vec4(\n        dot(random3(pi + vec3(0.0,0.0,0.0)),pf-vec3(0.0,0.0,0.0)),\n        dot(random3(pi + vec3(1.0,0.0,0.0)),pf-vec3(1.0,0.0,0.0)),\n        dot(random3(pi + vec3(0.0,1.0,0.0)),pf-vec3(0.0,1.0,0.0)),\n        dot(random3(pi + vec3(1.0,1.0,0.0)),pf-vec3(1.0,1.0,0.0))\n    );\n    \n    return trilinear(bottom,up,weight);\n}\n\nfloat turbulence_perline(vec3 uv,float lattice,int depth,bool flag,bool sine)\n{\n    float scale = 1.0;\n    float amplitude = 1.0;\n    float noise = 0.0;\n    \n    for (int i = 0; i < depth; i++)\n    {\n        if (flag){\n            noise += abs((perline_noise(uv*scale,lattice)) * amplitude);\n        }\n        else{\n            noise += (perline_noise(uv*scale,lattice) * amplitude);\n        }\n        \n        scale *= 2.0;\n        amplitude /= 2.0;\n    }\n    \n    if (sine)\n    {\n        noise = sin(uv.y*3.0 + noise*6.0);\n    }\n    return noise;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float lattice = 256.0;\n    float frequency = 4.0;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 col = texture(iChannel0, uv);\n    uv = uv * vec2(iResolution.x/iResolution.y, 1.0);\n    \n    \n    float noise = turbulence_perline(frequency*vec3(uv,iTime*0.1),lattice, 2, false, false);\n    float c = noise*0.5 + 0.5;\n    //float c = noise;\n    fragColor = vec4(c,c,c,1.0);\n    //fragColor = col * noise;\n    /*\n    fragColor = vec4(\n        random3(vec3(fragCoord,0.0)),\n        1.0\n    );\n    */\n}\n","name":"Image","description":"","type":"image"}]}