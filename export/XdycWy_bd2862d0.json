{"ver":"0.1","info":{"id":"XdycWy","date":"1523097958","viewed":3192,"name":"Accelerated two pass raymarching","username":"Psycho","description":"As used in One Of Those Days - http://www.pouet.net/prod.php?which=75790\n\nExample of a raymarching low res pass that not only establish a coarse zbuffer for the primary rays, but also adds object masking and accelerates shadow rays. ","likes":65,"published":1,"flags":32,"usePreview":0,"tags":["raymarch","masking","shadows","optimization"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Illustrative example of my new tile based ray marching acceleration\n// First used in the 8kb intro One Of Those Days - http://www.pouet.net/prod.php?which=75790 \n\n// Red: iteration count primary rays\n// Green: iteration count shadow rays\n\n// The main discovery is that the additional stepping into the object looking for a \n// negative sdf value large enough to fully cover (and thus terminate) the tile\n// cone/beam, can give us:\n// a) occlusion in our scene mask determination\n// b) a tile bounding sphere from which to run a similar shadow beam trace for masking/maxdistance\n// c) which may also determine the whole tile as shadowed\n\n// It is not worth measuring performance on this scene and setup, instead look at \n// the iteration counts and masking.\n\n// In One Of Those Days (which doesn't have that many objects on screen and \n// with the trees overextending) it renders a good twice as fast with the prepass.\n// Similar iteration shot from the actual intro:\n// http://misc.loonies.dk/oneofthosedays_iterations.jpg\n// http://misc.loonies.dk/oneofthosedays_iterations_nopre.jpg\n\n\n/////////////////// Scene setup shared between passes //////////\nvec3 lightdir=vec3(-1,.7,1), campos=vec3(5,3.5,5);\nfloat viewrange=50.;\nvec3 color=vec3(1,0,0);\n\nvec3 rotatey(vec3 r, float v)\n{\n\treturn vec3(r.x*cos(v)+r.z*sin(v),r.y,r.z*cos(v)-r.x*sin(v)); \n}\n\nfloat box( vec3 p, vec3 b )\n{\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.) +\n\tlength(max(d,0.));\n}\n\nfloat sdf(vec3 p, int mask) \n{\n\tp= rotatey(p,iTime);\n\tfloat r = 100.;\n    \n    if ((mask&1)>0)\n    {\n        r = p.y;\n        color = vec3(.7,.7,.7);\n    }\n    \n    if ((mask&2)>0)\n    {\n        float r2 = box(p-vec3(2,2,0),vec3(1));\n        if (r2<r)\n        {\n            r=r2;\n            color = vec3(1,0,0);\n        }\n    } \n    \n    if ((mask&4)>0)\n    {\n        float r2 = length(p-vec3(-2,3,0))-1.;\n        if (r2<r)\n        {\n            r=r2;\n            color = vec3(0,0,1);\n        }\n    }  \n\treturn r;\n}\n\nvoid setup(in vec2 fragCoord, out vec3 vdir)\n{\n    vec2 p = fragCoord.xy / iResolution.xy-.5;\n\tvdir= normalize(rotatey(rotatey(\n        vec3(p.y,p.x*iResolution.x/iResolution.y,1)\n\t\t,-.3).yxz,3.65));\n}\n///////////////////////////////////////////////////////////\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // 0: visual, 1: iterations optimized, 2: iterations without prepass, 3: primary mask\n    int mode = int(mod(iTime,4.));\n   \n    vec3 vdir, vpos= campos, e=vec3(.01,0,0), res = vec3(.7,.7,.9);\n    setup(fragCoord, vdir);\n    \n    // parse info from pre pass\n    vec4 pass1 = texture(iChannel0, vec2((fragCoord.x-4.)/iResolution.x/8., (fragCoord.y-4.)/iResolution.y/8.));\n    int mask = int(pass1.y), shadowmask=int(pass1.w);\n  \tfloat primary_tmin= pass1.x, shadow_tmax=pass1.z; \n\n    if (mode==2)\n    {\n        mask=shadowmask=255;\n        primary_tmin=0.;\n        shadow_tmax=viewrange;\n    }\n\n    // ordinary raymarching using the values from above...\n    float t=primary_tmin, stp=0.;\n    vec2 iterations = vec2(0,0);\n  \tdo\n  \t{\n        iterations.x++;\n        t+=stp;\n\t\tstp = sdf(vpos+vdir*t,mask);\n  \t} \n    while (t<viewrange && stp>.001*t);\n    \n  \tif (t<viewrange) \n  \t{ \n    \tvpos+= vdir*t;  \n        vec3 m = color,\n\t\tn= normalize(vec3(sdf(vpos+e.xyy,mask),sdf(vpos+e.yxy,mask),sdf(vpos+e.yyx,mask))-stp);\n        vpos+=n*.02;\n        \n        t = 0.;\n        float ph=1e10, shadow=.3;\n        if (shadowmask<1024)\n        {\n            // simple hard shadows for the example - otherwise shadow beam in prepass should be widened\n            do\n            {\n                iterations.y++; \n                stp = sdf( vpos + normalize(lightdir)*t, shadowmask );\n                t += stp;\n            }\n            while (t<shadow_tmax && stp>.01); \n\n           if (t>shadow_tmax)\n                shadow=1.;\n    \t}\n        \n\t\tres =clamp(dot(normalize(lightdir),n),.0,1.) * m * shadow;\n\t}\n    \n    if (mode>0) \n        res = vec3(iterations.xy*.03,0.);\n    if (mode==3)\n        res = vec3((mask&1)>0,(mask&2)>0,(mask&4)>0);\n    fragColor.xyz= res;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/////////////////// Scene setup shared between passes //////////\nvec3 lightdir=vec3(-1,.7,1), campos=vec3(5,3.5,5);\nfloat viewrange=50.;\nvec3 color=vec3(1,0,0);\n\nvec3 rotatey(vec3 r, float v)\n{\n\treturn vec3(r.x*cos(v)+r.z*sin(v),r.y,r.z*cos(v)-r.x*sin(v)); \n}\n\nfloat box( vec3 p, vec3 b )\n{\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) +\n\tlength(max(d,0.0));\n}\n\nfloat sdf(vec3 p, int mask) \n{\n\tp= rotatey(p,iTime);\n\tfloat r = 100.;\n    \n    if ((mask&1)>0)\n    {\n        r = p.y;\n        color = vec3(.7,.7,.7);\n    }\n    \n    if ((mask&2)>0)\n    {\n        float r2 = box(p-vec3(2,2,0),vec3(1));\n        if (r2<r)\n        {\n            r=r2;\n            color = vec3(1,0,0);\n        }\n    } \n    \n    if ((mask&4)>0)\n    {\n        float r2 = length(p-vec3(-2,3,0))-1.;\n        if (r2<r)\n        {\n            r=r2;\n            color = vec3(0,0,1);\n        }\n    }  \n\treturn r;\n}\n\nvoid setup(in vec2 fragCoord, out vec3 vdir)\n{\n    vec2 p = fragCoord.xy / iResolution.xy-.5;\n\tvdir= normalize(rotatey(rotatey(\n        vec3(p.y,p.x*iResolution.x/iResolution.y,1)\n\t\t,-.3).yxz,3.65));\n}\n\n///////////////////////////////////////////////////////////\n\n\n#define BITS 8\n\n// adapted from hlsl and unwrapped/expanded/commented, \n// but probably still looks too much like size coding for some ;)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 vdir, vpos= campos;\n    if (fragCoord.x*8.<iResolution.x && fragCoord.y*8.<iResolution.y)\n    {\n\t\tsetup(fragCoord*8.+4., vdir);\n        \n        // bitmasks to record in\n\t\tint primarymask = 0, shadowmask = 255; // set shadow mask for the case where we don't run part 2\n\t\tfloat tmax = viewrange, tmin = tmax, shadowmax = tmax, \n              conewidth = 4. / iResolution.y; // sufficient width of tile cone for our test setup\n\n        // run for each object(mask) in our sdf \n        for (int mask = 1; mask < BITS; mask *= 2)\n        {\n            float stp = .1, t1 = 0., t2;\n            // step until the cone intersects something\n            while (t1<tmax && stp> .04+t1*conewidth)\n            {\n                t1 += stp-t1*conewidth;\n                stp = sdf(vpos + vdir * t1, mask);\n            }\n            if (t1 < tmax)\n            {\n                t2 = t1;\n                // step further on until cone is completely inside (if ever)\n                // a very large bounding sphere isn't useful so we stop at t1*1.5+1\n                while (t2<min(tmax,t1*1.5 + 1.) && stp>-t2*conewidth)\n                {\t\n                    t2 += max(.01, stp) + t2*conewidth;\n                    stp = sdf(vpos + vdir * t2, mask);            \n                }\n\n                if (stp < -t2*conewidth)\n                {\n                    // clear earlier results if they are occluded and set new max for next bit\n                    if (t2 < tmin) primarymask = 0; \n                    tmax = min(t2, tmax);\n                }\n                primarymask |= mask;\t\t\n                tmin = min(t1, tmin);\n            }\n        }\n        // do we have a useful situation for shadow optimization?\n        if (primarymask>0 && tmax < tmin*1.5+1.)\n        {\n            shadowmask = 0; shadowmax = 0.;\n            vec3 dir = normalize(lightdir), \n            // set up the bounding sphere for visible pixels in our tile    \n            center = vpos + vdir * (tmin + tmax)*.5;;\n            conewidth = (tmax - tmin)*.5+.05;     \n\n            for (int m = 1; m < BITS; m *= 2)\n            {\n                //find first intersection\n                float stp = conewidth+.1, t = viewrange;\n                while (t>0. && stp>conewidth)\n                {\n                    t -= stp - conewidth+.02;\n                    stp = sdf(center + dir * t, m);                \n                }         \n                \n                // if we got a hit, record in shadow mask\n                if (stp<conewidth) shadowmask |= m; \n                // and update the maximum distiance (from primary hitpoint) we have to trace shadows\n                shadowmax = max(t + .01, shadowmax);\n\n                // step further into object searching for total occlusion\n                for (int i = 0; i<30 && stp>-conewidth && t > conewidth; i++)\n                    stp = sdf(center + dir * (t -= max(stp + conewidth, .1)), m);\n\n                // our whole tile is shadowed so no need to continue, mark with special value 1024.\n                if (stp < -conewidth && t>conewidth) { shadowmask = 1024; break; }\n            }\n        }\n        fragColor = vec4(tmin, primarymask, shadowmax, shadowmask); \n    }\n}","name":"Buf A","description":"","type":"buffer"}]}