{"ver":"0.1","info":{"id":"4cS3Wc","date":"1704681954","viewed":6,"name":"Volumetric Mandelbox","username":"BearKirb","description":"As always, volumetrics are difficult to optimize.  In this program I attempt to optimize volumetrics for any sdf while maintaining descent visuals.  Let me know how I did in the comments!","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","cloud","volumetric","fog","mandelbox"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float Mand(vec3 pos) {\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n    float Bailout=2.0;\n    float Power=8.0;\n    int Iterations = 3;\n\tfor (int i = 0; i < Iterations ; i++) {\n\t\tr = length(z);\n\t\tif (r>Bailout) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n\t}\n\treturn 0.5*log(r)*r/dr-0.01;\n}\n float distanceEstimatorBox(vec3 z, vec3 c1, vec3 c2) {\n    \tvec3 closestPoint = clamp(z, c1, c2);\n    \treturn length(z - closestPoint);\n    }\n      const int iterations = 5;\n    \n    float Scale = 2.48;\n    float foldingLimit = 1.50;\n    float fixedRadius2 = 4.0;\n    float minRadius2 = 0.0;\n\t\n\tvec3 boxCorner1 = vec3(-8.0, 9.0, -8.0);\n\tvec3 boxCorner2 = vec3(8.0, 20.0, 8.0);\n    float distanceEstimator1(vec3 z) {\n    \treturn min(distanceEstimatorBox(z, boxCorner1, boxCorner2), distanceEstimatorBox(z, boxCorner1-vec3(0.0, 28.0, 0.0), boxCorner2-vec3(0.0, 28.0, 0.0)));\n    }\n    \n    float distanceEstimator2(vec3 z) {\n\t\tvec3 offset = z;\n\t\t\n\t\tfloat dr = 1.0;\n\t\t\n\t\tfor (int n = 0; n < iterations; n ++) {\n\t\t\tz = clamp(z, -foldingLimit, foldingLimit) * 2.0 - z;\n\t\t\tfloat r2 = dot(z,z);\n\t\t\tfloat temp = r2 < minRadius2 ? (fixedRadius2/minRadius2) : (r2 < fixedRadius2 ? (fixedRadius2 / r2) : 1.0);\n\t\t\tz *= temp;\n\t\t\tdr *= temp;\n\t\t\tz = z * Scale + offset;\n\t\t\tdr = dr * abs(Scale) + 1.0;\n\t\t}\t\n\t\treturn length(z) / abs(dr);\n    }\nfloat distanceEstimator(vec3 z) {\n    \treturn distanceEstimator2(z);\n    }\nfloat random(in vec2 uv)\n{\n    return 0.0;\n}\n\nfloat noise(in vec2 uv)\n{\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n    f = f * f * (3. - 2. * f);\n    \n    float lb = random(i + vec2(0., 0.));\n    float rb = random(i + vec2(1., 0.));\n    float lt = random(i + vec2(0., 1.));\n    float rt = random(i + vec2(1., 1.));\n    \n    return mix(mix(lb, rb, f.x), \n               mix(lt, rt, f.x), f.y);\n}\n\n#define OCTAVES 8\nfloat fbm(in vec2 uv)\n{\n    float value = 0.;\n    float amplitude = .5;\n    \n    for (int i = 0; i < OCTAVES; i++)\n    {\n        value += noise(uv) * amplitude;\n        \n        amplitude *= .5;\n        \n        uv *= 2.;\n    }\n    \n    return value;\n}\n\nvec3 Sky(in vec3 ro, in vec3 rd)\n{\n    const float SC = 1e5;\n\n \t// Calculate sky plane\n    float dist = (SC - ro.y) / rd.y; \n    vec2 p = (ro + dist * rd).xz;\n    p *= 1.2 / SC;\n    \n    // from iq's shader, https://www.shadertoy.com/view/MdX3Rr\n    vec3 lightDir = normalize(vec3(-.8, .15, -.3));\n    float sundot = clamp(dot(rd, lightDir), 0.0, 1.0);\n    \n    vec3 cloudCol = vec3(1.);\n    //vec3 skyCol = vec3(.6, .71, .85) - rd.y * .2 * vec3(1., .5, 1.) + .15 * .5;\n    vec3 skyCol = vec3(0.3,0.5,0.85) - rd.y*rd.y*0.5;\n    skyCol = mix( skyCol, 0.85 * vec3(0.7,0.75,0.85), pow( 1.0 - max(rd.y, 0.0), 4.0 ) );\n    \n    // sun\n    vec3 sun = 0.25 * vec3(1.0,0.7,0.4) * pow( sundot,5.0 );\n    sun += 0.25 * vec3(1.0,0.8,0.6) * pow( sundot,64.0 );\n    sun += 0.2 * vec3(1.0,0.8,0.6) * pow( sundot,512.0 );\n    skyCol += sun*2.0;\n    \n    // clouds\n    float t = iTime * 0.5;\n    float den = fbm(vec2(p.x - t, p.y - t));\n    skyCol = mix( skyCol, cloudCol, smoothstep(.4, .8, den));\n    \n    // horizon\n    skyCol = mix( skyCol, 0.68 * vec3(.418, .394, .372), pow( 1.0 - max(rd.y, 0.0), 16.0 ) );\n    \n    return skyCol;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = a-b;\n    return 0.5*( (a+b) - sqrt(h*h+k) );\n}\nfloat sdBox( vec3 p, vec3 b ,float r)\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0)-r;\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat sdf(vec3 p){\n\n//float f=sdBox(p,vec3(1.0,0.2,1.0),0.1);\n//f=smin(f,sdTorus(p-vec3(0.0,0.3,0.0),vec2(0.5,0.1)),0.005);\nfloat f= distanceEstimator(p);\nreturn f;\n}\n\nvoid Rotate( inout vec3 vector, vec2 angle )\n{\n\tvector.yz = cos(angle.y)*vector.yz\n\t\t\t\t+sin(angle.y)*vec2(-1,1)*vector.zy;\n\tvector.xz = cos(angle.x)*vector.xz\n\t\t\t\t+sin(angle.x)*vec2(-1,1)*vector.zx;\n}\nvoid Rotate( inout vec2 vect, vec2 angle )\n{\nvec3 vector = vec3(vect.x,0.0,vect.y);\n\tvect.yx = cos(angle.y)*vector.yz\n\t\t\t\t+sin(angle.y)*vec2(-1,1)*vector.zy;\n\tvect.xy = cos(angle.x)*vector.xz\n\t\t\t\t+sin(angle.x)*vec2(-1,1)*vector.zx;\n}\nvec3 calcNormal(vec3 p) {\nfloat EPSILON = 0.0001;\n    return normalize(vec3(\n        sdf(vec3(p.x + EPSILON, p.y, p.z)) - sdf(vec3(p.x - EPSILON, p.y, p.z)),\n        sdf(vec3(p.x, p.y + EPSILON, p.z)) - sdf(vec3(p.x, p.y - EPSILON, p.z)),\n        sdf(vec3(p.x, p.y, p.z  + EPSILON)) - sdf(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\nfloat shadow( in vec3 ro, in vec3 rd)\n{\n    float res = 1.0;\n  vec3 po=rd;\n  int breaki=0;\n  float minDist=10000.0;\n  float count=0.0;\n    for( int i=0; i<44; i++ )\n    {\n  \n        po -= normalize(rd-ro) * sdf(po);\n        minDist=min(minDist,sdf(po));\n  \n      \n      \n    }\n          if( sdf(po)<0.04){\n        if(distance(po,ro)<0.04){\n            return 1.0;\n            }else{\n            return 0.0;\n            }\n            }\n    return 1.0;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = 8.0*(fragCoord-iResolution.xy*0.5)/-iResolution.x;\n vec3 ray = normalize( vec3(\n\t\t\t\t(fragCoord-iResolution.xy*.5)/iResolution.x, \n\t\t\t\t0.4 ) ); \n             \n    vec3 pos = vec3(0.0,0.0,-18.0); \n    \n  \n float cou=0.0;\n    \nvec2 angle = -(iMouse.xy/iResolution.xy-.5)*4.14+vec2(3.14,0.0);\n\tRotate(pos,angle);\n \n\tRotate(ray,angle);\n vec3 cameraPos = pos; \n    fragColor = texture(iChannel0, ray);\n    float cameraPosDist=distance(vec3(0.0,0.0,0.0),cameraPos);\n    for(int x=0;x<110;x++){\n    float h=sdf(pos);\n    if((x>30&&cou<0.1)||distance(cameraPos,pos)>30.0){\n    break;\n    }\n    cou+=min(pow(2.0,-h*36.0),1.0);\n   \n  \n    pos+=ray*max(h,0.05);\n    \n    }\n    \n    \n \n    fragColor.rgb += vec3(cou/50.0);//max((ambient),(ambient+lambert+spec+reflec));\n \n    \n    fragColor.a = 1.0;\n}","name":"Image","description":"","type":"image"}]}