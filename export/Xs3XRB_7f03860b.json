{"ver":"0.1","info":{"id":"Xs3XRB","date":"1460131802","viewed":635,"name":"Procedural Forest","username":"tomkel","description":"started life as a cave .... its an attempt at making  a cell shaded forest. Its probably overkill the way it is done - uses a cellular automata to make the clumps, converts into SDF and ray marches. Move around with arrow keys.","likes":10,"published":1,"flags":48,"usePreview":0,"tags":["procedural"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sphere( vec3 spherepos, float r, vec3 raypos )\n{\n    return distance( spherepos, raypos ) - r;\n}\n\nvec4 getlight( vec3 normal, vec3 position, vec3 lightpos, vec4 lightcolour  )\n{\n    float d = distance( position, lightpos );\n    vec3 n = normalize( position - lightpos );\n    return max( dot( normal, n ), 0.0 ) * lightcolour;\n    \n}\n\nvec4 hardmin( float k, vec4 a, vec4 b)\n{\n    if ( a.x < b.x )\n    {\n        return a; \n    }\n    \n    return b;\n}\n\nvec4 softmin( float k, vec4 a , vec4 b )\n{\n    float res = exp( -k*a.x ) + exp( -k*b.x );\n    float blend = -log( res )/k;\n    float aw = exp( -k*a.x ) / res;\n    float bw = exp(-k*b.x) / res;\n    \n    return vec4( blend, aw*a.yzw + bw*b.yzw );\n}\n\n\nvec4 canopy( vec3 raypos )\n{\n     const float scale = 0.01;\n    const vec3 material = vec3( 0.0, 0.5, 0.0 );\n    float d0 = texture( iChannel2 , raypos.xz * 0.1  ).x * 0.4;\n    //float sdf = (texture( iChannel1 , raypos.xz  * scale ).x - 0.5) * 0.5 ;\n    return vec4( 3.0 - raypos.y - d0, material );\n}\n\nfloat baseground( vec3 raypos )\n{\n    float d1 = 0.05 - texture( iChannel2 , raypos.xz * 0.1  ).x * 0.4;\n    return raypos.y + d1;\n}\n\nvec4 ground( vec3 raypos )\n{\n    const vec3 material = vec3( 0.0,1.0,0.0 );\n    //float d1 = 0.05 - texture( iChannel2 , raypos.xz * 0.1  ).x * 0.4;\n    float grassheight = 0.1 - texture( iChannel2 , raypos.xz * 4.0  ).x * 0.1;\n    \n    return vec4( baseground( raypos ) + grassheight, material );\n}\n\nvec4 walls( vec3 raypos )\n{\n   const float scale = 0.01;\n   const vec3 material = vec3( 0.5,0.0,0.0 );\n   float d1 = 0.5 - texture( iChannel2 , raypos.xz * 0.1  ).x ;\n   float sdf = (texture( iChannel1 , (raypos.xz - vec2(  d1*raypos.y,0.0) * 0.5 ) * scale ).x - 0.5) * 2.0 ;\n   return vec4( sdf,  material );\n}\n\n\nvec4 water( vec3 raypos )\n{\n    vec2 pos = mod( abs(raypos.xz), 2.0 ) - vec2( 1.0, 1.0 );\n    float d = 0.5  + cos( (length(  pos ) - iTime * 0.0125) * 64.0 ) * 0.5 ;\n    d *= exp( -length( pos ) );\n    const vec3 material = vec3(0.0,0.0,0.5);\n    \n    vec3 r = reflect( normalize(raypos), vec3(0,1,0 ) );\n    \n    \n    if ( d > 0.5)\n    {\n         return vec4( raypos.y + 0.05, vec4(2.0,2.0,2.0,1.0)  );\n    }  \n    return vec4( raypos.y + 0.05, material );\n}\n\n\nvec4 sdf( vec3 raypos )\n{\n    const float scale = 0.01;\n    float e = 1.5  ;\n\n    return hardmin( e, water( raypos ),\n           hardmin( e, ground(raypos ), \n           softmin( e, canopy( raypos), \n                       walls( raypos ))));\n}\n\n\nvec3 grad( vec3 raypos, float delta )\n{\n    float dx =  sdf( raypos + vec3( delta, 0,0 ) ).x - sdf( raypos - vec3( delta,0,0 ) ).x;\n    float dy =  sdf( raypos + vec3( 0, delta,0 ) ).x - sdf( raypos - vec3( 0,delta,0 ) ).x;\n    float dz =  sdf( raypos + vec3( 0,0, delta ) ).x - sdf( raypos - vec3( 0,0,delta ) ).x;\n    return vec3( -dx,-dy,-dz );\n}\n\nvec4 march( vec3 ray, vec3 origin, float ep )\n{\n    vec3 p = origin;\n    for ( int i = 0; i < 1024; i++ )\n    {\n        vec4 step = sdf(p);\n        if ( step.x  <  ep )\n        {\n          vec3 normal = normalize( grad( p, 0.1 ) );\n          // return getlight( normal, p,  origin, vec4(1.0, 1.0, 1.0, 1.0 )) * vec4( step.yzw, 1.0 ); // + \n                  //getlight( normal, p,  vec3( -100,-100,-100 ), vec4(0.0,1.0,1.0,1.0 )) ;\n           // if ( i > )\n           // {\n             //   return vec4( 0,0,0, 1.0 );\n           // }\n           // else \n            {\n                float l =  pow( (1.0 - max(0.0, dot( normalize( ray ), normal ))),1.0);\n                \n                if ( l > 0.5 )\n                {\n            \t\treturn vec4( step.yzw, 1.0 ) * 0.5;\n                }\n                else\n                {\n                    return vec4( step.yzw, 1.0 ) * 1.0;\n                }\n            }\n          //return vec4( normal.z, normal.z, normal.z, 1.0 );\n          // return texture( iChannel1 , (p.xz ) * 0.01);// / iChannelResolution[1].xy )); \n        }\n        \n        p += ray * step.x;\n    }\n    \n    return vec4(0.0,0,0,1);\n}\n\n\nvec3 hit( vec3 ray, vec3 origin, float ep )\n{\n    vec3 p = origin;\n    for ( int i = 0; i < 1024; i++ )\n    {\n       float  step = baseground(p);\n        if ( step  <  ep )\n        {\n            return p;\n        }\n        \n        p += ray * step;\n    }\n    \n    return origin;\n}\n\nvec3 rotatevecY( vec3 vec, float angle )\n{\n    vec3 m0 = vec3( cos( angle ), 0, sin( angle ));\n    vec3 m1 = vec3( 0            , 1.0,   0      );\n    vec3 m2 = vec3( -sin( angle ), 0, cos( angle ) );\n    \n    return vec3(  dot( m0, vec ), dot( m1, vec ), dot( m2, vec )) ;\n} \n\n\nvoid mainMarch( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n /*  if ( fragCoord.x >=  float(iFrame)  &&\n        fragCoord.x <= float(iFrame+1) )\n   {\n       fragColor = vec4(1,1,1,1);\n   }\n    else */\n    {\n    \n    float aspect = iResolution.y / iResolution.x;\n    \n    vec4 pos = texture( iChannel3, vec2(0,0));\n    \n    vec3 origin = pos.xyz;\n    vec3 ray = vec3( uv.x - 0.5, (uv.y - 0.5) * aspect, 0.5 );\n    \n    float angle = (iMouse.x / iResolution.x - 0.5) * 2.0 * 3.142;\n    \n    ray = rotatevecY( ray,  angle ) ; //(iMouse.x / iResolution.x - 0.5) * 2.0 * 3.142  ) ;// iTime );\n   // origin = rotatevecY( origin, 0.0 ); //iTime );\n    \n    origin = hit( vec3(0,-1,0 ), origin, 0.01 ) + vec3(0,0.5,0);\n    \n\tfragColor = march( ray, origin, 0.01 );\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    mainMarch( fragColor, fragCoord );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// buff a\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \n    if ( iFrame < 50 )\n    {\n        vec2 uv =  fragCoord / iChannelResolution[1].xy ;\n      \tvec4 init = texture( iChannel1, uv);\n        if ( init.x > 0.6 )\n        {\n        \tfragColor = vec4(1.0,0.0,0.0,1.0 );\n        }\n        else\n        {\n            fragColor = vec4(0.0,0.0,0.0,1.0 );\n        }\n    }\n   else if ( iFrame > 50 && iFrame <  100 )\n    {\n        int neighbours = 0;\n        int alive = 0;\n        for ( int i = -1; i <= 1; i++ )\n        {\n            for ( int j = -1; j <= 1; j++ )\n            {\n                vec2 uv = (vec2(float(i),float(j))  + fragCoord ) / iChannelResolution[0].xy;\n                float cell = texture( iChannel0, uv ).x; \n                if ( !(i == 0 && j == 0 ))\n                {\n                    if ( cell > 0.5 )\n                    {\n                        neighbours++;\n                    }\n                }\n                else\n                {\n                    if ( cell > 0.5 )\n                    {\n                        alive = 1;\n                    }\n                }\n            }\n            \n        }\n        \n      \n\t\t// game of life\n        /*\n\t\tif ( (alive == 1) && ( neighbours == 2 || neighbours == 3 ) )\n        {\n            fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n        }\n        else if ( ( alive == 0 ) && ( neighbours == 3 ) )\n        {\n             fragColor = vec4(1.0,0.0,0.0,1.0);\n        }\n        else\n        {\n             fragColor = vec4(0.0,0.0,0.0,1.0);\n        } \n\t    */\n        \n         \n        \n        // caves: \n        // from http://gamedevelopment.tutsplus.com/tutorials/generate-random-cave-levels-using-cellular-automata--gamedev-9664\n\t    if( alive == 1 && (neighbours >= 4) )\n        {\n             fragColor = vec4(1.0,0.0,0.0,1.0);\n        }\n        else if ( alive == 0 && ( neighbours >= 5 ) )\n        {\n \t\t\tfragColor = vec4( 1.0,0.0,0.0,1.0);\n        }\n        else\n        {\n            fragColor = vec4( 0.0, 0.0,0.0,1.0);\n        }\n        \n    \n    } \n    else\n    {\n           vec2 uv = fragCoord  / iChannelResolution[0].xy;\n           fragColor = texture( iChannel0, uv ); \n    }\n}\n\n","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n// buff b\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord + vec2(0.0,0.0) ) / iChannelResolution[0].xy;\n    vec4 id = texture( iChannel0, uv ); \n    \n    if ( iFrame < 101 )\n    {\n    \tfragColor = vec4(0.0,0.0,0.0,1.0);\n    }\n    else if ( iFrame >= 101  && iFrame <= 102 )\n    {\n   \n        const int w = 4;\n        float r = length( vec2( float(w), float(w)) );\n        float maxdist = r;\n        for ( int i = -w; i <= w; i++ )\n        {\n            for( int j = -w; j <=w;j++ )\n            {\n                if ( !(j==0 && i==0) )\n                {\n                    float dist = length( vec2(float(i),float(j) )); \n                    vec2 offset = (vec2(float(i)+0.0,float(j) + 0.0) + fragCoord )/ iChannelResolution[0].xy;\n                    vec4 n = texture( iChannel0, offset ); \n                    if ( (abs(n.x - id.x ) > 0.0 ) && (dist < maxdist) )\n                    {\n                        maxdist = dist ;\n                    }\n                }\n\n            }\n        }\n\n        if ( id.x > 0.1 )\n        {\n            maxdist = -maxdist;\n        }\n\n        maxdist += r;\n        fragColor = vec4( maxdist, 0.0, 0.0, r ) / (2.0*r);\n    }\n    else\n    {\n        vec2 uv = fragCoord  / iChannelResolution[1].xy;\n    \tvec4 id = texture( iChannel1, uv ); \n        fragColor = id;\n    }\n}\n","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"const float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\n\nconst float delta = 0.1;\n\nvec3 rotatevecY( vec3 vec, float angle )\n{\n    vec3 m0 = vec3( cos( angle ), 0, sin( angle ));\n    vec3 m1 = vec3( 0            , 1.0,   0      );\n    vec3 m2 = vec3( -sin( angle ), 0, cos( angle ) );\n    \n    return vec3(  dot( m0, vec ), dot( m1, vec ), dot( m2, vec )) ;\n} \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if ( iFrame < 100 )\n    {\n        fragColor = vec4(1.0, 1.0, 0.0,160.0);\n    }\n    else\n    {\n    vec3 last = texture( iChannel2, vec2(0,0)).xyz;\n    \n    float angle = (iMouse.x / iResolution.x - 0.5) * 2.0 * 3.142;\n    vec3 front  = rotatevecY( vec3(0,0,1), angle ); \n    \n    vec3 left =   cross( front, vec3(0,1,0) );\n    \n    last += delta * -left * texture( iChannel1, vec2( KEY_RIGHT, 0.5/3.0 )).x;\n    last += delta * left * texture( iChannel1, vec2( KEY_LEFT, 0.5/3.0 )).x;\n    last += delta * front * texture( iChannel1, vec2( KEY_UP, 0.5/3.0 )).x;\n    last += delta * -front * texture( iChannel1, vec2( KEY_DOWN, 0.5/3.0 )).x;\n    \n    fragColor = vec4(last,1.0);\n    }\n}","name":"Buf C","description":"","type":"buffer"}]}