{"ver":"0.1","info":{"id":"MXffDX","date":"1729064108","viewed":77,"name":"learn curling smoke from leon","username":"ruochen","description":"learn how to create curling smoke from leon's project","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["procedural","2d","noise","curl"],"hasliked":0,"parentid":"cl23Wt","parentname":"Curling Smoke"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// forked from Curling Smoke by Leon:https://www.shadertoy.com/view/cl23Wt\n\nfloat DistanceFromSphere(vec3 point, vec3 c, float r)\n{\n    return distance(point, c) - r;    \n}\n\nvec3 sphere_center = vec3(0);\nvec3 sphere_vel = vec3(0);\n\nfloat MapWorld(vec3 point)\n{   \n    float map_result = DistanceFromSphere(point, sphere_center, 1.0);\n    //float displacement = sin(5.0 * point.x) * cos(5.0 * point.y) * sin(5.0 * point.z - iTime) * 0.05;// * abs(cos(iTime));\n    // return map_result + displacement;\n    return map_result;\n}\n\nvec3 GetFlowNormal(vec2 in_uv)\n{\n    // frame\n    vec3 color = texture(iChannel0, in_uv).rgb;\n    vec3 blu = normalize(color.xyz);\n    // normal\n    \n    vec2 e = vec2(pow(blu.z, 3.)*5e-3,0);\n    #define T(u) texture(iChannel0, in_uv+u).r\n    vec3 normal = vec3(\n        T(e.xy)-T(-e.xy), \n        T(-e.yx)-T(e.yx),\n        color.r*.1);\n    if (abs(normal.x) + abs(normal.y) + abs(normal.z) > .001)\n        normal = normalize(normal);\n             \n    return normal;\n}\n\nvec3 CalculateNormal(vec3 point)\n{\n    vec3 SMALL_STEP = vec3(1e-3, 0.0, 0.0);\n\n    float gradient_x = MapWorld(point + SMALL_STEP) - MapWorld(point - SMALL_STEP);\n    float gradient_y = MapWorld(point + SMALL_STEP.yxy) - MapWorld(point - SMALL_STEP.yxy);\n    float gradient_z = MapWorld(point + SMALL_STEP.yyx) - MapWorld(point - SMALL_STEP.yyx);\n\n\n    return normalize(vec3(gradient_x, gradient_y, gradient_z));\n}\n\nvec3 getFlowColor(vec2 texture_uv)\n{\n    // frame\n    vec3 color = texture(iChannel0, texture_uv).rgb;\n    return color;\n}\n\nvec3 light_position = normalize(vec3(.5, -0.4, 1.));\nvec3 RayMarch(vec3 ro, vec3 rd)\n{\n    float total_distance_traveled = 0.0;\n    const int STEPS = 32;\n    const float MINIMUM_HIT_DISTANCE = 1e-3;\n    const float MAXIMUM_TRACE_DISTANCE = 1e3;\n\n    for(int i = 0; i <STEPS; ++i)\n    {\n        vec3 current_position = ro + total_distance_traveled*rd;\n        //float distance_to_closest = MapWorld(current_position);\n        float distance_to_closest = MapWorld(current_position);\n        // close enough, hit the object\n        if(distance_to_closest < MINIMUM_HIT_DISTANCE)\n        {\n            vec3 normal = -CalculateNormal(current_position);                       \n            vec2 color_coord = normal.xy * 0.5 + 0.5;\n#if USE_FLOW_NORMAL==1            \n            normal = normalize(normal - GetFlowNormal(color_coord)*0.5);\n#endif            \n            vec3 diffuse_color = getFlowColor(color_coord);\n                        \n            //float diffuse_intensity = max(0.1, dot(normal, direction_to_light));\n            float diffuse_intensity = smoothstep(0.0, 1.0, dot(normal, light_position));\n            vec3 ambient = vec3(0.05);\n            return diffuse_intensity*diffuse_color+ ambient;\n        }\n\n        // traveled long enough and hit nothing, return black color\n        if(total_distance_traveled > MAXIMUM_TRACE_DISTANCE)\n        {\n            break;\n        }\n\n        total_distance_traveled += distance_to_closest;\n    }\n    return vec3(0.2);\n}\n\nvoid GetPixelColor(vec3 ro, vec3 rd, out vec4 pixel_color)\n{    \n    pixel_color = vec4(RayMarch(ro, rd), 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordinates\n    vec2 uv = fragCoord/iResolution.xy;\n    \n#if SHOW_TEX==1\n    // noise\n    //vec3 blu = texture(iChannel1, fragCoord/1024.).rgb;\n    vec3 color = texture(iChannel0, uv).rgb;\n#if USE_FLOW_NORMAL==1\n    vec3 normal = GetFlowNormal(uv);\n    // shade\n    color *= dot(normal, light_position)*.5+.5;\n#endif\n    fragColor = vec4(color,1.0);\n#else\n    // ray march sphere\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, -1.5);    \n    vec3 rd = normalize(vec3(uv, 1));\n\n    GetPixelColor(ro, rd, fragColor);\n#endif\n   \n}\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// forked from Curling Smoke by Leon:https://www.shadertoy.com/view/cl23Wt\n\nfloat pi = 3.1415926;\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64);\n\nfloat hash(float n)\n{\n    return fract(sin(n) * 43758.5453);\n}\n\n///\n/// Noise function\n///\nfloat noise(in vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    \n    f = f * f * (3.0 - 2.0 * f);\n    \n    float n = p.x + p.y * 57.0 + 113.0 * p.z;\n    \n    float res = mix(mix(mix(hash(n +   0.0), hash(n +   1.0), f.x),\n                        mix(hash(n +  57.0), hash(n +  58.0), f.x), f.y),\n                    mix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n                        mix(hash(n + 170.0), hash(n + 171.0), f.x), f.y), f.z);\n    return res;\n}\n\nfloat fbm(vec3 p)\n{    \n    int octaves = 7;\n    float noise_val = 0.0;\n    float amp = 2.5;\n    float freq = 1.5;\n    for(int i = 0; i < octaves; ++i)\n    {\n        noise_val += noise(p*freq) * amp;\n        amp*= 0.5;\n        freq *= 2.0;\n    }\n    return noise_val;\n}\n\nvec2 curlPattern(in vec2 p)\n{\n    //p += iTime*0.1;\n    vec3 pos = vec3(p, iTime*0.1);\n    vec3 eps = vec3(1e-3, 0.0, 0.0);\n\n    float n1 = fbm(pos + eps);\n    float n2 = fbm(pos - eps);\n\n    float a = (n1 - n2) / (2.*eps.x);\n\n    n1 = fbm(pos + eps.yxy);\n    n2 = fbm(pos - eps.yxy);\n\n    float b = (n1 - n2) / (2.*eps.x);\n\n    return vec2(b, -a);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(0);\n    \n    // coordinates\n    vec2 uv = fragCoord/iResolution.xy;    \n    vec2 offset = vec2(0);\n    \n    // curl noise\n    vec2 curl = curlPattern(uv);\n    // force fields\n    offset += curl;\n\n    // \n    uv += offset*vec2(iResolution.y/iResolution.x, 1)*.0005;\n    vec3 frame = texture(iChannel0, uv).rgb;\n    \n    // spawn from edge\n    bool spawn = fragCoord.x < 1. || fragCoord.x > iResolution.x - 1.\n        || fragCoord.y < 1. || fragCoord.y > iResolution.y - 1.;\n    \n    // spawn at first frame\n    spawn = spawn || iFrame < 1;\n    \n    // color palette\n    // https://iquilezles.org/articles/palettes\n    if (spawn) \n    {   \n#if USE_COLOR_PALATTE==0\n        color = 0.5 + 0.5 * cos(2.0*pi*(mod(uv.x+uv.y, 1.0)+vec3(0.3, 0.33, 0.2)));        \n#elif USE_COLOR_PALATTE==1\n        color = 0.5 + 0.5 * cos(2.0*pi*(mod(uv.x+uv.y, 1.0)+vec3(0.0, 0.33, 0.667))); \n#elif USE_COLOR_PALATTE==2\n        \n        color = vec3(uv, 0.5);\n#endif\n    }\n    // buffer\n    else\n    {\n        color = max(color, frame);\n    }\n    // color.xy = curl*0.0005;\n    fragColor = vec4(color,1.0);\n}\n\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// forked from Curling Smoke by Leon:https://www.shadertoy.com/view/cl23Wt\n\n// set USE_COLOR_PALATTE for different color palatte\n#define USE_COLOR_PALATTE 1\n\n// set SHOW_TEX to 1 will render the flow texture fullscreen\n#define SHOW_TEX 0\n\n// set USE_FLOW_NORMAL to 0 will turn off the normal for flow texture\n#define USE_FLOW_NORMAL 1","name":"Common","description":"","type":"common"}]}