{"ver":"0.1","info":{"id":"cstGRr","date":"1682347542","viewed":80,"name":"Algida","username":"xrosecky","description":"mod(x+sin(y+t),0.85)","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["quantizethemall"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://romop5.github.io//QuantitizeThemAll/?data=eyJwcm9ncmFtIjoibW9kKHgrc2luKHkrdCksMC44NSkiLCJ0cmFuc2Zvcm1hdGlvblR5cGUiOiJjaXJjbGUiLCJzdGFydENvbG9yIjoiIzAwMDAwMCIsImVuZENvbG9yIjoiI2ZmZmZmZiIsIm9mZnNldFgiOiIwIiwib2Zmc2V0WSI6IjAiLCJ6b29tIjoiMi4yIiwiZm9jYWwiOiIxIiwidGhyZXNob2xkaW5nVHlwZSI6ImNvbG9yIiwiY29sb3JUaHJlc2hvbGQiOiIwLjUifQ\n\n/*\n * Generated while using QuantizeThemAll\n * Try it yourself: https://romop5.github.io/QuantitizeThemAll/\n * You can also use https://github.com/danilw/shadertoy-to-video-with-FBO to render this shader.\n */\n\n   const vec3 colorStart = vec3(245,147,66)/255.0;\n   const vec3 colorEnd = vec3(255,255,255)/255.0;\n   const float threshValue = 0.5000;\n   vec2 linear(vec2 uv)\n   {\n        return uv; \n   }\n\n   vec2 circle(vec2 uv)\n   {\n        vec2 nuv = normalize(uv);\n        float dist = 1.0/length(uv);\n        return nuv*dist;\n   }\n   vec2 polar(vec2 uv)\n   {\n        return vec2(atan(uv.x,uv.y),sqrt(uv.x*uv.x+ uv.y*uv.y));  \n   }\n   vec2 spherical(vec2 uv)\n   {\n        vec2 direction = uv;\n        float len = length(uv);\n        return vec2(exp(len))*direction;\n   }\n   vec2 fisheye(vec2 uv)\n   {\n        float f = 1.0000;\n        // Calculate angle from plane's UV\n        vec2 angles = atan(uv, vec2(1.0));\n        //return angles*f;\n        return vec2(2.0)*sin(angles*vec2(0.5))*vec2(f);\n   }\n\n   float inv(float x)\n   {\n    return 1.0/x;\n   }\n\n   // Color thresholding\n   vec3 thresholdingNone(float level)\n   {\n          return mix(colorStart,colorEnd,level); \n   }\n\n   vec3 thresholdingColor(float level)\n   {\n          return (level> threshValue)?colorStart:colorEnd;  \n   }\n\n   vec3 thresholdingContour(float level)\n   {\n        float distanceToThreshold = length(level-threshValue);\n        if(distanceToThreshold < 0.1)\n            return colorStart;\n        return colorEnd;\n   }\n   vec3 applyThresholding(float level)\n   {\n        return thresholdingColor(level);\n   }\n   \n   vec4 calculate(vec2 fragCoord) {\n       vec2 uv = fragCoord/iResolution.y;\n       uv *= 2.0;\n       uv -= iResolution.xy / iResolution.y;\n       float t = iTime*1.0000;\n       vec2 resultingUv = circle(vec2(uv.x, uv.y)*vec2(2.2000));\n       float x = resultingUv.x + 0.0000;\n       float y = resultingUv.y + 0.0000;\n       float program = mod(x+sin(y+t),0.85);\n       float parameter = clamp(program, 0.0,1.0);\n       vec3 resultColor = applyThresholding(parameter);\n       return vec4(resultColor, 1.0);\n   }\n\n\n   void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n       float neighbourhood = 1.0 / 2.0;\n   \n       vec4 res = vec4(0);\n       float pixels = 0.0;\n   \n       for (float x = -1.0; x <= 1.0; x += neighbourhood) {\n           for (float y = -1.0; y <= 1.0; y += neighbourhood) {\n               res += calculate(fragCoord + vec2(x, y));\n               pixels += 1.0;\n           }\n       }\n       \n       fragColor = res / pixels;\n   }\n   ","name":"Image","description":"","type":"image"}]}