{"ver":"0.1","info":{"id":"3sySzD","date":"1588625836","viewed":56,"name":"LittleMandelbrotAnimation","username":"lirfu","description":"My little Mandelbrot animation. The colors represent the slice offset along the imaginary axis of the starting point (negative blue to positive red).","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["mandelbrot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ITER 100.\n\nvec2 compl_mul(vec2 a, vec2 b)\n{\n\treturn vec2(a.x*b.x - a.y*b.y, a.y*b.x + a.x*b.y);\n}\n\nvec3 recurse(vec2 z, vec2 c)\n{\n    float i;\n    for(i = 0.0; i < ITER; i++)\n    {\n\t\tz = compl_mul(z,z) + c;\n        \n\t\tif (length(z) > 2.0) \n            break;\n    }\n\treturn vec3(z, i/ITER);\n}\n\nfloat approx_sqrt(float x, vec4 boost)\n{\n    return dot(vec4(x*x*x, x*x, x, 1.), boost * vec4(2.0196,-3.8579,2.8382,-1.8534e-7));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy - .5;  // Normalize.\n    uv *= 4.;  // Zoom.\n    \n    float speed = 0.25;  // Frequency of animation.\n    float scale = 1.25;  // Amplitude of offset.\n    float y = scale * sin(speed * iTime);\n\n    // Select slice along the imaginary axis.\n    vec3 l = recurse(vec2(0.,y), uv);\n    \n    // Make depth gradation more visible in lower range.\n    //l.z = sqrt(l.z);\n    l.z = approx_sqrt(l.z, vec4(1.5));\n    \n    // Old colorization (colorful mess).\n    //l = 1.0 / l;\n    //l = log2(l);\n    //float x = sin(speed * iTime);\n    //vec3 col = l.z * vec3((x+1.0)/2.0, (y+1.0)/2.0, 1.);\n    //fragColor = vec4(1.-col, 1.);\n    \n    // Colors represent the location of the slice (positive red to negative blue).\n    vec3 col = l.z * vec3(y, .3, 1.-y);\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}