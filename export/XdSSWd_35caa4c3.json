{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"\n// Table of pigments \n// from Computer-Generated Watercolor. Cassidy et al.\n// K is absortion. S is scattering\nvec3 K_QuinacridoneRose = vec3(0.22, 1.47, 0.57);\nvec3 S_QuinacridoneRose = vec3(0.05, 0.003, 0.03);\nvec3 K_FrenchUltramarine = vec3(0.86, 0.86, 0.06);\nvec3 S_FrenchUltramarine = vec3(0.005, 0.005, 0.09);\nvec3 K_CeruleanBlue = vec3(1.52, 0.32, 0.25);\nvec3 S_CeruleanBlue = vec3(0.06, 0.26, 0.40);\nvec3 K_HookersGreen = vec3(1.62, 0.61, 1.64);\nvec3 S_HookersGreen = vec3(0.01, 0.012, 0.003);\nvec3 K_HansaYellow = vec3(0.06, 0.21, 1.78);\nvec3 S_HansaYellow = vec3(0.50, 0.88, 0.009);\n\n// Math functions not available in webgl\n//vec3 cosh(vec3 val) { vec3 e = exp(val); return (e + vec3(1.0) / e) / vec3(2.0); }\n//vec3 tanh(vec3 val) { vec3 e = exp(val); return (e - vec3(1.0) / e) / (e + vec3(1.0) / e); }\n//vec3 sinh(vec3 val) { vec3 e = exp(val); return (e - vec3(1.0) / e) / vec3(2.0); }\n\n// Kubelka-Munk reflectance and transmitance model\nvoid KM(vec3 k, vec3 s, float h, out vec3 refl, out vec3 trans)\n{\n    vec3 a = (k+s)/s;\n    vec3 b = sqrt(a*a - vec3(1.0));\n    vec3 bsh = b*s*vec3(h);\n    vec3 sinh_bsh = sinh(bsh);\n    vec3 denom = b*cosh(bsh)+a*sinh_bsh;\n    refl = sinh_bsh/denom;\n    trans = b/denom;\n}\n\n// The watercolours tends to dry first in the center\n// and accumulate more pigment in the corners\nfloat brush_effect(float dist, float h_avg, float h_var)\n{\n    float h = max(0.0,1.0-10.0*abs(dist));\n    h *= h;\n    h *= h;\n    return (h_avg+h_var*h) * smoothstep(-0.01, 0.002, dist);\n}\n\n// Kubelka-Munk model for layering\nvoid layering(vec3 r0, vec3 t0, vec3 r1, vec3 t1, out vec3 r, out vec3 t)\n{\n    r = r0 + t0*t0*r1 / (vec3(1.0)-r0*r1);\n    t = t0*t1 / (vec3(1.0)-r0*r1);\n}\n\n// Simple 2d noise fbm with 3 octaves\nfloat noise2d(vec2 p)\n{\n    float t = texture(iChannel0, p).x;\n    t += 0.5 * texture(iChannel0, p * 2.0).x;\n    t += 0.25 * texture(iChannel0, p * 4.0).x;\n    return t / 1.75;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 r0,t0,r1,t1;\n    \n    float sky = 0.1 + 0.1 * noise2d(uv * vec2(0.1));\n    KM(K_CeruleanBlue, S_CeruleanBlue, sky, r0, t0);\n    \n    float mountain_line = 0.5+0.04*(sin(uv.x*18.0+2.0)+sin(sin(uv.x*2.0)*7.0))-uv.y;\n    float s = clamp(2.0-10.0*abs(mountain_line),0.0,1.0);\n    vec2 uv2 = uv + vec2(0.04*s*noise2d(uv * vec2(0.1)));\n    float mountains = brush_effect(0.5+0.04*(sin(uv2.x*18.0+2.0)+sin(sin(uv2.x*2.0)*7.0))-uv2.y, 0.2, 0.1);\n    mountains *= 0.85+0.15*noise2d(uv*vec2(0.2));\n    KM(K_HookersGreen, S_HookersGreen, mountains, r1, t1);\n    layering(r0,t0,r1,t1,r0,t0);\n    \n    vec2 uv3 = uv*vec2(1.0,iResolution.y/iResolution.x) + vec2(0.02*noise2d(uv * vec2(0.2)));\n    float sun = brush_effect(1.0 - distance(uv3, vec2(0.2,0.45)) / 0.08, 0.2, 0.1);\n    KM(K_HansaYellow, S_HansaYellow, sun, r1, t1);\n    layering(r0,t0,r1,t1,r0,t0);\n    \n\tfragColor = vec4(r0+t0,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XdSSWd","date":"1416953995","viewed":3856,"name":"Child with watercolours","username":"caosdoar","description":"The simplest possible picture to test watercolour layering usin Kubelka-Munk model.","likes":55,"published":1,"flags":0,"usePreview":1,"tags":["2d","watercolor","watercolour","kubelka","munk"],"hasliked":0,"parentid":"","parentname":""}}