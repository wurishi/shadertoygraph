{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"vec4 cubic(float v)\n{\n    vec4 n = vec4(1.0, 2.0, 3.0, 4.0) - v;\n    vec4 s = n * n * n;\n    float x = s.x;\n    float y = s.y - 4.0 * s.x;\n    float z = s.z - 4.0 * s.y + 6.0 * s.x;\n    float w = 6.0 - x - y - z;\n    return vec4(x, y, z, w);\n}\nvec4 filterf(sampler2D tex, vec2 texcoord, vec2 texscale)\n{\n    float fx = fract(texcoord.x);\n    float fy = fract(texcoord.y);\n    texcoord.x -= fx;\n    texcoord.y -= fy;\n\n    vec4 xcubic = cubic(fx);\n    vec4 ycubic = cubic(fy);\n\n    vec4 c = vec4(texcoord.x - 0.5, texcoord.x + 1.5, texcoord.y -\n0.5, texcoord.y + 1.5);\n    \n    vec4 s = vec4(xcubic.x + xcubic.y, xcubic.z + xcubic.w, ycubic.x +\nycubic.y, ycubic.z + ycubic.w);\n    \n    vec4 offset = c + vec4(xcubic.y, xcubic.w, ycubic.y, ycubic.w) /\ns;\n\n    vec4 sample0 = texture(tex, vec2(offset.x, offset.z) *\ntexscale);\n    vec4 sample1 = texture(tex, vec2(offset.y, offset.z) *\ntexscale);\n    vec4 sample2 = texture(tex, vec2(offset.x, offset.w) *\ntexscale);\n    vec4 sample3 = texture(tex, vec2(offset.y, offset.w) *\ntexscale);\n\n    float sx = s.x / (s.x + s.y);\n    float sy = s.z / (s.z + s.w);\n    \n    float sxdx = fx*fx-fx-.5;    \n    float sydy = fy*fy-fy-.5;\n\n\tfloat x_dir = mix(sample3- sample2 ,sample1- sample0, sy).x*sxdx;\n\tfloat y_dir = mix(sample3- sample1 ,sample2- sample0, sx).x*sydy;\n\tfloat depth = mix(mix(sample3, sample2,  sx),mix(sample2, sample0, sx), sy).x;\n\n    return vec4(normalize(vec3(x_dir, y_dir, 1.0)), depth);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec4 samplev = filterf(iChannel0, uv, vec2(512., 512.)/iResolution.xy)*0.5+0.5;\n\tvec3 normal = samplev.xyz;\n    vec3 eye = normalize(vec3(uv, 1.) + normal);\n    vec3 light = vec3(0.4, 0.2+sin(iTime*0.1)*0.5, 0.2+cos(iTime*0.1)*0.5);\n    vec2 xy = vec2(dot(normal, light), dot(eye, light));\n   \n\tfragColor = texture(iChannel1, xy*0.5+0.5);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4s2Xzh","date":"1409011947","viewed":431,"name":"Bicubic normal filtering","username":"sakunthala","description":"Bicubic normal map filtering ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["normals","imageprocessing","bicubic"],"hasliked":0,"parentid":"","parentname":""}}