{"ver":"0.1","info":{"id":"lc33W8","date":"1711835491","viewed":53,"name":"Prak_Pimenova","username":"elizaveta_pimenova","description":"Prak_Pimenova","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["prakpimenova"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define max 1000.0\nconst int n = 6; // количество фигур(+овал)\nvec3 colors[n] = vec3[](vec3(0.3, 1.0, 0.5), vec3(0.3, 0.8, 0.5), vec3(0.3, 0.5, 0.9), vec3(1.0, 0.3, 0.4), vec3(1.0, 0.9, 0.4), vec3(0.1, 1.0, 1.0));\nvec3 BGcolor = vec3(0.2, 0.2, 0.1); // background\nint vert_inds[n + 1] = int[](0, 3, 6, 9, 12,15, 19) ;\nconst int m = 19; // количество вершин\nvec3 vert_coord[m]; // массив координат вершин фигур\nvec2 centre; float r;\nvec3 normal;\n\nvoid init_Circle(){\n    centre = vec2(0.3, 0.3);\n    r = 0.1;\n}\n\nbool in_Circle(in vec2 xy){\n    bool flag = false;\n    float moving_center_x = centre.x + 0.5 * sin(iTime); // изменение координаты центра по оси X\n    if ((xy.x - moving_center_x)*(xy.x - moving_center_x) + (xy.y - centre.y)*(xy.y - centre.y) <= r*r) flag = true;\n    return flag;\n}\n\n\nvoid initialization(out vec3  vert_coord[m], in float time){\n    vert_coord[0] = vec3(0.5, 0.5, 0.0);//первая грань объемной начало\n    vert_coord[1] = vec3(0.8, 0.5, 0.2);\n    vert_coord[2] = vec3(0.65, 0.7, 0.0);//первая грань объемной начало\n    \n    vert_coord[3] = vec3(0.5, 0.5, 0.0);//вторая грань объемной начало\n    vert_coord[4] = vec3(0.65, 0.7 , 0.0);\n    vert_coord[5] = vec3(0.45, 0.55, 0.0);//вторая грань объемной начало\n   \n    vert_coord[6] = vec3(0.4 + 0.2 * cos(time), 0.7-0.1 * sin(time), 0.2);//первый подвижный тр начало\n    vert_coord[7] = vec3(0.5 + 0.2 * cos(time),  0.7-0.1 * sin(time), 0.0);\n    vert_coord[8] = vec3(0.4 + 0.2 * cos(time), 0.85 - 0.1 * sin(time), 0.2);//первый подвижный тр конец\n    \n    vert_coord[9] = vec3(0.45 - 0.1* cos(time), 0.45 - 0.1 * sin(time), 0.25);//второй подвижный тр начало\n    vert_coord[10] = vec3(0.85 - 0.1* cos(time), 0.3 -  0.1 * sin(time), -0.1);\n    vert_coord[11] = vec3(0.42 - 0.1 * cos(time), 0.6 - 0.1 * sin(time), -0.2);//второй подвижный тр начало\n    \n    vert_coord[12] = vec3(0.4 - 0.2 * cos(time), 0.7+0.1 * sin(time), 0.2);//первый подвижный тр начало\n    vert_coord[13] = vec3(0.5 - 0.2 * cos(time),  0.7+0.1 * sin(time), 0.0);\n    vert_coord[14] = vec3(0.4 - 0.2 * cos(time), 0.85 + 0.1 * sin(time), 0.2);//первый подвижный тр конец\n    \n    vert_coord[15]=vec3(0.6+0.5*cos(time), 0.5+0.4*sin(time), 0.0);//прямоугольник начало\n    vert_coord[16]=vec3(0.75+0.5*cos(time), 0.5+0.4*sin(time),- 0.2);\n    vert_coord[17]=vec3(0.75+0.5*cos(time), 0.65+0.4*sin(time), -0.2);\n    vert_coord[18]=vec3(0.6+0.5*cos(time), 0.65+0.4*sin(time), 0.0);//прямоугольник конец\n    \n   \n}\n\nbool in_poly(in vec2 vert_in, in int m) {\n    int size = vert_inds[m+1] - vert_inds[m], start = vert_inds[m];\n    vec2 a, b;\n    int i, tmp;\n    for(i = start; i < size+start; i++) {\n        tmp = i + 1;\n        if(i == start + size - 1) {\n            tmp = start; // возвращаемся к начальной точке, чтобы замкнуть фигуру\n        }\n        a = vec2(vert_coord[tmp].x - vert_coord[i].x, vert_coord[tmp].y - vert_coord[i].y);\n        b = vec2(vert_in.x - vert_coord[i].x, vert_in.y - vert_coord[i].y);\n        if(a.x * b.y - b.x * a.y < 0.0) return false; \n    }\n    return true;\n}\n\nbool in_circle(in vec2 center, float radius, vec2 point) {\n    float dist = distance(center, point);\n    return dist <= radius;\n}\n\nfloat plosk_coord_z(int i, vec3 vert_coord[m], float x, float y){// определяем координату z пересечения луча и фигуры\n         float Z, D, x1, x2, x3, y1, y2, y3, z1, z2, z3;\n         \n         //определяем плоскость по трем точкам с соответствующими координатами\n         \n         x1 = vert_coord[vert_inds[i]].x;\n         x2 = vert_coord[vert_inds[i] + 1].x;\n         x3 = vert_coord[vert_inds[i] + 2].x;\n         \n         y1 = vert_coord[vert_inds[i]].y;\n         y2 = vert_coord[vert_inds[i] + 1].y;\n         y3 = vert_coord[vert_inds[i] + 2].y;\n         \n         z1 = vert_coord[vert_inds[i]].z;\n         z2 = vert_coord[vert_inds[i] + 1].z;\n         z3 = vert_coord[vert_inds[i] + 2].z;\n         \n         normal = cross(vec3(x2-x1, y2-y1, z2-z1), vec3(x3-x1,y3-y1,z3-z1)); //(A, B, C) векторное произведение\n         D = (-normal.x * x1 - normal.y * y1 - normal.z * z1);\n         Z = ((-normal.x * x - normal.y * y - D)/normal.z);\n         //A=normal.x, B=normal.y, C=normal.z\n         return Z;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n     int i;\n     vec2 tmp1= fragCoord/iResolution.xy;//нормализация\n     initialization(vert_coord, iTime);\n     float leading=1000.0;\n     vec3 curr_color=BGcolor;\n     float  x = tmp1.x, y = tmp1.y, z = leading;\n     for(i = 0; i < n; i++){\n         if (in_poly(tmp1, i)){\n         \n             z=plosk_coord_z(i, vert_coord, x, y);\n             if (z < leading){\n                 leading=z;\n                 curr_color=colors[i];//цвет пикселя от лидирующего\n             }\n          }\n     }\n     \n     init_Circle();\n     if (in_Circle(tmp1)) curr_color = vec3(1.0+0.1*cos(iTime), 170.0/255.0+0.2*sin(iTime), 184.0/255.0+0.1*cos(iTime));//вывод овала\n     fragColor = vec4(curr_color, 1.0); // вывод ответа\n}\n     ","name":"Image","description":"","type":"image"}]}