{"ver":"0.1","info":{"id":"4lt3WH","date":"1469086011","viewed":151,"name":"RayMarchingAttempt-2","username":"sea","description":" ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415192\n\nconst float fov = 90.0;\n\nvec3 spherePosition = vec3(0.0, 0.0, 3.0);\nvec3 lightPosition = vec3(-3.0, 3.0, 1.0);\n\nfloat sphereRadius = 1.0;\n\nfloat calculateLight (vec3 intersection, vec3 normal)\n{\n    // Rotate light on y axis around the sphere.\n    float lightX = lightPosition.x * cos(iTime) - lightPosition.z * sin(iTime);\n    float lightZ = lightPosition.z * cos(iTime) + lightPosition.x * sin(iTime);\n    \n    // Set light position.\n    vec3 lPosition = vec3(lightX, lightPosition.y, lightZ);\n    \n    // Calculate intersection between the light and the sphere.\n    vec3 intersectionDirection = normalize(intersection - lPosition);\n    \n    // Compare the light direction to the sphere normal.\n    return dot(intersectionDirection, normal);\n}\n\nvec3 intersectSphere (vec3 rayOrigin, vec3 rayDirection)\n{\n    float distance = 0.0;\n    \n    // Walk forward starting from the ray origin in the ray direction.\n    for (float i = 0.0; i < 4.0; i += 0.01)\n    {\n        // Calculate ray position.\n        vec3 point = rayOrigin + rayDirection * i;\n        \n        float sphereDistance = length(spherePosition - point);\n        \n        if (sphereDistance < sphereRadius)\n        {\n            // Calculate sphere normal by calculating the direction between center and the intersection point.\n            vec3 normal = normalize(spherePosition - point);\n            float v = calculateLight(point, normal);\n            return vec3(v);\n        }\n    }\n    \n    return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 viewSpace = uv * 2.0 - 1.0;\n    \n    float aspect = iResolution.x / iResolution.y;\n    \n    viewSpace.y /= aspect;\n    \n    vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n    \n    // Calculate ray direciton.\n    vec3 rayDirection = normalize(vec3(viewSpace, 1.0));\n    vec3 color = intersectSphere(rayOrigin, rayDirection);\n    \n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}