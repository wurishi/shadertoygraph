{"ver":"0.1","info":{"id":"4d3GRX","date":"1451268266","viewed":954,"name":"Round Rock Island","username":"Hamneggs","description":"It's lonely on Round Rock Island. Uses lots of FBMs and an atmospheric scattering approach from a shader that I can no longer find.","likes":34,"published":1,"flags":0,"usePreview":0,"tags":["ray","time","displacement","ocean","sky","reflections","scattering","bump","mapping","surface","island","march","rock","sand","atmospheric","real"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n * Written by Gerard Geer.\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * \n * Version 1.0:\tInitial release.\n * Version 1.1:\tAdded a couple quality defines. CALC_OCCLUSION specifies to calculate\n * \t\t\t\tambient occlusion, which is about 5 calls to dist(), each of which has\n * \t\t\t\tabout 10 texture samples.\n * \t\t\t\tHQ_RENDER does a whole lot. In its absence, the FBMs have one fewer\n * \t\t\t\toctave, the rock loses a middle octave of noise, the sand is no longer\n * \t\t\t\timage-reflective, and the field as in the ocean reflections is textured\n * \t\t\t\tonly with the sand texture. This cuts out a whole lot of texture calls,\n * \t\t\t\tand a deep-in-there branch.\n * \t\t\t\tThese defines are commented by default. Enable them to see the whole\n * \t\t\t\tpicture.\n */\n\n// Render quality defines.\n// #define CALC_OCCLUSION\n// #define HQ_RENDER\n\n// Occlusion attenuation factor.\n#define OCC_FACTOR 1.5\n    \n// Light and reflection penumbra factors.\n#define PENUMBRA_FACTOR 50.0\n// Oren-Nayar material reflectance coefficient.\n#define MAT_REFLECTANCE 4.0\n// Main marching steps.\n#define V_STEPS 100\n// Reflection marching steps.\n#define R_STEPS 30\n// Shadow marching steps.\n#define S_STEPS 30\n// Maximum successful marching distance.\n#define EPSILON .025\n// Max ray depth.\n#define MAX_DEPTH 150.0\n\n// How fast do you want time to go?\n#define TIME_WARP .3\n\n// Object constants.\n#define SAND_NOISE_TEX iChannel1\n#define SAND_BUMP_HEIGHT .6\n#define OCEAN_NOISE_TEX iChannel1\n#define OCEAN_HEIGHT -.25\n#define OCEAN_AMPLITUDE .45\n#define OCEAN_SPEED .35\n#define WALL_BUMP_HEIGHT 7.5\n#define WALL_DIFF_TEX iChannel2\n#define RAND_NOISE_TEX iChannel0\nconst vec2 ROCK_DIM = vec2(4.0,1.75);\n\n// Object IDs for shading.\n#define ID_ROCK 1.0\n#define ID_SAND 128.0\n#define ID_OCEAN 256.0\n\n// Environment and color constants.\nconst vec3 UP = vec3(0.0, 1.0, 0.0);\t\t\t\t\t\t// An up vector.\nconst vec3 PLANET_ROT = vec3(0.0,0.0,1.0);\t\t\t\t\t// The axis on which the planet rotates.\nconst vec3 SUN_DIR = vec3(0., 0.995037, 0.0995037);\t\t\t// The starting direction of the sun.\nconst vec3 SKY_COLOR_A = vec3(0.53,0.81,0.92);\t\t\t    // Sky color.\nconst vec3 SKY_COLOR_B = vec3(0.23,0.34,0.85);\t\t\t\t// High angle sky.\nconst vec3 SUN_COLOR_A = vec3(4.0);\t\t\t\t\t\t\t// Noontime sun color.\nconst vec3 SUN_COLOR_B = vec3(2.0, .66, 0.06);\t\t\t\t// Evening sun color.\nconst vec3 GROUND_COLOR = vec3(.6, .5, .32);\t\t\t\t// Average ground color.\nconst vec3 SAND_COLOR = vec3(.4, .35, .22);\t\t\t\t\t// The color of the sand.\nconst vec3 ROCK_COLOR_A = vec3(.4,.3,.15);\t\t\t\t\t// One rock color.\nconst vec3 ROCK_COLOR_B = vec3(.4,.2,.15);\t\t\t\t\t// Another rock color.\n#define NIGHT_BRIGHTNESS .1\n\n// Math constants.\nconst mat2 ROT45 = mat2(-.710, -.710, .710, -.710);\nconst mat2 ROT90 = mat2(0.,1.,-1.,0.);\nconst vec2 RAND_SEED = vec2(12.9898,78.233);\n#define PI   3.141593\n#define PI4 12.56637\n\n// Camera parameters.\nconst vec3 CAM_LOOK_AT = vec3(0.0, 2.0, 0.0);\nconst float CAM_DIST_AWAY = 50.25; // How far away the camera is from CAM_LOOK_AT.\nconst float CAM_ZOOM = 1.0;\n\n/*\n\tOlinde Rodrigues' vector rotation formula for rotating a vector <a>\n\taround a vector <b> <t> radians.\n*/\nvec3 rodRot( in vec3 a, in vec3 b, in float t )\n{\n    // Straight from wikipedia.\n\treturn normalize(a*cos(t) + cross(b, a)*sin(t) + b*dot(b,a)*(1.0-cos(t)));\n}\n\n/*\n\tMy goofy redefinition-of-basis-based camera.\n*/\nvoid camera(in vec2 uv, in vec3 cp, in vec3 cd, in vec3 up, in float f, out vec3 ro, out vec3 rd)\n{\n\tro = cp;\n\trd = normalize((cp + cd*f + cross(cd, up)*uv.x + up*uv.y)-ro);\n}\n\n/*\n\tReturns a coefficient for a shutter fade.\n*/\nfloat shutterfade( in float s, in float e, in float t, in float duration )\n{\n    return min( smoothstep(s, s+duration, t), smoothstep(e, e-duration, t) );\n}\n\n/*\n\tA decoration function to get between you and and camera().\n\tNevermind that it does fancy animation; death to interface degraders!\n*/\nvoid animateCam(in vec2 uv, in float t, out vec3 p, out vec3 d, out vec3 e, out float s )\n{\n\tt = mod(t,35.0);\n    \n    vec3 u = UP;\n    float f = 1.0;\n    if(t<PI4)\n    {\n    \te = vec3(30.0*cos(t*.125),2.0,30.0*sin(t*.125));\n   \t\td = normalize(vec3(0.0)-e);\n        s = shutterfade(0.0, PI4, t, .5);\n    }\n    else if(t<20.0)\n    {\n        e = mix(PLANET_ROT*-10.0,PLANET_ROT*10.0,smoothstep(PI4,20.0,t));\n        e.y += 1.0;\n        d = PLANET_ROT;\n        s = shutterfade(PI4, 20.0, t, .5);\n    }\n    else if(t<25.0)\n    {\n        e = mix(vec3(-10.0,1.0,3.0),vec3(10.0,1.0,3.0),smoothstep(20.0,25.0,t));\n        d = vec3(0.948683, 0.316228, 0.0);\n        u = vec3(-d.y,d.x,0.0); \n        s = shutterfade(20.0, 25.0, t, .5);\n    }\n    else if(t<30.0)\n    {\n        e = mix(vec3(-30.0,10.0,-10.0),vec3(10.0,10.0,10.0),smoothstep(25.0,30.0,t));\n        d = vec3(0.666667, -0.333333, 0.666667);\n        u = vec3(-d.y,d.x,0.0); \n        s = shutterfade(25.0, 30.0, t, .5);\n    }\n    else\n    {\n        e = mix(vec3(1.0,1.0,2.0),vec3(1.0,5.0,1.5),smoothstep(30.0,35.0,t));\n        d = UP;\n        u = PLANET_ROT;\n        f = .5;\n        s = shutterfade(30.0, 35.0, t, .5);\n    }\n    camera(uv, e, d, u, f, p, d);\n}\n\n/*\n\tTakes a vec2 containing a distance and a primitive's ID and returns\n\tthe ID and distance of the nearer primitive, effectively performing\n\ta solid modeling union.\n*/\nvec2 u( in vec2 a, in vec2 b )\n{\n    return mix(a,b,step(b.s,a.s));\n}\n\n/*\n\tThe random function from the first Stack Overflow article that is\n\treturned after googling \"GLSL noise\".\n\tCan we have a conversation about how GLSL defines a noise function\n\tbut no vendors actually implement it?\n*/\nfloat rand( in vec2 co )\n{\n    return fract(sin(dot(co,RAND_SEED)) * 43758.5453);\n}\n\n/*\n\tA 2D texture-sampled noise function. Used when the surface to be\n\tdistorted exists entirely in one plane.\n*/\nfloat n(vec2 p, sampler2D tex)\n{\n    return texture(tex,p).r;\n}\n\n/*\n\tIQ's seminal noise function. I learned that the weird ring artifacts\n\twere due to vflipping it's texture buddy.\n*/\nfloat nIQ( in vec3 x, in sampler2D t )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( t, (uv+0.5)/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n/*\n\tA 2D FBM with time dependence.\n*/\nfloat fbm2Dt( in vec2 p, in float t, in sampler2D tex )\n{\n    float r = n(p+t*.1,tex);\n    p*=ROT45;p*=2.0;p+=t*-.24;\n    r += n(p,tex)*.500;\n    p*=ROT45;p*=2.0;p+=t*-.12;\n    #ifdef HQ_RENDERING\n    r += n(p,tex)*.250;\n    #endif\n    return r*1.0075;\n}\n\n/*\n\tA 3 octave FBM that uses IQ's noise.\n*/\nfloat fbm3D( in vec3 p, in sampler2D t )\n{\n    float r = nIQ(p, t)*.5;\n    r += nIQ(p*2.0, t)*.25;\n    r += nIQ(p*4.1, t)*.125;\n    return r * 1.11872;\n}\n\n    \n/*\n\tReturns the distance to the ocean plane.\n*/\nfloat ocean( in vec3 p )\n{\n    // Translate to the Y coordinate of the ocean.\n    p.y -= OCEAN_HEIGHT;\n    // Do some optimization where if we're beyond a certain\n    // distance from the plane, we don't worry about calculating the bump height.\n    // The *4.0 is there because the bump map would fall to 0 near the horizon.\n    if(p.y>OCEAN_AMPLITUDE*4.0)return p.y;\n    // If we're within that threshold, we modulate the distance by the bump map.\n    else return p.y+fbm2Dt(p.xz*.025, iTime*OCEAN_SPEED, OCEAN_NOISE_TEX)*OCEAN_AMPLITUDE;\n}\n\n/*\n\tReturns the distance to the sand. This is really just sphere that looks cool\n\tand is drowning.\n*/\nfloat sand( in vec3 p )\n{\n    // Translate the sphere down into the water.\n    p.y += 50.0;\n    // An inlining of the classic sphere distance formula.\n    float sphere = length(p)-51.0;\n    // Same distance check as with the ocean.\n    if(sphere-SAND_BUMP_HEIGHT> 0.0) return sphere;\n   \t// Same method of height modulation. Since we're only considering the\n    // scalp of the sphere, we don't need worry about the fact that we're\n    // using a 2D fbm.\n    else\n    {\n        return sphere + fbm2Dt(p.xz*.025,0.0,SAND_NOISE_TEX)\n            \t\t  * SAND_BUMP_HEIGHT;\t// The general height of the sand features.\n    }\n}\n\n/*\n\tThe distance function of the rock.\n*/\nfloat rock( in vec3 p )\n{\n    // Inlined torus distance function.\n    vec2 q = vec2(length(p.xy)-ROCK_DIM.x,p.z);\n  \tfloat d = length(q)-ROCK_DIM.y;\n    \n    // The sum of the heights of the FBM and noise calls.\n    if(d > 1.5125) return d;\n    else\n    {        \n        float t = fbm3D(p, RAND_NOISE_TEX);\n        #ifdef HQ_RENDERING\n        t += nIQ(p*1.0,RAND_NOISE_TEX)*.5;\n        #endif\n        t += nIQ(p*32.0,RAND_NOISE_TEX)*.0125;\n        return d + t;\n    }\n}\n\n\n/*\n\tThe scene's distance function.\n*/\nfloat dist( in vec3 p )\n{\n    // I think nesting this is a bit more better than dicing it out\n    // into two calls. Could someone confirm or deny this?\n    return min(sand(p),min(ocean(p),rock(p)));\n}\n\n/*\n\tThe distance function of the stuff that's visible in \n\treflections. This doesn't include some stuff to save\n\ttime.\n*/\nfloat distR( in vec3 p )\n{\n    // By not having the ocean here we're cutting out hundreds\n    // of texture samples per ray.\n    return min(sand(p),rock(p));\n}\n\n/*\n\tReturns the id and distance of the nearest object.\n*/\nvec2 distID( in vec3 p )\n{\n    vec2 d = u(vec2(sand(p),ID_SAND), vec2(ocean(p), ID_OCEAN));\n    return u(d, vec2(rock(p), ID_ROCK));\n}\n\n/*\n\tAnother reflection shortcut variation of another function.\n*/\nvec2 distIDR( in vec3 p )\n{\n    return u(vec2(sand(p),ID_SAND),vec2(rock(p), ID_ROCK));\n}\n\n/*\n\tReturns the direction of the sun based on the current time.\n*/\nvec3 sunDir()\n{\n    return rodRot(SUN_DIR, PLANET_ROT, iTime*TIME_WARP);\n}\n\n/*\n\tReturns the color of the sun. Just does some janky fading\n\tbetween white at zenith and yellow at asimuth.\n*/\nvec3 sunColor( in vec3 sunDir )\n{\n    return mix(SUN_COLOR_B, SUN_COLOR_A, clamp(dot(sunDir,UP),0.0,1.0));\n}\n\n/* \n\tOkay this is not my atmospheric scattering solution, and for the\n\tlife of me I can't find the shader that I'm borrowing it from.\n\tIt's an implementation of the method discussed in this paper:\n\thttp://www.cs.utah.edu/~shirley/papers/sunsky/sunsky.pdf\n\n\tThe nice thing is that it's not the usual Scratchapixel solution.\n*/\nfloat saturatedDot( in vec3 a, in vec3 b )\n{\n\treturn max( dot( a, b ), 0.0 );   \n}\nvec3 YxyToXYZ( in vec3 Yxy )\n{\n\tfloat X = Yxy.g * ( Yxy.r / Yxy.b );\n\tfloat Z = ( 1.0 - Yxy.g - Yxy.b ) * ( Yxy.r / Yxy.b );\n\n\treturn vec3(X,Yxy.r,Z);\n}\nvec3 XYZToRGB( in vec3 XYZ )\n{\n\t// CIE/E\n\treturn XYZ * mat3\n\t(\n\t\t 2.3706743, -0.9000405, -0.4706338,\n\t\t-0.5138850,  1.4253036,  0.0885814,\n \t\t 0.0052982, -0.0146949,  1.0093968\n\t);\n}\nvec3 YxyToRGB( in vec3 Yxy )\n{\n\tvec3 XYZ = YxyToXYZ( Yxy );\n\tvec3 RGB = XYZToRGB( XYZ );\n\treturn RGB;\n}\nvoid calculatePerezDistribution( in float t, out vec3 A, out vec3 B, out vec3 C, out vec3 D, out vec3 E )\n{\n\tA = vec3(  0.1787 * t - 1.4630, -0.0193 * t - 0.2592, -0.0167 * t - 0.2608 );\n\tB = vec3( -0.3554 * t + 0.4275, -0.0665 * t + 0.0008, -0.0950 * t + 0.0092 );\n\tC = vec3( -0.0227 * t + 5.3251, -0.0004 * t + 0.2125, -0.0079 * t + 0.2102 );\n\tD = vec3(  0.1206 * t - 2.5771, -0.0641 * t - 0.8989, -0.0441 * t - 1.6537 );\n\tE = vec3( -0.0670 * t + 0.3703, -0.0033 * t + 0.0452, -0.0109 * t + 0.0529 );\n}\nvec3 calculateZenithLuminanceYxy( in float t, in float thetaS )\n{\n\tfloat chi  \t \t= ( 4.0 / 9.0 - t / 120.0 ) * ( PI - 2.0 * thetaS );\n\tfloat Yz   \t \t= ( 4.0453 * t - 4.9710 ) * tan( chi ) - 0.2155 * t + 2.4192;\n\n\tfloat theta2 \t= thetaS * thetaS;\n    float theta3 \t= theta2 * thetaS;\n    float T \t \t= t;\n    float T2 \t \t= t * t;\n\n\tfloat xz =\n      ( 0.00165 * theta3 - 0.00375 * theta2 + 0.00209 * thetaS + 0.0)     * T2 +\n      (-0.02903 * theta3 + 0.06377 * theta2 - 0.03202 * thetaS + 0.00394) * T +\n      ( 0.11693 * theta3 - 0.21196 * theta2 + 0.06052 * thetaS + 0.25886);\n\n    float yz =\n      ( 0.00275 * theta3 - 0.00610 * theta2 + 0.00317 * thetaS + 0.0)     * T2 +\n      (-0.04214 * theta3 + 0.08970 * theta2 - 0.04153 * thetaS + 0.00516) * T +\n      ( 0.15346 * theta3 - 0.26756 * theta2 + 0.06670 * thetaS + 0.26688);\n\n\treturn vec3( Yz, xz, yz );\n}\nvec3 calculatePerezLuminanceYxy( in float theta, in float gamma, in vec3 A, in vec3 B, in vec3 C, in vec3 D, in vec3 E )\n{\n\treturn ( 1.0 + A * exp( B / cos( theta ) ) ) * ( 1.0 + C * exp( D * gamma ) + E * cos( gamma ) * cos( gamma ) );\n}\nvec3 calculateSkyLuminanceRGB( in vec3 s, in vec3 e, in float t )\n{\n\tvec3 A, B, C, D, E;\n\tcalculatePerezDistribution( t, A, B, C, D, E );\n\tfloat thetaS = acos( saturatedDot( s, vec3(0,1,0) ) );\n\tfloat thetaE = acos( saturatedDot( e, vec3(0,1,0) ) );\n\tfloat gammaE = acos( saturatedDot( s, e )\t\t   );\n\tvec3 Yz = calculateZenithLuminanceYxy( t, thetaS );\n\tvec3 fThetaGamma = calculatePerezLuminanceYxy( thetaE, gammaE, A, B, C, D, E );\n\tvec3 fZeroThetaS = calculatePerezLuminanceYxy( 0.0,    thetaS, A, B, C, D, E );\n\tvec3 Yp = Yz * ( fThetaGamma / fZeroThetaS );\n\treturn YxyToRGB( Yp );\n}\n\n/*\n\tTakes a ray direction (presumably out into the sky)\n\tand returns how much it hits a star.\n*/\nfloat stars( in vec3 d)\n{\n    d = rodRot( d, PLANET_ROT, -iTime*TIME_WARP);\n    return pow(nIQ(d*200.0,RAND_NOISE_TEX),80.0); // These numbers are so magic they\n    \t\t\t\t\t\t\t\t\t\t\t\t\t// could carry the Lakers.\n}\n\n/*\n\tCombines the sky radiance from the magic above with a specular \n\thighl^H^H^H^H^H^Hsun.\n*/\nvec3 sky( in vec3 d, in vec3 ld )\n{\n    // Get the sky color.\n    vec3 sky = calculateSkyLuminanceRGB(ld, d, 3.0);\n    \n    // How night time is it? This variable will tell you.\n    float night = smoothstep(-0.0, -0.5, clamp(dot(ld, UP),-0.5, -0.0));\n    // Set a general brightness level so we don't just have a white screen,\n    // and artificially darken stuff at night so it looks good.\n    sky *= .040-.035*night;\n    \n    // Create a spot for the sun. This version gives us some nice edges\n    // without having a pow(x,VERY_LARGE_NUMBER) call.\n    float sunspot = smoothstep(.99935, .99965, max(dot(d,ld),0.0));\n    sunspot += smoothstep(.98000, 1.0, max(dot(d,ld),0.0))*.05; // Corona.\n    \n   \t// Mix the sky with the sun.\n    sky = sky*(1.0+sunspot);\n    \n    // Also add in the stars.\n    return sky + stars(d)*.5;\n}\n\n/*\n\tReturns the surface normal of the distance field at the given\n\tpoint p.\n*/\nvec3 norm( in vec3 p )\n{\n\treturn normalize(vec3(dist(vec3(p.x+EPSILON,p.y,p.z)),\n\t\t\t\t\t\t  dist(vec3(p.x,p.y+EPSILON,p.z)),\n\t\t\t\t\t\t  dist(vec3(p.x,p.y,p.z+EPSILON)))-dist(p));\n}\n\n/*\n\tReturns the surface normal of the stuff in reflections.\n*/\nvec3 normR( in vec3 p )\n{\n\treturn normalize(vec3(distR(vec3(p.x+EPSILON,p.y,p.z)),\n\t\t\t\t\t\t  distR(vec3(p.x,p.y+EPSILON,p.z)),\n\t\t\t\t\t\t  distR(vec3(p.x,p.y,p.z+EPSILON)))-distR(p));\n}\n\n/*\n\tThe ray-marching function. Marches a point p along a direction d\n\tuntil it reaches a point within a minimum distance of the distance\n\tfield.\n*/\nvoid march( inout vec3 p, in vec3 d, in vec3 e )\n{\n\tfloat r = dist(p+d*EPSILON);\n\tfor(int i = 0; i < V_STEPS; i++)\n\t{\n\t\tif(r < EPSILON || length(p-e) > MAX_DEPTH)\n\t\t\treturn;\n\t\tp += d*r*.66; // The higher levels of noise in the rock may be skipped\n        \t\t\t  // if the steps are too large.\n        r = dist(p);\n\t}\n\treturn;\n}\n\n/*\n\tYet another secondary function for the case of reflections. This one\n\tdoes ray marching.\n*/\nvoid marchR( inout vec3 p, in vec3 d, in vec3 e )\n{\n\tfloat r = distR(p+d*EPSILON);\n\tfor(int i = 0; i < R_STEPS; i++)\n\t{\n\t\tif(r < EPSILON || length(p-e) > MAX_DEPTH)\n\t\t\treturn;\n\t\tp += d*r; // Eh the reflections are barely seen. We don't need to\n        \t\t  // attenuate distance marched because of high frequency distance stuff.\n        r = distR(p);\n\t}\n\treturn;\n}\n\n/*\n\tMarch-from-surface-to-light shadowing, with IQ's glancing penumbras.\n*/\nfloat shadow( in vec3 start, in vec3 n, in vec3 ldir, in float p )\n{    \n    // Do some quick \"is the sun even shining on here\" tests.\n    // We wait until the sun is just below the horizon before considering\n    // it gone.\n    if( dot(n,ldir) <= 0.0 || dot(ldir,UP) <= -.25) return 0.0;\n    \n\tfloat t = EPSILON*40.0;\n\tfloat res = 1.0;\n    for ( int i = 0; i < S_STEPS; ++i )\n    {\n        float d = distR( start + ldir * t );\n        if ( d < EPSILON*.1 )\n            return 0.0;\n\t\t\n\t\tres = min( res, p * d / t );\n        t += d;\n\t\t\n\t\tif ( t > MAX_DEPTH )\n\t\t\tbreak;\n    }\n    return res;\n}\n\n/*\n\tIQ's really compact implementation of Oren Nayar reflectance.\n*/\nfloat orenNayar( in vec3 n, in vec3 v, in vec3 ldir )\n{\n    float r2 = pow(MAT_REFLECTANCE, 2.0);\n    float a = 1.0 - 0.5*(r2/(r2+0.57));\n    float b = 0.45*(r2/(r2+0.09));\n\n    float nl = dot(n, ldir);\n    float nv = dot(n, v);\n\n    float ga = dot(v-n*nv,n-n*nl);\n\n\treturn max(0.0,nl) * (a + b*max(0.0,ga) * sqrt((1.0-nv*nv)*(1.0-nl*nl)) / max(nl, nv));\n}\n\n/*\n\tCalculates the ambient occlusion factor at a given point in space.\n\tUses IQ's marched normal distance comparison technique.\n*/\nfloat occlusion( in vec3 pos, in vec3 norm)\n{\n    // I even unrolled it for you. Aren't I nice?\n    float result = pow(2.0,-1.0)*(0.25-dist(pos+0.25*norm));\n    result += pow(2.0,-2.0)*(0.50-dist(pos+0.50*norm));\n    result += pow(2.0,-3.0)*(0.75-dist(pos+0.75*norm));\n\treturn 1.0-result*OCC_FACTOR;\n}\n\n/*\n\tPerforms the full suite of lighting for Oren Nayar-appropriate\n\tsurfaces. Calculates direct (sun), sky, and ambient radiance\n\tcontributions.\n*/\nvec3 light( in vec3 p, in vec3 d, in vec3 e, in vec3 n, in vec3 ld )\n{\n    // Get an ambient occlusion value.\n    #ifdef CALC_OCCLUSION\n    float amb = occlusion(p,n)*max(dot(ld,UP),0.25);\n    #else\n    float amb = 1.0;\n    #endif\n    \n    // Get light colors and radiance for the three lights.\n    // (Or just specral radiance if that's your thing.)\n    vec3 skc = .6*orenNayar(n,-d,UP)*sky(n,ld);\n    vec3 sun = orenNayar(n,-d,ld)*sunColor(ld);\n    vec3 gnd = .2*GROUND_COLOR*max(orenNayar(n,-d,-UP),0.25);\n    \n    // Modulate those by ambient occlussion and shadowing.\n    skc *= amb;\n    gnd *= amb;\n    sun *= shadow(p,n,ld,PENUMBRA_FACTOR);;\n    \n    // Return the sum.\n    return skc+gnd+sun; \n}\n\n/*\n\tReturns the texture of the sand, and does some basic distance\n\tfiltering.\n*/\nvec3 texSand( in vec3 p, in float l )\n{\n    // Essentially what we're doing is just calculating low contrast\n    // random values whose contrast diminishes with distance.\n    return SAND_COLOR*mix(.75+rand(p.xz)*.25, .85, clamp(l/MAX_DEPTH,0.0,1.0));\n}\n\n/*\n\tShades dry sand. Just takes in an illumination value and texture\n\tand multiplies the two together. Simple.\n*/\nvec3 shadeDrySand( in vec3 i, in vec3 t )\n{\n    return i*t;\n}\n\n/*\n\tNon reflective wet sand is a bit harder, but still simple.\n\tEssentially we're doing per-pixel Phong shading, but the diffuse\n\tterm is .5 of the dry sand result. Oh, and the ambient term is\n\tthe sky above.\n*/\nvec3 shadeWetSand( in vec3 p, in vec3 d, in vec3 e, in vec3 n, in vec3 i, in vec3 ld, in vec3 tex )\n{\n\t// Specular.\n\tvec3 r = reflect(d,n);\n    vec3 spec = sunColor(ld) * max( pow(dot(ld,r),50.0), 0.0);\n    // Diffuse.\n    vec3 diff = shadeDrySand(i,tex)*.5;\n    // Ambient.\n    vec3 ambi = sky(n,ld);\n    return spec+diff+ambi;\n}\n\n/*\n\tConstructs the appearance of non-reflection sand (sand that is \n\talready a reflection.) Since you barely see this sand, we don't\n\tworry about if it's wet or not. (To save cycles.)\n*/\nvec3 shadeSand( in vec3 p, in vec3 i, in float l )\n{\n    // Get the texture of the sand.\n    vec3 tex = texSand(p,l);\n    // Pass it into the the shading function.\n    return shadeDrySand(i,tex);\n}\n\n/*\n\tPrepares the texture of the rock. It's pretty much just\n\ta jumbled mix of two colors.\n*/\nvec3 texRock( in vec3 p )\n{\n    p.y *= 8.0;\n    float chroma = nIQ(p*8.0, RAND_NOISE_TEX);\n    // Mix the two rock colors based on a noise value, then somewhat\n    // randomize the lumosity to make it look rough.\n    return mix(ROCK_COLOR_A, ROCK_COLOR_B,chroma)*mix(.8, 1.2, rand(p.xy));\n}\n\n/*\n\tShades the rock. With the illumination color and value pre-computed\n\tthis is a simple task.\n*/\nvec3 shadeRock( in vec3 p, in vec3 i )\n{\n    return texRock(p)*i;\n}\n\n/*\n\tShades the scene as seen through a reflection.\n\tNote how reflections only feature a subset of the\n\tscene's items.\n*/\nvec3 shadeR( in vec3 p, in vec3 d, in vec3 ld, in vec3 e )\n{\n    // Get the distance to the point.\n    float l = length(p-e);\n    \n    // If the ray ran out of length, we return the sky.\n    if(l > MAX_DEPTH) return sky(d,ld);\n    \n    // Get the ID of the current object.\n    float id = distID(p).t;\n    // Get the surface normal of the reflected scene.\n    vec3 n = normR(p);\n    // Get a general light color to use...wherever.\n    vec3 i = light(p,d,e,n,ld);\n    \n    // Do some piecewise shading.\n    #ifdef HQ_RENDERING\n    if(id == ID_ROCK) return shadeRock(p,i);\n    else \t\t\t  return shadeSand(p,i,l);\n    #else\n    return shadeSand(p,i,l);\n    #endif\n}\n\n/*\n\tConstructs the appearance of reflective sand.\n*/\nvec3 shadeWetSandR( in vec3 p, in vec3 d, in vec3 e, in vec3 n, in vec3 i, in vec3 ld, in vec3 tex )\n{\n    // Get the reflected ray direction.\n    vec3 r = reflect(d,n);\n    \n    // March the (now reflected) ray in that direction.\n    #ifdef HQ_RENDERING\n    marchR(p,r,e);\n    // Get the appearance of the point the reflect ray found.\n    vec3 reflection = shadeR(p,r,ld,e);\n    #else\n    vec3 reflection = sky(r,ld);\n    #endif\n    // Create a standard Phong specular term to spice things up in\n    // the shiny department.\n    vec3 specular = pow(max(dot(r,ld),0.0),350.0)*sunColor(ld);\n    // Get the reflectance of the surface given the angle of incidence.\n    float reflectance = max(length(cross(n,d)),0.0);\n    // Get the diffuse term. (discussed in shadeWetSand().)\n    vec3 diffuse = tex*i*.5;\n    // Return a blend of the reflection and the sand and the specular highlight.\n    return mix(diffuse, reflection, pow(reflectance,128.0))+specular;\n}\n\n/*\n\tConstructs the appearance of first-bounce sand, whether it's wet and reflective\n\tor not.\n*/\nvec3 shadeSandR( in vec3 p, in vec3 d, in vec3 e, in vec3 n, in vec3 i, in vec3 ld, in float l )\n{\n    // Compute the texture of the sand.\n    vec3 tex = texSand(p,l);\n    \n    // Figure out how wet the sand is. This is just some quasi-good value\n    // that is vaguely related to the height of the water, but higher.\n    float wetness = clamp(smoothstep(OCEAN_HEIGHT, 0.075, p.y),\n                          0.0,1.0);\n    \n    // Get the appearance of reflective wet sand.\n    vec3 wet = shadeWetSandR(p,d,e,n,i,ld,tex);\n    // Get the appearance of the dry sand.\n    vec3 dry = shadeDrySand(i,tex);\n    \n    // Return a mix of wet and dry sand based on the wetness of the sand.\n    return mix(wet,dry,wetness);\n}\n\n/*\n\tShades the ocean with its reflections.\n*/\nvec3 shadeOceanR( in vec3 p, in vec3 d, in vec3 e, in vec3 n, in vec3 ld, in vec3 sky )\n{\n    // Get the pirate vector.\n    vec3 r = reflect(d,n);\n    \n    // March P away from where it started out.\n    marchR(p,r,e);\n    \n    // Get the image of the reflection.\n    vec3 reflection = shadeR(p,r,ld,e);\n    // Make a swanky specular highlight.\n    vec3 specular = pow(max(dot(r,ld),0.0),500.0)*sunColor(ld);\n    \n    // Get a non-reflection color for the ocean.\n    vec3 ocean = vec3(.0,.08, .1)*max(0.005, dot(d,UP));\n    // Get how much the reflection should be visible.\n    float reflectance = pow(max(length(cross(n,d)),0.0),2.0); //Sin^2(incidence)\n    // Do some mixin'.\n    return mix(ocean,reflection,reflectance*.5)+specular;\n}\n\n/*\n\tThe first bounce shading function. Takes that first ray, beats it up,\n\tand sends to next Tuesday.\n*/\nvec3 shade( in vec3 p, in vec3 d, in vec3 e )\n{\n    // Get the distance for that gentle blend at the horizon.\n    float l = length(p-e);\n    // Get the sun direction and sky color once, and pass it around.\n    vec3 ld = sunDir();\n    vec3 s = sky(d,ld);\n    \n    // Take care of the appearance of culled stuff--they're sky now.\n    if(l > MAX_DEPTH) return s;\n    \n    // Get the ID of the object we're shading, and make a place\n    // to store the final result.\n    float id = distID(p).t;\n    vec3 result;\n    \n    // Get the normal and create a general Oren Nayar term to be\n    // the shade functions' village bicycle, right next to the\n    // light direction, which is the village Razor scooter.\n    vec3 n = norm(p);\n    vec3 i = light(p,d,e,n,ld);\n    \n    // Shade the surface, based on the object ID.\n    if(id == ID_OCEAN){\n        float distSand = sand(p);\n        float distOcean = ocean(p);\n        vec3 sand = shadeSandR(p,d,e,n,i,ld,l);\n        vec3 ocean = shadeOceanR(p,d,e,n,ld,s);\n        result = mix(sand,ocean,clamp(distSand-distOcean,0.0,2.0)*.5);\n    }\n    else if(id == ID_SAND)\tresult = shadeSandR(p,d,e,n,i,ld,l);\n    else result = shadeRock(p,i);\n        \n    // Mix this shaded color with the color of the sky at far distances,\n    // so we don't have that ugly plane() @ MAX_DEPTH edge.\n\treturn mix(s,result,smoothstep(0.0, MAX_DEPTH*.125, clamp(MAX_DEPTH-l,0.0,MAX_DEPTH*.125)));\n}\n\n/*\n\tPerforms some quick post-processing. Does gamma correction\n\tand adds a soft vignette just to make whatever you're doing\n\tlook pretty.\n*/\nvec3 postProcess( in vec2 uv, in vec3 c )\n{\n    float vig = 1.0-dot(uv,uv)*.3;\n    return pow(c,vec3(1.0/2.2))*vig;\n}\n\n/*\n\tShadertoy's entry point.\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Standard pixel-coordinate normalization.\n    vec2 uv = fragCoord / iResolution.xy - 0.5;\n\tuv.x *= iResolution.x/iResolution.y; //fix aspect ratio\n    \n    // Position, direction, and eye.\n    // Notice that it spells out the Processing file extension?\n    vec3 p,d,e;\n    \n    // The shutter. This is populated by animateCam() as a frame\n    // brightness coefficient to fade between scenes.\n    float s;\n    \n    // Set up the camera.\n    animateCam(uv,iTime,p,d,e,s);\n    \n    // Do the actual ray marching.\n    march(p,d,e);\n    \n    // Store the final pixel color.\n    //fragColor = postProcess(uv,shade(p,d,e)).rgbb*s;\n    // Eventually the alpha of fragColor may be used.\n    fragColor = vec4(postProcess(uv,shade(p,d,e)),1.0);\n}","name":"Image","description":"","type":"image"}]}