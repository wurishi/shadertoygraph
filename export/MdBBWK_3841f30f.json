{"ver":"0.1","info":{"id":"MdBBWK","date":"1502172128","viewed":155,"name":"Variable depth simplex terrain","username":"tiusic","description":"Varying the depth of simplex noise based on more simplex noise. This changes the average feature size of the terrain in different areas, allowing for huge continents and intricate archipelagos.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["procedural","fractal","simplex"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float R2 = 0.5;\nfloat TAU = 6.28318530718;\nfloat F = 0.86602540378;\n\nvec2 hash(vec2 p, float z) {\n    vec3 p3 = vec3(p, z);\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    float t = TAU * fract((p3.x + p3.y) * p3.z);\n    return vec2(cos(t), sin(t));\n}\n\nvec2 skew(vec2 p) {\n    p.y /= F;\n    p.x += 0.5 * p.y;\n    return p;\n}\n\nvec2 unskew(vec2 q) {\n    q.x -= 0.5 * q.y;\n    q.y *= F;\n    return q;\n}\n\nfloat surflet(vec2 q, vec2 p, float z) {\n    vec2 h = hash(q, z);\n    vec2 d = unskew(q) - p;\n    float d2 = d.x * d.x + d.y * d.y;\n    return pow(max(0.0, R2 - d2), 4.0) * dot(d, h);\n}\n\nfloat simplex(vec2 p, float z) {\n    vec2 q = skew(p);\n    vec2 qa = floor(q);\n    vec2 qi = q - qa;\n    vec2 qb = qa + vec2(1.0, 1.0);\n    vec2 qc;\n    \n    if (qi.x < qi.y) {\n\t\tqc = qa + vec2(0.0, 1.0);\n    } else {\n\t\tqc = qa + vec2(1.0, 0.0);\n    }\n    \n    float ka = surflet(qa, p, z);\n    float kb = surflet(qb, p, z);\n    float kc = surflet(qc, p, z);\n    return ka + kb + kc;\n}\n\nfloat lim(float x) {\n    return max(0.0, min(1.0, x));\n}\n\nfloat noise(vec2 p, float l, float w) {\n    float k = 0.0;\n    float o = 1.0;\n    float z;\n    for (z = 0.0; z < l; ++z) {\n        k += simplex(p / o, z + w) * o;\n        o *= 2.0;\n    }\n    k += (l + 1.0 - z) * simplex(p / o, z + w) * pow(2.0, l);\n    return lim(0.5 + 50.0 * k / pow(2.0, l));\n}\n\nvec4 terrain(float k) {\n    k = lim(k);\n    if (k < 0.5) {\n        return vec4(0.0, k, 0.7 + 0.6 * k, 1.0);\n    } else if (k < 0.55) {\n        return vec4(1.0, 4.0 * (k - 0.5) + 0.8, 0.6, 1.0);\n    } else if (k < 0.8) {\n        return vec4(0, 0.5 * k + 0.5, 0.0, 0.0);\n    } else if (k < 0.85) {\n        return vec4(0, -9.1 * k + 8.18, 0.0, 1.0);\n    }\n    return vec4(0, (1.0 - k) * 0.3 + 0.4, 0.0, 1.0);\n}\n\nfloat grid(vec2 p, float cam, float size) {\n    size *= 30.0;\n    float cc = sqrt(0.25 * cam / size);\n    vec2 d = abs(mod(p / size + 0.5, 1.0) - 0.5);\n    float dd = min(d.x, d.y);\n    if (dd < cc) {\n        return 1.0 - dd / cc;\n    }\n    return 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float zoom = 0.5 + 0.5 * sin(0.1 * iTime);\n    float cam = 1.0 + 50.0 * zoom;\n    vec2 p = (fragCoord - 0.5 * iResolution.xy) * cam;\n    p += 1000.0 * vec2(10.0 * sin(iTime / 10.0), iTime);\n    \n    float l = noise(p / 100.0, 7.0, 0.0);\n    float k = noise(p, 9.0 + 5.0 * l, 100.0);\n    float m = noise(p, 16.0, 0.0);\n    float h = 3.0 * m + 0.6 * k - 2.0;\n    float r = 1.0 - abs(noise(p / 6.0, 12.0, 200.0) - 0.5) * 100.0;\n    if (r > 0.0 && h > 0.5) {\n        h = min(h, 0.55 - 0.1 * r);\n    }\n    fragColor = terrain(h);\n    \n    if (zoom < 0.25) fragColor += 0.1 * grid(p, cam, 1.0) * smoothstep(zoom, 0.25, 0.15);\n    fragColor += 0.1 * grid(p, cam, 10.0);\n}","name":"Image","description":"","type":"image"}]}