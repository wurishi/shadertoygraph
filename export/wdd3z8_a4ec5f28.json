{"ver":"0.1","info":{"id":"wdd3z8","date":"1567807073","viewed":118,"name":"Smoothmin Ray Marching Acid Trip","username":"jacobus_ii","description":"I did a thing. It is probably incredibly inefficient. ","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","smoothmin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float tau = 6.28318530718;\nconst int maxiterations = 300;\nconst float maxdist = 1000.0;\nconst float stopCriterium = 0.001;\n\nfloat distanceEstimatorFloor(vec3 v){\n\treturn v.y;\n}\n\nfloat distanceEstimatorBall(vec3 v, vec3 center, float r){\n\treturn length(v-center)-r;   \n}\n\nvec4 mixShadow(vec4 col, float shadow){\n    return mix(col,vec4(0.0,0.0,0.0,1.0),1.0-shadow);\n}\n\nfloat smoothMin(float distA, float distB, float k){\n\tfloat h = max(k-abs(distA - distB),0.0)/k;\n    return min(distA, distB) - h*h*h*k*1.0/6.0;\n}\n\nmat4 cameraTransform() {\n    //no scaling allowed\n    return mat4(cos(-iTime-tau/4.0), 0.0, sin(-iTime-tau/4.0), 0.0,\n                0.0, 1.0, 0.0, 0.0,\n                -sin(-iTime-tau/4.0), 0.0, cos(-iTime-tau/4.0), 0.0,\n                3.0 + sqrt(18.0) * sin(iTime), 1.0, 3.0 + sqrt(18.0)*cos(iTime), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //objects\n    vec3 ballPos = vec3(3.0,1.5 + 1.0*sin(3.0*iTime),3.0);\n    float ballRad = 1.0;\n    \n    vec3 ball2Pos = vec3(3.0+1.5*sin(2.0*iTime),1.5,3.0-1.5*sin(2.0*iTime));\n    float ball2Rad = 0.5;\n    \n    vec3 ball3Pos = vec3(3.0+2.0*sin(1.0*iTime),1.5-2.0*cos(1.0*iTime),3.0-2.0*sin(1.0*iTime));\n    float ball3Rad = 0.5;\n    \n    vec4 homCamerapos = vec4(0.0,0.0,0.0,1.0);\n    \n    //camera vectors\n    vec3 camerapos = (cameraTransform() * homCamerapos).xyz;\n    \n    vec3 cameradir = vec3(1.0,0.0,0.0);//vec3(1.0 /*sin(0.5*iTime)*/, 0, 1.0/*cos(0.5*iTime)*/);\n    vec3 normalone = vec3(0.0,1.0,0.0);\n    vec3 normaltwo = vec3(0.0,0.0,1.0);\n    float fovstep = tau/3.0;\n    \n    //light\n    vec3 lightpos = vec3(0.0,10.0,0.0);\n    \n    \n    // Normalized pixel coordinates (from 0 to 1), but without distortion\n    vec2 uv = (fragCoord - (iResolution.xy * 0.5))/(iResolution.x * 0.5);\n    \n    //crosshair\n    \n    /*if(length(uv)<0.003){\n    \tfragColor = vec4(0.0,0.0,0.0,1.0);\n        return;\n    }*/\n\t\n    \n    //particle cast direction\n    \n    vec3 particleDir = cameradir + fovstep * uv.x * normaltwo + fovstep*uv.y*normalone;\n    particleDir = normalize(particleDir);\n    particleDir = (cameraTransform() * vec4(particleDir,0.0)).xyz;\n    \n    float distFromCam = 0.0;\n    vec3 particlePos = camerapos;\n    \n    for(int i=0;i<maxiterations && distFromCam < maxdist;++i){\n        \n        //ugly distance calculations\n        float planeDist = distanceEstimatorFloor(particlePos);\n        float ballDist = distanceEstimatorBall(particlePos,ballPos,ballRad);\n        float ball2Dist = distanceEstimatorBall(particlePos,ball2Pos,ball2Rad);\n        float ball3Dist = distanceEstimatorBall(particlePos,ball3Pos,ball3Rad);\n        \n        \n        float stepsize = smoothMin(smoothMin(planeDist,ballDist,1.0),smoothMin(ball3Dist,ball2Dist,1.0),1.0);\n        \n        //draw object\n        if(stepsize < stopCriterium){\n        \t//draw closest object maybe\n            \n            //cast ray towards light\n            //1.0 = no shadow\n            float shadow = 1.0;\n            vec3 lightParticlePos = particlePos;\n            vec3 lightParticleDir = normalize(lightpos - lightParticlePos);\n            float minLightStep = 1000.0;\n            \n            //initial small step\n            lightParticlePos += 100.0*stopCriterium*lightParticleDir;\n            \n            for(int j=0;j<maxiterations;++j){\n                float lightBall1Dist = distanceEstimatorBall(lightParticlePos,ballPos,ballRad);\n                float lightBall2Dist = distanceEstimatorBall(lightParticlePos,ball2Pos,ball2Rad);\n           \t\tfloat lightBall3Dist = distanceEstimatorBall(lightParticlePos,ball3Pos,ball3Rad);\n                float lightLightDist = distanceEstimatorBall(lightParticlePos,lightpos,0.0);\n                \n                float lightBallDist = smoothMin(smoothMin(lightBall1Dist,lightBall2Dist,1.0),lightBall3Dist,1.0);\n                \n                //lots of bad constants. wish i could put this into a nice second function,\n                //without having to pass all the worldObjects as vectors.\n                \n                if (lightLightDist < lightBallDist){\n                  shadow = min(minLightStep,0.1)/0.1; \n                    break;\n                }\n                \n                float lightStepsize = min(lightBallDist,lightLightDist);\n                \n                if(lightStepsize < minLightStep){\n                \tminLightStep = lightStepsize;   \n                }\n                \n                lightParticlePos += lightParticleDir * lightStepsize;\n                if(j == maxiterations-1){\n                    shadow = min(minLightStep,0.2)/0.2;\n                    break;\n                }\n            }\n            \n            //shadow mixing with color of balls/floor\n            shadow = min(shadow + 0.2,1.0);\n            \n            if(ballDist < planeDist && ballDist < ball2Dist && ballDist < ball3Dist){\n                fragColor = mixShadow(vec4(1.0,0.5,0.0,1.0),shadow);\n                return;\n            }\n            \n            if(ball2Dist < planeDist && ball2Dist < ballDist && ball2Dist < ball3Dist){\n                fragColor = mixShadow(vec4(0.0,0.5,1.0,1.0),shadow);\n                return;\n            }\n            \n            if(ball3Dist < planeDist && ball3Dist < ballDist && ball3Dist < ball2Dist){\n                fragColor = mixShadow(vec4(0.5,0.0,1.0,1.0),shadow);\n                return;\n            }\n            \n            if(  (fract(particlePos.x/2.)<0.5) == (fract(particlePos.z/2.)<0.5)   ){\n            \tfragColor = mixShadow(vec4(0.6,0.6,0.6,1.0),shadow);\n            }else{\n                fragColor = mixShadow(vec4(0.8,0.8,0.8,1.0),shadow);\n            }\n            return;\n        }else{\n            //continue stepping\n            particlePos = particlePos + stepsize*particleDir;\n            distFromCam = length(particlePos - camerapos);\n        }\n        \n    }\n    if(distFromCam >= maxdist){\n        //max dist reached\n    \tfragColor = vec4(0.7,0.7,0.7,1.0);\n    \treturn;\n    }else{\n        //max iterations reached\n    \tfragColor = vec4(0.8,0.8,0.8,1.0);\n    \treturn;\n    }\n}","name":"Image","description":"","type":"image"}]}