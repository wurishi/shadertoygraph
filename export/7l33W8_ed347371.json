{"ver":"0.1","info":{"id":"7l33W8","date":"1636148278","viewed":184,"name":"Voxel cave","username":"StarikTenger","description":"If it seems to be wrong try to set FOG_STRENGTH to 0.0 (line 5)","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raycasting","water","voxel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141693\n#define CAVE_STRETCH 1.\n#define RAYCASTING_STEPS 50\n#define FOG_POWER 5.\n#define FOG_STRENGTH .01\n#define SHADOW_K .3\n#define FIREFLY_SIZE 0.1\n#define FIREFLY_REFLECTION_SIZE 0.3\n#define FIREFLY_REFLECTION_STRENGTH 1.\n#define WATER_LEVEL -3.2\n#define REFRACTION_K 1.03\n#define CAM_WIDTH 2500.\n#define COLOR_SATURATION .5\n#define TIME_SPEEDUP 2.;\n\nfloat time;\n\n// Sine function with frequency, amplitude and phase\nfloat wave(float x, float freq, float amp, float phase) {\n    return sin(x * freq + phase) * amp;\n}\n\n// Form of the tunnel\nvec2 main_curve(float x) {\n    x *= CAVE_STRETCH;\n    // Some weird sine composition\n    return vec2(\n        wave(x, 0.0067, 2., 2.3) + wave(x, 0.1, 1., 0.), \n        wave(x, 0.01, 16., 2.) + wave(x, 0.23, 6., 0.2)\n    );\n}\n\n// Checks if this coordinates is in solid block\nbool checkVox(vec3 pos) {\n    // Round coordinates\n    pos = floor(pos);\n    // Just another sine composition\n    return distance(pos.yz, \n        vec2(\n            wave(pos.x, 1., 1., 0.) + main_curve(pos.x).x, \n            wave(pos.x, 1., 1., 1.) + main_curve(pos.x).y\n        )) > 6. + 2.*sin(pos.x * 0.1);\n}\n\n// Light source\nvec3 light_pos;\n\n\n// Rotate funcs\nvec2 rotate(vec2 v, float a) {\n\treturn vec2(v.x * cos(a) - v.y * sin(a), v.x * sin(a) + v.y * cos(a));\n}\n\nvec3 rotate(vec3 v, vec2 ang){\n    v = v.zxy;\n    vec2 p = rotate(vec2(v.x, v.z), ang.y);\n\tv = vec3(p.x, v.y, p.y);\n    v = vec3(rotate(vec2(v.x, v.y), ang.x), v.z);\n    return v.xzy;\n}\n\n// Actual ray direction, position\nvec3 cam_pos;\nvec3 ray_dir;\nvec3 ray_pos;\nvec3 normal;\nbool contact = false;\nstruct ray {\n    vec3 pos;\n    vec3 dir;\n    vec3 cam;\n    vec3 normal;\n};\nint ray_stack_top = 0;\nray ray_stack[3];\nvec3 ray_pos_prev;\nvec3 ray_dir_prev;\nvec3 cam_pos_prev;\nvec3 normal_prev;\n\nvoid ray_save() {\n    ray_stack[ray_stack_top].pos = ray_pos;\n    ray_stack[ray_stack_top].dir = ray_dir;\n    ray_stack[ray_stack_top].cam = cam_pos;\n    ray_stack[ray_stack_top].normal = normal;\n    ray_stack_top++;\n}\n\nvoid ray_restore() {\n    ray_stack_top--;\n    ray_pos = ray_stack[ray_stack_top].pos;\n    ray_dir = ray_stack[ray_stack_top].dir;\n    cam_pos = ray_stack[ray_stack_top].cam;\n    normal = ray_stack[ray_stack_top].normal;\n    contact = false;\n}\n\nvoid ray_reflect(){\n    ray_pos += normal * 0.01;\n    cam_pos = ray_pos;\n    ray_dir -= normal * dot(normal, ray_dir) * 2.;\n}\n\nvoid ray_refract() {\n    float eta = REFRACTION_K;\n    vec3 I = ray_dir;\n    vec3 N = normal;\n    float k = 1.0 - eta * eta * (1.0 - dot(N, I) * dot(N, I));\n    k *= -1.;\n    if (k >= 0.0)\n        ray_dir = eta * I - (eta * dot(N, I) + sqrt(k)) * N;\n}\n\n// Step of raycasting\nvoid raycastStep() {\n    // Find corner coresponding to ray direction\n    vec3 pos_cornered = floor(ray_pos);\n    if (ray_dir.x > 0.) pos_cornered.x += 1.;\n    if (ray_dir.y > 0.) pos_cornered.y += 1.;\n    if (ray_dir.z > 0.) pos_cornered.z += 1.;\n    \n    // Get intersections\n    vec4 intersections[3];\n    intersections[0].xyz = ray_dir * (pos_cornered.xxx - ray_pos.xxx) / ray_dir.xxx + ray_pos;\n    intersections[1].xyz = ray_dir * (pos_cornered.yyy - ray_pos.yyy) / ray_dir.yyy + ray_pos;\n    intersections[2].xyz = ray_dir * (pos_cornered.zzz - ray_pos.zzz) / ray_dir.zzz + ray_pos;\n    for (int i = 0; i < 3; i++) intersections[i].w = distance(ray_pos, intersections[i].xyz);\n    \n    // Find closest intersection\n    float min_dist = intersections[0].w;\n    int closest_intersection = 0;\n    for (int i = 1; i < 3; i++) {\n        if (intersections[i].w < min_dist) {\n            closest_intersection = i;\n            min_dist = intersections[i].w;\n        }\n    }\n    \n    ray_pos = intersections[closest_intersection].xyz;\n    \n    // Calculate normal vector\n    normal = vec3(0.,0.,0.);\n    switch (closest_intersection) {\n        case 0: normal.x = -sign(ray_dir.x); break;\n        case 1: normal.y = -sign(ray_dir.y); break;\n        case 2: normal.z = -sign(ray_dir.z); break;\n    }\n    \n    // If we should terminate, contact=true. If not, we apply micromovement to avoid ray_pos on very edge of voxel\n    if (checkVox(ray_pos - normal*0.5))\n        contact = true;\n    else\n        ray_pos -= normal*0.001;\n}\n\n// Returns color of a pixel\nvec3 raycast() {\n    vec3 col = vec3(0.4,0.4,0.4);\n    \n    // Find closest intersection\n    for (int i = 0; i < RAYCASTING_STEPS && !contact; i++)\n        raycastStep();\n        \n    // Texture & surface\n    if (contact) {\n    \n        // Get right point on texture\n        float k = 8.;\n        vec3 pos = (ray_pos / k - floor(ray_pos / k));\n        if (normal.x != 0.) pos.xy = pos.yz;\n        if (normal.y != 0.) pos.xy = pos.xz;\n        if (normal.z != 0.) pos.xy = pos.xy;\n        \n        // Texture\n        col = texture(iChannel0, pos.xy).xyz * 0.4;\n        \n        // Surface\n        normal += texture(iChannel1, pos.xy*4.).xyz * 0.4;\n        normal = normalize(normal);\n        //col = normal;\n        \n    }\n    // Light\n    float light = dot(light_pos - ray_pos, normal) * 5. / pow(distance(light_pos, ray_pos), 2.);\n    col *= light;\n    \n    // Shadow\n    bool shadow = false;\n    // save ray parameters\n    ray_save();\n    // Find obastacles between light and current point\n    cam_pos = ray_pos;\n    ray_pos += normal * 0.01;\n    ray_dir = normalize(light_pos - ray_pos);\n    contact = false;\n    float lim_dist = distance(cam_pos, light_pos);\n    for (int i = 0; distance(cam_pos, ray_pos) < lim_dist && !contact; i++)\n        raycastStep();\n    shadow = contact;\n    \n    // restore ray parameters\n    ray_restore();\n    \n    \n    // Firefly\n    {\n        vec3 proj = cam_pos + dot(ray_dir, light_pos - cam_pos) * ray_dir;\n        float dist = distance(proj, light_pos);\n        if (distance(cam_pos, light_pos) < distance(cam_pos, ray_pos))\n            col += vec3(FIREFLY_SIZE/pow(dist, 0.7),0.,0.).xxx;\n    }\n    \n    \n    \n    // Firefly reflection\n    ray_reflect();\n    if (!shadow && dot(ray_dir, light_pos - cam_pos) > 0.) {\n        vec3 proj = cam_pos + dot(ray_dir, light_pos - cam_pos) * ray_dir;\n        float dist = distance(proj, light_pos);\n        col += vec3(FIREFLY_REFLECTION_SIZE/pow(dist, .9),0.,0.).xxx * FIREFLY_REFLECTION_STRENGTH;\n    }\n    \n    \n    // Apply shadow\n    if (shadow)\n        col *= SHADOW_K;\n    \n   \n    \n    return col;\n}\n\n// Raycasting with water\nvec3 raycast_water() {\n    vec3 col = vec3(0,0,0);\n    // Find intersection with water\n    vec3 water_intersection = ray_dir * (WATER_LEVEL - ray_pos.yyy) / ray_dir.yyy + ray_pos;\n    \n    \n    // Find closest intersection\n    for (int i = 0; i < RAYCASTING_STEPS && !contact; i++)\n        raycastStep();\n    ray_save();\n    \n    // Water\n    float opacity = 1.;\n    if (dot(ray_dir, water_intersection-cam_pos) > 0. && distance(cam_pos, water_intersection) < distance(cam_pos, ray_pos)) {\n        col += vec3(0.,0.05,0.1) * 0.5;\n        normal = vec3(0,1.,0.);        \n        contact = false;\n        ray_pos = water_intersection;\n        \n        // Surface\n        // Get right point on texture\n        float k = 16.;\n        vec3 pos = (ray_pos / k - floor(ray_pos / k));\n        normal += \n            texture(iChannel2, (pos.xz + vec2(0., time * 0.1))/8.).xyz * 0.2 +\n            texture(iChannel2, pos.xz + vec2(-time * 0.02, time * 0.02)/4.).xyz * 0.1 +\n            texture(iChannel2, pos.xz + vec2(time * 0.02, -time * 0.02)).xyz * 0.05;\n        normal = normalize(normal);\n        \n        ray_save();\n        ray_reflect();\n        col += raycast() * 0.8;\n        \n        opacity = 0.4;\n        \n        // Refraction\n        ray_restore();\n        ray_refract();\n    } else {\n        ray_restore();\n        contact = true;\n    }\n    \n    col += raycast() * opacity;\n    // Calculate fog\n    cam_pos = ray_stack[ray_stack_top - 1].cam;\n    vec3 fog = vec3(.6, 0.8, 1.) * 0.5;\n    float fogK = pow(distance(cam_pos, ray_pos) * 0.1, FOG_POWER) * FOG_STRENGTH;\n    // Apply fog\n    col = (col + fog * fogK) / (1. + fogK);\n    \n    return col;\n}\n\n// Coordinates based on x-pos (to process cam and light positions)\nvec3 current_coordinates(float t) {\n    return vec3(\n        t,\n        main_curve(t).xy\n    );\n}\n\n// vec2-dir from direction vector\nvec2 get_dir(vec3 dir) {\n    return vec2(\n        atan(dir.xz).y,\n        atan(vec2(sqrt(dir.x * dir.x + dir.z * dir.z), dir.y)).y\n    );\n}\n\n// Cubic saturation; x from 0 to 1\nfloat saturate(float x) {\n    float t = 2.*x-1.;\n    return (3.*t-t*t*t)/4. + 0.5;\n}\n\n// Post-processing func\nvec3 post_proc(vec3 col) {\n    return col * (1. - COLOR_SATURATION) + \n        vec3(\n            saturate(col.x),\n            saturate(col.y),\n            saturate(col.z)\n        ) * COLOR_SATURATION;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    time = 235. + iTime * TIME_SPEEDUP;\n    float x = time * 1.;\n    // Camera position\n    cam_pos = current_coordinates(x);\n    // Light position\n    light_pos = current_coordinates(x + 5. + 3.*sin(time));\n    light_pos.y += 1. + 2.*sin(time * 0.33);\n    // Some kind of camera velocity\n    x += 5.;\n    vec3 move_dir = normalize(current_coordinates(x+1.) - current_coordinates(x));\n    // Camera direction\n    vec2 cam_dir = vec2(2.*PI*(iMouse.x/iResolution.x - 0.5), PI* (1./2.0*(iMouse.y/iResolution.y - 1.0) +0.25)) * 2.; \n    \n    float cam_width = CAM_WIDTH;\n    cam_width /= iResolution.x;\n    cam_dir = get_dir(move_dir);\n    ray_pos = cam_pos ;\n    \n    // Normalized pixel coordinates\n    vec2 uv = (fragCoord/iResolution.xy- vec2(0.5, 0.5)) * iResolution.xy * 0.001;\n    // Rotation according to velocity\n    uv = rotate(uv, -move_dir.z * 0.5);\n    // Ray direction\n    ray_dir = rotate(normalize(vec3(uv.xy, (1. ) / cam_width)), cam_dir);\n\n    // Raycasting\n    vec3 col = raycast_water();\n    \n    // Limiting color\n    col.x = min(1., col.x);\n    col.y = min(1., col.y);\n    col.z = min(1., col.z);\n    \n    // Post-processing\n    col = post_proc(col);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}