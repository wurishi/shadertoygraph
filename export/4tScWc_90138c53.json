{"ver":"0.1","info":{"id":"4tScWc","date":"1510506050","viewed":551,"name":"Coupled Lotka-Volterra Equations","username":"FlexMonkey","description":"A pair of coupled Lotka-Volterra equations modified to include the Gray Scott reaction rate term (uv²). Channel 0 subtracts the reaction rate from `x` and adds to `y`, channel 1 does the opposite.\n\nThe result  are transient blobs racing across the scene.","likes":24,"published":1,"flags":48,"usePreview":0,"tags":["lotkavolterra","predatorprey"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\tSimon Gladman | http://flexmonkey.blogspot.co.uk/ | November 2017\n\n\tSee: https://en.wikipedia.org/wiki/Lotka–Volterra_equations\n*/\n\nint radius = 5; \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = fragCoord / iResolution.xy;\n    vec2 pixelSize = vec2(1.0 / iResolution.xy); \n    \n    vec3 zero = texture(iChannel0, coord).xyz;\n\n    float count = 0.0;\n    vec2 accum = vec2(0);\n    \n    for (int x = -radius; x <= radius; x++) {\n        for (int y = -radius; y <= radius; y++) {\n            if (length(vec2(x, y)) < float(radius)) {\n            \taccum += texture(iChannel0, coord + pixelSize * vec2(x, y)).xy;\n                count++;\n            }\n        }\n    }\n    \n    accum /= count; \n    \n    fragColor = vec4(smoothstep(0.0, 0.1, accum.xyy), 1.0); \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n/*\n\tSimon Gladman | http://flexmonkey.blogspot.co.uk/ | November 2017\n\n\tSee: https://en.wikipedia.org/wiki/Lotka–Volterra_equations\n*/\n\nint radius = 9; \n\nfloat alpha = 1.76; \nfloat beta = 1.75;\nfloat gamma = 1.45;\nfloat delta = 1.65;\n\nfloat timestep = 0.0005; \n\n\nfloat noise(vec2 co) {\n    vec2 seed = vec2(sin(co.x), cos(co.y));\n    return fract(sin(dot(seed ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// Keyboard reset taken from https://www.shadertoy.com/view/XtcGD2\nbool reset() {\n    return texture(iChannel3, vec2(32.5/256.0, 0.5) ).x > 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = fragCoord / iResolution.xy;\n    vec2 pixelSize = vec2(1.0 / iResolution.xy); \n\n    vec2 accum = vec2(0);\n    \n    for (int x = -radius; x <= radius; x++) {\n        for (int y = -radius; y <= radius; y++) {\n            if (length(vec2(x, y)) < float(radius)) {\n            \taccum += texture(iChannel0, coord + pixelSize * vec2(x, y)).xy;\n            }\n        }\n    }\n\n    if(texture(iChannel1, coord) == vec4(0) || reset()) {\n       float x = noise(coord);\n       float y = noise(coord.yx);\n       fragColor = vec4(x, y, 0.0, 1.0) * length(coord - 0.5); \n    } \n    else {\n        float x = accum.x;\n        float y = accum.y;\n      \n    \tfloat reactionRate = x*y*y;\n    \n\t\tfloat dx = alpha*x - reactionRate -beta*x*y;\n\t\tfloat dy = delta*x*y + reactionRate - gamma*y;\n        \n        vec2 result = texture(iChannel0, coord).xy + vec2(dx, dy) * timestep;\n\n        fragColor = clamp(vec4(result.xy,\n                               0.0,\n                               1.0), 0.0, 1.0); \n    }\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n/*\n\tSimon Gladman | http://flexmonkey.blogspot.co.uk/ | November 2017\n\n\tSee: https://en.wikipedia.org/wiki/Lotka–Volterra_equations\n*/\n\nint radius = 5; \n\nfloat alpha = 2.95; \nfloat beta = 1.20;\nfloat gamma = 3.85;\nfloat delta = 3.85;\n\nfloat timestep = 0.001; \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = fragCoord / iResolution.xy;\n    vec2 pixelSize = vec2(1.0 / iResolution.xy); \n\n    vec2 accum = vec2(0);\n    \n    for (int x = -radius; x <= radius; x++) {\n        for (int y = -radius; y <= radius; y++) {\n            if (length(vec2(x, y)) < float(radius)) {\n            \taccum += texture(iChannel0, coord + pixelSize * vec2(x, y)).xy;\n            }\n        }\n    }\n\n\tfloat x = accum.x;\n\tfloat y = accum.y;\n      \n    float reactionRate = x*y*y;\n    \n\tfloat dx = alpha*x + reactionRate -beta*x*y;\n\tfloat dy = delta*x*y - reactionRate - gamma*y;\n        \n\tvec2 result = texture(iChannel0, coord).xy + vec2(dx, dy) * timestep;\n\n\tfragColor = clamp(vec4(result.xy,\n                           0.0,\n                           1.0), 0.0, 1.0); \n   \n}","name":"Buf A","description":"","type":"buffer"}]}