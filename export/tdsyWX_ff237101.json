{"ver":"0.1","info":{"id":"tdsyWX","date":"1585759096","viewed":123,"name":"PCD@Tokyo DCC1 'hole'","username":"ankd","description":"fall down into the hole.\n---\n#dailycodingchallenge is a project of PCD(ProcessingCommunityDay)@Tokyo\nhttps://twitter.com/PCD_Tokyo","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","pcd"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = acos(-1.);\n#define SS smoothstep\n\nfloat Y;// camera's pos.y\n\nmat2 rotate(in float r) { float s=sin(r), c=cos(r); return mat2(c, -s, s, c); }\nvec2 rotate(in vec2 p, in float r) { return rotate(r) * p; }\nvec3 rotate(in vec3 p, in vec3 r) {\n    p.xy *= rotate(r.z);\n    p.yz *= rotate(r.x);\n    p.zx *= rotate(r.y);\n    return p;\n}\n\nfloat hash(in float v) { return fract(sin(v)*43768.5453); }\nfloat hash(in vec2 v) { return fract(sin(dot(v, vec2(12.9898, 78.233)))*43768.5453); }\nfloat hash(in vec3 v) { return fract(sin(dot(v, vec3(12.9898, 78.233, 171.98)))*43768.5453); }\nvec3 hash3(in vec3 v) {\n\treturn vec3(hash(v.x), hash(v.y), hash(v.z));\n}\n\n\n// 2d df\nfloat circle(in vec2 p, in float r) { return length(p) - r; }\nfloat rect(in vec2 p, in vec2 b) { vec2 d = abs(p)-b; return length(max(d, 0.)) + min(max(d.x, d.y), 0.); }\n\n// 3d df\nfloat sphere(in vec3 p, in float r) { return length(p) - r; }\nfloat box(in vec3 p, in vec3 b) { vec3 d = abs(p) - b; return length(max(d, 0.)) + min(max(d.x, max(d.y, d.z)), 0.); }\nfloat box(in vec3 p, in float b) { return box(p, vec3(b)); }\n\nfloat hole(in vec3 p, in float r) { return rect(p.xz, vec2(r)); }\n\n// scene objs\nfloat arch(in vec3 p) {\n    p.xz = rotate(p.xz, p.y*0.1+iTime);\n    float d = abs(hole(p, 1.6));\n    return d;\n}\n\n#define repeat(p,c) (mod(p,c)-0.5*c)\n#define repeatid(p,c) (floor(p/c))\nvec2 particle(in vec3 p) {\n    vec3 c = vec3(.8);\n    vec3 id = repeatid(p,c);\n\tp = repeat(p,c);\n    float r = 0.01;\n    vec3 offset = hash3(id*vec3(9999., 99., 999.));\n    offset = (offset - 0.5) * (0.5*c - r);\n    offset += 0.1*sin(2.*hash3(id.zxy*99.)*iTime);\n    \n    \n    return vec2(sphere(p-offset, 0.01), 1. + hash(id));\n}\n\nfloat obj(in vec3 p) {\n\tvec3 offset = 0.04 * vec3(\n    \tsin(iTime*10.3+sin(iTime*10.9)),\n    \tsin(iTime*12.1+sin(iTime*12.1)),\n        sin(iTime*13.2+sin(iTime*13.4))\n    );\n    offset.y += Y-0.8;\n\n    p = rotate(p - offset, iTime*vec3(2.4, 2.2, 2.3));\n\n    float d = 1e5;\n    for (int i=0;i<3;i++) {\n    \tp = abs(p) - 0.1;\n        p = rotate(p, vec3(0.1*PI, 0.25*PI, iTime*3.));\n        d = min(d, box(p, vec3(0.03, 0.01, 0.3)));\n    }\n    \n    return d;\n}\n\nvec2 opU(in vec2 d1, in vec2 d2) { return d1.x<d2.x ? d1 : d2; }\n\nvec2 map(in vec3 p) {\n    vec2 d = vec2(obj(p), 1.);\n    d = opU(d, vec2(arch(p), 0.));\n    d = opU(d, particle(p));\n    return d;\n}\n\n/*\n\tcastRay\n\treturn vec2(\n\t\tt: ray length,\n\t\tc: object id\n\t)\n*/\nvec2 castRay(in vec3 ro, in vec3 rd, in vec2 tmm) {\n\tfloat t = tmm.x;\n    float c = -1.;\n    for(int i=0;i<200;i++) {\n    \tvec2 o = map(ro + rd*t);\n        if (o.x<5e-4 || tmm.y<t) {\n        \tbreak;\n        }\n        t += o.x * 0.7;\n        c = o.y;\n    }\n    if (tmm.y < t) {\n        t = -1.;\n        c = -1.;\n    }\n    return vec2(t, c);\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1., -1.) * 1e-4;\n\treturn normalize(\n    \te.xyy * map(p + e.xyy).x +\n    \te.yxy * map(p + e.yxy).x +\n    \te.yyx * map(p + e.yyx).x +\n    \te.xxx * map(p + e.xxx).x\n    );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy*2. - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    Y = -iTime*10.;\n    \n    vec3 ro = vec3(1.5*cos(iTime), Y, 1.5*sin(iTime));\n    vec3 ta = vec3(0., Y-0.75, 0.);\n    float cr = 0.5;\n    vec3 cz = normalize(ta - ro);\n    vec3 cx = normalize(cross(cz, vec3(sin(cr), cos(cr), 0.)));\n    vec3 cy = normalize(cross(cx, cz));\n    vec3 rd = normalize(mat3(cx, cy, cz) * vec3(p, 2.));\n    \n    vec2 cmm = vec2(0., 100.);\n    vec2 d = castRay(ro, rd, cmm);\n    float t=d.x, c=d.y;\n\n    vec3 col = vec3(1., 0., 0.);// error \n    if (t<0.) {\n    } else {\n        vec3 pos = ro + rd*t;\n        vec3 nor = calcNormal(pos);\n\n        // arch\n        vec2 uv = vec2(atan(pos.z, pos.x) / PI, fract(pos.y));\n        uv.x = fract(uv.x*1.);\n        uv = clamp((1.2*(uv*2.-1.)) * 0.5+0.5, 0., 1.);\n\n        vec2 st = uv * 2. - 1.;\n        float l = length(st);\n\n        float val = abs(mod(pos.y*0.04, 2.)-1.);\n\n        col = vec3(1.);\n        float w = 0.01;\n        col = mix(col, 1.-col, SS(0.5-w, 0.5+w, val));\n        \n        // obj\n        if (c==1.) {\n            col = 1.-col;\n            vec3 ld = normalize(vec3(1.));\n            col *= clamp(dot(ld, nor), 0.02, 1.);\n        } else if (1.<c) {\n            col = 1. - col;\n            col *= c-1.;\n        }\n        \n    }\n    \n    \n    col *= 1.-pow(1.-clamp(2.-length(p)*0.8, 0., 1.), 2.);\n    col = pow(col, vec3(0.4545));\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}