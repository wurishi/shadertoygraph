{"ver":"0.1","info":{"id":"dt2BW1","date":"1694009746","viewed":46,"name":"cubic surface","username":"Efim","description":"https://mathcurve.com/surfaces.gb/cubic/cubic.shtml\n\nin this shader using analytic  solving cubic equation from https://www.shadertoy.com/view/4lsfzj","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","intersection","cubic","analyticall"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define TAU 6.283185\nmat3 rotateX(float f)\n{\n    return mat3(\n    vec3(1.0,    0.0,      0.0),\n    vec3(0.0,\t cos(f),  -sin(f)), \t\n\tvec3(.0, sin(f), cos(f))\n    );\n}\n\n\nmat3 rotateZ(float f)\n{\n    return mat3(\n    vec3(cos(f),    -sin(f),  0.0),\n    vec3(sin(f),\t cos(f),  0.0), \t\n\tvec3(0.0, 0.0, 1.0)\n    );\n    \n}\n\n\nmat3 rotateY(float f)\n{\n    return mat3(\n    vec3(cos(f), 0.0,  sin(f)),\n    vec3(0.0,\t 1.0,  0.0), \t\n\tvec3(-sin(f), 0.0, cos(f))\n    );\n}\n\n\nstruct HIT\n{\n    float dist;\n    vec3 nor;\n    vec3 pos;\n};\n\nfloat aafi(vec2 p)\n{\n    float l = length(p);\n    float fi = asin(abs(p.y)/l);\n    float pst = step(0.0, p.y)*step(p.x, 0.0);\n    fi = fi + pst*(PI - 2.0*fi);\n    pst = step(p.y, 0.0)*step(p.x, 0.0);\n    fi = fi + pst*PI;\n    pst = step(p.y, 0.0)*step(0.0, p.x);\n    fi = fi + pst*(2.0*PI - 2.0*fi);\n    return fi;    \n}\n\n//converts a vector on a sphere to longitude and latitude\nvec2 lonlat (vec3 p)\n{\n    float lon = aafi(p.xy)/2.0/PI;\n    float lat = aafi(vec2(p.z, length(p.xy)))/PI;\n    return vec2(1.0-lon, lat);\n}\n\nconst float dist_infin = 100000.0;\nconst HIT hit_inf = HIT(100000.0, vec3(0.0), vec3(0.0));\n\n/*\nvec3 calcSkyReflect(vec3 rd, vec3 nor, mat3 sky)\n{\n    vec3 n = nor;\n    float d = dot(rd, nor);\n    n = nor*sign(d);\n    vec3 r = reflect(rd, n);\n    vec2 fon = lonlat(sky*r); //get longitude and latitude\n    vec3 col = texture(iChannel0, fon).rgb;\n    return col;\n\n}\n*/\nvec3 culccolor(vec3 col_in, vec3 backcol, vec3 rd, vec3 light1, vec3 light2, vec3 nor)\n{\n    vec3 col = col_in;\n    float d = dot(rd, nor);\n    if (d < 0.0)\n        col = backcol;\n    \n    nor *= -sign(d);\n    float difu1 = dot(nor, light1);\n    float difu2 = dot(nor, light2);\n    float difu = max(difu1, difu2);\n        col *= clamp(difu, 0.3, 1.0);\n    return col;   \n}\n\n/// https://www.shadertoy.com/view/4lsfzj\nint quadratic(float A, float B, float C, out vec3 x) {\n   float D = B*B - 4.0*A*C;\n   if (D < 0.0) return 0;\n   D = sqrt(D);\n   if (B < 0.0) D = -D;\n   x[0] = (-B-D)/(2.0*A);\n   x[1] = C/(A*x[0]);\n   return 2;\n}\n\n// Numerical Recipes algorithm for solving cubic equation\nint cubic0(float a, float b, float c, float d, out vec3 x) {\n  if (a == 0.0) return quadratic(b,c,d,x);\n  //if (d == 0.0) return quadratic(a,b,c,x); // Need 0 too.\n  float tmp = a; a = b/tmp; b = c/tmp; c = d/tmp;\n  // solve x^3 + ax^2 + bx + c = 0\n  float Q = (a*a-3.0*b)/9.0;\n  float R = (2.0*a*a*a - 9.0*a*b + 27.0*c)/54.0;\n  float R2 = R*R, Q3 = Q*Q*Q;\n  if (R2 < Q3) {\n    float X = clamp(R/sqrt(Q3),-1.0,1.0);\n    float theta = acos(X);\n    float S = sqrt(Q); // Q must be positive since 0 <= R2 < Q3\n    x[0] = -2.0*S*cos(theta/3.0) - a/3.0;\n    x[1] = -2.0*S*cos((theta+2.0*PI)/3.0) - a/3.0;\n    x[2] = -2.0*S*cos((theta+4.0*PI)/3.0) - a/3.0;\n    return 3;\n  } else {\n    float A = -sign(R)*pow(abs(R)+sqrt(R2-Q3),0.3333);\n    float B = A == 0.0 ? 0.0 : Q/A;\n    x[0] = (A+B) - a/3.0;\n    return 1;\n  }\n}\n\nint cubic(float A, float B, float C, float D, out vec3 x) {\n  int nroots;\n  // Some ill-conditioned coeffs can cause problems\n  // The worst is fixed by solving for reciprocal\n  if (abs(A) > abs(D)) {\n    nroots = cubic0(A,B,C,D,x);\n  } else {\n    nroots = cubic0(D,C,B,A,x);\n    for (int i = 0; i < 3; i++) {\n      x[i] = 1.0/x[i];\n    }\n  }\n  return nroots;\n}\n/// https://www.shadertoy.com/view/4lsfzj\n\n\nHIT giper3D(vec3 ro, vec3 rd, float t, float r)\n{\n    float a = ro.x;\n    float b = rd.x;\n    float c = ro.y;\n    float d = rd.y;\n    float e = ro.z;\n    float f = rd.z;\n\n    float a0 =  + 1.*e*e*e-1.*e*t*t-1.*a*a*a + 3.*a*c*c;\n    float a1 =  + 3.*e*e*f-1.*f*t*t-3.*a*a*b + 6.*a*c*d + 3.*b*c*c;\n    float a2 =  + 3.*e*f*f-3.*a*b*b + 3.*a*d*d + 6.*b*c*d;\n    float a3 =  + 1.*f*f*f-1.*b*b*b + 3.*b*d*d;\n\n    vec3 roots = vec3(dist_infin);\n    int nroots = cubic(a3, a2, a1, a0, roots);\n    \n    \n    float dist = dist_infin;\n    vec3 pos = vec3(0.0);\n    vec3 nor = vec3(0.0);\n    for (int i = 0; i < 3; i++)\n    {\n        if (i >= nroots)\n            break;\n        if (roots[i] < 0.0)\n            continue;\n        vec3 p = ro + roots[i]*rd;\n        if (length(p) > r)    \n            continue;\n        if (roots[i] < dist)    \n        {\n            dist = roots[i];\n            pos = p;\n        }\n\n    }\n    if (dist < dist_infin)\n    {\n        // -3x^2 + 3y^2, 6yx, 3z^2 - t^2\n        nor = vec3(-3.0*pos.x*pos.x + 3.0*pos.y*pos.y, 6.0*pos.x*pos.y, 3.0*pos.z*pos.z - t*t);\n        nor = normalize(nor);\n    }\n    return HIT(dist, nor, pos);\n    \n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 light = normalize(vec3(0.0, 0.0, -1.0)); //light\n    vec3 light2 = normalize(vec3(0.0, 0.0, 1.0)); //light\n\n    float ra = 2.5;\n    float g = 1.0;\n\n    float t = iTime/2.0;\n    vec2 m = vec2(0.0, 0.0);\n    if  (iMouse.z > 0.0)\n    {\n        m = (-iResolution.xy + 2.0*(iMouse.xy))/iResolution.y;\n        t = 0.;\n    }\n    vec3 ro = vec3(0.0, 0.0, 5.0); // camera\n    ro = rotateY(-m.x*TAU)*rotateX(-m.y*PI)*ro; //camera rotation\n    \n    \n    const float fl = 1.5; // focal length\n    float dist = dist_infin;\n    mat3 rota  = rotateZ(t)*rotateY(-t);\n    mat3 rota_1  = rotateY(t)*rotateZ(-t);\n    mat3 sky = rotateZ(0.0)*rotateX(PI/2.0);\n    \n    vec2 torus = vec2(1.0,0.3);\n    vec3 tot = vec3(0.0);\n    \n    #define AA 2\n    //antiblick\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        vec3 col = vec3(0.7, 0.7, 0.9); // background        \n            // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        //vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n        //vec3 rd = normalize( vec3(p,fl) ); // ray direction\n        vec3 rd = GetRayDir(p, ro, vec3(0,0.,0), fl); //ray direction\n        HIT giper = giper3D(rota*ro, rota*rd, g, ra);\n        if (giper.dist < dist)\n        {\n            col = vec3(0.5, 0.5, 1.0);\n            vec3 backcol = vec3(1.0, 0.2, 0.2);\n            vec3 nor = rota_1*giper.nor;\n            col = culccolor(col, backcol, -rd, light, light2, nor);\n            // gamma\n            //col = pow( col, vec3(0.4545) ); \n            //reflect\n            //col = calcSkyReflect(-rd, nor, sky);\n        }\n        tot += col;\n    }\n    //antiblick\n    tot /= float(AA*AA);\n    fragColor = vec4(tot,1.0);\n    \n}","name":"Image","description":"","type":"image"}]}