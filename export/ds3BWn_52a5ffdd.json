{"ver":"0.1","info":{"id":"ds3BWn","date":"1697096299","viewed":26,"name":"gem container thing","username":"ChthonicF4","description":"messing around with sdf shaped in 3d","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// scene\n\n    //shapes from https://iquilezles.org/articles/distfunctions/\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3  ba = b - a;\n    vec3  pa = p - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    \n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    \n    return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec3 colLerp(in vec3 a , in vec3 b , in float t){\n\n    return b*t + a*(1.-t) ; \n    \n}\n\nvec4 map (in vec3 pos) {  \n    \n    float sphere = sdSphere(pos,.25);\n    \n    float cube = sdBox(pos,vec3(.2,.2,.2)) ;\n    \n    float cubything = max(sphere,cube) ;\n    \n    float cylinderX = sdCylinder(pos,vec3(.3,.0,.0),vec3(-.3,.0,.0),.13);\n    float cylinderY = sdCylinder(pos,vec3(.0,.3,.0),vec3(.0,-.3,.0),.13);\n    float cylinderZ = sdCylinder(pos,vec3(.0,.0,.3),vec3(.0,.0,-.3),.13);\n    \n    float cylinders = min(cylinderX,min(cylinderY,cylinderZ)) ;\n    \n    cubything = max(cubything,-cylinders) ;\n    \n    float an = 0.5*(iTime-10.0);\n    \n    vec3 posO = pos * mat3(cos(an*2.),0.,sin(an*2.),\n                             0.,       1.,    0.,\n                           -sin(an*2.),0.,cos(an*2.));\n                           \n    posO -= vec3(0.,sin(iTime)*.04,0.);\n    \n    float octo = sdOctahedron(posO,.15);\n    \n    vec3 col = vec3(1.) ;\n    \n    if (octo < cubything){\n    col = colLerp(vec3(0.078, 0.91, 0.839),vec3(1.),abs(pos.y-sin(iTime)*.04)*10.);\n    col += vec3(texture(iChannel1,vec3(pos.x, pos.y,pos.z+iTime*.05)).r*.5);\n    }\n    else {\n    col = vec3(.3);\n    col *= texture(iChannel0,vec2(pos.x+pos.z, pos.y+pos.z)).rgb*.7;\n    }\n    \n    return vec4(col,min(cubything,octo)) ;\n\n}\n\nconst float MaxDist = 5.;\n\n\nvec3 RayMarch( in vec3 pos , in vec3 direction) {\n    \n    // ray march settings\n    float t = map(pos).w ;\n    float h = 0. ; \n    float an = 0.5*(iTime-10.0);\n    for (int i=0;i<256;++i) {\n        // get new position\n        pos = pos + t*direction ;\n        // get closest distance \n        h = map(pos).w ; \n        // check if hit somthing or have gone too far\n        if (h < 0.00001 || t > MaxDist) break;\n        // set safe move distance to h\n        t = h ;        \n    }\n    // return the position at the end of the ray marching\n    return pos ;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ).w + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ).w + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ).w + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ).w );\n}\n\nvec3 Shading (in vec3 pos) {\n\n    if (length(pos) > MaxDist) return vec3(.1,.2,.3); \n\n    vec3 col = map(pos).xyz;\n    \n    vec3 normal = calcNormal(pos) ; \n    \n    float dif = clamp( dot(normal,vec3(0.57703)), 0.0, 1.0 ) ; \n    float amb = 0.5 + 0.5*dot(normal,vec3(0.0,1.0,0.0)) ;\n    \n    // shadows \n\n    \n    \n    \n    // combine\n        \n    col *= vec3(0.2,0.3,0.4)*amb + vec3(0.8,0.7,0.5)*dif ;\n    \n    return sqrt(col) ; \n    \n    \n\n    \n    \n} \n\n// drawing\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // convert to point \n    vec2 uv = (fragCoord*2. - iResolution.xy)/iResolution.y ; \n    \n     // camera movement\t\n     //ro => ray origin \n     //rd => ray direction \n     //an => angle (used for camera movement)\n     //ta => target point \n    float an = 0.5*(iTime-10.0);\n\tvec3 ro = vec3( .5*cos(an), 0.1, .5*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    // ray direction \n    vec3 rd = normalize( uv.x*uu + uv.y*vv + 1.5*ww );\n    \n    vec3 point = RayMarch(ro,rd) ;\n    \n    vec3 col = Shading(point) ; \n    \n    fragColor = vec4(col,1.) ;    \n}","name":"Image","description":"","type":"image"}]}