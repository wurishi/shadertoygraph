{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"/* Compiled with Shaderforth: https://github.com/daeken/Shaderforth\nimport[ noise ]\n\n:globals\n\t@vec3 uniform =iResolution\n\t@float uniform =iTime\n;\n\n:m , ;\n\n: rotationmat ( axis:vec3 angle:float -> mat4 )\n\taxis normalize =axis\n\tangle sin =s\n\tangle cos =c\n\t1 c - =>oc\n\n\t[\n\t\toc axis .x * axis .x * c +           , oc axis .x * axis .y * axis .z s * - , oc axis .z * axis .x * axis .y s * + , 0\n\t\toc axis .x * axis .y * axis .z s * + , oc axis .y * axis .y * c +           , oc axis .y * axis .z * axis .x s * - , 0\n\t\toc axis .z * axis .x * axis .y s * - , oc axis .y * axis .z * axis .x s * + , oc axis .z * axis .z * c +           , 0\n\t\t0                                    , 0                                    , 0                                    , 1\n\t]m\n;\n\n:m rotate ( p axis angle ) [ p 1 ] axis angle rotationmat * .xyz ;\n\n:m sphere ( p s ) p length s - ;\n:m torus ( p t ) [ p .xy length t .x - p .z ] length t .y - ;\n: box ( p:vec3 b:vec3 -> float )\n\tp abs b - =d\n\td \\max 0 min\n\td 0 max length +\n;\n: cyl ( p:vec3 s:vec2 -> float )\n\t( p .xz s .xx - length s .y - )\n\t\t\tp .xz length s .x -\n\t\t\tp .y neg s .y -\n\t\tmax\n\t\tp .y s .y -\n\tmax\n;\n:m plane ( p n ) p n .xyz dot n .w + ;\n\n:m union \\min ;\n:m hitunion \\{ ( $a $b ) a b a .distance b .distance < select } ;\n:m subtract \\{ ( d1 d2 ) d1 neg d2 max } ;\n:m intersect \\max ;\n:m repeat ( block p c ) p c mod 0.5 c * - *block ;\n\n:m time iTime ;\n\n:m tx ( p t ) p [ t 0 0 ] + ;\n:m ty ( p t ) p [ 0 t 0 ] + ;\n:m tz ( p t ) p [ 0 0 t ] + ;\n\n:struct hit\n\t@float =distance\n\t@float =material\n;\n\n:struct marched\n\t@float =distance\n\t@float =obj-distance\n\t@vec3 =origin\n\t@vec3 =pos\n\t@float =material\n\t@vec3 =color\n;\n\n: morph ( p:vec3 dim:vec2 v:float -> float )\n\t\tp dim .xyx box\n\t\tp dim cyl\n\t\tv\n\tmix\n;\n\n: scene ( p:vec3 -> hit )\n\t[\n\t\tp .xz iTime + snoise-2d .05 * p .y .05 + - abs\n\t\tp .x 10 * sin p .z 15 * sin + iTime 5 * +\n\t] hit\n;\n\n:struct material\n\t@vec4 =color\n\t@float =ambient\n\t@float =diffuse\n\t@float =specular\n\t@float =reflection\n\t@float =refraction\n;\n\n: get-material ( id:float -> material )\n\t[\n\t\t[ [ id 360 5 / * 1 1 ] hsv->rgb 1 ]\n\t\t.3 1 1 10 5\n\t] material\n;\n\n:m getnormal ( p )\n\t[\n\t\tp eps     tx scene .distance\n\t\tp eps neg tx scene .distance -\n\t\tp eps     ty scene .distance\n\t\tp eps neg ty scene .distance -\n\t\tp eps     tz scene .distance\n\t\tp eps neg tz scene .distance -\n\t] normalize\n;\n\niResolution frag->position =pos\n\n3 =>focus\n:m far 20 ;\n:m close 0.01 ;\n\n[ 0 0 5 ] =origin\n[ 0 0 0 ] =>ct\n\nct origin - normalize =>cd\n[ 0 0.5 0 ] =cu\ncd cu cross =>cs\ncs pos .x * cu pos .y * + cd focus * + normalize =dir\n\n[ 0 0 0 ] =c\n\n: shade ( cur:marched normal:vec3 level:float -> vec4 )\n\tcur .pos =>ray\n\n\t[ 0 1 -5 ] =>lightpos\n\t[ 1 1 1 ] =>lightcolor\n\tlightpos ray - normalize =ivec\n\tivec normal dot 0 max =incidence\n\tlightcolor incidence * =>diffuse\n\t0.1 =>ambient\n\n\tcur .material get-material =mat\n\n\t0 =specular\n\t{\n\t\tivec cur .origin + normalize normal dot\n\t\t0 max mat .specular pow\n\t\tlightpos ray - length / =specular\n\t} mat .specular 0 != incidence 0 > and when\n\n\t[ mat .color .rgb.a * diffuse mat .diffuse * ambient mat .ambient * + specular + * level mat .reflection pow * mat .reflection ]\n;\n\n: skip-bulk ( ray:vec3 dir:vec3 mat:float -> vec3 )\n\t{\n\t\tray scene =cur\n\t\tray dir cur .distance 0.05 max * + =ray\n\t\t{ break } cur .distance 0.01 > cur .material mat != or when\n\t} #100 times\n\tray\n;\n\n: march ( ray:vec3 dir:vec3 -> marched )\n\tray =origin\n\t0 =dist\n\t[ 0 0 0 ] =color\n\t1 =trans\n\t{\n\t\tray scene =cur\n\t\tdist cur .distance + far min =dist\n\t\tray dir cur .distance * + =ray\n\n\t\t{ break } dist far >= when\n\n\t\tcur .material get-material =mat\n\t\t{\n\t\t\t{ break }\n\t\t\t{\n\t\t\t\tray getnormal =normal\n\t\t\t\t{\n\t\t\t\t\tdir normal reflect normalize =rdir\n\t\t\t\t\tray dir cur .distance * + =rorigin\n\t\t\t\t\trorigin dir march-one color + =color\n\t\t\t\t} mat .reflection 0 > when\n\t\t\t\t[ dist cur .distance origin ray cur .material color ] marched =>cm\n\t\t\t\tcm normal 1 shade =>shaded\n\t\t\t\tshaded .rgb trans * color + =color\n\t\t\t\tmat .color .a trans * =trans\n\t\t\t\tdir normal 1 mat .refraction / refract =dir\n\t\t\t\tray dir cur .material skip-bulk =ray\n\t\t\t\tdir normal mat .refraction refract =dir\n\t\t\t} mat .refraction 0 == if\n\t\t} cur .distance close < when\n\t} #50 times\n\t[\n\t\tdist far cur .distance close < select\n\t\tcur .distance\n\t\torigin\n\t\tray\n\t\tcur .material\n\t\tcolor\n\t] marched\n;\n\n: march-one ( ray:vec3 dir:vec3 -> vec3 )\n\tray =origin\n\t0 =dist\n\t[ 0 0 0 ] =color\n\t{\n\t\tray scene =cur\n\t\tdist cur .distance + far min =dist\n\t\tray dir cur .distance * + =ray\n\n\t\t{ break } dist far >= when\n\t\t{ break } cur .distance close < when\n\t} #10 times\n\t[\n\t\tdist far cur .distance close < select\n\t\tcur .distance\n\t\torigin\n\t\tray\n\t\tcur .material\n\t\tcolor\n\t] marched =mcur\n\t{\n\t\tray getnormal =normal\n\t\tmcur normal 0.9 shade =shaded\n\t\tshaded .rgb =color\n\t} cur .distance far < when\n\tcolor\n;\n\n#10 =>iters\n{\n\tfloat iters float / 1 swap - =level\n\n\torigin dir march =cur\n\tc cur .color + =c\n\n\t{\n\t\tcur .pos getnormal =normal\n\t\tcur normal level shade =shaded\n\t\tc shaded .rgb + =c\n\n\t\t{\n\t\t\tdir normal reflect normalize =dir\n\t\t\tcur .pos dir cur .obj-distance * + =origin\n\t\t} {\n\t\t\tbreak\n\t\t} shaded .w 0 != if\n\t} {\n\t\tbreak\n\t} cur .distance far < if\n} iters times\n\nc ->fragcolor\n*/\n\nstruct marched {\n\tfloat distance;\n\tfloat obj_distance;\n\tvec3 origin;\n\tvec3 pos;\n\tfloat material;\n\tvec3 color;\n};\nstruct material {\n\tvec4 color;\n\tfloat ambient;\n\tfloat diffuse;\n\tfloat specular;\n\tfloat reflection;\n\tfloat refraction;\n};\nstruct hit {\n\tfloat distance;\n\tfloat material;\n};\nvec3 snoise_permute(vec3 x) {\n\treturn mod((x * 34. + 1.) * x, 289.);\n}\nfloat snoise_2d(vec2 v) {\n\tvec4 C = vec4(.211324865405187, .366025403784439, -.577350269189626, .024390243902439);\n\tvec2 i = floor(dot(v, C.yy) + v);\n\tvec2 x0 = v - i + dot(i, C.xx);\n\tvec2 i1 = x0.x > x0.y ? vec2(1., 0.) : vec2(0., 1.);\n\tvec4 x12 = x0.xyxy + C.xxzz - vec4(i1, 0., 0.);\n\ti = mod(i, 289.);\n\tvec3 p = snoise_permute(snoise_permute(vec3(0., i1.y, 1.) + i.y) + i.x + vec3(0., i1.x, 1.));\n\tvec3 m = max(.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.);\n\tm = m * m * m * m;\n\tvec3 x = 2. * fract(p * C.www) - 1.;\n\tvec3 h = abs(x) - .5;\n\tvec3 ox = floor(x + .5);\n\tvec3 a0 = x - ox;\n\tm = (1.79284291400159 - .85373472095314 * (a0 * a0 + h * h)) * m;\n\treturn dot(m, vec3(a0.x * x0.x + h.x * x0.y, a0.yz * x12.xz + h.yz * x12.yw)) * 130.;\n}\nhit scene(vec3 p) {\n\treturn hit(abs(snoise_2d(p.xz + iTime) * .05 - (p.y + .05)), sin(p.x * 10.) + sin(p.z * 15.) + iTime * 5.);\n}\nvec3 skip_bulk(vec3 ray, vec3 dir, float mat) {\n\tray;\n\tfor(int temp_16 = 0; temp_16 < 100; ++temp_16) {\n\t\thit cur = scene(ray);\n\t\tray = ray + dir * max(cur.distance, .05);\n\t\tif(cur.distance > .01 || cur.material != mat) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ray;\n}\nvec3 hsv_rgb(vec3 hsv) {\n\treturn mix(vec3(1., 1., 1.), clamp(abs(mod(hsv.x / 60. + vec3(0., 4., 2.), 6.) - 3.) - 1., 0., 1.), hsv.y) * hsv.z;\n}\nmaterial get_material(float id) {\n\treturn material(vec4(hsv_rgb(vec3(id * 72., 1., 1.)), 1.), .3, 1., 1., 10., 5.);\n}\nvec4 shade(marched cur, vec3 normal, float level) {\n\tfloat specular;\n\tvec3 ivec = normalize(vec3(0., 1., -5.) - cur.pos);\n\tfloat incidence = max(dot(ivec, normal), 0.);\n\tmaterial mat = get_material(cur.material);\n\tspecular = 0.;\n\tif(mat.specular != 0. && incidence > 0.) {\n\t\tspecular = pow(max(dot(normalize(ivec + cur.origin), normal), 0.), mat.specular) / length(vec3(0., 1., -5.) - cur.pos);\n\t}\n\treturn vec4(mat.color.rgb * mat.color.a * (vec3(1., 1., 1.) * incidence * mat.diffuse + .1 * mat.ambient + specular) * pow(level, mat.reflection), mat.reflection);\n}\nvec3 march_one(vec3 ray, vec3 dir) {\n\thit cur;\n\tfloat dist;\n\tray;\n\tvec3 color;\n\tvec3 origin = ray;\n\tdist = 0.;\n\tcolor = vec3(0., 0., 0.);\n\tfor(int temp_7 = 0; temp_7 < 10; ++temp_7) {\n\t\tcur = scene(ray);\n\t\tdist = min(dist + cur.distance, 20.);\n\t\tray = ray + dir * cur.distance;\n\t\tif(dist >= 20.) {\n\t\t\tbreak;\n\t\t}\n\t\tif(cur.distance < .01) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tmarched mcur = marched(cur.distance < .01 ? dist : 20., cur.distance, origin, ray, cur.material, color);\n\tif(cur.distance < 20.) {\n\t\tvec3 normal = normalize(vec3(scene(ray + vec3(.00001, 0., 0.)).distance - scene(ray + vec3(-.00001, 0., 0.)).distance, scene(ray + vec3(0., .00001, 0.)).distance - scene(ray + vec3(0., -.00001, 0.)).distance, scene(ray + vec3(0., 0., .00001)).distance - scene(ray + vec3(0., 0., -.00001)).distance));\n\t\tvec4 shaded = shade(mcur, normal, .9);\n\t\tcolor = shaded.rgb;\n\t}\n\treturn color;\n}\nmarched march(vec3 ray, vec3 dir) {\n\tvec3 color;\n\thit cur;\n\tfloat dist;\n\tray;\n\tvec3 origin = ray;\n\tdist = 0.;\n\tcolor = vec3(0., 0., 0.);\n\tfloat trans = 1.;\n\tfor(int temp_9 = 0; temp_9 < 50; ++temp_9) {\n\t\tcur = scene(ray);\n\t\tdist = min(dist + cur.distance, 20.);\n\t\tray = ray + dir * cur.distance;\n\t\tif(dist >= 20.) {\n\t\t\tbreak;\n\t\t}\n\t\tmaterial mat = get_material(cur.material);\n\t\tif(cur.distance < .01) {\n\t\t\tif(mat.refraction == 0.) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tvec3 normal = normalize(vec3(scene(ray + vec3(.00001, 0., 0.)).distance - scene(ray + vec3(-.00001, 0., 0.)).distance, scene(ray + vec3(0., .00001, 0.)).distance - scene(ray + vec3(0., -.00001, 0.)).distance, scene(ray + vec3(0., 0., .00001)).distance - scene(ray + vec3(0., 0., -.00001)).distance));\n\t\t\t\tif(mat.reflection > 0.) {\n\t\t\t\t\tvec3 rdir = normalize(reflect(dir, normal));\n\t\t\t\t\tvec3 rorigin = ray + dir * cur.distance;\n\t\t\t\t\tcolor = march_one(rorigin, dir) + color;\n\t\t\t\t}\n\t\t\t\tcolor = shade(marched(dist, cur.distance, origin, ray, cur.material, color), normal, 1.).rgb * trans + color;\n\t\t\t\ttrans = mat.color.a * trans;\n\t\t\t\tdir = refract(dir, normal, 1. / mat.refraction);\n\t\t\t\tray = skip_bulk(ray, dir, cur.material);\n\t\t\t\tdir = refract(dir, normal, mat.refraction);\n\t\t\t}\n\t\t}\n\t}\n\treturn marched(cur.distance < .01 ? dist : 20., cur.distance, origin, ray, cur.material, color);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec3 c;\n\tvec2 pos = (fragCoord.xy / iResolution.xy * 2. - 1.) * vec2(iResolution.x / iResolution.y, 1.);\n\tvec3 origin = vec3(0., 0., 5.);\n\tvec3 cu = vec3(0., .5, 0.);\n\tvec3 dir = normalize(cross(normalize(vec3(0., 0., 0.) - origin), cu) * pos.x + cu * pos.y + normalize(vec3(0., 0., 0.) - origin) * 3.);\n\tc = vec3(0., 0., 0.);\n\tfor(int temp_8 = 0; temp_8 < 10; ++temp_8) {\n\t\tfloat level = 1. - float(temp_8) / 10.;\n\t\tmarched cur = march(origin, dir);\n\t\tc = c + cur.color;\n\t\tif(cur.distance < 20.) {\n\t\t\tvec3 normal = normalize(vec3(scene(cur.pos + vec3(.00001, 0., 0.)).distance - scene(cur.pos + vec3(-.00001, 0., 0.)).distance, scene(cur.pos + vec3(0., .00001, 0.)).distance - scene(cur.pos + vec3(0., -.00001, 0.)).distance, scene(cur.pos + vec3(0., 0., .00001)).distance - scene(cur.pos + vec3(0., 0., -.00001)).distance));\n\t\t\tvec4 shaded = shade(cur, normal, level);\n\t\t\tc = c + shaded.rgb;\n\t\t\tif(shaded.w != 0.) {\n\t\t\t\tdir = normalize(reflect(dir, normal));\n\t\t\t\torigin = cur.pos + dir * cur.obj_distance;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\tfragColor = vec4(c, 1.);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ltfGRN","date":"1419117612","viewed":256,"name":"Oilspill","username":"daeken","description":"Just messing around with raymarching refractive terrain.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","shaderforth"],"hasliked":0,"parentid":"","parentname":""}}