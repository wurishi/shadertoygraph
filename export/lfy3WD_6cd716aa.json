{"ver":"0.1","info":{"id":"lfy3WD","date":"1714143593","viewed":72,"name":"Laplacian Waves - Two slit","username":"berelium","description":"https://beltoforion.de/en/recreational_mathematics/2d-wave-equation.php\nFull screen doesnt really work right now as it doesnt rescale, but i'll make an adjustment later to correct it.\nChange the number of emitters if you want in Buffer A!","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["2d","grid","wave","laplacian"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 wallColor = vec3(0.6);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 p = fragCoord / iResolution.y;\n    vec3 col = vec3(0);\n    \n    // Sample the wave\n    float wave  = texture(iChannel0, uv).r;\n    float awave = abs(wave);\n    //wave = (wave + 1.0) * 0.5; // Offset wave values, because some parts of the wave will be black\n    \n    // == Different ways to render the wave ==\n    //col += wave; // Raw wave\n    //col += wave / 2.0; // Subtle wave\n    //col += wave * 2.0; // Amplified wave\n    //col += awave; // Absolute wave\n    //col += awave - wave; // Trailing wave\n    col += awave + wave * 3.0; // Darker center wave + lightened edges\n    // ====\n    \n    //col *= vec3(0.310,0.620,0.953); // Blue color\n    \n    col = mix(col, wallColor, obstacles(p));\n    \n    // == Tonemap options == \n    //col = tanh(col); // previous technique\n    col = sqrt(col); // should be brighter\n    col = pow(col, vec3(1.0 / 2.2)); // Approximate sRGB\n    // ====\n    \n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float vel = 2.0; \nfloat freq = 13.; // The higher the frequency, the more subtractive banding there is in the output\nfloat damp = 0.991; \n\nvec4 scene(sampler2D channel, vec2 uv) {\n    vec2 p = uv * vec2(iResolution.x / iResolution.y, 1.0);\n    return mix(textureLod(channel, uv, 0.), vec4(0.0, 0.0, 0.0, 1.0), obstacles(p));\n}\n\n// 3x3 kernel, derived from\n// 0  1  0\n// 1 -4  1\n// 0  1  0\n// Normalized from -1 to 1\nconst float[5] kernel = float[](\n       0.25,\n  .25, -1.0, .25,\n       0.25\n); // Note: optimized to simply be a 5 texel lookup\n\n// Relative neighbor locations from current pixel\nconst vec2[5] neighbors = vec2[5](\n                       vec2(0.0,  1.0),\n     vec2(-1.0,  0.0), vec2(0.0,  0.0), vec2(1.0,  0.0),\n                       vec2(0.0, -1.0)\n);\n// Get neighboring pixel values to the current uv position\nfloat[5] getNeighbors(sampler2D channel, vec2 uv) {\n\tvec2 px = 1.0 / iResolution.xy;\n    float[5] field;\n    for (int i = 0; i < 5; i++) {\n        vec2 r = uv + px * neighbors[i];\n        //field[i] = texture(channel, r).x;\n        field[i] = scene(channel, r).x;\n    }\n    return field;\n}\n\n// Laplacian of a 2d-grid\nfloat laplacian(float[5] samples) {\n    float sum = 0.0;\n    for (int i = 0; i < 5; i++) {\n        sum += samples[i] * kernel[i];\n    }\n    return sum;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p  = fragCoord.xy / iResolution.yy;\n    \n    if (iFrame == 0) { // Ensure the buffer is zeroed\n        fragColor = vec4(0.0,0.0,0.0,1.0);\n        return;\n    }\n\n    vec2 tex = scene(iChannel0, uv).rg;\n    float u0 = 0.0;   // Future value \n    float u1 = tex.r; // Current value\n    float u2 = tex.g; // Past value\n    \n    float[5] field = getNeighbors(iChannel0, uv);\n    \n    // Solve for u0 using the wave formula\n    u0 = vel * laplacian(field) + (2.0 * u1) - u2; \n    u0 *= damp;\n     \n     \n    // Emitters\n    float ems = 1.0, offY = (1.0 / ems), r = 0.0025;\n    if(int(ems) % 2 == 0) ems += 1.0; // Even amount of emitters will result in an asymmetrical simulation\n    \n    // Initial emitter location\n    vec2 e = vec2(0.2, offY / 2.0);\n    for(float i = 0.; i < ems; i++) {\n        if(length(p - e) < r) u0 = sin(iTime * freq); // sin(freq * float(iFrame));\n        e.y += offY;\n    }\n    \n    \n    \n     // If the mouse is pressed, calculate a small circle of waves at its position\n    if(iMouse.z > 0.5) {\n        vec2 m = iMouse.xy / iResolution.y;\n        float r = 0.2;\n        \n        if(length(p - m) < 0.005) u0 = 0.5;\n    } \n    \n    \n    fragColor = vec4(u0, u1, u2, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Credit to @Blackscreeen : https://www.shadertoy.com/view/Ndtyzl\nfloat Band(float t, float start, float end, float blur){\n    float step1 = smoothstep(start-blur, start+blur, t);\n    float step2 = smoothstep(end+blur, end-blur, t);\n     \n    return step1*step2;\n}\nfloat rectangle(vec2 uv, float left, float right, float bottom, float top){\n    float blur = 0.001;\n    float band1 = Band(uv.x, left, right, blur);\n    float band2 = Band(uv.y, bottom, top, blur);\n    \n    return band1*band2; \n}\n\nfloat circle(vec2 uv, vec2 p, float r) {\n    return smoothstep(r, r - 0.005, length(uv - p) - r);\n}\n\nfloat obstacles(vec2 p) {\n    float line  = rectangle(p, 0.85, 0.88, 0.0, 1.00);\n    float slit1 = rectangle(p, 0.85, 0.88, 0.385, 0.415);\n    float slit2 = rectangle(p, 0.85, 0.88, 0.585, 0.615);\n    \n    float wall = max(line - slit1, 0.0);\n    wall = max(wall - slit2, 0.0);\n    \n    return wall;\n    \n}","name":"Common","description":"","type":"common"}]}