{"ver":"0.1","info":{"id":"3dKGDd","date":"1613872967","viewed":179,"name":"bit fractals","username":"khlorghaal","description":" ","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["2d","fractal","bitwise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//copyright khlorghaal, most rights reserved\n\n#define SNAKE(x,y,w) (x+y*w)\n#define ANTI_SNAKE(x,y,w) ivec2 //TODO LOL (x%w+)\n\n#define CELLDIM 64\n//vector type? why the fuck not\nivec2 type(ivec2 uv){ return uv/CELLDIM; }\nbool border(ivec2 uv){\n    return \n      uv.x%CELLDIM==0\n    ||uv.y%CELLDIM==0;\n}\n\nfloat tonemap(float x){ return 1.-(1./(1.+x)); }\n\n\nvoid mainImage(out vec4 col, vec2 fg){\n    ivec2 p= ivec2(fg);\n\n    //zoom\n    int Z= 1;\n    //bool BIGSCREEN= ires.y/CELLDIM > 6*4;\n    //int Z= BIGSCREEN? 4:2;//fuck these constants\n    ///PURGED\n    //do not touch these\n    //the duck will not help you\n    //only math will help you\n    //and im not math enough right now\n    //perhaps my future self will find sufficient math to this\n    //   future self: no.\n    p= p-(p%Z);//quantize\n    p/= Z;//scale\n    //zoom test //col.rgb= vec3(p.x)/32.; return;\n\n    ivec2 T= type(p);\n    if(border(p)){\n        col= vec4(0.);\n        return;\n    }\n\n    p%= CELLDIM;//gridding\n    p= abs(p-CELLDIM/2);//symmetry\n\n    float t= mod(iTime*30.,256.);\n    t= abs(t-128.);//loop\n    int q= int(t);\n\n    float lum= 0.;\n    const bool A= true;\n    int i;\n    #define CAS(T,LAM) case T: i= LAM; break;\n    #define BIGDICKMACROITERATOR( FOOF,\\\n    I0,I1,I2,I3,I4,I5,I6,I7,I8,I9,I10,I11,I12,I13,I14)\\\n    FOOF( 0,(I0))\\\n    FOOF( 1,(I1))\\\n    FOOF( 2,(I2))\\\n    FOOF( 3,(I3))\\\n    FOOF( 4,(I4))\\\n    FOOF( 5,(I5))\\\n    FOOF( 6,(I6))\\\n    FOOF( 7,(I7))\\\n    FOOF( 8,(I8))\\\n    FOOF( 9,(I9))\\\n    FOOF(10,(I10))\\\n    FOOF(11,(I11))\\\n    FOOF(12,(I12))\\\n    FOOF(13,(I13))\\\n    FOOF(14,(I14))\n    \n    #define B(OP) p.x OP p.y\n    #define C(O,C,K) (p.x O p.y) C (p.x K p.y)\n    switch(T.x){\n        BIGDICKMACROITERATOR( CAS,\n            B(+),\n            B(-),\n            B(*),\n            B(/),\n            B(%),\n            B(&),\n            B(|),\n            B(^),\n            C(&,+,|),\n            C(&,-,|),\n            C(&,+,^),\n            C(&,-,^),\n            ((p.x%p.y)%4)*4,\n            0,0\n        )\n        default:i=i;\n    }\n        \n    #undef B\n    #define B(OP) i OP q\n    switch(T.y){\n        BIGDICKMACROITERATOR( CAS,\n            B(+),\n            B(-),\n            B(*),\n            B(/),\n            B(%),\n            B(&),\n            B(|),\n            B(^),\n            i%(q+i),\n            0,\n            0,\n            0,\n            0,\n            0,0\n        )\n        default:i=i;\n    }\n    /*\n    last time i tried this bad things happened\n    also glsl does not support macro operator ##\n    this is high power intellectual retardation\n    */\n        \n    //luminance based tonemapping\n    //coloration is applied after tonemap\n    lum= float(i);\n    lum/= 128.;\n    lum= abs(lum);\n    // 0->0 inf->1\n    //reciprocal approximate to exponential decay in terms of asytmptotes\n    lum= tonemap(lum);\n    \n    //neednt inverse srgb because tonemap\n    \n    //coloration\n    col.rgb= vec3(lum);\n    if(i<0)\n        col.rg*= 0.;\n    \n    float bigv= float(abs(i));\n    col.g+= tonemap(bigv/float(0x400))*1.;//big=>green\n    \n    col= sqrt(col);\n    \n    col.a= 1.;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//Consts\n#define PI  3.14159265359\n#define TAU (PI*2.)\n#define PHI 1.61803399\n#define deg2rad 0.01745329251\n#define SQRT2 (sqrt(2.))\n#define SQRT3 (sqrt(3.))\n#define BIG 1e8\n#define ETA 1e-3\n#define eqf(a,b) ( abs((a)-(b))<ETA )\n\n//Aliases\n#define fc (gl_FragCoord.xy)\n#define res (iResolution.xy)\n#define ires ivec2(iResolution.xy)\n#define aspect (res.x/res.y)\n#define asp aspect\n#define aspinv (1./aspect)\n#define vec1 float\n#define ivec1 int\n#define uvec1 uint\n#define len length\n#define lerp mix\n#define norm normalize\n#define sat saturate\n#define sats saturate_signed\n#define smooth(x) smoothstep(0.,1.,x)\n#define time float(iTime)\n#define mouse ((iMouse.xy-res/2.)/(res*2.))\n#define mouse_ang (mouse*TAU)\n#define tex texture\n#define ass(pred,ret) if(!(pred)) return (ret);\n\n//normalized map to signed\n//[ 0,1]->[-1,1]\nvec1 nmaps(vec1 x){ return x*2.-1.; }\nvec2 nmaps(vec2 x){ return x*2.-1.; }\nvec3 nmaps(vec3 x){ return x*2.-1.; }\nvec4 nmaps(vec4 x){ return x*2.-1.; }\n//normalized map to unsigned\n//[-1,1]->[ 0,1]\nvec1 nmapu(vec1 x){ return x*.5+.5; }\nvec2 nmapu(vec2 x){ return x*.5+.5; }\nvec3 nmapu(vec3 x){ return x*.5+.5; }\nvec4 nmapu(vec4 x){ return x*.5+.5; }\n\nfloat quant(float x, float q){ return floor(x*q)/q; }\n\nfloat maxv( vec2 a){ return                 max(a.x,a.y)  ;}\nfloat maxv( vec3 a){ return         max(a.z,max(a.x,a.y)) ;}\nfloat maxv( vec4 a){ return max(a.w,max(a.z,max(a.x,a.y)));}\nfloat minv( vec2 a){ return                 min(a.x,a.y)  ;}\nfloat minv( vec3 a){ return         min(a.z,min(a.x,a.y)) ;}\nfloat minv( vec4 a){ return min(a.w,min(a.z,min(a.x,a.y)));}\n  int maxv(ivec2 a){ return                 max(a.x,a.y)  ;}\n  int maxv(ivec3 a){ return         max(a.z,max(a.x,a.y)) ;}\n  int maxv(ivec4 a){ return max(a.w,max(a.z,max(a.x,a.y)));}\n  int minv(ivec2 a){ return                 min(a.x,a.y)  ;}\n  int minv(ivec3 a){ return         min(a.z,min(a.x,a.y)) ;}\n  int minv(ivec4 a){ return min(a.w,min(a.z,min(a.x,a.y)));}","name":"Common","description":"","type":"common"}]}