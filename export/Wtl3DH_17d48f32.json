{"ver":"0.1","info":{"id":"Wtl3DH","date":"1556277629","viewed":525,"name":"raycasting illustrated","username":"stduhpf","description":"I needed something to explain visually how raytracing works, so i raytraced it.\n\nCode commented in french for some reasons.","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["raycasting","meta"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 iSphere(vec3 sp, float sr,vec3 ro, vec3 rd) //intersection entre une sphere et un rayon\n{\nvec3 p = sp-ro;\nfloat d = dot(-rd,p);\nfloat i = d*d- dot(p,p)+sr*sr;\nd = i>0.?-sqrt(i)-d:-1000.;\n    if(d<0.)\n        i=-abs(i);\nreturn vec4(normalize(rd*d-p),i>0.?d:1e6); //renvoie le vecteur normal au point d'intersection et la distance\n}\t\t\t\t\t\t\t\t\t//1e6 est un nombre tres grand\n\nfloat iPlane(vec3 ro, vec3 rd, vec3 po, vec3 pn){//intersection entre un plan et un rayon\n    float d =dot(rd,pn);\n    if(abs(d)<1e-4)\n        return -1.;\n  \treturn dot(po-ro,pn)/d;//renvoie juste la distance\n}\n\nfloat iRec(vec3 ro, vec3 rd, vec3 po, vec3 pn,vec2 dim, vec3 vert){//intersection entre un rectangle et un rayon\n    vec3 horiz = cross(pn,vert);\n\tfloat d =iPlane( ro,  rd,  po,  pn); //on calcule l'intersection avec le plan contenant le rectangle\n    if(d>0.){\n    \tvec3 p = ro+d*rd-po;\n    \tif(abs(dot(p,horiz))>dim.x || abs(dot(p,vert))>dim.y) //on verifie si on est effectivement a l'interieur du rectangle\n    \t\treturn 1e6;\n     }else\n     \treturn 1e6;\n    return d;\n}\n\nvec2 rli(vec3 o1, vec3 d1, vec3 o2, vec3 d2){ //intersection entre deux rayons(demi-droites)\n\tvec3 n = normalize(cross(d1,d2));\n    float md = dot(o1-o2,n);\n    o1 = o1-md*n;\t\t\t\t\t//o1 projeté dans le plan passant par o2\n    vec3 dt = normalize(cross(d1,n)); //\"transposée\" de d1 dans le plan induit par d1,d2 \n    float d = (dot(dt,o1))/dot(dt,d2);\n    return vec2(abs(md)*d,abs(md)<d && dot(cross(d2,n),o1)>0.?d:1e6); //renvoie la distance minimale entre les deux rayons ainsi que la distance parcourue par le deuxieme rayon avant ce point\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.*fragCoord-iResolution.xy;\n    \n    float vFov = radians(70.); // champ de vision de la camera \"virtuelle\"\n    float Fov = radians(67.38);  // champ de vision de la camera principale\n    \n    float vdcam =  1./tan(0.5*vFov);\n    float dcam =  1./tan(0.5*Fov); // a peu pres 1.5 avec le Fov par défaut\n    \n    vec3 ro = vec3(0,0,0);\t\t\t\t\t\t\t//origine des rayons = position de la \"camera\"\n    vec3 rd = normalize(vec3(uv,iResolution.y*dcam));//direction du rayon\n\n\n\t\n    vec3 ld = normalize(vec3(1,1,-1));//direction de la lumiere\n    vec3 c = vec3(1);  //couleur temporaire (avant gestion de la lumiere)\n    \n    \n    vec3 spp = vec3(-3,1.1,8);//position de la sphere\n    float spr = .8;//rayon de la sphere\n    \n    vec4 isph = iSphere(spp,spr,ro,rd);//sphere\n    vec3 n = isph.rgb;\n    float d = isph.a;//distance a l'objet le plus proche le long du rayon en cours\n \n    \n    float ipl = iPlane(ro,rd,vec3(0,-.5,0),normalize(vec3(0,1,0))); //sol\n    if(ipl<d && ipl>0.){\n        // ajout de \"bruit\" sur le vecteur normal pour donner de la texture au sol\n        n = normalize(mix(texture(iChannel1,50.*(ro+ipl*rd).xz/iChannelResolution[1].xy).rgb*2.-1.,vec3(0,1,0),.9));\n    \td=ipl;\n    }\n    \n    \n    vec3 so = vec3(1.3,.6+.2*cos(iTime*.9),4.);\t//position du centre de l'\"ecran\"\n    so.xz+=.8*vec2(cos(iTime*.4),sin(iTime*.4));//animation\n    vec3 sn = normalize(so-vec3(.35,.44,6.6));\t//orientation de l'\"ecran\"\n    vec3 ro2 = so+sn*vdcam;\t\t\t\t\t\t//position de la \"camera\" viruelle\n    vec3 vert = normalize(vec3(0,1,0));\t\t\t//orientation de la verticale de l'écran \n    vert =normalize(vert-dot(sn,vert)*sn);\t\t//correction de la verticale pour qu'elle soit orthogonale a la direction de l'ecran\n    vec2 format=vec2(1.6,.9);\t\t\t\t\t//dimension de l'ecran\n    \n    float ir = iRec(ro,rd,so,sn,format,vert); \t//\"ecran\"\n    if(ir<d && ir>0.){\n        n = sn;\n    \td=ir;\n        vec3 ro = d*rd;\n        vec3 rd2 = normalize(ro-ro2);\n        vec4 isph = iSphere(spp,spr,ro,rd2); //encore la sphere\n    \tvec3 n = isph.rgb;\n    \tfloat d = isph.a;\n \n    \n    \tfloat ipl = iPlane(ro,rd2,vec3(0,-.5,0),normalize(vec3(0,1,0)));//encore le sol\n    \tif(ipl<d && ipl>0.){\n        n = normalize(mix(texture(iChannel1,50.*(ro+ipl*rd2).xz/iChannelResolution[1].xy).rgb*2.-1.,vec3(0,1,0),.9));\n    \t\td=ipl;\n    \t}\n        float l =(iSphere(spp,spr,ro+d*rd2,ld).a>=1e6?max(0.,dot(ld,n)):0.);//lumiere directe\n    \t//c = mix(vec3(.4+l),vec3(.5,.7,1.),float(d>1e5));//affichage de la scene sur l'\"ecran\" secondaire\n        c = mix(vec3(.4+l),pow(texture(iChannel0,rd2).rgb,vec3(2.4)),float(d>1e5));//affichage de la scene sur l'\"ecran\" secondaire\n    }\n    \n\n    \n    vec4 io =iSphere(ro2,.03,ro,rd); //camera (bille noire)\n    if(io.a<d){\n        n = io.rgb;\n    \td=io.a;\n        c = vec3(.1);\n    }\n   \n    \n    vec3 p =ro+(d-1e-5)*rd;\n    float sh = min(iSphere(spp,spr,p,ld).a,min( iRec(p,ld,so,sn,format,vert),iSphere(so+sn*vdcam,.03,p,ld).a));\n    float l =(sh>=1e6?max(0.,dot(ld,n)):0.);//limiere directe\n    \n    vec3 col =  mix(c*vec3(.4+l),pow(texture(iChannel0,rd).rgb,vec3(2.4)),float(d>1e5));//application de l'eclairage \n\n    \n   \tfloat epsilon = 2./(iResolution.y*dcam);//antialiasing\n\n    vec2 itsc=(rli(ro2,normalize(ro2-spp-vec3(3,1,0)),ro,rd)); // le rayon qui n'intersecte pas la scène\n    if(itsc.y<d && itsc.y>0.){\n        col=mix(col,vec3(1,0,0),smoothstep(.05+epsilon*itsc.y*itsc.y,.05,itsc.x));\n        d=mix(d,itsc.y,step(itsc.x,.06));\n    }\n\n    itsc=(rli(ro2,normalize(ro2-spp+.3),ro,rd));//le rayon qui intersecte la sphère\n    if(itsc.y<d && itsc.y>0.){\n        col=mix(col,vec3(0,1,0),smoothstep(.05+epsilon*itsc.y*itsc.y,.05,itsc.x));\n        d=mix(d,itsc.y,step(itsc.x,.06));\n    }\n\n    vec3 horiz = cross(sn,vert);\t//et les quatre coins\n    itsc=(rli(ro2,normalize(ro2-so+format.x*horiz+format.y*vert),ro,rd));\n    if(itsc.y<d && itsc.y>0.){\n        col=mix(col,vec3(.4,.45,1),smoothstep(.05+epsilon*itsc.y*itsc.y,.05,itsc.x));\n        d=mix(d,itsc.y,step(itsc.x,.06));\n    }\n    itsc=(rli(ro2,normalize(ro2-so-format.x*horiz+format.y*vert),ro,rd));\n    if(itsc.y<d && itsc.y>0.){\n        col=mix(col,vec3(.4,.45,1),smoothstep(.05+epsilon*itsc.y*itsc.y,.05,itsc.x));\n        d=mix(d,itsc.y,step(itsc.x,.06));\n    }\n    itsc=(rli(ro2,normalize(ro2-so+format.x*horiz-format.y*vert),ro,rd));\n    if(itsc.y<d && itsc.y>0.){\n        col=mix(col,vec3(.4,.45,1),smoothstep(.05+epsilon*itsc.y*itsc.y,.05,itsc.x));\n        d=mix(d,itsc.y,step(itsc.x,.06));\n    }\n    itsc=(rli(ro2,normalize(ro2-so-format.x*horiz-format.y*vert),ro,rd));\n    if(itsc.y<d && itsc.y>0.){\n        col=mix(col,vec3(.4,.45,1),smoothstep(.05+epsilon*itsc.y*itsc.y,.05,itsc.x));\n        d=mix(d,itsc.y,step(itsc.x,.06));\n    }\n    \n    \n    col = pow(col*.6,vec3(1./2.24));//correction gamma\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}