{"ver":"0.1","info":{"id":"XltyW2","date":"1553028028","viewed":145,"name":"restart march","username":"turnage","description":"march restarter","likes":2,"published":1,"flags":1,"usePreview":0,"tags":["rest"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n\n#define STEP 0.3\n\n#define THRESHOLD 0.1\n#define MAX_STEPS 300\n#define EPSILON 0.01\n#define LIGHTS 1\n#define TWO_PI 6.28318530718\n#define NO_DISTANCE 100000.\n#define PENUMBRA 4.\n#define MAX_DIST 4000.\n\nvec3 random3(vec3 st)\n{\n    st = vec3( dot(st,vec3(127.1,311.7,211.2)/20.),\n            \tdot(st,vec3(269.5,183.3, 157.1)), dot(st,vec3(269.5,183.3, 17.1))  );\n   \treturn -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\nfloat noise3D(vec3 st) \n{\n\tvec3 i = floor(st) ;\n  \tvec3 f = fract(st);\n\t\t\n    vec3 u = smoothstep(0.,1.,f);\n    \n\tfloat valueNowxy01 =mix( mix( dot( random3(i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ),\n                    \t\t \t dot( random3(i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                \t\tmix( dot( random3(i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ),\n                     \t\t \t dot( random3(i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y);\n\tfloat valueNowxy02 =mix( mix( dot( random3(i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ),\n                    \t\t \t dot( random3(i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                \t\tmix( dot( random3(i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ),\n                     \t\t \t dot( random3(i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y);\n\n    float toReturn = abs(mix(valueNowxy01, valueNowxy02, u.z));\n    return pow(.2, toReturn) -0.4;;\n\n}\n\n    \nstruct Material {\n    vec3 color;\n    float specular;\n    float shininess;\n    float diffuse;\n};\n\nstruct Matter {\n    float exists;\n    float brush;\n    vec3 pos;\n    vec3 normal;\n    Material material;\n};\n      \nstruct SDFResult {\n\tfloat dist;\n    Material material;\n};\n    \nstruct Light {\n    vec3 pos;\n\tfloat specular;\n    float diffuse;\n};\n \nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat cylinders(vec3 p)\n{\n    float c = 2000.;\n    vec3 q = mod(p,c)-0.5*c;\n    return 1./0.;//sdCappedCylinder(q, vec2(200., 10000.));\n}\n    \nfloat rollingHills(in vec3 pos)\n{\n        return length(heightMap(abs(pos.xz)/5000.))*12.2+sin(pos.x/5.)*8.+sin(pos.z/100.)*20.+noise3D(vec3(pos.xz/700., iTime*0.1))*300.;\n}\n\nSDFResult unionOf(in SDFResult r1, in SDFResult r2)\n{\n    if (r1.dist < r2.dist)\n        return r1;\n   \treturn r2;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nSDFResult scene(in vec3 pos)\n{\n    SDFResult r;\n    float hillDist = pos.y - rollingHills(pos);\n    float cylDist = cylinders(pos);\n    r.dist = min(hillDist, cylDist);\n    vec3 cylcol = heightMap(abs(pos.xz)/5000.).xzy;\n    cylcol.y = cylcol.z < 0.9 ? cylcol.y * 0.6 : cylcol.y * 0.4;\n    cylcol.x = cylcol.z < 0.9 ? cylcol.x * 0.6 : cylcol.x * 0.4;\n    cylcol.z = 1.;\n    r.material.color = hillDist < cylDist ? cylcol : vec3(1.);\n    r.material.specular = 1.0;\n    r.material.shininess = 1.8;\n    r.material.diffuse = 0.1;\n    return r;\n}\n\nfloat sceneDist(in vec3 pos) {\n\treturn scene(pos).dist;\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneDist(vec3(p.x + EPSILON, p.y, p.z)) - sceneDist(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneDist(vec3(p.x, p.y + EPSILON, p.z)) - sceneDist(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneDist(vec3(p.x, p.y, p.z  + EPSILON)) - sceneDist(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nMatter march(in vec3 origin, in vec3 ray, in float maxDist, in vec3 brushRef)\n{\n    Matter matter;\n    matter.exists = 0.;\n    matter.brush = 1.0;\n    \n    float traveled = 0.;\n    int steps = 0;\n    float oldTraveled = 0.;\n    float oldY = 0.;\n    float oldTh = 0.;\n    float dt = 0.;\n    while (steps < MAX_STEPS && traveled < maxDist) {\n    \tvec3 marchPoint = origin + ray * traveled;\n        SDFResult result = scene(marchPoint);\n\t\tmatter.brush = min(matter.brush, PENUMBRA*result.dist/(distance(brushRef, marchPoint)));\n        if (result.dist < THRESHOLD) {\n            float th = rollingHills(marchPoint);\n            float oldDist = oldY - oldTh;\n            float yDiff = marchPoint.y - oldY;\n            float hDiff = th - oldTh;\n            float ft = traveled - dt + dt * (oldDist/(yDiff - hDiff));\n            matter.pos = origin + ft * ray;\n            matter.normal = estimateNormal(marchPoint);\n            matter.exists = 1.0;\n            matter.material = result.material;\n            return matter;\n        }\n        dt = STEP * result.dist;// * max(traveled*0.01, 0.1);\n        traveled += dt;\n        steps += 1;\n        oldY = marchPoint.y;\n        oldTh = rollingHills(marchPoint);\n    }\n    return matter;\n}\n\nvec3 rayDir(in float fov, in vec2 fragCoord)\n{\n    float xExpand = iResolution.x/iResolution.y;\n\n\tfloat paneWidth = tan(radians(fov)/2.)*2.;\n    float x_ = ((fragCoord.x + 0.5)/iResolution.x  - 0.5) * xExpand * (paneWidth/2.);\n    float y_ = ((fragCoord.y + 0.5)/iResolution.y - 0.5) * (paneWidth/2.);\n    return normalize(vec3(x_, y_, -1.));\n}\n\nvec3 phong(in vec3 camera, in Light lights[LIGHTS], in Matter matter) {\n    float intensity = 0.;\n    float ambient = 0.4;\n    for (int i = 0; i < LIGHTS; i++) {\n        vec3 rayToCam = normalize(camera - matter.pos);\n\t\tvec3 rayToLight = normalize(lights[i].pos - matter.pos);\n        vec3 rayFromLight = normalize(matter.pos - lights[i].pos);\n        Matter obstruction = march(lights[i].pos, rayFromLight,\n                                   distance(matter.pos, lights[i].pos) - THRESHOLD*2.,\n                                   matter.pos);\n        float shadow = obstruction.brush;\n        vec3 idealReflRay = 2. * dot(rayToLight, matter.normal) * matter.normal - rayToLight;\n        float specular = pow(abs(dot(idealReflRay, rayToCam)), matter.material.shininess)*matter.material.specular*lights[i].specular;\n        float diffuse = abs(dot(rayToLight, matter.normal))*lights[i].diffuse*matter.material.diffuse;\n        intensity += (diffuse + specular)*shadow;\n    }\n\treturn clamp(ambient + intensity, 0., 1.) * matter.material.color;\n}\n\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 camera, in vec3 dir)\n{\n    Matter matter = march(camera, dir, MAX_DIST, camera);\n    Light lights[LIGHTS];\n    lights[0].pos = vec3(400., 3000., 0.);\n    lights[0].specular = 1.0;\n    lights[0].diffuse = 0.8;\n    vec3 color = phong(camera, lights, matter);\n    vec3 horizon = vec3(.43, .42, .61);\n    vec3 ceiling = vec3(.071, .055, .31);\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 bg = mix(horizon, ceiling, uv.y);\n    vec3 fog = vec3(0.4, 0.4, 0.4);\n    vec3 final = mix(bg, color, matter.exists);\n    vec3 fogged = mix(final, fog, 1.0 - exp( -distance(matter.pos, camera)*0.0005));\n    fragColor = vec4(fogged,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float camZ = -iTime*80.;\n    vec3 camera = vec3(-9., sin(camZ/100.)*20.+240., camZ);\n    vec3 dir = rayDir(90., fragCoord);\n\tmainVR(fragColor, fragCoord, camera, dir);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265359\n\nfloat N21(vec2 p)\n{\t// Dave Hoskins - https://www.shadertoy.com/view/4djSRW\n\tvec3 p3  = fract(vec3(p.xyx) * vec3(443.897, 441.423, 437.195));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle), sin(_angle),cos(_angle));\n}\n\nfloat tri(vec2 uv){\n    vec2 id = floor(uv)*0.02;\n    float t = 0.1;\n    uv = fract(uv);\n    uv -= vec2(0.5);    \n    float angle = N21(vec2(id.x,id.y)+t*0.001);\n    angle = floor(angle*4.0)*0.5;\n    uv = rotate2d( angle* PI ) * uv;\n    uv += vec2(0.5);\n    return smoothstep(0.99,1.0,uv.x + uv.y);\n}\n\nvec4 heightMap(in vec2 uv )\n{\n   vec2 u = uv;\n   vec3 f = vec3(1);\n\n   uv *= 20.;\n   f.g =  clamp(tri(uv)+u.x, 0., 1.);\n    \n   uv*=.25;\n   f.r= clamp(tri(uv)+u.y, 0., 1.);\n    \n   uv*=.5*.5;\n   f.b = clamp(tri(uv)+u.y+uv.y, 0., 1.);\n    \n   return vec4(f,1.0);\n}","name":"Common","description":"","type":"common"}]}