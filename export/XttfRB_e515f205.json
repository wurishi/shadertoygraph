{"ver":"0.1","info":{"id":"XttfRB","date":"1540074622","viewed":139,"name":"Swirly Bits","username":"villain749","description":"Learning about domain repetition and manipulation","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","swirly","domainmanipulation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec2 REPS = vec2(3.0, 2.0);\nconst float AMP = .325;\n\nvec2 hash(vec2 vec) {\n    return fract(sin(vec2(dot(vec,vec2(622.1,311.7)),dot(vec,vec2(269.5,383.3))))*42758.5453);\n}\n\nfloat sineNoise(float x) {\n    return (sin(3.0 * x) + sin(7.0 * x) + sin(9.0 * x) + sin(13.0 * x) + sin(17.0 * x) + sin(31.0 * x)) * 0.12 + 0.5;\n}\n\n\nvec4 drawSwirlyBits(vec2 uv, float t, vec2 uv_off, float seed,  vec3 color) {\n\n    uv += uv_off;\n\n    //scale the domain\n    vec2 p = uv * REPS;\n\n    // up and down ocilation of entire domain\n    uv.y += cos((t + seed) * .99) * 0.10;\n\n    // add a wave to domain\n    p.y += sin((uv.x - t * 0.1) * 8.5) * AMP;\n    p.x += cos((uv.y + t * 0.2) * 3.5) * AMP;\n\n    // get index for each row and column\n    vec2 index = floor(p);\n\n    // repeat the domain\n    p = fract(p);\n    // range -1 to 1\n    p = p * 2.0 - 1.0;\n\n    // use atan2 to paramertize each cell with a cirle\n    float spiral = atan(p.x, p.y);\n\n    // get a random value per cell\n    float rdm = hash(index + seed).x; \n\n    // shifts the clock for each cell\n    float cell_time = t + rdm * 3.0;\n\n    // radar scan line\n    float epsilon = 2.5;\n    float cur_spot = mod(cell_time, 6.28) - 3.14;\n    float radar_line = abs(spiral - cur_spot) < epsilon ? (spiral - cur_spot) / epsilon : 0.0;\n    radar_line = clamp(radar_line, 0.0, 1.0);\n    radar_line = pow(radar_line, 3.5);\n    radar_line = clamp(radar_line, 0.0, 1.0);\n\n    // radar ring\n    float delta = 0.09 + (rdm - 0.5)  * 0.05;\n    float ring_cur = mod((-cell_time ) * (1.0 / 6.28), 1.0);\n    // test making ring wavey \n    delta += sineNoise(spiral * .34 + seed + rdm)  * 0.05;\n    // make a tadpole like profile modulating the radar line\n    float profile = 1.0 - abs(1.0 - (radar_line * 1.5));\n    // apply the profile to our delta\n    delta *= profile ;\n    float ring_gradient = length(p);\n    float radar_ring = abs(ring_gradient - ring_cur) < delta ? 0.999 : 0.0;\n\n    // get the little swimmy bits\n    float bits = clamp(min(radar_line, radar_ring), 0.0, 1.0);\n\n    // each cell is randomly more gray sinking into background\n    bits *= rdm;\n\n    // fade them smoothly into and out of existance by reshaping cur_spot\n    // put in zero to one range\n    float fade = (cur_spot + 3.1415) / 6.2831;\n    // make linear symertrical\n    fade = 1.0 - abs(1.0 - (fade * 2.0));\n    // make non-linear so we can see the bit longer\n    //fade = pow(fade, 0.45);\n    // apply fade\n    bits *= fade;\n\n    // give the bits a whitish tip, fading out at the tail\n    color = mix(color, vec3(1.0), bits) * bits;\n    \n    return vec4(color, bits);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float t = iTime;\n\tvec2 uv = (gl_FragCoord.xy / iResolution.xy);\n     // correct for image aspect...this still doesn't look right to me\n    float aspect =  iResolution.x / iResolution.y;\n    uv.x *= aspect;\n    // range -1 to 1\n    vec2 p = uv * 2.0 - 1.0;\n    // a very dark background gradient\n    vec4 bg = vec4(0.0, uv.y * 0.03, (1.0 - length(p) / 1.8) * 0.07, 0.0);\n\n    // compositing five instances of swirly bits\n    vec4 swirly1 = drawSwirlyBits(uv * 0.65, t, vec2(0.5, 9.4), 12.0, vec3(0.0, 1.0, 0.0));\n    // this one is transposed 90 degrees\n    vec2 uv_tilted = vec2(uv.y, uv.x);\n    vec4 swirly2 = drawSwirlyBits(uv_tilted, t * 1.25, vec2(33.0, 0.0), 0.1, vec3(0.4, 0.0, 1.0));\n    vec4 swirly3 = drawSwirlyBits(uv * vec2(-1.5, 1.5), t * 1.5, vec2(0.0, 2.0), 42.0, vec3(0.8, .6, .0));\n    // this one spins clockwise\n    float slow = t * 0.1;\n    mat2 rot1 = mat2(cos(-slow), sin(-slow), -sin(-slow), cos(-slow));\n    vec2 uv_rot1 = rot1 * p;\n    vec4 swirly4 = drawSwirlyBits(uv_rot1 * 0.35, t * 0.94, vec2(0.0, 2.0), 1.0, vec3(0.0, 1.0, 1.0));   \n    // this one spins counter clockwise\n    slow = slow * 1.2;\n    mat2 rot = mat2(cos(slow), sin(slow), -sin(slow), cos(slow));\n    vec2 uv_rot = rot * p;\n    vec4 swirly5 = drawSwirlyBits(uv_rot * 0.7, t * 1.1, vec2(0.0, 2.0), 71.0, vec3(1.0, 0.0, 1.0));\n    \n    // doing a z composite on all 5\n    if (swirly1.w > bg.w) {\n        bg = swirly1;\n    }\n    if (swirly2.w > bg.w) {\n        bg = swirly2;\n    }\n    if (swirly3.w > bg.w) {\n        bg = swirly3;\n    }\n    if (swirly4.w > bg.w) {\n        bg = swirly4;\n    }\n    if (swirly5.w > bg.w) {\n        bg = swirly5;\n    }\n\n    // testing subtle usage \n    //bg = vec4(0.0, 0.1, 0.25, 0.0) + bg.w * 0.045;\n\n    fragColor = vec4(bg.xyz, 1.0);\n}","name":"Image","description":"","type":"image"}]}