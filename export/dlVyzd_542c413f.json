{"ver":"0.1","info":{"id":"dlVyzd","date":"1700572382","viewed":38,"name":"toon doughnut","username":"darkfox","description":"toon doughnut.\nreference: https://qiita.com/_sayo_y/items/2b9b64b00ef5ccb31186","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","torus","toon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// constant\nconst float pi = 3.14159;\n// palette\nconst vec3 brown = vec3(0.72, 0.48, 0.34);\n\n// axis\nconst vec3 ex = vec3(1.0, 0.0, 0.0);\nconst vec3 ey = vec3(0.0, 1.0, 0.0);\nconst vec3 ez = vec3(0.0, 0.0, 1.0);\n\n// 2D rotate.\nvec2 rotate(vec2 p, float t){\n  return p * cos(t) + vec2(-p.y, p.x) * sin(t);\n}\n// x-axis rotate\nvec3 rotateX(vec3 p, float t){\n  p.yz = rotate(p.yz, t);\n  return p;\n}\n// y-axis rotate\nvec3 rotateY(vec3 p, float t){\n  p.zx = rotate(p.zx, t);\n  return p;\n}\n// z-axis rotate\nvec3 rotateZ(vec3 p, float t){\n  p.xy = rotate(p.xy, t);\n  return p;\n}\n\n// torus axis:u\nfloat freeTorus(vec3 p, vec3 u, float a, float b){\n  return sqrt(dot(p, p) + dot(a, a) - 2.0 * a * length(p - dot(p, u) * u)) - b;\n}\n\n// map. rgb:color, a:distance\nvec4 map(vec3 p){\n  vec3 color = brown;\n  vec3 e = vec3(1.0/sqrt(3.0));\n  float t = freeTorus(p, e, 1.5, 0.5);\n  return vec4(color, t);\n}\n// calculate normal vector\nvec3 calcNormal(vec3 p){\n  const vec2 eps = vec2(0.0001, 0.0);\n// F(x, y, z) = 0\n  vec3 n;\n  n.x = map(p + eps.xyy).w - map(p - eps.xyy).w;\n  n.y = map(p + eps.yxy).w - map(p - eps.yxy).w;\n  n.z = map(p + eps.yyx).w - map(p - eps.yyx).w;\n  return normalize(n);\n}\n// ray marching\nfloat march(vec3 ray, vec3 camera){\n  const float maxd = 20.0; // max distance\n  const float precis = 0.001; // precision\n  const int ITERATION = 64; // loop max count\n  float h = precis * 2.0; // estimate value\n  // if h < precis: finish.\n  float t = 0.0;\n  // t: accumulation of distance\n  // reach: return t else return -1.0\n  float result = -1.0;\n  for(int i = 0; i < ITERATION; i++){\n    if(h < precis || t > maxd){ break; }\n    // calculate estimate value and add that to t\n    h = map(camera + t * ray).w;\n    t += h;\n  }\n  // if t < maxd, reach.\n  if(t < maxd){ result = t; }\n  return result;\n}\n// camera transform\nvoid transform(out vec3 p){\n  float angleX = pi * iTime * 0.29;\n  float angleY = pi * iTime * 0.13;\n\n  p = rotateX(p, angleX);\n  p = rotateY(p, angleY);\n}\n// background color\nvec3 getBackground(vec2 p){\n  return vec3(0.9);\n}\n// main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  vec2 p = (fragCoord.xy*2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n  // set background color\n  vec3 color = getBackground(p);\n  // set ray\n  vec3 ray = normalize(vec3(p, -1.8));\n  // set eye position\n  vec3 camera = vec3(0.0, 0.0, 4.5);\n  // set directionalLight\n  vec3 light = normalize(vec3(0.5, 0.8, 3.0));\n  // rotate view\n  transform(ray);\n  transform(camera);\n  // execute ray marching\n  float t = march(ray, camera);\n  // if t > -0.001, reach.\n  if(t > -0.001){\n    vec3 pos = camera + t * ray; // surface position\n    vec3 n = calcNormal(pos); // calculate normal\n    // brightness\n    float diff = clamp((dot(n, light) + 0.5) * 0.7, 0.3, 1.0);\n    // toon effect (core)\n    diff = clamp(floor(diff * 3.0) / 3.0, 0.3, 1.0);\n    // get BodyColor\n    vec3 baseColor = map(pos).xyz;\n    baseColor *= diff;\n    if(abs(dot(ray, n)) < 0.4){ baseColor = vec3(0.0); }\n    // fadeout effect\n    color = mix(baseColor, color, tanh(t * 0.02));\n  }\n  fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}