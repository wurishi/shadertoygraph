{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","sampler":{"filter":"nearest","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":2,"type":"texture","id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"/*\nCompute distance to a (hermite) spline\nsquared distance from point D = |(P-MT)|^2 for \nquery point P\n3x4 spline matrix M\nparameter vector T = [ t^3  t^2 t 1 ]\nD is minimized where D'=0 (degree 5)\nD' roots are bracketed where D'' = 0 (degree 4)\nSo solve the quartic D''=0 to get the brackets.\nThen bisect each bracketed interval to get nearer the root and guarantee convergence.\nNewton's method to finish it off.\nKeep the closest of them all = spline parameter of closest point.\n*/\n\nvec3 hsv2rgb(vec3 c);\nvec3 rgb2hsv(vec3 c);\nvoid MakeViewRay(out vec3 eye, out vec3 ray, in vec2 fragCoord);\nvec4 Sort(vec4 n);\nint quartic_descartes(float a, float b, float c, float d, inout vec4 rts);\nfloat RaySphere(vec3 P, vec3 V, vec3 A, float r);\n\nvoid InitSpline();\nvec3 GetPosOnSpline(float t);\nvec3 SplineOrtho(float t);\nfloat FindClosestPointOnSplineToPoint( vec3 p );\n\n\nmat4 geometrymatrix;\n\n#define pi 3.1415927\n\nfloat sdf(vec3 p, out vec3 C, out float t_close)\n{\t\n\tfloat r=0.2;\n\tt_close = FindClosestPointOnSplineToPoint( p );\n\tC=GetPosOnSpline(t_close);\n\tfloat d = length(p-C)-r;\n\t\n#if 0\t\n\tvec3 b = SplineOrtho(t_close);\n\tvec3 n = normalize(p-C);\n//\tfloat v = acos(dot(b,n));\n\td += sin(10.*acos(dot(b,n)))*0.04;\n#endif\n\t\n\treturn d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewP, viewD;\n\tMakeViewRay(viewP, viewD, fragCoord);\n\n\t\n\t//sweep a plane up and down through the distance field to show distances\n\tfloat t = iTime * 0.5;\n\tfloat floor_height = -5.;//sin(t)+0.5; //(sin(t*pi+pi*1.5)+1.)*2.;\n\tfloat floor_intersect_t = (-viewP.y + floor_height) / (viewD.y);\n\n\t//query point is on this plane\t\n\tvec3 p = viewP+viewD*floor_intersect_t;\n\n\tInitSpline();\n\t\n\t//vec3 c = hsv2rgb(vec3(p.x,1.,1.));\n\t\n\tvec3 c, C; float t_close; float d;\n\tc = texture(iChannel2,p.xz*0.1).xyz;\n#if 0\t\n\td = sdf(p,C, t_close);\t\t\t\t\t\t\n\tc = hsv2rgb(vec3(d,1.,1.));\n#endif\n\t\n\tvec3 L = normalize(vec3(1,2,-1));\n\t\n\tfloat nearest_t = floor_intersect_t;\n\t\n#if 0 //draw blob running along spline\n\tvec3 C=GetPosOnSpline(mod(iTime,1.));\n\tfloat st=RaySphere(viewP, viewD, C, 0.2);\n\tif (st > 0. && st < nearest_t)\n\t{\n\t\tvec3 pS = viewP+st*viewD;\n\t\tvec3 n = normalize(pS-C);\n\t\tc = vec3(max(dot(n,L),0.));\n\t\t\n\t\tnearest_t =st;\n\t}\n#endif\n\t\n#if 0\t//draw control points\n\tfor (int i=0; i<4; i++)\n\t{\n\t\tvec3 C=vec3(geometrymatrix[0][i],geometrymatrix[1][i],geometrymatrix[2][i]);\t\t\t\n\t\tfloat st=RaySphere(viewP, viewD, C, 0.25);\n\t\tif (st > 0. && st < nearest_t)\n\t\t{\n\t\t\tnearest_t = st;\n\t\t\t\n\t\t\tvec3 pS = viewP+st*viewD;\n\t\t\tvec3 n = normalize(pS-C);\n\t\t\tc = vec3(max(dot(n,L),0.));\n\t\t\tvec3 cc = vec3(0.);\n\t\t\tif (i < 3)\n\t\t\t\tcc[i]=1.;\n\t\t\telse\n\t\t\t\tcc=vec3(1.);\n\t\t\tc *= cc;\n\t\t}\t\n\t}\n#endif\n\t\n#if 1\n\tvec3 X;\n\tt = 0.;\n\tfor (int i=0; i<64; i++)\n\t{\n\t\tX = viewP + viewD * t;\n\t\t\n\t\td = sdf(X,C,t_close);\n\t\tif ((abs(d) < 0.00001) && (t < nearest_t)) \n\t\t{\n\t\t//\tif (t < nearest_t)\n\t\t\t{\n\t\t\t\tvec3 n = normalize(X-C);\n\t\t\t//\tvec3 n = C;\n\t\t\t\t//c = vec3(n*0.5+0.5);\n\t\t\t\tc = vec3(max(dot(n,L),0.));\n#if 1\t\t\t\t\n\t\t\t\tvec3 b = SplineOrtho(t_close);\n\t\t\t\tfloat v = acos(dot(b,n));\n\t\t\t\tc *= 0.1 + pow(texture(iChannel1,vec2(t_close,v/16.)*4.).xyz,vec3(2.2));\n#endif\t\t\t\t\n\t\t\t}\n\t\t\tbreak; //near enough surface for normals to look OK.\n\t\t}\n\t\t\n\t\tt += d;\n\t\t\n\t\t//on Mac this line is a magic frame rate fix, but breaks windows.\n\t//\tif (t > nearest_t) break;\n\t}\t\t\n#endif\n\t\n\tc=pow(c,vec3(1./2.2));\n\tfragColor = vec4(c,1.0);\n}\n\n\nfloat Q(float a, float b, float c)\n{\n\tfloat d = b*b-4.0*a*c;\n\tif (d < 0.0) return -1.0;\n\td=sqrt(d);\t\n\tfloat oo2a = 0.5/a;\n\treturn min((-b-d)*oo2a,(-b+d)*oo2a);\n}\n\nfloat RaySphere(vec3 P, vec3 V, vec3 A, float r)\n{\n\treturn Q(dot(V,V),2.0*(dot(P,V)-(dot(A,V))),dot(A,A)+dot(P,P)-r*r-(2.0*(dot(A,P))));\n}\n\nvec3 RotY(vec3 p, float t) {\n\tfloat c = cos(t); float s = sin(t);\n\treturn vec3(p.x*c+p.z*s,\n\t\t\t\tp.y,\n\t\t\t\t-p.x*s+p.z*c);\n}\n\nvoid MakeViewRay(out vec3 eye, out vec3 ray, in vec2 fragCoord)\n{\n\tvec2 ooR = 1./iResolution.xy;\n    vec2 q = fragCoord.xy * ooR;\n    vec2 p =  2.*q -1.;\n    p.x *= iResolution.x * ooR.y;\n\t\n    vec3 lookAt = //vec3(-4.,-8.,0.);\n\t\t\t\t\t//vec3(0.2349,0.737,-2.49);\n\t\t\t\t\tvec3(0.);\n\tfloat t = sin(iTime*.5)*2.5;\n\teye = vec3(2.5,5.,-2.5) * 1.; // (t+2.);\n//\teye = RotY(eye,smoothstep(0.,1.,t)*-0.5*pi);\t\n\teye = RotY(eye,iTime);\n\t\n    // camera frame\n    vec3 fo = normalize(lookAt-eye);\n    vec3 ri = normalize(vec3(fo.z, 0., -fo.x ));\n    vec3 up = normalize(cross(fo,ri));\n     \n    float fov = .25;\n\t\n    ray = normalize(fo + fov*p.x*ri + fov*p.y*up);\n}\n\nstruct Spline\n{\n\t//stuff that's constant over the shape of the spline...\n\t\n\tmat4 MG;\t//4x3\n\n\t//cofficients of 2nd derivative of distance function\n\tfloat G_4, oo_G_4, G_3, G_2;\n\tvec3 G_1_p; float G_1;\n\tvec3 G_0_p; float G_0;\n\n\t//cofficients of 1st derivative of distance function\n\tfloat F_5, F_4, F_3, F_2;\n\n\tvec3 F_1_p;\n\tfloat F_1;\n\n\tvec3 F_0_p; \n\tfloat F_0;\n\n\tvec3 endpoint0;\n\tfloat quartic_a;\n\n\tfloat quartic_b;\t\n};\n\n\nvoid Initialize(inout Spline sp, mat4 geometrymatrix)\n{\t\n\t//GLSL: column major mats/accessors!\n\t\n\tmat4 Mh;\n\tMh[0] = vec4( 2, -2,  1,  1);\n\tMh[1] = vec4(-3,  3, -2, -1);\n\tMh[2] = vec4( 0,  0,  1,  0);\n\tMh[3] = vec4( 1,  0,  0,  0);\n\tsp.MG = geometrymatrix * Mh; \n\t\n\tsp.endpoint0 = geometrymatrix[0].xyz; \n\n\tfloat X_1 = geometrymatrix[0][0];\n\tfloat Y_1 = geometrymatrix[0][1];\n\tfloat Z_1 = geometrymatrix[0][2];\n\tfloat X_2 = geometrymatrix[1][0];\n\tfloat Y_2 = geometrymatrix[1][1];\n\tfloat Z_2 = geometrymatrix[1][2];\n\tfloat X_3 = geometrymatrix[2][0];\n\tfloat Y_3 = geometrymatrix[2][1];\n\tfloat Z_3 = geometrymatrix[2][2];\n\tfloat X_4 = geometrymatrix[3][0];\n\tfloat Y_4 = geometrymatrix[3][1];\n\tfloat Z_4 = geometrymatrix[3][2];\n\t\n\tfloat X_3_sq = X_3*X_3;\n\tfloat Y_3_sq = Y_3*Y_3;\n\tfloat Z_3_sq = Z_3*Z_3;\n\t\n\tfloat A_3=(2.*X_1-(2.*X_2)+X_3+X_4);\n\tfloat A_3_sq = A_3 * A_3;\n\tfloat A_2=(-(3.*X_1)+3.*X_2-(2.*X_3)-X_4);\n\tfloat A_2_sq = A_2 * A_2;\n\tfloat B_3=(2.*Y_1-(2.*Y_2)+Y_3+Y_4);\n\tfloat B_3_sq = B_3 * B_3;\n\tfloat B_2=(-(3.*Y_1)+3.*Y_2-(2.*Y_3)-Y_4);\n\tfloat B_2_sq = B_2 * B_2;\n\tfloat C_3=(2.*Z_1-(2.*Z_2)+Z_3+Z_4);\n\tfloat C_3_sq = C_3 * C_3;\n\tfloat C_2=(-(3.*Z_1)+3.*Z_2-(2.*Z_3)-Z_4);\n\tfloat C_2_sq = C_2 * C_2;\n\n\tsp.F_5 = 6.*(A_3_sq+B_3_sq+C_3_sq);\n\tsp.F_4 = 10.*(A_2*A_3+B_2*B_3+C_2*C_3);\n\tsp.F_3 = (4.*A_2_sq+4.*B_2_sq+8.*A_3*X_3+8.*B_3*Y_3+4.*C_2_sq+8.*C_3*Z_3);\n\tsp.F_2 = A_3*X_1+A_2*X_3+B_3*Y_1+B_2*Y_3+C_3*Z_1+C_2*Z_3;\n\tsp.F_1 = 2.*X_3_sq+4.*A_2*X_1+4.*B_2*Y_1+4.*C_2*Z_1+2.*Y_3_sq+2.*Z_3_sq;\n\tsp.F_0 = 2.*X_3*X_1+2.*Y_3*Y_1+2.*Z_3*Z_1;\t\t\t\t\t\t\n\tsp.F_0_p = -2.*vec3(X_3,Y_3,Z_3);\n\n\tsp.G_4 = 30.*(A_3_sq+C_3_sq+B_3_sq);\n\tsp.oo_G_4 = 1. / sp.G_4;\n\tsp.G_3 = 40.*(A_2*A_3+B_2*B_3+C_2*C_3);\n\tsp.G_2 = (24.*A_3*X_3+12.*A_2_sq+24.*B_3*Y_3+24.*C_3*Z_3+12.*B_2_sq+12.*C_2_sq);\n\tsp.G_1 = A_3*X_1+A_2*X_3+B_3*Y_1+B_2*Y_3+C_3*Z_1+C_2*Z_3;\t\t\t\t\n\tsp.G_1_p = -vec3(A_3,B_3,C_3);\n\tsp.G_0 = 4.*A_2*X_1+2.*Y_3_sq+4.*B_2*Y_1+2.*X_3_sq+2.*Z_3_sq+4.*C_2*Z_1;\t\t\n\tsp.G_0_p = -4. * vec3(A_2,B_2,C_2);\n\n\tsp.quartic_a = sp.G_3 / sp.G_4;\n\tsp.quartic_b = sp.G_2 / sp.G_4;\n}\t\t\n\nvec3 S(float t, float x)\n{\n\treturn texture(iChannel0,vec2(t,x*(1./256.0)) ).xyz*2.-1.;\n}\nSpline spline;\nvoid InitSpline()\n{\n#if 0\t\n\tvec3 endpoint0 = vec3(0.79762733,0.45774102,-2.0626645);\n\tvec3 endpoint1 = vec3(0.23499674,0.73739231,-2.4975600);\n\t\n\tvec3 tangent0 = vec3(0.64538366,5.9951859,-1.0051248);\n\tvec3 tangent1 = vec3(-0.77649212,-3.6806760,-4.8185802);\n#else\n\t//wiggly control points to test a bunch of different shapes\n\tfloat t = iTime*0.01;\n\tvec3 endpoint0 = S(t,0.);\n\tvec3 endpoint1 = S(t,1.);\n\tvec3 tangent0 = S(t,2.)*20.*sin(iTime);\n\tvec3 tangent1 = S(t,3.)*10.;\n\t\n#endif\n\n\tvec3 ave = 0.5 * (endpoint1+endpoint0);\n\tendpoint0 -= ave;\n\tendpoint1 -= ave;\n\t\t\n\tgeometrymatrix[0] = vec4(endpoint0,0.);\n\tgeometrymatrix[1] = vec4(endpoint1,0.);\n\tgeometrymatrix[2] = vec4(tangent0,0.);\n\tgeometrymatrix[3] = vec4(tangent1,0.);\t\n\t\n\tInitialize(spline, geometrymatrix);\n}\n\nstruct FactorsOfP\n{\n\t//stuff that's constant over iterations of solve given the query point p:\n\t//maybe compiler will optimize these already, or maybe not!\n\tfloat p_dot_G_0_p;\n\tfloat p_dot_G_1_p;\n\tfloat G_0_plus_p_dot_G_0_p;\n\tfloat G_1_plus_p_dot_G_1_p;\n\tfloat F_t_2;\n\tfloat F_t_1;\n\tfloat F_t_0;\n\tfloat G_t_0;\n};\n\nvoid InitFactorsOfP(inout FactorsOfP fp, Spline s, vec3 p)\n{\n\tfp.p_dot_G_0_p = dot(p,s.G_0_p);\n\tfp.p_dot_G_1_p = dot(p,s.G_1_p);\n\n\tfp.G_0_plus_p_dot_G_0_p = \t  s.G_0 + fp.p_dot_G_0_p;\n\tfp.G_1_plus_p_dot_G_1_p = 12.*(s.G_1 + fp.p_dot_G_1_p);\n\n\tfp.F_t_2 = 6. * (s.F_2 + fp.p_dot_G_1_p);\n\tfp.F_t_1 = \t  s.F_1 + fp.p_dot_G_0_p;\n\tfp.F_t_0 = \t  s.F_0 + dot(s.F_0_p,p);\n\n//\tG_t_1 = 12. * (s.G_1 + dot(s.G_1_p,p));\n\tfp.G_t_0 = \t   s.G_0 + fp.p_dot_G_0_p;\n}\n\nvec4 GetNormalizedQuarticConstants(Spline s, FactorsOfP fp, vec3 p)\n{\n\tvec4 ret;\n\tret.x = s.quartic_a;\n\tret.y = s.quartic_b;\n\tret.z =\tfp.G_1_plus_p_dot_G_1_p * s.oo_G_4;\n\tret.w = fp.G_0_plus_p_dot_G_0_p * s.oo_G_4;\n\treturn ret;\n}\n\n\n/*\n(A dot B)' = A dot B' + A' dot B\nD  =   (P-MT) dot (P-MT)\nD' = 2 (P-MT) dot (P-MT')\nD''= 2 (P-MT) dot (P-MT'') + 2 (P-MT') dot (P-MT')\nT   =   t^3    t^2 \tt \t1\nT'  = 3 t^2  2 t  \t1 \t0\nT'' = 6 t    2      0   0\n*/\n\nfloat DistanceSqFirstDeriv(Spline s, FactorsOfP fp, vec3 p, float t)\n{\n\treturn t * (t * (t * (t * (t * s.F_5 + s.F_4) + s.F_3) + fp.F_t_2) + fp.F_t_1) + fp.F_t_0;\n}\n\nfloat DistanceSqSecondDeriv(Spline s, FactorsOfP fp, vec3 p, float t)\n{\n\treturn t * (t * (t * (t * s.G_4 + s.G_3) + s.G_2) + fp.G_1_plus_p_dot_G_1_p) + fp.G_t_0;\n}\n\nfloat NewtonSpline(Spline s, FactorsOfP fp, vec3 p, float t )\n{\n\t//iterate newton's method:\n\tfor (int n=0; n<2; n++)\n\t{\n\t\tt -= DistanceSqFirstDeriv(s,fp,p,t) / DistanceSqSecondDeriv(s,fp,p,t);\n\t}\n\n\treturn t;\n}\n\nfloat BisectSpline(Spline s, FactorsOfP fp, vec3 Q, float a, float b, float fa )\n{\n//\tfloat fa = DistanceSqFirstDeriv(s,Q,a);\n\n\tfloat p = a+(b-a)*0.5;\n\n\tfor (int n=0; n<4; n++)\n\t{\n\t\tfloat fp = DistanceSqFirstDeriv(s,fp,Q,p);\n\t\tif (fa*fp > 0.)\n\t\t{\n\t\t\ta=p;\n\t\t\tfa = fp;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tb = p;\n\t\t}\n\n\t\tp = a+(b-a)*0.5;\n\t}\n\n\treturn p;\n}\n\nvec3 Spline_Evaluate(mat4 MG, float t )\n{\n\tvec4 tvec = vec4(t*t*t, t*t, t, 1.);\t\n\tvec3 p = (MG*tvec).xyz;\n\treturn p;\n}\n\nvec3 Spline_EvaluateTangent(mat4 MG, float t )\n{\n\tvec4 tvec = vec4(3.*t*t, 2.*t, 1, 0.);\t\n\tvec3 p = (MG*tvec).xyz;\n\treturn p;\n}\n\nvec3 Spline_EvaluateBinormal(mat4 MG, float t )\n{\n\tvec4 tvec = vec4(6.*t, 2., 0., 0.);\t\n\tvec3 p = (MG*tvec).xyz;\n\treturn p;\n}\n\nvec3 SplineOrtho(float t)\n{\n//\treturn normalize( Spline_EvaluateBinormal(spline.MG,t));\n\treturn normalize(cross(Spline_EvaluateTangent(spline.MG,t),Spline_EvaluateBinormal(spline.MG,t)));\n}\n\nvec3 GetPosOnSpline(float t)\n{\n\treturn Spline_Evaluate(spline.MG,t);\n}\n\nfloat DistSq( mat4 MG,  float s, vec3 p )\n{\n\tvec3 spline_pos = Spline_Evaluate(MG, s );\n\tvec3 d = spline_pos - p;\t\t\n\tfloat dist_sq = dot(d,d);\n\treturn dist_sq;\n}\n\nfloat LengthSquared(vec3 a)\n{\n\treturn dot(a,a);\n}\n\nfloat FindClosestPointOnSplineToPoint( Spline sp, vec3 p)\n{\n\t//start by finding roots of 2nd derivative of degree 6 Distance function ... solve quartic!\n\n\tFactorsOfP fp;\n\tInitFactorsOfP(fp, sp, p);\n\t\n\tvec4 abcd = GetNormalizedQuarticConstants(sp, fp, p);\n\tvec4 roots = vec4(1.);\n\tint root_count = quartic_descartes(abcd.x, abcd.y, abcd.z, abcd.w, roots);\n\t\n\t//apparently returns stilly stuff in spaces >= root count so reset to something that will sort to the end!\n\tfor (int i=0; i<4; i++)\n\t\troots[i] = (i<root_count)?roots[i] : 1.;\n\n\tvec4 sorted_roots = Sort(roots);\n\n\t//start with distance to the first endpoint, then try and do better\n\tfloat t = 0.;\n\tfloat end0_dist = LengthSquared(sp.endpoint0-p);\n\tfloat best_dist = end0_dist;\t\n\tfloat prev_root = 0.0;\n\tfloat prev_first_deriv = DistanceSqFirstDeriv(sp, fp, p, prev_root);\n\tfloat prev_dist = end0_dist;\n//\tfor (int root=0; root<root_count+1; root++)\n\tfor (int root=0; root<5; root++)\n\t{\n\t\tif (root >= root_count+1) break;\n\t\t\n//\t\tfloat next_root = (root < root_count) ? min(sorted_roots[root],1.0) : 1.0;\n\t\tfloat next_root = (root < root_count) ? sorted_roots[root] : 1.0;\n\t\tif (next_root > 0.0)\n\t\t{\n\t\t\t//may as well test this point seeing as we went to the trouble of evaluating it... \n\t\t\t//also handles the case of the end of the parameter range\n\t\t\tfloat next_dist = DistSq(sp.MG, next_root, p );\n\t\t\tif (next_dist < best_dist)\n\t\t\t{\n\t\t\t\tbest_dist = next_dist;\n\t\t\t\tt = next_root; \n\t\t\t}\n\n\t\t\t//if there was a sign change in this bracket, it might be worth testing\n\t\t\tfloat next_first_deriv = DistanceSqFirstDeriv(sp, fp, p, next_root);\n\t\t\tif (prev_first_deriv*next_first_deriv < 0.)\n\t\t\t{\n\t\t\t\tfloat bisect_parameter = BisectSpline(sp, fp, p, prev_root, next_root, prev_first_deriv );\n\t\t\t\tfloat newton_parameter = NewtonSpline(sp, fp, p, bisect_parameter );\n\n\t\t\t\t//might be a decent root!\n\t\t//\t\tif (prev_root < newton_parameter && newton_parameter < next_root)\n\t\t\t\t{\n\t\t\t\t\tfloat newton_dist = DistSq(sp.MG, newton_parameter, p );\n\t\t\t\t\tif (newton_dist < best_dist)\n\t\t\t\t\t{\n\t\t\t\t\t\tbest_dist = newton_dist;\n\t\t\t\t\t\tt = newton_parameter;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t/*\t\telse //if (prev_root < bisect_parameter && bisect_parameter < next_root)\n\t\t\t\t{\n\t\t\t\t\t//fall back to bisected one if newton exploded or something.\n\t\t\t\t\tfloat minimized_dist = DistSq(sp.MG, bisect_parameter, p );\n\t\t\t\t\tif (minimized_dist < best_dist)\n\t\t\t\t\t{\n\t\t\t\t\t\tbest_dist = minimized_dist;\n\t\t\t\t\t\tt = bisect_parameter;\n\t\t\t\t\t}\n\t\t\t\t} */\t\t\t\t\n\t\t\t}\n\n\t\t\tprev_first_deriv = next_first_deriv;\n\t\t\tprev_dist = next_dist;\n\t\t\tprev_root = next_root;\n\t\t}\n\t}\n\t\t\t\n\treturn t;\n}\n\nfloat FindClosestPointOnSplineToPoint( vec3 p )\n{\n\treturn FindClosestPointOnSplineToPoint( spline, p);\n}\n\nvec4 Sort( vec4 a)\n{\n\tvec4 m = vec4(min(a.xz,a.yw), max(a.xz,a.yw) );\n\tvec4 r = vec4(min(m.xz,m.yw), max(m.xz,m.yw) ); \n\ta = vec4( r.x, min(r.y,r.z),  max(r.y,r.z), r.w );\n\treturn a;\n}\n\n//Graphics Gems V cubic & quartic solvers ... ancient code but still seems to work fine in GLSL! :)\n//http://sydney.edu.au/engineering/it/research/tr/tr487.pdf\n\nint quadratic(float b,float c, inout vec2 rts, float dis)\n{\t\n\tif (dis >= 0.)\n\t{\n\t\tfloat rtdis = sqrt(dis);\t   \n\t\trts[0] = (b > 0.) ? ( -b - rtdis)*0.5 : ( -b + rtdis)*0.5;\n\t\trts[1] = (rts[0] == 0.) ? -b : c/rts[0] ;\n\t\treturn 2;\n\t}\n\n\trts[0] = 0.;\n\trts[1] = 0.;\n\treturn 0;\n}\n\nfloat acos3(float x)\n{\n   return cos(acos(x)*(1.0/3.0));\n}\n\nfloat curoot(float x)\n{\n\treturn sign(x)*pow(abs(x),1./3.);\n}\n\nfloat cubic(float p, float q, float r)\n/* \n     find the lowest real root of the cubic - \n       x**3 + p*x**2 + q*x + r = 0 \n\n   input parameters - \n     p,q,r - coeffs of cubic equation. \n\n   output- \n     cubic - a real root. \n\n   global constants -\n     sqrt(3.0f) - sqrt(3) \n     (1.0f/3.0f) - 1/3 \n     doubmax - square root of largest number held by machine \n\n     method - \n     see D.E. Littlewood, \"A University Algebra\" pp.173 - 6 \n\n     Charles Prineas   April 1981 \n\n     called by  neumark.\n     calls  acos3 \n*/\n{\n\tint nrts;\n\tfloat po3,po3sq,qo3;\n\tfloat uo3,u2o3,uo3sq4,uo3cu4 ;\n\tfloat v,vsq,wsq ;\n\tfloat m,mcube,n;\n\tfloat muo3,s,scube,t,cosk,sinsqk ;\n\tfloat root;\n\t\n\tm = 0.;\n\tnrts =0;\n\t\n\tpo3 = p*(1./3.) ;\n\tpo3sq = po3*po3 ;\n\t\n\tv = r + po3*(po3sq + po3sq - q) ;\n\t\n\tvsq = v*v ;\n\tqo3 = q*(1./3.) ;\n\tuo3 = qo3 - po3sq ;\n\tu2o3 = uo3 + uo3 ;\n\tuo3sq4 = u2o3*u2o3 ;\n\tuo3cu4 = uo3sq4*uo3 ;\n\twsq = uo3cu4 + vsq ;\n\tif (wsq >= 0.)\n\t{\n\t\t/* \n\t\tcubic has one real root \n\t\t*/\n\t\tnrts = 1;\n\t\tif (v <= 0.) mcube = ( -v + sqrt(wsq))*0.5 ;\n\t\telse /*if (v  > 0.)*/ mcube = ( -v - sqrt(wsq))*0.5 ;\n\t\tm = curoot(mcube) ;\n\t\tif (m != 0.) n = -uo3/m ;\n\t\telse n = 0.;\n\t\troot = m + n - po3 ;\n\t}\n\telse\n\t{\n\t\tnrts = 3;\n\t\t/* \n\t\tcubic has three real roots \n\t\t*/\n\t\tif (uo3 < 0.)\n\t\t{\n\t\t\tmuo3 = -uo3;\n\t\t\ts = sqrt(muo3) ;\n\t\t\tscube = s*muo3;\n\t\t\tt =  -v/(scube+scube) ;\n\t\t\tcosk = acos3(t) ;\n\t\t\tif (po3 < 0.)\n\t\t\t\troot = (s+s)*cosk - po3;\n\t\t\telse\n\t\t\t{\n\t\t\t\tsinsqk = max(1. - cosk*cosk,0.);\n\t\t\t\troot = s*( -cosk - sqrt(3.)*sqrt(sinsqk)) - po3 ;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\t/* \n\t\t\tcubic has multiple root -  \n\t\t\t*/\n\t\t\troot = curoot(v) - po3 ;\n\t}\n\n\treturn(root);\n} /* cubic */\n\n#if 1\nvoid AssignElementOfVectorWithVariableIndex(inout vec4 dst, int index, float src)\n{\n\tfor (int i=0; i<4; i++)\n\t{\n\t\tdst[i]=(i==index)?src:dst[i];\n\t}\n}\n#else\nvoid AssignElementOfVectorWithVariableIndex(inout vec4 dst, int index, float src)\n{\n\tdst[index] = src;\n}\n#endif\n\nint quartic_descartes(float a, float b, float c, float d, inout vec4 rts)\n/*\n   Solve quartic equation using\n   Descartes-Euler-Cardano algorithm\n\n   Strong, T. \"Elemementary and Higher Algebra\"\n      Pratt and Oakley, p. 469 (1859)\n\n     29 Jun 1994  Don Herbison-Evans\n*/\n{\n\n   int nrts;\n   int r1,r2;\n   vec2 v1, v2;\n   float y;\n   float p,q,r;\n   float A,B,C;\n   float m,n1,n2;\n   float d3o8,d3o256;\n   float inv8,inv16;\n   float asq;\n   float Binvm;\n\n   d3o8 = 3./8.;\n   inv8 = 1./8.;\n   inv16 = 1./16.;\n   d3o256 = 3./256.;\n\n   asq = a*a;\n\n   A = b - asq*d3o8;\n   B = c + a*(asq*inv8 - b*0.5);\n   C = d + asq*(b*inv16 - asq*d3o256) - a*c*0.25;\n\n   p = 2.*A;\n   q = A*A - 4.*C;\n   r = -B*B;\n\n/***\n   inv64 = 1.0f/(float)64;\n   p = 2.0f*b - 3.0f*a*a*0.25f ;\n   q = b*b - a*a*b - 4.0f*d + 3.0f*a*a*a*a*inv16 + a*c;\n   r = -c*c - a*a*a*a*a*a*inv64 - a*a*b*b*0.25f\n       -a*a*a*c*0.25f + a*b*c + a*a*a*a*b*inv8;\n***/\n\n   y = cubic(p,q,r);\n   if (y <= 0.) \n      nrts = 0;\n   else\n   {\n      m = sqrt(y);\n      Binvm = B/m;\n      n1 = (y + A + Binvm)*0.5;\n      n2 = (y + A - Binvm)*0.5;\n      r1 = quadratic(-m, n1, v1, y-4.*n1);\n      r2 = quadratic( m, n2, v2, y-4.*n2);\n      rts[0] = v1[0]-a*0.25;\n      rts[1] = v1[1]-a*0.25;\n   //   rts[r1] = v2[0]-a*0.25;\n\t  AssignElementOfVectorWithVariableIndex(rts,r1,v2[0]-a*0.25);\n\t//  rts[r1+1] = v2[1]-a*0.25f;\n\t  AssignElementOfVectorWithVariableIndex(rts,r1+1,v2[1]-a*0.25);\n      nrts = r1+r2;\n   } \n   return(nrts);\n}\n\n//http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XssGWl","date":"1383576171","viewed":2355,"name":"Spline solver","username":"Antonalog","description":"Compute the distance to a spline. ","likes":33,"published":1,"flags":0,"usePreview":0,"tags":["spline","distance","numerical"],"hasliked":0,"parentid":"","parentname":""}}