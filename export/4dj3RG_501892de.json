{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"#ifdef GL_ES\nprecision highp float;\n#endif\n\n#define FULLBODY\n\n#define DELTA 0.02\n#define MAXDISTANCE 2.0\n#define RAYITERATIONS 100\n\n#define CASTITERATIONS 20\n#define CASTDELTA 0.01\n#define CASTDISTANCE 20.0\n\n#define SPHERERADIUS 1.0\n\n//uniform float time;\n//uniform vec2 mouse;\n//uniform vec2 resolution;\n\n#define time iTime\n#define resolution iResolution\n\nvec4 getAmbientSample( vec3 p )\n{\n\treturn vec4( 0.0, 0.05, 0.1, 0.010 );\n}\n\nfloat getSphereDistance( vec3 p, float r )\n{\n\treturn max( 0.0, length(p)-r );\n//\treturn length(p)-r;\n}\n\t\nvec4 getSphereSample( vec3 p, float r )\n{\n\tif( getSphereDistance(p,r)<=0.0 )\n\t{\n\t\tp = normalize(p);\n\t\tp.x = sin(p.x*10.0 + 1.0*time)/3.0;\n\t\tp.y = cos(p.y*11.0 + 2.0*time)/3.0;\n\t\tp.z = sin(p.z*12.0 + 1.0*time)/3.0;\n\t\t\n\t\t//return vec4(vec3(p), 0.015);\n\t\treturn vec4( 5.0*p.z*p.y,3.0*abs(p.x),0.9 , abs(p.x+p.y+p.z)/20.0 );\n\t}\n\telse\n\t{\n\t\treturn getAmbientSample(p);\n\t}\n}\n\nvec3 castRay( vec3 emitterP, vec3 rayV )\n{\n\tfloat t = 0.0;\n\tvec3 rayP = emitterP;\n\n\tfor(int i=0;i<CASTITERATIONS;i++)\n\t{\n        \tfloat h = getSphereDistance(rayP, SPHERERADIUS);\n        \tif( h<CASTDELTA )\n\t\t\tbreak;\n\t\tif( h>CASTDISTANCE )\n\t\t\treturn emitterP + rayV*CASTDISTANCE; \n\t\trayP += rayV*h;\n\t}\n\treturn rayP;\n}\n\nvec3 getWorldC( vec3 emitterP, vec3 rayV )\n{\n\tvec3 sampleP = castRay( emitterP, rayV );\n\t//vec3 sampleP = emitterP + rayV;\n\t\n\tvec4 accumulatedS = getAmbientSample( MAXDISTANCE*rayV );\n\n\t#ifdef FULLBODY\n\tfor( float depth = 0.0; depth <= MAXDISTANCE; depth += DELTA )\n\t#else\n\tfor( int i = 0; i < RAYITERATIONS; i++ )\n\t#endif\n\t{\n\t\t//if( accumulatedS.a >= 1.0 )\n\t\t//\tbreak;\n\t\tvec4 sampleS = getSphereSample( sampleP, SPHERERADIUS );\n\t\t//accumulatedS = vec4( vec3(mix(sampleS.rgb, accumulatedS.rgb,  accumulatedS.a)),\n\t\t//\t\t     accumulatedS.a + sampleS.a); \n\t\taccumulatedS = vec4( vec3(mix(accumulatedS.rgb, sampleS.rgb,  sampleS.a)),\n\t\t\t\t     accumulatedS.a + sampleS.a); \n\t\tsampleP += DELTA*rayV;\n\t}\n\treturn vec3( accumulatedS.rgb );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 scrP    = 2.0*fragCoord.xy/resolution.xy - 1.0;\n\t     scrP.x *= resolution.x/resolution.y;\t\n\t\n\tvec3 camP      = vec3(-2.0, 0.0, 0.0 );\n\tvec3 trgP      = vec3( 0.0, 0.0, 0.0 );\n\tvec3 upV       = vec3( 0.0, 1.0, 0.0 );\n\tvec3 camV      = normalize( trgP - camP );\n\tvec3 camRightV = cross( upV, camV );\n\tvec3 camUpV    = cross( camV, camRightV );\n\t\n\tvec3 lightP = vec3(-5.0, 5.0, 2.0 );\n\tvec3 lightV = normalize(lightP);\n\tvec3 lightC = vec3( 1.0, 0.9, 0.5 );\n\t\n\tvec3 rayV = normalize( camV + camRightV*scrP.x + camUpV*scrP.y );\n\t\n\tvec3 color = getWorldC( camP, rayV );\n\t//vec3 color = castRay(camP,rayV);\n\t\n\tfragColor = vec4( color, 1.0 );\n\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4dj3RG","date":"1390040124","viewed":1221,"name":"Transparent sphere","username":"aczkasow","description":"transparent sphere","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","transparency"],"hasliked":0,"parentid":"","parentname":""}}