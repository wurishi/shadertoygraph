{"ver":"0.1","info":{"id":"DdVBzt","date":"1718798489","viewed":190,"name":"Particle Soup","username":"TheTurk","description":"Use mouse to spawn particles. Hold \"C\" to tilt the camera and \"D\" to show the debug view.\n\nPhysics based on [url]https://www.shadertoy.com/view/dscfRf[/url] by Mykhailo Moroz.","likes":26,"published":1,"flags":48,"usePreview":0,"tags":["simulation","sdf","fluid","voxel","particles","liquid","physics","particle","pbr","sph","pressure","bowl","hydrodynamics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"bool keyToggled(int key) {\n\treturn texelFetch(iChannel3, ivec2(key, 2), 0).x > 0.0;\n}\n\nbool debugEnabled() {\n\treturn keyToggled(68);\n}\n\nvoid particlesFromTexture(vec3 cellCoordinate, inout Particle particle1, inout Particle particle2) { \n    particlesFromTexture(iChannel0, cellCoordinate, particle1, particle2);\n}\n\nvec4 sampleDensity(vec3 position) {\n    return trilinear(iChannel1, position);\n}\n\nfloat grid(vec2 position) {\n    position += 0.5;\n    vec2 d = abs(fract(position) - 0.5);\n    return min(d.x, d.y);\n}\n\nfloat disk(vec2 position, float radius) {\n    return length(position) - radius;\n}\n\nvec3 heatmapColor(float value) {\n    return vec3(sin(2.0 * pi / 4.0 * value), value * value, mix(sin(2.0 * pi * value), value, 0.6));\n}\n\nvec3 debugView(vec2 position) {\n    float scale = 1.0 / 32.0;\n    position /= scale;\n    position.x = -position.x;\n    float z = 0.5;\n    vec3 cellCoordinate = floor(vec3(position.xy, z));\n    vec3 color = vec3(0.0);\n    color = mix(color, vec3(0.1), 1.0 - smoothstep(0.0, 3.0, ((grid(position) * scale) - 1.0 / iResolution.y) * iResolution.y));\n    float environmentClosestDistance = environment(vec3(position.xy, z)) * scale;\n    color = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 3.0, (abs(environmentClosestDistance) - 1.0 / iResolution.y) * iResolution.y));\n    if (!all(lessThan(abs(cellCoordinate), halfGridSize))) {\n        return color;\n    } \n    float threshold = 0.25;\n    float density = sampleDensity(vec3(position.xy, z)).z;\n    density = density > threshold ? 0.0 : density / threshold;\n    color += heatmapColor(density) * 0.5;\n    for (int y = -1; y <= 1; y++) {\n        for (int x = -1; x <= 1; x++) {\n            vec3 neighborCellCoordinate = cellCoordinate + vec3(x, y, 0.0);\n            Particle particle1, particle2;  \n            particlesFromTexture(neighborCellCoordinate, particle1, particle2);\n            if (particle1.mass > 0.0) {\n                vec3 particlePosition = neighborCellCoordinate + particle1.position;\n                float radius = 0.15 * sqrt(particle1.mass / pi);\n                float d = disk(position - particlePosition.xy, radius) * scale;\n                color = mix(color, vec3(0.5), 1.0 - smoothstep(0.0, 3.0, d * iResolution.y));\n            }\n            if (particle2.mass > 0.0) {\n                vec3 particlePosition = neighborCellCoordinate + particle2.position;\n                float radius = 0.15 * sqrt(particle2.mass / pi);\n                float d = disk(position - particlePosition.xy, radius) * scale;\n                color = mix(color, vec3(0.5), 1.0 - smoothstep(0.0, 3.0, d * iResolution.y));\n            }\n        }\n    }\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    configureBuffer(iResolution.xy);\n    vec3 color;\n    if (debugEnabled()) {\n        vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n        color = debugView(uv);\n    } else {\n        color = texelFetch(iChannel2, ivec2(fragCoord), 0).xyz;\n    }\n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"bool keyPressed(int key) {\n\treturn texelFetch(iChannel3, ivec2(key, 0), 0).x > 0.0;\n}\n\nvoid particlesFromTexture(vec3 cellCoordinate, inout Particle particle1, inout Particle particle2) { \n    particlesFromTexture(iChannel0, cellCoordinate, particle1, particle2);\n}\n\nfloat pressure(float density) {\n    return density * 2.0 - 1.0;\n}\n\nvoid applyParticleForces(inout Particle particle, inout Particle neighborParticle, vec3 cellCoordinate, vec3 neighborCellCoordinate, float density, float neighborDensity) {\n    if (neighborParticle.mass == 0.0) {\n        return;\n    }\n    vec3 positionDifference = (neighborCellCoordinate + neighborParticle.position) - (cellCoordinate + particle.position);\n    vec3 velocityDifference = neighborParticle.velocity - particle.velocity;\n    vec3 gradient = computeGaussianGradient(positionDifference, 1.0);\n    vec3 direction = normalize(positionDifference);\n    vec3 pressureForce = 0.15 * density * neighborParticle.mass * (pressure(density) / max(density * density, 0.001) + pressure(neighborDensity) / max(neighborDensity * neighborDensity, 0.001)) * gradient;\n    vec3 viscosityForce = -5.0 *  neighborParticle.mass * dot(direction, velocityDifference) * gradient; \n    vec3 surfaceTensionForce = -0.5 * neighborParticle.mass * computeGaussianGradient(positionDifference, 2.0);\n    vec3 spikeForce = -1.0 * neighborParticle.mass * direction * gaussian(dot(positionDifference, positionDifference), 0.75);\n    particle.force += pressureForce + viscosityForce + surfaceTensionForce + spikeForce;\n}\n\nvoid applyExternalForces(inout Particle particle, vec3 cellCoordinate) {\n    particle.force += 0.01 * vec3(0.0, -1.0, 0.0);\n    float environmentClosestDistance = environment(cellCoordinate + particle.position);\n    vec3 environmentGradient = sampleEnvironmentGradient(cellCoordinate + particle.position);\n    particle.force += 1.0 * exp(-4.0 * environmentClosestDistance * environmentClosestDistance) * environmentGradient;      \n}\n\nvoid updateParticle(inout Particle particle) {\n    particle.velocity += particle.force;\n    float particleSpeed = length(particle.velocity);\n    if (particleSpeed > particleMaximumSpeed) {\n        particle.velocity = particle.velocity / particleSpeed * particleMaximumSpeed;\n    }\n}\n\nvec3 sampleRandomDirection() {\n    vec2 uv = vec2(randFloat(), randFloat());\n    float phi = 2.0 * uv.x - 1.0;\n    float r = sqrt(1.0 - phi * phi);\n    float theta = 2.0 * pi * uv.y;\n    return vec3(r * cos(theta), phi, r * sin(theta));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    configureBuffer(iResolution.xy);\n    vec3 cellCoordinate = convertTextureToWorldCoordinate(floor(fragCoord)) - halfGridSize;\n    Particle particle1, particle2;  \n    particlesFromTexture(cellCoordinate, particle1, particle2);        \n    if (physicsEnabled && (particle1.mass > 0.0 || particle2.mass > 0.0)) {\n        if (particle1.mass > 0.0 && particle2.mass > 0.0 && distanceSquared(particle1.position, particle2.position) < 0.001 * 0.001) {\n            uint seed = 0x578437adu; \n            randState = hash(uvec2(fragCoord), seed + uint(iFrame)); \n            vec3 direction = sampleRandomDirection();\n            particle1.position -= 0.001 * direction;\n            particle2.position += 0.001 * direction;\n        }\n        vec2 density = voxel(iChannel1, cellCoordinate).xy;  \n        applyParticleForces(particle1, particle2, cellCoordinate, cellCoordinate, density.x, density.y);\n        applyParticleForces(particle2, particle1, cellCoordinate, cellCoordinate, density.y, density.x); \n        for (int x = -2; x <= 2; x++) {\n            for (int y = -2; y <= 2; y++) {\n                for (int z = -2; z <= 2; z++) {\n                    if (x == 0 && y == 0 && z == 0) {\n                        continue;\n                    }\n                    vec3 neighborCellCoordinate = cellCoordinate + vec3(x, y, z);\n                    Particle neighborParticle1, neighborParticle2;  \n                    particlesFromTexture(neighborCellCoordinate, neighborParticle1, neighborParticle2);\n                    vec2 neighborDensity = voxel(iChannel1, neighborCellCoordinate).xy;\n                    applyParticleForces(particle1, neighborParticle1, cellCoordinate, neighborCellCoordinate, density.x, neighborDensity.x);\n                    applyParticleForces(particle1, neighborParticle2, cellCoordinate, neighborCellCoordinate, density.x, neighborDensity.y);\n                    applyParticleForces(particle2, neighborParticle1, cellCoordinate, neighborCellCoordinate, density.y, neighborDensity.x);\n                    applyParticleForces(particle2, neighborParticle2, cellCoordinate, neighborCellCoordinate, density.y, neighborDensity.y);                    \n                }\n            }   \n        }\n        applyExternalForces(particle1, cellCoordinate);\n        applyExternalForces(particle2, cellCoordinate);\n        updateParticle(particle1);\n        updateParticle(particle2);\n    }\n    if (!keyPressed(67) && iMouse.z > 0.0) {\n        vec3 cellCenter = cellCoordinate + 0.5;\n        mat3 orbitRotation = rotationAxisAngle(vec3(0.0, 1.0, 0.0), cameraOrbitYaw);\n        orbitRotation *= rotationAxisAngle(vec3(1.0, 0.0, 0.0), cameraOrbitPitch);\n        vec3 cameraPosition = cameraOrbitCenter + orbitRotation * vec3(0.0, 0.0, -cameraOrbitRadius);   \n        vec2 uv = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n        vec3 rayDirection = orbitRotation * normalize(vec3(uv, 1.5)); \n        vec3 emitterPosition = cameraPosition + rayDirection * cameraPosition.z;\n        uint seed = 0x578437adu; \n        randState = hash(uvec2(fragCoord), seed + uint(iFrame)); \n        if (distanceSquared(cellCenter, emitterPosition) < emitterRadius * emitterRadius && randFloat() < emissionRate) {\n            Particle particle;\n            particle.position = vec3(0.5);\n            particle.mass = 1.0;\n            particle.velocity = emitterInitialVelocity;\n            particle.force = vec3(0.0);\n            merge(particle1, particle2, cellCoordinate, particle, cellCoordinate);\n        }\n    }\n    fragColor = encodeParticles(particle1, particle2);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void particlesFromTexture(vec3 cellCoordinate, inout Particle particle1, inout Particle particle2) { \n    particlesFromTexture(iChannel0, cellCoordinate, particle1, particle2);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    configureBuffer(iResolution.xy);\n    vec3 cellCoordinate = convertTextureToWorldCoordinate(floor(fragCoord)) - halfGridSize;              \n    Particle particle1, particle2;\n    if (!physicsEnabled) {\n        particlesFromTexture(cellCoordinate, particle1, particle2);\n    } else {\n        for (int z = -1; z <= 1; z++) {\n            for (int y = -1; y <= 1; y++) {\n                for (int x = -1; x <= 1; x++) {\n                    vec3 neighborCellCoordinate = cellCoordinate + vec3(x, y, z);\n                    if (!all(lessThan(abs(neighborCellCoordinate), halfGridSize - vec3(3.0, 1.0, 3.0)))) {\n                        continue;\n                    }\n                    Particle neighborParticle1, neighborParticle2;  \n                    particlesFromTexture(neighborCellCoordinate, neighborParticle1, neighborParticle2);\n                    if (neighborParticle1.mass > 0.0) {\n                        neighborParticle1.position += neighborParticle1.velocity;\n                        merge(particle1, particle2, cellCoordinate, neighborParticle1, neighborCellCoordinate);\n                    }\n                    if (neighborParticle2.mass > 0.0) {\n                        neighborParticle2.position += neighborParticle2.velocity; \n                        merge(particle1, particle2, cellCoordinate, neighborParticle2, neighborCellCoordinate);\n                    }\n                }\n            }\n        }      \n        if (particle1.mass > 1.0 && particle2.mass == 0.0) {\n            split(particle1, particle2);\n        }\n        if (particle2.mass > 1.0 && particle1.mass == 0.0) {\n            split(particle2, particle1);\n        }\n    } \n    fragColor = encodeParticles(particle1, particle2);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float pi = 3.1415927;\n\nfloat emitterRadius = 3.0;\nfloat emissionRate = 1.0 / 8.0;\nvec3 emitterInitialVelocity = vec3(0.0, 0.1, 0.0);\nfloat cameraOrbitYaw = -pi;\nfloat cameraOrbitPitch = 0.4;\nvec3 cameraOrbitCenter = vec3(0.0, -10.0, 0.0);\nfloat cameraOrbitRadius = 72.0;\nfloat particleMaximumSpeed = 0.9;\nbool physicsEnabled = true;\n\nvec2 bufferLayout = vec2(0.0);\nvec3 gridSize = vec3(0.0);\nvec3 halfGridSize = vec3(0.0);\n\nstruct Particle {\n    float mass;\n    vec3 position;\n    vec3 velocity;\n    vec3 force;\n};\n\nuint hash(uvec2 x, uint seed){\n    const uint m = 0x5bd1e995u;\n    uint hash = seed;\n    uint k = x.x; \n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n    k = x.y; \n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n    hash ^= hash >> 13;\n    hash *= m;\n    hash ^= hash >> 15;\n    return hash;\n}\n\nuint hash(uvec3 x, uint seed){\n    const uint m = 0x5bd1e995u;\n    uint hash = seed;\n    uint k = x.x; \n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n    k = x.y; \n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n    k = x.z; \n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n    hash ^= hash >> 13;\n    hash *= m;\n    hash ^= hash >> 15;\n    return hash;\n}\n\nuint randState;\n\n// pcg pseudo random number generator https://www.pcg-random.org/\nuint rand() {\n    uint state = randState;\n    randState = randState * 747796405u + 2891336453u;\n    uint x = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n    return (x >> 22u) ^ x;\n}\n\nfloat randFloat() {\n   return float(rand()) / float(0xffffffffu);\n}\n\nvec3 convertTextureToWorldCoordinate(vec2 position) {\n    float x = position.x - floor(position.x / gridSize.x) * gridSize.x;\n    float z = position.y - floor(position.y / gridSize.z) * gridSize.z;\n    float y = floor(position.y / gridSize.z) * bufferLayout.x + floor(position.x / gridSize.x);\n    return vec3(x, y, z);    \n}\n\nvec2 convertWorldToTextureCoordinate(vec3 position) {\n    float m = floor((position.y + 0.001) / bufferLayout.x);\n    float n = position.y - floor((position.y + 0.001) / bufferLayout.x) * bufferLayout.x;\n    float x = n * gridSize.x + position.x;\n    float y = m * gridSize.z + position.z;\n    return vec2(x, y);    \n}\n\nfloat bowl(vec3 position, float radius, float thickness) {\n    if (position.y < 0.0) {\n        return abs(length(position) - radius) - thickness;\n    }\n    return length(vec2(length(position.xz) - radius, position.y)) - thickness;\n}\n\nfloat bowl(vec3 position) {\n    return bowl(position, 30.0, 1.0);\n}\n\nfloat environment(vec3 position) {\n    return min(position.y + 30.0, bowl(position));\n}\n\nvec3 sampleEnvironmentGradient(vec3 position) {\n    float epsilon = 0.001;\n    vec2 k = vec2(1.0, -1.0);\n\treturn normalize(\n        k.xyy * environment(position + k.xyy * epsilon) +\n        k.yyx * environment(position + k.yyx * epsilon) +\n        k.yxy * environment(position + k.yxy * epsilon) +\n        k.xxx * environment(position + k.xxx * epsilon)\n    );\n}\n\nfloat distanceSquared(vec3 p1, vec3 p2) {\n    vec3 d = p1 - p2;\n    return dot(d, d);\n}\n\nfloat gaussian(float r, float h) {            \n    return exp(-0.5 * r / (h * h)) / (sqrt(8.0 * pi * pi * pi) * h * h * h);\n}\n\nvec3 computeGaussianGradient(vec3 difference, float h) {\n    return -difference / (h * h) * gaussian(dot(difference, difference), h);\n}\n\nuint encodeMassAndPosition(float mass, vec3 position) {\n    uvec3 p = uvec3(clamp(position, 0.0, 1.0) * 255.0 + 0.5);\n    uint data = uint(mass) | (p.x << 8) | (p.y << 16) | (p.z << 24);\n    return data;\n}\n\nvoid decodeMassAndPosition(uint data, out float mass, out vec3 position) {\n    mass = float(data & 0xffu);   \n    uvec3 p = uvec3(data >> 8, data >> 16, data >> 24) & 0xffu;\n    position = vec3(p) / 255.0;\n}\n\nuint encodeVelocity(vec3 value) {\n    float maximumValue = max(abs(value.x), max(abs(value.y), abs(value.z)));\n    float exponent = clamp(ceil(log2(maximumValue)), -15.0, 15.0);\n    uvec3 d = uvec3((clamp(value * exp2(-exponent), -1.0, 1.0) + 1.0) * 0.5 * 511.0 + 0.5);\n    return uint(exponent + 15.0) | (d.x << 5) | (d.y << 14) | (d.z << 23);\n}\n\nvec3 decodeVelocity(uint data) {\n    float exponent = float(data & 0x1fu) - 15.0;\n    vec3 v = vec3((data >> 5) & 0x1ffu, (data >> 14) & 0x1ffu, (data >> 23) & 0x1ffu);\n    v = ((v / 511.0) * 2.0) - 1.0;\n    v *= exp2(exponent);\n    return v;\n}\n\nvec4 encodeParticles(Particle particle1, Particle particle2) {\n   return vec4(\n       uintBitsToFloat(encodeMassAndPosition(particle1.mass, particle1.position)), \n       uintBitsToFloat(encodeVelocity(particle1.velocity)),\n       uintBitsToFloat(encodeMassAndPosition(particle2.mass, particle2.position)), \n       uintBitsToFloat(encodeVelocity(particle2.velocity))\n   );\n}\n\nvoid decodeParticles(vec4 pixel, out Particle particle1, out Particle particle2) {\n    decodeMassAndPosition(floatBitsToUint(pixel.x), particle1.mass, particle1.position);\n    particle1.velocity = decodeVelocity(floatBitsToUint(pixel.y));\n    decodeMassAndPosition(floatBitsToUint(pixel.z), particle2.mass, particle2.position);\n    particle2.velocity = decodeVelocity(floatBitsToUint(pixel.w));\n}\n\nvoid particlesFromTexture(sampler2D buffer, vec3 cellCoordinate, inout Particle particle1, inout Particle particle2) { \n    vec2 uv = convertWorldToTextureCoordinate(cellCoordinate + halfGridSize);\n    vec4 pixel = texelFetch(buffer, ivec2(uv), 0);\n    decodeParticles(pixel, particle1, particle2); \n}\n\nvec4 voxel(sampler2D buffer, vec3 position) {\n    position += halfGridSize;\n    position.y = max(position.y, 0.0);\n    vec2 uv = convertWorldToTextureCoordinate(position);\n    return texelFetch(buffer, ivec2(uv), 0);\n}\n\nvec4 bilinear(sampler2D buffer, vec2 position) {   \n    vec2 t = position - floor(position);\n    position.y = max(position.y, 0.0);\n    vec4 value1 = texelFetch(buffer, ivec2(position), 0);\n    vec4 value2 = texelFetch(buffer, ivec2(position) + ivec2(1, 0), 0);\n    vec4 value3 = texelFetch(buffer, ivec2(position) + ivec2(0, 1), 0);\n    vec4 value4 = texelFetch(buffer, ivec2(position) + ivec2(1, 1), 0);\n    return mix(mix(value1, value2, t.x), mix(value3, value4, t.x), t.y);\n}\n\nvec4 trilinear(sampler2D buffer, vec3 position) {\n    position += halfGridSize;\n    position -= 0.5;\n    vec2 position1 = convertWorldToTextureCoordinate(vec3(position.x, floor(position.y), position.z));\n    vec2 position2 = convertWorldToTextureCoordinate(vec3(position.x, floor(position.y) + 1.0, position.z));\n    vec4 value1 = bilinear(buffer, position1);\n    vec4 value2 = bilinear(buffer, position2);\n    return mix(value1, value2, fract(position.y));\n}\n\nmat3 rotationAxisAngle(vec3 axis, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    vec3 column1 = axis * axis.x * (1.0 - c) + vec3(c, axis.z * s, -axis.y * s);\n    vec3 column2 = axis * axis.y * (1.0 - c) + vec3(-axis.z * s, c, axis.x * s);\n    vec3 column3 = axis * axis.z * (1.0 - c) + vec3(axis.y * s, -axis.x * s, c);\n    return mat3(column1, column2, column3);\n}\n\n// build orthonormal basis https://graphics.pixar.com/library/OrthonormalB/paper.pdf\nmat3 rotation(vec3 normal) {\n    float s = normal.z < 0.0 ? -1.0 : 1.0;    \n    float a = 1.0 / (1.0 + abs(normal.z));\n    float b = -s * normal.x * normal.y * a;\n    vec3 right = vec3(1.0 - normal.x * normal.x * a, s * b, s * -normal.x);\n    vec3 forward = vec3(b, s - normal.y * normal.y * a * s, -normal.y);\n    return mat3(right, normal, forward);\n}\n\nvoid configureBuffer(vec2 bufferSize) {\n   float height = 64.0;\n   float width = sqrt(bufferSize.x * bufferSize.y / height);\n   width = floor(min(bufferSize.x / ceil(bufferSize.x / width), bufferSize.y / ceil(bufferSize.y / width)) * 0.5) * 2.0;\n   bufferLayout = floor(bufferSize / vec2(width));\n   gridSize = vec3(width, height, width);\n   halfGridSize = 0.5 * gridSize;\n}\n\nvoid merge(inout Particle particle, vec3 cellCoordinate, in Particle neighborParticle, vec3 neighborCellCoordinate) {\n    float mass = min(particle.mass + neighborParticle.mass, 5.0);\n    vec2 weight = vec2(particle.mass, neighborParticle.mass) / float(mass);\n    particle.position = (particle.position + cellCoordinate) * weight.x + (neighborParticle.position + neighborCellCoordinate) * weight.y - cellCoordinate;\n    particle.velocity = particle.velocity * weight.x + neighborParticle.velocity * weight.y;\n    particle.mass = mass;\n}\n\nvoid merge(inout Particle particle1, inout Particle particle2, vec3 cellCoordinate, in Particle neighborParticle, vec3 neighborCellCoordinate) {\n    if(!all(equal(floor(neighborCellCoordinate + neighborParticle.position), cellCoordinate))) {\n        return;\n    }\n    if (particle1.mass == 0.0) {\n        merge(particle1, cellCoordinate, neighborParticle, neighborCellCoordinate);\n    } else if (particle2.mass == 0.0) {\n        merge(particle2, cellCoordinate, neighborParticle, neighborCellCoordinate);\n    } else {\n        vec3 particlePosition1 = cellCoordinate + particle1.position;\n        vec3 particlePosition2 = cellCoordinate + particle2.position;\n        vec3 neighborPosition = neighborCellCoordinate + neighborParticle.position;\n        float d1 = distanceSquared(particlePosition1, neighborPosition);\n        float d2 = distanceSquared(particlePosition2, neighborPosition);\n        if (d1 < d2) {\n            merge(particle1, cellCoordinate, neighborParticle, neighborCellCoordinate);\n        } else {\n            merge(particle2, cellCoordinate, neighborParticle, neighborCellCoordinate);\n        }\n    }\n}\n\nvoid split(inout Particle particle1, inout Particle particle2) {\n    float mass = particle1.mass;\n    vec3 position = particle1.position;\n    particle1.mass = floor(0.5 * mass);\n    particle2.mass = mass - particle1.mass;\n    particle2.position = position;\n    particle2.velocity = particle1.velocity;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"float particleRadius = 1.0;\n\nvoid particlesFromTexture(vec3 cellCoordinate, inout Particle particle1, inout Particle particle2) { \n    particlesFromTexture(iChannel0, cellCoordinate, particle1, particle2);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    configureBuffer(iResolution.xy);\n    vec3 cellCoordinate = convertTextureToWorldCoordinate(floor(fragCoord)) - halfGridSize;\n    vec3 cellCenter = cellCoordinate + 0.5;\n    Particle particle1, particle2;  \n    particlesFromTexture(cellCoordinate, particle1, particle2);\n    vec3 position1 = cellCoordinate + particle1.position;\n    vec3 position2 = cellCoordinate + particle2.position;\n    vec4 density = vec4(0.0, 0.0, 0.0, 2.0);\n    float h = 1.0;\n    for (int x = -2; x <= 2; x++) {\n        for (int y = -2; y <= 2; y++) {\n            for (int z = -2; z <= 2; z++) { \n                vec3 neighborCellCoordinate = cellCoordinate + vec3(x, y ,z);\n                Particle neighborParticle1, neighborParticle2;  \n                particlesFromTexture(neighborCellCoordinate, neighborParticle1, neighborParticle2);\n                vec3 neighborPosition1 = neighborCellCoordinate + neighborParticle1.position;\n                vec3 neighborPosition2 = neighborCellCoordinate + neighborParticle2.position;\n                if (particle1.mass > 0.0) {\n                    if (neighborParticle1.mass > 0.0) {\n                        density.x += neighborParticle1.mass * gaussian(distanceSquared(position1, neighborPosition1), h);\n                    }\n                    if (neighborParticle2.mass > 0.0) {\n                        density.x += neighborParticle2.mass * gaussian(distanceSquared(position1, neighborPosition2), h);\n                    }\n                }\n                if (particle2.mass > 0.0) {\n                    if (neighborParticle1.mass > 0.0) {\n                        density.y += neighborParticle1.mass * gaussian(distanceSquared(position2, neighborPosition1), h);\n                    }\n                    if (neighborParticle2.mass > 0.0) {\n                        density.y += neighborParticle2.mass * gaussian(distanceSquared(position2, neighborPosition2), h);\n                    }\n                } \n                if (neighborParticle1.mass > 0.0) {\n                    float d = distanceSquared(cellCenter, neighborPosition1);\n                    density.z += neighborParticle1.mass * gaussian(d, h);\n                    density.w = min(density.w, sqrt(d) - particleRadius);\n                }\n                if (neighborParticle2.mass > 0.0) {\n                    float d = distanceSquared(cellCenter, neighborPosition2);\n                    density.z += neighborParticle2.mass * gaussian(d, h);\n                    density.w = min(density.w, sqrt(d) - particleRadius);\n                }\n            }\n        }\n    }\n    fragColor = density;\n}\n\n","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"vec3 lightColor = vec3(1.0, 0.85, 0.65);\nfloat lightIntensity = 12.5;\nvec3 lightPosition = vec3(0.0, 30.0, 0.0) * 256.0;\nvec2 lightHalfSize = vec2(30.0, 30.0) * 256.0;\n\n\nbool keyPressed(int key) {\n\treturn texelFetch(iChannel3, ivec2(key, 0), 0).x > 0.0;\n}\n\n// https://www.cs.cmu.edu/~scoros/cs15467-s16/lectures/11-fluids2.pdf\nvec3 aces(vec3 color) {\n    return clamp((color * (2.51 * color + 0.03)) / (color * (2.43 * color + 0.59) + 0.14), 0.0, 1.0);\n}\n\nstruct Material {\n    vec3 baseColor;\n    float roughness;\n    float metallic;\n};\n\nMaterial createMaterial(int i) {\n    vec3 baseColor = vec3(0.0);\n    float roughness = 1.0;\n    float metallic = 0.0;\n    switch (i) { \n    case 0:\n        break;\n    case 1: // ground\n        baseColor = vec3(1.0);\n        roughness = 0.5;\n        metallic = (1.0 - roughness) * 0.3;\n        break;\n    case 2: // bowl\n        baseColor = vec3(1.0);\n        roughness = 0.5;\n        metallic = (1.0 - roughness) * 0.3;\n        break;\n    case 3: // particles\n        baseColor = vec3(0.6, 0.05, 0.0);\n        roughness = 0.55;\n        metallic = (1.0 - roughness) * 0.3;\n        break;\n    }\n  \n    Material material;\n    material.baseColor = baseColor;\n    material.roughness = roughness;\n    material.metallic = metallic;\n    return material;\n}\n\nstruct Hit {\n    float t; \n    vec3 cellCoordinate;\n    vec3 position;\n    vec3 normal;\n    Material material;\n    float stepCount;\n};\n\nvoid particlesFromTexture(vec3 cellCoordinate, inout Particle particle1, inout Particle particle2) { \n    particlesFromTexture(iChannel0, cellCoordinate, particle1, particle2);\n}\n\nvec4 sampleDensity(vec3 position) {\n    return trilinear(iChannel1, position);\n}\n\nvec3 sampleBowlNormal(vec3 position) {\n    float epsilon = 0.001;\n    vec3 gradient = vec3(\n        bowl(position + vec3(epsilon, 0, 0)) - bowl(position + vec3(-epsilon, 0, 0)),\n        bowl(position + vec3(0, epsilon, 0)) - bowl(position + vec3(0, -epsilon, 0)),\n        bowl(position + vec3(0, 0, epsilon)) - bowl(position + vec3(0, 0, -epsilon))\n    );\n    return normalize(gradient);\n}\n\nvec3 sampleParticleNormal(vec3 position) {\n    float epsilon = 0.5;\n\tconst vec2 k = vec2(1.0, -1.0);\n    return -normalize(k.xyy * sampleDensity(position + k.xyy * epsilon).z +\n\t\t\t k.yyx * sampleDensity(position + k.yyx * epsilon).z +\n\t\t\t k.yxy * sampleDensity(position + k.yxy * epsilon).z +\n\t\t\t k.xxx * sampleDensity(position + k.xxx * epsilon).z);\n}\n\nbool testVisibility(vec3 rayOrigin, vec3 rayDirection, float threshold) {\n    float t = 0.0;    \n    for (int i = 0; i < 16; i++) {\n        vec3 currentPosition = rayOrigin + rayDirection * t;\n        float d1 = currentPosition.y + 30.0;\n        float d2 = bowl(currentPosition);\n        float d3;\n        if (all(lessThan(abs(currentPosition), halfGridSize))) {\n           // d3 = sampleDensity(currentPosition).w;\n           d3 = voxel(iChannel1, floor(currentPosition)).w;\n        } else {\n            d3 = 2.0;\n        }\n        float d = min(min(d1, d2), d3);\n        if (d < threshold) {\n            return false;\n        }\n        t += d + threshold;\n    }\n    return true;\n}\n\nfloat normalDistribution(float halfwayAngle, float roughness) {\n    float alpha = roughness * roughness;\n    float denominator = (alpha * alpha - 1.0) * halfwayAngle * halfwayAngle + 1.0;\n    denominator = pi * denominator * denominator;\n    return (alpha * alpha) / denominator;\n}\n\nfloat geometricAttenuation(float incomingAngle, float outgoingAngle, float roughness) {    \n    float k = (roughness + 1.0) * (roughness + 1.0) / 8.0;\n    return (outgoingAngle / (outgoingAngle * (1.0 - k) + k)) * (incomingAngle / (incomingAngle * (1.0 - k) + k));\n}\n\nvec3 fresnel(vec3 baseReflectance, float angle) {\n    return baseReflectance + (1.0 - baseReflectance) * pow(1.0 - angle, 5.0);\n}\n\nvec3 evaluateReflectance(Hit hit, vec3 incomingDirection, vec3 outgoingDirection) { \n    float incomingAngle = max(dot(incomingDirection, hit.normal), 0.0);\n    float outgoingAngle = max(dot(outgoingDirection, hit.normal), 0.0);\n    vec3 halfwayDirection = normalize(incomingDirection + outgoingDirection);\n    float halfwayAngle = max(dot(halfwayDirection, hit.normal), 0.0);\n    float specularAngle = max(dot(outgoingDirection, halfwayDirection), 0.0);\n    vec3 baseReflectance = mix(vec3(0.04), hit.material.baseColor, hit.material.metallic);\n    vec3 fresnelReflectance = fresnel(baseReflectance, specularAngle);\n    vec3 specularReflectance = (normalDistribution(halfwayAngle, hit.material.roughness) * geometricAttenuation(incomingAngle, outgoingAngle, hit.material.roughness) * fresnelReflectance) / max(4.0 * incomingAngle * outgoingAngle, 0.001);  \n    vec3 diffuseReflectance = (1.0 - fresnelReflectance) * (1.0 - hit.material.metallic) * hit.material.baseColor / pi;\n    return diffuseReflectance + specularReflectance;\n}\n\nvec2 fibonacci(int i, int sampleCount) {\n    const float goldenRatio = (1.0 + sqrt(5.0)) / 2.0;\n    float u = (float(i) + 0.5) / float(sampleCount);\n    float v = goldenRatio * float(i);\n    return vec2(u, v);\n}\n\nvec3 computeDirectLight(Hit hit, vec3 outgoingDirection) {\n    vec3 lightPosition = lightPosition - hit.position;\n    vec3 light = vec3(0.0);\n    vec2 offset = vec2(randFloat(), randFloat());\n    int sampleCount = 16 ;\n    for (int i = 0; i < sampleCount; i++) {\n        vec2 uv = fract(fibonacci(i, sampleCount) + offset);\n        uv = (uv * 2.0 - 1.0) * lightHalfSize;\n        vec3 samplePosition = lightPosition + vec3(uv.x, 0.0, uv.y);\n        vec3 sampleDirection = normalize(samplePosition);\n        if (!testVisibility(hit.position + hit.normal * 0.2 + sampleDirection * 2.0, sampleDirection, 0.1)) {\n            continue;\n        }\n        float samplingProbability = dot(samplePosition, samplePosition) / (abs(sampleDirection.y) * 4.0 * lightHalfSize.x * lightHalfSize.y);      \n        vec3 reflectance = evaluateReflectance(hit, sampleDirection, outgoingDirection);\n        light += lightIntensity * lightColor * (reflectance / samplingProbability) * max(dot(sampleDirection, hit.normal), 0.0);\n    }\n    return light / float(sampleCount);\n}\n\nbool raycast(vec3 rayOrigin, vec3 rayDirection, int stepCount, inout Hit hit) {\n    float maximumDistance = 300.0;\n    float t = 0.0;\n    for (int i = 0; i < stepCount; i++) {\n        if (t > maximumDistance) {\n            hit.t = maximumDistance;\n            hit.stepCount = float(i);\n            return false;\n        }\n        vec3 currentPosition = rayOrigin + rayDirection * t;\n        float d1 = currentPosition.y + 30.0;\n        int material = 1;\n        float d = d1;\n        float d2 = bowl(currentPosition);\n        if (d2 < d) {\n            material = 2;\n            d = d2;\n        } \n        float d3;\n        if (all(lessThan(abs(currentPosition), halfGridSize - 1.0))) {\n            d3 = sampleDensity(currentPosition).w;\n        } else {\n            vec3 p = abs(currentPosition) - (halfGridSize - 1.0);\n            d3 = max(max(max(p.x, p.y), p.z), 2.0);\n        }\n        if (d3 < d) {\n            material = 3;\n            d = d3;\n        }\n        float threshold = 0.001 * max(t, 1.0);\n        if (d < threshold) {\n            hit.t = t;\n            hit.position = currentPosition;\n            if (material == 1) {\n                hit.normal = vec3(0.0, 1.0, 0.0);\n            } else if (material == 2) {\n                hit.normal = sampleBowlNormal(currentPosition);\n            } else if (material == 3) {\n                hit.normal = sampleParticleNormal(currentPosition);\n            }\n            hit.material = createMaterial(material);\n            hit.stepCount = float(i);\n            return true;\n        }\n        t += d; \n    }\n    hit.t = maximumDistance;\n    hit.stepCount = float(stepCount);\n    return false;\n}\n\nvec3 trace(vec3 cameraPosition, vec3 rayDirection) {\n    Hit hit;   \n    if (!raycast(cameraPosition, rayDirection, 128, hit)) {\n        return vec3(2.0);\n    }\n    vec3 color = computeDirectLight(hit, -rayDirection);\n    float t = max(hit.t - 120.0, 0.0);\n    color = mix(color, vec3(2.0), 1.0 - exp(-0.05 * t));\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    configureBuffer(iResolution.xy);\n    uint seed = 0x578437adu; \n    randState = hash(uvec2(fragCoord), seed); \n    float yaw = cameraOrbitYaw;\n    float pitch = cameraOrbitPitch;\n    if (keyPressed(67) && iMouse.z > 0.0) {\n        float mouseSensitivity = 0.01;\n        vec2 delta = iMouse.xy - abs(iMouse.zw);\n        pitch = clamp(pitch - delta.y * mouseSensitivity, 0.0, 0.5 * pi);\n    }\n    mat3 orbitRotation = rotationAxisAngle(vec3(0.0, 1.0, 0.0), yaw);\n    orbitRotation *= rotationAxisAngle(vec3(1.0, 0.0, 0.0), pitch);\n\tvec3 cameraPosition = cameraOrbitCenter + orbitRotation * vec3(0.0, 0.0, -cameraOrbitRadius);   \n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 rayDirection = orbitRotation * normalize(vec3(uv, 1.5)); \n    vec3 color = trace(cameraPosition, rayDirection);\n    color = aces(color);\n    color = pow(color, vec3(1.0 / 2.2));\n\tfragColor = vec4(color, 1.0);  \n}","name":"Buffer D","description":"","type":"buffer"}]}