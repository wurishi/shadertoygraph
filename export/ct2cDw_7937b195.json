{"ver":"0.1","info":{"id":"ct2cDw","date":"1691855053","viewed":124,"name":"Coral Shader Using Functions","username":"qg64","description":"Interesting coral pattern I saw on a Twitter post.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["patterns","maths","corals"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Original Post: Corals by Hamid Yeganeh\n    Link: https://twitter.com/naderi_yeganeh/status/1690296100496838656\n    \n    Translation to GLSL by qg64.\n*/\n\n/* Prefer high precision */\nprecision highp float; \n\n/* The original post had 150, but WebGL begins struggling around 15-20, the higher this number, the more detailed the image. */\n#define MAX_ITER 10.0\n\nfloat F(in float x)\n{\n    return exp(-exp(-1000.0*x))*pow(abs(x), exp(-exp(1000.0*(x-1.0))));\n}\n\nfloat K(in float x, in float y)\n{\n    float t1 = 0.5 + 2.0*(y - 0.6);\n    float t2 = (1.0 - 0.3*pow(sin(120.0*(y - 0.6)*exp(10.0*(x-1.0)*(x-1.0))), 8.0));\n    float exp_t1 = 170.0 - 160.0*exp(-500.0 * pow(x - 0.95, 4.0));\n    float exp_t2 = 0.6*(x-1.0)*(x-1.0) + 14.0 * (100.0 / (100.0 - 99.0*exp(-10.0*pow(x-1.15, 2.0))))*pow(abs(y-0.6), 2.0 + 3.0*(x-0.6)) - 0.05;\n    return t1*t2*exp(-exp(exp_t1*exp_t2));\n}\n\nfloat Q(in float x, in float y, in float s)\n{\n    return y + 0.6*x + 0.1*(x+1.0)*(x+1.0) - 1.8*(1.0 - pow((1.0 - (s/150.0)), 1.6)) + 1.7 + 0.3*sin(s*s*s);\n}\n\nfloat P(in float x, in float y, in float s)\n{\n    return sin(5.0*(x + 0.2*(sin(7.0*s*s) + sin(x + s*s) - 3.0)*y + sin(s*s) - 0.08*sin(5.0*y + sin(4.0*s*s))));\n}\n\nfloat J(in float x, in float y, in float s)\n{\n    if(s < 1.0)\n        return 0.0;\n    \n    float P3 = abs(pow(P(x,y,s), 3.0));\n    float Q4 = pow(Q(x,y,s), 4.0);\n    return exp(-exp(50.0 * (30.0*P3 + Q4 - 0.6)));\n}\n\nfloat U(in float x, in float y, in float s)\n{\n    float result = 0.0;\n    for(float r = 0.0; r <= MAX_ITER; r += 1.0)\n    {\n        float P_computed = P(x,y,r);\n        float Q_computed = Q(x,y,r);\n        float J_computed = J(x,y,r);\n        \n        float P3 = abs(pow(P_computed, 3.0));\n        float Q4 = pow(Q_computed, 4.0);\n        \n        float c1 = exp(100.0 * (30.0 * P3 + Q4 - 0.6));\n        float c2 = exp(-5.0 * (20.0 * P3 + pow((1.0/50.0) + Q_computed, 4.0) - 0.6));\n        float c3 = exp(-1000.0*Q_computed);\n\n        float t1 = 4.0 * exp(-(c1+c2+c3));\n\n        float t2 = 1.0 + 0.05 * (2.0 - s) * (2.0 - s) + 0.2 * sin(5.0*(1.0 + s)*r);\n        float t3 = 0.3 * Q_computed + exp(-exp(30.0 * P3 + Q4 - 0.6));\n        \n        float t4 = (1.0 + P_computed)*J_computed;\n        float t5 = 1.0;\n\t    \n        for(float k = 0.0; k < r; k += 1.0)\n        {\n            t5 *= 1.0 - J(x,y,k);\n        }\n\n        result += (t1 + t2*t3)*t4*t5;\n    }\n    return result;\n}\n\nfloat H(in float x, in float y, in float s)\n{\n    float c1 = (1.0 + pow(-1.0, s)*(s*0.5)) * U(x,y,s);\n    float c2 = (0.1 + s*0.25 + (y - (x*x)*0.33 - 0.5)*((0.04 + 0.056*(s*s - s))));\n    float c3 = 100.0 * ((sqrt(pow(x-0.82, 2.0) + pow(y - 0.6, 2.0))) - 0.01);\n    float c4 = 1.0;\n    for(float r = 1.0; r <= MAX_ITER; r += 1.0)\n    {\n        c4 *= (1.0 - J(x,y,r)) + (2.5 - (1.75*s))*K(x,y) - exp(-exp(c3)); \n    }\n    return c1 + c2*c4;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    /* Zoom out */\n    uv *= 2.0;\n    /* Essentially, the H(x,y,s) expects x mapped between -2.5,2.5 and y mapped between 0 to 2 */\n    float x = (uv.x - 0.5) * 2.5;\n    /* GLSL coordinates are inverse of normal math coordinations in Y-axis */\n    float y = 2.05*(uv.y - 1.0);\n    fragColor = vec4(F(H(x,y,0.0)), F(H(x,y,1.0)), F(H(x,y,2.0)), 1.0);\n}","name":"Image","description":"","type":"image"}]}