{"ver":"0.1","info":{"id":"NdBBWG","date":"1649245330","viewed":86,"name":"metaball 3d","username":"leoamsa","description":"3d project","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// float sdSphere  (vec3 p, float r)\n    // return length(p) - r (distance entre un point et la sphere)\n    \n// utilisation du ray tracing => calcule des distances avec les coordonnées z\n// Il faut générer des rayons et le repère de la caméra (origine (0.0.0))\n// repère trois axes => u => haut de la caméra (mode portrait ou paysage) v=> vue de la caméra \n// r=> vecteur perpendiculaire au deux autres\n\n// -1            0       p  1\n//  |------------x------x---| ecran de taille -1,1\n//   \\                     /\n//    \\                   /\n//     \\                 /\n//      \\               /\n//       \\             /\n//        \\           / \n//         \\---------/ angle alpha\n//          \\   ^   /                \n//           \\  |v /\n//            \\ | /\n//             \\|/________>\n//              e        r\n\n#define R iResolution.xy\n#define DIST_MIN 0.5 // minimum distance to objects\n#define DIST_MAX 30.0 // maximum distance to objects\n#define RAY_MARCH_STEPS 1000\n#define RAY_MARCH_PRECI 0.001\n#define PI 3.14159265359\n#define TEXTURE_RES 256.0 // texture resolution\n\n\n// ray structure\nstruct Ray {\n    vec3 o; // origin\n    vec3 d; // direction\n};\n\nstruct Surface {\n    float t; // surface distance\n    vec3 c; // surface color\n};\n\nfloat sdSphere( vec3 p, float s ) {\n  return length(p)-s;\n}\n\n\nfloat noise(vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    // pour passer d'une interpolation purement linéaire à une transition plus arrondie/organique.\n    // Permet d'obtenir un resultat plus lisse\n    f = f*f*(3.0-2.0*f);\n    \n    // astuce d'empilement de volume de bruit : couche g = couche r décalée de 37x17 pixels \n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n    vec2 rg = textureLod( iChannel0, (uv+ 0.5)/TEXTURE_RES, 0.0 ).yx;\n\t\n\t// on lisse les valeurs\n    return mix( rg.x, rg.y, f.z);\n}\n\n\n// Smooth union\nSurface sminSurf( Surface s1, Surface s2, float k )\n{\n    // exp2 => 2^x\n    float res = exp2( -k*s1.t ) + exp2( -k*s2.t  );\n    float dist = -log2( res )/k;\n    \n    // plus le distDiff est petit plus\n    float distDiff = abs(s2.t - s1.t);    \n    vec3 m = (s1.c + s2.c)/2.;\n\n    vec3 col = s1.t < s2.t ? s1.c : s2.c;\n    //mix(a,b,c) => interpolation btw m and col using distDiff  \n    // si le pixel est assez proche des deux spheres on colorie en vert\n    return Surface(dist,mix(m,col,distDiff));\n}\n\n\nSurface scene(in vec3 p) {\n    float time = iTime*0.4;\n        \n    vec3 pos1 = p+(vec3(5.25,0.,0.)*0.5-cos(iTime)*0.5);\n    vec3 pos2 = p+(vec3(-5.25,0.,0.)*0.5+cos(iTime)*0.5);\n    float v = -.3*noise(vec3(p*0.4+time*1.35));\n\n    // cyan sphere\n    float d1 = sdSphere(pos1,1.)+v;\n    // yellow sphere\n    float d2 = sdSphere(pos2,1.)+v;\n\n    Surface s1 = Surface(d1, vec3(0.,1.,1.));\n    Surface s2 = Surface(d2, vec3(1.,1.,0.));\n\n    return sminSurf(s1,s2,0.5);\n}\n\nSurface march(in Ray r, vec2 uv) {\n    float t = DIST_MIN;\n\n    for(int i=0;i<RAY_MARCH_STEPS,t<=DIST_MAX;++i) {\n        Surface s = scene(r.o+t*r.d);\n\n        if(s.t<RAY_MARCH_PRECI) {\n            return Surface(t+s.t,s.c);\n        }\n\n        t = t+s.t;\n    }\n    \n    // couleur de fond \n    float b = (-0.5 * uv.y + 0.5) * cos(uv.x);\n    vec3 col = vec3(0, 0, 0);\n    col.r = b ; col.g = b  * sin(iTime);\n    \n    return Surface(DIST_MAX,col * 1.);\n}\n\nvec3 normalAt(in Surface s,in Ray r) {\n    const float e = 0.01;\n    vec3 p = r.o+s.t*r.d;\n    float nx = scene(vec3(p.x+e,p.y,p.z)).t-scene(vec3(p.x-e,p.y,p.z)).t;\n    float ny = scene(vec3(p.x,p.y+e,p.z)).t-scene(vec3(p.x,p.y-e,p.z)).t;\n    float nz = scene(vec3(p.x,p.y,p.z+e)).t-scene(vec3(p.x,p.y,p.z-e)).t;\n\n    return normalize(vec3(nx,ny,nz));\n}\n\nRay camRay(in vec2 p) {\n    // p is the current pixel coord, in [-1,1]\n\n    // normalized mouse position\n    vec2 m = iMouse.xy/R.y;\n    \n    // camera position\n    float DP = 10.;\n    float d = DP/2.;\n    //vec3 ro = vec3(d*cos(6.0*m.x),DP/5.0,d*sin(6.0*m.x) );\n    //vec3 ro = vec3(d*cos(6.0*m.x),(DP/2.0)*(m.y*4.),d*sin(6.0*m.x) );\n\n    vec3 ro = vec3(0.,0.,7.);\n\n    // target point\n    //vec3 ta = vec3(0.0,DP/10.0,0.0);\n    vec3 ta = vec3(0.0,0.0,0.0);\n\n    // camera view vector\n    vec3 cw = normalize(ta-ro);\n\n    // camera up vector\n    vec3 cp = vec3(0.0,1.0,0.0);\n\n    // camera right vector\n    vec3 cu = normalize(cross(cw,cp));\n\n    // camera (normalized) up vector\n    vec3 cv = normalize(cross(cu,cw));\n    \n    float fovDeg = 45.;\n    float fovRad = (fovDeg/360.)*2.*PI;\n    float zf = 1./tan(fovRad/2.);\n    \n    // view vector, including perspective (the more you multiply cw, the less fovy)\n    vec3 rd = normalize(p.x*cu + p.y*cv*(R.y/R.x) + 1.25*cw);\n\n    return Ray(ro,rd);\n}\n\nvec3 shade(in Surface surf, in Ray ray) {\n    // tous les vecteurs nécessaires au shading\n    vec3 n = normalAt(surf,ray);\n    vec3 l = normalize(vec3(1.));\n    vec3 v = ray.d;\n    vec3 r = reflect(l,n);\n    \n    // parametres du materiau\n    vec3 kd = surf.c;\n    vec3 ks = vec3(.3); // taches lumineuses\n    float s = 2.5;\n    \n    // coeficients diffus et spéculaires\n    float diff = max(dot(n,l),0.25);\n    float spec = pow(max(dot(r,v),0.95),s);\n    \n    return kd*diff + ks*spec;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord / R.xy)*2.-1.;\n    \n    Ray r = camRay(uv);\n    Surface s = march(r, uv);\n    vec3 c = s.c;\n    \n    //float b;\n    if(s.t<DIST_MAX) {\n        c = shade(s,r);\n    }\n\n    fragColor = vec4(c,1.0);\n}","name":"Image","description":"","type":"image"}]}