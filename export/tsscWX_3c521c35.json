{"ver":"0.1","info":{"id":"tsscWX","date":"1586307204","viewed":439,"name":"Spherical Harmonics functions","username":"jesusdz","description":"Two scenes: 3D shapes of spherical harmonics generated on the fly / sphere illuminated with SH coefficients after projection from Cubemap. Set the PERFORMANCE define to 1 to use precomputed/simplified version of the first 9 SH formulas.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sphericalharmonics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Performance setting:\n// 0 - SH bases computation from formulae\n// 1 - Precomputed factors for 9 first bases\n#define PERFORMANCE     1\n\n// Scene selection:\n// 0 - Renders first 3 SH bands (9 bases)\n// 1 - SH usage (projects Cubemap onto 9 SH bases\n//     and uses them for illumination)\n#define SCENE_ID        0\n\n\n#define HPI 1.57079632679\n#define PI  3.14159265359 \n#define TAU 6.28318530718\n#define EPS 0.001\n#define FAR 9.0\n\n    \n//////////////////////////////////////////////////////////////////////\n// Spherical harmonics bases\n//////////////////////////////////////////////////////////////////////\n\n#if PERFORMANCE==0\n\n// table of factorials\nint fact[13] = int[13](\n1,\n1,\n2,\n6,\n24,\n120,\n720,\n5040,\n40320,\n362880,\n3628800,\n39916800,\n479001600);\n\n// associated legendre polynomial\nfloat P(int l, int m, float x)\n{\n    float pmm = 1.0;\n    if (m > 0)\n    {\n        float somx2 = sqrt((1.0-x)*(1.0+x));\n        float fact  = 1.0;\n        for (int i = 1; i <= m; i++)\n        {\n            pmm *= (-fact) * somx2;\n            fact += 2.0;\n        }\n    }\n    if (l == m) return pmm;\n    float pmmp1 = x * float(2*m + 1) * pmm;\n    if (l == m+1) return pmmp1;\n    float pll = 0.0;\n    for (int ll = m+2; ll <= l; ll++)\n    {\n        pll = (float(2*ll-1)*x*pmmp1-float(ll+m-1)*pmm) / float(ll - m);\n        pmm = pmmp1;\n        pmmp1 = pll;\n    }\n    return pll;\n}\n\n// renormalisation constant for SH function\nfloat K(int l, int m)\n{\n    int lmm = l - m;\n    int lpm = l + m;\n#if 0\n    int factlmm = 1;\n    int factlpm = 1;\n    for (int i = 2; i <= lmm; i++)\n    {\n        factlmm *= i;\n    }\n    for (int i = 2; i <= lpm; i++)\n    {\n        factlpm *= i;\n    }\n#else\n    // better use precomputed factorials than\n    // perform the calculation here...\n    int factlmm = fact[lmm];\n    int factlpm = fact[lpm];\n#endif\n    \n    float temp = float((2 * l + 1)*factlmm) / (4.0 * PI * float(factlpm));\n    //return sqrt(pow(-1.0, float(m))*temp);\n    return sqrt(temp);\n}\n\n// returns a sample of a spherical harmonic basis\n// l     the band (first one is 0)\n// m     the basis in the band in the range [-l, l]\n// theta in the range [0, PI]\n// phi   in the range [0, 2PI]\nfloat y(int l, int m, float theta, float phi)\n{\n    const float sqrt2 = sqrt(2.0);\n    if      (m==0) return K(l, m) * P(l, m,cos(theta));\n    else if (m >0) return K(l, m) * P(l, m,cos(theta)) * sqrt2 * cos( float(m)*phi);\n    else           return K(l,-m) * P(l,-m,cos(theta)) * sqrt2 * sin(-float(m)*phi);\n    return 0.0;\n}\n\n// returns a sample of a spherical harmonic basis\n// d     direction vector\n// l     the band (first one is 0)\n// m     the basis in the band in the range [-l, l]\nfloat SH(in vec3 d, in int l, in int m)\n{\n    float theta = atan(length(d.xy), d.z);\n    float phi   = atan(d.y, d.x);\n    return y(l, m, theta, phi);\n}\n\n// distance to a spherical harmonic base in the radius direction\nfloat dSH(in vec3 pos, in vec3 o, in int l, in int m)\n{\n    vec3 d = pos - o;\n    return length(d) - abs(SH(normalize(d), l, m));\n}\n\n// normal of a spherical harmonic base at some point on its surface\nvec3 nSH(in vec3 pos, in vec3 o, in int l, in int m)\n{\n    vec2 e = vec2(0.001, 0.0);\n    vec3 n = normalize(vec3(dSH(pos + e.xyy, o, l, m) - dSH(pos - e.xyy, o, l, m),\n                            dSH(pos + e.yxy, o, l, m) - dSH(pos - e.yxy, o, l, m),\n                            dSH(pos + e.yyx, o, l, m) - dSH(pos - e.yyx, o, l, m)));\n    return n;\n}\n\n#else\n\n// Real spherical harmonics constants. See:\n// https://en.wikipedia.org/wiki/Table_of_spherical_harmonics\n#define k0 0.28209479177\n#define k1 0.48860251190\n#define k2 1.09254843059\n#define k3 0.31539156525\n#define k4 0.54627421529\n\nfloat y00 (in vec3 d) { return  k0; }\nfloat y11_(in vec3 d) { return -k1 * d.y; }\nfloat y10 (in vec3 d) { return  k1 * d.z; }\nfloat y11 (in vec3 d) { return -k1 * d.x; }\nfloat y22_(in vec3 d) { return  k2 * d.x * d.y; }\nfloat y21_(in vec3 d) { return -k2 * d.y * d.z; }\nfloat y20 (in vec3 d) { return  k3 * (-d.x*d.x-d.y*d.y+2.0*d.z*d.z); }\nfloat y21 (in vec3 d) { return -k2 * d.x * d.z; }\nfloat y22 (in vec3 d) { return  k4 * (d.x*d.x - d.y*d.y); }\n\n#endif\n\n\n//////////////////////////////////////////////////////////////////////\n// Sphere\n//////////////////////////////////////////////////////////////////////\n\nfloat dsphere(in vec3 pos, in vec3 o, in float r)\n{\n    return length(pos - o) - r;\n}\n\nvec3 nsphere(in vec3 pos, in vec3 o)\n{\n    return normalize(pos - o);\n}\n\n\n#if SCENE_ID == 0\n\n//////////////////////////////////////////////////////////////////////\n// Scene composition: rendering of 9 SH bases\n//////////////////////////////////////////////////////////////////////\n\n#define HSEP 1.2\n#define VSEP 1.5\n\n// distance map\n// .x = signed distance\n// .y = spherical harmonic value from the nearest base\nvec2 map(in vec3 pos)\n{\n    float t;\n    float tmin = 9999.0;\n    float shmin;\n    float sh;\n    float f;\n    vec3  v = vec3(0.0);\n    \n#ifdef PERFORMANCE\n    \n    #define updateClosestSH(shfunc, center) \\\n    \tv = pos - center; \\\n        sh = shfunc(normalize(v).xzy); \\\n        t = length(v) - abs(sh); \\\n        f = step(t, tmin); \\\n        shmin = sh * f + shmin * (1.0 - f); \\\n    \ttmin = min(tmin, t);\n    \n\tupdateClosestSH(y00 , vec3( 0.0*HSEP,  1.0*VSEP, 0.0));\n    updateClosestSH(y11_, vec3(-1.0*HSEP,  0.0*VSEP, 0.0));\n    updateClosestSH(y10 , vec3( 0.0*HSEP,  0.0*VSEP, 0.0));\n    updateClosestSH(y11 , vec3( 1.0*HSEP,  0.0*VSEP, 0.0));\n    updateClosestSH(y22_, vec3(-2.0*HSEP, -1.0*VSEP, 0.0));\n    updateClosestSH(y21_, vec3(-1.0*HSEP, -1.0*VSEP, 0.0));\n    updateClosestSH(y20 , vec3( 0.0*HSEP, -1.0*VSEP, 0.0));\n    updateClosestSH(y21 , vec3( 1.0*HSEP, -1.0*VSEP, 0.0));\n    updateClosestSH(y22 , vec3( 2.0*HSEP, -1.0*VSEP, 0.0));\n    \n#else\n    \n    #define updateClosestSH(l, m, center) \\\n    \tv = pos - center; \\\n        sh = SH(normalize(v).xzy, l, m); \\\n        t = length(v) - abs(sh); \\\n        f = step(t, tmin); \\\n        shmin = sh * f + shmin * (1.0 - f); \\\n    \ttmin = min(tmin, t);\n    \n\tupdateClosestSH(0, 0, vec3( 0.0*HSEP,  1.0*VSEP, 0.0));\n    updateClosestSH(1,-1, vec3(-1.0*HSEP,  0.0*VSEP, 0.0));\n    updateClosestSH(1, 0, vec3( 0.0*HSEP,  0.0*VSEP, 0.0));\n    updateClosestSH(1, 1, vec3( 1.0*HSEP,  0.0*VSEP, 0.0));\n    updateClosestSH(2,-2, vec3(-2.0*HSEP, -1.0*VSEP, 0.0));\n    updateClosestSH(2,-1, vec3(-1.0*HSEP, -1.0*VSEP, 0.0));\n    updateClosestSH(2, 0, vec3( 0.0*HSEP, -1.0*VSEP, 0.0));\n    updateClosestSH(2, 1, vec3( 1.0*HSEP, -1.0*VSEP, 0.0));\n    updateClosestSH(2, 2, vec3( 2.0*HSEP, -1.0*VSEP, 0.0));\n    \n#endif\n    \n    return vec2(tmin, shmin);\n}\n\nvec3 shade(in vec3 pos, in vec3 obs)\n{\n    // normal\n    vec2 eps = vec2(0.001, 0.0);\n    vec3 n = normalize(vec3(map(pos + eps.xyy).x - map(pos - eps.xyy).x,\n                            map(pos + eps.yxy).x - map(pos - eps.yxy).x,\n                            map(pos + eps.yyx).x - map(pos - eps.yyx).x));\n    // color\n\tvec3 colAquamarine = vec3(0.239216, 0.858824, 0.976471);\n\tvec3 colGoldenrod = vec3(0.917647, 0.817647, 0.478431);\n    vec2 rmap = map(pos);\n    vec3 col1 = colAquamarine * (0.1 + abs(rmap.y));\n    vec3 col2 = colGoldenrod * (0.1 + abs(rmap.y));\n    vec3 col  = mix(col1, col2, step(0.0, rmap.y));\n    \n    // light, view, and half vectors\n    vec3 l = normalize(vec3(-1.0, 3.0, 2.0));\n    vec3 v = normalize(obs - pos);\n    vec3 h = normalize(v + l);\n    \n    // light composition\n    vec3 namb = n;\n    namb.y = 0.5 * namb.y + 1.0;\n    vec3 amb = col * dot(namb, vec3(0.0, 1.0, 0.0));\n    vec3 diff = col * max(0.0,  dot(n, l)) * 0.3;\n    vec3 spec = vec3(0.2) * pow(max(0.0, dot(n, h)), 8.0) * 0.2;\n    return amb + diff + spec;\n}\n\n#elif SCENE_ID == 1\n\n//////////////////////////////////////////////////////////////////////\n// Scene composition: rendering of a sphere using SH illumination\n//////////////////////////////////////////////////////////////////////\n\n// 9 first SH bases' coefficients (to be projected from cubemap)\nvec3 SHCoefs[9] = vec3[](vec3(0.0), vec3(0.0), vec3(0.0),\n                         vec3(0.0), vec3(0.0), vec3(0.0),\n                         vec3(0.0), vec3(0.0), vec3(0.0));\n\n// pseudo-random number generator\nvec2 hash( vec2 p )\n{\n\tp = vec2(dot(p,vec2(127.1,311.7)),\n             dot(p,vec2(269.5,183.3)));\n\treturn fract(sin(p)*43758.5453);\n}\n\n// Projection of env. light on SH coefficients (should be precomputed)\nvoid projectCubemapOnSHCoefficients()\n{\n    #define SAMPLES 8\n    \n    float invN = 1.0/float(SAMPLES);\n    for (int xx = 0; xx < SAMPLES; ++xx)\n        for (int yy = 0; yy < SAMPLES; ++yy)\n        {\n            vec2 r = (vec2(float(xx), float(yy)) +\n                      hash(vec2(float(xx), float(yy)))) * invN;\n            //float theta = 2.0 * acos(sqrt(1.0 - r.x)); // This is as in 'Robin Green SH the gritty details' doc\n            float theta = acos(1.0 - 2.0 * r.x);\n            float phi = 2.0 * PI * r.y;\n            vec3 dir = vec3(sin(theta)*cos(phi),\n                            cos(theta),\n                            sin(theta)*sin(phi));\n            \n            vec3 texcol = texture(iChannel0, dir).rgb;\n            #if PERFORMANCE==1\n\t\t\tSHCoefs[0] += y00 (dir.xzy) * texcol;\n\t\t\tSHCoefs[1] += y11_(dir.xzy) * texcol;\n\t\t\tSHCoefs[2] += y10 (dir.xzy) * texcol;\n\t\t\tSHCoefs[3] += y11 (dir.xzy) * texcol;\n\t\t\tSHCoefs[4] += y22_(dir.xzy) * texcol;\n\t\t\tSHCoefs[5] += y21_(dir.xzy) * texcol;\n\t\t\tSHCoefs[6] += y20 (dir.xzy) * texcol;\n\t\t\tSHCoefs[7] += y21 (dir.xzy) * texcol;\n\t\t\tSHCoefs[8] += y22 (dir.xzy) * texcol;\n            #else\n            for (int l = 0; l < 3; ++l)\n                for (int m = -l; m <= l; ++m)\n                {\n                    int index = l*(l+1)+m;\n                    SHCoefs[index] += SH(dir.xzy, l, m) * texcol;\n                }\n            #endif\n        }\n    \n    // divide result by weight and total number of samples\n    float factor = 4.0 * PI / float(SAMPLES * SAMPLES);\n    for (int i = 0; i < 9; ++i)\n    {\n        SHCoefs[i] = SHCoefs[i] * factor;\n    }\n}\n\n// distance map\n// .x = signed distance\n// .y = nothing useful\nvec2 map(in vec3 pos)\n{\n    float t = 9999.0;\n    t = min(t, dsphere(pos, vec3(0.0), 1.0));\n    return vec2(t, 0.0);\n}\n\nvec3 shade(in vec3 pos, in vec3 obs)\n{\n    // normal\n    vec2 eps = vec2(0.001, 0.0);\n    vec3 n = normalize(vec3(map(pos + eps.xyy).x - map(pos - eps.xyy).x,\n                            map(pos + eps.yxy).x - map(pos - eps.yxy).x,\n                            map(pos + eps.yyx).x - map(pos - eps.yyx).x));\n \n    // material color\n    vec3 col = vec3(1.0, 1.0, 1.0);\n    \n    // ambient light using the computed SH coefficients\n    vec3 lightColor = vec3(0.0);\n    \n    // calc amount of light coming from the normal direction\n    #if PERFORMANCE==1\n    \n    lightColor += SHCoefs[0] * y00 (n.xzy);\n    lightColor += SHCoefs[1] * y11_(n.xzy);\n    lightColor += SHCoefs[2] * y10 (n.xzy);\n    lightColor += SHCoefs[3] * y11 (n.xzy);\n    lightColor += SHCoefs[4] * y22_(n.xzy);\n    lightColor += SHCoefs[5] * y21_(n.xzy);\n    lightColor += SHCoefs[6] * y20 (n.xzy);\n    lightColor += SHCoefs[7] * y21 (n.xzy);\n    lightColor += SHCoefs[8] * y22 (n.xzy);\n    \n    #else\n    \n    for (int l = 0; l < 3; ++l) {\n        for (int m = -l; m <= l; ++m) {\n            int index = l*(l+1)+m;\n            lightColor += SHCoefs[index] * SH(n.xzy, l, m);\n        }\n    }\n    \n    #endif\n    \n    return col * lightColor;\n}\n\n#endif\n\n\n//////////////////////////////////////////////////////////////////////\n// Ray marcher\n//////////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    // camera\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 s = vec3(2.0 * uv - 1.0, 0.0) * 1.5;\n    s.x *= iResolution.x / iResolution.y;\n    \n    vec3 d = normalize(s - vec3(0.0, 0.0, 2.0));\n    \n    vec2 mouse = (iMouse.y == 0.0) ? vec2(0) :(-(2.0 * iMouse.xy / iResolution.xy - 1.0));\n    vec3 c = vec3(0.0, 0.0, 0.0);\n    vec3 o = c + vec3(cos(mouse.y * HPI) * sin(mouse.x * PI),\n                  sin(mouse.y * HPI),\n                  cos(mouse.y * HPI) * cos(mouse.x * PI)\n        ) * 5.0;\n    \n    vec3 ww = normalize(o - c);\n    vec3 uu = normalize(cross(vec3(0.0, 1.0, 0.0), ww));\n    vec3 vv = cross(ww, uu);\n    d = mat3(uu, vv, ww) * d;\n    \n    // ray marching\n    float t = 0.0;\n    float sd = 0.0;\n    \n    vec3 p = vec3(0.0);\n    \n    for (int i = 0; i < 200; ++i)\n    {\n        t += 0.3 * sd;\n        p = o + t * d;   \n        sd = map(p).x;\n        \n        if (sd < EPS || t > FAR)\n        {\n            break;\n        }\n    }\n\n    // background\n#if SCENE_ID == 0\n    vec3 col = vec3(1.0 - length(s)*0.2);\n#elif SCENE_ID == 1\n    vec3 col = texture(iChannel0, d).rgb;\n#endif\n    \n    // shading\n    if (t < FAR)\n    {\n#if SCENE_ID == 1\n        projectCubemapOnSHCoefficients();\n#endif\n        \n    \tcol = shade(p, o);\n    }\n    \n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}