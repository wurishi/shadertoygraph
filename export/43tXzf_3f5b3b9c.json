{"ver":"0.1","info":{"id":"43tXzf","date":"1719365177","viewed":68,"name":"easy spherical harmonic lighting","username":"sam_izdat","description":"Minimal SH lighting. \nI did not author this approach or select the parameters - just reproduced someone's example. According to my notes, may have been by Morgan McGuire of http://graphicscodex.com, but I'm not sure and can't find the original. ","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sphericalharmonics","sh"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Number of azimuth & altitude segments on sphere:\n#define N_PHI 16\n#define N_THETA 16\n\nconst float N_SAMPLES = float(N_PHI) * float(N_THETA);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  const float N_SAMPLES = float(N_PHI) * float(N_THETA);\n  SH sh_probe[3];\n  sh_probe[0] = SH(0., 0., 0., 0.);\n  sh_probe[1] = SH(0., 0., 0., 0.);\n  sh_probe[2] = SH(0., 0., 0., 0.);\n  DirSample samp;\n\n  // Diffuse reflectance, outputs\n  vec3 base_color = vec3(1.0);\n  vec3 col_right, col_left;\n\n  // Sphere\n  vec2 px = vec2(mod(fragCoord.x, iResolution.x * 0.5) - iResolution.x * 0.25, fragCoord.y - iResolution.y * 0.5) * 0.6;\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  vec3 normal = intersect_sphere(px, 0.25 * min(iResolution.x, iResolution.y));    \n  normal = normalize(normal.xyz);\n  \n  // Spherical coordinates\n  float theta = atan(-normal.y, -normal.x) + PI;\n  float phi = acos(normal.z);\n\n  // LEFT: Integrate radiance directly\n  for (int i_theta = 0; i_theta < N_THETA; i_theta++) {\n    for (int i_phi = 0; i_phi < N_PHI; i_phi++) {\n      samp.wi = jk_to_vec(i_phi, i_theta, N_PHI, N_THETA);\n      samp.radiance = texture(iChannel0, samp.wi).rgb;\n      col_left += base_color * max(dot(normal.xyz, samp.wi), 0.) * samp.radiance;\n    }\n  }\n  col_left *= (4. / N_SAMPLES); // 4 because sampling sphere, not hemisphere\n\n  // RIGHT: Sample with SH probe, then evaluate probe\n  for (int i_theta = 0; i_theta < N_THETA; i_theta++) {\n    for (int i_phi = 0; i_phi < N_PHI; i_phi++) {        \n      samp.wi = jk_to_vec(i_phi, i_theta, N_PHI, N_THETA);\n      samp.radiance = texture(iChannel0, samp.wi).rgb;\n      compute_sh_probe(samp, sh_probe);\n    }\n  }\n  for ( int i = 0; i < 3; i++){ convert_to_irradiance_probe(sh_probe[i]); }  \n  col_right = normal.xyz == vec3(0.)\n    ? vec3(0.) \n    : shade(sh_probe, normal.xyz, base_color) * (4. / N_SAMPLES);\n  \n  // Output\n  vec3 col = (uv.x < 0.5) ? col_left: col_right;\n  fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI                  3.141592654\n#define FOUR_PI             12.5663706144\n#define TAU                 6.28318530718\n#define PI_OVER_2           1.57079632679\n#define PI_OVER_4           0.78539816339\n#define THREE_PI_OVER_4     2.35619449019\n\n// SH types (just because)\n//========================\n\n#define SH vec4\nstruct DirSample {\n    vec3 wi;\n    vec3 radiance;\n};\n\n// SH params\n//==========\n\nconst float sh_sharpness = 1.0;\nconst float sh_cos_wt_int_order2 = 0.95; \nconst float sh_norm_factor = (PI / sh_cos_wt_int_order2);\n\n// SH logic\n//=========\n\nSH project_to_sh(vec3 direction) {\n    const float p_1_1 = -0.488602511902919920;\n    return vec4(\n        // l=0, m=0 \n        0.282094791773878140,\n\n        // l=1, m=0\n        0.488602511902919920 * direction.z,\n\n        // l=1, m=-1\n        p_1_1 * direction.y,\n\n        // l=1, m=+1\n        p_1_1 * direction.x);\n}\n\nvoid convert_to_irradiance_probe(inout SH sh_l) {\n    const float sh_c0 = (2.0 - sh_sharpness) * 1.0;\n    const float sh_c1 = sh_sharpness * 2.0 / 3.0;\n    sh_l *= vec4(sh_c0, sh_c1, sh_c1, sh_c1);\n}\n\nvec3 shade(SH sh_probe[3], vec3 normal, vec3 surf_reflectivity) {\n    vec4 sh_normal = project_to_sh(normal);\n    vec3 result;\n    for (int c = 0; c < 3; ++c) { result[c] = dot(sh_probe[c], sh_normal); }\n    return (max(result, vec3(0., 0., 0.))) * surf_reflectivity;\n}\n\nvoid compute_sh_probe(DirSample wi, inout SH sh_probe[3]) {\n    vec4 light_sh = project_to_sh(vec3(wi.wi)) * sh_norm_factor;\n    for (int c = 0; c < 3; ++c) { sh_probe[c] += light_sh * wi.radiance[c]; }\n}\n\n\n// Not directly SH-related\n//========================\n\nvec3 intersect_sphere(vec2 pix, float size) {\n    vec2 uv = pix / size;\n    float offset = uv.x * uv.x + uv.y * uv.y;\n    return (offset > 1.) ? vec3(0.) : vec3(uv, sqrt(1. - offset));\n}\n\nfloat k_to_theta(float k, float n_theta) {\n    float theta = k * (TAU / n_theta);\n    return mod(theta, TAU);\n}\n\nfloat j_to_phi(float j, float n_phi) {\n    return j * (PI / (float(n_phi)));\n}\n\nivec2 vec_to_jk(float theta, float phi, int n_phi, int n_theta){\n    int j = int(round((phi * (float(n_phi) - 1.)) / PI));\n    int k = int(mod(round((theta * float(n_theta)) / TAU), float(n_theta)));\n    return ivec2(j, k);\n}\n\nvec3 jk_to_vec(int j, int k, int n_phi, int n_theta) {\n    float phi_h = j_to_phi(float(j), float(n_phi));\n    float theta_h = k_to_theta(float(k), float(n_theta));\n    return vec3(sin(phi_h) * cos(theta_h), sin(phi_h) * sin(theta_h), cos(phi_h));\n}\n\nvec3 discretize_vec(float theta, float phi, int n_phi, int n_theta){  \n    ivec2 jk = vec_to_jk(theta, phi, n_phi, n_theta);\n    float phi_h = float(jk.x) * (PI / (float(n_phi) - 1.));\n    float theta_h = float(jk.y) * (TAU / float(n_theta));    \n    return vec3(sin(phi_h) * cos(theta_h), sin(phi_h) * sin(theta_h), cos(phi_h));\n}\n\n// Silly stuff\n//=============\n\nfloat fast_sqrt(float x_in)\n{\n    int x = floatBitsToInt(x_in);\n    x = 0x1FBD1DF5 + (x >> 1);\n    return intBitsToFloat (x);\n}\n\nfloat sloppy_acos(float x) {\n   float res = -0.156583 * abs(x) + PI_OVER_2;\n   res *= fast_sqrt(1. - abs(x));\n   return x > 0. ? res : PI - res;\n}\n\nfloat sloppier_acos(float x) {\n   return (-0.69813170079773212 * x * x - 0.87266462599716477) * x + 1.5707963267948966;\n}\n\nfloat sloppy_atan(float x) {\n    return PI_OVER_4 * x + 0.273 * x * (1. - abs(x));\n}\n\n// https://dspguru.com/dsp/tricks/fixed-point-atan2-with-self-normalization/\nfloat sloppy_atan2(float y, float x)\n{\n   float abs_y = abs(y)+1e-10;\n   float r = x >= 0. ? (x - abs_y) / (x + abs_y) : (x + abs_y) / (abs_y - x);\n   float angle =  x >= 0. ? PI_OVER_4 - PI_OVER_4 * r : THREE_PI_OVER_4 - PI_OVER_4 * r;\n   if (y < 0.) return(-angle);\n   else return angle;\n}","name":"Common","description":"","type":"common"}]}