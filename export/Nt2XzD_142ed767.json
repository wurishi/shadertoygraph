{"ver":"0.1","info":{"id":"Nt2XzD","date":"1628273404","viewed":1402,"name":"Generalized regular polygon SDF","username":"felipetovarhenao","description":"Rotation-based generalization of a regular polygon SDF, taking Inigo Quilez's approach as a departure. The length of the apothem is constant for all polygons.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sdfs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nAuthor: Felipe Tovar-Henao [www.felipe-tovar-henao.com]\n\nDescription: Rotation-based generalization of a regular polygon's signed distance field (SDF), \nbased on Inigo Quilez's method in https://youtu.be/62-pRVZuS5c\nThe length of the apothem is constant for all polygons.\n*/\n\n#define u_resolution iResolution\n#define u_time iTime\n\nfloat polygonSDF(in vec2 vUV, in int V) {\n    float N = max(1.0, float(V));\n    float rot = floor(N*(atan(-vUV.x,-vUV.y) / 6.28318530718 + 0.5));\n    float offset = 3.14159265359*(N+2.0)/(2.0*N);\n    float theta = (6.28318530718/N) * rot + offset;\n    float side = tan(3.14159265359/max(N, 3.0));\n    vec2 r = vec2(cos(theta), sin(theta));\n    vUV *= mat2(r.x, -r.y, r.y, r.x);\n    float scl = 0.5 * (float(N==2.0)*(0.25/sqrt(3.0)) + step(2.0,N)) / (step(1.0,N) + step(N, 2.0));\n    vec2 s = vec2(step(3.0, N), side) * scl;\n    vec2 p = abs(vUV)-s;\n    return length(max(vec2(0.0), p)) + min(0.0, max(p.x, p.y/side));\n}\n\nfloat fold(in float x) {\n    float y = fract(x);\n    return mix(y, 1.0-y, float(mod(x, 2.0) >= 1.0));\n}\n\nfloat relu_ramp(in float x, in float s) {\n    return floor(x) + clamp((max(1.0, s)*(fract(x) - 0.5)) + 0.5, 0.0, 1.0);\n}\n\nfloat dx_ramp(in float x, in float s) {\n    float y = fract(x);\n    float h = max(0.0, pow(y, s));\n    return floor(x) + 1.0 - length(vec2(y-1.0,(h*h)-1.0)) * 0.707106781187;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 vUV = fragCoord.xy / u_resolution.xy;\n    float scl = 2.25;\n    vUV = (vUV-0.5) * scl;\n    vUV.x *= u_resolution.x / u_resolution.y;\n    float max_sides = 15.0;\n    vec3 color = vec3(0.0);\n\n    float t = max_sides*pow(fract(u_time/max_sides), 1.25);\n    float V1 = mod(t, max_sides) + 1.0;\n    float V2 = mod(t+1.0, max_sides) + 1.0;\n    float sdfA = polygonSDF(vUV, int(V1));\n    float sdfB = polygonSDF(vUV, int(V2));\n    float sdf = mix(sdfA, sdfB, relu_ramp(fract(V1), 3.0));\n    float border = 1.0-clamp(smoothstep(0.0,0.005,abs(sdf)), 0.0, 1.0);\n    sdfA = max(0.0, sdf);\n    sdfB = abs(min(0.0, sdf));\n    vec3 c1 = vec3(1.0, 0.1961, 0.1961) * pow(sdfA, 0.5);\n    vec3 c2 = vec3(0.1765, 1.0, 0.9882)  * pow(sdfB, 0.5);    \n    color = dx_ramp(fold(sdfA*scl*15.0), 4.0) * c1;\n    color += dx_ramp(fold(sdfB*scl*15.0), 4.0) * c2;\n    color += border*vec3(0.7412, 1.0, 0.9608);\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}