{"ver":"0.1","info":{"id":"4XlBDj","date":"1728923365","viewed":75,"name":"fractalic change room","username":"nayk","description":"originals https://www.shadertoy.com/view/Nsy3Dy https://www.shadertoy.com/view/4tyfWy https://www.shadertoy.com/view/stsXDl","likes":1,"published":3,"flags":0,"usePreview":0,"tags":["fractal","room","change"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\n\nconst float pi = 3.14159;\n\nmat3 xrot(float t)\n{\n    return mat3(1.0, 0.0, 0.0,\n                0.0, cos(t), -sin(t),\n                0.0, sin(t), cos(t));\n}\n\nmat3 yrot(float t)\n{\n    return mat3(cos(t), 0.0, -sin(t),\n                0.0, 1.0, 0.0,\n                sin(t), 0.0, cos(t));\n}\n\nmat3 zrot(float t)\n{\n    return mat3(cos(t), -sin(t), 0.0,\n                sin(t), cos(t), 0.0,\n                0.0, 0.0, 1.0);\n}\nfloat cheap_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdBoxXY( vec3 p, vec2 b )\n{\n  vec2 d = abs(p.xy) - b;\n  return min(max(d.x,d.y),0.0) +\n         length(max(d,0.0));\n}\n\n#define room (iTime * -0.25)\nfloat mat = 0.0;\nvec2 muv = vec2(0.0);\nvec3 mpos = vec3(0.0);\n\nfloat map(vec3 p)\n{\n    mat = 1.0;\n\tfloat d = 1000.0;\n    \n    vec3 h = p;\n    h *= zrot(room * 2.0);\n    h *= yrot(room * 3.0);\n    \n    float rs = 4.0;\n    d = min(d, -sdBox(h, vec3(rs)));\n    mpos = h;\n    \n    float cv = 0.3;\n\td = max(d, -sdBoxXY(h, rs * vec2(cv)));\n    float o = -sdBoxXY(h.zyx, rs * vec2(cv));\n    if (o > d) {\n        d = o;\n        mpos = h.zyx;\n    }\n    \n    o = -sdBoxXY(h.xzy, rs * vec2(cv));\n    if (o > d) {\n        d = o;\n        mpos = h.xzy;\n    }\n    \n    vec3 q = p - vec3(0.0, 0.0, 3.0);\n    q *= zrot(room * 3.14159 * 2.0);\n    vec3 ps = vec3(1.0, 1.0, 0.11);\n    float frame = sdBox(q, ps + vec3(0.1, 0.1, -0.01));\n    if (frame < d) {\n        d = frame;\n        mat = 2.0;\n        muv = q.xy / ps.xy;\n        mpos = q;\n    }\n    \n    float portal = sdBox(q, ps);\n    if (portal < d) {\n        d = portal;\n        mat = 0.0;\n        muv = q.xy / ps.xy;\n    }\n    \n    return d;\n}\n\nvec3 normal(vec3 p)\n{\n\tvec3 o = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(map(p+o.xyy) - map(p-o.xyy),\n                          map(p+o.yxy) - map(p-o.yxy),\n                          map(p+o.yyx) - map(p-o.yyx)));\n}\n\nfloat trace(vec3 o, vec3 r)\n{\n    float t = 0.0;\n    for (int i = 0; i < 32; ++i) {\n        vec3 p = o + r * t;\n        float d = map(p);\n        t += d;\n    }\n    return t;\n}\n\nmat3 xform(float t)\n{\n    mat3 xfm = yrot((mod(t, 3.0) + 1.0) * pi * 0.5);\n    //xfm *= xrot(t * pi * 0.5);\n    return xfm;\n}\n\nvec3 campos(float t, float u)\n{\n    vec3 exit = vec3(0.0, 0.0, 2.99);\n    vec3 enter = exit * xform(t);\n    vec3 pos = mix(enter, exit, u);\n    return pos;\n}\n\nmat3 slerp(vec3 a, vec3 b, float t)\n{\n\tvec3 fw = normalize(a);\n  \tvec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 left = normalize(cross(fw, up));\n    up = normalize(cross(left, fw));\n    mat3 xfm = mat3(left, up, fw);\n    vec3 k = xfm * b;\n    float theta = atan(k.x, k.z) * t;\n    fw = vec3(sin(theta), 0.0, cos(theta)) * xfm;\n    left = normalize(cross(fw, up));\n    up = normalize(cross(left, fw));\n    return mat3(left, up, fw);\n}\n\nvec3 _texture(sampler2D s, vec3 p, vec3 n)\n{\n    mat3 t = mat3(texture(s, p.zy).xyz,\n                  texture(s, p.xz).xyz,\n                  texture(s, p.xy).xyz);\n\treturn t * t * abs(n);\n}\n\n/* Shane's bump mapping */\nvec3 bump(sampler2D s, vec3 p, vec3 n)\n{\n\tvec2 d = vec2(0.01, 0.0);\n    mat3 m = mat3(_texture(s, p - d.xyy, n),\n                  _texture(s, p - d.yxy, n),\n                  _texture(s, p - d.yyx, n));\n    vec3 gs = vec3(0.299, 0.587, 0.114);\n    vec3 v = gs * m;\n    vec3 c = dot(_texture(s, p, n), gs) - v;\n    return normalize(n + c * 0.5);\n    \n}\n\n#define H(h) (cos((h)*6.3+vec3(0,23,21))*.5+.5)\n\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n      vec2 uv2 = ( C - .5*iResolution.xy ) / iResolution.y;\n     uv2 *= 2.0 * ( cos(iTime * 2.0) -2.5); // scale\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;  // anim between 0.9 - 1.1 \n   \n    vec4  O2=vec4(0);\n    \n    vec3 p2,r22=iResolution,\n    d=normalize(vec3((C-.5*r22.xy)/r22.y,1));  \n    for(\n        float i=0.,g=0.,e,s;\n        ++i<99.;\n        O2.rgb+=mix(r22/r22,H(log(s)),.7)*.05*exp(-.45*i*i*e))\n    {\n        p2=g*d;\np2.z-=0.7;\n        s=4.;\n        vec4 q=vec4(p2,sin(iTime*.4)*.5);\n\t\tfor(int j=0;j++<8;)\n            q=abs(q),\n            q=q.x<q.y?q.zwxy:q.zwyx,\n            s*=e=1.35/min(dot(q,q),0.54),\n            q=q*e-vec4(0,4,.8,3);\n        g+=e=min(\n            length(q.w)/s,\n            length(cross(q.xyw,normalize(vec3(1,2,3))))/s-.0002\n        );\n    }\n    O2=pow(O2,vec4(5));\n   O2.xyz+= vec3(cheap_star(uv2, anim) * vec3(0.5,0.5,0.505))*2.;\n    \n    vec3 p,o,r=iResolution,c=vec3(0),\n    d4=normalize(vec3((C-.5*r.xy)/r.y,1)),q;\n    float i=0.,s,e,g=0.,t=iTime;\n\tfor(;i++<90.;){\n        p=g*d4;\n        p.z-=mix(.9,9.,step(0.,sin(t*.3)));\n        p=R(p,normalize(cos(t*.5+vec3(1,8,3))),clamp(sin(t*.3)*3.,-5.,.5));\n        p=abs(p);\n        q=p*1.5;\n        s=3.;\n        for(int i=0;i++<8;)\n            p=1.-abs(abs(p-2.)-1.),\n            s*=e=-13.*min(.3*max(1./dot(p,p),.8),1.),\n            p=p*e+q;\n        g+=e=length(p)/s-.003;\n        c+=mix(vec3(1),H(log(s)*.2+t*.6),.6)*.01/exp(i*i*e);  \n    }\n    \n    vec3 n1,q2,r3=iResolution,\n    d2=normalize(vec3((C*2.-r3.xy)/r3.y,1));  \n    vec2 uv = C.xy / iResolution.xy;\n     uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n     float fov = 0.9;\n    vec3 sv = normalize(vec3(uv, fov - dot(uv, uv) * 0.2));\n\n    vec3 oo = campos(floor(room), fract(room));\n    sv *= zrot(room * 3.14159);\n    \n    vec3 or = sv;\n    float st = 1.0 - pow(1.0 - fract(room), 2.0);\n    vec3 rto = vec3(0.0, 0.0, 1.0);\n    vec3 rfrom = -rto * xform(floor(room));\n    or = or * slerp(rfrom, rto, st);\n\n    vec3 r2 = or;\n    vec3 o3 = oo;\n    \n    vec3 fc = vec3(0.0);\n    \n      for(float i=0.,a,s,e,g=0.;\n        ++i<70.;\n        O.xyz+=mix(vec3(1),H(g*.1),.8)*100./e/8e3\n    )\n    {\n        p=g*d;\n      \n        a=30.;\n        p=mod(p-a,a*2.)-a;\n        s=2.;\n        for(int i=0;i++<8;){\n            p=.3-abs(p);\n            p.x<p.z?p=p.zyx:p;\n            p.z<p.y?p=p.xzy:p;\n            s*=e=1.7+sin(iTime*.01)*.1;\n            p=abs(p)*e-\n                vec3(\n                    5.*3.,\n                    120,\n                    8.*5.\n                 );\n         }\n         g+=e=length(p.yxxz)/s;\n    }\n    \n    for (int i = 0; i < 8; ++i) {\n\t\tfloat fi = float(i);\n        \n        float t = trace(o3, r2);\n        vec3 w = o3 + r2 * t;\n        vec3 sn = normal(w);\n        \n        if (mat != 0.0) {\n            \n            vec3 sc = vec3(0.0);\n            float rtex = mod(floor(room + fi), 3.0);\n            if (rtex == 0.0) {\n                 sn = bump(iChannel0, mpos * 0.25, sn)*O.xyz;\n                sc = _texture(iChannel0, mpos * 0.25, sn)*O.xyz;\n            } else if (rtex == 1.0) {\n                sn = bump(iChannel1, mpos * 0.25, sn)*O2.xyz;\n                sc = _texture(iChannel1, mpos * 0.25, sn)*O2.xyz;\n            } else if (rtex == 2.0) {\n                sn = bump(iChannel2, mpos * 0.25, sn);\n                sc = _texture(iChannel2, mpos * 0.25, sn)*c.xyz;\n            }\n            \n            vec3 lpos = vec3(2.0, 2.0, -2.0);\n            vec3 ldir = lpos - w;\n            float ldist = length(ldir);\n            ldir /= ldist;\n            float lprod = max(dot(ldir, sn), 0.0);\n            float lpow = 1.0 / (1.0 + ldist * ldist * 0.01);\n\n        \tfloat fog = lprod / (1.0 + t * t * 0.001);\n            \n            fc += vec3(fog) * sc * lpow;\n            \n            break;\n        }\n        \n        float to = clamp(-sign(fi - 0.5), 0.0, 1.0);\n        \n        vec2 pmuv = muv * vec2(-1.0,1.0);\n        r = normalize(vec3(pmuv, fov - dot(pmuv, pmuv) * 0.2));\n        float speed = pow(fract(room), 4.0);\n        r = mix(r, sv, speed * to);\n        r = normalize(r);\n        vec3 srt = vec3(0.0, 0.0, 1.0);\n        vec3 srf = -srt * xform(floor(room + fi + 1.0));\n        r = r * slerp(srf, srt, 0.0);\n        o = campos(floor(room + fi + 1.0), 0.0);\n    }\n    \n   O= vec4(fc, 1.0);\n\n  \n}","name":"Image","description":"","type":"image"}]}