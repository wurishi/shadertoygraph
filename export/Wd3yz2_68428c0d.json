{"ver":"0.1","info":{"id":"Wd3yz2","date":"1601248315","viewed":128,"name":"Question for you all","username":"browric2","description":"Hi guys,\n\nI've implemented a very simple raymarched truchet pattern based mostly off iq's raymarching primitives.\n\nIs anyone able to tell me why I am getting artefacts on my rounded blocks?\n\nThanks very much, I look forward to learning this cool skill :)","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["truchet","noob","question"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define pi 3.1415926535897932384\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define speed 2.0\n\nfloat hash21(vec2 p) {\n    return fract(43758.5453123 * sin(dot(p, vec2(12.988, 243.233))+0.874539));\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n\nmat3 rot(float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);   \n    return mat3(c, 0., -s,0., 1.,0., s, 0.,c);\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x, p.y)) - t.y;\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n    return length(max(abs(p)-b,0.0))-r;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos ) // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n{\n    vec3 lpos = vec3(fract(pos.x),pos.y,fract(pos.z))-0.5;\n    vec2 id = floor(pos.xz);\n    \n    vec2 rnd = hash22(id);\n    float rotam = floor(rnd.x*4.);\n    lpos *= rot(rotam * (pi/2.));\n    \n    vec2 mplane = vec2(sdPlane(pos), 8.0 );\n    float mtorus1 = sdTorus(lpos-vec3(0.5,-0.5,0.5),vec2(0.5,0.13));\n    float mtorus2 = sdTorus(lpos-vec3(-0.5,-0.5,-0.5),vec2(0.5,0.13));\n    \n    float mtorus3 = sdTorus(lpos-vec3(0.5,-0.35,0.5),vec2(0.5,0.06));\n    float mtorus4 = sdTorus(lpos-vec3(-0.5,-0.35,-0.5),vec2(0.5,0.06));\n\n\tvec2 subtorus1 = vec2(max(mtorus1,-mtorus3),40.0);\n  \tvec2 subtorus2 = vec2(max(mtorus2,-mtorus4),40.0);\n    \n    vec2 mroundbox = vec2(udRoundBox(lpos-vec3(0.,-0.5,0.),vec3(0.1,0.4,0.1),0.1),40.);\n\n    vec2 res = opU(mplane,subtorus1);\n    res = opU(res,subtorus2);\n    if (rnd.y > 0.95) res = opU(res,mroundbox);\n\n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    tmax = 100.;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<64; i++ )\n    {\n\t    float precis = 0.0005*t;\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    \n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x; // distance\n\tfloat m = res.y; // material code\n    if( m > -0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n        vec3 ref = reflect(rd, nor); // reflected ray\n        \n\t\tcol = 0.45 + 0.35*sin( vec3(0.05,0.08,0.10)*(m-1.0) ); // material        \n\n\t\tvec3  lig = normalize( vec3(-0.4, 0.7, -0.6) ); // sunlight\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 ); // diffuse reflection from sunlight\n        \n\t\tvec3 lin = vec3(0.0);\n        lin += 1.30*dif*vec3(1.00,0.80,0.55);\n\t\tcol = col*lin;\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    vec3 ro = vec3(3.0-iTime*speed,3.0,3.0 - iTime*speed*0.8);\n    vec3 ta = vec3( -0.5-iTime*speed, -0.4, 0.5 -iTime*speed*0.8);\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n    vec3 col = render( ro, rd );\n\n    col = pow( col, vec3(0.4545) );\n    fragColor = vec4( col, 1.0 );\n}\n","name":"Image","description":"","type":"image"}]}