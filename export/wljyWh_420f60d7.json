{"ver":"0.1","info":{"id":"wljyWh","date":"1594313185","viewed":281,"name":"Octahedralis IV","username":"sl2c","description":"The \"Octahedralis\" shaders can all be described in terms of integers augmented with sqrt(-2) and this is a cohomology fractal effectively using the full symmetry group.","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["fractal","circles","hyperbolic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Copyright 2020 Google LLC\n// SPDX-License-Identifier: Apache-2.0\n// NOT an official Google project; see Google Open Source guidelines for more info on copyright transfer\n// written by William Cadegan-Schlieper \nfloat s = 0.4142135623730951; // silver ratio\n\nvoid octant1(inout vec3 z, inout float coh, inout bool fl) {\n    if (z.x < 0.0) {\n        z.x = -z.x;\n        coh=-coh;\n        fl=!fl;\n    }\n    if (z.y < 0.0) {\n        z.y = -z.y;\n        coh=-coh;\n        fl=!fl;\n    }\n    float r2 = dot(z,z);\n    if (r2 > 1.0) {\n        z /= r2;\n        coh=-coh;\n        fl=!fl;\n    }\n}\n\nvec3 color(vec3 z, float t) {\n    float coh = 0.0;\n    bool fl = false;\n    \n    float r2;\n    for(int i=0;i<40;i++) {\n        \n        octant1(z, coh, fl);\n        z -= vec3(s,s,0);\n        r2 = dot(z,z);\n        if (r2 < s * s) {\n            z *= s * s / r2;\n            fl = !fl;\n            coh = 1.0-coh;\n        }\n        z += vec3(s,s,0);\n        \n        \n        octant1(z, coh, fl);\n        \n        r2 = dot(z,z);\n        if (r2 < s*s) {\n            z *= s * s / r2;\n        }\n        z.y -= s + 1.0;\n        if (dot(z,z) < 1.0) {\n            z /= dot(z,z);\n        }\n        z.y += s + 1.0;\n        \n        z.x -= s + 1.0;\n        if (dot(z,z) < 1.0) {\n            z /= dot(z,z);\n        }\n        z.x += s + 1.0;\n        \n    }\n    octant1(z, coh, fl);\n    if (fl) {coh = -coh;}\n    coh -= t * 3.0;\n    coh = coh / (1.5 + abs(coh));\n    return vec3(0.5 + coh * 0.45);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = 2.0 * (fragCoord - iResolution.xy * 0.5)/iResolution.y;\n    float ds = 2.0 / iResolution.y;\n    \n    float period = 4.2549485065150545;\n    float t = iTime * 0.5;\n    bool r = false;\n    \n    while (t > period * 0.5) {\n        t -= period;\n        float c = 0.766311365; float s = -0.64246936;\n        uv = vec2(uv.x * c - uv.y * s, uv.x * s + uv.y * c);\n        //r = !r;\n    }\n    \n    vec3 z = vec3(uv,ds); z*=3.5;\n    z *= exp(-t); ds *= exp(-t);\n    \n    z += vec3(0.25262046414724887,-1.0187347727326157,0);\n\tz /= dot(z,z);\n    z += vec3(0.22732631827540598,0.4228686518338363,0);\n\n    fragColor = vec4(color(z, t/period),1.0);\n    fragColor = pow(fragColor, vec4(1./2.2));\n}","name":"Image","description":"","type":"image"}]}