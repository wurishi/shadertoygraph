{"ver":"0.1","info":{"id":"wdcSWB","date":"1572756741","viewed":150,"name":"phase space explorer","username":"micahbro","description":"Surface of section explorer for the vertically driven pendulum. It's a fractal! Drag to zoom (once). \nControls (left to right): reset display, toggle curve overlay, slow-mo, drive period, gravity, drive amplitude.\nButton in corner toggles control bar.","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["fractal","mechanics","chaos","pendulum","driven","hamiltonian"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n\tconfigureAndUpdate(iResolution, iChannel3, iMouse, iFrame < 10);\n    \n    // Screen coordinates (anisotropic, -0.5 - 0.5)\n\t//vec2 uv = (fragCoord.xy - iResolution.xy*.5) / iResolution.xy;\n    \n    // Phase space evolution\n    vec4 pqdt = texture(iChannel0, fragCoord / iResolution.xy);\n    fragColor = vec4(clamp(pqdt.xyz, 0., 1.), 1.);\n\n    // Curve tracing overlay\n    if (controls[overlayCtl].value > 0.) {\n        vec4 overlayColor = texture(iChannel1, fragCoord / iResolution.xy);    \n        fragColor = (1. - overlayColor[3]) * fragColor + overlayColor[3] * overlayColor;\n    }\n\n    // Zoom selection box\n    if (controls[zoomclickCtl].mouseDown) {\n        vec2 bb1 = iResolution.xy * 0.5 + clickboxCoordsNorm(controls[zoomclickCtl].value)*iResolution.xy;\n        vec2 dist = abs(bb1 - fragCoord);\n        if (dot(dist, dist) < 5.) {\n            fragColor = vec4(0., 0., 1., 1.);\n        }\n\n        vec2 bb2 = iResolution.xy * 0.5 + clickboxCoordsNorm(controls[zoomclickCtl].value2)*iResolution.xy;\n        dist = abs(bb2 - fragCoord);\n        if (dot(dist, dist) < 5.) {\n            fragColor = vec4(1., 0., 0., 1.);\n        }\n        \n        vec2 bbmin = min(bb1, bb2);\n        vec2 bbmax = max(bb1, bb2);\n            \n        if (fragCoord.x > bbmin.x && fragCoord.x < bbmax.x &&\n            fragCoord.y > bbmin.y && fragCoord.y < bbmax.y) {\n            fragColor = fragColor * 0.7 + vec4(1.) * 0.3;\n        }\n        \n    }\n    \n    \n    vec4 controlColor = texture(CTRL_CHANNEL, fragCoord / vec2(iResolution));\n    fragColor = (1. - controlColor[3]) * fragColor + controlColor[3] * controlColor;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// sh*ttyguikit 0.1.1\n\n#define TOGGLE_BTN_T 1\n#define PUSH_BTN_T 2\n#define SPINNER_T 3\n#define CLICKBOX_T 4\n\n#define MAX_CTRLS 9\n#define CTRL_CHANNEL iChannel3\n#define GRN_MID 0.3\n\nstruct control {\n    int type;\n    vec4 bboxUV;\n    float value; \n    float value2; \n    bool mouseDown;\n    bool visible;\n    bool enabled;\n    float opacity;\n};\n    \n    \ncontrol[MAX_CTRLS] controls;\nint controlCount = 0;\n\nvec3 giResolution;\n\n\nvec2 uvToXY(vec2 uv) {\n    return uv * giResolution.y + giResolution.xy*.5;\n}\n\nvec2 xyToUV(vec2 xy) {\n    return (xy - giResolution.xy*.5) / giResolution.y;\n}\n\nint newControl(int type, vec4 bbox) {\n    controls[controlCount].type = type;\n    controls[controlCount].bboxUV = bbox;\n    controls[controlCount].mouseDown = false;\n    controls[controlCount].visible = true;\n    controls[controlCount].enabled = true;\n    controls[controlCount].opacity = 1.0;\n    return controlCount++;\n}\n\n\nvec4 getControl(int index, sampler2D sampler) {\n    vec4 bbox = controls[index].bboxUV;\n    vec2 midpoint = vec2(bbox[0] + bbox[2], bbox[1] + bbox[3]) * 0.5;\n    ivec2 ixy = ivec2(uvToXY(midpoint));\n    return texelFetch(sampler, ixy, 0);\n}\n\nvoid updateValue2(int index) {\n    int type = controls[index].type;\n    if (type != CLICKBOX_T) {\n    \tcontrols[index].value2 = 1. - controls[index].value;\n    }\n}\n\nvoid updateControls(sampler2D sampler) {\n    for (int i = 0 ; i < controlCount; i++) {\n        vec4 readout = getControl(i, sampler);\n        controls[i].value = readout[2];\n        controls[i].value2 = readout[0];\n        controls[i].mouseDown = readout[1] > GRN_MID;\n        float alphanorm = 1.;\n        if (controls[i].opacity > 0.) {\n            alphanorm = (readout[3] / controls[i].opacity);\n        }\n        controls[i].visible = alphanorm > 0.;\n        controls[i].enabled = alphanorm > .5;        \n        updateValue2(i);\n    }    \n}\n\nfloat getShapeNorm(int type) {\n    if (type == TOGGLE_BTN_T) {\n    \treturn 3.5;\n    } else if (type == PUSH_BTN_T) {\n    \treturn  1.5;\n    } else if (type == CLICKBOX_T) {\n    \treturn  100.;\n    } else {\n    \treturn 2.0;\n    }\n}\n\n// -1 to 1\nvec2 hitCoordsNormalized(int index, vec2 xy) {\n    vec4 bbox = controls[index].bboxUV;\n    vec2 midpoint = vec2(bbox[0] + bbox[2], bbox[1] + bbox[3]) * 0.5;\n    vec2 span = abs(vec2(bbox[0] - bbox[2], bbox[1] - bbox[3]));\n    vec2 uv = xyToUV(xy);\n \n    return (uv - midpoint) / (0.5 * span);\n}\n    \nfloat midpointDistNorm(int index, int type, vec2 xy) {\n    vec2 dr = hitCoordsNormalized(index, xy);\n    //return sqrt(dot(dr, dr));\n    float normpow = getShapeNorm(type);\n    float sumnorm = pow(abs(dr[0]), normpow) + pow(abs(dr[1]), normpow);\n    return pow(sumnorm, 1.0 / normpow);\n}\n\nfloat midpointAngle(int index, vec2 xy) {\n    vec2 dr = hitCoordsNormalized(index, xy);\n    \n    return acos(dr[0] / sqrt(dot(dr, dr))) * sign(dr[1]);\n}\n\nvec2 clickboxCoordsNorm(float value) {\n    return 2. * vec2(fract(value) - 0.5, floor(value) / 500. - 0.5);\n}\n\nfloat normCoordsToClickboxVal(vec2 dr) {\n    return clamp(dr[0] * 0.5 + 0.5, 0., 1.) + round(500. * clamp(dr[1] * 0.5 + 0.5, 0., 1.));\n}\n\nvoid mouseDownEvt(int index, vec4 mouse, int capturedIndex) {\n    //  mouseDown event:\n    switch (controls[index].type) {\n        case PUSH_BTN_T:\n        controls[index].value = 1.;\n        break;\n\n        case TOGGLE_BTN_T:\n        controls[index].value = 1. - controls[index].value;\n        break;\n\n        case CLICKBOX_T:\n\t    vec2 dr = hitCoordsNormalized(index, mouse.xy) / 2.;\n        controls[index].value = normCoordsToClickboxVal(dr);\n        controls[index].value2 = controls[index].value;\n        break;        \n    }\n}\n\nvoid mouseMoveEvt(int index, vec4 mouse, int capturedIndex, bool inBounds) {\n    // mouseMove event:\n    switch (controls[index].type) {\n        case PUSH_BTN_T:\n        controls[index].value = inBounds ? 1. : 0.;\n        break;\n\n        case SPINNER_T:\n        controls[index].value = midpointAngle(index, mouse.xy) / 3.14159;\n        break;\n\n        case CLICKBOX_T:\n\t    vec2 dr = hitCoordsNormalized(index, mouse.xy) / 2.;\n        controls[index].value2 = normCoordsToClickboxVal(dr);\n        break;        \n    }\n}\n\nvoid mouseUpEvt(int index, vec4 mouse, int capturedIndex) {\n    // mouseUp event:\n    switch (controls[index].type) {\n        case PUSH_BTN_T:\n        controls[index].value = 0.;\n        break;\n    }\n}\n\nint typeCheatSheet(int index);\n\nbool handleMouse(int index, vec4 mouse, int capturedIndex) {\n    float dist = midpointDistNorm(index, typeCheatSheet(index), mouse.xy);\n    bool capturable = capturedIndex == index || capturedIndex < 0;\n    if (mouse[2] > 0. && dist < 1. && controls[index].visible) {\n        if (controls[index].enabled && capturable) {\n            if (!controls[index].mouseDown) {\n                controls[index].mouseDown = true;\n\n                mouseDownEvt(index, mouse, capturedIndex);\n            } else {\n            \tmouseMoveEvt(index, mouse, capturedIndex, true);\n        \t}\n        }\n        return true;\n    } else {\n        if (controls[index].mouseDown) {\n            if (mouse[2] <= 0.) {\n                mouseUpEvt(index, mouse, capturedIndex);\n            } else {            \n                mouseMoveEvt(index, mouse, capturedIndex, false);\n            }\n        }        \n        \n        if (capturedIndex != index) {\n            controls[index].mouseDown = false;        \n        }\n        return false;\n    }            \n}\n\nvec4 processMouse(vec4 mouse) {\n    int capturedIndex = -1;\n    if (mouse[2] > 0.) {\n        for (int i = 0 ; i < controlCount; i++) {\n            if (controls[i].mouseDown) {\n                capturedIndex = i;\n            }\n        }\n    }\n    \n    bool handled = false;\n    for (int i = controlCount - 1 ; i >= 0; i--) {\n        handled = handleMouse(i, mouse, capturedIndex);\n        if (handled) {\n            break;\n        }\n    }\n    if (handled || capturedIndex >= 0) {\n        return vec4(mouse.xy, 0., 0.);\n    } else {        \n    \treturn mouse;\n    }\n}\n\nvec4 renderControls(vec2 fragCoord, vec4 mouse) {\n    vec4 pixel = vec4(0.);\n    for (int i = 0 ; i < controlCount; i++) {\n        float dist = midpointDistNorm(i, controls[i].type, fragCoord);\n        float mouseThickAdj = controls[i].mouseDown ? 0.07 : 0.;\n        \n        float alpha = 0.;\n        if (controls[i].visible) {\n            alpha = (controls[i].enabled? 1. : 0.5) * controls[i].opacity;\n        }\n        \n        // special casing handling invisible controls partly overlapping visible ones\n        if (alpha > 0. || pixel[3] <= 0.) {\n            if (dist <= 0.9 - mouseThickAdj) {\n                float mouseColor = GRN_MID + (controls[i].mouseDown ? 0.02 : -0.02);\n                pixel = vec4(controls[i].value2, mouseColor, controls[i].value, alpha);\n\n                if (controls[i].type == SPINNER_T) {\n                    if (dist > 0.5 && \n                        abs(midpointAngle(i, fragCoord) / 3.14159 - controls[i].value) < .1) {\n                        pixel = vec4(0., 0., 0., alpha);\n                    }\n                }\n\n                if (dist > 0.8 - mouseThickAdj - .1) {\n                    float delta = dist - (0.9 - mouseThickAdj);\n                    float blend = exp(-delta * delta * 500.);\n                    pixel = (1. - blend) * pixel * pixel[3] + vec4(0., 0., 0., alpha);\n                    pixel[3] = alpha;\n                }\n                \n            } else if (dist <= 1.1) {                \n                float blend = exp(-(dist - 0.9) * (dist - 0.9) * 100.);\n                if (dist < 0.9) blend = 1.0;\n                pixel = (1. - blend) * pixel + vec4(0., 0., 0., blend * alpha);\n            }            \n        }\n    }    \n    \n    return pixel;    \n}\n\nint visControl;\nint zoomclickCtl;\nint ampCtl;\nint gCtl;\nint pdrivCtl;\n//int pzoomCtl;\nint slowmoCtl;\nint overlayCtl;\nint resetCtl;\n\n\nvoid defineYourControls()\n{\n    vec2 corner = xyToUV(vec2(giResolution[0], 0.));\n\n    zoomclickCtl = newControl(CLICKBOX_T, vec4(corner, -corner));\n    controls[zoomclickCtl].opacity = 0.;\n    \n    visControl = newControl(TOGGLE_BTN_T, vec4(corner, corner - vec2(0.05, -0.05)));\n    \n    float pos = corner.x - 0.046;\n    ampCtl = newControl(SPINNER_T, vec4(pos -= 0.1, -.4, pos + 0.1, -.5));\n    gCtl = newControl(SPINNER_T, vec4(pos -= 0.1, -.4, pos + 0.1, -.5));\n    pdrivCtl = newControl(SPINNER_T, vec4(pos -= 0.1, -.4, pos + 0.1, -.5));\n    //pzoomCtl = newControl(SPINNER_T, vec4(pos -= 0.1, -.4, pos + 0.1, -.5));\n    slowmoCtl = newControl(TOGGLE_BTN_T, vec4(pos -= 0.1, -.4, pos + 0.1, -.5));\n    overlayCtl = newControl(TOGGLE_BTN_T, vec4(pos -= 0.1, -.4, pos + 0.1, -.5));\n    resetCtl = newControl(PUSH_BTN_T, vec4(pos -= 0.1, -.4, pos + 0.1, -.5));\n}\n\n// this function is sadness and kludge but remarkably faster than the obvious thing,\n// at least on my integrated graphics laptop -- perhaps because handleMouse is so serial?\nint typeCheatSheet(int index) {\n    // hard code results of controls[index].type, for fast access during mouse hit testing:\n    if (index == zoomclickCtl) {\n        return CLICKBOX_T;\n    } else if (index == resetCtl) {\n        return PUSH_BTN_T;\n    } else if (index >= ampCtl && index <= slowmoCtl) {\n        return SPINNER_T;\n    } else {\n        return TOGGLE_BTN_T;\n    }\n}\n\nvoid configure(vec3 res) {\n    giResolution = res;        \n    defineYourControls();\n}\n\nvec4 configureAndUpdate(vec3 res, sampler2D sampler, vec4 mouse, bool init) {\n    configure(res);\n    if (!init) {\n    \tupdateControls(sampler);\n    }\n    \n    return processMouse(mouse);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// GUI state\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    configureAndUpdate(iResolution, CTRL_CHANNEL, iMouse, iFrame < 10);    \n\n    if (iFrame < 10) {\n        controls[overlayCtl].value = 1.;\n    }\n        \n    // hackery: guess if we're in preview mode and show the button bar\n    if (iResolution.x + iResolution.y < 500.) {\n        controls[visControl].value = 1.;\n    }\n    \n    for (int i = 0; i < MAX_CTRLS; i++) {\n        if (i != visControl && i != zoomclickCtl) {\n            controls[i].visible = controls[visControl].value > 0.;\n            controls[i].enabled = controls[visControl].value > 0.;\n        } else {\n            // Resizes inevitably bork gui state, but at least the toggle should be made visible:\n            controls[i].visible = true;\n            controls[i].enabled = true;\n        }\n    }\n\n    fragColor = renderControls(fragCoord, iMouse);\n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Phase portrait evolution\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 mouse = configureAndUpdate(iResolution, CTRL_CHANNEL, iMouse, iFrame < 10);\n    \n    // Screen coordinates (anisotropic, -0.5 - 0.5)\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5) / iResolution.xy;\n   \n    //ivec2 ifc = ivec2(round(fragCoord)); \n    //vec4 pqdt = texelFetch(iChannel0, ifc, 0);\n    vec4 pqdt = texture(iChannel0, fragCoord / iResolution.xy);\n    \n    vec4 bbox = vec4(clickboxCoordsNorm(controls[zoomclickCtl].value), \n                     clickboxCoordsNorm(controls[zoomclickCtl].value2));    \n    if (bbox.xy == bbox.zw) bbox = vec4(-.5, -.5, .5, .5);    \n    vec2 center = (bbox.xy + bbox.zw) / 2.;\n    vec2 span = abs(bbox.zw - bbox.xy);\n    \n    float g = 1.0 * (controls[gCtl].value + 1.0);\n    float amp = .02 * exp(controls[ampCtl].value * 2.);\n\tfloat prange = 2.; // * exp(controls[pzoomCtl].value);\n    float pdriv = 2. * exp(controls[pdrivCtl].value);\n    \n    float dt = 0.01;\n    \n    //int reps = 200;//50;\n    int reps = int(ceil(pdriv / dt)) + 1;\n    if (controls[slowmoCtl].value > 0.) reps = 10;\n    \n    if (iFrame < 10 || controls[resetCtl].value > 0. || controls[zoomclickCtl].mouseDown) {        \n        pqdt = vec4(center + uv * span, 0., 0.);         \n    } else {\n        \n\n        float p = pqdt[0] * prange;\n        float q = pqdt[1];\n        float d = pqdt[2] * 2.;\n        float t = pqdt[3];\n        \n        for (int i = 0; i < reps; i++) {\n\n            float drive = sin(6.28318 * t / pdriv);\n            \n            p += -sin(6.28318 * q) * (g + amp * drive) * dt;\n            q += p * dt;\n            t += dt;\n\n            float driveNew = sin(6.28318 * t / pdriv);\n            \n            if (driveNew >= 0. && drive < 0.) break;\n            \n            if (q > 0.5) q -= 1.;\n            if (q < -0.5) q += 1.;\n            \n            d = drive;\n        }\n        \n        if (t > pdriv) t -= pdriv;\n        \n        pqdt = vec4(p / prange, q, d / 2., t);\n    }\n\n\n    fragColor = pqdt;            \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Curve tracing\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 mouse = configureAndUpdate(iResolution, CTRL_CHANNEL, iMouse, iFrame < 10);    \n\n    // Screen coordinates (anisotropic, -0.5 - 0.5)\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5) / iResolution.xy;\n\n    float cf = 1.;\n    \n    vec4 bbox = vec4(clickboxCoordsNorm(controls[zoomclickCtl].value), \n                     clickboxCoordsNorm(controls[zoomclickCtl].value2));    \n    if (bbox.xy == bbox.zw) {\n        cf = 2.;\n        bbox = vec4(-.5, -.5, .5, .5);    \n    }\n    vec2 center = (bbox.xy + bbox.zw) / 2.;\n    vec2 span = abs(bbox.zw - bbox.xy);        \n    \n    fragColor = texture(iChannel1, fragCoord / iResolution.xy);\n\n    if (iFrame < 10 || controls[resetCtl].value > 0. || controls[zoomclickCtl].mouseDown) {        \n        fragColor = vec4(0.);         \n    } else {\n\n    \n        float pdriv = 2. * exp(controls[pdrivCtl].value);\n\n        float dt = 0.01;\n\n        int np = 40;\n        \n        // hackery: guess if we're in preview mode and use fewer points\n        if (iResolution.x + iResolution.y < 500.) {\n            np /= 3;\n        }\n        \n        for (int s = 0; s < 2; s++) {\n            for (int i = 2; i < np; i++) {\n\t\t\t    //vec4 pqdt = texture(iChannel0, vec2(float(i) / float(np), float(i) / float(np)));\n\t\t\t    vec4 pqdt = texelFetch(iChannel0, ivec2((vec2(float(s) * 0.5) + (s > 0 ? vec2(i, i) : vec2(np * int(cf - 1.) + i, np - i))) * vec2(iResolution.xy / cf)) / np, 0);\n\n                float t = pqdt[3];                \n\n\t            float driveOld = sin(6.28318 * (t - dt) / pdriv);\n\t            float driveNew = sin(6.28318 * t / pdriv);\n                \n                if (driveNew >= 0. && driveOld < 0.) { \n                    vec2 dezoomedCoord = (pqdt.xy - center) / span;\n                    vec2 coord = round(dezoomedCoord * iResolution.xy + iResolution.xy*.5);\n                    if (trunc(fragCoord) == coord) {\n                        fragColor = vec4(1., 1., 1., 0.6);\n                    }\n                }\n                \n            }\n        }        \t    \n    }\n}","name":"Buffer B","description":"","type":"buffer"}]}