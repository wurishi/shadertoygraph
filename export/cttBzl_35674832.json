{"ver":"0.1","info":{"id":"cttBzl","date":"1701476448","viewed":85,"name":"LiveCoding@Inércia 2023","username":"gam0022","description":"1 hour Live Coding at the Shader Royale Jam at Inércia 2023\nhttps://2023.inercia.pt/index.php?page=Timetable","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fractal","ifs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRr","filepath":"/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","previewfilepath":"/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Original Bonzomatic Shader\n// https://gist.github.com/gam0022/f033c62069f2149b4560333778d056b8\n\n#define time iTime\n#define PI acos(-1.)\n#define TAU (2. * PI)\n#define VOL 0.\n#define SOL 1.\n#define saturate(x) clamp(x, 0., 1.)\n\nfloat beat, beatTau;\nvec3 pos;\nfloat scene;\n\nvec3 pal(float h) {\n  vec3 col = vec3(0.5) + 0.5 * cos(TAU * (vec3(0, 0.33, 0.67) + h));\n  return mix(col, vec3(1), 0.1 * floor(h));\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q, 0.)) + min(0., max(q.x, max(q.y, q.z)));\n}\n\nvoid rot(inout vec2 p, float a) { p *= mat2(cos(a), sin(a), -sin(a), cos(a)); }\n\nvoid U(inout vec4 m, float d, float a, float b, float c) {\n  if (d < m.x) m = vec4(d, a, b, c);\n}\n\nvec4 map(vec3 p) {\n  pos = p;\n\n  float a = 16.;\n  vec4 m = vec4(1);\n  vec3 of1 = vec3(6.26, 2.7, 1.5);\n  p = mod(p, a) - 0.5 * a;\n  p -= of1;\n\n  for (int i = 0; i < 1 + int(scene); i++) {\n    p = abs(p + of1) - of1;\n    rot(p.xz, TAU * (0.05 + scene * 0.));\n    rot(p.zy, TAU * 0.35);\n    rot(p.xy, TAU * -0.05);\n  }\n\n  vec3 p2 = p;\n  p2.y = mod(p2.y, 0.4) - 0.5 * 0.4;\n\n  vec3 p3 = p;\n  p3.y = mod(p3.y, 4.) - 0.5 * 4.;\n  U(m, sdBox(p2, vec3(1, 0.05, 1)), SOL, 0.1, 1.);\n  U(m, sdBox(p, vec3(0.5, 20, 0.5)), VOL, saturate(cos(beatTau / 2. + p.y * TAU / 4.)),\n    2.8 + 0.1 * scene + ((scene == 3.) ? (fract(p.y * 2.3) - 2.) : 0.));\n  U(m, sdBox(p3, vec3(1, 0.2, 1)), VOL, saturate(cos(beatTau / 2. + TAU / 32. * pos.z / 16.)),\n    2.4 + 0.1 * scene);\n\n  return m;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  vec3 col = vec3(0);\n  float t = 0.;\n  for (int i = 0; i < 100; i++) {\n    vec3 p = ro + rd * t;\n    vec4 m = map(p);\n    float d = m.x;\n\n    if (m.y == SOL) {\n      t += d;\n      if (d < t * 0.001) {\n        col += float(i) / 50. * pal(m.w) * m.z;\n        t += d;\n        break;\n      }\n    } else {\n      t += 0.1 * abs(d) + 0.1;\n      col += 0.2 * pal(m.w) * m.z * exp(-3. * d);\n    }\n  }\n  col = mix(vec3(0), col, exp(-0.001 * t));\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  beat = time * 120. / 60.;\n  beatTau = beat * TAU;\n  scene = floor(beat / 4.);\n  scene += saturate(pow(fract(beat / 4.), 1.) - abs(uv.y));\n  // vec2 up = vec2(0, 1);\n  // rot(up, TAU * pow(fract(beat / 4), 3));\n  // scene += dot(uv, up) > 0 ? 1 : 0;\n  scene = mod(floor(scene + 0.5), 6.);\n\n  vec3 ro = vec3(0, 0, 4. * time);\n  vec3 rd = vec3(uv, 1);\n  rd = normalize(rd);\n  vec3 col = render(ro, rd);\n\n  fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}