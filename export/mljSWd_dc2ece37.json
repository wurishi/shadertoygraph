{"ver":"0.1","info":{"id":"mljSWd","date":"1676830129","viewed":145,"name":"watercolorFBM","username":"westgarthb","description":"An abstract watercolor effect on domain warped noise","likes":3,"published":1,"flags":0,"usePreview":1,"tags":["noise","fbm","watercolor","domainwarp"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define width iResolution.x\n#define height iResolution.y\n\nconst mat3 mtx = mat3( 0.80,  0.60, -0.60,  0.80 , -0.40, 0.60, 0.44, 0.65, 0.83);\n\nfloat scale = 0.6; // noise scale\nfloat mode = 0.2; // color mode\nfloat levels = 7.0;\n\nvec3 hash( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec3 x )\n{\n    // grid\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    // quintic interpolant\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n\n    \n    // gradients\n    vec3 ga = hash( p+vec3(0.0,0.0,0.0) );\n    vec3 gb = hash( p+vec3(1.0,0.0,0.0) );\n    vec3 gc = hash( p+vec3(0.0,1.0,0.0) );\n    vec3 gd = hash( p+vec3(1.0,1.0,0.0) );\n    vec3 ge = hash( p+vec3(0.0,0.0,1.0) );\n    vec3 gf = hash( p+vec3(1.0,0.0,1.0) );\n    vec3 gg = hash( p+vec3(0.0,1.0,1.0) );\n    vec3 gh = hash( p+vec3(1.0,1.0,1.0) );\n    \n    // projections\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\n\t\n    // interpolation\n    return va + \n           u.x*(vb-va) + \n           u.y*(vc-va) + \n           u.z*(ve-va) + \n           u.x*u.y*(va-vb-vc+vd) + \n           u.y*u.z*(va-vc-ve+vg) + \n           u.z*u.x*(va-vb-ve+vf) + \n           u.x*u.y*u.z*(-va+vb+vc-vd+ve-vf-vg+vh);\n}\n\nfloat fbm( vec3 p )\n{\n    float f = 0.0;\n    f += 0.5000*(noise( p )); p = mtx*p*2.02;\n    f += 0.500*(noise( p )); p = mtx*p*2.03;\n    return f/0.9375;\n}\n\n\nfloat pattern( in vec3 p )\n{\n    vec3 q = vec3( fbm( p + vec3(0.0,0.0, 0.0) ),\n                   fbm( p + vec3(5.2,1.3, 2.3) ),\n                   fbm( p + vec3(5.2,1.3, 0.3) ) );\n\n    return fbm( p + (-sin(iTime)+2.0)*q );\n}\n\nfloat biasLookup(float k, float ref)\n{\n    float kcube = 1.0 - 2.0*abs(k - 0.5);\n    if(k <= 0.5)\n    {\n        return (ref * kcube) / (ref * kcube - ref + 1.0);\n    }\n    return 1.0 - ((-(ref-1.0) * kcube) / (-(ref-1.0) * kcube + ref));\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec4 map(vec2 p)\n{\n    vec2 meta = vec2(0.0, 1.0);\n    float min = 1000.0;\n    for(int i = 0; i < 2; i++)\n    {\n      vec2 cent = vec2((float(i%2)*2.0-1.0) * 1.0 *cos(iTime*0.5), (float(i%2)*2.0-1.0) * 0.45 *sin(iTime*0.5));\n      float r = 0.3;\n\n      float len = length(p - cent);\n      if(len < r+0.1 && len > r && len < min)\n      {\n          //p = vec2(0.0);\n          //p *= 0.8;\n          meta.y = ((len - r) / 0.10) * 0.5 + 0.5;\n          //meta.x = -0.01;\n      }\n      else if(length(p - cent) < r && len < min)\n      {\n          vec2 temp = (p - cent);\n          p.x = -temp.y;\n          p.y = temp.x;\n          p = p + cent;\n          meta.x = 0.5;\n      }\n    }\n    \n    return vec4(p, meta);\n}\n \n\nvec4 getCol(vec2 pos)\n\n{\n    float minAx = min(width, height);\n    pos = (pos * 2.0 - vec2(width, height))/minAx;\n    vec4 info = map(pos);\n    vec2 uv = info.xy;\n    vec3 vt = vec3(uv* 3.0, 0.0);\n\n    float v = clamp( (pattern(vt * scale) + 0.3) * 1.2, 0.0, 1.0 );\n    //v = biasLookup(v, 0.25);\n    float y = v * levels;\n    float co = fract(y) * 2.0 - 1.0;\n    v = step(0.35, fract(y)) * (floor(y) + 3.0) / (levels + 3.0);\n    \n    float vv = step(0.35, fract(y)) * biasLookup(clamp(abs((fract(y) - 0.35)*1.53 * 2.0 - 1.0), 0.0, 1.0), 0.3);\n    //vec3 col = vec3(1.0-v);\n    vec3 col = vec3(0.951, 0.927, 0.873) * info.w;\n    if(v > 0.01)\n    {\n        float hue_off = 0.0;\n        if(mode < 1.0)\n          hue_off = (uv.x+uv.y);\n        else if(mode < 2.0)\n          hue_off = length(uv)*1.5;\n        else if(mode < 4.0)\n          hue_off = (uv.x)*2.0;\n        col = hsv2rgb(vec3(fract(v*0.4 + info.z + hue_off*fract(mode) + iTime*0.1), clamp(0.6-vv*0.2, 0.0, 1.0), clamp(1.0-v+vv*0.5, 0.0, 1.0)));\n        col *= (1.0 - 0.7*biasLookup(abs(co), 0.3)) * info.w;\n    }\n    \n    \n    float xs = width < height ? 0.92 : width / height - 0.08;\n    float ys = width < height ? height / width - 0.08 : 0.92;\n    if(abs(pos.x) > xs || abs(pos.y) > ys || info.z < 0.0)\n         col = vec3(0.951, 0.927, 0.873);\n    return(vec4(col,1.0));\n\n}\n\nvec2 getGrad(vec2 pos,float delta)\n\n{\n\n    vec2 d=vec2(delta,0);\n\n    return vec2(\n\n        dot((getCol(pos+d.xy)-getCol(pos-d.xy)).xyz,vec3(.333)),\n\n        dot((getCol(pos+d.yx)-getCol(pos-d.yx)).xyz,vec3(.333))\n\n    )/delta;\n\n}\n\nvec4 getColRand(vec2 pos)\n\n{\n    vec2 uv = pos * 0.2;\n    vec3 m = vec3(noise(vec3(uv, 0.0)));\n\n    return vec4(m, 1.0);\n\n}\n\n\n#define SampNum 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    levels = sin(iTime*0.5) * 4.0 + 5.0;\n    vec2 pos= fragCoord;\n    vec2 pos3=pos;\n    vec2 pos4=pos;\n    vec3 col2=vec3(0);\n    float cnt2=0.;\n\n    for(int i=0;i<1*SampNum;i++)\n\n    {  \n\n        vec2 gr3= getGrad(pos3,2.0)+.1;\n        vec2 gr4= getGrad(pos4,2.0)+.1;\n\n\n        float fact=1.0-float(i)/float(SampNum);\n\n        pos3+=.8*normalize(gr3);\n\n        pos4-=.8 *normalize(gr4);\n\n       \n\n        float f1=4.*fact;\n\n        float f2=4.*(1.0-fact);\n\n        col2+=f1*(getCol(pos3).xyz+.1+.15*getColRand(pos3*1.2*1.0).xyz);\n        col2+=f2*(getCol(pos4).xyz+.1+.15*getColRand(pos4*1.2*1.0).xyz);\n        cnt2+=f1+f2;\n\n    }\n\n    col2/=cnt2*1.25;\n    vec3 c = vec3(col2);\n\n    fragColor = vec4(c, 1.0);\n}","name":"Image","description":"","type":"image"}]}