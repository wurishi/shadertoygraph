{"ver":"0.1","info":{"id":"7lfBWl","date":"1651636051","viewed":180,"name":"Fork hex grid","username":"HaleyHalcyon","description":"a","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["grid","hexagon"],"hasliked":0,"parentid":"sdK3Ry","parentname":"less complicated hexagon grid"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float TURN = 2. * acos(-1.);\n\n// hue rotation code\n// references a comment in https://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\nmat3 rotAxis(vec3 axis, float a) {\n    float s=sin(a);\n    float c=cos(a);\n    float oc=1.0-c;\n    vec3 as=axis*s;\n    mat3 p=mat3(axis.x*axis,axis.y*axis,axis.z*axis);\n    mat3 q=mat3(c,-as.z,as.y,as.z,c,-as.x,-as.y,as.x,c);\n    return p*oc+q;\n}\n\n\n// a lot of this gaussian blur code is taken from https://www.shadertoy.com/view/XdfGDH\n// hence the spelling of \"colour\" with the u\n\nfloat normpdf(in float x, in float sigma)\n{\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 c = texture(iChannel0, fragCoord.xy / iResolution.xy).rgb;\n\t\n    //declare stuff\n    const int mSize = 47;\n    const int kSize = (mSize-1)/2;\n    float kernel[mSize];\n    vec3 final_colour = vec3(0.0);\n\n    //create the 1-D kernel\n    float sigma = 9.;\n    float Z = 0.0;\n    for (int j = 0; j <= kSize; ++j)\n    {\n        kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);\n    }\n\n    //get the normalization factor (as the gaussian has been clamped)\n    for (int j = 0; j < mSize; ++j)\n    {\n        Z += kernel[j];\n    }\n\n    //read out the texels\n    for (int i=-kSize; i <= kSize; ++i)\n    {\n        for (int j=-kSize; j <= kSize; ++j)\n        {\n            final_colour += kernel[kSize+j]*kernel[kSize+i]*texture(\n                iChannel0, (\n                    fragCoord.xy+vec2(float(i),float(j))\n                ) / iResolution.xy\n            ).rgb;\n\n        }\n    }\n    \n    final_colour = final_colour/(Z*Z);\n    \n    c = c * 0.7 + final_colour * 1.0;\n    c -= 0.2;\n    \n    // hue rotation\n    c = c * rotAxis(vec3(1, 1, 1), 0.2 * sin(iTime * TURN));\n    \n\n    fragColor = vec4(c, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// square root of 3 because hexagon stuff\n#define SQRT3 (1.7320508)\n\n// tau because working with rotations\n#define TURN 6.283185\n\n// converts rgb hex code to a vec3\n#define HEX(x) (vec4((x >> 24) & 255, (x >> 16) & 255, (x >> 8) & 255, x & 255) / 255.)\n\n// rotation matrix. idk why it works. thanks fabriceneyret!\n#define rot(a) mat2( cos( a + vec4(0,33,11,0) ) )\n\n// calculate the distance from the center of a hexagon\nfloat hex(vec2 uv) {\n    // Scales coords to the right proportions, and also scale the hexagons down\n    // loop around to tile\n    uv = abs(\n        mod(\n            uv + vec2(1.0, SQRT3),\n            vec2(2.0, 2.0 * SQRT3)\n        ) - vec2(1.0, SQRT3)\n    );\n    // hexangle proportions\n    // return whichever is closer:\n    // distance towards the top right side,\n    // or distance towards the right side\n    // (i.e. absolute value of x coordinate)\n    return max(\n        (uv.x + uv.y * SQRT3) / 2.,\n        uv.x\n    );\n}\n\nfloat map(float minv, float maxv, float x) {\n    if (minv == maxv) {return step(minv, x);}\n    return clamp(0., 1., (x - minv) / (maxv - minv));\n}\n\n// map the range [0, 1) to stripes of colors\n// you can change the number of colors by changing the constant here\n// and adding more colors and thresholds\n#define COLOR_COUNT 4\n// mixing sharpness. set to 0.0 to make it pixely\n#define BLEND_FACT 0.02\nvec4 colorize(float value) {\n    const vec4 color[COLOR_COUNT] = vec4[](\n        HEX(0x00000000),\n        HEX(0xFF66FFFF),\n        HEX(0x8000C0c0),\n        HEX(0x30006080)\n    );\n    const float thres[COLOR_COUNT] = float[](\n        0.0, // ignored\n        0.6,\n        0.65,\n        0.75\n    );\n    // loop around\n    value = fract(value);\n    // i don't like using for loops, but it's the best way\n    // i could think of to adapt to any number of colors.\n    vec4 color_out = mix(\n        color[COLOR_COUNT - 1],\n        color[0],\n        map(0.0, BLEND_FACT, value)\n    );\n    for (int i = 1; i < COLOR_COUNT; i++) {\n        if (value > thres[i]) {\n            color_out = mix(\n                color[i - 1],\n                color[i],\n                map(thres[i], thres[i] + BLEND_FACT, value)\n            );\n        } else {\n            return color_out;\n        }\n    }\n    return color_out;\n}\n\nfloat hexGrid(vec2 uv) {\n    return min(\n        hex(uv),\n        hex(uv + vec2(1.0, SQRT3))\n    );\n}\n\n#define LAYERS 8.\n#define CIRC_RADIUS 0.075\n#define SPEED (1. / 3.)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // makes it loop\n    float time = fract(iTime * SPEED);\n    // Scales coords so that the diagonals are all a known distance from center\n    vec2 uv = ( 2.* fragCoord - iResolution.xy ) / length(iResolution.xy);\n    \n    \n    // time changing colors\n    vec4 col = vec4(0);\n    \n    // add multiple grids\n    for (float i = 0.; i < LAYERS; i++) {\n        float ti = 0.1 + LAYERS - (i + time);\n        vec2 uv_ = uv * ti * 6.;\n        \n        vec4 thisCol = colorize(\n            hexGrid(\n                // Scales coords to the right proportions, and also scale the hexagons down\n                (\n                    uv_\n                    + vec2(cos(ti * 0.2 + time * TURN), sin(ti * 0.2 + time * TURN)) * CIRC_RADIUS\n                )\n                * rot(ti * 0.1 + -0.1)\n            ) * 0.5 + ti * 0.2 + .1\n        );\n        \n        col = mix(\n            col, thisCol, thisCol.a\n        );\n    }\n\n    // Output to screen\n    fragColor = vec4(col);\n}","name":"Buffer A","description":"","type":"buffer"}]}