{"ver":"0.1","info":{"id":"NtcSWN","date":"1639195775","viewed":148,"name":"MT19937 (maybe)","username":"akohdr","description":"First try re-implementing MT19937, tricky part large shared state vs GPU reg file or texture storage.\nLikely incorrect implementation since twister state write only 'catches' once per frame.\nNot sure best way to unit test this against known good data.\n\n","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["random"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Andrew Wild - akohdr/2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n/*\n  Not sure of applicability of this to shader world given large set of faster hash functions\n  but in former life/project (2006) I worked on implementing MT19937 in synthesizable Verilog\n  as part of larger Monte Carlo simulation where statistical distribution was important.\n  \n  Matsumoto paper:\n  https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.315.6296&rep=rep1&type=pdf\n  \n  I recently found some of my old notes and java RTL model so thought I'd try \n  using it as basis for a working GLSL implementation of MT19937 (or likely not)\n  \n  Tricky part implementing this in shader is the large shared state vs GPU reg file/texture access\n  Concurrent/missed state updates likely cause loss of determinism and effect PRNG distribution stats\n  \n  More background and link to seminar in another shader by ollj:\n \n     https://www.shadertoy.com/view/4llcWn \n     https://www.youtube.com/watch?v=45Oet5qjlms // Stanford seminar\n\n*/\n\nvoid mainImage( out vec4 o, in vec2 p )\n{\n  // Mersenne Twister state is maintained in BufferA\n\n  o = texture(iChannel0, p/iResolution.xy);\n  \n//  o = o.rrrr;\n//  o = vec4(o.r,0,0,0);\n//  o = vec4(0,o.g,0,0);\n//  o = vec4(0,0,o.b,0);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Created by Andrew Wild - akohdr/2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// https://mathworld.wolfram.com/MersennePrime.html\n//  number of form 2^n - 1 where n is\n//\n// 2,3,5,7,13,17,19,107,127,521,607,1279,2203,2281,3217,\n// 4253,4423,9689,9941,11213,19937  <= used in MT19937\n// 21701, 23209, 44497 ...\n\n#define MT_N 624     // MT19937 dimensions (+1), 623*32bits == 19,936\n#define N 624\n\n// If you have patience for init you can have N be large portion of texture\n// I'll leave it to mathematicians to decide on suitability of distribution for task at hand.\n// I believe the MATRIX_A, M and maybe masks would also need updating refer to Matsumoto paper:\n\n// https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.315.6296&rep=rep1&type=pdf\n\n//#define N 1000\n//#define N 10000      \n//#define N 100000      \n\n#define M 397        // offset\n\n#define MATRIX_A 0x9908b0df\n#define UPPER_MASK 0x80000000\n#define LOWER_MASK 0x7fffffff\n#define TEMPERING_MASK_B 0x9d2c5680\n#define TEMPERING_MASK_C 0xefc60000\n\nconst int[] mag01 = int[](0,MATRIX_A);\n\nint prj;\t\t// Previous read of word 'j'\nint i,j,k; \t    // divide by N counters acting as pointers to \n                // previous, current and current+M values\n\n//int mt [N]; // 1D since \"arrays of arrays supported in GLSL ES 3.10 and above only\"\n              // gave up with slow large shared arrays and used bufferA texture instead\n\n\n\n// Original java code derived from java port of C++ MT19937 \n// TODO: find link to java port starting point.\n\n\n/*\n  The crazy varible names in this iteration of java code resulted from piecemeal hand \n  transformations moving from algorithmic executable code toward a synthesizable definiton\n  \n  Indentation follows steps in synthesized pipeline of operations, one indent per tick in RTL\n  \n  If memory serves 'banks' in models exploited dual-port memory on Xilinx Spartan? fpgas of day\n  Seem to remember final timing closure coming in around 160-200MHz depending on utilization.\n  Theorectically you can use jump ahead feature of twister to cascade multiple cores outputing \n  as many numbers as you have space for cores on fpga for every tick of clock.\n  At that scale you're likely I/O rather than compute bound in your monte carlo sim.\n  \n  public class Mersenne6 implements IMersenne {\n\tprivate static final int N = 624;\t\t\t\t  // Number of dimensions\n\tprivate static final int M = 397;\n\tprivate static final int MATRIX_A = 0x9908b0df;\n\tprivate static final int UPPER_MASK = 0x80000000; // most significant w-r bits\n\tprivate static final int LOWER_MASK = 0x7fffffff; // least significant r bits\n\tprivate static final int TEMPERING_MASK_B = 0x9d2c5680;\n\tprivate static final int TEMPERING_MASK_C = 0xefc60000;\n\tprivate static final int mag01[] = {0, MATRIX_A};\n\n\t// the array for the state vector split across upper and lower portions of differing width\n\t// one memory dedicated per counter plus one for write this redundancy enables pipelining\n\tprivate static final int B = 2;\n\tprivate final int mt[][] = new int[N][B];\n\t// NOTE: had tried multiple arrays of differing types as better model but java bit manipulation\n\t//       issues means it's just as easy to play with n-dimensional array after all this is JUST a model\n\t\n\t//Bank access enums\n\tprivate int br;\t\t\t// current read bank\n\tprivate int bw;\t\t\t// current write bank\n\t\n\tprivate int jl;\t\t\t// Low bit of word 'j'\n\tprivate int bih;\t\t// High bit of word 'i'\n\tprivate int sbihjl;\t\t// right shift of bihjl\n\tprivate int mbihjl;\t\t// MATRIX_A result from bihjl\n\tprivate int rnd;\t\t// generated random number\n\tprivate int prj;\t\t// Previous read of word 'j'\n\t\n\tprivate int rj;\t\t\t// Memory read of word 'j'\n\tprivate int rk;\t\t\t// Memory read of work 'k'\n\t\n\tprivate int ari; \t\t// addressing registers\n\tprivate int awi; \t\t// addressing registers\n\tprivate int awj; \t\t// addressing registers\n\tprivate int ark; \t\t// addressing registers\n\tprivate int awk; \t\t// addressing registers\n\n\tprivate int i,j,k; \t// divide by N counters acting as pointers to previous, current and current+M values\n\t                   \t// could always use one counter plus const adders what's cheaper ?\n\t\n\tpublic Mersenne6(int seed)\n\t{\n\t\tfor (int b = 0; b<B;b++)\n\t\t\tfor (int k = 0,l = seed-1; k < N; mt[k++][b] = (++l&UPPER_MASK) | (l&LOWER_MASK), l *= 69069){}\n\t\tprj = seed; i = 0; j = 1; k = M;\t//initialise so as to pull first number from array\n\t\tbr=0;bw=br+1;\n\t}\n\t\n    // Indentation used to determine pipeline steps in Verilog data moves one indent per tick\n    \n\tpublic int genrand()\n\t{\n\t\t// 4 ticks cascaded to start of conditioning pipe\n\t\tbih = prj&UPPER_MASK;  //@ prj MUST be set before entering; in practice bih is zero for positive seeds\n\t\tari = awj = awk = j;\n\t\t\tj = ++j%N;\n\t\t\trj = mt[ari][br];\n\t\t\t\tprj = rj;  \t\t\t\t\t\t//@remember read for next cycle (handoff to next pipeline?)\n\t\t\t\t//mt[awj][bw] = mt[awk][bw] = rj;\n\t\t\t\tark = awj = awk = k;\n\t\t\t\t\tk = ++k%N;\t\t\n\t\t\t\trk = mt[ark][br];\n\t\t\t\t\t//mt[awj][bw] = mt[awk][bw] = rk;\n\t\t\t\tjl = rj&LOWER_MASK;  \t\t\t// combined in single bit select in verilog\n\t\t\t\tmbihjl = mag01[jl & 0x1];  \t\t// LSB select so doesn't need & mask NOTE: bihjl gets optimized out !\n\t\t\t\tsbihjl = (bih | jl) >>> 1; \t\t// combined in single bit select in verilog\n\t\t\t\t\trnd =  rk ^ sbihjl ^ mbihjl;\n\t\t\t\t\tawi = i;\n\t\t\t\t\t\ti = ++i%N;\n\t\t\t\t\t\tmt[awi][bw] = (rnd&UPPER_MASK) | (rnd&LOWER_MASK);\n\t\t\t\t\t\t\tbr = ++br%B;\n\t\t\t\t\t\t\tbw = ++bw%B;\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t// MUX 4 pipes here\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// condition output after MUXed pipelined calc units\n\t\t\t\t\t\t\t// 9 ticks dependant conditioning\n\t\t\t\t\t\t\t// (not sure we need all this)\n\t\t\t\t\t\t\tint tmp = rnd >>> 11;\n\t\t\t\t\t\t\t\trnd ^= tmp;\n\t\t\t\t\t\t\t\t\ttmp = rnd<<7;\n\t\t\t\t\t\t\t\t\t\ttmp &= TEMPERING_MASK_B;\n\t\t\t\t\t\t\t\t\t\t\trnd ^= tmp;\n\t\t\t\t\t\t\t\t\t\t\t\ttmp = rnd<<15;\n\t\t\t\t\t\t\t\t\t\t\t\t\ttmp &= TEMPERING_MASK_C;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\trnd ^= tmp;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttmp = rnd>>>18;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\trnd ^= tmp;\n\t\treturn rnd; \n\t}\n}\n\n\n*/\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by Andrew Wild - akohdr/2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Addressing macros to store twister state in lower scanlines of bufferA\n//#define ADDR(a) a%int(iResolution.x), a/int(iResolution.x)\n// rx used implicitly must be declared in functions using this macro\n#define ADDR(a) a%rx, a/rx\n\n// Read/Store macros, the store is problematic we can only commit if p is at the store location \n// large shared array for state too slow beyond ~170 elements on my hardware(!)\n#define MT_R(a)   (int(texture(iChannel0, vec2(ADDR(a))/iResolution.xy)))\n//#define MT_R(a)   int(texelFetch(iChannel0, ivec2(ADDR(a)),0).x)\n#define MT_W(p,a,v) if(length((p)-vec2(ADDR(a)))<1.) { o = vec4(v); }\n\nvoid init(out vec4 o, in vec2 p, int rx, int seed)\n{    \n    int l = seed-1;\n    \n    for (int k = 0; k < N; k++)\n    {\n        MT_W(p, k, (++l&UPPER_MASK) | (l&LOWER_MASK));\n        l *= 69069;\n    }\n    prj = seed; i = 0; j = 1; k = M;\n}\n\n    \nint rand(inout vec4 o, in vec2 p, in ivec2 ir)\n{\n    int rx = ir.x,\n        jl,\t\t\t// Low bit of word 'j'\n        bih,\t\t// High bit of word 'i'\n        sbihjl,\t\t// right shift of bihjl\n        mbihjl,\t\t// MATRIX_A result from bihjl\n        rnd,\t\t// generated random number\n        rj,\t\t\t// Memory read of word 'j'\n        rk,\t\t\t// Memory read of work 'k'\n        ari, \t\t// addressing registers\n        awi, \t\t// addressing registers\n        awj, \t\t// addressing registers\n        ark, \t\t// addressing registers\n        awk, \t\t// addressing registers\n        tmp;        // tmp\n\n      // essentially two reads, simple computation and a write on large twister state\n      \n      bih = prj&UPPER_MASK;\n      ari = awj = awk = j;\n        j = ++j%N;\n\n    // rj = mt[ari][br];\n       rj = MT_R(ari);\n//       rj = int(abs(float(N)*cos(float(iFrame+i))));            //TEST\n\n      prj = rj;\n      ark = awj = awk = k;\n        k = ++k%N;\t\n\n    // rk = mt[ark][br];\n       rk = MT_R(ark);\n//       rk = int(abs(float(N)*cos(float(iFrame+k))));            //TEST\n\n       jl = rj&LOWER_MASK;\n   mbihjl = mag01[jl & 1];\n   sbihjl = (bih | jl) >> 1;\n      rnd = rk ^ sbihjl ^ mbihjl;\n      awi = i;\n        i = ++i%N;\n\n    // mt[awi][bw] = (rnd&UPPER_MASK) | (rnd&LOWER_MASK);\n    MT_W(p, awi, (rnd&UPPER_MASK) | (rnd&LOWER_MASK));\n\n     tmp  = rnd >> 11;\n     rnd ^= tmp;\n     tmp  = rnd<<7;\n     tmp &= TEMPERING_MASK_B;\n     rnd ^= tmp;\n     tmp  = rnd<<15;\n     tmp &= TEMPERING_MASK_C;\n     rnd ^= tmp;\n     tmp  = rnd>>18;\n     rnd ^= tmp;\n\n    return rnd;\n}\n\n#define rand() rand(o,p,ir)\nvoid twist(inout vec4 o, in vec2 p, in ivec2 ir)\n{\n    if(iFrame==0 || iMouse.z>0.)\n        init(o, p, ir.x, 8891);    // seed twister on first frame or mouse click\n    else {\n        float r = float(rand());\n\n        if(p.y > (float(N/ir.x)+1.) \n            && length(p.x-mod(float(iFrame),iResolution.x)) < 1.\n        ) {\n            for(int l=rand()&0xFF; l>0 ; l--){}\n            for(float l=p.y; l>=0. ; l--)\n                o = normalize(vec4(ivec3(rand(),rand(),rand()),0));\n            o = .5+.5*o*sin(16.28*p.y*o);\n        }\n        \n    }\n}\n\n\nvoid mainImage( out vec4 o, in vec2 p )\n{\n    vec2 r = iResolution.xy,\n         a_vars = vec2(r.x,0);     // scanline address to store vars\n         \n    // maintain buffer state between frames\n    o = texture(iChannel0, p/r);\n    \n    // retrieve variables\n    ivec4 v = ivec4(texture(iChannel0, a_vars));\n    i = v.x;     j = v.y;     k = v.z;   prj = v.w;\n\n    // we can perform twist a number of times nice effect but\n    //   does this improve distribution or introduce bias? who knows......\n    \n    for(int i=0; i<10; i++)\n        twist(o, p+vec2(i,0), ivec2(r));\n\n    // store variables\n    if(length(p-a_vars)<2.) o = vec4(i,j,k,prj);\n}\n\n","name":"Buffer A","description":"","type":"buffer"}]}