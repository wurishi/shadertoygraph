{"ver":"0.1","info":{"id":"lstXRr","date":"1457630011","viewed":1139,"name":"Gold Frame","username":"Xor","description":"Here's my latest fractal experiment.","likes":28,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","fractal","light","gold"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define T iTime\n#define LIGHT vec3(cos(T)-1.,sin(T),cos(T*.5))*8.0-vec3(T*16.0,0,0)\n\nfloat MAX = 120.;\nfloat PRE = .01;\n\n//Mapping Function\nvec3 map(vec3 p, float s)\n{\n    vec3 S = vec3(8);\n    vec3 A = mod(p+s/2.0,s)-s/2.0;\n    //vec3 B = max(abs(p)-S,0.0) * sign(p-S);\n    return A;\n}\n//Main Distance Field Function\nfloat model(vec3 p)\n{   \n    float S = -1.0;\n    for(int i = 0;i<7;i++)\n    {\n        float I = exp2(float(i));\n        S = max(S,I/4.0-length(max(abs(map(p,I))-I/8.0,0.0)));\n    }\n    return S;\n}\n//Normal Function\nvec3 normal(vec3 p)\n{\n \tvec2 N = vec2(-1, 1) * PRE;\n\n \treturn normalize(model(p+N.xyy)*N.xyy+model(p+N.yxy)*N.yxy+\n                     model(p+N.yyx)*N.yyx+model(p+N.xxx)*N.xxx);\n}\n//Simple Raymarcher\nvec4 raymarch(vec3 p, vec3 d)\n{\n    float S = 0.0;\n    float T = S;\n    vec3 D = normalize(d);\n    vec3 P = p+D*S;\n    for(int i = 0;i<240;i++)\n    {\n        S = model(P);\n        T += S;\n        P += D*S;\n        if ((T>MAX) || (S<PRE)) break;\n    }\n    return vec4(P,min(T/MAX,1.0));\n}\n//Color/Material Function\nvec3 color1(vec3 p, vec3 n)\n{\n \tvec3 C = vec3(1,.8,.4);\n    vec3 D = normalize(LIGHT-p);\n    float M = model(p);\n \tfloat L = smoothstep(-.05,.05,M+model(p+D*.1));\n    \t  L *= smoothstep(-.5,.5,M+model(p+D));\n    \t  L *= smoothstep(-1.,1.,M+model(p+D*2.));\n          L *= max(dot(n,D),-.5)*.5+.5;\n    \t  L *= exp2(1.-length(LIGHT-p)/16.);\n    \n    return C*L;\n}\nvec3 color2(vec3 p, vec3 d)\n{\n    vec3 N = normal(p);\n    vec3 C = color1(p,N);    \n    \n    float A = exp2(1.-length(LIGHT-p)/16.);\n    float R = (1.-abs(dot(N,normalize(LIGHT-p))));\n    vec3 D = reflect(normalize(LIGHT-p),N);\n    return C+pow(max(dot(D,d),0.),32.)*A;\n}\n//Camera Variables\nvoid camera(out vec3 P,out vec3 D, out vec3 X, out vec3 Y, out vec3 Z)\n{\n\tfloat M = float((iMouse.x+iMouse.y)>0.);\n\tvec2 A = (.5-iMouse.xy/iResolution.xy)*vec2(6.2831,3.1416);\n    vec3 F = mix(vec3(1,0,0),vec3(cos(-A.x)*cos(A.y),sin(-A.x)*cos(A.y),sin(A.y)),M);\n\tP = vec3(-T*16.,0,0)+24.*F;\n\n\tD = -F;\n\n\tX = normalize(D);\n\tY = normalize(cross(X,vec3(0,0,1)));\n\tZ = cross(X,Y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 P,D,X,Y,Z;\n    camera(P,D,X,Y,Z);\n\tvec2 UV = (fragCoord.xy-iResolution.xy*.5)/iResolution.y;\n    D = normalize(mat3(X,Y,Z) * vec3(1.,UV));\n    \n    vec4 M = raymarch(P,D);\n    vec3 COL = vec3(.01,.01,.01)+max(color2(M.xyz,D)*sqrt(1.-M.w),0.);\n    COL += exp2(-length(cross(D,LIGHT-P)));\n\tfragColor = vec4(COL,0);\n}","name":"Image","description":"","type":"image"}]}