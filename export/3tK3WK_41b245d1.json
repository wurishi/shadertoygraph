{"ver":"0.1","info":{"id":"3tK3WK","date":"1580129291","viewed":472,"name":"test laser","username":"jojobavg","description":"test laser","likes":24,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","noise","fog","laser"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Using code from\n\n// Inigo Quilez for the primitives\n// https://www.shadertoy.com/view/Xds3zN\n\n//Morgan McGuire for the noise function\n// https://www.shadertoy.com/view/4dS3Wd\n\n#define time iTime\n\nuniform vec2 v2Resolution; // viewport resolution (in pixels)\n\n\nfloat random (in float x) {\n    return fract(sin(x)*1e4);\n}\n\n\nfloat noise(in vec3 p) {\n    const vec3 step = vec3(110.0, 241.0, 171.0);\n\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n\n    // For performance, compute the base input to a\n    // 1D random from the integer part of the\n    // argument and the incremental change to the\n    // 1D based on the 3D -> 1D wrapping\n    float n = dot(i, step);\n\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix( mix(mix(random(n + dot(step, vec3(0,0,0))),\n                        random(n + dot(step, vec3(1,0,0))),\n                        u.x),\n                    mix(random(n + dot(step, vec3(0,1,0))),\n                        random(n + dot(step, vec3(1,1,0))),\n                        u.x),\n                u.y),\n                mix(mix(random(n + dot(step, vec3(0,0,1))),\n                        random(n + dot(step, vec3(1,0,1))),\n                        u.x),\n                    mix(random(n + dot(step, vec3(0,1,1))),\n                        random(n + dot(step, vec3(1,1,1))),\n                        u.x),\n                u.y),\n            u.z);\n}\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nfloat sphere(in vec3 p, in vec2 uv) {\n  vec3 truc = vec3(p.x,p.y,0.0);\n  return length(truc)-1.0;\n}\n\nfloat fog(in vec3 p, vec3 centerPos, float scale,float radius ) {\n  \n  float x=(noise((p+(time*1.0)*2.0)*0.2)*2.0-1.0)*15.0;\n  float y=(noise((p+(time*1.0+5.0)*2.0)*0.2)*2.0-1.0)*15.0;\n  float z=(noise((p+(time*1.0+3.5)*2.0)*0.2)*2.0-1.0)*15.0;\n  p+=vec3(x,y,z);\n\treturn max((noise(p*scale)+noise(p*2.0*scale)*0.5+\n              noise(p*3.0*scale)*0.33+\n              noise(p*4.0*scale)*0.25)*0.4807,0.0)*5.0;\n}\n  \n\nfloat map(vec3 p, vec2 uv){\n  return sphere(p,uv);\n  }\n\n \nfloat mapHyper(vec3 p){ \n  return fog(p,vec3(0,0,0),0.5,0.1);\n  }  \n\n  \nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat udQuad( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n    \n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 dc = d - c; vec3 pc = p - c;\n    vec3 ad = a - d; vec3 pd = p - d;\n    vec3 nor = cross( ba, ad );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(dc,nor),pc)) +\n     sign(dot(cross(ad,nor),pd))<3.0)\n     ?\n     min( min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n     dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat map3(vec3 p){\nreturn udQuad(p,\n              vec3(5, 0, 100.0),\n              vec3(-5.0, 0, 100.0), \n              vec3(-5.0,   cos(time*0.35)*2.0, -100.0),\n              vec3(5.0,  cos(time*0.35)*2.0, -100.0));\n  }\n  \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\t\n\t\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1.0);\n  vec3 s=vec3(0.0,0.0,-100.0);\n  vec3 t=vec3(0.0,0.0,0.0);\n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n  vec3 cy=normalize(cross(cz,cx));\n  vec3 r=normalize(uv.x*cx+uv.y*cy+cz*0.7);\n  \n  vec3 p=s;\n float dd=0.0;\n  \n  vec3 col=vec3(0.0);\n//  float text1=mapHyper(p);\n  if(dd==500.0)col = vec3(0.0);\n  p=s;\n  dd=0.0;\n  vec2 c= vec2(0,0);\n  for(int i=0; i<1000; ++i) {\n    float d=map(p,uv);\n    float d2=map3(p);\n   float mH=mapHyper(p);\n    c+=vec2(pow(mH*0.06,2.0)*clamp(0.2-d2,0.0,1.0)*0.55+\n       pow(mH*clamp(cos((p.x+sin(p.x+time*100.0))*20.0),0.0,1.0),4.0)*0.007*clamp(0.05-d2,0.0,1.0)+mH*0.0004,0.0)+\n       pow(mH*0.06,2.0)*clamp(1.0-d2,0.0,1.0)*0.20;\n\n    if( d>0.0001 ){ break;}\n    p+=r*(0.1);\n    dd+=0.1;\n  }\n  \n \n  \n  col = mix(vec3(0,0,0),vec3(0.5,0.5,0.8),c.x);\n  \n  \n  fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}