{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"music","id":"4dfGzn","filepath":"/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"float hue2rgb(float p, float q, float t)\n{\n\tif(t < 0.0) t += 1.0;\n\tif(t > 1.0) t -= 1.0;\n\tif(t < 1.0/6.0) return p + (q - p) * 6.0 * t;\n\tif(t < 1.0/2.0) return q;\n\tif(t < 2.0/3.0) return p + (q - p) * (2.0/3.0 - t) * 6.0;\n\treturn p;\n}\n\nvec3 hslToRgb(float h, float s, float l)\n{\n    vec3 rgb;\n    if(s == 0.0)\n\t{\n        rgb = vec3( l );\n    }\n\telse\n\t{\n        float q = l < 0.5 ? l * (1.0 + s) : l + s - l * s;\n        float p = 2.0 * l - q;\n        rgb = vec3( hue2rgb(p, q, h + 0.33333), hue2rgb(p, q, h), hue2rgb(p, q, h - 0.33333) );\n    }\n\n    return rgb;\n}\n\nfloat intersectAuroraPlane( vec3 ro, vec3 rd, float planeZ )\n{\n\treturn ( -ro.z + planeZ ) / rd.z;\n}\n\nfloat intersectWaterPlane( vec3 ro, vec3 rd, float waterY )\n{\n\treturn ( -ro.y + waterY ) / rd.y;\n}\n\n// Clasic Perlin noise functions copied from the internet...\n\nvec3 mod289(vec3 x) \n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n} \n\nvec4 mod289(vec4 x)\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n \nvec4 permute(vec4 x)\n{\n    return mod289(((x*34.0)+1.0)*x);\n}\n \nvec4 taylorInvSqrt(vec4 r)\n{\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n \nvec2 fade(vec2 t) {\n    return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\nfloat cnoise(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\nfloat FBM( vec2 uv, float z )\n{\n\tfloat lacunarity = 2.0;\n\tfloat gain = 0.25;\n    float amplitude = 1.0;\n    float frequency = 1.0;\n    float sum = 0.0;\n    for(int i = 0; i < 4; ++i)\n    {\n        sum += amplitude * cnoise(vec3( uv * frequency, z ));\n        amplitude *= gain;\n        frequency *= lacunarity;\n    }\n    return sum;\n}\n\nfloat calcAurora( vec3 ro, vec3 rd, out vec3 pt, out vec3 color )\n{\n\tfloat angle = 1.0;\n\tvec3 aro = ro;\n\tvec3 ard = rd;\n\t\n\tfloat at = intersectAuroraPlane( aro, ard, 1.0 );\n\tpt = aro + at * ard;\n\t\n\tvec2 uv = pt.xy - vec2( -0.5, 0.7 );\n\t\n\tvec3 fft = hslToRgb( \n\t\tuv.y * 0.4 - 0.05 + texture( iChannel1, vec2( uv.x * 0.05 + iTime * 0.002, 0.0 ) ).x * 0.1\n\t\t, .5, .5 ) * 0.95;\n\t\n\tfft *= texture( iChannel0, vec2( mod( abs( uv.x ) * 0.35, 1.0 ), 0.0 ) ).xyz * 0.3\n\t\t+  texture( iChannel0, vec2( mod( abs( uv.x * 0.1 ) * 0.35, 1.0 ), 0.0 ) ).xyz * 0.7;\n\tfloat dist = 1.0 - min( 1.0, max( 0.0, length( vec2( 0.5, 0.2 ) - uv ) * 0.8 ) );\n\tcolor = vec3( fft ) * smoothstep( 0.0, 1.0, dist );\n\t\n\tvec3 stars = vec3( 0.0, 0.1, 0.2 );\n\tfor( float i = 0.0; i < 60.0; i+=1.0 ) \n\t{\n\t\tvec3 star = texture( iChannel1, vec2( i * 0.03, 0.1 ) ).xyz; // 0-1;0-1\n\t\tstar.x = mod( star.x - iTime * 0.0015 * (texture( iChannel1, vec2( i * 0.03, 0.0 ) ).x * 3.0 + 1.0)\n\t\t\t\t\t , 1.0 );\n\t\tstar.x -= 0.3;\n\t\tstar.x *= 2.3;\n\t\tstar.z = ( star.z * 0.6 + 0.4 ) * 300.0;\n\t\tfloat lumi = smoothstep( 0.0, 1.0, max( 0.0, min( 1.0, ( 1.1 - length( uv - star.xy ) * star.z ) ) ) ) * 0.8 *\n\t\t\tabs( sin( iTime * 0.1 * (1.0+i*0.111) ) * texture( iChannel1, vec2( i * 0.3, 0.0 ) ).x * 0.6 );\n\t\t\t\n\t\tstars += vec3( min( vec3( 1.0, 1.0, 1.0 ), color + vec3( 0.5,0.5,0.5 ) ) * lumi );\n\t}\n\tcolor += stars;\n\t// pseudo landscape\n\tcolor *= clamp( (uv.y*3.0-FBM(uv * 10.0, 0.) * .2) * 50.0 - 10.0, 0.0, 1.0 );\n\t\n\treturn at;\n}\n\nfloat pattern( vec2 uv )\n{\n\treturn FBM( uv, iTime );\n}\n\nvec3 colorize( vec2 uv, vec3 ro, vec3 rd )\n{\n\t// aurora\n\tvec3 aurora = vec3(0.0,0.0,0.0);\n\tvec3 apt = vec3(0.0,0.0,0.0);\n\tfloat at = calcAurora( ro, rd, apt, aurora );\n\t\n\t// water\n\tfloat waterH = 0.7;\n\tif ( apt.y < waterH )\n\t{\n\t\tfloat wt = intersectWaterPlane( ro, rd, waterH );\n\t\t{\n\t\t\tvec3 wpt = ro + wt * rd;\n\t\t\tvec2 uvfbm = uv * 100.0;\n\t\t\tuvfbm.y *= 1.5;\n\t\t\tuvfbm.y += iTime * 0.1;\n\t\t\tvec2 disturb = vec2( pattern( uvfbm ), pattern( uvfbm + vec2( 5.2, 1.3 ) ) );\n\t\t\tdisturb *= 0.1;\n\t\t\tvec3 normal = normalize( vec3( disturb.x, 1.0, disturb.y ) );\n\t\t\tvec3 R = reflect( normalize( -rd ), normal );\n\t\t\tat = calcAurora( wpt, R, apt, aurora );\n\t\t}\n\t}\n\t\n\treturn aurora;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\tvec3 ro = vec3( 0.0, 1.0, -0.2 );\n\tvec3 rd = vec3( uv - vec2(0.5, 0.5), 1.0 );\n\trd.x *= iResolution.x / iResolution.y;\n\t\n\tvec3 color = colorize( uv, ro, rd );\n\t\n\tfragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldfGWf","date":"1380490405","viewed":4097,"name":"Aurora Borealis","username":"mi_ku","description":"Quick'n'dirty Aurora Borealis like audio visualization","likes":41,"published":1,"flags":0,"usePreview":1,"tags":["visualization","audio","auroraborealis"],"hasliked":0,"parentid":"","parentname":""}}