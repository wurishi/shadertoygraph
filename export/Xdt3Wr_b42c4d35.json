{"ver":"0.1","info":{"id":"Xdt3Wr","date":"1449055493","viewed":929,"name":"Quantization & Dithering 2","username":"104","description":"Combining https://www.shadertoy.com/view/4ddGWr and https://www.shadertoy.com/view/4dd3Wn, showing how to add res reduction, quantization, and dithering to any scene. I'd like to expand and use a fixed-color palette.","likes":25,"published":1,"flags":0,"usePreview":0,"tags":["palette","quantization","dithering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// for a dramatic display of the value of dithering,\n// use these settings.\n//const float PaletteRGBSize = 2.;// only 1 bit per R G B (8-color palette)\n//const float ResolutionDivisor = 1.;// 1 pixel = 1 pixel, the finest visible.\n\n\nconst float PaletteRGBSize = 4.;// number of values possible for each R, G, B.\nconst float ResolutionDivisor = 2.;\n\n//#define USE_BAYER4x4\n#define USE_BAYER8x8\n//#define USE_NOISE\n//#define USE_ANIM_NOISE\n\n//----------------------------------------------------------------------------\n\n\nfloat quantize(float inp, float period)\n{\n    return floor((inp+period/2.)/period)*period;\n}\nvec2 quantize(vec2 inp, vec2 period)\n{\n    return floor((inp+period/2.)/period)*period;\n}\n\n\n//----------------------------------------------------------------------------\n\n\n//----------------------------------------------------------------------------\nfloat bayer4x4(vec2 uvScreenSpace)\n{\n\tvec2 bayerCoord = floor(uvScreenSpace/ResolutionDivisor);\n    bayerCoord = mod(bayerCoord, 4.);\n    const mat4 bayerMat = mat4(\n    1,9,3,11,\n    13,5,15,7,\n    4,12,2,10,\n    16,8,14,6) / 16.;\n    int bayerIndex = int(bayerCoord.x + bayerCoord.y * 4.);\n    if(bayerIndex == 0) return bayerMat[0][0];\n    if(bayerIndex == 1) return bayerMat[0][1];\n    if(bayerIndex == 2) return bayerMat[0][2];\n    if(bayerIndex == 3) return bayerMat[0][3];\n    if(bayerIndex == 4) return bayerMat[1][0];\n    if(bayerIndex == 5) return bayerMat[1][1];\n    if(bayerIndex == 6) return bayerMat[1][2];\n    if(bayerIndex == 7) return bayerMat[1][3];\n    if(bayerIndex == 8) return bayerMat[2][0];\n    if(bayerIndex == 9) return bayerMat[2][1];\n    if(bayerIndex == 10) return bayerMat[2][2];\n    if(bayerIndex == 11) return bayerMat[2][3];\n    if(bayerIndex == 12) return bayerMat[3][0];\n    if(bayerIndex == 13) return bayerMat[3][1];\n    if(bayerIndex == 14) return bayerMat[3][2];\n    if(bayerIndex == 15) return bayerMat[3][3];\n\n    return 10.;// impossible\n}\n\nfloat bayer8x8(vec2 uvScreenSpace)\n{\n    return texture(iChannel1, uvScreenSpace/(ResolutionDivisor*8.)).r;\n}\n\n\n\n\n\n\n\n\n\n\n\n//----------------------------------------------------------------------------\n// c64 palette\nvec3 color0 = vec3(0,0,0);// black\nvec3 color1 = vec3(1,1,1);// white\nvec3 color2 = vec3(0.41,0.22,0.17);// red\nvec3 color3 = vec3(0.44,0.64,0.70);// cyan\nvec3 color4 = vec3(0.44,0.24,0.53);// violet\nvec3 color5 = vec3(0.35,0.55,0.26);// green\nvec3 color6 = vec3(0.21,0.16,0.47);// blue\nvec3 color7 = vec3(0.72,0.78,0.44);// yellow\nvec3 color8 = vec3(0.44,0.31,0.15);// orange\nvec3 color9 = vec3(0.26,0.22,0);// brown\nvec3 colorA = vec3(0.60,0.40,0.35);// light red\nvec3 colorB = vec3(0.27,0.27,0.27);// grey1\nvec3 colorC = vec3(0.42,0.42,0.42);// grey2\nvec3 colorD = vec3(0.60,0.82,0.52);// light green\nvec3 colorE = vec3(0.42,0.37,0.71);// light blue\nvec3 colorF = vec3(0.58,0.58,0.58);// grey3\n\n// not sure the best curve to use for mixing. linear looks nice to me though; better\n// than smoothstep and smootherstep.\n// smoothstep is of course the fastest though.\nfloat gradientStep(float edge0, float edge1, float x)\n{\n    return smoothstep(edge0, edge1, x);\n\n    // smootherstep\n    //x = clamp((x - edge0)/(edge1 - edge0), 0.0, 1.0);\n    //return x*x*x*(x*(x*6. - 15.) + 10.);\n    \n    // linear\n    //x = clamp((x - edge0)/(edge1 - edge0), 0.0, 1.0);\n    //return x;\n}\n\n\n// edge colors will naturally get slightly more intensity because they don't blend with\n// anything on the left/right.\nvec3 gradient(float t, vec3 c1, vec3 c2, vec3 c3)\n{\n    const float colCount = 3.;\n    const float bandSize = 1./colCount;\n    const float plateauSize = 0.0 * (bandSize/2.);\n    t -= bandSize*.5;\n\treturn\n        + (c1 * (1.-gradientStep(plateauSize,bandSize-plateauSize, t-bandSize*0.)))\n        + (c2 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*1.))))\n        + (c3 * (1.-gradientStep(plateauSize,bandSize-plateauSize, bandSize*2.-t)))\n        ;\n}\n\nvec3 gradient(float t, vec3 c1, vec3 c2, vec3 c3, vec3 c4)\n{\n    const float colCount = 3.;\n    const float bandSize = 1./colCount;\n    const float plateauSize = 0.0 * (bandSize/2.);\n    t -= bandSize*.5;\n\treturn\n        + (c1 * (1.-gradientStep(plateauSize,bandSize-plateauSize, t-bandSize*0.)))\n        + (c2 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*1.))))\n        + (c3 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*2.))))\n        + (c4 * (1.-gradientStep(plateauSize,bandSize-plateauSize, bandSize*3.-t)))\n        ;\n}\n\nvec3 gradient(float t, vec3 c1, vec3 c2, vec3 c3, vec3 c4, vec3 c5)\n{\n    const float colCount = 5.;\n    const float bandSize = 1./colCount;\n    const float plateauSize = 0.0 * (bandSize/2.);\n    t -= bandSize*.5;\n\treturn\n        + (c1 * (1.-gradientStep(plateauSize,bandSize-plateauSize, t-bandSize*0.)))\n        + (c2 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*1.))))\n        + (c3 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*2.))))\n        + (c4 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*3.))))\n        + (c5 * (1.-gradientStep(plateauSize,bandSize-plateauSize, bandSize*4.-t)))\n        ;\n}\n\n\n\nvec3 gradient(float t, vec3 c1, vec3 c2, vec3 c3, vec3 c4, vec3 c5, vec3 c6, vec3 c7, vec3 c8, vec3 c9, vec3 c10, vec3 c11, vec3 c12, vec3 c13, vec3 c14, vec3 c15, vec3 c16)\n{\n    const float colCount = 16.;\n    const float bandSize = 1./colCount;\n    const float plateauSize = 0.0 * (bandSize/2.);\n    t -= bandSize*.5;\n\treturn\n        + (c1 * (1.-gradientStep(plateauSize,bandSize-plateauSize, t-bandSize*0.)))\n        + (c2 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*1.))))\n        + (c3 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*2.))))\n        + (c4 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*3.))))\n        + (c5 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*4.))))\n        + (c6 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*5.))))\n        + (c7 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*6.))))\n        + (c8 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*7.))))\n        + (c9 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*8.))))\n        + (c10 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*9.))))\n        + (c11 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*10.))))\n        + (c12 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*11.))))\n        + (c13 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*12.))))\n        + (c14 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*13.))))\n        + (c15 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*14.))))\n        + (c16 * (1.-gradientStep(plateauSize,bandSize-plateauSize, bandSize*15.-t)))\n        ;\n\n}\n\n\nvec3 getSceneColor(in vec2 uv )\n{\n    vec4 fragColor;\n//\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    if(uv.y > .666)\n\t\tfragColor = vec4(gradient(uv.x, color3, color2, colorC, colorD),1);\n    else if(uv.y > .333)\n\t\tfragColor = vec4(gradient(uv.x, color2, color3, color4, color5, color6),1);\n    else\n\t\tfragColor = vec4(gradient(uv.x, color0, color1, color2, color3, color4, color5, color6, color7, color8, color9, colorA, colorB, colorC, colorD, colorE, colorF),1);\n\n\n    // post-processing courtesy of IQ ( https://www.shadertoy.com/view/ll2GD3 )\n\n    // band\n    float f = fract(uv.y*3.0);\n    // borders\n    fragColor.rgb *= smoothstep( 0.49, 0.47, abs(f-0.5) );\n    // shadowing\n    fragColor.rgb *= 0.5 + 0.5*sqrt(4.0*f*(1.0-f));\n    \n    return fragColor.rgb;\n}\n\nfloat rand(vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;// 0-1\n    \n    // space between values of the dest palette\n    vec3 quantizationPeriod = vec3(1./(PaletteRGBSize-1.));\n    \n\tvec2 uvPixellated = floor(fragCoord / ResolutionDivisor)*ResolutionDivisor;\n    \n    // original color panel---------------------\n    vec3 originalCol = getSceneColor(uv);\n    \n    // dithered panel---------------------\n    vec3 dc = getSceneColor(uvPixellated / iResolution.xy);\n    // apply bayer matrix, perturbing the original color values.\n#ifdef USE_BAYER4x4\n    dc += (bayer4x4(fragCoord)-.5)*(quantizationPeriod);\n#endif\n#ifdef USE_BAYER8x8\n\tdc += (bayer8x8(fragCoord)-.5)*(quantizationPeriod);\n#endif\n#ifdef USE_NOISE\n\tdc += (rand(uvPixellated)-.5)*(quantizationPeriod);\n#endif\n#ifdef USE_ANIM_NOISE\n\tdc += (rand(vec2(rand(uvPixellated),iDate.w))-.5)*(quantizationPeriod);\n#endif\n    // quantize color to palette\n    dc = vec3(\n        quantize(dc.r, quantizationPeriod.r),\n        quantize(dc.g, quantizationPeriod.g),\n        quantize(dc.b, quantizationPeriod.b)\n            );\n   \n    // quantize to palette (raw quantization panel)---------------------\n    vec3 qc = getSceneColor(uvPixellated / iResolution.xy);\n    qc = vec3(\n        quantize(qc.r, quantizationPeriod.r),\n        quantize(qc.g, quantizationPeriod.g),\n        quantize(qc.b, quantizationPeriod.b)\n            );\n\n\n    // framing and post\n    float ySplit = (iMouse.y > 0.0 ? iMouse.y / iResolution.y : 0.3);\n    float xSplit = .7;\n    if(iMouse.x > 0.) xSplit = iMouse.x / iResolution.x;\n    if(uv.x > xSplit)\n\t    fragColor = vec4(originalCol, 1);\n    else\n    {\n        if(uv.y > ySplit)\n\t\t    fragColor = vec4(dc, 1);\n        else\n\t\t    fragColor = vec4(qc, 1);\n    }\n\n    float f = abs(uv.x - xSplit);\n    fragColor.rgb *= smoothstep(.00,.005, f);\n    f = abs(uv.y - ySplit);\n    if(uv.x < xSplit)\n\t    fragColor.rgb *= smoothstep(.00,.005, f);\n}\n\n\n\n\n\n","name":"","description":"","type":"image"}]}