{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"//GAMMA_SRGB, GAMMA_2, GAMMA_24\n#define GAMMA_SRGB\n\n//note: normalized rand, [0;1[\nfloat nrand( vec2 n )\n{\n  return fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\nvec3 nrand3( vec2 n ) {\n\treturn fract( sin(dot(n.xy, vec2(12.9898, 78.233)))* vec3(43758.5453, 28001.8384, 50849.4141 ) );\n}\n\nfloat mytrunc( float a, float l )\n{\n\treturn floor(a*l)/l;\n}\nvec3 mytrunc( vec3 a, float l )\n{\n\treturn floor(a*l)/l;\n}\nvec4 mytrunc( vec4 a, float l )\n{\n\treturn floor(a*l)/l;\n}\nfloat truncRound( float a, float l )\n{\n\treturn floor(a*l+0.5)/l;\n}\nvec3 truncRound( vec3 a, float l )\n{\n\treturn floor(a*l+0.5)/l;\n}\n\n\n//CORRECT_SRGB_CONVERSION\n#if defined( GAMMA_SRGB )\n// see http://www.opengl.org/registry/specs/ARB/framebuffer_sRGB.txt\nvec3 srgb2lin( vec3 cs )\n{\n\tvec3 c_lo = cs / 12.92;\n\tvec3 c_hi = pow( (cs + 0.055) / 1.055, vec3(2.4) );\n\tvec3 s = step(vec3(0.04045), cs);\n\treturn mix( c_lo, c_hi, s );\n}\nvec3 lin2srgb( vec3 cl )\n{\n\t//cl = clamp( cl, 0.0, 1.0 );\n\tvec3 c_lo = 12.92 * cl;\n\tvec3 c_hi = 1.055 * pow(cl,vec3(0.41666)) - 0.055;\n\tvec3 s = step( vec3(0.0031308), cl);\n\treturn mix( c_lo, c_hi, s );\n}\n#endif //GAMMA_SRGB\n\n#if defined( GAMMA_2 )\nvec3 lin2srgb( vec3 cl ) {\n\treturn sqrt(cl);\n}\nvec3 srgb2lin( vec3 cs ) {\n\treturn cs*cs;\n}\n#endif //GAMMA_2\n\n#if defined( GAMMA_24 )\nvec3 lin2srgb( vec3 cl ) {\n\treturn pow( cl, vec3(1.0/2.4) );\n}\nvec3 srgb2lin( vec3 cs ) {\n\treturn pow( cs, vec3(2.4) );\n}\n#endif //GAMMA_24\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\tfloat its = uv.y * uv.y;\n\t\n\tfloat nrnd = nrand( uv ); //normalised noise [0;1[\n\tfloat nrnd_2 = nrand( uv + 0.597149 );\n\t//vec3 nrnd3 = nrand3( uv ); //rgb normalised noise [0;1[\n\t//float srnd =   -0.5+nrnd; //signed noise [-1;1[\n\tfloat srnd_2 = -0.5+nrnd_2;\n\tfloat trnd = nrnd + srnd_2; //\"triangular\" noise\n\n\tconst float levels = 8.0;\n\t\n\tvec3 val = vec3(its);\n\tvec3 val_noise = vec3(its + nrnd/levels);\n\tvec3 val_noise_srgb = srgb2lin(lin2srgb(vec3(its))+nrnd/levels);\n\n\t\n\t//note: convert to srgb and quantize\n\tvec3 outval            = lin2srgb( val );\n\tvec3 outval_round      = truncRound( lin2srgb(val), levels );\n\tvec3 outval_noise      = mytrunc( lin2srgb(val_noise), levels );\n\tvec3 outval_noise_srgb = mytrunc( lin2srgb(val_noise_srgb), levels );\n\t\n\n\t//display values\n\tvec4 outcol = vec4(0);\n\tif ( uv.x < 1.0/4.0 )\n\t\toutcol.rgb = outval;\n\telse if ( uv.x < 2.0 / 4.0 )\n\t\toutcol.rgb = outval_round;\n\telse if ( uv.x < 3.0 / 4.0 )\n\t\toutcol.rgb = outval_noise;\n\telse if ( uv.x < 4.0 / 4.0 )\n\t\toutcol.rgb = outval_noise_srgb;\n\n\t//note: display error\n\t//outcol.rgb = abs( outcol.rgb - lin2srgb(val) );\n\t\t\n\t//display lines\n\tif ( abs(uv.x - 1.0/4.0) < 0.001 ) outcol = vec4(0);\n\tif ( abs(uv.x - 2.0/4.0) < 0.001 ) outcol = vec4(0);\n\tif ( abs(uv.x - 3.0/4.0) < 0.001 ) outcol = vec4(0);\n\n\tfragColor = outcol;\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XsfXzf","date":"1404866611","viewed":1640,"name":"dithering: srgb","username":"hornet","description":"Shows dithering color when using an autoconverting sRGB rendertarget.\nFrom left to right:\n- signal\n- quantized signal, properly rounded\n- quantized incorrect dithered signal in linear space\n- quantized signal correctly dithered in srgb space.","likes":20,"published":1,"flags":0,"usePreview":0,"tags":["banding","dithering","srgb"],"hasliked":0,"parentid":"","parentname":""}}