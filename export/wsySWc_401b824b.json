{"ver":"0.1","info":{"id":"wsySWc","date":"1575152771","viewed":122,"name":"Ray Tracer Spheres Stolen","username":"undeadmockingbird","description":"stolen spheres: https://www.shadertoy.com/view/XllBRf","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int nSpheres = 5; \nconst float sphereRadius = 3.0 / log2(float(nSpheres));\nconst float tau = 6.28318;\nconst float inf = 999.0;\nstruct Hit { \n    float t; \n    vec3 p; \n    vec3 n;\n    int id;\n};\nHit noHit;\n\nHit sphereHit(\n    vec3 center, \n    float radius, \n    vec3 rayOrigin, \n    vec3 rayDirection, \n    int id) \n{\n    radius += sin(dot(rayOrigin,rayDirection) * 5.0) / 2.0;\n    float a = dot(rayDirection, rayDirection);\n    vec3 L = rayOrigin - center;\n    float b = 2.0 * dot(rayDirection, L);\n    float c = dot(L, L) - radius * radius;\n    float discrim = b * b - 4.0 * a * c;\n    if (discrim < 0.0) return noHit;\n    float t = (-b - sqrt(discrim)) / (2.0 * a);\n    if (t < 0.0) {\n        return noHit;\n    }\n    vec3 p = rayOrigin + t * rayDirection;\n    return Hit(t, p, normalize(p - center), id);\n}\n\nHit hitSomething(vec3 rayOrigin, vec3 rayDirection, float time) {\n    const float fns = float(nSpheres);\n    Hit minHit = noHit;\n    for (int i = 0; i < nSpheres; i++) {\n        float fi = float(i);\n        float fni = fi / fns;\n        float d = sin(time * fni + fi) + 2.5;\n        vec3 center = vec3(\n            d*cos(tau*fni+time*10.0*fni) + sin(time*10.0) + 1.0, \n            d*sin(tau*fni+time*10.0*fni) + 1.0,\n            d*sin(0.5*tau*fni+time*fni*1.4142) + cos(time*10.0) + 1.0);\n        Hit hit = sphereHit(\n            center, \n            sphereRadius + sphereRadius * 2.0 * pow(float(i%10)/10.0, 5.0), \n            rayOrigin, \n            rayDirection, \n            0);\n        if (hit.t <= 0.0 || hit.t > minHit.t) continue;\n        minHit = hit;\n    }\n    Hit hit = sphereHit(vec3(0.0, -41.5, 2.0), 40.0, rayOrigin, rayDirection, 1);\n    if (hit.t > 0.0 && hit.t < minHit.t) {\n        minHit = hit;\n    }\n    return minHit;\n}\n\nvec3 colorSomething(\n    Hit hit, \n    float time, \n    vec3 rayOrigin, \n    vec3 rayDirection, \n    mat3x3 cam) \n{\n    if (hit.t > inf - 0.5) {\n        return vec3(0.0, 0.75+0.25*sin(time), 1.0);\n    }\n    vec3 color;\n    // diffuse\n    if (hit.id == 0) {\n        float dup    = 1.0 * dot(hit.n, cam[1]) + 0.0;\n        float dright = 1.0 * dot(hit.n, cam[0]) + 0.0;\n        float dfwd   = 1.0 * dot(hit.n, -cam[2] ) + 0.0;\n        color = vec3(dright, dup, dfwd);\n    } else if(hit.id == 1) {\n        color = vec3(sin((hit.p.x+iTime)*3.0), cos(hit.p.y*20.0),0.0);\n    }\n    // specular\n    vec3 refl = reflect(rayDirection, hit.n);\n    float spec = pow(dot(refl, cam[1]), 20.0);\n    if (spec > 0.0) {\n        color += vec3(spec, spec, spec);\n    }\n    return color;\n}\n\nconst int maxDepth = 4;\nvec3 trace( \n    mat3x3 cam, \n    vec3 rayOrigin, \n    vec3 rayDirection, \n    float time)\n{\n    vec3 color = vec3(0.2);\n    float ref = 1.0;\n    for (int i = 0; i < maxDepth; i++) {\n        Hit minHit = hitSomething(rayOrigin, rayDirection, time);\n        if (minHit == noHit) {\n            break;\n        }\n        color += ref * colorSomething(minHit, time, rayOrigin, rayDirection, cam);\n        ref *= 0.6;\n        rayOrigin = minHit.p;\n        rayDirection = reflect(rayDirection, minHit.n);\n    }\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    const vec3 zero = vec3(0.0, 0.0, 0.0);\n    noHit = Hit(inf, zero, zero, -1);\n    \n    // make time optionally srubbable\n    float time = (iMouse.z > 0.0) ? iMouse.x / iResolution.x : iTime / 15.0;\n    float camDist = 8.0;\n    vec3 rayOrigin = vec3(\n        1.1 * camDist * sin(tau * time * 0.5), \n        0.0,\n        0.9 * camDist * cos(tau * time * 0.5));\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - vec2(1.0, 1.0);\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 lookat = vec3(0.0, -1.0, 0.0);\n    vec3 fwd   = normalize(lookat - rayOrigin);\n    vec3 right = normalize(cross(fwd, up));\n    vec3 camup = normalize(cross(right, fwd));\n    vec3 rayDirection = normalize(fwd + 0.5 * (uv.x*right + uv.y*up));\n    \n    fragColor = vec4(trace(\n        mat3x3(right, camup, fwd), rayOrigin, rayDirection, time), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}