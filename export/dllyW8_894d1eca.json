{"ver":"0.1","info":{"id":"dllyW8","date":"1690701948","viewed":89,"name":"6.2 Raymarcher (blinn-phong HDR)","username":"Envy24","description":"https://en.wikipedia.org/wiki/Blinn%E2%80%93Phong_reflection_model\nhttps://bruop.github.io/tonemapping/\nMore tonemap functions: https://www.shadertoy.com/view/WdjSW3","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","reflection","phong","light","model","blinn"],"hasliked":0,"parentid":"clscDH","parentname":"6.1 Raymarcher (phong HDR)"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale + origin;\n}\n\n// SDFs\nfloat boxSDF_L2(vec3 P, vec3 S)\n{ \n  P = abs(P) - S; \n  return length(max(P,vec3(0.))) + min(max(P.x,max(P.y,P.z)),0.0);\n}\nfloat sphereSDF_L2(in vec3 P, in vec3 C, in float r) { return length(P - C)-r; }\nfloat planeSDF_L2(in vec3 P, in vec3 N, in float height) { return dot(P-vec3(0,-1,0),N); }\n\n/* SCENE */\n#define NUM_OF_OBJECTS ( 3 )\nmat4 bwd_transforms[NUM_OF_OBJECTS];\nMATERIAL materials[NUM_OF_OBJECTS];\n#define NUM_OF_LIGHTS ( 3 )\nLIGHT lights[NUM_OF_LIGHTS];\n\nvoid init_scene()\n{\n    materials[0].diffuse_Kd = 1. * vec3(1);\n    materials[0].ambient_Ka = 0.1 * materials[0].diffuse_Kd;\n    materials[0].specular_Ks = 2.8 * materials[0].diffuse_Kd;\n    materials[0].spec_exp = 64.;\n    \n    materials[1].diffuse_Kd = 1. * vec3(1);\n    materials[1].ambient_Ka = 0.1 * materials[1].diffuse_Kd;\n    materials[1].specular_Ks = 0.2 * materials[1].diffuse_Kd;\n    materials[1].spec_exp = 64.;\n    \n    materials[2].diffuse_Kd = 0.8 * vec3(.1,.4,.7);\n    materials[2].ambient_Ka = 0.1 * materials[2].diffuse_Kd;\n    materials[2].specular_Ks = 0.8 * materials[2].diffuse_Kd;\n    materials[2].spec_exp = 16.;\n    \n    float T = iTime;\n    bwd_transforms[0] = bwd_srt_transform(vec3(1), vec3(0), vec3(-1,0.,0));\n    bwd_transforms[1] = mat4(1);\n    bwd_transforms[2] = bwd_srt_transform(vec3(1), vec3(T, T*.5, T), vec3(1,0.5,1.0));\n        \n    lights[0].pos = vec3(-10,10,10);\n    lights[0].diffuse_Id = vec3(1,0,0);\n    lights[0].ambient_Ia = 0.1 * lights[0].diffuse_Id;\n    lights[0].specular_Is = lights[0].diffuse_Id;\n    \n    lights[1].pos = vec3(0,10,10);\n    lights[1].diffuse_Id = vec3(0,1,0);\n    lights[1].ambient_Ia = 0.1 * lights[1].diffuse_Id;\n    lights[1].specular_Is = lights[1].diffuse_Id;\n    \n    lights[2].pos = vec3(10,10,10);\n    lights[2].diffuse_Id = vec3(0,0,1);\n    lights[2].ambient_Ia = 0.1 * lights[2].diffuse_Id;\n    lights[2].specular_Is = lights[2].diffuse_Id;\n}\n\nfloat find_closest_scene_object(in vec3 marching_point, out int hitted_idx)\n{\n    float min_d = 9e5, U = 1.;\n    for (int idx = 0; idx < NUM_OF_OBJECTS; ++idx)\n    {\n        float d;\n        vec3 P = (bwd_transforms[idx] * vec4(marching_point, 1)).xyz;\n        \n        switch(idx)\n        {      \n\t\tcase 0: d = sphereSDF_L2(P, vec3(0), 1.); break;  \n        case 1: d = planeSDF_L2(P, vec3(0,1,0), -1.); break;\n        case 2: d = boxSDF_L2(P, vec3(0.5)); break;\n        }\n        \n        min_d = min(min_d, d); // this also works as z-buffer.\n        \n        // Need to update index?\n        hitted_idx = \n            min_d == d ?\n                idx :\n                hitted_idx;\n    }\n    return min_d;\n}\n/* SCENE */\n\n/* You can see how this works in 2d here:\n   https://www.shadertoy.com/view/slyBRc */\nvec3 approximate_normal(in vec3 P)\n{    \n    const float delta = .01; int dummy = -1;        \n    // Sample distance function at hit point and three nearby points.\n    float s0 = find_closest_scene_object(P, dummy),\n          s1 = find_closest_scene_object(P + vec3(delta, 0, 0), dummy),\n          s2 = find_closest_scene_object(P + vec3(0, delta, 0), dummy),\n          s3 = find_closest_scene_object(P + vec3(0, 0, delta), dummy);\n    // Calculate finite differencies.    \n    float dfdx = s1 - s0,\n          dfdy = s2 - s0,\n          dfdz = s3 - s0;\n    // Approximate gradient/normal direction.\n    return normalize(vec3(dfdx, dfdy, dfdz));\n}\n\nHIT ray_march(\n    RAY ray,\n    float max_num_of_steps,\n    float max_distance,\n    float surface_distance) \n{\n    float marched_distance = 0.0; // Distance marched from ray origin.\n    float minimal_distance = 0.0; // Current distance to closest object.\n\n    bool quit = false, hit = false;\n    int hitted_idx = -1;\n\n    for (float step = 0.; (step < max_num_of_steps) && (quit == false) && (hit == false); step += 1.)\n    {\n        // Calculate current coordinates at ray.\n        vec3 marching_point = ray.origin + ray.direction * marched_distance;\n\n        // Find distance to closest object to point.\n        minimal_distance = find_closest_scene_object(marching_point, hitted_idx);\n\n        // March.\n        marched_distance += minimal_distance;\n\n        hit = minimal_distance < surface_distance; // Hit some object?\n        quit = marched_distance > max_distance;    // Marched into infinity?\n    }\n\n    vec3 hp = ray.origin + ray.direction*marched_distance;\n    vec3 hp_normal = approximate_normal(hp);\n\n    return HIT(hp, hp_normal, marched_distance, hit, hitted_idx);  \n}\n\nvec3 blinn_phong(RAY ray, HIT hit)\n{\n    int idx = hit.hitted_idx;\n    vec3 Ka = materials[idx].ambient_Ka; \n    vec3 Kd = materials[idx].diffuse_Kd;\n    vec3 Ks = materials[idx].specular_Ks;\n    float se = materials[idx].spec_exp;\n    \n    vec3 accumulated_color = vec3(0);\n    \n    for (int i = 0; i < NUM_OF_LIGHTS; ++i)\n    {\n        // Calculate directions.\n        vec3 hp_to_l_dir = normalize(lights[i].pos - hit.hit_point); \n        vec3 h = -ray.direction + hp_to_l_dir;\n             h /= length(h);\n\n        /* Blinn-Phong reflection model. */\n        // Calculate diffuse and specular components, and their sum for shadows.\n        float diffuse = max(dot(hit.hp_normal, hp_to_l_dir), 0.), \n              specular = pow(max(dot(hit.hp_normal, h), 0.0), se);\n\n        vec3 ambient_color = Ka * lights[i].ambient_Ia;\n        vec3 total_color =\n            ambient_color +\n            Kd * lights[i].diffuse_Id * diffuse +\n            Ks * lights[i].specular_Is * specular;\n        vec3 result = total_color;\n        /* !Blinn-Phong reflection model. */\n\n        /* On/Off Hard shadows */\n        RAY shadow_ray;\n        shadow_ray.direction = hp_to_l_dir;\n        shadow_ray.origin = hit.hit_point + hp_to_l_dir*0.001;\n        HIT shadow_hit = ray_march(shadow_ray, MAX_NUM_OF_STEPS, MAX_MISS_DIST, MIN_HIT_DIST);\n        result = shadow_hit.hit_something == true ?\n            ambient_color : result;\n        /**/\n        \n        accumulated_color += result;      \n    }\n    \n    return accumulated_color;\n}\n\nRAY perspective_camera(vec2 SC, vec3 pos, vec3 look_at)\n{\n    float zFocalLength = 50.0; // mm.\n    vec3 camera = pos;\n\n    vec3 f = normalize(look_at - camera);                // forward\n    vec3 r = normalize(cross(vec3(0.0, -1.0, 0.0), f)); // right\n    vec3 u = normalize(cross(r, f));                    // up\n        \n    float size = 36.0;        // Sensor Fit: Mode = Auto.    \n    float aspectRatio = iResolution.x / iResolution.y;\n    float vpWidth = size;\n    float vpHeight = vpWidth / aspectRatio;\n           \n    // Before uv=[0;1][0;1]\n    vec2 uv = SC / iResolution.xy;\n    uv.x = (uv.x * vpWidth) - vpWidth * 0.5;\n    uv.y = (uv.y * vpHeight) - vpHeight * 0.5;\n    // After uv=[-vpWidth*0.5; vpWidth*0.5][-vpHeight*0.5; vpHeight*0.5]\n\n    return RAY(\n        camera,\n        normalize(uv.x * r + uv.y * u + f * zFocalLength));\n}\n\nvec3 Reinhard_tone_mapping(vec3 HDR)\n{\n    return HDR / (HDR + vec3(1));\n}\nvec3 exposure_tone_mapping(vec3 HDR, float exposure)\n{\n    return vec3(1.0) - exp(-HDR * exposure);\n}\nvec3 ACES(const vec3 x) \n{\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51; const float b = 0.03; const float c = 2.43;\n    const float d = 0.59; const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvec3 scene(in vec2 SC)\n{\n    init_scene();\n\n    vec2 NDC = map_to_centered_ndc(SC, 1., vec2(0), false),\n         MP =\n             iMouse.xy == vec2(0) ?\n                 vec2(0) :\n                 map_to_centered_ndc(iMouse.xy, 1., vec2(0), false);\n\n    RAY ray = perspective_camera(SC, vec3(0,4,8), vec3(MP, 0));\n         \n    // March through scene.\n    HIT hit = ray_march(ray, MAX_NUM_OF_STEPS, MAX_MISS_DIST, MIN_HIT_DIST);\n    \n    //return Reinhard_tone_mapping(blinn_phong(ray, hit));\n    //return exposure_tone_mapping(blinn_phong(ray, hit), 1.5);\n    return ACES(blinn_phong(ray, hit));\n}\n\nvec3 RSSAA(in vec2 SC)\n{\n    vec3 col = vec3(0);\n    float order = 9., blur = 1.0;\n\n    for (float s = 0.; s < order; s += 1.0)\n    {\n        vec2 jitter = HASH(s, s*order) * 0.5;\n        col += scene(SC + jitter * blur);\n    }\n    \n    return col / order;  \n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{   \n    //O = vec4(scene(SC), 1.); \n    O = vec4(RSSAA(SC), 1.);   \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MAX_MISS_DIST    ( 1e4 )\n#define MIN_HIT_DIST     ( 1e-4 )\n#define MAX_NUM_OF_STEPS ( 300. )\n\n// Data structures.\nstruct RAY\n{\n    vec3 origin;\n    vec3 direction;\n};\nstruct HIT\n{\n    vec3 hit_point;\n    vec3 hp_normal;\n    float hit_dist;\n    bool hit_something;\n    int hitted_idx; // By default if no hit, then hitted_idx == -1.\n};\nstruct LIGHT\n{\n    vec3 pos;\n    vec3 ambient_Ia;\n    vec3 diffuse_Id;\n    vec3 specular_Is;\n};\nstruct MATERIAL\n{\n    vec3 ambient_Ka;\n    vec3 diffuse_Kd;\n    vec3 specular_Ks;\n    float spec_exp;\n};\n/*\n    Matricies for column vectors and row major matricies,\n    because i prefer this variant)\n    \n    Multiplication order:\n    T2 * T1 * T0 * V;\n    \n    Representation for points and directions\n    in homogeneous coordinates:\n        Points     p = vec4(p.xyz, 1),\n        Direction  d = vec4(p.xyz, 0).\n*/\nmat4 scale(vec3 s)\n{\n    mat4 M = mat4(\n        s.x,   0,   0, 0,\n          0, s.y,   0, 0,\n          0,   0, s.z, 0,\n          0,   0,   0, 1);\n    return transpose(M);\n}\nmat4 rotX(float rad)\n{\n    float s = sin(rad), c = cos(rad);\n    mat4 M = mat4(\n         1, 0,  0, 0,\n         0, c, -s, 0,\n         0, s,  c, 0,\n         0, 0,  0, 1);\n    return transpose(M);\n}\nmat4 rotY(float rad)\n{\n    float s = sin(rad), c = cos(rad);\n    mat4 M = mat4(\n         c, 0, s, 0,\n         0, 1, 0, 0,\n        -s, 0, c, 0,\n         0, 0, 0, 1);\n    return transpose(M);\n}\nmat4 rotZ(float rad)\n{\n    float s = sin(rad), c = cos(rad);\n    mat4 M = mat4(\n         c, -s, 0, 0,\n         s,  c, 0, 0,\n         0,  0, 1, 0,\n         0,  0, 0, 1);\n    return transpose(M);\n}\nmat4 translate(vec3 t)\n{\n    mat4 M = mat4(\n        1, 0, 0, t.x,\n        0, 1, 0, t.y,\n        0, 0, 1, t.z,\n        0, 0, 0,   1);\n    return transpose(M);\n}\n/*\n    Transforms for row major matricies and column vectors order:\n        v = T * Rz * Ry * Rx * S * V.\n    1. Scale V; 2. Rotate V around X; 3. Rotate V around Y;\n    4. Rotate V around Z; 5. Translate V. \n*\nvec4 fwd_transform(vec4 p, vec3 s, vec3 r, vec3 t) // point, scale, rotate, translate\n{\n    mat4 fwd = translate(t) * rotZ(r.z) * rotY(r.y) * rotX(r.x) * scale(s);\n    return fwd * p;   \n}\nvec4 bwd_transform(vec4 p, vec3 s, vec3 r, vec3 t) // point, scale, rotate, translate\n{\n    mat4 fwd = translate(t) * rotZ(r.z) * rotY(r.y) * rotX(r.x) * scale(s);\n    return inverse(fwd) * p;\n}\n/**/\nmat4 fwd_srt_transform(vec3 s, vec3 r, vec3 t) // scale, rotate, translate\n{\n    return translate(t) * rotZ(r.z) * rotY(r.y) * rotX(r.x) * scale(s);\n}\nmat4 bwd_srt_transform(vec3 s, vec3 r, vec3 t) // scale, rotate, translate\n{\n    return inverse(translate(t) * rotZ(r.z) * rotY(r.y) * rotX(r.x) * scale(s));\n}\n\n/* \n    Other stuff \n*/\n\n/* \n    Returns random vec2([-1.0; 1.0], [-1.0; 1.0]).\n*/\nvec2 hash2to2(\n    const uint x,\n    const uint y)\n{\n    // Pick some seeds.\n    const uint s0 = 123u;\n    const uint s1 = 456u;\n    const uint s2 = 789u;\n\n    // Mix coordinates.\n    uint v0 = y * s2 + x;\n    uint v1 = x * s2 + y;\n\n    // Calculate hash.\n\tv0 += s1; v0 *= 445593459u; v0 ^= s0;\n    v1 += s1; v1 *= 445593459u; v1 ^= s0;\n    \n    // 2.0f / 4294967295.0f = 4.6566128730773926e-10\n\n    return \n        vec2(\n            float(v0 * v0 * v0) * 4.6566128730773926e-10f - 1.0f,\n            float(v1 * v1 * v1) * 4.6566128730773926e-10f - 1.0f);\n}\n#define HASH(x, y)                ( hash2to2(uint(x), uint(y)) )\n\nfloat diskSDF(in vec2 NDC, in vec2 C, in float r) { return length(C - NDC)-r; }\nfloat vertical_lineSDF(vec2 NDC, float x0) { return abs(NDC.x-x0); }\nfloat segmentSDF(in vec2 NDC, in vec2 B, in vec2 E, in float r)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - r;\n}","name":"Common","description":"","type":"common"}]}