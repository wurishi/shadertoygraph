{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\n    vec3 hex_colors[6] = vec3[6](vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0), vec3(1.0, 1.0, 0.0), vec3(0.0, 1.0, 1.0), vec3(1.0, 0.0, 1.0));\n    // Normalized coordinates (from 0 to 1)\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    // Calculate a bouncing dot.\n    vec2 dotPos = bouncingDot(vec2(0.35663, 0.17164), iTime);\n    dotPos -= vec2(0.5);\n    dotPos *= 1.3; // A bit smaller so it stays inside the hexagon more\n    if(sign(iMouse.z) > 0.01)\n        dotPos = m;\n\n    // Convert coordinates to match the two quadliterals the hex is composed off.\n    // Select between top side and bottom side quadliteral.\n    int startIndex = (dotPos.y > 0.0) ? 0 : 2;\n    // Then calculate bilinear coordinates of that quadliteral.\n    vec2 uv = invBilinear(dotPos, hexVertex(startIndex+2), hexVertex(startIndex+3), hexVertex(startIndex+1), hexVertex(startIndex));\n    \n    // Render everything\n    // Hex in Background\n    vec3 bg_color = vec3(0.8);\n    int bg_quad_index = (p.y > 0.0) ? 0 : 2;\n    vec2 bg_uv = invBilinear(p, hexVertex(bg_quad_index+2), hexVertex(bg_quad_index+3), hexVertex(bg_quad_index+1), hexVertex(bg_quad_index));\n    bg_color = mix(mix(hex_colors[bg_quad_index+2], hex_colors[bg_quad_index+3], bg_uv.x), mix(hex_colors[bg_quad_index], hex_colors[bg_quad_index+1], bg_uv.x), bg_uv.y);\n    if(bg_quad_index!=startIndex)\n    {\n        bg_color *= 0.75;\n    }\n    vec3 c = renderSDF(sdfHexagon(p, vec2(0.0), 0.86, 0.0), 0.03, bg_color, vec3(0.5), vec3(0.0));\n    \n    // Sampled quadliteral\n    c = renderSDF(sdfCircle(p, hexVertex(startIndex),   0.04), 0.02, hex_colors[startIndex], c, vec3(0.0));\n    c = renderSDF(sdfCircle(p, hexVertex(startIndex+1), 0.04), 0.02, hex_colors[startIndex+1], c, vec3(0.0));\n    c = renderSDF(sdfCircle(p, hexVertex(startIndex+2), 0.04), 0.02, hex_colors[startIndex+2], c, vec3(0.0));\n    c = renderSDF(sdfCircle(p, hexVertex(startIndex+3), 0.04), 0.02, hex_colors[startIndex+3], c, vec3(0.0));\n    vec3 firstSample = mix(hex_colors[startIndex+2], hex_colors[startIndex+3], uv.x);\n    vec3 secondSample = mix(hex_colors[startIndex], hex_colors[startIndex+1], uv.x);\n    vec2 a = mix(hexVertex(startIndex+2), hexVertex(startIndex+3), uv.x);\n    vec2 b = mix(hexVertex(startIndex), hexVertex(startIndex+1), uv.x);\n    if(uv.x <= 1.0 && uv.y <= 1.0 && uv.x >= 0.0 && uv.y >= 0.0)\n    {\n        c = mix(c, renderSDF(sdfSegment(p, a, b, 0.02), 0.02, vec3(0.0), c, vec3(0.0)), 0.5);\n        c = renderSDF(sdfCircle(p, a, 0.04), 0.02, firstSample, c, vec3(0.0));\n        c = renderSDF(sdfCircle(p, b, 0.04), 0.02, secondSample, c, vec3(0.0));\n        c = mix(c, renderSDF(sdfSegment(p, mix(hexVertex(startIndex+3), hexVertex(startIndex+1), uv.y), mix(hexVertex(startIndex+2), hexVertex(startIndex), uv.y), 0.005), 0.0, vec3(0.0), c, vec3(0.0)), 0.1);\n    }\n    // Colored dot\n    vec3 dotColor = mix(firstSample, secondSample, uv.y);\n    dotColor = (uv.x>1.0 || uv.y>1.0 || uv.x<0.0 || uv.y<0.0) ? vec3(0.0) : dotColor;\n    c = renderSDF(sdfCircle(p, dotPos, 0.04), 0.02, dotColor, c, vec3(0.0));\n    \n    fragColor.rgb = c * 1.1;\n}\n","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"float sdfHexagon( vec2 p, vec2 pos, float s, float r ) \n{\n    p = p - pos;\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*s, k.z*s), s);\n    return length(p)*sign(p.y) - r;\n}\n\nfloat sdfSegment( in vec2 p, in vec2 a, in vec2 b, float r)\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdfCircle( vec2 p, vec2 pos, float r )\n{\n    p = p - pos;\n    return length(p) - r;\n}\n\nvec3 renderSDF(float sdf, float radius, vec3 background, vec3 foreground, vec3 outline)\n{\n    vec3 clr = (sdf>0.0) ? foreground : background;\n    clr = mix(outline, clr, smoothstep(0.0, radius*0.5, abs(sdf)));\n    return clr;\n}\n\nvec2 bouncingDot(vec2 speed, float time)\n{\n    vec2 pos = mod(speed*time, 2.0);\n    pos = abs(1.0 - abs(pos - 1.0));\n    return pos;\n}\n\nvec2 hexVertex(int N)\n{\n    // 60 degrees\n    int indexMapping[6] = int[6](1, 2, 0, 3, 5, 4);\n    float angle = float(indexMapping[N]) * (2.0 * 3.14159265359 / 6.0);\n    return vec2(cos(angle), sin(angle));\n}\n\n// From iq: https://www.shadertoy.com/view/lsBSDm\nfloat cross2d( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\nvec2 invBilinear( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    vec2 res = vec2(-1.0);\n\n    vec2 e = b-a;\n    vec2 f = d-a;\n    vec2 g = a-b+c-d;\n    vec2 h = p-a;\n        \n    float k2 = cross2d( g, f );\n    float k1 = cross2d( e, f ) + cross2d( h, g );\n    float k0 = cross2d( h, e );\n    \n    // if edges are parallel, this is a linear equation\n    if( abs(k2)<0.001 )\n    {\n        res = vec2( (h.x*k1+f.x*k0)/(e.x*k1-g.x*k0), -k0/k1 );\n    }\n    // otherwise, it's a quadratic\n\telse\n    {\n        float w = k1*k1 - 4.0*k0*k2;\n        if( w<0.0 ) return vec2(-1.0);\n        w = sqrt( w );\n\n        float ik2 = 0.5/k2;\n        float v = (-k1 - w)*ik2;\n        float u = (h.x - f.x*v)/(e.x + g.x*v);\n        \n        if( u<0.0 || u>1.0 || v<0.0 || v>1.0 )\n        {\n           v = (-k1 + w)*ik2;\n           u = (h.x - f.x*v)/(e.x + g.x*v);\n        }\n        res = vec2( u, v );\n    }\n    \n    return res;\n}\n","name":"Common","description":"","type":"common"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lfyfWm","date":"1734099896","viewed":78,"name":"Hexagonal Interpolation","username":"API_Beast","description":"Interpolation between 6 vertices of a hexagon, by splitting the hexagon in two quadliterals along it's primary (pointy) axis.\n\nUse mouse to see for yourself.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["hexagon","interpolation","quadliteral"],"hasliked":0,"parentid":"","parentname":""}}