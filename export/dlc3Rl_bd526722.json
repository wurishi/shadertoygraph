{"ver":"0.1","info":{"id":"dlc3Rl","date":"1682916664","viewed":62,"name":"Fork raymarcher kenneth","username":"kennethshyle","description":"raymarcher","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["raymarcher"],"hasliked":0,"parentid":"mltGDr","parentname":"raymarcher 184"},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Buffer A generates the raymarched image (the bulk of the logic)\n// Buffer B collects the frames to improve the image over time if necessary\n// Common defines configuration for the raymarcher\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Gradient color\n    vec3 col1 = vec3(135.0, 206.0, 250.0) / 255.0;\n    vec3 col2 = vec3(178.0, 255.0, 255.0) / 255.0;\n\n    // Center of the gradient\n    vec2 center = vec2(0.70, 0.45);\n    \n    // Gradiant\n    vec3 grad = mix(col2, col1, length(uv));\n    \n    //vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = texture(iChannel0,uv);\n    \n    vec4 black = vec4(0, 0, 0, 1);\n    if (fragColor == black) {\n        fragColor = vec4(grad,1.0);\n    }\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/* =========\n * Utilities\n * ========= */\n \nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x % (1u << 16u);\n}\n\n// Creates a basis with dir as the z-axis vector.\n// Assumes dir is a normalized vector\nmat3 createbasis(vec3 dir) {\n    vec3 a = vec3(0.13, 0.53, 0.23);\n    a = normalize(a - dot(a, dir) * dir);\n    return mat3(a, normalize(cross(a, dir)), dir);\n}\n\nvec4 samplecosine(in vec3 normal, inout uint random) {\n    mat3 basis = createbasis(normal);\n    \n    random = hash(random);\n    float e1 = float(random) / float(1u << 16u);\n    random = hash(random);\n    float e2 = float(random) / float(1u << 16u);\n    \n    float theta = acos(sqrt(e1));\n    float phi = 2.0 * 3.14159 * e2;\n    vec3 dir = vec3(cos(phi) * sin(theta), sin(phi) * sin(theta), cos(theta));\n    return vec4(\n        basis * dir,\n        cos(theta) / 2.0 / 3.14159\n    );\n}\n\nvec4 samplelight(in vec3 pos, in vec3 box, in vec2 dim, inout uint random) {\n    random = hash(random);\n    float x = dim.x * 2.0 * float(random) / float(1u << 16u) - dim.x;\n    random = hash(random);\n    float y = dim.y * 2.0 * float(random) / float(1u << 16u) - dim.y;\n    vec3 point = vec3(x,0,y) + box;\n    \n    \n    float dist2 = dot(point - pos, point - pos);\n    float cosTheta = dot(normalize(point - pos), vec3(0,1,0));\n    return vec4(normalize(point - pos), 0.25 / dim.x / dim.y / cosTheta);\n}\n\n/* ===============\n * SDF combinators\n * =============== */\n\nfloat min3(float a, float b, float c) {\n    return min(a, min(b, c));\n}\n\nfloat max3(float a, float b, float c) {\n    return max(a, max(b, c));\n}\n\n// min2 differs from the inbuilt min because this function\n// only compares based on the x value of the vector. Probably not the best\n// name the world has ever seen... but it's fine\nvec2 min2(vec2 a, vec2 b) {\n    return a.x > b.x ? b : a;\n}\n\nvec2 min3(vec2 a, vec2 b, vec2 c) {\n    return min2(a, min2(b, c));\n}\n\nvec2 max2(vec2 a, vec2 b) {\n    return a.x > b.x ? a : b;\n}\n\nfloat softmerge(float k, float a, float b){\n    float res = exp(-k*a) + exp(-k*b);\n    return -log(max(0.0001,res)) / k;\n}\n\nfloat softmerge3(float k, float a, float b, float c){\n    float res = exp(-k*a) + exp(-k*b) + exp(-k*c);\n    return -log(max(0.0001,res)) / k;\n}\n\n/* =========\n * SDF \n * ========= */\n\nfloat box(in vec3 pos, vec3 dim) {\n    vec3 d = abs(pos) - dim;\n    return min(max3(d.x,d.y,d.z),0.0) + length(max(d,0.0));\n}\n\nfloat sphere(in vec3 pos, vec3 center) {\n    return length(pos - center);\n}\n\n/* ===================\n * Scene and materials\n * =================== */\n\nvec2 scene1(in vec3 pos) {\n    return min3(\n        vec2(sphere(pos, vec3(0)) - 1.4, 0),\n        vec2(sphere(pos, vec3(1.5)) - 1.0, 1),\n        vec2(box(pos - vec3(-3,0,-1), vec3(2,2,2)), 2)\n    );\n}\n\nvec2 scene2(in vec3 pos) {\n    return vec2(\n        softmerge3(2.0,\n            sphere(pos, vec3(0)) - 1.4,\n            sphere(pos, vec3(1.5)) - 1.0,\n            box(pos - vec3(-3,0,-1), vec3(2,2,2))\n        ),\n        2.0\n    );\n}\n\nvec2 scene3(in vec3 pos) {\n    return min3(\n        vec2(box(pos - vec3(0,4.8,0), vec3(1,0.1,1)), 3),\n        vec2(max(\n            box(pos, vec3(4,5,4)) ,\n            -box(pos - vec3(1,0,0), vec3(4.8,4.8,3.8))\n        ), 0),\n        vec2(sphere(pos, vec3(0)) - 1.5, 2)\n    );\n}\n\nvec2 scene4(in vec3 pos) {\n    return min2(vec2(box(pos, vec3(3,4,3)), 1), vec2(sphere(pos, vec3(0)) - 1.0, 2));\n}\n\n\nvec2 scenemandlebrot(in vec3 pos) {\n    vec3 init = pos / 4.0;\n    vec3 z = init;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n    int iterations = 0;\n    float power = - cos(iTime / 5.0) * 4.0 + 5.5;\n\n\tfor (int i = 0; i < 32 ; i++) {\n        iterations = i;\n\t\tr = length(z);\n\n\t\tif (r > 2.0) {\n            break;\n        }\n        \n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow(r, power-1.0)*power*dr + 1.0;\n\n\t\t// scale and rotate the point\n\t\tfloat zr = pow(r, power);\n\t\ttheta = theta*power;\n\t\tphi = phi*power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz += init;\n\t}\n    \n    float dst = 0.5*log(r)*r/dr;\n\treturn vec2(dst, 0);\n}\n\nfloat S(float lambda) {\n\treturn 3.0*pow(lambda,2.0) - 2.0*pow(lambda,3.0);\n}\n\n// return smoothstep and its derivative\nfloat smoothstepd(float a, float b, float x) {\n    float lambda = min(1.0, max(0.0, (x-a)/(b-a)));\n\treturn S(lambda);\n}\n\n\nfloat calculate_ij(float x, float y) {\n    float u = 50.0 * fract(float(x) / 3.14159265);\n    float v = 50.0 * fract(float(y) / 3.14159265);\n    float a_ij = 2.0* fract(u*v*(u+v)) - 1.0;\n    \n    return a_ij;\n}\n\nfloat calculate_height_one_level(float x, float z) {\n    float x0 = floor(x);\n    float x1 = ceil(x);\n    float z0 = floor(z);\n    float z1 = ceil(z);\n\n    float a_ij = calculate_ij(x0, z0);\n    float c_ij = calculate_ij(x0, z1);\n    float b_ij = calculate_ij(x1, z0);\n    float d_ij = calculate_ij(x1, z1);\n\n    float level_height = a_ij + (b_ij-a_ij)*S(x-x0) + (c_ij-a_ij)*S(z-z0) + (a_ij-b_ij-c_ij+d_ij)*S(x-x0)*S(z-z0);\n    return level_height;\n}\n\nfloat calculate_height(float x, float z, float xz_scale, float h_scale, in vec2 trans, in mat2 rot) {\n    float surface_height = 0.0;\n\n    vec2 xz = vec2(x, z);\n    float scale = xz_scale;\n    \n    xz = (xz + trans)/scale;\n    vec2 rot_xz = xz;\n    \n    for (int power = 0; power <= 10; power +=1) {\n        float level = pow(2.0, float(power));\n        \n        float adj_x = rot_xz.x * level;\n        float adj_z = rot_xz.y * level;\n        \n        float level_height = calculate_height_one_level(adj_x, adj_z);\n        level_height = level_height/level;\n        // for scaling\n        level_height = level_height * h_scale;\n        \n        surface_height += level_height;\n        rot_xz = rot * rot_xz;\n    }\n    return surface_height;\n}\n\nvec3 surfaceNorm(float x, float z, float xz_scale, float h_scale, in vec2 trans, in mat2 rot) // for function f(p)\n{\n    const float eps = 0.0001; // or some other value\n    const vec2 h = vec2(eps,0);\n    \n    float o_height = calculate_height(x,z, xz_scale, h_scale, trans, rot);\n    float deltx = calculate_height(x+eps,z, xz_scale, h_scale, trans, rot);\n    float deltz = calculate_height(x,z+eps, xz_scale, h_scale, trans, rot);\n    \n    float ddx = (deltx - o_height)/eps;\n    float ddz = (deltz - o_height)/eps;\n    \n    vec3 tanx = vec3(1,ddz,0);\n    vec3 tanz = vec3(0,ddx,1);\n    \n    return normalize(cross(tanx, tanz));\n}\n\nvec2 surface(in vec3 pos) {\n    vec2 trans = vec2(20.0, 35.0);\n    float scale = 20.0;\n    float h_scale = 8.0;\n    mat2 rot = mat2(0.8, -0.5,\n                    0.6, 0.8);\n                \n    float surface_height = calculate_height(pos.x, pos.z, scale, h_scale, trans, rot);\n\n    vec3 n = surfaceNorm(pos.x, pos.z, scale, h_scale, trans, rot);\n    float angle = abs(dot(n, vec3(0,1,0)));\n    \n    //return min2(vec2(pos.y - angle, 4), vec2(pos.y - 0.0, 3));\n    \n    if (angle >= 0.9) {\n        return vec2(pos.y - surface_height, 6);\n    }\n    if (angle >= 0.6) {\n        return vec2(pos.y - surface_height, 7);\n    }\n    if (angle >= 0.3) {\n        return vec2(pos.y - surface_height, 8);\n    }\n    return vec2(pos.y - surface_height, 4);\n}\n\nvec2 cloud(in vec3 pos) {\n    vec2 trans = vec2(20.0, 35.0);\n    float scale = 100.0;\n    float h_scale = 20.0;\n    mat2 rot = mat2(0.8, -0.5,\n                    0.6, 0.8);\n                \n    float surface_height = calculate_height(pos.x, pos.z, scale, h_scale, trans, rot);\n\n    vec3 n = surfaceNorm(pos.x, pos.z, scale, h_scale, trans, rot);\n    float angle = abs(dot(n, vec3(0,1,0)));\n    \n    //return min2(vec2(pos.y - angle, 4), vec2(pos.y - 0.0, 3));\n    \n    float dist = (20.0-surface_height) - pos.y;\n    if (angle >= 0.5) {\n        return vec2(dist, 9);\n    }\n    if (angle >= 0.1) {\n        return vec2(dist, 10);\n    }\n    if (angle >= 0.3) {\n        return vec2(dist, 11);\n    }\n    return vec2(dist, 12);\n}\n\nvec2 first2(vec2 a, vec2 b) {\n    if (abs(a.x) < 1.0) {\n        return a;\n    }\n    return b;\n}\n\nvec2 sceneLandscape(in vec3 pos) {\n    vec2 mountains = surface(pos);\n    vec2 sky = cloud(pos);\n    \n    //return min2(sky, mountains);\n    return mountains;\n}\n\nvec2 sceneTorusKnot(in vec3 pos) {\n    vec2 min_vec = vec2(10000.0, 0);\n    \n    for (int i = 0; i < 32 ; i++) {\n        float x = float(i) - 16.0;\n        float y = float(i) - 16.0;\n        float z = 0.0;\n        \n        vec2 curr = vec2(sphere(pos, vec3(x, y, z)) - 1.2, 1);\n        min_vec = min2(min_vec, curr);\n    }\n    //float peturbation = cos(iTime / 4.0) + 5.0;\n    \n    //float displacement = sin(peturbation * pos.x) * sin(peturbation * pos.y) * sin(peturbation * pos.z) * 0.25;\n    //float sphere_0 = sphere(pos, vec3(0.0)) - 2.0;\n    // vec2(sphere(pos, vec3(0)) - 1.4, 0),\n    //float dist = displacement + sphere_0;\n    \n    return min_vec;\n}\n\nvec3 phong_material(int idx) {\n    vec3 mountain_brown = vec3(0.5, 0.375, 0.26171875);\n    vec3 forest_green = vec3(50.0, 100.0, 41.0)/255.0;\n    vec3 sky_blue = vec3(135.0, 206.0, 250.0) / 255.0;\n    vec3 cloud_color = vec3(1,1,1);\n    \n    switch (idx) {\n    case 0: return vec3(0.8,0.3,0.2);\n    case 1: return vec3(0.3,0.9,0.4);\n    case 2: return vec3(0.4,0.3,0.9);\n    case 3: return vec3(1,1,1);\n    //mountain\n    case 4: return mountain_brown;\n    case 5: return vec3(255.0,255.0,255.0) / 255.0;\n    //grass\n    case 6: return forest_green;\n    case 7: return 0.5*forest_green + 0.5* mountain_brown;\n    case 8: return 0.1*forest_green + 0.9* mountain_brown;\n    //sky\n    case 9: return cloud_color;\n    case 10: return 0.5*cloud_color + 0.5* sky_blue;\n    case 11: return 0.1*cloud_color + 0.9* sky_blue;\n    case 12: sky_blue;\n    }\n}\n\nvec4 bsdf_material(int idx) {\n    switch (idx) {\n    case 0: return vec4(0.8,0.3,0.2,0);\n    case 1: return vec4(0.3,0.9,0.4,0);\n    case 2: return vec4(0.4,0.3,0.9,0);\n    case 3: return vec4(0.4,0.3,0.9,20);\n    }\n}\n\n/* =================\n * Raymarching logic\n * ================= */\n\n// Intersection returns what is an effectively a tuple, (t, m) where\n// t is the time when the ray hits some object, m is the approximate\n// value of the index of material that's pre registered.\nvec2 intersect(in vec3 ro, in vec3 rd) {\n    float tmin = 0.1;\n    float tmax = 200.0;\n    \n    for (int i=0; i<200 && tmin <= tmax; i++) {\n        vec3 pos = ro + rd * tmin;\n        vec2 r = SCENE(pos);\n        if (abs(r.x) <= EPS*tmin) {\n            return vec2(tmin,r.y);\n        }\n        tmin = tmin + r.x * 0.24;\n    }\n    \n    return vec2(-1, -1);\n}\n\n\n// This implementation of estnormal uses tetrahedron-based\n// normal estimation as seen here:\n// [https://iquilezles.org/articles/normalsSDF/]\nvec3 estnormal(in vec3 pos) {\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize(\n        e.xyy*SCENE( pos + e.xyy ).x + \n        e.yyx*SCENE( pos + e.yyx ).x + \n\t\te.yxy*SCENE( pos + e.yxy ).x + \n\t\te.xxx*SCENE( pos + e.xxx ).x );\n}\n\nvec3 normal(in vec3 pos, int material, in vec3 rd, inout uint random, in vec3 ro) {\n    vec3 n = estnormal(pos);\n    return abs(n);\n}\n\nvec3 phong(in vec3 pos, int material, in vec3 rd, inout uint random, in vec3 ro) {\n    vec3 m = phong_material(material);\n        \n    vec3 lightpos = vec3(5, 20, 0);\n    float dist2 = dot(lightpos - pos, lightpos - pos);\n    vec3 l = normalize(lightpos - pos);\n    vec3 h = normalize(-rd+l);\n    vec3 n = estnormal(pos);\n\n    vec3 ambient = m * vec3(0.3);\n    vec3 diffuse = m * max(0.0, dot(n, l));\n    vec3 specular = vec3(0.3) * pow(max(0.0, dot(n, h)), 100.0);\n\n    return ambient + diffuse + specular;\n}\n\nvec3 landscape(in vec3 pos, int material, in vec3 rd, inout uint random, in vec3 ro) {\n    vec3 m = phong_material(material);\n        \n    vec3 lightpos = vec3(100, 100, 120);\n    float dist2 = dot(lightpos - pos, lightpos - pos);\n    vec3 l = normalize(lightpos - pos);\n    vec3 h = normalize(-rd+l);\n    vec3 n = estnormal(pos);\n\n    vec3 ambient = m * vec3(0.3);\n    vec3 diffuse = m * max(0.0, dot(n, l));\n    vec3 specular = vec3(0.3) * pow(max(0.0, dot(n, h)), 3000.0);\n    \n    vec3 sky_blur = vec3(184.0, 190.0, 195.0) / 255.0;\n    vec3 original = ambient + diffuse + specular;\n    \n    float cam_dist = dot(ro - pos, ro - pos);\n    float lambda = exp(-0.0001 * cam_dist);\n    \n    vec3 blurred = (lambda*original + sky_blur*(1.0-lambda))/2.0;\n    return blurred;\n}\n\n\nvec3 bsdf1C(in vec3 pos, int material, in vec3 rd, inout uint random, in vec3 ro) {\n    vec4 m = bsdf_material(material);\n    vec3 o = vec3(0);\n    vec3 n = estnormal(pos);\n    \n    for (uint i=0u; i<16u; i++) {\n        random = hash(random + hash(98761u * i));\n        vec4 spl = samplecosine(n, random);\n        vec3 outdir = vec3(spl);\n        if (dot(outdir, n) < 0.0) continue;\n        float pdf = spl.a;\n        vec2 isect = intersect(pos + 5.0 * EPS * outdir, outdir);\n        o += bsdf_material(int(round(isect.y))).a / pdf / isect.x / isect.x / 16.0 * dot(n, outdir);\n    }\n    \n    return vec3(m) * o + m.a;\n}\n\nvec3 bsdf1(in vec3 pos, int material, in vec3 rd, inout uint random, in vec3 ro) {\n    vec4 m = bsdf_material(material);\n    vec3 o = vec3(0);\n    vec3 n = estnormal(pos);\n    \n    for (uint i=0u; i<16u; i++) {\n        random = hash(random + hash(98761u * i));\n        vec4 spl = samplelight(pos, vec3(0,4.80,0), vec2(1,1), random);\n        vec3 outdir = vec3(spl);\n        if (dot(outdir, n) < 0.0) continue;\n        float pdf = spl.a;\n        vec2 isect = intersect(pos + 5.0 * EPS * outdir, outdir);\n        o += bsdf_material(int(round(isect.y))).a / pdf / isect.x / isect.x / 16.0 * dot(n, outdir);\n    }\n    \n    return vec3(m) * o + m.a;\n}\n\nvec3 bsdfn(in vec3 pos, int material, in vec3 rd, inout uint random, in vec3 ro) {\n    // TODO:\n    return vec3(0);\n}\n\nvec3 raycast(in vec3 ro, in vec3 rd, inout uint random) {\n    vec2 intersection = intersect(ro, rd);\n    vec3 pos = ro + rd * intersection.x;\n    \n    int idx = int(round(intersection.y));\n    bool hasintersect = idx != -1;\n    random = hash(random + uint(idx));\n    if (hasintersect) return LIGHTING(pos, idx, rd, random, ro);\n    return vec3(0);\n}\n\nmat3 camera(in vec3 ro, in vec3 ta) {\n\tvec3 up = vec3(0,1,0);\n\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = cross(cu,cw);\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 mo = iMouse.xy/iResolution.xy;\n    // ray origin\n    float camera_radius = 9.0;\n    vec3 ro = vec3(\n        camera_radius*sin(mo.x * 1.6 + 0.55),\n        mo.y * 6.0,\n        camera_radius*cos(mo.x * 1.6 + 0.55)\n    );\n    // looking at\n    vec3 ta = vec3(0,0,0);\n    // camera-to-world transformation matrix\n    mat3 c2w = camera(ro, ta);\n    // ray in camera coordinates, normalized from -1 to 1\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    // ray in world coordinates\n    vec3 rd = c2w * vec3(p, 1);\n    // output to screen\n    uint random = hash(hash(hash(uint(fragCoord.x)) + uint(fragCoord.y)) + uint(iTime * 103.0));\n    fragColor = vec4(raycast(ro, rd, random), 1);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n#ifdef BUFFER\n    fragColor = 1.0 * texture(iChannel0,uv) + 0.0 * texture(iChannel1,uv);\n#else\n    fragColor = 0.98 * texture(iChannel0,uv) + 0.02 * texture(iChannel1,uv);\n#endif\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define EPS 0.01\n\n// One of:\n// - scene1: some primitives\n// - scene2: some primitives that use softmerge\n// - scene3: sphere in a box scene with area light\n// - scenemandlebrot\n#define SCENE sceneLandscape\n\n// One of:\n// - normal: debug shading to check if the normals look right\n// - phong:  phong model of shading\n// - bsdf1C: one-bounce diffuse bsdf with cosine-hemisphere sampling\n// - bsdf1:  one-bounce diffuse bsdf with light-importance sampling\n// - bsdfn:  multi-bounce diffuse bsdf with light-importance sampling\n#define LIGHTING landscape\n\n// Define buffer to be true if you want to collect results\n// over multiple frames.\n#define BUFFER\n","name":"Common","description":"","type":"common"}]}