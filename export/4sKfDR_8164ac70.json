{"ver":"0.1","info":{"id":"4sKfDR","date":"1528332551","viewed":328,"name":"Interactive SDF visualizer","username":"greendolph","description":"Example of unions, intersections, and subtractions on simple signed distance fields","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["sdf","visualization","distance"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * This shader displays a simple scene built using union, intersect, and subtract\n * operations on signed distance fields. \n */\n\nconst int line_dist = 15;\n\n// defines the distance to the surface of a square\n// based on an example from this fantastic article: http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\nfloat sdf_square(vec2 p, vec2 o, float s)\n{\n    vec2 d = abs(p - o) - vec2(s, s);\n    float inside = min(max(d.x, d.y), 0.0);\n    float outside = length(max(d, 0.0));\n    return inside + outside;\n}\n\n// defines the distance to the surface of a circle\n// distance from p to origin minus radius\nfloat sdf_circle(vec2 p, vec2 o, float r)\n{\n    return length(p - o) - r;\n}\n\n// pick the closer of two items\nfloat sdf_union(float a, float b) \n{    \n    return min(a, b);\n}\n\n// pick the further of two items\nfloat sdf_intersect(float a, float b)\n{\n    return max(a, b);\n}\n\n// intersect an item and an inside-out item\nfloat sdf_sub(float a, float b)\n{\n    return max(a, -b);\n}\n\n// percent of screen size\nvec2 svec(float x, float y)\n{\n    return iResolution.xy * vec2(x, y);\n}\n\nfloat psize(float percent)\n{\n    return iResolution.x * percent;\n}\n\nfloat get_world(vec2 p)\n{\n    // small circle in bottom right\n    float a = sdf_circle(p, svec(0.1, 0.1), psize(0.1));\n\n    // medium circle in center top\n    float b = sdf_circle(p, svec(0.5, 0.7), psize(0.2));\n    \n    // small circle at center of b\n    float b2= sdf_circle(p, svec(0.5, 0.7), psize(0.05));\n\n    // square that moves in a circle around b\n    float c = sdf_square(p, svec(0.5 + sin(iTime) / 10.0, 0.7 + cos(iTime) / 10.0), psize(0.15));\n\n    // large circle centered to right of screen\n    float d = sdf_circle(p, svec(1.1, 0.5), psize(0.3));\n\n    // large circle at bottom right of screen\n    float e = sdf_circle(p, svec(1.1, 0.0), psize(0.3));\n\n    return\n        sdf_union(\n            a,\n            sdf_union(                \n                sdf_intersect(\n                    sdf_sub(b, b2), \n                    c\n                ),                                    \n                sdf_sub(d, e)\n            )\n        );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord;\n\n    float world = get_world(fragCoord);\n    \n    // subtract a square at mouse from world\n    world = \n        sdf_sub(\n            world,\n            sdf_square(p, iMouse.xy, 30.0)\n        );\n\n    // normalize distance to fit within canvas\n    float dcolor = pow( world / iResolution.x, 0.3);\n    \n    // pick a cool looking background color\n\tvec4 bg = vec4(dcolor, 0.0, 1.0 - dcolor, 1.0);\n    \n    // if inside an object\n    if (world < 0.0)     \n        fragColor = vec4(0.6, 0.1, 0.1, 1.0); // red!\n    \n    // if on a line of constant distance from the nearest surface (+ animation!)\n    else if (int(world) % line_dist == line_dist - (int(iTime * 20.0) % line_dist) - 1)  \n        fragColor = vec4(bg.x / 1.2, bg.y / 1.2, bg.z / 1.2, 1.0);    \n    \n    // otherwise, draw the cool looking background color\n    else    \n        fragColor = bg;\n}","name":"Image","description":"","type":"image"}]}