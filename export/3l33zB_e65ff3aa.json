{"ver":"0.1","info":{"id":"3l33zB","date":"1576661814","viewed":172,"name":"candy cane rings","username":"cmarangu","description":"I really need to clean up and optimize the code then I wil merge it with a different one\n\nInspired by a gif by @i_am_pi / pi-slices\n[url]https://twitter.com/concinnus/status/1206665313426608128[/url]","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["ice","candycane"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Need to add a billion twinkling stars\n// norther lights check min dist to aurora\n// and snow hills in the distance\n\nconst float FRAMES = 60.;\n\nfloat wnoise (float ix, float iy) {\n    iy = mod(iy, 20.*3./5.);\n    return mod(ix*ix*26.+ix*iy*41.+ix*55.+iy*77., 16.)/15.;\n}\n\nfloat gnoise (float px, float py) {\n    float mx = mod(px, 1.);\n    float my = mod(py, 1.);\n    mx = 3.*mx*mx-2.*mx*mx*mx;\n    my = 3.*my*my-2.*my*my*my;\n    \n    px = floor(px);\n    py = floor(py);\n    return mix(\n        mix(wnoise(px, py), wnoise(px+1., py), mx),\n        mix(wnoise(px, py+1.), wnoise(px+1., py+1.), mx),\n        my\n    );\n}\n\n// i know more\nconst float PI = 3.14159265358979323;\n\n#define arg (mod((float(iTime*5.)/1.), 30.)/30.)\n\nvec3 sund () {\n    // return normalize(\n    //     vec3(\n    //         cos(arg()*PI*2.),\n    //         1.,\n    //         sin(arg()*PI*2.)\n    //     )\n    // );\n    return normalize(\n        vec3(\n            -1.,\n            1.,\n            -1.\n        )\n    );\n}\n// const vec3 sund = normalize(vec3(-3., 0., -1.));\n\nvec3 skyTEX (vec3 d) {\n    vec3 skyTEXd = vec3(0.);\n    \n   \t\n    float azimuth = .5*atan(d.z, d.x);\n    float zenith =  .5*acos(d.y);\n    // skyTEXd += texture(iChannel0, vec2(azimuth, zenith)).rgb;\n    // skyTEXd = vec3(\n    //     pow(skyTEXd.r, 6.),\n    //     pow(skyTEXd.g, 6.),\n    //     pow(skyTEXd.b, 6.)\n    // );\n    \n    skyTEXd += vec3(0., 0., 100./255.)+pow(\n        clamp(dot(d, sund()), 0., 1.),\n        340.\n    );\n    \n    return clamp(skyTEXd, 0., 1.);\n}\n\nfloat objSDF (vec3 p) {\n    p.z = mod(p.z, 20.)-10.;\n    float pyxr = length(p.xy);\n    p.x = pyxr*cos(0.);\n    p.y = pyxr*sin(0.);\n    \n    return length(p-vec3(8., 0., 0.) )-1.;\n}\n\nfloat waterSDF (vec3 p) {\n    return p.y+1.+gnoise(p.x*.3, p.z*3./5.+p.x*.4)*.6;\n}\n\n// float auroraSDF (vec3 p) {\n//     // return max(abs(p.x - sin(p.z*PI*2./20.)*5.)-.5, (20.-p.y) );\n//     return max(mod(500.+p.x+sin(p.z*PI*2.*1./20.), 6.), (30.-p.y) );\n// }\n\nvec3 dobjSDF (vec3 p) {\n    float objSDFp = objSDF(p);\n    return normalize(\n        vec3(\n            objSDF(vec3(p.x+1e-3, p.y, p.z))-objSDFp,\n            objSDF(vec3(p.x, p.y+1e-3, p.z))-objSDFp,\n            objSDF(vec3(p.x, p.y, p.z+1e-3))-objSDFp\n        )\n    );\n}\n\nvec3 dwaterSDF (vec3 p) {\n    float waterSDFp = waterSDF(p);\n    return normalize(\n        vec3(\n            waterSDF(vec3(p.x+1e-3, p.y, p.z))-waterSDFp,\n            waterSDF(vec3(p.x, p.y+1e-3, p.z))-waterSDFp,\n            waterSDF(vec3(p.x, p.y, p.z+1e-3))-waterSDFp\n        )\n    );\n}\n\nvec3 objTEX (vec3 p, vec3 d, vec3 dobjSDFp, float argp) {\n    vec3 TEXp = vec3(1.);\n    float pyx = atan(p.y, p.x)/PI;\n    vec3 q = p;\n    q.z = mod(p.z, 20.)-10.;\n    float qyxr = length(q.xy);\n    q.x = qyxr*cos(0.);\n    q.y = qyxr*sin(0.);\n    q -= vec3(8., 0., 0.);\n    float ang2 = atan(q.z, q.x)/PI;\n    \n    if (mod(10.+pyx*14.+ang2*4.+sin(\n        argp*PI*2. + (floor((p.z+2.)/20.)-argp)*-.7\n    \t)*6., 2.) < 1.) {\n        TEXp = vec3(1., 0., 0.);\n    }\n    float lighting = 1.;\n    //lighting *= clamp(dot(dobjSDFp, sund()), 0., 1.);\n    // lighting = .7+.3*lighting;\n    return TEXp*lighting;\n}\n\nvec3 waterTEX (vec3 p, vec3 d, vec3 dwaterSDFp) {\n    vec3 TEXp = vec3(.4, .8, 1.);\n    // TEXp *= .8+.2*mod(floor(p.x*3.)+floor(p.y*3.), 2.);\n    float lighting = 1.;\n    lighting *= clamp(dot(dwaterSDFp, sund()), 0., 1.);\n    lighting = .5+.5*lighting;\n    return TEXp*lighting;\n}\n\nfloat objSPEX (vec3 p, vec3 d, vec3 dobjSDFp) {\n    return pow(\n        clamp(\n            dot(\n                reflect(\n                    d,\n                    dobjSDFp\n                ),\n            \tsund()\n            ),\n        \t0.,\n        \t1.\n        ),\n        10.\n    );\n}\n\nfloat waterSPEX (vec3 p, vec3 d, vec3 dwaterSDFp) {\n    return 0.*pow(\n        clamp(\n            dot(\n                reflect(\n                    d,\n                    dwaterSDFp\n                ),\n            \tsund()\n            ),\n        \t0.,\n        \t1.\n        ),\n        1.\n    );\n}\n\nvec3 march (vec3 p, vec3 d) {\n    vec3 cam = p;\n    float objSDFp;\n    float waterSDFp;\n    float auroraSDFp;\n    float SDFp;\n    \n    vec3 dobjSDFp;\n    vec3 dwaterSDFp;\n    \n    vec3 TEXp;\n    vec3 finalcol = vec3(0.);\n    float shiny = 1.;\n    float rxcount = 0.;\n    float closestaurora = 1e7;\n    \n    for (int i=0; i<460; ++i) {\n        objSDFp = objSDF(p);\n        waterSDFp = abs(waterSDF(p));\n        // auroraSDFp = auroraSDF(p);\n        SDFp = min(objSDFp, waterSDFp);\n        // SDFp = min(SDFp, auroraSDFp);\n        closestaurora = min(closestaurora, auroraSDFp);\n        if (SDFp < mix(1e-4, 1e-2, min(length(p-cam)/20., 0.) )) {\n            p = p+d*SDFp*.95;\n            // if (auroraSDFp < waterSDFp && auroraSDFp < objSDFp) {\n            //     break;\n            // }\n            // else {\n                if (objSDFp < waterSDFp) {\n                    dobjSDFp = dobjSDF(p);\n                    TEXp = objTEX(p, d, dobjSDFp, arg);\n                    finalcol = finalcol+clamp(TEXp*.4+objSPEX(p, d, dobjSDFp), 0., 1.)*shiny;\n                    shiny *= .6;\n                    d = reflect(d, dobjSDFp);\n                    p = p+d*.2;\n                    ++rxcount;\n                    ++rxcount;\n                    //break;\n                }\n                else {\n                    dwaterSDFp = dwaterSDF(p);\n                    TEXp = waterTEX(p, d, dwaterSDFp);\n                    finalcol = finalcol+clamp(TEXp*.6+waterSPEX(p, d, dwaterSDFp), 0., 1.)*shiny;\n                    shiny *= 1.-.6;\n                    d = reflect(d, dwaterSDFp);\n                    p = p+d*smoothstep(.05, 1., length(p-cam)/50.);\n                    ++rxcount;\n                }\n            // }\n            if (rxcount > 2.) {\n                break;\n            }\n            if (p.y < -10. || p.y > 20.) {\n                break;\n            }\n        }\n        p = p+d*SDFp;\n        if (length(p-cam) > 170.) {\n            break;\n        }\n    }\n    // add the sky color\n    // float am = 1./(1.+closestaurora/3.)*clamp(1.-sqrt(p.y-30.+.1)/6., 0., 1.);\n    // vec3 acol = vec3(0., .8, .9);\n    // if (am > .8) {\n    //     acol = mix(acol, vec3(1.), (am-.8)/.2);\n    // }\n    // am *= .7;\n    // finalcol = finalcol+acol*shiny*am;\n    // shiny *= 1.-am;\n    \n    finalcol = finalcol+shiny*skyTEX(d);\n    \n    return finalcol;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screen = (fragCoord-iResolution.xy/2.)/iResolution.y;\n    vec2 maus =   (iMouse.xy-iResolution.xy/2.)/iResolution.y;\n    if (iMouse.x == 0.) {\n        maus.x = 0.;\n        maus.y = 0.;\n    }\n    vec3 d = normalize(vec3(screen.x, screen.y, 1.));\n    // rotate\n    float dzy = atan(d.z, d.y)+maus.y*PI*.5*3.;\n    float dzyr = sqrt(d.z*d.z+d.y*d.y);\n    d.y = dzyr*cos(dzy);\n    d.z = dzyr*sin(dzy);\n    float dzx = atan(d.z, d.x)+maus.x*PI*2.;\n    float dzxr = sqrt(d.z*d.z+d.x*d.x);\n    d.x = dzxr*cos(dzx);\n    d.z = dzxr*sin(dzx);\n    \n    \n    vec3 retina = march(vec3(0., 2., arg*20.), d);\n    fragColor = vec4(retina, 1.);\n}\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}