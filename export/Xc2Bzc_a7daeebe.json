{"ver":"0.1","info":{"id":"Xc2Bzc","date":"1725288905","viewed":54,"name":"Polytrace Effect ","username":"Akascape","description":"Low-poly triangulate effect inspired from the AE polytrace plugin\n\nsome reference taken from here: https://www.shadertoy.com/view/3dcczM\nNote: This shader has some issues on different platforms; if anyone knows how to fix it, then please comment below :)","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["lowpoly","triangulation","delaunay","polytrace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Creative Commons License\n\nconst float RelativeTileSize = 10.0;\n\n#define Swap(T, a, b) { T temp = a; a = b; b = temp; }\n\nvec4 fetchColor(vec2 position) { \n    vec2 textureResolution = vec2(textureSize(iChannel0, 0));\n    vec2 uv = (position - iResolution.xy * 0.5) * min(textureResolution.x / iResolution.x, textureResolution.y / iResolution.y) / textureResolution.xy + 0.5; \n    return texture(iChannel0, uv); \n}\n\nvec4 fetchModifiedColor(vec2 position) { \n    vec4 color = fetchColor(position); \n    return mix(color, vec4(0.2, 0.5, 0.2, 1.0), dot(color, vec4(-1.0, 2.0, -1.0, 0.0))); \n}\n\nfloat computeValue(vec2 position) { \n    return dot(fetchModifiedColor(position), vec4(0.333)); \n}\n\nvec2 computeGradient(vec2 position, float epsilon) { \n    vec2 delta = vec2(epsilon * 0.5, 0.0); \n    return vec2(computeValue(position + delta.xy) - computeValue(position - delta.xy), computeValue(position + delta.yx) - computeValue(position - delta.yx)) / epsilon; \n}\n\nvec2 generatePoint(int x, int y, float tileSize) {\n    vec4 randomVec = vec4(0.0);\n    vec2 point = vec2(x, y) + vec2(1.0, 0.0) * (float(y % 2) - 0.5) * 0.5 + (randomVec.xy - 0.5) * 0.2;\n    vec2 gradient = computeGradient(point * tileSize, tileSize);\n    vec2 normalizedGradient = (dot(gradient, gradient) < 0.00000001) ? (randomVec.zw - 0.5) * 0.1 : normalize(gradient);\n    float gradientLength = min(0.005 / (length(gradient) + 0.0), 1.0);\n    return (point - normalizedGradient * gradientLength) * tileSize;\n}\n\nbool isInTriangle(vec2 point, vec2 vertex0, vec2 vertex1, vec2 vertex2) {\n    vec2 edge0 = vertex1 - vertex0;\n    vec2 edge1 = vertex2 - vertex0;\n    vec2 edge2 = point - vertex0;\n\n    float dot00 = dot(edge0, edge0);\n    float dot01 = dot(edge0, edge1);\n    float dot02 = dot(edge0, edge2);\n    float dot11 = dot(edge1, edge1);\n    float dot12 = dot(edge1, edge2);\n\n    float invDenominator = 1.0 / (dot00 * dot11 - dot01 * dot01);\n    float u = (dot11 * dot02 - dot01 * dot12) * invDenominator;\n    float v = (dot00 * dot12 - dot01 * dot02) * invDenominator;\n\n    return (u >= 0.0) && (v >= 0.0) && (u + v < 1.0);\n}\n\nconst int MaxPoints = 20;\n\nvec2 intersectLines(vec2 point1, vec2 direction1, vec2 point2, vec2 direction2) {\n    float determinant = direction1.x * direction2.y - direction1.y * direction2.x;\n    vec2 difference = point2 - point1;\n    float t = (difference.x * direction2.y - difference.y * direction2.x) / determinant;\n    return point1 + direction1 * t;\n}\n\nbool OutsideCircumcircle(int index1, int index2, int index3, vec2 points[MaxPoints]) {\n    vec2 center = intersectLines((points[index1] + points[index2]) * 0.5, (points[index2] - points[index1]).yx * vec2(1.0, -1.0),\n                                 (points[index1] + points[index3]) * 0.5, (points[index3] - points[index1]).yx * vec2(1.0, -1.0));\n    float radius = length(points[index1] - center);\n    for (int i = 0; i < MaxPoints; i++) {\n        if (i == index1 || i == index2 || i == index3) continue;\n        if (length(points[i] - center) < radius) return false;\n    }\n    return true;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    float tileSize = RelativeTileSize * sqrt(iResolution.x / 600.0);\n    vec2 position = fragCoord;\n    vec2 gridPosition = floor(position / tileSize + 0.5);\n    float minDistances[MaxPoints]; \n    for (int i = 0; i < MaxPoints; i++) minDistances[i] = 10000.0;\n    vec2 closestPoints[MaxPoints];\n\n    #define NeighborRange 3\n    for (int x = -NeighborRange; x <= NeighborRange; x++) {\n        for (int y = -NeighborRange; y <= NeighborRange; y++) {\n            vec2 point = generatePoint(int(gridPosition.x) + x, int(gridPosition.y) + y, tileSize);\n            float distance = length(position - point);\n            for (int i = 0; i < MaxPoints; i++) { \n                if (distance < minDistances[i]) { \n                    Swap(float, minDistances[i], distance); \n                    Swap(vec2, closestPoints[i], point); \n                } \n            }\n        }\n    }\n\n    int index1, index2, index3;\n    bool triangleFound = false;\n\n    for(int i = 0; i < MaxPoints * MaxPoints * MaxPoints; i++) {\n        index1 = i % MaxPoints;\n        index2 = (i / MaxPoints) % MaxPoints;\n        index3 = (i / MaxPoints / MaxPoints) % MaxPoints;\n\n        if (index1 == index2 || index1 == index3 || index3 == index2) continue;\n        if (isInTriangle(position, closestPoints[index1], closestPoints[index2], closestPoints[index3]) && OutsideCircumcircle(index1, index2, index3, closestPoints)) { \n            triangleFound = true; \n        }\n        if (triangleFound) break;\n    }\n\n    vec2 centroid_point = (closestPoints[index1] + closestPoints[index2] + closestPoints[index3]) / 3.0;\n    vec4 color = fetchColor(centroid_point);\n    fragColor = color; \n}\n","name":"Image","description":"","type":"image"}]}