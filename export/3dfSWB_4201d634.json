{"ver":"0.1","info":{"id":"3dfSWB","date":"1565696019","viewed":276,"name":"Space Station","username":"lz","description":"Space station near a gas planet.","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["space","spacestation","shuttle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define INV_CHAR_DEPTH 0.0625\n#define _CHAR(start, size, uv, ch) pos = clamp(uv, start,  start+size); col += texture(iChannel3, (ch+(pos-start)/size)*INV_CHAR_DEPTH);    \n\n#define _SPACE vec2(0.,13.)\n#define _      vec2(0.,13.)\n#define _dot   vec2(14.,13.)\n#define _MINUS vec2(13., 13.)\n\n#define _0 vec2(0.,12.)\n#define _1 vec2(1.,12.)\n#define _2 vec2(2.,12.)\n#define _3 vec2(3.,12.)\n#define _4 vec2(4.,12.)\n#define _5 vec2(5.,12.)\n#define _6 vec2(6.,12.)\n#define _7 vec2(7.,12.)\n#define _8 vec2(8.,12.)\n#define _9 vec2(9.,12.)\n\nvec4 drawLetter(in vec2 uv, in vec2 start, in float size, vec2 letter)\n{\n    vec4 col;\n    vec2 pos;\n    \n    vec2 inbound = step(start, uv) - step(start + vec2(size), uv);\n    \n    if (inbound.x*inbound.y > 0.5)\n    {\n    \t_CHAR(start, size, uv, letter);\n    \tcol.g = col.b = col.r;\n    \tcol.w = col.r*0.7;\n    }\n    return col;\n}\n\n\nvec2 debugFrame(in vec2 fragCoord, in vec2 mouseCoord, int frameSize)\n{\n  vec2 frame = abs(mouseCoord - fragCoord);\n  ivec2 iframe = ivec2(frame + 0.0001);\n  \n  int sw = frameSize / 2 + 1;\n  \n  if (max(iframe.x, iframe.y) == sw)\n  {\n    return vec2(1., 0.);\n  }\n  else if (max(iframe.x, iframe.y) == sw + 1)\n  {\n    return vec2(1., 1.);\n  }\n  \n  return vec2(0., 0.);\n}\n\nstruct dgbWinParams\n{\n  float frameSize;\n  float gridSize;\n  bool  showValues;\n  bool  axesValues;\n  ivec3 dRGB;\n};\n\nfloat debugWindow(in vec2 mCoord, in vec2 Coord, in vec2 resolution, in sampler2D s, in dgbWinParams params, out vec4 res)\n{\n  vec2 muv = mCoord / resolution;\n  vec2 uv = Coord / resolution;\n  \n  float ratio = resolution.x / resolution.y;\n  \n  muv = 2. * (muv - vec2(0.5));\n  uv = 2. * (uv - vec2(0.5));\n    \n  vec2 center = sign(muv * -1.) * vec2(0.5);\n  vec2 ruv = uv - center;\n  vec2 aruv = abs(ruv);\n  \n  res = vec4(0.);\n  float inside = 0.;\n  float bordWidth = 0.005;\n  \n  if (max(aruv.x, aruv.y) <= params.frameSize)\n  {\n    vec2 frUv = (uv - (center - vec2(params.frameSize)))/(2.*params.frameSize);\n    vec2 grUv = frUv * params.gridSize;\n    vec2 fgrUv = fract(grUv);\n    ivec2 icenter = ivec2(params.gridSize) / 2;\n    ivec2 igrUv = ivec2(grUv) - icenter;\n    float border = 1. - (smoothstep(0., bordWidth * ratio, frUv.y) - smoothstep(1. - bordWidth * ratio, 1., frUv.y)) * \n                        (smoothstep(0., bordWidth, frUv.x) - smoothstep(1. - bordWidth, 1., frUv.x));\n    res.w = border;\n  \n    vec4 td = texture(s, (mCoord + vec2(igrUv))/iResolution.xy);\n    \n    float[3] shiftsY = float[3](0.1, 0.4, 0.7);\n    float[4] shiftsX = float[4](0.1, 0.3, 0.4, 0.5);\n    vec4[3]  letter = vec4[3](vec4(0.), vec4(0.), vec4(0.));\n    float lSize = 0.2;\n    \n    for (int iCh = 0; iCh < 3; iCh++)\n    {\n        if (params.dRGB[iCh] == 0)\n            continue;\n        \n        float v = td[iCh];\n        float ov = v;\n        res[iCh] = v;\n        \n        if (params.showValues == false)\n            continue;\n        \n        float mshift = 0.1;\n\n        letter[iCh] += drawLetter(fgrUv, vec2(0.25 + mshift, shiftsY[iCh]), lSize, _dot);\n        if (v < 0.)\n        {\n          letter[iCh] += drawLetter(fgrUv, vec2(0.05, shiftsY[iCh]), lSize, _MINUS);\n        }\n        v = abs(v);\n        for (int li = 0; li < 4; li++)\n        {\n          float fv = floor(v);\n          letter[iCh] += drawLetter(fgrUv, vec2(0.05 + mshift + shiftsX[li], shiftsY[iCh]), lSize, vec2(fv, 12.));\n          v = 10.* fract(v);\n        }\n    }\n    \n    if (params.axesValues == false && (letter[0].r > 0.5 || letter[1].r > 0.5 || letter[2].r > 0.5))\n    {\n      res.rgb = vec3(1.) * step(dot(res.rgb, vec3(0.299, 0.587, 0.114)), 0.5);\n    }\n    else if (params.axesValues == true && (letter[0].r > 0.5 || letter[1].r > 0.5 || letter[2].r > 0.5))\n    {\n      res.rgb = vec3(letter[0].r * step(td.r, 0.5), letter[1].r * step(td.g, 0.5), letter[2].r * step(td.b, 0.5));\n    }\n \n    inside = 1.;\n  }\n  \n  return inside;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 tuv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 mtuv = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\tvec2 e = vec2(1., 0.)/iResolution.xy;\n    \n    /*int TestTexels = 3;\n    \n    vec2 mf = debugFrame(fragCoord, iMouse.xy, TestTexels);\n    \n    dgbWinParams params;\n    params.frameSize = 0.48;\n    params.gridSize = float(TestTexels);\n    params.dRGB = ivec3(1, 1, 1);\n    params.showValues = true;\n    params.axesValues = false;\n    \n    vec4 dwData;\n    float dwindow = debugWindow(iMouse.xy, fragCoord, iResolution.xy, iChannel0, params, dwData);\n    */\n    vec4 col = texture(iChannel0, uv);\n    \n    vec4 finalCol = col;\n    \n    // color debug\n    /*if (iMouse.z > 0.5 && mf.x > 0.5)\n    {\n      finalCol.r = step(mf.y, 0.5);\n      finalCol.b = step(0.5, mf.y);\n      finalCol.g = 0.;\n    }\n    if (iMouse.z > 0.5 && dwindow > 0.5)\n    {\n      finalCol.rgb = dwData.rgb + vec3(0., dwData.w, dwData.w);\n    }*/\n    \n    fragColor = vec4(finalCol);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n#define PI 3.14159265359\n#define PI2 6.28318530718\n\n#define ROTY(p,al) p.xz = cos(al)*p.xz+ sin(al)*vec2(p.z,-p.x);\n#define ROTX(p,al) p.yz = cos(al)*p.yz+ sin(al)*vec2(p.z,-p.y);\n#define ROTZ(p,al) p.xy = cos(al)*p.xy+ sin(al)*vec2(p.y,-p.x);\n\nfloat hash(in vec2 st) {\nreturn fract(sin(dot(st.xy,\nvec2(12.9898,78.233)))\n* 43758.5453123);\n}\n\nfloat noise2d(vec2 st) {\n  vec2 ist = floor(st);\n  vec2 fst = fract(st);\n\n  vec2 u = 3.*fst*fst - 2.*fst*fst*fst;\n\n  float ll = hash(ist);\n  float lr = hash(ist + vec2(1.,0.));\n  float tl = hash(ist + vec2(0.,1.));\n  float tr = hash(ist + vec2(1.,1.));\n\n  float f = mix(mix(ll,lr,u.x),\n    mix(tl,tr,u.x),u.y);\n\n  return f;\n\n}\n\nfloat noise2d(in vec2 st, in vec2 m) {\nvec2 i = floor(st);\nvec2 f = fract(st);\n\n// Four corners in 2D of a tile\nfloat a = hash(mod(i,m));\nfloat b = hash(mod(i + vec2(1.0, 0.0),m));\nfloat c = hash(mod(i + vec2(0.0, 1.0),m));\nfloat d = hash(mod(i + vec2(1.0, 1.0),m));\n\n// Smooth Interpolation\n\n// Cubic Hermine Curve. Same as SmoothStep()\nvec2 u = f*f*(3.0-2.0*f);\n// u = smoothstep(0.,1.,f);\n\n// Mix 4 coorners porcentages\nreturn mix(a, b, u.x) +\n(c - a)* u.y * (1.0 - u.x) +\n(d - b) * u.x * u.y;\n}\n\nvec2 hash22( in vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat hash12(in vec2 p) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*437.545);\n}\n\nfloat hash12_b(in vec2 p, in int b) {\n    p = mod(p, vec2(b, b));\n    return hash12(p);\n}\n\nfloat gaussWeights[49] = float[49](0.00000067, 0.00002292, 0.00019117, 0.00038771, 0.00019117, 0.00002292, 0.00000067,\n                                   0.00002292, 0.00078633, 0.00655965, 0.01330373, 0.00655965, 0.00078633, 0.00002292,\n                                   0.00019117, 0.00655965, 0.05472157, 0.11098164, 0.05472157, 0.00655965, 0.00019117,\n                                   0.00038771, 0.01330373, 0.11098164, 0.22508352, 0.11098164, 0.01330373, 0.00038771,\n                                   0.00019117, 0.00655965, 0.05472157, 0.11098164, 0.05472157, 0.00655965, 0.00019117,\n                                   0.00002292, 0.00078633, 0.00655965, 0.01330373, 0.00655965, 0.00078633, 0.00002292,\n                                   0.00000067, 0.00002292, 0.00019117, 0.00038771, 0.00019117, 0.00002292, 0.00000067);\n                                   \n\nvec4 gauss33(in vec2 fragCoord, in sampler2D ch)\n{\n   vec4 val;\n   for (int i = 0; i < 7; i++)\n   {\n     for (int j = 0; j < 7; j++)\n     {\n       int si = i - 3;\n       int sj = j - 3;\n       vec4 ngh = texelFetch(ch, ivec2(fragCoord) + ivec2(si, sj), 0);\n       val += ngh * gaussWeights[i * 7 + j];\n     }\n   }\n   \n   return val;\n}\n\n/*\nfloat noised_b( in vec2 p, in float b )\n{\n    p *= b;\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n#if 1\n    // quintic interpolation\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n#else\n    // cubic interpolation\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n#endif    \n    \n    vec2 ga = hash22( mod(i + vec2(0.0,0.0), vec2(b,b)) );\n    vec2 gb = hash22( mod(i + vec2(1.0,0.0), vec2(b,b)) );\n    vec2 gc = hash22( mod(i + vec2(0.0,1.0), vec2(b,b)) );\n    vec2 gd = hash22( mod(i + vec2(1.0,1.0), vec2(b,b)) );\n    \n    float va = dot( ga, f - vec2(0.0,0.0) );\n    float vb = dot( gb, f - vec2(1.0,0.0) );\n    float vc = dot( gc, f - vec2(0.0,1.0) );\n    float vd = dot( gd, f - vec2(1.0,1.0) );\n\n    return va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd);\n}\n\nfloat noisev_b(in vec2 p, in float b) {\n    int ib = int(b);\n    p *= b;\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n    float flb = hash12_b(i + vec2(0.,0.), ib);\n    float flu = hash12_b(i + vec2(0., 1.), ib);\n    float frb = hash12_b(i + vec2(1., 0.), ib);\n    float fru = hash12_b(i + vec2(1., 1.), ib);\n    \n    #if 1\n    // quintic interpolation\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n\t#else\n    // cubic interpolation\n    vec2 u = f*f*(3.0-2.0*f);\n\t#endif  \n    \n    float fv = mix(mix(flb, frb, u.x), mix(flu, fru, u.x), u.y);\n    \n    return fv;\n}\n*/\n\nfloat hash(in vec3 p)\n{\nreturn fract(sin(dot(p,\nvec3(12.6547, 765.3648, 78.653)))*43749.535);\n}\n\nfloat noise3(in vec3 p)\n{\nvec3 pi = floor(p);\nvec3 pf = fract(p);\n\npf = pf*pf*(3.-2.*pf);\n\nfloat a = hash(pi + vec3(0., 0., 0.));\nfloat b = hash(pi + vec3(1., 0., 0.));\nfloat c = hash(pi + vec3(0., 1., 0.));\nfloat d = hash(pi + vec3(1., 1., 0.));\n\nfloat e = hash(pi + vec3(0., 0., 1.));\nfloat f = hash(pi + vec3(1., 0., 1.));\nfloat g = hash(pi + vec3(0., 1., 1.));\nfloat h = hash(pi + vec3(1., 1., 1.));\n\nreturn mix(mix(mix(a,b,pf.x),mix(c,d,pf.x),pf.y),\nmix(mix(e,f,pf.x),mix(g,h,pf.x),pf.y), pf.z);\n}\n\nfloat fbm(vec3 p) {\n\n  float f = 0.;\n  float ampl = 0.5;\n  float freq = 1.;\n  float off = 0.;\n\n  int i = 0;\n  for (i = 0; i < 6; i++) {\n    f += ampl*noise3(p*freq + off);\n    ampl*= 0.5;\n    freq *= 2.;\n    off += 12.274739*ampl;\n  }\n\n  return f;\n}\n\nfloat fbmH(vec3 p) {\n\n  float f = 0.;\n  float ampl = 0.5;\n  float freq = 1.;\n  float off = 0.;\n\n  int i = 0;\n  for (i = 0; i < 8; i++) {\n    f += ampl*noise3(p*freq + off);\n    ampl*= 0.5;\n    freq *= 2.;\n    off += 12.274739*ampl;\n  }\n\n  return f;\n}\n\nfloat fbmLH(vec3 p) {\n\n  float f = 0.;\n  float ampl = 0.5;\n  float freq = 1.;\n  float off = 0.;\n\n  int i = 0;\n  for (i = 0; i < 12; i++) {\n    f += ampl*noise3(p*freq + off);\n    ampl*= 0.66;\n    freq *= 2.;\n    off += 12.274739*ampl;\n  }\n\n  return f;\n}\n\nfloat fbmLHL(vec3 p) {\n\n  float f = 0.;\n  float ampl = 0.5;\n  float freq = 1.;\n  float off = 0.;\n\n  int i = 0;\n  for (i = 0; i < 2; i++) {\n    f += ampl*noise3(p*freq + off);\n    ampl*= 0.66;\n    freq *= 2.;\n    off += 12.274739*ampl;\n  }\n\n  return f;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  //p.xz = cos(time)*p.xz+ sin(time)*vec2(p.z,-p.x);\n   vec3 d = abs(p) - b;\nreturn length(max(d,0.0));\n// + min(max(d.x,max(d.y,d.z)),0.0);\n// remove this line for an only partially signed sdf }\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h ) { vec2 q = vec2( length(p.xz), p.y ); float b = (r1-r2)/h; float a = sqrt(1.0-b*b); float k = dot(q,vec2(-b,a)); if( k < 0.0 ) return length(q) - r1; if( k > a*h ) return length(q-vec2(0.0,h)) - r2; return dot(q, vec2(a,b) ) - r1; }\n\n\nfloat sminC( float a, float b, float k ) { float h = max( k-abs(a-b), 0.0 )/k; return min( a, b ) - h*h*h*k*(1.0/6.0); }\nfloat sdVerticalCapsule( vec3 p, float h, float r ) { p.y -= clamp( p.y, 0.0, h ); return length( p ) - r; }\n\nfloat hex(in vec2 p) {\n   vec3 vhex = vec3(0.5, -0.5773503, 0.866025);\n   \n   float alpha = atan(p.y, p.x) + 0.833333*PI;\n   float len = length(p);\n      \n   float new_alpha = mod(alpha, PI / 3.) + PI / 3.;\n    \n   vec2 ap = len*vec2(cos(new_alpha), sin (new_alpha));\n    \n   float f = ap.y;\n    \n   return length(f);\n}\n\nvec2 hexSquares(in vec2 p, in float dist) {\n   vec3 vhex = vec3(0.5, -0.5773503, 0.866025);\n   \n   float alpha = atan(p.y, p.x) + 0.83333*PI;\n   float len = length(p);\n   \n    \n   float new_alpha = mod(alpha, PI / 3.) + PI/3.;\n    \n   vec2 ap = len*vec2(cos(new_alpha), sin (new_alpha));\n   \n   // this one should be used if new_alpha is adjusted to + PI.\n   mat2 m = mat2(vhex.xy, vec2(vhex.y, -vhex.x));\n   vec2 vp = ap*m;\n   float f = abs(vp.y);\n    \n   f = ap.y;\n   vec2 cp = vec2(ap.x, ap.y-dist);\n   float modv = 0.8;//len/6.;\n   cp.x = mod(abs(cp.x) - 0.5*modv, modv) - 0.5*modv;\n   cp.x = abs(cp.x) - 0.12;\n   \n   return cp;\n}\n\nvec3 noiseNorm(in vec2 uv) {\n  vec2 e = vec2(0.001,0.0);\n\n  vec3 norm;\n\n  norm.x = .1*(noise2d(uv + e.xy) - noise2d(uv - e.xy));\n  norm.y = .1*(noise2d(uv + e.yx) - noise2d(uv - e.yx));\n  norm.z = 2.*e.x;\n\n  return normalize(norm);\n}\n\nvec2 panelNormal(in vec2 st) {\n  float mrg = 0.1;\n   float inv_mrg = 10.;\n  float st1 = step(mrg,st.x);\n  float st2 = step(mrg,1.-st.x);\n  float normx = (1.-st1)*6.*st.x*(1.-st.x*inv_mrg)*inv_mrg;\n  normx -= (1.-st2)*6.*(1.-st.x)*(1.-(1.-st.x)*inv_mrg)*inv_mrg;\n  float normz = clamp(step(0.01,normx)/normx,0.,1.) +\n                step(0.99,1.-normx);\n  return normalize(vec2(normx,normz));\n}\n\nvec3 panelNormal3(in vec2 st) {\n  float mrg = 0.05;\n  float inv_mrg = 20.;\n  float stx1 = step(mrg,st.x);\n  float stx2 = step(mrg,1.-st.x);\n  float normx = (1.-stx1)*6.*st.x*(1.-st.x*inv_mrg)*inv_mrg;\n  normx -= (1.-stx2)*6.*(1.-st.x)*(1.-(1.-st.x)*inv_mrg)*inv_mrg;\n  float sty1 = step(mrg,st.y);\n  float sty2 = step(mrg,1.-st.y);\n  float normy = (1.-sty1)*6.*st.y*(1.-st.y*inv_mrg)*inv_mrg;\n  normy -= (1.-sty2)*6.*(1.-st.y)*(1.-(1.-st.y)*inv_mrg)*inv_mrg;\n  normx *= (step(0.999,abs(sty1*sty2)));\n  normy *= (step(0.999,abs(stx1*stx2)));\n  return normalize(vec3(normx,normy,1.));\n}\n\nvec3 dCirculNorm(in vec2 uv,in vec2 grid) {\n  vec2 center = vec2(0.5,0.5);\n  vec2 fuv = fract(uv*grid);\n  vec2 iuv = floor(uv*grid);\n  float rad = length(fuv - center);\n  float step1 = 10.;\n  float step2 = 10.;\n  float r1 = clamp(6.*(rad-0.1)*(1.-(rad-0.1)*step1)*step1,0.,1.);\n  r1 += clamp(6.*(rad-0.3)*(1.-(rad-0.3)*step2)*step2,0.,1.);\n\n  vec2 r2 = vec2(1.) - (step(1.,iuv)*step(1.,grid-iuv-1.));\n  r2.x = r2.y = float(bool(r2.x)||bool(r2.y));\n  vec3 norm = normalize(vec3(r1*r2,1./(1.+0.01)));\n  //norm = normalize(vec3(rad,rad,1./(rad+0.001)));\n  return norm;\n}\n\n/*float hash12(in vec2 i) {\n    return fract((dot(sin(i), vec2(139243.1251234,7719.119348))));\n}*/\n\nfloat cpattern(in vec2 p) {\n    vec2 grid = vec2(0.2);\n    vec2 ip = floor((p - grid/2.)/grid + 1.);\n    vec2 pp = mod(p - grid/2., grid) - grid / 2.;\n    float rad = length(pp);\n    float iff = hash12(ip);\n    float f = smoothstep(0.96, 0.97, 1.-rad)*step(0.7, iff);\n    return f;\n}\n\nvec3 pattNorm(in vec2 uv) {\n  vec2 e = vec2(0.001,0.0);\n\n  vec3 norm;\n\n  norm.x = .1*(cpattern(uv + e.xy) - cpattern(uv - e.xy));\n  norm.y = .1*(cpattern(uv + e.yx) - cpattern(uv - e.yx));\n  norm.z = 2.*e.x;\n\n  return normalize(norm);\n}\n\nvec3 camera(in vec3 o, in vec3 d, in vec3 tar) {\n  vec3 dir = normalize(o - tar);\n  vec3 right = cross(vec3(0.,1.,0.),dir);\n  vec3 up = cross(dir,right);\n\n  mat3 view = mat3(right,up,dir);\n  return view*d;\n}\n\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\nvec2 boxIntersect( in vec3 ro, in vec3 rd, in vec3 boxSize, out vec3 outNormal ) \n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    outNormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    return vec2( tN, tF );\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n Space Station.\n\n The basic model design was taken from:\n https://www.ctvnews.ca/china-launches-first-module-for-future-space-station-1.704462\n\n Added the Hex (as a living module)\n \n Mostly made from cylinders and boxes. Added bump map to several surfaces (panels in particular).\n\n As always, the helper functions (noise, intersections) are taken from others (mostly iq).\n*/\n\nfloat shuttle(in vec3 p)\n{\nvec3 op = p;\n//p.xz = cos(time)*(p.xz)+ sin(time)*vec2(p.z,-p.x);\nfloat lenxz = length(p.xz);\n\n//cylw\nop = p;\nop.y -= 2.;\nop.x = abs(p.x) - 2.2;\nfloat brad = length(op.zy);\nfloat blen = abs(op.x);\n//float bli = clamp(pow(blen*0.7,8.),0.,brad*0.2);\nfloat fc1 = max(brad - .8,(blen-1.5+brad*0.8));\n\n//cylwf\nop = p;\nop.y -= 2.;\nop.x = abs(p.x) - 5.;\n\nbrad = length(op.zy);\nblen = abs(op.x);\n\nfloat fc2 = max(brad - .4,(blen-2.));\n\n//central sphere\nop = p - vec3(0.,2.,0.);\nfloat fc3 = length(op) - 0.65;\n\n//wingc\nop = p - vec3(0.,2.,0.);\nfloat f1 = max(length(op.yz)-0.25,abs(op.x)-1.4);\nfloat f2 = max(lenxz-0.25,abs(op.y)-1.4);\nfloat fc4 = min(f1,f2);\n\n//rear1\nop = p - vec3(0.,.85,0.);\nfloat fr1 = max(lenxz-0.6,abs(op.y)-0.5+0.5*lenxz*lenxz);\n\n//rear2\nfloat fr2 = sdVerticalCapsule(p+vec3(0.,0.6,0.),0.6,0.45);\n\n//rear3\nop = p + vec3(0.,.9,0.);\nblen = abs(op.y);\nfloat fr3 = max(lenxz - 0.6 -0.1*pow(blen*2.,8.)*step(0.,-op.y),blen - 0.5);\n\n//forward 1\nop = p - vec3(0.,4.2,0.);\nfloat fw1 = max(lenxz-0.6,abs(op.y)-1.8+1.4*lenxz);\n\n//forward 2\nop = p - vec3(0.,5.7,0.);\nfloat fw2 = max(lenxz-0.9,abs(op.y)-.9+0.35*lenxz*lenxz);\n\n//forward 3+\nop = p - vec3(0.,6.7,0.);\nfloat rad = lenxz;\nf2 = max(rad-0.8,abs(op.y)-.4);\nop.y +=0.3;\nfloat f3 = max(rad - 0.7,abs(op.y)-.8);\nop.y -=1.35;\nfloat f4 = max(rad - .7,abs(op.y)-.6 +0.5*rad);\nop.y += 0.7;\nfloat f5 = max(rad - .3,abs(op.y)-.6);\nop.y -= 1.3;\nfloat f6 = max(rad - .5,abs(op.y)-.4);\nfloat fw3 = min(min(min(min(f3,f2),f4),f5),f6);\n\n//solar panel rear\nop = vec3(abs(p.x)-1.9,p.y+.94,p.z);\nfloat fpr = sdBox(op,vec3(1.,0.36,.02));\n\n// solar panel wing center\nop = vec3(abs(p.x)-6.,p.y-2.,abs(p.z) - 2.);\nfloat fpc = sdBox(op,vec3(0.02,0.5,1.4));\n\n//solar panel forward\nop = vec3(abs(p.x)-1.3,p.y-8.5,p.z);\nfloat fpw = sdBox(op,vec3(.7,0.2,.02));\n\n// solar panel c4\nop = vec3(p.x,p.y-4.,abs(p.z)-2.1);\nfloat ft = sdBox(op,vec3(0.02,0.7,1.4));\n\nop = vec3(abs(p.x)-2.1,p.y-4.,p.z);\nfloat fp4 = min(ft,sdBox(op,vec3(1.4,0.7,0.02)));\n\n// rear panel connect\nop = vec3(abs(p.x)-0.68,p.y+.95,p.z);\nfloat lenyz = length(op.yz);\nblen = abs(op.x);\nf1 = max(lenyz-.05,blen-0.1);\nop.x -= 0.17;\nop.y = abs(op.y) - 0.15;\nROTZ(op,PI/3.);\nlenyz = length(op.yz);\nblen = abs(op.x);\nf2 = max(lenyz-0.02,blen-0.1);\nfloat frc = sminC(f1,f2,0.1);\n\n// panel connect\nop = vec3(abs(p.x)-0.65, abs(p.y-4.)-0.3,p.z);\nfloat r1 = length(op)-0.03;\nfloat r2 =  length(vec3(p.x, abs(p.y-4.)-0.3,abs(p.z)-0.65))-0.03;\nfloat frc1 = min(r1,r2);\n\n// wing connect\nop = vec3(abs(p.x)-6.,p.y-2.,p.z);\nROTX(op,PI/8.);\nf1 = max(length(op.xy)-0.02,abs(op.z)-.7);\nROTX(op,-PI/4.);\nf2 = max(length(op.xy)-0.02,abs(op.z)-.7);\nfloat frc2 = min(f1,f2);\n\n// forward panel connect\nop = vec3(abs(p.x)-0.5,p.y-8.5,p.z);\nlenyz = length(op.yz);\nblen = abs(op.x);\nf1 = max(lenyz-.02,blen-0.05);\nop.x -= 0.06;\nop.y = abs(op.y) - 0.06;\nROTZ(op,PI/3.);\nlenyz = length(op.yz);\nblen = abs(op.x);\nf2 = max(lenyz-0.02,blen-0.05);\nfloat frc3 = sminC(f1,f2,0.05);\n    \n// hex\nop = vec3(p.x, p.y - 6.7, p.z);\nROTY(op, iTime*.05);\nfloat hfr = max(lenxz - .8, abs(op.y) - 0.5);\nfloat hff = max(length(op.zy) - .2, abs(op.x) - 3.);\nvec2 qf = vec2(hex(op.xz) - 3., op.y); \nhff = sminC(hff, hfr, 0.1);\nfloat hf = sminC(hex(qf) - .6, hff, 0.1);\n    \nvec2 windHex = hexSquares(op.xz, 3.6);\n    \nvec2 hexwind = vec2(max(abs(windHex.x)-0.01, abs(windHex.y)-0.05),op.y);\nhexwind.y = abs(hexwind.y) - 0.2;\nfloat hfwind = max(abs(hexwind.x)-0.08, abs(hexwind.y)-0.07);\nhf = max(hf, -hfwind);\n\nvec2 topHex = hexSquares(op.xz, 3.2);    \nvec2 hextop = vec2(max(abs(topHex.x)-0.3, abs(topHex.y)-0.3),op.y);\nhextop.y = abs(hextop.y) - 0.4;\nfloat hftop = max(abs(hextop.x)-0.08, abs(hextop.y)-0.07);\nhf = max(hf, -hftop);\n\nfloat of = min(min(min(fc1,fc2),fc3),fc4);\nof = min(min(fr2,min(of,fr1)),fr3);\nof = min(min(min(of,fw1),fw2),fw3);\nof = min(of,min(fpr,min(fpw,min(fp4,fpc))));\nof = sminC(of, hf, 0.1);\n    \nof = sminC(of,frc,0.08);\nof = sminC(of,frc1,0.1);\nof = sminC(of,frc2,0.1);\nof = sminC(of,frc3,0.05);\n//of = mix(-of, df,0.54);\n\nreturn of;\n//p.xz = cos(time)*p.xz+ sin(time)*vec2(p.z,-p.x);\n//p.y -=abs(p.x)*1.5*(2.-p.y);\n}\n\n\n#define T3D_S 64.\n#define T3D_SR 8. // square root of T3D_S\n#define T3D_INV_S 0.015625\n#define T3D_INV_SR 0.125\n\nfloat shuttle(in vec3 p,inout vec3 norm, out vec4 col)\n{\nvec3 op = p;\n//p.xz = cos(time)*(p.xz)+ sin(time)*vec2(p.z,-p.x);\nfloat lenxz = length(p.xz);\n\n//cylw\nop = p;\nop.y -= 2.;\nop.x = abs(p.x) - 2.2;\nfloat brad = length(op.zy);\nfloat blen = abs(op.x);\n//float bli = clamp(pow(blen*0.7,8.),0.,brad*0.2);\nfloat fc1 = max(brad - .8,(blen-1.5+brad*0.8));\n\n//cylwf\nop = p;\nop.y -= 2.;\nop.x = abs(p.x) - 5.;\n\nbrad = length(op.zy);\nblen = abs(op.x);\n\nfloat fc2 = max(brad - .4,(blen-2.));\n\n//central sphere\nop = p - vec3(0.,2.,0.);\nfloat fc3 = length(op) - 0.65;\n\n//wingc\nop = p - vec3(0.,2.,0.);\nfloat f1 = max(length(op.yz)-0.25,abs(op.x)-1.4);\nfloat f2 = max(lenxz-0.25,abs(op.y)-1.4);\nfloat fc4 = min(f1,f2);\n\n//rear1\nop = p - vec3(0.,.85,0.);\nfloat fr1 = max(lenxz-0.6,abs(op.y)-0.5+0.5*lenxz*lenxz);\n\n//rear2\nfloat fr2 = sdVerticalCapsule(p+vec3(0.,0.6,0.),0.6,0.45);\n\n//rear3\nop = p + vec3(0.,.9,0.);\nblen = abs(op.y);\nfloat fr3 = max(lenxz - 0.6 -0.1*pow(blen*2.,8.)*step(0.,-op.y),blen - 0.5);\n\n//forward 1\nop = p - vec3(0.,4.2,0.);\nfloat fw1 = max(lenxz-0.6,abs(op.y)-1.8+1.4*lenxz);\n\n//forward 2\nop = p - vec3(0.,5.7,0.);\nfloat fw2 = max(lenxz-0.9,abs(op.y)-.9+0.35*lenxz*lenxz);\n\n//forward 3+\nop = p - vec3(0.,6.7,0.);\nfloat rad = lenxz;\nf2 = max(rad-0.8,abs(op.y)-.4);\nop.y +=0.3;\nfloat f3 = max(rad - 0.7,abs(op.y)-.8);\nop.y -=1.35;\nfloat f4 = max(rad - .7,abs(op.y)-.6 +0.5*rad);\nop.y += 0.7;\nfloat f5 = max(rad - .3,abs(op.y)-.6);\nop.y -= 1.3;\nfloat f6 = max(rad - .5,abs(op.y)-.4);\nfloat fw3 = min(min(min(min(f3,f2),f4),f5),f6);\n\n//solar panel rear\nop = vec3(abs(p.x)-1.9,p.y+.94,p.z);\nfloat fpr = sdBox(op,vec3(1.,0.36,.02));\n\n// solar panel wing center\nop = vec3(abs(p.x)-6.,p.y-2.,abs(p.z) - 2.);\nfloat fpc = sdBox(op,vec3(0.02,0.5,1.4));\n\n//solarop = vec3(p.x,p.y-4.,abs(p.z)-2.1); panel forward\nop = vec3(abs(p.x)-1.3,p.y-8.5,p.z);\nfloat fpw = sdBox(op,vec3(.7,0.2,.02));\n\n// solar panel c4\nop = vec3(p.x,p.y-4.,abs(p.z)-2.1);\nfloat ft = sdBox(op,vec3(0.02,0.7,1.4));\n\nop = vec3(abs(p.x)-2.1,p.y-4.,p.z);\nfloat fp4 = min(ft,sdBox(op,vec3(1.4,0.7,0.02)));\n\n// rear panel connect\nop = vec3(abs(p.x)-0.68,p.y+.95,p.z);\nfloat lenyz = length(op.yz);\nblen = abs(op.x);\nf1 = max(lenyz-.05,blen-0.1);\nop.x -= 0.17;\nop.y = abs(op.y) - 0.15;\nROTZ(op,PI/3.);\nlenyz = length(op.yz);\nblen = abs(op.x);\nf2 = max(lenyz-0.02,blen-0.1);\nfloat frc = sminC(f1,f2,0.1);\n\n// panel connect\nop = vec3(abs(p.x)-0.65, abs(p.y-4.)-0.3,p.z);\nfloat r1 = length(op)-0.03;\nfloat r2 =  length(vec3(p.x, abs(p.y-4.)-0.3,abs(p.z)-0.65))-0.03;\nfloat frc1 = min(r1,r2);\n\n// wing connect\nop = vec3(abs(p.x)-6.,p.y-2.,p.z);\nROTX(op,PI/8.);\nf1 = max(length(op.xy)-0.02,abs(op.z)-.7);\nROTX(op,-PI/4.);\nf2 = max(length(op.xy)-0.02,abs(op.z)-.7);\nfloat frc2 = min(f1,f2);\n\n// forward panel connect\nop = vec3(abs(p.x)-0.5,p.y-8.5,p.z);\nlenyz = length(op.yz);\nblen = abs(op.x);\nf1 = max(lenyz-.02,blen-0.05);\nop.x -= 0.06;\nop.y = abs(op.y) - 0.06;\nROTZ(op,PI/3.);\nlenyz = length(op.yz);\nblen = abs(op.x);\nf2 = max(lenyz-0.02,blen-0.05);\nfloat frc3 = sminC(f1,f2,0.05);\n\n// hex\nop = vec3(p.x, p.y - 6.7, p.z);\nROTY(op, iTime*.05);\nfloat hfr = max(lenxz - .8, abs(op.y) - 0.5);\nfloat hff = max(length(op.zy) - .2, abs(op.x) - 3.);\nvec2 qf = vec2(hex(op.xz) - 3., op.y); \nhff = sminC(hff, hfr, 0.1);\nfloat hf = sminC(hex(qf) - .6, hff, 0.1);\n    \nvec2 windHex = hexSquares(op.xz, 3.6);\n    \nvec2 hexwind = vec2(max(abs(windHex.x)-0.01, abs(windHex.y)-0.05),op.y);\nhexwind.y = abs(hexwind.y) - 0.2;\nfloat hfwind = max(abs(hexwind.x)-0.08, abs(hexwind.y)-0.07);\nhf = max(hf, -hfwind);\n\nvec2 topHex = hexSquares(op.xz, 3.2);    \nvec2 hextop = vec2(max(abs(topHex.x)-0.3, abs(topHex.y)-0.3),op.y);\nhextop.y = abs(hextop.y) - 0.4;\nfloat hftop = max(abs(hextop.x)-0.08, abs(hextop.y)-0.07);\nhf = max(hf, -hftop);\n\nfloat of = min(min(min(fc1,fc2),fc3),fc4);\nof = min(min(fr2,min(of,fr1)),fr3);\nof = min(min(min(of,fw1),fw2),fw3);\nof = min(of,min(fpr,min(fpw,min(fp4,fpc))));\nof = sminC(of, hf, 0.1);\n    \nof = sminC(of,frc,0.08);\nof = sminC(of,frc1,0.1);\nof = sminC(of,frc2,0.1);\nof = sminC(of,frc3,0.05);\n//of = mix(-of, df,0.54);\n\nif ((of == fpr) && abs(norm.z) > 0.5) {\n   vec2 uof = vec2(abs(p.x)-0.95,p.y+.94)/vec2(2.,0.72);\n   vec2 nuv = panelNormal(fract(uof*5.));\n   norm *= vec3(nuv.x,0.,nuv.y);\n   col = vec4(0.12,0.,0.23, 2.);\n\n} else if ((of == fpw) && abs(norm.z) > 0.5) {\n   vec2 uof = vec2(abs(p.x)-0.65,p.y-8.5)/vec2(1.4,0.4);\n   vec2 nuv = panelNormal(fract(uof*5.));\n   norm *= vec3(nuv.x,0.,nuv.y);\n   col = vec4(0.12,0.,0.23, 0.5);\n} else if (of==fp4 && abs(norm.z) > 0.5) {\n   vec2 uof = vec2(abs(p.x)-2.1,p.y-4.)/vec2(1.4,0.7);\n   norm = panelNormal3(fract(uof*3.))*sign(norm);\n   col = vec4(0.12,0.,0.23, 4.);\n} else if (of==fp4 && abs(norm.x) > 0.5) {\n   vec2 uof = vec2(abs(p.z)-2.1,p.y-4.)/vec2(1.4,0.7);\n   norm.zyx = panelNormal3(fract(uof*3.))*sign(norm.x);\n   col = vec4(0.12,0.,0.23, 4.);\n} else if (of==fpc && abs(norm.x) > 0.5) {\n   vec2 uof = vec2(abs(p.z) - 2.,p.y-2.)/vec2(1.4,0.5);\n   vec2 nuv = panelNormal(fract(uof*5.))*sign(norm.x);\n   norm = vec3(nuv.y,nuv.x,0.);\n   col = vec4(0.12,0.,0.23, 0.5);\n} else if (of == fc2) {\n   vec2 uof = vec2(abs(p.x)-5.,p.y-2.);\n   float ang = 0.5*(atan(p.z,uof.y)/PI)+0.5;\n   float h = clamp((abs(p.x) - 3.)/6.,0.,1.);\n   float fnoise = noise2d(vec2(h, ang)*20., vec2(20.));\n   col = vec4(0.4,0.6,0.8, 4.)*(1.+fnoise*0.1);\n   col.w = 1.;\n} else if (of == fc1) {\n   vec2 uof = vec2(abs(p.x)-2.2,p.y-2.);\n   float ang = 0.5*(atan(p.z,uof.y)/PI)+0.5;\n   float h = clamp((abs(p.x) - 1.4)/1.6,0.,1.);\n   vec2 uv = vec2(ang,h);\n   vec3 v1 = vec3(1.,0.,0.);\n   vec3 v2 = cross(norm,v1);\n   vec2 cuv = vec2(uv.x*16.,uv.y*3.);\n   vec3 nnorm = noiseNorm(uv*100.);\n   vec3 anorm = panelNormal3(fract(cuv));\n   //vec3 cnorm = dCirculNorm(fract(cuv),vec2(4.,6.));\n\n   norm = (mat3(v1,v2,norm)*(anorm+nnorm));\n\n   col = vec4(0.88,0.88,0.91, 1.);\n   //norm = vec3(1.);\n} else if (of == fc4) {\n   col = vec4(0.5,0.52,0.2, 1.);\n} else if (of == fw2) {\n   vec2 uof = vec2(p.x,p.y-5.7);\n   float ang = 0.5*(atan(p.z,p.x)/PI)+0.5;\n   float h = clamp((abs(p.y) - 5.2)/1.,0.,1.);\n   vec2 uv = vec2(ang,h);\n   vec3 v1 = vec3(0.,1.,0.);\n   vec3 v2 = cross(norm,v1);\n   vec2 cuv = vec2(uv.x*16.,uv.y*4.);\n   vec3 anorm = panelNormal3(fract(cuv));\n   vec3 nnorm = noiseNorm(uv.yx*100.);\n   //vec3 cnorm = dCirculNorm(fract(cuv),vec2(4.,6.));\n\n   norm = mat3(v1,v2,norm)*(anorm+nnorm);\n   col = vec4(0.5,0.6,0.87, 0.5);\n} else if (of == fw1) {\n    vec3 uop = p - vec3(0.,4.2,0.);\n    float h = clamp((uop.y+1.5)/3., 0., 1.);\n    float ang = 0.5*(atan(uop.z, uop.x)/PI) + 0.5;\n    vec3 v1 = normalize(vec3(p.x, 0., p.z));\n    vec3 v2 = vec3(0., 1., 0.);\n    vec3 v3 = cross(v1, v2);\n    \n    vec3 anorm = pattNorm(vec2(ang, h));\n    norm = mat3(v3, v2, v1)*anorm;\n    col = vec4(0.5,0.6,0.87, 0.5);\n} else {\n   /*vec3 rp = p + vec3(10.);\n    \n   vec3 cube = mod(rp*T3D_INV_S,1.);\n    \n   vec2 ccoord0 = vec2(floor(cube.z*T3D_SR)*T3D_INV_SR, \n                       floor(T3D_SR*mod(cube.z, T3D_INV_SR))*T3D_INV_SR );\n   \n   vec2 ccoord1 = vec2(floor((cube.z+T3D_INV_S)*T3D_SR)*T3D_INV_SR, \n                       floor(T3D_SR*mod((cube.z+T3D_INV_S), T3D_INV_SR))*T3D_INV_SR );\n    \n   vec3 cl0 = texture(iChannel0, ccoord0 + cube.xy).xyz;\n   vec3 cl1 = texture(iChannel0, ccoord1 + cube.xy).xyz;\n   float interpF = mod(cube.z,T3D_INV_S);*/\n\n   col = vec4(0.5,0.5,0.5, 1.2);\n   \n   col = texture(iChannel0, vec2(0.5) + p.xz*.1);\n   //col = vec4(mix(cl0, cl1, interpF), 1.2);\n}\n\nreturn of;\n//p.xz = cos(time)*p.xz+ sin(time)*vec2(p.z,-p.x);\n//p.y -=abs(p.x)*1.5*(2.-p.y);\n}\n\nconst vec4 planet_center = vec4(-23., -15., -3., 12.);\nfloat planet(in vec3 p)\n{\n    return length(p - planet_center.xyz) - planet_center.w;\n}\n\n/*float planet_b(in vec3 p) {\n    //return rock(p);\n    vec2 tuv = vec2(atan(p.y,p.x)/PI2 + 0.5,\n                    asin(p.z/length(p))/PI + 0.5);\n    // scale the amplitude so that it's smaller at the poles.\n   \tfloat ascale = 0.01 + smoothstep(0., 1.,1.-abs(0.5-tuv.y)*2.);\n    \n    float ampl = planet_center.w/3.;\n    float freq = 2.;\n    float nf = 0.;\n    \n    for (int i = 0; i < 4; i++) {\n        nf += ampl*ascale*clamp(noised_b(tuv, freq),0.,1.);\n        ampl *= 0.5;\n        freq *= 2.;\n        tuv += 0.94;\n    }\n    return 0.8*(length(p - planet_center.xyz) - planet_center.w -nf);\n}\n\nfloat planet_bh(in vec3 p) {\n    //return rock(p);\n    vec2 tuv = vec2(atan(p.y,p.x)/PI2 + 0.5,\n                    asin(p.z/planet_center.w)/PI + 0.5);\n    // scale the amplitude so that it's smaller at the poles.\n   \tfloat ascale = 0.01 + smoothstep(0., 1.,1.-abs(0.5-tuv.y)*2.);\n    \n    float ampl = planet_center.w/3.;\n    float freq = 2.;\n    float nf = 0.;\n    \n    for (int i = 0; i < 16; i++) {\n        nf += ampl*ascale*clamp(noised_b(tuv, freq),0.,1.);\n        ampl *= 0.5;\n        freq *= 2.;\n        tuv += 0.94;\n    }\n    return (length(p - planet_center.xyz) - planet_center.w -nf);\n}*/\n\n\n\n#define FAR 60.\n#define VOL_FOG_STEP .4\n#define VOL_DENSITY 2.\n\nfloat star_p(in vec3 p) {\n  return FAR - 3. - length(p);   \n}\n\nvec2 geom(in vec3 p)\n{\n    vec2[2] t_vec; \n    t_vec[0].x = shuttle(p);\n    t_vec[1].x = planet(p);\n    //t_vec[2].x = star_p(p);\n    \n    vec2 res = vec2(FAR, -1.);\n    \n    for (int i_t = 0; i_t < 2; i_t++)\n    {\n        if (t_vec[i_t].x < res.x)\n        {\n            res.x = t_vec[i_t].x;\n            res.y = float(i_t);\n        }\n    }\n        \n    return res;\n}\n\nvec3 getCentralDiffShuttle(vec3 o, vec3 d, float t)\n{\n    vec3 norm;\n    vec3 e = vec3(0.00001, 0.0, 0.0)*t;\n\n    vec3 p = o + t*d;\n\n    norm.x = shuttle(p + e.xyy) - shuttle(p - e.xyy);\n    norm.y = shuttle(p + e.yxy) - shuttle(p - e.yxy);\n    norm.z = shuttle(p + e.yyx) - shuttle(p - e.yyx);\n\n    norm = normalize(norm);\n    \n    return norm;\n}\n\n/*\nvec3 getCentralDiffPlanet(vec3 o, vec3 d, float t)\n{\n    vec3 norm;\n    vec3 e = vec3(0.0001, 0.0, 0.0)*t;\n\n    vec3 p = o + t*d;\n\n    norm.x = planet_bh(p + e.xyy) - planet_bh(p - e.xyy);\n    norm.y = planet_bh(p + e.yxy) - planet_bh(p - e.yxy);\n    norm.z = planet_bh(p + e.yyx) - planet_bh(p - e.yyx);\n\n    norm = normalize(norm);\n    \n    return norm;\n}*/\n\nvec4 trace(in vec3 o, in vec3 d)\n{\n    float threshold = 0.0001;\n    // vec4(final distance, current distance, nearest distance, geom type);\n    vec4 res = vec4(0., FAR, FAR, 10.);\n    for (int i=0;i<192;i++)\n    {\n       vec3 p = o + res.x*d;\n       \n       res.yw = geom(p);\n       res.z = min(res.z, res.y);\n       res.x += res.y;\n\n       if (res.y < threshold*res.x || res.x > FAR) \n       {\n           threshold *= res.x;\n           break;\n       }\n    }\n    \n    return res;\n}\n\nvec4 vol_trace(in vec3 o, in vec3 d, in vec3 res_t)\n{\n    float vol_steps = 0.;\n    float valpha = 0.;\n    float vol_acc = 0.;\n    vec3 vol_col = vec3(0.);\n    float threshold = 0.0001*res_t.x;\n    \n    float v_dist = step(threshold, res_t.y)*FAR + (1.-step(threshold,res_t.y))*res_t.x;\n    \n    vol_steps = (v_dist / VOL_FOG_STEP)*(exp(-res_t.z*.001));\n    vec3 cp = vec3(0.13, 0.34, .886);\n    float fvsteps = 0.;\n    for (int iv = 0; float(iv) < vol_steps; iv++)\n    {\n        vec3 vp = o + (float(iv)*VOL_FOG_STEP)*d - threshold;\n        \n        float density = VOL_DENSITY*exp(0.3*\n             (planet_center.w - length(vp-planet_center.xyz)));\n             \n        float ns = (1. + 0.5 * (hash(vp)));\n        valpha = ns * fbm(vp)*density*VOL_FOG_STEP;\n        vol_col = valpha*cp + (1.-valpha)*(vol_acc);\n        vol_acc = valpha + (1. - valpha)*(vol_acc);\n        \n        fvsteps += 1.0;\n        if (vol_acc > 0.98)\n        {\n            break;\n        }\n    }\n    \n    float dsteps = dFdx(fvsteps);\n    \n    return vec4(vec3(vol_col), vol_acc);\n}\n\nvoid cameraSetup(inout vec3 o, inout vec3 d)\n{\n    o.y = 20.*sin(iTime*0.2);\n    float r = 2. + min(0., 0.5*o.y);\n    o = vec3(6.*sin(iTime),o.y, 6.*cos(iTime));\n    vec3 target = vec3(0., 10.*sin(iTime*0.065), 0.);\n    target = mix(target, vec3(planet_center.x, 0., 0.), pow(cos(0.25*iTime)*0.5+0.5, 8.));\n    d = camera(o, d, target);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    if (iResolution.y > iResolution.x)\n       uv.y *= iResolution.y/iResolution.x;\n    else\n       uv.x *= iResolution.x/iResolution.y;\n\n    vec3 o = vec3(sin(iTime),5.,10.);\n    vec3 d = normalize(vec3(-1. +2.*(uv-vec2(0.,0.)),-1.));\n    \n    vec3 col;\n    \n    \n    float threshold = 0.0001;\n    vec4 res_t;\n    vec4 vol_col;\n    \n    cameraSetup(o, d);\n\n    res_t = trace(o, d);\n    threshold *= res_t.x;\n    \n\t// volumetric step\n    vol_col = vol_trace(o, d, res_t.xyz);\n    \n\n    if (res_t.y < threshold && res_t.w < 0.5)\n    {\n       vec3 specCol;\n       vec3 p = o + res_t.x*d;\n       vec4 bc;\n        \n       vec3 norm = getCentralDiffShuttle(o, d, res_t.x);\n\t   shuttle(p,norm,bc);\n      \n      col += 0.7*bc.xyz*(dot(-norm,d));\n      specCol = 0.3*bc.w*vec3(256.*exp(-res_t.x))*\n          clamp(pow(max(0., dot(reflect(d, norm), -d)),4.*bc.w), 0., 1.);\n      \n      col = clamp(col + specCol, 0., 1.);\n    } else if (res_t.y < threshold && res_t.w < 1.5)\n    {\n        vec3 p = o + res_t.x*d;\n        vec3 norm = normalize(p - planet_center.xyz);\n        col += vec3(0.83, 0.34, 0.16)*(dot(-norm,d));;\n    } else\n    {\n        vec2 st = sphIntersect(o, d, vec3(0.), 70.);\n        vec3 boxNorm;\n        vec2 st_b = boxIntersect(o, d, vec3(100.), boxNorm);\n        vec2 st_b2 = boxIntersect(o, d, vec3(200.), boxNorm);\n  \t\t\n        vec3 p_sph = o + min(st.x, st.y)*d;\n        \n        float thr = fbm(p_sph*0.035);\n        col = 0.7*vec3(0.,thr*0.95, thr);\n        \n        vec3 p_box = o +st_b.y*d;\n        float shr = fbmLH(p_box*0.04);\n\t\tshr = pow(shr - 0.2, 8.);\n        \n        vec3 p_box2 = o +st_b2.y*d;\n        float shr2 = fbmLHL(p_box2*0.2);\n\t\tshr += pow(shr2 + 0.2, 64.);\n        \n        col = col + vec3(shr, 0.8*shr, shr);\n        col = clamp(col, 0., 1.);\n    }\n\n\n    col = mix(col, vol_col.xyz, vol_col.w);\n\n    fragColor = vec4(pow(col, vec3(2.2)), 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 fct = 1. / iResolution.xy;\n    vec2 uv = fragCoord * fct;\n    vec4 col = gauss33(fragCoord, iChannel0);\n    fragColor = vec4(col);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 fct = 1. / iResolution.xy;\n    vec2 uv = fragCoord * fct;\n    vec4 col = gauss33(fragCoord, iChannel0);\n    fragColor = vec4(col);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 fct = 1. / iResolution.xy;\n    vec2 uv = fragCoord * fct;\n    //vec4 gcol = gauss33(fragCoord, iChannel1);\n    vec4 col = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec4 pcol = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    float t = mod(iTime, 20.);\n    float at = 0.5;/* + 0.5 * ( smoothstep(0., 10., t) - smoothstep(10., 20., t) );*/\n    float pt = mod(iTime, 15.);\n    float pulse = smoothstep(3., 6., at * pt) - smoothstep(6., 9., at * pt);\n    col = vec4(mix(col, pcol, pulse));\n    fragColor = col;\n}","name":"Buffer D","description":"","type":"buffer"}]}