{"ver":"0.1","info":{"id":"wltXR8","date":"1580418109","viewed":359,"name":"Day 42 - Part 2","username":"jeyko","description":"code messy yo","likes":5,"published":3,"flags":32,"usePreview":0,"tags":["mdtmjvm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Day 42 - Magma\" by jeyko. https://shadertoy.com/view/WltXR8\n// 2020-01-30 18:18:08\n\n//Code is messy!\n// Kinda looked better with no post hmm\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    vec4 tA = texture(iChannel0, fragCoord/iResolution.xy);\n    vec4 tB = texture(iChannel0, fragCoord/iResolution.xy, 6.);\n             \n    //tB = pow(tB*1., vec4(4.));\n    tB = smoothstep(0.,2.,tB);\n    fragColor = tA +tB*2.6;\n    fragColor *= 1.2;\n    fragColor = smoothstep(0.,1.,fragColor);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec2 r22(vec2 x){return vec2(\n\tfract(sin(x.y*213.124)*214.),\n\tfract(sin(x.x*513.524)*614.5)\n);}\nfloat voronoi (vec2 uv){\n    vec2 fuv = fract(uv) - 0.5;\n    vec2 uvid = floor(uv);\n    \n    vec2 me = r22(uvid);\n    vec2 u = r22(uvid + vec2(0,1)) + vec2(0,1);\n    vec2 d = r22(uvid - vec2(0,1)) - vec2(0,1);\n    vec2 l = r22(uvid - vec2(1,0)) - vec2(1,0);\n    vec2 r = r22(uvid + vec2(1,0)) + vec2(1,0);\n    \n    vec2 ul = r22(uvid + vec2(1,-1))+ vec2(1,-1);\n    vec2 ur = r22(uvid + vec2(1,1))+ vec2(1,1);\n    vec2 dl = r22(uvid + vec2(-1,-1))+ vec2(-1,-1);\n    vec2 dr = r22(uvid + vec2(-1,1)) + vec2(-1,1);\n    \n    vec3 col = vec3(0);\n\n    \n    float Di = distance(me,fuv);\n    float Du = distance(u,fuv);\n    float Dd = distance(d,fuv);\n    float Dl = distance(l,fuv);\n    float Dr = distance(r,fuv);\n    \n    float Dul = distance(ul,fuv);\n    float Dur = distance(ur,fuv);\n    float Ddl = distance(dl,fuv);\n    float Ddr = distance(dr,fuv);\n    \n    \n    float ddd = min(Di, Du);\n    ddd = min(ddd, Dd);\n    ddd = min(ddd, Dl);\n    ddd = min(ddd, Dr);\n    \n    ddd = min(ddd, Dul);\n    ddd = min(ddd, Dur);\n    ddd = min(ddd, Ddl);\n    ddd = min(ddd, Ddr);\n    \n    float c =  ddd;\n    \n    return  c;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvec3 glow = vec3(0);\n#define fov 0.9\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n\tvec3 dir = normalize(lookAt -ro);\n    vec3 right = normalize(cross(vec3(0,1,0), dir));\n    vec3 up = normalize(cross(dir, right));\n\treturn normalize(dir + right*uv.x*fov + up*uv.y*fov);\n    //return (dir + right*uv.x*fov + up*uv.y*fov);\n}\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n#define pi acos(-1.)\n#define tau (2.*pi)\n\n#define mx (iTime*0.5 + 10.*iMouse.x/iResolution.y)\n\nfloat w = 0.;\n\n#define ITERS 4\n#define pmod(p, x) mod(p,x) - 0.5*x\nfloat[] WS = float[ITERS](1.,1.,1.,1.);\n\nfloat id;\nvec2 map(vec3 q){\n\tvec2 d = vec2(10e5);\n    #define repD 3.7\n    \n    id = floor(q.z/repD);\n\tq.z = pmod(q.z, repD);\n    q.xy -= 2.;\n\tq.xy = pmod(q.xy, 4.);\n    #define ZOOM 4.\n    //d.x = min(d.x, length(p) - 0.);\n    \n    vec4 p = vec4(q.xyz, 1.);\n    vec4 c = vec4(0.5,1.,0.4,0.);\n    vec4 u = vec4(0.4,0.44,0.7,0.4);\n    \n    \n    for(int i = 0; i < ITERS; i++){\n        p.xyz = abs(p.xyz) - vec3(0.78,0.9,0.4 + sin(id)*0.0);\n        float dpp = dot(p.xyz,p.xyz);\n        p=p*(1.5 + u)/clamp(dpp,.4,1.)-c;\n\t\t\n        p.xy *= rot(-0.8 + sin(id)*0.7);\n        if(i < 2)\n        \tp.z -= 0.5;\n        WS[i] = p.w;\n    }\n    w = p.z;\n    p.xyz = abs(p.xyz);\n    \n    p.xz *= rot(0.2);\n    float fr =  max(p.x - 0., max(p.y - 2.4 + sin(id)*0.7, p.z - 2.9))/p.w;\n    d.x = min(d.x, fr );\n\n    d.x *= 0.5;\n\treturn d;\n}\n\nvec2 march(vec3 ro, vec3 rd,inout vec3 p,inout float t,inout bool hit){\n\t\n    vec2 d = vec2(10e5);\n    hit = false;\n    t = 0.;\n    p = ro;\n    for(int i = 0; i < 180 ; i++){\n    \td = map(p);\n        \n        glow += exp(-d.x*20.);\n        \n        if(d.x < 0.001){\n            hit = true;\n        \tbreak;\n        }\n    \tt += d.x;\n        p = ro + rd*t;\n    }\n    return d;\n}\n\nvec3 getNormal(vec3 p){\n\tvec2 t = vec2(0.001, 0);\n\treturn normalize(map(p).x - vec3(\n    \tmap(p-t.xyy).x,\n    \tmap(p-t.yxy).x,\n    \tmap(p-t.yyx).x\n    ));\n}\n#define pal(a,b,c,d,e) (a + b*sin(c*d + e))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    \n    vec3 col = vec3(0);\n    /*\n    vec3 ro = vec3(0,1,0);\n\n    ro.x += sin(iTime)*ZOOM;\n    ro.z += cos(iTime)*ZOOM;\n    */\n    uv.xy *= rot(iTime*0.1);\n    vec3 ro = vec3(0);\n    ro.z += mx;\n    bool hit;\n    vec3 lookAt = vec3(0.001);\n    lookAt.z = ro.z + 2.;\n    //lookAt.y -= 0.7;\n    uv *= 1. + dot(uv,uv)*0.9;\n    vec3 rd = getRd(ro, lookAt, uv);\n    vec3 p; float t;\n    vec2 d = march( ro, rd,p,t, hit);\n\n    vec3 CA, CB, CC, CD;\n    if (hit){\n        vec3 lD = normalize(vec3(1));\n        vec3 h = normalize(lD - rd);\n        vec3 n = getNormal(p);\n        float diff = max(dot(n,lD),0.);\n        float spec = pow(max(dot(n,h),0.), 50.);\n        float fres = pow(1. - max(dot(n,-rd),0.), 5.);\n        //diff = w*0.1;\n        CA = vec3(0.2,0.0,0.2)*(pow(1. - WS[0]*(0.15 + sin(id*1.5)*0.1), 7.));\n         CB = vec3(1.,1,0.4 + sin(iTime)*0.2)*pow(WS[1]*0.05, 4.);\n         CC = vec3(0.,0.4,0.2)*pow(WS[2]*0.02, 2.);\n         CD = vec3(0.9,0.4,0.2 + 0.2*abs(sin(id*0.1 - 0.2)))*pow(WS[3]*0.01, 2.);\n        \n        vec3 C =  CD + CC - CB + CA*0.5;\n    \tcol += mix(C, spec*vec3(1.0,.7,.1)*1., 0.3);\n        col += diff*0.1;\n        \n    }\n    vec3 g = glow*pal(0.2,0.5,vec3(2.9,5.4,0.7),0.5,4.7  - t*0.1 );\n    \n    //col = mix(col, vec3(0.8,1,1)*0.2,smoothstep(0.,1.,t*0.08 ));\n    //col *= 2.0;\n    col *= 1.8;\n    col = smoothstep(0.,1.,col);\n    //col = smoothstep(0.,0.4,col);\n\n    col = clamp(col*1., 0., 1.);\n    //col *= 1.;\n    col = pow(col, vec3(0.45));\n    col = mix(col, vec3(0.9,1,0.8)*0.2,smoothstep(0.,1.,t*0.08 ));\n    \n    \n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}