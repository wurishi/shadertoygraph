{"ver":"0.1","info":{"id":"XtKXR3","date":"1485513802","viewed":873,"name":"WindyPlains VR","username":"Tempally","description":"Tried to choose (or make) good-enough-for-VR shader of grass. Based on work WindyPlains by kuvkar\n (https://www.shadertoy.com/view/ltXXRM), but heavily modified and optimized.","likes":12,"published":1,"flags":1,"usePreview":1,"tags":["procedural","3d","grass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Tried to choose (or make) good-enough-for-VR shader of grass.\n// Most impressive (IMHO) grass was in \"Windyplains\" by kuvkar\n// (https://www.shadertoy.com/view/ltXXRM), but his shader is too heavy!\n// This shader is based on that work, but was heavily optimized and modified.\n// (completely replaced clouds (based on 2DClouds by Drift), \n//  no need any passage through the field,\n//  need a really big field, have added elliptic waves on the grass,\n//  ground should not be black, etc.)\n// Now it can perform >90 FPS in VR at 3240x1800 on GTX1070\n// Tempally, 2017\n\nconst vec4 darkGrass = vec4(.45, 0.35, 0.1, 0.0);\nconst vec4 brightGrass = vec4(1.5, 1.3, 0., 0.0);\n// btw, AA was really fast here! I have turn it off\n// because aliased image looks better in VR (surprisingly):\n// #define AA_ENABLED\n\n// sky consts:\nconst float cloudscale = .1;\nconst float speed = 0.01;\nconst float clouddark = 0.5;\nconst float cloudlight = 0.3;\nconst vec3 skyColor = vec3(0.2, 0.4, 0.6);\nconst int count = 7;\nconst mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\nvec2 hash( vec2 p ) {\n\tp = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n\treturn fract(sin(p)*43758.5453123) - .5;\n    // another ver. (see the comment in 'noise' func):\n    //p  = fract(p * vec2(0.3247122237916646, 0.134707348285849));\n    //p += dot(p.xy, p.yx+19.19);\n    //return fract(p)-.5;\n    \n}\n\nfloat skyNoise( in vec2 p ) {\n    const float K1 = 0.366025404; \n    const float K2 = 0.211324865; \n    vec2 i = floor(p + (p.x+p.y)*K1);\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n    vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3 n = 2.*h*h*h*h*vec3( dot(a,hash(i)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot(n, vec3(70.));\t\n}\n\nfloat fbm(vec2 n) {\n\tfloat total = 0.0, amplitude = 0.1;\n\tfor (int i = 0; i < count; i++) {\n\t\ttotal += skyNoise(n) * amplitude;\n\t\tn *= m;\n\t\tamplitude *= 0.4;\n\t}\n\treturn total;\n}\n\n\nfloat noise( in vec2 p )\n{\n    return fract((sin(p.x)+cos(p.y))*43758.5453123);\n    // my tests showed that another ver. has a tiny speed difference:\n    // - a little bit faster on Intel chips,\n    // - but a little bit slower on Nvidia:\n    //  p  = fract(p * vec2(0.3247122237916646, 0.134707348285849));\n    //  p += dot(p.xy, p.yx+19.19);\n    //  return fract(p.x * p.y);\n}\n\n\n// Height of grass\nconst float H = 0.3;\n\nfloat fltr(float f, float a)\n{\n    f = clamp(f - a, 0.0, 1.0);\n    return f / (1.0 - a);\n}\n\nvec4 sky(in vec3 rp, in vec3 rd)\n{\n\n    rp += 4. * rd / rd.y;\n    vec2 uvbase = rp.xz;\n    float q = fbm(uvbase * cloudscale);\n    float time = iTime * speed;\n    vec3 skycolour = skyColor;//= mix(skycolour2, skycolour1, uvbase.y);\n    uvbase = uvbase * cloudscale + time;\n\n    vec2 uv = uvbase - q;\n    float r = 0., f = 0., wr = .8, wf = .7; //skyNoise shape\n    for (int i=0; i<=count; i++) {\n\t\tr += abs(wr*skyNoise( uv ));\n\t\tf += wf*skyNoise( uv );\n        uv = m*uv + time;\n\t\twr *= .7;\n\t\twf *= .6;\n    }\n    f *= r + f;\n    f = .2 + 8.*f*r;\n\n    float c = 0., weight = .4; //skyNoise colour\n    uv = uvbase * 2. - q;\n    vec2 uv1 = uvbase * 3. - q;\n    for (int i=0; i<count; i++) {\n\t\tc += weight*(skyNoise( uv ) + abs(skyNoise( uv1 )));\n        uv = m*uv + time + time;\n        uv1 = m*uv1 + time*3.;\n\t\tweight *= .6;\n    }\n\n    vec3 cloudcolour = vec3(1.1, 1.1, 0.9) * clamp((clouddark + cloudlight*c), 0.0, 1.0);\n    vec3 result = mix(skycolour, clamp(.5 * skycolour + cloudcolour, 0.0, 1.0), clamp(f + c, 0.0, 1.0));\n\n\n    result *= smoothstep(0.0, 0.2, rd.y);\n    return vec4( result, 1.0 );\n}\n\n//------------------------------------------------------------\n\nstruct AA\n{\n    float a;\n    float b;\n    float c;\n    float d;\n    float e;\n    float f;\n    float g;\n    float h;\n};\n\n\nvoid rotate(inout AA aa, float v)\n{\n    aa.h = aa.g;\n    aa.g = aa.f;\n    aa.f = aa.e;\n    aa.e = aa.d;\n    aa.d = aa.c;\n    aa.c = aa.b;\n    aa.b = aa.a;\n    aa.a = v;\n}\n\nfloat avg(in AA aa)\n{\n    float a3 = mix(aa.a + aa.b, aa.c + aa.d, .3);\n    float a5 = mix(aa.e + aa.f, aa.g + aa.h, .5);\n    return  mix(a3, a5, .02) * 0.5;\n}\n\nvec2 rot2d(in vec3 p, float angle)\n{\n\tfloat x = p.x * cos(angle) + p.y * -sin(angle);\n\tfloat y = p.x * sin(angle) + p.y * cos(angle);\n    return vec2(x, y);\n}\n\n\nvec3 warpedRp = vec3(0.0);\n\nfloat map(in vec3 rp, inout AA aa)\n{\n\tfloat mt = iTime * 0.9;\n    float t = sin(mt + rp.x * 1.2);\n    t += sin(mt + rp.z * 1.4);\n\n    vec2 off = rot2d(vec3(0.0, 5.0, 0.0), rp.y * 5.* t);\n    rp.x -= off.x * 0.04;\n    rp.y -= off.y * 0.005;\n\n    float h =\n        //texture(iChannel0, uv -100.0).r;\n        noise(floor(rp.xz*516.));\n\n#ifdef AA_ENABLED\n        rotate(aa, h);\n        h = avg(aa);\n#endif\n\n    h *=\n        //mix(texture(iChannel0, uv * 0.025).r + 0., 1.0, 0.7);\n        mix(noise(floor(rp.xz*123.)), 1.0, 0.6)*H;\n    warpedRp = rp;\n    return rp.y - h;\n}\n\n\nfloat shadow(in vec3 rp)\n{\n\tfloat d = 0.05;\n\tAA aa;\n    float h = map(rp + vec3(0., 0., 1.) * d, aa);\n    return clamp(h / d, 0.0, 1.0);\n}\n\n\nbool trace(inout vec3 rp, in vec3 rd, inout vec4 col)\n{\n    if(rd.y >= 0.) return false; // there is no grass in the sky\n\n    vec3 ro = rp; // our camera\n    float ydiff = rp.y - H; // distance to the top of the grass\n    float l = 0.;\n    rp -= rd * (ydiff / rd.y);// minus because rd.y <0\n    AA aa;\n    for (int i = 0; i < 220; ++i)\n    {\n        float h = map(rp, aa);\n    \t\n        if(h <= 0. || rp.y < 0.)\n        {\n            //vec4 tx = texture(iChannel2, warpedRp.xz * 0.5);\n\n        \t// straw color variance\n            float strw = noise(floor(warpedRp.xz*31.))-.3;\n            vec4 strawcol = mix(brightGrass, darkGrass, strw);\n\n            // it was coloring part but now it makes waves on the grass\n            vec4 c2 = texture(iChannel2, warpedRp.xz * 0.0625);\n            col = mix(c2, strawcol, 0.8);\n\n            col = mix(vec4(0.0), col, smoothstep(H * 0.2,  H * 1.4, rp.y));\n\n            col *= mix(shadow(rp), 1.0, 0.7);\n            return true;\n        }\n\n        //if ( distance(rp,ro)>7.) return false;\n        vec3 diff = rp - ro;\n        if ( dot(diff, diff) > 60. ) return false;\n\n        float dist = max(0.0001, h * 0.06 * exp(max(0.0, (l - 0.5) * .2)));\n        rp += rd * dist;\n        l += dist;\n    }\n\n    return false;\n}\n\n//-----------------------------------------------------------------------\n\nvoid drawImage(out vec4 fragColor, in vec3 ro, in vec3 rd )\n{\n    vec3 rp = ro;\n\n    //grass:\n    fragColor = darkGrass;\n    if(!trace(rp, rd, fragColor))\n        if(rd.y > -0.08)\n            rp += rd * 10.0;\n    //fog:\n    float dist = length(ro - rp);\n    vec3 fog = skyColor;\n    fog = mix(fog, vec3(1.0), smoothstep(0.5,-0.4, rd.y));\n    fragColor.rgb = mix(fragColor.rgb, fog, smoothstep(3.0, 10.0, dist));\n\n    //sky:\n    if(rd.y > 0.02) fragColor = mix(fragColor, vec4(1.), sky(ro, rd));\n\n    //sun halo:\n    float halo = 2.053136; //pow(11.0, .3);\n    if(rd.z > 0.0) halo = pow(length(rd.xy), .3);\n    fragColor += clamp(1.0 - halo, 0.0, 1.0);\n    float mx = max(fragColor.r, fragColor.g);\n    mx = max(fragColor.b, mx);\n    fragColor /= max(1.0, mx); //remove its defect\n\n    // contrast\n    const float contr = 0.2;\n    fragColor = mix(vec4(0.0), vec4(1.0), fragColor * .2 + (1.0 - contr) * fragColor * fragColor * (3.0 - 2.0 * fragColor));\n}\n\n//--------------------------------------------------------------------------\n\nmat3 rotx(float a) { mat3 rot; rot[0] = vec3(1.0, 0.0, 0.0); rot[1] = vec3(0.0, cos(a), -sin(a)); rot[2] = vec3(0.0, sin(a), cos(a)); return rot; }\nmat3 roty(float a) { mat3 rot; rot[0] = vec3(cos(a), 0.0, sin(a)); rot[1] = vec3(0.0, 1.0, 0.0); rot[2] = vec3(-sin(a), 0.0, cos(a)); return rot; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= vec2(0.5);\n    uv.y /= iResolution.x / iResolution.y;\n\n    vec3 rp = vec3(0.0, 0.5, -1.0);\n    rp.z += iTime * 0.15;\n\n    vec3 rd = normalize(vec3(uv ,0.5));\n\n    vec2 m = iMouse.xy - 0.5 * iResolution.xy;\n    if(iMouse.xy == vec2(0.0)) m = vec2(0.0, 0.2 * iResolution.y);\n\n    rd *= rotx( (m.y / iResolution.y) * 2.0);\n    rd *= roty( (m.x / iResolution.y) * 3.0);\n    rd = normalize(rd);\n\n    drawImage( fragColor, rp, rd);\n}\n\n// VR entry point with cutting unnecessary pixels\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir ) {\n    fragCoord.x-=iResolution.x*.25;\n    fragCoord.y-=iResolution.y*.5;\n    if (length(fragCoord.xy)>iResolution.x*.225) discard;\n\tfragRayOri.y+=1.;\n    drawImage(fragColor, fragRayOri*.5, fragRayDir);\n}","name":"Image","description":"","type":"image"}]}