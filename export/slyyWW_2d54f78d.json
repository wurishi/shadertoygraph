{"ver":"0.1","info":{"id":"slyyWW","date":"1662313537","viewed":118,"name":"Cylinder aligned - intersection","username":"EisernSchild","description":"Here i provide an aligned Cylinder intersector since it has less computations than a generic one.\n\nGeneric cylinder (by IQ) : https://www.shadertoy.com/view/4lcSRn","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","intersector"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Cylinder vertical - Intersector\n// Copyright (c) 2022 by Denis Reischl\n//\n// SPDX-License-Identifier: MIT\n\n/*\n    Here i provide an aligned Cylinder intersector since it has less computations than a generic one.\n\n    Generic cylinder (by IQ) : https://www.shadertoy.com/view/4lcSRn\n*/\n\n// ray hit attribute\nstruct PosNorm\n{\n\tvec3 vPosition;\n\tvec3 vNormal;\n};\n\n// simple planar intersector, sets up normal\nvec4 iPlane(in vec3 vOri, in vec3 vDir)\n{\n    if (vDir.y > 0.f) return vec4(-1.);\n    \n    // set up normal, ortho project up-origin/up-dir\n    return vec4(-vOri.y/vDir.y, 0., 1., 0.);\n}\n\n// vertical, infinite cylinder\nvec4 iCylinderYInf(in vec3 vOri, in vec3 vDir, in vec2 vCen, float fRad)\n{\n    // get local origin XZ\n    vec2 vOriL = vOri.xz - vCen;\n    \n    // ortho project local origin->direction\n    float fOD = dot(vOriL, normalize(vDir.xz));\n    \n    // square distance origin->center minus radius\n    float fOR = dot(vOriL, vOriL) - fRad*fRad;\n    \n    // square hit center XZ (!)\n    float fTHitS = fOD*fOD - fOR;\n    \n    if (fTHitS < 0.) return vec4(-1.);\n    else\n    {\n        float fTHit = (-fOD - sqrt(fTHitS))/length(vDir.xz);\n        return vec4(fTHit, normalize(((vOri + vDir * fTHit) - vec3(vCen.x, 0., vCen.y)) * vec3(1., 0., 1.)));\n    }\n}\n\n// vertical cylinder, returns trace hit and normal\nvec4 iCylinderY(in vec3 vOri, in vec3 vDir, in vec3 vCen, vec2 vRad)\n{\n    // get local origin\n    vec3 vOriL = vOri - vCen;\n    \n    // ortho project local origin->direction XZ\n    float fOD = dot(vOriL.xz, normalize(vDir.xz));\n    \n    // square distance origin->center minus radius XZ\n    float fOR = dot(vOriL.xz, vOriL.xz) - vRad.x*vRad.x;\n    \n    // square hit center XZ (!)\n    float fTHitS = fOD*fOD - fOR;\n    \n    // no hit (cylinder side) ?\n    if (fTHitS < 0.) return vec4(-1.);\n    \n    // get actual hit distances near+far (to cylinder side..)\n    float fH = sqrt(fTHitS);\n    float fLXZ = length(vDir.xz);\n    vec2 afTHit = vec2((-fOD - fH)/fLXZ, (-fOD + fH)/fLXZ);\n    \n    // get hit distances to top and bottom\n    vec2 afDifY = vec2(vOri.y - (vCen.y + vRad.y), vOri.y - (vCen.y - vRad.y));\n    float fTHitT = abs(afDifY.x)/-vDir.y;\n    float fTHitB = abs(afDifY.y)/vDir.y;\n    \n    // above top base ?\n    if ((fTHitT > 0.) && (afDifY.x > 0.))\n        return (abs(fTHitB) < afTHit.x) ? vec4(-1.) : (fTHitT > afTHit.x) ? (fTHitT < afTHit.y) ? vec4(fTHitT, 0., 1., 0.) : vec4(-1.) : \n               vec4(afTHit.x, normalize(((vOri + vDir * afTHit.x) - vCen) * vec3(1., 0., 1.)));\n    // beneath bottom base ?\n    if ((fTHitB > 0.) && (afDifY.y < 0.))\n        return (abs(fTHitT) < afTHit.x) ? vec4(-1.) : (fTHitB > afTHit.x) ? (fTHitB < afTHit.y) ? vec4(fTHitB, 0., -1., 0.) : vec4(-1.) : \n               vec4(afTHit.x, normalize(((vOri + vDir * afTHit.x) - vCen) * vec3(1., 0., 1.)));\n    // beside cylinder or ray off\n    return (vDir.y > 0.) ? (afDifY.x > 0.) ? vec4(-1.) : (afTHit.x < abs(fTHitT)) ? vec4(afTHit.x, normalize(((vOri + vDir * afTHit.x) - vCen) * vec3(1., 0., 1.))) : vec4(-1.) : \n           (afDifY.y < 0.) ? vec4(-1.) : (afTHit.x < abs(fTHitB)) ? vec4(afTHit.x, normalize(((vOri + vDir * afTHit.x) - vCen) * vec3(1., 0., 1.))) : vec4(-1.);\n}\n\n// provide a lookat matrix\nmat4x4 LookAtLH(vec3 vCam, vec3 vTar, vec3 vUp)\n{\n    mat4x4 avLookAt;\n    vec3 vZ = normalize(vTar - vCam);\n    vec3 vX = normalize(cross(vUp, vZ));\n    vec3 vY = cross(vZ, vX);\n       \n    avLookAt = \n    mat4x4(\n        vec4(1., 0., 0., -vCam.x),\n        vec4(0., 1., 0., -vCam.y),\n        vec4(0., 0., 1., -vCam.z),\n        vec4(0., 0., 0., 1.)\n    ) *\n    mat4x4(\n        vec4(vX.x, vX.y, vX.z, 0.),\n        vec4(vY.x, vY.y, vY.z, 0.),\n        vec4(vZ.x, vZ.y, vZ.z, 0.),\n        vec4(0., 0., 0., 1.)\n    );\n    \n    return avLookAt;\n}\n\n// provide a perspective projection matrix\nmat4x4 PerspectiveLH(vec2 vFov, vec2 vZnf)\n{\n    float fW = tan(vFov.x*0.5),\n          fH = tan(vFov.y*0.5);\n    \n    mat4x4 avProj = mat4x4( 0.0 );\n    avProj[0][0] = 2. * vZnf.x / fW;\n    avProj[1][1] = 2. * vZnf.x / fH;\n    avProj[2][2] = vZnf.y / (vZnf.y - vZnf.x);\n    avProj[3][2] = 1.;\n    avProj[2][3] = vZnf.x*vZnf.y/(vZnf.x - vZnf.y);\n    \n    return avProj;  \n}\n\n// transform a ray based on screen position, camera position and inverse wvp matrix - Microsoft method\nvoid TransformRay(in uvec2 sIndex, in vec2 sScreenSz, in vec4 vCamPos, in mat4x4 sWVPrInv,\n\tout vec3 vOrigin, out vec3 vDirection)\n{\n\t// center in the middle of the pixel, get screen position\n\tvec2 vXy = vec2(sIndex.xy) + 0.5f;\n\tvec2 vUv = vXy / sScreenSz.xy * 2.0 - 1.0;\n\t\n\t// unproject by inverse wvp\n\tvec4 vWorld = vec4(vUv, 0, 1) * sWVPrInv;\n\n\tvWorld.xyz /= vWorld.w;\n\tvOrigin = vCamPos.xyz;\n\tvDirection = normalize(vWorld.xyz - vOrigin);\n}\n\n// simple checkers\nfloat checkers_001(vec2 vUv, float fDist)\n{\n    return mix(0.3, smoothstep(0.005, 0.005 + fDist * 0.005, min(fract(vUv.x), fract(vUv.y))) * (max(mod(floor(vUv.x), 2.), mod(floor(vUv.y), 2.)) * .25 + .75),\n        (1. - smoothstep(0.995 - fDist * 0.005, 0.995, max(fract(vUv.x), fract(vUv.y)))));\n}\n\n#define PI 3.141592654f\n#define AA 3\n\nvoid mainImage(out vec4 cOut, in vec2 vXY )\n{\n    // get current camera position and lookat matrix\n    float fCamDist = 3.6f + sin(iTime * .8);\n    vec4 vCamPos = vec4(sin(iTime) * fCamDist, .75f, cos(iTime) * fCamDist, 0.f);\n    mat4x4 avLookAt = LookAtLH(vCamPos.xyz, vec3(0.f, 0.45, 0.f), vec3(0.f, 1.f, 0.f));\n    \n    // get projection matrix\n    mat4x4 avProj = PerspectiveLH(vec2(radians(90.), radians(60.)), vec2(1., 1000.));\n    \n    cOut = vec4(0.);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n    // pixel coordinates\n    vec2 vOff = vec2(float(m),float(n)) / float(AA) - 0.5;\n    vec2 vXYo = vXY + vOff;\n    #else\n    vec2 vXYo = vXY;\n    #endif\n    \n    // get ray\n    vec3 vOri, vDir;\n    TransformRay(uvec2(vXY), iResolution.xy, \n        vCamPos, inverse(avLookAt * avProj), vOri, vDir);\n    \n    // do raytracing\n    float fTHit = -1.f, fTDist = 0.f, fB = 1.f;\n    vec3 avPos[2];\n    vec4 avTHitNor[2];\n    PosNorm sAttr;\n    \n    // intersect primitives\n    avPos[1] = vec3(0., sin(iTime) * .5 + .75, .5);\n    avTHitNor[0] = iPlane(vOri, vDir);\n    avTHitNor[1] = iCylinderY(vOri, vDir, avPos[1], vec2(0.5f, 0.25f));\n       \n    // get lit primitive index\n    int nTI = 0;\n    for(int nI = 0; nI < 2; nI++)\n    {\n        if (avTHitNor[nI].x > 0.)\n        {\n            if (fTHit > 0.)\n            {\n                if (avTHitNor[nI].x < fTHit) nTI = nI;\n            }\n            else nTI = nI;\n            \n            fTHit = avTHitNor[nTI].x;           \n        }\n    }\n    \n    // skip far/no hit\n    if ((fTHit < 0.) || (fTHit > 16.)) return;\n    \n    // get lit position + normal (hit attributes)\n    sAttr.vPosition = vOri + vDir * fTHit;\n    sAttr.vNormal = avTHitNor[nTI].yzw;\n    \n    // get tex uv\n    vec2 vUv = sAttr.vPosition.xz;\n    if (nTI ==  1)\n        vUv = (abs(sAttr.vNormal.y) < 1.) ? vec2(atan(sAttr.vNormal.z, sAttr.vNormal.x)/PI, sAttr.vPosition.y - avPos[1].y) :\n              vUv - avPos[1].xz;\n    \n    // simple checkers, set color * lighting\n    const vec3 vLight = normalize(vec3(-.4f, .2f, -.3f)); \n    float fOcc = 0.7 + 0.3*sAttr.vNormal.y;\n    fB *= (1. - fTHit * .1) * checkers_001(vUv * 2., fTHit) * fOcc;\n    vec3 cLit = mix(vec3(.1f, .1f, .2f), vec3(1.f, 1.f, 1.f), fB);\n\tfloat fDist = length(sAttr.vPosition.xyz - vOri);\n\tvec3 vRef = normalize(reflect(vDir, sAttr.vNormal));\n\tfloat fFresnel = max(dot(sAttr.vNormal, -vDir), 0.0);\n    float fSpecular = max(dot(vRef, vLight), 0.0);\n\tfFresnel = pow(fFresnel, .3) * 1.1;\n\tcLit = mix(cLit * .5, cLit * max(dot(sAttr.vNormal, vLight), 1.), min(fFresnel, 1.0));\n    cLit += pow(fSpecular, 100.) * .3;\n\tcLit = clamp(cLit, 0.f, 1.f);    \n\t                \n    cOut += vec4(cLit, 1.);\n                \n    #if AA>1\n    }\n    cOut /= float(AA*AA);\n    cOut.a = 1.f;\n    #endif\n}","name":"Image","description":"","type":"image"}]}