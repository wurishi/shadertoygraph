{"ver":"0.1","info":{"id":"MllXW2","date":"1440374153","viewed":190,"name":"budding","username":"mprice","description":"smin morphing doodle","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["blob"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"const int MAX_ITER = 35;\nconst float MAX_DIST = 5.0;\nconst float EPSILON = 0.001;\nconst float PI = 3.14159265;\n\nbool HIT_HOLE = false;\nbool HIT_BARREL = false;\nbool SPH_A = false;\nfloat DA, DB;\nvec3 posa;\nvec3 posb;\nfloat mix_factor;\nfloat barrel_factor;\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat smin( float a, float b) {\n    float k = 0.1;\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec3 rotateX(vec3 p, float ang) {\n  mat3 rmat = mat3(\n    1., 0., 0.,\n    0., cos(ang), -sin(ang),\n    0., sin(ang), cos(ang));\n  return rmat * p;\n}\nvec3 rotateY(vec3 p, float ang) {\n  mat3 rmat = mat3(\n    cos(ang), 0., sin(ang),\n    0., 1., 0.,\n    -sin(ang), 0., cos(ang));\n  return rmat * p;\n}\nvec3 rotateZ(vec3 p, float ang) {\n  mat3 rmat = mat3(\n    cos(ang), -sin(ang), 0.,\n    sin(ang), cos(ang), 0.,\n    0., 0., 1.);\n  return rmat * p;\n}\n\nfloat sphere(vec3 pos, float r) {\n  return length(pos) - r;   \n}\n\nfloat barrel(vec3 pos) {\n  float d = sphere(pos, 0.5);\n  pos.y += 0.5;\n  float holed = -sphere(pos, .25);\n  d = max(d, holed);\n  HIT_HOLE = (holed == d) ? true : HIT_HOLE;\n  return d;\n}\n\nfloat placedBarrel(vec3 pos, float rx, float ry) {\n  pos = rotateY(pos, ry);\n  pos = rotateX(pos, rx);\n  pos.y += 2.0;\n  return barrel(pos);\n}\n\nfloat spore(vec3 pos) {\n  float sphered = sphere(pos, 2.0);\n  float d = sphered;\n  d = min(d, placedBarrel(pos, 0., 0.));\n  d = min(d, placedBarrel(pos, 0.8, 0.));\n  d = min(d, placedBarrel(pos, 1.6, 0.));\n  d = min(d, placedBarrel(pos, 2.4, 0.));\n  d = min(d, placedBarrel(pos, 3.2, 0.));\n  d = min(d, placedBarrel(pos, 4.0, 0.));\n  d = min(d, placedBarrel(pos, 4.8, 0.));\n  d = min(d, placedBarrel(pos, 5.6, 0.));\n  d = min(d, placedBarrel(pos, 0.8, PI / 2.0));\n  d = min(d, placedBarrel(pos, 1.6, PI / 2.0));\n  d = min(d, placedBarrel(pos, 2.4, PI / 2.0));\n  d = min(d, placedBarrel(pos, 4.0, PI / 2.0));\n  d = min(d, placedBarrel(pos, 4.8, PI / 2.0));\n  d = min(d, placedBarrel(pos, 5.6, PI / 2.0));\n  d = min(d, placedBarrel(pos, 1.2, PI / 4.0));\n  d = min(d, placedBarrel(pos, 2.0, PI / 4.0));\n  d = min(d, placedBarrel(pos, 1.2, 3.0 * PI / 4.0));\n  d = min(d, placedBarrel(pos, 2.0, 3.0 * PI / 4.0));\n  d = min(d, placedBarrel(pos, 1.2, 5.0 * PI / 4.0));\n  d = min(d, placedBarrel(pos, 2.0, 5.0 * PI / 4.0));\n  d = min(d, placedBarrel(pos, 1.2, 7.0 * PI / 4.0));\n  d = min(d, placedBarrel(pos, 2.0, 7.0 * PI / 4.0));\n  HIT_BARREL = d != sphered;\n  barrel_factor = abs(d - sphered);\n  return d;\n}\n\nfloat distfunc(vec3 pos) {\n\n  HIT_HOLE = false;\n  HIT_BARREL = false;\n  \n  float si = sin(iTime);\n  float dsi = 2.;\n  float sc = (sin(iTime * .3) + 1.) * .5 + .2;\n    \n  posa = pos;\n  posa.x -= si * dsi;\n  posa = rotateX(posa, sin(iTime) * 3.);\n  posa /= sc;\n  DA = spore(posa) * sc;\n  float barrel_factor_a = barrel_factor;\n  \n  posb = pos;\n  posb.x += si * dsi;\n  DB = spore(posb);\n  float barrel_factor_b = barrel_factor;\n\n\n  SPH_A = (abs(DA) < abs(DB));\n\n  float dist = smin(DA, DB, 2.);\n  mix_factor = clamp(3. * min(abs(dist - DA), abs(dist - DB)), 0., 1.);\n  barrel_factor = clamp(4. * min(barrel_factor_a, barrel_factor_b), 0., 1.);\n  \n  vec3 bumppos = DA <= DB ? posa : posb;\n  dist += 0.003 *  noise(bumppos * 30.);\n  \n  return dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float m_x = (iMouse.x / iResolution.x) - 0.5;\n    float m_y = (iMouse.y / iResolution.y) - 0.5;\n    vec3 cameraOrigin = vec3(5.0 * sin(m_x * PI * 2.), m_y * 15.0, 5.0 * cos(m_x * PI * 2.));\n    vec3 cameraTarget = vec3(0.0, 0.0, 0.0);\n    vec3 upDirection = vec3(0.0, 1.0, 0.0);\n    vec3 cameraDir = normalize(cameraTarget - cameraOrigin);\n    vec3 cameraRight = normalize(cross(upDirection, cameraOrigin));\n    vec3 cameraUp = cross(cameraDir, cameraRight);\n    vec2 screenPos = -1.0 + 2.0 * gl_FragCoord.xy / iResolution.xy;\n    screenPos.x *= iResolution.x / iResolution.y;\n    vec3 rayDir = normalize(cameraRight * screenPos.x + cameraUp * screenPos.y + cameraDir);\n\n    float totalDist = 0.0;\n    vec3 pos = cameraOrigin;\n    float dist = EPSILON;\n    for (int i = 0; i < MAX_ITER; i++) {\n        if (dist < EPSILON || totalDist > MAX_DIST) { break; }\n        dist = distfunc(pos);\n        totalDist += dist;\n        pos += dist * rayDir;\n    }\n\n    if (dist < EPSILON) {\n      vec2 eps = vec2(0.0, EPSILON);\n      vec3 normal = normalize(vec3(\n            distfunc(pos + eps.yxx) - distfunc(pos - eps.yxx),\n            distfunc(pos + eps.xyx) - distfunc(pos - eps.xyx),\n            distfunc(pos + eps.xxy) - distfunc(pos - eps.xxy)));\n\n      vec3 lightdir = normalize(vec3(1., -1., 1.));\n      float diffuse = max(0.3, dot(lightdir, normal));\n      \n\n\n      float facingRatio = abs(dot(normal, rayDir));\n      \n        \n      vec3 sphcol = vec3(0.4, .6, .9);\n      if (!SPH_A) {\n        sphcol = vec3(1., 1., 0.);\n      }\n      vec3 mixcol = vec3(0.3, 0.8, 0.5);\n      vec3 barrelcol = vec3(1., 0.9, 0.9);\n      vec3 col = sphcol;\n      col = mix(barrelcol, col, barrel_factor );\n      col = mix(col, mixcol, mix_factor);\n      if (HIT_HOLE) {\n        col = mix(vec3(1., .9, .0), vec3(1., .3, 0.), facingRatio);    \n      }\n       col *= diffuse;\n       col += vec3(0.6, 0.6, 0.2) * (1. - facingRatio);\n\n\n        \n      fragColor = vec4(col, 1.0);\n    } else {\n      fragColor = vec4(screenPos.y + 1.5);\n    }\n\n}","name":"","description":"","type":"image"}]}