{"ver":"0.1","info":{"id":"DlBXz1","date":"1675648233","viewed":151,"name":"Sunny field","username":"ianertson","description":"Just wanted to see if I could produce a somewhat realistic grass texture from the textures we have here at shadertoy, combined with some noise.\n\nAnyways, use the mouse to look around :)","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","raymarch","texture","grass","repeat"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R iResolution.xy\n#define SPEED 1.0\n#define MOVE_SPEED (SPEED*2.8)\n#define T ((iTime*SPEED)+409.29)\n#define ZERO (min(0, int(iTime)))\n\n#define MOVE_Z ((iTime*MOVE_SPEED)+409.29)\n\n#define SUN_COLOR (vec3(253., 184., 19.) / 255.0)\n\n#define NEAR 0.003\n#define FAR 100.0\n#define STEPS 100\n\n#define ID_NONE 0\n#define ID_GROUND 1\n\n\n#define LIGHT_POINT 0\n#define LIGHT_AMBIENT 1\n\nstruct Light {\n    vec3 pos;\n    vec3 color;\n    float strength;\n    int type;\n};\n\nvec3 getLightDir(in Light light, vec3 p) {\n    switch (light.type) {\n        case LIGHT_POINT: return normalize(light.pos - p); break;\n        case LIGHT_AMBIENT: return normalize(light.pos); break;\n    }\n    \n    return vec3(0.0);\n}\n\nvec3 getLightAtt(in Light light, vec3 p, vec3 n) {\n    vec3 L = getLightDir(light, p);\n    float NdotL = max(0.0, dot(n, L));\n    float dist = distance(p, light.pos);\n    float att = NdotL * (light.type == LIGHT_AMBIENT ? (pow(light.strength, 2.0)) :\n        (pow(light.strength, 2.0) / max(0.0001, pow(dist, 2.0))));\n    \n    return light.color * att;\n}\n\nfloat fastnoise(vec2 p, float freq, float lod) {\n    return textureLod(iChannel3, p*freq, lod).r;\n}\n\nvec3 fastnoise(vec3 p) {\n    vec3 a = texture(iChannel0, p.xy+p.z).rgb;\n    vec3 b = texture(iChannel1, p.xz+p.y).rgb;\n    float c = texture(iChannel3, p.yz+p.x).r;\n    vec3 d = cross(a, b);\n    vec3 avg = (a+b+d)/3.0;\n    return avg*c;\n    \n}\n\nvec3 fastnoise(vec2 p) {\n    vec3 a = texture(iChannel0, p.xy).rgb;\n    vec3 b = texture(iChannel1, p.xy).rgb;\n    float c = texture(iChannel3, p.xy).r;\n    vec3 d = cross(a, b);\n\n    vec3 avg = (a+b+d)/3.0;\n    return avg*c;\n    \n}\n\nstruct Data {\n    vec3 point;\n    vec3 normal;\n    vec2 uv;\n    float dist;\n    float depth;\n    int id;\n    int skip;\n};\n\nvoid dataInit(inout Data data) {\n    data.point = vec3(0.0);\n    data.normal = vec3(0.0);\n    data.uv = vec2(0.0);\n    data.dist = FAR;\n    data.depth = 1.0;\n    data.id = 0;\n    data.skip = 0;\n}\n\nfloat groundHeight(vec3 p) {\n    const float freq = 0.002;\n\n    \n    vec2 uv = p.xz;\n    vec3 nb = vec3(0.0);\n    float nbf = 0.00023;\n    nb += fastnoise(uv*nbf); nbf *= 2.0;\n    nb += fastnoise(uv*nbf); nbf *= 2.0;\n    nb += fastnoise(uv*nbf); nbf *= 2.0;\n    nb += 0.9*fastnoise(uv*nbf); nbf *= 2.0;\n    nb += 0.8*fastnoise(uv*nbf); nbf *= 2.0;\n    nb /= 3.6;\n    \n    \n    float h = nb.x * 9.0;\n    \n    vec3 hill = fastnoise(uv*0.001);\n    \n    h += pow(hill.x, 2.2)*32.0;\n    \n    return h;\n}\n\nfloat groundSDF(inout Data data, vec3 p) {\n    float h = groundHeight(p);\n    \n    float dist = p.y - h;\n    \n    return dist / (1.0 + (h*0.5));\n}\n\n#define SAMPLE(var, id_) if (id_ != data.skip && var < minDist) { data.id = id_; minDist = var; }\n\nfloat getDist(inout Data data, vec3 p) {\n    float minDist = FAR;\n    \n    float ground = groundSDF(data, p);\n    \n    SAMPLE(ground, ID_GROUND);\n    \n    return minDist;\n}\n\nvec3 getNormal(inout Data data, vec3 p) {\n    vec2 e = vec2(0.3, 0.0);\n    return normalize(getDist(data, p) - vec3(\n        getDist(data, p - e.xyy),\n        getDist(data, p - e.yxy),\n        getDist(data, p - e.yyx)\n    ));\n}\n\nvec2 getUv(inout Data data) {\n    vec3 p = data.point;\n    vec3 n = data.normal;\n    vec2 uv = vec2(0.0);   \n    uv = mix(uv, p.xy, abs(dotc(n, vec3(0, 0, 1))));\n    uv = mix(uv, p.zx, abs(dotc(n, vec3(0, 1, 0))));\n    uv = mix(uv, p.yz, abs(dotc(n, vec3(1, 0, 0))));\n    return uv;\n}\n\nbool march(inout Data data, vec3 ro, vec3 rd) {\n    float dist = 0.0;\n    \n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*dist;\n        float next = getDist(data, p);\n        dist += next;\n        if (abs(next) <= NEAR || abs(dist) >= FAR) break;\n    }\n    \n    dist = abs(dist);\n    if (dist >= FAR) return false;\n    \n    vec3 p = ro+rd*dist;\n    data.point = p;\n    data.dist = dist;\n    data.depth = dist / FAR;\n    data.normal = getNormal(data, p);\n    data.uv = getUv(data);\n    \n    return true;\n}\n\nvec3 getAlbedo(inout Data data, vec2 uv) {\n    uv = data.point.xz * 2.3;\n    vec3 green0 = vec3(0.2, 0.9, 0.1);\n    vec3 green1 = vec3(0.6, 0.8, 0.2);\n    vec3 green2 = vec3(0.4, 1.0, 0.1);\n    vec3 a = getTexture(iChannel0, uv, vec2(0.25, 2.0)).rgb;\n    vec3 b = getTexture(iChannel1, uv, vec2(0.25, 2.0)).rgb;\n    vec3 c = getTexture(iChannel2, uv*0.5, vec2(1.0, 4.0)).rgb;\n    vec3 n = fastnoise(uv*0.1);\n    float n2 = pnoise(uv, 0.5, 2);\n    \n    vec3 nb = vec3(0.0);\n    float nbf = 0.001;\n    nb += fastnoise(uv*nbf); nbf *= 2.0;\n    nb += fastnoise(uv*nbf); nbf *= 2.0;\n    nb += fastnoise(uv*nbf); nbf *= 2.0;\n    nb += fastnoise(uv*nbf); nbf *= 2.0;\n    nb = pow(nb, vec3(1.6));\n    \n    vec3 col = vec3(0.);\n    col += green0*n.x;\n    col += green1*n.y;\n    col += green2*n.z;\n    col /= vec3(1.0) + col;\n    \n    col = mix(col, a, compress(nb.x));\n    col = mix(col, b, compress(nb.y));\n\n    \n    col = mix(col, c*c, compress(2.0*pow(n2, 4.0)));\n    \n    return col;\n}\n\n\n\nfloat getClouds(inout Data data, vec2 uv) {\n    uv = uv * 2.0 - 1.0;\n    \n    float speed = 0.16;\n    float mT = T * speed;\n    \n    float pwrFactor = fastnoise((uv*0.01) + (0.05*vec2(sin(mT*0.05), cos(mT*0.05))), 0.2, 0.0);\n    \n    float pwr = 2.6 + 0.6*(10.0*pwrFactor);\n    vec2 movement = vec2(0.0);\n    float freq = 1.0;\n    int depth = 4;\n    \n    \n    \n    \n    vec2 timeshift = vec2(cos(mT+(uv.x*freq)), sin(mT+(uv.y*freq)));\n    \n    vec2 moveshift = pow(pnoise2((uv+timeshift)*0.01, freq, depth), vec2(pwr)) * TAU;\n    \n    movement = vec2(cos(mT + moveshift.x), sin(mT + moveshift.y));\n    \n    \n    float n = pnoise(uv + movement, freq, depth);\n\n\n    movement = abs(movement);\n    float mag = max(movement.x, movement.y);\n    \n    n = (n+mag) / 2.0;\n    //n = (n + mag) / 2.0;\n    \n    \n    return compress(pow(n, pwr)*1.6);\n}\n\nvec3 getSky(inout Data data, vec3 ro, vec3 rd, in Light light, in vec3 L) {\n    vec3 col = vec3(0.0);\n    vec3 blue = vec3(0.1, 0.34, 0.8);\n    \n    \n    float clouds = getClouds(data, rd.xz / rd.y);\n    \n    col = blue;\n    \n    col += clouds;\n    \n    float dp = max(0.0, dot(rd, L));\n    float dotlight = compress(16.0*pow(dp, 128.0));\n    \n    float rad = 1000.0;\n    float feat = 0.001;\n    \n    vec3 flare = light.color * dotlight;\n    \n    col = mix(col, flare, dp*dp);\n //   col += light.color * dotlight;\n    \n    return col;\n}\n\nvec3 render(inout Data data, vec3 ro, vec3 rd) {\n    vec3 col = vec3(0.0);\n    \n    vec3 sunColor1 = vec3(1.0, 0.9, 0.5);\n    vec3 sunColor2 = vec3(1., 1., 0.95);\n    vec3 sunColor = mix(sunColor1, sunColor2, 0.4);\n    sunColor = mix(sunColor, SUN_COLOR, 0.33);\n    \n    Light light = Light(vec3(4, 4, 10.), sunColor, 2.0, LIGHT_AMBIENT);\n    vec3 L = getLightDir(light, vec3(0.));\n    vec3 sky = getSky(data, ro, rd, light, L);\n    \n    float dotup = max(0.0, dot(rd, vec3(0, 1, 0)));\n    float invup = 1.0 - smoothstep(0.0, 1.0, dotup*2.);\n    float dotlight = max(0.0, dot(rd, L));\n    \n    if (march(data, ro, rd)) {\n        vec3 albedo = getAlbedo(data, data.uv);\n        vec3 diffuse = albedo / M_PI;\n        \n        vec3 n = data.normal;\n        vec3 p = data.point;\n        \n        vec3 att = getLightAtt(light, p, n);\n        \n        col += diffuse * att;\n    } else {\n        col += sky;\n    }\n    \n    float depth = data.depth;\n    \n    col += mix(vec3(1.0), light.color, dotlight) * depth * invup;\n    \n\n    col += (light.color * pow(dotlight, 2.0)) / (TAU*TAU);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = (fc-0.5*R.xy)/R.y;\n    vec2 m = (iMouse.xy-0.5*R.xy)/R.y;\n    \n    vec3 ro = vec3(0.0, M_PI+0.5, -5.0);\n    vec3 rd = normalize(vec3(uv.xy, 1.0));\n    \n    ro.z += MOVE_Z;\n    \n    if (iMouse.z > 0.001) {\n        rd.yz *= rot(m.y*TAU);\n        rd.xz *= rot(m.x*TAU);\n    } else {\n        float moveT = T*0.25;\n        rd.yz *= rot(sin(moveT)*0.2);\n        rd.xz *= rot(cos(moveT)*0.5);\n    }\n    \n    \n    float H1 = groundHeight(ro);\n    float H2 = groundHeight(ro + vec3(0, 0, MOVE_Z));\n\n    \n    float H = mix(H1, H2, 1.0 / 60.);\n    \n    float dy = max(0.0, H - (ro.y - 1.6));\n    \n    ro.y += dy*(0.69+(dy*0.05));//H*(0.69+(H*0.05));\n    \n    Data data;\n    dataInit(data);\n    col += render(data, ro, rd);\n    \n    col /= vec3(0.659231) + col;\n    \n    col = pow(col, vec3(1.0 / 2.2));\n    \n    O = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define M_PI (3.1416)\n#define TAU (M_PI * 2.0)\n\nfloat mut(float p) { return fract(2.2151*exp(fract(fract((p+0.06981) / 10.0)*10.315)));}\nfloat mut2(float p) { return mut(mut(p)); }\nfloat mut4(float p) { return mut2(mut2(p)); }\nfloat mut8(float p) { return mut4(mut4(p)); }\nfloat mut16(float p) { return mut8(mut8(p)); }\nvec2 mut8(vec2 p) { return vec2(mut8(p.x), mut8(p.y)); }\nvec3 mut8(vec3 p) { return vec3(mut8(p.x), mut8(p.y), mut8(p.z)); }\nvec2 mut16(vec2 p) { return vec2(mut16(p.x), mut16(p.y)); }\nvec3 mut16(vec3 p) { return vec3(mut16(p.x), mut16(p.y), mut16(p.z)); }\n\nconst float HASH_MAP[16] = float[16](\n    0.4484410750068152, 0.5604512254151961, 0.49955284268263, 0.40679892641422355,\n    0.5180849501908357, 0.5472588115354913, 0.6766984192813609, 0.9064048675129073,\n    0.39864570212504613, 0.21022362764468383, 0.9516217965343488, 0.7301211180314449,\n    0.9928938541159735, 0.9095016245648258, 0.34485129267821846, 0.9842958980653165\n);\n#define IDX(v) (int(abs(v)*16.0) % 16)\n#define HASH(v) HASH_MAP[IDX(v)]\nfloat rand(vec2 p, float seed) {\n    p += vec2(cos(seed), sin(seed));\n    vec2 a = vec2(HASH(p.x), HASH(p.y))*10.0215;\n    vec2 b = vec2(HASH(p*a.x), HASH(p*a.y))*10.3921;    \n    return fract(20.0154*(dot(a, b) * dot(p, b)));\n}\n\nvec3 rand3(vec3 p, float seed) {\n    float x = rand(p.xz, seed);\n    float y = rand(p.yz, seed);\n    float z = rand(p.xy, seed);\n    return vec3(x, y, z) * 2.0 - 1.0;\n}\nmat2 rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\nvec4 getTexture(sampler2D tex, vec2 uv) {\n    vec2 id = floor(uv);\n    vec2 sv = smoothstep(0.0, 1.0, fract(uv));\n    float seed = 9.78376;\n    float self = rand(id, seed);\n    float right = rand(id+vec2(1.0, 0.0), seed);\n    float top = rand(id+vec2(0.0, 1.0), seed);\n    float topRight = rand(id+vec2(1.0, 1.0), seed);\n    vec2 dx = dFdx(uv);\n    vec2 dy = dFdy(uv);\n    return mix(\n        mix(textureGrad(tex, uv*rot(self*6.28), dx, dy),\n            textureGrad(tex, uv*rot(right*6.28), dx, dy), sv.x),\n        mix(textureGrad(tex, uv*rot(top*6.28), dx, dy),\n            textureGrad(tex, uv*rot(topRight*6.28), dx, dy), sv.x),\n        sv.y\n    );\n}\nvec4 textureAntiRepeatSingleLayer(sampler2D tex, vec2 uv, vec2 dx, vec2 dy) {\n    vec2 id = floor(uv);\n    vec2 sv = smoothstep(0.0, 1.0, fract(uv));\n    float seed = 9.78376;\n    float self = rand(id, seed);\n    float right = rand(id+vec2(1.0, 0.0), seed);\n    float top = rand(id+vec2(0.0, 1.0), seed);\n    float topRight = rand(id+vec2(1.0, 1.0), seed);\n    return mix(\n        mix(textureGrad(tex, uv*rot(self*6.28), dx, dy),\n            textureGrad(tex, uv*rot(right*6.28), dx, dy), sv.x),\n        mix(textureGrad(tex, uv*rot(top*6.28), dx, dy),\n            textureGrad(tex, uv*rot(topRight*6.28), dx, dy), sv.x),\n        sv.y\n    );\n}\nvec4 getTextureLayered(sampler2D tex, vec2 uv, vec2 scale) {\n    vec2 id = floor(uv);\n    vec2 sv = smoothstep(0.0, 1.0, fract(uv));\n    float seed = 3.31915;\n    float self = mix(scale.x, scale.y, rand(id, seed));\n    float right = mix(scale.x, scale.y, rand(id+vec2(1.0, 0.0), seed));\n    float top = mix(scale.x, scale.y, rand(id+vec2(0.0, 1.0), seed));\n    float topRight = mix(scale.x, scale.y, rand(id+vec2(1.0, 1.0), seed));\n    vec2 dx = dFdx(uv);\n    vec2 dy = dFdy(uv);\n    return mix(\n        mix(textureAntiRepeatSingleLayer(tex, (uv*self), dx, dy),\n            textureAntiRepeatSingleLayer(tex, (uv*right), dx, dy), sv.x),\n        mix(textureAntiRepeatSingleLayer(tex, (uv*top), dx, dy),\n            textureAntiRepeatSingleLayer(tex, (uv*topRight), dx, dy), sv.x),\n        sv.y\n    );\n}\nvec4 getTexture(sampler2D tex, vec2 uv, vec2 scale) {\n    return getTextureLayered(tex, uv, scale);\n}\n\nfloat compress(float n) { return clamp(n, 0.0, 1.0); }\n\n\n#define MAP(v) (0.5+(0.5*v))\n\n// https://en.wikipedia.org/wiki/Linear_congruential_generator\nuint linc(uint s) { return ((1103515245u * s) + 12345u) % 7883u; } \nfloat linc(float s) { return float(linc(uint(ceil(abs(s*10.0))))) / float(7883u); }\n\n// parkmiller\nuint pm_u(uint s) {return (s+16u) * 48271u % 0x7fffffffu;}\n\n// float parkmiller\nfloat pm(float s) { return exp(fract((float(pm_u(uint(ceil(abs(s))))) / float(0x7fffffffu / 48271u)) * (0.5 + s))); }\n\n// combination of linc and pm\nfloat rand11(float v) { return linc(v+pm(v)); }\n\n// combination of linc and pm but with vec2 as input\nfloat rand21(vec2 p) {\n    float x = rand11(rand11(rand11(p.x)));\n    float y = rand11(rand11(rand11(p.y)));\n    float z = fract(dot(p, vec2(x, y))) * 10.2315;\n    return fract(rand11((z*z)/(10.0315+exp(x*y))) * exp(z));\n}\n\n// smooth noise\nfloat pnoise(vec2 p) {\n    vec2 id = floor(p);\n    vec2 lv = smoothstep(0.0, 1.0, fract(p));\n    return mix(mix(rand21(id), rand21(id+vec2(1.0, 0.0)), lv.x),\n        mix(rand21(id+vec2(0.0, 1.0)),\n        rand21(id+vec2(1.0, 1.0)), lv.x), lv.y);\n}\n\n// layered smooth noise\nfloat pnoise(vec2 p, float freq, int depth) {\n    float n = 0.0;\n    for (int i = 0; i < depth; i++) { n += pnoise(p*freq); freq *= 2.0; }\n    return n / float(depth);\n}\n\nvec2 pnoise2(vec2 p, float freq, int depth) {\n    float x = pnoise(p, freq, depth);\n    float y = pnoise(p+vec2(0.3219, 0.1215), freq, depth);\n    return vec2(x, y);\n}\n\nfloat dotc(vec3 a, vec3 b) { return clamp(dot(a, b), 0.0, 1.0); }","name":"Common","description":"","type":"common"}]}