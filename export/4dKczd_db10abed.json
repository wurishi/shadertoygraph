{"ver":"0.1","info":{"id":"4dKczd","date":"1522986848","viewed":414,"name":"Katabatic caustic of an ellipse","username":"dpiponi","description":"Rendered using wave optics. Mouse controls the wavelength.\nThere's some colour leaking outside of the ellipse. Need to fix that.\nFiddle with the source code if you want to see some other shapes.\nParabola's nice if you can see which lines to comment out","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["physics","optics","diffraction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat hypot(vec2 p) {\n    return sqrt(p.x*p.x+p.y*p.y);\n}\n\nfloat pi = 3.1415926;\n\nfloat cross2(vec2 u, vec2 v) {\n    return u.x*v.y-u.y*v.x;\n}\n\nvec2 path(float t) {\n    float theta = 2.0*pi*(t-0.5);\n    float alpha = 0.2*iTime;\n    mat2 m = mat2(cos(alpha), -sin(alpha), sin(alpha), cos(alpha));\n\n    vec2 xy = vec2(0.75*cos(theta), sin(theta));\n    //vec2 xy = vec2(theta, 1.5*theta*theta-1.0);\n    //return vec2(-theta*theta, theta);\n    //return vec2(-cos(theta), sin(theta));\n    //vec2 xy = vec2(-cos(theta)*cos(theta)*cos(theta), sin(theta)*sin(theta)*sin(theta));\n\n    return 1.0*m*xy;\n}\n\n// float l(vec2 xy, float theta) {\n//     return -path(theta).x+hypot(xy-path(theta));\n// }\n\nfloat gain = 0.70;\n//float wavelength = 0.03;\n\nfloat integrate(vec2 xy) {\n    float tx = 0.0;\n    float ty = 0.0;\n    int n = 2000;\n    vec2 last_p = path(0.0);\n\n    float wavelength = 0.02+0.02*iMouse.x/iResolution.x;\n\n    for (int i = 0; i < 2000; ++i) {\n        float t = float(i)/float(n);\n        vec2 p = path(t);\n        float d = hypot(xy-p);\n\n        float dt = p.y-last_p.y;\n\n        if (dt < 0.0 && cross2(p-last_p, xy-p) > 0.0) {\n            float path_length = d-p.x;\n            float s = 2.0*pi/wavelength*path_length;\n            tx += cos(s)*dt/d;\n            ty += sin(s)*dt/d;\n        }\n\n//        path_length = d+p.x;\n//        s = -2.0*pi/wavelength*path_length;\n//        tx += cos(s)*dt/d;\n//        ty += sin(s)*dt/d;\n\n        last_p = p;\n    }\n    return hypot(vec2(tx, ty));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = vec2(0.5*iResolution.x, 0.5*iResolution.y);\n    vec2 uv = fragCoord.xy-center;\n    uv = 2.0*uv/iResolution.y;\n    float c = gain*integrate(uv);\n    fragColor = vec4(1.2*sqrt(c), c, 0.5*c, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}