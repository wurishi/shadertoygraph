{"ver":"0.1","info":{"id":"WtdfRr","date":"1612130694","viewed":76,"name":"sphere23","username":"edwardbraed","description":"Just a first raymarch experiment..","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","sphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS_MARCH 64\n#define SPHERE_RADIUS 1.0\n#define COLOR vec3(0.8, 0.5, 1.0)\n\nfloat raymarch(vec3 ro, vec3 rd, vec3 lv, float g)\n{\n    float t = 0.0;\n    for(int x = 0; x < MAX_STEPS_MARCH; x++)\n    {\n        vec3 pos = ro + rd * t;\n        float d = length(pos) - SPHERE_RADIUS;\n        if(d < 0.001)\n        {\n            float l = dot(normalize(lv), normalize(pos));\n            return max(l, 0.1);\n        }\n        \n        t += d;\n    }\n    \n    return g;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // aspect ratio for correction rays..\n    float a = iResolution.x / iResolution.y;\n    \n    // pseudo perspective pyramid (directions rays)\n    vec2 dTr = vec2(1.0, 1.0);\n    vec2 dTl = vec2(-1.0, 1.0);\n    vec2 dBr = vec2(1.0, -1.0);\n    vec2 dBl = vec2(-1.0, -1.0);\n    \n    // common uv ray direction\n    vec3 rd = vec3(mix(mix(dBl, dBr, uv.x),\n                       mix(dTl, dTr, uv.x), uv.y),\n                   1.0);\n    rd.x *= a;\n    \n    // origin direction (or pseudo camera position)\n    vec3 ro = vec3(0.0, 0.0, -2.0);\n    // light vector\n    vec3 lv = vec3(sin(iTime), 0.5, cos(iTime));\n    // background gradient\n    float g = pow(1.0 - distance(uv, vec2(0.5)), 2.0) * 0.7;\n    \n    vec3 rgb = vec3(COLOR * raymarch(ro, rd, lv, g));\n    \n    // Output to screen\n    fragColor = vec4(rgb, 1.0);\n}","name":"Image","description":"","type":"image"}]}