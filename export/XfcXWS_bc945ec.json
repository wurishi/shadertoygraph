{"ver":"0.1","info":{"id":"XfcXWS","date":"1714349803","viewed":81,"name":"Electric field around particles","username":"ealbers","description":"Field around various point charges, click and drag ","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["physics","electricfield"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Thanks to  https://www.shadertoy.com/view/lljczz  !\n#define field(p) vec2( (p).x, (p).y ) / dot(p,p)      // field around a point charge\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n#define JIT true                                      // jittering on or off\n    float n = 10.,                                     // number of cells = 2n x 2n\n        dt = 1./60.;                                  // dt represents the field strength\n    vec2 R = iResolution.xy,\n         u = (U+U-R)/R.y,                             // normalized coordinates\n         M = iMouse.xy,                               // mouse control or autodemo\n         m1 = length(M)>10. ? (M+M-R)/R.y : vec2(sin(iTime), .2*cos(iTime/3.71)),  // Controlled by mouse or demo\n         m2 = vec2(sin(iTime*0.6), cos(iTime*0.6)),   // Second pair controlled by time\n         m3 = vec2(sin(iTime*1.1), cos(iTime*0.3)),   // Third pair controlled by time\n         p = floor(u*n+.5) / n;                       // cell center\n    O-=O;\n    \n    int N = 5;                                        // Neighborhood size = NxN   \n    for( int i=0; i<N*N; i++)                         // allows overflow to neighbor cell\n    {\n        vec2 P = p + vec2( i%N -N/2, i/N -N/2 ) / n;  // cell coordinate in neighborhood\n        if (JIT) P += .2* ( 2.* fract( 4e4* sin( 1e3* mat2(1,7.1,-5.1,2.3) * (P) )) -1. ) / n;  // jittering\n        \n        vec2 X = u-P,                                  // local coordinate\n             V =  field(P-m1) - field(P+m1) +          // field at P caused by charges at +- m1\n                  field(P-m2) - field(P+m2) +          // field at P caused by charges at +- m2\n                  field(P-m3) - field(P+m3);           // field at P caused by charges at +- m3\n        \n        float l = length(V),\n             r1 = dt * l, r2 = 2./R.y;                 // ellipse radii ~ ( |V|dt , 1 pixel )\n        V /= l;\n        mat2 Q = mat2( V / r1, vec2(-V.y,V.x) / r2 );  // ellipse equation: length(Q.X) = const\n                                                        // main axis = V\n        \n        // Color based on polarity and field strength\n        vec3 colorPos = vec3(1.0, 0.1, 0.1) * smoothstep(0., 1., l * 10.);  // Red for positive\n        vec3 colorNeg = vec3(0.1, 0.1, 1.0) * smoothstep(0., 1., l * 10.);  // Blue for negative\n        \n        // Add positive and negative contributions separately\n        O += vec4((length(P-m1) < length(P+m1) ? colorPos : colorNeg), 1.0) * smoothstep(2., 0., length(X*Q));\n        O += vec4((length(P-m2) < length(P+m2) ? colorPos : colorNeg), 1.0) * smoothstep(2., 0., length(X*Q));\n        O += vec4((length(P-m3) < length(P+m3) ? colorPos : colorNeg), 1.0) * smoothstep(2., 0., length(X*Q));\n    }\n}\n","name":"Image","description":"","type":"image"}]}