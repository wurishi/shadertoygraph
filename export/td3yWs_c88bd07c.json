{"ver":"0.1","info":{"id":"td3yWs","date":"1601971339","viewed":2181,"name":"INKTtober - Mirror","username":"Flopine","description":"Third day of the Inktober challenge! For 2020 I'm using the Inkt-Tober list: https://twitter.com/Trish_Argh/status/1304878524797419525","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","isometric","voronoise","twitch","inktober"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan and slerpy for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n\n#define time iTime\n#define PI acos(-1.)\n#define TAU 6.283581\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define hash22(x) fract(sin(vec2(dot(x,vec2(34.1,27.14)),dot(x,vec2(17.4,32.4))))*147.4)\n#define hash21(x) fract(sin(dot(x,vec2(14.5,35.4)))*1479.37) \n\nvec2 voronoise (vec2 uv)\n{\n    vec2 uvid = floor(uv),\n        uvrep = fract(uv),\n        m_point;\n    float m_dist = 10.;\n\n    for (int j = -1; j<=1; j++)\n    {\n        for (int i = -1; i<=1; i++)\n        {\n            vec2 neighbor = vec2(float(i), float(j));\n            vec2 point = hash22(uvid + neighbor);\n            point = 0.5+0.5*sin(2.*PI*point+time);\n            vec2 diff = neighbor + point - uvrep;\n\n            float dist = length(diff);\n            if (dist < m_dist)\n            {\n                m_dist = dist;\n                m_point = uvid + neighbor;\n            }\n        }\n    }\n    return m_point;\n}\n\nvoid moda (inout vec2 p, float rep)\n{\n    float per = TAU/rep;\n    float a = mod(atan(p.y,p.x), per)-per*0.5;\n    p = vec2(cos(a), sin(a))*length(p);\n}\n\nvoid mo (inout vec2 p, vec2 d)\n{\n    p = abs(p)-d;\n    if(p.y>p.x) p = p.yx;\n}\n\nfloat stmin (float a, float b, float k, float n)\n{\n    float st = k/n;\n    float u = b-k;\n    return min(min(a,b),0.5*(u+a+abs(mod(u-a+st,2.*st)-st)));\n}\n\nfloat box (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0.,max(q.x,max(q.y,q.z)))+length(max(q,0.));\n}\n\nfloat sc (vec3 p, float d)\n{\n    p = abs(p);\n    p = max(p,p.yzx);\n    return min(p.x,min(p.y,p.z))-d;  \n}\n\nfloat cyl (vec3 p, float r, float h)\n{return max(length(p.xy)-r,abs(p.z)-h);}\n\nfloat room (vec3 p)\n{\n    float sx = 10.;\n    float sy = 3.;\n    float d = -box(p,vec3(sx,sy,6.));\n\n    moda(p.xz, 5.);\n    p.x -= sx*0.3;\n\n    p.x = abs(p.x)-sx*0.1;\n    d = stmin(d,cyl(p.xzy, 0.4, sy*1.2),0.3, 4.);\n\n    return d;\n}\n\nfloat SDF (vec3 p)\n{return room(p);}\n\nfloat isoSDF (vec3 p)\n{\n    p.yz *= rot(-atan(1./sqrt(2.)));\n    p.xz *= rot(PI/4.);\n\n    mo(p.xy, vec2(2.));\n    mo(p.xz, vec2(1.5));\n    p.x -= 1.;\n    float d = max(-sc(p,0.8),box(p,vec3(.9)));\n\n    return d;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n\n    float dither = hash21(uv);\n\n    vec2 voro = voronoise(uv*4.5);\n    float mask = smoothstep(0.75,0.9,length(voro)*0.25);\n\n    uv += voro*0.05;\n    \n    bool inside = step(0.9,length(voro)*0.25)<0.5;\n    vec3 ro, rd;\n    if(inside)\n    {\n        ro = vec3(uv*4.,-30.); \n        rd = vec3(0.,0.,1.); \n    }    \n    else  \n    {\n        ro = vec3(1.2,0.001, -4.9);\n        rd = normalize(vec3(uv,1.)); \n    }    \n\n    vec3 p = ro, col = vec3(0.);\n\n\n    float shad = 0., d;\n    for (float i=0.; i<64.;i++)\n    {\n        d = inside ? isoSDF(p) : SDF(p);\n        if (d<0.01)\n        {\n            shad = i/64.; break;\n        }\n        d *= 0.7+dither*0.4;\n        p += d*rd;\n    }\n\n    col = vec3(1.-shad);\n\n    col = mix(1.-col, col, mask);\n\n    fragColor = vec4(sqrt(col),0.);\n}","name":"Image","description":"","type":"image"}]}