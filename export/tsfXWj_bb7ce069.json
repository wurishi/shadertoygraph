{"ver":"0.1","info":{"id":"tsfXWj","date":"1552231004","viewed":2984,"name":"VHS Compression","username":"mpalko","description":"Simulates the resolution and format of VHS tapes (with resolution presets for both NTSC and PAL) without any noise/distortion effects.\n\nUse the mouse to swipe back and forth with the effect enabled/disabled.\n\nPreview video can be subbed out in Buffer A.","likes":28,"published":1,"flags":32,"usePreview":0,"tags":["video","vhs","ntsc","pal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvec2 rotate(vec2 v, float a)\n{\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 mouseNormalized = iMouse.xy / iResolution.xy;\n    \n    vec2 resLuminance = min(maxResLuminance, vec2(iResolution));\n    vec2 resChroma = min(maxResChroma, vec2(iResolution));\n    \n    vec2 uvLuminance = uv * (resLuminance / vec2(iResolution));\n    vec2 uvChroma = uv * (resChroma / vec2(iResolution));\n    \n    vec3 result;\n    \n    if (uv.x > mouseNormalized.x)\n    {\n        float luminance = textureBicubic(iChannel1, uvLuminance).x;\n        vec2 chroma = textureBicubic(iChannel1, uvChroma).yz;\n        result = vec3(luminance, chroma) * yiq2rgb;\n    }\n    else\n    {\n        result = texture(iChannel0, uv).rgb;\n    }\n    \n    fragColor = vec4(result, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Copies input video to buffer, for a common input source in subsequent shaders\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define lerp mix\n\n#define NTSC 0\n#define PAL 1\n\n// Effect params\n#define VIDEO_STANDARD PAL\n\n#if VIDEO_STANDARD == NTSC\n    const vec2 maxResLuminance = vec2(333.0, 480.0);\n    const vec2 maxResChroma = vec2(40.0, 480.0);\n#elif VIDEO_STANDARD == PAL\n    const vec2 maxResLuminance = vec2(335.0, 576.0);\n    const vec2 maxResChroma = vec2(40.0, 240.0);\n#endif\n\nconst vec2 blurAmount = vec2(0.2, 0.2);\n\n// End effect params\n\n#define VIDEO_TEXTURE iChannel0\n\n\n\nmat3 rgb2yiq = mat3(0.299, 0.596, 0.211,\n                        0.587, -0.274, -0.523,\n                        0.114, -0.322, 0.312);\n\nmat3 yiq2rgb = mat3(1, 1, 1,\n                        0.956, -0.272, -1.106,\n                        0.621, -0.647, 1.703);\n\n// from http://www.java-gaming.org/index.php?topic=35123.0\nvec4 cubic(float v)\n{\n    vec4 n = vec4(1.0, 2.0, 3.0, 4.0) - v;\n    vec4 s = n * n * n;\n    float x = s.x;\n    float y = s.y - 4.0 * s.x;\n    float z = s.z - 4.0 * s.y + 6.0 * s.x;\n    float w = 6.0 - x - y - z;\n    return vec4(x, y, z, w) * (1.0/6.0);\n}\n\nvec4 textureBicubic(sampler2D sampler, vec2 texCoords)\n{\n\n    vec2 texSize = vec2(textureSize(sampler, 0));\n    vec2 invTexSize = vec2(1.0) / texSize;\n\n    texCoords = texCoords * texSize - 0.5;\n\n\n    vec2 fxy = fract(texCoords);\n    texCoords -= fxy;\n\n    vec4 xcubic = cubic(fxy.x);\n    vec4 ycubic = cubic(fxy.y);\n\n    vec4 c = texCoords.xxyy + vec2 (-0.5, +1.5).xyxy;\n\n    vec4 s = vec4(xcubic.xz + xcubic.yw, ycubic.xz + ycubic.yw);\n    vec4 offset = c + vec4 (xcubic.yw, ycubic.yw) / s;\n\n    offset *= invTexSize.xxyy;\n\n    vec4 sample0 = texture(sampler, offset.xz);\n    vec4 sample1 = texture(sampler, offset.yz);\n    vec4 sample2 = texture(sampler, offset.xw);\n    vec4 sample3 = texture(sampler, offset.yw);\n\n    float sx = s.x / (s.x + s.y);\n    float sy = s.z / (s.z + s.w);\n\n    return mix(\n       mix(sample3, sample2, sx), mix(sample1, sample0, sx)\n    , sy);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Downsample buffer A and convert to YIQ color space\n\n\nvec3 downsampleVideo(vec2 uv, vec2 pixelSize, ivec2 samples)\n{\n    //return texture(VIDEO_TEXTURE, uv).rgb * rgb2yiq;\n    \n    vec2 uvStart = uv - pixelSize / 2.0;\n    vec2 uvEnd = uv + pixelSize;\n    \n    vec3 result = vec3(0.0, 0.0, 0.0);\n    for (int i_u = 0; i_u < samples.x; i_u++)\n    {\n        float u = lerp(uvStart.x, uvEnd.x, float(i_u) / float(samples.x));\n        \n        for (int i_v = 0; i_v < samples.y; i_v++)\n        {\n            float v = lerp(uvStart.y, uvEnd.y, float(i_v) / float(samples.y));\n            \n            result += texture(VIDEO_TEXTURE, vec2(u, v)).rgb;\n        }\n    }    \n    \n    return (result / float(samples.x * samples.y)) * rgb2yiq;\n}\n\nvec3 downsampleVideo(vec2 fragCoord, vec2 downsampledRes)\n{\n   \n    if (fragCoord.x > downsampledRes.x || fragCoord.y > downsampledRes.y)\n    {\n        return vec3(0.0);\n    }\n    \n    vec2 uv = fragCoord / downsampledRes;\n    vec2 pixelSize = 1.0 / downsampledRes;\n    ivec2 samples = ivec2(8, 3);\n    \n    pixelSize *= 1.0 + blurAmount; // Slight box blur to avoid aliasing\n    \n    return downsampleVideo(uv, pixelSize, samples);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 resLuminance = min(maxResLuminance, vec2(iResolution));\n    vec2 resChroma = min(maxResChroma, vec2(iResolution));    \n    \n    float luminance = downsampleVideo(fragCoord, resLuminance).r;\n    vec2 chroma = downsampleVideo(fragCoord, resChroma).gb;\n    \n    fragColor = vec4(luminance, chroma, 1);\n}","name":"Buffer B","description":"","type":"buffer"}]}