{"ver":"0.1","info":{"id":"tt3cDl","date":"1611175091","viewed":378,"name":"engelwood - sundown â™«","username":"TheNosiriN","description":"I really love engelwood's tracks","likes":30,"published":1,"flags":96,"usePreview":0,"tags":["raymarching","reflection","sdf","water","song","lighthouse","jazz"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XtsSzN","filepath":"https://soundcloud.com/engelwoodmusic/sundown","previewfilepath":"https://soundcloud.com/engelwoodmusic/sundown","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//ACES tonemapping from: https://www.shadertoy.com/view/3tfcD8\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\n\n\n\n//partly from: https://www.shadertoy.com/view/4dySRw\nfloat normpdf(in float x, in float sigma){\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\nvec3 soften(sampler2D tex, vec2 coord, vec3 screen, float strength)\n{\n    const int mSize = 9;\n    const int kSize = (mSize-1)/2;\n    float kernel[mSize];\n    vec3 final_colour = vec3(0.0);\n\n    float sigma = 7.0;\n    float Z = 0.0;\n    for (int j = 0; j <= kSize; ++j){\n        kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);\n    }\n\n    for (int j = 0; j < mSize; ++j){\n        Z += kernel[j];\n    }\n\n    for (int i=-kSize; i <= kSize; ++i){\n        for (int j=-kSize; j <= kSize; ++j){\n            final_colour += saturate(kernel[kSize+j]*kernel[kSize+i]*texture(tex, (coord+vec2(float(i),float(j))) / iResolution.xy).rgb);\n        }\n    }\n\n    return mix(screen,final_colour/(Z*Z),strength);\n}\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 buff;\n    float AA_size = 3.0;\n    for (float y = 0.0; y < AA_size; y++){\n        for (float x = 0.0; x < AA_size; x++){\n            buff += texture(iChannel0, (fragCoord+vec2(x, y)/AA_size)/iResolution.xy).rgba;\n        }\n    }\n    buff /= AA_size*AA_size;\n    \n    buff.a = buff.a >= 1.0 ? 0.0 : buff.a;\n    \n    buff.rgb = soften(iChannel0, fragCoord, buff.rgb, (buff.a)/2.0);\n    \n    \n    buff.rgb = ACESFilm(buff.rgb);\n    buff.rgb = pow(buff.rgb, vec3(1.0/2.2)); //comment this for an extra red sunset\n    \n    fragColor = vec4(buff.rgb, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//use this if your pc can handle it, mine blew up\n//#define BRUTE_FORCE_AA\n#define FORCED_AA_SIZE 3.0\n//\n\n\n\n#define UV (gl_FragCoord.xy/iResolution.y)\n#define PI 3.1415972\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define maxd(p1, p2) (p1.x > p2.x ? p1 : p2)\n#define mind(p1, p2) (p1.x < p2.x ? p1 : p2)\n#define M3 mat3(0.00,0.80,0.60,-0.80,0.36,-0.48,-0.60,-0.48,0.64)\n#define M2 mat2(0.8,-0.6,0.6,0.8)\n\n#define TIME (iTime*0.5)\n\n\nconst float MAX_DIST = 100.0;\nconst int MAX_BOUNCES = 3; //making this 3 increases the quality\nconst float EPSILON = 0.001;\n#define SUN_DIR normalize(vec3(0,sin(TIME*0.1),1))\n\n\n\n\nstruct Material{\n    vec3 color;\n    float diffuse;\n    float specular;\n    float reflective;\n    bool unshaded;\n};\n\n\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\n\nvec3 rotateCamera(float len, vec2 m, vec4 mouse)\n{\n    float phi = m.x * PI * 2.0;\n    if(mouse.x < 0.5){\n        phi = PI * 0.1;\n    }\n    \n    float psi = m.y * PI;\n    if(mouse.y < 0.5){\n        psi = 0.33 * PI;\n    }\n    return len * vec3(cos(phi)*sin(psi), cos(psi), sin(phi)*sin(psi));\n}\n\n\n\n\n\n//////////////////////////////////////////////////////////\n#define dot2(x) dot(x,x)\n\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.0*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.0;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.0;\n\tp = vec2(cos(a), sin(a))*r;\n\tif (abs(c) >= (repetitions/2.0)) c = abs(c);\n\treturn c;\n}\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) {\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\nfloat minr(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min(a, b)) - length(u);\n}\nvec2 minr(vec2 a, vec2 b, float r) {\n\tvec2 u = max(vec2(r - a.x,r - b.x), vec2(0));\n    vec2 ab = mind(a,b);\n\treturn vec2(max(r, ab.x) - length(u), ab.y);\n}\n\n\n\n\nfloat cyl(vec3 p, float h, float r)\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r, h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat cylside(vec3 p, float h, float r)\n{\n  vec2 d = abs(vec2(length(p.xy),p.z)) - vec2(r, h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat cube(vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat bBox( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\nfloat cone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\nfloat torus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//Frabrice's octagon: https://www.shadertoy.com/view/4sKfD3\nfloat octagon(vec3 p, float h, float r)\n{\n    vec3 a = abs(p);\n    float t = max(a.x,a.z) -r;\n    t = max(t,(a.x+a.z)/1.41 -r);\n    t = max(t,a.y -h);\n    return t;\n}\n\n\nfloat remap(float val, float OldMin, float OldMax, float NewMin, float NewMax){\n    return (((val - OldMin) * (NewMax - NewMin)) / (OldMax - OldMin)) + NewMin;\n}\n\n\n\nmat2 rotate(float angle)\n{\n\tangle *= PI / 180.0;\n    float s = sin(angle), c = cos(angle);\n    return mat2( c, -s, s, c );\n}\n\n\n\nvec3 triplanarMap(sampler2D tex, vec3 p, vec3 n, float scale)\n{\n    p *= scale;\n    \n    return  (texture(tex,p.xy).rgb*n.z*n.z\n            +texture(tex,p.zy).rgb*n.x*n.x\n            +texture(tex,p.xz).rgb*n.y*n.y);\n}\nvec3 triplanarNormal(sampler2D tex, vec3 p, vec3 N, float strength, float scale)\n{\n    vec3 P = vec3(-4, 4, 0) * 0.01;\n    \n    vec3 B = vec3(\n        triplanarMap(tex, p+P.xzz, N, scale).r, \n        triplanarMap(tex, p+P.zxz, N, scale).r,\n        triplanarMap(tex, p+P.zzx, N, scale).r\n    ) - triplanarMap(tex, p, N, scale).r;\n    \n    B = (B-N*dot(B,N));\n    return normalize(N+B*strength);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int M_WATER = 1;\nconst int M_ROCK = 2;\nconst int T_WHITE = 3;\nconst int T_STONE = 4;\nconst int T_WINDOW = 5;\nconst int T_SIGN = 6;\n\n\n\n\nvec4 getHashTex(vec2 p){\n    p.y = 1.0 - p.y;\n    return textureLod(iChannel0, p/256.0, 0.0);\n}\nfloat noiseTex( in vec3 x ){\n\tvec3 i = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n    vec2 rg = getHashTex(((i.xy+vec2(37.0,17.0)*i.z) + f.xy)+0.5).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\nfloat fbm(vec2 p, int oct)\n{\n    p *= 0.05;\n    float d = 0.0, a = 1.0;\n    float dist = pow(smoothstep(0.5, 1.0, 1.0-(length(p)-0.1)), 5.0);\n    for (int i=0; i<oct; i++){\n        float n = texture(iChannel1, p).r;\n        d += n * a * dist;\n        p = M2*p*2.0;\n        a *= 0.5;\n    }\n    return d;\n}\n\n\nfloat getpebbles(vec3 p, vec3 n){\n    return triplanarMap(iChannel1, p, n, 0.02).r;\n}\n\n\nfloat getFogfbm(vec3 d){\n    d.x += TIME*0.05;\n    d.y -= TIME*0.08;\n    d.z += TIME*0.10;\n    float f = 0.0;\n    f += 0.5000 * noiseTex(d); d = M3*d*2.02;\n    f += 0.2500 * noiseTex(d);\n    return (f/0.75);\n}\n\n\n\n\nfloat getwave(vec3 p){\n    p *= 0.01;\n    return mix(\n        texture(iChannel1, p.xz+TIME*0.01).r,\n        texture(iChannel1, p.zx-TIME*0.025).r,\n        sin(p.y*2.0)*0.5+0.5\n    );\n}\n\n\n\nvec3 getfloating(vec3 p, float shift, float str){\n    p.xy *= rotate(sin(TIME+shift)*str*PI);\n    p.yz *= rotate(cos(TIME+shift)*str*PI);\n    p.yx *= rotate(cos(TIME+shift)*str*PI);\n    return p;\n}\n\n\n\n\nvec2 floatingThing(vec3 p)\n{\n    float r = 1.0;\n    float h = 3.0;\n    \n    vec2 bd = vec2(length(p) - r*1.25, M_ROCK);\n    bd.x = max(bd.x, p.y);\n    \n    float cone = length(p.xz) - mix(r*1.25, 0.0, smoothstep(0.0, r, p.y));\n    cone = max(cone, abs(p.y-r/3.0)-r/3.0);\n    p.y -= r/2.25;\n    \n    float stand = length(p.xz) - r/6.0;\n    stand = max(stand, abs(p.y-h/2.0)-h/2.0);\n    \n    vec3 boxs = vec3(0,h/2.0,0);\n    boxs.x = mix(r/1.5, r/2.0, smoothstep(0.0, h, p.y));\n    boxs.z = boxs.x;\n    float box = bBox(p-vec3(0,h/2.0-0.1,0), boxs, 0.05);\n    \n    vec3 xp = p;\n    float c = pModPolar(xp.xz, 4.0);\n    xp.x -= boxs.x;\n    xp.y -= r/2.0 + 0.05;\n    xp = abs(xp);\n    float xsdf = max(xp.z-abs(xp.y)-0.05, -(xp.z-xp.y)-0.05);\n    xsdf = max(xsdf, max(xp.y-0.5, xp.x-EPSILON));\n    \n    float sgn = max((xp.x-EPSILON*10.0), abs(p.y-h/1.5)-h/6.0);\n    sgn = max(-sgn, max((xp.x-EPSILON*10.0), abs(p.y-h/1.5)-h/8.0)-0.05);\n    \n    \n    bd.x = min(bd.x, stand);\n    bd = mind(bd, vec2(length(p-vec3(0,h+r/2.0,0))-r/1.8, M_WATER));\n    cone = min(cone, box);\n    cone = min(cone, xsdf);\n    bd = mind(bd, vec2(cone, T_STONE));\n    bd = mind(bd, vec2(sgn, T_SIGN));\n    \n    return bd;\n}\n\n\n\n\n\n\nvec2 tower(vec3 p, float scale)\n{\n    float h = 5.0;\n    float r = 1.0;\n    float rt = r/1.5;\n    p /= scale;\n    p.y -= h;\n    \n    //main body\n    vec2 bd = vec2(cone(p, h, r, rt),T_WHITE);\n    \n    //windows\n    vec3 wnp = p;\n    float wnc = 1.0;\n    float wnh = r*0.2;\n    float wnw = wnh/2.0;\n    float c = pModPolar(wnp.xz, 4.0);\n    wnp.y -= h/2.0;\n    c = pModInterval1(wnp.y, (h*wnh*2.5), -2.0, 0.0);\n    wnp.y -= h*wnh;\n    float wn = cube(wnp, vec3(r*2.0, wnh, wnw));\n    float frame = max(-wn, cube(wnp, vec3(rt+wnw*2.0, wnh*1.5, wnw*1.5)));\n    \n    //arc\n    vec3 arcp = p;\n    float arcw = r/10.0;\n    float arcr = arcw*(h/2.0);\n    c = pModPolar(arcp.xz, 10.0);\n    arcp.y -= h - arcr*4.5;\n    arcp.y /= 3.0;\n    arcp.x -= rt+arcr;\n    float arc = max(\n        -(length(arcp+vec3(-arcr,arcr,0))-(arcr*2.25)), \n        cube(arcp, vec3(arcr,arcr*1.5,arcw))\n    );\n    \n    //top body\n    vec3 bd2p = p;\n    bd2p.y -= h;\n    float bd2r = rt+arcr*2.0;\n    vec2 bd2 = vec2(cyl(bd2p, h/40.0, bd2r), T_STONE);\n    \n    //bars\n    vec3 barp = bd2p;\n    c = pModPolar(barp.xz, 30.0);\n    barp.x -= bd2r;\n    float bar = cyl(barp-vec3(0,wnh*1.25,0), wnh*1.25, rt/80.0);\n    vec3 bar2p = bd2p;\n    bar2p.y -= (wnh*2.5)/1.5;\n    c = pModInterval1(bar2p.y, (wnh*2.5)/4.0, 0.0, 1.0);\n    float bar2 = torus(bar2p, vec2(bd2r,rt/80.0));\n    \n    //house\n    vec3 hsp = bd2p;\n    float hsph = wnh*2.5;\n    float hspr = bd2r/2.0;\n    hsp.y -= hsph/1.8;\n    vec2 hs = vec2(octagon(hsp, hsph/2.0, hspr), T_STONE);\n    c = pModPolar(hsp.xz, 8.0);\n    hsp.x -= hspr*0.95;\n    hsp.y += hsph/2.0;\n    float hbar = cyl(hsp, hsph*2.0, hspr/10.0);\n    vec3 rfp = bd2p;\n    rfp.y -= hsph*1.8;\n    float roof = max(length(rfp)-hspr*1.2, -cube(rfp+vec3(0,hsph*1.25,0), vec3(hspr*1.3)));\n    rfp.y -= hspr*1.2;\n    roof = minr(roof, cyl(rfp, h/10.0, hspr/20.0), hspr/2.0);\n    \n    \n    //comp\n    float modpy = p.y, red = pMod1(p.y, 1.0);\n    bd.y = mod(red,2.0) == 0.0 ? float(T_STONE) : float(T_WHITE);\n    \n    bd = max(bd, -wn);\n    bd = mind(bd, vec2(frame, T_WINDOW));\n    bd = minr(bd, vec2(arc, T_STONE), arcr/2.0);\n    bd2.x = min(bd2.x, min(bar, bar2));\n    bd2 = mind(bd2, mind(hs, mind(vec2(hbar,T_WHITE), vec2(roof,T_STONE))));\n    bd = mind(bd, bd2);\n    \n    bd.x *= scale;\n    return bd;\n}\n\n\n\n\n\nvec4 water(vec3 p, float depth){\n    p *= 2.0;\n    return vec4(p.y+getwave(p)*remap(depth,0.0,MAX_DIST,3.0,0.0), 0,0,M_WATER);\n}\nvec4 solids(vec3 p){\n    vec3 ftpos = vec3(-20.0,0.25,35.0);\n    vec3 ftp = p+ftpos;\n    float c = pModInterval1(ftp.z, 12.0, 0.0, 3.0);\n    ftp.x += c * (mod(c,2.0)==1.0 ? 5.0 : -5.0);\n    ftp = getfloating(ftp, c*2.0, 2.0);\n    vec2 ft = floatingThing(ftp*1.8);\n    \n    p *= 2.0;\n    p.x -= 80.0;\n    vec2 t = tower(p, 3.5);\n    t.x /= 2.;\n    t = mind(t, ft);\n    p.y += 3.0;\n    float terrain = max(p.y-pow(fbm(p.xz/3.0,2),0.5)*10.0-0.1, length(p.xz)-30.0)/2.;\n    return mind(vec4(t.x,0,0,t.y), vec4(terrain, 0,1,M_ROCK));\n}\n\n\nvec4 scene(vec3 p, float depth)\n{\n    vec4 d = vec4(1e10);\n    \n    d = mind(d, water(p, depth));\n    d = mind(d, solids(p));\n    \n    return d;\n}\n\n\n\n\n\n\n\nvec4 makeSolids(vec3 eye, vec3 dir, int steps, float maxdist)\n{\n    float depth = 0.0;\n    vec4 info = vec4(0.0);\n    float stepsf = float(steps);\n    for (int i=0; i<steps && depth<maxdist; i++){\n        vec3 p = eye + depth * dir;\n        info = solids(p);\n        if (abs(info.x) < EPSILON * depth)break;\n        depth += info.x * remap(float(i),0.0,stepsf,0.5,1.0);\n    }\n    return vec4(depth >= maxdist ? MAX_DIST : depth, info.yzw);\n}\n\nvec4 makeWater(vec3 eye, vec3 dir, int steps, float maxdist)\n{\n    float depth = 0.0;\n    vec4 info = vec4(0.0);\n    for (int i=0; i<steps && depth<maxdist; i++){\n        vec3 p = eye + depth * dir;\n        info = water(p, depth);\n        if (abs(info.x) < EPSILON * depth)break;\n        depth += info.x * remap(max(0.0,depth),0.0,maxdist,1.0,0.5);\n    }\n    return vec4(depth >= maxdist ? MAX_DIST : depth, info.yzw);\n}\n\n\n\nfloat shadow(vec3 eye, vec3 dir, float maxdist) {\n    float res = 1.0;\n    float depth = 0.0;\n        \n    for( int i=0; i<32 && depth<maxdist; i++ ){\n     \tvec3 p = eye + dir * depth;\n        float h = solids(p).x;\n        if (h < 0.0){ return 0.0; }\n        \n        float y = h*h/(2.0*1e10);\n        float d = sqrt(h*h-y*y);\n        res = min( res, 10.0*d/max(0.0,depth-y) );\n        \n        depth += h;\n    }\n\n    return res;\n}\n\n\nvec3 normal(vec3 p, float depth)\n{\n \tvec3 P = vec3(-4, 4, 0) * 0.01;\n \treturn normalize(\n        scene(p+P.xyy, depth).x * \n        P.xyy + scene(p+P.yxy, depth).x * \n        P.yxy + scene(p+P.yyx, depth).x * \n        P.yyx + scene(p+P.xxx, depth).x * \n        P.xxx\n    );\n}\n\n\n\n\n//alro's stars: https://www.shadertoy.com/view/ttScDc\nconst float flickerSpeed = 5.0;\nfloat getGlow(float dist, float radius, float intensity){\n    dist = max(dist, 1e-7);\n\treturn pow(radius/dist, intensity);\t\n}\nfloat getStars(vec3 rayDir){\n\n    float scale = 60.0;\n    vec3 id = floor(rayDir * scale);\n    float d = length(scale * rayDir - (id + 0.5));\n\n    float stars = 0.0;\n    \n    vec2 uv = id.xy+vec2(37.0,17.0)*id.z;\n    vec3 rnd = getHashTex(uv+0.5).yxz;\n    \n    if(rnd.x > 0.92 && d < 0.15){\n        stars = getGlow(d, 0.075, 2.5 - 2.0 * sin(rnd.y * flickerSpeed * iTime));\n    }\n    return stars;\n}\n///\n\n\n\n\n\nvoid getSkyComp(vec3 dir, vec3 sundir, out vec3 suncolor, out vec3 sunhalo, out vec3 sky){\n    sky = vec3(0.2,0.4,0.8) * max(0.2,sundir.y);\n    suncolor = saturate(mix(vec3(0.99,0.3,0.1),vec3(1.0,1.0,0.8),sundir.y));\n    sunhalo = mix(max(0.0,(1.0-max(0.0,(1.0-sundir.y*3.0))*dir.y*4.0)),0.0,sundir.y) * saturate(pow(0.5*(dot(sundir,normalize(dir)))+0.5,(8.0-sundir.y*5.0))) * suncolor;\n    return;\n}\n\n\n\n\nvec3 getBackground(vec3 dir, vec3 sundir, vec3 suncolor, vec3 sunhalo, vec3 sky, bool showstars)\n{\n    vec3 bg = sky;\n    bg += saturate(2.0*pow(saturate(dot(sundir,normalize(dir))),800.0)) * (suncolor+vec3(0.4));\n    bg += pow(sunhalo, vec3(2.0));\n    bg += pow(1.0-dir.y, 2.0)*suncolor*0.5;\n    \n    vec3 color;\n    \n    if (showstars){\n        float stars = getStars(dir*2.0);\n        vec3 starsfar = getStars(dir*4.0)*(sunhalo+sky);\n        float n = getFogfbm(dir*2.5);\n        vec3 starfog = pow(n*2.0-1.0,2.0)*mix(vec3(0.492,0.152,0.925)*0.5,sunhalo+sky,n)*0.5;\n        \n        //I had to remove the stars at the reflections because of a problem the gaussian blur has\n        color += stars+starsfar+starfog;\n    }\n    \n    color += pow(bg*1.5, vec3(3.0));\n    return color;\n}\n\n\n\n\nvoid compose(\n    inout vec3 eye, inout vec3 dir, vec4 info, vec3 P, vec3 N, Material mat, \n    inout vec4 incomp, out vec3 suncolor, out vec3 sunhalo, out vec3 sky, int b\n){\n    vec3 sundir = SUN_DIR;\n    getSkyComp(dir, sundir, suncolor, sunhalo, sky);\n    \n    if (info.x >= MAX_DIST){\n        incomp.xyz += getBackground(dir, sundir, suncolor, sunhalo, sky, b<1)*incomp.w;\n        return;\n    }\n    \n    vec3 color = mat.color;\n    int id = int(info.w);\n    \n    if (id != M_WATER){\n        float df = pow(saturate(dot(N, sundir)), 0.5)*2.0;\n        if (df >= 0.0){ df *= shadow(P, sundir, MAX_DIST/2.0); }\n        color *= (df*mat.diffuse+0.2);\n    }\n    color += pow(max(0.0, dot(N, normalize(sundir+normalize(eye-P)))), 64.0) * mat.specular;\n    color *= suncolor+sky;\n    \n    float fresnel = pow(saturate(1.0 - dot(eye - P, N)), 3.0);\n    mat.reflective = min(mat.reflective+fresnel*0.5, 1.0);\n    if (id != T_STONE){ color += (color*3.0+suncolor+sky) * fresnel; }\n    \n    //fog\n    float startDist = MAX_DIST/1.2;\n    float fog = 1.0 - exp(-(info.x-1.0) * (1.0/startDist));\n    color = mix(color, sunhalo+sky, pow(fog,2.0));\n    \n    color *= (1.0 - mat.reflective);\n    incomp.xyz += (color) * incomp.w;\n    incomp.w *= mat.reflective;\n    \n    eye = P;\n    dir = normalize(reflect(dir, normalize(N)));\n}\n\n\nvec3 makePixel(vec3 eye, vec3 dir, out float depth)\n{\n    vec4 incomp = vec4(vec3(0), 1.0);\n    for (int b=0; b<MAX_BOUNCES && incomp.w>0.0002; b++)\n    {\n        vec4 info = makeWater(eye, dir, 128, MAX_DIST);\n        info = mind(info, makeSolids(eye, dir, 64, MAX_DIST/1.5));\n        \n        vec3 P = eye + info.x * dir;\n        vec3 N = normal(P, info.x);\n        \n        if (b == 0){ depth = info.x; }\n        \n        Material mat;\n        mat.color = vec3(0.5);\n        mat.diffuse = 1.0;\n        mat.specular = 0.0;\n        mat.reflective = 0.05;\n        \n        switch(int(info.w)){\n            case M_WATER:\n                mat.reflective = 0.7;\n                mat.color = vec3(0.05,0.1,0.2)*0.1;\n                mat.diffuse = 0.1;\n                mat.specular = 1.0;\n            break;\n            \n            case M_ROCK:\n                mat.color = vec3(0.1);\n                mat.reflective = info.z>0.0 ? 0.0 : 0.1;\n            break;\n            \n            case T_WHITE:\n                mat.color = vec3(0.796,0.255,0.329)+getpebbles(P*100.0,N);\n                mat.color = min(mat.color+0.2,1.0);\n                mat.reflective = 0.1;\n            break;\n            case T_WINDOW:\n                mat.color = vec3(0.1);\n            break;\n            case T_STONE:\n                mat.color = vec3(0.796,0.255,0.329)*triplanarMap(iChannel2,P,N,1.0);\n                N = triplanarNormal(iChannel2,P,N,1.0,1.0);\n                mat.reflective = 0.01;\n            break;\n            case T_SIGN:\n                mat.color = vec3(0.796,0.255,0.329)*triplanarMap(iChannel2,P,N,1.0);\n                N = triplanarNormal(iChannel2,P,N,1.0,1.0);\n                mat.reflective = 0.1;\n            break;\n        }\n        \n        if (b == MAX_BOUNCES-1) { mat.reflective = 0.0; }\n        \n        vec3 suncolor, sunhalo, sky;\n        compose(\n            eye, dir, info, P, N, mat, \n            incomp, suncolor, sunhalo, sky, b\n        );\n        \n    }\n    \n    return incomp.xyz;\n}\n\n\n\n\n\n\n\nconst float fov = 75.0;\nconst float marginSize = 0.1;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(vec3(0.0),1.0);\n    //I need as much speed as I can get!\n    if(UV.y < marginSize || UV.y > 1.0-marginSize){ return; }\n    //why is it still slow though??\n    \n    vec3 eye = vec3(10,1,-50);\n    vec3 lookAt = vec3(50,25,100);\n    //eye = vec3(0,10,0);\n    //lookAt = eye - rotateCamera(20.0, iMouse.xy/iResolution.xy, iMouse);\n    \n    mat4 viewToWorld = viewMatrix(eye, lookAt, vec3(0.0, 1.0, 0.0));\n    \n    vec3 color;\n    float depth;\n    \n    #ifdef BRUTE_FORCE_AA\n    for (float y = 0.0; y < FORCED_AA_SIZE; y++){\n        for (float x = 0.0; x < FORCED_AA_SIZE; x++){\n            vec3 dir = rayDirection(fov, iResolution.xy, fragCoord+vec2(x, y)/FORCED_AA_SIZE);\n            vec3 worldDir = (viewToWorld * vec4(dir, 0.0)).xyz;\n            \n            worldDir = getfloating(worldDir, 0.0, 0.3);\n            color += makePixel(eye, worldDir, depth);\n        }\n    }\n    color /= FORCED_AA_SIZE*FORCED_AA_SIZE;\n    #else\n    vec3 dir = rayDirection(fov, iResolution.xy, fragCoord);\n    vec3 worldDir = (viewToWorld * vec4(dir, 0.0)).xyz;\n    worldDir = getfloating(worldDir, 0.0, 0.3);\n    color += makePixel(eye, worldDir, depth);\n    #endif\n    \n    fragColor = vec4(saturate(color),depth/MAX_DIST);\n}","name":"Buffer A","description":"","type":"buffer"}]}