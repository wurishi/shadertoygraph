{"ver":"0.1","info":{"id":"fdXXDH","date":"1618533557","viewed":513,"name":"Pointless Structures","username":"Kali","description":"A shader I kept private until now because the fractal structures in the 4k intro Mesh Odyssey are based on this. https://www.shadertoy.com/view/NdB3zK","likes":44,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float det=.0001;\nfloat maxdist=15.;\nvec3 ldir=vec3(0.5,1.,1.);\nvec3 pa;\nfloat gcol;\nfloat t, it, k;\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nmat2 rot(float a) {\n    a=radians(a);\n\tfloat s=sin(a),c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat sdBoundingBox( vec3 p, vec3 b, float e)\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return sqrt(min(min(dot2(max(vec3(p.x,q.y,q.z),0.0)),\n                      dot2(max(vec3(q.x,p.y,q.z),0.0))),\n                      dot2(max(vec3(q.x,q.y,p.z),0.0)))) \n         +min(0.0,min(min( max(p.x,max(q.y,q.z)),\n                           max(p.y,max(q.z,q.x))),\n                           max(p.z,max(q.x,q.y))));\n}\n\nfloat kset(vec3 p) {\n\tp=abs(fract(p*.5)-.5);\n    for (int i=0; i<6; i++) {\n    \tp=abs(p)/dot(p,p)-.8;\n    }\n    return length(p.xy);\n}\n\n\nfloat shape (vec3 p, float z) {\n    p.xz*=rot(smoothstep(.28,.3,abs(.5-fract(t*.1+floor(z*4.)*.005)))*90.);\n    float d=sdBoundingBox(p,vec3(1.,1.,2.),.07);\n    return d;\n}\n\nvec3 path(float t) {\n\treturn vec3(sin(t*.5),cos(t)*.5,t);\n}\n\nvec3 pathcam(float t) {\n\tvec3 p=path(t);\n    p.y+=smoothstep(0.,.5,abs(.5-fract(t*.05)))*3.;\n    return p;\n}\n\n\n\nfloat de(vec3 pos) {\n\tfloat tu=length(pos.xy-pathcam(pos.z).xy)-.1;\n    pos.y+=-1.;\n    pos.x-=.4;\n\tpos.xy-=path(pos.z).xy;\n    float z=pos.z;\n    pos=abs(4.-mod(pos,8.))-4.;\n    pa=pos;\n\tfloat sc=1.4, d=1000., der=1.;\n    vec3 p=pos,m=vec3(100.);\n    float o=1000.;\n    for (int i=0; i<7; i++) {\n        p.xy*=rot(90.);\n        p.xz=abs(p.xz);\n        p.y+=1.;\n        sc=1.7/clamp(dot(p,p),0.1,1.0);\n\t\tp=p*sc-vec3(2.,1.,3.);\n        p.y-=1.;\n        der*=sc;\n        float shp=shape(p,z)/der;\n        if (shp<d && i>1) {\n            d=shp;\n            it=float(i);\n        }\n        o=min(o,length(p));\n    }\n    d=min(d,length(p.xy)/der-.005);\n    gcol=step(fract(pos.z*.1+iTime*.2+p.z*.005+it*.25),.02)*10.+1.5;\n    d=max(d,-tu);\n    return d*.7;\n}\n\nvec3 march(vec3 from, vec3 dir) {\n\tvec3 p, col=vec3(0.);\n    float totdist=0.,d;\n    float g=0.,gg=0.;\n    for(int i=0; i<130; i++) {\n\t\tp=from+totdist*dir;\n        d=de(p);\n        det*=1.+totdist*.03;\n        if (d<det || totdist>maxdist) break;\n        totdist+=d*(1.+hash12(dir.xy*1000.)*.3);\n        g+=exp(-.03*totdist)*kset(p)*gcol;\n    }\n    if (d<.1) {\n        col=gcol*vec3(.05);\n    }\n    col=mix(vec3(0.),col,exp(-.2*totdist));\n    col=pow(col,vec3(1.3))*1.5;\n    return col+pow(g*.012,1.5)*vec3(1.,.25,0.);\n}\n\nmat3 lookat(vec3 dir, vec3 up) {\n\tdir=normalize(dir); vec3 r=normalize(cross(dir,up));\n    return mat3(r,cross(dir,r),dir);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tt=iTime*.5;\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    vec3 from = pathcam(t);\n    vec3 to = pathcam(t+2.);\n    vec3 adv = normalize(to-from);\n    vec3 dir = normalize(vec3(uv,1.));\n    dir*=lookat(adv,vec3(0.,1.,0.));\n    dir.xy*=rot(45.);\n    dir.yz*=rot(-20.);\n    vec3 col = march(from, dir)*max(mod(fragCoord.x,3.),mod(fragCoord.y,3.))*.7;\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}