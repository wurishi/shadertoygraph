{"ver":"0.1","info":{"id":"stdfDB","date":"1663628565","viewed":99,"name":"truchet labyrinth sdf","username":"jt","description":"SDF of a labyrinth consisting from diagonal walls (direction determined by hashing tile-number).\nSee also [url=https://www.shadertoy.com/view/Nl3BDj]truchet labyrinth 3d[/url].","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["sdf","truchet","labyrinth"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/stdfDB truchet labyrinth sdf by jt\n// SDF of a labyrinth consisting from diagonal walls (direction determined by hashing tile-number).\n\n// See comments in source code for contributions from other shaders.\n\n// https://www.shadertoy.com/view/WttXWX \"Best\" Integer Hash by FabriceNeyret2\n// implementing Chris Wellons https://nullprogram.com/blog/2018/07/31/\nuint triple32(uint x)\n{\n    x ^= x >> 17;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15;\n    x *= 0x31848babU;\n    x ^= x >> 14;\n    return x;\n}\n\nfloat hash(uint x)\n{\n    return float(triple32(x)) / float(0xffffffffU);\n}\n\nuint hashi(uvec2 v)\n{\n    return triple32(v.x + triple32(v.y));\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdOrientedBox( in vec2 p, in vec2 a, in vec2 b, float th )\n{\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = (p-(a+b)*0.5);\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n}\n\n// Create infinite copies of an object -  https://iquilezles.org/articles/distfunctions\nvec2 opRep(in vec2 p)\n{\n    return p - 2.0*round(p/2.0);\n    //return fract(p) - 1.0;\n}\n\nivec2 opRepIdx(in vec2 p)\n{\n    return ivec2(floor((p + 1.0) / 2.0));\n}\n\nuint opRepIdxRnd(in vec2 p)\n{\n    //return hashi(uvec2(opRepIdx(p)));\n    return hashi(triple32(uint(iFrame/100)) + uvec2(opRepIdx(p)));\n}\n\nbool opRepIdxRndBool(in vec2 p)\n{\n    return (opRepIdxRnd(p) & 1u) != 0u;\n}\n\nfloat labyrinth(in vec2 p)\n{\n    vec2 r = opRep(p); // coordinates inside tile\n    //float d = 1.0 / 0.0;\n    float d = 10000.0; // maximal distance\n\n    float th = 0.1; // wall thickness\n    float l = 1.0 + th / 4.0; // wall length\n    mat2 m = mat2(vec2(1,1),vec2(-1,1)); // 45 degree rotation\n    \n    // naive method: traverse 3x3 tiles\n    //for(int v = -1; v <= +1; v++)\n    //{\n    //    for(int u = -1; u <= +1; u++)\n    //    {\n    // kastorp's optimization: traverse only 2 tiles (instead of 3),\n    // chosen depending on where in the tile the current point is located.\n    ivec2 oo = -ivec2(step(vec2(0), r));\n    for(int v = oo.y; v <= oo.y+1; v++)\n    {\n        for(int u = oo.x; u <= oo.x+1; u++)\n        {\n            vec2 o = 2.0 * vec2(u, v); // offset\n            if(opRepIdxRndBool(p - o))\n                //d = min(d, sdOrientedBox(r + o, vec2(-l,+l), vec2(+l,-l), th));\n                d = min(d, sdBox((r + o)*m, vec2(th/sqrt(2.0),2.0+th/sqrt(2.0)))/sqrt(2.0));\n            else\n                //d = min(d, sdOrientedBox(r + o, vec2(-l,-l), vec2(+l,+l), th));\n                d = min(d, sdBox(m*(r + o), vec2(th/sqrt(2.0),2.0+th/sqrt(2.0)))/sqrt(2.0));\n                \n        }\n    }\n\n    return d;\n}\n\nfloat map(in vec2 p)\n{\n    return labyrinth(p * 6.0) / 6.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec2 m = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n\n    float d = map(p);\n    \n    vec3 col = vec3(1.0) - sign(d) * vec3(0.1, 0.4, 0.7);\n\tcol *= 1.0 - exp(-24.0 * abs(d));\n\tcol *= 0.8 + 0.2 * cos(240.0*d);\n\tcol = mix(col, vec3(1.0), 1.0 - smoothstep(0.0, 0.01, abs(d)));\n\n    if(iMouse.z > 0.001)\n    {\n        d = map(m);\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0 - smoothstep(0.0, 0.005, abs(length(p - m) - abs(d)) - 0.0025));\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0 - smoothstep(0.0, 0.005, length(p - m) - 0.015));\n    }\n\n\tfragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}