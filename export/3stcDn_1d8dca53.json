{"ver":"0.1","info":{"id":"3stcDn","date":"1600759677","viewed":274,"name":"Click and Drag for Ripples","username":"resontone","description":"Interactive Water (interactivity may not work on mobile)\nThis effect uses a bed of springs, one for each pixel, resulting in a displacement map that is then fed into iChannel0. The RGBA values represent pos, v, a, and mass.","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["interactive","water"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //PARAMETERS\n    \n    //0. = just the velocity of the springs, 1. = just the position of springs\n    float mix_amount_x = 1.;\n    float mix_amount_y = 0.25;\n    \n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    //x = position, y = velocity, z = acceleration. A mix of position and velocity seems to work well\n    float displacement_x = mix(texture(iChannel0, uv).y,  texture(iChannel0, uv).x, mix_amount_x);\n    float displacement_y = mix(texture(iChannel0, uv).y,  texture(iChannel0, uv).x, mix_amount_y);\n    \n    \n    vec4 col = texture(iChannel1, uv+vec2(displacement_x*0.175,displacement_y*0.175));\n    \n    vec4 highlights = vec4(vec3(clamp((displacement_y), 0., 1.)), 0.);\n    \n    \n    // Output to screen\n    fragColor = mix(col + highlights*0.25, vec4(1.), 0.5*(1.-clamp(0.5+0.5*displacement_y, 0., 1.)));\n    \n    \n    //uncomment to show displacement map without texture\n    //fragColor = 0.5+0.5*texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//TODO: Optimise full screen performance by rendering displacement map to a smaller internal buffer and interpolating\nconst float TWO_PI = 6.28318530718;\nconst float MIN_SECONDS_PER_FRAME = 0.0166666; //hack to deal with instability on large timesteps\n\n\n\n//Convenience function for sampling pixel colour\n//PixelCoord = from 0. to 1.\nvec4 cellGLES2( in vec2 pixelCoord)\n{\n    // do wrapping\n    ivec2 r = ivec2(iResolution.x, iResolution.y);\n    \n    if(pixelCoord.x > 1. || pixelCoord.y > 1. || pixelCoord.x < 0. || pixelCoord.y < 0.)\n    {\n     \treturn(vec4(0.));   \n    }\n    \n    pixelCoord = fract(pixelCoord);\n    \n    // fetch texel\n    return (texture(iChannel0, pixelCoord));\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 px = ivec2( fragCoord );\n    \n    vec2 uv_screen = fragCoord/iResolution.xy;\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    vec2 pixelSize = 1./iResolution.xy;\n    \n    \n    //------------------------------------------------------------------------------\n    //PARAMETERS\n    //------------------------------------------------------------------------------\n    //SPRING PROPERTIES\n    \n    //Controls the amount of ripples created when force is applied to the surface\n    //At k1=0., only the first ripple will be created. \n    float k1 = 20.;\n    \n    //EDITABLE\n    float viscousity = 0.0; //0. to 1. increase for more syrupy fluid\n    \n    \n    //neighbour position\n    float k2 = mix(2000., 0., viscousity); \n    //neighbour velocity - \n    float k3 = mix(0.5, 40.,viscousity); //40. seems to be the upper limit for stability\n\n    //OTHER PARAMETERS\n    float friction_loss = 0.12; //per second\n    \n    //mass set to 1. for optimisation\n    //float mass = 0.5; //below 0.25 it becomes unstable. Increasing this value slows down the simulation\n    \n    \n   \t//------------------------------------------------------------------------------\n    //stability is always a risk with bigger timesteps\n    \n    //for stability, we limit the size of the time step\n    //TODO: Make frame rate independent with friction method modifications\n    float timeDelta = MIN_SECONDS_PER_FRAME; \n    //iTimeDelta = timeDelta\n\n\n\t//------------------------------------------------------------------------------\n    //INITIAL PHYSICS PROPERTIES (position, velocity, acceleration)\n    //These are stored as rgb values in the displacement map\n    //------------------------------------------------------------------------------\n    vec4 currentCell = cellGLES2( uv_screen);\n    float position = currentCell.x;\n    float velocity = currentCell.y;\n    float acceleration = currentCell.z;\n\n\t//------------------------------------------------------------------------------\n    //Calculating the forces acting on the particle/pixel\n    float force = 0.;\n\n    //MOUSE PRESS FORCE\n    if(length(fragCoord.xy - iMouse.xy) < 4.)\n    {\n        if(iMouse.z > 0.)\n        {\n            force = -200.;\n        }\n    }\n    \n    if(iTime < 1.)\n    {\n        if(length(uv+0.5 - mod(iTime*40., 1.)*vec2(1.,0.25)) < 0.015)\n        {\n            force -= 100.;\n        }\n    }\n    \n    float mass = 0.5;\n    \n    \n    //SELF\n\t//Self-correcting spring that pulls the particle back to 0.\n    force += k1*(-position);\n\n\t//NEIGHBOURS\n\t//Self-correcting spring that pulls the particle back to 0.\n    //The laplace weights\n    float laplace_diag_weight = 0.1;\n    float laplace_edge_weight = 0.2;\n    float laplace_center_weight = 1.2;//4.*laplace_diag_weight + 4.*laplace_edge_weight;\n\n\n    \n    \n    //Laplace function is a weighted average of the neighbours minus a weighted version of the current cell\n    vec3 weightedNeigbourAverage;\n    \n     weightedNeigbourAverage = \n        laplace_edge_weight*(cellGLES2(uv_screen + vec2(0.,-1.)*pixelSize)\n                             + cellGLES2(uv_screen + vec2(0.,1.)*pixelSize)\n                             + cellGLES2(uv_screen + vec2(-1.,0.)*pixelSize)\n                             + cellGLES2(uv_screen + vec2(1.,0.)*pixelSize)).xyz\n        + laplace_diag_weight*(cellGLES2(uv_screen + vec2(1.,-1.)*pixelSize)\n                               + cellGLES2(uv_screen + vec2(1.,1.)*pixelSize)\n                               + cellGLES2(uv_screen + vec2(-1.,1.)*pixelSize)\n                               + cellGLES2(uv_screen + vec2(-1.,-1.)*pixelSize)).xyz;\n    \n    \n\n    //Forces acting on the current particle/pixel\n    vec3 laplace = weightedNeigbourAverage - laplace_center_weight*currentCell.xyz;\n\n\t//Force from the relative position\n    force += k2*laplace.x;\n\n    //Force from the momentum (p=mv) of each neighbour\n    //This might be incorrect, but it works well enough\n    force += mass*k3*laplace.y;\n\n    \n\n\t//------------------------------------------------------------------------------\n    //FINAL PHYSICS CALCULATIONS\n    acceleration = force/mass;\n\n    velocity += timeDelta*acceleration;\n\t//velocity *= friction_hack;\n\t\n    velocity -= velocity*friction_loss*timeDelta;\n    \n\n    position += timeDelta*velocity;\n    position = clamp(position, -1., 1.); //bounding box to catch unstable waves\n\n    \n\t//------------------------------------------------------------------------------\n    fragColor = vec4(position, velocity, acceleration, 1.);\n}","name":"Buffer A","description":"","type":"buffer"}]}