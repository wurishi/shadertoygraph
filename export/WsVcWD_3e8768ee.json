{"ver":"0.1","info":{"id":"WsVcWD","date":"1602871189","viewed":89,"name":"UPBP 0.3 - Ray Bounce","username":"rory618","description":"https://cs.dartmouth.edu/~wjarosz/publications/krivanek14upbp.html","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["3d","lighttransport"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float lineDist(vec2 z, vec2 a, vec2 b){\n    \n    z -= a; b -= a;                        // go to A referential\n    float q = dot(z, b) / dot(b, b) ;      // projection of P on line AB: normalized ordinate\n    b *= clamp(q, 0., 1.);                 // point on segment AB closest to P     \n    return length( z - b);\n}\n\nvec2 project(vec3 right, vec3 forward, vec3 up, vec3 coord, vec3 r0){\n    vec3 delta = coord-r0;\n    vec3 dir = (delta);\n    float f = dot(dir,forward);\n    float r = dot(dir,right);\n    float u = dot(dir,up);\n    return vec2(r/f,u/f);\n    \n}\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    float sf = iResolution.y*1.8;\n    \n    vec2 uv = (I*2.-iResolution.xy)/sf;\n    vec2 m = iMouse.z>0.?(iMouse.xy*2.-iResolution.xy)/sf:.3*sin(iTime*vec2(.13,.14));\n    \n    \n    vec3 r0 = vec3(17,1,8);\n    vec3 forward = normalize(vec3(3,17,3)-r0);\n    vec3 right = normalize(cross(forward,vec3(0,0,1)));\n    vec3 up = cross(right,forward);\n    vec3 rd = normalize(forward + right*uv.x + up*uv.y);\n    \n    vec3 rd_m = normalize(forward + right*m.x + up*m.y);\n    \n    surface_intersection i = ray_scene(r0, rd);\n    O = (i.type==1)?vec4(1):vec4(i.normal*.5+.5,1);\n    \n    surface_intersection m_hit = ray_scene(r0, rd_m);\n    vec2 m_hit_proj = project(right,forward,up,m_hit.coord,r0);\n    \n    if(abs(length(m_hit_proj-uv)-10./sf)<2./sf) O += 1.;\n    \n    for(int b = 0; b < 10; b++){\n        \n        vec3 rd_m_next = reflect(rd_m, m_hit.normal);\n        surface_intersection m_hit_next = ray_scene(m_hit.coord + rd_m_next*1e-4, rd_m_next);\n        \n        \n    \tvec2 m_hit_proj_next = project(right,forward,up,m_hit.coord,r0);\n        \n        O = mix(vec4(1,0,0,1),O,clamp(lineDist(uv,m_hit_proj_next,m_hit_proj)*sf/2.,0.,1.));\n        \n        m_hit = m_hit_next;\n        rd_m = rd_m_next;\n        m_hit_proj = m_hit_proj_next;\n    \tif(abs(length(m_hit_proj-uv)-10./sf)<2./sf) O = vec4(0,1,0,1);\n    }\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"struct surface_intersection {\n    vec3 coord;\n    vec3 normal;\n    float d;\n    int type;\n};\n\nstruct AABB {\n    vec3 a;\n    vec3 b;\n};\n    \nAABB[] walls = AABB[] (\n\tAABB(vec3(0,0,0),vec3(20,20,12)),\n\tAABB(vec3(0,3,0),vec3(3,20,12)),\n\tAABB(vec3(17,3,0),vec3(20,20,12)),\n\tAABB(vec3(8,10,0),vec3(10,12,12)),\n\tAABB(vec3(3,19,0),vec3(6,20,12)),\n\tAABB(vec3(9,19,0),vec3(11,20,12)),\n\tAABB(vec3(14,19,0),vec3(17,20,12)),\n\tAABB(vec3(6,19.4,0),vec3(9,20,3)),\n\tAABB(vec3(6,19.4,9),vec3(9,20,12)),\n\tAABB(vec3(11,19.4,0),vec3(14,20,3)),\n\tAABB(vec3(11,19.4,9),vec3(14,20,12))\n);\n\nAABB[] sunlights = AABB[] (\n\tAABB(vec3(6,19.9,3),vec3(9,20,9)),\n\tAABB(vec3(11,19.9,3),vec3(14,20,9))\n);\n\nAABB[] lamplights = AABB[] (\n\tAABB(vec3(9,2,11.9),vec3(11,4,12))\n);\n\n    \nbool inAABB(AABB box, vec3 p){\n    return (p.x>box.a.x && p.y>box.a.y && p.z>box.a.z && \n            p.x<box.b.x && p.y<box.b.y && p.z<box.b.z);\n}\n\nsurface_intersection ray_AABB(vec3 r0, vec3 rd, AABB box){\n    \n    vec3 tMin = (box.a - r0) / rd;\n    vec3 tMax = (box.b - r0) / rd;\n    vec3 t1 = min(tMin, tMax);\n    vec3 t2 = max(tMin, tMax);\n    float tNear = max(max(t1.x, t1.y), t1.z);\n    float tFar = min(min(t2.x, t2.y), t2.z);\n    \n    vec3 nNear = vec3(equal(t1,vec3(tNear)));\n    vec3 nFar = vec3(equal(t2,vec3(tFar)));\n    \n    \n    if(inAABB(box,r0)){\n    \treturn surface_intersection(r0 + rd*length(rd*tFar), -nFar*sign(rd),length(rd*tFar),0);\n    } else{\n    \tif(tNear>tFar || tNear < 1e-5){\n        \treturn surface_intersection(r0,vec3(0),1e8,0);\n    \t} else{\n            return surface_intersection(r0 + rd*length(rd*tNear),-nNear*sign(rd),length(rd*tNear),0);\n        }\n    }\n}\n\nsurface_intersection ray_scene(vec3 r0, vec3 rd){\n    surface_intersection intersect_final = ray_AABB(r0,rd,walls[0]);\n    for(int i = 1; i < walls.length(); i++){\n        surface_intersection intersect = ray_AABB(r0,rd,walls[i]);\n        if(intersect.d<intersect_final.d){\n            intersect_final = intersect;\n        }\n    }\n    for(int i = 0; i < sunlights.length(); i++){\n        surface_intersection intersect = ray_AABB(r0,rd,sunlights[i]);\n        if(intersect.d<intersect_final.d){\n            intersect_final = intersect;\n            intersect_final.type = 1;\n        }\n    }\n    for(int i = 0; i < lamplights.length(); i++){\n        surface_intersection intersect = ray_AABB(r0,rd,lamplights[i]);\n        if(intersect.d<intersect_final.d){\n            intersect_final = intersect;\n            intersect_final.type = 2;\n        }\n    }\n    return intersect_final;\n}","name":"Common","description":"","type":"common"}]}