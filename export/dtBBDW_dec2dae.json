{"ver":"0.1","info":{"id":"dtBBDW","date":"1694204552","viewed":20,"name":"P1 Computer Graphics","username":"isaac_d","description":"This is my shader for Shader Assignment 1. It contains a combination of primitive shapes that rotate on the x-axis. The primitives also have an animated pattern on their surface, and there are animated patterns in the background and foreground.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["box"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//From https://iquilezles.org/articles/distfunctions/\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n//From https://iquilezles.org/articles/distfunctions/\nfloat sdCone( vec3 p, vec2 c, float h )\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\n\n/**/\n//Checker pattern from class\nvec3 checker(vec2 Pos) \n{\n    Pos = floor(Pos);\n    return vec3(mod(Pos.x + mod(0.5 + Pos.y, 2.0), 2.0));\n}\n/**/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    /**/\n    //Matrix for x rotation\n    float s = sin(iTime);\n    float c = cos(iTime);\n    mat3 rotx = mat3(\n        1.0, 0.0, 0.0,\n        0.0, c, s,\n        0.0, -s, c\n    );\n    /**/\n    \n    /**\n    //Matrix for z rotation\n    mat3 rotz = mat3(\n        c, -s, 0.0,\n        s, c, 0.0,\n        0.0, 0.0, 1.0\n    );\n    /**/\n    \n    /**\n    //Matrix for y rotation\n    mat3 roty = mat3(\n    c, 0.0, s,\n    0.0, 1.0, 0.0,\n    -s, 0.0, c    \n    );\n    /**/\n\n\n    //Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    //Light\n    vec3 lightDir = vec3(0.0, 0.0, 1.0);\n    \n    //Box and cone color\n    vec3 boxCol = vec3(cos(iTime + fragCoord.x/50.0), cos(iTime + fragCoord.y/50.0), 0.8);//vec3(1.0, 0.0, 1.0);\n\n    //Time varying pixel color\n    //Background\n    vec3 col = checker(fragCoord.xy/30.0 + vec2(iTime));//vec3(0.8 * cos(iTime + fragCoord.x/30.0), 0.5, 0.7);//0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    //Create a ray\n    //Assume orthographic projection\n    vec3 rayPt = vec3(uv.xy,  0);\n    //\n    //\n    vec3 rayDir = vec3(0, 0, 1);\n    \n    //Ray parameter\n    float t = 0.0;\n    \n    //Define the object properties\n    vec3 boxDimensions = vec3 (0.1, 0.1, 0.1);\n    vec3 boxPos = vec3 (0.5, 0.5, 5.0);\n    \n    vec3 conePos = vec3 (0.5, 0.5, 5.0);\n    vec2 coneAngle = vec2 (2, 5);\n    float coneHeight = 0.4;\n    \n    //vec3 pyramidPos = vec3 (0.5, 0.5, 5.0);\n    //float pyramidHeight = 0.3;\n    \n    \n    //Calculate a point 5 units along the ray\n    for (int i = 0; i < 20; i++)\n    {\n        vec3 pos = rayPt + rayDir * t;\n        //Having multiple rays is useful for unpredictable surfaces.\n        //vec3 posdx = rayPtdx + rayDir * tdx;\n        //vec3 posdy = rayPtdy + rayDir * tdy;\n        \n        //Cone\n        //Subtract object position from ray position, and check if that point\n        //is in the box \n        float dist = min(sdBox(rotx * (pos - boxPos), boxDimensions), sdCone(rotx * (pos - conePos), coneAngle, coneHeight));\n        //float dist = min(sdBox(rotx * (pos - boxPos), boxDimensions), sdPyramid(rotx * (1.3 * (pos - pyramidPos)), pyramidHeight));\n        if(dist < 0.01)\n        {\n            col = boxCol *dot(-lightDir, normalize(pos - boxPos));\n            //col.z = -col.z;\n        }\n        \n        \n        //Cone\n        //Subtract object position from ray position, and check if that point\n        //is in the cone\n        /**\n        dist = sdCone(rotx * (pos - conePos), coneAngle, coneHeight);\n        if(dist < 0.000001)\n        {\n            col = coneCol*dot(-lightDir, normalize(pos - conePos));\n            col.z = -col.z;\n        }\n        /**/\n        \n        t = t + dist;\n        //tdx = tdx + distdx\n        //tdy = tdy + distdy\n    }\n    \n\n  \n    //Noise pattern over final image\n    col = mix(col, vec3(texture(iChannel0, uv.xy).rrr), cos(iTime) * 0.6);//max(col, -vec3(sin(iTime + fragCoord.x/50.0), 0.3, 0.4));\n    \n    // Output to screen\n\n    fragColor = vec4(col,1.0);\n    //fragColor = vec4(uv.x, uv.y, 0.8, 1.0);\n}","name":"Image","description":"","type":"image"}]}