{"ver":"0.1","info":{"id":"MXXfDM","date":"1728847737","viewed":169,"name":"Tetrahedral 3D Texture Filtering","username":"gehtsiegarnixan","description":"Comparison of vanilla, manual quadrilinear, and 2x barycentric filtering methods and performance testing.","likes":6,"published":3,"flags":0,"usePreview":0,"tags":["volume","texture","filtering","tetrahedron","barycentric","sample","trilinear","dodecahedron","bilinear","rhombic","tetra","quadrilinear"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The MIT License\n// Copyright © 2024 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nComparison of Texture Filtering Methods\n\nLeft: Vanilla quadrilinear filtering (16 samples)\nRight: Two tetrahedral filtering (8 samples)\n?: 4D Simplex is 5 samples and should be possible ...\n\nLower sampling may look odd up close but appears similar from a normal \ndistance.\n\nIn theory, fewer texel fetches should be faster, but in practice, they \nare not. This is likely due to GPU hardware optimizations for native \nfunctions, which manual functions do not leverage. This is evident in \nthe comparison between vanilla texture filtering and my manual version, \nwhich perform similarly but the manual version is much slower.\n\nThis shader has mouse controls and several settings in the global \nconstants below. Mouse.x controls the border, while Mouse.y controls \nthe camera height. You can also try the performance test for yourself.\n\nThe test measures frames per second (FPS) on Shadertoy. To ensure valid \nresults, we repeat the test function with varying values and accumulate \ntheir results into a final image.\n\nSteps:\n- Increase REPEAT until the FPS drops below your monitor's refresh rate \n    (likely between 60-144 fps).\n- Modify the TEST value to switch between test cases.\n- The highest FPS indicates the fastest implementation.\n- Celebrate your contribution to SCIENCE!\n\nAdditional reading material:\n- I build a variant of tetrahedral interpolation for 3D directional flow:\n    https://www.shadertoy.com/view/mlBczy\n\n- A paper on tetrahedral interpolation for cheaper volume textures from \n    Róbert Bán and Gábor Valasek https://doi.org/10.2312/egp.20211031\n*/\n\n// Number of repeats of the test, 1000 should be enough for RTX3080, \n// 1 is comparison view of all 2\n#define REPEAT 1\n\n/* Switch this parameter to change which function is performance tested\nHEABILY depends on the COUNT which makes it also way slower so try gently\n0 = Vanilla Volume Texture Filtering       ~ 113 fps\n1 = Manual quadrilinear Texture Filtering  ~ 21 fps\n2 = 2 Tetrahedral Texture Filtering        ~ 21 fps*/\n#define TEST 0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    #if REPEAT == 1\n        // Normalized pixel coordinates (from 0 to 1)\n        vec2 uv = fragCoord/iResolution.x;\n\n        // If the mouse was not clicked, animate\n        float border = 0.5;\n        float zoom = 10.0;\n        if (iMouse.x > 0.0) {\n\n            // scale mouse coords to 0-1 range of screen\n            vec2 mouse = iMouse.xy / iResolution.x;\n\n            // Stepped zoom control\n            float zoomSteps = 10.0;\n            zoom = mix(2.0, 800.0, pow((floor(mouse.y * zoomSteps) + \n                               smoothstep(0.75, 1.0, fract(mouse.y * zoomSteps))) \n                               / zoomSteps, 2.0));\n            border = mouse.x;\n        }\n    #else\n        float zoom = 800.0;\n    #endif\n        \n    // Calculate ray direction\n    vec3 ray = vec3(fragCoord / iResolution.xy * 2.0 - vec2(1, 2.0), 1.0);\n\n    // Calculate intersection point on the floor\n    vec2 groundUV = ray.y != 0.0 ? -ray.xz / ray.y : vec2(0);\n        \n    // Find the texture resolution\n    vec2 texSize = vec2(textureSize(iChannel0, 0));\n    \n    // Zoom level\n    groundUV *= zoom / texSize;\n    \n    // Animation for the movement\n    vec2 myTime = iTime / texSize * 5.0;\n    //groundUV += vec2(sin(myTime.x), cos(myTime.y));\n\n    // Rotate the coordinates arbitrarily\n    groundUV = rotateUV(groundUV, normalize(vec2(1, 2)));\n    \n    // make ground coords 3d with slow animation\n    vec3 groundUVW = vec3(groundUV, iTime *0.01);\n    \n    #if REPEAT > 1\n        // if you get around 144 fps use a higher repeat value\n        vec3 color;\n        for(int i=0; i<REPEAT; i++) {\n\n            // unique permutation each iteration        \n            groundUVW = fract(groundUVW + (float(i)/float(REPEAT)));\n\n            // use which ever you wish to test\n            #if TEST == 0\n                // Vanilla Texture Sample\n                color += texture(iChannel0, groundUVW).xyz;            \n            #elif TEST == 1\n                // Manual Trilinear Texture Sample\n                color += quadrilinearTexture(iChannel0, groundUVW).xyz;\n            #elif TEST == 2\n                // 2 Barycentric Texfiltering\n                color += bitetraTexture(iChannel0, groundUVW).xyz;\n            #endif\n        }\n        \n        // Ensure test vector stays in visible range\n        color = fract(color);\n        \n    #else    \n        // Choose interpolation method based on the x-coordinate\n        vec3 color;\n        if (uv.x < border) {\n            // Left side\n            color = quadrilinearTexture(iChannel0, groundUVW).xyz;\n            //color = texture(iChannel0, uvw, 0.).xyz; // or default texture\n        } else {\n            // Right side\n            color = bitetraTexture(iChannel0, groundUVW).xyz;\n        }\n\n        // Calculate anti-aliasing effect\n        vec2 uvFwidth = fwidth(uv);\n        float aa = max(uvFwidth.x, uvFwidth.y);\n\n        // Add a dividing line\n        float line = 0.002;\n        color -= smoothstep(line+aa, line-aa, abs(uv.x - border));\n    #endif\n\n    // Output to screen\n    fragColor = vec4(color,1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Optional Contrast for nicer noise transitions, but images become worse\n//#define CONTRAST 1.6\n\n// GENERAL FUNCTIONS _____________________________________________________\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See: https://www.desmos.com/calculator/hs1nsjb32q\nfloat smoothContrast(float alpha, float contrast) {\n    // increase steepness using power\n    float powAlpha = pow(alpha, contrast);\n    float powInvAlpha = pow(1.-alpha, contrast);\n    \n    // normalize back to precentage of 1\n    return powAlpha/(powAlpha + powInvAlpha);\n}\n\nvec3 smoothContrast(vec3 alpha, float contrast) {\n    // increase steepness using power\n    vec3 powAlpha = pow(alpha, vec3(contrast));\n    vec3 powInvAlpha = pow(1.-alpha, vec3(contrast));\n    \n    // normalize back to precentage of 1\n    return powAlpha/(powAlpha + powInvAlpha);\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 2 value example (https://www.desmos.com/calculator/dpxa6mytnv)\nvec4 smoothContrast(vec4 alpha, float contrast) {\n    // increase steepness using power\n    vec4 powAlpha = pow(alpha, vec4(contrast));\n    \n    // normalize back to precentage of 1\n    return powAlpha/(powAlpha.x + powAlpha.y + powAlpha.z + powAlpha.w);\n}\n\n// Rotate UV in vector direction\nvec2 rotateUV(vec2 uv, vec2 direction) {\n\n    // Calculate the rotation matrix\n    mat2 rotationMatrix = mat2( direction.y, direction.x,\n                                -direction.x, direction.y );\n\n    // Rotate the UV coordinates\n    return rotationMatrix * uv;\n}\n\n// TEXTURE FILTERING FUNCTIONS __________________________________________\n\n// Function to calculate the mip level and max mip level\nfloat getMipLevel(sampler3D sam, vec3 uvw) {\n\n    // Adjust mip level based on your texture size\n    vec3 texSize = vec3(textureSize(sam, 0));  \n\n    // Scale the partial derivatives by the texture size\n    vec3 scaledDDX = dFdx(uvw) * texSize;\n    vec3 scaledDDY = dFdy(uvw) * texSize;\n\n    // Find the largest rate of change\n    float maxDDLength = max(dot(scaledDDX, scaledDDX), dot(scaledDDY, scaledDDY));\n\n    // Calculate the mip level based on the rate of change\n    float mipLevel = log2(sqrt(maxDDLength));\n\n    // Find the maximum dimension of the texture\n    float maxDimension = max(max(texSize.x, texSize.y), texSize.z);\n    \n    // Calculate the highest mip level using the logarithm base 2\n    float highestMipLevel = log2(maxDimension);\n\n    // Return both the mip level and the maximum mip level\n    return clamp(mipLevel, 0., highestMipLevel);\n}\n\n// Trilinear filtering function (8 samples)\nvec4 trilinearTexture(sampler3D tex, vec3 uvw, int mip) {\n\n    // Find the texture resolution\n    vec3 texSize = vec3(textureSize(tex, mip));\n\n    // Generate texture coordinates\n    vec3 coords = uvw * texSize - 0.5;\n    vec3 id = floor(coords); // Cell id\n    vec3 weights = coords - id; // Technically also the grid\n\n    // Sample the 8 corners of the texture\n    vec4 a = texelFetch(tex, ivec3(mod(id,                 texSize)), mip);\n    vec4 b = texelFetch(tex, ivec3(mod(id + vec3(1, 0, 0), texSize)), mip);\n    vec4 c = texelFetch(tex, ivec3(mod(id + vec3(0, 1, 0), texSize)), mip);\n    vec4 d = texelFetch(tex, ivec3(mod(id + vec3(1, 1, 0), texSize)), mip);\n    vec4 e = texelFetch(tex, ivec3(mod(id + vec3(0, 0, 1), texSize)), mip);\n    vec4 f = texelFetch(tex, ivec3(mod(id + vec3(1, 0, 1), texSize)), mip);\n    vec4 g = texelFetch(tex, ivec3(mod(id + vec3(0, 1, 1), texSize)), mip);\n    vec4 h = texelFetch(tex, ivec3(mod(id + vec3(1, 1, 1), texSize)), mip);\n\n    #ifdef CONTRAST \n        weights = smoothContrast(weights, CONTRAST); // optional\n    #endif\n\n    // Trilinear interpolation between the 8 corners\n    return mix(mix(mix(a, b, weights.x), \n                   mix(c, d, weights.x), weights.y), \n               mix(mix(e, f, weights.x), \n                   mix(g, h, weights.x), weights.y), weights.z);\n}\n\n// Quadrilinear filtering function (16 samples)\nvec4 quadrilinearTexture(sampler3D tex, vec3 uvw) {\n\n    // Calculate the mip level\n    float mipLevel = getMipLevel(tex, uvw);\n\n    // Get the integer and fractional parts of the mip level\n    int mipA = int(floor(mipLevel));\n    float weight = mipLevel - float(mipA);\n\n    // If mip level is an integer, perform trilinear filtering at that mip level\n    if (weight == 0.0) {\n        return trilinearTexture(tex, uvw, mipA);\n    }\n    \n    #ifdef CONTRAST \n        weight = smoothContrast(weight, CONTRAST); // optional\n    #endif\n\n    // Perform trilinear filtering on the two mip levels\n    vec4 color0 = trilinearTexture(tex, uvw, mipA);\n    vec4 color1 = trilinearTexture(tex, uvw, mipA + 1);\n\n    // Interpolate between the two mip levels\n    return mix(color0, color1, weight);\n}\n\n// Tetrahedral texture sampling for volume textures (4 Samples)\nvec4 tetraTexture(sampler3D tex, vec3 pos, int mip) {\n\n    // Find the texture resolution\n    vec3 texSize = vec3(textureSize(tex, mip));\n\n    // Generate texture coordinates\n    #if 0\n        // ++Cube pattern (Mirrored)\n        vec3 coords = pos * texSize * 0.5 + 0.25;\n        vec3 id = floor(coords); // texel coords\n        vec3 grid = abs((coords - id) * 2.0 - 1.0);\n        \n        vec3 offsetC = (grid.x > grid.z && grid.y > grid.z) ? vec3(0.5,0.5,0) : \n                                          (grid.y > grid.x) ? vec3(0,0.5,0.5) : \n                                                              vec3(0.5,0,0.5);\n        vec3 offsetD = (grid.x < grid.z && grid.y < grid.z) ? vec3(0,0,0.5) : \n                                          (grid.y < grid.x) ? vec3(0.5,0,0) : \n                                                              vec3(0,0.5,0);\n\n        ivec3 idA = ivec3(mod((floor(coords +vec3(0.5)) -vec3(0.5)) *2.0, texSize));\n        ivec3 idB = ivec3(mod( floor(coords)                        *2.0, texSize));\n        ivec3 idC = ivec3(mod((floor(coords +offsetC)   -offsetC)   *2.0, texSize));\n        ivec3 idD = ivec3(mod((floor(coords +offsetD)   -offsetD)   *2.0, texSize));\n\n    #else\n        // Rohmbic Dodecahedron pattern\n        vec3 coords = pos * texSize - 0.5;\n        vec3 id = floor(coords); // texel coords\n        vec3 grid = coords - id;\n        \n        vec3 offsetC = (grid.x > grid.z && grid.y > grid.z) ? vec3(1,1,0) : \n                                          (grid.y > grid.x) ? vec3(0,1,1) : \n                                                              vec3(1,0,1);\n        vec3 offsetD = (grid.x < grid.z && grid.y < grid.z) ? vec3(0,0,1) : \n                                          (grid.y < grid.x) ? vec3(1,0,0) : \n                                                              vec3(0,1,0);\n\n        ivec3 idA = ivec3(mod(id +vec3(1), texSize));\n        ivec3 idB = ivec3(mod(id,           texSize));\n        ivec3 idC = ivec3(mod(id +offsetC, texSize));\n        ivec3 idD = ivec3(mod(id +offsetD, texSize));\n    #endif\n\n    // Sample the 4 corners of the texture\n    vec4 a = texelFetch(tex, idA, mip);\n    vec4 b = texelFetch(tex, idB, mip);\n    vec4 c = texelFetch(tex, idC, mip);\n    vec4 d = texelFetch(tex, idD, mip);\n\n    // generate the interpolation weights\n    vec3 iGrid = 1.-grid;\n    float weightA = min(min( grid.x,  grid.y),  grid.z);\n    float weightB = min(min(iGrid.x, iGrid.y), iGrid.z);\n    float weightC = abs(min(abs( grid.x  -grid.y),  grid.z -min( grid.x, grid.y)));\n    //float weightD = abs(min(abs(iGrid.x -iGrid.y), iGrid.z -min(iGrid.x, iGrid.y)));\n    vec4 weights = vec4(weightA, weightB, weightC, 1. - weightA - weightB - weightC);\n    \n    #ifdef CONTRAST \n        weights = smoothContrast(weights, CONTRAST); // optional\n    #endif\n\n    // barycentric interpolation between 4 values\n    return a * weights.x + b * weights.y + c * weights.z + d * weights.w;\n}\n\n// 2x Quadrilinear filtering function (16 samples)\nvec4 bitetraTexture(sampler3D tex, vec3 uvw) {\n\n    // Calculate the mip level\n    float mipLevel = getMipLevel(tex, uvw);\n\n    // Get the integer and fractional parts of the mip level\n    int mipA = int(floor(mipLevel));\n    float weight = mipLevel - float(mipA);\n\n    // If mip level is an integer, perform filtering at that mip level\n    if (weight == 0.0) {\n        return tetraTexture(tex, uvw, mipA);\n    }\n    \n    #ifdef CONTRAST \n        weight = smoothContrast(weight, CONTRAST); // optional\n    #endif\n\n    // Perform trilinear filtering on the two mip levels\n    vec4 color0 = tetraTexture(tex, uvw, mipA);\n    vec4 color1 = tetraTexture(tex, uvw, mipA + 1);\n\n    // Interpolate between the two mip levels\n    return mix(color0, color1, weight);\n}","name":"Common","description":"","type":"common"}]}