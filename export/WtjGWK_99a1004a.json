{"ver":"0.1","info":{"id":"WtjGWK","date":"1561206842","viewed":145,"name":"Hello Text","username":"bitrate1280","description":"Hello Text","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_CAST_RAY = 150;\nconst float PI = 3.14159;\nconst float BUTTON_NUM = 10.0;\nconst float BUTTON_NUM_HALF = BUTTON_NUM * 0.5;\n\nconst int WAVE_MAX = 9;\nconst float[] WAVE_TIME_LIST = float[]\n(\n    3.0, // 0:sphere\n    0.5, // 1:wait\n    1.5, // 2:H\n    1.5, // 3:E\n    1.5, // 4:L\n    1.5, // 5:L\n    1.5, // 6:O\n    1.5, // 7:Face\n    3.0  // 8:return sphere\n);\n\nconst float MAX_WAVE_TIME = \n    WAVE_TIME_LIST[0] + \n    WAVE_TIME_LIST[1] +\n    WAVE_TIME_LIST[2] +\n    WAVE_TIME_LIST[3] +\n    WAVE_TIME_LIST[4] + \n    WAVE_TIME_LIST[5] +\n    WAVE_TIME_LIST[6] +\n    WAVE_TIME_LIST[7] +\n    WAVE_TIME_LIST[8];\n    \n// wave number\nconst int WAVE_SPHERE = 0;\nconst int WAVE_WAIT1 = 1;\nconst int WAVE_CHAR_H = 2;\nconst int WAVE_CHAR_E = 3;\nconst int WAVE_CHAR_L = 4;\nconst int WAVE_CHAR_L2 = 5;\nconst int WAVE_CHAR_O = 6;\nconst int WAVE_CHAR_FACE = 7;\nconst int WAVE_CHAR_RETURN_SPHERE = 8;\n\n#define ToBit(x1,x2,x3,x4,x5,x6,x7,x8,x9,x10) x1 + ((1 << x2) & (1 << 1)) +((1 << (x3 + 1)) & (1 << 2)) +((1 << (x4 + 2)) & (1 << 3)) +((1 << (x5 + 3)) & (1 << 4)) +((1 << (x6 + 4)) & (1 << 5)) +((1 << (x7 + 5)) & (1 << 6)) +((1 << (x8 + 6)) & (1 << 7)) +((1 << (x9 + 7)) & (1 << 8)) +((1 << (x10 + 8)) & (1 << 9))\n\nconst int[] charH = int[](\n    ToBit(0,1,1,0,0,0,0,1,1,0),\n    ToBit(0,1,1,0,0,0,0,1,1,0), \n    ToBit(0,1,1,0,0,0,0,1,1,0),\n    ToBit(0,1,1,0,0,0,0,1,1,0),\n    ToBit(0,1,1,1,1,1,1,1,1,0),\n    ToBit(0,1,1,1,1,1,1,1,1,0),\n    ToBit(0,1,1,0,0,0,0,1,1,0), \n    ToBit(0,1,1,0,0,0,0,1,1,0),\n    ToBit(0,1,1,0,0,0,0,1,1,0),\n    ToBit(0,1,1,0,0,0,0,1,1,0)\n);\n\nconst int[] charE = int[](\n    ToBit(0,1,1,1,1,1,1,1,0,0),\n    ToBit(0,1,1,1,1,1,1,1,0,0), \n    ToBit(0,1,1,0,0,0,0,0,0,0),\n    ToBit(0,1,1,0,0,0,0,0,0,0),\n    ToBit(0,1,1,1,1,1,1,0,0,0),\n    ToBit(0,1,1,1,1,1,1,0,0,0),\n    ToBit(0,1,1,0,0,0,0,0,0,0), \n    ToBit(0,1,1,0,0,0,0,0,0,0),\n    ToBit(0,1,1,1,1,1,1,1,0,0),\n    ToBit(0,1,1,1,1,1,1,1,0,0)\n);\n\nconst int[] charL = int[](\n    ToBit(0,1,1,0,0,0,0,0,0,0),\n    ToBit(0,1,1,0,0,0,0,0,0,0), \n    ToBit(0,1,1,0,0,0,0,0,0,0),\n    ToBit(0,1,1,0,0,0,0,0,0,0),\n    ToBit(0,1,1,0,0,0,0,0,0,0),\n    ToBit(0,1,1,0,0,0,0,0,0,0),\n    ToBit(0,1,1,0,0,0,0,0,0,0), \n    ToBit(0,1,1,0,0,0,0,0,0,0),\n    ToBit(0,1,1,1,1,1,1,1,0,0),\n    ToBit(0,1,1,1,1,1,1,1,0,0)\n);\n\nconst int[] charO = int[](\n    ToBit(0,0,1,1,1,1,1,1,0,0),\n    ToBit(0,1,1,1,1,1,1,1,1,0), \n    ToBit(0,1,1,0,0,0,0,1,1,0),\n    ToBit(0,1,1,0,0,0,0,1,1,0),\n    ToBit(0,1,1,0,0,0,0,1,1,0),\n    ToBit(0,1,1,0,0,0,0,1,1,0),\n    ToBit(0,1,1,0,0,0,0,1,1,0), \n    ToBit(0,1,1,0,0,0,0,1,1,0),\n    ToBit(0,1,1,1,1,1,1,1,1,0),\n    ToBit(0,0,1,1,1,1,1,1,0,0)\n);\n\nconst int[] charFace = int[](\n    ToBit(0,0,0,1,0,0,0,1,0,0),\n    ToBit(0,0,1,0,0,0,0,0,1,0),\n    ToBit(0,1,0,1,0,0,0,1,0,1),\n    ToBit(0,0,0,1,0,0,0,1,0,0),\n    ToBit(0,0,0,0,0,0,0,0,0,0),\n    ToBit(1,0,0,0,1,1,1,0,0,0),\n    ToBit(1,0,0,1,0,0,0,1,0,0),\n    ToBit(0,1,0,1,0,0,0,1,0,0),\n    ToBit(0,1,0,0,1,1,1,0,0,1),\n    ToBit(0,0,1,0,0,0,0,0,1,0)\n);\n\nconst vec3[] CHAR_COLOR_LIST = vec3[](\n    vec3(0.5, 0.0, 0.0),\n    vec3(0.5, 0.0, 0.0),\n    vec3(1.0, 0.0, 0.0),\n    vec3(0.7, 0.7, 0.0),\n    vec3(0.0, 1.0, 0.0),\n    vec3(0.0, 0.5, 0.7),\n    vec3(0.0, 0.0, 1.0),\n    vec3(1.0, 0.0, 1.0),\n    vec3(0.5, 0.0, 0.0)\n);\n\nfloat convertXYToChar(int char, int x, int y)\n{\n    if(char == 0) { return (charH[y] & (1 << x)) > 0 ? 1.0 : 0.0; }\n    if(char == 1) { return (charE[y] & (1 << x)) > 0 ? 1.0 : 0.0; }\n    if(char == 2) { return (charL[y] & (1 << x)) > 0 ? 1.0 : 0.0; }\n    if(char == 3) { return (charL[y] & (1 << x)) > 0 ? 1.0 : 0.0; }\n    if(char == 4) { return (charO[y] & (1 << x)) > 0 ? 1.0 : 0.0; }\n    if(char == 5) { return (charFace[y] & (1 << x)) > 0 ? 1.0 : 0.0; }\n    \n    return 0.0;\n}\n\nint getWave()\n{\n    float time = mod(iTime, MAX_WAVE_TIME);\n    float waveTime = 0.0;\n    \n    for(int i = 0; i < WAVE_MAX; i++)\n    {\n        waveTime += WAVE_TIME_LIST[i];\n        if(time < waveTime){return i;}\n    }\n    \n    return 0;\n}\n\nfloat getWaveProgress(int wave)\n{\n    float time = mod(iTime, MAX_WAVE_TIME);\n    float subTime = 0.0;\n    for(int i = 0; i < wave; i++)\n    {\n        subTime += WAVE_TIME_LIST[i];\n    }\n    \n    time -= subTime;\n    \n    return time / WAVE_TIME_LIST[wave];\n}\n\nfloat getSphereRate(int wave, float prog)\n{\n    float sphereWave = (wave == WAVE_SPHERE || wave == WAVE_CHAR_RETURN_SPHERE) ? 1.0 : 0.0;\n    sphereWave *= wave == WAVE_SPHERE ? (1.0 - prog) : prog;\n    \n    return sphereWave;\n}\n\nfloat checkChara(int wave, int index)\n{\n    if(index < 0) return 0.0;\n    \n    int x = int(mod(float(index), BUTTON_NUM));\n    int y = int(float(index) / BUTTON_NUM);\n\n    if(wave == WAVE_CHAR_H){ return convertXYToChar(0, x, y); }\n    if(wave == WAVE_CHAR_E){ return convertXYToChar(1, x, y); }\n    if(wave == WAVE_CHAR_L){ return convertXYToChar(2, x, y); }\n    if(wave == WAVE_CHAR_L2){ return convertXYToChar(3, x, y); }\n    if(wave == WAVE_CHAR_O){ return convertXYToChar(4, x, y); }\n    if(wave == WAVE_CHAR_FACE){ return convertXYToChar(5, x, y); }\n}\n\nvec3 waveColor(int wave)\n{\n    return CHAR_COLOR_LIST[wave];\n}\n\nfloat sine(float p)\n{\n    return sin(p * PI);\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nvec2 sdButtonList(vec3 p)\n{\n    float interval = 4.2;\n    vec2 xz = p.xz;\n    p.xz = mod(xz, interval) - interval * 0.5;\n    \n    vec2 indexXz = floor((xz) / interval);\n    \n    if(abs(indexXz.x) > BUTTON_NUM_HALF || indexXz.x >= BUTTON_NUM_HALF ||\n       abs(indexXz.y) > BUTTON_NUM_HALF || indexXz.y >= BUTTON_NUM_HALF)\n    {\n        return vec2(1.0, -1.0);\n    }\n    \n    float index = floor(indexXz.x + BUTTON_NUM_HALF) + floor((indexXz.y + BUTTON_NUM_HALF) * BUTTON_NUM);\n    \n    int wave = getWave();\n    float progress = getWaveProgress(wave);\n    \n    float up = float((indexXz.x + BUTTON_NUM_HALF) + (indexXz.y + BUTTON_NUM_HALF)) / float(float(BUTTON_NUM) * 2.0);\n    up = pow(1.0 - abs(progress - up), 5.0);\n    \n    p.y -= ((checkChara(wave, int(index)) - 0.5) * pow(sine(progress), 0.5) * 3.0 * up);\n\n\tvec3 d = abs(p) - vec3(1.0, 1.0, 1.0);\n\tfloat l = length(max(d,0.0)) - 1.0 + min(max(d.x,max(d.y,d.z)),0.0);\n\n    return vec2(l, index);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map(vec3 pos)\n{\n    vec2 button = sdButtonList(pos);\n    \n    int wave = getWave();\n    float prog = getWaveProgress(wave);\n    \n    float sphereWave = getSphereRate(wave, prog);\n    sphereWave = pow(sphereWave, abs((sphereWave - 0.5) * 2.0) * 3.5);\n    vec2 res = vec2(mix(button.x, sdSphere(pos, 10.0), sphereWave), button.y);\n   \n    // float sphere\n    float around = 15.0 + 15.0 * (1.0 - sphereWave);\n\tres = opU( vec2(sdSphere(pos + vec3(cos(iTime * 0.3) * around, sine(iTime) * (3.0 + (sphereWave * 5.0)), sin(iTime * 0.3) * around), 2.0), -10.0), res);\n    \n    return res;\n}\n\nvec2 castRay(vec3 cPos, vec3 ray)\n{\n    float top = 0.0;\n\n    for(int i = 0; i < MAX_CAST_RAY; i++)\n    {\n        vec3 check = cPos + top * ray;\n        vec2 h = map(check);\n        if(abs(h.x) < 0.00001)\n        {\n            return vec2(h.y, check.y);\n        }\n        top += h.x;\n    }\n    \n    return vec2(-1.0, 0.0);\n}\n\nvec3 getRay(vec2 fragCoord, vec3 cDir)\n{\n    vec2 p = (-iResolution.xy+2.0*(fragCoord.xy))/min(iResolution.x, iResolution.y);\n    vec3 cUp = vec3(0.0, 1.0, 0.0);\n    \n    vec3 cSide = cross(cDir, cUp);\n\n    return normalize(cSide * p.x + cUp * p.y + cDir);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cPos = vec3(cos(iTime * 0.05) * 40.0, 30.0, sin(iTime * 0.05) * 45.0);\n    vec3 cDir = normalize(cPos * -1.0);\n    \n    vec3 ray = getRay(fragCoord, cDir);\n    vec2 res = castRay(cPos, ray);\n    \n    if(res.x < 0.0)\n    {\n        // float sphere or empty\n        vec2 uv = fragCoord/iResolution.xy;\n        fragColor = res.x == -10.0 ? vec4(fragCoord/iResolution.xy * 2.0, 0.0, 1.0) :\n        \tvec4(0.3 * uv.y, 0.0, pow(0.3 * (1.0 - uv.y), 0.5), 1.0);\n\n    }\n    else\n    {\n        // button or shpere\n        \n    \tint wave = getWave();\n        float progress = getWaveProgress(wave);\n\n        float up = (mod(res.x, BUTTON_NUM) + (res.x / BUTTON_NUM)) / (BUTTON_NUM * 2.0);\n\n        int showWave = progress > up ? wave : wave -1;\n\n        float chara = checkChara(showWave, int(res.x));\n        fragColor = vec4(abs(chara - waveColor(showWave)), 1.0);\n        \n        float sphereWave = getSphereRate(wave, progress);\n        \n        // color add\n        fragColor.xyz += (sin(res.x * 0.02 * iTime) * mod(res.x, 1.6333)) * 0.15 * (1.0 - sphereWave);\n\n        fragColor.xzy *= res.y;\n    }\n}","name":"Image","description":"","type":"image"}]}