{"ver":"0.1","info":{"id":"7tjcRK","date":"1650126397","viewed":207,"name":"Vorobubble","username":"MonsieurSoleil","description":"vorobubble","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","voronoi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Matter\n{\n    float m;\n    bool hit;\n    int type;\n    bool reflected;\n    float glow;\n    float glow02;\n};\n\nstruct Ray\n{\n    vec3 o;\n    vec3 t;\n    vec3 p;\n    vec3 dir;\n    float dist;\n    vec3 hitloc;\n};\n\nstruct Light\n{\n    vec3 liPos;\n    vec3 liDir;\n    float shad;\n    float liGlow;\n};\n\nstruct Res\n{\n    vec3 skyColor;\n    vec3 fogGlow;\n    vec3 glowCol;\n    vec3 color;\n};\n\nMatter mat;\nMatter mat02;\nRay ray;Ray ray02;\nLight li;\nRes res;\n\nmat2 rot(float a)\n{\n    float ca = cos(a);\n    float sa = sin(a);\n    \n    return mat2(ca, -sa, sa, ca);\n}\n\n// using voronoi by iq https://www.shadertoy.com/view/MsXGzM\n\nvec3 random3f( vec3 p )\n{\n\n    return fract(sin(vec3( dot(p,vec3(1.0,57.0,113.0)), \n                           dot(p,vec3(57.0,113.0,1.0)),\n                           dot(p,vec3(113.0,1.0,57.0))))*43758.5453);\n}\n\nvec3 voronoi( in vec3 x )\n{\n    vec3 p = floor( x );\n    vec3 f = fract( x );\n\n\tfloat id = 0.0;\n    vec2 res = vec2( 100.0 );\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 b = vec3( float(i), float(j), float(k) );\n        vec3 r = vec3( b ) - f + random3f( p + b );\n        float d = dot( r, r );\n\n        if( d < res.x )\n        {\n\t\t\tid = dot( p+b, vec3(1.0,57.0,113.0 ) );\n            res = vec2( d, res.x );\t\t\t\n        }\n        else if( d < res.y )\n        {\n            res.y = d;\n        }\n    }\n\n    return vec3( sqrt( res ), abs(id) );\n}\n\nfloat rep(float p, float s)\n{\n    return (fract(abs(p/s) - 0.5)-0.5)*s;\n}\n\nfloat box(vec3 p, vec3 s)\n{\n    p = abs(p) - s;\n    return max(max(p.x, p.y), p.z);\n}\n\nfloat sphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\nvoid map(inout Matter ma, vec3 p)\n{\n    float mat01 = 10.0, mat02 = 10.0, mat03 = 10.0;\n    vec3 p01 = p, p02 = p, p03 = abs(p+vec3(0.0, 1.0, 0.0));\n    //p02.x = rep(p02.x, 1.0);\n    p02.xy *= rot(iTime * 0.75);\n    p03.xy *= rot(iTime * 0.75);\n    \n    mat01 = sphere(p, 3.0);\n   \n    if(mat01 < 0.01)\n    {\n        p01.xz *= rot(iTime*0.5);\n    \n        mat02 = sphere(p01, 2.0);\n        mat02 = max(mat02, -sphere(p03+vec3(0.0, 1.0, 0.0), 2.0));\n        \n        vec3 v = voronoi(1.0*(p01)+smoothstep(0.45, 0.75, pow(fract(iTime*0.25), 1.2))+iTime*0.25 + floor(iTime*0.25));\n        float f = clamp( 3.5*(v.y-v.x), 0.0, 1.0 );\n        \n        mat02 += f * 1.0 /** smoothstep(abs(sin(iTime) * 2.0), 0.5, 1.0)*/;\n        \n        mat03 = sphere(p02 + vec3(-5.0+fract(iTime*0.5)*10.0, 0.0, 0.0), 2.0);\n        mat03 = max(mat03, -box(p02 + vec3(2.0-5.0+fract(iTime*0.5)*10.0,0.0,0.0), vec3(1.95)));\n        mat03 = max(mat03, -box(p02 - vec3(2.0+5.0+fract(iTime*0.5)*10.0,0.0,0.0), vec3(1.95)));\n        mat03 = max(mat03, -sphere(p02+ vec3(-5.0+fract(iTime*0.5)*10.0, 0.0, 0.0), 1.95));\n        \n        ma.glow += 0.15/(0.05+abs(mat02));\n        ma.glow02 += 0.15/(0.05+abs(mat03)) * ma.glow;\n        \n        ma.m = mat02;\n        return;\n    }\n    \n    \n    \n    \n    //ma.glow += 0.15/(0.05+abs(mat01));\n    \n    ma.m = mat01;\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv /= vec2(iResolution.y/iResolution.x, 1.0);\n\n    res.glowCol = vec3(0.5);\n    \n    ray.o = vec3(0.0, 0.0, 10.0), ray.t = vec3(0.0);\n    vec3 fr = normalize(ray.t-ray.o);\n    vec3 ri = normalize(cross(vec3(0.0, 1.0, 0.0), fr));\n    vec3 up = normalize(cross(ri ,fr));\n    ray.dir = normalize(fr + uv.x * ri + uv.y * up);\n    ray.p = ray.o + ray.dir * 0.25;\n    ray02.p = ray.p;\n    ray02.dir = ray.dir;\n    mat.hit = false;\n    \n    for(int i = 0; i < 200; i++)\n    {\n        //if(!mat.hit)\n            map(mat, ray.p);\n            \n        //map02(mat02, ray02.p);\n        \n        if(mat.m < 0.00001)\n        {\n            mat.m = 1.05;\n            //break;\n        }\n        \n        res.glowCol -= vec3(1.0) * 0.000010 * mat.glow;\n        res.glowCol += vec3(uv.x*4.0, uv.y*4.0, 0.0) * 0.000001 * mat.glow02;\n        //res.glowCol += vec3(1.0) * 0.0020 * mat02.glow;\n        \n        ray.p += ray.dir * mat.m * 0.25;\n        ray02.p += ray02.dir * mat02.m;\n    }\n    \n    // Output to screen\n    fragColor = vec4(res.glowCol,1.0);\n}","name":"Image","description":"","type":"image"}]}