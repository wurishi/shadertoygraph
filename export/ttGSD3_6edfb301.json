{"ver":"0.1","info":{"id":"ttGSD3","date":"1583703070","viewed":103,"name":"Snowy Hills","username":"JentGent","description":"Title.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","terrain","lighting","spheretracing","rendering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision mediump float;\n\nvec3 c = vec3(1., 1., 1.);\n\nconst float PI = 3.14159265358979323;\n\nfloat random(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nfloat noise(vec2 iteration) {\n    vec2 i = floor(iteration);\n    vec2 f = fract(iteration);\n    float a = random(i);\n    float b = random(i + vec2(1., 0.));\n    float c = random(i + vec2(0., 1.));\n    float d = random(i + vec2(1., 1.));\n    vec2 u = f * f * (3. - 2. * f);\n    return mix(a, b, u.x) + (c - a) * u.y * (1. - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n    return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nfloat deSphere(vec3 from, vec3 center, float radius) {\n    return length(center - from) - radius;\n}\nfloat deTorus(vec3 from, vec3 center, float radius, float thickness) {\n    return length(vec2(length(center.xz - from.xz) - radius, center.y - from.y)) - thickness;\n}\nfloat deCuboid(vec3 from, vec3 center, vec3 dimensions) {\n    vec3 section = abs(center - from) - dimensions;\n    return length(max(section, 0.)) + min(max(section.x, max(section.y, section.z)), 0.);\n}\nfloat deUncappedCylinder(vec3 from, vec3 center, float radius) {\n    return length(center.yz - from.yz) - radius;\n}\nfloat deCappedCylinder(vec3 from, vec3 center, float radius, float capAt) {\n    return length(vec3(from.x, center.yz) - vec3(clamp(from.x, center.x - capAt / 2., center.x + capAt / 2.), from.yz)) - radius;\n}\nfloat deCapsule(vec3 from, vec3 center, float radius, float capAt) {\n    return length(vec3(from.x, center.yz) - vec3(clamp(from.x, center.x - capAt / 2., center.x + capAt / 2.), from.yz)) - radius;\n}\nfloat dePlane(vec3 from, vec3 center, vec3 normal) {\n    return dot(center - from, normalize(normal));\n}\n\nvec3 normalSphere(vec3 v, vec3 center) {\n    return normalize(center - v);\n}\n\nfloat deRound(float pd, float radius) {\n    float de = pd;\n    return de - radius;\n}\n\nfloat boolUnion(float pd, float pd2) {\n    return min(pd, pd2);\n}\nfloat boolSubtraction(float pd, float pd2) {\n    return max(pd, -pd2);\n}\nfloat boolIntersection(float pd, float pd2) {\n    return max(pd, pd2);\n}\n\nfloat smoothBoolUnion(float pd, float pd2, float smoothness) {\n    float level = clamp(0.5 + (pd - pd2) / smoothness / 2., 0., 1.);\n    return mix(pd, pd2, level) - smoothness * level * (1. - level);\n}\nfloat smoothBoolSubtraction(float pd, float pd2, float smoothness) {\n    float level = clamp(0.5 - (pd + pd2) / smoothness / 2., 0., 1. );\n    return mix(pd2, -pd, level) + smoothness * level * (1. - level);\n}\nfloat smoothBoolIntersection(float pd, float pd2, float smoothness) {\n    float level = clamp(0.5 - (pd - pd2) / smoothness / 2., 0., 1.);\n    return mix(pd, pd2, level) + smoothness * level * (1. - level);\n}\n\nfloat displace(float pd, vec3 from, vec3 dir, float size, float strength) {\n    vec3 p = from + dir * pd;\n    float d2 = sin(size * p.x) * sin(size * p.y) * sin(size * p.z) * strength;\n    return pd + d2;\n}\n\nvec3 rot(vec3 inp, float xRot, float yRot, float zRot, vec3 anchor) {\n    inp -= anchor;\n    mat2 rot = mat2(\n        cos(xRot), -sin(xRot),\n        sin(xRot), cos(xRot)\n    );\n    inp.yz *= rot;\n    rot = mat2(\n        cos(yRot), -sin(yRot),\n        sin(yRot), cos(yRot)\n    );\n    inp.xz *= rot;\n    rot = mat2(\n        cos(zRot), -sin(zRot),\n        sin(zRot), cos(zRot)\n    );\n    inp.xy *= rot;\n    inp += anchor;\n    return inp;\n}\n\nvec3 sun = normalize(vec3(1., -1., 0.));\nvec3 point = vec3(0., 0., 0.);\n\nvec3 cam = vec3(0., 5., 0.);\nfloat FOV = 0.5;\n\nuniform vec2 cursor;\n\nvec3 color = vec3(1.);\n\nfloat sceneNormal(vec3 from) {\n    float de = (from.y + noise(from.xz * 0.05 + vec2(1.)) * 20.0\n            + noise(from.xz * 1.0) * 0.05\n            ) * 0.05 - 1.0;\n    if(from.y < -12.) {\n        de = (from.y + noise(from.xz * 0.05 + vec2(1.)) * 20.0\n            + noise(from.xz * 1.0) * 0.05\n            + noise(from.xz * 3.0 + vec2(1.)) * 0.05\n            + noise(from.xz * 5.0) * 0.1) * 0.05;\n    }\n    return de;\n}\n\nvec3 getNormal(vec3 from) {\n    vec2 slopeOther = vec2(0.01, -0.01); \n    return normalize(\n        slopeOther.xxx * sceneNormal(from + slopeOther.xxx) +\n        slopeOther.xyy * sceneNormal(from + slopeOther.xyy) +\n        slopeOther.yyx * sceneNormal(from + slopeOther.yyx) + \n        slopeOther.yxy * sceneNormal(from + slopeOther.yxy)\n    );\n}\n\nfloat scene(vec3 from, bool outColor) {\n    \n    float de = (from.y + noise(from.xz * 0.05 + vec2(1.)) * 20.0) * 0.5;\n    vec3 ret = vec3(0.);\n    if(outColor) {\n        ret = vec3(0.54, 0.27, 0.07);\n        vec3 n = getNormal(from);\n        if(from.y > -12. && n.y > 0.6) {\n            float snow = 1.;\n            if(n.y < 0.8) {\n                snow = map(n.y, 0.6, 0.8, 0., 1.);\n            }\n            if(from.y < -11.) {\n                snow *= map(from.y, -12., -11., 0., 1.);\n            }\n            ret = ret * (1. - snow) + vec3(snow);\n            de -= snow * 0.3;\n        }\n        if(outColor) {\n            color = ret;\n        }\n    }\n    return de;\n    \n}\n\nvec3 render(vec3 from, vec3 dir) {\n    float sky = clamp(map(dir.y, 0., 1., 1., 0.), 0., 1.);\n    float night = 0.5 + cos(iTime * 0.3) * 0.5;\n    vec3 skyColor = (vec3(0.3, 0.8, 1.) * (1. - sky) + vec3(0.5, 1., 1.) * sky) * night;\n    vec3 at = from;\n    float closest = 10000.;\n    float totalDE = 0.;\n    for(int iter = 0; iter < 400; iter += 1) {\n        if(totalDE > 150.) {\n            break;\n        }\n        color = vec3(1.);\n        float de = scene(at, true);\n        at += dir * de;\n        totalDE += de;\n        if(de < closest) {\n            closest = de;\n        }\n        if(de < 0.01) {\n            vec3 normal = getNormal(at);\n            \n            // Shadows\n            float shade = 1.;\n            float bias = 0.1;\n            vec3 atShadow = at + normal * bias;\n            float inc = 0.001;\n            float shadowDE = 0.;\n            for(int iter = 0; iter < 100; iter ++) {\n                if(shadowDE > 400.) {\n                    break;\n                }\n                atShadow += -sun * inc;\n                shadowDE += inc;\n                float penumbra = scene(atShadow, false);\n                shade = min(shade, 8. * penumbra / inc);\n                inc += penumbra;\n                if(shade < 0.001) {\n                    break;\n                }\n            }\n            // Shadows\n            \n            shade = clamp(shade, 0.0, 1.0);\n            shade = shade*shade*(3. - 2. * shade);\n            shade = clamp(shade, 0.0, 1.0);\n            shade *= clamp(dot(normal, -sun) * 0.8, 0., 1.);\n            float sunShade = shade;\n            color += vec3(0., 0.4, 0.4) * (1. - sunShade);\n            shade = shade * 0.6 + 0.2;\n            vec3 sunRGB = vec3(0.4, 0.4, 0.2);\n            float fog = clamp(map(totalDE, 100., 150., 0., 1.), 0., 1.);\n            return clamp(color * shade + sunRGB * sunShade, 0., 1.) * (1. - fog) + skyColor * fog;\n        }\n    }\n    float facingSun = dot(dir, -sun);\n    if(facingSun > 0.98) {\n        float sunBrightness = (facingSun - 0.98) * 1./0.02;\n        return vec3(vec3(1., 1., 0.8) * clamp(sunBrightness * 2. - 1., 0., 1.) + skyColor * clamp(1. - (sunBrightness * 2. - 1.), 0., 1.));\n    }\n    if(facingSun < -0.99) {\n        return vec3(1.);\n    }\n    return skyColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    sun = rot(sun, 0., 0., iTime * 0.3, vec3(0.));\n    \n    float yaw = iTime * 0.1;\n    float pitch = 0.5;\n    \n    float xMap = fragCoord.x / iResolution.x - 0.5;\n    float yMap = fragCoord.y / iResolution.y - 0.5;\n    vec3 dir = normalize(vec3(xMap, yMap, FOV));\n    vec3 rotd = rot(dir, pitch, 0., 0., vec3(0.));\n    rotd = rot(rotd, 0., yaw, 0., vec3(0.));\n    dir = rotd;\n    \n    c = render(cam, dir);\n    fragColor = vec4(c, 1.);\n}","name":"Image","description":"","type":"image"}]}