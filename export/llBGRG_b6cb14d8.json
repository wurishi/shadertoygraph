{"ver":"0.1","info":{"id":"llBGRG","date":"1429831911","viewed":135,"name":"The Black Shuriken","username":"GreenSpiny","description":"Project for Game Architecture, Spring 2015.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","3d","raymarching","shuriken"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// Constants\nconst float PI = 3.1415;\nconst float spinSpeed = 2.5;\nconst float gSpeed = -5.0;\n\n// 2D Background : Movement constants\nconst float bHeight = .45;\nconst float bHeight2 = .48;\nconst float bSpeed = 5.0;\n\n// Spinning shuriken : Blade position\nvec3 bladePos (vec3 anchor, float offset) {\n    return vec3(\n        anchor.x + sin(offset-(PI/12.0)+iTime*spinSpeed),\n        anchor.y + cos(offset-(PI/12.0)+iTime*spinSpeed),\n        0.0);\n}\n\n// Spinning shuriken : Blade angle\nvec3 bladeRot (float offset) {\n    return vec3(0.0,0.0,PI+offset-(PI/6.0)+iTime*spinSpeed);\n}\n\n// ------------------------------------------------------------------- o\n\n// Distance function for a sphere --- o\nfloat sphere (vec3 pos, float radius) {\n\treturn length(pos) - radius;\n}\n\n// Distance function for a box --- o\nfloat box (vec3 pos, vec3 bounds) {\n \tvec3 d = abs(pos) - bounds;\n  \treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));   \n}\n\n// Distance function for a triangular prism --- o\nfloat triPrism (vec3 pos, vec2 h) {\n    vec3 q = abs(pos);\n    return max(q.z-h.y,max(q.x*0.866025+pos.y*0.5,-pos.y)-h.x*0.5);\n}\n\n// Distance function for a cone --- o\nfloat cone (vec3 p, vec3 c) {\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -p.y-c.z;\n    float d2 = max( dot(q,c.xy), p.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// Distance functions for a cylinder --- o\nfloat cylinder (vec3 pos, vec2 h) {\n  vec2 d = abs(vec2(length(pos.xz),pos.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// Distance function for an infinite y-axis plane -- o\nfloat plane (vec3 pos) {\n\treturn pos.y;   \n}\n\n// Union - combines two distance functions --- o\nvec2 opUnion (vec2 a, vec2 b) {\n    if (a.x < b.x) {return a;}\n    else           {return b;}\n}\n\n// Subtract - combines two distance functions --- o\nvec2 opSubtract (vec2 a, vec2 b) {\n    if (-a.x > b.x) {return vec2(-a.x,a.y);}\n    else            {return b;}\n}\n\n// Intersect - combines two distance functions --- o\nvec2 opIntersect (vec2 a, vec2 b) {\n    if (a.x > b.x) {return a;}\n    else           {return b;}\n}\n\n// Repeat - uses modulo to repeat distances --- o\nvec3 opRepeat (vec3 pos, vec3 c) {\n    return mod(pos,c)-0.5*c;\n}\n\n// Rotate - rotates a primitive --- o\nvec3 opRotate (vec3 pos, vec3 rot) {\n \tvec3 temp = pos;\n    // x\n    vec3 m1 = vec3(1.0,0.0,0.0);\n    vec3 m2 = vec3(0.0,cos(rot.x),-sin(rot.x));\n    vec3 m3 = vec3(0.0,sin(rot.x),cos(rot.x));\n    temp *= mat3(m1,m2,m3);\n    \n    // y\n    m1 = vec3(cos(rot.y),0.0,sin(rot.y));\n    m2 = vec3(0.0,1.0,0.0);\n    m3 = vec3(-sin(rot.y),0.0,cos(rot.y));\n    temp *= mat3(m1,m2,m3);\n    \n    // z\n    m1 = vec3(cos(rot.z),-sin(rot.z),0.0);\n    m2 = vec3(sin(rot.z),cos(rot.z),0.0);\n    m3 = vec3(0.0,0.0,1.0);\n    return temp * mat3(m1,m2,m3);\n}\n\n// ------------------------------------------------------------------- o\n\n// 2D background effect function\nvec3 effect (vec2 pos) {\n\t\n    vec3 color = vec3(.8*(1.0-pos.y),0.25,0.55) - (1.0-pos.y);\n    float rad = .1 * (2.0-pos.x) + .07;\n    \n    if (pos.y > bHeight2) {\n        \n        // Scrolling clouds 1\n        if ((distance(vec2(mod(pos.x-iTime/bSpeed*2.0,.3),pos.y), vec2(0.0,bHeight) ) < rad\n        ||  distance(vec2(mod(-pos.x+iTime/bSpeed*2.0,.3),pos.y), vec2(0.0,bHeight) ) < rad)){\n            color = vec3(.9,.8,.95)*pos.y*1.5; \n        }\n\n        // Scrolling clouds 2\n        else if ((distance(vec2(mod(pos.x-iTime/bSpeed*3.0,.6),pos.y), vec2(0.0,bHeight) ) < rad*2.0\n        ||  distance(vec2(mod(-pos.x+iTime/bSpeed*3.0,.6),pos.y), vec2(0.0,bHeight) ) < rad*2.0)){\n            color = vec3(0.7,0.3,0.5)*pos.y*1.5;\n        }\n    }\n    return color;\n}\n\n\n// Function to convert rgb color to hex\nfloat hex (vec3 rgb) {\n\treturn rgb.r + rgb.g * 256.0 + rgb.b * 256.0 * 256.0;\n}\n\n\n// Function to convert hex color to rgb\nvec3 rgb (float hex) {\n\tvec3 color;\n    color.b = floor(hex / 256.0 / 256.0);\n    color.g = floor((hex - color.b * 256.0 * 256.0) / 256.0);\n    color.r = floor(hex - color.b * 256.0 * 256.0 - color.g * 256.0);\n    return color / 256.0;\n}\n\n\n// Function to create a camera matrix --- o\nmat3 setCamera (vec3 pos, vec3 target, float rot) {\n\tvec3 cw = normalize(target-pos);\n\tvec3 cp = vec3(sin(rot), cos(rot),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\n// Function in which all the objects in the scene are placed and measured --- o\nvec2 scene (vec3 cameraPos) {\n    \n    // Final result\n    vec2 result = vec2(99999.0,hex(vec3(0,0,0)));\n    \n    // Shuriken ~ ~ ~ ~ ~\n    vec3 shurikenPos = vec3(0.0,1.5 + sin(iTime*2.0)/5.0,0.0);\n    float sColor = hex(vec3(150,120,150));\n    float eyeColor = hex(vec3(20,0,20));\n    const float w = 0.15;\n    \n    vec2 shuriken = opUnion(\n        vec2(cone(opRotate(cameraPos-shurikenPos+vec3(0,0,w),vec3(PI/2.0,0,0)),vec3(.1,.83,w)),sColor),\n        vec2(cone(opRotate(cameraPos-shurikenPos+vec3(0,0,-w),vec3(PI/2.0,0,PI)),vec3(.1,.83,w)),sColor)\n        );\n    \n    shuriken = opSubtract(vec2(sphere(cameraPos-shurikenPos, 0.28), sColor), shuriken);\n    \n    for (float i=0.0; i<2.0*PI; i+=2.0*PI/8.0){\n    shuriken = opSubtract(\n    \tvec2(triPrism(opRotate(cameraPos-bladePos(shurikenPos,i),bladeRot(i)),vec2(0.6,0.5)), sColor),\n    \tshuriken);\n    }\n    \n    float eyeRadius = .17 + cos(iTime*2.0)*0.005;\n    shuriken = opUnion(shuriken,\n    \tvec2(cylinder(opRotate(cameraPos-shurikenPos,vec3(PI/2.0,0,0)), vec2(eyeRadius,0.1)), sColor));\n    \n    result = opUnion(result, shuriken);\n    \n    // Trees ~ ~ ~ ~ ~\n    vec3 treePos = vec3(1.0 + iTime*gSpeed,0.0,1.0);\n    vec3 treeRep = vec3(5.0,2.0,5.0);\n    float tColor = hex(vec3(80,40,40));\n    vec2 tree = vec2(cylinder(opRepeat(cameraPos-treePos,treeRep),vec2(0.3,10.0)),tColor);\n    \n    result = opUnion(result,tree);\n    \n    // Flower petals ~ ~ ~ ~ ~\n    float pColor = hex(vec3(255,150,200));\n    vec3 petalPos = vec3(4.0+iTime*0.3, 0.0-iTime*1.0+sin(iTime)*0.4, 0.0-iTime*1.5);\n    vec3 petalRot = vec3(iTime*5.0,iTime*4.0,0.0);\n    vec3 petalRep = vec3(5.0,1.0,1.0);\n    vec2 petal = vec2(box(opRotate(opRepeat(cameraPos-petalPos,petalRep),petalRot),vec3(.005,.02,.07)),pColor);\n    \n    result = opUnion(result,petal);\n    \n    // Road ~ ~ ~ ~ ~\n    float rColor = hex(vec3(70,50,30));\n    vec3 roadPos = vec3(cameraPos.x,0,0);\n    vec2 road = vec2(box(cameraPos-roadPos,vec3(.1,.01,.5)),rColor);\n    \n    result = opUnion(result,road);\n    \n    // Ground plane ~ ~ ~ ~ ~\n   \tfloat gColor = hex(vec3(20,50,20));\n    \n   \tresult = opUnion(result, vec2(plane(cameraPos - vec3(0,0,0)), gColor));\n    \n   \treturn result;\n}\n\n\n// Function to cast and march a ray though worldspace --- o\nvec2 raycast (vec3 cameraPos, vec3 rayDir) {\n    \n    float tmin = 0.5;\t\t// Near clipping distance\n    float tmax = 20.0;\t\t// Far clipping distance\n    float precis = .002;\t// Threshold for detecting a raycast hit\n    \n    float t = tmin;\t\t\t// Start the ray distance at the minimum threshold\n    float m = -1.0;\t\t\t// Color. Assume no hit detected (color is -1.0)\n        \n    // March the ray forward 50 times. This uses distance-aided raymarching (variable step).\n    for (int i=0; i<50; i++) {\n        \n        vec2 result = scene(cameraPos + (rayDir * t));\t// Cast the ray into the scene of objects\n        if( result.x<precis || t>tmax ) break;\t\t\t// Check if the ray hit an object\n        t += result.x;\t\t\t\t\t\t\t\t\t// RESULT: The distance traveled\n\t    m = result.y;\t\t\t\t\t\t\t\t\t// RESULT: The color of the object\n    }\n\n    if (t>tmax) {m = -1.0;}\t\t// Double check if the clipping threshold has been passed\n    return vec2(t,m);\t\t\t// Return the resulting distance and base color\n}\n\n\n// Function to calculate a normal\nvec3 calcNormal (vec3 pos) {\n    vec3 epsilon = vec3 (0.001,0,0);\n\tvec3 normal = vec3(\n\t    scene(pos+epsilon.xyy).x - scene(pos-epsilon.xyy).x,\n\t    scene(pos+epsilon.yxy).x - scene(pos-epsilon.yxy).x,\n\t    scene(pos+epsilon.yyx).x - scene(pos-epsilon.yyx).x );\n\treturn normalize(normal);\n}\n\n\n// Function to calculate a shadow\nfloat shadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat result = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = scene(ro + rd*t).x;\n        result = min(result, 8.0*h/t);\n        t += clamp(h, 0.02, 0.10);\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp(result, 0.0, 1.0);\n}\n\n\n// Function to determine an output color via raycasting --- o\nvec3 render (vec3 cameraPos, vec3 rayDir, vec2 oldUV) {\n    \n    // Default to the background color\n    vec3 bgColor = vec3(0.4,0.25,0.55);\n    vec3 color = bgColor;\n    \n    // Cast the ray, and use the result to determine pixel color\n    vec2 result = raycast(cameraPos, rayDir);\n    float rayDist = result.x;\n    float baseColor = result.y;\n    \n    // If the color found is not -1.0, an object has been hit.\n    if (baseColor > -0.5 ) {\n   \t   color = rgb(baseColor);\n    }\n    else {\n    \treturn effect(oldUV); \t   \n    }\n    \n    // Calculate lighting #1: lighting vectors\n    vec3 position = cameraPos + (rayDir * rayDist);\t// Position of the surface in world space\n    vec3 normal = calcNormal(position); \t\t\t// Direction of the surface normal\n    vec3 rayReflect = reflect(rayDir,normal);\t\t// Direction of the reflected ray\n    vec3 lightDir = normalize(vec3(-2.0,2.0,-1.0));\t// Direction of the light source\n    \n    // Calculate lighting #2: components of illumination\n    float diffuse = clamp(dot(normal,lightDir),0.0,1.0);\n    diffuse *= shadow(position,normal,.5,.55);\n    float specular = pow(clamp(dot(rayReflect,lightDir),0.0,1.0),50.0);\n    \n    // Calculate lighting #3: sum the components of illumination\n    vec3 multiplier = vec3(0.0);\n    multiplier += 0.5*diffuse*vec3(1.0,1.0,1.0);\n    multiplier += 1.0*specular*bgColor*diffuse;\n    \n    // Return the final color\n    color *= multiplier;\n    return vec3(clamp(color,0.0,1.0));\n}\n\n// ------------------------------------------------------------------- o\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    \n    // Get the position of the current pixel\n\tvec2 uv = fragCoord.xy / iResolution.xy;\t// The pixel position in screen space (0 to 1)\n    vec2 pixel = -1.0 + (2.0 * uv);\t\t\t\t// The pixel position in screen space (-1 to 1)\n\tpixel.x *= iResolution.x/iResolution.y;\t\t// The pixel position adjusted for aspect ratio\n    \n    // Create a camera\n    vec3 cameraPos = vec3(3.5,2.0,-3.0);\t// The position of the camera\n    vec3 cameraTarget = vec3(0,1.5,0);\t\t// The point at which the camera looks\n    float cameraRot = 0.0;\t\t\t\t\t// The rotation of the camera lens\n    float FOV = 2.5;\t\t\t\t\t\t// The field of view multiplier\n    \n    // Create a camera matrix in world space\n    mat3 camera = setCamera(cameraPos,cameraTarget,cameraRot);\n    \n    // Get the direction of the ray from the current pixel\n    vec3 rayDir = camera * normalize(vec3(pixel.xy,FOV));\n    \n    // Cast the ray and return a color based on the result (render)\n    vec2 extra = vec2(uv.x*iResolution.x/iResolution.y,uv.y);\n    vec3 color = render(cameraPos,rayDir,extra);\n    \n    // Set the color of the pixel on screen\n    fragColor = vec4(color,1.0);\n}","name":"","description":"","type":"image"}]}