{"ver":"0.1","info":{"id":"wdsSz7","date":"1551103037","viewed":92,"name":"MCG: skeletal animation","username":"tale3d","description":"We have not learnt 3D geometry yet, so this example is about compound transformations used in character animation.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["teachingmaterial"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Find the distance to the segment\n//This function has some mathematics which we have not discussed yet\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n//The idea behind distance to segment algorithm is the following: \n//  given the points AB for segment and query point P, we project vector AP to the vector AB. \n    vec2 ab = b - a, ap = p - a;\n    \n//However, we do not use explicit projection formula, but just scalar factor which we would multiply by vector AB. \n    float t = dot(ab, ap) / dot(ab, ab);\n//We need that to check if the projected point lies inside the segment and therefore t is in [0,1]\n//   but if it does not, we find the closest point to the segment by ensuring t is in [0,1]\n    if (t < 0.0) t = 0.0;\n    if (t > 1.0) t = 1.0; //we can also use \"clamp\" function in GLSL language\n    \n//Here we find the distance from point P to the segment AB\n    float distance = length(ap - ab*t);\n\n//For visiualisation purposes we re-map it to make the resulting shape to look like an arrow, not a straight line\n    t = 0.2+0.8*t;\n//If we wanted to draw just a segment, we would return distance. But we want to draw a joint, so we multiply by a coefficient we discussed above    \n    return distance*t;\n}\n\n//Translation matrix as in the previous example\nmat3 matTranslate(in float tx, in float ty)\n{\n    //in GLSL we use column-major matrices, so fill the one column by column\n    return mat3(1.0,0.0,0.0,0.0,1.0,0.0,tx,ty,1.0);\n}\n//Rotation matrix as in the previous example\nmat3 matRotate(in float angle)\n{\n    float sa = sin(angle), ca = cos(angle);\n    //in GLSL we use column-major matrices, so fill the one column by column\n    return mat3(ca,sa,0.0,-sa,ca,0.0,0.0,0.0,1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //////////////////////////////////////////////////////\n    //Starting the common section\n    //The lines above are the same for most of the examples. \n    //Basically it is a mapping between pixel coordinates and world coordinates.\n    //We discuss coordinates systems soon. \n    //\n    //taking pixel coordinates in the uv space, range [0,1]\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    //map pixel coordinates to [-1,1]\n    vec2 c = 2.0 * uv - 1.0;\n    //adjust coordinates given an aspect ratio\n    float aspect_ratio = iResolution.x/iResolution.y;\n    c.x *= aspect_ratio;\n    //\n    //End of the common section\n    ///////////////////////////////////////////////////////\n\n    //Adding more to the common section:\n    //This example has a mouse as an input device.\n    //The mouse coordinates are taking in uv space, and then is modified in the same way\n    //  as the pixel coordinates (see above). \n    vec2 mouse = 2.0*(iMouse.xy / iResolution.xy) - vec2(1.0,1.0);\n    mouse.x *= aspect_ratio;\n\n\n    //Background colour (default)\n    vec3 colour = vec3(1.0,1.0,1.0);\n\n\t//Here we set up local transformation for every joint. For joint 1 it is dynamic shift.    \n    mat3 loc1 = matTranslate(0.2*sin(iTime), 0.1);\n    \n    //For all other joint we have static shift and dynamic rotation. Note that we move first and then rotate, \n    //    so matrices are multiplied in the reverse order.\n    mat3 loc2 = matRotate(iTime)*matTranslate(0.5, 0.0);\n    mat3 loc3 = matRotate(-iTime*0.5)*matTranslate(0.0,0.2);\n    mat3 loc4a = matRotate(iTime*1.7)*matTranslate(0.3,0.2);\n    mat3 loc4b = matRotate(iTime*2.2)*matTranslate(0.2,-0.1);\n    \n    //Now we calculate the global transformations for our joints\n    mat3 abs1 = loc1;\n    //We find position of the point (0,0) after transformation for each joint to visualise where the joints are.\n    //In actual skeletal animation we only keep transformation matrices. \n\tvec3 joint1 = abs1*vec3(0.0,0.0,1.0);\n    mat3 abs2 = abs1*loc2;\n    vec3 joint2 = abs2*vec3(0.0,0.0,1.0);\n    mat3 abs3 = abs2*loc3;\n    vec3 joint3 = abs3*vec3(0.0,0.0,1.0);\n    mat3 abs4a = abs3*loc4a;\n    vec3 joint4a = abs4a*vec3(0.0,0.0,1.0);\n    mat3 abs4b = abs3*loc4b;\n    vec3 joint4b = abs4b*vec3(0.0,0.0,1.0);\n\n\n    //Now we draw our segments by finding the distance to the joints from our current point \n    //    and checking if the distance within limits\n    \n    //Note that I am using here conversion from vec3 to vec2 by using internal GLSL .xy function, \n    //   which returns first two fields of vec3 as vec2\n    float segment1 = segment(c, joint1.xy, joint2.xy);\n    if (segment1 < 0.01) colour = vec3(0.0,0.0,1.0);\n    float segment2 = segment(c, joint2.xy, joint3.xy);\n    if (segment2 < 0.01) colour = vec3(0.0,1.0,1.0);\n    float segment3a = segment(c, joint3.xy, joint4a.xy);\n    if (segment3a < 0.01) colour = vec3(1.0,0.0,1.0);\n    float segment3b = segment(c, joint3.xy, joint4b.xy);\n    if (segment3b < 0.01) colour = vec3(1.0,0.0,0.0);\n\n\n    //This is it, colour the pixel and see what we get.\n    fragColor = vec4(colour,1.0);\n\n\n}","name":"Image","description":"","type":"image"}]}