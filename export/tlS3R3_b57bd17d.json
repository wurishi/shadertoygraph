{"ver":"0.1","info":{"id":"tlS3R3","date":"1560439735","viewed":516,"name":"Scene changing by time","username":"edo_m18","description":"Scene changing by time","likes":7,"published":1,"flags":64,"usePreview":0,"tags":["time","scene","changing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XlsGRj","filepath":"https://soundcloud.com/elektrik-dreams-music/nicola-cite-borderline-original-mix-out-now-on-beatport","previewfilepath":"https://soundcloud.com/elektrik-dreams-music/nicola-cite-borderline-original-mix-out-now-on-beatport","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// -----------------------------------------------\n// Scene 1\nMaterial sdBoxS(vec3 p, vec3 b)\n{\n    float d = length(max(abs(p) - b, 0.0));\n    Material m;\n    m.d = d;\n    m.t = 1;\n    return m;\n}\n\nMaterial sdPlaneS(vec3 p, vec4 n)\n{\n    float d = dot(p, n.xyz) + n.w;\n    Material m;\n    m.d = d;\n    m.t = 0;\n    return m;\n}\n\nMaterial map1(vec3 p)\n{\n    vec3 q = -abs(p);\n    q.y += 1.5;\n    \n    Material m1 = sdPlaneS(q, vec4(0, 1, 0, 1));\n    \n    float i = texture(iChannel0, vec2(0.1, 0.5)).x;\n    float rad = iTime * PI * 0.5;\n    q = Rotate(p, rad, vec3(1));\n    Material m2 = sdBoxS(q, vec3(2.5 * i));\n    \n    return Add(m1, m2);\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec2 e = vec2(0.0001, 0);\n    Material m = map1(p);\n    vec3 n = m.d - vec3(\n        map1(p - e.xyy).d,\n        map1(p - e.yxy).d,\n        map1(p - e.yyx).d);\n    return normalize(n);\n}\n\nfloat hexDist(vec2 p)\n{\n    p = abs(p);\n    \n    float c = dot(p, normalize(vec2(1., 1.73)));\n    \n    return max(c, p.x);\n}\n\nvec4 hexCoords(vec2 uv)\n{\n    vec2 r = vec2(1., 1.73);\n    vec2 h = r * 0.5;\n    vec2 a = mod(uv, r) - h;\n    vec2 b = mod(uv - r * 0.5, r) - h;\n    vec2 gv = length(a) < length(b) ? a : b;\n    \n    vec2 id = gv - uv;\n    \n    float x = atan(gv.x, gv.y);\n    float y = 0.5 - hexDist(gv);\n    \n    return vec4(x, y, id);\n}\n\nvoid scene1( out vec4 O, in vec2 U )\n{\n    vec2 uv = (U - 0.5 * iResolution.xy) / iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    float time = iTime * 0.3;\n    float dist = 20.0;\n    vec3 ro = vec3(cos(time) * dist, 0, sin(time) * dist);\n    vec3 ta = vec3(0, 0, 0);\n    \n    vec3 up = normalize(vec3(0, 1, 0));\n    vec3 ray = camera(ro, ta, up) * normalize(vec3(uv, 1.5));\n    \n    const int max_march = 128;\n    \n    vec3 p = ro;\n    \n    float t = 0.0;\n    Material m;\n    for (int i = 0; i < max_march; i++)\n    {\n        m = map1(p);\n        \n        if (m.d < 0.01) break;\n        \n        p += ray * m.d;\n        t += m.d;\n    }\n    \n    if (m.d < 0.01)\n    {\n        if (m.t == 0)\n        {\n            vec2 st = p.xz;\n            vec4 hc = hexCoords(st);\n        \n            float time = iTime * 5.0;\n\n            float l = pow(sin((length(hc.zw) - time) * 0.3), 4.0);\n\n            vec3 c = vec3(S(0.01, 0.03, hc.y));\n\n            float f = exp(-t * 0.08);\n\n            col.rgb = c * l * f;\n        }\n        else if (m.t == 1)\n        {\n            vec3 n = getNormal(p);\n            vec3 light = normalize(vec3(1));\n            float diff = clamp(dot(n, light), 0.1, 1.0);\n            col = vec3(diff) * n;\n        }\n    }\n\n    vec3 fog = vec3(0.5, 0.7, 1.5) * t * 0.015;\n    \n    O = vec4(col + fog,1.0);\n}\n\n// Scene 1\n// --------------------------------------------------\n\n\n// --------------------------------------------------\n// Scene 2\n\nfloat map(vec3 p)\n{\n    float i = texture(iChannel0, vec2(0.1, 0.5)).x;\n    \n    float h = 1.8;\n    float grid = 1.3;\n    \n    vec3 g = ceil(p / grid);\n    \n    float rxz = rand(g.xz) * i;\n    \n    p = -abs(p);\n    \n    float d1 = p.y + h + rxz;\n    float d2 = p.x + h * 0.6;\n    \n    vec3 q = Repeat(p, vec3(grid));\n    float dc = sdCylinder(q, vec3(0.1, 0.0, .5));\n    return max(max(d1, dc), d2);\n}\n\n\nvoid scene2( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    vec3 ro = vec3(cos(iTime * 0.1), sin(iTime * 0.1), iTime * 5.);\n    vec3 ta = vec3(cos(iTime), sin(iTime), iTime * 5. + 10.);\n    \n    vec3 up = normalize(vec3(0.5, 1.0, 0.0));\n    vec3 ray = camera(ro, ta, up) * normalize(vec3(uv, 1.5));\n    \n    float d = 0., t = 0.;\n    \n    vec3 p = ro;\n    \n    const int MAX_MARCH = 128;\n    int march = 0;\n    for (int i = 0; i < MAX_MARCH; i++)\n    {\n        d = map(p);\n        \n        march = i;\n        \n        if (d < 0.01) break;\n        \n        p += ray * d;\n        t += d;\n    }\n    \n    vec3 col = vec3(0);\n    \n    if (d < 0.01)\n    {\n        vec3 n = getNormal(p);\n        float v = max(0., dot(n, -ray));\n        col = vec3(v);\n    }\n    \n    float fog = min(1.0, (1.0 / float(MAX_MARCH)) * float(march));\n    vec3 rgb = hue2rgb(sin(iTime * 0.1));\n    vec3 fog2 = t * 0.01 * rgb;\n    col = col * fog + fog2;\n    fragColor = vec4(col, 1.0);\n}\n// Scene 2\n// --------------------------------------------------\n\n\n// --------------------------------------------------\n// Scene 3\n#define R iResolution\n\nfloat burn;\n\nmat2 rot(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    \n    return mat2(s, c, -c, s);\n}\n\nfloat map3(vec3 p)\n{\n    float i = texture(iChannel0, vec2(0.3, 0.5)).x;\n    \n    float d1 = length(p) - 1. * i;\n    \n    //mat2 r = rot(-iTime / 3.0 + length(p));\n    mat2 r = rot(iTime * 2.0 + length(p));\n    p.xy *= r;\n    p.zy *= r;\n    \n    p = abs(p);// - iTime;\n    p = abs(p - round(p)) *  2.5 * i;\n    \n    //r = rot(iTime);\n    //p.xy *= r;\n    //p.xz *= r;\n    \n    float l1 = length(p.xy);\n    float l2 = length(p.yz);\n    float l3 = length(p.xz);\n    \n    float g = 0.01;\n    float d2 = min(min(l1, l2), l3) + g;\n    \n    burn = pow(d2 - d1, 2.0);\n    \n    return min(d1, d2);\n}\n\nvoid scene3( out vec4 O, in vec2 U )\n{\n    vec2 uv = (2.0 * U - R.xy) / R.y;\n    vec3 ro = normalize(vec3(uv, 1.5));\n    \n    vec3 ta = vec3(0, 0, -2);\n    \n    float t = 0.;\n    for  (int i = 0; i < 30; i++)\n    {\n        t += map3(ta + ro * t) * 0.5;\n    }\n\n    O = vec4(1.0 - burn, 0, exp(-t), 1.0);\n}\n// Scene 3\n// --------------------------------------------------\n\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n\tfloat span = 5.;\n    float sceneCount = 3.0;\n    float idx = mod(iTime / span, sceneCount);\n    \n    if (idx < 1.0)\n    {\n        scene1(O, U);\n    }\n    else if (idx < 2.0)\n    {\n        scene2(O, U);\n    }\n    else if (idx < 3.0)\n    {\n        scene3(O, U);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define S(a, b, t) smoothstep(a, b, t)\n#define PI 3.14159265358979\n\n#define Repeat(p, span) mod(p, span) - (0.5 * span)\n\nfloat rand(vec3 p)\n{\n    return fract(sin(dot(p, vec3(43.5824, 17.394, 30.234)) * 41345.3431));\n}\n\nfloat rand(vec2 p)\n{\n    return fract(sin(dot(p, vec2(43.5824, 17.394)) * 41345.3431));\n}\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0 );\n\treturn c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvec3 hue2rgb(float h)\n{\n    return clamp(abs(mod(h * 6. + vec3(0, 4, 2), 6.) - 3.) - 1., 0., 1.);\n}\n\nvec3 Rotate(vec3 p, float angle, vec3 axis) {\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nmat3 camera(vec3 ro, vec3 ta, vec3 up)\n{\n    vec3 cw = normalize(ta - ro);\n    vec3 cu = normalize(cross(cw, up));\n    vec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nstruct Material\n{\n    // distance\n    float d;\n    \n    // type\n    int t;\n};\n\nMaterial Add(Material a, Material b)\n{\n\tif (a.d < b.d)\n    {\n        return a;\n    }\n    else\n    {\n        return b;\n    }\n}\n\n\nMaterial And(Material a, Material b)\n{\n    if( a.d < b.d)\n    {\n        return b;\n    }\n    else\n    {\n        return a;\n    }\n}\n\n// ----------------------\n// distance functions\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    return length(max(abs(p) - b, 0.0));\n}\n\nfloat sdPlane(vec3 p, vec4 n)\n{\n    return dot(p, n.xyz) + n.w;\n}\n\nfloat sdCylinder(vec3 p, vec3 c)\n{\n    return length(p.xz - c.xy) - c.z;\n}\n\nfloat sdPlanes(vec3 p)\n{\n    p = abs(p);\n    \n    return max(max(p.x, p.y), p.z) - 0.5;\n}","name":"Common","description":"","type":"common"}]}