{"ver":"0.1","info":{"id":"MdBBDc","date":"1502468936","viewed":174,"name":"Chimney Thing","username":"TinyTexel","description":"camera controls via mouse + shift key\nlight controls via WASD","likes":4,"published":1,"flags":48,"usePreview":0,"tags":["shader"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// \n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by TinyTexel\n\n/*\n\ncamera controls via mouse + shift key\nlight controls via WASD\n*/\n\n#define Time iTime\n#define Frame iGlobalFrame\n#define PixelCount iResolution.xy\n#define clamp01(x) clamp(x, 0.0, 1.0)\n\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 uv = floor(fragCoord.xy);\n\tvec2 tex = fragCoord.xy / PixelCount;\n    \n    vec3 col = textureLod(iChannel0, tex, 0.0).rgb;\n    \n    col = 1.0 - exp2(-col * 2.0 * 2.0);\n    col = mix(col, col*col, 0.5);\n    //col += vec3(100.0);\n    \n    fragColor = vec4(GammaEncode(clamp01(col)), 0.0);\n    //fragColor = vec4(col, 0.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// \n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by TinyTexel\n\n/*\n\ncamera controls via mouse + shift key\nlight controls via WASD\n*/\n\n///////////////////////////////////////////////////////////////////////////\n//=======================================================================//\n\n#define Frame float(iFrame)\n#define Time iTime\n#define PixelCount iResolution.xy\n#define OUT\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nfloat Root4(float x) {return rsqrt(rsqrt(x));}\n\nfloat Length3(vec2 vec) {return pow(Pow3(vec.x) + Pow3(vec.y), 1.0/3.0);}\nfloat Length3(vec3 vec) {return pow(Pow3(vec.x) + Pow3(vec.y) + Pow3(vec.z), 1.0/3.0);}\n\nfloat Length4(vec2 vec) {return Root4(Pow4(vec.x) + Pow4(vec.y));}\nfloat Length4(vec3 vec) {return Root4(Pow4(vec.x) + Pow4(vec.y) + Pow4(vec.z));}\n\nvec2 CosSin(float ang) {return vec2(cos(ang), sin(ang));}\n\nvec3 AngToVec(vec2 ang)\n{\n    float sinPhi   = sin(ang.x);\n    float cosPhi   = cos(ang.x);\n    float sinTheta = sin(ang.y);\n    float cosTheta = cos(ang.y);    \n\n    return vec3(cosPhi * cosTheta, \n                         sinTheta, \n                sinPhi * cosTheta); \n}\n\nvoid NormAndNormalize(vec3 vec, out float len, out vec3 dir)//TODO: fix nans\n{\n\tfloat sqrLen = dot(vec, vec);\n\tfloat rcpLen = rsqrt(sqrLen);\n\t\n\tlen = sqrLen * rcpLen;\n\tdir = vec * rcpLen;\n}\n\nfloat SqrLen(float v) {return v * v;}\nfloat SqrLen(vec2  v) {return dot(v, v);}\nfloat SqrLen(vec3  v) {return dot(v, v);}\nfloat SqrLen(vec4  v) {return dot(v, v);}\n\nfloat GammaEncode(float x) {return pow(x, 1.0 / 2.2);}\nvec2 GammaEncode(vec2 x) {return pow(x, vec2(1.0 / 2.2));}\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\nvec4 GammaEncode(vec4 x) {return pow(x, vec4(1.0 / 2.2));}\n\n#define KEY_LEFT  37\n#define KEY_UP    38\n#define KEY_RIGHT 39\n#define KEY_DOWN  40\n\n#define KEY_SHIFT 0x10\n#define KEY_A 0x41\n#define KEY_D 0x44\n#define KEY_S 0x53\n#define KEY_W 0x57\n\n#define KeyBoard iChannel1\n\nfloat ReadKey(int keyCode) {return texelFetch(KeyBoard, ivec2(keyCode, 0), 0).x;}\n\n\n#define VarTex iChannel0\n#define OutCol outCol\n#define OutChannel w\n\n#define WriteVar(v, cx, cy) {if(uv.x == float(cx) && uv.y == float(cy)) OutCol.OutChannel = v;}\n#define WriteVar4(v, cx, cy) {WriteVar(v.x, cx, cy) WriteVar(v.y, cx, cy + 1) WriteVar(v.z, cx, cy + 2) WriteVar(v.w, cx, cy + 3)}\n\nfloat ReadVar(int cx, int cy) {return texelFetch(VarTex, ivec2(cx, cy), 0).OutChannel;}\nvec4 ReadVar4(int cx, int cy) {return vec4(ReadVar(cx, cy), ReadVar(cx, cy + 1), ReadVar(cx, cy + 2), ReadVar(cx, cy + 3));}\n\n\n// single iteration of Bob Jenkins' One-At-A-Time hashing algorithm:\n//  http://www.burtleburtle.net/bob/hash/doobs.html\n// suggested by Spatial on stackoverflow:\n//  http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\nuint BJXorShift(uint x) \n{\n    x += x << 10u;\n    x ^= x >>  6u;\n    x += x <<  3u;\n    x ^= x >> 11u;\n    x += x << 15u;\n\t\n    return x;\n}\n\n\n// xor-shift algorithm by George Marsaglia\n//  https://www.thecodingforums.com/threads/re-rngs-a-super-kiss.704080/\n// suggested by Nathan Reed:\n//  http://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/\nuint GMXorShift(uint x)\n{\n    x ^= x << 13u;\n    x ^= x >> 17u;\n    x ^= x <<  5u;\n    \n    return x;\n}\n\n// hashing algorithm by Thomas Wang \n//  http://www.burtleburtle.net/bob/hash/integer.html\n// suggested by Nathan Reed:\n//  http://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/\nuint WangHash(uint x)\n{\n    x  = (x ^ 61u) ^ (x >> 16u);\n    x *= 9u;\n    x ^= x >> 4u;\n    x *= 0x27d4eb2du;\n    x ^= x >> 15u;\n    \n    return x;\n}\n\n#define Hash WangHash\n\n// \"floatConstruct\"          | renamed to \"ConstructFloat\" here \n// By so-user Spatial        | http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n// used under CC BY-SA 3.0   | https://creativecommons.org/licenses/by-sa/3.0/             \n// reformatted and changed from original to extend interval from [0..1) to [-1..1) \n//-----------------------------------------------------------------------------------------\n// Constructs a float within interval [-1..1) using the low 23 bits + msb of an uint.\n// All zeroes yields -1.0, all ones yields the next smallest representable value below 1.0. \nfloat ConstructFloat(uint m) \n{\n\tfloat flt = uintBitsToFloat(m & 0x007FFFFFu | 0x3F800000u);// [1..2)\n    float sub = (m >> 31u) == 0u ? 2.0 : 1.0;\n    \n    return flt - sub;// [-1..1)             \n}\n\nvec2 ConstructFloat(uvec2 m) { return vec2(ConstructFloat(m.x), ConstructFloat(m.y)); }\nvec3 ConstructFloat(uvec3 m) { return vec3(ConstructFloat(m.xy), ConstructFloat(m.z)); }\nvec4 ConstructFloat(uvec4 m) { return vec4(ConstructFloat(m.xyz), ConstructFloat(m.w)); }\n\n\nuint Hash(uint  v, uint  r) { return Hash(v ^ r); }\nuint Hash(uvec2 v, uvec2 r) { return Hash(Hash(v.x , r.x ) ^ (v.y ^ r.y)); }\nuint Hash(uvec3 v, uvec3 r) { return Hash(Hash(v.xy, r.xy) ^ (v.z ^ r.z)); }\nuint Hash(uvec4 v, uvec4 r) { return Hash(Hash(v.xy, r.xy) ^ Hash(v.zw, r.zw)); }\n\n// Pseudo-random float value in interval [-1:1).\nfloat Hash(float v, uint  r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\nfloat Hash(vec2  v, uvec2 r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\nfloat Hash(vec3  v, uvec3 r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\nfloat Hash(vec4  v, uvec4 r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\n\n\nfloat HashFlt(uint   v, uint  r) { return ConstructFloat(Hash(v, r)); }\nfloat HashFlt(uvec2  v, uvec2 r) { return ConstructFloat(Hash(v, r)); }\nfloat HashFlt(uvec3  v, uvec3 r) { return ConstructFloat(Hash(v, r)); }\nfloat HashFlt(uvec4  v, uvec4 r) { return ConstructFloat(Hash(v, r)); }\n\nuint HashUInt(float v, uint  r) { return Hash(floatBitsToUint(v), r); }\nuint HashUInt(vec2  v, uvec2 r) { return Hash(floatBitsToUint(v), r); }\nuint HashUInt(vec3  v, uvec3 r) { return Hash(floatBitsToUint(v), r); }\nuint HashUInt(vec4  v, uvec4 r) { return Hash(floatBitsToUint(v), r); }\n//=======================================================================//\n///////////////////////////////////////////////////////////////////////////\n\nstruct Cam\n{\n\tvec3 Front, Right, Up;\n\tfloat Aspect;\n\tfloat AxisLen;\t\n};\n\nCam NewCam(vec2 ang, float fov, float aspect)\n{\n    Cam cam;\n\n    float sinPhi   = sin(ang.x);\n    float cosPhi   = cos(ang.x);\n    float sinTheta = sin(ang.y);\n    float cosTheta = cos(ang.y);    \n\n    cam.Front = vec3(cosPhi * cosTheta, \n                              sinTheta, \n                     sinPhi * cosTheta);\n\n    cam.Right = vec3(-sinPhi, 0.0, cosPhi);\n    cam.Up    = cross(cam.Right, cam.Front);\n\n    cam.Aspect = aspect;\n    cam.AxisLen = aspect * tan(Pi05 - fov * 0.5);\n\n    return cam;\n}\n\n// tc [-1..1]\nvec3 NewRay(Cam cam, vec2 tc)\n{\n    tc.x *= cam.Aspect;\n\n    vec3 imgPos = cam.Front * cam.AxisLen + (cam.Right * tc.x + cam.Up * tc.y);\n    \n    vec3 dir = normalize(imgPos);\n\n    return dir;\n}\n\n\n/*\nIN:\n\trp\t\t: ray start position\n\trd\t\t: ray direction (normalized)\n\t\n\tcp\t\t: cube position\n\tcth\t\t: cube thickness (cth = 0.5 -> unit cube)\n\t\nOUT:\n\tt\t\t: distances to intersection points (negative if in backwards direction)\n\nEXAMPLE:\t\n\tvec2 t;\n\tfloat hit = Intersect_Ray_Cube(pos, dir, vec3(0.0), vec3(0.5), OUT t);\n*/\nfloat Intersect_Ray_Cube(\nvec3 rp, vec3 rd, \nvec3 cp, vec3 cth, \nout vec2 t)\n{\t\n\trp -= cp;\n\t\n\tvec3 m = 1.0 / -rd;\n\tvec3 o = If(lessThan(rd, vec3(0.0)), -cth, cth);\n\t\n\tvec3 uf = (rp + o) * m;\n\tvec3 ub = (rp - o) * m;\n\t\n\tt.x = max(uf.x, max(uf.y, uf.z));\n\tt.y = min(ub.x, min(ub.y, ub.z));\n\t\n\t// if(ray start == inside cube) \n\tif(t.x < 0.0 && t.y > 0.0) {t.xy = t.yx;  return 1.0;}\n\t\n\treturn t.y < t.x ? 0.0 : (t.x > 0.0 ? 1.0 : -1.0);\n}\n\n/*\n[...]\n\nOUT:\n\tn0 : normal for t.x\n\tn1 : normal for t.y\n\nEXAMPLE:\t\n\tvec2 t; vec3 n0, n1;\n\tfloat hit = Intersect_Ray_Cube(pos, dir, vec3(0.0), vec3(0.5), OUT t, n0, n1);\n*/\nfloat Intersect_Ray_Cube(\nvec3 rp, vec3 rd, \nvec3 cp, vec3 cth, \nout vec2 t, out vec3 n0, out vec3 n1)\n{\t\n\trp -= cp;\n\t\n\tvec3 m = 1.0 / -rd;\n    vec3 os = If(lessThan(rd, vec3(0.0)), vec3(1.0), vec3(-1.0));\n    //vec3 os = sign(-rd);\n\tvec3 o = -cth * os;\n\t\n    \n\tvec3 uf = (rp + o) * m;\n\tvec3 ub = (rp - o) * m;\n\t\n\t//t.x = max(uf.x, max(uf.y, uf.z));\n\t//t.y = min(ub.x, min(ub.y, ub.z));\n\t\n    if(uf.x > uf.y) {t.x = uf.x; n0 = vec3(os.x, 0.0, 0.0);} else \n                    {t.x = uf.y; n0 = vec3(0.0, os.y, 0.0);}\n    if(uf.z > t.x ) {t.x = uf.z; n0 = vec3(0.0, 0.0, os.z);}\n    \n    if(ub.x < ub.y) {t.y = ub.x; n1 = vec3(os.x, 0.0, 0.0);} else \n                    {t.y = ub.y; n1 = vec3(0.0, os.y, 0.0);}\n    if(ub.z < t.y ) {t.y = ub.z; n1 = vec3(0.0, 0.0, os.z);}\n    \n    \n\t// if(ray start == inside cube) \n\tif(t.x < 0.0 && t.y > 0.0) \n    {\n        t.xy = t.yx;  \n        \n        vec3 n00 = n0;\n        n0 = n1;\n        n1 = n00;\n        \n        return 1.0;\n    }\n\t\n\treturn t.y < t.x ? 0.0 : (t.x > 0.0 ? 1.0 : -1.0);\n}\n\n/*\nIN:\n\trp\t\t: ray start position\n\trd\t\t: ray direction (normalized)\n\t\n\tsp2\t\t: sphere position\n\tsr2\t\t: sphere radius squared\n\t\nOUT:\n\tt\t\t: distances to intersection points (negative if in backwards direction)\n\nEXAMPLE:\t\n\tvec2 t;\n\tfloat hit = Intersect_Ray_Sphere(pos, dir, vec3(0.0), 1.0, OUT t);\n*/\nfloat Intersect_Ray_Sphere(\nvec3 rp, vec3 rd, \nvec3 sp, float sr2, \nout vec2 t)\n{\t\n\trp -= sp;\n\t\n\tfloat a = dot(rd, rd);\n\tfloat b = 2.0 * dot(rp, rd);\n\tfloat c = dot(rp, rp) - sr2;\n\t\n\tfloat D = b*b - 4.0*a*c;\n\t\n\tif(D < 0.0) return 0.0;\n\t\n\tfloat sqrtD = sqrt(D);\n\t// t = (-b + (c < 0.0 ? sqrtD : -sqrtD)) / a * 0.5;\n\tt = (-b + vec2(-sqrtD, sqrtD)) / a * 0.5;\n\t\n\t// if(start == inside) ...\n\tif(c < 0.0) t.xy = t.yx;\n\n\t// t.x > 0.0 || start == inside ? infront : behind\n\treturn t.x > 0.0 || c < 0.0 ? 1.0 : -1.0;\n}\n\n\n/*\nSOURCE: \n\t\"Building an Orthonormal Basis from a 3D Unit Vector Without Normalization\"\n\t\thttp://orbit.dtu.dk/files/126824972/onb_frisvad_jgt2012_v2.pdf\n\t\t\n\t\"Building an Orthonormal Basis, Revisited\" \n\t\thttp://jcgt.org/published/0006/01/01/\n\t\n\t- modified for right-handedness here\n\t\nDESCR:\n\tConstructs a right-handed, orthonormal coordinate system from a given vector of unit length.\n\nIN:\n\tn  : normalized vector\n\t\nOUT:\n\tox\t: orthonormal vector\n\toz\t: orthonormal vector\n\t\nEXAMPLE:\n\tfloat3 ox, oz;\n\tOrthonormalBasis(N, OUT ox, oz);\n*/\nvoid OrthonormalBasisRH(vec3 n, out vec3 ox, out vec3 oz)\n{\n\tfloat sig = n.z < 0.0 ? 1.0 : -1.0;\n\t\n\tfloat a = 1.0 / (n.z - sig);\n\tfloat b = n.x * n.y * a;\n\t\n\tox = vec3(1.0 + sig * n.x * n.x * a, sig * b, sig * n.x);\n\toz = vec3(b, sig + n.y * n.y * a, n.y);\n}\n\n// s0 [-1..1], s1 [-1..1]\n// samples spherical cap for s1 [cosAng05..1]\n// samples hemisphere if s1 [0..1]\nvec3 Sample_Sphere(float s0, float s1)\n{\n    float ang = Pi * s0;\n    float s1p = sqrt(1.0 - s1*s1);\n    \n    return vec3(cos(ang) * s1p, \n                           s1 , \n                sin(ang) * s1p);\n}\n\n// s0 [-1..1], s1 [-1..1]\n// samples spherical cap for s1 [cosAng05..1]\nvec3 Sample_Sphere(float s0, float s1, vec3 normal)\n{\t \n    vec3 sph = Sample_Sphere(s0, s1);\n\n    vec3 ox, oz;\n    OrthonormalBasisRH(normal, ox, oz);\n\n    return (ox * sph.x) + (normal * sph.y) + (oz * sph.z);\n}\n\n// s0 [-1..1], s1 [-1..1]\nvec3 Sample_Hemisphere(float s0, float s1, vec3 normal)\n{\n    vec3 smpl = Sample_Sphere(s0, s1);\n\n    if(dot(smpl, normal) < 0.0)\n        return -smpl;\n    else\n        return smpl;\n}\n\n// s0 [-1..1], s1 [0..1]\nvec2 Sample_Disk(float s0, float s1)\n{\n    return vec2(cos(Pi * s0), sin(Pi * s0)) * sqrt(s1);\n}\n\n// s0 [-1..1], s1 [0..1]\nvec3 Sample_ClampedCosineLobe(float s0, float s1)\n{\t \n    vec2 d  = Sample_Disk(s0, s1);\n    float y = sqrt(clamp01(1.0 - s1));\n    \n    return vec3(d.x, y, d.y);\n}\n\n// s0 [-1..1], s1 [0..1]\nvec3 Sample_ClampedCosineLobe(float s0, float s1, vec3 normal)\n{\t \n    vec2 d  = Sample_Disk(s0, s1);\n    float y = sqrt(clamp01(1.0 - s1));\n\n    vec3 ox, oz;\n    OrthonormalBasisRH(normal, ox, oz);\n\n    return (ox * d.x) + (normal * y) + (oz * d.y);\n}\n\n// s [-1..1]\nfloat Sample_Triangle(float s) \n{ \n    float v = 1.0 - sqrt(abs(s));\n    \n    return s < 0.0 ? -v : v; \n}\n\n\nfloat func(vec3 x);\n\nvec3 GradientCD(vec3 x, float o)\n{\n\tfloat xn = func(vec3(x.x - o, x.y, x.z));\n\tfloat xp = func(vec3(x.x + o, x.y, x.z));\n\t\n\tfloat yn = func(vec3(x.x, x.y - o, x.z));\n\tfloat yp = func(vec3(x.x, x.y + o, x.z));\n\t\n\tfloat zn = func(vec3(x.x, x.y, x.z - o));\n\tfloat zp = func(vec3(x.x, x.y, x.z + o));\n\t\n\tvec3 g = vec3(xp - xn, yp - yn, zp - zn) / o * 0.5;\n\t\n\treturn g;\n}\n\nvec3 GradientCD(vec3 x)\n{\n    return GradientCD(x, 0.0001);\n}\n\nvec3 GradientFD(vec3 x, float o)\n{\n\tx -= o * 0.5;\n\tfloat c = func(x);\n\t// c = 0.0;\n    \n\tfloat xp = func(vec3(x.x + o, x.y, x.z));\n\tfloat yp = func(vec3(x.x, x.y + o, x.z));\n\tfloat zp = func(vec3(x.x, x.y, x.z + o));\n\t\n\tvec3 g = vec3(xp - c, yp - c, zp - c) / o;\n\t\n\treturn g;\n}\n\nvec3 GradientFD(vec3 x)\n{\n    return GradientFD(x, 0.0001);\n}\n\nbool ImplicitRC(\nfloat funcScale,\nvec3 x, \nvec3 dir, \nfloat linCount,\nfloat binCount,\nfloat stepSize,\nfloat stepOffPercent,\nout float t0, out float tm, out float t1)\n{\n\tbool hit = false;\n\n    t0 = tm = 0.0;\n    \n    #if 0\n    t1 = -stepSize * stepOffPercent;\n\t\n\tfor(float i = 0.0; i < linCount; ++i)\n\t{\t\n\t\tt1 += stepSize;\n\n        vec3 p = x + dir * t1;\n        \n        hit = func(p) * funcScale < 0.0;\n\t\t\n        if(hit) {i=linCount;}\n        else\n        t0 = t1;\n\t}\n\t#else\n    float stepSizeAdd = 0.004;\n    float minStepSize = min(0.00, stepSize);\n    \n    stepSize = max(minStepSize, abs(func(x)) + stepSizeAdd);\n    \n    t1 = -stepSize * stepOffPercent*1.0;\n\t//t1 = 0.0;\n    \n\tfor(float i = 0.0; i < linCount; ++i)\n\t{\t\n\t\tt1 += stepSize;\n\n        vec3 p = x + dir * t1;\n        \n        float f = func(p) * funcScale;\n        \n        stepSize = max(minStepSize, abs(f) + stepSizeAdd);\n        //stepSize = 0.02;\n        \n        hit = f < 0.0;\n\t\t\n        if(hit) {i=linCount;}\n        else{\n        t0 = t1;\n        //t1 += stepSize;\n            }\n\t}\n    #endif\n    \n\tif(hit)\n    {\n        #if 1\n        for(float i = 0.0; i < binCount; ++i)\n\t\t{\n\t\t\ttm = (t0 + t1) * 0.5;\n\t\t\t\n            vec3 p = x + dir * tm;\n            \n\t\t\tif(func(p) * funcScale < 0.0)\n\t\t\tt1 = tm;\n\t\t\telse\n\t\t\tt0 = tm;\n\t\t}\n        \n        vec3 p0 = x + dir * t0;\n        vec3 p1 = x + dir * t1;\n        \n        float f0 = func(p0) * funcScale;\n        float f1 = func(p1) * funcScale;\n        \n        float div = f0 - f1;\n        \n        tm = mix(t0, t1, abs(div) > 1e-16 ? f0 / div : 0.5);\n        \n        if(false)\n        {\n           vec3 pm = x + dir * tm;\n            \n           float fm = func(p0) * funcScale; \n            \n           if(fm < 0.0)\n               t0 = tm;\n            else\n               t1 = tm;\n        }\n        #else\n        tm = (t0 + t1) * 0.5;\n        #endif\n        \n        return true;\n    }\n    else\n    return false;\n}\n\n\nfloat Intersect_Scene(\nvec3 rp, vec3 rd, bool shadowRay, uint hh,\nout vec2 t, out vec3 n, out vec3 a)\n{\n    float hit = 0.0;\n    t = vec2(1e10);\n    \n   \tif(false)// ground plane [/]\n    {\n    \tvec2 tt; vec3 n0, n1;\n\t\tfloat th = Intersect_Ray_Cube(rp, rd, vec3(0.0, -0.75, 0.0), vec3(1.5, 0.05, 1.5), OUT tt, n0, n1);\n      \n        if(th > 0.0)\n        if(hit <= 0.0 || tt.x < t.x)\n        {\n            hit = 1.0;\n            t.x = tt.x;\n            t.y = t.x;\n            n = n0;\n            a = vec3(0.005, 1.0, 0.005);\n            \n            #if 1\n                vec3 x = rp + rd * t.x;\n                float sdf = func(vec3(x.x, 0.25, x.z));\n                if(sdf < 0.0) a = a.grb;\n            \n                a *= mix(0.5, 1.0, Pow2(cos(sdf*32.0)*.5+.5));\n            #endif\n        }\n    }\n    \n    {\n    \tvec2 tt; vec3 n0, n1;\n\t\tfloat th; \n        \n        th = Intersect_Ray_Cube(rp, rd, vec3(0.0, 0.0, 0.0), vec3(0.5), OUT tt, n0, n1);\n        \n        if(th > 0.0)\n        if(hit <= 0.0 || tt.x < t.x)\n        {   \n            bool inside = tt.y < 0.0;\n            //inside = true;\n            \n            vec3 p = inside ? rp : rp + rd * tt.x;\n            //p = rp;\n            \n            if(func(p) < 0.0)\n            {\n                hit = 1.0;\n                t.x = (!inside ? tt.x : 0.0);\n                t.y = (!inside ? t.x : 0.0);\n                n = n0;\n                //a = vec3(1.0, 0.0, 0.0);\n                a = vec3(1.0, 1.0, 1.0);                \n                //a.gb = vec2(1.0);// red border col [/]\n            }\n            else\n            {     \n                float linCount = shadowRay ? 20.0 : 30.0;\n                float binCount = shadowRay ? 0.0 : 5.0;\n                float stepSize = (inside ? tt.x : tt.y - tt.x) / linCount;\n                float stepOffPercent = shadowRay ? 1.0 : 0.0;\n                \n                {\n                    float h0 = HashFlt(hh, shadowRay ? 0x9D21245Eu : 0x64959FA2u);                    \n                          h0 = clamp01(h0 * 0.5 + 0.5);                    \n\n                    stepOffPercent = h0;\n                }\n                \n                float t0, tm, t1;\n                bool th2 = ImplicitRC(1.0, p, rd, linCount, binCount, stepSize, stepOffPercent, OUT t0, tm, t1);\n\n                if(th2)\n                {\n                   hit = 1.0;\n                   \n                   if(!shadowRay)\n                   {\n                   t.x = (!inside ? tt.x : 0.0) + tm;\n                   t.y = (!inside ? tt.x : 0.0) + t0;\n                    \n                   vec3 p = rp + rd * t.x;\n                    \n                   vec3 grad = GradientCD(p);\n                   n = dot(grad, grad) > 0.0001 ? normalize(grad) : vec3(0.0);\n                 //n*=0.0;\n                   a = vec3(1.0); \n                       \n                      if(false)\n                      {\n                          float h0 = HashFlt(hh, 0x43DC8E79u);\n                          float h1 = HashFlt(hh, 0x52BB4259u);\n                          float h2 = HashFlt(hh, 0x15DEFD6Bu);\n\n                          vec3 off = Sample_Sphere(h0, h1);\n                          off *= h2;\n                          off *= 0.01;\n                          \n                          a = func(p + off) > 0.0 ? vec3(1.0) : vec3(0.2);\n                      }\n                   }\n                }\n                else\n                {\n                    // conservatively estimate hit for shadows\n                    if(shadowRay && t0 < linCount*stepSize) hit = 1.0;\n                }\n            }\n        }\n    }\n    \n    return hit;\n}\n\nvec3 EvalSceneCol(\n    vec3 rp,\n    Cam cam, vec2 uv0, vec3 light, uint hh)\n{\n    vec3 col = vec3(0.0);\n    \n    vec2 tex = uv0.xy / PixelCount;\n    vec2 tex21 = tex * 2.0 - vec2(1.0);\n    \n    vec3 rd = NewRay(cam, tex21);\n    \n    vec2 t; vec3 n; vec3 a;\n    float hit = Intersect_Scene(rp, rd, false, hh, OUT t, n, a);\n \n    if(hit > 0.0)\n    {\n        vec3 p = rp + rd * t.x;\n\n        float sh;\n        {\n            //vec3 p = rp + rd * t.y;\n            \n            vec2 t2; vec3 n2; vec3 a2;\n            sh = Intersect_Scene(p + n * 0.001, light, true, hh, OUT t2, n2, a2);\n            sh = 1.0 - sh;\n        }\n        \n        float occ = 1.0;\n        {\n            float h0 = HashFlt(hh, 0x874C40D4u);\n            float h1 = HashFlt(hh, 0xF27BD7E1u);\n            h1 = clamp01(h1 * 0.5 + 0.5);\n            \n        \tvec3 dir = Sample_ClampedCosineLobe(h0, h1, n);\n            \n            vec2 t2; vec3 n2; vec3 a2;\n            occ = Intersect_Scene(p + n * 0.001, dir, true, hh, OUT t2, n2, a2);\n            occ = 1.0 - occ;\n        }\n        \n        float LdN = dot(light, n);\n        float VdN = dot(-rd, n);\n        \n        float front = clamp01(LdN);\n        float back  = clamp01(-LdN) / max(1.0e-12, clamp01(-LdN) + clamp01(VdN));// Lommel-Seeliger\n        \n        vec3 amb = vec3(0.05, 0.3, 1.0) * 0.4;\n        amb *= a;\n        //amb *= 1.0 + a * back;\n        //sh = 1.0;\n        //front += clamp01((1.0 - occ) * 0.3)*sh;\n        col = front * a * sh + amb * occ;\n        #if 0\n        bvec3 p0 = equal(mod(floor(p * 3.0 + 0.5), 2.0), vec3(0.0));\n        col *= ((p0.x != p0.z) != p0.y) ? 1.0 : 0.5;\n        #endif\n        //col *= textureLod(iChannel2, p, 0.0).x;\n        //col = (n*0.5+0.5);col*=col;//*front;\n        //col = vec3(t.x)*0.1;\n        //col = vec3(LdN);\n        //col = occ*vec3(1.0);\n    }\n    else\n    {\n        if(dot(rd, light) > 0.9999)\n        col = vec3(1.0);\n    }\n\n    return col;\n}\n\nfloat Length(vec3 vec)\n{\n    //return sqrt(dot(vec, vec));\n    \n\tfloat sqrLen = dot(vec, vec);\n    \n\tfloat rcpLen = rsqrt(sqrLen);\n\t\n\treturn max(0.0, sqrLen * rcpLen);\n}\n\n\nfloat Cube(vec3 x, vec3 b, float r)\n{    \n    vec3 d = abs(x) - b + r;\n    \n    float inner = max(d.x, max(d.y, d.z)); \n    \n    float box = (inner < 0.0 ? inner : Length4(max(d, 0.0))) - r;\n    \n    return box;\n}\n\n/*\n\tx ..sample pos [-b..b]\n\n\tb .. size\n\tfr..face roundness [0..1]   flat  -> round\n\ter..edge roundness [0..b] sharp -> round\n*/\nfloat CubeR(vec3 x, float b, float fr, float er)\n{\n    float f = Cube(x, vec3(b), er);\n    \n    f = mix(f, length(x) - b, fr);\n    \n    return f; \n}\n\nfloat SMax_Norm2(float a, float b, float r)\n{\n   float ap = a + r;\n   float bp = b + r;\n   \n   float inner = max(ap, bp); \n   \n   float box = (inner < 0.0 ? inner : length(max(vec2(ap, bp), 0.0))) - r;\n    \n   return box;\n    \n   //return max(max(a, b), length(vec2(ap, bp)) - r);//cylinder, sphere, torus\n   //return ap > 0.0 && bp > 0.0 ? length(vec2(ap, bp)) - r : max(a, b); \n}\n\nfloat SMax_Norm3(float a, float b, float r)\n{\n   float ap = a + r;\n   float bp = b + r;\n   \n   float inner = max(ap, bp); \n   \n   float box = (inner < 0.0 ? inner : Length3(max(vec2(ap, bp), 0.0))) - r;\n    \n   return box;\n}\n\nfloat SMax_Norm4(float a, float b, float r)\n{\n   float ap = a + r;\n   float bp = b + r;\n   \n   float inner = max(ap, bp); \n   \n   float box = (inner < 0.0 ? inner : Length4(max(vec2(ap, bp), 0.0))) - r;\n    \n   return box;\n}\n\nfloat SMin_Norm2(float a, float b, float r) {return -SMax_Norm2(-a, -b, r);}\nfloat SMin_Norm3(float a, float b, float r) {return -SMax_Norm3(-a, -b, r);}\nfloat SMin_Norm4(float a, float b, float r) {return -SMax_Norm4(-a, -b, r);}\n\nfloat SMax_Norm2(float a, float b, float c, float r)\n{\n   float ap = a + r;\n   float bp = b + r;\n   float cp = c + r;\n   \n   float inner = max(cp, max(ap, bp)); \n   \n   float box = (inner < 0.0 ? inner : length(max(vec3(ap, bp, cp), 0.0))) - r;\n    \n   return box; \n}\n\nfloat SMax_Norm3(float a, float b, float c, float r)\n{\n   float ap = a + r;\n   float bp = b + r;\n   float cp = c + r;\n   \n   float inner = max(cp, max(ap, bp)); \n   \n   float box = (inner < 0.0 ? inner : Length3(max(vec3(ap, bp, cp), 0.0))) - r;\n    \n   return box; \n}\n\nfloat SMax_Norm4(float a, float b, float c, float r)\n{\n   float ap = a + r;\n   float bp = b + r;\n   float cp = c + r;\n   \n   float inner = max(cp, max(ap, bp)); \n   \n   float box = (inner < 0.0 ? inner : Length4(max(vec3(ap, bp, cp), 0.0))) - r;\n    \n   return box; \n}\n\n\nfloat SMin_Norm2(float a, float b,float c, float r) {return -SMax_Norm2(-a, -b, -c, r);}\nfloat SMin_Norm3(float a, float b,float c, float r) {return -SMax_Norm3(-a, -b, -c, r);}\nfloat SMin_Norm4(float a, float b,float c, float r) {return -SMax_Norm4(-a, -b, -c, r);}\n\n\n#if 0\n#define SMin_Norm2 SMin_Norm4\n#define SMax_Norm2 SMax_Norm4\n#endif\n\n\nfloat SMax_C(float a, float b, float c, float r, float rs)\n{\n    float rbox = SMax_Norm3(a, b, c, r);\n    \n    vec3 d = vec3(a, b, c) + r;   \n    \n    float ro = r * rs;\n    float xo = SMax_Norm2(d.x, d.y, ro);\n    float yo = SMax_Norm2(d.x, d.z, ro);\n    float zo = SMax_Norm2(d.y, d.z, ro);\n    \n    float o = min(xo, min(yo, zo));\n    \n    #if 1\n    o = max(max(o, a), max(b, c));\n    return min(rbox + ro, o);\n\t#else\n    o = SMax_Norm2(o, max(a, max(b, c)), ro*0.25);  \n    return SMin_Norm2(rbox + ro, o, ro*0.25);    \n    #endif\n}\n\n/*\n{\nvec2 o_uv, o_s, o_id;\nPattern_RectCircBricks(uv, /*out:/ o_uv, o_s, o_id);\n\nk = o_uv; s = o_s; n = o_id; \n}\n*/\nvoid Pattern_RectCircBricks(vec2 uv, out vec2 o_uv, out vec2 o_s, out vec2 o_id)\n{\n    vec2 uvi = floor(uv);\n    vec2 uvf = uv - uvi;\n    \n    o_uv = uvf;\n    o_id = uvi;\n    o_s = vec2(1.0);\n\n    uint m = mod(uvi.x + uvi.y, 2.0) == 0.0 ? 0u : 2u;// brick wall tiling\n\n    if(uvi.y >= uvi.x && -uvi.y >  uvi.x) { m += 1u; }\n    if(uvi.y <  uvi.x && -uvi.y >= uvi.x) { m += 2u; }\n    if(uvi.y <= uvi.x && -uvi.y <  uvi.x) { m += 3u; }\n   \n    //if(mod(dim, 2.0) == 1.0 && -uvi.y == uvi.x) m += 1u;\n    //if(-uvi.y == uvi.x) m += 1u;\n \n    m &= 3u;// m % 4\n    \n    if(uvi.y == uvi.x && -uvi.y == uvi.x) return;// center brick\n        \n    \n    if(m == 0u) { o_s.x = 2.0;                                       }// right\n    if(m == 1u) { o_s.y = 2.0;                                       }// up\n    if(m == 2u) { o_s.x = 2.0; o_id.x -= 1.0; o_uv.x = 1.0 - o_uv.x; }// left\n    if(m == 3u) { o_s.y = 2.0; o_id.y -= 1.0; o_uv.y = 1.0 - o_uv.y; }// down\n}\n\nstruct Pattern_RectCircBricks_Out { vec2 id; vec2 uv; vec2 s; };\n#define PATTERN_RectCircBricks(name, p) Pattern_RectCircBricks_Out name; Pattern_RectCircBricks(p, /*out:*/ name.uv, name.s, name.id);\n\n    \nvoid Pattern_RectCircBricks2(vec3 p, out vec3 o_uvw, out vec3 o_s, out vec3 o_id)\n{\n   float wi = floor(p.y);\n   float wf = p.y - wi;\n    \n   if(mod(wi, 2.0) == 0.0) p.x = 1.0 - p.x;\n    \n   PATTERN_RectCircBricks(o, p.xz);\n\n   o_uvw = vec3(o.uv, wf);\n   o_s   = vec3(o.s, 1.0);\n   o_id  = vec3(o.id, wi); \n}\n\nstruct Pattern_RectCircBricks2_Out { vec3 id; vec3 uvw; vec3 s; };\n#define PATTERN_RectCircBricks2(name, p) Pattern_RectCircBricks2_Out name; Pattern_RectCircBricks2(p, /*out:*/ name.uvw, name.s, name.id);\n\n    \n// implicit function; prototype farther up\n#define func1 func\n\nfloat func1(vec3 x)\n{\n    float lc = max(abs(x.x), max(abs(x.y), abs(x.z))) - 0.5;\n\n    #if 1\n    float lc2 = 64.0;\n    {\n        lc2 = 0.5/3.0 - max(abs(x.x), abs(x.z));\n    }\n    #endif\n    \n    x += 0.5;\n       \n    float s = 7.0;\n    \n    float ss = s*2.0+1.0;\n    \n    vec3 x2 = x * ss;\n    x2.xz -= s;\n    \n    PATTERN_RectCircBricks2(o, x2);\n    o.s *= 0.5;\n    \n    vec3 k0 = abs(o.uvw - o.s);\n    vec3 k = k0 - o.s;\n\n    float u = SMax_Norm3(k.x, k.y, k.z, 0.5);\n    //float u = SMax_C(k.x, k.y, k.z, 0.25, 0.125);\n    \n    #if 0\n    vec3 k2 = o.s - k0;\n    //if(Hash(vec3(o.id, wi), uvec3(0xFA722B82u, 0xAC7C8CDFu, 0x05347A00u)) > 0.0) \n    if(textureLod(iChannel2, o.id * 0.01, 0.0).x + SqrLen(o.id.xy*0.05) > 0.5)         \n    u = 0.25 + min(k2.x, min(k2.y, k2.z));\n    #endif\n    \n    //float u = max(k.z+0.01, max(k.x, k.y)+0.125);\n    //u = SMax_Norm4(u, k.z, 0.5);\n    u += 0.01;\n    u /= ss;\n    \n    if(lc2 >= 0.0) u = max(u, lc2);\n    //return max(lc, x.y-2.0);\n    return max(lc, u);\n    //return max(lc, SMax_Norm3(x.y-0.5, u, 0.05));\n}\n\nfloat func0(vec3 x)\n{\n    float lc = max(abs(x.x), max(abs(x.y), abs(x.z))) - 0.5;\n    //lc += 0.0001;\n    \n\tfloat r = 64.0;\n    x += 0.5;\n    \n    float cells = 4.0;\n    x *= cells;\n    \n    r = x.y - 2.0;\n    \n    {\n        vec3 x0 = x;\n        \n        float pillar = Cube(x0 - vec3(1.5, 2.0, 1.5), vec3(0.5, 2.0, 0.5)+0.0, 0.01); \n        float pillar2 = Cube(x0 - vec3(1.5, 2.0, 1.5), vec3(0.5, 2.0, 0.5)-0.09, 0.04); \n            \n            \n        vec3 s = 1.0/vec3(3.0, 3.0, 3.0);\n       // s = vec3(.5);\n        //s = 1.0 / vec3(3.0*3.0);\n\n        x0 = mod(x0, s) - s*.5;\n\n        float bricks = Cube(x0, s*0.5 - 0.0, 0.05);\n        bricks = CubeR(x0, s.x*0.5, 0.3, 0.08);\n        \n        vec3 d = abs(x0)-s.x*0.5;\n        bricks = SMax_C(d.x, d.y, d.z, 0.125*0.5, 0.25); \n        \n        bricks = max(bricks, pillar);\n        //bricks = min(bricks, pillar2);\n        \n        r = min(r, bricks);\n    }\n    \n    r /= cells;\n    r = max(r, lc);\n    \n    return r;   \n}\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{\n    vec3 col = vec3(0.0);\n    \n    vec2 uv = uv0.xy - 0.5;\n\tvec2 tex = uv0.xy / PixelCount;\n    vec2 tex21 = tex * 2.0 - vec2(1.0);\n    \n    vec4 mouseAccu  = ReadVar4(1, 0);\n    vec4 wasdAccu   = ReadVar4(2, 0);\n    float frameAccu = ReadVar (3, 0);\n\n    vec2 ang = vec2(Pi * 0.24, -Pi * 0.2);\n    ang += mouseAccu.xy * 0.008;\n\n    Cam cam = NewCam(ang, Pi * 0.5, PixelCount.x / PixelCount.y);\n    vec3 cpos = -cam.Front * 2.0;\n    cpos = -cam.Front * (exp2(0.2 + mouseAccu.w * 0.02));\n\n    float fId = frameAccu;\n    \n    vec3 pxId  = vec3(frameAccu, uv); \n    pxId *= vec3( 0.76032, 1.47035, 0.92526); \n    pxId += vec3(-0.69060, 0.02293, 0.68109);\n    \n    uint hh = HashUInt(pxId, uvec3(0xB8D3E97Cu, 0x736D370Fu, 0xA7D00135u));\n    \n    vec2 uv2 = uv0;\n    //if(false)\n    {\n        float h0 = Hash(fId * 0.50112 - 0.47648, 0x82EBEB4Cu);\n        float h1 = Hash(fId * 1.64683 + 0.84377, 0xF4D83B59u);\n        \n        //vec2 off = vec2(h0, h1) * 0.5;\n        vec2 off = vec2(Sample_Triangle(h0), Sample_Triangle(h1));\n        \n        //tex21 = (uv0.xy + off) / PixelCount * 2.0 - vec2(1.0);\n        if(frameAccu > 0.0)\n        uv2 += off;\n    }\n    \n    vec3 rdir = NewRay(cam, tex21);\n    \n    float t; vec3 n; vec3 a;\n    //float hit = Intersect_Scene(cpos, rdir, OUT t, n, a);\n \n    vec2 lightAng = vec2(Pi * 0.7, Pi * 0.2);\n    lightAng.x += (wasdAccu.y - wasdAccu.w) * 0.06; \n    lightAng.y += (wasdAccu.x - wasdAccu.z) * 0.04;    \n    \n    vec3 light = AngToVec(lightAng);\n    float lc = 0.9999;\n    vec3 lightp;\n    {\n        float h0 = HashFlt(hh, 0x9E2355B4u);\n        float h1 = HashFlt(hh, 0xDC305E12u);\n        h1 = clamp01(h1 * 0.5 + 0.5);\n        \n        h1 = mix(lc, 1.0, h1);\n        \n        lightp = Sample_Sphere(h0, h1, light);\n    }\n    \n\n    col = EvalSceneCol(cpos, cam,  uv2,  lightp, hh);\n    \n    vec3 colLast = textureLod(iChannel0, tex, 0.0).rgb;\n    \n    \n    col = mix(colLast, col, 1.0 / (frameAccu + 1.0));  \n    \n    //col = vec3(Hash(uv * 0.50112 - 0.47648, uvec2(0x4A539D7Cu, 0x9FD724FBu)));\n\t//outCol = vec4(GammaEncode(Clamp(col)), 1.0);\n    outCol = vec4(col, 1.0);\n    \n    {\n        vec4 iMouseLast     = ReadVar4(0, 0);\n        vec4 iMouseAccuLast = ReadVar4(1, 0);\n        vec4 wasdAccuLast   = ReadVar4(2, 0);\n        float frameAccuLast = ReadVar (3, 0);\n        float timeLast      = ReadVar (4, 0);        \n\n\n        bool shift = ReadKey(KEY_SHIFT) != 0.0;\n\n        float kW = ReadKey(KEY_W);\n        float kA = ReadKey(KEY_A);\n        float kS = ReadKey(KEY_S);\n        float kD = ReadKey(KEY_D);\n\n        float left  = ReadKey(KEY_LEFT);\n        float right = ReadKey(KEY_RIGHT);\n        float up    = ReadKey(KEY_UP);\n        float down  = ReadKey(KEY_DOWN);\n        \n        \n        bool anyK = false;\n        \n        anyK = anyK || iMouse.z > 0.0;\n        anyK = anyK || shift;\n        anyK = anyK || kW != 0.0;\n        anyK = anyK || kA != 0.0;\n        anyK = anyK || kS != 0.0;\n        anyK = anyK || kD != 0.0;\n        anyK = anyK || left  != 0.0;\n        anyK = anyK || right != 0.0;\n        anyK = anyK || up    != 0.0;\n        anyK = anyK || down  != 0.0;\n        \n        if(Time != timeLast)\n        frameAccuLast += 1.0;\n        if(anyK) frameAccuLast = 0.0;\n        \n\n        vec4 wasdAccu = wasdAccuLast;\n        wasdAccu += vec4(kW, kA, kS, kD);\n        wasdAccu += vec4(up, left, down, right);        \n\n        \n        vec2 mouseDelta = iMouse.xy - iMouseLast.xy;\n\n        bool cond0 = iMouse.z > 0.0 && iMouseLast.z > 0.0;\n        vec2 mouseDelta2 = cond0 && !shift ? mouseDelta.xy : vec2(0.0);\n        vec2 mouseDelta3 = cond0 &&  shift ? mouseDelta.xy : vec2(0.0);\n\n        vec4 iMouseAccu = iMouseAccuLast + vec4(mouseDelta2, mouseDelta3);\n\n        \n        WriteVar4(iMouse,        0, 0);\n        WriteVar4(iMouseAccu,    1, 0);\n        WriteVar4(wasdAccu,      2, 0);\n        WriteVar (frameAccuLast, 3, 0);\n        WriteVar (Time,          4, 0);\n        \n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}