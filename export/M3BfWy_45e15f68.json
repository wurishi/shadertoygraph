{"ver":"0.1","info":{"id":"M3BfWy","date":"1729876079","viewed":92,"name":"six^n","username":"pb","description":"pause at your favorite color scheme","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"X3SfR3","parentname":"zz six^n"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//philip.bertani@gmail.com\n//see buffer A please\n\nvoid mainImage(out vec4 O, vec2 u) {\n\n    vec2 R = iResolution.xy,\n        uv = u/R;\n\n    O *= 0.;\n\n    float[] gk1s = float[](\n        0.003765, 0.015019, 0.023792, 0.015019, 0.003765,\n        0.015019, 0.059912, 0.094907, 0.059912, 0.015019,\n        0.023792, 0.094907, 0.150342, 0.094907, 0.023792,\n        0.015019, 0.059912, 0.094907, 0.059912, 0.015019,\n        0.003765, 0.015019, 0.023792, 0.015019, 0.003765\n    );\n\n    //golfed by fabriceneyret2\n    for (int k; k < 25; k++)      \n        O += gk1s[k] * texture(iChannel0, uv + ( vec2(k%5,k/5) - 2. ) / R );\n          \n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// philip.bertani@gmail.com\n\n#define t iTime/2.\n\nvoid mainImage0( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;    \n        \n    vec2 center = vec2(.78,.22);\n    vec2 width  =vec2(.25);\n \n    vec2 z = uv * width + center ; \n    \n    float max_iter=7., mix_factor=.999, infinity=1e9;\n\n    vec2 wgt=vec2(mix_factor, 1.-mix_factor);\n    \n    float r=1.41,an=3.9;  //the Julia set params, play with it\n    vec2 jc = vec2(r*cos(an),r*sin(an));\n    \n    vec2 maxz = vec2(0);\n    \n    float escape_value = 0.;\n    for ( float i=0.; i<max_iter; i++ ) {\n    \n        vec2 tmp = vec2(z.x*z.x*z.x - 3.*z.x*z.y*z.y,\n                    -z.y*z.y*z.y + 3.*z.x*z.x*z.y);\n                    \n        float div = max(tmp.x*tmp.x+tmp.y*tmp.y,1e-5);\n        \n        //combo of abs(z^3) and abs(1/z^3)\n        z = wgt.x*abs(tmp) + wgt.y*abs(tmp)/div+jc;\n        \n        float distance = z.x*z.x + z.y*z.y;\n\n        maxz = max(maxz,abs(z)); //for coloring\n        \n        if ( distance > infinity ) {\n            escape_value = i;\n            break;\n        }\n         \n    }\n\n    if ( escape_value != 0. ) { \n        fragColor = vec4(0);\n    }\n    else {\n    //all of the action here is for points in the bounded set\n        vec3 freqs=.3*vec3(31,21,11);\n        vec3 angles= sin(vec3(t,t/1.2+2.2,t/1.3+4.));\n    \n        vec3 cosa=cos(angles);\n        vec3 sina=sin(angles);\n        \n        vec3 cc=vec3(log(abs(maxz.x)),log(abs(maxz.y)),atan(maxz.x,maxz.y) );\n        cc=sin(cc*freqs);\n        cc *= cc;\n        \n        mat3 mm=mat3(cosa.x*cosa.z,sina.x*sina.y*cosa.z+cosa.x*sina.z,-sina.x*cosa.y*cosa.z+sina.y*sina.z,\n                    -cosa.x*sina.z,-sina.x*sina.y*sina.z+cosa.y*cosa.z,sina.x*cosa.y*sina.z+sina.y*cosa.z,\n                     sina.x, -cosa.x*sina.y, cosa.x*cosa.y);\n           \n        cc = mm*cc;\n        \n        fragColor = vec4( clamp(3.*cc*cc,0.,1.), 1. );\n    }\n    \n\n}\n\n//FabriceNeyret2 antialiasing trick\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    if ( fwidth(length(O)) > .01 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { mainImage0(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n        //O.b++;                        // uncomment to see where the oversampling occurs\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}