{"ver":"0.1","info":{"id":"4cyczd","date":"1732220784","viewed":45,"name":"Uitvinding van Elektriciteit ","username":"Mirtheamvm","description":"Uitvinding van Elektriciteit (19e eeuw)","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["elektriciteit"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Shader for \"Invention of Electricity\" with enhanced shadow effects, improved depth, and refined color scheme for greater contrast and visual interest.\n\n// User parameters\nuniform float tech_input;      // Technology input for sigmoid function\n\n#define AA 2  // Set AA to 1 if your machine is too slow\n#define METHOD 3\n\n// Sigmoid function for technology growth\nfloat sigmoid(float x) {\n    return 1.0 / (1.0 + exp(-x));\n}\n\n// Function to compute the quaternion constant c based on the \"Invention of Electricity\"\nvec4 computeC(float time) {\n    float health;\n    float freedom;\n    float interconnectivity;\n    float tech_factor = sigmoid(tech_input);\n\n    // CARE values for the \"Invention of Electricity\"\n    if (time < 0.33) {  // Early phase\n        health = 5.0;\n        freedom = 5.0;\n        interconnectivity = 5.0;\n    } else if (time < 0.66) {  // Acceleration phase\n        health = 7.0;\n        freedom = 8.0;\n        interconnectivity = 8.0;\n    } else {  // Maturity phase\n        health = 8.0;\n        freedom = 9.0;\n        interconnectivity = 9.0;\n    }\n\n    // Normalize the CARE values and compute the quaternion constant\n    return vec4(\n        (5.0 + min(health, 8.5)) / 10.0 * (5.0 + min(freedom, 8.5)) / 10.0 * (5.0 + min(interconnectivity, 8.5)) / 10.0 * tech_factor,\n        0.8 * (5.0 + health) / 10.0 * sin(time * 0.7),\n        0.8 * (5.0 + freedom) / 10.0 * cos(time * 0.5),\n        0.8 * (5.0 + interconnectivity) / 10.0\n    );\n}\n\nvec4 qsqr(in vec4 a) {\n    return vec4(\n        a.x * a.x - a.y * a.y - a.z * a.z - a.w * a.w,\n        2.0 * a.x * a.y,\n        2.0 * a.x * a.z,\n        2.0 * a.x * a.w\n    );\n}\n\nconst int numIterations = 1500; // Higher number of iterations for more detail\n\n// Function to map the fractal and limit bailout-radius for stability\nfloat map(in vec3 p, out vec4 oTrap, in vec4 c, out float iteration) {\n    vec4 z = vec4(p, 0.0);\n    float md2 = 1.0;\n    float mz2 = dot(z, z);\n    oTrap = vec4(abs(z.xyz), dot(z, z));\n\n    iteration = 0.0;\n    for (int i = 0; i < numIterations; i++) {\n        md2 *= 4.0 * mz2;\n        z = qsqr(z) + c;\n\n        // Add subtle noise for organic deformation\n        z.xyz += 0.12 * sin(8.0 * z.xyz + iTime * 0.03);\n\n        // Orbit trap to enhance visual detail\n        oTrap = min(oTrap, vec4(abs(z.xyz), dot(z, z)));\n        mz2 = dot(z, z);\n        iteration += 1.0;\n\n        // Adjust the bailout threshold for stability and visibility\n        if (mz2 > 50.0) break;\n    }\n\n    return 0.05 * sqrt(mz2 / md2) * log(mz2);  // Adjusted scaling factor for visibility\n}\n\n// Function to get refined electric colors with more contrast\nvec3 getElectricityColor(float health, float freedom, float interconnectivity) {\n    float totalCARE = (health + freedom + interconnectivity) / 3.0;\n\n    // Define refined electricity colors with more neon-like, vibrant variety\n    vec3 neonGreen = vec3(0.1, 1.0, 0.1);   // Neon green for a striking and vibrant tone\n    vec3 neonYellow = vec3(0.9, 1.0, 0.1);   // Neon yellow for dynamic highlights\n    vec3 brightCyan = vec3(0.0, 1.0, 0.8);   // Bright cyan for high energy and electricity\n    vec3 softWhite = vec3(0.95, 0.95, 1.0);   // Soft white glow for bright areas\n\n    // Gradual transitions between electricity-inspired colors\n    if (totalCARE <= 5.0) {\n        return mix(neonGreen, neonYellow, totalCARE / 5.0);  // Transition from neon green to neon yellow\n    }\n    if (totalCARE <= 6.0) {\n        return mix(neonYellow, brightCyan, (totalCARE - 5.0));  // Transition from yellow to bright cyan\n    }\n    return mix(brightCyan, softWhite, (totalCARE - 6.0));  // Transition from cyan to white\n}\n\n// Function to adjust color based on the CARE-scores using electricity colors\nvec3 getColor(float iteration, float maxIteration, vec4 oTrap, float health, float freedom, float interconnectivity) {\n    float t = iteration / maxIteration;\n\n    // Get the electric color based on CARE values\n    vec3 baseColor = getElectricityColor(health, freedom, interconnectivity);\n    \n    // Add orbit trap influence to color for more visual complexity\n    baseColor += 0.25 * vec3(oTrap.x, oTrap.y, oTrap.z) * (1.0 - t);\n    \n    // Add a glow effect for areas with high interconnectivity\n    baseColor += 0.2 * pow(max(0.0, 1.0 - t), 3.0) * vec3(0.9, 1.0, 0.95);\n    \n    return baseColor;\n}\n\nfloat intersect(in vec3 ro, in vec3 rd, in vec4 c, out vec4 res, out float iteration) {\n    vec4 tmp;\n    float resT = -1.0;\n    float maxd = 50.0;  // Increased maximum distance for depth\n    float h = 1.0;\n    float t = 0.0;\n    for (int i = 0; i < 1500; i++) {\n        if (h < 0.0001 || t > maxd) break;\n        h = map(ro + rd * t, tmp, c, iteration);\n        t += h;\n    }\n    if (t < maxd) {\n        resT = t;\n        res = tmp;\n    }\n    return resT;\n}\n\n// Function to render the fractal and ensure it remains visible\nvec3 render(in vec3 ro, in vec3 rd, in vec4 c, float health, float freedom, float interconnectivity) {\n    const vec3 sun = vec3(0.577, 0.577, 0.577);\n\n    vec4 tra;\n    float iteration;\n    float t = intersect(ro, rd, c, tra, iteration);\n\n    vec3 col;\n    if (t < 0.0) {\n        // Background with consistent beige color\n        col = vec3(0.94, 0.87, 0.78) * (0.7 + 0.3 * rd.y); // Beige background\n    } else {\n        vec3 mate = vec3(0.8, 0.8, 1.0) * 0.3; // Light material to contrast dark shadows\n        vec3 pos = ro + t * rd;\n        vec3 nor = normalize(pos);  // Normal approximation\n\n        // Get color based on iteration count and orbit trap using the electric color scheme\n        col = getColor(iteration, float(numIterations), tra, health, freedom, interconnectivity);\n\n        // Add some subsurface scattering effect for depth\n        float subsurface = clamp(dot(rd, nor) + 0.5, 0.0, 1.0);\n        col += mate * 0.5 * subsurface;\n\n        // Sun lighting with more contrast\n        vec3 lig = sun;\n        float dif = clamp(dot(lig, nor), 0.0, 1.0);\n        col += mate * vec3(1.0, 0.95, 0.85) * dif;\n\n        // Enhanced shadow for better depth perception\n        float shadow = 0.6 + 0.4 * pow(max(0.0, dot(nor, lig)), 4.0);\n        col *= shadow;\n\n        // Brightness variation for depth perception\n        col *= 0.9 + 0.3 * sin(iTime * 0.1 + iteration);\n    }\n\n    return pow(col, vec3(0.4545));  // Gamma correction for realistic brightness and contrast\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Parameters for animation\n    float time = iTime * 0.0025;  // Slower movement for a calmer effect\n    vec4 c = computeC(time);\n\n    // Set up the camera\n    float r = 3.0;  // Zoom level for the fractal\n    vec3 ro = vec3(r * cos(0.3 + 0.37 * time), 0.3 + 0.8 * r * cos(1.0 + 0.33 * time), r * cos(2.2 + 0.31 * time));\n    vec3 ta = vec3(0.0, 0.0, 0.0);\n    float cr = 0.1 * cos(0.1 * time);\n\n    // Compute camera direction vectors\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n\n    // Ray direction\n    vec2 p = (-iResolution.xy + 2.0 * fragCoord) / iResolution.y;\n    vec3 rd = normalize(p.x * cu + p.y * cv + 2.0 * cw);\n\n    // CARE parameters for the \"Invention of Electricity\"\n    float health, freedom, interconnectivity;\n    if (time < 0.33) {\n        // Early phase\n        health = 5.0;\n        freedom = 5.0;\n        interconnectivity = 5.0;\n    } else if (time < 0.66) {\n        // Acceleration phase\n        health = 7.0;\n        freedom = 8.0;\n        interconnectivity = 8.0;\n    } else {\n        // Maturity phase\n        health = 8.0;\n        freedom = 9.0;\n        interconnectivity = 9.0;\n    }\n\n    // Render the scene with the electricity-based color scheme\n    vec3 col = render(ro, rd, c, health, freedom, interconnectivity);\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}