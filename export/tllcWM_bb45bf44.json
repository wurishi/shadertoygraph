{"ver":"0.1","info":{"id":"tllcWM","date":"1592314517","viewed":217,"name":"Miller","username":"kesson","description":"Inspired by Miller, the waterworld and the first planet in the system orbiting Gargantua, in the movie Interstellar.\n\nAn experiment while studying Fractional Brownian Motion in 3D space with Ray marching.","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["noise","raymarch","fbm","space","planet","interstellar","waterworld"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* fBM\n * Thanks to\n *\n * thebookofshaders.com, by Patricio Gonzalez Vivo\n * https://thebookofshaders.com/13/\n *\n * Domain Warping and fBM, by Inigo Quilez\n * https://iquilezles.org/articles/warp\n * https://iquilezles.org/articles/fbm\n *\n * Code made, adapted, modified and merged by Giovanni Muzio - Kesson\n * https://kesson.io\n */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n \tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 col = texture(iChannel0, uv);\n    fragColor = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define NUM_OCTAVES 8\n#define DETAILS 2.0\n#define SIZE 2.0\n#define RAYMARCH_MAX_STEPS \t\t256\n#define RAYMARCH_MAX_DIST \t\t500.0\n#define RAYMARCH_SURFACE_DIST \t0.01\n\n//\t<https://www.shadertoy.com/view/4dS3Wd>\n//\tBy Morgan McGuire @morgan3d, http://graphicscodex.com\n//\nfloat hash(float n) { return fract(sin(n) * 1e4); }\nfloat hash(in vec2 _st) { return fract(sin(dot(_st.xy, vec2(12.9898,78.233)))* 43758.5453123); }\n\n// This one has non-ideal tiling properties that I'm still tuning\nfloat noise(vec3 x) {\n    const vec3 step = vec3(110, 241, 171);\n\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n\n    // For performance, compute the base input to a 1D hash from the integer part of the argument and the \n    // incremental change to the 1D based on the 3D -> 1D wrapping\n    float n = dot(i, step);\n\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n            mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\nfloat fbm( in vec3 x) {    \n    // float G = exp2(-H);\n    float f = 1.0;\n    float a = 0.5;\n    float t = 0.0;\n    for( int i=0; i < NUM_OCTAVES; i++ ) {\n        t += a*noise(vec3(f*x));\n        f *= 2.0;\n        a *= 0.475;\n    }\n    return t;\n}\n\nfloat pattern(vec3 p, vec3 st, out vec3 q, out vec3 r) {\n    q = vec3(\n\t\t\tfbm( st.xyz + vec3(0.01)*iTime ),\n\t\t\tfbm( st.xyz + vec3(5.2,1.3, 1.0) ),\n\t\t\tfbm( st.xyz + vec3(1.0, 1.0, 1.0) ) );\n\n\tr = vec3(\n\t\t\tfbm( st.xyz + DETAILS * q + vec3(1.7, 9.2, 1.0) + 0.1 * iTime ),\n\t\t\tfbm( st.xyz + DETAILS * q + vec3(8.3, 2.8, 1.0) + 0.0125 * iTime ),\n\t\t\tfbm( st.xyz + DETAILS * q + vec3(2.8, 8.3, 1.0) + 0.0125 * iTime ) );\n\n\t//float f = fbm( + vec2(fbm(st + vec2(fbm(st + r)))));\n\tfloat f = fbm(p + r);\n    \n    return f;\n}\n\nfloat getDist(vec3 p, vec3 lp) {\n\tvec4 sphere = vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 sun = vec4(lp.xyz, 40.0);\n    \n    float sphereDist = length(p - sphere.xyz) - sphere.w;\n    float sunDist = length(p - sun.xyz) - sun.w;\n    \n    return min(sphereDist, sunDist);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, vec3 lp, out int mr) {\n\tfloat dO = 0.0;\n    \n    for (int i = 0; i < RAYMARCH_MAX_STEPS; i++) {\n\t\tvec3 p = ro + rd * dO;\n        float dS = getDist(p, lp);\n        dO += dS;\n        if (dO > RAYMARCH_MAX_DIST) break;\n        if (dS < RAYMARCH_SURFACE_DIST) {\n            mr = 1;\n            break;\n        }\n    }\n    \n    return dO;\n}\n\nvec3 getNormal(vec3 p, vec3 lp) {\n\tfloat d = getDist(p, lp);\n    vec2 e = vec2(0.01, 0.0);\n    \n    vec3 n = d - vec3(\n        getDist(p - e.xyy, lp),\n        getDist(p - e.yxy, lp),\n        getDist(p - e.yyx, lp));\n    \n    return normalize(n);\n}\n\nfloat getLight(vec3 p, vec3 lp) {\n    vec3 lightPos = lp;//vec3(0.0, 5.0, 6.0);\n    vec3 l = normalize(lightPos - p);\n    vec3 n = getNormal(p, lp);\n    \n    float dif = dot(n, l);\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 uv = (fragCoord-0.5 * iResolution.xy) / iResolution.y;\n    \n    float an = iTime * 0.1;\n    float an2 = iTime * 0.01;\n    float cd = 4.5 + (sin(an));\n    // Camera matrix and movement from https://www.shadertoy.com/view/ldl3Dl\n    vec3 ro = vec3( cd*cos(an), sin(an), cd*sin(an) );\n    vec3 ta = vec3( 0.0, 1.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( uv.x*uu + uv.y*vv + 1.5*ww );\n    \n    int mr = 0;\n    \n    float sTheta = 0.28;\n    float sPhi = 0.5;\n    float sDistance = 1000.0;\n  \n    vec3 lp = vec3(sDistance * cos(sTheta) * cos(sPhi),\n                   sDistance * cos(sTheta) * sin(sPhi),\n                   sDistance * sin(sTheta));\n    \n    float d = rayMarch(ro, rd, lp, mr);\n    \n    vec3 p = ro + rd * d;\n    \n    vec3 st = (p) * SIZE;\n    \n    vec3 color = vec3(0.0);\n    \n    fragColor = vec4(color, 1.0);\n\n    if (mr == 1) {\n        \n        vec3 q, r;\n        float f = pattern(p, st, q, r);\n\n    \tvec3 baseColor = vec3(0.00, 0.10, 0.980);\n    \tvec3 colorMixA = vec3(0.00, 0.09, 0.89);\n    \tvec3 colorMixB = vec3(0.14, 0.38, 0.61);\n    \tvec3 finalColor = vec3(1.0, 1.0, 1.0) ;\n    \n    \tcolor = mix(baseColor, colorMixA, clamp((f*f)*1.0,0.0,1.0));\n    \tcolor = mix(color, colorMixB,clamp(length(q)*1.0,0.0,1.0));\n    \tcolor = mix(color, finalColor, clamp(length(r.x)*2.0,0.0,1.0));\n        \n    \tfloat dif = clamp(getLight(p, lp), 0.02, 1.0);\n        \n        if (d < 25.0) {\n            fragColor = vec4((f*f*f+0.5*f*f+0.5*f)*color * dif, 1.0);\n        } \n    } \n    \n}","name":"Buffer A","description":"","type":"buffer"}]}