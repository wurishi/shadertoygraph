{"ver":"0.1","info":{"id":"7sfXDf","date":"1622908401","viewed":305,"name":"RmpRefract","username":"sashasan","description":"Reverse raytracing, ray march physically correct refraction.\nShow back surface. N beam bouncing depth","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","ray","beam","depth","surface","recursion","march","bouncing","flip","fraction","physically","back","reverse","correctre"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Copyright Â© 2021 Sashasan https://www.facebook.com/profile.php?id=100005029953825\n// Reverse raytracing ray march physically correct refraction. Show back surface.\n// There are lots of tips and forms here - https://iquilezles.org\n\nconst int MAX_MARCHING_STEPS = 256;\nconst float NearP = 0.4;\nconst float FarP = 96.0;\nconst float MinD = 0.002;\nconst float NminR = 0.04;\nconst float NmaxR = 96.0;\nconst float stepB = 0.5;\n\nconst float kr_air = 1.0002926;\nconst float kr_glass = 1.4874;\n\nvec3\tlp;\n\n#define itime iTime*0.05\n\nstruct res\n{\n\tfloat\td;\n\tint\t\tm;\n};\n\n\n//func sdf\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\nfloat sdSphere( vec3 p, float r )\n{\n\treturn length(p)-r;\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n\tp.xy = mat2x2(cos(itime),sin(itime),-sin(itime),cos(itime))*p.xy;\n\tvec3 q = abs(p);\n\treturn max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n\tp.xz = mat2x2(cos(-itime),sin(-itime),-sin(-itime),cos(itime))*p.xz;\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n//refract func\nvec3 refractk(vec3 I, vec3 N, float eta) {\n\tvec3 R;\n\tfloat k = 1.0 - eta * eta * (1.0 - dot(N, I) * dot(N, I));\n\treturn\tR = eta * I - (eta * dot(N, I) + sqrt(k)) * N;\n}\n// to take negative steps into account, compare the absolute values\nres opU( res d1, res d2 )\n{\n\tif (abs(d1.d) < abs(d2.d)){\n\t\td2=d1;\n\t}\n\treturn d2;\n}\nres sceneSDF(vec3 p)\n{\n\tres oh,th;\n\tvec3 varp;\n\toh=res(sdPlane(p+0.5),1);\n\n\tvarp = p-vec3(-1.0+fract(itime*1.0)*14.0*(1.0-fract(itime*1.0)),fract(itime*0.1)*8.0*(1.0-fract(itime*0.1)),-1.0);\n\tth=res(sdSphere(varp,1.0),2);\n\toh=opU(oh,th);\n\n\tvarp = p-lp;\n\tth=res(sdSphere(varp,0.4),3);\n\toh=opU(oh,th);\n\n\tvarp = p-vec3(-8.0+fract(itime*1.0)*40.0*(1.0-fract(itime*1.0)),fract(itime*3.0)*10.0*(1.0-fract(itime*3.0)),-1.0);\n\tth=res(sdCapsule(varp,vec3(3.0,0.0,0.0),vec3(3.0,3.0,-1.0),0.05),4);\n\toh=opU(oh,th);\n    \n    varp = p-vec3(-2.5,fract(itime*0.1)*20.0*(1.0-fract(itime*0.1)),-1.5);\n\tth=res(sdTriPrism(varp,vec2(1.0,2.0)),2);\n\toh=opU(oh,th);\n    \n    varp = p-vec3(3.0,fract(itime*0.1)*15.0*(1.0-fract(itime*0.1)),-3.0);\n\tth=res(sdBox(varp,vec3(0.5,1.5,1.2)) ,2);\n\toh=opU(oh,th);\n    \n\treturn oh;\n}\n//Rey March + Neg. value\nres RayMarch(vec3 ro, vec3 rd, float Min_Dist, float Max_Dist) {\n\tres t0 = res(Min_Dist,0);\n\tres h;\n\tfor (int i = 0; i < MAX_MARCHING_STEPS && t0.d<=Max_Dist; i++) {\n\t\th = sceneSDF(ro + t0.d * rd);\n\t\tif (abs(h.d) < MinD) {\n\t\t\tt0.m=h.m;\n\t\t\tbreak;\n\t\t}\n\t\tt0.d=abs(h.d)*stepB+t0.d;\n\t}\n\tif (t0.d > Max_Dist) {t0.m=0;t0.d=Max_Dist;}\n\treturn t0;\n}\n//MatView\nvec3 RayD(float fieldOfView, vec2 size, vec2 tc0) {\n\tvec2 xy = tc0 - size / 2.0;\n\tfloat z = size.y / tan(radians(fieldOfView) / 2.0);\n\treturn normalize(vec3(xy, -z));\n}\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n\treturn mat3( cu, cv, cw );\n}\n//GetNormal\nvec3 GradeSdfNormal(vec3 p) {\n\treturn normalize(vec3(\tsceneSDF(vec3(p.x + MinD, p.y, p.z)).d  - sceneSDF(vec3(p.x - MinD, p.y, p.z)).d,\n\t\t\t\t\t\t\tsceneSDF(vec3(p.x, p.y + MinD, p.z)).d  - sceneSDF(vec3(p.x, p.y - MinD, p.z)).d,\n\t\t\t\t\t\t\tsceneSDF(vec3(p.x, p.y, p.z  + MinD)).d - sceneSDF(vec3(p.x, p.y, p.z - MinD)).d));\n}\nvec3 RayRr (in vec3 ro, in vec3 rd, int dr) {\n\tvec3 n,col,r_d,io;\n\tcol=vec3(0.0);\n\tres t0 = RayMarch(ro,rd,NearP,FarP);\n\tfor (int i = 0; i < dr; i++) {\n\t\tif (t0.m==1) {\n\t\t\tro = ro + t0.d * rd;\n\t\t\tn = GradeSdfNormal(ro);\n            if (dot(rd,n)>=0.0){n=-n;}\n\t\t\trd = normalize(lp-ro);\n\t\t\tr_d = vec3(dot(rd,n)*0.9);\n\t\t\tfloat f = mod( floor(2.0*ro.z) + floor(2.0*ro.x), 2.0);\n\t\t\tcol -= (vec3( 0.5*f)+vec3(0.2,0.2,0.2))*(1.0-r_d);\n\t\t\tt0 = RayMarch(ro,rd,NminR,NmaxR);\n            continue;\n\t\t}\n\t\telse if (t0.m==2) {\n\t\t\tro = ro + t0.d * rd;\n\t\t\tn = GradeSdfNormal(ro);\n\t\t\tif (dot(rd,n)<0.0){io.x=kr_air/kr_glass;}else{io.x=kr_glass/kr_air;n=-n;}\n\t\t\tr_d = vec3(dot(rd,n)*0.1);\n\t\t\tcol -= vec3(0.1,0.1,0.01)*(1.0-r_d);\n            vec3 rd2=rd;\n\t\t\trd = refract(rd,n,io.x);\n            if (rd==vec3(0.0)){rd=reflect(rd2,n);}\n\t\t\tt0 = RayMarch(ro,rd,NminR,NmaxR);\n            continue;\n\t\t}\n\t\telse if (t0.m==3) {\n\t\t\tcol += vec3(1.0,1.0,0.9);\n\t\t\tbreak;\n\t\t}\n\t\tif (t0.m==4) {\n\t\t\tro = ro + t0.d * rd;\n\t\t\tn = GradeSdfNormal(ro);\n\t\t\tif (dot(rd,n)>=0.0){n=-n;}\n\t\t\trd = normalize(lp-ro);\n\t\t\tr_d = vec3(dot(rd,n)*0.9);\n\t\t\tcol -= (vec3(0.1,0.3,0.2))*(1.0-r_d);;\n\t\t\tt0 = RayMarch(ro,rd,NminR,NmaxR);\n            continue;\n\t\t}\n\t\telse {\n\t\t\tro = ro + t0.d * rd;\n\t\t\tfloat sun =dot(rd,normalize(ro-lp));\n\t\t\tvec3 clo=0.9*(sun*(vec3(0.65,0.75,0.9)-(rd.y*0.5))) ;\n\t\t\tcol+=clo.xyz-vec3(0.01,0.01,0.01);\n\t\t\tbreak;\n\t\t}\n\n\t}\n\t\n\n\treturn clamp(col,0.0,1.0) ;\n}\nvoid mainImage( out vec4 oC0, in vec2 tc0 ) \n{\n\tvec3 col;\n\tlp = vec3(10.0 * sin(itime*2.5),4.0,10.0 * cos(itime*2.5));\n\t// camera\n\tvec2 s_uv = (2.0*tc0-iResolution.xy)/iResolution.y;\n\tfloat cl2 = sin(0.5*itime);\n\tfloat an = 10.0*iMouse.x/iResolution.x+3.57 + 3.7*sin(0.15*itime);\n\tvec3  ta = vec3( 0.0, 0.35, cl2);\n\tvec3  ro = ta + vec3( 10.0*cos(an),2.250+10.0*cos(4.0*iMouse.y/iResolution.y), -10.0*sin(an)+cos(4.0*iMouse.y/iResolution.y) );\n\tfloat ti = fract(itime-0.15);\n\tti = 4.0*ti*(1.0-ti);\n\tta.y += 0.15*ti*ti*(3.0-2.0*ti)*smoothstep(0.4,0.9,cl2);\n\n\tmat3 ca = setCamera( ro, ta, 0.0 );\n\t// ray direction\n\tvec3 rd = ca * normalize( vec3(s_uv,1.8) );\n\t//Render\n\tcol = RayRr(ro,rd,10);\n\n\toC0 = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}