{"ver":"0.1","info":{"id":"4cKyD1","date":"1731805183","viewed":62,"name":"SDF lerping","username":"badatcode123","description":"just some lerping between SDFs","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float hit_rad = 0.1;\nconst vec3 light_dir = normalize(vec3(-1,-1,1));\nconst float ambient = 0.05;\n\n\nstruct ray{\n    vec3 origin;\n    vec3 dir;\n    vec3 col;\n};\nstruct hit{\n    bool hit;\n    float sde;\n    vec3 col;\n};\nstruct sphere{\n    vec3 pos;\n    float rad;\n    vec3 col;\n};\nstruct box{\n    vec3 pos;\n    vec3 s;\n    vec3 col;\n};\nfloat SDsphere(ray ray, sphere sphere, inout hit hit){\n    return distance(ray.origin,sphere.pos)-sphere.rad;\n}\nfloat SDbox(ray ray, box box, inout hit hit){\n    //from https://iquilezles.org/articles/distfunctions/\n    vec3 q = abs(ray.origin) - box.s;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nvoid update(float sde, vec3 col, inout hit hit){\n    if (sde < hit.sde){\n        hit.sde = sde;\n        if (sde <= hit_rad){\n            hit.hit = true;\n        }\n        hit.col = col;\n    }\n}\nvoid scene(ray ray, inout hit hit){\n    hit.hit = false;\n    hit.sde = 2500.0;\n    float t = smoothstep(0.0,1.0,cos(iTime)+0.5);\n    float sdf;\n    \n    sphere sphere = sphere(vec3(0),15.0,vec3(0.5,1,0.5));\n    box box = box(vec3(0),vec3(15)/2.0,vec3(1,0.5,0.5));\n    \n    sdf = SDsphere(ray,sphere,hit);\n    sdf = mix(sdf,SDbox(ray,box,hit),t);\n    vec3 colLerp = mix(sphere.col,box.col,t);\n    update(sdf,colLerp,hit);\n    \n}\nfloat f(vec3 p){\n    ray ray2;\n    ray2.origin = p;\n    hit hit2;\n    scene(ray2,hit2);\n    return hit2.sde;\n}\nvec3 calcNormal(vec3 p )\n//from https://iquilezles.org/articles/normalsSDF/\n{\n    const float h = 0.001;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*f( p + k.xyy*h ) + \n                      k.yyx*f( p + k.yyx*h ) + \n                      k.yxy*f( p + k.yxy*h ) + \n                      k.xxx*f( p + k.xxx*h ) );\n}\nvec3 shoot_ray(vec3 origin, vec3 dir){\n    ray ray;\n    ray.origin = origin;\n    ray.dir = dir;\n    hit hit;\n    ray.col = vec3(0);\n    int i;\n    for(i = 0; hit.sde <= 500.0 && i < 25; i++){\n        scene(ray,hit);\n        if (hit.hit){\n            vec3 normal = calcNormal(ray.origin);\n            ray.col = (1.0-ambient)*hit.col*clamp(-dot(normal,light_dir),0.0,1.0);\n            ray.col += ambient*hit.col;\n            return ray.col;\n        }\n        ray.origin += ray.dir*hit.sde;\n        if (hit.sde < 0.5){\n            vec3 normal = calcNormal(ray.origin);\n            ray.col += (1.0-hit.sde)*0.07*(1.0-ambient)*hit.col*clamp(-dot(normal,light_dir),0.0,1.0);\n            ray.col += (1.0-hit.sde)*0.07*ambient*hit.col;\n            //some antialiasing\n        }\n    }\n    ray.col += pow(texture(iChannel0,ray.dir).rgb,vec3(2.2));\n    return ray.col;\n}\nvec3 raymarch(vec2 coord, float focal_length){\n    vec3 origin = vec3(0,0,-100);\n    vec3 dir = normalize(vec3(coord,focal_length));\n    return shoot_ray(origin,dir);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = fragCoord/iResolution.x - vec2(0.5,iResolution.y/(2.0*iResolution.x));\n    coord *= 2.0;\n    vec3 col = raymarch(coord,2.0);\n    col = pow(col,vec3(1.0/2.2));\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}