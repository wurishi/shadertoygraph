{"ver":"0.1","info":{"id":"WtSXRW","date":"1567440121","viewed":204,"name":"Sparks - music visualisation","username":"Lom","description":"Test with your own music and play with the constants in the common tab.\nAlso check out miavono if you like the song.","likes":4,"published":1,"flags":96,"usePreview":0,"tags":["music","sparks","visualisation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    fragColor = iFrame > INIT_FRAME ? texelFetch(iChannel0, ivec2(fragCoord), 0) : vec4(0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4ddGzM","filepath":"https://soundcloud.com/miavono/sparks","previewfilepath":"https://soundcloud.com/miavono/sparks","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"int getIndex(ivec2 coord)\n{\n    return coord.x+coord.y*int(iResolution.x);\n}\n\nfloat getHue(float curVol, float avgVol, float hue, vec2 fragCoord)\n{\n    float hueSpread = clamp(curVol / avgVol - COLOR_CHANGE_VOLUME, 0., 1.);\n    return mod(hue + rand(fragCoord+iTime)*hueSpread-hueSpread*.5, 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int index = getIndex(ivec2(fragCoord));  \n    if (index < NUM_BALLS && index >= 0)\n    { \n        vec4 ballData = iFrame > INIT_FRAME ? texelFetch(iChannel0, ivec2(fragCoord), 0) : vec4(vec3(0), rand(fragCoord)*2.*PI);\n        vec2 pos = ballData.xy;    //position\n        float hue = ballData.z;    //hue\n        float dir = ballData.w;    //direction     \n        vec4 volData = iFrame > INIT_FRAME ? texelFetch(iChannel0, getCoords(NUM_BALLS, ivec2(iResolution.xy)), 0) : vec4(0);\n        float curVol = volData.x;  //current volume\n        float avgVol = volData.y;  //average volume\n        float avgHue = volData.z;  //average hue\n\n        float vel = min(MAX_SPEED, curVol / avgVol / 10.);\n        \n        dir += (rand(iTime+fragCoord)-0.5)/10.;\n        if (getZ(index, iTime) > BACK-Z_SPEED*iTimeDelta) \n        {\n            if (pos.x < -BORDER || pos.x > BORDER || pos.y < -BORDER || pos.y > BORDER) \n            {\n                pos.xy = vec2(0);\n                dir = iTime*2.;\n            }\n        }\n        if (curVol < COLAPSE_VOLUME*avgVol) \n        {\n            dir = atan(-pos.x, -pos.y);\n            vel = MAX_SPEED;\n        }\n        pos.x += sin(dir)*vel;\n        pos.y += cos(dir)*vel;\n        \n\t\t\n        float colDif = avgHue-hue;\n        hue += sign(colDif)*sign(0.5-abs(colDif))* COLOR_CHANGE_SPEED*min(abs(colDif), 1.-abs(colDif)); \n        \n        if (curVol > COLOR_CHANGE_VOLUME*avgVol) \n        {\n            hue = getHue(curVol, avgVol, hue, fragCoord);          \n        }\n        hue = mod(hue,1.);\n        \n        fragColor = vec4(pos, hue,  dir);\n    }\n    else if (index == NUM_BALLS) //volume\n    {\n        float curVol = 0.;\n        vec4 volData = iFrame > INIT_FRAME ? texelFetch(iChannel0, ivec2(fragCoord), 0) : vec4(0);\n        float avgVol = volData.y;\n        float avgVolDif = volData.w;\n        for (int i = 0; i < int(iChannelResolution[1].x); i++) \n        {\n            curVol += abs(texelFetch(iChannel1, ivec2(i, 1), 0).r-.5);\n        }\n        curVol /= iChannelResolution[1].x;\n        avgVol = avgVol*(1.-AVERAGE_VOLUME_DECAY)+curVol*AVERAGE_VOLUME_DECAY;\n        avgVolDif = avgVolDif*(1.-AVERAGE_VOLUME_DECAY)+abs(curVol-avgVol)/avgVol*AVERAGE_VOLUME_DECAY;\n        float hue = volData.z;\n        if (curVol > COLOR_CHANGE_VOLUME*avgVol || iFrame == 0) \n        {\n            hue = getHue(curVol, avgVol, hue, fragCoord);  \n        }\n        fragColor = vec4(curVol, avgVol, hue, avgVolDif);   \n    }\n    else\n    {\n        fragColor = vec4(.0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float PI = 3.141592653;\n\nconst int NUM_BALLS = 200;\nconst int INIT_FRAME = 100;\nconst float BACK = 80.;\nconst float FOV = 45. * PI / 180.; //degrees to radians\nconst float MAX_FREQ = 10000.;\nconst float FOG_START = 50.;\nconst float FOG_END = 80.; \nconst float Z_SPEED = 0.3*60.;\nconst float COLOR_CHANGE_SPEED = .005;\nconst float MAX_SPEED = .3;\nconst float COLAPSE_VOLUME = .3;\nconst float COLOR_CHANGE_VOLUME = 2.;\nconst float AVERAGE_VOLUME_DECAY = .02;\n\nconst float Z = .5 / tan(FOV / 2.);\nconst vec3 DIR = normalize(vec3(0.5, 0, Z));\nconst float BORDER = BACK / DIR.z * DIR.x;\n\nivec2 getCoords(int index, ivec2 res) \n{\n    return ivec2(index % res.x, index / res.x);\n}\n\n// return a \"random\" number.\n// from https://www.shadertoy.com/view/XdtSWn\nhighp float rand(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\nvec3 hueToRGB(float hue)\n{\n    hue = fract(hue)*6.;\n    vec3 color;\n    color.r = clamp(abs(hue-3.)-1.,0.,1.);\n    color.g = clamp(-abs(hue-2.)+2.,0.,1.);\n    color.b = clamp(-abs(hue-4.)+2.,0.,1.);\n    return color;\n}\n\nfloat getZ(int index, float time) \n{\n    return mod(float(index)/float(NUM_BALLS)*BACK-Z_SPEED*time, BACK);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec4 getData(int index) \n{\n    ivec2 coord = getCoords(index, ivec2(iResolution.xy));\n    return texelFetch(iChannel0, coord, 0);\n}\n\nvec3 intersect(vec3 pos, vec3 dir)\n{ \n    return pos.z / dir.z * dir;\n}\n   \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy/2.0)/iResolution.y;\n    vec3 dir = normalize(vec3(uv, Z));\n\n\n    vec3 color = vec3(0);\n    vec4 volData = getData(NUM_BALLS);\n\n    for (int i = 0; i < NUM_BALLS; i++)\n    {\n        vec4 ballData = iFrame > INIT_FRAME ? getData(i) : vec4(0);\n    \tvec3 pos = vec3(ballData.xy, getZ(i, iTime));\n        float radius = volData.x / volData.y / 2.;\n        vec3 hit = intersect(pos, dir);\n        float dis = distance(hit.xy, pos.xy);\n        if (dis < radius) color += hueToRGB(ballData.z)*(1.0-dis/radius)*clamp((FOG_END-pos.z) / (FOG_END-FOG_START), 0., 1.);\n    }\n    fragColor = clamp(vec4(color,1.0)+max(0., 1.-pow(volData.w, 2.))*texelFetch(iChannel1, ivec2(fragCoord), 0)-0.001, 0., 1.);\n}","name":"Buffer B","description":"","type":"buffer"}]}