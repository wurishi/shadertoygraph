{"ver":"0.1","info":{"id":"X3jBzG","date":"1729783242","viewed":52,"name":"potential map","username":"2CM","description":"f","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["f"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float m = 1.0;\n\nfloat onLine(vec2 v) {\n    float lastSign = sign(sin(texture(iChannel0, v).r * PI * m - iTime * 4.0));\n\n    for(float i = 0.0; i < PI * 2.0; i += PI / 6.0) {\n        vec2 angle = vec2(cos(i), sin(i)) * 0.00125 * (vec2(iResolution.y/iResolution.x, 1));\n        \n        float s = sign(sin(texture(iChannel0, v + angle).r * PI * m - iTime * 4.0));\n        \n        if(s != lastSign) {\n            return 1.0;\n        }\n    }\n    \n    return 0.0;\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec4 pass(vec2 fragCoord) {\n    vec2 vuv = vec2(-1) + 2.0 * (fragCoord - vec2(0.5 * (iResolution.x - iResolution.y), 0))/iResolution.yy;\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 tex = texture(iChannel0, uv);\n    float potential = tex.r;\n    \n    for(int i = 0; i < POINTS; i++) {\n        if(distance(vuv, points[i].position) < 0.02) {\n            return potentialToColor(points[i].charge) + 20.0 * (0.04 - distance(vuv, points[i].position));;\n        }\n    }\n    \n    for(int i = 0; i < LINES; i++) {\n        vec2 closest = vec2(lines[i].position.x, clamp(vuv.y, lines[i].position.y - lines[i].length * 0.5, lines[i].position.y + lines[i].length * 0.5));\n        \n        if(distance(vuv, closest) < 0.02) {\n            return potentialToColor(lines[i].charge) + 20.0 * (0.04 - distance(vuv, closest));\n        }\n    \n        //total += potentialLine(v, lines[i]);\n    }\n    \n    if(abs(potential) > 10.0) {\n        return vec4(1);\n    }\n    \n    vec4 color = potentialToColor(potential);\n    \n    //fragColor = mix(vec4(1), vec4(lineValue) * color, lineValue * colorMap(abs(potential)));\n    \n    float line = onLine(uv);\n    \n    return mix(vec4(1), color, line * colorMap(potential) + abs(tex.r) * 0.1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //https://www.shadertoy.com/view/mtyXzV\n    float AA_STAGES = 2.0;\n    float AA_JITTER = 0.5;\n    float AA_TOTAL_PASSES = AA_STAGES * AA_STAGES + 1.0;\n    \n    vec4 color = pass(fragCoord);\n\n    for (float x = 0.0; x < AA_STAGES; x++) {\n        for (float y = 0.0; y < AA_STAGES; y++)\n        {\n            vec2 offset = AA_JITTER * (2.0 * hash22(vec2(x, y)) - 1.0);\n            color += pass(fragCoord + offset);\n        }\n    }\n    \n    fragColor = color / AA_TOTAL_PASSES;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159\n\nstruct Point {\n    vec2 position;\n    float charge;\n};\n\n\nstruct Line {\n    vec2 position;\n    float length;\n    float charge;\n};\n\n#define POINTS 2\nPoint[] points = Point[POINTS] (\n    Point(vec2(-0.5,0.5), -5.0),\n    Point(vec2(-0.7,-0.5), 3.0)\n);\n\n#define LINES 1\nLine[] lines = Line[LINES] (\n    Line(vec2(0.5,-0), 1.0, 2.0)\n);\n\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nfloat potentialPoint(vec2 v, Point point) {\n    return point.charge / distance(v, point.position);\n}\n\nfloat potentialLine(vec2 v, Line line) {\n    vec2 p = line.position;\n    float charge = line.charge;\n    float l = line.length;\n\n    if(abs(v.x - p.x) < 0.0075 && abs(v.y - p.y) > l/2.0) {\n        return charge * abs(log2(abs(l/2.0 + (v.y - p.y))) - log2(abs(-l/2.0 + (v.y - p.y))))/log2(2.718);\n    }\n\n    float a = atan((-l/2.0 + (v.y - p.y))/(v.x - p.x));\n    float b = atan((+l/2.0 + (v.y - p.y))/(v.x - p.x));\n    \n    return charge * abs((log2(1.0/cos(b) + tan(b)) - log2(1.0/cos(a) + tan(a)))/log2(2.718));\n}\n\nfloat potentialTotal(vec2 v, float time) {\n    /*\n    return (\n        potentialPoint(v, Point(vec2(sin(time), 0), 2.0)) +\n        potentialPoint(v, Point(vec2(2.0 * cos(time), cos(time)), 1.0)) + \n        potentialPoint(v, Point(vec2(cos(2.0 * time), sin(time)), -3.0)) +\n        potentialLine(v, Line(vec2(0.5, 0.25), 1.0, 2.0))\n    );\n    */\n\n    float total = 0.0;\n    \n    for(int i = 0; i < POINTS; i++) {\n        total += potentialPoint(v, points[i]);\n    }\n    \n    for(int i = 0; i < LINES; i++) {\n        total += potentialLine(v, lines[i]);\n    }\n    \n    return total;\n}\n\nfloat colorMap(float v) {\n    return 1.0 / pow((1.0 / v) + 1.0, 2.0);\n}\n\nvec4 potentialToColor(float v) {\n    return vec4(sign(v), 0.0, 1.0 - sign(v), 1.0);\n}\n\nvec4 blend(vec4 source, vec4 destination, float alpha) {\n    return source * alpha + destination * (1.0-alpha);\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(-1) + 2.0 * (fragCoord - vec2(0.5 * (iResolution.x - iResolution.y), 0))/iResolution.yy;\n\n    float potential = potentialTotal(uv, iTime);\n\n    fragColor = vec4(-potential, 0, 0, 1);\n}","name":"Buffer A","description":"","type":"buffer"}]}