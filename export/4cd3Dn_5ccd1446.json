{"ver":"0.1","info":{"id":"4cd3Dn","date":"1711569078","viewed":43,"name":"Mandelbrot^2","username":"BagelOrb","description":"Mandelbrot, but changing the end condition shape from circular.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["fractal","mandelbrot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalize fragCoord to the range [0, 1]\n    vec2 uv = fragCoord / iResolution.xy;\n    // Sample the texture from iChannel0 (Buffer A)\n    vec4 color = texture(iChannel0, uv);\n    // Set the output fragment color\n    fragColor = color;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define SMOOTHNESS .0\n\nfloat smin(float a, float b)\n{\n    float h = clamp(0.5 + .5 * (b-a) / SMOOTHNESS, 0., 1.);\n    return mix(b, a, h) - SMOOTHNESS * h * (1. - h);\n}\n\nfloat smax(float a, float b)\n{\n    float h = clamp(0.5 - .5 * (b-a) / SMOOTHNESS, 0., 1.);\n    return mix(b, a, h) + SMOOTHNESS * h * (1. - h);\n}\n\nbool shape(vec2 a)\n{\n    return smax(length(a + vec2(.2,0.)), length(a - vec2(.2,0.))) < .5;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAX_ITER 100\n\n\nvec2 rotateCCW(vec2 v, float a) {\n    float ca = cos(a);\n    float sa = sin(a);\n    return vec2(ca * v.x - sa * v.y, sa * v.x + ca * v.y);\n}\n\nint mand1(vec2 uv) {\n    vec2 c = uv;\n    vec2 z = vec2(0.0, 0.0);\n    int i;\n    for(i = 0; i < MAX_ITER / 4; i++) {\n        float x = (z.x * z.x - z.y * z.y) + c.x;\n        float y = (2.0 * z.x * z.y) + c.y;\n        z.x = x;\n        z.y = y;\n        if((z.x * z.x + z.y * z.y) > 4.0) {\n        //if (shape(z * 2.25 + vec2(cos(iTime)*.25, 0.))) {\n        //if (length(texture(iChannel0, rotateCCW(z, cos(iTime)))) < .0001 || length(z) > 4.) {\n            return i; // Return the number of iterations before escape\n        }\n    }\n    return -1; // Indicates the point is likely in the Mandelbrot set\n}\n\n\nint mand(vec2 uv) {\n    vec2 c = uv;\n    vec2 z = vec2(0.0, 0.0);\n    int i;\n    for(i = 0; i < MAX_ITER; i++) {\n        float x = (z.x * z.x - z.y * z.y) + c.x;\n        float y = (2.0 * z.x * z.y) + c.y;\n        //x += .5 * intBitsToFloat(floatBitsToInt(x) ^ int(8765. * iTime) % 14123);\n        z.x = x;\n        z.y = y;\n        //if((z.x * z.x + z.y * z.y) > 4.0) {\n        //if (shape(z * .25 + vec2(cos(iTime)*.25, 0.))) {\n        int r = mand1(rotateCCW(z, sin(iTime / 3.)*.1) * (3. + .5 * cos(iTime)) - vec2(.75, 0.));\n        if (r > 0) {\n        //if (length(texture(iChannel0, rotateCCW(z, cos(iTime)))) < .0001 || length(z) > 4.) {\n            return i ^ r; // Return the number of iterations before escape\n        }\n    }\n    return -1; // Indicates the point is likely in the Mandelbrot set\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 intToRainbowColor(int value) {\n    float hue = float(value) / float(MAX_ITER); // Normalize value to [0,1]\n    float saturation = 0.6; // Keep saturation constant for simplicity\n    float brightness = value > 0 ? 0.125 + pow(hue, .25) * 0.875 : 0.0; // Darker for lower values, brighter for higher\n    return hsv2rgb(vec3(hue + iTime * .05, saturation, brightness));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - .5 * iResolution.xy)/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    int iter = mand(uv * (1.01 + sin(iTime / 8.)) - iMouse.xy/iResolution.y + vec2(.5));\n    \n    if (iter >= 0) {\n        col = col / float(iter);\n        col.rgb = intToRainbowColor(iter);\n    } else {\n        col = vec3(0.);\n    }\n    \n    //if (shape(uv)) { col *= 0.; }\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}