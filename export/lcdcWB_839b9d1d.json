{"ver":"0.1","info":{"id":"lcdcWB","date":"1731835389","viewed":20,"name":"Ray Marcher v0.25","username":"pg_dev","description":"A very basic ray marcher.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","raytracing","raymarching","ray"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat4 getCameraMatrix(vec3 position, vec3 rotation) {\n\tmat4 camRotationXMat = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(rotation.x), -sin(rotation.x), 0.0, 0.0, sin(rotation.x), cos(rotation.x), 0.0, 0.0, 0.0, 0.0, 1.0);\n\tmat4 camRotationYMat = mat4(cos(rotation.y), 0.0, sin(rotation.y), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(rotation.y), 0.0, cos(rotation.y), 0.0, 0.0, 0.0, 0.0, 1.0);\n\tmat4 camRotationZMat = mat4(cos(rotation.z), -sin(rotation.z), 0.0, 0.0, sin(rotation.z), cos(rotation.z), 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);\n\tmat4 camPosMat = mat4(1.0, 0.0, 0.0, position.x, 0.0, 1.0, 0.0, position.y, 0.0, 0.0, 1.0, position.z, 0.0, 0.0, 0.0, 1.0);\n\n\treturn camPosMat * ((camRotationZMat * camRotationYMat) * camRotationXMat);\n}\n\nstruct SDFResult {\n    float dist;\n    vec3 color;\n    float metalness;\n    float roughness;\n};\n\nSDFResult sdfSphere(vec3 p, vec3 position, float radius, vec3 color, float roughness, float metalness) {\n    SDFResult result;\n    result.dist = length(p - position) - radius;\n    result.color = color;\n    result.metalness = metalness;\n    result.roughness = roughness;\n    return result;\n}\n\nSDFResult sdfBox(vec3 p, vec3 position, vec3 size, vec3 color, float roughness, float metalness) {\n    vec3 d = abs(p - position) - size;\n    SDFResult result;\n    result.dist = length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n    result.color = color;\n    result.metalness = metalness;\n    result.roughness = roughness;\n    return result;\n}\n\n\nSDFResult sdfScene(vec3 p) {\n    vec3 sphereColor = vec3(0.95, 0.095, 0.095);\n    float sphereRoughness = 0.0;\n    float sphereMetalness = 0.0;\n    vec3 boxColor = vec3(0.095, 0.95, 0.095);\n    float boxRoughness = 0.0;\n    float boxMetalness = 0.0;\n\n    SDFResult sphere = sdfSphere(mod(p, 128.0) - 64.0, vec3(0.0, 0.0, 0.0), 16.0, sphereColor, sphereRoughness, sphereMetalness);\n    SDFResult box = sdfBox(mod(p, 256.0) - 128.0, vec3(0.0, -2.0, 0.0), vec3(64.0, 2.0, 64.0), boxColor, boxRoughness, boxMetalness);\n        \n    if (sphere.dist < box.dist) {\n        return sphere;\n    }\n    \n    return box;\n}\n\n\nvec3 calculateNormal(vec3 p) {\n    float eps = 0.05;\n    return normalize(vec3(\n        sdfScene(p + vec3(eps, 0.0, 0.0)).dist - sdfScene(p - vec3(eps, 0.0, 0.0)).dist,\n        sdfScene(p + vec3(0.0, eps, 0.0)).dist - sdfScene(p - vec3(0.0, eps, 0.0)).dist,\n        sdfScene(p + vec3(0.0, 0.0, eps)).dist - sdfScene(p - vec3(0.0, 0.0, eps)).dist\n    ));\n}\n\nstruct Ray {\n    vec3 orig;\n    vec3 dir;\n};\n\nconst float pi = 3.14159265358979;\nconst float tau = 6.28318530717958;\n\nfloat fovDeg = 70.0;\n\nvec3 skyCol1 = vec3(1.0, 1.0, 1.0);\nvec3 skyCol2 = vec3(0.5, 0.7, 1.0);\nvec3 sunPos = normalize(vec3(0.5, 1.0, -0.5));\nfloat sunThreshold = 0.999;\nvec3 sunCol = vec3(1.0, 0.95, 0.85);\n\nvec3 getEnvCol(vec3 dir) {\n    float t = dir.y * 0.5 + 0.5;\n    vec3 skyColor = mix(skyCol1, skyCol2, t);\n    \n    vec3 sunContrib = smoothstep(sunThreshold, 1.0, dot(dir, sunPos)) * sunCol;\n    \n    return skyColor + sunContrib;\n}\n\nvec3 getOrbitingCameraPosition(float radius, float angleX, float angleY) {\n    // Use spherical coordinates to calculate position\n    float x = radius * cos(angleY) * cos(angleX);\n    float y = radius * sin(angleY);\n    float z = radius * cos(angleY) * sin(angleX);\n    return vec3(x, y, z);\n}\n\nmat4 lookAt(vec3 eye, vec3 target, vec3 up) {\n    // Calculate the camera's orientation matrix to look at the origin\n    vec3 z = normalize(eye - target);\n    vec3 x = normalize(cross(up, z));\n    vec3 y = cross(z, x);\n\n    return mat4(\n        vec4(x, 0.0),\n        vec4(y, 0.0),\n        vec4(z, 0.0),\n        vec4(eye, 1.0)\n    );\n}\n\nfloat calculateSoftShadow(vec3 point, vec3 lightDir) {\n    float shadow = 1.0;\n    float maxDistance = 1024.0; // Maximum distance to march in the shadow ray\n    float minDist = 0.1; // Minimum safe distance threshold\n    float k = 16.0; // Soft shadow constant for penumbra control\n    float totalDistance = 0.0;\n    \n    // March the shadow ray from the point towards the light source\n    for (int i = 0; i < 64; i++) {\n        float dist = sdfScene(point + lightDir * totalDistance).dist;\n        \n        if (dist < minDist) {\n            // The point is in shadow\n            shadow = 0.0;\n            break;\n        }\n        \n        shadow = min(shadow, k * dist / totalDistance);\n        totalDistance += dist;\n        \n        // Stop if the ray exceeds the maximum distance\n        if (totalDistance > maxDistance) break;\n    }\n    \n    return clamp(shadow, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = fragCoord / iResolution.xy;\n    vec2 ndc = uv - 0.5;\n    \n    float fov = radians(fovDeg);\n    float screenWidth = 2.0 * tan(fov / 2.0);\n    float aspectRatio = iResolution.x / iResolution.y;\n    float screenHeight = screenWidth / aspectRatio;\n    \n    vec3 col = vec3(0.0);\n    \n    vec2 mouseCoord = iMouse.xy / iResolution.xy - 0.5;\n    float radius = 128.0;\n    float angleX = mouseCoord.x * tau * 0.99;\n    float angleY = -mouseCoord.y * pi * 0.99;\n\n    //vec3 camPos = getOrbitingCameraPosition(radius, angleX, angleY);\n    vec3 camPos = vec3(0.0, 16.0, -128.0 + iTime * 128.0);\n    //vec3 target = vec3(0.0, 16.0, 0.0);\n    //vec3 up = vec3(0.0, 1.0, 0.0);\n\n    //mat4 camMat = lookAt(camPos, target, up);\n    vec3 camRot = vec3(mouseCoord.y * tau, -mouseCoord.x * tau, 0.0);\n    camRot.x = clamp(camRot.x, -pi / 2.0, pi / 2.0);\n    mat4 camMat = getCameraMatrix(camPos, camRot);\n    \n    Ray r;\n    r.orig = camPos;\n    vec4 rd = normalize(vec4(ndc.x * screenWidth, ndc.y * screenHeight, 1.0, 0.0));\n    \n    r.dir = normalize((camMat * rd).xyz);\n    \n    int iterations = 128;\n    bool hit = false;\n    vec3 hitColor = vec3(0.0);\n    float d = 0.0;\n    vec3 rp = r.orig;\n    float roughness = 0.0;\n    float metallic = 0.0;\n\n    for (int i = 0; i < iterations; i++) {\n        SDFResult result = sdfScene(rp);\n        if (result.dist < 0.05) {\n            hit = true;\n            hitColor = result.color;\n            roughness = result.roughness;\n            metallic = result.metalness;\n            break;\n        }\n\n        if (d > clamp(pow(iTime * 16.0, 2.0), 0.0, 8192.0)) {\n            break;\n        }\n\n        rp += r.dir * result.dist;\n        d += result.dist;\n    }\n    if (true) {\n    if (hit) {\n        vec3 normal = calculateNormal(rp);\n        vec3 viewDir = normalize(r.orig - rp);\n        \n        // Calculate diffuse lighting\n        float diffuse = max(dot(normal, sunPos), 0.0);\n\n        // Calculate shadow\n        float shadow = calculateSoftShadow(rp + normal, sunPos);\n\n        col = (hitColor * diffuse * 0.5) * 1.0 * sunCol + vec3(0.1, 0.1, 0.1) * hitColor;\n    } else {\n        col = getEnvCol(r.dir);\n    }\n    } else {\n    col = vec3(d / 4096.0);\n}\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}