{"ver":"0.1","info":{"id":"ftSSDy","date":"1628465904","viewed":442,"name":"Growing/weathering rocks","username":"stb","description":"An attempt to make a bump/height map for natural stone surfaces. Not physically-based.\n\nClick to move light source, click the bottom of the screen to reset & reseed.","likes":47,"published":1,"flags":32,"usePreview":0,"tags":["2d","heightfield","map","heightmap","bump","field","height","automata","cellular","ca","automaton","stones","cliff"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n\tGrowing/weathering rocks\n    \n    2021 stb\n    \n    Image shader\n    Input: iChannel 0 - Buf A (Filter: linear; Wrap: repeat)\n\n*/\n\n#define res iResolution.xy\n\n// texture sampler (height)\nfloat map(vec2 p) {\n    return texture(iChannel0, p).r;\n}\n\n// surface normal function\nvec3 getNorm(vec2 p) {\n    vec3 acc = vec3(-1., 0., 1.);\n    return\n        normalize(\n            vec3(\n                map(p+acc.zy/res) - map(p+acc.xy/res),\n            \tmap(p+acc.yz/res) - map(p+acc.yx/res),\n            \t.0625*acc.z\n\t\t\t)\n\t\t);\n}\n\nvoid mainImage( out vec4 fo, in vec2 fc ) {\n\t// ...\n    vec2 uv = fc.xy / res;\n    \n    // image aspect\n    vec3 asp = vec3(1., res.y/res.x, 1.);\n    \n    // get normal\n    vec3 norm = getNorm(uv);\n    \n    // 3d vector from uv\n    vec3 p = vec3(uv, 0.);\n    \n    // light position\n    vec3 light = vec3(iMouse.xy/res*4.-1.5, -1.);\n    \n    // light distance\n    float dist = pow(length(light-vec3(.5, .5, 0.)), .5);\n    \n    // get diffuse lighting\n    float diff = pow(clamp(dot(normalize(asp*(p-light)), norm), 0., 1.), .5) / dist;\n    \n    // get specular reflection\n    vec3 ref = reflect(vec3(p.xy-.5, 1.), norm);\n    float spec = pow(clamp(dot(normalize(ref), normalize(asp*(light-p))), 0., 1.), 1.);\n    \n    // initial value of f is the red channel of Buf A\n    float f = .2 * map(uv);\n    \n    // add diffuse\n    f += .975 * pow(diff, 2.);\n    \n    // add specular\n    f += .15 * spec;\n    \n    // something like ambient occlusion, but more like a proximity pattern\n    float prox = 3. * (texture(iChannel0, uv).r - texture(iChannel0, uv).g) / dist;\n    \n    // output\n    fo = vec4(f+vec3(prox, .5*prox, 0.), 1.);\n    \n    // show rest area when clicking\n    if(iMouse.z>0. && fc.y<16.) fo.rgb += vec3(1., 0., 0.);\n    \n    // view only the channels\n    //fo = vec4(texture(iChannel0, uv).rg, 0., 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n\n    Growing/weathering rocks\n    \n    2021 stb\n    \n    Buffer shader\n    Input/Output: iChannel0 - Buf A (Filter: nearest; Wrap: repeat)\n\n*/\n\n// hash without sine\n// https://www.shadertoy.com/view/4djSRW\n#define MOD3 vec3(443.8975, 397.2973, 491.1871) // uv range\n//#define MOD3 vec3(.1031, .11369, .13787) // int range\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// texture definition\n#define tx(o) texture( iChannel0, uv+o/res )\n\nvoid mainImage( out vec4 fo, in vec2 fc ) {\n\tvec2 res = iResolution.xy;\n    vec2 uv = fc / res;\n    vec2 fc2 = fc*.0005;\n    vec3 o = vec3(-1., 0., 1.);\n    \n    // texture samples\n    vec4 s[9];\n    \n    //\tsample directions\n    //\ts[7] s[4] s[8]\n\t//\ts[1] s[0] s[2]\n\t//\ts[5] s[3] s[6]\n    \n    s[0] = tx(o.yy);\n    \n    s[1] = tx(o.xy);\n    s[2] = tx(o.zy);\n    s[3] = tx(o.yx);\n    s[4] = tx(o.yz);\n    \n    s[5] = tx(o.xx);\n    s[6] = tx(o.xz);\n    s[7] = tx(o.zx);\n    s[8] = tx(o.zz);\n    \n    // these will be saved to red and green channels\n    float r, g;\n    \n    // center sample\n    float c = s[0].r;\n    \n    // general-purpose blur\n    vec4 blur = .25*s[0] + .125*(s[1]+s[2]+s[3]+s[4]) + .0625*(s[5]+s[6]+s[7]+s[8]);\n    \n    // initial r value\n    r = c;\n    \n    // upward diagonal propagation\n    r = max(r, max(s[5].r-.025, s[7].r)-.01);\n\n    // downward vertical propagation\n    r = max(r, s[4].r-.01);\n\n    // add noise to outside edges/corners\n    r += 4.75 * (c-blur.r) * pow(hash12(mod(fc2+float(iFrame)/100., 100.)), .25*2048.);\n\n    // add noise to inside edges/corners\n    r += .3 * (s[0].g-c) * pow(hash12(mod(fc2+float(iFrame)/87.+3.102, 100.)), .25*2048.);\n\n    // blur outside edges/corners\n    r = mix(r, blur.r, .5*pow(clamp(c-blur.r, 0., 1.), .5));\n\n    // subtract from r\n    r -= .00025;\n\n    // prevent overflow\n    r = min(1., r);\n\n    // new value for g is a simple blur of r mixed with an older and blurred value of g\n    g = mix(blur.r, blur.g, .995);\n    \n    // initialize buffer for first frame or if mouse is clicked in bottom left corner\n    if(iFrame==0 || (iMouse.z>0. && iMouse.y<16.)) {\n        // seed r with noise\n        //r = 1.5 * pow(hash12(mod(fc2+124.73*iTime, 100.)), 4096.);\n        r = 1.5 * pow(hash12(mod(fc2+.01*iMouse.x, 100.)), 8192.);\n        \n        // zero g\n        g = 0.;\n    }\n    \n    // output\n\tfo = vec4(r, g, 0., 0.);\n}","name":"Buffer A","description":"","type":"buffer"}]}