{"ver":"0.1","info":{"id":"4fySRm","date":"1714934707","viewed":177,"name":"Neon Voxel Drops","username":"chronos","description":"3D version of the forked shader + neon raindrops: \nhttps://www.shadertoy.com/view/lcjXRc","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["ray","grid","intersection","traversal"],"hasliked":0,"parentid":"McGXRD","parentname":"Ray Grid Intersections"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Neon Voxel Drops by chronos\n    ---------------------------------------------------------------------\n    \n    3D version of the forked shader + neon raindrops: \n    https://www.shadertoy.com/view/lcjXRc\n    \n    I don't think this is a particularly good implementation of this idea, i just ported the \n    neon raindrops function straigth over (scaled and adapted it slightly),\n    but I would rather have a proper 3D version.\n    \n    self link: https://www.shadertoy.com/view/4fySRm\n\n\n    // Forked shader description:\n    ---------------------------------------------------------------------\n        Ray grid intersections 3D by chronos\n        --------------------------------------\n\n        Nothing special, just doing some more practice in DDA grid traversal.\n    \n*/\n\nconst float PI = 3.14159265;\nfloat sRGBencode(float C_linear) { return C_linear > 0.0031308 ? (1.055 * pow(C_linear, 1./2.4) - 0.055) : (12.92 * C_linear); }\nvec3 sRGBencode(vec3 C_linear) { C_linear = clamp(C_linear, 0., 1.); return vec3(sRGBencode(C_linear.x), sRGBencode(C_linear.y), sRGBencode(C_linear.z)); }\n\nfloat hash(vec3 uv)\n{\n    uint x = floatBitsToUint(uv.x) | 1u; // 0 is a fixed point so we remove it. although this introduces duplicate 1\n    uint y = floatBitsToUint(uv.y);\n    uint z = floatBitsToUint(uv.z);\n    \n    y ^= y >> 13;\n    y ^= y << 17;\n    y ^= y >> 5;\n    y *= 0x2545F491u;\n\n    x ^= y;\n    x ^= x >> 13;\n    x ^= x << 17;\n    x ^= x >> 5;\n    x *= 0x4F6CDD1Du;\n    \n    z ^= x;\n    z ^= z >> 13;\n    z ^= z << 17;\n    z ^= z >> 5;\n    z *= 0x1D6C45F4u;\n    \n    // Shift down by 9 to use top 23 bits in mantissa\n    // Use exponent and sign bits from 0.5\n    // floatBitsToUint(.5) is a constant so that part can be pre-computed. (0x3f000000)\n    // Since the top 23 bits are shifted right, the rest (top bits) are zero and do not need to be masked out\n    // uint w = ((z>>9) & 0x007FFFFFu) | (0xFF800000u & floatBitsToUint(.5));\n    \n    uint w = (z>>9) | 0x3f000000u; // simplified version of the above commented out line\n    \n    // re-normalize from [0.5, 1) to [0, 1)\n    // This probably loses some bits, but should still be ok\n    return 2. * uintBitsToFloat(w) - 1.;\n}\n\n// from \"neon raindrops\" shader by chronos: \n// https://www.shadertoy.com/view/lcjXRc\nvec3 drops(vec2 uv)\n{\n    uv/=20.;\n    vec3 color = vec3(0);\n    float hash_cnt = 0.;\n    // GRID\n    float grid_size = 20.;\n    vec2 g = cos(grid_size * (1.+uv) * PI);\n    float grid = smoothstep(0.98, 0.99, max(g.x, g.y));\n    grid += (.0001/(1.5+max(g.x, g.y)) + grid*(40./255.)*hash(vec3(uv, 0.)));\n\n    // MASKS\n    vec2 mask_uv = abs(uv);\n    float square_mask = smoothstep(1.01, 1.0, max(mask_uv.x, mask_uv.y));\n    float disc_mask   = smoothstep(1., .66, length(uv));\n\n    // UNIT CIRCLE\n    float circle = smoothstep(0.01, 0.005, abs(length(uv)-1.));\n\n    for(int i = 0; i < 7; i++)\n    {\n        int anim_instance = i;\n        // ANIMATION\n        float time_offset = hash(vec3(anim_instance, 1., hash_cnt++));\n        float speed_offset = hash(vec3(anim_instance, 1., hash_cnt++));\n\n        float speed = 0.25 * mix(0.8, 1.2, speed_offset);\n\n        float t = speed * iTime + time_offset;\n        float drop_cycle = fract(t);\n        float drop_instance = floor(t);\n\n        // COLOR\n        vec3 L = normalize(vec3(1));\n        vec3 U = normalize(vec3(2,-1,-1)/3.);\n        vec3 V = cross(L, U);\n        float hue = 2. * PI * hash(vec3(drop_instance, anim_instance, hash_cnt++));\n        vec3 pulse_color = clamp(.5 * L + U * cos(hue) + V * sin(hue), 0., 1.);\n\n        // PULSE\n        vec2 pos = vec2(\n            -.5+hash(vec3(drop_instance, 1., hash_cnt++)),\n            -.5+hash(vec3(drop_instance, 1., hash_cnt++))\n        );\n        vec2 p = abs(uv-pos);\n        float pulse_tail_len = 0.5;\n        float f = p.x + p.y - (pulse_tail_len + 2. * sqrt(2.)) * drop_cycle;\n        float pulse = max(1.-abs(f)/pulse_tail_len, 0.) * exp(-abs(f))/(0.001 + 100.*abs(f));\n \n        pulse_color = mix(pulse_color, vec3(1), 0.1*smoothstep(0.9, .95, pulse));\n        \n        pulse = mix(pulse, pulse*smoothstep(0.01, 0.00, f), .8);\n \n        color += pulse * pulse_color * grid;\n    }\n    \n    color += 0.01 * (.075/(1.5+max(g.x, g.y)) + (40./255.)*hash(vec3(uv, 0.)));\n    \n    color *= mix(0.0, 1., disc_mask);\n    color *= square_mask;\n        \n    return color;\n} \n\nfloat map(vec3 p)\n{\n    p = floor(p) + 0.5 - vec3(0, 10., 0);\n    float result = (length(vec2(p.x, abs(length(p.yz) - 10.))) - 4.);\n    return result;\n}\n\nvec3 rot(vec3 p, vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    vec3 proj = dot(p, axis) * axis;\n    return proj + cos(angle) * (p-proj) + sin(angle) * cross(axis, p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 mouse = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n    vec2 mouse2 = (2.*abs(iMouse.zw)-iResolution.xy)/iResolution.y;\n    float ps = .05;\n    \n    float focal = 1.5;\n    vec3 rd = normalize(vec3(uv, -focal));\n    vec3 ro = vec3(0);\n    \n    float angle = iTime;\n    \n    rd = rot(rd, vec3(0,0,1), angle/2.);\n    \n    ro -= vec3(0., 10., 0.);\n    ro = rot(ro, vec3(1,0,0), angle);\n    ro += vec3(0., 10., 0.);\n    \n    rd = rot(rd, vec3(1,0,0), angle);\n    \n    vec3 color = vec3(0);\n    \n    vec2 grid_uv = vec2(0);\n    vec2 grid_id = vec2(0);\n\n    \n    vec3 steps = vec3(0);\n    float t = 0.;\n    for(float i = 0.; i <= 100.; i++)\n    {\n        vec3 T = ( step(0.0, rd) + sign(rd) * steps - fract(ro) ) / rd;  \n        \n        if(T.x <= T.y && T.x <= T.z)\n        {\n            steps.x += 1.;\n            t = T.x;\n            uv = (rd * t + ro).yz;\n            grid_uv = fract(uv);\n        }\n        else if(T.y < T.x && T.y <= T.z)\n        {\n            steps.y += 1.;\n            t = T.y;\n            uv = (rd * t + ro).zx;\n            grid_uv = fract(uv);\n        }\n        else\n        {\n            steps.z += 1.;\n            t = T.z;\n            uv = (rd * t + ro).xy;\n            grid_uv = fract(uv);\n        }\n        \n        vec3 p = steps*sign(rd) + floor(ro);\n        if(map(p)>0.5)\n        {\n            break;\n        }\n    }\n    \n    float axes_thickness = 0.025;\n    vec2 grid_axes = smoothstep(axes_thickness+ps, axes_thickness, grid_uv) + smoothstep(axes_thickness+ps, axes_thickness, 1.-grid_uv);\n    color = mix(color, vec3(0., 0.3, 0.7), 0.01 + 0.99 * grid_axes.x);\n    color = mix(color, vec3(0.7 , 0., 0.3), 0.01 + 0.99 * grid_axes.y);\n    color *= 0.125;\n    color *= exp(-t*0.3);\n    \n    color += drops(uv);\n    \n    #if 0\n    color = sqrt(tanh(color * color));\n    #endif\n    color = sRGBencode(color);\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}