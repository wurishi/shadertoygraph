{"ver":"0.1","info":{"id":"Mdc3W7","date":"1450026935","viewed":374,"name":"B&W blur filter","username":"havran","description":"Median black & wite blur filter","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["blur","filter","bw","median"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"/*\nThe main idea of the median filter is to run through the signal entry by entry, \nreplacing each entry with the median of neighboring entries. \nThe pattern of neighbors is called the \"window\", which slides,entry by entry, \nover the entire signal. For 1D signals, the most\nobvious window is just the first few preceding and following entries, whereas for 2D \n(or higher-dimensional) signals such as images, \nmore complex window patterns are possible (such as \"box\" or \"cross\" patterns). \nNote that if the window has an odd number of entries, then the median is simple to define: \nit is just the middle value after all the entries in the window are sorted numerically.\nFor an even number of entries, there is more than one possible median, see median for more details.\nSource: https://en.wikipedia.org/wiki/Median_filter\n*/\n\n\n\n//Window size (blur strength)\n#define n 7\n\nfloat colors[n*n];\n\n//Mod function \nint MathMod(int a, int b)\n{\n    int c = int(floor(float(a)/float(b)));\n    return int(a - b * c);\n}\n//get colors from image window and write it to an colors array\nvoid getColors(vec2 coord)\n{\n    vec2 Step= vec2(1.0)/iResolution.xy;\n    \n    for (int i = 0; i < n*n; i++)\n    {\n        vec4 color = texture(iChannel0, coord + vec2(i/n, MathMod(i, n))*Step);\n        \n        colors[i] = (color.r + color.g + color.b)/3.0;\n    }\n}\n//Bubble sort \nvoid sort()\n{\n    bool swapped = true;\n    int j = 0;\n    float tmp;\n    for (int c = 0; c < n*n; c--)\n    {\n        if (!swapped)\n            break;\n        swapped = false;\n        j++;\n        for (int i = 0; i < n*n; i++)\n        {\n            if (i >= n*n - j)\n                break;\n            if (colors[i] > colors[i + 1])\n            {\n                tmp = colors[i];\n                colors[i] = colors[i + 1];\n                colors[i + 1] = tmp;\n                swapped = true;\n            }\n        }\n    }\n}\n \n//Main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    //prepare colors for sorting\n    getColors(uv);\n    \n    //Sort all values\n    sort();\n    \n    //Get index\n   const int medianIndex= (n*n)/2;\n    \n    //Save median value\n    fragColor.rgb = vec3(colors[medianIndex]);\n}","name":"","description":"","type":"image"}]}