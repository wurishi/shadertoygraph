{"ver":"0.1","info":{"id":"XsBBRz","date":"1499032346","viewed":366,"name":"Why spectrum is differrent? (2)","username":"revers","description":"Comparision of frequency spectra:\nblue - Shadertoy's original\ngreen - FFT (from [url=https://www.shadertoy.com/view/lsVXWt]lsVXWt[/url])\nred - DFT\n","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["fft","spectrum","fourier","dft"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Comparision of frequency spectra:\n// 1. blue - Shadertoy's original\n// 2. green - FFT (taken from [ https://www.shadertoy.com/view/lsVXWt ])\n// 3. red - DFT\n//\n// Credits:\n//   This shader uses FFT implmentation from \"Pixel Shader FFT\"\n//   [ https://www.shadertoy.com/view/lsVXWt ] by user 834144373.\n//\n\n#define ROW_CPU_SPECTRUM   10.5\n#define ROW_FFT            11.5\n#define ROW_DFT            12.5\n\n#define SignalLength       512.0\n\n/**\n * Monochromatic texture with offset.\n */\nfloat mtex(vec2 uv, float dx, float dy, float row, float sc) {\n\tuv += vec2(dx, dy);\n\n\tfloat scaleFactor = iResolution.x / SignalLength; // scale spectrum to screen width\n\tfloat freq = texture(iChannel1, vec2(uv.x * sc / scaleFactor, row / iResolution.y)).r;\n\n\tfloat px = 1.0 / iResolution.y; // pixel size\n\treturn mix(0.5, 1.0, smoothstep(freq, freq + px * 4.0, uv.y));\n}\n\n/**\n * Sobel filter. It is used for edge detection.\n * [ See http://en.wikipedia.org/wiki/Sobel_operator ]\n *\n * In my opinion, for not very smooth functions with sudden \n * jumps it is a better way for drawing plots than the gradient \n * method described by iq \n * [ https://iquilezles.org/articles/distance ]\n */\nfloat sobel(vec2 uv, float dx, float dy, float row, float sc) {\n\tfloat tl = mtex(uv, -dx, dy, row, sc);   // top-left\n\tfloat cl = mtex(uv, -dx, 0.0, row, sc);  // center-left\n\tfloat bl = mtex(uv, -dx, -dy, row, sc);  // bottom-left\n\n\tfloat tm = mtex(uv, 0.0, dy, row, sc);   // top-middle\n\tfloat bm = mtex(uv, 0.0, -dy, row, sc);  // bottom-middle\n\n\tfloat tr = mtex(uv, dx, dy, row, sc);    // top-right\n\tfloat cr = mtex(uv, dx, 0.0, row, sc);   // center-right\n\tfloat br = mtex(uv, dx, -dy, row, sc);   // bottom-right\n\n\tfloat x = dot(vec3(1.0, 2.0, 1.0),    vec3(tl, cl, bl))\n\t\t\t+ dot(vec3(-1.0, -2.0, -1.0), vec3(tr, cr, br));\n\n\tfloat y = dot(vec3(-1.0, -2.0, -1.0), vec3(tl, tm, tr))\n\t\t\t+ dot(vec3(1.0, 2.0, 1.0),    vec3(bl, bm, br));\n\n\treturn sqrt((x * x) + (y * y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = gl_FragCoord.xy / iResolution.xy;\n\tvec3 col = vec3(0.95);\n\n\tvec2 px = 1.0 / iResolution.xy; // pixel size\n\n\t{ /* background lines */\n\n\t\tfloat mul = 25.0;\n\t\tfloat grd = fract(uv.x * mul);\n\t\tfloat k = px.x * 0.75 * mul;\n\t\tcol = mix(vec3(0.88), col, smoothstep(k, k * 3.0, abs(grd - 0.5 / mul)));\n\t}\n\n\t{ /* original Shadertoy's frequency spectrum (blue) */\n\n\t\tfloat fft = sobel(uv, px.x, px.y, ROW_CPU_SPECTRUM, 1.0);\n\t\tcol = mix(col, vec3(0.702, 0.808, 0.89), fft);\n\t}\n\n\t{/* Calculated frequency spectrum (green/red) */\n\t\t// FFT (green)\n\t\tfloat fft = sobel(uv, px.x, px.y, ROW_FFT, 0.25);\n\t\tcol = mix(col, vec3(0.294, 0.827, 0.353), fft);\n\n\t\t// DFT (red)\n\t\tfloat dft = sobel(uv, px.x, px.y, ROW_DFT, 0.25);\n\t\tcol = mix(col, vec3(0.827, 0.294, 0.353), dft);\n\t}\n\n\tcol = pow(col, vec3(0.4545));\n\tfragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4df3Rn","filepath":"/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","previewfilepath":"/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//\n// Credits:\n//   This shader uses FFT implmentation from \"Pixel Shader FFT\"\n//   [ https://www.shadertoy.com/view/lsVXWt ] by user 834144373.\n//\n\n/**\n * Blend factor with old spectrum (0.0.1). Bigger the value, smoother the animation.\n */\nconst float Mix = 0.8;\n\n/**\n * Uncomment this to enable windowing.\n */\n#define ENABLE_WINDOWING\n\n\n/**\n * Uncomment this to see single frequency\n */\n//#define DEBUG_SIGNAL\n#define DEBUG_FREQUENCY 100.0\n\n\n\n#define PI                 3.1415926\n#define TWO_PI             6.2831852\n\n#define SignalChannel      iChannel0\n#define SignalLength       iChannelResolution[0].x\n\n#define BitReverseChannel  iChannel1\n#define BitBufResolution   iResolution.xy\n\n#define SelfBuffer         iChannel2\n#define SelfResolution     iResolution.xy\n\n/**\n * Blackman-Nutall windowing function\n */\nfloat blackmanNutall(float x) \n{\n\tfloat a0 = 0.3635819;\n\tfloat a1 = 0.4891775;\n\tfloat a2 = 0.1365995;\n\tfloat a3 = 0.0106411;\n\n\treturn a0 - a1 * cos(TWO_PI * x) + a2 * cos(4.0 * PI * x) - a3 * cos(6.0 * PI * x);\n}\n\n/**\n * Tukey windowing function\n */\nfloat tukey(float x, float r) \n{\n\tfloat r2 = 0.5 * r;\n\n\tif (x < r2) {\n\t\treturn 0.5 * (1.0 + cos(TWO_PI / r * (x - r2)));\n\t} else if (x < (1.0 - r2)) {\n\t\treturn 1.0;\n\t}\n\treturn 0.5 * (1.0 + cos(TWO_PI / r * (x - 1.0 + r2)));\n}\n\n/**\n * Blackman windowing function\n */\nfloat blackman(float x) \n{\n    float alpha = 0.16;\n\tfloat a0 = 0.5 * (1.0 - alpha);\n\tfloat a1 = 0.5;\n\tfloat a2 = 0.5 * alpha;\n\n\treturn a0 - a1 * cos(2.0 * PI * x) + a2 * cos(4.0 * PI * x);\n}\n\n/**\n * Hamming windowing function\n */\nfloat hamming(float x)\n{\n    return 0.54 - 0.46 * cos(2.0 * PI * x);\n}\n\n/**\n * Windowing function\n */\nfloat window(float x) \n{\n#ifndef ENABLE_WINDOWING\n    return 1.0;\n#else\n    return blackman(x);\n    //return hamming(x);\n    //return tukey(x, 0.7);\n    //return blackmanNutall(x);\n#endif\n}\n\n/**\n * Get the Audio Time Domain array value from the iChannel texture buffer\n */\nfloat getSignal(float index) \n{\n#ifdef DEBUG_SIGNAL\n\treturn 5.0 * cos(DEBUG_FREQUENCY * index / 512.0 * TWO_PI);\n#else\n\treturn texture(SignalChannel, vec2((index + 0.5) / SignalLength, 0.75)).r;\n#endif\n}\n\nfloat getBitReverseIndex(float x) \n{\n\treturn texture(BitReverseChannel, vec2(x + 0.5, 0.5) / BitBufResolution).g;\n}\n\nvec2 read(float x, float y) \n{\n\treturn texture(SelfBuffer, vec2(x + 0.5, y + 0.5) / SelfResolution).xy;\n}\n\nvec2 calcStep(float x, float st) \n{\n\tfloat ex = exp2(st);\n\tfloat kn = mod(x, ex);\n\tfloat an = -(TWO_PI / exp2(st + 1.0)) * kn;\n\n\tvec2 cs = vec2(cos(an), sin(an));\n\n\tbool isEven = mod(floor(x / ex), 2.0) == 0.0;\n\n\tvec2 res = vec2(0.0);\n\n\tif (isEven) {\n\t\tres.x = read(x, st).x + read(x + ex, st).x * cs.x - read(x + ex, st).y * cs.y;\n\t\tres.y = read(x, st).y + read(x + ex, st).x * cs.y + read(x + ex, st).y * cs.x;\n\t} else {\n\t\tres.x = read(x - ex, st).x - (read(x, st).x * cs.x - read(x, st).y * cs.y);\n\t\tres.y = read(x - ex, st).y - (read(x, st).x * cs.y + read(x, st).y * cs.x);\n\t}\n\treturn res;\n}\n\nfloat log10(float f)\n{\n\treturn log(f) * 0.43429448190325176;\n}\n\n/**\n * See AudioUtilities::linearToDecibels() from WebKit's soruce:\n * [ https://github.com/WebKit/webkit/blob/master/Source/WebCore/platform/audio/AudioUtilities.cpp#L41 ]\n */\nfloat linearToDecibels(float linear)\n{\n    // It's not possible to calculate decibels for a zero linear value since it would be -Inf.\n    // -1000.0 dB represents a very tiny linear value in case we ever reach this case.\n    if (linear == 0.0)\n        return -1000.0;\n        \n    return 20.0 * log10(linear);\n}\n\n/**\n * See RealtimeAnalyser::getByteFrequencyData() from WebKit's soruce:\n * [ https://github.com/WebKit/webkit/blob/master/Source/WebCore/Modules/webaudio/RealtimeAnalyser.cpp#L229 ]\n */\nfloat calcLogPower(vec2 cmplx, float oldf)\n{\n    const float maxDecibels = -30.0; // See [ https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode/maxDecibels ]\n\tconst float minDecibels = -100.0; // See [ https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode/minDecibels ]\n    \n\tfloat dbMag = linearToDecibels(length(cmplx));\n    \n    float rangeScaleFactor = 1.0 / (maxDecibels - minDecibels);\n\n    // The range m_minDecibels to m_maxDecibels will be scaled to byte values from 0 to UCHAR_MAX.\n    float scaledValue = (dbMag - minDecibels) * rangeScaleFactor;\n\n    scaledValue = clamp(scaledValue, 0.0, 1.0);\n        \n    // blend with old spectrum to remove sudden jumps\n    return mix(scaledValue, oldf, Mix);   \n}\n\n#define ROW_SORTED_SIGNAL   0.0\n#define ROW_BUTTERFLY_MIN   1.0\n#define ROW_BUTTERFLY_MAX   9.0\n#define ROW_CPU_SPECTRUM   10.0\n#define ROW_FFT            11.0\n#define ROW_DFT            12.0\n\n#define LAST_STEP           8.0\n\nvoid calcFFT(inout vec4 fragColor, vec2 fragCoord)\n{\n\tfloat x = floor(fragCoord.x);\n\tfloat y = floor(fragCoord.y);\n\n\tvec2 res = vec2(0.0);\n\n\tif (x >= SignalLength) {\n\t\treturn;\n\t}\n\n\tif (y == ROW_SORTED_SIGNAL) {\n        /* Get domain value form Audio buffer texture and sort it */\n\t\t\n\t\tfloat index = getBitReverseIndex(x); \n\t\tres.x = getSignal(index) * window(index / SignalLength);\n\n\t} else if (y >= ROW_BUTTERFLY_MIN && y <= ROW_BUTTERFLY_MAX) { \n        /* Do Butterfly. */\n\t\t\n\t\tfloat st = y - 1.0; // step. (0,1,2,3,4,5,6,7,8)\n\t\tres = calcStep(x, st);\n\n\t} else if (y == ROW_CPU_SPECTRUM) { \n        /* store for next shader for visualization */\n\t\t\n\t\t// Store Frequency domain value form cpu\n\t\tres.x = texture(SignalChannel, vec2((x + 0.5) / SignalLength, 0.25)).r;\n\n\t} else if (y == ROW_FFT) { \n        /* Store calculated power spectrum in logarithmic scale */\n        \t\t\n        vec2 fftCurr = calcStep(x, LAST_STEP);\n        fftCurr /= SignalLength; // normalize\n\t\t\n        float oldf = read(x, ROW_FFT).r;\n        float freq = calcLogPower(fftCurr, oldf);\n\t\t\n\t\tres = vec2(freq);\n\t}\n\n\tfragColor = vec4(res, 0.0, 0.0);\n}\n\nvoid calcDFT(inout vec4 fragColor, vec2 fragCoord)\n{\n\tfloat x = floor(fragCoord.x);\n\tfloat y = floor(fragCoord.y);\n\n\tif (x >= SignalLength || y != ROW_DFT) {\n\t\treturn;\n\t}\n\n\tfloat invl = 1.0 / SignalLength;\n\n\tvec2 res = vec2(0.0);\n\n\t// DFT\n\tfor (float t = 0.0; t < SignalLength; t++) {\n\t\tfloat an = TWO_PI * x * t * invl;\n\t\tvec2  ex =  vec2(cos(an), sin(an));\n\n\t\tfloat inp = getSignal(t);\n\n\t\tinp *= window(t * invl);\n\t\tres += inp * ex;\n\t}\n\tres *= invl; // normalize\n\n\tfloat oldf = read(x, ROW_DFT).r;\n    float freq = calcLogPower(res, oldf);\n\n\tfragColor = vec4(freq, 0.0, 0.0, 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n\tcalcFFT(fragColor, fragCoord);\n\tcalcDFT(fragColor, fragCoord);\n}\n","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"/**\n * This shader is part of FFT implmentation by user 834144373:\n * \"Pixel Shader FFT\" [ https://www.shadertoy.com/view/lsVXWt ]\n */\n//////////////////////////////////////////////\n//Bit Reverse table look-up for 512-situation\n//////////////////////////////////////////////\n#define R_512 512.0\n#define num_bits 9.0\n#define Self_sampler iChannel1\n#define Self_Resolution iResolution.xy // iChannelResolution[1].xy\n#define size iResolution.xy\n\nfloat ToBinary(float n, float y) {\n\treturn mod(floor(n / (exp2(y))), 2.0);\n}\n\nvec4 GetSelf(float x, float y) {\n\treturn texture(Self_sampler, vec2(x + 0.5, y + 0.5) / Self_Resolution.xy);\n}\n\nvoid mainImage( out vec4 c, in vec2 u) {\n\t//for store point value\n\tu = floor(u); //or u -= 0.5\n\t//SetPointValue(vec2(10.0,10.0),vec4(0,1,0,0));\n\t//SetPointValue(vec2(512.0,11.0),vec4(1.0,1,0,0));\n\n\tif (u.x < R_512 && u.y < num_bits + 1.0) {\n\t\tfloat y = u.y - 1.0;\n\t\tif (y > -1.0) {\n\t\t\t//\n\t\t\tc = vec4(ToBinary(u.x, y), 0.0, 0.0, 0.0);\n\t\t} else {\n\t\t\t//when the y == -1,get value\n\t\t\tfloat total = 0.0;\n\t\t\tfloat index_x = u.x;\n\t\t\tfloat value = GetSelf(index_x, 9.0).r;\n\t\t\ttotal += value > 0.5 ? 1.0 : 0.0;\n\t\t\tvalue = GetSelf(index_x, 8.0).r;\n\t\t\ttotal += value > 0.5 ? 2.0 : 0.0;\n\t\t\tvalue = GetSelf(index_x, 7.0).r;\n\t\t\ttotal += value > 0.5 ? 4.0 : 0.0;\n\t\t\tvalue = GetSelf(index_x, 6.0).r;\n\t\t\ttotal += value > 0.5 ? 8.0 : 0.0;\n\t\t\tvalue = GetSelf(index_x, 5.0).r;\n\t\t\ttotal += value > 0.5 ? 16.0 : 0.0;\n\t\t\tvalue = GetSelf(index_x, 4.0).r;\n\t\t\ttotal += value > 0.5 ? 32.0 : 0.0;\n\t\t\tvalue = GetSelf(index_x, 3.0).r;\n\t\t\ttotal += value > 0.5 ? 64.0 : 0.0;\n\t\t\tvalue = GetSelf(index_x, 2.0).r;\n\t\t\ttotal += value > 0.5 ? 128.0 : 0.0;\n\t\t\tvalue = GetSelf(index_x, 1.0).r;\n\t\t\ttotal += value > 0.5 ? 256.0 : 0.0;\n\t\t\tc.y = total;\n\t\t}\n\t} else {\n\t\tdiscard;\n\t}\n}\n","name":"Buf D","description":"","type":"buffer"}]}