{"ver":"0.1","info":{"id":"DlVfDW","date":"1702211369","viewed":15,"name":"projet graphisme","username":"isma5217","description":"projet","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["projet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Camera {\n    vec3 Obs;\n    vec3 View;\n    vec3 Up;\n    vec3 Horiz;\n    float H;\n    float W;\n    float z;\n};\n\nstruct Ray {\n    vec3 Origin;\n    vec3 Dir;\n};\n\nCamera camera(in vec3 Obs, in vec3 LookAt, in float aperture) {\n    Camera C;\n    C.Obs = Obs;\n    C.View = normalize(LookAt - Obs);\n    C.Horiz = normalize(cross(vec3(0, 0, 1), C.View));\n    C.Up = normalize(cross(C.View, C.Horiz));\n    C.H = iResolution.y;\n    C.W = iResolution.x;\n    C.z = C.H/2.0/tan(aperture * 3.1415 / 180.0 /2.0);\n    return C;\n}\nRay launch(in Camera C, in vec2 XY) {\n    Ray r;\n    r.Origin = C.Obs;\n    r.Dir = C.z*C.View + (XY.x - C.W/2.0)*C.Horiz + (XY.y - C.H/2.0)*C.Up;\n    return r;\n}\n\nstruct Disk {\n    vec3 Center;\n    vec3 Normal;\n    float Radius;\n};\n\nvec3 diskTexture(vec3 point, Disk disk) {\n    vec3 localPoint = point - disk.Center;\n\n    float radius = length(localPoint.xy);\n    float theta = atan(localPoint.y, localPoint.x);\n\n    float normalizedRadius = radius / disk.Radius;\n    float normalizedTheta = (theta + 3.14159265358979323846) / (2.0 * 3.14159265358979323846);\n\n    float gradient = smoothstep(0.0, 0.1, 1.0 - normalizedRadius);\n\n    vec3 interieur = vec3(0.7, 0.0, 0.0); \n    vec3 exte = vec3(0.0, 0.0, 0.0); \n\n    vec3 finalColor = mix(exte, interieur, gradient);\n\n    return finalColor;\n}\n\nbool intersect_disk(in Ray R, in Disk D, out float t) {\n    float denominator = dot(D.Normal, R.Dir);\n\n    if (abs(denominator) < 0.0001) {\n        t = 1e30;\n        return false;\n    }\n\n    t = dot(D.Center - R.Origin, D.Normal) / denominator;\n\n    vec3 intersectionPoint = R.Origin + t * R.Dir;\n    float distanceToCenter = length(intersectionPoint - D.Center);\n\n    if (distanceToCenter > D.Radius) {\n        t = 1e30;\n        return false;\n    }\n\n    if (t > 0.0) {\n        return true;\n    } else {\n        t = 1e30;\n        return false;\n    }\n}\n\n\nstruct Plane {\n    vec3 Point;\n    vec3 Normal;\n    float Width;\n    float Height;\n};\n\nbool intersect_plane(in Ray R, in Plane P, out float t) {\n    float denominator = dot(P.Normal, R.Dir);\n\n    if (abs(denominator) < 0.0001) {\n        t = 1e30;\n        return false;\n    }\n\n    t = dot(P.Point - R.Origin, P.Normal) / denominator;\n\n    vec3 intersectionPoint = R.Origin + t * R.Dir;\n    vec3 localPoint = intersectionPoint - P.Point;\n    float halfWidth = P.Width / 2.0;\n    float halfHeight = P.Height / 2.0;\n\n    if (abs(localPoint.x) > halfWidth || abs(localPoint.y) > halfHeight) {\n        t = 1e30;\n        return false;\n    }\n\n    if (t > 0.0) {\n        return true;\n    } else {\n        t = 1e30;\n        return false;\n    }\n}\n\nstruct Sphere {\n    vec3 Center;\n    float R;\n};\n\nbool intersect_sphere(in Ray R, in Sphere S, out float t) {\n    float a = dot(R.Dir,R.Dir);\n    float b = 2.0*dot(R.Dir,(R.Origin - S.Center));\n    float c = dot(R.Origin - S.Center, R.Origin - S.Center) - S.R*S.R;\n    float delta = b*b - 4.0*a*c;\n    if (delta > 0.0) {\n        t = (-b - sqrt(delta)) / (2.0*a);\n    }\n    return delta > 0.0;\n}\n\nstruct Cylinder {\n    vec3 Base;\n    vec3 Axis;\n    float Radius;\n    float Height;\n};\n\nbool intersect_cylinder(in Ray R, in Cylinder C, out float t) {\n    vec3 OC = R.Origin - C.Base;\n    float a = dot(R.Dir - dot(R.Dir, C.Axis) * C.Axis, R.Dir - dot(R.Dir, C.Axis) * C.Axis);\n    float b = 2.0 * dot(R.Dir - dot(R.Dir, C.Axis) * C.Axis, OC - dot(OC, C.Axis) * C.Axis);\n    float c = dot(OC - dot(OC, C.Axis) * C.Axis, OC - dot(OC, C.Axis) * C.Axis) - C.Radius * C.Radius;\n\n    float discriminant = b * b - 4.0 * a * c;\n\n    if (discriminant < 0.0) {\n        return false;\n    }\n\n    float t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n    float t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n\n    float h1 = dot((R.Origin + t1 * R.Dir) - C.Base, C.Axis);\n    float h2 = dot((R.Origin + t2 * R.Dir) - C.Base, C.Axis);\n\n    if (t1 > 0.0 && h1 >= 0.0 && h1 <= C.Height) {\n        t = t1;\n        return true;\n    }\n\n    if (t2 > 0.0 && h2 >= 0.0 && h2 <= C.Height) {\n        t = t2;\n        return true;\n    }\n\n    return false;\n}\n\nSphere s1;\nSphere s2;\nSphere ener;\nSphere ener2;\nSphere ener3;\nSphere power;\nSphere sol;\n\nfloat lighting(vec3 p, vec3 n, vec3 light) {\n    vec3 light_dir = light - p;\n    Ray r = Ray(p, light_dir);\n    float coef;\n    \n    //ombres retirées car le programme mettait plus de 1min à compiler\n    \n    coef = dot(n, light_dir)/length(light_dir);\n    \n    if (coef < 0.0) {\n        coef = 0.0;\n    }\n    return coef;\n}\n//TexturePlanet\nvec3 planetTexture(vec3 point) {\n    // On convertit le rayon en coordonnées polaires en un point  x et un point y\n    //uv.x correspond à l'ange phi et uv.y à theta \n    vec2 uv = vec2(atan(point.y, point.x) / (2.0 * 3.14159265358979323846) + 0.5,\n                   asin(point.z) / 3.14159265358979323846 + 0.5);\n\n   \n    vec3 waterColor = vec3(0.0, 0.0, 1.0); // Bleu\n    vec3 landColor = vec3(0.0, 1.0, 0.0);  // Vert\n\n    // On crée deux chemins d'eau définis par des seuils à\n    //dépasser\n    float waterPath1 = smoothstep(0.48, 0.52, sin(uv.x * 30.0));\n    float waterPath3 = smoothstep(0.48, 0.52, sin((uv.x + uv.y) * 40.0));\n\n    // On prend le seuil le plus haut\n    float waterPath = max(waterPath1, waterPath3);\n\n    // On mixe le sol et l'eau en fonction  du seuil waterpath\n    //ce sera souvent soit l'un soit l'autre mais permet d'avoir\n    //un gradiant au niveau des contrastes terre-eau\n    return mix(landColor, waterColor, waterPath);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    float a = mod(iTime, 31.4159265);\n    \n    float t = 1e30;\n    float t1;\n    mat3 rotz = mat3(1,0,0,1,cos(a), sin(a),0,-sin(a), cos(a));\n    mat3 rotcyl1 = mat3(cos(a),0,- sin(a),0,1,0,sin(a), 0,cos(a));\n    mat3 rotcyl2 = mat3(cos(3.0*a),0,- sin(3.0*a),0,1,0,sin(3.0*a), 0,cos(3.0*a));\n    mat3 rotcyl3 = mat3(cos(2.0*a),0,- sin(2.0*a),0,1,0,sin(2.0*a), 0,cos(2.0*a));\n    mat3 rot = mat3(cos(a),0,- sin(a),0,1,0,sin(a), 0,cos(a));\n    mat3 rot2 = mat3(cos(-a), sin(-a), 0,\n                    -sin(-a), cos(-a), 0,\n                    0, 0, 1);\n                    \n    \n    Cylinder cyli = Cylinder(rot*vec3(4.0, 5.0, 1.5), normalize(vec3(0.0, -4.0, 2.0)), 0.35, 2.2);\n    s1 = Sphere(rot2*rotcyl1*vec3(0.25,0.25,0.25)+vec3(-6.6, 12.0, 6.0), 0.6);\n    sol = Sphere(vec3(0.0, 0.0, -1.2), 3.0);\n    //declPlanetes\n    Sphere pl1 = Sphere(rotz*rotcyl1 * vec3(1.0, -4.0, 4.2), 1.2);\n    Sphere pl2 = Sphere(rotz*rot*vec3(8.0, 3.0, 4.2), 0.6);\n    Sphere pl3 = Sphere(cyli.Base+rotcyl3*vec3(1.0, 0.0, 0.0), 0.3);\n    Sphere pl4 = Sphere(rot*rotz*vec3(4.5, 6.0, 1.2), 0.7);\n    \n    \n    float enerx=50.0;    \n    float enerx2=50.0;    \n    float enerx3=50.0;\n    \n    //deplCam1\n    //La caméra va à l'opposé du système jusqu'à t=1.75 sec \n    //Puis reviens par le même chemin\n    vec3 pos=vec3(-6.4, 15.0, 7.4);\n    vec3 depl=vec3(5.0, -20.0, 2.0);\n    if(iTime<3.5){pos+=iTime*depl;\n        if(iTime>1.75){\n        pos=vec3(-6.4, 15.0, 7.4)+1.75*depl\n        -(iTime-1.75)*depl;\n        }\n    }\n    Camera C = camera(\n        pos,\n        vec3(0.0,0.0,0.0),\n        50.0       \n    );\n    \n//travel back in time\nfloat relativeTime=a;\n    if(a>25.0){\n        a=25.0*(1.0-1.0/6.4159265*(a-25.0));\n        \n    }\n    \n\n    //grosseur soleil\n    if(a>20.0){sol.R=sol.R+2.5*(a-20.0);}\n\n\n//deplCam2\n//Observer portail tout en  descendant en dessous du systeme\nif (a > 4.0) {\n    \n    if(a<5.0){\n        C.Obs=(5.0-a)*C.Obs+(a-4.0)*vec3(17.0,20.0,-7.0);\n        C=camera(C.Obs,(5.0-a)*vec3(0.0,0.0,0.0)+(a-4.0)*vec3(0.0,0.0,40.0),50.0       );}\n    \n    else{\n        C.Obs=vec3(17.0,20.0,-7.0);\n    C=camera(\n        C.Obs, vec3(0.0,0.0,40.0),50.0); \n       }\n}\n\n//Observer boule 1 et revenir\nif (a > 8.0) {\n    float temp=40.0-20.0*(a-8.0);\n    if(temp<0.0){temp=0.0;}\n    \n    \n    if(a<9.0){\n        C.Obs=(9.0-a)*C.Obs+(a-8.0)*vec3(-6.4, 15.0, 7.4);\n        C=camera(C.Obs,(9.0-a)*vec3(0.0,0.0,40)+(a-8.0)*vec3(0.0,0.0,temp),50.0       );}\n    \n    else{\n        C.Obs=vec3(-6.4, 15.0, 7.4);\n    C=camera(\n        C.Obs, vec3(0.0,0.0,temp),50.0); \n       }\n}\n\n//Observer boule 2\nif (a > 11.0) {\n    float temp=40.0-20.0*(a-11.0);\n    if(temp<0.0){temp=0.0;}\n    \n    \n    if(a<12.0){\n        C=camera(C.Obs,(12.0-a)*vec3(0.0,0.0,0.0)+(a-11.0)*vec3(0.0,0.0,temp),50.0       );}\n    \n    else{\n    C=camera(\n        C.Obs, vec3(0.0,0.0,temp),50.0); \n       }\n}\n\n//Observer boule 3\nif (a > 14.0) {\n    float temp=40.0-20.0*(a-14.0);\n    if(temp<0.0){temp=0.0;}\n    \n    \n    if(a<15.0){\n        C=camera(C.Obs,(15.0-a)*vec3(0.0,0.0,0.0)+(a-14.0)*vec3(0.0,0.0,temp),50.0       );}\n    \n    else{\n    C=camera(\n        C.Obs, vec3(0.0,0.0,temp),50.0); \n       }\n}\n\n\n//Observer laser\nif (a > 17.0) {\n    float temp=40.0-20.0*(a-17.0);\n    if(temp<0.0){temp=0.0;}\n    \n    \n    if(a<18.0){\n        C=camera(C.Obs,(18.0-a)*vec3(0.0,0.0,0.0)+(a-17.0)*vec3(0.0,0.0,temp),50.0       );}\n    \n    else{\n    C=camera(\n        C.Obs, vec3(0.0,0.0,temp),50.0); \n       }\n}\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 col;\n    Ray r = launch(C, fragCoord);\n\n\n//gestion ciel\n    vec3 sunriseColor = vec3(1.0, 0.6, 0.2);\n    vec3 dayColor = vec3(0.2, 0.6, 1.0);\n    vec3 apocalypse = vec3(0.4, 0.0, 0.6);\n    vec3 nightColor = vec3(0.0, 0.0, 0.1);\n    if (a < 1.0) {\n        col = mix(nightColor, sunriseColor, smoothstep(0.0, 1.0, a));\n    } else if (a < 4.5) {\n        col = mix(sunriseColor, dayColor, smoothstep(1.0, 4.5, a));\n    } else if (a < 18.5) {\n        col = mix(dayColor, apocalypse, smoothstep(4.5, 5.5, a));\n    } else {\n        col = mix(apocalypse, nightColor, smoothstep(18.5, 20.0, a));\n    } \n    \n//coefficients de descente des trois boules rouges    \nif (a > 8.0) {\n    enerx=40.0-20.0*(a-8.0);\n    if(enerx<0.0){enerx=0.0;}\n}\nif (a > 11.0) {\n    enerx2=40.0-20.0*(a-11.0);\n    if(enerx2<0.0){enerx2=0.0;}\n}\nif (a > 14.0) {\n    enerx3=40.0-20.0*(a-14.0);\n    if(enerx3<0.0){enerx3=0.0;}\n}\n\n\n    //lumières\n    vec3 light = vec3(-7.0, 15.0, 3.9);\n     depl = vec3(5.0, -15.0, 10.0);\n    if(a<3.5){light+=a*depl;\n        if(a>1.75){\n        light=vec3(-5.0, 15.0, 0.0)+1.75*depl\n        -(a-1.75)*depl;\n        }\n    }\n    \n   // lightsDeclaration\n    s2 = Sphere(rot*vec3(1.0, 0.0, 5.0), 0.3);\nener = Sphere(vec3(0.0, 0.0, enerx), 1.0);\n ener2 = Sphere(vec3(0.0, 0.0, enerx2), 1.0);\n ener3 = Sphere(vec3(0.0, 0.0, enerx3), 1.0);\n         power = Sphere(s1.Center+vec3(0.12, -0.03, 0.75), 0.06);\n\n    \n    if (intersect_sphere(r, ener, t1) && t1 < t && a>8.0) {\n        t = t1;\n        vec3 p = r.Origin + t1*r.Dir;\n        vec3 n = normalize(p - ener.Center);\n        col = vec3(0.8, 0.2, 0.2);\n    }\n\n    if (intersect_sphere(r, ener2, t1) && t1 < t && a>11.0) {\n        t = t1;\n        vec3 p = r.Origin + t1*r.Dir;\n        vec3 n = normalize(p - ener2.Center);\n        col = vec3(0.8, 0.2, 0.2);\n    }\n\n    if (intersect_sphere(r, ener3, t1) && t1 < t && a>14.0) {\n        t = t1;\n        vec3 p = r.Origin + t1*r.Dir;\n        vec3 n = normalize(p - ener3.Center);\n        col = vec3(0.8, 0.2, 0.2);\n    }\n    \n    \n//powerSpawn\n    if (intersect_sphere(r, power, t1) && t1 < t && relativeTime>25.0) {\n        t = t1;\n        vec3 p = r.Origin + t1*r.Dir;\n        vec3 n = normalize(p - power.Center);\n        col = vec3(0.678431, 0.847059, 0.901961);}\n//soleilSpawn\n    if (intersect_sphere(r, sol, t1) && t1 < t) {\n        t = t1;\n        vec3 p = r.Origin + t1*r.Dir;\n        vec3 n = normalize(p - sol.Center);\n        float coef = lighting(p, n, light);\n        col = vec3(1.0, 0.8, 0.2);\n        col = mix(vec3(1.0, 0.8, 0.2),vec3(0.8, 0.2, 0.2),smoothstep(18.5, 20.0, a));\n        \n    }\n    \n    \n    \n    \n    Disk disk;\nfloat t_disk;\ndisk = Disk(rot2*vec3(4.0, 0.0, 3.0), normalize(vec3(0.0, 0.0, 1.0)), 3.0);\n\nif (intersect_disk(r, disk, t_disk) && t_disk < t) {\n    vec3 p = r.Origin + t_disk * r.Dir;\n    vec3 n = normalize(disk.Normal);\n    float coef = lighting(p, n, light);\n    col = coef * vec3(0.7, 0.5, 0.2);\n        coef = lighting(p, n, ener.Center);\n        if(enerx==0.0 || enerx==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.7, 0.5, 0.2)*vec3(1.0, 0.5, 0.5);\n        coef = lighting(p, n, ener2.Center);\n        if(enerx2==0.0 || enerx2==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.7, 0.5, 0.2)*vec3(1.0, 0.5, 0.5);\n        coef = lighting(p, n, ener3.Center);\n        if(enerx3==0.0 || enerx3==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.7, 0.5, 0.2)*vec3(1.0, 0.5, 0.5);\n        coef = lighting(p, n, sol.Center);\n        col+= coef*vec3(0.7, 0.5, 0.2)*vec3(1.0, 0.8, 0.2);\n        if(a>25.0){coef = lighting(p, n, power.Center);\n        col+= coef*vec3(0.7, 0.5, 0.2)*vec3(0.529, 0.808, 0.922);}\n    t = t_disk;\n}\ndisk = Disk(rot2*vec3(-4.0, 0.0, 3.0), normalize(vec3(0.0, 0.0, 1.0)), 3.0);\n\nif (intersect_disk(r, disk, t_disk) && t_disk < t) {\n    vec3 p = r.Origin + t_disk * r.Dir;\n    vec3 n = normalize(disk.Normal);\n    float coef = lighting(p, n, light);\n    col = coef * vec3(0.2, 0.8, 0.2);\n        coef = lighting(p, n, ener.Center);\n        \n        if(enerx==0.0 || enerx==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.2, 0.8, 0.2)*vec3(1.0, 0.5, 0.5);\n        coef = lighting(p, n, ener2.Center);\n        if(enerx2==0.0 || enerx2==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.2, 0.8, 0.2)*vec3(1.0, 0.5, 0.5);\n        coef = lighting(p, n, ener3.Center);\n        if(enerx3==0.0 || enerx3==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.2, 0.8, 0.2)*vec3(1.0, 0.5, 0.5);\n        coef = lighting(p, n, sol.Center);\n        col+= coef*vec3(0.2, 0.8, 0.2)*vec3(1.0, 0.8, 0.2);\n        if(a>25.0){coef = lighting(p, n, power.Center);\n        col+= coef*vec3(0.2, 0.8, 0.2)*vec3(0.529, 0.808, 0.922);}\n    t = t_disk;\n}\n\n    vec3 sphereColor = vec3(1.0, 1.0, 1.0); \nvec3 textureColor;\n    if (intersect_sphere(r, s1, t1) && t1 < t) {\n        t = t1;\n        vec3 p = r.Origin + t1*r.Dir;\n        vec3 n = normalize(p - s1.Center);\n        float coef = lighting(p, n, light);\n        textureColor = planetTexture(p - s1.Center);\n\n        col = coef*textureColor;\n        coef = lighting(p, n, ener.Center);\n        if(enerx==0.0 || enerx==50.0 ){coef=0.0;}\n        col+= coef*textureColor*vec3(1, 0, 0);\n        coef = lighting(p, n, ener2.Center);\n        if(enerx2==0.0 || enerx2==50.0 ){coef=0.0;}\n        col+= coef*textureColor*vec3(1, 0, 0);\n        coef = lighting(p, n, ener3.Center);\n        if(enerx3==0.0 || enerx3==50.0 ){coef=0.0;}\n        col+= coef*textureColor*vec3(1, 0, 0);\n        coef = lighting(p, n, sol.Center);\n        col+= coef*textureColor*vec3(1.0, 0.8, 0.2);\n        if(relativeTime>25.0){coef = lighting(p, n, power.Center);\n        col+= coef*textureColor*vec3(0.529, 0.808, 0.922);}\n    }\n    if (intersect_sphere(r, pl1, t1) && t1 < t) {\n        t = t1;\n        vec3 p = r.Origin + t1*r.Dir;\n        vec3 n = normalize(p - pl1.Center);\n        float coef = lighting(p, n, light);\n        col = coef*vec3(0.678431, 0.847059, 0.901961);\n        coef = lighting(p, n, ener.Center);\n        if(enerx==0.0 || enerx==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.678431, 0.847059, 0.901961)*vec3(1, 0, 0);\n        coef = lighting(p, n, ener2.Center);\n        if(enerx2==0.0 || enerx2==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.678431, 0.847059, 0.901961)*vec3(1, 0, 0);\n        coef = lighting(p, n, ener3.Center);\n        if(enerx3==0.0 || enerx3==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.678431, 0.847059, 0.901961)*vec3(1, 0, 0);\n        coef = lighting(p, n, sol.Center);\n        col+= coef*vec3(0.678431, 0.847059, 0.901961)*vec3(1.0, 0.8, 0.2);\n        if(a>25.0){coef = lighting(p, n, power.Center);\n        col+= coef*vec3(0.678431, 0.847059, 0.901961)*vec3(0.529, 0.808, 0.922);}\n    }\n    if (intersect_sphere(r, pl2, t1) && t1 < t) {\n        t = t1;\n        vec3 p = r.Origin + t1*r.Dir;\n        vec3 n = normalize(p - pl2.Center);\n        float coef = lighting(p, n, light);\n\n        col = coef*vec3(1, 1, 1);\n        coef = lighting(p, n, ener.Center);\n        if(enerx==0.0 || enerx==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.678431, 0.847059, 0.901961)*vec3(1, 0, 0);\n        coef = lighting(p, n, ener2.Center);\n        if(enerx2==0.0 || enerx2==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.678431, 0.847059, 0.901961)*vec3(1, 0, 0);\n        coef = lighting(p, n, ener3.Center);\n        if(enerx3==0.0 || enerx3==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.678431, 0.847059, 0.901961)*vec3(1, 0, 0);\n        coef = lighting(p, n, sol.Center);\n        col+= coef*vec3(0.678431, 0.847059, 0.901961)*vec3(1.0, 0.8, 0.2);\n        if(a>25.0){coef = lighting(p, n, power.Center);\n        col+= coef*vec3(0.678431, 0.847059, 0.901961)*vec3(0.529, 0.808, 0.922);}    }\n    if (intersect_sphere(r, pl3, t1) && t1 < t) {\n        t = t1;\n        vec3 p = r.Origin + t1*r.Dir;\n        vec3 n = normalize(p - pl3.Center);\n        float coef = lighting(p, n, light);\n\n        col = coef*vec3(0.678431, 0.847059, 0.901961);\n        coef = lighting(p, n, ener.Center);\n        if(enerx==0.0 || enerx==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.678431, 0.847059, 0.901961)*vec3(1, 0, 0);\n        coef = lighting(p, n, ener2.Center);\n        if(enerx2==0.0 || enerx2==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.678431, 0.847059, 0.901961)*vec3(1, 0, 0);\n        coef = lighting(p, n, ener3.Center);\n        if(enerx3==0.0 || enerx3==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.678431, 0.847059, 0.901961)*vec3(1, 0, 0);\n        coef = lighting(p, n, sol.Center);\n        col+= coef*vec3(0.678431, 0.847059, 0.901961)*vec3(1.0, 0.8, 0.2);\n        if(a>25.0){coef = lighting(p, n, power.Center);\n        col+= coef*vec3(0.678431, 0.847059, 0.901961)*vec3(0.529, 0.808, 0.922);}    }\n    if (intersect_sphere(r, pl4, t1) && t1 < t) {\n        t = t1;\n        vec3 p = r.Origin + t1*r.Dir;\n        vec3 n = normalize(p - pl4.Center);\n        float coef = lighting(p, n, light);\n\n        col = coef*vec3(0.678431, 0.847059, 0.901961);\n        coef = lighting(p, n, ener.Center);\n        if(enerx==0.0 || enerx==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.678431, 0.847059, 0.901961)*vec3(1, 0, 0);\n        coef = lighting(p, n, ener2.Center);\n        if(enerx2==0.0 || enerx2==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.678431, 0.847059, 0.901961)*vec3(1, 0, 0);\n        coef = lighting(p, n, ener3.Center);\n        if(enerx3==0.0 || enerx3==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.678431, 0.847059, 0.901961)*vec3(1, 0, 0);\n        coef = lighting(p, n, sol.Center);\n        col+= coef*vec3(0.678431, 0.847059, 0.901961)*vec3(1.0, 0.8, 0.2);\n        if(a>25.0){coef = lighting(p, n, power.Center);\n        col+= coef*vec3(0.678431, 0.847059, 0.901961)*vec3(0.529, 0.808, 0.922);}    }\n    float t2;\n    if (intersect_sphere(r, s2, t2) && t2 < t) {\n        vec3 p = r.Origin + t2*r.Dir;\n        vec3 n = normalize(p - s2.Center);\n        float coef = lighting(p, n, light);\n\n        col = coef*vec3(0.2,0.78,0.6);\n        coef = lighting(p, n, ener.Center);\n        if(enerx==0.0 || enerx==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.2,0.78,0.6)*vec3(1, 0, 0);\n        coef = lighting(p, n, ener2.Center);\n        if(enerx2==0.0 || enerx2==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.2,0.78,0.6)*vec3(1, 0, 0);\n        coef = lighting(p, n, ener3.Center);\n        if(enerx3==0.0 || enerx3==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.2,0.78,0.6)*vec3(1, 0, 0);\n        coef = lighting(p, n, sol.Center);\n        col+= coef*vec3(0.2,0.78,0.6)*vec3(1.0, 0.8, 0.2);\n        if(a>25.0){coef = lighting(p, n, power.Center);\n        col+= coef*vec3(0.2,0.78,0.6)*vec3(0.529, 0.808, 0.922);}\n        t = t2;\n    }\n\n    //laser\n    float tempo;\n    tempo = 20.0*(a-17.0);\n    \n    float t_cyl;\n    \n    Cylinder cyl = Cylinder(vec3(0.0, 0.0, 40.0), normalize(vec3(0.0, 0.0, -1.0)), 1.0, tempo);\n\n    if (intersect_cylinder(r, cyl, t_cyl) && t_cyl < t && a>17.0 && a<20.0) {\n        vec3 p = r.Origin + t_cyl * r.Dir;\n        vec3 n = normalize(p - (cyl.Base + dot(p - cyl.Base, cyl.Axis) * cyl.Axis));\n        float coef = lighting(p, n, light);\n        if(p.z>0.0){\n        col =  vec3(0.8, 0.2, 0.2);}\n        t = t_cyl;\n    }\n    \n    \n    //anneaux\n    cyl = Cylinder(vec3(0.0, 0.0, 0.0), normalize(vec3(0.0, 0.0, 1.0)), 13.0, 4.5);\n\n    if (intersect_cylinder(r, cyl, t_cyl) && t_cyl < t) {\n        vec3 p = r.Origin + t_cyl * r.Dir;\n        vec3 n = normalize(p - (cyl.Base + dot(p - cyl.Base, cyl.Axis) * cyl.Axis));\n        float coef = lighting(p, n, light);\n        col = coef * vec3(0.8, 0.2, 0.2);\n        coef = lighting(p, n, ener.Center);\n        if(enerx==0.0 || enerx==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.8, 0.8, 0.2)*vec3(1, 0, 0);\n        coef = lighting(p, n, ener2.Center);\n        if(enerx2==0.0 || enerx2==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.8, 0.8, 0.2)*vec3(1, 0, 0);\n        coef = lighting(p, n, ener3.Center);\n        if(enerx3==0.0 || enerx3==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.8, 0.8, 0.2)*vec3(1, 0, 0);\n        coef = lighting(p, n, sol.Center);\n        col+= coef*vec3(0.8, 0.8, 0.2)*vec3(1.0, 0.8, 0.2);\n        if(a>25.0){coef = lighting(p, n, power.Center);\n        col+= coef*vec3(0.8, 0.8, 0.2)*vec3(0.529, 0.808, 0.922);}\n        t = t_cyl;\n    }\n\n    cyl = Cylinder(vec3(0.0, 0.0, 0.0), normalize(vec3(0.0, 0.0, 1.0)), 13.5, 4.5);\n\n    if (intersect_cylinder(r, cyl, t_cyl) && t_cyl < t) {\n        vec3 p = r.Origin + t_cyl * r.Dir;\n        vec3 n = normalize(p - (cyl.Base + dot(p - cyl.Base, cyl.Axis) * cyl.Axis));\n        float coef = lighting(p, n, light);\n        col = coef * vec3(0.8, 0.2, 0.2);\n        coef = lighting(p, n, ener.Center);\n        if(enerx==0.0 || enerx==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.8, 0.8, 0.2)*vec3(1, 0, 0);\n        coef = lighting(p, n, ener2.Center);\n        if(enerx2==0.0 || enerx2==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.8, 0.8, 0.2)*vec3(1, 0, 0);\n        coef = lighting(p, n, ener3.Center);\n        if(enerx3==0.0 || enerx3==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.8, 0.8, 0.2)*vec3(1, 0, 0);\n        coef = lighting(p, n, sol.Center);\n        col+= coef*vec3(0.8, 0.8, 0.2)*vec3(1.0, 0.8, 0.2);\n        if(a>25.0){coef = lighting(p, n, power.Center);\n        col+= coef*vec3(0.8, 0.8, 0.2)*vec3(0.529, 0.808, 0.922);}\n        t = t_cyl;\n    }\n\n    cyl = Cylinder(vec3(0.0, 0.0, -5.0), normalize(vec3(0.0, 0.0, 1.0)), 11.5, 4.5);\n\n    if (intersect_cylinder(r, cyl, t_cyl) && t_cyl < t) {\n        vec3 p = r.Origin + t_cyl * r.Dir;\n        vec3 n = normalize(p - (cyl.Base + dot(p - cyl.Base, cyl.Axis) * cyl.Axis));\n        float coef = lighting(p, n, light);\n        col = coef * vec3(0.8, 0.2, 0.2);\n        coef = lighting(p, n, ener.Center);\n        if(enerx==0.0 || enerx==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.8, 0.8, 0.2)*vec3(1, 0, 0);\n        coef = lighting(p, n, ener2.Center);\n        if(enerx2==0.0 || enerx2==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.8, 0.8, 0.2)*vec3(1, 0, 0);\n        coef = lighting(p, n, ener3.Center);\n        if(enerx3==0.0 || enerx3==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.8, 0.8, 0.2)*vec3(1, 0, 0);\n        coef = lighting(p, n, sol.Center);\n        col+= coef*vec3(0.8, 0.8, 0.2)*vec3(1.0, 0.8, 0.2);\n        if(a>25.0){coef = lighting(p, n, power.Center);\n        col+= coef*vec3(0.8, 0.8, 0.2)*vec3(0.529, 0.808, 0.922);}\n        t = t_cyl;\n    }\n    cyl = Cylinder(vec3(0.0, 0.0, -8.0), normalize(vec3(0.0, 0.0, 1.0)), 7.5, 4.5);\n\n    if (intersect_cylinder(r, cyl, t_cyl) && t_cyl < t) {\n        vec3 p = r.Origin + t_cyl * r.Dir;\n        vec3 n = normalize(p - (cyl.Base + dot(p - cyl.Base, cyl.Axis) * cyl.Axis));\n        float coef = lighting(p, n, light);\n        col = coef * vec3(0.8, 0.2, 0.2);\n        coef = lighting(p, n, ener.Center);\n        if(enerx==0.0 || enerx==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.8, 0.8, 0.2)*vec3(1, 0, 0);\n        coef = lighting(p, n, ener2.Center);\n        if(enerx2==0.0 || enerx2==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.8, 0.8, 0.2)*vec3(1, 0, 0);\n        coef = lighting(p, n, ener3.Center);\n        if(enerx3==0.0 || enerx3==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.8, 0.8, 0.2)*vec3(1, 0, 0);\n        coef = lighting(p, n, sol.Center);\n        col+= coef*vec3(0.8, 0.8, 0.2)*vec3(1.0, 0.8, 0.2);\n        if(a>25.0){coef = lighting(p, n, power.Center);\n        col+= coef*vec3(0.8, 0.8, 0.2)*vec3(0.529, 0.808, 0.922);}\n        t = t_cyl;\n    }\n\n//Dyson  (anneaux en rotation autour du soleil)\n    cyl = Cylinder(sol.Center, normalize(rot2*rotcyl3*rotz*vec3(0.0, 0.0, 1.0)), 3.4, 0.8);\n\n    if (intersect_cylinder(r, cyl, t_cyl) && t_cyl < t) {\n        vec3 p = r.Origin + t_cyl * r.Dir;\n        vec3 n = normalize(p - (cyl.Base + dot(p - cyl.Base, cyl.Axis) * cyl.Axis));\n        float coef = lighting(p, n, light);\n        col = coef * vec3(0.8, 0.2, 0.2);\n        coef = lighting(p, n, ener.Center);\n        if(enerx==0.0 || enerx==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.8, 0.8, 0.2)*vec3(1, 0, 0);\n        coef = lighting(p, n, ener2.Center);\n        if(enerx2==0.0 || enerx2==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.8, 0.8, 0.2)*vec3(1, 0, 0);\n        coef = lighting(p, n, ener3.Center);\n        if(enerx3==0.0 || enerx3==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.8, 0.8, 0.2)*vec3(1, 0, 0);\n        coef = lighting(p, n, sol.Center);\n        col+= coef*vec3(0.8, 0.8, 0.2)*vec3(1.0, 0.8, 0.2);\n        if(a>25.0){coef = lighting(p, n, power.Center);\n        col+= coef*vec3(0.8, 0.8, 0.2)*vec3(0.529, 0.808, 0.922);}\n        t = t_cyl;\n    }\n    cyl = Cylinder(sol.Center, normalize(rot2*0.7*rotcyl2*rotz*vec3(1.0, 0.0, 0.0)), 3.4, 0.8);\n\n    if (intersect_cylinder(r, cyl, t_cyl) && t_cyl < t) {\n        vec3 p = r.Origin + t_cyl * r.Dir;\n        vec3 n = normalize(p - (cyl.Base + dot(p - cyl.Base, cyl.Axis) * cyl.Axis));\n        float coef = lighting(p, n, light);\n        col = coef * vec3(0.8, 0.2, 0.2);\n        coef = lighting(p, n, ener.Center);\n        if(enerx==0.0 || enerx==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.8, 0.8, 0.2)*vec3(1, 0, 0);\n        coef = lighting(p, n, ener2.Center);\n        if(enerx2==0.0 || enerx2==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.8, 0.8, 0.2)*vec3(1, 0, 0);\n        coef = lighting(p, n, ener3.Center);\n        if(enerx3==0.0 || enerx3==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.8, 0.8, 0.2)*vec3(1, 0, 0);\n        coef = lighting(p, n, sol.Center);\n        col+= coef*vec3(0.8, 0.8, 0.2)*vec3(1.0, 0.8, 0.2);\n        if(a>25.0){coef = lighting(p, n, power.Center);\n        col+= coef*vec3(0.8, 0.8, 0.2)*vec3(0.529, 0.808, 0.922);}\n        t = t_cyl;\n    }\n    cyl = Cylinder(sol.Center, normalize(-rot2*rotcyl1*rotz*vec3(0.0, 1.0, 0.0)), 3.4, 0.8);\n\nif (intersect_cylinder(r, cyl, t_cyl) && t_cyl < t) {\n    vec3 p = r.Origin + t_cyl * r.Dir;\n    vec3 n = normalize(p - (cyl.Base + dot(p - cyl.Base, cyl.Axis) * cyl.Axis));\n    float coef = lighting(p, n, light);\n    col = coef * vec3(0.8, 0.2, 0.2);\n        coef = lighting(p, n, ener.Center);\n        if(enerx==0.0 || enerx==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.8, 0.8, 0.2)*vec3(1, 0, 0);\n        coef = lighting(p, n, ener2.Center);\n        if(enerx2==0.0 || enerx2==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.8, 0.8, 0.2)*vec3(1, 0, 0);\n        coef = lighting(p, n, ener3.Center);\n        if(enerx3==0.0 || enerx3==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.8, 0.8, 0.2)*vec3(1, 0, 0);\n        coef = lighting(p, n, sol.Center);\n        col+= coef*vec3(0.8, 0.8, 0.2)*vec3(1.0, 0.8, 0.2);\n        if(a>25.0){coef = lighting(p, n, power.Center);\n        col+= coef*vec3(0.8, 0.8, 0.2)*vec3(0.529, 0.808, 0.922);}\n    t = t_cyl;\n}\n\n\nPlane finitePlane;\n\n// flying island\ncyl = Cylinder(3.0*rotcyl1*rotz*rot2*vec3(1.0, 1.0, 1.0)+vec3(0.0, 3.0, 1.5), normalize(vec3(0.0, -4.0, 2.0)), 0.35, 2.2);\n\n// Intersecting with the cylinder\nt_cyl;\nif (intersect_cylinder(r, cyl, t_cyl) && t_cyl < t) {\n    vec3 p = r.Origin + t_cyl * r.Dir;\n    vec3 n = normalize(p - (cyl.Base + dot(p - cyl.Base, cyl.Axis) * cyl.Axis));\n    float coef = lighting(p, n, light);\n    col = coef * vec3(0.8, 0.2, 0.2);\n        coef = lighting(p, n, ener.Center);\n        if(enerx==0.0 || enerx==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.8, 0.8, 0.2)*vec3(1, 0, 0);\n        coef = lighting(p, n, ener2.Center);\n        if(enerx2==0.0 || enerx2==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.8, 0.8, 0.2)*vec3(1, 0, 0);\n        coef = lighting(p, n, ener3.Center);\n        if(enerx3==0.0 || enerx3==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.8, 0.8, 0.2)*vec3(1, 0, 0);\n        coef = lighting(p, n, sol.Center);\n        col+= coef*vec3(0.8, 0.8, 0.2)*vec3(1.0, 0.8, 0.2);\n        if(a>25.0){coef = lighting(p, n, power.Center);\n        col+= coef*vec3(0.8, 0.8, 0.2)*vec3(0.529, 0.808, 0.922);}\n    t = t_cyl;\n}\n\n finitePlane = Plane(3.0*rotcyl1*rotz*rot2*vec3(1.0, 1.0, 1.0)+vec3(0.0, 4.0, 1.32), normalize(vec3(0.0, 0.0, 1.0)), 2.0, 2.0);\n\n    // Intersecting with the finite plane\n    float t_finitePlane;\n    if (intersect_plane(r, finitePlane, t_finitePlane) && t_finitePlane < t) {\n        vec3 p = r.Origin + t_finitePlane * r.Dir;\n        vec3 n = normalize(finitePlane.Normal);\n        float coef = lighting(p, n, light);\n        col = coef * vec3(0.2, 0.8, 0.2);\n        coef = lighting(p, n, ener.Center);\n        if(enerx==0.0 || enerx==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.2, 0.8, 0.2)*vec3(1, 0, 0);\n        coef = lighting(p, n, ener2.Center);\n        if(enerx2==0.0 || enerx2==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.2, 0.8, 0.2)*vec3(1, 0, 0);\n        coef = lighting(p, n, ener3.Center);\n        if(enerx3==0.0 || enerx3==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.2, 0.8, 0.2)*vec3(1, 0, 0);\n        coef = lighting(p, n, sol.Center);\n        col+= coef*vec3(0.2, 0.8, 0.2)*vec3(1.0, 0.8, 0.2);\n        if(a>25.0){coef = lighting(p, n, power.Center);\n        col+= coef*vec3(0.2, 0.8, 0.2)*vec3(0.529, 0.808, 0.922);}\n        t = t_finitePlane;\n    }\n    \n     finitePlane = Plane(3.0*rotcyl1*rotz*rot2*vec3(1.0, 1.0, 1.0)+vec3(0.0, 4.0, 1.82), normalize(vec3(4.0, -4.0, 8.0)), 1.0, 1.0);\n\n    // Intersecting with the finite plane\n    if (intersect_plane(r, finitePlane, t_finitePlane) && t_finitePlane < t) {\n        vec3 p = r.Origin + t_finitePlane * r.Dir;\n        vec3 n = normalize(finitePlane.Normal);\n        float coef = lighting(p, n, light);\n        \n        col = coef * vec3(0.5);\n        coef = lighting(p, n, ener.Center);\n        if(enerx==0.0 || enerx==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.5)*vec3(1, 0, 0);\n        coef = lighting(p, n, ener2.Center);\n        if(enerx2==0.0 || enerx2==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.5)*vec3(1, 0, 0);\n        coef = lighting(p, n, ener3.Center);\n        if(enerx3==0.0 || enerx3==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.5)*vec3(1, 0, 0);\n        coef = lighting(p, n, sol.Center);\n        col+= coef*vec3(0.5)*vec3(1.0, 0.8, 0.2);\n        if(a>25.0){coef = lighting(p, n, power.Center);\n        col+= coef*vec3(0.5)*vec3(0.529, 0.808, 0.922);}\n        t = t_finitePlane;\n    }\n    finitePlane = Plane(3.0*rotcyl1*rotz*rot2*vec3(1.0, 1.0, 1.0)+vec3(-0.4, 4.5, 1.82), normalize(vec3(4.0, -4.0, -8.0)), 1.0, 1.0);\n\n    // Intersecting with the finite plane\n    if (intersect_plane(r, finitePlane, t_finitePlane) && t_finitePlane < t) {\n        vec3 p = r.Origin + t_finitePlane * r.Dir;\n        vec3 n = normalize(finitePlane.Normal);\n        float coef = lighting(p, n, light);\n        \n        col = coef * vec3(0.5);\n        coef = lighting(p, n, ener.Center);\n        if(enerx==0.0 || enerx==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.5)*vec3(1, 0, 0);\n        coef = lighting(p, n, ener2.Center);\n        if(enerx2==0.0 || enerx2==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.5)*vec3(1, 0, 0);\n        coef = lighting(p, n, ener3.Center);\n        if(enerx3==0.0 || enerx3==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.5)*vec3(1, 0, 0);\n        coef = lighting(p, n, sol.Center);\n        col+= coef*vec3(0.5)*vec3(1.0, 0.8, 0.2);\n        if(a>25.0){coef = lighting(p, n, power.Center);\n        col+= coef*vec3(0.5)*vec3(0.529, 0.808, 0.922);}\n        t = t_finitePlane;\n    }\nfinitePlane = Plane(3.0*rotcyl1*rotz*rot2*vec3(1.0, 1.0, 1.0)+vec3(0.0, 0.0, 2.1), normalize(vec3(0.0, 0.0, 1.0)), 2.0, 2.0);\n\n    if (intersect_plane(r, finitePlane, t_finitePlane) && t_finitePlane < t) {\n        vec3 p = r.Origin + t_finitePlane * r.Dir;\n        vec3 n = normalize(finitePlane.Normal);\n        float coef = lighting(p, n, light);\n        col = coef * vec3(0.2, 0.8, 0.2);\n        coef = lighting(p, n, ener.Center);\n        if(enerx==0.0 || enerx==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.2, 0.8, 0.2)*vec3(1, 0, 0);\n        coef = lighting(p, n, ener2.Center);\n        if(enerx2==0.0 || enerx2==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.2, 0.8, 0.2)*vec3(1, 0, 0);\n        coef = lighting(p, n, ener3.Center);\n        if(enerx3==0.0 || enerx3==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.2, 0.8, 0.2)*vec3(1, 0, 0);\n        coef = lighting(p, n, sol.Center);\n        col+= coef*vec3(0.2, 0.8, 0.2)*vec3(1.0, 0.8, 0.2);\n        if(a>25.0){coef = lighting(p, n, power.Center);\n        col+= coef*vec3(0.2, 0.8, 0.2)*vec3(0.529, 0.808, 0.922);}\n    \n        t = t_finitePlane;\n    }\n// flying island\n\nif (intersect_cylinder(r, cyli, t_cyl) && t_cyl < t) {\n    vec3 p = r.Origin + t_cyl * r.Dir;\n    vec3 n = normalize(p - (cyli.Base + dot(p - cyli.Base, cyli.Axis) * cyli.Axis));\n    float coef = lighting(p, n, light);\n    col = coef * vec3(0.8, 0.2, 0.2);\n        coef = lighting(p, n, ener.Center);\n        if(enerx==0.0 || enerx==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.8, 0.8, 0.2)*vec3(1, 0, 0);\n        coef = lighting(p, n, ener2.Center);\n        if(enerx2==0.0 || enerx2==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.8, 0.8, 0.2)*vec3(1, 0, 0);\n        coef = lighting(p, n, ener3.Center);\n        if(enerx3==0.0 || enerx3==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.8, 0.8, 0.2)*vec3(1, 0, 0);\n        coef = lighting(p, n, sol.Center);\n        col+= coef*vec3(0.8, 0.8, 0.2)*vec3(1.0, 0.8, 0.2);\n        if(a>25.0){coef = lighting(p, n, power.Center);\n        col+= coef*vec3(0.8, 0.8, 0.2)*vec3(0.529, 0.808, 0.922);}\n    t = t_cyl;\n}\n\n finitePlane = Plane(rot*vec3(4.0, 6.0, 1.32), normalize(vec3(0.0, 0.0, 1.0)), 2.0, 2.0);\n\n    // Intersecting with the finite plane\n    if (intersect_plane(r, finitePlane, t_finitePlane) && t_finitePlane < t) {\n        vec3 p = r.Origin + t_finitePlane * r.Dir;\n        vec3 n = normalize(finitePlane.Normal);\n        float coef = lighting(p, n, light);\n        col = coef * vec3(0.2, 0.8, 0.2);\n        coef = lighting(p, n, ener.Center);\n        if(enerx==0.0 || enerx==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.2, 0.8, 0.2)*vec3(1, 0, 0);\n        coef = lighting(p, n, ener2.Center);\n        if(enerx2==0.0 || enerx2==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.2, 0.8, 0.2)*vec3(1, 0, 0);\n        coef = lighting(p, n, ener3.Center);\n        if(enerx3==0.0 || enerx3==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.2, 0.8, 0.2)*vec3(1, 0, 0);\n        coef = lighting(p, n, sol.Center);\n        col+= coef*vec3(0.2, 0.8, 0.2)*vec3(1.0, 0.8, 0.2);\n        if(a>25.0){coef = lighting(p, n, power.Center);\n        col+= coef*vec3(0.2, 0.8, 0.2)*vec3(0.529, 0.808, 0.922);}\n    }\nfinitePlane = Plane(rot*vec3(4.0, 2.0, 2.1), normalize(vec3(0.0, 0.0, 1.0)), 2.0, 2.0);\n\n    if (intersect_plane(r, finitePlane, t_finitePlane) && t_finitePlane < t) {\n        vec3 p = r.Origin + t_finitePlane * r.Dir;\n        vec3 n = normalize(finitePlane.Normal);\n        float coef = lighting(p, n, light);\n        col = coef * vec3(0.2, 0.8, 0.2);\n        coef = lighting(p, n, ener.Center);\n        if(enerx==0.0 || enerx==50.0 ){coef=0.0;}\n\n        col+= coef*vec3(0.2, 0.8, 0.2)*vec3(1, 0, 0);\n        coef = lighting(p, n, ener2.Center);\n        if(enerx2==0.0 || enerx2==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.2, 0.8, 0.2)*vec3(1, 0, 0);\n        coef = lighting(p, n, ener3.Center);\n        if(enerx3==0.0 || enerx3==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.2, 0.8, 0.2)*vec3(1, 0, 0);\n        coef = lighting(p, n, sol.Center);\n        col+= coef*vec3(0.2, 0.8, 0.2)*vec3(1.0, 0.8, 0.2);\n        if(a>25.0){coef = lighting(p, n, power.Center);\n        col+= coef*vec3(0.2, 0.8, 0.2)*vec3(0.529, 0.808, 0.922);}\n        t = t_finitePlane;\n    }\n    \n\n    \n    \n\n\ndisk = Disk(vec3(0.0, 0.0, 40.0), normalize(vec3(0.0, 0.0, 1.0)), 30.0);\ndisk.Radius = 0.0;\n\nif (a > 4.0) {\n    disk.Radius = 4.0*(a - 4.0);\n}\n    \n    \n    \nif (intersect_disk(r, disk, t_disk) && t_disk < t) {\n    vec3 p = r.Origin + t_disk * r.Dir;\n    vec3 n = normalize(disk.Normal);\n    float coef = lighting(p, n, light);\n    vec3 diskCol=diskTexture(p, disk);\n    col = diskCol;\n    t = t_disk;\n}\n\n\n\nfinitePlane = Plane(3.0*rotcyl1*rotz*rot2*vec3(1.0, 1.0, 1.0)+vec3(0.0, 0.0, 2.1), normalize(vec3(0.0, 0.0, 1.0)), 2.0, 2.0);\n\n    if (intersect_plane(r, finitePlane, t_finitePlane) && t_finitePlane < t) {\n        vec3 p = r.Origin + t_finitePlane * r.Dir;\n        vec3 n = normalize(finitePlane.Normal);\n        float coef = lighting(p, n, light);\n        col = coef * vec3(0.2, 0.8, 0.2);\n        coef = lighting(p, n, ener.Center);\n        if(enerx==0.0 || enerx==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.2, 0.8, 0.2)*vec3(1, 0, 0);\n        coef = lighting(p, n, ener2.Center);\n        if(enerx2==0.0 || enerx2==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.2, 0.8, 0.2)*vec3(1, 0, 0);\n        coef = lighting(p, n, ener3.Center);\n        if(enerx3==0.0 || enerx3==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.2, 0.8, 0.2)*vec3(1, 0, 0);\n        coef = lighting(p, n, sol.Center);\n        col+= coef*vec3(0.2, 0.8, 0.2)*vec3(1.0, 0.8, 0.2);\n        if(a>25.0){coef = lighting(p, n, power.Center);\n        col+= coef*vec3(0.2, 0.8, 0.2)*vec3(0.529, 0.808, 0.922);}\n    }\n    \n    \n    //Personnage\n    Sphere tete = Sphere(s1.Center+vec3(0.01, -0.02, 0.88), 0.06);\n    if (intersect_sphere(r, tete, t1) && t1 < t) {\n        t = t1;\n        vec3 p = r.Origin + t1*r.Dir;\n        vec3 n = normalize(p - tete.Center);\n        float coef = lighting(p, n, light);\n        col = coef*vec3(1, 1, 1);\n        coef = lighting(p, n, ener.Center);\n        if(enerx==0.0 || enerx==50.0 ){coef=0.0;}\n        col+= coef*vec3(1, 1, 1)*vec3(1, 0, 0);\n        coef = lighting(p, n, ener2.Center);\n        if(enerx2==0.0 || enerx2==50.0 ){coef=0.0;}\n        col+= coef*vec3(1, 1, 1)*vec3(1, 0, 0);\n        coef = lighting(p, n, ener3.Center);\n        if(enerx3==0.0 || enerx3==50.0 ){coef=0.0;}\n        col+= coef*vec3(1, 1, 1)*vec3(1, 0, 0);\n        coef = lighting(p, n, sol.Center);\n        col+= coef*vec3(1, 1, 1)*vec3(1.0, 0.8, 0.2);\n        if(a>25.0){coef = lighting(p, n, power.Center);\n        col+= coef*vec3(1, 1, 1)*vec3(0.529, 0.808, 0.922);}\n    }\n    \n finitePlane = Plane(s1.Center+vec3(0.0, 0.0, 0.78), normalize(vec3(0.5, 5.0, 1.0)), 0.05, 0.05);\n\n    if (intersect_plane(r, finitePlane, t_finitePlane) && t_finitePlane < t) {\n        vec3 p = r.Origin + t_finitePlane * r.Dir;\n        vec3 n = normalize(finitePlane.Normal);\n        float coef = lighting(p, n, light);\n        col = coef * vec3(0.2, 0.8, 0.2);\n        coef = lighting(p, n, ener.Center);\n        if(enerx==0.0 || enerx==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.2, 0.8, 0.2)*vec3(1, 0, 0);\n        coef = lighting(p, n, ener2.Center);\n        if(enerx2==0.0 || enerx2==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.2, 0.8, 0.2)*vec3(1, 0, 0);\n        coef = lighting(p, n, ener3.Center);\n        if(enerx3==0.0 || enerx3==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.2, 0.8, 0.2)*vec3(1, 0, 0);\n        coef = lighting(p, n, sol.Center);\n        col+= coef*vec3(0.2, 0.8, 0.2)*vec3(1.0, 0.8, 0.2);\n        if(a>25.0){coef = lighting(p, n, power.Center);\n        col+= coef*vec3(0.2, 0.8, 0.2)*vec3(0.529, 0.808, 0.922);}\n    t = t_disk;\n    }\n finitePlane = Plane(s1.Center+vec3(0.0, 0.0, 0.78), normalize(vec3(0.5, 5.0, 1.0)), 0.25, 0.01);\n    if (intersect_plane(r, finitePlane, t_finitePlane) && t_finitePlane < t) {\n        vec3 p = r.Origin + t_finitePlane * r.Dir;\n        vec3 n = normalize(finitePlane.Normal);\n        float coef = lighting(p, n, light);\n        col = coef * vec3(0.2, 0.8, 0.2);\n        coef = lighting(p, n, ener.Center);\n        if(enerx==0.0 || enerx==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.2, 0.8, 0.2)*vec3(1, 0, 0);\n        coef = lighting(p, n, ener2.Center);\n        if(enerx2==0.0 || enerx2==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.2, 0.8, 0.2)*vec3(1, 0, 0);\n        coef = lighting(p, n, ener3.Center);\n        if(enerx3==0.0 || enerx3==50.0 ){coef=0.0;}\n        col+= coef*vec3(0.2, 0.8, 0.2)*vec3(1, 0, 0);\n        coef = lighting(p, n, sol.Center);\n        col+= coef*vec3(0.2, 0.8, 0.2)*vec3(1.0, 0.8, 0.2);\n        if(a>25.0){coef = lighting(p, n, power.Center);\n        col+= coef*vec3(0.2, 0.8, 0.2)*vec3(0.529, 0.808, 0.922);}\n    t = t_disk; \n    }\n    \n    \n    \n    //Aura temporelle\n    if(relativeTime>=25.0){float size=4.0;\n        if(relativeTime<26.5){\n            size=(relativeTime-25.0)/1.5*4.0;\n        }\n    \n        if(relativeTime>30.0){\n            size=(1.4159265-(relativeTime-30.0))/1.4159265*4.0;\n            }\n            \n    Sphere aura=Sphere(power.Center,size);\n    float taura;\n    if(intersect_sphere(r, aura, taura) && taura < t) {\n        t = taura;\n        vec3 p = r.Origin + taura*r.Dir;\n        vec3 n = normalize(p - aura.Center);\n        float coef = lighting(p, n, light);\n        col = mix(col, vec3(0.678431, 0.847059, 0.901961), 0.3);\n        }\n    }\n    fragColor = vec4(col, 1.0);\n    \n}\n","name":"Image","description":"","type":"image"}]}