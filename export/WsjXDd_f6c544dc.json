{"ver":"0.1","info":{"id":"WsjXDd","date":"1555473963","viewed":156,"name":"Lake Pathtrace","username":"scratch13764","description":"I might remake this because the rays can't reflect from an object back to the same object, a stupid oversight when writing the parallax function.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["ss"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage (out vec4 o, in vec2 u)\n{\n    o = pow(texture(iChannel0, u/iResolution.xy)*.8, vec4(.8));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Render info\n#define rays 7\n#define raySteps 7\n// Pi and Tau\n#define pi 3.14159\n#define tau 2.*pi\n// Shortcut defines for different heightmaps\n#define rocks 0\n#define water 1\n// Defines for parallax tracing detail\n#define parallaxSteps 5\n// Minimum of 5 steps\n#define pStepSize 1./float(parallaxSteps)\n\nvec3 skyCol (vec3 p)\n{\n    p = normalize(p);\n    vec3 c = vec3(.4,.4,.85);\n    c += p.y*.2;\n    c = mix(c, vec3(1.5),\n            pow(clamp(dot(p, normalize(vec3(1,.8,1))), 0., 1.), 100.));\n    return c;\n}\n\nmat2 rot (float a)\n{\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat tracePlaneD (vec3 ro, vec3 rs, float h)\n{\n    return (h-ro.y)/rs.y;\n}\n\nfloat seed = 0.12;\nvec3 hash3 ()\n{\n    return fract(sin((seed += 3.)*269.2589)*vec3(7284.3874, 3852.4356, 5449.1463))*2.-1.;\n}\nfloat hash1 ()\n{\n    return fract(sin((seed += 1.)*236.2789)*2375.5789)*2.-1.;\n}\n\nvec3 hash (vec3 p)\n{\n    p = round(p);\n    return -1. + 2.*fract(vec3(582.2358, 833.5892, 751.8523)*sin(\n        p.x*64.3 + p.y*97.5 + p.z*25.8));\n}\n\nfloat perlin (vec3 p) //Perlin noise\n{\n    vec3 f = fract(p);\n    p -= f;\n    vec3 m = f*f*f*(f*f*6. - f*15. + 10.);\n    return\n        mix(mix(mix(dot(hash(p + vec3(0,0,0)), f -  vec3(0,0,0)),\n                    dot(hash(p + vec3(1,0,0)), f -  vec3(1,0,0)), m.x),\n                mix(dot(hash(p + vec3(0,1,0)), f -  vec3(0,1,0)),\n                    dot(hash(p + vec3(1,1,0)), f -  vec3(1,1,0)), m.x), m.y),\n            mix(mix(dot(hash(p + vec3(0,0,1)), f -  vec3(0,0,1)),\n                    dot(hash(p + vec3(1,0,1)), f -  vec3(1,0,1)), m.x),\n                mix(dot(hash(p + vec3(0,1,1)), f -  vec3(0,1,1)),\n                    dot(hash(p + vec3(1,1,1)), f -  vec3(1,1,1)), m.x), m.y), m.z);\n}\n\nfloat pHeight (vec2 p, int t)\n{\n    if (t == 0) return texture(iChannel1, p/3.).x;\n    if (t == 1) return .5+.25*(perlin(vec3(p*2., iTime*.5)) + \n                               perlin(vec3(p*.5, iTime*.1)));\n}\n\nvec3 sampleNorm (vec2 p, float s, int t)\n{\n    vec2 slope = vec2(\n    pHeight(p + vec2(0.02, 0), t) - pHeight(p - vec2(0.02, 0), t),\n    pHeight(p + vec2(0, 0.02), t) - pHeight(p - vec2(0, 0.02), t)\n    )/0.04;\n    \n    return normalize(vec3(slope*s, 1)).xzy;\n}\n\nfloat traceParallaxD (vec3 ro, vec3 rs, float h, float s, int t)\n{\n    float dir = sign(h + pHeight(ro.xz, t)*s - ro.y);\n    float lh = .5-(.5+pStepSize)*dir;\n    float d, pD = 1.;\n    vec3 r;\n    float dep, pDep = lh;\n    \n    for (int i = 0; i <= parallaxSteps + 1; i++)\n    {\n        d = tracePlaneD(ro, rs, h + lh*s);\n        r = ro + rs*d;\n        dep = (r.y - h - pHeight(r.xz, t)*s)*(-dir);\n        if (dep < 0.) break;\n        pDep = dep;\n        pD = d;\n        lh += dir*pStepSize;\n    }\n    d = mix(d, pD, dep/(dep - pDep));\n    \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    \n    vec3 cam = vec3(0, sin(iTime/2.)*.25+1.,0);\n    vec3 camstep = normalize(vec3(uv,1));\n    camstep.yz *= rot(.3);\n    camstep.xz *= rot(3.75*pi);\n    vec3 ro, rs;\n    \n    fragColor.rgb = vec3(0);\n    float d;\n    vec3 normal;\n    vec3 col;\n    for (int i = 0; i <= rays; i++)\n    {\n        ro = cam + hash3()/iResolution.y;\n        rs = camstep;\n        d = traceParallaxD (ro, rs, 0., .2, water);\n        if (d <= 0.)\n        {\n            fragColor.rgb = skyCol (rs)*float(rays);\n            break;\n        }\n        ro = ro+rs*d;\n        normal = sampleNorm(ro.xz, .2, water);\n        normal = normalize(normal + hash3()*.01);\n        col = vec3(1);\n        if (hash1 () >= .5)\n        {\n            fragColor.rgb += skyCol (reflect(rs, normal));\n        }else{\n            rs = refract(rs, normal, 1./1.333);\n            for (int s = 0; s <= raySteps; s++)\n            {\n                d = traceParallaxD(ro, rs, -2., .3, rocks);\n                ro = ro+rs*d;\n                col *= texture(iChannel0, ro.xz/5.).rgb;\n                ro = ro+rs*d;\n                normal = sampleNorm(ro.xz, .3, rocks);\n                normal = normalize(normal + hash3()*.3);\n                rs = reflect(rs, normal);\n                d = traceParallaxD (ro, rs, 0., .2, water);\n                ro = ro+rs*d;\n                normal = sampleNorm(ro.xz, .2, water);\n                normal = normalize(normal + hash3()*.3);\n                col = mix(col, vec3(0), .5/(1.+d*.35));\n                if (hash1() >= 0.)\n                {\n                    rs = refract(rs, -normal, .75);\n                    col *= skyCol (rs);\n                    break;\n                }else{\n                    rs = reflect(rs, normal);\n                }\n                \n            }fragColor.rgb += clamp(col, 0., 1.);\n        }\n    }fragColor.rgb /= float(rays); \n    fragColor = mix(fragColor, texture(iChannel3, fragCoord/iResolution.xy), .5);\n}","name":"Buffer A","description":"","type":"buffer"}]}