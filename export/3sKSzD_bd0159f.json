{"ver":"0.1","info":{"id":"3sKSzD","date":"1573564456","viewed":704,"name":"Spinning Mandala ","username":"Luther","description":"Animated circular mandala, my attempt to recreate this animation:\n[url]https://external-preview.redd.it/T8WDx6I5wsLIOaNuXV7o1tnwx-jhj0fdpsmZ4tvhVaU.gif?format=mp4&s=911fe4731f472311b0d163d114284ff6a2451422[/url]","likes":30,"published":1,"flags":32,"usePreview":0,"tags":["2d","animated","spinning","gif","mandala","reproduction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec4 getNoise(in vec2 uv, in vec2 noiseUVscale, in float noiseBrightness, float zoffset)\n{\n     vec4 noise = texture(iChannel1, vec3(uv * noiseUVscale,zoffset + iTime * 0.1)) * noiseBrightness;\n     return noise;\n}\n\nvec4 getMultiNoise(in vec2 uv, in vec2 noiseUVscale, in float noiseBrightness)\n{\n    int octaves = 4;\n    vec2 sScale = noiseUVscale.xy;\n    float brightness = noiseBrightness;\n    float brightMul = 0.2;\n    float freqMul = 20.4;\n    float zOffset = iTime * 0.1;\n    vec4 anoise = vec4(0,0,0,0);\n    for (int i = 0; i < octaves; ++i)\n    {\n     \tvec4 noise = texture(iChannel1, vec3(uv * sScale,zOffset)) * brightness;\n    \tanoise += noise;\n        sScale *= freqMul;\n        brightness *= brightMul;\n        zOffset += 0.1;\n    }\n    //anoise /= float(octaves);\n    return anoise;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float ratio = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 scaleFactor = getScaleFactor(iResolution.xy);\n    vec4 noise =  getNoise(uv, vec2(20.5, 20.5), 0.0015 * scaleFactor.x, 0.0);\n    //vec4 ChromaticAberration(sampler2D samp,vec2 sampuv, vec2 uv, float chromatic_aberration_amount, vec2 noise)\n    vec4 c = vec4(0,0,0,0);//texture(iChannel0, uv);\n    fragColor = ChromaticAberration(iChannel3, uv, uv,2.5 + (sin(iTime) + 0.5 + c.x * 2.0) *1.0, noise.xy);//vec4(texture(iChannel0,uv));    \n        \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\nvec3 cyan_col = vec3(0.4,0.75,1);\nvec3 black_col = vec3(0.0,0.0,0.0);\nvec3 white_col = vec3(1,1,1);\nvec3 red_col = vec3(1,0.1,0.15);\n\nlowp float smooth_edge_interpolate(lowp float v, lowp float minv, lowp float maxv, lowp float edge)\n{\n\t\n\tmediump float diff = maxv - minv;\n\tmediump float sf = ((v - minv) / diff) * PI;\n\tmediump float rs = sin(sf);\n\trs = min(rs *  abs(diff) * edge, 1.0);\n\t\n\treturn (v > minv) && (v < maxv) ? rs : 0.0;\n}\n\nfloat edgefunc(in float d)\n{\n    return pow(d,20.0) + pow(d, 2.0) * 0.4;\n}\n\nmediump vec4 solid_circle(in mediump vec2 uv,in mediump vec2 cp,in float r, in float edgeThickness, in vec3 colour)\n{\n    float d = length(cp - uv) - r;\n    d = 1.0 - clamp(d / edgeThickness, 0.0, 1.0);\n    d = edgefunc(d);\n    return vec4(d * colour,d);    \n}\n\nmediump vec4 circle(in mediump vec2 uv,in mediump vec2 cp,in float r, in float lineThickness, in vec3 colour)\n{\n    float d = length(cp - uv) - r;\n    d = 1.0 - clamp(abs(d) / lineThickness, 0.0, 1.0);\n    d = edgefunc(d);\n    return vec4(d * colour, d);    \n}\n\n\nvec2 FindClosestPoint(in vec2 v1, in vec2 v2, in vec2 pt)\n{\n\tvec2 d = v2 - v1;\n\tvec2 pd = pt - v1;\n\tfloat det = (d.x * d.x + d.y * d.y);\n\tif (det == 0.0)\n\t\treturn v1;\n\tfloat u = clamp((pd.x * d.x + pd.y * d.y) /det, 0.0, 1.0);\n\treturn v1 + (d*u);\n}\n\n\nfloat DistanceFromLine(in vec2 v1, in vec2 v2, in vec2 pt)\n{\n\treturn length((pt - FindClosestPoint(v1, v2, pt)));\n}\n\nmediump vec3 line(in mediump vec2 uv, in mediump vec2 cp1, in mediump vec2 cp2, in float lineThickness, in vec3 colour)\n{\n    float d = 1.0 - clamp(DistanceFromLine(cp1, cp2, uv) / lineThickness, 0.0, 1.0);\n    return edgefunc(d) * colour;\n}\n\n\nfloat quantise(float val, float step)\n{\n    return val - mod(val, step);    \n}\n\nvec3 mandalla(in vec2 uv, in float rad, in highp float offset, float stepRotateOffset)\n{\n    const int ccount = 16;\n    const int rdcount = 3;\n \tfloat lineThickness = 0.03;   \n    vec3 col = circle(uv, vec2(0,0), rad, lineThickness, cyan_col).rgb;\n    float innerOffset = 0.04;\n    col += circle(uv, vec2(0,0), rad - rad * innerOffset, lineThickness, cyan_col).rgb;\n    float crad = rad * 0.07;\n    float icrad = rad - rad * innerOffset * 0.5;\n    highp float cx = 0.0;\n    highp float dx = 2.0 * PI / float(ccount);\n    for (int i = 0; i < ccount; ++i)\n    {\n        cx = dx * float(i);\n        vec2 icp = vec2(sin(cx) * icrad, cos(cx) * icrad);\n        col -= solid_circle(uv, icp, crad * 0.9, 0.025, white_col * 2.0).rgb;\n        col = clamp(col, 0.0, 1.0);\n        col += circle(uv, icp, crad, lineThickness, cyan_col).rgb;\n        col += solid_circle(uv, icp, crad * 0.1, lineThickness * 1.0, cyan_col * 1.7).rgb;\n    \t\n    }\n    //\n    highp float timeStart = offset - stepRotateOffset * dx;\n    cx = timeStart;//\n    highp float ndx = 2.0 * PI / float(rdcount);\n    float incrad = rad - rad * innerOffset * 6.0;\n    float redcrad = crad * 0.6;\n    \n    for (int i = 0; i < rdcount; ++i)\n    {\n        cx = (ndx * float(i)) + timeStart;\n        vec2 icp = vec2(sin(cx) * incrad, cos(cx) * incrad);\n        \n        col = clamp(col, 0.0, 1.0);\n                      \n        float offset2 = quantise(cx, dx)+ (-2.0* dx);           \n        \n    \tfloat cx2 = float(offset2)  ;//0.0;    \n        for (int j = 0; j < 5; ++j)        \n        {\n            vec2 icp2 = vec2(sin(cx2) * icrad, cos(cx2) * icrad);\n            float dist = length(icp2 - icp);\n            vec2 n = (icp2 - icp) / dist;\n            float circStrength = clamp(1.0 - (dist * 8.0), 0.0, 2.0);\n            float lineStrength = clamp(1.0 - (dist * 2.0), 0.01, 2.0);\n            col+=line(uv, icp + n* 0.022, icp2 - n *0.03, lineThickness * 2.0, cyan_col * lineStrength * 1.0);\n            float wrad = crad * pow(circStrength * 0.001, 1.9) * 0.9;\n            vec3 circle_shine = solid_circle(uv, icp2, wrad, lineThickness * 0.9, cyan_col * 112.0 * circStrength).rgb;               ;\n            col += max(vec3(0.0,0.0,0.0), circle_shine);\n            cx2 += dx;\n        }\n        vec4 ccol = solid_circle(uv, icp, redcrad , 0.01, red_col * 2.0);\n        col = mix(col, ccol.rgb, ccol.a);        \n        vec4 wcol = circle(uv, icp, redcrad, lineThickness * 1.2, white_col);\n        //col.rgb += wcol.rgb * 20.0;\n        col = mix(col, wcol.rgb, wcol.a);\n              \n    \t\n        \n    }\n    \n    \n        \n    return col;\n    \n}\n//#define ZOOMYZOOM\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float ratio = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= ratio;\n\t\n    float mtime = iTime * 0.2;\n    \n    // Time varying pixel color\n    #ifdef ZOOMYZOOM\n    float scale = 0.2;\n    float zoom = mod(mtime, 0.4);\n    float rotateOffset = -floor(zoom * 1.4); //attemping to fix the step rotation when the zoom gets modded \n    #else\n    float scale = 0.9;\n    float zoom = 0.0;\n    float rotateOffset = 0.0;\n    #endif\n    float angle =  iTime;//mod(iTime,(2.0 * PI) / 3.0);\n    vec3 col = vec3(0.0,0.0,0.0);\n\t\n    \n    \n    //angle -= rotateOffset;\n    for (int i = 0; i < 10; ++i)\n    {        \n    \t    \n        float scalezoom = scale + zoom;\n        float brightness = clamp(1.2 - scalezoom * 0.3, 0.0, 2.0);\n        #ifdef ZOOMYZOOM        \n    \tcol += mandalla(uv * (scalezoom), 0.4,angle, rotateOffset ) * brightness;\n        #else\n        col += mandalla(uv * scale, 0.4,angle, rotateOffset) * brightness;\n        #endif\n        //brightness-=0.15;\n        scale+= 0.4;\n        angle-=0.40;\n    \t\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\nvec4 cutoff(in vec4 col, float amount)\n{\n    return clamp(col - vec4(amount, amount, amount, amount), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n       // Normalized pixel coordinates (from 0 to 1)\n    float ratio = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = cutoff(texture(iChannel0, uv), 0.8);//vec4(texture(iChannel0,uv));\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"float m_chromatic_aberration_amount = 0.7; //= 0, range(0, 1)\nfloat m_coef1 = -12.108;\nfloat m_coef2 = 22.126;\nfloat m_coef3 = 5.8857;\nfloat m_coef4 = 0.18;\n#define PI 3.141592654\nfloat gaussCurve(float x, float a, float b, float c)\n{\n\tfloat e = 2.71828;\n\tfloat x_b = x-b;\n\tx_b*=x_b;\n\tfloat _2c2 = 2.0*c*c;\t\n\n\treturn a * pow(e, -(x_b / _2c2));\n}\n\n\nfloat normpdf(in float x, in float sigma)\n{\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n//borred from https://www.shadertoy.com/view/XdfGDH\n\n\nmat2 rotmatz2x2Scale(float r, vec2 s)\n{\n    lowp float ca = cos(r);\n    lowp float sa = sin(r);\n\treturn mat2( ca * s.x, -sa *s.y \n\t\t\t\t,sa *s.x, ca * s.y);\n    \n}\n\nvec2 getScaleFactor(vec2 iResolution)\n{\n    return vec2(iResolution.x / 512.0, iResolution.y / 288.0);\n}\n\nvec4 blur( sampler2D samp,vec2 c, vec2 fragCoord, float angle, vec2 scale, vec2 iResolution )\n{\n\t\t\n\t\t//declare stuff\n\t\tconst int mSize = 11;\n\t\tconst int kSize = (mSize-1)/2;\n\t\tfloat kernel[mSize];\n\t\tvec3 final_colour = vec3(0.0);\n    \tvec2 cscale = c * 12.0;\n\t\tvec2 kernel_scale = scale * getScaleFactor(iResolution);\n    \n    \tmat2 kernel_matrix = rotmatz2x2Scale(angle, kernel_scale);\n\t\t//create the 1-D kernel\n\t\tfloat sigma = 7.0;\n\t\tfloat Z = 0.0;\n\t\tfor (int j = 0; j <= kSize; ++j)\n\t\t{\n\t\t\tkernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);\n\t\t}\n\t\t\n\t\t//get the normalization factor (as the gaussian has been clamped)\n\t\tfor (int j = 0; j < mSize; ++j)\n\t\t{\n\t\t\tZ += kernel[j];\n\t\t}\n\t\t\n\t\t//read out the texels\n\t\tfor (int i=-kSize; i <= kSize; ++i)\n\t\t{\n\t\t\tfor (int j=-kSize; j <= kSize; ++j)\n\t\t\t{\n            \t//int j = 0;\n            \tvec2 uv= (fragCoord.xy+vec2(float(i),float(j))*kernel_matrix) / iResolution.xy;\n\t\t\t\tfinal_colour += kernel[kSize+j]*kernel[kSize+i]*texture(samp, uv).rgb;\n            \n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\treturn vec4(final_colour/(Z * Z), 1.0);\n\t\n}\n\nvec2 getChromaValues(vec2 uv)\n{    \n    vec2 abvec = uv - vec2(0.5,0.5);\n    float dist = length(abvec);    \n    float fval = gaussCurve(1.0 - dist, m_coef1,m_coef2,m_coef3);\n    abvec *= m_chromatic_aberration_amount * fval;\n    return abvec;\n}\nvec4 ChromaticAberration(sampler2D samp,vec2 sampuv, vec2 uv, float chromatic_aberration_amount, vec2 noise)\n{   \n    vec3 channel_scaling = vec3(0,1,2) * chromatic_aberration_amount;\n    vec2 abvec = getChromaValues(uv);   \n   \n    abvec += noise.xy;\n    vec3 res = vec3(0,0,0);\n    vec4 central_samp = texture(samp, sampuv);\n    const int steps = 15;   \n    \n    for (int i = 0; i < steps; ++i)\n    {\n        float cx = float(i) / float(steps);\n    \tres.r += texture(samp, sampuv.st + abvec * cx * channel_scaling.r).r;    \n    \tres.g += texture(samp, sampuv.st + abvec * cx * channel_scaling.g).g;\n    \tres.b += texture(samp, sampuv.st + abvec * cx * channel_scaling.b).b;\n    }\n    res /= float(steps * 2);\n    \n    res.rgb += central_samp.rgb * 0.4;\n    \n    return vec4(res.rgb, 1);\n}\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float ratio = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = vec4(texture(iChannel0,uv));\n    vec2 kernel_scale = vec2(6.2,0.001);\n    fragColor += blur(iChannel1, uv, fragCoord, 1.25 * PI, kernel_scale, iResolution.xy) * 1.5;//ChromaticAberration(iChannel2, uv, uv, 2.0,0.001) * 20.0;//vec4(texture(iChannel0,uv));\n    fragColor += blur(iChannel1, uv, fragCoord, 0.55 * PI, kernel_scale, iResolution.xy) * 1.5;\n    fragColor += blur(iChannel1, uv, fragCoord, 0.95 * PI, kernel_scale, iResolution.xy) * 1.5;\n        \n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float ratio = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy;\n    //fragColor = vec4(texture(iChannel0,uv));\n    vec2 kernel_scale = vec2(1.0,1.0);\n    fragColor = blur(iChannel0, uv, fragCoord, 1.25 * PI, kernel_scale, iResolution.xy);//ChromaticAberration(iChannel2, uv, uv, 2.0,0.001) * 20.0;//vec4(texture(iChannel0,uv));\n    //fragColor += blur(iChannel0, uv, fragCoord, 0.55 * PI, kernel_scale, iResolution.xy) * 0.33;\n    //fragColor += blur(iChannel0, uv, fragCoord, 0.95 * PI, kernel_scale, iResolution.xy) * 0.333;\n        \n}","name":"Buffer D","description":"","type":"buffer"}]}