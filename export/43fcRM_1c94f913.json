{"ver":"0.1","info":{"id":"43fcRM","date":"1725967848","viewed":94,"name":"PlasmaThing (simplified version)","username":"mnasell","description":"Plasma Thing\nSimple old-school plasma effect re-interpreted\n\njust tinkering around to see where the endless learning process goes ...\n\nCheers!","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","plasma","light","antialiasing","camera","palettes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Plasma Thing\n// Simple old-school plasma effect re-interpreted\n//\n// I'm still into learning shader coding, if I've some free time.\n// Many thanks to all here who share their great stuff,\n// especially iq for his great learning resource \n// (which I still not nearly understand all, most probably never will :)\n//\n// Cheers!\n\n#define PALCOUNT 3\n#define PALFADE\n#define AA 3\n\n#define MAT_1 float(1)\n#define MAT_2 float(2)\n\n#define MAX_STEPS 256\n#define MIN_DIST     .0001\n#define MAX_DIST  100.\n#define PRECISION    .001\n#define PI          3.141593\n#define TAU         6.283186\n#define FOCAL_LEN   3.\n#define ZERO (min(iFrame,0))\n\nconst float sphereRadius = 50.;\nconst float patternScale = 5.;\n\nconst vec3 palbase[PALCOUNT*4] = vec3[PALCOUNT*4] (\n  //https://iquilezles.org/articles/palettes/\n  vec3(.5, .5, .5), vec3(.5, .5, .5),vec3(1., 1., .5), vec3(.8, .9, .3),\n  vec3(.5, .5, .5), vec3(.5, .5, .5),vec3(1., 1., 1.), vec3(.0, .1, .2),  \n  vec3(.5, .5, .5), vec3(.5, .5, .5),vec3(1., .7, .4), vec3(.1, .15, .2)\n);\n\nfloat rand(vec2 p2d) {\n    return fract(sin(mod(dot(p2d.xy ,vec2(12.9898,78.233)),TAU)) * 43758.5453);\n}\n\n//https://iquilezles.org/articles/palettes/\nvec3 palette(float t, int i) {\n  vec3   a = palbase[i * 4 + 0];\n  vec3   b = palbase[i * 4 + 1];\n  vec3   c = palbase[i * 4 + 2];\n  vec3   d = palbase[i * 4 + 3];\n  return a + b * cos(TAU*(c*t+d));\n}\n\n// fading through the palettes\nvec3 fader(int m, float t, float c, vec3 bc, float bs) {\n#ifdef PALFADE\n  float  phase  = mod(t, 1.); \n  int    i1 = int(mod(floor(t), float(m)));\n  int    i2 = (i1 + 1) % m; \n  return abs(c - .5) < bs ? bc : mix(palette(c,i1), palette(c,i2), smoothstep(0., 1., phase));\n#else  \n  return abs(c - .5) < bs ? bc : palette(1. - c, 0);\n#endif  \n}\n\n// Old-School plasma effect \n// used for object and background\nvec4 plasma(vec2 uv, float bs) {\n  // prevent from running into getting worse if value gets too big\n  float t   = mod(iTime,PI * 4.);\n  float scl = 2.;\n  float v   = 0.33 * (\n    sin(t + uv.x * scl) +\n    sin(t + (uv.x + uv.y) * scl) +\n    sin(t + length(uv + vec2(scl * sin(t), scl * cos(t * .5))) * scl)\n  ) * .5 + .5;\n  return vec4(fader(PALCOUNT, iTime * .05, v, vec3(.5, 0., .5), bs), v);\n}\n\n// https://iquilezles.org/articles/distfunctions/\n// based on sdSphere, but from inside viewport\nvec2 sdSphereInv( vec3 p, float s, float mId) {\n  return vec2(s-length(p),mId);\n}\n\n// https://iquilezles.org/articles/distfunctions/\nvec2 sdRoundBox( vec3 p, vec3 b, float r, float mId) {\n  vec3 q = abs(p) - b + r;  \n  vec2 v = vec2(length(max(q,.0)) + min(max(q.x,max(q.y,q.z)),.0) - r, mId);\n  return v;\n}\n\nvec2 render(vec3 p) {\n    // using a box and apply the plasma as a height\n    vec2 thingy = sdRoundBox(p-vec3(0,-.25+plasma(p.xz,.01).w,.01),vec3(3.,0.1,3.),.3, MAT_1);\n    // a spherical background concave\n    vec2 sphere = sdSphereInv(p, sphereRadius, MAT_2);\n    return sphere.x < thingy.x ? sphere : thingy;\n}\n\n// simple raymarching function\nvec2 raymarching(vec3 ro, vec3 rd) {\n  float d = MIN_DIST;\n  float c = 0.;\n  for (int i = ZERO; i < MAX_STEPS; i++) {\n    vec3 p = ro + d * rd;\n    vec2 cd = render(p);\n    d += cd.x;\n    c=cd.y;\n    if (cd.x < PRECISION || d > MAX_DIST) {\n        break;\n    }\n  }\n  return vec2(d,c);\n}\n\nvec3 calcNormal(vec3 p) {                 \n// trying the version from iq who was \n// inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n// seems to work good :)\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i < 4; i++ )\n    {\n        vec3 e = 0.5773*(2.0 * vec3((((i+3)>>1)&1),((i>>1)&1),(i&1)) - 1.0);\n        n += e*render(p + 0.0005 * e).x;\n    }\n    return normalize(n);                    \n}\n\n// camera orientation matrix\nmat3 camera( in vec3 origin, in vec3 lookAt, float camRotation) {\n\tvec3 cw = normalize(lookAt-origin);\n\tvec3 cp = vec3(sin(camRotation), cos(camRotation),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n// ambient occlusion\n// https://iquilezles.org/articles/nvscene2008/rwwtt.pdf\nfloat calcAO( in vec3 pos, in vec3 nor ) {\n\tfloat occ = 0.;\n    float sca = 1.;\n    for( int i=ZERO; i < 5; i++ ) {\n        float h = .01 + .12 * float(i) / 4.;\n        float d = render(pos + h*nor).x;\n        occ += (h-d)*sca;\n        sca *= .95;\n        if( occ > .35 ) break;\n    }\n    return clamp(1. - 3. * occ, 0., 1. ) * (.5 + .5 * nor.y);\n}\n\n// improve surface/light reflections\nfloat fresnel(vec3 n, vec3 rd) {\n  return pow(clamp(1. - dot(n, -rd), 0., 1.), 5.);\n}\n\n// Phong-Shading light + adding AO and fresnel\nvec3 light(vec3 K_a, vec3 ld, float li, vec3 p, vec3 rd, vec3 n) {\n    vec3  K_d   = vec3(.05);\n    vec3  K_s   = vec3(1.);\n    float alpha = 50.;\n\n    float diffuse  = clamp(dot(ld, n), 0., 1.); \n    diffuse *= calcAO(p,n); \n    float specular = pow(clamp(dot(reflect(ld, n), -rd), 0., 1.), alpha);\n    vec3  combined = li * (K_a + K_d * diffuse + K_s * specular);\n    combined += fresnel(n, rd) * 0.4;\n    return combined;\n}\n\n// as the name says ...\nvec3 grayScale(vec3 c, float s) {\n    return s * vec3(dot(c, vec3(0.299, 0.587, 0.114)));\n}\n\n// background rendering\n// spherical projection of grid with random points + some effects\nvec3 background(vec3 n, float scale, float t) {\n    vec2  uv  = vec2(.5 + atan(n.z, n.x) / TAU, .5 - asin(n.y) / PI * (iResolution.y/iResolution.x))* sphereRadius * scale;       \n    float dC  = length(fract(uv) - 0.5);\n    float rnd = rand(floor(uv));\n    float bF  =  .2 + .2 * cos(rnd * TAU + t * 3.);    \n    float gF  =  1.25 - smoothstep(0.1, 0.5, dC);\n    vec3  sC  = plasma(vec2(n.xy*scale+t), 0.).rgb;\n    return mix(grayScale(sC, .3),gF * sC, step(dC, max(.1,bF))); \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  \tfloat t     = 32.0 + iTime * 1.5;    \n    vec3  lA    = vec3( 0., .75, 0. );\n    vec3  ro    = lA + vec3( 8.5 * cos(.1 * t), 2.25, 8.5 * sin(.1 * t));\n    mat3  cam   = camera(ro, lA, .0); \n    vec3  lpFix = ro + -cam * vec3(2., 6., -2.);    \n// Anti-Aliasing looks quite smoother and not that crispy as without it :)\n#ifdef AA \n    vec3 colorSum = vec3(0.);\n    for (int i = ZERO; i < AA; i++) {\n        for (int j = ZERO; j < AA; j++) {\n            vec2 offset = vec2(float(i),float(j)) / float(AA) - .5;\n            vec2 sampleUV = (2. * (fragCoord+offset) - iResolution.xy) / iResolution.y;\n            vec3 rd = cam * normalize(vec3(sampleUV, FOCAL_LEN));\n            vec2 vd = raymarching(ro, rd);\n            vec3 p  = ro + rd * vd.x;\n            vec3 n  = calcNormal(p);\n            colorSum += light(vd.y == MAT_1 ? plasma(p.xz, .01).rgb : background(normalize(p),patternScale, iTime), normalize(lpFix - p), 1., p, rd, n);\n        }\n    }        \n    fragColor = vec4(colorSum / float(AA * AA), 1.);\n#else\n    vec2 uv = (2. * fragCoord.xy - iResolution.xy) / iResolution.y;\n    vec3 rd = cam * normalize(vec3(uv,FOCAL_LEN));\n    vec2 vd = raymarching(ro, rd);\n    vec3 p  = ro + rd * vd.x;\n    vec3 n  = calcNormal(p);    \n    vec3 oc = vd.y == MAT_1 ? plasma(p.xz, .01).rgb : background(normalize(p), patternScale, iTime);\n    fragColor = vec4(light(oc, normalize(lpFix - p), 1., p, rd, n),1.);\n#endif\n}\n","name":"Image","description":"","type":"image"}]}