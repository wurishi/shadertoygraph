{"ver":"0.1","info":{"id":"WdByWd","date":"1587563374","viewed":57,"name":"Very Ugly Earth","username":"42yeah","description":"Because today's Earth Day? Anyway, you don't want to look behind the globe. I am still terrible at raymarching.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["whatevs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPSILON 0.001\n\nvec2 rand2d(vec2 p) {\n\treturn fract(sin(vec2(\n        dot(p, vec2(31.516, 42.567)),\n        dot(p, vec2(74.52, 636.642))\n    )) * 10000.0);\n}\n\nvec2 ballProject(vec3 p) {\n    return vec2(p.x / (1.0 - p.z), p.y / (1.0 - p.z)); \n}\n\nfloat perlin(vec2 p) {\n    vec2 u = floor(p);\n    vec2 f = fract(p);\n    vec2 s = smoothstep(0.0, 1.0, f);\n\n    vec2 a = rand2d(u);\n    vec2 b = rand2d(u + vec2(1.0, 0.0));\n    vec2 c = rand2d(u + vec2(0.0, 1.0));\n    vec2 d = rand2d(u + vec2(1.0, 1.0));\n    \n    return mix(mix(dot(a, f), dot(b, f - vec2(1.0, 0.0)), s.x),\n               mix(dot(c, f - vec2(0.0, 1.0)), dot(d, f - vec2(1.0, 1.0)), s.x),\n               s.y) * 0.5 + 0.5;\n}\n\nfloat sphereSDF(vec3 p) {\n    return length(p) - 1.0;\n}\n\nfloat sceneSDF(vec3 p) {\n \treturn sphereSDF(p);   \n}\n\nvec3 rayDirection(float fov, vec2 size, vec2 coord) {\n    vec2 xy = coord - size / 2.0;\n    float z = size.y / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, z));\n}\n\nvec3 normalOf(vec3 p) {\n    return normalize(vec3(\n    \tsceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 phong(vec3 p, vec3 eye) {\n    vec3 lightPos = vec3(sin(iTime) * 30.0, 10.0, cos(iTime) * 30.0),\n        lightColor = vec3(1.0, 1.0, 1.0),\n        objColor = vec3(1.0, 0.5, 0.0);\n    \n    vec3 n = normalOf(p);\n    float shinyness = 32.0;\n    float specularMultiplier = 0.0;\n\n    vec2 proj = ballProject(p);\n    float perl = perlin(proj);\n\n    if (perl < 0.45) {\n        objColor = vec3(0.1, 0.2, 0.7);\n        n = n + normalize(p - eye) * perl * 0.3;\n        specularMultiplier = 1.0;\n    } else if (perl < 0.55) {\n        objColor = vec3(0.3, 0.9, 0.3);\n        n = n + vec3(rand2d(proj), rand2d(proj + 1.0).x) * 0.1;\n    } else {\n        objColor = vec3(1.0, 1.0, 1.0);\n        n = n - normalize(p - eye) * perl * 0.5;\n        specularMultiplier = 1.3;\n    }\n\n    \n    vec3 lightDir = normalize(lightPos - p);\n    vec3 refl = normalize(reflect(-lightDir, n));\n    vec3 eyeDir = normalize(eye - p);\n    \n    float diffuse = dot(lightDir, n);\n    if (diffuse < 0.0) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    \n    vec3 o = objColor * (0.1                                       // ambient\n        + dot(lightDir, n)                                         // diffuse\n        + pow(dot(eyeDir, refl), shinyness) * specularMultiplier); // specular\n    return o;\n}\n\nfloat march(vec3 eye, vec3 direction, float start, float end) {\n    float depth = start;\n    \n    for (int i = 0; i < 200; i++) {\n    \tfloat dist = sceneSDF(eye + direction * depth);\n        if (dist <= EPSILON) {\n            return depth + dist;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\n    vec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, 0.0, -6.0);\n    float dist = march(eye, dir, 0.0, 200.0);\n    if (dist >= 200.0) {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        return;  \n    }\n    \n    vec3 p = eye + dir * dist;\n    fragColor = vec4(phong(p, eye), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}