{"ver":"0.1","info":{"id":"stjXDR","date":"1627478056","viewed":323,"name":"scope voro-bluenoise","username":"Carandiru","description":"original shader: https://www.shadertoy.com/view/XtGBDc\nanalyzing https://www.shadertoy.com/view/NlsXDf \nover time is taken into account in 2D fft\nnot so great I guess. sure looks blue.","likes":6,"published":3,"flags":32,"usePreview":0,"tags":["fft","bluenoise","jitter","temporal"],"hasliked":0,"parentid":"Wdt3Rf","parentname":"bluenoise Animation"},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// experimental animation of blue noise\n// animation is judged by the fft output\n// fft output is the result of the animation, taking the last\n// 4 frames into account to give a fairer assesment of the\n// animations destruction to the blue noise properties \n\n// good for checking your blue noise animation\n// that it is still blue noise w/o any significant dc components\n// added (see bufferA)\n// example showing this animation is no good\n\n// *challenge* is to make animation of blue noise with fft output\n// that looks the same or similar to the fft result of non-animated \n// blue noise.\n\n// ################################################## //\n// Buffer A - section ANIMATED BLUE NOISE BEGIN / END //\n// ################################################## //\n\n// original comments:\n//2D Signal Inspector\n//by nimitz 2018 (twitter: @stormoid)\n\n//The noise/signal type can be changed in the Common tab\n//and the code for the signal generation is in Buffer A\n\n/*\n\tTools to help design 2D functions. Here used for noise design, but can be \n\tused for SDFs, Hashes, Image filters or any function that takes 2D input.\n\n\t[...]\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n#ifdef SHOW_FOURIER\n    if (q.x > 0.5)\n    {\n        vec2 dft = textureLod(iChannel1, q-vec2(0.5,0.0), 0.).xy;\n        float amp = length(dft) / SIZE; \n        col = vec3(amp);\n        \n        vec3 cb = col;\n        col *= vec3(0.005, 0.0, 6.0);// * 8e-3;\n\n        // Compress dynamic range.\n        col.rgb *= 6.0;\n        col.rgb = 1.5 * col.rgb / (1.0 + col.rgb);\n        col = mix(cb, col, 0.5f);\n        \n    }\t\n    else\n#endif\n    {\n        col = textureLod(iChannel0, q, 0.).rgb;\n    }\n    //col = pow(col*col, vec3(1.0/2.2)); // up to now, its been linear.\n    \n    //Distribution plot\n    float tot = 0.;\n    if (fragCoord.y> SIZE && fragCoord.x < SIZE)\n    {\n        const float bands = 60.;\n        float bt = floor(fragCoord.x*bands/SIZE);\n        float pt = (floor((fragCoord.x)*bands/SIZE)+0.5)/bands;\n        const float width = 6.;\n        for (float j = 0.; j<=width; j++)\n        for (float i = 0.; i<SIZE; i++)\n        {\n            float v = texelFetch(iChannel0, ivec2(bt+j, i + 0.5), 0).x;\n            if (abs(v-pt) < .5/bands)\n            \ttot += 1.;\n        }\n        tot /= SIZE*width;\n        col.rgb = vec3(smoothstep(0.00,1.,tot*SIZE-fragCoord.y + SIZE + 1.))*vec3(.4,.4,.5);\n        col.rgb += vec3(smoothstep(1.,0.,abs(tot*SIZE-fragCoord.y + SIZE + 0.5)))*vec3(.8,.8,.8);\n        if(fragCoord.y < (SIZE+50.))\n        {\n        \tcol.rgb = max(col.rgb, vec3(0.9,0.6,0.1)*vec3(smoothstep(1.4,0.,abs(fragCoord.x - SIZE/2.))));\n        \tcol.rgb = max(col.rgb, vec3(0.55,0.5,0.4)*vec3(smoothstep(1.4,0.,abs(abs(fragCoord.x - SIZE/2.)-SIZE/4.))));\n        }\n    }\n    \n\n    \n    col *= smoothstep(0.,1.7,abs(fragCoord.y-SIZE+1.));\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// analyzing : https://www.shadertoy.com/view/NlsXDf \n\n//note: remaps v to [0;1] in interval [a;b]\nfloat remap( float a, float b, float v )\n{\n\treturn clamp( (v-a) / (b-a), 0.0, 1.0 );\n}\n\n// voro-blue noise animation test\n\n#define SCALE (127.0)\n#define SPEED 3.0\n\nfloat random1( vec2 p ) {\n    return textureLod(iChannel0, (p * iResolution.xy) / (1024.0f * SCALE), 0.0f).b;\n}\nvec2 random2( vec2 p ) {\n    return textureLod(iChannel0, (p * iResolution.xy) / (1024.0f * SCALE), 0.0f).rg;\n    //return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvec3 voro_bluenoise( in vec2 uv ) {\n    \n    uv *= SCALE;\n    \n    vec2 iuv = floor(uv);\n    vec2 fuv = fract(uv);\n    \n    vec4 mDist = vec4(1.0f); // x least point distnace, y 2nd least point distance ....\n    \n    for(int j=-1; j<=1; ++j) {\n        for(int i=-1; i<=1; ++i) {\n            vec2 neighbour = vec2(float(i), float(j));\n            vec2 point = random2(iuv + neighbour);\n            \n            // animate\n            //point = 0.5f + 0.5f * vec2(cos(SPEED*iTime + 6.2831f*point.x),\n            //                          -sin(SPEED*iTime + 6.2831f*point.y));\n            point = 0.5f + 0.5f*sin(SPEED*iTime + 6.2831f*point);\n            \n            vec2 diff = neighbour + point - fuv;\n                        \n            float dist = dot(diff, diff); // lenght^2\n            \n            if(dist < mDist.x) {\n                mDist.w = mDist.z;\n                mDist.z = mDist.y;\n                mDist.y = mDist.x;\n                mDist.x = dist;\n            } \n            else if(dist < mDist.y) {\n                mDist.w = mDist.z;\n                mDist.z = mDist.y;\n                mDist.y = dist;\n            }\n            else if(dist < mDist.z) {\n                mDist.w = mDist.z;\n                mDist.z = dist;\n            }\n            else if(dist < mDist.w) {\n                mDist.w = dist;\n            }\n        }\n    }\n    \n    mDist = sqrt(mDist);\n\n    float d = mix(mix(mDist.x,mDist.y,0.5f),\n                  mix(mDist.z,mDist.w,0.5f),0.5f);\n       \n    vec3 col = vec3(d);\n    \n    return 1.0f - col;\n}\n\n// ################################################################ //\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(fragCoord.x > SIZE)\n    {\n        fragColor = vec4(0);\n        return;\n    }\n\n    vec2 p = fragCoord/iResolution.xy;\n\n\tp.x *= iResolution.x/iResolution.y;\n    \n    if (fragCoord.y > SIZE)\n        p*=0.75;\n    \n\n    p *= globalScale;\n    \n    // static blue noise reference //\n    //float bn = textureLod(iChannel0, fragCoord/iChannelResolution[0].xy, 0.0).r;\n    \n    // #### ANIMATED BLUE NOISE BEGIN ### //\n               \n    fragColor = vec4(voro_bluenoise(p),1.0);\n    \n    // #### ANIMATED BLUE NOISE END ### //\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define INV_TEMPORAL_FRAMES_HALF (1.0f / 2.0f)\n// original comments:\n//2D Signal Inspector\n//by nimitz 2018 (twitter: @stormoid)\n\n//Type 1 = Orbit noise (https://www.shadertoy.com/view/4t3yDn)\n//Type 2 = Bicubic noise (https://www.shadertoy.com/view/XlVcWV)\n//Type 3 = Value noise\n//Type 4 = Gradient noise (from iq : https://www.shadertoy.com/view/XdXGW8)\n//Type 5 = Simplex noise (modified from iq's to use normalized gradients as per the original paper)\n//Type 6 = FBM (base noise can be defined in buffer A)\n#define NOISE_TYPE 1\n\n//#define SCROLL_COORDS\n#define DIAGONAL_DERIVATIVES\n#define SHOW_FOURIER\n#define SIZE (floor(iResolution.y/2.25)*2.)\n\nconst float globalScale = 1.;\n\n\n//See: https://www.shadertoy.com/view/Xt3cDn\nuint baseHash(uvec2 p)\n{\n    uint h32 = p.y + 374761393U + p.x*3266489917U;\n    h32 = 2246822519U*(h32^(h32 >> 15));\n    h32 = 3266489917U*(h32^(h32 >> 13));\n    return h32^(h32 >> 16);\n}\n\nfloat hash12(vec2 x)\n{\n    uint n = baseHash(uvec2(ivec2(x)));\n    return float(n)*(1.0/float(0xffffffffU));\n}\n\nvec2 hash22(vec2 x)\n{\n    uint n = baseHash(uvec2(ivec2(x)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec4 hash42(vec2 x)\n{\n    uint n = baseHash(uvec2(ivec2(x)));\n    uint n2 = n*48271U;\n    uvec4 rz = uvec4(n, n*16807U, n*n*48271U, n*n*69621U);\n    return vec4(rz & uvec4(0x7fffffffU))/float(0x7fffffff);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n// original comments:\n//2D Signal Inspector\n//by nimitz 2018 (twitter: @stormoid)\n\n//Horizontal + Vertical Discrete Fourier Transform of the input \n//adapted from FabriceNeyret2's https://www.shadertoy.com/view/XtScWt\n\nvec2 cmul (vec2 a,float b) { return mat2(a,-a.y,a.x) * vec2(cos(b),sin(b)); } \n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord )\n{\n   \tfragColor = vec4(0);\n    \n#ifdef SHOW_FOURIER\n    if(fragCoord.x > SIZE || fragCoord.y > SIZE) return;\n    \n    for(float i = 0.; i < SIZE; i++)  \n\t{\n\t\tvec2 xn = texelFetch(iChannel0, ivec2(i, fragCoord.y), 0).rr;\n        vec2 yn = texelFetch(iChannel1, ivec2(fragCoord.x, i), 0).ba;\n\t\tvec2 ang = - 6.2831853 * (fragCoord-.5 -SIZE/2.) * i/SIZE;\n\t\tfragColor.zw += cmul(xn, ang.x);\n\t\tfragColor.xy += cmul(yn, ang.y);\n    }\n#endif\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 temporal_noise = texelFetch(iChannel1, ivec2(fragCoord), 0) * INV_TEMPORAL_FRAMES_HALF;\n    temporal_noise += texelFetch(iChannel0, ivec2(fragCoord), 0) * INV_TEMPORAL_FRAMES_HALF;    \n    \n    fragColor = temporal_noise;\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     vec4 temporal_noise = texelFetch(iChannel1, ivec2(fragCoord), 0) * INV_TEMPORAL_FRAMES_HALF;\n    temporal_noise += texelFetch(iChannel0, ivec2(fragCoord), 0) * INV_TEMPORAL_FRAMES_HALF;    \n    \n    fragColor = temporal_noise;\n}","name":"Buffer D","description":"","type":"buffer"}]}