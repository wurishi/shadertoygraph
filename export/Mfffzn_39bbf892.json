{"ver":"0.1","info":{"id":"Mfffzn","date":"1723226545","viewed":70,"name":"SpotLightTileIntersection","username":"ShadingKnight","description":"Use solid-angle sdf for spotlight culling. Based on https://www.shadertoy.com/view/wtjSDW.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["sdf","lightculling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TILE_SIZE 32.0\n#define SPOT_LIGHT_OUTTER_ANGLE 15.0\n#define LIGHT_RANGE 0.9\n\n// https://www.shadertoy.com/view/wtjSDW.\nfloat sdSolidAngle(vec3 p, vec2 c, float ra)\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float l = length(q) - ra;\n\tfloat m = length(q - c*clamp(dot(q,c),0.0,ra) );\n    return max(l,m*sign(c.y*q.x-c.x*q.y));\n}\n\nfloat map( in vec3 pos )\n{\n    pos.y += 0.4;\n    pos.xy = (mat2(4,3,-3,4)/5.0) * pos.xy;\n    \n    float angle = SPOT_LIGHT_OUTTER_ANGLE * 0.0174;\n    vec2 c = vec2(sin(angle), cos(angle));\n    return sdSolidAngle(pos, c, LIGHT_RANGE);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.5*iTime;\n\tvec3 ro = vec3( 1.0*cos(an), 0.4, 1.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.2,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    \n    const float tmax = 18.0;\n    vec2 o = vec2(-0.5, -0.5);\n    vec3 tot = vec3(0.0);\n    {\n        vec2 p = (2.0 * (floor(fragCoord / TILE_SIZE) * TILE_SIZE + o) - iResolution.xy)/iResolution.y;\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n        \n        // ray differentials\n        vec2 pTop = (2.0 * ((floor(fragCoord / TILE_SIZE) + vec2(0.0, -1.0)) * TILE_SIZE + o) - iResolution.xy)/iResolution.y; \n        vec2 pRight = (2.0 * ((floor(fragCoord / TILE_SIZE) + vec2(1.0, 0.0)) * TILE_SIZE + o) - iResolution.xy)/iResolution.y; \n        vec3 rdTop = normalize( pTop.x*uu + pTop.y*vv + 1.5*ww );\n        vec3 rdRight = normalize( pRight.x*uu + pRight.y*vv + 1.5*ww );\n        \n        // raymarch\n        float t = 0.0;\n        for( int i = 0; i < 64; i++)\n        {\n            vec3 pos = ro + t * rd;\n            vec3 posTop = ro + t * rdTop;\n            vec3 posRight = ro + t * rdRight;\n            posTop += distance(pos, posTop) * rdTop;\n            posRight += distance(pos, posRight) * rdRight;\n            float offset = max(distance(pos, posTop), distance(pos, posRight));\n            float h = map(pos);\n            if(h < offset || t>tmax ) break;\n            t += h;\n        }\n        \n        vec3 col = vec3(0.0);\n        if( t>= tmax )\n        {\n            vec3 pos = ro + t * rd;\n            tot += vec3(0.2,0.3,0.4);\n        }\n    }\n    \n    {\n        // pixel coordinates\n        vec2 p = (2.0*(fragCoord +o)-iResolution.xy)/iResolution.y; \n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n    \n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            tot += vec3(0.8, 0.8, 0.8);\n        }\n    }\n    \n    // grid\n    if (uint(fragCoord.x) % uint(TILE_SIZE) == 0u\n    || uint(fragCoord.y) % uint(TILE_SIZE) == 0u)\n    {\n        tot = vec3(1.0, 1.0, 1.0);\n    }\n\n\tfragColor = vec4(tot, 1.0);\n}","name":"Image","description":"","type":"image"}]}