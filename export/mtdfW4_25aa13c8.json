{"ver":"0.1","info":{"id":"mtdfW4","date":"1701263083","viewed":64,"name":"Pawn","username":"rawburt","description":"small pawn with raymarching, knight in work","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["chess","pawn"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n\n   \n   \n    \n    fragColor = vec4(0);\n    float x, y;\n    float A = 2.;\n    float sx = 1./iResolution.x;\n    float sy = 1./iResolution.y;\n    float ax = sx * A / 2.;\n    float ay = sy * A / 2.;\n    for (x=-ax; x< ax; x+= sx) for (y=-ay; y<ay; y+=sy) fragColor += min ( texture(iChannel0, q + vec2(x,y)), 1.0);\n        \n\tfragColor /= A*A;\n \n    //fragColor =  texelFetch(iChannel0, ivec2(fragCoord), 0);\n    //fragColor = texture(iChannel0, q);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\nvec3  campos        = vec3( 0. , .0 , -15.5 );\nfloat max_distance  = 80.;\nint   max_steps     = 150; \nfloat hit_distance  = 0.001;\nvec3  light_pos     = vec3( -15., 5., -15. );\n\nfloat \ndistance_sphere( in vec3 position, in vec3 sphere_position, float rad ) {\n\n    float onion_out = length( ( position ) - sphere_position ) - rad;\n    \n    return onion_out;\n}\n\nfloat \ndistance_elisp( in vec3 p, in vec3 r) {\n    float d = length( p / r );\n    float k = length( p / ( r * r ) );\n    return d * ( d - 1. ) / k;\n}\n\nfloat \ndistance_line( in vec3 p, in vec3 a, in vec3 b, in float r ) {\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = clamp( dot( pa, ba ) / dot( ba, ba ), 0., 1. );\n    return length( pa - ba * h );\n}\n\nfloat \ndistance_box( in vec3 position, in vec3 box_dims ) {\n\n    vec3 q =  abs( position ) - box_dims;\n    float onion_out = length( max( q, 0.0 ) );\n\n    return onion_out;\n}\n\n\nfloat \ndistance_cyl( vec3 p, float h, float r1 , float r2)\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot(k2, k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n\n  return s*sqrt( min(dot(ca, ca),dot(cb, cb)) );\n}\n\nfloat \nsmax(float a, float b, float k ) {\n    float h = max( k - abs( a - b ), 0.0 );\n    return max( a, b ) + ( .25 / k )*h*h;\n}\n\nfloat \nsmin(float a, float b, float k ) {\n    float h = max( k - abs( a - b ), 0.0 );\n    return min( a, b ) - ( .25 / k )*h*h;\n}\n\n\nvec3 \nop_bend( in vec3 p )\n{\n    const float k = .2; // or some other amount\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    return q;\n}\nfloat knight(vec3 q) {\n\n    q.x -= 4.5;\n    \n    float ds = abs(length( q.xz ) - 1.5 ) - .5;\n    ds = max( ds,  q.y + 1.8 );\n    ds = max( ds, -q.y - 2.  );\n\n    float df = abs(length( q.xz ) - 1.9 ) - .5;\n    df = max( df,  q.y + 1.6   );\n    df = max( df, -q.y - 1.8   );\n\n    //float dc = distance_line(q, vec3(0., 0, -.5), vec3(sin(q.x), cos(q.z), 0.), .2 ); \n    ds = smin(df, ds, 0.6 );\n\n    //body\n\n    float elips_h = .8;\n\n    vec3 qe = q;\n\n    qe.y += 1.;\n\n    float de = distance_elisp( qe, vec3( 2.1, elips_h, 2.1 ) );\n\n    ds = smin(ds, de, .4 );\n    \n    float dh = abs(length( q.xz ) - .9 ) - .5;\n\n    dh = max( dh,  q.y + .1   );\n    dh = max( dh, -q.y - .5   );\n    \n    ds = smin(dh, ds, .4 );\n    \n    vec3 bend = q;\n    bend.y -= 1.5;\n    bend.x -= .5;\n    \n    vec3 qb = op_bend(bend);\n    \n    float stuff = pow( .12 * (.5 + .5 * sin( 16. * atan(qb.x, qb.z ) ) ), 2. );\n    \n    float dbox = distance_box(qb, vec3(.3 - stuff, 2., .5 - .1*qb.y - stuff )) - .2;\n     \n    ds = smin(dbox, ds, .5);\n       \n    qe.y  = q.y;\n    qe.x += .05;\n    float dbd = distance_elisp( qe, vec3(.8, 1.2, 1. ));\n    \n    ds = smin(dbd, ds, .8 );\n    \n    vec3 qhead = q;\n    \n    qhead.y -= 3.7;\n    qhead.x += 1.3;\n    float angle = -2.1;\n    \n    qhead.xy = mat2(sin(angle), -cos(angle), cos(angle), sin(angle) ) * qhead.xy;\n    \n    stuff = pow( .16 * (.5 + .5 * sin( 16. * atan(qhead.x, qhead.z ) ) ), 2. );\n    \n    float dhead = distance_box(qhead, vec3(1.3 - .3 * qhead.y - stuff, .4 -.1 * qhead.x, .7 - .2 * qhead.x - stuff) ) - .2;\n    \n    ds = smin(ds, dhead, .7 );\n    \n    qhead.x -= .2;\n    qhead.y += .6;\n    float dhead_s = distance_box(qhead, vec3(2.2 - .2 * qhead.y, .2 -.08 * qhead.x, .4 - .2 * qhead.x ) ) - .2;\n       \n    ds = max(ds, -dhead_s);\n    \n    qhead.y += .0;\n    qhead.x -= .25;\n   \n    float diff_el = distance_elisp( qhead, vec3( 2.1, .5, 2.1 ) );\n    \n    ds = smax(ds, -diff_el, .3 );\n    \n    qhead.x += .8;\n    qhead.y -= .7;\n    qhead.z  = abs(qhead.z) - .9;\n    float eye =  distance_elisp( qhead, vec3( .4, .15, .2 ) );\n    ds = smin(ds, eye, .02 );\n    return ds;\n}\n\nfloat pawn(vec3 q) {\n\n    q.x += 4.5;\n    \n    float ds = abs(length( q.xz ) - 1.5 ) - .5;\n    ds = max( ds,  q.y + 1.8 );\n    ds = max( ds, -q.y - 2.  );\n\n    float df = abs(length( q.xz ) - 1.9 ) - .5;\n    df = max( df,  q.y + 1.6   );\n    df = max( df, -q.y - 1.8   );\n\n    //float dc = distance_line(q, vec3(0., 0, -.5), vec3(sin(q.x), cos(q.z), 0.), .2 ); \n    ds = smin(df, ds, 0.6 );\n\n    //body\n\n    float elips_h = .8;\n\n    vec3 qe = q;\n\n    qe.y += 1.;\n\n    float de = distance_elisp( qe, vec3( 2.1, elips_h, 2.1 ) );\n\n    ds = smin(ds, de, .4 );\n\n    float dh = abs(length( q.xz ) - .9 ) - .5;\n\n    dh = max( dh,  q.y + .1   );\n    dh = max( dh, -q.y - .5   );\n    \n    ds = smin(dh, ds, .4 );\n\n    float dif = 1.5 + .55*(.4 - q.y ) ;\n\n    float rad = .3 * dif * dif ;\n\n    rad      -= pow( .12 * (.5 + .5 * sin( 16. * atan(q.x, q.z ) ) ), 2. );\n\n    float db = abs(length( q.xz ) - rad ) - .2;\n    \n    db = max( db,  q.y -  2.2 );\n    db = max( db, -q.y - .1   );\n    \n    ds = smin(db, ds, .1);\n\n    //head\n\n    qe    = q;\n    qe.y -= 2.2;\n    elips_h = .3; \n    \n    float dk = distance_elisp( qe, vec3( 1.1, elips_h, 1.1 ) );\n\n    ds = smin(ds, dk, .3 );\n\n    float dp = distance_sphere( q, vec3(0., 3.1, 0. ), .9 );\n    ds = smin(ds, dp, .08 );\n    \n    return ds;\n\n}\n\nvec2\nmap_world(in vec3 p ) {\n    p.y += 2.5;\n    vec3 q = p;\n    q.xz = mat2(sin(iTime), -cos(iTime), cos(iTime), sin(iTime) ) * q.xz;\n    //base \n    \n    float ds = pawn(q);\n    float dp = knight(q);\n    \n    ds *= .5;\n    dp *= .5;\n    \n    ds = min(ds, dp);\n    \n    float dg = q.y + 2.15;\n    \n    dg *= .5;\n    return dg < ds ? vec2( dg, 0.) : vec2(ds, 1.);\n\n}\n\n\n\nvec3\ncalc_normals( vec3 position ) {\n    vec3 small_step = vec3( 0.00001, 0., 0. );\n\n    float grad_x    = map_world( position + small_step.xyy ).x - map_world( position - small_step.xyy ).x;\n    float grad_y    = map_world( position + small_step.yxy ).x - map_world( position - small_step.yxy ).x;\n    float grad_z    = map_world( position + small_step.yyx ).x - map_world( position - small_step.yyx ).x; \n\n    return normalize( vec3( grad_x, grad_y, grad_z ) );\n}\n\nvec2 \ncast_ray(vec3 start, vec3 direct) {\n    float total_distance = 0.;\n\n    vec3  new_pos        = vec3(0., 0., 0.);\n\n    for(int i = 0; i < max_steps; i++) {\n\n        vec3  new_pos     = start + total_distance * direct;\n        vec2  distance    = map_world( new_pos );\n\n        if( distance.x < hit_distance ) {\n            return vec2( total_distance, distance.y );\n        }\n        if( total_distance > max_distance ) {\n            return vec2( -1., -1. );\n        }\n        total_distance += distance.x;\n    }\n    return vec2(total_distance, -1. );\n}\n\n\n\nvec4 ray_march(vec3 dir) {\n\n    vec2  t = cast_ray(campos, dir);\n    \n    vec3 col = vec3( .3, .3, .3) - .8 * dir.y;\n         //col = mix( col, vec3( .9, .95, .9 ), exp( -8. * dir.y) );\n         \n    if( t.x > 0. ) {\n        vec3  new_pos    = campos +  t.x * dir;\n\n        vec3  normal     =  calc_normals( new_pos );\n\n        vec3 light_dir  = normalize( light_pos - new_pos );\n\n        float intensity = clamp( dot( light_dir, normal ), .0, 1.);\n\n        vec3 refl       = reflect( -normalize(( campos - new_pos )), normal );\n        \n        float spec      = pow(max(dot(light_dir, refl ), 0. ), 32. );\n        \n        float sky       = clamp( .5 + .5 * dot(normal, vec3(0.,  1., 0.) ), 0., 1.);\n\n        float bnc       = clamp( .5 + .5 * dot(normal, vec3(0., -1., 0.) ), 0., 1.);\n        float shad      = cast_ray( new_pos + .001 * normal, light_dir ).x;\n        shad = shad > 0. ? shad/80. : 1.;\n        vec3 reflvec    = reflect(dir, -normal);\n        vec2 refl_p     = cast_ray(new_pos + .001 * normal, reflvec);\n        vec3 refl_col   = vec3(0.);\n        \n        vec3 retrvec    = refract(dir, -normal, 1.2);\n        vec2 retr_p     = cast_ray(new_pos + .001 * normal, retrvec);\n        vec3 retr_col   = vec3(0.);\n        \n\n        vec3 mat        = vec3( .18 );\n\n        vec3 sky_col = vec3(.1, .15, .2 );\n        vec3 bnc_col = vec3(.1, .05, .1 );\n\n        int checker_x = int( ( new_pos.x - 200. ) / 4. ) ;\n\n        int checker_z = int( ( new_pos.z - 200. ) / 4. ) ;\n\n        vec3 checker_col = ( checker_x + checker_z )%2 == 0 ? vec3( 4.1, .2, .2 ) : vec3( 9, 9, 9 );\n        \n        if(refl_p.x > 0. && t.y < .5) {\n            refl_col = refl_p.y > .5 ? vec3(4.2, 4.5,  4.5 ) : checker_col; \n            vec3  refl_pos     = new_pos +  refl_p.x * reflvec;\n\n            vec3  refl_normal    =  calc_normals( refl_pos );\n            float refl_intensity = clamp( dot( light_dir, refl_normal ), .0, 1.);\n\n            vec3  refl_refl      = reflect( -normalize(( campos - refl_pos )), refl_normal );\n\n            float refl_spec      = pow(max(dot(light_dir, refl_refl ), 0. ), 32. );\n            \n            refl_col *= (refl_intensity + refl_spec) * mat * shad;\n         }\n         \n         if(retr_p.x > 0. && t.y > .5) {\n            retr_col = retr_p.y > .5 ? vec3(4.2, 4.5,  4.5 ) : checker_col; \n            vec3  retr_pos     = new_pos +  retr_p.x * retrvec;\n\n            vec3  retr_normal    =  calc_normals( retr_pos );\n            float retr_intensity = clamp( dot( light_dir, retr_normal ), .0, 1.);\n\n            vec3  retr_refl      = reflect( -normalize(( campos - retr_pos )), retr_normal );\n\n            float retr_spec      = pow(max(dot(light_dir, retr_refl ), 0. ), 32. );\n            \n            retr_col *= (retr_intensity + retr_spec) * mat * shad;\n         }\n        \n        col = t.y > .5 ? vec3(4.2, 4.5,  4.5 ) : checker_col; \n\n        col = mat * col * shad * ( intensity + spec ) +  mat * sky_col * sky + bnc_col * mat * bnc + .3*refl_col;\n\n        col = pow(col, vec3( 0.4545 ) );\n\n    }\n    return vec4(col, 1.);\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n\n   \n    vec3  dir           = normalize( vec3( p, 1.5 ) );\n    /*\n    fragColor = vec4(0);\n    float A = 8.,  // Change A to define the level of anti-aliasing (1 to 16) ... higher numbers are REALLY slow!\n          s = .001/A, x, y;\n    \n    for (x=-.0005; x<.0005; x+=s) for (y=-.0005; y<.0005; y+=s) fragColor += min ( ray_march(dir + vec3(x,y, 0.) ), 1.0);\n        \n\tfragColor /= A*A;*/\n    fragColor = ray_march(dir);\n}","name":"Buffer A","description":"","type":"buffer"}]}