{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"struct\t\tobj\n{\n    int id;     // id of object\n\tvec3 pos;   // position\n\tvec3 dir;   // direction\n    vec3 scale; // scale\n    vec3 col;   // color\n    float r;    // radius\n    float ka;   // ambiance coeff\n    float kd;   // diffuse coeff\n    float ks;   // spectral coeff\n    float kl;   // shishiness coeff\n};\n\nvec4 cam = vec4(0.0, 0.0, 8.0, 1.0); // camera pos\n\nobj olum = obj(0,\n               vec3(0.0, 4.0, 0.0),\n               vec3(0.0, 0.0, 0.0),\n               vec3(1.0,1.0, 1.0),\n               vec3(1.0, 1.0, 1.0),\n               0.0, 0.0, 0.0, 0.0, 0.0); // light\nobj osph = obj(1,\n               vec3(0.0, 0.0, 0.0),\n               vec3(0.0, 0.0, 0.0),\n               vec3(0.5, 1.0, 0.5),\n               vec3(1.0, 1.0, 1.0),\n               0.5, 0.15, 0.5, 0.5, 1042.0); // sphere\nobj opln = obj(2,\n               vec3(0.0, -1.0, 0.0),\n               vec3(0.0, 0.0, 0.0),\n               vec3(1.0, 1.0, 1.0),\n               vec3(1.0, 0.0, 0.0),\n               0.0, 0.15, 0.5, 0.5, 42.0); // plane\n\nmat4 mid = mat4(1.0, 0.0, 0.0, 0.0,\n                0.0, 1.0, 0.0, 0.0,\n                0.0, 0.0, 1.0, 0.0,\n                0.0, 0.0, 0.0, 1.0);\n\nmat4\ttranslate(in vec3 tr)\n{\n    mat4 m;\n    \n    m = mid;\n    m[0][3] = tr.x;\n    m[1][3] = tr.y;\n    m[2][3] = tr.z;\n    return m;\n}\n\nmat4\tinvTranslate(in vec3 tr)\n{\n    mat4 m;\n    \n    m = mid;\n    m[0][3] = -tr.x;\n    m[1][3] = -tr.y;\n    m[2][3] = -tr.z;\n    return m;\n}\n\nmat4\tscale(in vec3 sc)\n{\n    mat4 m;\n    \n    m = mid;\n    m[0][0] = sc.x;\n    m[1][1] = sc.y;\n    m[2][2] = sc.z;\n    return m;\n}\n\nmat4\tinvScale(in vec3 sc)\n{\n    mat4 m;\n    \n    m = mid;\n    m[0][0] = 1.0 / sc.x;\n    m[1][1] = 1.0 / sc.y;\n    m[2][2] = 1.0 / sc.z;\n    return m;\n}\nmat4\trotX(float a)\n{\n\tmat4 m;\n    \n    m = mid;\n    m[1][1] = cos(a);m[1][2] = -sin(a);\n    m[2][1] = sin(a);m[2][2] = cos(a);\n    return (m);\n}\n\nmat4\trotY(float a)\n{\n\tmat4 m;\n    \n    m = mid;\n    m[0][0] = cos(a);m[0][2] = -sin(a);\n    m[2][0] = -sin(a);m[2][2] = cos(a);\n    return (m);\n}\n\nmat4\trotZ(float a)\n{\n\tmat4 m;\n    \n    m = mid;\n    m[0][0] = cos(a);m[0][1] = -sin(a);\n    m[1][0] = sin(a);m[1][1] = cos(a);\n    return (m);\n}\n\nmat4\trot(float x,float y, float z)\n{\n\tmat4 m;\n    \n    x = x * 3.1416 / 180.0;\n    y = y * 3.1416 / 180.0;\n    z = z * 3.1416 / 180.0;\n    m = mid;\n\tm *= rotY(y);\n    m *= rotZ(z);\n    m *= rotX(x);\n    return (m);\n}\n\nmat4\tinvRot(float x,float y, float z)\n{\n\tmat4 m;\n    \n    x = -x * 3.1416 / 180.0;\n    y = -y * 3.1416 / 180.0;\n    z = -z * 3.1416 / 180.0;\n    m = mid;\n    m *= rotX(x);\n    m *= rotZ(z);\n\tm *= rotY(y);\n    return (m);\n}\n\nvec4\ttransform(in vec4 v, in obj o)\n{\n\tmat4 m;\n\n    m = scale(o.scale);\n    m *= rot(o.dir.x, o.dir.y, o.dir.z);\n    m *= translate(o.pos);\n    v *= m;\n    if (v.w != 0.0)\n        v /= v.w;\n    return v;\n}\n\nvec4\tinvTransform(in vec4 v, in obj o)\n{\n\tmat4 m;\n    \n    m = invTranslate(o.pos);\n\tm *= invRot(o.dir.x, o.dir.y, o.dir.z);\n    m *= invScale(o.scale);\n    v *= m;\n    if (v.w != 0.0)\n        v /= v.w;\n    return v;\n}\n\nobj\t\tgetObj(in int id)\n{\n\tif (id == 1)\n        return (osph);\n    return (opln);\n}\n\nvec4\tcorrect(in vec4 n, in vec4 rd, in obj o)\n{\n\trd = invTransform(rd, o);\n    if (dot(n.xyz, rd.xyz) > 0.0)\n        n.xyz = n.xyz * -1.0;\n    n = transform(n, o);\n    return (vec4(normalize(n.xyz), 0.0));\n}\n\nfloat\tisphere(in vec4 ro, in vec4 rd, in int id, out vec4 i)\n{\n\tobj o = getObj(id);\n    ro = invTransform(ro, o);\n    rd = invTransform(rd, o);\n    float a = dot(rd.xyz, rd.xyz);\n    float b = dot(ro.xyz, rd.xyz);\n    float c = dot(ro.xyz, ro.xyz) - o.r * o.r;\n    float delta = b * b - a * c;\n    if (delta < 0.0)\n        return (-1.0);\n    float t1 = (-b + sqrt(delta)) / a;\n    float t2 = (-b - sqrt(delta)) / a;\n\tif (t1 <= 0.001 && t2 <= 0.001)\n\t\treturn (-1.0);\n    float t;\n\tif ((t1 <= t2 && t1 > 0.001) || (t2 < t1 && t2 < 0.001))\n\t\tt = t1;\n    else if ((t2 <= t1 && t2 > 0.001) || (t1 < t2 && t1 < 0.001))\n\t\tt = t2;\n    i.xyz = ro.xyz + rd.xyz * t;\n    i.w = 1.0;\n    t = length(ro.xyz - i.xyz);\n    i = transform(i, o);\n    return (t);\n}\n\nvec4\tnsphere(in vec4 p, in obj o, in vec4 rd)\n{\n    vec4 n = invTransform(p, o);\n    n.xyz /= n.w;\n    n.w = 0.0;\n    return correct(n, rd, o);\n}\n\nfloat\tiplane(in vec4 ro, in vec4 rd, in int id, out vec4 i)\n{\n    obj o = getObj(id);\n    ro = invTransform(ro, o);\n    rd = invTransform(rd, o);\n    if (rd.y == 0.0)\n        return (-1.0);\n    float t = -ro.y / rd.y;\n    if (t <= 0.0)\n        return (-1.0);\n    i.xyz = ro.xyz + rd.xyz  * t;\n    i.w = 1.0;\n    i.y = 0.0;\n    t = length(ro.xyz - i.xyz);\n\ti = transform(i, o);\n    return (t);\n}\n\nvec4\tnplane(in vec4 pos, in obj o, in vec4 rd)\n{\n    vec4 n = vec4(0.0, 1.0, 0.0, 0.0);\n\treturn correct(n, rd, o);\n}\n\nfloat\tgetIntersect(in vec4 ro, in vec4 rd, in int id, out vec4 i)\n{\n\tif (id == 1)\n        return (isphere(ro, rd, id, i));\n    return (iplane(ro, rd, id, i));\n}\n\nvec4\tgetNormale(in vec4 pos, in obj o, in vec4 rd)\n{\n\tif (o.id == 1)\n        return (nsphere(pos, o, rd));\n    return (nplane(pos, o, rd));\n}\n\nint\t\tintersect(in vec4 ro, in vec4 rd, out float t, out vec4 it)\n{\n    int id = -1;\n    \n    t = -1.0;\n    for (int i = 1; i < 3; i++)\n    {\n        float ti = getIntersect(ro, rd, i, it);\n        if (ti > 0.001 && (t < 0.0 || ti < t))\n        {\n            id = i;\n            t = ti;\n        }\n    }\n    return (id);\n}\n\nbool\tisLightning(in vec4 p) // p is the point of the intersection\n{\n    float t; // length of ray\n    vec4 ipt; // useless\n    vec4 ild = vec4(normalize(olum.pos - p.xyz), 0.0); // invert light direction\n    vec3 d = p.xyz - olum.pos; // length between point and light\n    \n\tint id = intersect(p, ild, t, ipt);\n    if (id > 0 && t > 0.001 && t < length(d))\n        return false;\n    return true;\n}\n\nvec3\tprocessColor(in vec4 ro, in vec4 rd, in float t, int id, in vec4 p)\n{\n    obj o, l; // object and light\n\tvec3 amb, dif, spe; // ambiance, diffuse, spectral colors\n    vec4 n, ld, ild;\n    float ps1, ps2;\n\n    o = getObj(id);\n    l = olum;\n    n = getNormale(p, o, rd); // normal\n    ld = vec4(normalize(l.pos - p.xyz), 0.0); // light direction\n    ild = vec4(normalize(p.xyz - l.pos), 0.0); // inverse light direction\n    ps1 = dot(n, ld);\n    ps2 = -dot(n, ild);\n    amb = o.col * o.ka;\n    dif = spe = vec3(0.0);\n    if (isLightning(p) && ps1 > 0.0)\n    {\n        dif = o.kd * o.col * ps1;\n    \tif (ps2 > 0.0)\n    \t\tspe = l.col * o.ks * pow(ps2, o.kl);\n    }\n    return (clamp(amb + dif + spe, 0.0, 1.0));\n}\n\nvec3\tgetPixelColor(in vec4 ro, in vec4 rd)\n{\n    vec3 col = vec3(0.0);\n    float t;\n    vec4 i;\n    int id = intersect(ro, rd, t, i);\n    \n    if (id > 0)\n    \treturn (processColor(ro, rd, t, id, i));\n    return (col);\n}\n\nvoid\tmainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float e = tan(30.0 * 3.1416 / 180.0);\n    float ratio = iResolution.x / iResolution.y;\n\tvec2 uv = -1.0 + 2.0 * (fragCoord.xy / iResolution.xy);\n    uv *= vec2(e, e / ratio);\n    vec4 ro = cam; // ray origin\n    vec4 rd = vec4(normalize(vec3(uv, -1.0)), 0.0); // ray direction\n    float c = cos(iTime);\n    float s = sin(iTime);\n    osph.dir.x += c * 180.0 + 180.0; // rotation x of sphere\n    osph.dir.z += s * 180.0 + 180.0; // rotation y of sphere\n    olum.pos.x += c * 3.0; // position x of light\n    olum.pos.z += s * 3.0; // position y of light\n\tfragColor = vec4(getPixelColor(ro, rd),1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ll2GzW","date":"1427367523","viewed":179,"name":"test matrix transform","username":"Dermenslof","description":"i try to understand how matrix-tranformation works.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracermatrixtransform"],"hasliked":0,"parentid":"","parentname":""}}