{"ver":"0.1","info":{"id":"DsVcz1","date":"1696146290","viewed":85,"name":"Building_lightning","username":"vince5287","description":"raymarch","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Ray Marching Framework -> IQ\n\n\n// ------1-Utils------------\n#define AA 2\n#define PI 3.14159265\n#define SQ2 1.41421356237\n\nfloat smax(in float a, in float b, in float k)\n{\n    float h = max(k-abs(a-b), 0.0);\n    return max(a, b) + h*h*0.25/k;;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\nfloat repeatPattern(float p, float size) {\n    return mod(p, size) - size / 2.0;\n}\n\n//https://www.shadertoy.com/view/3s3GDn\nfloat getGlow(float dist, float radius, float intensity){\n\treturn pow(radius / max(dist, 1e-6), intensity);\t\n}\n\n// ----------- Noise + Brownian Motion-----------\n\n// rand\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Noise 2D\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\n//noise 3d\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\n//fbm\n#define OCTAVES 6\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\n\n// ----2-SDFs shapes---------- \n//https://iquilezles.org/articles/distfunctions\n\nfloat roundedBox( in vec3 p, in vec3 b, in float r )\n{\n      vec3 q = abs(p) - b;\n      return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdCutHollowSphere( vec3 p, float r, float h, float t )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float w = sqrt(r*r-h*h);\n    \n    return ((h*q.x<w*q.y) ? length(q-vec2(w,h)) : \n                            abs(length(q)-r) ) - t;\n}\n\n\nvec4 towerStruct(in vec3 p, in float time, float offset)\n{\n    vec3 q = p;\n    vec3 q2 = p;\n    vec3 q3 = p;\n    float d = 0.0;\n    \n    // 2 towers around origin with x-symmetry\n    {\n    q.x = abs(q.x);\n    \n    float an = PI/4.0;\n    float ss = sin(an);\n    float cc = cos(an);\n    q.xz = mat2(cc, -ss, ss, cc) * q.xz;\n    \n    float d1 = roundedBox( q-vec3(0.08, 0.0, 0.0), vec3(0.035, 0.1, 0.035), 0.001);\n    \n    d = d1;   \n    \n    // Cut visible corners \n    q2.x = abs(q2.x);   \n    float d2 = roundedBox( q2-vec3(0.108, 0.0, 0.05), vec3(0.005, 0.12, 0.025), 0.0);\n    d = smax(d1, -d2, 0.001);\n    d2 = roundedBox( q2-vec3(0.1, 0.0, 0.108), vec3(0.05, 0.12, 0.005), 0.0);\n    d = smax(d, -d2, 0.001);\n    d2 = roundedBox( q2-vec3(0.1, 0.0, 0.005), vec3(0.05, 0.12, 0.005), 0.0);\n    d = smax(d, -d2, 0.001);\n    }\n    \n    // Big box in the middle\n    {\n    float d2 = roundedBox( p - vec3(0.0, 0.009, 0.067), vec3(0.05, 0.05, 0.025), 0.001 );\n    d = smin(d, d2, 0.005);\n    }\n     \n    return vec4( d, p );\n}\n\n\n// ----3-Core Ray-marching functions-------\n\nvec4 map( in vec3 p, float time )\n{\n    vec3 q = p;\n    vec3 test = p;\n    vec4 res = vec4(2.0, -1.0, 1.0, 1.0);\n    \n    // ------------ 1st Mat ----------\n    // 2 platforms\n    res.y = 1.0;\n    // Top \n    float d = roundedBox( q + vec3(0.0, 0.022, 0.0), vec3(0.204, 0.02, 0.204), 0.001 );\n    // Bottom\n    // Bounding Volume\n    if (d < 0.6){\n        float d2 = roundedBox( q + vec3(0.0, 0.09, 0.0), vec3(0.25, 0.02, 0.25),0.001);\n        d = min(d, d2);\n\n        // 2 Tower structures\n        {\n        q.z = abs(q.z);\n        vec4 d1 = towerStruct(q + vec3(0.0, 0.0, -0.115), time, 0.0);\n\n        d = smin(d, d1.x, 0.004);\n        }\n\n        // Side walls\n        {\n        q.x = abs(q.x);\n        float d1 = roundedBox( q-vec3(0.175, -0.04, 0.0), vec3(0.008, 0.045, 0.195), 0.001 );\n        d = smin(d, d1, 0.01);\n        }\n\n        // Side panels\n        if (abs(p.z) < 0.26)\n        {\n            vec3 qp = p;\n            qp.x = abs(qp.x);\n\n            float repeatDepth = 0.082;\n            qp.z = repeatPattern(qp.z, repeatDepth);\n\n            float san = PI / 4.0;\n            float sfa = tan(san);\n\n            qp.x += sfa * qp.y;\n\n            float d1 = roundedBox( qp-vec3(0.075, -0.15, 0.0), vec3(0.045, 0.055, 0.01), 0.001 );\n            d1 *= 0.6;\n            d = smin(d, d1, 0.01);\n        }\n\n        // 2 Hollow spheres\n        {\n        vec3 qh = p;\n        qh.x = abs(qh.x);\n        // Pythagorean Triplet\n        qh.xy = (mat2(3,4,-4,3)/5.0)*qh.xy;\n\n        float d1 = sdCutHollowSphere( qh-vec3(0.04,0.14,0.0), 0.06, 0.01, 0.005 );\n        d = min(d, d1);\n        if (d < res.x) res.x = d;\n\n        // ------- Change Mat ----------\n        qh -= vec3(0.055, 0.135, 0.0);\n        \n        // Non Linear rotation still following time(not defined at 0)\n        float an = 0.0;\n        if (time > 0.01) an = 0.5*sqrt(time) + (0.5*time + 0.5* sin(time));\n        \n        float ss = sin(an);\n        float cc = cos(an);\n        qh.yz = mat2(cc, -ss, ss, cc) * qh.yz;\n        \n        // Tiny sphere inside the hollow // Gold inside\n        float d2 = length(qh) - 0.04;\n        d1 = min(d1, d2);\n\n        // Cut by a cube for final shape\n        d2 = roundedBox(qh, vec3(0.032), 0.001);\n        d1 = smax(d1, d2, 0.01);\n        \n        d = min(d, d1);\n        \n        if (d < res.x) res = vec4(d, 2.0, 1.0, 1.0);\n        }\n    }\n    // ---------- Change Mat ------------\n    // ground\n    float fh = -0.23 +0.12*fbm(p.zx) + (sin(0.02*p.x) + sin(0.02*p.z));\n    float ground = p.y - fh;\n    \n    d = smin(ground, d, 0.0015);\n    if (d < res.x) res = vec4(d, 4.0, 1.0, 1.0);\n    \n    // ---------- Change Mat ------------\n    // Building base\n    float d1 = roundedBox( p-vec3(0.0, -0.16, 0.0), vec3(0.17, 0.09, 0.17), 0.001 );\n    d = min(d, d1);\n    if (d < res.x) res = vec4(d, 3.0, 1.0, 1.0);\n    \n            \n    // ------ Change Material ----------\n    // Lightning\n    //test.x = abs(test.x);\n    test.x = sign(sin(time*0.3))* test.x;\n    test.x += 0.5 * (-test.y + noise(20.*-test.xy)*-test.y) ;\n    float sp = clamp( exp( -6.0 * mod(time*0.174 , 1.0)),  0.0, 5.0) ;\n    \n    float d2 = roundedBox(test-vec3(.145,0.,0.), vec3(.01*1.2*(sp-.4),1.,0.005*1.2*(sp-.4)),0.001);\n    d2 *= 0.6;\n    \n    if (d2 < res.x) res = vec4(d2, 5.0, 1.0, 1.0);\n    \n    return res;\n}\n\nvec3 calcNormal( in vec3 pos, in float time )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.00025;\n    return normalize( e.xyy*map( pos + e.xyy*eps, time ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps, time ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps, time ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps, time ).x );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor, in float time )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos+h*nor, time ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/rmshadows/\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float k, in float time)\n{\n    float res = 1.0;\n    \n    float t    = 0.001;\n    float tmax = 5.0;\n     \n    for( int i=0; i<64; i++ )\n    {\n        float h = map( ro + rd*t, time ).x;\n        res = min( res, k*h/t );\n        // Change min clamp in case of aliasing\n        t += clamp( h, 0.002, 0.2 );\n        if( res<0.001 || t>tmax ) break;\n    }\n    \n    return clamp( res, 0.0, 1.0 );\n}\n\nvec4 castRay( in vec3 ro, in vec3 rd, in float time)\n{\n    vec4 res = vec4(-1.0);\n\n    float t = 0.001;\n    float tmax = 5.0;\n    for( int i=0; i<256 && t<tmax; i++ )\n    {\n        vec4 h = map(ro+t*rd,time);\n        \n        if( h.x<0.001 ) { res=vec4(t,h.yzw); break; }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nfloat castGlow( in vec3 ro, in vec3 rd, float time, inout float glow  )\n{\n    float depth = 0.0;\n    vec4 dist = vec4(0.0);\n    float end = 50.0;\n    \n    for( int i=0; i<64; i++ )\n    {\n        dist = map(ro+depth*rd, time);\n        glow += getGlow(dist.x, 0.001, 0.65);\n        \n        if( dist.x < 0.000001 ) { return depth; }\n        depth += dist.x;\n        if(depth >= end){\n            return end;\n        }\n    }\n    \n\n    return end;\n}\n\nvec4 castRayIn( in vec3 ro, in vec3 rd, in float time )\n{\n    vec4 res = vec4(-1.0);\n\n    float t = 0.001;\n    float tmax = 5.0;\n    for( int i=0; i<128 && t<tmax; i++ )\n    {\n        vec4 h = -1.0*map(ro+t*rd,time);\n        if( h.x<0.001 ) { res=vec4(t,h.yzw); break; }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n//----4-Render -----------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    float glow = 0.0;\n    float can = 1.0;\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord.xy+o)-iResolution.xy)/iResolution.y;\n        float d = 0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n        \n        float time = iTime - (1.0/48.0)*(float(m*AA+n)+d)/float(AA*AA);\n        #else    \n        vec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n        float time = iTime - 1.0/48.0;\n        \n        #endif\n\n\t    // camera\t\n        float an = 6.2831*time/40.0;\n        vec3 ta = vec3( 0.0, 0.0, 0.0 );\n        //Cinematic camera\n        vec3 ro = ta + vec3( 0.4*(0.5+0.5*sin(an)), -0.10+0.4*(0.5+0.5*sin(an)), 0.5 );\n\n        //float an = -10.0 * iMouse.x/iResolution.x;\n        // Target\n        //vec3 ta = vec3(0.0, 0.0, 0.0);\n        // Ray origin(camera pos)\n        //vec3 ro = ta + vec3(0.8*sin(an), 0.08, 0.8*cos(an));\n        \n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta, 0.0 );\n        \n        // Get some spikes\n        //float sp = -clamp(mod(time, 5.0)*0.5,0.1,1.1) + 1.1;\n        float sp = 5.0*clamp( exp( -6.0 * mod(time*0.174 , 1.0)),  0.0, 5.0) ;\n        \n        // ray direction\n        float fl = 2.0;\n        vec3 rd = ca * normalize( vec3(p,fl) );\n        \n        // raymarch geometry\n        vec4 tuvw = castRay( ro, rd, time);\n        \n        // Base col is sky\n        vec3 col = vec3(0.05, 0.05, 0.09) + max(rd.y,0.1)\n            * clamp(fbm(p*3.0 + ((sin(time*0.04)*4.0))) * (1.0+0.5*sp), 0.2, 1.0);\n        vec3 bco = col;\n        \n        // Get glow on last iteration\n        if (n == 1 && m == 1)\n        {\n            castGlow(ro, rd, time, glow);\n        }\n        \n        \n        if( tuvw.x> 0.0 && tuvw.y > 0.5)\n        {\n            // --------Shading/lighting----------\t\n            \n            // Essential variables\n            vec3 pos = ro + tuvw.x*rd; // Ray hit pos\n            vec3 nor = calcNormal(pos, time);\n            float occ = calcAO(pos, nor, time);\n            vec3 ref = reflect(rd, nor);\n            col = vec3(0.0);\n            \n            // Materials\n            vec3 mat = vec3(1.0);\n            float k = 0.0;\n            vec3 fi = vec3(0.);\n            if (tuvw.y < 1.5) // Building (concrete) \n            {\n                mat = vec3(0.62, 0.63, 0.66);\n                float noi = noise(50.0*pos);\n                noi += noise(500.0*pos);\n                noi += noise(1000.0*pos);\n                sp *= 0.5;\n                mat *= 0.5 + 0.5*noi;\n                  \n                k = 0.1;\n            }\n            else if (tuvw.y < 2.5) // Sphere (Gold)\n            {\n                mat = vec3(0.98, 0.80, 0.01);\n                \n                // Refraction index\n                float IOR = 1.65;\n                // Refract at In pos\n                vec3 rdIn = refract(rd, nor, 1.0/IOR);\n\n                // Take the point of contact - 3epsilon\n                vec3 posIn = pos - nor*0.001*3.0;\n                // Ray march from this new point inside object\n                vec4 dIn = castRayIn(posIn, rdIn, time);\n\n                // Get position of exit\n                vec3 pExit = posIn + rdIn * dIn.x;\n                vec3 nExit = -calcNormal(pExit, time);\n\n                // Refract again at exit point\n                vec3 rdOut = refract(rdIn, nExit, IOR);\n                \n                // Account for total angle refraction\n                if (length(rdOut) == 0.0) rdOut = reflect(rdIn, nExit);\n                \n                sp *= 2.0;\n                \n                ref = rdOut;\n                nor = nExit;\n                fi = vec3(0.08);\n\n                k = 1.0;\n            }\n            else if (tuvw.y < 3.5) // Base (black)\n            {\n                mat = vec3(0.2, 0.2, 0.2);\n                k = 1.0;\n            }\n            else if (tuvw.y < 4.5) // Ground\n            {\n                if (nor.x < 0.011 && nor.z < 0.015)\n                {\n                    mat = vec3(0.17, 0.115, 0.07);\n                    sp = 0.5;\n                    k = 0.3;\n                }\n                else\n                {\n                   mat = vec3(1.0, 1.0, 1.0);\n                   k = 0.01;\n                }\n                \n            }\n            else if (tuvw.y < 5.5) // Lightning\n            {\n                \n                //https://www.shadertoy.com/view/3s3GDn\n                //vec3 glowColour = vec3(0.2, 0.5, 1.0);\n                vec3 glowColour = vec3(10., 10., 10.0);\n                // Glow now holds the value from the ray marching\n                mat = glow * glowColour;\n                // Cancel out diff and spec ligths\n                float can = 0.0;\n                k = 0.0;\n                sp = 0.5;\n            }\n\n            vec3 f0 = fi.x > 0. ? fi : mat;\n            \n            // Top Light - Dark Blue / Gray\n            {\n                float dif = 0.5 + 0.5*nor.y;\n                vec3 spec = vec3(1.0)*smoothstep(-1.0+1.5*occ, 0.6, ref.y);\n                float fre = clamp(1.0+dot(rd, nor), 0.0, 1.0);\n                spec *= f0 + (1.0-f0)*pow(fre, 5.0);\n                \n                col += can*(mat*vec3(0.06,0.14, 0.22)*dif*occ*0.5 * (1.0+2.0*sp));\n                col += can*(k*vec3(0.06,0.14, 0.22)*spec*dif*occ * (1.0+2.0*sp));\n                \n            }\n            // Moon Light - White\n            {\n                vec3 lig = normalize(vec3(0.6, 0.4, 0.4));\n                float diff = clamp(dot(nor,lig), 0.0, 1.0);\n                float sha = calcSoftshadow(pos, lig, 32.0, time);\n                vec3 hal = normalize(lig - rd);\n                vec3 spe = vec3(1.0) * pow(clamp(dot(hal,nor), 0.0, 1.0), 16.0);\n                spe *= f0 + (1.0-f0) * pow(1.0 - clamp(dot(hal,lig), 0.0, 1.0),5.0);\n                 \n                col += can*(mat*vec3(0.95, 0.95, 0.99)*diff*sha*0.2 * (1.0+2.0*sp));\n                col += can*(k*vec3(0.95, 0.95, 0.99)*diff*sha*spe * (1.0+2.0*sp));\n            }\n            \n        }\n        \n        // Blend floor and bg col\n        col = mix(col, bco, clamp(-1.0+exp(tuvw.x*tuvw.x*0.025),0.0, 1.0));\n        \n        // Vignetting (helps focusing attention to center)\n        col *= 1.0 - 0.2*dot(p, p);\n        \n        // gamma        \n\t    tot += pow(col,vec3(0.45) );\n        \n        \n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // cheap dithering\n    tot += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n\n\n    fragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"}]}