{"ver":"0.1","info":{"id":"ttyXWy","date":"1706055808","viewed":55,"name":"Triangle Rendering","username":"KiwiRobbie","description":" ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926538\n#define MaxFaces 1\nstruct tri\n{\n\tvec3 vert1;\n    vec3 vert2;\n    vec3 vert3;\n};\n    \nstruct tri2D\n{\n\tvec2 vert1;\n    vec2 vert2;\n    vec2 vert3;\n};\n\nfloat areaTri(vec2 a,vec2 b,vec2 c){\n\treturn  abs(a.x * (b.y-c.y) + b.x * (c.y-a.y) + c.x  * (a.y-b.y)) * 0.5f; \n}\n\nvec3 findBayCoords(tri2D t,vec2 point){\n    \n    \n    \n    float aABC = areaTri(t.vert1,t.vert2,t.vert3);\n    \n    float aABP = areaTri(t.vert1,t.vert2,point);\n    float aBCP = areaTri(t.vert2,t.vert3,point);\n    float aCAP = areaTri(t.vert3,t.vert1,point);\n\n    vec3 bay = vec3(aBCP/aABC,aCAP/aABC,aABP/aABC);\n    \n\treturn bay;\n\n}\n\nvec3 matRotate(vec3 point,vec3 theta){\n    mat3x3 matrix1 = mat3x3(1, 0,           0,\n                            0, cos(theta.x),sin(theta.x),\n                            0,-sin(theta.x),cos(theta.x));\n    \n    \n    mat3x3 matrix2 = mat3x3(cos(theta.y), 0,-sin(theta.y),\n                            0,            1,           0,\n                            sin(theta.y), 0, cos(theta.y));\n    \n    mat3x3 matrix3 = mat3x3( cos(theta.z), sin(theta.z),0,\n                            -sin(theta.z), cos(theta.z),0,\n                             0,            0,           1);\n    \n    return point * matrix1 * matrix2 * matrix3;\n\n}\n\ntri matRotateTri(tri triangle,vec3 theta){\n    mat3x3 matrix1 = mat3x3(1, 0,           0,\n                            0, cos(theta.x),sin(theta.x),\n                            0,-sin(theta.x),cos(theta.x));\n    \n    \n    mat3x3 matrix2 = mat3x3(cos(theta.y), 0,-sin(theta.y),\n                            0,            1,           0,\n                            sin(theta.y), 0, cos(theta.y));\n    \n    mat3x3 matrix3 = mat3x3( cos(theta.z), sin(theta.z),0,\n                            -sin(theta.z), cos(theta.z),0,\n                             0,            0,           1);\n    \n    return tri( triangle.vert1 * matrix1 * matrix2 * matrix3,\n              \ttriangle.vert2 * matrix1 * matrix2 * matrix3,\n              \ttriangle.vert3 * matrix1 * matrix2 * matrix3);\n\t\n}\n\n\n\nvec2 project2D(vec3 a,vec3 c,vec3 theta,vec3 e,float z){\n\n\n    vec3 vector = a-c;\n    \n    vec3 d = matRotate(vector,theta);\n    vec2 b = vec2((e.z/d.z*z)*d.x+e.x,(e.z/d.z*z)*d.y+e.y);\n    \n\treturn b;\n}\n\ntri2D projectTri(tri a,vec3 c,vec3 theta,vec3 e,float z){\n\ttri2D b;\n\tvec3 vector;\n    vec3 d;\n    \n    vector = a.vert1-c;\n    \n    d = matRotate(vector,theta);\n    b.vert1 = vec2((e.z/d.z*z)*d.x+e.x,(e.z/d.z*z)*d.y+e.y);\n    \n    vector = a.vert2-c;\n    \n    d = matRotate(vector,theta);\n    b.vert2 = vec2((e.z/d.z*z)*d.x+e.x,(e.z/d.z*z)*d.y+e.y);\n        \n    vector = a.vert3-c;\n    \n    d = matRotate(vector,theta);\n    b.vert3 = vec2((e.z/d.z*z)*d.x+e.x,(e.z/d.z*z)*d.y+e.y);\n\treturn b;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat zoom = 2.0f;\n   \n    vec2 mouse = vec2(-0.5f,-0.5*iResolution.y/iResolution.x)+iMouse.xy/iResolution.x;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = vec2(-0.5f,-0.5*iResolution.y/iResolution.x)+fragCoord/iResolution.x;\n    vec2 uv = fragCoord/iResolution.x;\n    \n    vec3 camera = vec3(0,5,-5);\n    vec3 cameraRot = vec3(PI/4.0f,0,0);\n    vec3 cameraPlane = vec3(0.5f,0.25f,0.25);\n   \n\tconst int numFaces = 12;\n    vec3 bayCoords;\n    bool isInTri;\n    vec2 uvCoords;\n    vec4[numFaces] pixels;\n\n    \n    tri[numFaces] t =     tri[numFaces]( tri( vec3(-1,-1,-1), vec3(-1,-1, 1), vec3( 1,-1,-1)),\n                                 \t\t tri( vec3( 1,-1, 1), vec3(-1,-1, 1), vec3( 1,-1,-1)),\n                           \t \t\t\t tri( vec3(-1,-1,-1), vec3(-1,-1, 1), vec3(-1, 1,-1)),\n                                         tri( vec3(-1, 1, 1), vec3(-1,-1, 1), vec3(-1, 1,-1)),\n                                         tri( vec3( 1,-1,-1), vec3( 1,-1, 1), vec3( 1, 1,-1)),\n                                         tri( vec3( 1, 1, 1), vec3( 1,-1, 1), vec3( 1, 1,-1)),\n                                         tri( vec3(-1,-1,-1), vec3( 1,-1,-1), vec3(-1, 1,-1)),\n                                         tri( vec3( 1, 1,-1), vec3( 1,-1,-1), vec3(-1, 1,-1)),\n                                         tri( vec3(-1,-1, 1), vec3( 1,-1, 1), vec3(-1, 1, 1)),\n                                         tri( vec3( 1, 1, 1), vec3( 1,-1, 1), vec3(-1, 1, 1)),\n                                         tri( vec3(-1, 1,-1), vec3(-1, 1, 1), vec3( 1, 1,-1)),\n                                 \t\t tri( vec3( 1, 1, 1), vec3(-1, 1, 1), vec3( 1, 1,-1)));;\n                                       \n    \n    tri2D[numFaces] tUV = tri2D[numFaces]( tri2D( vec2( 0, 0), vec2( 0, 1), vec2( 1, 0)), \n                               \t\t\t   tri2D( vec2( 1, 1), vec2( 0, 1), vec2( 1, 0)), \n                               \t\t\t   tri2D( vec2( 0, 0), vec2( 0, 1), vec2( 1, 0)),\n                                           tri2D( vec2( 1, 1), vec2( 0, 1), vec2( 1, 0)),\n                               \t\t\t   tri2D( vec2( 0, 0), vec2( 0, 1), vec2( 1, 0)),\n                                           tri2D( vec2( 1, 1), vec2( 0, 1), vec2( 1, 0)),\n                                           tri2D( vec2( 0, 0), vec2( 0, 1), vec2( 1, 0)),\n                                           tri2D( vec2( 1, 1), vec2( 0, 1), vec2( 1, 0)),\n                               \t\t\t   tri2D( vec2( 0, 0), vec2( 0, 1), vec2( 1, 0)),\n                                           tri2D( vec2( 1, 1), vec2( 0, 1), vec2( 1, 0)),\n                                           tri2D( vec2( 0, 0), vec2( 0, 1), vec2( 1, 0)), \n                               \t\t\t   tri2D( vec2( 1, 1), vec2( 0, 1), vec2( 1, 0)));\n    tri2D[numFaces] p;\n    \n    float[numFaces] depth;\n\t\n    for(int i = 0;i<t.length();i++){\n    \tt[i] = matRotateTri(t[i],vec3(iTime,iTime/2.0f,iTime/3.0f));\n        p[i] = projectTri(t[i],camera,cameraRot,cameraPlane,zoom);\n        bayCoords = findBayCoords(p[i],uv);\n        isInTri = bayCoords.x+bayCoords.y+bayCoords.z<1.001f;\n    \tuvCoords =\n        bayCoords.x*tUV[i].vert1 + \n        bayCoords.y*tUV[i].vert2 + \n        bayCoords.z*tUV[i].vert3;\n        \n        \n        depth[i] = \n        bayCoords.x*distance(t[i].vert1,camera) + \n        bayCoords.y*distance(t[i].vert2,camera) + \n        bayCoords.z*distance(t[i].vert3,camera);\n    \tpixels[i] += float(isInTri) * float(i)/12.0f * vec4(bayCoords.x>0.5,bayCoords.y>0.5,bayCoords.z>0.5,1);//vec4(bayCoords.x>0.5,bayCoords.y>0.5,bayCoords.z>0.5,1); //vec4(uvCoords.x>0.5f,uvCoords.y>0.5f,0,1);//* vec4(texture(iChannel0,uvCoords).x,texture(iChannel0,uvCoords).y,texture(iChannel0,uvCoords).z,1);\n        depth[i] *= float(isInTri);\n        depth[i] += 1000.0f*float(!isInTri);\n    }\n    \n    float closest = 1000.0f;\n\tint index;\n    \n    for(int i = 0;i<pixels.length();i++){\n        if(closest>depth[i]){\n        \tindex = i;\n            closest = depth[i];\n        }\n    }\n\t\n    \n    \n\n    // Output to screen\n    fragColor = pixels[index];\n}","name":"Image","description":"","type":"image"}]}