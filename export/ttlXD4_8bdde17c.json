{"ver":"0.1","info":{"id":"ttlXD4","date":"1563236196","viewed":175,"name":"Bouncy Glowy Particles","username":"agordeevw","description":"Experimenting with state persistent through frames.","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["simulation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float CONTRIBUTION_SCALE = 0.0125;\nconst float COLOR_SCALE = 1.5;\nconst float COLOR_UPPER_BOUND = 0.625;\n\nfloat ColorContribution(int sphereId, vec2 fragCoord)\n{\n    vec4 transform = texelFetch(iChannel0, ivec2(sphereTransformsBegin)\n                                + ivec2(sphereId, 0), 0);\n    float dist = length(transform.xy - fragCoord.xy);\n    return 1.0 / (dist + CONTRIBUTION_SCALE * float(numSpheres));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(0.0);\n    for (int i = 0; i < numSpheres; i++)\n    {\n        float t = 0.125421 * float(i);\n        vec3 c = textureLod(iChannel1, vec2(t * t + t, t * t * t * t), 0.0).xyz;\n        float m = c.r > c.g ? c.r : c.g;\n        m = m > c.b ? m : c.b;\n        c /= m;\n        color += c * ColorContribution(i, fragCoord);\n    }\n    \n    float centerDist = length(fragCoord - iResolution.xy * 0.5);\n    \n    float colorScale = COLOR_SCALE * 0.625\n        + (0.125 * (1.0 + sin(32.0 * (centerDist - 16.0 * iTime) / iResolution.x)));\n    color *= colorScale;\n    color = clamp(color, 0.0, COLOR_UPPER_BOUND) / COLOR_UPPER_BOUND;\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Layout\nconst ivec2 timeState = ivec2(0, 0);\nconst int numSpheres = 64;\nconst ivec2 sphereTransformsBegin = ivec2(0, 16);\nconst float SMALL_SPHERE_RADIUS = 4.0;\n\nconst float INIT_TIME = 1.0;\nconst float PI = 3.1415926535;\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec4 HandleCollision(vec4 transform, vec4 otherTransform, float dt)\n{\n    if (length(transform.xy - otherTransform.xy) > 2.0 * SMALL_SPHERE_RADIUS)\n\t\treturn transform;\n    \n    vec2 vel_a = transform.w * vec2(cos(transform.z), sin(transform.z));\n    vec2 vel_b = otherTransform.w * vec2(cos(otherTransform.z), sin(otherTransform.z));\n    vec2 e = normalize(transform.xy - otherTransform.xy);\n    vec2 new_vel_a = vel_a + dot(vel_b - vel_a, e) * e;\n    // approximate velocity drop due to bounce\n    new_vel_a *= 0.999;\n    transform.w = length(new_vel_a);\n    transform.z = atan(new_vel_a.y, new_vel_a.x);\n    \n    float offset = 2.0 * SMALL_SPHERE_RADIUS - length(transform.xy - otherTransform.xy); \n    offset *= 0.5;\n    transform.xy += e * offset + 0.001;\n    \n    return transform;\n}\n\nvec4 HandleGravPull(vec4 transform, vec4 otherTransform, float dt)\n{\n    vec2 dir = otherTransform.xy - transform.xy;\n    float dist = length(dir);\n    float forceMultiplier = 1000.0;\n    \n    vec2 vel = transform.w * vec2(cos(transform.z), sin(transform.z));\n    vel += (forceMultiplier / (dist * dist + 0.001)) * normalize(dir) * dt;\n    transform.w = length(vel);\n    transform.z = atan(vel.y, vel.x);\n    return transform;\n}\n\nvec4 UpdateTransform(vec4 transform, float dt)\n{\n    float angle = transform.z;\n    float velocity = transform.w;\n\ttransform.xy += velocity * vec2(cos(angle), sin(angle)) * dt;\n    if (transform.x - SMALL_SPHERE_RADIUS < 0.0 || transform.x + SMALL_SPHERE_RADIUS > iResolution.x)\n    {\n        float offset = transform.x - SMALL_SPHERE_RADIUS < 0.0\n            ? transform.x - SMALL_SPHERE_RADIUS\n            : transform.x + SMALL_SPHERE_RADIUS - iResolution.x;\n        transform.x -= 2.0 * offset;\n        angle = PI - angle;\n    }\n    if (transform.y - SMALL_SPHERE_RADIUS < 0.0 || transform.y + SMALL_SPHERE_RADIUS > iResolution.y)\n    {\n        float offset =\n            transform.y - SMALL_SPHERE_RADIUS < 0.0\n            ? transform.y - SMALL_SPHERE_RADIUS\n            : transform.y + SMALL_SPHERE_RADIUS - iResolution.y;\n        transform.y -= 2.0 * offset;\n        angle = -angle;\n    }\n    \n    transform.z = angle;\n    transform.w = velocity;\n    return transform;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    if (ivec2(fragCoord) == timeState)\n    {\n    \tfragColor.x = iTime;\n        return;\n    }\n    \n    float dt;\n    {\n        float prevTime = texelFetch(iChannel0, timeState, 0).x;\n        dt = min(iTime - prevTime, 1.0 / 30.0);\n    }\n    \n    if (ivec2(fragCoord).y == sphereTransformsBegin.y\n        && ivec2(fragCoord).x >= sphereTransformsBegin.x\n       \t&& ivec2(fragCoord).x < sphereTransformsBegin.x + numSpheres)\n    {\n        int transformId = ivec2(fragCoord).x - sphereTransformsBegin.x;\n        if (iTime < INIT_TIME)\n        {\n            float id = float(transformId);\n            vec2 texcoord = vec2(0.14214 * id * id, 0.12421 * id * id * id);\n        \tvec2 position = iResolution.xy * 0.5;\n            position.x += 64.0 - 128.0 * textureLod(iChannel1, texcoord, 0.0).x;\n            position.y += 64.0 - 128.0 * textureLod(iChannel1, 2.0 * texcoord, 0.0).x;\n            float angle = 4.0 * PI * textureLod(iChannel1, 3.0 * texcoord, 0.0).x;\n            float velocity = 50.0 + 50.0 * float(textureLod(iChannel1, 4.0 * texcoord, 0.0));\n            fragColor = vec4(position, angle, velocity);\n            return;\n        }\n        vec4 transform = texelFetch(iChannel0, sphereTransformsBegin + ivec2(transformId, 0), 0);\n        \n        // Add gravitational pull\n        for (int i = 0; i < numSpheres; i++)\n        {\n            if (i != transformId)\n            {\n                vec4 otherTransform = texelFetch(iChannel0, sphereTransformsBegin + ivec2(i, 0), 0);\n                transform = HandleGravPull(transform, otherTransform, dt);\n            }\n        }\n        \n        // Handle collisions\n        for (int i = 0; i < numSpheres; i++)\n        {\n            if (i != transformId)\n            {\n                vec4 otherTransform = texelFetch(iChannel0, sphereTransformsBegin + ivec2(i, 0), 0);\n                transform = HandleCollision(transform, otherTransform, dt);\n            }\n        }\n        \n        transform = UpdateTransform(transform, dt);\n        fragColor = transform;\n        return;\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}