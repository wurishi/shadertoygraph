{"ver":"0.1","info":{"id":"WdsSRf","date":"1551788069","viewed":169,"name":"Dithered cube","username":"mensab","description":"Quick dithering test","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","pixel","effect","dithering","aliased"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MIN_DIST .2\n#define MAX_DIST 20.\n#define MAX_MARCHING_STEPS 100\n#define EPS .001\n\nfloat box(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n  \treturn min(max(d.x, max(d.y, d.z)), 0.) + length(max(d, 0.));\n}\n\nfloat scene(vec3 p) {\n    //  rotate + bob around\n    float t = iTime;\n    p += vec3(cos(2. * t), sin(.5 * t), sin(t));\n    float theta = .9 * t;\n    mat4 rot = mat4(cos(theta), 0., sin(theta), 0.,\n                    0., 1., 0., 0.,\n                    -sin(theta), 0., cos(theta), 0.,\n                    0., 0., 0., 1.);\n    p = vec3(rot * vec4(p, 0.));\n    \n    return box(p, vec3(.5));\n}\n\n//  simple raymarcher\nfloat raymarch(vec3 cam_pos, vec3 march_dir) {\n    float depth = MIN_DIST;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = scene(cam_pos + depth * march_dir);\n        if (dist < EPS) {\n            return depth;\n        }\n        depth += dist;\n        if (depth >= MAX_DIST) {\n            return MAX_DIST;\n        }\n    }\n    return MAX_DIST;\n}\n\nvec3 cam_dir(float fov, vec2 uv) {\n    vec2 xy = (uv * iResolution.xy) - iResolution.xy / 2.0;\n    float z = iResolution.y / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec3 normal(vec3 p) {\n    vec2 eps = vec2(EPS, 0.);\n    return normalize(vec3(scene(p + eps.xyy) - scene(p - eps.xyy),\n                          scene(p + eps.yxy) - scene(p - eps.yxy),\n                          scene(p + eps.yyx) - scene(p - eps.yyx)));\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 pos = vec3(0., 0., 3.);\n    \n    //  border\n    vec2 px_dist = uv / iResolution.xy;\n\n    vec3 dir = cam_dir(90., uv);\n    float dist = raymarch(pos, dir);\n    \n    float acc = 0.;\n    float sc = 4.;\n    for (float i = 0.; i < 6.28318530; i += 6.28318530 / sc) {\n        vec2 off = vec2(cos(i), sin(i));\n    \tvec3 dir_d = cam_dir(90., uv + px_dist * off);\n    \tfloat dist_d = raymarch(pos, dir_d);\n        acc += abs(dist - dist_d);\n    }\n    \n    float v_d = ceil(acc / (sc * MAX_DIST) - 0.1);\n    \n    //  light\n    float d_n = 1. - (dist / MAX_DIST);\n    vec3 n = normal(pos + dir * dist);\n    vec3 ld = vec3(cos(iTime), sin(0.3 * iTime), sin(iTime));\n    float v = dot(n, ld) * ceil(d_n);\n    \n    //  dither\n    vec2 uvi0 = fragCoord / iChannelResolution[0].xy;\n    float b = texture(iChannel0, uvi0).r;\n\n    fragColor = vec4(1. - step(v, b) + v_d);\n}","name":"Image","description":"","type":"image"}]}