{"ver":"0.1","info":{"id":"slB3WR","date":"1623685203","viewed":623,"name":"Ray Marching BVH","username":"playbyan1453","description":"This shader demonstrates BVH optimization on ray marching, it's quite demanding evaluating both fractals at the same time each object has it's own bounding. When we are too close to bounding volume it will evaluate the fractals inside.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","mandelbulb","bvh","mengersponge"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define steps 256\n#define tmax 16.0\n#define eps 1e-4\n#define detail 0.5\n\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\n// Note : Not exact since we didn't need the interior correct\nfloat cubeSDF(vec3 p, vec3 s) {\n    vec3 q = abs(p) - s;\n    return length(max(q, 0.0));\n}\n\n// oneshade's suggestion clamp the theta\nfloat mandelbulbSDF(vec3 p, float power) {\n    vec3 z = p;\n    float r = 0.0;\n    float dz = 1.0;\n    for(int i = 0; i < 4; i++) {\n        dz = power * pow(r, (power - 1.0) * 0.5) * dz + 1.0;\n        float th = power * acos(clamp(z.z / r, -1.0, 1.0));\n        float ph = power * atan(z.y, z.x);\n        z = p + pow(r, power) * vec3(sin(th) * cos(ph), sin(ph) * sin(th), cos(th));\n        r = length(z);\n        if(r > 2.0) break;\n    }\n    return 0.8 * log(r) * sqrt(r) / dz;\n}\n\nfloat spongeSDF(vec3 p){\n    float d = cubeSDF(p, vec3(1));\n    float res = d;\n    float s = 1.0;\n    for(int m = 0; m < 4; m++) {\n        vec3 a = mod(p * s, 2.0) - 1.0;\n        s *= 3.0;\n        vec3 r = abs(1.0 - 3.0 * abs(a));\n\n        float da = max(r.x, r.y);\n        float db = max(r.y, r.z);\n        float dc = max(r.z, r.x);\n        float c = (min(da, min(db, dc)) - 1.0) / s;\n\n        if(c > d) {\n            d = c;\n            res = c;\n        }\n    }\n    return res;\n}\n\n// Source : https://iquilezles.org/articles/sdfbounding\nfloat map(vec3 p) {\n    vec3 sPos = vec3(-2.0+sin(iTime), 0, 0); // Menger Sponge Position\n    vec3 mPos = vec3(2.25-sin(iTime), 0, 0); // Mandelbulb Posititon\n    float b = cubeSDF(p - sPos, vec3(1)); // Any cheap sdf can be used for bounding volume\n    b = min(b, length(p - mPos) - 1.35);\n    \n    if(fract(iTime/16.0) < 0.5) \n        if(b > 0.2) return b; // March the bounding volume\n\n    float d = spongeSDF(p-sPos);\n    d = min(d, mandelbulbSDF(p-mPos, cos(iTime)*3.0+6.0));\n    return d;\n}\n\nmat3 rot(vec3 ang) {\n    vec3 s = sin(ang);\n    vec3 c = cos(ang);\n    mat3 x = mat3(\n        vec3(1, 0, 0),\n        vec3(0, c.x,-s.x),\n        vec3(0, s.x, c.x)\n    );\n    mat3 y = mat3(\n        vec3(c.y, 0, s.y),\n        vec3(0, 1, 0),\n        vec3(-s.y, 0, c.y)\n    );\n    mat3 z = mat3(\n        vec3(c.z, s.z, 0),\n        vec3(-s.z, c.z, 0),\n        vec3(0, 0, 1)\n    );\n    return x*y*z;\n}\n\nvec3 normal(vec3 p, float ep) {\n    vec2 h = vec2(1,-1) * ep;\n    return normalize(h.xyy*map(p + h.xyy)+\n                     h.yyx*map(p + h.yyx)+\n                     h.yxy*map(p + h.yxy)+\n                     h.xxx*map(p + h.xxx));\n}\n\nfloat adDist(float t, float fov, float de) {\n    float d = de / fov; // Lower more detail\n    return max(t / max(iResolution.x, iResolution.y) * d + eps, eps);\n}\n\nfloat raymarch(vec3 ro, vec3 rd, float fov, out float it) {\n    float t = 0.0;\n    int i = 0;\n    for(; i < steps; i++) {\n        float d = map(ro + rd * t);\n        t += d;\n        if(t > tmax || d < adDist(t, fov, detail)) break;\n    }\n    it = float(i) / float(steps);\n    return t;\n}\n\nvec3 ramp(float x) {\n    float s = 0.2; // blend\n    vec3 p = vec3(0.35, 0.50, 0.66);\n    vec3 col =     vec3(0.0, 0.3, 1.0);\n    col = mix(col, vec3(0.2, 1.0, 0.0), smoothstep(p.x - s, p.x + s, x));\n    col = mix(col, vec3(1.0, 0.8, 0.0), smoothstep(p.y - s, p.y + s, x));\n    col = mix(col, vec3(1.0, 0.0, 0.0), smoothstep(p.z - s, p.z + s, x));\n    col *= 0.5 + 0.5 * x;\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2.0*fragCoord.xy-iResolution.xy)/max(iResolution.x, iResolution.y);\n    mat3 mat = rot(vec3(iTime, 0, -iTime));\n    vec3 ro = vec3(0, 0, -6)*mat;\n    float fov = 1.0;\n    vec3 rd = normalize(vec3(uv, fov)) * mat;\n    float iter;\n    float t = raymarch(ro, rd, fov, iter); // Raymarch and how many iterations\n    float fi = adDist(t, fov, detail);\n    // vec3 nor = normal(ro + rd * t, fi);\n    // vec3 col = nor * mat * 0.5 + 0.5;\n    vec3 col = ramp(iter * 4.0);\n         col = pow(col, vec3(0.4545));\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}