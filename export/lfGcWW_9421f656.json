{"ver":"0.1","info":{"id":"lfGcWW","date":"1731859978","viewed":108,"name":"spiral rotator","username":"nayk","description":"source https://www.shadertoy.com/view/4c3yRX https://www.shadertoy.com/view/4cGyDW https://www.shadertoy.com/view/lfKyWz","likes":5,"published":3,"flags":0,"usePreview":0,"tags":["fractal","tunnel","spiral"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float tri_sin( in float x ) {\n    float m = mod(2.0*(x*3.141593)-1.0,4.0)-2.0;\n    return m*sign(m) - 1.0;\n}\nfloat Xor(float a, float b){\n    return a*(1.-b)+b*(1.-a);\n}\n\nfloat exp_mix0( in float a, in float b, in float c, in float s ) {\n    return a+(b-a)*( c<0.5 ? (1.0-pow(1.0-2.0*c,s))*0.5 : pow(2.0*c-1.0,s)*0.5+0.5 );\n}\nfloat exp_mix1( in float a, in float b, in float c, in float s ) {\n    return a+(b-a)*( c<0.5 ? pow(2.0*c,s)*0.5 : (1.0-pow(2.0-2.0*c,s))*0.5+0.5 );\n}\nfloat exp_mix_div( in float a, in float b, in float c, in float s ) {\n    return \n    s>1.0?\n    exp_mix1(a,b,c,s)\n    :\n    exp_mix0(a,b,c,2.0-s);\n}\n\nvec3 h2rgb( in float h, in float s ) {\n    h *= 360.0;\n    float R = max(0.0,2.0*h-480.0)+max(0.0,-2.0*h+240.0);\n    R = exp_mix_div( 0.0, 1.0, min(120.0,R)/120.0 - 0.000001, s );\n    float G = min(120.0,2.0*h)+min(120.0,-2.0*h+480.0)-120.0;\n    G = exp_mix_div( 0.0, 1.0, max(0.0,G)/120.0 - 0.000001, s );\n    float B = min(120.0,2.0*h-240.0)+min(120.0,-2.0*h+720.0)-120.0;\n    B = exp_mix_div( 0.0, 1.0, max(0.0,B)/120.0 - 0.000001, s );\n    return vec3( R, G, B );\n}\n\n\nfloat u_transitionAmount; // Controls transition between states\n\nfloat hash(float n) { \n    return fract(sin(n) * 43758.5453123); \n}\n\nfloat noise(float x) {\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(hash(i), hash(i + 1.0), u);\n}\n\nfloat noise2D(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f);\n    \n    float a = hash(i.x + i.y * 57.0);\n    float b = hash(i.x + 1.0 + i.y * 57.0);\n    float c = hash(i.x + (i.y + 1.0) * 57.0);\n    float d = hash(i.x + 1.0 + (i.y + 1.0) * 57.0);\n    \n    return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n}\n\nvec3 calculateSimpleFlare(vec2 uv) {\n    float flareIntensity = 0.0;\n    float eps = 0.001;\n    \n    // Make all lines start extremely small (dot-like)\n    float hLength = mix(0.05, 1.0, u_transitionAmount);  // Start at 5% of original size\n    float diagLength = mix(0.03, 1.0, u_transitionAmount); // Start even smaller for diagonals\n    \n    vec2 scaledUV = uv * vec2(hLength);\n    vec2 diagScaledUV = uv * vec2(diagLength);\n    \n    // Reduce initial intensity\n    float baseIntensity = mix(0.002, 0.01, u_transitionAmount);\n    float diagIntensity = mix(0.001, 0.005, u_transitionAmount);\n    \n    float horizontalFlare = baseIntensity / (abs(scaledUV.x) + eps);\n    horizontalFlare *= smoothstep(hLength, 0.0, abs(uv.y));\n    \n    float verticalFlare = baseIntensity / (abs(scaledUV.y) + eps);\n    verticalFlare *= smoothstep(hLength, 0.0, abs(uv.x));\n    \n    float diagonalFlare1 = diagIntensity / (abs(diagScaledUV.x + diagScaledUV.y) + eps);\n    float diagonalFlare2 = diagIntensity / (abs(diagScaledUV.x - diagScaledUV.y) + eps);\n    \n    diagonalFlare1 *= smoothstep(diagLength, 0.0, length(uv));\n    diagonalFlare2 *= smoothstep(diagLength, 0.0, length(uv));\n    \n    flareIntensity = horizontalFlare + verticalFlare + diagonalFlare1 + diagonalFlare2;\n    \n    // Tighter initial fade\n    float fadeStrength = mix(3.6, 1.8, u_transitionAmount);\n    flareIntensity *= exp(-length(uv) * fadeStrength);\n    \n    vec3 flareColor = vec3(1.0, 0.8, 0.6);\n    return flareColor * flareIntensity * mix(0.05, 0.15, u_transitionAmount);\n}\n\nvec3 calculateComplexFlare(vec2 uv, float flickerIntensity, float transitionAmount) {\n    float flareIntensity = 0.0;\n    float eps = 0.001;\n    \n    // Start extremely small\n    float baseLength = mix(0.05, 1.2, transitionAmount);\n    float diagBaseLength = mix(0.03, 1.2, transitionAmount);\n    \n    vec2 scaledUV = uv * vec2(baseLength);\n    vec2 diagScaledUV = uv * vec2(diagBaseLength);\n    \n    // Reduce initial intensities\n    float horizontalLength = 0.01 * (0.05 + transitionAmount * 1.75);\n    float verticalLength = 0.01 * (0.05 + transitionAmount * 1.75);\n    float diagonalLength = 0.0025 * (0.05 + transitionAmount * 1.75);\n    \n    float time = iTime;\n    vec2 stretchUV = scaledUV * 2.0;\n    vec2 diagStretchUV = diagScaledUV * 2.0;\n    \n    float dynHorizLength = horizontalLength * mix(0.2, 2.0 + transitionAmount * 2.0, noise2D(stretchUV * 2.0 + time));\n    float dynVertLength = verticalLength * mix(0.2, 2.0 + transitionAmount * 2.0, noise2D(stretchUV * 2.0 + time * 0.8));\n    float dynDiagLength1 = diagonalLength * mix(0.2, 2.0 + transitionAmount * 2.5, noise2D(diagStretchUV * 2.0 + time * 0.9));\n    float dynDiagLength2 = diagonalLength * mix(0.2, 2.0 + transitionAmount * 2.5, noise2D(diagStretchUV * 2.0 + time * 1.1));\n    \n    float pulse = sin(time * (2.0 + transitionAmount * 3.0)) * 0.5 + 0.5;\n    pulse *= transitionAmount;\n    \n    float horizontalFlare = dynHorizLength / (abs(scaledUV.x) + eps);\n    horizontalFlare *= smoothstep(baseLength, 0.0, abs(uv.y));\n    \n    float verticalFlare = dynVertLength / (abs(scaledUV.y) + eps);\n    verticalFlare *= smoothstep(baseLength, 0.0, abs(uv.x));\n    \n    float diagAttenuation = smoothstep(diagBaseLength * 1.5, 0.0, length(uv));\n    \n    float diagonalFlare1 = dynDiagLength1 / (abs(diagScaledUV.x + diagScaledUV.y) + eps);\n    diagonalFlare1 *= diagAttenuation;\n    \n    float diagonalFlare2 = dynDiagLength2 / (abs(diagScaledUV.x - diagScaledUV.y) + eps);\n    diagonalFlare2 *= diagAttenuation;\n    \n    flareIntensity = horizontalFlare + verticalFlare + diagonalFlare1 + diagonalFlare2;\n    \n    // Tighter initial fade\n    float distanceFade = exp(-length(uv) * (4.0 + noise2D(uv + time * 0.1)) * (2.0 - transitionAmount));\n    flareIntensity *= distanceFade * flickerIntensity;\n    \n    vec3 baseColor = vec3(1.0, 0.8, 0.6);\n    vec3 energizedColor = vec3(1.0, 0.7, 0.4);\n    vec3 flareColor = mix(baseColor, energizedColor, transitionAmount * pulse);\n    \n    return flareColor * flareIntensity * mix(0.05, 1.0, transitionAmount);\n}\n\nfloat smoothFlicker(float t, float transitionAmount) {\n    return mix(\n        noise(t * (3.0 + transitionAmount * 5.0)),\n        noise(t * (6.0 + transitionAmount * 8.0)),\n        0.5\n    ) * (0.8 + transitionAmount * 0.2) + 0.2;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    \n    float a = .707*iTime;\n    float s = sin(a);\n    float c = cos(a);\n    uv *= mat2(c, -s, s, c);\n  \tfloat t3 = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(uv.xy) + .07)) * 2.2;\n\tfloat si = sin(t3);\n\tfloat co = cos(t3);\n    mat2 ma = mat2(-co, si, si, co);\n    uv*=ma;\n\t\n     uv/=vec2(fract(log(length(uv.xy))+iTime*0.25));\n    uv *= 10.;\n     u_transitionAmount = abs(sin(iTime * 0.4));\n    \n \n    \n    vec2 simpleMovement = vec2(\n        sin(iTime * 1.5) * 0.5,\n        cos(iTime * 1.3) * 0.3\n    );\n    \n    vec2 complexMovement = vec2(\n        sin(iTime * 1.2) * 0.3,\n        sin(iTime * 1.2) * 0.3\n    );\n    \n    vec2 movement = mix(simpleMovement, complexMovement, u_transitionAmount);\n    uv += movement;\n   \n    float flickerIntensity = smoothFlicker(iTime, u_transitionAmount);\n    vec3 simpleFlare = calculateSimpleFlare(uv);\n    vec3 complexFlare = calculateComplexFlare(uv, flickerIntensity, u_transitionAmount);\n    \n    vec3 color = mix(simpleFlare, complexFlare, u_transitionAmount);\n    \n    vec3 simpleBg = vec3(0.05);\n    vec3 complexBg = vec3(0.05) + vec3(0.02 + u_transitionAmount * 0.05) * noise2D(uv + iTime * 0.1);\n    color += mix(simpleBg, complexBg, u_transitionAmount);\n    vec2 gv = fract(uv)-.5;\n    //vec2 id = floor(uv);\n    \n    float m = 0.;\n    float t = iTime;\n    \n    \n    for(float y = -1.;y<=1.;y++){\n        for(float x = -1.;x<=1.;x++){\n            vec2 offs = vec2(x,y);\n            float d = length(gv+offs);\n            float dist = length(uv-offs)*.3;\n            float r = mix(.3, 1.5, sin(dist-t)*.5+.5);\n            m = Xor(m, smoothstep(r, r*.9, d));  \n        }\n    }\n    col.rg = gv;\n    col += m;\n   col*= h2rgb(fragCoord.x/iResolution.x, tri_sin(iTime/20.0)*5.0)+color;\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}