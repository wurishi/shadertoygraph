{"ver":"0.1","info":{"id":"tlGXDK","date":"1583592367","viewed":133,"name":"March 3D","username":"spalmer","description":"simple debug ray marcher for testing out and visualizing different SDF functions","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["raymarch","sdf","distance"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// March 3D !\n\n// for development and debugging ray marching methods and\n// visualizing various experimental 3D signed distance field shape functions\n\n// for 1d version, see https://shadertoy.com/view/tlK3Ww\n// shows the marching process a bit clearer\n// for 2d version, see https://shadertoy.com/view/WlK3Wm\n// shape and march methodology testbed!\n\n#define BufferC   iChannel2\n\n// a simple fake ambient occlusion HACK based on distance near surface\nfloat FakeAO(vec3 p, vec3 n, float d)\n{\n    float ao = 1.; // ambient occlusion attenuation factor estimate\n    ao = clamp((sceneDistance(p + n * d) - sceneDistance(p)) / d, 0., 1.);\n    ao = sqrt(ao); //pow(ao, .5); //\n//    ao = 1. - (1.-ao) * (1.-ao); //ao *= ao; // revsqr works well, has nice falloff here but there's probably other ways to accomplish same thing\n    return ao;\n}\n// idk if I like it, it's a complete HACK and difficult to tune in a way that works well for the entire scene :(\n\n// FIXME soft fake AO is great, but\n// it makes the hard shadow edges look bad :(\n// TODO so I should really work on soft shadows!  see Fly Camera\n\n// p is fragment world pos, v is view dir (toward eye), n is surf normal, t is distance from p to camera plane\n// lv is dot(-L,v), albedo is diffuse/ambient color, datmo is (fake scaled) frag depth\n// returns premultiplied alpha color c of lit fragment\nvec3 sceneLight(vec3 p, vec3 v, vec3 n, float t, float lv, vec3 albedo, float datmo) //vec3 ro, vec3 rd, float t,\n{\n    float satten = 1.;\n    int nshadowsteps = IZERO + 32; //28; //24; //18; //\n    const float aodist = .02; // hard to tune btw\n    float ao = FakeAO(p, n, aodist); //1.; //\n    p += 2e-3 * (n + lightDir * max(dot(n, lightDir),0.)); // self-shadow bias hacks        \n    satten = ao\n        * rayshadow(p, lightDir, nshadowsteps)\n        ;\n\treturn LightingBlinnPhong(n, v, albedo, t, satten).rgb;\n}\n\n// raymarch to find termination depth when ray hits solid object\nfloat sceneDepth(vec3 ro, vec3 rd)\n{\n    int nsteps = 128; //160; //192; //256; //512; //32; // \n    nsteps += IZERO; // HACK prevent unwise compiler loop unrolling; can't do in Common because uniforms aren't directly accessible there\n    float d = raymarch(ro, rd, nsteps);\n    if (!(d >= 0.)) { \n        d = ro.y / -rd.y;\n        if (!(d >= 0.)) \n            d = -1.; //hatmo / depthscale; // TODO 'dome'\n    }\n    return d;\n}\n\nvec3 RenderScene(vec3 ro, vec3 rd, float time, out float d)\n{\n    float lv = dot(lightDir, rd); // factor of all fog and eye glare lighting\n    d = sceneDepth(ro, rd);\n    float datmo;\n    vec3 albedo, normal;\n    vec3 hitp = ro + rd * d;\n    sceneSurface(IZERO, hitp, d, albedo, normal, datmo);\n    vec3 c;\n    c = sceneLight(hitp, -rd, normal, d, lv, albedo, datmo);\n    c = sceneAtmosphere(c, ro, rd, d, lv, datmo);\n    return c;\n}\n\nvec2 StoQ(vec2 s, vec2 r)\n{\n\treturn (s + s - r) / r.y;\n}\n\nvec3 camRayDir(vec2 p, vec2 r)\n{\n    vec2 q = StoQ(p, r);\n    const float hfovy = pi/6.;\n    return viewRayDir(q, hfovy);\n}\n\n// idk about this \"run the ray marcher and lighting in a loop\" style of\n// SSAA antialiasing but it's better than nothing.\nvec3 Render(vec2 p, vec2 r, int ss, vec3 camera_pos, vec3 camera_dir)\n{\n    mat3 iview = cameraMatrix(camera_dir);\n    float iss = 1. / float(ss);\n    vec3 o = vec3(0);\n    for (int i = ss; i-- > 0; ) {\n        float f = float(i) * iss;\n        vec2 fc = p; // fragcoord subpixel\n        // golden angle phi factor\n        const float phi = (sqrt(5.)+1.)/2.;\n        fc += .7 * sqrt(f) * cossin(pi*phi*2.*(f+.1*iTime)); // vogel disc jitter\n        // could add some extra angular defocus using iResolution\n\t    vec3 ro, rd, vd;\n    \tvd = camRayDir(fc, r);\n\t    ro = camera_pos, rd = normalize(iview * vd);\n\t    float d;\n\t    o.rgb += RenderScene(ro, rd, iTime, d);\n    }\n    o.rgb *= iss;\n    return o;\n}\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    vec3 camera_pos = cameraPosition (BufferC)\n       , camera_dir = cameraDirection(BufferC);\n    vec3 c = Render(p, iResolution.xy, supersamples, camera_pos, camera_dir);\n    c = pow(c, vec3(1./2.2)); // to srgb gamut\n    c += vec3(.75/256. * rand(p)); // dither quantization bands\n    o = vec4(c, 1);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define IZERO min(0, iFrame)\n\nconst float pi = acos(-1.); //3.141592;\n// mandelbulb is too complex to handle with AA btw\nconst int supersamples = 1; //4; //6; //2; //8; // for SSAA antialiasing\nconst vec3 lightDir = normalize(vec3(0,.5,.866));\nconst float ambient = .3;\n// these aren't energy conserving and aren't PBR at all actually, just some HACK for now\nconst float specularity = 32.;\nconst vec3 specularColor = vec3(.3);\nconst vec3 diffuseColor = vec3(.7);\nconst float hatmo = 85000.; // air extinct distance\nconst float depthscale = 120.; //1200.; //12.; // fog exaggeration for horizon look mostly, affects sun also though\nconst vec3 csky = vec3(.2,.4,.6);\nconst vec3 objectpos = vec3(0,1,0); //0,1.5,0); //0,1.1,0); //0,2,0); //\n\n// buffer mapping logic, could wrap to subsequent rows\nint slotid(ivec2 loc) { return loc.x; }\nivec2 slotloc(int id) { return ivec2(id, 0); }\n\nvec4 loadValue(sampler2D buf, int slot_id)\n{\n    return texelFetch(buf, slotloc(slot_id), 0);\n}\n\n\n// channel allocations can't be done in Common,\n// as the defines for the iChannel# samplers have not yet been set.\n// but we can allocate the slots within BufferC at least.\n\nconst int slotCameraPosition = 0;\nconst int slotCameraForward  = 1;\nconst int slotDesiredForward = 2;\nconst int slotMouseOld       = 3; // iMouse from prior frame\nconst int slotCount          = 4;\n\nvec2 cossin(float r)\n{\n    return sin(vec2(r + .5*pi, r));\n}\n\n// cheap rotation transform on p by s=(cos(a),sin(a))\n/*void rot(inout vec2 p, vec2 s) \n{\n\tp = p * s.x + vec2(p.y, -p.x) * s.y;\n}*/ // then can rot(q.xz, cossin(a))\n// as matrix\n//mat2 mrot(vec2 s)\n//{\n//    return mat2(s.x, s.y, -s.y, s.x);\n//} // then can q.xz = mrot(cossin(a)) * q.xz;\n// idk yet which I will wind up using\n\nmat2 spin(float turns)\n{\n    vec2 _ = cossin(2.*pi*turns);\n    return mat2(_.x,-_.y, _.y, _.x);\n}\n//mat2(.866,-.5,.5,.866) * q.xz;\n\n// build a 3x3 camera orientation matrix given forward direction vector, assuming up is +Y\nmat3 cameraMatrix(vec3 camFwd)\n{\n    vec3 w = normalize(camFwd)\n       , u = normalize(cross(vec3(0., 1., 0.), w))\n       , v = normalize(cross(w, u));\n    return mat3(u, v, w);\n} // inverse view matrix\n// then just transform by pw = iview * pv;\n\n// implements inverse proj matrix transform (postclip to view dir)\n// with hfovy in radians\nvec3 viewRayDir(vec2 q, float hfovy)\n{\n\treturn normalize(vec3(q, 1./sin(hfovy)));\n//    return normalize(vec3(q, 2.)); // hard-coded to hfovy=60 degrees\n}\n/*\n// implements inverse view*proj matrix transform (postclip to world dir)\n// with hfovy in radians\nvec3 cameraRayDir(vec2 q\n                  //, mat3 view, vec3 cam_fwd\n                  , float hfovy)\n{\n//    mat3 M = cameraMatrix(cam_fwd);\n\treturn normalize(M * viewRayDir(q, hfovy));\n}\n\nvec3 lightRayDir(vec2 q, vec3 lgt_fwd)\n{\n    mat3 M = cameraMatrix(lgt_fwd);\n// FIXME perspective projection for light is wrong\n    return normalize(M * vec3(q, 20.));\n} // needs large near clip plane\n*/\n// refactored to Common; complicated by BufferC isn't available directly!\nvec3 cameraPosition(sampler2D BufC) \n{\n    return loadValue(BufC, slotCameraPosition).xyz;\n}\n\nvec3 cameraDirection(sampler2D BufC) \n{\n    return loadValue(BufC, slotCameraForward).xyz;\n}\n\n\n// see https://shadertoy.com/view/tdKSWW\nfloat rand(float x)\n{\n    // sine provides good decorrelation and as a bonus includes its own range reduction\n    // see https://stackoverflow.com/questions/12964279/whats-the-origin-of-this-glsl-rand-one-liner\n    x = sin(x*7.);\n    x *= 43708.8672;\n    x = fract(x);\n    return x;\n}\n\nfloat rand(vec2 x) { return rand(dot(x, vec2(11.07,10.71))); }\n\n\n// helpers\n\n// iq http://iquilezles.org/www/articles/smin/smin.htm\nfloat sminroot(float a, float b, float k)\n{\n\tfloat h = a - b;\n    return .5 * (a + b - sqrt(h * h + k));\n}\n// the sqrt version is apparently the best\n\n// delete h units around the origin in both directions, clamping result to zero if necessary\nfloat extrude(float p, float h) {\n\treturn p < -h ? p + h : p > h ? p - h : 0.;\n}\n// vector reject, but limited differently; converts a rod into a point for purposes of distance or normal calculation\n// note that this is almost the same code as dseg!  it's centered at 0 and signed, not 0..1 though, and doesn't do the final length/sqr\nvec2 extrude(vec2 p, vec2 h) { return p - h * clamp(dot(p, h) / dot(h,h), -1., 1.); }\nvec3 extrude(vec3 p, vec3 h) { return p - h * clamp(dot(p, h) / dot(h,h), -1., 1.); }\n\nvec2 latheY(vec3 p) { return vec2(length(p.xz), p.y); }\n\nvec2 lathe(vec2 p, vec2 b) {  // any axis\n\tfloat l = length(b);\n\tfloat y = dot(p, b) / l;\n\tfloat x = length(p - y / l * b);\n\treturn vec2(x, y);\n}\n// signed distance\n\n// bad corner SDF sharp box - FIXME roundbox is easy, see below\nfloat dbox(float p)\n{\n    return abs(p) - 1.;\n}\n\n\n// iq's, mostly\nfloat dseg(vec3 q, vec3 a, vec3 b)\n{\n    q -= a; b -= a;\n    return length(q - b * clamp(dot(q, b) / dot(b, b), 0., 1.));\n}\n\n// a double-ended rod using space deletion\nfloat drody(vec3 q)\n{\n    q.y = sign(q.y) * max(abs(q.y) - 1., 0.);\n    return length(q);\n}\n// a single-ended rod (one end anchored at zero)\nfloat drody1(vec3 q)\n{\n    q.y = max(abs(q.y - .5) - .5, 0.);\n    return length(q);\n}\nfloat drod(vec3 q)\n{\n    const float r = .1;\n    #if 1\n    // my space-deleting version is superior\n    q.y = extrude(q.y, 1.);\n    return length(q) - r;\n    #elif 1\n    const vec3 y = vec3(0, 1. - r, 0);\n    return length(extrude(q, y)) - r;\n    #elif 1\n    return drody(q); //drody1(q); //\n    #else\n    return dseg(q, -y, y) - r;\n    #endif\n}\n\n\nfloat dslab(vec3 q, vec3 n)\n{\n    return dbox(dot(q, n));\n}\n\nfloat dslab(vec3 q, vec3 n, float h)\n{\n    return abs(dot(q, n)) - h;\n}\n\nfloat dball(vec3 p)\n{\n    return length(p) - 1.;\n}\n// an example, probably wouldn't hard-code the radii like this.\n// in certain cases, the shape itself should be parameterized,\n// but since glsl doesn't let us curry functions,\n// it makes it difficult to convert back to a single-argument\n// sdf point query; must write a wrapper function or overload.\n// Or just send in all the arguments at point of query,\n// which is likely the scene function or some object's shape function anyway.\n// Where the customized arguments are not a problem.\n// But later in my scene switcher I treat them all the same signature.\nfloat dtorus(vec3 p)\n{\n    return length(vec2(length(p.xz) - .75, p.y)) - .25;\n}\n\nfloat dbox(vec3 q)\n{\n    float d = -3.4e38;\n    d = max(d, dslab(q, vec3(1, 0, 0)));\n    d = max(d, dslab(q, vec3(0, 1, 0)));\n    d = max(d, dslab(q, vec3(0, 0, 1)));\n    // should replace distance in corner voronoi regions; sometimes would rather leave them too-sharp though.\n    if (d >= 0.)\n        d = length(max(abs(q) - 1., 0.));\n    return d;\n}\n// actually if any two are past, it's an edge... but since we max anyway, handles all those cases\n//vec3 a = abs(q) - 1.; //if (any(lessThan(vec3(0.), a)))//if (dot(step(0., a), vec3(1)) >= 2.) //if (all(lessThan(vec3(0.), a))) //\n\n// gotta be a more elegant way to write this without scaling and unscaling FIXME\nfloat dboxround(vec3 q)\n{\n    const float r = .15, s = 1. - r;\n    return dbox(q / s) * s - r;\n}\n\n// mo better\nfloat dBox(vec3 q, vec3 e)\n{\n    q = abs(q) - e;\n    return any(lessThan(q, vec3(0))) ? max(q.x, max(q.y, q.z)) : length(q);\n}\n        \n/*float drhomb(vec2 p)\n{\n    p = abs(p);\n    const float r = sqrt(.5), R = sqrt(2.);\n    if (p.y < p.x - 1.5) return length(p - vec2(1.5,0));\n    if (p.x < p.y - 1.5) return length(p - vec2(0,1.5));\n    float d0 = dslab(p, vec2(r,r), r * 1.5); // - 0.07; //vec2(1,1)) * r; //(1. - r); //(R - 1.);\n    return d0;\n}*/\n\nfloat drhombdod(vec3 p)\n{\n    p = abs(p); // then sort so x is largest\n    if (p.x < p.y) p = p.yxz;\n    if (p.x < p.z) p = p.zxy;\n//    if (p.y < p.z) p = p.xzy; // order of smaller two doesn't matter much\n    const float \n      r = sqrt(.5)\n//  , poof = .0\n        ;\n    float\n      d0 = dslab(p, vec3(r,r,0), r * 1.5)\n    , d1 = dslab(p, vec3(r,0,r), r * 1.5)\n    , d2 = dslab(p, vec3(0,r,r), r * 1.5)\n    , maxslab = max(max(d0,d1), d2)\n    , dedge = dseg(p, vec3(1.5,0,0), vec3(.75));\n//    return dedge; \n//    return min(dedge - .01, maxslab);\n    if (maxslab > 0.) { // not inside\n        vec3 q = p - vec3(1.5,0,0); // relative to corner, easier to check planes with\n        if (q.x + 2.*q.z - q.y > 0. && q.x + 2.*q.y - q.z > 0.)\n        \treturn dedge;// - poof;\n    }\n    return maxslab;// - poof;\n}\n    // the planes' two verts are (1.5,0,0), (.75,.75,.75), and normal either (r,r,0) or (r,0,r)\n//  , R = sqrt(2.)\n\n// mandelbulb originally from https://shadertoy.com/view/3ttSWf\n// uses initial position as both the initial value and the per-iteration offset\n// iterates Q' = Q^Power + pos\nfloat dmandelbulb(vec3 pos) \n{\n    if (dot(pos,pos) >= 1.7*1.7) return length(pos)-1.3; // LOD sphere approx when query far away\n    vec3 z = pos; // treating pos as spinor, complex point, uh, quaternion, uh, dual thingy, I guess\n\tfloat dr = 1.;\n\tfloat r = 0.;\n    float Power = 8.; //2.; //7.; //4.; // 8 is the \"standard\" mandelbulb\n    const int niter = 5; //3; //7; //\n\tfor (int i = niter; i-- > 0; ) {\n\t\tr = length(z); // scalar part of logarithm\n\t\tif (r > 1.5) break;\n\n\t\t// convert to spherical coordinates = angular part of logarithm\n\t\tfloat theta = acos(z.z / r);\n\t\tfloat phi = atan(z.y, z.x);\n\n\t\t// multiply logarithm to exponentiate (scale and rotate) the spinor\n\t\tfloat zr = pow(r, Power);\n\t\ttheta = theta * Power;\n\t\tphi = phi * Power;\n\t\tdr = pow(r, Power - 1.) * Power * dr + 1.; // derivative too\n\n\t\t// convert back to cartesian coordinates = antilogarithm = e^spinor; loses the scalar part of quaternion?\n\t\tz = zr * vec3(cos(phi) * sin(theta), sin(phi) * sin(theta), cos(theta));\n\t\tz += pos;\n\t}\n\treturn .5 * log(r) * r / dr;\n}\n//    pos.z = 0.; // HACK extrude a 2D mandelbulb - meh, unbounded\n    //    + abs(pos.z)*.9 - .03\n\n// seems theoretically possible to determine in/out after N iterations\n// using one huge exponentiation, but would lose the benefit of\n// being able to estimate the distance.  need powertower of spinor,\n// maybe can exponentiate the exponentiated rotation\n\nfloat dtet(vec3 q)\n{\n    float d = 0.;\n    const float phi = (sqrt(5.)+1.)*.5;\n    vec3[4] ntet = vec3[4] (\n        normalize(vec3(-1,-1,-1))\n      , normalize(vec3(-1, 1, 1))\n      , normalize(vec3( 1,-1, 1))\n      , normalize(vec3( 1, 1,-1))\n    );\n    for (int i = ntet.length(); i-- > 0; ) {\n        float x = dot(q, ntet[i]);\n        if (x > d)\n            d = x;\n    }\n    return d - .5;\n}\n\n// simple super-sharp unit octahedron\nfloat doct(vec3 q)\n{\n    return (dot(abs(q), vec3(1)) - 1.) / sqrt(3.);\n}\n\nfloat dOctahedron(vec3 p, float s) // by Iq 2019\n{\n    p = abs(p);\n    float m = p.x + p.y + p.z - s;\n         if (3.*p.x < m) p = p.xyz;\n    else if (3.*p.y < m) p = p.yzx;\n    else if (3.*p.z < m) p = p.zxy;\n    else return m * sqrt(1./3.); //.57735027;    \n    float k = clamp(.5 * (p.z - p.y + s), 0., s); \n    return length(p - vec3(0,s-k,k));\n}\n\n// neat superprimitive from http://shadertoy.com/view/3lBGzt\nfloat dChamferBox(vec3 p, vec3 b, float c, float r) \n{\n    return dOctahedron(max(vec3(0), abs(p) + c + r - b), c) - r;\n}\n\nfloat dChamferBoxTest(vec3 p)\n{\n    return dChamferBox(p, vec3(1.), .5, .25); // a rounded cuboctahedron\n}\n\n// I got the idea from https://shadertoy.com/view/wdSGRG\n// I don't usually do icosahedrons for anything, hardly ever need it lol\n// anyway this one has non-eikonal gradients (edges too sharp)\n// so it's best bounded by a sphere lod\nfloat dicosa(vec3 q)\n{\n    float d = 0.; //3.4e38; //\n    const float phip1 = 1.5 + sqrt(1.25); //1.5 + sqrt(5.)*.5; //\n    const vec4 v = vec4(1,-1,0,phip1);\n\t// 10 slabs based off a tetrahedron\n\t// intersecting a wonky dodecahedron.\n\t// well it's one way to do it.\n    vec3[10] nicosa = vec3[10] (\n        normalize(v.yyy) //vec3(-1,-1,-1)) //\n      , normalize(v.yxx) //vec3(-1, 1, 1)) //\n      , normalize(v.xyx) //vec3( 1,-1, 1)) //\n      , normalize(v.xxy) //vec3( 1, 1,-1)) //\n      , normalize(v.wxz) //vec3(phip1, 1,0)) //\n      , normalize(v.wyz) //vec3(phip1,-1,0)) //\n      , normalize(v.zwx) //vec3(0,phip1, 1)) //\n      , normalize(v.zwy) //vec3(0,phip1,-1)) //\n      , normalize(v.xzw) //vec3( 1,0,phip1)) //\n      , normalize(v.yzw) //vec3(-1,0,phip1)) //\n    );\n    for (int i = nicosa.length(); i-- > 0; ) {\n        float x = abs(dot(q, nicosa[i]));\n        if (x > d)\n            d = x;\n    }\n    return d - .7071; //866; // cos(?)\n}\n\n#if 1\n// the main toy is at https://shadertoy.com/view/wsXBRj\nfloat dhalflink(vec3 p)\n{\n    vec2 r = sin(pi*.264 + vec2(.5*pi,0));\n    mat2 R = mat2(r.x, -r.y,\n                  r.y,  r.x);\n    vec3 f = p;\n    f.xy = R * f.xy;\n    const float rw = .04; // radius of wire\n    vec3 e = f;\n    float a = length(max(vec2(0), abs(e.yz) - vec2(.7,.0))) - rw;\n   \tfloat d = length(vec2(a, e.x)) - rw;\n    float g = -e.z;\n    return max(d, g);\n}\n\nfloat dlink(vec3 p)\n{\n    return min(dhalflink(p), dhalflink(vec3(-p.x, p.y, -p.z)));\n}\n\nfloat dlinksx4(vec3 p)\n{\n    p.xy += .5;\n    p.xy = fract(p.xy);\n    p.xy -= .5;\n    float d = 3.4e38;\n    for (float j = -.5; j <= .5 + 1e-3; j += 1.)\n    for (float i = -.5; i <= .5 + 1e-3; i += 1.)\n        d = min(d, dlink(p + vec3(i,j,0)));\n    return d;\n}\n\nfloat dchainlink(vec3 p)\n{\n    const float tiling = 4.;\n    float dlo = length(max(vec3(0), abs(p - vec3(0,0,0)) - vec3(3e38,1,0))) - .1;\n\tif (dlo > .5) return dlo - .01;\n    const float s = sqrt(.5) * tiling;\n    p = tiling * p;\n    float d = dlinksx4(p);\n    d /= tiling;\n    return max(d, dlo);\n}\n#endif\n\n// see https://shadertoy.com/view/XsdBW8 single-coil helicoid\nfloat dhelicoidx(vec3 q)\n{\n   #if 1\n    if (dot(q.yz,q.yz) > 1.5) return length(q.yz) - 1.01; // LOD bound cylinder\n    float a = fract(q.x/2./pi + .25); // /2./pi);\n    if (a > .5) --a;\n    q.x = a;\n    vec2 s = sin(vec2(.5*pi,0) - 2.*pi*a);\n    mat2 m = mat2(s.x,-s.y,s.y,s.x);\n    //return drody1(vec3(0., m * q.yz));\n    q.yz = m * q.yz;\n    return length(vec2(max(abs(q.y - .5) - .5, 0.), q.z));\n// #else\n//    // garbage\n//    return max(length(q.yz)-1.,\n//               (max(0.,sin(atan(q.y,q.z)-q.x))\n//                    *min(1.,length(q.yz))\n//\t\t\t\t\t) - .05);\n   #endif\n} // FIXME I have a feeling that the problem is this:\n// fn is presently taking distance to the rod swept and rotated along the helical path\n// to the same x as the query; what we need is to augment that with also\n// taking distance to the rod that's pointing in our yz direction, which is closest\n// to query point laterally, so we can estimate the lateral distance better.\n// Presently I think radially, it's perfect, but oversteps laterally along the x axis.\n\nfloat dhelix(vec3 q)\n{\n #if 1 \n    // join 2 helicoids - not efficient but tests the helicoids\n    return min(dhelicoidx(q), dhelicoidx(q - vec3(pi,0,0)));\n #else\n    // Fabrice's https://shadertoy.com/view/wdXBDs is actually a double-coil\n    return max(length(q.yz)-1.,\n               abs(sin(atan(q.y,q.z)-q.x)\n                    *min(1.,length(q.yz))\n\t\t\t\t\t) - .0); // fabrice helix\n #endif\n}\n// found this in Mist at https://shadertoy.com/view/tdBGWD\n// it's a nifty infinitely extruded jack/axis cross shape\n// with each axis here hard coded to 1-unit square cross section\nfloat dsc(vec3 p) \n{\n\tp = abs(p);\n\tp = max(p, p.yzx);\n\treturn min(p.x, min(p.y, p.z)) - 1.;\n}\n// another cross, same thing but with round cross sections\nfloat drc(vec3 p)\n{\n    return min(length(p.xy), min(length(p.yz), length(p.zx))) - 1.;\n}\n// this can be generalized to extrude\n// any 2D shape into a 3D cross\n// or subset of the axes.\n// would need a macro to do such \n// generic programming in glsl!\n// main model selector\nfloat shape(vec3 q)\n{\n    //q.xz = mat2(1,-1,1,1)*sqrt(.5) * q.xz;\n    q.xz = spin(1./12.) * q.xz;\n    //return max(drhombdod(q), dbox(q) - .5); // perfect fit\n    return\n        //dsc\n        //drc\n        //dball\n        //dtorus\n        //drod\n        //dbox\n        //dboxround\n        //drhombdod\n        //dtet\n        //doct\n        //dOctahedron\n        dChamferBoxTest\n        //dicosa\n        //dmandelbulb\n        //dchainlink\n        //dhelicoidx\n        //dhelix\n        (q)\n      //   - .04 // HACK poof to test gradients away from surface, eikonal-ness of field\n        ;\n}\n\n// show main model at origin, over a plane\nfloat sceneDistance(vec3 q)\n{\n    return min(shape(q - objectpos), q.y);\n}\n\n// hey, it's a way to do antialiasing on normal and such\n// here in Common tab without reliance on some external factor\n// such as camera distance.  But this is really a computation...\n// an exchange of info between threads, derivatives vs. fragCoord.  \n// So not free.\n//float AntialiasPosition(vec3 q)\n//{ // idk how best to say it without being repetitive at all; all these seem sub-optimal somehow but will all probably be about the same speed\n//    return fwidth(q.x) + fwidth(q.y) + fwidth(q.z); //dot(vec3(1),fwidth(q)); //length(fwidth(q)); //\n//} // length introduces an unnecessary sqrt that is probably not even wanted\n// at this point two functions use it; hopefully compiler will combine\n// the multiple calls with same argument when optimizing. FIXME\n// I got tired of worrying about artifacts due to use of auto-derivatives\n// in situations where sdf has discontinuities; better to not worry about it here\n// in this shader since it's mostly for testing the SDFs themselves.\n// Not the antialiasing techniques for blurring the normal sampling and stuff.\n\n// FIXME should depend on distance; not be fixed\nconst float normal_precision = 0.002;\n// TODO may merge with sceneMaterial so it can adjust the normal per-material\n// TODO btw on blog page iq mentions using IZERO and a loop over an array to\n// prevent compiler inlining 4 loose calls, saving much compilation time.\n#if 1\n// iq's looped simplex gradient, excellent! loop idea by Thomas Hooper\n// https://iquilezles.org/articles/normalsSDF \"An Important Implementation Detail\"\n// I really did a number on the bitshifting though!\n// requires access to a uniform integer zero for proper looping\nvec3 sceneNormal(vec3 q, float blur, int uniformzero)\n{\n    float h = normal_precision\n        * sqrt(1./3.) // .5773\n        * (1. + 128.*blur) // antialiasing, band limit TODO tuning!! maybe need iResolution?\n        ;\n    vec3 n = vec3(0);\n    int i = 0;\n    i = uniformzero; //i = IZERO; //\n    for (; i < 4; ++i) {\n        vec3 e = vec3((ivec3(i+3, i, i+i)&2) - 1);\n        n += sceneDistance(q + e * h) * e;\n    }\n    return normalize(n);\n}\n    // really h shouldn't be constant but should depend on the distance to camera etc.\n    // so... not const \n        //vec3 e = vec3(((i+3)>>1)&1, (i>>1)&1, i&1) * 2. - 1.;\n        //vec3 e = vec3(ivec3((i+3)>>1)&1, (i>>1)&1, i&1) * 2 - 1);\n    // since normalizing, pretty much any effort toward dividing the differences\n    // is mostly wasted, and the small improvement in precision doesn't make up for it.\n    // just let normalize handle it.\n        \t// * h; // normalizing later anyway, don't bother\n\n#elif 1\n// iq's simplex gradient, super nice\n// I took it from the mandelbulb https://shadertoy.com/view/ltfSWn\n// but there's probably a more definitive source page\n// such as https://iquilezles.org/articles/normalsSDF\n// anyway I already rearranged it and reformatted\n// FIXME epsilon got hardcoded in the process :( to match my other kludge\nvec3 sceneNormal(vec3 q, float blur, int uniformzero)\n{\n    vec2 e = normal_precision*.5773*vec2(1,-1) * (1. + blur);\n    //.25* // normalizing later anyway, don't bother\n    return normalize(e.xyy * sceneDistance(q + e.xyy) + \n\t\t\t\t\t e.yyx * sceneDistance(q + e.yyx) + \n\t\t\t\t\t e.yxy * sceneDistance(q + e.yxy) + \n\t\t\t\t\t e.xxx * sceneDistance(q + e.xxx));\n}\n\n#elif 0\n// WIP looped forward difference gradient - FIXME borked :( probably not great anyway\n\nvec3 sceneNormal(vec3 p, float blur, int uniformzero)\n{\n    vec3 n = vec3(0);\n    for (int i = uniformzero; i < 4; ++i) { \n        vec3 h = vec3(-1), o = p;\n        if (i > 0) { h -= h; h[i-1] = blur; o += h; }\n        n += h * sceneDistance(o);\n    }\n    return normalize(n); // / blur); //\n} \n\n#else\n// mine, standard forward difference gradient, unbalanced but simple and fast\n\nvec3 sceneNormal(vec3 q, float blur, int uniformzero)\n{\n    vec2 eps = vec2(normal_precision, 0) * (1. + blur); // not too small, beware inaccuracies in far distance\n    // TODO accumulate into array first using uniformzero loop index\n    vec3 n = vec3( // forward is fine if eps is small enough\n       sceneDistance(q + eps.xyy),\n       sceneDistance(q + eps.yxy),\n       sceneDistance(q + eps.yyx)) - sceneDistance(q);\n   return normalize(n);\n}\n\n// TODO #else naive central difference gradient? meh.\n// actually should just choose the best one and move the rest\n// to some gradient experimentation toy\n\n#endif\n\n//struct Material {}; // if material gets any more complicated, should just return the entire material; currently just albedo\n\nvec3 sceneMaterial(vec3 q, float blur)\n{\n    // simple grey plastic is fine for the object\n    vec3 albedo = diffuseColor;\n    // plane sinegrid\n\tif (q.y <= 1e-2)\n        albedo = vec3(.4,.5,.3)\n        \t+ .1 * sin(q.x) * sin(q.z)\n        \t\t* exp2(-1.2 * blur)\n        \t;\n   \treturn albedo;\n}\n\n\nvoid sceneSurface(int uniformzero\n      , vec3 phit, inout float t\n      , out vec3 albedo, out vec3 n, out float datmo)\n{\n    float blur = 0.; // AntialiasPosition(phit);\n    bool is_hit = (t >= 0.);\n    float dsky = hatmo / depthscale;\n    datmo = t;\n    bool sky = !is_hit || t > dsky;\n    albedo = vec3(1);\n    if (sky) {\n        datmo = hatmo; //dsky; //\n        albedo = vec3(0);\n        n *= -0.; //*rd;\n        t = dsky; //hatmo; //8.5e4;// / depthscale; // / 1200.; // decorrect for exaggeration\n        // TODO sky *dome* - not working :(\n      //  t *= 1. - .975*exp2(-35.*max(0., rd.y));\n     //   t = dsky; //datmo / depthscale; // decorrect for exaggeration\n    } else { // hit sdf, so render it over bg, lit\n\t\tn = sceneNormal(phit, blur, uniformzero);\n      \talbedo = sceneMaterial(phit, blur); // HACK material is only albedo atm\n    \t// t sent for future reflection/shadow ray generation\n    \tdatmo *= depthscale;\n    }\n    //if (!isHit(t)) t = datmo; // HACK maybe sceneDraw should handle sky misses?\n}\n\n\nvec3 sceneAtmosphere(vec3 c, vec3 ro, vec3 rd, float t, float lv, float datmo)\n{\n    datmo = min(datmo, hatmo);\n//    datmo = max(0., datmo);\n//    t = max(t, 0.); // wtf? HACK\n    c *= exp2(-7e-5*vec3(1.,2.,3.)*datmo); // extinction\n    float afog = mix(pow(max(lv * .5 + .5, 0.), 2.), 1., .875);\n    vec3 cfog = 1. - exp2(-1e-4*csky*datmo);\n    vec3 ad = abs(rd);\n    c += afog\n        * cfog; // inscatter - crappy phase function tho FIXME kind of vaguely rayleigh-like\n    c += (1.-exp2(-4e-2*vec3(.22,.15,.08)*datmo)) * pow(max(lv, 0.), 8.) * .36; // fake mie\n    return c;\n}\n\n\n// for an explanation, see Pyramid Field https://shadertoy.com/view/3ld3Dl\n// TODO may make this toy the definitive one with the documentation.\n\nstruct Ray3 \n{\n    vec3 o, d; // origin and direction vectors\n};\n\nRay3 queryRay;\n\nvec3 queryAt(float t) \n{\n    return queryRay.o + queryRay.d * t;\n}\n\n// the parametric function of the ray;\n// given global queryRay and given index along it,\n// compute position along ray p and return sdf(p)\nfloat sdfQueryRay(float t)\n{\n    return sceneDistance(queryAt(t));\n}\n\n// a single iteration of a linear bracketed root finder algorithm aka regula falsi;\n// Linearly interpolate the position of a root between two known values on either side\n// returns mix factor to use between original two points\n// v0 = sdf(x0) and v1 = sdf(x1), then xRoot ~= mix(x0, x1, FalsePositionEstimate(v0, v1))\n// x0 and x1 *must* bracket the root, so v0 and v1 must have opposite signs or be zero.\n// takes two samples from field and returns interpolation factor between them where zero is likely to be found\nfloat FalsePositionEstimate(float v0, float v1)\n{\n\tfloat l = v0 - v1; \n\treturn abs(l) < 1e-24 ? .5 : v0 / l;\n}\n\nvec2 sdfqrFalsePositionStep(inout float x0, inout float x1, inout float v0, inout float v1)\n{\n    float u = FalsePositionEstimate(v0, v1);\n    float x = mix(x0, x1, u); // new guess\n    float d = sdfQueryRay(x); // NOTE function is hardcoded.  maybe I can make a small enough part of this into a macro.\n\tif (d < 0. == v0 < 0.)\n        v0 = d, x0 = x;\n\telse\n        v1 = d, x1 = x;\n    return vec2(x, d);\n}\n// result.x should then be between input x0 and x1, and closer than either.\n// result.y is the function's value at the new point result.x\n// on exit, either x0 or x1 will now contain the return value.x, and the extent should have shrunk.\n// post-result bracketing situation *should* be an improvement.\n// at some point you can stop calling it, and just use the midpoint of the remaining bracket.\n\n// now all that remains is to call it, perhaps repeatedly, until satisfied\n\n// usually even a few iterations does wonders.\nfloat sdfqrFalsePosition(inout float p0, inout float p1, inout float v0, inout float v1, int niter, float tol)\n{\n\tfloat x;\n    for (int i = niter; i-- > 0; ) {\n        vec2 r = sdfqrFalsePositionStep(p0, p1, v0, v1);\n        x = r.x;\n        if (abs(r.y) < tol) break;\n    }\n    return x;\n}\n\n// t is ray index into queryRay\n// d should be sdfQueryAt(t)\n// ot is t at prior step\n// od is d at prior step aka sdfQueryAt(ot)\n// r is a scale factor relating progress along t to the d value; usually somewhere around .9 works well for sdfs.\n// a is a minimum step size and determines the fine structure scale where details won't be skipped.\n// yes I realize these names are horrible, but I'm just getting this working.\nvoid sdfQueryRayStep(inout float t, inout float d, inout float ot, inout float od, float i, float r, float a)\n{\n    float t0 = t, d0 = d; //, ot0 = ot, od0 = od; // copy input values for later\n    float p = .5 * d / od;\n    float s = 1e-4 + d * r; /* * (.5\n\t\t+ .25 * p // \n\t\t+ .25 * i // overestimate more as we run out of iterations (i almost 1)\n\t\t);*/\n    // t += max(s, a); // TODO a better function of the available data\n    t += d; // * rate;\n    d = sdfQueryRay(t);\n    ot = t0, od = d0;\n}\n\n// FIXME this is surprisingly brittle for how \"advanced\" it is.\n// I think it's because due to how it works by hunting an actual zero crossing,\n// not just getting sufficiently near the surface, it's prone to \n// either overshooting the surface so badly it skips thin shells and silhouette edges,\n// or it undermarches and never reaches the surface, which is considered a miss.\n// There are some very robust methods on shadertoy here that I should seriously\n// manage to incorporate somehow, which is a major point of this toy.\nfloat sdfqrRayMarch(vec3 ro, vec3 rd, float rate, int iter)\n{\n    queryRay.o = ro, queryRay.d = rd;\n    float rit = 1. / float(iter);\n    float ret = -1.; // \"missed\". see isMiss.\n    float t = .0, t1 = -1e-9, d = sdfQueryRay(t);\n    float d1 = d + 1e-9; // d1 is just a wild guess at the value of sdfQueryRay(t1); shouldn't matter a whole lot but does influence the size of the first step, probably.\n    do {\n        // TODO someone had a really good hack that prevented overstepping past thin shells - find it!\n        /*if (d < .0) {\n        \tt = sdfqrFalsePosition(t, t1, d, d1, 4, 5e-4);\n            ret = t;\n            break;\n        }*/\n        // Shane reminded me of this trick recently; idk who I first saw do it.\n        // Works out almost as good as regula falsi, perhaps even better!  Certainly simpler.\n        if (abs(d) < 2e-3) { // FIXME configurable tolerance, argument\n            ret = t; break;\n        }\n        sdfQueryRayStep(t, d, t1, d1, float(iter)*rit, rate, 9e-4); //1e-3); //5e-4); //\n    } while (iter-- > 0);\n    return ret;\n}\n\n\n// TODO need tmax arg, limit max trace distance; really, lo, hi range would be nice\nfloat raymarch(vec3 ro, vec3 rd, int nsteps)\n{\n    float spd = .975; //.8; // .8 is far too slow but can help w busted sdf's\n    float t = sdfqrRayMarch(ro, rd, spd, nsteps);\n\treturn t;\n}\n\nfloat rayshadow(vec3 ro, vec3 rd, int nsteps)\n{\n    //return 1.; // HACK disable\n    if (rd.y <= 0. || ro.y <= 0.) return 1.;\n    float t = sdfqrRayMarch(ro, rd, 1.25, nsteps);\n\treturn t >= 0. ? 0. : 1.; // hard shadows atten\n}\n\n\n\n// basic plasticky BRDF - not going for photoreal here\nvec4 LightingBlinnPhong(vec3 n, vec3 v, vec3 albedo, float d, float satten)\n{\n    float amb = clamp(0.5 + 0.5 * n.y, 0., 1.); // less coming from down; makes hemispherical ambient\n    float lv = clamp(dot(lightDir, n) * satten, 0., 1.); // n dot l\n    vec3 h = normalize(v + lightDir);\n\n\tfloat dl = mix(lv, amb, ambient); // how much diffuse+ambient lighting\n\tvec3 c = dl * albedo;\n    \n    float spec = pow(clamp(dot(h, n), 0., 1.), specularity);\n    spec *= lv * specularity * .038; // should mul by n*l and power, divide by 8*pi\n\tc += spec * specularColor;\n    return vec4(c, 1);\n}\n\n\n// rest the lighting is in Image tab currently and needs cleaned up before moving to Common\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Debug Camera from https://shadertoy.com/view/WlVGDh\n\n// BufferC controls the state, mostly the camera location+direction\n// but wound up needing old mouse state and, for smoothing,\n// the desired facing direction.\n\n#define BufferC   iChannel2\n#define Keyboard  iChannel3\n\nconst float moverate = .5;\nconst float turnratemouse = .02;\nconst float turnratekbd = 2.6;\n\n\nvec3 desiredDirection() \n{\n    return loadValue(BufferC, slotDesiredForward).xyz;\n}\n\nvec4 oldMouse() \n{\n    return loadValue(BufferC, slotMouseOld);\n}\n\nbool asleep(vec2 mouse) // in shadertoy.com shader browser thumbnail? \n{\n    return dot(mouse, mouse) <= 2.;\n}\n\n// read keyboard key, return 1.0 if down\n// ultimately want to do differencing of negatives from positives\nfloat key(int vk) // key down state value as a float fraction\n{\n    float s = loadValue(Keyboard, vk).x; // read keyboard key state from texture\n    return step(.5, s); // test if down\n}\n\nconst int\n  KEY_SPACE = 32\n, KEY_CTRL  = 17 // DO NOT use control generally as when held, bad things can happen to our window or tab\n, KEY_SHIFT = 16\n, KEY_C     = 67\n, KEY_W     = 87\n, KEY_A     = 65\n, KEY_S     = 83\n, KEY_D     = 68\n// in DVORAK it's ,AOE, in AZERTY it's ZQSD\n, KEY_Z     = 90 // but Image tab is using it for showing depth FIXME\n, KEY_Q     = 81\n, KEY_O     = 79\n, KEY_E     = 69\n, KEY_COMMA = 188 //188 JS, 44 ASCII\n, KEY_X     = 88 // used by Image tab; should keys move to Common tab?\n#if 0 \n    // AZERTY ZQSD\n, KEY_FW    = KEY_Z\n, KEY_LF    = KEY_Q\n, KEY_BW    = KEY_S\n, KEY_RT    = KEY_D\n#elif 0\n    // DVORAK ,AOE\n, KEY_FW    = KEY_COMMA\n, KEY_LF    = KEY_A\n, KEY_BW    = KEY_O\n, KEY_RT    = KEY_E\n#else\n    // QWERTY\n, KEY_FW    = KEY_W\n, KEY_LF    = KEY_A\n, KEY_BW    = KEY_S\n, KEY_RT    = KEY_D\n#endif\n, KEY_UW    = KEY_SPACE\n, KEY_DW    = KEY_C  // anything but control!\n, KEY_LEFT  = 37 // arrow keys for lookaround\n, KEY_RIGHT = 39\n, KEY_UP    = 38\n, KEY_DOWN  = 40\n;\n\nvec3 cameraMovement(bool shift)\n{\n    vec3 campos = cameraPosition(BufferC);\n    float\n      fw = key(KEY_FW)\n    , bw = key(KEY_BW)\n    , lf = key(KEY_LF)\n    , rt = key(KEY_RT)\n    , up = key(KEY_UW)\n    , dn = key(KEY_DW);\n    vec3 camfwd = cameraDirection(BufferC);\n    //if (asleep(iMouse.xy)) fw = .5; // automate forward\n    if (asleep(iMouse.xy)) campos = -4. * camfwd + objectpos; // orbit // * objectscale\n    mat3 camori = cameraMatrix(camfwd);\n    vec3 cammove = vec3(rt-lf, up-dn, fw-bw) * iTimeDelta * moverate;\n    if (shift) cammove *= 4.0; // shift key for speed boost\n    campos += camori * cammove;\n    const float camradius = .04;\n    vec3 normal = sceneNormal(campos, 1e-7, IZERO);\n    float cdist = sceneDistance(campos);\n    campos += normal * -min(cdist - camradius, .0); // collision with sdf\n    return campos;\n}\n\nvec3 cameraSteering(bool shift)\n{\n    vec3 desiredRot = desiredDirection();\n    vec4 oMouse = oldMouse();\n    bool lmb = iMouse.z >= 0.;\n    bool olmb = oMouse.z >= 0.;\n    float shiftmod = shift ? .5 : 1.; // shift actually slows rotation down\n    vec2 orbit = vec2(0);\n    if (asleep(iMouse.xy)) {\n    \torbit = vec2(.15*iTimeDelta, 0);   // slow spin\n\t} else {\n    \tif (lmb && olmb) {\n\t        vec2 m = iMouse.xy - oMouse.xy;\n    \t    orbit += m * turnratemouse * shiftmod;\n    \t} \n    \t{\n    \t\tfloat aL = key(KEY_LEFT), aR = key(KEY_RIGHT), aU = key(KEY_UP), aD = key(KEY_DOWN);\n\t        vec2 m = vec2(aR - aL, aU - aD);\n    \t    orbit += m * iTimeDelta * turnratekbd * shiftmod;\n        }\n    }\n    if (dot(orbit,orbit) != 0.) {\n        // TODO cossin is too nifty not to use\n        //rot(desiredRot.xz, vec2(cos(orbit.x),sin(orbit.x)));\n        desiredRot.xz *= spin(orbit.x*-.5/pi); // *= basically transposes the direction, reversing angle\n        vec2 vr = vec2(1.,desiredRot.y);\n        //rot(vr, vec2(cos(orbit.y),-sin(orbit.y)));\n        vr *= spin(orbit.y*.5/pi);\n        desiredRot.xz *= max(1e-1f, vr.x); // do not flip signs here!\n        desiredRot.y = vr.y;\n  \t\tdesiredRot = normalize(desiredRot);\n    }\n    return desiredRot;\n}\n\n// smoothing filter\nvec3 cameraSmoothing()\n{\n    vec3 camfwd = cameraDirection(BufferC);\n    vec3 desiredFwd = desiredDirection();\n    camfwd = normalize(mix(desiredFwd, camfwd, exp2(-64.*iTimeDelta)));\n    return camfwd;\n}\n\n// a debugging fly camera using keyboard WASD + mouse + C/space\n// stores camera position,aim,etc. into c as a \n// color coded vector suitable for output to buffer\nvoid debugFlyCamera(out vec4 c, vec2 p)\n{    \n    ivec2 ip = ivec2(p);\n    c = loadValue(BufferC, ip.x); // passthru by default\n    bool shift = key(KEY_SHIFT) > .5;\n    bool init = iFrame < 3; //iFrame == 0; // thumbnail issues\n    switch (slotid(ip)) {\n      case slotCameraPosition: {\n \t    c.xyz = init ? vec3(.0,2.1,-3.5) : cameraMovement(shift);            \n        break;\n      }\n      case slotCameraForward: {\n        c.xyz = init ? vec3(0.,0.,1.) : cameraSmoothing();\n        break;\n      }\n      case slotDesiredForward: {\n        c.xyz = init ? vec3(0.,0.,1.) : cameraSteering(shift);\n        break;\n      }\n      case slotMouseOld: {\n        c = iMouse;\n        break;\n      }\n      default:\n        break;\n    }\n}\n\n// output to Buffer C\nvoid mainImage(out vec4 c, vec2 p)\n{    \n    if (p.y >= 1. && int(p.x) >= slotCount) discard;\n    //if (p.y >= 1. || p.x >= float(slotCount)) return; // ignore most pixels - otherwise using an entire buffer is really bad\n    debugFlyCamera(c, p);\n}\n\n","name":"Buffer C","description":"","type":"buffer"}]}