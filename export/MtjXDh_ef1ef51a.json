{"ver":"0.1","info":{"id":"MtjXDh","date":"1443424164","viewed":930,"name":"3D kissing-Schottky Orbit-sphere","username":"soma_arc","description":"We use a new distance estimation(DE) to render the orbit-spheres of a kissing-Schottky group.\nThis \"kissing-Schottky DE\" algorithm is devised by Kazushi Ahara, Meiji university.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["fractal","kleiniangroups"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"/*\nCreated by soma_arc, Kazushi Ahara - 2015\nThis work is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported.\n*/\n\nconst float PI = 3.14159265;\nconst float angle = 60.0;\nconst float fov = angle * 0.5 * PI / 180.0;\nconst vec3  cPos = vec3(0.0, 0.0, 500.0);\nconst vec3 lightDir = vec3(-0.577, 0.577, 0.577);\n\nconst vec3 spherePos1 = vec3(300, 300, 0);\nconst vec3 spherePos2 = vec3(300, -300, 0);\nconst vec3 spherePos3 = vec3(-300, 300, 0);\nconst vec3 spherePos4 = vec3(-300, -300, 0);\nconst vec3 spherePos5 = vec3(0, 0, 424.26);\nconst vec3 spherePos6 = vec3(0, 0, -424.26);\nconst float sphereR = 300.;\n\n\n\nvec3 rotate(vec3 p, float angle, vec3 axis){\n  vec3 a = normalize(axis);\n  float s = sin(angle);\n  float c = cos(angle);\n  float r = 1.0 - c;\n  mat3 m = mat3(\n      a.x * a.x * r + c,\n      a.y * a.x * r + a.z * s,\n      a.z * a.x * r - a.y * s,\n      a.x * a.y * r - a.z * s,\n      a.y * a.y * r + c,\n      a.z * a.y * r + a.x * s,\n      a.x * a.z * r + a.y * s,\n      a.y * a.z * r - a.x * s,\n      a.z * a.z * r + c\n  );\n  return m * p;\n}\n\nvec3 sphereInverse(vec3 pos, vec3 circlePos, float circleR){\n  return ((pos - circlePos) * circleR * circleR)/(distance(pos, circlePos) * distance(pos, circlePos) ) + circlePos;\n}\n\nconst int ITERATIONS = 30;\nfloat loopNum = 0.;\nconst vec3 ROTATION = vec3(1.0, 0.5, 0.5);\nconst float r2 = sphereR * sphereR;\nfloat DE(vec3 pos){\n  pos = rotate(pos, radians(iTime * 10.0), ROTATION);\n  float dr = 1.;\n  bool cont = false;\n  for(int i = 0 ; i < ITERATIONS ; i++){\n    cont = false;\n    if(distance(pos, spherePos1) < sphereR){\n      vec3 diff = (pos - spherePos1);\n      dr *= r2 / dot(diff, diff);\n      pos = sphereInverse(pos, spherePos1, sphereR);\n      cont = true;\n      loopNum++;\n    }else if(distance(pos, spherePos2) < sphereR){\n        vec3 diff = (pos- spherePos2);\n         dr *= r2 / dot(diff, diff);\n      pos = sphereInverse(pos, spherePos2, sphereR);\n      cont = true;\n      loopNum++;\n    }else if(distance(pos, spherePos3) < sphereR){\n        vec3 diff = (pos- spherePos3);\n         dr *= r2 / dot(diff, diff);\n      pos = sphereInverse(pos, spherePos3, sphereR);\n      cont = true;\n      loopNum++;\n    }else if(distance(pos, spherePos4) < sphereR){\n        vec3 diff = (pos- spherePos4);\n         dr *= r2 / dot(diff, diff);\n      pos = sphereInverse(pos, spherePos4, sphereR);\n      cont = true;\n      loopNum++;\n    }else if(distance(pos, spherePos5) < sphereR){\n        vec3 diff = (pos- spherePos5);\n         dr *= r2 / dot(diff, diff);\n      pos = sphereInverse(pos, spherePos5, sphereR);\n      cont = true;\n      loopNum++;\n    }else if(distance(pos, spherePos6) < sphereR){\n        vec3 diff = (pos- spherePos6);\n         dr *= r2 / dot(diff, diff);\n      pos = sphereInverse(pos, spherePos6, sphereR);\n      cont = true;\n      loopNum++;\n    }\n    if(cont == false) break;\n  }\n//return (length(pos) - 300.) / abs(dr) * 0.08;\n    return (length(pos) - 125.) / abs(dr) * 0.08;\n}\n\nvec3 getNormal(vec3 p){\n  float d = 0.01;\n  return normalize(vec3(\n      DE(p + vec3(  d, 0.0, 0.0)) - DE(p + vec3( -d, 0.0, 0.0)),\n      DE(p + vec3(0.0,   d, 0.0)) - DE(p + vec3(0.0,  -d, 0.0)),\n      DE(p + vec3(0.0, 0.0,   d)) - DE(p + vec3(0.0, 0.0,  -d))\n  ));\n}\n\nconst int MARCHING_LOOP = 800;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n  vec3 ray = normalize(vec3(sin(fov) * p.x, sin(fov) * p.y, -cos(fov)));\n\n  float dist;\n  float rLen = 0.0;\n  vec3  rPos = cPos;\n\n  float numMarch = 0.;\n  for(int i = 0; i < MARCHING_LOOP; i++){\n    dist = DE(rPos);\n    rLen += dist;\n    rPos = cPos + ray * rLen;\n    numMarch++;\n    if(dist < 0.01) break;\n  }\n\n  if(dist < 0.01){\n    vec3 normal = getNormal(rPos);\n    float diff = clamp(dot(lightDir, normal), 0.1, 1.0);        \n    fragColor = vec4(vec3(diff), 1.0);\n  }else{\n    fragColor = vec4(0.,0.,0.,1.);\n  }\n}\n\n","name":"Image","description":"","type":"image"}]}