{"ver":"0.1","info":{"id":"3dyXDd","date":"1575310984","viewed":57,"name":"Minimal PBR PT Demo","username":"saidwho12","description":"I had this sitting in my shader collection since 2019 as a small PBR PT demo.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["test","demo","lambert","pbr","pt","ggx","heitz","eric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{    \n    const float exposure = 1.5;\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = texture(iChannel0, uv).rgb * exposure;\n    \n\tfragColor.rgb = col;\n    \n    // Vignette effect\n    //fragColor.rgb *= 0.05 + 0.95 * pow( clamp(16.0 * uv.x * uv.y * (1.0-uv.x) * (1.0-uv.y),0.,1.), 0.5 );\n    \n    //fragColor.rgb += .086 * (hash32(fragCoord)-0.5);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define ENABLE_MIS\n\n#define M_PI 3.14159265358979323846\n#define M_E 2.71828182845904523536\n#define GAMMA 1.5\n#define ENV_HDR_STRENGTH 1.4\n#define EXPOSURE 0.75\n\nconst vec3  GLOBAL_UP_VECTOR  = vec3(0,1,0);\nconst float CAMERA_Y_FOV      = radians(90.0);\nconst float EPSILON           = 0.0005;\nconst float MIN_RAY_T         = 0.01;\nconst float MAX_RAY_T         = 1000.0;\nconst int   MAX_BOUNCE_COUNT  = 8;\nconst int   AA_JITTER_COUNT   = 1;\nconst int   DEMO_SPHERE_COUNT = 6;\n\nstruct Material\n{\n\tvec3 albedo;\n    float roughness;\n    float anisotropic;\n    float metallic;\n    float ior;\n};\n\nstruct HitRecord\n{\n\tfloat t;\n    vec3 hitpoint;\n    vec3 normal;\n    Material mtl;\n};\n    \nstruct Camera\n{\n\tvec3 position;\n    vec3 forward;\n    float fov;\t\n\tfloat focusDist;\n    float focalLength;\n\tfloat sensorSize;\n    \n    float aspect;\n};\n\nfloat IntersectSphere(in vec3 ro, in vec3 rd, in vec3 center, in float radius)\n{\n    vec3 v = ro - center;\n    float b = 2.0*dot(rd,v), c = dot(v,v) - radius*radius, delta = b*b - 4.0*c;\n    \n    if(delta < 0.) return -1.0;\n    else if(delta == 0.0 && -b >= 0.0) return -b*0.5;\n    else if(delta > 0.0)\n    {\n        float h = sqrt(delta);\n        float t0 = -b+h, t1 = -b-h;\n        float tmin = min(t0,t1), tmax = max(t0,t1);\n        return (tmin > 0.0 ? tmin : tmax > 0.0 ? tmax : -1.0)*0.5;\n    }\n}\n\nvec3 GetSphereNormal(in vec3 hitpoint, in vec3 center, in float radius)\n{\n\treturn (hitpoint - center) / radius;\n}\n\nstruct Sphere\n{\n    vec3 center;\n    float radius;\n};\n\nbool IntersectDemo1(out HitRecord rec, in vec3 ro, in vec3 rd)\n{\n    const Sphere sph = Sphere(vec3(0), 1.0);\n    float t = IntersectSphere(ro, rd, sph.center, sph.radius);\n    \n    bool hit = t <= MAX_RAY_T && t >= MIN_RAY_T;\n    \n    if (hit)\n    {\n    \trec.hitpoint = ro + rd * t;\n        rec.normal = GetSphereNormal(rec.hitpoint, sph.center, sph.radius);\n    }\n    \n    return hit;\n}\n\nbool IntersectDemo2(out HitRecord rec, in vec3 ro, in vec3 rd)\n{\n    Sphere spheres[DEMO_SPHERE_COUNT * DEMO_SPHERE_COUNT];\n    float closestT = MAX_RAY_T;\n    int closestIndex = -1;\n    \n    \n    for ( int y = 0; y < DEMO_SPHERE_COUNT; ++y )\n    {\n        for ( int x = 0; x < DEMO_SPHERE_COUNT; ++x )\n        {\n            vec2 p = (vec2(x,y) + 0.5) - 0.5 * float(DEMO_SPHERE_COUNT);\n            float  param = pow(abs((p.x+p.y)*.5),0.77);\n            float radius = 0.5* param;\n            vec3 center = vec3(p, sin(param * M_PI*2.0)*2.0) * 1.02;\n            \n            int index = y * DEMO_SPHERE_COUNT + x;\n            spheres[index] = Sphere(center, radius);\n            \n            float t = IntersectSphere(ro, rd, center, radius);\n\n            bool hit = t <= MAX_RAY_T && t >= MIN_RAY_T;\n\n            if (hit && t < closestT)\n            {\n                closestT = t;\n                closestIndex = index;\n            }\n        }\n    }\n    \n    if (closestIndex != -1)\n    {\n    \tSphere sph = spheres[closestIndex];\n        \n        int x = closestIndex % DEMO_SPHERE_COUNT;\n        int y = closestIndex / DEMO_SPHERE_COUNT;\n        \n        rec.hitpoint = ro + rd * closestT;\n        rec.normal = GetSphereNormal(rec.hitpoint, sph.center, sph.radius);\n\n        rec.mtl.roughness = (float(x) + 0.5) / float(DEMO_SPHERE_COUNT);\n        rec.mtl.anisotropic = (float(y) + 0.5) / float(DEMO_SPHERE_COUNT);\n        rec.mtl.ior = 0.45;\n        rec.mtl.albedo = vec3(1.0,0,0);\n        rec.mtl.metallic = (float(y) + 0.5) / float(DEMO_SPHERE_COUNT);\n        \n        return true;\n    }\n    \n    return false;\n}\n\n\nvec3 SampleCosineWeighted(in float U1, in float U2)\n{\n\tfloat r = sqrt(U1);\n\tfloat theta = 2.0 * M_PI * U2;\n\n\treturn vec3( r * cos(theta), r * sin(theta), sqrt(max(0.0, 1.0 - U1)) );\n}\n\nvec3 SampleUniform(in float U1, in float U2)\n{\n\tfloat r = sqrt(1.0 - U1 * U1);\n\tfloat phi = 2.0 * M_PI * U2;\n\n\treturn vec3(cos(phi)* r, sin(phi)* r, U1);\n}\n\nvec3 SampleEnv(in vec3 w)\n{\n\treturn texture(iChannel1, w).rgb * ENV_HDR_STRENGTH;\n}\n\nfloat globalSeed = 0.0;\n\nfloat Rand(void)\n{\n    return hash11(globalSeed++);\n}\n\nfloat Square(in float x)\n{\n    return x * x;\n}\n\nfloat Theta(in vec3 w) { return acos(w.z / length(w)); }\nfloat CosTheta(in vec3 w) { return cos(Theta(w)); }\n\nvec3 SampleCosineHemisphere(in float U1, in float U2)\n{\n\tfloat r = sqrt(U1);\n\tfloat theta = 2.0 * M_PI * U2;\n\n\tfloat x = r * cos(theta);\n\tfloat y = r * sin(theta);\n\n\treturn vec3( x, y, sqrt(max(0.0, 1.0 - U1)) );\n}\n\nfloat EricHeitz2018GGXG1Lambda(in vec3 V, in float alpha_x, in float alpha_y)\n{\n\tfloat Vx2 = Square(V.x);\n\tfloat Vy2 = Square(V.y);\n\tfloat Vz2 = Square(V.z);\n\tfloat ax2 = Square(alpha_x);\n\tfloat ay2 = Square(alpha_y);\n\treturn (-1.0 + sqrt(1.0 + (Vx2 * ax2 + Vy2 * ay2) / Vz2)) / 2.0;\n}\n\nfloat EricHeitz2018GGXG1(vec3 V, float alpha_x, float alpha_y)\n{\n\treturn 1.0 / (1.0 + EricHeitz2018GGXG1Lambda(V, alpha_x, alpha_y));\n}\n\n// wm: microfacet normal in frame\nfloat EricHeitz2018GGXD(in vec3 N, in float alpha_x, in float alpha_y)\n{\n\tfloat Nx2 = Square(N.x);\n\tfloat Ny2 = Square(N.y);\n\tfloat Nz2 = Square(N.z);\n\tfloat ax2 = Square(alpha_x);\n\tfloat ay2 = Square(alpha_y);\n\treturn 1.0 / (M_PI * alpha_x * alpha_y * Square(Nx2 / ax2 + Ny2 / ay2 + Nz2));\n}\n\n\nfloat EricHeitz2018GGXG2(in vec3 V, in vec3 L, in float alpha_x, in float alpha_y)\n{\n\treturn EricHeitz2018GGXG1(V, alpha_x, alpha_y) * EricHeitz2018GGXG1(L, alpha_x, alpha_y);\n}\n\nvec3 SchlickFresnel(in float NoX, in vec3 F0)\n{\n\treturn F0 + (1.0 - F0) * pow(1.0 - NoX, 5.0);\n}\n\nfloat ConductorFresnel(in float ior, in float cosT, in float k)\n{\n    float x = (ior - 1.0);\n    float x2 = Square(x);\n    float y = (ior + 1.0);\n    float y2 = Square(y);\n    float k2 = Square(k);\n\treturn (x2 + 4.0 * ior * pow(1.0 - cosT, 5.0) + k2) / (y2 + k2);\n}\n\nvec3 EricHeitz2018GGXVNDF(in vec3 Ve, in float alpha_x, in float alpha_y, in float U1, in float U2)\n{\n\t// Section 3.2: transforming the view direction to the hemisphere configuration\n\tvec3 Vh = normalize(vec3(alpha_x* Ve.x, alpha_y* Ve.y, Ve.z));\n\t// Section 4.1: orthonormal basis (with special case if cross product is zero)\n\tfloat lensq = Vh.x * Vh.x + Vh.y * Vh.y;\n\tvec3 T1 = lensq > 0.0 ? vec3(-Vh.y, Vh.x, 0.0) * (1.0/sqrt(lensq)) : vec3(1.0, 0.0, 0.0);\n\tvec3 T2 = cross(Vh, T1);\n\t// Section 4.2: parameterization of the projected area\n\tfloat r = sqrt(U1);\n\tfloat phi = 2.0 * M_PI * U2;\n\tfloat t1 = r * cos(phi);\n\tfloat t2 = r * sin(phi);\n\tfloat s = 0.5 * (1.0 + Vh.z);\n\tt2 = (1.0 - s) * sqrt(1.0 - t1 * t1) + s * t2;\n\t// Section 4.3: reprojection onto hemisphere\n\tvec3 Nh = T1*t1 + T2*t2 + sqrt(max(0.0, 1.0 - t1 * t1 - t2 * t2))*Vh;\n\t// Section 3.4: transforming the normal back to the ellipsoid configuration\n\tvec3 Ne = normalize(vec3(alpha_x* Nh.x, alpha_y* Nh.y, max(0.0, Nh.z)));\n\treturn Ne;\n}\n\nfloat EricHeitz2018GGXDV(in vec3 N, in vec3 V, in float alpha_x, in float alpha_y)\n{\n\tfloat dotVZ = CosTheta(V);\n\tfloat dotNV = dot(N, V);\n\tfloat G = EricHeitz2018GGXG1(V, alpha_x, alpha_y);\n\tfloat D = EricHeitz2018GGXD(N, alpha_x, alpha_y);\n\treturn (G * max(dotNV, 0.0) * D) / dotVZ;\n}\n\nfloat EricHeitz2018GGXPDF(in vec3 V, in vec3 Ni, in vec3 Li, in float alpha_x, in float alpha_y)\n{\n\tfloat DV = EricHeitz2018GGXDV(Ni, V, alpha_x, alpha_y);\n\tfloat NoV = dot(V, Ni);\n\treturn DV / (4.0 * NoV);\n}\n\nvec3 EricHeitz2018GGX(in Material mtl, in vec3 wo, out vec3 wi, in float U1, in float U2)\n{\n\tfloat NoL = CosTheta(wi);\n    float NoV = CosTheta(wo);\n    \n    float alpha = mtl.roughness * mtl.roughness;\n    float aspect = sqrt(1.0 - 0.9 * mtl.anisotropic);\n    float alpha_x = alpha * aspect;\n    float alpha_y = alpha / aspect;\n    \n    vec3 Ni = EricHeitz2018GGXVNDF(wo, alpha_x, alpha_y, U1, U2);\n    wi = reflect(-wo, Ni);\n\n    float dotVL = dot(wo, wi);\n    float cosT = max(dotVL, 0.0);\n    vec3 F0 = vec3(abs((1.0 - mtl.ior) / (1.0 + mtl.ior)));\n    F0 = F0 * F0;\n    F0 = mix(F0, mtl.albedo, mtl.metallic);\n    vec3 F = SchlickFresnel(cosT, F0);\n    \n    float G2 = EricHeitz2018GGXG2(wo, wi, alpha_x, alpha_y);\n    float G1 = EricHeitz2018GGXG1(wo, alpha_x, alpha_y);\n\n    return max((F * G2) / G1, 0.0);\n}\n\nvec3 PathTrace(in vec3 ro, in vec3 rd)\n{\n    float U1, U2;\n    vec3 wi, wo, N, T, B;\n    mat3 TBN, invTBN;\n    \n    vec3 color = vec3(0);\n    vec3 falloff = vec3(1);\n    \n    for ( int i = 0; i < MAX_BOUNCE_COUNT; ++i )\n    {\n    \tHitRecord rec;\n        \n        if ( IntersectDemo2(rec, ro, rd) )\n        {\n            N = rec.normal;\n            T = normalize(cross(N, N.zxy));\n            B = cross(N, T);\n            TBN = mat3(T, B, N);\n            invTBN = transpose(TBN);\n            \n            wo = invTBN * (-rd);\n            U1 = Rand();\n            U2 = Rand();\n            \n            if (Rand() < 1.0 - rec.mtl.metallic)\n            {\n                // Half of the time, do diffuse\n            \twi = SampleCosineWeighted(U1, U2);\n            }\n            else\n            {\n            \t// Otherwise, do specular\n                falloff *= EricHeitz2018GGX(rec.mtl, wo, wi, U1, U2);\n            }\n            \n            ro = rec.hitpoint + N * EPSILON;\n            rd = TBN * wi;\n        }\n        else\n        {\n            color = SampleEnv(rd);\n            break;\n        }\n    }\n    \n    return color * falloff;\n}\n\nconst float DOF_BLUR_RADIUS = 5.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 m = (2.0*iMouse.xy - iResolution.xy)/iResolution.y;\n    float theta = 2.0 * M_PI * m.x, phi = M_PI * (m.y*0.5+0.5);\n    \n    Camera cam;\n    cam.position = vec3(sin(phi)*sin(theta), cos(phi), -sin(phi)*cos(theta)) * 3.5;\n\tcam.sensorSize = 0.024;\n\tcam.focalLength = length(cam.position);\n\tcam.focusDist = 1.0;\n    \n    vec2 R = iResolution.xy;\n \n    globalSeed = hash13(vec3(iTime, fragCoord / R));\n    \n    \n    vec3 col = vec3(0);\n    \n    for ( int i = 0; i < AA_JITTER_COUNT; ++i )\n    {\n        /*\n        float U1 = Rand();\n        float U2 = Rand();\n        float r1 = 2.0 * M_PI * U1;\n        float r2 = U2;\n        \n        vec2 offset = vec2(cos(r1)*r2, sin(r1)*r2) * DOF_BLUR_RADIUS;\n        \n        //vec3 p = vec3(samplePoint, 0.0) + sampleDir * DOF_FOCAL_LENGTH;\n        \n        float halfFov = CAMERA_Y_FOV * 0.5;\n        float tanHalfFov = tan(halfFov);\n        \n        vec2 sampleCoord = fragCoord + 0.5 + offset;\n        vec2 samplePoint = (2.0 * sampleCoord - R) / R.y;\n        vec3 sampleLoc = vec3(samplePoint * tanHalfFov, 1.0);\n        \n        //vec3 focalPoint = Lee2007FocalPoint(vec3(0), 1.0, length(sampleLoc), focalLength, normalize(sampleLoc));\n        */\n        vec3 ro = cam.position;//vec3(0.0, 1.5, 1.0) * 2.1;\n        vec3 c = vec3(0.0, 0.0, 0.0);\n        vec3 cf = normalize(c - ro);\n        vec3 cr = normalize(cross(cf, GLOBAL_UP_VECTOR));\n        vec3 cu = normalize(cross(cr, cf));\n        cr = normalize(cross(cf, cu));\n\t\tmat3 viewMatrix = mat3(cr, cu, cf);\n        \n        float halfFov = CAMERA_Y_FOV * 0.5;\n        float tanHalfFov = tan(halfFov);\n        \n        vec2 sampleCoord = fragCoord + vec2(Rand(), Rand());\n        vec2 samplePoint = (2.0 * sampleCoord - R) / R.y;\n        vec3 rd = viewMatrix * normalize(vec3(samplePoint * tanHalfFov, 1.0));\n\n        col += PathTrace(ro, rd);//texture(iChannel0, uv);\n    }\n    \n    col /= float(AA_JITTER_COUNT);\n    \n    // exposure\n    \n    col = pow(col, 1.0/vec3(GAMMA)) * EXPOSURE;\n    \n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    float f = (iMouse.z > 0.0) ? 1.0 : 1.0 / float(iFrame - int(fragColor.a) + 1);\n    fragColor = vec4(mix(fragColor.rgb, col, f), (iMouse.z > 0.0) || NO_TEMPORAL_INTEGRATION ? float(iFrame) : fragColor.a);\n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n#define NO_TEMPORAL_INTEGRATION false\n#define T(x) texelFetch(iChannel0, ivec2(x), 0)\n\n// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n\n// https://www.shadertoy.com/view/4djSRW\n// Trying to find a Hash function that is the same on ALL systens\n// and doesn't rely on trigonometry functions that change accuracy \n// depending on GPU. \n// New one on the left, sine function on the right.\n// It appears to be the same speed, but I suppose that depends.\n\n// * Note. It still goes wrong eventually!\n// * Try full-screen paused to see details.\n\n\n#define ITERATIONS 4\n\n\n// *** Change these to suit your range of random numbers..\n\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n//#define HASHSCALE1 .1031\n//#define HASHSCALE3 vec3(.1031, .1030, .0973)\n//#define HASHSCALE4 vec4(.1031, .1030, .0973, .1099)\n\n// For smaller input rangers like audio tick or 0-1 UVs use these...\n#define HASHSCALE1 443.8975\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n#define HASHSCALE4 vec4(443.897, 441.423, 437.195, 444.129)\n\n\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}","name":"Common","description":"","type":"common"}]}