{"ver":"0.1","info":{"id":"wl2GRR","date":"1558325531","viewed":1221,"name":"Marble Marcher","username":"rmmh","description":"Levels extracted from Marble Marcher, a game about racing over fractals. (exaggerated sizes)\n\nLeft/right arrows to switch levels.\n\nhttps://codeparade.itch.io/marblemarcher\nhttps://github.com/WAUthethird/Marble-Marcher-Community-Edition","likes":21,"published":1,"flags":48,"usePreview":1,"tags":["fractal","ray","marching","distance","marble"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* This file is part of the Marble Marcher (https://github.com/HackerPoet/MarbleMarcher).\n* Copyright(C) 2018 CodeParade\n*\n* This program is free software: you can redistribute it and/or modify\n* it under the terms of the GNU General Public License as published by\n* the Free Software Foundation, either version 2 of the License, or\n* (at your option) any later version.\n*\n* This program is distributed in the hope that it will be useful,\n* but WITHOUT ANY WARRANTY; without even the implied warranty of\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n* GNU General Public License for more details.\n*\n* You should have received a copy of the GNU General Public License\n* along with this program.If not, see <http://www.gnu.org/licenses/>.\n*/\n#define AMBIENT_OCCLUSION_COLOR_DELTA vec3(0.7)\n#define AMBIENT_OCCLUSION_STRENGTH 0.008\n#define ANTIALIASING_SAMPLES 1\n#define BACKGROUND_COLOR vec3(0.6,0.8,1.0)\n#define COL col_scene\n#define DE de_scene\n#define DIFFUSE_ENABLED 0\n#define DIFFUSE_ENHANCED_ENABLED 1\n#define FILTERING_ENABLE 0\n#define FOCAL_DIST 1.73205080757\n#define FOG_ENABLED 0\n#define FRACTAL_ITER 16\n#define LIGHT_COLOR vec3(1.0,0.95,0.8)\n#define LIGHT_DIRECTION vec3(-0.36, 0.8, 0.48)\n#define MAX_DIST 30.0\n#define MAX_MARCHES 1000\n#define MIN_DIST 1e-5\n#define PI 3.14159265358979\n#define SHADOWS_ENABLED 1\n#define SHADOW_DARKNESS 0.7\n#define SHADOW_SHARPNESS 10.0\n#define SPECULAR_HIGHLIGHT 40\n#define SPECULAR_MULT 0.25\n#define SUN_ENABLED 1\n#define SUN_SHARPNESS 2.0\n#define SUN_SIZE 0.004\n#define VIGNETTE_STRENGTH 0.5\n\nmat4 iMat;\nuniform vec3 iDebug;\n\nfloat iFracScale;\nfloat iFracAng1;\nfloat iFracAng2;\nvec3 iFracShift;\nvec3 iFracCol;\nvec3 iMarblePos;\nvec3 iAnim; // x=angle 1, y=angle2, z=offset y\nfloat iOrbitDist;\nfloat iMarbleRad;\nfloat iFlagScale;\nvec3 iFlagPos;\nfloat iExposure = 1.0;\n\nfloat FOVperPixel;\n\nvec3 refraction(vec3 rd, vec3 n, float p) {\n\tfloat dot_nd = dot(rd, n);\n\treturn p * (rd - dot_nd * n) + sqrt(1.0 - (p * p) * (1.0 - dot_nd * dot_nd)) * n;\n}\n\n//##########################################\n//   Space folding\n//##########################################\nvoid mengerFold(inout vec4 z) {\n\tfloat a = min(z.x - z.y, 0.0);\n\tz.x -= a;\n\tz.y += a;\n\ta = min(z.x - z.z, 0.0);\n\tz.x -= a;\n\tz.z += a;\n\ta = min(z.y - z.z, 0.0);\n\tz.y -= a;\n\tz.z += a;\n}\nvoid boxFold(inout vec4 z, vec3 r) {\n\tz.xyz = clamp(z.xyz, -r, r) * 2.0 - z.xyz;\n}\nvoid rotX(inout vec4 z, float s, float c) {\n\tz.yz = vec2(c*z.y + s*z.z, c*z.z - s*z.y);\n}\nvoid rotY(inout vec4 z, float s, float c) {\n\tz.xz = vec2(c*z.x - s*z.z, c*z.z + s*z.x);\n}\nvoid rotZ(inout vec4 z, float s, float c) {\n\tz.xy = vec2(c*z.x + s*z.y, c*z.y - s*z.x);\n}\nvoid rotX(inout vec4 z, float a) {\n\trotX(z, sin(a), cos(a));\n}\nvoid rotY(inout vec4 z, float a) {\n\trotY(z, sin(a), cos(a));\n}\nvoid rotZ(inout vec4 z, float a) {\n\trotZ(z, sin(a), cos(a));\n}\n\n//##########################################\n//   Primitive DEs\n//##########################################\nfloat de_sphere(vec4 p, float r) {\n\treturn (length(p.xyz) - r) / p.w;\n}\nfloat de_box(vec4 p, vec3 s) {\n\tvec3 a = abs(p.xyz) - s;\n\treturn (min(max(max(a.x, a.y), a.z), 0.0) + length(max(a, 0.0))) / p.w;\n}\nfloat de_capsule(vec4 p, float h, float r) {\n\tp.y -= clamp(p.y, -h, h);\n\treturn (length(p.xyz) - r) / p.w;\n}\n\n//##########################################\n//   Main DEs\n//##########################################\nfloat de_fractal(vec4 p) {\n\tfor (int i = 0; i < FRACTAL_ITER; ++i) {\n\t\tp.xyz = abs(p.xyz);\n\t\trotZ(p, iFracAng1);\n\t\tmengerFold(p);\n\t\trotX(p, iFracAng2);\n\t\tp *= iFracScale;\n\t\tp.xyz += iFracShift;\n\t}\n\treturn de_box(p, vec3(6.0));\n}\nvec4 col_fractal(vec4 p) {\n\tvec3 orbit = vec3(0.0);\n\tfor (int i = 0; i < FRACTAL_ITER; ++i) {\n\t\tp.xyz = abs(p.xyz);\n\t\trotZ(p, iFracAng1);\n\t\tmengerFold(p);\n\t\trotX(p, iFracAng2);\n\t\tp *= iFracScale;\n\t\tp.xyz += iFracShift;\n\t\torbit = max(orbit, p.xyz*iFracCol);\n\t}\n\treturn vec4(orbit, de_box(p, vec3(6.0)));\n}\nfloat de_marble(vec4 p) {\n\treturn de_sphere(p - vec4(iMarblePos, 0), iMarbleRad);\n}\nvec4 col_marble(vec4 p) {\n\treturn vec4(0, 0, 0, de_sphere(p - vec4(iMarblePos, 0), iMarbleRad));\n}\nfloat de_flag(vec4 p) {\n\tvec3 f_pos = iFlagPos + vec3(7, 12, 0)*iFlagScale;\n\tfloat d = de_box(p - vec4(f_pos, 0), vec3(1.5, 0.8, 0.08)*iMarbleRad);\n\td = min(d, de_capsule(p - vec4(iFlagPos + vec3(0, iFlagScale*2.4, 0), 0), iMarbleRad*2.4, iMarbleRad*0.18));\n\treturn d;\n}\nvec4 col_flag(vec4 p) {\n\tvec3 f_pos = iFlagPos + vec3(7, 12, 0)*iFlagScale;\n\tfloat d1 = de_box(p - vec4(f_pos, 0), vec3(1.5, 0.8, 0.08)*iMarbleRad);\n\tfloat d2 = de_capsule(p - vec4(iFlagPos + vec3(0, iFlagScale*2.4, 0), 0), iMarbleRad*2.4, iMarbleRad*0.18);\n\tif (d1 < d2) {\n\t\treturn vec4(1.0, 0.2, 0.1, d1);\n\t} else {\n\t\treturn vec4(0.9, 0.9, 0.1, d2);\n\t}\n}\nfloat de_scene(vec4 p) {\n\tfloat d = de_fractal(p);\n\td = min(d, de_marble(p));\n\td = min(d, de_flag(p));\n\treturn d;\n}\nvec4 col_scene(vec4 p) {\n\tvec4 col = col_fractal(p);\n\tvec4 col_f = col_flag(p);\n\tif (col_f.w < col.w) { col = col_f; }\n\tvec4 col_m = col_marble(p);\n\tif (col_m.w < col.w) {\n\t\treturn vec4(col_m.xyz, 1.0);\n\t}\n\treturn vec4(col.xyz, 0.0);\n}\n\n//##########################################\n//   Main code\n//##########################################\n\n//A faster formula to find the gradient/normal direction of the DE(the w component is the average DE)\n//credit to https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(vec4 p, float dx) {\n\tconst vec3 k = vec3(1,-1,0);\n\treturn normalize(k.xyy*DE(p + k.xyyz*dx) +\n\t\t\t\t\t k.yyx*DE(p + k.yyxz*dx) +\n\t\t\t\t\t k.yxy*DE(p + k.yxyz*dx) +\n\t\t\t\t\t k.xxx*DE(p + k.xxxz*dx));\n}\n\n//find the average color of the fractal in a radius dx in plane s1-s2\nvec4 smoothColor(vec4 p, vec3 s1, vec3 s2, float dx) {\n\treturn (COL(p + vec4(s1,0)*dx) +\n\t\t\tCOL(p - vec4(s1,0)*dx) +\n\t\t\tCOL(p + vec4(s2,0)*dx) +\n\t\t\tCOL(p - vec4(s2,0)*dx))/4.0;\n}\n\nvec4 ray_march(inout vec4 p, vec4 ray, float sharpness) {\n\t//March the ray\n\tfloat d = DE(p);\n\tif (d < 0.0 && sharpness == 1.0) {\n\t\tvec3 v;\n\t\tif (abs(iMarblePos.x) >= 999.0f) {\n\t\t\tv = (-20.0 * iMarbleRad) * iMat[2].xyz;\n\t\t} else {\n\t\t\tv = iMarblePos.xyz - iMat[3].xyz;\n\t\t}\n\t\td = dot(v, v) / dot(v, ray.xyz) - iMarbleRad;\n\t}\n\tfloat s = 0.0;\n\tfloat td = 0.0;\n\tfloat min_d = 1.0;\n\tfor (; s < float(MAX_MARCHES); s += 1.0) {\n\t\t//if the distance from the surface is less than the distance per pixel we stop\n\t\tfloat min_dist = max(FOVperPixel*td, MIN_DIST);\n\t\tif (d < min_dist) {\n\t\t\ts += d / min_dist;\n\t\t\tbreak;\n\t\t} else if (td > MAX_DIST) {\n\t\t\tbreak;\n\t\t}\n\t\ttd += d;\n\t\tp += ray * d;\n\t\tmin_d = min(min_d, sharpness * d / td);\n\t\td = DE(p);\n\t}\n\treturn vec4(d, s, td, min_d);\n}\n\nvec4 scene(inout vec4 p, inout vec4 ray, float vignette) {\n\t//Trace the ray\n\tvec4 d_s_td_m = ray_march(p, ray, 1.0f);\n\tfloat d = d_s_td_m.x;\n\tfloat s = d_s_td_m.y;\n\tfloat td = d_s_td_m.z;\n\n\t//Determine the color for this pixel\n\tvec4 col = vec4(0.0);\n\tfloat min_dist = max(FOVperPixel*td, MIN_DIST);\n\tif (d < min_dist) {\n\t\t//Get the surface normal\n\t\tvec3 n = calcNormal(p, min_dist*0.5);\n\t\t\n\t\t//find closest surface point, without this we get weird coloring artifacts\n\t\tp.xyz -= n*d;\n\n\t\t//Get coloring\n\t\t#if FILTERING_ENABLE\n\t\t\t//sample direction 1, the cross product between the ray and the surface normal, should be parallel to the surface\n\t\t\tvec3 s1 = normalize(cross(ray.xyz, n));\n\t\t\t//sample direction 2, the cross product between s1 and the surface normal\n\t\t\tvec3 s2 = cross(s1, n);\n\t\t\t//get filtered color\n\t\t\tvec4 orig_col = clamp(smoothColor(p, s1, s2, min_dist*0.5), 0.0, 1.0);\n\t\t#else\n\t\t\tvec4 orig_col = clamp(COL(p), 0.0, 1.0);\n\t\t#endif\n\t\tcol.w = orig_col.w;\n\n\t\t//Get if this point is in shadow\n\t\tfloat k = 1.0;\n\t\t#if SHADOWS_ENABLED\n\t\t\tvec4 light_pt = p;\n\t\t\tlight_pt.xyz += n * MIN_DIST * 100.0;\n\t\t\tvec4 rm = ray_march(light_pt, vec4(LIGHT_DIRECTION, 0.0), SHADOW_SHARPNESS);\n\t\t\tk = rm.w * min(rm.z, 1.0);\n\t\t#endif\n\n\t\t//Get specular\n\t\t#if SPECULAR_HIGHLIGHT > 0\n\t\t\tvec3 reflected = ray.xyz - 2.0*dot(ray.xyz, n) * n;\n\t\t\tfloat specular = max(dot(reflected, LIGHT_DIRECTION), 0.0);\n\t\t\tspecular = pow(specular, float(SPECULAR_HIGHLIGHT));\n\t\t\tcol.xyz += specular * LIGHT_COLOR * (k * SPECULAR_MULT);\n\t\t#endif\n\n\t\t//Get diffuse lighting\n\t\t#if DIFFUSE_ENHANCED_ENABLED\n\t\t\tk = min(k, SHADOW_DARKNESS * 0.5 * (dot(n, LIGHT_DIRECTION) - 1.0) + 1.0);\n\t\t#elif DIFFUSE_ENABLED\n\t\t\tk = min(k, dot(n, LIGHT_DIRECTION));\n\t\t#endif\n\n\t\t//Don't make shadows entirely dark\n\t\tk = max(k, 1.0 - SHADOW_DARKNESS);\n\t\tcol.xyz += orig_col.xyz * LIGHT_COLOR * k;\n\n\t\t//Add small amount of ambient occlusion\n\t\tfloat a = 1.0 / (1.0 + s * AMBIENT_OCCLUSION_STRENGTH);\n\t\tcol.xyz += (1.0 - a) * AMBIENT_OCCLUSION_COLOR_DELTA;\n\n\t\t//Add fog effects\n\t\t#if FOG_ENABLED\n\t\t\ta = td / MAX_DIST;\n\t\t\tcol.xyz = (1.0 - a) * col.xyz + a * BACKGROUND_COLOR;\n\t\t#endif\n\n\t\t//Return normal through ray\n\t\tray = vec4(n, 0.0);\n\t} else {\n\t\t//Ray missed, start with solid background color\n\t\tcol.xyz += BACKGROUND_COLOR;\n\n\t\tcol.xyz *= vignette;\n\t\t//Background specular\n\t\t#if SUN_ENABLED\n\t\t\tfloat sun_spec = dot(ray.xyz, LIGHT_DIRECTION) - 1.0 + SUN_SIZE;\n\t\t\tsun_spec = min(exp(sun_spec * SUN_SHARPNESS / SUN_SIZE), 1.0);\n\t\t\tcol.xyz += LIGHT_COLOR * sun_spec;\n\t\t#endif\n\t}\n\n\treturn col;\n}\n\nstruct level {\n    float scale, angle1, angle2;\n    vec3 offset, color;\n    float marbleRadius, startLook, orbitDistance;\n    vec3 marblePos, flagPos;\n    float deathBarrier;\n    bool isPlanet;\n    vec3 anim;\n};\n\nconst int NLEVELS = 26;\nconst level levels[NLEVELS] = level[NLEVELS](\n    /* JumpTheCrater */ level(1.8,-0.12,0.5,vec3(-2.12,-2.75,0.49),vec3(0.42,0.38,0.19),0.035,-2.0,3.3,vec3(-2.95862,2.68825,-1.11868),vec3(2.95227,2.65057,1.11848),-4.0,false,vec3(0)),\n    /* TooManyTrees */ level(1.9073,-9.83,-1.16,vec3(-3.508,-3.593,3.295),vec3(-0.34,0.12,-0.08),0.04,-2.365,5.8,vec3(-3.40191,4.14347,-3.48312),vec3(3.40191,4.065,3.48312),-4.5,false,vec3(0)),\n    /* HoleInOne */ level(2.02,-1.57,1.62,vec3(-3.31,6.19,1.53),vec3(0.12,-0.09,-0.09),0.009,1.570796,7.0,vec3(3.18387,5.99466,0.0),vec3(0.0,-6.25,0.0),-7.0,false,vec3(0)),\n    /* AroundTheWorld */ level(1.65,0.37,5.26,vec3(-1.41,-0.22,-0.77),vec3(0.14,-1.71,0.31),0.01,3.14159,3.1,vec3(0.0,2.26418,0.0),vec3(0.0,-2.25,0.0),-999.0,true,vec3(0)),\n    /* TheHillsAreAlive */ level(1.77,-0.22,5.62,vec3(-2.08,-1.42,-1.93),vec3(0.42,0.38,0.19),0.02,0.545116,3.3,vec3(1.98046,2.56955,2.08186),vec3(-0.514117,3.14,-2.01516),-3.8,false,vec3(0.0,0.06,0.0)),\n    /* BewareOfBumps */ level(1.66,1.52,0.19,vec3(-3.83,-1.94,-1.09),vec3(0.42,0.38,0.19),0.02,0.0,3.1,vec3(0.68147,2.80038,2.52778),vec3(0.0,2.84448,-2.71705),-4.0,false,vec3(0)),\n    /* MountainClimbing */ level(1.58,-1.45,3.95,vec3(-1.55,-0.13,-2.52),vec3(-1.17,-0.4,-1.0),0.02,0.0,4.3,vec3(0.0,3.36453,2.28284),vec3(0.0,3.68893,-0.604513),-5.5,false,vec3(0)),\n    /* TheCatwalk */ level(1.87,-3.12,0.02,vec3(-3.57,0.129,2.95),vec3(0.42,0.38,0.19),0.02,3.14159,4.2,vec3(0.0,3.66236,-3.30036),vec3(0.0,3.64236,3.80),-3.6,false,vec3(0.0,0.0,0.05)),\n    /* MindTheGap */ level(1.81,-4.84,-2.99,vec3(-2.905,0.765,-4.165),vec3(0.16,0.38,0.15),0.022,-1.570796,4.5,vec3(-4.63064,3.6365,0.0),vec3(4.63,3.61,0.0),-5.5,false,vec3(0)),\n    /* Don'tGetCrushed */ level(1.93,1.34637,1.58,vec3(-2.31,1.123,1.56),vec3(0.42,0.38,0.19),0.02,-2.39681,2.7,vec3(-1.71412,1.84836,-1.70884),vec3(0.0,2.13651,1.74782),-3.6,false,vec3(0.1,0.0,0.0)),\n    /* TheSponge */ level(1.88,1.52,4.91,vec3(-4.54,-1.26,0.1),vec3(-1.0,0.3,-0.43),0.03,-1.570796,5.7,vec3(-2.8896,3.76526,0.0),vec3(2.88924,3.73,0.0),-4.5,false,vec3(0)),\n    /* RideTheGecko */ level(1.6,3.77,3.93,vec3(-2.0,-0.41,-1.43),vec3(0.42,0.38,0.19),0.02,-1.570796,3.5,vec3(-2.30432,0.0444069,2.31072),vec3(2.30432,0.0244069,-2.31072),-1.0,false,vec3(0.02,0.0,0.0)),\n    /* BuildUpSpeed */ level(2.08,-4.79,3.16,vec3(-7.43,5.96,-6.23),vec3(0.16,0.38,0.15),0.023,1.570796,7.6,vec3(6.06325,6.32712,0.0),vec3(0.0,6.72,0.0),-7.0,false,vec3(0)),\n    /* AroundTheCitadel */ level(2.0773,-9.66,-1.34,vec3(-1.238,-1.533,1.085),vec3(0.42,0.38,0.19),0.01,1.4,3.0,vec3(1.03543,1.06432,1.22698),vec3(-1.39536,0.641835,0.0),-2.0,false,vec3(0)),\n    /* PlanetCrusher */ level(1.78,-0.1,3.28,vec3(-1.47,1.7,-0.4),vec3(0.42,0.38,0.19),0.02,3.14159,2.9,vec3(0.0,2.1431,0.0),vec3(0.0,-2.12,0.0),-999.0,true,vec3(0.0,0.08,0.0)),\n    /* TopOfTheCitadel */ level(2.0773,-9.66,-1.34,vec3(-1.238,-1.533,1.085),vec3(0.42,0.38,0.19),0.005,0.78539816339,2.0,vec3(1.04172,1.41944,1.09742),vec3(-1.04172,1.414,-1.09742),-2.0,false,vec3(0)),\n    /* BuildingBridges */ level(1.8093,-3.165,-3.2094777,vec3(-1.0939,-0.43495,-3.1113),vec3(-0.61,-0.92,0.33),0.005,0.0,5.0,vec3(0.0,-0.483245,2.16278),vec3(0.0,-0.489,-2.16278),-5.0,false,vec3(0.0,0.0,0.06)),\n    /* PylonPalace */ level(1.95,1.570796,0.0,vec3(-6.75,-3.0,0.0),vec3(0.42,0.38,0.19),0.022,0.0,6.3,vec3(0.0,3.96637,4.54647),vec3(0.0,0.396,-2.38815),-5.0,false,vec3(0)),\n    /* TheCrownJewels */ level(1.91,0.06,-0.76,vec3(-3.44,-0.69,-1.14),vec3(0.42,0.38,0.19),0.012,3.14159,5.0,vec3(0.0,3.78299,0.0),vec3(0.0,-3.77,0.0),-999.0,true,vec3(0.0,0.05,0.0)),\n    /* Expressways */ level(1.8986,-0.4166,0.00683,vec3(-2.5130,-5.4067,-2.51),vec3(0.42,0.38,0.19),0.01,-1.570796,5.0,vec3(1.19695,3.19773,2.8491),vec3(1.168,3.195,-2.8491),-5.0,false,vec3(0)),\n    /* BunnyHops */ level(2.03413,1.688,-1.57798,vec3(-4.803822,-4.1,-1.39063),vec3(-0.95,-0.16,0.14),0.005,1.570796,7.0,vec3(3.77655,4.7211,0.0),vec3(-3.77655,4.716,0.0),-5.0,false,vec3(0)),\n    /* AsteroidField */ level(1.6516888,0.026083898,-0.7996324,vec3(-3.85863,-5.13741,-0.918303),vec3(0.42,0.38,0.19),0.016,0.0,7.0,vec3(0.0,5.91936,4.3357),vec3(0.0,-1.01,-3.94),-6.5,false,vec3(0)),\n    /* LilyPads */ level(1.77746,4.62318,0.0707307,vec3(-4.6867,-0.84376,1.98158),vec3(-0.35,1.5,0.48),0.016,1.570796,7.0,vec3(3.03669,4.3497,0.0),vec3(-3.03669,4.331,0.0),-5.0,false,vec3(0)),\n    /* FatalFissures */ level(2.13,-1.77,-1.62,vec3(-4.99,-3.05,-4.48),vec3(0.42,0.38,0.19),0.01,3.14159,6.2,vec3(0.479104,2.18768,-4.29408),vec3(0.479104,2.177,4.29408),-4.0,false,vec3(0)),\n    /* Gladiator */ level(1.312,0.630,-1.744,vec3(-.807,-1.692,-.615),vec3(0.3,1,0.21),0.035,-2.0,3.3,vec3(3,1.8,1),vec3(-2,0,-1),-4.0,false,vec3(0)),\n    /* LEVEL EDITOR */ level(2.0,.1,.1,vec3(-2,-2,.5),vec3(0.3,1,0.21),0.035,-2.0,3.3,vec3(999),vec3(999),-4.0,false,vec3(0))\n);\n\n// https://stackoverflow.com/q/23793698\nvec3 slerp(vec3 p0, vec3 p1, float t)\n{\n\tif (t >= 1.0) {\n    \treturn p1;\n\t}\n  \tfloat dotp = dot(normalize(p0), normalize(p1));\n  \tif (abs(dotp) > 0.9999) {\n    \treturn t <= 0.5 ? p0 : p1;\n  \t}\n  \tfloat theta = acos(dotp);\n  \tvec3 P = ((p0*sin((1.0-t)*theta) + p1*sin(t*theta)) / sin(theta));\n  \treturn P;\n}\n\nfloat alerp(float a, float b, float t) {\n\tif (t >= 1.0) {\n    \treturn b;\n\t}\n    if (b - a > PI) {\n        a += 2.0*PI;\n    } else if (a - b > PI) {\n        b += 2.0 * PI;\n    }\n    return mix(a, b, t);\n}\n\n// readUI state\nfloat readFloat(int address) { return texture(iChannel1, (floor(vec2(address, 1))+0.5) / iChannelResolution[1].xy).r; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    vec4 t = texture(iChannel0, vec2(0, 0));\n    int lnum = (int(t.x) + NLEVELS) % NLEVELS;\n    bool edit = lnum == NLEVELS - 1;\n    level a = levels[(int(t.y) + NLEVELS) % NLEVELS];\n    level b = levels[lnum];\n    float c = clamp(iTime - t.z, 0.0, 1.0);\n    \n    #define M(x) mix(a.x, b.x, c)\n\t#define VM(x) slerp(a.x, b.x, c)\n    #define AM(x) alerp(a.x, b.x, c)\n    \n    iFracScale = M(scale); iFracAng1 = AM(angle1); iFracAng2 = AM(angle2); iFracShift = VM(offset); \n    iFracCol = VM(color); iFlagPos = M(flagPos); iOrbitDist = M(orbitDistance); iAnim = M(anim);\n    \n    if (edit) {\n        c = 1.0;\n        iFracScale = readFloat(1); iFracAng1 = readFloat(2); iFracAng2 = readFloat(3);\n        iFracShift = vec3(readFloat(4), readFloat(5), readFloat(6));\n        iOrbitDist = readFloat(7);\n    }\n    \n    iMarbleRad = mix(a.marbleRadius * 5.0, b.marbleRadius * 5.0, c);\n    iFlagScale = mix(a.isPlanet ? -a.marbleRadius : a.marbleRadius, b.isPlanet ? -b.marbleRadius : b.marbleRadius, c); \n    iMarblePos = mix(a.marblePos + vec3(0,5,0) * a.marbleRadius, b.marblePos + vec3(0,5,0) * b.marbleRadius, c);\n\n    if (c == 1.0) {  // level interpolation over; begin animation\n        iFracAng1 += iAnim.x * sin(iTime - t.z + 1.0);\n        iFracAng2 += iAnim.y * sin(iTime - t.z + 1.0);\n        iFracShift.y += iAnim.z * sin(iTime - t.z + 1.0);\n    }\n    \n           \n    vec2 mo = iMouse.xy/iResolution.xy;\n    if (edit && iMouse.x < 400.0 && iMouse.y < 300.0) { mo = vec2(0); }\n\tfloat time = 15.0 + iTime*2.0;\n    iOrbitDist *= 2.5;\n\n    float angle = .1*time + 7.0 *mo.x;\n    float yAngle = 0.5 - 7.0 * mo.y;\n    vec3 camPos = vec3(sin(angle)*cos(yAngle), sin(yAngle), cos(angle)*cos(yAngle)) * iOrbitDist;\n    float xRot = -angle;\n    float yRot = yAngle;\n    \n    mat3 rot = mat3(cos(xRot), 0, sin(xRot), 0, 1, 0, -sin(xRot), 0, cos(xRot)) *\n        \t   mat3(1, 0, 0, 0, cos(yRot), -sin(yRot), 0, sin(yRot), cos(yRot));\n\n    iMat = mat4(\n      \trot[0], 0,\n        rot[1], 0,\n        rot[2], 0,\n    \tcamPos, 1\n    );\n    \n\t//Calculate the view angle per pixel, with a minimum quality level\n\tFOVperPixel = 1.0 / max(iResolution.x, 900.0);\n\n\tvec3 col = vec3(0.0);\n\tfor (int i = 0; i < ANTIALIASING_SAMPLES; ++i) {\n\t\tfor (int j = 0; j < ANTIALIASING_SAMPLES; ++j) {\n\t\t\t//Get normalized screen coordinate\n\t\t\tvec2 delta = vec2(i, j) / float(ANTIALIASING_SAMPLES);\n\t\t\tvec2 screen_pos = (fragCoord.xy + delta) / iResolution.xy;\n\n\t\t\tvec2 uv = 2.0*screen_pos - 1.0;\n\t\t\tuv.x *= iResolution.x / iResolution.y;\n\n\t\t\t//Convert screen coordinate to 3d ray\n\t\t\tvec4 ray = iMat * normalize(vec4(uv.x, uv.y, -FOCAL_DIST, 0.0));\n\t\t\tvec4 p = iMat[3];\n\n\t\t\t//Reflect light if needed\n\t\t\tfloat vignette = 1.0 - VIGNETTE_STRENGTH * length(screen_pos - 0.5);\n\t\t\tvec3 r = ray.xyz;\n\t\t\tvec4 col_r = scene(p, ray, vignette);\n\n\t\t\t//Check if this is the glass marble\n\t\t\tif (col_r.w > 0.5) {\n\t\t\t\t//Calculate refraction\n\t\t\t\tvec3 n = normalize(iMarblePos - p.xyz);\n\t\t\t\tvec3 q = refraction(r, n, 1.0 / 1.5);\n\t\t\t\tvec3 p2 = p.xyz + (dot(q, n) * 2.0 * iMarbleRad) * q;\n\t\t\t\tn = normalize(p2 - iMarblePos);\n\t\t\t\tq = (dot(q, r) * 2.0) * q - r;\n\t\t\t\tvec4 p_temp = vec4(p2 + n * (MIN_DIST * 10.0), 1.0);\n\t\t\t\tvec4 r_temp = vec4(q, 0.0);\n\t\t\t\tvec3 refr = scene(p_temp, r_temp, 0.8).xyz;\n\n\t\t\t\t//Calculate refraction\n\t\t\t\tn = normalize(p.xyz - iMarblePos);\n\t\t\t\tq = r - n*(2.0*dot(r,n));\n\t\t\t\tp_temp = vec4(p.xyz + n * (MIN_DIST * 10.0), 1.0);\n\t\t\t\tr_temp = vec4(q, 0.0);\n\t\t\t\tvec3 refl = scene(p_temp, r_temp, 0.8).xyz;\n\n\t\t\t\t//Combine for final marble color\n\t\t\t\tcol += refr * 0.6f + refl * 0.4f + col_r.xyz;\n\t\t\t} else {\n\t\t\t\tcol += col_r.xyz;\n\t\t\t}\n\t\t}\n\t}\n\n\tcol *= iExposure / float(ANTIALIASING_SAMPLES * ANTIALIASING_SAMPLES);\n\tfragColor = vec4(clamp(col, 0.0, 1.0), 1.0);\n    \n    //UI\n    if (edit) {\n        vec4 ui = texture(iChannel1, fragCoord/iResolution.xy);\n    \tfragColor = mix(fragColor, ui, ui.a);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// --- keyboard -----------------------------------------------------\n\n// FYI: LEFT:37  UP:38  RIGHT:39  DOWN:40   PAGEUP:33  PAGEDOWN:34  END : 35  HOME: 36\nbool keyClick(int ascii) {\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.25)).x > 0.);\n}\nbool keyToggle(int ascii) {\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    // this really doesn't *want* to be a buffer!\n    if (length(fragCoord.xy / iResolution.xy) > 2.)\n        return;\n    \n    // track level number  \n    vec4 t = texture(iChannel0, fragCoord);\n    \n    if (t.z == 0.0) {\n        t = vec4(-1, -1, iTime, 0);\n    }\n    \n    bool act = t.w != 0.0;\n    fragColor = t;\n    int cur = int(t.x);\n    \n    if (iTime - t.z > 1.0) {\n        t.y = t.x;\n    }\n    \n    if (keyClick(37)) { // LEFT\n        if (!act) {\n            t.y = t.x;\n            cur -= 1;\n            act = true;\n            t.z = iTime;\n        }\n    } else if (keyClick(39)) { // RIGHT\n        if (!act) {\n            t.y = t.x;\n            cur += 1;\n            act = true;\n            t.z = iTime;\n        }\n    } else {\n        act = false;\n    }\n    \n    t.xw = vec2(cur, act);\n    \n    fragColor = t;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// from https://www.shadertoy.com/view/XlG3WD\n\n#define UI_COLOR vec3(1,1,1)\n\n//8x8 font \n#define _A text.w += char(0x386C, 0xC6C6, 0xFEC6, 0xC600); \n#define _B text.w += char(0xFCC6, 0xC6FC, 0xC6C6, 0xFC00);\n#define _C text.w += char(0x3C66, 0xC0C0, 0xC066, 0x3C00);\n#define _D text.w += char(0xF8CC, 0xC6C6, 0xC6CC, 0xF800);\n#define _E text.w += char(0xFEC0, 0xC0FC, 0xC0C0, 0xFE00);\n#define _F text.w += char(0xFEC0, 0xC0FC, 0xC0C0, 0xC000);\n#define _G text.w += char(0x3E60, 0xC0CE, 0xC666, 0x3E00);\n#define _H text.w += char(0xC6C6, 0xC6FE, 0xC6C6, 0xC600);\n#define _I text.w += char(0x7E18, 0x1818, 0x1818, 0x7E00);\n#define _J text.w += char(0x606, 0x606, 0x6C6, 0x7C00);\n#define _K text.w += char(0xC6CC, 0xD8F0, 0xF8DC, 0xCE00);\n#define _L text.w += char(0x6060, 0x6060, 0x6060, 0x7E00);\n#define _M text.w += char(0xC6EE, 0xFEFE, 0xD6C6, 0xC600);\n#define _N text.w += char(0xC6E6, 0xF6FE, 0xDECE, 0xC600);\n#define _O text.w += char(0x7CC6, 0xC6C6, 0xC6C6, 0x7C00);\n#define _P text.w += char(0xFCC6, 0xC6C6, 0xFCC0, 0xC000);\n#define _Q text.w += char(0x7CC6, 0xC6C6, 0xDECC, 0x7A00);\n#define _R text.w += char(0xFCC6, 0xC6CC, 0xF8DC, 0xCE00);\n#define _S text.w += char(0x78CC, 0xC07C, 0x6C6, 0x7C00);\n#define _T text.w += char(0x7E18, 0x1818, 0x1818, 0x1800);\n#define _U text.w += char(0xC6C6, 0xC6C6, 0xC6C6, 0x7C00);\n#define _V text.w += char(0xC6C6, 0xC6EE, 0x7C38, 0x1000);\n#define _W text.w += char(0xC6C6, 0xD6FE, 0xFEEE, 0xC600);\n#define _X text.w += char(0xC6EE, 0x7C38, 0x7CEE, 0xC600);\n#define _Y text.w += char(0x6666, 0x663C, 0x1818, 0x1800);\n#define _Z text.w += char(0xFE0E, 0x1C38, 0x70E0, 0xFE00);\n\n#define A text.w += char(0x0, 0x7C06, 0x7EC6, 0x7E00);\n#define B text.w += char(0xC0C0, 0xFCC6, 0xC6C6, 0x7C00);\n#define C text.w += char(0x0, 0x7EC0, 0xC0C0, 0x7E00);\n#define D text.w += char(0x606, 0x7EC6, 0xC6C6, 0x7E00);\n#define E text.w += char(0x0, 0x7CC6, 0xFEC0, 0x7C00);\n#define F text.w += char(0xE18, 0x7E18, 0x1818, 0x1800);\n#define G text.w += char(0x0, 0x7EC6, 0xC67E, 0x67C);\n#define H text.w += char(0xC0C0, 0xFCC6, 0xC6C6, 0xC600);\n#define I text.w += char(0x1800, 0x3818, 0x1818, 0x7E00);\n#define J text.w += char(0xC00, 0x1C0C, 0xC0C, 0xC78);\n#define K text.w += char(0xC0C0, 0xCEFC, 0xF8DC, 0xCE00);\n#define L text.w += char(0x3818, 0x1818, 0x1818, 0x7E00);\n#define M text.w += char(0x0, 0xFCB6, 0xB6B6, 0xB600);\n#define N text.w += char(0x0, 0xFCC6, 0xC6C6, 0xC600);\n#define O text.w += char(0x0, 0x7CC6, 0xC6C6, 0x7C00);\n#define P text.w += char(0x0, 0xFCC6, 0xC6FC, 0xC0C0);\n#define Q text.w += char(0x0, 0x7EC6, 0xC67E, 0x606);\n#define R text.w += char(0x0, 0x6E70, 0x6060, 0x6000);\n#define S text.w += char(0x0, 0x7CC0, 0x7C06, 0xFC00);\n#define T text.w += char(0x1818, 0x7E18, 0x1818, 0x1800);\n#define U text.w += char(0x0, 0xC6C6, 0xC6C6, 0x7E00);\n#define V text.w += char(0x0, 0x6666, 0x663C, 0x1800);\n#define W text.w += char(0x0, 0xB6B6, 0xB6B6, 0x7E00);\n#define X text.w += char(0x0, 0xC6FE, 0x38FE, 0xC600);\n#define Y text.w += char(0x0, 0xC6C6, 0xC67E, 0x67C);\n#define Z text.w += char(0x0, 0xFE1C, 0x3870, 0xFE00);\n\n#define _0 text.w += char(0x384C, 0xC6C6, 0xC664, 0x3800);\n#define _1 text.w += char(0x1838, 0x1818, 0x1818, 0x7E00);\n#define _2 text.w += char(0x7CC6, 0xE3C, 0x78E0, 0xFE00);\n#define _3 text.w += char(0x7E0C, 0x183C, 0x6C6, 0x7C00);\n#define _4 text.w += char(0x1C3C, 0x6CCC, 0xFE0C, 0xC00);\n#define _5 text.w += char(0xFCC0, 0xFC06, 0x6C6, 0x7C00);\n#define _6 text.w += char(0x3C60, 0xC0FC, 0xC6C6, 0x7C00);\n#define _7 text.w += char(0xFEC6, 0xC18, 0x3030, 0x3000);\n#define _8 text.w += char(0x78C4, 0xE478, 0x9E86, 0x7C00);\n#define _9 text.w += char(0x7CC6, 0xC67E, 0x60C, 0x7800);\n#define EXC text.w += char(0x3838, 0x3830, 0x3000, 0x3000);\n#define QTN text.w += char(0x7CFE, 0xC60C, 0x3800, 0x3800);\n#define COM text.w += char(0x0, 0x0, 0x30, 0x3060);\n#define APO text.w += char(0x3030, 0x3000, 0x0, 0x0);\n\n#define MINUS text.w += char(0x0, 0x003c, 0x0, 0x0); \n#define STP text.z-=2.0; text.w += char(0x0, 0x0, 0x30, 0x3000); text.z-=4.0;\n\n#define SP text.z+=4.;\n#define _ text.z+=4.;\n#define NL text.z=0.; text.y-=9.0;\n\nvec2 pixel;\nvec4 text;//x y index result\nfloat ui = 0.0;\nvec4 result;    \n\nfloat char(int b1, int b2, int b3, int b4){\n  int bin; \n  vec2 p = pixel - text.xy - vec2(text.z, 0); \n  text.z += 9.0; \n  if (!(all(lessThan(p,vec2(8))) &&  all(greaterThanEqual(p,vec2(0))))) return 0.0;\n  p = floor(8.0-p);    int c = int(p.y / 2.0);\n  if (c == 0){bin = b1;}else if (c == 1){bin = b2;}else if (c == 2){bin = b3;}else if(c == 3){bin = b4;}\n  if (int(mod(p.y, 2.0)) == 0) p.x += 8.;\n  return mod(floor(float(bin) / pow(2.0, p.x)), 2.0);\n}\nvoid digit(float d){\n    if(d == 0.)_0 else if(d == 1.)_1 else if(d == 2.)_2 else if(d == 3.)_3 else if(d == 4.)_4\n    else if(d == 5.)_5 else if(d == 6.)_6 else if(d == 7.)_7 else if(d == 8.)_8 else if(d == 9.)_9        \n}\nvoid drawNumber(float val, float fractPrecision){  \n    if(sign(val)==-1.0) MINUS //draw minus sign if needed\n    val = abs(val);    \n    float intCount = floor(val)==0.0 ? 1.0 : floor(log(val)/2.302585) +1.;//calculate int part length\n    // log10(val) = log(val)/2.302585    \n    if(fractPrecision > 0.){val *= pow(10.,fractPrecision);}  // move decimal point \n    val = floor(val); // strip the fractional part   \n    float count = intCount + fractPrecision; //totla number of digits to print    \n    if(count > 8.){ E R R O R return;} //show error if count > 8 \n    float pw = pow(10., count-1.);\n    for(float i = 8.;i > 0.;i--){ // 8 is max digit per number\n        if(count<i){ continue;} //skip unnecessary loops\n        if(i-fractPrecision == 0.){STP} //draw decimal point        \n        float d = floor(val/pw); //get one digit\n        digit( d ); //draw digit\n        val -= d*pw; pw /= 10.; //prepare for next iteration\n    }\n}\n\n\nvoid newText(vec2 p, in vec2 o){pixel = p; text= vec4(o, 0,0);}\nvoid moveCursor(in vec2 o){text.xy = o; text.z=0.0;}\nfloat outputText(){return text.w;}\n\nfloat printFloat(float val, float prec, vec2 p, vec2 o){\n    newText(p, o);  drawNumber(val, prec); return outputText();\n}\n\nfloat printVec2(vec2 val, float prec, vec2 p, vec2 o){ \n    newText(p, o);\n    float str = 0.0;\n    drawNumber(val.x, prec);\n    _ COM _\n    drawNumber(val.y, prec);    \n    str += outputText();    \n    return str;\n}\n\n\n\n// distance functions\nfloat dfBox(vec2 p, vec2 size) {vec2 d = abs(p)-size; return max(d.x, d.y);}\nfloat dfBox(vec2 p, vec4 b) {vec2 d = abs(-b.xy-b.zw*.5 + p) - b.zw*.5; return max(d.x, d.y);}\nfloat dfBoxRounded(vec2 p, vec2 size, float radius){ size -= vec2(radius); vec2 d = abs(p)-size;  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;}\nfloat dfBoxRounded(vec2 p, vec4 b, float radius){ vec2 size = b.zw*.5-vec2(radius); vec2 d = abs(-b.xy-b.zw*.5 + p)-size;  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;}\nfloat fillMask(float dist){return clamp(-dist, 0.0, 1.0);}\n\n\n// read/write\nvec4 readPixel(vec2 address) { return texture(iChannel0, (floor(address)+0.5) / iChannelResolution[0].xy); }\nbool isCell(in vec2 p, in vec2 a) { return floor(p.x) == a.x && floor(p.y) == 1.0;}    \nvoid setPixel(vec2 address, vec4 val){if(isCell(pixel, address)){result=val;}}\n\n//slider\nvoid drawSlider(int id, float val, inout float ui, vec2 p, vec4 b, vec2 range){  \n    \n    float gap = 5.;\n    vec4 data = readPixel(vec2(id,1)); \n    \n    //if first frame write default value\n    if(data.g < 0.1){ \n        data = vec4(val,.4,0,1);\n        setPixel(vec2(id,1), data);\n    }    \n    \n    //draw bg\n    ui = mix(ui, .8, fillMask(dfBoxRounded(p,b,4.0))); \n    \n    //if mouse over slider write new value\n    if(dfBox(iMouse.xy,b)<=gap){\n        float distanceFromLeftEdege = clamp(iMouse.x, b.x, b.x+b.z)-b.x;\n        data.r = mix(range.x, range.y, distanceFromLeftEdege/ b.z);        \n        //data.a=1.0;\n        setPixel(vec2(id,1), data);\n        \n        b.w=35.0;\n    }\n    \n    //draw sliding bar   \n    if(ui >=0.6){\n    \tb.z *= (data.r - range.x) / (range.y - range.x);\n        ui = mix(ui, .9, fillMask(dfBox(p,b)));\n    }\n    \n    //draw number    \n    vec4 tmp = text;\n    ui = mix(ui, .1, printFloat(data.r, 3., p, b.xy + vec2(8., 5.)));\n    text = tmp;\n    \n}\n\n\nvec4 bounds = vec4(30,260,400,18);\n#define EASYSLIDER(id,val) drawSlider(id, val, ui, pixel, bounds, vec2(0, 1)); moveCursor(bounds.xy + vec2(3,20)); bounds.y -=40.;\n#define EASYSLIDERB(id,val, lo, hi) drawSlider(id, val, ui, pixel, bounds, vec2(lo,hi)); moveCursor(bounds.xy + vec2(3,20)); bounds.y -=40.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Fast pass: if the mouse isn't clicked in our box, just passthrough.\n    if (iFrame > 0 && (iMouse.z <= 0. || iMouse.y > bounds.y && iMouse.x > (bounds.z + bounds.x)) ) {\n        fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n        return;\n    }\n    \n    vec2 p = fragCoord.xy;\n    result = p.y<2.0 ? vec4(texture(iChannel0, p/iResolution.xy).rgb, 0) : vec4(0);\n    newText(p,vec2(0)); //for labels\n    \n    //define sliders    \n    EASYSLIDERB(1,2.0,0,10)  _S C A L E\n    EASYSLIDERB(2,.1,-3.15,3.15)  _A N G L E _1\n    EASYSLIDERB(3,.1,-3.15,3.15)  _A N G L E _2\n    EASYSLIDERB(4,-2.0,-10,10)  _O F F S E T _X     \n    EASYSLIDERB(5,-2.0,-10,10)  _O F F S E T _Y     \n    EASYSLIDERB(6,.5,-10,10)  _O F F S E T _Z       \n    EASYSLIDERB(7,3.0,.1,20)  _O R B I T    \n          \n      //  vec3(-2,-2,.5)\n        \n    result = mix(result, vec4(UI_COLOR,1), ui); //add sliders\n    result = mix(result, vec4(UI_COLOR,1), text.w*.8); //add labels\n    \n    fragColor=result;\n}","name":"Buffer B","description":"","type":"buffer"}]}