{"ver":"0.1","info":{"id":"4ssGWS","date":"1486230228","viewed":774,"name":"metal meta thing","username":"Kecho","description":"your typical SDF.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarchingfun"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Kleber Garcia (c) 2017\n\nconst float EPSILON = 0.001;\nconst vec3 AMBIENT = vec3(0.6, 0.4, 0.3);\nvec3 gDirLight1 = normalize(vec3(-0.1, 0.2, -1));\nvec3 gLightPos1 = vec3(-1, 1, -8);\n\n#define SATURATE(x) clamp(x, 0.0, 1.0)\n#define NORMOBJ(o,p) normalize(vec3(o(p.xyz + dif.xyy)-o(p.xyz - dif.xyy),o(p.xyz + dif.yxy)-o(p.xyz - dif.yxy),o(p.xyz+dif.yyx)-o(p.xyz-dif.yyx)))\n#define PI 3.14159265359\n#define HALF_PI (PI / 2.0)\nvec4 SPHERE1 = vec4(0, 0, 3, 2.5); //xyz pos, w radius\nfloat genericSphere(vec3 pos, vec4 sphere)\n{\n\treturn length(sphere.xyz - pos) - sphere.w;\n}\n\nfloat sphere1(vec3 pos)\n{\n\treturn genericSphere(pos, SPHERE1);\n}\n\nvec2 getSphereUv(const in vec3 pos, const vec3 center, vec3 norm)\n{\n\tvec3 dir = normalize(pos - center);\n\tvec2 orz = normalize(dir.xz);\n\tfloat sigmaU = 1.0 - (acos(orz.x) / PI);//optimize arccos with fast impl!!!\n\tfloat thetaV = acos(dir.y) / PI;\n\tfloat u = sigmaU * 0.5 + 0.5;\n\tfloat v = thetaV * 0.5 + 0.5;\n\treturn vec2(u, v);\n}\n\n\nvec2 scene(vec3 pos, out vec3 intersectP)\n{\n\n    intersectP = pos + vec3(sin(pos.y + iTime),0,0);\n    intersectP.y += 0.3*sin(pos.x + iTime);\n    intersectP.x -= 0.5*cos(4.0*(pos.y + iTime));\n    intersectP.y -= 0.5*cos(2.5+2.3*(pos.x + 3.0*iTime));    \n    intersectP.y -= 0.5*sin(0.8+pos.x + 2.0*iTime);\n    intersectP.z += 0.1*sin(0.9+pos.x + 1.35*iTime);\n    intersectP.x -= 0.2*cos(1.9+0.2*pos.y + 1.4*iTime);    \n    intersectP.x += 0.5*sin(1.9+4.2*pos.y + 0.3*iTime);\n    intersectP.y += 0.2*cos(2.5+0.7*pos.y + 0.32*iTime);\n    intersectP.x += 0.2*sin(4.6+6.5*pos.y + 1.45*iTime);\n    intersectP.x -= 0.1*cos(1.9+0.6*pos.y + 0.6*iTime);\n        \n\n\tfloat s1 = sphere1(intersectP);\n\tfloat d = s1;\n\tfloat matId = 1.0;\n\treturn vec2(d, matId);\n}\n\nvec2 raymarch(const in vec3 camPos, const in vec3 rayDir, out vec3 posOut, out vec3 pp)\n{\n\tvec2 d = vec2(1000.0, 0.0);\n\tvec3 pos = camPos;\n    vec3 intersectP = vec3(0,0,0);\n\tfor (int i = 0; i < 80; ++i)\n\t{\n\t\tif (d.x < EPSILON)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n        \n\t\td = scene(pos, intersectP);\n        pp = \n\t\tpos += d.x*rayDir;\n\t}\n\tposOut = intersectP;\n\treturn d;\n}\n\n\n\nvec3 norm(vec3 pos, float matId)\n{\n\tvec3 n = vec3(0,0,0);\n\tvec2 dif = vec2(EPSILON, 0.0);\n\tn = NORMOBJ(sphere1, pos);\t\n\t\n\treturn n;\n}\n\nvec3 material(float matId, vec3 normal, vec3 posOut, out vec3 normOut, out vec3 specTint)\n{\n\tvec3 col = vec3(1,1,1);\n\tspecTint = vec3(1,1,1);\n\tnormOut = normal;\n\tif (matId == 1.0)\n\t{\n\t\tvec2 uv = getSphereUv(posOut, SPHERE1.xyz, normal);\n\t\tcol = vec3(0.2,0.5,0.3) ;\n\t\tspecTint = vec3(0.5, 0.6, 0.2);\n\t\tnormOut.x += 0.2 * sin(uv.y*uv.x * 150.0) - 0.3 * cos(uv.y * 150.0);\n\t\tnormOut.y += 0.4 * sin(uv.x*uv.y * 250.0) + 0.3 * cos(uv.x * 150.0);\n\n\t\tnormOut = normalize(normOut);\n\t\tvec2 newUv = uv.xy + 0.001*normOut.xy;\n\t\t\n\t\t\n\t\tvec2 muls = abs(vec2(1, 1) - 900.0*abs(vec2(mod(newUv.x, 0.003) - 0.0002, mod(newUv.y, 0.003) - 0.0002)));// , );\n\t\tnormOut.xy -= 0.3 * muls;\n\t\tnormOut = normalize(normOut);\n\t\t\n\t}\n\telse if (matId == 2.0)\n\t{\n\t\tcol = vec3(1,1,1);\n\t}\n\t\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tfloat gAspect = iResolution.x / iResolution.y;    \n\tvec2 gMouseHomogeneous = 4.0*((iMouse.xy / iResolution.xy) * 2.0 - 1.0);\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec3 homogeneousPos = vec3(uv * 2.0 - 1.0, 0.0);\n\thomogeneousPos.x *= gAspect;\n\tvec3 camPos = vec3(0, 0, -1);\n\tvec3 camPivot = vec3(0, 0, 3);\n\tvec3 seeDir = normalize(camPos - camPivot);\n\tvec3 screenDir = normalize(homogeneousPos - camPivot);\n\tfloat initAngle =  (HALF_PI / 150.0) * (sin(iTime * 2.7));\n\tfloat initAngleVet =  (HALF_PI / 150.0) * (cos(iTime * 3.0));\n\tfloat angle = HALF_PI + initAngle + (-gMouseHomogeneous.x) * 0.1;//(iTime * 0.9);\n\tfloat angleVert = HALF_PI + initAngleVet + (-gMouseHomogeneous.y) * 0.1;//(iTime * 0.9);;\n\t\n\tvec2 cosSinAngle = vec2(sin(angle), cos(angle));\n\tvec2 cosSinAngleVert = vec2(sin(angleVert), cos(angleVert));\n\t\n\tseeDir.xz = vec2( dot( seeDir.xz, cosSinAngle.xy ), dot( seeDir.xz, vec2(-cosSinAngle.y, cosSinAngle.x) ) );\n\tscreenDir.xz = vec2( dot( screenDir.xz, cosSinAngle.xy ), dot( screenDir.xz, vec2(-cosSinAngle.y, cosSinAngle.x) ) );\n\t\n\tseeDir.yz = vec2( dot( seeDir.yz, cosSinAngleVert.xy ), dot( seeDir.yz, vec2(-cosSinAngleVert.y, cosSinAngleVert.x) ) );\n\tscreenDir.yz = vec2( dot( screenDir.yz, cosSinAngleVert.xy ), dot( screenDir.yz, vec2(-cosSinAngleVert.y, cosSinAngleVert.x) ) );\n\t\n\t\n\tcamPos = seeDir * length(camPos - camPivot) + camPivot;\n\thomogeneousPos = screenDir * length(homogeneousPos - camPivot) + camPivot;\n\t\n\t\n\t\n\tvec3 rayDir = normalize(homogeneousPos - camPos);\n\tvec3 finalCol = 2.9*vec3(vec3(1.0 - uv.y) * 0.3) * vec3(0.7,0.7,0.8);\n\tvec3 posOut; vec3 pp;\n\tvec2 d = raymarch(camPos, rayDir, posOut, pp);\n\tif (d.x < EPSILON )\n\t{\n\t\tvec3 lightDir = normalize(gLightPos1 - posOut);\n\t\tvec3 n = norm(pp, d.y);\n\t\tvec3 normOut = vec3(0,0,0);\n\t\tvec3 specTint = vec3(0,0,0);\n\t\tvec3 col = material(d.y, n, pp, normOut, specTint);\n\t\tvec3 viewVec = normalize(camPos - posOut);\n\t\tfloat diff = max(dot(normOut, lightDir), 0.0);\n\t\tvec3 h = normalize(normOut + viewVec);\n\t\tvec3 spec = 1.0*pow(max(dot(h, lightDir), 0.0), 64.0)*specTint;\n\t\tvec3 fresnel = 0.08*vec3(pow(max(1.0-dot(viewVec, normOut), 0.0),8.0))*specTint;\n        \n\t\tfinalCol =  col*(diff + AMBIENT) + spec + fresnel ;\t\t\n\t}\n\t\n\tfragColor = vec4(pow(finalCol,vec3(2.2)), 1.0);\n}","name":"Image","description":"","type":"image"}]}