{"ver":"0.1","info":{"id":"cdGyWW","date":"1696160127","viewed":348,"name":"PEACHY","username":"alro","description":"A plump, juicy peach covered in soft fuzz","likes":49,"published":1,"flags":32,"usePreview":0,"tags":["sss","sdf","soft","pbr","sheen","fuzz"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Rendering fuzzy hair using sheen for a soft velvet effect\n*/\n\n// Set false to render a nectarine\nconst bool renderFuzz = true;\n\nconst float sheenRoughness = 0.65;\n\nconst float lightAzimuth = 3.0;\nconst float lightHeight = 0.7;\n\nconst int MAX_STEPS = 80;\nconst float MIN_DIST = 0.01;\nconst float MAX_DIST = 100.0;\n\nconst float EPSILON = 1e-4;\nconst float DETAIL_EPSILON = 2e-3;\n\nconst float DETAIL_HEIGHT = 0.05;\nconst vec3 DETAIL_SCALE = vec3(3.0);\n\nconst vec3 BLENDING_SHARPNESS = vec3(32.0);\n\nvec3 getEnvironment(vec3 rayDir){\n    return 1.5 * mix(vec3(0.15), vec3(0.5), 0.5 + 0.5 * rayDir.y);\n}\n\nvec3 rayDirection(float fieldOfView, vec2 fragCoord) {\n    vec2 xy = fragCoord - iResolution.xy / 2.0;\n    float z = (0.5 * iResolution.y) / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n// https://www.geertarien.com/blog/2017/07/30/breakdown-of-the-lookAt-function-in-OpenGL/\nmat3 lookAt(vec3 camera, vec3 at, vec3 up){\n  vec3 zaxis = normalize(at-camera);    \n  vec3 xaxis = normalize(cross(zaxis, up));\n  vec3 yaxis = cross(xaxis, zaxis);\n\n  return mat3(xaxis, yaxis, -zaxis);\n}\n\n//-------------------------------- Rotations --------------------------------\n\nvec3 rotate(vec3 p, vec4 q){\n  return 2.0 * cross(q.xyz, p * q.w + cross(q.xyz, p)) + p;\n}\nvec3 rotateX(vec3 p, float angle){\n    return rotate(p, vec4(sin(angle/2.0), 0.0, 0.0, cos(angle/2.0)));\n}\nvec3 rotateY(vec3 p, float angle){\n\treturn rotate(p, vec4(0.0, sin(angle/2.0), 0.0, cos(angle/2.0)));\n}\nvec3 rotateZ(vec3 p, float angle){\n\treturn rotate(p, vec4(0.0, 0.0, sin(angle/2.0), cos(angle/2.0)));\n}\n\n\n//---------------------------- Shape operations ----------------------------\n\nfloat displacement(vec3 p){\n    return sin(p.x)*sin(p.y)*sin(p.z);\n}\n\nfloat opSmoothSub( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n    \nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\nfloat opSmoothMin(float a, float b, float k){\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n//---------------------------- Distance functions ----------------------------\n\nfloat sphereSDF(vec3 p, float radius){\n    return length(p) - radius;\n}\n\nfloat sdBox( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCappedTorus(vec3 p, vec2 sc, float ra, float rb){\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdRoundCone( vec3 p, float r1, float r2, float h ){\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat getStemDist(vec3 p){\n    vec3 q = p;\n    q.x += 0.35;\n    q.y -= 0.35;\n    q.z += 0.1;\n    q = rotateX(q, 0.05);\n    q = rotateZ(q, 0.05);\n    float d = sdRoundCone(q, 0.055, 0.05, 0.2);\n    \n    q = p;\n    q.x += 0.3;\n    q.y -= 0.65;\n    q.z += 0.1;\n    d = opSmoothSub(sphereSDF(q, 0.105), d, 0.01);\n    \n    return d;\n}\n\nfloat getSDF(vec3 p) {\n    p.x -= 0.35;\n    p.z -= 0.25;\n    vec3 q = p;\n    \n    float d = sphereSDF(q, 0.8);\n    \n    q = p;\n    q.x += 0.7;\n    d = opSmoothMin(d, sphereSDF(q, 0.8), 0.01);\n    \n    q = p;\n    q.xz += 0.35;\n    q.z += 0.1;\n    d = opSmoothMin(d, sphereSDF(q, 0.8), 0.4);\n    \n    q = p;\n    q.y -= 0.5;\n    q.x += 0.35;\n    q.z += 0.1;\n    d = opSmoothSub(sdRoundCone(q, 0.01, 1.5, 3.5), d, 0.5);\n    \n    q = p;\n    q.x += 0.35;\n    q.z += 0.15;\n    d = opSmoothIntersection(d, sphereSDF(q, 0.9), 0.3);\n    \n    q = p;\n    q.x += 0.35;\n    q.z += 0.15;\n    q.y += 1.1;\n    d = opSmoothIntersection(d, sdRoundCone(q, 0.3, 2.5, 3.0), 0.9);\n    \n    d += 0.01 * displacement(6.0 * p);\n    \n    d = opSmoothMin(d, getStemDist(p), 0.0);\n    \n    return d;\n}\n\nfloat distanceToScene(vec3 cameraPos, vec3 rayDir, float start, float end){\n\t\n    // Start at a predefined distance from the camera in the ray direction\n    float depth = start;\n    \n    // Variable that tracks the distance to the scene at the current ray endpoint\n    float dist;\n    \n    // For a set number of steps\n    for (int i = ZERO; i < MAX_STEPS; i++) {\n        \n        // Get the sdf value at the ray endpoint, giving the maximum \n        // safe distance we can travel in any direction without hitting a surface\n        dist = getSDF(cameraPos + depth * rayDir);\n        \n        // If it is small enough, we have hit a surface\n        // Return the depth that the ray travelled through the scene\n        if (dist < EPSILON){\n            return depth;\n        }\n        \n        // Else, march the ray by the sdf value\n        depth += 0.8 * dist;\n        \n        // Test if we have left the scene\n        if (depth >= end){\n            return end;\n        }\n    }\n\n    return depth;\n}\n\n//----------------------------- Normal mapping -----------------------------\n\nvec3 getTexture(vec2 uv, vec2 scaleSize){\n    return texture(iChannel2, scaleSize * (scaleSize.x < 1.0 ? fract(uv) : uv)).rgb;\n}\n\n// https://tinyurl.com/y5ebd7w7\nvec3 getTriplanar(vec3 position, vec3 normal, vec2 scaleSize){\n\n    vec3 xaxis = vec3(getTexture(DETAIL_SCALE.x*(position.zy), scaleSize));\n    vec3 yaxis = vec3(getTexture(DETAIL_SCALE.y*(position.zx), scaleSize));\n    vec3 zaxis = vec3(getTexture(DETAIL_SCALE.z*(position.xy), scaleSize));\n   \n    vec3 blending = abs(normal);\n\tblending = normalize(max(blending, 0.00001));\n    blending = pow(blending, BLENDING_SHARPNESS);\n\tfloat b = (blending.x + blending.y + blending.z);\n\tblending /= b;\n\n    return\txaxis * blending.x + \n       \t\tyaxis * blending.y + \n        \tzaxis * blending.z;\n}\n\n// Return the position of p extruded in the normal direction by normal map\nvec3 getDetailExtrusion(vec3 p, vec3 normal, vec2 scaleSize){\n    float detail = DETAIL_HEIGHT * length(getTriplanar(p, normal, scaleSize));\n    \n    return p + detail * normal;\n}\n\n// Tetrahedral normal technique with a loop to avoid inlining getSDF()\n// This should improve compilation times\n// https://iquilezles.org/articles/normalsSDF\nvec3 getNormal(vec3 p){\n    vec3 n = vec3(0.0);\n    int id;\n    for(int i = ZERO; i < 4; i++){\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*getSDF(p+e*EPSILON);\n    }\n    return normalize(n);\n}\n\n// Return the normal after applying a normal map\nvec3 getDetailNormal(vec3 p, vec3 normal, vec2 scaleSize){\n\n    vec3 tangent;\n    vec3 bitangent;\n    \n    // Construct orthogonal directions tangent and bitangent to sample detail gradient in\n    pixarONB(normal, tangent, bitangent);\n    \n    tangent = normalize(tangent);\n    bitangent = normalize(bitangent);\n\n    vec3 delTangent = vec3(0);\n    vec3 delBitangent = vec3(0);\n    \n    for(int i = ZERO; i < 2; i++){\n       \n        float s = 1.0 - 2.0 * float(i&1);\n    \n        delTangent += s * getDetailExtrusion(p + s * tangent * DETAIL_EPSILON, normal, scaleSize);\n        delBitangent += s * getDetailExtrusion(p + s * bitangent * DETAIL_EPSILON, normal, scaleSize);\n\n    }\n    \n    return normalize(cross(delTangent, delBitangent));\n}\n\n//--------------------------------- PBR ---------------------------------\n\n// Charlie\nfloat sheenDistribution(float NdotH, float roughness){\n    float a = clamp(roughness * roughness, 1e-5, 1.0);\n    float invR = 1.0 / a;\n    float cos2h = NdotH * NdotH;\n    float sin2h = 1.0 - cos2h;\n    return (2.0 + invR) * pow(sin2h, invR * 0.5) / (2.0 * PI);\n}\n\nfloat sheenVisibility(vec3 n, vec3 v, vec3 l){\n    float NdotL = dot_c(n, l);\n    float NdotV = dot_c(n, v);\n    // Neubelt and Pettineo\n    return clamp(1.0 / (4.0 * (NdotL + NdotV - NdotL * NdotV)), 0.0, 1.0);\n}\n\nfloat sheenBRDF(vec3 n, vec3 v, vec3 l, float roughness){\n    vec3 h = normalize(v + l);\n    float NdotH = dot_c(n, h);\n    float D = sheenDistribution(NdotH, roughness);\n    float V = sheenVisibility(n, v, l);\n    return clamp(D * V, 0.0, 1.0);\n}\n\nfloat max3(vec3 v) { return max(max(v.x, v.y), v.z); }\n\n// Trowbridge-Reitz\nfloat distribution(vec3 n, vec3 h, float roughness){\n    float a2 = roughness * roughness;\n    return a2 / (PI * pow(pow(dot_c(n, h), 2.0) * (a2 - 1.0) + 1.0, 2.0));\n}\n\n// GGX and Schlick-Beckmann\nfloat geometry(float cosTheta, float k){\n    return cosTheta / (cosTheta * (1.0 - k) + k);\n}\n\nfloat smiths(float NdotV, float NdotL, float roughness){\n    float k = pow(roughness + 1.0, 2.0) / 8.0; \n\treturn geometry(NdotV, k) * geometry(NdotL, k);\n}\n\n// Fresnel-Schlick\nvec3 fresnel(float cosTheta, vec3 F0){\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness){\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n// https://www.shadertoy.com/view/llXBWn\nvec3 sss( float ndl, float ir ){\n    float pndl = clamp( ndl, 0.0, 1.0 );\n    float nndl = clamp(-ndl, 0.0, 1.0 );\n\n    return vec3(pndl) +  vec3(1.0,0.25,0.01)*0.7*pow(clamp(ir*0.75-nndl,0.0,1.0),2.0);\n\n}\n\n// Cook-Torrance BRDF\nfloat specularBRDF(vec3 n, vec3 viewDir, vec3 lightDir, vec3 h, float roughness){\n    \n    // Normal distribution\n    // What fraction of microfacets are aligned in the correct direction\n    float D;\n\n    // Geometry term\n    // What fraction of the microfacets are lit and visible\n    float G;\n    \n    // Visibility term. \n    // In Filament it combines the geometry term and the denominator\n    float V;\n    \n    float NdotL = dot_c(lightDir, n);\n    float NdotV = dot_c(viewDir, n);\n    \n    D = distribution(n, h, roughness);\n    G = smiths(NdotV, NdotL, roughness);\n    V = G / max(0.0001, (4.0 * NdotV * NdotL));\n        \n    // Specular reflectance\n    return D * V;\n}\n\n\nvec3 getBRDFIntegrationMap(vec2 texCoord, vec2 scaleSize){\n    return texture(iChannel1, scaleSize * texCoord).rgb;\n}\n\n\n//------------------------------- Shading -------------------------------\n\n// https://www.shadertoy.com/view/4djSRW\nvec3 hash(vec3 p3){\n    p3 = fract(p3 * vec3(0.1031, 0.1030, 0.0973));\n    p3 += dot(p3, p3.yxz + 33.33);\n    return 2.0 * fract((p3.xxy + p3.yxx) * p3.zyx) - 1.0;\n}\n\nfloat worley(vec3 pos, float numCells){\n\tvec3 p = pos * numCells;\n\tfloat d = 1.0e10;\n\tfor (int x = -1; x <= 1; x++){\n\t\tfor (int y = -1; y <= 1; y++){\n\t\t\tfor (int z = -1; z <= 1; z++){\n                vec3 tp = floor(p) + vec3(x, y, z);\n                tp = p - tp - (0.5 + 0.5 * hash(mod(tp, numCells)));\n                d = min(d, dot(tp, tp));\n            }\n        }\n    }\n\treturn saturate(d);\n}\n\nvec3 getAlbedo(vec3 p, vec3 normal){\n    p.z -= 0.15;\n    float polar = (atan(p.z, p.x)+PI)/TWO_PI;\n    float azimuth = acos(p.y/length(p))/PI;\n    float d = length(texture(iChannel3, vec2(polar, 0.1*azimuth)).rgb);\n    vec3 col = mix(vec3(1.0, 0.01, 0.01), vec3(1.0, 0.01, 0.01), smoothstep(0.25, 1.0, azimuth));\n    \n    float dist;\n    \n    dist = smoothstep(-0.15, 0.5, worley(vec3(polar, 0.5*azimuth, 0.0), 8.0));\n    col = mix(mix(col, vec3(1.0, 0.2, 0.0), 0.5), col, dist);\n    \n    dist = smoothstep(0.0, 0.8, worley(vec3(polar, 0.15*azimuth, 0.0), 16.0));\n    col = mix(vec3(1.0, 0.1, 0.0), col, dist);\n    \n    col = mix(col, vec3(1.0, 0.01, 0.0), smoothstep(-0.0, 1.0, azimuth));\n    \n    dist = smoothstep(0.0, 0.3, worley(p, 64.0));\n    col = mix(vec3(0.9, 0.02, 0.0), col, dist);\n    \n    dist = smoothstep(-0.5, 0.8, worley(p, 3.0));\n    col = mix(vec3(0.8, 0.01, 0.0), col, dist);\n    \n    dist = smoothstep(0.1, 0.35, azimuth + 0.05*sin(4.0*TWO_PI*polar));\n    col = mix(mix(col, vec3(1, 0.3, 0.0), 0.5), col, dist);\n    \n    dist = smoothstep(0.1, 0.2, azimuth + 0.025*sin(5.0*TWO_PI*polar));\n    col = mix(mix(col, vec3(1, 0.3, 0.0), 0.75), col, dist);\n   \n    return col;\n}\n\nvec3 shadingPBR(vec3 p, vec3 rayDir, vec3 normal, vec2 scaleSize){\n\n    vec3 sheenNormal = normalize(getDetailNormal(p, normal, scaleSize));\n        \n    vec3 direct = vec3(0);\n\n    float fuzz = length(getTriplanar(p, normal, scaleSize));\n\n    vec3 albedo = getAlbedo(p, normal) + clamp(10.0 * fuzz, 0.0, 1.0);\n    \n    vec3 F0 = vec3(0.04);\n    float roughness = 0.5;\n    float metalness = 0.0;\n    \n    vec3 q = p;\n    q.x -= 0.35;\n    q.z -= 0.25;\n    bool stem = getStemDist(q) < 1e-4;\n\n    vec3 lightPosition = 10.0 * normalize(vec3(cos(lightAzimuth), lightHeight, sin(lightAzimuth)));\n\n    vec3 vectorToLight = lightPosition - p;\n   \tvec3 lightDir = normalize(vectorToLight);\n    \n    vec3 radiance = 5.0*vec3(1, 0.95, 0.75);\n    \n    vec3 h = normalize(-rayDir + lightDir);\n    \n    if(stem){\n        albedo = vec3(0.25, 0.01, 0.01);\n        float dist = smoothstep(-0.0, 0.75, worley(q, 8.0));\n        albedo = mix(vec3(0.75, 0.2, 0.0), albedo, dist);\n        roughness = mix(0.8, 0.2, dist);\n    }\n\n    // Fresnel term\n    // How reflective are the microfacets viewed from the current angle\n    vec3 F = fresnelSchlickRoughness(dot_c(h, -rayDir), F0, roughness);\n    vec3 specular = F * specularBRDF(normal, -rayDir, lightDir, h, roughness);\n\n    float d = dot(normal, lightDir);\n    vec3 diffuse = sss(d, 0.45);\n    //return diffuse;\n    \n    if(stem){\n        diffuse = albedo / PI;\n    }\n\n    vec3 directDiffuse = diffuse * albedo;\n    vec3 directSpecular = specular * radiance * dot_c(normal, lightDir);\n    \n    if(stem){\n        vec3 kD = (1.0 - F) * (1.0 - metalness);\n        directDiffuse = (kD * directDiffuse) * dot_c(normal, lightDir);\n    }\n    \n    direct = directDiffuse + directSpecular;\n    vec3 sheenColor = clamp(vec3(0.15) + 75.0 * fuzz, 0.0, 1.0);\n\n    float directionalAlbedo = getBRDFIntegrationMap(vec2(dot_c(sheenNormal, -rayDir), sheenRoughness), scaleSize).b;\n    float albedoScaling = 1.0 - max3(sheenColor) * directionalAlbedo;\n    vec3 directSheen = vec3(5) * sheenColor * sheenBRDF(sheenNormal, -rayDir, lightDir, sheenRoughness) * dot_c(sheenNormal, lightDir);\n  \n    if(!stem && renderFuzz){\n        direct = directSheen + albedoScaling * direct;\n    }\n\n    // Find ambient diffuse IBL component\n    F = fresnelSchlickRoughness(dot_c(normal, -rayDir), F0, roughness);\n    vec3 kD = saturate(1.0 - F) * (1.0 - metalness);\t\n    vec3 irradiance = getEnvironment(normal);\n    diffuse = irradiance * albedo.rgb / PI;\n\n    // Find ambient specular IBL component\n    vec3 R = reflect(rayDir, normal);\n\n    vec3 prefilteredColor = getEnvironment(R);\n    vec2 envBRDF = getBRDFIntegrationMap(vec2(dot_c(normal, -rayDir), roughness), scaleSize).rg;\n    specular = prefilteredColor * mix(envBRDF.xxx, envBRDF.yyy, F0);\n\n    vec3 ambient = kD * diffuse + specular;\n    \n    if(!stem && renderFuzz){\n        vec3 ambientSheen = sheenColor * getEnvironment(normalize(reflect(-rayDir, sheenNormal))) * directionalAlbedo;\n        ambient = ambientSheen + albedoScaling * ambient;\n    }\n    \n    return ambient + direct;\n}\n\n//----------------------------- Tonemapping and output ------------------------------\n\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x){\n    return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    vec2 renderSize = texelFetch(iChannel1, ivec2(0.5), 0).rg;\n    vec2 scaleSize = 1.0 / (iResolution.xy / renderSize);\n    \n    \n\t//----------------- Define a camera -----------------\n    \n    vec3 rayDir = rayDirection(30.0, fragCoord);\n\n    vec3 cameraPos = texelFetch(iChannel0, ivec2(0.5, 1.5), 0).xyz;\n\n    vec3 targetDir = -cameraPos;\n\n    vec3 up = vec3(0.0, 1.0, 0.0);\n\n    // Get the view matrix from the camera orientation.\n    mat3 viewMatrix = lookAt(cameraPos, targetDir, up);\n\n    // Transform the ray to point in the correct direction.\n    rayDir = normalize(viewMatrix * rayDir);\n\n    //---------------------------------------------------\n\n    // Find the distance to where the ray stops.\n    float dist = distanceToScene(cameraPos, rayDir, MIN_DIST, MAX_DIST);\n    \n    vec3 col = vec3(0);\n    \n    if(dist < MAX_DIST){\n        vec3 position = cameraPos + rayDir * dist;\n        vec3 geoNormal = getNormal(position);\n        col = shadingPBR(position, rayDir, geoNormal, scaleSize);\n    } else {\n        col = vec3(0.1);\n    }\n    \n    // Tonemapping\n    col = ACESFilm(col);\n    \n    // Gamma\n    col = pow(col, vec3(0.4545));\n    \n    // Render hair heightmap\n    //col = 100.0 * texture(iChannel2, (fragCoord/iResolution.xy)*scaleSize).rgb;\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\n    Copyright (c) 2023 al-ro\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the \"Software\"), to deal\n    in the Software without restriction, including without limitation the rights\n    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all\n    copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n    SOFTWARE.\n*/\n\n#define PI 3.14159\n#define TWO_PI (2.0*PI)\n\n// Variable iterator initializer to stop loop unrolling\n#define ZERO (min(iFrame,0))\n\n// Minimum dot product value\nconst float minDot = 1e-3;\n\n// Clamped dot product\nfloat dot_c(vec3 a, vec3 b){\n\treturn max(dot(a, b), minDot);\n}\n\nfloat saturate(float x){\n\treturn clamp(x, 0.0, 1.0);\n}\n\nvec3 saturate(vec3 x){\n\treturn clamp(x, 0.0, 1.0);\n}\n\n// Get orthonormal basis from surface normal\n// https://graphics.pixar.com/library/OrthonormalB/paper.pdf\nvoid pixarONB(vec3 n, out vec3 b1, out vec3 b2){\n\tfloat sign_ = n.z >= 0.0 ? 1.0 : -1.0;\n\tfloat a = -1.0 / (sign_ + n.z);\n\tfloat b = n.x * n.y * a;\n\tb1 = vec3(1.0 + sign_ * n.x * n.x * a, sign_ * b, -sign_ * n.x);\n\tb2 = vec3(b, sign_ + n.y * n.y * a, -n.y);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n    Track mouse movement and resolution change between frames and set camera position.\n*/\n\n#define EPS 1e-4\n#define CAMERA_DIST 3.25\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    //Work with just the first four pixels.\n    if((fragCoord.x == 0.5) && (fragCoord.y < 4.0)){\n        \n        vec4 oldData = texelFetch(iChannel0, ivec2(0.5), 0).xyzw;\n\n        vec2 oldPolarAngles = oldData.xy;\n        vec2 oldMouse = oldData.zw;\n\n        vec2 polarAngles = vec2(0);\n        vec2 mouse = iMouse.xy / iResolution.xy; \n        \n        // Stop camera going directly above and below\n        float angleEps = 0.01;\n\n        float mouseDownLastFrame = texelFetch(iChannel0, ivec2(0.5, 3.5), 0).x;\n        \n        // If mouse button is down and was down last frame.\n        if(iMouse.z > 0.0 && mouseDownLastFrame > 0.0){\n            \n            // Difference between mouse position last frame and now.\n            vec2 mouseMove = mouse - oldMouse;\n            polarAngles = oldPolarAngles + vec2(5.0, 3.0) * mouseMove;\n            \n        }else{\n            polarAngles = oldPolarAngles;\n        }\n        \n        polarAngles.x = mod(polarAngles.x, 2.0 * PI - angleEps);\n        polarAngles.y = min(PI - angleEps, max(angleEps, polarAngles.y));\n\n        // Store mouse data in the first pixel of Buffer A.\n        if(fragCoord == vec2(0.5, 0.5)){\n            // Set value at first frames.\n            if(iFrame < 1){\n                polarAngles = vec2(-1.25, 1.1);\n                mouse = vec2(0);\n            }\n            fragColor = vec4(polarAngles, mouse);\n        }\n\n        // Store camera position in the second pixel of Buffer A.\n        if(fragCoord == vec2(0.5, 1.5)){\n            // Cartesian direction from polar coordinates.\n            vec3 cameraPos = normalize(vec3(-cos(polarAngles.x) * sin(polarAngles.y), \n                                             cos(polarAngles.y), \n                                            -sin(polarAngles.x) * sin(polarAngles.y)));\n\n            fragColor = vec4(CAMERA_DIST * cameraPos, 1.0);\n        }\n        \n        //Store resolution change data in the third pixel of Buffer B.\n        if(fragCoord == vec2(0.5, 2.5)){\n            float resolutionChangeFlag = 0.0;\n            //The resolution last frame.\n            vec2 oldResolution = texelFetch(iChannel0, ivec2(0.5, 2.5), 0).yz;\n            \n            if(iResolution.xy != oldResolution){\n            \tresolutionChangeFlag = 1.0;\n            }\n            \n        \tfragColor = vec4(resolutionChangeFlag, iResolution.xy, 1.0);\n        }\n           \n        //Store whether the mouse button is down in the fourth pixel of Buffer A\n        if(fragCoord == vec2(0.5, 3.5)){\n            if(iMouse.z > 0.0){\n            \tfragColor = vec4(vec3(1.0), 1.0);\n            }else{\n            \tfragColor = vec4(vec3(0.0), 1.0);\n            }\n        }\n        \n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*\n    BRDF LUT for split sum PBR and sheen directional albedo\n*/\n\n#define SAMPLE_COUNT 1024\n\nfloat radicalInverse(uint bits) {\n    bits = (bits << 16u) | (bits >> 16u);\n    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n    return float(bits) * 2.3283064365386963e-10; // / 0x100000000\n}\n\nvec2 hammersley(int i, int N){\n    return vec2(float(i)/float(N), radicalInverse(uint(i)));\n}\n\n// -------------------------------------------------------------------------------\n\n// From tangent-space vector to world-space sample vector\nvec3 rotateToNormal(vec3 L, vec3 N){\n    vec3 tangent;\n    vec3 bitangent;\n\n    pixarONB(N, tangent, bitangent);\n\n    tangent = normalize(tangent);\n    bitangent = normalize(bitangent);\n\n    return normalize(tangent * L.x + bitangent * L.y + N * L.z);\n}\n\n// Return a world-space halfway vector H around N which corresponds to the GGX normal\n// distribution. Reflecting the view ray on H will give a light sample direction\nvec3 importanceSampleGGX(vec2 Xi, vec3 N, float roughness){\n    float a = roughness*roughness;\n\n    // GGX importance sampling\n    float cosTheta = sqrt((1.0 - Xi.x) / (1.0 + (a * a - 1.0) * Xi.x));\n    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n    float phi = Xi.y * 2.0 * PI;\n\n    vec3 L = normalize(vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta));\n\n    return rotateToNormal(L, N);\n}\n\n// Schlick-Beckmann\nfloat geometry(float cosTheta, float k){\n\treturn (cosTheta) / (cosTheta * (1.0 - k) + k);\n}\n\nfloat smithShadowing(float NdotV, float NdotL, float roughness){\n    // IBL uses a different k than direct lighting\n    float k = (roughness*roughness) / 2.0; \n\treturn geometry(NdotV, k) * geometry(NdotL, k);\n}\n\n// https://github.com/DassaultSystemes-Technology/dspbr-pt/blob/e7cfa6e9aab2b99065a90694e1f58564d675c1a4/packages/lib/shader/bsdfs/sheen.glsl\n// Charlie\nfloat sheenDistribution(float NdotH, float roughness){\n    float a = clamp(roughness * roughness, 1e-5, 1.0);\n    float invR = 1.0 / a;\n    float cos2h = NdotH * NdotH;\n    float sin2h = 1.0 - cos2h;\n    return (2.0 + invR) * pow(sin2h, invR * 0.5) / (2.0 * PI);\n}\n\nfloat sheenVisibility(vec3 n, vec3 v, vec3 l){\n    float NdotL = dot_c(n, l);\n    float NdotV = dot_c(n, v);\n    // Neubelt and Pettineo\n    return clamp(1.0 / (4.0 * (NdotL + NdotV - NdotL * NdotV)), 0.0, 1.0);\n}\n\nfloat sheenBRDF(vec3 n, vec3 v, vec3 l, float roughness){\n    vec3 h = normalize(v + l);\n    float NdotH = dot_c(n, h);\n    float D = sheenDistribution(NdotH, roughness);\n    float V = sheenVisibility(n, v, l);\n    return clamp(D * V, 0.0, 1.0);\n}\n\n// https://google.github.io/filament/Filament.html#toc9.5\nvec3 integrateBRDF(float NdotV, float roughness, int sampleCount){\n    \n    // Surface normal\n    vec3 N = vec3(0.0, 0.0, 1.0);\n\n    // Generate view direction for fragment such that dot(N, V) is uv.x\n    vec3 V = normalize(vec3(sqrt(1.0 - NdotV * NdotV), 0.0, NdotV));\n\n    // To accumulate\n    vec3 result = vec3(0);\n    \n    for(int i = min(0, iFrame); i < sampleCount; i++){\n    \n        // Low discrepancy random point in uniform square\n        vec2 Xi = hammersley(i, sampleCount);\n        // Halfway vector\n        vec3 H = importanceSampleGGX(Xi, N, roughness);\n        // Light vector\n        vec3 L = normalize(reflect(-V, H));\n\n        float NdotL = dot_c(N, L);\n        float NdotH = dot_c(N, H);\n        float VdotH = dot_c(V, H);\n\n        if(NdotL > 0.0){\n            float G = smithShadowing(NdotV, NdotL, roughness);\n            float S = (G * VdotH) / (NdotH * NdotV);\n            \n            // Fresnel-Schlick\n            float F = pow(1.0 - VdotH, 5.0);\n\n            // Multiple scattering approach from Filament\n            result.x += F * S;\n            result.y += S;\n        }\n        \n        \n        // Generate uniform ray direction\n        float phi = Xi.y * 2.0 * PI;\n        float cosTheta = 1.0 - Xi.x;\n        float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n        \n        H = normalize(vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta));\n        L = normalize(reflect(-V, H));\n        \n        NdotL = dot_c(N, L);\n        VdotH = dot_c(V, H);\n        if(NdotL > 0.0){\n            result.z += 4.0 * TWO_PI * sheenBRDF(N, V, L, roughness) * NdotL * VdotH;\n        }\n    }\n\n    return result / float(sampleCount);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    if(iFrame == 0){\n        vec2 uv = fragCoord.xy/iResolution.xy;\n\n        float NdotV = uv.x;\n        float roughness = uv.y;\n\n        vec3 col = integrateBRDF(NdotV, roughness, SAMPLE_COUNT);\n        \n        // Store the size of the render\n        if(fragCoord.x == 0.5 && fragCoord.y == 0.5){\n             col = vec3(iResolution.xy, 0.0);\n        }\n\n        fragColor = vec4(col, 1.0);\n    }else{\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    }\n\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"/*\n    Trichome height map\n*/\n\nvec2 rotate(vec2 p, float a){\n    return mat2(cos(a), sin(a), -sin(a), cos(a)) * p;\n}\n\n//https://www.shadertoy.com/view/MlKcDD\n//Signed distance to a quadratic bezier\nfloat sdBezier(vec2 pos, vec2 A, vec2 B, vec2 C){    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n\n    float res = 0.0;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if(h >= 0.0){ \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = uv.x + uv.y - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 1 root\n        vec2 qos = d + (c + b*t)*t;\n        res = length(qos);\n    }else{\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = vec3(m + m, -n - m, n - m) * z - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 3 roots\n        vec2 qos = d + (c + b*t.x)*t.x;\n        float dis = dot(qos,qos);\n        \n        res = dis;\n\n        qos = d + (c + b*t.y)*t.y;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n\n        qos = d + (c + b*t.z)*t.z;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n\n        res = sqrt( res );\n    }\n    \n    return res;\n}\n\n\n#define SIZE 1024\n\n// https://www.shadertoy.com/view/4djSRW\nvec2 hash(vec2 p){\n    p = mod(p, float(SIZE));\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(0.1031, 0.1030, 0.0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return 2.0 * fract((p3.xx+p3.yz)*p3.zy) - 1.0;\n}\n\nfloat hash(float p){\n    p = fract(p * 0.1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat getHairHeight(vec2 pos, float id, vec2 cell){\n\n    float r = 0.005;\n    \n    vec2 rand = hash(43.11 * cell + vec2(22.0 * id, 30.9 * id));\n    pos += 0.25 * (2.0 * rand - 1.0);\n\n    pos = rotate(pos, TWO_PI * hash(12.0*id));\n\n    const int N = 4;\n    vec2 points[N];\n    points[0] = vec2(0.0, 0.0);\n    points[1] = vec2(mix(-0.025, 0.025, hash(float(id + 23.21))), 0.2);\n    points[2] = vec2(0.1, 0.4);\n    points[3] = vec2(0.1, 0.4);\n    \n    vec2 c = (points[0] + points[1]) / 2.0;\n    vec2 c_prev;\n    float dist = 1e10;\n    for(int i = 0; i < N-2; i++){\n        c_prev = c;\n        c = (points[i] + points[i+1]) / 2.0;\n        dist = min(dist, sdBezier(pos, c_prev, points[i], c));\n    }\n    \n    \n    float t = dist / r;\n    float z = sqrt(1.0-t*t) * r;\n    z *= smoothstep(r, 0.999*r, dist);\n    z *= mix(0.5, 1.0, hash(float(id + 2.1)));\n    z *= 3.0 * smoothstep(0.05, 0.45, pos.y);\n\n    return z;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    if(iFrame == 0){\n\n        vec2 uv = fragCoord/iResolution.xy;\n\n        // Number of tiles\n        float count = 6.0;\n        vec2 p = fract(count*uv);\n        vec2 cell = floor(count*uv);\n\n        p -= 0.5;\n        \n        float maxZ = 0.0;\n        \n        for(float x = -1.0; x <= 1.0; x++){\n            for(float y = -1.0; y <= 1.0; y++){\n                vec2 pp = p - vec2(x, y);\n                for(float i = 0.0; i < 64.0; i++){\n                    maxZ = max(maxZ, getHairHeight(pp, i, mod(cell+vec2(x, y), count)));\n                }\n            }\n        }\n        \n        vec3 col = vec3(maxZ);\n\n        fragColor = vec4(col, 1.0);\n    }else{\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    }\n}","name":"Buffer C","description":"","type":"buffer"}]}