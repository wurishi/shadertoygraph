{"ver":"0.1","info":{"id":"MlVfWw","date":"1543485188","viewed":355,"name":"Rhombicuboctahedron","username":"skaplun","description":"Another Dave's animation repro - https://twitter.com/beesandbombs/status/1064996921557815296\nAccording to the wiki page (https://en.wikipedia.org/wiki/Rhombicuboctahedron) it could be done much more effective.\niCappedCone function humbly borrowed from @iq","likes":24,"published":1,"flags":0,"usePreview":0,"tags":["opticalillusion","animation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3[RECT_V_COUNT] getBaseRect(){\n\treturn vec3[RECT_V_COUNT](vec3(-HALFSIZE, HALFSIZE, R1), vec3(vec2(-HALFSIZE), R1),\n                              vec3(HALFSIZE, -HALFSIZE, R1), vec3(vec2(HALFSIZE), R1));\n}\n\nvec3[TRIANG_V_COUNT] getBaseTriangle(){\n\tfloat size = sqrt(sqrt(SIZE) - sqrt(HALFSIZE)) * .915;\n    return vec3[TRIANG_V_COUNT](vec3(size * cos(radians(90.)), size * sin(radians(90.)), R2 * .98),\n            \t\t\t\t\tvec3(size * cos(radians(210.)), size * sin(radians(210.)), R2 * .975),\n    \t\t\t\t\t\t\tvec3(size * cos(radians(330.)), size * sin(radians(330.)), R2 * .975));\n}\n\nWorld makeWorld(float time){\n    mat3 zrot = zrotate(time);\n    vec3 baseRect[] = getBaseRect();\n    vec3 baseTriang[] = getBaseTriangle();\n    return World(Rect[12](Rect(baseRect, zrot * yrotate(PI * .25)),\n                          Rect(baseRect, zrot * yrotate(PI * .75)),\n                          Rect(baseRect, zrot * yrotate(PI * 1.25)),\n                          Rect(baseRect, zrot * yrotate(PI * 1.75)),\n                          Rect(baseRect, zrot * xrotate(PI * .25) * yrotate(PI * .5)),\n                          Rect(baseRect, zrot * xrotate(PI * .25) * yrotate(-PI * .5)),\n                          Rect(baseRect, zrot * xrotate(PI * .25) * yrotate(PI)),\n                          Rect(baseRect, zrot * xrotate(PI * .25)),\n                          Rect(baseRect, zrot * xrotate(PI * -.25) * yrotate(PI * .5)),\n                          Rect(baseRect, zrot * xrotate(PI * -.25) * yrotate(-PI * .5)),\n                          Rect(baseRect, zrot * xrotate(PI * -.25) * yrotate(PI)),\n                          Rect(baseRect, zrot * xrotate(PI * -.25))));\n}\n\nWorld2 makeWorld2(float time){\n    mat3 zrotR = zrotate(time);\n    mat3 zrotT = zrotate(time * 1.333333);\n    vec3 baseRect[] = getBaseRect();\n    vec3 baseTriang[] = getBaseTriangle();\n    return World2(Rect[6](Rect(baseRect, zrotR * yrotate(PI * .5)),\n                          Rect(baseRect, zrotR * yrotate(PI)),\n                          Rect(baseRect, zrotR * yrotate(PI * 1.5)),\n                          Rect(baseRect, zrotR * yrotate(PI * 2.)),\n                          Rect(baseRect, zrotR * xrotate(PI * .5)),\n                          Rect(baseRect, zrotR * xrotate(PI * -.5))),\n                  Triangle[8](Triangle(baseTriang, zrotT * xrotate(PI * .195) * yrotate(PI * .25)),\n                          \t  Triangle(baseTriang, zrotT * xrotate(PI * .195) * yrotate(PI * .75)),\n                          \t  Triangle(baseTriang, zrotT * xrotate(PI * .195) * yrotate(PI * 1.25)),\n                          \t  Triangle(baseTriang, zrotT * xrotate(PI * .195) * yrotate(PI * 1.75)),\n                          \t  Triangle(baseTriang, zrotT * zrotate(PI) * xrotate(PI * -.195) * yrotate(PI * .25)),\n                          \t  Triangle(baseTriang, zrotT * zrotate(PI) * xrotate(PI * -.195) * yrotate(PI * .75)),\n                          \t  Triangle(baseTriang, zrotT * zrotate(PI) * xrotate(PI * -.195) * yrotate(PI * 1.25)),\n                          \t  Triangle(baseTriang, zrotT * zrotate(PI) * xrotate(PI * -.195) * yrotate(PI * 1.75))));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 newRes = iResolution.xy * 5.;\n    vec3 clr = vec3(0.);\n    for (int i=-2; i<3; i++){\n\t\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n        float ang = iTime * .33 + (iResolution.x - iMouse.x) * .01;\n        vec3 eye = vec3(6. * sin(ang), 1.5, 6. * cos(ang));\n        mat4 viewToWorld = viewMatrix(eye, vec3(0.), vec3(0.0, 1.0, 0.0));\n        vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n\n        float time = mod(ang, PI);\n        float s = sign(time - PI * .5);\n        if(s >= 0.)\n            clr += hitAndColor(Ray(eye, worldDir), makeWorld(time));\n        else\n            clr += hitAndColor(Ray(eye, worldDir), makeWorld2(time));    \t\t\n    }\n    fragColor = vec4(clr/5., 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.1415\n#define MAX_FLOAT 1e5\n#define EDGE_W .025\n#define RECT_V_COUNT 4\n#define TRIANG_V_COUNT 3\n#define R1 1.\n#define R2 (R1/(R1 * cos(EDGE_SIZE)))\n#define EDGE_SIZE PI*.125\n#define SIZE distance(R2 * sin(-EDGE_SIZE), R2 * sin(EDGE_SIZE))\n#define HALFSIZE SIZE * .5\n#define WIRE_WIDTH .0075\n\nstruct Ray{vec3 origin, dir;};\nstruct Box{vec3 origin; vec3 bounds;};\nstruct Triangle{vec3 v[TRIANG_V_COUNT]; mat3 pos;};\nstruct Rect{vec3 v[RECT_V_COUNT]; mat3 pos;};\nstruct HitRecord{float dist; vec3 point, normal;};\nstruct World{Rect rects[12];};\nstruct World2{Rect rects[6]; Triangle tri[8];};\n    \nmat3 xrotate(float theta) {\n  return mat3(1,0,0,0,cos(theta),sin(theta),0,-sin(theta),cos(theta));\n}\n\nmat3 yrotate(float theta) {\n  return mat3(cos(theta),0,sin(theta),0,1,0,-sin(theta),0,cos(theta));\n}\n\nmat3 zrotate(float theta) {\n  return mat3(cos(theta),sin(theta),0,-sin(theta),cos(theta),0,0,0,1);\n}\n    \nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.;\n    float z = size.y / tan(radians(fieldOfView) / 2.);\n    return normalize(vec3(xy, -z));\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye),\n         s = normalize(cross(f, up)),\n         u = cross(s, f);\n    return mat4(vec4(s, 0.), vec4(u, 0.), vec4(-f, 0.), vec4(vec3(0.), 1.));\n}\n\nfloat computeDistance(vec3 ptnt, vec3 p0, vec3 p1) {\n    vec3 d = (p1 - p0) / distance(p1, p0);\n    vec3 v = ptnt - p0;\n    float t = dot(v, d);\n    vec3 P = p0 + t * d;\n    return distance(P, ptnt);\n}\n\nvec4 iCappedCone( in vec3  ro, in vec3  rd, \n                  in vec3  pa, in vec3  pb, \n                  in float ra, in float rb )\n{\n    vec3  ba = pb - pa;\n\tvec3  oa = ro - pa;\n\tvec3  ob = ro - pb;\n    float rr = ra - rb;\n    float m0 = dot(ba,ba);\n    float m1 = dot(ba,oa);\n    float m2 = dot(ba,rd);\n    float m3 = dot(rd,oa);\n    float m5 = dot(oa,oa);\n\tfloat m6 = dot(ob,rd);\n    float m7 = dot(ob,ob);\n    \n    float d2 = m0-rr*rr;\n    \n\tfloat k2 = d2    - m2*m2;\n    float k1 = d2*m3 - m1*m2 + m2*rr*ra;\n    float k0 = d2*m5 - m1*m1 + m1*rr*ra*2.0 - m0*ra*ra;\n    \n\tfloat h = k1*k1 - k0*k2;\n\tif(h < 0.0) return vec4(-1.0);\n    float t = (-sqrt(h)-k1)/k2;\n  //if( t<0.0 ) return vec4(-1.0);\n\n    float y = m1 - ra*rr + t*m2;\n    if( y>0.0 && y<d2 ) \n    {\n        return vec4(t, normalize( d2*(oa + t*rd)-ba*y) );\n    }\n\n    // Caps. I feel this can be done with a single square root instead of two\n    float h1 = m3*m3 - m5 + ra*ra;\n    float h2 = m6*m6 - m7 + rb*rb;\n    if( max(h1,h2)<0.0 ) return vec4(-1.0);\n    \n    vec4 r = vec4(1e20);\n    if( h1>0.0 )\n    {        \n    \tt = -m3 - sqrt( h1 );\n        r = vec4( t, (oa+t*rd)/ra );\n    }\n\tif( h2>0.0 )\n    {\n    \tt = -m6 - sqrt( h2 );\n        if( t<r.x )\n        r = vec4( t, (ob+t*rd)/rb );\n    }\n    \n    return r;\n}\n\nbool intersectWired(const in Ray inray, const in Triangle triangle, out float dist){\n    for(int i=0; i<TRIANG_V_COUNT; i++){\n        vec4 curCyl = iCappedCone(inray.origin, inray.dir, triangle.v[i], triangle.v[(i+1)%TRIANG_V_COUNT], WIRE_WIDTH, WIRE_WIDTH);\n        if(curCyl.x > 0.){\n            dist = curCyl.x;\n            return true;\n        }\n        //TODO could be break here\n    }\n    return false;\n}\n\nbool intersectWired(const in Ray inray, const in Rect rect, out float dist){\n    for(int i=0; i<RECT_V_COUNT; i++){\n        vec4 curCyl = iCappedCone(inray.origin, inray.dir, rect.v[i], rect.v[(i+1)%RECT_V_COUNT], WIRE_WIDTH, WIRE_WIDTH);\n        if(curCyl.x > 0.){\n            dist = curCyl.x;\n            return true;\n        }\n        //TODO could be break here\n    }\n    return false;\n}\n\nRect affine(const in Rect rect){\n\treturn Rect(vec3[RECT_V_COUNT](rect.v[0] * rect.pos,\n                                   rect.v[1] * rect.pos,\n                                   rect.v[2] * rect.pos,\n                                   rect.v[3] * rect.pos), mat3(1.));\n}\n\nTriangle affine(const in Triangle triang){\n\treturn Triangle(vec3[TRIANG_V_COUNT](triang.v[0] * triang.pos,\n                                   \t\t triang.v[1] * triang.pos,\n                                         triang.v[2] * triang.pos), mat3(1.));\n}\n\nvec3 hitAndColor(const in Ray inray, const in World world){\n    bool hit_something = false;\n    float max_dist = MAX_FLOAT;\n    float dist;\n    for(int i=0; i<12; i++){\n        Rect rect = affine(world.rects[i]);\n        if (intersectWired(inray, rect, dist) && dist < max_dist){\n            max_dist = dist;\n        \thit_something = true;\n        }\n    }\n    \n\treturn hit_something ? vec3(1.) * smoothstep(8., 5., max_dist) : vec3(0.);\n}\n\nvec3 hitAndColor(const in Ray inray, const in World2 world){\n    bool hit_something = false;\n    float max_dist = MAX_FLOAT;\n    float dist;\n    for(int i=0; i<6; i++){\n        Rect rect = affine(world.rects[i]);\n        if (intersectWired(inray, rect, dist) && dist < max_dist){\n            max_dist = dist;\n        \thit_something = true;\n        }\n    }\n    \n    for(int i=0; i<8; i++){\n        Triangle tri = affine(world.tri[i]);\n        if (intersectWired(inray, tri, dist) && dist < max_dist){\n            max_dist = dist;\n            hit_something = true;\n        }\n    }\n    \n\treturn hit_something ? vec3(1.) * smoothstep(8., 5., max_dist) : vec3(0.);\n}","name":"Common","description":"","type":"common"}]}