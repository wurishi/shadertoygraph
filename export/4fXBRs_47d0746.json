{"ver":"0.1","info":{"id":"4fXBRs","date":"1724164087","viewed":90,"name":"Night road","username":"gest","description":"The camera is controlled by the mouse","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","lighting","cars"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SHADERTOY\n\n#ifdef SHADERTOY\n    #define main() mainImage( out vec4 fragColor, in vec2 fragCoord )\n    #define u_canvas iResolution\n    #define u_mouse iMouse\n    #define u_time iTime\n    #define gl_FragCoord fragCoord\n    #define gl_FragColor fragColor\n\t#define texture2D texture\n\t#define textureCube texture\n\t#define u_texture0 iChannel0\n\t#define u_texture1 iChannel1\n\t#define u_textureCube0 iChannel0\n\t#define u_textureCube1 iChannel1\n#endif\n\n//#define SUPER_GRAPHIC_CARD\n\n#ifdef SUPER_GRAPHIC_CARD\n\t#define SOFT_SHADOW\n\t//#define MODEL_HARD\n#endif\n\nfloat time;\n#define FAR 200.\n#define ID_NONE -1.\n\n/// NOISE\n// Precision-adjusted variations of https://www.shadertoy.com/view/4djSRW\nfloat hash(float p) {\n  p = fract(p * 0.011); \n  p *= p + 7.5;\n  p *= p + p;\n  return fract(p);\n}\n\nfloat hash(vec2 p) {\n  vec3 p3 = fract(vec3(p.xyx) * 0.13);\n  p3 += dot(p3, p3.yzx + 3.333);\n  return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise(float x) {\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(hash(i), hash(i + 1.0), u);\n}\n\nfloat noise(vec2 x) {\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n\n\t// Four corners in 2D of a tile\n\tfloat a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    // Simple 2D lerp using smoothstep envelope between the values.\n\t// return vec3(mix(mix(a, b, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tmix(c, d, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tsmoothstep(0.0, 1.0, f.y)));\n\n\t// Same code, with the clamps in smoothstep and common subexpressions\n\t// optimized away.\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n\nfloat noise(vec3 x) {\n    const vec3 step = vec3(110, 241, 171);\n\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n \n    // For performance, compute the base input to a 1D hash from the integer part of the argument and the \n    // incremental change to the 1D based on the 3D -> 1D wrapping\n    float n = dot(i, step);\n\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\n\nvec3 Path(float t) {\n\treturn vec3(\n\t\t5.*sin(0.05*t) + 10.*sin(0.01*t)*cos(0.03*t),\n\t\t(1.-cos(time*0.1))*(3.)*sin(0.05*t),\n\t\tt\n\t);\n}\n\n////https://www.shadertoy.com/view/4dGcDh\nvec3 PathOrt(float t, float dt) {\n\tvec3 posF = Path(t + dt);\n\tvec3 posB = Path(t - dt);\n\tvec3 dir = posF - posB;\n\tfloat anY = atan(dir.z, dir.x) - 0.5*PI;\n\tvec3 vel = dir / (2. * dt);\n\tfloat anX = asin (-vel.y / length (vel));\n\t#if 0\n\t\tvec3 acc = (posF - 2. * Path(t) + posB) / (dt * dt);\n\t\tvel.y = 0.;\n\t\tacc.y = 0.;\n\t\tvec3 va = cross (acc, vel) / length (vel);\n\t\tfloat anZ = 40. * length (va) * sign (va.y);\n\t#else\n\t\tfloat anZ = 0.;\n\t#endif\n\treturn vec3(anX, anY, anZ);\n}\n\nmat3 PathMatrix(float t, float dt) {\n\tvec3 ort = PathOrt(t, dt);\n\treturn TF_ROTATE_Z(ort.z) * TF_ROTATE_X(ort.x) * TF_ROTATE_Y(ort.y);\n}\n\n#define LAMP_REPEAT_DIST 80.\n#define HOUSE_REPEAT_DIST LAMP_REPEAT_DIST * 2.\n\nconst vec3 sunDir = normalize(vec3(-0.5,2.5,2));\nbool useLamp = true;\n\nvec3 carPos[3];\nmat3 carMat[3];\nfloat carTime[3];\n\n#define ID_GROUND 0.\n#define ID_LIGHTER_COLUMN 1.\n#define ID_LAMP 2.\n#define ID_CAR_WHEEL 3.\n#define ID_PARKING 4.\n#define ID_HOUSE_WALL 5.\n#define ID_SIGN_PLATE 6.\n#define ID_HOUSE_WINDOW 7.\n#define ID_SIGN_TUBE 8.\n#define ID_CAR_F 101.\n#define ID_CAR_B 102.\n\nfloat glow = 0.;\nfloat calcGlow = 1.;\n\nfloat groundHeight(vec3 p) {\n\t#if 1\n\t\tfloat rnd = noise(p.xz * 0.1);\n\t\tfloat f = pow(abs(p.x) * 0.02, 2.);\n\t#else\n\t\tfloat rnd = noise(p.xz * 1.6);\n\t\tfloat f = length(p.yx) * 0.02;\n\t#endif\n\tf = clamp(f, 0., 1.);\n\tfloat h = mix(0., 14., f) * rnd;\n\tfloat f_mount = 1.- TF_SMOOTHSTEP_BETWEEN(p.x, 10., 20.);\n\treturn h * f_mount;\n}\n\nObject Car(vec3 p, vec3 carPos, mat3 carMat, float id) {\n\tvec3 q;\n\tfloat d;\n\t\n\tObject object = Object(FAR, ID_NONE, p);\n\n\tp -= carPos;\n\tp = carMat*p;\n\t\n\t//Кузов\n\tObject OBJ1 = Object(FAR, id, p);\n\t{\n\t\tq = p;\n\t\tTF_TRANSLATE(q.y, 0.5);\n\t\td = TF_BOX_ROUND(q, vec3(1,0.25,2.0)-0.2, 0.2);\n\t\tOBJ1.position = q;\n\t\tTF_TRANSLATE(q.y, 0.5);\n\t\tfloat d1 = TF_BOX(q, vec3(1,0.25,2.0)*0.5);\n\t\td = OR(d, d1, 1.2);\n\t\tOBJ1.distance = d;\n\t}\n\tobject = OR(object, OBJ1);\n\t\n\t//Колеса\n\tObject OBJ2 = Object(FAR, ID_CAR_WHEEL, p);\n\t{\n\t\tq = p;\n\t\tTF_TRANSLATE(q.y, 0.2);\n\t\tTF_MIRROR(q.xz, vec2(0.9, 1.5));\n\t\td = AND(TF_BALL(q.yz, 0.3), TF_BETWEEN(q.x, 0.2));\n\t\tOBJ2.distance = d;\n\t\tOBJ2.position = q;\n\t}\n\tobject = OR(object, OBJ2);\n\t\n\treturn object;\n}\n\nObject House(vec3 p) {\n\tvec3 q;\n\tfloat d;\n\t\n\tObject object = Object(FAR, ID_NONE, p);\n\n\t//Окна\n\tObject OBJ1 = Object(FAR, ID_HOUSE_WINDOW, p);\n\t{\n\t\tq = p;\n\t\tTF_TRANSLATE(q.xy, vec2(20., 2.));\n\t\td = TF_BOX3D(q, vec3(2., 2.5, 5.));\n\t\tOBJ1.distance = d;\n\t\tOBJ1.position = q;\n\t}\n\tobject = OR(object, OBJ1);\n\n\t//Здание\n\tObject OBJ2 = Object(FAR, ID_HOUSE_WALL, p);\n\t{\n\t\tq = p;\n\t\td = OBJ1.distance - 0.2;\n\t\tTF_TRANSLATE(q.y, 3.3);\n\t\tTF_REPLICA(q.yz, 2.0);\n\t\tfloat d_cut = TF_BOX2D(q.yz, 0.6);\n\t\td = AND(d, -d_cut);\n\t\tOBJ2.distance = d;\n\t\tOBJ2.position = q;\n\t}\n\tobject = OR(object, OBJ2);\n\t\t\n\t//Фонарь\n\tif (useLamp) {\n\t\tObject OBJ3 = Object(FAR, ID_LAMP, p);\n\t\t{\n\t\t\tq = p;\n\t\t\tTF_TRANSLATE(q.xy, vec2(17.5, 4.4));\n\t\t\t#if 0\n\t\t\t\tq.y = TF_BALL(q.yz, 0.4);\n\t\t\t\td = TF_BALL(q.xy, 0.1);\n\t\t\t#else\n\t\t\t\td = TF_BALL(q, 0.3);\n\t\t\t#endif\n\t\t\tOBJ3.distance = d;\n\t\t\tOBJ3.position = q;\n\t\t\t\n\t\t\tif (calcGlow==1.) glow += (0.01)/(OBJ3.distance*OBJ3.distance);\n\t\t}\n\t\tobject = OR(object, OBJ3);\n\t}\n\t\n\treturn object;\n}\n\nObject RoadSign(vec3 p) {\n\tvec3 q;\n\tfloat d;\n\t\n\tObject object = Object(FAR, ID_NONE, p);\n\n\t//Знак\n\tObject OBJ1 = Object(FAR, ID_SIGN_PLATE, p);\n\t{\n\t\tq = p;\n\t\tTF_TRANSLATE(q.x, -sign(p.z)*6.);\n\t\tTF_TRANSLATE(q.y, 1.);\n\t\tTF_MIRROR(q.z, 15.);\n\t\td = AND(TF_BOX2D(q.xy, vec2(1., 0.5)), TF_BETWEEN(q.z, 0.01));\n\t\tOBJ1.distance = d;\n\t\tOBJ1.position = q;\n\t}\n\tobject = OR(object, OBJ1);\n\n\t//Опора\n\tObject OBJ2 = Object(FAR, ID_SIGN_TUBE, p);\n\t{\n\t\td = AND(TF_BALL(q.xz, 0.1), TF_BEFORE(q.y, -0.5));\n\t\tOBJ2.distance = d;\n\t\tOBJ2.position = q;\n\t}\n\tobject = OR(object, OBJ2);\n\t\n\treturn object;\n}\n\nObject RoadLighter(vec3 p) {\n\tvec3 q;\n\tfloat d;\n\t\n\tObject object = Object(FAR, ID_NONE, p);\n\n\tconst float lampY = 3.5;\n\t\n\t//Столб\n\tObject OBJ1 = Object(FAR, ID_LIGHTER_COLUMN, p);\n\t{\n\t\tq = p;\n\t\tTF_MIRROR(q.x, 5.8);\n\t\td = TF_SEGMENT(q, vec3(0., 0., 0.), vec3(0, 3., 0.), 0.1);\n\t\tfloat d1 = TF_SEGMENT(q, vec3(0., 3., 0.), vec3(-1.4, lampY, 0.), 0.05);\n\t\td = OR(d, d1, 0.05);\n\t\tOBJ1.distance = d;\n\t}\n\tobject = OR(object, OBJ1);\n    \n\t//Лампа\n\tif (useLamp) {\n\t\tObject OBJ2 = Object(FAR, ID_LAMP, p);\n\t\t{\n\t\t\tq = p;\n\t\t\tTF_MIRROR(q.x, 4.4);\n\t\t\tTF_TRANSLATE(q.y, lampY);\n\t\t\td = TF_BALL(q, 0.25);\n\t\t\tOBJ2.distance = d;\n\t\t\tOBJ2.position = q;\n\t\t\t\n\t\t\tif (calcGlow==1. && q.y<0.) glow += 0.006/(OBJ2.distance*OBJ2.distance);\n\t\t}\n\t\tobject = OR(object, OBJ2);\n\t\t\n\t}\n\t\n\t\n\t\n\treturn object;\n}\n\nfloat map(vec3 p, inout Object object) {\n\tvec3 q;\n\tfloat d;\n\tobject = Object(FAR, ID_NONE, p);   \n\n\tvec3 path = Path(p.z);\n\tvec3 p0 = p;\n\t\n\t//Привязка к пути\n\tp.xy -= path.xy;\n\t\n\t//Поверхность\n\tObject OBJ0 = Object(FAR, ID_GROUND, p);\n\t{\n\t\td = TF_BEFORE(p.y, groundHeight(p));\n\t\tOBJ0.distance = d;\n\t}\n\tobject = OR(object, OBJ0);\n    \n    \n\t\n\tp = p0;\n\tp.xy -= path.xy;\n\tTF_REPLICA(p.z, HOUSE_REPEAT_DIST);\n\n\t//Парковка\n\tObject OBJ3 = Object(FAR, ID_PARKING, p);\n\t{\n\t\tq = p;\n\t\tTF_TRANSLATE(q.x, 20.)\n\t\td = AND(TF_BOX2D(q.xz, 10.), TF_AFTER(q.y, 0.));\n\t\tOBJ3.distance = d;\n\t\tOBJ3.position = q;\n\t}\n\tobject = AND(object, NOT(OBJ3), 0.5);\n\n\t//Здание\n\tobject = OR(object, House(p));\n\t//Дорожный знак\n\tobject = OR(object, RoadSign(p));\n\n    //Осветители дороги\n\tp = p0;\n\tp.xy -= path.xy;\n\tTF_REPLICA(p.z, LAMP_REPEAT_DIST);\n\tobject = OR(object, RoadLighter(p));\n\t\n\t//Машины\n\tp = p0;\n\tobject = OR(object, Car(p - vec3(2,0,0), carPos[0], carMat[0], ID_CAR_F));\n\tobject = OR(object, Car(p - vec3(2,0,0), carPos[1], carMat[1], ID_CAR_B));\n\t\n\n\treturn object.distance;\n}\n\nfloat map ( in vec3 p ) {\n\tObject object;\n\treturn map (p, object);\n}\n\nvec3 mapNormal(vec3 p, float eps) {\n    vec2 e = vec2(eps, 0);\n    vec3 n = map(p) - \n        vec3(map(p-e.xyy),\n             map(p-e.yxy), \n             map(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat rayMarch(inout Ray ray) {\n\tray.distance = ray.near;\n\tfloat steps;\n\tfor (float i = 0.; i < 200.; ++i) {\n\t\tray.position = ray.origin + ray.direction * ray.distance;\n\t\tray.object.distance = map(ray.position, ray.object);\n\t\tray.hit = abs(ray.object.distance) < ray.epsilon;\n\t\tif (ray.hit) break;\n\t\tray.distance += ray.object.distance*ray.swing;\n\t\tif (ray.distance>ray.far) break;\n\t\tsteps = i + 1.;\n\t\tif (steps>ray.steps) break;\n\t}\n\treturn steps;\n}\n\nfloat softShadow( Ray ray, float k ) {\n    float shade = 1.0;\n    ray.distance = ray.near;    \n\tfloat steps = 1.;\n    for ( int i = 0; i < 40; i++ ) {\n\t\tray.position = ray.origin + ray.direction * ray.distance;\n        ray.object.distance = map(ray.position);\n        shade = min( shade, smoothstep( 0.0, 1.0, k * ray.object.distance / ray.distance)); \n\t\tray.hit = ray.object.distance < ray.epsilon;\n\t\tif (ray.hit) break;\n        ray.distance += min( ray.object.distance, ray.far / ray.steps * 2. ); \n        if (ray.distance > ray.far ) break; \n\t\tsteps++;\n\t\tif (steps>ray.steps) break;\n    }\n\treturn shade;\n    return min( max( shade, 0.0 ) + 0.5, 1.0 ); \n}\n\n\nvec3 bgCol (vec3 rd, vec3 sunDir) {\n\tfloat sd = clamp (dot(sunDir, rd), 0., 1.);\n\t//vec3 skyCol = mix(vec3(1), vec3 (0.5, 0.75, 1.), rd.y+0.2);\n\tvec3 skyCol = mix(vec3 (0.5, 0.75, 1.), vec3(1), rd.y+0.2);\n\tvec3 col = skyCol;\n\n//\tcol += (0.5) * vec3 (1., 0.4, 0.2) * pow (sd, 256./2.);\n//\tcol += (0.5) * vec3 (1., 0.8, 0.7) * pow (sd, 1024./2.);\n\n\tfloat skyFactor = TF_SMOOTHSTEP_BEFORE(rd.y, -0.5, 0.2) * TF_SMOOTHSTEP_AFTER(rd.z, 0.0, 2.2);\n\tcol = mix(vec3(0.05), col*5., skyFactor);\n\treturn col;\n}\n\n\n\n\nstruct Light {\n\tvec3 color;\n\tvec3 direction;\n\tfloat distance;\n\tfloat intensity;\n};\n\nstruct Material {\n    vec3 color;\n\tfloat ambi;\n\tfloat diff;\n\tfloat spec;\n    float shine;\n\tbool lighting;\n};\n\nvec2 uv;\n\nvec3 lighting(Ray ray, Light light, Material m) {\n\tfloat att = 1.;\n\t#if 0\n\t\tatt = 1./(1. + pow(light.distance, 2.));\n\t#endif\n\n\t#if 1\n\t\tfloat back = clamp(0.5 + 0.5 * dot(ray.normal, vec3(0.0,-1.0,0.0)), 0.0, 1.0);\n\t#else\n\t\tfloat back = max(0., dot(ray.normal, -light.direction));\n\t#endif\n\t\n\t\n    float diff = max(0., dot(ray.normal, light.direction));\n    float spec = pow(max(0., dot(reflect(ray.direction, ray.normal), light.direction)), m.shine) ;\n    \n\tfloat sh = 1.;\n\n\t#ifdef SOFT_SHADOW\n\t\tuseLamp = false;\n\t\tRay ray1 = ray;\n\t\t{\n\t\t\tray1.origin = ray.position;\n\t\t\tray1.direction = light.direction;\n\t\t\tray1.far = 10.;\n\t\t}\n\t\t#if 0\n\t\t\trayMarch(ray1);\n\t\t\tsh = ray1.distance < light.distance ? 0. : 1.;\n\t\t\t//sh = TF_SMOOTHSTEP_AFTER(ray1.distance, light.distance-10., light.distance+10.);\n\t\t#else\n\t\t\tsh = softShadow(ray1, 10.);\n\t\t#endif\n\t#endif\n\t\n    vec3 col = m.color; \n    if (m.lighting) col *= light.color * light.intensity * (m.ambi*(back + 1.) + sh * att * (m.diff*diff + spec * m.spec));\n\treturn col;\n}\n\n//https://www.shadertoy.com/view/Mtf3zM\nfloat Brick (vec2 p) {\n\tvec2 q = p / vec2 (2., 1.);\n\tif (mod(floor(q.y), 2.)==0.) q.x += 0.5;\n\tq = smoothstep (0.02*2., 0.04*2., abs (fract (q + 0.5) - 0.5));\n\treturn q.x*q.y;\n}\nfloat Brick (vec3 p, vec3 n) {\n\tvec3 b = vec3(Brick(p.zy), Brick(p.xz), Brick(p.xy));\n\treturn dot(b,n);\n}\n\nfloat Square (vec2 p) {\n\tvec2 q = p;\n\tq = smoothstep (0.02*2., 0.04*2., abs (fract (q + 0.5) - 0.5));\n\treturn q.x*q.y;\n}\nfloat Square (vec3 p, vec3 n) {\n\tvec3 b = vec3(Square(p.zy), Square(p.xz), Square(p.xy));\n\treturn dot(b,n);\n}\n\nMaterial getMaterial(Ray ray) {\n\tMaterial m = Material(vec3(1), 0.1, 0.9, 10., 0.5, true);\n\tvec3 p = ray.position;\n\tvec3 q = ray.object.position;\n\tvec3 n = ray.normal;\n\t\n\tif (ray.object.id==ID_GROUND) {\n    \tfloat grain = texture2D(u_texture0, q.xz * (0.5)).r;\n\t\tm = Material(vec3(0.2), 0.1, 0.9, 5., 10., true);\n\t\tm.color = mix(m.color * grain, m.color, 0.1);\n\t\tfloat f_mount = 1.- TF_SMOOTHSTEP_BETWEEN(q.x, 10., 20.);\n\t\tm.color = mix(m.color, vec3(0.01, 0.3, 0.1), f_mount);\n\t\t\n\t\t//Боковые полосы\n\t\tvec3 qq = q;\n\t\tqq.x = abs(qq.x) - 5.;\n\t\tif (TF_BETWEEN(qq.x, 0.3)<0.) m = Material(vec3(0.7, 0.7, 0.1), 0.1, 0.9, 5., 40., true);\n\t\t\n\t\t//Центральная полоса\n\t\tqq = q;\n\t\tTF_REPLICA(qq.z, 5.);\n\t\tif (TF_BOX2D(qq.xz, vec2(0.15, 1.5))<0.) m = Material(vec3(0.95), 0.1, 0.9, 5., 40., true);\n\t\t\n\t\t//Обочина\n\t\tqq = q;\n\t\tqq.x = abs(qq.x) - 7.;\n\t\tif (TF_BETWEEN(qq.x, 1.)<0.) {\n\t\t\tm = Material(vec3(0.1, 0.1, 0.1), 0.1, 0.9, 5., 0., true);\n\t\t\tm.color *= Square(qq/1.0, abs(n));\n\t\t}\n\t\t//Пешеходый переход\n\t\tqq = q;\n\t\tTF_REPLICA(qq.z, LAMP_REPEAT_DIST);\n\t\tTF_REPLICA(qq.x, 1.);\n\t\tfloat d1 = TF_BETWEEN(q.x, 4.5);\n\t\tfloat d2 = TF_BOX2D(qq.xz, vec2(0.2, 1.5));\n\t\tif (AND(d1,d2)<0.) {\n\t\t\tm = Material(vec3(0.95), 0.1, 0.9, 20., 2., true);\n\t\t}\n\t} else if (ray.object.id==ID_LIGHTER_COLUMN) {\n\t\tm = Material(vec3(0.5), 0.1, 0.9, 5., 120., true);\n\t} else if (ray.object.id==ID_LAMP) {\n\t\tm = Material(vec3(20.), 0.2, 0.8, 10., 10., true);\n\t\tif (q.y>0.) m.color = vec3(0.5);\n\t} else if (ray.object.id==ID_CAR_WHEEL) {\n\t\tm = Material(vec3(0), 0.1, 0.9, 5., 1., true);\n\t} else if (ray.object.id>100.) {\n\t\tvec3 qq = q;\n\t\tif (ray.object.id==ID_CAR_F) {\n\t\t\t//Цвет кузова\n\t\t\tm.color = vec3(0,0,1);\n\t\t\t//Стоп-сигналы\n\t\t\tqq.x = abs(qq.x) - 0.9;\n\t\t\tif (TF_BALL(qq.xy, 0.1)<0.) {\n\t\t\t\tm.color = vec3(30,0,0);\n\t\t\t\tm.lighting = false;\n\t\t\t}\n\t\t} else if (ray.object.id==ID_CAR_B) {\n\t\t\t//Цвет кузова\n\t\t\tm.color = vec3(0,1,0);\n\t\t\t//Фары\n\t\t\tqq.x = abs(qq.x) - 0.8;\n\t\t\tif (TF_BOX2D(qq.xy, vec2(0.2,0.1))<0.) {\n\t\t\t\tm.color = vec3(30);\n\t\t\t\tm.lighting = false;\n\t\t\t}\n\t\t}\n\t\t//Номер\n\t\tqq = q;\n\t\tif (TF_BOX2D(qq.xy, vec2(0.2,0.1))<0.) {\n\t\t\tm.color = vec3(3);\n\t\t\tm.shine = 10.;\n\t\t}\n\t\t//Стекла\n\t\tqq = q;\n\t\tqq.y -= 0.5;\n\t\tif (TF_BETWEEN(qq.y, 0.20)<0.) {\n\t\t\tm.color = vec3(0.0);\n\t\t}\n\t} else if(ray.object.id==ID_PARKING) {\n\t\tm.color = vec3(0.5);\n\t\tif (abs(ray.normal.y)<0.01) {\n\t\t\tm.color *= Brick(p/0.5, abs(n));\n\t\t} else {\n\t\t\tm.spec = 1.;\n\t\t\tvec3 qq = q;\n\t\t\tqq.x -= -7.;\n\t\t\tTF_REPLICA(qq.z, 2.2);\n\t\t\tif (TF_BOX2D(qq.xz, vec2(2, 0.15))<0.) {\n\t\t\t\tm.color = vec3(2);\n\t\t\t\tm.spec = 10.;\n\t\t\t}\n\t\t}\n\t} else if(ray.object.id==ID_HOUSE_WALL) {\n\t\tm.color = vec3(0.2,0.1,0.1);\n\t\tm.spec = 1.;\n\t} else if(ray.object.id==ID_HOUSE_WINDOW) {\n\t\tm.color = vec3(0.2,0.2,0.4)*ray.distance;\n\t} else if (ray.object.id==ID_SIGN_PLATE) {\n\t\tm = Material(vec3(4), 0.2, 0.8, 5., 2., true);\n\t\tvec3 qq = q;\n\t\tfloat d = TF_BETWEEN2(qq.y, -0.2, 0.);\n\t\tfloat d1 = TF_BOX2D(qq.xy, vec2(1, 0.5) - 0.08);\n\t\tfloat d2 = abs(d1) - 0.02;\n\t\td = OR(d, d2);\n\t\tfloat id = TF_REPLICA(qq.x, 0.4);\n\t\tTF_ROTATE(qq.xy, id*PI/4.);\n\t\tid = mod(id, 3.);\n\t\tif (id==1.) qq.xy/= 0.5;\n\t\tfloat d3 = TF_BOX2D(qq.xy, 0.15);\n\t\td = OR(d, d3);\n\t\td = AND(d, d1);\n\t\tif (d<0.) m.color = vec3(0);\n\t\t\n\t\tif (q.z < 0.) {\n\t\t\tTF_ROTATE(q.xy, atan(1., 0.5));\n\t\t\tif (TF_BETWEEN(q.x, 0.08)<0.) m.color = vec3(1,0,0);\n\t\t}\n\t}\n\treturn m;\n}\n\nfloat getPointLightIntensity(Light light, vec3 fwd, float an, float lightDistFar) {\n\tfloat res = 0.;\n\tfloat f = dot (-light.direction, fwd);\n\tif (light.distance<lightDistFar && f > cos(an)) {\n\t\tres = (0.1 + pow (f, 8.)) * min (1., 100. / pow(light.distance, 2.5));\n\t}\n\treturn res;\n}\n\nvec3 render(Ray ray, Camera cam) {\n\tvec3 bgColor = bgCol(ray.direction, sunDir);\n\n    vec3 col = vec3(0);\n\t\n    rayMarch(ray);\n\n    if (ray.distance < ray.far) {\n\t\tcalcGlow = 1.;\n        ray.normal = mapNormal(ray.position, 0.001);\n\t\tMaterial m = getMaterial(ray);\n\n\t\tLight light;\n\t\tlight.color = vec3(1.0); //vec3(1.0, .3, .05);\n\t\t\n\t\t//Окружающее освещение\n\t\tlight.direction = sunDir;\n\t\tlight.distance = FAR;\n\t\tlight.intensity = 0.05;\n\t\tcol += lighting(ray, light, m);\n\t\t\n\t\t//Столбы освещения\n\t\tvec3 lightPos = vec3(\n\t\t\t0, //2.8\n\t\t\t3.5,\n\t\t\tray.object.position.z\n\t\t);\n\t\t\n\t\tlightPos.xy += Path(lightPos.z).xy;\n\t\tfloat id = TF_REPLICA(lightPos.z, LAMP_REPEAT_DIST);\n\t\tlightPos.z = id * LAMP_REPEAT_DIST;\n\n\t\tvec3 fwd = normalize(vec3(0,-lightPos.y, 0));\n\t\tlightPos.x -= -2.8;\n\t\tlight.direction = normalize(lightPos - ray.position);\n\t\tlight.distance = length (lightPos - ray.position);\n\t\tlight.intensity = getPointLightIntensity(light, fwd, radians(80.), 50.);\n\t\tlight.intensity *= 5.;\n\t\tcol += lighting(ray, light, m);\n\t\t\n\t\tlightPos.x -= 5.6;\n\t\tlight.direction = normalize(lightPos - ray.position);\n\t\tlight.distance = length (lightPos - ray.position);\n\t\tlight.intensity = getPointLightIntensity(light, fwd, radians(80.), 50.);\n\t\tlight.intensity *= 5.;\n        col += lighting(ray, light, m);\n\t\t\n\t\t\n\t\t//Передняя машина\n\t\tlightPos = Path(carTime[0]+1.5) + vec3(2, 0.5, 0);\n\t\tfwd = normalize(ray.origin);\n\t\t\n\t\t//Передняя машина - правая фара\n\t\tlightPos.x -= 0.9;\n\t\tlight.direction = normalize(lightPos - ray.position);\n\t\tlight.distance = length (lightPos - ray.position);\n\t\tlight.direction = carMat[0] * light.direction;\n\t\tlight.intensity = getPointLightIntensity(light, fwd, radians(25.), 50.);\n\t\tlight.intensity *= 5.;\n\t\tcol += lighting(ray, light, m);\n\n\t\t\n\t\t//Передняя машина - левая фара\n\t\tlightPos.x -= -1.8;\n\t\tlight.direction = normalize(lightPos - ray.position);\n\t\tlight.distance = length (lightPos - ray.position);\n\t\tlight.direction = carMat[0] * light.direction;\n\t\tlight.intensity = getPointLightIntensity(light, fwd, radians(25.), 50.);\n\t\tlight.intensity *= 5.;\n\t\tcol += lighting(ray, light, m);\n\n\t\t//Задняя машина\n\t\tlightPos = Path(carTime[1]+1.5) + vec3(2, 0.5, 0);\n\t\t\n\t\t//Задняя машина - правая фара\n\t\tlightPos.x -= 0.9;\n\t\tlight.direction = normalize(lightPos - ray.position);\n\t\tlight.distance = length (lightPos - ray.position);\n\t\tlight.direction = carMat[1] * light.direction;\n\t\tlight.intensity = getPointLightIntensity(light, fwd, radians(25.), 50.);\n\t\tlight.intensity *= (length(ray.origin-carPos[1])<25. ? 1.5 : 5.);\n\t\tcol += lighting(ray, light, m);\n\t\t\n\t\t//Задняя машина - левая фара\n\t\tlightPos.x -= -1.8;\n\t\tlight.direction = normalize(lightPos - ray.position);\n\t\tlight.distance = length (lightPos - ray.position);\n\t\tlight.direction = carMat[1] * light.direction;\n\t\tlight.intensity = getPointLightIntensity(light, fwd, radians(25.), 50.);\n\t\tlight.intensity *= (length(ray.origin-carPos[1])<25. ? 1.5 : 5.);\n\t\tcol += lighting(ray, light, m);\n\n\t\t//Фонарь на доме\n\t\tlightPos = vec3(\n\t\t\t18., //2.8\n\t\t\t4.5,\n\t\t\tray.position.z\n\t\t);\n\t\tlightPos.xy += Path(lightPos.z).xy;\n\t\tid = TF_REPLICA(lightPos.z, HOUSE_REPEAT_DIST);\n\t\tlightPos.z = id * HOUSE_REPEAT_DIST;\n\t\tlight.direction = normalize(lightPos - ray.position);\n\t\tlight.distance = length (lightPos - ray.position);\n\t\tlight.intensity = (5.)/pow(light.distance, 2.);\n\t\tcol += lighting(ray, light, m);\n\t\t\n\t\t//Туман\n\t\tfloat fogStart = 25.;\n\t\tvec3 fogColor = bgColor;\n\t\tcol = mix(col, fogColor, clamp((ray.distance-fogStart)/(ray.far-fogStart), 0., 1.));\n\t\t\n\t} else {\n        col = bgColor;\n    }\n\t\n\tcol += (0.9)* glow * vec3(0.2,0.1,1.0);\n\t\n    col = pow(col, vec3(.4545));\n\t\n\treturn col;\n}\n\n\nvoid main() {\n    time = u_time;\n\n\tfloat aspect = u_canvas.x/u_canvas.y;\n\tuv = gl_FragCoord.xy/u_canvas.xy;\n\tuv = uv - 0.5;\n\n\tvec2 mouse = u_mouse.xy / u_canvas.xy - 0.5;\n\tif (u_mouse.xy==vec2(0)) mouse = vec2(0);\n\n\tvec2 ori = vec2(\n\t\tu_mouse.z==0. ? 0. : mouse.y*PI*2.,\n\t\tu_mouse.z==0. ? 0./*sin(0.5*time)*/ : mouse.x*PI*2.\n\t);\n\n\t#if 1\n\t\tori.x = clamp(ori.x, -PI/2., PI/2.);\n\t#else\n\t\tori.x = clamp(ori.x, -PI/2., 0.);\n\t#endif\n\n\t//Настройка зеркала\n\tfloat px = 1./u_canvas.x;\n\tconst vec2 mirrorLocation = vec2(0.25, 0.3);\n\tconst vec2 mirrorViewCenter = vec2(0,0.05);\n\tconst vec2 mirrorSize = vec2(0.2, 0.1);\n\tconst float mirrorRadius = 0.05;\n\tfloat mirrorDist = TF_BOX_ROUND(uv - mirrorLocation, mirrorSize-mirrorRadius, mirrorRadius);\n\tbool isMirror = mirrorDist<0.;\n\tfloat mirrorFrameDist = abs(mirrorDist- 1.*px) - 1.*px;\n\tif (isMirror) {\n\t\tuv = uv - mirrorLocation - mirrorViewCenter;\n\t\taspect = mirrorSize.x / mirrorSize.y;\n\t}\n\n\t//Камера\n\tfloat camTime = time*16.;\n\t\n\t//Передняя машина\n\tcarTime[0] = camTime + 20.;\n\t#if 1\n\t\tcarTime[0] += 10.*sin(0.5*time);\n\t#endif\n  \tcarPos[0] = Path(carTime[0]);\n\tcarMat[0] = PathMatrix(carTime[0], 0.5);\n\n\t//Задняя машина\n\tcarTime[1] = camTime - 25.;\n\t#if 1\n\t\tcarTime[1] -= 15.*sin(0.3*time);\n\t#endif\n  \tcarPos[1] = Path(carTime[1]);\n\tcarMat[1] = PathMatrix(carTime[1], 0.5);\n\t\n\tCamera cam;\n\t{\n\t\tcam.fov     = isMirror ? 120. : 60.;\n\t\tcam.aspect  = aspect;\n\t\tcam.origin  = Path(camTime) + vec3(2,2,0);\n\t\tcam.target  = Path(camTime + (isMirror ? -1. : 1.)) + vec3(2,2,0);\n\t\tcam.up \t\t= vec3(0,1,0);\n\t\tcam.vMat \t= isMirror ? mat3(1) : TF_ROTATE_Y(ori.y) * TF_ROTATE_X(ori.x);\n\t\tcam.mMat\t= mat3(1);//TF_ROTATE_Y(ori.y) * TF_ROTATE_X(ori.x);\n\t}\n\t\n\tRay ray = lookAt(uv, cam);\n\t{\n\t\tray.near \t= 0.01;\n\t\tray.far  \t= FAR;\n\t\tray.epsilon = 0.001;\n\t\tray.swing\t= 1.;\n\t\tray.steps \t= 150.;\n\t}\n\t\n\tvec3 ro = ray.origin;\n\tvec3 rd = ray.direction;\n\n\tvec3 col = render(ray, cam);\n\n\t//Окантовка зеркала\n\tif (mirrorFrameDist<0.) col = vec3(0.5);\n\t\n    gl_FragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = radians(180.);\n//Камера\nstruct Camera {\n\t//Задаваемые параметры\n\tfloat fov, aspect;\n\tvec3  origin, target, up;\n\tmat3 vMat, mMat;\n\t//Расчетные параметры\n\tfloat factor;\n\tvec3  forward, right, position, coord;\n\tmat3 pMat, uMat;\n};\n\n//Параметры объекта\nstruct Object {\n\tfloat   distance;\t//Последнее приближение к объекту сцены\n\tfloat \tid;\t\t\t//id найденого объека сцены\n\tvec3 \tposition;\t//Координатв поверхности объекта\n};\n\n//Луч\nstruct Ray {\n\t//Задаваемые параметры\n\tvec3  origin;\t\t//Начало луча\n\tvec3  direction;\t//Направление луча\n\tfloat near;\t\t\t//Минимальное расстояние от камеры (начало сцены)\n\tfloat far;\t\t\t//Максивальное расстояние от камеры (конец сцены)\n\tfloat epsilon;\t\t//Точность обнаружения поверхности\n\tfloat steps;\t\t//Максимальное число итераций\n\tfloat swing;\t\t//\"+\" -колебание в найденной точке, \"-\"\n\t//Вычисляемые параметры\n\tfloat distance; \t//Расстояние до объекта сцены от ray.origin в направлении ray.direction\n\tvec3  position; \t//Точка поверхности\n\tvec3  normal;\t\t//Нормаль в точке поверхности\n\tbool  hit;\t\t\t//Флаг нахождения точки поверхности с заданной точностью\n\tObject object;\t\t//Параметры объекта (можно формировать непосредственно в карте расстояний)\n};\n//Формирование луча камеры\nRay lookAt (in vec2 uv, inout Camera cam) {\n\t//Расчетные характеристики камеры\n\tcam.factor\t\t= 1.0/tan(radians(cam.fov/2.));\n\tcam.forward \t= normalize(cam.target-cam.origin); \n\tcam.right \t\t= normalize(cross(cam.up, cam.forward));\n\tcam.up \t\t\t= cross(cam.forward, cam.right);\n\tcam.position \t= cam.origin + cam.factor * cam.forward;\n\tcam.coord \t\t= cam.position + uv.x * cam.right*cam.aspect + uv.y * cam.up;\n\tcam.pMat \t\t= mat3(cam.right, cam.up, cam.forward);\n\n\t//Формирование луча\n\tRay ray;\n\t{\n\t\tray.origin \t\t= cam.mMat * cam.origin;\n\t\tray.direction \t= cam.mMat * normalize( cam.pMat * cam.vMat * vec3(uv.x*cam.aspect, uv.y, cam.factor));\n\t\t//Умолчания\n\t\tray.near\t\t= 0.01;\n\t\tray.far\t\t\t= 100.;\n\t\tray.epsilon\t\t= 0.001;\n\t\tray.swing\t\t= 1.0;\n\t\tray.steps\t\t= 200.;\n\t}\n\treturn ray;\n}\n//-------------------функции трансформации и позиционирования объектов сцены\n//Допустимая ошибка (для удаления артефактов) 1./min(u_canvas.x, u_canvas.y)\nfloat EPS = 0.01;\n//Функция расстояния до фигуры со скругленными ребрами (объединение и сглаживание с увеличением на R)\n//float d - сглаживание фигуры\n//vec2 d - объединение и сглаживание двух фигур\n//vec3 d - объединение и сглаживание трех фигур\n//vec4 d - объединение и сглаживание четырех фигур\n#define TF_ROUND(d, R) (length(max(d, 0.)) - (R))\n//Функция расстояния до бокса (p vec3) или прямоугольника (p vec2) со скругленными ребрами\n//Функция расстояния до капсулы, если два размера 0\n#define TF_BOX_ROUND(p, S, R) TF_ROUND(abs(p)-(S), R)\n#define TF_BOX_ROUND1(p, S, R) TF_ROUND(abs(p)-(S) + R, R)\n//Функция расстояния до бокса (p vec3) или прямоугольника (p vec2)\n#define TF_BOX(p, S) TF_BOX_ROUND(p, S, 0.)\n//#define TF_BOX(p, S) TF_ROUND(abs(p) - (S) - EPS, EPS)\n#define TF_BOX1(p, S) TF_BOX_ROUND(p, S, EPS)\n#define TF_BOX3D(p, S) max(abs((p).x)-vec3(S).x, max(abs((p).y)-vec3(S).y, abs((p).z)-vec3(S).z))\n#define TF_BOX2D(p, S) max(abs((p).x)-vec2(S).x, abs((p).y)-vec2(S).y)\n//Функция расстояния до шара (p vec3) или круга (p vec2)\n#define TF_BALL(p, R) TF_ROUND(abs(p), R)\n//Эллипс\n#define TF_ELLIPSE3D(p, r) min ((r).x, min((r).y, (r).z)) * TF_BALL((p)/(r), 1.)\n#define TF_ELLIPSE2D(p, r) min ((r).x, (r).y) * TF_BALL((p)/(r), 1.)\n//Отрезок от a до b радиусом r\n#define TF_SEGMENT(p, a, b, r) TF_BALL((p)-(a) - ((b)-(a)) * clamp( dot((p)-(a),(b)-(a))/dot((b)-(a),(b)-(a)), 0.0, 1.0 ), r)\n//Функция расстояния до пространства ДО p1\n#define TF_BEFORE(p, p1) (p - (p1))\n#define TF_BEFORE1(p, p1) TF_ROUND(p - (p1) + EPS, EPS)\n//Функция расстояния до пространства ДО normal с отступом p1\n#define TF_BEFORE_PLANE(p, normal, p1) dot(p, normal) - p1\n//Функция расстояния до пространства ПОСЛЕ p1\n#define TF_AFTER(p, p1) (-p + (p1))\n#define TF_AFTER1(p, p1) TF_ROUND(-p + (p1) + EPS, EPS)\n//Функция расстояния до пространства ПОСЛЕ normal с отступом p1\n#define TF_AFTER_PLANE(p, normal, p1) dot(p, normal) + p1\n//Функция расстояния до симметричного пространства МЕЖДУ -p1 и +p1\n//#define TF_BETWEEN(p, p1) TF_ROUND(abs(p) - (p1) + EPS, EPS)\n#define TF_BETWEEN(p, p1) (abs(p) - (p1))\n//Функция расстояния до несимметричного пространства МЕЖДУ p1 и p2\n//#define TF_BETWEEN2(p, p1, p2) TF_ROUND( abs(p - 0.5*(p1+p2)) - 0.5*(p2-p1) + EPS, EPS)\n#define TF_BETWEEN2(p, p1, p2) (abs(p - 0.5*((p1)+(p2))) - 0.5*((p2)-(p1)))\n//Перемещение пространства p (float p...vec4 p)\n#define TF_TRANSLATE(p, d) p -= d;\n//Масштаб\n#define TF_SCALE(p, s) p /= s\n//Преобразование двух координат пространства в круг\n#define TF_CIRCLE(p, R) p = vec2(TF_BALL(p.xy, R), (R)*atan(p.x,p.y))\n\n//Вращение пространства p (vec2 p)\n#if 0\n\t#define TF_ROTATE(p, a) p = mat2(cos(a), sin(a), -sin(a), cos(a)) * p\n#else\n\t#define TF_ROTATE(p, a) p = p.xy * cos (a) * vec2 (1., 1.) + p.yx * sin (a) * vec2 (-1., 1.)\n#endif\n#define TF_ROTATE_MAT2(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n#define TF_ROTATE_X(a) mat3(1.0,    0.0, 0.0,       0.0, cos(a), -sin(a),   0.0, sin(a), cos(a))\n#define TF_ROTATE_Y(a) mat3(cos(a), 0.0, -sin(a),   0.0, 1.0, 0.0,   \t    sin(a), 0.0, cos(a))\n#define TF_ROTATE_Z(a) mat3(cos(a), -sin(a), 0.0,   sin(a), cos(a), 0.0,   \t0.0, 0.0, 1.0)\n//Отражение пространства p (float p...vec4 p)\n#define TF_MIRROR(p, d) p = abs(p) - (d)\n//Разбиение пространства на повторяющиеся. Возвращает id центра ячейки\n//float p - пространство 1D\n//vec2 p - пространство 2D\n//vec3 p - пространство 3D\n#define TF_REPLICA(p, d) \\\n\tfloor((p)/(d) + 0.5);\\\n\tp = mod((p) + 0.5*(d), d) - 0.5*(d)\n#define TF_REPLICA1(p, d) \\\n\tfloor((p)/(d) + 0.5);\\\n\tp = p - (d) * floor((p)/(d) + 0.5)\n//Разбиение пространства на повторяющиеся в диапазоне id от ida до idb включительно. Возвращает id центра ячейки\n#define TF_REPLICA_LIMIT(p, d, ida, idb) \\\n\tfloor((p)/(d) + 0.5);\\\n\tp = p-(d)*clamp(floor((p)/(d) + 0.5), ida, idb)\n#define TF_REPLICA_LIMIT_MIRROR(p, d, id) \\\n\tfloor((p=p-0.5*(d))/(d) + 0.5);\\\n\tp = p-(d)*clamp(floor((p)/(d) + 0.5), -id, id-1.)\n\n//Разбиение пространства на повторяющиеся сектора в плоскости vec2 p в полярной системе координат\n//Возвращает id сектора\t\n#define TF_REPLICA_ANGLE_POLAR(p, n, off)\\\n\tfloor(mod(atan(p.x, p.y) + off, 2.*PI)/(2.*PI/(n)) + 0.5);\\\n\tp = vec2(atan(p.x,p.y) + off, length(p.xy));\\\n\tp.x = mod(p.x + 0.5*(2.*PI/(n)), (2.*PI/(n))) - 0.5*(2.*PI/(n))\n//Разбиение пространства на повторяющиеся сектора в плоскости vec2 p в декартовой системе координат\n//Возвращает id сектора\t\n#if 1\n\t#define TF_REPLICA_ANGLE(p, n, off) \\\n\t\tfloor(mod(atan(p.x, p.y) + PI /(n) + off, 2.*PI)/(2.* PI /(n)));\\\n\t\tTF_ROTATE(p.xy, -off);\\\n\t\tTF_ROTATE(p.xy, (2.* PI /(n)) * floor(atan(p.x,p.y)/(2.* PI /(n)) + 0.5))\n#else\n\t#if 0\n\t\t#define TF_REPLICA_ANGLE(p, n, off) \\\n\t\t\tfloor(mod(atan(p.x, p.y) + off, 2.*PI)/(2.*PI/(n)) + 0.5);\\\n\t\t\tp = vec2(atan(p.x,p.y) + off, length(p.xy));\\\n\t\t\tp.x = mod(p.x + 0.5*(2.*PI/(n)), (2.*PI/(n))) - 0.5*(2.*PI/(n));\\\n\t\t\tp = p.y * vec2(sin(p.x), cos(p.x))\n\t#else\n\t\t#define TF_REPLICA_ANGLE(p, n, off) \\\n\t\t\tTF_REPLICA_ANGLE_POLAR(p, n, off);\\\n\t\t\tp = p.y * vec2(sin(p.x), cos(p.x))\n\t#endif\n#endif\n\n//По p2.xy формирует координату винта вдоль p1 с шагом s \n//Возвращает ID\n#define TF_REPLICA_SPIN(p1, p2, s) (\\\n\tp1 += atan(p2.x,p2.y) * (s),\\\n\tTF_REPLICA(p1, 2. * PI / 1. * (s))\\\n)\n\n#define TF_REPLICA_SPIN_LIMIT(p1, p2, s, ida, idb) (\\\n\tp1 += atan(p2.x,p2.y) * (s),\\\n\tTF_REPLICA_LIMIT(p1, 2. * PI / 1. * (s), ida, idb)\\\n)\t\n//Формирование в плоскости p.xy n ветвей равномерной бесконечной спирали.\n//Возвращает в p.x расстояние до спирали.\n#if 1\n\t#define TF_SPIRAL(p, n)\\\n\t\tp.x = atan(p.x,p.y)*(n)/(2.*PI) - length(p.xy) - 0.5;\\\n\t\tp.x -= 1. * floor(p.x/1. + 0.5)\n#else\n\t#define TF_SPIRAL(p, n)\\\n\t\tp.xy = vec2(atan(p.x,p.y), length(p.xy));\\\n\t\tp.x = p.x*(n)/(2.*PI) - p.y - 0.5;\\\n\t\tp.x -= 1. * floor(p.x/1. + 0.5)\n#endif\n//Формирование в плоскости p.xy n ветвей равномерной спирали с ограничением количества витков \n//Возвращает в p.x расстояние до спирали.\n#if 1\n\t#define TF_SPIRAL_LIMIT(p, n, ida, idb)\\\n\t\tp.x = atan(p.x,p.y)*(n)/(2.*PI) - length(p.xy) - 0.5;\\\n\t\tp.x -= 1. * clamp(floor(p.x/1. + 0.5), ida, idb);\n#else\n\t#define TF_SPIRAL_LIMIT(p, n, ida, idb)\\\n\t\tp.xy = vec2(atan(p.x,p.y), length(p.xy));\\\n\t\tp.x = p.x*(n)/(2.*PI) - p.y - 0.5;\\\n\t\tp.x -= 1. * clamp(floor(p.x/1. + 0.5), ida, idb);\n#endif\n//Формирование в плоскости p.xy n ветвей расширяющейся бесконечной спирали.\n//Возвращает масштаб для корректировки профиля и в p.x расстояние до спирали.\n#if 1\n\t#define TF_SPIRAL_LOG(p, n)\\\n\t\tlength(p.xy);\\\n\t\tp.x = atan(p.x,p.y)*(n)/(2.*PI) - log(length(p.xy)) - 0.5;\\\n\t\tp.x -= 1. * floor(p.x/1. + 0.5)\n#else\n\t#define TF_SPIRAL_LOG(p, n)\\\n\t\tlength(p.xy);\\\n\t\tp.xy = vec2(atan(p.x,p.y), length(p.xy));\\\n\t\tp.y = log(p.y);\\\n\t\tp.x = p.x*(n)/(2.*PI) - p.y - 0.5;\\\n\t\tp.x -= 1. * floor(p.x/1. + 0.5)\n#endif\n//Формирование в плоскости p.xy n ветвей расширяющейся спирали с ограничением количества витков.\n//Возвращает масштаб для корректировки профиля и в p.x расстояние до спирали.\n#if 1\n\t#define TF_SPIRAL_LOG_LIMIT(p, n, ida, idb)\\\n\t\tlength(p.xy);\\\n\t\tp.x = atan(p.x,p.y)*(n)/(2.*PI) - log(length(p.xy)) - 0.5;\\\n\t\tp.x -= 1. * clamp(floor(p.x/1. + 0.5), ida, idb);\n#else\n\t#define TF_SPIRAL_LOG_LIMIT(p, n, ida, idb)\\\n\t\tlength(p.xy);\\\n\t\tp.xy = vec2(atan(p.x,p.y), length(p.xy));\\\n\t\tp.y = log(p.y);\\\n\t\tp.x = p.x*(n)/(2.*PI) - p.y - 0.5;\\\n\t\tp.x -= 1. * clamp(floor(p.x/1. + 0.5), ida, idb);\n#endif\n\n//------------------------------------------------------------------------------------------------------\n//Возвращает 0 или 1 в зависимоти от знячения p относительно a или b\n//Операция ИЛИ(OR) \t: step1 + step2 (сложение)\n//Операция И(AND) \t: step1 * step2 (умножение)\n//Операция NOT \t\t: 1. - step\n//------------------------------------------------------------------------------------------------------\n//Возвращает 1 если p > a\n//    1-----\n//    |\n//    |\n//----0\n//    a\n#define TF_STEP_AFTER(p, a) step(a, p)\n\n//Возвращает 1 если p < a\n//----1\n//    |\n//    |\n//    0-----\n//    a\n#define TF_STEP_BEFORE(p, a) step(p, a)\n\n//Возвращает 1 если -a < p < a\n//    1------1\n//    |      |\n//    |      |\n//----0      0--------\n//   -a      +a\n#define TF_STEP_BETWEEN(p, a) TF_STEP_BEFORE(abs(p), a)\n//Возвращает 1 если a < p < b\n//    1------1\n//    |      |\n//    |      |\n//----0      0--------\n//    a      b\n#define TF_STEP_BETWEEN2(p, a, b) TF_STEP_AFTER(p, a)*TF_STEP_BEFORE(p, b)\n\n//------------------------------------------------------------------------------------------------------\n//Возвращает 0 или 1 в зависимоти от знячения p относительно a или b со сглаживанием [-0.5*eps, 0.5*eps]\n//Операция ИЛИ(OR) \t: smoothstep1 + smoothstep2 (сложение)\n//Операция И(AND) \t: smoothstep1 * smoothstep2 (умножение)\n//Операция NOT \t\t: 1. - smoothstep\n//------------------------------------------------------------------------------------------------------\n//Возвращает \n//\t0 если p < a-eps/2; \n//\t1 если p > a+eps/2;\n//  сглаживание от 0 до 1  между a-0.5*eps и a+0.5*eps\n//        1-----\n//       /      \n//      /       \n//     /        \n//----0         \n//    |eps|\n//      a \n//\n//        1-----\n//       /      \n//      /       \n//     /        \n//----0         \n//    a   b \n//      \n#define TF_SMOOTHSTEP_AFTER_EPS(p, a, eps) smoothstep(a-0.5*eps, a+0.5*eps, p)\n#define TF_SMOOTHSTEP_AFTER(p, a, b) smoothstep(a, b, p)\n//Возвращает \n//\t1 если p < a-eps/2; \n//\t0 если p > a+eps/2;\n//  сглаживание от 1 до 0  между a-eps/2 и a+eps/2\n//-----1\n//      \\\n//       \\\n//        \\\n//         0------\n//     |eps|\n//       a \n//\n//-----1\n//      \\\n//       \\\n//        \\\n//         0------\n//    a    b \n//       \n#define TF_SMOOTHSTEP_BEFORE_EPS(p, a, eps) (1.-smoothstep(a-0.5*eps, a+0.5*eps, p))\n#define TF_SMOOTHSTEP_BEFORE(p, a, b) (1.-smoothstep(a, b, p))\n\n//Возвращает \n//\t1 если p > -a+eps/2  и  p < a-eps/2; \n//\t0 если p < -a-eps/2 или p > a+eps/2; \n//  сглаживание от 0 до 1  между -a-eps/2 и -a+eps/2\n//  сглаживание от 1 до 0  между  a-eps/2 и  a+eps/2\n//        1-----1\n//       /       \\\n//      /         \\\n//     /           \\\n//----0             0------\n//    |eps|     |eps|\n//     -a         +a\n//\n//        1-----1\n//       /       \\\n//      /         \\\n//     /           \\\n//----0             0------\n//   -b  -a    +a  +b\n//\n#define TF_SMOOTHSTEP_BETWEEN_EPS(p, a, eps) TF_SMOOTHSTEP_BEFORE_EPS(abs(p), a, eps)\n#define TF_SMOOTHSTEP_BETWEEN(p, a, b) TF_SMOOTHSTEP_BEFORE(abs(p), a, b)\n//Возвращает \n//\t1 если p > a+eps/2  и  p < b-eps/2; \n//\t0 если p < a-eps/2 или p > b+eps/2; \n//  сглаживание от 0 до 1  между a-eps/2 и a+eps/2\n//  сглаживание от 1 до 0  между b-eps/2 и b+eps/2\n//        1-----1\n//       /       \\\n//      /         \\\n//     /           \\\n//----0             0------\n//    |eps|     |eps|\n//      a         b\n//\n//        1-----1\n//       /       \\\n//      /         \\\n//     /           \\\n//----0             0------\n//   a1   b1    a2  b2\n//\n#define TF_SMOOTHSTEP_BETWEEN2_EPS(p, a, b, eps) TF_SMOOTHSTEP_AFTER_EPS(p, a, eps)*TF_SMOOTHSTEP_BEFORE_EPS(p, b, eps)\n#define TF_SMOOTHSTEP_BETWEEN2(p, a1, b1, a2, b2) TF_SMOOTHSTEP_AFTER(p, a1, b1)*TF_SMOOTHSTEP_BEFORE(p, a2, b2)\n\n//Возвращает для момента u_time номер отрезка времени 0,1,2...\n//                -------\n//               |\n//        -------\n//       |\n//-------\n//   0       1       2\n#define TF_TIMER(u_time, intervalCount, intervalDuration) mod(floor(u_time/(intervalDuration)), (intervalCount))\n\n//-------------------Функции сочетания расстояний до объектов сцены\n//Сложение / Объединение / ИЛИ\nfloat OR(float distA, float distB) {\n\treturn min(distA, distB);\n\t//if (distB<distA) return distB; return distA;\n\t//return mix(distA, distB, step(distB, distA)); \n}\n//Умножение / Пересечение / И\nfloat AND(float distA, float distB) {\n\treturn max(distA, distB);\n\t//if (distB>distA) return distB; return distA;\n\t//return mix(distA, distB, step(distA, distB)); \n}\n// Минимальная функция сглаживания. Есть бесчисленное множество статей, но IQ объясняет это лучше всего здесь:\n// http://iquilezles.org/www/articles/smin/smin.htm\n//Гладкое сложение / Объединение / ИЛИ (k==0 без)\nfloat OR( float distA, float distB, float k ) {\n\tfloat h = clamp( 0.5 + 0.5*(distB-distA)/k, 0., 1. );\n\treturn mix( distB, distA, h ) - k*h*(1.-h);\n}\n//Гладкое умножение / Пересечение / И (k==0 без)\n#if 0\n\tfloat AND( float distA, float distB, float k ) {\n\t\tfloat h = clamp( 0.5 - 0.5*(distB-distA)/k, 0., 1. );\n\t\treturn mix( distB, distA, h ) + k*h*(1.-h);\n\t}\n#else\n\tfloat AND( float distA, float distB, float k ) {\n\t\treturn - OR (- distA, - distB, k);\n\t}\n#endif\n//Исключение / НЕ\nfloat NOT(float dist) {\n\treturn -dist;\n}\n//-------------------Функции сочетания объектов сцены\n\n//Сложение / Объединение / ИЛИ\n//object = OR(objectA, objectB)\nObject OR(Object objectA, Object objectB) {\n\tif (objectB.distance<objectA.distance) return objectB;\n\treturn objectA;\n}\n//Мягкое Сложение / Объединение / ИЛИ  \n//object = OR(objectA, objectB, k)\nObject OR(Object objectA, Object objectB, float k) {\n\tObject object = objectA;\n\tif (objectB.distance<objectA.distance) object = objectB;\n\tif (k!=0.) object.distance = OR(objectA.distance, objectB.distance, k);\n\treturn object;\n}\n//Умножение / Пересечение / И\n//object = AND(objectA, objectB)\nObject AND(Object objectA, Object objectB) {\n\tif (objectB.distance>objectA.distance) return objectB;\n\treturn objectA;\n}\n//Мягкое Умножение / Пересечение / И\n//object = AND(objectA, objectB, k)\nObject AND(Object objectA, Object objectB, float k) {\n\tObject object = objectA;\n\tif (objectB.distance>objectA.distance) object = objectB;\n\tif (k!=0.) object.distance = AND(objectA.distance, objectB.distance, k);\n\treturn object;\n}\n//Исключение / НЕ\n//object = NOT(objectA)\nObject NOT(Object object) {\n\tobject.distance = -object.distance;\n\treturn object;\n}\n","name":"Common","description":"","type":"common"}]}