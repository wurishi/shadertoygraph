{"ver":"0.1","info":{"id":"4sfBz8","date":"1497563294","viewed":341,"name":"Tunnel_Spiral","username":"balkhan","description":"Experimenting some more with space partitioning. ","likes":12,"published":1,"flags":64,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"ldfXzB","filepath":"https://soundcloud.com/krabe/bad-company-the-pulse","previewfilepath":"https://soundcloud.com/krabe/bad-company-the-pulse","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n* Created by bal-khan\n*/\n\n#define I_MAX\t150\n#define E\t\t0.001\n\n#define L1\tvec3(0., 4.75, 1.-t*4.)\n#define L2\tvec3(0.,-4.75, 1.-t*4.)\n\n#define SPIKES\n#define TRIPPY\n#define ANIM -0.5 // Speed of the animation\n//#define CENTERED\n\nvoid\trotate(inout vec2 v, float angle);\nvec3\tcalcNormal( in vec3 pos, float e, vec3 dir);\nfloat\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvec3\tblackbody(float Temp);\nfloat\tscene(vec3 p);\n\n// --globals-- //\nvec3\ttech;\nvec3\th;\nfloat\tt;\nfloat\tmind;\nfloat\ttess;\nfloat\tst;\nfloat\tct;\nfloat\thit;\nfloat\texp_a;\nfloat\tbass;\nfloat\tmedium;\nfloat\thigh;\n// --globals-- //\n\nconst vec3\tlightCol1 = vec3(.1,.3,.7);\nconst vec3\tlightCol2 = vec3(.5,.3,.2);\n\n// blackbody by aiekick : https://www.shadertoy.com/view/lttXDn\n\n// -------------blackbody----------------- //\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\n\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\n// -------------blackbody----------------- //\n\n// sebH's volumetric light : https://www.shadertoy.com/view/XlBSRz\n\n// ------------volumetric light----------- //\n\nvec3 evaluateLight(in vec3 pos)\n{\n    float distanceToL = length(L1-pos);\n    float distanceToL2 = length(L2-pos);\n    return (\n        \tlightCol2 * 1.0/(distanceToL*distanceToL)\n           +lightCol1 * 1.0/(distanceToL2*distanceToL2)\n        \t)*.5;\n}\n\n// ------------volumetric light----------- //\n\t\nvoid mainImage(out vec4 o, in vec2 f )\n{\n\tbass = texture(iChannel0, vec2(.1, .015)).x*20.;\n\tmedium = texture(iChannel0, vec2(.5, .015)).x*20.;\n\thigh = texture(iChannel0, vec2(.8, .015)).x*20.;\n\tt = iTime;\n\texp_a = exp(-t*1.+3.);\n\thit = 0.;\n\ttech = vec3(0.);\n\tvec2 R = iResolution.xy,\n          uv  = vec2(f-R/2.) / R.y;\n    h = vec3(0.);\n    \n    vec3\tdir = camera(uv);\n\t#ifndef CENTERED\n    rotate(dir.zy, -.35);\n    vec3\tpos = vec3(.0, 8.+sin(t)*2., 15.0-t*4. );\n    #else\n    vec3\tpos = vec3(.0, .0250, 15.0-t*4. );\n\t#endif\n    float\tinter = (march(pos, dir));\n\n    if (hit == 1.0)\n    {\n    #ifdef TRIPPY\n    vec3\tp = inter*dir + pos;\n\ttech = vec3(cos(3.*length(p-vec3(high, medium, bass)*.5)+1.04), \n              \tcos(3.*length(p-vec3(high, medium, bass)*.5)+2.08), \n              \tcos(3.*length(p-vec3(high, medium, bass)*.5)+3.14) )*.5\n\t        -\n\t        vec3(cos(20.*length(p+vec3(high, medium, bass)*.5)+1.04),\n    \t         cos(20.*length(p+vec3(high, medium, bass)*.5)+2.08),\n        \t     cos(20.*length(p+vec3(high, medium, bass)*.5)+3.14) )*.5\n        ;\n        if (mind == tess)\n            o.xyz+=vec3(cos(20.*length(p)+1.04), cos(20.*length(p)+2.08), cos(20.*length(p)+3.14) )*.75;\n        else\n\t  \t\to.xyz += tech;\n    #endif\n\t    o.xyz += blackbody(length(h)*20000.+(inter*.51)*(100.-min(100.,100.*exp(-t*1.+3.)) ));\n\t    o.xyz *= (1.-length(uv)*1.); // vignette\n    }\n    o.xyz *= .5;\n    o.xyz += h*1.;\n}\n\nfloat\tscene(vec3 p)\n{\n    float\tmine;\n    mind = mine = tess = 1e5;\n    \n    mine = min(mine, length(p-L1)-.1);\n\tmine = min(mine, length(p-L2)-.1);\n\n    p.xy = abs(p.xy)-2.0+2.*sin(p.z*.125+t*.052*ANIM+bass*.025);\n    p *= .5;\n\tp+= vec3(cos(p.z+t*1.*ANIM)*1.,sin(p.z+t*1.*ANIM)*1.,0.);\n    p.xy=abs(p.xy)-.5;\n    p.x += cos(p.z*3.+t*2.*ANIM)*.5;\n    p.y += sin(p.z*3.+t*2.*ANIM)*.5;\n    \n    mine = min(mine, ( -.02+.02*exp_a+1.01002-length( ( cos(p.x)*cos(p.y ) ) ) ) );\n    \n    #ifdef\tSPIKES\n    if(t > 4.)\n    {\n   \t\tfloat\tba;\n    \tba = length(sin(p.xy))*(.251+0.749*exp_a);\n    \tp.z-=t*.5;\n    \ttess = min(tess,\n    \t          ((ba-.075)+length(sin(vec2(p.y, mod(p.z, .125) )) ))\n    \t          );\n        p*=.5;\n    \trotate(p.xy, -p.z*(7.)*3.-t);\n    \ttess = min(tess, length(vec2(abs(p.y)-.1+0.*.0125*cos(p.z*80.+high*20.-t*20.*ANIM),abs(p.x) ))\n    \t           -.006125-0.*.006125*high-.025*clamp( (40.*sin(p.z*80.+t*30.*ANIM)), .25,.75) );\n\t}\n    #endif\n    mind = min(mine, mind);\n    mind = min(mind, tess);\n    return mind;\n}\n\nfloat\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0);\n    vec3\tp = vec3(0.0);\n\n    for (int i = 1; i < I_MAX; ++i)\n    {\n        hit = 0.;\n    \tp = pos + dir * dist.y;\n        dist.x = scene(p);\n        dist.y += dist.x;\n        h += evaluateLight(p)*.25;\n        if (dist.x < E)\n        {\n           hit = 1.;\n           break;\n        }\n    }\n    return (dist.y);\n}\n\n// Utilities\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n\nvec3\tcamera(vec2 uv)\n{\n    float   fov = 1.;\n\tvec3    forw  = vec3(0.0, 0.0, -1.0);\n\tvec3    right = vec3(1.0, 0.0, 0.0);\n\tvec3    up    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x) * right + (uv.y) * up + fov * forw));\n}\n","name":"Image","description":"","type":"image"}]}