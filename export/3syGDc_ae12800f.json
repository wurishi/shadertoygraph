{"ver":"0.1","info":{"id":"3syGDc","date":"1571055862","viewed":203,"name":"ShaderTober - Snow","username":"Flopine","description":"A small doodle with inktober's theme \"Snow\"","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fractal","snow","inktober"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n#define PI 3.141592\n#define ITER 64.\n\n// taken from YX here : https://www.shadertoy.com/view/tdlXW4\n// rough shadertoy approximation of the bonzomatic noise texture\nvec4 texNoise(vec2 uv)\n{\n    float f = 0.;\n    f += texture(iChannel0, uv*.125).r*.5;\n    f += texture(iChannel0, uv*.25).r*.25;\n    f += texture(iChannel0, uv*.5).r*.125;\n    f += texture(iChannel0, uv*1.).r*.125;\n    f=pow(f,1.2);\n    return vec4(f*.45+.05);\n}\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nvoid moda (inout vec2 p, float rep)\n{\n    float per = 2.*PI/rep;\n    float a= atan(p.y,p.x);\n    float l = length(p);\n    a = mod(a,per)-per*0.5;\n    p = vec2(cos(a),sin(a))*l;\n}\n\nvoid mo (inout vec2 p, vec2 d)\n{\n    p = abs(p)-d;\n    if (p.y>p.x) p = p.yx;\n}\n\nfloat stmin (float a, float b, float k ,float n)\n{\n    float st = k/n;\n    float u = b-k;\n    return min(min(a,b), 0.5*(u+a+abs(mod(u-a+st,2.*st)-st)));\n}\n\nfloat cyl (vec2 p, float r)\n{return length(p)-r;}\n\nfloat box (vec3 p, vec3 c)\n{return length(max(abs(p)-c,0.));}\n\nfloat prim1 (vec3 p)\n{\n    float b = box(p, vec3(0.3,4.,0.08));\n    p.xz *= rot(p.y+iTime);\n    moda(p.xz, 5.);\n    p.x -= 0.4+sin(p.y)*0.3;\n    \n    return stmin(b,cyl(p.xz, 0.08),0.4,3.);\n}\n\nfloat fractal (vec3 p)\n{\n    float d = 1e10;\n    for (int i=0; i<=4; i++)\n    {\n        float ratio = float(i)/5.;\n        p.xz *= rot(PI*ratio);\n        mo(p.xy, vec2(1.+ratio*2.,0.5+ratio*2.));\n        p.yz *= rot(iTime*ratio);\n        p -= 5.+ratio*2.+texNoise(p.xy*0.5).r*0.4;\n            \n        d = min(d,prim1(p));\n    }\n    return d;\n}\n\nfloat SDF (vec3 p)\n{return fractal(p);}\n\nvec3 getnorm(vec3 p)\n{\n    vec2 eps = vec2(0.1,0.);\n    return normalize(SDF(p)-vec3(SDF(p-eps.xyy), SDF(p-eps.yxy), SDF(p-eps.yyx)));\n}\n\nfloat dir_light (vec3 n, vec3 l)\n{return dot(n,normalize(l))-0.5+.5;}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy) / iResolution.y;\n\t\n    vec3 ro = vec3(0.001,0.001,-4.),\n        p = ro,\n        rd = normalize(vec3(uv,1.)),\n        col = vec3(0.),\n   \t\tl = vec3(1.,0.,-3.); \n        \n    float shad = 0.;\n    bool hit = false;\n    \n    for (float i = 0.; i < ITER; i++)\n    {\n        float d = SDF(p);\n        if (d < 0.01)\n        {\n            hit = true;\n            shad = i/ITER;\n            break;\n        }\n        p += d*rd;\n    }\n    \n    if (hit)\n    {\n        vec3 n = getnorm(p);\n        col = mix(vec3(0.2, 0.5, 0.5),vec3(0.8,0.8,0.9),dir_light(n,l));\n        col *= 1.-shad;\n    }\n    \n    // Output to screen\n    fragColor = vec4(sqrt(col),1.0);\n}","name":"Image","description":"","type":"image"}]}