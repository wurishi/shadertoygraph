{"ver":"0.1","info":{"id":"wdGBWR","date":"1682499747","viewed":107,"name":"Fancy ties Yellow Moth Remix","username":"ytktkd69","description":"2020 12 02 test1 ","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarchingflare"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fancy ties by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/ltfGDs\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n/*\n\tSomewhat complex modelling in a fully procedural shader that runs decently fast.\n\tI kinda cheated on the wings, the real ones are less hexagonal than this.\n\tNot doing proper occlusion checking for the lens flares to keep it fast.\n*/\n\n#define ITR 100\n#define FAR  165. // 155.\n#define time iTime\n\nconst float fov = 4. ; // De 1.5;    how to zoom\n\n//Global material id (keeps code cleaner)\nfloat matid = 0.;\n\n//--------------------Utility, Domain folding and Primitives---------------------\nfloat tri(in float x){return abs(fract(x)-.5);}\nmat3 rot_x(float a){float sa = sin(a); float ca = cos(a); return mat3(1.,.0,.0,    .0,ca,sa,   .0,-sa,ca);}\nmat3 rot_y(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,.0,sa,    .0,1.,.0,   -sa,.0,ca);}\nmat3 rot_z(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,sa,.0,    -sa,ca,.0,  .0,.0,1.);}\nvec3 rotz(vec3 p, float a){\n    float s = sin(a), c = cos(a);\n    return vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\n/////////////////////////////////////////////////////////////\nfloat hash(vec2 p){ float h = dot(p,vec2(127.1,311.7));\n                   return fract(sin(h)*43758.5453) ; }\nvec2 nmzHash22(vec2 q) {\n    return vec2(hash(q),hash(q.xy));}\n            \n \nfloat hash(vec3 p){ float h = dot(p,vec3(127.1,311.7, 758.5453123));\n                   return fract(sin(h)*43758.5453123); }\nvec3 nmzHash33(vec3 p){\n    return vec3(hash(p),hash(p.zyx),hash(p.yxz)); }\n////////////////////////////////////////////////////////////////\n//2dFoldings, inspired by Gaz/Knighty  see: https://www.shadertoy.com/view/4tX3DS\nvec2 foldHex(in vec2 p)\n{\n    p.xy = abs(p.xy);\n    const vec2 pl1 = vec2(-0.5, 0.8657);\n    const vec2 pl2 = vec2(-0.8657, 0.5);\n    p -= pl1*2.*min(0., dot(p, pl1));\n    p -= pl2*2.*min(0., dot(p, pl2));\n    return p;\n}\n\nvec2 foldOct(in vec2 p)\n{\n    p.xy = abs(p.xy);\n    const vec2 pl1 = vec2(-0.7071, 0.7071);\n    const vec2 pl2 = vec2(-0.9237, 0.3827);\n    p -= pl1*2.*min(0., dot(p, pl1));\n    p -= pl2*2.*min(0., dot(p, pl2));\n    \n    return p;\n}\n\nfloat sbox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat cyl( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat torus( vec3 p, vec2 t ){\n  return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\n//using floor() in a SDF causes degeneracy.\nfloat smoothfloor(in float x, in float k)\n{\n    float xk = x+k*0.5;\n    return floor(xk-1.) + smoothstep(0.,k,fract(xk));\n}\n\nfloat hexprism(vec3 p, vec2 h){\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.y*0.866025+q.x*0.5),q.x)-h.x);\n}\n\n// ------------------------------------------------------- adition\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n/////////////////////////////////////////////------------ adition dr2\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  const vec3 cHashVA3 = vec3 (37.1, 61.7, 12.4);\n  const vec3 e = vec3 (1., 0., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Noisefv3a (vec3 p)\n{\n  vec3 i, f;\n  i = floor (p);  f = fract (p);\n  f *= f * (3. - 2. * f);\n  vec4 t1 = Hashv4v3 (i);\n  vec4 t2 = Hashv4v3 (i + vec3 (0., 0., 1.));\n  return mix (mix (mix (t1.x, t1.y, f.x), mix (t1.z, t1.w, f.x), f.y),\n              mix (mix (t2.x, t2.y, f.x), mix (t2.z, t2.w, f.x), f.y), f.z);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  const mat3 mr = mat3 (0., 0.8, 0.6, -0.8, 0.36, -0.48, -0.6, -0.48, 0.64);\n  float f, a, am, ap;\n  f = 0.;  a = 0.5;\n  am = 0.5;  ap = 4.;\n  p *= 0.5;\n  for (int i = 0; i < 6; i ++) {\n    f += a * Noisefv3a (p);\n    p *= mr * ap;  a *= am;\n  }\n  return f;\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s = vec3 (0.);\n  float a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 e = vec3 (0.2, 0., 0.);\n  float s = Fbmn (p, n);\n  vec3 g = vec3 (Fbmn (p + e.xyy, n) - s,\n     Fbmn (p + e.yxy, n) - s, Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) * vec2 (1., 1.) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., h * clamp (p.z / h, -1., 1.))) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h)\n{\n  return max (length (p.xy - vec2 (rhi *\n     clamp (p.x / rhi, -1., 1.), 0.)) - rlo, abs (p.z) - h);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r) {\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nint idObj;\nmat3 flMat;\nvec3 flPos, qHit, qHitTransObj, sunDir;\nfloat fusLen, wSpan, flyVel, tCur;\nconst float dstFar = 350.;\nconst int idFus = 11, idPipe = 12, idWing = 13, idStrut = 14,\n   idHstab = 15, idFin = 16, idLeg = 17, idAxl = 18, idWhl = 19,\n   idNose = 20, idCkpit = 21, idPlt = 22, idWing1= 25 ,idWhl2 =26  ;\n\n\n//------------------------------------------------------------------------\n\nvec3 position(in vec3 p)\n{\n    float dst = 2.5 ; //   de 7.;\n    float id =  floor (p.z/dst*.1);  // body expand  or shrink\n    p.xy += (sin(id*10.+time));          // flat flight\n    p.z += abs(sin(id*10.+time*0.9))*.5;\n    p = rotz(p,sin(time*0.5)*1.+id*0.1);   // no rotation\n    p.z = (abs(p.z)-dst) *sign(p.z) ;\n    return p;\n}\n\nfloat map(vec3 p)\n{\n                            \n    ////////////////////////////////////////////////////////////  \n    // -------------------------------------------- dr2 Yellow Moth airplane ad\n    float dMin=dstFar;\n    vec3 q, qq;  matid=1.;\n  float d, wr;\n    p *=0.65 ;\n  q = p;\n  wr = -0.2 + q.z / fusLen;\n  d = PrRoundBoxDf (q, vec3 (0.07 * (1. - 0.8 * wr * wr),\n     0.11 * (1. - 0.6 * wr * wr), 1.) * fusLen, 0.05 * fusLen);\n  q -= vec3 (0., 0.1, 0.3) * fusLen;\n  d = max (d, - PrRoundBoxDf (q, vec3 (0.05, 0.1, 0.15) * fusLen,\n     0.03 * fusLen)); \n    \n  if (d < dMin) { dMin = min (dMin, d);  idObj = idFus;  qHit = q; }// idFus=body\n    \n  q = p;  q -= vec3 (0., 0.08, 0.3) * fusLen;\n//  d = PrRoundBoxDf (q, vec3 (0.05, 0.02, 0.15) * fusLen, 0.03 * fusLen); \n    d =min(d,PrRoundBoxDf (q, vec3 (0.05, 0.02, 0.15) * fusLen, 0.03 * fusLen)); \n // if (d < dMin) { dMin = min (dMin, d);  idObj = idCkpit;  qHit = q; }\n  q = p;  q.z = abs (q.z - 0.33 * fusLen) - 0.08 * fusLen;\n  q -= vec3 (0., 0.17, 0.) * fusLen;\n//  d = PrSphDf (q, 0.04 * fusLen); \n    d =min(d,PrSphDf (q, 0.04 * fusLen)); \n//  if (d < dMin) { dMin = min (dMin, d);  idObj = idPlt;  qHit = q; }\n    \n  q = p - fusLen * vec3 (0., 0.03, 0.8);\n  q.x = abs (q.x) - 0.1 * fusLen;\n//  d = PrCapsDf (q, 0.02 * fusLen, 0.15 * fusLen);\n    d =min(d,PrCapsDf (q, 0.02 * fusLen, 0.15 * fusLen));\n  //  if (d < dMin) { dMin = min (dMin, d);  idObj = idPipe;  qHit = q; }\n    \n  q = p - fusLen * vec3 (0., 0.03, 1.05);\n//  d = PrCapsDf (q, 0.05 * fusLen, 0.02 * fusLen);\n    d =min(d,PrCapsDf (q, 0.05 * fusLen, 0.02 * fusLen));\n //  if (d < dMin) { dMin = d;  idObj = idNose;  qHit = q; }\n    //---------------------------------------------------- Propel\n    \n    \n    //------------------------------------------------------\n    \n    \n  q = p - fusLen * vec3 (0., 0.09, 0.2);\n  qq = q;  qq.y = abs (qq.y) - 0.21 * fusLen;\n  wr = q.x / wSpan;\n    //-------------------------------------------------- check wing color\n  float d1 = PrFlatCylDf (qq.zyx, 0.24 * (1. - 0.2 * wr * wr) * fusLen,\n     0.01 * (1. - 0.8 * wr * wr) * fusLen, wSpan);\n    if (d1 < dMin) { dMin = min (dMin, d1);  idObj = idWing1;  qHit = q; }\n    //---------------------------------------------------\n    \n    d =min(d,PrFlatCylDf (qq.zyx, 0.24 * (1. - 0.2 * wr * wr) * fusLen,\n          0.01 * (1. - 0.8 * wr * wr) * fusLen, wSpan));                     \n  if (d < dMin) { dMin = min (dMin, d);  idObj = idWing;  qHit = q; }\n    \n  q = p - fusLen * vec3 (0., 0.09, 0.25);\n  q.xz = abs (q.xz) - fusLen * vec2 (0.5, 0.1);\n // d = PrCylDf (q.xzy, 0.01 * fusLen, 0.21 * fusLen);\n    d =min(d,PrCylDf (q.xzy, 0.01 * fusLen, 0.21 * fusLen));\n // if (d < dMin) { dMin = min (dMin, d);  idObj = idStrut;  qHit = q; }\n    \n  q = p - fusLen * vec3 (0., 0.15, 0.25);\n  q.x = abs (q.x) - 0.1 * fusLen;\n//  d = PrCylDf (q.xzy, 0.01 * fusLen, 0.15 * fusLen);\n    d =min(d, PrCylDf (q.xzy, 0.01 * fusLen, 0.15 * fusLen));\n // if (d < dMin) { dMin = min (dMin, d);  idObj = idStrut;  qHit = q; }\n    \n    //////////////////////////////////////////////////pennding\n  float tSpan = 0.35 * wSpan;\n  q = p - fusLen * vec3 (0., 0., - 0.9);\n  wr = q.x / tSpan;\n\n  d =min(d,PrFlatCylDf (q.zyx, 0.15 * (1. - 0.25 * wr * wr) * fusLen,\n     0.007 * (1. - 0.2 * wr * wr) * fusLen, tSpan));\n\n  q.x = abs (q.x);\n  d = max (d, 0.02 * fusLen - 1.5 * q.x - q.z);\n //   d =min(d,max (d, 0.02 * fusLen - 1.5 * q.x - q.z));\n // if (d < dMin) { dMin = min (dMin, d);  idObj = idHstab;  qHit = q; }\n   //\n    /////////////////////////////////////////////////pennding\n    \n  float fSpan = 0.32 * wSpan;\n  q = p - fusLen * vec3 (0., 0.2, - 0.87);\n  q.yz = Rot2D (q.yz, 0.35);\n  wr = q.y / fSpan;\n//  d = PrFlatCylDf (q.zxy, 0.15 * (1. - 0.3 * wr * wr) * fusLen,\n//     0.007 * (1. - 0.3 * wr * wr) * fusLen, fSpan);\n    \n    d =min(d,PrFlatCylDf (q.zxy, 0.115 * (1. - 0.3 * wr * wr) * fusLen,\n          0.007 * (1. - 0.3 * wr * wr) * fusLen, fSpan*0.4));                \n //----------------------------------------------------------   ad Fin color\n    if (d < dMin) { dMin = min (dMin, d);  idObj = idFin;  qHit = q; }\n  //---------------------------------------------------------  \n  //  d = max (d,  -0.2*q.y-0.1);           //  ???? cut by y axis=0. plane\n\n    \n//  if (d < dMin) { dMin = min (dMin, d);  idObj = idFin;  qHit = q; }\n \n   q = p - fusLen * vec3 (0., -0.25, 0.5);\n  q.x = abs (q.x) - 0.14 * fusLen;\n  q.xy = Rot2D (q.xy, -0.55);  q.yz = Rot2D (q.yz, 0.15);\n // d = PrCylDf (q.xzy, 0.013 * fusLen, 0.12 * fusLen);\n    d =min(d,PrCylDf (q.xzy, 0.013 * fusLen, 0.12 * fusLen));\n\n//  if (d < dMin) { dMin = d;  idObj = idLeg;  qHit = q; }\n    \n  q = p - fusLen * vec3 (0., -0.34, 0.515);\n  q.x = abs (q.x) - 0.22 * fusLen;\n // d = PrCylDf (q.yzx, 0.01 * fusLen, 0.035 * fusLen);\n    d =min(d,PrCylDf (q.yzx, 0.01 * fusLen, 0.035 * fusLen));\n\n//  if (d < dMin) { dMin = d;  idObj = idAxl;  qHit = q; }\n    \n  q.x -= 0.01 * fusLen;\n    //---------------------------------------------- Whl color ad\n    float d2 = PrCylDf (q.yzx, 0.1 * fusLen, 0.015 * fusLen);\n       if (d2 < dMin) { dMin = d2;  idObj = idWhl2;  qHit = q; }   \n    //------------------------------------------------------\n    \n    d =min(d,PrCylDf (q.yzx, 0.1 * fusLen, 0.015 * fusLen));\n    //-------------------------------------------------------\n    \n//  if (d < dMin) { dMin = d;  idObj = idWhl;  qHit = q; }  \n    \n    //\t----------------------------------------------------Propela\n   // q=p;\n    q =p-fusLen*vec3(0.,0.02,1.07);\n     q.xy *=rot(time*38.0);     // Propela rotation\n   \n    \n     d =min(d, PrRoundBoxDf(q,vec3(0.35*fusLen,0.013*fusLen,0.007*fusLen),0.002));\n   //------------------------------------- the second blade ad failure\n    \n  \n    \n  return  d  /*dMin */;\n    \n    \n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tfloat precis = 0.001;\n    float h=precis ; // *2.0;\n    float d = 0.;\n    for( int i=0; i< 100 /*ITR */; i++ )\n    {\n        if( abs(h)<precis || d>FAR ) break;\n        d += h;\n        float res = map(position(ro+rd*d)) ; //*0.93;\n        h = res;\n    }\n\treturn d;\n}\n\n//greeble-ish texture\n\n\n//---------------------------------------- change\n\nvec3 normal(const in vec3 p)\n{  \n    vec2 e = vec2(-1., 1.)*0.008;\n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n   \n//----------------------------------------\n\n//form iq\nfloat getAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.13*float(i)/3.;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1. - 3.5*occ, 0.0, 1.0 );    \n}\n\n//smooth and cheap 3d starfield\nvec3 stars(in vec3 p)\n{\n    vec3 c = vec3(0.);\n    float res = iResolution.x*.85*fov;\n    \n    //Triangular deformation (used to break sphere intersection pattterns)\n    p.x += (tri(p.z*50.)+tri(p.y*50.))*0.006;\n    p.y += (tri(p.z*50.)+tri(p.x*50.))*0.006;\n    p.z += (tri(p.x*50.)+tri(p.y*50.))*0.006;\n    \n\tfor (float i=0.;i<3.;i++)\n    {\n        vec3 q = fract(p*(.15*res))-0.5;\n        vec3 id = floor(p*(.15*res));\n        float rn = nmzHash33(id).z;\n        float c2 = 1.-smoothstep(-0.2,.4,length(q));\n        c2 *= step(rn,0.005+i*0.014);\n        c += c2*(mix(vec3(1.0,0.75,0.5),vec3(0.85,0.9,1.),rn*30.)*0.5 + 0.5);\n        p *= 1.15;\n    }\n    return c*c*1.5;\n}\n\nvec3 flare(in vec2 p, in vec2 pos, in vec3 lcol, in float sz)\n{\n\tvec2 q = p-pos;\n    q *= sz;\n\tfloat a = atan(q.x,q.y);\n    float r = length(q);\n    \n    float rz= 0.;\n    rz += .07/(length((q)*vec2(7.,200.))); //horiz streaks\n    rz += 0.3*(pow(abs(fract(a*.97+.52)-0.5),3.)*(sin(a*30.)*0.15+0.85)*exp2((-r*5.))); //Spokes\n\t\n    vec3 col = vec3(rz)*lcol;   \n    col += exp2((1.-length(q))*50.-50.)*lcol*vec3(3.);\n    col += exp2((1.-length(q))*20.-20.)*lcol*vec3(1,0.95,0.8)*0.5;    \n    return clamp(col,0.,1.);\n}\n\n\n//A weird looking small moon\nfloat slength(in vec2 p){ return max(abs(p.x), abs(p.y)); }\nfloat moontex(in vec3 p)\n{\n    float r = length(p);\n    vec3 q = vec3(r, acos(p.y/r), atan(p.z,p.x));\n    q *= 6.5;\n    vec3 bq = q;\n    q.y = q.y*0.44-0.42;\n    vec2 id = floor(q.zy);\n    vec2 s = fract(q.zy)-0.5;\n    \n    float rz = 1.;\n    float z = 0.25;\n    for(int i=0;i<=3;i++)\n    {\n        vec2 rn = nmzHash22(id+vec2(i)+0.0019)*.6 + 0.4;\n        s -= abs(s)-rn*0.45;\n        rz -= smoothstep(0.5,0.45-float(i)*0.1,slength(s*rn*1.3))*z;\n        q *= 3.5;\n        z *= .85;\n        id = floor(q.zy);\n    \ts = fract(q.zy)-0.5;\n    }\n    \n    rz -= smoothstep(0.035,.03,abs(bq.y-10.15))*.3; //main trench\n    return rz;\n}\n\nfloat sphr(in vec3 ro, in vec3 rd, in vec4 sph)\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot(oc,rd);\n\tfloat c = dot(oc,oc) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif (h < 0.) return -1.;\n\telse return -b - sqrt(h);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 p = fragCoord.xy/iResolution.xy-0.5;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 mo = iMouse.xy / iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(-0.15,0.):mo;\n\tmo.x *= iResolution.x/iResolution.y;\n    mo*=4.;\n\tmo.x += time*0.17+0.1;\n    \n    fusLen=1.;  wSpan=1.2*fusLen ;\n\n    vec3 ro = vec3(0.,0.,17.);\n    vec3 rd = normalize(vec3(vec2(-p.x,p.y),-fov));\n    float cms = 1.-step(sin((time+0.0001)*0.5),0.);\n    mat3 inv_cam = mat3(0);\n    \n    if ( mod(floor(time),40.)<20.0 /* cms < 0.5  */) // time interval change\n    {\n        mat3 cam = rot_x(-mo.y)*rot_y(-mo.x);\n        inv_cam = rot_y(-mo.x)*rot_x(mo.y); \n        ro *= cam;rd *= cam;\n    }\n    else\n    {\n        float frct = fract(time*0.105915);  // de time*0.15915=1.=> time =7.1sec\n        float frct2 = fract(time*0.15915+0.50001);\n        float cms = 1.-step(sin((time+0.0001)*0.5),0.);\n        ro = vec3(-15.,1.-(step(frct2,0.5))*frct2*10.,140.-frct*280.);\n        vec3 ta = vec3(0);\n    \n        \n        vec3 fwd = normalize(ta - ro);\n        vec3 rgt = normalize(cross(vec3(0., 1., 0.), fwd ));\n        vec3 up = normalize(cross(fwd, rgt));\n        mat3 cam = mat3(rgt,up,-fwd);\n        rd = normalize(vec3(vec2(p.x,p.y),-fov))*cam;\n        inv_cam = transpose(cam);\n    }\n    \n\tfloat rz = march(ro,rd);\n\t\n    vec3 lgt = normalize( vec3(.2, 0.1535, 0.7) ); // pos of sun\n    vec3 col = vec3(0.0);\n    float sdt = max(dot(rd,lgt),0.); \n    \n    vec3 lcol = vec3(1,.85,0.73);\n    col += stars(rd);\n    \n    vec3 fp = (-lgt*inv_cam);\n    col += clamp(flare(p,-fp.xy/fp.z*fov*1.5/fov, lcol,0.5)*fp.z*1.1,0.,1.);\n    \n    //Another nearby star       \n    vec3 lcol2 = vec3(0.25,0.66,0.234*sin(time*0.5));          // de (0.25,.38,1); blue+white\n    vec3 lgt2 = normalize(vec3(-0.2,-.1,-0.8));   // pos of planet\n    fp = (-lgt2*inv_cam);\n    col += clamp(flare(p,-fp.xy/fp.z*fov*1.5/fov, lcol2,0.5*(1.+0.3*sin(time)))*fp.z*1.1,0.,1.);\n    \n    //A \"moon\"  /////////////////////////////////////////\n    vec4 sph = vec4(2500,500,-00,1800);\n    float mn = sphr(ro,rd,sph);\n    \n    if (mn > 0.)\n    {\n        vec3 pos = ro+rd*mn;\n        vec3 nor = normalize(pos-sph.xyz);\n        vec3 dif = clamp(dot( nor, lgt ), 0., 1.)*0.985*lcol;\n        vec3 bac = clamp( dot( nor, lgt2), 0.0, 1.0 )*lcol2;\n        col = moontex((pos-sph.xyz))*vec3(0.852,0.754 /**sin(time*0.4)*/,0.7)*0.93;\n        col *= dif + bac*0.01 + 0.005;\n    }\n    \n    \n    if ( rz < FAR  )\n    {\n        float mat = matid;\n        vec3 pos = ro+rz*rd;\n        pos = position(pos);\n        vec3 nor= normal(pos);\n        float dif = clamp( dot( nor, lgt ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, lgt2), 0.0, 1.0 );\n        float spe = pow(clamp( dot( reflect(rd,nor), lgt ), 0.0, 1.0 ),7.);\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 3.0 );\n        vec3 brdf = /*vec3(0) ;*/ vec3 (0.95,0.904,0.02);\n        brdf += bac*mix(lcol2,vec3(1),0.5)*0.06;\n        brdf += 1.5*dif*lcol;\n        col = vec3(0.52954,0.7956,0.2965)*1.5;\n        col *= col;\n        \n        if(idObj ==idFus ) {col =vec3(0.,0.18,0.568) ; }\n        else if(idObj ==idWing1 ){col =vec3(0.94,0.5045,0.753000) ; \n                                  \n                //   brdf *= 0.510045;\n               //    spe *= 0.135;\n              //     fre *= 0.05;   \n                /*     col=col*brdf+spe+fre; */   }  // check\n        else if(idObj ==idFin ) {col=vec3(0.8,1.,0.3);    }\n        else if(idObj ==idWhl2   ) {col =vec3(0.5,0.6,0.4) ;   }\n        \n \n        \n        col = col*brdf + spe*.23 +.03*fre;\n        col *= getAO(pos,nor);\n    }\n    \n    col = clamp(col, 0.,1.);\n    col = pow(clamp(col,0.,1.), vec3(0.416667))*1.055 - 0.055; //sRGB\n\t\n\tfragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}