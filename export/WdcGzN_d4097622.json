{"ver":"0.1","info":{"id":"WdcGzN","date":"1567884392","viewed":298,"name":"Dual Quaternion Julia Set","username":"skye_adaire","description":"Uses automatic differentiation to compute the distance estimate and surface normal. The hypercomplex functions are my design. This draws heavily from http://blog.hvidtfeldts.net/index.php/2011/12/distance-estimated-3d-fractals-vii-dual-numbers/","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["fractal","julia","quaternion","dual","set","automatic","hypercomplex","differentiation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//created by Skye Adaire\n\n#define pi32 3.1415926535\n#define tau32 6.2831853072\n#define eps32 10e-15\n\n//begin Hypercomplex\n\n#define Real float\n\nReal H_negate(Real r)\n{\n    return -r;\n}\n\nReal H_conjugate(Real r)\n{\n    return r;\n}\n\nReal H_norm(Real r)\n{\n    return abs(r);\n}\n\nReal H_sqnorm(Real r)\n{\n    return r * r;\n}\n\nReal H_add(Real lhs, Real rhs)\n{\n    return lhs + rhs;\n}\n\nReal H_subtract(Real lhs, Real rhs)\n{\n    return lhs - rhs;\n}\n\nReal H_multiply(Real lhs, Real rhs)\n{\n    return lhs * rhs;\n}\n\nReal H_divide(Real lhs, Real rhs)\n{\n    return lhs / rhs;\n}\n\nbool H_isZero(Real r)\n{\n    return H_norm(r) < eps32;\n}\n\nReal H_sq(Real r)\n{\n    return r * r;\n}\n\n#define Complex vec2\n\nComplex H_negate(Complex h)\n{\n    return -h;\n}\n\nComplex H_conjugate(Complex h)\n{\n    return Complex(h[0], -h[1]);\n}\n\nReal H_sqnorm(Complex h)\n{\n    return dot(h, h);\n}\n\nReal H_norm(Complex h)\n{\n    return length(h);\n}\n\nComplex H_inverse(Complex h)\n{\n    return H_conjugate(h) / H_sqnorm(h);\n}\n\nComplex H_normalize(Complex h)\n{\n    return normalize(h);\n}\n\nComplex H_add(Complex lhs, Complex rhs)\n{\n    return lhs + rhs;\n}\n\nComplex H_subtract(Complex lhs, Complex rhs)\n{\n    return lhs - rhs;\n}\n\nComplex H_multiply(Complex lhs, Complex rhs)\n{\n    Real lhs_0 = lhs[0];\n    Real lhs_1 = lhs[1];\n    Real rhs_0 = rhs[0];\n    Real rhs_1 = rhs[1];\n\n    return Complex(\n        H_subtract(H_multiply(lhs_0, rhs_0), H_multiply(H_conjugate(rhs_1), lhs_1)),\n        H_add(H_multiply(rhs_1, lhs_0), H_multiply(lhs_1, H_conjugate(rhs_0))));\n}\n\nComplex H_divide(Complex lhs, Complex rhs)\n{\n    return H_multiply(lhs, H_conjugate(rhs)) / H_sqnorm(rhs);\n}\n\nbool H_isZero(Complex h)\n{\n    return H_norm(h) < eps32;\n}\n\nReal H_argument(Complex h)\n{\n   return atan(h[1], h[0]);//[-pi, pi]\n}\n\nReal H_argument2(Complex h)\n{\n    Real angle = H_argument(h);\n    return angle < Real(0) ? angle + tau32 : angle;//[0, tau]\n}\n\nComplex H_versor(Real angle)\n{\n    return Complex(cos(angle), sin(angle));\n}\n\nstruct PolarComplex\n{\n    float norm;\n    float argument;\n};\n\nPolarComplex H_toPolar(Complex h)\n{\n    return PolarComplex(H_norm(h), H_argument(h));\n}\n\nComplex H_toCartesian(PolarComplex h)\n{\n    return h.norm * H_versor(h.argument);\n}\n\nPolarComplex H_power(PolarComplex polar, Real exponent)\n{\n    return PolarComplex(pow(polar.norm, exponent), polar.argument * exponent);\n}\n\nComplex H_power(Complex h, Real exponent)\n{\n    return H_toCartesian(H_power(H_toPolar(h), exponent));\n}\n\nComplex H_sq(Complex h)\n{\n    return H_multiply(h, h);\n}\n\n#define Quaternion vec4\n\nQuaternion H_negate(Quaternion h)\n{\n    return -h;\n}\n\nQuaternion H_conjugate(Quaternion h)\n{\n    return Quaternion(h[0], -h[1], -h[2], -h[3]);\n}\n\nReal H_sqnorm(Quaternion h)\n{\n    return dot(h, h);\n}\n\nReal H_norm(Quaternion h)\n{\n    return length(h);\n}\n\nQuaternion H_inverse(Quaternion h)\n{\n    return H_conjugate(h) / H_sqnorm(h);\n}\n\nQuaternion H_normalize(Quaternion h)\n{\n    return normalize(h);\n}\n\nQuaternion H_add(Quaternion lhs, Quaternion rhs)\n{\n    return lhs + rhs;\n}\n\nQuaternion H_subtract(Quaternion lhs, Quaternion rhs)\n{\n    return lhs - rhs;\n}\n\nQuaternion H_multiply(Quaternion lhs, Quaternion rhs)\n{\n    Complex lhs_0 = Complex(lhs[0], lhs[1]);\n    Complex lhs_1 = Complex(lhs[2], lhs[3]);\n    Complex rhs_0 = Complex(rhs[0], rhs[1]);\n    Complex rhs_1 = Complex(rhs[2], rhs[3]);\n\n    return Quaternion(\n        H_subtract(H_multiply(lhs_0, rhs_0), H_multiply(H_conjugate(rhs_1), lhs_1)),\n        H_add(H_multiply(rhs_1, lhs_0), H_multiply(lhs_1, H_conjugate(rhs_0))));\n}\n\nQuaternion H_divide(Quaternion lhs, Quaternion rhs)\n{\n    return H_multiply(lhs, H_conjugate(rhs)) / H_sqnorm(rhs);\n}\n\nbool H_isZero(Quaternion h)\n{\n    return H_norm(h) < eps32;\n}\n\nstruct PolarQuaternion\n{\n    Real norm;\n    Real angle;\n    vec3 axis;//normalized\n};\n\nPolarQuaternion H_toPolar(Quaternion h)\n{\n    PolarQuaternion result;\n    Real vectorLength2 = dot(h.yzw, h.yzw);\n\n    if(H_isZero(vectorLength2))\n    {\n        result.axis = vec3(0);\n    }\n    else//normalize the vector part\n    {\n        result.axis = h.yzw / sqrt(vectorLength2);\n    }\n\n    result.norm = sqrt(H_sq(h[0]) + vectorLength2);\n\n    if(H_isZero(result.norm))\n    {\n        result.angle = 0.0;\n    }\n    else\n    {\n        result.angle = acos(h[0] / result.norm);\n    }\n\n    return result;\n}\n\nQuaternion H_toCartesian(PolarQuaternion p)\n{\n    return p.norm * Quaternion(cos(p.angle), sin(p.angle) * p.axis);\n}\n\nQuaternion H_versor(Real angle, vec3 axis)\n{\n    return H_toCartesian(PolarQuaternion(1.0, angle / 2.0, axis));\n}\n\nPolarQuaternion H_power(PolarQuaternion polar, Real exponent)\n{\n    polar.norm = pow(polar.norm, exponent);\n    polar.angle = polar.angle * exponent;\n    return polar;\n}\n\nQuaternion H_power(Quaternion h, Real exponent)\n{\n    if(H_isZero(exponent))\n    {\n        return Quaternion(1,0,0,0);\n    }\n    else\n    {\n        return H_toCartesian(H_power(H_toPolar(h), exponent));\n    }\n}\n\nQuaternion H_sq(Quaternion h)\n{\n    return H_multiply(h, h);\n}\n\n#define DualComplex mat2x2\n\nDualComplex D_add(DualComplex lhs, DualComplex rhs)\n{\n    return lhs + rhs;\n}\n\nDualComplex D_subtract(DualComplex lhs, DualComplex rhs)\n{\n    return lhs - rhs;\n}\n\nDualComplex D_multiply(DualComplex lhs, DualComplex rhs)\n{\n    return DualComplex(\n        H_multiply(rhs[0], lhs[0]),\n        H_add(H_multiply(lhs[1], rhs[0]), H_multiply(lhs[0], rhs[1])));\n}\n\nDualComplex D_divide(DualComplex lhs, DualComplex rhs)\n{\n    return DualComplex(\n        H_divide(rhs[0], lhs[0]),\n        H_divide(\n            H_subtract(H_multiply(lhs[1], rhs[0]), H_multiply(lhs[0], rhs[1])),\n            H_sq(rhs[0])));\n}\n\n#define DualQuaternion mat2x4\n\nDualQuaternion D_add(DualQuaternion lhs, DualQuaternion rhs)\n{\n    return lhs + rhs;\n}\n\nDualQuaternion D_subtract(DualQuaternion lhs, DualQuaternion rhs)\n{\n    return lhs - rhs;\n}\n\nDualQuaternion D_multiply(DualQuaternion lhs, DualQuaternion rhs)\n{\n    return DualQuaternion(\n        H_multiply(lhs[0], rhs[0]),\n        H_add(H_multiply(lhs[1], rhs[0]), H_multiply(lhs[0], rhs[1])));\n}\n\nDualQuaternion D_divide(DualQuaternion lhs, DualQuaternion rhs)\n{\n    return DualQuaternion(\n        H_divide(rhs[0], lhs[0]),\n        H_divide(\n            H_subtract(H_multiply(lhs[1], rhs[0]), H_multiply(lhs[0], rhs[1])),\n            H_sq(rhs[0])));\n}\n\nDualQuaternion D_power(DualQuaternion d, Real exponent)\n{\n    return DualQuaternion(\n        H_power(d[0], exponent),\n        H_multiply(exponent * H_power(d[0], exponent - 1.0), d[1]));\n}\n\n//end Hypercomplex\n\nmat3 rotation3XZ(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n}\n\nfloat getJuliaDE(DualQuaternion dd, vec3 inPosition, out vec3 outNormal, out int i)\n{\n    Quaternion c = Quaternion(inPosition, 0);\n\n    //gradient\n    DualQuaternion dx = DualQuaternion(c, Quaternion(1,0,0,0));\n    DualQuaternion dy = DualQuaternion(c, Quaternion(0,1,0,0));\n    DualQuaternion dz = DualQuaternion(c, Quaternion(0,0,1,0));\n\n    for(i = 0; i <= 10; i++)\n    {\n        if(H_sqnorm(dx[0]) > 16.0)\n        {\n            break;\n        }\n\n        dx = D_add(D_multiply(dx, dx), dd);\n        dy = D_add(D_multiply(dy, dy), dd);\n        dz = D_add(D_multiply(dz, dz), dd);\n    }\n\n    //the final position is the same for all partials\n    vec3 fp = dx[0].xyz;\n    float r = H_norm(dx[0]);\n    \n    vec3 vdx = vec3(dx[1]);\n    vec3 vdy = vec3(dy[1]);\n    vec3 vdz = vec3(dz[1]);\n    float dr = length(vdx) + length(vdy) + length(vdz);\n    outNormal = normalize(vec3(dot(fp, vdx), dot(fp, vdy), dot(fp, vdz)));\n\n  \treturn 0.5 * log(r) * r / dr;//better for low iteration counts\n    //return 0.5 * r / dr;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 clip = uv * 2.0 - 1.0;\n    vec2 unitSpacePosition = 0.5 * clip;\n    vec2 ratioSpacePosition = vec2(aspectRatio, 1) * unitSpacePosition;\n    \n    //view basis\n    mat3 viewTransform = rotation3XZ(iTime * 0.1);\n    vec3 viewPosition = viewTransform * vec3(0, 0, 2);\n    vec3 viewRight = viewTransform * vec3(1, 0, 0);\n    vec3 viewUp = viewTransform * vec3(0, 1, 0);\n    vec3 viewForward = viewTransform * vec3(0, 0, -1);\n    \n    //view ray\n    vec3 frustumPoint = viewPosition - viewForward;\n    vec3 srp =\n       viewPosition +\n       viewRight * ratioSpacePosition.x +\n       viewUp * ratioSpacePosition.y;\n    vec3 srd = normalize(srp - frustumPoint);\n    \n    //julia constant\n    float time = 0.2 * iTime;\n    float ct = cos(time);\n    float st = sin(time);\n    Quaternion d = Quaternion(0, ct * 1.1, 0, 0);\n    DualQuaternion dd = DualQuaternion(d, Quaternion(0));\n\n    //ray march the distance field\n    int i;\n    float t = 0.0;\n    vec3 p;\n    bool hit = false;\n    \n    //last julia outputs\n    int iEscape;\n    vec3 globalNormal;\n    \n    for(i = 0; i < 150; i++)\n    {\n        p = srp + t * srd;\n        \n        float de = getJuliaDE(dd, p, globalNormal, iEscape);\n        \n        if(de < 0.001)\n        {\n            hit = true;\n            p -= 0.001 * srd;\n            break; \n        }\n\n        t += de;\n    }\n    \n    if(hit)\n    {\n        fragColor = vec4(globalNormal, 1);\n    }\n}","name":"Image","description":"","type":"image"}]}