{"ver":"0.1","info":{"id":"ftlBR2","date":"1651208840","viewed":63,"name":"Line vs Circle","username":"Behzod","description":"sample line and circle","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["linevscircle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define  t   iTime\n#define Da 0.7\n//#define Db 0.5\n// unsigned round box\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdfCLine(vec2 uv, float r) {\n  float x = uv.x;\n  float y = uv.y;\n  \n  float d = length(vec2(x, y)) - r;\n  float dx = length(vec2(x, y)) - r - 0.03;\n  \n  return max(-d, dx);\n}\n\nfloat line_segment(in vec2 p, in vec2 a, in vec2 b) {\n\tvec2 ba = b - a;\n\tvec2 pa = p - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n\treturn length(pa - h * ba);\n}\n\nfloat rayMarch(vec2 ro, vec2 rd, float start, float end) {\n  float depth = start;\n  \n  for (int i = 0; i < 255; i++) {\n    vec2 p = ro + depth * rd;\n    float d = sdfCLine(p, Da);//sdBox(p, vec2(Da, Db));\n    depth += d;\n    if (d < 0.001 || depth > end) break;\n  }\n  \n  return depth;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 pos = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    float zoom = 2.5;\n    pos *= zoom;\n    \n    float c = cos(t);\n    float s = sin(t);\n    mat2 rot = mat2(c, -s, s, c);\n    \n    //float dis = step(0., sdfCircle(pos, .1));\n    vec2 ro = vec2(0, 1.2); // ray origin that represents camera position\n    vec2 rd = normalize(vec2(pos.x, -1.)); // ray direction\n    \n    \n    float dis = 1.;// = rayMarch(ro, rd, 0., 100.); // distance to sphere\n    float depth = 0.;\n  \n  for (int i = 0; i < 255; i++) {\n    vec2 p = ro + depth * rd;\n    float d = sdfCLine(p, Da);//sdBox(p, vec2(Da, Db));\n    depth += d; \n    float lines = step(0., sdfCLine(pos + 0.0, depth));\n    dis = min(dis, lines);\n    \n    if (d < 0.001 || depth > 100.) break;\n  }\n  \n  \n  dis = min(dis, depth);\n    \n    \n    float disM = step(0., sdfCLine(pos, Da));//sdBox(pos, vec2(Da, Db))\n    \n    float cout = dis;//min(d1, d2);\n    \n    vec2 v1d1 = vec2(0.0, 0.0);\n\tvec2 v2d1= vec2(dis, 0.0);\n    float d1 = smoothstep(0.007, 0.008, line_segment(pos, v1d1, v2d1));\n    \n    vec2 v1d2 = vec2(0.5, 1.0);\n\tvec2 v2d2 = vec2(0.7, 1.0);\n    float d2 = smoothstep(0.007, 0.008, line_segment(pos, v1d2, v2d2));\n    \n    \n    \n    \n    cout = min(cout, d1);\n    //cout = min(cout, d2);\n    cout = min(cout, disM);\n    \n\tvec3 color = vec3(cout, cout, cout);\n\tfragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"}]}