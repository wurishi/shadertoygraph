{"ver":"0.1","info":{"id":"Mf3SDs","date":"1714857028","viewed":59,"name":"Voronoi via natural neighbours","username":"mrboggieman","description":"Creation of Voronoi mesh by finding the polygon splitting and finding natural neighbours (closest points that contribute to the Voronoi cell divisions). Drag the mouse to move a point around.\nKeys:\n  '1' - toggle Mesh\n  '2' - toggle fill","likes":3,"published":1,"flags":16,"usePreview":0,"tags":["voronoi","natural","neighbours"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// One pass Voronoi mesh generation using polygon splitting and determining natural neighbours\n\n// utils\nconst float EPSILON = 0.0001;\n\nstruct Line {\n   vec2 a;\n   vec2 b;\n};\n\nfloat det2(in vec2 a, in vec2 b) {\n    //return (a.x * b.y) - (a.y * b.x);\n    return determinant(mat2(a, b));\n}\n\nvec2 project(in vec2 a, in vec2 b) {\n    return dot(a, b)/dot(b, b) * b;\n}\n\nvec2 closestPointOnLine(in Line line, in vec2 pos) {\n    return line.a + project(pos - line.a, line.b - line.a);\n}\n\nbool pointInsideLine(in Line line, in vec2 pos) {\n    return det2(pos - line.a, line.b - line.a) < 0.0;\n}\n\nint intersectLines(in Line line1, in Line line2, out vec2 collision) {\n    float c = det2(line1.a, line1.b);\n    float d = det2(line2.a, line2.b);\n    float e = det2(line1.a - line1.b, line2.a - line2.b);\n\n    collision = vec2(\n        det2(vec2(c, line1.a.x - line1.b.x), vec2(d, line2.a.x - line2.b.x)) / e,\n        det2(vec2(c, line1.a.y - line1.b.y), vec2(d, line2.a.y - line2.b.y)) / e\n    );\n\n    // ensure the collision point is in the 0-1 range of our line (must be more efficient way of doing this)\n    if ((dot(collision - line1.a, line1.b - line1.a) < 0.0) || (distance(collision, line1.a) > distance(line1.a, line1.b) + EPSILON)) {\n        return 0;\n    }\n\n    return int(sign(e));\n}\n\nfloat distanceToLine(in Line line, in vec2 pos) {\n    return distance(closestPointOnLine(line, pos), pos);\n}\n\nfloat distanceToLineSegment(in Line line, in vec2 pos) {\n    return distance(clamp(closestPointOnLine(line, pos), min(line.a, line.b), max(line.a, line.b)), pos);\n}\n\n// START\nconst float LINE_THICKNESS = 0.0015;\nconst float VERTEX_SIZE = 0.02;\nconst float VERTEX_FILL_SIZE = 0.015;\n\nstruct Point {\n    vec2 pos;\n    vec3 colour;\n};\n\nPoint[] points = Point[](\n  Point(vec2(0.25, 0.25), vec3(0.9, 0.1, 0.3)),\n  Point(vec2(1.5, 0.25), vec3(0.1, 0.9, 0.2)),\n  Point(vec2(0.75, 0.25), vec3(0.9, 0.8, 0.2)), \n  Point(vec2(1.25, 0.5), vec3(0.1, 0.2, 1.0)),\n  Point(vec2(0.9, 0.8), vec3(0.8, 0.3, 0.4)),\n  Point(vec2(0.75, 0.5), vec3(0.9, 0.1, 0.7)),\n  Point(vec2(1.25, 0.75), vec3(0.9, 0.7, 0.6)),\n  Point(vec2(0.5, 0.75), vec3(0.3, 0.4, 0.2)),\n  Point(vec2(1.1, 0.15), vec3(0.7, 0.4, .2))\n);\n\nconst int NUM_POINTS = points.length();\n\nconst int MAX_LINES = NUM_POINTS;\n\nstruct AreaLine {\n    Line line;\n    int index;\n};\n\nstruct LineVec {\n    AreaLine[MAX_LINES] lines;\n    int count;\n};\n\nLineVec slicePolygon(in LineVec lines, in AreaLine cutting_line) {\n    AreaLine[MAX_LINES] new_lines;\n    int num_new_lines = 0;\n    vec2 in_point;\n    vec2 out_point;\n    bool has_in_point;\n    bool has_out_point;\n    \n    for (int i=0; i<lines.count; i++) {\n        vec2 intersection;\n        AreaLine line = lines.lines[i];\n        int dir = intersectLines(line.line, cutting_line.line, intersection);\n\n        switch (dir) {\n            case 0:\n                // determine if the line is inside or outside by checking the center of the line\n                if (!pointInsideLine(cutting_line.line, mix(line.line.a, line.line.b, 0.5))) {\n                    new_lines[num_new_lines] = line;\n                    num_new_lines++;\n                }\n                break;\n            case -1:\n                // break the line into two keeping the first part\n                new_lines[num_new_lines] = AreaLine(Line(line.line.a, intersection), line.index);\n                num_new_lines++;\n                \n                in_point = intersection;\n                has_in_point = true;\n                break;\n            case 1:\n                // break the line into two keeping the second part\n                new_lines[num_new_lines] = AreaLine(Line(intersection, line.line.b), line.index);\n                num_new_lines++;\n\n                out_point = intersection;\n                has_out_point = true;\n                break;\n        }\n    }\n    \n    if (has_in_point && has_out_point) {\n        new_lines[num_new_lines] = AreaLine(Line(in_point, out_point), cutting_line.index);\n        num_new_lines++;\n    }\n\n    return LineVec(new_lines, num_new_lines);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    float pixel_size = 1.5/iResolution.y;\n \n    // allow dragging one of the points\n    if (length(iMouse.xy) > 10.0) {\n        points[4].pos = iMouse.xy / iResolution.y;\n    }\n    \n    // find the closest point\n    Point closest;\n    float closest_distance = 2.0;\n\n    for (int i=0; i < NUM_POINTS; i++) {\n        Point point = points[i];\n        float dist = distance(uv, point.pos);\n        \n        if (dist < closest_distance) {\n            closest = point;\n            closest_distance = dist;\n        }\n    }\n\n    // the point's voronoi cell - start with the entire canvas\n    float width = iResolution.x/iResolution.y;\n    float height = 1.0;\n    \n    vec2[] vertices = vec2[](\n        vec2(0.0, 0.0),\n        vec2(0.0, height),\n        vec2(width, height),\n        vec2(width, 0.0)\n    );\n    \n    LineVec voronoi_lines;\n    voronoi_lines.count = 4;\n    voronoi_lines.lines[0] = AreaLine(Line(vertices[0], vertices[1]), -1);\n    voronoi_lines.lines[1] = AreaLine(Line(vertices[1], vertices[2]), -1);\n    voronoi_lines.lines[2] = AreaLine(Line(vertices[2], vertices[3]), -1);\n    voronoi_lines.lines[3] = AreaLine(Line(vertices[3], vertices[0]), -1);\n\n    // iterate through all of the neighbours and slice them up\n    for (int i = 0; i < NUM_POINTS; i++) {\n        vec2 pos = mix(points[i].pos, closest.pos, 0.5);\n\n        //create a line to split the voronoi cell using the line tangent\n        vec2 tangent_dir = vec2(-(closest.pos.y - pos.y), closest.pos.x - pos.x);\n\n        AreaLine split_line = AreaLine(Line(pos, pos + tangent_dir), i);\n\n        // slice the voronoi cell by the tangent of the neighbour\n        voronoi_lines = slicePolygon(voronoi_lines, split_line);\n    }\n    \n    vec3 col = vec3(0.5);\n\n    // fill the voronoi cell (can just use the closest point for this)\n    if (texelFetch(iChannel0, ivec2(50, 2), 0).r < 1.0) {\n        col = closest.colour;\n    }\n    \n    //draw the points as dots with the fill colour\n    for (int i=0; i<NUM_POINTS; i++) {\n        Point point = points[i];\n\n        col = mix(col, vec3(0.0), smoothstep(pixel_size, 0.0, distance(point.pos, uv) - VERTEX_SIZE));\n        col = mix(col, point.colour, smoothstep(pixel_size, 0.0, distance(point.pos, uv) - VERTEX_FILL_SIZE));\n    }\n\n    // draw the voronoi cell lines\n    if (texelFetch(iChannel0, ivec2(49, 2), 0).r < 1.0) {\n        for (int i=0; i<voronoi_lines.count; i++) {\n            Line line = voronoi_lines.lines[i].line;\n            col = mix(col, vec3(0.0), smoothstep(pixel_size, 0.0, distanceToLineSegment(line, uv) - LINE_THICKNESS));\n        }\n    }\n    \n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}