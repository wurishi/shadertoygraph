{"ver":"0.1","info":{"id":"llGXRD","date":"1483216888","viewed":85,"name":"Blotter Logo","username":"bradleygriffith","description":"Blotter","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["blotter"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n    // Setup ========================================================================\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float time = iTime / 4.0;\n\n    vec4 finalColour = vec4(0.0);\n\n\n    // Create Heat Points ===========================================================\n\n    float heatDistanceScale = 35.0; // Larger value equates to smaller spread\n\n    // Define 2 heat points\n    float heatPoint1X = 0.5 - (sin(time) / 2.0);\n    float heatPoint1Y = 0.5 - ((cos(time) * abs(cos(time))) / 1.5);\n    vec2 heatPoint1Uv = vec2(heatPoint1X, heatPoint1Y) * iResolution.xy;\n\n    float heatPoint2X = 0.5 - (sin(time - 1.0) / 2.0);\n    float heatPoint2Y = 0.5 - ((cos(time - 1.0) * abs(cos(time))) / 1.0);\n    vec2 heatPoint2Uv = vec2(heatPoint2X, heatPoint2Y) * iResolution.xy;\n\n    // Calculate distances from current UV and combine\n    float heatPoint1Dist = smoothstep(0.0, 1.4, distance(fragCoord, heatPoint1Uv) / iResolution.y);\n    float heatPoint2Dist = smoothstep(0.0, 1.25, distance(fragCoord, heatPoint2Uv) / iResolution.y);\n    float combinedDist = (heatPoint1Dist * heatPoint2Dist);\n\n    // Invert and scale\n    float amount = 1.0 - smoothstep(0.15, 25.0, combinedDist * heatDistanceScale);\n    amount = smoothstep(-1.0, 1.0, amount);\n\n\n    // Create Darkness ==============================================================\n\n    const int darknessRadius = 10;\n\n    vec2 stepCoord = vec2(0.0);\n    vec2 stepUV = vec2(0.0);\n\n    vec4 stepSample = vec4(1.0);\n    vec4 darkestSample = vec4(1.0);\n\n    float stepDistance = 1.0;\n\n    vec2 maxDistanceCoord = fragCoord.xy + vec2(float(darknessRadius), 0.0);\n    vec2 maxDistanceUV = maxDistanceCoord.xy / iResolution.xy;\n    float maxDistance = distance(fragCoord, maxDistanceCoord);\n\n    float randNoise = rand(uv * sin(time * 0.025)) * 0.15;\n\n    // Find the darkest sample and some relevant meta data within a radius.\n    //   Note: You may notice some artifacts in our darkness. This is due to\n    //   us making steps on a `+=2` basis in the interest of performance. Play!\n    for (int i = -darknessRadius; i <= darknessRadius; i += 1) {\n        for (int j = -darknessRadius; j <= darknessRadius; j += 1) {\n            stepCoord = fragCoord + vec2(float(i), float(j));\n            stepUV = stepCoord / iResolution.xy;\n            stepSample = texture(iChannel0, stepUV);\n            vec4 sampleOnWhite = stepSample;\n            \n            stepDistance = distance(fragCoord, stepCoord) / smoothstep(-1.0, 1.0, amount);\n\n            float stepDarkestSampleWeight = 1.0 - clamp((stepDistance / maxDistance), 0.0, 1.0) + randNoise;\n            stepDarkestSampleWeight *= smoothstep(0.0, 7.5, amount);\n\n            vec4 mixedStep = mix(darkestSample, sampleOnWhite, stepDarkestSampleWeight);\n\n            if (mixedStep == min(mixedStep, darkestSample) && stepDistance <= maxDistance) {\n                darkestSample = mixedStep;\n            }\n        }\n    }\n\n\n    fragColor = darkestSample;\n}","name":"Image","description":"","type":"image"}]}