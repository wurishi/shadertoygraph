{"ver":"0.1","info":{"id":"cltcWr","date":"1699071204","viewed":38,"name":"curve-normals","username":"gboyraz","description":"Delve into the graceful flow of a time-modulated quadratic curve and its normals. Witness the perpendicular symphony with hues shifting from green to purple, visualizing the invisible backbone of calculus in motion.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["curve","nornals"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Curve function: y = ax^2 + bx + c\nconst float a = 1.5;\nconst float b = -1.5;\nconst float c = 0.0;\n\n// Curve function definition with time-based variation\nfloat curve(float x, float time) {\n    // The time function oscillates between -1 and 1 over a period of 9 seconds.\n    float periodicTime = 9.0 * sin(time * 3.14159265 / 9.0);\n    return periodicTime * a * x * x + b * x + c;\n}\n\n// Curve function's derivative with time-based variation\nfloat curveDerivative(float x, float time) {\n    // We use the same time function for the derivative calculation.\n    float periodicTime = 9.0 * sin(time * 3.14159265 / 9.0);\n    return periodicTime * 2.0 * a * x + b;\n}\n\n// Helper function to color the normal based on its slope\nvec4 colorForNormal(float slope) {\n    // Check for near-vertical slopes to avoid infinite values\n    if (abs(slope) < 0.01) {\n        return vec4(1.0, 1.0, 0.0, 1.0); // Yellow for near-vertical normals\n    }\n    // Normalize the slope of the normal (which is -1/slope of tangent) to get a value between 0 and 1\n    float normalizedSlope = atan(-1.0 / slope) / 3.14159265 + 0.5;\n    // Create a gradient from yellow to magenta\n    return vec4(1.0 - normalizedSlope, normalizedSlope, 1.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalize coordinates with respect to screen resolution\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    // Calculate the curve at this point\n    float curveY = curve(uv.x, iTime);\n\n    // Draw the curve itself\n    float curveWidth = 0.05; // The thickness of the curve\n    bool onCurve = abs(uv.y - curveY) < curveWidth;\n\n    // Find if we are near a point that could be on a normal\n    float sampleStep = 0.03; // How far apart our samples are on the x-axis\n    float normalThreshold = 0.02; // How close we need to be to the normal line\n    vec4 normalColor = vec4(0.0);\n\n    for (float x = -1.0; x < 1.0; x += sampleStep) {\n        // For each sample point on the curve, calculate the derivative\n        float slope = curveDerivative(x, iTime);\n        // Calculate y intercept of the normal line\n        float normalSlope = -1.0 / slope;\n        float yInterceptNormal = curve(x, iTime) - normalSlope * x;\n        // Get the y value of this normal line at our current x (which is uv.x)\n        float normalY = normalSlope * uv.x + yInterceptNormal;\n\n        // Check if the current pixel is close to the normal line\n        if (abs(normalY - uv.y) < normalThreshold) {\n            // Color the pixel with the color of the normal\n            normalColor += colorForNormal(slope);\n            break; // Stop if we've found a close normal line\n        }\n    }\n\n    // Coloring logic\n    if (onCurve) {\n        fragColor = vec4(1.0, 1.0, 1.0, 1.0); // White color for the curve\n    } else if (normalColor != vec4(0.0)) {\n        fragColor = normalColor; // Color determined by the slope of the normal\n    } else {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0); // Background color\n    }\n}\n","name":"Image","description":"","type":"image"}]}