{"ver":"0.1","info":{"id":"4clfWN","date":"1724530846","viewed":18,"name":"Ray Marching Tryout","username":"BloodyMoonlight","description":"My try at raymarching","likes":0,"published":1,"flags":16,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**********************\n ** CAMERA STRUCTURE **\n **********************/\n\nstruct Camera {\n    vec3 position;\n    vec3 direction;\n    vec3 up;\n    float hfov;\n    float nearClip;\n    float farClip;\n    uint maxRayMarchSteps;\n    float aspectRatio;\n    float hitTolerance;\n    vec3 clearColor;\n};\n\nvec3 get_frag_world_coord(Camera camera, vec2 fragCoord) {\n    return vec3(0.0, 0.0, 0.0);\n}\n\n/*******************\n ** RAY STRUCTURE **\n *******************/\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nRay create_ray(vec3 origin, vec3 direction) {\n    Ray result;\n    result.origin = origin;\n    result.direction = normalize(direction);\n    return result;\n}\n\nvec3 ray_t(Ray ray, float t) {\n    return ray.origin+ray.direction*t;\n}\n\nRay gen_orthogonal_ray(Camera camera, vec2 fragCoord) {\n    Ray result;\n    result.origin    = get_frag_world_coord(camera, fragCoord);\n    result.direction = camera.direction;\n    \n    return result;\n}\n\n/***************************\n ** PRIMITIVES STRUCTURES **\n ***************************/\n     \nstruct Sphere {\n    vec3 center;\n    float radius;\n};\n\nstruct Box {\n    vec3 center;\n    vec3 dimensions; // whole lengths of all 3 components\n};\n\n\n/*******************************\n ** SIGNED DISTANCE FUNCTIONS **\n *******************************/\n\n    // SPHERE\n    \nfloat sdf_sphere(vec3 point, Sphere sphere) {\n    return distance(sphere.center, point) - sphere.radius;\n}\n\nfloat sdf_sphere(vec3 point, vec3 sphereCenter, float sphereRadius) {\n    return sdf_sphere(point, Sphere(sphereCenter, sphereRadius));\n}\n\n    // BOX\n\nfloat sdf_box(vec3 point, Box box) {\n    vec3 relativePoint = point - box.center;\n    vec3 q = abs(relativePoint) - box.dimensions/2.0;\n    \n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdf_box(vec3 point, vec3 boxCenter, vec3 boxDimensions) {\n    return sdf_box(point, Box(boxCenter, boxDimensions));\n}\n\n/************\n ** LIGHTS **\n ************/\n\nstruct OmniLight {\n    vec3 position;\n    vec3 color;\n};\n\n/************************\n ** OBJECTS COLLECTION **\n ************************/\n\nconst uint MAX_OBJECTS_AMOUNT = 5u;\n\nstruct World {\n    uint spheresAmount;\n    Sphere[MAX_OBJECTS_AMOUNT] spheres;\n    \n    uint boxesAmount;\n    Box[MAX_OBJECTS_AMOUNT] boxes;\n    \n    uint omnilightsAmount;\n    OmniLight[MAX_OBJECTS_AMOUNT] omnilights;\n};\n\nconst uint RECORD_SPHERE = 1u;\nconst uint RECORD_BOX    = 2u;\n\nstruct WorldRecord {\n    uint type;\n    uint index;\n};\n\nstruct WorldClosestRecord {\n    WorldRecord wr;\n    float dist;\n};\n\nbool world_record_is_valid(WorldRecord wr, World w) {\n    switch (wr.type) {\n        case RECORD_SPHERE:\n            return (w.spheresAmount > wr.index);\n        case RECORD_BOX:\n            return (w.boxesAmount > wr.index);\n    }\n    \n    return false;\n}\n\nWorldClosestRecord closest_distance_in_world(vec3 point, World w, Camera cam) {\n    float closest = cam.farClip;\n    uint type = 0u;\n    uint index = 0u;\n    \n    // Iterating through spheres\n    for (uint i = 0u; i != min(MAX_OBJECTS_AMOUNT, w.spheresAmount); ++i) {\n        float currentDistance = sdf_sphere(point, w.spheres[i]);\n        if (closest > currentDistance && currentDistance >= 0.0) {\n            closest = currentDistance;\n            type = RECORD_SPHERE;\n            index = i;\n        }\n    }\n    \n    // Iterating through boxes\n    for (uint i = 0u; i != min(MAX_OBJECTS_AMOUNT, w.boxesAmount); ++i) {\n        float currentDistance = sdf_box(point, w.boxes[i]);\n        if (closest > currentDistance && currentDistance >= 0.0) {\n            closest = currentDistance;\n            type = RECORD_BOX;\n            index = i;\n        }\n    }\n    \n    return WorldClosestRecord(WorldRecord(type, index), closest);\n}\n\nOPTFloat get_distance_from_world_record(vec3 point, World w, WorldRecord wr) {\n    switch (wr.type) {\n        case RECORD_SPHERE:\n            if (w.spheresAmount <= wr.index) {\n                return OPTFloat(false, 0.0);\n            }\n            return OPTFloat(true, sdf_sphere(point, w.spheres[wr.index]));\n        \n        case RECORD_BOX:\n            if (w.boxesAmount <= wr.index) {\n                return OPTFloat(false, 0.0);\n            }\n            return OPTFloat(true, sdf_box(point, w.boxes[wr.index]));\n    }\n    \n    return OPTFloat(false, 1.0);\n}\n\nconst float SMALL_FLOAT_STEP = 0.001;\n\nOPTVec3 get_normal_from_world_record(vec3 point, World w, WorldRecord wr) {    \n    if (!world_record_is_valid(wr, w)) {\n        return OPTVec3(false, vec3(0.0, 0.0, 0.0));\n    }\n    \n    float gradientX;\n    float gradientY;\n    float gradientZ;\n    \n    switch (wr.type) {\n        case RECORD_SPHERE:\n            Sphere s = w.spheres[wr.index];\n            \n            gradientX = sdf_sphere(point + vec3(SMALL_FLOAT_STEP, 0.0, 0.0), s) - sdf_sphere(point - vec3(SMALL_FLOAT_STEP, 0.0, 0.0), s);\n            gradientY = sdf_sphere(point + vec3(0.0, SMALL_FLOAT_STEP, 0.0), s) - sdf_sphere(point - vec3(0.0, SMALL_FLOAT_STEP, 0.0), s);\n            gradientZ = sdf_sphere(point + vec3(0.0, 0.0, SMALL_FLOAT_STEP), s) - sdf_sphere(point - vec3(0.0, 0.0, SMALL_FLOAT_STEP), s);\n            \n            return OPTVec3(true, normalize(vec3(gradientX, gradientY, gradientZ)));\n    \n        case RECORD_BOX:\n            Box b = w.boxes[wr.index];\n            \n            gradientX = sdf_box(point + vec3(SMALL_FLOAT_STEP, 0.0, 0.0), b) - sdf_box(point - vec3(SMALL_FLOAT_STEP, 0.0, 0.0), b);\n            gradientY = sdf_box(point + vec3(0.0, SMALL_FLOAT_STEP, 0.0), b) - sdf_box(point - vec3(0.0, SMALL_FLOAT_STEP, 0.0), b);\n            gradientZ = sdf_box(point + vec3(0.0, 0.0, SMALL_FLOAT_STEP), b) - sdf_box(point - vec3(0.0, 0.0, SMALL_FLOAT_STEP), b);\n            \n            return OPTVec3(true, normalize(vec3(gradientX, gradientY, gradientZ)));\n    }\n    \n    return OPTVec3(false, vec3(1.0, 1.0, 1.0));\n}\n\n/************************\n ** RAY MARCHING LOGIC **\n ************************/\n \nvec3 ray_march(Ray ray, Camera camera, World world) {\n    float t = 0.0;\n    \n    for (uint i = 0u; i != camera.maxRayMarchSteps; ++i) {\n        vec3 currentPoint = ray_t(ray, t);\n        \n        WorldClosestRecord distanceToNearest = closest_distance_in_world(currentPoint, world, camera);\n        \n        if (distanceToNearest.dist <= camera.hitTolerance) {\n            if (t <= camera.nearClip) {\n                break;\n            }\n            \n            \n            OPTVec3 calculatedNormal = get_normal_from_world_record(currentPoint, world, distanceToNearest.wr);\n            \n            if (!calculatedNormal.valid) {\n                return vec3(1.0, 1.0, 0.0);\n            }\n            \n            float diffuseIntensity = 0.1; // Base \"ambient\" lighting\n            \n            for (uint j = 0u; j != world.omnilightsAmount; ++j) {\n                vec3 lightVector = normalize(currentPoint - world.omnilights[j].position);\n                \n                diffuseIntensity = max(diffuseIntensity, dot(calculatedNormal.value, lightVector));\n            }\n            \n            return vec3(1.0, 0.0, 0.0)*diffuseIntensity;\n        }\n        \n        if (t >= camera.farClip) {\n            break;\n        }\n        \n        t += distanceToNearest.dist;\n    }\n    \n    return vec3(camera.clearColor);\n}\n\n\n/*******************\n ** MAIN FUNCTION **\n *******************/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Remapping UV to [-1, 1]\n    vec2 camUV = uv*2.0 - 1.0;\n    \n    Camera cam = Camera(\n        vec3(0.0, 0.0, -5.0),        // Position\n        vec3(0.0, 0.0, 1.0),         // direction\n        vec3(0.0, 1.0, 0.0),         // up\n        100.0,                       // hfov\n        0.0001,                     // nearClip\n        9999.9,                      // farClip\n        99u,                         // maxRayMarchSteps\n        iResolution.x/iResolution.y, // aspectRatio\n        0.00001,                     // hitTolerance\n        vec3(0.8, 0.2, 0.9)          // ClearColor\n    );\n    \n    camUV.y *= (iResolution.y/iResolution.x);\n    \n    //world building\n    World world;\n    \n    world.spheresAmount = 1u;\n    world.spheres[0] = Sphere(vec3(0.0, 0.0, 0.0), 1.0);\n\n    world.boxesAmount = 1u;\n    world.boxes[0] = Box(vec3(2.0, 0.0, 0.0), vec3(1.0));\n    \n    world.omnilightsAmount = 1u;\n    world.omnilights[0] = OmniLight(vec3(sin(iTime), cos(iTime)*sin(iTime), cos(iTime)), vec3(0.8, 0.0, 0.0));\n    \n    Ray fragmentRay = Ray(cam.position, vec3(camUV, 1.0));\n    \n    vec3 col = ray_march(fragmentRay, cam, world);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}\n\n\n\nstruct OPTBool {\n    bool valid;\n    bool value;\n};\n\nstruct OPTFloat {\n    bool valid;\n    float value;\n};\n\nstruct OPTint {\n    bool valid;\n    int value;\n};\n\nstruct OPTUint {\n    bool valid;\n    uint value;\n};\n\nstruct OPTVec3 {\n    bool valid;\n    vec3 value;\n};","name":"Common","description":"","type":"common"}]}