{"ver":"0.1","info":{"id":"MctBR4","date":"1732877343","viewed":45,"name":"Earth_1","username":"yh","description":"earth","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["earth"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float Precision = 0.001;\nfloat MaxDest = 10.0;\nvec3 co = vec3(0.,0.,0.); // 圆心\nfloat cr = 0.5; // 半径\nfloat PI = 3.1415926;\n\nvec3 ls = vec3(-.5,-0.2,.4);\nvec3 le = vec3(.5,0.3,.0);\nvec3 lc1;\n\nstruct RayMatchRes {\n    float d;\n    vec3 p;\n    int n;\n};\n\nfloat sdfSphere(vec3 p, vec3 c, float r){\n    return length(p - c) - r;\n}\n\nfloat sdfCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat det( vec2 a, vec2 b ) { return a.x*b.y-b.x*a.y; }\nvec3 getClosest( vec2 b0, vec2 b1, vec2 b2 ) \n{\n    float a =     det(b0,b2);\n    float b = 2.0*det(b1,b0);\n    float d = 2.0*det(b2,b1);\n    float f = b*d - a*a;\n    vec2  d21 = b2-b1;\n    vec2  d10 = b1-b0;\n    vec2  d20 = b2-b0;\n    vec2  gf = 2.0*(b*d21+d*d10+a*d20); gf = vec2(gf.y,-gf.x);\n    vec2  pp = -f*gf/dot(gf,gf);\n    vec2  d0p = b0-pp;\n    float ap = det(d0p,d20);\n    float bp = 2.0*det(d10,d0p);\n    float t = clamp( (ap+bp)/(2.0*a+b+d), 0.0 ,1.0 );\n    return vec3( mix(mix(b0,b1,t), mix(b1,b2,t),t), t );\n}\n\n\nfloat sdBezier( vec3 a, vec3 b, vec3 c, vec3 p )\n{\n\tvec3 w = normalize( cross( c-b, a-b ) );\n\tvec3 u = normalize( c-b );\n\tvec3 v =          ( cross( w, u ) );\n\n\tvec2 a2 = vec2( dot(a-b,u), dot(a-b,v) );\n\tvec2 b2 = vec2( 0.0 );\n\tvec2 c2 = vec2( dot(c-b,u), dot(c-b,v) );\n\tvec3 p3 = vec3( dot(p-b,u), dot(p-b,v), dot(p-b,w) );\n\n\tvec3 cp = getClosest( a2-p3.xy, b2-p3.xy, c2-p3.xy );\n\n\treturn sqrt(dot(cp.xy,cp.xy)+p3.z*p3.z);\n}\n\nfloat sdfLine(vec3 p, vec3 a, vec3 b, vec3 c1, int n){\n    float nd = 1./float(n);\n    vec3 n1 = (c1 - a) * nd;\n    vec3 n2 = (b - c1) * nd;\n    vec3 lastP = a;\n    float d = MaxDest;\n    for(int i = 0; i <= n; i++){\n        vec3 p1 = a + n1*float(i);\n        vec3 p2 = c1 + n2*float(i);\n        // 曲线上的点\n        vec3 p3 = float(i) * nd * (p2 - p1) + p1;\n        d = min(d, sdfCapsule(p, lastP, p3, .001));\n        if(d < Precision) break;\n        lastP = p3;\n    }\n    return d;\n}\n\nmat3 getCameraMat(vec3 ta, vec3 o ){\n    vec3 z = normalize(ta - o);\n    vec3 x = normalize(cross(z, vec3(0.,1.,0.)));\n    vec3 y = cross(x,z);\n    return mat3(x,y,z);\n}\n\nRayMatchRes rayMarching(vec3 ro, vec3 rd){\n    RayMatchRes res;\n    float d0 = 0.;\n    res.d = MaxDest;\n    res.p = ro;\n    for(int i = 1; i < 20 || d0 <= MaxDest;i++){\n        res.p = ro + d0 * rd;\n        float d1 = sdfSphere(res.p, co, cr);\n        float d2 = sdBezier(ls,  lc1,le,res.p);//sdfLine(res.p, ls, le, lc1, 16);//sdfCapsule(res.p, ls, le, 0.01);\n        float d = min(d1, d2 );\n        if(d < Precision) {\n            res.n = int(step(d2,d1));\n            res.d = d;\n            break;\n        };\n        d0 += d;\n    }\n\n    // if(res.d > MaxDest) res.d = -1.;\n    return res;\n}\n\nvoid handleLines(){\n    vec3 c1 = 0.5 * (ls+le);\n    lc1 = co + normalize(c1 - co)*cr*2.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = 2. * uv - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 cameraPos = vec3( sin(iTime),0., cos(iTime));\n    // vec3 cameraPos = vec3(0.,0., -1.);\n    mat3 camMat = getCameraMat(vec3(0.),cameraPos);\n    handleLines();\n    \n    RayMatchRes res = rayMarching(cameraPos, normalize(camMat * vec3(uv, 1.6)));\n\n    if(res.d < Precision) {\n        if(res.n == 0) {\n            vec3 p = normalize(res.p - co);\n            float phi = atan(p.z,p.x);\n            float theta = asin(p.y);\n            float u = 1. - (phi+PI)/(2.*PI);\n            float v = (theta + 0.5 * PI) / PI;\n            fragColor = texture(iChannel0,vec2(u,v));\n            return;\n        }\n        // 外反光\n        float a = smoothstep(0.,1.,res.d*16.);\n        fragColor = a+vec4(1.,0.,0.,1.);\n        // fragColor = vec4(1.,1.,1.,1.);\n    } else {\n        fragColor = vec4(0., 0.,0.,1.);\n    }\n}","name":"Image","description":"","type":"image"}]}