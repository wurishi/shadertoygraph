{"ver":"0.1","info":{"id":"XdGXRD","date":"1463071268","viewed":357,"name":"Pyramid CA","username":"akohdr","description":"Example 3D cellular automata to grow then dissolve pyramids.\n(resolved x/y drift in z-direction by deriving z-slice FDIM from FRES rather than reverse.)","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["voxel","automata"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Andrew Wild - akohdr/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// The Viewer - displays a voxel volume described by 2D tiled z-slices\n//\n#define EYE 90\n#define FRES vec3(33,47,89)\n#define HALF (FRES/2.)\n#define FDIM vec3(floor(iResolution.xy/FRES.xy),FRES.z)\n\nbool isVoxel(out vec4 k, const in vec3 P)\n{\n//    if(any(greaterThan(abs(P.xyz),HALF))) return false; // bounds check, kills repetition \n    vec3 p = P + HALF;  \t\t\t\t\t\t\t \t// recenter volume in viewport\n\tfloat z = p.z, w = FDIM.x;\t\t\t\t\t\t\t// inlined prj4Dto2D()\n    vec2 FR = FRES.xy;\n    k = texture(iChannel0, (FR * floor(vec2(mod(z,w),z/w)) + mod(p.xy,FR))/iResolution.xy);\n    return k.x + k.y + k.z>0.;\t// anything but black\n}\n\nvoid mainImage(out vec4 k, vec2 P)\n{\n    float T, Rx = iResolution.x, Ry = iResolution.y;\n    if(iMouse.z>0.){\n        if (iMouse.y>250.){ k = texture(iChannel0, P/iResolution.xy); return; } // show state space\n        T = 5.*iMouse.x/Rx;  \t// mouse rotate\n    } else\n        T = float(iFrame)/256.; // slow rotate\n    \n    vec2 h = vec2(0,.5),\n         u = (P - h*Ry)/Rx - h.yx;\n    vec3 v = vec3(cos(T), 1, sin(T)),\n         r = mat3(u.x,    0,   .8,\n                    0,  u.y,    0,\n                  -.8,    0,  u.x) * v,\n         o = vec3(EYE,0,-EYE)*v.zyx,\n         f = floor(o),\n         q = sign(r),\n         d = abs(length(r)/r),\n         s = d * ( q*(f-o + .5) +.5), m;\n\n    for(int i=0; i<256; i++) {\n        float a=s.x, b=s.y, c=s.z;\n        s += d*(m = vec3(a<b&&a<=c, b<c&&b<=a, c<a&&c<=b));\n        f += m*q;\n        if(isVoxel(k, f)) { k += vec4(m.x>.0 ? 0. : m.y>.0 ? .6 : .3); return; } //early exit\n    }\n    k = texture(iChannel1, P/iResolution.xy/3.)/3.; // background\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by Andrew Wild - akohdr/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// The Automata - 3D state space maintained in looped buffer of 2D tiled z-slices\n//\n// Simple CA to grow pyramid structure from initial seed then dissolve to base\n//\n#define RES  iResolution.xy\n#define FRES vec3(33,47,89)\n#define FDIM vec3(floor(RES/FRES.xy),FRES.z)\n\n#define BLK vec4(.0,.0,.0,1.)\n#define GRY vec4(.2,.2,.2,1.)\n#define RED vec4(1,0,0,1)\n#define GRN vec4(0,1,0,1)\n#define ANY vec4(-1)\n\n#define VX(x,y,z,K) if(length(q.xyz - vec3(x,y,z)+.25)<.5)k=K;\n\nvec2 prj4Dto2D(const in vec4 p)\n{\n    float z = p.z, w = FDIM.x;\n    vec2 FR = FRES.xy;\n    return FR * floor(vec2(mod(z,w), z/w)) + mod(p.xy, FR);\n}\n\nvec4 prj2Dto4D(const in vec2 p)\n{\n    vec2 f = floor(p/FRES.xy);\n    return vec4(mod(vec3(p, FDIM.x*f.y + f.x),FRES), 0);//iTime);\n}\n\n// rule processing =========================================================================\n\nbool noMatch(const in vec4 dp, const in vec4 K)\n{\n    if(K==ANY) return false;\n    return texture(iChannel0, prj4Dto2D(dp)/iResolution.xy).rgb != K.rgb;\n}\n\nvoid applyRule(const in vec4 p, const in vec4 r[28], inout vec4 k)\n{\n    if(noMatch(p+vec4(-1,-1,-1,1), r[ 1])) return;\n    if(noMatch(p+vec4(-1,-1, 0,1), r[ 2])) return;\n    if(noMatch(p+vec4(-1,-1, 1,1), r[ 3])) return;\n    if(noMatch(p+vec4( 0,-1,-1,1), r[ 4])) return;\n    if(noMatch(p+vec4( 0,-1, 0,1), r[ 5])) return;\n    if(noMatch(p+vec4( 0,-1, 1,1), r[ 6])) return;\n    if(noMatch(p+vec4( 1,-1,-1,1), r[ 7])) return;\n    if(noMatch(p+vec4( 1,-1, 0,1), r[ 8])) return;\n    if(noMatch(p+vec4( 1,-1, 1,1), r[ 9])) return;\n    if(noMatch(p+vec4(-1, 0,-1,1), r[10])) return;\n    if(noMatch(p+vec4(-1, 0, 0,1), r[11])) return;\n    if(noMatch(p+vec4(-1, 0, 1,1), r[12])) return;\n    if(noMatch(p+vec4( 0, 0,-1,1), r[13])) return;\n    if(noMatch(p+vec4( 0, 0, 0,1), r[14])) return;\n    if(noMatch(p+vec4( 0, 0, 1,1), r[15])) return;\n    if(noMatch(p+vec4( 1, 0,-1,1), r[16])) return;\n    if(noMatch(p+vec4( 1, 0, 0,1), r[17])) return;\n    if(noMatch(p+vec4( 1, 0, 1,1), r[18])) return;\n    if(noMatch(p+vec4(-1, 1,-1,1), r[19])) return;\n    if(noMatch(p+vec4(-1, 1, 0,1), r[20])) return;\n    if(noMatch(p+vec4(-1, 1, 1,1), r[21])) return;\n    if(noMatch(p+vec4( 0, 1,-1,1), r[22])) return;\n    if(noMatch(p+vec4( 0, 1, 0,1), r[23])) return;\n    if(noMatch(p+vec4( 0, 1, 1,1), r[24])) return;\n    if(noMatch(p+vec4( 1, 1,-1,1), r[25])) return;\n    if(noMatch(p+vec4( 1, 1, 0,1), r[26])) return;\n    if(noMatch(p+vec4( 1, 1, 1,1), r[27])) return;\n    \n    k = r[0];\n}\n\n// mini-DSL for rule definitions ===========================================================\n#define APPLY(f) f(r);applyRule(q,r,k);\n#define RULE(n) void n(inout vec4 r[28]){clrRule(r,ANY);\n#define WHEN r[14]=\n#define OUT  r[0]=\n\nvoid clrRule(out vec4 k[28], const in vec4 K)\n{\n    k[0]=K;k[1]=K;k[2]=K;k[3]=K;k[4]=K;k[5]=K;k[6]=K;k[7]=K;k[8]=K;k[9]=K;\n    k[10]=K;k[11]=K;k[12]=K;k[13]=K;k[14]=K;k[15]=K;k[16]=K;k[17]=K;k[18]=K;k[19]=K;\n    k[20]=K;k[21]=K;k[22]=K;k[23]=K;k[24]=K;k[25]=K;k[26]=K;k[27]=K;\n}\n\n// local rules =============================================================================\n// growth rules\nRULE(rule1)\t\t\tWHEN BLK;\tOUT GRN;\tr[19] = GRN;}\nRULE(rule2)\t\t\tWHEN BLK;\tOUT GRN;\tr[21] = GRN;}\nRULE(rule3)\t\t\tWHEN BLK;\tOUT GRN;\tr[25] = GRN;}\nRULE(rule4)\t\t\tWHEN BLK;\tOUT GRN;\tr[27] = GRN;}\n\n// age rule\nRULE(rule5)\t\t\tWHEN GRN;\tOUT GRY;}\n\n// burn rule\nRULE(rule6)\t\t\tWHEN GRY;\tOUT RED; r[19]=BLK; r[1]=GRY; r[3]=GRY; r[7]=GRY; r[9]=GRY;}\n\nvoid applyLocalRules(inout vec4 k, const in vec4 q)\n{\n    if(k!=GRY) k=BLK;  // clear everything except...\n    \n    vec4 r[28];\t\t   // rule buffer\n    \n    // spatially qualified rule application\n    if(q.y>12. && q.y<26.){\n         APPLY(rule1) APPLY(rule2) APPLY(rule3) APPLY(rule4) APPLY(rule5)\n    }\n    \n    // temporally qualified rule application\n    if(mod(iTime,4.)>3.)\n        APPLY(rule6)\n}\n\n// automata initial condition ==============================================================\nvoid init(out vec4 k, const in vec2 p, const in vec4 q, vec2 uv)\n{\n    k = BLK;\n    \n    // seeds\n    VX( 20,25,15, GRN)\n    VX( 20,25,43, GRN)\n    VX( 20,25,71, GRN)\n}\n\nvoid mainImage(out vec4 k, in vec2 p )\n{\n    vec4 q = prj2Dto4D(p);\t\t\t\t\t\t\t\t\t// 4D state position\n    vec2 uv = p/RES;\n    if(mod(iTime,4.)<1.) { init(k,p,q,uv); return;}\t// init() condition\n    k = texture(iChannel0, uv);\t\t\t\t\t\t\t// retrieve prior state\n    \n    applyLocalRules(k, q);\n}\n\n\n","name":"Buffer A","description":"","type":"buffer"}]}