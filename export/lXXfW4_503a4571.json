{"ver":"0.1","info":{"id":"lXXfW4","date":"1728396470","viewed":11,"name":"Hologram 1","username":"rcmz","description":"Simulation of a hologram + pinhole camera\nMouse : move object\nSpace : view normal projection instead of hologram","likes":0,"published":1,"flags":16,"usePreview":0,"tags":["light","interference","hologram"],"hasliked":0,"parentid":"l3XBW4","parentname":"Double-Slit Interferometer"},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"bool isKeyPressed(int key) {\n    return texelFetch(iChannel0, ivec2(key, 0), 0).x > 0.f;\n}\n\nfloat f(float d) {\n    return sin(iTime * 10.f - 1000.f * d);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    float aspect = iResolution.x / iResolution.y;\n    vec2 pixel = fragCoord / iResolution.y;\n    \n    vec2 object = iMouse.xy / iResolution.y;\n    vec2 hologram = vec2(aspect * 0.4f, 0);\n    vec2 pinhole = vec2(aspect * 0.7f, 0.5f);\n    \n    float objectBeamAngle = radians(-150.f);\n    vec2 objectBeam = normalize(vec2(cos(objectBeamAngle), sin(objectBeamAngle)));\n    \n    float refBeamAngle = radians(60.f);\n    vec2 refBeam = normalize(vec2(cos(refBeamAngle), sin(refBeamAngle)));\n    \n    float intensity  = 0.f;\n    \n    if (pixel.x < hologram.x) \n    {\n        intensity += f(dot(objectBeam, pixel));\n        intensity += f(dot(objectBeam, object) + distance(object, pixel));\n    }\n    else if (pixel.x < pinhole.x)\n    {\n        intensity += f(dot(objectBeam, object) + distance(object, pixel));\n        intensity += f(dot(refBeam, pixel));\n    }\n    else \n    {\n        const float I = 20.f;\n        for (float i = 0.f; i < I; i++) {\n            vec2 h = pinhole + vec2(0, 0.05f * (i / I - 0.5f));\n            if (isKeyPressed(32)) {\n                intensity += f(dot(objectBeam, object) + distance(object, h) + distance(h, pixel));\n            } else {\n                const float J = 400.f;\n                float t = 0.f;\n                for (float j = 0.f; j < J; j++) {\n                    vec2 g = vec2(hologram.x, j / J);\n                    t += f(dot(objectBeam, object) + distance(object, g) + distance(g, h) + distance(h, pixel));\n                    t += f(dot(refBeam, g) + distance(g, h) + distance(h, pixel));\n                }\n                t /= sqrt(J);\n                intensity += t;\n            }\n        }\n        intensity /= I;\n    }\n    \n    fragColor.rgb = abs(intensity) * (intensity > 0.f ? vec3(1,0,0) : vec3(0,0,1));\n}","name":"Image","description":"","type":"image"}]}