{"ver":"0.1","info":{"id":"7l3yzs","date":"1714164657","viewed":54,"name":"Fantasy World","username":"princejangid","description":"A Fantasy World.","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["fantasyworld"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*Coordinate system used:\n  x - Towards right\n  y - Towards up\n  z - Towards you */\n  \n#define PI    3.14159265\n\nfloat dis_sph(vec3 pos,vec3 sphcentre,float sphradius,float rigidness)\n{\n    pos = pos - sphcentre;\n    \n    float y = sphcentre.y;\n    y = min(y/sphradius,1.0);\n    pos.x = y*pos.x;\n    pos.z = y*pos.z;\n    pos.y = pos.y/y/y;\n    return(length(pos)-sphradius);\n}\n\nfloat dis_ground( in vec3 pos)\n{\n    return pos.y;\n    //return(pos.y-1.0*sin(0.2*pos.x)*sin(0.2*pos.z));\n}\n\nfloat dis_box( vec3 pos, vec3 boxcentre, vec3 boxsize)\n{\n    pos = pos - boxcentre;\n    mat3 rotate1 = 0.707*mat3( vec3( 1.414, 0, 0   ),\n                                 vec3( 0,1,-1),\n                                 vec3( 0, 1, 1   )  );\n    mat3 rotate2 = 0.707*mat3( vec3( 1, 0,-1   ),\n                                 vec3( 0,1.414,0),\n                                 vec3( 1, 0, 1   )  );\n    //pos = rotate2*rotate1*pos;\n    pos = abs(pos);\n    vec3 distance = vec3(max(pos.x-0.5*boxsize.x,0.0),\n                         max(pos.y-0.5*boxsize.y,0.0),\n                         max(pos.z-0.5*boxsize.z,0.0) );\n    return length(distance)-0.0;\n}\nfloat dis_cyl( vec3 pos , vec3 cylcentre )\n{\n    pos = abs(pos);\n    vec3 distance = pos-vec3(cylcentre.x,pos.y,cylcentre.z);\n    return length(distance)-0.5;\n}\n\nvec2 dis( in vec3 pos,in vec3 YourPos,in vec3 view)\n{\n    float d;\n    float oc;float s=500.0;\n    float sphradius = 0.3;\n    \n    //sphere 1\n    float t = (0.99*iTime);\n    float rigidness = 0.7;\n    float ModifiedRadius = rigidness*sphradius;\n    float v=100.0 ,th=3.0*PI/4.0 ,h=1.0, t0=sqrt(h/5.0);\n    //vec3 sphcentre1 = vec3(v*sin(th)*t,ModifiedRadius+5.0*t-5.0*pow(t,2.0) ,v*cos(th)*t);\n    vec3 sphcentre1 = vec3(v*sin(th)*t,\n                           ModifiedRadius+h-5.0*pow(mod(t-t0,2.0*t0)-t0,2.0),\n                           v*cos(th)*t);\n    float d1 = dis_sph(pos,sphcentre1,sphradius,rigidness);\n    d = min(d1,d1);\n    oc = 1.0;\n\n    //sphere 2\n    vec3 sphcentre2 = vec3(-1, sphradius+5.0*t-5.0*pow(t,2.0) ,0);\n    float d2 = dis_sph(pos,sphcentre2,sphradius,rigidness);\n    //d = min(d,d2);\n    \n    //sphere 3\n    vec3 sphcentre3 = vec3(1, sphradius+5.0*t-5.0*pow(t,2.0) ,0);\n    float d3 = dis_sph(pos,sphcentre3,sphradius,rigidness);\n    //d = min(d,d3);\n\n    //box\n    vec3 boxsize = vec3(0.5,4.0,2.0);\n    vec3 boxcentre = vec3(-5,0.5*boxsize.y,-5);\n    float d4 = dis_box(pos,boxcentre,boxsize);\n    oc = min(4.0,max(oc,-s*(d4-d)));\n    d = min(d,d4);\n    \n    //pillar\n    vec3 cylcentre = vec3(3,0,3);\n    float d5 = dis_cyl(pos,cylcentre);\n    //d = min(d,d5);\n    \n    //sphere 4\n    vec3 sphcentre4 = vec3(0, sphradius+5.0*t-5.0*pow(t,2.0) ,1);\n    float d6 = dis_sph(pos,sphcentre4,sphradius,rigidness);\n    //d = min(d,d6);\n    \n    //ground\n    float dis_ground = dis_ground(pos);\n    oc = min(7.0,max(oc,-s*(dis_ground-d)));\n    d = min(d,dis_ground);\n    \n    \n    //gun\n    //vec3 gunCen = vec3(0.0,0.5,0.0);\n    vec3 handPos = 0.05*cross(view,vec3(0,1,0)) - vec3(0,0.03,0);\n    vec3 gunCen = YourPos + handPos;\n    vec3 disGun = pos - gunCen;\n    \n    vec3 gunDir = view;//vec3(0.0,1.0,0.0);\n    \n    float c = length(vec2(gunDir.y,gunDir.z));\n    mat3 rt1 =(1.0/c)* mat3( vec3(c  ,0.0      ,0.0     ),\n                             vec3(0.0,gunDir.y ,-gunDir.z),\n                             vec3(0.0,gunDir.z ,gunDir.y)   );\n    float cosalpha = gunDir.x;\n    float sinalpha = sin( acos(cosalpha) );\n    mat3 rt2 = mat3( vec3(cosalpha ,-sinalpha,0.0),\n                     vec3(sinalpha,cosalpha,0.0),\n                     vec3(0.0      ,0.0     ,1.0) );\n                     \n    vec3 new = rt2*rt1*disGun;\n    \n    //new.x = abs(new.x);\n    new = abs(new);\n    \n    float dg2 = length( vec3(max(new.x-0.15,0.0),new.y,new.z) )-0.005 ;   \n    \n    //float dg = length( cross(disGun,view))-0.1 ;\n    oc = min(8.0,max(oc,-s*(dg2-d)));\n    d = min(d,dg2);\n    \n    //gunshot\n    \n    vec3 bulletpos = gunCen;\n    vec3 bullets = texelFetch(iChannel1,ivec2(0,0),0).xyz;\n    bulletpos += bullets;\n    \n    float db = dis_sph(pos,bulletpos,0.01,rigidness);\n    oc = min(9.0,max(oc,-s*(db-d)));\n    d=min(d,db);\n\n    return vec2(d,oc);\n}\n\nvec3 CalcNormal(in vec3 pos,in vec3 ro,in vec3 view)\n{\n    vec2 e = vec2(0.0001,0.0);\n    return normalize(vec3(dis(pos+e.xyy,ro,view).x-dis(pos-e.xyy,ro,view).x,\n                          dis(pos+e.yxy,ro,view).x-dis(pos-e.yxy,ro,view).x,\n                          dis(pos+e.yyx,ro,view).x-dis(pos-e.yyx,ro,view).x ));\n}\n\nvec4 castray( in vec3 ro, in vec3 rd,in vec3 YourPos,in vec3 view)\n{\n    float t = 0.0;\n    vec3 pos = ro;\n    float d = 0.0;\n    float c = 0.0;//object code (0 for sky)\n    for( int i=0; i<200; i++)\n    {\n        d = dis(pos,YourPos,view).x;\n        if(d<0.0001)\n        {\n            c = dis(pos,YourPos,view).y;\n            break;\n        }\n        pos += d*rd;\n        t += d;\n        if(t>30.0)\n        {\n            break;\n        }\n    }\n    return(vec4(pos,c));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec2 tweak = 2.0*(2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    //tweak.x = 1.5*tweak.x;\n    //tweak.y = 0.5*tweak.y;\n\n    vec3 view = normalize(vec3(sin(tweak.x),tweak.y,-cos(tweak.x)));\n    vec3 x = normalize(cross(view,vec3(0,1,0)));\n    vec3 y = normalize(cross(x,view));\n    \n    vec3 YourPosition = vec3(0.0,0.5,5.0);\n    \n    //keyboard\n    vec2 offset = texelFetch( iChannel0, ivec2(0, 0), 0).xy;\n    YourPosition += vec3(offset.x,0,offset.y);\n\n    vec3 ro = YourPosition;\n    vec3 rd = normalize(4.0*view + x*p.x + y*p.y);\n    \n    vec4 config = castray(ro,rd,YourPosition,view);\n    vec3 hitspot = config.xyz;\n    float explored = config.w;\n    float c = explored;\n\n    float s = 500.0;\n    float f0 = min(1.0,max(0.0,s*(c+0.5)));\n    float g0 = min(1.0,max(0.0,-s*(c-0.5)));\n\n    float f1 = min(1.0,max(0.0,s*(c-0.5)));\n    float g1 = min(1.0,max(0.0,-s*(c-1.5)));\n\n    float f2 = min(1.0,max(0.0,s*(c-1.5)));\n    float g2 = min(1.0,max(0.0,-s*(c-2.5)));\n\n    float f3 = min(1.0,max(0.0,s*(c-2.5)));\n    float g3 = min(1.0,max(0.0,-s*(c-3.5)));\n\n    float f4 = min(1.0,max(0.0,s*(c-3.5)));\n    float g4 = min(1.0,max(0.0,-s*(c-4.5)));\n   \n    float f7 = min(1.0,max(0.0,s*(c-6.5)));\n    float g7 = min(1.0,max(0.0,-s*(c-7.5)));\n    \n    float f8 = min(1.0,max(0.0,s*(c-7.5)));\n    float g8 = min(1.0,max(0.0,-s*(c-8.5)));\n    \n    float f9 = min(1.0,max(0.0,s*(c-8.5)));\n    float g9 = min(1.0,max(0.0,-s*(c-9.5)));\n    \n    vec3 col = min(f0,g0)*vec3(0.1,0.7,1.0)*0.8;//sky\n        \n        //objects\n    col += min(f1,g1)*0.1*vec3(6.0,4.0,2.0);//brownish\n    col += min(f4,g4)*vec3(0.1,0.2,0.2);//grey\n        \n        //ground\n    col += min(f7,g7)*vec3(0.2,0.8,0.2);//green\n        \n        //gun\n    col += min(f8,g8)*vec3(0.05,0.05,0.05);//grey\n        \n        //gunshot\n    col += min(f9,g9)*vec3(1.05,1.05,1.05);//grey\n    \n        //lighting\n    vec3 SunDir = normalize(vec3(1,1,1));\n    vec3 nor = CalcNormal(hitspot,YourPosition,view);\n        \n        //diffuse lighting\n    float SunDif = clamp(dot(SunDir,nor),0.0,1.0);\n    col *= 1.5*SunDif;\n        \n    float SkyDif = clamp(dot(nor,vec3(0,1,0)),0.0,1.0);\n    col += 0.1*SkyDif*vec3(0.1,0.7,1.0);\n\n        //specular lighting\n    float SunSpec = dot(SunDir,nor);\n    //col += pow(col,vec3(20.0*SunSpec));\n    //col += 1.9*vec3(smoothstep(0.98,1.02,SunSpec) );\n    col += smoothstep(0.985,0.99,SunSpec*SunSpec*SunSpec*SunSpec);\n\n        //sun shadow\n    float SunShadow = smoothstep(0.01,0.0,castray(hitspot+0.0001*nor,SunDir,YourPosition,view).w);\n    col *= SunShadow;\n        \n        //bounce light\n    float SunBounce = dot(nor,vec3(0,-1,0));\n    col += 0.1*SunBounce*vec3(0.8,1.0,0.6);    \n   \n        //gamma\n    col = pow(col,vec3(0.4545));\n    //float br = length(col);\n    //col *= br;\n    \n    // output to screen\n    fragColor = vec4(col,1.0);\n}\n\n/*\nfloat[n] dis_spheres( in vec3 pos)\n{\n    float[n] spheres;\n    for(int i=0; i<n; i++)//n=No. of spheres\n    {\n        spheres[i]=length(pos-sphcentres[i])-sphradius;\n    }\n    return(spheres);\n}\nfloat minimum( in float[3] array)\n{\n    float x = array[0];\n    for(int i=0; i<array.length(); i++)\n    {\n        x = min(x,array[i]);\n    }\n    return(x);\n}\n*/","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n// Numbers are based on JavaScript key codes: https://keycode.info/\nconst int KEY_LEFT  = 65;\nconst int KEY_UP    = 87;\nconst int KEY_RIGHT = 68;\nconst int KEY_DOWN  = 83;\nconst int KEY_FIRE  = 70;\n\nvec2 handleKeyboard(vec2 offset) {\n    float velocity = 0.1; // This will cause offset to change by 0.01 each time an arrow key is pressed\n    \n    vec2 tweak = 2.0*(2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    vec2 forward = vec2(sin(tweak.x),-cos(tweak.x));\n    vec2 rightward = vec2(cos(tweak.x),sin(tweak.x));\n    \n    // texelFetch(iChannel1, ivec2(KEY, 0), 0).x will return a value of one if key is pressed, zero if not pressed\n    vec2 left = -rightward * texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).x;\n    vec2 up = forward * texelFetch(iChannel1, ivec2(KEY_UP,0), 0).x;\n    vec2 right = rightward * texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).x;\n    vec2 down = -forward * texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).x;\n    \n    offset += (left + up + right + down) * velocity;\n\n    return offset;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Return the offset value from the last frame (zero if it's first frame)\n    vec2 offset = texelFetch( iChannel0, ivec2(0, 0), 0).xy;\n    \n    // Pass in the offset of the last frame and return a new offset based on keyboard input\n    offset = handleKeyboard(offset);\n    \n    // Store offset in the XY values of every pixel value and pass this data to the \"Image\" shader and the next frame of Buffer A\n    fragColor = vec4(offset, 0, 0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n// Numbers are based on JavaScript key codes: https://keycode.info/\n\nconst int KEY_FIRE  = 70;\n\n\nvec3 handleFire(vec3 bullets)\n{\n    float velocity = 0.1;\n    \n    vec2 tweak = 2.0*(2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    vec2 forward = vec2(sin(tweak.x),-cos(tweak.x));\n    \n    // texelFetch(iChannel1, ivec2(KEY, 0), 0).x will return a value of one if key is pressed, zero if not pressed\n    vec2 up = forward * texelFetch(iChannel1, ivec2(KEY_FIRE,0), 0).x;\n    \n    bullets += vec3(up.x,0,up.y) * velocity;\n\n    return bullets;\n}\n\nvoid mainImage( out vec4 fracolor,in vec2 fragCoord )\n{\n    // Return the offset value from the last frame (zero if it's first frame)\n    \n    vec3 bullets = texelFetch(iChannel0,ivec2(0,0),0).xyz;\n    \n    // Pass in the offset of the last frame and return a new offset based on keyboard input\n    \n    bullets = handleFire(bullets);\n\n    // Store offset in the XY values of every pixel value and pass this data to the \"Image\" shader and the next frame of Buffer A\n    //vec4[12] fragcolor;\n    //for(int i=0;i<12;i++)\n    //{\n    //    fragcolor[i] = vec4(bullets, 0);\n    //}\n    fracolor=vec4(bullets,0.0);//fragcolor[0]);\n}","name":"Buffer B","description":"","type":"buffer"}]}