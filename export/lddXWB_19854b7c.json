{"ver":"0.1","info":{"id":"lddXWB","date":"1461355509","viewed":569,"name":"Digesting","username":"drone1","description":"From a personal project I am working on. This code is a bit of a mess, but please let me know if you see anything off or have other feedback. I'm here to learn. Thanks a lot.\n\nI think the AO messes up, causing some artifacts. Anyone see it?","likes":23,"published":1,"flags":8,"usePreview":0,"tags":["3d","noise","audio","distance","field","creepy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Uncomment ENABLE_AA to make things even slower.\n// Lots of utility code in here by IQ.\n\n#define ULTRA_DETAIL\n//#define ENABLE_AA\n\nfloat camHeight;\n\nfloat amount_balls = 1.0000;\nfloat amount_ribs = 0.0000;\nfloat amount_smooth = 0.0000;\nfloat amount_fresnel = 0.0696;\nfloat amount_remove = 0.0000;\nfloat amount_bottomlight = 0.1000;\nfloat specular_exp = 4.0000;\n\nvec3 clr_bg = vec3( 0.0 );\nvec3 clr_base = vec3( 0.0 );\nvec3 clr_ambient = vec3( 0.0100, 0.0100, 0.0100 );\nvec3 clr_remove = vec3( 0.3000, 0.3000, 0.3000 );\nvec3 clr_spec = vec3( 1.0000, 1.0000, 1.0000 );\nvec3 clr_skylight = vec3( 1.0000, 0.9608, 0.8431 );\nvec3 clr_diffuse = vec3( 1.0000, 0.0000, 0.0000 );\nvec3 clr_subsurface = vec3( 0.3176, 0.1059, 0.5608 );\nvec3 clr_lights_ambient = vec3( 0.4000, 0.4000, 0.4000 );\nvec3 clr_lights_diffuse = vec3( 1.0000, 1.0000, 1.0000 );\nvec3 clr_glow = vec3( 1.0000, 1.0000, 1.0000 );\n\nfloat glow_dist = 0.1000;\nfloat glow_amount = 0.0000;\nfloat show_lights = 1.0000;\n\nvec3 cam_mindist = vec3( -7.3140, -7.7585, -5.9952 );\nvec3 cam_floatdist = vec3( 1.0000, 1.0000, 0.5000 );\n\n#ifdef ENABLE_AA\n#define AA_ITER_COUNT 9\n#define AA_ITER_COUNT_SQRT 3.0\n#else\n#define AA_ITER_COUNT 1\n#define AA_ITER_COUNT_SQRT 1.0\n#endif\n\n#define AO_ITERATIONS\t32\n\n#define MAX_DIST\t60.0\n#define MATERIAL_NONE\t0.0\n#define MATERIAL_MAIN\t1.0\n#define MATERIAL_LIGHTS\t100.0\n\n// Globals\nfloat time0;\n\nvec3 hash3( float n )\n{\n\treturn fract(sin(vec3(n,n+1.0,n+2.0))*23421.7578287);\n}\n\nfloat hash1f( float f )\n{\n\treturn fract(.5 + .5 * sin(f)*12859.2342608);\n}\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdSphere( vec3 p, float r )\n{\n\treturn length(p) - r;\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n\treturn length(p.xz-c.xy)-c.z;\n}\n\n// iq fast noise\nfloat noisefast( vec3 p )\n{\n\tvec3 ip = floor( p ), f = fract( p );\n    f = f * f * f * ( f * ( f * 6.0 - 15.) + 10.0 );\n    \n\tvec2 uv = ( ip.xy + vec2(37.0,17.0)*ip.z) + f.xy;\n\tvec2 rg = texture( iChannel0, (uv + 0.5)/256.0, -100.0 ).yx;\n    \n\treturn mix(rg.x, rg.y, f.z);\n}\n\nfloat noise11( in float x )\n{\n\tfloat p = floor(x);\n\tfloat f = fract(x);\n\treturn mix( hash1f(p), hash1f(p+1.0), f*f*(3.0-2.0*f));\n}\n\nfloat n( vec3 p )\n{\n\treturn noisefast( p );\n}\n\nmat3 GetCameraRotationMatrix( in vec3 eye, in vec3 lookat, float roll )\n{\n\tvec3 cz = normalize( lookat - eye );\n\tvec3 cp = vec3(sin( roll ), cos( roll ), 0.0);\n\tvec3 cx = normalize( cross(cz,cp) );\n\tvec3 cy = normalize( cross(cx,cz) );\n\treturn mat3( cx, cy, cz );\n}\n\nfloat FBM( in vec3 p, in vec3 offset, float a, float f )\n{\n\tfloat x = 0.0;\n\tx += a * n( p ); a *= 0.5; p = 2.01 * p - offset;\n\tx += a * n( p ); a *= 0.5; p = 2.03 * p - offset;\t\n\tx += a * n( p ); a *= 0.5; p = 2.02 * p - offset;\t\n\tx += a * n( p ); a *= 0.5; p = 2.01 * p - offset;\t\n#ifdef ULTRA_DETAIL\n\tx += a * n( p ); a *= 0.5; p = 2.02 * p - offset;\t\n\tx += a * n( p ); a *= 0.5; p = 2.01 * p - offset;\t\n\tx += a * n( p ); a *= 0.5; p = 2.01 * p - offset;\t\n#endif\n\tx += a * n( p );\n\treturn x;\n}\n\nfloat Thingy( in vec3 p, float phase )\n{\n\tfloat t = time0 + phase;\n\tfloat st = sin( t );\n\tfloat nst = 0.5 + 0.5 * sin( t );//sin( noise11( t ) );\n\tfloat v = sin( st + sin( 0.1 * p.x ) );\n\tfloat offset_r = mix( 0.1, 2.0, 0.75 + 0.25 * sin( time0 * 0.1 ) );\n\tvec3 q = p;\n\tfloat n11 = noise11( 2.0 * t );\n\tfloat yf = t + .1 * p.y + n11;\n\tfloat yf2 = t + .12 * p.y + noise11( 1.58 * t + 234234.3234 );\n\tq.xz += vec2( v * offset_r * cos( yf ), v * offset_r * sin( yf2 ) );\n\n\tfloat r = 0.6 + 0.3 * sin( q.y + t );\n\tfloat d = sdCylinder( q, vec3( r, r * 2.0, r ) );\n\n\t// Ribs\n\tfloat f = 3.0;\n\td += amount_balls * 0.23 * nst * sin( .3 * t + f * q.x ) * sin( f * q.y ) * sin( f * q.z );\n\td += amount_ribs * .004 * sin( .9 * t + 10. * f * q.y ) * sin( f * q.z );\n\n\tfloat sphere_y = camHeight + mix( -13.0, 13.0, mod( 0.1 * t + sin( .05 * ( mix( -1.0, 1.0, noise11( t ) ) + t ) ), 5.0 ) );\n\tfloat sp = sdSphere( q + vec3( 0.0, sphere_y, 0.0 ), mix( 2.0, 2.35, nst ) - mod( phase, 0.1 ) );\n\n\tfloat k = mix( 1.0, 1.6, .5 + .5 * sin( .3 * t ) );\n\tfloat n = ( 1.0 - amount_smooth ) * FBM( q - vec3( 0.0, -time0, 0.0 ), mix( vec3( k ), vec3( cos( nst ) ), nst ), 0.5, 1.0 );\n\tn = pow( 0.5 + 0.5 * n, 2.0 );\n\treturn smin( d, sp, k ) - n;\n}\n\nvec2 Map( in vec3 p )\n{\n\tvec3 q = p;\n\n\treturn vec2( Thingy( q, 0.0 ), MATERIAL_MAIN );\n}\n\nvec3 Normal( in vec3 p, float e ) \n{\n\tvec3 eps = vec3( e, 0.0, 0.0 );\n\n\treturn normalize( vec3( Map(p+eps.xyy).x - Map(p-eps.xyy).x,\n\t\t\t\tMap(p+eps.yxy).x - Map(p-eps.yxy).x,\n\t\t\t\tMap(p+eps.yyx).x - Map(p-eps.yyx).x ) );\n}\n\nvec3 Render( vec2 uv, vec3 eye, vec3 dir )\n{\n\tvec3 col = clr_base;\n\n\tfloat tmax = MAX_DIST;\n\tfloat h = 1.0;\n\tfloat t = 0.0;\n\tfloat m = 1e10;\n\tfloat mat = MATERIAL_NONE;\n\tvec2 min_result = vec2( 1e10, MATERIAL_NONE );\n\n\tfor( int i=0; i<100; i++ ) \n\t{\n        vec3 p = eye + t*dir;\n\t\tvec2 result = Map( p );\n\n\t\th = result.x;\n\t\tmat = result.y;\n\n\t\tif ( result.x < min_result.x )\n\t\t{\n\t\t\tmin_result = result;\n\t\t}\n       \n\t\tif( h < 0.0001 || t > tmax )\n\t\t\tbreak;\n\n\t\tt += h;\n\t}\n\n\tvec3 sunpos = vec3( 0.0, 5.0, 0.0 );\n\tvec3 lightdir = vec3( cos( time0 ), 1.0, sin( time0 ) );\n\n\tif( t<tmax && t >= 0.0 )\n\t{\n\t\tvec3 pos = eye + t*dir;\n\t\tvec3 norm = Normal( pos, 0.005 );\n\n\t\tcol += clr_ambient;\n\n\t\tfloat f = mix( 1.0, 10.0, noise11( 28342.223 + iTime ) );\n\t\tfloat occ = mix( 0.0, 1.1, noise11( f * iTime ) );\n\n\t\t// diffuse\n\t\tfloat diff = 0.0;\n\t\tfor( int i=0; i<AO_ITERATIONS; i++ )\n\t\t{\n\t\t\tvec3 rr = normalize(-1.0 + 2.0*hash3(float(i)*123.5463));\n\t\t\trr = normalize( norm + 7.0*rr );\n\t\t\trr = rr * sign(dot(norm,rr));\t\t\t\t\t\t\t  \n\t\t\tdiff += 4.0 * 0.1 * dot(rr,norm);\n\n\t\t}\n\t\tdiff /= float(AO_ITERATIONS);\n\n\t\tdiff *= 4.0;\n\n\t\t// material\n\t\tif ( mat == MATERIAL_MAIN )\n\t\t{\n\t\t\tvec3 ref = reflect( lightdir, norm );\n\t\t\tfloat spec = clamp( dot( normalize( eye - pos ), ref ), 0.0, 1.0 );\n\t\t\tfloat fres = clamp( 1.0 + dot( norm, dir ), 0.0, 1.0 );\n\t\t\tfloat diff_dot = clamp( dot(norm,lightdir), 0.0, 1.0 );\n\t\t\tcol += occ * diff * clr_diffuse * diff_dot;\n\n\t\t\tcol += clr_skylight * clamp( norm.y, 0.0, 1.0 );\t// sky light\n\t\t\t\n\t\t\tfloat s = .5 + .5 * sin( .5 * iTime );\n\t\t\tcol.r -= amount_remove * smoothstep( -3.0, 3.0, pos.x ) * clr_remove.r * s;\n\t\t\tcol.g -= amount_remove * smoothstep( -3.0, 3.0, pos.x ) * clr_remove.g * s;\n\t\t\tcol.b -= amount_remove * smoothstep( -3.0, 3.0, pos.z ) * clr_remove.b * s;\n\n\t\t\t// glow\n\t\t\tcol += glow_amount * clr_glow;\n\t\t}\n\t\telse if ( mat >= MATERIAL_LIGHTS && show_lights > 0.0 )\n\t\t{\n\t\t\tcol += clr_lights_ambient;\n\t\t\tcol += diff * clr_lights_diffuse * clamp( dot( norm, lightdir ), 0.0, 1.0 );\n\n\t\t\tcol *= show_lights;\n\t\t}\n\n\t\tcol *= exp( -0.050*t );\t// fog\n\t}\n\telse\n\t{\n\t\tcol = clr_bg;\n\t}\n\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 coord )\n{\n\tfloat aspect = iResolution.x / iResolution.y;\n\n\ttime0 = 25. + iTime;\n\ttime0 += 2.0 * smoothstep( 0.00,  1.5, iTime );\n\ttime0 += 2.0 * smoothstep( 10.0, 15.0, iTime );\n\n\tvec3 col = vec3( 0.0 );\n\n#ifdef ENABLE_AA\n\tfor ( int i = 0; i < AA_ITER_COUNT; ++i )\n#else\n\tint i = 0;\n#endif\n\t{\n\t\tvec2 offset = vec2( float(i) / AA_ITER_COUNT_SQRT, mod( float(i), AA_ITER_COUNT_SQRT ) ) / AA_ITER_COUNT_SQRT;\n\t\tvec2 uvs = -1.0 + 2.0 * ( coord.xy + offset ) / iResolution.xy;\n        uvs.x *= aspect;\n\n\t\t// CAMERA\n\n\t\tfloat camspeed = 0.1;\n        float look_phase = 0.03 * iTime + 3.14159 * 2.0 * iMouse.x/iResolution.x;\n        float df = mix( 1.0, 1.7, iMouse.y/iResolution.y );\n\t\tcamHeight=0.0;//3.0*iTime;\n        float camOffset = 2.0+15.0*(.5+.5*sin(iTime));\n        vec3 eye = vec3(\n\t\t\tdf * cam_mindist.x * cos( look_phase ) + cam_floatdist.x * cos( 1.5708 + camspeed * 0.10 * time0 ),\n\t\t\tcamHeight+df * cam_mindist.y + cam_floatdist.y * cos( camspeed * 0.011 * time0 ),\n\t\t\tcamOffset+df * cam_mindist.z * sin( look_phase ) + cam_floatdist.z * sin( camspeed * 0.10 * time0 )\n\t\t);\n        float circleTime = iTime*.1;\n        eye.xz += 30.0*vec2(cos(circleTime),sin(circleTime));\n\n\t\tmat3 ca = GetCameraRotationMatrix( eye, vec3( 0.0, camHeight+20.*sin(.1632*iTime), 0.0 ), 0.0 );\n\n\t\t// ray direction\n\t\tvec3 dir = ca * normalize( vec3(uvs.xy,8.0) );\n\n\t\tcol += Render( uvs, eye, dir );\n\t}\n\n\tcol /= float( AA_ITER_COUNT );\n\n\t// POSTPROCESSING\n\n\t// contrast    \n\tcol = mix( col, smoothstep( 0.0, 1.0, col ), 0.1 );\n\n\t// dithering\n\tcol += ( 25.0 / 255.0 )*hash3( iTime + coord.x + 300.0 * coord.y );\n\n    // scanlines\n    float f = noise11( ( 300.0 + iTime ) * ( 0.2 + coord.y * 0.1 ) );\n    vec2 uv = coord.xy / iResolution.xy;\n    f *= smoothstep( 0.0, 0.5, uv.y );\n\tcol.r -= 0.20 * f;\n    col.g *= 1.0 + 0.1 * f * f + 0.05 * uv.y;\n    col.b -= 0.1 * ( 1.0 - uv.y );\n    col.r += 0.03 * uv.x;\n    col = pow( col, vec3( mix( 0.9, 1.0, f ) ) );\n    \n\tfragColor = vec4( mix( col, 1.0 - col, 0.1 * 0.7 * noise11( 30.0 * iTime ) ), 1.0 );\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"XsfGRr","channel":0}],"code":"\n\nvec2 mainSound( in int samp, float time )\n{\n    float f = mix( 80.0, 90.0, 0.5 * 0.5 * sin( time * 2.1 ) );\n    float f2 = f * 88.0 / 80.0;\n    float ex = mix( 1.0, 256.0, 0.5 + 0.5 * sin( time * 300.0 ) );\n    float s = mix( 0.1, 10.0, 0.5 + 0.5 * sin( time * 1.0 ) );\n    \n    float attack = smoothstep( 0.0, 0.05, mod( time, 3.0 ) );\n    \n    return 0.5 * attack * 1.2 * \n        vec2( .5 * sin(6.2831*f*time)*exp(-2.0*mod( time, 3.0 )) +\n             .5 * sin(6.2831*f2*time)*exp(-2.0*mod( time, 3.0 )) +\n             .15 * step( 0.00005, mod( time, 1.0 / ( 6.2831 * time ) ))*exp(-1.0*mod( time, 3.0 )) +\n             .5 * pow(abs(sin(2342.96+6.2831*f2*(1.0 - 2.0 * (.5+.5*sin(time)))*time)*exp(-s*mod( time, 3.0 ))), ex )\n        );\n}","name":"Sound","description":"","type":"sound"}]}