{"ver":"0.1","info":{"id":"DtjfzR","date":"1693693153","viewed":113,"name":"Wasteland","username":"twixuss","description":".","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","wasteland"],"hasliked":0,"parentid":"WtGXDD","parentname":"RayMarching starting point"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Wasteland by twixuss\n//\n// Uses template by BigWIngs https://www.shadertoy.com/view/WtGXDD\n//\n#define USE_FASTER_VERSION 1\n#define MAX_STEPS 50\n#define MAX_DIST 500.\n#define SURF_DIST .01\n#define TAU 6.283185\n#define PI 3.141592\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 random_vec3(vec3 a) {\n    a = vec3(dot(a,vec3(127.1,311.7,634.8)), \n\t\t\t dot(a,vec3(269.5,183.3,878.8)), \n\t\t\t dot(a,vec3(413.2,631.3,194.3)));\n\treturn fract(sin(a)*43758.5453);\n}\nfloat random_float(vec3 p){\n\tvec3 a = fract((p + 1.414) * vec3(31.123, 3.141, 6.762));\n\ta += dot(a, a + 12.653);\n\ta = vec3(a.x * a.y, a.x * a.z, a.y * a.z);\n    return fract(dot(a,a));\n}\nfloat distance_squared3(vec3 a, vec3 b) {\n    a -= b;\n    return dot(a, a);\n}\nfloat distanceToLine3(vec3 point, vec3 linea, vec3 lineb) {\n\tfloat l2 = distance_squared3(linea, lineb);\n\tif (l2 == 0.) return 0.;\n\n\tfloat t = dot(point - linea, lineb - linea) / l2;\n    t = clamp(t, 0., 1.);\n\tvec3 projection = linea + t * (lineb - linea);\n\treturn distance(point, projection);\n}\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n\nfloat snoise1(vec3 uv){\n    vec3 r = fract(uv);\n    r = smoothstep(0., 1., r);\n\n    vec3 t = floor(uv);\n    \n\n    float a = random_float(t + vec3(0,0,0));\n    float b = random_float(t + vec3(1,0,0));\n    float c = random_float(t + vec3(0,1,0));\n    float d = random_float(t + vec3(1,1,0));\n    float e = random_float(t + vec3(0,0,1));\n    float f = random_float(t + vec3(1,0,1));\n    float g = random_float(t + vec3(0,1,1));\n    float h = random_float(t + vec3(1,1,1));\n    return mix(mix(mix(a, b, r.x), mix(c, d, r.x), r.y),\n               mix(mix(e, f, r.x), mix(g, h, r.x), r.y), r.z);\n}\n\nvec3 snoise3(vec3 uv){\n    vec3 r = fract(uv);\n    r = smoothstep(0., 1., r);\n\n    vec3 t = floor(uv);\n    \n\n    vec3 a = random_vec3(t + vec3(0,0,0));\n    vec3 b = random_vec3(t + vec3(1,0,0));\n    vec3 c = random_vec3(t + vec3(0,1,0));\n    vec3 d = random_vec3(t + vec3(1,1,0));\n    vec3 e = random_vec3(t + vec3(0,0,1));\n    vec3 f = random_vec3(t + vec3(1,0,1));\n    vec3 g = random_vec3(t + vec3(0,1,1));\n    vec3 h = random_vec3(t + vec3(1,1,1));\n    return mix(mix(mix(a, b, r.x), mix(c, d, r.x), r.y),\n               mix(mix(e, f, r.x), mix(g, h, r.x), r.y), r.z);\n}\n\nfloat sdRGrid(vec3 uv) {\n#if USE_FASTER_VERSION\n    uv += snoise3(uv);\n    uv = fract(uv) - 0.5;\n    vec3 r;\n    r.x = length(uv.yz);\n    r.y = length(uv.xz);\n    r.z = length(uv.xy);\n    return min(r.x, min(r.y, r.z));\n#else\n    vec3 tile = floor(uv);\n    vec3 local = uv - tile;\n    \n    float d = 100.;\n    \n    vec3 r[3*3*3];\n    \n    for (int x = -1; x <= 1; ++x) {\n        for (int y = -1; y <= 1; ++y) {\n            for (int z = -1; z <= 1; ++z) {\n                int ix = x + 1;\n                int iy = y + 1;\n                int iz = z + 1;\n                r[ix*3*3 + iy*3 + iz] = vec3(x,y,z) + random_vec3(tile + vec3(x,y,z));\n            }\n        }\n    }\n    \n\tfor (int x = 0; x < 3; ++x) {\n\t\tfor (int y = 0; y < 3; ++y) {\n\t\t\tfor (int z = 0; z < 2; ++z) {\n\t\t\t\td = min(d, distanceToLine3(local, r[x*3*3 + y*3 + z], r[(x  )*3*3 + (y  )*3 + (z+1)]));\n\t\t\t\td = min(d, distanceToLine3(local, r[x*3*3 + z*3 + y], r[(x  )*3*3 + (z+1)*3 + (y  )]));\n\t\t\t\td = min(d, distanceToLine3(local, r[z*3*3 + x*3 + y], r[(z+1)*3*3 + (x  )*3 + (y  )]));\n\t\t\t}\n\t    }\n\t}\n    \n    return d;\n#endif\n}\nstruct Material {\n    vec3 albedo;\n    float shiny;\n};\n\nstruct World {\n    float g, n, y;\n};\n\nWorld getWorld(vec3 p) {\n    World w;\n    w.g = sdRGrid(p*0.2)/0.2 - 0.6;\n    w.n = \n        snoise1(p*0.1)/0.1 +\n        snoise1(p*0.05)/0.05;\n    w.y = p.y + 0.1;\n    return w;\n}\n\nfloat GetDist(vec3 p) {\n    World w = getWorld(p);\n    return clamp(w.g, w.n-3.0 + w.y, w.n + w.y);\n}\n\nMaterial GetMaterial(vec3 p) {\n    World w = getWorld(p);\n    if (w.g < 0.01)\n        return Material(vec3(.5), 1.);\n    \n    return Material(vec3(\n        snoise1(p+0.)*.2 + .2,\n        snoise1(p+4.)*.2 + .1,\n        snoise1(p+8.)*.2 + .0\n    ), 0.);\n}\n\nvoid RayMarch(vec3 ro, vec3 rd, out float dO, out Material material) {\n\tdO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    if (dO < MAX_DIST)\n        material = GetMaterial(ro+rd*dO);\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = GetDist(p) - \n        vec3(GetDist(p-e.xyy), GetDist(p-e.yxy),GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    return normalize(vec3(uv, 1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(m.x, 5. + m.y, 0);\n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    //rd.yz *= Rot(-(m.y-0.5)*0.4*PI);\n    rd.xz *= Rot(-(m.x-0.5)*TAU + iTime*0.1);\n    \n    vec3 col = vec3(0);\n   \n    vec3 V = normalize(rd);\n   \n    float d;\n    Material material;\n    RayMarch(ro, rd, d, material);\n\n    vec3 L = normalize(vec3(2,3,1));\n    vec3 ambient = vec3(.3,.6,.9);\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 N = GetNormal(p);\n        vec3 H = normalize(L-V);\n        vec3 dif = material.albedo * max(0.,dot(N, L));\n        vec3 indirect = material.albedo * ambient / PI;\n        float specular = pow(max(0.001, dot(N, H)), material.shiny * 100.) * pow(material.shiny, 2.0);\n\n        Material dummy;\n        RayMarch(p+N*0.1, L, d, dummy);\n        if(d<MAX_DIST) {\n            dif *= 0.;\n            specular *= 0.;\n        }\n        \n        \n        col = dif + specular + indirect;\n    } else {\n        col = ambient + vec3(0.8, 1.0, 0.6) * smoothstep(0.0, 1.0, dot(V, L));\n        \n        col = vec3(1.2, 1.4, 1.0) * pow(ambient, vec3((-dot(V,L)+1.) * 2.));\n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}