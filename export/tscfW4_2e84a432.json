{"ver":"0.1","info":{"id":"tscfW4","date":"1605167027","viewed":673,"name":"Schwarzchild_Checkerboard","username":"stevejtrettel","description":"Schwarzchild black hole  sandwiched between checkered planes of distance 100 units apart (one black, one red).  BH makes orbit around observer, who remains stationary, equidistant from both planes.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raytrace","blackhole"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nbool eventHorizon;\nfloat M;\nvec3 bhPos;\n\n//a position and velocity\nstruct state{\n    vec3 pos;\n    vec3 dir;\n};\n\n\n//derivative of initial condition: velocity and acceleration\nstruct dState{\n    vec3 vel;\n    vec3 acc;\n};\n\n\n//adding velocity /acceleration pairs\ndState add(dState s1,dState s2){\n    vec3 vel=s1.vel+s2.vel;\nvec3 acc=s1.acc+s2.acc;\ndState sum;\nsum.vel=vel;\nsum.acc=acc;\n    return sum;\n}\n\n\n\n//scaling an acceleration /velocity pair\ndState scale(dState dS,float k){\n    dS.vel*=k;\n    dS.acc*=k;\n    return dS;\n}\n\n\n//evolve a state in time by dS for size stp\nstate nudge(state S, dState dS,float stp){\n    S.pos+=dS.vel*stp;\n    S.dir+=dS.acc*stp;\n    return S;\n}\n    \n    \n\n\n\n//this is the function which sets up the dynamics for the system\n//can put any 2nd order ODE in here\ndState stateDeriv(state S){\n\n//translate by black hole position\nvec3 r=S.pos-bhPos;\nvec3 v=S.dir;\n\ndState dS;\n    //copy over velocity: the equation below \n    //is a trajectory of the form x''=f(x) so this is the standard\n    //trick to turnr it into a system of first order equations\n    dS.vel=v;\n    \n    //now compute acceleration:\n    \n    \n    //the schwarzschild solution is time invarirant, so, we are focused on \n    //drawing the view of an observer stationary w.r.t. coordinates,\n    //we can project off the time direction, and look at the projection of\n    //lightlike geodesics onto xyz space slices of constant time.\n    \n    //different coordinate systems give different ODES: schwarzchild coordinates\n    //give a system with coordinate singularities at the event horizon AND pole phi=0 axis\n    //instead, we convert to a system of eqns in XYZ coords\n    \n    //things turn out after some work to be quite simple: each trajectory has a constnat\n\t//of motion: angular momentum L.  For that fixed L, we can write an ODE for the trajectory\n    //in terms of a force field F_L(x) on RR^3: that is, projections of timelike geodesics\n    //solve x''(t)=F_L(x(t)) (this is not a real force, just a way to think about this ODE)\n    //this acceleration is F_L(x)=-(3/2 M L^2/R^5)*(x,y,z)\n    //where R is the length of xyz\n    \n    float R=length(r);\n    \n    vec3 l=cross(r,v);\n    float L=length(l);\n    \n    float mag=3./2.*M*L*L/(R*R*R*R*R);\n    \n    //set the acceleration\n    dS.acc=-mag*r;\n    //dS.acc=vec3(0.);\n    return dS;\n    \n}\n    \n    \n\n\nvoid euler(inout state S,float dt){\n    \n    dState dS;\n    dS=stateDeriv(S);\n    S=nudge(S,dS,dt);\n}\n    \n    \n    \n\n\nvoid rk4(inout state S,float dt){\n    //constants computed during the process\n    dState k1,k2,k3,k4;\n    state tempS;\n    \n        //get the derivative\n        k1=stateDeriv(S);\n        k1=scale(k1,dt);\n        \n        //move the point a little\n        tempS=nudge(S,k1,0.5);\n        k2=stateDeriv(tempS);\n        k2=scale(k2,dt);\n        \n        //get k3\n        tempS=nudge(S,k2,0.5);\n        k3=stateDeriv(tempS);\n        k3=scale(k3,dt);\n        \n        //get k4\n        tempS=nudge(S,k3,1.);\n        k4=stateDeriv(tempS);\n        k4=scale(k4,dt);\n        \n        //add up results:\n        dState total=scale(k1,1.);  \n        total=add(total,scale(k2,2.));\n        total=add(total,scale(k3,2.));\n        total=add(total,k4);\n        total=scale(total,1./6.);\n        \n        //the state S has been reset to the endpoint;\n        S=nudge(S,total,1.); \n\n}\n\n\n\n\n//make the step size adaptive so it is only small //\n//near the black hole, and then again as you approach\n// the scene boundary as a cheap way to not overshoot\nfloat setDT(state S){\n    \n    float dt,R,bhDT,sceneDT;\n    float sceneRad=50.;//radius of outer sphere;\n    float planeOffset=50.;//how far back the plane is\n    \n    //distance to the black hole:\n    R=length(S.pos-bhPos)-2.*M;\n    //set step size to large if far from black hole, and small if close\n    if(R>5.){bhDT=1.;}\n        else{bhDT=(R/5.)*(R/5.)*0.5+0.01;}\n  //  bhDT=max(R/2.,0.001);\n    \n    \n    //shrink when you approach the boundary\n    //so you don't massively overstep it\n    \n    //this is for a sphere of radius sceneRad\n    //R=sceneRad-length(S.pos);\n    \n    //this is for a plane at z=-planeOffset\n    R=S.pos.z+planeOffset;\n    \n    \n    //this is for a cylinder of radius same as sphere:\n    //R=sceneRad-length(S.pos.xz);\n    \n    sceneDT=max(R/2.,0.001);\n    \n    dt=min(bhDT,sceneDT);\n    dt=min(1.,dt);\n    \nreturn dt;\n    \n    \n}\n\n\n\nvoid trace(inout state S){\n    \n    float dt;\n    \n      //iteratively step through rk4\n    for(int n=0;n<350;n++){\n\n        //setting some sort of adaptive dt\n        dt=setDT(S);\n\n        //do a step of rk4\n        //euler(S,dt);\n        rk4(S,dt);\n        \n        //if you hit the event horizon, stop.\n        if(length(S.pos-bhPos)<2.*M){\n            eventHorizon=true;\n            break;\n    }\n        \n        //if you pass the back plane stop\n        if(S.pos.z<-49.5){break;} \n    }\n    \n}\n\n\n\nvec4 gridlines(state S,float size){\n    float x=mod(S.pos.x/size+iTime/2.,2.);\n    float y=mod(S.pos.y/size,2.);\n    vec3 color;\n  \n    \n    color=vec3(1.);\n    \n     float mag=clamp(10./(50.*x*(2.-x)*y*(2.-y)),0.,10.);\n    \n    color*=mag;\n        \n\n  \n    return vec4(color,1.);\n}\n\n\nvec4 checkerboard(state S,float size){\n    float x=mod(S.pos.x/size+iTime/2.,2.);\n    float y=mod(S.pos.y/size,2.);\n    vec3 color;\n    \n    \n    //if you hit the plane in front of us\n    if(S.dir.z<0.){\n    \n    color=vec3(0.);\n    if(y<1.&&x<1.||y>1.&&x>1.)\n    {color=vec3(1.);}\n        \n    }\n    \n    \n        //if you turn around and hit the plane behind us!\n    if(S.dir.z>0.){\n    \n    color=vec3(0.,0.,0.);\n    if(y<1.&&x<1.||y>1.&&x>1.)\n    {color=vec3(1,0,0);}\n        \n    }\n//rescale color brightness by distance along xy plane (ie the z component of direction):\n   // color*=clamp(abs(2.*S.dir.z),0.,1.);\n    \n    \n    return vec4(color,1.);\n}\n\n\nvec4 sphGrid(state S){\n    vec3 color=vec3(166./255.,24./255.,2./255.);;\n    float numGrids=30.;\n    \n    float theta=atan(S.dir.z,S.dir.x)+iTime/40.;\n    float phi=acos(S.dir.y);\n    \n    float x=mod(numGrids*theta/6.28,2.);\n    float y=mod(numGrids*phi/6.28,2.);\n\n    \n    float mag=clamp(10./(50.*x*(2.-x)*y*(2.-y)),0.,10.);\n    \n    color*=mag;\n    \n    \n    //if instead you want a checkerboard:\n    color=vec3(0.);\n    if(y<1.&&x<1.||y>1.&&x>1.){color=vec3(1.);}\n\n\n  \n    return vec4(color,1.);\n}\n\n\n\nvec4 cylGrid(state S){\n    vec3 color=vec3(166./255.,24./255.,2./255.);;\n    float numGrids=20.;\n    \n    float theta=atan(S.dir.z,S.dir.x)+iTime/20.;\n   float z=acos(S.dir.y);\n    \n    float x=mod(numGrids*theta/6.28,2.);\n    float y=mod(numGrids*z/6.28,2.);\n\n    \n  //if instead you want a checkerboard:\n    color=vec3(0.);\n    if(y<1.&&x<1.||y>1.&&x>1.){color=vec3(1.);}\n\n  \n    return vec4(color,1.);\n}\n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\n//intial starting location of your eye (should be along z axis).\nvec3 eyePosition(float time){\n    return vec3(0.,0.,10.);\n    //return vec3(15.*cos(time),0,30.*sin(time));\n}\n\n\nvec3 bhPosition(float time){\n    return vec3(15.*cos(time),0,30.*sin(time));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    eventHorizon=false;\n    \n    //set the initial state\n    vec3 dir = rayDirection(90.0, iResolution.xy, fragCoord);\n    vec3 eye = eyePosition(iTime);\n    state S=state(eye,dir);\n    \n    //set the black hole's mass:\n    M=3.;\n    \n    //set the black hole's position:\n    bhPos=bhPosition(iTime/2.);\n\n    //do the actual raytracing\n    trace(S);\n    if(eventHorizon){\n       fragColor=vec4(0.);\n       return;\n    }\n    \n    //else, make the color\n    vec4 color;\n       // color=sphGrid(S);}\n        color=checkerboard(S,8.);\n         // color=cylGrid(S);\n\n   \n    \n    fragColor = color;\n}","name":"Image","description":"","type":"image"}]}