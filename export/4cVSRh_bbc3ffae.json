{"ver":"0.1","info":{"id":"4cVSRh","date":"1714791878","viewed":50,"name":"Geometrical inversions","username":"ageron","description":"Each point p is mapped to p * r^2 / |p|^2\nThis means that any straight line turns into a circle that goes through O.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["geometry"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float axesThickness = 0.005;\nconst float pointRadius = 0.02;\nconst float radius = 0.3;\nconst float circleThickness = 0.005;\n\nfloat sdfCircle(vec2 uv, vec2 center, float radius)\n{\n    return length(center - uv) - radius;\n}\n\nfloat sdfPoint(vec2 uv, vec2 point)\n{\n    return sdfCircle(uv, point, pointRadius);\n}\n\n\nfloat sdfAxes(vec2 p)\n{\n    vec2 absp = abs(p);\n    return min(absp.x, absp.y) - axesThickness;\n}\n\nconst int N = 200;\n\nvoid makeLine(inout vec2[N] points) {\n    float x = -4.0;\n    float d = -2. * x / float(N);\n    for (int i = 0; i < N; i++) {\n        x += d;\n        points[i] = vec2(x, 0.2 * x - 0.2);\n    }\n}\n\nvoid makeSquare(inout vec2[N] points) {\n    vec3 square = vec3(0.05, 0.1, 0.7); \n    float x = 0.;\n    float d = 4. * square.z / float(N);\n    for (int i = 0; i < N / 4; i++) {\n        x += d;\n        points[4 * i] = vec2(square.x + x, square.y);\n        points[4 * i + 1] = vec2(square.x + x, square.y + square.z);\n        points[4 * i + 2] = vec2(square.x, square.y + x);\n        points[4 * i + 3] = vec2(square.x + square.z, square.y + x);\n    }\n}\n\n\nvec2 invertPoint(vec2 point) {\n    float l = length(point);\n    float k = radius / l;\n    return point * k * k;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy; // Screen coord to [0,1) range.\n    uv = uv * 2.0 - 1.0;                     // To [-1, 1) range.\n    uv.x *= iResolution.x / iResolution.y;   // Fix aspect ratio.\n\n    vec2 points[N];\n    makeLine(points);\n    //makeSquare(points);\n\n\n    // Output to screen\n    float d = sdfAxes(uv);\n    if (d < 0.) {\n        fragColor = vec4(0., 0., 0., 1.0);\n        return;\n    }\n\n    d = abs(sdfCircle(uv, vec2(0.), radius)) - circleThickness;\n    if (d < 0.) {\n        fragColor = vec4(0.8, 0., 0., 1.0);\n        return;\n    }\n\n    //d *= step(0., abs(sdfCircle(uv, vec2(0.), radius)) - circleThickness);\n    float t = clamp((cos(iTime / 2.0) / 2.0 + 0.5) * 1.1 - 0.05, 0., 1.);\n    for (int i = 0; i < N; i++) {\n        vec2 invertedPoint = invertPoint(points[i]);\n        vec2 interpolated = mix(points[i], invertedPoint, t);\n        d *= step(0., sdfPoint(uv, interpolated));\n    }\n    d = sign(d);\n    fragColor = vec4(1. - d, 1., 1., 1.0);\n}","name":"Image","description":"","type":"image"}]}