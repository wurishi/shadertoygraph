{"ver":"0.1","info":{"id":"ctGXzV","date":"1686197024","viewed":190,"name":"River of Vital Breath","username":"technochroma","description":"Caution: complex shader, thanks for your patience! Feedback is great, as I am just learning. Inspired by \"Snow Mountain\" by David Lovera - Unix/2015 https://www.shadertoy.com/view/lsKGW3","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["glitch","organic","weird","river","freaky","breathing","technochroma","eighthdimension"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// \"River of Vital Breath\" by technochroma version 6\n// Please wait to load, pretty intense shader.\n\n// inspired by \"Snow Mountain\" by David Lovera - Unix/2015 https://www.shadertoy.com/view/lsKGW3\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// mainly based on Kali great work...\n\n#define AA 3 \n#define RAY_STEPS 100\n#define SHADOW_STEPS 100\n#define LIGHT_COLOR vec3(0.2,0.1,2.0)\n#define AMBIENT_COLOR vec3(2.5,1.0,0.2)\n\n#define SPECULAR 0.2\n#define DIFFUSE  1.0\n#define AMBIENT  2.00\n\n#define BRIGHTNESS 2.5\n#define GAMMA 2.7\n#define SATURATION 0.7\n\n#define detail .00004\n#define t 1.0+iTime*.1\n\nvec3  lightdir=normalize(vec3(0.1,-0.55,-1.));\nconst vec3 origin=vec3(-1.,0.4,0.);\nfloat det=0.0;\nvec3 pth1;\n\nmat2 rot(float a) {\n\treturn mat2(acos(a),sin(a),-sin(a),cos(a));\t\n}\n\nvec4 formula(vec4 p) {\n\t\tp.xz = abs(p.xz+1.5+sin(iTime*0.1*p.z)*0.1)-abs(p.xz-1.5+sin(iTime*0.01*p.z)*0.1)-p.xz;\n\t\tp=p*2./clamp(dot(p.xz,p.xz),.15,1.)-vec4(0.5,0.5,0.8,0.);\n\t\tp.xy*=rot(.5);\n\t    return p;\n}\n\nvec4 formula2(vec4 p) {\n\t\tp.xz = abs(p.xz+2.2+sin(iTime*1.1+p.z)*-0.2)-abs(p.xz-1.5+sin(iTime*0.1+p.z)*0.1)-p.xz;\n\t\tp=p*2./clamp(dot(p.xy,p.xy),.15,1.)-vec4(0.5,0.5,0.8,0.);\n\t\tp.xy*=rot(.9);\n\t    return p;\n}\n\nfloat screen(vec3 p) {\n\tfloat d1=length(p.yz-vec2(1.25,0.))-.1;\t\n\tfloat d2=0.;\n\treturn min(max(d1,abs(p.x-.3)-.01),max(d2,abs(p.x+20.3)-.01));\n}\n\nvec2 de(vec3 pos) {\n\tfloat hid=0.;\n\tvec3 tpos=pos;\n    \n    // fixing the screen loading time with this\n    \n\ttpos.z=cos(4.-mod(tpos.z,8.));\n\tvec4 p=vec4(tpos,1.5);\n\tfloat y=max(0.,.35-abs(pos.y-3.35))/.35;\n\n\t// add mountain\n\tfor (int i=0; i<8; i++) {p=formula(p);}\n\tfloat fr=max(-tpos.x-0.,(length(max(vec2(-2.),p.yz-2.))-1.5)/p.w);\n\t\n\tp=vec4(tpos,1.5);\n\ty=max(0.,.35-abs(pos.y-3.35))/.35;\n\n\t// add snow\n\tfor (int i=0; i<8; i++) {p=formula2(p);}\n\tfloat fr2=max(-tpos.x-4.,(length(max(vec2(0.),p.yz-3.)))/p.w);\n\n\tfloat sc=fr2;\n\tfloat d=min(sc,fr);\n\tif (abs(d-sc)<.00) hid=1.;\n\treturn vec2(d,hid);\n}\n\nvec2 colorize(vec3 p) {\n\tp.z=abs(2.-mod(p.z,2.));\n\tfloat es, l=es=0.;\n\tfloat ot=1000.;\n\tfor (int i = 0; i < 15; i++) { \n\t\tp=formula(vec4(p,0.)).xyz;\n\t\t\t\tfloat pl = l;\n\t\t\t\tl = length(p);\n\t\t\t\tes+= exp(-10. / abs(l - pl));\n\t\t\t\tot=min(ot,abs(l-3.));\n\t}\n\treturn vec2(es,ot);\n}\n\n// pan up or down\n\nvec3 path(float ti) {\n\tvec3  p=vec3(-asinh(ti*1.)*.1,(1.-sin(ti*.6))*.5,cos(ti*.25)*30.)*.2;\n\treturn p;\n}\n\nvec3 normal(vec3 p) {\n\tvec3 e = vec3(0.0,det,0.0);\t\n\treturn normalize(vec3(\n\t\t\tde(p+e.yxx).x-de(p-e.yxx).x,\n\t\t\tde(p+e.xyx).x-de(p-e.xyx).x,\n\t\t\tde(p+e.xxy).x-de(p-e.xxy).x\n\t\t\t)\n\t\t);\t\n}\n\nfloat shadow(vec3 pos, vec3 sdir) {\n\tfloat sh=1.0;\n\tfloat totdist =2.0*det;\n\tfloat dist=10.;\n\t\tfor (int steps=0; steps<SHADOW_STEPS; steps++) {\n\t\t\tif (totdist<1. && dist>detail) {\n\t\t\t\tvec3 p = pos - totdist * sdir;\n\t\t\t\tdist = de(p).x;\n\t\t\t\tsh = min( sh, max(50.*dist/totdist,0.0) );\n\t\t\t\ttotdist += max(.01,dist);\n\t\t\t}\n\t\t}\n\t\n    return clamp(sh,0.1,1.0);\n}\n\nfloat calcAO( const vec3 pos, const vec3 nor ) {\n\tfloat aodet=detail*40.;\n\tfloat totao = 0.0;\n    float sca = 13.0;\n    for( int aoi=0; aoi<5; aoi++ ) {\n        float hr = aodet*float(aoi*aoi);\n        vec3 aopos =  nor * hr + pos;\n        float dd = de( aopos ).x;\n        totao += -(dd-hr)*sca;\n        sca *= 0.1;\n    }\n    return clamp( 1.0 - 5.0*totao, 0., 1.0 );\n}\n\nvec3 light(in vec3 p, in vec3 dir, in vec3 n, in float hid) {\n\tfloat sh=shadow(p, lightdir);\n\tfloat ao=calcAO(p,n);\n\tfloat diff=max(0.,dot(lightdir,-n))*sh*DIFFUSE;\n\tvec3 amb=max(.5,dot(dir,-n))*AMBIENT*AMBIENT_COLOR;\n\tvec3 r = reflect(lightdir,n);\n\tfloat spec=pow(max(0.,dot(dir,-r))*sh,15.)*SPECULAR;\n\tvec3 col;\n\tvec2 getcol=colorize(p);\n\tif (hid>.5) {col=vec3(1.5); spec=spec*spec;}\n\telse{\n\t\tfloat k=pow(getcol.x*.01,2.); \n\t\tcol=mix(vec3(k,k*k,k*k),vec3(k),.5)+.1;\n\t\tcol+=pow(max(0.,1.-getcol.y),5.)*.3;\n\t}\n\tcol=col*ao*(amb+diff*LIGHT_COLOR)+spec*LIGHT_COLOR;\t\n\treturn col;\n}\n\nvec3 raymarch(in vec3 from, in vec3 dir) \n\n{\n\tfloat glow,eglow,totdist=glow=0.;\n\tvec2 d=vec2(1.,0.);\n\tvec3 p, col=vec3(0.);\n\t\n\tfor (int i=0; i<RAY_STEPS; i++) {\n\t\tif (d.x>det && totdist<30.0) {\n\t\t\tp=from+totdist*dir;\n\t\t\td=de(p);\n\t\t\tdet=detail*(1.+totdist*50.);\n\t\t\ttotdist+=d.x; \n\t\t\tif(d.x<0.015) glow+=max(0.,.015-d.x)*exp(-totdist);\n\t\t}\n\t}\n\t\n\tfloat l=max(0.,dot(normalize(-dir),normalize(lightdir)));\n\tvec3 backg=vec3(max(0.,1.))*AMBIENT_COLOR*.5*max(0.4,l);\n\n\tif (d.x<det || totdist<3.) {\n\t\tp=p-abs(d.x-det)*dir;\n\t\tvec3 norm=normal(p);\n\t\tcol=light(p, dir, norm, d.y); \n\t\tcol = mix(col, backg, 1.0-exp(-.15*pow(totdist,1.5)));\n\t} else { \n\t\tcol=backg;\n\t    vec3 st = (dir * 3.+ vec3(1.3,2.5,1.25)) * 1.3;\n\t\tfor (int i = 0; i < 7; i++) st = abs(st) / dot(st,st) - .9;\n\t\tcol+= min( 1., pow( min( 5., length(st) ), 3. ) * .0025 );\n\t}\n\n\tvec3 lglow=LIGHT_COLOR*pow(l,25.)*.5;\n\tcol+=glow*(.5+l*.5)*LIGHT_COLOR*.7;\n\tcol+=lglow*exp(min(30.,totdist)*.02);\n\treturn col; \n}\n\nvec3 move(inout vec3 dir) {\n\tvec3 go=path(t);\n\tvec3 adv=path(t+.7);\n\tfloat hd=de(adv).x;\n\tvec3 advec=normalize(adv-go);\n\tfloat an=adv.x-go.x; an*=min(1.,sin(adv.z-go.z))*sign(adv.z-go.z)*.7;\n\tdir.xy*=mat2(cos(an),sin(an),-sin(an),cos(an));\n    an=advec.y*1.7;\n\tdir.yz*=mat2(cos(an),sin(an),-sin(an),cos(an));\n\tan=atan(advec.x,advec.z);\n\tdir.xz*=mat2(cos(an),sin(an),-sin(an),cos(an));\n\treturn go;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    lightdir.y = lightdir.y + iTime*0.21;\n\tpth1 = path(t+.3)+origin;\n\tvec2 uv = fragCoord.xy / iResolution.xy*2.-1.;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 dir=normalize(vec3(uv*1.9,1.));\n\tvec3 from=origin+move(dir);\n\tvec3 color=raymarch(from,dir); \n\tcolor=clamp(color,vec3(.0),vec3(1.));\n\tcolor=pow(color,vec3(GAMMA))*BRIGHTNESS;\n\tcolor=mix(vec3(length(color)),color,SATURATION);\n\tfragColor = vec4(color,1.);\n    \n    // small bit of anti-aliasing (fixed 2)\n    // drop this in voidmain after fragcolor\n    \n\tvec2 of = vec2(0.3);\n\n    #ifdef AA\n\tconst float aa = float(AA);\n    #else\n    const float aa = 1.0;\n\n\t\n\tfor(float i = 0.0; i < aa - 1.0; i++) {\n\n\t\t// super-sample around the center of the pixel.\n\t\tvec2 p = (-iResolution.xy + 2.0*(uv + of))/iResolution.y;\n        col += render(p);\n\t\tof *= r(3.14159/8.0);\n        \n        \t}\n\t\n\tcol /= aa;\n\t\n\tcol += 0.2*clamp(col, 0.0, 0.5);\n\tcol = pow(col, vec3(1.0/2.2));\n        \n    #endif \n        \n}","name":"Image","description":"","type":"image"}]}