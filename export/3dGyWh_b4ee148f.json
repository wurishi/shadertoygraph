{"ver":"0.1","info":{"id":"3dGyWh","date":"1602648873","viewed":77,"name":"Parallax cubes","username":"jsharifi","description":"Cubes which have been given parallax translations.\nBased on https://www.shadertoy.com/view/XsyXWV (camargo) with some stub code from https://www.shadertoy.com/view/Xds3zN (iq).","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","cube","parallax","iq","camargo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// code primarily from https://www.shadertoy.com/view/XsyXWV\n// Author: Chris Camargo\n\n\n// First Raymarch - Cubes\n// Chris Camargo, June 2016\n\n// Distance function for box.\nfloat box(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n\n    return min(max(d.x,max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n// from https://www.shadertoy.com/view/Xds3zN\n// THE Inigo Quilez\nfloat sdBoundingBox( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n// from https://www.shadertoy.com/view/Xds3zN\n// THE Inigo Quilez\nfloat sdEllipsoid( vec3 p, vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n// Repeater distance function for box.\nfloat rep(vec3 p, vec3 c)\n{\n    vec3 q = mod(p, c) - 0.5 * c;\n    return box(q, vec3(0.5, 0.5, 0.5));\n}\n\n// Raymarch, computing the distance at each step and incrementing the\n// ray parameter t.\nfloat trace(vec3 o, vec3 r)\n{\n    float t = 0.0;\n    for (int i = 0; i < 32; ++i) {\n        vec3 p = o + r * t;\n\n        // Distance function.\n        float d = rep(p, vec3(2.0, 3.0, 2.0));\n\n        t += d;\n    }\n    return t;\n}\n\n// Image computation.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float x = fragCoord.x;            // Current pixel x-coordinate. Range: [0.5, iResolution.x - 0.5].\n    float y = fragCoord.y;            // Current pixel y-coordinate. Range: [0.5, iResolution.y - 0.5].\n    float minX = 0.5;                 // Min x-coordinate value.\n    float minY = 0.5;                 // Min y-coordinate value.\n    float maxX = iResolution.x - 0.5; // Viewport width.\n    float maxY = iResolution.y - 0.5; // Viewport height.\n\n    // Feature Scaling. Bring coords to value between [0, 1].\n    // https://en.wikipedia.org/wiki/Feature_scaling#Rescaling\n    vec2 uv = vec2((x - minX) / (maxX - minX), (y - minY) / (maxY - minY));\n\n    // Coords between [0, 1] so 'eye' is centered at (0.5, 0.5).\n    // We want 'eye' centered at (0, 0). Thus subtract 0.5 from\n    // each coord.\n    uv -= 0.5;\n\n    // Move coords away from 'eye' by a factor of 2.0.\n    // You can play with this number.\n    uv *= 2.0;\n    \n    // Scale x based on aspect ratio.\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // translate in x\n    float xtranslate = cos(iTime) * 2.0;\n    const float positionK = 0.5;\n    const float parallaxK = 0.5;\n    // origin is a-function-of-translation\n    // Ray origin.\n    vec3 o = vec3(xtranslate * positionK, 0.0, 0.0);\n\n    // view direction scales linearly with the opposite of translation\n    // Ray direction.\n    vec3 r = normalize(vec3(uv.x - xtranslate * parallaxK, uv.y, 1.0));\n\n    r = normalize(r);\n    \n    // Rotate direction r around y-axis by a fraction of time.\n    // float theta = iTime * 0.25;\n    // r.xz *= mat2(cos(theta), -sin(theta), sin(theta), cos(theta));\n    \n    // Trace ray from origin o in direction r.\n    float t = trace(o, r);\n    float t2 = trace(o + vec3(0.01, 0.0, 0.0), r - vec3(0.01, 0.0, 0.0));\n    \n    // compute marginal derivative. $t is distance\n    float dtdx = (t - t2) / 0.001;\n    \n    // dampen the force field glows\n    float g = 0.05 * dtdx;\n    \n    // Set the color via 1 / (1. + t): Light attenuation.\n    // lerp in an occasional dark tint to gb values\n    float forceFieldMode = cos(iTime * 2.0) * 0.1 + 0.9;\n    vec3 color = vec3(0.5 * (1.0 - forceFieldMode), +0.01 * g + forceFieldMode / (1. + t), -0.01 * g + forceFieldMode / (1. + t));\n    \n    // Set pixel color.\n    fragColor =  vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}