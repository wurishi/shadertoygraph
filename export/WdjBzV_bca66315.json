{"ver":"0.1","info":{"id":"WdjBzV","date":"1590559586","viewed":187,"name":"Animated cat on quad with camera","username":"kylesimpson","description":"Left mouse to move camera left/right/up/down. The camera always faces the cat.\n\nI made this to learn.\n\n1. Project a quad onto the screen with a perspective view.\n2. Determine texture coordinates for pixels in the quad's 2 triangles.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["raycasting","texture","animation","perspective","quad"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 quadTexture(vec2 uv) {\n    return texture(iChannel1, uv);\n}\n\nvec2 rotate(vec2 pos, float angle) {\n \tfloat oldAngle = atan(pos.y, pos.x);\n    float newAngle = oldAngle + angle;\n    float dist = length(pos);\n    return vec2(\n        dist * cos(newAngle),\n        dist * sin(newAngle));\n}\n\nvec3 rotateY(vec3 pos, float angle) {\n    vec2 r = rotate(pos.zx, angle);\n    return vec3(r.y, pos.y, r.x);\n}\n\nvec3 rotateX(vec3 pos, float angle) {\n    vec2 r = rotate(pos.yz, angle);\n    return vec3(pos.x, r.xy);\n}\n\nvec3 rotateZ(vec3 pos, float angle) {\n    vec2 r = rotate(pos.xy, angle);\n    return vec3(r.xy, pos.z);\n}\n\nvec2 project(vec2 a, vec2 b) {\n \tfloat angle = atan(b.y, b.x) - atan(a.y, a.x);\n    return length(a) * cos(angle) * normalize(b);\n}\n\n// Intersects if pixel is \"to the right\" of lines (A, B), (B, C) and (C, A)\nbool inTriangle(vec2 p, vec2 A, vec2 B, vec2 C) {\n    bool ab = cross(vec3(p - A, 0.0), vec3(B - A, 0.0)).z >= 0.0;\n    bool bc = cross(vec3(p - B, 0.0), vec3(C - B, 0.0)).z >= 0.0;\n    bool ca = cross(vec3(p - C, 0.0), vec3(A - C, 0.0)).z >= 0.0;\n\n    return ab && bc && ca;\n}\n\nbool inPoint(vec2 p, vec2 vertex, float radius) {\n    return length(p - vertex) < radius;\n}\n\n// Cast a ray from the camera at the origin through the pixel p and find where it intersects the plane\n// defined by triangle ABC\n// https://en.wikipedia.org/wiki/Line%E2%80%93plane_intersection\nbool planeIntersection(vec2 p, vec3 A, vec3 B, vec3 C, out vec3 result) {\n    // line from the camera towards p is:\n    // P = (0, 0, 0) + d * (p.x, p.y, 1)\n    // where d is any scalar\n    \n    // (P - origin) dot n = 0\n    // origin = A\n    // n = plane normal = AB X AC\n\n    //     ((0, 0, 0) - A) dot n\n    // d = ---------------------\n    //      (p.x, p.y, 1) dot n\n    \n    vec3 lineOrigin = vec3(0.0, 0.0, 0.0);\n    vec3 lineDir = normalize(vec3(p, -1.0));\n    vec3 planeNormal = normalize(cross((B - A), (C - A)));\n    float denom = dot(lineDir, planeNormal);\n    \n    if (denom == 0.0) {\n     \t// line and plane are parallel. 0 or infinite intersection points.\n        result = vec3(0.0);\n        return false;\n    } else {\n        float d = dot(A - lineOrigin, planeNormal) / denom;\n        result = lineDir * d;\n     \treturn true;\n    }\n}\n\n// Maps p to coordinates within triangle ABC. uv at A = (0, 0), at B = (1, 0), at C = (0, 1)\nvec2 triangleUv(vec2 p, vec3 A, vec3 B, vec3 C) {\n    \n    vec3 uv;\n    if (planeIntersection(p, A, B, C, uv)) {\n     \tp = uv.xy;\n    } else {\n     \treturn vec2(0.0, 0.0);   \n    }\n        \n    vec2 AB = B.xy - A.xy;\n    vec2 AC = C.xy - A.xy;\n\tvec2 Ap = p - A.xy;\n    \n    vec2 AB90 = rotate(AB, radians(90.0));\n    \n    vec2 ACProjOnAB90 = project(AC, AB90);\n    vec2 ApProjOnAB90 = project(Ap, AB90);\n\n    vec2 skewedC = A.xy + ACProjOnAB90;\n    vec2 skewedP = p + length(ApProjOnAB90) / length(ACProjOnAB90) * (skewedC - C.xy);\n        \n    float u = length(project(skewedP - A.xy, AB.xy)) / length(AB.xy);\n    float v = length(ApProjOnAB90) / length(ACProjOnAB90);\n    \n    return vec2(u, v);\n}\n\nvec4 triangleCol(vec2 p, vec3 A, vec3 B, vec3 C, vec2 uvA, vec2 uvB, vec2 uvC) {\n    vec2 coords = triangleUv(p, A, B, C);\n\n    float contribB = coords.x;\n    float contribC = coords.y;\n    float contribA = 1.0 - contribB - contribC;\n    \n    vec2 uv = (uvA * contribA + uvB * contribB + uvC * contribC);\n\n    return quadTexture(uv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pMouse = (iMouse.xy - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    vec3 quadPos = vec3(0.0, 0.0, 0.0);\n    vec2 quadSize = vec2(0.4);\n    vec3 quadTopLeft = vec3(quadPos.x - quadSize.x / 2.0, quadPos.y + quadSize.y / 2.0, quadPos.z);\n    vec3 quadTopRight = vec3(quadPos.xy + quadSize.xy / 2.0, quadPos.z);\n    vec3 quadBottomLeft = vec3(quadPos.xy - quadSize / 2.0, quadPos.z);\n    vec3 quadBottomRight = vec3(quadPos.x + quadSize.x / 2.0, quadPos.y - quadSize.y / 2.0, quadPos.z);\n\n    vec3 A = quadTopLeft;\n    vec3 B = quadTopRight;\n    vec3 C = quadBottomLeft;\n    vec3 D = quadBottomRight;\n\n    // Texture coordinates\n    float imageIndex = floor(fract(iTime) * 6.0);\n    \n    vec2 uvLow = vec2(40.0 * imageIndex / 256.0, 0.0);\n    vec2 uvHigh = vec2(40.0 * (imageIndex + 1.0) / 256.0, 1.0);\n    vec2 uvA = vec2(uvLow.x, uvHigh.y);\n    vec2 uvB = uvHigh;\n    vec2 uvC = uvLow;\n    vec2 uvD = vec2(uvHigh.x, uvLow.y);\n\n    vec3 cam = vec3(0.0, 0.0, 0.3);\n    vec3 target = vec3(0.0, 0.0, 0.0);\n\n    if (iMouse.w == 0.0) {\n        // Default value\n        cam.xy = vec2(-0.6, 0.3);\n    } else {\n    \tcam.xy = pMouse.xy * 2.0;\n    }\n\n    vec3 minusZ = vec3(0.0, 0.0, -1.0);\n\n    vec3 forward = normalize(vec3(target - cam));\n    float rotY = -(atan(forward.x, forward.z) - atan(minusZ.x, minusZ.z));\n    forward = rotateY(forward, rotY);\n    float rotX = -(atan(forward.z, forward.y) - atan(minusZ.z, minusZ.y));\n\n    // translate to camera\n    A -= cam;\n    B -= cam;\n    C -= cam;\n    D -= cam;\n        \n    // rotate about Y axis (left/right)\n    A = rotateY(A, rotY);\n    B = rotateY(B, rotY);\n    C = rotateY(C, rotY);\n    D = rotateY(D, rotY);\n\n    // rotate about X axis (up/down)\n\tA = rotateX(A, rotX);\n    B = rotateX(B, rotX);\n    C = rotateX(C, rotX);\n    D = rotateX(D, rotX);\n    \n    // project onto camera\n    float fov = radians(30.0);\n    float fovRatio = 1.0 / sin(fov);\n\n    A *= fovRatio;\n    B *= fovRatio;\n    C *= fovRatio;\n    D *= fovRatio;\n\n    vec2 screenA = A.xy / -A.z;\n    vec2 screenB = B.xy / -B.z;\n    vec2 screenC = C.xy / -C.z;\n    vec2 screenD = D.xy / -D.z;\n\n    vec3 col = mix(vec3(1.0), vec3(uv, 1.0), 0.6);\n\n    bool drawTri1 = true;\n    bool drawTri2 = true;\n    \n    if (drawTri1 && inTriangle(p, screenA, screenB, screenC)) {\n        vec4 triCol = triangleCol(p, A, B, C, uvA, uvB, uvC);\n\t\tcol = mix(col, triCol.xyz, triCol.a);\n    }    \n    \n    else if (drawTri2 && inTriangle(p, screenB, screenD, screenC)) {\n        vec4 triCol = triangleCol(p, B, D, C, uvB, uvD, uvC);\n\t\tcol = mix(col, triCol.xyz, triCol.a);\n    }\n    \n    bool drawVertexPoints = true;\n    if (drawVertexPoints) {\n\t    float pointSize = 0.02;\n        if (inPoint(p, screenA, pointSize)) {\n            col = vec3(0.0);   \n        }\n        if (inPoint(p, screenB, pointSize)) {\n            col = vec3(1.0, 0.0, 0.0);   \n        }\n        if (inPoint(p, screenC, pointSize)) {\n            col = vec3(0.0, 1.1, 0.0);   \n        }\n        if (inPoint(p, screenD, pointSize)) {\n            col = vec3(0.0, 0.0, 1.0);   \n        }\n    }\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = vec3(uv, uv.x + uv.y) * 1.0 + 0.0;\n    \n    if (uv.x <= 1.0 / 200.0) {\n        col = vec3(1.0, 0.0, 0.0);\n    }\n    if (uv.y <= 1.0 / 200.0) {\n        col = vec3(0.0, 1.0, 0.0);\n    }\n\n    if (uv.x >= 199.0 / 200.0) {\n        col = vec3(0.0, 0.0, 1.0);\n    }\n    if (uv.y >= 199.0 / 200.0) {\n        col = vec3(0.0, 0.0, 0.0);\n    }\n    \n    float n = 10.0;\n    if (length(mod(uv, 1.0 / n) - (1.0 / n) * 0.5) < 0.5 * 1.0 / n) {\n        col = 1.0 - col;\n    }\n\n    fragColor = vec4(col, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}