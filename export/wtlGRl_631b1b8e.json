{"ver":"0.1","info":{"id":"wtlGRl","date":"1557435091","viewed":484,"name":"Acid Egyptians","username":"polymonster","description":"I just needed something animated with different colours quickly so I could implement animated area lights in my engine: https://github.com/polymonster/pmtech","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["pyramids"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define pi 3.14\n#define MOD2 vec2(3.07965, 7.4235)\n\nfloat hash( float p )\n{\n\tvec2 p2 = fract(vec2(p) / MOD2);\n    p2 += dot(p2.yx, p2.xy+19.19);\n\treturn fract(p2.x * p2.y);\n}\n\nfloat hash(vec2 p)\n{\n\tp  = fract(p / MOD2);\n    p += dot(p.xy, p.yx+19.19);\n    return fract(p.x * p.y);\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0;\n    float res = mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n    return res;\n}\n\nmat3 create_camera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = cross(cu,cw);\n    \n    return mat3( cu, cv, cw );\n}\n\nfloat sd_sphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sd_box( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sd_octahedron(vec3 p, float s ) \n{\n    p = abs(p);\n    return (p.x + p.y + p.z - s)*0.57735027;\n}\n\nfloat bsin(float v)\n{\n    return sin(v) * 0.5 + 1.0;\n}\n\nfloat bcos(float v)\n{\n    return cos(v) * 0.5 + 1.0;\n}\n\nfloat op_union( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat map(vec3 p)\n{\n\tfloat scale = 10.0;\n    float rep = 2.0;\n    float pyr_rep = 300.0;\n    \n    float y = noise(p.xz / 20.0) * 8.0;\n    \n    vec3 q = mod(p - vec3(0.0, y, 0.0), vec3(rep, 0.0, rep)) - 0.5 * rep;\n    vec3 b = mod(p / vec3(1.0, 10.0, 1.0), vec3(0.0, 0.0, 200.0)) - 0.5 * vec3(0.0, 0.0, 200.0);\n    vec3 c = mod(p, vec3(0.0, 0.0, pyr_rep)) - 0.5 * vec3(0.0, 0.0, pyr_rep);\n    \n \tfloat terrain = sd_box(q - vec3(0.0, 5.0, 0.0), vec3(2.5));\n    float pillars_left = sd_box(b - vec3(40.0, 0.0, 0.0), vec3(10.0));\n    float pillars_right = sd_box(b - vec3(-40.0, 0.0, 0.0), vec3(10.0));\n    float pyramids_left = sd_octahedron(c - vec3(-400.0, 0.0, 0.0), 100.0);\n    float pyramids_right = sd_octahedron(c - vec3(400.0, 0.0, 0.0), 100.0);\n    \n    float res = op_union(terrain, pillars_left);\n    res = op_union(res, pillars_right);\n    res = op_union(res, pyramids_left);\n    res = op_union(res, pyramids_right);\n        \n    return res;\n}\n\nvec3 sky(vec3 v)\n{\n    vec3 grad_a = vec3(0.5, 0.5, 0.0);\n    vec3 grad_b = vec3(0.5, 0.0, 1.0);\n    \n    grad_a = vec3(bcos(iTime), 0.2, bcos(-iTime));\n    grad_b = vec3(bsin(iTime), bsin(-iTime), 0.2);\n    \n    float grad_t = v.y * 0.5 + 0.5;\n    \n    return mix(grad_b, grad_a, grad_t);\n}\n\nvec3 calc_normal(in vec3 pos)\n{\n    vec3 eps = vec3(0.001, 0.0, 0.0);\n    vec3 nor;\n    \n    nor.x = map(pos+eps.xyy) - map(pos-eps.xyy);\n    nor.y = map(pos+eps.yxy) - map(pos-eps.yxy);\n    nor.z = map(pos+eps.yyx) - map(pos-eps.yyx);\n    \n    return normalize(nor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float eps = 0.005;\n    \n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 15.0 + iTime;\n    \n    float yp = 20.0 + bsin(iTime) * 20.0;\n    float xp = -0.0;\n    float zp = -10.0 + iTime * 50.0;\n\n    vec3 ro = vec3(xp, yp, zp);\n    \n    vec3 ta = vec3( xp, yp, zp + 10.0);\n    mat3 cam = create_camera( ro, ta, 0.0 );\n        \n    vec3 col = vec3(0.0, 0.0, 0.0);\n    \n\tvec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;  \n    \n    vec3 rd = cam * normalize( vec3(p.xy,2.0) );\n    \n    float d = 10.0;\n    float xt = 0.0;\n    vec3 pp = ro;\n   \n    vec3 l = normalize(vec3(0.0, 1.0, 1.0));\n    \n    for(float t = 0.0; t < 200.0; ++t)\n    {\n        pp = ro + rd * xt;\n        \n        vec3 qq = pp;\n        d = map(qq);\n        \n        if(d < eps)\n            break;\n        \n        xt += d;\n    }\n    \n    vec3 n = calc_normal(pp);\n    \n    float nv = dot(n, -rd);\n    \n    vec3 csky = sky(rd);\n    vec3 lsky = sky(-rd);\n    \n    vec3 ir = vec3(1.0, 0.0, 0.0) * lsky;\n    vec3 ig = vec3(0.0, 1.0, 0.0) * lsky;\n    vec3 ib = vec3(0.0, 0.0, 1.0) * lsky;\n\n    col += sin(nv * ig * 10.0 * 1.5) * 0.5 + 0.5;  \n    col += sin(nv * ir * 20.0 * 1.5) * 0.5 + 0.5;  \n    col += sin(nv * ib * 5.0 * 1.5) * 0.5 + 0.5;\n    col = clamp(normalize(col), 0.0, 1.0);\n    \n    float mask = step(d, eps);\n    float inv_mask = 1.0 - mask;\n    \n    fragColor = vec4(csky * inv_mask + col * mask, 1.0);\n}","name":"Image","description":"","type":"image"}]}