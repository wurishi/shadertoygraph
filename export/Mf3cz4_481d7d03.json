{"ver":"0.1","info":{"id":"Mf3cz4","date":"1730983363","viewed":346,"name":"Shortest Path Erosion","username":"TekF","description":"FULLSCREEN RECOMMENDED!\n\nTrying out an erosion idea based on a couple of youtube videos I saw (see comments in code)","likes":33,"published":3,"flags":32,"usePreview":1,"tags":["raymarching","terrain","generative","realistic","erosion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fake Erosion - by Hazel Quantock\n// Generate erosion-like features by finding shortest path between points\n// Surface colours follow the direction of erosion\n\n// Terrain generation based on https://www.youtube.com/watch?v=7RqJewZK0SE by Cartesian Caramel\n// And colouring based on https://www.youtube.com/watch?v=XIwikUOOw7I by Samuel Krug\n\n\nconst float scale = 1.;\nfloat height = 2.; // modified later\n\nvec2 PosToUV( vec3 p )\n{\n    return p.xz*vec2(iResolution.y/iResolution.x,1)/scale+.5;\n}\n\nfloat SDF( vec3 p )\n{\n    // the terrain generator doesn't make vertical things\n    // so I can use the map as an SDF\n    \n    vec2 uv = PosToUV(p);\n    \n    float h = texture(iChannel0,uv).w*scale*height;\n\n    vec2 bounds = abs(p.xz) - .5*scale*vec2(iResolution.x/iResolution.y,1);\n\n    return max(\n            (p.y-h) * .3 // reduce this number to reduce glitches on steep slopes\n            , max(bounds.x,bounds.y));\n}\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n// debug\n//    fragColour = texelFetch(iChannel0,ivec2(fragCoord),0); fragColour.rgb *= step(.1,fract(fragColour.a*.1)); return;\n\n\n    height /= iResolution.y;\n\n    vec3 ray = vec3((fragCoord-iResolution.xy*.5)/length(iResolution.xy),1.);\n    ray = normalize(ray);\n    \n    float tt = iTime;\n    vec3 cam = cos(vec3(tt*.09,tt*.13,tt*.07+.1)) * vec3(2,.6,2) * scale;\n    cam.y += 1.;\n    cam.y = max( cam.y, .1);\n    \n    vec3 k = normalize(vec3(0,.3*height*scale,0)-cam);\n    vec3 i = cross(vec3(0,1,0),k);\n    vec3 j = cross(k,i);\n    ray = ray.x*i+ray.y*j+ray.z*k;\n    \n    vec3 pos = cam;\n    float t = 0.;\n    for ( int i=0; i < 200; i++ )\n    {\n        float h = SDF(ray*t+pos);\n        t += h;\n        if ( h < .0001 || t > 10. ) break;\n    }\n    \n    pos += ray*t;\n    \n    if ( t > 10. || pos.y < -.05 )\n    {\n        // sky\n        fragColour.rgb = vec3(1);\n        return;\n    }\n    \n    // shading\n    vec2 d = vec2(1,-1)*.4*scale/iResolution.y; // sample at texel size [and in 2D - actually the y cancels this is 2D already]\n    vec3 normal = normalize(\n        SDF(pos+d.xxx)*d.xxx +\n        SDF(pos+d.yyx)*d.yyx +\n        SDF(pos+d.yxy)*d.yxy +\n        SDF(pos+d.xyy)*d.xyy\n    );\n    \n    vec3 albedo = texture(iChannel0,PosToUV(pos)).rgb;\n    \n    if ( normal.y < .2 ) albedo = vec3(.04); // sides and base\n\n    vec3 ambientlight = vec3(.4,.55,1) * .7;\n    ambientlight *= clamp( min( SDF(pos+normal*.3)/.3, SDF(pos+normal*.6)/.6 ), 0., 1. );\n\n    vec3 sundir = normalize(normalize(cam*vec3(-1,0,-1))+vec3(.1,.3,0));//vec3(-2,4,-3));\n    vec3 suncol = 1.4*vec3(1,.95,.9);\n    vec3 diffuselight = suncol*max(0.,dot( normal.xyz, sundir ));\n    vec3 specularlight = suncol*pow(max(0.,dot(normalize(sundir-ray),normal)),100.)*.07;\n\n    fragColour.rgb = albedo*(diffuselight + ambientlight) + specularlight;\n    \n    fragColour.rgb = pow(fragColour.rgb,vec3(1./2.2));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float colourErosion = 0.3; // > 0 and < 1\n\nvec3 SampleColour( vec2 fragCoord )\n{\n    return texture(iChannel2,fragCoord/iResolution.y).rgb;\n}\n\n// cost function influences which path is shortest, determining the shape of the mountains\nfloat Cost( vec2 uv )\n{\n    const float bias = .5; // higher = slope away from the river, lower = flatter\n\n    // detail strengths & frequencies\n    const float bigAmp = .75;\n    const float midAmp = .2;\n    const float lilAmp = .05;\n    \n    const float bigFrq = 1.;\n    const float midFrq = 5.;\n    const float lilFrq = 25.;\n    \n    return bias\n        +(texture(iChannel3,bigFrq*uv/iResolution.x).g-.5)*bigAmp\n        +(texture(iChannel3,midFrq*uv/iResolution.x).g-.5)*midAmp\n        +(texture(iChannel3,lilFrq*uv/iResolution.x).g-.5)*lilAmp;\n}\n\n// compute total cost of path from uv+stp to uv, based on cost stored at uv+stp\nvoid TotalCost( inout vec4 lowest, inout vec4 highest, in vec4 current, in ivec2 uv, in ivec2 stp )\n{\n    uv += stp;\n    if ( uv.x < 0 || uv.y < 0 || uv.x >= int(iResolution.x) || uv.y >= int(iResolution.y) )\n        return;\n\n    vec4 t = texelFetch(iChannel0,uv,0);\n    if ( t.w < 0. ) return; // no data\n\n    float edgeLength = length(vec2(stp));\n\n    // colour erosion - blend colours from higher neighbours\n    float weight = (t.w-current.w)/edgeLength; // slope\n    if ( weight > 0.\n           && (uv.x > 0 || uv.y > 0 ) ) // ignore data pixel\n    {\n        highest += vec4(t.rgb*weight, weight);\n    }\n    \n    // compute cost of the step from sample pixel to target pixel\n    float edgeCost = Cost( vec2(uv)-vec2(stp)*.5 );\n    t.w += edgeCost*edgeLength;\n    \n    if ( t.w < lowest.w ) lowest = t;\n}\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    if ( iChannelResolution[3].x <= 0. ) return;\n\n    // detect resolution changes by storing resolution at (0,0)\n    bool reset = any( notEqual( texelFetch(iChannel0,ivec2(0),0).xyz, iResolution ) );\n    bool isDataPixel = ( fragCoord.x < 1. && fragCoord.y < 1. );\n\n    if ( reset )\n    {\n        fragColour = vec4(-1);\n        \n        // starting shape, some points at height 0\n        //if ( fragCoord.x < 1. || fragCoord.y < 1. || fragCoord.x > iResolution.x-2. || fragCoord.y > iResolution.y-2. )\n        //if ( length(fragCoord-iResolution.xy*.5) < 1. )\n        if ( abs(fragCoord.x/iResolution.x-.5-.3*sin(1.+3.*fragCoord.y/iResolution.y)) < .005 )\n        {\n            fragColour = vec4(0);\n        }\n        \n        // store iresolution in top right pixel, so I can detect resolution changes etc\n        if (isDataPixel) fragColour.xyz = iResolution;\n        \n        return;\n    }\n    \n    \n    \n    fragColour = texelFetch(iChannel0,ivec2(fragCoord),0);\n    \n    // measure cost*distance, plus score of those pixels, to any adjacent scored pixels\n    ivec3 d = ivec3(-1,0,1);\n\n    vec4 lowestNeighbour = vec4(0,0,0,1e38);  //ignored xyz,totalcost\n    vec4 highestNeighbour = vec4(0,0,0,0);  //colour,weight\n    TotalCost(lowestNeighbour,highestNeighbour,fragColour,ivec2(fragCoord),d.xx);\n    TotalCost(lowestNeighbour,highestNeighbour,fragColour,ivec2(fragCoord),d.yx);\n    TotalCost(lowestNeighbour,highestNeighbour,fragColour,ivec2(fragCoord),d.zx);\n    TotalCost(lowestNeighbour,highestNeighbour,fragColour,ivec2(fragCoord),d.xy);\n    TotalCost(lowestNeighbour,highestNeighbour,fragColour,ivec2(fragCoord),d.zy);\n    TotalCost(lowestNeighbour,highestNeighbour,fragColour,ivec2(fragCoord),d.xz);\n    TotalCost(lowestNeighbour,highestNeighbour,fragColour,ivec2(fragCoord),d.yz);\n    TotalCost(lowestNeighbour,highestNeighbour,fragColour,ivec2(fragCoord),d.zz);\n\n    if ( lowestNeighbour.w < 1e37 &&\n        ( lowestNeighbour.w < fragColour.w || fragColour.w < 0. ) )\n    {\n        fragColour.w = lowestNeighbour.w;\n    }\n\n    if ( !isDataPixel )\n    {\n        if ( highestNeighbour.w > 0. )\n        {\n            float erosiveness = 50.*highestNeighbour.w;\n\n            // modify the influence of this point based on the distance between samples, ie the resolution\n            // not sure about the correct maths here, I tuned it until it looked pretty consistent between resolutions\n            erosiveness *= pow(iResolution.y/2560.,3.);\n            erosiveness = mix( erosiveness, 360./iResolution.y, .5 ); // prevent 0 erosion\n\n//                float erosiveness = 360./iResolution.y;\n\n            highestNeighbour.rgb /= highestNeighbour.w;\n            fragColour.rgb = mix( fragColour.rgb, highestNeighbour.rgb,\n                pow(colourErosion,1./erosiveness) );\n            fragColour.rgb = mix( fragColour.rgb, SampleColour(fragCoord), .01 );\n        }\n        else\n        {\n            fragColour.rgb = texture(iChannel2,fragCoord/iResolution.y).rgb;\n        }\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"}]}