{"ver":"0.1","info":{"id":"Wsj3RK","date":"1549370102","viewed":209,"name":"Voronoi-05-ST","username":"teraspora","description":"Yet another take on Voronoi Shading!","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","grid","tiling","distancemetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\nVoronoi Shading, another approach, single pass\nBy John Lynch\nFebruary 2019\n\n*/\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nvec4 img;\n\n#define PI 3.1415922653589793234\n#define PHI 1.6180339887 \n#define SQ2 1.4142135623\n\n\nconst float HALF = 0.5;\nconst float HALF_PI = 1.5707963267948966;\nconst float TWO_PI = 6.283185307;\n\n// Gold Noise Â©2015 dcerisano@standard3d.com\nfloat gold_noise(in vec2 coord, in float seed) {\n    return fract(tan(distance(coord * (seed + PHI), vec2(PHI, PI))) * SQ2);\n}\n\nconst vec3 white =      vec3(1.,   1.,   1.  );\nconst vec3 black =      vec3(0.,   0.,   0.  );\nconst vec3 cyan =       vec3(0.0,  1.,   0.84);\nconst vec3 magenta =    vec3(1.0,  0.,   1.0 );\nconst vec3 blue =       vec3(0.0,  0.6,  0.84);\nconst vec3 gold =       vec3(0.89, 0.84, 0.66);\nconst vec3 orange =     vec3(1.0,  0.2,  0.0 );\nconst vec3 yellow =     vec3(1.0,  0.9,  0.0 );\nconst vec3 dark_blue =  vec3(0.0,  0.02, 0.38);\nconst vec3 crimson =    vec3(0.76, 0.0,  0.42);\nconst vec3 green =      vec3(0.1,  0.5,  0.25);\nconst vec3 rich_blue =  vec3(0.0,  0.55, 1.0 );\n    \nvec3[] cols = vec3[](gold, cyan, rich_blue, crimson, blue, orange, yellow, dark_blue, magenta, green);\nint cl = cols.length();\nvec3 col;\nfloat tileIndex;\nfloat t;\nfloat tile;\nfloat toe;\nfloat scale;\nvec2 uv;\nfloat tileDim;\n\nvec3 getCol(float nf) {\n    return cols[int(mod(nf, float(cl)))];\n}\n\n// Some functions adapted from Github - \n// https://github.com/tobspr/GLSL-Color-Spaces/blob/master/ColorSpaces.inc.glsl\n// - not tested!\n\nvec3 hue2rgb(float hue)\n{\n    float R = abs(hue * 6. - 3.) - 1.;\n    float G = 2. - abs(hue * 6. - 2.);\n    float B = 2. - abs(hue * 6. - 4.);\n    return clamp(vec3(R,G,B), 0., 1.);\n}\n\n// Converts a value from linear RGB to HCV (Hue, Chroma, Value)\nvec3 rgb2hcv(vec3 rgb) {\n    // Based on work by Sam Hocevar and Emil Persson\n    vec4 P = (rgb.g < rgb.b) ? vec4(rgb.bg, -1.0, 2.0/3.0) : vec4(rgb.gb, 0.0, -1.0/3.0);\n    vec4 Q = (rgb.r < P.x) ? vec4(P.xyw, rgb.r) : vec4(rgb.r, P.yzx);\n    float C = Q.x - min(Q.w, Q.y);\n    float H = abs((Q.w - Q.y) / (6. * C + 1.e-10) + Q.z);\n    return vec3(H, C, Q.x);\n}\n\n// Converts from HSL to linear RGB\nvec3 hsl2rgb(vec3 hsl) {\n    vec3 rgb = hue2rgb(hsl.x);\n    float C = (1. - abs(2. * hsl.z - 1.)) * hsl.y;\n    return (rgb - 0.5) * C + hsl.z;\n}\n\n// Converts from linear rgb to HSL\nvec3 rgb2hsl(vec3 rgb) {\n    vec3 HCV = rgb2hcv(rgb);\n    float L = HCV.z - HCV.y * 0.5;\n    float S = HCV.y / (1. - abs(L * 2. - 1.) + 1.e-10);\n    return vec3(HCV.x, S, L);\n}\n\n// My own functions:\n\nfloat hue(vec3 col) {\n    return rgb2hsl(col).s;\n}\n\nvec3 changeHue(vec3 col, float newHue) {\n    vec3 colHSL = rgb2hsl(col);\n    colHSL.s = newHue;\n    return hsl2rgb(colHSL);\n}\n\nvec3 invert(vec3 col) {\n    return 1. - clamp(col, 0., 1.);   \n}\n\nfloat om(float x) {\n    return 1. - x;\n}\n\nvec3 om(vec3 v) {\n    return 1. - v;\n}\n\nfloat op(float x) {\n    return 1. + x;\n}\n\nfloat nsin(float x) {\n    return op(sin(x)) * 0.5;\n}\n\nfloat ncos(float x) {\n    return op(cos(x)) * 0.5;\n}\n\nfloat arg(vec2 z) {\n    return atan(z.y, z.x);\n}\n\nvec2 polar(float r, float phi) {\n    return vec2(r * cos(phi), r * sin(phi));\n}\n\nvec2 times(vec2 v, vec2 w) {\n    return vec2(v.x * w.x - v.y * w.y, v.x * w.y + v.y * w.x);\n}\n\nvec2 rotate(vec2 v, float phi) {\n    return times(v, polar(1.0, phi)) ;\n}\nvec2 nmouse() {\n    return iMouse.xy / iResolution.xy;\n}\n\nfloat minkd(vec2 u, vec2 v, float order) {  // Minkowski distance\n    if (order <= 0.) return 0.;\n    return abs(pow(abs(pow(v.x - u.x, order)) + abs(pow(v.y - u.y, order)), 1. / order)); \n}\n\nfloat minkl(vec2 v, float order) {  // Minkowski length\n    if (order <= 0.) return 0.;\n    return abs(pow(abs(pow(v.x, order)) + abs(pow(v.y, order)), 1. / order)); \n}\n\nfloat measure(vec2 u, vec2 v, float order, int alt) {  // Minkowski distance or...\n    if (alt == 0) return minkd(u, v, order);\n    // else do something weird!\n    else return 0.5 * abs(minkd(u, v, 1.) + minkd(u, v, 2.)); \n}\n\nvec3 saturate(vec3 col) {\n    vec3 colHSL = rgb2hsl(col);\n    colHSL.t = 1.0;\n    return hsl2rgb(colHSL);    \n}\n\nvec2 ffract(vec2 v) {\n    // flavour of fract() to handle negative numbers \n    return vec2(v.x >= 0. ? fract(v.x) : 1. - fract(v.x), v.y >= 0. ? fract(v.y) : 1. - fract(v.y));\n}\n\n// from IQ:\n// vec2 rand2( vec2 p ) {\n//    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n// }\n\nvec3 drawBorder(vec3 col, float b, vec3 insetColour, vec3 outsetColour, vec2 pp, vec2 hr, float tileIndex) {\n    // `b` is the border width\n    // `col` is the input (and output) colour\n    // `pp` is (unnormalised) coordinate of pixel\n    // `hr` is (unnormalised) resolution\n    // Make a border: `b` px solid black; with `insetColour` inset:\n    if (tileIndex != -1.) {\n        //  any special code for single-pane use goes here    \n    }\n     // Now put a black border on top:\n    col *= step(b, pp.x);\n    col *= step(b, pp.y);\n    col *= (1. - step(hr.x - b, pp.x));\n    col *= (1. - step(hr.y - b, pp.y));\n    // Make a line inset:\n    if ((pp.x >= b - 2. && pp.x <= b + 2.) || (pp.x > hr.x - b - 1. && pp.x < hr.x - b + 1.)) col = insetColour;\n    if ((pp.y >= b - 2. && pp.y <= b + 2.) || (pp.y > hr.y - b - 1. && pp.y < hr.y - b + 1.)) col = insetColour;\n    if ((pp.x >= 0. && pp.x <= 1.) || (pp.x >= hr.x - 1. && pp.x <= hr.x)) col = outsetColour;\n    if ((pp.y >= 0. && pp.y <= 1.) || (pp.y >= hr.y - 1. && pp.y <= hr.y)) col = outsetColour;\n   return col;\n}\n\n// MAIN METHOD:\n\nvec3 doStuff(vec2 pixel, vec2 res) {\n    // just takes a pixel and a context and outputs a\n    // colour to mainImage, which keeps things organised\n    // and encapsulated.\n        \n    // Set this var to the number of tiles across and down:\n    tileDim = 3.;\n    float numTiles = tileDim * tileDim;\n        \n    // the output vector, before normalisation,\n    // giving the position the program needs to know!-\n    vec2 pp = pixel;\n    vec2 hr = res / tileDim;    // resolution of one tile   \n\n    // Normalisation and tiling:\n\n    // Make numTiles sub-frames:\n    vec2 n = vec2(float(int(pp.x / res.x * tileDim)), float(int(pp.y / res.y * tileDim)));\n    tile = numTiles - (n.y * tileDim + n.x);\n    tile = numTiles - tile + 1.;\n    if (tile == 2. || tile == 3.) tile = 5. - tile;\n    toe = fract(tile / 2.) * 4. - 1.; // returns 1. if tile index odd, -1. if even;\n    float tile2 = tile * tile;\n    t = mod(iTime + 37. * tile, 300.);\n    \n    // shift back to the first tile if in any other tile:\n    pp.x -= hr.x * n.x;\n    pp.y -= hr.y * n.y;\n    // normalise to [0, 1[, shift to make unit quad with origin in centre\n    uv = pp / hr - 0.5;     // normalise\n    // rotate the frame\n    float level = mod(iTime, 30.);\n    uv = rotate(uv, TWO_PI * 0.2 * toe * iTime / 64. * (1. + nsin(tile * 5.)));\n    \n    scale =  1.0; // 0.1 + 6. * nmouse().x;\n    uv /= scale;\n    // Main code for the shader goes here:\n    // Of the 9 distances from our pt. to the special points of the 3x3 subgrid centred on the block in \n    // which current pixel is to be found, get the two smallest.\n    // If they are nearly equal, i.e our pt. is equidistant from its two nearest neighbours, then we're on\n    // aboundary, so draw it black (having previously coloured based on min. distances):\n    float grid = tile + 2.;\n    vec2 uvx = uv * grid;\n    vec2 id = floor(uvx);\n    vec2 pq = ffract(uvx);\n    vec2 apos;\n    float dist;\n    float d1 = 9998.;   // some big numbers for initial minima\n    float d2 = 9999.;\n    vec2 idNearest;\n    for (float j = id.y - 1.; j <= id.y + 1.; j++) {\n        for (float i = id.x - 1.; i <= id.x + 1.; i++) {\n            vec2 idCurrent = vec2(i, j);\n            // vec2 rpos = rand2(idCurrent + tile);\n            vec2 rpos = vec2(gold_noise(idCurrent, tile),\n                             gold_noise(idCurrent.yx, 1. / tile));\n            rpos = 0.5 + 0.5 * sin(t + 64. * rpos);\n            apos = idCurrent + rpos;\n            dist = measure(uvx, apos, 2., 1);\n            if (dist < d1) {\n                d2 = d1;\n                d1 = dist;\n                idNearest = idCurrent;\n            }\n            else if (dist < d2) {\n                d2 = dist;\n            }\n        }\n    }\n    vec2 nidn = idNearest + grid / 2.0;\n    col = getCol(nidn.x + grid * nidn.y);\n    col.rb *= pow(d2 - d1, 0.25);\n    col.g *= d2 * d2 - d1 * d1;\n    \n    col *= smoothstep(0.0, 0.05, d2 - d1);\n    vec2 st = uv + 0.5;\n    \n    // Border code:  \n    \n    float borderWidth = 2.;\n    vec3 borderInsetLineColour = white;\n    vec3 borderOutsetLineColour = white;\n    \n    col = drawBorder(col, borderWidth, borderInsetLineColour, borderOutsetLineColour, pp, hr, tile);\n\n    // finally return the colour to caller(mainImage()):     \n    return col;\n}   // END doStuff()\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {   \n    float asp = iResolution.x / iResolution.y;\n    bool centreTexture = false;\n    bool outerTexture = true;\n    // MUTABLE PARAMETERS:\n    float blackThreshold = 2.5; // 0.5 + 2. * nmouse().y; // 1.1; // Best between 1.0 and 1.3\n    float borderWidth = 5.;\n    vec3 borderInsetLineColour = white;\n    vec3 borderOutsetLineColour = white;\n    vec3 col = doStuff(fragCoord, iResolution.xy);\n    col *= step(0., blackThreshold - length(col));\n    \n    col = saturate(col);\n    \n    float cdelta = mod(t / 2., tile * 7.) / (tile * 7.);\n    col = changeHue(col, fract(hue(col) + toe * cdelta));     \n    if (tileDim == 1.) col = drawBorder(col, borderWidth, borderInsetLineColour, borderOutsetLineColour, fragCoord, iResolution.xy, -1.);\n    // finally return the colour:\n    fragColor = vec4(col, 1.0);        \n}    ","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}","name":"Common","description":"","type":"common"}]}