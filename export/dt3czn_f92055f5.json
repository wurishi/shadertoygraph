{"ver":"0.1","info":{"id":"dt3czn","date":"1699411460","viewed":53,"name":"Rolling ball with number8","username":"zma","description":"My first raytracer. ","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sphere","roll"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592653\n\nfloat square(float a){\n    return a*a;\n}\n\n\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\nvec3 font_tex (sampler2D t, vec2 tpos) {\n\n    vec2 pos = vec2(7.5, 3.5);\n    \n    float k =1. - texture(t, (tpos-pos)/16.).r;\n    float c =1. - step(.4, length(tpos));\n        \n    return vec3(k*c);\n    \n}\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n){ \n    \n    n = max(abs(n) - .0, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n);\n    \n    // Texure samples. One for each plane.\n   \n    vec3 tx = font_tex(t, p.xy).xyz;\n    vec3 ty = font_tex(t, p.yz).xyz;\n    vec3 tz = font_tex(t, p.xz).xyz;\n    \n    return mat3(tx*tx, tx*tx, tx*tx)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n\n\nfloat sphsoftshadow(vec3 ro, vec3 rd, in vec4 sph, float k)\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w*sph.w;\n    float h = b*b - c;\n    \n    return b>0.? step(-0.0001, c) : smoothstep(0., 1., h*k/b);\n\n}\nfloat sphocclusion(in vec3 pos,in vec3 norm,in vec4 sph){\n    vec3 r = pos - sph.xyz;\n    float l = length(r);\n    return dot(r, norm)*(sph.w*sph.w)/(l*l*l);\n\n}\n\nvec2 boxIntersection( in vec3 ro, in vec3 rd, vec3 boxSize, out vec3 outNormal ) \n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    outNormal = (tN>0.0) ? step(vec3(tN),t1) : step(t2,vec3(tF));  // ro inside the box\n    outNormal *= -sign(rd);\n    return vec2( tN, tF );\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv0 = fragCoord.xy/iResolution.xy;\n    vec2 uv = (2.0*fragCoord.xy-iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0., 2., -4.);\n    vec3 rd = normalize(vec3(uv, 1.));\n    vec3 groundcolor = vec3(0., 0.5, 0.);\n    vec3 offset = vec3(0., 0.4, 0.);\n    float t = iTime;\n    float ct = cos(t);\n    float st = sin(t);\n    \n    mat2 rotate2 = mat2(ct, -st, st, ct);\n    vec3 lig = normalize(vec3(0.5, 0.5, -0.5));\n    vec3 m = 1.5*vec3(-ct, 0., -st); \n    vec4 sph = vec4(0., .6, 0., .5) + vec4(m, 0.);\n    vec3 norm;\n    vec3 pos;\n    vec3 col = vec3(0.);\n    float occ = 1.;\n  \n    \n    vec3 size = vec3(4., 0.1, 2.);\n    float r = 0.1;\n    \n    vec3 backgroundcolor = (1. - uv.y)*vec3(0., 0., 0.5);\n    \n    //t1:distance factor of plane and origin\n    \n    vec2 t1 = boxIntersection(ro, rd, size, norm);\n    float tmin = 1e10;\n    if(t1.x > 0.){\n        tmin = t1.x;\n        norm = vec3(0., 1., 0);\n        pos = ro + tmin*rd;\n        \n        col = groundcolor;\n        col *= sphsoftshadow(pos, lig, sph, 2.);\n        occ = 1. - sphocclusion(pos, norm, sph);  //plane ambient occlusion\n        col += 0.15*occ*groundcolor ;\n        \n       \n    }\n    vec2 sphDepth = sphIntersect(ro, rd, sph.xyz, sph.w);\n    float t2 = sphDepth.x;\n    if(t2 > 0. && t2 < tmin){\n        tmin = t2;\n        pos = ro + tmin*rd;\n        norm = (pos - sph.xyz);\n        vec3 bnorm = (ro + sphDepth.y * rd - sph.xyz); \n        \n        vec3 tpos = norm;\n        vec3 btpos = bnorm;\n        \n        tpos.zx *= mat2(ct, -st, st, ct);\n        tpos.yz *= mat2(ct, -st, st, ct);       \n        btpos.zx *= mat2(ct, -st, st, ct);\n        btpos.yz *= mat2(ct, -st, st, ct);       \n        \n        float spec =pow(dot(reflect(lig, 2.*norm), normalize(pos - ro)), 32.);\n        \n        vec3 specular = vec3(spec);\n        vec3 ambient = tex3D(iChannel0, 2.*tpos, norm); \n        \n        \n        //col *= ambient.xyz*2. + .2;\n        col = max(ambient, specular);\n        col *= clamp(dot(norm, lig), 0., 1.);\n                \n        occ = 0.5 + 0.5*norm.y;\n        col += occ*ambient;\n              \n    }\n    else if (t1.x<0.) col = backgroundcolor;\n    \n    col = 0.78*sqrt(col);  \n       \n    // Output to screen\n    fragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}