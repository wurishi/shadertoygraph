{"ver":"0.1","info":{"id":"fd3yzs","date":"1654107195","viewed":81,"name":"Squished Mandelbrot","username":"MisterSirCode","description":"I really dont know what I'm doing anymore. Just having fun with math\n\nCheck out my Simple Fractals playlist: [URL]https://www.shadertoy.com/playlist/NfSGW3[/URL]","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fractal","mandelbrot"],"hasliked":0,"parentid":"fscyzB","parentname":"11 Line Mandelbrot"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = ((2.0 * fragCoord - iResolution.xy) / iResolution.y) * 2.0;\n    vec2 z = vec2(0.0);\n    float l = 0.0;\n    for (l = 0.0; l < 100.0; l += 1.0) {\n        z = cross(z.xyx, z.yyy).xy - (cMul(z, z) + uv);\n        if(dot(z, z) > 65536.0) break;\n    }\n    l = l - log2(log2(dot(z,z))) + 4.0;\n    fragColor = vec4(vec3((l > 99.0) ? 0.0 : sin(l / 20.0)) * vec3(0.1, 1.0, 0.8), 1.0); // Samples - 1 check. Makes interior black\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec2 cConj(vec2 z) {\n  return vec2(z.x, -z.y);\n}\n\nfloat cNorm(vec2 z) {\n    return dot(z, z);\n}\n\nfloat cAbs(vec2 z) {\n    return length(z);\n}\n\nfloat cArg(vec2 a) {\n    return atan(a.y, a.x);\n}\n\nvec2 cSqr(vec2 z) {\n    return vec2(z.x * z.x - z.y * z.y, 2. * z.x * z.y);\n}\n\nvec2 cMul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\nvec2 cInverse(vec2 a) {\n    return vec2(a.x, -a.y) / dot(a, a);\n}\n\nvec2 cDiv(vec2 a, vec2 b) {\n    float d = dot(b, b);\n    return vec2(dot(a, b), a.y * b.x - a.x * b.y ) / d;\n}\n\nvec2 cSqrt(vec2 z) {\n    float m = length(z);\n    return sqrt(max(vec2(0.0), 0.5 * vec2(m + z.x, m - z.x))) * vec2(1.0, sign(z.y));\n}\n\nvec2 cExp(vec2 z) {\n    return exp(z.x) * vec2(cos(z.y), sin(z.y));\n}\n\nvec2 cLog(vec2 a) {\n    return vec2(log(cAbs(a)), cArg(a));\n}\n\nvec2 cPow(vec2 z, vec2 a) {\n    return cExp(cMul(cLog(z), a));\n}\n\nvec2 cPow(vec2 z, float a) {\n    return cExp(cLog(z) * a);\n}\n\nvec2 cSin(vec2 z) {\n    return vec2(sin(z.x) * cosh(z.y), cos(z.x) * sinh(z.y));\n}\n\nvec2 cCos(vec2 z) {\n    return vec2(cos(z.x) * cosh(z.y), -sin(z.x) * sinh(z.y));\n}\n\nvec2 cTan(vec2 z) {\n    return cDiv(cSin(z), cCos(z));\n}\n\nvec2 cSinh(vec2 z) {\n    return 0.5 * (cExp(z) - cExp(-z));\n}\n\nvec2 cCosh(vec2 z) {\n    return 0.5 * (cExp(z) + cExp(-z));\n}\n\nvec2 cTanh(vec2 z) {\n    return cDiv(cSinh(z), cCosh(z));\n}\n\nvec2 cAsin(vec2 z) {\n    const vec2 I = vec2(0.0, 1.0);\n    return cMul(-I, cLog(cMul(I, z) + cSqrt(1.0 - cSqr(z))));\n}\n\nvec2 cAcos(vec2 z) {\n    const vec2 I = vec2(0.0, 1.0);\n    return cMul(-I, cLog(z + cMul(I, cSqrt(1.0 - cSqr(z)))));\n}\n\nvec2 cAtan(vec2 z) {\n    const vec2 I = vec2(0.0, 1.0);\n    return cDiv(cLog(1.0 + cMul(I, z)) - cLog(1.0 - cMul(I, z)), 2.0 * I);\n}\n\nvec2 cAsinh(vec2 z) {\n    return cLog(z + cSqrt(cSqr(z) + 1.0));\n}\n\nvec2 cAcosh(vec2 z) {\n    return 2.0 * cLog(cSqrt(0.5 * (z + 1.0)) + cSqrt(0.5 * (z - 1.0)));\n}\n\nvec2 cAtanh(vec2 z) {\n    return 0.5 * (cLog((1.0 + z)) - cLog((1.0 - z)));\n}","name":"Common","description":"","type":"common"}]}