{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"struct sphere_t\n{\n\tvec3 pos;\n\tfloat rayon;\n};\n\t\nstruct plan_t\n{\n\tvec3 normale; // la normale au plan\n\tfloat d; //offset de l'Ã©quation\n};\n\t\nstruct surface_t\n{\n\tvec3 pos;\n\tvec3 normale;\n\tint id;\n};\n\t\nstruct ray_t\n{\n\tvec3 pos;\n\tvec3 direction;\n};\n\t\nfloat max_distance = 1e5; //distance par rapport Ã  la sphÃ¨re\n\nfloat intersectSphere( const in ray_t ray, const in sphere_t sphere)\n{\t\n\tfloat t,t1,t2;\n\tvec3 position = (ray.pos - sphere.pos);\n\tfloat a = pow(ray.direction.x, 2.0) + pow(ray.direction.y, 2.0) + pow(ray.direction.z, 2.0);\n\tfloat b = 2.0 *( (ray.direction.x*position.x) + (ray.direction.y*position.y) + (ray.direction.z*position.z) );\n\tfloat c = pow(position.x,2.0) + pow(position.x,2.0)+pow(position.z,2.0) - pow(sphere.rayon,2.0);\n\t\n\tfloat delta = pow(b,2.0) - (4.0 * a * c);\n\t\n\tif(delta > 0.0){\n\t\tt1 = ( - b + sqrt(delta)) / (2.0 * a);\n\t\tt2 = ( - b - sqrt(delta)) / (2.0 * a);\n\t\t\n\t\tif(t1 < t2){\n\t\t\tt = t1;\n\t\t}\n\t\telse{\n\t\t\tt =t2;\t\n\t\t}\n\t}\n\telse{\n\t\tt = max_distance;\t\n\t}\n\treturn t ;\n}\n\nfloat intersectPlan( const in ray_t ray, const in plan_t plan)\n{\t\n\tfloat t;\n\n\tfloat num = -plan.d - (plan.normale.x*ray.pos.x) - (plan.normale.y*ray.pos.y) - (plan.normale.z*ray.pos.z);\n\tfloat denom = (plan.normale.x*ray.direction.x)+(plan.normale.y*ray.direction.y)+(plan.normale.z*ray.direction.z);\n\tt =  num / denom ;\n\t\n\tif (t < 0.0){\n\t\tt=max_distance;\t\n\t}\n\treturn t;\n}\n\nfloat intersect(const in ray_t ray, out surface_t surface)\n{\n\tsphere_t sphere;\n\tsphere.pos = vec3(0.0,0.0,4.0);\n\tsphere.rayon = 1.0;\n\t\n\tplan_t plan;\n\tplan.normale = vec3(0.0, 0.9, 0.04);\n\tplan.d = 0.1;\n\t\n\tfloat distance_from_origin_Plan = intersectPlan(ray, plan);\n\tfloat distance_from_origin_Sphere = intersectSphere(ray, sphere);\n\t\n\tif (distance_from_origin_Plan < distance_from_origin_Sphere){\n\t\tsurface.id = 1; //1  = id de la plan\n\t\tsurface.pos = ray.pos + (distance_from_origin_Plan * ray.direction);\n\t\tsurface.normale = plan.normale;\n\t\t\n\t\treturn\tdistance_from_origin_Plan;\n\t}\n\telse{\n\t\tsurface.id = 2; //2 = id de la sphere\n\t\tsurface.pos = ray.pos + (distance_from_origin_Sphere * ray.direction);\n\t\tsurface.normale = normalize(surface.pos - sphere.pos);\n\t\t\n\t\treturn \tdistance_from_origin_Sphere;\n\t}\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 coordinate = fragCoord.xy / iResolution.xy;\n\tvec2 coordinate_entered = 2.0 * coordinate - 1.0;\n\t\n\tfloat coeffCorrection = (iResolution.x/iResolution.y);\n\t\n\tray_t camera_ray;\n\tsurface_t surface;\n\t\n\tcamera_ray.pos = vec3(0.0, 0.0, abs(3.0*sin(iTime)*1.0));\n\tcamera_ray.direction = vec3((coordinate_entered.x * coeffCorrection) , coordinate_entered.y, -1.0);\n\t\n\tfloat distance_from_origin = intersect(camera_ray, surface);\n\n\t\n\t\tif (distance_from_origin < max_distance){\n\t\t\tconst vec3 _color = vec3(0.4, 0.1, 0.3);\n\t\t\tfragColor = vec4 (surface.normale, 1.0);\n\t\t}\n\t\telse{\n\t\t\tconst vec3 background_color = vec3(0.9, 0.9, 0.9);\n\t\t\tfragColor = vec4 (background_color, 1.0);\n\t\t}\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldj3zc","date":"1392023057","viewed":140,"name":"Ray tracing 0","username":"MugiwaraLuffy","description":"Perpendicular Angle !!","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["perpendicularanglecode"],"hasliked":0,"parentid":"","parentname":""}}