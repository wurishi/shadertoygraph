{"ver":"0.1","info":{"id":"mtdBD2","date":"1701633750","viewed":37,"name":"Heavy snowfall","username":"xernobyl","description":"balls moving around and stuff. slightly buggy. Just trying to come up with some slightly randomized grid infinite objects kind of thing.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["ballsraymarhcing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define saturate(x) clamp(x, 0.0, 1.0)\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\n\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat sd_ball_grid(vec3 p) {\n    p.y += 1.0 * iTime;\n    \n    float s0 = 3.0; //1.2 - r;\n    vec3 center0 = round(p / s0) * s0;\n    float r0 = noise(center0); // 1.0 * noise(center);\n    \n    vec3 bias0 = (1.0 - r0) * sin(iTime) * s0 * vec3(\n        1.0 - 2.0 * noise(center0 * 1.0 + vec3(-0.5763457634, 12.534534, 5.65654)),\n        1.0 - 2.0 * noise(center0 * 1.0 + vec3(5.65654, -0.5763457634, 3.534534)),\n        1.0 - 2.0 * noise(center0 * 1.0 + vec3(-3.534534, 0.5763457634, -5.65654))\n    );\n    \n   vec3 p0 = p + bias0;\n    \n    p0 = p0 - s0 * round(p0 / s0);\n\n    return length(p0) - r0;\n}\n\n\nfloat sd_plane(vec3 p, vec3 n, float h) {\n  return dot(p, n) + h;\n}\n\n\nfloat scene(vec3 p) {\n    float f0 = sd_ball_grid(-p);\n    float f1 = sd_ball_grid(p + vec3(1.5));\n    \n    float f2 = opSmoothUnion(f0, f1, 1.0);\n    \n    // float d0 = length(p.xz) - 10.0;\n    // return max(d0, f2);\n    \n    \n    return min(f0, f1) + 0.25 * noise(2.0 * p);\n}\n\n\n\nvec3 scene_normal(vec3 p, float scale) {\n  float h = 0.001 * scale;\n  const vec2 k = vec2(1.0, -1.0);\n  return normalize(k.xyy * scene(p + k.xyy * h) + \n                   k.yyx * scene(p + k.yyx * h) + \n                   k.yxy * scene(p + k.yxy * h) + \n                   k.xxx * scene(p + k.xxx * h));\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(6.28318 * (c * t + d));\n}\n\nvec3 sRGB(vec3 linear) {\n  vec3 a = 12.92 * linear;\n  vec3 b = 1.055 * pow(linear, vec3(1.0 / 2.4)) - 0.055;\n  vec3 c = step(vec3(0.0031308), linear);\n  return mix(a, b, c);\n}\n\nvec3 sRGB(float linear) {\n  float a = 12.92 * linear;\n  float b = 1.055 * pow(linear, 1.0 / 2.4) - 0.055;\n  float c = step(0.0031308, linear);\n  return vec3(mix(a, b, c));\n}\n\nfloat min3(float a, float b, float c) {\n  return min(a, min(b, c));\n}\n\nfloat min4(float a, float b, float c, float d) {\n  return min(a, min(b, min(c, d)));\n}\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n  // camera movement\t\n  vec3 up = vec3(0.0, 1.0, 0.0);\n  vec3 ray_origin = vec3(15.0 * cos(0.125 * iTime), 5.0 + iTime, 15.0 * sin(0.125 * iTime)); // vec3(10.0 * cos(0.25 * iTime), 2.0 * sin(2.0 * iTime), 10.0 * sin(0.25 * iTime));\n  // vec3 ray_origin = vec3(10.0, 5.0, 10.0);\n  vec3 target = vec3(0.0, iTime, 0.0);\n\n  // camera matrix\n  vec3 cw = normalize(target - ray_origin);\n  vec3 cu = normalize(cross(cw, up));\n  vec3 cv = normalize(cross(cu, cw));\n  \n  int object = 0;\n  vec2 uv = (2.0 * frag_coord - iResolution.xy) / iResolution.y;\n  vec3 ray_dir = normalize(uv.x * cu + uv.y * cv + 1.5 * cw);\n  vec3 ray_pos = ray_origin;\n  float total_distance = 0.0;\n  const float max_dist = 1000.0;\n  \n  for (int it = 0; it < 128; ++it) {\n    float step_size = scene(ray_pos);\n    total_distance += step_size;\n    ray_pos = ray_origin + total_distance * ray_dir;\n    \n    if (step_size <= 0.001 * total_distance) {\n      object = 1;\n      break;\n    }\n    \n    if (total_distance >= max_dist) {\n      break;\n    }\n  }\n  \n  vec3 fog_color = vec3(0.5, 0.5, 0.5);\n  \n  if (object == 0) {\n    frag_color = vec4(sRGB(fog_color), 0.0);\n    return;\n  }\n  \n  vec3 n = scene_normal(ray_pos, total_distance);\n  float l = saturate(-dot(n, ray_dir)) + iTime;\n  \n  //vec3 color = n * 0.5 + 0.5;\n  vec3 color = vec3(saturate(dot(-n, ray_dir)));\n  \n  // color = palette(l, vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5), vec3(1.0, 1.0, 0.5), vec3(0.80, 0.90, 0.30));\n  color = mix(color, fog_color, saturate(total_distance * total_distance / 2048.0));\n  frag_color = vec4(sRGB(color), 0.0);\n}\n","name":"Image","description":"","type":"image"}]}