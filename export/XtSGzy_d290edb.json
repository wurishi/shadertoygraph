{"ver":"0.1","info":{"id":"XtSGzy","date":"1429802249","viewed":119,"name":"TestShaderDraz","username":"Drazatlam","description":"Test","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Rotation ------------------------------------------------------------\n \n// Rotation around y axis\n// v : Vector\n// a : Angle\nvec3 rotate(in vec3 v,in float a)\n{\n    return vec3(v.x*cos(a)+v.z*sin(a),v.y,-v.x*sin(a)+v.z*cos(a));\n}\n \n// Textures ------------------------------------------------------------\n \nconst vec3 red=vec3(0.4,0.137,0.047);\nconst vec3 pink=vec3(0.8,0.6,0.6);\nconst vec3 yellow=vec3(0.808,0.443,0.0549);\nconst vec3 fonce=vec3(0.141,0.117,0.078);\nconst vec3 clair=vec3(0.407,0.329,0.211);\nconst vec3 grey = vec3(0.5,0.5,0.5);\nconst vec3 grey2 = vec3(0.2,0.2,0.2);\nconst vec3 jaune = vec3(1.0,0.9,0.3);\nconst vec3 orange = vec3(0.958,0.3,0.0);\nconst vec3 orangeFonce = vec3(0.3,0.0,0.0);\nconst vec3 blanc = vec3(0.9,0.9,0.9);\nconst vec3 noir = vec3(0.1,0.1,0.1);\nconst vec3 tenebres = vec3(0.0,0.0,0.0);\n \nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\n \nfloat hash( float n ) { return fract(sin(n)*43758.5453123); }\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n// Simple color\n// p : Point on object\n// n : Normal at point\nvec3 color(in vec3 p,in vec3 n)\n{\n    return vec3(1,1,1);\n}\n \n\nfloat PerlinNoise3DABS(vec3 p,float alpha,float beta)\n{\n   float val,sum = 0.0;\n   float scale = 1.0;\n    \n   for (int i=0;i<5;i++) {\n      val = noise(p);\n            val = abs(val);\n      sum += val / scale;\n      scale *= alpha;\n      p *= beta;\n   }\n   return(sum);\n}\n\n\n\n\n// Checker\n// p : Point on object\n// n : Normal at point\nvec3 checker(in vec3 p,in vec3 n)\n{\n    //float v=mod(floor(p.x)+floor(p.y)+floor(p.z),2.0);\n    float f;\n     vec3 q = 8.0*p;\n    f  = 0.5000*noise( q ); q = m*q*2.01;\n    f += 0.2500*noise( q ); q = m*q*2.02;\n    f += 0.1250*noise( q ); q = m*q*2.03;\n    f += 0.0625*noise( q ); q = m*q*2.01;\n    return mix(red,yellow,f);\n    //return vec3(f,f,f);\n}\n\nvec3 rouille(in vec3 p,in vec3 n)\n    \n{\n    float f;\n    vec3 q = 8.0*p;\n    f  = 0.5000*noise( q ); q = m*q*2.01;\n    f += 0.2500*noise( q ); q = m*q*2.02;\n    f += 0.1250*noise( q ); q = m*q*2.03;\n    f += 0.0625*noise( q ); q = m*q*2.01;\n    float seuil=0.5;\n\tif(f > seuil)\n    {\n        return mix(red,yellow,(f-seuil)/(1.0-seuil));//checker(p+2,n+2);\n    }\n    else\n    {\n        return mix(grey2,grey,f/seuil);\n    }   \n}\n\nvec3 bois(in vec3 p,in vec3 n){\n    \n    float f;\n    vec3 q =1.2*m* p;\n    f  = 0.7*noise( q ); q = m*q*2.01;\n    f += 0.300*noise( q ); q = m*q*2.02;\n    //f += 0.100*noise( q ); q = m*q*2.02;\n    f/=(0.7+0.3);\n   // f += 0.1250*noise( q ); q = m*q*2.03;\n    //f += 0.1250*noise( q ); q = m*q*2.01;\n    float m =mod(10.0*(p.x+f*0.2),1.0);\n    //float m=(1.0+sin(30.0*(0.7*p.x+0.3*f)))/2.0;\n    return mix(clair,fonce,pow(m,1.5));\n}\n\nvec3 marbre(in vec3 p,in vec3 n){\n    float i=p.x,j=p.y;\n    float PN1;\n   \n   \tPN1=(1.0+cos(i*70.0+PerlinNoise3DABS(p,5.0,5.0)*200.0))/2.0;\n    return mix(blanc,noir,pow(PN1,3.0));\n        \n}\n\nvec3 trait(in vec3 p,in vec3 n){\n   \t\n float c= floor((1.0 + cos(p.x*5.0))/2.0*15.0);// floor(p.x*100.0);// - floor(1.0+p.y*12.0);\n float cy=(1.0 + sin(p.y*50.0))/2.0*15.0;\n float cz=0.0;\n     //floor(p.z*5.0);\n \n    if(mod(c+cy+cz,3.0)<1.0){\n     \treturn blanc;   \n    }\n    \n    if(mod(c+cy+cz,3.0)<2.0){\n     \treturn grey;   \n    }\n    \n    if(mod(c+cy+cz,3.0)<3.0){\n     \treturn noir;   \n    }\n return mix(grey,grey2,(c+cy+cz)/20.0);\n \n}\n\nvec3 lave(in vec3 p, in vec3 n, in float temperature) {\n\t\n    float seuil = temperature-0.8;\n    if(seuil == 0.0) {\n    \tseuil = 0.00001;   \n    }\n    float c;\n    vec3 q = p*10.0;\n    c = 0.7*noise(q);\n    c += 0.3*noise(2.0*q);\n    \n    if(c < seuil) {\n    \treturn mix(jaune*temperature, orange*temperature, pow(c/seuil,4.0));\n    }\n    else {\n    \treturn mix(orangeFonce, tenebres, (c-seuil)/(1.0-seuil));\n    }\n}\n\nvec3 granit(in vec3 p,in vec3 n){\n    \n     float f,g,h;\n     vec3 q = 100.0*p;\n    f  = 0.8*noise( q );\n    f  += 0.25*noise( 2.0*q );\n    f  += 0.125*noise( 4.0*q );\n    f/=(0.8+0.25+0.125);\n    q = m*q;\n     g  = 0.8*noise( q );\n    g  += 0.25*noise( 2.0*q );\n    g  += 0.125*noise( 4.0*q );\n    g/=(0.8+0.25+0.125);\n    q=m*q;\n     h  = 0.8*noise( q );\n    h  += 0.25*noise( 2.0*q );\n    h  += 0.125*noise( 4.0*q );\n    h/=(0.8+0.25+0.125);\n    //f += 0.2500*noise( q ); q = m*q*2.02;\n    //f += 0.1250*noise( q ); q = m*q*2.03;\n    //f += 0.1250*noise( q ); q = m*q*2.01;\n    \n    if(f>0.6){\n        return noir;\n    }\n    else{\n        if(g>0.6){\n       \t\t return grey;\n   \t\t}\n        else{\n        \tif(h>0.6){\n       \t\t return blanc;\n   \t\t}\n        else{\n        \treturn pink;\n        }\n        }\n        //return blanc;\n    }\n}\n \n// Color sine wave\nvec3 sine(in vec3 p,in vec3 n)\n{\n    vec3 pa=p-vec3(1.0,1.0,1.0);\n    float v=0.5*(1.0+cos(14.0*sqrt(dot(pa,pa))));\n    \n    \n        return mix(red,yellow,v);\n}\n\nbool inTruc(in vec3 p,in vec3 c, in float r){\n    \n    float dist = distance(p,c);\n    float f;\n    vec3 q = 0.5*p;\n    f  = 0.8*noise( q );\n    f  += 0.4*noise( 4.0*q );\n    f  += 0.2*noise( 8.0*q );\n    f  += 0.1*noise( 16.0*q );\n    f/=(0.8+0.4+0.2+0.1);\n    f  = f/dist/dist/dist/dist/dist/dist/dist/dist;\n    \n    return f>0.8;\n}\n \n// Objects --------------------------------------------------------------\n \n// Intersection between a ray and a sphere\n// o : Ray origin\n// d : Ray direction\n// c : Center of sphere\n// r : Radius\n// t : Intersection depth\n// n : Normal at intersection point\nbool sphere(in vec3 o,in vec3 d,in vec3 c,in float r,out float t,out vec3 n)\n{\n    vec3 oc = o-c;\n   \n    float b=dot(d,oc);\n    float k = dot(oc,oc)-r*r;\n    t=b*b-k;\n    float e = 0.001;\n    for(float i=0.0;i<10000.0;++i){\n        vec3 p =o+(e*i)*d;\n        if(inTruc(p,c,r)){\n            t=e*i;\n            return true;\n        }\n    }\n      \n    /*if (t<=0.0) return false;\n   \n    t=-b-sqrt(t);\n    if (t<0.0) return false;\n   \n    // Normal\n    n=(o+t*d-c)/r;*/\n \n   return false;\n}\n \n// Lighting -------------------------------------------------------------\n \n// Background color\n// r : Ray direction\nvec3 background(in vec3 r)\n{\n    return mix(vec3(0.2, 0.3, 0.4), vec3(0.7, 0.8, 1.0), r.y*0.5+0.5);\n}\n\nvec3 planet(in vec3 p){\n    float h =0.9;\n    if(distance(p,vec3(0.0,0.0,0.0))<h)\n        return vec3(0.0, 0.0, 1.0);\n    \n    else \n   \t\treturn mix(vec3(0.0, 1.0, 0.0),vec3(1.0, 0.0, 0.0),distance(p,vec3(0.0,0.0,0.0))-h);\n    \n}\n \n// p : Point on object\n// n : normal at point\nvec3 shade(in vec3 p,in vec3 n)\n{\n    // Point light\n    const vec3 lightPos = vec3(1.0, 1.0,-5.0);\n    const vec3 lightColor = vec3(0.95, 0.95,0.95);\n \n    vec3 l = normalize(lightPos - p);\n \n    // Not even Phong shading, use weighted cosine instead for smooth transitions\n    float diff = 0.5*(1.0+dot(n, l)*dot(n, l));\n \n    // Change call to Texture there : apply either color() or sine() or checker() or whatever texture you wish\n    vec3 c = planet(p)*diff*lightColor;//1.0*marbre(p,n)*\n \n    return c;\n}\n \n// Vignetting    \n// c : Color\n// p : Point in screen space\nvec4 Vignetting(in vec4 c,in vec2 p)\n{\n                return c * ( 0.5 + 0.5*pow( (p.x+1.0)*(p.y+1.0)*(p.x-1.0)*(p.y-1.0), 0.1 ) );\n}\n\n\n// Main -----------------------------------------------------------------\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = -1.0 + 2.0*fragCoord.xy/iResolution.xy;\n    vec2 uv = xy * vec2(iResolution.x/iResolution.y, 1.0);\n   \n                // Ray origin and direction\n    vec3 o = vec3(0.0, 0.0, -2.0);\n                vec3 d = normalize(vec3(uv, 1.0));\n               \n    o=rotate(o,0.5*iTime);\n    d=rotate(d,0.5*iTime);\n   \n                vec3 n;\n    float t;\n   \n    // Default background color\n    fragColor=vec4(background(d),1.0);\n    if (sphere(o, d, vec3(0.0, 0.0, 0.0), 1.0, t, n))\n    {         \n        fragColor = vec4( mix(background(d), shade(o+d*t,n), step(0.0, t)), 1.0 );\n    }\n    fragColor=Vignetting(fragColor,xy);\n}","name":"Image","description":"","type":"image"}]}