{"ver":"0.1","info":{"id":"mtyGzd","date":"1684453210","viewed":87,"name":"blinn phong shadow fog ball box","username":"ShelbyLynn","description":"just a ball man idk","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["phong","ball","softshadows","blinn","fresnel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2\n#define BOUNCES 0\n\nvec3 pt(vec3 ro, vec3 rd) {\n    vec3 th = vec3(1.);\n    vec3 lp = (vec3(1. * cos(iTime),1.,1. * sin(iTime)));\n    hitInfo fo = map(ro,rd);\n    for (int b = BOUNCES+1; b>0;b--){\n        vec3 n, p;\n        hitInfo o = map(ro,rd);\n        if (o.d < RAY_LIMIT) {\n            p = ro + rd * o.d;\n            vec3 ord = normalize(ro - p);\n            n = calcNormal(p);\n            //th *= pow(norm * 0.5 + 0.5, vec3(2.2));\n           //\n             float ao = ao(p, n);\n             vec3 col, light;\n             float rough, ior, fresnel;\n             bool non_reflective = false;\n             switch(o.mat_id) {\n                 case 0:\n                     col = vec3(1., 0., 0.);\n                     ior = 1.26;\n                     rough = 0.6 + (1. - 0.6) * schlick(ior, -dot(n, ord));\n                     light = blinn_phong(col, lp, p, ord, n, rough);\n                     break;\n                 case 1: \n                     col = (n * 0.5 + 0.5);\n                     ior = 1.1;\n                     rough = 0.2 + (1. - 0.2) * schlick(ior, -dot(n, ord));\n                     light = blinn_phong(col, lp, p, ord, n, rough);\n                     break;\n                 \n             }\n             th *= light * ao+vec3(0.01)*(1.-ao) ;\n             //th *= rough;\n             if (BOUNCES==0) th *= soft_shadow(p, normalize(lp - p))+vec3(0.05)*(ao);\n\n            if (non_reflective) break;\n        } else {\n            th *= applyFog(th, o.d);\n            break;\n        }\n        ro = p;\n        rd = rd - 2.*n*dot(n,rd);\n    }\n    \n    return applyFog(th, fo.d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec3 col = vec3(0.);\n    \n    for (int py = AA; py > 0; py--)\n    for (int px = AA; px > 0; px --)\n    {\n        vec2 p = (fragCoord + 0.5 - vec2(float(px),float(py)) / float(AA))/iResolution.xy * 2. - 1.;\n        p.y *= iResolution.y / iResolution.x;\n        vec2 m = iMouse.xy / iResolution.xy * 2. - 1.;\n\n        vec3 wu = vec3(0., 1., 0.);\n        vec3 ro = vec3(0., 1.0, -2.);\n\n        vec3 la = vec3(0., 0., 0.);\n\n        vec3 cf = normalize( la - ro);\n        vec3 cr = cross(wu,cf);\n        vec3 cu = cross(cf, cr);\n\n        //float fov = .;\n\n        //vec3 er = normalize( vec3( p.xy, fov ) );\n        vec3 rd = normalize(p.x*cr + p.y*cu + cf);\n\n        //vec3 go = blurAmount*vec3( -1.0 + 2.0*random2f(), 0.0 );\n        //vec3 gd = normalize( er*focusDistance - go );\n        //ro += go.x*uu + go.y*vv;\n        //rd += gd.x*uu + gd.y*vv;\n\n        col += pt(ro, rd);\n    }\n    \n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(1. - exp2(-pow(col / float(AA * AA), vec3(2.2))),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define RAY_STOP 0.00001\n#define RAY_LIMIT 16.\n#define RAY_DEPTH 64\n\n#define NORM_SCALE 0.0001\n\n#define SHADOW_STEPS 64\n#define SHADOW_SHARPNESS 10.\n\n#define AO_STEPS 8\n#define AO_SOFT 0.01\n\n#define PI acos(-1.)\n\nfloat linear_rgb_c(float v) {\n  if (v <= 0.04045) {\n    return (v / 12.92);\n  }\n  else {\n    return pow((v + 0.005) / 1.055f, 2.4);\n  }\n}\n\nvec3 linear_rgb(vec3 rgba) {\n  return pow(rgba, vec3(2.2));\n}\n#define R_2_2 1.0f / 2.2f\nvec3 nonlinear_rgb(vec3 rgb) {\n    return pow(rgb, vec3(R_2_2));\n}\n\nvec3 rgb_to_xyz(vec3 rgba) {\n  vec3 srgb =nonlinear_rgb (rgba);\n  return vec3(\n    dot(vec3(0.4124564, 0.3575761, 0.1804375), srgb),\n    dot(vec3(0.2126729, 0.7151522, 0.0721750), srgb),\n    dot(vec3(0.0193339, 0.1191920, 0.9503041), srgb));\n}\n\nvec3 xyz_to_rgb(vec3 xyz) {\n  return linear_rgb(\n    vec3(dot(vec3(3.2404542, -1.5371385, -0.4985314), xyz),\n      dot(vec3(-0.9692660, 1.8760108, 0.0415560), xyz),\n      dot(vec3(0.0556434, -0.2040259, 1.0572252), xyz)));\n}\n\nfloat dist_scale(float d) {\n    return RAY_STOP + RAY_STOP * (1. - exp2(-d));\n}\n\n/// https://iquilezles.org/articles/distfunctions/\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  return dot(p,n) + h;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}\n\n///\n\nstruct hitInfo {\n    float d;\n    int mat_id;\n};\n\nstruct Material {\n    vec3 albedo;\n    vec3 specular;\n    float roughness;\n    float ior;\n};\n\nMaterial new_material(vec3 albedo, vec3 specular, float roughness, float ior) {\n    Material mat;\n    mat.albedo = albedo;\n    mat.specular = specular;\n    mat.roughness = roughness;\n    mat.ior = ior;\n    return mat;\n}\n\nhitInfo info(float d, int mat_id) {\n    hitInfo newinfo;\n    newinfo.d = d;\n    newinfo.mat_id = mat_id;\n    return newinfo;\n}\n\nvec3 ortho(vec3 v)\n{\n    return abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0)\n                               : vec3(0.0, -v.z, v.y);\n}\n\nhitInfo world(vec3 p) {\n    //float test = opSmoothIntersection(sdSphere(p, 0.5), sdRoundBox(p, vec3(0.25), 0.15), 0.2);\n    float sphere_a = sdSphere(p+vec3(0.66,0.,0.25), 0.5);\n    float sphere_b = sdBox(p-vec3(0.66,0.,0.0), vec3(0.5));\n    float plane = sdPlane(p, vec3(0.,1.,0.),0.5);\n    hitInfo info = info(min(min(sphere_a, plane), sphere_b), 0);\n    if (sphere_a < plane || sphere_b < plane) {\n        info.mat_id = 0;\n    } else {\n        info.mat_id = 1;\n    }\n    return info;\n}\n\nfloat de(vec3 p) {\n    return world(p).d;\n}\n\nvec3 calcNormal(vec3 p) // for function f(p)\n{\n    const float h = NORM_SCALE; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*de( p + k.xyy*h ) + \n                      k.yyx*de( p + k.yyx*h ) + \n                      k.yxy*de( p + k.yxy*h ) + \n                      k.xxx*de( p + k.xxx*h ) );\n}\n\nhitInfo map(vec3 ro, vec3 rd) {\n    hitInfo o = world(ro);\n    float d = NORM_SCALE;\n    for (int i = RAY_DEPTH; i > 0; i--) {\n       vec3 p = ro + (rd * d);\n       o = world(p);\n       if (o.d < RAY_STOP) break;\n       if (o.d > RAY_LIMIT) break;\n       d += o.d;\n    }\n    return info(d,o.mat_id);\n}\n\nfloat ao(vec3 ro, vec3 rd) {\n    float d = NORM_SCALE;\n    int i = 0;\n    float mn = 0.;\n    float mx = 0.;\n    while (i < AO_STEPS) {\n        vec3 p = ro + (rd * float(i + 1) * AO_SOFT);\n        float de =  world(p).d;\n        float decay = 1. / pow(2.,float(i + 1));\n        mn += de *decay;\n        mx +=  float(i + 1) * AO_SOFT * decay ; \n        \n        i += 1;\n    }\n    return   clamp(mn/mx, 0., 1.);\n}\n\n// https://www.shadertoy.com/view/lsKcDD\nfloat soft_shadow(vec3 ro, vec3 rd)\n{\n\tfloat res = 1.0;\n    float d = NORM_SCALE;\n    for( int i=SHADOW_STEPS; i>0; i-- )\n    {\n        vec3 p = ro + rd*d;\n\t\tfloat dist = world(p).d;\n        res = min( res, SHADOW_SHARPNESS*dist/d );\n        d += dist;\n        if( res<RAY_STOP|| d>RAY_LIMIT ) break;\n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n\n// https://iquilezles.org/articles/fog/\nvec3 applyFog( in vec3  rgb,       // original color of the pixel\n               in float d ) // camera to point distance\n{\n    float fogAmount = 1.0 - exp( -d * 0.3);\n    vec3  fogColor  = vec3(0.5,0.6,0.7);\n    return mix( rgb, fogColor, fogAmount );\n}\n\nvec3 blinn_phong(vec3 albedo, vec3 lp, vec3 o, vec3 d, vec3 n, float rough) {\n    vec3 ld = lp - o;\n    float ldist = length(ld);\n    ld /= ldist;\n    ldist *= ldist;\n    \n    float ndl = max(0., dot(n, ld)) / ldist;\n    vec3 h = normalize(ld + d);\n    float ndh = pow(max(0., dot(n, h)), (1. - rough) * (1. - rough)) / ldist;\n    \n    return albedo * ndl + ndh*2.;\n}\n\nfloat schlick(float ior, float costheta) {\n    float r0 = (1. - ior) / (1. + ior);\n    r0 *= r0;\n    float oct = 1. - costheta;\n    float oct2 = oct * oct;\n    return r0 + (1. - r0)*(oct2 * oct2 * oct);\n}","name":"Common","description":"","type":"common"}]}