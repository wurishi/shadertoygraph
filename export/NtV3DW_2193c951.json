{"ver":"0.1","info":{"id":"NtV3DW","date":"1637721167","viewed":97,"name":"Fork Taylor Series sin() loop","username":"akohdr","description":"Fork of earlier switch() impl. idea  Loop version (or NOT! see common) in this shader.  \nLooks like switch() still hit / miss you can try the switch version in the linked fork (unlisted) (sorry iq)\n\n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["math"],"hasliked":0,"parentid":"7lG3DD","parentname":"Taylor Series sin()"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Andrew Wild - akohdr/2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Wikipedia has the theory\n//   https://en.wikipedia.org/wiki/Taylor_series#Approximation_error_and_convergence\n\n// choose numerical approximation implementation (refer common tab)\n#define SIN taylorSin_loop\n//#define SIN taylorSin_N\n//#define SIN taylorSin_pre\n\n// overloaded functions dealing with vector arguments\nvec2 SIN(int n, vec2 v) { return vec2(SIN(n, v.x),SIN(n, v.y)); }\nvec3 SIN(int n, vec3 v) { return vec3(SIN(n, v.x),SIN(n, v.y),SIN(n, v.z)); }\nvec4 SIN(int n, vec4 v) { return vec4(SIN(n, v.x),SIN(n, v.y),SIN(n, v.z),SIN(n, v.w)); }\n\nvoid mainImage( out vec4 k, in vec2 p )\n{\n    vec2 c = p-iR.xy/2.; c/=iR.y; c*=3.*TAU; c.x+=3.*PI;\n    \n    float w = .75;\n    k = vec4(0);\n    \n    // RED: GPU intrinsic implementation of sin() unless you overode it :)\n    float s = sin(c.x);\n    k.r = smoothstep(-w,.0,c.y-s)-smoothstep(.0,w,c.y-s);\n    \n    // GRN: Taylor series increasing discrete approximation with time\n    float n = SIN(int(iTime),c.x);\n    k.g = smoothstep(-w,.0,c.y-n)-smoothstep(.0,w,c.y-n);\n        \n    // Transition effect after reaching twelve terms\n    float t = clamp((iTime-12.),0.,1.);\n    c.x = mod(c.x,TAU);\n    n = SIN(9,c.x);\n    k.g -= t*k.g;\n    k.g += max(0.,t*smoothstep(-w,.0,c.y-n)-smoothstep(.0,w,c.y-n));\n    \n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define iR iResolution\n#define PI2 1.570796326794896619231321691639751442098584699687552910487472296\n#define PI  3.141592653589793238462643383279502884197169399375105820974944592\n#define TAU 6.283185307179586476925286766559005768394338798750211641949889185\n\n\nfloat taylorSin_loop(int n, float x) \n{ \n//    x = mod(x,TAU);             // uncomment and use n>6 or use fixed length as below\n    float a=x, f=1., p=1., z=x;\n    \n/* Apparently non-constant bounded loops and while loops cause heartburn on iPhone\n//    for(;n>0;n-=2)                          // loop step 2\n//    for(int i=n;i>0;i-=2)                   // loop step 2\n//    while(n>0)\n    { \n        n-=2;\n        z*=x; f*=++p; z*=x; f*=++p; a-=z/f;  // repeated code avoids branch for +/-  *-1\n        z*=x; f*=++p; z*=x; f*=++p; a+=z/f;\n    }\n*/\n\n// resort to branching faux loop (urghh!)\n#define LOOP(n,blk) if(--n<0) return a; blk\n\n    LOOP(n, z*=x; f*=++p; z*=x; f*=++p; a-=z/f;)\n    LOOP(n, z*=x; f*=++p; z*=x; f*=++p; a+=z/f;)\n    LOOP(n, z*=x; f*=++p; z*=x; f*=++p; a-=z/f;)\n    LOOP(n, z*=x; f*=++p; z*=x; f*=++p; a+=z/f;)\n    LOOP(n, z*=x; f*=++p; z*=x; f*=++p; a-=z/f;)\n    LOOP(n, z*=x; f*=++p; z*=x; f*=++p; a+=z/f;)\n    LOOP(n, z*=x; f*=++p; z*=x; f*=++p; a-=z/f;)\n    LOOP(n, z*=x; f*=++p; z*=x; f*=++p; a+=z/f;)\n    LOOP(n, z*=x; f*=++p; z*=x; f*=++p; a-=z/f;)\n    LOOP(n, z*=x; f*=++p; z*=x; f*=++p; a+=z/f;)\n    LOOP(n, z*=x; f*=++p; z*=x; f*=++p; a-=z/f;)\n    LOOP(n, z*=x; f*=++p; z*=x; f*=++p; a+=z/f;)\n    \n    return a;\n}\n\n\nfloat taylorSin_N(int n, float x) \n{ \n    x = mod(x,TAU);\n    float a=x,       // approximation accumulator\n          y=x*x,     // only need to do this once\n          f=1.,      // factorial accumulator\n          p=1.,      // power index\n          z=x;       // x^p\n\n    z*=y; f*=++p; f*=++p; a-=z/f; \n    z*=y; f*=++p; f*=++p; a+=z/f; \n    z*=y; f*=++p; f*=++p; a-=z/f; \n    z*=y; f*=++p; f*=++p; a+=z/f; \n    z*=y; f*=++p; f*=++p; a-=z/f; \n    z*=y; f*=++p; f*=++p; a+=z/f; \n    z*=y; f*=++p; f*=++p; a-=z/f;   // need minimum 6/7 terms\n\n// add one line for each term remember alternating add/sub\n//    z*=y; f*=++p; f*=++p; a+=z/f; \n//    z*=y; f*=++p; f*=++p; a-=z/f; \n\n    return a;\n}\n\n// precomputed factorials\nfloat taylorSin_pre(int n, float x) \n{ \n    x = mod(x,TAU);\n    float a=x,       // approximation accumulator\n          y=x*x;     // do this once then we can reuse x\n\n    x*=y; a-=x/6.; \n    x*=y; a+=x/120.; \n    x*=y; a-=x/5040.; \n    x*=y; a+=x/362880.; \n    x*=y; a-=x/39916800.; \n    x*=y; a+=x/6227020800.; \n    x*=y; a-=x/1307674368000.;\n    x*=y; a+=x/355687428096000.; \n    x*=y; a-=x/121645100408832000.;\n    x*=y; a+=x/51090942171709440000.; \n    x*=y; a-=x/25852016738884976640000.;\n    x*=y; a+=x/15511210043330985984000000.; \n    \n    return a;\n}\n\n/*\n// --- Cut/Paste start: overload sin()/cos() in target shader ----------------------------------\n\n// I have achieved couple fps gain here and there but not sure it's worth the trouble\n\nfloat taylorSin_N(float x) \n{ \n    x = mod(x,6.28);\n    float a=x,       // approximation accumulator\n          y=x*x,     // only need to do this once\n          f=1.,      // factorial accumulator\n          p=1.,      // power index\n          z=x;       // x^p\n\n    z*=y; f*=++p; f*=++p; a-=z/f; \n    z*=y; f*=++p; f*=++p; a+=z/f; \n    z*=y; f*=++p; f*=++p; a-=z/f; \n    z*=y; f*=++p; f*=++p; a+=z/f; \n    z*=y; f*=++p; f*=++p; a-=z/f; \n    z*=y; f*=++p; f*=++p; a+=z/f; \n    z*=y; f*=++p; f*=++p; a-=z/f;   // need minimum 6/7 terms\n\n// add one line for each term remember alternating add/sub\n//    z*=y; f*=++p; f*=++p; a+=z/f; \n//    z*=y; f*=++p; f*=++p; a-=z/f; \n\n    return a;\n}\n\nfloat taylorSin_pre(float x) \n{ \n    x = mod(x,TAU);\n    float a=x,       // approximation accumulator\n          y=x*x;     // do this once then we can reuse x\n\n    x*=y; a-=x/6.; \n    x*=y; a+=x/120.; \n    x*=y; a-=x/5040.; \n    x*=y; a+=x/362880.; \n    x*=y; a-=x/39916800.; \n    x*=y; a+=x/6227020800.; \n//    x*=y; a-=x/1307674368000.;\n//    x*=y; a+=x/355687428096000.; \n//    x*=y; a-=x/121645100408832000.;\n//    x*=y; a+=x/51090942171709440000.; \n//    x*=y; a-=x/25852016738884976640000.;\n//    x*=y; a+=x/15511210043330985984000000.; \n    \n    return a;\n}\n\n#define SIN taylorSin_pre\nvec2 SIN(vec2 v) { return vec2(SIN(v.x),SIN(v.y)); }\nvec3 SIN(vec3 v) { return vec3(SIN(v.x),SIN(v.y),SIN(v.z)); }\nvec4 SIN(vec4 v) { return vec4(SIN(v.x),SIN(v.y),SIN(v.z),SIN(v.w)); }\n\n#define sin(x) SIN(x)             // you can overide intrinsic but use judiciously \n#define cos(x) SIN((x)+1.57)\n\n// --- Cut/Paste end: overload sin()/cos() in target shader ------------------------------------\n*/\n\n\n\n\n","name":"Common","description":"","type":"common"}]}