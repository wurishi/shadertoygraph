{"ver":"0.1","info":{"id":"lt3XRN","date":"1478395564","viewed":407,"name":"There","username":"Draedrus","description":"There WIP","likes":7,"published":1,"flags":96,"usePreview":1,"tags":["water","postprocess","reflections","island","screenspace","refractions","deferred"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"ld23WR","filepath":"https://soundcloud.com/bricesalek/ocean-waves-by-brice-salek","previewfilepath":"https://soundcloud.com/bricesalek/ocean-waves-by-brice-salek","type":"musicstream","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/***********************************************************************\n * author: pierre.plans@gmail.com\n ***********************************************************************/\n// You can found the audio here https://soundcloud.com/bricesalek/ocean-waves-by-brice-salek\n\n/*#ifndef GLSL\n#define textureProj texture2DProj\n#endif*/\n\n// costly\n#define USE_FAKEDREAL_WATER\n\n#define CAMERA_CONTROLLED\n\n#define NEAR 0.01\n#define FAR 500.0\n\n#define TIME iTime*0.2\n#define CAMERATIME TIME*0.1\n#define CAMERADIST max(0.7, sin(CAMERATIME))*20.0\n\n#define Time iTime*0.25\n\n#define CAMPOS vec3(2.0, 3.5, 12.0)\n#define TARGETPOS vec3(2.0, 1.0, 2.0)\n\n#define ISLANDPOS vec3(3.0, 0.0, -1.0)\n\n#define COLORWATER vec3(0.0, 0.0, 1.0)\n\n#define VAR_WATER_LEVEL 0.9\n// 0.08 - 0.1 is a good value for VAR_WATER_AMP\n#define VAR_WATER_AMP 0.15\n#define VAR_WATER_FREQ 0.4\n#define VAR_WATER_SPEED 0.5\n\n// water info\n#define WATER_REFR_INDEX 1.0/1.33\n\n// 0.9\n#define WATER_DEPTH_VISIBILITY 1.2\n#define WATER_DEPTH_MAX 20.0\n\n#define REFLREFR_FRESNEL_BIAS 0.18\n#define REFLREFR_FRESNEL_SCALE 1.0\n#define REFLREFR_FRESNEL_EXPO 0.8\n\n// HDR sky parameters\n#define SCALE_HEIGHT\t\t 8000.0\n#define SUNDIST \t149597870700.0\n#define EARTHRADIUS\t\t\t 6360e3\n#define ATMOSPHERERADIUS \t6420e3\n#define SUNINTENSITY\t\t 20.0\n#define SUNRADIUS \t  695700000.0\n#define MOONRADIUS \t\t1737400.0\n#define EARTHPOS vec3(0.0, 0.0, 0.0)\n#define SUNPOS normalize(vec3(0.0, -1.0, 0.0))*149597870700.0\n#define MOONPOS normalize(vec3(1.0, 0.5, 1.7))*384467700.0\n\nstruct Light {\n    vec3 o;\n    vec3 d;\n    vec4 diffuseColor;\n    vec4 specularColor;\n    float shininess;\n\tfloat power;\n};\n\nLight _light = Light(\n    SUNPOS,\n    normalize(EARTHPOS-SUNPOS),\n    vec4(1.0, 1.0, 0.8, 1.0),\n    vec4(1.0, 1.0, 0.8, 1.0),\n    2.0,\n    SUNINTENSITY);\n\nfloat IntersectSphere(vec3 ro, vec3 rd, vec3 sc, float sr, out float tmin, out float tmax) {\n    vec3 Z = ro-sc;\n    float B = 2.0 * dot(rd, Z);\n    float C = Z.x*Z.x+Z.y*Z.y+Z.z*Z.z-sr*sr;\n    float D = B*B - 4.0*C;\n    float d = -1.0;\n    if(D>=0.0) {\n        if(C==0.0) {\n            tmax = -B/2.0;\n            d = 0.0;\n        }else{\n            tmin = (-B-sqrt(D))/2.0;\n            tmax = (-B+sqrt(D))/2.0;\n            d = 1.0;\n        }\n    }\n    return d;\n}\n\nvec3 RotXV3(in vec3 P, float A)\n{\n    float cA = cos(A), sA = sin(A);\n    return P*mat3(1.0, 0.0, 0.0, 0.0, cA, -sA, 0.0, sA, cA);\n}\nvec3 RotYV3(in vec3 P, float A)\n{\n    float cA = cos(A), sA = sin(A);\n    return P*mat3(cA, 0.0, -sA, 0.0, 1.0, 0.0, sA, 0.0, cA);\n}\n\nfloat hash1D(float x)\n{\n \treturn fract(sin(x*13.14434)*1.40503503);   \n}\n\nfloat hash2D(vec2 x) {\n\treturn fract(sin(dot(x, vec2(13.454, 7.405)))*12.3043);\n}\n\nfloat hash3D(vec3 x) {\n\treturn fract(dot(x, vec3(12.4955, 10.4294, 42.40594))*13.4959451);    \n}\n\nfloat voronoi2D(vec2 uv) {\n    vec2 fl = floor(uv);\n    vec2 fr = fract(uv);\n    float res = 1.0;\n    for( int j=-1; j<=1; j++ ) {\n        for( int i=-1; i<=1; i++ ) {\n            vec2 p = vec2(i, j);\n            float h = hash2D(fl+p);\n            vec2 vp = p-fr+h;\n            float d = dot(vp, vp);\n            \n            res +=1.0/pow(d, 8.0);\n        }\n    }\n    return pow( 1.0/res, 1.0/16.0 );\n}\n\nfloat waterNoise(vec2 x) {\n    vec2 p = floor(x);\n    vec2 n = fract(x);\n    vec2 f = n*n*(3.0-2.0*n);\n    float winx = 1.0;\n    float winy = 1.0;\n    \n    return mix(\n                mix(hash2D(p)     , hash2D(p+vec2(winx, 0.0)), f.x),\n                mix(hash2D(p+vec2(0.0, winy)), hash2D(p+vec2(winx, winy)), f.x),\n                f.y);\n}\n\nfloat smoothNoise2D(vec2 x) {\n    vec2 p = floor(x);\n    vec2 n = fract(x);\n    vec2 f = n*n*(3.0-2.0*n);\n    float winx = 1.0;\n    float winy = 70.0;\n    \n    float wx = p.x*winx+winy*p.y;\n    return mix(\n                mix(hash1D(wx+0.0)     ,      hash1D(wx+1.0), f.x),\n                mix(hash1D(wx+0.0+winy), \thash1D(wx+1.0+winy), f.x),\n                f.y);\n}\n\nfloat smoothNoise(vec3 x) {\n    vec3 p = floor(x);\n    vec3 n = fract(x);\n    vec3 f = n*n*(3.0-2.0*n);\n    float winy = 157.0;\n    float winz = 113.0;\n    \n    float wx = p.x+winy*p.y+winz*p.z;\n    return mix(\n        \tmix(\n                mix(hash1D(wx+0.0)     ,      hash1D(wx+1.0), f.x),\n                mix(hash1D(wx+0.0+winy), \thash1D(wx+1.0+winy), f.x),\n                f.y),\n        \tmix(\n                mix(hash1D(wx+0.0+winz)     ,      hash1D(wx+1.0+winz), f.x),\n                mix(hash1D(wx+0.0+winy+winz), hash1D(wx+1.0+winy+winz), f.x),\n                f.y)\n        , f.z);\n}\n\n// Simplex 2D noise\n// sources: Ian McEwan - https://github.com/ashima/webgl-noise/blob/master/src/noise2D.glsl\n// sources: Patricio Gonzalez Vivo - https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\nfloat snoise(vec2 v){\n    const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n                        -0.577350269189626, 0.024390243902439);\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod(i, 289.0);\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n                     + i.x + vec3(0.0, i1.x, 1.0 ));\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n                            dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n//  Simplex 3D Noise \n//  by Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v){ \n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    // First corner\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n    // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    //  x0 = x0 - 0. + 0.0 * C \n    vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n    vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n    vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n    // Permutations\n    i = mod(i, 289.0 ); \n    vec4 p = permute( permute( permute( \n        i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n                              + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n                     + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n    // Gradients\n    // ( N*N points uniformly over a square, mapped onto an octahedron.)\n    float n_ = 1.0/7.0; // N=7\n    vec3  ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n    //Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    // Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                 dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat noise3D(vec3 x) {\n    vec3 p = floor(x);\n    vec3 n = fract(x);\n    vec3 f = n*n*(3.0-2.0*n);\n    float winx = 1.0;\n    float winy = 1.0;\n    float winz = 1.0;\n    \n    return mix(\n        \tmix(\n                mix(hash3D(p)     \t\t\t\t  , hash3D(p+vec3(winx, 0.0, 0.0)), f.x),\n                mix(hash3D(p+vec3(0.0, winy, 0.0)), hash3D(p+vec3(winx, winy, 0.0)), f.x),\n                f.y),\n        \tmix(\n                mix(hash3D(p+vec3(0.0, 0.0, winz)), hash3D(p+vec3(winx, 0.0, winz)), f.x),\n                mix(hash3D(p+vec3(0.0, winy, winz)), hash3D(p+vec3(winx, winy, winz)), f.x),\n                f.y),\n   \t\t\tf.z);\n}\n\n/**\n * This one is inspired by IQ code from this website.\n **/\nfloat fbm2D(vec2 p) {\n    float total = 0.0;\n    total  = 0.5000* snoise(p); p = p*2.0;\n    total += 0.2500* snoise(p); p = p*2.0;\n    total += 0.1250* snoise(p); p = p*2.0;\n    total += 0.0625* snoise(p); p = p*2.0;\n    return total;\n}\n\nfloat fbm3D(vec3 p)\n{\n    float total = 0.0;\n    total  = 0.5000* smoothNoise(p); p = p*2.0;\n    total += 0.2500* smoothNoise(p); p = p*2.0;\n    total += 0.1250* smoothNoise(p); p = p*2.0;\n    total += 0.0625* smoothNoise(p); p = p*2.0;\n    return total;\n}\n\n/***\nHASH VERSION\n***/\n\nvec2 rot(vec2 X, float a)\n{\n \tfloat s = sin(a); float c = cos(a);\n    return mat2(c, -s, s, c)*X;\n}\n\nfloat hash(vec2 uv)\n{\n \tvec2 suv = sin(uv);\n    suv = rot(suv, uv.x);\n    return fract(mix(suv.x*13.13032942, suv.y*12.01293203924, dot(uv, suv)));\n}\n\nfloat custom_perlin_hash(vec2 uv)\n{\n \tvec2 lower\t= floor(uv);\n    vec2 frac \t= fract(uv);\n    vec2 f = frac*frac*(3.0-2.0*frac);\n    \n    return mix(\n        \tmix(hash(lower+vec2(0.0, 0.0)), hash(lower+vec2(1.0, 0.0)), f.x),\n        \tmix(hash(lower+vec2(0.0, 1.0)), hash(lower+vec2(1.0, 1.0)), f.x),\n        \tf.y);\n}\n\nfloat fbm_hash(vec2 uv)\n{\n    float total = 0.0;\n    total += 0.5000*custom_perlin_hash(uv); uv*=2.001;\n    total += 0.2500*custom_perlin_hash(uv); uv*=2.003;\n    total += 0.1250*custom_perlin_hash(uv); uv*=2.002;\n    total += 0.0625*custom_perlin_hash(uv); uv*=2.001;\n    return clamp(total, 0.0, 1.0);\n}\n\n/*#####################\nThe Island\n#####################*/\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat _mapIsland(vec3 p) {\n    p.y += voronoi2D(p.xz);\n    float d = sdEllipsoid(p, vec3(8.0, 16.0, 8.0));\n    \n    float di = length(p);\n    \n    return d+di+voronoi2D(p.xz*6.0)*0.2;\n}\n\nfloat mapIsland(vec3 p) {\n    return _mapIsland(p-ISLANDPOS);\n}\n\n\n/*#####################\n Water handling\n#######################*/\n\n#ifdef USE_FAKEDREAL_WATER\n\nfloat getWaterLevel(vec3 p)\n{\n    float h = -1.5;\n    float a = 2.0;\n    h += p.y+0.0;\n    \n    vec2 ws = 0.001*vec2(TIME*240.0, TIME*180.0);\n    \n    //h += 0.04*sin(p.x*0.8+ws.x);\n    //h += 0.02*sin(p.x*0.7+p.y*0.65+ws.y*1.1);\n    //h -= 0.005*sin(p.x*0.60+p.y*0.57+ws.y*0.9);\n    \n    //h += 0.0025*sin(p.x*0.43+p.y*0.38+ws.y*3.0);\n    //h += 0.001*sin(p.x*0.34+p.y*0.29+ws.y*4.0);\n    #ifdef NEW\n    float f = 2.4;\n    for(int i=0;i<7;++i) {\n        h += fbm_hash(p.xz*f+TIME)*a;\n        h -= fbm_hash(p.xz*f-TIME)*a;\n        //p.xz*=f;\n        a*= 0.2;\n        f *= 1.2;\n    }\n    #else\n    h *= a;\n    \n    h -= voronoi2D(p.xz*0.8+waterNoise(p.xz)-ws.y*9.4)*0.3;\n    h -= fbm2D(p.xz*1.2-ws.x*4.4)*0.05;\n    float f = 1.5;\n    a = 1.1;\n    p.xz *= 0.1;\n    for(int i=0;i<7;++i) {\n        h -= smoothNoise2D(p.xz*f+ws.y*VAR_WATER_SPEED)*a;\n        a *= 0.1;\n        f *= 1.2;\n    }\n    #endif\n\n    return h;\n}\n#else\nfloat getWaterLevel(vec3 p)\n{\n    float h = VAR_WATER_LEVEL;\n    float a = VAR_WATER_AMP;\n    float f = VAR_WATER_FREQ;\n    \n    /*vec2 ws = 0.001*vec2(iTime*320.0, iTime*240.0);\n    \n    h += 0.8*sin(p.x*0.021+ws.x);\n    h += 0.6*sin(p.x*0.017+p.y*0.017+ws.y*1.2);\n    h -= 0.6*sin(p.x*0.009+p.y*0.009+ws.y*0.9);*/\n    \n    for(int i=0;i<7;++i) {\n        h += smoothNoise2D(p.xz*f+iTime*VAR_WATER_SPEED)*a;\n        h -= smoothNoise2D(p.xz*f-iTime*VAR_WATER_SPEED)*a;\n        a *= 0.6;\n        f *= 1.4;\n    }\n    return h;\n}\n#endif\n\n\nfloat mapWater(vec3 p)\n{\n \treturn p.y+getWaterLevel(p);   \n}\n\nvec3 mapNormalWater(vec3 pt, float e) {\n    vec3 normal;\n    normal.y = mapWater(pt);\n    normal.x = mapWater(vec3(pt.x+e,pt.y,pt.z)) - normal.y;\n    normal.z = mapWater(vec3(pt.x,pt.y,pt.z+e)) - normal.y;\n    normal.y = e;\n    return normalize(normal);\n}\n\n/*######################\nRendering\n######################*/\n\nfloat fresnel(vec3 I, vec3 N, float B, float S, float E)\n{\n    return B+S*pow(max(0.0, 1.0+dot(I,N)),E);\n}\n\nvec3 getSkyLight(vec3 ro, vec3 rd, vec3 L, vec3 betaR, vec3 betaM)\n{\n    vec3 light = vec3(0.0);\n    float tmin = 0.0;\n    float tmax = 0.0;\n    float d = IntersectSphere(ro, rd, EARTHPOS, ATMOSPHERERADIUS, tmin, tmax);\n    vec3 Pa = ro+rd*tmax;\n    /*if(d>0.0)\n        Pa = ro+rd*(tmax-tmin);*/\n    float RdotL = dot(rd, L);\n    float tCurrent = 0.0;\n    float segL = tmax/16.0;\n    /*if(d>0.0)\n        segL = (tmax-tmin)/16.0;*/\n    float g = 0.76; // 0.76\n    float g2 = g*g;\n    float hr = 7994.0; // 7994\n    float hm = 300.0; // 1200\n    // Rayleigh\n    vec3 sumR = vec3(0.0);\n    float phaseR = 3.0/(16.0*3.14)*(1.0+RdotL*RdotL);\n    //vec3 betaR = vec3(5.5e-6, 13.0e-6, 22.4e-6);\n    float opticalDepthR = 0.0;\n    // Mie\n    vec3 sumM = vec3(0.0);\n    //float phaseM = 3.0/(8.0*3.14)*((1.0-g*g)+(1.0+RdotL*RdotL))/((2.0+g*g)+pow(1.0+g*g-2.0*g*RdotL, 1.5));\n    // correction thanks to from http://http.developer.nvidia.com/GPUGems2/gpugems2_chapter16.html\n    // my implementation has an error with the first terms in the equation\n    float phaseM = (\n        \t\t\t(3.0*(1.0-g2))/\n        \t\t\t(2.0*(2.0+g2))\n        \t\t\t)*\n        \t\t\t(\n                        (1.0+RdotL*RdotL)/\n                        pow(1.0+g2-2.0*g*RdotL, 1.5)\n                    );\n    //vec3 betaM = vec3(21e-6);\n    float opticalDepthM = 0.0;\n    for (int i = 0; i < 16; ++i)\n    {\n        vec3 X = ro+rd*(tCurrent+0.5*segL);\n        float h = length(X) - EARTHRADIUS;\n        float _hr = exp(-h/hr)*segL;\n        float _hm = exp(-h/hm)*segL;\n        opticalDepthR += _hr;\n        opticalDepthM += _hm;\n        vec3 lRay = L;//normalize((SUNDIST*L)-X);\n        float tlmin = 0.0;\n        float tlmax = 0.0;\n        float dl = IntersectSphere(X, L, EARTHPOS, ATMOSPHERERADIUS, tlmin, tlmax);\n        float segLLight = tlmax/8.0;\n        float tCurrentLight = 0.0;\n        float opticalDepthLightR = 0.0;\n        float opticalDepthLightM = 0.0;\n        bool ended = true;\n        for (int j = 0; j < 8; ++j)\n        {\n            vec3 samplePositionLight = X+L*(tCurrentLight + 0.5 * segLLight);\n            float hLight = length(samplePositionLight) - EARTHRADIUS;\n            if (hLight < 0.0)\n            {\n                ended = false;\n                break;\n            }\n            opticalDepthLightR += exp(-hLight / hr) * segLLight;\n            opticalDepthLightM += exp(-hLight / hm) * segLLight;\n            tCurrentLight += segLLight;\n        }\n        if (ended)\n        {\n            vec3 tau = betaR * (opticalDepthR + opticalDepthLightR) + betaM * 1.1 * (opticalDepthM + opticalDepthLightM);\n            vec3 attenuation = vec3(exp(-tau.x), exp(-tau.y), exp(-tau.z));\n            sumR += _hr * attenuation;\n            sumM += _hm * attenuation;\n        }\n        tCurrent += segL;\n    }\n    return SUNINTENSITY * (sumR * phaseR * betaR + sumM * phaseM * betaM);\n}\n\nvec3 getSkyColor(vec3 ro, vec3 rd)\n{\n    float daynight = sin(TIME);//max(0.0, dot(vec3(0.0, 1.0, 0.0), -_light.d));\n    vec3 betaR = daynight>=0.0?\n        \t\t\tvec3(5.5e-6, 13.0e-6, 22.4e-6):// DAY\n        \t\t\tvec3(0.1e-6, 0.2e-6, 0.5e-6);\n    vec3 betaM = daynight>=0.0?\n        \t\t\tvec3(21e-6):\n        \t\t\tvec3(1e-6);\n    vec3 L = -_light.d;\n    vec3 color = vec3(0.0);\n    if(daynight<0.0)\n        L = normalize(vec3(0.0, 1.0, 0.0));\n    color = getSkyLight(ro+vec3(0.0, EARTHRADIUS, 0.0), rd, L, betaR, betaM);\n    //color = L;\n    //color = daynight>=0.0?vec3(1.0, 0.0, 0.0):vec3(1.0);\n    return color;\n}\n\n// https://www.shadertoy.com/view/lstSRS\nvec3 tonemapping(vec3 color)\n{\n    //Tonemapping and color grading\n    color = pow(color, vec3(1.5));\n    color = color / (1.0 + color);\n    color = pow(color, vec3(1.0 / 1.5));\n\n    \n    color = mix(color, color * color * (3.0 - 2.0 * color), vec3(1.0));\n    color = pow(color, vec3(1.3, 1.20, 1.0));    \n\n\tcolor = clamp(color * 1.01, 0.0, 1.0);\n    \n    color = pow(color, vec3(0.7 / 2.2));\n    return color;\n}\n\nfloat beckmannDistribution(float roughness, float NdotH)\n{\n    float r1 = 1.0 / ( 4.0 * roughness * roughness * pow(NdotH, 4.0));\n    float r2 = (NdotH * NdotH - 1.0) / (roughness * roughness * NdotH * NdotH);\n    return r1 * exp(r2);\n}\n\n// https://github.com/stackgl/glsl-specular-cook-torrance/blob/master/index.glsl\nfloat cookTorranceSpecular(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float roughness,\n  float fresnel) {\n\n  float VdotN = max(dot(viewDirection, surfaceNormal), 0.0);\n  float LdotN = max(dot(lightDirection, surfaceNormal), 0.0);\n\n  //Half angle vector\n  vec3 H = normalize(lightDirection + viewDirection);\n\n  //Geometric term\n  float NdotH = max(dot(surfaceNormal, H), 0.0);\n  float VdotH = max(dot(viewDirection, H), 0.000001);\n  float LdotH = max(dot(lightDirection, H), 0.000001);\n  float G1 = (2.0 * NdotH * VdotN) / VdotH;\n  float G2 = (2.0 * NdotH * LdotN) / LdotH;\n  float G = min(1.0, min(G1, G2));\n  \n  //Distribution term\n  float D = beckmannDistribution(roughness, NdotH);\n\n  //Fresnel term\n  float F = pow(1.0 - VdotN, fresnel);\n\n  //Multiply terms and done\n  return  G * F * D / max(3.14159265 * VdotN * LdotN, 0.000001);\n}\n\nfloat Fresnel_Schlick(float n1, float n2, float NdotV)\n{\n    float R0 = (n1-n2)/(n1+n2);\n    R0 *= R0;\n    return R0+(1.0-R0)*(1.0-NdotV)*(1.0-NdotV)*(1.0-NdotV)*(1.0-NdotV)*(1.0-NdotV);\n}\n\nvec3 brdf(\n    float Ks,\n    float Kd,\n    float roughness,\n    float opacity,\n    vec3 specularColor,\n    vec3 diffuseColor,\n    vec3 I,\n    vec3 N,\n    vec3 L)\n{\n    vec3 Vn = -I;\n    float NdotV = dot(Vn, N);\n    vec3 C = vec3(0.0);\n    float Oi = opacity;\n    float spec = 0.0;\n    if(NdotV>0.0)\n    {\n        float F = Fresnel_Schlick(1.0, 1.0, NdotV);\n        spec = cookTorranceSpecular(L, Vn, N, roughness, F);\n    }\n    return (Kd*diffuseColor*max(0.0, NdotV)+Ks*specularColor*spec) * Oi;\n}\n\nvec3 getIslandColor(vec3 rd, vec3 p, vec3 n, vec3 L)\n{\n    /*float a = 120.0*3.14/180.0;\n    mat3 r = mat3(cos(a), -sin(a), 0.0, sin(a), cos(a), 0.0, 0.0, 0.0, 1.0);\n    p = r*p;\n    vec3 diffuse = textureProj(iChannel1, p).rgb;*/\n    vec3 tex1 = textureProj(iChannel1, p).rgb;\n    vec3 tex2 = textureProj(iChannel2, p).rgb;\n    float noise = max(0.0, waterNoise(p.xz*10.0));\n    vec3 diffuse = mix(\n        tex1,\n        tex2,\n        noise);\n    vec3 diffuseNature = mix(\n        tex1,\n        tex2,\n        noise)*vec3(0.2, 0.5, 0.4);\n    float angle = max(0.0, dot(vec3(0.0, 1.0, 0.0), n));\n    float noiseV = min(1.0, max(0.0, fbm3D(p*1.8)));\n    \n    vec3 color = vec3(0.0);\n    \n    color = mix(\n        \tbrdf(0.0, 1.0,\n                1.0, // roughness\n                1.0, // opacity\n                diffuse, // specular\n                diffuse, // diffuse\n                rd,\n                n,\n                L),\n        \tbrdf(0.0, 1.0,\n                1.0, // roughness\n                1.0, // opacity\n                diffuseNature, // specular\n                diffuseNature, // diffuse\n                rd,\n                n,\n                L),\n        noiseV);\n    noiseV = min(1.0, max(0.0, pow(fbm3D(p*1.0)+1.5, 2.0)-3.0));\n    color = mix(color,\n        \tbrdf(0.0, 1.0,\n                1.0, // roughness\n                1.0, // opacity\n                tex2*vec3(0.01, 0.3, 0.05), // specular\n                tex2*vec3(0.01, 0.3, 0.05), // diffuse\n                rd,\n                n,\n                L),\n        noiseV);\n    //color = vec3(noiseV);\n    return color;\n}\n\nfloat shadowIsland(vec3 ro, vec3 rd, in float tmin, in float tmax)\n{\n    float shadow = 1.0;\n    float d = tmin;\n\tfor( int i=0; i<5; i++ )\n\t{\n        float dt = mapIsland(ro + d*rd);\n\t\tif( abs(dt)<tmin || d>tmax ) break;\n\t\td += 0.5*dt;\n\t}\n    d = max(0.0, d);\n\treturn (tmax-d)/(tmax-tmin);\n}\n\nfloat shadowOcean(vec3 ro, vec3 rd, in float tmin, in float tmax)\n{\n    float shadow = 1.0;\n    float d = tmin;\n\tfor( int i=0; i<5; i++ )\n\t{\n        float dt = mapWater(ro + d*rd);\n\t\tif( abs(dt)<tmin || d>tmax ) break;\n\t\td += 0.5*dt;\n\t}\n    d = max(0.0, d);\n\treturn (tmax-d)/(tmax-tmin);\n}\n\nvec3 getEarthColor(vec3 ro, vec3 rd, vec3 p, vec3 pI, vec3 n, float d, float dI, vec3 L, vec2 uv)\n{\n    vec3 color = vec3(0.0);\n    #ifdef USE_FAKEDREAL_WATER\n    if(pI.y>p.y || d>dI && dI<60.0)\n    #else\n    if(pI.y>waterLevel && dI<60.0)\n    #endif\n    {\n        color = getIslandColor(rd, pI, n, -L);\n        color *=clamp(shadowIsland(pI+n*1.0, -L, 0.1, 10.0), 0.0, 1.0);\n        //color = -L;\n    }\n    else\n    {\n        // new point in space\n        vec3 wp = p;\n        #ifndef USE_FAKEDREAL_WATER\n        wp.y = waterLevel;\n        #endif\n\n        vec3 wn = normalize(mapNormalWater(wp, 0.001));\n        color = wn;\n        //color = wn;\n        //color *=(1.0-depth/3.0);\n        vec3 rdr = refract(rd, wn, WATER_REFR_INDEX);\n        vec3 rdrfl = reflect(rd, wn);\n        if(rdrfl.y<0.0) rdrfl.y = -rdrfl.y; // -rdrfl\n\n        float f = clamp(fresnel(rd, wn, REFLREFR_FRESNEL_BIAS, REFLREFR_FRESNEL_SCALE, REFLREFR_FRESNEL_EXPO), 0.0, 1.0);\n\n        vec3 refrcolor = clamp(getIslandColor(rdr, ro+rdr*dI, n, L), 0.0, 1.0);\n\n        vec2 ruv = vec2(uv.x, 1.0-uv.y)+rdrfl.xy*vec2(0.01, 0.05);/*normalize(rdrfl.xy);/*rdrfl.xy;\nruv = normalize(ruv);\nruv = vec2(max(0.0, ruv.x+0.5), max(0.0, ruv.y+0.5));*/\n        ruv.x = clamp(ruv.x, 0.0, 1.0);\n        ruv.y = clamp(ruv.y, 0.0, 1.0);\n\n        vec4 gBufferMirror = texture(iChannel0, ruv/*vec2(uv.x, 1.0-uv.y)*/);\n        float dIMirror = gBufferMirror.y;\n        vec3 nIMirror = normalize(vec3(gBufferMirror.z, 0.001, gBufferMirror.w));\n        vec3 rdrflh = rd+rdrfl;\n        vec3 pr = ro+rdrflh*dIMirror;\n        float dfl = length(pr-wp);\n        vec3 reflcolor = getSkyColor(wp.xyz, rdrfl);\n\n        reflcolor += (1.0-f)*(d<dI && dI<60.0?1.0:0.0)*clamp(getIslandColor(rdrfl, wp+rdrfl*dfl, nIMirror, L), 0.0, 1.0);\n\n        //f = Fresnel_Schlick(1.0, 1.33, max(0.0, dot(rd, wn)));\n        float depth = wp.y-pI.y;\n        float dt=clamp(depth/WATER_DEPTH_VISIBILITY, 0.0, 1.0);\n        float dtfoam=1.0-clamp((depth+fbm3D(wp*5.0)*0.1)/0.1, 0.0, 1.0);\n\n        //reflcolor = clamp(log(reflcolor), 0.0, 1.0);\n        color = mix(refrcolor, reflcolor, dt);\n        color = mix(color, vec3(fbm3D(pI)), dtfoam);\n\n        color *=(1.0-0.9*clamp(shadowIsland(wp, L, NEAR, 10.0), 0.08, 1.0));\n        color *=(1.0-0.6*clamp(shadowOcean(wp, L, NEAR, 10.0), 0.01, 1.0));\n\n        //color = vec3(normalize(rdrfl.xy), 0.0);\n        //color = reflcolor;\n        //color = normalize(ro+rdrfl*dIMirror);\n        //color = vec3(shadowIsland(wp, -_light.d, NEAR, 20.0));\n        //color = -_light.d;\n    }\n    return color;\n}\n\nvec3 rendering(vec3 ro, vec3 rd, vec2 uv, float d, float dI, vec3 normal) {\n    float dn = (FAR-d)/(FAR-NEAR);\n    float dIn = (FAR-d)/(FAR-NEAR);\n    vec3 p = ro+rd*d;\n    vec3 pI = ro+rd*dI;\n    vec3 n = normalize(normal.xyz);\n    vec3 color = vec3(0.0);\n    vec3 L = -_light.d;\n    float daynight = sin(TIME);\n    if(daynight<0.0)\n        L = normalize(vec3(0.0, 1.0, 0.0));\n    float foamHeight = 1.0/length(p-pI);\n    //return vec3(foamHeight);\n    #ifndef USE_FAKEDREAL_WATER\n    float waterLevel = getWaterLevel(p);\n    #endif\n    if(dn<=0.8 && dI>FAR)\n    {\n        color = getSkyColor(p, rd);\n    }\n    else if(dn>0.8 && dn<=0.82 && dI>FAR)\n    {\n        color = mix(\n            \tgetSkyColor(p, rd),\n            \tgetEarthColor(ro, rd, p, pI, n, d, dI, L, uv),\n            \t(dn-0.8)/0.02);\n    }\n    else\n    {\n        color = getEarthColor(ro, rd, p, pI, n, d, dI, L, uv);\n    }\n    return tonemapping(color);\n}\n\n// the camera construction method is inspired by the one from IQ\nmat3 setCamera( in vec3 origin, in vec3 target, vec3 viewUp )\n{\n\tvec3 cw = normalize(target-origin);\n\tvec3 cu = normalize( cross(cw,viewUp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy /iResolution.xy;\n    vec2 pixel = -1.0 + 2.0*uv;// vec2(iResolution.x*0.6, iResolution.y);\n\tpixel.x *= iResolution.x/iResolution.y;\n\n    \n    vec3 ro = CAMPOS;\n    //#ifndef CAMERA_CONTROLLED\n        ro.x = cos(CAMERATIME)*CAMERADIST;\n        ro.z = sin(CAMERATIME)*CAMERADIST;\n    //#endif\n    vec3 rd = normalize(vec3(pixel, 1.0));\n    \n    mat3 ca = setCamera(ro, TARGETPOS, vec3(0.0, 1.0, 0.0));\n    rd = ca*normalize(vec3(pixel.xy, 2.0));\n    \n    #ifdef CAMERA_CONTROLLED\n    vec2 mv = 3.5*(-1.0 + 2.0*iMouse.xy/iResolution.xy);\n    ro = RotYV3(ro, mv.x);\n    rd = RotYV3(rd, mv.x);\n    #endif\n    \n    vec3 color = vec3(0.0);\n    vec4 gbuff = texture(iChannel0, uv);\n    \n    float depth = gbuff.x;\n    float depthIsland = gbuff.y;\n    vec3 n = normalize(vec3(gbuff.z, 0.001, gbuff.w));\n    \n\t_light.o = normalize(vec3(cos(TIME), sin(TIME), 0.0))*149597870700.0;\n    \n    /*_light.o = mat3(0.0, -sin(TIME), cos(TIME),\n                    0.0, cos(TIME), sin(TIME),\n                    0.0\t\t, 0.0\t\t, 1.0)*_light.o;*/\n    \n    \n    _light.d = normalize(EARTHPOS-_light.o);\n    \n    color = rendering(ro, rd, uv, depth, depthIsland, n);\n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/***********************************************************************\n * author: pierre.plans@gmail.com\n ***********************************************************************/\n\n/**\n * CAMERA BEHAVIOUR RELATED CONSTANTS\n **/\n#define CAMERA_CONTROLLED\n#define NEAR 0.01\n#define FAR 500.0\n\n#define TIME iTime*0.2\n#define CAMERATIME TIME*0.1\n#define CAMERADIST max(0.7, sin(CAMERATIME))*20.0\n\n#define RAYMARCHING_NUM_STEPS 60\n\n//\n\n#define CAMPOS vec3(2.0, 3.5, 12.0)\n#define TARGETPOS vec3(2.0, 1.0, 2.0)\n\n#define ISLANDPOS vec3(3.0, 0.0, -1.0)\n\n#define TYPE_WATER 0.0\n#define TYPE_ISLAND 1.0\n\n#define NOISEFUNC(x) noise3D(x*6.0)\n//#define NOISEFUNC(x) voronoi3D(x*3.0)\n\n// costly\n#define USE_FAKEDREAL_WATER\n\n\nvec3 RotXV3(in vec3 P, float A)\n{\n    float cA = cos(A), sA = sin(A);\n    return P*mat3(1.0, 0.0, 0.0, 0.0, cA, -sA, 0.0, sA, cA);\n}\nvec3 RotYV3(in vec3 P, float A)\n{\n    float cA = cos(A), sA = sin(A);\n    return P*mat3(cA, 0.0, -sA, 0.0, 1.0, 0.0, sA, 0.0, cA);\n}\n\n\nfloat hash1D(float x)\n{\n \treturn fract(sin(x*13.14434)*1.40503503);   \n}\n\nfloat hash2D(vec2 x) {\n\treturn fract(sin(dot(x, vec2(13.454, 7.405)))*12.3043);\n}\n\nfloat hash3D(vec3 x) {\n\treturn fract(dot(x, vec3(12.4955, 10.4294, 42.40594))*13.4959451);    \n}\n\nfloat voronoi2D(vec2 uv) {\n    vec2 fl = floor(uv);\n    vec2 fr = fract(uv);\n    float res = 1.0;\n    for( int j=-1; j<=1; j++ ) {\n        for( int i=-1; i<=1; i++ ) {\n            vec2 p = vec2(i, j);\n            float h = hash2D(fl+p);\n            vec2 vp = p-fr+h;\n            float d = dot(vp, vp);\n            \n            res +=1.0/pow(d, 8.0);\n        }\n    }\n    return pow( 1.0/res, 1.0/16.0 );\n}\n\nfloat waterNoise(vec2 x) {\n    vec2 p = floor(x);\n    vec2 n = fract(x);\n    vec2 f = n*n*(3.0-2.0*n);\n    float winx = 1.0;\n    float winy = 1.0;\n    \n    return mix(\n                mix(hash2D(p)     , hash2D(p+vec2(winx, 0.0)), f.x),\n                mix(hash2D(p+vec2(0.0, winy)), hash2D(p+vec2(winx, winy)), f.x),\n                f.y);\n}\n\nfloat smoothNoise2D(vec2 x) {\n    vec2 p = floor(x);\n    vec2 n = fract(x);\n    vec2 f = n*n*(3.0-2.0*n);\n    float winx = 1.0;\n    float winy = 70.0;\n    \n    float wx = p.x*winx+winy*p.y;\n    return mix(\n                mix(hash1D(wx+0.0)     ,      hash1D(wx+1.0), f.x),\n                mix(hash1D(wx+0.0+winy), \thash1D(wx+1.0+winy), f.x),\n                f.y);\n}\n\nfloat smoothNoise(vec3 x) {\n    vec3 p = floor(x);\n    vec3 n = fract(x);\n    vec3 f = n*n*(3.0-2.0*n);\n    float winy = 157.0;\n    float winz = 113.0;\n    \n    float wx = p.x+winy*p.y+winz*p.z;\n    return mix(\n        \tmix(\n                mix(hash1D(wx+0.0)     ,      hash1D(wx+1.0), f.x),\n                mix(hash1D(wx+0.0+winy), \thash1D(wx+1.0+winy), f.x),\n                f.y),\n        \tmix(\n                mix(hash1D(wx+0.0+winz)     ,      hash1D(wx+1.0+winz), f.x),\n                mix(hash1D(wx+0.0+winy+winz), hash1D(wx+1.0+winy+winz), f.x),\n                f.y)\n        , f.z);\n}\n\n// Simplex 2D noise\n// sources: Ian McEwan - https://github.com/ashima/webgl-noise/blob/master/src/noise2D.glsl\n// sources: Patricio Gonzalez Vivo - https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\nfloat snoise(vec2 v){\n    const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n                        -0.577350269189626, 0.024390243902439);\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod(i, 289.0);\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n                     + i.x + vec3(0.0, i1.x, 1.0 ));\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n                            dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n//  Simplex 3D Noise \n//  by Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v){ \n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    // First corner\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n    // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    //  x0 = x0 - 0. + 0.0 * C \n    vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n    vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n    vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n    // Permutations\n    i = mod(i, 289.0 ); \n    vec4 p = permute( permute( permute( \n        i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n                              + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n                     + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n    // Gradients\n    // ( N*N points uniformly over a square, mapped onto an octahedron.)\n    float n_ = 1.0/7.0; // N=7\n    vec3  ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n    //Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    // Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                 dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat noise3D(vec3 x) {\n    vec3 p = floor(x);\n    vec3 n = fract(x);\n    vec3 f = n*n*(3.0-2.0*n);\n    float winx = 1.0;\n    float winy = 1.0;\n    float winz = 1.0;\n    \n    return mix(\n        \tmix(\n                mix(hash3D(p)     \t\t\t\t  , hash3D(p+vec3(winx, 0.0, 0.0)), f.x),\n                mix(hash3D(p+vec3(0.0, winy, 0.0)), hash3D(p+vec3(winx, winy, 0.0)), f.x),\n                f.y),\n        \tmix(\n                mix(hash3D(p+vec3(0.0, 0.0, winz)), hash3D(p+vec3(winx, 0.0, winz)), f.x),\n                mix(hash3D(p+vec3(0.0, winy, winz)), hash3D(p+vec3(winx, winy, winz)), f.x),\n                f.y),\n   \t\t\tf.z);\n}\n\n/**\n * This one is inspired by IQ code from this website.\n **/\nfloat fbm2D(vec2 p) {\n    float total = 0.0;\n    total  = 0.5000* snoise(p); p = p*2.0;\n    total += 0.2500* snoise(p); p = p*2.0;\n    total += 0.1250* snoise(p); p = p*2.0;\n    total += 0.0625* snoise(p); p = p*2.0;\n    return total;\n}\n\nfloat fbm3D(vec3 p)\n{\n    float total = 0.0;\n    total  = 0.5000* smoothNoise(p); p = p*2.0;\n    total += 0.2500* smoothNoise(p); p = p*2.0;\n    total += 0.1250* smoothNoise(p); p = p*2.0;\n    total += 0.0625* smoothNoise(p); p = p*2.0;\n    return total;\n}\n\n/**\n * PRIMITIVES\n **/\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float r )\n{\n    return length(p)-r;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdPlainTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdCappedCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 v = vec2( c.z*c.y/c.x, -c.z );\n    vec2 w = v - q;\n    vec2 vv = vec2( dot(v,v), v.x*v.x );\n    vec2 qv = vec2( dot(v,w), v.x*w.x );\n    vec2 d = max(qv,0.0)*qv/vv;\n    return sqrt( dot(w,w) - max(d.x,d.y) )* sign(max(q.y*v.x-q.x*v.y,w.y));\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\n/**\n * (Distance, Type) with Type =\n * 0.0 == Nthg\n **/\n\n/***********************\n * PRIMITIVE OPERATIONS\n ***********************/\n\n// polynomial smooth min (k = 0.1);\nvec2 polsmin( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return vec2(mix( b.x, a.x, h ) - k*h*(1.0-h), floor(mix( b.y, a.y, h )*2.0));\n}\n\n// polynomial smooth min (k = 0.1);\nvec2 polsmax( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return vec2(mix( b.x, a.x, 1.0-h ) - k*h*(1.0-h), floor(mix( b.y, a.y, 1.0-h )*2.0));\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 opI( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x>d2.x) ? d1 : d2;\n}\n\nvec2 opS( vec2 d1, vec2 d2 )\n{\n    float dmax = max(-d1.x, d2.x);\n\treturn abs(d1.x-dmax)<0.01?d1:d2;\n}\n\n/*******************\n * DEPTH MAP + TYPE\n *******************/\n\nfloat _mapIsland(vec3 p) {\n    p.y += voronoi2D(p.xz);\n    float d = sdEllipsoid(p, vec3(8.0, 16.0, 8.0));\n    \n    float di = length(p);\n    \n    return d+di+voronoi2D(p.xz*6.0)*0.2;\n}\n\nfloat getWaterLevel(vec3 p)\n{\n    float h = -1.5;\n    float a = 2.0;\n    h += p.y+0.0;\n    \n    vec2 ws = 0.001*vec2(TIME*580.0, TIME*400.0);\n    \n    h += 0.04*sin(p.x*0.8+ws.x);\n    h += 0.02*sin(p.x*0.7+p.y*0.65+ws.y*1.1);\n    h -= 0.005*sin(p.x*0.60+p.y*0.57+ws.y*0.9);\n    \n    h += 0.0025*sin(p.x*0.43+p.y*0.38+ws.y*3.0);\n    h += 0.001*sin(p.x*0.34+p.y*0.29+ws.y*4.0);\n    h *= a;\n    \n    h -= fbm2D(p.xz*0.6-ws.x*1.2)*0.1;\n    float f = 4.0;\n    a = 1.4;\n    for(int i=0;i<3;++i) {\n        h -= smoothNoise2D(p.xz*0.1*f+ws.y*2.0)*a;\n        a *= 0.1;\n        f *= 1.2;\n    }\n\n    return h;\n}\n\nvec2 map(vec3 p) {\n    vec2 d = vec2(-1.0, -1.0);\n    #ifdef USE_FAKEDREAL_WATER\n    d = vec2(getWaterLevel(p), TYPE_WATER);\n    #else\n    d = vec2(sdPlane(p-vec3(0.0, -1.0, 0.0)), TYPE_WATER);\n    #endif\n    //d = opU(d, vec2(mapIsland(p-vec3(0.0, 0.0, 0.0)), TYPE_ISLAND));\n    \n    return d;\n}\n\nvec2 mapIsland(vec3 p) {\n    vec2 d = vec2(-1.0, -1.0);\n    d = vec2(_mapIsland(p-ISLANDPOS), TYPE_ISLAND);\n    \n    return d;\n}\n\nvec3 mapNormal(vec3 pt, float e) {\n    vec3 normal;\n    normal.y = map(pt).x;\n    normal.x = map(vec3(pt.x+e,pt.y,pt.z)).x - normal.y;\n    normal.z = map(vec3(pt.x,pt.y,pt.z+e)).x - normal.y;\n    normal.y = e;\n    return normalize(normal);\n}\n\nvec3 mapNormalIsland(vec3 pt, float e) {\n    vec3 normal;\n    normal.y = mapIsland(pt).x;\n    normal.x = mapIsland(vec3(pt.x+e,pt.y,pt.z)).x - normal.y;\n    normal.z = mapIsland(vec3(pt.x,pt.y,pt.z+e)).x - normal.y;\n    normal.y = e;\n    return normalize(normal);\n}\n\n\n/**********************\n * RAYMARCHING\n **********************/\n\nvec2 raymarch(vec3 ro, vec3 rd, in float tmin, in float tmax) {\n    vec2 m = vec2(-1.0, -1.0);\n    vec2 res = vec2(tmin, -1.0);\n\tfor( int i=0; i<RAYMARCHING_NUM_STEPS; i++ )\n\t{\n        m = map(ro + res.x*rd);\n\t\tif( abs(m.x)<tmin || res.x>tmax ) break;\n\t\tres.x += 0.5*m.x;\n        res.y = m.y;\n\t}\n    if( res.x>tmax ) res.y=-1.0;\n\treturn res;\n}\n\nvec2 raymarchIsland(vec3 ro, vec3 rd, in float tmin, in float tmax) {\n    vec2 m = vec2(-1.0, -1.0);\n    vec2 res = vec2(tmin, -1.0);\n\tfor( int i=0; i<RAYMARCHING_NUM_STEPS; i++ )\n\t{\n        m = mapIsland(ro + res.x*rd);\n\t\tif( abs(m.x)<tmin || res.x>tmax ) break;\n\t\tres.x += 0.5*m.x;\n        res.y = m.y;\n\t}\n    if( res.x>tmax ) res.y=-1.0;\n\treturn res;\n}\n\n// the camera construction method is inspired by the one from IQ\nmat3 setCamera( in vec3 origin, in vec3 target, vec3 viewUp )\n{\n\tvec3 cw = normalize(target-origin);\n\tvec3 cu = normalize( cross(cw,viewUp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy /iResolution.xy;\n    vec2 pixel = -1.0 + 2.0*uv;// vec2(iResolution.x*0.6, iResolution.y);\n\tpixel.x *= iResolution.x/iResolution.y;\n\n    \n    vec3 ro = CAMPOS;\n    //#ifndef CAMERA_CONTROLLED\n        ro.x = cos(CAMERATIME)*CAMERADIST;\n        ro.z = sin(CAMERATIME)*CAMERADIST;\n    //#endif\n    vec3 rd = normalize(vec3(pixel, 1.0));\n    \n    mat3 ca = setCamera(ro, TARGETPOS, vec3(0.0, 1.0, 0.0));\n    rd = ca*normalize(vec3(pixel.xy, 2.0));\n    \n    #ifdef CAMERA_CONTROLLED\n    vec2 mv = 3.5*(-1.0 + 2.0*iMouse.xy/iResolution.xy);\n    ro = RotYV3(ro, mv.x);\n    rd = RotYV3(rd, mv.x);\n    #endif\n\n    vec2 rm = vec2(FAR, -1.0);\n    rm = raymarch(ro, rd, NEAR, FAR);\n    vec2 rmi = vec2(FAR, -1.0);\n    rmi = raymarchIsland(ro, rd, NEAR, FAR);\n    float normalized = (FAR-rm.x)/(FAR-NEAR);\n    //if(length(ro+rd*rm.x)<2.5) rm.y = abs(1.0/length(ro+rd*rm.x));//0.5;\n    vec3 n = mapNormalIsland(ro+rd*rmi.x, 0.001);\n    fragColor = vec4(rm.x, rmi.x, n.x, n.z);\n}","name":"Buf A","description":"","type":"buffer"}]}