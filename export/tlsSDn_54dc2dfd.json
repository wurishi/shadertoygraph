{"ver":"0.1","info":{"id":"tlsSDn","date":"1659618878","viewed":104,"name":"Parametric rose","username":"nkaretnikov","description":"Parametric rose.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d","rose","parametric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Public domain or CC0.\n\n// Constants.\nconst float pi = acos(-1.);   \n\n// Colors.\nconst vec3 black = vec3(0.);\nconst vec3 white = vec3(1.);\nconst vec3 red   = vec3(1., 0., 0.);\nconst vec3 green = vec3(0., 1., 0.);\nconst vec3 blue  = vec3(0., 0., 1.);\n\n// Parametric equation of a rose.\n// https://en.wikipedia.org/wiki/Rose_(mathematics)\nvec2 pRose(float r, float t, float n)\n{\n    float x = r * cos(n * t) * cos(t);\n    float y = r * cos(n * t) * sin(t);\n    return vec2(x, y);\n}\n\n// Draw a rose.\nvec3 rose(vec3 color, vec2 uv, float pos, float r, float n, float blur)\n{    \n    vec3 res = white;\n    \n    float eps = .01;\n    \n    // XXX: Note: this is very slow because it samples a bunch of points.\n    // That's not the most efficient way to draw on the GPU.\n    // But the parametric form makes it quite easy to work with.\n    \n    // Change the bounds of 't' to draw a part of a rose.\n    for (float t = 0.; t < 12. * pi; t += eps) {\n        // Bounds.\n        vec2 c1 = pRose(pos,     t, n);\n        vec2 c2 = pRose(pos - r, t, n);\n        \n        // Find if a point belongs to a section using the triangle\n        // inequality (comparing to 'eps' due to floating-point).\n        float d1 = distance(c2, uv);\n        float d2 = distance(uv, c1);\n        float d3 = distance(c2, c1);\n\n        \n\t\tif (abs(d1 + d2 - d3) < eps) {\n            res = color;\n            res -= d1;  // shading\n            res += d2;\n            break;\n        }\n        else res -= color;\n    }\n    \n    return res;\n}\n\n// Draw a point.\nvec3 point(vec3 color, vec2 uv, float pos, float r, float t, float n, float blur)\n{  \n\t// Bounds.\n    vec2 c1 = pRose(pos,     t, n);\n    vec2 c2 = pRose(pos - r, t, n);\n\n    // Multiplying one of the arguments by -1 shifts it by pi.\n    float d1 = distance(uv, c1);\n    float d2 = distance(c1, c2);\n    \n    // XXX: Do not invert colors when 'blur' == 1.\n    vec3 res = vec3(smoothstep(d2, d2 * blur, d1));\n    \n    return res * color;\n}\n    \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1).\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Move 0.0 to the center.\n    uv -= .5;\n    \n    // Account for the screen ratio.\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Output color.\n    vec3 color = black;\n    \n    color += red;\n    \n    // float n = 7./9.; // petals\n    float n = mod(iTime*.001,7.)/(.1+mod(iTime*.001,9.));\n    // float n = sin(iTime*.001)/.1+sin(iTime*.001);\n    color -= rose(red - blue, uv, .5, .1, n, .9);\n    \n    // Without a loop, the parametric equation gives a point\n    // on a rose, which can be used to create a rotating point.\n\t//\n\t// Multiplying 't' by -1 makes it move counterclockwise.\n\t// Multiplying 'iTime' changes the rotation speed.\n    \n    // float t = pi;  // fixed position\n    float speed = .5;\n    float t = mod(iTime * speed, 12. * pi);  // rotate\n    color -= point(red + blue - green, uv, .45, .01, t, n, .9);\n    \n    // Output to screen.\n    fragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"}]}