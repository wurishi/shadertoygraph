{"ver":"0.1","info":{"id":"McV3zV","date":"1713063751","viewed":21,"name":"sdf rounded ploygon","username":"letbonsaibe","description":"sdf rounded ploygon","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define WHITE vec3(1.0, 1.0, 1.0)\n#define OCOLOR vec3(0.9,0.6,0.3) \n#define ICOLOR vec3(0.65,0.85,1.0)\n#define PI    3.141592653\n#define PI2   6.283185306 \n\n\nfloat vector_angle(vec2 iAxis, vec2 v) {\n    float theta = acos(dot(iAxis, v) / length(iAxis) / length(v));\n    float crossV = iAxis.x * v.y - iAxis.y * v.x;\n    if (crossV < 0.0) {\n      return PI * 2.0 - theta;\n    } else {\n      return theta;\n    }\n}\n\n\nfloat sdf_rectangle(vec2 pct, vec2 wh) {\n  vec2 dxy = abs(pct) - wh;\n  return length(max(dxy, 0.0)) +  // one of (dx, dy) greater than 0 \n          max(min(dxy.x, 0.0), min(dxy.y, 0.0)); // dx, dy lower than 0\n}\n\nfloat sdf_circle(vec2 p, float r) {\n    return length(p) - r;\n}\n\n\nvec2 symmetrical_point(vec2 P, vec2 V) {\n    vec2 V_normalized = normalize(V);\n    vec2 H = dot(P, V_normalized) * V_normalized;\n    vec2 PH_vector = H - P;\n    vec2 PP = P + 2.0 * PH_vector;\n    return PP;\n}\n\n\nvec2 cartesianToPolar(vec2 cartesianCoords) {\n    float r = length(cartesianCoords); // Radial distance\n    float theta = atan(cartesianCoords.y, cartesianCoords.x); // Angle in radians\n\n    return vec2(r, theta);\n}\n\n\nvec2 polarToCartesian(vec2 polarCoords) {\n    float x = polarCoords.x * cos(polarCoords.y); // r * cos(theta)\n    float y = polarCoords.x * sin(polarCoords.y); // r * sin(theta)\n\n    return vec2(x, y);\n}\n\nfloat cross2(vec2 a, vec2 b) {return a.x * b.y - b.x * a.y;}\n\n\n\nfloat sdf_star(vec2 P, float outRadius, float inRadius, int sides) {\n    float angle = atan(P.y, P.x);\n    angle = P.y > 0. ? angle: angle + PI * 2.;\n    \n    float delta = 2. * PI / float(sides);\n    float theta = mod(angle, delta) - delta / 2.0;\n    float pieceIdx = floor(angle / delta);\n\n    // start angle of current piece\n    float theta3 = delta * pieceIdx;\n    vec2 polar_P1 = vec2(outRadius, theta3);    \n    vec2 polar_P4 = vec2(inRadius, delta/2.0+theta3);\n    \n    // p and symmetrical p\n    float theta2 = delta / 2.0 - abs(theta) + theta3;    \n    vec2 polar_P = vec2(length(P), theta2); \n    \n    vec2 P0 = polarToCartesian(polar_P);\n    vec2 P1=polarToCartesian(polar_P1);\n    vec2 P4=polarToCartesian(polar_P4);\n\n    vec2 v1 = P0 - P4;\n    vec2 v2 = P1 - P4;\n    float h = clamp(dot(v1,v2)/dot(v2,v2), 0.0, 1.0);\n    \n     \n    return sign(cross2(v2, v1)) * length(v1-h*v2); \n\n}\n\nfloat rounded_polygon(vec2 P, float radius, int sides) {\n    // get polar angle\n    float angle = atan(P.y, P.x);\n    // make angle to range [0, 2*PI]\n    angle = P.y > 0. ? angle: angle + PI * 2.;\n\n    // get each piece angle\n    float delta = 2. * PI / float(sides);\n    // how many pieces?\n    float areaNumber = floor(angle / delta);\n    \n    // start angle of current piece\n    float theta1 = delta * areaNumber;\n    // end angle of current piece\n    float theta2 = delta * (areaNumber + 1.0);\n   \n    \n    \n    float roundR = -abs(sin(iTime / 2.)) * 1.5  ;\n    float radius2 = -radius - roundR;\n    radius2 = -abs(radius2);\n\n    // start point on current piece\n    vec2 POINT_A       = vec2(radius2  * cos(theta1), radius2 * sin(theta1) );\n    // end point on current piece\n    vec2 POINT_A_Prime = vec2(radius2 * cos(theta2), radius2 * sin(theta2) );\n    // the middle of startPoint and endPoint\n    vec2 POINT_D       = (POINT_A + POINT_A_Prime)/2.0;\n    // corrdinate center\n    vec2 POINT_O       = vec2(0.0); \n    // start axis of current piece\n    vec2 iAxis1   =  vec2(-POINT_O+POINT_A);\n    \n    \n\n    for (int i=0; i<2; i++) {\n        vec2 PP = P;\n        if (i==1) {     // symmetrical for area2\n            PP = symmetrical_point(P, POINT_D);\n        }\n     \n        \n        vec2 vector1  = vec2(PP - POINT_A);\n        float a1 = vector_angle(iAxis1, vector1);\n        if (a1 <  (delta / 2.0)) {\n            return length(vector1)-roundR * abs(cos(delta/2.)) ;\n        }\n    }\n    \n    \n    // area 3 \n    float theta = mod(angle, delta) - delta / 2.0;\n    float l1 =  (length(P) + roundR) * cos(theta) - length(POINT_D) - roundR;\n    return l1;\n}\n\n\n\n\n\n\nvoid wave(float dist, inout vec3 color) {\n    color *= .8  + 0.2 * sin(dist * 50.0 - iTime * 5.0);\n}\n\nvoid border(float dist, inout vec3 color) {\n    color *= 1.0 - exp(-40.0 * abs(dist));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    // convert screen to [-1, 1] coordinate\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    int n = int(abs(sin(iTime / 5.0)) * 5.0) + 3;\n    \n    float dist = rounded_polygon(uv, 0.9, 6);\n    \n    \n    vec3 finalColor = dist > 0.0 ? OCOLOR: ICOLOR;\n    \n    border(dist, finalColor);\n    wave(dist, finalColor);\n    \n   \n    fragColor = vec4(finalColor, 0.);\n    \n}","name":"Image","description":"","type":"image"}]}