{"ver":"0.1","info":{"id":"Xscyz7","date":"1518145678","viewed":208,"name":"Dobrar a meta (EC)","username":"mmutai","description":"Part 1: https://www.shadertoy.com/view/4s3cRM\nI wish there was more room in the description. Then I could tell you all the wonders of Dilma's speech about the \"meta\". For now, I will leave you with this:\nWhen we hit the \"meta\", we will double the \"meta\".","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","metaballs","metaball"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Extra credit #defines -- uncomment only one of these!\n//#define NORMALS\n//#define CUBEMAP\n#define BLINN_PHONG\n\nconst float PI = 3.14159265;\nconst vec3 BG_COLOR = vec3(0.2, 0.2, 0.2);\nconst vec3 BALL_COLOR = vec3(0.97, 0.25, 0.04);\nconst float THRESHOLD = 3.4;\nconst float BLEND_EPSILON = 0.05;\n\nconst float DIR_LEN = 0.75;\nconst float HALF_SQRT2 = 0.70710678118;\nconst vec3 DIR1 = (vec3(+0.0, +1.0, 0.0)) * DIR_LEN;\nconst vec3 DIR2 = (vec3(-HALF_SQRT2, +HALF_SQRT2, 0.0)) * DIR_LEN;\nconst vec3 DIR3 = (vec3(-1.0, +0.0, 0.0)) * DIR_LEN;\nconst vec3 DIR4 = (vec3(-HALF_SQRT2, -HALF_SQRT2, 0.0)) * DIR_LEN;\nconst vec3 DIR5 = (vec3(+0.0, -1.0, 0.0)) * DIR_LEN;\nconst vec3 DIR6 = (vec3(+HALF_SQRT2, -HALF_SQRT2, 0.0)) * DIR_LEN;\nconst vec3 DIR7 = (vec3(+1.0, +0.0, 0.0)) * DIR_LEN;\nconst vec3 DIR8 = (vec3(+HALF_SQRT2, +HALF_SQRT2, 0.0)) * DIR_LEN;\n// some browsers don't like normalize() in const declarations?\n/*\nconst vec2 DIR1 = normalize(vec2(+0.0, +1.0)) * DIR_LEN;\nconst vec2 DIR2 = normalize(vec2(-1.0, +1.0)) * DIR_LEN;\nconst vec2 DIR3 = normalize(vec2(-1.0, +0.0)) * DIR_LEN;\nconst vec2 DIR4 = normalize(vec2(-1.0, -1.0)) * DIR_LEN;\nconst vec2 DIR5 = normalize(vec2(+0.0, -1.0)) * DIR_LEN;\nconst vec2 DIR6 = normalize(vec2(+1.0, -1.0)) * DIR_LEN;\nconst vec2 DIR7 = normalize(vec2(+1.0, +0.0)) * DIR_LEN;\nconst vec2 DIR8 = normalize(vec2(+1.0, +1.0)) * DIR_LEN;\n*/\n\nconst float TIME_OFFSET = -PI * 0.25;\n\n#define U_TIME (iTime * 0.44)\n\n// don't eat uncooked metaballs\nfloat rawMetaball(vec3 p, vec3 center, float radius) {\n    return radius / distance(p, center);\n}\n\n// anime metaball, or ~metaballon anim√©~\nfloat aniMetaball(vec3 p, vec3 dir, float radius, float timeOffset) {\n\tfloat dist = cos(U_TIME * PI + timeOffset) * 0.5 + 0.5;\n    //dist = pow(dist, 1.1);\n    vec3 center = dir * dist;\n    return rawMetaball(p, center, radius);\n}\n\n\nfloat metaStep(vec3 p, out float minDist) {\n    float metaSum = 0.0;\n    float thisVal = 0.0;\n    float minVal = 10000000.0;\n    thisVal = rawMetaball(p, vec3(0.0), 0.08);\n    minVal = min(minVal, thisVal);\n    metaSum += thisVal;\n    thisVal = aniMetaball(p, DIR1, 0.16, 0.0);\n    minVal = min(minVal, thisVal);\n    metaSum += thisVal;\n    thisVal = aniMetaball(p, DIR2, 0.16, TIME_OFFSET);\n    minVal = min(minVal, thisVal);\n    metaSum += thisVal;\n    thisVal = aniMetaball(p, DIR3, 0.16, TIME_OFFSET * 2.0);\n    minVal = min(minVal, thisVal);\n    metaSum += thisVal;\n    thisVal = aniMetaball(p, DIR4, 0.16, TIME_OFFSET * 3.0);\n    minVal = min(minVal, thisVal);\n    metaSum += thisVal;\n    thisVal = aniMetaball(p, DIR5, 0.16, TIME_OFFSET * 4.0);\n    minVal = min(minVal, thisVal);\n    metaSum += thisVal;\n    thisVal = aniMetaball(p, DIR6, 0.16, TIME_OFFSET * 5.0);\n    minVal = min(minVal, thisVal);\n    metaSum += thisVal;\n    thisVal = aniMetaball(p, DIR7, 0.16, TIME_OFFSET * 6.0);\n    minVal = min(minVal, thisVal);\n    metaSum += thisVal;\n    thisVal = aniMetaball(p, DIR8, 0.16, TIME_OFFSET * 7.0);   \n    minVal = min(minVal, thisVal);\n    metaSum += thisVal;\n    \n    minDist = minVal;\n    return metaSum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n        \n    vec2 p = uv * 2.0 - 1.0;\n    p.x *= iResolution.x / iResolution.y;\n\n\tfloat metaSum;\n\tfloat t = 0.0;\n\tfloat minDist;\n    \n    vec3 rayO = vec3(p, -0.5);\n    vec3 rayD = vec3(0.0, 0.0, 1.0);\n    \n    for (int i = 0; i < 200; i++) {\n        metaSum = metaStep(rayO + rayD * t, minDist);\n        if (metaSum >= THRESHOLD) {\n            break; \n        } \n        t += 0.005;//minDist * 0.1;\n    }\n    \n    vec3 bgCol = BG_COLOR;\n#ifdef CUBEMAP\n\tbgCol = texture(iChannel0, normalize(vec3(p, 0.5))).xyz;    \n#endif\n    vec3 col = bgCol;\n    \n    // estimate normal\n    vec3 rayP = rayO + rayD * t;\n    const float NOR_EPSILON = 0.01;\n    \n    float xL = metaStep(rayP + vec3(-NOR_EPSILON, 0.0, 0.0), minDist);\n    float xH = metaStep(rayP + vec3(+NOR_EPSILON, 0.0, 0.0), minDist);\n    float yL = metaStep(rayP + vec3(0.0, -NOR_EPSILON, 0.0), minDist);\n    float yH = metaStep(rayP + vec3(0.0, +NOR_EPSILON, 0.0), minDist);\n    float zL = metaStep(rayP + vec3(0.0, 0.0, -NOR_EPSILON), minDist);\n    float zH = metaStep(rayP + vec3(0.0, 0.0, +NOR_EPSILON), minDist);\n    \n    vec3 nor = normalize(vec3(xL - xH, yL - yH, zL - zH));\n    vec3 lightDir = normalize(vec3(1, 1, -2));\n    const vec3 eyeDir = vec3(0, 0, -1);\n    \n    if (metaSum >= THRESHOLD) {\n        //col = mix(BG_COLOR, vec3(0.1), smoothstep(0.0, BLEND_EPSILON, metaSum - THRESHOLD)); \n#ifdef NORMALS\n        col = nor * 0.5 + 0.5;\n        \n#elif defined(CUBEMAP)\n        vec4 amb = texture(iChannel0, nor * 0.5 + 0.5);\n        col = amb.xyz;\n#elif defined(BLINN_PHONG)\n        col = BALL_COLOR * clamp(dot(nor, lightDir), 0.0, 1.0);\n        float spec = pow(max(0.0, dot(lightDir, normalize(nor + eyeDir))), 16.0);\n        col += vec3(spec);\n#else\n        col = BALL_COLOR;\n#endif\n        // blend like it's 2D\n        metaSum = metaStep(vec3(p, 0.0), minDist);\n        col = mix(bgCol, col, smoothstep(0.0, BLEND_EPSILON, metaSum - THRESHOLD)); \n        //col = vec3((metaSum / 2.2) - 1.0);\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}