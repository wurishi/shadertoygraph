{"ver":"0.1","info":{"id":"llfcDs","date":"1650924960","viewed":98,"name":"WIP / Abandoned Cauldron","username":"ssell","description":"I meant to make and release a spooky shader for Halloween of 2018 and never finished it (and honestly never will).\n\nBut why not make it public? Think its still kinda neat looking.","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["cauldronspookyhalloween"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\nTo-Do:\n\n - Potion surface/bubble displacement\n - Area light for surface\n - Cast-iron material for cauldron body\n - Add legs to cauldron\n - Add fire below cauldron\n - Rest of room (minimal due to final expected scene lighting)\n - Fire particle effect\n - Billowing fume particle effect\n \n\n\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n\tfragColor     = texture(iChannel0, uv);\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0 / 2.2));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/**\n * ao, thick, shadow, \n *\n *     .r = id.depth\n *     .g = \n *     .b = \n *     .a = packed norm\n */\n\n#define Epsilon              0.001\n#define NearClip             Epsilon\n#define FarClip              20.0\n#define MaxSteps             150\n#define PI                   3.14159\n#define SSSThicknessSamples  8.0\n#define SSSThicknessSamplesI 0.125\n\n#define MAT_None     0.0\n#define MAT_Cauldron 1.0\n#define MAT_Potion   2.0\n#define MAT_Tentacle 3.0\n\n#define IsMat(x,y) (int(x) == int(y))\n\n\nconst vec3 BackgroundColor = vec3(0.0015, 0.0015, 0.005);\nconst vec3 PotionLightPos  = vec3(0.0, 0.5, 0.0);\nconst vec3 PotionLightCol  = vec3(0.9, 1.5, 0.9);\nconst vec3 FireLightPos    = vec3(0.0, -1.5, 0.0);\nconst vec3 FireLightCol    = vec3(1.0, 1.0, 1.0);\nconst vec3 KeyLightDir     = normalize(vec3(1.0, 1.0, 0.0));\n\nconst float AOSteps     = 32.0;\nconst float AOStepsI    = 0.03125;\n\n\n//------------------------------------------------------------------------------------------\n// Utilities\n//------------------------------------------------------------------------------------------\n\nuint PackNormal(in vec3 nor, uint sh)\n{\n    nor /= ( abs( nor.x ) + abs( nor.y ) + abs( nor.z ) );\n    nor.xy = (nor.z >= 0.0) ? nor.xy : (1.0-abs(nor.yx))*sign(nor.xy);\n    vec2 v = 0.5 + 0.5*nor.xy;\n\n    uint mu = (1u<<sh)-1u;\n    uvec2 d = uvec2(floor(v*float(mu)+0.5));\n    return (d.y<<sh)|d.x;\n}\n\nmat3 RotMat(vec3 from, vec3 to)\n{\n    vec3  u     = normalize(cross(to, from));\n    float cosA  = dot(from, to);\n    float cosA1 = 1.0 - cosA;\n    float sinA  = sin(acos(cosA));\n    \n    mat3 mat;\n    mat[0] = vec3(cosA + (u.x * u.x) * cosA1,         (u.x * u.y) * cosA1 - (u.z * sinA), (u.x * u.z) * cosA1 + (u.y * sinA));\n\tmat[1] = vec3((u.y * u.x) * cosA1 + (u.z * sinA), cosA + (u.y * u.y) * cosA1,         (u.y * u.z) * cosA1 - (u.x * sinA));\n\tmat[2] = vec3((u.z * u.x) * cosA1 - (u.y * sinA), (u.z * u.y) * cosA1 + (u.x * sinA), cosA + (u.z * u.z) * cosA1);\n    \n    return mat;\n}\n\nvec3 MirrorVector(in vec3 v, in vec3 n)\n{\n    return v + 2.0 * n * max(0.0, -dot(n,v));\n}\n\nvec2 Hammersley(float i, float numSamples)\n{   \n    uint b = uint(i);\n    \n    b = (b << 16u) | (b >> 16u);\n    b = ((b & 0x55555555u) << 1u) | ((b & 0xAAAAAAAAu) >> 1u);\n    b = ((b & 0x33333333u) << 2u) | ((b & 0xCCCCCCCCu) >> 2u);\n    b = ((b & 0x0F0F0F0Fu) << 4u) | ((b & 0xF0F0F0F0u) >> 4u);\n    b = ((b & 0x00FF00FFu) << 8u) | ((b & 0xFF00FF00u) >> 8u);\n    \n    float radicalInverseVDC = float(b) * 2.3283064365386963e-10;\n    \n    return vec2((i / numSamples), radicalInverseVDC);\n} \n\nvec3 SampleHemisphere(float i, float numSamples)\n{\n\tvec2 xi = Hammersley(i, numSamples);\n    \n    float phi      = xi.y * 2.0 * PI;\n    float cosTheta = 1.0 - xi.x;\n    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n    \n    return vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);\n}\n\n// Dave_Hoskins hash functions (https://www.shadertoy.com/view/4djSRW)\nfloat Hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * 443.897);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 Hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(443.897, 441.423, 437.195));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n//------------------------------------------------------------------------------------------\n// Ray / Camera\n//------------------------------------------------------------------------------------------\n\nstruct Ray\n{\n    vec3 o;\n    vec3 d;\n};\n\nRay Ray_LookAt(in vec2 uv, in vec3 o, in vec3 d)\n{\n    vec3 forward = normalize(d - o);\n    vec3 right   = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up      = normalize(cross(right, forward));\n\n    uv    = (uv * 2.0) - 1.0;\n    uv.x *= (iResolution.x / iResolution.y);\n\n    Ray ray;\n    ray.o = o;\n    ray.d = normalize((uv.x * right) + (uv.y * up) + (forward * 2.0));\n\n    return ray;\n}\n\nvec3 OrbitAround(vec3 origin, float radius, float rate)\n{\n    float time = iTime + (PI * 2.0);\n  \treturn vec3((origin.x + (radius * cos(time * rate))), (origin.y), (origin.z + (radius * sin(time * rate))));\n}\n\nvec3 CameraPos()\n{\n\treturn vec3(0.0, 1.5, 2.75);//OrbitAround(vec3(0.0, 1.5, 0.0), 2.75, 0.25);\n}\n\n//------------------------------------------------------------------------------------------\n// Scene\n//------------------------------------------------------------------------------------------\n\nvec3 hash( vec3 x )\n{\n\tx = vec3( dot(x,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(x,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(x,vec3(113.5,271.9,124.6)));\n\n\treturn fract(sin(x)*43758.5453123);\n}\n\nfloat Bubbles(in vec3 pos, float y, float radius, float t)\n{\n    float modifier = 3.0;\n    \n    pos *= modifier;\n    pos.y = pos.y - y * modifier - t;\n    \n    vec3 p = floor(pos);\n    vec3 f = fract(pos);\n    \n    float c = FarClip;\n    float m = clamp((pos.y + t) / 15.0, 0.0, 1.0);\n    \n    float l = length(pos.xz);\n    float lp = clamp(l / (radius * modifier), 0.0, 1.0);\n    \n    float n = (lp < 0.9) ? 0.0 : mix(0.0, 1.0, (lp - 0.9) / 0.1);\n    \n    for(int k=-1; k<=1; k++)\n    {\n        for(int j=-1; j<=1; j++)\n        {\n            for(int i=-1; i<=1; i++)\n            {\n                vec3 b  = vec3( float(i), float(j), float(k) );\n                vec3 r  = b - f + hash(p + b);\n                float d = dot(r, r);\n                d = d - 0.02 * (1.0 - m);\n                \n                d = mix(d, 1.0, m);\n                d = mix(d, 1.0, n);\n                \n                c = min(c, d);\n            }\n        }\n    }\n\n    return c;\n}\n\nvec3 RotX(in vec3 p, float a)        \n{ \n    float s = sin(a); \n    float c = cos(a); \n    return vec3(p.x, (c * p.y) - (s * p.z), (s * p.y) + (c * p.z)); \n}\n\nvec3 RotZ(const in vec3 p, const in float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    \n    vec3 vResult = vec3((c * p.x) + (s * p.y), (-s * p.x) + (c * p.y), p.z);\n    \n    return vResult;\n}\n\nvec2 U(in vec2 d1, in vec2 d2) \n{ \n    return (d1.x < d2.x) ? d1 : d2; \n}\n\nfloat SU(in float a, in float b, in float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat Cylinder(in vec3 p, in vec2 h)\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat Ellipsoid(in vec3 p, in vec3 r)\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat Torus(in vec3 p, in vec2 t)\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat Capsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nvec2 Cauldron(in vec3 pos)\n{\n    float base  = max(length(pos) - 1.0, pos.y - 0.55);\n    float lip   = Cylinder(pos - vec3(0.0, 0.55, 0.0), vec2(1.0, 0.03));\n    float cauld = SU(base, lip, 0.15);\n    float cut   = Cylinder(pos - vec3(0.0, 0.6, 0.0), vec2(0.875, 0.75));\n    \n    vec3  hpos    = vec3(abs(pos.x), pos.y, pos.z);\n    float handles = min(Torus(RotZ(hpos - vec3(1.05, -0.1, 0.0), PI * 0.6), vec2(0.3, 0.03)),\n                        Torus(hpos - vec3(0.775, 0.175, 0.0), vec2(0.2, 0.05)));\n    \n    float result = max(min(cauld, handles), -cut);\n    \n    return vec2(result, MAT_Cauldron);\n}\n\nvec2 Potion(in vec3 pos)\n{\n    float bubbles = (abs(pos.y - 0.5) > 0.2) ? FarClip : Bubbles(pos, 0.45, 0.975, iTime * 0.9);\n    float surface = Cylinder(pos - vec3(0.0, 0.4, 0.0), vec2(0.875, 0.05));\n    \n    return vec2(SU(surface, bubbles, 0.025), MAT_Potion);\n}\n\nfloat TentacleSegment(in vec3 pos, in vec3 a, in vec3 b, in float ra, in float rb)\n{\n    vec3 pa = pos - a;\n    vec3 ba = b - a;\n    \n    float d = clamp(dot(ba, pa) / dot(ba, ba), 0.0, 1.0);\n    \n    return Capsule(pos, a, b, mix(ra, rb, d));\n}\n\nvec2 Tentacle(in vec3 pos)\n{\n    //float segmentA = TentacleSegment(pos, vec3(0.4, 0.4, 0.4), vec3(0.5, 0.6, 0.5), 0.15, 0.125);\n    //float segmentB = TentacleSegment(pos, vec3(0.5, 0.6, 0.5), vec3(0.55, 0.7, 0.55), 0.125, 0.125);\n    //float segmentC = TentacleSegment(pos, vec3(0.55, 0.7, 0.55), vec3(0.7, 0.7, 0.7), 0.125, 0.075);\n    \n    vec3 a = vec3(0.2, 0.3, 0.45);//vec3(0.4, 0.3, 0.4);\n    vec3 b = vec3(1.0, 0.4, 0.625 + sin(iTime) * 0.025);//vec3(0.8, 0.3, 0.8);\n    \n    vec3 pa = pos - a;\n    vec3 ba = b - a;\n    \n    float d      = clamp(dot(ba, pa) / dot(ba, ba), 0.0, 1.0);\n    float rad    = d * 3.14;\n    float radius = mix(0.15, 0.1, d);\n    \n    d = 0.5 - abs(0.5 - d);\n    \n   \tpos.y -= sin((pos.x - a.x) * PI) * 0.35;\n    //a.y += d;//sin(rad + iTime);\n    \n    return vec2(Capsule(pos, a, b, radius), MAT_Tentacle);\n    \n    /*vec3 a  = vec3(0.0, 0.0, 0.0);\n    vec3 b  = vec3(0.1, 0.3, 0.1);\n    float r = 0.3;\n    \n    vec2 f = vec2(FarClip, 0.0);\n    \n    for(int i = 0; i < 5; ++i)\n    {\n        f = min(f, TentacleSegment(pos, a, b, r, r));\n        \n        //r *= 0.8;\n        a  = b;\n        b += vec3(0.1, 0.3, 0.1);\n    }\n    \n    return f;*/\n    \n    //return vec2(SU(SU(segmentA, segmentB, 0.01), segmentC, 0.01), 0.0);\n}\n\nvec2 Scene(in vec3 pos)\n{\n    vec2 ground   = vec2(FarClip, MAT_None);//vec2(pos.y + 1.5, MAT_None);\n    vec2 cauldron = Cauldron(pos);\n    vec2 potion   = Potion(pos);//vec2(Cylinder(pos - vec3(0.0, 0.35, 0.0), vec2(0.875, 0.1)), 2.0);\n    vec2 backwall = vec2(FarClip, MAT_None);//vec2(pos.z + 3.0, MAT_None);\n    vec2 tentacle = Tentacle(pos);\n    \n    vec2 lights = vec2(min(length(pos - PotionLightPos) - 0.1, length(pos - FireLightPos) - 0.1), 0.0);\n    \n    //return U(backwall, U(ground, U(cauldron, lights)));\n    return U(backwall, U(ground, U(cauldron, U(potion, tentacle))));\n}\n\nfloat ShadowScene(in vec3 pos)\n{\n\treturn min(Cauldron(pos).x, Tentacle(pos).x);   \n}\n\n//------------------------------------------------------------------------------------------\n// Scene Marching\n//------------------------------------------------------------------------------------------\n\nvec2 March(in Ray ray)\n{\n    float depth  = NearClip;\n    float surfID = 0.0;\n    \n    for(int i = 0; i < MaxSteps; ++i)\n    {\n        vec3 pos = ray.o + (ray.d * depth);\n        vec2 sdf = Scene(pos);\n        \n        if(sdf.x < Epsilon)\n        {\n            surfID = sdf.y;\n            break;\n        }\n        \n        if(depth > FarClip)\n        {\n            break;\n        }\n        \n        depth += sdf.x;\n    }\n    \n    return vec2(clamp(depth, NearClip, FarClip), surfID);\n}\n\nvec3 SceneNormal(in vec3 pos, in float depth)\n{\n    vec2 eps = vec2(0.003 * depth, 0.0);\n    return normalize(vec3(Scene(pos + eps.xyy).x - Scene(pos - eps.xyy).x,\n                          Scene(pos + eps.yxy).x - Scene(pos - eps.yxy).x,\n                          Scene(pos + eps.yyx).x - Scene(pos - eps.yyx).x));\n}\n\nfloat CalcShadow(in vec3 pos, in vec3 lightPos)\n{\n    float shadow = 1.0;\n    float depth  = 0.1;\n    \n    float lightDist = distance(pos, lightPos);\n    vec3 lightDir = normalize(pos - lightPos);\n    \n    for(int i = 0; i < 24; ++i)\n    {\n        float sdf = ShadowScene(pos + (-lightDir * depth));\n\n        shadow = min(shadow, (64.0 * sdf) / depth);\n        depth += sdf;\n\n        if(depth >= lightDist)\n        {\n            break;\n        }\n        \n        if(sdf < 0.01)\n        {\n            shadow = 0.0;\n            break;\n        }\n    }\n    \n    return clamp(shadow, 0.0, 1.0);\n}\n\nfloat CalcOcclusion(in vec3 pos, in vec3 norm)\n{\n    float occlusion = 0.0;\n    mat3  rotMat    = RotMat(vec3(0.0, 0.0, 1.0), norm);\n    \n    for(float i = 0.0; i < AOSteps; ++i)\n    {\n        vec3  sampleDir    = rotMat * SampleHemisphere(i, AOSteps);\n        vec2  march        = Scene(pos + sampleDir);\n        \n        occlusion += clamp(1.0 - 5.0 * max(0.0, march.x + 0.05), 0.0, 1.0);\n    }\n    \n    occlusion = clamp(occlusion * AOStepsI, 0.0, 1.0);\n    occlusion = (occlusion > 0.9 ? 0.0 : occlusion);\n    \n    return (1.0 - occlusion);\n}\n\nvec3 GenerateSampleVector(in vec3 norm, in float i)\n{\n\tvec3 randDir = normalize(Hash33(norm + i));\n    return MirrorVector(randDir, norm);\n}\n\nfloat CalcThickness(in vec3 pos, in vec3 norm, in float depth)\n{\n    float thickness = 0.0;\n    \n    for(float i = 0.0; i < SSSThicknessSamples; ++i)\n    {\n        float sampleLength = Hash11(i) * depth;\n        vec3 sampleDir = GenerateSampleVector(-norm, i);\n\n        thickness += sampleLength + Scene(pos + (sampleDir * sampleLength)).x;\n    }\n    \n    return clamp(thickness * SSSThicknessSamplesI, 0.0, 1.0);\n}\n\n//------------------------------------------------------------------------------------------\n// Material\n//------------------------------------------------------------------------------------------\n\nstruct Material\n{\n\tvec3 albedo;\n    \n    float type;\n    float roughness;\n    float sssDepth;\n    float sssAmbient;\n    float sssDistortion;\n    float sssScale;\n    float sssPower;\n};\n    \nMaterial CreateMaterial(in vec3 pos, in vec3 norm, in float surfID)\n{\n    Material result;\n    \n    result.type          = surfID;\n    result.albedo        = vec3(1.0);\n    result.roughness     = 8.0;\n    result.sssDepth      = 1.0;\n    result.sssAmbient    = 1.0;\n    result.sssDistortion = 1.0;\n    result.sssScale      = 1.0;\n    result.sssPower      = 1.0;\n    \n    if(IsMat(MAT_Cauldron, surfID))\n    {\n        result.albedo   = vec3(0.05);\n        result.sssDepth = 0.01;\n    }\n    else if(IsMat(MAT_Potion, surfID))\n    {\n        result.albedo     = vec3(0.0, 1.0, 0.0);\n        result.roughness  = 32.0;\n        result.sssDepth   = 10.0;\n        result.sssAmbient = 10.0;\n    }\n    else if(IsMat(MAT_Tentacle, surfID))\n    {\n        result.albedo        = vec3(0.439216, 0.152941, 1.0);\n        result.roughness     = 16.0;\n        result.sssDepth      = 0.5;\n        result.sssAmbient    = 1.5;\n        result.sssDistortion = 1.5;\n        result.sssScale      = 5.0;\n        result.sssPower      = 0.5;\n    }\n    \n    return result;\n}\n\n//------------------------------------------------------------------------------------------\n// Lighting\n//------------------------------------------------------------------------------------------\n\nvec3 PointInCircle(in vec3 pos, in vec3 circlePos, in vec3 circleNorm, in float circleRadius)\n{\n    vec3 d = pos - circlePos;\n    vec3 q = d - dot(circleNorm, d) * circleNorm + circlePos;\n    \n    return (length(q - circlePos) <= circleRadius) ? q : (circlePos + circleRadius * normalize(q - circlePos));\n}\n\nvec3 PointOnCircle(in vec3 pos, in vec3 circlePos, in vec3 circleNorm, in float circleRadius)\n{\n \tvec3 d = pos - circlePos;\n    vec3 qc = d - dot(circleNorm, d) * circleNorm;\n    \n    return (circlePos + circleRadius * normalize(qc));\n}\n\nfloat Attenuation(float d, float c, float l, float q)\n{\n    return (1.0 / (c + (l * d) + (q * d * d)));\n}\n\nfloat CalcSSS(\n    in Material mat,\n    in float    thickness,\n    in float    attenuation,\n    in vec3     toView,\n    in vec3     lightPos,\n    in vec3     surfPos,\n    in vec3     surfNorm)\n{\n\tvec3  SSSLight = (normalize(lightPos - surfPos) + surfNorm * mat.sssDistortion);\n    float SSSDot   = pow(clamp(dot(toView, -SSSLight), 0.0, 1.0), mat.sssPower) * mat.sssScale;\n    \n    return ((SSSDot + mat.sssAmbient) * thickness * attenuation);    \n}\n\nvec3 Lighting_Potion(\n    in Material mat, \n    in vec3     toView,\n    in vec3     norm, \n    in vec3     pos, \n    in float    occlusion, \n    in float    thickness)\n{\n    vec3 lightNorm = normalize(vec3(0.0, 1.0, 0.0));\n    \n    vec3 pointOnLight = PointInCircle(pos, PotionLightPos, lightNorm, 1.0);\n    vec3 toLight      = pos - pointOnLight;\n    vec3 toLightN     = normalize(toLight);\n    \n    float lightCos    = dot(-toLightN, norm);\n          lightCos    = max(0.3, abs(lightCos));//max(0.0, lightCos);\n    \n    float lightDist   = length(toLight);\n    float attenuation = Attenuation(lightDist, 2.5, 2.0, 10.0);\n    float sss         = CalcSSS(mat, thickness, attenuation, toView, PotionLightPos, pos, norm);\n    \n    vec3 reflVector = reflect(-toView, norm);\n    \n    vec3 dirLight = PotionLightCol * 0.8 * lightCos * attenuation;\n    vec3 spcLight = vec3(0.2) * pow(max(0.0, dot(reflVector, toLightN)), mat.roughness) * lightCos;\n    \n    return (mat.albedo * dirLight * sss);// + spcLight;\n    \n    /*\n    vec3 toPotionLight  = (pos - PotionLightPos);\n    \n    float attenuation = Attenuation(length(toPotionLight), 1.5, 1.0, 1.5);\n    float sss         = CalcSSS(mat, thickness, attenuation, toView, PotionLightPos, pos, norm);\n    \n    return (PotionLightCol * mat.albedo * sss);*/\n}\n\nvec3 Lighting_Fire(\n    in Material mat, \n    in vec3     toView,\n    in vec3     norm, \n    in vec3     pos, \n    in float    occlusion, \n    in float    thickness)\n{\n    vec3 lightNorm = normalize(vec3(0.0, 1.0, 0.0));\n    \n    vec3 pointOnLight = PointOnCircle(pos, vec3(0.0, -1.5, 0.0), lightNorm, 5.0);\n    vec3 toLight      = pos - pointOnLight;\n    vec3 toLightN     = normalize(toLight);\n    \n    float lightCos    = dot(-toLightN, norm);\n          lightCos    = max(0.0, lightCos);\n    \n    float lightDist   = length(toLight);\n    float attenuation = Attenuation(lightDist, 2.0, 1.0, 1.0);\n    \n    vec3 reflVector = reflect(-toView, norm);\n    \n    vec3 dirLight = vec3(1.0) * lightCos * attenuation;\n    vec3 spcLight = vec3(0.2) * pow(max(0.0, dot(reflVector, toLightN)), mat.roughness) * lightCos;\n    \n    return (mat.albedo * dirLight) + spcLight;\n    \n    \n    \n    /*vec3 toFireLight  = (pos - FireLightPos);\n    \n    float attenuation = Attenuation(toFireLight, 10.0, 0.5, 1.0, 2.0);\n    float sss         = CalcSSS(mat, thickness, attenuation, toView, FireLightPos, pos, norm);\n    \n    return (FireLightCol * mat.albedo * sss);*/\n}\n\nvec3 Lighting(\n    in Material mat, \n    in vec3     toView,\n    in vec3     norm, \n    in vec3     pos, \n    in float    occlusion, \n    in float    thickness)\n{\n    vec3 lightPotion = Lighting_Potion(mat, toView, norm, pos, occlusion, thickness);\n    vec3 lightFire   = Lighting_Fire(mat, toView, norm, pos, occlusion, thickness);\n    \n    return (lightPotion + lightFire);\n    //shadow = IsMat(mat.type, MAT_Potion) ? shadow : min(potionCos, shadow);\n    //float keyIntens   = max(0.0, dot(norm, KeyLightDir));\n    //vec3 keyLight = vec3(1.0);\n    //vec3 spcLight = vec3(1.0) * pow(max(0.0, dot(reflect(-toView, norm), KeyLightDir)), mat.roughness);\n    //vec3 dirLight = (keyLight + spcLight) * max(0.5, keyIntens) * shadow;\n    //vec3 ambLight = vec3(0.1) * pow(occlusion, 2.0) * occlusion * (1.0 - keyIntens);\n    \n    //return (mat.albedo * dirLight) + ambLight + spcLight;//(mat.albedo * occlusion);//(mat.albedo * dirLight);\n}\n\n//------------------------------------------------------------------------------------------\n// Scene Sampling\n//------------------------------------------------------------------------------------------\n\nvec4 Render(in Ray ray)\n{\n    vec3 color = BackgroundColor;\n    vec2 march = March(ray);\n    \n    float depth  = clamp(march.x / FarClip, 0.0, 1.0);\n    float surfID = march.y;\n    \n    if(depth < (1.0 - Epsilon))\n    {\n        vec3  pos  = ray.o + (ray.d * march.x);\n        vec3  norm = SceneNormal(pos, march.x);\n        \n        Material mat = CreateMaterial(pos, norm, surfID);\n        \n        float occlusion = CalcOcclusion(pos, norm);\n        float thickness = CalcThickness(pos, norm, mat.sssDepth);\n        \n        color = Lighting(mat, -ray.d, norm, pos, occlusion, thickness);\n    }\n    \n    return vec4(color, depth);\n}\n\n//------------------------------------------------------------------------------------------\n// Main\n//------------------------------------------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    Ray ray = Ray_LookAt(uv, CameraPos(), vec3(0.0, 0.25, 0.0));\n    \n    fragColor = Render(ray);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"float Edge(in sampler2D tex, in vec2 uv)\n{\n\tfloat edge = 0.0;\n    \n    vec2 o = vec2(0.0035, 0.0);\n    \n    float depthSrc  = texture(tex, uv + o.yy).a;\n    float depthCmpA = texture(tex, uv + o.xy).a;\n    float depthCmpB = texture(tex, uv - o.yx).a;\n    \n    float diff = clamp(max(abs(depthSrc - depthCmpA), abs(depthSrc - depthCmpB)) / 0.0045, 0.0, 1.0);\n    \n    // 0.6 is a control value for outline stroke thickness, and 8.0 is stroke strength.\n    return smoothstep(0.5, -0.001, pow(diff, 8.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float edge = Edge(iChannel0, uv);\n    \n    fragColor = texture(iChannel0, uv) * step(0.05, edge);\n}","name":"Buffer B","description":"","type":"buffer"}]}