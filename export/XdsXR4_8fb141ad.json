{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"vec3 frustum;\nfloat drawDistance = 250.0;\nfloat epsilon = 0.05;\nfloat aoStep = 0.2;\nfloat aoFactor = 0.04;\nfloat tileSize = 5.0;\n\nconst float PI = 3.14159;\n\nvec3 rotVec3(vec3 vector,vec3 eulerAngles) {\n\tfloat sinT;\n\tfloat cosT;\n\tmat3 matrix;\n\teulerAngles = -eulerAngles;\n\tif (eulerAngles.x!=0.0) {\n\t\tsinT = sin(eulerAngles.x);\n\t\tcosT = cos(eulerAngles.x);\n\t\tmatrix = mat3(1.0,0.0,0.0,0.0,cosT,-sinT,0.0,sinT,cosT);\n\t\tvector = matrix * vector;\n\t}\n\tif (eulerAngles.y!=0.0) {\n\t\tsinT = sin(eulerAngles.y);\n\t\tcosT = cos(eulerAngles.y);\n\t\tmatrix = mat3(cosT,0.0,sinT,0.0,1.0,0.0,-sinT,0.0,cosT);\n\t\tvector = matrix * vector;\n\t}\n\tif (eulerAngles.z!=0.0) {\n\t\tsinT = sin(eulerAngles.z);\n\t\tcosT = cos(eulerAngles.z);\n\t\tmatrix = mat3(cosT,-sinT,0.0,sinT,cosT,0.0,0.0,0.0,1.0);\n\t\tvector = matrix * vector;\n\t}\n\treturn(vector);\n}\n\nfloat distanceToSphere(vec4 sphere,vec3 point) {\n\treturn(length(point-sphere.xyz)-sphere.w);\n}\n\nfloat distanceToRect(vec3 rectExtents,vec3 rectCenter,vec3 point) {\n\tvec3 tPoint = point-rectCenter;\n\treturn(length(max(abs(tPoint)-rectExtents,0.0)));\n}\nfloat distanceToRoundRect(vec4 rectExtents,vec3 rectCenter,vec3 point) {\n\tvec3 tPoint = point-rectCenter;\n\treturn(length(max(abs(tPoint)-rectExtents.xyz,0.0)) - rectExtents.w);\n}\nfloat distanceToFloor(float floorHeight,vec3 point) {\n\treturn(point.y-floorHeight);\n}\n\nfloat distanceField(vec3 point) {\n\tfloat dist = 10000.0;\n\t\n\t//point.x+=sin(point.y+iTime) * 0.5;\n\t\n\tpoint=vec3(mod(point.x+tileSize*1.5,tileSize*3.0)-tileSize*1.5,point.y,mod(point.z+tileSize,tileSize*2.0)-tileSize);\n\t\n\tvec4 theSphere = vec4(0.0,0.0,0.0,1.0);\n\tdist = min(dist, distanceToSphere(theSphere,point));\n\t\n\tvec3 rectCenter = vec3(3.0,0.0,0.0);\n\tvec3 rectExtents = vec3(1.0,2.0,1.0);\n\tdist = min(dist, distanceToRect(rectExtents,rectCenter,point));\n\t\n\trectCenter = vec3(-3.0,0.0,0.0);\n\tvec4 rectExtents2 = vec4(1.0,1.0,1.0,0.7);\n\tdist = min(dist,distanceToRoundRect(rectExtents2,rectCenter,point));\n\t\n\tdist=min(dist,distanceToFloor(-2.0,point));\n\t\n\treturn(dist);\n}\n\nvec3 findNormal(vec3 point) {\n\tvec3 normal;\n\t\n\tfloat ep = epsilon * .25;\n\t\n\tnormal.x=distanceField(point+vec3(ep,0.0,0.0))-\n\t\t\t distanceField(point-vec3(ep,0.0,0.0));\n\tnormal.y=distanceField(point+vec3(0.0,ep,0.0))-\n\t\t\t distanceField(point-vec3(0.0,ep,0.0));\n\tnormal.z=distanceField(point+vec3(0.0,0.0,ep))-\n\t\t\t distanceField(point-vec3(0.0,0.0,ep));\n\t\n\treturn(normalize(normal));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat camRot = iTime*0.3;\n\tvec3 camPos = vec3(cos(camRot)+.1,1.0,sin(camRot))*8.0;\n\t\n\tfrustum = vec3 (1.0,iResolution.y/iResolution.x,1.0);\n\t\n\t//tileSize = 7.0 + cos(iTime*0.2)*2.0;\n\t\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec3 uv2 = vec3(uv,1.0);\n\tuv2 = uv2 * 2.0 - 1.0;\n\tvec3 viewDir = normalize(frustum * uv2);\n\t\n\tviewDir = rotVec3(viewDir, vec3(.3,-camRot-PI*0.5,0.0));\n\t\n\tfloat dist;\n\tvec3 rayPos = camPos+viewDir*0.001;\n\tvec3 travelVector;\n\t\n\tfloat light=0.0;\n\t\n\tbool stop = false;\n\t\n\tvec3 normal;\n\t\n\tfor (int i=0;i<64;i++) {\n\t\tif (stop == false) {\n\t\t\ttravelVector=rayPos-camPos;\n\t\t\t\n\t\t\tdist=distanceField(rayPos);\n\t\t\t\n\t\t\tif (dist<epsilon) {\n\t\t\t\tlight=1.0;\n\t\t\t\tnormal=findNormal(rayPos);\n\t\t\t\tstop=true;\n\t\t\t} else if (dot(travelVector,travelVector)>drawDistance*drawDistance) {\n\t\t\t\tlight=0.0;\n\t\t\t\tstop=true;\n\t\t\t} else {\n\t\t\t\trayPos+=viewDir*dist;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\tvec3 finalColor;\n\tif (light<.5) {\n\t\tlight=uv2.y*.5+.5;\n\t\tfinalColor = vec3(light,light,light);\n\t} else {\n\t\tvec3 sun = normalize(vec3(1.0,1.0,1.0));\n\t\tlight = clamp(dot(normal,sun),0.0,1.0);\n\t\t\n\t\tsun = normalize(vec3(-1.0,-1.0,-1.0));\n\t\tlight+=clamp(dot(normal,sun)*.5,0.0,1.0);\n\t\t\n\t\tlight=max(light,0.1);\n\t\t\n\t\tfloat oDist = dist;\n\t\tfor (float j=0.0;j<8.0;j++) {\n\t\t\trayPos+=normal*aoStep;\n\t\t\tdist=distanceField(rayPos);\n\t\t\tlight-=(aoStep*(j+1.0)-(dist-oDist))*aoFactor;\n\t\t}\n\t\tlight=clamp(light,0.0,1.0);\n\t\t\n\t\tfinalColor=vec3(light,light,light);\n\t}\n\t//light=length(travelVector)/drawDistance;\n\t//finalColor = vec3(light,light,light);\n\t\n\t\n\tfragColor = vec4(finalColor,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XdsXR4","date":"1397546976","viewed":362,"name":"distance field renderer","username":"2DArray","description":"A distance-field renderer with directional lights and ambient occlusion","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","distancefield"],"hasliked":0,"parentid":"","parentname":""}}