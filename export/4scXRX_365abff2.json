{"ver":"0.1","info":{"id":"4scXRX","date":"1460805842","viewed":439,"name":"Kleinyan Cat","username":"soma_arc","description":"This is created for practice of bitmap orbit traps.\nThis work is inspired by Fractal Nyancat by iq (https://www.shadertoy.com/view/4slGWH)","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["fractal","nyancat","kleiniangroups"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nCreated by soma_arc - 2016\nThis work is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported.\n*/\n\n// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(vec2 co, float sampleIndex) {\n    vec2 seed = co * (sampleIndex + 1.0);\n\tseed+=vec2(-1,1);\n    // implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n    return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nvec2 t1c = vec2(-100, -100);\nvec2 t2c = vec2(100, 100);\n\nvec4 getNyanCatColor( vec2 p, float time)\n{\n    p += vec2(100, 100);//offset\n    p = p / 200.;\n\tp = clamp(p,0.0,1.0);\n\tp.x = p.x*40.0/256.0;\n    float fr = floor( mod( 20.0*time, 6.0 ) );\n\tp.x += fr*40.0/256.0;\n\treturn texture( iChannel0, p);\n}\n\nfloat LINE_THRESHOLD = 0.0001;\nvec3 getLine(vec2 p1, vec2 p2){\n  float xDiff = p2.x - p1.x;\n  float yDiff = p2.y - p1.y;\n  if(abs(xDiff) < LINE_THRESHOLD){\n    //x = c\n    return vec3(1, 0, p1.x);\n  }else if(abs(yDiff) < LINE_THRESHOLD){\n    //y = c\n    return vec3(0, 1, p1.y);\n  }else{\n    //y = ax + b\n    return vec3(yDiff / xDiff, p1.y - p1.x * (yDiff / xDiff), 0);\n  }\n}\n\nfloat calcX(vec3 line, float y){\n  if(line.z == 0.){\n    return (y - line.y) / line.x;\n  }else{\n    return line.z;\n  }\n}\n\nfloat calcY(vec3 line, float x){\n  if(line.z == 0.){\n    return line.x * x + line.y;\n  }else{\n    return line.z;\n  }\n}\n\nvec2 calcIntersection(vec3 line1, vec3 line2){\n  if(line1.z == 0. && line2.z == 0.){\n    float x1 = 1.;\n    float x2 = 5.;\n    float y1 = calcY(line1, x1);\n    float y2 = calcY(line1, x2);\n\n    float x3 = 4.;\n    float x4 = 8.;\n    float y3 = calcY(line2, x3);\n    float y4 = calcY(line2, x4);\n\n    float ksi   = ( y4-y3 )*( x4-x1 ) - ( x4-x3 )*( y4-y1 );\n    float eta   = ( x2-x1 )*( y4-y1 ) - ( y2-y1 )*( x4-x1 );\n    float delta = ( x2-x1 )*( y4-y3 ) - ( y2-y1 )*( x4-x3 );\n\n    float lambda = ksi / delta;\n    float mu    = eta / delta;\n    return vec2(x1 + lambda*( x2-x1 ), y1 + lambda*( y2-y1 ));\n  }else{\n    if(line1.x == 1.){\n      return vec2(line1.z, calcY(line2, line1.z));\n    }else if(line1.y == 1.){\n      return vec2(calcX(line2, line1.z), line1.z);\n    }else if(line2.x == 1.){\n      return vec2(line2.z, calcY(line1, line2.z));\n    }\n    return vec2(calcX(line1, line2.z), line2.z);\n  }\n}\n\nconst vec2 commonCirclePos = vec2(0, 0);\nconst float commonCircleR = 100.;\nconst vec2 p = commonCirclePos + vec2(0, commonCircleR);\nconst vec2 q = commonCirclePos + vec2(-commonCircleR, 0);\nconst vec2 r = commonCirclePos + vec2(0, -commonCircleR);\nconst vec2 s = commonCirclePos + vec2(commonCircleR, 0);\nvec2 cPos[4];\nfloat cR[4];\nvoid calcContactCircles(vec2 commonCirclePos, float commonCircleR){\n  vec2 pqMid = (p + q)/2.;\n  vec2 u = (pqMid - commonCirclePos)/distance(commonCirclePos, pqMid);\n  vec2 a = u * commonCircleR * (sin(iTime) * 6. + 6.72) + commonCirclePos;\n  cPos[0] = a;\n  cR[0] = distance(a, p);\n    \n  vec3 aq = getLine(a, q);\n  vec3 qrMidPer = getLine(commonCirclePos, (q + r) / 2.);\n  vec2 b = calcIntersection(aq, qrMidPer);\n  cPos[1] = b;\n  cR[1] = distance(b, q);\n    \n  vec3 br = getLine(b, r);\n  vec3 rsMidPer = getLine(commonCirclePos, (r + s) / 2.);\n  vec2 c = calcIntersection(br, rsMidPer);\n  cPos[2] = c;\n  cR[2] = distance(c, r);\n  \n  vec3 cs = getLine(c, s);\n  vec3 spMidPer = getLine(commonCirclePos, (s + p) / 2.);\n  vec2 d = calcIntersection(cs, spMidPer);\n  cPos[3] = d;\n  cR[3] = distance(d, s);\n}\n\nvec2 circleInverse(vec2 pos, vec2 circlePos, float circleR){\n\treturn ((pos - circlePos) * circleR * circleR)/(length(pos - circlePos) * length(pos - circlePos) ) + circlePos;\n}\n\nconst int ITERATIONS = 30;\nfloat trap2 = 999999999.;\nfloat trap1 = 999999999.;\n\nfloat co2 = 0.;\nvec4 col;\nfloat scale = 3.1;\nfloat DE(vec2 pos, float time){\n    float loopNum = 0.;\n    trap2 = min( trap2, dot(pos-t2c,pos-t2c) );\n    trap1 = min( trap1, dot(pos-t1c,pos-t1c) );\n\tfloat d1 = abs(dot(pos-vec2(0.0,1.0),vec2(0.707)));\n\tfloat ff = step( d1, 1.0 );\n\tco2 += ff;\n    \n    col = getNyanCatColor( pos - cPos[0] * scale, time );\n    if (col.w < 0.1)\n \t\tcol = getNyanCatColor( pos - cPos[1] * scale, time );\n    if (col.w < 0.1)\n \t\tcol = getNyanCatColor( pos - cPos[2] * scale, time);\n    if (col.w < 0.1)\n \t\tcol = getNyanCatColor( pos - cPos[3] * scale, time);\n\tbool cont = false;\n\tfor(int i = 0 ; i < ITERATIONS ; i++){\n\t\tcont = false;\n      \tif(length(pos - cPos[0]) < cR[0]){\n            pos = circleInverse(pos, cPos[0], cR[0]);\n            cont = true;\n            loopNum++;\n\t\t}else if(length(pos - cPos[1]) < cR[1]){\n            pos = circleInverse(pos, cPos[1], cR[1]);\n            cont = true;\n            loopNum++;\n\t\t}else if(length(pos - cPos[2]) < cR[2]){\n            pos = circleInverse(pos, cPos[2], cR[2]);\n            cont = true;\n            loopNum++;\n\t\t}else if(length(pos - cPos[3]) < cR[3]){\n            pos = circleInverse(pos, cPos[3], cR[3]);\n            cont = true;\n            loopNum++;\n\t\t}\n                        \n        if (col.w < 0.1)\n            col = getNyanCatColor( pos - cPos[0] * scale, time );\n        if (col.w < 0.1)\n            col = getNyanCatColor( pos - cPos[1] * scale, time );\n        if (col.w < 0.1)\n            col = getNyanCatColor( pos - cPos[2] * scale, time );\n        if (col.w < 0.1)\n            col = getNyanCatColor( pos - cPos[3] * scale, time );\n\t\tif(cont == false) break;\n\t}\n\n\treturn loopNum;\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nconst float SAMPLE_NUM = 20.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 sum = vec4(0);\n\tfloat ratio = iResolution.x / iResolution.y / 2.0;\n    calcContactCircles(commonCirclePos, commonCircleR);\n    float time = iTime;\n    \n    for(float i = 0. ; i < SAMPLE_NUM ; i++){\n        vec2 position = ( (fragCoord.xy + rand2n(fragCoord.xy, i)) / iResolution.yy ) - vec2(ratio, 0.5);\n\t\tposition = position * 600.;\n\t\tfloat loopNum = DE(position, time);\n        vec3 hsv = vec3(0);\n        if(loopNum > 0. && col.w < 1.)\n            sum += vec4(hsv2rgb(vec3(0.04 * loopNum,1.0,1.0)), 1.);\n        else if(col.w > 0.)\n        \tsum += col;\n\n    \t//col.xyz = mix( hsv, col.xyz, col.w );\n    }\n    fragColor = vec4(sum/SAMPLE_NUM);\n    \n}","name":"Image","description":"","type":"image"}]}