{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"const mat2 mtx = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n    \n    vec2 ga = hash( i + vec2(0.0,0.0) );\n    vec2 gb = hash( i + vec2(1.0,0.0) );\n    vec2 gc = hash( i + vec2(0.0,1.0) );\n    vec2 gd = hash( i + vec2(1.0,1.0) );\n    \n    float va = dot( ga, f - vec2(0.0,0.0) );\n    float vb = dot( gb, f - vec2(1.0,0.0) );\n    float vc = dot( gc, f - vec2(0.0,1.0) );\n    float vd = dot( gd, f - vec2(1.0,1.0) );\n\n    return va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd);\n}\n\nfloat fbm0( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*(-1.0+2.0*noise( p )); p = mtx*p*2.02;\n    f += 0.2500*(-1.0+2.0*noise( p )); p = mtx*p*2.03;\n    f += 0.1250*(-1.0+2.0*noise( p )); p = mtx*p*2.01;\n    f += 0.0625*(-1.0+2.0*noise( p ));\n    return f/0.9375;\n}\n\nfloat fbm1( vec2 p )\n{\n    float f = 0.0;\n    f += 0.500000*noise( p ); p = mtx*p*2.02;\n    f += 0.250000*noise( p ); p = mtx*p*2.03;\n    f += 0.125000*noise( p ); p = mtx*p*2.01;\n    f += 0.062500*noise( p ); p = mtx*p*2.04;\n    f += 0.031250*noise( p ); p = mtx*p*2.01;\n    f += 0.015625*noise( p );\n    return f/0.96875;\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 pattern(vec2 p)\n{\n    float t = iTime * 0.02;\n    const float h = 0.6;\n    const float sat = 1.0;\n    \n    if(fract(length(p)) < 0.5)\n    {\n        vec2 temp = p;\n        p.x = -temp.y;\n        p.y = temp.x;\n        t = -iTime * 0.02;\n    }\n    mat2 rotation = mat2(cos(t), -sin(t), sin(t), cos(t));\n    p = rotation * p;\n    vec2 q;\n    vec2 r;\n    q.x = fbm1(p);\n    q.y = fbm0( p + vec2(-5.2,1.3*(iTime * 0.02)) );\n    r.x = fbm0( p + 2.0*q);\n    r.y = fbm1( p + 3.0*q + vec2(-2.3,2.8) );\n    \n    vec2 index;\n    index.x = fbm1( p + 6.0*r )+150.0;\n    index.y = fbm0( p + 4.0*r )+200.0;\n    \n    float n = noise(1.7*(p+index));\n    \n    float sig = 1.0 / (1.0 + exp(-9.0*n));\n    vec3 c = hsv2rgb(vec3(h, (1.0-(sig * 0.7 + 0.3))*sat, sig));\n    float w = 1.0-0.8*(exp(-4.0*(1.0-fract(length(p)*2.0))));\n    return c * w;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n    \n    vec3 col = pattern(1.7*uv);\n\n    float aspect = iResolution.x / iResolution.y;\n    \n    // Border\n    if(abs(uv.x) > (aspect - 0.1) || abs(uv.y) > 0.9)\n        col = vec3(0.93, 0.91, 0.86);\n\n    // Add some texture\n    col += 0.25*noise(uv * 180.0);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Nsdfz8","date":"1734988761","viewed":138,"name":"Warped Porcelain","username":"westgarthb","description":"Fractional brownian noise and domain warping","likes":23,"published":1,"flags":0,"usePreview":1,"tags":["noise","fbm","warping"],"hasliked":0,"parentid":"","parentname":""}}