{"ver":"0.1","info":{"id":"NdG3Ry","date":"1632059019","viewed":120,"name":"RayMarching Env","username":"yunhai","description":"a place to try a lot of mess\n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["study"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*------------OBJ DEFINE------------*/\nconst int OBJ_NUM=4;\nconst int ID_BOUND=0;\nconst int ID_BOX=1;\nconst int ID_LOWCUBE=2;\nconst int ID_HIGHCUBE=3;\nMarchPoint sdf(in vec3 p)\n{\n    float[OBJ_NUM] objSDF;\n    for(int i=0;i<OBJ_NUM;i++)\n        objSDF[i]=INF;\n    objSDF[ID_BOUND]=-sdSphere(p,MAX_DIST);//Bound\n    \n    /*--------add objects begin--------*/\n    objSDF[ID_BOX]=-sdCube(p-vec3(0,-.1,.5),vec3(1.3,1.,2.2));\n    \n    vec3 np=p;np-=vec3(.1,-.4,.83);\n    mat2x2 rot=mrot(-20.);np.xz*=rot;\n    objSDF[ID_LOWCUBE]=max(sdCube(np,vec3(.2)),-sdCube(np,vec3(.1,.1,.3)));\n    \n    np=p;np-=vec3(-.13,-.28,1.2);\n    rot=mrot(20.);np.xz*=rot;\n    objSDF[ID_HIGHCUBE]=sdCube(np,vec3(.1,.23,.1)*2.3);\n    /*--------add objects end--------*/\n    \n    MarchPoint tar=MarchPoint(objSDF[ID_BOUND],ID_BOUND);\n    for(int i=1;i<OBJ_NUM;i++)\n        if(tar.d>objSDF[i])\n            tar.d=objSDF[i],\n            tar.id=i;\n\n    return tar;\n}\nvec3 getNormal(in vec3 p)\n{\n    vec2 e=vec2(0,EPS);\n    float c=sdf(p).d;\n    return normalize(vec3(sdf(p+e.yxx).d-c,\n                          sdf(p+e.xyx).d-c,\n                          sdf(p+e.xxy).d-c));\n}\nstruct FragInfo\n{\n    vec3 worldPos,normal,kc;\n    float ao;\n};\nvec3 getLight()\n{\n    return vec3(0.,.1,1.);\n}\nCam getCam()\n{\n    cam.pos=vec3(0,-.1,-.2);\n    cam.dir=vec3(0.,0.,1.);\n    //cam.r=-cross(cam.dir,vec3(0,1,0));\n    cam.r=vec3(cam.dir.z,0.,-cam.dir.x);\n    cam.u=-cross(cam.r,cam.dir);\n    return cam;\n}\nvec3 pixelShade(in FragInfo I)\n{\n    vec3 pl=getLight()-I.worldPos,ld,\n        viewDir=I.worldPos-getCam().pos;\n    float plLen=length(pl);\n    ld=pl/plLen;\n    float tense=.06;\n    vec3 diff=vec3(1.,.7,.4)*max(dot(ld,I.normal),0.)/(plLen*plLen)*tense;\n    vec3 amb=vec3(.1,.2,.3)*.3*((1.-I.ao)*.7+.3);\n    vec3 specular=vec3(0);//*pow(max(0.,dot((normalize(-viewDir)+ld)*.5,I.normal)),40.);\n    return I.kc*(diff+amb+specular);\n}\nMarchHit rayCast(in Ray r,inout float edge)\n{\n    float d=0.,i=0.,l=0.;edge=0.;\n    MarchPoint point;\n    \n    float lastD=1e9;\n    for(;i<MAX_STEP;i++)\n    {\n        point=sdf(r.o+d*r.d);\n        \n        /*edge*/\n        const float EDGE_WIDTH=.007;\n        if(lastD<EDGE_WIDTH&&point.d>lastD)\n            edge=1.;\n        /**/\n        \n        if(abs(point.d)<MIN_DIST)\n            break;\n\n        l=i/MAX_STEP;\n        float SUB_BOUND=.4,UPPER_BOUND=1.;\n        d+=point.d*clamp(SUB_BOUND,UPPER_BOUND,\n        mix(SUB_BOUND,UPPER_BOUND,point.d));//*((1.-l*l*l)*0.7+0.3);\n        if(point.id==ID_BOUND)\n        {\n            d=MAX_DIST;\n            break;\n        }\n        lastD=point.d;\n    }\n    return MarchHit(d,i,point.id);\n}\nvec4 render(in Ray r)\n{\n    float edge=0.;\n    MarchHit h=rayCast(r,edge);\n    \n    vec3 pos=r.o+r.d*h.d,nml=getNormal(pos);\n    vec3 col=vec3(0),t=col;\n    float ao=h.marchTimes/MAX_STEP;\n    switch (h.id)\n    {\n        case ID_BOUND:\n            break;\n        case ID_BOX:\n            vec3 kc=mix(vec3(1),\n            mix(vec3(.5,1,.1),vec3(1.,.2,.2),nml.x*.5+.5),\n                        step(.5,abs(nml.x)));kc=max(kc,0.);\n            \n            /*parallax map\n            float height=.02*triplanar(iChannel1,pos*4.,nml).x;\n            pos=pos-height*r.d;//see pos\n            t=triplanar(iChannel0,pos*2.,nml).xyz;\n            kc=mix(kc,t,0.2);\n            \n            vec3 tagent=dFdx(pos),\n                 bitagent=dFdy(pos);\n            nml=normalize(-cross(tagent,bitagent));\n            /**/\n    \n            col=pixelShade(FragInfo(pos,nml,kc,ao));\n\n\n            break;\n        case ID_LOWCUBE:\n        case ID_HIGHCUBE:\n            col=pixelShade(FragInfo(pos,nml,vec3(1),ao));\n            \n            break;\n    }\n    col=mix(col,vec3(0.),edge);//edge\n    return vec4(col,ao);\n}\nRay genRay(in vec2 C)\n{\n    getCam();\n    vec2 uv=(C-iR*.5)/iR.y;\n    //uv+=(iM.xy-.5*iR)/iR.y*2.;//handle input\n    Ray r=Ray(cam.pos,normalize(uv.x*cam.r+uv.y*cam.u+1.*cam.dir));\n    return r;\n}\nvoid mainImage( out vec4 O, in vec2 C )\n{\n#ifdef SSAA\n    vec2 e=vec2(.25,-.25);\n    O=render(genRay(C+e.yy))+render(genRay(C+e.xy))+\n      render(genRay(C+e.yx))+render(genRay(C+e.xx));\n    O*=.25;\n#else\n    O=render(genRay(C));\n#endif\n    O=ACESFilm(O);//tone mapping\n    O=pow(O,vec4(0.45));//linear to sRGB\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*------------Log------------*/\n//updated: QuickAO\n\n//updated: SSAA\n//NOTICE! this option cost 4x more calculations\n//#define SSAA\n\n//updated:Gamma Correction\n\n//updated: edge depict\n//updated: parallax map\n/*------------utilities------------*/\n#define iR iResolution.xy\n#define iT iTime\n#define iM iMouse\nconst float MAX_DIST=20.;\nconst float MIN_DIST=1e-4;\nconst float MAX_STEP=80.;\nconst float EPS=1e-4;\nconst float INF=1e9;\nconst float PI=3.14159265;\nconst float DTA=PI/180.;\nstruct Ray\n{\n    vec3 o,d;\n};\nstruct Cam\n{\n    vec3 pos,dir;\n    vec3 r,u;\n}cam;\nstruct MarchPoint\n{\n    float d;\n    int id;\n};\nstruct MarchHit\n{\n    float d,marchTimes;\n    int id;\n};\nmat2x2 mrot(float r)\n{\n    r*=DTA;\n    float c=cos(r),s=sin(r);\n    return mat2x2(c,s,-s,c);\n}\nfloat sdCube(vec3 p,vec3 size)\n{\n    vec3 np=abs(p)-size*.5;\n    float o=length(max(np,vec3(0)));\n    float i=min(0.,max(np.x,max(np.y,np.z)));\n    return o+i;\n}\nfloat sdSphere(vec3 p,float s)//p=uv-origin\n{\n    return length(p)-s;\n}\n/*---------------------------*/\n\nvec4 ACESFilm(vec4 x)//1->0.8,10->1()\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\nvec4 triplanar(sampler2D sam,vec3 p,vec3 n)\n{\n    vec4 x = texture( sam, p.yz );\n    vec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n    n*=n;\n\treturn x*n.x + y*n.y + z*n.z;\n}","name":"Common","description":"","type":"common"}]}