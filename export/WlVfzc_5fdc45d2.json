{"ver":"0.1","info":{"id":"WlVfzc","date":"1614788177","viewed":230,"name":"Path Tracing Testing 141","username":"Pjbomb2","description":"WASD and mouse to move\nSettings and options in the Common Tab\nHow can I further optimize this and make the materials more realistic/look better?","likes":6,"published":1,"flags":48,"usePreview":0,"tags":["pathtracing"],"hasliked":0,"parentid":"3tKfzc","parentname":"Path Tracing Testing 140"},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Buffer A is camera controls\n//Buffer B is the main renderer\n//Buffer C is a denoiser(replace iChannel0 in Image tab with Buffer C to use it instead of raw output from Buffer B)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n  vec3 col = texture( iChannel0, uv ).xyz;\n\n#ifdef render  \n   col *= 2.; // exposure\n    col *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 );\n    //col = pow( col, vec3(0.8,0.85,0.9) );\n       col = ACESFilm(col); // convert unbounded HDR color range to SDR color range\n    col = LinearToSRGB(col); // convert from linear to sRGB for display\n        col = smoothstep(0., 1., col); // increase contrast\n#endif\n    fragColor = vec4( col, 1 );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//increase/decrease bouncecount for more bounces per ray\n#define BOUNCECOUNT 10\n//background values: 0 is skybox, 1 is directional sun, 2 is void\n#define background 1\n//Applys exposure, color correction, contrast in Image tab\n#define render\n\n//Russian Roulette \n#define Russian\n//Testing a modified, and seemingly faster, sphere tracing algorithm\n//#define in1\n\nvec3 SunPos = vec3(0, 100, -100);\nvec3 sunCol = 2.0*vec3(0.8, 0.7, 0.6);\n\n//Defines\n#define c_twopi 6.2831853072\n#define PI 3.141592\n\n\n//material numbers\n\n#define MATLIGHT 0.\n#define MATMETAL 1.\n#define MATBLUE 2.\n#define MATFLOOR 3.\n#define MATWHITE 4.\n#define MATWOOD 5.\n#define MATMIRROR 6.\n#define MATSLATE 7.\n#define MATGLASS 8.\n#define MATWATER 9.\n#define MATRED 10.\n#define MATGLASS2 11.\n#define MATDEBUG 12.\n\n\n//materials and their properties\nvec3 GetMatProps(in float matID, out float refl, out float refr, out float emmis, out float IOR, out float absorb, out float roughness) {//return material properties when what material is being hit is requested\n\n \n            if(matID == MATLIGHT) {\n     \trefl = 0.0;\n        refr = 0.0;\n        emmis = 3.5;\n        absorb = 0.0;\n        IOR = 1.0;\n        roughness = 1.0;\n\n       return vec3(0.9,0.8,0.7); //return vec3(0.79,0.64,0.45);\n    }\n    if(matID == MATMETAL) {\n     \trefl = 0.6;\n        refr = 0.0;\n        emmis = 0.0;\n        absorb = 0.0;\n        IOR = 3.0;\n        roughness = 0.3;\n\n       return vec3(.4, .4, .4);\n    }\n    if(matID == MATBLUE) {\n     \trefl = 0.0;\n        refr = 0.0;\n        emmis = 0.0;\n        absorb = 0.0;\n        IOR = 1.0;\n        roughness = 1.0;\n\n       return vec3(.6, .6, .8);\n    }\n    if(matID == MATFLOOR) {\n     \trefl = 0.0;\n        refr = 0.0;\n        emmis = 0.0;\n        absorb = 0.0;\n        IOR = 1.0;\n        roughness = 1.0;\n\n       return vec3(.88, .78, .6);\n    }\n    if(matID == MATWHITE) {\n     \trefl = 0.0;\n        refr = 0.0;\n        emmis = 0.0;\n        absorb = 0.0;\n        IOR = 1.0;\n        roughness = 1.0;\n\n       return vec3(.88, .88, .88);\n    }\n    if(matID == MATWOOD) {\n     \trefl = 0.3;\n        refr = 0.0;\n        emmis = 0.0;\n        absorb = 0.0;\n        IOR = 2.0;\n        roughness = 0.7;\n\n       return vec3(.82, .41, .12);\n    }\n    if(matID == MATMIRROR) {\n     \trefl = 0.98;\n        refr = 0.0;\n        emmis = 0.0;\n        absorb = 0.0;\n        IOR = 2.0;\n        roughness = 0.0;\n\n       return vec3(.7, 0.7, 0.9);\n    }\n    if(matID == MATSLATE) {\n     \trefl = 0.2;\n        refr = 0.0;\n        emmis = 0.0;\n        absorb = 0.0;\n        IOR = 2.0;\n        roughness = 0.8;\n\n       return vec3(.44, 0.5, 0.57);\n    }    \n    if(matID == MATGLASS) {\n     \trefl = 0.0;\n        refr = 1.0;\n        emmis = 0.0;\n        absorb = 0.5;\n        IOR = 1.52;\n        roughness = 0.0;\n\n       return vec3(.44, 0.5, 0.57);\n    }  \n    if(matID == MATWATER) {\n     \trefl = 0.0;\n        refr = 1.0;\n        emmis = 0.0;\n        absorb = 10.0;\n        IOR = 1.3;\n        roughness = 0.0;\n\n       return vec3(.9, 0.9, 0.1);\n    }   \n    if(matID == MATRED) {\n     \trefl = 0.4;\n        refr = 0.0;\n        emmis = 0.0;\n        absorb = 0.0;\n        IOR = 1.0;\n        roughness = 0.7;\n\n       return vec3(.9, 0.1, 0.1);\n    }   \n    if(matID == MATGLASS2) {\n     \trefl = 0.0;\n        refr = 1.0;\n        emmis = 0.0;\n        absorb = 2.0;\n        IOR = 2.3;\n        roughness = 0.7;\n\n       return vec3(.9, 0.1, 0.1);\n    } \n    if(matID == MATDEBUG) {\n     \trefl = 0.0;\n        refr = 0.0;\n        emmis = 0.2;\n        absorb = 0.0;\n        IOR = 2.3;\n        roughness = 0.7;\n\n       return vec3(.9, 0.1, 0.9);\n    }  \nreturn vec3(1.0, 0.0, 1.0);\n}\nvec4 texcube( sampler2D sam, in vec3 p, in vec3 n )\n{\n    vec3 m = n*n;\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n\treturn (x*m.x + y*m.y + z*m.z) / (m.x+m.y+m.z);\n}\n\n//Color correction from Demofox\nvec3 LessThan(vec3 f, float value) {return vec3(lessThan(f, vec3(value)));}//Reccomended change by Dave_Hoskins\n \nvec3 LinearToSRGB(vec3 rgb) {\n    rgb = clamp(rgb, 0.0f, 1.0f);\n     \n    return mix(\n        pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,\n        rgb * 12.92f,\n        LessThan(rgb, 0.0031308f)\n    );\n}\n \nvec3 SRGBToLinear(vec3 rgb) {\n    rgb = clamp(rgb, 0.0f, 1.0f);\n     \n    return mix(\n        pow(((rgb + 0.055f) / 1.055f), vec3(2.4f)),\n        rgb / 12.92f,\n        LessThan(rgb, 0.04045f)\n    );\n}\n\n\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x) {\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n\n\n\n//SDF functions\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat SDFSphere(vec3 point, float radius) {\n    return length(point) - radius;\n}\n\nfloat SDFBox(vec3 point, vec3 size) {\n    vec3 d = abs(point) - size;\n    return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nvec2 Union(in vec2 a, in vec2 b) {\n    return a.x < b.x ? a : b;\n}\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat SmoothMin( float a, float b, float k ) {\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec3 rotateZ( in vec3 p, const float t ) {\n    float co = cos(t);\n    float si = sin(t);\n    p.xy = mat2(co,-si,si,co)*p.xy;\n    return p;\n}\nvec3 rotateY( in vec3 p, const float t ) {\n    float co = cos(t);\n    float si = sin(t);\n    p.xz = mat2(co,-si,si,co)*p.xz;\n    return p;\n}\nvec3 rotateX( in vec3 p, const float t ) {\n    float co = cos(t);\n    float si = sin(t);\n    p.yz = mat2(co,-si,si,co)*p.yz;\n    return p;\n}\nfloat sdCylinderXY( const vec3 p, const vec2 h ) {\n  vec2 d = abs(vec2(length(p.xy),p.z)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat sdCylinderZY( const vec3 p, const vec2 h ) {\n  vec2 d = abs(vec2(length(p.zy),p.x)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat sdCylinder( const vec3 p, const vec2 h ) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2./repetitions*PI;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\nfloat udQuad( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d )\n{\na /= 20.0;\nb /= 20.0;\nc /= 20.0;\nd /= 20.0;\n\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 dc = d - c; vec3 pc = p - c;\n  vec3 ad = a - d; vec3 pd = p - d;\n  vec3 nor = cross( ba, ad );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(dc,nor),pc)) +\n     sign(dot(cross(ad,nor),pd))<3.0)\n     ?\n     min( min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n     dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\n\n\n//for non transparent materials\nfloat FresnelReflectAmount (float n1, float n2, vec3 normal, vec3 incident, float refl)\n{\n\n        // Schlick aproximation\n        float r0 = (n1-n2) / (n1+n2);\n        r0 *= r0;\n        float cosX = -dot(normal, incident);\n        if (n1 > n2)\n        {\n            float n = n1/n2;\n            float sinT2 = n*n*(1.0-cosX*cosX);\n            // Total internal reflection\n            if (sinT2 > 1.0)\n                return 1.0;\n            cosX = sqrt(1.0-sinT2);\n        }\n        float x = 1.0-cosX;\n        float ret = r0+(1.0-r0)*x*x*x*x*x;\n\n        // adjust reflect multiplier for object reflectivity\n        ret = (refl + (1.0-refl) * ret);\n        return ret;\n\n}\n//for transparent materials\nfloat fresnel(in vec3 I, in vec3 N, float eps) \n{ \n    float cosi = clamp( dot(I, N), -1.0, 1.0); \n    \n    float etai = 1.0;\n    float etat = eps; \n    float tmp;\n    if (cosi > 0.0) { tmp = etai; etai = etat; etat = etai; /*swap(etai, etat);*/ } \n    \n    // Compute sini using Snell's law\n    float sint = etai / etat * sqrt(max(0.0, 1.0 - cosi * cosi)); \n    // Total internal reflection\n    if (sint >= 1.0) { \n        return 1.0;\n    } \n    else { \n        float cost = sqrt(max(0.0, 1.0 - sint * sint)); \n        cosi = abs(cosi); \n        float Rs = ((etat * cosi) - (etai * cost)) / ((etat * cosi) + (etai * cost)); \n        float Rp = ((etai * cosi) - (etat * cost)) / ((etai * cosi) + (etat * cost)); \n        return  (Rs * Rs + Rp * Rp) / 2.0; \n    } \n    // As a consequence of the conservation of energy, transmittance is given by:\n    // kt = 1 - kr;\n} \n\n\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by genis sole - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.\n\n#define store(P, V) if (all(equal(ivec2(fragCoord), P))) fragColor = V\n#define load(P) texelFetch(iChannel1, ivec2(P), 0)\n#define key(K)  step(0.5, texelFetch(iChannel0, ivec2(K, 0), 0).x)\n\nconst ivec2 MEMORY_BOUNDARY = ivec2(4, 3);\n\nconst ivec2 POSITION = ivec2(1, 0);\n\nconst ivec2 VMOUSE = ivec2(1, 1);\nconst ivec2 PMOUSE = ivec2(2, 1);\n\nconst ivec2 TARGET = ivec2(0, 2);\n\nconst ivec2 RESOLUTION = ivec2(3, 1);\n\n// Keyboard constants definition\nconst int KEY_BSP   = 8;\nconst int KEY_SP    = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\nconst int KEY_COMMA = 188;\nconst int KEY_PER   = 190;\n\n#define KEY_BINDINGS(FORWARD, BACKWARD, RIGHT, LEFT) const int KEY_BIND_FORWARD = FORWARD; const int KEY_BIND_BACKWARD = BACKWARD; const int KEY_BIND_RIGHT = RIGHT; const int KEY_BIND_LEFT = LEFT;\n\n#define ARROWS  KEY_BINDINGS(KEY_UP, KEY_DOWN, KEY_RIGHT, KEY_LEFT)\n#define WASD  KEY_BINDINGS(KEY_W, KEY_S, KEY_D, KEY_A)\n#define ESDF  KEY_BINDINGS(KEY_E, KEY_D, KEY_F, KEY_S)\n\n#define INPUT_METHOD  WASD\nvec2 KeyboardInput() {\n    INPUT_METHOD\n    \n\tvec2 i = vec2(key(KEY_BIND_RIGHT)   - key(KEY_BIND_LEFT), \n                  key(KEY_BIND_FORWARD) - key(KEY_BIND_BACKWARD));\n    \n    float n = abs(abs(i.x) - abs(i.y));\n    return i * (n + (1.0 - n)*inversesqrt(2.0));\n}\n\nvec3 CameraDirInput(vec2 vm) {\n    vec2 m = vm/iResolution.x;\n    m.y = -m.y;\n    \n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n    mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n    \n    return (rotY * rotX) * vec3(KeyboardInput(), 0.0).xzy * 10.0;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    if (any(greaterThan(ivec2(fragCoord), MEMORY_BOUNDARY))) return;\n    \n    fragColor = load(fragCoord);\n    \n    vec2 resolution = load(RESOLUTION).xy;\n    store(RESOLUTION, vec4(iResolution.xy, 0.0, 0.0));\n    \n    if (iTime == 0.0 || iFrame == 0 || any(notEqual(iResolution.xy, resolution))) {\n        store(POSITION, vec4(0.0, 0.0, 0.0, 0.0));\n        store(TARGET, vec4(0.0, 0.0, 0.0, 0.0));\n        store(VMOUSE, vec4(0.0));\n        store(PMOUSE, vec4(0.0));\n        \n        return;\n    }\n\n    vec3 target      = load(TARGET).xyz;   \n    vec3 position    = load(POSITION).xyz;\n    vec2 pm          = load(PMOUSE).xy;\n    vec3 vm          = load(VMOUSE).xyz;\n    \n    vec3 ptarget = target;\n    target += CameraDirInput(vm.xy) * iTimeDelta * 5.0;\n    \n\n    \n    position += (0.1 * target - position);\n    \n    store(TARGET, vec4(target, 0.0));\n    store(POSITION, vec4(position, 0.0));\n    \n    if (any(greaterThan(iMouse.zw, vec2(0.0)))) {\n    \tstore(VMOUSE, vec4(pm + (abs(iMouse.zw) - iMouse.xy), 1.0, 0.0));\n    }\n    else if (vm.z != 0.0) {\n    \tstore(PMOUSE, vec4(vm.xy, 0.0, 0.0));\n    }\n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Camera and Keyboard input by glk7, from https://www.shadertoy.com/view/4lVXRm\n#define load(P) texelFetch(iChannel1, ivec2(P), 0)\nconst ivec2 VMOUSE = ivec2(1, 1);\nconst ivec2 POSITION = ivec2(1, 0);\n\n\n\n\n\n\nuint wang_hash(inout uint seed) {//random number generator(unsigned integer)\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat RandomFloat01(inout uint state) {//random number generator(float)\n    return float(wang_hash(state)) / 4294967296.0;\n}\n\nvec3 RandomUnitVector(inout uint state, in vec3 nor) {//cosine hemisphere ray direction calculation when ray bounces off an object\n    float u = RandomFloat01(state);\n    float v = RandomFloat01(state) * c_twopi;\n   \n    \t// method 2 by pixar:  http://jcgt.org/published/0006/01/01/paper.pdf\n    \tfloat ks = (nor.z>=0.0)?1.0:-1.0;     //do not use sign(nor.z), it can produce 0.0\n        float ka = 1.0 / (1.0 + abs(nor.z));\n        float kb = -ks * nor.x * nor.y * ka;\n        vec3 uu = vec3(1.0 - nor.x * nor.x * ka, ks*kb, -ks*nor.x);\n        vec3 vv = vec3(kb, ks - nor.y * nor.y * ka * ks, -nor.y);\n    \n        float a = 6.2831853 * v;\n        return sqrt(u)*(cos(a)*uu + sin(a)*vv) + sqrt(1.0-u)*nor;\n}\n\n\nfloat mapLights(vec3 p) {//Light Mapping Function\np += vec3(0,0,0);\nfloat fs2 = SDFBox(p - vec3(0.4,0.2,-2.075), vec3(0.3,0.5,0.1));\nfloat fs3 = SDFBox(p - vec3(-0.4,0.2,-2.075), vec3(0.3,0.5,0.1));\n//float l1 = SDFSphere(p - vec3(-0.4, 0.2, -2.075), 0.25);\n\nreturn min(fs2, fs3);\n//return l1;\n}\n\nvec2 map(vec3 p, in float inside) {//main mapping function\n    float lights = mapLights(p);\n    p += vec3(0,0,0);\n    float f1 = SDFBox(p - vec3(0), vec3(2.1,1.2,2.1));\n    float fs1 = SDFBox(p - vec3(0), vec3(2,2.4,2));\n    float fs2 = SDFBox(p - vec3(-1,-0.1,3.9), vec3(0.5,1,2.3));\n    float fs3 = SDFBox(p - vec3(-1,0.1,3.9), vec3(0.6,1.1,2.1));\n\n    float fs4 = SDFBox(p - vec3(0,1.1,0), vec3(0.75,0.11,0.25));\n\n    float f2 = SDFBox(p - vec3(0,1.1,0), vec3(2.1,0.1,2.1));\n    float f3 = SDFBox(p - vec3(0,-1.1,0), vec3(6.1,0.1,6.1));\n\n    float a1 = sdCylinder(p - vec3(1.35,-0.8,1.35), vec2(0.04,0.4));\n    float a2 = sdCylinder(p - vec3(1.35,-0.8,1.85), vec2(0.04,0.4));\n    float a3 = sdCylinder(p - vec3(0.25,-0.8,1.35), vec2(0.04,0.4));\n    float a4 = sdCylinder(p - vec3(0.25,-0.8,1.85), vec2(0.04,0.4));\n\n    float a5 = SDFBox(p - vec3(-1.8,0,-0.5), vec3(0.3,1,0.75));\n\n    float a6 = SDFBox(p - vec3(-1.8,0,-0.2), vec3(0.3,0.8,0.25));\n    float a7 = SDFBox(p - vec3(-1.8,0,-0.8), vec3(0.3,0.8,0.25));\n    float a8 = SDFBox(p - vec3(0.8, -0.4,1.6), vec3(0.8,0.025,0.4));\n\n    vec3 p2 = rotateX(p - vec3(0.8, -0.275,1.6), 1.57);\n    float a9 = sdHexPrism(p2 , vec2(0.08,0.1));\n\n\n    float a10 = sdCylinder(p - vec3(0.8, -0.255,1.6), vec2(0.06, 0.1));\n    float a11 = sdCylinder(p - vec3(0.8, -0.275,1.6), vec2(0.06, 0.08));\n    float a12 = SDFSphere(p - vec3(0,-0.75,0), 0.25);\n    float a13 = SDFSphere(p - vec3(1,-0.75,0), 0.25);\n    p2 = rotateX(p - vec3(1,-0.75,0.1), 0.83);\n    float a14 = sdCylinder(p2, vec2(0.04,0.4));\n\n    vec2 ret = vec2(min(max(max(max(f1,-fs1),-lights),-fs2),max(fs3,-fs2)), MATBLUE);\n    //vec2 ret = vec2(1000,1000);\n    ret = Union(ret, vec2(max(f2,-fs4), MATWHITE));\n    ret = Union(ret, vec2(f3, MATFLOOR));\n    ret = Union(ret, vec2(lights, MATGLASS));\n    ret = Union(ret, vec2(min(a1,min(a2,min(a3,a4))), MATMETAL));\n    ret = Union(ret, vec2(a5, MATWOOD));\n    ret = Union(ret, vec2(min(a6,a7), MATMIRROR));\n    ret = Union(ret, vec2(a8, MATSLATE));\n    ret = Union(ret, vec2(min(a12, a14), MATRED));\n\n    ret = Union(ret, vec2(a11, MATWATER));\n    //ret = Union(ret, vec2(fs4, MATDEBUG));\n\n\n        if(ret.x < 0.001) return (inside == 1.0) ? vec2(-ret.x, ret.y): ret;\n    ret = Union(ret, vec2(max(a9,-a10), MATGLASS));\n    ret = Union(ret, vec2(max(a13,-a14), MATGLASS2));\n    ret = Union(ret, vec2(fs4, MATGLASS));\n    \n    return (inside == 1.0) ? vec2(-ret.x, ret.y): ret;\n}\n\nvec3 calcNormal( in vec3 pos ) {//normals calculation\n    vec2 eps = vec2(0.0001,0.0);\n\n    return normalize( vec3(\n      map( pos+eps.xyy, 0.0).x - map( pos-eps.xyy, 0.0).x,\n      map( pos+eps.yxy, 0.0).x - map( pos-eps.yxy, 0.0).x,\n      map( pos+eps.yyx, 0.0).x - map( pos-eps.yyx, 0.0).x ) );\n}\n\n#ifdef in1\n\nfloat intersect(in vec3 ro, in vec3 rd, in float inside) {//normal sphere tracing function\n    float res = -1.0;\n    int ignore;\n    float t = 1.0 * max(0.03, map(ro, inside).x);\n    float t_max = 50.0;\n float relax = 1.5;\n    float last_d = 0.0;\n    float last_dt = 0.0;\n    for (int i = 0; i < 128; ++i)\n    {\n        if (t > t_max) break;\n        \n        int curr_id;\n        float d = map(ro + t*rd, inside).x;\n        \n        //test for overrelaxation\n        if (relax != 1.0 && last_dt > abs(last_d) + abs(d))\n        {\n            //if overrelaxed, turn off relaxation and step back\n            t += (1.0 - relax) * last_dt;\n            relax = 1.0;\n            continue;\n        }\n        \n        if (d < 0.005)\n        {\n            break;\n        }        \n        t += relax * d;\n        last_dt = relax * d;\n        last_d = d;\n    } \n    if(t<t_max) res = t;\n    \n    return res;\n    \n}\n\n#else\nfloat intersect(in vec3 ro, in vec3 rd, in float inside) {//normal sphere tracing function\n\tfloat res = -1.0;\n    float tmax = 100.0;\n    float t = 0.001;\n    for(int i = 0; i < 128; i++) {\n    \tfloat h = map(ro+rd*t, inside).x;\n        if((h<0.0001) || (t>tmax)) break;\n        t += h;\n    }\n    if(t<tmax) res = t;\n    \n    return res;\n    \n}\n#endif\n\n\nvec3 calcFinalColor(vec3 ro, vec3 rd, inout uint rngState) {//main function\n    vec3 accumulatedColor = vec3(0.0);\n    vec3 colorMask = vec3(1.0);\n    float fdis = 0.0;\n\n    float emmis, rough, refr, absorb, refl = 0.0;//material properties initialization\n    float IOR = 1.0003;\n        \n    vec3 norm = vec3(0.0);\n    float rand = RandomFloat01(rngState);//initial random number generation\n\n\n    for(int bounce = 0; bounce < BOUNCECOUNT; bounce++) {\n\n\n        #if background == 1\n         vec3 SunDir = normalize(SunPos - ro);\n        #endif\n        rand = RandomFloat01(rngState);//random number generator\n        float preIOR = IOR;\n        float t = intersect(ro, rd, 0.0);\n        vec3 iColor = vec3(0.0);\n    \tif(bounce == 0) fdis = t;\n        vec3 pos = ro + rd*t;\n        vec3 surfaceColor = GetMatProps(map(pos, 0.0).y, refl, refr, emmis, IOR, absorb, rough);//gets material color and properties\n\n\n\n\n        if( t < 0.0 ) {//if ray goes into the void\n            #if background == 0\n                colorMask *= texture(iChannel0, rd).xyz;\n                iColor += texture(iChannel0, rd).xyz+2.0*accumulatedColor;\n                accumulatedColor += iColor * colorMask * 0.5;\n            #elif background == 1\n                colorMask *= sunCol;\n                iColor += max(pow(max(0.0, dot(rd, SunDir)), 20.0),0.0001) * (10.0 * sunCol) + 2.0 * accumulatedColor;\n                accumulatedColor += colorMask * iColor;//pow is to enhance the directionality of it, I wanted sharper shadows, so I did that\n            #elif background == 2\n                break;\n            #endif\n            break;\n        }\n\n         norm = calcNormal(pos);\n\n\n            if(refr == 1.0) {//if material is refractive\n            float eps = IOR;\n            if(t < 0.001) {//theory: if ray is already inside an object, use first calculation, else use second calculation\n                norm = -norm;         \n            }else {\n               eps = preIOR/eps;\n            }\n            \n            rd = (fresnel(rd, norm, preIOR/eps) > rand) ? reflect(rd, norm) : refract(rd, norm, eps);//Fresnel function located in common\n\n            t = intersect(pos, rd, 1.0);\n            pos += rd*t;\n                    \n            colorMask *= exp(-(surfaceColor*absorb) * t * t ); //coloring based on distance ray travels through transparent object\n            \n        }else { //else if material not refractive\n            colorMask *= surfaceColor;\n            \n            float fres = clamp(1.0 - FresnelReflectAmount(preIOR, IOR,rd, norm, refl),0.0,1.0);\n            float gloss = ((fres*fres) > RandomFloat01(rngState)) ? 1.0 : 0.0;\n            vec3 rdreflect = mix( reflect(rd, norm), RandomUnitVector(rngState, norm), ((fres) + gloss));\n            rd = mix(RandomUnitVector(rngState, norm), rdreflect, 1.0 - (rough*rough));\n            }        \n                  \n\t\tro = pos;\n\n        iColor +=  (emmis * surfaceColor) + 2.0 * accumulatedColor * dot(norm, rd);\n\n        accumulatedColor += colorMask * iColor;//apply colors and emmissive to final color\n        \n\n        \n    // Russian Roulette\n    // As the throughput gets smaller, the ray is more likely to get terminated early.\n    // Survivors have their value boosted to make up for fewer samples being in the average.\n    #ifdef Russian\n        float p = max(colorMask.r, max(colorMask.g, colorMask.b));\n        if (RandomFloat01(rngState) > p){ break;}\n\n        // Add the energy we 'lose' by randomly terminating paths\n        colorMask *= 1.0f / p;\n\n    #endif\n    }\n    //distance fog\n    \n   float ff = exp(-0.001*fdis*fdis);\n    accumulatedColor *= ff; \n    accumulatedColor += (1.0-ff)*0.05*vec3(0.9,1.0,1.0);\n   \n    return accumulatedColor;\n}\n\n\n\n\nvoid Camera(in vec2 fragCoord, out vec3 ro, out vec3 rd) {//Camera function to make flying camera\n    ro = load(POSITION).xyz;\n    vec2 m = load(VMOUSE).xy/iResolution.x;\n    m.y = -m.y;\n    \n    float a = 1.0/max(iResolution.x, iResolution.y);\n    rd = normalize(vec3(((fragCoord) - iResolution.xy*0.5)*a, 0.5));\n    \n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n    mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n    \n    rd = (rotY * rotX) * rd;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n\n vec3 col = vec3(0);\n float blend = 0.0;\n \n    vec2 jitter = vec2(RandomFloat01(rngState), RandomFloat01(rngState)) - 0.5f;//anti-aliasing\n\n    vec3 ro, rd = vec3(0.0);\n    Camera(fragCoord + jitter, ro, rd);\n    col = calcFinalColor(ro, rd, rngState);\n\n    vec4 lastFrameColor = texture( iChannel2, fragCoord/iResolution.xy );//Blending previous frames with current frame\n    blend = (lastFrameColor.a == 0.0f || iMouse.z > 1.0) ? 1.0f : 1.0f / (1.0f + (1.0f / lastFrameColor.a));\n    col = mix(lastFrameColor.rgb, col, blend);\n \n fragColor = vec4(col, blend);\n //fragColor = vec4(col, min(1.0, float(iFrame)));\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//Temporal sampling\n\nfloat grayscale(vec3 image) {\n    return dot(image, vec3(0.3, 0.59, 0.11));\n}\n\nfloat normpdf(in float x, in float sigma)\n{\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  lowp vec2 uv = fragCoord.xy / iResolution.xy;\n\n    \n  lowp vec3 imageacc = max( texture(iChannel1,uv).rgb , vec3(0.0));\n  lowp vec3 image = max( texture(iChannel0,uv).rgb , vec3(0.0));  \n\n    //declare stuff\n    const int mSize = 9;\n    const int kSize = (mSize-1)/2 ;\n    float kernel[mSize];\n    vec3 imageblurred = vec3(0.0);\n\n    //create the 1-D kernel\n    float sigma = 1.5;\n    float Z = 0.0;\n    for (int j = 0; j <= kSize; ++j)\n    {\n        kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);\n    }\n\n    //get the normalization factor (as the gaussian has been clamped)\n    for (int j = 0; j < mSize; ++j)\n    {\n        Z += kernel[j];\n    }\n\n    //read out the texels\n    for (int i=-kSize; i <= kSize; ++i)\n    {\n        for (int j=-kSize; j <= kSize; ++j)\n        {\n            imageblurred += kernel[kSize+j]*kernel[kSize+i]*texture(iChannel0, (fragCoord.xy+vec2(float(i),float(j))) / iResolution.xy).rgb;\n\n        }\n    }   \n    \n    imageblurred = imageblurred / (Z*Z);  \n    \n    image = min(image, imageblurred); // reduce fireflies    \n\n    if (iMouse.z < 0.5) \n    {\n        // attempt to reduce ghosting\n        lowp float weight = grayscale( pow( clamp( abs(imageacc - image) * 0.3 , 0., 1.), vec3(0.5)));\n        imageacc = mix(imageacc, image, clamp(weight + 0.1, 0., 1.));\n    } else { \n\n        imageacc = image;\n    }\n    \n    fragColor = vec4(imageacc,1.0);\n\n\t\n}","name":"Buffer C","description":"","type":"buffer"}]}