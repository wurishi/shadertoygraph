{"ver":"0.1","info":{"id":"dlfXzl","date":"1675362123","viewed":573,"name":"A Flimsy Rocket Paperplane...","username":"msm01","description":"Did it for my blog, and finished too late ! I still have NO IDEA what I'm doing. BUT. I'm back with a paperplane and a laser lightshow, so there is that. Hope you enjoy the mood. And the Great Dome-City of Flamicogyre !","likes":54,"published":1,"flags":96,"usePreview":0,"tags":["2d","space","planet","city","scifi","dome"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// FUN FACT : If you put a few specks of antimatter in a clervely-designed\n// container at the back of a paperplane, you can propel it at high speed\n// through a moderately dense atmosphere ! The game was first invented on\n// Mars at the end of the 21st century. It requires small-scale force-fields\n// though...\n\n// WARNING : Rocket paperplanes are highly unstable at hypersonic regime, due\n// to the force-field being extra-slippery, but not \"perfectly\" so...\n// SO DO NOT GO OVER THE SPEED LIMIT !\n\n// WARNING : Antimatter is expensive, and can be tricky to handle. WEAR\n// GLOVES, GLASSES AND USE EXTREME CAUTION AT ALL TIMES !\n\n// FUN FACT : To obtain small, recreational quantities of antimatter, contact\n// the nearest particle accelerator and pretend it's for educational purpose.\n// Usually works better in May, when managers are drowning in administrative\n// paperwork !\n\n// Also, Happy New Year to you all !\n\n// Use this code as you wish, just try to give proper credit when so.\n// https://creativecommons.org/licenses/by-nc-sa/3.0/\n\n// Music is \"Stingray\" by Malmen, thanks A LOT for sharing your music !\n// https://soundcloud.com/malmen/malmen-stingray\n// https://creativecommons.org/licenses/by-nc-sa/3.0/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     vec2 p = fragCoord.xy/iResolution.xy;\n     \n     vec4 col = vec4(1.0,1.0,1.0,1.0);\n     float chromab = length(p-vec2(0.5,0.5));\n     col.r = texture(iChannel0,p + vec2( 0.004*chromab)).x;\n     col.g = texture(iChannel0,p + vec2( 0.000*chromab)).y;\n     col.b = texture(iChannel0,p + vec2(-0.004*chromab)).z;\n     \n     // This (badly) fakes the old dot matrix screens...\n     // Like an old flipper.\n     if( mod(TimeVar,MusicTimeBase)>MusicTimeBase/2.0 &&\n         mod(fragCoord.y,4.0) > 2.0                   &&\n         mod(fragCoord.x,4.0) > 2.0                       )\n     {\n         col *= vec4(0.7,0.7,0.7,1.0);\n     };\n\n     // POP POP THE CHAMPAGNE !\n     fragColor = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4t2XWV","filepath":"https://soundcloud.com/malmen/malmen-stingray","previewfilepath":"https://soundcloud.com/malmen/malmen-stingray","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"mat2 r2d( float a ){ float c = cos(a), s = sin(a); return mat2( c, s, -s, c ); }\nfloat noise(vec2 st) { return fract( sin( dot( st.xy, vec2(12.9898,78.233)))*43758.5453123 ); }\n\n// Basic Geometry Functions.\n\nfloat sdCircle(in vec2 p, float radius, vec2 pos, float prec)\n{\n      return smoothstep(0.0,prec,radius - length(pos-p));\n}\n\n// This belongs to Iq...\nfloat dis_e(vec2 center, float a, float b, vec2 coord)\n{\n      float x2 = (coord.x-center.x)*(coord.x-center.x);\n      float y2 = (coord.y-center.y)*(coord.y-center.y);\n      float a2 = a*a;\n      float b2 = b*b;\n      float d = 1.0;\n      d = x2/a2+y2/b2;\n      return d;\n}\n\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n      vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n      vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n      vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n      vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n      vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n      float s = sign( e0.x*e2.y - e0.y*e2.x );\n      vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                       vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                       vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n      return -sqrt(d.x)*sign(d.y);\n}\n\n// This belongs to a nice shadertoy coder whose name I lost.\n// Please tell me if you read this !\nfloat metaDiamond(vec2 p, vec2 pixel, float r, float s)\n{\n      vec2 d = abs((p-pixel));\n      return r / (d.x + d.y);\n}\n\n// That's it guys, everything else is mine.\n\nvec4 drawAtmoGradient(in vec2 v_p)\n{\n     return mix( vec4(1.0,0.6,0.1,1.00),vec4(0.5,0.2,0.5,1.00),sqrt(abs(2.7*v_p.y)) - 1.0);\n}\n\n// Simple Value Noise Please\nfloat fbm(in vec2 v_p)\n{\n      float VarX1 = 0.0;\n      float VarX2 = 0.0;\n      float VarD0 = 0.0;\n      float VarS1 = 0.0;\n      float Amplitude = 1.0/2.0;\n      float Periode   = 2.0;\n      VarX1 = Amplitude*floor( Periode*v_p.x);\n      VarX2 = Amplitude*floor( Periode*v_p.x + 1.0);\n      VarD0 = fract( Periode*v_p.x);\n      VarS1 += mix( noise(vec2(VarX1)), noise(vec2(VarX2)), smoothstep( 0.0, 1.0, VarD0));\n      return VarS1;\n}\n\n// A starfield\nfloat drawStars(in vec2 v_p)\n{\n      float Disp_Star = 0.000;\n      float Accu_Star = 0.000;\n      float PosX_Star = 0.000;\n      float PosY_Star = 0.000;\n      float Dist_Star = 0.000;\n\n      for( int j = 0; j < 50 ; j++ )\n      {\n           PosX_Star  = mod((4.0*noise(vec2(j))-2.0) - Disp_Star,4.0) - 2.0;\n           PosY_Star  = 1.9*noise(vec2(j + 2))+ 0.5;\n           Dist_Star  = length(v_p - vec2(PosX_Star,PosY_Star));\n           Accu_Star += 0.0002*pow(Dist_Star,-1.1);\n      };\n      return Accu_Star;\n}\n\n// Text function...\nvec4 traceChar( in vec2 v,float charac, vec2 PosTxt)\n{\n     vec4 colorT = vec4(0.0,0.0,0.0,1.0);\n     v = vec2(v.x, 1.0-v.y);\n     float DispY,DispX;\n     DispX = mod(charac,16.0)/16.0;\n     DispY = floor(charac/ 16.0)/16.0;\n\n     if( v.x > PosTxt.x\n      && v.x < PosTxt.x + 1.0/16.0 )\n     {\n         if( v.y > PosTxt.y\n          && v.y < PosTxt.y + 1.0/16.0 )\n         {\n             colorT += texture(iChannel3,\n                               vec2( DispX + (v.x-PosTxt.x),-DispY - (v.y-PosTxt.y)) ).xxxx;\n         };\n     };\n     return colorT;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     vec2 p = vec2( (iResolution.x/iResolution.y)\n                  * (fragCoord.x - iResolution.x/2.0)\n                  / iResolution.x,\n                    fragCoord.y / iResolution.y);\n\n     float TiltX =  -0.001*(iMouse.x - iResolution.x/2.0);\n     float AltiY =   0.005*(iMouse.y - iResolution.y/2.0);\n\n     vec4 col = vec4(0.0,0.0,0.0,1.0);\n     \n     float Beat = 64.0/MusicTimeBase;\n\n     if( ( TimeVar > 2.0*MusicTimeBase && TimeVar < 3.0*MusicTimeBase ) ||\n         ( TimeVar > 4.0*MusicTimeBase && TimeVar < 5.0*MusicTimeBase )    )\n     {\n         p = 0.0075*floor(133.333*p); // Pixel Mode\n     };\n\n     vec2 last_p = p;\n\n     col = drawAtmoGradient(p);\n\n     // Zoom back during the entire show\n     p *= (1.0 + 0.005*TimeVar);\n\n     // Random global animations/zooms/rotations at some timecodes...\n     if( ( TimeVar > 4.0*MusicTimeBase )\n     &&  ( TimeVar < 5.0*MusicTimeBase ) )\n     {\n         p *= r2d(0.20*fbm(vec2(floor(TimeVar*Beat))) - 0.1);\n         p *= 1.0+(0.20*fbm(vec2(floor(TimeVar*Beat))) - 0.1);\n     };\n\n     // Draw starfield but not on the three planets !\n     if( length(p - vec2( 0.70,0.90)) - 0.09 > 0.0\n      && length(p - vec2(-0.60,0.75)) - 0.19 > 0.0 \n      && length(p - vec2( 0.74,0.92)) - 0.03 > 0.0  )\n     {\n        col = mix(col,vec4(1.0),drawStars(p));\n     };\n\n     // Stars and planets\n     Beat = 4.0/MusicTimeBase;\n     col += vec4(1.0,0.5,0.2,1.0)*sdCircle(p,0.14 + 0.01*sin(TimeVar*3.14/Beat),vec2(0.0,0.9),0.1);\n     col += vec4(1.0,0.4,0.1,1.0)*metaDiamond(p,vec2(0.0,0.9),0.05,0.0);\n     col += vec4(1.0,0.7,0.5,1.0)*metaDiamond(p,vec2(0.15,0.8),0.008 + 0.003*sin(TimeVar*3.14/(0.5*Beat) + 3.14),0.0);\n\n     // Anamorphic streak\n     col += vec4(0.35,0.25,0.0,1.0)\n            *smoothstep(0.025,0.0,abs(sin(p.y - 0.9))      )\n            *smoothstep(0.000,0.5,abs(cos(p.x      )) - 0.7);\n\n     // Planet 1\n     float FD1 = sdCircle(p,0.10,vec2( 0.70, 0.9), 0.01);\n     float DS1 = sdCircle(p,0.17,vec2( 0.75, 0.9), 0.07);\n     float Croissant1 = FD1 - DS1;\n     col += clamp(Croissant1,0.0,1.0);\n\n     // Planet 2\n     float FD2 = sdCircle(p,0.20,vec2(-0.60, 0.75), 0.01);\n     float DS2 = sdCircle(p,0.27,vec2(-0.64, 0.74), 0.07);\n     float Croissant2 = (FD2 - DS2);\n     col += 0.2*FD2*texture(iChannel2,p);\n     col += clamp(Croissant2,0.0,1.0);\n\n     // Planet 3\n     float FD3 = sdCircle(p,0.03,vec2( 0.74, 0.92), 0.005);\n     float DS3 = sdCircle(p,0.04,vec2( 0.76, 0.92), 0.010);\n     float Croissant3 = (FD3 - DS3);\n     col += 0.1*FD3*texture(iChannel2,p);\n     col += 0.25*clamp(Croissant3,0.0,1.0);\n\n     // Mountains\n     col = mix(col,\n               vec4(0.35,0.15,0.15,1.0),\n               smoothstep(0.007,0.0,p.y - 0.04*fbm(vec2(7.0*p.x))  - 0.41) );\n     // Mountains Highlights\n     col += vec4(0.2,0.17,0.10,1.0)\n           *texture(iChannel0,p)\n           *fbm(vec2(20.0*p.x))\n           *smoothstep(0.01,0.0,p.y - 0.04*fbm(vec2(7.0*p.x))  - 0.41);\n\n     // Ground Color\n     col = mix(col,vec4(0.3,0.1,0.1,1.0),smoothstep(0.001,0.0,p.y - 0.40) );\n\n     // Dome City\n\n     // Structural Ellipsis - background\n     float Factor01 = 0.4 + 0.1*TimeVar;\n     if( p.y > 0.4325 && (r2d(Factor01)*(p-vec2( 0.0,0.42))).y < 0.0 )\n         col += 0.1\n                *vec4(1.0,1.0,0.2,1.0)\n                *smoothstep(0.0001,0.0,abs(dis_e(vec2(0.0,0.0),4.2,1.5,r2d(Factor01)*(p-vec2( 0.0,0.42))) - 0.005));\n     Factor01 = 2.5 - 0.1*TimeVar + 3.14159/2.0;\n     if( p.y > 0.4325 && (r2d(Factor01)*(p-vec2( 0.0,0.42))).y < 0.0 )\n         col += 0.1*vec4(1.0,1.0,0.2,1.0)*smoothstep(0.0001,0.0,abs(dis_e(vec2(0.0,0.0),4.2,1.5,r2d(Factor01)*(p-vec2( 0.0,0.42))) - 0.005));\n\n     if( p.y > 0.4 )\n     {\n         if( (length(p - vec2(0.0, 0.42)) - 0.25) < 0.0)\n         {\n             // Draw the skyline like it's drenched in sunlight, with an offset\n             p += vec2(sign(p.x)*0.004,-0.005);\n             col += 2.0*vec4(1.0,0.7,0.6,1.0)\n                    *texture(iChannel2,vec2(0.4,20.0)*p).xxxx\n                    *(0.1+0.9*smoothstep(0.0,0.99,fbm(vec2(120.0*p.x + 250.5))))\n                    *smoothstep(0.004,0.0,p.y - 0.19*fbm(vec2(floor(50.0*p.x)))- 0.02*fbm(vec2(floor(70.0*p.x))) - 0.42);\n             p -= vec2(sign(p.x)*0.004,-0.005);\n\n             // Draw the real Skyline\n             col = mix(col,\n                       3.5*vec4(0.8,0.6,0.5,1.0)*texture(iChannel2,vec2(0.4,20.0)*p).xxxx\n                       *(0.1+0.9*smoothstep(0.0,0.99,fbm(vec2(120.0*p.x + 250.5)))),\n                       smoothstep(0.004,0.0,p.y - 0.19*fbm(vec2(floor(50.0*p.x))) - 0.02*fbm(vec2(floor(70.0*p.x))) - 0.42));\n\n             // Draw the smaller skyline like it's drenched in sunlight, with an offset\n             p += vec2(sign(p.x)*0.002,-0.004);\n             col = mix(col,\n                       5.0*vec4(1.0,0.5,0.4,1.0)\n                       *texture(iChannel2,vec2(0.4,20.0)*p)\n                       *(1.0-0.95*smoothstep(0.0,0.9,fbm(vec2(100.0*p.x)))),\n                       smoothstep(0.004,0.0,p.y - 0.10*fbm(vec2(floor(40.0*p.x)))  - 0.42));\n             p -= vec2(sign(p.x)*0.002,-0.004);\n\n             // Draw the smaller Skyline\n             col = mix(col,\n                       vec4(0.8,0.5,0.4,0.8)\n                       *texture(iChannel2,vec2(0.4,20.0)*p)\n                       *(2.0-1.95*smoothstep(0.0,0.9,fbm(vec2(100.0*p.x)))),\n                       smoothstep(0.004,0.0,p.y - 0.10*fbm(vec2(floor(40.0*p.x)))  - 0.42));\n\n             // Add some trees at the bottom... :)\n             col = mix(col,vec4(0.1,0.5,0.1,1.0)*texture(iChannel0,2.0*p),smoothstep(0.0025,0.0,p.y - 0.01*fbm(vec2(25.0*p.x)) - 0.43));\n\n             // Add some glow at low altitude (useful for night scenes\n             // and/or giving the dome some glow)\n             col += vec4(0.9,0.7,0.4,1.0)*smoothstep(0.07,0.0,p.y - 0.43);\n         };\n\n         // Dome General Color\n         col = mix(col,vec4(1.0,0.6,0.5,0.1),0.4*sdCircle(p,0.3,vec2( 0.0,0.4),0.001));\n\n         // Dome Base\n         if( (length(p - vec2(0.0, 0.42)) - 0.3) < 0.0 )\n         {\n             col = mix(col,vec4(0.5,0.3,0.3,1.0)*(0.75 + 0.25*texture(iChannel0,p).xxxx) - 0.1*smoothstep(0.0,1.0,cos(5.0*p.x)),smoothstep(0.005,0.0,abs(p.y - 0.41) - 0.02));\n             // Lights / portholes\n             col += vec4(1.0,0.3,0.2,1.0)*abs(cos(1000.0*cos(p.x)))*smoothstep(0.002,0.0,abs(p.y - 0.42));\n             float ColorLarson = mod(floor(TimeVar * Beat),4.0);\n             vec4 ColorLarsonV = vec4(1.0,1.0,1.0,1.0);\n             switch( int(ColorLarson) )\n             {\n                      case 0  : ColorLarsonV = vec4(1.0,0.5,0.5,1.0); break;\n                      case 1  : ColorLarsonV = vec4(0.2,1.0,0.2,1.0); break;\n                      case 2  : ColorLarsonV = vec4(0.2,0.2,1.0,1.0); break;\n                      case 3  : ColorLarsonV = vec4(1.0,0.5,0.2,1.0); break;\n                      default : ColorLarsonV = vec4(1.0,1.0,1.0,1.0); break;\n             };\n             col += smoothstep(0.0,0.5,clamp(cos(20.0*(p.x - TimeVar)),0.0,1.0))*ColorLarsonV*abs(cos(1000.0*cos(p.x)))*smoothstep(0.010,0.0,abs(p.y - 0.42));\n         };\n\n         // Wide Dome Entrance - Reminiscent of NASA lunar bases...\n         col = mix(col,\n                   vec4(0.9,0.4,0.3,1.0),\n                   smoothstep(0.01,0.0,abs(p.x)-0.03)*smoothstep(0.002,0.0,abs(p.y - 0.405)-0.005));\n     };\n\n     // Dome Outer-Shine : gives off a \"spherical feeling\".\n     if((length(p - vec2(0.0, 0.42)) - 0.3) < 0.0 && p.y>0.43)col += 1.9*vec4(0.9,0.5,0.4,0.1)*smoothstep(1.0,0.0,sdCircle(p,0.41,vec2( 0.0,0.38),0.17))*smoothstep(0.0,0.01,length(p-vec2(0.0,0.4)));\n\n     // Structural Ellipsis - foreground\n     if(p.y>0.4325 && (r2d(0.4 + 0.1*TimeVar)*(p-vec2( 0.0,0.42))).y > 0.0)col += 0.9*vec4(1.0,1.0,0.2,1.0)*smoothstep(0.0001,0.0,abs(dis_e(vec2(0.0,0.0),4.2,1.5,r2d(0.4 + 0.1*TimeVar)*(p-vec2( 0.0,0.42))) - 0.005));\n     if(p.y>0.4325 && (r2d(2.5 - 0.1*TimeVar + 3.14159/2.0)*(p-vec2( 0.0,0.42))).y > 0.0)col += 0.9*vec4(1.0,1.0,0.2,1.0)*smoothstep(0.0001,0.0,abs(dis_e(vec2(0.0,0.0),4.2,1.5,r2d(2.5 - 0.1*TimeVar + 3.14159/2.0)*(p-vec2( 0.0,0.42))) - 0.005));\n\n     // Star Dome-Reflection\n     col += vec4(1.0,1.0,1.0,1.0)\n           *metaDiamond(p,vec2(0.0,0.72),0.005 + 0.002*sin(TimeVar*3.14/Beat),0.0);\n\n     if(p.y < 0.4)\n     {\n        // Receding ground\n        col -= 0.05*vec4(texture(iChannel0,vec2( 0.1*p.x/(0.40-p.y),0.19*sin(0.3/(0.40-p.y) - 15.5*TimeVar))));\n\n        // Ground light\n        p *= 1.0/(1.0 + 0.005*TimeVar);\n        col += 0.3*vec4(1.0,0.5,0.2,1.0)*sdCircle(p,0.6,vec2(0.0,0.4),0.3);\n        p *= (1.0 + 0.005*TimeVar);\n     };\n\n     vec2 PosLaser;\n     if( ( TimeVar > 4.0*MusicTimeBase && TimeVar < 6.0*MusicTimeBase ) ||\n         ( TimeVar > 8.0*MusicTimeBase )\n     )\n     {\n         // Choose a random laser source between 4...\n         float SourceLaser = mod(floor(4.0*fbm(vec2(0.5*TimeVar))),4.0);\n         switch(int(SourceLaser))\n         {\n                case 0:PosLaser = vec2( 0.0,-0.43);break;\n                case 1:PosLaser = vec2( 0.0,-0.72);break;\n                case 2:PosLaser = vec2(-0.3,-0.43);break;\n                case 3:PosLaser = vec2( 0.3,-0.43);break;\n         };\n         p += PosLaser; // Move To Current Laser Source\n         Factor01 = 5.0*TimeVar;\n         p*=r2d( 2.5*fbm(vec2(Factor01)) - 1.25 + 3.14159 + TimeVar);\n         col += vec4(0.0,1.0,0.0,1.0)*smoothstep(0.0001 + 0.03*length(p),0.0,abs(p.y) + 0.005*fbm(vec2(40.0*p.x) - 150.0*TimeVar));\n         p*=r2d(-2.5*fbm(vec2(Factor01)) + 1.25 - 3.14159 - TimeVar);\n\n         p*=r2d(-2.5*fbm(vec2(Factor01 + 105.6)) + 1.25 + 3.14159 + TimeVar);\n         col += vec4(0.5,0.5,1.0,1.0)*smoothstep(0.0001 + 0.03*length(p),0.0,abs(p.y) + 0.005*fbm(vec2(40.0*p.x) - 150.0*TimeVar));\n         p*=r2d( 2.5*fbm(vec2(Factor01 + 105.6)) - 1.25 - 3.14159 - TimeVar);\n\n         p*=r2d(-4.5*fbm(vec2(Factor01 + 175.1)) + 2.5 + 3.14159 + TimeVar);\n         col += vec4(1.0,1.0,1.0,1.0)*smoothstep(0.0001 + 0.03*length(p),0.0,abs(p.y) + 0.005*fbm(vec2(40.0*p.x) - 150.0*TimeVar));\n         p*=r2d( 4.5*fbm(vec2(Factor01 + 175.1)) - 2.5 - 3.14159 - TimeVar);\n         p -= PosLaser;\n\n         // Draw a halo on the source position\n         col += vec4(1.0,1.0,1.0,1.0)*metaDiamond(p,vec2(-PosLaser),0.004,0.0);\n\n     };\n\n     // Adding an \"atmospheric speed effect\"\n     // similar to the ground effect, but way, way more transparent...\n     if(p.y > 0.4)col += (0.02 + 0.02*fbm(vec2(TimeVar)))*vec4(texture(iChannel0,vec2( 0.1*p.x/(p.y-0.4),0.19*sin(0.3/(p.y-0.4) - 15.5*TimeVar))));\n\n     // Just a dust line on the horizon... looks better. :)\n     col = mix(col,1.2*vec4(0.35,0.15,0.15,1.0),smoothstep(0.004,0.0,abs(p.y-0.40)));\n\n     // The Paperplane !\n\n     // Quick'n easy fix to make the paperplane colors blend perfectly into the scene...\n     vec4 GeneralBrightness = 1.5*vec4(1.0);\n     // Pretty straightforward...\n     float AltitudePaperplane = 0.6;\n\n     // We want the paperplane to always be at the front so we cancel the \"global zoom back\"\n     p *= 1.0/(1.0 + 0.005*TimeVar);\n     //p.x = -p.x;\n\n     // Minute rotations and translations, less static that way...\n     p *= r2d(0.05*fbm(vec2(0.1*TimeVar)));\n     p.y += 0.01*sin(0.1*TimeVar);\n\n     // Fine-tuning contrail Y position\n     p.y -= 0.4;\n     // Positioning contrail by rotating it.\n     p*=r2d(-1.21);\n     // Thruster Contrail\n     if(p.y < AltitudePaperplane && p.y > 0.0)col += 2.0*vec4(1.0,0.7,0.5,1.0)*smoothstep(0.001 + 0.05*length(p),0.0,abs(p.x) + 0.01*fbm(vec2(10.0*p.y + 20.0*TimeVar)))*smoothstep(0.0,0.8,p.y);\n     p*=r2d( 1.21);\n     p.y += 0.4;\n\n     // Fine-tuning x pos...\n     p.x -= 0.1;\n\n     // Thruster diamond flame, pulsating for effect...\n     col += vec4(1.0,1.0,0.75,1.0)*clamp(metaDiamond(p,vec2(0.40,0.59),0.01 + 0.005*sin(60.0*TimeVar),0.0),0.0,1.0);\n\n     // How to draw an (admittedly) strange arrow paperplane in 3 triangles... A tutorial.\n\n     vec2 Arrowhead = vec2(0.50,0.64);\n\n     // The fbm parts are for making the wingtips wobble fast like there's a little\n     // residual wind inside the flow-control bubble-shield... because an active\n     // system that small can not be perfect.\n     col = mix( col,\n                GeneralBrightness*0.8*vec4(1.0,0.7,0.4,1.0),\n                smoothstep(0.001,0.0,\n                sdTriangle(p,vec2(0.4,0.6),\n                             vec2(0.40+0.01*fbm(vec2(70.0*TimeVar)), 0.68+0.01*fbm(vec2(70.0*TimeVar))),\n                             Arrowhead)));\n     col = mix( col,\n                GeneralBrightness*vec4(0.5,0.25,0.2,1.0),\n                smoothstep(0.001,0.0,\n                sdTriangle(p,vec2(0.4,0.6),\n                             vec2(0.49+0.01*fbm(vec2(70.0*TimeVar+1.1)), 0.53+0.01*fbm(vec2(70.0*TimeVar+1.1))),\n                             Arrowhead)));\n     col = mix(col,\n               GeneralBrightness*vec4(1.0,0.7,0.4,1.0),\n               smoothstep(0.001,0.0,\n               sdTriangle(p,vec2(0.4,0.6),\n                            vec2(0.33,0.53+0.01*fbm(vec2(70.0*TimeVar+2.2))),\n                            Arrowhead)));\n\n     // Un-Fine-tuning x pos...\n     p.x += 0.1;\n     //p.x = -p.x;\n\n     // let's go back to p before tracing the paperplane...\n     p = last_p;\n\n     // Text\n\n     if( TimeVar > MusicTimeBase )\n     {\n         float TabTxt[16] = float[]( 72.0 ,65.0 ,80.0 ,80.0 ,89.0 ,32.0 ,78.0 ,69.0 ,87.0 ,32.0 ,89.0 ,69.0 ,65.0 ,82.0 ,32.0 ,33.0 );\n         vec2 centrage = vec2(0.0 - 8.0*0.028,0.9);\n\n         // Let's zoom to make the text bigger...\n         p *= 0.35;\n\n         if( ( TimeVar > 4.0*MusicTimeBase && TimeVar < 6.0*MusicTimeBase ) ||\n             ( TimeVar > 2.0*MusicTimeBase && TimeVar < 3.0*MusicTimeBase ) ||\n               TimeVar > 8.0*MusicTimeBase )\n         {\n             centrage += vec2(0.25*fbm(vec2(floor(TimeVar*64.0/MusicTimeBase) + 1.7)) - 0.125,\n                              0.25*fbm(vec2(floor(TimeVar*64.0/MusicTimeBase) + 0.4)) - 0.125 - 0.15);\n             p *= r2d(0.90*fbm(vec2(floor(TimeVar*64.0/MusicTimeBase))) - 0.45);\n         };\n\n         // We're gonna make A LOT of scaling so... better save a correct base for later.\n         last_p = p;\n\n         // Draw the text 10 times with a small offset...\n         for( int j = 0; j < 10; j++)\n         {\n              for( int i= 0; i < 16; i++)\n              {\n                   centrage.y += 0.01*sin(15.0*p.x + 8.0*TimeVar - 1.5);\n                   col += vec4(0.8,0.3,0.1,1.0)*(0.02*mod(float(j) - 50.0*TimeVar,20.0))*traceChar(p,TabTxt[i], centrage + vec2(0.028*mod(float(i),39.0),0.0));\n                   centrage.y -= 0.01*sin(15.0*p.x + 8.0*TimeVar - 1.5);\n              };\n              p *= 1.02;\n         };\n\n         // RE-LOOO-OOOAAAD !\n         p = last_p;\n\n         // Let's draw the text one more time, but flat, and over the rest,\n         // with a scroller effect...\n         for( int i = 0; i < 16; i++)\n         {\n              centrage.y += 0.01*cos(15.0*(p.x-0.5) + 8.0*TimeVar - 1.5);\n              if(mod(float(i) - 25.0*TimeVar,18.0) > 10.0)col = mix(col,vec4(1.0,0.95,0.5,1.0),traceChar(p,TabTxt[i], centrage + vec2(0.028*mod(float(i),39.0),0.0)));\n              centrage.y -= 0.01*cos(15.0*(p.x-0.5) + 8.0*TimeVar - 1.5);\n         };\n     };\n\n     // Color-flooding for the last seconds of the show...\n     if( TimeVar > 8.0*MusicTimeBase )\n     {\n         float ColorSplash = mod(floor(TimeVar/(MusicTimeBase/64.0)),5.0);\n         switch( int(ColorSplash) )\n         {\n                 case 0  : col *= vec4(1.0,0.1,0.7,1.0);break;\n                 case 1  : col *= vec4(0.0,0.8,0.0,1.0);break;\n                 case 2  : col *= vec4(1.0,1.0,1.0,1.0);break;\n                 case 3  : col *= vec4(0.0,0.5,1.0,1.0);break;\n                 case 4  : col *= vec4(1.0,0.7,0.0,1.0);break;\n                 default : col *= vec4(1.0,0.7,0.4,1.0);break;\n         };\n     };\n\n     fragColor = vec4(col);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define TimeVar mod(iTime,277.279)\n#define MusicTimeBase 22.33","name":"Common","description":"","type":"common"}]}