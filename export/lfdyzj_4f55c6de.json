{"ver":"0.1","info":{"id":"lfdyzj","date":"1732859597","viewed":40,"name":"Ray Marching - 2D Visualization","username":"Ponjee","description":"Rays","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","raymarch","sdf","distance"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ShaderToy fragment shader\n\nconst float PI = 3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117067982148086513282306647093844609550582231725359408128481;\nvec2 ro = vec2( 0.0, 1.0 );\nvec2 rd = vec2( 0.0, 1.0 );\n\n\n// Rotation matrices\nvec2 rotateVec2(vec2 p, float a) {\n    return vec2(\n        p.x*cos(a) - p.y*sin(a), \n        p.x*sin(a) + p.y*cos(a)\n    );\n}\n\n// Map function to find the distance to the nearest object\nfloat map(vec2 p) {\n    float l = 5.0;\n    \n    vec2 scene_pos = vec2(0.,0.4);\n    float scene_rot = 0.8;\n    \n    float d1 = sdCircle(rotateVec2(p,scene_rot)-scene_pos, 0.5);\n    float d2 = sdBox(rotateVec2(p,scene_rot)-vec2(0.,-0.5)-scene_pos, vec2(0.08, 0.2));\n    float d3 = sdSegment(rotateVec2(p,scene_rot)-vec2(0.,-0.3)-scene_pos, vec2(0.,0.), vec2(0.,-1.));\n    \n    float _d1 = opUnion(d1,d2);\n    \n    //return vec4(\n    //opUnion(_d1,_d2)\n    //,vec3(1.));\n    \n    return opUnion(_d1, d3-0.02);\n}\n\n// returns the distance to the circles that represent \nfloat castRay( vec2 p, vec2 ro, vec2 rd ) {\n    float totalDist = 0.0;\n    float d = map(ro);\n    float cd = 1000.0; // circle dists\n    float pd = 1000.0; // point dists\n    for (int i = 0; i < 10/*MAX_STEPS*/; i++) {\n        vec2 p0 = ro + totalDist * rd;\n        d = map(p0);\n        \n        cd = min(cd, abs(sdCircle(p-p0,abs(d))));\n        pd = min(pd, sdCircle(p-p0,0.03));\n        \n        if (d < 0.01/*MIN_DIST*/) totalDist;\n        totalDist += d;\n        \n        if (totalDist > 50.0/*MAX_DIST*/) break;\n    }\n    return min(min(cd,pd), sdSegment(p,ro,ro + rd*totalDist));\n}\n\n// Main function\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Other display variables\n    vec2 displaySize = iResolution.xy; // 1920,1080   800,450\n    float zoom = 1.25; \n    // 1.0 zoom with a circle of radius '1.0' at (0,0) will be displayed with a radius \n    // of 225 (touching top and bottom of the screen with a 800x450 res).\n    \n    \n    // p and m are localized positions to the scene\n    vec2 p = (2.0*fragCoord-displaySize.xy)/displaySize.y;\n    p *= zoom;\n    vec2 m = (2.0*iMouse.xy-displaySize.xy)/displaySize.y;\n    m *= zoom;\n    \n    float t0 = iTime/2.0;\n    float t1 = iTime/8.0;\n    ro = vec2( cos(t1)-sin(t1), sin(t1)+cos(t1) ) * 1.0;\n    rd = vec2( cos(t0), sin(t0) );\n    \n    // Perform ray marching\n    float d = map( p );\n    \n    bool hit = (d <= 0.0 ? true : false);\n    \n    // Coloring the SDFs\n    vec3 col;\n    \n    // Coloring used by iquilezles' SDFs\n    col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n    col *= 1.0 - exp(-6.0*abs(d));\n    col *= 0.8 + 0.2*cos(150.0*d);\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n    \n    d = castRay( p, ro, rd);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(d)-0.0025));\n    \n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float opRound( in float d, in float r )\n{\n  return d - r;\n}\nfloat opOnion( in float d, in float r )\n{\n  return abs(d) - r;\n}\nvec2 opRepetition( in vec2 p, in vec2 s )\n{\n    return p - s*round(p/s);\n}\nvec2 opLimitedRepetition( in vec2 p, in float s, in vec2 l )\n{\n    return p - s*clamp(round(p/s),-l,l);\n}\n\n//--- Booleans -----------------------------------------------------------------------------------------------------------\nfloat opUnion( float d1, float d2 )\n{\n    return min(d1,d2);\n}\nfloat opSubtraction( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\nfloat opIntersection( float d1, float d2 )\n{\n    return max(d1,d2);\n}\nfloat opXor(float d1, float d2 )\n{\n    return max(min(d1,d2),-max(d1,d2));\n}\n\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\nfloat opSmoothSubtraction( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\nfloat opSmoothIntersection( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\n//--- Booleans with Color ------------------------------------------------------------------------------------------------\nvec4 opUnionColor( vec4 a, vec4 b )\n{\n    return ( a.x<b.x ? a : b );\n}\nvec4 opSubtractionColor( vec4 a, vec4 b )\n{\n    return ( -a.x>b.x ? vec4(-a.x,b.yzw) : b );\n}\nvec4 opIntersectionColor( vec4 a, vec4 b )\n{\n    return ( a.x>b.x ? vec4(a.x,b.yzw) : vec4(b.x,a.yzw) );\n}\nvec4 opXorColor( vec4 a, vec4 b )\n{\n    vec4 m = ( a.x<b.x ? a : b );\n    vec4 M = ( a.x>b.x ? vec4(a.x,b.yzw) : vec4(b.x,a.yzw) );\n    return ( m.x>-M.x ? m : vec4(-M.x,M.yzw) );\n}\n\nvec4 opSmoothUnionColor( vec4 a, vec4 b, float k )\n{\n    float h = clamp( 0.5 - 0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return vec4( mix(a.x,b.x,h) - k*h*(1.0-h), mix(a.yzw,b.yzw,h));\n}\nvec4 opSmoothSubtractionColor( vec4 b, vec4 a, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(-b.x-a.x)/-k, 0.0, 1.0 );\n\treturn vec4( mix( -b.x, a.x, h ) - -k*h*(1.0-h), mix(b.yzw,a.yzw,h) );\n}\nvec4 opSmoothIntersectionColor( vec4 a, vec4 b, float k )\n{\n    float h = clamp( 0.5 - 0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return vec4( mix(a.x,b.x,h) - k*h*(1.0-h), mix(a.yzw,b.yzw,h));\n}\nvec4 opSmoothXorColor1( vec4 a, vec4 b, float k )\n{\n    //vec4 sub_b_from_a = opSubtractionColor(b,a);\n    //vec4 sub_a_from_b = opSubtractionColor(a,b);\n    //return opSmoothUnionColor(sub_b_from_a,sub_a_from_b,k);\n    \n\tvec4 m = ( -b.x>a.x ? vec4(-b.x,a.yzw) : a );\n\tvec4 M = ( -a.x>b.x ? vec4(-a.x,b.yzw) : b );\n    float h = clamp( 0.5 - 0.5*(M.x-m.x)/k, 0.0, 1.0 );\n    return vec4( mix(m.x,M.x,h) - k*h*(1.0-h), mix(m.yzw,M.yzw,h));\n}\nvec4 opSmoothXorColor2( vec4 a, vec4 b, float k )\n{\n    //vec4 sub_b_from_a = opSmoothSubtractionColor(vec4(b.x,a.yzw),a,k);\n    //vec4 sub_a_from_b = opSmoothSubtractionColor(vec4(a.x,b.yzw),b,k);\n    //return opUnionColor(sub_b_from_a,sub_a_from_b);\n    \n    float h = clamp( 0.5 + 0.5*(-b.x-a.x)/-k, 0.0, 1.0 );\n\tvec4 m = vec4( mix( -b.x, a.x, h ) - -k*h*(1.0-h), mix(a.yzw,a.yzw,h) );\n    h = clamp( 0.5 + 0.5*(-a.x-b.x)/-k, 0.0, 1.0 );\n\tvec4 M = vec4( mix( -a.x, b.x, h ) - -k*h*(1.0-h), mix(b.yzw,b.yzw,h) );\n    return ( m.x<M.x ? m : M );\n}\n\n//  Shapes  //////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n// Circle - exact   (https://www.shadertoy.com/view/3ltSW2)\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\n// Rounded Box - exact   (https://www.shadertoy.com/view/4llXD7 and https://www.youtube.com/watch?v=s5NGeUV2EyU)\n\nfloat sdRoundedBox( in vec2 p, in vec2 b, in vec4 r )\n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\n// Box - exact   (https://www.youtube.com/watch?v=62-pRVZuS5c)\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// Oriented Box - exact   (https://www.shadertoy.com/view/stcfzn)\n\nfloat sdOrientedBox( in vec2 p, in vec2 a, in vec2 b, float th )\n{\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = (p-(a+b)*0.5);\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n}\n\n// Segment - exact   (https://www.shadertoy.com/view/3tdSDj and https://www.youtube.com/watch?v=PMltMdi1Wzg)\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// Rhombus - exact   (https://www.shadertoy.com/view/XdXcRB)\n\nfloat sdRhombus( in vec2 p, in vec2 b ) \n{\n    p = abs(p);\n    float h = clamp( ndot(b-2.0*p,b)/dot(b,b), -1.0, 1.0 );\n    float d = length( p-0.5*b*vec2(1.0-h,1.0+h) );\n    return d * sign( p.x*b.y + p.y*b.x - b.x*b.y );\n}\n\n// Isosceles Trapezoid - exact   (https://www.shadertoy.com/view/MlycD3)\n\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n// Parallelogram - exact   (https://www.shadertoy.com/view/7dlGRf)\n\nfloat sdParallelogram( in vec2 p, float wi, float he, float sk )\n{\n    vec2 e = vec2(sk,he);\n    p = (p.y<0.0)?-p:p;\n    vec2  w = p - e; w.x -= clamp(w.x,-wi,wi);\n    vec2  d = vec2(dot(w,w), -w.y);\n    float s = p.x*e.y - p.y*e.x;\n    p = (s<0.0)?-p:p;\n    vec2  v = p - vec2(wi,0); v -= e*clamp(dot(v,e)/dot(e,e),-1.0,1.0);\n    d = min( d, vec2(dot(v,v), wi*he-abs(s)));\n    return sqrt(d.x)*sign(-d.y);\n}\n\n// Equilateral Triangle - exact   (https://www.shadertoy.com/view/Xl2yDW)\n\nfloat sdEquilateralTriangle( in vec2 p, in float r )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0*r, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\n// Isosceles Triangle - exact   (https://www.shadertoy.com/view/MldcD7)\n\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n// Triangle - exact   (https://www.shadertoy.com/view/XsXSz4)\n\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n// Uneven Capsule - exact   (https://www.shadertoy.com/view/4lcBWn)\n\nfloat sdUnevenCapsule( vec2 p, float r1, float r2, float h )\n{\n    p.x = abs(p.x);\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(p,vec2(-b,a));\n    if( k < 0.0 ) return length(p) - r1;\n    if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n    return dot(p, vec2(a,b) ) - r1;\n}\n\n// Regular Pentagon - exact   (https://www.shadertoy.com/view/llVyWW)\n\nfloat sdPentagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(0.809016994,0.587785252,0.726542528);\n    p.x = abs(p.x);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    p -= vec2(clamp(p.x,-r*k.z,r*k.z),r);    \n    return length(p)*sign(p.y);\n}\n\n// Regular Hexagon - exact\n\nfloat sdHexagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\n// Regular Octogon - exact   (https://www.shadertoy.com/view/llGfDG)\n\nfloat sdOctogon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.9238795325, 0.3826834323, 0.4142135623 );\n    p = abs(p);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\n// Hexagram - exact   (https://www.shadertoy.com/view/tt23RR)\n\nfloat sdHexagram( in vec2 p, in float r )\n{\n    const vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= 2.0*min(dot(k.yx,p),0.0)*k.yx;\n    p -= vec2(clamp(p.x,r*k.z,r*k.w),r);\n    return length(p)*sign(p.y);\n}\n\n// Star 5 - exact   (https://www.shadertoy.com/view/3tSGDy)\n\nfloat sdStar5(in vec2 p, in float r, in float rf)\n{\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0*max(dot(k1,p),0.0)*k1;\n    p -= 2.0*max(dot(k2,p),0.0)*k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n    float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n    return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n\n// Regular Star - exact   (https://www.shadertoy.com/view/3tSGDy)\n\nfloat sdStar( in vec2 p, in float r, in int n, in float m)\n{\n    // next 4 lines can be precomputed for a given shape\n    float an = 3.141593/float(n);\n    float en = 3.141593/m;  // m is between 2 and n\n    vec2  acs = vec2(cos(an),sin(an));\n    vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) for regular polygon\n\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n    p -= r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\n\n// Pie - exact   (https://www.shadertoy.com/view/3l23RK)\n\nfloat sdPie( in vec2 p, in vec2 c, in float r )\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n    float m = length(p-c*clamp(dot(p,c),0.0,r)); // c=sin/cos of aperture\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\n// Cut Disk - exact   (https://www.shadertoy.com/view/ftVXRc)\n\nfloat sdCutDisk( in vec2 p, in float r, in float h )\n{\n    float w = sqrt(r*r-h*h); // constant for any given shape\n    p.x = abs(p.x);\n    float s = max( (h-r)*p.x*p.x+w*w*(h+r-2.0*p.y), h*p.x-w*p.y );\n    return (s<0.0) ? length(p)-r :\n           (p.x<w) ? h - p.y     :\n                     length(p-vec2(w,h));\n}\n\n// Arc - exact   (https://www.shadertoy.com/view/wl23RK)\n\nfloat sdArc( in vec2 p, in vec2 sc, in float ra, float rb )\n{\n    // sc is the sin/cos of the arc's aperture\n    p.x = abs(p.x);\n    return ((sc.y*p.x>sc.x*p.y) ? length(p-sc*ra) : \n                                  abs(length(p)-ra)) - rb;\n}\n\n// Ring - exact   (https://www.shadertoy.com/view/DsccDH)\n\nfloat sdRing( in vec2 p, in vec2 n, in float r, float th )\n{\n    p.x = abs(p.x);\n   \n    p = mat2x2(n.x,n.y,-n.y,n.x)*p;\n\n    return max( abs(length(p)-r)-th*0.5,\n                length(vec2(p.x,max(0.0,abs(r-p.y)-th*0.5)))*sign(p.x) );\n}\n\n// Horseshoe - exact   (https://www.shadertoy.com/view/WlSGW1)\n\nfloat sdHorseshoe( in vec2 p, in vec2 c, in float r, in vec2 w )\n{\n    p.x = abs(p.x);\n    float l = length(p);\n    p = mat2(-c.x, c.y, c.y, c.x)*p;\n    p = vec2((p.y>0.0 || p.x>0.0)?p.x:l*sign(-c.x),\n             (p.x>0.0)?p.y:l );\n    p = vec2(p.x,abs(p.y-r))-w;\n    return length(max(p,0.0)) + min(0.0,max(p.x,p.y));\n}\n\n// Vesica - exact   (https://www.shadertoy.com/view/XtVfRW)\n\nfloat sdVesica(vec2 p, float r, float d)\n{\n    p = abs(p);\n    float b = sqrt(r*r-d*d);\n    return ((p.y-b)*d>p.x*b) ? length(p-vec2(0.0,b))\n                             : length(p-vec2(-d,0.0))-r;\n}\n\n// Oriented Vesica - exact   (https://www.shadertoy.com/view/cs2yzG)\n\nfloat sdOrientedVesica( vec2 p, vec2 a, vec2 b, float w )\n{\n    float r = 0.5*length(b-a);\n    float d = 0.5*(r*r-w*w)/w;\n    vec2 v = (b-a)/r;\n    vec2 c = (b+a)*0.5;\n    vec2 q = 0.5*abs(mat2(v.y,v.x,-v.x,v.y)*(p-c));\n    vec3 h = (r*q.x<d*(q.y-r)) ? vec3(0.0,r,0.0) : vec3(-d,0.0,d+w);\n    return length( q-h.xy) - h.z;\n}\n\n// Moon - exact   (https://www.shadertoy.com/view/WtdBRS)\n\nfloat sdMoon(vec2 p, float d, float ra, float rb )\n{\n    p.y = abs(p.y);\n    float a = (ra*ra - rb*rb + d*d)/(2.0*d);\n    float b = sqrt(max(ra*ra-a*a,0.0));\n    if( d*(p.x*b-p.y*a) > d*d*max(b-p.y,0.0) )\n          return length(p-vec2(a,b));\n    return max( (length(p          )-ra),\n               -(length(p-vec2(d,0))-rb));\n}\n\n// Circle Cross - exact   (https://www.shadertoy.com/view/NslXDM)\n\nfloat sdRoundedCross( in vec2 p, in float h )\n{\n    float k = 0.5*(h+1.0/h);\n    p = abs(p);\n    return ( p.x<1.0 && p.y<p.x*(k-h)+h ) ? \n             k-sqrt(dot2(p-vec2(1,k)))  :\n           sqrt(min(dot2(p-vec2(0,h)),\n                    dot2(p-vec2(1,0))));\n}\n\n// Simple Egg - exact   (https://www.shadertoy.com/view/XtVfRW)\n\nfloat sdEgg( in vec2 p, in float ra, in float rb )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x);\n    float r = ra - rb;\n    return ((p.y<0.0)       ? length(vec2(p.x,  p.y    )) - r :\n            (k*(p.x+r)<p.y) ? length(vec2(p.x,  p.y-k*r)) :\n                              length(vec2(p.x+r,p.y    )) - 2.0*r) - rb;\n}\n\n// Heart - exact   (https://www.shadertoy.com/view/3tyBzV)\n\nfloat sdHeart( in vec2 p )\n{\n    p.x = abs(p.x);\n\n    if( p.y+p.x>1.0 )\n        return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n                    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\n\n// Cross - exact exterior, bound interior   (https://www.shadertoy.com/view/XtGfzw)\n\nfloat sdCross( in vec2 p, in vec2 b, float r ) \n{\n    p = abs(p); p = (p.y>p.x) ? p.yx : p.xy;\n    vec2  q = p - b;\n    float k = max(q.y,q.x);\n    vec2  w = (k>0.0) ? q : vec2(b.y-p.x,-k);\n    return sign(k)*length(max(w,0.0)) + r;\n}\n\n// Rounded X - exact   (https://www.shadertoy.com/view/3dKSDc)\n\nfloat sdRoundedX( in vec2 p, in float w, in float r )\n{\n    p = abs(p);\n    return length(p-min(p.x+p.y,w)*0.5) - r;\n}\n\n// Polygon - exact   (https://www.shadertoy.com/view/wdBXRW)\n\n//float sdPolygon( in vec2[N] v, in vec2 p )\n//{\n//    float d = dot(p-v[0],p-v[0]);\n//    float s = 1.0;\n//    for( int i=0, j=N-1; i<N; j=i, i++ )\n//    {\n//        vec2 e = v[j] - v[i];\n//        vec2 w =    p - v[i];\n//        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n//        d = min( d, dot(b,b) );\n//        bvec3 c = bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);\n//        if( all(c) || all(not(c)) ) s*=-1.0;  \n//    }\n//    return s*sqrt(d);\n//}\n\n// Ellipse - exact   (https://www.shadertoy.com/view/4sS3zz)\n\nfloat sdEllipse( in vec2 p, in vec2 ab )\n{\n    p = abs(p); if( p.x > p.y ) {p=p.yx;ab=ab.yx;}\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      float m2 = m*m; \n    float n = ab.y*p.y/l;      float n2 = n*n; \n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    return length(r-p) * sign(p.y-r.y);\n}\n\n// Parabola - exact   (https://www.shadertoy.com/view/ws3GD7)\n\nfloat sdParabola( in vec2 pos, in float k )\n{\n    pos.x = abs(pos.x);\n    float ik = 1.0/k;\n    float p = ik*(pos.y - 0.5*ik)/3.0;\n    float q = 0.25*ik*ik*pos.x;\n    float h = q*q - p*p*p;\n    float r = sqrt(abs(h));\n    float x = (h>0.0) ? \n        pow(q+r,1.0/3.0) - pow(abs(q-r),1.0/3.0)*sign(r-q) :\n        2.0*cos(atan(r,q)/3.0)*sqrt(p);\n    return length(pos-vec2(x,k*x*x)) * sign(pos.x-x);\n}\n\n// Parabola Segment - exact   (https://www.shadertoy.com/view/3lSczz)\n\nfloat sdParabola( in vec2 pos, in float wi, in float he )\n{\n    pos.x = abs(pos.x);\n    float ik = wi*wi/he;\n    float p = ik*(he-pos.y-0.5*ik)/3.0;\n    float q = pos.x*ik*ik*0.25;\n    float h = q*q - p*p*p;\n    float r = sqrt(abs(h));\n    float x = (h>0.0) ? \n        pow(q+r,1.0/3.0) - pow(abs(q-r),1.0/3.0)*sign(r-q) :\n        2.0*cos(atan(r/q)/3.0)*sqrt(p);\n    x = min(x,wi);\n    return length(pos-vec2(x,he-x*x/ik)) * \n           sign(ik*(pos.y-he)+pos.x*pos.x);\n}\n\n// Quadratic Bezier - exact   (https://www.shadertoy.com/view/MlKcDD)\n\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx-3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if( h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot2(d + (c + b*t)*t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx,0.0,1.0);\n        res = min( dot2(d+(c+b*t.x)*t.x),\n                   dot2(d+(c+b*t.y)*t.y) );\n        // the third root cannot be the closest\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\n    }\n    return sqrt( res );\n}\n\n// Bobbly Cross - exact   (https://www.shadertoy.com/view/NssXWM)\n\nfloat sdBlobbyCross( in vec2 pos, float he )\n{\n    pos = abs(pos);\n    pos = vec2(abs(pos.x-pos.y),1.0-pos.x-pos.y)/sqrt(2.0);\n\n    float p = (he-pos.y-0.25/he)/(6.0*he);\n    float q = pos.x/(he*he*16.0);\n    float h = q*q - p*p*p;\n    \n    float x;\n    if( h>0.0 ) { float r = sqrt(h); x = pow(q+r,1.0/3.0)-pow(abs(q-r),1.0/3.0)*sign(r-q); }\n    else        { float r = sqrt(p); x = 2.0*r*cos(acos(q/(p*r))/3.0); }\n    x = min(x,sqrt(2.0)/2.0);\n    \n    vec2 z = vec2(x,he*(1.0-2.0*x*x)) - pos;\n    return length(z) * sign(z.y);\n}\n\n// Tunnel - exact   (https://www.shadertoy.com/view/flSSDy)\n\nfloat sdTunnel( in vec2 p, in vec2 wh )\n{\n    p.x = abs(p.x); p.y = -p.y;\n    vec2 q = p - wh;\n\n    float d1 = dot2(vec2(max(q.x,0.0),q.y));\n    q.x = (p.y>0.0) ? q.x : length(p)-wh.x;\n    float d2 = dot2(vec2(q.x,max(q.y,0.0)));\n    float d = sqrt( min(d1,d2) );\n    \n    return (max(q.x,q.y)<0.0) ? -d : d;\n}\n\n// Stairs - exact   (https://www.shadertoy.com/view/7tKSWt)\n\nfloat sdStairs( in vec2 p, in vec2 wh, in float n )\n{\n    vec2 ba = wh*n;\n    float d = min(dot2(p-vec2(clamp(p.x,0.0,ba.x),0.0)), \n                  dot2(p-vec2(ba.x,clamp(p.y,0.0,ba.y))) );\n    float s = sign(max(-p.y,p.x-ba.x) );\n\n    float dia = length(wh);\n    p = mat2(wh.x,-wh.y, wh.y,wh.x)*p/dia;\n    float id = clamp(round(p.x/dia),0.0,n-1.0);\n    p.x = p.x - id*dia;\n    p = mat2(wh.x, wh.y,-wh.y,wh.x)*p/dia;\n\n    float hh = wh.y/2.0;\n    p.y -= hh;\n    if( p.y>hh*sign(p.x) ) s=1.0;\n    p = (id<0.5 || p.x>0.0) ? p : -p;\n    d = min( d, dot2(p-vec2(0.0,clamp(p.y,-hh,hh))) );\n    d = min( d, dot2(p-vec2(clamp(p.x,0.0,wh.x),hh)) );\n    \n    return sqrt(d)*s;\n}\n\n// Quadratic Circle - exact   (https://www.shadertoy.com/view/Nd3cW8)\n\nfloat sdQuadraticCircle( in vec2 p )\n{\n    p = abs(p); if( p.y>p.x ) p=p.yx;\n\n    float a = p.x-p.y;\n    float b = p.x+p.y;\n    float c = (2.0*b-1.0)/3.0;\n    float h = a*a + c*c*c;\n    float t;\n    if( h>=0.0 )\n    {   \n        h = sqrt(h);\n        t = sign(h-a)*pow(abs(h-a),1.0/3.0) - pow(h+a,1.0/3.0);\n    }\n    else\n    {   \n        float z = sqrt(-c);\n        float v = acos(a/(c*z))/3.0;\n        t = -z*(cos(v)+sin(v)*1.732050808);\n    }\n    t *= 0.5;\n    vec2 w = vec2(-t,t) + 0.75 - t*t - p;\n    return length(w) * sign( a*a*0.5+b-1.5 );\n}\n\n// Hyperbola - exact   (https://www.shadertoy.com/view/DtjXDG)\n\nfloat sdHyberbola( in vec2 p, in float k, in float he ) // k in (0,inf)\n{\n    p = abs(p);\n    p = vec2(p.x-p.y,p.x+p.y)/sqrt(2.0);\n\n    float x2 = p.x*p.x/16.0;\n    float y2 = p.y*p.y/16.0;\n    float r = k*(4.0*k - p.x*p.y)/12.0;\n    float q = (x2 - y2)*k*k;\n    float h = q*q + r*r*r;\n    float u;\n    if( h<0.0 )\n    {\n        float m = sqrt(-r);\n        u = m*cos( acos(q/(r*m))/3.0 );\n    }\n    else\n    {\n        float m = pow(sqrt(h)-q,1.0/3.0);\n        u = (m - r/m)/2.0;\n    }\n    float w = sqrt( u + x2 );\n    float b = k*p.y - x2*p.x*2.0;\n    float t = p.x/4.0 - w + sqrt( 2.0*x2 - u + b/w/4.0 );\n    t = max(t,sqrt(he*he*0.5+k)-he/sqrt(2.0));\n    float d = length( p-vec2(t,k/t) );\n    return p.x*p.y < k ? d : -d;\n}\n\n// Cool S - exact   (https://www.shadertoy.com/view/clVXWc)\n\nfloat sdfCoolS( in vec2 p )\n{\n    float six = (p.y<0.0) ? -p.x : p.x;\n    p.x = abs(p.x);\n    p.y = abs(p.y) - 0.2;\n    float rex = p.x - min(round(p.x/0.4),0.4);\n    float aby = abs(p.y-0.2)-0.6;\n    \n    float d = dot2(vec2(six,-p.y)-clamp(0.5*(six-p.y),0.0,0.2));\n    d = min(d,dot2(vec2(p.x,-aby)-clamp(0.5*(p.x-aby),0.0,0.4)));\n    d = min(d,dot2(vec2(rex,p.y  -clamp(p.y          ,0.0,0.4))));\n    \n    float s = 2.0*p.x + aby + abs(aby+0.4) - 0.4;\n    return sqrt(d) * sign(s);\n}\n\n// Circle Wave - exact   (https://www.shadertoy.com/view/stGyzt)\n\nfloat sdCircleWave( in vec2 p, in float tb, in float ra )\n{\n    tb = 3.1415927*5.0/6.0*max(tb,0.0001);\n    vec2 co = ra*vec2(sin(tb),cos(tb));\n    p.x = abs(mod(p.x,co.x*4.0)-co.x*2.0);\n    vec2  p1 = p;\n    vec2  p2 = vec2(abs(p.x-2.0*co.x),-p.y+2.0*co.y);\n    float d1 = ((co.y*p1.x>co.x*p1.y) ? length(p1-co) : abs(length(p1)-ra));\n    float d2 = ((co.y*p2.x>co.x*p2.y) ? length(p2-co) : abs(length(p2)-ra));\n    return min(d1, d2); \n}\n\n// Spiral - inexact   (https://www.shadertoy.com/view/fslyWN)\n\nfloat sdSpiral( in vec2 p, float w, in float k )\n{\n    // body\n    const float kTau = 6.283185307;\n    float r = length(p);\n    float a = atan(p.y,p.x);\n    float n = floor( 0.5/w + (log2(r/w)*k-a)/kTau );\n    float ra = w*exp2((a+kTau*(min(n+0.0,0.0)-0.5))/k);\n    float rb = w*exp2((a+kTau*(min(n+1.0,0.0)-0.5))/k);\n    float d = min( abs(r-ra), abs(r-rb) );\n\n    // tip\n    return min( d, length(p+vec2(w,0.0)) );\n}","name":"Common","description":"","type":"common"}]}