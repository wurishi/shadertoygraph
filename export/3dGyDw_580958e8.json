{"ver":"0.1","info":{"id":"3dGyDw","date":"1602966086","viewed":139,"name":"Lambertian IES light intensity","username":"wagyx","description":"Computation of radiometric intensity emitted by a 3D object with constant radiance (lambertian).\nSupported objects are flat surfaces, box, tube, cylinder (tube with end caps), sphere.\nTodo: ellipsoid,  ...","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["intensity","radiometry","ies"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nThis shader computes the radiant intensity distribution from the 3D shape of a lambertian light source.\nA lambertian light source has a constant radiance L.\nThe radiant intensity I is a directional quantity in W/sr or in candela.\nhttps://en.wikipedia.org/wiki/Radiant_intensity\n\nI(theta,phi) = L A_app(theta,phi)\ntheta is the inclination from the z-axis and phi is the azimuth from the x-axis.\nA_app is the apparent surface of the light source in some direction (theta,phi)\nA_app(theta,phi) = integral over the surface of the shape of cos(theta_s) dA_s\nwith dA_s an elementary patch on the surface,\nand theta_s the angle between the view direction w=(theta,phi) and the normal n_s of the elementary patch\nThe formula can be rewritten as\nA_app(w) = integral dot(n_s,w) dA_s\n\nI have computed analytically this integral for several shapes:\n- a flat surface\n- a rectangular box\n- a sphere\n- a cylinder\n\nThis computation gives the intensity as is measured by the Illuminating Engineering Society (IES)\nin their .IES data file.\nhttps://docs.unrealengine.com/en-US/Engine/Rendering/LightingAndShadows/IESLightProfiles/index.html\nhere is a large database : https://ieslibrary.com/en/home\nhere is a viewer: http://photometricviewer.com/\n\nTodo:\nconvex polyhedron\nconvex triangle meshes\nellipsoid\nelliptic cylinder -> analytical formula (finite elements method is DONE)\n*/\n#define meshMaxNbFaces 30\n#define meshMaxNbVert 30\n\nconst float PI = 3.141592653589793;\nconst float C0 = 0.35355339059328;\n\nstruct TriMesh {\n    int nbVert;\n    int nbFaces;\n\tvec3 vert[meshMaxNbVert];\n\tivec3 faces[meshMaxNbFaces];    \n};\n\nTriMesh genTetrahedron() {\n    TriMesh mesh;\n    mesh.nbVert=4;\n    mesh.vert[0] = vec3( C0, -C0,  C0);\n    mesh.vert[1] = vec3( C0,  C0, -C0);\n    mesh.vert[2] = vec3(-C0,  C0,  C0);\n    mesh.vert[3] = vec3(-C0, -C0, -C0);\n    mesh.nbFaces=4;\n    mesh.faces[0] = ivec3( 0, 1, 2 );\n    mesh.faces[1] = ivec3( 1, 0, 3 );\n    mesh.faces[2] = ivec3( 2, 3, 0 );\n    mesh.faces[3] = ivec3( 3, 2, 1 );\n    return mesh;\n}\n\n//taken from https://www.shadertoy.com/view/WlfXRN\n// t must be between 0 and 1 otherwise the color will saturate\nvec3 viridis(float t) {\n\n    const vec3 c0 = vec3(0.2777273272234177, 0.005407344544966578, 0.3340998053353061);\n    const vec3 c1 = vec3(0.1050930431085774, 1.404613529898575, 1.384590162594685);\n    const vec3 c2 = vec3(-0.3308618287255563, 0.214847559468213, 0.09509516302823659);\n    const vec3 c3 = vec3(-4.634230498983486, -5.799100973351585, -19.33244095627987);\n    const vec3 c4 = vec3(6.228269936347081, 14.17993336680509, 56.69055260068105);\n    const vec3 c5 = vec3(4.776384997670288, -13.74514537774601, -65.35303263337234);\n    const vec3 c6 = vec3(-5.435455855934631, 4.645852612178535, 26.3124352495832);\n\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n// taken from https://www.shadertoy.com/view/WtjcDt\n\n\nmat4 rotationMatrix(vec3 axis, float cosAngle, float sinAngle) {\n    float s = sinAngle;\n    float c = cosAngle;\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nmat4 rotationMatrix(vec3 axis, float angle) {\n    // taken from http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\n    // angle = radians(angle);\n    //axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    return rotationMatrix(axis, c, s);\n}\n\n//taken from https://www.shadertoy.com/view/WtjcDt\nvec3 apply_rot(mat4 r, vec3 p) {\n    return (r*vec4(p, 1.)).xyz;\n}\n\nfloat sphereAppSurface(float radius){\n    return PI*radius*radius;\n}\n\n// view is the direction from which the object is observed, must be normalized\n// normal is the normal of the falt surface, must be normalized\n// area is the area of the object\n// isSingleFaced indicates whether the surface emits from the normal side (true) or both sides false.\nfloat flatAppSurface(vec3 view, vec3 normal, float area, bool isSingleFaced) {\n    float res = dot(view,normal);\n    //when negative, take absolute value if not single faced and zero else\n    if (res < 0.f) {\n        res*= sign(res)*float(!isSingleFaced); \n    }\n\treturn res*area;\n}\n//widths are the side lengths of the rectangle\nfloat rectAppSurface(vec3 view, vec3 normal, vec2 widths, bool isSingleFaced){\n\treturn flatAppSurface(view, normal, widths.x*widths.y, isSingleFaced);\n}\n\nfloat triangleAppSurface(vec3 view, vec3 p0, vec3 p1, vec3 p2, bool isSingleFaced){\n\tvec3 normal = cross(p1-p0,p2-p0);\n    float area = length(normal);\n    normal/=area;\n    area/=2.f;\n    return flatAppSurface(view, normal, area, isSingleFaced);\n}\n\n// halfWidths are the half widths of the minor and major axis of the ellipse\nfloat ellipseAppSurface(vec3 view, vec3 normal, vec2 halfWidths, bool isSingleFaced){\n\treturn flatAppSurface(view, normal, PI*halfWidths.x*halfWidths.y, isSingleFaced);\n}\nfloat diskAppSurface(vec3 view, vec3 normal, float radius, bool isSingleFaced){\n\treturn ellipseAppSurface(view, normal, vec2(radius), isSingleFaced);\n}\n\nfloat alignedBoxAppSurface(vec3 view, vec3 widths){\n    const vec3 xaxis = vec3(1.f,0.f,0.f);\n    const vec3 yaxis = vec3(0.f,1.f,0.f);\n    const vec3 zaxis = vec3(0.f,0.f,1.f);\n\tfloat res= rectAppSurface(view, zaxis, widths.xy, false);\n    res+= rectAppSurface(view, xaxis, widths.yz, false);\n    res+= rectAppSurface(view, yaxis, widths.xz, false);\n    return res;\n}\n\nfloat vertTubeAppSurface(vec3 view, float radius, float height){\n    const vec3 zaxis= vec3(0.f,0.f,1.f);\n    float res= length(cross(view,zaxis));\n    return res*radius*height*2.f;\n}\n\nfloat vertCylinderAppSurface(vec3 view, float radius, float height){\n    const vec3 zaxis = vec3(0.f,0.f,1.f);\n\tfloat res= diskAppSurface(view, zaxis, radius, false);\n    res+= vertTubeAppSurface(view, radius, height);\n    return res;\n}\n\n\nfloat complementTrig(float value){\n\treturn clamp(sqrt(1.f-value*value),-1.f,1.f);\n}\n    \nvec3 rotateVectorFromZenith(vec3 view, vec3 direction) {\n    const vec3 zaxis = vec3(0.f,0.f,1.f);\n    vec3 axis = cross(zaxis,direction);\n    float sinAngle = length(axis);\n    float cosAngle = dot(zaxis,direction);\n    axis /= sinAngle;\n    mat4 mat = rotationMatrix(axis, cosAngle, sinAngle);\n    return apply_rot(mat,view);\n}\n\nfloat tubeAppSurface(vec3 view, vec3 axis, float radius, float height){\n    vec3 newView= rotateVectorFromZenith(view,axis);\n    return vertTubeAppSurface(newView, radius, height);\n}\n    \nfloat cylinderAppSurface(vec3 view, vec3 axis, float radius, float height){\n    float res=0.f;\n\tres+= diskAppSurface(view, axis, radius, false);\n\tres+= tubeAppSurface(view, axis, radius, height);\n    return res;\n}\n\nfloat boxAppSurface(vec3 view ,vec3 axis, vec3 widths){\n    vec3 newView= rotateVectorFromZenith(view,axis);\n    return alignedBoxAppSurface(newView, widths);\n}\n\n// only works for convex triangular mesh\nfloat triMeshAppSurface(vec3 view, vec3 axis, TriMesh mesh){\n    vec3 newView= rotateVectorFromZenith(view,axis);\n    float res=0.f;\n    for(int i=0; i<mesh.nbFaces; ++i){\n        ivec3 face = mesh.faces[i];\n        res+=triangleAppSurface(newView, mesh.vert[face.x], mesh.vert[face.y], mesh.vert[face.z], true);\n    }\n    return res;\n}\n\n// could not compute the analytical form of the integral\n// instead, doing a numerical integration by discretizing the ellipse\n// not a 100% sure the computation is okay\nfloat vertEllipticTubeAppSurface(vec3 view, vec2 radiuses, float height){\n    float N=100.f;\n    float s = sin(PI/N);\n    float sum=0.f;\n    for(float i=0.f; i<N; ++i){\n    \tfloat t= i*2.f*PI/N;\n        vec2 normal = vec2(cos(t),sin(t));\n        vec2 edge= radiuses * s * 2.f * vec2(-normal.y,normal.x);\n        normal*=radiuses.yx;\n        normal= normalize(normal);\n        sum += rectAppSurface(view, vec3(normal,0.f), vec2(length(edge),height),true);\n    }\n    return sum;\n}\n\nfloat vertEllipticCylinderAppSurface(vec3 view, vec2 radiuses, float height){\n    float res=0.f;\n    vec3 zAxis=vec3(0,0,1);\n\tres+= ellipseAppSurface(view, zAxis, radiuses, false);\n\tres+= vertEllipticTubeAppSurface(view, radiuses, height);\n    return res;\n}\n\nfloat ellipticTubeAppSurface(vec3 view, vec3 axis, vec2 radiuses, float height){\n    vec3 newView= rotateVectorFromZenith(view,axis);\n    return vertEllipticTubeAppSurface(newView, radiuses, height);\n}\n\nfloat ellipticCylinderAppSurface(vec3 view, vec3 axis, vec2 radiuses, float height){\n    float res = 0.f;\n\tres+= ellipseAppSurface(view, axis, radiuses, false);\n\tres+= ellipticTubeAppSurface(view, axis, radiuses, height);\n    return res;\n}\n    \nvec2 uvToInclinationAzimuth(vec2 uv) {\n\treturn vec2((1.f-uv.y),2.f*uv.x)*PI;\n}\n\n// radius, inclination from z, azimuth from x\nvec3 sph2cart(vec3 ria){\n    float z= cos(ria.y);\n    float x= sin(ria.y);\n    float y= x*sin(ria.z);\n    x=x*cos(ria.z);\n    return ria.x*vec3(x,y,z);\n}\n\n// shows the equirectangular map (spherical projection) of the chosen object apparent surface\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 view = sph2cart(vec3(1,uvToInclinationAzimuth(uv)));\n\n    // shape axis\n    vec2 uvMouse = iMouse.xy/iResolution.xy;\n    //vec3 surfaceNormal = vec3(1.f,0.f,0.f);\n    vec3 surfaceNormal = vec3(0.01f,0.f,1.f);\n    if (iMouse.z>0.f) {\n\t    surfaceNormal = sph2cart(vec3(1,uvToInclinationAzimuth(uvMouse)));\n    }\n    surfaceNormal = normalize(surfaceNormal);\n    \n    float appSurf=0.5f;\n    // choose the object below\n    // I am scaling the final result so that the value for the colormap does not saturate\n    \n    // Rectangle and Box\n    //appSurf = flatAppSurface(view,surfaceNormal,1.f,false);\n    //appSurf = rectAppSurface(view,surfaceNormal,vec2(1.f,1.f),false);\n\tappSurf = alignedBoxAppSurface(view, vec3(1.f,1.f,1.f))/1.73f;\n    //appSurf = boxAppSurface(view, surfaceNormal, vec3(1.f, 1.f,1.f))/1.73f;\n    \n    //Disk, Tube and Cylinder\n    //appSurf = diskAppSurface(view, surfaceNormal, 1.f, false)/PI;\n    //appSurf = vertTubeAppSurface(view, 1.f, 1.f)/2.f;\n    //appSurf = vertCylinderAppSurface(view, 1.f, 1.f)/3.8f;\n    //appSurf = tubeAppSurface(view, surfaceNormal, 1.f, 1.f)/2.f;\n    //appSurf = cylinderAppSurface(view, surfaceNormal, 1.f, 1.f)/3.8f;\n\t\n    // Ellipse, Elliptic Tube and Cylinder\n    //appSurf = ellipseAppSurface(view, surfaceNormal, vec2(1.f,2.f), false)/(2.f*PI);\n    //appSurf = vertEllipticTubeAppSurface(view, vec2(1,2), 1.f)/4.f;\n    //appSurf = vertEllipticCylinderAppSurface(view, vec2(1,2), 1.f)/8.f;\n    //appSurf = ellipticTubeAppSurface(view, surfaceNormal, vec2(1,2), 1.f)/3.8f;\n    //appSurf = ellipticCylinderAppSurface(view, surfaceNormal, vec2(1,2), 1.f)/8.f;\n    \n    //Sphere\n    //appSurf = sphereAppSurface(1.f)/PI;\n    \n    TriMesh tet = genTetrahedron();\n    appSurf = triMeshAppSurface(view, surfaceNormal, tet)*2.f;\n    \n    // Output to screen\n    vec3 col = viridis(appSurf);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}