{"ver":"0.1","info":{"id":"DsdXWS","date":"1709581973","viewed":50,"name":"Truchet + line fountain","username":"revanw","description":"Playing with Truchet tiling for my own sake, adding afading line effect with double buffer.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["simple","glitch","truchet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// this image shader overlay glitches on the output given by buffer A which deals with \n// the main drawing\n// buffer B only contributes to the fading/zoomed effect\n\n//  Global Parameters to tweak:\n// Glitches can be turned on or off\n// Main drawing can be circle or truchet\n#define glitches true\n\n\n#define noise(uv) texture(iChannel2, uv)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y; // -0.5 to 0.5 along y axis\n    vec2 st = fragCoord/iResolution.xy; // 0 to 1 along both axis\n\n    \n    // All data come from Buffer A\n    vec3 col = texture(iChannel0, st).rgb;\n    \n    if (glitches) {\n    // Glitchy artefact\n    // Get some block/line randomly, shift their position:\n    float n = noise(vec2(mod(iTime, 8.0), 0.0)).g; //dynamic\n    float n_s = noise(vec2(mod(floor(iTime*0.8), 8.0)/8.0, 0.0)).g; // static\n    float blk_size = 5.0 + 44.0*n_s;\n    vec2 blocks = floor(fragCoord/vec2(blk_size));\n    if (noise(vec2(blocks.y/blk_size, mod(iTime*0.009, 15.0))).r < 0.25) {\n        st.x += (n -0.5) * 0.04; // displacment\n        col = texture(iChannel0, st).rgb; // displacement\n        col.r = n*0.1;// color glitch\n    }\n    \n    // Glitch2: square blocks color shift, blocks corods themselves rotate\n    // and follow a hyperbolic curved surface: pow(blks.x*blks.y, 4.)\n    // if instead of 4. I have a fractional term (e.g. 4.1), negative\n    // are not defined and we don't have a 4 fold symmetries (maybe nicer)\n    n_s = noise(vec2(mod(floor(iTime*2.75), 10.0)/10.0, 0.0)).g; // static\n    blk_size = 2.0 + 12.0*n_s;\n    blocks = floor((fragCoord - iResolution.xy*0.5)/vec2(blk_size));\n    blocks.x = cos(iTime) * blocks.x + sin(iTime) * blocks.y;\n    blocks.y = cos(iTime) * blocks.y - sin(iTime) * blocks.x;\n    if (noise(vec2(pow(blocks.x/blk_size*blocks.y/blk_size, 4.0), mod(iTime*0.05, 11.0)/13.0)).r  < 0.1) {\n        st.y += (n -0.5) * 0.04; // displacment\n        col = texture(iChannel0, st).rgb; // displacement\n        col.g = n*0.3;// color glitch\n        //col.rgb += noise(uv).rgb*0.5;\n    }\n    }\n\n    fragColor = vec4(col,1.0);\n    fragColor = pow(fragColor, vec4(1./2.2)); // sRGB/gamma correction\n    \n    // Debug\n    //blocks /= 32.0;\n    //fragColor = vec4(blocks.x, blocks.y, 0.0, 1.0);\n    //fragColor = vec4(vec3(n_s), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define zoom_effect\n//#define show_grid\n#define random_flips\n#define depth_flow\n\n#define col1 vec3(255.0/255.0,113.0/255.0,206.0/255.0)\n#define col2 vec3(30.0/255.0,210.0/255.0,255.0/255.0)\n\n#define hash21(p) fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)\n\n//float hash21(vec2 n) { \n\t//return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n//}\n\nvec2 rot2(vec2 p, float a) {\n    p.x = cos(a) * p.x + sin(a) * p.y;\n    p.y = -sin(a) * p.x + cos(a) * p.y;\n    return p;\n}\n\n\nvec4 truchet(vec2 uv) {\n    // grid for truchet\n    float ncells_y = 8.0; //number of cells along y axis\n    vec2 grid = fract(uv*ncells_y); // 0 to 1: coordinate withing grid cell\n    grid -= 0.5; //center 0 in the middle of the cell\n    vec2 cid = floor((uv)*ncells_y); // cell ids\n    \n    // flip grid cells: along x axis\n    grid.x *= hash21(cid) > 0.5 ? 1.0 : -1.0;\n    \n    float d = 1.0; // depth (to interleave several truchet)\n    \n    // draw line:\n    vec2 p = grid;\n    //p.y = p.y + 0.5;\n    //p *= 2.0;\n    float blur = 0.01;\n    float s = smoothstep(blur, -blur, abs(p.y+0.5 - p.x) - 0.05);\n    s += smoothstep(blur, -blur, abs(p.y-0.5 - p.x) - 0.05);\n    d = (.5-abs(p.x+p.y)); // depth\n    \n    // Circle\n    //p -= 0.5;\n    float center = grid.x + grid.y > 0.0 ? 0.5 : -0.5;\n    s = smoothstep(-blur, blur, -abs(length(p-0.5) - 0.5) + 0.05); \n    s += smoothstep(-blur, blur, -abs(length(p+0.5) - 0.5) + 0.05);\n    d = atan((p.y-center)/(p.x - center)); // depth\n    #ifdef depth_flow\n    d -= sin(iTime);\n    #endif\n    /////////////////////////////////\n    \n    // colour flow    \n    uv = rot2(uv, iTime*.5);\n    float f = 0.5+0.5*sin(uv.x * uv.y *20.0 - uv.x*0.01 - (0.5+0.5*cos(iTime*0.2))*6.0 * uv.y  - iTime*5.0);\n    vec3 col = vec3(s*mix(col1, col2, f));\n    \n    // draw grid\n    #ifdef show_grid\n    if (grid.x > 0.49 || grid.x < -0.49) col = vec3(.5);\n    if (grid.y > 0.49 || grid.y < -0.49) col = vec3(.5);\n    #endif\n    \n    return vec4(col, d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - 0.5*iResolution.xy)/iResolution.y; // -0.5 to 0.5 along y axis\n    vec2 st = fragCoord/iResolution.xy; // 0 to 1 along both axis\n    \n    \n    // Circle\n    float c = smoothstep(0.005, 0.0, length(uv) - 0.1) - smoothstep(0.005, 0.0, length(uv) - 0.095);\n    \n    \n    \n    // Color\n    vec3 col = vec3(c);\n    uv *= 1.0; // zoom out/in\n    col = truchet(uv).rgb;\n    // just to show the depth value too\n    col *= truchet(uv).a;\n    \n    // Add \"zoomed\" texture\n    float fade = 0.75;\n    float z = 1.2; // zomo factor\n    vec2 center = vec2(0.5, 0.5); // center of zoom\n    center.x += 0.051*cos(iTime);\n    center.y += 0.05*sin(-iTime);\n    #ifdef zoom_effect\n    col += fade * texture(iChannel1, (st-center)/z+center).rgb;\n    #endif\n    \n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 uv = (fragCoord.xy - 0.5*iResolution.xy)/iResolution.y; // -0.5 to 0.5 along y axis\n    vec2 st = fragCoord/iResolution.xy; // 0 to 1 along both axis\n    \n    // Read in bufferA circle and write in itself\n    vec3 c = texture(iChannel0, st).rgb;\n    fragColor = vec4(c,1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}