{"ver":"0.1","info":{"id":"DdyBRV","date":"1698374897","viewed":151,"name":"Nestled Sine Onions","username":"isaacchurchill","description":"I know it would be more efficient to have each pixel just test what sine curve it's closest to, but then the regions where they all overlap wouldn't look the same.","likes":6,"published":3,"flags":0,"usePreview":0,"tags":["2d","sine","rainbow","onion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265\n\nvec3 palette(float x)\n{\n    return 0.5 + 0.5 * cos(x + vec3(0,2,4));\n}\n\nvec3 graph(vec2 p)\n{\n    float t = iTime * 0.1;\n    vec3 col = vec3(0.0);\n    for (float y = -2.0; y <= 1.0; y += 0.05) {\n        float i = y + fract(t);\n        float dist = abs(p.y - i - cos(p.x * PI) * sin(i * PI) / PI);\n        float intensity = exp(dist * -50.0);\n        float highlight = exp(dist * -200.0);\n        col += palette(y * PI * 2.0 + t) * intensity + highlight;\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0 * fragCoord - iResolution.xy ) / iResolution.y;\n    vec3 col = graph(p);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}