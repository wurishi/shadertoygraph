{"ver":"0.1","info":{"id":"Wty3RG","date":"1579147277","viewed":116,"name":"CircularBoundaryMandelbrot","username":"antoinefortin","description":"Allo","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["rec"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define RAYITERATION 64\n\n#define MARCHINGAMOUNT 0.5\n\n#define MARCHINGSMALLESTSTEP 0.01\n\n#define DISTANCE 2.0\n\n#define MAXMANDELBROTDIST 1.5\n#define MANDELBROTSTEPS 5\n\n\nvec3 cosinusCouleur(float t, vec3 a, vec3 b, vec3 c, vec3 d)\n{\n\t\n    \n\treturn 0.5 + b*cos( (5.) * (c*t+d));\n    \n}\n\nvec3 palette(float t)\n{\n \t return cosinusCouleur( t, vec3(0.0,0.5,0.5),vec3(0.22,0.5,0.5),vec3(0.01,0.01,0.01),vec3(0.00, 0.15, 0.20) );\n}\n\nvec3 distanceEstimation(vec3 pos)\n{\n    \n    float puissance = 0.0 + 4.0 *(iTime / 10.0) + 1.0;\n        vec3 z = pos;\n    float dr = 1.1001;\n    float r = 0.0;\n    \n    for(int i = 0; i < MANDELBROTSTEPS; i++)    \n    {\n    \tr = length(z);\n        if(r > MAXMANDELBROTDIST) break;\n        \n        // Coordone spherique\n        float theta = acos(z.z / r);\n        float phi   = atan(z.y, z.x);\n        dr = pow(r, puissance - 1.0) * puissance * dr + 1.0;\n        \n        \n        float zr = pow(r, puissance);\n        zr += abs(sin(iTime / 5.0));\n        theta = theta * puissance;\n        phi = phi * (puissance / 8.0);\n        \n        //Remap en cartesien\n        \n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n       \n    }\n    \n    \n\treturn vec3(0.5*log(r)*r/dr,75.0*pow(dr,0.128/float(RAYITERATION)), 0.5);\n}\n\nvec3 map(vec3 p)\n{\n\t\n    vec3 d = distanceEstimation(p);\n    return d;\n}\n    \n\nvec3 trace(vec3 origin, vec3 ray)\n{\n\n\tfloat t = 0.0;\n    float c = 0.0;\n    \n    \n    for(int i = 0; i < RAYITERATION; i++)\n    {\n        // r(t) = ro + rd * t // \n    \tvec3 path = origin + ray *t;\n        vec3 dist = map(path);\n        \n        t += MARCHINGAMOUNT * dist.x;\n        c += dist.y;\n        \n        if(dist.y  < MARCHINGSMALLESTSTEP) break;\n        \n    \n    }\n    \n    return vec3(t, c, 5.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n\n    uv.x *= iResolution.x / iResolution.y;\n    \n \n    vec3 ray = normalize(vec3 (uv,1.0));\n\n\n    float rotAngle = 0.4+iTime/40.0 + 6.28 * iMouse.x / iResolution.x;\n    \n    ray.yz *= mat2(cos(rotAngle), -sin(rotAngle), sin(rotAngle), cos(rotAngle));\n \n    //camera position (rays origin)\n    float camDist = DISTANCE  * iMouse.y / iResolution.y;\n    if (iMouse.xy==vec2(0)) camDist = DISTANCE*0.55;\n    vec3 origin = vec3 (camDist * sin(rotAngle),0.0,-camDist *cos(rotAngle));           \n\n\tvec3 depth = trace(origin,ray);\n\t\n    //rendering with a fog calculation (further is darker)\n\tfloat fog = 1.0 / (1.0 + depth.x * depth.x * 0.1);\n\t\n    //frag color\n    vec3 fc = vec3(fog);\n    \n    \n    // Output to screen\n    fragColor = vec4(palette(depth.y)*fog,0.0);\n}","name":"Image","description":"","type":"image"}]}