{"ver":"0.1","info":{"id":"Nd23Rd","date":"1617895065","viewed":159,"name":"Sea of Clouds","username":"andrew741","description":"clouds and waves go brrrrrrrrrrr. This is an early version and builds off of my cloud texture shader (for the volumetric clouds). Note that it's very slow.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","waves","clouds","ocean","sky","shadows","spheretracing","reflections","specularreflection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n// remaps a value\nfloat map(float val, float cMin, float cMax, float nMin, float nMax)\n{\n    // a basic remapping function\n    // remapping from 0 - any\n    float nVal = val - cMin;\n    // scaling from 0 - (new_max - new_min)\n    nVal *= (nMax - nMin) / (cMax - cMin);\n    // adding the new min\n    nVal += nMin;\n    // returning it\n    return nVal;\n}\n\n\n// a heighly random persudo random number generator that takes in a vec3 and returns a vec3\nvec3 random(vec3 co)\n{\n    // note that this code is from another user (on shadertoy)\n    vec3 p = co;\n    p = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n    vec3 output_ = fract(sin(p)*43758.5453123);\n\treturn output_;\n}\n\n\n// a smoothstep function\nfloat Smoothstep(float x)\n{\n    float k = clamp(x, 0., 1.);\n    return k * k * (3. - 2. * k);\n}\n\n\n// returns the magnitude\nfloat mag(vec3 v)\n{\n    // this is just the dot of v\n    return dot(v, v);\n}\n\n\n// returns a value between 0 and 1 (of worly noise)\nfloat WorlyNoise(vec3 sample_pos, float scale, int o)\n{\n    // e is unused and is here because it was used in an earlier version\n    float e = float(o);\n    \n    // multiplacation is faster then divition\n    float scale_dived = 1. / scale;\n    \n    // geting the sample poses cell pos\n    vec3 cell_pos = floor(sample_pos * scale_dived);\n    \n    // generating cells/nabors positions\n    // layer 1\n    vec3 cell1 = cell_pos + vec3(1., -1., -1.);\n    vec3 cell2 = cell_pos + vec3(1., 0., -1.);\n    vec3 cell3 = cell_pos + vec3(1., 1., -1.);\n    \n    vec3 cell4 = cell_pos + vec3(0., -1., -1.);\n    vec3 cell5 = cell_pos + vec3(0., 0., -1.);\n    vec3 cell6 = cell_pos + vec3(0., 1., -1.);\n    \n    vec3 cell7 = cell_pos + vec3(-1., -1., -1.);\n    vec3 cell8 = cell_pos + vec3(-1., 0., -1.);\n    vec3 cell9 = cell_pos + vec3(-1., 1., -1.);\n    \n    // layer 2\n    vec3 cell10 = cell_pos + vec3(1., -1., 0.);\n    vec3 cell11 = cell_pos + vec3(1., 0., 0.);\n    vec3 cell12 = cell_pos + vec3(1., 1., 0.);\n    \n    vec3 cell13 = cell_pos + vec3(0., -1., 0.);\n    vec3 cell14 = cell_pos + vec3(0., 0., 0.);\n    vec3 cell15 = cell_pos + vec3(0., 1., 0.);\n    \n    vec3 cell16 = cell_pos + vec3(-1., -1., 0.);\n    vec3 cell17 = cell_pos + vec3(-1., 0., 0.);\n    vec3 cell18 = cell_pos + vec3(-1., 1., 0.);\n    \n    // layer 3\n    vec3 cell19 = cell_pos + vec3(1., -1., 1.);\n    vec3 cell20 = cell_pos + vec3(1., 0., 1.);\n    vec3 cell21 = cell_pos + vec3(1., 1., 1.);\n    \n    vec3 cell22 = cell_pos + vec3(0., -1., 1.);\n    vec3 cell23 = cell_pos + vec3(0., 0., 1.);\n    vec3 cell24 = cell_pos + vec3(0., 1., 1.);\n    \n    vec3 cell25 = cell_pos + vec3(-1., -1., 1.);\n    vec3 cell26 = cell_pos + vec3(-1., 0., 1.);\n    vec3 cell27 = cell_pos + vec3(-1., 1., 1.);\n    \n    // generating the random offests for cell points    \n    // layer1\n    vec3 rand1 = random(cell1) * scale;\n    vec3 rand2 = random(cell2) * scale;\n    vec3 rand3 = random(cell3) * scale;\n    vec3 rand4 = random(cell4) * scale;\n    vec3 rand5 = random(cell5) * scale;\n    vec3 rand6 = random(cell6) * scale;\n    vec3 rand7 = random(cell7) * scale;\n    vec3 rand8 = random(cell8) * scale;\n    vec3 rand9 = random(cell9) * scale;\n    // layer2\n    vec3 rand10 = random(cell10) * scale;\n    vec3 rand11 = random(cell11) * scale;\n    vec3 rand12 = random(cell12) * scale;\n    vec3 rand13 = random(cell13) * scale;\n    vec3 rand14 = random(cell14) * scale;\n    vec3 rand15 = random(cell15) * scale;\n    vec3 rand16 = random(cell16) * scale;\n    vec3 rand17 = random(cell17) * scale;\n    vec3 rand18 = random(cell18) * scale;\n    // layer3\n    vec3 rand19 = random(cell19) * scale;\n    vec3 rand20 = random(cell20) * scale;\n    vec3 rand21 = random(cell21) * scale;\n    vec3 rand22 = random(cell22) * scale;\n    vec3 rand23 = random(cell23) * scale;\n    vec3 rand24 = random(cell24) * scale;\n    vec3 rand25 = random(cell25) * scale;\n    vec3 rand26 = random(cell26) * scale;\n    vec3 rand27 = random(cell27) * scale;\n    \n    // generating the distance to each of those cell positions/points position (the mag not length)\n    // layer1\n    float dist1 = mag(sample_pos - (cell1 * scale + rand1));\n    float dist2 = mag(sample_pos - (cell2 * scale + rand2));\n    float dist3 = mag(sample_pos - (cell3 * scale + rand3));\n    float dist4 = mag(sample_pos - (cell4 * scale + rand4));\n    float dist5 = mag(sample_pos - (cell5 * scale + rand5));\n    float dist6 = mag(sample_pos - (cell6 * scale + rand6));\n    float dist7 = mag(sample_pos - (cell7 * scale + rand7));\n    float dist8 = mag(sample_pos - (cell8 * scale + rand8));\n    float dist9 = mag(sample_pos - (cell9 * scale + rand9));\n    // layer2\n    float dist10 = mag(sample_pos - (cell10 * scale + rand10));\n    float dist11 = mag(sample_pos - (cell11 * scale + rand11));\n    float dist12 = mag(sample_pos - (cell12 * scale + rand12));\n    float dist13 = mag(sample_pos - (cell13 * scale + rand13));\n    float dist14 = mag(sample_pos - (cell14 * scale + rand14));\n    float dist15 = mag(sample_pos - (cell15 * scale + rand15));\n    float dist16 = mag(sample_pos - (cell16 * scale + rand16));\n    float dist17 = mag(sample_pos - (cell17 * scale + rand17));\n    float dist18 = mag(sample_pos - (cell18 * scale + rand18));\n    // layer3\n    float dist19 = mag(sample_pos - (cell19 * scale + rand19));\n    float dist20 = mag(sample_pos - (cell20 * scale + rand20));\n    float dist21 = mag(sample_pos - (cell21 * scale + rand21));\n    float dist22 = mag(sample_pos - (cell22 * scale + rand22));\n    float dist23 = mag(sample_pos - (cell23 * scale + rand23));\n    float dist24 = mag(sample_pos - (cell24 * scale + rand24));\n    float dist25 = mag(sample_pos - (cell25 * scale + rand25));\n    float dist26 = mag(sample_pos - (cell26 * scale + rand26));\n    float dist27 = mag(sample_pos - (cell27 * scale + rand27));\n    \n    // finding the smallest value\n    // layer1\n    float strength1 = min(min(min(dist1, dist2), min(dist3, dist4)), min(min(dist5, dist6), min(dist7, min(dist8, dist9))));\n    // layer2\n    float strength2 = min(min(min(dist10, dist11), min(dist12, dist13)), min(min(dist14, dist15), min(dist16, min(dist17, dist18))));\n    // layer3\n    float strength3 = min(min(min(dist19, dist20), min(dist21, dist22)), min(min(dist23, dist24), min(dist25, min(dist26, dist27))));\n    // finding the overal smallest and taking the square root of it to get the length to it\n    // layers all\n    float strength = (min(min(strength1, strength2), strength3)) / (scale);\n    \n    // returning and remapping\n    //return map(strength / (scale * 1.25), 0., 1., 0.2, -0.1);\n    return (1. - strength / (scale * 1.25)) * 3.25 - 2.25;\n    //return map(strength / (scale * 1.25), 0., 1., 1., -4.);\n}\n\n// this noise method is from https://www.shadertoy.com/view/XslGRr\n#define NOISE_METHOD 1\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\n#if NOISE_METHOD==0\n    x = p + f;\n    return textureLod(iChannel2,(x+0.5)/32.0,0.0).x*2.0-1.0;\n#endif\n#if NOISE_METHOD==1\n\tvec2 uv = (p.xy+vec2(37.0,239.0)*p.z) + f.xy;\n    vec2 rg = textureLod(iChannel0,(uv+0.5)/256.0,0.0).yx;\n\treturn mix( rg.x, rg.y, f.z )*2.0-1.0;\n#endif    \n#if NOISE_METHOD==2\n    ivec3 q = ivec3(p);\n\tivec2 uv = q.xy + ivec2(37,239)*q.z;\n\tvec2 rg = mix(mix(texelFetch(iChannel0,(uv           )&255,0),\n\t\t\t\t      texelFetch(iChannel0,(uv+ivec2(1,0))&255,0),f.x),\n\t\t\t\t  mix(texelFetch(iChannel0,(uv+ivec2(0,1))&255,0),\n\t\t\t\t      texelFetch(iChannel0,(uv+ivec2(1,1))&255,0),f.x),f.y).yx;\n\treturn mix( rg.x, rg.y, f.z )*2.0-1.0;\n#endif    \n}\n\n\nfloat Hash31(vec3 p)\n{\n    vec3 r = random(p);\n    return r.x * r.y * r.z;\n}\n\n\n// generates a noise texture (a height from 0 - 1 based on position)\nfloat OctaveWorly(vec3 fragCoord, int octaves, float scale, float persistance, float luclarity)\n{\n    // initializing veriables\n    float height = 0.;\n    float l = 1.;\n    float total = 0.;\n    // looping over all octaves\n    for (int o = 0; o < octaves; o++)\n    {\n        // getting the height for that octave and adding it\n        vec3 p = fragCoord + float(o * 500);\n        height += noise(fragCoord / scale);  // WorlyNoise(p, scale, o) * l;\n        // this is to remap the final height\n        total += l;  // the 0.95 is because the height of the bumps (when added up) is almost never equal to the max height and thefore the more octaves, the duller the color\n        // changing the height and scale based on inputed paramaters\n        l *= luclarity;\n        scale *= persistance;\n    }\n    // remaping the final height\n    height /= total;\n    // returning the height\n    height *= 0.2;\n    //height *= smoothstep(0., 0.05, noise(fragCoord / 200.));\n    //height = clamp(height, 0.01, 0.5);\n    //return floor(Hash31(floor((fragCoord - vec3(0, 120, 0)) / 240.)) + 0.85) * 0.05;\n    return height;\n}\n\n\n// returns a scaler for density so the clouds arnt just cut off at the bounds of the cloud container\nfloat GetHeightFalloff(float y, float cloud_height, float cloud_thickness)\n{\n    float scaler = 1. - Smoothstep(max(map((y - 120.) / 160., 0., 1., -3., 1.), 0.));\n    return scaler;\n}\n\n\n// gets the height of the waves at a given xy point\nfloat waterHeight(vec2 p)\n{\n    /*\n    float height = map(sin(p.x * 0.1 + p.y * 0.3 + (sin(p.y * 0.5 + p.x * 0.1) * 0.5 + 0.5)) + sin(p.x * 0.4 - p.y + (sin(p.y) * 0.5)), -3., 1.5, 0., 1.) * (sin(p.y * 0.2) * 0.5 + 0.5 + (sin(p.x * 0.1 + p.y * 0.7) * 0.5 + 0.5) * 0.2 + sin(p.x * 0.05) * sin(p.y * 0.025) * 0.2);\n    height = height + (sin(p.x * 0.002 + p.y * 0.004) * sin(p.y * 0.007 + p.x * 0.035)) + sin(p.x * 0.01 + p.y * 0.2 + 1.5) * 0.4;\n    return height + 1.;\n    */\n    p *= 0.3;\n    float h1 = 1. - abs(sin(iTime) * cos(p.x + sin(p.y*0.4))) * 1.;\n    float h2 = 1.5 - abs(cos(iTime) * sin(p.y * 0.8 + cos(p.x * 0.1))) * 1.5;\n    float h3 = 0.75 - abs(sin(iTime + 4.) * sin((p.y + 6.) * 1.25 + sin((p.x - 8.) * 0.4))) * 0.75;\n    float h4 = 0.75 - abs(cos(iTime - 5.) * cos((p.x - 6.) + sin(p.y + 8.))) * 0.75;\n    return h1 + h2 + h3 + h4;\n}\n\n\n// returns the distance to the ocean (surface)\nfloat getDst(vec3 p)\n{\n    float dst1 = p.y - waterHeight(p.xz);\n    return dst1;\n}\n\n\n// reverses a ray\nvec3 reverseRay(vec3 angle)\n{\n    return vec3(-angle.x, -angle.y, -angle.z);\n}\n\n\n// gets the normal of the water\nvec3 getNormal(vec3 p) {\n\tfloat d = getDst(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 normal = d - vec3(\n        getDst(p - e.xyy),\n        getDst(p - e.yxy),\n        getDst(p - e.yyx));\n    \n    return normalize(normal);\n}\n\n\n// the derection of the sun (constant)\n//vec3 sun_derection = normalize(vec3(-0.5, 0.25, 1.));\n\n\n// main loop/the shader\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // the normalized coordinates\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / (iResolution.x * 0.5);\n    // the ray's direction\n    vec2 cam_rot = (iMouse.xy / iResolution.xy - 0.5) * 2.;\n    vec3 rd = normalize(vec3(uv.x + (iMouse.x / (iResolution.x * 0.5) - 0.5) * 0.5, uv.y + (iMouse.y / (iResolution.y * 0.5) - 0.5) * 0.5, 1.));\n    \n    // the suns angle (rotates)\n    vec3 sun_derection = normalize(vec3(sin(iTime * 0.05), map(sin(iTime * 0.01), -1., 1., 0.25, 1.), cos(iTime * 0.05)));\n    \n    // the camera's position\n    vec3 camera_pos = vec3(iTime * 20., (sin(iTime * 0.15) * 0.5 + 0.5) * 400. + 5., iTime * 20.);// + vec3(iMouse.x, 0., iMouse.y);\n    \n    // some parameters that change the look of the clouds and performance\n    int steps = 90;\n    int sun_steps = 10;\n    float cloud_height = 120.;\n    float cloud_thickness = 160.;\n    bool in_cloud = false;\n    \n    // generating the distance to the cloud and the distance through the cloud\n    float dst_to_cloud, dst_through_cloud;\n    \n    float rd2 = 1. / rd.y;\n    // the cloud is above the player\n    if (camera_pos.y < cloud_height)\n    {\n        // checking if the cloud is in view\n        if (rd.y > 0.)\n        {\n            // finding the dist to the cloud and through the cloud\n            dst_to_cloud = (cloud_height - camera_pos.y) * rd2;\n            dst_through_cloud = cloud_thickness * rd2;\n            // the cloud is in view\n            in_cloud = true;\n        }\n    }\n    // the cloud is in the player\n    else if (camera_pos.y < cloud_height + cloud_thickness)\n    {\n        // checking if the ray's direction is above or bellow\n        dst_to_cloud = 0.;  // the distance to the cloud is 0 because your in the cloud\n        // ray's going up\n        if (rd.y > 0.)\n        {\n            // finding the dist through the cloud\n            dst_through_cloud = (cloud_thickness - (camera_pos.y - cloud_height)) * rd2;\n        }\n        // the ray is going downwards\n        else\n        {\n            // finding the dist through the cloud\n            dst_through_cloud = (camera_pos.y - cloud_height) * abs(rd2);\n        }\n        // the cloud is in view\n        in_cloud = true;\n    }\n    // the cloud is bellow the player\n    else\n    {\n        // checking if the cloud is in view\n        if (rd.y < 0.)\n        {\n            // finding the dist to and through the cloud\n            dst_to_cloud = ((camera_pos.y - cloud_height) - cloud_thickness) * abs(rd2);\n            dst_through_cloud = cloud_thickness * abs(rd2);\n            // the cloud is in view\n            in_cloud = true;\n        }\n    }\n    \n    // the color of the sky\n    float intensity = rd.y * 0.5 + 0.5;\n    vec3 sky_color = vec3(intensity * 0.6, intensity * 0.6, intensity);\n    vec3 col = sky_color;\n    // drawing the sun in the sky\n    vec3 sun_col = vec3(1., 0.95, 0.85);\n    col = mix(col, sun_col, pow(max(dot(sun_derection, rd), 0.), 100.));\n    \n    // simulating water\n    float water_height = 0.;\n    \n    bool hit_water = false;\n    float dst_to_water;\n    \n    if (rd.y < 0.)\n    {\n        hit_water = true;\n        dst_to_water = max(camera_pos.y - water_height, 0.) / abs(rd.y);\n    }\n    \n    // rendering the water\n    if (hit_water)\n    {\n        // finding where the view ray hits the water\n        vec3 water_p = camera_pos + rd * dst_to_water;\n        \n        // using sphere tracing to add waves to the water\n        float d;\n        for (int s = 0; s < 5; s++)\n        {\n            d = getDst(water_p);\n            water_p += d * rd;\n            if (d < 0.01) break;\n        }\n        \n        // finding where the sun's direction vector hits the clouds (for shadows)\n        vec3 cloud_collide = water_p + sun_derection * ((cloud_height - water_p.y) / sun_derection.y);\n        \n        // finding the shadow cast by clouds\n        float ss = (cloud_thickness / sun_derection.y) / float(sun_steps);\n        vec3 pss = sun_derection * ss;\n        float dens = 0.;\n        for (int s = 0; s < sun_steps; s++)\n        {\n            // adding up the density\n            dens += max(OctaveWorly(cloud_collide, 1, 120., 0.5, 0.5), 0.) * ss * GetHeightFalloff(cloud_collide.y, cloud_height, cloud_thickness) * 0.175;\n            // stepping through the cloud\n            cloud_collide += pss;\n        }\n        \n        // calculating the color of the water\n        vec3 water_color = vec3(0.45, 0.45, 0.65);\n        \n        // finding the color of the clouds above the water\n        \n        // the water normal and reflected ray for the water\n        vec3 water_normal = getNormal(water_p);\n        vec3 reflected_image;\n        \n        // finding the darkness from the clouds\n        float tr = exp(-dens * 0.075);\n        // getting the normal of the water\n        // the smoothness (size of the specular reflection)\n        float smoothness = 0.5;\n        // finding the specular highlight and diffused lighting\n        float specularAngle = acos(dot(normalize(sun_derection - rd), water_normal));\n        float specularExponent = specularAngle / (1. - smoothness);\n        float specularHighlight = exp(-specularExponent * specularExponent) * tr;\n        float diffseLighting = clamp(dot(water_normal, sun_derection), 0., 1.);\n        // finding how much reflection will be seen\n        float ref = pow(1. - diffseLighting, 1.5);\n        \n        // the reflection dose acount for a good amount\n        if (ref >= 0.06)\n        {\n            vec3 reflected = water_normal - (0. - rd);\n            float dst_through_cloud2 = cloud_thickness / reflected.y;\n            float dst_to_cloud2 = (cloud_height - water_p.y) / reflected.y;;\n\n            // finding the step size\n            float step_size = min(dst_through_cloud2 / float(steps / 4), 15.);\n            vec3 point_step_size = reflected * step_size;\n\n            // initializing some veriables\n            float transmittion = 1.;\n            float lightEnergy = 0.;\n\n            // some peramaters related to transparency of the cloud and brightness\n            float lightApsorbtionToSun = 0.235;\n            float lightApsorbtion = 0.165;\n            float lightPhase = map(clamp(pow(dot(sun_derection, rd), 7.5), 0., 1.), 0., 1., 0.21, 0.5);//0.21;\n            \n            // the color of the cloud\n            vec3 cloud_color = sun_col;  // vec3(1., 0.9, 0.85);\n\n            // the starting position\n            vec3 p = water_p + reflected * dst_to_cloud2;\n\n            // initializing some veriables that are going to be used later\n\n            float density, dst_to_sun_through_cloud, lightTransmittion, density_in_cloud, sun_step_size, density_sun, sun_trans;\n            vec3 point_sun_step_size, p2;\n\n            // stepping through the cloud\n            for (int s = 0; s < steps / 4; s++)\n            {\n                p2 = vec3(p.x, p.y, p.z);\n\n                // finding the density at this point using worly noise\n                density = max(OctaveWorly(p, 3, 120., 0.6, 0.5), 0.) * step_size * GetHeightFalloff(p.y, cloud_height, cloud_thickness);\n\n                // checking if the current sample point is in a cloud (within the container of clouds)\n                if (density > 0.)\n                {\n                    // sun is upwards\n                    if (sun_derection.y > 0.)\n                    {\n                        // finding the distance through the cloud going in ther direction of the sun\n                        dst_to_sun_through_cloud = (cloud_thickness - (p.y - cloud_height)) / sun_derection.y;\n                    }\n                    // sun is downwards\n                    else\n                    {\n                        // finding the distance through the cloud going in ther direction of the sun\n                        dst_to_sun_through_cloud = (p.y - cloud_height) / abs(sun_derection.y);\n                    }\n                    // finding the step size through the cloud going twords the sun\n                    sun_step_size = dst_to_sun_through_cloud / float(sun_steps);\n                    point_sun_step_size = sun_derection * sun_step_size;\n\n                    // resetting some veriables for lighting\n                    density_in_cloud = 0.;\n                    // stepping through the cloud twords the sun\n                    for (int sun_step = 0; sun_step < sun_steps; sun_step++)\n                    {\n                        // moving twords the sun\n                        p2 += point_sun_step_size;\n                        // finding the density at the current point\n                        density_sun = max(OctaveWorly(p2, 3, 120., 0.6, 0.5), 0.) * sun_step_size * GetHeightFalloff(p.y, cloud_height, cloud_thickness);\n                        // adding up the total density\n                        density_in_cloud += density_sun;\n                    }\n\n                    // finding how much light made it through at this current point\n                    sun_trans = exp(-density_in_cloud * lightApsorbtionToSun);\n\n                    // changing the light\n                    lightTransmittion = sun_trans;\n                    lightEnergy += density * transmittion * lightTransmittion * lightPhase;\n                    // altering the cloud coverage\n                    transmittion *= exp(-density * lightApsorbtion);\n                }\n\n                // increases preformace with no visual change\n                if (transmittion < 0.01)\n                {\n                    break;\n                }\n\n                // moving further through the cloud\n                p += point_step_size;\n            }\n            // finding the new color\n            reflected_image = col * transmittion + cloud_color * lightEnergy;\n        }\n        // the reflection dosent acount for anything\n        else\n        {\n            // setting the reflected color to the color of the sky\n            reflected_image = col;\n        }\n        reflected_image = col;\n        \n        // darkening the water color to acount for refraction (isnt at all physically correct)\n        water_color = mix(water_color, vec3(0.1, 0.1, 0.35), clamp(abs(rd.y + 0.05) * 2., 0., 1.));\n        \n        // adding in the reflected color\n        vec3 final_water_col = mix(water_color, reflected_image, ref);\n        // setting the color of the ocean\n        col = final_water_col * tr * map(dot(water_normal, sun_derection), -1., 1., 0.25, 1.75) * max(diffseLighting, 0.4) + sun_col * specularHighlight;\n    }\n    \n    // chekcing if the cloud/clouds are in view\n    if (in_cloud)\n    {\n        // finding the step size\n        float step_size = min(dst_through_cloud / float(steps), 15.);\n        vec3 point_step_size = rd * step_size;\n        \n        // initializing some veriables\n        float transmittion = 1.;\n        float lightEnergy = 0.;\n        \n        // some peramaters related to transparency of the cloud and brightness\n        float lightApsorbtionToSun = 0.235;\n        float lightApsorbtion = 0.165;\n        float lightPhase = map(clamp(pow(dot(sun_derection, rd), 7.5), 0., 1.), 0., 1., 0.21, 0.5);//0.21;\n        \n        // the color of the cloud\n        vec3 cloud_color = sun_col;  // vec3(1., 0.9, 0.85);\n\n        // the starting position\n        vec3 p = camera_pos + rd * dst_to_cloud;\n        \n        // initializing some veriables that are going to be used later\n        \n        float density, dst_to_sun_through_cloud, lightTransmittion, density_in_cloud, sun_step_size, density_sun, sun_trans;\n        vec3 point_sun_step_size, p2;\n        \n        // stepping through the cloud\n        for (int s = 0; s < steps; s++)\n        {\n            p2 = vec3(p.x, p.y, p.z);\n            \n            // finding the density at this point using worly noise\n            density = max(OctaveWorly(p, 3, 120., 0.6, 0.5), 0.) * step_size * GetHeightFalloff(p.y, cloud_height, cloud_thickness);\n\n            // checking if the current sample point is in a cloud (within the container of clouds)\n            if (density > 0.)\n            {\n                // sun is upwards\n                if (sun_derection.y > 0.)\n                {\n                    // finding the distance through the cloud going in ther direction of the sun\n                    dst_to_sun_through_cloud = (cloud_thickness - (p.y - cloud_height)) / sun_derection.y;\n                }\n                // sun is downwards\n                else\n                {\n                    // finding the distance through the cloud going in ther direction of the sun\n                    dst_to_sun_through_cloud = (p.y - cloud_height) / abs(sun_derection.y);\n                }\n                // finding the step size through the cloud going twords the sun\n                sun_step_size = dst_to_sun_through_cloud / float(sun_steps);\n                point_sun_step_size = sun_derection * sun_step_size;\n            \n                // resetting some veriables for lighting\n                density_in_cloud = 0.;\n                // stepping through the cloud twords the sun\n                for (int sun_step = 0; sun_step < sun_steps; sun_step++)\n                {\n                    // moving twords the sun\n                    p2 += point_sun_step_size;\n                    // finding the density at the current point\n                    density_sun = max(OctaveWorly(p2, 3, 120., 0.6, 0.5), 0.) * sun_step_size * GetHeightFalloff(p.y, cloud_height, cloud_thickness);\n                    // adding up the total density\n                    density_in_cloud += density_sun;\n                }\n                // finding how much light made it through at this current point\n                sun_trans = exp(-density_in_cloud * lightApsorbtionToSun);\n                \n                // changing the light\n                lightTransmittion = sun_trans;\n                lightEnergy += density * transmittion * lightTransmittion * lightPhase;\n                // altering the cloud coverage\n                transmittion *= exp(-density * lightApsorbtion);\n            }\n\n            // increases preformace with no visual change\n            if (transmittion < 0.01)\n            {\n                break;\n            }\n\n            // moving further through the cloud\n            p += point_step_size;\n        }\n        // finding the new color\n        col = col * transmittion + cloud_color * lightEnergy;\n    }\n        \n    // setting the pixels color\n    fragColor = vec4(col,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}