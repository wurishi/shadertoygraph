{"ver":"0.1","info":{"id":"ftKBRw","date":"1664252016","viewed":86,"name":"Purdue Hackers Workshop","username":"fiiisssh","description":"workshop","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["purduehackers"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdEquilateralTriangle( in vec2 p );\nmat2 rot(float angle);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // https://puhack.horse/shader-slideshow\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy / 2.0)/iResolution.y;\n\n    // for the current pixel,\n    // if its distance from the center is less than 0.3\n    // set its red component to 1\n    vec3 col = vec3(0.0);\n    if (length(uv) < 0.3) {\n        //col.r = 1.0;\n    }\n    \n    // GLSL has a builtin for this\n    // step returns 1 if the second argument \n    // is greater than the first, otherwise 0\n    //\n    // see what happens if we don't subtract it from 1\n    // col.g += 1.0 - step(0.3, length(uv));\n    \n    // the circle is slightly jagged at the edges,\n    // instead of step let's use smoothstep\n    // the further the two values, the blurrier it\n    // will get\n    // col.b += 1.0 - smoothstep(0.3, 0.305, length(uv));\n    \n    // we can also use smoothstep to invert it for us\n    // by switching the first two arguments\n    // col.r += smoothstep(0.305, 0.3, length(uv));\n    \n    // SDFs:\n    // https://iquilezles.org/articles/distfunctions2d/\n    // An SDF is the distance of a point from the edges of\n    // a shape. For a circle, that's just length(uv) - radius\n    // col.g += smoothstep(0.0075, 0.0, length(uv) - 0.2);\n    \n    // Using SDFs, we can easy create filled shapes\n    // and edges and transform them by transforming the whole UV.\n    \n    vec2 triangle_uv = uv * 5.0;\n    float triangle = sdEquilateralTriangle(triangle_uv);\n    // col.b += smoothstep(0.0075, 0.0, triangle);\n    // col.r += smoothstep(0.0075, 0.0, abs(triangle) - 0.05);\n    \n    // this is a quirky UV transformation,\n    // first the triangle is scaled up a little bit,\n    // and multipied by a scaled sine function\n    // it could also work with addition, try playing with\n    // it to understand\n    triangle_uv /= 1.5;\n    triangle_uv *= 1.0 - (0.1 * sin(uv.x * 60.0));\n    triangle = sdEquilateralTriangle(triangle_uv);\n    // col.g += smoothstep(0.0075, 0.0, abs(triangle) - 0.05);\n    \n    // aside from drawing shapes, we can also draw\n    // interesting things with gradients\n    // col.bg += uv.y + 0.5;\n    // col.rb += vec2(uv.y, uv.x) + 0.5;\n    \n    // we can also turn our UV into a grid using fract\n    vec2 grid_uv = fract(uv);\n    //col.rg += grid_uv;\n    grid_uv = fract(uv * 5.0);\n    //col.rg += grid_uv;\n    \n    // using our grid uv, we can multiply everything from before\n    \n    // first, we have to shift our grid_uv up and to the right\n    // to center each grid segment\n    grid_uv.xy -= 0.5;\n    float grid_triangle = sdEquilateralTriangle(grid_uv * 5.0);\n    // col.r += smoothstep(0.05, 0.0, grid_triangle);\n    \n    // we can animate stuff using iTime\n    // col.rbg += vec3(sin(iTime), cos(iTime), sin(iTime) - cos(iTime));\n    \n    // try putting this line near the top and then drawing stuff\n    // uv.y += iTime / 5.0;\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\nfloat sdEquilateralTriangle( in vec2 p )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nmat2 rot(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return mat2(c, -s, s, c);\n}","name":"Image","description":"","type":"image"}]}