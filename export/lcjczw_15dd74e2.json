{"ver":"0.1","info":{"id":"lcjczw","date":"1722082070","viewed":36,"name":"[Dev suspended] Piano Tiles","username":"ODtian","description":"Currently no sound, since sound channel can't read buffer. Z X C V for each track.","likes":1,"published":1,"flags":56,"usePreview":0,"tags":["game"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// #define VSCODE\n\n#ifdef VSCODE\n#iChannel0 \"file://buffera.glsl\"\n#iChannel1 \"file://fonts.png\"\n#include \"common.glsl\"\n#endif\n\nconst vec2 block_size = vec2(BLOCK_WIDTH / 2.0, BLOCK_HEIGHT / 2.0);\n\nint progress;\nfloat block_offset;\nfloat start_time;\nfloat end_time;\nint wrong_track;\n\nvec4 char(vec2 pos, uint c) {\n    if (pos.x < 0. || pos.x > 1. || pos.y < 0. || pos.y > 1.)\n        return vec4(0, 0, 0, 1.0);\n    return textureGrad(iChannel1, pos / 16. + fract(vec2(c, 15u - c / 16u) / 16.), dFdx(pos / 16.), dFdy(pos / 16.));\n}\n\nSurface map(vec2 pos) {\n\n    // for (int i = 0; i < DATA_LENGTH_B; ++i) {\n    //     vec4 d = data[DATA_LENGTH_A + i];\n    //     sounds[i * 2] = Sound(floatBitsToInt(d.x), d.y);\n    //     sounds[i * 2 + 1] = Sound(floatBitsToInt(d.z), d.w);\n    // }\n\n    // vec4 res = vec4(1.0);\n    Surface co = Surface(1.0, Material(vec3(float(0.0)), 1.0, 1.0));\n    int len = BLOCK_SIZE - progress;\n    bool render_end = len < 10;\n\n    len = min(len, 10);\n\n    float y = block_offset;\n    for (int i = 0; i < len; ++i, y += BLOCK_HEIGHT) {\n        float offset = float(blocks[progress + i].track) - 2.0;\n        float x = (offset + 0.5) * BLOCK_WIDTH;\n        co.d = op_union(co.d, sdBox(pos - vec2(x, y + BLOCK_HEIGHT_H), block_size));\n    }\n    co.d = op_union(co.d, sdBox(pos - vec2(0.0, 1.0), vec2(10.0, 0.001)));\n    co.d = op_union(co.d, sdBox(pos, vec2(0.001, 10.0)));\n\n    if (render_end) {\n        Surface end = Surface(y - pos.y, Material(vec3(0.1, 1.0, 0.2), 0.0, 0.0));\n        co = surf_op_union(co, end);\n    }\n\n    if (wrong_track >= 0) {\n        float x = (float(wrong_track) - 2.0 + 0.5) * BLOCK_WIDTH;\n        float size = step(WRONG_SHIN_DUR_H, mod(iTime - end_time + WRONG_SHIN_DUR_H, WRONG_SHIN_DUR));\n        Surface wrong = Surface(sdBox(pos - vec2(x, block_offset + BLOCK_HEIGHT_H), size * block_size), Material(vec3(1.0, 0.1, 0.1), 0.0, 0.0));\n        co = surf_op_union(co, wrong);\n    }\n\n    // co.d = op_union(c.a, co.d);\n\n    return co;\n}\n\nvec3 render(vec2 pos) {\n    const vec3 background = vec3(0.8);\n    float len = min(1.0 / iResolution.x, 1.0 / iResolution.y);\n    Surface co = map(pos);\n\n    vec3 col = mix(co.mat.albedo, background, smoothstep(0.0, len, co.d));\n\n    bool text_normal = pos.y > 2.0 - FONT_SCALE && start_time > 0.0;\n    bool text_end = end_time > 0.0 && wrong_track < 0;\n\n    if (text_normal || text_end) {\n        // including a dot\n        uint digit[5];\n\n        float pre = 0.1;\n        float t = end_time > 0.0 ? end_time - start_time : iTime - start_time;\n\n        int char_length = 0;\n        for (int i = 1; i < 5; ++i, pre *= 10.0) {\n            uint d = uint(mod(t / pre, 10.0));\n            if (d != 0u) {\n                char_length = i;\n            }\n            digit[i] = 48u + d;\n        }\n\n        char_length = max(char_length + 1, 3);\n\n        digit[0] = digit[1];\n        digit[1] = 46u;\n\n        float char_width = float(char_length) * FONT_GUTTER - (1.0 - FONT_GUTTER);\n\n        float text_end = char_width / 2.0;\n\n        float end_t = smoothstep(0.0, 1.0, (iTime - end_time) * step(0.0, end_time));\n        float font_scale = mix(FONT_SCALE, 2.0 * FONT_SCALE, end_t);\n        float font_height = mix(2.0 / font_scale - 1.0, 1.0 / font_scale - 0.5, end_t);\n\n        float c;\n        for (int i = 0; i < char_length; ++i) {\n            text_end -= FONT_GUTTER;\n            c = char(pos / font_scale - vec2(text_end, font_height), digit[i]).r;\n            col = mix(col, FONT_COLOR, c);\n        }\n\n    }\n\n    return col;\n}\n\nvoid read_data() {\n    vec4 data[DATA_LENGTH_A + DATA_LENGTH_B];\n\n    for (int i = 0; i < DATA_LENGTH_A + DATA_LENGTH_B; ++i) {\n        data[i] = texelFetch(iChannel0, ivec2(i, 0), 0);\n    }\n\n    progress = floatBitsToInt(data[0].x);\n    block_offset = data[0].y;\n    start_time = data[0].z;\n    end_time = data[0].w;\n\n    wrong_track = floatBitsToInt(data[1].x);\n\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    read_data();\n\n    vec2 pos = (2.0 * fragCoord - vec2(iResolution.x, 0.0)) / iResolution.y;\n\n    vec3 col = render(pos);\n\n    col = Tonemap_ACES(col);\n    col = pow(col, vec3(0.4545));\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// #define VSCODE\n\n#ifdef VSCODE\n#iChannel0 \"file://buffera.glsl\"\n#include \"common.glsl\"\n#endif\n\nvec2 mainSound(int samp, float time) {\n    Sound sounds[SOUND_LENGTH];\n\n    vec2 res = vec2(0.0);\n\n    vec4 data[DATA_LENGTH_A + DATA_LENGTH_B];\n    for (int i = 0; i < DATA_LENGTH_A + DATA_LENGTH_B; ++i) {\n        data[i] = texelFetch(iChannel0, ivec2(i, 0), 0);\n    }\n\n    for (int i = 0; i < DATA_LENGTH_B; ++i) {\n        vec4 d = data[DATA_LENGTH_A + i];\n        sounds[i * 2] = Sound(floatBitsToInt(d.x), d.y);\n        sounds[i * 2 + 1] = Sound(floatBitsToInt(d.z), d.w);\n    }\n\n    for (int i = 0; i < SOUND_LENGTH; ++i) {\n        int j = sounds[i].block_index;\n        if (j > 0) {\n            res += INSTRUMENT(blocks[j].freq, sounds[i].t);\n        }\n    }\n    return res;\n}","name":"Sound","description":"","type":"sound"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// #define VSCODE\n\n#ifdef VSCODE\n#iChannel0 \"self\"\n#include \"common.glsl\"\n#endif\n\n#ifdef VSCODE\n#iKeyboard\nfloat getKey(int key_code) {\n    return float(isKeyDown(key_code));\n}\n#else\nfloat getKey(int key_code) {\n    return texelFetch(iChannel1, ivec2(key_code, 0), 0).x;\n}\n#endif\n\n// #define FUCK_GLSL(i) \n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 coord = ivec2(fragCoord);\n\n    // if (coord.y != 0) {\n    //     return;\n    // }\n\n    // GameData data = unpack(iChannel0, iFrame);\n    int progress;\n    float block_offset;\n    float start_time;\n    float end_time;\n    int wrong_track;\n    float key_can_trigger[4];\n    Sound sounds[SOUND_LENGTH];\n\n    vec4 data[DATA_LENGTH_A + DATA_LENGTH_B];\n    for (int i = 0; i < DATA_LENGTH_A + DATA_LENGTH_B; ++i) {\n        data[i] = texelFetch(iChannel0, ivec2(i, 0), 0);\n    }\n\n    progress = floatBitsToInt(data[0].x);\n    block_offset = data[0].y;\n    start_time = data[0].z;\n    end_time = data[0].w;\n\n    wrong_track = floatBitsToInt(data[1].x);\n    // int i_key_down = floatBitsToInt(data[0].z);\n    key_can_trigger[0] = data[2].x;\n    key_can_trigger[1] = data[2].y;\n    key_can_trigger[2] = data[2].z;\n    key_can_trigger[3] = data[2].w;\n\n    for (int i = 0; i < DATA_LENGTH_B; ++i) {\n        vec4 d = data[DATA_LENGTH_A + i];\n        sounds[i * 2] = Sound(floatBitsToInt(d.x), d.y);\n        sounds[i * 2 + 1] = Sound(floatBitsToInt(d.z), d.w);\n    }\n\n    float key_down[4];\n    key_down[0] = getKey(Key_Z);\n    key_down[1] = getKey(Key_X);\n    key_down[2] = getKey(Key_C);\n    key_down[3] = getKey(Key_V);\n\n    float key_triggered[4];\n    key_triggered[0] = key_can_trigger[0] * key_down[0];\n    key_triggered[1] = key_can_trigger[1] * key_down[1];\n    key_triggered[2] = key_can_trigger[2] * key_down[2];\n    key_triggered[3] = key_can_trigger[3] * key_down[3];\n\n    key_can_trigger[0] = 1.0 - key_down[0];\n    key_can_trigger[1] = 1.0 - key_down[1];\n    key_can_trigger[2] = 1.0 - key_down[2];\n    key_can_trigger[3] = 1.0 - key_down[3];\n\n    if (iFrame < 5) {\n        progress = 0;\n        block_offset = 0.0;\n        start_time = -1.0;\n        end_time = -1.0;\n        wrong_track = -1;\n        key_can_trigger = float[4](1.0, 1.0, 1.0, 1.0);\n\n        sounds = Sound[SOUND_LENGTH](DEFAULT_SOUND, DEFAULT_SOUND, DEFAULT_SOUND, DEFAULT_SOUND, DEFAULT_SOUND, DEFAULT_SOUND);\n    }\n    // data.key_down = key_down;\n    // bool need_update = ;\n    // float next_dir, next_dist, next_shape, next_radius;\n    // bool space_down = getKey(Key_Space) > 0.0;\n    // bool space_released = force > 0.0 && !space_down;\n    // bool flying = length(velocity) > 0.0;\n\n    // Sound lru;\n    if (block_offset > 0.0 || end_time > 0.0) {\n        block_offset = max(0.0, block_offset - iTimeDelta * BLOCK_SLIDE_SPEED);\n\n    }\n\n    for (int i = 0; i < SOUND_LENGTH; ++i) {\n        if (sounds[i].block_index >= 0) {\n            sounds[i].t += iTimeDelta;\n            // if (sounds[i].t <= 0.0) {\n            //     sounds[i].block_index = -1;\n            // }\n        }\n    }\n    // fragColor = vec4(1.0, 0.5, 0.2, 1.0);\n\n    // Sound s[6] = Sound[SOUND_LENGTH](DEFAULT_SOUND, DEFAULT_SOUND, DEFAULT_SOUND, DEFAULT_SOUND, DEFAULT_SOUND, DEFAULT_SOUND);\n\n    // for (int j = 0; j < SOUND_LENGTH; ++j) {\n    //     if (s[j].t < lru_t) {\n    //         lru_index = j;\n    //         lru_t = s[j].t;\n    //         break;\n    //     }\n    // }\n    // if (progress < BLOCK_SIZE) {}\n    if (end_time < 0.0) {\n        for (int i = 0; i < 4; ++i) {\n            bool triggered = key_triggered[i] > 0.5;\n            if (triggered) {\n                if (progress == 0) {\n                    start_time = iTime;\n                }\n\n                if (blocks[progress].track == i) {\n                    ++progress;\n                    block_offset += BLOCK_HEIGHT;\n\n                    int lru_index = -1;\n                    float lru_t = -1.0;\n\n                    for (int j = 0; j < SOUND_LENGTH; ++j) {\n                        if (sounds[j].block_index < 0) {\n                            lru_index = j;\n                            break;\n                        }\n                        if (sounds[j].t > lru_t) {\n                            lru_index = j;\n                            lru_t = sounds[j].t;\n                        }\n                    }\n\n                    sounds[lru_index].block_index = i;\n                    sounds[lru_index].t = 0.0;\n\n                    if (progress == BLOCK_SIZE) {\n                        end_time = iTime;\n                    }\n                } else {\n                    end_time = iTime;\n                    wrong_track = i;\n                }\n\n                break;\n            }\n        }\n    }\n\n    if (coord.y == 0) {\n        if (coord.x == 0) {\n            fragColor = vec4(intBitsToFloat(progress), block_offset, start_time, end_time);\n\n        } else if (coord.x == 1) {\n            fragColor = vec4(intBitsToFloat(wrong_track), 0.0, 0.0, 0.0);\n\n        } else if (coord.x == 2) {\n            fragColor = vec4(key_can_trigger[0], key_can_trigger[1], key_can_trigger[2], key_can_trigger[3]);\n\n        } else if (coord.x < DATA_LENGTH_A + DATA_LENGTH_B) {\n            int i = 2 * (coord.x - DATA_LENGTH_A);\n            vec4 res;\n            res.x = intBitsToFloat(sounds[i].block_index);\n            res.y = sounds[i].t;\n            res.x = intBitsToFloat(sounds[i + 1].block_index);\n            res.y = sounds[i + 1].t;\n            fragColor = res;\n        }\n    } else {\n        fragColor = vec4(1.0, 0.5, 0.2, key_triggered[0]);\n        // fragColor = vec4(float(progress) / 22.0, 0.5, 0.2, 1.0);\n    }\n    // float lru_t = BLOCK_SOUND_DUR + 1.0;\n\n    // while (j < 6) {\n    //     if (data.sounds[j].t < abc.t) {\n    //         euhfi = j;\n    //         abc = data.sounds[j];\n    //     }\n    //     j++;\n    // }\n    // for (int j = 0; j < SOUND_LENGTH; j++) {\n    //     if (data.sounds[j].t < abc.t) {\n\n    //     }\n    // }\n    // data.sounds[euhfi].block_index = 1;\n\n    // fragColor = pack(coord, data);\n\n    // if (coord.y > 1) {\n    //     fragColor = vec4(1.0, 0.5, 0.2, 1.0);\n    // }\n    // fragColor = vec4(vec3(float(x) / 6.0), 1.0);\n\n    // if (coord.x == 0) {\n    //     fragColor.xyz = player_pos;\n    //     fragColor.w = force;\n    // } else if (coord.x == 1) {\n    //     fragColor.xyz = velocity;\n    // } else if (coord.x == 2) {\n    //     fragColor.x = last_jump_tick;\n    //     fragColor.y = last_land_tick;\n    //     fragColor.zw = dir_vec;\n    // } else if (coord.x == 3) {\n    //     fragColor.xy = stack_pos[0];\n    //     fragColor.z = intBitsToFloat(shape[0]);\n    //     fragColor.w = radius[0];\n    // } else if (coord.x == 4) {\n    //     fragColor.xy = stack_pos[1];\n    //     fragColor.z = intBitsToFloat(shape[1]);\n    //     fragColor.w = radius[1];\n\n    // } else if (coord.x == 5) {\n    //     fragColor.xy = stack_pos[2];\n    //     fragColor.z = intBitsToFloat(shape[2]);\n    //     fragColor.w = radius[2];\n    // }\n        //  else if (coord.x == 5) {\n\n        // } else if (coord.x == 6) {\n\n        // }\n\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Game Setting\n//------------------------------------------------------------------\n// #define SHAPE_BOX 0\n// #define SHAPE_CYLINDER 1\n// #define SHAPE_MAX 2\n\n// #define L vec2(-1.0, 0.0)\n// #define R vec2(1.0, 0.0)\n// #define T vec2(0.0, 1.0)\n// #define B vec2(0.0, -1.0)\n\n// #define STACK_HEIGHT 0.2\n// #define CHECK_LENGTH 0.05\n// #define VELOCITY_Y 3.0\n// #define VELOCITY_H 1.0\n// #define FORCE_ACCL 2.0\n// #define RIPPLE_SPEED 0.8\n// #define RIPPLE_WIDTH 0.05\n// #define SWEET_POINT 0.03\n#define INSTRUMENT bassTromboneSound\n\n#define BLOCK_HEIGHT 0.25\n#define BLOCK_HEIGHT_H 0.125\n#define BLOCK_WIDTH 0.1\n#define BLOCK_SLIDE_SPEED 0.8\n#define BLOCK_SOUND_DUR 0.5\n#define BLOCK_SIZE 12\n#define WRONG_SHIN_DUR 0.8\n#define WRONG_SHIN_DUR_H 0.4\n\n#define FONT_COLOR vec3(1.0, 0.0, 0.0)\n#define FONT_SCALE (1.0 / 10.0)\n#define FONT_GUTTER 0.4\n\n#define A Block(0.0, 0)\n#define B Block(0.0, 1)\n#define C Block(0.0, 2)\n#define D Block(0.0, 3)\n#define DEFAULT_SOUND Sound(-1, 0.0)\n\n#define DATA_LENGTH_A 3\n#define DATA_LENGTH_B 3\n#define SOUND_LENGTH (DATA_LENGTH_B * 2)\n\n#define DEBUG\n\n#ifdef DEBUG\n\n#define TIME_SCALE 1.0\n\n#define iTime (iTime * TIME_SCALE)\n#define iTimeDelta (iTimeDelta * TIME_SCALE)\n#endif\n\nstruct Block {\n    float freq;\n    int track;\n};\n\nconst Block blocks[BLOCK_SIZE] = Block[BLOCK_SIZE](A, B, C, D, A, B, C, D, A, B, C, D);\n\nstruct Sound {\n    int block_index;\n    float t;\n};\n\n//------------------------------------------------------------------\n\n// keyboard stuff\n//------------------------------------------------------------------\n#define Key_Space 32\n#define Key_Z 90\n#define Key_X 88\n#define Key_C 67\n#define Key_V 86\n//------------------------------------------------------------------\n\n// Sound\n//------------------------------------------------------------------\nconst float C4 = 261.63;\nconst float D4 = 293.66;\nconst float E4 = 329.63;\nconst float F4 = 349.23;\nconst float G4 = 392.00;\nconst float A4 = 440.00;\nconst float B4 = 493.88;\nconst float C5 = 523.25;\n\n//D44 means D#4\nconst float D44 = 311.3;\nconst float B3 = 246.94;\nconst float A33 = 233.08;\nconst float A3 = 220.00;\nconst float G33 = 207.65;\nconst float C44 = 277.18;\nconst float G44 = 415.30;\nconst float F44 = 369.99;\nconst float G22 = 103.83;\nconst float G11 = 51.91;\nconst float B2 = 123.47;\nconst float B1 = 61.74;\nconst float C33 = 138.59;\nconst float C22 = 69.3;\nconst float D2 = 73.42;\nconst float D3 = 146.83;\nconst float D33 = 155.56;\nconst float D55 = 622.25;\nconst float D22 = 77.78;\nconst float F33 = 185.0;\nconst float G55 = 830.61;\nconst float G66 = 1661.22;\nconst float C66 = 1108.73;\nconst float D66 = 1244.51;\nconst float F66 = 1479.98;\nconst float F55 = 739.99;\nconst float B6 = 1975.53;\nconst float A66 = 1864.66;\nconst float B5 = 987.77;\nconst float A55 = 932.33;\nconst float A44 = 466.16;\nconst float C55 = 554.37;\n\nvec2 bassTromboneSound(float noteFreq, float noteTime) {\n    noteFreq *= 0.25;\n    float y = 0.6 * sin(6.2831 * 0.5 * noteFreq * noteTime) * exp(-0.002 * noteFreq * noteTime);\n    y += 0.3 * sin(6.2831 * 1.0 * noteFreq * noteTime) * exp(-0.002 * noteFreq * noteTime);\n    y += 0.2 * sin(6.2831 * 1.5 * noteFreq * noteTime) * exp(-0.002 * noteFreq * noteTime);\n    y *= smoothstep(0.0, 0.1, noteTime) * (1.0 - smoothstep(0.8, 1.5, noteTime));\n    return vec2(y);\n}\n\nvec2 clarinetSound(float noteFreq, float noteTime) {\n    float y = 1.0 * sin(6.2831 * 1.00 * noteFreq * noteTime) * exp(-0.0008 * noteFreq * noteTime);\n    y += 0.7 * sin(6.2831 * 0.50 * noteFreq * noteTime) * exp(-0.0008 * noteFreq * noteTime);\n    y += 0.5 * sin(6.2831 * 0.25 * noteFreq * noteTime) * exp(-0.0008 * noteFreq * noteTime);\n    y *= smoothstep(0.0, 0.2, noteTime) * (1.0 - smoothstep(1.0, 2.0, noteTime));\n    return vec2(y);\n}\n\nvec2 pianoSound(float freq, float time) {\n    freq /= pow(2.0, 1.0 / 1.0);\n    float ph = 1.0;\n    ph *= sin(6.283185 * freq * time * 2.0);\n    ph *= 0.5 + 0.5 * max(0.0, 5.0 - 0.01 * freq);\n    ph *= exp(-time * freq * 0.2);\n\n    float y = 0.0;\n    y += 0.70 * sin(1.00 * 6.283185 * freq * time + ph) * exp2(-0.7 * 0.007 * freq * time);\n    y += 0.20 * sin(2.01 * 6.283185 * freq * time + ph) * exp2(-0.7 * 0.011 * freq * time);\n    y += 0.20 * sin(3.01 * 6.283185 * freq * time + ph) * exp2(-0.7 * 0.015 * freq * time);\n    y += 0.16 * sin(4.01 * 6.283185 * freq * time + ph) * exp2(-0.7 * 0.018 * freq * time);\n    y += 0.13 * sin(5.01 * 6.283185 * freq * time + ph) * exp2(-0.7 * 0.021 * freq * time);\n    y += 0.10 * sin(6.01 * 6.283185 * freq * time + ph) * exp2(-0.7 * 0.027 * freq * time);\n    y += 0.09 * sin(8.01 * 6.283185 * freq * time + ph) * exp2(-0.7 * 0.030 * freq * time);\n    y += 0.07 * sin(9.01 * 6.283185 * freq * time + ph) * exp2(-0.7 * 0.033 * freq * time);\n\n    y += 0.35 * y * y * y;\n    y += 0.10 * y * y * y;\n\n    y *= 1.0 + 1.5 * exp(-8.0 * time);\n    y *= clamp(time / 0.004, 0.0, 1.0);\n\n    y *= 2.5 - 1.5 * clamp(log2(freq) / 10.0, 0.0, 1.0);\n\n    float modulation = sin(6.283185 * 0.5 * freq * time);\n    y += 0.1 * sin(6.283185 * 1.5 * freq * time + modulation) * exp2(-0.7 * 0.007 * freq * time);\n    y += 0.08 * sin(6.283185 * 2.5 * freq * time + modulation) * exp2(-0.7 * 0.009 * freq * time);\n    y += 0.06 * sin(6.283185 * 3.5 * freq * time + modulation) * exp2(-0.7 * 0.011 * freq * time);\n\n    return vec2(y);\n}\n\nvec2 pianoWithPedal(float freq, float time) {\n    vec2 y = pianoSound(freq, time);\n    float pedalEffect = smoothstep(0.0, 0.5, mod(time, 3.0));\n    y *= 1.0 + 0.8 * pedalEffect;\n\n    return y;\n}\n\nvec2 fluteSound(float noteFreq, float noteTime) {\n    float y = 0.6 * sin(6.2831 * noteFreq * noteTime) * exp(-0.0015 * noteFreq * noteTime);\n    y += 0.4 * sin(6.2831 * noteFreq * noteTime * 2.0) * exp(-0.0015 * noteFreq * noteTime);\n    y += 0.2 * sin(6.2831 * noteFreq * noteTime * 3.0) * exp(-0.0015 * noteFreq * noteTime);\n    y *= smoothstep(0.0, 0.2, noteTime) * (1.0 - smoothstep(1.0, 2.0, noteTime));\n    return vec2(y);\n}\n\nvec2 yangqinSound(float noteFreq, float noteTime) {\n    noteFreq *= pow(1.5, 1.2);\n    float y = 0.8 * sin(6.2831 * noteFreq * noteTime) * exp(-0.005 * noteTime);\n    y += 0.5 * sin(6.2831 * 2.0 * noteFreq * noteTime) * exp(-0.005 * noteTime);\n    y += 0.3 * sin(6.2831 * 4.0 * noteFreq * noteTime) * exp(-0.005 * noteTime);\n    y *= smoothstep(0.0, 0.02, noteTime) * (1.0 - smoothstep(0.05, 0.1, noteTime));\n    return vec2(y);\n}\n//------------------------------------------------------------------\n\n// random\n//------------------------------------------------------------------\n// [0.0, 1.0)\nfloat random(in vec2 _st) {\n    return fract(sin(dot(_st.xy, vec2(12.246334, 78.34534))) *\n        4346.23643);\n}\n\n// [min, high)\nint randint(in vec2 _st, int low, int high) {\n    return int(random(_st) * float(high - low)) + low;\n}\n//------------------------------------------------------------------\n\n// constant\n//------------------------------------------------------------------\n#define PI 3.1415926\n#define PI2 6.2831852\n//------------------------------------------------------------------\n\n// rendering & modeling\n//------------------------------------------------------------------\nstruct Material {\n    vec3 albedo;\n    float roughness;\n    float metallic;\n};\n\nstruct Surface {\n    float d;\n    Material mat;\n};\n\nSurface surf_op_union(Surface s1, Surface s2) {\n    if (s1.d < s2.d) {\n        return s1;\n    } else {\n        return s2;\n    }\n}\n\nSurface surf_op_sub(Surface s1, Surface s2) {\n    s2.d *= -1.0;\n    if (s1.d > s2.d) {\n        return s1;\n    } else {\n        return s2;\n    }\n}\n\nSurface surf_op_smooth_union(Surface s1, Surface s2, float k) {\n    float h = clamp(0.5 + 0.5 * (s2.d - s1.d) / k, 0.0, 1.0);\n\n    vec3 p1 = vec3(s1.d, s1.mat.roughness, s1.mat.metallic), p2 = vec3(s2.d, s2.mat.roughness, s2.mat.metallic);\n    p1 = mix(p2, p1, h) - k * h * (1.0 - h);\n\n    s1.mat.albedo = mix(s2.mat.albedo, s1.mat.albedo, h) - k * h * (1.0 - h);\n    s1.d = p1.x;\n    s1.mat.roughness = p1.y;\n    s1.mat.metallic = p1.z;\n    return s1;\n}\n\nSurface surf_op_smooth_sub(Surface s1, Surface s2, float k) {\n    float h = clamp(0.5 - 0.5 * (s2.d + s1.d) / k, 0.0, 1.0);\n    vec3 p1 = vec3(s1.d, s1.mat.roughness, s1.mat.metallic), p2 = vec3(s2.d, s2.mat.roughness, s2.mat.metallic);\n    p1 = mix(p2, -p1, h) + k * h * (1.0 - h);\n\n    s1.mat.albedo = mix(s2.mat.albedo, s1.mat.albedo, h) - k * h * (1.0 - h);\n    s1.d = p1.x;\n    s1.mat.roughness = p1.y;\n    s1.mat.metallic = p1.z;\n    return s1;\n}\n\nSurface surf_op_smooth_intersection(Surface s1, Surface s2, float k) {\n    float h = clamp(0.5 - 0.5 * (s2.d - s1.d) / k, 0.0, 1.0);\n    vec3 p1 = vec3(s1.d, s1.mat.roughness, s1.mat.metallic), p2 = vec3(s2.d, s2.mat.roughness, s2.mat.metallic);\n    p1 = mix(p2, p1, h) + k * h * (1.0 - h);\n\n    s1.mat.albedo = mix(s2.mat.albedo, s1.mat.albedo, h) - k * h * (1.0 - h);\n    s1.d = p1.x;\n    s1.mat.roughness = p1.y;\n    s1.mat.metallic = p1.z;\n    return s1;\n}\n\nfloat op_union(float d1, float d2) {\n    return min(d1, d2);\n}\n\nfloat op_inter(float d1, float d2) {\n    return max(d1, d2);\n}\n\nfloat op_sub(float d1, float d2) {\n    return max(d1, -d2);\n}\n\nfloat op_smooth_union(float d1, float d2, float k) {\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat op_smooth_subtraction(float d1, float d2, float k) {\n    float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n    return mix(d2, -d1, h) + k * h * (1.0 - h);\n}\n\nfloat op_smooth_intersection(float d1, float d2, float k) {\n    float h = clamp(0.5 - 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) + k * h * (1.0 - h);\n}\n//------------------------------------------------------------------\n\n// 2d sdf\n//------------------------------------------------------------------\nfloat sdCircle(vec2 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdBox(in vec2 p, in vec2 b) {\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\n//------------------------------------------------------------------\nvec3 Tonemap_ACES(const vec3 x) {\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n//------------------------------------------------------------------","name":"Common","description":"","type":"common"}]}