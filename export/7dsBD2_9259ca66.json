{"ver":"0.1","info":{"id":"7dsBD2","date":"1651604491","viewed":221,"name":"Empty Universe","username":"Wildric","description":"You saw an empty moon, you decided to land there with your ship and meditate...Alone... In a beautiful and empty universe...","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","space","universe"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 10000\n#define MAX_DISTANCE 1000.0\n#define MIN_DISTANCE 0.000001\n\n\n#define Nebula 30.0\n#define NebIntensity 4.0\n#define stars 600.0\n#define colIntensity vec3(1.5,.5,1.0)\n\n\nfloat rand(vec2 uv) {\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat noise(vec2 uv, float freq) {\n    uv *= freq;\n    vec2 fractional = fract(uv);\n    vec2 integer = floor(uv);\n    fractional = fractional*fractional*(3.0-2.0*fractional);\n    vec2 down = vec2( rand(integer), rand(integer + vec2(1.0, 0.0)) );\n    vec2 up = vec2( rand(integer + vec2(0.0,1.0)), rand(integer + vec2(1.0, 1.0)) );\n    float x = mix(down.x, down.y, fractional.x);\n    float y = mix(up.x, up.y, fractional.x);\n    return mix(x,y, fractional.y);\n}\n\n\nvec3 perlin(vec2 uv, float amplitudeMul, float freqMul,float amplitude, float freq)  {\n    vec3 col = vec3(noise(uv, 10.0)*10.0);\n    float total = amplitude;\n    for (int i = 0; i<10; i++) {\n        freq *= freqMul;\n        amplitude *= amplitudeMul;\n        col += vec3(noise(uv, freq)*amplitude);\n        total += amplitude;\n    }\n    col/= total;\n    return col;\n}\n\n\nfloat ThreeMin(float f, float sec, float third) {\n    return min(f, min(sec,third));\n}\n\nvec4 sphere = vec4(100.0,-.5, 10, 2);\nvec4 sphere1 = vec4(100,1,5,0.4);\n    \nfloat GetDistance(vec3 point, inout int isSphere) {\n\n    vec3 background = vec3(0.0,0.0,10.0);\n    float a = iTime;\n    float b = 2.0;\n    int animeTime = 1;\n    float time = float(int(iTime)%animeTime);\n    time += fract(iTime);\n    float sDistance = length(point - sphere.xyz) -  sphere.w;\n    float sDistance1 = abs(point.z-background.z);\n    //plane at 0,0,0\n    \n    float pDistance = point.y - 1.5 * perlin(point.xz,2.0,0.5,5.,400.0).x;\n    \n    \n    if (ThreeMin(pDistance,sDistance, sDistance1) == sDistance) {\n        isSphere = 1;\n    }\n    else if (ThreeMin(pDistance,sDistance, sDistance1) == sDistance1) {\n       isSphere = 2;\n    }\n    else isSphere = 0;\n    return ThreeMin(pDistance,sDistance, sDistance1);\n    \n    \n}\nfloat RayMarching(vec3 origin, vec3 direction, inout int isSphere) {\n    float dis = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 temp = origin + direction * dis;\n        float d = GetDistance(temp, isSphere);\n        dis += d;\n        if (dis > MAX_DISTANCE || d < MIN_DISTANCE) break;\n    }\n    return dis;\n\n}\n\nvec3 GetNormal(vec3 p, float EPSILON) {\n    int none = 0;\n    EPSILON = 0.01;\n    return normalize(vec3(\n        GetDistance(vec3(p.x + EPSILON, p.y, p.z),none) - GetDistance(vec3(p.x - EPSILON, p.y, p.z), none),\n        GetDistance(vec3(p.x, p.y + EPSILON, p.z),none) - GetDistance(vec3(p.x, p.y - EPSILON, p.z), none),\n        GetDistance(vec3(p.x, p.y, p.z  + EPSILON), none) - GetDistance(vec3(p.x, p.y, p.z - EPSILON), none)\n    ));\n}\n//That's a mess, I just got the first raymarcher and my last shader to make this\n\nfloat GetLight(vec3 p)\n{\n    vec3 lightPos = vec3(0.0, 10.0, 20.0);\n    vec3 lightDir = normalize(p - lightPos);\n    return -dot(GetNormal(p,0.0000001), lightDir);    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5* iResolution.xy)/iResolution.y;\n    vec3 origin = vec3(0,1.0,0);\n    vec3 direction = normalize(vec3(uv.x, uv.y, 1));\n    int isSphere = 0;\n    float ray= RayMarching( origin, direction, isSphere);\n    vec3 color = vec3(0.3,0.1,0.0);\n    \n    vec3 p = (origin + direction*ray);\n    \n    vec3 col = vec3(GetLight(p));\n    \n    /* LAYERS: \n        1: sphere1\n        2: background\n        3:\n    */\n    if (isSphere == 1) {\n        vec2 co = uv;\n        vec3 normal = GetNormal(p, 0.0001);\n        \n        vec3 vec1 = normalize(vec3(normal.x,0.0,normal.z));\n        vec3 vector2 = normalize(vec3(0.0,normal.y,normal.z));\n        vec1 = normalize((vec1-vec3(0.5,0.0,0.5))/0.5);\n        vector2 = normalize((vector2-vec3(0.0,0.5,0.5))/0.5);\n\n        \n        float productX = dot( vec1, vec3(0, 0, -1) );\n        float sX = sign(cross( vec1, vec3(0, 0, -1)).y);\n        float productY = dot(  vector2, vec3(0, 0, -1) );\n        float sY = sign(cross( vector2, vec3(0, 0, -1)).x);\n        if (sX <  0.0) {\n            co.x = productX*0.5;\n        }\n        \n        if (sX>=0.0) {\n            co.x = -productX*0.5+1.0;\n        }\n        \n        if (sY >  0.0) {\n            co.y = productY*0.5;\n        }\n        \n        if (sY<=0.0) {\n            co.y = -productY*0.5+1.0;\n        }\n        \n        //col *= texture(iChannel0, co).xyz;\n        //col = vec3(1.0);\n       }\n    else if (isSphere == 2) {\n            vec2 uv1 = fragCoord/iResolution.xy;\n            vec3 r = perlin(uv1, 0.5, 2.0, 100.0, 3.0)*colIntensity.r; //arbitrary values in perlin function to generate \"galatical\" colors\n            vec3 g = perlin(uv1+0.1, 0.5, 2.0, 100.0, 3.0)*colIntensity.g;\n            vec3 b = perlin(uv1 + 0.5, 0.5, 4.0, 100.0, 1.0)*colIntensity.b;\n            float fade = pow(length(perlin(uv1-0.1, 0.6, 2.0, 10.,10.0)),NebIntensity)*Nebula;\n            col = vec3(length(r),length(g), length(b))/sqrt(3.0);\n            vec3 sky = vec3(pow(rand(uv1), stars));\n            sky += col/fade;\n        \n            col = 0.8*sky;\n    \n    }\n    else {\n        col *= texture(iChannel1, fract(p.xz*1.0)).xyz;\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}