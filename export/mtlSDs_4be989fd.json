{"ver":"0.1","info":{"id":"mtlSDs","date":"1675513982","viewed":71,"name":"Simple Clouds with Noise","username":"patrickhartono","description":"Simple Clouds","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["clouds"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\nThe MIT License\n\nCopyright Â© 2023 Patrick Hartono\n\nPermission is hereby granted, free of charge, to any person obtaining \na copy of this software and associated documentation files (the \"Software\"), \nto deal in the Software without restriction, including without limitation \nthe rights to use, copy, modify, merge, publish, distribute, sublicense, \nand/or sell copies of the Software, and to permit persons to whom the Software \nis furnished to do so, subject to the following conditions: \nThe above copyright notice and this permission notice shall be included in \nall copies or substantial portions of the Software. \nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, \nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF \nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. \nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, \nDAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, \nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH \nTHE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n*/\n\n\n\n// Utility function to generate a random value for a given 2D coordinate\nfloat hash(vec2 n) { \n  // Calculates a random value using the dot product of the coordinate and a constant seed value\n  return fract(sin(dot(n, vec2(12.9898, 78.233))) * 43758.5453); \n}\n\n// The Simplex noise function\nfloat noise(vec2 n)\n{\n    // Calculate the integer coordinate values for the current coordinate\n    vec2 i = floor(n);\n    // Calculate the fractional component of the coordinate\n    vec2 f = fract(n);\n\n    // Calculate the random values for each of the 4 corners of the grid cell\n    float a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    // Interpolate between the values using a smoothstep-like function\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    // Interpolate horizontally and then vertically to get the final noise value\n    float res = mix(a, b, u.x);\n    res = mix(res, mix(c, d, u.x), u.y);\n    return res;\n}\n\n// Fractal Brownian Motion (fbm) function\nfloat fbm(vec2 n)\n{\n    // Initialize the total, starting amplitude, and number of octaves\n    float total = 0.0, amplitude = 1.0;\n    for(int i = 0; i < 5; i++)\n    {\n        // Add each octave of noise to the total, scaling the amplitude and frequency\n        total += noise(n) * amplitude;\n        n = n * 2.0;\n        amplitude *= 0.5;\n    }\n    return total;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Calculate the UV coordinate for the current pixel\n    vec2 uv = fragCoord.xy / iResolution.xy - 0.5;\n    // Correct aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Calculate the elapsed time\n    float time = iTime * 0.3;\n    // Offset the noise coordinate based on the elapsed time\n    vec2 noiseCoord = vec2(uv.x + time * 0.5, uv.y + time * 0.5);\n    // Calculate the noise value for the current coordinate\n    float n = fbm(noiseCoord);\n    // Set the color of the pixel to white, with brightness controlled by the noise value\n    fragColor = vec4(vec3(1.0, 1.0, 1.0) * n, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}