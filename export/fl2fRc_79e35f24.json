{"ver":"0.1","info":{"id":"fl2fRc","date":"1652880656","viewed":46,"name":"test nr. 2","username":"DLG03","description":"just a test, nothing fancy","likes":0,"published":1,"flags":16,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Player stuff\nvec3 playerPosition = vec3(0.0, 1.0, 0.0);\nvec3 playerDirection = vec3(0.0);\n\n//Object properties and structs\n\nvec3 backgroundColor = vec3(0.5, 0.6, 0.8);\n\nconst int nrOfObjects = 4;\n\nstruct Object {\n    int type;\n    vec3 center;\n    float size;\n    vec3 color;\n    int id;  \n};\n\nObject objects[nrOfObjects] = Object[nrOfObjects](\n    Object(0, vec3(3.0, 4.0, 0.0), 1.2,  vec3(0.3, 0.7, 0.3), 0),\n    Object(0, vec3(3.0, 6.0, 0.0), 1.2,  vec3(0.3, 0.6, 0.3), 1),\n    Object(0, vec3(3.0, 2.0, 0.0), 1.2,  vec3(0.3, 0.5, 0.3), 2),\n    Object(1, vec3(0.0, 0.0, 0.0), 90.0, vec3(0.858, 0.458, 0.458), 3)\n);\n\n// Sunlight\nstruct Sunlight {\n    vec3 direction;\n    vec3 color;\n};\n\nSunlight sunlight = Sunlight(\n     normalize(vec3(0.0, 1.0, 1.0)),\n     vec3(1.0, 1.0, 1.0)\n);\n\n// Ray and shadow properties\nfloat max_distance = 100.0;\nfloat min_distance = 0.01;\nint max_marching_steps = 80;\n\nfloat max_shadow_distance = 50.0;\nfloat min_shadow_distance = 0.01;\nint max_shadow_steps = 40;\n\n// Collision struct\n\nstruct Collision {\n    float distance;\n    vec3 color;\n    int objectID;\n};\n\n// END\n\nfloat sphereDistance(vec3 rayPosition, vec3 center, float radius) {\n    return length(rayPosition - center) - radius;\n}\n\nfloat planeDistance(vec3 rayPosition, vec3 center, float sideLength){\n\tvec3 q = abs(rayPosition-center) - vec3(sideLength, 0.01, sideLength);\n\treturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nCollision distanceObject (vec3 rayPosition, Object object) {\n    switch(object.type) {\n        case 0: // Sphere\n            return Collision(sphereDistance(rayPosition, object.center, object.size), object.color, object.id); \n        case 1: // Plane\n            return Collision(planeDistance(rayPosition, object.center, object.size), object.color, object.id);\n    }\n}\n\nCollision closestObject(vec3 rayPosition) {\n    Collision collision = Collision(max_distance, backgroundColor, -1);\n\n    for(int i = 0; i < nrOfObjects; i++) {\n        Collision currentCollision = distanceObject(rayPosition, objects[i]);\n        if(currentCollision.distance < collision.distance) {\n            collision = currentCollision;\n        }\n    }\n    return collision;\n}\n\nvec3 getNormal(vec3 rayPosition, Object object) {\n    switch(object.type) {\n        case 0: // Sphere\n            return normalize(rayPosition - object.center); \n        case 1: // Plane\n            // Not finished yet\n            if(rayPosition.y + 0.05 > object.center.y) {\n                return vec3(0.0, 1.0, 0.0);\n            }\n            else if (rayPosition.y - 0.05 < object.center.y) {\n                return vec3(0.0, -1.0, 0.0);\n            }\n        /* \n        case 2: //Torus\n        For more complex shapes, a derivative function needs to be added\n        */\n        \n    } \n}\nvec3 shadowMarching(vec3 from, vec3 direction, vec3 color) {\n    vec3 colorResult = color;\n    float totalDistance = 0.0;\n    vec3 rayPosition = from;\n    Collision fromCollision = closestObject(rayPosition);\n    min_distance = fromCollision.distance;\n    \n    \n    Collision collision;\n    \n    for(int steps = 0; steps < max_shadow_steps; steps++) {\n        collision = closestObject(rayPosition);\n        totalDistance += collision.distance;\n        rayPosition = from + totalDistance * direction;\n        \n        if(totalDistance > max_shadow_distance) {\n            return colorResult;\n        }\n        \n        // This extra if statement to help the ray escape the SDF of current object\n        else if (collision.distance < min_distance * 0.5) {\n            return colorResult * 0.3;\n        }\n    }\n    return colorResult;\n}\n\nvec3 marching(vec3 from, vec3 direction) {\n    vec3 colorResult = backgroundColor;\n    float totalDistance = 0.0;\n    vec3 rayPosition = from;\n    Collision collision;\n\n    for(int steps = 0; steps < max_marching_steps; steps++) {\n         collision = closestObject(rayPosition);\n         totalDistance += collision.distance;\n         rayPosition = from + totalDistance * direction;\n         if(totalDistance > max_distance) {\n             colorResult = backgroundColor;\n         }\n         if(collision.distance < min_distance) {\n             Object object = objects[collision.objectID];\n             \n             // Compute shadow after hit with object\n             \n             colorResult = collision.color;\n             colorResult = shadowMarching(rayPosition, sunlight.direction, colorResult);\n             return colorResult;\n         }\n    }\n    return colorResult;\n}\n\nvec4 updateTrigValues(vec2 angle) {\n    return vec4(sin(angle.x), cos(angle.x), sin(angle.y), cos(angle.y));\n}\n\nvec3 rayDirection(vec4 trVal, vec2 fragCoord) {\n    playerDirection = vec3(trVal.y * trVal.w, trVal.z, trVal.x * trVal.w);\n    vec3 pDirRight = vec3(-trVal.x, 0.0, trVal.y);\n    vec3 pDirUp = vec3(-trVal.y * trVal.z, trVal.w, -trVal.x * trVal.z);\n    \n    vec2 offset = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    offset.x *= 1.69;\n    \n    return normalize(playerDirection + pDirUp * offset.y + pDirRight * offset.x);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    vec2 angle;\n    angle.x = radians(180.0) * iMouse.x * 0.005;\n    angle.y = radians(180.0) * iMouse.y * 0.003;\n    \n    \n    playerPosition = vec3(0.0, 1.0, 0.0);\n    playerPosition.x += texelFetch(iChannel0, ivec2(11, 1), 0).x;\n    \n    vec4 trigValues = updateTrigValues(angle);\n    \n    vec3 dir = rayDirection(trigValues, fragCoord);\n    vec3 color = marching(playerPosition, dir);\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}