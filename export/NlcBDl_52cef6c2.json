{"ver":"0.1","info":{"id":"NlcBDl","date":"1663776067","viewed":70,"name":"Ray Marching balls","username":"killbyte","description":"Basic ray marcher","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","lambert"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_MARCHING_STEPS 2550\n#define EPSILON 0.0001\n#define MIN_DIST 0.0\n#define MAX_DIST 100.0\n\nfloat cycle_dist(float dist, float stride) {\n    return mod(dist + stride/2.f, stride) - stride/2.f;\n}\n\nfloat sphere_sdf(vec3 position, vec3 sphere_position, float radius)\n{\n    // position.x = cycle_dist(clamp(position.x, -3.9f, 3.9f), 2.5f);\n    // position.y = cycle_dist(clamp(position.y, -3.9f, 3.9f), 2.5f);\n    // radius = 0.5 + 0.3*sin(position.y*2.0);\n    return length(position - sphere_position) - radius;\n}\n\nfloat smooth_min(float a, float b, float k)\n{\n    return -(log(exp(k * -a) + exp(k * -b)) / k);\n}\n\nfloat scene_sdf(vec3 position)\n{\n    // // Combine distances\n    // return smooth_min(\n    //     sphere_sdf(position, vec3(1,0,-5), 1.f),\n    //     sphere_sdf(position, vec3(-1,0,-5), 1.f),\n    //     5.\n    // );\n\n    // // Repeat sphere\n    // float sphere_dist; \n    // {\n    //     vec3 tmp_pos = position;\n    //     tmp_pos.x = cycle_dist(clamp(tmp_pos.x, -3.9f, 3.9f), 2.5f);\n    //     tmp_pos.y = cycle_dist(clamp(tmp_pos.y, -3.9f, 3.9f), 2.5f);\n    //     sphere_dist = sphere_sdf(position, vec3(0,0,-20), 1.f);\n    // }\n    // return sphere_dist;\n\n    // Animated spheres sphere\n    vec3 sphere1_pos = vec3(0.3f * cos(-iTime * 4.3f), sin(iTime * 2.3f), -5.f + sin(iTime * 1.3f));\n    vec3 sphere2_pos = vec3(0.2f * cos(-iTime * 2.3f), 1.f * sin(iTime * 4.3f), -5.f + 0.2f * cos(iTime * 1.3f));\n    vec3 sphere3_pos = vec3(1.7f * sin(-iTime * 3.6f), cos(iTime * 0.3f), -5.f + cos(iTime * 3.7f));;\n    vec3 sphere4_pos = vec3(0.1f * sin(-iTime * 1.3f), sin(-iTime * 1.0f), -5.f + sin(-iTime * 1.1f));;\n\n    float comp1 = smooth_min(\n        sphere_sdf(position, sphere1_pos, 0.7f),\n        sphere_sdf(position, sphere2_pos, 0.3f),\n        5.\n    );\n    float comp2 = smooth_min(\n        sphere_sdf(position, sphere3_pos, 1.0f),\n        sphere_sdf(position, sphere4_pos, 0.5f),\n        5.\n    );\n    return smooth_min(comp1, comp2, 5.);\n}\n\n// Get the ray direction for the camera settings\nvec3 ray_direction(float fov, vec2 frag_coord)\n{\n    vec2 uv = frag_coord - iResolution.xy / 2.0f;\n    float z = iResolution.y / tan(radians(fov) / 2.0);\n    return normalize(vec3(uv, -z));\n}\n\n// Raymarching algorithm\nfloat ray_march(vec3 eye, vec3 dir)\n{\n    // Marching distance\n    float depth = MIN_DIST;\n    for(int i = 0; i < MAX_MARCHING_STEPS; i++)\n    {\n        // Get closest distance to an object\n        float march_dist = scene_sdf(eye + depth * dir);\n        if(march_dist < EPSILON) {\n            // Hit surface\n            return depth;\n        }\n        // Increment the distance\n        depth += march_dist;\n\n        if(depth >= MAX_DIST) {\n            // Missed any surface\n            break;\n        }\n    }\n    return MAX_DIST;\n}\n\n// Estimate normal from the marching point\nvec3 estimate_normal(vec3 p) {\n    return normalize(vec3(\n        scene_sdf(vec3(p.x + EPSILON, p.y, p.z)) - scene_sdf(vec3(p.x - EPSILON, p.y, p.z)),\n        scene_sdf(vec3(p.x, p.y + EPSILON, p.z)) - scene_sdf(vec3(p.x, p.y - EPSILON, p.z)),\n        scene_sdf(vec3(p.x, p.y, p.z  + EPSILON)) - scene_sdf(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n\n    // return normalize(vec3(\n    //     scene_sdf(vec3(p.x + EPSILON, p.y, p.z)) - scene_sdf(vec3(p.x - EPSILON, p.y, p.z)),\n    //     scene_sdf(vec3(p.x, p.y + EPSILON, p.z)) - scene_sdf(vec3(p.x, p.y - EPSILON, p.z)),\n    //     scene_sdf(vec3(p.x, p.y, p.z  + EPSILON)) - scene_sdf(vec3(p.x, p.y, p.z - EPSILON))\n    // ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Camera position\n    vec3 eye = vec3(0.0, 0.0, 5.0);\n    // Horizontal FOV\n    float fov = 45.0;\n    // Ray direction\n    vec3 dir = ray_direction(fov, fragCoord);\n\n    float dist = ray_march(eye, dir);\n    // Hits the object\n    if(dist < MAX_DIST) {\n        // Shade pixel\n        vec3 normal = estimate_normal(eye + dir * dist);\n        vec3 directional_light = normalize(vec3(-5,5,3));\n        vec3 ambient_lightning = vec3(0.2);\n        vec3 diffuse_lightning = max(dot(directional_light, normal), 0.f) * vec3(normal);\n        fragColor = vec4(diffuse_lightning + ambient_lightning, 1.);\n    }\n    // Doesn't hit the object\n    else {\n        fragColor = vec4(0., 0., 0., 1.);\n    }\n}","name":"Image","description":"","type":"image"}]}