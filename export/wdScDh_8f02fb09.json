{"ver":"0.1","info":{"id":"wdScDh","date":"1586533693","viewed":425,"name":"Unknow holographic crystal","username":"sukupaper","description":"raymarching + testing some effects (bloom, blur, \"holographic\", chromatic aberations) with frambuffer","likes":22,"published":1,"flags":32,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = fragCoord.xy/iResolution.xy;\n    float aa = 1./iResolution.x;\n    \n    vec3 c = texture(iChannel0,st).rgb;\n    \n    mat3 conv = mat3(\n    \t1,2,1,\n        2,4,2,\n        1,2,1\n    );\n    vec3 cSum = vec3(0.);\n    for(int k = 1; k <= 10; k++) {\n        for(int i = -1; i < 2; i++) {\n            for(int j = -1; j < 2; j++) {\n                vec2 relCoord = vec2(float(i),float(j));\n                cSum += texture(iChannel0,st + relCoord*aa*float(k)*3.).rgb\n                    *conv[int(relCoord.x)][int(relCoord.y + 1.)];\n            }\n        }\n    }\n    cSum /= 16.*10.;\n    \n    \n    vec3 finalC = (c + cSum*2.)*.35;\n    \n    //finalC *= step(.15,st.y)*step(st.y,.85);\n\n    fragColor = vec4(finalC,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n#define P 3.14159265359\n\nfloat animate1(float x, float sm) {\n  x = mod(x,1.) - .25;\n  return smoothstep(-sm,sm,x)*smoothstep(sm + .5,-sm + .5,x);\n}\nfloat animate2(float x, float sm){\n  float xmd = mod(x,1.) - (1. - sm);\n  return smoothstep(-sm,sm,xmd) + floor(x);\n}\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\nfloat opExtrusion(vec3 p, float d, float h) {\n    vec2 w = vec2( d, abs(p.z) - h );\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nfloat circle2d(vec2 p, float s) {\n    return length(p) - s;\n}\n\nfloat plane(vec3 p, vec3 r){ return max(-p.z/r.z,0.); }\n\nfloat t;\nfloat df(vec3 p) {\n    //p.xz *= rot(P + animate2(t*.5,.5 + .05*cos(10.*t))*P);//3.14*animate1(t*.1,.2)*2.\n    p.xz *= rot(t*1.2);\n    p.yz *= rot(P*-.2);\n    p.xz *= rot(P*.25);\n    /*p.xz *= rot(u_time*.4);\n    p.xy *= rot(u_time*1.2);\n    p.yz *= rot(u_time*.2);*/\n    \n    float ctrl = cos(t)*.5+.5;\n    float dec = 0.0469;\n    float rad = 0.66*2.5;\n    float d = 10e6;\n    for(int i = 0; i < 4; i++) {\n        float dt1 = length(abs(p) - vec3(0.,+1.,0.)) - rad;\n    \tdt1 = abs(dt1) - dec;\n        float dt2 = length(abs(p) - vec3(+1.,0.,0.)) - rad;\n        dt2 = abs(dt2) - dec;\n        float dt3 = length(abs(p) - vec3(0.,0.,+1.)) - rad;\n        dt3 = abs(dt3) - dec;\n        \n        d = min(d,dt1);\n        d = min(d,dt2);\n        d = min(d,dt3);\n        rad -= .2;\n    }\n    \n    p = abs(p);\n    float dshape = (p.x+p.y+p.z - 1.)*.57735027;\n    \n    d = max(-d,dshape);\n    return d;\n}\n\n#define EPSI .001\nvec3 normal(vec3 p){\n    vec2 u = vec2(0.,1.);\n    return normalize(vec3(\n        df(p + EPSI*u.yxx) - df(p),\n        df(p + EPSI*u.xyx) - df(p),\n        df(p + EPSI*u.xxy) - df(p)\n    ));\n}\n\n#define MIN_DIST 0.\n#define MAX_DIST 10.\n#define MAX_STEPS 50\n#define LIM EPSI\nvec3 rm(vec3 c, vec3 r) {\n    vec3 color = vec3(.1);\n    vec3 p = c + r*MIN_DIST;\n    for(int i = 0; i < MAX_STEPS; i++) {\n        float d = df(p);\n        if(d < LIM) {\n            color = 1. - (normal(p)*.5 + .5);\n            return color;\n        }\n        if(distance(c,p) > MAX_DIST) return color;\n        p += d*r;\n    }\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = fragCoord.xy/iResolution.xy - .5;\n    st.x *= iResolution.x/iResolution.y;\n\tt = iTime;\n    \n    float md = 15. + floor(-st.y*3.)*10.;\n    t = floor(t*md)/md;\n \n    vec3 c = vec3(0.,0.,(-2. + cos(t*.33)*.5));\n    vec3 r = normalize(vec3(st,0.8));\n    \n    vec3 color = rm(c,r);\n    \n    vec3 cColor = color;\n    color += vec3(color.r+color.b+color.g)/3.;\n    color.r *= cColor.b;\n    color.g *= cColor.g;\n\n    fragColor = vec4(color.grb,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"float rd(vec2 st){\n    return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.585 + iTime*.1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = fragCoord.xy/iResolution.xy;\n    float aa = 2./iResolution.x;\n    \n    vec3 c = vec3(texture(iChannel0,st*4. + .5).r*.15);\n    \n    st.x += step(.95, rd(floor(vec2(st.y*10.))))*.99;\n    c.r += texture(iChannel0,st + vec2(aa,0.)).r;\n    \n    st.x -= step(.95, rd(floor(vec2(st.y*8.))))*.99;\n    c.g += texture(iChannel0,st + vec2(-aa,-aa)).g;\n    \n    st.x += step(.8, rd(floor(vec2(st.y*5.))))*.8;\n    c.b += texture(iChannel0,st + vec2(0.,aa)).b;\n    \n    float rdVal = rd(st + iTime*.1);\n    vec3 bandes = mix(c, c-.1, (cos(st.y*500. + iTime*15.)*.5+.5))\n        - .2*rdVal;\n    c = mix(c, bandes, (c.r+c.g+c.b)/3.) - rdVal*.1;\n    \n    fragColor = vec4(c,1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}