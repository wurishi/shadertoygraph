{"ver":"0.1","info":{"id":"fsdfzH","date":"1656130691","viewed":148,"name":"RayMarching : 6-28-22","username":"doggle","description":"A simple raymarching shader. Should be able to handle most SDFs for objects. By default displays a mandelbulb.\n\nW,A,S,D to move camera, left shift and space to move up & down.\n\nCamera rotation is on Q,E; R,F; Z,C","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["raymarching","fractal","mandelbrot","mandelbulb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Benjamin Rigg\n//A basic ray-marching shader. Should work with most any SDF function.\n\nvec3 spherePos = vec3(0,0,5);\nfloat sphereRadius = 0.5;\n\nvec3 cubePos = vec3(2,0,5);\nvec3 cubeDim = vec3(0.5,0.5,0.5);\n\nfloat mandelbulbPow = 0.0;\nint mandelbulbSteps = 0;\nvec3 mandelPos = vec3(0,0,0);\n\nvec3 objCol = vec3(0.5,0.1, 0.05);\n\nvec3 skyCol = vec3(0.2,0.2,0.2);\n\nvec3 cameraPos = vec3(0.05,0,-1.9);\nfloat focalLength = 0.1;\nvec2 viewPortScale = vec2(0.1,0.1);\nvec3 cameraRot = vec3(-0.1,0,0);\n\nint maxIterations = 100;\nfloat farClip = 200.0;\nfloat nearBreakpoint = 0.002;\n\nconst float moveSpeed = 1.;\n\n\nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat sphereSDF(vec3 pos)\n{\n    float dist = distance(pos, spherePos) - sphereRadius;\n    return dist;\n}\n\nfloat cubeSDF( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat mandelbulbSDF(vec3 pos, out int steps) {\n\tfloat Power = mandelbulbPow + ((iTime+9.5) * 0.1);\n    \n    vec3 z = pos.xyz - mandelPos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < 50 ; i++) {\n\t\tr = length(z);\n        steps = i;\n\t\tif (r>9.0) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n\t}\n\n\treturn 0.5*log(r)*r/dr;\n}\n\nfloat sdf(vec3 pos)\n{\n    //float dist = opUnion(sphereSDF(pos), cubeSDF(pos - cubePos, cubeDim)); //Sphere & cube test\n    float dist = mandelbulbSDF(pos, mandelbulbSteps);  //Mandelbulb fractal\n    return dist;\n}\n\n/*vec3 rotateVec3(vec3 v, float theta)\n{\n    //for 2d vec:\n    //v` = v.x*a + v.y*b\n    //   =  _            _  _ _\n    //     |cos()  -sine()||v.x|\n    //     |sin()   cos() ||v.y|\n    //      -            -  - -\n    //where a and b are the axes of local space, e.g.\n    //a = (cos(theta), sin(theta))\n    //b = (-sin(theta), cos(theta))\n}*/\n\nvec2 rotateVec2(vec2 v, float theta)\n{\n    float sine = sin(theta);\n    float cosine = cos(theta);\n    \n    vec2 vprime = mat2(cosine, -sine, sine, cosine) * v;\n    \n    return vprime;\n}\n\nvoid HandleInput()\n{\n    vec3 offset = texelFetch(iChannel0, ivec2(0,0), 0).xyz;\n    offset *= moveSpeed;\n    cameraPos += offset;\n    \n    vec3 rot = texelFetch(iChannel0, ivec2(iResolution.x - 1., 0), 0).xyz;\n    cameraRot += rot; \n    \n    vec2 mouse = texelFetch(iChannel0, ivec2(1,1), 0).xy;\n    //cameraPos += vec3(mouse, 0);\n    //viewPortPos += vec3(mouse, 0);\n    //skyCol = vec3(mouse, 0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Handle input\n    HandleInput();\n    \n    // Camera Setup\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec3 viewPortPos = cameraPos;\n    viewPortPos.z += focalLength;\n    vec3 fragPos = vec3(((uv.x - 0.5) * aspectRatio) * viewPortScale.x, (uv.y - 0.5) * viewPortScale.y, 0);\n    fragPos += viewPortPos;\n    vec3 fragDirection = normalize(fragPos - cameraPos);\n    \n    //Camera rotation -- not working\n    float fragDistFromCam = distance(fragPos, cameraPos);\n    vec2 newDirX = rotateVec2(fragDirection.xz, cameraRot.x);\n    fragDirection.x = newDirX.x; fragDirection.z = newDirX.y;\n    vec2 newDirY = rotateVec2(fragDirection.yz, cameraRot.y);\n    fragDirection.y = newDirY.x; fragDirection.z = newDirY.y;\n    vec2 newDirZ = rotateVec2(fragDirection.xy, cameraRot.z);\n    fragDirection.x = newDirZ.x; fragDirection.y = newDirZ.y;\n    fragPos = cameraPos + (normalize(fragDirection) * fragDistFromCam);\n\n    \n    \n    //Ray Marching\n    float distance = 0.0;\n    float dMax = 0.0; float dMin = farClip++;\n    vec3 workingPos = fragPos;\n    int i = 0;\n    for(;i < maxIterations; i++)\n    {\n        float d = sdf(workingPos.yxz);\n        workingPos += fragDirection * d;\n        distance += d;\n        \n        if(d > dMax)\n            dMax = d;\n            \n        if(d < dMin)\n            dMin = d;\n                \n        if(distance > farClip)\n        {\n            fragColor = vec4(skyCol * vec3(clamp(log2(dMin/0.01),0.,1.)), 1.0);\n            break;\n        }\n        \n        /*if(d < 0.0)\n        {\n            fragColor = vec4(1,0,1,1);\n            return;\n        }*/\n\n        \n        if(d < nearBreakpoint)\n        {\n            //fragColor = vec4(clamp(objCol + vec3(dMin/nearBreakpoint) * 0.6,0.,1.), 1.0);\n            vec3 col = (objCol + clamp(3.*(1./float(i) - 0.1),-1.,1.));\n            \n            fragColor = vec4(col, 1.);\n            break;\n        }\n    }\n    \n    //fragColor += vec4((distance));\n    //fragColor = texelFetch(iChannel0, ivec2(fragCoord.xy), 0); //Show FrameBufferA\n    \n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Shamelessly ripped from inspirnathan, https://www.shadertoy.com/view/sdf3RS\n//Adapted for personal use.\n\n// For details on how the keyboard input works, see iq's tutorial: https://www.shadertoy.com/view/lsXGzf\n\n// Numbers are based on JavaScript key codes: https://keycode.info/\nconst int KEY_W = 87;\nconst int KEY_S = 83;\nconst int KEY_A = 65;\nconst int KEY_D = 68;\nconst int KEY_SPACE = 32;\nconst int KEY_L_SHIFT = 16;\nconst int KEY_Q = 81;\nconst int KEY_E = 69;\nconst int KEY_R = 82;\nconst int KEY_F = 70;\nconst int KEY_Z = 90;\nconst int KEY_C = 67;\n\nvec3 handleKeyboard(vec3 offset) {\n    float velocity = 1. / 100.; // This will cause offset to change by 0.01 each time an arrow key is pressed\n    \n    // texelFetch(iChannel1, ivec2(KEY, 0), 0).x will return a value of one if key is pressed, zero if not pressed\n    vec3 left = texelFetch(iChannel1, ivec2(KEY_A, 0), 0).x * vec3(-1, 0, 0);\n    vec3 up = texelFetch(iChannel1, ivec2(KEY_SPACE,0), 0).x * vec3(0, 1, 0);\n    vec3 right = texelFetch(iChannel1, ivec2(KEY_D, 0), 0).x * vec3(1, 0 ,0);\n    vec3 down = texelFetch(iChannel1, ivec2(KEY_L_SHIFT, 0), 0).x * vec3(0, -1, 0);\n    vec3 forward = texelFetch(iChannel1, ivec2(KEY_W, 0), 0).x * vec3(0, 0, 1);\n    vec3 back = texelFetch(iChannel1, ivec2(KEY_S, 0), 0).x * vec3(0, 0, -1);\n    \n    offset += (left + up + right + down + forward + back) * velocity;\n\n    return offset;\n}\n\nvec3 handleExtraKeyboard(vec3 offset)\n{\n    float velocity = 1. / 100.; // This will cause offset to change by 0.01 each time an arrow key is pressed\n    \n    // texelFetch(iChannel1, ivec2(KEY, 0), 0).x will return a value of one if key is pressed, zero if not pressed\n    vec3 left = texelFetch(iChannel1, ivec2(KEY_Q, 0), 0).x * vec3(-1, 0, 0);\n    vec3 up = texelFetch(iChannel1, ivec2(KEY_R,0), 0).x * vec3(0, 1, 0);\n    vec3 right = texelFetch(iChannel1, ivec2(KEY_E, 0), 0).x * vec3(1, 0 ,0);\n    vec3 down = texelFetch(iChannel1, ivec2(KEY_F, 0), 0).x * vec3(0, -1, 0);\n    vec3 rollLeft = texelFetch(iChannel1, ivec2(KEY_Z, 0), 0).x * vec3(0, 0, 1);\n    vec3 rollRight = texelFetch(iChannel1, ivec2(KEY_C, 0), 0).x * vec3(0, 0, -1);\n    \n    offset += (left + up + right + down + rollRight + rollLeft) * velocity;\n\n    return offset;\n}\n\nvec3 handleMouse(vec3 offset)\n{\n    vec4 m = iMouse / iResolution.x - 0.5;\n    float x = (m.x);\n    float y = (m.y);\n    \n    offset += vec3(x, y, 0);\n    return offset;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy; \n\n    // Return the offset value from the last frame (zero if it's first frame)\n    vec3 offset = texelFetch( iChannel0, ivec2(0, 0), 0).xyz;\n    \n    // Pass in the offset of the last frame and return a new offset based on keyboard input\n    offset = handleKeyboard(offset);\n\n    // Store offset in the XY values of every pixel value and pass this data to the \"Image\" shader and the next frame of Buffer A\n    if(uv.x < 0.5 && uv.y < 0.5)\n    {\n        fragColor = vec4(offset, 1);\n        return;\n    }\n        \n    vec3 offset2 = texelFetch( iChannel0, ivec2(iResolution.x - 1., 0), 0).xyz;\n    offset2 = handleExtraKeyboard(offset2);\n    if(uv.x > 0.5 && uv.y < 0.5)\n    {\n        fragColor = vec4(offset2,1);\n        return;\n    }\n    \n    //Mouse -- not working\n    vec3 offset3 = texelFetch(iChannel0, ivec2(iResolution.xy - 1.), 0).xyz;\n    \n    offset = handleMouse(offset3);\n    \n    if(uv.x > 0.5 && uv.y > 0.5)\n    {\n        fragColor = vec4(offset3, 1);\n        return;\n    }\n\n}","name":"Buffer A","description":"","type":"buffer"}]}