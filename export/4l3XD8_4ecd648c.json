{"ver":"0.1","info":{"id":"4l3XD8","date":"1488576875","viewed":204,"name":"Droplet (Ray Marching Exercise)","username":"ereif","description":"Lab 10 for CS123","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["lab"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SPHERE 0\n#define PLANE 1\n#define NO_INTERSECT 2\n#define DISPLACEMENT_FACTOR 0.1\n\n// Data structure for raymarching results\nstruct PrimitiveDist {\n    float dist;\n    int primitive; // Can be SPHERE, PLANE, or NO_INTERSECT\n};\n\n// Helper function for tri3.\nfloat tri(in float x) {\n\treturn abs(fract(x)-.5);\n}\n\n// Triangle noise. Use it as a sample displacement map for task 7.\nvec3 tri3(in vec3 p) {\n    return vec3(tri(p.z+tri(p.y*1.)), \n                tri(p.z+tri(p.x*1.)), \n                tri(p.y+tri(p.x*1.)));\n}\n\n// TODO [Task 8] Make a displacement map\n// You can check out tri3 above and the functions in the handout as inspiration\nfloat calcDisplacement(in vec3 p) {\n    //return (sin(p.x)/2.0 * sin(p.y*p.y) + sin(iTime))*1.2;\n    float r = sqrt(p.x*p.x + p.z*p.z);\n    float radiusWithTime = sqrt(p.x*p.x + p.z*p.z) * 7.0  - 9.0 * iTime;\n    \n    float zeroerOut = max(r - 0.5, 0.0);\n    \n    //if (r < 0.5) {\n       // if (mod(iTime*9.0, 9.0) > 4.5) {\n        //\treturn 0.0;\n        //}\n        //return r*r + 2.0*sin(9.0 *iTime);\n        //return (min(p.x, p.z));\n    //}\n    float widthOfWaves = - 1.0;\n    float invHeight = 5.0;\n    return p.y*invHeight + widthOfWaves + sin(radiusWithTime);\n}\n\n// TODO [Task 6] Implement triplanar texture mapping\n// If you want, you can play around with the textures in iChannels 0 and 1\n// The textures should show no distortion\nvec3 texCube( sampler2D sam, in vec3 p, in vec3 n )\n{\n    vec4 zPlane = texture(sam, vec2(p.x, p.y));\n    vec4 xPlane = texture(sam, vec2(p.y, p.z));\n    vec4 yPlane = texture(sam, vec2(p.x, p.z));\n    \n    vec4 color = zPlane*abs(n.z) + xPlane*abs(n.x) + yPlane*abs(n.y);\n    return vec3(normalize(color));\n}\n\n// Signed distance to the twisted sphere.\nfloat sdTwistedSphere(vec3 p) {\n    vec3 spherePosition = vec3(0.0, 0.25, 0.0);\n    float radius = 1.5;\n    float primitive = length(p - spherePosition) - radius;\n    return primitive + calcDisplacement(p);\n}\n\nfloat sdFloor(vec3 p) {\n    return p.y;\n}\n\nPrimitiveDist map(vec3 p) {\n    // TODO [Task 3] Implement distance map\n    float sph = sdTwistedSphere(p);\n    float flo = sdFloor(p);\n    if (sph > flo) {\n        return PrimitiveDist(flo, PLANE);\n    } else {\n        return PrimitiveDist(sph, SPHERE);\n    }\n}\n\n// TODO [Task 4] Calculate surface normals\nconst float epsilon = 0.001;\nconst vec2 e = vec2(epsilon, 0.0); // For swizzling\nvec3 calcNormal(vec3 p) {\n    float x = map(p + e.xyy).dist - map(p - e.xyy).dist;\n    float y = map(p + e.yxy).dist - map(p - e.yxy).dist;\n    float z = map(p + e.yyx).dist - map(p - e.yyx).dist;\n\n    return normalize(vec3(x, y, z));\n}\n\nfloat shadow(vec3 ro, vec3 rd, float k) {\n    float marchDist = 0.001;\n    float boundingVolume = 25.0;\n    float darkness = 1.0;\n    float threshold = 0.001;\n    \n    for(int i = 0; i < 30; i++) {\n        if(marchDist > boundingVolume) continue;\n        float h = map(ro + rd * marchDist).dist;\n        // TODO [Task 7] Modify the loop to implement soft shadows\n            darkness = min(darkness, k * h / marchDist);\n        marchDist += h * 0.7;\n    }\n    \n    return darkness;\n}\n\n\nPrimitiveDist raymarch(vec3 ro, vec3 rd) {\n    \n    // TODO [Task 2] Implement ray marching algorithm\n    // Fill in parameters\n    float marchDist = 0.001;\n    float boundingDist = 50.0;\n    float threshold = 0.0001;\n    \n    // Fill in the iteration count\n    for (int i = 0; i < 1000; i++) {\n        // Fill in loop body\n        vec3 worldSpaceRay = ro + rd*marchDist;\n        PrimitiveDist dist = map(worldSpaceRay);\n        \n        // Exit\n        if (dist.dist < threshold){\n        \treturn PrimitiveDist(marchDist, dist.primitive);\n        }\n        if (dist.dist > boundingDist) {\n        \tbreak;\n        }       \n        marchDist += 0.1 * dist.dist;\n    }\n    \n    return PrimitiveDist(-1.0, NO_INTERSECT);\n}\n\nvec3 render(vec3 ro, vec3 rd, float t, int which) {\n    \n    // Col is the final color of the current pixel.\n    vec3 col = vec3(0.);\n    vec3 pos = ro + rd * t;\n    // Light vector\n    vec3 lig = normalize(vec3(1.0,0.6,0.5));\n    \n    // Normal vector\n    vec3 nor = calcNormal(pos);\n    // Ambient\n    float ambient = 0.1;\n    // Diffuse\n    float diffuse = clamp(dot(nor, lig), 0.0, 1.0);\n    // Specular\n    float shineness = 32.0; \n    float specular = pow(clamp(dot(rd, reflect(lig, nor)), 0.0, 1.0), 32.0);\n    \n    float darkness = shadow(pos, lig, 18.0);\n    // Applying the phong lighting model to the pixel.\n    col += vec3(((ambient + diffuse + specular) * darkness));\n    \n    // TODO [Task 5] Assign different intersected objects with different materials\n    // Make things pretty!\n    vec3 material = vec3(0.0);\n    if (which == PLANE) {\n        material = texCube(iChannel0, pos, nor);\n    } else if (which == SPHERE) {\n        material = texCube(iChannel1, pos, nor);\n    } else {\n        material = vec3(0.0);\n    }\n    \n    // Blend the material color with the original color.\n    col = mix(col, material, 0.4);\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n   \n    vec3 rayOrigin = vec3(6.0 * sin(iTime * .3), 4.8, 6.0 * cos(iTime * .3));\n    \n    float focalLength = 2.0;\n    \n    // The target we are looking at\n    vec3 target = vec3(0.0);\n    // Look vector\n    vec3 look = normalize(rayOrigin - target);\n    // Up vector\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    \n    // Set up camera matrix\n    vec3 cameraForward = -look;\n    vec3 cameraRight = normalize(cross(cameraForward, up));\n    vec3 cameraUp = normalize(cross(cameraRight, cameraForward)); \n  \n    // TODO [Task 1] Construct the ray direction vector\n    float u = fragCoord.x/iResolution.x * 2.0 - 1.0;\n    float v = fragCoord.y/iResolution.y * 2.0 - 1.0;\n    u *= iResolution.x/iResolution.y;\n    vec2 uv = vec2(u, v);\n    vec3 rayDirection = vec3(uv, focalLength);\n    \n    vec3 x = cameraRight * rayDirection.x;\n    vec3 y = cameraUp * rayDirection.y;\n    vec3 z = cameraForward * rayDirection.z;\n    \n    rayDirection = normalize(x + y + z);\n        \n    PrimitiveDist rayMarchResult = raymarch(rayOrigin, rayDirection);\n    vec3 col = vec3(0.0);\n    if (rayMarchResult.primitive != NO_INTERSECT) {\n      col = render(rayOrigin, rayDirection, rayMarchResult.dist, rayMarchResult.primitive);\n    }\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}