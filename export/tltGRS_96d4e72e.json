{"ver":"0.1","info":{"id":"tltGRS","date":"1576763980","viewed":400,"name":"Linebox","username":"noby","description":"A sketch inspired by IRC discussions.","likes":30,"published":1,"flags":32,"usePreview":0,"tags":["2d","lines","feedback"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord){\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor = mix(fragColor, smoothstep(0.0, 1.0, fragColor), 0.6);\n    fragColor = pow(fragColor, vec4(1.0/2.2));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int Line_count = 256;\n\nvec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d){\n    return a + b*cos(6.28318*(c*t+d));\n}\n\nfloat segment_distance(vec2 a, vec2 b, vec2 p){\n    vec2 n = b - a;\n    vec2 pa = a - p;\n    float c = dot(n, pa);\n    if(c > 0.0)\n        return dot(pa, pa); \n    vec2 bp = p - b;\n    if(dot(n, bp) > 0.0)\n        return dot(bp, bp);\n    vec2 e = pa - n * (c / dot(n, n));\n    return dot(e, e);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 R = iResolution.xy;\n    float T = iTime*0.25;\n    // Centering offset.\n    float offset = max(R.x, R.y)/2.0 - min(R.x, R.y)/2.0;\n    // Apply centering to the correct axis.\n    vec2 cc = fragCoord - vec2(offset, offset)*vec2(step(R.y, R.x), step(R.x, R.y));\n    // UV coordinates.\n    vec2 c = cc / min(R.x, R.y);\n    \n    if(c.x < 0.0 || c.x > 1.0 || c.y < 0.0 || c.y > 1.0){\n        fragColor = vec4(0);\n        return;\n    }\n\t\n    const float margin = 0.03;\n    const vec3 pa = vec3(0.5);\n    const vec3 pb = vec3(0.5);\n    const vec3 pc = vec3(1, 0.9, 0.8);\n    const vec3 pd = vec3(0.0, 0.2, 0.4);\n    \n    vec3 color = vec3(0);\n    for(int i = 0; i < Line_count; ++i){\n        float x = float(1+i);\n        float sx = (0.5+0.5*sin(x+T*cos(x*1234.0)));\n        float sy = (0.5+0.5*cos(x+T*sin(x*2345.0)));\n        vec2 s = margin + (1.0-margin*2.0) * vec2(sx, sy);\n        float ex = (0.5+0.5*sin(x-T*cos(x*3456.0)));\n        float ey = (0.5+0.5*cos(x-T*sin(x*4567.0)));\n        vec2 e = margin + (1.0-margin*2.0) * vec2(ex, ey);\n        \n        float sd = segment_distance(s, e, c)/1.5;\n        float sm = clamp(1.0-sd*R.x*R.y, 0.0, 100.0);\n        vec3 h = palette(mod((x-1.0)/float(Line_count)+T*0.25, 1.0), pa, pb, pc, pd);\n        color = max(color, sm*h);\n    }\n    \n    vec3 previous = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n    fragColor.rgb = mix(color, previous, 0.99);\n}","name":"Buffer A","description":"","type":"buffer"}]}