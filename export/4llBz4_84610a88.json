{"ver":"0.1","info":{"id":"4llBz4","date":"1511195080","viewed":164,"name":"[TP5]Shadowed Scene","username":"Sando","description":"Illuminated scene with floor and added shadows and movement.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","shadow","tp"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float FLT_MAX = 1.0 / 0.0;   \nconst int MAX_NB_BOUNCES = 10;\nconst int NB_SHOT_RAY = 15;\nconst float FLT_NB_SHOT_RAY = 15.0;\n\nstruct Material\n{\n    float Ka; // ambiant\t\tcoefficient\n    float Kd; // diffuse\t\tcoefficient\n    float Ks; // specular\t\tcoefficient\n    float Kn; // specular power coefficient\n};\n    \nstruct ShadeInfo\n{\n    vec3 shadeCol;\n    float Ks;\n};\n    \n// Camera Parameters\n      vec3\t\tcameraInitPos\t= vec3(6, 4, -5);\n\t  vec3 \t\tcameraPos \t\t= vec3(6, 4, -5);\nconst vec3 \t\tcameraTarget\t= vec3(3, 1, -8);\nconst float \tcameraFovY\t\t= 80.0;\n\n//Light Parameters\nconst vec3\t\tambiantCol\t= vec3(0,0,1);\nconst vec3\t\tlightCol\t= vec3(1,1,1);\nconst vec3 \t\tlightInitPos= vec3(8, 10, -12);\n      vec3\t\tlightPos\t= vec3(8, 10, -12);\n    \n// Sky Parameters\nconst vec3\t\tskyCol\t= vec3(0.2);\nconst int\t\tskyId\t= 0;\nconst Material\tskyMat\t= Material(1.0,0.0,0.0,0.0);\n\n// Sphere Parameters\nconst int \t\tsphereId \t\t= 1;\nconst vec3 \t\tspherePos\t\t= cameraTarget + vec3(0, 1, 2);\nconst float \tsphereRadius\t= 1.0;\nconst vec3\t\tsphereCol\t\t= vec3(1,0,0);\nconst Material \tsphereMat\t\t= Material(0.2, 0.7, 0.1, 50.0);\n\n// Sphere2 Parameters\nconst int \t\tsphere2Id \t\t= 2;\nconst vec3 \t\tsphere2Pos\t\t= cameraTarget + vec3(2, 1, 5);\nconst float \tsphere2Radius\t= 1.0;\nconst vec3\t\tsphere2Col\t\t= vec3(0.2,0.5,0.5);\nconst Material \tsphere2Mat\t\t= Material(0.5, 0.7, 1.0, 500.0);\n\n// Plan Parameters\nconst int \t\tplaneId \t\t= 3;\nconst vec3 \t\tplanePos\t\t= vec3(0, 0.1, 0);\nconst vec3\t\tplaneNormal\t\t= vec3(0, 1.0, 0);\nconst vec3\t \tplaneCol1\t\t= vec3(1.0);\nconst vec3\t\tplaneCol2\t\t= vec3(0.4);\nconst Material \tplaneMat\t\t= Material(0.2, 1.0, 0.2, 5.0);\n\n\nvoid animateCamera(){\n    cameraPos = vec3(cameraTarget.x+5.0*cos(iTime/4.0), cameraInitPos.y, cameraTarget.z+5.0*sin(iTime/4.0));\n\tlightPos  = vec3(lightInitPos.x - 8.0*sin(iTime), lightInitPos.y, lightInitPos.z + 12.0*cos(iTime));\n\n}\n\nvoid computeCameraRayFromPixel(vec2 fragCoord, out vec3 rayPos, out vec3 rayDir)\n{\n    float fragX = fragCoord.x - iResolution.x/2.0;\n    float fragY = iResolution.y/2.0 - fragCoord.y;\n    float fragZ = iResolution.y/(2.0*tan(radians(cameraFovY/2.0)));\n \n    vec3 cz = normalize(cameraTarget - cameraPos); \n    \n    vec3 tmpCy = vec3(0, -1, 0);\n    vec3 tmpCx = cross(tmpCy, cz);\n    \n    vec3 cx = normalize(tmpCx);\n    vec3 cy = cross(cz, cx);\n    \n    rayDir = normalize(fragX*cx + fragY*cy + fragZ*cz);\n    rayPos = cameraPos;\n}\n\nfloat rayPlane(vec3 rayPos, vec3 rayDir, vec3 planePos, vec3 planeNormal, out vec3 intersectPt, out vec3 normalP)\n{\n   \tfloat den = dot(planeNormal, rayDir);\n    if(abs(den) < 0.0001)\n        return(-1.0);\n    float intersectDist = dot(planeNormal, planePos - rayPos)/den;\n    intersectPt = rayPos + rayDir*intersectDist;\n    normalP = -sign(den)*planeNormal;\n    return intersectDist;\n}\n\nfloat raySphere(vec3 rayPos, vec3 rayDir, vec3 spherePos, float sphereRadius, out vec3 intersectS, out vec3 normalS)\n{\n    float intersectDist = 0.0;\n    vec3 camSph = spherePos - rayPos;\n\tfloat proj = dot(camSph, rayDir);\n    float intersect = pow(sphereRadius, 2.0)+ pow(proj,2.0) - pow(length(camSph),2.0);\n    if(intersect > 0.0)\n        intersectDist = proj - sqrt(intersect);\n    intersectS = rayPos + rayDir*intersectDist;\n    normalS = normalize(intersectS - spherePos);\n    \n    return intersectDist;\n}\n\n\nfloat computeNearestIntersection(vec3 rayPos, vec3 rayDir, out int objectId, out vec3 intersectI, out vec3 normalI){\n\tfloat minDist = FLT_MAX;\n    objectId = skyId;\n    \n    vec3 intersectS, normalS;\n\tfloat distS = raySphere(rayPos, rayDir, spherePos, sphereRadius, intersectS, normalS);\n    if((distS > 0.0) && (distS < minDist)){\n    \tintersectI = intersectS;\n        normalI = normalS;\n        minDist = distS;\n        objectId = sphereId;\n    }\n    \n    vec3 intersectS2, normalS2;\n\tfloat distS2 = raySphere(rayPos, rayDir, vec3(sphere2Pos.x+cos(iTime), sphere2Pos.y+sin(iTime), sphere2Pos.z), sphere2Radius, intersectS2, normalS2);\n    if((distS2 > 0.0) && (distS2 < minDist)){\n    \tintersectI = intersectS2;\n        normalI = normalS2;\n        minDist = distS2;\n        objectId = sphere2Id;\n    }\n    \n    vec3 intersectP, normalP;\n    float distP = rayPlane(rayPos, rayDir, planePos, planeNormal, intersectP, normalP);\n    if((distP > 0.0) && (distP < minDist)){\n    \tintersectI = intersectP;\n        normalI = normalP;\n        minDist = distP;\n        objectId = planeId;\n    }\n    if (objectId == skyId)\n        minDist = -1.0;\n    \n    return(minDist);\n}\n\nvec3 getSphereColorAtPoint(vec3 pt){\n    return(sphereCol);\n}\n\nvec3 getSphere2ColorAtPoint(vec3 pt){\n    return(sphere2Col);\n}\n\nvec3 getPlaneColorAtPoint(vec3 pt){    \n    vec3 worldX = vec3(1,0,0);\n    vec3 axisX  = normalize(worldX - dot(worldX, planeNormal) * planeNormal);\n    vec3 axisY  = normalize(cross(planeNormal, axisX));\n    vec3 diff = pt - planePos; \n    \n    float u = dot(diff, axisX);\n    float v = dot(diff, axisY);\n    \n    vec3 planeCol = (mod(floor(pt.x*0.5) + floor(pt.z*0.5),2.0) < 1.0) ? planeCol1 : planeCol2;\n    return(planeCol);\n}\n\nvec3 getColorAtPoint(int object, vec3 pt, out Material objectMat){\n    if (object == sphereId)\n    {\n        objectMat = sphereMat;\n        return getSphereColorAtPoint(pt);\n    }\n    else if (object == sphere2Id)\n    {\n        objectMat = sphere2Mat;\n        return getSphere2ColorAtPoint(pt);\n    } \n    else if (object == planeId)\n    {\n        objectMat = planeMat;\n        return getPlaneColorAtPoint(pt);\n    }\n        \n    return skyCol;\n}\n\nfloat getShadowCoeffAtPoint(Material object, vec3 pt, vec3 normal, vec3 lightPos, vec3 L){\n    vec3 null1, null2;\n    int null3;\n    \n    float distToL = distance(pt, lightPos);\n    float epsilon = 0.00001;\n    \n    float distIntersect = computeNearestIntersection(pt+normal*epsilon, L, null3, null1, null2);\n    \n    if(distIntersect < 0.0 || distIntersect >= distToL){\n        return(1.0);\n    } else {\n        return(object.Ka);\n    }\n}\n\nvec3 computePhongShader(float shadowCoeff, vec3 objectCol, Material objectMat, vec3 normalI, vec3 L, vec3 R, vec3 V){\n    vec3 ambiant \t= objectMat.Ka*ambiantCol;\n    float cosTheta\t= max(dot(normalI,L),0.0);\n    float cosAlpha\t= max(dot(R, V),0.0);\n    \n    vec3 diffuse \t= objectMat.Kd*lightCol*objectCol*cosTheta;   \n    vec3 specular\t= objectMat.Ks*lightCol*pow(cosAlpha,objectMat.Kn);\n    \n    float shadowCoeffSpec = shadowCoeff<1.0 ? 0.0 : 1.0; \n    \n    return ambiant + diffuse*shadowCoeff + specular*shadowCoeff;\n}\n\nvec3 RayTraceAtPixelCoord(vec2 pixCoord){\n    \n\t// Compute the ray to be casted through the pixel towards the 3D scene\n    vec3 rayPos, rayDir;\n    computeCameraRayFromPixel(pixCoord, rayPos, rayDir);\n\t\n    ShadeInfo infos[MAX_NB_BOUNCES];\n    int nbBounces = 0;\n    do{\n        \n        // Test ray-objects intersections and find the nearest one\n        // (with its associated intersection point and normal at the object surface)\n        int objectId;\n        vec3 intersectI, normalI;\n        float distI = computeNearestIntersection(rayPos, rayDir, objectId, intersectI, normalI);\n        \n        //We did not hit the sphere, so we have the sky color (here : black)\n        if (distI <= 0.0){\n            infos[nbBounces].shadeCol \t= skyCol;\n            infos[nbBounces].Ks\t\t\t= 0.0;\n            break;\n        }\n        \n        // Apply the shading to the points that are on the surface and seen by the camera\n\n        // Unit-vector from surface point to light\n    \tvec3 L = normalize(lightPos - intersectI);\n    \t// Unit-vector of reflection direction of the light at the surface point\n    \tvec3 R = normalize(2.0*normalI*dot(normalI,L)-L);\n    \t// Unit-vector from surface point to camera\n\t    vec3 V = normalize(cameraPos - intersectI);\n        \n\t    //Get point color\n    \tMaterial objectMaterial;\n\t    vec3 color = getColorAtPoint(objectId, intersectI, objectMaterial); \n        \n        float shadowCoeff;\n        shadowCoeff = getShadowCoeffAtPoint(objectMaterial, intersectI, normalI, lightPos, L);\n   \t \n    \tinfos[nbBounces].shadeCol \t= computePhongShader(shadowCoeff, color, objectMaterial, normalI, L, R, V);\n        infos[nbBounces].Ks\t\t\t= objectMaterial.Ks;\n                \n        // Bounce from the surface towards the reflected direction of the ray\n        rayPos = intersectI ;\n        rayDir = rayDir - 2.0*normalI*dot(rayDir, normalI);\n        \n        nbBounces++;\n    }\n    while(nbBounces < MAX_NB_BOUNCES);\n    \n    vec3 resCol = vec3(0);\n    \n    for(int i=nbBounces; i>=0; i--){\n     \tresCol = infos[i].shadeCol + infos[i].Ks*resCol; \n    }\n    \n    return resCol;\n}\n\nvec2 noise2(vec2 location, vec2 delta){\n    const vec2 c = vec2(12.9898, 78.233);\n    const float m = 43758.5453;\n    return vec2(\n        fract(sin(dot(location + delta, c)) * m),\n        fract(sin(dot(location + vec2(delta.y, delta.x), c)) * m)\n        );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Test intersection\n\tanimateCamera();\n    vec3 pixelCol = vec3(0);\n    for(int i=0; i<NB_SHOT_RAY; i++){\n\t    pixelCol += RayTraceAtPixelCoord(fragCoord + noise2(fragCoord,vec2(i,i*i)));\n    }\n    fragColor = vec4(pixelCol/FLT_NB_SHOT_RAY, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}