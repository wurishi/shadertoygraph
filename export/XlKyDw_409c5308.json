{"ver":"0.1","info":{"id":"XlKyDw","date":"1537966217","viewed":398,"name":"Better PT","username":"noxbuds","description":"Improved on my path tracer. It now resolves quicker, and is much more interactive; WASD to move and mouse to look around.","likes":10,"published":1,"flags":48,"usePreview":0,"tags":["3d","ray","trace","path"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//////////////////////////////////////////////////\n//                                              //\n//  Another experiment in path tracing. This    //\n//  time I'm trying to improve on my previous   //\n//  one. Various things have been added too.    //\n//                                   - Noxbuds  //\n//                                              //\n//////////////////////////////////////////////////\n\n/////////////////////////////////////////////////\n//                                             //\n//              IMAGE PROCESSING               //\n//                                             //\n/////////////////////////////////////////////////\n\n// Burgess tonemapping - looks fairly bright/cheerful, has quite\n// a bit of contrast aswell\nvec3 burgess(vec3 col)\n{\n    vec3 maxCol = max(vec3(0.0), col - 0.004);\n    vec3 retCol = (maxCol * (6.2 * maxCol + 0.05)) / (maxCol * (6.2 * maxCol + 2.3) + 0.06);\n    return pow(retCol, vec3(1.0 / 2.2));\n}\n\n// Final composition\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Setup colour\n    vec3 col = vec3(0.0);\n    \n    // Grab colour from Buf A\n    col = texture(iChannel0, uv).rgb / texture(iChannel0, uv).w;\n    \n    // Tonemapping to make the scene look better\n    col = pow(col, vec3(2.2));\n    col = burgess(col);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//////////////////////////////////////////////////\n//                                              //\n//  Another experiment in path tracing. This    //\n//  time I'm trying to improve on my previous   //\n//  one. Various things have been added too.    //\n//                                   - Noxbuds  //\n//                                              //\n//////////////////////////////////////////////////\n\n// Macros\n#define bright(c) c.r * 0.2126 + c.g * 0.7152 + c.b * 0.0722\n#define aspectmult vec2(iResolution.x / iResolution.y, 1.0);\n\n/////////////////////////////////////////////////\n//                                             //\n//                 CONSTANTS                   //\n//                                             //\n/////////////////////////////////////////////////\n\n// Numbers\n#define PI 3.14159\n#define BIG_NUMBER 1e6\n#define EPS 1e-5\n#define MAX_DEPTH 4\n#define OBJ_COUNT 26\n#define SAMPLES 8.0\n\n// Object types\n#define NONE 0\n#define SPHERE 1\n#define PLANE 2\n#define BOX 3\n\n// Makes it noisy (doesn't smooth image out over time)\n//#define NOISY\n\n// Fake AA\n#define FAKE_AA\n\n/////////////////////////////////////////////////\n//                                             //\n//                 UTILITIES                   //\n//                                             //\n/////////////////////////////////////////////////\n\n// Note: these utilities are pretty much the same as in my\n// previous path tracer, but I've shortened most of them\n// into defines\n\n// Random number generator\n#define noisev(p) fract(sin(p * 1234.0) * 5647.0)\n\n// Returns the minimum component of a vector\n#define min3(v) min(min(v.x, v.y), v.z)\n\n// Returns the maximum component of a vector\n#define max3(v) max(max(v.x, v.y), v.z)\n\n// Swaps two terms\nvoid swap(inout float a, inout float b)\n{\n    float temp = a;\n    a = b;\n    b = temp;\n}\n\n// Random 3D vector function\nvec3 R3D(vec3 p)\n{\n    vec3 a = fract(p.xyx * vec3(123.34, 234.34, 345.65));\n    a += dot(a, a + 34.45);\n    return fract(vec3(a.x * a.y, a.y * a.z, a.x * a.z));\n}\n\n/////////////////////////////////////////////////\n//                                             //\n//                  OBJECTS                    //\n//                                             //\n/////////////////////////////////////////////////\n\n// A general object data structure\nstruct Obj\n{\n    // Object type\n    int type;\n    \n    // Position, dimensions\n    vec3 pos;\n    vec4 dim;\n};\n    \n// List of objects\nObj[OBJ_COUNT] objects = Obj[](\n    \n    // Empty object\n    Obj(NONE, vec3(0.0), vec4(0.0)),\n    \n    // Reflective sphere\n    Obj(SPHERE, vec3(-0.8, 0.15, 0.2), vec4(0.4)),\n    \n    // Another sphere\n    Obj(SPHERE, vec3(-1.6, 0.15, 0.2), vec4(0.4)),\n    \n    // Glass box\n    Obj(BOX, vec3(0.2, -0.35, 0.2), vec4(0.8, 0.8, 0.2, 0.0)),\n    \n    ////////////// Table ///////////////\n    //// Add on vec3(-1.2, -0.3, 1.5) ///\n    \n    Obj(BOX, vec3(-1.2, -0.3, 0.5), vec4(1.6, 0.1, 1.6, 0.0)),\n    Obj(BOX, vec3(-1.85, -0.95, 1.15), vec4(0.1, 1.2, 0.1, 0.0)),\n    Obj(BOX, vec3(-0.55, -0.95, -0.15), vec4(0.1, 1.2, 0.1, 0.0)),\n    Obj(BOX, vec3(-1.85, -0.95, -0.15), vec4(0.1, 1.2, 0.1, 0.0)),\n    Obj(BOX, vec3(-0.55, -0.95, 1.15), vec4(0.1, 1.2, 0.1, 0.0)),\n    \n    ////////////// Chair ///////////////\n    //// Add on vec3(0.2, 0.8, 1.5) ////\n    \n    Obj(BOX, vec3(0.2, -0.8, 0.2), vec4(1.0, 0.1, 1.0, 0.0)),\n    Obj(BOX, vec3(-0.25, -1.3, -0.25), vec4(0.1, 1.0, 0.1, 0.0)),\n    Obj(BOX, vec3(0.65, -1.3, 0.65), vec4(0.1, 1.0, 0.1, 0.0)),\n    Obj(BOX, vec3(-0.25, -1.3, 0.65), vec4(0.1, 1.0, 0.1, 0.0)),\n    Obj(BOX, vec3(0.65, -1.3, -0.25), vec4(0.1, 1.0, 0.1, 0.0)),\n    \n    ////////////////////////////////////\n    \n    // Mirror\n    Obj(BOX, vec3(0.0, 1.5, -4.25), vec4(5.0, 4.0, 0.5, 0.0)),\n    \n    // Floor\n    Obj(BOX, vec3(0.0, -1.7, 0.0), vec4(10.0, 0.48, 10.0, 0.0)),\n    \n    // Back wall\n    Obj(BOX, vec3(0.0, 1.5, -4.75), vec4(10.0, 6.0, 0.5, 0.0)),\n    \n    // Left wall\n    Obj(BOX, vec3(4.75, 1.5, 0.0), vec4(0.5, 6.0, 10.0, 0.0)),\n    \n    // Right wall\n    Obj(BOX, vec3(-4.75, -0.75, 0.0), vec4(0.5, 1.5, 10.0, 0.0)),\n    Obj(BOX, vec3(-4.75, 0.75, -3.0), vec4(0.5, 1.5, 4.0, 0.0)),\n    Obj(BOX, vec3(-4.75, 0.75, 3.0), vec4(0.5, 1.5, 4.0, 0.0)),\n    Obj(BOX, vec3(-4.75, 3.0, 0.0), vec4(0.5, 3.0, 10.0, 0.0)),\n    \n    // Front wall\n    Obj(BOX, vec3(0.0, 1.5, 4.75), vec4(10.0, 6.0, 0.5, 0.0)),\n    \n    // Ceiling\n    Obj(BOX, vec3(0.0, 4.75, 0.0), vec4(10.0, 0.5, 10.0, 0.0)),\n    \n    // Window\n    Obj(BOX, vec3(-4.75, 0.75, 0.0), vec4(0.5, 2.0, 2.0, 0.0)),\n    \n    // Light\n    Obj(SPHERE, vec3(0.0, 3.75, 0.0), vec4(0.6))\n);\n\n// Surface fragment. By having surface(id, p) give this instead of just\n// having a uniformly colored surface, we can have textures/patterns.\nstruct SurfFrag\n{\n    vec3 surface;\n    vec3 emission;\n    float roughness;\n    float ior;\n};\n\n/////////////////////////////////////////////////\n//                                             //\n//           INTERSECTION FUNCTIONS            //\n//                                             //\n/////////////////////////////////////////////////\n\n// Sphere intersection\nfloat iSphere(Obj obj, vec3 o, vec3 r, inout vec3 n)\n{\n    // Move to local co-ordinates\n    o -= obj.pos;\n    n = vec3(0.0);\n    \n    // Solve the intersection equation\n    float ret = 0.0;\n    float b = 2.0 * dot(o, r);\n    float c = dot(o, o) - obj.dim.x * obj.dim.x;\n    float h = b * b - 4.0 * c;\n    if (h < 0.0) ret = -1.0;\n    else ret = (-b - sqrt(h)) / 2.0;\n    \n    // Return normal and distance\n    n = (o + r * ret) / obj.dim.x;\n    return ret;\n}\n\n// Plane intersection\nfloat iPlane(Obj obj, vec3 o, vec3 r, inout vec3 n)\n{\n    // Normal\n    n = vec3(0.0, step(obj.dim.x, o.y) * 2.0 - 1.0, 0.0);\n    \n    // Intersection distance\n    return -o.y / r.y - obj.dim.x;\n}\n\n// Box intersection\nfloat iBox(Obj obj, vec3 o, vec3 r, inout vec3 n)\n{\n    // Calculate bounds\n    vec3 bmin = obj.pos - obj.dim.xyz / 2.0;\n    vec3 bmax = obj.pos + obj.dim.xyz / 2.0;\n    \n    // Calculate minima and maxima\n    vec3 tmin3 = (bmin - o) / r;\n    vec3 tmax3 = (bmax - o) / r;\n    \n    // Make sure they're the right way around\n    if (tmin3.x > tmax3.x) swap(tmin3.x, tmax3.x);\n    if (tmin3.y > tmax3.y) swap(tmin3.y, tmax3.y);\n    if (tmin3.z > tmax3.z) swap(tmin3.z, tmax3.z);\n    \n    // Calculate minimum and maximum distance\n    float tmin = max3(tmin3);\n    float tmax = min3(tmax3);\n    float t = min(tmin, tmax);\n    \n    // Skip over box if we're out of bounds\n    if (tmin > min3(tmax3) || max3(tmin3) > tmax)\n        t = -1.0;\n    \n    // Calculate sphere normal\n    vec3 p = o + r * t;\n    vec3 sn = 2.0 * (p - obj.pos) / obj.dim.xyz;\n    \n    // Calculate normal\n    n = step(vec3(1.0 - EPS * 2.0), abs(sn)) * mix(vec3(-1.0), vec3(1.0), step(vec3(0.0), sn));\n    \n    // Return distance\n    return t;\n}\n\n// Calculates intersections with the scene\nint intersect(vec3 o, vec3 r, inout float t, inout vec3 n)\n{\n    // Return values\n    t = BIG_NUMBER;\n    int id = 0;\n    \n    // Loop through each object\n    for (int i = 0; i < OBJ_COUNT; i++)\n    {\n        // Current variables\n        float ct = BIG_NUMBER;\n        vec3 cn = vec3(0.0);\n        \n        // Check what type it is\n        if (objects[i].type == SPHERE)\n            ct = iSphere(objects[i], o, r, cn);\n        else if (objects[i].type == PLANE)\n            ct = iPlane(objects[i], o, r, cn);\n        else if (objects[i].type == BOX)\n            ct = iBox(objects[i], o, r, cn);\n        \n        // If the point is closer than the current\n        // point but still visible, use it instead\n        if (ct < t && ct > 0.0)\n        {\n            t = ct;\n            id = i;\n            n = normalize(cn);\n        }\n    }\n    \n    // Return the ID found.\n    return id;\n}\n\n// Casts a ray and returns the final colour\nint castRay(vec3 o, vec3 r, inout vec3 n, inout vec3 p)\n{\n    // Setup variables\n    vec3 col = vec3(0.0);\n    int rn = 0;\n    \n    // Initialise normal vector and distance\n    n = vec3(0.0);\n    float t = BIG_NUMBER;\n\n    // Calculate intersection\n    int i = intersect(o, r, t, n);\n    \n    // Setup the point\n    p = o + r * t;\n    \n    // Return colour\n    return i;\n}\n\n/////////////////////////////////////////////////\n//                                             //\n//                 MATERIALS                   //\n//                                             //\n/////////////////////////////////////////////////\n\n// Returns a surface fragment at a point\nSurfFrag surface(int id, vec3 p)\n{\n    // Hardly anything special in terms of textures I guess, just adds a nice\n    // touch to more easily see different effects in action\n    \n    // Checkerboard multiplier\n    float ch = 1.0;\n    if (mod(p.x, 0.5) < 0.1 || mod(p.y + 0.1, 0.5) < 0.1 || mod(p.z, 0.5) < 0.1) ch = 0.5;\n    \n    // Reflective sphere\n    if (id == 1) return SurfFrag(vec3(1.0), vec3(0.0), 0.0, 0.0);\n    \n    // Another sphere\n    if (id == 2) return SurfFrag(vec3(0.9, 0.2, 0.2), vec3(0.0), 0.1, 0.0);\n    \n    // Glass box\n    if (id == 3) return SurfFrag(vec3(0.9, 1.0, 0.9), vec3(0.0), 0.0, 1.5);\n    \n    // Table\n    if (id >= 4 && id <= 8) return SurfFrag(vec3(0.8), vec3(0.0), 0.8, 0.0);\n    \n    // Chair\n    if (id >= 9 && id <= 13) return SurfFrag(vec3(0.9, 0.9, 0.1), vec3(0.0), 0.8, 0.0);\n    \n    // Mirror\n    if (id == 14) return SurfFrag(vec3(1.0, 0.9, 0.7), vec3(0.0), 0.01, 0.0);\n    \n    // Floor\n    if (id == 15) return SurfFrag(vec3(0.7, 0.8, 1.0), vec3(0.0), 0.2 * ch, 0.0);\n    \n    // Walls\n    if (id >= 16 && id <= 22) return SurfFrag(vec3(1.0, 1.0, 0.9), vec3(0.0), 0.8, 0.0);\n    \n    // Ceiling\n    if (id == 23) return SurfFrag(vec3(1.0, 1.0, 0.9), vec3(0.0), 0.8, 0.0);\n    \n    // Window\n    if (id == 24) return SurfFrag(vec3(0.9, 1.0, 0.9), vec3(0.0), 0.0, 1.5);\n    \n    // Light\n    if (id == 25) return SurfFrag(vec3(1.0), vec3(1.0, 1.0, 0.9), 1.0, 0.0);\n    \n    // Otherwise return nothing\n    return SurfFrag(vec3(0.0), vec3(0.0), 0.0, 0.0);\n}\n\n// Returns probability of reflection vs refraction\nfloat schlick(float cosine, float ior)\n{\n    float R0 = pow((1.0 - ior) / (1.0 + ior), 2.0);\n    return R0 + (1.0 - R0) * pow(1.0 - cosine, 5.0);\n}\n\n// BRDFs\nfloat diffuseBRDF(vec3 rayOut, vec3 n) { return max(dot(n, rayOut), 0.0); }\n\n// Direct light sampling. Helps get more accurate results\nvec3 directLight(vec3 p, vec3 n)\n{\n    // Sampled light color\n    vec3 lightSample = vec3(0.0);\n    \n    // Diffuse light path\n    vec3 vDiff = normalize(R3D(p + iTime) * 2.0 - 1.0);\n\n    // Loop through each object\n    for (int i = 0; i < OBJ_COUNT; i++)\n    {\n        // If it's emissive, try cast a ray toward it\n        if (surface(i, p).emission != vec3(0.0))\n        {\n            // Temporary p and n\n            vec3 p_, n_ = vec3(0.0);\n\n            // Setup a ray towards the object\n            vec3 ld = objects[i].pos - p;\n\n            // Direction to cast ray in\n            vec3 dir = normalize(vDiff + ld);\n\n            // Cast a ray. If we hit the object, add onto the light sample\n            if (castRay(p, dir, n_, p_) == i)\n                lightSample += surface(i, p_).emission * diffuseBRDF(dir, n);\n        }\n    }\n    \n    // Return it\n    return lightSample;\n}\n\n// Calculate color for a ray\nvec3 color(vec3 o, vec3 r, float iSample)\n{\n    // Light\n    vec3 attenuation = vec3(1.0);\n    vec3 emission = vec3(0.0);\n    \n    // fix for backwards positions\n    o *= vec3(-1.0, 1.0, -1.0);\n    r *= vec3(-1.0, 1.0, -1.0);\n    \n    // Previous IOR\n    float prevIor = 1.0;\n    \n    // Bounce the ray around a few times\n    for (int i = 0; i < MAX_DEPTH; i++)\n    {\n        // Cast a ray and get a surface fragment\n        vec3 p, n = vec3(0.0);\n        int id = castRay(o, r, n, p);\n        \n        // Set new positions\n        p += n * EPS;\n        \n        // Get a surface fragment\n        SurfFrag Surf = surface(id, p);\n        \n        // Gather incoming light\n        vec3 incLight = directLight(p, n);\n        \n        // Light attenuation\n        if (id != 0)\n        {\n        \tattenuation *= Surf.surface;\n        \temission += Surf.emission + incLight;\n        }\n        else\n        {\n            // Image-based lighting\n            emission += texture(iChannel1, r).rgb;\n            break;\n        }\n        \n        // Diffuse light path\n        vec3 vDiff = normalize(R3D(p + iTime + iSample) * 2.0 - 1.0);\n        \n        // Refraction probability\n        float fresnel = schlick(dot(n, -r), Surf.ior);\n        float nv = noisev(p.x + p.y + p.z + iTime + iSample);\n        \n        // Default is reflection\n        vec3 vRef = reflect(r, n);\n        \n        // If the object is refractive, refract if nv > fresnel\n        if (nv > fresnel)\n        {\n            p -= 2.0 * n * EPS;\n            vRef = refract(r, n, prevIor / Surf.ior);\n        }\n        \n        // Mix between them\n        r = mix(vRef, vDiff, Surf.roughness);\n        o = p;\n        \n        // Set previous data\n        if (Surf.ior > 0.0) prevIor = Surf.ior;\n        else prevIor = 1.0;\n    }\n    \n    return attenuation * emission;\n}\n\n/////////////////////////////////////////////////\n//                                             //\n//              IMAGE PROCESSING               //\n//                                             //\n/////////////////////////////////////////////////\n\n\n// Add movement\nvec3 getPosition()\n{\n    // Check the position in the data buffer\n    return texelFetch(iChannel2, ivec2(0, 0), 0).xyz;\n}\n\n// Movement flag\nfloat moveFlag()\n{\n    // Fetch the flag at (0, 1).x\n    return texelFetch(iChannel2, ivec2(0, 1), 0).x;\n}\n\n// Get y rotation\nvec2 getRotation()\n{\n    // Fetch y-rotation at (0, 1).y\n    return texelFetch(iChannel2, ivec2(0, 1), 0).yz;\n}\n\n// Main image construction\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Setup co-ordinates\n    vec2 uv = (fragCoord / iResolution.xy * 2.0 - 1.0) * aspectmult;\n    \n    // Normalised mouse position\n    vec2 mp = (iMouse.xy / iResolution.xy * 2.0 - 1.0) * aspectmult;\n    \n    // Base ray properties\n    vec3 camPos = getPosition();\n    vec3 o = vec3(camPos.x * 3.0 + 0.05, 0.7 + camPos.y * 3.0, camPos.z * 3.0 - 3.0);\n    //if (iMouse.xy == vec2(0.0)) o = vec3(0.05, 0.5, -3.0);\n    vec3 r = normalize(vec3(uv, 0.58 * PI));\n    \n    #ifdef FAKE_AA\n    // Add a random offset to the ray\n    r = normalize(r + R3D(o + r * (iTime + 1.0)).xzy * 0.002);\n    #endif\n    \n    // Rotate the view\n    vec2 rot = getRotation();\n    r.yz *= mat2(cos(rot.x), -sin(rot.x), sin(rot.x), cos(rot.x));\n    r.xz *= mat2(cos(rot.y), -sin(rot.y), sin(rot.y), cos(rot.y));\n    \n    // Setup colour. Since we are only really doing one thing per iteration\n    // of this for loop, we can swap the last statement (n++) with the code\n    // that runs for every step, and replace 'n < SAMPLES' with 'n++ < SAMPLES'\n    vec3 col = vec3(0.0);\n    for (float n = 0.0; n++ < SAMPLES; col += color(o, r, n) / SAMPLES){}\n    \n    // Output to screen\n    #ifdef NOISY\n    vec3 prevFrame = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    fragColor = vec4(mix(col, prevFrame, 0.25), 1.0);\n    #else\n    float moveFlag = (1.0 - step(0.5, moveFlag()));\n    float mouseFlag = (1.0 - step(0.5, iMouse.z));\n    // Thanks to a comment on https://www.shadertoy.com/view/XtyXW1 - neatened it\n    // up a little and removed the 'if' statement.\n    vec4 prevFrame = texture(iChannel0, fragCoord / iResolution.xy) * moveFlag * mouseFlag;\n    fragColor = vec4(col, 1.0) + prevFrame;\n    #endif\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//////////////////////////////////////////////////\n//                                              //\n//  Another experiment in path tracing. This    //\n//  time I'm trying to improve on my previous   //\n//  one. Various things have been added too.    //\n//  Buffer B here is the 'data' buffer, which   //\n//  stores data on player position, rotation    //\n//  and possibly other things.                  //\n//                                   - Noxbuds  //\n//                                              //\n//////////////////////////////////////////////////\n\n// Values\n#define PI 3.14159\n#define EPS 1e-5\n\n// Macros\n#define tex(x, y) texelFetch(iChannel0, ivec2(x, y), 0)\n#define getKey(n) texelFetch(iChannel1, ivec2(n, 0), 0).x\n#define getKeyDown(n) texelFetch(iChannel1, ivec2(n, 1), 0).x\n\n// Keys\n#define KEY_LEFT 37\n#define KEY_UP 38\n#define KEY_RIGHT 39\n#define KEY_DOWN 40\n#define KEY_W 87\n#define KEY_A 65\n#define KEY_S 83\n#define KEY_D 68\n#define KEY_SPACE 32\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 data = tex(0, 0);\n    \n    // Old mouse position\n    vec2 oldMouse = iMouse.zw / iResolution.xy;\n    vec2 newMouse = iMouse.xy / iResolution.xy;\n    vec2 dragDiff = newMouse - oldMouse;\n    \n    ////////////////////////////////////////////////////////\n    // Player rotation                                    //\n    ////////////////////////////////////////////////////////\n    vec2 rot = tex(0, 1).yz;\n    \n    // Get y-rotation speed\n    float yrVel = newMouse.x - oldMouse.x;//getKey(KEY_RIGHT) - getKey(KEY_LEFT);\n    yrVel *= step(0.5, iMouse.z);\n    \n    // Get x-rotation speed\n    float xrVel = newMouse.y - oldMouse.y;\n    xrVel *= step(0.5, iMouse.z);\n    \n    // Rotate\n    rot -= vec2(xrVel, yrVel);// * 0.025;\n    \n    ////////////////////////////////////////////////////////\n    // Player position                                    //\n    ////////////////////////////////////////////////////////\n    vec3 pos = tex(0, 0).xyz;\n    \n    // Get the velocity\n    float vHorizontal = getKey(KEY_RIGHT) - getKey(KEY_LEFT) + getKey(KEY_D) - getKey(KEY_A);\n    float vVertical = getKey(KEY_UP) - getKey(KEY_DOWN) + getKey(KEY_W) - getKey(KEY_S);\n    \n    // Clamp velocity\n    vec2 vel = vec2(clamp(vHorizontal, -1.0, 1.0), clamp(vVertical, -1.0, 1.0));\n    \n    // Rotate velocity\n    float yrot = rot.y + 0.5 * PI;\n    vec2 velocity = vel;\n    velocity.x = vel.y * cos(yrot) + vel.x * cos(yrot - 0.5 * PI);\n    velocity.y = vel.y * sin(yrot) + vel.x * sin(yrot - 0.5 * PI);\n    \n    // Move the object\n    pos.xz += velocity * 0.01;\n    \n    ////////////////////////////////////////////////////////\n    // Player jumping                                     //\n    ////////////////////////////////////////////////////////\n    \n    // Upwards velocity (jumping) is stored in data(0, 0).w\n    float upVel = tex(0, 0).w;\n    \n    // If upwards velocity is zero, and we press the jump key,\n    // set an upward velocity\n    if (upVel <= EPS && getKeyDown(KEY_SPACE) > 0.0) upVel = 0.08;\n    \n    // Downwards acceleration is 10 m/s^2\n    upVel -= 0.3 * iTimeDelta;\n    \n    // Update player position based on upwards velocity\n    pos.y += upVel;\n    if (pos.y <= EPS)\n    {\n        pos.y = 0.0;\n        upVel = 0.0;\n    }\n    \n    ////////////////////////////////////////////////////////\n    // Store data                                         //\n    ////////////////////////////////////////////////////////\n    \n    // Only store the following data at (0, 0)\n    if (ivec2(fragCoord) == ivec2(0))\n    {\n    \t// Store player position\n        data.xyz = pos;\n        \n        // Store upwards velocity\n        data.w = upVel;\n    }\n    // Only store the following data at (0, 1)\n    else if (ivec2(fragCoord) == ivec2(0, 1))\n    {\n        // Store a flag (0 | 1) if the player has moved this frame\n        data.x = step(EPS, abs(velocity.x)) + step(EPS, abs(velocity.y));\n        //if (abs(upVel) > 0.0) data.x = 1.0;\n        data.x += step(EPS, abs(upVel));\n        \n        // Store y rotation\n        data.yz = rot;\n    }\n    \n    // Output data\n    fragColor = data;\n}","name":"Buffer B","description":"","type":"buffer"}]}