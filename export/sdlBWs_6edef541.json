{"ver":"0.1","info":{"id":"sdlBWs","date":"1645570593","viewed":129,"name":"avoidance","username":"formographik","description":"avoidance with light and shadows","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"sdsfDl","parentname":"bouncy guy tutorial"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// A shader by Nicole Vella. (2022)\n// @nicole.vella.art\n// www.nicolevella.com\n//\n// Attribution 4.0 International (CC BY 4.0)\n// This work is licensed under a Creative Commons Attribution 4.0 International License. \n// http://creativecommons.org/licenses/by/4.0/\n\n#define PI 3.14159265359\n#define AA 2\n#define BLUR 8.\n\nmat2 rot (float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\nfloat sphereSDF(vec3 p, float s) { \n    return length(p) - s;\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nfloat map(in vec3 pos, float time) {\n\n\tpos.xz *= rot(time*.1);\n\tpos.xy *= rot(time*.2);\n\n    vec3 pos2 = pos;\n    vec3 pos3 = pos;\n    vec3 pos4 = pos;\n  \n  \tpos2.xz *= rot(PI*.5);\n\tpos2.xy *= rot(PI*.75);\n\tpos2.yz *= rot(PI*.75);\n\t\n\tpos3.xz *= rot(PI*.75);\n\tpos3.xy *= rot(PI*.25);\n\n\tpos4.xz *= rot(PI*.25);\n\tpos4.xy *= rot(PI*.65);\n\tpos4.yz *= rot(PI*.5);\n     \n    float off = .4525;\n    float size = 0.04 + 0.07 * (sin(-time) * .5 + .5);\n    \n    float S = sin(time);\n    float C = cos(time);\n\n    float s0 = sphereSDF(pos,off - size + 0.0025);\n        \n    float s1 =\n    sphereSDF(vec3(pos.x + S * off,pos.y + C * off,pos.z), size);\n\t\n    float s2 =\n    sphereSDF(vec3(pos.x,pos.y - C * off,pos.z + S * off), size);\n\t\n    float s3 =\n    sphereSDF(vec3(pos.x - S * off, pos.y, pos.z + C * off), size);\n\t\n\tfloat s4 =\n    sphereSDF(vec3(pos2.x + S * off, pos2.y + C * off, pos2.z), size);\n\t\n    float s5 =\n    sphereSDF(vec3(pos3.x, pos3.y - C * off, pos3.z + S * off), size);\n\t\n    float s6 =\n    sphereSDF(vec3(pos4.x - S * off, pos4.y, pos4.z + C * off), size);\n        \n    float spheres = min(min(min(min(min(min(s0,s1),s2),s3),s4),s5),s6);\n    \n    return spheres;\n}\n\n\nvec3 calcNormal( in vec3 p, float time )\n{\n    const float h = 0.0001;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h, time ) + \n                      k.yyx*map( p + k.yyx*h, time ) + \n                      k.yxy*map( p + k.yxy*h, time ) + \n                      k.xxx*map( p + k.xxx*h, time ) );\n}\n\nfloat castGlow (in vec3 ro, vec3 rd, float time) {\n\n    float res = 1.0;\n    float t = 0.001;\n    \n    for ( int i = 0; i < 100; i++) {\n        vec3 pos = ro + t*rd;\n        float h = map( pos, time );\n        \n        res = min( res, h/t );\n        if (res<0.0001) break;\n        \n        t += h;\n        if (t>20.) break;\n    }\n\n    return 1.-clamp(res,0.,1.0);\n}\n\n\nfloat castShadow (in vec3 ro, vec3 rd, float time) {\n\n    float res = 1.0;\n    float t = 0.001;\n    \n    for ( int i = 0; i < 100; i++) {\n        vec3 pos = ro + t*rd;\n        float h = map( pos, time );\n        \n        res = min( res, 16.0*h/t );\n        if (res<0.0001) break;\n        \n        t += h;\n        if (t>20.) break;\n    }\n\n    return clamp(res,0.,1.0);\n}\n\nfloat castRay(in vec3 ro, vec3 rd, float time) {\n    float t = 0.0;\n    for (int i=0; i<100; i++) {\n        vec3 pos = ro + t*rd;\n        \n        float h = map( pos, time );\n        \n        if (h<0.001) break;\n        t += h;\n        if( t>20.0 ) break;\n        \n    }\n    if ( t>20.0) t=-1.0;\n    return t;\n}\n\nvec3 Render(vec2 p, float time) {\n    vec3 ro = vec3(0.0,0.0,1.0);\n    vec3 rd = normalize( vec3(p,-1.5) );\n    \n    \n    vec3 col = vec3(0.4,0.75, exp(rd.y*.5)) - .7 * rd.y;\n    \n//    col = vec3(0.0);\n    \n    col *= 1.-length(p)*.33;\n   \n    \n    float t = castRay( ro, rd, time );\n  \n    if ( t>0.0 ) {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos, time);\n \n        vec3 matte = vec3(0.2, 0.2, 0.2);\n        \n        //float f = step(sin(88.0*pos.x)*sin(88.0*pos.y),.0);\n        //matte += f;\n\n        vec3 sun_dir = normalize( vec3(0.8,0.4,0.2) );\n        float sun_dif = clamp( dot(nor,sun_dir),0.0,1.0);\n        float sun_sha = castShadow( pos+nor*0.001, sun_dir, time );\n\n        float glow = castGlow( pos+nor*0.001, ro, time );\n\n        float sky_dif = clamp( 0.5 + 0.5 * dot(nor,vec3(0.0,1.0,0.0)),0.0,1.0);\n        float bou_dif = clamp( 0.5 + 0.5 * dot(nor,pos*vec3(0.0,-1.0,0.0)),0.0,1.0);\n               \n        col  = matte*vec3(7.0,4.5,3.0) * sun_dif * sun_sha;\n        col += matte*vec3(0.5,0.8,0.9) * sky_dif;\n        col += matte*vec3(0.7,0.3,0.2) * bou_dif;\n        \n        col += matte*vec3(1.7,0.5,0.5) * glow;\n        \n    }\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n   vec3 col = vec3(0.0);\n   vec3 tot = vec3(0.0);\n\n  #if AA>1\n  \n    for( int m=0; m<AA; m++ ) {\n    for( int n=0; n<AA; n++ ) {\n      vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n      vec2 uv = (2.0*(fragCoord.xy+o)-iResolution.xy)/min(iResolution.x, iResolution.y);\n      \n      float dd = 0.5+0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n      float time = iTime - 0.5*(1.0/BLUR)*(float(m*AA+n)+dd)/float(AA*AA);\n      col = Render((uv ), time);  \n\n  #else    \n  \n      vec2 uv = (2.0*fragCoord.xy-iResolution.xy)/min(iResolution.x, iResolution.y);\n      float time = iTime;\n      col = Render(uv, time);  \n      \n  #endif\n   \n  tot += pow(col,vec3(0.45) );\n   \n  #if AA>1\n    }\n    }\n    tot /= float(AA*AA);\n  #endif\n    \n  fragColor = vec4(tot,1.0);\n}","name":"Image","description":"","type":"image"}]}