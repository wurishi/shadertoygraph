{"ver":"0.1","info":{"id":"ltsfDs","date":"1514171074","viewed":327,"name":"an actual raymarcher","username":"ehsuun","description":"a simple actual raymarcher","likes":5,"published":1,"flags":4,"usePreview":0,"tags":["raymarcher"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGRr","filepath":"/presets/mic.png","previewfilepath":"/presets/mic.png","type":"mic","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MARCHING_STEPS = 128;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 500.0;\nconst float EPSILON = 0.1;\nconst float PI = 3.14159265359;\n\n// material parameters\n vec3 albedo;\n float metallic;\n float roughness;\n float ao;\n\n// lights\nvec3 lightPositions[1];\nvec3 lightColors[1];\n\n\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 );\n    return min( a, b ) - h*h*0.25/k;\n}\n\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\n\n\nfloat rand(vec2 c){\n\treturn fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise(vec2 p, float freq ){\n\tfloat unit = iResolution.x/freq;\n\tvec2 ij = floor(p/unit);\n\tvec2 xy = mod(p,unit)/unit;\n\t//xy = 3.*xy*xy-2.*xy*xy*xy;\n\txy = .5*(1.-cos(PI*xy));\n\tfloat a = rand((ij+vec2(0.,0.)));\n\tfloat b = rand((ij+vec2(1.,0.)));\n\tfloat c = rand((ij+vec2(0.,1.)));\n\tfloat d = rand((ij+vec2(1.,1.)));\n\tfloat x1 = mix(a, b, xy.x);\n\tfloat x2 = mix(c, d, xy.x);\n\treturn mix(x1, x2, xy.y);\n}\n\nfloat pNoise(vec2 p, int res){\n\tfloat persistance = .5;\n\tfloat n = 0.;\n\tfloat normK = 0.;\n\tfloat f = 4.;\n\tfloat amp = 1.;\n\tint iCount = 0;\n\tfor (int i = 0; i<50; i++){\n\t\tn+=amp*noise(p, f);\n\t\tf*=2.;\n\t\tnormK+=amp;\n\t\tamp*=persistance;\n\t\tif (iCount == res) break;\n\t\tiCount++;\n\t}\n\tfloat nf = n/normK;\n\treturn nf*nf*nf*nf;\n}\n\nfloat ripple(vec3 pin){\n    vec3 p = pin;\n    p.x-=-0.5+iMouse.x*1.0/iResolution.x;\n    p.y-=-0.5+iMouse.y*1.0/iResolution.y;\n \tfloat z =-0.0 +sin(30.0*(p.x*p.x+p.y*p.y)-iTime*10.0)/100.0;\n    return z;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sphereSDF (vec3 point){\n    return length(point) -0.08;\n}\n\nfloat sampleMusic() {\n\treturn 0.5*(\n\t\ttexture( iChannel2, vec2( 0.1, 0.25 ) ).x+\n        texture( iChannel2, vec2( 0.3, 0.25 ) ).x\n        \n        );\n}\n\nfloat sampleMusic2() {\n\treturn 0.5*(\n\t\ttexture( iChannel2, vec2( 0.6, 0.25 ) ).x+\n        texture( iChannel2, vec2( 0.9, 0.25 ) ).x\n        \n        );\n}\n\n\nfloat displacement(vec3 p){\n     \n    float f = -pNoise(p.xz*10.0+iTime*50.2,8)*sampleMusic()*10.0;\n    //f=0.0;\n    f+= -pNoise(-p.xz*10.0+iTime*50.8f,4)*sampleMusic2()*15.0;\n    return(f);\n}\n\nfloat displacement2(vec3 p){\n    float f = sin(3.0*p.x)*sin(3.0*p.y)*sin(3.0*p.z);\n    //f+= cos(sampleMusic()*p.x)*cos(sampleMusic()*p.y)*cos(sampleMusic()*p.z);\n return f ;\n}\n\n\n\nfloat opRep( vec3 p, vec3 c )\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return sphereSDF( q );\n}\n\nfloat opDisplace( vec3 p )\n{\n    float d1 = sdPlane(p,vec4(0.0,1.0,0.0,6.0));\n    float d2 = displacement(p);\n    return d1+d2;\n}\n\nfloat dancingShere(vec3 point){\n\t float sp = length(point-vec3(0.0,-1.0+sampleMusic2()*5.0,-50.0)) -2.0+-4.0*sampleMusic();\n    sp += displacement2(point)*0.3*sampleMusic();\n    return sp;\n}\n\nfloat scene(vec3 point) {\n\tfloat a1 = dancingShere(point);\n    float a2 = opDisplace(point);\n    return smin( a1, a2,4.1 );\n}\n\n\n\nfloat raymarch(vec3 cam, vec3 dir, float start, float end){\n    float depth = start;\n    for (int i = 0; i<MAX_MARCHING_STEPS;i++){\n     float dist = scene(cam+depth*dir);\n        if(dist<EPSILON){\n         \treturn depth;   \n        }\n        depth += dist;\n        if(depth>=end){\n         \treturn end;   \n        }\n    }\n    return end;  \n}\n\n\nvec3 raydir(in float fov,in vec2 size, in vec2 mfragCoord){\n    vec2 xy = mfragCoord - size / 2.0;\n    float z = size.y / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        scene(vec3(p.x + EPSILON, p.y, p.z)) - scene(vec3(p.x - EPSILON, p.y, p.z)),\n        scene(vec3(p.x, p.y + EPSILON, p.z)) - scene(vec3(p.x, p.y - EPSILON, p.z)),\n        scene(vec3(p.x, p.y, p.z  + EPSILON)) - scene(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n////////////////////////////// fresnelSchlickRoughness From LEARNINGOPENGL.COM\n\n// ----------------------------------------------------------------------------\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness)\n{\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n\n}   \n\n\n\n\nvec4 shade(in float id,in highp vec3 WorldPos,in vec3 dir){\n    \n    vec3 N = estimateNormal(WorldPos);\n    vec3 V = normalize(-dir);\n    vec3 R = reflect(-V, N);\n    lightPositions = vec3[](vec3(2.0,3.0,2.0));\n\n  \n    vec3 F0 = vec3(0.01); \n    F0 = mix(F0, albedo, metallic);\n    \n    // reflectance equation\n    vec3 Lo = vec3(0.0);\n    \n    // ambient lighting (we now use IBL as the ambient term)\n    vec3 F = fresnelSchlickRoughness(max(dot(N, V), 0.0), F0, roughness);\n    vec3 kS = F;\n    vec3 kD = 1.0 - kS;\n    \n\n\n    const float MAX_REFLECTION_LOD = 4.0;\n    vec3 specular = textureLod(iChannel0, R,  roughness * MAX_REFLECTION_LOD).rgb;    \n    vec3 ambient;\n\n\talbedo = vec3(0.1,0.6+pNoise(WorldPos.xz,1)*0.5,0.4+pNoise(WorldPos.xz*10.0+vec2(123.,23345.0),1)*0.5);\n    albedo = vec3(0.0,.2,0.0);\n    //albedo = texture( iChannel1, vec2( sampleMusic()*0.5, sampleMusic2()*0.5 ) ).xyz; \n    \n    float dif = clamp(dot(N,lightPositions[0]),0.0,1.0);\n    ao = 0.5 + 0.5*N.y;\n    ambient = ( albedo*vec3(0.1,0.2,0.4)*ao)*(1.0-metallic) + metallic*specular;\n    \n    vec3 color = ambient*kD + F*specular*ao;\n    // HDR tonemapping\n    color = color / (color + vec3(1.0));\n    // gamma correct\n    color = pow(color, vec3(1.0/2.2)); \n    \n    vec4 col = vec4(color,1.0);\n    return col;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    albedo = vec3(.3,0.1,0.1);\n    metallic = 0.0;\n    roughness = 0.0;\n    ao  = 1.0;\n    \n    float time = mod(iTime,10.0*PI);\n    vec3 dir = raydir(45.0,iResolution.xy,fragCoord);\n    //vec3 cam = vec3(2.*cos(iTime), 2.*sin(iTime), -iTime*50.0 + 500.0);\n\tvec3 cam = vec3(0.0, 0.0, -10.0);\n    \n    float dist = raymarch(cam, dir, MIN_DIST, MAX_DIST);\n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    //  closest point\n    highp vec3 p = cam + dist * dir;\n    \n\tfragColor = shade(1.0,p,dir);\n    fragColor/=(max(length(cam-p)*0.01,1.0));\n}\n\n","name":"Image","description":"","type":"image"}]}