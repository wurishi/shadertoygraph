{"ver":"0.1","info":{"id":"XXlGRH","date":"1707146155","viewed":97,"name":"Simple Random Tile Connections","username":"chronos","description":"Simple Random Tile Connections Pattern.\nSee description in Image buffer.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["simple","grid","basic","animated","pattern","tile","tiles","wang"],"hasliked":0,"parentid":"lf2SWy","parentname":"Simple Grid Dot Pattern"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n    Simple Random Tile Connections Pattern by chronos\n    \n        Uses a random grid cell pattern to determine which way tiles should be connected.\n        \n        \n        The principle is just that each tile is determined by the values on their edges,\n        which are determined by a random noise function. \n        \n        Care has to be taken to ensure that neighboring cells agree on the value of their shared edge.\n        (See the tile_edge_hashes() function for this)\n        \n        This can be seen as a simple special caase of wang tiles, \n        namely as an unconstrained / full tileset of binary edge colored wang tiles.\n        \n        Drawing the connections can be done in a variety of ways, but here I just opted to\n        draw simple line segments from the center of each tile to its connected borders.\n        \n        See also:\n        https://www.shadertoy.com/view/ttXSzX by Shane, which uses the same method.\n        or search for 'wang tiles' :)\n        \n*/\n\n// This determines the density [0,1].\n// Lower value makes it more likely to pass, giving higher density, and vice versa.\n// This can be varied by a larger scale pattern, or noise, to create variable density in regions.\n// Another extension is that threshold valuess also could be different between vertical and horizontal borders.\nconst float threshold = 0.5; \n\nconst float grid_dim = 5.; // number of cells in height and width per UV coordinate.\n\n#define SHOW_GRID_BORDERS 0\n\n// This is used to read the values of four neighbor edges of a random cell grid.\n// \nvec4 tile_edge_hashes(vec2 cell_idx)\n{\n    // This is a little trick to be able to write offsets in terms of +/-1 instead of +/- 0.5\n    // in order to sample edges.\n    cell_idx *= 2.;\n    \n    vec4 animation_offsets = vec4\n    (\n        hash(vec3(cell_idx+vec2(-1, 0), 0.)), // left\n        hash(vec3(cell_idx+vec2( 1, 0), 0.)), // right\n        hash(vec3(cell_idx+vec2( 0,-1), 0.)), // bottom\n        hash(vec3(cell_idx+vec2( 0, 1), 0.))  // top\n    );\n    \n    // can just set this to zero (vec4(0)) if you want a static pattern.\n    // In this case, the animation offsets above are not needed.\n    vec4 animations = floor(iTime*0.125 + animation_offsets);\n    \n    return vec4\n    (\n        hash(vec3(cell_idx+vec2(-1, 0), animations.x)), // left\n        hash(vec3(cell_idx+vec2( 1, 0), animations.y)), // right\n        hash(vec3(cell_idx+vec2( 0,-1), animations.z)), // bottom\n        hash(vec3(cell_idx+vec2( 0, 1), animations.w))  // top\n    );\n}\n\nfloat seg(vec2 a, vec2 b, vec2 p) // distance from p to line segment from a to b.\n{\n    b-=a; p-=a;\n    return length(clamp(dot(p,b)/dot(b,b), 0., 1.) * b - p);\n}\n\nfloat tile_pattern(vec2 p)\n{\n    vec2 cell_idx = floor(p); \n    vec2 cell_uv = fract(p);\n\n    vec4 tile_edges = floor(step(threshold, tile_edge_hashes(cell_idx)));\n    \n    // Compute 4 line segment distances\n    vec4 d = vec4(\n        seg(vec2( 0,.5), vec2(.5), cell_uv), // left\n        seg(vec2( 1,.5), vec2(.5), cell_uv), // right\n        seg(vec2(.5, 0), vec2(.5), cell_uv), // bottom\n        seg(vec2(.5, 1), vec2(.5), cell_uv)  // top\n    );\n    \n    // soft threshold the distances to create alpha values,\n    // then multipy with the edge indicators to mask out the ones that should not be drawn\n    vec4 a = smoothstep(0.075, 0.05, d) * tile_edges;\n    \n    // Combine the four line segment alphas to a single alpha value\n    float alpha = max(max(a.x, a.y), max(a.z, a.w));\n        \n    return alpha; \n}\n\n// This is just for visuals. From the forked shader.\nfloat dot_grid_pattern(vec2 p)\n{\n    vec2 cell_idx = floor(p);\n    \n    // can just remove these if you want a static pattern\n    float animation_offset = hash(vec3(cell_idx, 0.));\n    float animation = floor(iTime*.125 + animation_offset); \n    \n    float rnd = hash(vec3(cell_idx, animation));\n    vec2 q = .5 + .5*cos(2.*PI * p - PI);\n    return (q.x * q.y) * float(rnd > 0.5); // Last factor is the binary thresholded noise that is used as a mask\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n    vec2 mouse = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    if(length(iMouse.xy) < 10.) mouse.xy = vec2(0, max(sin(iTime), 0.));\n\n    float zoom = 1. + mouse.y;\n\n    vec3 color = vec3(0);\n    \n    // Grid coordinates. Zooming and animation with time are optional.\n    // Just using grid_dim and/or uv directly is fine.\n    vec2 p = grid_dim * (zoom * uv + iTime*.25); // animated grid coordinates\n    \n    // Draw the tile pattern!\n    color += tile_pattern(p);\n    \n    #if SHOW_GRID_BORDERS\n        vec2 q = pow(fract(p), vec2(40.)) + pow(1.-fract(p), vec2(40.));\n        color = mix(color, vec3(0,0,1), dot(q, vec2(.1)));\n    #endif\n    \n    // Just decor\n    color += 0.01 * dot_grid_pattern(2.*p);\n    \n    color = pow(color, vec3(1./2.2));\n    fragColor = vec4(color, 1.0);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = 3.14159265;\n\nfloat hash(vec3 uv)\n{\n    uint x = floatBitsToUint(uv.x) | 1u; // 0 is a fixed point so we remove it. although this introduces duplicate 1\n    uint y = floatBitsToUint(uv.y);\n    uint z = floatBitsToUint(uv.z);\n    \n    y ^= y >> 13;\n    y ^= y << 17;\n    y ^= y >> 5;\n    y *= 0x2545F491u;\n\n    x ^= y;\n    x ^= x >> 13;\n    x ^= x << 17;\n    x ^= x >> 5;\n    x *= 0x4F6CDD1Du;\n    \n    z ^= x;\n    z ^= z >> 13;\n    z ^= z << 17;\n    z ^= z >> 5;\n    z *= 0x1D6C45F4u;\n    \n    // Shift down by 9 to use top 23 bits in mantissa\n    // Use exponent and sign bits from 0.5\n    // floatBitsToUint(.5) is a constant so that part can be pre-computed. (0x3f000000)\n    // Since the top 23 bits are shifted right, the rest (top bits) are zero and do not need to be masked out\n    // uint w = ((z>>9) & 0x007FFFFFu) | (0xFF800000u & floatBitsToUint(.5));\n    \n    uint w = (z>>9) | 0x3f000000u; // simplified version of the above commented out line\n    \n    // re-normalize from [0.5, 1) to [0, 1)\n    // This probably loses some bits, but should still be ok\n    return 2. * uintBitsToFloat(w) - 1.;\n}\n","name":"Common","description":"","type":"common"}]}