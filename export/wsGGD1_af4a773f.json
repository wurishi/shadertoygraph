{"ver":"0.1","info":{"id":"wsGGD1","date":"1570090770","viewed":290,"name":"gmaj7","username":"nabr","description":"123","likes":11,"published":1,"flags":8,"usePreview":0,"tags":["3d","raymarching","bumpmapping","technique","parallaxmapping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// for my own educational purposes copy+pasted some stuff\n// -----------------------------------------------------\n// Parallax mapping by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/4lSGRh\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n// -----------------------------------------------------\n\n\nfloat tex(vec3 px)\n{\n    float z = 1., f = 0.;\n    for (int i = 0; i < 2; i++)\n    {\n        vec3 p = px;\n        p *= 4.5;\n        for (float i = .5; i > 0.; i -= .125)\n        {\n            float u = floor(p).x + (floor(p).y * 10.);\n            vec4 v = vec4(u, u + 1., u + 10., u + 11.);\n            // v = fract(.5 + fract(1.5701 * v) * v * 870.369);\n            v = fract(.5 + fract(1.57 * v) * v * 870.);\n            f += i * mix(mix(v.x, v.y, fract(p.x)), mix(v.z, v.w, fract(p.x)), fract(p.y));\n            p.xy *= mat2(.314, 1, -1, .341) + f * f;\n        }\n        px *= .125 + (exp(-.25 * (mod(iTime, 12.))));\n        z *= -1.1;\n        f /= z;\n    }\n    return clamp(f * f * 2.5, 0., 1.) * 2. - 1.;\n}\n// The amount of parallax\n#define PARALLAX_SCALE .12\n#define OFFSET_SCALE 1.\n// Bump mapping intensity\n#define BUMP_STRENGTH .125\n#define BUMP_WIDTH 0.0014\nvec3 prlpos(in vec3 p, in vec3 n, in vec3 rd)\n{\n    vec3 tgt = n * dot(rd, n) - rd; // Optimized\n    tgt /= (abs(dot(tgt, rd))) + OFFSET_SCALE;\n    p += tgt * tex(p) * PARALLAX_SCALE;\n    return p;\n}\n\nfloat btex(in vec3 p)\n{\n    float rz = tex(p);\n    rz += tex(p) * 1.1;\n    return rz;\n}\n\nvec3 bump(in vec3 p, in vec3 n, in float ds)\n{\n    vec2 e = vec2(BUMP_WIDTH * sqrt(ds) * 0.5, 0);\n    float n0 = btex(p);\n    vec3 d = vec3(btex(p + e.xyy) - n0, btex(p + e.yxy) - n0, btex(p + e.yyx) - n0) / e.x;\n    vec3 tgd = d - n * dot(n, d);\n    n = normalize(n - tgd * BUMP_STRENGTH * 8. / (ds));\n    return n;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\tvec3 q=abs(p)-b;\n    return min(0.,max(q.x,max(q.y,q.z)))+length(max(q, 0.));\t\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 col = vec3(0);\n    vec2 p = 2.0 * fragCoord.xy / iResolution.xy - 1.;\n    //--------camera\n    vec3 ro = vec3(0.001, 0.001, -5.);\n    vec3 lookAt = vec3(0);\n    if (mod(iTime, 8.) > 4.)\n    {\n        ro = vec3(0.001, sin(.5 * iTime) - .001, 5.);\n        lookAt = vec3(cos(.5 * iTime) * .5 + .5, 0, 0);\n    }\n    vec3 up = vec3(0, 0, 1);\n    vec3 g = normalize(lookAt - ro);\n    vec3 u = normalize(cross(g, up));\n    vec3 v = normalize(cross(u, g));\n    float aspect = (iResolution.x / iResolution.y);\n    float angel = 50.0; //+(1.0 - dot(p, p) * 1.125)\n    u = u * tan(radians(angel * 0.5));\n    v = v * tan(radians(angel * 0.5)) / aspect;\n    vec3 rd = normalize(g + p.x * u + p.y * v);\n    //--------raymarch\n    float precis = 0.001;\n    float h = precis * 2.0;\n    float d = 0.;\n\t#define map(p) sdBox(p, vec3(1, 1, -.1))\n    d += h;\n    float res = map(ro + rd * d);\n    h = res;\n    d += h;\n    res = map(ro + rd * d);\n    h = res;\n    d += h;\n    res = map(ro + rd * d);\n    h = res;\n    d += h;\n    \n    vec3 pos = ro + d * rd;\n    vec2 e = vec2(-1., 1.) * 0.0005;\n    vec3 nor = normalize(e.yxx * map(pos + e.yxx)+e.xxy * map(pos + e.xxy)+ e.xyx * map(pos + e.xyx)+e.yyy * map(pos + e.yyy));\n    pos = prlpos(pos, nor, rd);\n    float ds = distance(ro, pos);\n    nor = bump(pos, nor, ds);\n    //--------shade\n    vec3 ligt = normalize(vec3(5. * cos(.2 * iTime), 2. * sin(.6 * iTime), 20.));\n    float tx = tex(pos);\n    col = (nor.y + tx * 1.2 + 1.2) * cos(vec3(0, 3.14, 3) + iTime + 6.28);\n    col += pow(clamp(dot(reflect(rd, nor), ligt), 0.0, 1.0), 150.) * (.2 + sqrt(d*vec3(1.1,.98,.05)));\n    col = mix(col, vec3(0, .5, 1), clamp(exp(d * 0.43 - 5.), 0., 1.));\n    col *= 1.5*max(1. - abs(1.051 * p.y),0.);\n    // dither https://www.shadertoy.com/view/3tj3DW\n    col += 13. * fract(sin(gl_FragCoord.x * vec3(13, 1, 11) + p.y * vec3(1, 7, 5)) * 158.391832) / 255.0;\n    col = clamp(col * 1.05, 0., 1.);\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// https://www.shadertoy.com/view/wsGGD1\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://creativecommons.org/licenses/by-nc-sa/3.0/\n\n\n\n\n// adsr https://www.shadertoy.com/view/WsX3R4\nfloat adsr(float t, vec4 e, float s)\n{\n    return max(0.0, min(1.0, t / max(0.0001, e.x))\n            - min((1.0 - s), max(0.0, t - e.x) * (1.0 - s) / max(0.0001, e.y))\n            - max(0.0, t - e.z) * s / max(0.0001, e.w));\n}\nfloat square(float f){return sign(fract(f) - 0.5);}\n\n\n// snare\nfloat snare(in float rt)\n{\n  \tfloat tm = fract(rt);\n    uint c = uint(rt);\n    uint _ = 0u, x = 1u;\n    uint beat[]=uint[](x,_,x,_,x,_,x,x,_,x);\n    float d = 0.;\n    d += .05 * square(2763.0 * tan(rt * 80.0)) \n        \t* adsr(tm, vec4(0.01, .02, 0.013, 0.15), 0.5);\n    d += .5*sin(rt*829.)* exp(-20. * tm);\n    d *= min(1., 40. * tm) * max(0., 1. - tm);\n    if (!bool(beat[c % uint(beat.length())]))d *= 0.;\n    return d;\n}\n \nvec2 synth(float rt, float tm)\n{\n    tm = fract(rt); \n    float tau = 6.2831;\n    float b[]= float[](1.5, 2., 1., 1.7);\n    float m = b[(uint(rt)%4u)];\n    tau=m*tau; \n    vec4 gmaj7 = vec4(97.9989, 184.9972,246.9416, 293.6648);\n    vec2 snd = vec2(1.);\n    snd*= (.25 *(sin(tau * gmaj7.x * rt)\n                 + sin(tau * gmaj7.y * rt)\n                 + sin(tau * gmaj7.z * rt)\n                 + sin(tau * gmaj7.w * rt )) * exp(-1.0 * tm) );\n\tsnd *= min(1., 32. * tm ) * max(0., 1. - tm);\n    return snd;\n}\n\nvec2 mainSound( in int samp, float time )\n{\n    // A 440 Hz wave that attenuates quickly overt time\n    // return vec2( sin(6.2831*440.0*time)*exp(-3.0*time) );\n\n   \t//random time\n    #define mtime (gl_FragCoord.x+gl_FragCoord.y*512.)*.00002267;\n    #define rndp(rng, maxval) (1315313u % (rng + 1u)) % maxval   \n    if(mod(time, 5.)>3.)time=.5*-mtime; \n    time = time+1.*float(uint(.25*time)%5u);\n  \n    // kick\n    float kt = fract(2. * time);\n    float k = cos(210. * kt - 24. * exp(-24. * kt)) * exp(-2. * kt)\n        * adsr(kt, vec4(.05, .4, .1, .1), 0.0);\n    k *= float(int[](1,0)[uint(1. * time) % 2u]);\n\n    vec2 wd =vec2(snare(3.333*time));\n    vec2 wd1 = wd; \n\n    float b = time;\n    vec2 mst = vec2(synth(b+.0001 , .5 * b).x, \n                    synth(b+.0005 , .5 * b).y); \n    // rev https://www.shadertoy.com/view/XldcRr\n    vec2 rev = vec2(1); \n    float ivR = 1. / 12.5, sum = 0., rand = 1., t2 = 1., amp = 1.;\n    for (float _ii = 0.; (_ii <= 1.); _ii += ivR)\n    {\n        rand = fract(120. * sin(_ii * 1000.));\n        t2 = (ivR + _ii) + .25 * rand;\n        amp = exp(-_ii * t2);\n        rev += amp * vec2(synth(b - 1. * t2, b).x, \n                          synth(b - 1. * t2, b).y);\n       \twd1 +=amp * vec2(snare(time+1.*.1*t2),snare(time-1.005*.1*t2)); \n        sum += amp;\n    }\n    rev /= sum; wd1/=sum; \n    \n   if(time*2.<12.)wd*=0.,wd1*=0.;\n   return.707*(.8*(mst *.5- + rev)+.8*vec2(k)+.6*wd+wd1); \n}","name":"Sound","description":"","type":"sound"}]}