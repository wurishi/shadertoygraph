{"ver":"0.1","info":{"id":"WdjyzG","date":"1586951108","viewed":92,"name":"Perlin Noise Max TFG","username":"MaxitoSama","description":"Trying to undertand how to generate perlin noise\n","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["perlinnoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Perlin Noise following the algorithm of this super mega reliable source\n//https://en.wikipedia.org/wiki/Perlin_noise\n#define octaves 8\n\n//Home made function\n// I hate it xD\n//Random between -1 and 1\nvec2 Hash(vec2 c)\n{\n    //Non Correlated coords\n\tfloat x = fract(sin(dot(vec2(float(c.x),float(c.y)) ,vec2(12.9898,78.233))) * 43758.5453);\n    float y = fract(sin(dot(c+0.5 ,vec2(12.9898,78.233))) * 43758.5453);\n    \n    //returning the value converted from range [0,1.0] to [-1.0,1.0]\n\treturn vec2(2.0*x-1.0,2.0*y-1.0);\n}\n\nvec2 hash( in vec2 x )  // from https://www.shadertoy.com/view/XdXGW8\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return normalize(-1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y))));\n}\n\nfloat Noise(vec2 fragCoord, float frequency)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy/iResolution.y;\n    //turnin to Range [0,10] = [0.0,..,0.1,..,0.2,....9.8,..,9.9,..,10.0]\n    uv*=10.0*frequency;\n    //Converting decimals to integers [0,0,0,.....2,2,2,....,9,9,9]\n    vec2 tile = floor(uv);\n    \n    //Bottom Left Corner\n    vec2 botLeft = tile;\t\t\t\t\t\t//Tile Coords\n    vec2 botLeftG = Hash(botLeft);\t\t\t\t//Setting Random Gradient \n    vec2 offsetBL = uv - botLeft;\t\t\t\t//Distance vector from coords to Corner (Now yes :D)\n    float dotBL=dot(botLeftG,offsetBL);\t\t\t//Dot between distance and Corner\n    \n    //Bottom Right Corner\n    vec2 botRight = tile+vec2(1.0,0.0);\n    vec2 botRightG = Hash(botRight);\n    vec2 offsetBR = uv - botRight;\n    float dotBR=dot(botRightG,offsetBR);\n    \n    //Top Left Corner\n    vec2 topLeft = tile+vec2(0.0,1.0);\n    vec2 topLeftG = Hash(topLeft);\n    vec2 offsetTL = uv - topLeft;\n    float dotTL=dot(topLeftG,offsetTL);\n    \n    //Top Left Corner\n    vec2 topRight = tile+vec2(1.0,1.0);\n    vec2 topRightG = Hash(topRight);\n    vec2 offsetTR = uv - topRight;\n    float dotTR=dot(topRightG,offsetTR);\n    \n    \n    float mixFactor_x=smoothstep(0.0,1.0,fract(uv.x)); //mix factor depending on the x coords \n    float mixFactor_y=smoothstep(0.0,1.0,fract(uv.y)); //mix factor depending on the y coords \n\n    \n    float RLBR = mix(dotBL,dotBR,mixFactor_x);\n    float TLTR = mix(dotTL,dotTR,mixFactor_x);\n    \n    float total = mix(RLBR,TLTR,mixFactor_y);\n\n    return (total+1.0)*0.5;\n}\n\n//Different Levels of Detail \nfloat PerlinNoise(vec2 fragCoord)\n{\n    float color = 0.0;\n    float a =0.5;\n    float f=1.0;\n    \n   \tfor(int i=0; i<8;i++)\n   \t{\n    \tcolor += a*Noise(fragCoord,f);\n        a*=0.5;\n        f*=2.0;\n   \t}\n    \n    return color;\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Time varying pixel color\n    vec3 col = vec3(PerlinNoise(fragCoord));\n    //vec3 col = vec3(Noise(fragCoord,1.0));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}