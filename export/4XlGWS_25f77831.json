{"ver":"0.1","info":{"id":"4XlGWS","date":"1708233272","viewed":30,"name":"Smash Ball Shader (Ricki)","username":"2024team39","description":"スマッシュボール","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["school"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Setup\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    \n//Camera Stuff\n\n// Here, cameraPos represents the position of the camera in 3D space, and cameraDir represents the direction in which the camera is looking. \n// The direction is calculated by subtracting 0.5 from uv (to center the view) and setting the z-component to 1.0 to represent the direction along the z-axis.\n\n\nvec3 cameraPos = vec3(0.0, 0.0, -4.0);\n    vec3 cameraDir = normalize(vec3(uv - 0.5, 1.0));\n\n\n\n\n//Time and Rotation \n// This block deals with time and rotation. \n// time is a variable that represents the current time (iTime) multiplied by 1.0. \n// rotateMatrix is a 2x2 rotation matrix that rotates points in 2D space by an angle determined by time. \n// Finally, uv is rotated by multiplying it with rotateMatrix.\n\n\nfloat time = iTime * 1.0;\n    mat2 rotateMatrix = mat2(cos(time), -sin(time), sin(time), cos(time));\n    uv = rotateMatrix * uv;\n\n\n\n\n//Ray Marching\n\n// This section implements ray marching to simulate ray tracing. \n// It iteratively steps along the ray (rayOrigin + dist * rayDir) and checks for intersections with a sphere. \n// The loop iterates a maximum of 100 times (for (int i = 0; i < 100; i++)) or until the distance is less than a threshold (if (sphereDist < 0.001 || dist > 100.0))\n\n\n    float dist = 0.0;\n    float minDist = 1000.0;\n    vec3 rayOrigin = cameraPos;\n    vec3 rayDir = normalize(vec3(uv - 0.5, 1.0));\n    for (int i = 0; i < 100; i++) {\n        vec3 p = rayOrigin + dist * rayDir;\n        float sphereDist = length(p) - 1.0;\n        minDist = min(minDist, sphereDist);\n        dist += 0.1; // Step size\n        if (sphereDist < 0.001 || dist > 100.0) break;\n    }\n\n\n\n\n//Coloring Stuff  \n\n// Here, t is calculated as a function of minDist, which is the distance to the nearest surface. \n// It's used to interpolate between two colors based on the distance. brightness is computed using smoothstep to control the intensity of the color. \n// Finally, some additional color modifications are applied based on time.\n\n\nfloat t = 1.0 - minDist * 2.0;\n    vec3 color = mix(vec3(1.0, 0.5 + sin(time), 0.5 + cos(time)), vec3(0.0, 0.5 + sin(time), 1.0), t);\n    float brightness = smoothstep(0.4, 1.0, t);\n    color *= brightness;\n    color += 0.1 * sin(time) * vec3(1.0, 0.5, 0.0);\n    \n    \n    \n\n//Background Color  \n\n// This part sets the background color and combines it with the final calculated color using the mix function. \n// The resulting color is assigned to fragColor, which represents the color of the current fragment being processed.\n\n\n vec3 backgroundColor = vec3(0.5, 0.5, 0.8);\n    fragColor = vec4(mix(backgroundColor, color, brightness), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}