{"ver":"0.1","info":{"id":"WscfD2","date":"1607543124","viewed":530,"name":"Ray Tracer Lesson 7","username":"omegasbk","description":"Shader made for lesson two of Darko's Gamedev Cookbook series on youtube.\nhttps://www.youtube.com/channel/DarkoSupe","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Darko (omegasbk) \n//\n// Darko's Gamedev Cookbok Youtube serial\n// https://www.youtube.com/channel/DarkoSupe\n//\n// Lesson 7\n\nstruct Material \n{\n    float diffuse;\n    float specular;\n    float shininess;\n    float ambience;\n    float reflection;\n};\n    \nconst Material material1 = Material(0.514, 0.19, 76.8, 0.7, 1.);\nconst Material material2 = Material(0.4, 0.28, 124.3, 0.2, 1.);\n\nstruct Camera\n{\n    vec3 position;\n    float focalDistance;\n};\n    \n#define SPHERES_COUNT 2\nstruct Sphere \n{\n    vec3 position;\n    vec3 color;\n    float radius;\n    Material material;\n} spheres[SPHERES_COUNT];   \n\nstruct PointLight\n{\n    vec3 position;\n    vec3 color; // Not used for now\n    float intensity;\n} lights[1];\n    \nconst Sphere sphere1 = Sphere(\n\tvec3(0.1, 0., 0.), \n    vec3(0.1, 0.1, 0.3), \n    0.08, \n\tmaterial1);\n\nconst Sphere sphere2 = Sphere(\n\tvec3(-0.1, -0.05, 0.), \n    vec3(0.3, 0.1, 0.1),  \n    0.08, \n    material1);\n\nconst Camera camera = Camera(\n    vec3(0., 0., -0.3), \n    0.6);\n\nPointLight light1 = PointLight(\n    vec3(0., 0.19, -0.2), // position\n    vec3(1., 1., 1.),     // color\n    35.);                 // intensity\n\n# define PLANES_COUNT 6\nstruct Plane \n{\n    vec3 position;\n    vec3 normal;\n    vec3 color;\n    Material material;\n} planes[PLANES_COUNT];\n\nPlane plane1 = Plane(\n    vec3(0., -0.2, 0.), \n    vec3(0., 1., 0.), \n    vec3(0.5, 0.5, 0.5), \n    material2);\n\nPlane plane2 = Plane(\n    vec3(-0.3, 0., 0.), \n    vec3(1., 0., 0.), \n    vec3(0.2, 0.5, 0.6), \n    material2);\n\nPlane plane3 = Plane(\n    vec3(0.3, 0., 0.), \n    vec3(-1., 0., 0.), \n    vec3(0.2, 0.5, 0.6), \n    material2);\n\nPlane plane4 = Plane(\n    vec3(0., 0.3, 0.), \n    vec3(0., -1., 0.), \n    vec3(0.2, 0.5, 0.6), \n    material2);\n\nPlane plane5 = Plane(\n    vec3(0., 0., .12), \n    vec3(0., 0., -1.), \n    vec3(0.2, 0.5, 0.6), \n    material2);\n\nPlane plane6 = Plane(\n    vec3(0., 0., -1.), \n    vec3(0., 0., 1.), \n    vec3(0.2, 0.5, 0.6), \n    material2);\n\n#define SPHERE 0\n#define PLANE 1\n\nvoid setupScene()\n{\n\tspheres[0] = sphere1;\n    spheres[1] = sphere2;\n    \n    planes[0] = plane1;\n    planes[1] = plane2;\n    planes[2] = plane3;\n    planes[3] = plane4;\n    planes[4] = plane5;\n    planes[5] = plane6;\n    \n    lights[0] = light1;\n}    \n\n//////////////////////////////////////////////////////////////\n// \t                        UTILS                           // \n//////////////////////////////////////////////////////////////\nbool solveQuadratic(float a, float b, float c, out float t0, out float t1)\n{\n    float disc = b * b - 4. * a * c;\n    \n    if (disc < 0.)\n    {\n        return false;\n    } \n    \n    if (disc == 0.)\n    {\n        t0 = t1 = -b / (2. * a);\n        return true;\n    }\n    \n    t0 = (-b + sqrt(disc)) / (2. * a);\n    t1 = (-b - sqrt(disc)) / (2. * a);\n    return true;    \n}\n\nMaterial getMaterial(int type, int index)\n{\n    if (type == SPHERE)\n    {\n        return spheres[index].material;\n    }\n    \n    if (type == PLANE)\n    {\n        return planes[index].material;\n    }\n}\n\n//////////////////////////////////////////////////////////////\n// \t                   INTERSECTION CODE                    // \n//////////////////////////////////////////////////////////////\nbool intersectSphere(\n    vec3 origin, \n    vec3 direction, \n    Sphere sphere, \n    out float dist, \n    out vec3 surfaceNormal, \n    out vec3 Phit)\n{\n    vec3 L = origin - sphere.position;\n    \n    float a = dot(direction, direction);\n    float b = 2. * dot(direction, L);\n    float c = dot(L, L) - pow(sphere.radius, 2.);\n    \n    float t0;\n    float t1;\n    \n    if (solveQuadratic(a, b, c, t0, t1))\n    {        \n        if (t0 > t1) \n        {\n        \tfloat temp = t0;\n            t0 = t1;\n            t1 = temp;\n        } \n \n        if (t0 < 0.)\n        { \n            t0 = t1; // if t0 is negative, let's use t1 instead \n            if (t0 < 0.) return false; // both t0 and t1 are negative \n        }  \n             \n        dist = t0;\n       \n        Phit = origin + dist * direction;\n        surfaceNormal = normalize(Phit - sphere.position);               \n        \n        return true;\n    }  \n     \n    return false;\n}\n\nbool intersectPlane(in Plane plane, in vec3 origin, in vec3 rayDirection, out float t, out vec3 pHit) \n{    \n    // Assuming vectors are all normalized\n    float denom = dot(plane.normal, rayDirection); \n    if (denom < 1e-6) \n    { \n        vec3 p0l0 = plane.position - origin; \n        t = dot(p0l0, plane.normal) / denom; \n        \n        if (t >= 0.)\n        {\n            pHit = origin + rayDirection * t;\n            return true;\n        }             \n    } \n \n    return false; \n} \n\n//////////////////////////////////////////////////////////////\n// \t                     LIGTHING CODE                      // \n//////////////////////////////////////////////////////////////\nvec3 getLitColor(in vec3 viewDir, in vec3 surfacePointPosition, in vec3 objectColor, in PointLight pointLight, in vec3 surfaceNormal, in Material material)\n{\n    vec3 lightVector = surfacePointPosition - pointLight.position;\n    vec3 lightDir = normalize(lightVector);   \n    \n   \tfloat lightIntensity = (pow(0.1, 2.) / pow(length(lightVector), 2.)) * pointLight.intensity;\n    \n    float coeff = -dot(lightDir, surfaceNormal);     \n    \n    vec3 ambient = material.ambience * objectColor;\n        \n    vec3 diffuse = material.diffuse * max(coeff, 0.) * objectColor * lightIntensity;\n       \n    vec3 halfwayDir = normalize(lightDir + viewDir);  \n    vec3 specular = pow(max(-dot(surfaceNormal, halfwayDir), 0.0), material.shininess) * material.specular * objectColor * lightIntensity;\n    \n    vec3 color = ambient + diffuse + specular;\n    \n    return color;\n}\n\nvoid calculateShadow(vec3 pHit, inout vec3 finalColor, float ambient, int type, int index)\n{\n    // Intersect spheres\n    vec3 shadowSurfaceNormal;\n    vec3 shadowRay = lights[0].position - pHit;\n    vec3 shadowRayDirection = normalize(shadowRay);\n    float distanceToLight = sqrt(dot(shadowRay, shadowRay));\n    vec3 shadowPhit;\n    \n    float dist; \n    \n    for(int i = 0; i < 2; ++i)\n\t{\n        if (type == SPHERE && index == i)\n        {\n            continue;  \n        }\n    \n        if (intersectSphere(pHit, shadowRay, spheres[i], dist, shadowSurfaceNormal, shadowPhit))\n        {\n            if (dist > 0. && distanceToLight > dist)\n            {\n            \tfinalColor *= 2. * ambient; // Educated guess\n            }\n        }\n    }\n    \n    // Intersect planes\n    for(int i = 0; i < PLANES_COUNT; ++i)\n\t{\n \t\tif (type == PLANE && index == i)\n        {\n            continue;\n        }\n        \n        if (intersectPlane(planes[i], pHit, shadowRay, dist, shadowPhit))\n        {    \n            if (dist < distanceToLight)\n            {                \n \t\t\t\tfinalColor *= 2. * ambient;        \n            }\n        }\n    }     \n}\n\n//////////////////////////////////////////////////////////////\n// \t                       MAIN CODE                        // \n//////////////////////////////////////////////////////////////\nvec3 rayTrace(in vec3 rayDirection, in vec3 rayOrigin)\n{\n    vec3 finalColor = vec3(0.);\n    \n    int BOUNCES = 2;\n    \n    int prevType = -1;\n    int prevIndex = -1;  \n   \n\tvec3 pHit = rayOrigin; \n    vec3 passPHit;\n    \n    for (int bounce = 0; bounce < BOUNCES; bounce++)\n    {    \n        float dist = 1. / 0.; // Infinity :) \n        float objectHitDistance = dist;\n \n        vec3 surfaceNormal;\n        \n        int type = -1;\n    \tint index = -1;   \n        \n        vec3 passColor = vec3(0.);\n\n        for (int i = 0; i < SPHERES_COUNT; ++i)\n        {          \n            if (prevType == SPHERE && prevIndex == i)\n            {\n                continue;\n            }\n            \n            if (intersectSphere(rayOrigin, rayDirection, spheres[i], objectHitDistance, surfaceNormal, pHit))\n            {                \n                if (objectHitDistance < dist)\n                {\n                    dist = objectHitDistance;\n                    passColor = getLitColor(rayDirection, pHit, spheres[i].color, lights[0], surfaceNormal, spheres[i].material);\n                    calculateShadow(pHit, passColor, spheres[i].material.ambience, SPHERE, i);\n                    \n                    type = SPHERE;\n                    index = i;\n                    passPHit = pHit;\n                }\n            }\n        }\n\n        // Intersect planes\n        for(int i = 0; i < PLANES_COUNT; ++i)\n        {\n            if (prevType == PLANE && prevIndex == i)\n            {\n                continue;\n            }\n            \n            if (intersectPlane(planes[i], rayOrigin, rayDirection, objectHitDistance, pHit))\n            {\n                if (objectHitDistance <= dist)\n                {    \n\t\t\t\t\tdist = objectHitDistance;\n                    passColor = getLitColor(rayDirection, pHit, planes[i].color, lights[0], planes[i].normal, planes[i].material);        \n\n                    surfaceNormal = planes[i].normal;\n\n                    calculateShadow(pHit, passColor, planes[i].material.ambience, PLANE, i);\n                \n                \ttype = PLANE;\n                    index = i;                    \n                    passPHit = pHit;                    \n                }\n            }\n        } \n    \n        if (bounce == 0)\n        {\n            finalColor += passColor;\n        }\n        else\n        {\n        \tfinalColor += getMaterial(type, index).specular * passColor;\n        }\n        \n        if (type < 0) break;\n        \n        rayOrigin = passPHit;\n        rayDirection = reflect(rayDirection, surfaceNormal);\n        \n        prevType = type;\n        prevIndex = index;\n    }\n    \n    return finalColor / float(BOUNCES);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    setupScene();\n    \n    lights[0].position.x = sin(iTime) / 10.;\n    lights[0].position.z = (sin(iTime) - 2.) / 20.;\n    \n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv.x *= (iResolution.x / iResolution.y); \n    \n    vec3 clipPlanePosition = vec3(uv.x, uv.y, camera.position.z + camera.focalDistance);\n    vec3 rayDirection = normalize(clipPlanePosition - camera.position);\n     \n    vec3 finalColor = rayTrace(rayDirection, camera.position);\n    \n    // Output to screen\n    fragColor = vec4(finalColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}