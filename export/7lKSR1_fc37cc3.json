{"ver":"0.1","info":{"id":"7lKSR1","date":"1640276679","viewed":338,"name":"Atmospheric Scattering study","username":"AwareStubMan","description":"Rayleigh, Mie and ozone","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["raymarch","atmosphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = texture(iChannel0, uv).rgb / texture(iChannel0, uv).a;\n    \n    // Apply tonemapping and gamma correction\n    col *= ACES_INPUT_MATRIX;\n    col = Hejl2015(col);\n    col *= ACES_OUTPUT_MATRIX;\n    col = pow(col, vec3(1.0 / 2.2));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Mathematical constants\n#define PI 3.14159265359\n#define TAU 2.0*PI\n\n\n\n// Tonemapping\nvec3 Hejl2015(vec3 v)\n{\n    // https://twitter.com/jimhejl/status/633777619998130176\n    /*vec4 vh = vec4(v, whitepoint);\n    vec4 va = (1.425 * vh) + 0.05;\n    vec4 vf = ((vh*va + 0.004) / ((vh*(va + 0.55) + 0.0491))) - 0.0821;\n    return vf.rgb / vf.w;*/\n    /*\n        Modified the tone map for when the white point\n        approaches infinity.\n        ~ Tech\n    */\n    vec3 va = (1.425 * v) + 0.05;\n    vec3 vf = ((v * va + 0.004) / ((v * (va + 0.55) + 0.0491))) - 0.0821;\n    return vf / 0.9179;\n}\n\n\n\n// ACES Tonemapping\nconst mat3 ACES_INPUT_MATRIX = mat3(\n    0.59719, 0.35458, 0.04823,\n    0.07600, 0.90834, 0.01566,\n    0.02840, 0.13383, 0.83777\n);\nconst mat3 ACES_OUTPUT_MATRIX = mat3(\n    1.60475, -0.53108, -0.07367,\n    -0.10208,  1.10813, -0.00605,\n    -0.00327, -0.07276,  1.07602\n);\nvec3 RTT_ODT_FIT(vec3 v)\n{\n    vec3 a = v * (v + 0.0245786) - 0.000090537;\n    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    return a / b;\n}\nvec3 ACES_fitted(vec3 v)\n{\n    v = v * ACES_INPUT_MATRIX;\n    v = RTT_ODT_FIT(v);\n    return v * ACES_OUTPUT_MATRIX;\n}\n\n\n\n// Structs\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\n\n\n// Some equirectangular function i got from someone\nvec3 equirectangular(vec2 fragcoord, vec2 resolution)\n{\n    vec2 o = (fragcoord / resolution - 0.5) * PI * 2.0;\n    o.y *= 0.5;\n    return vec3(cos(o.x), tan(o.y), sin(o.x)) * cos(o.y);\n}\n\n\n\n// Random numbers\nfloat _Seed;\nfloat rand(vec2 n)\n{\n    _Seed++;\n\treturn fract(sin(_Seed / 100.0 * dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\nvec2 randV2(vec2 n)\n{\n    return vec2(rand(n), rand(n));\n}\n\n\n\n// Ray-sphere intersection\nvec2 intersectSphere(vec3 o, vec3 d, vec4 s)\n{\n    vec3 OC = o - s.xyz;\n    \n    float D_OC = dot(d, OC);\n    \n    float disc = D_OC*D_OC - dot(OC, OC) + s.w*s.w;\n    \n    if (disc < 0.0)\n    {\n        return vec2(-1.0);\n    }\n    \n    float disc_sqrt = sqrt(disc);\n    \n    return vec2(-D_OC - disc_sqrt, -D_OC + disc_sqrt);\n}\nvec2 intersectSphere(Ray r, vec4 s)\n{\n    vec3 OC = r.origin - s.xyz;\n    \n    float D_OC = dot(r.direction, OC);\n    \n    float disc = D_OC*D_OC - dot(OC, OC) + s.w*s.w;\n    \n    if (disc < 0.0)\n    {\n        return vec2(-1.0);\n    }\n    \n    float disc_sqrt = sqrt(disc);\n    \n    return vec2(-D_OC - disc_sqrt, -D_OC + disc_sqrt);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\nThe implementations in this code is based off Scratchapixel's \"Simulating the Colors of the Sky\":\nhttps://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/simulating-sky/simulating-colors-of-the-sky\n\nThe ozone absorption part, I've gotten some of it from people in discord server\n\nThis code does rayleigh and mie scattering with ozone absorption\n\nI just hope that I got this right ;-;\n*/\n\n\n// Atmosphere settings\n#define VIEW_STEPS 32\n#define LIGHT_STEPS 4\n#define SUN_INTENSITY 30.0\n\n// Camera settings\n#define doEquirectangular\n//#define inSpace\n\n// Constants define\n#define EARTH_RADIUS 6371e3\n#define ATMOSPHERE_RADIUS 6400e3\n#define BETA_RAYLEIGH vec3(3.8e-6, 13.5e-6, 33.1e-6)\n#define BETA_MIE vec3(21e-6)\n#define BETA_OZONE vec3(8.304280072e-7, 1.314911970e-6, 5.440679729e-8)//vec3(1.304132e-5, 1.286944e-5, 1.189952e-6)\n#define BETA_SCATTERING mat2x3(BETA_RAYLEIGH, BETA_MIE)\n#define BETA_EXTINCTION mat3x3(BETA_RAYLEIGH, BETA_MIE / 0.9, BETA_OZONE)\n\nvec3 getDensity(float altitude)\n{\n    return vec3(\n        // Rayleigh\n        exp(-altitude / 8000.0),\n        // Mie\n        exp(-altitude / 1200.0),\n        // Ozone\n\t\texp(-max(0.0, (35e3-altitude) - ATMOSPHERE_RADIUS )/5e3) *\n            exp(-max(0.0, (35e3-altitude) - ATMOSPHERE_RADIUS)/15e3)\n    );\n}\nvec2 phase(float mu)\n{\n    const float e = 1e4; // Mie energy\n\n    float mu2 = mu*mu;\n    \n    \n    return vec2(\n        // Rayleigh\n        3.0/(16.0 * PI) * (1.0 + mu2),\n        // Mie (Klein Nishina)\n        e / ((TAU * (e - e * mu) + 1.0) * log(2.0 * e + 1.0))\n    );\n}\nvec2 intersectSphericalShell(Ray ray, float innerSphereRadius, float outerSphereRadius) {\n    vec2 innerSphereDists = intersectSphere(ray, vec4(0.0, 0.0, 0.0, innerSphereRadius));\n    vec2 outerSphereDists = intersectSphere(ray, vec4(0.0, 0.0, 0.0, outerSphereRadius));\n\n    bool innerSphereIntersected = innerSphereDists.y >= 0.0;\n    bool outerSphereIntersected = outerSphereDists.y >= 0.0;\n\n    if (!outerSphereIntersected) return vec2(-1.0);\n\n    vec2 dists;\n    dists.x = innerSphereIntersected && innerSphereDists.x < 0.0 ? innerSphereDists.y : max(outerSphereDists.x, 0.0);\n    dists.y = innerSphereIntersected && innerSphereDists.x > 0.0 ? innerSphereDists.x : outerSphereDists.y;\n\n    return dists;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    _Seed = float(iFrame);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord + 0.5*(randV2(fragCoord)*2.0-1.0))/iResolution.xy;\n    // the jitter is in range [-0.5, 0.5] because fragCoord are not integers\n    //the range of fragCoord is [0.5, resolution-0.5] and the jitter will make it become\n    //[0, resolution], this is required in order for the jittered fragCoord will not be at another pixel\n\n    // Color initialization\n    vec3 col = vec3(0.0);\n    \n    // Ray initialization\n    Ray cameraRay;\n    #ifdef inSpace\n        cameraRay.origin = vec3(0.0, 0.0, -EARTH_RADIUS * 1.5);\n    #else\n        cameraRay.origin = vec3(0.0, EARTH_RADIUS + 1e3, 0.0);\n    #endif\n    #ifdef doEquirectangular\n        cameraRay.direction = equirectangular(fragCoord, iResolution.xy);\n    #else\n        cameraRay.direction = normalize(vec3((uv * 2.0 - 1.0) * vec2(iResolution.x/iResolution.y, 1.0), 1.0));\n    #endif\n    \n    // Sun direction\n    #ifdef inSpace\n        vec3 sunDir = normalize(vec3((iMouse.xy / iResolution.xy * 2.0 - 1.0) * 10.0, -1.0));\n    #else\n        vec3 sunDir = normalize(vec3((iMouse.xy / iResolution.xy * 2.0 - 1.0) * 10.0, 1.0));\n    #endif\n    \n    // Atmosphere intersection\n    vec2 atmosphereIntersect = intersectSphere(cameraRay, vec4(0.0, 0.0, 0.0, ATMOSPHERE_RADIUS));\n    \n    // Solving scattering integral\n    if (atmosphereIntersect.y >= 0.0)\n    {\n        vec3 marchedPos_View = atmosphereIntersect.x < 0.0 ? cameraRay.origin : cameraRay.origin + cameraRay.direction*atmosphereIntersect.x;\n        float segmentLength_View;\n        {\n            // We have to make it so that segmentLength_View won't let us go inside the planet to save step counts\n            vec2 sphericalShell = intersectSphericalShell(cameraRay, EARTH_RADIUS, ATMOSPHERE_RADIUS);\n            if (sphericalShell.x < 0.0)\n                segmentLength_View = sphericalShell.y / float(VIEW_STEPS);\n            else\n                segmentLength_View = (sphericalShell.y - sphericalShell.x) / float(VIEW_STEPS);\n        }\n        \n        vec3 opticalDepth_View; // we'll accumulate this\n        vec3 totalTransmittance_View = vec3(1.0); // for sun rendering\n        \n        marchedPos_View += cameraRay.direction*segmentLength_View*0.5; // for optimization, i guess?\n        // View ray loop\n        for (int i = 0; i < VIEW_STEPS; i++)\n        {            \n            // Calculate the position's altitude\n            float altitude_View = length(marchedPos_View) - EARTH_RADIUS;\n            \n            // Accumulate the view optical depth\n            vec3 opticalDepthSeg_View = getDensity(altitude_View) * segmentLength_View;\n            opticalDepth_View += opticalDepthSeg_View;\n            \n            // Calculate light optical depth\n            vec3 opticalDepth_Light;\n            bool hitPlanet = false;\n            {\n                // Calculate the atmosphere intersection for light optical depth\n                atmosphereIntersect = intersectSphere(marchedPos_View, sunDir, vec4(0.0, 0.0, 0.0, ATMOSPHERE_RADIUS));\n                \n                vec3 marchedPos_Light = marchedPos_View;\n                float segmentLength_Light = (atmosphereIntersect.y) / float(LIGHT_STEPS);\n                \n                marchedPos_Light += sunDir*segmentLength_Light*0.5;\n                for (int j = 0; j < LIGHT_STEPS; j++)\n                {\n                    \n                    // Altitude...\n                    float altitude_Light = length(marchedPos_Light) - EARTH_RADIUS;\n                    if (altitude_Light < 0.0) { hitPlanet = true; break; }\n\n                    // Accumulate...\n                    opticalDepth_Light += getDensity(altitude_Light) * segmentLength_Light;\n                    \n                    // March...\n                    marchedPos_Light += sunDir*segmentLength_Light;\n                    \n                    // And we're done, cool\n                }\n            }\n            \n            // Calculate transmittance\n            vec3 transmittance_View = exp(-BETA_EXTINCTION * opticalDepth_View);\n            vec3 transmittance_Light = exp(-BETA_EXTINCTION * opticalDepth_Light);\n            \n            // Calculate the scattering integral\n            if (!hitPlanet)\n                col += transmittance_View * transmittance_Light * opticalDepthSeg_View.x;\n            \n            // Accumulate view transmittance\n            totalTransmittance_View *= transmittance_View;\n            \n            // March the position along the camera ray direction\n            marchedPos_View += cameraRay.direction*segmentLength_View;\n        }\n        float mu = dot(cameraRay.direction, sunDir);\n        \n        col = BETA_SCATTERING * phase(mu) * col;\n        col *= SUN_INTENSITY;\n        \n        // Render the sun\n        if (intersectSphere(cameraRay, vec4(0.0, 0.0, 0.0, EARTH_RADIUS)).y <= -1.0)\n            col += totalTransmittance_View * float(mu > 0.999) * SUN_INTENSITY;\n    }\n    \n    col = mix(texture(iChannel0, fragCoord/iResolution.xy).rgb, col, 0.25); // apply temporal filter for anti aliasing\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}