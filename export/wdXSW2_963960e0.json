{"ver":"0.1","info":{"id":"wdXSW2","date":"1552545970","viewed":135,"name":"LowPoly Landscape using Voronoi","username":"TheWifflebrain","description":"This is a low-poly landscape using the Voronoi effect and a noise effect for the sky. ","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["terrain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//CREATION OF THE VORONOI EFFECT\n//Based on https://iquilezles.org/articles/voronoilines\nvec2 hash(vec2 p) \n{ \n    p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))); return fract(sin(p)*18.5453); \n}\n//Return distance, and cell id\nvec2 voronoi(in vec2 x, bool isMoving)\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n    vec2 r;\n    vec2 o;\n\n\tvec3 m = vec3(8.0);\n    for(int j=-1; j<=1; j++)\n    for(int i=-1; i<=1; i++)\n    {\n        vec2 g = vec2(float(i), float(j));\n        if(isMoving == true)\n        {\n        \to = hash( n + g );\n\t    \tr = g - f + (0.5+0.5*sin(iTime+6.2831*o));\n        }\n        else \n        {\n            o = hash( n + g + 42.);\n\t    \tr = g - f + (0.5+0.5*sin(6.2831*o));\n        }\n\t\tfloat d = dot(r, r);\n        if(d<m.x)\n            m = vec3(d, o);\n    }\n\n    return vec2(sqrt(m.x), m.y+m.z);\n}\n\n//CREATING THE SKY\n//Getting a vec2 and returning a float\nfloat N21(vec2 p) \n{\n    return fract(sin(p.x*100.0+p.y*6574.0)*5647.0);\n}\n\nfloat SmoothNoise(vec2 uv) \n{\n    vec2 lv = fract(uv);\n    vec2 id = floor(uv);\n    \n    lv = lv*lv*(3.0-2.0*lv);\n    \n    float bl = N21(id);\n    float br = N21(id+vec2(1,0));\n    float b = mix(bl, br, lv.x);\n    \n    float tl = N21(id+vec2(0,1));\n    float tr = N21(id+vec2(1,1));\n    float t = mix(tl, tr, lv.x);\n    \n    return mix(b, t, lv.y);\n}\n\nfloat SmoothNoise2(vec2 uv) {\n    float c = SmoothNoise(uv*4.0);\n    c += SmoothNoise(uv*8.0)*0.5;\n    c += SmoothNoise(uv*16.0)*0.25;\n    c += SmoothNoise(uv*32.0)*0.16;\n    c += SmoothNoise(uv*64.0)*0.0625;\n    \n    return c / 2.;\n}\n\n//Creating a circle for the sun\nvec4 circle(vec2 uv, vec2 pos, float rad, vec3 color) \n{\n\tfloat d = length(pos - uv) - rad;\n\tfloat t = clamp(d, 0.0, 1.0);\n    \n\treturn vec4(color, 1.0-t);\n}\n\n//Checking if a pixel is inside the desired triangle\nbool isInTriangle(vec2 v1, vec2 v2, vec2 v3, vec2 uv) \n{\n    //CCW direction vectors along triangle edges.\n    vec2 v21 = v2 - v1;\n    vec2 v32 = v3 - v2;\n    vec2 v13 = v1 - v3;\n    \n    //Normals point inward from triangle edges.  Just rotate triangle edges\n    //90 degrees CCW.\n    vec2 n21 = vec2(-v21.y, v21.x);\n    vec2 n32 = vec2(-v32.y, v32.x);\n    vec2 n13 = vec2(-v13.y, v13.x);\n    \n    return (dot(v1-uv,n21) < 0.0) && \n           (dot(v2-uv,n32) < 0.0) && \n           (dot(v3-uv, n13)< 0.0);\n}\n\n//MAIN\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    //Setting up the stage\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 uvFillIn = fragCoord.xy/iResolution.xy;\n    //Slowing down time\n    uv += iTime*.1;\n    \n    //SKY using the noise effect\n    //Setting boundaries for the sky\n    vec2 centerSky = iResolution.xy * 0.5;\n\tfloat width = 1.0 * iResolution.x;\n\tfloat height = 0.57 * iResolution.x;\n    //Starting noise effects\n    float c = SmoothNoise2(uv);\n    //vec2 col = vec2(c);\n    //vec4 skyLayer = vec4(col,1.5,255.0);\n    \n    //SUN using voronoi effect\n    vec2 p = fragCoord.xy/max(iResolution.x,iResolution.y);\n    vec2 uvSun = fragCoord.xy;\n\tvec2 center = (iResolution.xy * 0.87 * sin(((iTime)*.7)));//could multiply it by time to make the sun move\n    float darkness = (iResolution.y * 0.87 * sin(((iTime)*.7)));\n\tfloat radius = 0.1 * iResolution.y;\n    //Adding voroni effect\n    vec2 cSun = voronoi((14.0+6.0*cos(0.01*iTime))*p, true);\n    //The color of the sun\n    \t//Changes the intesisty of the sun \n    \t//Higher number more clouds and lighter/lower number darker yellow with less clouds\n    \t//+ The color of the sun in rgb\n    vec3 colorSun = (cSun.y*0.48 + (vec3(255.,255.,0.0)));//The white shapes are meant to be clouds\n\t//Cropping out a circle for the sun\n\tvec4 sunLayer = circle(uvSun, center, radius, colorSun);\n    \n    //changing the background color to the sky by the y coordinate\n    vec2 col;\n    vec4 skyLayer;\n    if(darkness < 120.0)\n    {\n        col = vec2(c-1.0);\n    \tskyLayer = vec4(col,0.1,0.0);\n    }\n    else if(darkness < 250.0)\n    {\n        col = vec2(c-1.0);\n    \tskyLayer = vec4(col,0.35,0.0);\n    }\n    else\n    {\n        col = vec2(c);\n        skyLayer = vec4(col,1.0,0.0);\n    }\n    \n    //Variables to shift the location of the mountains and the lake all at once\n    float mHeight = 0.28;\n    float mShift = 0.18;\n    float lHeight = 0.1;\n    \n    //Forest voronoi variables\n    \t//Density of the shapes (first two variables)\n    \t//Position of the shapes mostly (thrid and fouth variables)\n    vec2 cF = voronoi(8.0*(9.0+9.0*sin(0.2*(iTime*.001)))*p, true);\n    \t//Intensity of the shade (first two variables)\n    \t//Color of shapes (the vec3)\n    vec3 colorF = 0.2 + .8*cos(cF.y + vec3(0.1,5.5,0.1));\t\n    colorF *= clamp(4.0 - 0.4*cF.x*cF.x,1.0,0.8);\n    \n    //Lake voronoi variables\n    \t//iTime ebb and flows the lake\n    vec2 cL = voronoi(6.0*(42.0+6.0*cos(0.3*iTime))*p, true);\n    vec3 colorL = (cL.y*0.55 + (vec3(0.,0.,200.0)));\n    \n    //Mountain caps voronoi variables\n    vec2 cMC = voronoi((100.0+6.0*cos(15.7))*p, true);\n    vec3 colorMC = 0.9 + 0.1*cos(cMC.y*6.2831 + vec3(0.0,0.0,0.0));\t\n    colorMC *= clamp(1.0 - 0.4*cMC.x*cMC.x,0.0,1.0);\n    \n    //Shading the different components of the landscape\n    //Forest shading\n    //vec2 from left to right is right vertex, left vertex, then top vertex\n    if (isInTriangle(vec2(0,0.3), vec2(0,-0.2), vec2(0.3,0.0), uvFillIn)) \n    {\n    \tfragColor = vec4(colorF, 1.0);\n    }\n    else if (isInTriangle(vec2(1,0.3), vec2(0,-0.7), vec2(1.0,-0.3), uvFillIn)) \n    {\n    \tfragColor = vec4(colorF, 1.0);\n    }\n    //Lake shading\n    else if (isInTriangle(vec2(0.0,0.0-lHeight), vec2(1,0.33-lHeight), vec2(0.0,0.33-lHeight), uvFillIn)) \n    {\n    \tfragColor = vec4(colorL, 0.0);\n    }\n    else if (isInTriangle(vec2(1,0.33-lHeight), vec2(0,0.0-lHeight), vec2(1.0,0.0-lHeight), uvFillIn)) \n    {\n        fragColor = vec4(colorL, 0.0);\n    }\n    //Mountain caps shading\n    else if (isInTriangle(vec2(0.73,0.7), vec2(0.81,0.7), vec2(0.95-mShift,1.1-mHeight), uvFillIn)) \n    {\n    \tfragColor = vec4(sqrt(max(colorMC, 0.0)), 1);\n    }\n    else if (isInTriangle(vec2(0.173,0.7), vec2(0.295,0.7), vec2(0.41-mShift,1.2-mHeight), uvFillIn))\n    {\n\t\tfragColor = vec4(sqrt(max(colorMC, 0.0)), 1);\n    }\n    //Mountain shading\n    else if (isInTriangle(vec2(0.7-mShift,0.5-mHeight), vec2(0.9-mShift,0.5-mHeight), vec2(0.8-mShift,0.8-mHeight), uvFillIn)) \n    {\n        vec2 cM1 = voronoi((17.0*cos(0.17))*p, false);\n        vec3 colorM1 = 0.3 + 0.2*cos(cM1.y*6.2831 + vec3(0.8,0.8,0.8));\t\n    \tcolorM1 *= clamp(1.0 - 0.4*cM1.x*cM1.x,0.0,1.0);\n    \tfragColor = vec4(sqrt(max(colorM1, 0.0)), 1);\n    }\n    else if (isInTriangle(vec2(0.75-mShift,0.5-mHeight), vec2(1.15-mShift,0.5-mHeight), vec2(0.95-mShift,1.1-mHeight), uvFillIn)) \n    {\n    \tvec2 cM2 = voronoi((17.0+6.0*cos(15.7))*p, false);\n        vec3 colorM2 = 0.3 + 0.2*cos(cM2.y*6.2831 + vec3(0.8,0.8,0.8));\t\n    \tcolorM2 *= clamp(1.0 - 0.4*cM2.x*cM2.x,0.0,1.0);\n    \tfragColor = vec4(sqrt(max(colorM2, 0.0)), 1);\n    }\n    else if (isInTriangle(vec2(0.58-mShift,0.5-mHeight), vec2(0.98-mShift,0.5-mHeight), vec2(0.78-mShift,1.-mHeight), uvFillIn)) \n    {\n    \tvec2 cM3 = voronoi((19.0+6.0*cos(0.28))*p, false);\n        vec3 colorM3 = 0.3 + 0.2*cos(cM3.y*6.2831 + vec3(0.8,0.8,0.8));\t\n    \tcolorM3 *= clamp(1.0 - 0.4*cM3.x*cM3.x,0.0,1.0);\n    \tfragColor = vec4(sqrt(max(colorM3, 0.0)), 1);\n    }\n    else if (isInTriangle(vec2(0.21-mShift,0.5-mHeight), vec2(0.61-mShift,0.5-mHeight), vec2(0.41-mShift,.9-mHeight), uvFillIn)) \n    {\n    \tvec2 cM4 = voronoi((15.0+6.0*cos(6.27))*p, false);\n        vec3 colorM4 = 0.3 + 0.2*cos(cM4.y*6.2831 + vec3(0.8,0.8,0.8) );\t\n    \tcolorM4 *= clamp(1.0 - 0.4*cM4.x*cM4.x,0.0,1.0);\n    \tfragColor = vec4(sqrt(max(colorM4, 0.0)), 1);\n    }\n    else if (isInTriangle(vec2(0.41-mShift,0.5-mHeight), vec2(0.81-mShift,0.5-mHeight), vec2(0.61-mShift,1.05-mHeight), uvFillIn)) \n    {\n    \tvec2 cM5 = voronoi((14.5+6.0*cos(1.57))*p, false);\n        vec3 colorM5 = 0.3 + 0.2*cos(cM5.y*6.2831 + vec3(0.8,0.8,0.8));\t\n    \tcolorM5 *= clamp(1.0 - 0.4*cM5.x*cM5.x,0.0,1.0);\n    \tfragColor = vec4(sqrt(max(colorM5, 0.0)), 1);\n    }\n    else if (isInTriangle(vec2(0.23-mShift,0.5-mHeight), vec2(0.61-mShift,0.5-mHeight), vec2(0.41-mShift,1.2-mHeight), uvFillIn))\n    {\n    \tvec2 cM6 = voronoi((14.0+6.0*cos(1.57))*p, false);\n        vec3 colorM6 = 0.3 + 0.2*cos(cM6.y*6.2831 + vec3(0.8,0.8,0.8));\t\n    \tcolorM6 *= clamp(1.0 - 0.4*cM6.x*cM6.x,0.0,1.0);\n    \tfragColor = vec4(sqrt(max(colorM6, 0.0)), 1);\n    }\n    //Shading the background\n    else \n    {\n        //Mixing the two layers of the sun and the sky\n    \tfragColor = mix(skyLayer, sunLayer, sunLayer.a);\n    }\n}\n\n","name":"Image","description":"","type":"image"}]}