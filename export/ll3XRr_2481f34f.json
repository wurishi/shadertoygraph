{"ver":"0.1","info":{"id":"ll3XRr","date":"1477698090","viewed":570,"name":"GÃ¶del, Escher, Bach","username":"Observer","description":"Inspired by the cover of the famous book of Douglas Hofstadter.\nThis is a work in progress. A lot can be optimized (converting conditions to step/mix functions). It should also be possible to use ray marching, which should make the process a lot simpler ","likes":28,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","csg","reproduction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float HALFPI = acos(0.0);\nconst float PI = HALFPI * 2.0;\nconst float TWOPI = HALFPI * 4.0;\n\n// IQ's functions ----------------------------------------------------------------------\n\nfloat opI( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2, d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\n// Distance functions ----------------------------------------------------------------------\n\nvec2 rot(vec2 pos, float ang)\n{\n    return vec2(cos(ang) * pos.x + sin(ang)*pos.y, cos(ang) * pos.y - sin(ang)*pos.x);\n}   \n\nfloat findDistG1(in vec2 p)\n{\n    p = rot(vec2(p.x, -p.y), -0.05);\n    float d1 = length(max(abs(p)-vec2(0.2, 0.2),0.0))-0.8;\n    float d2 = length(max(abs(p - vec2(0.0, 0.03))-vec2(0.15, 0.18),0.0))-0.45;\n\tvec2 d = abs(vec2(p.x + 3.6 * p.y + 0.05, p.y + 0.72)) - vec2(1.0, 0.6);\n\tfloat d3 = min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n\td = abs(p - vec2(0.57, 0.07)) - vec2(0.43, 0.19);\n  \tfloat d4 = min(max(d.x, d.y),0.0) + length(max(d,0.0));    \n    return min(max(max(d1, -d2), -d3), d4);\n}    \n\nfloat findDistE1(in vec2 p)\n{\n\tp = vec2(p.x, -p.y);\n    vec2 d = abs(rot(p, -0.05) - vec2(-0.73, -0.05)) - vec2(0.24, 0.98);\n  \tfloat d1 = min(max(d.x, d.y),0.0) + length(max(d, 0.0));\n\td = abs(p - vec2(0.05, 0.78)) - vec2(0.95, 0.21);\n  \tfloat d2 = min(max(d.x, d.y),0.0) + length(max(d, 0.0));        \n\td = abs(p - vec2(0.04, 0.0)) - vec2(0.95, 0.21);\n  \tfloat d3 = min(max(d.x, d.y),0.0) + length(max(d, 0.0));        \n\td = abs(p - vec2(0.04, -0.74)) - vec2(0.95, 0.26);\n  \tfloat d4 = min(max(d.x, d.y),0.0) + length(max(d, 0.0));        \n    return min(min(min(d1, d2), d3), d4);\n}    \n\nfloat findDistE2(in vec2 p)\n{\n\tp = vec2(p.x, -p.y);\n\tvec2 d = abs(rot(p, 0.01) - vec2(-0.73, -0.02)) - vec2(0.24, 0.96);\n  \tfloat d1 = min(max(d.x, d.y),0.0) + length(max(d, 0.0));\n\td = abs(rot(p, 0.025) - vec2(0.05, 0.76)) - vec2(0.95, 0.20);\n  \tfloat d2 = min(max(d.x, d.y),0.0) + length(max(d, 0.0));        \n\td = abs(rot(p, 0.02) - vec2(0.02, 0.0)) - vec2(0.95, 0.20);\n  \tfloat d3 = min(max(d.x, d.y),0.0) + length(max(d, 0.0));        \n\td = abs(rot(p, 0.02) - vec2(0.04, -0.78)) - vec2(0.93, 0.20);\n  \tfloat d4 = min(max(d.x, d.y),0.0) + length(max(d, 0.0));        \n    return min(min(min(d1, d2), d3), d4);\n}    \n\nfloat findDistG2(in vec2 p)\n{\n    p = rot(vec2(p.x, -p.y), -0.045);\n    float d1 = length(max(abs(p)-vec2(0.35, 0.35),0.0))-0.65;\n    float d2 = length(max(abs(p - vec2(0.0, 0.05))-vec2(0.15, 0.11),0.0))-0.45;\n\tvec2 d = abs(vec2(p.x + 2.0 * p.y - 0.9, p.y + 0.72)) - vec2(1.0, 0.6);\n\tfloat d3 = min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n\td = abs(p - vec2(0.55, 0.055)) - vec2(0.45, 0.21);\n  \tfloat d4 = min(max(d.x, d.y),0.0) + length(max(d,0.0));    \n    return min(max(max(d1, -d2), -d3), d4);\n}  \n\nfloat findDistB(in vec2 p)\n{\n    vec2 q = rot(vec2(p.x, -p.y), 0.03);\n    float d1 = length(max(abs(q-vec2(-0.2, 0.0))-vec2(0.63, 0.85),0.0))-0.15;\n    float d2 = length((q-vec2(0.4, 0.4))*vec2(1.0, 1.0)) - 0.6;\n    float d3 = length((q-vec2(0.3, -0.412))*vec2(1.0, 1.0)) - 0.6;\n    float d4 = length(max(abs(p-vec2(-0.05, 0.4))-vec2(0.08, 0.01),0.0))-0.2;\n    float d5 = length(max(abs(p-vec2(-0.05, -0.4))-vec2(0.08, 0.01),0.0))-0.2;\n    \n    return max(min(min(d1, d2), d3), -min(d4, d5));\n}  \n\nvec2 walls (in vec3 pos)\n{\n    vec3 walls = abs(pos - vec3(-3.6, 4.0, -0.5));\n    return vec2(min(min(walls.x, walls.y), walls.z), 1.0);\n}   \n\nvec2 upperCube (in vec3 pos)\n{\n\tvec3 cb = pos - vec3(0.0, 0.0, 5.5);\n    return vec2(\n        opI(\n        \topI(\n                findDistG2(cb.yz), \n                findDistE2(cb.xz)\n            ),\n            findDistB(cb.xy)\n        ), 2.0);\n}\n\nvec2 lowerCube (in vec3 pos)\n{\n\tvec3 cb = pos - vec3(0.0, 0.0, 2.5);\n    return vec2(\n        opI(\n        \topI(\n                findDistE1(cb.yz), \n                findDistG1(cb.xz)\n            ),\n            findDistB(cb.xy)\n        ), 3.0);\n}\n\n\n// Material ----------------------------------------------------------------------\n\nvec3 colorWall(in vec3 s, in vec3 n)\n{\n    float c, cf = 10.0;\n    int glyph;\n    vec2 uv;\n    vec3 gridCol = vec3(0.0);\n    if (n.z == 1.0) \n    {\n        c = findDistB(vec2(s.x, s.y));\n        cf = 5.0;\n    }\n    else\n        if (n.x == 1.0)\n        {\n            c = s.z < 4.0 ? findDistE1(vec2(s.y, s.z - 2.5)) : findDistG2(vec2(s.y, s.z - 5.5));\n        }\n        else\n        {\n            c = s.z < 4.0 ? findDistG1(vec2(s.x, s.z - 2.5)) : findDistE2(vec2(s.x, s.z - 5.5));\n        }\n    \n    c = smoothstep(0.0, 0.15, c);\n    float i = abs(dot(normalize(s - vec3(0.0, 0.0, 3.7)), n));\n    i = 0.01 + 0.5 * i + pow(i, 10.0);\n    float j = max(0.0, 1.0 - 1.0 * pow(distance(s, vec3(-2.0, 2.0, 3.0)) * 0.15, 2.0));\n    return j * i * c * vec3(0.9, 0.7, 0.2);\n}\n\nvec3 colorLowerCube(in vec3 s, in vec3 n)\n{\n    // Wood texture\n    float f;\n    s.z -= 2.5;\n    vec2 fx = 0.1 * vec2(cos(s.x * 0.4), sin(s.x * 0.6)) + vec2(15.0, 15.0);\n    f = sin(length(s.yz - fx) * 100.0) * 0.2 + 0.5;\n    return mix(vec3(0.3, 0.2, 0.0), vec3(0.9, 0.6, 0.0), f);    \n}\n\nvec3 colorUpperCube(in vec3 s, in vec3 n)\n{\n    // Wood texture\n    float f;\n    s.z -= 5.5;\n    vec2 fx = 0.1 * vec2(cos(s.z * 0.4), sin(s.z * 0.3)) + vec2(-5.0, -5.0);\n    f = sin(length(s.xy - fx) * 100.0) * 0.2 + 0.5;\n    return mix(vec3(0.3, 0.2, 0.0), vec3(0.9, 0.6, 0.0), f);    \n}\n\n\n// Rendering ----------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = walls(pos);\n    res = opU(res, upperCube(pos));\n    res = opU(res, lowerCube(pos));\n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 0.01;\n    float tmax = 50.0;\n\tfloat precis = 0.0002;\n    float t = tmin;\n    float m = 1.0;     // material\n    for (int i = 0; i < 80; i++)\n    {\n\t    vec2 res = map(ro + rd * t);\n        if (res.x < precis || t > tmax) break;\n        t += abs(res.x);\n\t    m = res.y;\n    }\n    if (t > tmax) m = -1.0;\n    return vec2(t, m);\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i = 0; i < 16; i++ )\n    {\n\t\tfloat h = map(ro + rd*t).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h < 0.001 || t > tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.000, 0.000 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col, n, light;\n    vec2 res = castRay(ro, rd);\n    float t = res.x;  // res.x: distance\n    float m = res.y;  // res.y: material\n    if (m > 0.5)\n    {\n        vec3 s = ro + t*rd;\n        \n        // material        \n        if (m == 1.0)\n        {\n        \tn = abs(normalize(s - vec3(-3.6, 4.0, -0.5)));\n            n = (n.x < min(n.y, n.z)) ? vec3(1.0, 0.0, 0.0) :\n            \t  n.y < n.z ? vec3(0.0, -1.0, 0.0) :\n            \t  vec3(0.0, 0.0, 1.0);\n                \n            return colorWall(s, n);\n        }            \n        else \n        {\n            n = calcNormal(s);\n            if (m == 2.0)\n            {\n                col = colorLowerCube(s, n);\n            }\n            else\n            {\n                col = colorUpperCube(s, n);\n            }            \n            float cc = 0.0, ccc = 0.0;\n\n            for (int lt = 0; lt < 3; lt++)\n            {\n                // Light position\n                light = \n                \tlt == 0 ? vec3(5.0, 0.0, 3.7) :\n                \tlt == 1 ? vec3(0.0, -5.0, 3.7) :\n                \tvec3(-0.5, 0.0, 10.0);\n\n                // Light vector\n                vec3 lvec = normalize(light - s);\n                \n                float mm = castRay(s, lvec).y;\n                float shadow = mm > 1.5 ? 0.2 : 1.0;\n\n                // Mirror vector\n                float a = -dot(n, rd);\n\n                \n                // lighting intensity\n                cc += shadow * max(0.1, dot(n, lvec));\n\n                // specular spot intensity\n                ccc += shadow * 0.8 * max(0.0, dot(rd + 2.0 * a * n, lvec));\n\n            }\n            vec3 d = vec3((s.x + 0.1) * 2.0, (s.y - 0.1) * 2.0, s.z - (m == 3.0 ? 2.8: 4.0));\n            return col * cc + vec3(pow(ccc, 30.0));\n        }\n    }\n}\n\nvoid calcCamera(in vec2 fragCoord, out vec3 ro, out vec3 rd)\n{\n    vec2 mx;\n    if (iMouse.z > 0.0)\n        mx = iMouse.xy / iResolution.xy;\n    else\n        mx = vec2(0.58, 0.191);\n    \n    float dst = 35.0;\n    \n    ro = vec3(\n        max(0.1, dst *cos(mx.x * 4.0 - 1.4) * cos(mx.y * 4.0)), \n        min(-0.1, -dst *sin(mx.x * 4.0 - 1.4) * cos(mx.y * 4.0)), \n        max(0.1, (7.0 + dst) * sin(mx.y * 4.0 - 0.5)));\n    \n    vec3 at = vec3(-0.4, 0.0, 3.1);\n    vec3 up = vec3(-0.04, 0.0, 1.0); // Sorry I'm used to a right handed system, z pointing up\n    vec3 look = at - ro;\n    float dist = length(look);\n    float aper = 16.0;  // degrees\n    float hsize = tan(aper*PI/180.0)*dist;\n    float vsize = hsize * iResolution.y /iResolution.x;\n    vec3 hor = normalize(cross(look, up)) * hsize;\n    vec3 ver = normalize(cross(hor, look)) * vsize;\n    vec2 p = fragCoord/iResolution.xy * 2.0 - 1.0;\n    rd = normalize(look + p.x * hor + p.y * ver);\n}   \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = 15.0 + iTime;\n\n    vec3 ro, rd;\n    calcCamera(fragCoord, ro, rd);\n    \n    vec3 col = render( ro, rd );\n    \n    col = pow( col, vec3(0.4545) );\n    fragColor = vec4( col.rgb, 1.0 );\n}","name":"Image","description":"","type":"image"}]}