{"ver":"0.1","info":{"id":"dlXfWl","date":"1693865321","viewed":52,"name":"Triangle Renderer v8","username":"Cesium_137","description":"Added ambient light and tried to fix the seeing through walls glitch.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","interactive"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* I tried to fix the see through walls glitch, \nbut I know this is definitely not the proper way to do this.\n\nThe see through walls glitch is caused by the function that finds the distance\nto the closest triangle, but I couldn't find a function that\ndoesn't cause the artifacts. I even tried modifying an SDF for raymarching\nbut it still had artifacts.\n\nI kind of just threw things at it until I liked it, and\nif anyone knows how to really fix this issue please let me know.\n*/\n\nfloat d = 3.0; //FOV; lower numbers = higher FOV\nconst int faces = 88;\nconst int vertices = 46;\nvec3 lightPos = 100.*vec3(-.4,-.2,1.); //The 100 is because the sun is far away\nvec3 ambientLightColor = vec3(0.5,0.8,0.95);\nvec3 objectColor = vec3(1.);\nfloat ambientLightIntensity = .55; // dictates how much the ambient light should affect the object's color [0., 1.]\n\n\n\nvec3 camera(vec2 rot){\n    return d*(sign(cos(rot.y)))*(vec3(d*sin(rot.x),d*cos(rot.x),-d*tan(rot.y))); // An equation I came up with to get the camera's position\n} // The (sign(cos(rot.y))) fixes an issue I discovered where if the camera is upside down, everything gets wonky\n\n\nfloat saign(vec2 p1, vec2 p2, vec2 p3){\n    return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);\n}// Ignore this, it's just for calculating if a pixel is inside a triangle\n\nfloat inTriangle(vec2 pt, vec2 p1, vec2 p2, vec2 p3){\n    float d1 = saign(pt,p1,p2);\n    float d2 = saign(pt,p2,p3);\n    float d3 = saign(pt,p3,p1);\n    if(d1 < 0. && d2 < 0. && d3 < 0.){\n        return 1.;\n    }\n    else{\n        return 0.;\n    }\n}\n\nvec3 normal(vec3 p1, vec3 p2, vec3 p3){\n    vec3 n;\n    vec3 v = p2 - p1;\n    vec3 w = p3 - p1;\n    n.x = (v.y*w.z)-(v.z*w.y);\n    n.y = (v.z*w.x)-(v.x*w.z);\n    n.z = (v.x*w.y)-(v.y*w.x);\n    return normalize(n);\n}\n\nfloat calculateIntensity(vec3 p1, vec3 p2, vec3 p3){\n    return 1.5*clamp(dot(normalize(lightPos),normal(p1,p2,p3)),0.067,.8);\n}\n\nmat2 rot2( float a ){ vec2 v = sin(vec2(1.570796, 0) + a);\treturn mat2(v, -v.y, v.x); }\n\nfloat z(vec2 a, float theta, float r, float h){\n    return cos(a.y)*r*sin(a.x + theta) - sin(a.y)*h;\n}\n\nfloat zcart(vec2 a, vec3 p){\n    return z(a,atan(p.y,p.x),sqrt(p.x*p.x+p.y*p.y),p.z);\n}\n\nvec2 c(vec2 a, float theta, float r, float h){\nfloat A = a.y, \n          B = a.x + theta;\n    vec2 v = mat2(cos(A), -sin(A), sin(A), cos(A) ) * vec2(h,r*sin(B));\n    return .2 * d / ( d - v.y ) \n              * vec2( r*cos(B), v.x ) +.5;\n} //plots cylindrical coordinates\n\nvec2 b(vec2 a, float x, float y, float z){\n    return c(a, atan(y,x),sqrt(x*x+y*y),z);\n} // plots cartesian coordinates\n\n\nfloat furthestDist(vec2 rot, vec3 a, vec3 b, vec3 c){ // This is where the issue is (i think)\n    float closest1 = min(min(\n        length(camera(rot) - a),\n        length(camera(rot) - b)),\n        length(camera(rot) - c)); //finds the minimum distance from the closest point of the triangle to the camera\n        \n    \n    float closest2 = length(camera(rot) - (a + b + c)/3.); // finds the distance to the centroid of the triangle\n    float closest = mix(closest1, closest2, .45);\n    return 1./(closest); //inverts it\n} // I tried to not invert it and change line 105 to if(dist < maxDist){ but then the house wouldn't show up\n\nfloat[] xcoords = float[](-1.25,0.0,-1.0,1.0,0.0,1.25,-0.5,0.5,0.5,-0.5,-1.0,0.0,-1.25,0.0,1.0,1.25,-1.0,-1.0,1.0,0.0,0.0,1.0,1.0,-1.0,-1.0,1.0,-0.75,0.75,-0.75,-0.5,-0.5,-0.75,0.75,0.5,0.5,0.75,1.0,0.75,1.0,0.75,1.0,1.0,0.75,-0.75,0.75,0.78);\nfloat[] ycoords = float[](1.25,1.25,1.25,1.25,1.25,1.25,1.0,1.0,1.0,1.0,-1.25,-1.25,-1.25,-1.25,-1.25,-1.25,1.0,1.0,1.0,1.0,-1.0,-1.0,1.0,-1.0,-1.0,-1.0,0.75,0.75,0.75,0.75,0.75,-0.75,-0.75,0.75,0.75,0.75,0.0,0.0,0.0,-0.5,-0.5,-0.5,-0.75,-0.75,0.0,-0.5);\nfloat[] zcoords = float[](0.5,1.5,0.5,0.5,1.75,0.5,-1.0,-1.0,0.0,0.0,0.5,1.5,0.5,1.75,0.5,0.5,-1.5,0.5,-1.5,1.5,1.5,0.5,0.5,0.5,-1.5,-1.5,-1.5,-1.5,0.5,-1.0,0.0,-1.5,-1.5,0.0,-1.0,0.5,-1.5,-1.5,-0.5,-1.5,-1.5,-0.5,0.5,0.5,-0.5,-0.5);\nint[] triData1 = int[](2,1,5,4,7,18,17,19,10,14,11,23,15,14,13,12,19,16,20,20,8,5,14,12,20,20,3,12,22,19,23,27,29,29,32,25,17,17,28,27,34,21,37,37,35,35,37,23,26,40,26,9,9,22,41,10,10,35,34,34,42,23,34,29,43,43,17,17,27,27,36,38,33,46,33,36,39,39,46,46,45,45,16,3,43,29,5,5);\nint[] triData2 = int[](3,5,6,2,8,9,18,17,7,13,12,9,16,12,1,2,8,15,21,22,9,1,5,11,18,24,2,4,24,27,18,19,27,30,33,26,27,32,36,28,35,24,38,28,8,7,19,39,25,41,33,34,31,26,42,31,30,30,9,8,39,22,36,31,33,32,25,24,29,44,28,45,46,43,43,45,45,38,42,41,39,42,4,11,44,36,14,16);\nint[] triData3 = int[](1,2,2,6,19,10,7,7,18,12,13,18,12,16,11,4,23,4,22,23,23,13,13,2,24,21,11,15,26,17,20,28,30,31,25,24,32,25,35,35,36,22,28,19,7,30,39,19,33,33,41,31,10,42,26,30,7,27,8,35,22,39,31,36,32,44,24,18,44,32,45,28,40,45,46,43,38,37,41,40,42,46,6,1,36,44,16,6);\nvec2[vertices] projected;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float maxDist;\n    vec2 uv = 2.*( fragCoord -.5*iResolution.xy ) / iResolution.x +.5;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    vec2 rot = vec2(-mouse.x * 4. - iTime / 2.,(mouse.y - 0.2) * 4.); // rot is rotation\n    vec3 col = ambientLightColor;\n    for(int i = 0; i < vertices; i++) //Uses an equation to project the vertices into 2d coordinates\n    {\n        projected[i] = b(rot,xcoords[i],ycoords[i],zcoords[i]);\n    }\n    float sunDist = length(uv - b(rot, lightPos.x, lightPos.y, lightPos.z)); //distance from the current pixel to the projected sun point\n    if(sin(rot.y) > 0.){ //Removes the sun if the camera is facing down\n        col += .05/sunDist;\n    }\n    for(int i = 0; i < faces; i++)\n    {\n        vec3 intensity = calculateIntensity(vec3(xcoords[triData1[i]-1],ycoords[triData1[i]-1],zcoords[triData1[i]-1]),vec3(xcoords[triData2[i]-1],ycoords[triData2[i]-1],zcoords[triData2[i]-1]),vec3(xcoords[triData3[i]-1],ycoords[triData3[i]-1],zcoords[triData3[i]-1])) * ((ambientLightIntensity)*ambientLightColor + (1.-ambientLightIntensity)*objectColor);\n        if(inTriangle(uv,projected[triData1[i]-1],projected[triData2[i]-1],projected[triData3[i]-1]) == 1.){\n            float dist = furthestDist(rot,vec3(xcoords[triData1[i]-1],ycoords[triData1[i]-1],zcoords[triData1[i]-1]),vec3(xcoords[triData2[i]-1],ycoords[triData2[i]-1],zcoords[triData2[i]-1]),vec3(xcoords[triData3[i]-1],ycoords[triData3[i]-1],zcoords[triData3[i]-1]));\n            if(dist > maxDist){\n                col = inTriangle(uv,projected[triData1[i]-1],\n                                     projected[triData2[i]-1],\n                                     projected[triData3[i]-1]) * intensity;\n                maxDist = dist;\n            }\n        }\n    }\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}