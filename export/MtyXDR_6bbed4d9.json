{"ver":"0.1","info":{"id":"MtyXDR","date":"1483840536","viewed":183,"name":"Gas Giant PZ043","username":"nothke","description":"MY FIRST THING!\n\nOriginal planet base by glkt: https://www.shadertoy.com/view/XlGSDR","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["planet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// \n\nconst float radius = 0.7;\nconst vec3 sunDir = vec3(.707,.707,0.);\n\n\nvec3 rotateY(vec3 v, float t){\n    float cost = cos(t); float sint = sin(t);\n    return vec3(v.x * cost + v.z * sint, v.y, -v.x * sint + v.z * cost);\n}\n\nvec3 rotateX(vec3 v, float t){\n    float cost = cos(t); float sint = sin(t);\n    return vec3(v.x, v.y * cost - v.z * sint, v.y * sint + v.z * cost);\n}\n\nfloat hash( vec3 p ) {\n    float h = dot(p,vec3(127.1,311.7,79.1));\t\n    return fract(sin(h)*43758.5453123);\n}\n\n// from iq\nfloat OrenNayar( in vec3 l, in vec3 n, in vec3 v, float r )\n{\n\t\n    float r2 = r*r;\n    float a = 1.0 - 0.5*(r2/(r2+0.57));\n    float b = 0.45*(r2/(r2+0.09));\n\n    float nl = dot(n, l);\n    float nv = dot(n, v);\n\n    float ga = dot(v-n*nv,n-n*nl);\n\n\treturn max(0.0,nl) * (a + b*max(0.0,ga) * sqrt((1.0-nv*nv)*(1.0-nl*nl)) / max(nl, nv));\n}\n\nfloat noise( in vec3 p ) { // base noise\n\n    // iq 3d noise\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n    vec3 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    float v = mix( mix( mix( hash( i + vec3(0.,0.,0.) ), \n                             hash( i + vec3(1.,0.,0.) ), u.x),\n                        mix( hash( i + vec3(0.,1.,0.) ), \n                             hash( i + vec3(1.,1.,0.) ), u.x), u.y),\n                   mix( mix( hash( i + vec3(0.,0.,1.) ), \n                             hash( i + vec3(1.,0.,1.) ), u.x),\n                        mix( hash( i + vec3(0.,1.,1.) ), \n                             hash( i + vec3(1.,1.,1.) ), u.x), u.y),u.z); \n    \n       // bubble style\n    //v = v * 2. - .5;    \n    //v = abs(cos(v));\n    //v = clamp(v*10.-9.5,0.,1.);\n    //float sv = abs(sin(v));    \n    //v = mix(sv,cv,sv);\n    \n    return 1.-v;\n   \n}\n\nvec3 getP(vec2 uv){           \n    \n    float r = sqrt(radius - uv.x*uv.x - uv.y*uv.y);  \n    \n    vec3 p = vec3(uv.x,uv.y,r);\n    \n\tp = rotateX(p,-iMouse.y/(iResolution.y*0.15));\n    p = rotateY(p,-iMouse.x/(iResolution.x*0.3));\n    \n    //float n = noise(p*20.);\n    float n = 0.;\n    \n    p *= 1.+n/10.;\n    \n    return p;    \n}\n\nvec3 getColor(vec2 uv){\n    \n    float d = length(uv);\n    vec3 c = vec3(0.,0.,0.);\n    \n    // planet\n    \n    if ( radius*1.2 - d > 0.){ \n\n        vec3 p = getP(uv);\n        vec3 py = vec3(p.z,0, p.x);\n        \n        float nsd = noise(py * 5.);\n\n        \n        float ns = noise(0.02 * iTime + p * (4.));// + sin(iTime)));\n        float ns2 = noise(iTime + p * 6.);\n        \n        float t = iTime * 0.06;\n        \n        float strOffset = 0.;\n        strOffset += 2. * (1.3 + noise(t + py * 5.));\n        strOffset += 2. * (0.34 + noise((t+2.34) + p * 0.3));\n        strOffset += 3. * (2.78 + noise((t+34.56) + p * 7.3));\n        // Adds a little bit of lattitude variety to stripes:\n        strOffset += 0.1 + sin(p.y * 15.45) * 0.9;\n        //strOffset *= 1. * noise(py * 2.);\n        \n        float str = 0.;\n        str = sin(strOffset + p.y * 30.); // the birth of stripes\n        \n        float strClamped = clamp(str,0.,1.); // use clamped for coloring\n        \n        //str = clamp(str,0.,1.); // to CLAMP ? ...\n        str = abs(str); // or to ABS ?\n        \n        \n        \n        //str += hash(p)*0.1; // fuzz\n        \n        //str += 2. * (cos(p.x) * sin(p.z));\n        //str*=1. * noise(py * 30. + iTime);\n        \n        /*\n        float offset = 4. * noise(p * 0.4);\n        float numOfStripes = 4.;\n        float thickness = 0.1 * ns2;\n        \n        float inM = mod(offset + p.y, 1. / numOfStripes);\n        //float less = 0.1 * nsd + 0.4 + 0.03 * ns2;\n        float less = thickness;\n        \n        //float str = smoothstep(0., 1., inM);\n        float str = inM < less ? 1. : 0.;\n        */\n        \n        vec3 stripes = vec3(0.4, 0.4, 0) * str;\n        \n        float light = 0.;\n        light += clamp(dot(sunDir,p),0.,1.);\n        //light += OrenNayar(sunDir,p,vec3(1,1,1),1.);\n        \n        float light2 = clamp(dot(vec3(.707,0,.707),p),0.,1.) / 4.;\n\n        float specular = pow(light,10.);\n\n        float rim = pow(length(uv)/radius,8.) /30.;\n\n        //light += specular + rim;\n        \n        // BASE\n        //c += vec3(0,0.2,0.2);\n        c += vec3(0.6,0.4,0.1);\n                \n        // noise test\n        //c.r = noise(4.786+p*10.);\n        //c.r = clamp(c.r, 0., 1.);\n        \n        c += stripes;\n        \n        // mult green a bit to get a reddish color of odd stripes\n        c.g *= 1. - strClamped*0.15 * (1. +p.y  * 3.);\n        // mult red a bit to get greenish color\n        c.r *= 1. - strClamped*0.15 * (1. -p.y  * 2.);\n        // lil bit more shading\n        c.b += sin(p.y * 3.) *0.2;\n        \n        //c = vec3(1.,.9,.7)+ stripes;\n        //c = vec3(strClamped, strClamped, strClamped);\n        \n        \n        // LIGHT\n        c *= light;\n        //c *= light;\n        //c += vec3(2.,.5,.5) * specular;\n        //c += vec3(.1,.4,.8) * rim;\n        //c += vec3(.1,.5,.8) * light2;\n    }\n    \n    return c;\n}\n\nfloat gamma = 2.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy * 2.0 / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\tvec3 c = getColor(uv);\n\tfragColor = vec4(pow(c, vec3(1./gamma)),1.);\n}","name":"Image","description":"","type":"image"}]}