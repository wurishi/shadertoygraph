{"ver":"0.1","info":{"id":"Xt2cRV","date":"1509332129","viewed":393,"name":"Starry Vortex Flow","username":"riouxld","description":"You can add vorticity by left-clcking with the mouse. You can change the driving force in buffer A.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["simulation","fluid","multipass","navierstokes","jacobi","multistep","vorticity"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Attempt at solving the Navier Stokes equation in it's vorticity form.\n//Clearly there's to much diffusion. maybe vorticity confinement could help\n//but the problem seems to from the scheme and time-stepping.\n\n//You can change the driving force in Buffer A. \n\n//You can add vorticity by left clicking.\n\n//wheel color map add more detail\n\n// choose what field to look at by commenting the others\n//#define VELOCITY\n//#define STREAM\n//#define DIVERGENCE\n#define VORTICITY\n\n// must be modified in all buffers and image\n// simulation parameters\nconst float dt = 1.0/1000.0;\nconst float reynold = 20000.0;\n\n\n//macro\n#define GetVorticity(I,J) texelFetch( iChannel1, ijCoord+ivec2(I,J), 0 ).x\n#define GetStream(I,J) texelFetch( iChannel2, ijCoord+ivec2(I,J), 0 ).x\n#define GetVelocity(I,J) texelFetch( iChannel3, ijCoord+ivec2(I,J), 0 ).xy\n\n// COLORMAP\n\n\nvec3 hot(float t)\n{\n    return vec3(smoothstep(0.00,0.33,t),\n                smoothstep(0.33,0.66,t),\n                smoothstep(0.66,1.00,t));\n}\n\nvec3 jet(float t)\n{\n    return smoothstep(0.5,0.75,t) * vec3(1,0,0)\n         + (smoothstep(0.0,0.25,t)-(smoothstep(0.75,1.0,t))) * vec3(0,1,0)\n        + (1.0-smoothstep(0.25,0.5,t)) * vec3(0,0,1);\n}\n\nvec3 wheel(float t)\n{\n    return clamp(abs(fract(t + vec3(1.0, 2.0 / 3.0, 1.0 / 3.0)) * 6.0 - 3.0) -1.0, 0.0, 1.0);\n}\n\nvec3 cool(float t)\n{\n    return mix( vec3(0.0,1.0,1.0), vec3(1.0,0.0,1.0), t);\n}\n\n// for testing purpose, https://www.shadertoy.com/view/4dlczB\nvec3 blackbody(float t)\n{\n\tfloat Temp = t*7500.0;\n    vec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //set grid\n    float dx = 1.0 / iResolution.y;\n    float dxPow = dx *dx ;\n    vec2 uvCoord = dx*fragCoord.xy;\n    ivec2 ijCoord = ivec2(floor(fragCoord.xy));\n\n    \n    //to compute finite difference approximaton\n    float vorticity = GetVorticity(0,0); \n    float stream = GetStream(0,0); \n\n     //to compute finite difference approximaton\n    vec2 velocity = GetVelocity(0,0); \n    vec2 uvip1j = GetVelocity(1,0); \n    vec2 uvim1j = GetVelocity(-1,0); \n    vec2 uvijp1 = GetVelocity(0,1); \n    vec2 uvijm1 = GetVelocity(0,-1); \n    \n    //Set boundary condition (image method) \n    // Left\n    \n    if (ijCoord.x == 0) \n    {\n        uvim1j = GetVelocity(-ijCoord.x+int(iResolution.x)-1,0);\n    }\n        \n    // Right\n    if (ijCoord.x == int(iResolution.x)-1) \n    {\n        uvip1j = GetVelocity(-ijCoord.x,0);\n    }\n    // Down\n    if (ijCoord.y == 0) \n    {\n        uvijm1 = GetVelocity(0,-ijCoord.y+int(iResolution.y)-1);\n    }\n    // Up\n    if (ijCoord.y == int(iResolution.y)-1) \n    {\n        uvijp1 = GetVelocity(0,-ijCoord.y);\n    }\n    float divervence =  0.5*(uvip1j.x-uvim1j.x+uvijp1.y-uvijm1.y)/dx;\n    \n\n    #ifdef VELOCITY\n    fragColor =vec4(hot(0.15*length((velocity))),1);\n    #endif\n    #ifdef STREAM\n    fragColor =vec4(1.0-hot(0.75*(stream+0.75)),1);\n    #endif\n    #ifdef DIVERGENCE\n    fragColor =vec4(1.0-hot(abs(divervence)),1);\n    #endif\n    #ifdef VORTICITY\n    fragColor =vec4(1.1*(1.0-hot(0.5*(vorticity+1.3))),1);\n    //fragColor =vec4(1.0-wheel(0.5*(vorticity+1.3)),1);\n    #endif\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Set initial condition / perturbation / advection / force\n\n//Select scheme to do backward advection\n//#define EULER\n#define RUNGE\n\n// choose what field to look at by commenting the others\n// comment all to remove driving force.\n//#define VORTICES\n#define LATTICE\n\n// must be modified in all buffers and image\n// simulation parameters\nconst float dt = 1.0/1000.0;\nconst float reynold = 20000.0;\n//macro\n#define GetVelocity(I,J) texelFetch( iChannel3, ijCoord+ivec2(I,J), 0 ).xy\n#define GetVorticity(I,J) texelFetch( iChannel1, ijCoord+ivec2(I,J), 0 ).x\n\n#define GetVelocityUV(XY) texture( iChannel3, vec2(XY)).xy\n#define GetVorticityUV(XY) texture( iChannel1, vec2(XY)).x\n\nvec2 Euler(vec2 posUV){\n    vec2 AspectRatio = iResolution.xy/iResolution.y;\n    return dt*GetVelocityUV(mod(posUV,vec2(1.0)))/AspectRatio;\n}\n\nvec2 Runge(vec2 posUV){\n    vec2 AspectRatio = iResolution.xy/iResolution.y;\n    vec2 k1 = GetVelocityUV(mod(posUV,vec2(1.0)))/AspectRatio;\n    vec2 k2 = GetVelocityUV(mod(posUV-0.5*k1*dt,vec2(1.0)))/AspectRatio;\n    vec2 k3 = GetVelocityUV(mod(posUV-0.5*k2*dt,vec2(1.0)))/AspectRatio;\n    vec2 k4 = GetVelocityUV(mod(posUV-k3*dt,vec2(1.0)))/AspectRatio;\n    return dt/6.*(k1+2.0*k2+2.0*k3+k4);\n}\n\n/*\nstruct Vortex {\n    float orientation;\n    vec2 position;\n    float support;\n};\n*/   \n\n// constant height bumb function\nconst float radius = 0.1; \nfloat bumbCyl(float p)\n{\n\treturn 1.0;\n}\n\n// init vortex \nfloat initVortex( vec2 position, float vortexOri, vec2 vortexPos, float vortexSupp)\n{\n\tvec2 dist = position-vortexPos;\n    return vortexOri*exp(-dot(dist,dist)/vortexSupp);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // set grid\n    float dx = 1.0 / iResolution.y;\n    float dxPow = dx *dx ;\n    vec2 uvCoord = dx*fragCoord.xy;\n    ivec2 ijCoord = ivec2(floor(fragCoord.xy));\n    \n    // initial condition\n    /*\n    if (iFrame==0) {\n        \n        float vortex1 = initVortex(uvCoord, 1.0,vec2(1.7,0.6), 0.02);\n        float vortex2 = initVortex(uvCoord, 1.0,vec2(1.7,0.3), 0.02);\n        fragColor = 1000.0*vec4(vortex1+vortex2,0,0,0);\n        return;\n    }\n    \n    */\n    \n    // init simulation with noise. 15 because we need to calculate the corresponding\n    // stream funciton and velocity to advect.\n    if (iFrame<10) {\n        fragColor = 1.0*vec4(2.0*(texture(iChannel0, uvCoord).x-0.5),0,0,0);\n        return;\n    }\n    \n    \n    // add perturbation with mouse\n    // does not conserve incompressibility\n    float pert = length((fragCoord.xy - iMouse.xy) / iResolution.y);   \n    if(iMouse.z > 0.0 && pert < radius) {\n        vec2 temp = (vec2(fragCoord.y - iMouse.y,-fragCoord.x + iMouse.x)/ iResolution.y)/radius;\n        fragColor = 2.0*vec4(temp.x,0,0,0);\n        return;\n    }\n    \n    \n    // advect via semi-lagrangian method\n    vec2 velocity = GetVelocity(0,0);\n    \n    vec2 posUV =fragCoord/iResolution.xy;\n    #ifdef EULER\n    vec2 posAdvUV = posUV-Euler(posUV);\n    #endif\n    #ifdef RUNGE\n    vec2 posAdvUV = posUV-Runge(posUV);\n    #endif\n    float vortAdv = GetVorticityUV(mod(posAdvUV,vec2(1.0)));\n\n    \n    \n    // add driving force\n    float force = 0.0;\n    #ifdef VORTICES \n    float vortex1 = 2.0*initVortex(uvCoord, sin(0.5*iTime), (iResolution.xy)/iResolution.y/2.0-vec2(0.1), 0.02);\n    float vortex2 = 1.0*initVortex(uvCoord, 1.0, (iResolution.xy)/iResolution.y/2.0+vec2(0.1), 0.01);\n    \n    float vortex3 = 2.0*initVortex(uvCoord, sin(0.5*iTime), (iResolution.xy)/iResolution.y/6.0-vec2(0.1,0.0), 0.02);\n    float vortex4 = 1.0*initVortex(uvCoord, -1.0, (iResolution.xy)/iResolution.y/6.0+vec2(0.1), 0.01);\n    \n    float vortex5 = 2.0*initVortex(uvCoord, cos(0.5*iTime), (iResolution.xy)/iResolution.y/1.3+vec2(0.0,0.1), 0.02);\n    float vortex6 = 1.0*initVortex(uvCoord, -1.0, (iResolution.xy)/iResolution.y/vec2(1.3,10.0)-vec2(0.0,0.1), 0.01);\n    \n    force += vortex1+vortex2+vortex3+vortex4+vortex5+vortex6;\n    #endif\n    #ifdef LATTICE \n    force += 5.0*sin(10.0*uvCoord.x+2.0*iTime)*cos(20.0*uvCoord.y);\n    #endif\n    vortAdv += dt*force;\n    \n    fragColor = vec4(vortAdv, 0, 0, 0); \n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// solve for diffusion\n\n// must be modified in all buffers and image\n// simulation parameters\nconst float dt = 1.0/1000.0;\nconst float reynold = 20000.0;\n\n\n//macro\n#define GetVorticity(I,J) texelFetch( iChannel0, ijCoord+ivec2(I,J), 0 ).x\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // set grid\n    float dx = 1.0 / iResolution.y;\n    float dxPow = dx *dx ;\n    vec2 uvCoord = dx*fragCoord.xy;\n    ivec2 ijCoord = ivec2(floor(fragCoord.xy));\n\n    \n    //to compute finite difference approximaton\n    float vortij = GetVorticity(0,0); \n    float vortip1j = GetVorticity(1,0); \n    float vortim1j = GetVorticity(-1,0); \n    float vortijp1 = GetVorticity(0,1); \n    float vortijm1 = GetVorticity(0,-1); \n    \n    //Set boundary condition (image method) \n    // Left\n    \n    if (ijCoord.x == 0) \n    {\n        vortim1j = GetVorticity(-ijCoord.x+int(iResolution.x)-1,0);\n    }\n        \n    // Right\n    if (ijCoord.x == int(iResolution.x)-1) \n    {\n        vortip1j = GetVorticity(-ijCoord.x,0);\n    }\n    // Down\n    if (ijCoord.y == 0) \n    {\n        vortijm1 = GetVorticity(0,-ijCoord.y+int(iResolution.y)-1);\n    }\n    // Up\n    if (ijCoord.y == int(iResolution.y)-1) \n    {\n        vortijp1 = GetVorticity(0,-ijCoord.y);\n    }\n    \n    //should use more than 1 iteration...\n    //solve with jacobi for new velocity with laplacian\n    float coef = dt/(dxPow*reynold);\n    //float vortDiff = vort+coef*(vortip1+vortim1+vortjp1+vortjm1-4.0*vort);\n    vortij = (vortij+coef*(vortip1j+vortim1j+vortijp1+vortijm1))/(1.0+4.0*coef);\n \n    fragColor = vec4(vortij,0,0,0);\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// solve for stream\n\n// must be modified in all buffers and image\n// simulation parameters\nconst float dt = 1.0/1000.0;\nconst float reynold = 20000.0;\n//macro\n#define GetVorticity(I,J) texelFetch( iChannel1, ijCoord+ivec2(I,J), 0 ).x\n#define GetStream(I,J) texelFetch( iChannel2, ijCoord+ivec2(I,J), 0 ).x\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //set grid\n    float dx = 1.0 / iResolution.y;\n    float dxPow = dx *dx ;\n    vec2 uvCoord = dx*fragCoord.xy;\n    ivec2 ijCoord = ivec2(floor(fragCoord.xy));\n    \n    \n    //to compute finite difference approximaton\n    float vortij = GetVorticity(0,0); \n    \n     //to compute finite difference approximaton\n    float streamij = GetStream(0,0); \n    float streamip1j = GetStream(1,0); \n    float streamim1j = GetStream(-1,0); \n    float streamijp1 = GetStream(0,1);\n    float streamijm1 = GetStream(0,-1);\n    \n    //Set boundary condition (image method) \n    // Left\n    \n    if (ijCoord.x == 0) \n    {\n        streamim1j = GetStream(-ijCoord.x+int(iResolution.x)-1,0);\n    }\n    // Right\n    if (ijCoord.x == int(iResolution.x)-1) \n    {\n        streamip1j = GetStream(-ijCoord.x,0);\n    }\n\n    // Down\n    if (ijCoord.y == 0) \n    {\n        streamijm1 = GetStream(0,-ijCoord.y+int(iResolution.y)-1);\n    }\n    \n    // Up\n    if (ijCoord.y == int(iResolution.y)-1) \n    {\n        streamijp1 = GetStream(0,-ijCoord.y);\n    }\n    \n    \n    // should use more than 1 iteration...\n    // compute stream via jacobi iteration... \n    // sadly it take a while for the stream initial condition to be computed...\n    \n    streamij = (-vortij+dt/dxPow*(streamip1j+streamim1j+streamijp1+streamijm1))/(1.0+4.0*dt/dxPow);\n    //float streamHarm = 0.25*((streamip1+streamim1)+(streamjp1+streamjm1)+dxPow*vort);\n          \n    fragColor = vec4(streamij,0,0,0);\n}","name":"Buf C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// compute velocity\n\n// must be modified in all buffers and image\n// simulation parameters\nconst float dt = 1.0/1000.0;\nconst float reynold = 20000.0;\n\n//macro\n#define GetStream(I,J) texelFetch( iChannel2, ijCoord+ivec2(I,J), 0 ).x\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //set grid\n    float dx = 1.0 / iResolution.y;\n    float dxPow = dx *dx ;\n    vec2 uvCoord = dx*fragCoord.xy;\n    ivec2 ijCoord = ivec2(floor(fragCoord.xy));\n    \n    \n    //to compute finite difference approximaton\n    float streamij = GetStream(0,0); \n    float streamip1j = GetStream(1,0); \n    float streamim1j = GetStream(-1,0); \n    float streamijp1 = GetStream(0,1);\n    float streamijm1 = GetStream(0,-1);\n    \n    //Set boundary condition (image method) \n    // Left\n    \n    if (ijCoord.x == 0) \n    {\n        streamim1j = GetStream(-ijCoord.x+int(iResolution.x)-1,0);\n    }\n    // Right\n    if (ijCoord.x == int(iResolution.x)-1) \n    {\n        streamip1j = GetStream(-ijCoord.x,0);\n    }\n\n    // Down\n    if (ijCoord.y == 0) \n    {\n        streamijm1 = GetStream(0,-ijCoord.y+int(iResolution.y)-1);\n    }\n    \n    // Up\n    if (ijCoord.y == int(iResolution.y)-1) \n    {\n        streamijp1 = GetStream(0,-ijCoord.y);\n    }\n  \n    //compute velocity from stream function\n    \n    vec2 uij =  0.5*vec2(streamijp1-streamijm1, -(streamip1j-streamim1j))/dx;\n    \n    fragColor = vec4(uij, 0, 0);\n}","name":"Buf D","description":"","type":"buffer"}]}