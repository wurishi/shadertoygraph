{"ver":"0.1","info":{"id":"4dG3RV","date":"1455275160","viewed":145,"name":"Test new shader shit 2","username":"suspiciousimage","description":"Test new shader shit 2","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["testnewshadershit2"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int RAY_MARCHING_ITERATIONS = 95;\nconst float RAY_MARCHING_TMAX = 40.0;\nconst float MATERIAL_SKY = -1.0;\nconst float MATERIAL_FLOOR = 1.49;\nconst float MATERIAL_BALL = 47.0;\nconst vec3 COLOR_SKY = vec3(0.8, 0.7, 0.5);\nconst vec3 COLOR_BALL = vec3(0.2, 0.5, 0.9);\nconst vec3 COLOR_FLOOR = vec3(0.2, 0.2, 0.2);\n\n\nvec2 hash( vec2 p ) {\n\tp = vec2( dot(p,vec2(107.1,301.7)),\n\t\t\t  dot(p,vec2(151.5,353.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\tvec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( dot(hash( i + vec2(0.0,0.0)), f - vec2(0.0,0.0)), \n                     dot(hash( i + vec2(1.0,0.0)), f - vec2(1.0,0.0)), u.x),\n                mix( dot(hash( i + vec2(0.0,1.0)), f - vec2(0.0,1.0)), \n                     dot(hash( i + vec2(1.0,1.0)), f - vec2(1.0,1.0)), u.x), u.y);\n}\n\nfloat fractalnoise(in vec2 p, float scale, float opacity) {\n\tfloat f = 0.0;\n    p *= scale;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    f  = 0.5000*noise(p); \n    p = m*p;\n    f += 0.2500*noise(p); \n    p = m*p;\n    f += 0.1250*noise(p); \n    p = m*p;\n    f += 0.0625*noise(p); \n    p = m*p;\n    f += 0.0312*noise(p); \n\treturn (1.0 - opacity) + opacity * f;\n}\n\n// Objects\t\nfloat objectFloor(vec3 pos, float level) {\n\treturn pos.y - level;\n} \n\nfloat objectSphere(vec3 pos, float radius) {\n\treturn length(pos) - radius;\n} \n\n// Dado un vector de (distancia, material) y otro (distancia, material) retorna el que tenga menor distancia\nvec2 opU(vec2 d1, vec2 d2) {\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\n// PodrÃ­a separarse dos versiones donde una no devuelva el material y usarlo en el calculo de normales (ver si optimiza x default)\nvec2 hit(in vec3 pos) {\n\tvec3 sphereRotPoint = vec3(pos.x + cos(iTime + pos.z), \n                               pos.y + 0.5 * sin(iTime + pos.z), \n                               mod(pos.z + iTime * 4.0, 0.75))\n                           \t- vec3(-1.25, 0.1, 0.2);\n  \t\n    vec2 sphereZ = vec2(objectSphere(\n                    \tvec3(pos.x, pos.y, mod(pos.z + iTime, 1.0)) \n       \t\t\t\t\t\t- vec3(-1.25, 0.1, 0.2), 0.25), MATERIAL_BALL),\n         sphereRot = vec2(objectSphere(sphereRotPoint, 0.15), MATERIAL_BALL),\n         sphereRotRot =\n        \tvec2(objectSphere(\n        \t\tsphereRotPoint + \n        \t\tvec3(0.25 * cos(iTime * 2.0),\n                     0.25 * sin(iTime * 2.0),\n                     0.0),\n                  0.06),\n                 \tMATERIAL_BALL),\n        sphereRotRot2 = vec2(objectSphere(\n        \t\tsphereRotPoint + \n        \t\tvec3(0.25 * cos(iTime * 2.0 + 6.28 * 0.33),\n                     0.25 * sin(iTime * 2.0 + 6.28 * 0.33),\n                     0.0),\n                  0.06),\n                 \tMATERIAL_BALL),\n        sphereRotRot3 = vec2(objectSphere(\n        \t\tsphereRotPoint + \n        \t\tvec3(0.25 * cos(iTime * 2.0 + 6.28 * 0.66),\n                     0.25 * sin(iTime * 2.0 + 6.28 * 0.66),\n                     0.0),\n                  0.06),\n                 \tMATERIAL_BALL),\n        floorPlane = vec2(objectFloor(pos - vec3(0.25, -1.0, 0.0), 0.0), MATERIAL_FLOOR);\n    \n    vec2 res = opU(opU(opU(sphereRotRot, opU(sphereRotRot2, sphereRotRot3)), floorPlane), \n                   opU(sphereRot, sphereRot));\n    \n    return res;\n}\n\nvec3 calcNormal(in vec3 pos) {\n\tvec3 eps = vec3(0.001, 0.0, 0.0);\n\tvec3 nor = vec3(\n\t\thit(pos + eps.xyy).x - hit(pos - eps.xyy).x,\n\t\thit(pos + eps.yxy).x - hit(pos - eps.yxy).x,\n\t\thit(pos + eps.yyx).x - hit(pos - eps.yyx).x);\n\treturn normalize(nor);\n}\n\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr) {\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr), 0.0);\n\tvec3 cu = normalize(cross(cw, cp));\n\tvec3 cv = normalize(cross(cu, cw));\n\treturn mat3(cu, cv, cw);\n}\n\nbool isMaterial (float material, float value) {\n\treturn abs(material - value) < 0.01;\n}\n\nvec3 colorForMaterial(float material, vec3 p) {\n\t// #TODO: Pasar a tabla\n\tif (isMaterial(material, MATERIAL_FLOOR)) {\n        return 0.4 + COLOR_FLOOR * mod(floor(p.x * 4.0) + floor(p.z * 4.0), 2.0);\n\t}\n\telse if (isMaterial(material, MATERIAL_BALL))\n\t\treturn COLOR_BALL;\n\telse if (isMaterial(material, MATERIAL_SKY))\n\t\treturn vec3(fractalnoise(vec2(p.x / 20.0, p.z), 0.1, 0.2));\n\t\t//return COLOR_SKY;\n\telse\n\t\t// #NOTE: green is error color :)\n\t\treturn vec3(0.0, 1.0, 0.0);\n}\n\nvec2 castRayToWorld(in vec3 ro, in vec3 rd) {\n\tfloat tmin=1.0, tmax=RAY_MARCHING_TMAX, precis=0.01, t=tmin, m=-1.0;\n\n\tfor (int i=0; i< RAY_MARCHING_ITERATIONS; i++) {\n\t\tvec2 p = hit(ro + rd * t);\n\t\tif ((precis > p.x) || (t > tmax)) break;\n\t\t// En x viene la distancia al objeto\n\t\tt += p.x;\n\t\t// El material vuelve en la segunda coordenada\n\t\tm = p.y;\n\t}\n\n\t// m = -1.0 significa que pega en el infinito\n\tif (t > tmax) m = -1.0;\n\treturn vec2(t, m);\n}\n\nvec3 render(in vec3 ro, in vec3 rd) {\n\tvec2 value = castRayToWorld(ro, rd);\n\tfloat distance = value.x;\n\tfloat material = value.y;\n\tvec3 color;\n\t\n\tif (isMaterial(material, MATERIAL_SKY)) \n\t\t// #ADD: PodrÃ­a depender de la posicion tambiÃ©n, para usar un hash + perlin\n\t\tcolor = COLOR_SKY;\n\telse {\n\t\tvec3 pos = ro + distance * rd;\n\t\t\n\t\t// Material\n\t\tcolor = colorForMaterial(material, pos);\n\t\t// Normal\n\t\tvec3 normal = calcNormal(pos);\n\t\t//vec3 ref = reflect(rd, normal);\n\t\t// #TODO: Factorizar para tener varias luces\n\t\tvec3 light = normalize(vec3(-0.6, 0.7, -0.5));\t\n\t\tfloat dif = clamp(dot(normal, light), 0.0, 1.0);\n\t\t// Lighting\n\t\t\t// Ambient occlusion\n\t\t\t// Shadow\n\t\t\t// Ambient lighting\n\t\t\tfloat amb = clamp(0.5+0.5*normal.y, 0.0, 1.0);\n\t\t\n\t\t// Mix\n\t\tvec3 brdf = vec3(dif);\n\t\tbrdf += 1.2 * amb * vec3(0.50, 0.20, 1.00);\n\t\tcolor *= brdf;\n\t}\n\t\n\treturn color;\n} \n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\t// Ajuste de definicion\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\t// #VER: Aspect adjustment ??\n\tvec2 p = q * 2.0 - 1.0;\n\tp.x *= iResolution.x / iResolution.y;\n\t// Calculamos camara (algo a la izquierda del medio, un toque arriba y mirando para adelante 2.5).\n\t//vec3 ro = vec3(-0.5, 0.75, 4.5);\n    vec3 ro = vec3(-1.25, 0.25, iTime);\n\tvec3 ta = vec3(-3.5 + iMouse.x / 100.0, -1.1  + iMouse.y / 100.0 , 0.5 );\n\t// Matriz de la camara\n\tmat3 ca = setCamera(ro, ta, 0.0);\n\t// Disparamos rayo\n\t// #TODO: Ver normalizacion con dimensiones de arriba y dejar en unidad\n\tvec3 rd = ca * normalize(vec3(p.xy, 2.5));\n\t// Renderizamos ese punto\n\tfragColor = vec4(render(ro, rd), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}