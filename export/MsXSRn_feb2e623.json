{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\n-Otavio Good\n*/\n#define saturate(a) clamp(a, 0., 1.)\n\n// makes a thick line and passes back gray in x and derivates for lighting in yz\nvec3 ThickLine(vec2 uv, vec2 posA, vec2 posB, float radiusInv)\n{\n\tvec2 dir = posA - posB;\n\tfloat dirLen = length(dir);\n\tvec2 dirN = normalize(dir);\n\tfloat dotTemp = clamp(dot(uv - posB, dirN), 0.0, dirLen);\n\tvec2 proj = dotTemp * dirN + posB;\n\tfloat d1 = distance(uv, proj);\n\tvec2 derivative = (uv - proj);\n\n\tfloat finalGray = saturate(1.0 - d1 * radiusInv);\n\t// multiply derivative by gray so it smoothly fades out at the edges.\n\treturn vec3(finalGray, derivative * finalGray);\n}\n\n// makes a rune in the 0..1 uv space. Seed is which rune to draw.\n// passes back gray in x and derivates for lighting in yz\nvec3 Rune(vec2 uv, vec2 seed)\n{\n\tvec3 finalLine = vec3(0.0, 0.0, 0.0);\n\tfor (int i = 0; i < 4; i++)\t// number of strokes\n\t{\n\t\t// generate seeded random line endPoints - just about any texture should work.\n\t\t// Hopefully this randomness will work the same on all GPUs (had some trouble with that)\n\t\tvec2 posA = texture(iChannel1, floor(seed+0.5) / iChannelResolution[1].xy).xy;\n\t\tvec2 posB = texture(iChannel1, floor(seed+1.5) / iChannelResolution[1].xy).xy;\n\t\tseed += 2.0;\n\t\t// expand the range and mod it to get a nicely distributed random number - hopefully. :)\n\t\tposA = fract(posA * 128.0);\n\t\tposB = fract(posB * 128.0);\n\t\t// each rune touches the edge of its box on all 4 sides\n\t\tif (i == 0) posA.y = 0.0;\n\t\tif (i == 1) posA.x = 0.999;\n\t\tif (i == 2) posA.x = 0.0;\n\t\tif (i == 3) posA.y = 0.999;\n\t\t// snap the random line endpoints to a grid 2x3\n\t\tvec2 snaps = vec2(2.0, 3.0);\n\t\tposA = (floor(posA * snaps) + 0.5) / snaps;\t// + 0.5 to center it in a grid cell\n\t\tposB = (floor(posB * snaps) + 0.5) / snaps;\n\t\t//if (distance(posA, posB) < 0.0001) continue;\t// eliminate dots.\n\n\t\t// Dots (degenerate lines) are not cross-GPU safe without adding 0.001 - divide by 0 error.\n\t\tvec3 tl = ThickLine(uv, posA, posB + 0.001, 10.0);\n\t\tif (tl.x > finalLine.x) finalLine = tl;\n\t}\n\treturn finalLine.xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv.x *= iResolution.x / iResolution.y;\n\tuv.x += iTime * 0.03;\t// scroll left with time\n\tvec3 finalColor = texture(iChannel1, uv * vec2(1.0, -1.0)).xyz;\t// background texture\n\tfinalColor = finalColor * finalColor;\t// gamma correct\n\n\t//finalColor += ThickLine(uv, vec2(0.8, 0.2), vec2(0.8, 0.8), 8.0) * vec3(0.0, 10.0, 10.0);\n\tvec4 noise = texture(iChannel0, uv*3.0);\n\tuv += noise.xy*0.003;\t// noise makes everything look more natural\n\n\t// make a grid for drawing the runes.\n\tuv *= 16.0;\n\tuv.y *= 0.8;\n\tvec2 newSeed = floor(uv);\n\t// the mod kills every other line. I just thought it looks better.\n\tvec3 finalLine = Rune(fract(uv), newSeed-0.41) * mod(newSeed.y, 2.0);\n\n\tfinalColor = saturate(finalColor * (1.0 - pow(finalLine.x, 0.55)*0.97)) * (1.0+saturate(-finalLine.z)*128.0);\n\t//finalColor += fract(newSeed.xyy*0.123);\t// view grid\n\n\tfragColor = vec4(sqrt(finalColor),1.0);\n}\n\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MsXSRn","date":"1398149033","viewed":3801,"name":"runes","username":"otaviogood","description":"This is just the rune generator from my \"Solstice\" shader. I tried my best to make the random numbers consistent across GPUs so I could pick seeds that look like actual letters, but something tells me it's only 90%ish.","likes":115,"published":1,"flags":0,"usePreview":0,"tags":["procedural","font","letters","runes"],"hasliked":0,"parentid":"","parentname":""}}