{"ver":"0.1","info":{"id":"wdXXRS","date":"1551519296","viewed":323,"name":"Circular DOF revised","username":"egon","description":"Simplified code of https://www.shadertoy.com/view/Xd2BWc","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["circulardof","separabledof","siggraph2017"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// iChannelX = \n//    horizontally blurred X complex color,\n//    where xy and zw are different kernels\n//\n// blurs in vertical direction and calculates the final color.\n\n//(Pr+Pi)*(Qr+Qi) = (Pr*Qr+Pr*Qi+Pi*Qr-Pi*Qi)\nvec2 cmul(vec2 p, vec2 q)\n{\n    return vec2(p.x*q.x-p.y*q.y, p.x*q.y+p.y*q.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 stepVal = 1.0/iResolution.xy;\n  \n    vec4 valR = vec4(0,0,0,0);\n    vec4 valG = vec4(0,0,0,0);\n    vec4 valB = vec4(0,0,0,0);\n\n    float filterRadius = texture(iChannel3, uv).a;\n    for (int i=-KERNEL_RADIUS; i <=KERNEL_RADIUS; ++i)\n    {\n        vec2 coords = uv + stepVal*vec2(0.0,float(i))*filterRadius;\n\n        vec4 hblurR = texture(iChannel0, coords);  \n        vec4 hblurG = texture(iChannel1, coords);  \n        vec4 hblurB = texture(iChannel2, coords);  \n        \n        vec2 c0 = Kernel0_RealX_ImY_RealZ_ImW[i+KERNEL_RADIUS].xy;\n        vec2 c1 = Kernel1_RealX_ImY_RealZ_ImW[i+KERNEL_RADIUS].xy;\n\n        valR.xy += cmul(hblurR.xy, c0.xy);\n        valR.zw += cmul(hblurR.zw, c1.xy);\n        \n        valG.xy += cmul(hblurG.xy, c0.xy);\n        valG.zw += cmul(hblurG.zw, c1.xy);\n        \n        valB.xy += cmul(hblurB.xy, c0.xy);\n        valB.zw += cmul(hblurB.zw, c1.xy);       \n    }\n    \n    vec3 color = vec3(\n        dot(valR.xy, Kernel0Weights_RealX_ImY) + dot(valR.zw, Kernel1Weights_RealX_ImY),\n        dot(valG.xy, Kernel0Weights_RealX_ImY) + dot(valG.zw, Kernel1Weights_RealX_ImY),\n        dot(valB.xy, Kernel0Weights_RealX_ImY) + dot(valB.zw, Kernel1Weights_RealX_ImY)\n    );\n\n    fragColor = vec4(sqrt(color),1.0);   \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Circular DOF by Kleber Garcia \"Kecho\" - 2017\n// See https://www.shadertoy.com/view/Xd2BWc for the original.\n//\n// Click mouse in image and move to test circle dof size.\n// Big circles can get achieved in linear time.\n// Publication & Filter generator: https://github.com/kecho/CircularDofFilterGenerator\n// yehar's blog: http://yehar.com/blog/?p=1495\n//\n\n// Test knobs:\n#define ANIMATE_FILTER_SIZE\n#define SLIDE_SHOW\n//filter size can be bigger than 1, but then undersampling will occur.\n#define MAX_FILTER_SIZE 1.0\n\n// Prenormalization step available in siggraph publication. Can be generated by an offline tool, or passed as a cbuffer.\n// Small slideshow to show effect on multiple images.\n\n//Filter values:\n/********************************************************************/\n/********************************************************************/\n/*         Generated Filter by CircularDofFilterGenerator tool      */\n/*     Copyright (c)     Kleber A Garcia  (kecho_garcia@hotmail.com)*/\n/*           https://github.com/kecho/CircularDofFilterGenerator    */\n/********************************************************************/\n/********************************************************************/\n/**\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n**/\n\nconst int KERNEL_RADIUS = 8;\nconst int KERNEL_COUNT = 17;\n\nconst vec4 Kernel0BracketsRealXY_ImZW = vec4(-0.038708,0.943062,-0.025574,0.660892);\nconst vec2 Kernel0Weights_RealX_ImY = vec2(0.411259,-0.548794);\nconst vec4 Kernel0_RealX_ImY_RealZ_ImW[] = vec4[](\n        vec4(/*XY: Non Bracketed*/0.014096,-0.022658,/*Bracketed WZ:*/0.055991,0.004413),\n        vec4(/*XY: Non Bracketed*/-0.020612,-0.025574,/*Bracketed WZ:*/0.019188,0.000000),\n        vec4(/*XY: Non Bracketed*/-0.038708,0.006957,/*Bracketed WZ:*/0.000000,0.049223),\n        vec4(/*XY: Non Bracketed*/-0.021449,0.040468,/*Bracketed WZ:*/0.018301,0.099929),\n        vec4(/*XY: Non Bracketed*/0.013015,0.050223,/*Bracketed WZ:*/0.054845,0.114689),\n        vec4(/*XY: Non Bracketed*/0.042178,0.038585,/*Bracketed WZ:*/0.085769,0.097080),\n        vec4(/*XY: Non Bracketed*/0.057972,0.019812,/*Bracketed WZ:*/0.102517,0.068674),\n        vec4(/*XY: Non Bracketed*/0.063647,0.005252,/*Bracketed WZ:*/0.108535,0.046643),\n        vec4(/*XY: Non Bracketed*/0.064754,0.000000,/*Bracketed WZ:*/0.109709,0.038697),\n        vec4(/*XY: Non Bracketed*/0.063647,0.005252,/*Bracketed WZ:*/0.108535,0.046643),\n        vec4(/*XY: Non Bracketed*/0.057972,0.019812,/*Bracketed WZ:*/0.102517,0.068674),\n        vec4(/*XY: Non Bracketed*/0.042178,0.038585,/*Bracketed WZ:*/0.085769,0.097080),\n        vec4(/*XY: Non Bracketed*/0.013015,0.050223,/*Bracketed WZ:*/0.054845,0.114689),\n        vec4(/*XY: Non Bracketed*/-0.021449,0.040468,/*Bracketed WZ:*/0.018301,0.099929),\n        vec4(/*XY: Non Bracketed*/-0.038708,0.006957,/*Bracketed WZ:*/0.000000,0.049223),\n        vec4(/*XY: Non Bracketed*/-0.020612,-0.025574,/*Bracketed WZ:*/0.019188,0.000000),\n        vec4(/*XY: Non Bracketed*/0.014096,-0.022658,/*Bracketed WZ:*/0.055991,0.004413)\n);\n\nconst vec4 Kernel1BracketsRealXY_ImZW = vec4(0.000115,0.559524,0.000000,0.178226);\nconst vec2 Kernel1Weights_RealX_ImY = vec2(0.513282,4.561110);\nconst vec4 Kernel1_RealX_ImY_RealZ_ImW[] = vec4[](\n        vec4(/*XY: Non Bracketed*/0.000115,0.009116,/*Bracketed WZ:*/0.000000,0.051147),\n        vec4(/*XY: Non Bracketed*/0.005324,0.013416,/*Bracketed WZ:*/0.009311,0.075276),\n        vec4(/*XY: Non Bracketed*/0.013753,0.016519,/*Bracketed WZ:*/0.024376,0.092685),\n        vec4(/*XY: Non Bracketed*/0.024700,0.017215,/*Bracketed WZ:*/0.043940,0.096591),\n        vec4(/*XY: Non Bracketed*/0.036693,0.015064,/*Bracketed WZ:*/0.065375,0.084521),\n        vec4(/*XY: Non Bracketed*/0.047976,0.010684,/*Bracketed WZ:*/0.085539,0.059948),\n        vec4(/*XY: Non Bracketed*/0.057015,0.005570,/*Bracketed WZ:*/0.101695,0.031254),\n        vec4(/*XY: Non Bracketed*/0.062782,0.001529,/*Bracketed WZ:*/0.112002,0.008578),\n        vec4(/*XY: Non Bracketed*/0.064754,0.000000,/*Bracketed WZ:*/0.115526,0.000000),\n        vec4(/*XY: Non Bracketed*/0.062782,0.001529,/*Bracketed WZ:*/0.112002,0.008578),\n        vec4(/*XY: Non Bracketed*/0.057015,0.005570,/*Bracketed WZ:*/0.101695,0.031254),\n        vec4(/*XY: Non Bracketed*/0.047976,0.010684,/*Bracketed WZ:*/0.085539,0.059948),\n        vec4(/*XY: Non Bracketed*/0.036693,0.015064,/*Bracketed WZ:*/0.065375,0.084521),\n        vec4(/*XY: Non Bracketed*/0.024700,0.017215,/*Bracketed WZ:*/0.043940,0.096591),\n        vec4(/*XY: Non Bracketed*/0.013753,0.016519,/*Bracketed WZ:*/0.024376,0.092685),\n        vec4(/*XY: Non Bracketed*/0.005324,0.013416,/*Bracketed WZ:*/0.009311,0.075276),\n        vec4(/*XY: Non Bracketed*/0.000115,0.009116,/*Bracketed WZ:*/0.000000,0.051147)\n);\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Preprocess initial image.\n//    out.rgb = HDR color\n//    out.a   = filterRadius\n\nvec4 fetchImageHDR(vec2 coords, sampler2D tex)\n{\n    vec4 colorImg = texture(tex, coords);    \n    \n    //luma trick to mimic HDR, and take advantage of 16 bit buffers shader toy provides.\n    float lum = dot(colorImg.rgb,vec3(0.2126,0.7152,0.0722))*1.8;\n    colorImg = colorImg *(1.0 + 0.2*lum*lum*lum);\n\n    return colorImg * colorImg;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec4 imageA = fetchImageHDR(uv, iChannel0);\n    vec4 imageB = fetchImageHDR(uv, iChannel1);\n    \n    #ifdef SLIDE_SHOW    \n    float t = clamp(4.0*sin(0.2*iTime),-1.0,1.0)*0.5+0.5;\n    #else\n    float t = 0.0;\n    #endif\n    \n    vec3 finalCol = mix(imageA, imageB, t).rgb;\n\n    #ifdef ANIMATE_FILTER_SIZE\n    float filterSize = MAX_FILTER_SIZE*clamp(abs(4.0*sin(iTime * 0.7)),0.0,1.0);\n    #else\n    float filterSize = MAX_FILTER_SIZE;\n    #endif\n    \n    if (iMouse.z > 0.0)\n    {\n        vec2 mouseCoords = (iMouse.xy/iResolution.xy);\n        filterSize = 3.0*MAX_FILTER_SIZE*max(mouseCoords.x,mouseCoords.y);\n    }\n    \n   \tfragColor = vec4(finalCol, filterSize);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// blur R component horizontally using two complex kernels\n//   out.xy = output of Kernel0\n//   out.zw = output of Kernel1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 pixelSize = 1.0 / iResolution.xy;\n    \n    vec4 val = vec4(0,0,0,0);\n    float filterRadius = texture(iChannel0, uv).a;\n\n    for (int i=-KERNEL_RADIUS; i <=KERNEL_RADIUS; ++i)\n    {\n        vec2 p = uv + pixelSize*vec2(float(i), 0.0)*filterRadius;\n        float color = texture(iChannel0, p).r;\n        \n        vec2 c0 = Kernel0_RealX_ImY_RealZ_ImW[i+KERNEL_RADIUS].xy;\n        vec2 c1 = Kernel1_RealX_ImY_RealZ_ImW[i+KERNEL_RADIUS].xy;\n\n        val.xy += color * c0.xy;\n        val.zw += color * c1.xy;\n    }\n\n    fragColor = val;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// blur G component horizontally using two complex kernels\n//   out.xy = output of Kernel0\n//   out.zw = output of Kernel1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 pixelSize = 1.0 / iResolution.xy;\n    \n    vec4 val = vec4(0,0,0,0);\n    float filterRadius = texture(iChannel0, uv).a;\n\n    for (int i=-KERNEL_RADIUS; i <=KERNEL_RADIUS; ++i)\n    {\n        vec2 p = uv + pixelSize*vec2(float(i), 0.0)*filterRadius;\n        float color = texture(iChannel0, p).g;\n        \n        vec2 c0 = Kernel0_RealX_ImY_RealZ_ImW[i+KERNEL_RADIUS].xy;\n        vec2 c1 = Kernel1_RealX_ImY_RealZ_ImW[i+KERNEL_RADIUS].xy;\n\n        val.xy += color * c0.xy;\n        val.zw += color * c1.xy;\n    }\n\n    fragColor = val;\n}\n","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// blur B component horizontally using two complex kernels\n//   out.xy = output of Kernel0\n//   out.zw = output of Kernel1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 pixelSize = 1.0 / iResolution.xy;\n    \n    vec4 val = vec4(0,0,0,0);\n    float filterRadius = texture(iChannel0, uv).a;\n\n    for (int i=-KERNEL_RADIUS; i <=KERNEL_RADIUS; ++i)\n    {\n        vec2 p = uv + pixelSize*vec2(float(i), 0.0)*filterRadius;\n        float color = texture(iChannel0, p).b;\n        \n        vec2 c0 = Kernel0_RealX_ImY_RealZ_ImW[i+KERNEL_RADIUS].xy;\n        vec2 c1 = Kernel1_RealX_ImY_RealZ_ImW[i+KERNEL_RADIUS].xy;\n\n        val.xy += color * c0.xy;\n        val.zw += color * c1.xy;\n    }\n\n    fragColor = val;\n}\n","name":"Buffer D","description":"","type":"buffer"}]}