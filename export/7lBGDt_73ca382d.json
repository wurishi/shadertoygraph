{"ver":"0.1","info":{"id":"7lBGDt","date":"1628598340","viewed":79,"name":"3D balls fuse","username":"TFoucour","description":"3D balls fuse","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3dballsfuse"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nvec3 hash( vec3 p ) // replace this by something better. really. do\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n// returns 3D value noise\nfloat noise( vec3 x )\n{\n    // grid\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    // quintic interpolant\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n\n    \n    // gradients\n    vec3 ga = hash( p+vec3(0.0,0.0,0.0) );\n    vec3 gb = hash( p+vec3(1.0,0.0,0.0) );\n    vec3 gc = hash( p+vec3(0.0,1.0,0.0) );\n    vec3 gd = hash( p+vec3(1.0,1.0,0.0) );\n    vec3 ge = hash( p+vec3(0.0,0.0,1.0) );\n    vec3 gf = hash( p+vec3(1.0,0.0,1.0) );\n    vec3 gg = hash( p+vec3(0.0,1.0,1.0) );\n    vec3 gh = hash( p+vec3(1.0,1.0,1.0) );\n    \n    // projections\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\n\t\n    // interpolation\n    return va + \n           u.x*(vb-va) + \n           u.y*(vc-va) + \n           u.z*(ve-va) + \n           u.x*u.y*(va-vb-vc+vd) + \n           u.y*u.z*(va-vc-ve+vg) + \n           u.z*u.x*(va-vb-ve+vf) + \n           u.x*u.y*u.z*(-va+vb+vc-vd+ve-vf-vg+vh);\n}\n\nfloat map(vec3 p){\n    float noise = noise(p*5.);\n    float d = sphere(p+vec3(0., sin(iTime), -2.), 1.3);\n    d = min(d, p.y+1.);\n    //d = cos(d)*sin(d)*.4;\n    return d+noise*.2;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ));\n}\n\nvec3 trace( vec3 ro, vec3 rd) {\n\n    vec3 p = ro;\n    for(int i=0; i <255; i++){\n        p += rd * map(p); \n    }\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv*2.-1.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(0., 0., -1.);\n    vec3 rd = normalize(vec3(uv, 1.));\n    vec3 p = trace(ro, rd);\n    \n    vec3 color = vec3(.5,.3,.0);\n    \n    \n    vec3 normal = calcNormal(p);\n    vec3 soleil_direction = normalize(vec3(0.25, 1., 0.5));\n    \n\n    // Time varying pixel color\n    vec3 col = vec3(1.) * max( dot(normal,soleil_direction), 0.); \n    col = clamp(col, vec3(0.), vec3(1.));\n    col = mix(col, vec3(1.), min(distance(p,ro)*0.1, 1.));\n    \n    //col += vec3(.6, .5, .3);\n\n\n    vec3 pshadow = trace(p+normal*.1, soleil_direction);\n    if (map(pshadow) < 1.)\n        col *= 0.25;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}