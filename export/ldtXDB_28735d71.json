{"ver":"0.1","info":{"id":"ldtXDB","date":"1461373245","viewed":362,"name":"Drone Cells","username":"drone1","description":"Inspired by IQ's square fractal thingy (https://www.shadertoy.com/view/Ml2GWy). Please let me know if I did anything dumb. I'm here to learn. Thanks.","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["2d","lights","cells"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NUM_CELLS\t8\n#define SS\t\t\t2\n\nfloat tex( vec2 uv )\n{\n\treturn texture( iChannel0, uv ).r;\n}\n\nvec2 norm( vec2 uv )\n{\n    vec2 n = vec2( 0.0 );\n    vec2 ir = 1.0 / iResolution.xy;\n    vec2 eps = vec2( ir.x, 0.0 );    \n  \n    for ( int i = 0; i < SS; ++i )\n    for ( int j = 0; j < SS; ++j )\n    {\n        vec2 o = ir * vec2( float( i ), float( j ) ) / float( SS );\n        n += vec2(\n            tex( uv - eps.xy + o ) - tex( uv + eps.xy + o ),\n            tex( uv - eps.yx + o ) - tex( uv + eps.yx + o )\n        );\n    }\n    \n    return n / float( SS * SS );\n}\n\nfloat light( vec2 uv, vec2 lp )\n{\n    return 1.0 - pow( clamp( dot( norm( uv ), normalize( lp - uv ) ), 0.0, 1.0 ), 0.2 );\n}\n\nvec3 render( vec2 uv )\n{\n    float aspect = iResolution.x / iResolution.y;\n    const float nc = float( NUM_CELLS );\n    \n    float d = 1.0 / nc;\n    float t = iTime * 0.01;\n    vec2 offset = iTime * 0.1 * vec2( 0.1, 0.13 ) + vec2( cos( t ), sin( t ) );\n    vec2 p = mod( offset + vec2( uv.x * aspect, uv.y ), d ) / d;\n\n    float lt = 1.0 * iTime * 0.5;\n    vec2 lp = vec2( 0.5 * aspect*(0.5+0.5*cos( 0.5*lt )), 0.5+0.4*sin( lt ) );\n    \n    float ss = mix(\t2.0, 2.4, smoothstep( 0.5, 0.0, length( uv - lp ) ) );\n    float s = ss*ss;\n    vec3 c = s * vec3( 0.6, 0.3, 0.25 );\n    c *= 0.8;\n    \n    vec2 cell_dims = vec2( 1.0 / nc, 1.0 / nc );\n    vec2 mod_offset = mod( offset, cell_dims );\n    vec2 grid = vec2(\n        floor( ( aspect * uv.x + mod_offset.x ) * nc ) / nc,\n        floor( ( uv.y + mod_offset.y ) * float( NUM_CELLS ) ) / float( NUM_CELLS )\n    );\n\n    float dim = smoothstep( 0.0, cell_dims.x, mod_offset.x );\n    float id = 10.0 * fract( 98743.32 * ( 0.5 + 0.5 * sin( dot( grid, vec2( 12.0, 987654.0 ) ) ) ) );\n    vec3 clr = vec3( 1.0 );\n    clr.r = clamp( uv.x * aspect, 0.0, 1.0 );\n    float f = mix( 16.0, 0.1, ( 0.5 + 0.5 * sin( 3.14159 * dim ) ) * mod( id, 10.0 ) / 10.0 );\n    clr *= c * sqrt( f * p.x * ( 1.0 - p.x ) * p.y * ( 1.0 - p.y ) );\n    const float light_t = 0.015 * 2.5;\n    vec2 offset_2 = vec2( offset.x / aspect, offset.y );\n    float lv = light( uv + offset_2, lp + offset_2 );\n    clr = ( 1.0 - light_t ) * clr + light_t * lv * clr;\n    clr *= sqrt( 16.0 * uv.y * ( 1.0 - uv.y ) * uv.x * ( 1.0 - uv.x ) );\n    clr += ( 12.0 / 255.0 ) * fract( 23423.0 * sin( iTime + uv.x * 952.2 + uv.y * 38.63 ) );\n    clr *= 1.0 + 0.2 * dim;\n\n    return clr;\n}\n\nvoid mainImage( out vec4 fc, in vec2 coord )\n{\n\tvec2 uv = coord.xy / iResolution.xy;\n    fc = vec4( render( uv ), 1.0 );\n}","name":"Image","description":"","type":"image"}]}