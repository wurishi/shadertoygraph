{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"music","id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"#define PRECISION 0.001\n\n//----------------------------------------------------\n\nvec3 opTwist(vec3 p) {\n\tfloat c = cos(5.0*p.y);\n    float s = sin(5.0*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\nvec2 opU(vec2 d1, vec2 d2) {\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\nvec3 opT(vec3 p, vec3 t) {\n\treturn p - t;\n}\n\nvec3 opD(vec3 p, float c) {\n\treturn mod(p, c) - 0.5 * c;\n}\n\nvec2 opS(vec2 d1, vec2 d2) {\n\treturn vec2(max(-d2.x, d1.x), 2.0);\n}\n\n//-----------------------------------------------------\n\nvec2 sdSphere(vec3 p, float r) {\n\treturn vec2(length(p) - r, 1.0);\n}\n\nvec2 sdPlane(vec3 p) {\n\treturn vec2(p.y, 3.0);\n}\n\nvec2 sdBox(vec3 p, vec3 d) {\n\t//p = opTwist(p);\n\treturn vec2(length(max(abs(p)-d,0.0)), 2.0);\n}\n\n//-----------------------------------------------------------------\n\nvec2 scene(vec3 p) {\n\tvec3 v = vec3(0.0, -0.4-abs(sin(iTime)), 0.0);\n\tp.x = mod(p.x, 2.0) - 2.0*0.5;\n\tp.z = mod(p.z, 2.0) - 2.0*0.5;\n\t//beat implementation\n\tfloat beat;\n\tfloat ct = iChannelTime[0];\n\tif ((ct > 8.0 && ct < 33.5)\n\t|| (ct > 38.0 && ct < 88.5)\n\t|| (ct > 93.0 && ct < 194.5))\n\t\tbeat = pow(sin(ct*3.1416*3.78+1.9)*0.5+0.5,15.0)*0.1;\n\t//end beat implementation\n\treturn opU(sdSphere(p+v, 0.18+beat*sin(2.0*(0.3*iTime))) ,opU(sdPlane(p), opS(sdBox(p, vec3(0.4, 1.0, 0.4)), sdSphere(opT(p, vec3(0.0, 1.0, 0.0)), 0.3*abs(sin(iTime))))));\n}\n\nvec2 raymarch(vec3 ro, vec3 rd, float maxd) {\n\tfloat t = 0.0;\n\tfloat h = PRECISION * 2.0;\n\tfloat m = 0.0;\n\t\n\tfor(int i = 0; i < 128; i++) {\n\t\tif(abs(h) < PRECISION || t > maxd) {\n\t\t\tbreak;\n\t\t}\n\t\tt += h;\n\t\tvec2 res = scene(ro + rd * t);\n\t\th = res.x;\n\t\tm = res.y;\n\t}\n\t\n\tif(t > maxd) {\n\t\tm = 0.0;\n\t}\n\t\n\treturn vec2(t, m);\n}\n\nvec3 calcNormal(vec3 pos) {\n\tvec3 eps = vec3(0.001, 0.0, 0.0);\n\tvec3 nor = vec3(\n\t\tscene(pos + eps.xyy).x - scene(pos - eps.xyy).x,\n\t\tscene(pos + eps.yxy).x - scene(pos - eps.yxy).x,\n\t\tscene(pos + eps.yyx).x - scene(pos - eps.yyx).x\n\t);\n\treturn normalize(nor);\n}\n\nfloat calcAO(vec3 pos, vec3 nor) {\n\tfloat totao = 0.0;\n\tfloat sca = 1.0;\n\tfor(int i = 0; i < 5; i++) {\n\t\tfloat hr = 0.01 + 0.05 * float(i);\n\t\tvec3 aopos = nor * hr + pos;\n\t\tfloat dd = scene(aopos).x;\n\t\ttotao += -(dd - hr) * sca;\n\t\tsca *= 0.75;\n\t}\n\treturn clamp(1.0 - 4.0 * totao, 0.0, 1.0);\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k) {\n\tfloat res = 1.0;\n    float t = mint;\n    for(int i = 0; i < 30; i++) {\n\t\tif(t < maxt) {\n        \tfloat h = scene( ro + rd*t ).x;\n        \tres = min(res, k*h/t);\n        \tt += 0.02;\n\t\t}\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n\tvec3 col = vec3(0.6, rd.y*(0.5+0.5*abs(sin(iTime))), rd.x*(0.5+0.5*abs(cos(iTime))));\n\t\n\tvec2 res = raymarch(ro, rd, 40.0);\n\tfloat id = res.y;\n\tfloat t = res.x;\n\t\n\tif(id != 0.0) {\n\t\t//point on the shape surface\n\t\tvec3 pos = ro + rd * res.x;\n\t\t//normal vector to the surface\n\t\tvec3 nor = calcNormal(pos);\n\t\t//initial color\n\t\tif(id == 1.0) {\n\t\t\tcol = vec3(1.0, 0.0, 0.3);\n\t\t} else if(id == 2.0) {\n\t\t\tcol = vec3(0.4, 1.0, 0.0);\n\t\t} else if(id == 3.0) {\n\t\t\tcol = vec3(0.0, 0.4, 1.0);\n\t\t}\n\t\tfloat ao = calcAO( pos, nor );\n\n\t\tvec3 lig = normalize(vec3(-0.6, 0.7, -0.5));\n\t\tlig.x *= cos(iTime);\n\t\tlig.y *= sin(iTime);\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n\n\t\tfloat sh = 1.0;\n\t\tif( dif>0.02 ) { sh = softshadow( pos, lig, 0.02, 10.0, 7.0 ); dif *= sh; }\n\n\t\tvec3 brdf = vec3(0.0);\n\t\tbrdf += 0.20*amb*vec3(0.10,0.11,0.13)*ao;\n        brdf += 0.20*bac*vec3(0.15,0.15,0.15)*ao;\n        brdf += 1.20*dif*vec3(1.00,0.90,0.70);\n\n\t\tfloat pp = clamp( dot( reflect(rd,nor), lig ), 0.0, 1.0 );\n\t\tfloat spe = sh*pow(pp,16.0);\n\t\tfloat fre = ao*pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\n\t\tfloat fo = 1.0-exp(-0.0007*t*t);\n\t\tvec3 fco = vec3(0.55,0.65,0.75) + 0.6*vec3(1.0,0.8,0.5);\n\t\t\n\t\tcol = mix(col*brdf + vec3(1.0)*col*spe + 0.2*fre*(0.5+0.5*col), fco, fo);\n\t}\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-1.0 + 2.0 * fragCoord.xy / iResolution.xy) * vec2(iResolution.x/iResolution.y, 1.0);\n\t\t\n\tvec2 mo = iMouse.xy/iResolution.xy; \n\tfloat time = 15.0 + iTime;\n\n\t//camera\n\tvec3 ro = vec3( -0.5+3.2*cos(0.5*time + 6.0*mo.x), 3.0 + 2.0*mo.y, 10.0 + 3.2*sin(0.5*time + 6.0*mo.x) );\n\tvec3 ta = vec3( -0.5, -0.4, 0.5 );\t\n\t\n\t//camera setup\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(0.0, 1.0, 0.0);\n\tvec3 cu = normalize(cross(cw, cp));\n\tvec3 cv = normalize(cross(cu, cw));\n\tvec3 rd = normalize(p.x * cu + p.y * cv + 2.5 * cw);\n\t\n\t//vec3 hp = vec3(0.5/ iResolution.xy, 0.0);\n\tvec3 col = render(ro, rd);\n\t\n\tcol = sqrt(col);\n\t\n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4dXXRH","date":"1396386504","viewed":206,"name":"Getting Serious","username":"Nihilus","description":"shadows, light, raymarching test","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["light","shadows","raymarchingtest"],"hasliked":0,"parentid":"","parentname":""}}