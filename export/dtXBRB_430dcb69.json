{"ver":"0.1","info":{"id":"dtXBRB","date":"1693527454","viewed":220,"name":"Halloween Night","username":"andrew741","description":"A haunted moonlit forest with eerie birds on a dark Halloween night. Watch your step for who knows what's hiding in the trees or behind those dark hills or what may lay hidden beneath the stony graves.\n\nUse the mouse to look around.","likes":22,"published":1,"flags":0,"usePreview":1,"tags":["procedural","terrain","math","perlinnoise","light","forest","moon","night","halloween","trees","spooky","dark","wind","birds","eerie","haunted"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// tree settings\n#define TREE_COLOR vec3(0.6, 0.45, 0.3)\n#define BRANCH_LAYERS 6.\n#define BRANCH_ROT 0.75\n#define BRANCH_DEPTH 6.\n\n// forest settings\n#define FOREST_SPACING 9.\n#define FOREST_LAYERS 13.\n#define WIND_STRENGTH 0.1\n#define TREE_OFFSET 0.8\n#define FOREST_SEED 11.\n\n// ground/terrain settings\n#define GROUND_COLOR vec3(0.3, 0.45, 0.4)\n#define TERRAIN_BRIGHTNESS 4.\n#define TERRAIN_HEIGHT 4.\n#define TERRAIN_SEED 1.\n\n// how common gravestones are (more gravestones means less trees)\n#define ITEM_AMOUNT -0.75\n\n// bird flock (or bats, idk) settings\n#define PERCH_STEEPNESS 3.14159/3.\n#define PERCH_PERCENT 0.75\n#define FLAP_STRENGTH 0.75\n#define FLIGHT_DST 3.\n#define PERCH_DST 0.8\n\n// the matrix for the hash function (weights from the origonal Hash function)\n#define HashMat  mat3( vec3(127.1,311.7, 74.7), vec3(269.5,183.3,246.1),vec3(113.5,271.9,124.6))\n#define HashMat2 mat2( vec2(127.1, 311.7), vec2(269.5, 183.3))\n\n// this hash is from someone elses shader (with some modifactions)\nvec3 Hash(vec3 p) {  return fract(sin(p * HashMat ) * 43758.5453123) * 2. - 1.;  }\nvec2 Hash(vec2 p) {  return fract(sin(p * HashMat2) * 43758.5453123) * 2. - 1.;  }\n\n// from https://www.shadertoy.com/view/Xsl3Dl\nfloat Perlin( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\n    // cubic interpolant\n    vec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( Hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( Hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( Hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( Hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( Hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( Hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( Hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( Hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\n// squares a value (more preformant apprently then using pow(x, 2.))\nfloat Sqr(float v) {  return v*v;  }\n\n// rotates a 2d point based on an angle\nvec2 Rot2D(vec2 v, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return v * mat2(ca, -sa, sa, ca);\n}\n\n// renders a bird\nfloat Bird(vec2 uv, float pixelWidth, float speed)\n{\n    float x = abs(uv.x);\n    if (x>1.) return 1.;  // limiting the width of the bird\n    \n    // rendering the bird\n    float flap = (Sqr(sin(iTime*7.*speed)) * FLAP_STRENGTH + 1.);\n    float dst = abs(uv.y*flap - sqrt(x));\n    return smoothstep(-pixelWidth, pixelWidth, dst - 0.1);\n}\n\n// renders a tree limb\nfloat Limb(vec2 uv, vec2 pos, float rot, float thickness, float len)\n{\n    vec2 np = Rot2D(uv - pos, rot);       // getting the rotated position\n    if (np.y<0.) return 999.;             // limiting the height of the triangle\n    return abs(thickness*np.x)+np.y*len;  // getting the distance to the trangle\n}\n\n// renders grave stones\nfloat GraveStone(vec2 np)\n{\n    // getting the relative position\n    float bright = 1.;\n    \n    // drawing the grave stone\n    if (abs(np.x-0.03) < 0.1 && abs(np.y-max(np.x - 0.1, 0.)) < 0.15 || length(np-vec2(0.031, 0.16)) < 0.1) bright = 0.5;\n    if (abs(np.x) < 0.1 && abs(np.y) < 0.15 || length(np-vec2(0., 0.15)) < 0.1) bright = 0.05;\n    \n    // drawing the letters\n    if (abs(np.x+0.06) < 0.004 && abs(np.y-0.1  )<0.03 ) bright = 0.99;\n    if (abs(np.x+0.03) < 0.004 && abs(np.y-0.116)<0.015) bright = 0.99;\n    if (abs(np.x + 0.045) < 0.015 && abs(np.y - 0.1) < 0.004) bright = 0.99;\n    if (abs(np.x + 0.045) < 0.015 && abs(np.y - 0.129) < 0.004) bright = 0.99;\n    if (abs(-np.x-(np.y-0.045)) < 0.006 && abs(np.x+0.045) < 0.0155) bright = 0.99;\n\n    if (abs(np.x-0.007) < 0.004 && abs(np.y - 0.1  )< 0.03  ) bright = 0.99;\n    if (abs(np.x-0.007) < 0.015 && abs(np.y - 0.07 ) < 0.004) bright = 0.99;\n    if (abs(np.x-0.007) < 0.015 && abs(np.y - 0.129) < 0.004) bright = 0.99;\n\n    if (abs(np.x-0.05) < 0.004 && abs(np.y-0.1  )<0.03 ) bright = 0.99;\n    if (abs(np.x-0.08) < 0.004 && abs(np.y-0.116)<0.015) bright = 0.99;\n    if (abs(np.x - 0.065) < 0.015 && abs(np.y - 0.1) < 0.004) bright = 0.99;\n    if (abs(np.x - 0.065) < 0.015 && abs(np.y - 0.129) < 0.004) bright = 0.99;\n    \n    // returning the final brightness\n    return bright;\n}\n\n// renders a random tree\nvec2 Tree(vec2 uv, float rot, float seed, float pixelWidth, float midOffset, float offStrength)\n{\n    // rendering the base trunk\n    float dst=Limb(uv, vec2(0.), rot, 10., 0.5);\n    float r = rot;\n    vec2 pos = vec2(0.);\n    \n    // the distance to birds in the tree\n    float birdDst = 1.;\n    \n    // rendering multiple layers of multi segment branches\n    for (float layer = 0.; layer < BRANCH_LAYERS; layer++)\n    {\n        // rendering a the segments of the branch\n        r = rot;\n        pos = vec2(0.);\n        for (float i = 1.; i < BRANCH_DEPTH; i++)\n        {\n            // getting the new position\n            vec2 hash = Hash(vec2(seed, i + BRANCH_DEPTH*layer));\n            vec2 dir = vec2(sin(r), cos(r));\n            pos += dir * (hash.x*0.1+0.5);\n            r += hash.y*BRANCH_ROT;\n            \n            // rendering the branch segment\n            float limbDst = Limb(uv, pos, r, 10.+i*9., 0.6+i*0.1);\n            dst = min(dst, limbDst);\n            \n            // rendering possible birds in the tree\n            if (hash.x < PERCH_PERCENT && (pos.x < PERCH_DST && pos.x > -PERCH_DST) && (r-rot < -PERCH_STEEPNESS || r-rot > PERCH_STEEPNESS))\n            {\n                float flightOff = max(midOffset-hash.y*offStrength, 0.);\n                birdDst = min(birdDst, Bird((uv - (pos+dir*0.25))*8. - flightOff*vec2(-1., 1.), pixelWidth, 0.2 + smoothstep(0., 1., flightOff)));\n            }\n        }\n    }\n    \n    // returning the distance to the tree\n    return vec2(dst, birdDst);\n}\n\n// renders a bunch of layers of trees\nvoid RenderForest(inout vec3 col, vec2 uv, float pixelWidth, vec2 offset, float scrollX)\n{\n    // the depth (use for ground fog)\n    float depth = FOREST_LAYERS;\n\n    // looping through the layers of the forest\n    for (float layer = FOREST_LAYERS; layer > 0.; layer--)\n    {\n        // getting the position\n        float spacing = FOREST_SPACING / (layer * 0.5);\n        vec2 nuv = uv + offset/layer + vec2(scrollX/layer, 0.);\n        float xOffset = layer*spacing*0.25;\n        float x = nuv.x + xOffset;\n        float cell = floor(x / spacing);\n        vec3 hash = Hash(vec3(layer, cell+3., FOREST_SEED));\n        \n        // getting the wind amount\n        float wind = Perlin(vec3(nuv.x*0.25, nuv.y*0.1, iTime*0.75));\n        \n        // getting the height of the terrain and more position information\n        float l = max((FOREST_LAYERS - layer + 1.) * 0.75, 1.85);\n        float terrainOffset = layer*0.195-1.;\n        float height = terrainOffset + Perlin(vec3(nuv.x*0.1, TERRAIN_SEED, layer)) * min(TERRAIN_HEIGHT / ((l+3.25)*0.15), TERRAIN_HEIGHT * 0.6);\n        float y = nuv.y - height;\n        \n        // the final position of the tree\n        float treeOff = TREE_OFFSET*hash.x/(layer*0.1+0.2) - spacing*0.5;\n        vec2 pos = vec2(mod(x, spacing) + treeOff, y);\n        //pos.x += sin(wind) * smoothstep(0., 19., nuv.y-height) * WIND_STRENGTH;\n        \n        // rendering the ground\n        float terrainDst = smoothstep(-pixelWidth, pixelWidth, height-nuv.y);\n        col = mix(col, GROUND_COLOR / l, terrainDst);\n        \n        // checking if a secondary item should be rendered\n        if (hash.z < ITEM_AMOUNT && layer > 1.)\n        {\n            // rendering a gravestone\n            float grave = GraveStone(pos*(layer*0.2)*0.75);\n            if (grave < 1.)\n            {\n                col = vec3(grave);\n                depth = layer;\n            }\n        }\n        else\n        {\n            // rendering the tree\n            float blur = 1./layer * 0.25;\n            float midPoint = (scrollX/layer-6.-treeOff+xOffset) - cell * spacing;\n            vec2 tree = Tree(pos*(layer*0.2), wind * WIND_STRENGTH, cell+FOREST_SEED, pixelWidth, midPoint, layer * FLIGHT_DST);\n            float treeDst = smoothstep(-pixelWidth-blur, pixelWidth+blur, tree.x-0.75);\n            depth = mix(layer, depth, treeDst);\n\n            // rendering the terrain and trees\n            col = mix(TREE_COLOR / (l+1.5), col, treeDst);\n            \n            // rendering bird\n            col = mix(vec3(0.), col, tree.y);\n        }\n        \n        // finding the depth\n        depth = mix(depth, layer, terrainDst);\n    }\n    \n    // rendering ground fog\n    float fog = exp((depth-FOREST_LAYERS) * 0.15) * smoothstep(3., -4., uv.y);\n    col += fog;\n}\n\n// the main shader\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // getting the uv\n    float zoom = 6.;\n    vec2 cameraOffset = vec2(0., 1.);\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y * zoom + cameraOffset;\n    vec2 mouseOffset = smoothstep(0., 1., iMouse.xy/iResolution.xy) * vec2(10., 5.);\n    float pixelWidth = zoom / iResolution.y * 1.5;\n    \n    // rendering the sky\n    float moonLight = smoothstep(0.75, 0.7, length(uv-vec2(4., 3.))) * 0.45;\n    float edgeMask = smoothstep(1.3, 0.4, length(uv - vec2(3.65, 3.25)));\n    moonLight *= 1. - texture(iChannel0, uv*0.25).r * 0.75;  // craters in the moon\n    float skyLight = smoothstep(15., 0.9, length(uv-vec2(4., 3.))) * 0.25;\n    vec3 col = vec3(moonLight*(edgeMask) + skyLight);\n    \n    // rendering the ground and forest\n    RenderForest(col, uv, pixelWidth, mouseOffset, iTime*2.);\n    col *= skyLight * TERRAIN_BRIGHTNESS;  // darkens the left edge and corners\n    \n    // the final color\n    fragColor = vec4(pow(col, vec3(0.7))*1.4,1.0);\n}","name":"Image","description":"","type":"image"}]}