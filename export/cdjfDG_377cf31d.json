{"ver":"0.1","info":{"id":"cdjfDG","date":"1690087335","viewed":58,"name":"Physics World","username":"GENG_ZIXUAN","description":"NUS Summer Workshop 2023\nReal-time graphics rendering","likes":0,"published":1,"flags":0,"usePreview":1,"tags":["raytracing","phonglighting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Constants.\nconst float PI = 3.1415926536;\nconst vec3 BACKGROUND_COLOR = vec3( 0.1, 0.2, 0.6 );\nconst float FOVY = 50.0 * PI / 180.0;// Vertical field-of-view angle of camera. In radians.\nconst float DEFAULT_TMIN = 10.0e-4;  // Use this for avoiding the \"epsilon problem\" or the shadow acne problem.\nconst float DEFAULT_TMAX = 10.0e6;   // Use this for tmax for non-shadow ray intersection test.\nconst int NUM_ITERATIONS = 2;        // use iterations to replace recursions.\n\n// Constants for the scene objects.\nconst int NUM_LIGHTS = 3;\nconst int NUM_MATERIALS = 9;\nconst int NUM_PLANES = 20;\nconst int NUM_SPHERES = 52;\nconst int NUM_CUBES = 60;\nconst int NUM_BARS = 100;\n\n// Define new struct types.\nstruct Ray_t {\n    vec3 o;  // Ray Origin.\n    vec3 d;  // Ray Direction. A unit vector.\n};\n\nstruct Material_t {\n    vec3 k_a;   // Ambient coefficient.\n    vec3 k_d;   // Diffuse coefficient.\n    vec3 k_r;   // Reflected specular coefficient.\n    vec3 k_rg;  // Global reflection coefficient.\n    float n;    // The specular reflection exponent. Ranges from 0.0 to 128.0.\n};\n\nstruct Plane_t {\n    // The plane equation is Ax + By + Cz + D = 0.\n    float A, B, C, D;\n    int materialID;\n};\n\nstruct Sphere_t {\n    vec3 center;\n    float radius;\n    int materialID;\n};\n\nstruct Light_t {\n    vec3 position;  // Point light 3D position.\n    vec3 I_a;       // For Ambient.\n    vec3 I_source;  // For Diffuse and Specular.\n};\n\nstruct Cube_t {\n    vec3 center;\n    vec3 size;\n    int materialID;\n};\n\nstruct Bar_t {\n    vec3 v1;\n    vec3 v2;\n    float radius;\n    int materialID;\n};\n\n// Global scene data.\nPlane_t Plane[NUM_PLANES];\nSphere_t Sphere[NUM_SPHERES];\nLight_t Light[NUM_LIGHTS];\nMaterial_t Material[NUM_MATERIALS];\nCube_t Cube[NUM_CUBES];\nBar_t Bar[NUM_BARS];\n\n// Factory functions\nint n_planes = 0;\nint n_spheres = 0;\nint n_cubes = 0;\nint n_bars = 0;\n\nvoid makePlane(in float A, in float B, in float C, in float D, in int matID)\n{\n    Plane[n_planes].A = A;\n    Plane[n_planes].B = B;\n    Plane[n_planes].C = C;\n    Plane[n_planes].D = D;\n    Plane[n_planes].materialID = matID;\n    n_planes ++;\n}\n\nint makeSphere(in vec3 center, in float radius, in int matID)\n{\n    Sphere[n_spheres].center = center;\n    Sphere[n_spheres].radius = radius;\n    Sphere[n_spheres].materialID = matID;\n    return n_spheres ++;\n}\n\nint makeCube(vec3 bottom_center, vec3 size, int matID)\n{\n    vec3 center = bottom_center + vec3(0.0, size.y / 2.0, 0.0);\n    Cube[n_cubes].center = center;\n    Cube[n_cubes].size = size;\n    Cube[n_cubes].materialID = matID;\n    return n_cubes ++;\n}\n\nint makeBar(in vec3 v1, in vec3 v2, in float radius, in int matID)\n{\n    Bar[n_bars].v1 = v1;\n    Bar[n_bars].v2 = v2;\n    Bar[n_bars].radius = radius;\n    Bar[n_bars].materialID = matID;\n    return n_bars ++;\n}\n\nfloat waveFuncValue;\nfloat waveFunc(float time)\n{\n    float f = 0.3 * sin(0.7 * time);\n    float g = 0.2 * cos(8.0 * time + 0.25 * PI);\n    float h = 0.5 * sin(0.9 * time + 0.1 * PI);\n    return (1.0 + f + g + h) / 2.0;\n}\n\nvoid createWave()\n{\n    float side = 0.03;\n    float curx = -1.5;\n    float n = 12.0;\n\n    // left ear\n    for (float i = 0.0; i < n; i += 1.0)\n    {\n        float h = waveFunc(iTime + 2.0 * PI * (n - i - 1.0) / n);\n        int id = makeCube(vec3(curx, 0.0, 0.0), vec3(side, h, side), 1);\n        curx += side + 0.05;\n    }\n    // right ear\n    curx += 1.2;\n    for (float i = 0.0; i < n; i += 1.0)\n    {\n        float h = waveFunc(iTime + 1.9 * PI * i / n);\n        int id = makeCube(vec3(curx, 0.0, 0.0), vec3(side, h, side), 1);\n        curx += side + 0.05;\n    }\n}\n\nvoid create20SidesBalls()\n{\n    float fan = 0.6180339887498948;\n    float radius = 0.05;\n    float r = 0.01;\n\n    vec3 V[12];\n    V[0] = vec3(0.0, 1.0, fan);\n    V[1] = vec3(0.0, 1.0, -fan);\n    V[2] = vec3(0.0, -1.0, fan);\n    V[3] = vec3(0.0, -1.0, -fan);\n    V[4] = vec3(1.0, fan, 0.0);\n    V[5] = vec3(1.0, -fan, 0.0);\n    V[6] = vec3(-1.0, fan, 0.0);\n    V[7] = vec3(-1.0, -fan, 0.0);\n    V[8] = vec3(fan, 0.0, 1.0);\n    V[9] = vec3(fan, 0.0, -1.0);\n    V[10] = vec3(-fan, 0.0, 1.0);\n    V[11] = vec3(-fan, 0.0, -1.0);\n\n    // Create balls\n    for (int i = 0; i < 12; i ++)\n    {\n        V[i] *= vec3(0.2, 0.2, 0.2);\n        V[i] *= 2.0 * waveFuncValue;\n        V[i] += vec3(0.0, 1.2, 0.0);\n        makeSphere(V[i], radius, 0);\n    } \n    int Mat = 8;\n    // Connect balls\n    if (distance(V[0],V[1]) >= 2.3 * radius)\n    {\n      makeBar(V[0], V[1], r, Mat);\n      makeBar(V[0], V[6], r, Mat);\n      makeBar(V[0], V[10], r, Mat);\n      makeBar(V[0], V[8], r, Mat);\n      makeBar(V[0], V[4], r, Mat);\n      makeBar(V[1], V[6], r, Mat);\n      makeBar(V[1], V[10], r, Mat);\n      makeBar(V[10], V[8], r, Mat);\n      makeBar(V[8], V[4], r, Mat);\n      makeBar(V[4], V[1], r, Mat);\n      makeBar(V[3], V[2], r, Mat);\n      makeBar(V[3], V[5], r, Mat);\n      makeBar(V[3], V[9], r, Mat);\n      makeBar(V[3], V[11], r,Mat);\n      makeBar(V[3], V[7], r, Mat);\n      makeBar(V[2], V[5], r, Mat);\n      makeBar(V[5], V[9], r, Mat);\n      makeBar(V[9], V[11], r, Mat);\n      makeBar(V[11], V[7], r, Mat);\n      makeBar(V[7], V[2], r, Mat);\n      makeBar(V[2], V[8], r, Mat);\n      makeBar(V[8], V[5], r, Mat);\n      makeBar(V[5], V[4], r, Mat);\n      makeBar(V[4], V[9], r, Mat);\n      makeBar(V[9], V[1], r, Mat);\n      makeBar(V[1], V[11], r,Mat);\n      makeBar(V[11], V[6], r,Mat);\n      makeBar(V[6], V[7], r, Mat);\n      makeBar(V[7], V[10], r, Mat);\n      makeBar(V[10], V[2], r, Mat);\n    }\n}\n\nvoid createEight(float scalor, vec3 position){\n    float len = scalor * waveFuncValue;\n    float sphere_r = scalor * 0.1;\n    vec3 transDirec = position;\n    vec3 bottom_point = vec3(0, 0, 0) + transDirec;\n    makeSphere(vec3(0, 0, 0) + transDirec, sphere_r, 0);\n    \n    vec3 xpzp = vec3(0.707*len*cos(iTime+PI*0.25), 0.707 * len, 0.707*len*sin(iTime+PI*0.25)) + transDirec;\n    vec3 xnzp = vec3(0.707*len*cos(iTime+PI*0.75), 0.707 * len, 0.707*len*sin(iTime+PI*0.75)) + transDirec;\n    vec3 xnzn = vec3(0.707*len*cos(iTime+PI*1.25), 0.707 * len, 0.707*len*sin(iTime+PI*1.25)) + transDirec;\n    vec3 xpzn = vec3(0.707*len*cos(iTime+PI*1.75), 0.707 * len, 0.707*len*sin(iTime+PI*1.75)) + transDirec;\n    \n    int SMat = 0;\n    makeSphere(xpzp, sphere_r, SMat);\n    makeSphere(xnzp, sphere_r, SMat);\n    makeSphere(xnzn, sphere_r, SMat);\n    makeSphere(xpzn, sphere_r, SMat);\n\n    vec3 top_point = vec3(0, 1.414 * len, 0) + transDirec;\n    makeSphere(xpzp, sphere_r, SMat);\n    makeSphere(vec3(0,  1.414 * len, 0) + transDirec, sphere_r, SMat);\n\n    float bar_r = sphere_r / 3.0;\n    int BMat = 1;\n    makeBar(bottom_point, xpzp, bar_r, BMat);\n    makeBar(bottom_point, xnzp, bar_r, BMat);\n    makeBar(bottom_point, xnzn, bar_r, BMat);\n    makeBar(bottom_point, xpzn, bar_r, BMat);\n\n    makeBar(top_point, xpzp, bar_r, BMat);\n    makeBar(top_point, xnzp, bar_r, BMat);\n    makeBar(top_point, xnzn, bar_r, BMat);\n    makeBar(top_point, xpzn, bar_r, BMat);\n    \n    makeBar(xpzp, xnzp, bar_r, BMat);\n    makeBar(xnzp, xnzn, bar_r, BMat);\n    makeBar(xnzn, xpzn, bar_r, BMat);\n    makeBar(xpzn, xpzp, bar_r, BMat);\n}\n\nvoid createFerris(){\n    int s_num = 10;\n    vec3 V[20];\n    float bar_r = 0.06;\n    float x = 0.8; float z = 0.2; float h = 2.0;\n    vec3 xpzp = vec3(x, 0.0, z); vec3 xpzn = vec3(x, 0.0, -z);\n    vec3 xnzp = vec3(-x, 0.0, z); vec3 xnzn = vec3(-x, 0.0, -z);\n    vec3 zp_top = vec3(0.0, h, z); vec3 zn_top = vec3(0.0, h, -z);\n    \n    V[0] = vec3(x, 0.0, z); // xpzp\n    V[1] = vec3(x, 0.0, -z); // xpzn\n    V[2] = vec3(-x, 0.0, z); // xnzp\n    V[3] = vec3(-x, 0.0, -z); // xnzn\n    V[4] = vec3(0.0, h, z);\n    V[5] = vec3(0.0, h, -z); \n    \n    float xt = x*0.66; float ht = h/3.0;\n    V[6] = vec3(xt, ht, z);\n    V[7] = vec3(-xt, ht, z);\n    V[8] = vec3(xt, ht, -z);\n    V[9] = vec3(-xt, ht, -z);\n\n    float len = 1.2;\n    float rad_inter = PI * 2.0 / 10.0;\n    vec3 transDir = vec3(0.0, h, 0.0);\n    float sphere_r = 0.1;\n    float rad = 0.0;\n    for(int i = 0; i < s_num; i++){\n        rad = iTime+float(i)*rad_inter;\n        V[10+i] = vec3(len*cos(iTime+float(i)*rad_inter), len*sin(iTime+float(i)*rad_inter), 0.0) + transDir;\n    }\n\n    transDir += vec3(0.0, 0.0, -2.0);\n    for (int i = 0; i < 20; i ++)\n        V[i] += vec3(0.0, 0.0, -2.0);\n    int BMat = 7;\n    makeBar(V[0], V[2], bar_r, BMat);\n    makeBar(V[0], V[4], bar_r, BMat);\n    makeBar(V[2], V[4], bar_r, BMat);\n                               \n    makeBar(V[1], V[3], bar_r, BMat);\n    makeBar(V[1], V[5], bar_r, BMat);\n    makeBar(V[3], V[5], bar_r, BMat);\n                              \n    makeBar(V[4], V[5], bar_r, BMat);\n    makeBar(V[6], V[7], bar_r, BMat);\n    makeBar(V[8], V[9], bar_r, BMat);\n\n    int SMat = 0;\n    for(int i = 0; i < s_num; i++){\n        makeSphere(V[10+i], sphere_r, SMat);\n        makeBar(transDir, V[10+i], 0.02, BMat);\n    }\n}\n\nvoid makeSolar(float scalor, vec3 position) {\n    vec3 transDirec = position;\n    vec3 V[5];\n    V[0] = scalor * vec3( 0.0, 0.2, 0.0 ) + transDirec;\n    V[1] = scalor * vec3( 0.9 * cos(1.4 * iTime), 0.1 + 0.2, 0.3 * sin(1.4 * iTime) ) + transDirec;\n    V[2] = scalor * vec3( 1.2 * cos(iTime), 0.1 + 0.2, 0.9 * sin(iTime) ) + transDirec;\n    V[3] = scalor * vec3( 1.5 * cos(0.4 * iTime), 0.1 + 0.2, 1.9 * sin(0.4 * iTime) ) + transDirec;\n    V[4] = scalor * (vec3 (0.1* cos(4.0 * iTime), 0.0 , 0.3* sin(4.0 * iTime)) + vec3( 1.5 * cos(0.4 * iTime), 0.1 + 0.2, 1.9 * sin(0.4 * iTime) ) )+ transDirec;\n\n    float R[5];\n    R[0] = 0.2 * scalor;\n    R[1] = 0.1 * scalor;\n    R[2] = 0.1 * scalor;\n    R[3] = 0.1 * scalor;\n    R[4] = 0.04 * scalor;\n    // Sun\n    makeSphere(V[0], R[0], 2);\n    // Circling sphere.\n    makeSphere(V[1], R[1], 5); // first planet\n    makeSphere(V[2], R[2], 6); // second planet\n    makeSphere(V[3],R[3], 3); // earth\n    makeSphere(V[4], R[4], 4); // moon\n}\n\nvoid createNewton()\n{\n    vec3 V[24];\n    // Base of the cradle\n    // Bottom points\n    float xl = 1.0; float zl = 0.8;\n    V[0] = vec3(xl, 0, zl); // point_pxpz_l\n    V[1] = vec3(xl, 0, -zl); // point_pxnz_l\n    V[2] = vec3(-xl, 0, zl); // point_nxpz_l\n    V[3] = vec3(-xl, 0, -zl); // point_nxnz_l\n\n    // Top points\n    float h = 0.4;\n    float xh = 0.8; float zh = 0.2;\n    V[4] = vec3(xh, h, zl); // point_pxpz_h\n    V[5] = vec3(xh, h, -zl); // point_pxnz_h\n    V[6] = vec3(-xh, h, zl); // point_nxpz_h\n    V[7] = vec3(-xh, h, -zl); // point_nxnz_h\n  \n    // Frame\n    float stand_x = xh - 0.08; float stand_z = zh + 0.4;\n    float r = 0.06;\n   \n    V[8] = vec3( stand_x, h, stand_z); // stand_pxpz\n    V[9] = vec3( stand_x, h, -stand_z); // stand_pxnz\n    V[10] = vec3( -stand_x, h, stand_z); // stand_nxpz\n    V[11] = vec3( -stand_x, h, -stand_z); // stand_nxnz\n    \n    float h1 = 1.8; float stand_px_top = stand_x-0.03; float stand_nx_top = -(stand_x-0.03);\n    V[12] = vec3( stand_px_top, h+h1, 0.0); // top_pxz0\n    V[13] = vec3( stand_nx_top, h+h1, 0.0); // top_nxz0\n    \n    float line_r = 0.01;\n    float total_len = 2.0 * stand_px_top;\n    float interval = total_len / 6.0;\n    float sphere_r = interval / 2.0;\n    float h_l = h + sphere_r + 0.08;\n    float line_len = h + h1 - h_l;\n    float sec = mod(iTime * 0.38, 1.0);\n    float interp = 4.0 * mod(sec, 0.25);\n    float angle = 0.0;\n    \n    if(sec < 0.25)\n        angle = mix(0.0, -PI*0.14, interp );\n    else if(sec < 0.5)\n        angle = mix(-PI*0.14, 0.0, interp);\n    else if(sec < 0.75)\n        angle = mix(0.0, PI*0.14, interp);\n    else\n        angle = mix(PI*0.14, 0.0, interp);\n    \n    float left_x = stand_nx_top + interval;\n    vec3 center_left = vec3(left_x, h+h1, 0);\n   \n    float right_x = stand_px_top - interval;\n    vec3 center_right = vec3(right_x, h+h1, 0);\n    vec3 left_1 = angle > 0.0? vec3(0.0, -line_len, 0.0)+center_left:vec3(line_len*sin(angle), -line_len*cos(angle), 0)+center_left;\n    vec3 left_2 = angle > 0.0? vec3(interval, -line_len, 0.0)+center_left:vec3(line_len*sin(0.4*angle)+interval, -line_len*cos(0.4*angle), 0)+center_left;\n    vec3 right_1 = angle < 0.0? vec3(0.0, -line_len, 0.0)+center_right:vec3(line_len*sin(angle), -line_len*cos(angle), 0)+center_right;\n    vec3 right_2 = angle < 0.0? vec3(-interval, -line_len, 0.0)+center_right:vec3(line_len*sin(0.4*angle) - interval, -line_len*cos(0.4*angle), 0)+center_right;\n    vec3 middle = vec3(stand_nx_top + 3.0*interval, h_l, 0);\n    \n    V[14] = left_1;\n    V[15] = left_2;\n    V[16] = middle;\n    V[17] = right_2;\n    V[18] = right_1;\n    V[19] = vec3(stand_nx_top+interval, h+h1, 0);\n    V[20] = vec3(stand_nx_top+2.0*interval, h+h1, 0);\n    V[21] = vec3(stand_nx_top+3.0*interval, h+h1, 0);\n    V[22] = vec3(stand_nx_top+4.0*interval, h+h1, 0);\n    V[23] = vec3(stand_nx_top+5.0*interval, h+h1, 0);\n   \n    for (int i = 0; i < 24; i ++)\n        V[i] += vec3(0.0, -0.4, 2.0);\n    int BMat = 3;\n    int SMat = 0;\n    makeBar(V[12], V[13], r, BMat);\n    makeBar(V[8], V[12], r, BMat);\n    makeBar(V[9], V[12], r, BMat);\n    makeBar(V[10], V[13], r, BMat);\n    makeBar(V[11], V[13], r, BMat);\n    makeSphere(V[14], sphere_r, SMat);\n    makeSphere(V[15], sphere_r, SMat);\n    makeSphere(V[16], sphere_r, SMat);\n    makeSphere(V[17], sphere_r, SMat);\n    makeSphere(V[18], sphere_r, SMat);\n    makeBar(V[19], V[14], line_r, BMat);\n    makeBar(V[20], V[15], line_r, BMat);\n    makeBar(V[21], V[16], line_r, BMat);\n    makeBar(V[22], V[17], line_r, BMat);\n    makeBar(V[23], V[18], line_r, BMat); \n}\n\n// Initializes the scene.\nvoid InitScene()\n{\n    // Silver\n    Material[0].k_d = vec3( 0.5, 0.5, 0.5 );\n    Material[0].k_a = 0.2 * Material[0].k_d;\n    Material[0].k_r = 2.0 * Material[0].k_d;\n    Material[0].k_rg = 0.5 * Material[0].k_r;\n    Material[0].n = 64.0;\n    // Gold\n    Material[1].k_d = vec3( 0.8, 0.7, 0.1 );\n    Material[1].k_a = 0.2 * Material[1].k_d;\n    Material[1].k_r = 2.0 * Material[1].k_d;\n    Material[1].k_rg = 0.5 * Material[1].k_r;\n    Material[1].n = 64.0;\n    // Sun\n    Material[2].k_d = vec3( 1.0, 0.384, 0.263);\n    Material[2].k_a = 0.5 * Material[1].k_d;\n    Material[2].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[2].k_rg = 0.1 * Material[1].k_r;\n    Material[2].n = 128.0;\n    // Earth\n    Material[3].k_d = vec3( 0.474, 0.607, 0.894 );\n    Material[3].k_a = 0.2 * Material[2].k_d;\n    Material[3].k_r = vec3( 0.1, 0.1, 1.0 );\n    Material[3].k_rg = 0.5 * Material[2].k_r;\n    Material[3].n = 128.0;\n    // Moon\n    Material[4].k_d = vec3( 0.5, 0.5, 0.5 );\n    Material[4].k_a = 0.2 * Material[0].k_d;\n    Material[4].k_r = 2.0 * Material[0].k_d;\n    Material[4].k_rg = 0.5 * Material[0].k_r;\n    Material[4].n = 64.0;\n    // first planet material\n    Material[5].k_d = vec3( 0.925, 0.784, 0.49 );\n    Material[5].k_a = 0.2 * Material[0].k_d;\n    Material[5].k_r = 2.0 * Material[0].k_d;\n    Material[5].k_rg = 0.05 * Material[0].k_r;\n    Material[5].n = 64.0;\n    // second planet material\n    Material[6].k_d = vec3( 0, 0.874, 0.423 );\n    Material[6].k_a = 0.2 * Material[0].k_d;\n    Material[6].k_r = 2.0 * Material[0].k_d;\n    Material[6].k_rg = 0.5 * Material[0].k_r;\n    Material[6].n = 64.0;\n    \n    Material[7].k_d = vec3( 1.0, 0.66, 0.54 );\n    Material[7].k_a = 0.2 * Material[0].k_d;\n    Material[7].k_r = 2.0 * Material[0].k_d;\n    Material[7].k_rg = 0.5 * Material[0].k_r;\n    Material[7].n = 64.0;\n    \n    Material[8].k_d = vec3( 0.404, 0.765, 0.517 );\n    Material[8].k_a = 0.2 * Material[1].k_d;\n    Material[8].k_r = 2.0 * Material[1].k_d;\n    Material[8].k_rg = 0.5 * Material[1].k_r;\n    Material[8].n = 64.0;\n\n    // Light 0.\n    Light[0].position = vec3( 0.0, 2.5, 0.0 );\n    Light[0].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[0].I_source = vec3( 1.0, 1.0, 1.0 );\n    // Light 1.\n    Light[1].position = vec3(0.0, 1.2, 0.0);\n    Light[1].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[1].I_source = 0.3 * vec3( 0.5, 0.5, 1.0 );\n\n    // Horizontal plane.\n    makePlane(0.0, 1.0, 0.0, 0.0, 0);\n    // Vertical plane.\n    makePlane(0.0, 0.0, 1.0, 7.5, 8);\n    makePlane(0.0, 0.0, 1.0, -20.5, 0);\n\n    createWave();\n    create20SidesBalls();\n    createEight(0.5, vec3(-2.5, 1.4, 0.0));\n    createEight(0.5, vec3(2.5, 1.2, 0.0));\n    createFerris();\n    makeSolar(3.0, vec3(5.0, 4.5, 1.0));\n    makeSolar(3.0, vec3(-5.0, 5.0, 2.0));\n    createNewton();\n}\n\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec3 hitnormal )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n    // We have a hit -- output results.\n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitnormal = normalize( N );\n    return true;\n}\n\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n    return true;\n}\n\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitnormal )\n{\n    // Change coordinate\n    vec3 rd = ray.d;\n    vec3 ro = ray.o - sph.center;\n    // Build quadratic equation\n    float a = 1.0;\n    float b = 2.0 * dot(rd, ro);\n    float c = dot(ro, ro) - sph.radius * sph.radius;\n    // Determine intersected\n    float d = b * b - 4.0 * a * c;\n    float t1 = (-b + sqrt(d)) / (2.0 * a);\n    float t2 = (-b - sqrt(d)) / (2.0 * a);\n\n    if ((t1 >= tmin && t1 <= tmax) || (t2 >= tmin && t2 <= tmax))\n    {\n        // Determine t\n        if (t2 > 0.0 && t2 >= tmin && t2 <= tmax) t = t2;\n        else t = t1;\n\n        // Resolve hit point and norm\n        hitPos = ray.o + t * ray.d;\n        hitnormal = normalize(hitPos - sph.center);\n        return true;\n    }\n    return false;\n}\n\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax )\n{\n    // Transform coordinate\n    vec3 rd = ray.d;\n    vec3 ro = ray.o - sph.center;\n    // Build quadratic equation\n    float a = 1.0;\n    float b = 2.0 * dot(rd, ro);\n    float c = dot(ro, ro) - sph.radius * sph.radius;\n    // Determine intersected\n    float d = b * b - 4.0 * a * c;\n    float t1 = (-b + sqrt(d)) / (2.0 * a);\n    float t2 = (-b - sqrt(d)) / (2.0 * a);\n    return (t1 >= tmin && t1 <= tmax) || (t2 >= tmin && t2 <= tmax);\n}\n\nbool IntersectCube( in Cube_t cube, in Ray_t ray, in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec3 hitnormal)\n{\n    vec3 ro = ray.o;\n    ray.o -= cube.center;\n    vec3 m = sign(ray.d) / max(abs(ray.d), 1e-7);\n    vec3 n = m * ray.o;\n    vec3 k = abs(m) * cube.size;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tn = max(max(t1.x, t1.y), t1.z);\n    float tf = min(min(t2.x, t2.y), t2.z);\n    \n    if( tn > tf || tf <= 0.0) \n        return false;\n    \n    if(tn >= tmin && tf<=tmax){\n        t = tn;\n        hitPos = ro + t*ray.d;\n        hitnormal = -sign(ray.d) * step(t1.yzx, t1.xyz) * step(t1.zxy, t1.xyz);\n        return true;\n    }\n\n    if(tf >= tmin && tf <= tmax){\n        t = tf;\n        hitPos = ro + t*ray.d;\n        hitnormal = -sign(ray.d) * step(t1.yzx, t1.xyz) * step(t1.zxy, t1.xyz);\n        return true;\n    }\n    return false;\n}\n\nbool IntersectCube( in Cube_t cube, in Ray_t ray, in float tmin, in float tmax )\n{\n    ray.o -= cube.center;\n    vec3 m = sign(ray.d) / max(abs(ray.d), 1e-7);\n    vec3 n = m * ray.o;\n    vec3 k = abs(m) * cube.size;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tn = max(max(t1.x, t1.y), t1.z);\n    float tf = min(min(t2.x, t2.y), t2.z);\n    \n    if( tn > tf || tf <= 0.0) return false;\n    \n    return (tn >= tmin && tf <= tmax) || (tf >= tmin && tf <= tmax);\n}\n\nfloat IntersectE( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float r )\n{\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float oaoa = dot(oa,oa);\n    float a = dot(ba,ba) - dot(ba,rd)*dot(ba,rd);\n    float b = dot(ba,ba)*rdoa - baoa*dot(ba,rd);\n    float c = dot(ba,ba)*oaoa - baoa*baoa - r*r*dot(ba,ba);\n    float h = b*b - a*c;\n    if( h>=0.0 )\n    {\n        float t = (-b-sqrt(h))/a;\n        float y = baoa + t*dot(ba,rd);\n        if( y>0.0 && y<dot(ba,ba) ) return t;\n        vec3 oc = (y<=0.0) ? oa : ro - pb;\n        b = dot(rd,oc);\n        c = dot(oc,oc) - r*r;\n        h = b*b - c;\n        if( h>0.0 ) return -b - sqrt(h);\n    }\n    return -1.0;\n}\n\nvec3 NE( in vec3 pos, in vec3 a, in vec3 b, in float r )\n{\n    vec3  ba = b - a;\n    vec3  pa = pos - a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);\n    return (pa - h*ba)/r;\n}\n\nbool IntersectBar( in Bar_t br, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    t = IntersectE( ray.o, ray.d, br.v1, br.v2, br.radius );\n\n    if (t >= 0.0 && t <= tmax){\n        hitPos = ray.o + t * ray.d;\n        hitNormal = NE(hitPos, br.v1, br.v2, br.radius);\n        return true;\n    } else\n        return false;\n}\n\nbool IntersectBar( in Bar_t br, in Ray_t ray, in float tmin, in float tmax)\n{\n    float t = IntersectE( ray.o, ray.d, br.v1, br.v2, br.radius );\n    if (t >= 0.0 && t >= tmin && t <= tmax)\n        return true;\n    else\n        return false;\n}\n\nvec3 PhongLighting( in vec3 L, in vec3 N, in vec3 V, in bool inShadow,\n                    in Material_t mat, in Light_t light )\n{\n    if ( inShadow )\n        return light.I_a * mat.k_a;\n    else {\n        vec3 R = reflect( -L, N );\n        float N_dot_L = max( 0.0, dot( N, L ) );\n        float R_dot_V = max( 0.0, dot( R, V ) );\n        float R_dot_V_pow_n = ( R_dot_V == 0.0 )? 0.0 : pow( R_dot_V, mat.n );\n        return light.I_a * mat.k_a +\n               light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n    }\n}\n\nvec3 CastRay( in Ray_t ray, out bool hasHit, out vec3 hitPos, out vec3 hitnormal, out vec3 k_rg )\n{\n    bool hasHitSomething = false;\n    float nearest_t = DEFAULT_TMAX;   // The ray parameter t at the nearest hit point.\n    vec3 nearest_hitPos;              // 3D position of the nearest hit point.\n    vec3 nearest_hitnormal;           // Normal vector at the nearest hit point.\n    int nearest_hitMatID;             // MaterialID of the object at the nearest hit point.\n    float temp_t;\n    vec3 temp_hitPos;\n    vec3 temp_hitnormal;\n    bool temp_hasHit;\n\n    // Attempt to intersect with planes\n    for (int i = 0; i < n_planes; i ++)\n    {\n        temp_hasHit = IntersectPlane(Plane[i], ray, DEFAULT_TMIN, nearest_t, temp_t, temp_hitPos, temp_hitnormal);\n        if (temp_hasHit && temp_t < nearest_t)\n        {\n            hasHitSomething = true;\n            nearest_t = temp_t;\n            nearest_hitPos = temp_hitPos;\n            nearest_hitnormal = temp_hitnormal;\n            nearest_hitMatID = Plane[i].materialID;\n        }\n    }\n    // Attempt to intersect with spheres\n    for (int i = 0; i < n_spheres; i ++)\n    {\n        temp_hasHit = IntersectSphere(Sphere[i], ray, DEFAULT_TMIN, nearest_t, temp_t, temp_hitPos, temp_hitnormal);\n\n        if (temp_hasHit && temp_t < nearest_t)\n        {\n            hasHitSomething = true;\n            nearest_t = temp_t;\n            nearest_hitPos = temp_hitPos;\n            nearest_hitnormal = temp_hitnormal;\n            nearest_hitMatID = Sphere[i].materialID;\n        }\n    }\n    // Attempt to intersect with bars\n    for (int i=0; i < NUM_BARS; i++){\n        if (IntersectBar(Bar[i], ray, DEFAULT_TMIN,nearest_t,temp_t,temp_hitPos,temp_hitnormal))\n        {\n            hasHitSomething=true;\n            nearest_t=temp_t;\n            nearest_hitnormal=temp_hitnormal;\n            nearest_hitPos=temp_hitPos;\n            nearest_hitMatID=Bar[i].materialID;\n        }\n    }\n    // Attempt to intersect with cubes\n    Material_t cube_matl;\n    for (int i = 0; i < n_cubes; i ++)\n    {\n        temp_hasHit = IntersectCube(Cube[i], ray, DEFAULT_TMIN, nearest_t, temp_t, temp_hitPos, temp_hitnormal);\n\n        if (temp_hasHit && temp_t < nearest_t)\n        {\n            hasHitSomething = true;\n            nearest_t = temp_t;\n            nearest_hitPos = temp_hitPos;\n            nearest_hitnormal = temp_hitnormal;\n            nearest_hitMatID = Cube[i].materialID;\n        }\n    }\n    hasHit = hasHitSomething;\n    if ( !hasHitSomething ) return BACKGROUND_COLOR;\n    vec3 I_local = vec3( 0.0 ); \n    for (int i = 0; i < NUM_LIGHTS; i ++)\n    {\n        Light_t light = Light[i];\n        Material_t matl = Material[nearest_hitMatID];\n        \n        vec3 N = nearest_hitnormal;\n        vec3 L = normalize(light.position - nearest_hitPos);\n        vec3 V = -ray.d;\n        \n        bool shadowed = false;\n        Ray_t shadow_ray;\n        shadow_ray.o = nearest_hitPos;\n        shadow_ray.d = L;\n        if (dot(shadow_ray.d, nearest_hitnormal) > 0.0)\n        {\n          for (int j = 0; j < n_planes && !shadowed; j ++)\n              shadowed = IntersectPlane(Plane[j], shadow_ray, DEFAULT_TMIN, distance(nearest_hitPos, light.position));\n          for (int j = 0; j < n_spheres && !shadowed; j ++)\n              shadowed = IntersectSphere(Sphere[j], shadow_ray, DEFAULT_TMIN, distance(nearest_hitPos, light.position));\n          for (int j = 0; j < n_cubes && !shadowed; j ++)\n              shadowed = IntersectCube(Cube[j], shadow_ray, DEFAULT_TMIN, distance(nearest_hitPos, light.position));\n          for (int j = 0; j < n_bars && !shadowed; j ++)\n              shadowed = IntersectBar(Bar[j], shadow_ray, DEFAULT_TMIN, distance(nearest_hitPos, light.position));\n        }\n        I_local += PhongLighting(L, N, V, shadowed, matl, light); // Phong shading\n    }\n    // Populate output results.\n    hitPos = nearest_hitPos;\n    hitnormal = nearest_hitnormal;\n    k_rg = Material[nearest_hitMatID].k_rg;\n    return I_local;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Current wave function value\n    waveFuncValue = waveFunc(iTime);\n\n    InitScene();\n    vec2 pixel_pos = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n    // Position the camera.\n    float t = 0.3 * iTime;\n    float cam_x = 8.0 * sin(t);\n    float cam_z = 3.0 * cos(t);\n    float cam_y = 3.0 + 0.5 * sin(t);\n    vec3 cam_pos = vec3( cam_x, cam_y, cam_z );\n    vec3 cam_lookat = vec3( 0.25, 1.0 + 2.0 * sin(t) + 0.5, 0.0 );\n    vec3 cam_up_vec = vec3( 0.0, 1.0, 0.0 );\n\n    // Set up camera coordinate frame in world space.\n    vec3 cam_z_axis = normalize( cam_pos - cam_lookat );\n    vec3 cam_x_axis = normalize( cross(cam_up_vec, cam_z_axis) );\n    vec3 cam_y_axis = normalize( cross(cam_z_axis, cam_x_axis));\n\n    // Create primary ray.\n    float pixel_pos_z = -1.0 / tan(FOVY / 2.0);\n    Ray_t pRay;\n    pRay.o = cam_pos;\n    pRay.d = normalize( pixel_pos.x * cam_x_axis  +  pixel_pos.y * cam_y_axis  +  pixel_pos_z * cam_z_axis );\n\n    // Use iterations to emulate the recursion.\n    vec3 I_result = vec3( 0.0 );\n    vec3 compounded_k_rg = vec3( 1.0 );\n    Ray_t nextRay = pRay;\n\n    for ( int level = 0; level <= NUM_ITERATIONS; level++ )\n    {\n        bool hasHit;\n        vec3 hitPos, hitnormal, k_rg;\n        vec3 I_local = CastRay( nextRay, hasHit, hitPos, hitnormal, k_rg );\n        I_result += compounded_k_rg * I_local;\n        if ( !hasHit ) break;\n        compounded_k_rg *= k_rg;\n        nextRay = Ray_t( hitPos, normalize( reflect(nextRay.d, hitnormal) ) );\n    }\n    fragColor = vec4( I_result, 1.0 );\n}","name":"Image","description":"","type":"image"}]}