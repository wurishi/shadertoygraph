{"ver":"0.1","info":{"id":"DscXD7","date":"1679903714","viewed":70,"name":"cloud with turbulence","username":"batersy","description":"A mass of noise here, somehow get a not bad result.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d","noise","cloud","distortion","turbulence"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * cloud shader with turbulence\n * Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n * Contact: seplanely@gmail.com\n */\n\n// click mouse to change direction\n\n// use this to see turbulence only\n#define SHOW_TURBULENCE 0\nfloat cloudSpeed = 0.1;\nfloat turbulenceSpeed = 0.05;\nvec3 background = vec3(146., 204., 256.)/256.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Get basic shape\n    vec2 p0 = fragCoord.xy;\n    vec2 p = fragCoord.xy / iResolution.xy;\n    vec2 mousePos = iMouse.xy;\n    if (ivec2(iMouse.xy) == ivec2(0,0))\n        mousePos = vec2(0.2,0.1);\n\tp = p*vec2(iResolution.x/iResolution.y,1.0) + iTime*cloudSpeed*hash2(mousePos);\n    float perlin = perlinNoise2DFbm(p, 4, 6.);\n    float voronoi = voronoiNoiseFbm2D(p, 6, 7.);\n    float perlinWorley = remap(perlin, voronoi, 1., 0., 1.);\n    float baseShape = perlinWorley;\n    float highFreq =  0.625 * voronoiNoise2D(p, 4.) +\n        \t\t0.250 * voronoiNoise2D(p, 8.) +\n        \t\t0.125 * voronoiNoise2D(p, 16.);\n    baseShape = remap(perlinWorley, -highFreq, 1., 0., 1.);\n    float coverage = texture(iChannel0, p).r;\n    vec3 color = vec3(remap(baseShape, coverage - 0.3, 1., 0., 1.));\n    \n    // Scroll the detail cloud\n    float perlinNew = perlinNoise2DFbm(p0 / iResolution.xy, 4, 4.);\n    float angle = perlinNew * TWO_PI;\n    p0 += 10. * vec2(cos(angle), sin(angle));\n    vec2 pDetail = p0 / iResolution.xy + iTime * turbulenceSpeed*hash21(mousePos * 0.5);\n\tpDetail = pDetail*vec2(iResolution.x/iResolution.y,1.0);\n    float perlinDetail = perlinNoise2DFbm(pDetail, 4, 8.);\n    float voronoiDetail = voronoiNoiseFbm2D(pDetail, 4, 12.);\n    float perlinWorleyDetail = remap(perlinDetail, voronoiDetail, 1., 0., 1.);\n    float baseShapeDetail = perlinWorleyDetail;\n    float highFreqDetail =  0.625 * voronoiNoise2D(p, 4.) +\n        \t\t0.250 * voronoiNoise2D(p, 8.) +\n        \t\t0.125 * voronoiNoise2D(p, 16.);\n    vec3 detail = vec3(remap(perlinWorleyDetail, highFreqDetail, 1., 0., 1.) + 0.4);\n    \n#if SHOW_TURBULENCE\n    color = vec3(0.);\n#endif\n\n    // blend together\n    float blend = 0.2;\n    color = remap(color, detail * blend, vec3(1.0), vec3(0.0), vec3(1.0));\n    color = clamp(color, vec3(0), vec3(1));\n    color = lerp(background, color, color.r);\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const mat2 m2 = mat2(  0.80,  0.60,\n                      -0.60,  0.80 );\nconst float perlinRange = sqrt(2.) / 2.;\nconst float coverage = 1.;\nconst int surround = 2;\n\nconst float PI = 3.14159265358979323846;\nconst float TWO_PI = 6.28318530717958647692;\n\nfloat remap(const float originalValue, const float originalMin, const float originalMax, const float newMin, const float newMax) {\n\treturn newMin + (((originalValue - originalMin) / (originalMax - originalMin)) * (newMax - newMin));\n}\n\nvec3 remap(const vec3 originalValue, const vec3 originalMin, const vec3 originalMax, const vec3 newMin, const vec3 newMax) {\n\treturn newMin + (((originalValue - originalMin) / (originalMax - originalMin)) * (newMax - newMin));\n}\n\nfloat hash(vec2 p) {\n    p  = 100. * sin(p.x + p.y) *fract( p*0.3183099 + vec2(0.71,0.113));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat hash21(vec2 p) {\n    p  = 100. * sin(p.x + p.y) *fract( p*0.121234 + vec2(0.71,0.1212));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat hash(vec3 p3) {\n    p3  = fract(p3 * 0.1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash2( vec2 p ) {\n    vec2 q = vec2( dot(p,vec2(127.1,311.7)), \n\t\t\t\t   dot(p,vec2(269.5,183.3)));\n\treturn fract(fract(q)*43758.5453 + fract(dot(p,q*p) * 3820.3201) * 48390.2378);\n}\n\nfloat perlinNoise3D( in vec3 x, float tile ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(mod(p+vec3(0,0,0),tile)), \n                        hash(mod(p+vec3(1,0,0),tile)),f.x),\n                   mix( hash(mod(p+vec3(0,1,0),tile)), \n                        hash(mod(p+vec3(1,1,0),tile)),f.x),f.y),\n               mix(mix( hash(mod(p+vec3(0,0,1),tile)), \n                        hash(mod(p+vec3(1,0,1),tile)),f.x),\n                   mix( hash(mod(p+vec3(0,1,1),tile)), \n                        hash(mod(p+vec3(1,1,1),tile)),f.x),f.y),f.z);\n}\n\nfloat perlinNoise2D( in vec2 p) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash(i + vec2(0.0,0.0)), \n                     hash(i + vec2(1.0,0.0)), u.x),\n                mix( hash(i + vec2(0.0,1.0)), \n                     hash(i + vec2(1.0,1.0)), u.x), u.y);\n}\n\nfloat perlinNoise2DFbm( vec2 p, const int octaves, float frequency ) {\n    p *= frequency;\n    float G = 0.5;\n    float f = 1.0;\n    float a = .5;\n    float t = 0.0;\n\n    for( int i=0; i<octaves; i++ ) {\n        t += a*perlinNoise2D( m2 * f * p);\n        f *= 2.0;\n        a *= G;\n    }\n    float range = -perlinRange + 2. * coverage * perlinRange;\n    t += range;\n    if(t > 0.)\n        t = remap(t, 0., range + perlinRange, 0., 1.);\n    //t = abs(-2. * t + 1.);\n    return t;\n}\n\nfloat voronoiNoise2D(in vec2 x, float frequency) {\n    x *= frequency;\n\tvec2 xi = floor(x);\n\tvec2 xf = fract(x);\n    float m_dist = 1.;\n    for( int x=-surround; x<=surround; x++ ) {\n        for( int y=-surround; y<=surround; y++ ) {\n            // Neighbor place in the grid\n            vec2 neighbor = vec2(float(x),float(y));\n\n            vec2 point = abs(vec2(hash(xi + neighbor), hash(xi + neighbor)));\n\n            // Vector between the pixel and the point\n            vec2 diff = neighbor + abs(hash(xi + neighbor)) - xf;\n\n            float dist = length(diff);\n\n            // Keep the closer distance\n            if(dist < m_dist) {\n                m_dist = min(m_dist, dist);\n            }\n        }\n    }\n    return m_dist;\n}\n\nfloat voronoiNoiseFbm2D( vec2 p, const int octaves, float frequency ) {\n    float G = 0.5;\n    float f = 1.0;\n    float a = 0.5;\n    float t = 0.0;\n    float w = 0.0;\n\n    for( int i=0; i<octaves; i++ ) {\n        t += a*voronoiNoise2D( p * f, frequency );\n        f *= 2.0;\n        w += a;\n        a *= G;\n    }\n\n    return t / w;\n}\n\nvec3 lerp(vec3 a, vec3 b, float t)\n{\n    return a + (b - a) * t;\n}","name":"Common","description":"","type":"common"}]}