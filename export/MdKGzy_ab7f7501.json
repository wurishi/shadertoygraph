{"ver":"0.1","info":{"id":"MdKGzy","date":"1595944752","viewed":93,"name":"Zzushi","username":"Daedelus","description":"sushi inspired by gyabo's tokyo demofest 2015 demonstration\n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sushiraymarchcheap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void R(inout vec2 plane, float angle)\n{\n    float sa = sin(angle);\n    float ca = cos(angle);\n    plane *= mat2(ca, -sa, sa, ca);\n}\n\n// Repeat only a few times: from indices <start> to <stop>\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat length8(vec3 p)\n{\n    vec3 m = pow(p, vec3(8.0));\n    return pow(m.x + m.y + m.z, 0.125);\n}\nfloat length6(vec3 p)\n{\n    vec3 m = pow(p, vec3(6.0));\n    return pow(m.x + m.y + m.z, 0.1666);\n}\nfloat length4(vec3 p)\n{\n    vec3 m = pow(p, vec3(4.0));\n    return pow(m.x + m.y + m.z, 0.25);\n}\nfloat length2(vec3 p)\n{\n    vec3 m = p * p;\n    return sqrt(m.x + m.y + m.z);\n}\n\nfloat topping(vec3 point)\n{\n    const float RADIUS = 2.0;\n    const float THICKNESS = 0.1;\n    \n    point.y -= RADIUS - 0.35;\n    \n    float outer = length(point) - RADIUS;\n    float box = sdBox(point, vec3(0.3, 3.0 * RADIUS, 0.5));\n    float inner = length(point) - RADIUS + THICKNESS;\n    \n    return max(-inner, max(box, outer));\n}\n\nfloat rice(vec3 point)\n{\n\tfloat seed = pModInterval1(point.z, 0.2, -1.0, 1.0);\n    return length2(point) - 0.3;\n}\n\nfloat plank(vec3 point)\n{\n    point.y -= 0.35;\n    float main = sdBox(point, vec3(1.2, 0.05, 0.8));\n    point.y -= 0.2;\n    point.x = abs(point.x) - 0.6;\n    float legs = sdBox(point, vec3(0.1, 0.1, 0.8));\n    return min(main, legs);\n}\n\nfloat filling( vec3 point){\n    return sdBox(point, vec3(0.1, 0.25, 0.1));\n        }\nfloat rice_cylinder( vec3 point){\n \tfloat height  = abs(point.y) - 0.2;   \n    return max(height, length(vec3 (point.x, 0.0, point.z)) - 0.25);\n}\nfloat seaweed( vec3 point){\n \tfloat height  = abs(point.y) - 0.19;   \n    return max(height, length(vec3 (point.x, 0.0, point.z)) - 0.27);\n}\n\n        \n\n\nvec2 sushi1(vec3 point, float a, float id ){\n        float b = rice(point);\n        float c = topping(point);\n        if(b<a)\n        {\n            a = b;\n            id = 1.0;\n        }\n        if(c<a)\n        {\n            a = c;\n            id = 2.0;\n        }\n        return vec2(a, id);\n    }\nvec2 sushi2 (vec3 point, float a, float id){\n    float d = filling(point);\n    float e = rice_cylinder(point);\n    float f = seaweed(point);\n    if (d<a){\n        a =d;\n        id= 2.;\n    }\n    if (e<a){\n    \ta =e;\n        id = 1.;\n    }\n    if (f < a){\n    \ta = f;\n        id = 3.;\n    }\n    return vec2(a , id);    \n    \n    \n    }\n\nvec2 fField(vec3 point)\n{\n    float a = plank(point);\n    float id = 0.0;\n    \n\tvec2 sushi_2 = sushi2(point, a, id);    \n    vec2 sushi_1 = sushi1(point, a, id);\n\tfloat b = sushi_2.x;\n    float id2 = sushi_2.y;\n    a = sushi_1.x;\n    id = sushi_1.y;\n\t\n    float w = sin(iTime) * 0.5 +0.5;\n    if (w < 0.5){ id = id2; };\n    float outa = mix(b, a, w);\n    return vec2(outa, id);\n}\n\n            \n            \nvec3 grad(vec3 p) {\n\tvec2 e = vec2(0.01, 0.0);\n\treturn (vec3(fField(p+e.xyy).x, fField(p+e.yxy).x, fField(p+e.yyx).x) - fField(p).x) / e.x;\n}\n\nconst int MAX_STEPS = 12;\nconst float NEAR_CLIP = 1.5;\nconst float FAR_CLIP = 5.0;\nconst float EPSILON = 0.03;\nconst float FOV = 0.3;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = (uv * 2.0 - 1.0);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // pixelate!\n    // uv = floor(uv * 25.0) / 25.0;\n    \n    vec3 origin = vec3(0.0, 0.0, -4.0);\n    vec3 direction = vec3(0.0, 0.0, 1.0);\n    R(direction.xz, uv.x * FOV);\n    R(direction.yz, uv.y * FOV);\n    \n    R(direction.yz, -0.4);\n    R(origin.yz, -0.4);\n    R(direction.xz, iTime);\n    R(origin.xz, iTime);\n    \n    float dist = NEAR_CLIP;\n    float id;\n    for(int i = 0 ; i < MAX_STEPS ; ++i)\n    {\n        vec2 d = fField(origin + direction * dist);\n        if(d.x < EPSILON)\n            break;\n        dist += d.x;\n        id = d.y;\n        if(dist > FAR_CLIP)\n            break;\n    }\n    vec3 color;\n    if(id >= 3.0)\n        color = vec3(0.2, 0.8, 0.3);\n\telse if(id >= 2.0)\n\t\tcolor = vec3(0.6, 0.1, 0.15);\n    else if (id >= 1.0)\n\t\tcolor = vec3(0.8, 0.8, 0.75);\n    else\n\t\tcolor = vec3(0.4, 0.15, 0.05);\n        \n\tvec3 isect = origin + direction * dist;\n    vec3 normal = grad(isect);\n    \n    vec3 sunDir = normalize(vec3(0.5, -1.0, 0.4));\n    float sun = max(0.0, dot(normal, sunDir));\n    float bounce = max(0.0, dot(normal, vec3(-0.3, 0.7, 0.3)));\n    float fill = max(0.0, dot(normal, vec3(-0.3, -0.7, -0.5)));\n    \n    vec3 ambient = vec3(0.3, 0.4, 0.6);\n    vec3 sunCl = sun * vec3(1.0, 0.7, 0.3) * 2.0;\n    vec3 bounceCl = bounce * vec3(1.0, 0.8, 0.2);\n    vec3 fillCl = fill * vec3(0.0, 0.2, 0.2);\n    \n    vec3 diffCl = sunCl + bounceCl + fillCl;\n    float shadow = fField(isect + sunDir * 0.2).x;\n    if(shadow < 0.04)\n        diffCl = vec3(0.0);\n    \n    // float fog = 1.0 / (-0.5 + dist);\n    float fog = 1.0 - ((dist - NEAR_CLIP) / (FAR_CLIP - NEAR_CLIP));\n\tfragColor = vec4((diffCl + ambient) * color * fog, 1.0);\n}","name":"Image","description":"","type":"image"}]}