{"ver":"0.1","info":{"id":"3sGSRh","date":"1573308702","viewed":84,"name":"Simple ray marching 101","username":"mgjunior","description":"Simple ray marching 101","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float perStep=0.4;\nconst float PI = 3.14;\nconst float epsilon = 0.001;  \n\nstruct Ray\n{\n    vec3 from; // position\n    vec3 dir; // vector\n};\n\nRay[4] createRayDiff(vec3 eye, vec3 xAxis,vec3 yAxis,vec3 p){\n    vec2[4] multisampleDiff;\n    float x = 0.5;\n    float y =0.5;\n    // offset from p\n    multisampleDiff[0]=vec2(x,y)/iResolution.y;   \n    multisampleDiff[1]=vec2(-y,x)/iResolution.y; \n    multisampleDiff[2]=vec2(-x,-y)/iResolution.y;\n    multisampleDiff[3]=vec2(y,-x)/iResolution.y;\n\n    Ray[4] rays;\n    for(int i=0;i<4;++i){\n        rays[i].from =p+( multisampleDiff[i].x*xAxis + multisampleDiff[i].y*yAxis );\n        rays[i].dir =normalize(rays[i].from-eye);\n    }\n\n    return rays;\n}\n\n// from https://iquilezles.org/articles/distfunctions\nfloat sdVerticalCapsule( vec3 p, float h, float r,float offset )\n{\n    p.y -= clamp( p.y, offset, h+offset );\n    return length( p ) - r;\n}\n\nfloat bottle(vec3 pos){\n\tfloat H =2.,R =1.,Offset=0.;\n\tfloat h=1.,r=0.25,offset =3.;\n    \n    //return sdVerticalCapsule(pos,h,r,offset);\n    return min(sdVerticalCapsule(pos,H,R,Offset),sdVerticalCapsule(pos,h,r,offset));\n}\n\n// gradient is normal\nvec3 getNormal(vec3 pos){\n    float delta =0.01;\n    vec3 temp=vec3(bottle(pos+vec3(delta,0.,0.))-bottle(pos),\n                   bottle(pos+vec3(0.,delta,0.))-bottle(pos),\n                   bottle(pos+vec3(0.,0.,delta))-bottle(pos)\n                  );\n\treturn normalize(temp);\n}\n\nvec3 shading(Ray ray,vec3 eye){\n    vec3 shadingColor = vec3(0.0,0.0,0.0);\n    \n    // 物件 3軸 and 位移obj_offset\n    vec3 obj_offset=vec3(0.,1.,0.);\n    vec3 zAxis =vec3(0.,0.,1.);\n    float para_obj_rot=iTime;\n    vec3 yAxis = vec3(-sin(para_obj_rot),cos(para_obj_rot),0.);\n    vec3 xAxis =vec3(cos(para_obj_rot),sin(para_obj_rot),0.);\n    \n    \n\t// 座標變換\n\t// http://gpnnotes.blogspot.com/2018/10/worldpointvector.html\n    \n    // to local space(變換到物件的local座標系)\n    vec3 temp=(ray.from-obj_offset);\n    Ray localRay;\n    localRay.from =vec3(dot(xAxis,temp),dot(yAxis,temp),dot(zAxis,temp));\n    localRay.dir=vec3(dot(xAxis,ray.dir),dot(yAxis,ray.dir),dot(zAxis,ray.dir));\n    \n    vec3 lightDir=normalize(vec3(1.,1.,1.));\n    vec3 localLightDir =vec3(dot(xAxis,lightDir),dot(yAxis,lightDir),dot(zAxis,lightDir));\n    \n    //front side of bottle\n    vec3 final_color=vec3(0.2,0.2,0.2);\n    for(int i=0;i<20;i++){ // 改小一點試看看會怎樣\n    \tfloat dist = bottle(localRay.from);\n        if(dist<0.01){\n            \n            //shading bottle color\n            vec3 n=getNormal(localRay.from);\n        \tfinal_color= vec3(0.0,1.0,0.75)*max(0.,dot(n,localLightDir)) // 燈光1\n                +vec3(1.0,1.0,0.0)*max(0.,dot(n,-localLightDir)); // 燈光2\n            \n            break;\n        }\n        \n        localRay.from+=dist*localRay.dir;\n    }\n    \n    return final_color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // weight (from -1 to 1)\n    vec2 weight = fragCoord/iResolution.xy;\n    weight= weight*2.0-1.0;\n\n    vec3 lookAt =vec3(0.0,1.0,0.0);\n    vec3 eye = vec3(0.0,1.0,5.0);\n    //vec3 eye = lookAt+ 5.0*vec3(cos(iTime),0.0,sin(iTime))+vec3(0.0,1.0,0.0);\n\n    // camera 3軸\n    vec3 zAsix = normalize(eye-lookAt);\n    vec3 yAxis = vec3(0.0,1.0,0.0);\n    vec3 xAxis = cross(yAxis,zAsix);\n    \n    //view frustum 近平面(z = -1) 這裡用右手座標\n    //這裡就是projection matrix對x,y做的事，反過來做\n    float fovDegree =90.0;\n    float halfFov = radians(0.5*fovDegree);\n    float tanH = tan(halfFov);\n    float tanW = tanH*iResolution.x/iResolution.y;\n\n    // generate point from the plane\n    vec3 pointOnPlane = eye -zAsix + xAxis*weight.x*tanW + yAxis*weight.y*tanH;\n    \n    // Antialiasing (多射幾條，取平均)\n    Ray[4] rays =createRayDiff(eye,xAxis,yAxis,pointOnPlane);\n    \n    vec3 color= vec3(0.0,0.0,0.0);\n    for(int i=0;i<1;++i) // 只射1條、不然手機跑起來超慢\n        color += shading(rays[i],eye);\n    //color *=0.25;\n\n    fragColor = vec4(color,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}