{"ver":"0.1","info":{"id":"NlSSDy","date":"1646644864","viewed":756,"name":"Raymarching SDF Visualization","username":"viclw17","description":"This shader visualizes the way raymarching works. Wip. \nBlog post --> https://viclw17.github.io/2022/03/01/raymarching-visualization-shaders","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","visualization","distance","depth","steps","debug"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Based on The Art of Code - Raymarching\n//https://www.youtube.com/watch?v=PGtv-dBi2wE&ab_channel=TheArtofCode\n\n//- mouse.x to push the iteration\n//- mouse.y to scale the depth\n//- rgb grid to visualize world position of sdf traced points\n//- white gradient to visualize traced total distance\n\nint MAX_STEPS = 50;\nfloat MAX_DIST = 100.;\nfloat SURF_DIST = .001;\n\nint iteration = 0;\n\nconst float sphere_radius = 1.;\nconst float sphere_zpos = 5.;\nconst float scene_max_dist = sphere_zpos + sphere_radius;\n\n//Smooth Minimum by iq\n//Source: https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nfloat GetDist(vec3 point){\n    // sphere\n    vec3 spherePos = vec3(sin(iTime), cos(iTime), sphere_zpos + .1);\n    float sphereRadius = sphere_radius;\n    float sphereDist = length(point - spherePos) - sphereRadius;\n    // plane\n    float planeDist = point.y + .1;\n    // distance\n    //float d = sphereDist;\n    //float d = min(sphereDist, planeDist);\n    float d = smin(sphereDist, planeDist, .5);\n    \n    return d;\n}\n\n\nvec4 RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; // total marching distance\n    float dS = 0.;\n    vec3 p;\n    \n    int steps = MAX_STEPS;\n    // anim stepping\n    //float debug_sine = (.5*sin(iTime)+.5); // 0-1\n    //steps = int(debug_sine * float(MAX_STEPS));\n    \n    float x = iMouse.x / iResolution.x;\n    if(iMouse.x == 0.) x = .5;\n    steps = int(x * float(MAX_STEPS));\n    \n    for(int i = 0; i < steps; i++){\n        // construct ray\n        p = ro + rd * dO;\n        // sdf\n        dS = GetDist(p);\n        \n        // march forward\n        //// sphere tracing\n        dO += dS; \n        //// same distancing marching\n        //dO += scene_max_dist / float(MAX_STEPS);\n        \n        if(dO > MAX_DIST || dS < SURF_DIST){ \n            iteration = i;\n            break;\n        }\n    }    \n    return vec4(p,dO);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    // viz uv\n    //col = vec3(mod(uv*10.,1.),0);\n    \n    // viz pixelate uv\n    col = vec3(ceil(uv*10.)/10.,0); \n    float k = 50.;\n    //uv = ceil(uv*k)/k;\n    \n    float imagePlaneZ = 1.;\n    vec3 ro = vec3(0, 1, 0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, imagePlaneZ));\n   \n    // viz total march distance\n    float dist = RayMarch(ro, rd).w;\n    \n    // fract\n    //col = vec3(fract(dist * 2.));\n    \n    //dist /= scene_max_dist;\n    dist /= MAX_DIST;\n    float y = iMouse.y / iResolution.y;\n    if(iMouse.y == 0.) y = 1.;\n    col = vec3(dist * 10.*(y * .5 + .5)); // scale\n\n    // viz world position z\n    vec3 pos = RayMarch(ro, rd).xyz;\n    //col = vec3(RayMarch(ro, rd).z/scene_max_dist);\n    \n    // turn world position into color grid and scale by inverse depth\n    //col += floor(mod(pos,.5)/.5 + .1) * (1./(pos.z-1.)); // grid unit 0.5\n    col += (smoothstep(0.9,1.0,mod(pos,.5)/.5) + smoothstep(0.9,1.0,mod(pos,-.5)/-.5));\n        //* (1./(pos.z-1.)) * 2.;\n    \n    //col = vec3(iteration) / float(MAX_STEPS);\n\n    //col = GetNormal(RayMarch(ro, rd).xyz);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}