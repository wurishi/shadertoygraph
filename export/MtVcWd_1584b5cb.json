{"ver":"0.1","info":{"id":"MtVcWd","date":"1538257956","viewed":508,"name":"Electric pattern","username":"And390","description":"A simple 2D fractal ","likes":23,"published":1,"flags":0,"usePreview":0,"tags":["2d","fractal","pattern","electric","circuit","board","impulse"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float scale = 0.05;\n\nconst vec3 backColor = vec3(0.0, 0.1, 0.1);\n\nconst float lineWidth = 0.1;\nconst float halfLineWidth = lineWidth / 2.;\nconst vec3 lineColor = vec3(0.2, 0.12, 0.0);\nconst vec3 impulseColor = vec3(1.0, 0.85, 0.4);\nconst float impulseSpeed = 4.;\nconst float impulseLength = 3.;\nconst float impulsePeriod = 3.5;  //time between generation of two sequential impulses\nconst float impulsePeriodLen = impulsePeriod * impulseSpeed;\n\n\n\n// return the node level - the highest power of 2 value which is the multiple of n.x and n.y\nint getLevel(ivec2 n, int level) {\n    if (n.x == 0 && n.y == 0)  return 2147483647;\n    while (true) {\n        ivec2 r = n % 2;\n        if (r.x == 1 || r.y == 1)  return level;\n        n /= 2;\n        level *= 2;\n    }\n    return level;\n}\n\nint getLevel(ivec2 n) {\n    return getLevel(n, 1);\n}\n\n// return true if we have such node and false if no\nbool checkNode(ivec2 n, int level) {\n    return (n.x - n.y) % (2*level) != 0;\n}\n\nbool checkNode(ivec2 n) {\n    int level = getLevel(n);\n    return checkNode(n, level);\n}\n\n\n// return the next node with higher level\nivec2 getNextNode(ivec2 n, inout int level) {\n    if ((n.x / level) % 2 == 1)  {\n        ivec2 a = ivec2(n.x+level, n.y);\n        ivec2 b = ivec2(n.x-level, n.y);\n        int al = getLevel(a, 1);\n        int bl = getLevel(b, 1);\n        if (!checkNode(a, al))  {  level = bl;  return b;  }\n        if (!checkNode(b, bl))  {  level = al;  return a;  }\n        if (al < bl)  {  level = bl;  return b;  }\n        else  {  level = al;  return a;  }\n    }\n    if ((n.y / level) % 2 == 1)  {\n        ivec2 a = ivec2(n.x, n.y+level);\n        ivec2 b = ivec2(n.x, n.y-level);\n        int al = getLevel(a, 1);\n        int bl = getLevel(b, 1);\n        if (!checkNode(a, al))  {  level = bl;  return b;  }\n        if (!checkNode(b, bl))  {  level = al;  return a;  }\n        if (al < bl)  {  level = bl;  return b;  }\n        else  {  level = al;  return a;  }\n    }\n    level = 2147483647;\n    return ivec2(0,0);\n}\n\n// return the shortest path from `n` to (0,0)\nint getPath(ivec2 n, int level) {\n    int path = 0;\n    ivec2 prevDir = ivec2(0, 0);\n    while (true) {\n        ivec2 prev = n;\n        if (n.x == 0 || n.y == 0)  {\n            return path + abs(prevDir.x) + abs(prevDir.y) + abs(n.x) + abs(n.y);\n        }\n        n = getNextNode(n, level);\n        ivec2 dir = n - prev;\n        if (dir.x == 0 && prevDir.x == 0 || dir.y == 0 && prevDir.y == 0)  {\n            prevDir += dir;\n        }\n        else  {\n            path += abs(prevDir.x) + abs(prevDir.y);\n            prevDir = dir;\n        }\n    }\n    return path;\n}\n\nivec2 getHomeNodeDir(ivec2 n, int level) {\n    ivec2 accDir = ivec2(0, 0);\n    if (n.x == 0 || n.y == 0)  accDir = -n;\n    else  {\n        while (true) {\n            ivec2 prev = n;\n            n = getNextNode(n, level);\n            ivec2 dir = n - prev;\n            if (dir.x == 0 && accDir.x == 0 || dir.y == 0 && accDir.y == 0)  accDir += dir;\n            else  break;\n        }\n    }\n    if (accDir.x == 0)  return accDir.y < 0 ? ivec2(0, -1) : ivec2(0, 1);\n    else  return accDir.x < 0 ? ivec2(-1, 0) : ivec2(1, 0);\n}\n\nvec3 getLineColor(ivec2 n, vec2 f, int level) {\n    float fx = abs(f.x - 0.5);\n    float fy = abs(f.y - 0.5);\n\n    if (fx < halfLineWidth || fy < halfLineWidth)  {\n        float p = float(getPath(n, level)) - iTime * impulseSpeed ;\n        if (mod(p, impulsePeriodLen) > impulseLength && mod(p + 1., impulsePeriodLen) > impulseLength)  return lineColor;\n\n        ivec2 dir = getHomeNodeDir(n, level);\n        float subPath = 1.;\n        if (fx < halfLineWidth)  {\n            float path;\n            if (dir.y==-1)  path = f.y;\n            else if (dir.y==1)  path = 1. - f.y;\n            else  path = 0.5 + fy;\n            subPath = path;\n        }\n        if (fy < halfLineWidth)  {\n            float path;\n            if (dir.x==-1)  path = f.x;\n            else if (dir.x==1)  path = 1. - f.x;\n            else  path = 0.5 + fx;\n            if (path < subPath)  subPath = path;\n        }\n\n        p += subPath;\n        float t = mod(p, impulsePeriodLen) / impulseLength;\n        float v = (t > 1. ? 0. : sin(t*3.1415926535897932384626433832795));\n        return mix(lineColor, impulseColor, v);\n    }\n\n    return backColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord * scale + vec2(0.5) + vec2(iTime*3.0, iTime*1.0);\n    //vec2 p = (fragCoord - iResolution.xy / 2.) * scale + vec2(0.5);\n    vec2 f = fract(p);\n    ivec2 n = ivec2(floor(p));\n    vec3 col = backColor;\n\n    if (fragCoord == iMouse.xy)  {  fragColor = vec4(1.0, 0.0, 0.0, 0.0);  return;  }\n\n    if (f.x > 0.5-halfLineWidth  && f.x < 0.5+halfLineWidth  || f.y > 0.5-halfLineWidth  && f.y < 0.5+halfLineWidth) {\n        if (n.x == n.y)  col = backColor;\n        else {\n            int level = getLevel(n);\n            if (checkNode(n, level))  col = getLineColor(n, f, level);\n            else  col = backColor;\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n\n","name":"Image","description":"","type":"image"}]}