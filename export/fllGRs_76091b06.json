{"ver":"0.1","info":{"id":"fllGRs","date":"1650958602","viewed":138,"name":"Point Ray nonSDF","username":"Rugged","description":"racasting with points. My quaternion math is a little \"wonky\" because I'm using the estimation that the sphereical ray direction vector is just the yzw components of the quaternion ray direction. It is only a good approximation when near 0 rotation.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["raycasting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float rayHit(vec3 camLoc, vec3 camDv, vec3 point, float pointRadius, vec3 rayDirec){\n    //vector from point to camera\n    vec3 camToP = point - camLoc;\n    \n    //length of previous vector\n    float cpL = length(camToP);\n    \n    //distance from ray to point\n    float d = cpL - dot(camToP, rayDirec);\n    \n    return pointRadius / d;\n}\n\n\n//hamilton product and quaternion mult are equivalent\nvec4 hamiltonProduct(vec4 a, vec4 b){\n    float r = (a.x * b.x) - (a.y * b.y) - (a.z * b.z) - (a.w * b.w);\n    float x = (a.x * b.y) + (a.y * b.x) + (a.z * b.w) - (a.w * b.z);\n    float y = (a.x * b.z) - (a.y * b.w) + (a.z * b.x) + (a.w * b.y);\n    float z = (a.x * b.w) + (a.y * b.z) - (a.z * b.y) + (a.w * b.x);\n    return vec4(r, x, y, z);\n}\n\nvec4 quaternionMult(vec4 a, vec4 b){\n    return vec4(a.x * b.x - dot(a.yzw, b.yzw), a.x*b.yzw + b.x*a.yzw + cross(a.yzw, b.yzw));\n}\n\n\nvec3 quatToEuler(vec4 q){\n    float a = atan((2. * ((q.x * q.y) + (q.z * q.w))) / (1. - (2. * ((q.y * q.y) + (q.z * q.z)))));\n    float b = asin(2. * ((q.x * q.z) + (q.y * q.w)));\n    float c = atan((2. * ((q.x * q.w) + (q.y * q.z))) / (1. - (2. * ((q.z * q.z) + (q.w * q.w)))));\n    return vec3(a, b, c);\n}\n\nvec3 eulerToSph(vec3 a){\n    return vec3(cos(a.x) * sin(a.y), sin(a.x) * sin(a.y), cos(a.y));\n}\n\nvec3 quatToSph(vec4 q){\n    return vec3(2. * ((q.x * q.z) + (q.w * q.y)), 2. * ((q.y * q.z) - (q.w * q.x)), 1. - (2. * ((q.x * q.x) + (q.y * q.y))));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //get the mouse location for look direction unless mouse is not down\n    vec2 muv = iMouse.z > 0.0 ? iMouse.xy / iResolution.xy : vec2(0.5, 0.5);\n    \n    \n    \n    vec3 col = vec3(0.);\n    \n    float screenRatio = iResolution.y / iResolution.x;\n    \n    //Setting up the ray directions and other information about the point and camera\n    //##############################################################################\n    \n    \n    //camera direction angles phi (xy plane) and theta (xz plane)\n    float phi = radians(360. * (1. - muv.x));\n    float theta = radians(180. * (1. - muv.y));\n    \n    //get the camera direction as the basis for the rotation (each ray direction is a rotation of the camera direciton vector)\n    //it is in quarternion form here so its a vec4 instead of a vec3\n    vec4 camD = vec4(0., cos(phi) * sin(theta), sin(phi) * sin(theta), cos(theta));\n    \n    \n    float rad90 = radians(90.);\n    \n    float fov = 100.;\n    \n    float xAng = radians(fov * (.5 - uv.x));\n    //replace \"fov\" with \"(fov + (110. * pow(.5 - uv.x, 2.)))\" below to add a counteractment to the fisheye lens effect\n    //it basically counteracts the artifact with quaternions that happens when you rotate by a large angle on one axis then try to rotate on another axis perpendicular, it just rotates around it thus making the new direction lesser\n    float yAng = radians(fov * screenRatio * (.5 - uv.y));\n    \n    //get the axes that the quarternions should be based around (perpendicular to the camera plane or dv)\n    vec3 xRotAxis = vec3(cos(phi) * sin(theta - rad90), sin(phi) * sin(theta - rad90), cos(theta - rad90));\n    vec3 yRotAxis = cross(xRotAxis, camD.yzw);//vec3(cos(phi - rad90) * sin(theta), sin(phi - rad90) * sin(theta), cos(theta));\n    \n    //get the quarternions of the ray direction rotations\n    vec4 xQuat = vec4(cos(xAng / 2.), xRotAxis * sin(xAng / 2.));\n    vec4 yQuat = vec4(cos(yAng / 2.), yRotAxis * sin(yAng / 2.));\n    \n    \n    \n    //combine the rotations\n    vec4 compQuat = quaternionMult(yQuat, xQuat);\n    \n    \n    \n    //get the conjugate of the compQuart\n    vec4 conjComp = vec4(compQuat.x, -compQuat.yzw);\n\n    \n    //ray direction\n    vec3 rayD = quaternionMult(quaternionMult(compQuat, camD), conjComp).yzw;\n    \n    \n    /*\n    vec4 yturn = hamiltonProduct(hamiltonProduct(yQuart, camD), vec4(yQuart.x, -yQuart.yzw));\n    vec3 xRotAxisTurned = hamiltonProduct(hamiltonProduct(yQuart, vec4(0., xRotAxis)), vec4(yQuart.x, -yQuart.yzw)).yzw;\n    \n    vec4 xQuart2 = vec4(cos(xAng / 2.), xRotAxisTurned * sin(xAng / 2.));\n    \n    vec4 xturn = hamiltonProduct(hamiltonProduct(xQuart2, vec4(0., yturn.yzw)), vec4(xQuart2.x, -xQuart2.yzw));\n    \n    vec3 rayD = xturn.yzw;\n    */\n    \n    \n    /*\n    vec4 xturn = hamiltonProduct(hamiltonProduct(xQuart, camD), vec4(xQuart.x, -xQuart.yzw));\n    vec3 rayD = hamiltonProduct(hamiltonProduct(yQuart, xturn), vec4(yQuart.x, -yQuart.yzw)).yzw;\n    */\n    \n    /*\n    vec4 compQuart = hamiltonProduct(yQuart, xQuart);\n    vec4 turnQuart = hamiltonProduct(compQuart, camD);\n    vec4 conjX = hamiltonProduct(turnQuart, vec4(xQuart.x, -xQuart.yzw));\n    vec3 rayD = hamiltonProduct(conjX, vec4(yQuart.x, -yQuart.yzw)).yzw;\n    */\n    \n    \n    //camera location\n    vec3 cam = vec3(cos(iTime), 0., 0.);\n    \n    \n    //point location and radius\n    //vec3 p = vec3(0., (5. * iTime) + 1., 0.);\n    float pr = .00001;\n    \n    \n    //############################################\n    \n    \n    \n    \n    for(int i = 0; i <= 200; i++){\n        vec3 p = texelFetch(iChannel0, ivec2(i % int(iResolution.y), i / int(iResolution.y)), 0).xyz;\n        \n        col += vec3(1. * (.6 / distance(p, cam))) * rayHit(cam, camD.yzw, p, pr, rayD);\n        \n        \n    }\n    \n    /*\n    if(abs(rayD.x - 0.) < .01 && abs(rayD.y - 1.) < .001 && abs(rayD.z - 0.) < .001){\n        col = vec3(1.);\n    }\n    */\n    \n    /*\n    if(abs(xAng - radians(-180.)) <.1){\n        col = vec3(1., 0., 0.);\n    }\n    */\n    \n    \n    /*\n    //Actual calculation of ray\n    //###########################\n    \n    \n    //vector from point to camera\n    vec3 camToP = p - cam;\n    \n    float cpL = length(camToP);\n    \n    float d = cpL - dot(camToP, rayD);\n    \n    if (d < pr){\n        col = vec3(1.);\n    }\n    \n    //#############################\n    */\n    \n    \n    \n    \n    \n    \n    \n    \n    //col = vec3(phi / radians(180.));\n    \n    //col = texture(iChannel0, uv).xyz;\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 col = vec3(0.);\n    \n    if(iFrame == 0){\n        col = vec3(2. * (hash3(uv) - .5), 2. * (hash3(uv.yx) - .5), 2. * (hash3(uv.xx) - .5));\n    }\n    else{\n        col = texture(iChannel0, uv).xyz;\n        //col.z -= .01;\n    }\n    \n    \n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//this hash gives good noise and has all numbers 0. to 1., \n//it is very slightly slower\nfloat hash3(vec2 xy){\n    xy = mod(xy, .19);\n    float h = dot(xy.yyx, vec3(.013, 27.15, 2027.3));\n    h *= h;\n    h *= fract(h);\n    \n    return fract(h);\n}\n","name":"Common","description":"","type":"common"}]}