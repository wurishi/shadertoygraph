{"ver":"0.1","info":{"id":"4X3GRS","date":"1716629839","viewed":84,"name":"Web of Reflections","username":"chronos","description":"Ray tracing reflective planes of a truncated cube.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["3d","reflection","ray","cube","mirror","trace","truncated"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Web of Reflections by chronos\n    --------------------------------------\n    \n    Just a doodle inspired by the reflective polyhedra going around these days :)\n    \n    This is just ray tracing the inside of a truncated cube.\n    \n    self link: \n    \n        https://www.shadertoy.com/view/4X3GRS\n    \n*/\n\nfloat sRGBencode(float C_linear) { return C_linear > 0.0031308 ? (1.055 * pow(C_linear, 1./2.4) - 0.055) : (12.92 * C_linear); }\nvec3 sRGBencode(vec3 C_linear) { C_linear = clamp(C_linear, 0., 1.); return vec3(sRGBencode(C_linear.x), sRGBencode(C_linear.y), sRGBencode(C_linear.z)); }\n\nfloat rayplane(vec3 ro, vec3 rd, vec3 pos, vec3 normal)\n{\n    float t = dot(normal, pos - ro) / dot(normal, rd);\n    return t;\n}\n\nvec3 axisangle(vec3 p, vec3 axis, float angle)\n{\n    float scalar_proj = dot(p, axis)/dot(axis, axis);\n    vec3 proj = scalar_proj * axis;\n    vec3 reject = p - proj;\n    \n    return proj + reject * cos(angle) + cross(axis, p) * sin(angle);\n}\n\nfloat hash(vec3 uv)\n{\n    uint x = floatBitsToUint(uv.x) | 1u; // 0 is a fixed point so we remove it. although this introduces duplicate 1\n    uint y = floatBitsToUint(uv.y);\n    uint z = floatBitsToUint(uv.z);\n    \n    y ^= y >> 13;\n    y ^= y << 17;\n    y ^= y >> 5;\n    y *= 0x2545F491u;\n\n    x ^= y;\n    x ^= x >> 13;\n    x ^= x << 17;\n    x ^= x >> 5;\n    x *= 0x4F6CDD1Du;\n    \n    z ^= x;\n    z ^= z >> 13;\n    z ^= z << 17;\n    z ^= z >> 5;\n    z *= 0x1D6C45F4u;\n    \n    // Shift down by 9 to use top 23 bits in mantissa\n    // Use exponent and sign bits from 0.5\n    // floatBitsToUint(.5) is a constant so that part can be pre-computed. (0x3f000000)\n    // Since the top 23 bits are shifted right, the rest (top bits) are zero and do not need to be masked out\n    // uint w = ((z>>9) & 0x007FFFFFu) | (0xFF800000u & floatBitsToUint(.5));\n    \n    uint w = (z>>9) | 0x3f000000u; // simplified version of the above commented out line\n    \n    // re-normalize from [0.5, 1) to [0, 1)\n    // This probably loses some bits, but should still be ok\n    return 2. * uintBitsToFloat(w) - 1.;\n}\n\nconst float PI = 3.14159265;\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    vec2 mouse = (2. * iMouse.xy - iResolution.xy) / iResolution.y;\n    \n    if(length(iMouse.xy) < 10.)\n        mouse = cos(iTime*.125 + vec2(0, PI*.5));\n    \n    vec3 color = vec3(0);\n\n    float focal = 1.5;\n    vec3 rd = normalize(vec3(uv, -focal));\n    \n    float angle = iTime*.5;\n    \n    rd = axisangle(rd, normalize(vec3(1,0,0)), 2.*PI*mouse.y);\n    rd = axisangle(rd, normalize(vec3(0,1,0)), 2.*PI*mouse.x);\n    //rd = axisangle(rd, normalize(vec3(1,1,1)), angle);\n    \n    vec3 ro = vec3(0);\n\n    float num_bounces = 10.;\n\n    const int num_planes = 14;\n\n    vec3[num_planes] planepositions = vec3[num_planes]( \n        vec3( 1,0,0), \n        vec3(-1,0,0), \n        vec3(0, 1,0), \n        vec3(0,-1,0),\n        vec3(0,0, 1),\n        vec3(0,0,-1),\n        \n        1.45 * normalize(vec3( 1, 1, 1)), \n        1.45 * normalize(vec3( 1, 1,-1)),\n        1.45 * normalize(vec3( 1,-1, 1)),\n        1.45 * normalize(vec3( 1,-1,-1)),\n        1.45 * normalize(vec3(-1, 1, 1)),\n        1.45 * normalize(vec3(-1, 1,-1)),\n        1.45 * normalize(vec3(-1,-1, 1)), \n        1.45 * normalize(vec3(-1,-1,-1))\n        \n    );\n    vec3[num_planes] planenormals   = vec3[num_planes](\n        vec3(-1,0,0),\n        vec3( 1,0,0),\n        vec3(0,-1,0),\n        vec3(0, 1,0),\n        vec3(0,0,-1),\n        vec3(0,0, 1),\n        \n        -normalize(vec3( 1, 1, 1)), \n        -normalize(vec3( 1, 1,-1)),\n        -normalize(vec3( 1,-1, 1)),\n        -normalize(vec3( 1,-1,-1)),\n        -normalize(vec3(-1, 1, 1)),\n        -normalize(vec3(-1, 1,-1)),\n        -normalize(vec3(-1,-1, 1)), \n        -normalize(vec3(-1,-1,-1))\n        \n    );\n\n    int current_idx  = -1;\n    float throughput = 1.;\n    \n    float T = 0.;\n\n    for(float bounce = 0.; bounce < num_bounces; bounce++)\n    {\n        float min_t = 9e9;\n        for(int plane_idx = 0; plane_idx < num_planes; plane_idx++)\n        {\n            if(plane_idx == current_idx) continue;\n\n            vec3 planepos = planepositions[plane_idx];\n            vec3 planenormal = planenormals[plane_idx];\n\n            float t = rayplane(ro, rd, planepos, planenormal);\n\n            if(t < min_t && t > 1e-6)\n            {\n                current_idx = plane_idx;\n                min_t = t;\n            }\n        }\n\n        if(current_idx >= 0)\n        {\n            ro = min_t * rd + ro;\n            T += min_t;\n            \n            float smoothing = 5e-3;\n            float alpha = smoothstep(.99-smoothing,.99+smoothing,length(ro - planepositions[current_idx]));\n            color += throughput * alpha;\n            throughput *= 1.-alpha;\n            \n            rd = reflect(rd, planenormals[current_idx]);\n        }\n        throughput *= 0.5;\n    }\n\n    // A bit of fog\n    color = mix(color, vec3(0.3, 0.7, 0.9), 1.-exp(-T * 0.0005));\n    \n    // Add some random vignetting\n    color *= max(0., 1.- 0.5*pow(length((2. * fragCoord.xy-iResolution.xy)/iResolution.xy) / sqrt(2.), 2.));\n    \n    color = tanh(color);\n    color = sRGBencode(color);\n    color += pow(tanh(20.*hash(vec3(fragCoord, iFrame))),2.) * 0.05; // Not for dithering, just for fun :)\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}