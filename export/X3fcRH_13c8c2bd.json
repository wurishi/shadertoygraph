{"ver":"0.1","info":{"id":"X3fcRH","date":"1726417391","viewed":63,"name":"eye-hurt torus 2","username":"ARCASHH","description":"trying with textures\n","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["texturing","pbr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NUM_LIGHT_SOURCES 2\n#define MAX_SHADOWS_STEPS 80\n#define MAX_MARCHING_STEPS 100\n#define MARCH_STEP_COEF 0.8\n#define MIN_DIST 0.0\n#define MAX_DIST 8.\n\n#define EPS 0.001\n#define PI 3.141592\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz) - t.x, p.y);\n  return length(q) - t.y\n      + 0.04 * sin(20.0*p.y + iTime )\n      + 0.08 * sin(10.0*p.x + iTime )\n      + 0.08 * sin(5.0*p.z + iTime);\n}\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  return dot(p,n) + h;\n}\n\n\n// Rotation matrix around the axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nstruct Light\n{\n    vec3 color;\n    vec3 pos;\n    float intensity;\n};\n\nstruct Material \n{\n    vec3 F0;\n    vec3 base_color;\n    float roughness;\n    float reflectance;\n    float gamma;\n};\n\n// operations\nvec2 Union( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\nvec2 smoothSubtraction ( vec2 d1, vec2 d2, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(d1.x + d2.x) / k, 0.0, 1.0 );\n    return vec2(mix( d1.x, -d2.x, h ) + k * h * (1.0 - h), d1.y); \n}\n\n\n//scene\nvec2 map(vec3 p)\n{\n    mat3 rot = rotateX(iTime * 0.2)*rotateY(iTime * 0.1)*rotateZ(iTime * 0.1);\n    vec2 res = vec2( MAX_DIST, 0.0 ); // second component - material id of object\n    \n    float m_id1 = 1., m_id2 = 2.;\n    float smooth_coef1 = .8, smooth_coef2 = .2;\n    \n    res = Union (res, vec2(sdPlane(p - vec3(0., -1.1, 0.), vec3(0., 1., 0.), 0.), m_id1));\n    \n    res = Union (res, vec2(sdTorus((p - vec3(0.2, 0., 0.2)) * rot, vec2(.5, .3)), m_id2));\n    res = smoothSubtraction(res, vec2(sdTorus(p - vec3(0.5, 0., 0.5), vec2(.5, .3)), m_id2 ), smooth_coef2);\n    \n    return res;\n}\n\nvec3 generateNormal ( vec3 p)\n{\n    float e = EPS;\n    float dx = map(p + vec3(e, 0, 0)).x - map(p - vec3(e, 0, 0)).x;\n    float dy = map(p + vec3(0, e, 0)).x - map(p - vec3(0, e, 0)).x;\n    float dz = map(p + vec3(0, 0, e)).x - map(p - vec3(0, 0, e)).x;   \n    return normalize ( vec3 ( dx, dy, dz ) );\n}\n\nvec2 rayMarch( vec3 ro,  vec3 rd) {\n  vec2 depth = vec2(MIN_DIST, 0.);\n  vec2 d = vec2(0.);\n  for (int i = 0; i < MAX_MARCHING_STEPS; ++i) {\n    vec3 p = ro + depth.x * rd;\n    d = map(p);\n    depth.x += d.x * MARCH_STEP_COEF;\n    if (d.x < EPS || depth.x > MAX_DIST) \n        break;\n  }\n  depth.y = d.y;\n  return depth;\n}\n\nfloat softShadow(in vec3 ro, in vec3 rd, float mint, float w)\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i = 0; i < MAX_SHADOWS_STEPS && t < MAX_DIST; ++i )\n    {\n        float h = map(ro + t * rd).x;\n        if( h < EPS )\n            return 0.0;\n        res = min( res, h / (t * w) );\n        t += clamp(h, 0.01, 0.2);\n    }\n    return res;\n}\n\nvec4 getTexture(sampler2D channel, vec3 p, float k)\n{\n    vec3 w = abs(generateNormal(p));\n    return  pow(w.x, k) * texture(channel, p.yz) +\n        pow(w.y, k) * texture(channel, p.xz) + \n        pow(w.z, k) * texture(channel, p.xy);\n}\n\n//Fresnel\nvec3 F_Schlick  ( in vec3 f0, in float nv )\n{\n    nv = clamp ( nv, 0.0, 1.0 ); \n    return mix ( f0, vec3 (1.0), pow(1.0 - nv, 5.0) );\n}\n\n//Distribution\nfloat D_blinn(in float roughness, in float nh)\n{\n    float m = roughness * roughness;\n    float m2 = m * m;\n    float n = 2.0 / m2 - 2.0;\n    return (n + 2.0) / (2.0 * PI) * pow(nh, n);\n}\nfloat D_beckmann ( in float roughness, in float nh )\n{\n\tfloat m    = roughness * roughness;\n\tfloat m2   = m * m;\n\tfloat nh2 = nh * nh;\n\t\n\treturn exp( (nh2 - 1.0) / (m2 * nh2) ) / (PI * m2 * nh2 * nh2);\n}\nfloat D_GGX ( in float roughness, in float nh )\n{\n\tfloat m  = roughness * roughness;\n\tfloat m2 = m * m;\n\tfloat nh2 = nh * nh;\n\tfloat d  = (m2 - 1.0) * nh2 + 1.0;\n\t\n\treturn m2 / (PI * d * d);\n}\n//Geometry\nfloat G_Schlick ( in float roughness, in float nv, in float nl )\n{\n    float k = roughness * roughness * 0.125;\n    float V = nv * (1.0 - k) + k;\n\treturn nv / V;\n}\nfloat G_neumann ( in float nl, in float nv )\n{\n\treturn nl * nv / max ( nl, nv );\n}\nfloat G_klemen ( in float nl, in float nv, in float vh )\n{\n\treturn nl * nv / (vh * vh );\n}\nfloat G_default ( in float nl, in float nh, in float nv, in float vh )\n{\n\treturn min ( 1.0, min ( 2.0*nh*nv/vh, 2.0*nh*nl/vh ) );\n}\n\nvec4 cookTorrance ( Material m, in vec3 n, in vec3 l, in vec3 v, in vec3 l_color )\n{\n    vec3  h = normalize ( l + v );\n    \n    float nh   = dot (n, h);\n\tfloat nv   = dot (n, v);\n\tfloat nl   = dot (n, l);\n\tfloat vh   = dot (v, h);\n    \n   \tvec3 F = F_Schlick ( m.F0, nv );\n    \n    float D = D_beckmann ( m.roughness, nh );\n    //float D = D_blinn( m.roughness, nh);\n    //float D = D_GGX ( m.roughness, nh );\n   \n    float G = G_default ( nl, nh, nv, vh );\n    //float G = G_neumann ( nl, nv );\n    //float G =  G_klemen ( nl,nv, vh );\n    //float G = G_Schlick ( m.roughness, nv, nl );\n    \n\tfloat  V   = 0.25 * G / ( nv * nl );\n    \n    m.base_color = mix( m.base_color, texture(iChannel0, reflect(-v, n)).rgb, m.reflectance);\n    vec3 ct = F * V * D * l_color;\n\tvec3  diff =  ( vec3(1.) - F ) * m.base_color / PI;\n\n\treturn vec4 ( pow ( diff + ct, vec3 ( 1.0 / (m.gamma + EPS) ) ), 1.0 );\n}\n\nMaterial getMaterial(float id, vec3 p)\n{\n    mat3 rot = rotateX(iTime * 0.2)*rotateY(iTime * 0.1)*rotateZ(iTime * 0.1);\n    Material m;  \n    if (id < 2.)\n       return Material(\n           vec3(0.04), //F0\n           texture(iChannel2, p.xz*0.5).rrr, //base_color\n           .9, //roughness\n           .8, //reflectance\n           1. //gamma\n       );\n    else\n       return Material(\n           vec3(0.7), //F0\n           getTexture(iChannel1, p * rot, 4.).rgb, //base_color\n           0.3, //roughness\n           0.6, //reflectance\n           3. //gamma\n       );\n      \n}\n\nvec3 getColor(vec2 res, vec3 p, vec3 ro, Light lightArray[NUM_LIGHT_SOURCES])\n{\n    Material m = getMaterial(res.y, p);\n    vec3 color = vec3(0.);\n    vec3 n = generateNormal(p); \n    vec3 v = normalize( ro - p ); // viewpoint vector\n    for(int i = 0; i < lightArray.length(); ++i){\n        vec3 l = normalize(lightArray[i].pos - p); // light direction\n        float shadow = 1.; //softShadow(p, l, .2, .3);\n        color += cookTorrance(m, n, l, v, lightArray[i].color * lightArray[i].intensity ).xyz * shadow; \n    }   \n    return color;\n}\n\n\n\nvec3 render( vec3 rd, vec3 ro)\n{\n    Light lightArray[NUM_LIGHT_SOURCES] = Light[NUM_LIGHT_SOURCES](\n        Light( vec3(1., 1., 0.), vec3(0., 2., 10.), 1. ),\n        Light( vec3(0.5, 0., 1.), vec3(0., 2., -10.), 1.)\n        );\n        \n    vec3 col = texture(iChannel0, rd).rgb; // background color\n    \n    vec2 res = rayMarch(ro, rd); \n    if (res.x < MAX_DIST) // if hit\n    {\n        vec3 p = (ro + rd * res.x);\n        col = getColor(res, p, ro, lightArray);\n    }\n    return col;\n}\n\nmat3 camera(vec3 cameraPos) {\n    vec3 cd = normalize(- cameraPos); \n    vec3 cr = normalize(cross(vec3(0, 1, 0), cd)); \n    vec3 cu = normalize(cross(cd, cr)); \n    return mat3(-cr, cu, -cd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;  \n    vec2 mouse = iMouse.xy/iResolution.xy;\n    \n    vec3 ro = vec3(0., 0., 3.); //camera position\n    ro *= rotateX(mix( 0.,-PI/2., mouse.y)) * rotateY(mix(-PI, PI, mouse.x ));\n    vec3 rd = camera(ro) * normalize(vec3(uv, -1));\n    \n    vec3 color = render(rd, ro);\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    vec3 col = vec3(0.);\n    if(rayDir.y<0.5)\n        col = vec3(1.);\n    if(abs(rayDir.z) > 0.8)\n        col = texture(iChannel0, rayDir.yx*.8 +.5).rgb;\n    else if(abs(rayDir.z) > 0.7 || abs(rayDir.z) <0.1)\n        col = vec3(0.);\n    else \n        col = 0.4 * (mix(vec3(0., 0., 0.), texture(iChannel1, rayDir.yz).rgb, rayDir.x) +\n            mix(texture(iChannel1, rayDir.yz).rgb, vec3(0., 0., 0.) , rayDir.x));\n    col += (-rayDir)*rayDir*rayDir * 0.5;\n    fragColor = vec4(col, 1.0);\n    \n}","name":"Cube A","description":"","type":"cubemap"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.141592\nfloat sdHexagram( in vec2 p, in float r ) // from https://iquilezles.org\n{\n    const vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= 2.0*min(dot(k.yx,p),0.0)*k.yx;\n    p -= vec2(clamp(p.x,r*k.z,r*k.w),r);\n    return length(p)*sign(p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y; \n\n    vec3 col = vec3(0.);\n    col.x = sin(.2 * iTime);\n    col.y = cos(.4 * iTime);\n    col.z = sin(.6 * iTime);\n\n    float d = sin(sdHexagram(uv, 10.) * 100. - iTime) ;\n    col *=  d * .5;\n\n    fragColor = vec4(col,  1.);\n}","name":"Buffer A","description":"","type":"buffer"}]}