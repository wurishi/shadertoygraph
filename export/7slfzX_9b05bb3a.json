{"ver":"0.1","info":{"id":"7slfzX","date":"1653273564","viewed":157,"name":"冰墩墩","username":"jkai421","description":"奥运吉祥物","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["1"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2\n#define STEP 12\n#define SOFT_SHADOW\n\nmat4 matRotate( in vec3 xyz )\n{\n    vec3 si = sin(xyz);\n    vec3 co = cos(xyz);\n\n\treturn mat4( co.y*co.z,                co.y*si.z,               -si.y,       0.0,\n                 si.x*si.y*co.z-co.x*si.z, si.x*si.y*si.z+co.x*co.z, si.x*co.y,  0.0,\n                 co.x*si.y*co.z+si.x*si.z, co.x*si.y*si.z-si.x*co.z, co.x*co.y,  0.0,\n\t\t\t     0.0,                      0.0,                      0.0,        1.0 );\n}\n\nmat4 matTranslate( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,   y,   z,   1.0 );\n}\n\nmat4 matInverse( in mat4 m )\n{\n\treturn mat4(\n        m[0][0], m[1][0], m[2][0], 0.0,\n        m[0][1], m[1][1], m[2][1], 0.0,\n        m[0][2], m[1][2], m[2][2], 0.0,\n        -dot(m[0].xyz,m[3].xyz),\n        -dot(m[1].xyz,m[3].xyz),\n        -dot(m[2].xyz,m[3].xyz),\n        1.0 );\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\n\nfloat sdElipsoid(in vec3 pos, vec3 rad)\n{\n    float k0 = length(pos/rad);\n    float k1 = length(pos/rad/rad);\n    return k0*(k0-1.0)/k1;\n}\n\n\nfloat sdSphere(in vec3 pos, float rad)\n{\n    float d = length(pos) - rad;\n    return d;\n}\n\nfloat sdStick(in vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    vec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - mix(r1,r2,h*h*(3.0-2.0*h));\n}\n\n\nfloat sdFace(in vec3 head)\n{\n    //face\n    vec3 vface = head - vec3(0.0, -0.08, 0.04);\n    float d = sdElipsoid(vface, vec3(.25, .26, .2));\n    if(STEP > 7)\n    { \n        vec3 vfront = head - vec3(0.0, 0.03, 0.21);\n        float d1 = sdElipsoid(vfront, vec3(0.004, 0.004, 0.007));\n        d = smin(d, d1, 0.1);\n    }\n    return d;\n    \n}\n\n\nvec2 sdDundun(in vec3 pos)\n{\n    vec3 center = vec3(0., 0.2, 0.);\n    //body\n    vec3 rad = vec3(.23, .2, .23);\n    float d = sdElipsoid(pos - center, rad);\n    vec3 q = pos - center;\n    vec3 h = q - vec3(0.0, 0.2, 0.0);\n    vec3 abs_h = vec3(abs(h.x), h.yz);\n    vec2 ret = vec2(d, 2.0);\n    if(STEP > 1){\n        float d1 = sdElipsoid(h, vec3(.26, .22, .26));\n        d = smin(d, d1, 0.2);\n        ret = vec2(d, 2.0);\n    }\n    if(STEP > 2){\n        //hole\n        vec3 vhole = h - vec3(0.0, -0.0, 0.16);\n        float d11 = sdElipsoid(vhole, vec3(.24, .16, .16));\n        d = smax(d, -d11, 0.03);\n        ret = vec2(d, 2.0);\n    }\n    if(STEP > 5){ \n        //face\n        float d6 = sdFace(h);\n        if(d > d6)\n        {\n            d = smin(d, d6, 0.03);\n            ret = vec2(d, 3.0);\n        }\n        if(STEP > 6)\n        { \n            //mouth\n            vec3 vm = h - vec3(0.0, -0.03+5.0*h.x*h.x, 0.26);\n            float d2 = sdElipsoid(vm, vec3(0.055, 0.01, 0.2));\n            d = smax(d, -d2, 0.01);\n        }\n        if(STEP > 9)\n        { \n            //eyes\n            vec3 ve = abs_h - vec3(0.09, 0.04, 0.18);\n            float d3 = sdSphere(ve, 0.035);\n            if(d > d3)\n            {\n                ret = vec2(d3, 4.0);\n            }\n        }\n        if(STEP > 10)\n        { \n            //nose\n            vec3 vn = h - vec3(0.0, 0.03+5.0*h.x*h.x, 0.25);\n            float d5 = sdElipsoid(vn, vec3(0.018, 0.013, 0.01));\n            if(d > d5)\n            {\n               d = smin(d, d5, 0.02);\n               ret = vec2(d, 5.0);   \n            }\n        }\n        if(STEP > 11)\n        { \n            //tonge\n            vec3 vm = h - vec3(0.0, -0.03+5.0*h.x*h.x, 0.26);\n            vec3 vt = vm - vec3(0.0, -0.01, -0.05);\n            float d7 = sdElipsoid(vt, vec3(0.04, 0.005, 0.03));\n            if(d > d7)\n            {\n                ret = vec2(d7, 6.0);\n            }\n        }\n    }\n    if(STEP > 3){ \n        //ears\n        vec3 vr = abs_h - vec3(0.20, 0.17, 0.0);\n\n        float d4 = sdElipsoid(vr, vec3(0.05, 0.05, 0.04));\n        if(d > d4)\n        {\n            d = smin(d, d4, 0.04);\n            ret = vec2(d, 5.0);\n        }\n    }\n    \n    if(STEP > 4){ \n        //tail\n        vec3 vtail = h - vec3(0.0, -0.23, -0.25);\n        float d8 = sdSphere(vtail, 0.05);\n        if(d > d8)\n        {\n           d = smin(d, d8, 0.02);\n           ret = vec2(d, 5.0);   \n        }\n        //arms\n        vec3 varm = h - vec3(0.31, -0.04, 0.0);\n        vec3 joint_r = vec3(-0.1, 0.0, 0.0);\n        vec3 hand_r = vec3(0.1, 0.1, 0.0);\n        float d9 = sdStick(varm, joint_r, hand_r, 0.05, 0.06);\n        vec3 joint_l = vec3(-0.5, 0.0, 0.0);\n        vec3 hand_l = vec3(-0.7, -0.2, 0.0);\n        d9 = min(d9, sdStick(varm, joint_l, hand_l, 0.05, 0.06));\n        if(d > d9)\n        {\n            d = smin(d, d9, 0.03);\n            ret = vec2(d, 5.0);\n        }\n        //legs\n        vec3 vleg = h - vec3(0.11, -0.4, 0.0);\n        vec3 up_l = vec3(0.01, 0.01, 0.0);\n        vec3 down_l = vec3(0.01, -0.1, 0.0);\n        float d10 = sdStick(vleg, up_l, down_l, 0.08, 0.09);\n        vec3 up_r = vec3(-0.21, 0.01, 0.0);\n        vec3 down_r = vec3(-0.21, -0.1, 0.0);\n        d10 = min(d10, sdStick(vleg, up_r, down_r, 0.08, 0.09));\n        if(d > d10)\n        {\n            d = smin(d, d10, 0.06);\n            ret = vec2(d, 5.0);\n        }\n    }\n    return ret;\n}\n\nvec2 sdGround(in vec3 pos)\n{\n    float groundHeight = -0.15;\n    return vec2(pos.y - groundHeight, 1.0);\n}\n\n\nvec2 sdScene(in vec3 pos)\n{\n\n    vec2 d1 = sdDundun(pos);\n    vec2 d2 = sdGround(pos);\n    return d1.x < d2.x? d1: d2;\n}\n                      \nvec3 calcNormal(in vec3 pos)\n{\n    vec2 e = vec2(0.001, 0.);\n    return normalize(vec3(\n    sdScene(pos+e.xyy).x - sdScene(pos-e.xyy).x, \n    sdScene(pos+e.yxy).x - sdScene(pos-e.yxy).x, \n    sdScene(pos+e.yyx).x - sdScene(pos-e.yyx).x));\n}\n\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    \n    for( int i=0; i<8; i++ )\n    {\n        float h = 0.01 + 0.21*float(i)/7.0;\n        occ += (h-sdScene( pos + h*nor )).x;\n    }\n    return clamp( 1.0 - 5.8*occ/8.0, 0.0, 1.0 );    \n}\n\nfloat castGroundShadow( in vec3 ro, vec3 rd)\n{\n    float res = 1.0;\n    float t = 0.001;\n    for(int i=0;i<100;i++)\n    {\n        vec3 pos = ro + t*rd;\n        float h = sdScene(pos).x;\n        if(h < 0.001)\n            break;\n        t +=h;\n        if (t > 20.0)\n        {\n            t = -1.0;\n            break;\n        }\n    }\n    return step(t, 0.0);\n}\n\nfloat castShadow( in vec3 ro, in vec3 rd, float k )\n{\n    float res = 1.0;\n    float t = 0.01;\n    for( int i=0; i<100; i++ )\n    {\n        float h = sdScene(ro + rd*t ).x;\n        res = min( res, smoothstep(0.2,1.0,k*h/t) );\n        t += clamp( h, 0.01, 0.025 );\n\t\tif( res<0.01 ) break;\n    }\n    \n    return clamp(res,0.0,1.0);\n}\n\nvec2 castRay(in vec3 ro, vec3 rd)\n{\n    vec2 t = vec2(0.01, -1.0);\n    for(int i=0;i<100;i++){\n        vec3 pos = ro + t.x*rd;\n        \n        vec2 h = sdScene(pos);\n        t.y = h.y;\n        if(h.x <0.001) \n            break;\n        t.x += h.x;\n        if(t.x > 20.0) \n        {\n            t.y = -1.0;\n            break;\n        }\n    }\n    return t;\n}\n\n\n\n\nmat4 mtxHead;\nvec3 sun_dir = normalize( vec3(1.0,1.0,0.5) );\n\nvec3 shadeDundun( in vec3 ro, in vec3 rd, in float t, float m )\n{\n    vec3 pos = ro + t*rd;\n    vec3 nor = calcNormal( pos);\n    vec3 ref = reflect( rd, nor );\n    \n    vec3 mate = vec3(1.0,1.0,1.0);\n    \n    if( m<1.5 )\n    {\n        if(STEP > 0)\n        {  \n            float sun_dif = clamp(dot(nor, sun_dir), 0., 1.);\n            float sun_sha = castGroundShadow(pos + nor*0.001, sun_dir);\n            return vec3(0.7, 0.7, 0.7) * sun_dif * sun_sha;\n        }\n    }\n    else if(m<2.5)\n    {\n        mate = vec3(1.0);\n    }\n    else if(m<3.5)\n    {\n        mate = vec3(1.0);\n        vec2 uv = (mtxHead * vec4(pos,1.0)).xy;\n        if(STEP > 7)\n        {  \n            uv.x = abs(uv.x);\n            uv -= vec2(0.12,-0.07);\n            uv = mat2(0.7,0.7,-0.7,0.7)*uv;\n            vec3 eye = vec3(0.0);\n            float eyes = 1.0-smoothstep( 0.06, 0.07, length(uv * vec2(0.6,1.0)) );\n            mate = mix( mate, eye, eyes );\n        }\n        if(STEP > 8)\n        { \n            uv += vec2(0.03,0.0);\n            vec3 inn_eye = vec3(1.0);\n            float inn_eyes = 1.0 - smoothstep( 0.02, 0.024, length(uv * vec2(0.7,0.7)) );\n            mate = mix( mate, inn_eye, inn_eyes );\n        }\n        \n    }\n\telse if (m<4.5)\n    {\n        mate = vec3(0.0,0.0,0.0);\n    }\n    else if (m<5.5)\n    {\n        mate = vec3(0.05,0.05,0.05);\n    }\n    else if(m < 6.5)\n    {\n        mate = vec3(1.0, 0.2, 0.2);\n    }\n    \n    vec3 hal = normalize( sun_dir - rd );\n    \n    float fre = clamp( 1.0 + dot(nor,rd), 0.0, 1.0 );\n    float occ = calcAO( pos, nor );\n\n    float bak = clamp( dot(nor,normalize(vec3(-sun_dir.x,0.0,-sun_dir.z))), 0.0, 1.0 );\n    float dif = clamp( dot(nor,sun_dir), 0.0, 1.0 );\n    float spe = clamp( dot(nor,hal), 0.0, 1.0 );\n    float sha = castShadow( pos, sun_dir,8.0); \n    dif *= sha;\n\n    vec3 col = 1.4*vec3(1.0,0.9,0.8)*dif +  0.8*vec3(0.2,0.28,0.35)*occ;\n    col += vec3(0.6,0.6,0.6)*fre*(0.3+0.3*dif)*occ*1.5;\n    col += vec3(0.4,0.3,0.2)*bak*occ;\n    \n    col *= mate;\n    \n    col += 3.5*vec3(0.3,0.4,0.5) * smoothstep( -0.1, 0.1, ref.y ) * (0.04 + 0.96*pow( fre, 5.0 )) * occ;\n    col += 2.0*vec3(1.0)*pow( spe, 64.0 ) * (0.2 + 0.8*pow( fre, 5.0 )) * (occ*dif);\n    \n    col = pow( col, vec3(0.8,1.0,0.9) );\n\n    col *= mix( vec3(0.3,0.2,0.1), vec3(1.0), smoothstep(-1.0,0.4,pos.y) );\n    return clamp( col, 0.0, 1.0 );;        \n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 rt, in float cr )\n{\n\tvec3 cw = normalize(rt-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, -cw );\n}\n\nvec3 render( in vec3 ro, in vec3 rd)\n{\n     //sky\n    vec3 col = vec3(0.4, .75, 1.0) - 0.7*rd.y;\n    \n    vec2 t = castRay(ro, rd);\n    vec3 pos = ro + t.x*rd;\n    if(t.y>0.){\n        col = shadeDundun(ro, rd, t.x, t.y);\n    }\n    return clamp( col, 0.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     float time = iTime;\n    \n    mat4 hRot = matRotate( vec3(0.0, 0.0,0.0) );\n    mat4 hTra = matTranslate( 0.0,0.5,0.11 );\n\n    mtxHead = matInverse( hTra * hRot );\n    \n    vec3 col = vec3(0.0);\n        for( int m=0; m<AA; m++ )\n        for( int n=0; n<AA; n++ )\n        {\n            vec2 offset = vec2(float(m),float(n))/float(AA);\n            vec2 p = (2.0*(fragCoord+offset)-iResolution.xy)/iResolution.y;\n            float an = 2.0*iMouse.x/iResolution.x + 1.0;\n            \n            vec3 ta = vec3(0., 0.6, -0.1);\n            vec3 ro = ta + vec3(1.5*sin(10.0*an), 0., 1.5*cos(10.0*an));\n            mat3 ca = setCamera( ro, ta, 0.0);\n            vec3 rd = normalize( ca * vec3(p,-1.5) );\n\n\t\t    col += render( ro, rd);\n        }    \n        col /= float(AA*AA);\n\n    vec2 q = fragCoord.xy/iResolution.xy;\n\n    col = pow(col, vec3(0.4545));\n    // saturate\n    col = mix( col, vec3(dot(col,vec3(0.333))), -0.1 );\n\n    // vignette\n    col *= 0.2 + 0.8*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}