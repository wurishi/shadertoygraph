{"ver":"0.1","info":{"id":"slyyWV","date":"1662222735","viewed":101,"name":"Raymarching Bootstrap","username":"slashrawr","description":"This is a basic raymarching shader to be used to bootstrap new raymarching shaders. Contains the raymarching functions and a basic diffuse lighting model with simple shadows.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","simple","basic","setup","bootstrap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 500\n#define MIN_DIST 0.00001\n#define MAX_DIST 500.\n#define TOGGLE_DIST_FIELD 0\n#define TOGGLE_NORMALS 0\n\nfloat sdSphere(vec3 point)\n{\n    vec4 sphere = vec4(0., 3., 10., 2.);\n    return distance(point, sphere.xyz)-sphere.w;\n}\n\nfloat calcScene(vec3 point)\n{\n    float sphereDist = sdSphere(point);\n    float groundDist = point.y;\n    return min(sphereDist, groundDist);\n}\n\nfloat rayMarch(vec3 rayOrigin, vec3 rayDirection)\n{\n    float originDist = 0.;\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 currentPoint = rayOrigin + rayDirection * originDist;\n        float marchDist = calcScene(currentPoint);\n        originDist += marchDist;\n        \n        if (originDist > MAX_DIST || marchDist < MIN_DIST)\n            break;\n    }\n    \n    return originDist;\n}\n\nvec3 calcNormal(vec3 point)\n{\n    //Estimate the normal by inspecting neighbouring pixels\n    vec2 shift = vec2(.01,0.);\n    float dist = calcScene(point);\n    vec3 normal = dist - vec3(calcScene(point-shift.xyy), calcScene(point-shift.yxy), calcScene(point-shift.yyx));\n    return normalize(normal);\n    \n}\n\nfloat calcLighting(vec3 point)\n{\n    //Light origin\n    vec3 lightPos = vec3(0., 10., 5.);\n    \n    vec3 lightVector = normalize(lightPos-point);\n    vec3 normal = calcNormal(point);\n    \n    //Diffuse lighting\n    float diffuse = clamp(dot(lightVector, normal), 0., 1.);\n    \n    //Shadows\n    float lightDistance = rayMarch(point+normal*MIN_DIST*1.5, lightVector);\n    if (lightDistance<length(lightPos-point))\n     diffuse *= 0.4;\n    \n    return diffuse;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 rayOrigin = vec3(0,2,0);\n    vec3 rayDirection = normalize(vec3(uv.x, uv.y, 1));\n    \n    vec3 col = vec3(0);\n    \n    float dist = rayMarch(rayOrigin, rayDirection);\n    vec3 surfacePoint = rayOrigin + rayDirection * dist;\n    \n    float light = calcLighting(surfacePoint);\n    col = vec3(light);\n    \n    #if (TOGGLE_NORMALS == 1)\n    {\n        col = vec3(calcNormal(surfacePoint)*(1./dist));\n    }\n    #endif\n \n    #if (TOGGLE_DIST_FIELD == 1)\n    {\n        dist /= 10.;\n        col = vec3(dist);\n    }\n    #endif\n    \n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}