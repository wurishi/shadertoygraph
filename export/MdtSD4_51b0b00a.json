{"ver":"0.1","info":{"id":"MdtSD4","date":"1459455586","viewed":112,"name":"basic implicit","username":"substack","description":"basic implicit function shader","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["implicit"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float udRoundBox (vec3 p, vec3 sizes, float round) {\n  return length(max(abs(p)-sizes,0.0))-round;\n}\n\nvec2 model(vec3 p) {\n  return vec2(udRoundBox(p, vec3(1.0,0.5,0.8), 0.2),0.0);\n}\n\nconst int steps = 20;\n\nvec2 calcRayIntersection(vec3 rayOrigin, vec3 rayDir, float maxd, float precis) {\n  float latest = precis * 2.0;\n  float dist   = +0.0;\n  float type   = -1.0;\n  vec2  res    = vec2(-1.0, -1.0);\n  for (int i = 0; i < steps; i++) {\n    if (latest < precis || dist > maxd) break;\n    vec2 result = model(rayOrigin + rayDir * dist);\n    latest = result.x;\n    type = result.y;\n    dist += latest;\n  }\n  if (dist < maxd) res = vec2(dist, type);\n  return res;\n}\n\nvec2 raytrace(vec3 rayOrigin, vec3 rayDir) {\n  return calcRayIntersection(rayOrigin, rayDir, 20.0, 0.001);\n}\n\nvec2 square(vec2 screenSize) {\n  vec2 position = 2.0 * (gl_FragCoord.xy / screenSize.xy) - 1.0;\n  position.x *= screenSize.x / screenSize.y;\n  return position;\n}\n\nvec3 camera(mat3 camMat, vec2 screenPos, float lensLength) {\n  return normalize(camMat * vec3(screenPos, lensLength));\n}\n\nmat3 lookAt(vec3 origin, vec3 target, float roll) {\n  vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n  vec3 ww = normalize(target - origin);\n  vec3 uu = normalize(cross(ww, rr));\n  vec3 vv = normalize(cross(uu, ww));\n\n  return mat3(uu, vv, ww);\n}\n\nvec3 lighting (vec3 pos, vec3 nor, vec3 rd, float dis, vec3 mal) {\n  vec3 lin = vec3(0.0);\n  vec3  lig = normalize(vec3(1.0,0.7,0.9));\n  float dif = max(dot(nor,lig),0.0);\n  lin += dif*vec3(2);\n  lin += vec3(0.05);\n  return mal*lin;\n}\n\nvec3 calcNormal(vec3 pos) {\n  const float eps = 0.002;\n\n  const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n  const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n  const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n  const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n  return normalize(v1*model(pos + v1*eps).x\n    + v2*model(pos + v2*eps).x\n    + v3*model(pos + v3*eps).x\n    + v4*model(pos + v4*eps).x);\n}\n\n\nvec3 camera(vec3 origin, vec3 target, vec2 screenPos, float lensLength) {\n  mat3 camMat = lookAt(origin, target, 0.0);\n  return camera(camMat, screenPos, lensLength);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  float cameraAngle = 0.8 * iTime;\n  vec3 rayOrigin = vec3(3.5 * sin(cameraAngle), 3.0, 3.5 * cos(cameraAngle));\n  vec3 rayTarget = vec3(0, 0, 0);\n  vec2 screenPos = square(iResolution.xy);\n  float lensLength = 2.0;\n  vec3 rayDirection = camera(rayOrigin, rayTarget, screenPos, lensLength);\n  vec2 collision = raytrace(rayOrigin, rayDirection);\n  if (collision.x > -0.5) {\n    vec3 pos = rayOrigin + rayDirection * collision.x;\n    vec3 nor = calcNormal(pos);\n    vec3 mat = vec3(0.5,0.1,0.8);\n    vec3 col = lighting(pos, nor, rayDirection, collision.x, mat);\n    col = pow(clamp(col,0.0,1.0), vec3(0.45));\n    fragColor = vec4(col, 1.0);\n  } else {\n    fragColor = vec4(0.0,0.0,0.0,1.0);\n  }\n}","name":"Image","description":"","type":"image"}]}