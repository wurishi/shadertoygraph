{"ver":"0.1","info":{"id":"7ttSzX","date":"1639520618","viewed":109,"name":"Log Meromorphic (help!)","username":"browric2","description":"I'm trying to emulate the patterns produced in the following twitter thread by Keenan Crane:https://twitter.com/keenanisali\nUnforunately, it doesn't appear to be working! Is anyone able to figure out what I'm doing wrong? Details in the comments :)","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["complexanalysis","meromorphic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\nI'm trying to emulate the beautiful patterns produced by taking the imaginary part of the log\nof a rational meromorphic function, initially just in grayscale.\n\nThis was inspired by this great twitter thread by Keenan Crane:\nhttps://twitter.com/keenanisalive/status/1448011475231117315\n\nAs you can see, I'm having a little trouble getting it to work correctly! Any help diagnosing\nthis would be really appreciated, hopefully my code is easy to follow for those familiar with\ncomplex analysis (I myself have only a beginner's knowledge of the field).\n\nI am also a GLSL noob (as you can probably tell), so I have some additional qs for anyone\nfeeling especially helpful:\n\n- Am I implementing the polynomials and rational function in a sensible way, or am I missing\n  a far easier or faster approach?\n- Is there any way to generalise the poly and mero functions for arbitrary rank?\n\n*/\n\n// Coeff Scale (Unneeded)\n#define SCALE 5.0\n\n// Simple complex operations\n#define product(a, b) vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x)\n#define conjugate(a) vec2(a.x,-a.y)\n#define divide(a, b) vec2(((a.x*b.x+a.y*b.y)/(b.x*b.x+b.y*b.y)),((a.y*b.x-a.x*b.y)/(b.x*b.x+b.y*b.y)))\n#define polar(a) vec2(length(a), atan(a.y, a.x))\n\n\n// Dave Hoskins \"Hash without Sine\" (4djSRW)\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n\n// --- Further complex ops ---\n\n// Complex powers\nvec2 c_pow(vec2 c, int n)\n{\n    vec2 c2 = c; \n    for (int i=1;i<n;i++){c2 = product(c2,c);}\n    return c2;\n}    \n\n// Complex log\nvec2 c_ln(vec2 c)\n{\n  vec2 pol = polar(c);\n  return vec2(log(pol.x), pol.y);\n}\n\n\n// --- Complex Polynomials ---\n\n// Rank 5 complex poly\nvec2 poly5(vec2 c, vec2 a1, vec2 a2, vec2 a3, vec2 a4, vec2 a5, vec2 a6)\n{\n    vec2 p5 = product(a1,c_pow(c,5)) + product(a2,c_pow(c,4)) + product(a3,c_pow(c,3));\n    p5 += product(a4,c_pow(c,2)) + product(a5,c) + a6;\n    return p5;\n}\n\n// Rank 7 complex poly\nvec2 poly7(vec2 c, vec2 a1, vec2 a2, vec2 a3, vec2 a4, vec2 a5, vec2 a6, vec2 a7, vec2 a8)\n{\n    vec2 p7 = product(a1,c_pow(c,7)) + product(a2,c_pow(c,6)) + product(a3,c_pow(c,5));\n    p7 += product(a4,c_pow(c,4)) + product(a5,c_pow(c,3)) + product(a6,c_pow(c,2));\n    p7 += product(a7,c) + a8;\n    return p7;\n}\n\n// R5/R7 complex rational meromorphic function\nvec2 mero57(vec2 c, vec2 a1, vec2 a2, vec2 a3, vec2 a4, vec2 a5, vec2 a6,\n            vec2 b1, vec2 b2, vec2 b3, vec2 b4, vec2 b5, vec2 b6, vec2 b7, vec2 b8)\n{\n    vec2 p5 = poly5(c, a1, a2, a3, a4, a5, a6);\n    vec2 p7 = poly7(c, b1, b2, b3, b4, b5, b6, b7, b8);\n    return divide(p5,p7);\n}\n\n\n// --- Main ---\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Pixel coordinates\n    vec2 uv = fragCoord/iResolution.xy;\n    float AR = iResolution.x/iResolution.y;\n    uv.x *= AR;\n    uv -= vec2(AR/2.,0.5);\n    \n    uv *= 5.;\n\n    // Poly coefficients\n    vec2 a1 = SCALE * hash21(23.12312);\n    vec2 a2 = SCALE * hash21(491.1234);\n    vec2 a3 = SCALE * hash21(13.12341);\n    vec2 a4 = SCALE * hash21(82345.97659);\n    vec2 a5 = SCALE * hash21(78.76857);\n    vec2 a6 = SCALE * hash21(275.9769);\n    vec2 b1 = SCALE * hash21(876.8765);\n    vec2 b2 = SCALE * hash21(326458.93759);\n    vec2 b3 = SCALE * hash21(48.97658);\n    vec2 b4 = SCALE * hash21(9.987699);\n    vec2 b5 = SCALE * hash21(0.879766987);\n    vec2 b6 = SCALE * hash21(29.98769);\n    vec2 b7 = SCALE * hash21(168.9867);\n    vec2 b8 = SCALE * hash21(192345.33980);\n\n    // Log Meromorphic function\n    vec2 mero = mero57(uv, a1, a2, a3, a4, a5, a6, b1, b2, b3, b4, b5, b6, b7, b8);\n    vec2 logmero = c_ln(mero);\n\n    // Colour\n    float c = logmero.y; // Imaginary part of meromorphic func\n    vec3 col = vec3(c);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}