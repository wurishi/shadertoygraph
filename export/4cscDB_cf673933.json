{"ver":"0.1","info":{"id":"4cscDB","date":"1721544911","viewed":104,"name":"Endless snow fields","username":"AndyCamelopardalis","description":"ÔºÅ","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Thanks for iq's tutorial on Bilibili: https://www.bilibili.com/video/BV1Da4y1q78H\n\n\n//limit\nfloat saturate(float x) { \n    return clamp(x,0.,1.); \n}\n//hash\nfloat hash(vec2 p) {\n    return fract(sin(dot(p,vec2(1022.4,1019.6)))*2005.05061);\n}\nfloat hash3(vec3 p) {\n    return fract(sin(p.x*p.y*p.z)*345444.531834);\n}\n\n//noise\nfloat noise_3(in vec3 p) {\n\tvec3 u = fract( p )*fract( p )*(3.0-2.0*fract( p )); \n    return abs(mix(mix(mix(hash3(floor(p)+vec3(0.0,0.0,0.0)),hash3(floor( p )+ vec3(1.0,0.0,0.0) ),u.x), mix(hash3(floor( p )+vec3(0.0,1.0,0.0)),hash3(floor( p )+vec3(1.0,1.0,0.0)),u.x), u.y),mix(mix(hash3(floor( p )+vec3(0.0,0.0,1.0) ),hash3(floor( p )+ vec3(1.0,0.0,1.0) ),u.x), mix(hash3(floor( p )+ vec3(0.0,1.0,1.0) ),hash3(floor( p )+ vec3(1.0,1.0,1.0) ),u.x), u.y),u.z));\n}\nvec3 noised(in vec2 p) {\n\tvec2 u = fract( p )*fract( p )*(3.0-2.0*fract( p ));\n    return vec3(abs(mix(mix(hash(floor( p )+ vec2(0.0,0.0) ),hash(floor( p )+ vec2(1.0,0.0) ),u.x),mix(hash(floor( p )+ vec2(0.0,1.0) ),hash(floor( p )+ vec2(1.0,1.0) ),u.x),u.y)), 6.0*fract( p )*(1.0-fract( p ))*(vec2(hash(floor( p )+ vec2(1.0,0.0) )-hash(floor( p )+ vec2(0.0,0.0) ),hash(floor( p )+ vec2(0.0,1.0) )-hash( floor( p )+ vec2(0.0,0.0) ))+(hash(floor( p )+ vec2(0.0,0.0) )-hash(floor( p )+ vec2(1.0,0.0) )-hash(floor( p )+ vec2(0.0,1.0) )+hash(floor( p )+ vec2(1.0,1.0) ))*u.yx));\n}\n\n//color\nvec3 sky_color(vec3 e) {\n    e.y = max(e.y,0.0);\n    vec3 ret = vec3(pow(1.0-e.y,3.0),pow(1.0-e.y, 1.2),0.8+(1.0-e.y)*0.3); \n    return ret;\n}\nvec3 terr_color(in vec3 p, in vec3 n, in vec3 eye, in vec3 dist) {\n    float slope = 1.0-dot(n,vec3(0.,1.,0.));     \n    vec3 ret = mix(vec3(2,2,2),vec3(0.0,0.1,0.1),smoothstep(0.0,0.2,slope*slope));\n    ret = mix(ret,vec3(2,2,2),saturate(smoothstep(0.6,0.8,slope+(p.y-13.*0.5)*0.05)));\n    return ret;\n}\n\n//map\nvec3 octave(vec2 uv) {\n    vec3 no = noised(uv);\n    return vec3(pow(no.x,1.9), no.y, no.z);\n}\nfloat map(vec3 p) {\n    float frq = 0.23;\n    float amp = 1.0;\n    vec2 uv = p.xz * frq + vec2(13.5,15.);\n    vec2 dsum = vec2(0.0);\n    float h = 0.0;    \n    for(int i = 0; i < 7; i++) {          \n    \tvec3 n = octave((uv - dsum * 0.7) * frq);\n        h += n.x * amp;       \n        dsum += n.yz * (n.x*2.0-1.0) * amp;\n        frq *= 2.5;\n        amp *= 0.58*pow(n.x,0.27);        \n    }\n    h *= 13. / (1.0 + dot(p.xz,p.xz) * 1e-3);\n    return p.y - h;\n}\nfloat map_noise(vec3 p) {\n    p *= 0.5;    \n    float ret = noise_3(p);\n    ret += noise_3(p * 2.0) * 0.5;\n    ret = (ret - 1.0) * 5.0;\n    return saturate(ret * 0.5 + 0.5);\n}\n\n//diffuse\nfloat diffuse(vec3 n,vec3 l,float p) { \n    return pow(max(dot(n,l),0.0),p); \n}\n//tracing\nvec3 getNormal(vec3 p, float e) {\n    return normalize(vec3(map(vec3(p.x+e,p.y,p.z)) - map(p),e,map(vec3(p.x,p.y,p.z+e)) - map(p)));\n}\nfloat tracing(vec3 ori, vec3 dir, out vec3 p, out float t) {\n    float d = 0.0;\n    t = 0.0;\n    for(int i = 0; i < 64; i++) {\n        p = ori + dir * t;\n        d = map(p);\n        if(d < 0.0) break;\n        t += d*0.6;\n    }\n    return d;\n}\n\n//rotating\nmat3 EulerAngleConversion(vec3 ang) {\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x)), a2 = vec2(sin(ang.y),cos(ang.y)), a3 = vec2(sin(ang.z),cos(ang.z));\n    mat3 m = mat3(vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x), vec3(-a2.y*a1.x,a1.y*a2.y,a2.x), vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y));\n\treturn m;\n}\n////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;    \n        \n    // ray\n    vec3 ang = vec3(0.1,0.1, iMouse.x*0.01);\n\tmat3 rot = EulerAngleConversion(ang);\n    vec3 ori = vec3(0.0,5.0,40.0);\n    vec3 dir = normalize(vec3(uv.xy,-2.0));\n    dir.z += length(uv) * 0.12;\n    dir = normalize(dir) * rot;\n    ori = ori * rot;\n    ori.y -= map(ori) * 0.75 - 3.0;\n    \n    // tracing\n    vec3 p;\n    float t;\n    float dens = tracing(ori,dir,p,t);\n    vec3 dist = p - ori;\n    vec3 n = getNormal(p, dot(dist,dist)* (1e-1 / iResolution.x));\n             \n    // terrain\n    vec3 color = terr_color(p,n,dir,dist) * vec3(0.45,0.53,0.75) * 0.6;\n    color += vec3(diffuse(n,normalize(vec3(1.0,1.0,-0.3)),4.0) * vec3(1.,1.,0.98) * 0.7);\n\n    // sky\n    color = mix(sky_color(dir),color,step(dens,4.0));\n    color += pow(max(dot(dir,normalize(vec3(1.0,1.0,-6.))),0.0),3.0)*0.3;\n    \n    //enddddddd\n    color = pow(((color - 1.0) * 1.2 + 1.0)* 0.8,vec3(1.0/2.2));\n\tfragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}