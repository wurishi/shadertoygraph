{"ver":"0.1","info":{"id":"ctjfzd","date":"1694394644","viewed":57,"name":"kisquadrille DDA","username":"jt","description":"Combine two 2d grid DDAs (one rotated and scaled) to a 4d hyper voxel DDA to render a [url=https://www.shadertoy.com/view/dtSBzc]kisquadrille[/url]/[url=https://en.wikipedia.org/wiki/Tetrakis_square_tiling]Tetrakis square tiling[/url] honeycomb.\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d","3d","raytracing","raycasting","voxel","square","diamond","4d","slice","honeycomb","dda","hyper","hourglass","kisquadrille"],"hasliked":0,"parentid":"cl2fRd","parentname":"DDA test site 2d"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/ctjfzd kisquadrille DDA, 2023 by jt\n// based on https://www.shadertoy.com/view/cl2fRd DDA test site 2d\n// (to render https://www.shadertoy.com/view/dtSBzc kisquadrille)\n// based on https://www.shadertoy.com/view/7dK3D3 Branchless Voxel Raycasting Tex\n// fork of https://www.shadertoy.com/view/4dX3zl Branchless Voxel Raycasting by fb39ca4\n// (with loop optimization by kzy), DDA based on http://lodev.org/cgtutor/raycasting.html\n// 3d-texture on voxels addon by jt\n\n// Combine two 2d grid DDAs (one rotated and scaled) to a 4d hyper voxel DDA\n// to render a kisquadrille (aka https://en.wikipedia.org/wiki/Tetrakis_square_tiling) honeycomb.\n\n// tags: 2d, 3d, raytracing, raycasting, voxel, square, diamond, 4d, slice, honeycomb, dda, hyper, hourglass, kisquadrille\n\n// The MIT License\n// Copyright (c) 2023 Jakob Thomsen\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n#define pi 3.1415926\n\n#define DIST_MAX 100.0\n\nmat3 yaw_pitch_roll(float yaw, float pitch, float roll)\n{\n    mat3 R = mat3(vec3(cos(yaw), sin(yaw), 0.0), vec3(-sin(yaw), cos(yaw), 0.0), vec3(0.0, 0.0, 1.0));\n    mat3 S = mat3(vec3(1.0, 0.0, 0.0), vec3(0.0, cos(pitch), sin(pitch)), vec3(0.0, -sin(pitch), cos(pitch)));\n    mat3 T = mat3(vec3(cos(roll), 0.0, sin(roll)), vec3(0.0, 1.0, 0.0), vec3(-sin(roll), 0.0, cos(roll)));\n\n    return R * S * T;\n}\n\nfloat checker(vec3 p)\n{\n    //return step(0.5, length(1.0 - abs(2.0 * fract(p) - 1.0))); // dots\n    return step(0.0, sin(pi * p.x + pi/2.0)*sin(pi *p.y + pi/2.0)*sin(pi *p.z + pi/2.0));\n    //return step(0.0, sin(p.x)*sin(p.y)*sin(p.z));\n}\n\nbool get_voxel(ivec4 c)\n{\n    c = c >> 2;\n    return ((c.x & 1) != (c.y & 1)) != ((c.z & 1) != (c.w & 1)); // checker\n\n    c = abs(c) - 3;\n\n    return c.x*c.x + c.y*c.y + c.z*c.z + c.w*c.w < 10;\n}\n\nvec2 flatten(vec4 v) // collapse 4d to 2d by identifying x with z and y with w\n{\n    return v.xy + v.zw;\n}\n\n// \"The raycasting code is somewhat based around a 2D raycasting toutorial found here:\n//  http://lodev.org/cgtutor/raycasting.html\" (fb39ca4)\n\n#define MAX_RAY_STEPS 64\n\nvec4 traverse_kisquadrille(vec3 ray_pos_orig, vec3 ray_dir_orig)\n{\n    float h = 0.5;\n\n    float plate_dist = abs(ray_pos_orig.z) <= h ? 0.0 : min((-h-ray_pos_orig.z)/ray_dir_orig.z, (+h-ray_pos_orig.z)/ray_dir_orig.z); // distance from camera to plate\n\n    if(plate_dist < 0.0) return vec4(-ray_dir_orig, DIST_MAX); // if entire plate missed return sky\n\n    ray_pos_orig += plate_dist * ray_dir_orig; // snap camera to nearest border of plate\n\n    mat4 M =\n        // kisquadrille is xor of normal grid (upper left matrix) with 45 deg rotated and scaled grid (lower right matrix)\n        mat4 // NOTE: matrix constructor by column therefore matrix looks transposed here\n        (\n            1,0,0,0,\n            0,1,0,0,\n            0,0,1,1,\n            0,0,-1,1\n        ); // rotate 45 deg and scale by sqrt(2.0) NOTE: det(M) == 2 so inverse(M) == transpose(M)/2\n    vec4 ray_pos = M*vec4(ray_pos_orig.xy, ray_pos_orig.xy);\n    vec4 ray_dir = M*vec4(ray_dir_orig.xy, ray_dir_orig.xy);\n\n    ivec4 tile_pos = ivec4(floor(ray_pos)); // round down position to get tile position\n    //if(get_voxel(tile_pos)) return vec4(vec3(0,0,sign(ray_pos_orig.z)), plate_dist); // if starting point at filled volume return surface normal (comment this out to remove floors & ceilings)\n    if(get_voxel(tile_pos)) return vec4(vec3(0,0,1), plate_dist); // if starting point at filled volume return surface normal (comment this out to remove floors & ceilings)\n\n    // decompose ray direction into reciprocal absolute ray direction and sign (-1,+1)\n    vec4 delta_dist = 1.0 / abs(ray_dir); // reciprocal absolute ray direction\n    ivec4 ray_step = ivec4(sign(ray_dir)); // sign of ray direction\n    // initial distances to nearest walls by dimension:\n    //     calculate ray position in relation to tile origin\n    //     (requires adding one half because tile origin is floor of ray position)\n    //     adjust sign according to ray direction\n    //     because tile has size 1 and we start in the middle wall is located at 0.5 (sign depends on ray direction)\n    //     divide by ray direction (to get distance with respect to ray)\n    vec4 side_dist = (vec4(ray_step) * (vec4(tile_pos) - ray_pos + 0.5) + 0.5) * delta_dist; // initial distances to nearest walls by dimension\n    bvec4 nearest = lessThanEqual(side_dist.xyzw, min(min(side_dist.yzwx, side_dist.zwxy), side_dist.wxyz)); // component is true if nearest wall in that dimension\n\n    vec4 result = vec4(-ray_dir_orig, DIST_MAX); // sky\n\n    for (int i = 0; i < MAX_RAY_STEPS; i++)\n    {\n        if(get_voxel(tile_pos))\n        {\n            // recover distance as described in https://lodev.org/cgtutor/raycasting.html (see \"perpWallDist\" there)\n            //float dist = abs(nearest.x ? side_dist.x - delta_dist.x : nearest.y ? side_dist.y - delta_dist.y : 0.0);\n            float dist = length(vec4(nearest) * (side_dist - delta_dist));\n            if(abs(ray_pos_orig.z + dist * ray_dir_orig.z) > h) return vec4(-ray_dir_orig, DIST_MAX); // leaving plate? sky\n            // NOTE: nearest contains only one component set to true indicating nearest direction and since normal points along this direction just cast nearest to normal (sign opposite to ray direction)\n            result = vec4(flatten(inverse(M)*(vec4(nearest)*vec4(-ray_step))), 0.0, dist + plate_dist);\n\n            break;\n        }\n\n        // core of https://www.shadertoy.com/view/4dX3zl Branchless Voxel Raycasting by fb39ca4 (somewhat reduced)\n        nearest = lessThanEqual(side_dist.xyzw, min(min(side_dist.yzwx, side_dist.zwxy), side_dist.wxyz)); // component is true if nearest wall in that dimension\n        side_dist += vec4(nearest) * delta_dist; // update distances to nearest walls by dimension\n        tile_pos += ivec4(nearest) * ray_step; // step to next tile in direction of nearest wall\n    }\n\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 I )\n{\n    bool demo = all(lessThan(iMouse.xy, vec2(10.0)));\n    vec2 R = iResolution.xy;\n    //I = 2.0 * I.xy / R - 1.0;\n    //I.x *= R.x / R.y;\n    I = (2.0 * I - R) / R.y; // concise pixel-position mapping thanks to Fabrice\n    float yaw = 2.0 * pi * float(iMouse.x) / float(R.x);\n    float pitch = -pi/4.0 + pi - pi / 2.0 * float(iMouse.y) / float(R.y);\n    yaw = !demo ? yaw : 2.0 * pi * fract(iTime * 0.01);\n    pitch = !demo ? pitch : 1.5 * pi/2.0;\n\n    vec3 ray_pos = vec3(0.0, 0.0, -16.0);\n    vec3 ray_dir = vec3(I.x, I.y, 2.0); // NOTE: un-normalized direction appears to work fine here!\n    //ray_dir = normalize(ray_dir); // looks like ray-direction does not need to be normalized\n\n    mat3 M = yaw_pitch_roll(yaw, pitch, 0.0); // rotate camera\n    ray_pos = M * ray_pos;\n    ray_dir = M * ray_dir;\n\n    //ray_pos.z -= 0.0;\n\n    //ray_dir = normalize(ray_dir);\n\n    vec4 result = traverse_kisquadrille(ray_pos, ray_dir);\n    vec3 color = vec3(0);\n    if(result.w < DIST_MAX)\n    {\n        vec3 n = result.xyz;\n        float d = result.w;\n        vec3 dst = ray_pos + ray_dir * d;\n        d *= length(ray_dir); // fix distance in case ray was not normalized\n\n        vec3 light_dir = normalize(vec3(1,2,3));\n        //float brightness = max(0.0, dot(lightdir, n));\n        float diffuse = abs(dot(light_dir, n));\n        bool shadow = traverse_kisquadrille(dst+result.xyz*0.001, light_dir).w < DIST_MAX;\n        if(shadow)\n            diffuse = 0.0;\n        float ambient = 0.2;\n        float specular = max(0.0, dot(result.xyz, normalize(-normalize(ray_dir) + light_dir)));\n        color = (diffuse + ambient) * vec3(0.5 + 0.5 * result.xyz);\n        //color *= mix(vec3(0.5), vec3(1.0), checker(dst*2.0));\n        if(!shadow)\n            color += 0.5 * pow(specular, 50.0);\n\n        vec3 fogcolor = vec3(0); // fog\n        color *= mix(fogcolor, color, exp(-d * d / 1000.0)); // fog for depth impression & to suppress flickering\n    }\n    else\n    {\n        color = vec3(0,0,0);\n    }\n\n    //color = mix(vec3(1,1,0),vec3(0,0,1),result.w/20.0); // debug distance\n\n    color = tanh(color); // roll-off overly bright colors\n\n    fragColor = vec4(sqrt(color), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}