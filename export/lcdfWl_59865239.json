{"ver":"0.1","info":{"id":"lcdfWl","date":"1733646097","viewed":184,"name":"Foggy SDF's","username":"TheNuclearWolf","description":"Wanted to learn how to create better volumetric effects, Pretty happy with the results.\nNo idea if this is correct but might be useful resource for others to learn off.","likes":23,"published":3,"flags":32,"usePreview":0,"tags":["volumetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 texelSize = 1.0 / iResolution.xy;\n    \n    vec4 color = vec4(0.0);\n    \n    float blurRadius = 5.0;\n    float samples = 0.0;\n    for(float y = -blurRadius; y <= blurRadius; y++) {\n        vec2 offset = vec2(0.0, y + 0.5) * texelSize;\n        color += texture(iChannel0, uv + offset);\n        samples += 1.0;\n    }\n    \n    fragColor = color / samples;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// MIT Licensed\n\n// ==================== Shape Stuff ==================== \n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat smoothMin(float d1, float d2, float k) {\n    float h = max(k - abs(d1 - d2), 0.0) / k;\n    return min(d1, d2) - h * h * h * k / 6.0;\n}\n\nfloat sampleDensity(vec3 p) {\n    p.y += 2.0;\n    // Create base shape - a torus\n    float torus = sdTorus(p, vec2(2.0, 0.5));\n    \n    // Add floating spheres around the torus\n    float spheres = 999999.0;\n    for(int i = 0; i < 6; i++) {\n        float a = float(i) * 3.14159 * 2.0 / 6.0;\n        vec3 offset = vec3(cos(a) * 2.0, sin(iTime + float(i)), sin(a) * 2.0);\n        float sphere = sdSphere(p - offset, 0.3);\n        spheres = min(spheres, sphere);\n    }\n    \n    // Add a center piece\n    vec3 boxP = p;\n    boxP.y *= 1.0 + 0.3 * sin(iTime);  // Stretch/squish animation\n    float box = sdBox(boxP, vec3(0.7));\n    \n    // Combine everything with smooth min\n    float d = smoothMin(torus, spheres, 1.0);\n    d = smoothMin(d, box, 1.0);\n    \n    // Convert distance to density (negative distance = inside shape)\n    return -d;\n}\n\n// ==================== End Of Shape Stuff ==================== \n\n// ==================== Camera Stuff ==================== \n\nmat3 getCameraMatrix(vec3 ro, vec3 lookAt) {\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(right, forward));\n    return mat3(right, up, forward);\n}\n\nvoid getRoRd(vec2 fragCoord, out vec3 ro, out vec3 rd)\n{    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    // Orbit camera controls\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    float camDist = 5.0;\n    \n    // If mouse isn't being used, auto-rotate\n    if (iMouse.z <= 0.0) {\n        mouse = vec2(0.5 + 0.5*cos(0.2*iTime), 0.5);\n    }\n    \n    // Convert mouse position to spherical coordinates\n    float azimuth = (mouse.x * 2.0 - 1.0) * 3.141592;\n    float elevation = (mouse.y - 0.5) * 3.141592;\n    \n    // Calculate camera position\n    ro = vec3(\n        camDist * cos(elevation) * cos(azimuth),\n        camDist * sin(elevation),\n        camDist * cos(elevation) * sin(azimuth)\n    );\n    \n    // Look at origin\n    vec3 lookAt = vec3(0.0, -2.0, 0.0);\n    mat3 camMat = getCameraMatrix(ro, lookAt);\n    rd = camMat * normalize(vec3(p, 2.0));\n\n}\n\n// ==================== End Of Camera Stuff ==================== \n\nconst float DensityMultiplier = 2.0;\nconst float ShadowMultiplier = 15.0;\n\nfloat sampleLight(vec3 pos, vec3 lightDir, float jitter) {\n    \n    // Sample fewer steps for light than main ray for performance\n    const int LIGHT_STEPS = 32;\n    const float MAX_LIGHT_DIST = 2.0;\n    float stepSize = MAX_LIGHT_DIST / float(LIGHT_STEPS);\n    \n    // March towards light\n    vec3 p = pos + (lightDir * jitter * stepSize);\n    float totalDensity = 0.0;\n    for(int i = 0; i < LIGHT_STEPS; i++) {\n        float density = sampleDensity(p);\n        if(density > 0.0)\n        {\n            totalDensity += density * DensityMultiplier * ShadowMultiplier * stepSize;\n            p += lightDir * stepSize;\n        }\n        else\n        {\n            // Density is also the distance we are to surface.... lets do a cheecky skip\n            int stepsToSkip = max(1, int(floor(-density / stepSize)));\n            p += lightDir * stepSize * float(stepsToSkip);\n            i += stepsToSkip - 1;\n        }\n    }\n    \n    return totalDensity;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 ro;\n    vec3 rd;\n    getRoRd(fragCoord, ro, rd);\n    \n    // Sun direction\n    vec3 sunDir = normalize(vec3(0.5, 0.2, -0.3));\n    vec3 sunColor = vec3(1.0, 0.9, 0.7); // Warm, bright sun\n    \n    // Per-channel scattering coefficients\n    vec3 scatteringCoeff = vec3(0.3, 1.64, 2.28);\n    \n    // Raymarch parameters\n    const int MAX_STEPS = 32;\n    const float MAX_DIST = 6.5;\n    float stepSize = MAX_DIST/float(MAX_STEPS);\n    \n    vec3 acc = vec3(0.0);\n    float totalDensity = 0.0;\n    \n    // Jitter the start position with blue noise\n    float blueNoise = texture(iChannel0, fragCoord / 1024.0f).r;\n    vec3 pos = ro + (rd * stepSize * blueNoise);\n    // We can start the ray a little closer\n    pos += (rd * 1.5);\n    \n    // Raymarch loop\n    for(int i = 0; i < MAX_STEPS; i++) {\n    \n        float density = sampleDensity(pos);\n        \n        if(density > 0.0) \n        {\n            density *= DensityMultiplier * stepSize;\n            totalDensity += density;\n            \n            // Calculate inscattering with shadows\n            float sunRayDensity = sampleLight(pos, sunDir, blueNoise);\n            vec3 inscatter = exp(-sunRayDensity * scatteringCoeff) * density * scatteringCoeff;\n            \n            acc += inscatter * exp(-totalDensity * scatteringCoeff);\n            \n            pos += rd * stepSize;\n        }\n        else\n        {\n            // Density is also the distance we are to surface.... lets do a cheecky skip\n            int stepsToSkip = max(1, int(floor(-density / stepSize)));\n            pos += rd * stepSize * float(stepsToSkip);\n            i += stepsToSkip - 1;\n        }\n    }\n    \n    vec3 col = acc * 4.0;\n    col.rgb = (col.rgb * (2.51 * col.rgb + 0.03)) / (col.rgb * (2.43 * col.rgb + 0.59) + 0.14);\n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 texelSize = 1.0 / iResolution.xy;\n    \n    vec4 color = vec4(0.0);\n    \n    float blurRadius = 5.0;\n    float samples = 0.0;\n    for(float x = -blurRadius; x <= blurRadius; x++) {\n        vec2 offset = vec2(x + 0.5, 0.0) * texelSize;\n        color += texture(iChannel0, uv + offset);\n        samples += 1.0;\n    }\n    \n    fragColor = color / samples;\n}","name":"Buffer B","description":"","type":"buffer"}]}