{"ver":"0.1","info":{"id":"43SfR3","date":"1729725222","viewed":97,"name":"Permanent Zooming (using mouse)","username":"zubetto","description":"Zooming is controlled by horizontal mouse movement. Zoom center is determined by the mouse position at the moment the LMB is pressed. See the description of the ZoomOptions structure in the Common tab for information on the available options. ","likes":2,"published":1,"flags":32,"usePreview":1,"tags":["mouse","zoom","uv","scale","scaling","zooming"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Normalized pixel coordinates after zooming\n    ZoomData currentZoom;\n    fetchZoomData(iChannel0, ZOOM_DATA_TEXELS, currentZoom);\n    uv = zoomUV(currentZoom, uv);\n    \n    // As an example, texture sampling in a zoomed area\n    fragColor = textureLod(iChannel1, uv, 0.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// STRUCTURES //////////////////////////////////////////////\n// Zooming is controlled by horizontal mouse movement while holding down the left mouse button (LMB);\n// Zoom center is determined by the mouse position at the moment the LMB is pressed;\n// ZoomOptions:\n//\n// zoomOutToClampedUV : if true, then the current zoom center may be adjusted\n//                      to keep the UV coordinates of the zoomed area in the range [0, 1]\n//                      (for this adjustment to have a meaningful effect, zoomMin should be set to 1.0);\n//\n// zoomBase           : the zoom level multiplier is defined as zoomBase raised to the power\n//                      corresponding to the mouse movement (actual or by inertia),\n//                      for example, a zoomBase value of 4 means that the zoom level changes\n//                      by a factor of 2 when the mouse moves half the length of the viewport\n//\n// inertiaThreshold   : the minimum horizontal mouse speed (in normalized coordinates per second)\n//                      that causes the zoom level to change by inertia after the LMB is released\n//\n// inertiaDamping     : determines how quickly the speed of the mouse moving by inertia decreases over time\n//                      (0 - speed remains constant; \n//                      the larger the absolute value, the faster the speed decreases)\nstruct ZoomOptions\n{\n    bool zoomOutToClampedUV; \n    float zoomBase;\n    float zoomMin;\n    float zoomMax;\n    float inertiaThreshold;\n    float inertiaDamping;\n};\n\nstruct ZoomData\n{\n    vec2 offset;\n    float scale;\n    float controlInputRate;\n    float controlInputPrev;\n};\n\n// CONSTANTS ///////////////////////////////////////////////////\nconst ZoomOptions DFLT_ZOOM_OPTIONS = ZoomOptions(true, 8.0, 1.0, exp2(20.0), 0.1, 0.5);\nconst ZoomData    INI_ZOOM_DATA = ZoomData(vec2(0,0), 1.0, 0.0, 0.0);\n\nconst ivec4 ZOOM_DATA_TEXELS = ivec4(0,0,0,1);\n\n// COMMON VARIABLES ///////////////////////////////////////////\nZoomOptions zoomOptions = DFLT_ZOOM_OPTIONS;\n\n// PURE FUNCTIONS ///////////////////////////////////////////\nvoid fetchZoomData(sampler2D buf, ivec4 dataTexels, inout ZoomData target)\n{\n    vec4 dataSet1 = texelFetch(buf, dataTexels.xy, 0);\n    vec4 dataSet2 = texelFetch(buf, dataTexels.zw, 0);\n    \n    target.offset = dataSet1.xy;\n    target.scale = dataSet1.z;\n    target.controlInputRate = dataSet1.w;\n    \n    target.controlInputPrev = dataSet2.x;\n}\n\nvoid writeZoomData(sampler2D buf, ivec4 dataTexels, ZoomData source, ivec2 fragTexel, inout vec4 fragColor)\n{\n    if (fragTexel == dataTexels.xy)\n    {\n        fragColor.xy = source.offset;\n        fragColor.z = source.scale;\n        fragColor.w = source.controlInputRate;\n    }\n    \n    if (fragTexel == dataTexels.zw)\n    {\n        fragColor.x = source.controlInputPrev;\n    }\n}\n\nvec2 zoomUV(ZoomData zData, vec2 uv)\n{\n    return uv * zData.scale + zData.offset;\n}\n\nvoid updateZoomData(inout ZoomData zData, ZoomOptions zOptions, vec4 mouseUV, float dt)\n{\n    vec2 scaleCenter = zoomUV(zData, abs(mouseUV.zw));\n    float scaleFactor = 1.0;\n    \n    if (mouseUV.z > 0.0)\n    {\n        float ciCurr = mouseUV.x - mouseUV.z;\n        float ciDelta = ciCurr - zData.controlInputPrev;\n        float ciRate = ciDelta / dt;\n        \n        scaleFactor = pow(zOptions.zoomBase, -ciDelta);\n        zData.controlInputRate = abs(ciRate) < zOptions.inertiaThreshold ? 0.0 : ciRate;\n        zData.controlInputPrev = ciCurr;\n    }\n    else\n    { \n        zData.controlInputRate *= max(0.0, 1.0 - abs(zOptions.inertiaDamping) * dt);\n        zData.controlInputPrev = 0.0;\n        scaleFactor = pow(zOptions.zoomBase, -zData.controlInputRate * dt);\n    }\n    \n    float sfMin = 1.0 / (zData.scale * zOptions.zoomMax);\n    float sfMax = 1.0 / (zData.scale * zOptions.zoomMin);\n    scaleFactor = clamp(scaleFactor, sfMin, sfMax);\n    \n    zData.scale *= scaleFactor;\n    zData.offset = (zData.offset - scaleCenter) * scaleFactor + scaleCenter;\n    \n    zData.offset = zOptions.zoomOutToClampedUV ? clamp(zData.offset, vec2(0,0), vec2(1.0 - zData.scale)) : zData.offset;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    // Buffer_A is used to store the contents of the ZoomData structure\n    // and thereby to convey the zoom state between frames;\n    ZoomData currentZoom;\n    \n    if (iFrame == 0)\n        currentZoom = INI_ZOOM_DATA;\n    else\n        fetchZoomData(iChannel0, ZOOM_DATA_TEXELS, currentZoom);\n    \n    updateZoomData(currentZoom, zoomOptions, iMouse/iResolution.xyxy, iTimeDelta);\n    \n    writeZoomData(iChannel0, ZOOM_DATA_TEXELS, currentZoom, ivec2(fragCoord), fragColor);\n}","name":"Buffer A","description":"","type":"buffer"}]}