{"ver":"0.1","info":{"id":"fttBWS","date":"1663601581","viewed":72,"name":"Voxel raymarching testaroo-throo","username":"PrenexNormalForm","description":"third voxel raymarching test, forked from the first","likes":1,"published":1,"flags":0,"usePreview":1,"tags":["raymarching","voxels"],"hasliked":0,"parentid":"slcfzf","parentname":"Voxel raymarching testaroo"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n    Returns the distance to the environment at the given position.\n    pos: the position\n*/\nfloat signedDistance(vec3 pos);\n\n/**\n    Defines the voxel grid.\n*/\nbool isVoxel(vec3 pos);\n\n//stub\nvec3 voxelColor(vec3 pos);\n\n/**\n    Converts the fragment coordinate to a normalized ray\n    in camera's local space (camera facing -z).\n    fov: the field of view in degrees\n    fragCoord: the fragCoord\n    returns a normalized ray\n*/\nvec3 fragCoordToRay(float fov, vec2 fragCoord);\n\n/**\n    Marches the ray from the start position until it intersects\n    the environment.\n    startPos: the position to start marching from\n    ray: the direction to march, normalized\n    returns vec3(the position of intersection, minimum distance to env)\n*/\nvec4 rayMarch(vec3 startPos, vec3 ray);\n\n/**\n    Determines the color the current fragment should be based on\n    the camera position and the result of this fragment's\n    raymarch.\n    marchPos.xyz: the position at raymarch completion\n    marchPos.w: the minimum distance to the scene during the raymarch\n    cameraPos: the camera position\n    returns fragment color (linear)\n*/\nvec3 shadeScene(vec4 marchPos, vec3 cameraPos);\nvec3 encodeSRGB(vec3 linearRGB);\n\n\nconst float MAX_DISTANCE = 100.0;\nconst int MAX_RAY_MARCHES = 1000;\nconst float NEARLY_ZERO = 0.001;\nconst vec3 SUN_RAY = normalize(vec3(0.5, 1.0, 0.65));\n\n//helpers for signedDistance\nfloat lenSq(vec3 vec) {return dot(vec,vec);}\nfloat lenSq(vec2 vec) {return dot(vec,vec);}\nfloat lenSq(float vec) {return vec*vec;}\n\nfloat signedDistance(vec3 pos)\n{\n    //todo: make not slow\n    //9 voxels same z coord adjacent\n    vec3 up = pos + vec3(0.0, 1.0, 0.0);\n    vec3 down = pos + vec3(0.0, -1.0, 0.0);\n    vec3 left = pos + vec3(-1.0, 0.0, 0.0);\n    vec3 right = pos + vec3(1.0, 0.0, 0.0);\n    vec3 upleft = pos + vec3(-1.0, 1.0, 0.0);\n    vec3 upright = pos + vec3(1.0, 1.0, 0.0);\n    vec3 downright = pos + vec3(1.0, -1.0, 0.0);\n    vec3 downleft = pos + vec3(-1.0, -1.0, 0.0);\n    bool isVox = isVoxel(pos);\n    //9 voxels forwards adjacent\n    vec3 fup = pos + vec3(0.0, 1.0, 1.0);\n    vec3 fdown = pos + vec3(0.0, -1.0, 1.0);\n    vec3 fleft = pos + vec3(-1.0, 0.0, 1.0);\n    vec3 fright = pos + vec3(1.0, 0.0, 1.0);\n    vec3 fupleft = pos + vec3(-1.0, 1.0, 1.0);\n    vec3 fupright = pos + vec3(1.0, 1.0, 1.0);\n    vec3 fdownright = pos + vec3(1.0, -1.0, 1.0);\n    vec3 fdownleft = pos + vec3(-1.0, -1.0, 1.0);\n    vec3 forward = pos + vec3(0, 0, 1.0);\n    //9 voxels backwards adjacent\n    vec3 bup = pos + vec3(0.0, 1.0, -1.0);\n    vec3 bdown = pos + vec3(0.0, -1.0, -1.0);\n    vec3 bleft = pos + vec3(-1.0, 0.0, -1.0);\n    vec3 bright = pos + vec3(1.0, 0.0, -1.0);\n    vec3 bupleft = pos + vec3(-1.0, 1.0, -1.0);\n    vec3 bupright = pos + vec3(1.0, 1.0, -1.0);\n    vec3 bdownright = pos + vec3(1.0, -1.0, -1.0);\n    vec3 bdownleft = pos + vec3(-1.0, -1.0, -1.0);\n    vec3 backward = pos + vec3(0, 0, -1.0);\n    //boundaries\n    float upb = float(isVox ^^ isVoxel(up));\n    float downb = float(isVox ^^ isVoxel(down));\n    float leftb = float(isVox ^^ isVoxel(left));\n    float rightb = float(isVox ^^ isVoxel(right));\n    float upleftb = float(isVox ^^ isVoxel(upleft));\n    float uprightb = float(isVox ^^ isVoxel(upright));\n    float downrightb = float(isVox ^^ isVoxel(downright));\n    float downleftb = float(isVox ^^ isVoxel(downleft));\n    //forwards boundaries\n    float fupb = float(isVox ^^ isVoxel(fup));\n    float fdownb = float(isVox ^^ isVoxel(fdown));\n    float fleftb = float(isVox ^^ isVoxel(fleft));\n    float frightb = float(isVox ^^ isVoxel(fright));\n    float fupleftb = float(isVox ^^ isVoxel(fupleft));\n    float fuprightb = float(isVox ^^ isVoxel(fupright));\n    float fdownrightb = float(isVox ^^ isVoxel(fdownright));\n    float fdownleftb = float(isVox ^^ isVoxel(fdownleft));\n    float forwardb = float(isVox ^^ isVoxel(forward));\n    //backwards boundaries\n    float bupb = float(isVox ^^ isVoxel(bup));\n    float bdownb = float(isVox ^^ isVoxel(bdown));\n    float bleftb = float(isVox ^^ isVoxel(bleft));\n    float brightb = float(isVox ^^ isVoxel(bright));\n    float bupleftb = float(isVox ^^ isVoxel(bupleft));\n    float buprightb = float(isVox ^^ isVoxel(bupright));\n    float bdownrightb = float(isVox ^^ isVoxel(bdownright));\n    float bdownleftb = float(isVox ^^ isVoxel(bdownleft));\n    float backwardb = float(isVox ^^ isVoxel(backward));\n    \n    float dist = 1.0 - upb + upb * lenSq(1.0 - mod(pos.y, 1.0));\n    dist = min(dist, 1.0 - downb + downb * lenSq(mod(pos.y, 1.0)));\n    dist = min(dist, 1.0 - leftb + leftb * lenSq(mod(pos.x, 1.0)));\n    dist = min(dist, 1.0 - rightb + rightb * lenSq(1.0 - mod(pos.x, 1.0)));\n    dist = min(dist, 1.0 - upleftb + upleftb * lenSq(vec2(0.0, 1.0) - mod(pos.xy, 1.0)));\n    dist = min(dist, 1.0 - uprightb + uprightb * lenSq(vec2(1.0) - mod(pos.xy, 1.0)));\n    dist = min(dist, 1.0 - downrightb + downrightb * lenSq(vec2(1.0, 0.0) - mod(pos.xy, 1.0)));\n    dist = min(dist, 1.0 - downleftb + downleftb * lenSq(mod(pos.xy, 1.0)));\n    //9 voxels forward adjacent\n    dist = min(dist, 1.0 - fupb + fupb * lenSq(vec2(1.0,1.0) - mod(pos.yz, 1.0)));\n    dist = min(dist, 1.0 - fdownb + fdownb * lenSq(vec2(0.0,1.0) - mod(pos.yz, 1.0)));\n    dist = min(dist, 1.0 - fleftb + fleftb * lenSq(vec2(0.0,1.0) - mod(pos.xz, 1.0)));\n    dist = min(dist, 1.0 - frightb + frightb * lenSq(vec2(1.0,1.0) - mod(pos.xz, 1.0)));\n    dist = min(dist, 1.0 - fupleftb + fupleftb * lenSq(vec3(0.0,1.0,1.0) - mod(pos, 1.0)));\n    dist = min(dist, 1.0 - fuprightb + fuprightb * lenSq(vec3(1.0,1.0,1.0) - mod(pos, 1.0)));\n    dist = min(dist, 1.0 - fdownrightb + fdownrightb * lenSq(vec3(1.0,0.0,1.0) - mod(pos, 1.0)));\n    dist = min(dist, 1.0 - fdownleftb + fdownleftb * lenSq(vec3(0.0,0.0,1.0) - mod(pos, 1.0)));\n    dist = min(dist, 1.0 - forwardb + forwardb * lenSq(1.0 - mod(pos.z, 1.0)));\n    //9 voxels backward adjacent\n    dist = min(dist, 1.0 - bupb + bupb * lenSq(vec2(1.0,0.0) - mod(pos.yz, 1.0)));\n    dist = min(dist, 1.0 - bdownb + bdownb * lenSq(vec2(0.0,0.0) - mod(pos.yz, 1.0)));\n    dist = min(dist, 1.0 - bleftb + bleftb * lenSq(vec2(0.0,0.0) - mod(pos.xz, 1.0)));\n    dist = min(dist, 1.0 - brightb + brightb * lenSq(vec2(1.0,0.0) - mod(pos.xz, 1.0)));\n    dist = min(dist, 1.0 - bupleftb + bupleftb * lenSq(vec3(0.0,1.0,0.0) - mod(pos, 1.0)));\n    dist = min(dist, 1.0 - buprightb + buprightb * lenSq(vec3(1.0,1.0,0.0) - mod(pos, 1.0)));\n    dist = min(dist, 1.0 - bdownrightb + bdownrightb * lenSq(vec3(1.0,0.0,0.0) - mod(pos, 1.0)));\n    dist = min(dist, 1.0 - bdownleftb + bdownleftb * lenSq(vec3(0.0,0.0,0.0) - mod(pos, 1.0)));\n    dist = min(dist, 1.0 - backwardb + backwardb * lenSq(mod(pos.z, 1.0)));\n    \n    dist = sqrt(dist);\n    //negative if within voxel\n    dist *= 1.0 - 2.0 * float(isVox);\n    \n    //sphere as control\n    dist = min(dist, length(vec3(sin(iTime),0,-5) - pos) - 0.5);\n    return dist;\n}\n\n// rand function https://www.shadertoy.com/view/Xt23Ry\nfloat rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\nfloat rand(vec3 co){ return rand(co.xy+rand(co.z)); }\n\n\nbool isVoxel(vec3 pos)\n{\n    bool voxel = false;\n    //every other voxel in xy=0,0 is filled\n    voxel = voxel || floor(pos.xy) == vec2(0.) && mod(floor(pos.z), 2.) == 0.;\n    //every other voxel in xy=1,1 is filled\n    voxel = voxel || floor(pos.xy) == vec2(1.) && mod(floor(pos.z), 2.) == 1.;\n    //grid of every 5 spaces\n    voxel = voxel || floor(pos.z) == -7. && mod(floor(pos.x),5.) == 3. && mod(floor(pos.y),5.) == 4.;\n    //column of random voxels\n    voxel = voxel || pos.x < -2. && pos.x >= -7. && pos.z < -9. && pos.z >= -14. && rand(floor(pos) + vec3(floor(iTime))) < 0.2; \n    return voxel;\n}\n\nvec3 fragCoordToRay(float fov, vec2 fragCoord)\n{\n    float halfFOV = radians(fov) / 2.0;\n    float viewPlaneScale = tan(halfFOV);\n    vec2 centeredFragCoord = fragCoord - iResolution.xy * 0.5;\n    vec2 viewPlaneCoord = centeredFragCoord / iResolution.xx * 2.0;\n    vec3 ray = vec3(viewPlaneCoord * viewPlaneScale, -1.0);\n    return normalize(ray);\n}\n\nvec4 rayMarch(vec3 startPos, vec3 ray)\n{\n    vec3 pos = startPos;\n    float minDist = MAX_DISTANCE;\n    for (int i = 0; i < MAX_RAY_MARCHES; i++)\n    {\n        float dist = signedDistance(pos);\n        minDist = min(minDist, dist);\n        if (dist < NEARLY_ZERO || length(pos - startPos) > MAX_DISTANCE)\n        {break;}\n        pos += ray * dist;\n    }\n    return vec4(pos, minDist);\n}\n\nvec3 shadeScene(vec4 march, vec3 cameraPos)\n{\n    vec3 color = vec3(0.9, 0.25, 0.6);\n    if (march.w < NEARLY_ZERO)\n    {\n        vec3 normal = normalize(vec3(\n            signedDistance(march.xyz + vec3(0.001,0,0)) - signedDistance(march.xyz + vec3(-0.001,0,0)),\n            signedDistance(march.xyz + vec3(0,0.001,0)) - signedDistance(march.xyz + vec3(0,-0.001,0)),\n            signedDistance(march.xyz + vec3(0,0,0.001)) - signedDistance(march.xyz + vec3(0,0,-0.001))\n        ));\n        float light = max(0., dot(normal, SUN_RAY)) * 1. + 0.4;\n        color = light * color;\n    }\n    else\n    {\n        //sky color\n        color = vec3(0.2, 0.5, 0.8);\n        color = vec3(color.xy + 0.2*vec2(pow(exp(-march.w*march.w),2.0)), color.z);\n    }\n    return color;\n}\n\n//from https://www.shadertoy.com/view/lscSzl\nvec3 encodeSRGB(vec3 linearRGB)\n{\n    vec3 a = 12.92 * linearRGB;\n    vec3 b = 1.055 * pow(linearRGB, vec3(1.0 / 2.4)) - 0.055;\n    vec3 c = step(vec3(0.0031308), linearRGB);\n    return mix(a, b, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cameraPos = vec3(0.5) + 3.*vec3(cos(0.2 * iTime), sin(0.2 * iTime), 0);\n    vec3 ray = fragCoordToRay(80.0, fragCoord);\n    vec4 march = rayMarch(cameraPos, ray);\n    vec3 col = shadeScene(march, cameraPos);\n\n    // Output to screen\n    fragColor = vec4(encodeSRGB(col),1.0);\n}\n\n\n","name":"Image","description":"","type":"image"}]}