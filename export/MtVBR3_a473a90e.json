{"ver":"0.1","info":{"id":"MtVBR3","date":"1544760312","viewed":184,"name":"CS1230 - Lab 10","username":"dylleealt","description":"shadertoy lab","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarcher"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NO_INTERSECT 0\n#define SPHERE 1\n#define PLANE 2\n#define TERRAIN 3\n#define HILLS 4\n#define DISPLACEMENT_FACTOR 0.1\n\n#define MOD2 vec2(3.07965, 7.4235)\n\n// Data structure for raymarching results\nstruct PrimitiveDist {\n    float dist;\n    int primitive; // Can be SPHERE, PLANE, or NO_INTERSECT\n};\n    \n//--------------------------------------------------------------------------\n// Noise functions\n\nfloat Hash( float n ) { return fract(sin(n)*43758.5453123); }\n\nfloat Hash(vec2 p)\n{\n\tp  = fract(p / MOD2);\n    p += dot(p.xy, p.yx+19.19);\n    return fract(p.x * p.y);\n}\n//--------------------------------------------------------------------------\nfloat Noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0;\n    float res = mix(mix( Hash(n+  0.0), Hash(n+  1.0),f.x),\n                    mix( Hash(n+ 57.0), Hash(n+ 58.0),f.x),f.y);\n    return res;\n}\n\nfloat FractalNoise(in vec2 xy)\n{\n\tfloat w = .7;\n\tfloat f = 0.0;\n\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tf += Noise(xy) * w;\n\t\tw = w*0.6;\n\t\txy = 2.0 * xy;\n\t}\n\treturn f;\n}\n\nvec2 Voronoi( in vec2 x )\n{\n\tvec2 p = floor( x );\n\tvec2 f = fract( x );\n\tfloat res=100.0,id;\n\tfor( int j=-1; j<=1; j++ )\n\tfor( int i=-1; i<=1; i++ )\n\t{\n\t\tvec2 b = vec2( float(i), float(j) );\n\t\tvec2 r = vec2( b ) - f  + Hash( p + b );\n\t\tfloat d = dot(r,r);\n\t\tif( d < res )\n\t\t{\n\t\t\tres = d;\n\t\t\tid  = Hash(p+b);\n\t\t}\t\t\t\n    }\n\treturn vec2(max(.4-sqrt(res), 0.0),id);\n}\n\n//--------------------------------------------------------------------------\nfloat Linstep(float a, float b, float t)\n{\n\treturn clamp((t-a)/(b-a),0.,1.);\n}\n\nfloat heightMap( in vec2 p)\n{\n\tvec2 pos = p*0.003;\n\tfloat w = 60.0;\n\tfloat f = .0;\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tf += Noise(pos) * w;\n\t\tw = w * 0.62;\n\t\tpos *= 2.5;\n\t}\n\n\treturn f;\n}\n\nvec3 DE(vec3 p)\n{\n\tfloat base = heightMap(p.xz) - 1.9;\n\tfloat height = Noise(p.xz*2.0)*.7 + Noise(p.xz)*.15 + Noise(p.xz*.5)*.001;\n\t//p.y += height;\n\tfloat y = p.y - base - height;\n\ty = y*y;\n\tvec2 ret = Voronoi((p.xz*2.5+sin(y*0.4+p.zx*0.3)*.12+vec2(sin(2.3+0.1*p.z),sin(3.6+0.1*p.x))*y*.5));\n\tfloat f = ret.x * .6 + y * .58;\n\treturn vec3( y - f*1.4, clamp(f * 1.5, 0.0, 1.0), ret.y);\n}\n\nfloat CircleOfConfusion(float t)\n{\n\treturn max(t * .04, (2.0 / iResolution.y) * (1.0+t));\n}\n\nvec3 GrassBlades(in vec3 rO, in vec3 rD, in vec3 mat, in float dist)\n{\n\tfloat d = 0.0;\n\t// Only calculate cCoC once is enough here...\n\tfloat rCoC = CircleOfConfusion(dist*2.3);\n\tfloat alpha = 0.0;\n\t\n\tvec4 col = vec4(mat*0.15, 0.0);\n\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tif (col.w > .99) break;\n\t\tvec3 p = rO + rD * d;\n\t\t\n\t\tvec3 ret = DE(p);\n\t\tret.x += .5 * rCoC;\n\n\t\tif (ret.x < rCoC)\n\t\t{\n\t\t\talpha = (1.0 - col.y) * Linstep(-rCoC, rCoC, -ret.x);//calculate the mix like cloud density\n\t\t\t// Mix material with white tips for grass...\n\t\t\tvec3 gra = mix(mat, vec3(.35, .35, min(pow(ret.z, 4.0)*35.0, .35)), pow(ret.y, 9.0)*.7) * ret.y;\n\t\t\tcol += vec4(gra * alpha, alpha);\n\t\t}\n\t\td += max(ret.x * .7, .1);\n\t}\n\tif(col.w < .2)\n\t\tcol.xyz = vec3(0.1, .19, 0.05);\n\treturn col.xyz;\n}\n\nvec3 TerrainColour(vec3 pos, vec3 dir,  vec3 normal, float dis)\n{\n    // Random colour...\n    vec3 mat = mix(vec3(.0,.3,.0), vec3(.2,.3,.0), Noise(pos.xz*.25));\n    // Random shadows...\n    float t = FractalNoise(pos.xz * .1)+.5;\n    // Do grass blade tracing...\n    mat = GrassBlades(pos, dir, mat, dis) * t;\n\treturn mat;\n}\n\n//--------------------------------------------------------------------------\nPrimitiveDist sdHills(in vec3 p, in float scale)\n{\n\tfloat h = heightMap(p.xz * scale) / scale - 24.0 / scale;\n    return PrimitiveDist(p.y - h, HILLS);\n}\n\nPrimitiveDist sdTerrain(in vec3 p, in float scale)\n{\n\tfloat h = max(heightMap(p.xz * scale) / scale - 50.0 / scale, 0.0);\n    return PrimitiveDist(p.y - h, TERRAIN);\n}\n\n\nfloat v31(vec3 a)\n{\n    return a.x + a.y * 37.0 + a.z * 521.0;\n}\nfloat v21(vec2 a)\n{\n    return a.x + a.y * 37.0;\n}\nfloat Hash11(float a)\n{\n    return fract(sin(a)*10403.9);\n}\nfloat Hash21(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\nvec2 Hash22(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(cos(f)*vec2(10003.579, 37049.7));\n}\nvec2 Hash12(float f)\n{\n    return fract(cos(f)*vec2(10003.579, 37049.7));\n}\nfloat Hash1d(float u)\n{\n    return fract(sin(u)*143.9);\t// scale this down to kill the jitters\n}\nfloat Hash2d(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\nfloat Hash3d(vec3 uv)\n{\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\n    return fract(sin(f)*110003.9);\n}\n\n// helper functions\n\n// k should be negative. -4.0 works nicely.\n// smooth blending function\nfloat smin( float a, float b, float k ) { return -log(exp(-k*a)+exp(-k*b))/k; }\nfloat smin2( float a, float b, float k ) { return -log(exp2(-k*a)+exp2(-k*b))/k; }\n                                         \nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\nvec2 cmpDist(vec2 a, vec2 b){\n \treturn (a.x < b.y) ? a : b; \n}\n// Helper function for tri3.\nfloat tri(in float x) {\n\treturn abs(fract(x)-.5);\n}\n\n// Triangle noise. Use it as a sample displacement map for task 7.\nvec3 tri3(in vec3 p) {\n    return vec3(tri(p.z+tri(p.y*1.)), \n                tri(p.z+tri(p.x*1.)), \n                tri(p.y+tri(p.x*1.)));\n}\n\n// TODO [Task 8] Make a displacement map\n// You can check out tri3 above and the functions in the handout as inspiration\nfloat calcDisplacement(in vec3 p) {\n   // p = tri3(p);\n   return pow(sin(p.x * p.y), 2.0);\n}\n\n// TODO [Task 6] Implement triplanar texture mapping\n// If you want, you can play around with the textures in iChannels 0 and 1\n// The textures should show no distortion\nvec3 texCube( sampler2D sam, in vec3 p, in vec3 n )\n{\n    vec4 x = texture(sam, p.yz * abs(n.x));\n    vec4 y = texture(sam, p.xz * abs(n.y));\n    vec4 z = texture(sam, p.xy * abs(n.z));\n    vec4 texColor = x + y + z; \n    return texColor.xyz;\n}\n\nfloat sdBox(vec3 p, vec3 radius)\n{\n  vec3 dist = abs(p) - radius;\n  return min(max(dist.x, max(dist.y, dist.z)), 0.0) + length(max(dist, 0.0));\n}\n\nfloat mapCar(in vec3 p0){ \n\tvec3 p=p0+vec3(0.0,1.24,0.0);\n\tfloat r=length(p.yz);\n\tfloat d= length(max(vec3(abs(p.x)-0.35,r-1.92,-p.y+1.4),0.0))-0.05;\n\td=max(d,p.z-1.0);\n\tp=p0+vec3(0.0,-0.22,0.39);\n\tp.xz=abs(p.xz)-vec2(0.5300,0.9600);p.x=abs(p.x);\n\tr=length(p.yz);\n\td=smin(d,length(max(vec3(p.x-0.08,r-0.25,-p.y-0.08),0.0))-0.04,8.0);\n\td=max(d,-max(p.x-0.165,r-0.24));\n\tfloat d2=length(vec2(max(p.x-0.13,0.0),r-0.2))-0.02;\n\td=min(d,d2);\n\n\treturn d;\n}\n\n// Signed distance to the twisted sphere.\nfloat sdTwistedSphere(vec3 p) {\n    p = 2.0 * vec3(fract(p.x), p.y, fract(p.z)) - 1.0;\n    vec3 spherePosition = vec3(0.0, 0.25, 0.0);\n    float radius = 1.0;\n    float primitive = length(p - spherePosition) - radius;\n    return primitive + calcDisplacement(p);\n}\n\nfloat sdSphere(vec3 p, float r){\n    return length(p) - r;\n}\n\nfloat sdCylinder(vec3 p, vec2 h)\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdFloor(vec3 p) {\n    return p.y;\n}\n\nPrimitiveDist map(vec3 p) {\n    // TODO [Task 3] Implement distance map\n    float inCity = sdCylinder(vec3(floor(p.x), p.y, floor(p.z)), vec2(32.0, 10000.0));\n    if (inCity < 0.01){\n        float planeDist = sdFloor(p); \n        // city buildings\n        float buildingDist = sdCylinder(vec3(floor(p.x), p.y, floor(p.z)) - vec3(0.0, 0.0, 0.0), vec2(7.6, 10000.0));\n        // inside park\n        if (buildingDist < 0.1){\n            PrimitiveDist terrainDist = sdTerrain(p, 98.0);\n//            vec2 block = floor(p.xz);\n//            p.xz = fract(p.xz);\n//            if (Hash21(block) < 0.15){\n//                float treeDist = sdBox(p - vec3(0.0, terrainDist.dist, 0.0), vec3(0.25));//\n//                if (treeDist < terrainDist.dist){\n//                    return PrimitiveDist(treeDist, TERRAIN);\n//                }\n//            }\n            return terrainDist;\n        } else {\n            // outside park\n            vec2 block = floor(p.xz);\n            p.xz = fract(p.xz);\n            vec4 rand;\n            rand.xy = Hash22(block);\n            rand.zw = Hash22(rand.xy);\n            float baseRad = 0.5 + 2.0 / length(block.xy);\n            float height = rand.w*rand.z + 0.1;\n            float downtown = saturate(4.0 / length(block.xy + vec2(8.8, 7.0)));\n            height *= downtown;\n            height *= 1.5+(baseRad-0.15)*20.0;\n            buildingDist = sdBox(p, vec3(baseRad, height, baseRad));     \n        }\n        // float sphereDist = mapCar(p);\n        if (planeDist < buildingDist){\n           return PrimitiveDist(planeDist, PLANE);\n        } \n        return PrimitiveDist(buildingDist, SPHERE);\n    }\n    return sdHills(p, 2.4);\n}\n\n// TODO [Task 4] Calculate surface normals\nconst float epsilon = 0.001;\nvec2 e = vec2(epsilon, 0.0); // For swizzling\nvec3 calcNormal(vec3 p) {\n    float dx = map(p + e.xyy).dist - map(p - e.xyy).dist;\n    float dy = map(p + e.yxy).dist - map(p - e.yxy).dist;\n    float dz = map(p + e.yyx).dist - map(p - e.yyx).dist;\n    \n    return normalize(vec3(dx,dy,dz));\n}\n\nfloat shadow(vec3 ro, vec3 rd, float k) {\n    float marchDist = 0.01;\n    float boundingVolume = 25.0;\n    float darkness = 1.0;\n    float threshold = 0.001;\n    float hprev = 1e20;\n    \n    for(int i = 0; i < 100; i++) {\n        if(marchDist > boundingVolume) continue;\n        float h = map(ro + rd * marchDist).dist;\n        // TODO [Task 7] Modify the loop to implement soft shadows\n        if (h < threshold) {\n\t\t\treturn 0.0;\n        }\n        float y = h * h / (2.0 * hprev);\n\t\tfloat d = sqrt(h * h / y * y);\n        darkness = min(darkness, k * d / max(0.0, marchDist - y));\n        hprev = h;\n        marchDist += 0.2 * h;\n    }\n    \n    return darkness;\n}\n\n\nPrimitiveDist raymarch(vec3 ro, vec3 rd) {\n    \n    // TODO [Task 2] Implement ray marching algorithm\n    // Fill in parameters\n    float marchDist = 0.001;\n    float boundingDist = 450.0;\n    float threshold = 0.0001;\n    \n    int maxIterations = 1000;\n    vec3 p = ro;\n    // Fill in the iteration count\n    for (int i = 0; i < maxIterations; i++) {\n        PrimitiveDist intersect = map(p);\n        if (intersect.dist < threshold){\n            return PrimitiveDist(marchDist, intersect.primitive);\n        }\n\t\tmarchDist += 0.1 * intersect.dist;\n        if (marchDist > boundingDist){\n         \tbreak;\n        }\n        p = ro + marchDist * rd;\n    }\n    \n    return PrimitiveDist(-1.0, NO_INTERSECT);\n}\n\nvec3 renderReflect(vec3 ro, vec3 rd, float t, int which) {\n    \n    // Col is the final color of the current pixel.\n    vec3 col = vec3(0.);\n    vec3 pos = ro + rd * t;\n    // Light vector\n    vec3 lig = normalize(vec3(1.0,0.6,0.5));\n    \n    // Normal vector\n    vec3 nor = calcNormal(pos);\n    \n    // Ambient\n    float ambient = 0.3;\n    // Diffuse\n    float diffuse = clamp(dot(nor, lig), 0.0, 1.0);\n    // Specular\n    float shineness = 32.0; \n    float specular = pow(clamp(dot(rd, reflect(lig, nor)), 0.0, 1.0), 32.0);\n    \n    float darkness = shadow(pos, lig, 8.0);\n    // Applying the phong lighting model to the pixel.\n    col += vec3(((ambient + diffuse + specular) * darkness));\n    \n    // TODO [Task 5] Assign different intersected objects with different materials\n    // Make things pretty!\n    vec3 material = vec3(0.0);\n    if (which == PLANE) {\n        material = texCube(iChannel0, pos, nor);\n    } else if (which == SPHERE) {\n        material = texCube(iChannel1, pos, nor);\n    } else if (which == TERRAIN) {\n     \tmaterial = vec3(0.1, 0.85, 0.3);\n    } else if (which == HILLS) {\n     \tmaterial = texCube(iChannel2, pos, nor);\n    } else {\n        material = vec3(0.5);\n    }\n    \n    // Blend the material color with the original color.\n    col = mix(col, material, 0.4);\n    \n    return col;\n}\n\nvec3 render(vec3 ro, vec3 rd, float t, int which) {\n    \n    // Col is the final color of the current pixel.\n    vec3 col = vec3(0.);\n    vec3 pos = ro + rd * t;\n    // Light vector\n    vec3 lig = normalize(vec3(1.0,0.6,0.5));\n    \n    // Normal vector\n    vec3 nor = calcNormal(pos);\n    \n    // Ambient\n    float ambient = 0.3;\n    // Diffuse\n    float diffuse = clamp(dot(nor, lig), 0.0, 1.0);\n    // Specular\n    float shineness = 32.0; \n    float specular = pow(clamp(dot(rd, reflect(lig, nor)), 0.0, 1.0), 32.0);\n    \n    float darkness = shadow(pos, lig, 8.0);\n    // Applying the phong lighting model to the pixel.\n    col += vec3(((ambient + diffuse + specular) * darkness));\n    \n    // TODO [Task 5] Assign different intersected objects with different materials\n    // Make things pretty!\n    vec3 material = vec3(0.0);\n    if (which == PLANE) {\n        material = texCube(iChannel0, pos, nor);\n    } else if (which == SPHERE) {\n        material = texCube(iChannel1, pos, nor);\n    } else if (which == TERRAIN) {\n     \tmaterial = TerrainColour(2.0 * pos, rd, nor, t);\n        return min(vec3(1.0), (diffuse + 0.3) * material);\n    } else if (which == HILLS) {\n     \tmaterial = texCube(iChannel2, pos, nor);\n    } else {\n        material = vec3(0.5);\n    }\n    \n    // Blend the material color with the original color.\n    col = mix(col, material, 0.4);\n\t\n//    if (which == TERRAIN){\n//        vec3 intersect = pos += 0.001 * nor;\n//       \tvec3 reflectRay = reflect(rd, nor);\n//        PrimitiveDist res = raymarch(intersect, reflectRay);\n//        vec3 reflectCol = renderReflect(intersect, reflectRay, res.dist, res.primitive);\n//        return mix(col, reflectCol, 0.6);\n//    }\n    \n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n   \n    vec3 rayOrigin = vec3(16.0 * sin(iTime * .3), 8.0, 16.0 * cos(iTime * .3));\n    \n    float focalLength = 2.0;\n    \n    // The target we are looking at\n    vec3 target = vec3(0.0);\n    // Look vector\n    vec3 look = normalize(rayOrigin - target);\n    // Up vector\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    \n    // Set up camera matrix\n    vec3 cameraForward = -look;\n    vec3 cameraRight = normalize(cross(cameraForward, up));\n    vec3 cameraUp = normalize(cross(cameraRight, cameraForward)); \n  \n    // TODO [Task 1] Construct the ray direction vector\n    // set up UV coordinates in image space\n    vec2 uv = 2.0 * fragCoord / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    // set up ray\n    vec3 rayDirection = vec3(uv, focalLength);\n    // transform to world space\n    rayDirection = normalize(cameraRight * rayDirection.x + cameraUp * rayDirection.y + cameraForward * rayDirection.z);\n      \n    PrimitiveDist rayMarchResult = raymarch(rayOrigin, rayDirection);\n    vec3 col = vec3(0.0);\n    if (rayMarchResult.primitive != NO_INTERSECT) {\n      col = render(rayOrigin, rayDirection, rayMarchResult.dist, rayMarchResult.primitive);\n    }\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}