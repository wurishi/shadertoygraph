{"ver":"0.1","info":{"id":"4XXGWn","date":"1707930627","viewed":93,"name":"Explore The Meat Cavern!","username":"FNIX","description":"WASD - move\nArrow Keys - look\nC/Space - down/up\n\nDiscord is fnixco if you have any questions.","likes":2,"published":1,"flags":48,"usePreview":1,"tags":["raycasting","voxel","proceduralgeneration"],"hasliked":0,"parentid":"X3l3R8","parentname":"Raycasting!"},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct hitInfo {\n    vec3 pos;\n    vec3 normal;\n    vec2 uv;\n    bool hit;\n    float dist;\n};\n\nbool detect_hit(in vec3 pos) {\n    pos /= 2.;\n    float z = (cos(pos.x)+sin(pos.z))/2.;\n    z += (cos(pos.x*2.+sin(iTime*2.)*4.*cos(pos.z*2.))+sin(pos.z*2.))/4.;\n    z *= 4.; z -= 4.;\n    \n    if(-z-1. < pos.y || pos.y < z) {return true;}\n    \n    return false;\n}\n\nbool detect_hit_2(in vec3 pos) {\n    // Mod pos\n    pos *= 5.; vec3 mpos = pos-floor(pos); pos /= 5.;\n    \n    if(length(mpos-pos) < 24.) {return true;}\n    \n    return false;\n}\n\nvoid rotate_vec3(inout vec3 p, in vec3 r) {\n    vec3 n = p;\n    // Rotate X\n    n.y = cos(r.x)*p.y - sin(r.x)*p.z;\n    n.z = sin(r.x)*p.y + cos(r.x)*p.z;\n    p = n;\n    // Rotate Y\n    n.x = cos(r.y)*p.x + sin(r.y)*p.z;\n    n.z = -sin(r.y)*p.x + cos(r.y)*p.z;\n    p = n;\n    // Rotate Z\n    n.x = cos(r.z)*p.x - sin(r.z)*p.y;\n    n.y = sin(r.z)*p.x + cos(r.z)*p.y;\n    p = n;\n}\n\n\nhitInfo cast_ray(in vec3 rayPos, in vec3 rayVel) {\n    hitInfo result;\n    \n    \n    result.dist = 1024.;\n    result.normal = vec3(0.);\n    vec3 thisNormal = result.normal;\n    result.pos = rayPos;\n    \n    for(int t = 0; t < 3; t++) {\n        vec3 rayPos2 = rayPos;\n        vec3 rayVel2 = rayVel;\n        float rayLength = 0.;\n        \n        if(t == 0) {\n            // Snap to x plane\n            if(rayVel2.x == 0.) {continue;}\n            rayVel2 /= abs(rayVel2.x);\n            thisNormal = vec3(1.,0.,0.);\n            if(rayVel2.x < 0.) {\n                thisNormal.x = -1.;\n                rayPos2.x = floor(rayPos2.x);\n                rayPos2.yz += rayVel2.yz*(rayPos.x-rayPos2.x);\n            }\n            else {\n                rayPos2.x = ceil(rayPos2.x);\n                rayPos2.yz -= rayVel2.yz*(rayPos.x-rayPos2.x);\n            }\n            rayLength += length(rayPos2-rayPos);\n        }\n        else if(t == 1) {\n            // Snap to y plane\n            if(rayVel2.y == 0.) {continue;}\n            rayVel2 /= abs(rayVel2.y);\n            thisNormal = vec3(0.,1.,0.);\n            if(rayVel2.y < 0.) {\n                thisNormal.y = -1.;\n                rayPos2.y = floor(rayPos2.y);\n                rayPos2.xz += rayVel2.xz*(rayPos.y-rayPos2.y);\n            }\n            else {\n                rayPos2.y = ceil(rayPos2.y);\n                rayPos2.xz -= rayVel2.xz*(rayPos.y-rayPos2.y);\n            }\n            rayLength += length(rayPos2-rayPos);\n        }\n        else {\n            // Snap to z plane\n            if(rayVel2.z == 0.) {continue;}\n            rayVel2 /= abs(rayVel2.z);\n            thisNormal = vec3(0.,0.,1.);\n            if(rayVel2.z < 0.) {\n                thisNormal.z = -1.;\n                rayPos2.z = floor(rayPos2.z);\n                rayPos2.xy += rayVel2.xy*(rayPos.z-rayPos2.z);\n            }\n            else {\n                rayPos2.z = ceil(rayPos2.z);\n                rayPos2.xy -= rayVel2.xy*(rayPos.z-rayPos2.z);\n            }\n            rayLength += length(rayPos2-rayPos);\n        }\n        \n        bool hit = false;\n        float rayInc = length(rayVel2);\n        \n        for(int i = 0; i < 30; i++) {\n            vec3 blockOn = floor(rayPos2+thisNormal/2.);\n            if(detect_hit(blockOn) == true && detect_hit_2(blockOn) == false) {break;}\n            rayLength += rayInc;\n            rayPos2 += rayVel2;\n        }\n        \n        if(rayLength < result.dist) {\n            result.dist = rayLength;\n            result.normal = thisNormal;\n            result.pos = rayPos2;\n        }\n    }\n    \n    if(result.normal.x != 0.) {result.uv = result.pos.yz;}\n    if(result.normal.y != 0.) {result.uv = result.pos.xz;}\n    if(result.normal.z != 0.) {result.uv = result.pos.xy;}\n    \n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5; uv *= 2.; uv.x /= iResolution.y/iResolution.x;\n    vec3 col;\n    \n    vec3 playerPos = texelFetch(iChannel1,ivec2(0,0),0).xyz;\n    vec3 playerRot = texelFetch(iChannel1,ivec2(1,0),0).xyz;\n    \n    vec3 rV = vec3(uv,1.);\n    rotate_vec3(rV,playerRot);\n    hitInfo info = cast_ray(playerPos,rV);\n    \n\n    // Output to screen\n    float fogValue = clamp(info.dist/30.,0.,1.);\n    col = texture(iChannel0,info.uv).xyz;\n    //col = info.normal;\n    col = abs(col)*(1.-fogValue)+fogValue*vec3(0.,0.,0.);\n    fragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy; vec3 col;\n    vec3 pos = texelFetch(iChannel1,ivec2(0.),0).xyz;\n    vec3 rot = texelFetch(iChannel1,ivec2(1.,0.),0).xyz;\n    \n    if(floor(fragCoord) == vec2(0.)) {\n        // Forward\n        if(texelFetch(iChannel0,ivec2(87,0),0).x > 0.) {\n            pos.x += sin(rot.y) * .1;\n            pos.z += cos(rot.y) * .1;\n        }\n        // Backward\n        if(texelFetch(iChannel0,ivec2(83,0),0).x > 0.) {\n            pos.x -= sin(rot.y) * .1;\n            pos.z -= cos(rot.y) * .1;\n        }\n        // Left\n        if(texelFetch(iChannel0,ivec2(65,0),0).x > 0.) {\n            pos.x -= cos(rot.y) * .1;\n            pos.z += sin(rot.y) * .1;\n        }\n        // Right\n        if(texelFetch(iChannel0,ivec2(68,0),0).x > 0.) {\n            pos.x += cos(rot.y) * .1;\n            pos.z -= sin(rot.y) * .1;\n        }\n        if(texelFetch(iChannel0,ivec2(67,0),0).x > 0.) {\n            pos.y -= .1;\n        }\n        if(texelFetch(iChannel0,ivec2(32,0),0).x > 0.) {\n            pos.y += .1;\n        }\n        fragColor = vec4(pos,1.);\n    }\n    else if(floor(fragCoord) == vec2(1.,0.)) {\n        // Look up\n        if(texelFetch(iChannel0,ivec2(38,0),0).x > 0.) {\n            rot.x -= .03;\n        }\n        // Look down\n        if(texelFetch(iChannel0,ivec2(40,0),0).x > 0.) {\n            rot.x += .03;\n        }\n        // Look left\n        if(texelFetch(iChannel0,ivec2(37,0),0).x > 0.) {\n            rot.y -= .03;\n        }\n        // Look right\n        if(texelFetch(iChannel0,ivec2(39,0),0).x > 0.) {\n            rot.y += .03;\n        }\n        fragColor = vec4(rot,1.);\n    }\n    //fragColor = texture(iChannel1,uv);\n}","name":"Buffer A","description":"","type":"buffer"}]}