{"ver":"0.1","info":{"id":"llV3DV","date":"1476974869","viewed":147,"name":"Pong for 2 players (WIP)","username":"sephirot47","description":"************* Controls  ************\n - SPACE to start.\n - WASD/ZASD to move left player.\n - ARROW_KEYS to move right player.\n*********************************","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["pong","multipass","sephirot47","multiplayer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"////////////////////////////////\n// Image buffer ////////////////\n////////////////////////////////\n\n////////// CONTROLS ////////////////////\n// SPACE                   - to Start //\n// WASD/ZASD or ARROW_KEYS - to Move  //\n////////////////////////////////////////\n\n// Channel defines\n#define MEMORY_CHANNEL iChannel0\n#define BG_CHANNEL iChannel1\n#define BACKBUFFER_CHANNEL iChannel2\n////////////////////////////////\n\n// Game defines\nconst float playerWidth = 0.05;\nconst float playerHeight = 0.2;\nconst float playerVelocity = 0.025;\n\nconst float ballRadius = 0.025;\n//\n\n// Memory functions\nvec4 READ(vec2 id) { return texture(MEMORY_CHANNEL, id); }\n////////////////////////////////\n\n// Memory variables ids\nconst vec2 ID_playerPosLeft  = vec2(0.0, 0.0);\nconst vec2 ID_playerPosRight = vec2(0.0, 0.1);\nconst vec2 ID_ballPosition   = vec2(0.0, 0.2);\nconst vec2 ID_ballVelocity   = vec2(0.0, 0.3);\n////////////////////////////////\n\n// Structs and forward declarations\nstruct Player { vec2 pos; bool left; };\nvoid player_init(inout Player player);\nvoid player_draw(in Player p);\n\nstruct Ball { vec2 pos; };\nvoid ball_init(inout Ball ball);\nvoid ball_draw(Ball ball);\n\nstruct Rect { vec2 pos; vec2 size; };\nbool rect_pointInside(in Rect r, in vec2 p);\n////////////////////////////////\n\n// Global variables\nvec2 pixelUv;\nvec4 finalColor;\nPlayer playerLeft, playerRight;\nBall ball;\n////////////////////////////////\n\n// Functions - Player\nvoid player_init(inout Player player)\n{\n    vec2 ID_pos = player.left ? ID_playerPosLeft : ID_playerPosRight;\n    player.pos = READ(ID_pos).xy;\n}\nvoid player_draw(in Player p)\n{\n    Rect boundingRect = Rect(vec2(p.pos.x, p.pos.y),\n                             vec2(playerWidth, playerHeight));\n    \n    // Shadow\n    /*\n    vec2 ballPlayerDir = (p.pos - ball.pos);\n    float ballPlayerDist = (abs(p.pos.x-ball.pos.x) + \n                            abs(p.pos.y-ball.pos.y));\n    Rect shadowRect = Rect(boundingRect.pos + \n                           ballPlayerDir * ballPlayerDist * 0.04,\n                           boundingRect.size * 1.0);\n    if (rect_pointInside(shadowRect, pixelUv))\n    {\n        finalColor *= 0.3;\n    }\n    */\n    \n    // Bar\n    if (rect_pointInside(boundingRect, pixelUv))\n    {\n        vec3 baseColor = p.left ? vec3(1,0,0) : vec3(0,1,0);\n        float horizontalFade = (pixelUv.x-p.pos.x)/playerWidth;\n        horizontalFade = p.left ? horizontalFade : 1.0 - horizontalFade;\n        horizontalFade += 0.5;\n        finalColor = vec4(baseColor * horizontalFade, 0);\n        finalColor *= horizontalFade;\n    }\n}\n////////////////////////////////\n\n// Functions - Ball \nvoid ball_init(inout Ball ball)\n{\n    ball.pos = READ(ID_ballPosition).xy;\n}\nvoid ball_draw(Ball ball)\n{\n    float d = distance(ball.pos, pixelUv); \n    float fade = (ballRadius * 0.75) / d;\n    fade *= fade;\n    vec4 ballColor = vec4(1, 1, 1, 1);\n    finalColor += ballColor * fade;\n    ball.pos -= READ(ID_ballVelocity).xy * iTimeDelta;\n}\n////////////////////////////////\n\n\n// Functions - Rect\nbool rect_pointInside(in Rect r, in vec2 p)\n{\n    return p.x >= r.pos.x && p.y >= r.pos.y &&\n           p.x <= r.pos.x + r.size.x && p.y <= r.pos.y + r.size.y;\n}\n////////////////////////////////\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Global variables definition\n    pixelUv = fragCoord.xy / min(iResolution.x, iResolution.y);\n        //\n\n    // Read variables\n    playerLeft.left = true;\n    playerRight.left = false;\n    player_init(playerLeft);\n    player_init(playerRight);\n    ball_init(ball);\n    //\n\n\n    // Draw stuff\n    // Background color\n    finalColor = vec4(0.3,0.5,1,1) * texture(BG_CHANNEL, pixelUv * 1.0/vec2(iResolution.x/iResolution.y, 1));\n    \n    player_draw(playerLeft);\n    player_draw(playerRight);\n    ball_draw(ball);\n    //\n\n    fragColor = finalColor;\n    // See memory buffer:\n    // fragColor = texture(MEMORY_CHANNEL, pixelUv);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"////////////////////////////////\n// Memory BUFFER ///////////////\n////////////////////////////////\n\n// Channel defines\n#define MEMORY_CHANNEL                iChannel0\n#define INPUT_CHANNEL                 iChannel1\n#define PREVIOUS_FRAME_INPUT_CHANNEL  iChannel2\n////////////////////////////////\n\n// Key Ids and input functions\nconst int KEY_Z = 90; const int KEY_W = 87; const int KEY_S = 83; const int KEY_SPACE = 32; const int KEY_LEFT = 37; const int KEY_UP = 38; const int KEY_RIGHT = 39; const int KEY_DOWN = 40;\nfloat keyCodeToUvX(int keyCode) { return (float(keyCode)+0.5) / 256.0; }\nbool getKey(int keyCode, sampler2D inputChannel, float uvy) { return texture(inputChannel, vec2(keyCodeToUvX(keyCode), uvy)).r > 0.5; }\nbool getKey(int keyCode) { return getKey(keyCode, INPUT_CHANNEL, 0.25); }\nbool getKeyDown(int keyCode){ bool keyNow = getKey(keyCode); bool keyBefore = getKey(keyCode, PREVIOUS_FRAME_INPUT_CHANNEL, 0.25); return (keyNow && !keyBefore); }\nbool getKeyUp(int keyCode) { bool keyNow = getKey(keyCode); bool keyBefore = getKey(keyCode, PREVIOUS_FRAME_INPUT_CHANNEL, 0.25); return (!keyNow && keyBefore); }\n////////////////////////////////\n\n// Game defines\nconst float playerWidth = 0.05;\nconst float playerHeight = 0.2;\nconst float playerAcc = 0.0015;\nconst float playerMaxVelocity = 0.02;\nconst float playerFriction = 0.94;\n\nconst vec2 BallInitPos = vec2(0.9, 0.5);\nconst float BallInitVel = 0.6;\nconst float BallBounceGain = 1.03;\nconst float ballRadius = 0.025;\n//\n\n// Memory variables id\nconst vec2 ID_playerPosLeft  = vec2(0.0, 0.0);\nconst vec2 ID_playerPosRight = vec2(0.0, 0.1);\nconst vec2 ID_playerVelLeft  = vec2(0.0, 0.4);\nconst vec2 ID_playerVelRight = vec2(0.0, 0.5);\n\nconst vec2 ID_ballPosition   = vec2(0.0, 0.2);\nconst vec2 ID_ballVelocity   = vec2(0.0, 0.3);\n////////////////////////////////\n\n// Structs and forward declarations\nstruct Rect { vec2 pos; vec2 size; };\nbool rect_pointInside(in Rect r, in vec2 p);\nbool rect_intersects(in Rect r1, in Rect r2);\n\nstruct Ball { vec2 pos; vec2 vel; };\nvoid ball_init(inout Ball ball);\nvoid ball_writeToMemory(inout Ball ball);\n\nstruct Player { vec2 pos; vec2 vel; bool left; };\nvoid player_init(inout Player player);\nvoid player_writeToMemory(inout Player player);\nbool player_collidingBall(in Player player, in Ball ball);\nRect player_getRect(in Player player);\n////////////////////////////////\n\n// Global variables\nvec2 fragCoordinate;\nvec2 pixelUv;\nvec4 finalColor;\nPlayer playerLeft  = Player(vec2(0.05,  0.4), vec2(0.0), true);\nPlayer playerRight = Player(vec2(1.7,  0.4), vec2(0.0), false);\nBall ball = Ball( BallInitPos, vec2(0.0) );\n////////////////////////////////\n\n// Memory functions\nvec4 READ(vec2 id) { return texture(MEMORY_CHANNEL, id); }\nbool IS_MEMORY_PIXEL_OF(vec2 id)\n{\n    return (abs(pixelUv.x-id.x) + abs(pixelUv.y-id.y) < 0.005);\n}\nvoid WRITE(vec2 id, vec4 value)\n{\n    if (IS_MEMORY_PIXEL_OF(id)) finalColor = value;\n}\n////////////////////////////////\n\n// Functions - Player\nvoid player_init(inout Player player)\n{\n    vec2 ID_pos = player.left ? ID_playerPosLeft : ID_playerPosRight;\n    player.pos = READ(ID_pos).xy;\n    vec2 ID_vel = player.left ? ID_playerVelLeft : ID_playerVelRight;\n    player.vel = READ(ID_vel).xy;\n}\nvoid player_writeToMemory(inout Player player)\n{\n    vec2 ID_pos = player.left ? ID_playerPosLeft : ID_playerPosRight;\n    WRITE(ID_pos, vec4(player.pos, 0, 0));\n    vec2 ID_vel = player.left ? ID_playerVelLeft : ID_playerVelRight;\n    WRITE(ID_vel, vec4(player.vel, 0, 0));\n}\nRect player_getRect(in Player player)\n{\n    return Rect(player.pos, vec2(playerWidth, playerHeight));\n}\nvoid player_processMovement(inout Player player)\n{\n    bool upPressed   = player.left ? (getKey(KEY_W) || getKey(KEY_Z)) : getKey(KEY_UP);\n    bool downPressed = player.left ? getKey(KEY_S) : getKey(KEY_DOWN);\n    if (upPressed)\n    {\n        player.vel.y += playerAcc;\n    }\n    else if(downPressed)\n    {\n        player.vel.y -= playerAcc;\n    }\n    player.vel *= playerFriction;\n    player.vel.y = clamp(player.vel.y, -playerMaxVelocity, playerMaxVelocity);\n    player.pos += player.vel;\n}\nvoid player_processScreenCollisions(inout Player player)\n{\n    bool collidingY = (player.pos.y < 0.0) ||\n                      (player.pos.y + playerHeight > 1.0);\n    if (collidingY)\n    {\n        player.pos -= player.vel;\n        player.vel *= -0.95;\n    }\n}\n////////////////////////////////\n\n// Functions - Ball\nvoid ball_init(inout Ball ball)\n{\n    ball.pos = READ(ID_ballPosition).xy;\n    ball.vel = READ(ID_ballVelocity).xy;\n}\nvoid ball_writeToMemory(inout Ball ball)\n{\n    WRITE(ID_ballPosition, vec4(ball.pos, 0, 0));\n    WRITE(ID_ballVelocity, vec4(ball.vel, 0, 0));\n}\nRect ball_getRect(in Ball ball)\n{\n    return Rect(ball.pos - ballRadius*0.5,\n                vec2(ballRadius)*0.5);\n}\n////////////////////////////////\n// Functions - Rect\nbool rect_pointInside(in Rect r, in vec2 p)\n{\n    return p.x >= r.pos.x && p.y >= r.pos.y &&\n           p.x <= r.pos.x + r.size.x && p.y <= r.pos.y + r.size.y;\n}\nbool _rect_intersects(in Rect r1, in Rect r2)\n{\n    return rect_pointInside(r1, r2.pos + r2.size * vec2(0,0)) ||\n           rect_pointInside(r1, r2.pos + r2.size * vec2(0,1)) ||\n           rect_pointInside(r1, r2.pos + r2.size * vec2(1,0)) ||\n           rect_pointInside(r1, r2.pos + r2.size * vec2(1,1));\n}\nbool rect_intersects(in Rect r1, in Rect r2)\n{\n    return _rect_intersects(r1,r2) ||\n           _rect_intersects(r2,r1);\n}\n////////////////////////////////\n\n// Other functions\nfloat lastRand;\nfloat randf()\n{\n    float r = fract( sin(dot(vec2(34.8,21.233) * lastRand, vec2(12.9898,78.233)) ) * 43758.5453);\n    lastRand = r;\n    return r;\n}\n\nvoid restartGame()\n{\n    ball.pos = BallInitPos;\n    ball.vel = vec2(0.0);\n}\nvoid initGame()\n{\n    float vx = 1.0 * (randf() < 0.0 ? 1.0 : -1.0);\n    ball.vel = vec2(vx , randf()*2.0-1.0) * BallInitVel;\n}\n////////////////////////////////\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    finalColor = vec4(0,0,0,0); // \"Clean\" value\n    pixelUv = fragCoord.xy / min(iResolution.x, iResolution.y);\n    fragCoordinate = fragCoord;\n    \n    if (!IS_MEMORY_PIXEL_OF(ID_playerPosLeft)  &&\n        !IS_MEMORY_PIXEL_OF(ID_playerPosRight) &&\n        !IS_MEMORY_PIXEL_OF(ID_playerVelLeft)  &&\n        !IS_MEMORY_PIXEL_OF(ID_playerVelRight) &&\n        !IS_MEMORY_PIXEL_OF(ID_ballPosition)   &&\n        !IS_MEMORY_PIXEL_OF(ID_ballVelocity))\n    {\n        fragColor = finalColor;\n        return;\n    }\n\n    lastRand = iTime;\n\n    if (iTime < 0.1) // First frame\n    {\n        // Let the memory buffer fill, to avoid garbage reads\n    }\n    else // Rest of frames\n    {\n        // Variable loading from memory\n        player_init(playerLeft);\n        player_init(playerRight);\n        ball_init(ball);\n        //\n\n        // Game start\n        if (getKey(KEY_SPACE) && length(ball.vel) <= 0.05)\n        {\n            initGame();\n        }\n\n        // Player movement input\n        player_processMovement(playerLeft);\n        player_processMovement(playerRight);\n        //\n\n        // Player collisions with screen Y Bounds\n        player_processScreenCollisions(playerLeft);\n        player_processScreenCollisions(playerRight);\n        //\n\n        //////\n\n        // Ball movement\n        {\n            ball.pos += ball.vel * iTimeDelta;\n\n            bool collidingPlayer = false, collidingY = false;\n\n            // Ball collision with walls\n            {\n                collidingY = (ball.pos.y > 1.0 - ballRadius ||\n                              ball.pos.y < 0.0 + ballRadius);\n            }\n\n            // Ball collision with players\n            {\n                //collidingPlayer = rect_pointInside(rplayerRight, ball.pos)||\n                //                        rect_pointInside(rplayerLeft,  ball.pos);\n                Rect rBall = ball_getRect(ball);\n                Rect rPlayerLeft  = player_getRect(playerLeft);\n                Rect rPlayerRight = player_getRect(playerRight);\n                collidingPlayer = rect_intersects(rBall, rPlayerLeft) ||\n                                  rect_intersects(rBall, rPlayerRight);\n            }\n\n            // Ball movement fix after collision (if any)\n            {\n                if (collidingPlayer)\n                {\n                    ball.pos.x -= ball.vel.x * iTimeDelta * 3.0;\n                    ball.vel.x *= -BallBounceGain;\n                }\n                if (collidingY)\n                {\n                    ball.pos.y -= ball.vel.y * iTimeDelta;\n                    ball.vel.y *= -BallBounceGain;\n                }\n\n                if (ball.pos.x - ballRadius > 1.8 || ball.pos.x + ballRadius < 0.0)\n                {\n                    restartGame();\n                }\n            }\n\n        }\n    }\n\n    // Variable writing to memory\n    player_writeToMemory(playerLeft);\n    player_writeToMemory(playerRight);\n    ball_writeToMemory(ball);\n    //\n\n    fragColor = finalColor;\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Latest input BUFFER\n// Used to store last input state, to handle more complex input events\n\n// Channel defines\n#define INPUT_CHANNEL iChannel1\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = texture(INPUT_CHANNEL, uv);\n}","name":"Buf B","description":"","type":"buffer"}]}