{"ver":"0.1","info":{"id":"MXVSWw","date":"1720046515","viewed":110,"name":"Atmospheric Planet (path traced)","username":"guhcalm","description":"Baking (path-traced irradiance + shadows + heighmap + brdf)\nJumpl Flooding\nIBL + PBR\nArmospheric Scattering\n","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["pathtrace","brdf","ibl","jumplflooding"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 PincushionDistortion(vec2 uv, float strength) {\n  vec2 st = uv - 0.5;\n  float uvA = atan(st.x, st.y);\n  float uvD = dot(st, st);\n  return 0.5 + vec2(sin(uvA), cos(uvA)) * sqrt(uvD) * (1.0 - strength * uvD);\n}\nvec3 ChromaticAbberation(vec2 uv, sampler2D sampler) {\n  float amount = .5;\n  return vec3(\n    texture(sampler, PincushionDistortion(uv, 0.3 * amount)).r,\n    texture(sampler, PincushionDistortion(uv, 0.15 * amount)).g,\n    texture(sampler, PincushionDistortion(uv, 0.075 * amount)).b\n  );\n}\n#define ACESFilmic(color) (color * (2.51 * color + .03)) / (color * (2.43 * color + .59) + .14)\n#define Contrast(color) color * color * (3. -2. * color)\n#define HighlightRolloff(color) 1.85 * color / (1. + color)\nvec3 FilmGrain(vec2 uv, vec3 color) {\n  float seed = dot(uv, vec2(12.9898, 78.233));\n  float noise = .7978845608028654 * exp(-(pow(fract(sin(seed) * 43758.5453), 2.) / .5));\n  vec3 grain = vec3(noise) * (1.0 - color);\n  return color + noise * .075;\n}\n#define Vignetting(uv, color) color * (.5 + .5 * pow(16. * uv.x * uv.y * (1. - uv.x) * (1. - uv.y), .25))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  vec3 color = ChromaticAbberation(uv, iChannel0);\n  \n  color = Vignetting(uv, color);\n  color = FilmGrain(uv, color);\n  \n  color = GammaCompression(ACESFilmic(GammaExpansion(color)));\n  \n  color = Contrast(color);\n  color = HighlightRolloff(color);\n  \n  \n  //color = (texture(iChannel2, uv) / float(PATH_TRACE_STEPS)).rgb;\n  fragColor = vec4(color, 1.);\n  \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define GammaExpansion(color) pow(vec3(color), vec3(2.2))\n#define GammaCompression(color) pow(vec3(color), vec3(1. / 2.2))\n#define saturate(value) clamp(value, 0., 1.)\n\nstruct Ray { vec3 origin; vec3 direction; };\nstruct Material { vec3 albedo; float roughness; float metalness; float reflectance; };\nstruct Geometry { float distance; vec3 position; vec3 normal; };\nstruct Volume { float distance; vec3 position; vec3 normal; float path; };\nstruct Light { vec3 direction; vec3 color; };\n\nconst float PI = 3.14159265359;\nconst float EPSILON = .001;\nconst float INFINITY = 1. / 0.;\nconst int PATH_TRACE_STEPS = 100;\nLight SUN = Light(normalize(vec3(-1, 1, -1)), vec3(1));\n\nconst vec3 PLANET_POSITION = vec3(0);\nconst float PLANET_RADIUS = 1.5;\nconst float OCEAN_RADIUS = PLANET_RADIUS - .06;\nconst float ATMOSPHERE_RADIUS = PLANET_RADIUS + .2;\n\nfloat seed;\nfloat random() { return fract(sin(seed += .1) * 4568.7564); }\nfloat random(vec2 uv) { return fract(sin(dot(uv, vec2(127.1, 311.7))) * 4568.7564); }\nvec3 RandomVectorOnHemisphere(vec3 normal) {\n  float u = random();\n  float v = random();\n  float a = 6.283185 * v;\n  float b = u * 2. - 1.;\n  vec3 random = vec3(sqrt(1. - b * b) * vec2(cos(a), sin(a)), b);\n  return normalize(random * sign(dot(normal, random)));\n}\n\nvec2 sphereToUv(vec3 direction) {\n  float phi = atan(direction.z, direction.x);\n  float theta = acos(direction.y);\n  float u = (phi + PI) / (2.0 * PI);\n  float v = theta / PI;\n  return vec2(u, 1. - v);\n}\nvec3 uvToSphere(vec2 uv) {\n  float phi = (uv.x * 2.0 * PI) - PI;\n  float theta = PI * (1.0 - uv.y);\n  float x = sin(theta) * cos(phi);\n  float y = cos(theta);\n  float z = sin(theta) * sin(phi);\n  return vec3(x, y, z);\n}\n\nvec3 TurboColorPallete(float t) {\n  t = clamp(0., 1., t);\n  const vec3 c0 = vec3(0.1140890109226559, 0.06288340699912215, 0.2248337216805064);\n  const vec3 c1 = vec3(6.716419496985708, 3.182286745507602, 7.571581586103393);\n  const vec3 c2 = vec3(-66.09402360453038, -4.9279827041226, -10.09439367561635);\n  const vec3 c3 = vec3(228.7660791526501, 25.04986699771073, -91.54105330182436);\n  const vec3 c4 = vec3(-334.8351565777451, -69.31749712757485, 288.5858850615712);\n  const vec3 c5 = vec3(218.7637218434795, 67.52150567819112, -305.2045772184957);\n  const vec3 c6 = vec3(-52.88903478218835, -21.54527364654712, 110.5174647748972);\n  return c0 + t * (c1 + t * (c2 + t * (c3 + t * (c4 + t * (c5 + t * c6)))));\n}\n\nfloat PointedGridPattern(vec2 uv) { \n float u = fract((uv.x) * 60.) * 2. - 1.;\n float p = abs(uv.y * 2. - 1.);\n if (p >= (1. / 90.) * 80.) return 1.;\n float v = fract(p * 20.);\n float t = abs(u);\n if (abs(v) <= t) {\n   t = abs(v);\n   t = pow(1. - t, 45.);\n } else t = pow(1. - t, 35.);\n return clamp(1. - t, 0., 1.);\n}\n\nfloat BiggerPointedGridPattern(vec2 uv) { \n float u = fract((uv.x) * 60.) * 2. - 1.;\n float p = abs(uv.y * 2. - 1.);\n if (p >= (1. / 90.) * 80.) return 1.;\n float v = fract(p * 20.);\n float t = abs(u);\n if (abs(v) <= t) {\n   t = abs(v);\n   t = pow(1. - t, 40.);\n } else t = pow(1. - t, 30.);\n return clamp(1. - t, 0., 1.);\n}\n\nfloat GridPattern(vec2 uv) { \n vec2 iuv = fract((uv) * 10.) * 2. - 1.;\n float t = abs(iuv.x);\n if (abs(iuv.y) <= t) t = abs(iuv.y);\n t = pow(1. - t, 200.);\n return clamp(1. - t, 0., 1.);\n}\n\n/* View Projection | Camera */\n\nRay Camera(in vec2 uv, vec3 origin, vec3 target, float aspect, float focalLength) {\n  focalLength = 0.;\n  vec3 ndc = vec3(uv * 2.0 - 1.0, 1.0); // Coordenadas NDC, Z positivo para frente\n  const float fov = (60.0 * PI / 180.0); // Campo de visão\n  const vec3 up = vec3(0, 1, 0); // Vetor para cima\n  float f = tan(fov / 2.0); // Fator de campo de visão\n    \n  // Calcula a direção da tela em projeção de perspectiva padrão\n  vec3 screen = vec3(ndc.x * aspect * f, ndc.y * f, ndc.z / f);\n    \n    // Normaliza a direção da tela para projeção Panini\n  float d = sqrt(1.0 + screen.x * screen.x + screen.y * screen.y);\n  float u = screen.x / (screen.z + d * focalLength);\n  float v = screen.y / (screen.z + d * focalLength);\n  vec3 paniniScreen = normalize(vec3(u, v, 1.0));\n    \n    // Calcula a base da câmera\n  vec3 w = normalize(target - origin);\n  vec3 uAxis = normalize(cross(w, up));\n  vec3 vAxis = normalize(cross(uAxis, w));\n    \n    // Retorna o raio da câmera com a projeção Panini\n  return Ray(origin, normalize(mat3(uAxis, vAxis, w) * paniniScreen));\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/* Pre-Computing Bump Map */\n\nfloat N31(vec3 p) { return fract(cos(p.x*25013.+p.y*3539.+p.z*751.)*39863.); }\nfloat SmoothNoise3D(vec3 p) {\n    vec3 lv = fract(p);\n    vec3 id = floor(p);\n    \n    lv = lv*lv*(3.-2.*lv);\n    \n    float fbl = N31(id+vec3(0,0,0));\n    float fbr = N31(id+vec3(1,0,0));\n    float fb = mix(fbl, fbr, lv.x);\n    \n    float ftl = N31(id+vec3(0,1,0));\n    float ftr = N31(id+vec3(1,1,0));\n    float ft = mix(ftl, ftr, lv.x);\n    \n    float bbl = N31(id+vec3(0,0,1));\n    float bbr = N31(id+vec3(1,0,1));\n    float bb = mix(bbl, bbr, lv.x);\n    \n    float btl = N31(id+vec3(0,1,1));\n    float btr = N31(id+vec3(1,1,1));\n    float bt = mix(btl, btr, lv.x);\n    \n    float f = mix(fb, ft, lv.y);\n    float b = mix(bb, bt, lv.y);\n    \n    return mix(f,b, lv.z);\n}\nfloat SmoothNoise3DDetail(vec3 p) {\n    float c = SmoothNoise3D(p*4.);\n    c += SmoothNoise3D(p*8.)*.5;\n    c += SmoothNoise3D(p*16.)*.25;\n    c += SmoothNoise3D(p*32.)*.125;\n    c += SmoothNoise3D(p*64.)*.0625;\n    c += SmoothNoise3D(p*128.)*.03125;\n    return c/(2.-0.03125);\n}\n\nfloat Bumpmap(vec3 direction) {\n  float ws = SmoothNoise3D(direction * 4.);\n  float ns = .1 + SmoothNoise3D(direction*64.)*.5 + SmoothNoise3D(direction*128.)*.25;\n  return (1. - 4. * (ws * ns)) * .2;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  if (iFrame > 1) discard;\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  vec3 direction = uvToSphere(uv);  \n  float bump = Bumpmap(direction);\n  fragColor = vec4(bump);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/* Pre-Computing Diffused Radiance Light */\n\n/* Geometry buffer */\nfloat PlanetSDF(vec3 position) {\n  #define BakedBumpmap(uv) texture(iChannel0,uv).w\n  vec3 normal = - normalize(position);\n  vec2 uv = sphereToUv(normalize(position));\n  float bump = BakedBumpmap(uv);\n  float d = length(position) - (PLANET_RADIUS - bump);\n  return d * .2;\n}\n\nfloat SDF(in vec3 p) { return PlanetSDF(p); }\n\nfloat SphereTracer(Ray ray) {\n  float distance;\n  const float NEAR = EPSILON;\n  const float FAR = 18.;\n  const float RELAXATION = .35;\n  for(int step; step < 800; step++) {\n    float march = SDF(ray.origin + ray.direction * distance);\n    if (abs(march) <= NEAR) return distance;\n    distance += march * RELAXATION;\n    if (distance >= FAR) break;\n  }\n  return INFINITY;\n}\n\n#define RayMarcher(camera) SphereTracer(camera)\n\n/* Shadows */\nfloat SoftShadows(Geometry geometry, Light light) {\n  float k = 16.;\n  float res = 1.;\n  float t = .1;\n  float ph = 1e10;\n  for(int i = 0; i < 64; i++) {\n\tfloat h = SDF(geometry.position + light.direction * t);\n    float y = h * h / (2. * ph);\n    float d = sqrt(h * h - y * y);\n    res = min(res, k * d / max(0., t - y));\n    ph = h;    \n    t += h;\n    if(res < .001 || t > 16.) break;\n  }\n  res = clamp(res, 0., 1.);\n  return res * res * (3. - 2. * res);\n}\n\nGeometry GeometryBuffer(Ray camera) {\n  float distance = RayMarcher(camera);\n  vec3 position = camera.origin + camera.direction * distance;\n  vec2 e = vec2(EPSILON, 0);\n  vec3 normal = normalize(vec3(\n    SDF(position + e.xyy) - SDF(position - e.xyy),\n    SDF(position + e.yxy) - SDF(position - e.yxy),\n    SDF(position + e.yyx) - SDF(position - e.yyx)\n  ));\n  return Geometry(distance, position, normal);\n}\n\n/* Path Tracer */\nvec3 DiffuseRadiance(in Ray camera) {\n  #define Environment(direction) GammaExpansion(texture(iChannel1, direction).rgb)\n  for (int i; i < 5; i++) {\n    Geometry geometry = GeometryBuffer(camera);\n    if (geometry.distance == INFINITY) return Environment(camera.direction);\n    camera.origin = geometry.position + geometry.normal * .0001;\n    camera.direction = RandomVectorOnHemisphere(geometry.normal);\n  }          \n  return vec3(0);\n}\n\nvoid mainImage(out vec4 PrecomputedDiffuseRadiance, in vec2 fragCoord) {\n  if (iFrame > PATH_TRACE_STEPS) discard;\n\n  seed = iTime + random(fragCoord.xy / iResolution.xy); \n  vec2 off = vec2(random(), random());\n  vec2 uv = saturate((off + fragCoord.xy) / iResolution.xy);\n  vec3 direction = uvToSphere(uv);\n  \n  Ray camera = Ray(direction * 4.5, -direction);\n  \n  vec3 radiance = GammaCompression(DiffuseRadiance(camera));\n  \n  Geometry geometry = GeometryBuffer(camera);\n  float shadows = SoftShadows(geometry, SUN);\n  \n  vec4 currentFrame = vec4(radiance, shadows);\n  vec4 lastFrame = texture(iChannel2, vec2(fragCoord.xy / iResolution.xy));\n  \n  PrecomputedDiffuseRadiance = currentFrame + lastFrame;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"vec4 JumpFlooding(ivec2 ij, float seed) {\n  const int STEP_FRAMES = 30;\n  const int N = 9;  \n  int jump_size = (1 << N) >> min(iFrame/STEP_FRAMES, N); \n  float current_dist = 9e9;\n  vec2 current_offset = vec2(0);\n  float current_fill = 0.;\n  if(iFrame == 0) return vec4(0, 0, 0, seed);\n  for(int x = -1; x <= 1; ++x)\n  for(int y = -1; y <= 1; ++y) {\n    ivec2 jump = jump_size * ivec2(x,y);\n    ivec2 coord = ij + jump;\n    if(coord.x < 0 || coord.y < 0 || coord.x >= int(iResolution.x) || coord.y >= int(iResolution.y)) continue;\n    vec4 samp = texelFetch(iChannel1, coord, 0);\n    bool samp_fill = samp.a >= 1.;\n    vec2 samp_offset = samp.rg;\n    vec2 candidate_offset = vec2(jump) + samp_offset;\n    float candidate_dist = length(candidate_offset);\n    if (candidate_dist <= current_dist && samp_fill) {\n      current_dist = candidate_dist;\n      current_offset = candidate_offset;\n      current_fill = 1.;\n    }\n  }\n  return vec4(current_offset, 0., current_fill);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  if (iFrame > 600) discard;\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  ivec2 ij = ivec2(fragCoord);\n  float bump = texture(iChannel0, uv).w;\n  float seed = ((PLANET_RADIUS - bump) <= OCEAN_RADIUS) ? 0. : 1.;\n  fragColor = JumpFlooding(ij, seed);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"/* Geometry Buffer */\n\n\nfloat N31(vec3 p) { return fract(cos(p.x*25013.+p.y*3539.+p.z*751.)*39863.); }\nfloat SmoothNoise3D(vec3 p) {\n    vec3 lv = fract(p);\n    vec3 id = floor(p);\n    \n    lv = lv*lv*(3.-2.*lv);\n    \n    float fbl = N31(id+vec3(0,0,0));\n    float fbr = N31(id+vec3(1,0,0));\n    float fb = mix(fbl, fbr, lv.x);\n    \n    float ftl = N31(id+vec3(0,1,0));\n    float ftr = N31(id+vec3(1,1,0));\n    float ft = mix(ftl, ftr, lv.x);\n    \n    float bbl = N31(id+vec3(0,0,1));\n    float bbr = N31(id+vec3(1,0,1));\n    float bb = mix(bbl, bbr, lv.x);\n    \n    float btl = N31(id+vec3(0,1,1));\n    float btr = N31(id+vec3(1,1,1));\n    float bt = mix(btl, btr, lv.x);\n    \n    float f = mix(fb, ft, lv.y);\n    float b = mix(bb, bt, lv.y);\n    \n    return mix(f,b, lv.z);\n}\nfloat SmoothNoise3DDetail(vec3 p) {\n    float c = SmoothNoise3D(p*4.);\n    c += SmoothNoise3D(p*8.)*.5;\n    c += SmoothNoise3D(p*16.)*.25;\n    c += SmoothNoise3D(p*32.)*.125;\n    c += SmoothNoise3D(p*64.)*.0625;\n    c += SmoothNoise3D(p*128.)*.03125;\n    return c/(2.-0.03125);\n}\nfloat Bumpmap(vec3 direction) {\n  float ws = SmoothNoise3D(direction * 4.);\n  float ns = .1 + SmoothNoise3D(direction*64.)*.5 + SmoothNoise3D(direction*128.)*.25;\n  return (1. - 4. * (ws * ns)) * .2;\n}\n\n\nfloat PlanetSDF(vec3 position) {\n  #define BumpmapBaked(uv) Bumpmap(uvToSphere(uv))\n  vec3 normal = - normalize(position);\n  vec2 uv = sphereToUv(normalize(position));\n  float bump = BumpmapBaked(uv);\n  float radius = (PLANET_RADIUS - bump);\n  float d = length(position) - radius;\n  return d * .5;\n}\nfloat SDF(in vec3 p) { return PlanetSDF(p); }\nfloat SphereTracer(Ray ray) {\n  float distance;\n  const float NEAR = EPSILON;\n  const float FAR = 8.;\n  const float RELAXATION = .5;\n  for(int step; step < 300; step++) {\n    float march = SDF(ray.origin + ray.direction * distance);\n    if (abs(march) <= NEAR) return distance;\n    distance += march * RELAXATION;\n    if (distance >= FAR) break;\n  }\n  return INFINITY;\n}\nfloat ImprovedSphereTracer(Ray ray) {\n  float maxDist = 18.;\n  vec3 ro = ray.origin;\n  vec3 rd = ray.direction;\n  float t = SDF(ro);\n  float eps = 0.0001;\n  float dt = 0.;\n  vec3 rgb = vec3(0.25);\n  float stepCtr = 0.;\n  float w = 1.2;\n  float dw = 1.; \n  float prevF = 0.; \n  float prevDt = 0.; \n  bool relaxed = true;\n  while (t > eps && t < maxDist) {\n    vec3 p = ro + rd * t;\n    float f = SDF(p);\n    dt = f * w;\n    if (prevF + f < prevDt && relaxed) {\n      relaxed = false;\n      t += prevDt * (1.0f - w);\n      p = ro + rd * t;\n      f = SDF(p);\n      dt = f * w;\n    }\n    if (f < eps) break; \n    t += dt;\n    if (t >= maxDist) return INFINITY;\n    prevF = f;\n    prevDt = dt;\n    if (relaxed) w = mod(fract(w) * dw, 1.) + 1.;\n    else w = 1.2; \n    eps *= 1.05;    \t\n    stepCtr += 1.;\n  }\n  return t;\n}\n#define RayMarcher(camera) ImprovedSphereTracer(camera)\nvec2 SphereDistance(Ray camera, float radius) {\n  vec3 position;\n  vec3 direction = camera.origin - position;\n  float a = dot(camera.direction, camera.direction);\n  float b = 2. * dot(direction, camera.direction);\n  float c = dot(direction, direction) - radius * radius;\n  float discriminant = b * b - 4. * a * c;\n  if (discriminant <= 0.) return vec2(INFINITY);\n  float distanceA = (-b - sqrt(discriminant)) / (2. * a);\n  float distanceB = (-b + sqrt(discriminant)) / (2. * a);\n  if (distanceA < 0.) return vec2(INFINITY, distanceB); \n  return vec2(distanceA, distanceB);\n}\n\nfloat AtmosphereDensity(vec3 position) {\n  const float DENSITY_FALLOFF = 3.0;\n  float heightAboveSurface = length(position - PLANET_POSITION) - (PLANET_RADIUS);\n  float height01 = heightAboveSurface / (ATMOSPHERE_RADIUS - PLANET_RADIUS);\n  return exp(-height01 * DENSITY_FALLOFF) * (1. - height01);\n}\nfloat AtmosphereOpticalDepth(Ray ray, float path) {\n  const int OUTSCATTER_POINTS = 10;\n  vec3 densitySamplePoint = ray.origin;\n  float stepSize = path / float(OUTSCATTER_POINTS - 1);\n  float opticalDepth;\n  for (int i = 0; i < OUTSCATTER_POINTS; i++) {\n\topticalDepth += AtmosphereDensity(densitySamplePoint) * stepSize;\n\tdensitySamplePoint += ray.direction * stepSize;\n  }\n  return opticalDepth;\n}\nvec3 AtmosphereLight(Ray camera, float path) {\n  const int INSCATTER_POINTS = 10;\n  const vec3 WAVE_LENGTHS = vec3(750.0, 530.0, 400.0);\n  const float SCATTERING_STRENGTH = 15.0;\n  const vec3 SCATTERING_COEFFICIENTS = pow(400.0 / WAVE_LENGTHS, vec3(4.0)) * SCATTERING_STRENGTH;\n  vec3 inScatterPoint = camera.origin;\n  vec3 inScatteredLight;\n  float stepSize = path / float(INSCATTER_POINTS - 1);\n  for (int i = 0; i < INSCATTER_POINTS; i++) {\n    Ray sunRay = Ray(inScatterPoint, SUN.direction);\n    Ray viewRay = Ray(inScatterPoint, -camera.direction);\n    float sunRayPath = SphereDistance(sunRay, ATMOSPHERE_RADIUS).y;\n    if (sunRayPath == INFINITY) continue;\n    float sunRayOpticalDepth = AtmosphereOpticalDepth(sunRay, sunRayPath);\n    float viewOpticalDepth = AtmosphereOpticalDepth(viewRay, stepSize * float(i));\n    float density = AtmosphereDensity(inScatterPoint);\n    vec3 transmittance = exp(-(sunRayOpticalDepth + viewOpticalDepth) * SCATTERING_COEFFICIENTS);\n    inScatteredLight += density * transmittance * SCATTERING_COEFFICIENTS * stepSize;\n\tinScatterPoint += camera.direction * stepSize;\n  }\n  return ((inScatteredLight));\n}\n\n#define Environmentmap(direction) GammaExpansion(texture(iChannel2, direction).rgb)\nvec3 IBL(Ray camera, Geometry geometry, Material material, vec3 diffuseRadiance, float ao) {\n  #define SpecularRadiance(R, roughness) Environmentmap(R)\n  vec3 V = -camera.direction;\n  vec3 N = geometry.normal;\n  vec3 R = reflect(-V, N);\n  vec3 albedo = GammaExpansion(material.albedo);\n  float metalness = saturate(material.metalness);\n  float roughness = clamp(material.roughness, .1, 1.);\n  float reflectance = material.reflectance;\n  vec3 F0 = mix(vec3(reflectance), albedo, metalness);\n \n  vec3 irradiance = diffuseRadiance;\n  vec3 radiance = SpecularRadiance(R, roughness) * ao;\n  \n  vec2 brdf = texture(iChannel0, uvToSphere(vec2(max(dot(N, V), 0.), roughness))).rg;\n  vec3 fresnel = (F0 * brdf.r + brdf.g);\n  \n  vec3 diffuse = albedo * (irradiance * irradiance + irradiance);\n  vec3 specular = radiance * radiance + radiance;\n  return mix(diffuse, specular, fresnel);\n}\nvec3 PBR(Ray camera, Geometry geometry, Material material, Light light, float ao, float shadows) {\n  vec3 V = - camera.direction;\n  vec3 N = geometry.normal;\n  vec3 albedo = GammaExpansion(material.albedo);\n  float metalness = saturate(material.metalness);\n  float roughness = mix(.1, 1., material.roughness);\n  float reflectance = clamp(material.reflectance, 0., .16);\n  float alpha = pow(roughness, 2.);\n  float a2 = pow(alpha, 2.);\n  float k = saturate(alpha / 2.);\n  vec3 Fo = mix(vec3(reflectance), albedo, metalness);  \n  vec3 diffuse = (1. - metalness) * albedo / PI; \n  vec3 Lo;\n  {// direct\n    vec3 L = normalize(light.direction);\n    vec3 H = normalize(V + L);\n    float D = a2 / (PI * pow(pow(saturate(dot(N, H)), 2.) * (a2 - 1.) + 1., 2.));\n    float G = 1. / mix(saturate(dot(N, L)), 1., k) * mix(saturate(dot(N, V)), 1., k);\n    vec3 F = mix(vec3(pow(1. - saturate(dot(L, H)), 5.)), vec3(1), Fo);\n    vec3 radiance = light.color * ao * shadows; \n    Lo += mix(diffuse, vec3(D * G / 4.), F) * radiance * saturate(dot(N, L));\n  }\n  {// bouncing\n    vec3 L = normalize(-light.direction);\n    vec3 H = normalize(V + L);\n    float D = a2 / (PI * pow(pow(saturate(dot(N, H)), 2.) * (a2 - 1.) + 1., 2.));\n    float G = 1. / mix(saturate(dot(N, L)), 1., k) * mix(saturate(dot(N, V)), 1., k);\n    vec3 F = mix(vec3(pow(1. - saturate(dot(L, H)), 5.)), vec3(1), Fo);\n    vec3 radiance = .2 * light.color * ao * (1. - ao) * (1. - shadows);\n    Lo += mix(diffuse, vec3(D * G / 4.), F) * radiance * saturate(dot(N, L));\n  }\n  return Lo;\n}\n\nGeometry Planet(Ray camera) {\n  float distance = RayMarcher(camera);\n  vec3 position = camera.origin + camera.direction * distance;\n  vec2 e = vec2(EPSILON, 0);\n  vec3 normal = normalize(vec3(\n    SDF(position + e.xyy) - SDF(position - e.xyy),\n    SDF(position + e.yxy) - SDF(position - e.yxy),\n    SDF(position + e.yyx) - SDF(position - e.yyx)\n  ));\n  return Geometry(distance, position, normal);\n}\nVolume Atmosphere(Ray camera) {\n  vec2 distances = SphereDistance(camera, ATMOSPHERE_RADIUS);\n  float distance = distances.x;\n  float path = abs(distances.y - distances.x);\n  vec3 position = camera.origin + camera.direction * distance;\n  vec3 normal = normalize(position);\n  return Volume(distance, position, normal, path);\n}\nVolume Ocean(Ray camera) {\n  vec2 distances = SphereDistance(camera, OCEAN_RADIUS);\n  float distance = distances.x;\n  float path = abs(distances.y - distances.x);\n  vec3 position = camera.origin + camera.direction * distance;\n  vec3 normal = normalize(position);\n  return Volume(distance, position, normal, path);\n}\n\nvec3 Render(Ray camera) {\n  Geometry planet = Planet(camera);\n  Volume atmosphere = Atmosphere(camera);\n  Volume ocean = Ocean(camera);\n  //return planet.normal * .5 + .5;\n  vec2 atmosphereUv = sphereToUv(normalize(atmosphere.position));\n  vec2 oceanUv = sphereToUv(normalize(ocean.position));\n  vec2 planetUv = sphereToUv(normalize(planet.position));\n  \n  vec3 environmentmap = Environmentmap(camera.direction);\n  if (atmosphere.distance == INFINITY) return GammaCompression(environmentmap);\n  \n  float path = atmosphere.path;\n  float atmosphereGrid = PointedGridPattern(atmosphereUv);  \n  \n  if (planet.distance != INFINITY) path = abs(atmosphere.distance - planet.distance);\n  \n  vec4 bakedDiffuseRadiance = texture(iChannel1, planetUv) / float(PATH_TRACE_STEPS);\n  vec3 diffuseRadiance = GammaExpansion(bakedDiffuseRadiance.rgb);\n  float ao = clamp(diffuseRadiance.x + diffuseRadiance.y + diffuseRadiance.z, 0., 1.);\n  float shadows = bakedDiffuseRadiance.w;\n  \n  //return vec3(ao);\n // return GammaCompression(diffuseRadiance * shadows);\n  \n  if (ocean.distance != INFINITY && ocean.distance < planet.distance) {\n    float depth = 1. - saturate((abs(planet.distance - ocean.distance) / (PLANET_RADIUS - OCEAN_RADIUS)));\n    \n    float oceanGrid = BiggerPointedGridPattern(oceanUv);\n    \n    vec3 albedo =  mix(vec3(1), (TurboColorPallete(mix(0., .32, depth))), oceanGrid);\n    float wavesDistance = length(texture(iChannel3, oceanUv).xy);\n    float coastDepth = smoothstep(0., 1., clamp(wavesDistance, 0., 15.) / 15.);\n    float waves = saturate(mix(pow(abs(sin(wavesDistance * 4. - iTime * 5.5)), 2.1), 0., coastDepth));\n    if (wavesDistance == 0.) waves = 0.;\n    albedo = mix(albedo, vec3(1), GammaExpansion(waves));\n    \n    Material material = Material(albedo, 0., 0., .16);\n    Geometry geometry = Geometry(ocean.distance, ocean.position, ocean.normal);\n   \n    vec3 indirect = IBL(camera, geometry, material, diffuseRadiance, ao);\n    vec3 direct = PBR(camera, geometry, material, SUN, ao, shadows);\n    vec3 color = (direct + indirect) * shadows;\n    \n    path = abs(atmosphere.distance - ocean.distance);\n    vec3 light = AtmosphereLight(Ray(atmosphere.position, camera.direction), path);\n    return GammaCompression(mix(color, light, path / (atmosphere.path))) * atmosphereGrid;\n  }\n  vec3 light = AtmosphereLight(Ray(atmosphere.position, camera.direction), path);\n  \n  if (planet.distance == INFINITY) return GammaCompression(mix((environmentmap), light, path / (2. * ATMOSPHERE_RADIUS))) * atmosphereGrid;\n  \n  float planetGrid = BiggerPointedGridPattern(planetUv);\n  float height = abs(length(planet.position) - OCEAN_RADIUS) / (PLANET_RADIUS - OCEAN_RADIUS);\n  vec3 albedo = mix(vec3(1), TurboColorPallete(height), planetGrid);\n  //albedo = vec3(1);\n  \n // return GammaCompression(diffuseRadiance* shadows * albedo);\n  Material material = Material(albedo, 0., 0., .16) ;\n  \n  vec3 indirect = IBL(camera, planet, material, diffuseRadiance, ao);  \n  vec3 direct = PBR(camera, planet, material, SUN, ao, shadows);\n  vec3 color = vec3(indirect + direct) * shadows;\n  return GammaCompression(mix(color, light, path / (atmosphere.path))) * atmosphereGrid;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (fragCoord.xy) / iResolution.xy;\n  vec2 m = (iMouse.xy - .5 * iResolution.xy) / iResolution.y;\n  float theta = - m.x * PI * 2. - 1.5 + iTime * .0;\n  float phi = - m.y * PI * 2.;\n  float t = smoothstep(0., 1., abs(sin(iTime * .5)));\n // t = 0.8;\n  float distance = mix(5.5, 2., t) * 0. + 5.5;\n  float focalLength = mix(.0, 2.8, t);\n  vec3 origin = distance * normalize(vec3(sin(theta), phi - 3.1, cos(theta)));\n  vec3 target = vec3(0);\n  float aspect = iResolution.x / iResolution.y;\n  Ray camera = Camera(uv, origin, target, aspect, focalLength);\n  vec3 color = Render(camera);\n  fragColor = vec4(color, 1);\n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"/* BRDF integration */\n\nfloat RadicalInverse_VdC(uint bits)  {\n  bits = (bits << 16u) | (bits >> 16u);\n  bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n  bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n  bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n  bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n  return float(bits) * 2.3283064365386963e-10;\n}\nvec2 Hammersley(uint i, uint N) { return vec2(float(i) / float(N), RadicalInverse_VdC(i)); }\nvec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness) {\n  float a = roughness*roughness;\n\n  float phi = 2.0 * PI * Xi.x;\n  float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));\n  float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n  \n  vec3 H;\n  H.x = cos(phi) * sinTheta;\n  H.y = sin(phi) * sinTheta;\n  H.z = cosTheta;\n\n  vec3 up          = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n  vec3 tangent   = normalize(cross(up, N));\n  vec3 bitangent = cross(N, tangent);\n\t\n  vec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\n  return normalize(sampleVec);\n}\nfloat GeometrySchlickGGX(float NdotV, float roughness) {\n  float a = roughness;\n  float k = (a * a) / 2.0;\n  float nom   = NdotV;\n  float denom = NdotV * (1.0 - k) + k;\n  return nom / denom;\n}\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\n  float NdotV = max(dot(N, V), 0.0);\n  float NdotL = max(dot(N, L), 0.0);\n  float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n  float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n  return ggx1 * ggx2;\n}\n\nvec2 BRDF(float NdotV, float roughness) {\n  vec3 V;\n  V.x = sqrt(1.0 - NdotV*NdotV);\n  V.y = 0.0;\n  V.z = NdotV;\n\n  float A = 0.0;\n  float B = 0.0; \n\n  vec3 N = vec3(0.0, 0.0, 1.0);\n    \n  const uint SAMPLE_COUNT = 1024u;\n  for(uint i = 0u; i < SAMPLE_COUNT; ++i) {\n    vec2 Xi = Hammersley(i, SAMPLE_COUNT);\n    vec3 H = ImportanceSampleGGX(Xi, N, roughness);\n    vec3 L = normalize(2.0 * dot(V, H) * H - V);\n\n    float NdotL = max(L.z, 0.0);\n    float NdotH = max(H.z, 0.0);\n    float VdotH = max(dot(V, H), 0.0);\n\n    if(NdotL > 0.) {\n      float G = GeometrySmith(N, V, L, roughness);\n      float G_Vis = (G * VdotH) / (NdotH * NdotV);\n      float Fc = pow(1.0 - VdotH, 5.0);\n\n      A += (1. - Fc) * G_Vis;\n      B += Fc * G_Vis;\n    }\n  }\n  return vec2(A, B) / float(SAMPLE_COUNT);\n}\n\n\nvoid mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 direction) {\n   if (iFrame > 2) discard;\n  \n  vec2 uv = sphereToUv(direction);\n  fragColor = vec4(BRDF(uv.x, uv.y), 0, 1);\n}","name":"Cube A","description":"","type":"cubemap"}]}