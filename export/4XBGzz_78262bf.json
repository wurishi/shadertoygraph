{"ver":"0.1","info":{"id":"4XBGzz","date":"1708100925","viewed":57,"name":"Shader 3: Through the Dune","username":"JoeyBamboozles","description":"Game Engines Assignment 1 Part 1","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["gameengines"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Background color\nvec3 getSkyColor(vec3 rayDirection) \n{\n    float distanceAcrossRay = 0.5 * (rayDirection.y + 1.0);\n    return mix(vec3(1.0, 0.5, 0.0), vec3(0.263,0.541,0.957), distanceAcrossRay);\n}\n\n// Ground creation and size \nfloat map(vec3 currentPointOnRay) \n\n{\n    return currentPointOnRay.y - sin(currentPointOnRay.x*10.0)*0.1 - sin(currentPointOnRay.z*10.0)*0.1;\n}\n\n// Use of raymarching \nvec3 rayMarch(vec3 rayOrigin, vec3 normalizedRayDirection) \n{\n    float distanceAcrossRay = 0.0;\n    \n    // loop that steps a ray forward until it hits the ground or max steps\n    // Then returns the hit pointâ€™s color\n    for(int i=0; i<64; i++) \n    {\n        vec3 currentPointOnRay = rayOrigin + normalizedRayDirection * distanceAcrossRay;\n        float distanceToNearestSurface = map(currentPointOnRay);\n        if(distanceToNearestSurface < 0.0) \n        {\n            // Ground Color\n            return vec3(0.6, 0.4, 0.2) + vec3(0.4, 0.2, 0.1) * sin(vec2(currentPointOnRay.x, currentPointOnRay.z)*10.0).xxy;\n        }\n        \n        // If ray has yet to hit the ground then move the ray forward by its height\n        distanceAcrossRay += distanceToNearestSurface;\n    }\n    \n    // After 64 steps has passed the color of the sky in the direction of the ray is returned\n    return getSkyColor(normalizedRayDirection);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    // Normalization of the fragment coordinates \n    vec2 uv = fragCoord / iResolution.xy - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n       \n    // Camera postion    \n    vec3 rayOrigin = vec3(-0.15, 0.1, -iTime);\n   \n    // Ray direction\n    vec3 normalizedRayDirection = normalize(vec3(uv, -1.0));\n    \n    //Color of the pixel that is determined by raymarching\n    vec3 color = rayMarch(rayOrigin, normalizedRayDirection);\n\n    // Final color output\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}