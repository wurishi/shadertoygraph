{"ver":"0.1","info":{"id":"cdGBDt","date":"1698752825","viewed":55,"name":"GGX Sphere and Floor","username":"CycloneFox","description":"(Sorry, Path tracing is not included)\nfor learning","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["wip"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159265359;\n\nstruct Material\n{\n    vec3 BaseColor;\n    float Metallic;\n    float Roughness;\n    float Alpha;\n};\n\nstruct Plane\n{\n    vec3 PlaneP;\n    vec3 n;\n    Material Mat;\n};\n\nstruct Sphere\n{\n    vec3 c;\n    float r;\n    Material Mat;\n};\n\nstruct SDResult\n{\n    float d;\n    vec3 n;\n    Material Mat;\n};\n\n// hash\nuvec3 k = uvec3(0x456789abu, 0x6789ab45u, 0x89ab4567u);\nuvec3 u = uvec3(1, 2, 3);\nconst uint UINT_MAX = 0xffffffffu;\nuvec3 uhash33(uvec3 n)\n{\n    n ^= (n.yzx << u);\n    n ^= (n.yzx >> u);\n    n *= k;\n    n ^= (n.yzx << u);\n    return n * k;\n}\n\nfloat GTable3(vec3 Lattice, vec3 p)\n{\n    uvec3 n = floatBitsToUint(Lattice);\n    uint idx = uhash33(n).x >> 28;\n    float u = idx < 8u ? p.x : p.y;\n    float v = idx < 4u ? p.y : idx == 12u || idx == 14u ? p.x : p.z;\n    return ((idx & 1u) == 0u ? u : -u) + ((idx & 2u) == 0u ? v : -v);\n}\n\nfloat PNoise31(vec3 p)\n{\n    vec3 n = floor(p);\n    vec3 f = fract(p);\n    float[8] v;\n    for(int i = 0; i < 2; ++i)\n    {\n        for(int j = 0; j < 2; ++j)\n        {\n            for(int k = 0; k < 2; ++k)\n            {\n                v[i + 2 * j + 4 * k] = GTable3(n + vec3(i, j, k), f - vec3(i, j, k)) * 0.70710678;\n            }\n        }\n    }\n\n    f = f * f * f * (10.0 - 15.0 * f + 6.0 * f * f);\n    float[2] w;\n    for(int i = 0; i < 2; ++i)\n    {\n        w[i] = mix(mix(v[4 * i], v[4 * i + 1], f[0]), mix(v[4 * i + 2], v[4 * i + 3], f[0]), f[1]);\n    }\n\n    return 0.5 * mix(w[0], w[1], f[2]) + 0.5;\n}\n\nfloat Warp31(vec3 p, float g)\n{\n    float val = 0.f;\n    for(int i = 0; i < 4; ++i)\n    {\n        val = PNoise31(p + g * vec3(cos(2.0 * PI * val), sin(2.0 * PI * val), cos(2.0 * PI * val)));\n    }\n\n    return val;\n}\n\n// rotation functions\nvec3 EulerRotation(vec3 p, vec3 t)\n{\n    mat3x3 Rotation = mat3x3(\n        vec3(cos(t.y) * cos(t.z), sin(t.x) * sin(t.y) * cos(t.z) - cos(t.x) * sin(t.z), cos(t.x) * sin(t.y) * cos(t.z) + sin(t.x) * sin(t.y)),\n        vec3(cos(t.y) * sin(t.z), sin(t.x) * sin(t.y) * sin(t.z) + cos(t.x) * cos(t.z), cos(t.x) * sin(t.y) * sin(t.z) - sin(t.x) * cos(t.z)),\n        vec3(-sin(t.y), sin(t.x) * cos(t.y), cos(t.x) * cos(t.y))\n    );\n\n    return p * Rotation;\n}\n\nfloat text(vec2 st)\n{\n    return mod(floor(st.s) + floor(st.t), 2.0);\n}\n\nfloat SDPlane(vec3 p, Plane Pl)\n{\n    return dot((p - Pl.PlaneP), Pl.n);\n}\n\nfloat SDSphere(vec3 p, Sphere Sp)\n{\n    return length(p - Sp.c) - Sp.r;\n}\n\nSDResult Scene(vec3 p, Plane Pl, Sphere Sp)\n{\n    SDResult Res;\n    if(SDSphere(p, Sp) < SDPlane(p, Pl))\n    {\n        Res.d = SDSphere(p, Sp);\n        Res.n = normalize(p - Sp.c);\n        Res.Mat = Sp.Mat;\n    }\n    else\n    {\n        Res.d = SDPlane(p, Pl);\n        Res.n = Pl.n;\n        Res.Mat = Pl.Mat;\n        float WarpedVal = Warp31(vec3(p.xz, 8.f * sin(0.25f * iTime)), 1.25f); \n        Res.Mat.BaseColor = vec3(\n        smoothstep(0.3f, 0.7f, WarpedVal), \n        smoothstep(0.32f, 0.7f, WarpedVal), \n        smoothstep(0.45f, 0.8f, WarpedVal));\n    }\n\n    return Res;\n}\n\nvec3 SchlickFresnel(vec3 Specular, float VH)\n{\n    return Specular + (1.f - Specular) * pow((1.f - VH), 5.f);\n}\n\nfloat D_GGX(float m2, float NH)\n{\n    float f = (NH * m2 - NH) * NH + 1.f;\n    return m2 / (PI * f * f);\n}\n\nfloat G2_Smith(float NL, float NV, float a)\n{\n    float NL2 = NL * NL;\n    float NV2 = NV * NV;\n\n    float Lambda_V = (-1.f + sqrt(a * (1.f - NV2) / NV2 + 1.f)) * 0.5f;\n    float Lambda_L = (-1.f + sqrt(a * (1.f - NL2) / NL2 + 1.f)) * 0.5f;\n\n    return 1.f / (1.f + Lambda_L + Lambda_V);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = 2.f * (fragCoord.xy) / min(iResolution.x, iResolution.y) - 1.f;\n\n    Plane Pl;\n    Pl.PlaneP = vec3(0.f);\n    Pl.n = vec3(0.f, 1.f, 0.f);\n    Pl.Mat.BaseColor = vec3(1.f);\n    Pl.Mat.Metallic = 0.2f;\n    Pl.Mat.Roughness = 0.3f;\n    Pl.Mat.Alpha = 1.f;\n\n    Sphere Sp;\n    Sp.c = vec3(0.f, 1.f, 0.f);\n    Sp.r = 1.f;\n    Sp.Mat.BaseColor = vec3(1.f, 0.2f, 0.f);\n    Sp.Mat.Metallic = 0.5f;\n    Sp.Mat.Roughness = 0.2f;\n    Sp.Mat.Alpha = 1.f;\n\n    vec3 CameraPos = vec3(0.f, 2.f, 5.f);\n    vec3 CameraDir = vec3(0.f, 0.f, -1.f);\n    vec3 CameraUp = vec3(0.f, 1.f, 0.f);\n    vec3 CameraRight = cross(CameraDir, CameraUp);\n    float ScreenDist = 1.f;\n    vec3 Ray = CameraRight * p.x + CameraUp * p.y + CameraDir * ScreenDist;\n    vec3 RayPos = Ray + CameraPos;\n    Ray = normalize(Ray);\n\n    vec3 LPos = vec3(0.f, 3.f, 3.f);\n    LPos = EulerRotation(LPos, vec3(0.f, iTime * PI / 3.f, 0.f));\n\n    fragColor.rgb = vec3(0.f);\n\n    for(int i = 0; i < 50; ++i)\n    {\n        if(Scene(RayPos, Pl, Sp).d > 0.001f)\n        {\n            RayPos += Ray * Scene(RayPos, Pl, Sp).d;\n            fragColor.rgb = vec3(0.f);\n        }\n        else\n        {\n            SDResult Res = Scene(RayPos, Pl, Sp);\n            vec3 N = Res.n;\n            vec3 L = normalize(LPos - RayPos);\n            vec3 V = normalize(CameraPos - RayPos);\n            vec3 H = normalize(V + L);\n\n            float NH = clamp(dot(N, H), 0.f, 1.f);\n            float NV = clamp(dot(N, V), 0.f, 1.f);\n            float NL = clamp(dot(N, L), 0.f, 1.f);\n            float VH = clamp(dot(V, H), 0.f, 1.f);\n\n            vec3 Kd = Res.Mat.BaseColor * (1.f - Res.Mat.Metallic);\n            vec3 Diffuse = Kd * (1.0 / PI);\n\n            vec3 Ks = Res.Mat.BaseColor * Res.Mat.Metallic;\n            float a = Res.Mat.Roughness * Res.Mat.Roughness;\n            float m2 = a * a;\n\n            float D = D_GGX(m2, NH);\n            float G2 = G2_Smith(NL, NV, a);\n            vec3 Fr = SchlickFresnel(Ks, NL);\n\n            vec3 Specular = (D * G2 * Fr) / (4.f * NV * NL);\n\n            fragColor = vec4(Res.Mat.BaseColor * (Diffuse + Specular) * NL, Res.Mat.Alpha);\n            break;\n        }\n    }\n}","name":"Image","description":"","type":"image"}]}