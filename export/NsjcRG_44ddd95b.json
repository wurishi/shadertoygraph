{"ver":"0.1","info":{"id":"NsjcRG","date":"1643704819","viewed":93,"name":"BeatCube","username":"namanonamako","description":"raymarch","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 lightDir = normalize(vec3(.25, .5, -.5));\nfloat bpm;\n\nmat2 rot(float a){\n\tfloat s = sin(a), c = cos(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat sdBox(vec3 p, vec3 b){\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, 0.)) + min(max(max(d.x, d.y), d.z), 0.);\n}\n\nfloat sdFloor(vec3 p, vec3 n, float h){\n\treturn dot(p, n) - h;\n}\n\nconst float PI = acos(-1.);\n\nvec2 compare(vec2 d1, vec2 d2){\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\nfloat rand(float a){\n    return fract(sin(a) * 3249.432);\n}\n\nvec2 map(vec3 p, float mode){\t\n\t\n\tfloat d1 = 10.;\n\tfloat size = .5;\n    vec3 q = p;\n        \n\tint itr = 3;\n\tfor(int i = 0; i < itr; i++){\n\t\tfor(int j = 0; j < itr; j++){\n\t\t\tfor(int k = 0; k < itr; k++){\n                q = p;\n                q.xz *= rot(iTime);\n                \n\t\t\t\tvec3 offset = vec3(float(i), float(j), float(k)) - 1.;\n                q += - offset * (1. + smoothstep(.6, 1.,cos((bpm * 2. + .25) * PI) *.5 +.5)) * size;\n                q.xy *= rot((floor(bpm) + smoothstep(.6, 1., fract(bpm)))* PI / 2.);\n                q.xz *= rot((floor(bpm) + smoothstep(.6, 1., fract(bpm)))* PI / 2.);\n\t\t\t\td1 = min(d1, sdBox(q , vec3(.5 * size)));\n\t\t\t}\n\t\t}\n\t}\n\t\n    q = p;\n\tq.yz *= rot(-q.z * .02);\n\tfloat d2 = sdFloor(q, vec3(0., 1., 0.), -3.);\n    \n    float width = .025;\n    size = 1.65;\n    itr = 3;\n    float d3 = 100.;\n    for(int i = 0; i < itr; i++){\n        q = p;\n        q.xz *= rot(iTime * .75 + rand(float(i)) * .5 * sin(iTime * .6 + rand(float(i))));\n        q.xy *= rot(sin(iTime * .8 * (.5 + rand(float(i) * 2.))) * .2);\n        float d3_1 = sdBox(q, vec3(size, width, size));\n        float d3_2 = sdBox(q, vec3(size - width, 1., size - width));\n        float d3_3 = max(d3_1, -d3_2);\n        d3 = min(d3, d3_3);\n    }\n    \n    return mix(compare(compare(vec2(d1, 0.), vec2(d3, 1.6)), vec2(d2, 1.)), compare(vec2(d1, 0.), vec2(d2, 1.)), mode);\n    \n}\n\nvec3 genNormal(vec3 p){\n\tvec2 d = vec2(0.001, 0.);\n\treturn normalize(vec3(\n\t\tmap(p + d.xyy, 0.).x - map(p - d.xyy, 0.).x,\n\t\tmap(p + d.yxy, 0.).x - map(p - d.yxy, 0.).x,\n\t\tmap(p + d.yyx, 0.).x - map(p - d.yyx, 0.).x\n\t\t));\n}\n\nfloat genShadow(vec3 ro, vec3 rd){\n\tfloat c = 0.001;\n\tfloat h = 0.;\n\tfloat r = 1.;\n\tfloat shadowCoef = .5;\n\tfor(int i = 0; i < 40; i++){\n\t\th = map(ro + rd * c, 1.).x;\n\t\tif(h < 0.001){\n\t\t\treturn shadowCoef;\n\t\t}\n        if(c > 10.){\n            break;\n        }\n\t\tr = min(r, h * 32. / c);\n\t\tc += h;\n\t}\n\treturn mix(shadowCoef, 1., r);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bpm = iTime * 120. / 60.;\n\n\tvec2 p = ( fragCoord.xy * 2. - iResolution.xy )/ min(iResolution.x, iResolution.y);\n\n\tvec3 color = vec3(0.0);\n\t\n\tvec3 cPos = vec3(0., 1.5, -3.);\n\tvec3 t = vec3(0., 0., 0.);\n\tvec3 fwd = normalize(t - cPos);\n\tvec3 up = normalize(vec3 (0., 1., 0.));\n\tvec3 side = normalize(cross(up, fwd));\n\tup = normalize(cross(fwd, side));\n\tvec3 rd = normalize(p.x * side + p.y * up + fwd);\n\t\n\tfloat d;\n    vec2 dd;\n\t\n\tfor(int i = 0; i < 100; i++){\n\t\tdd = map(cPos + d * rd, 0.);\n\t\tif(dd.x < 0.001){\n\t\t\tbreak;\n\t\t}\n\t\td += dd.x;\n\t}\n\t\n\tvec3 ip = cPos + d * rd;\n\t\n\tif(dd.x < 0.001){\n        //light\n\t\tvec3 normal = genNormal(ip);\n\t\t\n\t\tfloat diff = clamp(dot(normal, lightDir), 0., 1.);\n\t\tfloat amb = .5;\n\t\t\n\t\tfloat shadow = genShadow(ip + normal * 0.01, lightDir);\n\t\t\n\t\tvec3 diffCol = vec3(.8, .7, .4);\n\t\tvec3 ambCol = vec3(.3, .4, .5);\n\t\t\n        // material\n        vec3 mat;\n        if(dd.y == 0.){\n            color += diff;\n            color += amb * .8;\n        \n            vec3 mate1 = vec3(255., 187., 221.) / 255.;\n            vec3 mate2 = vec3(255., 255., 187.) / 255.;\n            vec3 mate3 = vec3(153., 221., 255.) / 255.;\n\n\n            vec3 mat_norm = normal;\n\n            mat_norm.xz *= rot(iTime);\n            mat_norm.xy *= rot((floor(bpm) + smoothstep(.6, 1., fract(bpm)))* PI / 2.);\n            mat_norm.xz *= rot((floor(bpm) + smoothstep(.6, 1., fract(bpm)))* PI / 2.);\n\n            mat = step(.5, abs(mat_norm).x) * mate1 + step(.5, abs(mat_norm).y) * mate2 + step(.5, abs(mat_norm).z) * mate3;\n        }\n        if(dd.y == 1.){\n            color += 1.;\n        \n            mat = vec3(238., 136., 187.) / 255.;\n        }\n        if(dd.y == 1.6){\n            color += 1.;\n        \n            mat = vec3(.95);\n        }\n        \n        color *= mat;\n        \n        vec3 shadecol = vec3(1., 102., 187.) / 255.;\n        color = mix(shadecol, color, shadow);\n\t}\n\t\n\t\t\n\tfragColor = vec4( color, 1.0 );\n}","name":"Image","description":"","type":"image"}]}