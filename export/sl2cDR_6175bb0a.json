{"ver":"0.1","info":{"id":"sl2cDR","date":"1649547322","viewed":144,"name":"Dog God's simple raymarcher","username":"dog_god","description":"Soft shadows + Ambient occlusion + orbiting light thing.\nNot much to say, other than that this really needs optimization","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 tex3D(sampler2D tex, vec3 p, vec3 n)\n{\n    vec3 blending = abs(n);\n    blending = normalize(max(blending, 0.00001));\n    \n    // normalized total value to 1.0\n    float b = (blending.x + blending.y + blending.z);\n    blending /= b;\n    \n    vec4 xaxis = texture(tex, p.yz);\n    vec4 yaxis = texture(tex, p.xz);\n    vec4 zaxis = texture(tex, p.xy);\n    \n    // blend the results of the 3 planar projections.\n    return (xaxis * blending.x + yaxis * blending.y + zaxis * blending.z).rgb;\n}\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\nfloat sdPyramid( vec3 p, float h)\n{\n  float m2 = h*h + 0.25;\n    \n  p.xz = abs(p.xz);\n  p.xz = (p.z>p.x) ? p.zx : p.xz;\n  p.xz -= 0.5;\n\n  vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n  float s = max(-q.x,0.0);\n  float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n  float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n  float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n  float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n  return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n}\nfloat plane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\nfloat Sphere(vec3 center, float radius,vec3 slice)\n    {\n        return length(center-slice)-radius;\n    }\nfloat Scene ( vec3 pos){\n    float f = Sphere(vec3(-1,-1,0),1.,pos);\n    f = min(f,Sphere(vec3(1,-1,1),1.,pos-vec3(1.,0.,0.)));\n    f = min(f,sdBoxFrame(pos-vec3(0.,0.,1.),vec3(1.,2.,1.),0.1)-0.025);\n    f = min(f,plane(pos,vec3(0.,1.,0.),2.));\n    f = min(f, sdPyramid(pos-vec3(0.,-1.99,1.),1.));\n    return f;\n}\nvoid Rotate( inout vec3 vector, vec2 angle ) //rotation matrix\n{\n\tvector.yz = cos(angle.y)*vector.yz\n\t\t\t\t+sin(angle.y)*vec2(-1,1)*vector.zy;\n\tvector.xz = cos(angle.x)*vector.xz\n\t\t\t\t+sin(angle.x)*vec2(-1,1)*vector.zx;\n}\nfloat calcAO( in vec3 pos, in vec3 nor )//ambient occlusion code, from inigo quilez's website\n{\n\tfloat occ = 0.0;\n    float sca = 0.5;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.001 + 0.4*float(i)/4.0;\n        float d = Scene( pos + h*nor );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 1.5*occ, 0.0, 1.0 );    \n}\nfloat shadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )//soft shadow code, from inigo quilez's website\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        float h = Scene(ro + rd*t);\n        if( h<0.01 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\nvec3 normal;\nvec3 lpos = vec3(1.,2.,3.);\n    vec4 Raymarch(vec3 pos,vec3 ray){\n    float d;\n    for (int i = 0; i < 1000; i++)//number of raymarching iterations\n    {\n        float h = Scene(pos);\n        d = d + h;\n        if (h < 0.01){\n            normal.x = (Scene(pos+vec3(0.01,0.0,0.0))-Scene(pos-vec3(0.01,0.0,0.0)))/0.01;//generate normals\n            normal.y = (Scene(pos+vec3(0.0,0.01,0.0))-Scene(pos-vec3(0.0,0.01,0.0)))/0.01;\n            normal.z = (Scene(pos+vec3(0.0,0.0,0.01))-Scene(pos-vec3(0.0,0.0,0.01)))/0.01;\n            break;\n        }\n        if (h > 40.){\n        break;\n        }\n        pos += ray*h;\n    }\n    return vec4(normalize(normal),d);\n    }\nfloat g(vec3 pos){return Sphere(lpos,1.,pos);}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    \n    \n    lpos = vec3(cos(iTime)*3.,sin(iTime/2.)*2.+3.,sin(iTime)*3.);\n    float mx = iMouse.x/iResolution.x;\n    float my = iMouse.y/iResolution.y;//normalized mouse coords\n    \n    vec2 angle = vec2(iTime,0.3);\n    angle = -(vec2(mx,my)-.5)*3.14*2.;\n    vec3 pos = vec3(0.,0.,-13);//pos is camera position\n    vec3 ray = vec3((fragCoord-iResolution.xy*.5)/iResolution.x,1.); //ray is ray direction\n    Rotate(pos,angle);\n    Rotate(ray,angle);\n    float sdf = Scene(ray*8.+pos);\n    fragColor = vec4(1.);\n    vec4 render = Raymarch(pos,ray);\n    vec3 hal = normalize(lpos-(pos+render.w*ray));//direction to light source\n    vec3 hit = pos+render.w*ray;\n    //everything below is to create the nice-ish looking picture\n    fragColor = vec4(clamp(dot(hal,render.xyz),0.,1.));//dot product shading\n    float shado = (shadow(hit,normalize(lpos-hit),.1,100.,20.));//generate shadow (to reuse later)\n    fragColor = fragColor * clamp((shado+0.4),0.,1.)+vec4(0.05,0.,0.05,.0) *(1.-fragColor);//add shadows\n    float spe = pow( clamp( dot( render.xyz, hal ), 0.0, 1.0 ),16.0)* \n                    shado *\n                    (0.4 + .8*pow( clamp(1.0+dot(hal,ray),0.0,1.0), 5.0 ));//specular highlight\n    fragColor = fragColor * vec4(calcAO(hit,render.xyz));//ambient occlusion\n    fragColor = fragColor * vec4(tex3D(iChannel0,hit/10.,render.xyz),0.);//add texture\n    fragColor = fragColor + spe*dot(-render.xyz,normalize(ray));//add specular\n    float j = 0.;\n    vec3 loc = pos;\n    for (int b = 0; b < 100; b++){\n    float k = Sphere(lpos,.2,loc);//another raymarching loop to add the sphere. Really bad idea, ngl\n    j = j+k;\n    loc += ray * k;\n     if (k > render.w){\n     break;\n     }\n    if (k < .5){\n    fragColor = vec4(100.);\n    break;\n    }\n    if (j > 100.){\n    break;\n    }\n    \n    }\n}","name":"Image","description":"","type":"image"}]}