{"ver":"0.1","info":{"id":"ltlfWB","date":"1513252131","viewed":210,"name":"\"Lambert's problem\" in velocity","username":"blalele","description":"In white is the locus of the points where, starting with a velocity (1,0,0) and with an attraction body with mu = 1, the resulting Keplerian orbit include the point marked by the red cross.\n","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["orbitalmechanics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float cosh_shad(in float ang) {\n    float res;\n    res = (exp(ang)+exp(-ang))/2.0;\n    return(res);\n}\n\nfloat sinh_shad(in float ang) {\n    float res;\n    res = (exp(ang)-exp(-ang))/2.0;\n    return(res);\n}\n\nfloat atanh_shad(in float ang) {\n    float res;\n    res = log((1.0+ang)/(1.0-ang))/2.0;\n    return(res);\n}\n\nfloat acosh_shad(in float ang) {\n    float res;\n    res = log(ang + sqrt(ang*ang-1.0));\n    return(res);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float pi = 3.1415927;\n    vec3 Vc = vec3(1.0,0.0,0.0);\n    float mu = 1.0;\n    float size = 0.1;\n    vec3 posvis = vec3(0.5*cos(iTime),0.5*sin(iTime),0.0);\n    \n    float maxdim = max(iResolution.x,iResolution.y);\n    float mindim = min(iResolution.x,iResolution.y);\n    float rat = mindim/maxdim;\n\tvec3 uv = vec3(fragCoord.xy,0.0) / maxdim;\n    vec3 X = 8.0*(uv - vec3(0.5,rat/2.0,0.0));\n    vec3 h = cross(X, Vc);\n    float hnorm = length(h);\n    float r = length(X);\n    float vel = length(Vc);\n    float sE = vel*vel/2.0 - mu/r;\n    float SMA = - mu/(2.0*sE);\n    float mean_mo = sqrt(mu/pow(abs(SMA),3.0));\n    vec3 Ecv = cross(Vc,h)/mu - X/r;\n    float ECC = length(Ecv);\n    float arglat;\n    float INC;\n    if (h.z>0.0)\n    {arglat = 2.0*pi+atan(X.y,X.x);\n     INC = 0.0;}\n    else\n    {arglat = 2.0*pi-atan(X.y,X.x);\n     INC = pi;}\n    float LPE = 0.0;\n    float MNA = 0.0;\n    float minax = 0.0;\n    float N;\n    float M = 0.0;\n    float E;\n    float nE;\n    float nH;\n    vec3 nX;\n    vec3 nVc;\n    float nr;\n    float nu = 0.0;\n    float nnu;\n    float ntest;\n    float Etest;\n    float f;\n    float cosnu;\n    if (ECC>0.0000001)\n    {\n        cosnu = (SMA*(1.0-ECC*ECC)-r)/(ECC*r);\n        if (cosnu>1.0)\n        {cosnu = 1.0;}\n        else\n        {if (cosnu<-1.0) {cosnu=-1.0;}}\n        if (dot(X,Vc)>0.0)\n        {nu = acos(cosnu);}\n        else\n        {nu = 2.0*pi-acos(cosnu);}\n        LPE = mod(arglat - nu, 2.0*pi);\n        if (sE<0.0)\n        {\n            E = mod(2.0*atan(sqrt(1.0-ECC)*sin(nu/2.0),sqrt(1.0+ECC)*cos(nu/2.0)),2.0*pi);\n            MNA = E - ECC*sin(E);\n            minax = SMA*sqrt(1.0-ECC*ECC);\n        }\n        else\n        {\n            E = 2.0*atanh_shad(sqrt((ECC-1.0)/(1.0+ECC))*tan(nu/2.0));\n            MNA = ECC*sinh_shad(E)-E;\n            minax = SMA*sqrt(ECC*ECC-1.0);\n        }\n    }\n    else\n    {\n    \tvec3 r_un = normalize(X);\n    \tcosnu = dot(vec3(1.0,0.0,0.0),r_un);\n        LPE = 0.0;\n        if (X.y>0.0)\n        {MNA = acos(cosnu);}\n        else\n        {MNA = 2.0*pi-acos(cosnu);}\n    }\n    mat3 mat_rot = mat3(\n        cos(LPE), sin(LPE)*cos(INC), 0.0,\n        -sin(LPE), cos(LPE)*cos(INC), 0.0,\n        0.0, 0.0, cos(INC)\n    );\n    vec3 posvisO = posvis*mat_rot + vec3(SMA*ECC,0.0,0.0);\n    bool touch = false;\n    \n    if (sE<0.0)\n    \t{touch = (abs(pow(posvisO.x/SMA,2.0)+pow(posvisO.y/minax,2.0)-1.0)<(0.02/abs(SMA)));}\n    else\n        {touch = (abs(pow(posvisO.x/SMA,2.0)-pow(posvisO.y/minax,2.0)-1.0)<(0.02/abs(SMA)));}\n    \n    float per = (1.0-ECC)*SMA;\n    bool crashed;\n    \n    if (touch)\n    {fragColor = vec4(1.0,1.0,1.0,1.0);}\n    else\n    {fragColor = vec4(0.0,0.0,0.0,1.0);}\n    \n    \n    //fragColor = vec4(atan(nX)/pi+vec3(0.5,0.5,0.0),1.0);\n    //fragColor = vec4(atan(nr)*2.0/pi,0.0,0.0,1.0);\n    //if (crashed)\n    //{fragColor = vec4(0.0,1.0,1.0,1.0);}\n    if (length(X-vec3(0.0,0.0,0.0))<size)\n    {fragColor = vec4(0.0,0.0,1.0,1.0);}\n    if (((abs(X.x-posvis.x)<0.01)&&(abs(X.y-posvis.y)<0.05))||((abs(X.x-posvis.x)<0.05)&&(abs(X.y-posvis.y)<0.01)))\n    {fragColor = vec4(1.0,0.0,0.0,1.0);}\n}","name":"Image","description":"","type":"image"}]}