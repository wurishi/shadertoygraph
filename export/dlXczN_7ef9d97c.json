{"ver":"0.1","info":{"id":"dlXczN","date":"1690466091","viewed":105,"name":"halftone zoom inspired by posy","username":"HaleyHalcyon","description":" er","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["halftone"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// For GIF export: enable dither to reduce color count te 8\n// Set to 2 for noise\n#define DITHER 2\n#if DITHER == 1\nfloat threshold(vec2 xyf) {\n    ivec2 xy = ivec2(xyf) & 3;\n    return (float(\n        + ((xy.y >> 1) & 1)\n        + ((xy.x & 2) ^ (xy.y & 2))\n        + ((xy.y & 1) << 2)\n        + ((((xy.x) & 1) ^ (xy.y & 1)) << 3)\n    ) + 0.5) / 16.;\n}\n#endif\n#if DITHER == 2\nfloat threshold(vec2 xy) {\n    return fract(\n        sin(xy.x + 4.6 * xy.y) +\n        cos(2.3 * xy.x + 9.2 * xy.y) +\n        log(xy.x * 1.7 - xy.y * 0.7)\n    );\n}\n#endif\n\nconst float PI_2 = acos(-1.) * .5;\n#define ZIG(x) (1. - abs(1. - 2. * fract(x)))\n#define ROT(x) mat2x2(cos(x + PI_2 * vec4(0, 1, -1, 0)))\n#define HEX(x) vec3((ivec3(x) >> ivec3(16, 8, 0)) & 255) / 255.\n\nfloat depthFunc( float depth ) {\n    return smoothstep(\n        0., 1., min(depth, 3. - depth)\n    );\n}\n\nvec3 colormap(vec3 rgb) {\n    const vec3 c000 = HEX(0x010a31);\n    const vec3 c001 = HEX(0x000068);\n    const vec3 c011 = HEX(0x009be8);\n    const vec3 c010 = HEX(0x20a220);\n    const vec3 c110 = HEX(0xfff100);\n    const vec3 c100 = HEX(0xcb1018);\n    const vec3 c101 = HEX(0xeb0072);\n    const vec3 c111 = HEX(0xffffff);\n    \n    vec3 c00x = mix(c000, c001, rgb.b);\n    vec3 c01x = mix(c010, c011, rgb.b);\n    vec3 c10x = mix(c100, c101, rgb.b);\n    vec3 c11x = mix(c110, c111, rgb.b);\n    \n    vec3 c0xx = mix(c00x, c01x, rgb.g);\n    vec3 c1xx = mix(c10x, c11x, rgb.g);\n    \n    return mix(c0xx, c1xx, rgb.r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2. * fragCoord - iResolution.xy) / length(iResolution.xy);\n\n    float t = fract(iTime / 8.);\n    \n    // zoom level per layer\n    const float LEVEL = 6.;\n    \n    uv *= exp2(10. - t * LEVEL);\n    \n    // Time varying pixel color\n    vec4 cmyk = vec4(0);\n    \n    const mat2x2[] rots = mat2x2[](\n        ROT(1. / 6. * PI_2),\n        ROT(-1./ 6. * PI_2),\n        ROT(0.),\n        ROT(1. / 2. * PI_2)\n    );\n    \n    for (int channel = 0; channel < 4; channel++) {\n        for (float depth = 0.; depth < 3.; depth++) {\n            vec2 thisUV = uv * rots[channel] * exp2(-depth * LEVEL);\n            cmyk[channel] += smoothstep(\n                0.7, 0.75,\n                length(ZIG(thisUV))\n            ) * depthFunc(depth + t);\n        }\n    }\n    vec3 col = cmyk.xyz * cmyk.w;\n#if DITHER != 0\n    float thres = threshold(fragCoord);\n    const float STEPS = 1.;\n    col = (\n        floor(col * STEPS) +\n        step(vec3(thres), fract(col * STEPS))\n    ) / STEPS;\n#endif\n    col = colormap(col);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}