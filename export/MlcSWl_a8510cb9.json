{"ver":"0.1","info":{"id":"MlcSWl","date":"1482080311","viewed":443,"name":"Mandel Reef","username":"huwb","description":"Another exploration of shape with the formula i hacked together for [url=https://www.shadertoy.com/view/Xt3SWs]Meltdown[/url] . This time much closer to the familiar mandelbrot. Mouse to explore shape.","likes":35,"published":1,"flags":32,"usePreview":0,"tags":["fractal","mandelbrot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // blur code borrowed from wriggly: https://www.shadertoy.com/view/ld3SW7\n    \n    fragColor = vec4(0.);\n    \n    float uvr = 2.2*length(uv-.5);\n    float v = pow(uvr,2.);\n    v = max(v,0.05);\n    vec3 bg = .15-.07*vec3(uvr);\n    bg.r *= .75;\n    bg = vec3(1.);\n    \n    // crude blur. not quite box, cut off the corners to reduce boxyness\n    #define R 3.\n    float twt = 0.;\n    for( float i = -R; i <= R; i++ )\n    {\n        for( float j = -R; j <= R; j++ )\n        {\n            if( abs(i)+abs(j) > 5. ) continue; // corners not welcome\n            \n            vec4 s = texture( iChannel0, uv + 1.*v*vec2(i,j)/iResolution.xy );\n            s = smoothstep(0.,.5,s); // blow it out a bit\n            \n\t\t    fragColor += s;\n            twt += 1.;\n        }\n    }\n    fragColor /= twt;\n    fragColor *= 2.;\n    \n    // bg, vign\n    fragColor.xyz = .99*vec3(1.,.98,.97) - fragColor.xyz;\n    fragColor.xyz *= pow(1. - 1.9*dot(uv-.5,uv-.5),.07);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAX_ITERS 14.0\n\nfloat intersectsLayer( vec2 fragCoord, float layer, out float smallest )\n{\n    float mo = -.4;\n    if( iMouse.z > 0. ) mo = (.5-iMouse.x/iResolution.x)*2.;\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 c = (cos(.35*iTime)+20.) * (2.0 * uv - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);\n    c /= 10.+5.*cos(.1*iTime);\n    c.y -= 1.2;\n    c.x -= 3.;\n\tvec2 z = vec2( 0., 0.*iTime );\n\tfloat escapeRadius = 44.;\n    \n\tfor (float i = 0.; i < MAX_ITERS; ++i)\n    {\n\t\tvec2 newz = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n        float div = mo*0.01*dot(newz,z) - 2.;\n        z = newz / div; // added hack, inspired by kaliset\n        \n        // is this the layer we're interested in?\n        if( i + 1. == layer )\n        {\n\t        // check for escape, if so then the pixel has hit this layer.\n            // also, vary escape radius over time to add a little more interest\n            if( dot(z,z) > escapeRadius*escapeRadius )\n            {\n                return 1.;\n            }\n            else\n            {\n                return 0.;\n            }\n        }\n        \n        smallest = min( smallest, (escapeRadius*escapeRadius - dot(z,z))*layer );\n \t}\n    \n\treturn 0.;\n}\n\nvec3 shade( vec2 fragCoord )\n{\n    // process one layer of the fractal at a time so that we can apply different amounts of parallax to each\n    for( float layer = 2.; layer < MAX_ITERS; layer++ )\n    {\n        float parallaxZ = layer+1.; //parallaxZ = 4.5*parallaxZ*parallaxZ + zscr;\n        vec2 off = vec2( cos(.33*iTime), sin(.133*iTime)) * 360./parallaxZ;\n        float depth = 0., stepSz;\n        \n        \n        float sml;\n        float fractal = intersectsLayer( fragCoord + off, layer, sml );\n        if( fractal > 0. )\n        {\n            float ao = 1.;\n            ao = mix(1.,exp(.0001*sml),.5);\n            return ao*vec3(1.)*mix(vec3(.2,.2,.8)*.5,vec3(.5,.7,1.), (exp(-.25*(parallaxZ-6.))) );\n        }\n    }\n    // no hit, return bg\n    return vec3(0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // crude AA using N-Queens pattern, does the job. some kind of analytical version should be possible and could be cheaper.\n    fragColor.xyz  = shade( fragCoord + vec2(-3./8.,-1./8.) );\n    fragColor.xyz += shade( fragCoord + vec2(-1./8., 3./8.) );\n    fragColor.xyz += shade( fragCoord + vec2( 3./8., 1./8.) );\n    fragColor.xyz += shade( fragCoord + vec2( 1./8.,-3./8.) );\n    fragColor /= 4.;\n}\n","name":"Buf A","description":"","type":"buffer"}]}