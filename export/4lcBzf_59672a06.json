{"ver":"0.1","info":{"id":"4lcBzf","date":"1547317006","viewed":62,"name":"raydir","username":"caudya","description":"nslovnh","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raydir"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//camera parameters\nconst vec3 cameraPos = vec3(6, 4, -5);\nconst vec3 cameraTarget = vec3(3.0, 1.0, -8.0);\nconst float cameraFovY = 80.0;\n\nconst float distFoc = 1.0 / tan(radians(cameraFovY) / 2.0);\nconst vec3 dirCamera = normalize(cameraTarget - cameraPos);\n\n//sphere parameters\n//const vec3 spherePos = cameraTarget + cos(iTime+vec3(0.0,1.0,2.0));\nconst float sphereRadius = 1.0;\nconst vec3 sphereCol = vec3(1,0,0); //rouge\n    \n\nvec2 transfoFrag(in vec2 fragCoord);\nvoid computeCameraRayFromPixel(in vec2 uv, out vec3 rayDir);\nbool raySphere(in vec3 rayPos, in vec3 rayDir, in vec3 spherePos, in float sphereRadius);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 spherePos = cameraTarget;\n    // Normalized pixel coordinates (from x : -ratio, ratio, y : -1, 1) ratio : screenx / screeny\n    vec2 uv = transfoFrag(fragCoord);\n\n    vec3 rayPos = cameraPos;\n    vec3 rayDir;\n    \n    computeCameraRayFromPixel(uv, rayDir);\n    \n    bool res = raySphere(rayPos, rayDir, spherePos, sphereRadius);\n\n    // Output to screen\n    fragColor = vec4((res ? 1.0 : 0.0), 0.0, 0.0, 1.0);\n}\n\nvec2 transfoFrag(in vec2 fragCoord)\n{\n     vec2 uv = fragCoord/iResolution.y;\n    uv.y = uv.y * 2.0 - 1.0;\n    uv.x = uv.x * 2.0 - iResolution.x / iResolution.y;\n    \n    return uv;\n}\n\n\nvoid computeCameraRayFromPixel(in vec2 uv, out vec3 rayDir)\n{\n    vec3 posCameraPlusY = cameraPos + vec3(0, 1, 0);\n    \n    vec3 repereCameraZ = dirCamera;\n    vec3 repereCameraX = normalize(cross(vec3(0, -1, 0), repereCameraZ));\n    vec3 repereCameraY = normalize(cross(repereCameraZ, repereCameraX));\n    \n    rayDir = normalize(distFoc * repereCameraZ + uv.x * repereCameraX - uv.y * repereCameraY);\n}\n\nbool raySphere(in vec3 rayPos, in vec3 rayDir, in vec3 spherePos, in float sphereRadius)\n{\n    float a = dot(rayDir, rayDir);\n    float b = 2.0*dot(rayPos - spherePos,rayDir);\n    float c = dot(rayPos - spherePos,rayPos - spherePos)-sphereRadius*sphereRadius;\n    float d2 = b*b - 4.0*a*c;\n    return (d2 >= 0.0);\n}\n","name":"Image","description":"","type":"image"}]}