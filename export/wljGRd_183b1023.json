{"ver":"0.1","info":{"id":"wljGRd","date":"1560807435","viewed":376,"name":"[twitch] Lost Tree","username":"NuSan","description":"Shader coded live on twitch (https://www.twitch.tv/nusan_fx)\nOriginal Bonzomatic shader can be found here: http://lezanu.fr/LiveCode/LostTree.glsl","likes":20,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","tree","stars"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nShader coded live on twitch (https://www.twitch.tv/nusan_fx)\nOriginal Bonzomatic shader can be found here: http://lezanu.fr/LiveCode/LostTree.glsl\n*/\n\n#define time iTime\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nfloat noise(vec3 p) {\n  vec3 ip=floor(p);\n  p=fract(p);\n  p=smoothstep(0.0,1.0,p);\n  vec3 st=vec3(7,137,235);\n  vec4 val=dot(ip,st) + vec4(0,st.y,st.z,st.y+st.z);\n  vec4 v = mix(fract(sin(val)*5672.655), fract(sin(val+st.x)*5672.655), p.x);\n  vec2 v2 = mix(v.xz,v.yw, p.y);\n  return mix(v2.x,v2.y,p.z);\n}\n\nfloat tri(float t) {\n  return abs(fract(t)-0.5);\n}\n\nfloat smin(float a, float b, float h) {\n  float k=clamp((a-b)/h*.5+.5,0.0,1.0);\n  return mix(a,b,k) - k*(1.0-k)*h;\n}\n\nvec3 light=vec3(6,0,0);\n\nfloat at=0.0;\nfloat at2=0.0;\nfloat map(vec3 p) {\n  \n  vec3 bp=p;\n  \n  p.xz *= sign(p.y);\n  \n  float trunk = step(bp.y,0.0);\n  \n  p.y=-abs(p.y);\n  \n  float t=time*2.0;\n  float rotamount = trunk*0.5+0.5;\n  float rot2 = 0.3 + (1.0-trunk)*0.2;\n  float noi = 1.0 + (1.0-trunk)*2.0;\n  p.xy *= rot(sin(t*0.5) * 0.2 * p.y * rotamount);\n  p.zy *= rot(sin(t*0.6) * 0.25 * p.y * rotamount);\n  \n  p.y += 0.53;\n  \n  \n  p+=(noise(p*6.0)-.5)*0.05 * noi;\n  p+=(noise(p*2.0)-.5)*0.2 * noi;  \n  vec3 bp2=p;\n    \n  float d = 10000.0;\n  for(int i=0; i<7; ++i) {\n    p.xz = abs(p.xz);\n    float sizey = 0.2 - 0.005*float(i) - (1.0-trunk)*0.03;\n    float sizex = 0.53 - 0.07*float(i);\n    d = min(d, max(length(p.xz)-0.1*sizex, abs(p.y-sizey)-sizey));\n    p.xy *= rot(rot2);\n    p.zy *= rot(rot2);\n    p.y += sizey*1.9;    \n  }\n  \n  d = min(d, max(length(p.xz)-0.01, abs(p.y-0.3)-0.3));\n  \n  d += (1.0-trunk)*0.007;\n    \n  float leaf = length(p-vec3(0,0,0.1))-0.2;\n  leaf = max(leaf, 0.3-length(p-vec3(0,0.31,0)));\n  \n  leaf += -0.1+noise(bp2*3.0)/7.0 + (1.0-trunk);\n    \n  d = min(d, leaf);\n  d *= 0.5;\n  \n  float planet = length(bp-vec3(0,3,0))-3.2;\n  float tris = tri(bp.x)*0.2 + tri(bp.z*0.7+.2)*0.3 + tri(bp.z*1.8+.2)*0.1;\n  float pdist = 5.6 + tris;\n  planet = max(planet, pdist-length(bp-vec3(0,6.0,0)));\n  d=min(d, planet);\n  \n  float ast = (length(bp-light) - 1.0);\n  at += 0.2/(0.2+ast);\n  \n  float ast2 = (length(bp+light) - 1.2);\n  at2 += 0.2/(0.2+ast2);\n  \n  d=min(d, ast*0.6);\n  d=min(d, ast2*0.6);\n    \n  return d;\n}\n\nvoid cam(inout vec3 p) {\n  \n  p.yz *= rot(sin(time*.5)*0.4-0.2);\n  p.xz *= rot(time*0.2);\n  \n}\n\nvec3 sky(vec3 r) {\n  return mix(vec3(0), vec3(0.5,0.6,1.0), pow(clamp(-r.y*0.5+0.7,0.0,1.0),5.0));\n}\n\nfloat getao(vec3 p, vec3 n, float d) {\n  return clamp(map(p+n*d)/d,0.0,1.0)*0.5+0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec3 s=vec3(0,0,-8);\n  vec3 r=normalize(vec3(-uv, 0.8));\n  \n  cam(s);\n  cam(r);\n  \n  s.y -= 1.0;\n  \n  \n  \n  light.xy *= rot(time);\n  light.yz *= rot(time*.7);\n  \n  vec3 p=s;\n  float i=0.0;\n  bool outside = false;\n  for(i=0.0; i<100.0; ++i) {\n    float d=map(p);\n    if(d<0.001) {\n      i += d/0.001;\n      break;\n    }\n    if(d>100.0) {\n      outside = true;\n      break;\n    }\n    p+=r*d;\n  }\n  \n  \n  vec3 col = vec3(0);\n  \n  vec3 lcol = vec3(1.0,0.7,0.2);\n  vec3 lcol2 = vec3(0.3,1.0,0.5);\n  \n  col += pow(at * 0.1,0.6) * 0.8*lcol;\n  col += pow(at2 * 0.1,0.6) * 0.4*lcol2;\n  \n  float fog=1.0-clamp(length(p-s)/100.0,0.0,1.0);\n  \n  vec2 off=vec2(0.01,0);\n  vec3 n=normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));\n  \n  vec3 l = normalize(light-p);\n  \n  float fre = pow(1.0-abs(dot(n,r)), 4.0);\n  \n  float ao = pow(getao(p, n, 1.0) * getao(p, n, 0.5) * pow(getao(p, n, 0.05),3.0), 0.4);\n  \n  // hack: if close to one of the lights, we direct the normal toward the light to get full illumination\n  if(length(light-p)<2.0) n = l;\n  if(length(-light-p)<2.0) n = -l;\n  \n  col += max(0.0, dot(n,l)) * fog * lcol * 40.0 * ao / pow(length(light-p),2.0);\n  col += max(0.0, dot(n,-l)) * fog * lcol2 * 30.0 * ao / pow(length(-light-p),2.0);\n   \n  \n  if(outside) {\n    col += sky(r);\n    vec3 stars = vec3(smoothstep(0.0,1.0,noise(r*53.0)), smoothstep(0.0,1.0,noise(r*33.0)), smoothstep(0.0,1.0,noise(r*127.0)));\n    stars = mix(vec3(1.0), pow(stars, vec3(10.0)), 0.7);\n    col += vec3(6) * smoothstep(0.9,1.0,noise(r*120.0)) * stars;\n  } else {\n    col += sky(reflect(r,n)) * fre * ao;\n    col += sky(n) * fre * ao;\n  }\n    \n  fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}