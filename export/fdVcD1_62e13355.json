{"ver":"0.1","info":{"id":"fdVcD1","date":"1654790226","viewed":77,"name":"Simple Voronoi Demonstration","username":"HenriPK","description":"Just a Simple Voronoi Demonstration","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["voronoi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Point {\n    vec2 position;\n    vec3 value;\n};\n\nfloat sdTorus2D( vec2 p, float R, float r )\n{\n  float q = length(p)-R;\n  return abs(q)-r;\n}\n\n#define EUCLIDEAN\n\nfloat dist (vec2 a, vec2 b) {\n    #ifdef EUCLIDEAN\n        return distance(a, b);\n    #elif defined MANHATTAN\n        return abs(a.x - b.x) + abs(a.y - b.y);\n    #elif defined MAXIMUM\n        return max( abs(a.x - b.x), abs(a.y - b.y) );\n    #elif defined TORUS\n        return sdTorus2D(b - a, 0.4, 0.2);\n    #else\n        return 0.0;\n    #endif\n}\n\nfloat dist (Point a, vec2 b) {\n    return dist(a.position, b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.yy;\n    \n    // The array of all points\n    Point[] points = Point[4] (\n        Point(vec2(0.5, 0.3), vec3(1.0, 0.0, 0.5)),\n        Point(vec2(0.8, 0.4 + 0.2 * sin(iTime)), vec3(0.0, 1.0, 0.5)),\n        Point(vec2(0.3, 0.8), vec3(0.4, 0.0, 1.0)),\n        Point(iMouse.xy / iResolution.yy, vec3(1.0, 0.8, 0.4))\n    );\n    \n    // Keep track of the selected colour\n    vec3 col;\n    \n    // Keep track of the smallest distance found so far\n    float pd = 10.;\n    \n    // Loop through all points (can be optimized using chunks or octrees)\n    for (int i = 0; i < points.length(); i++) {\n        Point p = points[i];\n        \n        // If this point is less far than the previous distance...\n        float d = dist(p, uv);\n        if (d < pd) {\n        \n            // Update the current value and the previous distance (pd)\n            \n            col = p.value;\n            //col = vec3(abs(d));\n            \n            pd = d;\n        }\n        \n        // If the distance is very tiny, make a little black circle\n        // This helps visualize the voronoi centres.\n        \n        //if (dist(p, uv) < 0.02) {\n        if (distance(p.position, uv) < 0.02) {\n            col = vec3(0.0);\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}