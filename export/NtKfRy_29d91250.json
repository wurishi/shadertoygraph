{"ver":"0.1","info":{"id":"NtKfRy","date":"1664756091","viewed":88,"name":"Anaglyph Sandbox","username":"LJ","description":"Here you go","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["cube","demoscene","one","challenge"],"hasliked":0,"parentid":"7tGBWw","parentname":"One Cube Challenge"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n * Anaglyph sandbox, not \"scientific\", note that the parallax needs to be adjusted based on screen size in the fov of the viewer.\n * That means:\n *   - bigger screen or viewer closer to screen = smaller parallax\n *   - smaller screen or viewer further away from screen = bigger parallax\n *\n * If in doubt, less is more.\n *\n * Note that the colors have been adjusted to get good separation with the glasses handed out at deadline 2022.\n * Left eye: red\n * Right eye: cyan\n *\n * @license MIT\n * @author LJ\n */\n\n// focal point divergence\n#define IPD .0\n// screen space divergence\n#define SHIFT .1\n\nmat2 r2d(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat map(vec3 p) {\n    vec3 c=p;\n    c-=1.;\n    c.xz*=r2d(iTime*.2);\n    c.xy*=r2d(iTime*.2);\n    float cube = length(max(abs(p)-.49,0.))-.01;\n    float frontCube = length(max(abs(c)-.2,0.))-.01;\n    float sphere = length(p+vec3(cos(iTime*.3)*2.,0,sin(iTime*.3)*2.))-.5;\n    float groundPlane = p.y+.5;\n    return min(groundPlane,min(cube,min(frontCube,sphere)));\n}\n\nvec2 N=vec2(.005,0);\nvec3 march(vec3 ro, vec3 rd) {\n    float md;\n    vec3 mp = ro;\n    for(int i=0;i<50;i++) {\n        md = map(mp);\n        mp += rd * md;\n        if (md<.001)\n            break;\n        \n    }\n    vec3 normal = normalize(vec3(map(mp)-vec3(map(mp-N.xyy),map(mp-N.yxy),map(mp-N.yyx))));\n    // default shading here\n    return vec3(dot(normal,normalize(vec3(.5,.7,1)))*.5+.5)*(.5+sqrt(max(map(mp+normal*.2)/.2,.01))*.5)\n        *(1.-max(\n            smoothstep(.025,.01,length(mod(mp.xz,.2)-.1))\n            ,smoothstep(.025,.01,min(abs(mod(mp.z,1.)-.5),abs(mod(mp.x,1.)-.5))*2.)\n         )*.2*float(mp.y<-.49))\n    ;\n}\n\nmat3 viewFromForward(vec3 fwd) {\n    vec3 right = normalize(cross(fwd, vec3(0,1,0)));\n    vec3 up = normalize(cross(right,fwd));\n    return transpose(mat3(right,up,fwd));\n}\n\nvec3 marchAnaglyph(vec2 p, vec3 eye, vec3 lookAt, float fov) {\n    vec3 forward = normalize(eye-lookAt);\n    vec3 right = normalize(cross(forward,vec3(0,1,0)));\n    vec3 up = normalize(cross(forward,right));\n    \n    vec3 leftEye = eye-right*IPD;\n    vec3 rightEye = eye+right*IPD;\n    mat3 leftViewMatrix = viewFromForward(normalize(leftEye-lookAt));\n    mat3 rightViewMatrix = viewFromForward(normalize(rightEye-lookAt));\n    \n    return vec3(0,.5,1)*march(leftEye, normalize(vec3(p-vec2(SHIFT,0),fov))*leftViewMatrix)\n          +vec3(1,0,0)*march(rightEye, normalize(vec3(p+vec2(SHIFT,0),fov))*rightViewMatrix);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2\n        uv = fragCoord/iResolution.xy,\n        p = uv * 2. -1.\n    ;\n    p.x*=iResolution.x/iResolution.y;\n\n    fragColor = vec4(vec3(0),1.0);\n    \n    vec3 ro=vec3(0,3,7);\n    ro.xz*=r2d(iTime*.2);\n    \n    fragColor.rgb+=marchAnaglyph(p,ro,vec3(0,.5,0), -3.);\n    \n}","name":"Image","description":"","type":"image"}]}