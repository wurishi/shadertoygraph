{"ver":"0.1","info":{"id":"43d3Ds","date":"1717148853","viewed":104,"name":"Artificial Ink : 3D perlin noise","username":"patrickhartono","description":"Experiment with RayMarching and Perlin Noise","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","perlinnoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\nMIT License - https://opensource.org/license/mit\nCopyright (c) 2024, Patrick Hartono - https://patrickhartono.com/\n\n\nModifed from https://www.shadertoy.com/view/4djXzz\n\n\n*/\n\n\n\n// Hash function to generate a pseudo-random number based on 3D coordinates\nfloat Hash3d(vec3 coordinates)\n{\n    float hashValue = coordinates.x + coordinates.y * 37.0 + coordinates.z * 521.0; // Compute a unique float based on coordinates components\n    return fract(sin(hashValue * 1.333) * 100003.9); // Return the fractional part of the sine of hashValue multiplied by a constant\n}\n\n// Hermite interpolation function for smoother transitions\nfloat interpolateHermite(float value1, float value2, float factor)\n{\n    return mix(value1, value2, factor * factor * (3.0 - 2.0 * factor)); // Perform cubic Hermite interpolation\n}\n\nconst vec2 vector01 = vec2(0.0, 1.0); // Constant vector with values 0 and 1\n\n// Function to generate Perlin noise\nfloat noise(vec3 coordinates)\n{\n    vec3 fractional = fract(coordinates.xyz); // Compute the fractional part of coordinates\n    vec3 integral = floor(coordinates.xyz); // Compute the floor value of coordinates\n    float hash000 = Hash3d(integral); // Compute hash value for the corner integral\n    float hash100 = Hash3d(integral + vector01.yxx); // Compute hash value for the corner integral + (1, 0, 0)\n    float hash010 = Hash3d(integral + vector01.xyx); // Compute hash value for the corner integral + (0, 1, 0)\n    float hash110 = Hash3d(integral + vector01.yyx); // Compute hash value for the corner integral + (1, 1, 0)\n    float hash001 = Hash3d(integral + vector01.xxy); // Compute hash value for the corner integral + (0, 0, 1)\n    float hash101 = Hash3d(integral + vector01.yxy); // Compute hash value for the corner integral + (1, 0, 1)\n    float hash011 = Hash3d(integral + vector01.xyy); // Compute hash value for the corner integral + (0, 1, 1)\n    float hash111 = Hash3d(integral + vector01.yyy); // Compute hash value for the corner integral + (1, 1, 1)\n    \n    return interpolateHermite(\n        interpolateHermite(interpolateHermite(hash000, hash100, fractional.x), interpolateHermite(hash010, hash110, fractional.x), fractional.y), // Interpolate between the hash values on the x and y axes\n        interpolateHermite(interpolateHermite(hash001, hash101, fractional.x), interpolateHermite(hash011, hash111, fractional.x), fractional.y), // Interpolate between the hash values on the x and y axes for the next z slice\n        fractional.z); // Interpolate between the two z slices\n}\n\nfloat PI = 3.14159265; // Define the constant PI\n#define saturate(a) clamp(a, 0.0, 1.0) // Macro to clamp a value between 0 and 1\n\n// Macro to prevent loop unrolling by making the zero a variable based on the frame index\n#define ZERO_TRICK max(0, -iFrame)\n\n// Function to compute density at a point\nfloat computeDensity(vec3 position)\n{\n    float primaryNoise = noise(position * 0.1025); // Get noise value for position scaled by 0.1025\n    float secondaryNoise = noise(position * 0.1125 + 2000.0); // Get another noise value for position scaled and offset\n    secondaryNoise -= 0.5; // Adjust secondaryNoise to be centered around 0\n    primaryNoise -= 0.5; // Adjust primaryNoise to be centered around 0\n    float density = 0.1 / (abs(primaryNoise * primaryNoise * secondaryNoise)); // Compute the density using an inverse squared relation\n    density += 0.5; // Adjust the final density\n    return density * 0.00001; // Return the scaled final density\n}\n\n// Main function for rendering the image\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Convert pixel coordinates to normalized device coordinates (range [-1, 1])\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n\n    // Camera setup\n    vec3 cameraUp = vec3(0, 1, 0);\n    vec3 cameraLookat = vec3(0, 0.0, 0);\n    \n    // Animate camera X and Y positions randomly\n    float randomX = cos(iTime * 0.1) * 0.05; // Smooth random animation for X position\n    float randomY = sin(iTime * 0.1) * 0.05; // Smooth random animation for Y position\n\n    // Calculate horizontal rotation based on randomX position and time\n    float rotationX = randomX + iTime * 0.1;\n\n    // Calculate vertical rotation based on randomY position and time\n    float rotationY = randomY + cos(iTime * 0.1) * 0.2 + 0.2;\n\n    // Compute the camera position based on rotations and scales it\n    vec3 cameraPosition = vec3(sin(rotationY) * cos(rotationX), sin(rotationY), cos(rotationY) * sin(rotationX)) * (200.2);\n\n    // Compute the viewing direction\n    vec3 cameraDirection = normalize(cameraLookat - cameraPosition);\n\n    // Compute the right vector for the camera\n    vec3 cameraRight = normalize(cross(cameraUp, cameraDirection));\n\n    // Compute the up vector for the camera\n    vec3 cameraUpDirection = cross(cameraDirection, cameraRight);\n\n    // Compute the point directly in front of the camera\n    vec3 cameraFront = (cameraPosition + cameraDirection);\n\n    // Compute the world position of the pixel\n    vec3 pixelWorldPosition = cameraFront + uv.x * cameraRight * (iResolution.x / iResolution.y) + uv.y * cameraUpDirection;\n\n    // Normalize the vector from the camera to the pixel position\n    vec3 rayDirection = normalize(pixelWorldPosition - cameraPosition);\n\n    // Initialize the ray marching distance and other variables\n    float distance = 0.0;\n    float stepSize = 0.2;\n    float maximumDepth = 50.0;\n    vec3 currentPosition = vec3(0, 0, 0);\n    float accumulatedDensity = .5;\n\n    // Ray marching loop\n    for (int i = ZERO_TRICK; i < 50; i++)\n    {\n        if ((distance >= maximumDepth)) break; // Break the loop if the distance exceeds the maximum depth\n        currentPosition = cameraPosition + rayDirection * distance; // Update the current position along the ray\n        float density = computeDensity(currentPosition); // Compute the density at the current position\n\n        stepSize = 1.9 + density * 0.05; // Adjust the increment based on the density\n        accumulatedDensity += density * stepSize; // Accumulate the density\n        distance += stepSize; // Advance the ray by the increment\n    }\n\n    // Define the colors\n    vec3 colorRed = vec3(0.392, 0.443, 0.294);\n    vec3 colorYellow = vec3(0.5, 0.0, 1.0);\n    vec3 colorBlack = vec3(0.0, 0.0, 0.0);\n\n    // Compute the final color based on accumulated density\n    vec3 finalColor;\n    if (accumulatedDensity < 0.33)\n    {\n        finalColor = mix(colorBlack, colorRed, accumulatedDensity / 0.33);\n    }\n    else if (accumulatedDensity < 0.66)\n    {\n        finalColor = mix(colorRed, colorYellow, (accumulatedDensity - 0.33) / 0.33);\n    }\n    else\n    {\n        finalColor = mix(colorYellow, colorBlack, (accumulatedDensity - 0.66) / 0.34);\n    }\n\n    // Output the final color, gamma-corrected by taking the square root and clamped between 0 and 1\n    fragColor = vec4(sqrt(clamp(finalColor, 0.0, .5)), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}