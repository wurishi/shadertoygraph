{"ver":"0.1","info":{"id":"wdd3zB","date":"1568821762","viewed":249,"name":"Barth Sextic","username":"skye_adaire","description":"Implicit equation taken from:\nhttps://imaginary.org/gallery/oliver-labs","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["geometry","surface","dual","quintic","real","algebraic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//created by Skye Adaire\n\n#define pi32 3.1415926535\n#define tau32 6.2831853072\n#define eps32 10e-15\n\n//begin Hypercomplex\n\n#define Real float\n#define Nat uint\n\nReal H_negate(Real r)\n{\n    return -r;\n}\n\nReal H_conjugate(Real r)\n{\n    return r;\n}\n\nReal H_norm(Real r)\n{\n    return abs(r);\n}\n\nReal H_sqnorm(Real r)\n{\n    return r * r;\n}\n\nReal H_inverse(Real r)\n{\n \treturn 1.0 / r;   \n}\n\nReal H_add(Real lhs, Real rhs)\n{\n    return lhs + rhs;\n}\n\nReal H_subtract(Real lhs, Real rhs)\n{\n    return lhs - rhs;\n}\n\nReal H_multiply(Real lhs, Real rhs)\n{\n    return lhs * rhs;\n}\n\nReal H_divide(Real lhs, Real rhs)\n{\n    return lhs / rhs;\n}\n\nbool H_isZero(Real r)\n{\n    return H_norm(r) < eps32;\n}\n\nReal H_power(Real x, Real e)\n{\n    return pow(x, e);\n}\n\nReal H_power(Real x, Nat e)\n{\n    return pow(abs(x), float(e)) * ((e % 2u) == 0u ? 1.0 : sign(x));\n}\n\nReal H_sq(Real r)\n{\n    return r * r;\n}\n\nReal H_sin(Real r)\n{\n    return sin(r);\n}\n\nReal H_cos(Real r)\n{\n    return cos(r);\n}\n\n#define DualReal vec2\n\nDualReal D_add(DualReal lhs, DualReal rhs)\n{\n    return lhs + rhs;\n}\n\nDualReal D_subtract(DualReal lhs, DualReal rhs)\n{\n    return lhs - rhs;\n}\n\nDualReal D_multiply(DualReal lhs, DualReal rhs)\n{\n    return DualReal(\n        H_multiply(lhs[0], rhs[0]),\n        H_add(H_multiply(lhs[1], rhs[0]), H_multiply(lhs[0], rhs[1])));\n}\n\nDualReal D_divide(DualReal lhs, DualReal rhs)\n{\n    return DualReal(\n        H_divide(rhs[0], lhs[0]),\n        H_divide(\n            H_subtract(H_multiply(lhs[1], rhs[0]), H_multiply(lhs[0], rhs[1])),\n            H_sq(rhs[0])));\n}\n\nDualReal D_power(DualReal d, Real exponent)\n{\n    return DualReal(\n        H_power(d[0], exponent),\n        H_multiply(exponent * H_power(d[0], exponent - 1.0), d[1]));\n}\n\nDualReal D_power(DualReal d, Nat exponent)\n{\n    return DualReal(\n        H_power(d[0], exponent),\n        H_multiply(float(exponent) * H_power(d[0], exponent - 1u), d[1]));\n}\n\nDualReal D_sq(DualReal d)\n{\n \treturn D_multiply(d, d);   \n}\n\nDualReal D_inverse(DualReal d)\n{\n    return DualReal(\n        H_inverse(d[0]),\n        H_multiply(H_negate(H_inverse(H_sq(d[0]))), d[1]));\n}\n\nDualReal D_sin(DualReal d)\n{\n \treturn DualReal(\n        H_sin(d[0]), \n        H_multiply(d[1], H_cos(d[0])));   \n}\n                          \nDualReal D_cos(DualReal d)\n{\n \treturn DualReal(\n        H_cos(d[0]),\n        H_multiply(H_negate(d[1]), H_sin(d[0])));   \n}\n\n#define DualVector2 mat2x2\n#define DualVector3 mat3x2\n\n//end Hypercomplex\n\nDualReal f(int index, DualVector3 d)\n{\n    switch(index)\n    {\n        case 10:\n        {\n            DualReal x = d[0];\n            DualReal x2 = D_multiply(x, x);\n            DualReal y = d[1];\n            DualReal y2 = D_multiply(y, y);\n            DualReal z = d[2];\n            DualReal z2 = D_multiply(z, z);\n\n            Real ro = 0.5 * (1.0 + 2.2360679775);\n            Real ro2 = ro * ro;\n            Real al = 0.25 * (2.0 * ro + 1.0);\n         \tDualReal p6 = D_multiply(ro2 * x2 - y2, D_multiply(ro2 * y2 - z2, ro2 * z2 - x2));\n            DualReal k = x2 + y2 + z2 - DualReal(1, 0);\n            return p6 - al * D_sq(k);\n        }\n    }\n}\t\n\nfloat getDE(int index, vec3 p, out vec3 gradient)\n{\n \tDualReal dx = f(index, DualVector3(p.x, 1, p.y, 0, p.z, 0)); \n    DualReal dy = f(index, DualVector3(p.x, 0, p.y, 1, p.z, 0)); \n    DualReal dz = f(index, DualVector3(p.x, 0, p.y, 0, p.z, 1)); \n    \n    float fp = dx[0];//level, same for all partials\n    gradient = vec3(dx[1], dy[1], dz[1]);\n    float de = fp / length(gradient);\n    \n    float bound = length(p) - 2.25;\n    \n    return max(abs(de), bound) * 0.5;//intersection\n}\n\nmat3 rotationXY(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(c, s, 0, -s, c, 0, 0, 0, 1);\n}\n\nmat3 rotationXZ(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n}\n\nmat3 rotationYZ(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(1, 0, 0, 0, c, s, 0, -s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 clip = uv * 2.0 - 1.0;\n    vec2 unitSpacePosition = 0.5 * clip;\n    vec2 ratioSpacePosition = vec2(aspectRatio, 1) * unitSpacePosition;\n    \n    //model\n    float time = iTime * 0.15;\n    int index = 10;\n    \n    //view basis\n    float polar = (iMouse == vec4(0)) ? 0.0 : tau32 * iMouse.y / iResolution.y + pi32;\n    float az = (iMouse == vec4(0)) ? time * tau32 : -tau32 * iMouse.x / iResolution.x;\n    mat3 viewTransform = rotationXZ(az) * rotationYZ(polar);\n    vec3 viewPosition = viewTransform * vec3(0, 0, 4.5);\n    vec3 viewRight = viewTransform * vec3(1, 0, 0);\n    vec3 viewUp = viewTransform * vec3(0, 1, 0);\n    vec3 viewForward = viewTransform * vec3(0, 0, -1);\n    \n    //view ray\n    vec3 frustumPoint = viewPosition - viewForward;\n    vec3 srp =\n       viewPosition +\n       viewRight * ratioSpacePosition.x +\n       viewUp * ratioSpacePosition.y;\n    vec3 srd = normalize(srp - frustumPoint);\n\n    //sphere trace\n    int i;\n    float t = 0.0;\n    vec3 p;\n    bool hit = false;\n    vec3 gradient;\n    \n    for(i = 0; i < 300; i++)\n    {\n        p = srp + t * srd;\n        \n        float de = getDE(index, p, gradient);\n        \n        if(de < 0.0001)\n        {\n            hit = true;\n            p -= 0.001 * srd;\n            break; \n        }\n\n        t += de;\n    }\n    \n    if(hit)\n    {\n        vec3 color = vec3(1.0 - float(i) / 100.0) * 2.0;\n        color *= normalize(gradient) * 0.8 + 0.2;\n        fragColor = vec4(color, 1);\n    }\n    else\n    {\n     \tfragColor = vec4(vec3(0.2),1);   \n    }\n}","name":"Image","description":"","type":"image"}]}