{"ver":"0.1","info":{"id":"l3fGWN","date":"1708914315","viewed":54,"name":"Raymarch - Testing Soft Shadow","username":"davidkimighty","description":"raymarching test","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_DIST 100.\n\nfloat torus(vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nfloat circle(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat plane(vec3 p)\n{\n    return p.y;\n}\n\nfloat map(vec3 p)\n{\n    float c = circle(p-vec3(0, 1., 1), 1.);\n    float g = plane(p-vec3(0));\n    return min(c, g);\n}\n\nfloat raymarching(vec3 ro, vec3 rd, int ms, float sl)\n{\n    float td = 0.;\n    for (int i=0; i<ms; i++)\n    {\n        vec3 p = ro+rd*td;\n        float d = map(p);\n        td+=d;\n        if (d<sl || td>MAX_DIST) break;\n    }\n    if (td>MAX_DIST)\n        td = -1.;\n    return td;\n}\n\nvec3 get_normal(vec3 p)\n{\n    vec2 e = vec2(1, -1)*0.0001;\n    return normalize(e.xyy*map(p+e.xyy)+\n                     e.yyx*map(p+e.yyx)+\n                     e.yxy*map(p+e.yxy)+\n                     e.xxx*map(p+e.xxx));\n}\n\nfloat get_ao(vec3 p, vec3 n)\n{\n    float occ = 0.;\n    float sca = 1.;\n    for(int i=0; i<5; i++)\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map(p + h*n);\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if(occ>0.35) break;\n    }\n    return clamp(1.-3.*occ, 0., 1.)*(0.5+0.5*n.y);\n}\n\nfloat get_diffuse(vec3 ld, vec3 n)\n{\n    return clamp(dot(n, ld), 0., 1.);\n}\n\nfloat get_specular(vec3 rd, vec3 ld, vec3 n, float p)\n{\n    vec3 dir = normalize(ld-rd);\n    return pow(clamp(dot(n, dir), 0., 1.), p);\n}\n\nfloat get_hardshadow(vec3 ro, vec3 rd, float mint)\n{\n    float t = mint;\n    for(int i=0; i<25 && t<MAX_DIST; i++ )\n    {\n        float h = map(ro + rd*t);\n        if(h<0.001)\n            return 0.;\n        t += h;\n    }\n    return 1.;\n}\n\nfloat get_softshadow(vec3 ro, vec3 rd, int ms, float w)\n{\n    float res = 1.;\n    float t = 0.01;\n    for (int i=0; i<ms; i++)\n    {\n        float h = map(ro+rd*t);\n        res = min(res, h/(w*t));\n        t += clamp(h, 0.005, 0.5);\n        if (res<(-1.) || t>MAX_DIST) break;\n    }\n    res = max(res, -1.);\n    return 0.25*(1.+res)*(1.+res)*(2.-res);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    vec3 ro = vec3(0., 1, -1);\n    vec3 rd = vec3(uv, 1);\n    vec3 ld = normalize(vec3(3.6, 3., -2.3));\n    vec3 col = vec3(0);\n    \n    float td = raymarching(ro, rd, 256, 0.001);\n    if (td>0.)\n    {\n        vec3 p = ro+rd*td;\n        vec3 n = get_normal(p);\n        \n        float d = get_diffuse(ld, n);\n        float ao = get_ao(p, n);\n        d *= ao;\n        d *= get_softshadow(p, ld, 64, 0.1);\n        //d *= get_hardshadow(p, ld, 0.1);\n        \n        float s = d>0.01?get_specular(rd, ld, n, 192.):0.;\n        \n        col = d*vec3(1.,0.9,0.95);\n        col += vec3(1)*s;\n        \n        float sky = sqrt(clamp(0.5+0.5*n.y, 0., 1.));\n        sky *= ao;\n        col += 0.03*sky*vec3(0.4, 0.6, 1.15);\n    }\n    col *= exp(-0.0005*td*td*td);\n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}