{"ver":"0.1","info":{"id":"cdjcWt","date":"1688343441","viewed":73,"name":"Polar Plotter","username":"Envy24","description":"Hold LMB to see signed distance fiend.\nOther (thanks to NinjaKoala):\nhttps://www.shadertoy.com/view/cdsBzn\nhttps://www.shadertoy.com/view/wsXBW2\nhttps://www.shadertoy.com/view/3tsXDB\nhttps://www.shadertoy.com/view/XdSSRw","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["graph","plot","polar","plotter"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TAU                         6.2831853071795862\n#define PI                          3.1415926535897932\n#define TO_RAD                      0.017453292519943295        // Convert degrees to radians\n#define TO_DEG                      57.295779513082323          // Convert radians to degrees\n#define EULER                       2.7182818284590451          // e\n#define LMB_IS_HOLD               ( iMouse.z > 0.0 )\n\n/* Define your r = f(theta) function here */\n#define THETA_MIN       ( 0. )\n#define THETA_MAX       ( 6.*TAU )\n#define SCENE_SCALE     ( 3.35 )\n#define NUM_OF_SEGMENTS ( 1400. ) // better to use odd number of segments\n#define ORIGIN          ( vec2(0, 0.65) )\nfloat f(float t)\n{\n    \n    /* Lemniscate of Bernoulli (3000 segments, 1./1.3 scale, [0.; TAU] range, vec2(0) origin) *\n    return sqrt(cos(2.*t));\n    /* Cardioid (100 segments, 1./1.3 scale, [0.; TAU] range, vec2(0) origin) *\n    return .5*(1.-cos(t));\n    /* Lines *\n    //return 0.5 / (0.*cos(t) + 1.*sin(t)); // (20 segments, 1./1.3 scale, [-TAU; TAU] range, vec2(0) origin)\n    //return 0.5 / (1.*cos(t) + 0.*sin(t)); // (10 segments, 1./1.3 scale, [-TAU; TAU] range, vec2(0) origin)\n    return 0.5 / (1.*cos(t) + 1.*sin(t)); // (30 segments, 1./1.3 scale, [-TAU; TAU] range, vec2(0) origin)\n    /*Butterfly curve (1400 segments, 3.35 scale, [0.; 6.*TAU] range, vec2(0, 0.65) origin) */\n    float a = pow(EULER, sin(t)),\n          b = 2.*cos(4.*t),\n          c = sin((2.*t - PI) / ( 24. ));\n    return a - b + c*c*c*c*c;\n    /* (501 segments, 1./1.3 scale, [-2.*TAU; 2.*TAU] range, vec2(0, 0.35) origin) */\n    //return 1./t;\n}\n\n#define UNIT                      ( SCENE_SCALE * (3.0 / iResolution.y) )\n#define SMAA(d)                   ( smoothstep(UNIT, 0., d) )\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale + origin;\n}\n\nfloat y_axis(vec2 NDC) { return SMAA(abs(NDC.x)); }\nfloat x_axis(vec2 NDC) { return SMAA(abs(NDC.y)); }\nfloat vertical_line(vec2 NDC, float x0) { return SMAA(abs(NDC.x-x0)); }\nfloat horizontal_line(vec2 NDC, float y0) { return SMAA(abs(NDC.y-y0)); }\n\nfloat diskSDF_L2(in vec2 NDC, in vec2 C, in float r) { return length(C - NDC)-r; }\nfloat segmentSDF_L2(in vec2 NDC, in vec2 B, in vec2 E, in float r)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - r;\n}\n\nvec2 polar(vec2 z) { return vec2(length(z), atan(z.y, z.x)); } // atan2 implementation: https://www.shadertoy.com/view/csf3Wl\n\nfloat polarSDF(vec2 NDC)\n{\n    float s = (THETA_MAX - THETA_MIN) / NUM_OF_SEGMENTS,\n          min_dist = 9999.;   \n\n    for (float i = 0.; i < NUM_OF_SEGMENTS; i += 1.)\n    {\n        float t = THETA_MIN + s * i, nt = THETA_MIN + s * (i + 1.),\n              r = f(t),              nr = f(nt);\n              \n        vec2  P = vec2( r * cos(t),   r * sin(t)),\n             nP = vec2(nr * cos(nt), nr * sin(nt));\n\n        min_dist = min(min_dist, segmentSDF_L2(NDC, P, nP, 0.));\n    }\n    \n    return min_dist;\n}\n\n/* https://www.shadertoy.com/view/ddfGz2 */\nvec3 colorize_field(float dist, vec3 color)\n{    \n    float F = 30., freq = F*dist, aa = 1./F, C = 0.7, amp = 0.2, width = 0.3,\n          waves_sdf = C + amp*smoothstep(8./iResolution.y, 0., (width+cos(freq)) * aa),\n          exp_raise = 1. - exp(-4.*abs(dist));\n        \n    color = 1.0 - sign(dist) * color; // Change color if dist is negative. \n    color *= exp_raise;               // Attenuate color around edges.     \n    color *= waves_sdf;               // Add waves.\n    \n    return mix(color, vec3(1), smoothstep(8./iResolution.y, 0., abs(dist)) );\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, ORIGIN, false);\n\n    vec3 color = vec3(1);\n         color -= x_axis(NDC); color -= y_axis(NDC);\n    \n    vec2 ndc = polar(NDC);\n    float d = polarSDF(NDC);\n    \n    if (LMB_IS_HOLD)\n    {\n        O = vec4(colorize_field(d, vec3(0.1, 0.4, 0.7)), 1.);\n    }\n    else\n    {\n        /* Cheap rings */\n        ndc.x = fract(ndc.x);\n        ndc.x = min(ndc.x, 1.-fract(ndc.x));\n        color = mix(color, vec3(0), SMAA(ndc.x) * 0.2);\n        /* Cheap radii (but looks bad when close to 0) *\n        float l1_norm = min(fwidth(ndc.y), fwidth(ndc.x));\n        ndc.y = mod(ndc.y, TAU/16.);\n        ndc.y = min(ndc.y, TAU/16.-mod(ndc.y, TAU/16.));\n        color = mix(color, vec3(0), smoothstep(1.5*l1_norm, 0., ndc.y) * 0.2);\n        /* Radii */\n        float num_of_sectors = 16.,\n              a = 2.*3.141592 / num_of_sectors,\n              len = 9999.9; // because we want to approach \"infinity\" in end segment point\n        for (float i = 1.; i < num_of_sectors; i += 1.)\n        {\n            float theta = a * i;\n            vec2 E = vec2(len * cos(theta), len * sin(theta));\n\n            color = mix(color, vec3(0), SMAA(segmentSDF_L2(NDC, vec2(0), E, 0.)) * 0.2);\n        }\n        /**/\n        O = vec4(mix(color, vec3(1,0,0), SMAA(d)), 1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}