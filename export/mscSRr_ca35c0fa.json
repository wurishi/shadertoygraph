{"ver":"0.1","info":{"id":"mscSRr","date":"1679364234","viewed":141,"name":"3d noise, cloud.","username":"zy269018784","description":"worley, perlin, cloud ","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["cloud","perlin","worley"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nmat2 m = mat2(0, -1, \n              1,  0);\n\nvec3 getRayFromCamera(vec3 org, vec3 fwd, vec3 up, vec2 uv)\n{\n    vec3 d;\n    fwd = normalize(fwd);\n    up = normalize(up);\n    vec3 right = normalize(cross(fwd, up));\n    d = fwd + uv.x * right + uv.y * up;\n    d = normalize(d);\n    return d;\n}\n\nvec3 box(vec3 ray_origin, vec3 ray_dir, vec3 minpos, vec3 maxpos) {\n  vec3 inverse_dir = 1.0 / ray_dir;\n  vec3 tbot = inverse_dir * (minpos - ray_origin);\n  vec3 ttop = inverse_dir * (maxpos - ray_origin);\n  vec3 tmin = min(ttop, tbot);\n  vec3 tmax = max(ttop, tbot);\n  vec2 traverse = max(tmin.xx, tmin.yz);\n  float traverselow = max(traverse.x, traverse.y);\n  traverse = min(tmax.xx, tmax.yz);\n  float traversehi = min(traverse.x, traverse.y);\n  return vec3(float(traversehi > max(traverselow, 0.0)), traversehi, traverselow);\n}\n\n\n\nfloat worley3D(vec3 uvw)\n{\n    float minDist = 10000.;  \n    vec3 d = vec3(0);\n   \n    d = uvw - vec3( 0.5, 0., 0.);\n    minDist = min(minDist, dot(d, d));\n    \n    d = uvw - vec3(-0.5, 0., 0.);\n    minDist = min(minDist, dot(d, d));\n    \n     d = uvw - vec3( 0., 0.2, 0.);\n    minDist = min(minDist, dot(d, d));\n    \n    //d = uvw - vec3(0.1, 0.5, 0.3);\n    //minDist = min(minDist, dot(d, d));\n    //\n    //d = uvw - vec3(-0.2, -0.5, -0.7);\n    //minDist = min(minDist, dot(d, d));\n    //\n    //d = uvw - vec3(0.4, 0.0, -0.3);\n    //minDist = min(minDist, dot(d, d));\n     \n    if (abs(minDist - 10000.) < 0.001)\n        return 0.;\n    return 1. - minDist;\n}\n\n\nfloat worley(vec2 uv)\n{\n    float minDist = 1000.;\n \n    vec2 d = uv;\n    minDist = min(minDist, dot(d, d));\n    \n    d = uv - vec2(0.5, 0.3);\n    minDist = min(minDist, dot(d, d));\n    \n    d = uv - vec2(-0.1, 0.3);\n    minDist = min(minDist, dot(d, d));\n   \n    d = uv - vec2(-0.4, -0.3);\n    minDist = min(minDist, dot(d, d));\n    \n   // d = uv - vec2(0.1, -0.3);\n   // minDist = min(minDist, dot(d, d));\n    \n    float noise = 1. - minDist;\n    if (noise < 0.)\n        noise = 0.;\n    return noise;\n}\n\n\nfloat worleyFbm2(vec2 uv, float w, float coverage)\n{\n    float freq = 4.;\n    // pernlin worley\n    float worley_fbm1 = worleyFbm(vec3(uv * .5, w), freq * 1.);\n    \n    float pfbm= mix(1., perlinfbm(vec3(uv * .5, w), 4., 7), .5);\n    pfbm = abs(pfbm * 2. - 1.); // billowy perlin noise\n    \n    float perlin_worley = remap(pfbm, 0., 1., worley_fbm1, 1.); // perlin-worley\n    \n    // worley fbm\n    vec3 worley_fbm = vec3(0.);\n    worley_fbm.r += worleyFbm(vec3(uv * 1., w), freq * 1.) * 0.625;\n    worley_fbm.g += worleyFbm(vec3(uv * 2., w), freq * 2.) * 0.25;\n    worley_fbm.b += worleyFbm(vec3(uv * 4., w), freq * 4.) * 0.125;\n   \n    float wfbm = worley_fbm.r +\n                 worley_fbm.g +\n                 worley_fbm.b;\n                 \n    // cloud\n    float cloud = remap(perlin_worley, wfbm - 1., 1., 0., 1.);\n    \n    float noise = 0.;\n    noise = worley(uv * 1.);\n    //return noise;\n        \n\n    noise = clamp(remap(cloud, 0., 1., 0., noise), .0, 1.);\n    // coverage\n    noise = clamp(remap(noise, coverage, 1., 0., 1.), .0, 1.);\n    return noise;\n}\n\n\n\n\nvec3 scene(vec3 org, vec3 fwd, vec3 up, vec2 uv)\n{\n   vec3 sky_color = vec3(0, 0, 1);\n   float d = 0.;\n\n#if 1\n    vec3 ray = getRayFromCamera(org, fwd, up, uv);\n    \n    vec3 AA = vec3(-20, -10, -50);\n    vec3 BB = vec3( 20,  10, -30);\n    vec3 hit = box(org, ray, AA, BB);\n    \n    if (hit.x > 0.)\n    {\n        float t0 = hit.z;\n        float t1 = hit.y;\n        float steps = 16.;\n        float step_size = (t1 - t0) / steps;\n        float t = t0 + 0.0 * step_size;\n        vec3 pos = org + ray * t;\n        for (float i = 0.; i < steps; i += 1.)\n        {\n            vec3 uvw = (pos - AA) / (BB - AA);\n            //uvw *= 2.;\n            //uvw -= 1.;\n            float s = 1.;\n            s *= smoothstep(0., .2, uvw.y);\n            s *= smoothstep(0., .4, uvw.x);\n            s *= smoothstep(6., 1., uvw.x);\n            d += worleyFbm2(uvw.xy, uvw.z, 0.65)\n              * s\n            ;\n\n            pos += step_size * ray;\n        }\n        if (d > 0.)\n        {\n         //   d += noise;\n            d = d / (1. + d);    \n        }     \n    }\n\n#endif\n    return mix(sky_color, vec3(1), d);\n}\n\nvec3 scene2(vec3 org, vec3 fwd, vec3 up, vec2 uv)\n{\n    float w = iMouse.y / iResolution.y;\n\n    float cloud = worleyFbm2(uv, w, 0.65); \n\n    return vec3(cloud);\n}\n\nvec3 scene3(vec3 org, vec3 fwd, vec3 up, vec2 uv)\n{\n   float w = iMouse.y / iResolution.y;\n   vec3 sky_color = vec3(0, 0, 1);\n   \n    float steps = 13.;\n    float d = worleyFbm2(uv, w, 0.65) * steps;\n    d /= (1. + d);\n    return vec3(d);\n}\n\n\nvec3 scene4(vec3 org, vec3 fwd, vec3 up, vec2 uv)\n{\n   float w = iMouse.y / iResolution.y;\n   vec3 sky_color = vec3(0, 0, 1);\n   \n    float steps = 13.;\n    float d = 0.;\n    for (float i = 0.; i < steps; i += 1.)\n    {\n        w = i / steps;\n        d += worleyFbm2(uv, w, 0.80);\n        //for (int j = 0; j < steps; j++)\n        //{\n        //    \n        //}\n    }\n    d /= (1. + d);\n    return vec3(d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( 2.*fragCoord - iResolution.xy ) / iResolution.xy;\n    \n    vec3 org = vec3(0, 0, 0);\n    vec3 fwd = vec3(0, 0, -1);\n    vec3 up  = vec3(0, 1, 0);\n    \n    vec3 col = scene3(org, fwd, up, uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/**\nThis tab contains all the necessary noise functions required to model a cloud shape.\n*/\n\n// Hash by David_Hoskins\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1.0 / float(0xffffffffU))\n\nvec3 hash33(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn -1. + 2. * vec3(q) * UIF;\n}\n\nfloat remap(float x, float a, float b, float c, float d)\n{\n    return (((x - a) / (b - a)) * (d - c)) + c;\n}\n\n// Gradient noise by iq (modified to be tileable)\nfloat gradientNoise(vec3 x, float freq)\n{\n    // grid\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    // quintic interpolant\n    vec3 u = w * w * w * (w * (w * 6. - 15.) + 10.);\n\n    \n    // gradients\n    vec3 ga = hash33(mod(p + vec3(0., 0., 0.), freq));\n    vec3 gb = hash33(mod(p + vec3(1., 0., 0.), freq));\n    vec3 gc = hash33(mod(p + vec3(0., 1., 0.), freq));\n    vec3 gd = hash33(mod(p + vec3(1., 1., 0.), freq));\n    vec3 ge = hash33(mod(p + vec3(0., 0., 1.), freq));\n    vec3 gf = hash33(mod(p + vec3(1., 0., 1.), freq));\n    vec3 gg = hash33(mod(p + vec3(0., 1., 1.), freq));\n    vec3 gh = hash33(mod(p + vec3(1., 1., 1.), freq));\n    \n    // projections\n    float va = dot(ga, w - vec3(0., 0., 0.));\n    float vb = dot(gb, w - vec3(1., 0., 0.));\n    float vc = dot(gc, w - vec3(0., 1., 0.));\n    float vd = dot(gd, w - vec3(1., 1., 0.));\n    float ve = dot(ge, w - vec3(0., 0., 1.));\n    float vf = dot(gf, w - vec3(1., 0., 1.));\n    float vg = dot(gg, w - vec3(0., 1., 1.));\n    float vh = dot(gh, w - vec3(1., 1., 1.));\n\t\n    // interpolation\n    return va + \n           u.x * (vb - va) + \n           u.y * (vc - va) + \n           u.z * (ve - va) + \n           u.x * u.y * (va - vb - vc + vd) + \n           u.y * u.z * (va - vc - ve + vg) + \n           u.z * u.x * (va - vb - ve + vf) + \n           u.x * u.y * u.z * (-va + vb + vc - vd + ve - vf - vg + vh);\n}\n\n// Tileable 3D worley noise\nfloat worleyNoise(vec3 uv, float freq)\n{    \n    vec3 id = floor(uv);\n    vec3 p = fract(uv);\n    \n    float minDist = 10000.;\n    for (float x = -1.; x <= 1.; ++x)\n    {\n        for(float y = -1.; y <= 1.; ++y)\n        {\n            for(float z = -1.; z <= 1.; ++z)\n            {\n                vec3 offset = vec3(x, y, z);\n            \tvec3 h = hash33(mod(id + offset, vec3(freq))) * .5 + .5;\n    \t\t\th += offset;\n            \tvec3 d = p - h;\n           \t\tminDist = min(minDist, dot(d, d));\n            }\n        }\n    }\n    \n    // inverted worley noise\n    return 1. - minDist;\n}\n\n// Fbm for Perlin noise based on iq's blog\nfloat perlinfbm(vec3 p, float freq, int octaves)\n{\n    float G = exp2(-.85);\n    float amp = 1.;\n    float noise = 0.;\n    for (int i = 0; i < octaves; ++i)\n    {\n        noise += amp * gradientNoise(p * freq, freq);\n        freq *= 2.;\n        amp *= G;\n    }\n    \n    return noise;\n}\n\n// Tileable Worley fbm inspired by Andrew Schneider's Real-Time Volumetric Cloudscapes\n// chapter in GPU Pro 7.\nfloat worleyFbm(vec3 p, float freq)\n{\n    return worleyNoise(p*freq, freq) * .625 +\n        \t worleyNoise(p*freq*2., freq*2.) * .25 +\n        \t worleyNoise(p*freq*4., freq*4.) * .125;\n}\n\n","name":"Common","description":"","type":"common"}]}