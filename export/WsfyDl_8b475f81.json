{"ver":"0.1","info":{"id":"WsfyDl","date":"1585799526","viewed":181,"name":"alligator noise, hybrid terrain","username":"jamelouis","description":"alligator noise, hybrid terrain","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// blackjero\n// https://www.shadertoy.com/view/tl33Rn\n//\n\n#define pi 3.141592654\n\nvec2 hash22(vec2 p)//Dave Hoskins https://www.shadertoy.com/view/4djSRW\n{\n\treturn fract(cos(p*mat2(-64.2,71.3,81.4,-29.8))*8321.3);\n}\n\n#define smoothstep_unchecked(x) (x*x*(3.0-2.0*x))\n\n// source: adapted from Houdini online doc\nfloat calc_alligator_noise( vec2 p, float period )\n{\n\tvec2 p_index = floor( p );\n\tfloat d1 = 0.0;\n\tfloat d2 = 0.0;\n\tfor ( int x = -1; x <= 1; ++x )\n\t{\n\t\tfor ( int y = -1; y <= 1; ++y )\n\t\t{\n\t\t\tvec2 index = p_index + vec2( x, y );\n\t\t\tvec2 index_hash = index;\n\t\t\t//if ( period != 0.0 ) index_hash = mod( index_hash, vec2( period ) );\n            vec2 h = hash22(index_hash);\n            vec2 g =index_hash  + 0.5+ 0.5 * sin(h*12.6);\n\t\t\t//c2 c = index + hash22( index_hash ); // compiler bug.. hash bit returns 0 (but not always, depends where its called from)\n\t\t\t//vec2 cp = p - g;\n\t\t\tfloat d = distance( p,g ) * distance(p,g);\n\t\t\tif ( d < 1.0 )\n\t\t\t{\n\t\t\t\t//if ( period != 0.0 ) index_hash = mod( index_hash, vec2( period ) );\n\t\t\t\td =  h.x * smoothstep_unchecked( 1.0 - sqrt( d ) );\n\t\t\t\tif ( d1 < d )\n\t\t\t\t{\n\t\t\t\t\td2 = d1;\n\t\t\t\t\td1 = d;\n\t\t\t\t}\n\t\t\t\telse if ( d2 < d )\n\t\t\t\t{\n\t\t\t\t\td2 = d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn d1-d2;\n}\n\nfloat noised(vec2 p)\n{\n   //return hash22(floor(p)).x;\n   return calc_alligator_noise(p, 36.0);\n}\n\nfloat H = 0.2f;\nfloat hmft(vec2 x, int octaves, float lac, float roughness)\n{\n \tfloat val = noised(x);\n    float w = val;\n    for(int i = 1; i < octaves; ++i) {\n     \tif(w>1.0f) w = 1.0f;\n        x *= lac;\n        w *= roughness;\n        float ex = -H * float(i);\n        float a = pow(lac, ex);\n        float n = noised(x);\n        val += w * n * a;\n        w *= n;\n    }\n    \n    return val;\n}\n\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n\n\n// Compound versions of the hashing algorithm I whipped together.\nuint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }\nuint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }\nuint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }\n\n\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\n\n\n// Pseudo-random value in half-open range [0:1].\nfloat random( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }\nfloat random( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\n\nfloat rbf(float d)\n{\n    float dd = 1.-d;\n    float v = dd*dd*(3.0-2.0*dd);\n    return d < 1.0 ?  v : 0.; \n}\n\nvec3 get_center(int ix, int iy, int iz, ivec3 ipos)\n{\n    vec3 c;\n    c.x = random(vec3(ix+ipos.x, iy+ipos.y, iz+ipos.z)) + float(ix);\n    c.y = random(vec3(iy+ipos.y, iz+ipos.z, ix+ipos.x)) + float(iy);\n    c.z = random(vec3(iz+ipos.z, ix+ipos.x, iy+ipos.y)) + float(iz);\n \n    return c;\n}\n\nfloat noise_value(int ix, int iy, int iz, ivec3 ipos)\n{\n    return random(vec3(ix+ipos.x, iz+ipos.z, iy+ipos.y));\n}\n\nfloat alligator(vec3 pos)\n{\n    float h1 = 0.;\n    float h2 = 0.; \n    ivec3 ipos;\n    vec3  fpos;\n    vec3  vpos;\n    \n    ipos = ivec3(floor(pos.x), floor(pos.y), floor(pos.z));\n    fpos = pos - vec3(ipos);\n    \n    for(int ix = -1; ix <= 1; ++ix)\n    {\n        for(int iy = -1; iy <= 1; ++iy)\n        {\n            for(int iz = -1; iz <= 1; ++iz)\n            {\n                vpos = get_center(ix, iy, iz, ipos);\n                float d = sqrt(distance(fpos, vpos));\n                if(d<1.)\n                {\n                    float v = noise_value(ix, iy, iz, ipos) * rbf(d);\n                    if(h1 < v) {\n                        h2 = h1;\n                        h1 = v;\n                    }\n                    else if(h2 < v)\n                    {\n                        h2 = v;\n                    }\n                        \n                }\n            }\n        }\n    }\n    \n    return h1-h2;\n}\n\nfloat hmft3d(vec3 x, int octaves, float lac, float roughness)\n{\n \tfloat val = alligator(x);\n    float w = val;\n    for(int i = 1; i < octaves; ++i) {\n     \tif(w>1.0f) w = 1.0f;\n        x *= lac;\n        w *= roughness;\n        float ex = -H * float(i);\n        float a = pow(lac, ex);\n        float n = alligator(x);\n        val += w * n * a;\n        w *= n;\n    }\n    \n    return val;\n}\nvoid mainImage( out vec4 Color, in vec2 Coord)\n{\n    float scale = 80.0;\n    if(Coord.x < iResolution.x/2.)\n    {\n        if(Coord.y < iResolution.y/2.)   \n    \t\tColor = vec4(calc_alligator_noise(Coord/scale, 0.0));\n        else\n            Color = vec4(vec3(hmft(Coord/scale,8, 4.0, 1.0)),1.0+iTime);\n    } \n    else\n    {\n        vec3 offset = vec3(123.0);\n        vec3 pos = vec3(Coord.x/scale, 0, Coord.y/scale) - offset;\n        if(Coord.y < iResolution.y/2.)   \n        \tColor = vec4(alligator(pos));\n        else\n        \tColor = vec4(hmft3d(pos, 8, 4.0, 1.0));\n    }\n    \n}","name":"Image","description":"","type":"image"}]}