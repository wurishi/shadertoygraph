{"ver":"0.1","info":{"id":"fljfRw","date":"1651931803","viewed":104,"name":"ASOUL~","username":"laojieduo","description":"the renderer is based on Blinn Phong model, also with soft shadow","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","blinnphong","aoul"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define tMin 0.01\n#define tMax 50.\n#define rayMarchTime 256\n#define epsilon 0.001\n#define PI 3.141592653589\n#define eyePos vec3(0., 7., -2.5)\n#define lightPos vec3(5. * sin(iTime), 10., 5. * cos(iTime))\n#define lightInten vec3(1., 1., 1.) * 100.\n#define ambLightInten vec3(2.)\n#define kd vec3(1.)\n#define ka vec3(0.1)\n#define ks vec3(0.01)\n\n\nvec2 fixUV(in vec2 c)\n{\n    return 1. * (2. * c - iResolution.xy) / min(iResolution.x, iResolution.y);\n}\n\nmat3 setCamera(vec3 ta, vec3 ro, float cr)\n{\n    vec3 z = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr), 0.);\n    vec3 x = normalize(cross(z, cp));\n    vec3 y = cross(x, z);\n\n    return mat3(x, y, z);\n}\n\nvec4 sdfSphere(in vec3 p, in float radius)\n{\n    float d = length(p) - radius;\n    vec3 rgb = vec3(1., 2., 1.);\n    vec4 rgbd = vec4(rgb, d);\n    return rgbd;\n}\n\nvec4 sdfBox(in vec3 p, in vec3 b)\n{\n    vec3 q = abs(p) - b;\n    float d = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n    vec3 rgb = vec3(1., 0., 1.);\n    \n    return vec4(rgb, d);\n}\n\nvec4 sdfPlane(in vec3 p)\n{\n    vec3 color = vec3(0.4);\n    vec2 uv = p.xz;\n    vec2 grid = floor(mod(uv, 2.));\n\n    if (grid.x == grid.y)\n    {\n        color = vec3(0.6);\n    }\n\n    return vec4(color, p.y);\n}\n\nvec4 sdfEllipsoid( in vec3 p, in vec3 r ) \n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    vec3 color = vec3(0.4);\n    return vec4(color, k0*(k0-1.0)/k1);\n    //return k0*(k0-1.0)/k1;\n}\n\nvec4 sdfCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  vec3 color = vec3(0.4);\n  return vec4(color, length( pa - ba*h ) - r);\n}\n\nvec4 sdfCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  vec3 color = vec3(0.4);\n  return vec4(color, sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb);\n}\n\nvec4 sdfLink( vec3 p, float le, float r1, float r2 )\n{\n  vec3 q = vec3( p.y, max(abs(p.x)-le,0.0), p.z );\n  vec3 color = vec3(0.4);\n  return vec4(color, length(vec2(length(q.xy)-r1,q.z)) - r2);\n}\n\n\nvec4 findClosest(in vec4 a, in vec4 b)\n{\n    if (a.a <= b.a)\n    {\n        return a;\n    }\n    else\n    {\n        return b;\n    }\n}\n\nvec4 findMax(in vec4 d1, in vec4 d2, in float k)\n{\n    float h = clamp( 0.5 - 0.5*(d2.a+d1.a)/k, 0.0, 1.0 );\n    return vec4(d1.rgb, mix( d2.a, -d1.a, h ) + k*h*(1.0-h));\n}\n\n\nvec4 smin( vec4 d1, vec4 d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2.a-d1.a)/k, 0.0, 1.0 );\n    return vec4( d1.rgb, mix( d2.a, d1.a, h ) - k*h*(1.0-h));\n}\n\nvec4 sdfA(in vec3 p)\n{\n    float r = 0.2;\n    vec3 p1 = vec3(6.5, 0., 2.);\n    vec3 p2 = vec3(4., 3., 2.);\n    vec3 p3 = vec3(4., 0., 2.);\n\n    vec4 a = findClosest(sdfCapsule(p, p1, p2, r), sdfCapsule(p, p2, p3, r));\n    float lamda = 0.6;\n    a = findClosest(a, sdfCapsule(p, lamda*p1 + (1.-lamda)*p2, lamda*p3 + (1.-lamda)*p2, 0.2));\n\n    vec3 rgb = vec3(156., 203., 231.) / 255.;\n\n    return vec4(rgb, a.a);\n}\n\nvec4 sdfS(in vec3 p)\n{\n\n    float le = 0.4;\n    float r1 = 0.8;\n    float r2 = 0.2;\n\n    //vec4 s = findClosest(sdfCappedTorus(p, sc, ra, rb), sdfCappedTorus(p, sc, ra, rb));\n    vec4 s = sdfSphere(p - vec3(0., 1.5, 2.), 2.);\n    s = findMax(s, sdfLink(p - vec3(2., 2.25, 2.), le, r1, r2), 0.1);\n    vec4 s2 = sdfLink(p - vec3(2.4, 0.65, 2.), le, r1, r2);\n    s2 = findMax(-s2, sdfSphere(p - vec3(1.2, 0., 2.), 2.), 0.1);\n\n    s = smin(s, s2, 0.01);\n\n    vec3 rgb = vec3(222., 125., 116.) / 255.;\n\n    return vec4(rgb, s.a);\n}\n\nvec4 sdfO(in vec3 p)\n{\n\n    float le = 0.58;\n    float r1 = 1.0;\n    float r2 = 0.2;\n\n    vec4 o = sdfLink(vec3(p.y, p.x, p.z) - vec3(1.48, -0.5, 2.), le, r1, r2);\n\n    vec3 rgb = vec3(181., 166., 221.) / 255.;\n\n    return vec4(rgb, o.a);\n}\n\nvec4 sdfU(in vec3 p)\n{\n\n    float le = 1.0;\n    float r1 = 1.0;\n    float r2 = 0.2;\n\n    vec4 u = sdfLink(vec3(p.y, p.x, p.z) - vec3(2.0, -3.3, 2.), le, r1, r2);\n    u = findMax(-u, sdfBox(p - vec3(-3.3, 1.0, 2.), vec3(2.0)), 0.2);\n\n    vec3 rgb = vec3(239., 150., 172.) / 255.;\n\n    return vec4(rgb, u.a);\n}\n\nvec4 sdfL(in vec3 p)\n{\n\n    float r = 0.2;\n    vec3 p1 = vec3(-5.5, 3., 2.);\n    vec3 p2 = vec3(-5.5, 0., 2.);\n    vec3 p3 = vec3(-8.5, 0., 2.);\n\n    vec4 a = smin(sdfCapsule(p, p1, p2, r), sdfCapsule(p, p2, p3, r), 0.1);\n\n    vec3 rgb = vec3(90., 101., 147.) / 255.;\n\n    return vec4(rgb, a.a);\n}\n\n\n\nvec4 sdf(in vec3 p)\n{\n    p = p - vec3(1., 0., 0.);\n\n    vec4 a = sdfA(p);\n    vec4 s = sdfS(p);\n    vec4 o = sdfO(p);\n    vec4 u = sdfU(p);\n    vec4 l = sdfL(p);\n\n\n    vec4 asoul = findClosest(a, sdfPlane(p + 1.));\n    asoul = findClosest(asoul, s);\n    asoul = findClosest(asoul, o);\n    asoul = findClosest(asoul, u);\n    asoul = findClosest(asoul, l);\n\n    return asoul;\n}\n\nvec4 rayMarch(in vec3 ro, in vec3 rd)\n{\n    float t = tMin;\n    for (int i = 0; i < rayMarchTime; i++)\n    {\n        vec3 p = ro + t * rd;\n        vec4 rgbd = sdf(p);\n        float d = rgbd.a;\n        if (t >= tMax || d < epsilon)\n        {\n            return vec4(rgbd.rgb, t);\n        }\n        t += d;\n\n    }\n}\n\nvec3 calcNormal(in vec3 p) // for function f(p)\n{\n    const vec2 k = vec2(1, -1);\n    return normalize(k.xyy * sdf( p + k.xyy * epsilon ).a + \n                     k.yyx * sdf( p + k.yyx * epsilon ).a + \n                     k.yxy * sdf( p + k.yxy * epsilon ).a + \n                     k.xxx * sdf( p + k.xxx * epsilon ).a);\n}\n\nfloat softShadow(in vec3 ro, in vec3 rd, float k)\n{\n    float res = 1.;\n    float ph = 1e20;\n    for( float t = tMin; t < tMax;)\n    {\n        float h = sdf(ro + rd * t).a;\n        if(h < 0.001)\n            return 0.;\n        float y = h * h / (2. * ph);\n        float d = sqrt(h * h - y * y);\n        res = min(res, k * d / max(0., t - y));\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\nvec3 render(vec2 uv)\n{\n    vec3 color = vec3(0.);\n    vec3 ro = eyePos;\n    if (iMouse.z > 0.01)\n    {\n        float theta = iMouse.x / iResolution.x * 2. * PI;\n        ro = vec3(6. * cos(theta), 1., 6. * sin(theta));\n    }\n    vec3 ta = vec3(0.);\n    mat3 cam = setCamera(ta, ro, 0.);\n    vec3 rd = normalize(cam * vec3(uv, 1.));\n    vec4 rgbt = rayMarch(ro, rd);\n    float t = rgbt.a;\n    vec3 rgb = rgbt.rgb;\n\n    if(t < tMax)\n    {\n        vec3 p = ro + t * rd;\n        vec3 v = normalize(-t * rd);\n        vec3 vl = lightPos - p;\n        float r2 = pow(length(vl), 2.);\n        vec3 h = normalize(v + vl);\n        vec3 n = calcNormal(p);\n        vec3 l = normalize(lightPos - p);\n        float nh = max(0., dot(n, h));\n\n        vec3 diffuse = kd * lightInten / r2 * max(0., dot(n, l));\n        vec3 ambient = ka * ambLightInten;\n        vec3 specular = ks * lightInten / r2 * pow(nh, 150.);\n\n        float st = softShadow(p, normalize(vl), 20.);\n\n        color = diffuse * st + ambient + specular;\n        color *= rgb;\n    }\n    else\n    {\n        color = vec3(0.9, 0.8, 0.9);\n    }\n\n    return color;\n\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fixUV(fragCoord);\n    vec3 color = render(uv);\n    \n\n    fragColor = vec4(color, 1.);\n\n}","name":"Image","description":"","type":"image"}]}