{"ver":"0.1","info":{"id":"msySR1","date":"1680716620","viewed":279,"name":"difference of gaussians(dog)","username":"lalaoopybee","description":"1.calc structure tensor\n2.blur structure tensor, find maximal and minimal eigenvectors.\n3.1d DoG perp to edge.\n4.edge aligned blur with lic, then threshold.\n5.2nd edge aligned blur for antialiasing, multiply by base col.","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["dog","npr","lic","etf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//antialiasing 2nd edge aligned blur\n#define K 6//[3, 10]\n#define SIGMA_A 3.2//[0, 3]\n\n#define GETDIR(a) normalize(texture(iChannel1, a).xy)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv=fragCoord/iResolution.xy;\n    \n    vec2 pt0=fragCoord+.5, pt=pt0;\n    vec2 dir0=GETDIR(uv), dir=dir0;\n    vec2 sum=vec2(0);\n    for(int i=-K;i<=K;i++){\n        //which way are we going?\n        switch(sign(i)){\n            case -1://behind: step back\n                pt-=dir;\n                break;\n            case 0://middle: init for ahead\n                pt=pt0;\n                dir=dir0;\n                break;\n            case 1://ahead: step forward\n                pt+=dir;\n                break;\n        }\n        //sampling\n        float weight=gaussian(pt-pt0, SIGMA_A);\n        vec2 ptUV=pt/iResolution.xy;\n        vec4 col=texture(iChannel2, ptUV);\n        sum+=vec2(col.r, 1.)*weight;\n        dir=GETDIR(ptUV);\n    }\n    float mean=sum.x/sum.y;\n    \n    vec4 col=texture(iChannel0, uv);\n    //vec3 saturated=col.rgb/max(col.r, max(col.g, col.b));\n    fragColor=col*mean;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//make structure tensor from partial derivative using sobel operator\nmat3 sobelX=mat3(\n    -1., 0., 1.,\n    -2., 0., 2.,\n    -1., 0., 1.\n);\n\nmat3 sobelY=mat3(\n    1., 2., 1.,\n    0., 0., 0.,\n    -1., -2., -1.\n);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec3 gradX=vec3(0.);\n    vec3 gradY=vec3(0.);\n    for(int i=0;i<3;i++){\n        for(int j=0;j<3;j++){\n            vec2 kernCoord=fragCoord+vec2(i-1, j-1);\n            vec2 kernUV=kernCoord/iResolution.xy;\n            vec3 col=texture(iChannel0, kernUV).rgb;\n            gradX+=sobelX[i][j]*col;\n            gradY+=sobelY[i][j]*col;\n        }\n    }\n    gradX*=.25;\n    gradY*=.25;\n    \n    float e=dot(gradX, gradX);\n    float f=dot(gradX, gradY);\n    float g=dot(gradY, gradY);\n    fragColor=vec4(e, f, g, 1.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//blur structure tensor, calc eigenvectors. this is the etf.\n#define K 10\n#define SIGMA_C 2.9//[0, 5]\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv=fragCoord/iResolution.xy;\n    \n    vec4 sum=vec4(0.);\n    for(int i=0;i<2*K+1;i++){\n        for(int j=0;j<2*K+1;j++){\n            vec2 offset=vec2(i-K, j-K);\n            float weight=gaussian(offset, SIGMA_C);\n            \n            vec2 offsetUV=offset/iResolution.xy;\n            vec3 efg=texture(iChannel0, uv+offsetUV).rgb;\n            sum+=vec4(efg, 1.)*weight;\n        }\n    }\n    vec3 efg=sum.rgb/sum.a;\n    \n    //calc eigenvalues\n    float e=efg.x, f=efg.y, g=efg.z;\n    float sqeg24f2=sqrt(pow(e-g, 2.)+4.*f*f);\n    float l1=(e+g+sqeg24f2)*.5;\n    float l2=(e+g-sqeg24f2)*.5;\n    \n    //calc eigenvectors\n    vec2 v1=vec2(f, l1-e);//maximal, gradient\n    vec2 v2=vec2(l2-g, f);//minimal, tangent\n    fragColor=vec4(v1, v2);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//difference of 1d gaussians\n#define K 10\n#define SIGMA_E 3.5//[0, 5]\n#define SIGMA_K 2.5//[1, 5]\n\n#define TAU 1.4//?sharpness?\n\n#define N 5//posterize palette size\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv=fragCoord/iResolution.xy;\n    vec2 dir=normalize(texture(iChannel1, uv).xy);\n    \n    vec4 sumA=vec4(0.), sumB=sumA;\n    for(int i=-K;i<=K;i++){\n        vec2 offset=dir*float(i);\n        float weightA=gaussian(offset, SIGMA_E);\n        float weightB=gaussian(offset, SIGMA_E*SIGMA_K);\n        \n        vec2 offsetUV=offset/iResolution.xy;\n        vec4 col=texture(iChannel0, uv+offsetUV);\n        sumA+=vec4(col.rgb, 1.)*weightA;\n        sumB+=vec4(col.rgb, 1.)*weightB;\n    }\n    vec3 meanA=sumA.rgb/sumA.a;\n    vec3 meanB=sumB.rgb/sumB.a;\n    vec3 diff=(1.+TAU)*meanA-TAU*meanB;\n    fragColor=vec4(diff, 1.);\n    \n    //posterize\n    fragColor=floor(fragColor*float(N-1)+.5)/float(N-1);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"//edge aligned blur, threshold\n#define K 7//[3, 10]\n#define SIGMA_M 2.8//[0, 5]\n\n#define PHI 2.9//[0, 10]\n#define EPSILON .8//[0, 1]\n#define LUM(a) dot(a, vec3(.299, .587, .114))\n\n#define GETDIR(a) normalize(texture(iChannel0, a).xy)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv=fragCoord/iResolution.xy;\n    \n    vec2 pt0=fragCoord+.5, pt=pt0;\n    vec2 dir0=GETDIR(uv), dir=dir0;\n    vec4 sum=vec4(0);\n    for(int i=-K;i<=K;i++){\n        //which way are we going?\n        switch(sign(i)){\n            case -1://behind: step back\n                pt-=dir;\n                break;\n            case 0://middle: init for ahead\n                pt=pt0;\n                dir=dir0;\n                break;\n            case 1://ahead: step forward\n                pt+=dir;\n                break;\n        }\n        //sampling\n        float weight=gaussian(pt-pt0, SIGMA_M);\n        vec2 ptUV=pt/iResolution.xy;\n        vec4 col=texture(iChannel1, ptUV);\n        sum+=vec4(col.rgb, 1.)*weight;\n        dir=GETDIR(ptUV);\n    }\n    vec3 mean=sum.rgb/sum.a;\n    \n    float diff=LUM(mean);\n    if(diff>EPSILON) fragColor=vec4(1.);\n    else fragColor=vec4(1.+tanh(PHI*(diff-EPSILON)));\n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PI 3.1415927\n\nfloat gaussian(vec2 pos, float sigma){\n    float left=1./(2.*PI*sigma*sigma);\n    float right=exp(-dot(pos, pos)/(2.*sigma*sigma));\n    return left*right;\n}","name":"Common","description":"","type":"common"}]}