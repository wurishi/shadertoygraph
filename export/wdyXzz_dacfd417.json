{"ver":"0.1","info":{"id":"wdyXzz","date":"1574261870","viewed":531,"name":"Parallax Window Box Test","username":"Delvar","description":"just a test of parallax windows for another shader i'm tinkering with, thought id share it separately.\nUsed here https://www.shadertoy.com/view/WdyXzz","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["test","parallax","window"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// =================================================================\n//  'Parallax Window Box Test'\n//  https://www.shadertoy.com/view/wdyXzz\n//  License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//  Used in this shader https://www.shadertoy.com/view/WdyXzz\n//\n//\tCredits: \n//\tWindows inspired by but no longer bassed off otaviogood : 'Skyline' : https://www.shadertoy.com/view/XtsSWs\n//\tStarted from scratch with a parallax affect, lots of info taken from differnt palces but mainly this implementation, https://andrewgotow.com/2018/09/09/interior-mapping-part-1/\n//\tSome very good points here, like making the effect in texture space, and the optimisation of only needing to check 3 faces, which seems obvius once I read it.\n//\tObviusly my implementation doesn't use a cube texture for the interior, instead generates some pastal shaded walls.\n//\tI have added a fade to solid colour at distance too, no point doing the extra work for a window thats only a few pixles wide.\n//\n//\tThe bulk of the ray tracer and lighting was inspired by watching a video by Inigo Quilez https://www.youtube.com/watch?v=Cfe5UQ-1L9Q\n//\tand his related shadertoy iq: 'Happy Jumping' : https://www.shadertoy.com/view/3lsSzf\n//\n//\tDistance functions from https://iquilezles.org/articles/distfunctions\n//\t\tand implementation iq : 'Raymarching - Primitives' : https://www.shadertoy.com/view/Xds3zN\n//\n//\tMost of the other Math came from wikipedia https://www.wikipedia.org/\n// =================================================================\n\n#define RAY_MAX_STEPS 100\n#define RAY_MAX_DISTANCE 10.0\n#define OBJECT_MIN_SURFACE_DISTANCE 0.0001\n\n#define RAY_MAX_STEPS_SHADOW 30\n#define OBJECT_MIN_SURFACE_DISTANCE_SHADOW 0.01\n#define OBJECT_MIN_SURFACE_DISTANCE_SHADOW_OFFSET 0.041\n\n#define RAY_MAX_STEPS_REFLECTION 30\n#define RAY_MAX_DISTANCE_REFLECTION 10.0\n#define OBJECT_MIN_SURFACE_DISTANCE_REFLECTION 0.01\n#define OBJECT_MIN_SURFACE_DISTANCE_REFLECTION_OFFSET 0.041\n\n#define PI 3.1415926535897932384626433832795\n#define PARALLAX_INTERROOM_WALL_THICKNESS 0.47\n#define PARALLAX_INTERROOM_WALL_COLOUR vec3(0.01)\n#define PARALLAX_WINDOW_SURROUND_THICKNESS 0.1\n#define PARALLAX_WINDOW_SURROUND_COLOUR vec3(0.05)\n\n//Just for fun i added a cube map for the interior mapping ... \n//#define PARALLAX_CUBE_MAP iChannel0\n\n#define DEBUG_RAY_DITHER\n//#define DEBUG_CAMERA_FLY\n#define DEBUG_CAMERA_TABLE\n#define DEBUG_DISTANCE_FOG\n#define DEBUG_LIGHTING\n#define DEBUG_AMBIENT\n//#define DEBUG_AMBIENT_OCCLUSION\n#define DEBUG_OCCLUSION   // used instead of DEBUG_AMBIENT_OCCLUSION when you want the efect but without adding DEBUG_AMBIENT or DEBUG_LIGHTING\n#define DEBUG_REFLECTION\n#define DEBUG_REFLECTION_FRESNEL\n\n//change the filtering method, Linier, Smoothstep or Quintic, little visual change when noise is stacked but can impact performance.\n//#define VALUE_NOISE_FILTER_SMOOTH\n#define VALUE_NOISE_FILTER_QUINTIC\n\n// Flags to use texture lookups instead of noise functions, should be faster but introduces repetiton.\n//#define NOISE_TEXTURE_3D iChannel0\n//#define NOISE_TEXTURE_2D iChannel1\n\n// -- The Materials\n#define MAT_SKY \t0\n#define MAT_WINDOW\t1\n#define MAT_WALL\t2\n#define MAT_SOLID\t3\n\n\n// ========== Structs ==========\n\nstruct camera {\n    vec3 origin, forward, right, up;\n    mat3 rotationMatrix;\n    float roll, pitch, yaw;\n    float zoom; // Distance from screen\n};\n\nstruct ray {\n    vec3 origin, direction;\n};\n\nstruct rayMarchHit {\n    vec3 origin, surfaceNormal;\n    float distance;\n    vec3 neon;\n    int materialId;\n    int iteration;\n};\n\n// ========== ==========\n\n// ========== Constants ==========\n\nconst float gridSize = 5.0;\nconst float gridSizeH = gridSize*0.5;\nconst float gridSizeQ = gridSize*0.25;\n\nconst float roadLength = gridSize*5.0;\nconst float roadLengthH = roadLength*0.5;\nconst float roadLengthQ = roadLength*0.25;\n\nconst float roadWidth = gridSize;\nconst float roadWidthH = roadWidth*0.5;\nconst float roadWidthQ = roadWidth*0.25;\n\nconst float blockSize = roadLength + gridSize;\nconst float blockSizeH = blockSize*0.5;\nconst float blockSizeQ = blockSize*0.25;\n\nconst vec3 roadLightColour = vec3(0.9,0.6,0.1);\nconst float roadLightBrightness = 5.0;\n\n// ========== ==========\n\n// ========== Rotation ==========\n\nmat3 rotateX(float pitch){\n    float cPitch = cos(pitch), sPitch = sin(pitch);\n    return mat3(\t1.0,\t0.0,\t0.0,\n                0.0,\tcPitch,\tsPitch,\n                0.0,\t-sPitch,\tcPitch);\n}\n\nmat3 rotateY(float yaw){\n    float cYaw = cos(yaw), sYaw = sin(yaw);\n    return mat3(\tcYaw,\t0.0,\tsYaw,\n                0.0,\t1.0,\t0.0,\n                -sYaw,\t0.0,\tcYaw);\n}\n\nmat3 rotateZ(float roll){\n    float cRoll = cos(roll), sRoll = sin(roll);\n    return mat3(\tcRoll,\t-sRoll,\t0.0,\n                sRoll,\tcRoll,\t0.0,\n                0.0,\t0.0,\t1.0);\n}\n\nmat3 eulerToMatrix(float roll, float pitch, float yaw){\n    //return rotateX(pitch) * rotateY(yaw) * rotateZ(roll);\n    return  rotateZ(roll) * rotateX(pitch) * rotateY(yaw);\n}\n\n//Converts a unit vector into polar coordinates , vec2(Yaw, Pitch).\nvec2 toPolar(vec3 point) {\n    return vec2(atan(point.x,point.z),asin(point.y));\n}\n\n// ========== ==========\n\n// ========== Ray Constructor ==========\n\nray getRay(vec2 uv, camera camera) {\n    ray ray;\n    ray.origin = camera.origin;\n    vec3 center = ray.origin + camera.forward * camera.zoom;\n    vec3 intersection = center + (uv.x * camera.right) + ( uv.y * camera.up );\n    ray.direction = normalize(intersection - ray.origin);\n    return ray;   \n}\n\nray getRefRay(vec3 origin, vec3 normal, vec3 originalDirection) {\n    ray ray;\n    ray.direction = normalize(reflect(originalDirection, normal));\n    ray.origin = origin + ray.direction*OBJECT_MIN_SURFACE_DISTANCE_REFLECTION_OFFSET;\n    return ray;   \n}\n\n// ========== ==========\n\n// ========== Hash Functions ==========\n\n#define HD 43758.5453123\n#define HE 12.989824344\n#define HF 78.233235235\n#define HG 44.230257362\n#define HH 83.597411735\n\nfloat hash11(float st) {\n    #if defined(NOISE_TEXTURE_3D)\n    return texelFetch( NOISE_TEXTURE_3D, ivec3(vec3(HF,HG,HH)*st)&31,0).x;\n    #elif defined(NOISE_TEXTURE_2D)\n    return texelFetch( NOISE_TEXTURE_2D, ivec2(vec2(HF,HG)*st)&255,0).x;\n    # else\n    return fract(sin(st*HE)*HD); \n    #endif\n}\n\nfloat hash21(vec2 st) {\n    #if defined(NOISE_TEXTURE_3D)\n    return texelFetch( NOISE_TEXTURE_3D, ivec3(st*HE,(st.x*st.y)*HE) &31,0).x;\n    #elif defined(NOISE_TEXTURE_2D)\n    return texelFetch( NOISE_TEXTURE_2D, ivec2(st*HE)&255,0).x;\n    # else\n    return fract(sin(dot(st,vec2(HE,HF)))*HD);\n    #endif\n}\n\nfloat hash31(vec3 st) {\n    #if defined(NOISE_TEXTURE_3D)\n    return texelFetch( NOISE_TEXTURE_3D, ivec3(st*HE)&31,0).x;\n    #elif defined(NOISE_TEXTURE_2D)\n    return texelFetch( NOISE_TEXTURE_2D, ivec2(st.x*HE+st.z*HF,st.y*HG+st.z*HH)&255,0).x;\n    # else\n    return fract(sin(dot(st,vec3(HE,HF,HG)))*HD);\n    #endif\n}\n\n\n//FIXME: find alternativs with texture lookup\nvec3 hash13(float st) {\n    return fract(sin(st*vec3(HE,HH,HG))*HD);\n}\n\nvec3 hash23(vec2 st) {\n    return fract(sin(st.xyx*vec3(HE,HF,HH))*HD);\n}\n\nvec3 hash33(vec3 st) {\n    return fract(sin((st+vec3(HD,HH,HE))*vec3(HH,HE,HG))*HD);\n}\n\n// ========== ==========\n\n// ========== Helper Functions ==========\n\n//Simple remap of value and range to new value in new range\nfloat map(float value, float min1, float max1, float min2, float max2) {\n    return (value - min1) / (max1 - min1) * (max2 - min2) + min2;\n}\n\nvec3 valueNoiseFilter(vec3 x) {\n    #if defined(VALUE_NOISE_FILTER_QUINTIC)\n    return x*x*x*(x*(x*6.-15.)+10.);\n    #elif defined(VALUE_NOISE_FILTER_SMOOTH)\n    return smoothstep(0.0,1.0,x);\n    #else\n    return x;\n    #endif\n}\n\nvec2 valueNoiseFilter(vec2 x) {\n    #if defined(VALUE_NOISE_FILTER_QUINTIC)\n    return x*x*x*(x*(x*6.-15.)+10.);\n    #elif defined(VALUE_NOISE_FILTER_SMOOTH)\n    return smoothstep(0.0,1.0,x);\n    #else\n    return x;\n    #endif\n}\n\nfloat valueNoiseFilter(float x) {\n    #if defined(VALUE_NOISE_FILTER_QUINTIC)\n    return x*x*x*(x*(x*6.-15.)+10.);\n    #elif defined(VALUE_NOISE_FILTER_SMOOTH)\n    return smoothstep(0.0,1.0,x);\n    #else\n    return x;\n    #endif\n}\n\nfloat lengthSquare(vec2 a) {\n    return dot(a,a);\n}\n\nfloat lengthSquare(vec3 a) {\n    return dot(a,a);\n}\n\n//get the maximum of the 3 componants\nfloat max3 (vec3 v) {\n  return max (max (v.x, v.y), v.z);\n}\n\n// ========== ==========\n\n// ========== Coherent Noise ==========\n\n// - Value Noise, 3d, Unsigned\nfloat valueNoise3du(vec3 samplePoint) {\n    vec3 pointI = floor(samplePoint);\n    vec3 pointF = fract(samplePoint);\n    vec3 u = valueNoiseFilter(pointF);\n\n    //Slight Optimisation\n    vec4 m = mix(\n        vec4(\n            hash31(pointI ),//bbl,\n            hash31(pointI + vec3(0.0,1.0,0.0) ),//btl,\n            hash31(pointI + vec3(0.0,0.0,1.0) ),//fbl,\n            hash31(pointI + vec3(0.0,1.0,1.0) )//ftl\n        ),vec4(\n            hash31(pointI + vec3(1.0,0.0,0.0) ),//bbr,\n            hash31(pointI + vec3(1.0,1.0,0.0) ),//btr,\n            hash31(pointI + vec3(1.0,0.0,1.0) ),//fbr,\n            hash31(pointI + vec3(1.0,1.0,1.0) )//ftr\n        ),u.x);\n\n    vec2 n = mix(m.xz, m.yw, u.y);\n    return mix(n.x,n.y,u.z);\n}\n\n\n// - Value Noise, 2d, Unsigned\nfloat valueNoise2du(vec2 samplePoint) {\n    vec2 pointI = floor(samplePoint);\n    vec2 pointF = fract(samplePoint);\n    vec2 u = valueNoiseFilter(pointF);\n\n    vec2 m = mix(\n        vec2(\n            hash21(pointI), //bl\n            hash21(pointI + vec2(0.0,1.0)) //fl\n        ),\n        vec2(\n            hash21(pointI + vec2(1.0,0.0) ),//br\n            hash21(pointI + vec2(1.0,1.0) ) //fr\n        ),u.x);\n\n    return mix(m.x,m.y,u.y);\n}\n\n// - Value Noise, 1d, Unsigned\nfloat valueNoise1du(float samplePoint) {\n    float pointI = floor(samplePoint);\n    return mix(hash11(pointI),hash11(pointI + 1.0 ),valueNoiseFilter(fract(samplePoint)));\n}\n\n// - Value Noise, 1d, Unsigned, Wraped\nfloat valueNoise1duw(float samplePoint, float wrap) {\n    float pointI = floor(samplePoint);\n    return mix(hash11(mod(pointI, wrap)),hash11(mod(pointI + 1.0 ,wrap)),valueNoiseFilter(fract(samplePoint)));\n}\n\n// ========== ==========\n\n// ========== Distance Feilds ==========\n// All primitives are centered at the origin.\n\n// == 2D ==\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\n// == ==\n\n// == 3D ==\n\nfloat sdPlane( vec3 p )\n{\n    return p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdXAlignedCapsule( vec3 p, float l, float r )\n{\n    p.z -= clamp( p.z, 0.0, l );\n    return length(p) - r;\n}\n\nfloat sdYAlignedCapsule( vec3 p, float l, float r )\n{\n    p.y -= clamp( p.y, 0.0, l );\n    return length(p) - r;\n}\n\nfloat sdZAlignedCapsule( vec3 p, float l, float r )\n{\n    p.x -= clamp( p.x, 0.0, l );\n    return length(p) - r;\n}\n\nfloat sdXAlignedCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.yz),p.x)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdYAlignedCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n// == ==\n\n// ========== ==========\n\nfloat getFog(vec3 direction, float time) {\n    time=time*0.1;\n    float fog = 0.0;\n    vec2 t = vec2(time,-time);\n\n    fog+= valueNoise3du(direction + vec3(t.x));\n    fog+= valueNoise3du((direction + vec3(t.xyx)) * 2.0) * 0.5;\n    fog+= valueNoise3du((direction + vec3(t.xxy)) * 4.0) * 0.25;\n    fog+= valueNoise3du((direction + vec3(t.yyy)) * 8.0) * 0.125;\n    fog+= valueNoise3du((direction + vec3(t.yyy)) * 16.0)* 0.0625;\n    \n    //return fog/1.9375;\n    return fog;//*0.516129032258;\n}\n\n// --quick hack to strobe the road lights so they always strobe away from the camera\n\nfloat getRoadLightStrobe(float distanceFromCamera, float time) {\n    return smoothstep(0.0,1.0,clamp(sin(time*5.0 - (distanceFromCamera/RAY_MAX_DISTANCE)*PI*5.0)*0.5,0.0,1.0));\n}\n\n// ========== ==========\n\n// ========== Camera Motion ==========\n\nvec3 getCameraPath(float time) {\n    time *= 0.05;\n\n    float b = blockSize;\n\n    vec3 path[16];\n    int i=0;\n\n    path[i++] = vec3( 0.0*b,\t0.0,\t 0.0*b);\n    path[i++] = vec3( 0.0*b,\t0.0,\t 1.0*b - gridSize);\n    path[i++] = vec3( 0.0*b,\t0.0,\t 1.0*b + gridSize);\n    path[i++] = vec3( 0.0*b,\t0.0,\t 2.0*b);\n    path[i++] = vec3( 2.0*b - 1.0,\t0.0,\t 2.0*b);\n    path[i++] = vec3( 2.0*b,\t1.0*b,\t 2.0*b);\n    path[i++] = vec3( 2.0*b,\t1.0*b,\t 0.0*b);\n    path[i++] = vec3( 4.0*b,\t1.0*b,\t 0.0*b);\n    path[i++] = vec3( 4.0*b,\t1.0*b,\t-2.0*b+1.0);\n    path[i++] = vec3( 4.0*b,\t0.0,\t-2.0*b);\n    path[i++] = vec3( 2.0*b,\t0.0,\t-2.0*b);\n    path[i++] = vec3( 2.0*b,\t0.0,\t-4.0*b);\n    path[i++] = vec3( 0.0*b,\t0.0,\t-4.0*b);\n    path[i++] = vec3( 0.0*b,\t0.0,\t-2.0*b);\n    path[i++] = vec3(-2.0*b,\t0.0,\t-2.0*b);\n    path[i++] = vec3(-2.0*b,\t0.0,\t 0.0*b);\n\n    time = mod(time,float(path.length()));\n\n    float cornerRadius = 0.1;\n    float inverseCornerRadius = 1.0 - cornerRadius;\n\n    int timeI = int(floor(time));\n    float timeF = fract(time)*inverseCornerRadius+cornerRadius;\n\n    vec3 p0 = path[timeI];\n    vec3 r;\n    timeI += 1;\n    if (timeI>=path.length()) {\n        timeI = 0;\n    }\n    vec3 p1 = path[timeI];\n    if (timeF >= inverseCornerRadius) {\n        timeI += 1;\n        if (timeI>=path.length()) {\n            timeI = 0;\n        }\n        vec3 p2 = path[timeI];\n        vec3 p01 = p0 + ((p1-p0) * (inverseCornerRadius));\n        vec3 p12 = p2 + ((p1-p2) * (inverseCornerRadius));\n        float t = map(timeF,inverseCornerRadius,1.0,0.0,1.0);\n        vec3 a = mix(p01,p1,t);\n        vec3 b = mix(p1,p12,t);\n        r= mix(a,b,t);\n    } else {\n        r=mix( p0, p1, timeF);\n    }\n\n\n    vec3 rd;\n    rd.y = (sin(time*5.0) + sin(time*9.0)) * 0.8;\n    rd.x = sin(time*6.0) + sin(time*8.0);\n    rd.z = sin(time*7.0) + sin(time*7.0);\n\n    rd *= sin(fract(time)*PI);\n    rd *= clamp(length(r)/gridSize-gridSize,0.0,1.0);\n    r+=rd*0.5;\n    return r;\n}\n\ncamera getCamera(vec3 origin, float roll, float pitch, float yaw, float zoom) {\n    camera camera;\n    camera.origin = origin;\n    mat3x3 rotationMatrix = eulerToMatrix( roll, pitch, yaw);\n\n    camera.forward = vec3(0.0,0.0,1.0) * rotationMatrix;\n    camera.right = vec3(1.0,0.0,0.0) * rotationMatrix;\n    camera.up = vec3(0.0,1.0,0.0) * rotationMatrix;\n\n    camera.rotationMatrix = rotationMatrix;\n    camera.roll = roll;\n    camera.pitch = pitch;\n    camera.yaw = yaw;\n\n    camera.zoom = zoom;\n    return camera;\n}\n\ncamera getCamera(vec3 lookAt, float distance, float roll, float pitch, float yaw, float zoom) {\n    camera camera;\n    \n\tmat3x3 rotationMatrix = eulerToMatrix( roll, pitch, yaw );\n\n    camera.forward = vec3(0.0,0.0,1.0) * rotationMatrix;\n    camera.right = vec3(1.0,0.0,0.0) * rotationMatrix;\n    camera.up = vec3(0.0,1.0,0.0) * rotationMatrix;\n\n    camera.origin = lookAt + camera.forward*-distance;\n    \n    camera.rotationMatrix = rotationMatrix;\n    camera.roll = roll;\n    camera.pitch = pitch;\n    camera.yaw = yaw;\n\n    camera.zoom = zoom;\n    return camera;\n}\n\ncamera getCamera(vec3 origin, vec3 forward, float roll, float zoom) {\n    float yaw = atan(forward.x,forward.z);\n    float pitch = asin(forward.y);\n    return getCamera(origin, roll, pitch, yaw, zoom);\n}\n\ncamera getCamera(vec2 mouse, float time) {\n    #if defined(DEBUG_CAMERA_FLY)\n    vec3 cameraPos1 = getCameraPath(time);\n    if (iMouse.z<0.5) {\n        vec3 cameraPos2 = getCameraPath(time+0.5);\n        vec3 cameraPos3 = getCameraPath(time-0.5);\n\n        vec3 cameraForward = normalize(cameraPos2 - cameraPos1);\n\n        vec3 cameraForward2 = normalize(cameraPos1 - cameraPos3);\n\n        //Take atan and nivt to -1 to +1 range\n        float yaw1 = atan(cameraForward.x,cameraForward.z)/PI;\n        float yaw2 = atan(cameraForward2.x,cameraForward2.z)/PI;\n\n        // get the differance and renormalize using fract.\n        float roll = -(fract((yaw1-yaw2)*0.5+0.5)*2.0-1.0);\n        roll = clamp(roll,-0.5,0.5);//clamp(-0.1,0.1,1.0-pow(1.0-roll,5.0));\n        return getCamera(cameraPos1, cameraForward, roll,  0.5);\n    } else  {\n        return getCamera(cameraPos1, 0.0, mouse.y*PI, mouse.x*2.0*PI,  0.5);\n    }\n    #elif defined(DEBUG_CAMERA_TABLE)\n    return getCamera(vec3(0.0)+vec3(0.5), 2.5, 0.0, -mouse.y*PI, -mouse.x*2.0*PI,  0.5);\n    #else\n    return getCamera(vec3(0.0,0.0,-5.0), 0.0, mouse.y*PI, mouse.x*2.0*PI,  0.5);\n    #endif\n}\n\n// ========== ==========\n\n// ========== Ray Marcher ==========\n\nrayMarchHit GetRayMarchHit(vec3 position, float time) {\n    rayMarchHit hit;\n    #if defined(DEBUG_USE_SQUARE_DISTANCE)\n    hit.distance = RAY_MAX_DISTANCE*RAY_MAX_DISTANCE;\n    #else\n    hit.distance = RAY_MAX_DISTANCE;\n    #endif\n\n    float newDistance = hit.distance;\n\n    newDistance = min(newDistance, sdBox( position-vec3(0.5), vec3(0.48) )-0.02);\n    newDistance = min(newDistance, sdBox( position-vec3(0.5) - vec3(1.0,0.0,sin(time*0.5)), vec3(0.48))-0.02);\n    newDistance = min(newDistance, sdBox( position-vec3(0.5) - vec3(-1.0,sin(time*0.5),0.0), vec3(0.48))-0.02);\n    newDistance = min(newDistance, sdBox( position-vec3(0.5) - vec3(sin(time*0.5),1.0,0.0), vec3(0.48))-0.02);\n   \n    newDistance = min(newDistance, sdYAlignedCappedCylinder( position-vec3(0.5,-0.5,0.0), 0.98, 0.48 )-0.02);\n    newDistance = min(newDistance, sdXAlignedCappedCylinder( position-vec3(1.25,-0.5,0.0), 1.48, 0.23 )-0.02);\n\n    if (newDistance < hit.distance) {\n        hit.origin = position;\n        hit.distance = newDistance;\n        hit.materialId = MAT_WALL;\n    }\n    \n    /*if (newDistance < hit.distance) {\n        hit.origin = position;\n        hit.distance = newDistance;\n        hit.materialId = MAT_WINDOW;\n    }*/\n    \n    return hit;\n}\n\nrayMarchHit RayMarch(ray ray, float maxDistance, float minSurfaceDistance, int maxSteps, float time)\n{\n    rayMarchHit hit;\n    float accumilatedDistance = 0.0;\n    float modulatedMinSurfaceDistance = minSurfaceDistance;\n    int i;\n    for(i=0; i<maxSteps; i++) {\n        float distanceRatio = clamp((accumilatedDistance/maxDistance),0.0,1.0);\n\n        //the more itterations the less precise we are, improve perfomance a bit with only mild artifacts\n        modulatedMinSurfaceDistance=mix(minSurfaceDistance,minSurfaceDistance*20.0,distanceRatio);\n\n        vec3 currentPoint = ray.origin + ray.direction * accumilatedDistance;\n        hit = GetRayMarchHit(currentPoint, time);\n\n        #if defined (DEBUG_RAY_DITHER)\n        if(hit.distance > modulatedMinSurfaceDistance*2.0) {\n            //we take smaller steps closer to the camera, gives a better Neon result.           \n            hit.distance *= 0.5+mix(distanceRatio,1.0, hash31(fract(currentPoint+time)))*0.5;\n        }\n        #endif\n\n        accumilatedDistance += hit.distance;\n\n        if(accumilatedDistance >= maxDistance) {\n            accumilatedDistance = maxDistance;\n            hit.surfaceNormal = -ray.direction;\n            hit.materialId=MAT_SKY;\n            break;\n        }\n        //forget bouncing back, if we end up inside just terminate\n        else if(hit.distance < modulatedMinSurfaceDistance) {\n            break;\n        }\n\n    }\n    hit.iteration = i;\n    hit.distance = max(0.0,accumilatedDistance);\n    return hit;\n}\n// ========== ==========\n\n// ========== Texturing ==========\n\n\nfloat getConcreteErosion(vec3 position, bool showLine) {\n    float concrete=0.0;\n    concrete+= valueNoise3du(position * 4.0) * 0.25;\n    concrete+= valueNoise3du(position * 8.0) * 0.125;\n    concrete+= valueNoise3du(position * 16.0) * 0.0625;\n    concrete+= valueNoise3du(position * 32.0) * 0.03125;\n    concrete/=0.25+0.125+0.0625+0.03125;\n    concrete = (abs(concrete*2.0-1.0)+0.3);\n\n    if(showLine) {\n        float line = abs(fract(position.y)-0.5);\n        line = 1.0-clamp(line*25.0,0.0,1.0);\n        line*=line*line*4.0;\n        line = clamp(1.0-line,-10.0,1.0);\n        concrete = min(line,concrete*line);\n    }\n\n    return concrete;\n}\n\nfloat sampleConcrete(vec3 position, bool showLine) {\n    float concrete = valueNoise3du(position * 4.0);\n    concrete += valueNoise3du(position * 8.0) * 0.5;\n    concrete += valueNoise3du(position * 16.0) * 0.25;\n    concrete += valueNoise3du(position * 32.0) * 0.125;\n    concrete /= 1.0+0.5+0.25+0.125;\n    concrete = (abs(concrete*2.0-1.0)+0.8);\n    concrete = clamp(concrete,0.0,1.0);\n\n    if(showLine) {\n        float line = abs(fract(position.y)-0.5);\n        line = 1.0-clamp(line*25.0,0.0,1.0);\n        line*=line*line;\n        line = 1.0-clamp(line-0.2,0.0,1.0);\n        concrete *= line;\n    }\n\n    return concrete;\n}\n\nfloat getConcrete(vec3 position, inout vec3 normal, bool showLine) {\n    float center=getConcreteErosion(position, showLine);\n\n    vec3 rightDir;\n\tvec3 upDir;\n\n    if(abs(normal.y)<0.999) {\n    \trightDir = normalize(cross(vec3(0.0, 1.0, 0.0), normal));\n\t\tupDir = normalize(cross(normal, rightDir));\n    } else {\n        rightDir = normalize(cross(vec3(1.0, 0.0, 0.0), normal));\n\t\tupDir = normalize(cross(normal, rightDir));\n    }\n    float right = getConcreteErosion(position+rightDir*0.01, showLine);\n    float up = getConcreteErosion(position+upDir*0.01, showLine);\n    //FIXME: apply correct normal calculations, this is NOT how you do it!\n    vec3 pNormal;\n    pNormal=(vec3(\n        right - center,\n        up - center,\n        right - center\n    ));\n\n    pNormal*=-1.3;\n    normal = normalize(normal + pNormal);    \n\t   \n    //float concrete=clamp(getConcreteErosion(position, showLine)+0.5,0.0,1.0);\n    float concrete=sampleConcrete(position, showLine);\n    return concrete;\n}\n\nvoid textureSolid(in vec3 block, inout ray ray, inout rayMarchHit hit, inout vec3 colour, in float time) {\n    float concrete = getConcrete(hit.origin, hit.surfaceNormal, true);\n    colour = hash33(block.xyx) * vec3(0.25,0.1,0.2) + 0.5;\n    colour = clamp(colour,vec3(0.0),vec3(1.0));\n    colour *= concrete;\n}\n\n    \n    //Features to implement?\n    //curtains_left\n    //curtains_right\n    //curtains_both\n\t//blinds\n    //circle lights\n    //light spacing\n    //door\n    //door colour\n    \n\t//brightness\n    //light colour\n    //strip lights x, z\n    //ceiling colour\n    //wall colour\n    //floor colour\n    \n    \nvoid textureParallaxWindow(in vec3 block, inout ray ray, inout rayMarchHit hit, in vec2 uv, in vec3 cell, in vec3 lightColour, in float brightness, inout vec3 colour, in float time) {\n    \n    if(abs(uv.x)>PARALLAX_INTERROOM_WALL_THICKNESS||abs(uv.y)>PARALLAX_INTERROOM_WALL_THICKNESS) {\n        colour=PARALLAX_INTERROOM_WALL_COLOUR;\n        return;\n    }\n    \n    vec3 absNormal = abs(hit.surfaceNormal);\n    vec3 flatNormal;\n\n    //flaten the normal so we still project axis aligned with no distortion of y axis curve.\n    if(absNormal.y > absNormal.x && absNormal.y > absNormal.z) {\n        flatNormal = vec3(0.0,1.0,0.0);\n    } else {\n        flatNormal = normalize(vec3(hit.surfaceNormal.x,0.0,hit.surfaceNormal.z));\n    }    \n    \n    vec3 roomSize = vec3(1.0) ;\n    roomSize.z += hash31(cell*16.8736)*2.0;\n        \n    vec3 tangent = normalize(cross(vec3(0.0,1.0,0.0),flatNormal));\n    vec3 bitangent = normalize(cross(flatNormal,tangent));\n    mat3 tMatrix = mat3(tangent,bitangent,flatNormal);\n    \n    vec3 rayDir = normalize(ray.direction*tMatrix)/roomSize;\n    vec3 hitPos = vec3(uv.x,uv.y,0.0)/roomSize;\n\t\n    //Room cube, We assume the room is 1 unit cube from -0.5 to +0.5\n    vec3 roomMin = vec3(-PARALLAX_INTERROOM_WALL_THICKNESS,-PARALLAX_INTERROOM_WALL_THICKNESS,-1.0);\n    vec3 roomMax = vec3(PARALLAX_INTERROOM_WALL_THICKNESS,PARALLAX_INTERROOM_WALL_THICKNESS,0.0);\n    vec3 roomMid = vec3(0.0);\n    \n    //we only need to interesct 3 planes per ray, looking at the direction of the ray find which 3 its heading towards.\n    vec3 planes = mix(roomMin, roomMax, step(0.0, rayDir));\n    //now do the parallax calcualtion to find the project position 'into' the window\n    vec3 planeIntersect = ((planes-hitPos)/rayDir);\n    float distance;\n    \n\t#if defined(PARALLAX_CUBE_MAP)\n    \tdistance = min(planeIntersect.x,min(planeIntersect.y,planeIntersect.z));\n    \tvec3 intersectionPos = ((hitPos + rayDir * distance) );\n    \tvec3 samplePoint = intersectionPos * rotateY(hash31(cell)*PI);\n    \tcolour = texture( PARALLAX_CUBE_MAP, samplePoint ).xyz;\n    \tintersectionPos-=roomMin;\n    #else\n        if(planeIntersect.x < planeIntersect.y && planeIntersect.x < planeIntersect.z) {\n            //Left/Right wall\n            colour=clamp(hash33(cell*48.2270)+0.7,0.0,1.0);\n            distance = planeIntersect.x;\n        } else if (planeIntersect.y < planeIntersect.x && planeIntersect.y < planeIntersect.z) {\n            if(rayDir.y<0.0) {\n                //Floor\n                colour = clamp(hash33(cell*81.7619)+0.3,0.0,1.0);\n            } else {\n                //Ceiling\n                colour =mix(clamp(hash33(cell*20.9912)+0.3,0.0,1.0),\n                            lightColour*6.0,\n                        abs(sin((planeIntersect.y*PI*3.0))));\n            }\n            distance = planeIntersect.y;\n        } else if (planeIntersect.z < planeIntersect.x && planeIntersect.z < planeIntersect.y) {\n            //Back wall\n            colour=clamp(hash33(cell*54.8454)+0.7,0.0,1.0);\n            distance = planeIntersect.z;\n            //colour=vec3(planeIntersect.z);\n        } else {\n            //error!\n            colour=PARALLAX_INTERROOM_WALL_COLOUR;\n            distance = 0.0;   \n        }\n        vec3 intersectionPos = ((hitPos + rayDir * distance) - roomMin);\n    #endif\n        //add some distance and height shadow    \n        colour*=clamp(intersectionPos.z*(1.0-intersectionPos.y)+0.2,0.0,1.0)*brightness*lightColour;\n    \n}\n\nvoid textureWall(in vec3 block, inout ray ray, inout rayMarchHit hit, inout vec3 colour, in float time) {\n    vec2 uv;\n    vec3 absNormal = abs(hit.surfaceNormal);\n    float scale = 2.0;\n\n    if(absNormal.y > absNormal.x && absNormal.y > absNormal.z) {\n        uv.xy=fract(hit.origin.xz*scale)-0.5;\n    } else {\n        if(absNormal.x > absNormal.z) {\n            if(hit.surfaceNormal.x>0.0) {\n                uv.x=1.0-fract((hit.origin.z)*scale);\n            } else {\n                uv.x=fract((hit.origin.z)*scale);\n            }\n        } else {\n            if(hit.surfaceNormal.z>0.0) {\n                uv.x=fract((hit.origin.x)*scale);\n            } else {\n                uv.x=1.0-fract((hit.origin.x)*scale);\n            }\n        }\n        uv.y=fract(hit.origin.y*scale);\n\t\tuv-=0.5;\n        //vec2 windowSize=vec2(1.0);\n        vec2 windowSize=vec2(hash21(block.xy*39.195),hash21(block.xy*26.389))*0.7+0.2;\n\n        if (windowSize.x > 0.8){\n            windowSize.x=1.0;\n        }\n\n        if (windowSize.y > 0.8){\n            windowSize.y=1.0;\n        }\n\n        float round=0.0;\n\n        if (windowSize.x < 1.0 && windowSize.y < 1.0) {\n            round = min(windowSize.x,windowSize.y) * hash21(block.xy*87.981);\n        }\n\n        if ( abs(uv.x*2.0) < windowSize.x+PARALLAX_WINDOW_SURROUND_THICKNESS && abs(uv.y*2.0) < windowSize.y+PARALLAX_WINDOW_SURROUND_THICKNESS) {\n            float distance = sdBox(uv*2.0,windowSize-round)-round;\n            if(distance < 0.0) {\n                vec3 cell = floor(hit.origin*scale) + block*blockSize;\n                bool on = (hash31(cell) + sin(time*0.5)*0.05) > 0.5;\n                hit.materialId = MAT_WINDOW;\n                if(on) {\n                    float brightness = clamp(hash31(cell),0.1,1.0);\n                    vec3 lightColour = clamp(hash33(cell)+0.7,0.0,1.0);\n                    float distanceRatio=hit.distance/RAY_MAX_DISTANCE;\n                    if(distanceRatio<0.3) {\n                        textureParallaxWindow(block, ray, hit, uv, cell, lightColour, brightness, colour, time);\n                        colour*=3.0;\n                        if(distanceRatio>0.2) {\n                            colour=mix(colour,lightColour*3.0*brightness,(distanceRatio-0.2)*10.0);\n                        }\n                        //shade the edge of the glass a bit.\n                        colour = mix(PARALLAX_WINDOW_SURROUND_COLOUR,colour,clamp(abs(distance*20.0),0.0,1.0));\n                    } else {\n                        colour=lightColour*3.0*brightness;\n                    }\n                } else {\n                    colour=vec3(0.0);\n                }\n            } else if(distance < PARALLAX_WINDOW_SURROUND_THICKNESS) {\n                hit.materialId = MAT_WINDOW;\n                colour=PARALLAX_WINDOW_SURROUND_COLOUR;\n            } \n        }\n    }\n    \n    if (hit.materialId != MAT_WINDOW){\n        float concrete = getConcrete(hit.origin, hit.surfaceNormal, true);\n        colour = hash33(block.xyx) * vec3(0.25,0.1,0.2)+0.5;\n        colour = clamp(colour,vec3(0.0),vec3(1.0));\n        colour *= concrete;\n    }\n}\n\n// ========== ==========\n\nfloat getOcclusion( in vec3 origin, in vec3 normal, float time)\n{\n    float occlusion = 0.0;\n    float scale = 2.0;\n    rayMarchHit hit;\n\n    for( float i=0.0; i<3.0; i++ )\n    {\n        float distance = 0.1*i;\n        vec3  currentPoint = origin + distance*normal;\n        hit = GetRayMarchHit(currentPoint, time);\n        occlusion += (distance-hit.distance)*scale;\n        scale *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occlusion, 0.0, 1.0 );\n}\n\nvoid getOffsetLight(vec3 position, vec3 normal, vec3 rayDirection, vec3 lightOffset, float maxDistance, float shininess, out float diffuseBrightness, out float specularBrightness) {\n    float distance = length(lightOffset);\n    if (distance > maxDistance) {\n        diffuseBrightness=0.0;\n        specularBrightness=0.0;\n        return;\n    }\n    vec3 lightDirection = normalize(lightOffset);\n    float dotProd = dot(lightDirection,normal);\n\n    if (dotProd <= 0.0) {\n        diffuseBrightness=0.0;\n        specularBrightness=0.0;\n        return;\n    }\n\n    //fake the light falloff to limit distance\n    float fallOff = (1.0-clamp((distance/maxDistance),0.0,1.0));\n    fallOff*=fallOff;\n\n    //dotProd = pow(dotProd,shine);\n    diffuseBrightness = clamp(dotProd,0.0,1.0) * fallOff;\n\n    vec3 specDirection = reflect(lightDirection, normal);\n    dotProd = dot(specDirection, rayDirection);\n    dotProd = pow(clamp(dotProd,0.0,1.0),shininess);\n    //dotProd *= diffuseBrightness;\n    dotProd *= fallOff;\n    specularBrightness = dotProd;\n}\n\nvoid getLight(vec3 position, vec3 normal, vec3 rayDirection, float shininess, vec3 cameraOrigin, out vec3 diffuseLight, out vec3 specularLight, float time) {\n    diffuseLight = vec3(0.0);\n    specularLight = vec3(0.0);\n\n    // -- Camera Light\n    vec3 lightOrigin = cameraOrigin;\n\n    float diffuseBrightness;// = 0.0;\n    float specularBrightness;// = 0.0;\n\n    getOffsetLight(position, normal, rayDirection,lightOrigin-position, 5.0, shininess, diffuseBrightness, specularBrightness);\n    diffuseLight = vec3(0.5 * diffuseBrightness);\n    specularLight = vec3(0.5 * specularBrightness);\n}\n\n// ========== ==========\n\n// ========== Calculate Normal ==========\n\nfloat map(in vec3 pos, float time ){\n    return GetRayMarchHit(pos, time).distance;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, float time )\n{\n\n    #if 0\n    vec2 e = vec2(1.0,-1.0)*0.005773;\n    return normalize( e.xyy*map( pos + e.xyy, time ) + \n                     e.yyx*map( pos + e.yyx, time ) + \n                     e.yxy*map( pos + e.yxy, time ) + \n                     e.xxx*map( pos + e.xxx, time ) );\n    #else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.001*e,time);\n    }\n    return normalize(n);\n    #endif    \n}\n\n// ==========  ==========\n\n// ========== Get colour for a ray hit ==========\n\nvoid renderRay(inout ray ray, inout rayMarchHit hit, inout vec3 colour, bool isReflection, float time) {\n    vec3 skybox = mix(vec3(0.03,0.1,0.25),vec3(0.5,0.4,0.3),(ray.direction.y*0.5+0.5)+0.2);\n\tvec3 block = vec3(floor((hit.origin.xz+vec2(time*blockSize*0.5,0.0))/blockSize), floor(hit.origin.y));\n    \n    #if defined(DEBUG_OCCLUSION)\n        float occlusion =getOcclusion(hit.origin, hit.surfaceNormal, time);\n    #endif\n    \n    if(hit.materialId == MAT_SKY) {\n        colour = skybox;\n    } else if (hit.materialId == MAT_WALL) {\n        textureWall(block, ray, hit, colour, time);\n    } else if (hit.materialId == MAT_SOLID) {\n        textureSolid(block, ray, hit, colour, time);\n    }\n    #if defined(DEBUG_LIGHTING)\n        vec3 diffuseLight;\n        vec3 specularLight;\n        float shininess = 1.0;\n        float specularIntensity = 0.1;\n\n        if (hit.materialId == MAT_SOLID || hit.materialId == MAT_WALL) {\n            shininess = 5.0;\n            specularIntensity = 2.1;\n        } else if (hit.materialId == MAT_WINDOW) {\n            shininess = 50.0;\n            specularIntensity = 2.0;\n        } \n\n        getLight(hit.origin, hit.surfaceNormal, ray.direction, shininess, ray.origin, diffuseLight, specularLight, time);\n\n        #if defined(DEBUG_AMBIENT)\n            vec3 ambient = skybox;\n            #if defined(DEBUG_AMBIENT_OCCLUSION) && !defined(DEBUG_OCCLUSION)\n                if (hit.materialId == MAT_WALL || hit.materialId == MAT_SOLID) {\n                    ambient *=(getOcclusion(hit.origin, hit.surfaceNormal, time));\n                }\n            #endif\n            diffuseLight += ambient;\n        #endif\n\n        if (hit.materialId != MAT_WINDOW) {\n            colour*=diffuseLight;\n        }\n        colour+=(specularLight*specularIntensity);\n    #endif\n    \n\t#if defined(DEBUG_OCCLUSION)\n\t\tcolour *=occlusion;\n\t#endif\n    \n    #if defined(DEBUG_DISTANCE_FOG)\n    float distanceFog = hit.distance/RAY_MAX_DISTANCE;\n    colour = mix(colour, skybox, distanceFog);\n    #endif\n}\n\n// ==========  ==========\n\n// ========== Entry Point ==========\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    float time = iTime;\n\n    // Normalized Pixel coordinates (from -0.5 to +0.5, center at 0,0)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    // Normalized Mouse coordinates (from -0.5 to +0.5, center at 0,0)\n    vec2 mouse = ((iMouse.xy-0.5*iResolution.xy)/iResolution.y);// - vec2(0.5,0.5)*(iMouse.w*0.1);\n\n    //Snap to center on startup.\n    if((iMouse.x <= 1.0 && iMouse.y <= 1.0)) {\n        mouse = vec2(0.0,0.0);\n    }\n\n    camera camera = getCamera(mouse, time);\n\n    // --\n    ray mainRay = getRay(uv, camera);\n    \n    rayMarchHit hit = RayMarch(mainRay, RAY_MAX_DISTANCE, OBJECT_MIN_SURFACE_DISTANCE, RAY_MAX_STEPS, time);\n    hit.surfaceNormal = calcNormal( hit.origin, time );\n\t\n    // ---- Render\n    vec3 colour;\n    renderRay(mainRay, hit, colour, false, time);\n\n    #if defined(DEBUG_REFLECTION)\n    //if (hit.materialId == MAT_WINDOW) {\n        float distanceRatio = hit.distance/RAY_MAX_DISTANCE;\n        vec3 refColour;    \n        if(distanceRatio<1.0) {\n            float reflection;\n            if (hit.materialId == MAT_SOLID || hit.materialId == MAT_WALL) {\n                reflection = 0.1;\n            } else if (hit.materialId == MAT_WINDOW) {\n                reflection = 0.5;\n            } \n            \n            #if defined(DEBUG_REFLECTION_FRESNEL)\n            \tfloat fresnel = 1.0-max(0.0,-dot(hit.surfaceNormal,mainRay.direction));\n            \treflection=(reflection*fresnel);\n            #endif\n            \n            ray refRay = getRefRay(hit.origin, hit.surfaceNormal, mainRay.direction);\n            rayMarchHit refHit = RayMarch(refRay, RAY_MAX_DISTANCE_REFLECTION, OBJECT_MIN_SURFACE_DISTANCE_REFLECTION, RAY_MAX_STEPS_REFLECTION, time);\n            refHit.surfaceNormal = calcNormal( refHit.origin, time );\n            renderRay(refRay, refHit, refColour, true, time);\n            if(distanceRatio>0.25) {\n                reflection*=1.0-((distanceRatio-0.25)*4.0);\n            } \n            colour = mix(colour,refColour,reflection);\n        } \n   // }\n    #endif\n\t\n    float exposure = 0.5;\n    colour = pow( exposure * colour, vec3(1.0/2.2) );\n    colour = clamp(colour,0.0,1.0); \n    colour = 1.7*colour/(1.0+colour);\n    colour = colour*colour*(3.0-2.0*colour);\n    fragColour = vec4(colour,1.0);\n}","name":"Image","description":"","type":"image"}]}