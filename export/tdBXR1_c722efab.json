{"ver":"0.1","info":{"id":"tdBXR1","date":"1649161945","viewed":267,"name":"Edge Tangent Flow","username":"kam19_77","description":"calc ETF","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["filter"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 src_size = iResolution.xy;\n    vec2 uv = fragCoord/src_size;\n    \n    vec4 c = texture(iChannel0, uv);\n    //float p = length(c.rg);\n    \n    //fragColor = vec4(p, p, p, 1.0);\n    fragColor = vec4(c.rg, 0,1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float CalcGlayScale(in vec4 col) {\n    const vec3 kernel = vec3(0.2126f, 0.7152f, 0.0722f);\n    float glay = dot(kernel, col.rgb);\n    return glay;\n}\n\nvec2 SobelFilter(in vec2 fragCoord) {\n    const vec3 kernel0 = vec3(-1.0f, -2.0f, -1.0f);\n    const vec3 kernel1 = vec3(+1.0f, +2.0f, +1.0f);\n    \n    vec2 SRC_SIZE     = iResolution.xy;\n    vec2 INV_SRC_SIZE = vec2(1.0f, 1.0f) / SRC_SIZE;\n    vec2 uv = fragCoord * INV_SRC_SIZE;\n    \n    vec4 c00 = texture(iChannel0, uv + vec2(-1.0f, -1.0f) * INV_SRC_SIZE);\n    vec4 c01 = texture(iChannel0, uv + vec2( 0.0f, -1.0f) * INV_SRC_SIZE);\n    vec4 c02 = texture(iChannel0, uv + vec2(+1.0f, -1.0f) * INV_SRC_SIZE);\n    vec4 c10 = texture(iChannel0, uv + vec2(-1.0f,  0.0f) * INV_SRC_SIZE);\n    vec4 c12 = texture(iChannel0, uv + vec2(+1.0f,  0.0f) * INV_SRC_SIZE);\n    vec4 c20 = texture(iChannel0, uv + vec2(-1.0f, +1.0f) * INV_SRC_SIZE);\n    vec4 c21 = texture(iChannel0, uv + vec2( 0.0f, +1.0f) * INV_SRC_SIZE);\n    vec4 c22 = texture(iChannel0, uv + vec2(+1.0f, +1.0f) * INV_SRC_SIZE);\n    \n    float y00 = CalcGlayScale(c00);\n    float y01 = CalcGlayScale(c01);\n    float y02 = CalcGlayScale(c02);\n    float y10 = CalcGlayScale(c10);\n    float y12 = CalcGlayScale(c12);\n    float y20 = CalcGlayScale(c20);\n    float y21 = CalcGlayScale(c21);\n    float y22 = CalcGlayScale(c22);\n    \n    float u = 0.0f;\n    u += dot(kernel0, vec3(y00, y10, y20));\n    u += dot(kernel1, vec3(y02, y12, y22));\n    \n    float v = 0.0f;\n    v += dot(kernel0, vec3(y00, y01, y02));\n    v += dot(kernel1, vec3(y20, y21, y22));\n    \n    return vec2(u, v); \n}\n\nvec2 GetPerpendicularVec(in vec2 v)\n{\n    vec2 vv;\n    vv.x = v.y;\n    vv.y = -1.0f * v.x;\n    \n    return vv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 grad = SobelFilter(fragCoord);\n    //grad = normalize(grad);\n    \n    float mag = length(grad);\n    grad = GetPerpendicularVec(grad);\n    \n    //grad = grad * 0.5 + 0.5;\n    \n    //fragColor = vec4(grad, mag, 1.0);\n    fragColor = vec4(grad, 0,1);\n    //fragColor = vec4(dot(grad.x, grad.x), dot(grad.y, grad.y), dot(grad.x, grad.y), 1.0);\n    \n    //fragColor = vec4(mag,mag,mag,1);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define ENABLE_SMOOTHING_GRADIENT\t1\n\nconst float PI = 3.141592653589793238f;\n\nconst float Sigma = 1.0f;\nconst float Sigma2 = Sigma * Sigma;\nconst int Radius = int(Sigma * 3.0f);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 src_size = iResolution.xy;\n    vec2 uv = fragCoord/src_size;\n    \n    #if ENABLE_SMOOTHING_GRADIENT\n    {\n        vec3 accum = vec3(0.0f);\n        for (int y = -Radius; y <= Radius; ++y) {\n            for (int x = -Radius; x <= Radius; ++x) {\n                vec3 w = texture(iChannel0, uv + vec2(x, y) / src_size).rgb;\n                float r = float(x * x + y * y);\n                accum += exp(-r / (2.0f * Sigma2)) / (2.0f * PI * Sigma2) * w;\n            }\n        }\n\n        fragColor = vec4(accum, 1.0);\n    }\n    #else\n    fragColor = texture(iChannel0, uv);\n    #endif\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\nconst int RADIUS   = 5;\nconst float RADIUS_2 = float(RADIUS * RADIUS);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 src_size = iResolution.xy;\n    vec2 inv_src_size = 1.0 / src_size;\n    vec2 uv = fragCoord * inv_src_size;\n    \n    vec3 c0 = texture(iChannel0, uv).rgb;\n    \n    vec2 sum = vec2(0.0,0.0);\n    for (int i = -RADIUS; i <= RADIUS; ++i) {\n    \tfor (int j = -RADIUS; j <= RADIUS; ++j) {\n            if (i != 0 || j != 0) {\n                vec2 uv0 = uv + vec2(i, j) * inv_src_size;\n                vec3 c = texture(iChannel0, uv0).rgb;\n                    \n                float ws = dot(uv, uv0) < RADIUS_2 ? 1.0 : 0.0;\n                float wm = 0.5f * (1.0f + tanh(1.0 * (c.b - c0.b)));\n                float wd = abs(dot(c.rg, c0.rg));\n                \n                sum += sign(dot(c.rg, c0.rg)) * c.rg * wm * wd * ws;\n            }\n        }\n    }\n    sum = normalize(sum);\n    \n    fragColor = vec4(sum, c0.b, 1.0);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\nconst int RADIUS   = 5;\nconst float RADIUS_2 = float(RADIUS * RADIUS);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 src_size = iResolution.xy;\n    vec2 inv_src_size = 1.0 / src_size;\n    vec2 uv = fragCoord * inv_src_size;\n    \n    vec3 c0 = texture(iChannel0, uv).rgb;\n    \n    vec2 sum = vec2(0.0,0.0);\n    for (int i = -RADIUS; i <= RADIUS; ++i) {\n    \tfor (int j = -RADIUS; j <= RADIUS; ++j) {\n            if (i != 0 || j != 0) {\n                vec2 uv0 = uv + vec2(i, j) * inv_src_size;\n                vec3 c = texture(iChannel0, uv0).rgb;\n                    \n                float ws = dot(uv, uv0) < RADIUS_2 ? 1.0 : 0.0;\n                float wm = 0.5f * (1.0f + tanh(1.0 * (c.b - c0.b)));\n                float wd = abs(dot(c.rg, c0.rg));\n                \n                sum += sign(dot(c.rg, c0.rg)) * c.rg * wm * wd * ws;\n            }\n        }\n    }\n    sum = normalize(sum);\n    \n    fragColor = vec4(sum, c0.b, 1.0);\n}","name":"Buffer D","description":"","type":"buffer"}]}