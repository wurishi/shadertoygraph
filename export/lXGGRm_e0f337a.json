{"ver":"0.1","info":{"id":"lXGGRm","date":"1717424651","viewed":58,"name":"[Fork] Oklab-based tonemapper","username":"izutionix","description":"left is Oklab-based tonemapped, right is retonemapped with ACES. \nCompare with mouse.\n\nForked from [url=https://shadertoy.com/view/3lGyRy]Hatchling[/url] who forked it from afl_ext","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["tonemapping","tonemap","oklab"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Oklab-based tonemapper\" by Hatchling. https://shadertoy.com/view/3lGyRy\n// 2024-06-03 14:22:27\n\n// linear to tonemapped\nvec3 ACES(vec3 x) {\n    return x*(2.51*x + .03) / (x*(2.43*x + .59) + .14);\n}\n\n// tonemapped to linear\nvec3 ACES_Inv(vec3 x) {\n    return (sqrt(-10127.*x*x + 13702.*x + 9.) + 59.*x - 3.) / (502. - 486.*x); // thanks to https://www.wolframalpha.com/input?i=2.51y%5E2%2B.03y%3Dx%282.43y%5E2%2B.59y%2B.14%29+solve+for+y\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord)/iResolution.xy;\n\n    vec3 color = texture(iChannel0, uv).xyz;\n    vec3 col_linear = ACES_Inv(color);\n    \n    vec2 mouse = iMouse.xy/iResolution.xy;\n    if(dot(iMouse.xy, vec2(1.))==0.) mouse = .5+.5*vec2(sin(iTime),cos(iTime)); // if no mouse is detected\n    \n    if (mouse.x > uv.x)\n    {\n\t\tcolor = tonemap(2.*col_linear);\n        color = pow(color, vec3(2.2));\n\t}\n    else\n    {\n        color = ACES(col_linear);\n    }\n\n\tfragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define F1 float\n#define F3 vec3\n\nF1 Linear1(F1 c){return(c<=0.04045)?c/12.92:pow((c+0.055)/1.055,2.4);}\nF3 Linear3(F3 c){return F3(Linear1(c.r),Linear1(c.g),Linear1(c.b));}\nF1 Srgb1(F1 c){return(c<0.0031308?c*12.92:1.055*pow(c,0.41666)-0.055);}\nF3 Srgb3(F3 c){return F3(Srgb1(c.r),Srgb1(c.g),Srgb1(c.b));}\n\nvec3 rgb_to_oklab(vec3 c) \n{\n    float l = 0.4121656120f * c.r + 0.5362752080f * c.g + 0.0514575653f * c.b;\n    float m = 0.2118591070f * c.r + 0.6807189584f * c.g + 0.1074065790f * c.b;\n    float s = 0.0883097947f * c.r + 0.2818474174f * c.g + 0.6302613616f * c.b;\n\n    float l_ = pow(l, 1./3.);\n    float m_ = pow(m, 1./3.);\n    float s_ = pow(s, 1./3.);\n\n    vec3 labResult;\n    labResult.x = 0.2104542553f*l_ + 0.7936177850f*m_ - 0.0040720468f*s_;\n    labResult.y = 1.9779984951f*l_ - 2.4285922050f*m_ + 0.4505937099f*s_;\n    labResult.z = 0.0259040371f*l_ + 0.7827717662f*m_ - 0.8086757660f*s_;\n    \n    //labResult.yz /= labResult.x + 1.;\n    \n    return labResult;\n}\n\nvec3 oklab_to_rgb(vec3 c) \n{\n    //c.yz *= c.x + 1.;\n\n    float l_ = c.x + 0.3963377774f * c.y + 0.2158037573f * c.z;\n    float m_ = c.x - 0.1055613458f * c.y - 0.0638541728f * c.z;\n    float s_ = c.x - 0.0894841775f * c.y - 1.2914855480f * c.z;\n\n    float l = l_*l_*l_;\n    float m = m_*m_*m_;\n    float s = s_*s_*s_;\n\n    vec3 rgbResult;\n    rgbResult.r = + 4.0767245293f*l - 3.3072168827f*m + 0.2307590544f*s;\n    rgbResult.g = - 1.2681437731f*l + 2.6093323231f*m - 0.3411344290f*s;\n    rgbResult.b = - 0.0041119885f*l - 0.7034763098f*m + 1.7068625689f*s;\n    return rgbResult;\n}\n\nvec3 tonemap( vec3 linearRGB )\n{\n    const float limitHardness = 1.5;\n    \n    vec3 okl = rgb_to_oklab(linearRGB);\n    \n    // Limit luminance.\n    /*okl.x = okl.x / pow(pow(okl.x, limitHardness) + 1., 1./limitHardness);\n    \n    // Limit magnitude of chrominance.\n    {\n        float mag = length(okl.yz);\n        float magAfter = mag;\n        magAfter *= 4.;\n        magAfter = magAfter / pow(pow(magAfter, limitHardness) + 1., 1./limitHardness);\n        magAfter /= 4.;\n        okl.yz *= magAfter/mag;\n    }*/\n    \n    linearRGB = oklab_to_rgb(okl);\n\n    // Try to keep the resulting value within the RGB gamut while\n    // preserving chrominance and compensating for negative clipping.\n    {\n        {\n            // Compensate for negative clipping.\n            float lumBefore = dot(linearRGB, vec3(0.2126, 0.7152, 0.0722));\n            linearRGB = max(vec3(0), linearRGB);\n            float lumAfter = dot(linearRGB, vec3(0.2126, 0.7152, 0.0722));\n            linearRGB *= lumBefore/lumAfter;\n            \n            // Keep the resulting value within the RGB gamut.\n            linearRGB = linearRGB / pow(pow(linearRGB, vec3(limitHardness)) + vec3(1), vec3(1./limitHardness));\n        }\n        \n        for(int i = 0; i < 3; i++)\n        {\n            vec3 okl2 = rgb_to_oklab(linearRGB);\n\n            // Control level of L preservation.\n            okl2.x = mix(okl2.x, okl.x, 1.);\n             \n            // Enforce hue correction.\n            okl2.yz = okl.yz * (length(okl2.yz) / length(okl.yz));\n            \n            // Control level of ab preservation.\n            okl2.yz = mix(okl2.yz, okl.yz, 1.);\n\n            linearRGB = oklab_to_rgb(okl2);  \n  \n            {\n                // Compensate for negative clipping.\n                float lumBefore = dot(linearRGB, vec3(0.2126, 0.7152, 0.0722));\n                linearRGB = max(vec3(0), linearRGB);\n                float lumAfter = dot(linearRGB, vec3(0.2126, 0.7152, 0.0722));\n                linearRGB *= lumBefore/lumAfter;\n                \n                // Keep the resulting value within the RGB gamut.\n                linearRGB = linearRGB / pow(pow(linearRGB, vec3(limitHardness)) + vec3(1), vec3(1./limitHardness));\n            }\n        }\n    }\n        \n  \n    return Srgb3(linearRGB);\n}","name":"Common","description":"","type":"common"}]}