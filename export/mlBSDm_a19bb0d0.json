{"ver":"0.1","info":{"id":"mlBSDm","date":"1676161210","viewed":70,"name":"Shiny lump of something","username":"ianertson","description":"Not sure what this is supposed to be :D\nLook around with the mouse","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["3d","noise","raymarch","shiny"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":3,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NEAR 0.005\n#define FAR 60.0\n#define STEPS 86\n#define ZERO (min(0, int(iTime)))\n\n#define ID_NONE 0\n#define ID_THING 1\n#define ID_GROUND 2\n\nstruct Material { float roughness; vec3 spec; };\n\nvoid materialInit(inout Material m) {\n    m.roughness = 1.0;\n    m.spec = vec3(0.01);\n}\n\nstruct Data {\n    vec3 p;\n    vec3 n;\n    vec2 uv;\n    float dist;\n    float depth;\n    int id;\n    int skip;\n};\n\nvoid dataInit(inout Data data) {\n    data.p = vec3(0.);\n    data.n = vec3(0.);\n    data.uv = vec2(0.);\n    data.dist = FAR;\n    data.depth = 1.0;\n    data.id = 0;\n    data.skip = 0;\n}\n\n#define LIGHT_AMBIENT 0\n#define LIGHT_POINT 1\nstruct Light {\n    vec3 p;\n    vec3 c;\n    float s;\n    int type;\n};\n\nvec3 getLightDir(in Light light, vec3 p) {\n   return normalize(light.p);\n} \n\nvec3 getLightAtt(in Light light, vec3 p, vec3 n) {\n   return light.c * light.s * max(0.0, dot(n, getLightDir(light, p)));  \n}\n\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat thingSDF(inout Data data, vec3 p) {\n    p.xz *= 1.3;\n    float w = noise3D(iChannel3, p, 0.5)*1.6;\n    float z = noise3D(iChannel3,\n        (p*1.6)+vec3(3.02 + (w*0.1), 9.04 + (w*0.1), -11.34 + (w*0.1)));    \n    float h = noise3D(iChannel3, ((p*5.0)+vec3(w,z, w-z))*0.6) * 2.0 - 1.0;\n    p += z*0.2;\n    w += h*0.1;\n    float g = max(h, max(w, z));\n    float s = sphereSDF(p, 0.9+w);\n    return s / (1.0  + (g+1.3));\n}\n\nfloat groundSDF(inout Data data, vec3 p) {\n    return p.y+2.;\n}\n\n#define SAMPLE(var, id_) if (id_ != data.skip && var < dist) { data.id = id_; dist = var; }\n\nfloat getDist(inout Data data, vec3 p) {\n    float dist = FAR;\n    float thing = thingSDF(data, p);\n    float ground = groundSDF(data, p);\n    SAMPLE(thing, ID_THING);\n    SAMPLE(ground, ID_GROUND);\n    return dist;\n}\n\nvec3 getNormal(inout Data data, vec3 p) {\n    vec2 e = vec2(0.0003, 0.0);\n    return normalize(getDist(data, p) - vec3(\n        getDist(data, p - e.xyy),\n        getDist(data, p - e.yxy),\n        getDist(data, p - e.yyx)\n    ));\n}\n\nbool march(inout Data data, vec3 ro, vec3 rd) {\n    float dist = 0.0;\n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*dist;\n        float next = getDist(data, p);\n        dist += next;\n        if (abs(next) <= NEAR || abs(dist) >= FAR) break;\n    }\n    dist = abs(dist);\n    if (dist >= FAR) return false;\n    vec3 p = ro+rd*dist;\n    data.p = p;\n    data.dist = dist;\n    data.depth = dist / FAR;\n    data.n = getNormal(data, p);\n    return true;\n}\n\nfloat getShadow(int skip, vec3 ro, vec3 rd, float near, float far) {\n    float dist = 0.0;\n    Data data;\n    dataInit(data);\n    data.skip = skip;\n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*dist;\n        float next = getDist(data, p);\n        dist += next;\n        if (abs(next) <= NEAR || abs(dist) >= far) break;\n    }\n    dist = abs(dist);\n    if (dist >= far) return 1.0;\n    return dist/max(0.01, near);\n}\n\nvec3 checker(vec2 uv, float tile) {\n    vec2 id = floor(uv*tile);\n    return mix(\n        vec3(223.0, 230.0, 233.0) / 255.0,\n        vec3(45.0, 52.0, 54.0) / 255.0,\n        float(mod(id.x-id.y, 2.0) > 0.0)\n    );\n}\n\n#define ALBEDO_SIG inout Data data, inout Material m, vec2 uv\n\nvec3 getAlbedoThing(ALBEDO_SIG) {\n    vec3 p = data.p;\n    uv = vec2(p.x, atan(0.5+abs(p.y), abs(p.z)))*2.0-1.0;\n    float region = noise2D(iChannel3, (((uv)+9.281)*1.1)+vec2(9.01, -0.20), 0.6);\n    region = clamp(pow(region, 4.0)*2., 0.0, 1.0);\n    float low = noise2D(iChannel3, (uv*2.)+region);\n    float high = noise2D(iChannel3, (uv)+(region*0.2), 32.0);\n    high = pow(high, 3.0)*3.0;\n    vec3 col = vec3(0.48);\n    vec3 highColor = vec3(212,197,170)/255.0;\n    vec3 peakColor = max(vec3(0.0),vec3(158.*(0.8+(region+high)),66.*(0.7+region-(high*0.5)),(46.*(0.5+region-(high*0.5))))/255.0);\n    col = mix(col, vec3(127,117,104)/255.0, low);\n    col = mix(col, highColor, high);\n    col *= (0.2+region);\n    col += (high*max(0.0, (1.0-(region*9.)))*highColor)/M_PI;\n    float peaks = pow((region+low)/2., 5.0);\n    col += ((peaks*32.)*(0.002+pow(peakColor, vec3(0.7))))/M_PI;\n    m.roughness = max(0.0, low-(high*0.2));\n    m.spec = (vec3(region+low)/2.) * max(0.0, 1.0-high);\n    return col;\n}\n\nvec3 getAlbedoGround(ALBEDO_SIG) {\n    m.roughness = 0.25;\n    vec3 col = checker(uv, 0.4);\n    m.spec = vec3(pow(luma(col), 2.0)*3.0);\n    return col;\n}\n\nvec3 getAlbedo(inout Data data, inout Material m, vec2 uv) {\n    return data.id == ID_THING ? getAlbedoThing(data, m, uv) : getAlbedoGround(data, m, uv);\n}\n\nvec3 render(inout Data data, vec3 ro, vec3 rd) {\n    vec3 col = vec3(0.0);\n    Light light = Light(vec3(1, 2, -3), vec3(0.92, 0.89, 0.69), 2.0, LIGHT_AMBIENT);\n    Material lastMaterial;\n    materialInit(lastMaterial);\n    lastMaterial.roughness = 0.0;\n    float lastShadow = 1.;\n    float lastNdotL = 1.0;\n    float depth = 0.0;\n    bool hitAny = false;\n    vec3 ord = rd;\n    vec3 oro = ro;\n    float dist = FAR;\n    for (int i = ZERO; i < 2; i++) {\n        if (march(data, ro, rd)) {\n            hitAny = true;\n            Material m;\n            materialInit(m);\n            vec3 L = getLightDir(light, data.p);\n            vec3 att = getLightAtt(light, data.p, data.n);\n            vec3 albedo = getAlbedo(data, m, data.p.xz);\n            vec3 diffuse = albedo / M_PI;\n            float shadow = dot(att, att) > 0.001 ? getShadow(data.id, data.p, L, data.dist, FAR) : 0.0;\n            vec3 ref = reflect(L, data.n);\n            float VdotR = max(0.0, dot(rd, ref));\n            vec3 spec = m.spec * pow(VdotR, 32.0);\n            att *= max(0.0, 1.0 - (lastMaterial.roughness*2.))*lastNdotL;\n            col += ((((diffuse + spec) * att) * shadow) / (1.0 + float(i))) * lastShadow;\n            ro = data.p;\n            rd = reflect(rd, data.n);\n            data.skip = data.id;\n            lastMaterial = m;\n            lastShadow = max(0.1, shadow*luma(att));\n            col += (data.depth*data.depth)*att*shadow*lastShadow;\n            lastNdotL = max(0.0, dot(data.n, L));\n            dist = min(data.dist, dist);\n        } else {\n            col += ((texture(iChannel2, rd).rgb / (1.0 + float(i))) * lastShadow) * max(0.0, 1.0 - (lastMaterial.roughness*2.));\n            break;\n        }\n    }\n    if (!hitAny) col += data.depth*max(0.0, 1.0-max(0.0, 3.0*dot(ord, vec3(0, 1, 0))));\n    float dotL = pow(max(0.0, dot(ord, normalize(light.p))), 3.2);\n    col += (((light.c * dotL)) * pow(dist, 0.2)) / M_PI;\n    return col;\n}\n\nvec3 look(vec2 uv, vec3 point, vec3 ro) {\n    vec3 lookAt = point;\n    float zoom = 1.;\n    vec3 camForward = normalize(lookAt - ro);\n    vec3 camRight = -cross(camForward, vec3(0, 1, 0));\n    vec3 camUp = -cross(camRight, camForward);\n    vec3 screenCenter = ro + camForward * zoom;\n    vec3 screenIntersection = screenCenter + uv.x * camRight + uv.y * camUp;\n    return normalize(screenIntersection - ro);\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = (fc-0.5*R.xy)/R.y;\n    vec2 m = (iMouse.xy-0.5*R.xy)/R.y;\n    vec3 ro = vec3(0., 0.25, -8.0);\n    vec3 rd = normalize(vec3(uv.xy, 1.));\n    if (iMouse.z > 0.01) {\n        rd.yz *= rot(m.y*TAU);\n        rd.xz *= rot(m.x*TAU);\n        ro.yz *= rot(m.y*TAU);\n        ro.xz *= rot(m.x*TAU);\n    } else {\n        ro.xz *= rot(T*0.6);\n        rd = look(uv, vec3(0.0, 0.0, 0.0), ro);\n    }\n    ro.y = max(0.2, ro.y);\n    Data data;\n    dataInit(data);\n    col += render(data, ro, rd);\n    col += (col*luma(col)) / 1.6;\n    col /= vec3(1.) + col;\n    col = pow(col, vec3(1.0 / 2.2));\n    O = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R iResolution.xy\n#define T (iTime)\n#define M_PI (3.1416)\n#define TAU (M_PI * 2.0)\n\n\nfloat hash21(sampler2D ch, vec2 p) {\n    return textureLod(ch, p/256., 0.).r;\n}\n\nfloat hash31(sampler2D ch, vec3 p) {\n    return hash21(ch, vec2(p.x*p.z, p.y));\n}\n\nfloat noise2D(sampler2D ch, vec2 p) {\n    vec2 id = floor(p);\n    vec2 lv = smoothstep(0.0, 1.0, fract(p));\n    \n    return mix(mix(hash21(ch, id), hash21(ch, id+vec2(1, 0)), lv.x),\n        mix(hash21(ch, id+vec2(0, 1)), hash21(ch, id+vec2(1, 1)), lv.x), lv.y);\n}\n\n\nfloat noise3D(sampler2D ch, vec3 p) {\n  vec3 id = floor(p);\n  vec3 lv = smoothstep(0.0, 1.0, fract(p));\n  return mix(\n      mix(mix(hash31(ch, id + vec3(0, 0, 0)), hash31(ch, id + vec3(1, 0, 0)), lv.x),\n          mix(hash31(ch, id + vec3(0, 1, 0)), hash31(ch, id + vec3(1, 1, 0)), lv.x),\n          lv.y),\n      mix(mix(hash31(ch, id + vec3(0, 0, 1)), hash31(ch, id + vec3(1, 0, 1)), lv.x),\n          mix(hash31(ch, id + vec3(0, 1, 1)), hash31(ch, id + vec3(1, 1, 1)), lv.x),\n          lv.y),\n      lv.z);\n}\n\nfloat noise2D(sampler2D ch, vec2 p, float freq) {\n    float n = 0.0;\n    float amp = 1.0;\n    float div = 0.0;\n    n += amp*noise2D(ch, p*freq); div += amp; amp /= 2.0; freq *= 2.0;\n    n += amp*noise2D(ch, p*freq); div += amp; amp /= 2.0; freq *= 2.0;\n    n += amp*noise2D(ch, p*freq); div += amp; amp /= 2.0; freq *= 2.0;\n    \n    return n / div;\n}\n\nfloat noise3D(sampler2D ch, vec3 p, float freq) {\n    float n = 0.0;\n    float amp = 1.0;\n    float div = 0.0;\n    n += amp*noise3D(ch, p*freq); div += amp; amp /= 2.0; freq *= 2.0;\n    n += amp*noise3D(ch, p*freq); div += amp; amp /= 2.0; freq *= 2.0;\n    n += amp*noise3D(ch, p*freq); div += amp; amp /= 2.0; freq *= 2.0;\n    return n / div;\n}\n\nmat2 rot(float a) { float c = cos(a); float s = sin(a); return mat2(c, s, -s, c);}\n\nfloat luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}","name":"Common","description":"","type":"common"}]}