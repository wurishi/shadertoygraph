{"ver":"0.1","info":{"id":"clccWX","date":"1699710021","viewed":54,"name":"ray tracing with phong light","username":"tomcat7479","description":"RayTracing Demo With Phong Light Model","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","phong"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n    RayTracing Demo With Phong Light Model\n    Scense: Sphere and Plane\n*/\n\n#define PRECISION 1e-4\n#define SAMPLES 4   // smooth sampling count\n#define SPHERES 4   // number of spheres\n#define RAY_MIN_DISTANCE 1e-4   \n#define RAY_MAX_DISTANCE 1e4   \n#define BACKGROUND_COLOR vec3(0.8, 0.7, 0.5)\n#define LIGHT_DIR normalize(vec3(5.0, 10.0, 5.0))\n#define UNIT_PXY 1.0 / iResolution.xy \n#define FLOAT_ZERO_ABS_ERROR 1e-7\n\n#define GROUND_PLANE_FIX_POINT vec3(0.0, -1.0, 0.0)\n#define GROUND_PLANE_NORMAL vec3(0.0, 1.0, 0.0)\n#define GROUND_PLANE_DIFFUSE vec3(0.6, 0.5, 0.4)\n#define GROUND_PLANE_SPECULAR vec3(0.0)\n\n#define DEFAULT_SPHERE_RADIUS 2.5\n#define DEFAULT_SPHERE_COLOR vec3(0.902, 0.4, 0.7922)\n#define DEFAULT_SPHERE_SPEC vec3(0.65)\n\n#define AMBIENT_STRENGTH 0.33\n#define DIFFUSE_STRENGTH 0.91\n#define SPECULAR_STRENGTH 0.88 \n\n/**\n  Define Struct: material, ray, hit record, geometry (Plane, Sphere)\n*/\nstruct Material {\n    vec3 diffuse;\n    vec3 specular;\n    bool isRefract;\n} material;\n\n// Ray equation: r(t) = ro + t * rd\nstruct Ray {\n    vec3 ro;\n    vec3 rd;\n    float tmin;\n    float tmax;\n} ray;\n\nstruct HitRecord {  // record information about the intersections between ray and scenes\n    bool hitDid;    // intersect or not  \n    bool inside;    // whether the interesctions is inside the obj\n    float t;        // position of ray\n    vec3 p;         // point which ray intersects obj\n    vec3 n;         // normal of point which ray intersects obj\n    Material m;     // material of intersections\n} hitRecord;\n\n// Plane equation: <q - p, n> = 0, q in R^3\nstruct Plane {\n    vec3 p;     \n    vec3 n;\n    Material m;\n} plane;\n\n// Sphere equation: <p - center, p - center> - radius^2 = 0\nstruct Sphere {\n    vec3 center;\n    float radius;\n    Material m;\n} sphere;\n\n\n/**\n    Define struct construction\n*/\nMaterial newMaterial(vec3 dif, vec3 spec, bool isRefract) {\n    Material m;\n    m.diffuse = dif;\n    m.specular = spec;\n    m.isRefract = isRefract;\n    return m;\n}\n\nRay newRay(vec3 ro, vec3 rd, float tmin, float tmax) {\n    Ray r;\n    r.ro = ro;\n    r.rd = rd;\n    r.tmin = tmin;\n    r.tmax = tmax;  \n    return r;\n}\n\nPlane newPlane(vec3 p, vec3 n, Material m) {\n    Plane pl;\n    pl.p = p;\n    pl.n = n;\n    pl.m = m;\n    return pl;\n}\n\nSphere newSphere(vec3 center, float radius, Material m) {\n    Sphere s;\n    s.center = center;\n    s.radius = radius;\n    s.m = m;\n    return s;\n}\n\n\n\nvec2 fix(in vec2 coord) {\n    return (2.0 * coord.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n}\n\nmat3 setCamera(vec3 lookAt, vec3 ro) {\n    vec3 z = normalize(lookAt - ro);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 x = normalize(cross(z, up));\n    vec3 y = normalize(cross(x, z));\n    return mat3(x, y, z);\n}\n\nfloat random(int x, float y) {\n    return y * fract(sin(float(x)));\n}\n\n\n/********************************************Ray Tracing Part******************************************/\n\n/**\n    determine whether the ray intersects the plane\n    cameraRay: ro + t * rd\n    Plane: <q - p, n> = 0\n    <ro + t * rd - p, n> = 0 ---> t = <p - ro, n> / <rd, n>\n    the plane here represents the ground, so the camera ray must be above the ground\n*/\nbool intersectPlane(in Ray cameraRay, in Plane plane, inout HitRecord hitRecord) {\n    float rdN = dot(cameraRay.rd, plane.n);\n    if (abs(rdN) < FLOAT_ZERO_ABS_ERROR) return false;\n    float t = dot(plane.p - cameraRay.ro, plane.n) / rdN;\n    if (dot(plane.n, cameraRay.rd) > 0.0) { \n        return false;\n    }\n    if (t > cameraRay.tmin && t < cameraRay.tmax) {\n        hitRecord.hitDid = true;\n        hitRecord.t = t;\n        hitRecord.p = cameraRay.ro + t * cameraRay.rd;\n        hitRecord.n = normalize(plane.n);\n        hitRecord.m = plane.m;\n        return true;\n    }\n    return false;\n}\n\n/**\n    determine whether the ray intersects the sphere\n    cameraRay: ro + t * rd\n    Sphere: <p - center, p - center> - r^2 = 0\n    <ro + t * rd - center, ro + t * rd - center> - r^2 = 0 ----> at^2 + bt + c = 0\n    a = <rd, rd>\n    b = 2.0 * <ro - center, rd>\n    c = <ro - center, ro - center> - r^2\n*/\nbool intersectSphere(in Ray cameraRay, in Sphere sphere, inout HitRecord hitRecord) {\n    float a = dot(cameraRay.rd, cameraRay.rd);\n    float b = 2.0 * dot(cameraRay.ro - sphere.center, cameraRay.rd);\n    float c = dot(cameraRay.ro - sphere.center, cameraRay.ro - sphere.center) - sphere.radius * sphere.radius;\n    float delta = b * b - 4.0 * a * c;\n    if (delta < 0.0) {\n        return false;\n    }\n    float t1 = (-b - delta) / 2.0 * a;\n    float t2 = (-b + delta) / 2.0 * a;\n    if (t1 > cameraRay.tmin && t1 < cameraRay.tmax) {\n        hitRecord.hitDid = true;\n        hitRecord.inside = false;\n        hitRecord.t = t1;\n        hitRecord.p = cameraRay.ro + t1 * cameraRay.rd;\n        hitRecord.n = normalize(hitRecord.p - sphere.center);\n        hitRecord.m = sphere.m;\n        if (dot(hitRecord.n, cameraRay.rd) > 0.0) {\n            hitRecord.inside = true;\n            hitRecord.n = -hitRecord.n;\n        }\n        return true;\n    }\n\n    if (t2 > cameraRay.tmin && t2 < cameraRay.tmax) {\n        hitRecord.hitDid = true;\n        hitRecord.inside = false;\n        hitRecord.t = t1;\n        hitRecord.p = cameraRay.ro + t2 * cameraRay.rd;\n        hitRecord.n = normalize(hitRecord.p - sphere.center);\n        hitRecord.m = sphere.m;\n        if (dot(hitRecord.n, cameraRay.rd) > 0.0) {\n            hitRecord.inside = true;\n            hitRecord.n = -hitRecord.n;\n        }\n        return true;\n    }\n    return false;\n}\n\nbool intersectScense(in Ray cameraRay, inout HitRecord hitRecord) {\n    bool didHit = false;\n\n    Material planeMaterial = newMaterial(GROUND_PLANE_DIFFUSE, GROUND_PLANE_SPECULAR, false);\n    Plane plane = newPlane(GROUND_PLANE_FIX_POINT, GROUND_PLANE_NORMAL, planeMaterial);\n\n    if (intersectPlane(cameraRay, plane, hitRecord)) {\n        didHit = true;\n        cameraRay.tmax = hitRecord.t;\n    }\n\n    for (int i = 0; i < SPHERES; i++) {\n        Sphere sphere;\n        float sRadius = DEFAULT_SPHERE_RADIUS + random(i + 2, 0.2);\n        float sR = DEFAULT_SPHERE_COLOR.x + random(i + 4, 0.2);\n        float sG = DEFAULT_SPHERE_COLOR.y + random(i + 7, 0.3);\n        float sB = DEFAULT_SPHERE_COLOR.z + random(i + 9, 0.4);\n        vec3 sCenter = vec3(-sin(float(i * 2)) * 10.0 + 3.0, sRadius - 1.0,  -25.0 - cos(float(i + 2) * 3.0) * 10.0);\n        sphere.center = sCenter;\n        sphere.radius = sRadius;\n        Material sphereMaterial = newMaterial(vec3(sR, sG, sB), DEFAULT_SPHERE_SPEC, i == 3 ? true : false);\n        sphere.m = sphereMaterial;\n\n        sphere.center.x += sRadius * sin(sRadius * iTime * 0.4);\n        sphere.center.z += 2.0 * sRadius * cos(sRadius * iTime * 0.4);\n\n        if (intersectSphere(cameraRay, sphere, hitRecord)) {\n            didHit = true;\n            cameraRay.tmax = hitRecord.t;\n        }\n    }\n\n    return didHit;\n}\n\n/**\n    Calculate Phong illumination model: ambient, diffuse and specular\n*/\nvec3 calLightColor(in Ray cameraRay, inout HitRecord hitRecord) {\n    vec3 color = vec3(0.0);\n    if (intersectScense(cameraRay, hitRecord)) {\n        float difCof = clamp(dot(LIGHT_DIR, hitRecord.n), 0.0, 1.0);\n        vec3 refL = normalize(reflect(LIGHT_DIR, hitRecord.n));\n        float specCof = pow(clamp(dot(refL, hitRecord.n), 0.0, 1.0), 16.0);\n\n        vec3 ambientColor = hitRecord.m.diffuse * AMBIENT_STRENGTH;\n        vec3 diffuseColor = hitRecord.m.diffuse * difCof * DIFFUSE_STRENGTH;\n        vec3 specularColor = hitRecord.m.specular * specCof * SPECULAR_STRENGTH;\n\n        color = ambientColor + diffuseColor + specularColor;\n        color = sqrt(color);\n\n        // Calculate Shadow Ray and Shadow Ray Test: determine whether the light emitted by light source can hit the object\n        Ray shadowRay = newRay(hitRecord.p + PRECISION * LIGHT_DIR, LIGHT_DIR, RAY_MIN_DISTANCE, RAY_MAX_DISTANCE);\n        if (intersectScense(shadowRay, hitRecord)) {\n            return 2.0 * color; // it's brighter where the light hits, so multiply it by 2.0\n        } \n        return color;\n    }\n    return color;\n}\n\n/**\n    Core Function, we need go througth all objects in the scens and calculate the final color\n\n    In our scene, there are four spheres\n*/\nvec3 rayTracing(in Ray cameraRay) {\n    vec3 color = BACKGROUND_COLOR;  \n    for (int i = 0; i < SPHERES; i++) {\n        HitRecord hitRecord;\n        vec3 curColor = calLightColor(cameraRay, hitRecord);\n        if (!hitRecord.hitDid) {\n            return color; // not intersects\n        } else if (!hitRecord.m.isRefract) {\n            // obj don't refract light, only relfect light\n            cameraRay.rd = normalize(reflect(cameraRay.rd, hitRecord.n));\n            cameraRay.ro = hitRecord.p + PRECISION * cameraRay.rd;\n            color *= curColor;\n        } else {\n            curColor = vec3(0.8);\n            float refractive = 1.3;\n            if (!hitRecord.inside) {\n               refractive = 1.0 / refractive;\n            }\n            cameraRay.rd = normalize(refract(cameraRay.rd, hitRecord.n, refractive));\n            cameraRay.ro = hitRecord.p + PRECISION * cameraRay.rd;\n            color *= curColor;\n        }\n    }\n    return color;\n}\n\n/**\n  Sampling Smooth\n*/\nvec3 sampleRender(in vec3 ro, in vec3 rd) {\n    vec2 h = vec2(0.5, -0.5);\n    vec2 offset1 = UNIT_PXY * h.yy;\n    vec2 offset2 = UNIT_PXY * h.yx;\n    vec2 offset3 = UNIT_PXY * h.xy;\n    vec2 offset4 = UNIT_PXY * h.xx;\n\n    Ray ray1 = newRay(ro - vec3(offset1, 0.0), rd, RAY_MIN_DISTANCE, RAY_MAX_DISTANCE);\n    Ray ray2 = newRay(ro - vec3(offset2, 0.0), rd, RAY_MIN_DISTANCE, RAY_MAX_DISTANCE);\n    Ray ray3 = newRay(ro - vec3(offset3, 0.0), rd, RAY_MIN_DISTANCE, RAY_MAX_DISTANCE);\n    Ray ray4 = newRay(ro - vec3(offset4, 0.0), rd, RAY_MIN_DISTANCE, RAY_MAX_DISTANCE);\n\n    vec3 color = vec3(0.0);\n    color += rayTracing(ray1);\n    color += rayTracing(ray2);\n    color += rayTracing(ray3);\n    color += rayTracing(ray4);\n\n    return color / float(SAMPLES);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fix(fragCoord);\n\n    vec3 ro = vec3(0., 0., 1.);\n    vec3 lookAt = vec3(0., 0., 0.);\n    mat3 camera = setCamera(lookAt, ro);\n    vec3 rd = normalize(camera * vec3(uv, 1.0));\n\n    vec3 color = sampleRender(ro, rd);\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}