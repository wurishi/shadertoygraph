{"ver":"0.1","info":{"id":"fs3SDj","date":"1633931043","viewed":93,"name":"Rocks1","username":"rudros","description":"Very small but (hopefully) readable ray-caster","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raycasting","mini"],"hasliked":0,"parentid":"7ddSDB","parentname":"Arrows1"},"renderpass":[{"inputs":[],"outputs":[],"code":"#define PI 3.1415326\n\nmat2 rotate2D(float r) {\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\nfloat distanceTo(vec3 p, float waveNum) {\n    float frequency = exp(waveNum);\n    //p.xz *= rotate2D(PI/3.);\n    return abs(cos(p.x*frequency*PI)+sin(p.z*frequency*PI))/frequency;\n}\n\nfloat totalDistance(vec3 p) {\n    // Initial distace\n    float total = p.y;\n    // This loop determines the number of waves being combined\n    for(float j=0.; j < mod(iTime, 15.); j++) {\n        // Add noise to initial surface\n        total += distanceTo(p, j);\n    }\n    return total;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float i;\n    float eyeDist, minDist;\n\n    vec3 eyePos = vec3(0, 0, -1);\n    vec3 ray = vec3((fragCoord.xy-.5*iResolution.xy)/iResolution.x, 1.);\n    ray = normalize(ray);\n\n    // Camera motion\n    eyePos.yz *= rotate2D(5.);\n    eyePos.xz *= rotate2D(iTime);\n    ray.yz *= rotate2D(5.);\n    ray.xz *= rotate2D(iTime);\n\n    for(minDist = 1.; i<100. && minDist>0.001; i++) {\n        // Point to check\n        vec3 p = eyePos+eyeDist*ray;\n                 \n        minDist = totalDistance(p);\n        // Move point forward\n        eyeDist += minDist*.25;\n    }\n    i += 2.*(minDist*1000.+eyePos.z);\n    fragColor = vec4(0.);\n    fragColor += 600./(i*i);\n}","name":"Image","description":"","type":"image"}]}