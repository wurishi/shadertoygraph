{"ver":"0.1","info":{"id":"WsyXW1","date":"1573995276","viewed":133,"name":"Celtic Pattern - Fixed","username":"Podis","description":"Fixed the math in 'Repeating Celtic Pattern' found here: https://www.shadertoy.com/view/3syXDz","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["hexagon","pattern","tile","repeat","celtic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fixed the math in 'Repeating Celtic Pattern' found here: https://www.shadertoy.com/view/3syXDz\n\nfloat scale = 5.;\n\nfloat circ(vec2 uv, float r){\n    float d = length(uv);\n    float c = smoothstep(d, (d+2.*scale/iResolution.y), r);\n    return c;\n}\n\nfloat celt(vec2 uv, float r){\n    \n    // Hexagon Math\n    float hexA = 1./sqrt(3.);\t// Sides:       .57735\n    float hexLD = 2.*hexA;\t\t// Long Diag:  1.154701\n    float hexSD = 1.;\t\t\t// Short Diag: 1\n        \n    float c2 = circ(uv, r-.05);\t// Line Thickness\n    \n    vec2 uv1 = vec2(hexA, -(hexA * hexLD)/2.);\t// Translate: (.57735, -.3334)\n    float c3 = circ(uv + uv1, r);\n    \n    vec2 uv2 = vec2(-hexA, -(hexA * hexLD)/2.);\t// Translate: (-.57735, -.3334)\n    float c4 = circ(uv + uv2, r);\n    \n    vec2 uv3 = vec2(0, (hexLD * hexLD)/2.);\t\t// Translate: (0, .6667)\n    float c5 = circ(uv + uv3, r);\n\n    return c2 - (c3 + c4 + c5);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Hexagon Math\n    float hexA = 1./sqrt(3.);\t// .57735\n    float hexLD = 2.*hexA;\t\t// 1.154701\n    float hexSD = 1.;\t\t\t// 1\n    \n    // Main UV \n    vec2 uv = fragCoord / iResolution.y;\t// uv.x(0 to 1.78), uv.y(0 to 1)\n\tuv.y *= hexLD;\t\t\t\t\t\t\t// uv.x(0 to 1.78), uv.y(0 to 1.16)\n    uv *= scale;\t\t\t\t\t\t\t// uv.x(0 to 8.89), uv.y(0 to 5.78)\n    \n    // Insert Translations here\n    \n    // Offset every other Row\n    float n = mod(uv.y,2.);\t\t// divides uv\n    uv.x += step(1., n)*.5;\t\t// offsets every other row by .5\n    \n    // uv = fract(uv) - Split for testing purposes.\n    vec2 fuv = floor(uv);\t\t// uv.x(0 to 8), uv.y(0 to 5)\n    uv.x -= fuv.x;\t\t\t\t\n    uv.y -= fuv.y;\t\t\t\t\n    \n    // ind. uv's (0 - 1)\n    uv.x *= hexLD;\t\t\t\t// scale uv.x (0 - 1.155)\n    uv.x -= hexLD/2.;\t\t\t// translate uv.x to center.x\n    uv.y -= .5;\t\t\t\t\t// translate uv.y to center.y\n    \n    \n    \n    // Offset UV - 1\n    vec2 uv1 = fragCoord / iResolution.y;\n\tuv1.y *= hexLD;\t\t\t\t\t\n    uv1 *= scale;\t\t\t\t\t\n\tuv1.x -= .5;\t\t\t\t\t// Translates uv.x by .5\n    uv1.y -= (hexA*hexLD)/2.;\t\t// Translates uv.y by .3334\n    float m = mod(uv1.y,2.);\t\t\n    uv1.x += step(1., m)*.5;\t\t\n    uv1 = fract(uv1);\t\t\t\t\n    uv1.x *= hexLD;\t\t\t\t\t\n    uv1.x -= hexLD/2.;\t\t\t\t\n    uv1.y -= .5;\t\t\t\t\t\n    \n    // Offset UV - 2\n    vec2 uv2 = fragCoord / iResolution.y;\n\tuv2.y *= hexLD;\t\t\t\t\t\n    uv2 *= scale;\t\t\t\t\t\n\tuv2.x -= 1.;\t\t\t\t\t// Translates uv.x by 1\n    uv2.y -= (hexA*hexLD);\t\t\t// Translates uv.y by .3334\n    float o = mod(uv2.y,2.);\t\t\n    uv2.x += step(1., o)*.5;\t\t\n    uv2 = fract(uv2);\t\t\t\t\n    uv2.x *= hexLD;\t\t\t\t\t\n    uv2.x -= hexLD/2.;\t\t\t\t\n    uv2.y -= .5;\t\t\t\t\t\n    \n\t// Apply Celt to all UV Layers\n    float c1 = celt(uv, .45); \n    float c2 = celt(uv1, .45);\n    float c3 = celt(uv2, .45);\n\n    // Output to screen\n    fragColor = vec4(c1,c2, c3,1.0);\n}","name":"Image","description":"","type":"image"}]}