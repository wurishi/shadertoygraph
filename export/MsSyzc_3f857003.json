{"ver":"0.1","info":{"id":"MsSyzc","date":"1493122959","viewed":177,"name":"~Peony","username":"Seledorn","description":"Messing around with flowers using golden angle. Maybe early stage Peony?","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["flower"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n\n// iq's distance function\nfloat sdSphere( vec3 pos, float r ) {\n\treturn length( pos ) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nmat3 look_along(vec3 p, vec3 up)\n{\n    p = normalize(p);\n    vec3 l = normalize(cross(up,p));\n\tup = cross(p,l);\n    \n\treturn mat3(\n        l.x,l.y,l.z,\n        p.x, p.y, p.z,\n        up.x,up.y, up.z\n\t);\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  \tvec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  \treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdLeaf( vec3 pos) {\n    vec3 s =  vec3(0.4,0.7,0.5);\n    vec3 o =  vec3(0.0,-0.1,-0.6);\n    vec3 p1 = pos;\n    vec3 p2 = (pos*s+o);\n    \n\treturn max(sdSphere(p1,1.0),-sdSphere(p2,1.0));\n}\n\nfloat sdLeaf2( vec3 pos, mat3 mat) {\n    pos = pos*mat;\n   \treturn sdBox(pos,vec3(0.3,0.7,0.1));\n}\n\n\n\n\n\n// camera rotation : pitch, yaw\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\n\n\n\n\nfloat map(vec3 pos)\n{\n    mat3 rot = rotationXY(vec2(0,2.3998277));\n    mat3 orgrot = rot;\n\t\n    vec3 d = vec3(0.0);\n    mat3 no = rot;\n    float r = 200.0;\n\n    float l = 0.1;\n    for(int i = 0; i< 60;i++)\n    {\n        vec3 p=(pos + d)*rot; \n    \tmat3 r2 =  rotationXY(vec2(l,0));   \n        vec3 off = vec3(0,0.5,0);\n\t\t\t\n        r = min(r,sdLeaf((p+off)*r2-off)); \n        rot = rot *orgrot;\n        d = d + vec3(0.0,-0.01,0.0);\n\t\tl-= 0.05;\n        \n    }\n    \n \treturn r;   \n }\n\n\n#if 1\n\n\n\n\nconst int max_iterations =512;\nconst float stop_threshold = 0.0001;\nconst float grad_step = 0.001;\nconst float clip_far = 500.0;\n\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\n\n\n\n// get distance in the world\nfloat dist_field( vec3 pos ) {\n    return map(pos);\n}\n\n// get gradient in the world\nvec3 gradient( vec3 pos ) {\n\tconst vec3 dx = vec3( grad_step, 0.0, 0.0 );\n\tconst vec3 dy = vec3( 0.0, grad_step, 0.0 );\n\tconst vec3 dz = vec3( 0.0, 0.0, grad_step );\n\treturn normalize (\n\t\tvec3(\n\t\t\tdist_field( pos + dx ) - dist_field( pos - dx ),\n\t\t\tdist_field( pos + dy ) - dist_field( pos - dy ),\n\t\t\tdist_field( pos + dz ) - dist_field( pos - dz )\t\t\t\n\t\t)\n\t);\n}\n\nvec3 shading( vec3 v, vec3 n, vec3 eye ) {\n\t{\n\t\tvec3 light_pos   = vec3( 00.0, 20.0, 20.0 );\n\t\tvec3 light_color = vec3(0.7, 0.05, 0.03 );\n\t\n\t\tvec3 vl = normalize( light_pos - v );\n\t\tfloat diffuse  = max( 0.35, dot( vl, n ) );\n\t\treturn light_color * diffuse; \n\t}\n}\n\nfloat ray_marching( vec3 origin, vec3 dir, float start, float end ) {\n\tfloat t = start;\n    for ( int i = 0; i < max_iterations; i++ ) {\n\t\tfloat dist = dist_field(origin+dir*t);\n        t += dist;\n        if(dist<=stop_threshold) return t;\n\t\tif ( t > end ) {\n\t\t\treturn end;\n\t\t}\n\t}\n\treturn end;\n}\n\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 dir = ray_dir( 45.0, iResolution.xy , fragCoord.xy );\n\t\n\tvec3 eye = vec3( 0.0, 0.0,8.0 );\n\n\tmat3 rot = rotationXY( vec2(-0.4,0.0)+( iMouse.xy - iResolution.xy * 0.5 ).yx * vec2( 0.01, -0.01 ) );\n\tdir = rot * dir;\n\teye = rot * eye;\n\t\n\tfloat t = ray_marching( eye, dir, 0.0, clip_far );\n    vec3 p = eye + dir*t;\n\tif ( t >= clip_far ) {\n\t\tfragColor = vec4( 0.1, 0.4, 0.5, 1.0 )*(1.0-length((fragCoord-iResolution.xy/2.0)/iResolution.xy));\n        return;\n\t}\n    fragColor = vec4(p, p.x);\n\t\n\tvec3 pos = p;\n\tvec3 n = gradient( pos );\n\tfragColor = vec4( shading( pos, n, eye ), 1.0 );\n}\n\n#endif","name":"Image","description":"","type":"image"}]}