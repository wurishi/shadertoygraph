{"ver":"0.1","info":{"id":"XttGzj","date":"1470294088","viewed":887,"name":"Museum of random planets","username":"LukeRissacher","description":"Partly inspired by \"reactive sphere\" by glk7: https://www.shadertoy.com/view/XlfXzM","likes":42,"published":1,"flags":0,"usePreview":0,"tags":["procedural","raymarching","random","planets"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float MAX_DEPTH = 3.0;\nconst float START_PLANET = 18.0;\n\nvec2 Rotate(vec2 pos, float angle) {\n\treturn vec2(\n        pos.x * cos(angle) - pos.y * sin(angle),\n        pos.x * sin(angle) + pos.y * cos(angle)\n    );\n}\n\nfloat Cubic(float a, float b, float t) {\n    float blendFactor = t * t * (3.0 - 2.0 * t);\n    return mix(a, b, blendFactor);\n}\n\nvec3 HueToRgb(float h) {\n    vec3 rgb = 2.0 - abs(6.0 * h - vec3(3, 2, 4));\n    rgb.r = 1.0 - rgb.r;\n    return clamp(rgb, 0.0, 1.0);\n}\n\nvec3 HsvToRgb(vec3 hsv) {\n    vec3 rgb = HueToRgb(hsv.x);\n    return ((rgb - 1.0) * hsv.y + 1.0) * hsv.z;\n}\n\n// Gradient noise functions courtesy Inigo Q\nvec3 hash( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\nfloat Rand(vec2 pos) {\n    return fract(sin(dot(pos.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat Rand(float pos) {\n    return Rand(vec2(pos));\n}\n\nfloat SphereDistance(vec3 localPos, float radius) {\n\treturn length(localPos) - radius;\n}\n\nfloat SceneDistance(vec3 pos, out float layer) {\n    if (pos.x < 0.0) {\n        return 1.0;\n    }\n    \n    float planetNumber = floor((pos.x) / 2.0) + START_PLANET;\n    \n    vec3 planetPos = pos;\n    planetPos.x = mod(planetPos.x, 2.0) - 1.0;\n    float rotationSpeed = mix(-1.0, 1.0, fract(planetNumber / 2.3));\n    planetPos.xz = Rotate(planetPos.xz, rotationSpeed * iTime);\n    \n    float terrainDetail = mix(0.1, 5.5, Rand(planetNumber + 0.16));\n    float layerHeight = mix(0.005, 0.05, Rand(planetNumber + 0.55));\n    float layerCount = floor(mix(3.5, 20.5, Rand(planetNumber + 0.36)));\n    float noiseValue = 0.5 * noise((normalize(planetPos) + planetNumber) * terrainDetail) + 0.5;\n    layer = floor(noiseValue * layerCount);\n\t\n\tfloat baseSize = mix(0.2, 0.4, Rand(planetNumber + 0.28));\n    float d1 = SphereDistance(planetPos, baseSize + (layer - 1.0) * layerHeight);\n    float d2 = SphereDistance(planetPos, baseSize + layer * layerHeight);\n    \n    float layerTransition = smoothstep(0.0, 0.3, fract(noiseValue * layerCount) + 0.06);\n    return mix(d1, d2, layerTransition);\n}\n\nfloat SceneDistance(vec3 pos) {\n    float dummy;\n    return SceneDistance(pos, dummy);\n}\n\nfloat RayMarch(vec3 startPos, vec3 dir) {\n\tfloat depth = 0.0;\n    for (int i = 0; i < 64; i++) {\n        vec3 pos = startPos + dir * depth;\n        float dist = SceneDistance(pos);\n        if (dist < 0.0001) {\n        \treturn depth;\n        }\n        depth += 0.6 * dist;\n        if (depth >= MAX_DEPTH) {\n            return MAX_DEPTH;\n        }\n    }\n    return MAX_DEPTH;\n}\n\nvec3 SceneNormal(vec3 pos) {\n\tconst float DX = 0.004;\n\tconst vec3 dx = vec3(DX, 0.0, 0.0);\n    const vec3 dy = vec3(0.0, DX, 0.0);\n    const vec3 dz = vec3(0.0, 0.0, DX);\n    return normalize(vec3(\n        SceneDistance(pos + dx) - SceneDistance(pos - dx),\n        SceneDistance(pos + dy) - SceneDistance(pos - dy),\n        SceneDistance(pos + dz) - SceneDistance(pos - dz)\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tconst float FOV = radians(45.0);\n    vec3 eyePos = vec3(0.5 * iTime - 1.0, 0.0, -2.0);\n    vec2 xy = (2.0 * fragCoord - iResolution.xy) * 0.5;\n    vec3 rayDir = normalize(vec3(xy, 1.0 / tan(0.5 * FOV) * 0.5 * iResolution.y));\n    vec3 lightDir = normalize(vec3(0.5, 0.8, -1.0));\n   \n    float depth = RayMarch(eyePos, rayDir);\n    if (depth < MAX_DEPTH) {\n        \n        vec3 pos = eyePos + rayDir * depth;\n        float layer;\n        vec3 normal = SceneNormal(pos);\n        SceneDistance(pos, layer);\n        \n        float planetNumber = floor((pos.x) / 2.0) + START_PLANET;\n        \n        float baseHue = Rand(planetNumber + 1.72);\n        float hueStep = mix(0.02, 0.15, pow(Rand(planetNumber + 0.492), 2.0));\n        \n        float baseSat = pow(Rand(planetNumber + 0.195), 0.2);\n        float satStep = mix(-0.2, 0.2, Rand(planetNumber + 0.777));\n        \n        float baseVal = mix(0.5, 1.0, pow(Rand(planetNumber + 0.888), 0.3));\n        float valStep = mix(0.0, 0.2, Rand(planetNumber + 0.992));\n        \n        vec3 color = HsvToRgb(\n            vec3(fract(baseHue + layer * hueStep), \n\t             clamp(baseSat + layer * satStep, 0.0, 1.0), \n                 0.3 + 0.7 * fract(baseVal + layer * valStep)));\n        float diffuse = 2.0 * clamp(dot(lightDir, normal), 0.0, 1.0);\n    \tfragColor = vec4(diffuse * color, 1.0);\n    }\n    else {\n        float gradient = abs(2.0 * (fragCoord.y / iResolution.y) - 1.0);\n        vec3 skyColor = HsvToRgb(vec3(fract(0.015 * iTime) + 0.5, 1.0, 0.1 * gradient));\n        fragColor = vec4(skyColor, 1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}