{"ver":"0.1","info":{"id":"XltGzj","date":"1470309376","viewed":193,"name":"FlyingR Shielding","username":"Maff","description":"So far a mash-up of \nVery first plasma: https://www.shadertoy.com/view/4lsGDl\nVoronoi - distances: https://www.shadertoy.com/view/ldl3W8#\nSpherize and Antispherize: https://www.shadertoy.com/view/Md2SRd\n","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["poo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159265;\n\n\n#define ANIMATE\n\nvec2 hash2( vec2 p )\n{\n\t// texture based white noise\n//\treturn texture( iChannel0, (p+0.5)/256.0, -100.0 ).xy;\n\t\n    // procedural white noise\t\n\treturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat normpdf(in float x, in float sigma)\n{\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\nvec3 blur (in vec2 pos) \n{\n   \t//declare stuff\n\tconst int mSize = 11;\n\tconst int kSize = (mSize-1)/2;\n\tfloat kernel[mSize];\n\tvec3 final_colour = vec3(0.0);\n\t\t\n\t//create the 1-D kernel\n\tfloat sigma = 7.0;\n\tfloat Z = 0.0;\n\tfor (int j = 0; j <= kSize; ++j)\n\t{\n\t\tkernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);\n\t}\n\t\t\n\t//get the normalization factor (as the gaussian has been clamped)\n\tfor (int j = 0; j < mSize; ++j)\n\t{\n\t\tZ += kernel[j];\n\t}\n\t\t\n\t//read out the texels\n\tfor (int i=-kSize; i <= kSize; ++i)\n\t{\n\t\tfor (int j=-kSize; j <= kSize; ++j)\n\t\t{\n\t\t\tfinal_colour += kernel[kSize+j]*kernel[kSize+i]*texture(iChannel0, (pos.xy+vec2(float(i),float(j))) / iResolution.xy).rgb;\n\t\t}\n\t}\n\t\t\n\treturn vec3(final_colour/(Z*Z));\n}\n\n\nvec3 voronoi( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mg, mr;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\t#ifdef ANIMATE\n        o = 0.5 + 0.5*sin( iTime + 6.2831*o );\n        #endif\t\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\t#ifdef ANIMATE\n        o = 0.5 + 0.5*sin( iTime + 6.2831*o );\n        #endif\t\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>0.00001 )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\n\n    return vec3( md, mr );\n}\n\n\nfloat sphere(float t, float k)\n{\n    float d = 1.0+t*t-t*t*k*k;\n    if (d <= 0.0)\n        return -1.0;\n    float x = (k - sqrt(d))/(1.0 + t*t);\n    return asin(x*t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \tvec2 uv = fragCoord.xy - 0.5*iResolution.xy;\n    float v = iResolution.x;\n    if (v > iResolution.y)\n        v = iResolution.y;\n\tuv /= v;\n    uv *= 3.0;\n    float len = length(uv);\n    float k = 1.0;\n    float len2;\n\n    len2 = sphere(len*k,sqrt(2.0))/sphere(1.0*k,sqrt(2.0));\n\tuv = uv * len2 * 0.5 / len;\n\tuv = uv + 0.5;\n\tif (len2 < 0.0 || uv.x < 0. || uv.y < 0. || uv.x > 1. || uv.y > 1.)\n\t{\n\t\tfragColor = vec4(0,0,0,1.0);\n\t\treturn;\n\t}\n    \n    vec2 pos = uv;\n    float t = iTime/1.0;\n    float scale1 = 40.0;\n    float scale2 = 20.0;\n    float val = 0.0;\n    \n    val += sin((pos.x*scale1 + t));\n    val += sin((pos.y*scale1 + t)/2.0);\n    val += sin((pos.x*scale2 + pos.y*scale2 + sin(t))/2.0);\n    val += sin((pos.x*scale2 - pos.y*scale2 + t)/2.0);\n    val /= 2.0;\n\n\n    vec3 c = voronoi(64.0*pos );\n\n\t// isolines\n    val += 2.0*sin(t)*c.x*(0.5 + 0.5*sin(64.0*c.x));\n    \n    float r,g,b;\n    if ((len2 > 0.8) && (len2 < 1.1)) \n    {\n        float d = len2-0.8;\n\t    r = clamp(cos(PI*val)*d*12.0, 0.0, 1.0);\n    \tg = clamp(cos(PI*val)*d*12.0, 0.0, 1.0);\n    \tb = 1.0;\n    }\n    else\n    {\n\t    r = 0.7-clamp(cos(PI*val), 0.0, 1.0);\n    \tg = 0.7-clamp(cos(PI*val), 0.0, 1.0);\n    \tb = clamp(0.7, 0.0, 1.0);\n    }\n    \n    vec3 col = vec3(r,g,b);\n    \n    fragColor = vec4(col*.3 + .7, 1.0);\n}","name":"Image","description":"","type":"image"}]}