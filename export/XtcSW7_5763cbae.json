{"ver":"0.1","info":{"id":"XtcSW7","date":"1479827684","viewed":249,"name":"Mirror ball 3D","username":"tabacnik","description":"Learning shaders, this one is a reflection test using pong illumination method","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["3draytracepong"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define GT iTime \n\n\n// Material tem cor ambiente, difusa e specular. Tem um fator especular. Se reflete.\nstruct Material {\n    vec3 dif, amb, spc;\n    float spf;\n    bool rfl;\n};\n\n// Esfera tem um centro, um raio e um material primario e secundario\nstruct Sphere {\n\tvec3 cen;\n    float rai;\n    Material mat, sec;\n    int padrao;\n};\n\n// Plano tem uma origem e uma normal\nstruct Plane {\n    vec3 ori, nor;\n    Material mat, sec;\n};\n\n// Luz possue uma posição e uma cor\nstruct Ligth {\n    vec3 pos, cor;\n};\n\n// Hit information possue ponto, normal do ponto, material do ponto,\n// flag se acertou algo, flag de sombra e distancia;\nstruct HitInf {\n    vec3 pos, nor;\n    Material mat;\n    bool hit, ins;\n    float dis;\n};\n\n// Ray possue origem \nstruct Ray {\n    vec3 ori, dir;\n};\n\nconst Material air = Material(vec3(0.),vec3(0.),vec3(0.),1.,false);\nconst HitInf nulo = HitInf(vec3(0.),vec3(0.),air,false,false,0.);\n    \n// Objetos em cena\n//============================================================================================\nSphere bola[3];\n\nMaterial metal = Material(vec3(0.9,0.9,0.9),vec3(0.9,0.9,0.9),vec3(0.99),120.,true);\nMaterial blu = Material(vec3(0.1,0.2,0.6),vec3(0.1,0.1,0.3),vec3(0.99),80.,false);\nMaterial gre = Material(vec3(0.1,0.6,0.2),vec3(0.1,0.4,0.1),vec3(0.99),80.,false);\nMaterial red = Material(vec3(0.7,0.1,0.1),vec3(0.2,0.1,0.1),vec3(0.99),80.,false);\n\nconst Plane plano = Plane(vec3(0.,-2.,0.),vec3(0.,1.,0.),\n       Material(vec3(0.1,0.3,0.3),vec3(0.1,0.2,0.2),vec3(0.0),1.,false),\n       Material(vec3(0.5,0.4,0.1),vec3(0.3,0.2,0.1),vec3(0.0),1.,false) );\n    \n// Encontra Esfera\nHitInf findSphere(Sphere s, Ray ray) {\n    HitInf hit = nulo;\n    vec3 or = ray.ori - s.cen;\n    vec3 dir = ray.dir;\n    \n    float A = dot (dir,dir);\n    float B = 2.*dot(or,dir);\n    float C = dot(or,or) - s.rai*s.rai;\n    \n    float delt = B*B - 4.*A*C;\n    if(delt<0.) return hit;\n    \n    float t1 = (-B-sqrt(delt))/(2.*A);\n    float t2 = (-B-sqrt(delt))/(2.*A);\n    float t = min( max(0.,t1),max(0.,t2) );\n    \n    if(t>0.001) {\n    \thit.hit = true;\n        hit.pos = ray.ori + t*ray.dir;\n        hit.nor = (hit.pos - s.cen)/s.rai;\n        hit.mat = s.mat;\n        hit.dis = t;\n        \n        if(s.padrao>0) {\n            float X = hit.pos.x - s.cen.x;\n            float Y = hit.pos.y - s.cen.y;\n            float Z = hit.pos.z - s.cen.z;\n            \n            float sig = degrees(acos( Y/s.rai ));\n            float tet = degrees(atan( Z/X ));\n            tet += mod(180.*step(0.,-X),360.);\n            \n            if(s.padrao == 1){\n                float ang = sin((tet+sig)/2.);\n                if(ang<0.) hit.mat=s.sec;\n            }\n            if(s.padrao==2){\n                float ang = sin(tet/3.)*sin(sig/3.);\n                if(ang<0.) hit.mat=s.sec;\n            }\n            if(s.padrao==3){\n                float ang = pow(sin(tet/10.),4.) + pow(cos(sig/10.),4.);\n                if(ang>0.9) hit.mat=s.sec;\n            }\n        }\n    }\n    \n    return hit;\n}\n\n// Encontra Plano\nHitInf findPlane(Plane p, Ray ray) {\n    HitInf hit = nulo;\n    float t = dot(p.nor,ray.dir);\n    if(t!=0.){\n        t = dot(p.ori - ray.ori,p.nor)/t;\n        if(t>0.001){\n            hit.hit=true;\n            hit.nor=p.nor;\n            hit.pos=ray.ori+t*ray.dir;\n            hit.mat=p.mat;\n            hit.dis=t;\n            \n            float a = sin(hit.pos.x)*sin(hit.pos.z);\n            if(a>0.) hit.mat = p.sec;\n        }\n    }\n    \n    return hit;\n}\n\n\n//Luz minha gente\nconst Ligth luz = Ligth(vec3(50.,50.,50.),vec3(0.99));\nvec3 iluminate(HitInf hit, Ray ray, vec3 camera) {\n    if(!hit.hit) return vec3(0.);\n    vec3 cor = vec3(0.);\n    \n    vec3 L = normalize(luz.pos - hit.pos);\n    vec3 view = normalize(camera - hit.pos);\n    vec3 refl = reflect (-L, hit.nor);\n    float spcFac = max(0.,dot(refl,view));\n    \n    if(!hit.ins) cor += max(0.,dot(L,hit.nor))*hit.mat.dif*luz.cor;\n    cor += hit.mat.amb*luz.cor;\n    if(!hit.ins) cor += hit.mat.spc*luz.cor*pow(spcFac,hit.mat.spf);\n    \n    return cor;\n}\n\nbool sombra(Ray ray, Sphere b){\n    HitInf hit = findSphere(b,ray);\n    if(hit.hit) return true;\n    return false;\n}\n\nHitInf traceScene(Ray ray){\n    \n    HitInf hit = nulo;\n    float t;\n    \n    HitInf aux;\n    \n    for(int i=0;i<3;i++) {\n        aux = findSphere(bola[i],ray);\n        if(!hit.hit || (aux.hit && aux.dis<hit.dis)) {\n        \thit=aux;\n        }\n    }\n    aux = findPlane(plano,ray);\n    if(!hit.hit || (aux.hit && aux.dis<hit.dis)){\n        hit=aux;\n    }\n    for(int i=0;i<3;i++) {\n        bool test = sombra( Ray(hit.pos,normalize(luz.pos - hit.pos)), bola[i] );\n       \tif(test) hit.ins = test;\n    }\n    \n    return hit;\n}\n    \nvec3 rayTrace(Ray ray){\n    \n    HitInf hit = nulo;\n    const int N = 2;\n    float t;\n    vec3 cor = vec3(0.);\n    vec3 camera = ray.ori;\n    \n\tbola[0] = Sphere(vec3(0.,5.,0.),3., metal, blu, 0 );\n\tbola[1] = Sphere(vec3(5.*sin(GT),0.,5.*cos(GT)),2., gre, blu, 2 );\n\tbola[2] = Sphere(vec3(5.*sin(-GT),0.,5.*-cos(GT)),2., red, gre, 1 );\n    \n    hit = traceScene(ray);    \n    if(!hit.hit) return cor;\n    cor += iluminate(hit,ray,ray.ori);\n    cor*=exp(-0.01*hit.dis);\n    if(!hit.mat.rfl) return cor;\n    //return cor;\n    \n    for(int i=1; i<N; i++){\n        ray = Ray(hit.pos,normalize(reflect(ray.dir,hit.nor)));\n        hit = traceScene(ray);   \n    \t//if(!hit.hit) return cor;\n    \tcor *= iluminate(hit,ray,camera);\n        cor*=exp(-0.01*hit.dis);\n    \tif(!hit.mat.rfl) return cor;\n    }\n    //cor += rayReflec( Ray(hit.pos,normalize(reflect(ray.dir,hit.nor)) ));\n    //cor*=exp(-2.*hit.dis);\n    return clamp(cor,0.,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv/2.;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 up = vec3(0.,1.,0.);\n    \n    vec3 eye = vec3(-15.*sin(iTime/3.),8.,15.*cos(iTime/3.));\n    vec3 tar = vec3(0.,2.,0.);\n    \n    vec3 ww = normalize(tar-eye);\n    vec3 uu = normalize( cross(ww,up) );\n    vec3 vv = normalize( cross(uu,ww) );\n\t\n    vec3 ux = uu*tan(radians(30.));\n    vec3 vy = vv*tan(radians(30.));\n    \n    mat3 camera = mat3(ux,vy,-ww);\n    \n    const float N = 3.;\n    float zoom = 1.;\n    vec3 color = vec3(0.);\n    \n    for(float i = 0.; i<N; i++)\n        for(float j = 0.; j<float(N); j++) {\n    \t\tvec2 o = (1.0+abs(uv.x-0.5)*3.0)*(vec2(float(i),float(j))/float(N)-0.5);\n    \t\tvec2 p = (-iResolution.xy + 2.0*(gl_FragCoord.xy + o))/iResolution.y;\n            vec3 rt = normalize( camera*vec3(p,-zoom) );\n            color += rayTrace( Ray(eye,rt) );\n        \n    }\n    color /= N*N;\n    //color = pow(color,vec3(1./2.2));\n        \n\tfragColor = vec4(color,1.);\n}","name":"Image","description":"","type":"image"}]}