{"ver":"0.1","info":{"id":"tttfDl","date":"1618396310","viewed":55,"name":"hexagon distance","username":"Dude","description":"hexagon dsf shader with repetition","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["hexagons"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAXIMUM_STEPS 80\n#define DISTANCE_THRESHOLD 0.1\n#define FAR_CLIP 30.0\n\n/* ROTATIONS */\n\nvoid rX(inout vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    p.y = c * q.y - s * q.z;\n    p.z = s * q.y + c * q.z;\n}\n\nvoid rY(inout vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    p.x = c * q.x + s * q.z;\n    p.z = -s * q.x + c * q.z;\n}\n\nvoid rZ(inout vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    p.x = c * q.x - s * q.y;\n    p.y = s * q.x + c * q.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec4 marchRay(vec3 ro, vec3 rd, float id) {\n\n    float d = 0.0; //distance marched\n    vec4 pc = vec4(0.2, 0.2, 0.7, 1.); //pixel colour\n\n    for (int i = 0; i < MAXIMUM_STEPS; ++i) {\n        \n        vec3 rp = ro + rd * d; //ray position\n        float time = id + iTime * 1.5;\n        rX(rp,time);\n        rY(rp,time + 0.3);\n        float ns = sdHexPrism(rp, vec2(3., 3.));\n        d += ns;\n        \n        if (ns < DISTANCE_THRESHOLD) {\n            vec3 clr = vec3(1.);\n            \n            rp = clr + (rp.y*0.4);\n            pc = vec4(.9, .9, .3, 1.);\n            pc *= vec4(rp.x, rp.y, rp.z, 1) + 0.4;\n            pc *= texture(iChannel1, rp.xy).rgba;\n            break;\n        }\n        \n        if (d > FAR_CLIP) {\n            break;\n        }\n    }\n\n    return pc;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/ iResolution.y;\n    float xfac = fract(uv.x * 5.);\n    float yfac = fract(uv.y * 5.);\n    float id = abs(uv.x);\n    uv = vec2(xfac, yfac);\n    uv.x -= 0.5;\n    uv.y -= 0.5;\n    vec3 rd = normalize(vec3(uv, 2.));\n    vec3 ro = vec3(0, 0, -20);\n    \n\tfragColor = marchRay(ro, rd, id);\n}","name":"Image","description":"","type":"image"}]}