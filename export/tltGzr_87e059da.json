{"ver":"0.1","info":{"id":"tltGzr","date":"1575635913","viewed":199,"name":"[delete]2D bounding volume","username":"delete","description":"bounding volume,box,sphere,ellipsoid","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["boundingvolume","pca"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define P_COUNT 10\n\nvec2 points1[P_COUNT];\nfloat hash11( float n )\n{\n    return fract(sin(n*13.)*43758.5453);\n}\nvec2 hash12(float n){\n    return fract(vec2(sin(n*17.),cos(n*13.))*43758.5453);\n}\n\nvec3 checkboard(vec2 uv){\n\tuv=floor(uv);\n    return vec3(mod(uv.x+uv.y,2.))-0.8;\n}\n\nfloat lineSDF(vec2 p,vec2 p1,vec2 p2){\n\tvec2 v1=p-p1;\n    vec2 v2=p2-p1;\n    vec2 projv1ATv2=dot(v1,v2)*v2/dot(v2,v2);\n    vec2 k=projv1ATv2/v2;\n    \n    if(k.x<0.||k.y<0.)return length(v1);\n    if(k.x>1.||k.y>1.)return length(p-p2);\n\tfloat d=length(v1-projv1ATv2);\n    return d;\n}\nfloat circleSDF(vec2 p,vec2 sc,float r){\n\treturn length(p-sc)-r;\n}\n\nfloat ellipsoidSDF(vec2 p,vec2 sc,mat2 r){\n    mat2 M=inverse(r);\n    p=M*p;\n    vec2 r2=vec2(length(r[0]),length(r[1]));\n\treturn length((p-M*sc))-1.;\n}\n\nfloat unionSDF(float d1,float d2){return min(d1,d2);}\n\nvec2 bmin=vec2(0.),bmax=vec2(0.);\nfloat boxAABB(vec2 xy){\n    float d=lineSDF(xy,bmin,vec2(bmax.x,bmin.y));\n\td=unionSDF(d,lineSDF(xy,bmin,vec2(bmin.x,bmax.y)));\n    d=unionSDF(d,lineSDF(xy,bmax,vec2(bmin.x,bmax.y)));\n    d=unionSDF(d,lineSDF(xy,bmax,vec2(bmax.x,bmin.y)));\n    return d;\n}\n\nmat2 axis=mat2(0.);\nmat2 ext=mat2(0.);\nvec2 sc=vec2(0.);\nbool naturalAxis(vec2 pos[P_COUNT]){\n\tvec2 mid=vec2(0.);\n    for(int i=0;i<P_COUNT;++i)mid+=pos[i];\n\tmid/=float(P_COUNT);\n\tmat2 M=mat2(0.);\n    for(int i=0;i<P_COUNT;++i){\n        vec2 v=pos[i]-mid;\n    \tM+=outerProduct(v,v);\n   \t}\n    M/=float(P_COUNT);\n    float b=-(M[0][0]+M[1][1])/2.;\n    float c=M[0][0]*M[1][1]-M[0][1]*M[1][0];\n    if(M[0][1]*M[1][0]==0.)return false;\n    float delta=b*b-c;\n    if(delta<=0.)return false;\n    delta=sqrt(delta);\n    vec2 lambda=vec2(delta,-delta)-b;\n\tmat2 M1=M-lambda[0]*mat2(1.,0.,0.,1.);\n    \n    axis[0]=normalize(vec2(1.,-M1[0][0]/M1[0][1]));\n    M1=M-lambda[1]*mat2(1.,0.,0.,1.);\n    axis[1]=normalize(vec2(1.,-M1[0][0]/M1[0][1]));\n    ext[0]=vec2(dot(axis[0],pos[0]));\n    ext[1]=vec2(dot(axis[1],pos[0]));\n    for(int i=1;i<P_COUNT;++i){\n    \tvec2 aa=vec2(dot(axis[0],pos[i]),dot(axis[1],pos[i]));\n        ext=mat2(min(ext[0].x,aa.x),\n        max(ext[0].y,aa.x),\n        min(ext[1].x,aa.y),\n        max(ext[1].y,aa.y));\n    }\n    sc=((ext[0].x+ext[0].y)*axis[0]+(ext[1].x+ext[1].y)*axis[1])/2.;\n    return true;\n}\n\n\nfloat boundingBox(vec2 xy){\t\n    mat4x2 pp;\n    pp[0]=axis[0]*ext[0].x+axis[1]*ext[1].x;\n    pp[1]=axis[0]*ext[0].y+axis[1]*ext[1].x;\n    pp[2]=axis[0]*ext[0].y+axis[1]*ext[1].y;\n    pp[3]=axis[0]*ext[0].x+axis[1]*ext[1].y;\n    \n    float d=lineSDF(xy,pp[0],pp[1]);\n    d=unionSDF(d,lineSDF(xy,pp[1],pp[2]));\n    d=unionSDF(d,lineSDF(xy,pp[2],pp[3]));\n    d=unionSDF(d,lineSDF(xy,pp[3],pp[0]));\n    \n    #if 0\n    vec2 lmin,lmax;\n    lmin=pp[0];lmax=lmin;\n    for(int i=1;i<4;++i){\n    \tlmin=min(pp[i],lmin);\n        lmax=max(pp[i],lmax);\n    }\n    \n    d=unionSDF(d,lineSDF(xy,lmin,vec2(lmax.x,lmin.y)));\n    d=unionSDF(d,lineSDF(xy,lmin,vec2(lmin.x,lmax.y)));\n    d=unionSDF(d,lineSDF(xy,lmax,vec2(lmin.x,lmax.y)));\n    d=unionSDF(d,lineSDF(xy,lmax,vec2(lmax.x,lmin.y)));\n    #endif\n    \n    return d;\n}\n\nfloat boundingSphere(vec2 xy,vec2 pos[P_COUNT]){\n\tvec2 pk,pl;\n    pk=axis[0]*ext[0][0];\n    pl=axis[0]*ext[0][1];\n\tfloat r=length((pk-pl)/2.);\n    vec2 sc2=sc;\n    for(int i=0;i<P_COUNT;++i){\n        if(length(pos[i]-sc2)>r){\n        \tsc2=(pos[i]+sc2+normalize(sc2-pos[i])*r)/2.;\n            r=length(sc2-pos[i]);\n        }\n    }\n    float d=circleSDF(xy,sc2,r);\n    return d;\n}\nfloat boundingEllipsoid(vec2 xy,vec2 pos[P_COUNT]){\n    mat2 M=axis*mat2(1./(ext[0][1]-ext[0][0]),0.,0.,1./(ext[1][1]-ext[1][0]))*transpose(axis);\n    for(int i=0;i<P_COUNT;++i)pos[i]=M*pos[i];\n    float r=.5;\n    vec2 sc2=M*sc;\n    for(int i=0;i<P_COUNT;++i){\n        if(length(pos[i]-sc2)>r){\n        \tsc2=(pos[i]+sc2+normalize(sc2-pos[i])*r)/2.;\n            r=length(sc2-pos[i]);\n        }\n    }\n    mat2 invM=inverse(M);\n    sc2=invM*sc2;\n    mat2 r2=invM*r;\n    float d=min(ellipsoidSDF(xy,sc2,r2),1.);\n    return d;\n}\n\nfloat pointSDF(vec2 uv,vec2 pos[P_COUNT]){\n\tfloat d=100.;\n    for(int i=0;i<P_COUNT;++i){\n    \td=unionSDF(d,length(uv-pos[i]));\n    }\n\treturn d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    uv.y*=iResolution.y/iResolution.x;\n    uv*=7.;\n    uv.x-=1.5;\n    uv.y-=1.0;\n    \n    for(int i=1;i<=P_COUNT;++i){\n        float t=iTime*hash11(float(i))*3.;\n    \tint a=int(floor(t))+1;\n        float b=fract(t);\n    \tpoints1[i-1]=mix(hash12(float(i*a)),hash12(float(i*(a+1))),b)*(hash12(float(i))-0.5)*3.+vec2(1.5,1.);\n        if(i==1){bmin=points1[0];bmax=bmin;continue;}\n        bmax=max(bmax,points1[i-1]);\n        bmin=min(bmin,points1[i-1]);\n    }\n\tif(!naturalAxis(points1))return;\n    //\n\tvec3 bgColor=checkboard(uv);\n    if(abs(uv.x)<.02||abs(uv.y)<.02)bgColor=vec3(0.0,0.3,.1);\n    vec3 col=bgColor;\n    \n    //plot\n    float f1=abs(boxAABB(uv));\n   \tcol=mix(vec3(1.),col,smoothstep(0.01,0.02,f1));\n    float f2=abs(boundingBox(uv));\n   \tcol=mix(vec3(1.,0.,0.),col,smoothstep(0.01,0.02,f2));\n    float f3=abs(boundingSphere(uv,points1));\n   \tcol=mix(vec3(0.,1.0,0.),col,smoothstep(0.01,0.02,f3));\n    float f4=abs(boundingEllipsoid(uv,points1));\n   \tcol=mix(vec3(0.,.0,1.),col,smoothstep(0.01,0.02,f4));\n    //show points\n    float d=smoothstep(0.03,0.04,pointSDF(uv,points1));\n    col=mix(vec3(1.0,0.7,0.0),col,d);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}