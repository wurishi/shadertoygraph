{"ver":"0.1","info":{"id":"tsKcWG","date":"1603677218","viewed":68,"name":"RIOW - 7 - Antialiasing","username":"TheMunro","description":"https://raytracing.github.io/books/RayTracingInOneWeekend.html#antialiasing","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord),0);\n    //fragColor = vec4(sqrt(data.rgb/data.w),1.0);\n    fragColor = vec4(data.rgb, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define AA 4\n\n//data types\nstruct Ray\n{ \n    vec3 o; \n    vec3 d;\n};\n    \nstruct Sphere\n{ \n    vec3 c; \n    float r;\n};\n    \nstruct HitRecord\n{\n    vec3 p;\n    vec3 n;\n    float t;\n    bool front_face;\n};\n    \n//constants\nvec3 zero = vec3(0., 0., 0.);\nvec3 one = vec3(1., 1., 1.);\n\nfloat near = 0.0001;\nfloat far = 1e20;\n//wherever you are...\n\nconst int MAX_OBJECTS = 2;\n    \nconst Sphere sphere0 = Sphere(vec3(0., 0., -1.), 0.5);\nconst Sphere sphere1 = Sphere(vec3(0.,-100.5,-1), 100.);\n\nSphere[MAX_OBJECTS] spheres = Sphere[](sphere0, sphere1);\n\n\n//functions\nbool hit_sphere(in Sphere s, in Ray r, in float t_min, in float t_max, out HitRecord hr)\n{\n    //quadratic solution \n    vec3 oc = r.o - s.c;\n    float a = dot(r.d, r.d);\n    float half_b = dot(oc, r.d);\n\tfloat c = dot(oc, oc) - s.r * s.r;\n    \n\tfloat det = half_b*half_b - a*c;\n        \n    if(det < 0.)\n        return false;\n    \n    float t = (-half_b - sqrt(det)) / a;\n    if(t < t_max && t > t_min) \n    {\n        hr.t = t;\n        hr.p = r.d * t + r.o;\n        hr.n = (hr.p - s.c) / s.r;\n        hr.front_face = dot(hr.n, r.d) < 0.;\n    \treturn true;\n    }\n    \n    t = (-half_b + sqrt(det)) / a;\n    if(t < t_max && t > t_min) \n    {\n        hr.t = t;\n        hr.p = r.d * t + r.o;\n        hr.n = (hr.p - s.c) / s.r;\n        hr.front_face = dot(hr.n, r.d) < 0.;\n    \treturn true;\n    }  \n\n    return false;\n}  \n\nbool hit_objects(in Sphere[MAX_OBJECTS] s, in Ray r, in float t_min, in float t_max, out HitRecord hr) \n{\n    HitRecord tmp;\n    bool hit = false;\n    float t = t_max;\n    \n    for(int i = 0; i < MAX_OBJECTS; i++) \n    {\n        if(hit_sphere(s[i], r, t_min, t, tmp)) \n        {\n            hit = true;\n            t = hr.t;\n            hr = tmp;\n        }\n    }\n    \n    return hit;\n}\n    \nvec3 ray_color(in Ray r)\n{\n    HitRecord hr;\n    if(hit_objects(spheres, r, near, far, hr)) \n    {\n        return 0.5 * (hr.n + 1.);\n    }\n    \n    vec3 n = normalize(r.d);\n    float t = 0.5 * (n.y + 1.);\n    return (1.0 - t) * one + t * vec3(0.5, 0.7, 1.);\n}\n\n//output\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) \n{   \n    vec3 col = zero;\n    vec2 seed = vec2(hrand(fragCoord) + iTime);\n    \n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        vec2 uv = (2. * fragCoord.xy - iResolution.xy + vec2(float(m),float(n))/float(AA) + hash_2d(seed))/iResolution.y;\n#else      \n        vec2 uv = (2. * fragCoord.xy - iResolution.xy + hash_2d(seed))/iResolution.y;\n#endif\n        \n    \t//position \n        Ray r = Ray(zero, vec3(uv, -1.));\n\n        col += ray_color(r);\n        \n#if AA>1\n    }\n    col /= float(AA*AA);\n#endif\n    \n    //still need to accumulate per frame\n    fragColor = vec4(col, 1.);\n}","name":"Buffer @","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"float nrand(in vec2 n)\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\n\n// Hash functions by Nimitz:\n// https://www.shadertoy.com/view/Xt3cDn\n\nuint base_hash(uvec2 p)\n{\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nfloat hash_1d(vec2 x)\n{\n    uint n = base_hash(floatBitsToUint(x));\n    return float(n)*(1.0/float(0xffffffffU));\n}\n\nvec2 hash_2d(vec2 x)\n{\n    uint n = base_hash(floatBitsToUint(x));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2((rz.xy >> 1) & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 hash_3d(vec2 x)\n{\n    uint n = base_hash(floatBitsToUint(x));\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\n    return vec3((rz >> 1) & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec4 hash_4d(vec2 x)\n{\n    uint n = base_hash(floatBitsToUint(x));\n    uvec4 rz = uvec4(n, n*16807U, n*48271U, n*69621U); //see: http://random.mat.sbg.ac.at/results/karl/server/node4.html\n    return vec4((rz >> 1) & uvec4(0x7fffffffU))/float(0x7fffffff);\n}  \n\nfloat hrand(in vec2 coord) \n{\n    uint hashed_coord = base_hash(floatBitsToUint(coord));\n    return float(hashed_coord)/float(0xFFFFFFFFU);  \n}\n","name":"Common","description":"","type":"common"}]}