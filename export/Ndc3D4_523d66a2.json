{"ver":"0.1","info":{"id":"Ndc3D4","date":"1629777013","viewed":92,"name":"Basic convolution","username":"Yon","description":"Basic convolution, multiple sampling and not brdf.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["convolution"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define UV_SCALE 0.6\n\n#define sampleCount 128\n#define saturate(x) clamp(x,0.,1.)\n\n//------------------------------------------------------------------------------\n// Distance field functions\n//------------------------------------------------------------------------------\n\nfloat sdPlane(in vec3 p) {\n    return p.y;\n}\n\nfloat sdSphere(in vec3 p, float s) {\n    return length(p) - s;\n}\n\n\nvec2 opUnion(vec2 d1, vec2 d2) {\n    return d1.x < d2.x ? d1 : d2;\n}\n\nvec2 scene(in vec3 position) {\n    vec2 scene = opUnion(\n          vec2(sdPlane(position), 1.0),\n          vec2(sdSphere(position - vec3(0.0, 0.4, 0.0), 0.4), 12.0)\n    );\n    return scene;\n}\n\n//------------------------------------------------------------------------------\n// Ray casting\n//------------------------------------------------------------------------------\n\nfloat shadow(in vec3 origin, in vec3 direction) {\n    float hit = 1.0;\n    float t = 0.02;\n    \n    for (int i = 0; i < 1000; i++) {\n        float h = scene(origin + direction * t).x;\n        if (h < 0.001) return 0.0;\n        t += h;\n        hit = min(hit, 10.0 * h / t);\n        if (t >= 2.5) break;\n    }\n\n    return clamp(hit, 0.0, 1.0);\n}\n\nvec2 traceRay(in vec3 origin, in vec3 direction) {\n    float material = -1.0;\n\n    float t = 0.02;\n    \n    for (int i = 0; i < 1000; i++) {\n        vec2 hit = scene(origin + direction * t);\n        if (hit.x < 0.002 || t > 20.0) break;\n        t += hit.x;\n        material = hit.y;\n    }\n\n    if (t > 20.0) {\n        material = -1.0;\n    }\n\n    return vec2(t, material);\n}\n\nvec3 normal(in vec3 positionWS) {\n    vec3 epsilon = vec3(0.001, 0.0, 0.0);\n    vec3 n = vec3(\n          scene(positionWS + epsilon.xyy).x - scene(positionWS - epsilon.xyy).x,\n          scene(positionWS + epsilon.yxy).x - scene(positionWS - epsilon.yxy).x,\n          scene(positionWS + epsilon.yyx).x - scene(positionWS - epsilon.yyx).x);\n    return normalize(n);\n}\n\nvec3 SphereRand( uint seed )\n{\n    float a = (float((seed*0x73493U)&0xfffffU)/float(0x100000))*2. - 1.;\n    float b = 6.283*(float((seed*0xAF71fU)&0xfffffU)/float(0x100000));\n    float cosa = sqrt(1.-a*a);\n    return vec3(cosa*cos(b),a,cosa*sin(b));\n}\n\nfloat pow2(float x){\n    return x*x;\n}\n\nvec3 Convolution(vec3 n, in uint rngState, float roughness){\n\n    vec3 radiance = vec3(0.);\n\n    for(int i; i<= sampleCount;i++){\n        vec3 dir = normalize(n + SphereRand(rngState+uint(i))*roughness);\n        radiance += texture(iChannel0,dir).xyz *clamp(dot(dir, n),0.,1.)/ float(sampleCount);  \n    }\n    return radiance;  \n} \n\nvec3 render(in vec3 origin, in vec3 direction, out float distance, in uint rngState) {\n    // Sky gradient\n    vec3 color = texture(iChannel0,direction).xyz;\n\n    // (distance, material)\n    vec2 hit = traceRay(origin, direction);\n    distance = hit.x;\n    float material = hit.y;\n\n    // We've hit something in the scene\n    if (material > 0.0) {\n        //\n        vec3 positionWS = origin + distance * direction;\n\n        vec3 v = normalize(-direction);\n        vec3 n = normal(positionWS);\n        vec3 l = normalize(vec3(0.6, 0.7, -0.7));\n        vec3 h = normalize(v + l);\n        vec3 r = normalize(reflect(direction, n));\n\n        float NoV = abs(dot(n, v)) + 1e-5;\n        float NoL = saturate(dot(n, l));\n        float NoH = saturate(dot(n, h));\n        float LoH = saturate(dot(l, h));\n\n        vec3 baseColor = vec3(0.0);\n        float roughness = 0.0;\n        float metallic = 0.0;\n\n        float intensity = 4.0;\n        float indirectIntensity = 2.;\n\n        baseColor = Convolution(r,rngState,pow2(sin(iTime*0.25)));\n        color = baseColor;\n    }\n\n    return color;\n}\n\n// ------------------------------------------------------------------------------\n// Setup and execution\n// ------------------------------------------------------------------------------\n\nmat3 setCamera(in vec3 origin, in vec3 target, float rotation) {\n    vec3 forward = normalize(target - origin);\n    vec3 orientation = vec3(sin(rotation), cos(rotation), 0.0);\n    vec3 left = normalize(cross(forward, orientation));\n    vec3 up = normalize(cross(left, forward));\n    return mat3(left, up, forward);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized coordinates\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x / iResolution.y;\n\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n\n    // Camera positionWS and \"look at\"\n    vec3 origin = vec3(0.0,2., 0.0);\n    vec3 target = vec3(0.0);\n\n    origin.x += 3. * cos(iMouse.x * 0.006);\n    origin.z += 3. * sin(iMouse.x * 0.006);\n    origin.y += iMouse.y * 0.03-1.5;\n\n    mat3 toWorld = setCamera(origin, target, 0.0);\n    vec3 direction = toWorld * normalize(vec3(p.xy, 2.0));\n\n    // // Render scene\n    float distance;\n    vec3 color;\n    color = render(origin, direction, distance,rngState);\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}