{"ver":"0.1","info":{"id":"MlGfDW","date":"1562331701","viewed":99,"name":"RayRay","username":"AXaViaN","description":"Ray-tracer demo","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["raytracer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Check \"Common\" tab for usage and config\n\n//////////////////////////////////\n// Main\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 color = texture(iChannel0, uv).xyz;\n    \n    // HDR tone mapping\n    color = vec3(1.0f) - exp(-color * Config_HDRExposure);\n    \n    // Gamma correction\n    color = pow(color, vec3(1.0f/Config_Gamma));\n    \n    fragColor = vec4(color, 1.0f);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//////////////////////////////////\n///////////// USAGE //////////////\n//////////////////////////////////\n\n// Circulation on/off: space/escape\n// Camera movement: WASD + EQ\n// Camera rotation: arrow keys\n\n//////////////////////////////////\n///////////// CONFIG /////////////\n//////////////////////////////////\n\nconst float Config_Gamma = 2.2f;\nconst float Config_HDRExposure = 2.0f;\n\nconst uint Config_ScatterDepth = 15u;\n\nconst float Config_CameraMoveSpeed = 10.0f;\nconst float Config_CameraRotateSpeed = 100.0f;\n\nconst vec3 Config_CameraPosition = vec3(0.0f, 1.0f, 7.5f);\nconst vec3 Config_CameraDirection = vec3(0.0f, 0.0f, -1.0f);\nconst vec3 Config_CameraUp = vec3(0.0f, 1.0f, 0.0f);\nconst float Config_CameraFov = 45.0f;\n\nconst vec3 Config_CirculateAround = vec3(0.0f, 1.0f, 0.0f);\nconst float Config_CirculateDistance = 6.0f;\nconst float Config_CirculateSpeed = 30.0f;\n\n//////////////////////////////////\n////////// GLOBAL CODE ///////////\n//////////////////////////////////\n\n//////////////////////////////////\n// Globals\n\nvec2 g_RandomSeed; // Set this to vec2(uv * iTime)\nvec2 g_Resolution; // Set this to iResolution.xy\n\n//////////////////////////////////\n// Constants\n\nconst float PI = acos(-1.0f);\n\n//////////////////////////////////\n// SharedData\n\nconst uint CameraPosition_Idx = 0u; // xyz, w=isChanged\nconst uint CameraDirection_Idx = 1u; // xyz, w=isChanged\nconst uint SampleInfo_Idx = 2u; // x=sampleCount\nconst uint Circulation_Idx = 3u; // xyz, w=frameSinceStart\n\nconst uint SharedDataSize = 4u;\nvec4 g_SharedData[SharedDataSize];\n\n//////////////////////////////////\n// Data\n\nvec2 Data_GetCoord(uint idx)\n{\n    uint x = idx % uint(g_Resolution.x);\n    uint y = idx / uint(g_Resolution.x);\n    return vec2(0.5f + float(x), 0.5f + float(y));\n}\nvoid Data_LoadShared(sampler2D dataBuffer)\n{\n    for( uint i=0u ; i<SharedDataSize ; i++ )\n    {\n        vec2 uv = Data_GetCoord(i) / g_Resolution;\n        g_SharedData[i] = texture(dataBuffer, uv);\n    }\n}\nvec4 Data_GetValue(uint idx)\n{\n    return g_SharedData[idx];\n}\n\n//////////////////////////////////\n// Math\n\nfloat Math_ToRadian(float angle)\n{\n    return angle * (PI / 180.0f);\n}\n\nvec4 Math_Quaternion(vec3 axis, float angle)\n{\n    float halfRadian = Math_ToRadian(angle/2.0f);\n    vec4 quaternion;\n    quaternion.xyz = axis * vec3(sin(halfRadian));\n    quaternion.w = cos(halfRadian);\n    return quaternion;\n}\nvec4 Math_InverseQuaternion(vec4 quaternion)\n{\n    return vec4(-quaternion.xyz, quaternion.w) / length(quaternion);\n}\nvec4 Math_QuaternionMult(vec4 q1, vec4 q2)\n{ \n    vec4 qr;\n    qr.x = (q1.w * q2.x) + (q1.x * q2.w) + (q1.y * q2.z) - (q1.z * q2.y);\n    qr.y = (q1.w * q2.y) - (q1.x * q2.z) + (q1.y * q2.w) + (q1.z * q2.x);\n    qr.z = (q1.w * q2.z) + (q1.x * q2.y) - (q1.y * q2.x) + (q1.z * q2.w);\n    qr.w = (q1.w * q2.w) - (q1.x * q2.x) - (q1.y * q2.y) - (q1.z * q2.z);\n    return qr;\n}\nvec3 Math_Rotate(vec3 vector, vec3 axis, float angle)\n{\n    vec4 quaternion = Math_Quaternion(axis, angle);\n    if(length(quaternion) < 0.001f)\n    {\n        return vector;\n    }\n    vec4 inverseQuaternion = Math_InverseQuaternion(quaternion);\n    vec4 vectorQuaternion = vec4(vector, 0.0f);\n    vec4 result = Math_QuaternionMult(quaternion, vectorQuaternion);\n    result = Math_QuaternionMult(result, inverseQuaternion);\n    return result.xyz;\n}\n\n//////////////////////////////////\n// General\n\nfloat Random_Peek()\n{\n    return fract(sin(dot(g_RandomSeed ,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat Random()\n{\n    g_RandomSeed.x = Random_Peek();\n    g_RandomSeed.y = Random_Peek();\n    return g_RandomSeed.x;\n}\n\nvec3 Random_Direction()\n{\n    vec3 direction = vec3(Random(), Random(), Random())*2.0f - vec3(1.0f);\n    return normalize(direction);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//////////////////////////////////\n////// SHARED DATA TEXTURE ///////\n//////////////////////////////////\n\n// Inputs are handled here\n\n//////////////////////////////////\n// Constants\n\n#define SHARED_CHANNEL iChannel0\n#define KEYBOARD_CHANNEL iChannel1\n\nconst int KEY_W = 87;\nconst int KEY_A = 65;\nconst int KEY_S = 83;\nconst int KEY_D = 68;\nconst int KEY_E = 69;\nconst int KEY_Q = 81;\nconst int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\nconst int KEY_SPACE = 32;\nconst int KEY_ESCAPE = 27;\n\n//////////////////////////////////\n// General\n\nbool IsKeyPress(int key)\n{\n    return texelFetch(KEYBOARD_CHANNEL, ivec2(key, 0), 0).x != 0.0f;\n}\n\n//////////////////////////////////\n// Data\n\nvec4 Data_Write(vec2 fragCoord)\n{\n    vec4 data;\n    \n    if(fragCoord == Data_GetCoord(CameraPosition_Idx))\n    {\n        if(iFrame == 0)\n        {\n            return vec4(Config_CameraPosition, 1.0f);\n        }\n        \n        float isCirculateActive = Data_GetValue(Circulation_Idx).w;\n        if(isCirculateActive > 0.0f)\n        {\n            return vec4(Data_GetValue(Circulation_Idx).xyz, 1.0f);\n        }\n        \n        vec3 movement;\n        if(IsKeyPress(KEY_W))\n        {\n            movement.z += 1.0f;\n        }\n        if(IsKeyPress(KEY_S))\n        {\n            movement.z -= 1.0f;\n        }\n        if(IsKeyPress(KEY_A))\n        {\n            movement.x -= 1.0f;\n        }\n        if(IsKeyPress(KEY_D))\n        {\n            movement.x += 1.0f;\n        }\n        if(IsKeyPress(KEY_E))\n        {\n            movement.y += 1.0f;\n        }\n        if(IsKeyPress(KEY_Q))\n        {\n            movement.y -= 1.0f;\n        }\n        movement *= Config_CameraMoveSpeed * iTimeDelta;\n        \n        vec3 forward = Data_GetValue(CameraDirection_Idx).xyz;\n        vec3 right = normalize(cross(forward, Config_CameraUp));\n        vec3 up = normalize(cross(right, forward));\n        \n        vec3 cameraPosition = Data_GetValue(CameraPosition_Idx).xyz;\n        vec3 oldPosition = cameraPosition;\n        cameraPosition += forward * movement.z;\n        cameraPosition += right * movement.x;\n        cameraPosition += up * movement.y;\n        \n        data = vec4(cameraPosition, 0.0f);\n        if(cameraPosition != oldPosition)\n        {\n            data.w = 1.0f;\n        }\n    }\n    else if(fragCoord == Data_GetCoord(CameraDirection_Idx))\n    {\n        if(iFrame == 0)\n        {\n            return vec4(Config_CameraDirection, 1.0f);\n        }\n        \n        float isCirculateActive = Data_GetValue(Circulation_Idx).w;\n        if(isCirculateActive > 0.0f)\n        {\n            vec3 circulationPosition = Data_GetValue(Circulation_Idx).xyz;\n            vec3 direction = Config_CirculateAround - circulationPosition;\n            return vec4(normalize(direction), 1.0f);\n        }\n        \n        vec2 rotation;\n        if(IsKeyPress(KEY_UP))\n        {\n            rotation.x += 1.0f;\n        }\n        if(IsKeyPress(KEY_DOWN))\n        {\n            rotation.x -= 1.0f;\n        }\n        if(IsKeyPress(KEY_LEFT))\n        {\n            rotation.y += 1.0f;\n        }\n        if(IsKeyPress(KEY_RIGHT))\n        {\n            rotation.y -= 1.0f;\n        }\n        rotation *= Config_CameraRotateSpeed * iTimeDelta;\n        \n        vec3 cameraDirection = Data_GetValue(CameraDirection_Idx).xyz;\n        vec3 right = normalize(cross(cameraDirection, Config_CameraUp));\n        vec3 up = normalize(cross(right, cameraDirection));\n        \n        vec3 oldDirection = cameraDirection;\n        \n        // Rotate around right\n        vec3 tmpDirection = cameraDirection;\n        cameraDirection = Math_Rotate(cameraDirection, right, rotation.x);\n        if(abs(dot(cameraDirection, Config_CameraUp)) > 0.999f)\n        {\n            cameraDirection = tmpDirection;\n        }\n        \n        // Rotate around up\n        tmpDirection = cameraDirection;\n        cameraDirection = Math_Rotate(cameraDirection, up, rotation.y);\n        if(abs(dot(cameraDirection, Config_CameraUp)) > 0.999f)\n        {\n            cameraDirection = tmpDirection;\n        }\n        \n        data = vec4(cameraDirection, 0.0f);\n        if(cameraDirection != oldDirection)\n        {\n            data.w = 1.0f;\n        }\n    }\n    else if(fragCoord == Data_GetCoord(SampleInfo_Idx))\n    {\n        if(iFrame == 0)\n        {\n            return vec4(1.0f, 0.0f, 0.0f, 0.0f);\n        }\n        \n        float isPositionChanged = Data_GetValue(CameraPosition_Idx).w;\n        float isDirectionChanged = Data_GetValue(CameraDirection_Idx).w;\n        float shouldUpdate = (isPositionChanged + isDirectionChanged);\n        if(shouldUpdate != 0.0f)\n        {\n            data.x = 1.0f;\n        }\n        else\n        {\n        \tfloat sampleCount = Data_GetValue(SampleInfo_Idx).x;\n            data.x = sampleCount + 1.0f;\n        }\n    }\n    else if(fragCoord == Data_GetCoord(Circulation_Idx))\n    {\n        if(iFrame == 0)\n        {\n            return vec4(Config_CameraPosition, 1.0f);\n        }\n        \n        float frameSinceStart = Data_GetValue(Circulation_Idx).w;\n        if(IsKeyPress(KEY_SPACE))\n        {\n            frameSinceStart = 1.0f;\n        }\n        else if(IsKeyPress(KEY_ESCAPE))\n        {\n            frameSinceStart = 0.0f;\n        }\n        \n        if(frameSinceStart == 0.0f)\n        {\n            return vec4(0.0f);\n        }\n        \n        vec3 position = Config_CirculateAround;\n        float rotateDegree = iTime * Config_CirculateSpeed;\n        vec3 rotation = vec3(sin(Math_ToRadian(rotateDegree)), \n                             0.0f, \n                             cos(Math_ToRadian(rotateDegree)));\n        position += rotation * Config_CirculateDistance;\n        \n        vec3 cameraPosition = Data_GetValue(CameraPosition_Idx).xyz;\n        float animationStep = frameSinceStart / 1000.0f;\n        animationStep = min(animationStep * Config_CirculateSpeed, 1.0f);\n        position = mix(cameraPosition, position, animationStep);\n        \n        return vec4(position, ++frameSinceStart);\n    }\n    \n    return data;\n}\n\n//////////////////////////////////\n// Main\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Initialize\n    g_RandomSeed = vec2(uv * iTime);\n    g_Resolution = iResolution.xy;\n    Data_LoadShared(SHARED_CHANNEL);\n    \n    // Data\n    vec4 writeData = Data_Write(fragCoord);\n    fragColor = writeData;\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//////////////////////////////////\n/////////// RENDERING ////////////\n//////////////////////////////////\n\n//////////////////////////////////\n// Constants\n\n#define SHARED_CHANNEL iChannel3\n#define SKYBOX_CHANNEL iChannel0\n\nconst uint MaterialType_Diffuse = 0u;\nconst uint MaterialType_Metal = 1u;\n\n//////////////////////////////////\n// Structs\n\nstruct Ray\n{\n    vec3 Origin;\n    vec3 Direction;\n};\n\nstruct ObjectMaterial\n{\n    uint Type;\n    vec3 Color;\n    float Fuzziness;\n};\n\nstruct Sphere\n{\n    vec3 Position;\n    float Radius;\n    \n    ObjectMaterial Material;\n};\n\nstruct HitRecord\n{\n    ObjectMaterial Material;\n    \n    vec3 Point;\n    vec3 Normal;\n    float T;\n    bool IsHit;\n};\n\nstruct ScatterRecord\n{\n    Ray ScatterRay;\n    vec3 Color;\n    bool IsScatter;\n};\n\n//////////////////////////////////\n// Ray\n\nRay Ray_Create(vec3 origin, vec3 direction)\n{\n    Ray ray;\n    ray.Origin = origin;\n    ray.Direction = normalize(direction);\n    return ray;\n}\nvec3 Ray_GetPoint(Ray ray, float t)\n{\n    return ray.Origin + (ray.Direction * t);\n}\n\n//////////////////////////////////\n// Sphere\n\nSphere Sphere_Create(vec3 position, float radius, ObjectMaterial material)\n{\n    Sphere sphere;\n    sphere.Position = position;\n    sphere.Radius = radius;\n    sphere.Material = material;\n    return sphere;\n}\nHitRecord Sphere_HitCheck(Sphere sphere, Ray ray, float tMin, float tMax)\n{\n    HitRecord hitRecord;\n    hitRecord.Material = sphere.Material;\n    \n    vec3 sphereToRay = ray.Origin - sphere.Position;\n    float a = dot(ray.Direction, ray.Direction);\n    float b = 2.0f * dot(ray.Direction, sphereToRay);\n    float c = dot(sphereToRay, sphereToRay) - pow(sphere.Radius, 2.0f);\n    \n    float discriminant = b*b - 4.0f*a*c;\n    \n    hitRecord.IsHit = (discriminant > 0.0f);\n    if(hitRecord.IsHit)\n    {\n        hitRecord.T = (-b - sqrt(discriminant)) / (2.0f*a);\n        if(hitRecord.T > tMin && \n           hitRecord.T < tMax)\n        {\n            hitRecord.Point = Ray_GetPoint(ray, hitRecord.T);\n            hitRecord.Normal = (hitRecord.Point - sphere.Position) / sphere.Radius;\n        }\n        else\n        {\n            hitRecord.IsHit = false;\n        }\n    }\n    \n    return hitRecord;\n}\n\n//////////////////////////////////\n// Material\n\nScatterRecord Material_LambertianScatter(Ray ray, HitRecord hitRecord)\n{\n    ScatterRecord scatterRecord;\n    \n    vec3 rayDirection = hitRecord.Normal + Random_Direction();\n    scatterRecord.ScatterRay = Ray_Create(hitRecord.Point, rayDirection);\n    \n    scatterRecord.Color = hitRecord.Material.Color;\n    scatterRecord.IsScatter = true;\n    \n    return scatterRecord;\n}\nScatterRecord Material_MetalScatter(Ray ray, HitRecord hitRecord)\n{\n    ScatterRecord scatterRecord;\n    \n    vec3 reflected = reflect(ray.Direction, hitRecord.Normal);\n    vec3 fuzz = Random_Direction() * clamp(hitRecord.Material.Fuzziness, \n                                           0.0f, 1.0f);\n    reflected += fuzz;\n    scatterRecord.ScatterRay = Ray_Create(hitRecord.Point, reflected);\n    \n    scatterRecord.Color = hitRecord.Material.Color;\n    \n    float cosScatterNormal = dot(scatterRecord.ScatterRay.Direction, \n                                 hitRecord.Normal);\n    scatterRecord.IsScatter = (cosScatterNormal > 0.0f);\n    \n    return scatterRecord;\n}\n\nScatterRecord Material_ScatterCheck(Ray ray, HitRecord hitRecord)\n{\n    ScatterRecord scatterRecord;\n    scatterRecord.IsScatter = false;\n    if(hitRecord.Material.Type == MaterialType_Diffuse)\n    {\n        scatterRecord = Material_LambertianScatter(ray, hitRecord);\n    }\n    else if(hitRecord.Material.Type == MaterialType_Metal)\n    {\n        scatterRecord = Material_MetalScatter(ray, hitRecord);\n    }\n    return scatterRecord;\n}\n\n//////////////////////////////////\n// Camera\n\nRay Camera_GetRay(vec3 position, vec3 lookat, vec3 up, \n                  float fov, float aspectRatio, vec2 uv)\n{\n    vec3 cameraUp = normalize(up);\n    vec3 renderPlaneForward = normalize(position - lookat);\n    vec3 renderPlaneRight = normalize(cross(cameraUp, renderPlaneForward));\n    vec3 renderPlaneUp = normalize(cross(renderPlaneForward, renderPlaneRight));\n    \n    float height = tan(Math_ToRadian(fov / 2.0f)) * 2.0f;\n    float width = height * aspectRatio;\n    vec3 frustumSize = vec3(width, height, 2.0f);\n    \n    vec3 renderPlaneHorizontal = renderPlaneRight * frustumSize.x;\n    vec3 renderPlaneVertical = renderPlaneUp * frustumSize.y;\n    vec3 renderPlaneLowerLeftCorner = -renderPlaneHorizontal / 2.0f \n                                      -renderPlaneVertical / 2.0f \n                                      -(renderPlaneForward * frustumSize.z) / 2.0f;\n    \n    vec3 rayDirection = renderPlaneLowerLeftCorner + \n                        renderPlaneHorizontal*uv.x + \n                        renderPlaneVertical*uv.y;\n    rayDirection = normalize(rayDirection);\n    \n    return Ray_Create(position, rayDirection);\n}\n\n//////////////////////////////////\n// Render\n\nconst uint SphereCount = 4u;\n\nHitRecord Render_SpheresHitCheck(Sphere spheres[SphereCount], Ray ray)\n{\n    HitRecord hitRecord;\n    hitRecord.T = 1.0f / 0.0f;\n    for( uint i=0u ; i<SphereCount ; ++i )\n    {\n        HitRecord currentHitRecord = Sphere_HitCheck(spheres[i], ray, \n                                                     0.001f, hitRecord.T);\n        if(currentHitRecord.IsHit)\n        {\n            hitRecord = currentHitRecord;\n        }\n    }\n    return hitRecord;\n}\n\nvec3 Render_GetColor(Sphere spheres[SphereCount], Ray cameraRay)\n{\n    vec3 totalColor = vec3(1.0f);\n    Ray ray = cameraRay;\n    uint depth = 0u;\n    while(depth++ < Config_ScatterDepth)\n    {\n        HitRecord hitRecord = Render_SpheresHitCheck(spheres, ray);\n        if(hitRecord.IsHit)\n        {\n            ScatterRecord scatterRecord = Material_ScatterCheck(ray, hitRecord);\n            if(scatterRecord.IsScatter)\n            {\n                totalColor *= scatterRecord.Color;\n                ray = scatterRecord.ScatterRay;\n            }\n            else\n            {\n                totalColor *= vec3(0.0f);\n                break;\n            }\n        }\n        else\n        {\n            totalColor *= texture(SKYBOX_CHANNEL, ray.Direction).xyz;\n            break;\n        }\n    }\n    return totalColor;\n}\n\nvec3 Render(vec2 uv)\n{\n    // Scene\n    Sphere spheres[SphereCount];\n    {\n        vec3 position;\n        float radius;\n        ObjectMaterial material;\n        \n        position = vec3(0.0f, -10000.0f, 0.0f);\n        radius = 10000.0f;\n        material.Type = MaterialType_Metal;\n        material.Color = vec3(1.0f, 1.0f, 1.0f) * 0.25f;\n        material.Fuzziness = 0.25f;\n        spheres[0] = Sphere_Create(position, radius, material);\n        \n        position = vec3(-2.0f, 1.0f, 0.0f);\n        radius = 1.0f;\n        material.Type = MaterialType_Metal;\n        material.Color = vec3(5.0f, 1.0f, 1.0f);\n        material.Fuzziness = 0.0f;\n        spheres[1] = Sphere_Create(position, radius, material);\n        \n        position = vec3(0.0f, 1.0f, -1.0f);\n        radius = 1.0f;\n        material.Type = MaterialType_Diffuse;\n        material.Color = vec3(1.0f, 1.0f, 1.0f) * 0.75f;\n        spheres[2] = Sphere_Create(position, radius, material);\n        \n        position = vec3(2.0f, 1.0f, 0.0f);\n        radius = 1.0f;\n        material.Type = MaterialType_Metal;\n        material.Color = vec3(1.0f, 1.0f, 5.0f);\n        material.Fuzziness = 0.2f;\n        spheres[3] = Sphere_Create(position, radius, material);\n    }\n    \n    // Camera\n    Ray cameraRay;\n    {\n        vec3 position = Data_GetValue(CameraPosition_Idx).xyz;\n        vec3 direction = Data_GetValue(CameraDirection_Idx).xyz;\n        vec3 lookat = position + direction;\n        vec3 up = Config_CameraUp;\n        float fov = Config_CameraFov;\n        float aspectRatio = iResolution.x / iResolution.y;\n        \n        cameraRay = Camera_GetRay(position, lookat, up, \n                                  fov, aspectRatio, uv);\n    }\n    \n    // Rendering\n    return Render_GetColor(spheres, cameraRay);\n}\n\n//////////////////////////////////\n// Main\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Initialize\n    g_RandomSeed = vec2(uv * iTime);\n    g_Resolution = iResolution.xy;\n    Data_LoadShared(SHARED_CHANNEL);\n    \n    // Render for one sample\n    uv = (fragCoord+Random()) / iResolution.xy;\n    vec3 color = Render(uv);\n    fragColor = vec4(color, 1.0f);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//////////////////////////////////\n/////// SAMPLE ACCUMULATION //////\n//////////////////////////////////\n\n//////////////////////////////////\n// Constants\n\n#define SHARED_CHANNEL iChannel0\n#define RENDER_CHANNEL iChannel1\n#define LASTRENDER_CHANNEL iChannel2\n\n//////////////////////////////////\n// Main\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Initialize\n    g_RandomSeed = vec2(uv * iTime);\n    g_Resolution = iResolution.xy;\n    Data_LoadShared(SHARED_CHANNEL);\n    \n    vec4 oldColor = texture(LASTRENDER_CHANNEL, uv);\n    vec4 newColor = texture(RENDER_CHANNEL, uv);\n    float sampleCount = Data_GetValue(SampleInfo_Idx).x;\n    \n    // Accumulation\n    vec4 totalColor = (oldColor * (sampleCount - 1.0f)) + newColor;\n    totalColor /= sampleCount;\n    \n    fragColor = totalColor;\n}\n","name":"Buffer C","description":"","type":"buffer"}]}