{"ver":"0.1","info":{"id":"XfKGWD","date":"1712789887","viewed":103,"name":"Experiment with heightmap SDF","username":"jaszunio15","description":"Here I'm trying some idea to convert heightmap SDF to be more correct in positive values.\nThis approach works quite nicely, but I think that might be too costly to compute in realtime my use case.\n\nI have few more ideas that might work better or worse.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["heightmapsdftest"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Shader License: CC BY 3.0\n//Author: Jan Mr√≥z (jaszunio15)\n\n/*\nHere I'm trying some ideas to convert heightmap SDF to be more correct in positive values.\nThis approach works quite nicely, but I think that might be too costly to compute in realtime my use case.\n\nI don't like that the area near the surface looks stretched in many cases.\n\nI have few more ideas that might work better or worse.\nAnother idea that works better in my case (but doesn't look like it should): https://www.shadertoy.com/view/4cKGDm\n*/\n\nfloat Heightmap(float x)\n{\n    return (pow(textureLod(iChannel0, vec2((x) * 0.04, iTime * 0.001), 0.0).x, 1.0) - 0.5) * -8.0 - 1.0;\n}\n\nfloat SmoothMin(float d1, float d2, float k)\n{\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat SmoothMax(float d1, float d2, float k)\n{\n    float h = clamp(0.5 - 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) + k * h * (1.0 - h);\n}\n\nfloat DiskSDF(vec2 coord, vec2 diskCenter, float radius)\n{\n    return distance(coord, diskCenter) - radius;\n}\n\nbool fixHeightmap = false;\n\nfloat GetFixedHeightmapLayerSDF(vec2 coord, float shift, float scale)\n{\n    float rootX = round(coord.x * scale + shift);\n    float scaleInverted = 1.0 / scale;\n    \n    float sdf = 99999.0;\n    float circleRadius = 0.6;\n    \n    float x = 0.0;\n    for (float x = -3.0f; x <= 3.1; x += 1.0)\n    {\n        float circleX = (rootX + x - shift) * scaleInverted;\n        float height = Heightmap(circleX);\n        vec2 circleCenter = vec2(circleX, height - circleRadius * scaleInverted);\n        sdf = SmoothMin(sdf, DiskSDF(coord, circleCenter, circleRadius * scaleInverted), 0.9 * scaleInverted);\n    }\n    \n    return sdf;\n}\n\nfloat SDFFunction(vec2 coord)\n{\n    float heightmapSDF = coord.y - Heightmap(coord.x);\n    \n    float sdf = heightmapSDF;\n    \n    // Here is the main code - spawning many SDF spheres below the heightmap to approximate it.\n    if (fixHeightmap)\n    {\n        sdf += 999.0;\n        float shift = 0.0;\n        for (float i = 16.0; i > 2.0; i *= 0.73)\n        {\n            sdf = SmoothMin(sdf, GetFixedHeightmapLayerSDF(coord, shift, i), 0.3 / i);\n            shift += 0.712423;\n        }\n        \n        // And blend it with heightmap, disable this to see the approximation\n        sdf = min(heightmapSDF, sdf);\n    }\n\n    \n    return sdf;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y - 0.5;\n    vec4 mouse = iMouse;\n    if (abs(iMouse.x) < 1.0)\n        mouse.x = iResolution.x * 0.5;\n        \n    uv.x += iTime * 0.1;\n    uv *= 10.0;\n    \n    if (fragCoord.x < abs(mouse.x))\n        fixHeightmap = true;\n\n    float sdf = SDFFunction(uv);\n    \n    float sdfVisuals = cos(sdf * 40.0) * 0.5 + 0.5;\n    float sdfSign = sign(sdf) * 0.5 + 0.5;\n    vec3 color = mix(vec3(0.7, 0.8, 0.9) * 0.8, vec3(0.4, 1.0, 0.4) * 0.8, sdfSign) * sdfVisuals;\n    color *= 1.0 - 1.0 / exp(abs(sdf) * 3.0);\n    \n    float pixelSize = fwidth(sdf);\n    color += smoothstep(pixelSize * 2.0, 0.0, abs(sdf)) * vec3(1.0, 0.8, 0.4);\n    \n    float verticalLine = smoothstep(2.0, 1.0, abs(fragCoord.x - abs(mouse.x)));\n    color = mix(color, vec3(1.0, 1.0, 1.0), verticalLine);// * vec3(1.0, 1.0, 1.0);\n\n    // Output to screen\n    fragColor = vec4(pow(color, vec3(2.0)),1.0);\n}","name":"Image","description":"","type":"image"}]}