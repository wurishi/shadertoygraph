{"ver":"0.1","info":{"id":"fdyXDW","date":"1634614372","viewed":136,"name":"jneen - hexel test 1","username":"jneen","description":"start by getting the coordinate system right. apparently matrix mulitplication is reversed in glsl? who knew","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["hexel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// via https://www.redblobgames.com/grids/hexagons/#pixel-to-hex\nmat2 hexel = mat2(2.,0.,-1.,sqrt(3.))/3.;\nmat2 pixel = mat2(3.,0.,sqrt(3.),2.*sqrt(3.))/2.;\n\nfloat zz = 0./0.;\n\nvec3 to_cubic(vec2 p) { return vec3(p.x,-p.x-p.y,p.y); }\nvec2 from_cubic(vec3 p) { return p.xz; }\n\n// glsl-ized from https://www.redblobgames.com/grids/hexagons/#rounding\nvec3 round_cubic(vec3 p) {\n  vec3 r = round(p);\n\n  vec3 diff = abs(r-p);\n  vec3 alt = -r.yzx-r.zxy;\n  \n  float biggest = max(diff.x,max(diff.y,diff.z));\n\n  return mix(r, alt, step(biggest, diff));\n}\n\nfloat cube_len(vec3 c) {\n  vec3 d = abs(c);\n  return (d.x+d.y+d.z)/2.;\n}\n\n#define nsin(X) (.5+.5*sin(6.283*(X)))\n\nvec3 px_to_cube(float res, vec2 p) {\n  return round_cubic(to_cubic(res * p * hexel))/res;\n}\n\nvec2 cube_to_px(vec3 c) {\n  return c.xy * pixel;\n}\n\nmat2 rot(float T){float s=sin(T),c=cos(T);return mat2(c,s,-s,c);}\n\nfloat warp(vec3 c) {\n  float F = 10.+10.*nsin(iTime*.02);//+40.*nsin(iTime*.01);\n\n  c *= F;\n\n  vec2 p = cube_to_px(c);\n  \n  p*=rot(.3*iTime);\n  vec3 c2 = px_to_cube(1., p);\n  vec3 ta = tan(c2);\n  float w = length(ta);//(ta.x+ta.y-ta.z);//(pow(tan(p.x),2.)-pow(tan(p.y),2.));\n  return .05*w*w;//1./(1.-w);\n#if 0\n  float F = 3.+30.*nsin(.1*iTime);\n  c *= F;\n  vec3 t=tan(c);\n  \n  float w = (t.x*t.x+t.y*t.y+t.z*t.z)/F;\n  return 1./(1.+w);\n  \n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -=.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    uv *= rot(.3*iTime);\n    vec3 qr = px_to_cube(50.+10.*nsin(.4*iTime),uv);\n    vec3 C = vec3(warp(qr));\n    //C = vec3(nsin(iTime*.3+qr.xy),0.);\n    fragColor = vec4(C,0.);\n}","name":"Image","description":"","type":"image"}]}