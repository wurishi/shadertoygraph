{"ver":"0.1","info":{"id":"l3sXDB","date":"1709944799","viewed":97,"name":"Dollar Store Antialiasing","username":"Data_chan","description":"A super cheap antialiaser.\nBuffer A is my halftone shader, because that produces a very aliased output.\nThere is also code for comparison on line 22. The left half of the screen is the antialiased out, right side is original.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["cheap","alntialiasing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    //parameters for antialiasing\n    float pixeloffset = float(1.0);\n    vec4 antialiasBias = vec4(0.5 ,0.5 ,0.5, 0.5);\n    \n    //go go gadget most inefficient antialiasing ever\n    //matrix that stores the images\n    mat2x3 image;\n    //horizontal\n    image[0] = vec3(mix(texture(iChannel0, vec2(((fragCoord.x+(pixeloffset*1.0))/iResolution.x) ,uv.y)).rgb, texture(iChannel0, vec2(((fragCoord.x+(pixeloffset*-1.0))/iResolution.x) ,uv.y)).rgb, antialiasBias.rrr));\n    //vertical\n    image[1] = vec3(mix(texture(iChannel0, vec2(((fragCoord.y+(pixeloffset*1.0))/iResolution.y) ,uv.x).yx).rgb, texture(iChannel0, vec2(((fragCoord.y+(pixeloffset*-1.0))/iResolution.y) ,uv.x).yx).rgb, antialiasBias.ggg));\n\n    //We overwrite the old matrix data here, but you could make a mat4x3 to keep the old data.\n    image[0] = vec3(mix(image[0], image[1], antialiasBias.bbb));\n    image[0] = vec3(mix(image[0], texture(iChannel0, uv).rgb, antialiasBias.aaa));\n    \n    //This code is for adding the un-antialiased preview. Comment it to apply antialiasing to the whole image.\n    image[0] = vec3(mix(image[0], texture(iChannel0, uv).rgb, greaterThan(uv.rr, vec2(0.5 ,0.5)).rrr));\n    \n    // Output to screen\n    fragColor = vec4(image[0], 0.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    //define desired resoltion\n    float halftoneres = float(96);\n    //pixelate our image. We do this by modifying the UV coordinates before the image is set\n    vec2 halftoneuv = vec2((trunc(uv*halftoneres*(iResolution.xy/iResolution.yy))/halftoneres/(iResolution.xy/iResolution.yy)));\n    //make our image using the pixelated UV coordinates\n    vec3 halftoneimg = vec3(texture(iChannel0, halftoneuv).xyz);\n    \n    \n    //comment this line of code to enable color\n    //halftoneimg = vec3(((halftoneimg.xx+halftoneimg.yy+halftoneimg.zz)/3.0).xxx); \n    \n    //note that we recycle the halftoneuv vector\n    //turn our UV coordinates into a lot of smaller repeating ones\n    halftoneuv = vec2(fract(uv*halftoneres*(iResolution.xy/iResolution.yy)));\n    //take the distance between our uv coordinate and the point 0.5,0.5, to get a grid of circle gradients.\n    halftoneuv = vec2(distance(halftoneuv, vec2(0.5, 0.5))*2.0);\n    //check if the color value of the image is more than the threshold set by the circle gradients\n    halftoneimg = vec3(greaterThan(halftoneimg.xyz ,halftoneuv.xxx));\n    \n    // Output to screen\n    fragColor = vec4(halftoneimg.xyz ,1.0); \n}","name":"Buffer A","description":"","type":"buffer"}]}