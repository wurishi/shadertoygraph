{"ver":"0.1","info":{"id":"wljBz1","date":"1598357907","viewed":140,"name":"the white temple","username":"danhel95","description":"following iq tutorial , using minimal stuffs of everything to learn :) ","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["simple","sdf","tutorial","temple"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// learning tutorial 2\n// thanx iq & bigWigns and others!\n// minimal temple and lightings\n\n#define ITR 50\n#define EPSILON 0.001\n#define MAX_DIST 50.0\n#define SURF_DIST 0.01\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\n//-----------------------------------------------------------------------------\nvec3 sun, sun_col;\n\nvec3 normal;\n\n//------------------------------------------------------\n\nvec2 opRepLim(in vec2 p, in float s, in vec2 lima, in vec2 limb)\n{\n    return p - s*clamp(round(p / s), lima, limb);\n}\n\n\nmat3 RX(float a) {\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(a), - sin(a),\n        0.0, sin(a), cos(a)\n    );\n}\n\nmat3 RY(float a) {\n    return mat3(\n        cos(a), 0.0, sin(a),\n        0.0, 1.0, 0.0,\n        - sin(a), 0.0, cos(a)\n    );\n}\n\nmat3 RZ(float a) {\n    return mat3(\n        cos(a), - sin(a), 0.0,\n        sin(a), cos(a), 0.0,\n        0.0, 0.0, 1.0\n    );\n}\n\n\n\nfloat smax(float a , float b, float k) {\n\n    float h = clamp((b - a) / k + 0.5, 0.0, 1.0);\n    float s = mix(a, b, h) + h*(1.0 - h) * k*0.5 ;\n    return s;\n\n}\n\n//-----------------------------------------------------------------------------\n\nfloat plane(vec3 p, vec3 n, float h)\n{\n    return dot(p, n) + h;\n}\n\nfloat box(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n\nfloat cyl(vec3 p, float r) {\n    vec3 q = p;\n\n    r -= 0.05 * q.y;\n    r -= 0.05 * pow((0.5 + 0.5 * sin(12.0 * atan(q.x, q.z))), 2.0);\n    r -= 0.1 * pow((0.5 + 0.5 * sin(2.5 * sin(3.5 * q.y))), 0.15) - 0.1;\n\n    float d = length(q.xz) - r ;\n    d = max(d, abs(q.y - .1) - 4. );\n    //d = max(d, -q.y );\n    d *= 0.7;\n    return d;\n\n}\n\n//---------------------------------------------------------------------------------\nfloat scene(vec3 p) {\n    vec3 q = p - vec3(-10.0, 1.0, -4.);\n    vec3 s = vec3(q);\n    //q.xz = mod(q.xz + 1.0 , 2.0) - 1.0;\n\n    q.xz = opRepLim(q.xz, 2.0, vec2(1.0, 1.0), vec2(8.0, 4.0));\n    vec3 qq = vec3(q.x, abs(q.y - 2.0) - 2.0, q.z);\n    float d = plane(p, vec3(0.0, 1.0, 0.0), 0.1);\n    d = min(d, cyl(q, 0.4));\n    d = min(d, box(qq, vec3(0.6, 0.1, 0.6)));\n    d = max(d, - box(s - vec3(9.0, 0.0, 5.0), vec3(6.0, 4.0, 2.0)));\n\n    vec3 f = s - vec3(0.0, - 0.1, 0.0);\n    f.y = abs(f.y- 2.)-2.2;\n    vec3 sz = vec3(0.95, 0.01, 0.95);\n    f.xz = opRepLim(f.xz, 2., vec2(1.0, 1.0), vec2(8, 4.0));\n    d = min(d, box(f, sz - 0.1) - 0.2);\n\n    vec3 g = s - vec3(-3.0, - 0.6, - 3.0);\n    vec3 gsz = vec3(1.5, 0.2, 1.5);\n    g.xz = opRepLim(g.xz, 3.0, vec2(1.0, 1.0), vec2(7.0, 4.0));\n    d = min(d, box(g, gsz - 0.2) - 0.2);\n\n    return d ;\n}\n\n//-----------------------------------------------------------------------------\n\nvec3 raydir(vec2 uv, vec3 ro, vec3 lookat, float zoom) {\n    vec3 forward = normalize(lookat - ro);\n    vec3 temp = cross(vec3(0.0, 1.0, 0.0), forward);\n    vec3 up = normalize(cross(forward, temp));\n    vec3 right = cross(up, forward);\n    vec3 screen_center = ro + forward * zoom;\n    vec3 i = screen_center + uv.x * right + uv.y * up;\n    vec3 rd = i-ro;\n    return rd;\n\n}\n\nfloat march(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    for(int i = 0; i < ITR && t < MAX_DIST; ++i)\n    {\n        float dS = scene(ro + t*rd);\n        if (abs(dS) < SURF_DIST )break;\n        t += dS;\n    }\n        return  t ;\n    }\n\n\nvec3 grad(vec3 p) {\n    vec2 e = vec2(EPSILON, 0.0);\n    return (vec3(scene(p + e.xyy), scene(p + e.yxy), scene(p + e.yyx)) - scene(p)) / e.x;\n}\n\n//------------------------------------------------\n\n\n\n\nvoid luminance(inout vec3 col, float lum)\n{\n\tlum /= \tdot(col.rgb,vec3(0.2126 , 0.7152  ,0.0722) );\n\tcol *= lum;\n}\n\n\nfloat shadow(vec3 ro, vec3 rd, vec3 l_pos)\n{\n    float res = 1.;\n    float d = march(ro+100.*normal*SURF_DIST, rd);\n    vec3 p = ro + d*rd;\n    float dl = length(l_pos - p );\n    if (d < dl)\n        res = 0.;\n    float r = 10.;\n \tres = clamp((res*d*(d - dl)/(d + dl) + r) / (2. * r), 0., 1.);\n\tres = smoothstep(0., .8, res);\n\n    return res;\n}\n\n\nvec3 light(vec3 p, vec3 l_pos, vec3 color, bool nrf) {\n    vec3 ptol = l_pos - p;\n    vec3 ptol_n = normalize(ptol);\n    float d = length(ptol);\n    float difuse = max(dot(ptol_n, normal), 0.1);\n    vec3 difuse_col = pow(difuse/(d*d) , .5) * color;\n    float shadow = shadow(p, ptol_n, l_pos);\n    vec3 col = difuse_col  ;\n    if (nrf) col *= shadow;\n\n\n    return   col;\n\n\n\n}\n\n\nvec3 reflection(vec3 p, vec3 rd ) {\n\n    vec3 reflectDir = normalize(reflect(rd, normal));\n    vec3 o = p + reflectDir * SURF_DIST *10.;\n    float t = march( o , reflectDir);\n    vec3 pt = o + t*reflectDir;\n    vec3 reflected = light(pt,sun, vec3(1.,.0,.0),false ) ;\n\n    return reflected;\n\n}\n\n\n\nvec3 render(vec3 ro , vec3 rd) {\n\n    float t = march( ro , rd);\n    vec3 p = ro + t*rd;\n    normal = normalize(grad(p));\n    luminance(sun_col,3.);\n    vec3 specul = light(p, sun, sun_col,true);\n    specul += light(p, sun-vec3(1.,3.,-2.), sun_col*.5,true);\n    vec3 reflected = reflection(p,rd);\n\n    vec3 col = vec3(.0);\n    float spec = pow( max( normal.y, normal.z ), 2.);\n    col = mix((reflected), vec3(specul), .6 ) + spec*.3 ;\n    col += mix(col ,reflected, .8 );\n\n    return col ;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n\n   sun = vec3(5., 8. + m.y + sin(iTime * 0.3 * TWO_PI ) * 3.0, 5.0);\n   sun_col = vec3(1.0, .6, 0.2) * 10.0;\n\n    vec3 col = vec3(0);\n    float t = iTime;\n    float ang = sin(0.2 * t*PI + TWO_PI*m.x) * .5;\n    vec3 camR = vec3( sin(ang + m.x), 0. , cos(ang+ m.y));\n    vec3 ro = vec3(-10.0, 10.0, 15.0) + camR;\n    ro *= RX(-m.x*PI/4. + 0.4);\n    ro *= RY(- m.y * 6.2831);\n    vec3 lookat = vec3(0.0);\n    float zoom = 1.;\n    vec3 rd = raydir(uv, ro, lookat, zoom);\n\n    col = render(ro, rd);\n\n    col = pow(col, vec3(0.4545)); // gamma correction\n    fragColor = vec4(col, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}