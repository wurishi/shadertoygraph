{"ver":"0.1","info":{"id":"MfySRd","date":"1716049329","viewed":90,"name":"bezier sdf derivation","username":"letbonsaibe","description":"learn about https://www.shadertoy.com/view/MdXBzB\n\nAs someone who hasn't touched math in 12 years, this proof process is too hard to understand.\n\nI finnaly managed to write out the entire derivation \nhttps://github.com/OhBonsai/art/wiki/Bezier-Curve-SDF-D","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sdfbezierderivation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Solve cubic equation for roots\n// Additionally: returns number of roots\nvec4 solveCubic(float a2, float a1, float a0)\n//vec4 solveCubic(float a, float b, float c)\n{\n    // take the second derivative and shift to zero location\n    // (change of variables) to eliminate the quadratic term.\n    float offset = -a2 / 3.0;\n\n    // linear coefficient\n    float p = a1 - a2*a2 / 3.0, p3 = p*p*p;\n    // constant coefficient\n    float q = a2 * (2.0*a2*a2 - 9.0*a1) / 27.0 + a0;\n    \n    \n    // Cardano's discriminant\n    float d = (q/2.0)*(q/2.0) + (p/3.0)*(p/3.0)*(p/3.0);\n      \n\n    // one root\n    if(d >= 0.) {\n        float z = 2.0 * sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec4(vec3(offset + uv.x + uv.y), 1.0);\n    }\n    \n    // three root\n    // using Triple Angle Formula\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0; \n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec4(vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset, 3.0);\n}\n\n\nvec2 sd_bezier(vec2 A, vec2 B, vec2 C, vec2 p) {\n    // ensure the points A,B,C are not collinear\n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n\n    vec2 a = B - A, \n         b = A - B * 2.0 + C, \n         c = a * 2.0, \n         d = A - p;\n    \n    float a2 = ( 3.*dot(a,b)          ) / dot(b,b);\n    float a1 = ( 2.*dot(a,a)+dot(d,b) ) / dot(b,b);\n    float a0 = ( dot(d,a)             ) / dot(b,b);\n    \n    vec4 t = solveCubic(a2, a1, a0);\n    float t0 = t.x;\n    float t1 = t.y;\n    // t3 is impossible be minium root that we derive in wiki\n    float t3 = t.z; \n    float rootCount = t.w;\n    \n    // using f(t) equalation\n    vec2 dp1 = d + (c + b*t0)*t0;\n    float d1 = dot(dp1, dp1);\n    vec2 dp2 = d + (c + b*t1)*t1;\n    float d2 = dot(dp2, dp2);\n    vec2 dp3 = d + (c + b*t3)*t1;\n    float d3 = dot(dp3, dp3);\n    \n    \n    // find closest distance and t\n    vec4 r = (d1 < d2) ? vec4(d1, t.x, dp1) : vec4(d2, t.y, dp2);\n\n\n    // sign is just cross product with gradient\n    // gradient is f'(t)=g(t)\n    vec2 g = 2.*b*r.y + c;\n    float s =  sign(g.x*r.w - g.y*r.z);\n\n    return vec2(s*sqrt(r.x), r.y);\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    vec2 m = vec2(cos(iTime * 1.2) * 0.8, 0.0);\n\n    vec2 A = vec2(0.0, -0.6), C = vec2(0.0, +0.6), B = vec2(-0.8, +0.6);\n    vec3 color = vec3(0.0);\n    \n\n\n    vec2 r = sd_bezier(A, B, C, p);\n    float d = r.x;\n    \n    // iq sdf color platte\n    color += vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n    color *= (1.0 - exp(-4.0*abs(d))) * (0.8 + 0.2*cos(140.*d));\n    color = mix(color, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}