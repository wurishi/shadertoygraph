{"ver":"0.1","info":{"id":"DdKBzK","date":"1698442015","viewed":78,"name":"hexagontiles UPALMUCHA","username":"upalmucha","description":"trying to imitate kanding ray's clip","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["hexagons"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159\n\nfloat hash( in ivec2 p )  // this hash is not production ready, please\n{                         // replace this by something better\n\n    // 2D -> 1D\n    int n = p.x*3 + p.y*113;\n\n    // 1D hash by Hugo Elias\n\tn = (n << 13) ^ n;\n    n = n * (n * n * 15731 + 789221) + 1376312589;\n    return -1.0+2.0*float( n & 0x0fffffff)/float(0x0fffffff);\n}\n\n\nfloat noise( in vec2 p )\n{\n\n    ivec2 i = ivec2(floor( p ));\n\n\n    vec2 f = fract( p );\n\t\n\n    vec2 u = f*f*(3.0-2.0*f);\n  \n    return mix( mix( hash( i + ivec2(0,0) ), \n                     hash( i + ivec2(1,0) ), u.x),\n                mix( hash( i + ivec2(0,1) ), \n                     hash( i + ivec2(1,1) ), u.x), u.y);\n\n}\n\nfloat fractalnoise(vec2 uv)\n{\n\tfloat f = 0.0;\n\n\tuv *= 2.0;\n    uv.y += iTime*0.2;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tf  = 0.5000*noise( uv ); uv = m*uv;\n\tf += 0.2500*noise( uv ); uv = m*uv;\n\tf += 0.1250*noise( uv ); uv = m*uv;\n\tf += 0.0625*noise( uv ); uv = m*uv;\n\t\n\tf = 0.5 + 0.5*f;\n    f *= smoothstep( 0.0, 0.005, abs(uv.x-0.6) );\n    return fract(f*sin(iTime*0.2)*40.);\n}\nfloat fractalnoise2(vec2 uv)\n{\n\tfloat f = 0.0;\n\n\tuv *= 2.0;\n    uv.y += iTime*0.2;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tf  = 0.5000*noise( uv ); uv = m*uv;\n\tf += 0.2500*noise( uv ); uv = m*uv;\n\tf += 0.1250*noise( uv ); uv = m*uv;\n\tf += 0.0625*noise( uv ); uv = m*uv;\n\t\n//\tf = 0.5 + 0.5*f;\n   // f *= smoothstep( 0.0, 0.005, abs(uv.x-0.6) );\n    return f;\n}\n\n\n// convert distance to alpha\nfloat dtoa(float d, float amount)\n{\n    float a = clamp(1.0 / (clamp(d, 1.0/amount, 1.0)*amount), 0.,1.);\n    return a;\n}\n\nvec2 Swirl(vec2 uv, float angle, float radius, vec2 center)\n{\n    float effectRadius = radius;\n    float effectAngle = angle * PI;\n    float len = length(abs(fractalnoise(uv)));\n    angle = atan(uv.y, uv.x) + effectAngle * smoothstep(effectRadius, 0., len);\n    radius = length(uv);\n    return vec2(radius * cos(angle), radius * sin(angle)) + center;\n}\n\n\nvec4 hexCoords (vec2 uv)\n{\n    vec2 ratio = vec2(1.,1.73);\n    vec2 halfRatio = ratio*0.5;\n    vec2 gridA = mod(uv, ratio)-halfRatio;\n    vec2 gridB = mod(uv - halfRatio, ratio)-halfRatio;\n    \n    vec2 gv;\n    if(length(gridA)<length(gridB))\n        gv = gridA;\n    else\n        gv = gridB;\n    return vec4(gv.x, gv.y, 0., 0.);\n\n}\n\n\nfloat circle (vec2 uv, vec2 p, float radius)\n{\n    float d = length(uv-p);\n    return smoothstep(d,d+0.01,radius);\n\n}\n\nfloat hexD (vec2 p, float size)\n{\n    p = abs(p);\n\n    float c = dot(p,normalize(vec2(1.,1.73)));\n    c = max(c, (p.x));\n    return c - size;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    \n    float time = 12.*(iTime+(sin(iTime*12.)/24.));\n    \n    vec2 uv3 = Swirl(uv, fractalnoise(vec2(uv.x,uv.y+time/12.))*(2.*sin(iTime*6.)/12.), fractalnoise(uv)*1.5, vec2(0)); \n\n    uv = mix(uv, uv3, step(0.0,fractalnoise2(vec2(uv.x,uv.y+time/12.))));\n    //calc vignette on fresh uvs\n    vec2 viguv = fragCoord.xy / iResolution.xy;  \n    viguv *=  1.0 - viguv.yx;   //vec2(1.0)- uv.yx; -> 1.-u.yx; Thanks FabriceNeyret !\n    float vig = viguv.x*viguv.y * 15.0; // multiply with sth for intensity \n    vig = pow(vig, 0.25); // change pow for modifying the extend of the  vignette\n    \n    \n    vec2 uv2 = uv;\n    \n    uv *= vec2(1.5,3.);\n    uv.x *= (uv.y/3.) + iResolution.x/iResolution.y;\n    uv.y += time*0.2;\n\n    vec2 gv = hexCoords(uv).xy;\n    \n\n\n   // vec3 col = vec3(gv,0.1);\n    vec3 col = vec3(dtoa(hexD(gv, 0.46),40.));\n    float circles = 1.-circle(gv, vec2(0.3), 0.02) - circle(gv, vec2(-0.3), 0.02) - circle(gv, vec2(0.3,-0.3), 0.02) - circle(gv, vec2(-0.3,0.3), 0.02);\n    col -= vec3(dtoa(circles,20.));\n\n    \n    //texture\n    col *= 1. - texture(iChannel0, gv).r * 0.2;\n    \n    // vignette and shade\n    col -= uv2.y + .5;\n    col -= 1. - vig;\n   \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}