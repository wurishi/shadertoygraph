{"ver":"0.1","info":{"id":"XfVczK","date":"1732114689","viewed":98,"name":"Bouncy Bounce Beach 🏖️🌞🏐","username":"chronos","description":"Bouncy!","likes":15,"published":1,"flags":32,"usePreview":0,"tags":["2d","collision","deformation","ball","bounce","physics","bouncy","summer","beach"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Bouncy Bounce Beach 🏖️🌞🏐 by chronos\n    ---------------------------------------------------\n\n    Bouncy!\n    \n    (Mouse interactive! 🙂)\n\n    ---------------------------------------------------\n    self link: https://www.shadertoy.com/view/XfVczK\n*/\n\nfloat smax(float a, float b, float k)\n{\n    return log(exp(a*k) + exp(b*k))/k; \n}\n\nfloat seg(vec2 a, vec2 b, vec2 p)\n{\n    b-=a; p-=a;\n    return length(clamp(dot(p, b)/dot(b,b), 0. , 1.) * b - p);\n}\n\nfloat halfdisc(vec2 c, vec2 dir, float r, vec2 p)\n{\n    float sdf = length(c-p)-r;\n    dir = normalize(dir);\n    float proj = dot(p-c, dir);\n    if(length(p - (c + proj*dir)) <= r+0.1) sdf = max(sdf, proj);\n    return sdf;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv    = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 mouse = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n\n    float ps = 2. / iResolution.y;\n    \n    vec2 refl_offset = mat2(1,1,-1,1)*sqrt(1./2.)*(uv-vec2(0.85,-.25))*vec2(1.8,.8);\n    float wave_offset = texture(iChannel2, fragCoord.xy/512.).r;\n    float waves = (sin(3.14159265*(wave_offset + uv.y*20.) + 0.8*cos(iTime+(uv.x-1.)*20. * .33 / (+.25-uv.y)))*.125+.5);\n    vec3 color = mix(\n        mix(\n            \n            vec3(0.4, .3,0.1) * (1. + exp(-3. * dot(refl_offset,refl_offset)) )+ exp(-3. * dot(refl_offset,refl_offset))*.1, \n            vec3(0.05, 0.4, 0.8) + \n                (exp(-3. * dot(refl_offset,refl_offset)) + 0.25*exp(-.3 * dot(refl_offset,refl_offset))) * \n                mix(pow(waves, 3.), 1., 0.35)\n                ,\n            smoothstep(-0.75, -0.7, uv.y+cos(1.5*uv.x-.75)*.05+cos(10.5*uv.x-.75)*.005)\n            ),\n        vec3(0.1, 0.3, 0.7), \n        smoothstep(-0.025, 0.025, uv.y)\n        );\n        \n    // Sky sun-scattering\n    color += 0.5*exp(-3. * dot(uv-vec2(1), uv-vec2(1)));\n\n    // Clouds, lol\n    vec2 cloud_uv = vec2(-.5, -.25)+.4*uv*vec2(1.2,3) + .025*vec2(0, sin(iTime*.4+uv.x*5.) + .25*cos(.1+iTime+uv.x*20.));\n    color = mix(color, vec3(1.), 0.13*smoothstep(0.1, -0.1, halfdisc(vec2(-1,.3), vec2(0,-1), 0.35, cloud_uv)));\n    color = mix(color, vec3(1.), 0.17*smoothstep(0.1, -0.1, halfdisc(vec2(-1.2,.5), vec2(0.2,-1), 0.35, cloud_uv)));\n    color = mix(color, vec3(1.), 0.15*smoothstep(0.1, -0.1, halfdisc(vec2(-.8,.4), vec2(0.3,-1), 0.35, cloud_uv)));\n\n    // parasol\n    vec2 parasol_pos = vec2(-1.5, -.25);\n    vec2 parasol_dir = vec2(1,-2);\n    float parasol_pattern = smoothstep(0.15, 0.15, sin(20. * dot(uv-parasol_pos, parasol_dir)));\n    color = mix(color, vec3(0.5)*max(dot(uv-parasol_pos, parasol_dir.yx*vec2(-1,1))+.5, 0.), smoothstep(ps, -ps, seg(parasol_pos, parasol_pos+parasol_dir*.365, uv)-0.03));\n    color = mix(color,\n        mix(vec3(0.85), vec3(0.95,0.25,0.35), parasol_pattern)\n        *max(dot(uv-parasol_pos, parasol_dir.yx*vec2(-1,1))+.85, 0.)\n    , smoothstep(ps, -ps, halfdisc(parasol_pos, vec2(1,-2), 0.6, uv)));\n\n    vec4 pos_vel = texelFetch(iChannel0, ivec2(0), 0);\n\n    vec2 pos = pos_vel.xy;\n    vec2 vel = pos_vel.zw;\n\n    float rot = texelFetch(iChannel0, ivec2(0), 0).r;\n\n    \n    vec2 peg_pos = get_peg_pos(mouse, iMouse.xy, iTime);\n\n    vec3 ball_color = vec3(1);\n    vec2 ball_offset = uv-pos;\n\n    float C = cos(rot), S = sin(rot);\n    mat2 R = mat2(C, S, -S, C);\n    vec2 spoke_dir = R * ball_offset;\n    \n    float spokes = 1.-(smoothstep(0.1, 0.2, cos(10. * atan(spoke_dir.y, spoke_dir.x)))*.75+.25);\n    ball_color = mix(ball_color, vec3(0,0,1), spokes);\n    \n    float ball_sdf = length(uv-pos)-radius;\n    float peg_sdf = length(uv-peg_pos)-peg_radius;\n    \n    float pre_dent_sdf = ball_sdf;\n    \n    ball_sdf = smax(ball_sdf, -peg_sdf, 10.);\n    \n    float r_scaling = max(1.+ pre_dent_sdf - ball_sdf, 0.000001);\n    float scaled_radius = radius * r_scaling;\n    \n    float ball_offset_len = length(ball_offset);\n    \n    vec3 ball_normal = normalize(vec3(ball_offset/r_scaling, sqrt(max(scaled_radius*scaled_radius - dot(ball_offset, ball_offset), 0.))));\n    \n    vec3 L = normalize(vec3((vec2(1,1)-pos),0));\n    float NdotL = max(dot(ball_normal, vec3(0,1,1)+L), 0.);\n    float rim_light = smoothstep(0.3, 1., length(uv - pos - 0.2*normalize(pos-vec2(1)))/(.95+radius));\n    color = mix(color, mix(NdotL*.25+.35, 1., 0.1)*ball_color+rim_light, smoothstep(ps, -ps, ball_sdf));\n    \n    color = mix(color, vec3(0.5)*(1.-.5*smoothstep(-.1, 0.04, peg_sdf-0.075)), .75*smoothstep(ps, -ps, peg_sdf-0.075));\n    color = mix(color, vec3(0), .85*smoothstep(ps, -ps, peg_sdf+0.04));\n    color = mix(color, vec3(1), .85*smoothstep(ps, -ps, peg_sdf+0.05));\n\n    float sun_block = smoothstep(0., .35, length(pos-vec2(1))-radius);\n    color += 1.5*exp(-3. * dot(uv-vec2(1), uv-vec2(1)) / (.125+sun_block))*sun_block;\n    \n    color *= 1.-length(uv)*.1;\n\n    color = tanh(color);\n    fragColor = vec4(pow(color, vec3(1./2.2)) + texture(iChannel1, fragCoord.xy/1024.).rgb*(1./256.), 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(ivec2(fragCoord).y != 0 || ivec2(fragCoord).x > 1) return;\n\n    vec2 pos = ball_init_pos;\n    vec2 vel = vec2(0);\n    \n    float rotation = 0.;\n\n    if(iFrame == 0)\n    {\n        fragColor = vec4(pos, vel);\n        return;\n    }\n\n    vec2 mouse = (2. * iMouse.xy - iResolution.xy)/iResolution.y;\n\n    vec4 bufA = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    pos = bufA.xy;\n    vel = bufA.zw;\n\n    vec2 peg_pos = get_peg_pos(mouse, iMouse.xy, iTime);\n\n    vec2 normal = normalize(pos-peg_pos);\n\n    float proj_vel = dot(vel, normal);\n    vec2 rej_vel  = vel - dot(vel, normal) * normal;\n\n    float penetration = length(pos-peg_pos) - radius - peg_radius;\n    if(penetration < 0.)\n    {\n        pos += (pos-peg_pos) / length(pos - peg_pos) * (-penetration);\n        vel = max(proj_vel, 0.) * normal + rej_vel;\n    }\n    \n    vec2 force = 0.075 * smoothstep(radius+peg_radius + 0.0001, radius+peg_radius, length(pos-peg_pos)) * ((pos-peg_pos) / length(pos-peg_pos));\n    \n    float gravity = 0.0025;\n    \n    force.y -= gravity;\n    \n    vec2 accel = force;\n    \n    vel += accel;\n    pos += 0.5*vel;\n    \n    penetration = length(pos-peg_pos) - radius - peg_radius;\n    if(penetration <= 0.)\n    {\n        pos += (pos-peg_pos) / length(pos - peg_pos) * (-penetration);\n        vel = max(proj_vel, 0.) * normal + rej_vel;\n    }\n    \n    if(pos.y < -10.) { pos = ball_init_pos; vel = vec2(0); }\n    \n    if(ivec2(fragCoord).x == 0)\n        fragColor = vec4(pos, vel);\n    else\n        fragColor = vec4(rotation, 0, 0, 0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"float radius = 0.5;\nfloat peg_radius = 0.1;\n\nvec2 default_peg_pos = vec2(0, -0.5);\nvec2 ball_init_pos = vec2(0.045, 1.5);\n\n\nvec2 get_peg_pos(vec2 mouse_uv, vec2 mouse_xy, float time)\n{\n    vec2 peg_pos = default_peg_pos;\n    peg_pos.x += sin(time*.5)*.5;\n    peg_pos.y += cos(time*2.)*.25;\n    peg_pos = length(mouse_xy) > 10. ? mouse_uv : peg_pos;\n    return peg_pos;\n}","name":"Common","description":"","type":"common"}]}