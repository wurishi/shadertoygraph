{"ver":"0.1","info":{"id":"MfKSRm","date":"1715010639","viewed":47,"name":"Randomness Playground","username":"Bactus","description":"Learning how to use randomness with shaders","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["playground"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec2[] grads = vec2[3](\nvec2(1.0, 0.0), vec2(1.0),\nvec2(0.0, 1.0)\n);\n\nfloat rand(float seed) { return fract(sin(seed * 91.8294) * 47453.5453); }\nfloat rand(vec2 seed) { return fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453); }\nvec2 rand2(vec2 seed)\n{\n    seed = vec2(dot(seed, vec2(127.1, 311.7)),\n                dot(seed, vec2(269.5, 183.3)));\n    return 2.0 * fract(sin(seed) * 43758.5453123) - 1.0;\n}\nvec2 randomGradient(vec2 seed)\n{\n    int i = int(floor(rand(seed) * float(grads.length())));\n    return grads[i];\n}\n\n\n\nfloat smooth1(float t) { return t*t*(3.0-2.0*t); }\nfloat smooth2(float t) { return t*t*(2.0-t*t); }\nfloat smooth3(float t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }\n\nvec2 smooth1(vec2 t) { return t*t*(3.0-2.0*t); }\nvec2 smooth2(vec2 t) { return t*t*(2.0-t*t); }\nvec2 smooth3(vec2 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }\n\nvec2 skew(vec2 pos)\n{\n    return pos + vec2((pos.x + pos.y) * (sqrt(2.0) - 1.0) / 2.0);\n}\n\nfloat valueNoise2D(vec2 pos, float scale)\n{\n    vec2 i = floor(pos * scale);\n    vec2 f = fract(pos * scale);\n    \n    vec2 u = smooth1(f);\n    \n    float p0 = rand(i);                   // 3---2\n    float p1 = rand(i + vec2(1.0, 0.0));  // |   |\n    float p2 = rand(i + vec2(1.0));       // 0---1\n    float p3 = rand(i + vec2(0.0, 1.0));\n    \n    float top = mix(p3, p2, u.x);\n    float bot = mix(p0, p1, u.x);\n    return mix(bot, top, u.y);\n}\n\nfloat gradientNoise2D(vec2 pos, float scale)\n{\n    vec2 i = floor(pos * scale);\n    vec2 f = fract(pos * scale);\n    \n    vec2 u = smooth3(f);\n    \n    vec2 a = i + vec2(0.0);\n    vec2 b = i + vec2(1.0, 0.0);\n    vec2 c = i + vec2(1.0);\n    vec2 d = i + vec2(0.0, 1.0);\n    \n    float bot = mix(dot(rand2(a), f - vec2(0.0)), dot(rand2(b), f - vec2(1.0, 0.0)), u.x);\n    float top = mix(dot(rand2(d), f - vec2(0.0, 1.0)), dot(rand2(c), f - vec2(1.0)), u.x);\n    \n    return mix(bot, top, u.y);\n}\nfloat gradientNoise2D_v2(vec2 pos, float scale)\n{\n    //pos = vec2(pos.x + pos.y * 0.5, pos.y);\n    vec2 i = floor(pos * scale);\n    vec2 f = fract(pos * scale);\n    \n    //f = vec2(mix(f.x+0.5*mod(i.y, 2.0), f.x+0.5*mod(i.y+1.0, 2.0), f.y), f.y);\n    \n    vec2 u = smooth3(f);\n    \n    vec2 a;\n    vec2 b;\n    vec2 c;\n    \n    float v1;\n    float v2;\n    float v3;\n    \n    if (f.x < f.y)\n    {\n        //a = vec2(0.5 * mod(i.y, 2.0), 0.0);\n        //b = a + vec2(1.0, 0.0);\n        //c = a + vec2(0.5, 1.0);\n        \n\n        a = vec2(0.0);\n        b = vec2(1.0, 1.0);\n        c = vec2(0.0, 1.0);\n        v1 = dot(rand2(a + i), f - a);\n        v2 = dot(rand2(b + i), f - b);\n        v3 = dot(rand2(c + i), f - c);\n    }\n    else\n    {\n        //a = vec2(0.5 * mod(i.y, 2.0), 0.0);\n        //b = a + vec2(0.5, 1.0);\n        //c = a + vec2(-0.5, 1.0);\n    \n        a = vec2(0.0);\n        c = vec2(1.0, 0.0);\n        b = vec2(1.0, 1.0);\n        v1 = dot(rand2(a + i), f - a);\n        v2 = dot(rand2(b + i), f - b);\n        v3 = dot(rand2(c + i), f - c);\n    }\n    \n    //v1 = 1.0;\n    //v2 = 0.0;\n    //v3 = 0.0;\n    \n    // Triangle interpolation:\n    //float denominator = (b.y-c.y)*(a.x-c.x)+(c.x-b.x)*(a.y-c.y);\n    //float w1 = ((b.y - c.y)*(f.x - c.x) + (c.x - b.x)*(f.y - c.y)) / denominator;\n    //float w2 = ((c.y - a.y)*(f.x - c.x) + (a.x - c.x)*(f.y - c.y)) / denominator;\n    \n    float w1 = length(f - a);\n    float w2 = length(f - b);\n    float w3 = length(f - c);\n    \n    \n    if(w1 < 0.0)\n        return 1.0;\n    if(w2<0.0)\n        return 1.0;\n    if(w3<0.0)\n        return 1.0;\n    \n    return v1*w1 + v2*w2 + v3*w3;\n}\n\nfloat simplexNoise2D(vec2 pos, float scale)\n{\n    vec2 unskewed = pos;\n    vec2 us_i = floor(pos);\n    vec2 us_f = pos - us_i;\n    \n    pos = skew(pos * scale);\n    vec2 i = floor(pos);\n    vec2 f = pos - i;\n    \n    vec2 a = vec2(0.0);\n    vec2 b;\n    vec2 c = vec2(1.0);\n    \n    \n    if (f.x > f.y)\n    {\n        b = vec2(1.0, 0.0);\n    }\n    else\n    {\n        b = vec2(0.0, 1.0);\n    }\n    \n    //float v1 = rand(a + i); //dot(rand2(a + i), f - a);\n    //float v2 = rand(b + i);//dot(rand2(b + i), f - b);\n    //float v3 = rand(c + i);//dot(rand2(c + i), f - c);\n    \n    vec3 v = vec3(\n    dot((rand2(a + i)), normalize(f - a)),\n    dot((rand2(b + i)), normalize(f - b)),\n    dot((rand2(c + i)), normalize(f - c))\n    );\n    \n    //v = v * 0.5 + 0.5;\n    \n    //float v1 = dot(normalize(randomGradient(a + i)), normalize(f - a));\n    //float v2 = dot(normalize(randomGradient(b + i)), normalize(f - b));\n    //float v3 = dot(normalize(randomGradient(c + i)), normalize(f - c));\n\n    \n    \n    // Triangle interpolation:\n    float denominator = (b.y-c.y)*(a.x-c.x)+(c.x-b.x)*(a.y-c.y);\n    float w1 = ((b.y - c.y)*(f.x - c.x) + (c.x - b.x)*(f.y - c.y)) / denominator;\n    float w2 = ((c.y - a.y)*(f.x - c.x) + (a.x - c.x)*(f.y - c.y)) / denominator;\n    float w3 = 1.0 - w2 - w1;\n    \n    // dot(a, a) returns |a|^2\n    vec3 m = max(0.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), 0.0);\n    m = m*m;\n    m = m*m;\n    \n    return v.x*w1 + v.y*w2 + v.z*w3;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(simplexNoise2D(uv, 10.0 + iTime));// * 0.5 + 0.5);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}