{"ver":"0.1","info":{"id":"WtsyDX","date":"1593285247","viewed":254,"name":"Refractive Ball","username":"akoylasar","description":"A ray traced refractive ball.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["refraction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 2019-2019 Fouad Valadbeigi (akoylasar@gmail.com).\n// Mind the code it's not exactly optimal. \n\n// Constants\n#define PI 3.1415926535\n#define TWO_PI 6.2831853071\n\n// Shadertoy only settings.\n#define ANIMATE_CAMERA 1\n#define USE_MOUSE 1\n#define CAMERA_DISTANCE 8.0\n#define SPEED_MULTIPLIER 0.2\n#define ANIMATE_LIGHTS 1\n\n// Global constants.\n#define TFAR 1e7\n#define WORLD_UP vec3(0.0, 1.0, 0.0)\n#define NUM_LIGHTS 2\n\n// Camera parameters.\nvec3 uCameraOrigin = vec3(0.0, 5.5, 10.0);\nvec3 kCameraTarget = vec3(0.0, 1.5, 0.0);\n\n// Light parameters.\nvec3 uAmbientLight = vec3(0.1);\nvec3 uLightPos[NUM_LIGHTS] = vec3[](\n    vec3(8.0, 8.0, -8.0),\n    vec3(-8.0, 8.0, -8.0)\n);\nvec3 uLightRadiance[NUM_LIGHTS] = vec3[](\n    vec3(1.4),\n    vec3(0.5)\n);\n\n// Shadow parameters.\nfloat uShadowFactor = 0.0;\n\n// Ball parameters.\nvec4 uBall = vec4(0.0, 2.5, 0.0, 2.5); // position, raidus.\nfloat uBallIor = 1.25; // Index of refraction.\n\n// Floor parameters.\nvec3 uFloor = vec3(15.0, 15.0, 0.0); // width, height, y offset.\nvec3 kFloorNormal = vec3(0.0, 1.0, 0.0);\n\n \nvec4 intersectWithSphere(in vec3 rayOrigin, in vec3 rayDirection, vec4 sphere)\n{\n    vec3 oc = rayOrigin - sphere.xyz;\n    float b = dot(oc, rayDirection);\n    float c = dot(oc, oc) - sphere.w * sphere.w;\n    float d = b * b - c;\n    if (d < 0.0)\n        return vec4(-1.0);\n    float t = -b - sqrt(d);\n    float normalDirection = 1.0;\n    if (t < 0.0)\n    {\n        t = -b + sqrt(d);\n        normalDirection = -1.0;\n    }\n    vec3 hitPoint = rayOrigin + t * rayDirection;\n    vec3 normal = normalize(hitPoint - sphere.xyz);\n    return vec4(normalDirection * normal, t);\n}\n\nvec4 intersectWithBall(in vec3 rayOrigin, in vec3 rayDirection)\n{\n    return intersectWithSphere(rayOrigin, rayDirection, uBall);\n}\n\nvec4 intersectWithFloor(in vec3 rayOrigin, in vec3 rayDirection)\n{\n  \t// TODO: Could be simplified.\n  \tfloat t = (uFloor.z - rayOrigin.y) / rayDirection.y;\n    vec3 hitPoint = rayOrigin + t * rayDirection;\n    vec2 s = sign(uFloor.xy - abs(hitPoint.xz));\n    vec2 uv = (hitPoint.xz - uFloor.xy) / uFloor.xy;\n    return vec4(uv, min(t, min(s.x, s.y)), t);\n}\n\nmat3 lookAt(in vec3 target, in vec3 origin)\n{\n    vec3 w = normalize(target - origin);\n    vec3 u = normalize(cross(w, WORLD_UP));\n    vec3 v = cross(u, w);\n    return mat3(u, v, w);\n}\n\nvec3 shade(in vec3 hitPos,  in vec3 normal, in vec3 diffuse)\n{\n    vec3 radiance = vec3(0.0);\n    \n    for (int i = 0; i < NUM_LIGHTS; ++i)\n    {\n#if ANIMATE_LIGHTS\n        vec3 lightiPos = uLightPos[i];\n        float r = length(lightiPos.xz);\n        float a = float(i) * PI * 0.5;\n      \tfloat c = r * cos(iTime + a);\n      \tfloat s = r * sin(iTime + a);\n      \tlightiPos = vec3(c, lightiPos.y, s);\n        vec3 l = lightiPos - hitPos;\n#else\n        vec3 l = uLightPos[i] - hitPos;\n#endif\n        vec3 dir = normalize(l);\n        float len = length(l);\n        \n        // Calculate shadows.\n        vec4 rec0 = intersectWithBall(hitPos, dir);\n        float shadow = rec0.w < 0.0 ? 1.0 : uShadowFactor;\n\n        // Add ambient term.\n        radiance += diffuse * uAmbientLight / float(NUM_LIGHTS);\n        // Light intesity inversely proportaional to its distance squared. \n        vec3 lightIntensity = uLightRadiance[i] / len * len;\n        // Add diffuse term.\n        radiance += diffuse * lightIntensity * max(dot(normal, dir), 0.0) * shadow;\n    \t//TODO: Specular.\n    }\n\n    return radiance;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n#if ANIMATE_CAMERA\n    float c = cos(mouse.x + SPEED_MULTIPLIER * iTime);\n    float s = sin(mouse.x + SPEED_MULTIPLIER * iTime);\n    uCameraOrigin = vec3(c * CAMERA_DISTANCE, uCameraOrigin.y, s * CAMERA_DISTANCE);\n#endif\n#if USE_MOUSE\n    uCameraOrigin.y = 16.0 * sin(mouse.y);\n#endif\n    mat3 viewMat = lookAt(kCameraTarget, uCameraOrigin);\n    vec3 rayOrigin = uCameraOrigin;\n    vec3 rayDirection = viewMat * normalize(vec3(p, 1.8));\n    \n    vec3 col = vec3(0.0);\n    float tmin = TFAR;\n\n    vec4 rec0 = intersectWithFloor(rayOrigin, rayDirection);\n    if (rec0.z > 0.0)\n    {\n        // Update tmin value.\n        tmin = rec0.w;\n        vec3 hitPos = rayOrigin + tmin * rayDirection;\n        // Get the color of the floor based on it's uv coordinates.\n        col = shade(hitPos, kFloorNormal, texture(iChannel0, rec0.xy).xyz); \n    }\n    vec4 rec1 = intersectWithBall(rayOrigin, rayDirection);\n    // If we hit the crystal ball refraction happens.\n    if (rec1.w > 0.0 && rec1.w < tmin)\n    {\n        tmin = rec1.w;\n\n        vec3 hitPos = rayOrigin + tmin * rayDirection;\n\n        vec3 normal = rec1.xyz;\n        vec3 newPos = hitPos;\n        \n        // Intersect with the ball again.\n        vec3 refractRayIn = refract(rayDirection, normal, 1.0 / uBallIor);\n        vec4 rec2 = intersectWithBall(newPos + 0.001 * refractRayIn, refractRayIn);\n        \n        normal = rec2.xyz;\n        newPos = newPos + rec2.w * refractRayIn;\n       \n        // Intersect the floor with the refracted ray.\n        vec3 refractRayOut = refract(refractRayIn, normal, uBallIor);\n        vec4 rec3 = intersectWithFloor(newPos, refractRayOut);\n    \n        normal = kFloorNormal;\n        newPos = newPos + rec3.w * refractRayOut;\n        if (rec3.z > 0.0)\n          \tcol = shade(newPos, normal, texture(iChannel0, rec3.xy).xyz);\n        else\n            col = texture(iChannel1, refractRayOut).xyz;        \n    }\n\n    // Environment color if no hit.\n    if (tmin >= TFAR)\n        col = texture(iChannel1, rayDirection).xyz;\n    \n    fragColor = vec4(sqrt(col), 1.0);\n}","name":"Image","description":"","type":"image"}]}