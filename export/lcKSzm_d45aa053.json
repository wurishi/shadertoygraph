{"ver":"0.1","info":{"id":"lcKSzm","date":"1715004894","viewed":54,"name":"Structural Similarity Index SSIM","username":"chronos","description":"Structural Similarity Index Measure (SSIM)","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["index","similarity","measure","structural","ssim"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/*\n    Structural Similarity Index SSIM by chronos\n    ---------------------------------------------\n\n    Please note! I'm not at all sure this is a correct implementation,\n    and it's definitely not efficient! So consider yourself warned!\n\n    In particular, I'm not sure about the assumtions on the color space or dynamic range of the images.\n    Is sRGB gamma encoding assumed, or linear luma? SSIM is originally only defined for grayscale images,\n    so then the color to grayscale conversion also comes into play.\n    Many images are encoded as 8-bit integers [0, 255], I'm not sure how that plays into the\n    dynamic range factor 'L' in this algorithm when using floats in [0., 1.].\n    \n    I may have messed up the sample mean, standard deviation / variance or covariance computations. Should be checked.\n    \n    I used 11x11 sized windows here, with no gaussian filter / mask.\n    \n    \n    \n    If you can help shed any light on the above issues it would be very welcome! :)\n    \n    \n    \n    BufA: clean image\n    BufB: noisy image\n    BufC: compute SSIM\n    Common: helpers and preprocessor flags (for toggling gamma or grayscale)\n    \n    ------------------------------------------------------------------------------------------------\n    \n\n    // From wikipedia article on SSIM:\n    -------------------------------------------------------------\n    for image windows x and y, of size NxN\n\n    SSIM(x,y) = (2 * mu_x * mu_y + c1) * (2 sigma_xy + c2) / ((mu_x^2 + mu_y^2 + c1) * (sigma_x^2 + sigma_y^2 + c2))\n\n\n    mu_x pixel sample mean of x\n    mu_y pixel sample mean of y\n    sigma_x^2 the variance of x\n    sigma_y^2 the variance of y\n    sigma_xy the covariance of x and y\n\n    c1 = (k1 L)^2, c2 = (k2 L)^2 two variables to stabilize the division with weak denominator\n    L = the dynamic range of the pixel values, typically 2^bits_per_channel - 1, eg 2^8 - 1 = 255\n    k1 = 0.01, k2 = 0.03\n\n    typical window size: sliding gaussian window of size 11x11, or block window size of 8x8.\n\n    DSSIM = (1.-SSIM)*.5\n\n\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    vec3 color = mouse.x > uv.x ? \n        \n            mouse.y > uv.y ? texture(iChannel0, uv).rgb : texture(iChannel1, uv).rgb\n        \n        :\n    \n    (texture(iChannel2, uv).rgb)\n    ;\n    \n    //color *= max(vec3(0,1,0)*color, 0.) + max(vec3(0,0,-1)*color, 0.);\n    #if GAMMA_ENCODE_OUTPUT\n    color = sRGBencode(color);\n    #endif\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Clean image\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 color = texture(iChannel0, uv).rgb;\n    \n    #if USE_LINEAR_RGB\n    color = sRGBdecode(color);\n    #endif\n    \n    #if USE_GRAYSCALE\n    color = vec3(dot(color, vec3(1./3.)));\n    #endif\n    fragColor = vec4(color,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Noisy image\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 color = texture(iChannel0, uv).rgb;\n    \n    #if USE_LINEAR_RGB\n    color = sRGBdecode(color);\n    #endif\n    \n    float noise = abs(0.5*sin(iTime));//0.1;\n    color += noise*(-1. + 2.*texture(iChannel1, uv).rgb);\n    \n    #if USE_GRAYSCALE\n    color = vec3(dot(color, vec3(1./3.)));\n    #endif\n    fragColor = vec4(clamp(color,0.,1.),1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Compute SSIM of buf A and buf B\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 ssim = vec3(0);\n\n    ivec2 px = ivec2(fragCoord);\n\n    vec3 mu_x = vec3(0);\n    vec3 mu_y = vec3(0);\n\n    vec3 sigma_x  = vec3(0);\n    vec3 sigma_y  = vec3(0);\n    vec3 cov_xy = vec3(0);\n\n    float w = 0.;\n\n    for(int i = -5; i <= 5; i++)\n    {\n        for(int j = -5; j <= 5; j++)\n        {\n            ivec2 pix_coord = px + ivec2(j, i);\n            vec3 bufA = texelFetch(iChannel0, pix_coord, 0).rgb;\n            vec3 bufB = texelFetch(iChannel1, pix_coord, 0).rgb;\n            \n            mu_x += bufA;\n            mu_y += bufB;\n            \n            w++;\n        }\n    }\n    \n    mu_x /= w;\n    mu_y /= w;\n    \n    for(int i = -5; i <= 5; i++)\n    {\n        for(int j = -5; j <= 5; j++)\n        {\n            ivec2 pix_coord = px + ivec2(j, i);\n            vec3 bufA = texelFetch(iChannel0, pix_coord, 0).rgb;\n            vec3 bufB = texelFetch(iChannel1, pix_coord, 0).rgb;\n            \n            sigma_x  += (bufA - mu_x) * (bufA - mu_x);\n            sigma_y  += (bufB - mu_y) * (bufB - mu_y);\n            cov_xy   += (bufA - mu_x) * (bufB - mu_y);\n        }\n    }\n    \n    float L = 1.;\n    float k1 = 0.01;\n    float k2 = 0.03;\n    float c1 = L * k1 * L * k1;\n    float c2 = L * k2 * L * k2;\n    \n    sigma_x  /= w;\n    sigma_y  /= w;\n    \n    sigma_x  = sqrt(sigma_x);\n    sigma_y  = sqrt(sigma_y);\n    \n    cov_xy /= w;\n    \n    \n    ssim = \n        (2. * mu_x * mu_y + c1) * (2. * cov_xy + c2) \n        /\n        ((mu_x*mu_x + mu_y*mu_y + c1) * (sigma_x*sigma_x + sigma_y*sigma_y + c2));\n    \n    //ssim = texture(iChannel0, fragCoord.xy/iResolution.xy).rgb;\n    \n    fragColor.rgb = ssim;\n    fragColor.a = 1.;\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define USE_GRAYSCALE 1\n\n#define USE_LINEAR_RGB 1\n\n#define GAMMA_ENCODE_OUTPUT 1\n\n\nfloat sRGBencode(float C_linear)\n{\n    return C_linear > 0.0031308 ? (1.055 * pow(C_linear, 1./2.4) - 0.055) : (12.92 * C_linear);\n}\n\nvec3 sRGBencode(vec3 C_linear)\n{\n    C_linear = clamp(C_linear, 0., 1.);\n    return vec3(sRGBencode(C_linear.x), sRGBencode(C_linear.y), sRGBencode(C_linear.z));\n}\n\nfloat sRGBdecode(float C_sRGB)\n{\n    return C_sRGB > 0.04045 ? (pow((C_sRGB + 0.055)/1.055, 2.4) ) : (C_sRGB / 12.92);\n}\n\nvec3 sRGBdecode(vec3 C_sRGB)\n{\n    return vec3(sRGBdecode(C_sRGB.x), sRGBdecode(C_sRGB.y), sRGBdecode(C_sRGB.z));\n}\n","name":"Common","description":"","type":"common"}]}