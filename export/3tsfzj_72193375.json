{"ver":"0.1","info":{"id":"3tsfzj","date":"1597191262","viewed":93,"name":"Partial Pixelation","username":"hobbes","description":"The default shader rippling from a point that orbits the origin. Certain reds cause a pixelation effect. The programming is messy :)","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["pixelation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float rand(float n){\n    return fract(sin(n) * 51423.19613123 + cos(n));\n}\n\nfloat resolution(){ return 16.;}\n\n\n\nvec3 normal(vec2 fragCoord) {\n        // Normalized pixel coordinates (from 0 to 1)\n    fragCoord.x = fragCoord.x * (iResolution.x/iResolution.y);\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float speed = iTime * 1.0;\n    \n    float ripple_speed = 3.0 * speed;\n    float orbit_speed = 1.0 * speed;\n    bool direction = true;\n    vec2 origin_center = vec2(0.5, 0.5);\n    vec2 orbit_scale = vec2(1.,1.);\n    float freq = 1.5;\n    float blend = 0.5;\n    \n    \n    \n    if (direction) {\n        ripple_speed = -ripple_speed;\n    }\n    \n    // Center\n    vec2 origin = vec2(cos(orbit_speed) / orbit_scale.x + origin_center.x, sin(orbit_speed) / orbit_scale.y + origin_center.y);\n    \n    \n    \n    vec2 pos = vec2(origin.x - uv.x, origin.y - uv.y);\n    \n    //vec3 col = 0.5 + blend * sin(ripple_speed + sqrt(pow(freq * iTime * cos(iTime), 2.0) + pow(freq * iTime * sin(iTime), 2.0)) * freq + vec3(0,2,4));\n\t\n    // Time varying pixel color\n    return 0.5 + blend * sin(ripple_speed + sqrt(pow(pos.x, 2.0)+pow(pos.y, 2.0)) * freq + vec3(.3,2,3.5));\n}\n\nvec3 pixel(vec2 fragCoord) {\n        // Normalized pixel coordinates (from 0 to 1)\n    fragCoord.x = fragCoord.x * (iResolution.x/iResolution.y);\n    vec2 uv = floor(fragCoord/iResolution.xy * resolution()) / resolution();\n    \n    float ripple_speed = 3.0 * iTime;\n    float orbit_speed = 1.0 * iTime;\n    bool direction = true;\n    vec2 origin_center = vec2(0.5, 0.5);\n    vec2 orbit_scale = vec2(1.,1.);\n    float freq = 1.5;\n    float blend = 0.5;\n    \n    \n    \n    if (direction) {\n        ripple_speed = -ripple_speed;\n    }\n    \n    // Center\n    vec2 origin = vec2(cos(orbit_speed) / orbit_scale.x + origin_center.x, sin(orbit_speed) / orbit_scale.y + origin_center.y);\n    \n    \n    \n    vec2 pos = vec2(origin.x - uv.x, origin.y - uv.y);\n    \n    //vec3 col = 0.5 + blend * sin(ripple_speed + sqrt(pow(freq * iTime * cos(iTime), 2.0) + pow(freq * iTime * sin(iTime), 2.0)) * freq + vec3(0,2,4));\n\t\n    // Time varying pixel color\n    vec3 col = 0.5 + blend * sin(ripple_speed + sqrt(pow(pos.x, 2.0)+pow(pos.y, 2.0)) * freq + vec3(.3,2,3.5));\n    return floor(col * resolution()) / resolution();\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = pixel(fragCoord);\n    if (color.r < 0.6) {\n        color = normal(fragCoord);\n    }\n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}