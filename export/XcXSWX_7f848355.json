{"ver":"0.1","info":{"id":"XcXSWX","date":"1707732456","viewed":29,"name":"[inspirnathan] 02 - carre&rotat","username":"hrst4","description":"[inspirnathan] 02 - carre&rotat","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["inspirnathan"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This a french translation of the highly educational Nathan Vaughn's tutorials.\n// Un grand merci à lui !\n// his website: https://inspirnathan.com/\n// original:\n// https://inspirnathan.com/posts/49-shadertoy-tutorial-part-3\n#define PART 2\n\n/*\n# Comment dessiner des carrés\nDessiner un carré est très similaire à dessiner un cercle, \nsauf que nous utiliserons une équation différente. \nEn fait, vous pouvez dessiner pratiquement toutes les formes 2D que vous souhaitez\nsi vous disposez d'une équation pour les représenter !\n\nL'équation d'un carré est définie par ce qui suit :\n\nmax(abs(x),abs(y)) = r\n\nx = x-coordinate on graph\ny = y-coordinate on graph\nr = radius of square\n\nNous pouvons réarranger les variables pour que l'équation soit égale à zéro :\nmax(abs(x), abs(y)) - r = 0\n\nPour visualiser ce phénomène sur un graphique, vous pouvez utiliser la calculatrice\nDesmos pour tracer le graphique suivant :\nmax(abs(x), abs(y)) - 2 = 0\n\nVous pouvez également inclure un décalage :\nmax(abs(x - offsetX), abs(y - offsetY)) - r = 0\n\noffsetX = how much to move the center of the square in the x-axis\noffsetY = how much to move the center of the square in the y-axis\n\nLes étapes pour dessiner un carré à l'aide d'un pixel shader sont très similaires \nà celles du tutoriel précédent où nous avons créé un cercle. \nEn revanche, nous allons créer une fonction spécifique pour un carré.\n*/\n#if PART == 1 \nvec3 sdfSquare(vec2 uv, float size, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n  float d = max(abs(x), abs(y)) - size;\n  \n  return d > 0. ? vec3(1.) : vec3(1., 0., 0.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n  uv -= 0.5; // <-0.5,0.5>\n  uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n  vec2 offset = vec2(0.0, 0.0);\n\n  vec3 col = sdfSquare(uv, 0.2, offset);\n\n  // Output to screen\n  fragColor = vec4(col,1.0);\n}\n\n/*\n# Pivoter des formes\nVous pouvez faire pivoter des formes en utilisant une matrice de rotation\ndonnée par la notation suivante :\nLes matrices peuvent nous aider à travailler avec des équations linéaires\nmultiples et des transformations linéaires. \nEn fait, une matrice de rotation est un type de matrice de transformation. \nNous pouvons utiliser les matrices pour effectuer d'autres transformations\ntelles que le shearing, la translation ou la réflexion.\n\nSi vous souhaitez jouer avec l'arithmétique matricielle, \nvous pouvez utiliser la calculatrice matricielle Demos ou WolframAlpha.\nSi vous avez besoin d'un rappel sur les matrices, \nvous pouvez regarder cette étonnante vidéo de Derek Banas sur YouTube.\nhttps://www.youtube.com/watch?v=l3S1gKQLm4s\n\ndemo desmos:\nhttps://www.desmos.com/calculator/htynhlnbvs?lang=fr\n\nLa forme d'équation linéaire est obtenue en multipliant la matrice de rotation\npar le vecteur [x,y] tel que calculé par WolframAlpha. \nLe résultat est une équation pour la coordonnée x transformée et la coordonnée y\ntransformée après la rotation.\n\nDans Shadertoy, nous ne nous intéressons qu'à la matrice de rotation,\net non à la forme de l'équation linéaire. Je ne parle de la forme d'équation\nlinéaire que dans le but de montrer les rotations dans Desmos.\n\nNous pouvons créer une fonction rotate dans notre code shader \nqui accepte les coordonnées UV et un angle de rotation du carré. \nElle retournera la matrice de rotation multipliée par les coordonnées UV.\nEnsuite, nous appellerons la fonction rotate à l'intérieur de la fonction \nsdfSquare en passant nos coordonnées XY, décalées par un offset (s'il existe). \nNous utiliserons iTime comme angle, afin que le carré s'anime.\n\n*/\n\n#elif PART == 2\nvec2 rotate(vec2 uv, float th) {\n  return mat2(cos(th), sin(th), -sin(th), cos(th)) * uv;\n}\n\nvec3 sdfSquare(vec2 uv, float size, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n  vec2 rotated = rotate(vec2(x,y), iTime);\n  float d = max(abs(rotated.x), abs(rotated.y)) - size;\n  \n  return d > 0. ? vec3(1.) : vec3(1., 0., 0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n  uv -= 0.5; // <-0.5,0.5>\n  uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n  vec2 offset = vec2(0.0, 0.0);\n\n  vec3 col = sdfSquare(uv, 0.2, offset);\n\n  // Output to screen\n  fragColor = vec4(col,1.0);\n}\n\n\n#endif","name":"Image","description":"","type":"image"}]}