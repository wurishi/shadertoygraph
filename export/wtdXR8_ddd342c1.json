{"ver":"0.1","info":{"id":"wtdXR8","date":"1580408504","viewed":103,"name":"Simple mountains","username":"Dijkstra","description":"First attempt at creating mountains\n\nDepending on your graphic card it seems to be more or less broken... weird...","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float rand21(vec2 uv){\n \treturn fract(sin(uv.x*12165431.+uv.y*452654.)*94121.);\n}\n\nfloat smoothnoise(vec2 uv, float size){\n    vec2 lv = smoothstep(0.,1., fract(uv*size));\n    vec2 id = floor(uv*size);\n    \n    float bl = rand21(id + vec2(0.,0.));\n    float br = rand21(id + vec2(1.,0.));\n    float tl = rand21(id + vec2(0.,1.));\n    float tr = rand21(id + vec2(1.,1.));\n    float b = mix(bl, br, lv.x);\n    float t = mix(tl, tr, lv.x);\n    float c = mix(b, t, lv.y);\n    \n    return c;\n}\n\nfloat smoothMore(vec2 uv, float size){\n    float total = smoothnoise(uv, size);\n    total += smoothnoise(uv, size*2.)/4.;\n    total += smoothnoise(uv, size*4.)/8.;\n    total += smoothnoise(uv, size*8.)/16.;\n    total += smoothnoise(uv, size*16.)/32.;\n \treturn total;\n}\n\nvec4 sphere(vec3 p, vec3 spherePosition, float radius){\n\treturn vec4(length(abs(p-spherePosition)) - radius, 1.,1.,.6);\n}\n\nvec4 ground(vec3 p){\n    float offset = smoothMore(vec2(p.x,p.z), .5)*1.5;\n    float cursor = p.y+1.5;\n\treturn vec4(p.y+2. - offset, \n                mix(.44, 1., cursor), \t\t//r\n                mix(.35, 1., cursor), \t\t//g\n                mix(.25, 1., cursor));\t\t//b\n}\n\nvec4 scene(vec3 p){\n    vec4 d1 = sphere(p, vec3(25., 8., 20. + iTime), 1.);\n    vec4 d2 = ground(p);\n    if(d1.x < d2.x)\n        return d1;\n    return d2;\n}\n\nconst float EPSILON = 0.0001;\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        scene(vec3(p.x + EPSILON, p.y, p.z)).x - scene(vec3(p.x - EPSILON, p.y, p.z)).x,\n        scene(vec3(p.x, p.y + EPSILON, p.z)).x - scene(vec3(p.x, p.y - EPSILON, p.z)).x,\n        scene(vec3(p.x, p.y, p.z  + EPSILON)).x - scene(vec3(p.x, p.y, p.z - EPSILON)).x\n    ));\n}\n\nfloat getLight(vec3 p){\n \tvec3 lightPos = vec3(22., 10.,iTime+3.);\n    vec3 ld = normalize(lightPos-p);\n    vec3 n = estimateNormal(p);\n    \n    float dif = dot(n,ld);\n    return dif;\n}\n\nfloat glowing(vec3 p){\n \t return sphere(p, vec3(25., 8., 20. + iTime), 1.).x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=.5;\n    uv.x *= (iResolution.x/iResolution.y);\n\n    \n    vec3 ro = vec3(15.,0.,-3.+iTime);\n    vec3 rd = normalize(vec3(uv,1.));\n    vec3 rp = ro;\n   \tvec3 col = vec3(.3,.4,.98);\n    float i = 0.;\n    for(i=0.; i<100.; ++i){\n    \tfloat dist = scene(rp).x;\n        rp += rd * dist;\n        if(dist < .01){\n            col = scene(rp).yzw;\n            col *= vec3(getLight(rp));\n        \tbreak;\n        }\n        if(dist>100.) break;\n    }\n    \n    \n    rp = ro;\n    for(i=0.; i<100.; ++i){\n    \tfloat dist = glowing(rp);\n        rp += rd * dist;\n        if(dist < 1.){\n            col += vec3(.03);\n        }\n        if(dist>100.) break;\n    }\n    \n\n\n    // Output to screen\n    //fragColor = vec4(vec3(smoothMore(uv, 11.)),1.0);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}