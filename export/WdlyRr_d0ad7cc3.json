{"ver":"0.1","info":{"id":"WdlyRr","date":"1584014004","viewed":719,"name":"Centers of a triangle","username":"noby","description":"This shader demonstrated the first ten (10) triangle center points as defined by https://en.wikipedia.org/wiki/Encyclopedia_of_Triangle_Centers.\n\nYou can move the triangle vertices using your mouse. Use the legend to toggle individual points on or off. ","likes":48,"published":1,"flags":32,"usePreview":1,"tags":["2d","triangle","visualization","center","vectors","centers"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// MIT License\n\n// Copyright © 2020 Roope Mäkinen\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    #if DARKMODE\n    \tfragColor = 0.1+0.892*texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \tfragColor.rgb = pow(1.0-fragColor.rgb, vec3(1.0/2.2));\n    #else\n    \tfragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \tfragColor.rgb = pow(fragColor.rgb, vec3(1.0/2.2)).bgr;\n    #endif\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// This file just collects all preprocessor definitions for convenience.\n#define DARKMODE 1\n#define USE_TEXT_RENDERING 1\n#define CIRCUMCIRCLE_VERTICES 0\n#define ANIMATE 0\n#define INTERACTIVITY_HINT 1\n\nconst float TriangleGrabRadius = 0.1;\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// MIT License\n\n// Copyright © 2020 Roope Mäkinen\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\nstruct Line {\n    vec2 a, b;\n    vec4 color;\n    float thickness;\n};\n    \nstruct Circle {\n    vec2 c;\n    float r;\n    vec4 color;\n    float thickness;\n    bool filled;\n};\n\nstruct Triangle {\n    vec2 a, b, c;\n    vec4 color;\n    float thickness;\n};\n\nconst int TotalPoints = 10;\n    \nconst float Pi = 3.14159;\nconst float HalfPi = Pi*0.5;\nconst float TwoPi = Pi*2.0;\nconst float Third = 1.0/3.0;\nconst float Sq2 = sqrt(2.0);\n\nconst float Zoom = 2.0;\nconst float LetterSpacing = 0.41;\nconst float TextBorder = 0.0;\nvec3 Colors[TotalPoints];\n\n#if USE_TEXT_RENDERING\nfloat char(inout vec2 p, int C, float d, float w){\n    if(p.x < 0.0 || p.x > 1.0 || p.y < 0.0 || p.y > 1.0){\n        p.x -= w;\n        return d;\n    }\n    vec4 cc = textureGrad(iChannel0, p/16.0 + fract(vec2(C, 15-C/16) / 16.0), dFdx(p/16.0), dFdy(p/16.0));\n    p.x -= w;\n    return cc.r;\n}\n\nvoid printf(inout vec2 p, inout vec3 buffer, int[13] text, vec3 color){\n    float leftMargin = p.x;\n    int c, i = 0;\n    \n    // Read until first null is encountered.\n    while((c = text[i++]) != 0){\n        buffer += (1.0-color)*mix(0.0, 1.0, pow(length(char(p, c, TextBorder, LetterSpacing)), float(1+DARKMODE)));\n    }\n    \n    // An implicit \"newline\" character.\n    p = vec2(leftMargin, p.y + LetterSpacing*2.0);\n}\n\nvec3 drawAllText(vec2 p){\n    vec3 buffer = vec3(0);\n    \n    // Bounding box test.\n    if(p.x < 80.0 && iResolution.y - p.y < 130.0){\n        \n        // Align and scale the text positioning accordingly;\n        p.y -= iResolution.y-17.0;\n        p /= 15.0;\n\n        // Null-terminated strings.\n        // They all have to be the same length due to GLSL limitations.\n        const int Len = 13;\n        const int Incenter[Len] = int[](73, 110, 99, 101, 110, 116, 101, 114, 0, 0, 0, 0, 0);\n        const int Centroid[Len] = int[](67, 101, 110, 116, 114, 111, 105, 100, 0, 0, 0, 0, 0);\n        const int Circumcenter[Len] = int[](67, 105, 114, 99, 117, 109, 99, 101, 110, 116, 101, 114, 0);\n        const int Orthocenter[Len] = int[](79, 114, 116, 104, 111, 99, 101, 110, 116, 101, 114, 0, 0);\n        const int Ninepoint[Len] = int[](78, 105, 110, 101, 112, 111, 105, 110, 116, 0, 0, 0, 0);\n        const int Symmedian[Len] = int[](83, 121, 109, 109, 101, 100, 105, 97, 110, 0, 0, 0, 0);\n        const int Gergonne[Len] = int[](71, 101, 114, 103, 111, 110, 110, 101, 0, 0, 0, 0, 0);\n        const int Nagelpoint[Len] = int[](78, 97, 103, 101, 108, 112, 111, 105, 110, 116, 0, 0, 0);\n        const int Mittenpunkt[Len] = int[](77, 105, 116, 116, 101, 110, 112, 117, 110, 107, 116, 0, 0);\n        const int Spieker[Len] = int[](83, 112, 105, 101, 107, 101, 114, 0, 0, 0, 0, 0, 0);\n        printf(p, buffer, Incenter, Colors[0]);\n        printf(p, buffer, Centroid, Colors[1]);\n        printf(p, buffer, Circumcenter, Colors[2]);\n        printf(p, buffer, Orthocenter, Colors[3]);\n        printf(p, buffer, Ninepoint, Colors[4]);\n        printf(p, buffer, Symmedian, Colors[5]);\n        printf(p, buffer, Gergonne, Colors[6]);\n        printf(p, buffer, Nagelpoint, Colors[7]);\n        printf(p, buffer, Mittenpunkt, Colors[8]);\n        printf(p, buffer, Spieker, Colors[9]);\n    }\n    return buffer;\n}\n#endif //USE_TEXT_RENDERING\n\n// Antialiasing coefficient based on resolution,\n// assigned in the main function.\nfloat Dx;\n\nfloat lineShape(vec2 uv, Line l){\n    vec2 d  = l.b - l.a;\n    vec2 nd = normalize(d);\n    float len = dot(uv - l.a, nd);\n    return clamp((distance(uv, l.a + len * nd) - l.thickness)*Dx, 0.0, 1.0);\n}\n\nfloat segmentShape(vec2 uv, Line l){\n    vec2 d  = l.b - l.a;\n    vec2 nd = normalize(d);\n    float len = clamp(dot(uv - l.a, nd), 0.0, length(d));\n    return clamp((distance(uv, l.a + len * nd) - l.thickness)*Dx, 0.0, 1.0);\n}\n\nfloat circleShape(vec2 uv, Circle c){\n    float t = c.thickness;\n    if(c.filled)\n        return clamp((distance(uv, c.c) - c.r)*Dx, 0.0, 1.0);\n\telse\n        return clamp((abs((sqrt(pow(uv.x - c.c.x, 2.0) + pow(uv.y - c.c.y, 2.0))-c.r))-t)*Dx, 0.0, 1.0);\n}\n\nfloat triangleShape(vec2 uv, Triangle t){\n    return segmentShape(uv, Line(t.a, t.b, t.color, t.thickness)) *\n           segmentShape(uv, Line(t.b, t.c, t.color, t.thickness)) *\n           segmentShape(uv, Line(t.c, t.a, t.color, t.thickness));\n}\n\nvoid drawLine(vec2 uv, inout vec3 color, Line l){\n    float alpha = l.color.a;\n    #if DARKMODE\n    alpha = pow(alpha, 1.5);\n    #else\n    alpha = pow(alpha, 0.75);\n    #endif\n    color = mix(l.color.rgb, color, (1.0-alpha) + alpha*lineShape(uv, l));\n}\n\nvoid drawSegment(vec2 uv, inout vec3 color, Line s){\n    float alpha = s.color.a;\n    #if DARKMODE\n    alpha = pow(alpha, 1.5);\n    #else\n    alpha = pow(alpha, 0.75);\n    #endif\n    color = mix(s.color.rgb, color, (1.0-alpha) + alpha*segmentShape(uv, s));\n}\n\nvoid drawCircle(vec2 uv, inout vec3 color, Circle c){\n    float alpha = c.color.a;\n    #if DARKMODE\n    alpha = pow(alpha, 1.5);\n    #else\n    alpha = pow(alpha, 0.75);\n    #endif\n    color = mix(c.color.rgb, color, (1.0-alpha) + alpha*circleShape(uv, c));\n}\n\nvoid drawTriangle(vec2 uv, inout vec3 color, Triangle t){\n    float alpha = t.color.a;\n    #if DARKMODE\n    alpha = pow(alpha, 1.5);\n    #else\n    alpha = pow(alpha, 0.75);\n    #endif\n    color = mix(t.color.rgb, color, (1.0-alpha) + alpha*triangleShape(uv, t));\n}\n\n// Fake \"constructor\" for a barycentric coordinates\n// because I don't wanna repeat this everywhere explicitly.\nvec3 Barycentric(vec3 b){\n    return b / (b.x + b.y + b.z);\n}\n\nvec2 barycentricToCartesian(vec3 barycentric, Triangle t){\n    return vec2(barycentric.x*t.a.x + barycentric.y*t.b.x + barycentric.z*t.c.x,\n                barycentric.x*t.a.y + barycentric.y*t.b.y + barycentric.z*t.c.y);\n}\n\nvec2 intersectLines(Line a, Line b){\n    // Returns the cartesian intersection point between two lines.\n    float divisor = (a.a.x - a.b.x)*(b.a.y - b.b.y)-(a.a.y - a.b.y)*(b.a.x - b.b.x);\n    float tm1 = a.a.x*a.b.y - a.a.y*a.b.x;\n    float tm2 = b.a.x*b.b.y - b.a.y*b.b.x;\n    return vec2( (tm1*(b.a - b.b) - tm2*(a.a - a.b))/divisor );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Position the figure at the center at\n    // all orientations and aspect ratios.\n    vec2 R = iResolution.xy;\n    vec2 offset = vec2(mix(1.0, R.x/R.y, step(R.y, R.x)),\n                       mix(1.0, R.y/R.x, step(R.x, R.y)));\n    vec2 uv = (Zoom*0.5)*-offset + Zoom*fragCoord/min(R.x, R.y);\n    Dx = min(R.x, R.y) / Zoom;\n    \n    // Some constants and stuff.\n    const bool Filled = true;\n    const bool NotFilled = false;\n    const vec3 BgColor = vec3(1);\n    const float Dt = 0.0005;\n    float PointSize = mix(length(fwidth(uv))*2.0, 0.01, 0.3);\n    vec3 color = BgColor;\n    float T = iTime;\n    \n    // Read previous frame state from the alpha channel.\n    bool incenterOn     = (int(texelFetch(iChannel1, ivec2(0,  1), 0).w) == 1);\n    bool centroidOn     = (int(texelFetch(iChannel1, ivec2(0,  2), 0).w) == 1);\n    bool circumcenterOn = (int(texelFetch(iChannel1, ivec2(0,  3), 0).w) == 1);\n    bool orthocenterOn  = (int(texelFetch(iChannel1, ivec2(0,  4), 0).w) == 1);\n    bool ninepointOn    = (int(texelFetch(iChannel1, ivec2(0,  5), 0).w) == 1);\n    bool symmedianOn    = (int(texelFetch(iChannel1, ivec2(0,  6), 0).w) == 1);\n    bool gergonneOn     = (int(texelFetch(iChannel1, ivec2(0,  7), 0).w) == 1);\n    bool nagelOn        = (int(texelFetch(iChannel1, ivec2(0,  8), 0).w) == 1);\n    bool mittenpunktOn  = (int(texelFetch(iChannel1, ivec2(0,  9), 0).w) == 1);\n    bool spiekerOn      = (int(texelFetch(iChannel1, ivec2(0, 10), 0).w) == 1);\n    \n    // Read previous triangle states and vertex positions from the alpha channel.\n    bool AGrab      = (int(texelFetch(iChannel1, ivec2(1, 0), 0).w) == 1);\n    bool BGrab      = (int(texelFetch(iChannel1, ivec2(2, 0), 0).w) == 1);\n    bool CGrab      = (int(texelFetch(iChannel1, ivec2(3, 0), 0).w) == 1);\n    vec2 APos = vec2(texelFetch(iChannel1, ivec2(1, 1), 0).w, texelFetch(iChannel1, ivec2(1, 2), 0).w);\n    vec2 BPos = vec2(texelFetch(iChannel1, ivec2(2, 1), 0).w, texelFetch(iChannel1, ivec2(2, 2), 0).w);\n    vec2 CPos = vec2(texelFetch(iChannel1, ivec2(3, 1), 0).w, texelFetch(iChannel1, ivec2(3, 2), 0).w);\n    \n    // Triangle vertex position interactivity handling.\n    {\n        // Initial triangle vertex positions.\n        if(iFrame == 0){\n            APos = vec2(-0.98, -0.4);\n            BPos = vec2( 0.5,   0.6);\n            CPos = vec2( 0.98, -0.4);\n        // If mouse button is held down...\n        } else if(iMouse.z > -1.0){\n            // Same construction as with the UV coordinates above.\n            vec2 relativeMousePosition = (Zoom*0.5)*-offset + Zoom*iMouse.xy/min(R.x, R.y);\n            // If a vertex has been grabbed, update its position.\n            if(AGrab){\n                APos = relativeMousePosition;\n            } else if(BGrab){\n                BPos = relativeMousePosition;\n            } else if(CGrab){\n                CPos = relativeMousePosition;\n            // Else detect and initiate a grab.\n            } else {\n                if(distance(relativeMousePosition, APos) <= TriangleGrabRadius){\n                    APos = relativeMousePosition;\n                    AGrab = true;\n                }\n                else if(distance(relativeMousePosition, BPos) <= TriangleGrabRadius){\n                    BPos = relativeMousePosition;\n                    BGrab = true;\n                }\n                else if(distance(relativeMousePosition, CPos) <= TriangleGrabRadius){\n                    CPos = relativeMousePosition;\n                    CGrab = true;\n                }\n            }\n        // Else deactivate all grabs.\n        } else {\n            AGrab = false;\n            BGrab = false;\n            CGrab = false;\n        }\n    }\n    \n    // Fill in default color to indicate the point to be disabled.\n    for(int i = 0; i < TotalPoints; ++i)\n        Colors[i] = vec3(BgColor * 0.8);\n    \n    // Main triangle.\n    const vec3 Black = vec3(0);\n    const float Mr = 0.4;\n    // Three vertices.\n    #if ANIMATE\n    vec2 A = vec2(-0.8 + Mr*sin(1.0 + T*0.69), -0.5 + Mr*cos(1.0 + T*0.61));\n    vec2 B = vec2( 1.0 + Mr*sin(2.0 + T*0.73), -0.1 + Mr*cos(2.0 + T*0.59));\n    vec2 C = vec2(      -Mr*sin(3.0 + T*0.65),  0.7 - Mr*cos(3.0 + T*0.57));\n    #else\n    vec2 A = APos;\n    vec2 B = BPos;\n    vec2 C = CPos;\n    #endif\n    // Side lengths.\n    float a = distance(B, C);\n    float b = distance(A, C);\n    float c = distance(A, B);\n    \n    // Calculate the largest angle in the main triangle.\n    // (Used in animating and fading some of the points.)\n    float a2 = a*a;\n    float b2 = b*b;\n    float c2 = c*c;\n    float angleA = acos((b2 + c2 - a2)/(2.0*b*c));\n    float angleB = acos((c2 + a2 - b2)/(2.0*a*c));\n    float angleC = acos((a2 + b2 - c2)/(2.0*a*b));\n    float maxAngle = max(max(angleA, angleB), angleC);\n    \n    Triangle triangle = Triangle(A, B, C, vec4(Black, 1.0), Dt*3.0);\n    drawTriangle(uv, color, triangle);\n    drawCircle(uv, color, Circle(A, PointSize*1.25, vec4(Black, 1), Dt, Filled));\n    drawCircle(uv, color, Circle(B, PointSize*1.25, vec4(Black, 1), Dt, Filled));\n    drawCircle(uv, color, Circle(C, PointSize*1.25, vec4(Black, 1), Dt, Filled));\n    \n    #if INTERACTIVITY_HINT\n    float animA = mod(T, 1.1)/1.1;\n    float animB = mod(T, 1.2)/1.2;\n    float animC = mod(T, 1.3)/1.3;\n    float fadeA = 0.4*(1.0-smoothstep(0.7, 1.0, animA));\n    float fadeB = 0.4*(1.0-smoothstep(0.7, 1.0, animB));\n    float fadeC = 0.4*(1.0-smoothstep(0.7, 1.0, animC));\n    drawCircle(uv, color, Circle(A, PointSize*1.25+0.02*animA, vec4(Black, fadeA), Dt*0.5, NotFilled));\n    drawCircle(uv, color, Circle(B, PointSize*1.25+0.02*animB, vec4(Black, fadeB), Dt*0.5, NotFilled));\n    drawCircle(uv, color, Circle(C, PointSize*1.25+0.02*animC, vec4(Black, fadeC), Dt*0.5, NotFilled));\n    #endif\n\t\n    // Excircle centers.\n    // Excenter barycentric coordinate reference:\n    // https://math.stackexchange.com/a/2885094\n    vec2 excA = barycentricToCartesian(Barycentric(vec3(-a, b, c)), triangle);\n    vec2 excB = barycentricToCartesian(Barycentric(vec3( a,-b, c)), triangle);\n    vec2 excC = barycentricToCartesian(Barycentric(vec3( a, b,-c)), triangle);\n    // Draw the excircles for the main triangle.\n    {\n        drawLine(uv, color, Line(A, B, vec4(Black, 0.15), 0.0));\n    \tdrawLine(uv, color, Line(B, C, vec4(Black, 0.15), 0.0));\n    \tdrawLine(uv, color, Line(C, A, vec4(Black, 0.15), 0.0));\n        \n        drawCircle(uv, color, Circle(excA, PointSize, vec4(Black, 0.5), Dt, Filled));\n        drawCircle(uv, color, Circle(excB, PointSize, vec4(Black, 0.5), Dt, Filled));\n        drawCircle(uv, color, Circle(excC, PointSize, vec4(Black, 0.5), Dt, Filled));\n        \n        // Excrircle radii.\n        float s = 0.5*(a + b + c);\n        float ra = sqrt((s*(s - b)*(s - c))/(s - a));\n        float rb = sqrt((s*(s - c)*(s - a))/(s - b));\n        float rc = sqrt((s*(s - a)*(s - b))/(s - c));\n        drawCircle(uv, color, Circle(excA, ra, vec4(Black, 0.25), Dt, NotFilled));\n        drawCircle(uv, color, Circle(excB, rb, vec4(Black, 0.25), Dt, NotFilled));\n        drawCircle(uv, color, Circle(excC, rc, vec4(Black, 0.25), Dt, NotFilled));\n    }\n    \n    // Triangle incenter and incircle.\n    vec2 incenterPoint;\n    if(incenterOn || gergonneOn){\n        float abc = a + b + c;\n        float s = abc / 2.0;\n        incenterPoint = (a*A + b*B + c*C)/abc;\n        \n        if(incenterOn){\n            const vec3 IncircleColor = vec3(0.9, 0.2, 0.1);\n        \tColors[0] = IncircleColor;\n            Circle incircle = Circle(incenterPoint, sqrt((s - a)*(s - b)*(s - c)/s), vec4(IncircleColor, 1), Dt, NotFilled);\n            Circle incenter = Circle(incenterPoint, PointSize, vec4(IncircleColor, 1), Dt, Filled);\n            drawCircle(uv, color, incircle);\n            drawCircle(uv, color, incenter);\n        }\n    }\n    // The segments between incenter and the closes points on the triangle.\n    // These are based on the same approach as the line drawing function.\n    vec2 nda = normalize(B - A);\n    vec2 ndb = normalize(C - B);\n    vec2 ndc = normalize(A - C);\n    vec2 Ta = A + clamp(dot(incenterPoint - A, nda), 0.0, length(B - A)) * nda;\n    vec2 Tb = B + clamp(dot(incenterPoint - B, ndb), 0.0, length(C - B)) * ndb;\n    vec2 Tc = C + clamp(dot(incenterPoint - C, ndc), 0.0, length(A - C)) * ndc;\n    if(incenterOn){\n        drawSegment(uv, color, Line(incenterPoint, Ta, vec4(Colors[0], Third), Dt));\n        drawSegment(uv, color, Line(incenterPoint, Tb, vec4(Colors[0], Third), Dt));\n        drawSegment(uv, color, Line(incenterPoint, Tc, vec4(Colors[0], Third), Dt));\n        drawCircle(uv, color, Circle(Ta, PointSize, vec4(Colors[0], 0.5), Dt, Filled));\n        drawCircle(uv, color, Circle(Tb, PointSize, vec4(Colors[0], 0.5), Dt, Filled));\n        drawCircle(uv, color, Circle(Tc, PointSize, vec4(Colors[0], 0.5), Dt, Filled));\n    }\n    \n    // Triangle centroid point.\n    if(centroidOn){\n        const vec3 CentroidColor = vec3(0.15, 0.5, 0.05);\n        Colors[1] = CentroidColor;\n        \n        vec2 mean = (A + B + C) / 3.0;\n        Circle centroidd = Circle(mean, PointSize, vec4(CentroidColor, 1), Dt, Filled);\n        drawCircle(uv, color, centroidd);\n        drawSegment(uv, color, Line(mean, A, vec4(CentroidColor, 0.5), 0.0));\n        drawSegment(uv, color, Line(mean, B, vec4(CentroidColor, 0.5), 0.0));\n        drawSegment(uv, color, Line(mean, C, vec4(CentroidColor, 0.5), 0.0));\n    }\n    \n    // Circumcenter and circle.\n    float circumCircleDiameter;\n    vec2 circumCenterPoint;\n    {\n        vec2 Aa = A - A;\n        vec2 Ba = B - A;\n        vec2 Ca = C - A;\n        float Ba2 = dot(Ba, Ba);\n        float Ca2 = dot(Ca, Ca);\n        vec2 Uu = vec2(Ca.y*Ba2 - Ba.y*Ca2, Ba.x*Ca2 - Ca.x*Ba2) / (2.0*(Ba.x*Ca.y - Ba.y*Ca.x));\n        vec2 U = Uu + A;\n        circumCircleDiameter = length(Uu)*2.0;\n        circumCenterPoint = U;\n        if(circumcenterOn){\n            const vec3 CircumColor = vec3(0.1, 0.2, 0.6);\n        \tColors[2] = CircumColor;\n            \n            float circumcenterFade = 0.25 + 0.75*(1.0-smoothstep(HalfPi-0.05, HalfPi + 0.05, maxAngle));\n            \n            Circle circumcircle = Circle(U, length(Uu), vec4(CircumColor, 1), Dt, NotFilled);\n            Circle circumcenter = Circle(U, PointSize,  vec4(CircumColor, circumcenterFade), Dt, Filled);\n            drawCircle(uv, color, circumcircle);\n            drawCircle(uv, color, circumcenter);\n            #if CIRCUMCIRCLE_VERTICES\n            drawSegment(uv, color, Line(U, A, vec4(CircumColor, 0.25), 0.0));\n            drawSegment(uv, color, Line(U, B, vec4(CircumColor, 0.25), 0.0));\n            drawSegment(uv, color, Line(U, C, vec4(CircumColor, 0.25), 0.0));\n            #endif\n        }\n    } \n    \n    // Orthocenter and associated line segments.\n    vec2 orthoCenterPoint;\n    if(orthocenterOn){\n        // Color and animation curves as the point moves in an out the triangle area.\n        const vec3 OrthoColor = vec3(0.55, 0.15, 0.7);\n        Colors[3] = OrthoColor;\n        \n        float orthoCenterFade = 1.0-smoothstep(HalfPi-0.05, HalfPi + 0.05, maxAngle);\n        if(circumcenterOn && ninepointOn)\n            orthoCenterFade = 0.25+0.75*orthoCenterFade;\n    \tfloat orthoLineFade = 1.0-smoothstep(HalfPi - 0.1, HalfPi, maxAngle);\n        \n        vec3 orthoBary = Barycentric(vec3((a2+b2-c2)*(a2-b2+c2), (a2+b2-c2)*(-a2+b2+c2), (a2-b2+c2)*(-a2+b2+c2)));\n        orthoCenterPoint = barycentricToCartesian(orthoBary, triangle);\n        // Fade the orthocenter position half way out when it's outside the triangle.\n        Circle orthocenter = Circle(orthoCenterPoint, PointSize, vec4(OrthoColor, orthoCenterFade), Dt, Filled);\n        drawCircle(uv, color, orthocenter);\n        \n        // Altitude lines that define the orthocenter at their intersection.\n        vec2 altitudeA = B + (dot(A - B, C - B)/length(C - B)) * normalize(C - B);\n        vec2 altitudeB = C + (dot(B - C, A - C)/length(A - C)) * normalize(A - C);\n        vec2 altitudeC = A + (dot(C - A, B - A)/length(B - A)) * normalize(B - A);\n        drawSegment(uv, color, Line(A, altitudeA, vec4(OrthoColor, 0.75*orthoLineFade), 0.0));\n        drawSegment(uv, color, Line(B, altitudeB, vec4(OrthoColor, 0.75*orthoLineFade), 0.0));\n        drawSegment(uv, color, Line(C, altitudeC, vec4(OrthoColor, 0.75*orthoLineFade), 0.0));\n    }\n    \n    // Nine-point center.\n    if(ninepointOn){\n        const vec3 NinePointColor = vec3(0.1, 0.6, 0.6);\n        Colors[4] = NinePointColor;\n        \n        vec3 ninePointBary = Barycentric(vec3(a2*(b2 + c2) - pow(b2 - c2, 2.0),\n                                              b2*(c2 + a2) - pow(c2 - a2, 2.0),\n                                              c2*(a2 + b2) - pow(a2 - b2, 2.0)));\n        vec2 ninePointCart = barycentricToCartesian(ninePointBary, triangle);\n        \n        // \"If and only if two of the vertex angles differ from each other by more than 90°,\n        //  one of the barycentric coordinates is negative and so the nine-point center is outside the triangle.\"\n        float nineBaryMin = min(min(ninePointBary.x, ninePointBary.y), ninePointBary.z);\n        float ninePointFade = smoothstep(-0.05, 0.05, nineBaryMin);\n        \n        // Fade the orthocenter fully out when the nine-point center is outside the triangle.\n        // NOTE: code changed since then, cannot do right not without making things ugly...\n        drawCircle(uv, color, Circle(ninePointCart, PointSize, vec4(NinePointColor, ninePointFade), 0.0, Filled));\n        if(circumcenterOn && orthocenterOn){\n        \tdrawSegment(uv, color, Line(circumCenterPoint, ninePointCart, vec4(NinePointColor, 0.75*ninePointFade), 0.0));\n        \tdrawSegment(uv, color, Line(orthoCenterPoint, ninePointCart, vec4(NinePointColor, 0.75*ninePointFade), 0.0));\n        }\n    }\n    \n    // Symmedian point, or the Lemoine point.\n    if(symmedianOn){\n        Colors[5] = vec3(0.4);\n        \n        // The symmedian point is simply defined in barycentric coordinates as\n        // a² : b² : c²\n        vec2 symmedianPoint = barycentricToCartesian(Barycentric(vec3(a2, b2, c2)), triangle);\n        drawCircle(uv, color, Circle(symmedianPoint, PointSize, vec4(vec3(0.4), 1), 0.0, Filled));\n        \n        // The symmedians that define the above point.\n        // A bit ugly but can't be bothered right now...\n        Line AS = Line(A, symmedianPoint, vec4(0), 0.0);\n        Line BC = Line(B, C, vec4(0), 0.0);\n        vec2 symmedianA = intersectLines(AS, BC);\n        Line BS = Line(B, symmedianPoint, vec4(0), 0.0);\n        Line AC = Line(A, C, vec4(0), 0.0);\n        vec2 symmedianB = intersectLines(BS, AC);\n        Line CS = Line(C, symmedianPoint, vec4(0), 0.0);\n        Line AB = Line(A, B, vec4(0), 0.0);\n        vec2 symmedianC = intersectLines(CS, AB);\n        drawSegment(uv, color, Line(A, symmedianA, vec4(vec3(0.4), 0.5), 0.0));\n        drawSegment(uv, color, Line(B, symmedianB, vec4(vec3(0.4), 0.5), 0.0));\n        drawSegment(uv, color, Line(C, symmedianC, vec4(vec3(0.4), 0.5), 0.0));\n    }\n    \n    if(gergonneOn){\n        vec3 GergonneColor = vec3(0.6, 0.7, 0.0);\n        Colors[6] = GergonneColor;\n        \n        // The Gergonne triangle, or contact triangle,\n        // defined by the incircle contact points.\n        Triangle gergonneTriangle = Triangle(Ta, Tb, Tc, vec4(GergonneColor, 0.5), 0.0);\n        drawTriangle(uv, color, gergonneTriangle);\n        \n        // The Gergonne point is the symmedian point\n        // of the Gergonne triangle.\n        float ta2 = pow(distance(Tb, Tc), 2.0);\n        float tb2 = pow(distance(Ta, Tc), 2.0);\n        float tc2 = pow(distance(Ta, Tb), 2.0);\n        vec3 gergonnePointBary = Barycentric(vec3(ta2, tb2, tc2));\n        vec2 gergonnePoint = barycentricToCartesian(gergonnePointBary, gergonneTriangle);\n        drawCircle(uv, color, Circle(gergonnePoint, PointSize, vec4(GergonneColor, 1), 0.0, Filled));\n    }\n    \n    if(nagelOn){\n        vec3 NagelColor = vec3(0.8, 0.2, 0.5);\n        Colors[7] = NagelColor;\n        \n        // The extouch point barycentric coordinates.\n        // The multiplication at the end converts from trilinear.\n        // https://en.wikipedia.org/wiki/Extouch_triangle#Coordinates\n        vec3 etp = vec3((-a+b+c)/a, (a-b+c)/b, (a+b-c)/c) * vec3(a, b, c);\n        vec2 etA = barycentricToCartesian(Barycentric(vec3(0, etp.yz)),       triangle);\n        vec2 etB = barycentricToCartesian(Barycentric(vec3(etp.x, 0, etp.z)), triangle);\n        vec2 etC = barycentricToCartesian(Barycentric(vec3(etp.xy, 0)),       triangle);\n        \n        drawCircle(uv, color, Circle(etA, PointSize, vec4(NagelColor, 0.5), Dt, Filled));\n        drawCircle(uv, color, Circle(etB, PointSize, vec4(NagelColor, 0.5), Dt, Filled));\n        drawCircle(uv, color, Circle(etC, PointSize, vec4(NagelColor, 0.5), Dt, Filled));\n        \n        // Triangle formed by the extouch points.\n    \tdrawTriangle(uv, color, Triangle(etA, etB, etC, vec4(NagelColor, 0.5), Dt));\n        \n        drawSegment(uv, color, Line(A, etA, vec4(NagelColor, 0.25), 0.0));\n        drawSegment(uv, color, Line(B, etB, vec4(NagelColor, 0.25), 0.0));\n        drawSegment(uv, color, Line(C, etC, vec4(NagelColor, 0.25), 0.0));\n        \n        // The actual Nagel point.\n        vec2 nagelPoint = barycentricToCartesian(Barycentric(etp), triangle);\n        drawCircle(uv, color, Circle(nagelPoint, PointSize, vec4(NagelColor, 1), Dt, Filled));\n    }\n    \n    if(mittenpunktOn){\n        vec3 mittenpunktColor = vec3(0.2, 0.85, 0.7);\n        Colors[8] = mittenpunktColor;\n        \n        Triangle excentralTriangle = Triangle(excA, excB, excC, vec4(mittenpunktColor, Third), Dt);\n        drawTriangle(uv, color, excentralTriangle);\n        \n        // The symmedian point is simply defined in barycentric coordinates as\n        // a² : b² : c²\n    \tfloat ea = distance(excB, excC);\n    \tfloat eb = distance(excA, excC);\n    \tfloat ec = distance(excA, excB);\n        vec3 symmedianPointBary = Barycentric(vec3(ea*ea, eb*eb, ec*ec));\n        vec2 symmedianPoint = barycentricToCartesian(symmedianPointBary, excentralTriangle);\n        drawCircle(uv, color, Circle(symmedianPoint, PointSize, vec4(mittenpunktColor, 1), 0.0, Filled));\n        \n        // The symmedians that define the above point.\n        Line AS = Line(excA, symmedianPoint, vec4(0), 0.0);\n        Line BC = Line(excB, excC, vec4(0), 0.0);\n        vec2 symmedianA = intersectLines(AS, BC);\n        Line BS = Line(excB, symmedianPoint, vec4(0), 0.0);\n        Line AC = Line(excA, excC, vec4(0), 0.0);\n        vec2 symmedianB = intersectLines(BS, AC);\n        Line CS = Line(excC, symmedianPoint, vec4(0), 0.0);\n        Line AB = Line(excA, excB, vec4(0), 0.0);\n        vec2 symmedianC = intersectLines(CS, AB);\n        drawSegment(uv, color, Line(excA, symmedianA, vec4(mittenpunktColor, 0.25), 0.0));\n        drawSegment(uv, color, Line(excB, symmedianB, vec4(mittenpunktColor, 0.25), 0.0));\n        drawSegment(uv, color, Line(excC, symmedianC, vec4(mittenpunktColor, 0.25), 0.0));\n    }\n    \n    if(spiekerOn){\n        const vec3 SpiekerColor = vec3(0.0, 0.5, 0.9);\n        Colors[9] = SpiekerColor;\n        \n        vec3 spiekerBary = Barycentric(vec3(b + c, c + a, a + b));\n        vec2 spiekerPoint = barycentricToCartesian(spiekerBary, triangle);\n        drawCircle(uv, color, Circle(spiekerPoint, PointSize, vec4(SpiekerColor, 1), Dt, Filled));\n        \n        vec2 mAB = mix(A, B, 0.5);\n        vec2 mBC = mix(B, C, 0.5);\n        vec2 mCA = mix(C, A, 0.5);\n        drawCircle(uv, color, Circle(mAB, PointSize, vec4(SpiekerColor, 0.5), Dt, Filled));\n        drawCircle(uv, color, Circle(mBC, PointSize, vec4(SpiekerColor, 0.5), Dt, Filled));\n        drawCircle(uv, color, Circle(mCA, PointSize, vec4(SpiekerColor, 0.5), Dt, Filled));\n        drawSegment(uv, color, Line(mAB, mBC, vec4(SpiekerColor, Third), Dt));\n        drawSegment(uv, color, Line(mBC, mCA, vec4(SpiekerColor, Third), Dt));\n        drawSegment(uv, color, Line(mCA, mAB, vec4(SpiekerColor, Third), Dt));\n        \n        float ma = distance(mBC, mCA);\n        float mb = distance(mCA, mAB);\n        float mc = distance(mAB, mBC);\n        float mabc = ma + mb + mc;\n        float ms = mabc / 2.0;\n        Circle spiekerCircle = Circle(spiekerPoint, sqrt((ms - ma)*(ms - mb)*(ms - mc)/ms), vec4(SpiekerColor, 0.5), Dt, NotFilled);\n        drawCircle(uv, color, spiekerCircle);\n    }\n    \n    // Color output.\n    fragColor.rgb = color;\n    \n    #if USE_TEXT_RENDERING\n    // Handle mouse events and save user interface state.\n    {\n        // Set initial state.\n        if(iFrame == 0)\n            fragColor.w = 1.0;\n        // Otherwise make state persistent between frames.\n        else\n            fragColor.w = texelFetch(iChannel1, ivec2(fragCoord), 0).w;\n\t\t\n        // Save last mouse state (so holding doesn't trigger a new click event).\n        if(ivec2(fragCoord) == ivec2(0))\n            fragColor.w = iMouse.z;\n\t\t\n        // Gather clicks from the text bits and toggle them.\n        if(iMouse.z > 0.0 && iMouse.z != texelFetch(iChannel1, ivec2(0), 0).w && iMouse.x < 16.0 * 12.0 * LetterSpacing){\n            // Approximate text bounding boxes.\n            float y = 13.0 + R.y - iMouse.y;\n            int row = int(y/(16.0*2.0*LetterSpacing));\n            // Toggle the value.\n            if(ivec2(fragCoord) == ivec2(0, row))\n                fragColor.w = float(1-int(texelFetch(iChannel1, ivec2(0, row), 0).w));\n        }\n        \n        fragColor.rgb -= drawAllText(fragCoord);\n    }\n    #endif //USE_TEXT_RENDERING\n    \n    // Save triangle vertex states and positions to alpha channel.\n    {\n             if(ivec2(fragCoord) == ivec2(1,0)) fragColor.w = float(AGrab);\n        else if(ivec2(fragCoord) == ivec2(2,0)) fragColor.w = float(BGrab);\n        else if(ivec2(fragCoord) == ivec2(3,0)) fragColor.w = float(CGrab);\n        else if(ivec2(fragCoord) == ivec2(1,1)) fragColor.w = APos.x;\n        else if(ivec2(fragCoord) == ivec2(1,2)) fragColor.w = APos.y;\n        else if(ivec2(fragCoord) == ivec2(2,1)) fragColor.w = BPos.x;\n        else if(ivec2(fragCoord) == ivec2(2,2)) fragColor.w = BPos.y;\n        else if(ivec2(fragCoord) == ivec2(3,1)) fragColor.w = CPos.x;\n        else if(ivec2(fragCoord) == ivec2(3,2)) fragColor.w = CPos.y;\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"}]}