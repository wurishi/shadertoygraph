{"ver":"0.1","info":{"id":"fl3GDX","date":"1637159685","viewed":167,"name":"ðŸ¤¯WaterðŸŒŠLabyrinth (Fractal)","username":"rmmcal","description":"Labyrinth (Fractal) - asymmetrical / symmetrical\nWater Simulator\nDraw obstacles","likes":12,"published":1,"flags":32,"usePreview":0,"tags":["fractal","simulation","water","draw","labyrinth"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/////////////////////////////////////////////////////////////\n//               Labyrinth (Fractal)                     ////\n/////////////////////////////////////////////////////////////\n// Brasil/Amazonas/Manaus\n// Created by Rodrigo Cal (twitter: @rmmcal)\n// - Published: 2021/11\n// https://www.shadertoy.com/view/fl3GDX\n/////////////////////////////////////////////////////////////\n\nvec3 hsv2rgb(float v){\n\treturn abs(fract(v + vec3(3, 2, 1) / 3.) - .5) * 6. - 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n   \n    fragColor = texture(iChannel2,uv);\n\n    if (uv.x < .25 && uv.y < .25){\n        vec4 txb = texture(iChannel1, 1.0 - ( uv * vec2(1,1))*4.0);\n        fragColor = mix(clamp(fragColor, 0., 1.0), txb, .75);\n        fragColor = mix(fragColor, fragColor*vec4(4.0), txb.r);\n        \n    }\n\n    if (uv.x < .25 && uv.y > .75){\n        vec4 txb = texture(iChannel0, 1.0 - ( (uv-vec2(0,.75)) * vec2(1,1))*4.0);\n        fragColor = mix(fragColor, 1.-txb, .5);\n        fragColor = mix(fragColor, vec4(1.0), 1.-txb.g);\n        \n    }\n     \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.xy -= 0.5;\n    float ra = iResolution.x/iResolution.y;\n    uv.x *= iResolution.x/iResolution.y;\n    //uv.y *= iResolution.y/iResolution.x;\n    \n    uv *= 1.1;\n    \n    vec2 p = uv;\n   // uv\n    //(uv-.5);\n    \n    vec3 c  = vec3(1.0);\n    vec3 cb = vec3(0.9);\n    float s = 0.005;\n    \n    float s1 = 0.505;\n    float m =  smoothstep(s, 0.0, ((p.x+s1)*(p.x-s1))/((p.y+s1)*(p.y-s1))  );\n   \n    float q = .9;\n    vec2 q1 = vec2(-1.0, +1.0)*q;\n    vec2 q2 = vec2(-1.0, -1.0)*q;\n    vec2 q3 = vec2(+1.0, -1.0)*q;\n    vec2 q4 = vec2(+1.0, +1.0)*q;\n    \n    vec2 p1 = p - 0.5;\n    vec2 p2 = p + 0.5;\n\n    cb = vec3(1,.0, 0.0);\n    float sb = s;\n    float sa = s;\n      p *= 4.0;\n      float k = 3.0;\n \n   if (fragCoord.x <= 1.0 || fragCoord.y <= 1.0 || \n   \n   fragCoord.x >= iResolution.x-1. || fragCoord.y >= iResolution.y-1. )\n              c = vec3(1,0,0);\n              c = mix(c,vec3(1,0,0), smoothstep(0.01,0., abs(sdBox(p,vec2(.5)))    ));\n  \n    for (float i = 1.0; i < 6.; i++){\n           \n           \n       if (iTime>1.0 && fract(iTime*.2345)*5.0 + 1.0 < i ){\n           break;\n        }\n     \n        \n        sb = pow(s,1.0/i);\n        sa = pow(s,i);\n        \n        sb = ra*.02/k;\n    \n        //c = mix(c,vec3(0,0,1), smoothstep(s*1., -s*2., -1.50*sb+sdSegment(p, vec2(-1.,1.), vec2( 1.,-1.) )     ));\n\n        c = mix(c,cb, smoothstep(s*1., -s*2., -sb+sdSegment(p, vec2(-1.,1.), vec2( 1.,-1.) )     ));\n       \n\n        k /= 2.0;\n        \n        vec2 pr = p;\n        p /= 2.0;\n     \n        p = mod(p+.25,1.0)-.25;\n        p -= 0.5;\n        p *= 4.0;\n        p.xy = pr.x < 0.0 && pr.y < 0.0 ? p.yx*vec2( -1,  1 ) : p.xy;\n        p.xy = pr.x > 0.0 && pr.y < 0.0 ? p.yx*vec2(  1, -1 ) : p.xy;\n        p.xy = pr.y < 0.0 && pr.y > 0.0 ? p.yx*vec2( -1, -1 ) : p.xy;\n        p.xy = pr.x > 0.0 && pr.y > 0.0 ? p.yx*vec2(  1,  1 ) : p.xy;\n       \n    }\n\n    fragColor = vec4(c,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 r = vec3(1.0/iResolution.xy,0.0);\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel1,uv);\n\n    if (texture(iChannel1,vec2(1.0-r.x,.5)).y>0.5 || iTime < 1.0 ){ // || iTime < TB\n        vec4 c = texture(iChannel0,uv);\n        fragColor = vec4(1.0 - c.g, 0.,1.-c.b,0.);;\n      \n    }\n    else\n    {\n        vec4 vc = texture(iChannel1,uv,0.0);\n      \n        fragColor = vc;\n        if (vc.r <= 0. )\n        {\n            float k = 0.01;\n            \n            vec2 v[8];\n            v[0] = -r.zy;\n            v[1] =  r.zy;\n            v[2] = -r.xz;\n            v[3] =  r.xz;\n            \n            v[4] =  r.xy*vec2(-1,-1);\n            v[5] =  r.xy*vec2(-1, 1);\n            v[6] =  r.xy*vec2( 1,-1);\n            v[7] =  r.xy*vec2( 1, 1);\n            \n            for (int i = 0; i < 8; i++)\n            {\n                vec4 vt = texture(iChannel1,uv+v[i].xy,0.0);\n            \n                if (vt.g > 0.0)\n                {\n                    float len = 1.-pow(length(v[i].xy)/length(r.xy),.3);\n                    fragColor = vec4(0.0, vc.g+=k*len, 0.0, 1.0);\n                }\n            }\n        }\n    }\n    \n    if (sign(iMouse.z)>0.0)\n    {\n        fragColor.rg = vec2(mix( fragColor.rg, vec2(1,-1), smoothstep(.05, 0.045,length(  (uv-1.0+iMouse.xy*4./iResolution.xy) *vec2(iResolution.x/iResolution.y,1.))   )));\n        \n    }\n    \n    float s = r.x*25.0;\n    if(uv.x <= s && uv.y <= s + .5 && uv.y >= .5)\n        fragColor = vec4(0.0, 1.0, 0.0, 0.0);\n \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":" \n////////////////////////////////\n\n//https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n//https://www.shadertoy.com/view/ssySDV\nfloat sdBox( vec3 p, vec3 b )\n{ \n    vec3 d = abs(p) - b;   \n    return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); \n}\n\n\nfloat intersectSDF(float distA, float distB)\n{ \n    return max(distA, distB);\n    }\nfloat unionSDF(float distA, float distB)\n{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n{ return max(distA, -distB);}\n    \n///////////////////////////////////////////////////////////\n//@morgan3d 1D, 2D & 3D Value Noise\n// https://www.shadertoy.com/view/4dS3Wd\n\n// For multiple octaves\n#define NOISE fbm\n#define NUM_NOISE_OCTAVES 5\n\n// Precision-adjusted variations of https://www.shadertoy.com/view/4djSRW\nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\nfloat hash(vec2 p) {vec3 p3 = fract(vec3(p.xyx) * 0.13); p3 += dot(p3, p3.yzx + 3.333); return fract((p3.x + p3.y) * p3.z); }\n\n\nfloat noise(vec2 x) {\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n\n\t// Four corners in 2D of a tile\n\tfloat a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    // Simple 2D lerp using smoothstep envelope between the values.\n\t// return vec3(mix(mix(a, b, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tmix(c, d, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tsmoothstep(0.0, 1.0, f.y)));\n\n\t// Same code, with the clamps in smoothstep and common subexpressions\n\t// optimized away.\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n \n\nfloat fbm(vec2 x, int freq) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100);\n\t// Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n\tfor (int i = 0; i < freq; ++i) {//NUM_NOISE_OCTAVES\n\t\tv += a * noise(x);\n\t\tx = rot * x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n\n\nconst float pi = 3.1415926;\nconst float pi2 = 2.*pi;\nconst float rad = pi/180.;\nfloat rnd ;\n\nmat2 rotate(float x){\n    float c = cos(x);\n    float s = sin(x);\n    return mat2(c,s,-s,c);\n}\n  \nvec4 v(float v){\n    return vec4(v, 0.,0.,0.);\n}\nvec4 v(float v, float v2){\n    return vec4(v, v2, 0.,0.);\n}\n\nvec4 vmin(vec4 v1, vec4 v2){\n    return v1.x < v2.x ? v1 : v2;\n}\n\nvec4 vmin(vec4 v1, float v2){\n    return v1.x < v2 ? v1 : v(v2);\n}\n\nvec4 vmin(vec4 v1, float v2, float v3){\n    return v1.x < v2 ? v1 : v(v2,v3);\n}\n\n\nvec4 vminS( vec4 d1, float d2, float k, float id ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1.x)/k, 0.0, 1.0 );\n    return v( mix( d2, d1.x, h ) - k*h*(1.0-h),    h >= .55 ? d1.y : id ); \n}\n\nvec4 vmaxS( vec4 d2, float d1, float k, float id ) {\n    float h = clamp( 0.5 - 0.5*(d2.x+d1)/k, 0.0, 1.0 );\n    return v( mix( d2.x, -d1, h ) + k*h*(1.0-h), d2.y ); \n}\n\nvec4 vminI( vec4 d2, float d1, float k, float id ) {\n    float h = clamp( 0.5 - 0.5*(d2.x-d1)/k, 0.0, 1.0 );\n    return v( mix( d2.x, d1, h ) + k*h*(1.0-h) , d2.y );\n}\n\nbool water = true;\nvec4 dist(vec3 p)\n{\n    vec4 d = v(1.0);\n    vec2 ps = ((p.xy+vec2(3., 2.)))/1.0;\n    float f = .1;\n    d = min(d, .1);\n   \n    vec2 tuv = (p.xy+vec2(2.3,1.7))*1.;\n    tuv *= 100.0/iResolution.xy ;\n   \n    vec4 tb = texture(iChannel1, tuv);\n    float v1  = smoothstep(.8,  1., ( abs( 1.- tb.x) ));\n    \n    // floor\n    d = vmin(d, 1.- p.z + 0.0, 0.0);\n   \n    // maze\n    d = vmin(d,  intersectSDF(v1, sdBox(p-vec3(0.,0.,1.0), vec3(vec2(14.),.1))), 2.0);\n    \n    // maze workaround -.-\n    d.x = min(d.x, max(0.005, -p.z+.7));\n   \n    if (water){\n        // show water\n        float v2 = smoothstep(.0,  1., ( 1.- clamp(tb.y,0.,1.0)));\n\n        float wave = cos(cos(p.x*11.01) + cos((p.y+.5)*11.01)+ cos((p.x*.5+.5)*11.01) + iTime)*.0;\n       \n        wave = ((((v2)*.1)))-.01;\n\n        vec3 pw = p*.5;\n        wave +=cos(cos(pw.x*5.01) + cos((pw.y+.5)*11.01)+ cos((pw.x*.5+.5)*11.01) + iTime)*.005-.005;\n\n        pw = p*1.0;\n        wave +=cos(cos(pw.x*5.01) + cos((pw.y+.5)*11.01)+ cos((pw.x*.5+.5)*11.01) + iTime)*.01;\n        pw = p*2.0;\n        \n        wave +=cos(cos(pw.x*13.01) + cos((pw.y*1.2+.5)*11.01)+ cos((pw.x*.3+.5)*11.01) + iTime)*.003-.003;\n        pw = p*2.0;\n        \n        wave +=cos(cos(pw.x*11.01) + cos((pw.y*.8+.3)*11.01)+ cos((pw.x*.2+.3)*11.01) + iTime)*.003-.003;\n\n        pw = p*2.0;\n        wave +=cos(cos(pw.x*9.01) + cos((pw.y*.8+.2)*11.01)+ cos((pw.x*.2+.8)*11.01) + iTime)*.003-.003;\n\n        wave = wave / (sqrt(abs(wave*4.))*1.0)-.01;\n       \n        d = vmin(d, 1.- p.z + wave, 1.0);\n        d.w = wave*2.;\n    }\n       \n    return d;\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec2 d = vec2(0., 0.01);\n    float x = dist(p-d.yxx).x;\n    float y = dist(p-d.xyx).x;\n    float z = dist(p-d.xxy).x;\n    return normalize(vec3(x,y,z)-dist(p).x);\n}\n\nvec3 hsv2rgb(float v){\n\treturn abs(fract(v + vec3(3, 2, 1) / 3.) - .5) * 6. - 1.;\n}\n\n\n/**\n//https://www.shadertoy.com/view/WlKBDw\nmat3 lookAt(in vec3 pos, in vec3 target) {\n    vec3 f = normalize(target - pos);         // Forward\n    vec3 r = normalize(vec3(-f.z, 0.0, f.x)); // Right\n    vec3 u = cross(r, f);                     // Up\n    return mat3(r, u, f);\n}\n/**/\n\nmat3 lookAt2(in vec3 pos, in vec3 target) {\n    vec3 f = normalize(target - pos);         // Forward\n    vec3 r;\n    r.xz = normalize(f.xz*rotate(pi/2.0));    // Right\n    vec3 u = cross(r, f);                     // Up\n     r*=-1.;\n    return mat3(r, u, f);\n}\n\nfloat brick(vec3 p3d){\n  \tp3d.x  += p3d.z;\n    vec2 p = p3d.xy;\n\tvec2 brickPos = p.xy;\n\tbrickPos.x += floor(brickPos.y * 3.0) * 0.5;\n\tbrickPos = fract(brickPos * vec2(1.0, 3.0)+vec2(0.,.5));\n  \n    return  1.-\n        smoothstep(-0.1,0.0, +.0+abs(brickPos.x*2.-1.)-.1)*\n        smoothstep(-0.2,0.21, -.0+abs((brickPos.y)*2.-1.)-.1);\n}\n\nfloat hex(vec2 p) {\n\tp.x *= 0.57735*2.0;\n\tp.y += mod(floor(p.x), 2.0)*0.5;\n\tp = abs((mod(p, 1.0) - 0.5));\n\treturn abs(max(p.x*1.5 + p.y, p.y*2.0) - 1.0);\n}\n\nfloat checkin(float x, float y, float w, float h){\n    return x>=0.0&&x<w && y>=0.0&&y<h ? 1.0 : 0.0; \n}\n\nvec3 getColor(vec3 p, vec3 pn, vec4 hit, vec2 uv, float t){\n\n    vec3 c;\n    c += pn.z*.0;\n  \n    c += (normalize(pn-vec3(0.,0., .7)).z);\n    \n    if (hit.y==0.0) { \n        // floor \n        float k = 30.0;\n        c = pn.zzz *(.2+  .7*smoothstep(0.,.01, cos(p.x*k)*sin(p.y*k)));\n    }\n   \n    if (hit.y==1.0) {\n        // water\n        c = abs(pn.zzz)*vec3(0.0,1.,2.);\n        c += vec3(pow(pn.z+.01, 128.));\n    }\n    \n    if (hit.y==2.0) {\n        // up\n        \n        float k = 10.0;\n        c = (1.-((pn.xyz)*.5+.5)) * (.5+  .5*smoothstep(0.,.01, cos(p.x*k)*sin(p.y*k)));\n        c += vec3(smoothstep(0.2,.0, hex(p.xy*7.0) ))*0.2;\n        \n        c+= hsv2rgb(p.x*.01+p.y*.02+p.z*.03+iTime*0.1)*0.4;\n        c = mix(c, vec3(0.2), brick(p*3.0) * checkin(p.x+2., p.y+1.5, 30.1, 30.01));\n        c = mix(c, vec3(0.4,0.2, 1.2),  checkin(p.x+2.4, p.y+1.8, 6.7, 3.8));\n         \n        c *= pn.zzz *(.5+  .5*fbm(p.xy*20.0, 3));\n    }\n \n    if (t>40.) {\n        float v = 1.0/((t-40.0)*.3+1.0);\n        c *= v;\n        c += vec3(smoothstep(0.2,.0, hex(p.xy*7.0) )*v);\n    }\n    \n    \n    return c;\n}\n\n\nvoid raymarching(inout vec3 p, vec3 d, inout vec4 hit, inout float t){\n\n    for (int i = 0 ; i < 300; i++)\n    {\n         hit = dist(p);           // current \n        //hitn = dist(p+ d*hit.x); // next \n        float h=hit.x; \n        //float h2=hitn.x;\n        //h = (h+h2)/2.0;\n\n        //float y = h*h/(2.0*pd);\n        //float k = sqrt(h*h-y*y);\n        //pd = h;\n        //h = min(h, h/max(0.0, t-y));\n\n        if (h < 0.001)\n         break;\n        t+=h*(t+0.03);\n        \n        if (t>115.0)\n         break;\n        \n        \n        p += d*h;\n      \n    }\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 pc = (uv-.5)*vec2(1, iResolution.y/iResolution.x);\n\n    vec3 p = vec3(0.);\n    \n    float a = ((cos(iTime*.1)+1.0)*cos(iTime*.2));\n   \n    // cam near\n    float sr = (1.+cos(iTime*.2))*.5;\n    p = vec3(sr*cos(a),sr*sin(a), 0.2);\n    p.z+=(cos(iTime*.3)-1.)*.5;\n    p.x+=(cos(iTime*.5)-1.)*1.6+1.6;\n  \n    vec3 d = normalize(vec3(pc,1.0));\n    d.yz *= rotate(pi/3.0 -(cos(iTime*.15)*.5+.5)*.25 - length(p.xy)*.1   );//- mouse.y*.5- mouse.y*(+3.3 -sr*.38)\n    d.xy *= rotate(-a+pi*3./2.0);\n \n    // cam far\n    float k = 2.0;\n    a= iTime*.3;\n    float ta = cos(iTime*.7)*.5+.5;\n    p = mix (p,  vec3(cos(a)*k*2.0+2.0,sin(a)*k+2.0,-1.+sin(iTime*.5)), ta);\n    d = mix (d, normalize(vec3(pc,1.0)) * lookAt2(p, vec3(0.,-1., 2.)), ta);\n\n    ta = sin(iTime*.2)*.5+.5;\n    p  =  mix (p,  vec3(1.,1.,-5), ta);\n    d  = mix (d, normalize(vec3(pc,1.0)) * lookAt2(p, vec3(1.,0., 2.)), ta);\n \n    float t = 0.;\n    \n    vec3 c=vec3(0.0);\n    vec4 hit;\n    \n    raymarching(p,d, hit, t);\n\n    vec3 pn = getNormal(p);\n    pn = getNormal(p);\n    c = getColor( p, pn, hit, uv, t);\n    \n    water =false;\n    raymarching(p,d, hit, t);\n       \n    vec3 c2 = getColor( p, pn, hit, uv, t);\n    c = mix (c, c2, .7);\n    fragColor = vec4(c,1.);\n}","name":"Buffer C","description":"","type":"buffer"}]}