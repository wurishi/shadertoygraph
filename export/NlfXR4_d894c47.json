{"ver":"0.1","info":{"id":"NlfXR4","date":"1625195894","viewed":116,"name":"Warped Noise - Andrew","username":"andrew741","description":"Warped noise with a changing color gradient.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// from another shadertoy shader (same one as the gradient noise as this is a part of it)\nvec3 hash( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n// from another shadertoy shader (im not good with creating/inplmenting gradient noise algerithms)\nvec4 noised( in vec3 x )\n{\n    // grid\n    vec3 i = floor(x);\n    vec3 w = fract(x);\n    \n    // cubic interpolant\n    vec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n    \n    // gradients\n    vec3 ga = hash( i+vec3(0.0,0.0,0.0) );\n    vec3 gb = hash( i+vec3(1.0,0.0,0.0) );\n    vec3 gc = hash( i+vec3(0.0,1.0,0.0) );\n    vec3 gd = hash( i+vec3(1.0,1.0,0.0) );\n    vec3 ge = hash( i+vec3(0.0,0.0,1.0) );\n\tvec3 gf = hash( i+vec3(1.0,0.0,1.0) );\n    vec3 gg = hash( i+vec3(0.0,1.0,1.0) );\n    vec3 gh = hash( i+vec3(1.0,1.0,1.0) );\n    \n    // projections\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\n\t\n    // interpolations\n    return vec4( va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z,    // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.z*(ge-ga) + u.x*u.y*(ga-gb-gc+gd) + u.y*u.z*(ga-gc-ge+gg) + u.z*u.x*(ga-gb-ge+gf) + (-ga+gb+gc-gd+ge-gf-gg+gh)*u.x*u.y*u.z +   // derivatives\n                 du * (vec3(vb,vc,ve) - va + u.yzx*vec3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + u.zxy*vec3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh) ));\n}\n\n\n// samples the gradient noise and returns on height\nfloat SampleNoise(vec3 p)\n{\n    float h = noised(p).x;\n    h += noised(p*2. + 100.).x * 0.5;\n    h += noised(p*4. - 100.).x * 0.25;\n    h += noised(p*8. + 1000.).x * 0.125;\n    return h / (1.865);\n}\n\n\n// sample the gradient noise and returns 3 different heights (same as finding 3 different gradient noises)\nvec3 SampleNoiseV3(vec3 p)\n{\n    vec3 h = noised(p).rgb;\n    h += noised(p*2. + 100.).rgb * 0.5;\n    h += noised(p*4. - 100.).rgb * 0.25;\n    h += noised(p*8. + 1000.).rgb * 0.125;\n    return h / (1.865);\n}\n\n\n\n// gets the color based on the height\nvec3 colorGrade(float height)\n{\n    height *= 1.3;\n    vec3 col = SampleNoiseV3(vec3(height * 6., 0., -iTime * 0.3) - 20.);\n    // making it so that all the colors arnt black and also arnt neon\n    col /= pow(dot(col, col), 0.3);\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy*3.+iMouse.xy/60.;\n\n    // finding the amount of the x and y distortion for the noise\n    vec3 n = SampleNoiseV3(vec3(-uv * 0.2 - 5., -iTime * 0.3) - 20.);\n    n /= dot(n, n);\n    // finding the offset\n    vec3 offset = SampleNoiseV3(vec3(uv * 0.25, iTime) + 20.) * vec3(n.x, n.y, 0);\n    offset.x = length(offset.x + offset.y) * max(offset.x, offset.y) * 7.6;\n\n    // finding the color\n    vec3 col = colorGrade(1. - abs(SampleNoise(vec3(uv, iTime) + offset)));\n    \n    fragColor = vec4(col,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}