{"ver":"0.1","info":{"id":"MdG3Dm","date":"1454780291","viewed":177,"name":"3D Hammer","username":"samuelotherion","description":"coming off the track","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["simpleraytraycing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define _t_           iTime\n#define NUM_OF_ARROWS 6\n\n#define ID_ENV_SPHERE 0\n#define ID_ELLIPSOID  1\n#define ID_ARROW      2\n#define I3            mat3( 1., 0., 0.,  0., 1., 0.,  0., 0., 1.)\n\n#define ROTX90        mat3( 1., 0., 0.,  0., 0., 1.,  0.,-1., 0.)\n#define ROTX270       ( ROTX90 * ROTX90 * ROTX90 )\n\n#define ROTY90        mat3( 0., 0.,-1.,  0., 1., 0.,  1., 0., 0.)\n#define ROTY180       ( ROTY90 * ROTY90 )\n#define ROTY270       ( ROTY180 * ROTY90 )\n\n#define ROTZ90        mat3( 0., 1., 0., -1., 0., 0.,  0., 0., 1.)\n#define ROTZ270       ( ROTZ90 * ROTZ90 * ROTZ90 )\n\nconst vec3 \n    cArrowDims = vec3( .9, .4, .4 );\n\nstruct Location { vec3 pos, size; mat3 xyz; };\nstruct EnvSphere { int id; Location loc; };\nstruct Ellipsoid { int id; Location loc; };\nstruct Arrow { int id; Location loc; float ratio; };\nstruct Scene { vec2 xy; vec3 xy0, eye, ray, rayN; Ellipsoid ellipsoid; EnvSphere envSphere; Arrow arrows[ NUM_OF_ARROWS ]; };\nstruct Input { vec3 eye, rayN; };\nstruct Output { bool hit; vec3 point, norm, col; float dist; };\n    \nScene\n    scene;\n    \nmat3\n    crss( in vec3 p_vecLHS ) {\n        \n        return mat3( +0., -p_vecLHS.z, +p_vecLHS.y, +p_vecLHS.z, +0., -p_vecLHS.x, -p_vecLHS.y, +p_vecLHS.x, +0. );\n    }\n\nmat3\n    parallel( in vec3 p_axe ) {\n        \n        float\n            aa = dot( p_axe, p_axe );\n        \n        return mat3( p_axe.x * p_axe, p_axe.y * p_axe, p_axe.z * p_axe ) / aa;\n    }\n\nmat3\n    parallelN( in vec3 p_axeN ) {\n        \n        return mat3( p_axeN.x * p_axeN, p_axeN.y * p_axeN, p_axeN.z * p_axeN );\n    }\n\nmat3\n    orthogonal( in vec3 p_axeN ) {\n        \n        return I3 - parallelN( p_axeN );\n    }\n\nmat3\n    rot( vec3 p_axe, float p_alpha ) {\n        \n        vec3\n            n = normalize( p_axe );\n        \n        return parallel( n ) + cos( p_alpha ) * orthogonal( n ) + sin( p_alpha ) * crss( n );\n    }\n\nvoid\n    calcArrowsForEllipsoid( ) {\n        \n        mat3\n            dir = transpose( scene.ellipsoid.loc.xyz );\n        \n        scene.arrows[ 0 ] = Arrow( ID_ARROW, Location( scene.ellipsoid.loc.pos + ( scene.ellipsoid.loc.size.x + cArrowDims.x ) * scene.ellipsoid.loc.xyz[ 0 ], cArrowDims, dir ), .8 );\n        scene.arrows[ 1 ] = Arrow( ID_ARROW, Location( scene.ellipsoid.loc.pos - ( scene.ellipsoid.loc.size.x + cArrowDims.x ) * scene.ellipsoid.loc.xyz[ 0 ], cArrowDims, ROTY180 * dir ), .8 );\n        scene.arrows[ 2 ] = Arrow( ID_ARROW, Location( scene.ellipsoid.loc.pos - ( scene.ellipsoid.loc.size.y + cArrowDims.x ) * scene.ellipsoid.loc.xyz[ 1 ], cArrowDims, ROTZ90  * dir ), .8 );\n        scene.arrows[ 3 ] = Arrow( ID_ARROW, Location( scene.ellipsoid.loc.pos + ( scene.ellipsoid.loc.size.y + cArrowDims.x ) * scene.ellipsoid.loc.xyz[ 1 ], cArrowDims, ROTZ270 * dir ), .8 );\n        scene.arrows[ 4 ] = Arrow( ID_ARROW, Location( scene.ellipsoid.loc.pos - ( scene.ellipsoid.loc.size.z + cArrowDims.x ) * scene.ellipsoid.loc.xyz[ 2 ], cArrowDims, ROTY270 * dir ), .8 );\n        scene.arrows[ 5 ] = Arrow( ID_ARROW, Location( scene.ellipsoid.loc.pos + ( scene.ellipsoid.loc.size.z + cArrowDims.x ) * scene.ellipsoid.loc.xyz[ 2 ], cArrowDims, ROTY90  * dir ), .8 );\n    }\n\nvoid\n    init( vec2 p_xy ) {\n        \n\tmat3\n    \trotAxe = rot( vec3( 0., cos( 2.123 * _t_ ), 1. ), .91 * _t_ );\n        \n        //scene.ellipsoid.loc.xyz = rotAxe;\n        scene.xy   = vec2( p_xy / iResolution.xy - .5 ) * vec2( iResolution.x / iResolution.y, 1. );\n        scene.xy0  = vec3( scene.xy, 0. );\n        scene.eye  = vec3( 0., 0., 1.5 );\n        scene.ray  = scene.eye - scene.xy0;\n        scene.rayN = normalize( scene.ray );\n        scene.envSphere = EnvSphere( ID_ENV_SPHERE, Location( vec3( +0., +0., +0. ), vec3( 10., 10., 10. ), I3 ) );\n        scene.ellipsoid = Ellipsoid( ID_ELLIPSOID,  Location( vec3( 2. * cos( .3 * _t_ ), +0., -7. + 2. * sin( .3 * _t_ ) ), .25 * vec3( 3. + 2.95 * sin( 3.5 * _t_ ) , 3.0 + 2.95 * sin( 3.5 * _t_ + 2. / 3. * 3.14 ) , 3.0 + 2.95 * sin( 3.5 * _t_+ 4. / 3. * 3.14 ) ), rotAxe ) );\n    }\n\nfloat\n    setOutput( inout Output p_o, in vec3 p_pnt, in vec3 p_eye, in vec3 p_norm, in vec3 p_col ) {\n        \n        vec3\n            dist = p_pnt - p_eye;\n        \n        float\n            distSqr = dot( dist, dist );\n        \n        if( distSqr < p_o.dist ) {\n        \n        \tp_o.hit   = true;\n            p_o.point = p_pnt;\n            p_o.norm  = p_norm;\n            p_o.col   = p_col;\n            p_o.dist  = distSqr;\n            \n            return distSqr;\n        }\n        \n        return 10000000000000000000.;\n    }\n\nvoid\n    intersectArrow( inout Output p_out, in Input p_in, in Arrow p_arrow ) {\n    \n        p_out.hit  = false;\n        p_out.dist = 100000000000.;\n        p_out.col = vec3( 0., 0., 0. );\n        \n        vec3\n            eye2Pos    = p_in.eye - p_arrow.loc.pos,\n            eye2PosXYZ = p_arrow.loc.xyz * eye2Pos,\n            rayNXYZ    = p_arrow.loc.xyz * p_in.rayN;\n        \n        vec3\n            front = ( eye2PosXYZ - p_arrow.loc.size ) / rayNXYZ,\n            back =  ( eye2PosXYZ + p_arrow.loc.size ) / rayNXYZ;\n           \n        vec3\n            pxf = eye2PosXYZ - front.x * rayNXYZ,\n            pyf = eye2PosXYZ - front.y * rayNXYZ,\n            pzf = eye2PosXYZ - front.z * rayNXYZ,\n            pxb = eye2PosXYZ - back.x * rayNXYZ,\n            pyb = eye2PosXYZ - back.y * rayNXYZ,\n            pzb = eye2PosXYZ - back.z * rayNXYZ;\n        \n        if( all( lessThan( abs( pxf.yz ), p_arrow.loc.size.yz ) ) ) setOutput( p_out, pxf, eye2PosXYZ, vec3( +1., 0., 0. ) * p_arrow.loc.xyz, mix( texture( iChannel0, pxf.yz ).rgb, vec3( 1., 0., 0. ), pow( sin( .01 * _t_ ), 118. ) ) );\n        if( all( lessThan( abs( pyf.zx ), p_arrow.loc.size.zx ) ) ) setOutput( p_out, pyf, eye2PosXYZ, vec3( 0., +1., 0. ) * p_arrow.loc.xyz, mix( texture( iChannel0, pyf.zx ).rgb, vec3( 0., 1., 0. ), pow( sin( .02 * _t_ ), 118. ) ) );\n        if( all( lessThan( abs( pzf.xy ), p_arrow.loc.size.xy ) ) ) setOutput( p_out, pzf, eye2PosXYZ, vec3( 0., 0., +1. ) * p_arrow.loc.xyz, mix( texture( iChannel0, pzf.xy ).rgb, vec3( 0., 0., 1. ), pow( sin( .03 * _t_ ), 118. ) ) );\n        if( all( lessThan( abs( pxb.yz ), p_arrow.loc.size.yz ) ) ) setOutput( p_out, pxb, eye2PosXYZ, vec3( -1., 0., 0. ) * p_arrow.loc.xyz, mix( texture( iChannel0, pxb.yz ).rgb, vec3( 0., 1., 1. ), pow( sin( .04 * _t_ ), 118. ) ) );\n        if( all( lessThan( abs( pyb.zx ), p_arrow.loc.size.zx ) ) ) setOutput( p_out, pyb, eye2PosXYZ, vec3( 0., -1., 0. ) * p_arrow.loc.xyz, mix( texture( iChannel0, pyb.zx ).rgb, vec3( 1., 0., 1. ), pow( sin( .05 * _t_ ), 118. ) ) );\n        if( all( lessThan( abs( pzb.xy ), p_arrow.loc.size.xy ) ) ) setOutput( p_out, pzb, eye2PosXYZ, vec3( 0., 0., -1. ) * p_arrow.loc.xyz, mix( texture( iChannel0, pzb.xy ).rgb, vec3( 1., 1., 0. ), pow( sin( .06 * _t_ ), 118. ) ) );\n    }\n\nvoid\n    intersectEllipsoid( inout Output p_out, in Input p_in, in Ellipsoid p_ellipsoid ) {\n    \n        p_out.hit  = false;\n        p_out.dist = 100000000000.;\n        p_out.col = vec3( 0., 0., 0. );\n        \n        vec3\n            eye2Pos    = p_in.eye - p_ellipsoid.loc.pos,\n            eye2PosXYZ = eye2Pos * p_ellipsoid.loc.xyz,\n            rayNXYZ    = p_in.rayN * p_ellipsoid.loc.xyz;\n        \n        vec3\n            front = ( eye2PosXYZ - p_ellipsoid.loc.size ) / rayNXYZ,\n            back =  ( eye2PosXYZ + p_ellipsoid.loc.size ) / rayNXYZ;\n           \n        vec3\n            pxf = eye2PosXYZ - front.x * rayNXYZ,\n            pyf = eye2PosXYZ - front.y * rayNXYZ,\n            pzf = eye2PosXYZ - front.z * rayNXYZ,\n            pxb = eye2PosXYZ - back.x * rayNXYZ,\n            pyb = eye2PosXYZ - back.y * rayNXYZ,\n            pzb = eye2PosXYZ - back.z * rayNXYZ;\n        \n        if( all( lessThan( abs( pxf.yz ), p_ellipsoid.loc.size.yz ) ) ) setOutput( p_out, pxf, eye2PosXYZ, vec3( +1., 0., 0. ) * p_ellipsoid.loc.xyz, mix( texture( iChannel1, pxf.yz ).rgb, vec3( 1., 0., 0. ), pow( sin( .1 * _t_ ), 118. ) ) );\n        if( all( lessThan( abs( pyf.zx ), p_ellipsoid.loc.size.zx ) ) ) setOutput( p_out, pyf, eye2PosXYZ, vec3( 0., +1., 0. ) * p_ellipsoid.loc.xyz, mix( texture( iChannel1, pyf.zx ).rgb, vec3( 0., 1., 0. ), pow( sin( .2 * _t_ ), 118. ) ) );\n        if( all( lessThan( abs( pzf.xy ), p_ellipsoid.loc.size.xy ) ) ) setOutput( p_out, pzf, eye2PosXYZ, vec3( 0., 0., +1. ) * p_ellipsoid.loc.xyz, mix( texture( iChannel1, pzf.xy ).rgb, vec3( 0., 0., 1. ), pow( sin( .3 * _t_ ), 118. ) ) );\n        if( all( lessThan( abs( pxb.yz ), p_ellipsoid.loc.size.yz ) ) ) setOutput( p_out, pxb, eye2PosXYZ, vec3( -1., 0., 0. ) * p_ellipsoid.loc.xyz, mix( texture( iChannel1, pxb.yz ).rgb, vec3( 0., 1., 1. ), pow( sin( .4 * _t_ ), 118. ) ) );\n        if( all( lessThan( abs( pyb.zx ), p_ellipsoid.loc.size.zx ) ) ) setOutput( p_out, pyb, eye2PosXYZ, vec3( 0., -1., 0. ) * p_ellipsoid.loc.xyz, mix( texture( iChannel1, pyb.zx ).rgb, vec3( 1., 0., 1. ), pow( sin( .5 * _t_ ), 118. ) ) );\n        if( all( lessThan( abs( pzb.xy ), p_ellipsoid.loc.size.xy ) ) ) setOutput( p_out, pzb, eye2PosXYZ, vec3( 0., 0., -1. ) * p_ellipsoid.loc.xyz, mix( texture( iChannel1, pzb.xy ).rgb, vec3( 1., 1., 0. ), pow( sin( .6 * _t_ ), 118. ) ) );\n    }\n\nvec4\n    intersect( ) {\n    \n       Input\n            inp = Input( scene.eye, scene.rayN );\n      \n        Output\n            outp,\n            outpc;\n        \n        outp.dist = 1000000000000.;\n        outp.col  = vec3( 0. );\n        \n        \n        for( int i = 0; i < NUM_OF_ARROWS; i++ ) {\n            \n\t        outpc.hit = false;\n            intersectArrow( outpc, inp, scene.arrows[ i ] ); \n            \n            if( outpc.hit && outpc.dist < outp.dist ) {\n                \n                outp = outpc;\n            }                \n        }\n        \n        outpc.hit = false;\n        intersectEllipsoid( outpc, inp, scene.ellipsoid ); \n\n        if( outpc.hit && outpc.dist < outp.dist ) {\n\n            outp = outpc;\n        }                \n        \n        \n       \n//        return vec4( outp.col * 2. / 3.14 * asin( dot( outp.norm, inp.rayN ) ) , 1. );\n        return vec4( outp.col * clamp( dot( outp.norm, normalize( vec3( -1., +1., +2. ) - outp.point ) ), 0., 1. ) , 1. );\n    }\n\nvoid\n    mainImage( out vec4 p_c, in vec2 p_xy ) {\n        \n        init( p_xy );\n       \n        calcArrowsForEllipsoid( );\n\n        p_c = intersect( );\n       \n    }","name":"Image","description":"","type":"image"}]}