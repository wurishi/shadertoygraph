{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"vec4 quaternion(vec3 p, float a)\n{\n\treturn vec4(p*sin(a/2.0), cos(a/2.0));\n}\n\nvec3 qtransform(vec4 q, vec3 p)\n{\n\treturn p+2.0*cross(cross(p, q.xyz)-q.w*p, q.xyz);\n}\n\nvec2 hash2(float n)\n{\n\tvec2 p = vec2(dot(vec2(n, 12.34), vec2(127.1, 311.7)),\n\t\t\t\t  dot(vec2(n, 45.67), vec2(269.5, 183.3)));\n\treturn (2.0*fract(sin(p)*43758.5453)-1.0);\n}\n\nvec3 hash(float n)\n{\n\treturn vec3(8.0*hash2(n), n*20.0);\n}\n\nfloat sp(float p0, float p1, float p2, float p3, float t)\n{\n\treturn 0.5*(2.0*p1+(-p0+p2)*t+\n\t\t(2.0*p0-5.0*p1+4.0*p2-p3)*t*t+\n\t\t(-p0+3.0*p1-3.0*p2+p3)*t*t*t);\n}\n\nvec3 sp3(vec3 p0, vec3 p1, vec3 p2, vec3 p3, float t)\n{\n\treturn vec3(\n\t\tsp(p0.x, p1.x, p2.x, p3.x, t),\n\t\tsp(p0.y, p1.y, p2.y, p3.y, t),\t\n\t\tsp(p0.z, p1.z, p2.z, p3.z, t));\t\n}\n\nvec3 coord(float t)\n{\n\tfloat i = floor(t);\n\tvec3 p0 = hash(i-1.0);\n\tvec3 p1 = hash(i);\n\tvec3 p2 = hash(i+1.0);\n\tvec3 p3 = hash(i+2.0);\n\treturn sp3(p0, p1, p2, p3, fract(t));\t\n}\n\nfloat helix(vec3 p)\n{\n\tfloat a = atan(p.y,p.x)*0.1;\n\tfloat b = mod(p.z,0.6283)-0.314159;\n\ta = abs(a-b);\n\tif (a>0.314159) a = 0.6283-a;\n\treturn length(vec2(length(p.xy)-0.3, a))-0.2;\n}\n\nfloat helixBall(vec3 p)\n{\n\tfloat a = atan(p.y,p.x)*0.1;\n\tfloat b = mod(p.z,0.6283)-0.314159;\n\ta = abs(a-b);\n\tif (a>0.314159) a = 0.6283-a;\n\treturn length(vec2(length(p)-1.8, a))-0.15;\n}\n\nfloat de(vec3 p)\n{\n\tp.xy = mod(p.xy,8.0)-4.0;\n\tp.z = mod(p.z-10.0,50.0)-25.0;\n\tvec4 q = quaternion(vec3(1.0,0.1,0.0), -iTime);\n\tp = qtransform(q, p);\n\treturn helixBall(p);\n}\n\nfloat de2(vec3 p)\n{\n\tvec3 p0 = p;\n\tp0.x = mod(p0.x,10.0)-5.0;\n\tp0.z = mod(p0.z,50.0)-10.0;\n\tvec3 p1 = p;\n\tp1.y = mod(p1.y,10.0)-5.0;\n\tp1.z = mod(p1.z,50.0)-10.0;\n\treturn min(helix(p0.xzy), helix(p1.yzx));\n}\n\nvec2 map(vec3 p)\t\n{\n\tfloat d0 = de(p);\n\tfloat d1 = de2(p);\n\tfloat c = 0.0;\n\tif (d0 < d1) c = 1.0;\n\tfloat d = min(d0, d1);\n\treturn vec2(d, c);\t\n}\n\nvec3 calcNormal(vec3 p)\n{\n\tvec3 eps = vec3(0.0001, 0.0, 0.0);\n\tvec3 nor = vec3(\n\t\tmap(p+eps.xyy).x-map(p-eps.xyy).x,\n\t\tmap(p+eps.yxy).x-map(p-eps.yxy).x,\n\t\tmap(p+eps.yyx).x-map(p-eps.yyx).x);\n\treturn normalize(nor);    \n}\n\nvec3 render(vec3 ro, vec3 rd)\n{\n\tfloat t = 0.0;\n\tvec2 d;\n\tvec3 p = ro;\n\tfor(int i = 0; i < 32; ++i)\n\t{\n\t\td = map(p);\n\t\tt += d.x;\n\t\tp = ro+t*rd;\n\t}\n\tif(abs(d.x) < 0.001)\n\t{\n\t\tvec3 col = vec3(0.8, 1.0, 0.6);\n\t\tif (d.y < 1.0) col = vec3(1.0, 1.0, 0.0);\n\t\tvec3 nor = calcNormal(p);\n\t\tfloat b = dot(vec3(1.0), nor);\n\t\treturn b*exp(-0.001*t*t)*col;\n\t}else{\n\t\treturn vec3(0.0,0.0,0.);\n\t}\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = -0.5*iTime;\n\tvec2 p = (fragCoord.xy*2.0-iResolution.xy)/iResolution.y;\n\tvec3 rd = normalize(vec3(p, -1.5));\n\tvec3 ro = coord(time);\n\tvec3 target = coord(time-0.001);\n\tvec3 forward = vec3(0.0, 0.0, -1.0);\n\tvec3 diff = normalize(target-ro);\n\tvec3 axis = cross(forward, diff);\n\tfloat angle = acos(dot(forward, diff));\n\tvec4 q = quaternion(axis, angle);\n\trd = qtransform(q, rd);\n\tfragColor=vec4(render(ro, rd), 1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4sS3Rc","date":"1391433514","viewed":218,"name":"winding","username":"gaz","description":"I am using a DE that was taught by eiffie.\n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"","parentname":""}}