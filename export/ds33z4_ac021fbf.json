{"ver":"0.1","info":{"id":"ds33z4","date":"1677036331","viewed":128,"name":"Lumber axe","username":"ianertson","description":"Use the mouse to look around :)","likes":12,"published":1,"flags":32,"usePreview":1,"tags":["3d","raytracing","ray","terrain","raymarch","sdf","rays","raytrace","lights","axe","lumber"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 getColor(vec2 uv) { return texture(iChannel0, uv).rgb; }\n\n\nvec3 getAvg(vec2 uv) {\n    vec2 tex = 1.0 / R.xy;\n    vec3 center = getColor(uv);\n    vec3 right = getColor(uv + (vec2(1, 0)*tex));\n    vec3 left = getColor(uv + (vec2(-1, 0)*tex));\n    vec3 up = getColor(uv + (vec2(0, 1)*tex));\n    vec3 down = getColor(uv + (vec2(0, -1)*tex));\n    \n    return (center + right + left + up + down) / 5.0;\n}\n\nvec3 getBloom(vec2 uv, float f) {    \n    vec2 dx = dFdx(uv) * (f+0.2) * 16.;\n    vec2 dy = dFdy(uv) * (f+0.2) * 16.;\n    vec2 dir1x = vec2(1, 0) * dx;\n    vec2 dir1y = vec2(1, 1) * dy;\n    \n    vec2 dir2x = vec2(1, 1) * dx;\n    vec2 dir2y = vec2(0, 1) * dy;\n\n    vec3 a = textureGrad(iChannel0, uv, dir1x, dir1y).rgb;\n    vec3 b = textureGrad(iChannel0, uv, dir2x, dir2y).rgb;\n    vec3 c = getAvg(uv);\n    \n    return max(a+(luma(a)*0.3), max(b+(luma(b)*0.3), c+(luma(c)*0.1)));\n}\n\nvec3 getSmooth(vec2 uv, float f) {    \n    vec2 dx = dFdx(uv) * (f+0.2) * 16.;\n    vec2 dy = dFdy(uv) * (f+0.2) * 16.;\n    vec2 dir1x = vec2(1, 0) * dx;\n    vec2 dir1y = vec2(1, 1) * dy;\n    \n    vec2 dir2x = vec2(1, 1) * dx;\n    vec2 dir2y = vec2(0, 1) * dy;\n\n    vec3 a = textureGrad(iChannel0, uv, dir1x, dir1y).rgb;\n    vec3 b = textureGrad(iChannel0, uv, dir2x, dir2y).rgb;\n    vec3 c = getAvg(uv);\n    \n    return mix(mix(a, b, 0.5), c, 0.5);\n}\n\nfloat estimateNoise(vec3 col, vec2 uv) {\n    vec2 e = vec2(1.0) / R.xy;\n    vec3 a = vec3(\n        luma(getColor(uv + vec2(e.x, 0))),\n        luma(getColor(uv + vec2(0, e.y))),\n        luma(getColor(uv + vec2(e.x, e.y)))\n    );\n    \n    float l = luma(col);\n    float n1 = abs(l - ((a.x+a.y+a.z)/3.));\n    float n2 = abs(a.x - a.y);\n    float n3 = abs(a.x - a.z);\n    float n4 = abs(a.y - a.z);\n    float n5 = fwidth(l);\n    \n    float n = (n1+n2+n3+n4+n5)/5.0;\n    return clamp(n*M_PI, 0.0, 1.0);\n}\n\nvec3 shade(vec2 uv) {\n    vec3 col = getColor(uv);\n    float depth = texture(iChannel0, uv).a;\n    float noiseEst = estimateNoise(col, uv);\n    \n    col = mix(col, getSmooth(uv, noiseEst), noiseEst*0.9);\n    col = mix(col, getSmooth(uv, depth*1.6), depth);\n    \n    float lm = luma(col);\n    \n    col = mix(col, getBloom(uv, lm), lm);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = fc/R.xy;\n    \n    col = shade(uv);\n    \n    O = vec4(clamp(col, 0.0, 1.0), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R (iResolution.xy)\n#define T ((iFrame <= 1 || iTime <= 0.0003) ? 11.85 : (iTime*2.))\n#define M_PI (3.1416)\n#define TAU (M_PI * 2.0)\n#define ZERO (min(0, int(iTime)))\n#define adot(a,b) (abs(dot(a, b)))\n#define cdot(a,b) (max(0.0, dot(a, b)))\n#define pow2(v) pow(v, 2.0)\n#define sqrt2(v) sqrt(sqrt(v))\n#define IDQ vec4(0, 0, 0, 1)\n#define rgb(a,b,c) (vec3(a, b, c) / 255.0)\n#define SAMPLE(var, O, id_) if (var < dist) { dist = var; data.id = id_; data.o = O;}\n#define TEXTURE_SIGNATURE in vec2 uv, inout Material m\n#define AMBIENT_FACTOR 0.06\n\nmat2 rot(float a) { float c = cos(a); float s = sin(a); return mat2(c, s, -s, c); }\n\nfloat luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\n\nstruct Material {\n    float rough;\n    float spec;\n};\n\n#define NEW_MATERIAL Material(1., 1.)\n\nstruct Object {\n    vec3 pos;\n    vec4 q;\n};\n\n#define NEW_OBJECT Object(vec3(0.0), vec4(0., 0., 0., 1.))\n\nstruct Data {\n    vec3 p;\n    vec3 n;\n    vec2 uv;\n    vec2 uvOffset;\n    float d;\n    int id;\n    Material m;\n    Object o;\n    float waterDist;\n};\n\n#define NEW_DATA Data(vec3(0.0), vec3(0.0), vec2(0.0), vec2(0.0), FAR, 0, NEW_MATERIAL, NEW_OBJECT, FAR)\n\nstruct Light {\n    vec3 p;\n    vec3 d;\n    vec3 c;\n    float s;\n    int type;\n};\n\n#define LIGHT_AMBIENT 0\n#define LIGHT_POINT 1\n#define LIGHT_DIR 2\n\nvec3 getLightDir(in Light light, in vec3 p) {\n    switch (light.type) {\n        case LIGHT_AMBIENT: return normalize(light.p); break;\n        case LIGHT_POINT: return normalize(light.p - p); break;\n        case LIGHT_DIR: return normalize(light.d); break;\n    }\n    return vec3(0.0);\n}\n\nvec3 getLightAtt(in Light light, in vec3 n, in vec3 p) {\n    vec3 L = getLightDir(light, p);\n    float NdotL = max(AMBIENT_FACTOR, dot(n, L));\n    switch (light.type) {\n        case LIGHT_AMBIENT: return light.c * light.s * NdotL; break;\n        case LIGHT_POINT: {\n            float d = distance(light.p, p);\n            return light.c * NdotL * (pow(light.s, 2.0) / max(0.0001, pow(d, 2.0)));\n        }; break;\n        case LIGHT_DIR: {\n            const float cutoff = 0.8;\n            float cone = dot(normalize(light.p - p), normalize(light.d));\n            float pwr = smoothstep(cutoff, 1.0, cone);\n            return light.c * pwr * light.s * NdotL;\n        }; break;\n    }\n    return vec3(0.0);\n}\n\nvec2 boxUv(vec3 p, vec3 n) {\n    vec2 uv = vec2(0.0);\n    uv = mix(uv, p.xy, adot(n, vec3(0, 0, 1)));\n    uv = mix(uv, p.xz, adot(n, vec3(0, 1, 0)));\n    uv = mix(uv, p.yz, adot(n, vec3(1, 0, 0)));\n    return uv;\n}\n\n#define EST_NORM_FOR(TEXFUNC, UV, N, M, COMPFUNC, CLR, MIX, VAR)\\\n{\\\n    float a = COMPFUNC(CLR);\\\n    float e = fwidth(a)*M_PI;\\\n    VAR = fixNormal(N, normalize(a - vec3(\\\n        COMPFUNC(TEXFUNC(UV + vec2(e, 0), M)),\\\n        COMPFUNC(TEXFUNC(UV + vec2(0, e), M)),\\\n        COMPFUNC(TEXFUNC(UV + vec2(e, e), M))\\\n    )), MIX);\\\n}\n\n#define EST_NORM_FOR_E(TEXFUNC, UV, N, M, COMPFUNC, CLR, MIX, FREQ, VAR)\\\n{\\\n    float a = COMPFUNC(CLR);\\\n    float e = max(fwidth(a)*FREQ, 0.0001);\\\n    VAR = fixNormal(N, normalize(a - vec3(\\\n        COMPFUNC(TEXFUNC(UV + vec2(e, 0), M)),\\\n        COMPFUNC(TEXFUNC(UV + vec2(0, e), M)),\\\n        COMPFUNC(TEXFUNC(UV + vec2(e, e), M))\\\n    )), MIX);\\\n}\n\n#define EST_NORM_FOR_E2(TEXFUNC, UV, N, M, COMPFUNC, CLR, MIX, FREQ, VAR)\\\n{\\\n    float a = COMPFUNC(CLR);\\\n    float e = FREQ;\\\n    VAR = fixNormal(N, normalize(a - vec3(\\\n        COMPFUNC(TEXFUNC(UV + vec2(e, 0), M)),\\\n        COMPFUNC(TEXFUNC(UV + vec2(0, e), M)),\\\n        COMPFUNC(TEXFUNC(UV + vec2(e, e), M))\\\n    )), MIX);\\\n}\n\nvec3 fixNormal(vec3 wn, vec3 n, float mixf) {\n    vec3 t = cross(wn, vec3(0, 1, 0));\n    vec3 b = vec3(0.0);\n    if (abs(length(t)) == 0.0) t = cross(wn, vec3(0, 0, 1));\n    t = normalize(t);\n    b = normalize(cross(wn, t));\n    mat3 tbn = mat3(t, b, -wn);\n    n = normalize((tbn)*n);\n    return normalize(mix(wn, n, mixf*max(0.01, dot(wn, n))));\n}\n\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\n  return F0 + (max(vec3(1.0 - roughness), F0) - F0) *\n                  pow(max(1.0 - cosTheta, 0.0), 5.0);\n}\n\nvec3 pointQuat(vec3 v, vec4 q){ \n\treturn v + 2.0*cross(cross(v, q.xyz ) + q.w*v, q.xyz);\n}\n\nvec3 look(vec2 uv, vec3 point, vec3 ro) {\n    vec3 camForward = normalize(point - ro);\n    vec3 camRight = -normalize(cross(camForward, vec3(0, 1, 0)));\n    vec3 camUp = -normalize(cross(camRight, camForward));\n    vec3 screenCenter = ro + camForward * 1.;\n    vec3 screenIntersection = screenCenter + uv.x * camRight + uv.y * camUp;\n    return normalize(screenIntersection - ro);\n}\n\n/*vec3 onCycle(vec3 from, vec3 to, float time, float nrSteps, float transTime, float frame) {\n    float cycle = mod(time, nrSteps + transTime);\n    return mix(from, to, smoothstep(frame - transTime, frame + transTime, cycle));\n}*/\n\nvec3 onCycle2(vec3 from, vec3 to, float time, float nrSteps, float transTime, float frame, float cycle) {\n    return mix(from, to, smoothstep(frame - transTime, frame + transTime, cycle));\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define NEAR 0.003\n#define FAR 100.0\n#define STEPS 100\n\n#define ID_NONE 0\n#define ID_GROUND 1\n#define ID_LOG 2\n#define ID_AXE_HANDLE 3\n#define ID_AXE_HEAD 4\n#define ID_WATER 5\n#define ID_ROCK 6\n\n#define GROUND_LEVEL 7.0\n#define PUDDLE_POS vec2(-3.5, 3.0)\n#define PUDDLE_POS3 vec3(-3.5, 0, 3.0)\n\nvec3 noise(in vec2 p, in float seed) {\n    return textureLod(iChannel3, (p + (seed * 10.93877156)) / 256.0, 0.0).rgb;\n}\n\nvec3 noise(in vec2 p, in float seed, in float freq) {\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    #define ADV n += amp * noise(p*freq, seed); div += amp; amp /= 2.0; freq *= 2.0;\n    ADV; ADV; ADV; ADV;\n    #undef ADV \n    return n / div;\n}\n\nvec3 noise6(in vec2 p, in float seed, in float freq) {\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    #define ADV n += amp * noise(p*freq, seed); div += amp; amp /= 2.0; freq *= 2.0;\n    ADV; ADV; ADV; ADV; ADV; ADV;\n    #undef ADV \n    return n / div;\n}\n\n\nfloat sphereSDF(in vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat cylSDF(in vec3 p, vec3 a, vec3 b, float r) {\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    \n    vec3 c = a + t * ab;\n    \n    float x = length(p - c) - r;\n    float y = (abs(t - 0.5) - 0.5) * length(ab);\n    float e = length(max(vec2(x, y), 0.0));\n    float i = min(max(x, y), 0.0);\n    \n    return e + i;\n}\n\nfloat boxSDF(in vec3 p, in vec3 s) {\n    p = abs(p) - s;\n    return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\nfloat logSDF(in vec3 p) {\n    float dist = cylSDF(p-vec3(0, 0.0, 0), vec3(0, 0.0, 0), vec3(0, 0.8, 0), 0.28);\n    return dist;\n}\n\nfloat axeSDF(in vec3 p, inout int id, inout Object o) {\n    id = ID_AXE_HANDLE;\n\n    p = pointQuat(p, o.q);\n    //o.q = vec4(0, 0,sin(T*0.2), sin(T*0.2));\n    \n    \n    float dist = FAR;\n    float w = 0.9;\n    float handle = cylSDF(p-vec3(0, 0.0, 0), vec3(-w/2.0, 0.0, 0), vec3(w/2.0, 0.0, 0), 0.03);\n    \n\n\n    vec3 headP = p - vec3(-(w/2.0), -0.06, 0);\n    float taper = clamp(-headP.y, 0.0, 1.0);\n    taper += clamp(headP.y-0.01, 0.0, 1.0)*0.1;\n    taper /= 2.0;\n    float head = boxSDF(headP, vec3(0.09, 0.11, 0.05-taper)) - (0.03*clamp(headP.y, 0.0, 1.0));\n    \n    dist = handle;\n    \n    if (head < dist) { dist = head; id = ID_AXE_HEAD; }\n    \n    return dist;\n}\n\nfloat getPuddle(in vec3 p) {\n    vec3 n = noise6(p.xz, 4.48484, 0.5);\n    vec3 n2 = noise6(p.xz, 4.48484, 0.41);\n    n = (n + n2) / 2.0;\n    \n    vec2 pos = PUDDLE_POS;\n    float dist = distance(p.xz, pos);\n    \n    float radi = (1.0 + n.x*3.);\n    float feat = radi*0.2;\n    float amp = clamp(1.0 - smoothstep(radi-feat, radi+feat, dist), 0.0, 1.0);\n    \n    return -amp;\n}\n\nfloat getHeight(in vec3 p) {\n    vec3 n = noise6(p.xz, 7.74421, 0.3);\n    //vec3 n2 = noise6(p.xz, 1.33359, 0.4);\n    //n = (n + n2) / 2.0;\n    \n    float amp = clamp(smoothstep(4.0, 16.0, distance(p.xz, vec2(0.0))), 0.0, 1.0);\n    \n    return n.z*amp*4.;\n}\n\nfloat groundSDF(in vec3 p) {\n    float ph = getPuddle(p);\n    \n    float h = getHeight(p);\n    \n    \n    float d = ((p.y-h) - ph) / (1.0+(max(abs(ph), 0.1*(abs(h)/4.0))*3.));\n    \n    return d;\n}\n\nfloat waterSDF(in vec3 p) {\n    vec2 pos = PUDDLE_POS;\n    float dist = distance(p.xz + vec2(pos.x, pos.y), pos);\n    \n    float radi = M_PI;\n    float feat = radi*0.2;\n    float amp = clamp(1.0 - smoothstep(radi-feat, radi+feat, dist), 0.0, 1.0);\n   \n   vec3 n = noise6(p.xz + vec2(sin((T+11.9381)*0.1), cos((T+8.398871)*0.1)), 11.29315, 0.7);\n    \n    float h = n.x;\n\n    \n    vec2 pz = p.xz;\n    pz = abs(pz) - vec2(2.0);\n\n    float d = length(max(pz, 0.0)) + min(max(pz.x, pz.y), 0.0);\n    \n    return max((p.y+(0.6-(h*0.33))), max(abs(p.x)-M_PI, abs(p.z)-M_PI));\n}\n\nfloat rockSDF(in vec3 p, float r) {\n    //vec2 uv = vec2(acos(p.x), atan(p.y, p.z));\n\n    \n    float x = cos(p.y*6.)*0.5;\n    float y = sin(p.x*6.)*0.5;\n    float z = cos((p.x+p.z)*6.)*0.5;\n    r += (0.5-noise6(p.xz+(p.y-p.z), 3.29154, 2.5).r)*0.2;\n    p -= vec3(x, y, z)*0.2;\n    p.y += max(0.0, cos(p.x)*p.x);\n    p.y += sin((x+z)*4.)*0.1;\n    \n    \n    \n    //float v = (n.x+n.y+n.z)/3.0;\n    float rock = sphereSDF(p, r);\n    \n    //n = abs(n);\n    //float mag = max(n.x, max(n.y, n.z));\n    \n    return rock/2.2;// / (1.0+mag*0.5);\n}\n\n#define DEBUG 0\n\nfloat getDist(inout Data data, in vec3 p) {\n    p.y -= GROUND_LEVEL;\n    float dist = FAR;\n    Object O = NEW_OBJECT;\n    \n    float ground = groundSDF(p);\n\n    \n    float wlog1 = cylSDF(p-vec3(0, 0.0, 0), vec3(0, 0.0, 0), vec3(0, 0.8, 0), 0.28);\n    \n    Object logObj = Object(vec3(0.6, 0.16, 0.5), vec4(0, 0, sin(radians(45.)), cos(radians(45.))));\n    float wlog2 = cylSDF(pointQuat(p-logObj.pos, logObj.q), vec3(0, 0.0, 0), vec3(0.0, 0.5, 0), 0.16);\n    int axePart = 0;\n    \n    \n    float a = mix(radians(0.0), radians(-10.0), (0.5+(0.5*cos(T*2.))));\n    Object axeObj = Object(vec3(0.48, 1.0-0.038, 0), vec4(0, 0, sin(a), cos(a)));\n    float axe = axeSDF(p - axeObj.pos, axePart, axeObj);\n    \n    float rock = rockSDF(p - (vec3(0, 0.25, 2.)), 0.25);\n    \n    SAMPLE(ground, O, ID_GROUND);\n    SAMPLE(wlog1, O, ID_LOG);\n    SAMPLE(wlog2, logObj, ID_LOG);\n    SAMPLE(axe, axeObj, axePart);\n    SAMPLE(rock, O, ID_ROCK);\n    \n    float water = waterSDF(p - PUDDLE_POS3);\n    \n    if (water < dist) {\n        data.uvOffset = noise(p.xz + vec2(cos(T*0.5), sin(T*0.5)), 3.328154, 0.5).xy * 0.5;\n        data.waterDist = water;\n    }\n    \n    return dist;\n}\n\nbool march(inout Data data, in vec3 ro, in vec3 rd) {\n    float dist = 0.0;\n    \n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*dist;\n        float next = getDist(data, p);\n        dist += next;\n        \n        if (abs(next) <= NEAR) break;\n        if (abs(dist) >= FAR) return false;\n    }\n    vec3 p = ro+rd*dist;\n    data.p = p;\n    data.d = dist;\n    \n    float f = 0.001;\n    \n    f = mix(f, 0.16, float(data.id == ID_GROUND || data.id == ID_WATER) *\n        clamp(smoothstep(0.5, 1.0, distance(p.xz, vec2(0.0))), 0.0, 1.0));\n    \n    \n    vec2 e = vec2(f, 0.0); \n\n    \n    data.n = normalize(getDist(data, p) - vec3(\n        getDist(data, p - e.xyy),\n        getDist(data, p - e.yxy),\n        getDist(data, p - e.yyx)\n    ));\n    \n    \n \n    data.uv = boxUv(pointQuat((p - data.o.pos) - vec3(0, GROUND_LEVEL, 0), data.o.q), pointQuat(data.n, data.o.q));\n    data.uv += data.uvOffset;\n    \n    return true;\n}\n\n\nfloat getShadow(in vec3 ro, in vec3 rd, in float near, in float far) {\n    float dist = 0.0;\n    \n    Data data = NEW_DATA;\n    \n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*dist;\n        float next = getDist(data, p);\n        dist += next;\n        \n        if (abs(next) <= NEAR) break;\n        if (abs(dist) >= min(far, FAR)) return 1.0;\n    }\n    \n    return clamp(abs(dist) / (0.2+abs(near)), AMBIENT_FACTOR, 0.77);\n}\n\nvec3 getSky(in vec3 ro, in vec3 rd, in Light light) {\n    vec3 col = vec3(0.0);\n    vec3 L = normalize(light.p);\n    \n    vec2 uv = rd.xz/rd.y;\n    float dotup = cdot(rd, vec3(0, 1, 0));\n    float VdotL = cdot(rd, L);\n    \n    vec3 blueTop = rgb(62, 104, 144);\n    vec3 blueBot = rgb(142, 189, 209);\n    \n    col = mix(blueBot*blueBot, blueTop*blueTop*blueTop, clamp(dotup, 0.0, 1.0));\n    \n    float lightPwr = pow(VdotL, 32.0);\n    col = mix(col, light.c*light.c, lightPwr);\n    \n    vec2 shift = vec2(cos(T*0.05), sin(T*0.05));\n    \n    vec3 hf = noise(uv + shift, 6.4123, 16.0);  \n    vec3 lf = noise(uv - (shift*2.), 3.9877, 2.0);\n    \n    float cloudsHStart = (hf.x+lf.x)/2.;\n    float cloudsH = cloudsHStart;\n    \n  //  float timer = (0.5+(0.5*cos(T)));\n    \n    float cycle = mod((T*0.5), 4.0 + 0.9);\n    cloudsH = mix(cloudsH, hf.y, smoothstep(1.0 - 0.9, 1.0 + 0.9, cycle));\n    cloudsH = mix(cloudsH, hf.x, smoothstep(2.0 - 0.9, 2.0 + 0.9, cycle));\n    cloudsH = mix(cloudsH, hf.z, smoothstep(3.0 - 0.9, 3.0 + 0.9, cycle));\n    cloudsH = mix(cloudsH, cloudsHStart, smoothstep(4.0 - 0.9, 4.0 + 0.9, cycle));\n    \n    \n    float cloudsLStart = (lf.x+lf.y+lf.z)/2.;\n    float cloudsL = cloudsLStart;\n    \n  //  float timer = (0.5+(0.5*cos(T)));\n    \n    \n    cloudsL = mix(cloudsL, lf.y, smoothstep(1.0 - 0.9, 1.0 + 0.9, cycle));\n    cloudsL = mix(cloudsL, lf.x, smoothstep(2.0 - 0.9, 2.0 + 0.9, cycle));\n    cloudsL = mix(cloudsL, lf.z, smoothstep(3.0 - 0.9, 3.0 + 0.9, cycle));\n    cloudsL = mix(cloudsL, cloudsLStart, smoothstep(4.0 - 0.9, 4.0 + 0.9, cycle));\n    \n    float mixf = clamp((0.5+(0.5*cos((T*(0.1+(lf.y*0.001)))+(3.0*(lf.x+lf.y+lf.z))))), 0.0, 1.0);\n    \n    float clouds = mix(mix(cloudsH, cloudsL, mixf), (cloudsH+cloudsL)/2.0, 0.5);\n    clouds *= max(0.0, 1.0 - ((lf.x*lf.z)*0.5));\n    clouds = pow(clouds, 2.0);\n    \n    \n    col = mix(col, vec3(1.0), clouds);\n    col += pow(clouds, 2.0);\n    \n    return col;\n}\n\n//#define DEBUG_TEXTURE rockTexture\n\nvec3 rockTexture(TEXTURE_SIGNATURE) {\n    vec3 col = vec3(0.0);\n    \n    vec3 alt = noise6(uv, 8.3219, 30.0);\n    vec3 alt2 = noise(uv, 5.4636, 8.0);\n    \n    float scratch = abs(alt.x - (alt.z + cos(alt.y*TAU)));\n    col += alt.x*0.05;\n    col += alt.y*0.05;\n    col += alt.z*0.05;\n    col /= 3.0;\n    col += scratch*0.05;\n    \n    vec3 ra = abs(cross(alt2, alt));\n    \n    col = mix(col, vec3(0.56, 0.48, 0.55), abs(ra.x-ra.y));\n    col = mix(col, vec3(0.77, 0.77, 0.88), ra.z*ra.x);\n    \n    col += abs(alt2.x-alt2.y)/3.;\n    \n    m.spec = alt2.y;\n    m.rough = 1.0;\n    \n    //vec2 lv = fract(uv*2.0);\n   // return vec3(max(0.0, 1.0 - ceil(min(lv.x, lv.y)-0.09)));\n   \n    return col;\n}\n\nvec3 woodTexture(TEXTURE_SIGNATURE) {\n    vec3 col = vec3(0.0);\n    \n    vec3 c1 = rgb(141, 116, 88);\n    vec3 c2 = rgb(212, 168, 116);\n    vec3 c3 = rgb(153, 98, 50);\n    \n    vec3 alt = noise(uv, 9.96189, 32.0);\n    \n    col = mix(col, c1, abs(alt.x-(alt.z/4.)));\n    col = mix(col, c2, abs(alt.x-alt.y));\n    col = mix(col, c3, abs(alt.y-alt.z));\n    \n    vec2 lv = fract(uv) * 2.0 - 1.0;\n    \n    vec2 offset = vec2(alt.x*alt.z, alt.y)-0.5;\n    float amp = TAU*TAU/max(0.5, (alt.x+alt.y+alt.z));\n    amp = mix(amp, TAU*TAU, 0.9);\n\n\n    vec2 p = uv * 10.;\n    float rings = sin(((p.x+(alt.z*0.25))-cos((p.y-alt.y) + cos(p.x+alt.x)))*TAU);\n    rings = fract(max(0.0, 1.0 - rings));\n    \n    col = mix(col, ((c2*c2*c1*c3)/2.), rings);\n    \n    vec3 vary = textureLod(iChannel3, (uv*2.) + ((alt.xy-0.5)*0.05), 0.0).xyz;\n    \n    float v = pow(vary.x, 2.0);\n    \n    col = mix(col, c2*((vary.x+vary.y)/1.6), v);\n    \n    return col;\n}\n\nvec3 metalTexture(TEXTURE_SIGNATURE) {\n    vec3 col = vec3(0.0);\n    \n    vec3 c1 = rgb(135, 124, 122);\n    vec3 c2 = rgb(105, 91, 94);\n    vec3 c3 = rgb(205, 206, 202);\n    vec3 c4 = rgb(125, 125, 121);\n    \n    vec3 ax = noise(uv, 5.11123, 8.6);\n    vec3 ay = noise(uv, 4.44421, 32.6);\n    vec3 az = noise(uv, 1.53229, 64.6);\n    \n    col = mix(col, c1, ax.x);\n    col = mix(col, c2, ay.y);\n    col = mix(col, c3, az.z);\n    \n    float pat = (abs(ax.y - ay.x) + abs(ay.z - az.y)) / 2.;\n    pat = clamp(smoothstep(0.16, -0.2, pat), 0.0, 1.0);\n    \n    col = mix(col, c4*c4*c4, clamp(pat*2., 0.0, 1.0));\n    \n    uv *= 1.6;\n    float swirl = cos((ay.x)+(((uv.x + cos(uv.y*1.6)) - sin(uv.y*1.6+(ay.y*0.1)))*10.)*(TAU+az.x));\n    \n    col = mix(col, c3*c3, swirl);\n    \n    col *= (0.5+(fract(ax.x + ax.y + ax.z + ay.x + ay.y + ay.z + az.x + az.y + az.z)*0.5));\n    col *= vec3(0.89, 0.88, 0.89);\n    col += 0.5;\n    col /= M_PI;\n    \n    m.spec = clamp(swirl*3., 0.5, 1.0);\n    m.rough = (pat+swirl)/2.0;\n  \n    return clamp(col, 0.0, 1.0);\n}\n\nvec3 logTopTexture(TEXTURE_SIGNATURE) {\n    vec3 col = vec3(0.0);\n    \n    vec3 c1 = rgb(141, 116, 88);\n    vec3 c2 = rgb(212, 168, 116);\n    vec3 c3 = rgb(153, 98, 50);\n    \n    vec3 alt = noise(uv, 9.96189, 32.0);\n    \n    col = mix(col, c1, abs(alt.x-(alt.z/4.)));\n    col = mix(col, c2, abs(alt.x-alt.y));\n    col = mix(col, c3, abs(alt.y-alt.z));\n    \n    vec2 lv = fract(uv) * 2.0 - 1.0;\n    \n    vec2 offset = vec2(alt.x*alt.z, alt.y)-0.5;\n    float amp = TAU*TAU/max(0.5, (alt.x+alt.y+alt.z));\n    amp = mix(amp, TAU*TAU, 0.9);\n    float rings = abs(cos(length(lv + (offset*0.06))*amp));\n    \n    col *= (rings+((alt.x+alt.y+alt.z)/3.));\n    \n    m.spec = max(0.0, 1.0 - rings);\n    \n    return col;\n}\n\nvec3 barkTexture(TEXTURE_SIGNATURE) {\n    vec3 col = vec3(0.0);\n    \n    // browns\n    vec3 c1 = pow(rgb(98, 83, 61), vec3(2.0));\n    vec3 c2 = pow(rgb(49, 45, 37), vec3(2.0));\n    vec3 c3 = pow(rgb(120, 112, 90), vec3(2.0));\n    \n    // greens\n    vec3 c4 = pow(rgb(69, 71, 47), vec3(2.0));\n    vec3 c5 = pow(rgb(65, 70, 43), vec3(2.0));\n    vec3 c6 = pow(rgb(58, 65, 37), vec3(2.0));\n    \n    vec3 brown = rgb(60, 50, 39);\n    \n    vec3 sn = noise(uv, 6.69381, 9.4);\n    vec3 hf = noise(uv, 12.83715, 128.4);\n    \n    col = mix(col, c1, hf.x);\n    col = mix(col, c2, hf.y);\n    col = mix(col, brown*c3, hf.z*0.1);\n    \n\n    float stripes = 0.5-fract((uv.x*10.+(sn.x*0.3)) + cos(((uv.y+(sn.z*0.2))-(sin(uv.x*10.+(sn.y*0.3))*0.06))*TAU*1.6));\n    stripes = abs(stripes);\n    stripes = clamp(pow(smoothstep(0.26, 0.9, stripes), 2.0)*9., 0.0, 1.0);\n    \n    float stripes2 = 0.5-fract((uv.x*10.5+(sn.x*0.4)) + cos(((uv.y+(sn.z*0.3))-(sin(uv.x*10.5+(sn.y*0.4))*0.07))*TAU*1.61));\n    stripes2 = abs(stripes2);\n    stripes2 = clamp(pow(smoothstep(0.26, 0.9, stripes2), 2.0)*9., 0.0, 1.0);\n    \n    \n    float pat = clamp(smoothstep(abs(stripes - stripes2), 0.6, 0.4), 0.0, 1.0);\n      \n    col *= pat;\n    \n    float shade = max(0.0, 1.0 - ((stripes+stripes2+sn.x+sn.y+sn.z)/2.6));\n    \n    shade = pow(max(0.0, 1.0 - smoothstep(0.9, -0.6, shade*shade)), 6.0);\n\n    \n    col = mix(col, brown/(TAU*2.), stripes);\n    \n    col += shade*(col+brown+brown);\n    \n    col += luma(col)+col;\n    \n    m.spec = max(0.0, 1.0 - (pat+stripes+stripes2));\n    \n    return clamp(col, 0.0, 1.0);\n}\n\n//#define DEBUG_TEXTURE mudGrassTexture\nvec3 mudGrassTexture(TEXTURE_SIGNATURE) {\n    vec3 col = vec3(0.0);\n  //  uv *= 64.0;\n    vec3 alt = noise(uv, 1.29381, 64.0);\n    \n    vec3 fn = noise(uv, 4.32156, 1.2);\n    \n    float fny = abs((fn.y + (fn.x*0.1)) - (fn.z*0.99));\n    fny = clamp(smoothstep(-0.2, 1.0, fny), 0.0, 1.0);\n    \n    float fnx = abs((fn.x + (fn.z*0.1)) - (fn.y*0.99));\n    fnx = clamp(smoothstep(-0.2, 1.0, fnx), 0.0, 1.0);\n\n   // return vec3(fre);\n    vec3 grassRegions = noise(uv, 4.3915, 1.0);\n    \n    \n    float grassReg = pow((1.0-grassRegions.x), 2.0);\n    grassReg = max(smoothstep(0.23, 0.5, grassReg), pow(max(0.01, grassRegions.z - fny), 6.0));\n    grassReg = clamp(grassReg*40., 0.0, 1.0);\n    \n    \n    float mudReg = max((alt.x*0.2)+(fnx*0.3), 1.0 - grassReg);\n    \n    vec3 mud1 = rgb(62, 36, 31); // dark\n    vec3 mud2 = rgb(46, 18, 11); // really dark\n    vec3 mud3 = rgb(135, 101, 74); // bright\n    vec3 mud4 = rgb(102, 74, 56); // medium\n    vec3 w1 = rgb(44, 29, 22);\n    \n    vec3 mud = mudReg * mix(mix(mix(mud1, mud2, alt.x), mud3, alt.y), mud4, alt.z);\n    \n    vec3 g1 = rgb(129, 131, 49);\n    vec3 g2 = rgb(165, 170, 94);\n    vec3 g3 = rgb(108, 115, 52);\n    \n    vec3 galt = noise(uv, 2.39185, 10.0);\n    \n    vec3 grass = grassReg * mix(mix(g1*g1, g2, galt.x), g3*g3, galt.y);\n    \n    col += mud;\n    col += grass;\n    \n    vec3 wet = abs(reflect(alt, galt));\n    \n    col = mix(col, wet.x*w1, clamp((wet.y+wet.x+wet.z)/1.6, 0.0, 1.0));\n    \n    float shade = (mudReg+alt.x+alt.y+alt.z) / (6.+grassReg+galt.x+galt.y+galt.z);//min(grassReg, mudReg) / max(grassReg, mudReg); \n    shade = smoothstep(-1., 1., shade);\n    shade = clamp(shade, 0.0, 1.0);\n    \n    col *= (shade+(fny*fny));\n    \n    vec3 grains = textureLod(iChannel3, uv*1.6, 1.0 + (wet.x*9.)).rgb;\n    float grain = pow(grains.x, 3.0 + grassRegions.y);\n    \n    col += col.g*(grains.y+grains.z);\n    \n    col += grain * (mud3+g1)*shade;\n    \n    fny = max(grain*0.2, fny - (mudReg*0.5));\n    \n    col = mix(col, vec3(0.77), fny);\n    col = mix(col, col*col, (fnx+fn.z)/1.9);\n    \n    m.spec = clamp(max(grain, 1.0 - grassReg), 0.0, 1.0);\n    m.rough = clamp((1.0 - wet.x) + (grassReg), 0.1, 1.0);\n    \n\n    \n    return clamp(col*(0.3+col*0.7), 0.0, 1.0);\n}\n\nvec3 getAlbedoGround(inout Data data) {\n    vec3 col = vec3(0.0);\n    vec2 uv = data.p.xz + data.uvOffset;//data.uv;\n    \n    col = mudGrassTexture(uv, data.m);\n    \n    vec3 bump = vec3(0.0);\n    EST_NORM_FOR_E(mudGrassTexture, uv, data.n, data.m, luma, col, 0.9, 0.8, bump);\n    data.n = bump;\n    \n    Material rockMat = NEW_MATERIAL;\n    vec3 p = data.p;\n    float amp = clamp(smoothstep(4.0, 16.0, distance(p.xz, vec2(0.0))), 0.0, 1.0);\n    \n    vec3 rockvary = noise(uv, 1.29815, 0.4);\n    float vary = clamp((pow(rockvary.x, 2.0)*4.)*amp, 0.0, 1.0);\n    \n    vec3 rock = rockTexture(uv, rockMat);\n    \n    col = mix(col, rock, vary);\n    data.m.spec = mix(data.m.spec, rockMat.spec, vary);\n    data.m.rough = mix(data.m.rough, rockMat.rough, vary);\n    \n    return col;\n}\n\nvec3 getAlbedoLog(inout Data data) {\n    vec3 col = vec3(0.0);\n    vec2 uv = data.uv;\n    \n    Material mBark = NEW_MATERIAL;\n    Material mWood = NEW_MATERIAL;\n    \n    vec3 bark = barkTexture(uv, mBark);\n    vec3 wood = logTopTexture(uv, mWood);\n    \n    float updown = adot(pointQuat(data.n, data.o.q), vec3(0, 1, 0));\n    \n    col = mix(bark, wood, updown);\n    \n    \n    vec3 barkBump = vec3(0.0);\n    EST_NORM_FOR_E(barkTexture, uv, data.n, mBark, luma, col, 1.0, 0.001, barkBump);\n    \n    \n    vec3 woodBump = vec3(0.0);\n    EST_NORM_FOR_E(logTopTexture, uv, data.n, mWood, luma, col, 1.0, 0.001, woodBump);\n   \n    data.m.spec = mix(mBark.spec, mWood.spec, updown);\n    data.m.rough = mix(mBark.rough, mWood.rough, updown);\n    \n    data.n = normalize(mix(barkBump, woodBump, updown));\n    \n    return col;\n}\n\nvec3 getAlbedoAxeHead(inout Data data) {\n    vec3 col = vec3(0.0);\n    vec2 uv = data.uv;\n    \n    col = metalTexture(uv, data.m);\n    \n    vec3 bump = vec3(0.0);\n    EST_NORM_FOR_E(metalTexture, uv, data.n, data.m, luma, col, 0.5, 0.01, bump);\n    data.n = bump;\n    \n    return col;\n}\n\nvec3 getAlbedoAxeHandle(inout Data data) {\n    vec3 col = vec3(0.0);\n    vec3 p = data.p;\n\n    vec2 uv = data.uv;\n    \n    col = woodTexture(uv, data.m);\n    \n    vec3 bump = vec3(0.0);\n    EST_NORM_FOR_E(woodTexture, uv, data.n, data.m, luma, col, 0.9, 0.03, bump);\n    data.n = bump;\n    \n    return col;\n}\n\nvec3 getAlbedoRock(inout Data data) {\n    vec3 col = vec3(0.0);\n    vec3 p = data.p;// - vec3(0, 0.25, 2.);\n\n    vec2 uv = data.uv;\n    \n    uv = vec2(acos(p.x), atan(p.y, p.z));\n    uv.x = 0.5 + uv.x / TAU;\n    uv.y = 0.5 - uv.y / M_PI;\n\n    \n    uv *= 2.;\n    col = rockTexture(uv, data.m);\n    \n    vec3 bump = vec3(0.0);\n    EST_NORM_FOR_E(rockTexture, uv, data.n, data.m, luma, col, 0.9, 0.03, bump);\n    data.n = bump;\n    \n    return col;\n}\n\nvec3 getAlbedo(inout Data data) {\n    switch (data.id) {\n        case ID_GROUND: return getAlbedoGround(data); break;\n        case ID_LOG: return getAlbedoLog(data); break;\n        case ID_AXE_HEAD: return getAlbedoAxeHead(data); break;\n        case ID_AXE_HANDLE: return getAlbedoAxeHandle(data); break;\n        case ID_ROCK: return getAlbedoRock(data); break;\n    }\n    \n    return vec3(0.77);\n}\n\nvec3 forEachLight(inout Data data, in Light light, in vec3 ro, in vec3 rd) {\n    vec3 albedo = getAlbedo(data);\n    vec3 diffuse = albedo / M_PI;\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec3 L = getLightDir(light, p);\n    vec3 ref = reflect(L, n);\n    float VdotR = cdot(rd, ref);\n    float spec = data.m.spec * pow(VdotR, 32.0);\n    \n    float shadow = getShadow(p + (data.n*NEAR*2.0), L, data.d, (\n        light.type == LIGHT_AMBIENT ? FAR : distance(p, light.p)\n    ));\n    \n    vec3 att = getLightAtt(light, n, p);\n    \n    return (diffuse + spec) * att * shadow;\n}\n\n#define NUM_LIGHTS 1\n\nvec3 render(inout Data data, in vec3 ro, in vec3 rd, inout float dist) {\n    vec3 col = vec3(0.0);\n    \n    float dotup = cdot(rd, vec3(0, 1, 0));\n    \n    Light lights[NUM_LIGHTS];\n    lights[0] = Light(vec3(1, 2, -3), vec3(0.0), rgb(255, 245, 202), 2.0, LIGHT_AMBIENT);\n    \n    vec3 mixf = vec3(1.0);\n    dist = FAR;\n\n    for (int j = ZERO; j < 2; j++) {\n        if (march(data, ro, rd)) {\n            if (j <= 0) {\n                dist = data.d;\n            }\n            for (int i = ZERO; i < NUM_LIGHTS; i++) {\n                Light light = lights[i];\n                col += forEachLight(data, light, ro, rd) * mixf;\n            }\n            \n            col = mix(col, col*vec3(0.5, 0.7, 0.8), float(data.waterDist < FAR));\n            \n            vec3 f0 = vec3(0.04);\n            float NdotV = abs(dot(data.n, rd));\n            vec3 F = fresnelSchlickRoughness(NdotV, f0, data.m.rough);\n            \n            rd = reflect(rd, data.n);\n            ro = data.p+(data.n*NEAR*2.0);\n            mixf *= max(0.0, 1.0 - pow2(data.m.rough)) * F;\n            \n\n            if (data.m.rough > 0.999) break;\n        } else {\n            col += getSky(ro, rd, lights[0]) * mixf;\n            break;\n        }\n    }\n    \n    float depth = dist / FAR;\n    \n    col += (smoothstep(0.01, 1., depth) * max(0.0, 1.0 - dotup))/2.;\n    \n    return col;\n}\n\n\n\nvoid getRay(in vec2 uv, in vec4 m, inout vec3 ro, inout vec3 rd) {\n    ro = vec3(0, 1.4, -M_PI);\n    rd = normalize(vec3(uv.xy, 1.0));\n    \n    ro.z += 0.9;\n    ro.y -= 0.6;\n    \n    if (m.z > 0.001) {\n        rd.yz *= rot(m.y*TAU);\n        rd.xz *= rot(m.x*TAU);\n        \n        ro.yz *= rot(m.y*TAU);\n        ro.xz *= rot(m.x*TAU);\n    } else {\n        #if DEBUG\n        ro.y += 1.0;\n        ro.z += 1.5;\n        ro.x -= 0.5;\n        rd.yz *= rot(radians(-10.));\n        #else\n        vec3 center = vec3(0, 0.6, 0);\n        vec3 loc = ro + (vec3(0., 1.9, 0.)*0.15) + vec3(0, 0, 0.5);\n        vec3 oloc = loc;\n        vec3 lookp = center;\n        \n        float time = T*0.2;\n        float nrSteps = 11.0;\n        float transTime = 0.9;\n        float frame = 1.0;\n        float cycle = mod(time, nrSteps + transTime);\n        \n        lookp = onCycle2(lookp, center, time, nrSteps, transTime, frame, cycle);\n        loc = onCycle2(loc, center + vec3(0, 1.6, -0.1), time, nrSteps, transTime, frame, cycle);\n        frame += 1.0;\n        \n        lookp = onCycle2(lookp, center, time, nrSteps, transTime, frame, cycle);\n        loc = onCycle2(loc, center + vec3(-1.0, 0.0, 1.5), time, nrSteps, transTime, frame, cycle);\n        frame += 1.0;\n        \n        lookp = onCycle2(lookp, PUDDLE_POS3 - vec3(0, 0.5, 0), time, nrSteps, transTime, frame, cycle);\n        loc = onCycle2(loc, PUDDLE_POS3 - vec3(2, -1., -3), time, nrSteps, transTime, frame, cycle);\n        frame += 1.0;\n        \n        lookp = onCycle2(lookp, PUDDLE_POS3, time, nrSteps, transTime, frame, cycle);\n        loc = onCycle2(loc, vec3(1., 2., 10.), time, nrSteps, transTime, frame, cycle);\n        frame += 1.0;\n        \n        lookp = onCycle2(lookp, center, time, nrSteps, transTime, frame, cycle);\n        loc = onCycle2(loc, vec3(-1., 1.6, 2.), time, nrSteps, transTime, frame, cycle);\n        frame += 1.0;\n        \n        lookp = onCycle2(lookp, center, time, nrSteps, transTime, frame, cycle);\n        loc = onCycle2(loc, vec3(6., 2., 3.), time, nrSteps, transTime, frame, cycle);\n        frame += 1.0;\n        \n        lookp = onCycle2(lookp, center + vec3(0, 1., 0), time, nrSteps, transTime, frame, cycle);\n        loc = onCycle2(loc, vec3(-20, 4.9, 6.), time, nrSteps, transTime, frame, cycle);\n        frame += 1.0;\n        \n        lookp = onCycle2(lookp, PUDDLE_POS3 + vec3(0, 8, 0), time, nrSteps, transTime, frame, cycle);\n        loc = onCycle2(loc, vec3(-20, 4.9, 3.) + (vec3(sin(T), 0.0, cos(T))), time, nrSteps, transTime, frame, cycle);\n        frame += 1.0;\n        \n        lookp = onCycle2(lookp, loc + vec3(sin(T), 20., cos(T)), time, nrSteps, transTime, frame, cycle);\n        loc = onCycle2(loc, vec3(-19.9231, 4.8, 1.) + (vec3(sin(T), 0.0, cos(T))), time, nrSteps, transTime, frame, cycle);\n        frame += 1.0;\n        \n        lookp = onCycle2(lookp, PUDDLE_POS3, time, nrSteps, transTime, frame, cycle);\n        loc = onCycle2(loc, vec3(-19, 4.7, -16.) + (vec3(cos(T), 0, sin(T))), time, nrSteps, transTime, frame, cycle);\n        frame += 1.0;\n\n        \n        lookp = onCycle2(lookp, center, time, nrSteps, transTime, frame, cycle);\n        loc = onCycle2(loc, oloc, time, nrSteps, transTime, frame, cycle);\n        frame += 1.0;\n        \n        ro = loc;\n        rd  = look(uv, lookp, ro);\n        #endif\n    }\n    \n    ro.y += GROUND_LEVEL;\n    ro.y = max(GROUND_LEVEL+0.2, ro.y);\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec4 m = iMouse;\n    vec2 uv = (fc-0.5*R.xy)/R.y;\n    m.xy = (m.xy-0.5*R.xy)/R.y;\n    \n    vec3 ro = vec3(0.0);\n    vec3 rd = vec3(0.0);\n    getRay(uv, m, ro, rd);\n    float dist = FAR;\n    Data data = NEW_DATA;\n    \n    #ifdef DEBUG_TEXTURE\n    Material ma = NEW_MATERIAL;\n    col += DEBUG_TEXTURE(fc.xy/R.xy, ma);\n    #else\n    col += render(data, ro, rd, dist);\n    #endif\n    \n    col += (luma(col) * col);\n    \n    col /= vec3(1.0) + col;\n    col = pow(col, vec3(1.0 / 2.2));\n    \n    O = vec4(clamp(col, 0.0, 1.0), dist/FAR);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}