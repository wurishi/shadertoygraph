{"ver":"0.1","info":{"id":"fsByDW","date":"1644050430","viewed":102,"name":"milky waves revised","username":"AVKOR","description":"revised version of 2D waves from  https://www.shadertoy.com/view/Msy3D1","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["2dwaveequation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// riffing off tomkh's wave equation solver: https://www.shadertoy.com/view/Xsd3DB\n\n// i spent some time experimenting with different ways to speed up the raymarch.\n// at one point i even slowed down the ray march steps around the mouse, as this was\n// where the sharpest/highest peaks tend to be, which kind of worked but was complicated.\n// in the end the best i could do was to boost the step size by 20% and after\n// iterating, shade the point whether it converged or not, which gives plausible\n// results. some intersections will be missed completely, for the current settings\n// its not super noticeable. to fix divergence at steep surfaces facing\n// the viewer, i used the hybrid sphere march from https://www.shadertoy.com/view/Mdj3W3\n// which, at surface crossings, uses a first order interpolation to estimate the\n// intersection point.\n\n// i think the best and most robust way to speed up the raymarch would be to downsample\n// the height texture, where each downsample computes the max of an e.g. 4x4 neighborhood,\n// and then raymarch against this instead, using the full resolution texture to compute\n// exact intersections.\n\n\nfloat h( vec3 p ) { return 4.*textureLod(iChannel0, p.xz/HEIGHTMAPSCALE + 0.5, 0. ).x; }\nfloat DE( vec3 p ) { return 1.2*( p.y - h(p) ); }\n\nfloat FindDist(inout vec3 ro, vec3 rd){\n    float t = 0.;\n    \n    float d = DE(ro + t*rd);\n\n    for( int i = 0; i < MARCHSTEPS; i++ )\n    {\n        if( abs(d) < EPSILON )\n            break;\n        \n        float dNext = DE(ro+(t+d)*rd);\n        \n        // detect surface crossing\n        // https://www.shadertoy.com/view/Mdj3W3\n\t\tfloat dNext_over_d = dNext/d;\n        if( dNext_over_d < 0.0 )\n        {\n            // estimate position of crossing\n\t\t\td /= 1.0 - dNext_over_d;\n\t\t\tdNext = DE( ro+rd*(t+d) );\n        }\n        \n\t\tt += d;\n\t\td = dNext;\n    }\n    return t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy/iResolution.xy;\n    vec2 qq = 2.*q - 1.;\n    \n#ifdef RAYMARCH\n    vec3 L = normalize(vec3(.3,.5,1.));\n    \n    // raymarch the milk surface\n    vec3 ro;\n    vec3 rd = computePixelRay( qq, ro );\n    float t = FindDist(ro, rd);\n    \n        \n    // hit the milk\n    if( t < MARCHFAR )\n    //if( d < eps ) // just assume always hit, turns out its hard to see error from this\n    {\n        vec3 p = ro+t*rd;\n        \n\t    fragColor = vec4( textureLod(iChannel0, p.xz/HEIGHTMAPSCALE+0.5, 0. ).x );\n        \n        // finite difference normal\n        float h0 = h(p);\n        vec2 dd = vec2(0.01,0.);\n        vec3 n = normalize(vec3( h0-h(p + dd.xyy), dd.x, h0-h(p + dd.yyx) ));\n        \n        // improvised milk shader, apologies for hacks!\n        vec3 R = reflect( rd, n );\n        float s = .4*pow( clamp( dot( L, R ), 0., 1. ), 4000. );\n        float ndotL = clamp(dot(n,L),0.,1.);\n        float dif = 1.42*(0.8+0.2*ndotL);\n        // occlude valleys a little and boost peaks which gives a bit of an SSS look\n        float ao = mix( 0.8, .99, smoothstep(0.,1.,(h0+1.5)/6.));\n        // milk it up\n        fragColor.xyz = SURFACE_COLOR*(dif)*ao + SURFACE_SPEC_COLOR*s;\n        // for bonus points, emulate an anisotropic phase function by creaming up the region\n        // between lit and unlit\n        float creamAmt = smoothstep( 0.2, 0., abs(ndotL - 0.2) );\n        fragColor.xyz *= mix( vec3(1.), SURFACE_ANIS_COLOR, creamAmt );\n    }\n    \n    // fade to background\n    vec3 bg = BACKGROUND + 0.5*pow(clamp(dot(L,rd),0.,1.),20.);\n    bg *= vec2(1.,0.97).yxx;\n    fragColor.xyz = mix( fragColor.xyz, bg, smoothstep(MARCHNEAR,MARCHFAR,t) );\n    \n\t// vignette (borrowed from donfabio's Blue Spiral)\n\tvec2 uv =  q.xy - 0.5;\n\tfragColor.xyz *= 1.0 - .5*dot(uv, uv);\n    \n#else\n    float f = 2.*texture(iChannel0, q).x;\n    vec3 col =\n       vec3(dist(-f-0.5, .1),\n            exp(-1.*pow(f,2.)),\n            dist(f-0.5, .1));\n    fragColor = vec4(col,1.);\n#endif\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// from https://www.shadertoy.com/view/Msy3D1\n// Riffing off tomkh's wave equation solver\n// https://www.shadertoy.com/view/Xsd3DB\n// article: http://freespace.virgin.net/hugo.elias/graphics/x_water.htm\n// 1-buffer version: https://www.shadertoy.com/view/4dK3Ww\n// 1-buffer with half res sim to maintain wave speed: https://www.shadertoy.com/view/4dK3Ww\n\n#define HEIGHTMAPSCALE 90.0\n\n//surface waves with raymarching light\n//\n#define RAYMARCH\n#define MARCHSTEPS 25\n#define EPSILON 0.1\n#define MARCHNEAR 95.\n#define MARCHFAR  130.\n\n#define SURFACE_COLOR vec3(0.82,0.82,0.79)\n//#define SURFACE_SPEC_COLOR vec3(1.,.79,0.74)\n#define SURFACE_SPEC_COLOR vec3(0.2,0.2,0.9)\n#define SURFACE_ANIS_COLOR vec3(1.,0.985,0.975)\n//#define BACKGROUND vec3(0.5)\n//#define SURFACE_COLOR vec3(0.,0.663,0.49)\n//#define SURFACE_SPEC_COLOR vec3(1.,.79,0.74)\n//#define SURFACE_ANIS_COLOR vec3(0.,0.9,0.8)\n#define BACKGROUND vec3(0.4,0.6,1.)\n\n\n// texture vs texeFetch load\n#define TEXELFETCH\n\nfloat dist(float x, float dx){\n    return 1./(1.+exp(-x/dx));\n}\n\nvec3 computePixelRay( in vec2 p, out vec3 cameraPos )\n{\n    // camera orbits around origin\n\t\n    float camRadius = 60.;\n\tfloat theta = -3.141592653/2.;\n    float xoff = camRadius * cos(theta);\n    float zoff = camRadius * sin(theta);\n    cameraPos = vec3(xoff,20.,zoff);\n     \n    // camera target\n    vec3 target = vec3(0.,0.,0.);\n     \n    // camera frame\n    vec3 fo = normalize(target-cameraPos);\n    vec3 ri = normalize(vec3(fo.z, 0., -fo.x ));\n    vec3 up = normalize(cross(fo,ri));\n     \n    // multiplier to emulate a fov control\n    float fov = .5;\n\t\n    // ray direction\n    vec3 rayDir = normalize(fo + fov*p.x*ri + fov*p.y*up);\n\t\n\treturn rayDir;\n}\n\n\nfloat rain_drop(float t, vec2 pos, vec2 Res){\n    pos -= fract(floor(t)*vec2(0.456665,0.708618))*Res;\n    float amp = 1. - step(.05, fract(t));\n\n    return .02*amp*smoothstep(20.,5.,length(pos));\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float screenscale = iResolution.x/640.;\n    vec3 dr = vec3(vec2(1.)/iResolution.xy,0.);\n    vec2 r = fragCoord.xy/iResolution.xy;\n    \n    // current value\n#ifdef TEXELFETCH\n    ivec2 ir = ivec2(fragCoord);\n    ivec3 d_ir = ivec3(1,1,0);\n    float A = texelFetch(iChannel0, ir, 0).x;\n    // neighbor values\n    float Bx = (texelFetch(iChannel1, ir - d_ir.xz, 0).x + texelFetch(iChannel1, ir + d_ir.xz, 0).x)*.5;\n    float By = (texelFetch(iChannel1, ir - d_ir.zy, 0).x + texelFetch(iChannel1, ir + d_ir.zy, 0).x)*.5;\n#else\n    float A = texture(iChannel0, r).x;\n    // neighbor values\n    float Bx = (texture(iChannel1, r - dr.xz).x + texture(iChannel1, r + dr.xz).x)*.5;\n    float By = (texture(iChannel1, r - dr.zy).x + texture(iChannel1, r + dr.zy).x)*.5;\n#endif\n\n    float f = 0.;\n\n    if( iMouse.z > 0. )\n    {\n#ifdef RAYMARCH\n        vec3 ro;\n        vec3 rd = computePixelRay( 2.*iMouse.xy/iResolution.xy - 1., ro );\n        if( rd.y < 0. )\n        {\n            vec3 mp = ro + rd * ro.y/-rd.y;\n            vec2 uv = mp.xz/HEIGHTMAPSCALE + 0.5;\n            f -= .02*smoothstep(20.,5.,length(uv*iResolution.xy - fragCoord.xy));\n        }\n#else\n        f -= .02*smoothstep(20.,5.,length(iMouse.xy - fragCoord.xy));\n#endif\n    }\n    else\n    {\n        // Simulate rain drops\n        f -= rain_drop(iTime*3., fragCoord.xy, iResolution.xy);\n    }\n\n    // The actual propagation:\n    f += -A + Bx + By;\n    f *= .99; // damping\n//    f *= step(.1, iTime); // hacky way of clearing the buffer or\n    f *= min(1.,float(iFrame)); // clear the buffer at iFrame == 0\n\n    fragColor.x = f;\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float screenscale = iResolution.x/640.;\n    vec3 dr = vec3(vec2(1.)/iResolution.xy,0.);\n    vec2 r = fragCoord.xy/iResolution.xy;\n    \n    // current value\n#ifdef TEXELFETCH\n    ivec2 ir = ivec2(fragCoord);\n    ivec3 d_ir = ivec3(1,1,0);\n    float A = texelFetch(iChannel0, ir, 0).x;\n    // neighbor values\n    float Bx = (texelFetch(iChannel1, ir - d_ir.xz, 0).x + texelFetch(iChannel1, ir + d_ir.xz, 0).x)*.5;\n    float By = (texelFetch(iChannel1, ir - d_ir.zy, 0).x + texelFetch(iChannel1, ir + d_ir.zy, 0).x)*.5;\n#else\n    float A = texture(iChannel0, r).x;\n    // neighbor values\n    float Bx = (texture(iChannel1, r - dr.xz).x + texture(iChannel1, r + dr.xz).x)*.5;\n    float By = (texture(iChannel1, r - dr.zy).x + texture(iChannel1, r + dr.zy).x)*.5;\n#endif\n\n    float f = 0.;\n\n    if( iMouse.z > 0. )\n    {\n#ifdef RAYMARCH\n        vec3 ro;\n        vec3 rd = computePixelRay( 2.*iMouse.xy/iResolution.xy - 1., ro );\n        if( rd.y < 0. )\n        {\n            vec3 mp = ro + rd * ro.y/-rd.y;\n            vec2 uv = mp.xz/HEIGHTMAPSCALE + 0.5;\n            f -= .02*smoothstep(20.,5.,length(uv*iResolution.xy - fragCoord.xy));\n        }\n#else\n        f -= .02*smoothstep(20.,5.,length(iMouse.xy - fragCoord.xy));\n#endif\n    }\n    else\n    {\n        // Simulate rain drops\n        f -= rain_drop(iTime*3., fragCoord.xy, iResolution.xy);\n    }\n\n    // The actual propagation:\n    f += -A + Bx + By;\n    f *= .99; // damping\n//    f *= step(.1, iTime); // hacky way of clearing the buffer or\n    f *= min(1.,float(iFrame)); // clear the buffer at iFrame == 0\n\n    fragColor.x = f;\n}\n","name":"Buffer B","description":"","type":"buffer"}]}