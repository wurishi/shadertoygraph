{"ver":"0.1","info":{"id":"3tsczH","date":"1591630176","viewed":183,"name":"Bezier Quadric","username":"spalmer","description":"demonstrating how to compute bezier closest point, distance in one of the more efficient ways.\nspecial thanks to [url=http://shadertoy.com/user/bloxard]Per Bloksgaard[/url] and, as usual, iq!\n","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["bezier","spline","curve","quadratic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// I finally made a decent spline solver, and dusted off my old spline stuff,\n// Hope it helps somebody.\n\n// iq did http://shadertoy.com/view/ldj3Wh and others in 2013!\n// bloxard posted in 2014-01-03.  Influenced by both and others.\n\n// I refactored their solvers and spline code out.\n// I also managed to port iq's clever cubic solver fix\n// using taylor series expansion to avoid cancellation errors\n// back to other solvers, that took a lot of coffee.\n\n// Extra special thanks to Steve Noskowicz, who\n// long ago taught me everything I know about splines.\n\n// It's getting real hard to find my way around in this toy now,\n// so I moved a bunch of the solvers back to http://shadertoy.com/view/flyGDD\n// and moved other people's reference spline code into Common\n// just to get out of the way.\n\n// if an inexact approximation is good enough,\n// see also Bezier Quadric Approx at http://shadertoy.com/view/dsj3Wy\n\n// http://shadertoy.com/view/flyGDD\nvec3 CubicSpalmerInlined(vec4 k)\n{\n    float NaN = uintBitsToFloat(0x7f800001u);\n    float d = k.x, c = k.y, b = k.z, a = k.w;\n    if (a == 0.) { // quadratic inlined\n        if (b == 0.)\n            return vec3(-d/c, NaN, NaN); // handle malformed eqn, let divide handle c == 0 case\n        float n = c * c - 4. * b * d; // discriminant\n        return vec3(n < 0. ? vec2(NaN) :\n            .5 / b * (sign(b) * sqrt(n) * vec2(-1, 1) - c) // two solutions, lesser first (may be identical)\n            , NaN);\n    }\n    d /= a; c /= a; b /= a;\n    float x = b/-3.; // inflection point\n    d += (c - 2.*x*x)*x; c += b*x; // depress cubic\n    float l = c / 3.,\n        s = l*l*l,\n        m = d*d + 4.*s;\n    if (m > 0.) { // 1 real root\n        vec2 w = sqrt(m) * vec2(1,-1) - d;\n        float v = abs(w.x) < abs(w.y) ? w.y : w.x;\n        v = sign(v) * pow(.5*abs(v), 1./3.);\n        return vec3(v - l / v, NaN, NaN) + x; // Blinn single cbrt idea\n    }\n    // 2 or 3 distinct roots\n    return 2. * sign(c)*sqrt(abs(l)) * cos((atan(sqrt(-m), -sign(c)*d) - acos(-1.) * vec3(0,2,4))/3.) + x;\n}\n\n\n// http://shadertoy.com/view/flyGDD\nvec3 CubicSpalmer(float d, float c) // b = 0, a = 1\n{\n    float l = c / 3.\n    , s = l*l*l\n    , m = d*d + 4.*s;\n    if (m > 0.) { // 1 real root\n        vec2 w = (sqrt(m) * vec2(1,-1) - d) * .5;\n        float v = cbrt(abs(w.x) < abs(w.y) ? w.y : w.x);\n        return vec3(v - l / v, NaN, NaN); // Blinn single cbrt idea\n    }\n    // 2 or 3 distinct roots\n    float t = atan(sqrt(-m), -sign(c)*(d));\n    return 2. * ssqrt(l) * cos((t - pi * vec3(0,2,4))/3.);\n}\n        // ok I think I fixed it now, so I may no longer actually need iq's fix.... wow!\n        /*if (false && abs(c) < .004)\n        { // credit: iq from comment at http://shadertoy.com/view/dsfGWN\n            float k = s/d;  // linear approx\n            //k *= 1. + s/(d*d);  // quadratic approx \n            w = vec2(k, -k-d);\n        }\n        w = cbrt(w);\n        return vec3(w.x + w.y, NaN, NaN);*/\n        // yeah without iq's fix above, this really screws things up;\n        // with iq's fix, it does pretty well but still has a glitch\n        // must ensure it's done totally robustly or makes things worse!\n        // well, I'm working on it.\n    //    return vec3(w.x - l / w.x, NaN, NaN); // TODO blinn single cbrt idea\n\n// solve x³ + cx + d = 0\nvec3 CubicDepressed(float d, float c)\n{\n    vec3 k = vec3(d, c, 0.);\n//    return solveCubicspalmeriq(k);\n// for purpose of computing distance to quadric bezier,\n// middle solution will never be closest, so sort last to exclude it.\n//    return CubicBloxard(d, c).xzy;\n    return CubicSpalmer(d, c).xzy;\n}\n// by spalmer http://shadertoy.com/view/flyGDD\nvec3 CubicDepress(vec3 k)\n{\n    float d = k.x, c = k.y, b = k.z, x = b/-3.; // inflection point\n    return CubicDepressed((c - 2.*x*x)*x + d, c + b*x) + x;\n}\n// solve ((t + k.z)*t + k.y)*t + k.x = 0 for t\nvec2 Cubic(vec3 k)\n{\n    return CubicDepress(k).xy;\n}\n// solve ((k[3] * t + k[2]) * t + k[1]) * t + k[0] = 0\nvec2 Cubic(vec4 k)\n{\n    return CubicSpalmerInlined(k).xz;\n    if (k.w == 0.) return Quadratic(k.xyz);\n    return Cubic(k.xyz/k.w);\n}\n\n// fork of FabriceNeyret2  http://shadertoy.com/view/XtdyDn  origin: bloxard\nfloat bezierSpalmer(vec2 p, QuadricBezier q, out vec2 nv, out float nd2)\n{\n    vec2 u = q.b - q.a, v = q.c - q.b,\n\t b = v - u, d = q.a - p;\n    vec2 s[3] = vec2[3] ( d, 2.*u, b );\n    vec4 k = vec4(\n        dot(d,u),\n        2.*sqr(u) + dot(d,b),\n        3.*dot(b,u),\n        sqr(b));\n\tvec2 r = Cubic(k);\n    r = clamp(r, 0., 1.);\n    // check distance to both solutions and return closer root\n    vec2 qx = eval(r.x, s), qy = eval(r.y, s);\n    float dx = sqr(qx), dy = sqr(qy);\n    float t;\n    // since already found closest point on curve and quadrance to it, \n    // return those too so caller doesn't need to recompute\n    if (dx < dy) {\n        t = r.x; nv = qx; nd2 = dx;\n    } else {\n        t = r.y; nv = qy; nd2 = dy;\n    }\n    return t;\n}\n\nfloat indexSpalmer(vec2 p, QuadricBezier q)\n{\n    vec2 v; float dd;\n    return bezierSpalmer(p, q, v, dd);\n}\n\nvec2 Snap(vec2 p, QuadricBezier q)\n{\n    vec2 v; float dd;\n    float t = bezierSpalmer(p, q, v, dd);\n    return p + v;\n\t//return Eval(q, indexspalmer(p, q));\n}\n\nvec2 Normal(vec2 p, QuadricBezier q) \n{\n    vec2 v; float dd;\n    float t = bezierSpalmer(p, q, v, dd);\n    if (abs(dd) > 1e-8) // if p not exactly on curve q\n        v *= -inversesqrt(abs(dd)); // v = normalize(-v);\n    else // must obtain using derivative of curve instead\n        v = EvalNormal(q, t);\n    return v;\n\t//return normalize(p - Snap(p, q));\n}\n\n// everything down here is really just hosting code and wrappers \n// specific to Shadertoy or this particular toy's mainImage.\n// All the decision which method to use goes here.\n\n// return index of closest point on q to p\nfloat Index(vec2 p, QuadricBezier q)\n{\n    return indexSpalmer(p, q);\n//    return indexBezieriq2022(p, q);\n//    return indexiq2022(p, q);\n//    return indextomkh(p, q);\n//    return indexfabloxwrapper(p, q);\n}\n// returns index t useful with Eval(q, t) or EvalTangent(q, t)\n\n// returns (possibly signed) squared distance\nfloat DistanceSquared(vec2 p, QuadricBezier q) \n{\n  // but note that not all solvers benefit from this since it impacts precision on the measurements of the spline itself independent of query point\n//    return DistanceSquared(QuadricBezier(q.a - p, q.b - p, q.c - p)); //    q.a -= p; q.b -= p; q.c -= p; return DistanceSquared(q); //\n    return sqr(p - Snap(p, q)); //vec2 c = p - Snap(q, p); return dot(c, c); //\n}\n\nfloat Distance(vec2 p, QuadricBezier q) \n{\n//    return sdBezieriq(p, q.a, q.b, q.c); // iq's high quality signed distance\n//    return sqrt(DistanceSquared(p, q));\n    // expect and handle signed squared distance and propagate the sign to the result\n    float dd = DistanceSquared(p, q);\n    return sqrt(abs(dd)) * sign(dd);\n}\t\t\n\nfloat signBezier(vec2 p, QuadricBezier q, float t)\n{\n     return pdot(EvalTangent(q, t), p - Eval(q, t));\n} \n\nfloat d2cage(vec2 p, QuadricBezier q)\n{\n    vec2 mp = Mid(q);\n    float d1 = d2seg(p, q.a, q.b)\n        , d2 = d2seg(p, q.b, q.c)\n    //, d3 = d2seg(p, q.b, mp)\n    //, d3 = d2seg(p, q.a, mp)\n    //, d4 = d2seg(p, mp, q.c)\n    //, d5 = d2approx1(p, q)\n    ;\n    return min(d1, d2);\n}\n\n// \"standard\"-ish sdf gradient debugging    \nvec3 DebugSDF(float d)\n{\n    vec3 c = vec3(1) - sign(d)*vec3(.1,.5,.9);\n\tc *= 1. - exp2(-3. * abs(d));\n\tc *= .8 + .2 * cos(120.*d);\n    return c;\n}\n\n#define R  iResolution.xy\n\nvec2 viewport(vec2 s)\n{\n    return (2.*s-R)*.6/R.y;\n}\n    \nfloat aa(float d)\n{\n    return clamp(.5 + .4*R.y*d, 0., 1.);\n}\n\nconst vec2 spin = vec2(0,11); //0,.5*acos(-1.));\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    vec2 q = viewport(p)\n    , m = viewport(iMouse.xy);\n    float anim = .2 * (iTime + 0.);\n    vec2 p0 = vec2(-.5, .5), p1 = vec2(sin(anim), -.5), p2 = vec2(1, 0);\n    // exercise more configurations by rotating more; try 3 lissajous\n    p0 = .95 * sin(spin + 1.1*anim) * vec2(1,.5);\n    p1 = .97 * sin(spin + 3. *anim) * vec2(1,.5);\n    p2 = .99 * sin(spin - 2.2*anim) * vec2(1,.5);\n\tQuadricBezier bez = QuadricBezier(p0, p1, p2);\n    vec2 cm = Snap(m, bez)\n       , cq = Snap(q, bez)\n       , nq = Normal(q, bez);\n    float curve = Distance(q, bez)\n    , dmq = d2seg(q, m, cm)\n    , dcage = d2cage(q, bez)\n    , d = sqrt(min(dcage, dmq))\n    ;\n    float qs = sign(signBezier(q, bez, Index(q, bez)));\n    curve *= qs;\n    vec3 c = DebugSDF(curve * -3.);\n    c *= vec3(sqrt(nq * .5 + .5), 1); // show normal, brightened\n    //c.b = qs * .5 + .5; // old show sidedness sign in blue\n    c = mix(vec3(0,.9,0), c, aa(1./1.*abs(distance(q, m)-distance(m, cm)))); // show circle green\n    c = mix(vec3(.3,.3,1), c, aa(d)); // debug lines blue\n    float ta = sin(10.*anim)*.5+.5;\n    float dcj = sqrt(//min(\n        d2seg(q, mix(p0, p1, ta), mix(p1, p2, ta))\n    //)\n    );\n//    c = mix(vec3(0), c, aa(dcj)); // show de Castlejau construction\n    c = mix(vec3(1), c, aa(abs(curve) - 2./R.y)); //smoothstep(.0,.00666,abs(curve))); // stroke curve white\n//    c = mix(vec3(.7,0,0), c, aa(length(q - Eval(bez, clamp(ApexIndex(bez), 0., 1.))) - 3./R.y)); // apex dot red\n//    c = mix(vec3(0,0,.8), c, aa(distance(q, mix(mix(p0, p1, ta), mix(p1, p2, ta), ta)) - 6./R.y)); // de Castlejau dot blue\n    o = vec4(sqrt(c),1); // approximately sRGB gamut output\n}\n// TODO would be pretty easy to show the de Castlejau construction segments, swept over time","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float NaN = uintBitsToFloat(0x7f800001u);\nconst float invalid = NaN; //-3.4e38;\n\nconst float pi = acos(-1.);\n\nfloat sqr(float x) { return x * x; }\nfloat sqr(vec2  x) { return dot(x, x); }\n\nfloat ssqrt(float x) { return sign(x) * sqrt(abs(x)); }\nfloat spow(float x, float y) { return sign(x) * pow(abs(x), y); }\nfloat cbrt(float x) { return spow(x, 1./3.); } //sign(x) * pow(abs(x), 1./3.); } //\nvec2 cbrt(vec2 x) { return sign(x) * pow(abs(x), vec2(1./3.)); } // compute 2 cube roots at once\n\nvec2 perp(vec2 q)\n{\n    return vec2(q.y, -q.x);\n}\n\n// antisymmetric product\nfloat pdot(vec2 a, vec2 b) // aka cross2 or det 2x2\n{\n    //return dot(a, perp(b));\n    return a.x*b.y - a.y*b.x;\n}\n// Hoppe called it det as it's the determinant of the 2x2 matrix\n\n// branchless by spalmer\nvec2 Quadratic(vec3 k)\n{\n    float c = k.x, b = k.y, a = k.z;\n    return .5 / a * (sign(a) * sqrt(b * b - 4. * a * c) * vec2(-1, 1) - b);\n}\n\n// a quadratic bezier struct\nstruct QuadricBezier\n{\n\tvec2 a, b, c;\n};\n// support 'methods'\n// compute polynomial p[1]*t + p[0]\nvec2 eval(float t, in vec2 p[2])\n{\n    return p[1] * t + p[0];\n}\n\nvec2 eval(float t, in vec2 p[3])\n{\n    return (p[2] * t + p[1]) * t + p[0];\n}\n\nvec2 eval(float t, in vec2 p[4])\n{\n    return ((p[3] * t + p[2]) * t + p[1]) * t + p[0];\n}\n\nvec2 eval2(float t, in vec2 p[3])\n{\n    //return eval(t*t, p); // NO\n    vec2 r = eval(t, p); return r*r;\n    //return sqr(eval(t, p)); // NO\n}\n\n/*float eval(float t, vec3 p)\n{\n    return (p[2] * t + p[1]) * t + p[0];\n}*/\n\n/*float eval(float t, vec4 p)\n{\n    return (((p[3] * t) + p[2]) * t + p[1]) * t + p[0];\n}*/\n/*\nfloat Horner(vec3 x, float t) \n{\n    float r = 0.;\n\tfor (int i = 3; i-- > 0; r = r * t + x[i]);\n\treturn r;\n}\n*/\n\n// t from 0 to 1\nvec2 Eval(QuadricBezier q, float t)\n{\n    float mt = 1.-t;\n\treturn q.a * mt * mt + q.b * (2. * t * mt) + q.c * t * t;\n}\n// return mix(mix(q.a, q.b, t), mix(q.b, q.c, t), t);\n\nvec2 EvalTangent(QuadricBezier q, float t) \n{\n    return 2. * mix(q.b - q.a, q.c - q.b, t);\n}\n\n// in 2d I could either do the perp to the tangent (easy)\n// or compute the 2nd derivative of the curve (harder but doable)\n// not clamped to the 0..1 index range btw\nvec2 EvalGradient(QuadricBezier q, float t)\n{\n    return -perp(EvalTangent(q, t));\n}\n// TODO probably a more direct way to compute it\nvec2 EvalNormal(QuadricBezier q, float t)\n{\n    return normalize(EvalGradient(q, t));\n//    return normalize(-perp(EvalTangent(q, t)));\n}\n\n// index of q along the segment from origin to d\nfloat iseg(vec2 q, vec2 d)\n{\n    return clamp(dot(q,d) / sqr(d), 0., 1.);\n}\n\n// squared distance from q to segment ab\nfloat d2seg(vec2 q, vec2 a, vec2 b)\n{\n    q -= a; b -= a;\n    float si = iseg(q, b);\n    q -= b * si;\n    return sqr(q);\n}\n\nvec2 Mid(QuadricBezier q)  // a central point on the curve\n{\n\treturn .25 * (q.a + 2.*q.b + q.c);\n}\n\n// the t index of the apex of the parabola it's an arc of\n// http://en.wikipedia.org/wiki/Parabola#As_the_affine_image_of_the_unit_parabola\nfloat ApexIndex(QuadricBezier q)\n{\n    vec2 v = q.a - 2.*q.b + q.c;\n    return dot(q.a - q.b, v) / dot(v, v);\n}\n\n#if 0\nmat3x2 PolynomialOf(QuadricBezier q)\n{\n\treturn mat3x2(\n\t q.a, \n\t(q.b - q.a) * 2.,\n\t q.a + q.c - 2.*q.b\n\t);\n}\n \n// Bezier for only three points, a parabolic segment\n// p(t) = (1-t)^2*p0 + 2*(1-t)*t*p1 + t^2*p2, t in 0..1\nconst mat3 mQuadricBezier = mat3(\n  1, 0, 0,\n -2, 2, 0,\n  1,-2, 1\n);\n\n \n// unused old code of mine ported from C# but potentially useful:\n\nvec2 Foot(QuadricBezier q)  // midpoint of a and c\n{ \n\treturn (q.a + q.c) * .5;\n}\n\n// from 0 to .5\nQuadricBezier LowerHalf(QuadricBezier q)\n{\n    return QuadricBezier(q.a, (q.a + q.b) * .5, Mid(q));\n}\n// from .5 to 1\nQuadricBezier UpperHalf(QuadricBezier q)\n{\n    return QuadricBezier(Mid(q), (q.b + q.c) * .5, q.c);\n}\n\nbool Degenerate(QuadricBezier q)\n{\n    return dot(q.c - q.a, q.c - q.a) < 1e-7;\n}\n\n// recombine 2 halves' sub-indices to one full index\nfloat Combine(bool which, float a, float b)\n{\n    return .5 * (which ? a + 1. : b);\n}\n \n// convert quadric bezier control points\n// to parametric polynomial matrix form\nmat3x2 QuadricBezier(vec2 a, vec2 b, vec2 c)\n{\n\treturn mat3x2(a, 2.*(b - a), c - 2.*b + a);\n}\n\n// evaluate point on parametric curve from control points\nfloat QuadricBezier(float t, float a, float b, float c)\n{\n\treturn a + t * (2. * (b - a) + t * (c - 2.*b + a)));\n}\nvec2 QuadricBezier(float t, vec2 a, vec2 b, vec2 c)\n{\n\treturn a + t * (2. * (b - a) + t * (c - 2.*b + a)));\n}\n#endif\n\n// could instead search for the zero of the cross of the derivative of spline at t with direction to point on spline from query,\n// the place on spline most directly facing at the query is the closest point to the query.\n\n#if 0\n// http://shadertoy.com/view/ltXSDB by ajs15822 is quite good, CCA 3 2015-08-12\n// BUT I'm fairly sure it's actually based on bloxard's also (same solver) :)\n// Find the (un)signed distance from a point to a bezier curve\n// I did not refactor this one out between index and dist2 (yet!)\n// but simply converted it to return the closest index\n// tomkh worked on it at http://shadertoy.com/view/lssBDM\n// did not change solver at all, it seems\n// Find the (un)signed distance from a point to a quadratic bezier curve\nfloat indextomkh(vec2 p, QuadricBezier q)\n{\n    vec2 A = q.a, B = q.b, C = q.c;\n    // prevent 3 colinear points, should be better solution.\n    //B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    // Calculate roots.\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);      \n    vec2 t = clamp(solveCubicReal(k.zyx).xy, 0., 1.);\n    // note: 3rd root is actually unnecessary, it's never closest!\n    // [Tom'2017] simplified calculations\n    vec2 dp1 = d + (c + b*t.x)*t.x;\n    float d1 = dot(dp1, dp1);\n    vec2 dp2 = d + (c + b*t.y)*t.y;\n    float d2 = dot(dp2, dp2);\n    return d1 < d2 ? t.x : t.y; // spalmer removed the sign stuff for now\n}\n#endif\n\n\n// these do really well, but since they haven't had the\n// cubic solver refactored out, they are very hard-coded\n// for the bezier problem and difficult to work with.\n\n#if 0\n// TODO iq uses query-relative perpdot with tangent at index to determine sign, prior to choosing;\n// could do that afterward once closest index is known\n\n// spalmer modified it to also compute the index, returned now in w.\n// I also rearranged the normal into .xy and put squared distance into z instead.\n\n// The MIT License\n// Copyright © 2022 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance and gradient to a quadratic bezier segment.\n// Faster than central differences or automatic differentiation/duals.\n\n// .xy = ∇f(p) normalize(∂f(p)/∂x, ∂f(p)/∂y)\n// .z = f(p)²\n// .w = index t useful with Eval or EvalTangent(QuadricBezier(A,B,C), t)\nfloat indexiq2022(vec2 p, QuadricBezier q)\n{  \n    vec2 A = q.a, B = q.b, C = q.c;\n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - p;\n\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a) + dot(d,b))/3.0;\n    float kz = kk * dot(d,a);      \n\n    vec3 res;\n\n    float p  = ky - kx*kx;\n    float q  = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float p3 = p*p*p;\n    float q2 = q*q;\n    float h  = q2 + 4.0*p3;\n//#define E(t) (d+(c+b*(t))*(t))\n    // refactored; I like it better this way: spalmer\n  #define E(t) ((b*(t) + c)*(t) + d)\n    // seems to evaluate curve relative to pos query point\n    float T; // index: spalmer\n    if (h >= 0.)  // 1 root\n    {   \n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n\n      #if 1\n        // When p≈0 and p<0, h-q has catastrophic cancelation. So, we do\n        // h=√(q²+4p³)=q·√(1+4p³/q²)=q·√(1+w) instead. Now we approximate\n        // √ by a linear Taylor expansion into h≈q(1+½w) so that the q's\n        // cancel each other in h-q. Expanding and simplifying further we\n        // get x=vec2(p³/q,-p³/q-q). And using a second degree Taylor\n        // expansion instead: x=vec2(k,-k-q) with k=(1-p³/q²)·p³/q\n        if (abs(p) < 0.001)\n        {\n            float k = p3/q;              // linear approx\n        //  float k = (1.0-p3/q2)*p3/q;  // quadratic approx \n            x = vec2(k, -k-q);  \n        }\n      #endif\n\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp(uv.x+uv.y-kx, 0.0, 1.0);\n        vec2  q = E(t); //d+(c+b*t)*t;\n        res = vec3(dot(q,q), q);\n        T = t;\n    }\n    else          // 3 roots\n    {   \n        float z = sqrt(-p);\n        float v = acos(q/(p*z*2.0))/3.0;\n        float m = cos(v);\n        float n = sin(v)*sqrt(3.0); //1.732050808; // \n        vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0);\n        // check which of two nearer roots is closer\n        vec2  qx = E(t.x)/*d+(c+b*t.x)*t.x*/; float dx=dot(qx,qx);\n        vec2  qy = E(t.y)/*d+(c+b*t.y)*t.y*/; float dy=dot(qy,qy);\n        T   = (dx<dy) ? t.x : t.y;\n        res = (dx<dy) ? vec3(dx,qx) : vec3(dy,qy);\n    }\n#undef E    \n    return T;\n}\n// at this point I have it isolated enough I could probably\n// go ahead and extract the solver\n#endif\n\n#if 0\n// once have witnessed iq's marvellous toy at http://shadertoy.com/view/DdlGD8,\n// one wonders why should bother to try any more.\n// But perhaps even seemingly perfect code may be improved.\n\n// total refactor attempting to find closest index by extracted cubic solver: spalmer\nfloat indexBezieriq2022(vec2 p, QuadricBezier q)\n{\n    vec2 A = q.a, B = q.b, C = q.c,\n      m = B - A,\n      b = A - 2.0*B + C, // quadratic,\n      c = 2.0*m, // linear,\n      d = A - p; // constant terms\n    // compute coeffs of cubic equation to solve:\n    vec3 k = vec3(\n         dot(b,m),\n        (2.*sqr(m) + dot(d,b))/3.0, //dot(c,m) == 2.*sqr(m)\n         dot(d,m)\n        ) / max(sqr(b), 1e-7);\n    //vec2 r = solveCubiciqspalmer(k).xy; // do iq's way directly\n    // convert coeffs for use by other solvers instead\n    vec2 r = solveCubicReal(vec3(3. * k.x,  3. * k.y, k.z));\n    r = clamp(r, 0., 1.);\n    // check distance to both solutions and return closer root\n    vec2 s[3] = vec2[3] ( d, c, b );\n    vec2 qx = eval(r.x, s), qy = eval(r.y, s);\n    float dx = sqr(qx), dy = sqr(qy);\n    return dx<dy ? r.x : r.y;\n}\n// equation (b*t + c)*t + d produces a point\n// on spline at t relative to query point p\n#endif\n\n\n// TODO sign of the distance\n// most of these just compute unsigned distance,\n// disregarding which side of the curve the query is on.\n// how would one extend signed distance to 3d anyway?\n\n// anyway once you have the polynomial form of the curve\n// you can easily compute the derivative of the polynomial\n// then can use those two functions to easily solve\n// for the t which minimizes the perp with the derivative\n// using whatever minimizer.\n// in fact can be recursively subdivided\n// using the derivative at each step \n// to help find the zeroes. TODO\n\n// Another way that's probably slower, but probably more reliable\n// is to simply check both halves at every step, keeping the closest overall.\n\n// TODO see paper by Nickalls 1993\n// A new approach to solving the cubic: Cardan’s solution revealed\n// http://nickalls.org/dick/papers/maths/cubic1993.pdf\n// has some useful reparameterization insights\n// including how to compute the reduced cubic, and N the point of inflection\n\n// see http://blog.gludion.com/2009/08/distance-to-quadratic-bezier-curve.html\n\n// it was already done parabola way in glsl\n// by astiopin at http://shadertoy.com/view/tdsGDj\n// iq's done excellent parabolas also.\n// All the parabola conversion adds unnecessary complexity!\n// That's what I've been trying to bypass.\n\n// OLD partially-refactored variant\n#if 0\n// FabriceNeyret2 tried to clean it up at http://shadertoy.com/view/XtdyDn\n// cleanup of \"Bezier DistanceGlow\" by bloxard. http://shadertoy.com/view/XdB3Ww\n// bloxard's is great, but explained in danish and whiteboard snapshots\n// derived from fabrice's cleanup of bloxard's toy\n// refactored; still needs these out args and a wrapper though FIXME\nvec2 fabloxcore(vec2 p, QuadricBezier q, out vec2 A, out vec2 B, out vec2 C, out vec2 D)\n{\n    vec2 a = q.a, b = q.b, c = q.c;\n\tb = mix(b+vec2(1e-4), b, abs(sign(b*2. - a - c))); // this kludge bothers me, don't trust it, but it doesn't affect the glitch\n\tA = b-a, B = c-b-A, C = p-a, D = 2.*A;\n    // divide by -B^2 to normalize equation so highest order coeff is then implicitly 1.0 as solver requires\n\tvec2 P = solveCubicReal(vec3(3.*dot(A,B), 2.*sqr(A) - dot(C,B), -dot(C,A)) / (sqr(B) + 1e-7));\n    return clamp(P, 0., 1.); // curve parameterization\n}\n// it mainly gets confusing due to all these cipher letters!\n// also returns a convenient, if weird, bezier-relative breakdown.\n// How to solve the equation can be seen on this image:\n// http://perbloksgaard.dk/research/DistanceToQuadraticBezier.jpg\n\n// strangely, since must compute the actual points to get the distances\n// to determine which is closest, it's as fast to get the index\n// as to get the points.\nfloat indexfabloxwrapper(vec2 p, QuadricBezier q)\n{\n    vec2 A, B, C, D,\n    P = fabloxcore(p, q, A, B, C, D);\n    // seems must check both sides anyway to know which is closer\n\treturn sqr((D+B*P.x)*P.x - C)\n        <  sqr((D+B*P.y)*P.y - C)\n        ? P.x : P.y;\n}\n// bezierSpalmer in Image tab is a cleaned up variation of this\n#endif\n\n// now refactored all the methods to compute nearest index of curve instead\n\n#if 0\n// not currently using any of these query-relative formulations\nfloat DistanceSquared(QuadricBezier q) \n{\n    const vec2 p = vec2(0);\n    vec2 c = p - Snap(q, p);\n    return dot(c, c);\n}\nfloat Distance(QuadricBezier q) \n{\n    return sqrt(DistanceSquared(q));\n}\t\n// I've tried it; it works out ok, but pretty sure isn't optimal as it reduces precision unnecessarily.\n// one thing that it does do well is that then evaluating points on the polynomial\n// are automatically relative to the query point, so can just square to obtain distance.\n#endif\n\n// mainImage debugging stuffs:\n    //if (isnan(curve)) c = vec3(1,0,1); // * abs(sin(iTime));\n    //if (isinf(curve)) c = vec3(1,0,0); // * abs(sin(iTime));\n    //if (curve < .00005) c = vec3(0,1,0);\n    //if (curve > .000005) c = vec3(0,0,1);\n    //if (curve >= 0. && curve < .00005) c = vec3(1); //vec3(0,0,1); // wow somehow this eliminates the travelling glitch, so... it logically must be a value in this range somewhere\n    //if (curve <= .0) c = vec3(1,1,0);\n\n// see http://shadertoy.com/view/3llcR8","name":"Common","description":"","type":"common"}]}