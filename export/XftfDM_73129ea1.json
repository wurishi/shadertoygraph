{"ver":"0.1","info":{"id":"XftfDM","date":"1733310620","viewed":32,"name":"Pixelplanet - Terra with Rings","username":"recast","description":"A planet with customizable terrain, sea/land colors, rings, and lighting. Features dynamic shadows, atmosphere, and a starry background. Retro aesthetic with adjustable parameters for unique planet generation. Seed-based randomness for consistent results.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["procedural","2d","noise","terrain","raycast","retro","rings","lighting","space","planet","dither","shadows","shader","stars","pixelart"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PIXELS 150\n#define MAX_COLOR_PALETTE_SIZE 16 // Set a reasonable maximum size\n#define SHADING_PALETTE_SIZE 2\n\n// Customizable Parameters (Uniforms)\nfloat uPlanetSize = 0.75;\nfloat uRingDistance = 0.5;\nfloat uRingSize = 0.5;\nfloat uRingNoiseScale = 35.0;\n\nfloat uEquatorNoiseScale = 3.5;\nfloat uPoleNoiseScale = 3.5;\n\nvec3 uPlanetAxis = vec3(0.2,1.0,0.3);\n\nfloat uPlanetRotationSpeed = 0.1;\nfloat uLightRotationSpeed = 0.2;\n\nfloat uNoiseFrequency; // not used yet\nint uNoiseOctaves = 2;\nfloat uNoisePersistence = 0.15;\nfloat uNoiseLacunarity = 5.0;\nfloat uDitherEdgeSize = 15.0;\nint uRandomSeed = 215;\n\n#define RGB(r,g,b) (vec3(r,g,b) / 255.0)\n\n\n// New Uniforms for Sea/Land Customization\nfloat uHueShift = 0.0;\nfloat uSeaLevel = 0.55;\nint uSeaShades = 6;\nint uLandShades = 8;\nvec3 uSeaColor = RGB(14, 63, 240);\nvec3 uLandColor = RGB(0, 220, 80); // trees\n//vec3 uLandColor = RGB(194, 179, 85); // desert\n//vec3 uLandColor = RGB(115, 114, 110); // rock\n\n\nvec3 uRingColor = vec3(0.7,0.75,1.0);\n\n\n// Constants for seed manipulation\n#define MAX_SEED_VALUE 80000\n\n// Improved hash function that incorporates the seed more subtly\nfloat hash(float n, float fSeed) {\n    // Use a combination of sin and fract with different prime numbers\n    // and incorporate the seed in a way that doesn't dominate\n    float h1 = fract(sin(n * 1234.5678 + fSeed * 9876.5432) * 43758.5453123);\n    float h2 = fract(cos(n * 5678.1234 + fSeed * 5432.9876) * 85453.3545123);\n    \n    // Mix the two hash functions\n    return mix(h1, h2, 0.5);\n}\n\n// Random Number Generator (Seed-Based)\nfloat rand(vec2 p, float fSeed) {\n    return hash(dot(p, vec2(12.9898, 78.233)), fSeed);\n}\n\nfloat rand1D(float x, float fSeed) {\n    return hash(x * 1589.345, fSeed);\n}\n\n// Color conversion functions\nvec3 rgb2hsv(vec3 c) {\n    float maxVal = max(c.r, max(c.g, c.b));\n    float minVal = min(c.r, min(c.g, c.b));\n    float delta = maxVal - minVal;\n\n    float h = 0.0;\n    if (delta > 0.0) {\n        if (maxVal == c.r) {\n            h = mod((c.g - c.b) / delta, 6.0);\n        } else if (maxVal == c.g) {\n            h = (c.b - c.r) / delta + 2.0;\n        } else {\n            h = (c.r - c.g) / delta + 4.0;\n        }\n        h /= 6.0;\n        if (h < 0.0) h += 1.0;\n    }\n\n    float s = maxVal == 0.0 ? 0.0 : delta / maxVal;\n    float v = maxVal;\n    return vec3(h, s, v);\n}\n\nvec3 shiftHue(vec3 hsv, float shift) {\n    hsv.x = fract(hsv.x + shift);\n    return hsv;\n}\n\nvec3 hsv2rgb(vec3 c) {\n    float h = c.x * 6.0;\n    float s = c.y;\n    float v = c.z;\n\n    float i = floor(h);\n    float f = h - i;\n    float p = v * (1.0 - s);\n    float q = v * (1.0 - s * f);\n    float t = v * (1.0 - s * (1.0 - f));\n\n    if (i == 0.0) return vec3(v, t, p);\n    if (i == 1.0) return vec3(q, v, p);\n    if (i == 2.0) return vec3(p, v, t);\n    if (i == 3.0) return vec3(p, q, v);\n    if (i == 4.0) return vec3(t, p, v);\n    return vec3(v, p, q);\n}\n\nvec3 hueShift(vec3 color, float shift) {\n    vec3 hsv = rgb2hsv(color);\n    hsv = shiftHue(hsv, shift);\n    return hsv2rgb(hsv);\n}\n\n// Noise functions (Modified to use the improved hash function)\nfloat noise1D(float x, float fSeed) {\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(hash(i, fSeed), hash(i + 1.0, fSeed), u);\n}\n\nfloat noise3D(vec3 p, float fSeed) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f);\n\n    float n000 = hash(dot(i + vec3(0.0, 0.0, 0.0), vec3(1.0, 57.0, 113.0)), fSeed);\n    float n001 = hash(dot(i + vec3(0.0, 0.0, 1.0), vec3(1.0, 57.0, 113.0)), fSeed);\n    float n010 = hash(dot(i + vec3(0.0, 1.0, 0.0), vec3(1.0, 57.0, 113.0)), fSeed);\n    float n011 = hash(dot(i + vec3(0.0, 1.0, 1.0), vec3(1.0, 57.0, 113.0)), fSeed);\n    float n100 = hash(dot(i + vec3(1.0, 0.0, 0.0), vec3(1.0, 57.0, 113.0)), fSeed);\n    float n101 = hash(dot(i + vec3(1.0, 0.0, 1.0), vec3(1.0, 57.0, 113.0)), fSeed);\n    float n110 = hash(dot(i + vec3(1.0, 1.0, 0.0), vec3(1.0, 57.0, 113.0)), fSeed);\n    float n111 = hash(dot(i + vec3(1.0, 1.0, 1.0), vec3(1.0, 57.0, 113.0)), fSeed);\n\n    return mix(mix(mix(n000, n100, f.x), mix(n010, n110, f.x), f.y),\n               mix(mix(n001, n101, f.x), mix(n011, n111, f.x), f.y),\n               f.z);\n}\n\nfloat perlinNoise3D(vec3 p, float frequency, int octaves, float persistence, float lacunarity, float fSeed) {\n    float total = 0.0;\n    float amplitude = 1.0;\n    float maxValue = 0.0;\n\n    for (int i = 0; i < octaves; i++) {\n        total += noise3D(p * frequency, fSeed) * amplitude;\n        maxValue += amplitude;\n        amplitude *= persistence;\n        frequency *= lacunarity;\n    }\n    return total / maxValue;\n}\n\n// Lighting\nfloat GetDitheredShadingPalette(float x, vec2 pixel, float edgeSize) {\n    float idx = clamp(x, 0.0, 1.0) * float(SHADING_PALETTE_SIZE - 1);\n\n    float shadowAlpha = 0.5;\n    float lightAlpha = 1.0;\n\n    int checker = (int(pixel.x) + int(pixel.y)) % 2;\n    float checkerValue = float(checker);\n\n    float scaledFract = fract(idx) * edgeSize;\n    float mixAmt = float(scaledFract > checkerValue);\n\n    return mix(shadowAlpha, lightAlpha, mixAmt);\n}\n\nfloat diffuseLighting(vec3 lightDirection, vec3 normal, float power) {\n    float diffuse = dot(lightDirection, normal);\n    diffuse = pow(max(diffuse, 0.0), power);\n    return clamp(diffuse, 0.0, 1.0);\n}\n\n// Util functions\nmat3 rotationMatrix(vec3 axis, float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    float t = 1.0 - c;\n\n    return mat3(\n        t * axis.x * axis.x + c, t * axis.x * axis.y - s * axis.z, t * axis.x * axis.z + s * axis.y,\n        t * axis.x * axis.y + s * axis.z, t * axis.y * axis.y + c, t * axis.y * axis.z - s * axis.x,\n        t * axis.x * axis.z - s * axis.y, t * axis.y * axis.z + s * axis.x, t * axis.z * axis.z + c\n    );\n}\n\n// Background stars\nvec2 rand2(vec2 p, float fSeed) {\n    return vec2(rand1D(p.x,fSeed), rand1D(p.y,fSeed));\n}\n\nfloat stars(vec2 x, float numCells, float size, float br, float fSeed) {\n    vec2 n = x * numCells;\n    vec2 f = floor(n);\n\n    float d = 1.0e10;\n    for (int i = -1; i <= 1; ++i) {\n        for (int j = -1; j <= 1; ++j) {\n            vec2 g = f + vec2(float(i), float(j));\n            g = n - g - rand2(mod(g, numCells), fSeed) + rand(g, fSeed);\n            g *= 1.0 / (numCells * size);\n            d = min(d, dot(g, g));\n        }\n    }\n\n    return br * (smoothstep(.95, 1., (1. - sqrt(d))));\n}\n\n// Geometry functions\n\nfloat getRingTransparency(in vec3 point, in float ringInnerRadius, in float ringOuterRadius, float fSeed) {\n    float distanceToCenter = length(point);\n    float ringDensity = noise1D(length(point)*uRingNoiseScale, fSeed);\n    float ringFadeIn = smoothstep(ringInnerRadius, ringInnerRadius + 0.1, distanceToCenter); // Fade in from inner edge\n    float ringFadeOut = smoothstep(ringOuterRadius, ringOuterRadius - 0.1, distanceToCenter); // Fade out to outer edge\n    return ringFadeIn * ringFadeOut * ringDensity; // Inverted for correct transparency\n}\n\nvec3 rayIntersectSphere(vec3 rayOrigin, vec3 rayDir, vec3 sphereCenter, float radius) {\n    vec3 oc = rayOrigin - sphereCenter;\n    float A = dot(rayDir, rayDir);\n    float B = 2.0 * dot(rayDir, oc);\n    float C = dot(oc, oc) - radius * radius;\n    float discriminant = B * B - 4.0 * A * C;\n\n    if (discriminant < 0.0) return vec3(-100000.0);\n\n    float sqrtDisc = sqrt(discriminant);\n    float t0 = (-B - sqrtDisc) / (2.0 * A);\n    float t1 = (-B + sqrtDisc) / (2.0 * A);\n\n    float t = (t0 > 0.0) ? t0 : t1;\n    if (t > 0.0) return rayOrigin + t * rayDir;\n\n    return vec3(-100000.0);\n}\n\nbool intersectRayWithPlane(vec3 rayOrigin, vec3 rayDir, vec3 planeNormal, vec3 planePoint, out float t) {\n    float denominator = dot(rayDir, planeNormal);\n    if (abs(denominator) > 0.0001) {\n        vec3 p0l0 = planePoint - rayOrigin;\n        t = dot(p0l0, planeNormal) / denominator;\n        return (t >= 0.0);\n    }\n    return false;\n}\n\nbool isPointInsideCircle(vec3 point, vec3 circleCenter, float innerRadius, float outerRadius) {\n    float distance = length(point - circleCenter);\n    return distance >= innerRadius && distance <= outerRadius;\n}\n\nvec3 rayIntersectRing(vec3 rayOrig, vec3 rayDir, vec3 axis, float innerRadius, float outerRadius) {\n    vec3 planeNormal = normalize(axis);\n    vec3 planePoint = vec3(0.0, 0.0, 0.0);\n\n    float t;\n    bool hit = intersectRayWithPlane(rayOrig, rayDir, planeNormal, planePoint, t);\n    if (hit) {\n        vec3 intersectionPoint = rayOrig + t * rayDir;\n        if (isPointInsideCircle(intersectionPoint, planePoint, innerRadius, outerRadius)) return intersectionPoint;\n    }\n    return vec3(-100000.0);\n}\n\nvoid rayIntersectPlanet(in vec2 uv, in vec3 planetAxis, in float planetRadius, in float ringDistance, in float ringSize, out vec3 spherePoint, out vec3 ringPoint, out vec3 combinedPoint) {\n    float halfRingSize = ringSize * 0.5;\n    float ringInnerRadius = planetRadius + ringDistance - halfRingSize;\n    float ringOuterRadius = planetRadius + ringDistance + halfRingSize;\n\n    vec3 center = vec3(0.0, 0.0, 0.0);\n    planetAxis = normalize(planetAxis);\n\n    vec3 rayOrig = vec3(uv, 2.0);\n    vec3 rayDir = vec3(uv, -2.0);\n\n    spherePoint = rayIntersectSphere(rayOrig, rayDir, center, planetRadius);\n    ringPoint = rayIntersectRing(rayOrig, rayDir, planetAxis, ringInnerRadius, ringOuterRadius);\n\n    if (spherePoint.z > ringPoint.z) {\n        combinedPoint = spherePoint;\n    } else if (ringPoint.z > -9999.0) {\n        combinedPoint = ringPoint;\n    } else {\n        combinedPoint = vec3(-100000.0);\n    }\n}\n\nfloat planetIsInShadow(vec3 fragPosition, vec3 lightDirection, vec3 planetAxis, float ringInnerRadius, float ringOuterRadius, float fSeed) {\n    vec3 rayOrigin = fragPosition;\n    vec3 rayDirection = normalize(lightDirection);\n\n    vec3 point = rayIntersectRing(rayOrigin, rayDirection, planetAxis, ringInnerRadius, ringOuterRadius);\n\n    if(point.z > -100000.0) {\n        float ringDensity = getRingTransparency(point, ringInnerRadius, ringOuterRadius, fSeed);\n        return 1.0 - ringDensity;\n    } else {\n        return 1.0;\n    }\n}\n\nfloat ringIsInShadow(vec3 fragPosition, vec3 lightDirection, float planetRadius) {\n    vec3 rayOrigin = fragPosition;\n    vec3 rayDirection = normalize(lightDirection);\n\n    vec3 point = rayIntersectSphere(rayOrigin, rayDirection, vec3(0), planetRadius);\n    if(point.z > -100000.0) {\n        return 0.0;\n    } else {\n        return 1.0;\n    }\n}\n\n// Masking\nvoid getMasks(in vec3 spherePoint, in vec3 ringPoint, out float planetMask, out float ringMask, out float bgMask) {\n    planetMask = 0.0;\n    ringMask = 0.0;\n    bgMask = 0.0;\n\n    if (spherePoint.z > -9999.0 && spherePoint.z >= ringPoint.z) planetMask = 1.0;\n    if (ringPoint.z > -9999.0 && spherePoint.z < ringPoint.z) ringMask = 1.0;\n    if (spherePoint.z < -9999.0 && ringPoint.z < -9999.0) bgMask = 1.0;\n}\n\nvec3 getPlanetColor(float noise, vec3 point, float fSeed)\n{\n    float shadingBias = 0.25;\n    float darkeningSea = 0.4;\n    float darkeningLand = 0.6;\n    float colorTransitionWidth = 0.0;\n\n    uSeaColor = hueShift(uSeaColor, uHueShift);\n    uLandColor = hueShift(uLandColor, uHueShift);\n\n    float darkening;\n    float colorShading;\n\n    if (noise < uSeaLevel) {\n        // Calculate sea shades\n        float scaledNoise = (noise - uSeaLevel) / (0.0 - uSeaLevel);\n        scaledNoise = pow(scaledNoise, shadingBias);\n        float shadeIndex = floor(scaledNoise * float(uSeaShades));\n        darkening = (1.0 - shadeIndex / float(uSeaShades) * darkeningSea);\n\n        // Calculate colorShading for the sea (0.0 to 0.5)\n        colorShading = darkening*0.5;\n    } else {\n        // Calculate land shades\n        float scaledNoise = (noise - uSeaLevel) / (1.0 - uSeaLevel);\n        scaledNoise = pow(scaledNoise, shadingBias);\n        float shadeIndex = floor(scaledNoise * float(uLandShades));\n        darkening = (1.0 - shadeIndex / float(uLandShades) * darkeningLand);\n\n        // Calculate colorShading for the land (0.5 to 1.0)\n        colorShading = 0.5 + abs((-0.5 * (1.0 - (1.0 - shadeIndex / float(uLandShades) * darkeningLand))));\n\n    }\n    \n    // This part isn't working\n    // I want to change this so it the transition from 0.5 to 1.0 is sharper and also in a mirrored fashion the transition from 0.5 to \n    float center = 0.5;\n    float power = 3.0 - (2.0 * colorTransitionWidth); // Adjust this for the strength of the effect (higher = faster transition)\n\n    if (colorShading >= center) {\n      colorShading = 1.0 - pow(1.0 - colorShading, power);\n    } else {\n      colorShading = pow(colorShading, power);\n    }\n\n    // Placeholder for the actual color blending and shading, which you will add later\n    vec3 color = mix(uSeaColor,uLandColor,colorShading);\n    \n    // Remove highlights from coastline\n    darkening = clamp(darkening,0.0,0.8);\n \n    // Apply shading\n    color *= darkening;\n\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    // Quantize fragment coordinates\n    float minScale = min(iResolution.x, iResolution.y);\n    float PIXEL_SIZE = minScale / float(PIXELS);\n    vec2 pixelatedFragCoord = floor(fragCoord / PIXEL_SIZE) * PIXEL_SIZE;\n\n    // Normalize pixel coordinates\n    vec2 uv = (pixelatedFragCoord.xy - 0.5 * iResolution.xy) / minScale;\n\n    vec3 spherePoint = vec3(0.0);\n    vec3 ringPoint = vec3(0.0);\n    vec3 combinedPoint = vec3(0.0);\n\n    vec3 planetAxis = normalize(uPlanetAxis);\n    float planetAngle = iTime * uPlanetRotationSpeed;\n    mat3 planetRotMatrix = rotationMatrix(planetAxis, planetAngle);\n\n    // Calculate ring radii here\n    float halfRingSize = uRingSize * 0.5;\n    float ringInnerRadius = uPlanetSize + uRingDistance - halfRingSize;\n    float ringOuterRadius = uPlanetSize + uRingDistance + halfRingSize;\n\n   // Ray intersection\n    rayIntersectPlanet(uv, planetAxis, uPlanetSize, uRingDistance, uRingSize, spherePoint, ringPoint, combinedPoint);\n\n    // Calculate masks\n    float planetMask, ringMask, bgMask;\n    getMasks(spherePoint, ringPoint, planetMask, ringMask, bgMask);\n\n    // Calculate normal\n    vec3 planetNormal = normalize(spherePoint);\n    vec3 ringNormal = planetAxis;\n    vec3 combinedNormal = mix(planetNormal, ringNormal, ringMask);\n\n    // Light direction\n    vec2 mousePos = iMouse.xy / iResolution.xy - 0.5;\n    vec3 lightDirection = normalize(vec3(0.6, 0.6, 0.4));\n    if (iMouse.z > 0.0) lightDirection = normalize(vec3(mousePos.xy, 0.1));\n    float lightAngle = iTime * uLightRotationSpeed;\n    lightDirection = lightDirection * rotationMatrix(vec3(0, 1, 0), lightAngle);\n\n    // Calculate constrained seed value only once\n    float fSeed = float(int(mod(float(uRandomSeed), float(MAX_SEED_VALUE)))) * 0.001;\n\n    // Check for shadows\n    float castShadowsPlanet = planetIsInShadow(spherePoint, lightDirection, planetAxis, ringInnerRadius, ringOuterRadius, fSeed);\n    float castShadowsRing = ringIsInShadow(ringPoint, lightDirection, uPlanetSize);\n\n    // Calculate diffuse lighting\n    float planetDiffuse = min(diffuseLighting(lightDirection, planetNormal, 1.0), castShadowsPlanet);\n    float ringDiffuse = min(diffuseLighting(lightDirection, ringNormal, 1.0), castShadowsRing);\n\n    // Add noise\n    vec3 rotatedPosition = spherePoint * planetRotMatrix;\n    vec3 normalizedPosition = normalize(rotatedPosition);\n    float noiseDist = abs(rotatedPosition.y) / uPlanetSize; // Normalize to 0-1 range\n    float scaleMix = smoothstep(0.2, 0.8, pow(noiseDist, 2.0)); // Adjust values for desired transition and curve\n    float noiseScale = mix(uEquatorNoiseScale, uPoleNoiseScale, scaleMix);\n\n    // Separate noise layers for land and sea (optional but recommended)\n    float noise = perlinNoise3D(normalizedPosition, noiseScale, uNoiseOctaves, uNoisePersistence, uNoiseLacunarity, fSeed);\n\n    // Atmosphere\n    vec3 viewDir = vec3(0, 0, 1);\n    float fresnel = pow(1.0 - dot(planetNormal, viewDir), 2.0);\n    float atmosphere = fresnel * planetDiffuse * 3.5;\n\n    // Base planet color\n    float baseColor = mix(0.0, 1.0, planetDiffuse) * mix(0.6, 1.0, noise);\n\n    // Dithering\n    float ditheredPlanetDiffuse = GetDitheredShadingPalette(planetDiffuse, pixelatedFragCoord / PIXEL_SIZE, uDitherEdgeSize);\n    float ditheredRingDiffuse = GetDitheredShadingPalette(ringDiffuse, pixelatedFragCoord / PIXEL_SIZE, uDitherEdgeSize);\n\n    // --- Ring Transparency Gradient ---\n    float ringTransparency = getRingTransparency(ringPoint, ringInnerRadius, ringOuterRadius, fSeed);\n\n    // Final color\n    vec3 planetColor = getPlanetColor(noise, normalizedPosition, fSeed) * ditheredPlanetDiffuse + atmosphere * 0.3 * vec3(0, 0.75, 1);\n    vec3 ringColor = hueShift(uRingColor, uHueShift) * ditheredRingDiffuse;\n\n    vec3 starField = vec3(stars(uv, 64., 0.025, 0.5, fSeed));\n    vec3 finalColor = starField;\n\n    if (spherePoint.z > -9999.0) finalColor = mix(finalColor, planetColor, 1.0);\n    if (ringPoint.z > -9999.0 && spherePoint.z < ringPoint.z) finalColor = mix(finalColor, ringColor, ringTransparency);\n    \n    fragColor = vec4(finalColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}