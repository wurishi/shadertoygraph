{"ver":"0.1","info":{"id":"cdcXWH","date":"1679680161","viewed":96,"name":"Fish showcase","username":"ianertson","description":"The fish I made in my previous shader: https://www.shadertoy.com/view/cdcSWr\n\nUse the mouse to look around :)","likes":6,"published":1,"flags":0,"usePreview":1,"tags":["3d","raymarching","raymarch","fish"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// <image>\n\n#define ID_GROUND 1\n#define ID_BOX 2\n#define ID_FISH 3\n#define ID_FISH_EYE 4\n\n#define UID_FISH 0.92783712\n\nvec3 sandTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    float w = wnoise(uv*12., 5, 1.0);\n    vec3 hf1 = snoise(uv, 0.000089123, 0.05, 140.0, 6);\n    vec3 lf1 = snoise(uv + (vec2(cos(w*3.), sin(w*3.))*0.06), 2.29328921, 0.1, 6.0, 6);\n    vec3 grain = abs(normalize(cross(hf1*2.0-1.0, lf1*2.0-1.0)));\n    \n    vec3 c1 = rgb(200, 163, 111);\n    vec3 c2 = rgb(246, 205, 151);\n    vec3 c3 = rgb(225, 206, 191);\n    vec3 c4 = rgb(170, 123, 69);\n    \n    vec3 col1 = mix4(c1, c2*w, c3, c4, hf1);\n    vec3 col2 = mix4Alt(c1, c2, c3, c4, hf1.yxz);\n    vec3 col3 = mix4(c1, c2, c3, c4, grain);\n    \n    col = mix(col1, col2, lf1.y);\n    col = mix(col, col3, w*w*0.7);\n    col = mix(col, clamp((col+(col*w))/1.3, 0.0, 1.0), smoothstep(0.4, 0.7, lf1.z));\n    \n    m.spec = grain.x*grain.y*grain.z;\n    m.z = clamp(lf1.x-(0.5 - (0.5-w)), 0.0, 1.0);\n    \n    return col;\n}\n\nvec3 eyeTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(1.);\n    \n    float pupilR = 0.5;\n    float pupilF = pupilR*0.2;\n    float pupil = 1.0-smoothstep(pupilR-pupilF, pupilR+pupilF, distance(abs(uv*2.0-1.0), vec2(0.5, 0.7)));\n    \n    col = mix(col, vec3(0), pupil);\n    \n    \n        \n    float irisR = 0.7;\n    float irisF = irisR*0.001;\n    float iris = 1.0-smoothstep(irisR-irisF, irisR+irisF, distance(abs(uv*2.0-1.0), vec2(0.5, 0.7)));\n    iris = max(0.0, iris-pupil);\n    \n    col = mix(col, vec3(0, 1, 0), iris);\n    m.lum = 0.3;\n    \n    return col;\n}\n\nfloat scalePattern(in vec2 uv, in float tile, in float thick) {\n    vec2 uvShade = uv;\n    vec2 iidShade = floor(uvShade*tile);\n    vec2 uuvShade = uvShade;\n    uuvShade.x += (iidShade.y)/tile/2.;\n    vec2 lvShade = fract(uuvShade*tile);\n    float xx = smoothstep(0.0, 1.0, lvShade.x/1.5);\n     return max(line2D(lvShade, vec2(xx, 1), vec2(0.5, 0.), thick), \n                    line2D(lvShade, vec2(0.5-xx, 0.0), vec2(1., 1.), thick));\n}\n\nvec3 fishScaleTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    // scale\n    vec3 sc1 = rgb(185, 191, 141);\n    vec3 sc2 = rgb(186, 222, 212);\n    vec3 sc3 = rgb(220, 231, 214);\n    vec3 sc4 = rgb(175, 187, 178);\n    \n    // sep\n    vec3 sep1 = rgb(173, 86, 27);\n    vec3 sep2 = rgb(121, 72, 36);\n    vec3 sep3 = rgb(141, 110, 93);\n    vec3 sep4 = rgb(134, 48, 0);\n\n    // top dark\n    vec3 d1 = rgb(113, 89, 55);\n    vec3 d2 = rgb(161, 185, 121);\n    vec3 d3 = rgb(162, 134, 91);\n    vec3 d4 = rgb(193, 188, 138);\n    \n    vec3 hf1 = snoise(uv, 0.00823215, 0.3, 100.0, 6);\n    vec3 hf2 = snoiseWarp(uv, 3.9828124, 1.5, 64.0, 6, 0.45);\n    vec3 lf1 = snoiseWarp(uv, 6.69488335, 0.5, 8.0, 6, 0.3);\n    vec3 grain1 = abs(normalize(cross(hf1*2.0-1.0, hf2*2.0-1.0)));\n    vec3 grain2 = abs(normalize(reflect(grain1*2.0-1.0, lf1*2.0-1.0)));\n    vec3 lf2 = snoise(uv, 8.89394982, 0.2, 16.0, 6);\n    \n    vec3 scaleCol1 = mix4Alt(sc1, sc2, sc3, sc4, hf1);\n    col += scaleCol1;\n    \n    vec3 sepCol1 = mix4(sep1, sep2, sep3, sep4, smoothstep(0.4, 0.6, hf2));\n    \n    float tile = 12.0;\n    float itile = max(0.0, 0.2-(1.0/tile));\n    vec2 iid = floor(uv*tile);\n    vec2 uuv = uv;\n    uuv.x += (iid.y)/tile/2.;\n    vec2 id = floor(uuv*tile);\n    vec2 lv = fract(uuv*tile);\n    vec2 lv2 = fract((uuv+vec2(0.01, 0.01))*(tile));\n    vec2 alv = abs(lv*2.0-1.0);\n    \n    float sep = smoothstep(0.48-itile, 0.5, alv.x-0.5) +\n                smoothstep(0.48-itile, 0.5, alv.y-0.5);\n                \n\n    float thick = 0.08;\n    \n    thick = mix(thick, thick*0.5, smoothstep(0.4, 0.7, lf1.y));\n\n    vec2 patUv = uv + (lf1.xz*2.0-1.0)*0.05;\n    float scaleSep = scalePattern(patUv, tile, thick);\n    float scaleShade = scalePattern(patUv + vec2(0.007, 0.007), tile, thick);\n    float scaleLight = scalePattern(patUv - vec2(0.006, 0.006), tile, thick);\n\n\n    id = floor((uv)*(tile));\n    vec2 slv = fract(uv*tile);\n    slv = slv*slv*(3.0-2.0*slv);\n    float seed = 5.5982387;\n    vec3 idr = mix(\n        mix(hash23(id, seed), hash23(id+vec2(1., 0), seed), slv.x),\n        mix(hash23(id+vec2(0, 1), seed), hash23(id+vec2(1, 1), seed), slv.x),\n        slv.y\n    );\n    \n    vec3 scaleCol2 = mix4(sc1, sc2, sc3, sc4, idr);\n    col = mix(col, scaleCol2, smoothstep(0.4, 0.5, lf1.x));\n    \n    col = mix(col, idr, smoothstep(0.4, 0.7, lf1.z)*0.3);\n    \n    \n    col = mix(col, sepCol1, scaleSep);\n    col = mix(col, col*0.5, scaleShade);\n    col = mix(col, col+col, scaleLight*0.33);\n    \n    float grain = grain1.x;\n    \n    col += grain1.y*lf1.x*lf1.y*lf1.z;\n    col = mix(col, col*col, grain);\n    \n    vec3 darkCol = mix4(d1, d2, d3, d4, smoothstep(0.4, 0.7, lf2));\n    float darkReg = (idr.x+(grain2.x*0.5))*(0.5+smoothstep(0.4, 0.7, lf1.x)*0.5);\n    col = mix(col, darkCol, darkReg);\n    \n    m.z = clamp((0.5+scaleLight)-(scaleShade+(scaleSep*0.2)),0.0, 1.0);\n    m.spec = clamp(((scaleLight+idr.y)-(scaleShade*2.))+darkReg, 0.1, 1.0);\n\n    return col;\n}\n\n\nfloat groundSDF(in vec3 p) {\n    return p.y;\n}\n\nfloat fishSDF(in vec3 p, inout int skip, inout int id, inout Object o) {\n    if (skip == ID_FISH || skip == ID_FISH_EYE) return FAR;\n    float dist = FAR;\n    id = ID_FISH;\n    float r = 0.1009;\n    float len = 0.3133;\n\n  //  p.z += len/2.;\n \n    vec3 bodyDir = vec3(0, 0, 1);\n    bodyDir = mix(bodyDir, vec3(1.5, 0, 1), sin(T*3.)*smoothstep(0.07, 0.9, -p.z+(len/1.6)));\n    bodyDir = normalize(bodyDir);\n    float base = lineSDF(vec3(p.x*2., p.y, p.z) - vec3(0.0, 0.0, 0.0), bodyDir*(-len/2.), bodyDir*(len/2.), r);\n    base += smoothstep(0.0, 1.9, max(0.0, (len/2.)-p.z));\n    base += smoothstep(0.0, 1.0, max(0.0, p.z))*smoothstep(0.2, 0.7, max(0.0, p.y+0.7));\n    \n    base/= 2.1;\n    \n    dist = base;\n    \n    float backfinR = 0.07;\n    float backfinThick = 0.005;\n    //backfinR += smoothstep(0.0, 1.2, 1.2*clamp(abs(p.y)-0.001, 0.0, 0.1));\n    float k = -smoothstep(0.0, 1.0, abs(p.y)*1.7);\n    vec3 backfinDir = vec3(1, 0, 0);\n    backfinDir = mix(backfinDir, normalize(vec3(1.0, 0.0, 1.5)), sin(T*3.)*smoothstep(0.0, 0.6, max(0.0, -p.z+0.004)));\n    backfinDir = normalize(backfinDir);\n    float backfin = cylSDF(p - vec3(0, 0, (-(len-(backfinR+0.002)))+k), vec3(0, 0, 0), backfinDir*backfinThick, backfinR);\n    backfin -= 0.001;\n    backfin /= 1.7;\n    \n    float topfinR = 0.062;\n    topfinR += smoothstep(0.0, 1.0, clamp(abs(p.z), 0.0, 0.25));\n    topfinR -= smoothstep(0.09, 1.0, dot(p, vec3(0, 1, 1)));\n    topfinR -= smoothstep(0.0, 1.0, max(0.0, p.y-0.1));\n    float topfin = cylSDF(p - vec3(0, backfinR, 0), vec3(0, 0, 0), vec3(0.005, 0.0, 0.0), topfinR);\n    \n    float botfinR = 0.05;\n    botfinR += smoothstep(0.0, 1.0, clamp(abs(p.z), 0.0, 0.19));\n\n    botfinR -= smoothstep(0.0, 1.0, max(0.0, -p.y-0.06));\n    botfinR -= smoothstep(0.0, 1.5, max(0.0, (p.z+0.2)))*smoothstep(0.0, 0.6, max(0.0, -p.z*2.));\n    float botfin = cylSDF(p - vec3(0.0, -(r-0.02),(-len/12.)-0.011), vec3(0, 0, 0), vec3(0.01, 0.0, 0.0), botfinR);\n    \n    float eyeR = 0.012;\n    float eyeHole = sphereSDF(vec3(abs(p.x), p.y, p.z) - vec3(abs(((r/2.)-(eyeR*2.))-0.012), r/9., len/2.), eyeR);\n    dist = smax(dist, -eyeHole, 0.005);\n    float eyeBallR = eyeR*0.4;\n    vec3 eyeBallPos = vec3(abs(((r/2.)-(eyeBallR*2.))-0.024), r/9., len/2.);\n    float eyeBall = sphereSDF(vec3(abs(p.x), p.y, p.z) - eyeBallPos, eyeBallR);\n\n    float mouthHoleR = 0.016;\n    float mouthHole = sphereSDF(p - vec3(0, -len/10., (len/2.)+0.009), mouthHoleR);\n    dist = smax(dist, -mouthHole, 0.005);\n    \n    float lipR1 = 0.009;\n    float lipR2 = 0.0009;\n    vec3 lipP = p - vec3(0, (-len/10.)+0.009, (len/2.)+(mouthHoleR/1.9));\n    float lipTop = length(vec2(length(lipP.xz)-lipR1,lipP.y))-lipR2;\n    \n    \n    float botOpen = 0.5+sin(T*3.)*0.5;\n    \n    vec3 lipBotP = p - vec3(0, (-len/10.)+mix(0.0, -0.015, botOpen), (len/2.)+(mouthHoleR/6.));\n    float lipBot = length(vec2(length(lipBotP.xz)-lipR1,lipBotP.y))-lipR2;\n    \n    dist = smin(dist, lipTop, 0.006);\n    dist = smin(dist, lipBot, 0.006);\n\n    dist = smin(dist, botfin, 0.012);\n    dist = smin(dist, topfin, 0.007);\n    dist = smin(dist, backfin, 0.009);\n    \n    \n    Object oEye = Object(o.p+eyeBallPos, o.q);\n    \n    SAMPLE(eyeBall, oEye, ID_FISH_EYE);\n\n    \n    \n    return dist/1.2;\n}\n\nObject getFish(float uid) {\n    float r = fract(34.423812*cos(6.2839291*fract(uid*10.398281312)));\n    float r2 = fract(77.423812*sin(r+6.2839291*fract(r*10.194221312)));\n    float r3 = fract(84.332779*sin(r2+6.99392935*fract((r+uid)*12.194221312)));\n    float r4 = fract(sin((uid+3.928145)*2.)*dot(vec3(r, r2, r3), vec3(45.9381823, 83.928123, 69.998238)));\n    float r5 = fract(dot(vec3(r2,r3, r4), vec3(44.492391, 22.29391, 77.983233)));\n    \n    float time = T*mix(1.0, 0.5, r*r2);\n    time *= mix(1.0, 1.2, r3);\n    \n    time += (r+r2+r3+r4);\n    \n    vec3 nn = snoise(uid+(vec2(r4, r5)+vec2(cos(time*0.2), sin(time*0.2)))*0.3, 0.032981254+uid, 1., 0.01, 3);\n    \n    vec3 fishDir = vec3(sin(time+uid+r3), 0, cos(time+uid+r3));\n    fishDir = mix(fishDir, vec3(cos((fishDir.x+r4)-0.2*sin(fishDir.z)), 0.0, sin((fishDir.z+r4)-0.2*cos(fishDir.x))), 0.6*((r3+r4)/2.)*(0.5+sin(time+r)*0.5));\n    fishDir = mix(fishDir, vec3(sin(time+r), radians(mix(-(10.+(r3*3.)), (10.+(r3*3.)), 0.5+sin((time+(r*3.+r2)))*0.5)), cos(time+r)), r*r2);\n    fishDir.xz *= rot(r3*6.28*r);\n    fishDir.xz *= rot(atan(nn.x*2.0-1.0, nn.y*2.0-1.0)*TAU*nn.z*(0.5+cos(T*0.2)*0.5));\n    //fishDir.xz *= rot(-time*r5*mix(0.5, 0.0, 0.5+sin((T+r5+r)*0.003)*0.5));\n    fishDir.xz = mix(fishDir.xz, vec2(cos(r4*6.28), sin(r4*6.28)), r4*r4*(0.5+cos(time)*0.5));\n    fishDir.y += 0.03*(0.5+sin(T)*0.5);\n    if (length(fishDir) <= 0.0001) {\n        fishDir = vec3(cos(time), 0., sin(time));\n    }\n    fishDir = normalize(fishDir);\n    vec3 fishPos = vec3(0, 0.5+(r4*r*(0.5+sin(time)*0.5)), 0);\n    fishPos += fishDir*vec3(1, 2, 1)*mix(1.0, 0.5, r3);\n    fishPos.xz += (vec2(r, r2)*2.0-1.0)*mix(1.0, 1.5, r3);\n    fishPos.z += 1.;\n    fishPos *= mix(1.0, mix(r4, r, r2), (0.5+sin(time*0.3)*0.5)*0.43);\n    vec3 fishRot = vec3(-fishDir.y*TAU, atan(fishDir.z, fishDir.x)-radians(180.), 0.0);\n    \n    Object oFish = Object(fishPos, fishRot);\n    return oFish;\n}\n\nvoid insertFish(in vec3 p, in float uid, inout int skip, inout int id, inout float dist, inout Object o) {\n    int fishId = 0;\n    Object oFish = getFish(uid);\n    float fish = fishSDF(pointRot(p - oFish.p, oFish.q), skip, fishId, oFish);\n    \n    SAMPLE(fish, oFish, fishId);\n}\n\nfloat sdf(inout Data data, in vec3 p) {\n    int skip = data.skip;\n    int id = ID_NONE;\n    float dist = FAR;\n    Object o = NEW_OBJECT;\n    \n    float ground = groundSDF(p);\n    SAMPLE(ground, o, ID_GROUND);\n\n    insertFish(p, UID_FISH, skip, id, dist, o);\n    insertFish(p, 2.2233812, skip, id, dist, o);\n\n    \n    data.id = id;\n    data.o = o;\n    return dist;\n}\n\nRay getRay(in vec2 uv, in vec4 m) {\n    vec3 ro = vec3(0, 0, -2.0);\n    vec3 rd = normalize(vec3(uv.xy, 1.0));\n    \n    if (m.z > 0.001 && length(m.xy) > 0.0001 && iFrame > 1 && iTime > 0.0001) {\n        ro.yz *= rot(m.y*TAU);\n        ro.xz *= rot(m.x*TAU);\n        \n        rd.yz *= rot(m.y*TAU);\n        rd.xz *= rot(m.x*TAU);\n    } else {\n        Object fish = getFish(UID_FISH);\n        \n        rd = look(uv, fish.p - vec3(0, 0.5, 0), ro, 1.9);\n    }\n    \n    float y = 0.5;\n    ro.y += y;\n    ro.y = max(y, ro.y);\n    \n    return Ray(ro, rd);\n}\n\nvec3 getAlbedoGround(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = boxUv(p, n);\n    vec3 col = sandTexture(uv, p, data.m);\n    data.n = makeNormal(data.n, data.m.z, 0.6, 0.33);\n    return col;\n}\n\nvec3 getAlbedoBox(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = boxUv(p, n);\n    vec3 col = textureLod(iChannel3, uv, 0.0).rgb;\n    return col;\n}\n\nvec3 getAlbedoFish(inout Data data) {\n    vec3 p = pointRot(data.p - data.o.p, data.o.q);\n    vec3 n = data.n;\n    vec2 uv = boxUv(p, pointRot(n, data.o.q));\n    uv *= 6.;\n    vec3 col = fishScaleTexture(uv, p, data.m);\n    data.n = makeNormal(data.n, data.m.z, 0.39, 0.33);\n    return col;\n}\n\nvec3 getAlbedoFishEye(inout Data data) {\n    vec3 p = pointRot(data.p - data.o.p, data.o.q);\n    vec3 n = data.n;\n    vec2 uv = sphereUv(pointRot(n, data.o.q));\n    vec3 col = eyeTexture(uv, p, data.m);\n    return col;\n}\n\nvec3 getAlbedo(inout Data data) {\n    switch (data.id) {\n        case ID_GROUND: return getAlbedoGround(data); break;\n        case ID_BOX: return getAlbedoBox(data); break;\n        case ID_FISH: return getAlbedoFish(data); break;\n        case ID_FISH_EYE: return getAlbedoFishEye(data); break;\n    }\n    \n    return vec3(0.77);\n}\n\nvec3 getSky(in vec3 rd) {\n    float dotup = cdot(rd, vec3(0, 1, 0));\n    vec3 col = pow(COLOR_SKY, vec3(1.0 + dotup));\n    return col;\n}\n\nvec3 render(inout Data data, in vec3 ro, in vec3 rd, inout float depth) {\n    vec3 col = vec3(0.0);\n    depth = 1.0;\n    \n    Light lights[NUM_LIGHTS];\n    lights[0] = LIGHT_SUN; \n    \n    raycast(data, lights, true, col, ro, rd);\n    \n    depth = data.d / FAR;\n    \n    return col;\n}\n\nvec4 blit(in vec2 fc) {\n    vec3 col = vec3(0.0);\n    vec2 uv = (fc-0.5*R.xy)/R.y;\n    vec4 m = vec4((iMouse.xy-0.5*R.xy)/R.y, iMouse.zw);\n    \n    Ray ray = getRay(uv, m);\n    vec3 ro = ray.ro;\n    vec3 rd = ray.rd;\n    Data data = NEW_DATA;\n    float depth = 1.0;\n    \n    #ifdef DEBUG_TEXTURE\n    Material ma = NEW_MATERIAL;\n    col += DEBUG_TEXTURE(fc.xy/R.xy, ro+rd, ma);\n    #else\n    col += render(data, ro, rd, depth);\n    col = aces(col);\n    col = pow(col, vec3(1.0 / 2.2));\n    #endif\n    \n    return vec4(col, depth);\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    O = blit(fc);\n}\n// </image>\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// <common>\n#define R (iResolution.xy)\n#ifndef HW_PERFORMANCE\n#define iTime (0.0)\n#define iFrame (0)\nuniform sampler2D iChannel3;\n#define iResolution vec2(0.0)\n#define iMouse vec4(0.0)\n#endif\n#define T (iTime)\n#define M_PI (3.14159265359)\n#define TAU (M_PI * 2.0)\n#define ZERO (min(0, int(iTime)))\n#define adot(a,b) (abs(dot(a, b)))\n#define cdot(a,b) (max(0.0, dot(a, b)))\n#define rgb(a,b,c) (vec3(a, b, c) / 255.0)\n#define SAMPLE(var, OBJ, id_) if (id_ != skip && var < dist) { id = id_; dist = var; o = OBJ; }\n// Ray marcher constants\n\n#define NEAR 0.003\n#define FAR 100.0\n#define STEPS 100\n#define SHADOW_STEPS 33\n#define FAR_LOD 1.0\n#define NORMAL_RANGE 0.001\n#define AMBIENT 0.05\n#define NUM_LIGHTS 1\n#define ID_NONE -1\n\n// Colors\n\n#define COLOR_SKY vec3(0.29, 0.61, 0.9)\n#define COLOR_SUN vec3(0.97, 0.81, 0.79)\n\n// Render constants\n\n#define SPECULAR_AMPLITUDE 64.0\n#define SHADOW_NDOTL_EPSILON 0.000003\n\n// Default sun light\n\n#define LIGHT_SUN Light(vec3(1, 2, -3), vec3(0.0), COLOR_SUN, 2.0, LIGHT_AMBIENT)\n\nstruct Object {\n    vec3 p;\n    vec3 q;\n};\n\n#define NEW_OBJECT Object(vec3(0.0), vec3(0.0))\n\nstruct Material { float rough; float spec; float metallic; float lum; float z; float ior; };\n#define NEW_MATERIAL Material(1.0, 1.0, 0.0, 0.0, 0.0, 0.0)\n\nstruct Data {\n    vec3 q;\n    vec3 ro;\n    vec3 rd;\n    vec3 p;\n    vec3 n;\n    float d;\n    int skip;\n    int id;\n    float sig;\n    Material m;\n    Object o;\n};\n#define NEW_DATA Data(vec3(0.0), vec3(0.0),vec3(0.0), vec3(0.0), vec3(0.0), FAR, ID_NONE, ID_NONE, 1., NEW_MATERIAL, NEW_OBJECT)\n\n\nstruct Ray {\n    vec3 ro;\n    vec3 rd;\n};\n\n#ifndef HW_PERFORMANCE\nfloat sdf(inout Data data, in vec3 p) { return FAR; }\nvec3 getAlbedo(inout Data data) { return vec3(0.0); }\nvec3 getSky(in vec3 rd) { return vec3(0.0); }\n#else\nfloat sdf(inout Data data, in vec3 p);\nvec3 getAlbedo(inout Data data);\nvec3 getSky(in vec3 rd);\n#endif\n\n\n// Utilities\n\nmat2 rot(in float a) { float c = cos(a); float s = sin(a); return mat2(c, s, -s, c); }\n\nvec3 look(vec2 uv, vec3 point, vec3 ro, in float zoom) {\n    vec3 camForward = normalize(point - ro);\n    vec3 camRight = -normalize(cross(camForward, vec3(0, 1, 0)));\n    vec3 camUp = -normalize(cross(camRight, camForward));\n    vec3 screenCenter = ro + camForward * zoom;\n    vec3 screenIntersection = screenCenter + uv.x * camRight + uv.y * camUp;\n    return normalize(screenIntersection - ro);\n}\n\nvec3 pointRot(in vec3 p, in vec3 r) {\n    p.yz *= rot(r.x);\n    p.xz *= rot(r.y);\n    return p;\n}\n\nvec3 mix4(vec3 c1, vec3 c2, vec3 c3, vec3 c4, vec3 m) {\n    return mix(mix(mix(c1, c2, m.x), c3, m.y), c4, m.z);\n}\n\nvec3 mix4Alt(vec3 c1, vec3 c2, vec3 c3, vec3 c4, vec3 m) {\n    vec3 m2 = m;\n    m2.xz *= rot(6.28*m.z+m.y);\n    m2 = abs(m2);\n    return clamp(((c1 * m.x) + (c2 * m.y) + (c3 * m.z) + (c4 * m2.x))/4., 0.0, 1.0);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k) {\n    return smin(a, b, -k);\n}\n\nvec3 smin(vec3 a, vec3 b, float k) {\n    vec3 h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nvec3 smax(vec3 a, vec3 b, float k) {\n    return smin(a, b, -k);\n}\n\nfloat sabs(in float v, in float k) {\n    return smax(-v, v, k);\n}\n\nfloat line2D(in vec2 p, in vec2 a, in vec2 b, float t) {\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return clamp(1.0-length(pa - ba * h)/t, 0.0, 1.0);\n}\n\nvec3 makeNormal(in vec3 wn, in float z, in float mx, in float s) {\n    if (abs(z) <= 0.000000001) return wn;\n    vec2 dx = vec2(dFdx(z), 0.0);\n    vec2 dy = vec2(0.0, dFdy(z));\n    float bumpScale = s;\n    vec3 cp = cross(vec3(dx, bumpScale), vec3(dy, bumpScale));\n    if (length(cp) <= 0.0003) return wn;\n    cp = normalize(cp);   \n    vec3 next = normalize(mix(wn, normalize(wn+cp), mx));\n    if (length(next) <= 0.0003) return wn;\n    return next;\n}\n\n// UV functions\n\nvec2 boxUv(in vec3 p, in vec3 n) {\n    return mix(mix(p.xy, p.yz, round(adot(n, vec3(1, 0, 0)))), p.xz, round(adot(n, vec3(0, 1, 0))));\n}\n\nvec2 sphereUv(in vec3 p) {\n    float u = acos(p.y);\n    float v = atan(p.x, p.z);\n    u = 0.5 - u / M_PI;\n    v = 0.5 + v / M_PI;\n    return vec2(u, v);\n}\n\n// Distance functions\n\nfloat sphereSDF(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\nfloat boxSDF(in vec3 p, in vec3 s) {\n    p = abs(p) - s;\n    return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\nfloat lineSDF(in vec3 p, in vec3 a, in vec3 b, in float r) {\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    return length(pa - ba * (clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0))) - r;\n}\n\nfloat cylSDF(in vec3 p, in vec3 a, in vec3 b, in float r) {\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = dot(ab, ap) / dot(ab, ab);\n    vec3 c = a + t * ab;\n    float x = length(p - c) - r;\n    float y = (abs(t - 0.5) - 0.5) * length(ab);\n    float e = length(max(vec2(x, y), 0.0));\n    float i = min(max(x, y), 0.0);\n    return e + i;\n}\n\nfloat torusSDF(in vec3 p, in float r1, float r2) {\n    p = p.yzx;\n    float ll = length(p.yz)-r1;\n    return length(vec2(ll,p.x))-r2;\n}\n\n// Noise functions\n\nfloat wnoise(in vec2 uv, in int iter, float dim) {\n    vec2 k = uv*2.0-1.0;\n    vec2 r = vec2(0.0);\n    float f = 1.0;\n    for (int i = 0; i < iter; i++) {\n        r += sin( k*f +(float(i)/float(iter))*2.5) / f;\n        k = k * mat2(8.0, 6.28, -8.0, 6.28)*.1 + r*.29;     \n        r += sin( k*f +(float(i)/float(iter))*2.5) / f;\n        k = k * mat2(8.0, 6.28, -8.0, 6.28)*.1 + r*.29;\n    }\n    float n = 1.0-dFdx(length(r)*dim);\n    return clamp(exp(n-1.5)*n, 0.0, 1.0);\n}\n\nuint hash21u(in vec2 ip, in float seed) {\n    uvec2 p = uvec2(floatBitsToUint(ip.x), floatBitsToUint(ip.y));\n    uint s = floatBitsToUint(seed);\n    s ^= ~s >> 3U;\n    p ^= (p << 17U);\n    s ^= (~p.x);\n    s ^= (~p.y);\n    p ^= (p >> 11U);\n    p ^= (p << 5U);\n    p ^= (s << 3U);\n    return ((p.x + p.y) ^ (p.x * s + p.y))*293U;\n}\n\nfloat hash21(in vec2 ip, in float seed) { return float(hash21u(ip, seed)) / float(0xFFFFFFFFU); }\n\nvec3 hash23(in vec2 ip, in float seed) {\n    uint n = hash21u(ip, seed);\n    n ^= (n >> 13U);\n    return vec3(float((n >> 16U) & 0xFFU), float((n >> 8U) & 0xFFU), float(n & 0xFFU)) / float(0xFFU);\n}\n\n#define NOISE(p, seed, lod) (textureLod(iChannel3, (p + (seed*1.9287827185))/256.0, lod).rgb)\n\nvec3 snoise(in vec2 p, in float seed, in float lod) {\n    p += 0.99288124;\n    vec2 id = floor(p);\n    vec2 lv = fract(p); lv = lv*lv*(3.0-2.0*lv);\n    return mix(\n        mix(NOISE(id, seed, lod), NOISE(id + vec2(1, 0), seed, lod), lv.x),\n        mix(NOISE(id + vec2(0, 1), seed, lod), NOISE(id + vec2(1, 1), seed, lod), lv.x),\n        lv.y\n    );\n}\n\nvec3 snoise(in vec2 p, in float seed, in float lod, in float freq, const in int octaves) {\n    p += 0.99288124;\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    for (int i = ZERO; i < octaves; i++) {\n        n += amp * snoise(p*freq, seed, lod); div += amp; amp /= 2.0; lod /= 2.0; freq *= 2.0;\n    }\n    return n / div;\n}\n\nvec3 snoiseWarp(in vec2 p, in float seed, in float lod, in float freq, const in int octaves, in float warp) {\n    p += 0.99288124;\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    for (int i = ZERO; i < octaves; i++) {\n        n += amp * snoise(p*freq, seed, lod); div += amp; amp /= 2.0; lod /= 2.0; freq *= 2.0;\n        p += (n.xy*n.z)*warp;\n    }\n    return n / div;\n}\n\nfloat voronoi(in vec2 p, in float seed, out vec2 id){\n    vec2 Pi = floor(p);\n    vec2 Pf = fract(p);\n    \n    float dmin = 1e20;\n    vec2 res = vec2(0.0);\n    float r = 1.0;\n    \n    for(int j=-1; j<=1; j++){\n        for(int i=-1; i<=1; i++){\n            vec2 lattice = vec2(float(i),float(j));\n            vec2 offset = vec2(hash21(Pi+lattice, 0.9231234), hash21(Pi+lattice, 78.38381));\n            vec2 diff = lattice + offset - Pf;\n            \n            float dist = dot(diff,diff);\n            r = min(r, dist/0.56);\n            if(r<dmin){\n                id = offset;\n                dmin = r;\n                res = lattice + offset;\n            }\n        }\n    }\n\n    return clamp(sqrt(dmin), 0.0, 1.0);\n}\n\n// Shading & Colors\n\nfloat luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\n\nvec3 aces(vec3 x) {return x*(2.51*x + .03) / (x*(2.43*x + .59) + .14); }\n\nvec3 fresnelSchlickRoughness(float NdotV, vec3 F0, float rough) {\n  return F0 + (max(vec3(1.0 - rough), F0) - F0) * pow(max(1.0 - NdotV, 0.0), 5.0);\n}\n\n// Marching\n\nbool march(inout Data data, in vec3 ro, in vec3 rd) {\n    float d = 0.0;\n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*d;\n        float next = sdf(data, p);\n        d += next;\n        if (abs(next) <= (NEAR * (1.0 + (d / FAR_LOD)))) break;\n        if (abs(d) >= FAR) return false;\n    }\n    \n    vec3 p = ro+rd*d;\n    vec2 e = vec2(NORMAL_RANGE, 0.0);\n    vec3 n = normalize(sdf(data, p) - vec3(\n        sdf(data, p - e.xyy),\n        sdf(data, p - e.yxy),\n        sdf(data, p - e.yyx)\n    ));\n    \n    data.d = d;\n    data.p = p;\n    data.n = n;\n    \n    return true;\n}\n\nfloat getShadow(in vec3 ro, in vec3 rd, in vec3 n, in float far, in int skip) {\n    float NdotL = cdot(n, rd);\n    if (NdotL <= SHADOW_NDOTL_EPSILON) return 1.0;\n    \n    Data data = NEW_DATA;\n    data.skip = skip;\n    \n    float d = 0.0;\n    float r = 1.0;\n    for (int i = ZERO; i < SHADOW_STEPS; i++) {\n        vec3 p = ro+rd*d;\n        float next = sdf(data, p);\n        r = min(r, next/0.44);\n        d += next*0.13;\n        if (abs(next) <= (NEAR * (1.0 + (d / FAR_LOD)))) break;\n        if (abs(d) >= FAR) break;\n    }\n    \n    return clamp(r + 0.77*(d / (1.0 + d)), AMBIENT, 1.0);\n}\n\n// Lighting\n\nstruct Light { vec3 p; vec3 d; vec3 c; float s; int type; };\n#define LIGHT_AMBIENT 0\n#define LIGHT_POINT 1\n#define LIGHT_DIR 2\n\nvec3 getLightDir(in Light light, in vec3 p) {\n    return light.type == LIGHT_AMBIENT ? normalize(light.p) :\n           light.type == LIGHT_POINT ? normalize(light.p - p) :\n           normalize(light.d);\n}\n\nvec3 getLightAtt(in Light light, in vec3 p, in vec3 n) {\n    vec3 L = getLightDir(light, p);\n    float NdotL = max(AMBIENT, dot(n, L));\n    \n    switch (light.type) {\n        case LIGHT_AMBIENT: return light.c * light.s * NdotL; break;\n        case LIGHT_POINT: return light.c * NdotL * (\n            pow(light.s, 2.0) / max(0.0001, pow(distance(light.p, p), 2.0))\n        ); break;\n        case LIGHT_DIR: return light.c * light.s * NdotL * smoothstep(0.8, 1.0, dot(\n            normalize(light.p - p),\n            L\n        )); break;\n    }\n    \n    return vec3(0.0);\n}\n\nvec3 forEachLight(in Light light, in Data data, in vec3 ro, in vec3 rd, in vec3 diffuse) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec3 L = getLightDir(light, p);\n    vec3 ref = reflect(L, n);\n    float VdotR = cdot(rd, ref);\n    float spec = data.m.spec * pow(VdotR, SPECULAR_AMPLITUDE);\n    vec3 att = getLightAtt(light, p, n);\n    float shadow = getShadow(p + (n*NEAR*2.0), L, n, light.type == LIGHT_AMBIENT ? FAR :\n        distance(light.p, p), data.id);\n        \n    return (diffuse + spec) * att * shadow; \n}\n\nbool raycast(inout Data data, in Light lights[NUM_LIGHTS],\n    in bool with_sky, inout vec3 col, in vec3 ro, in vec3 rd) {\n    if (!march(data, ro, rd)) {\n        if (with_sky) {\n            col += getSky(rd);\n        }\n        return false;\n    }\n    vec3 albedo = getAlbedo(data);\n    vec3 diffuse = albedo / M_PI;\n    for (int i = ZERO; i < NUM_LIGHTS; i++) {\n        Light light = lights[i];\n        col += forEachLight(light, data, ro, rd, diffuse);\n    }\n    return true;\n}\n// </common>\n","name":"Common","description":"","type":"common"}]}