{"ver":"0.1","info":{"id":"fs3yD4","date":"1654184339","viewed":90,"name":"Custom procedural phasor noise","username":"VivienGagliano","description":"Custom implementation of phasor noise (Tricard et al., 2019)\nBased on publicaton in ACM Transactions on Graphics (https://dl.acm.org/doi/abs/10.1145/3306346.3322990)","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Phasor noise constants\nconst float b = 1.75;\nconst float F = 50.0;\nfloat theta = -1.*PI /3.;\nvec2 u = vec2(.5, sqrt(3.0) / 2.0);\nconst vec2 cell_size = vec2(.25, .25);\nconst int n_kernel = 15;\nconst bool rand_freq = false;\nconst bool rand_ori = false;\nconst int n_bilobe = 32;\nconst int n_direction = 15;\nconst float b_f = b / 2.0;\nconst float w_f = 2.4;\n\n\n// Kernels are encoded in vec4 : [x, y, orientation, frequency]\nvec4[n_kernel] kernel_grid(vec2 ij)\n{\n    set_seed(hash(ij));\n    vec4[n_kernel] k;\n    for (int i = 0; i < n_kernel; ++i)\n    {\n        float freq = F,\n              ori = theta;\n\n        if (rand_freq)\n            freq = unif(35.0, 65.0);\n        if (rand_ori)\n            ori = unif(0.0, 2.0*PI);\n\n        \n        k[i] = vec4(ij + vec2(unif01(), unif01()), ori, freq); \n    }\n    \n    \n    return k;\n}\n\n\nvoid display_kernel_location(inout vec4 color, vec2 uv)\n{\n    vec4[n_kernel] kernels = kernel_grid(floor(uv));\n    \n    for (int i = 0; i < n_kernel; ++i)\n        if (length(uv-kernels[i].xy) < 5.0 * eps)\n        {\n            color = vec4(1, 0, 0, 1);\n            break;\n        }\n}\n\n// return a list of impulses present in given cell\nvec2[n_direction] uniform_distribution(vec2 ij)\n{\n    set_seed(hash(ij) + 1u); // adding 1 so that resulting distribution is different than the one used for Gabor kernels\n    \n    vec2[n_direction] impulses;\n    for (int i = 0; i < n_direction; ++i)\n        impulses[i] = ij + vec2(unif01(), unif01());\n        \n    return impulses;\n}\n\nfloat locally_coherent_orientation(vec2 uv)\n{\n    vec2 u_i = vec2(0);\n    for (int x = -1; x <= 1; ++x)\n    for (int y = -1; y <= 1; ++y)\n    {\n        vec2[n_direction] impulses = uniform_distribution(floor(uv) + vec2(x,y));\n        \n        for (int k = 0; k < n_direction; ++k)\n        {\n            float a = gaussian(uv - impulses[k], b_f);\n            vec2 ruv = rotate(vec2(1.0, 0), unif(-w_f, w_f)); // is this a good random sample ? should we set the seed somewhere ?\n            \n            u_i += a*ruv;\n        }\n    }\n    \n    u_i /= length(u_i);    \n    return atan(u_i.y, u_i.x);;    \n}\n\n// return the evaluation of given phasor a(x)exp(phi(x)) in cartesian coordinates (a(x)cos(phi(x)), a(x)sin(phi(x)))\nvec2 phasor(vec2 center, vec2 uv, float bandwidth, float frequency, vec2 orientation)\n{\n     float a = gaussian(uv - center, b);\n     float phi = frequency * dot(uv - center, orientation);\n     \n     return vec2(a*cos(phi), a*sin(phi));\n}\n\n// return phasor noise in cartesian coordinates (/!\\ not normalized)\nvec2 phasor_noise(vec2 uv)\n{\n    vec2 pha = vec2(0);\n    for (int x = -1; x <= 1; ++x)\n    for (int y = -1; y <= 1; ++y)\n    {\n        vec4[n_kernel] kernels = kernel_grid(floor(uv) + vec2(x, y));\n        for (int i = 0; i < n_kernel; ++i)\n            pha += phasor(kernels[i].xy, uv, b, kernels[i].w, rotate(vec2(1, 0), kernels[i].z));\n    }\n    \n    return pha;\n}\n\n// return isotropic phasor noise in cartesian coordinates\nvec2 locally_coherent_isotropic_noise(vec2 uv)\n{\n    vec2 pha = vec2(0);\n    for (int x = -1; x <= 1; ++x)\n    for (int y = -1; y <= 1; ++y)\n    {\n        vec4[n_kernel] kernels = kernel_grid(floor(uv) + vec2(x, y));\n        for (int i = 0; i < n_kernel; ++i)\n        {\n            float orientation = locally_coherent_orientation(kernels[i].xy);\n            pha += phasor(kernels[i].xy, uv, b, kernels[i].w, rotate(vec2(1, 0), orientation));\n        }\n    }\n    \n    return pha;\n}\n\n// return a mix of different phasor noises with given orientations in cartesian coordinates\nvec2 noise_mix(vec2 uv, float[n_bilobe] orientations, int n)\n{\n    vec2 noise = vec2(0);\n    for (int i = 0; i < n; ++i)\n    {\n        theta = orientations[i];\n        \n        noise += phasor_noise(uv);\n    }\n    \n    return noise;\n}\n\nvec4 hash_test(vec2 uv)\n{\n    uint id = hash(floor(uv));\n    \n    set_seed(id);\n    \n    return vec4(unif01());\n}\n\n\nvoid tile( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates\n    vec2 uv = fragCoord/iResolution.y;\n    uv /= cell_size;\n    fragColor = vec4(1);\n    \n\n    /*************** Simple bi-lobe case ***************/\n    vec2 noise = to_polar(phasor_noise(uv));\n    \n    // fragColor *= mod(F * dot(uv / cell_size, u), 2.0 * PI) / (2.0 * PI); // perfectly oscillating wave \n    \n    // fragColor *= mod(noise.y - F * dot(uv / cell_size, u), 2.0 * PI) / (2.0 * PI); // phase shift\n    \n    // fragColor *= abs(sin(noise.y - F * dot(uv / cell_size, u))); // abs of sine phase shift\n    \n    // fragColor *= mod(noise.y, 2.0 * PI) / (2.0 * PI); // phasor noise\n     \n    // fragColor *= noise.x / 2.0; // amplitude\n    \n    fragColor *= sin(noise.y); // (bi-lobe) phasor sine wave\n     \n    // fragColor *= noise.x * sin(noise.y); // Gabor noise\n\n\n    /*************** Two bi-lobes ***************/\n    // set_seed(123u);\n    // theta = unif(0.0, 2.0*PI);\n    // phasor1 = phasor_noise(uv);\n    // \n    // set_seed(456u);\n    // theta = unif(0.0, 2.0*PI);\n    // phasor2 = phasor_noise(uv);\n    // \n    // vec2 noise = to_polar(phasor1 + phasor2);    \n    // fragColor *= sin(noise.y);\n    \n    \n    /*************** More bi-lobes ***************/\n    //float[n_bilobe] orientations;\n    //set_seed(123456u);\n    //for (int i = 0; i < n_bilobe; ++i)\n    //{\n        // theta += unif01() * 2.0 * PI;\n        // orientations[i] = float(i) * PI / float(n_bilobe) - (PI / 2.0);\n        // orientations[i] = unif(-PI/2.0, PI/2.0);\n    //}\n    \n    // float[n_bilobe] orientations = orientation_grid(uv);\n    // \n    // vec2 noise = to_polar(noise_mix(uv, orientations, n_bilobe));\n    // \n    // \n    // fragColor *= sin(noise.y);\n    \n    \n    /*************** Locally coherent isotropic noise ***************/\n    // vec2 noise = to_polar(locally_coherent_isotropic_noise(uv));\n    // \n    // fragColor *= sin(noise.y);\n    \n    // float p = 2.*sawtooth(noise.y)+.5;\n    // \n    // vec4 orange = vec4(250, 130, 3, 255) / 255.;\n    // vec4 brown = vec4(135, 0, 35, 255) / 255.;\n    // vec4 cyan = vec4(52, 229, 235, 255) / 255.;\n    // \n    // fragColor *= (1.-p)*orange + p*cyan; \n\n    \n    \n    \n    /*************** Oscillation's profiles ***************/\n    // vec2 phasor1 = to_polar(phasor_noise(uv));\n    // \n    // vec2 phasor2 = to_polar(phasor_noise(4. * uv));\n    // \n    //  float p = .5*(sin(phasor1.y)+sin(phasor2.y))+.5;\n    // \n    // vec4 orange = vec4(250, 130, 3, 255) / 255.;\n    // vec4 brown = vec4(59, 43, 6, 255) / 255.;\n    // vec4 cyan = vec4(52, 229, 235, 255) / 255.;\n    // vec4 cream = vec4(237, 222, 185, 255) / 255.;\n    // vec4 deep_blue = vec4(18, 47, 196, 255) / 255.;\n    // \n    // fragColor = (1.-p)*cyan + p*deep_blue; \n    // fragColor *= rectangle(phasor1.y, .7*PI);\n    // fragColor *= .5*(sin(phasor1.y) + sin(phasor2.y));\n    // \n    // float p = fragCoord.x / iResolution.x;\n    // float a,b;\n    // \n    // if (p > 0.)\n    // {\n    //     a = rectangle(phasor1.y, PI / 2.);\n    //     b = rectangle(phasor1.y, PI);\n    // }\n    // \n    // if (p > 1./3.)\n    // {\n    //     a = rectangle(phasor1.y, PI);\n    //     b = sawtooth(phasor1.y);\n    // }\n    // \n    // if (p > 2./3.)\n    // {\n    //     a = sawtooth(phasor1.y);\n    //     b = sin(phasor1.y);\n    // }\n    // \n    // p = 3.*p - floor(3.*p);\n    // fragColor *= (1.-p)*a + p*b;\n    \n   \n    /*************** Utilities ***************/\n    // fragColor = hash_test(uv);\n    \n    // display_grid(fragColor, uv);\n    // display_kernel_location(fragColor, uv);\n    // fragColor = vec4(.5)*sawtooth(uv.x *2.0 * PI / cell_size.x) + vec4(.5);\n}\n\n// Tile rendering to spread out rendering over several frames and avoid GPU timeout\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int tiles = 16;\n    ivec2 tile_size = ivec2(iResolution.xy)/tiles;\n    tile_size = ivec2(ceil(vec2(tile_size)/2.))*2;\n    ++tiles;\n    \n    int tile_id = int(fragCoord.x)/tile_size.x+(int(fragCoord.y)/tile_size.y)*tiles;\n    if (tile_id != (iFrame % (tiles*tiles)))\n        discard;\n        \n    tile(fragColor, fragCoord);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// General constants\nconst float PI = 3.141592;\nfloat eps = 0.005;\nconst int ARRAY_SIZE = 256;\n\n// Random generation related stuff\nuint N = 123456u;\nuint x = 1u;\nvoid set_seed(uint s) { x = s; }\nuint next() { x = (x * 456789u) % N; return x;}\nfloat unif01() { return float(next()) / float(N); }\nfloat unif(float min, float max) { return min + (max - min) * unif01(); }\n// Integer Hash - III\n// - Inigo Quilez, Integer Hash - III, 2017\n//   https://www.shadertoy.com/view/4tXyWN\nuint iqint3(uvec2 x)\n{\n    uvec2 q = 1103515245U * ( (x>>1U) ^ (x.yx   ) );\n    uint  n = 1103515245U * ( (q.x  ) ^ (q.y>>3U) );\n\n    return n;\n}\nuint hash(vec2 id) \n{ \n    return iqint3(uvec2(id));\n}\n\n\n\n// Other utility methods\nvec2 rotate(vec2 p, float theta)\n{\n    float c = cos(theta),\n          s = sin(theta);\n    return vec2(c * p.x - s * p.y, s * p.x + c * p.y);\n}\n\nvoid display_grid(inout vec4 color, vec2 uv)\n{\n    if (fract(uv.x) < eps || fract(uv.x) > 1.0 - eps)\n        color = vec4(1, 0, 0, 1);\n    if (fract(uv.y) < eps || fract(uv.y) > 1.0 - eps)\n        color = vec4(1, 0, 0, 1);\n}\n\n// cartesian -> polar coordinates (amp, phi)\nvec2 to_polar(vec2 v)\n{\n    return vec2(length(v), atan(v.y, v.x));\n}\n\n// polar -> cartesian coordinates (x, y)\nvec2 to_cartesian(vec2 v)\n{\n    return vec2(v.x*cos(v.y), v.x*sin(v.y));\n}\n\nfloat gaussian(vec2 p, float bandwidth)\n{\n    float norm = length(p);\n    return exp(-PI * bandwidth*bandwidth * norm*norm);\n}\n\n// Gabor kernel\nfloat kernel(vec4 k, vec2 p, float bandwidth)\n{\n    vec2 xy = p - k.xy;\n\n    return gaussian(xy, bandwidth) * sin(k.w * dot(rotate(vec2(1, 0), k.z), xy));\n}\n\n// 2-pi periodic profile functions\nfloat sawtooth(float x)\n{\n    x = mod(x, 2.0 * PI);\n    \n    return (x < PI) ? 1.0 - 2.0 * x / PI : -3.0 + 2.0 * x / PI;\n}\n\nfloat rectangle(float x, float b)\n{\n    x = mod(x, 2.0 * PI);\n    \n    return (x < b) ? -1. : 1.;\n}","name":"Common","description":"","type":"common"}]}