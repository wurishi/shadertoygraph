{"ver":"0.1","info":{"id":"Mf3fDX","date":"1733550581","viewed":38,"name":"Wave eq","username":"helenamuniz","description":"My first shader :D\n\n[W] enters the wall mode, so you can draw walls (opaque areas that bounce waves) . [D] toggles wall deletion\n","likes":5,"published":1,"flags":48,"usePreview":0,"tags":["simulation","physics","waveequation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define   bluredBuffer iChannel0 // Buffer D\n#define    stateBuffer iChannel1 // Buffer B\n#define     wallBuffer iChannel2 // Buffer C\n#define keyboardBuffer iChannel3 // Keyboard\n\n#define WALL_MODE key_t(23)\n#define DEL_MODE key_t(4)\n\n#define  CYAN vec4(0.0, 1.0, 1.0, 1.0)\n#define   RED vec4(1.0, 0.0, 0.0, 1.0)\nbool key_t (int key) {\n    return texture(iChannel3, vec2((0.5 +float(64 + key))/ 256.0 ,0.75)).x > 0.0;\n} \n\nvec4 wall_mode () {\n    if (WALL_MODE) return vec4(0.,1.,0.,1.);\n    return vec4(100.);\n}\n\nvec4 del_mode () {\n    if (DEL_MODE) return vec4(1.,0.,1.,1.);\n    return vec4(100.);\n}\n\nvec4 status_bar (vec2 uv, vec2 fragCoord, float h) {\n    if (fragCoord.y < h) {\n        if (fragCoord.x < 20.0) return wall_mode();\n        if (fragCoord.x >= 20.0 && fragCoord.x < 40.0) return del_mode();\n    }\n    \n    return vec4(0.0);\n}\n\nvec4 pointer (vec4 s) {\n    vec4 c = (CYAN * s + RED * -s);\n    return c + c * abs(s) * 10.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 wall = texture(wallBuffer, uv);\n    vec4 state = texture(bluredBuffer, uv);\n    // Output to screen\n    //fragColor = 5. * texture(stateBuffer, uv).xxxw * vec4(1.0, -1.0, -1.0, 1.0); //+ wall * vec4(0.3, 0.3, 0.3, 1.0) * 1.1;\n    \n    fragColor = pointer(state.xxxw) * 3.0 + pointer(state.zzzw); //+ wall * vec4(0.3, 0.3, 0.3, 1.0) + wall * vec4(0.3, 0.3, 0.3, 1.0) * 0.1;\n    if (WALL_MODE) fragColor = wall;\n    \n    \n    // fragColor += status_bar(uv, fragCoord, 5.0);\n    \n    // fragColor = texture(stateBuffer, uv);\n    \n    vec2 mousePos = iMouse.xy / iResolution.xy;\n    vec2 a = (iMouse.xy - fragCoord) / iResolution.yy;\n    vec2 a2 = a * a;\n    float d = float(abs(sqrt(a2.x + a2.y) - 0.025) < (1.0 / iResolution.y));\n    fragColor = vec4(d,d,d,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define WALL_MODE key_t(23)\n#define DEL_MODE key_t(4)\n\n\nbool key_t (int key) {\n    return texture(iChannel3, vec2((0.5 +float(64 + key))/ 256.0 ,0.75)).x > 0.0;\n}\n\nfloat sdCircle( vec2 p, float r ) {\n    return length(p) - r;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 mousePos = iMouse.xy / iResolution.xy;\n    bool mousePressed = iMouse.w > .0;\n    float distanceToMouse = length(uv - mousePos);\n    float mouseRadius = 0.05;\n    float sdCircle = distanceToMouse - mouseRadius;\n\n\n    vec2 a = (iMouse.xy - fragCoord) / iResolution.yy;\n    vec2 a2 = a * a;\n    bool disk = abs(sqrt(a2.x + a2.y) - 0.025) < (1.0 / iResolution.y);\n\n    if (WALL_MODE) mouseRadius += 0.5;\n\n    float effect = 0.0;\n    \n    if (mousePressed && disk) effect = 1.0;\n\n    fragColor = vec4(vec3(effect), 1.0);\n    if (iFrame == 1) fragColor = length(uv - vec2(0.5, 0.5)) <= mouseRadius ? vec4(1.0, 0.0, 0.0, 1.0) : vec4(0.0, 0.0, 0.0, 1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define    inputBuffer iChannel0 // Buffer A\n#define    stateBuffer iChannel1 // Buffer B\n#define     wallBuffer iChannel2 // Buffer C\n#define keyboardBuffer iChannel3 // Keyboard\n\nbool key_t (int key) {\n    return texture(keyboardBuffer, vec2((0.5 +float(64 + key))/ 256.0 ,0.75)).x > 0.0;\n}\n\nfloat dt = 0.2; // Time step\nfloat c = 3.0;    // Wave speed\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    float wall_c = c + texture(wallBuffer, uv).r * - (c * 0.5);\n    vec4  currentState = texture(stateBuffer, uv);\n    float   currentPos = currentState.r; // aka displacement\n    float   currentVel = currentState.g;\n\n    float left  = texture(stateBuffer, uv + vec2(-1.0 / iResolution.x, 0.0)).r;\n    float right = texture(stateBuffer, uv + vec2(1.0 / iResolution.x, 0.0)).r;\n    float up    = texture(stateBuffer, uv + vec2(0.0, 1.0 / iResolution.y)).r;\n    float down  = texture(stateBuffer, uv + vec2(0.0, -1.0 / iResolution.y)).r;\n    float laplacian = left + right + up + down - 4.0 * currentPos;\n    \n    // Compute acceleration and update velocity\n    //float acceleration = (2.0 * (wall_c * wall_c * laplacian * 0.9) + avgAcc) / 20.0;\n    float acceleration = wall_c * wall_c * laplacian;\n\n    float nextVel = (currentVel + acceleration * dt);\n\n    // Update position\n    float nextPos = (currentPos + nextVel * dt);\n\n    // Fetch input from input buffer (Buffer A)\n    float inputEffect = texture(inputBuffer, uv).r;\n    if (!key_t(23)) nextPos += inputEffect; // Add mouse input as displacement\n    \n    // Store updated state\n    fragColor = vec4(nextPos, nextVel, acceleration, 1.0);\n    \n    if (key_t(24)) fragColor = vec4(0.0);\n    fragColor.x -= fragColor.x * 0.002;\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"#define inputBuffer iChannel0\n#define cBuffer iChannel1\n#define texBuffer iChannel2\n\n\n#define WALL_MODE key_t(23)\n#define DEL_MODE key_t(4)\n#define IMPORT_MODE key_t(9)\n\nbool key_t (int key) {\n    return texture(iChannel3, vec2((0.5 +float(64 + key))/ 256.0 ,0.75)).x > 0.0;\n}\n\n// Wave equation parameters\nfloat dt = 0.196; // Time step\nfloat c = 3.0;    // Wave speed\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    bool mousePressed = iMouse.z > .0;\n    vec2 uv = fragCoord / iResolution.xy;\n    float currentState = texture(cBuffer, uv).r;\n    \n    float inputEffect = 0.0;\n    if (mousePressed) inputEffect = texture(inputBuffer, uv).r;\n    \n    fragColor = vec4(currentState);\n    \n    bool firstFrame = iFrame == 1;\n    if (WALL_MODE || firstFrame) {\n        if (IMPORT_MODE || firstFrame) fragColor = 1.8 - texture(texBuffer, uv) * 4.0;\n        else if (DEL_MODE) fragColor -= inputEffect * 10.0;\n        else fragColor += inputEffect;\n    }\n    fragColor = clamp(fragColor, 0.0, 1.0);\n    //if (WALL_MODE && IMPORT_MODE) fragColor = vec4(0.0, vec3(1.0));\n    \n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Gaussian weights\n    float w0 = 0.227027; // center weight\n    float w1 = 0.316216; // first neighbors\n    float w2 = 0.070270; // second neighbors\n\n    // Offsets\n    vec2 offsetX = vec2(1.0 / iResolution.x, 0.0);\n    vec2 offsetY = vec2(0.0, 1.0 / iResolution.y);\n\n    // Sample texels\n    vec4 center = texture(iChannel1, uv);                          // center\n    vec4 left   = texture(iChannel1, uv - offsetX);                // left\n    vec4 right  = texture(iChannel1, uv + offsetX);                // right\n    vec4 up     = texture(iChannel1, uv + offsetY);                // up\n    vec4 down   = texture(iChannel1, uv - offsetY);                // down\n    vec4 left2  = texture(iChannel1, uv - 2.0 * offsetX);          // second left\n    vec4 right2 = texture(iChannel1, uv + 2.0 * offsetX);          // second right\n    vec4 up2    = texture(iChannel1, uv + 2.0 * offsetY);          // second up\n    vec4 down2  = texture(iChannel1, uv - 2.0 * offsetY);          // second down\n\n    // Compute weighted sum for Gaussian blur\n    vec4 gaussianBlur = w0 * center +\n                        w1 * (left + right + up + down) +\n                        w2 * (left2 + right2 + up2 + down2);\n\n    // Incorporate input from the previous state (feedback loop)\n    vec4 prev = texture(iChannel0, uv);\n    float feedbackWeight = 0.9; // Adjust feedback influence\n    fragColor = mix(gaussianBlur, prev, feedbackWeight);\n}\n","name":"Buffer D","description":"","type":"buffer"}]}