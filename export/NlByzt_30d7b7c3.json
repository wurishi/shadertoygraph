{"ver":"0.1","info":{"id":"NlByzt","date":"1650059057","viewed":177,"name":"Revision 2022 Showdown quarter","username":"Exca","description":"Shader made for the quarterfinals of shader showdown on revision 2022. Not matching exactly to one on Bonzomatic as fftIntegrated & smoothed is missing and textures used differ a bit.","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","revision"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = texture(iChannel3, uv).rgb;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dfGzn","filepath":"/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3","previewfilepath":"/media/ap/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n float fft = 0.0;\n float ffts = 0.0;\n float ffti = 0.0;\n float beat = 0.0;\n float beatstep = 0.0;\n float bar = 0.0;\n\n\nvec3 texmap( vec3 p, vec3 n)\n{\n  return mat3( texture(iChannel2, p.yz).rgb, texture(iChannel2, p.xz).rgb, texture(iChannel2, p.xy).rgb) * n;\n}\n\nvec3 getcam(vec3 cam, vec3 target, vec2 uv, float fov)\n{\n  vec3 forward = normalize( target - cam);\n  vec3 right = normalize(cross(vec3(0,1,0), forward));\n  vec3 up = normalize( cross(forward, right));\n  return normalize( forward*fov + right * uv.x + up*uv.y);\n}\n\nfloat sphere( vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nvec3 repeat( vec3 p, vec3 c)\n{\n  return mod(p+0.5*c,c) - c*0.5;\n}\n\nvec3 map( vec3 p )\n{\n  if( mod(bar, 8.0) < 4.5)\n    p = repeat(p, vec3( 2.0, 0.0, 3.0));\n  \n  float h = texmap( p, p).r * (\n    0.1 +\n    smoothstep( 0.0, 0.1, ffts)*0.75+\n    smoothstep( 0.1, 0.3, ffts)*1.5\n  );\n  float s = sphere(p, 0.25 + h);\n  return vec3(s, 1.0, 1.0);\n}\n\n\n\nvec3 march( vec3 cam, vec3 rd, out vec3 p, out float t)\n{\n  for(int i =0 ;i < 100; i++)\n  {\n    p = cam + rd*t;\n    vec3 r = map(p);\n    t+=r.x*0.5;\n    if(r.x < 0.001)\n    {\n      return r;\n    }\n    if(t > 50.0)\n    {\n     t= 50.0;\n       return vec3(-1);\n    }\n  }\n  return vec3(-1.0);\n}\nfloat marchV( vec3 cam, vec3 rd)\n{\n  float t = 0.0;\n  float v = 0.0;\n  for(int i =0 ;i < 100; i++)\n  {\n    vec3 p = cam + rd*t;\n    vec3 r = map(p);\n    t+=r.x*0.5;\n    if(r.x < 10.001)\n    {\n      v +=1.0/50.0;\n    }\n    if(t > 50.0)\n    {\n       return v;\n    }\n  }\n  return 0.0;\n}\n\n\nvec3 normal( vec3 p )\n{\n  vec3 c = map(p);\n  vec2 e = vec2( 0.001, 0.0);\n  return normalize( vec3(\n    map(p+e.xyy).x,\n    map(p+e.yxy).x,\n    map(p+e.yyx).x\n  )-c.x );\n}\n\nfloat light( vec3 p, vec3 l, vec3 n)\n{\n  return max( 0.0, dot( n, normalize(l-p) ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n  vec2 vuv = uv;\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n\n  \n  float time = iTime;\n  \n  \n  beat = floor( time * 127.0/60.0);\n  beatstep = fract( time * 127.0/60.0);\n  bar = floor( beat / 4.0 );\n  vec3 col1 = vec3(1.0, 0.5, 0.0);\n  vec3 col2 = vec3(0.0, 0.5, 1.0);\n  \n  \n  fft = texture( iChannel0, vec2(0.1,0.5)).r*0.1;\n  ffts = texture( iChannel0, vec2(0.1, 0.5)).r*0.175;\n  \n  vec3 col = vec3(0.0);\n  vec3 cam = vec3( \n    sin(time*0.7+ffti)*2.0, \n    cos(time*0.5+ffti*0.1)*2.0, \n    sin(time*0.25)*2.0\n  );\n  vec3 target = vec3(0,0,0);\n  vec3 light1 = vec3(\n    sin(time)*10.0,\n    sin(time*0.5)*10.0,\n    sin(time*0.25)*10.0\n  );\n  vec3 light2 = vec3(\n    sin(time*0.5)*10.0,\n    sin(time*0.25)*10.0,\n    sin(time*0.55)*10.0\n  );\n  float fov = 3.2 + 1.5*sin(bar*4.2);\n  vec3 rd = getcam( cam, target, uv, fov);\n  \n  float travel = 0.0;\n  vec3 p = cam;\n  vec3 res = march(cam, rd, p, travel);\n  if(res.y > -0.5)\n  {\n    vec3 n = normal(p);\n    col = col1*light(p, light1, n) + \n          col2*light(p, light2, n);\n  }\n  \n  float v = marchV( cam, rd);\n  col += mix( col1, col2, uv.x+uv.y)*v*0.15 * (0.25 + smoothstep( 0.0, 0.05, ffts) +0.5* smoothstep( 0.5,  1.0, beatstep));\n  \n  vuv -= 0.5;\n  vuv*=0.98;\n  vuv+=0.5;\n  \n  vec3 previous = texture( iChannel1, vuv).rgb;\n  \n  if(mod(bar, 4.0) < 0.5) col = col.gbr;\n  else if(mod(bar, 4.0) < 1.5) col = col.bgr;\n  else if(mod(bar, 4.0) < 2.5) col = col.rbg;\n  \n\tfragColor = vec4( col + 0.85*previous*(0.15+0.85*smoothstep(0.0, 0.1, ffts)) , 1.0);\n}\n\n\n\n\n\n\n\n/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n*/","name":"Buffer A","description":"","type":"buffer"}]}