{"ver":"0.1","info":{"id":"NlKfzt","date":"1732277913","viewed":247,"name":"Apollonian Refraction [018]","username":"byt3_m3chanic","description":"Apollonian fractal formula with a sliced SDF\nMouse X turns object / Mouse Y changes thickness of surface in formula","likes":36,"published":3,"flags":0,"usePreview":0,"tags":["raymarching","fractal","refraction","glass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n    Apollonian Refraction [018]\n    11/22/2024  @byt3_m3chanic\n    \n    I've been slacking on my shader coding - but its holiday PTO season now!\n    \n    Just messing with my go to refraction loop and an Apollonian fractal formula\n    with a sliced SDF.\n    \n*/\n\n#define R \t\tiResolution\n#define T \t\tiTime\n#define M \t\tiMouse\n\n#define PI          \t3.14159265358\n#define PI2         \t6.28318530718\n\n#define MAX_DIST    100.\n\n\nfloat hash21(vec2 a) { return fract(sin(dot(a,vec2(21.23,41.232)))*4123.2323); }\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat rx,ry;\n\nfloat vmax(vec3 p) { return max(max(p.x,p.y),p.z); }\nfloat box(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d,vec3(0))) + vmax(min(d,vec3(0)));\n}\n\nvec3 hit=vec3(0);vec3 hitpt=vec3(0);\nmat2 spin;\n \nvec2 dom (vec2 p, float size) {\n    float hlf = size/2.;\n \treturn mod(p+hlf,size)-hlf;\n}\nvec3 dom (vec3 p, float size) {\n    float hlf = size/2.;\n \treturn mod(p+hlf,size)-hlf;\n}\n\nvec2 map (in vec3 p) {\n\tfloat scale = 1.5;\n\n    p.xy*=spin;\n    \n    vec3 q = p; \n    vec2 bx = vec2(.4,.5);\n\tfloat orb =1e5;\n    \n    float cut = box(q,bx.yyx);\n\n    for( int i=0; i<2;i++ ) {\n        p=dom(p,19.);\n       \n        float r2 = dot(p,p);  \n        float k = 4.75/dot(p,p);\n \n        p *= k;\n        scale *= k;\n\n        orb = max(length(p.xz),r2)/12.;\n    }\n\n\n    float d = .075, mf = 1e5;\n    float mm = .25+.25*sin(T*.75);\n    \n    for(float j=-1.;j<1.;j++){\n        vec3 nf =p;\n        nf.z=round(nf.z/d+j)*d;\n        float ids = mod(nf.z,2.);\n        \n        float tubes = length(dom(p.xy,1.))-rx;\n\n        float oube = abs(tubes)-.005;\n        tubes = max(oube,-tubes);\n\n        float fd = max(cut, (tubes));\n        \n        nf.z=clamp(p.z,nf.z-d/2.5,nf.z+d/2.5);\n        fd=length(vec2(max(.0,fd), nf.z-p.z));\n\n        float idx = mod(nf.z,5.);\n        \n \n        mf=min(mf,fd/scale);\n    }\n\n    \n\treturn vec2(mf,orb);\n}\n\n//Tetrahedron technique\n//https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t, float mindist)\n{\n    float e = mindist*t;\n    vec2 h = vec2(1.,-1.)*.5773;\n    return normalize( h.xyy*map( p + h.xyy*e ).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e ).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e ).x + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e ).x );\n}\n\nvec3 shade(vec3 p, vec3 rd, float d, float m, inout vec3 n)\n{\n    n = normal(p,d,1.);\n    vec3 lpos = vec3(4,-3,7);\n    vec3 l = normalize(lpos-p);\n    float diff = clamp(dot(n,l),0.,1.);\n    vec3 clr = .35 + .35 *sin((m*.35)+ vec3(.5,1.5,2.75));\n    return mix(vec3(0),clr,diff)*diff;\n}\n\nvec3 render(in vec2 uv, in vec2 F )\n{    \n    vec3 C=vec3(.0);\n    vec3 ro = vec3(0,0,.95),\n         rd = normalize(vec3(uv,-1));\n\n    rx = M.xy == vec2(0) || M.z<0. ? .33+.15*cos(T*.1) : (M.y/R.y * .25 - .15) * PI;\n    ry = M.xy == vec2(0) || M.z<0. ? 0. : (M.x/R.x * 2. - 1.) * PI;\n    rx = clamp(abs(rx),.1,.5);\n    \n    mat2 fx = rot(-.78),fy = rot(ry+.4*sin(T*.1));\n\n    ro.yz*=fx, ro.xz*=fy;\n    rd.yz*=fx, rd.xz*=fy;\n    \n    vec3  p = ro + rd * .1;\n    float atten = 1.;\n    float k = 1.,b = 4.,iv = 1.;\n    \n    // loop inspired/adapted from @blackle's \n    // marcher https://www.shadertoy.com/view/flsGDH\n    for(int i=0;i<132;i++)\n    {\n        vec2 ray = map(p);\n        vec3 n=vec3(0);\n\n        float d = i<32?ray.x*.4:ray.x*.8;\n        float m = ray.y;\n\n        p += rd * d *k;\n        \n        if (d*d < 1e-8) {\n\n            C+=shade(p,rd,d,ray.y,n)*atten;\n            if(b<1.)break;\n            \n            b-=1.;\n            atten *=.2;\n            p += rd*.05;\n            k = sign(map(p).x);\n        \n            vec3 rf=refract(rd,n,iv > 0. ? .925 : 1.1);\n            iv *= -1.;\n            if(length(rf) == 0.) rf = reflect(rd,n);\n            rd=rf;\n            p+=-n*.005;\n        }  \n        if(distance(p,rd)>20.) { break; }\n    }\n    // Output to screen\n    return C;\n}\n\n// AA = 1 = OFF else 2 > depending on GPU\n#define ZERO (min(iFrame,0))\n#define AA 2\n\n// AA from @iq https://www.shadertoy.com/view/3lsSzf\nvoid mainImage( out vec4 O, in vec2 F )\n{\n\n    spin=rot(-T*8.*PI/180.);\n    \n    vec3 C = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 uv = (-R.xy + 2.0*(F+o))/max(R.x,R.y);\n#else    \n        vec2 uv = (-R.xy + 2.0*F)/max(R.x,R.y);\n#endif\n        vec3 color = render(uv,F);\n        // compress        \n        color = 1.35*color/(1.0+color);\n        // gamma\n        C += color;\n#if AA>1\n    }\n    C /= float(AA*AA);\n#endif\n    \n    C = pow(C, vec3(0.4545) );\n    C = clamp(C,vec3(0),C);\n    // Output to screen\n    O = vec4(C,1.);\n}\n//end","name":"Image","description":"","type":"image"}]}