{"ver":"0.1","info":{"id":"lsKGzG","date":"1455187044","viewed":421,"name":"snowy sky","username":"thu_yumeng","description":"TEST learn from snowy and mouton valley shader \nThanks a lot!!\nhttps://www.shadertoy.com/view/4dl3R4\nhttps://www.shadertoy.com/view/XsfXWH\n","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["flareskytest"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//function to generate noise seed\nfloat hash(vec2 uv) {\n    float f = fract(cos(sin(dot(uv, vec2(.009123898, .00231233))) * 48.512353) * 11111.5452313);\n    return f;\n}\n//interpolate\nfloat noise(vec2 uv)\n{\n    vec2 fuv = floor(uv);\n    vec4 cell = vec4(\n        \thash(fuv + vec2(0,0)),\n            hash(fuv + vec2(0,1)),\n            hash(fuv + vec2(1,0)),\n            hash(fuv + vec2(1,1))\n        );\n    vec2 axis = mix(cell.xz, cell.yw, fract(uv.y));\n    return mix(axis.x, axis.y, fract(uv.x));\n}\n\nfloat fbm(vec2 uv){\n\tfloat f = 0.;\n    float r = 1.;\n    for (int i = 0; i < 8; ++i){\n    \tf += noise(uv*r)/(r *= 2.);\n    }\n    return f/(1.-1./r);\n}\n\nvec3 BlueSky(vec2 uv)\n{\n    vec3 skyColor = vec3(0.4,0.7,.9);\n    vec3 skyColorb = vec3(0.9,0.9,0.9);\n    //cosine interpolation\n    float ft = uv.y * 3.1415927;\n    //cosine interpolation changing to quick use exp to slow it down\n   \tft = (1.- cos(ft))*.5*exp(2.4*(1.-uv.y));\n    \n    return skyColorb*(1.-ft)+skyColor*ft;\n}\n\nvec3 GlowSky(vec2 uv)\n{\n    //normalize\n    uv.x = uv.x/iResolution.y*iResolution.x;\n    vec3 glowColor = vec3(1.0,1.0,1.0);\n   \t//sun point\n    vec2 sunPoint = vec2(0.15,0.85);\n    //use exponential to model sun light\n    vec2 vecDis = uv - sunPoint;\n    float ft = length(vecDis);\n    ft = exp(-1.6*ft);\n    //limit the parameter avoid the light too intense\n\n    \n    //calculate the lensflare\n    float ang = atan(vecDis.y, vecDis.x);\n    float alterScale = exp(-2.9)*0.8;\n    float flareColor = ft*sin(fbm(vec2(ang,0.0)+iTime*0./8.)*16.0+iTime)*alterScale;\n    //smooth the flareColor\n    flareColor = smoothstep(0.0,0.12,flareColor)*ft*0.1;\n  \n    ft = ft+flareColor;   \n    ft = min(0.95,ft);\n    return glowColor*ft;\n}\n\n//eda model from gltracy\n\n// ray marching\nconst int max_iterations = 128;\nconst float stop_threshold = 0.01;\nconst float grad_step = 0.05;\nconst float clip_far = 1000.0;\n\n// math\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\nmat3 roty( float angle ) {\n\tfloat c = cos( angle );\n\tfloat s = sin( angle );\n\t\n\treturn mat3(\n\t\tc  , 0.0, -s  ,\n\t\t0.0, 1.0, 0.0,\n\t\ts  , 0.0, c  \n\t);\n}\n\nmat3 rotzx( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn\n\tmat3(\n\t\tc.y, s.y, 0.0,\n\t\t-s.y, c.y, 0.0,\n\t\t0.0, 0.0, 1.0\n\t) *\n\tmat3(\n\t\t1.0, 0.0, 0.0,\n\t\t0.0, c.x, s.x ,\n\t\t0.0, -s.x, c.x\n\t);\n}\n\n// distance function\nfloat dist_sphere( vec3 pos, float r ) {\n\treturn length( pos ) - r;\n}\n\nfloat dist_box( vec3 pos, vec3 size ) {\n\treturn length( max( abs( pos ) - size, 0.0 ) );\n}\n\nfloat dist_cone( vec3 p, float r, float h )\n{\n\tvec2 c = normalize( vec2( h, r ) );\n    float q = length(p.xy);\n    return max( dot(c,vec2(q,p.z)), -(p.z + h) );\n}\n\nfloat dist_capsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nvec2 princess( vec3 p ) {\n\tp = vec3( p.x,abs(p.y),p.z );\n\t\n\t// hat\n\tfloat d0 = dist_cone( roty( radians( 70.0  ) ) * ( p - vec3( -3.4, 0.0, 2.04 ) ), 0.97, 3.3 );\n\t// skirt\n\tfloat d1 = dist_cone( roty( radians( -10.0 ) ) * ( p - vec3( 0.03, 0.0, -0.1 ) ), 1.6, 2.6 );\n\t// head\n\tfloat d2 = dist_sphere( p + vec3( 0.0, 0.0, -0.8 ), 1.0 );\n\t// neck\n\tfloat d3 = dist_capsule( p, vec3( 0.0, 0.0, -0.5 ), vec3( 0.0, 0.0, 1.0 ), 0.18 );\n\t// legs\n\tfloat d4 = dist_capsule( p + vec3( 0.0, -0.4, 0.0 ), vec3( 0.0, 0.0, -4.6 ), vec3( 0.0, 0.0, -2.0 ), 0.15 );\n\t// feet\n\tfloat d5 = dist_cone( roty( -90.0 * DEG_TO_RAD ) * ( p + vec3( -0.53, -0.4, 4.58 ) ), 0.16, 0.5 );\n\n\tfloat g0 = min( min( d0, d1 ), min( d4, d5 ) );\n\n\tfloat d = g0;\n\tfloat id = 1.0;\n\t\n\tif ( d > d3 ) { d = d3; id = 0.0; }\n\tif ( d > d2 ) { d = d2; id = step( 0.2, p.x ); }\n\t\n\treturn vec2( d, id );\n}\n\n// distance\nvec2 dist_field( vec3 p ) {\n\treturn princess( p + vec3( 0.0, 0.0, -0.85 ) );\n}\n\n// gradient\nvec3 gradient( vec3 pos ) {\n\tconst vec3 dx = vec3( grad_step, 0.0, 0.0 );\n\tconst vec3 dy = vec3( 0.0, grad_step, 0.0 );\n\tconst vec3 dz = vec3( 0.0, 0.0, grad_step );\n\treturn normalize (\n\t\tvec3(\n\t\t\tdist_field( pos + dx ).x - dist_field( pos - dx ).x,\n\t\t\tdist_field( pos + dy ).x - dist_field( pos - dy ).x,\n\t\t\tdist_field( pos + dz ).x - dist_field( pos - dz ).x\t\t\t\n\t\t)\n\t);\n}\n\n// ray marching\nvec2 ray_marching( vec3 origin, vec3 dir, float start, float end ) {\n\tfloat depth = start;\n\tfor ( int i = 0; i < max_iterations; i++ ) {\n\t\tvec2 hit = dist_field( origin + dir * depth );\n\t\tif ( hit.x < stop_threshold ) {\n\t\t\treturn hit;\n\t\t}\n\t\tdepth += hit.x;\n\t\tif ( depth >= end) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn vec2( end, -1.0 );\n}\n\n// othogonal ray direction\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\nvec3 EvalPixel( vec2 pix ) {\n\t// default ray dir\n\tvec3 dir = ray_dir( 45.0, iResolution.xy, pix );\n\t\n\t// default ray origin\n\tvec3 eye = vec3( 0.0, 0.0, 13.0 );\n\n\t// rotate camera\n\tmat3 rot = rotzx( vec2( 70.0 * DEG_TO_RAD, 3.5 ) );\n\tdir = rot * dir;\n\teye = rot * eye;\n\t\n\t// ray marching\n\tvec2 hit = ray_marching( eye, dir, 0.0, clip_far );\n\tif ( hit.x >= clip_far ) {\n\t\treturn vec3(0.0);\n        //return mix( vec3( 0.0, 0.3, 0.4 ), vec3( 0.17, 0.7, 0.7 ), pix.y / iResolution.y );\n\t}\n\t\n\t// shading\n\treturn vec3( hit.y );\n}\n\n//add some snow\n\t\tvec2 mod289(vec2 x) {\n\t\t  return x - floor(x * (1.0 / 289.0)) * 289.0;\n\t\t}\n\n\t\tvec3 mod289(vec3 x) {\n\t\t  \treturn x - floor(x * (1.0 / 289.0)) * 289.0;\n\t\t}\n\t\t\n\t\tvec4 mod289(vec4 x) {\n\t\t  \treturn x - floor(x * (1.0 / 289.0)) * 289.0;\n\t\t}\n\t\tvec3 permute(vec3 x) {\n\t\t  return mod289(((x*34.0)+1.0)*x);\n\t\t}\n\n\t\tvec4 permute(vec4 x) {\n\t\t  return mod((34.0 * x + 1.0) * x, 289.0);\n\t\t}\n\n\nfloat worleyNoise(vec2 P){\n\t\t#define K 0.142857142857 // 1/7\n\t\t#define K2 0.0714285714285 // K/2\n\t\t#define jitter 0.8 // jitter 1.0 makes F1 wrong more often\n\t\t\t\t\n\t\tvec2 Pi = mod(floor(P), 289.0);\n\t\tvec2 Pf = fract(P);\n\t\tvec4 Pfx = Pf.x + vec4(-0.5, -1.5, -0.5, -1.5);\n\t\tvec4 Pfy = Pf.y + vec4(-0.5, -0.5, -1.5, -1.5);\n\t\tvec4 p = permute(Pi.x + vec4(0.0, 1.0, 0.0, 1.0));\n\t\tp = permute(p + Pi.y + vec4(0.0, 0.0, 1.0, 1.0));\n\t\tvec4 ox = mod(p, 7.0)*K+K2;\n\t\tvec4 oy = mod(floor(p*K),7.0)*K+K2;\n\t\tvec4 dx = Pfx + jitter*ox;\n\t\tvec4 dy = Pfy + jitter*oy;\n\t\tvec4 d = dx * dx + dy * dy; // d11, d12, d21 and d22, squared\n\t\t// Sort out the two smallest distances\n\t\t\t\t\n\t\t// Cheat and pick only F1\n\t\td.xy = min(d.xy, d.zw);\n\t\td.x = min(d.x, d.y);\n\t\treturn d.x; // F1 duplicated, F2 not computed\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 gColor = GlowSky(uv);\n    vec3 bColor = BlueSky(uv);\n    \n    gColor = gColor.x*gColor.x+bColor*(1.-gColor.x);\n\t\n    vec3 color = vec3( 0.0 );\n\tcolor += EvalPixel( fragCoord.xy                    );\n\tcolor += EvalPixel( fragCoord.xy + vec2( 0.5, 0.0 ) );\n\tcolor += EvalPixel( fragCoord.xy + vec2( 0.0, 0.5 ) );\n\tcolor += EvalPixel( fragCoord.xy + vec2( 0.5, 0.5 ) );\n\t\n\tcolor *= 0.25;\n    \n    gColor = gColor + color;\n    \n    //add some snow\n    vec2 GA;\n    float speed = .2;\n    GA.x -= iTime*1.8;\n    GA.y += iTime*0.9;\n    GA *= speed;\n    float F1;\n    uv.x = uv.x*iResolution.x/iResolution.y;\n    F1 = 1. - worleyNoise((uv+GA*0.8+fbm(uv)*0.3)*8.1);\n    F1 = smoothstep(0.995,1.0,F1);\n    \n   \tfloat F2 = 1. - worleyNoise((uv+GA*0.4+fbm(uv)*0.2)*7.1);\n    F2 = smoothstep(0.99,1.0,F2);\n    \n    float A = uv.x - (1.-uv.y)*.8;\n    A = clamp(A,.0,1.);\n    A = 1.-A;\n    \n    F1 = F1*A+F2*A*1.8;\n    //F1 = F1*A;\n    gColor = gColor*(1.-F1) + vec3(0.9,0.8,0.95)*F1;\n    \n\tfragColor = vec4(gColor,1.0);\n    //fragColor = vec4(F1);\n    //fragColor = vec4(vec3(1.4,1.2,1.0)*LensFlare(uv),1.0);\n}","name":"Image","description":"","type":"image"}]}