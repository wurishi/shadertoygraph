{"ver":"0.1","info":{"id":"MfccWM","date":"1730728681","viewed":60,"name":"Snake in the shape of a tube","username":"Secretstar","description":"Screensaver ","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["snake","screensaver","tubes","pipes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 128\n#define MAX_DIST 100.0\n#define MIN_DIST 0.001\n#define MAX_BOUND 10.0\n#define TUBE_RADIUS 0.25\n#define MAX_SEGMENTS 30  // Ridotto per migliorare le performance\n#define LOOP_TIME 20.0   // Tempo dopo il quale i pattern si ripetono\n\n// Funzione hash più stabile\nfloat hash(float n) {\n    return fract(sin(n) * 43758.5453123);\n}\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// Funzione per ottenere la lunghezza del segmento\nfloat getSegmentLength(int segmentIndex, float timeOffset) {\n    vec2 seed = vec2(float(segmentIndex), timeOffset);\n    return 0.8 + rand(seed) * 1.2; // Lunghezze tra 0.8 e 2.0\n}\n\n// Funzione per ottenere la direzione successiva\nvec3 getNextDirection(vec3 currentDir, int segmentIndex, float timeOffset) {\n    vec3 globalUp = vec3(0.0, 1.0, 0.0);\n    if(abs(dot(currentDir, globalUp)) > 0.99) {\n        globalUp = vec3(1.0, 0.0, 0.0);\n    }\n    vec3 right = normalize(cross(currentDir, globalUp));\n    vec3 up = normalize(cross(right, currentDir));\n    \n    vec3 possibleDirs[4] = vec3[4](right, -right, up, -up);\n    \n    float seed = rand(vec2(float(segmentIndex), timeOffset));\n    int dirIndex = int(seed * 4.0) % 4;\n    return possibleDirs[dirIndex];\n}\n\n// Funzione ottimizzata per calcolare la posizione del segmento\nvoid getTubeSegment(int index, float timeOffset, out vec3 pos, out vec3 dir, out float length) {\n    pos = vec3(0.0);\n    dir = vec3(0.0, 0.0, 1.0);\n    \n    // Limita il numero di iterazioni per evitare loop troppo lunghi\n    int maxIter = min(index, 15);\n    for(int i = 0; i < maxIter; i++) {\n        length = getSegmentLength(i, timeOffset);\n        pos += dir * length;\n        dir = getNextDirection(dir, i, timeOffset);\n        pos = clamp(pos, vec3(-MAX_BOUND), vec3(MAX_BOUND));\n    }\n    length = getSegmentLength(index, timeOffset);\n}\n\nfloat map(vec3 p, float time) {\n    float d = MAX_DIST;\n    \n    // Usa un sistema di loop temporale per evitare accumulo infinito\n    float loopedTime = mod(time, LOOP_TIME);\n    float timeOffset = floor(time / LOOP_TIME);\n    \n    // Calcola l'indice base del segmento\n    int baseSegment = int(loopedTime * 2.0);\n    \n    // Considera solo i segmenti più recenti\n    int startSegment = max(baseSegment - MAX_SEGMENTS, 0);\n    int endSegment = baseSegment;\n    \n    for(int i = startSegment; i <= endSegment; i++) {\n        vec3 pos, dir;\n        float length;\n        getTubeSegment(i, timeOffset, pos, dir, length);\n        \n        vec3 startPos = pos;\n        vec3 endPos = pos + dir * length;\n        \n        float tubeDist = sdCapsule(p, startPos, endPos, TUBE_RADIUS);\n        \n        // Fade out per i segmenti più vecchi\n        float age = float(endSegment - i) / float(MAX_SEGMENTS);\n        float fadeEffect = smoothstep(1.0, 0.7, age);\n        \n        if(fadeEffect > 0.0) {\n            d = opSmoothUnion(d, tubeDist, 0.1);\n        }\n    }\n    \n    return d;\n}\n\nvec3 calcNormal(vec3 p, float time) {\n    vec2 e = vec2(0.001, 0.0);\n    float d = map(p, time);\n    return normalize(vec3(\n        map(p + vec3(e.x, e.y, e.y), time) - d,\n        map(p + vec3(e.y, e.x, e.y), time) - d,\n        map(p + vec3(e.y, e.y, e.x), time) - d\n    ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    float time = iTime * 1.5; // Velocità di generazione dei segmenti\n    \n    vec3 cameraPos = vec3(0.0, 0.0, -20.0);\n    vec3 cameraTarget = vec3(0.0);\n    \n    vec3 forward = normalize(cameraTarget - cameraPos);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(right, forward));\n    \n    vec3 rd = normalize(uv.x * right + uv.y * up + 1.5 * forward);\n    vec3 ro = cameraPos;\n    \n    float td = 0.0;\n    vec3 pos = ro;\n    vec3 col = vec3(0.0);\n    \n    // Ray marching ottimizzato\n    for(int i = 0; i < MAX_STEPS; i++) {\n        float d = map(pos, time);\n        if(d < MIN_DIST) {\n            vec3 n = calcNormal(pos, time);\n            vec3 lightDir = normalize(vec3(1.0, 1.0, -1.0));\n            \n            float diff = max(dot(n, lightDir), 0.0);\n            float spec = pow(max(dot(n, normalize(lightDir + normalize(ro - pos))), 0.0), 32.0);\n            \n            // Colore cangiante con variazione temporale ciclica\n            vec3 baseColor = 0.5 + 0.5 * cos(vec3(0.0, 0.33, 0.67) * 6.2831 + length(pos) * 0.5 + mod(time, 10.0) * 0.3);\n            col = baseColor * (diff * 0.8 + 0.2) + vec3(0.3) * spec;\n            break;\n        }\n        if(td > MAX_DIST) break;\n        td += max(d * 0.8, MIN_DIST); // Step size control\n        pos = ro + rd * td;\n    }\n    \n    col = pow(col, vec3(0.4545));\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//\n// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n// \n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }","name":"Common","description":"","type":"common"}]}