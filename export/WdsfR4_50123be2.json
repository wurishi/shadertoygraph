{"ver":"0.1","info":{"id":"WdsfR4","date":"1587792069","viewed":73,"name":"circular truchet","username":"blepfo","description":"https://en.wikipedia.org/wiki/Truchet_tiles","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["truchet","tile"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141\n#define MAX_HISTORY 200\n#define MAX_SIMUL_ROTATIONS 50\n\n\nvec2 translate(\n\tvec2 uv,\n    vec2 t\n) {\n    return uv - t;\n}\n\nmat2 rotate2d(float theta) {\n    return mat2(cos(theta), -sin(theta),\n                sin(theta), cos(theta));\n}\n\nfloat random (vec2 uv, float bigSeed) {\n    return fract(sin(\n        dot(uv,vec2(12.9898,78.233)))\n                 *bigSeed);\n}\n\nfloat rectSdf(\n    vec2 uv,\n    vec2 halfSize\n) {\n\tvec2 edgeDist = abs(uv) - halfSize;\n    float insideDist = min(0., max(edgeDist.x, edgeDist.y));\n    float outsideDist = length(max(edgeDist, 0.));\n    return insideDist + outsideDist;\n}\n\nfloat circSdf(\n\tvec2 uv,\n\tfloat r\n) {\n    return length(uv) - r;\n}\n\nfloat annularSdf(\n\tfloat d, \n    float w\n) {\n    return abs(d) - w;\n}\n\nfloat unionSdf(float d1, float d2) {\n    return min(d1, d2);\n}\n\nfloat annulus(vec2 uv, float r, float w, float blur) {\n    float circ = circSdf(uv, r);\n    return smoothstep(0.-blur, 0.+blur, annularSdf(circ, w));\n}\n\nfloat baseTile(\n    vec2 uv,\n    float circW,\n    float blur\n) {\n    float circTr = annulus(translate(uv, vec2(1.)), 1., circW, blur);\n    float circBl = annulus(translate(uv, vec2(-1.)), 1., circW, blur);\n    float shape = 1. - unionSdf(circTr, circBl);\n    return  shape;\n}\n\nfloat randomGridSquare(\n\tvec2 scaledUv,\n    float iTime,\n    float scaleFactor,\n    float seed\n) {\n    float xRandom = scaleFactor * random(vec2(floor(iTime)), seed);\n    float yRandom = scaleFactor * random(vec2(xRandom), seed);\n    float xIdx = floor(mod(xRandom, scaleFactor));\n    float yIdx = floor(mod(yRandom, scaleFactor));\n\t// Create circular mask for smother rotation\n    vec2 circC = translate(vec2(xIdx, yIdx), vec2(-0.5));\n    float circMaskSdf = circSdf(translate(scaledUv, circC), 0.500);\n    float randomSquare = 1. - step(0., circMaskSdf);\n    return randomSquare;\n}\n\nfloat randomGridSquares(\n    int nSquares,\n\tvec2 scaledUv, \n    float iTime,\n    float scaleFactor,\n    float seed\n) {\n    float allSquares = 0.;\n    for (int i = 0; i < MAX_SIMUL_ROTATIONS; i++) {\n        if (i >= nSquares) { break; }\n        allSquares += randomGridSquare(scaledUv, iTime, scaleFactor, seed);\n        seed *= 2.;\n    }\n    return min(1., allSquares);\n}\n\nvec2 aggregateRotations(\n    vec2 fractUv,\n    vec2 scaledUv,\n    int nSquares,\n    float iTime,\n    float scaleFactor,\n    float seed\n) {\n    vec2 rotatedUv = fractUv;\n    // Keep track of all tile rotations for up to MAX_HISTORY\n\tfor (int historySecond = 0; historySecond < MAX_HISTORY; historySecond++) {\n        if (historySecond >= int(floor(mod(iTime, float(MAX_HISTORY))))) { break; }\n        float rotateSquare = randomGridSquares(\n            nSquares,\n            scaledUv, \n            float(historySecond), \n            scaleFactor, \n            seed\n        );\n        // Rotate 90 degrees \n        float theta = (PI / 2.) * rotateSquare;\n        rotatedUv *= rotate2d(theta);\n    }\n    return rotatedUv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    float scaleFactor = 14.;\n    vec2 scaledUv = uv * scaleFactor;\n    vec2 tileIdx = floor(scaledUv);\n    vec2 fractUv = fract(scaledUv);\n    fractUv = 2. * fractUv - 1.;\n    \n    float randSeed = 212034.331;\n    \n    // Random initial orientations\n    float rand = 2.*random(tileIdx, randSeed);\n\tfloat isEven = floor(mod(rand, 2.));\n\tfractUv.x *= 2.*isEven - 1.;\n    \n    float iTime = iTime;\n    iTime = mod(iTime, float(MAX_HISTORY));\n    // Move backwards in time once we reach MAX_HISTORY\n    float timeForward = 1. - step(float(MAX_HISTORY / 2), iTime);\n    iTime = (iTime * timeForward) + (float(MAX_HISTORY) - iTime) * (1. - timeForward);\n    \n    int nSquares = 10;\n    vec2 rotatedUv = aggregateRotations(\n        fractUv, \n        scaledUv, \n        nSquares, \n        iTime, \n        scaleFactor, \n        randSeed\n    );\n    //  Current rotation\n\tfloat rotateSquare = randomGridSquares(nSquares, scaledUv, iTime, scaleFactor, randSeed);\n    float theta = (PI / 2.) * fract(iTime) * rotateSquare;\n\trotatedUv *= rotate2d(theta);\n    \n    float shape = baseTile(\n        vec2(rotatedUv.x, rotatedUv.y),\n    \t.08,\n    \t.03\n    );\n    \n    vec3 color = vec3(0.013,0.185,0.380);\n    color = mix(color, vec3(1.000,0.978,0.858), shape);\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}