{"ver":"0.1","info":{"id":"ddV3WG","date":"1679073336","viewed":291,"name":"Xor's \"AO\": Explained","username":"AleDev","description":"I was bored. Credits to Xor for the original shader","likes":16,"published":1,"flags":32,"usePreview":0,"tags":["ao"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This shader original is made by Xor.\n// Original Tweet: https://twitter.com/XorDev/status/1636387373226524673?s=20\n// Xor Twitter: https://twitter.com/XorDev?s=20\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 data = texelFetch(iChannel0,ivec2(fragCoord),0);\n    fragColor = vec4(data.xyz/data.w, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// This shader original is made by Xor.\n// Original Tweet: https://twitter.com/XorDev/status/1636387373226524673?s=20\n\n// Rotate3D function from: https://github.com/doxas/twigl/blob/master/src/shader_snippet/noise.glsl\nmat3 rotate3D(float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    \n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    \n    return mat3\n    (\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Define the screen coordinates and compute the aspect ratio.\n    float r = iResolution.x / iResolution.y;\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n    \n    // Create a variable for the world SDF, Position, and the Ray direction.\n    vec3 map, pos = vec3(1.0, 0.0, 0.0),\n    ray = rotate3D(1.0, pos++) * vec3(uv.xy, r), col = vec3(0);\n    \n    // Init the first loop with the init of 3 vars.\n    // Dist: The distance to the world SDF, i: For a the loop of the SDF Fractal, Leng: Ray length (Raymarch Itt).\n    // Next make 200 itt, and updates the position.\n    for(float dist, i, leng; leng++ < 200.; pos += ray/length(ray) * dist)\n    {\n        // Update the map to the position.\n        map = pos;\n        // Simple distance to a floor based on the 'y' component of the Position.\n        dist = map.y;\n        // Internal loop, for each iteration the 'x' and 'z' coordinate of the map is updated and the distance is calculated\n        for (i = 0.01; i < 1.0; i += i)\n        {\n            map.xz = mod(pos.xz, i + i) - i;\n            dist = min(dist, length(max(abs(map) - i * 0.5, 0.0)));\n        }\n        \n        // Make the AO after 100 itt.\n        if (leng > 100.)\n        {\n            dist += 1e-6;\n            // Pseudo random ray direction.\n            ray = fract(cos(iTime + length(fragCoord) * vec3(7, 8, 9)) * 5e2) - 0.4;\n            col += dist / 4e2;\n        }\n    }\n    \n   \t// Final output.\n    vec4 data = texelFetch(iChannel0,ivec2(fragCoord),0);\n    fragColor = data + vec4(clamp(col, 0., 1.),1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}