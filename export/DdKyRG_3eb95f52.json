{"ver":"0.1","info":{"id":"DdKyRG","date":"1696258911","viewed":52,"name":"Attempt at raytracing no. 1","username":"SpaceFishDev","description":"Dawg why is it a toon shader now?","likes":0,"published":1,"flags":0,"usePreview":1,"tags":["pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Ray\n{\n    vec3 Origin;\n    vec3 Direction;\n};\n\nstruct HitRecord\n{\n    vec3 p;\n    vec3 normal;\n    float t;\n    bool frontFace;\n};\n\nstruct Sphere\n{\n    vec3 Center;\n    float rad;\n};\n\nstruct Hit\n{\n    bool Hit;\n    HitRecord hitRec;\n};\n\nfloat lenSqr(vec3 v)\n{\n    return v.x*v.x+v.y*v.y+v.z*v.z;\n}\nfloat spp = 128.0f;\n\n\nvec3 RayAt(Ray r, float t)\n{\n    return r.Origin + (t * r.Direction);\n}\n\nfloat hash(vec2 p)\n{\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n\n\nfloat perlin(vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(\n        mix(hash(i + vec2(0, 0)), hash(i + vec2(1, 0)), u.x),\n        mix(hash(i + vec2(0, 1)), hash(i + vec2(1, 1)), u.x),\n        u.y\n    );\n}\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat random(vec2 st)\n{\n    return rand(st) + perlin(st);\n}\nvec3 random()\n{\n    return fract(random(vec2(214125214.2414,2152151254.02141))*vec3(0.989999,0.95262674386,0.921568));\n}\n\nvec3 randomUnitInSphere()\n{\n    while(true)\n    {\n        vec3 p = random();\n        if(lenSqr(p) < 1.0) return p;\n        \n    }\n}\n\nvec3 randomUnitVector()\n{\n    return normalize(randomUnitInSphere());\n}\n\nvec3 randomOnHemisphere(vec3 normal)\n{\n    vec3 onUnitSphere = randomUnitVector();\n    if(dot(onUnitSphere, normal) > 0.0 )\n    {\n        return onUnitSphere;\n    }\n    return -onUnitSphere;\n}\n\nHitRecord SetFaceNormal(Ray r, vec3 OutwardNormal, HitRecord rec)\n{\n   rec.frontFace = dot(r.Direction, OutwardNormal) < 0.0f;\n   rec.normal = rec.frontFace ? OutwardNormal : -OutwardNormal;\n   return rec;\n}\n\nHit HitSphere(Sphere s, Ray r, float rayTMin, float rayTMax)\n{\n    vec3 Center = s.Center;\n    float Radius = s.rad;\n    vec3 oc = r.Origin - Center;\n    float a = lenSqr(r.Direction);\n    float half_b = dot(oc, r.Direction);\n    float c = lenSqr(oc) - Radius*Radius;\n    \n    float Discriminant = half_b*half_b - a*c;\n    \n    if(Discriminant < 0.0f) return Hit(false, HitRecord(vec3(0,0,0), vec3(0,0,0), 0.0f, false));\n    \n    float sqrtd = sqrt(Discriminant);\n    \n    float root = (-half_b - sqrtd) / a;\n    \n    if(root <= rayTMin || rayTMax <= root)\n    {\n        root = (-half_b + sqrtd) / a;\n        if(root <= rayTMin || rayTMax <= root)\n        {\n            return Hit(false, HitRecord(vec3(0,0,0), vec3(0,0,0), 0.0f, false));\n        }\n    }\n    \n    HitRecord rec = HitRecord( RayAt(r, root), vec3(0,0,0) ,root, true);\n    vec3 outwardNormal = (rec.p - Center) / Radius;\n    rec = SetFaceNormal(r, outwardNormal, rec);\n    return Hit(true, rec);\n}\n\nfloat HitSphere(vec3 center, float radius, Ray r) {\n    vec3 oc = r.Origin - center;\n    float a = lenSqr(r.Direction);\n    float half_b = dot(oc, r.Direction);\n    float c = lenSqr(oc) - radius*radius;\n    float discriminant = half_b*half_b - a*c;\n      \n    if(discriminant < 0.0f)\n    {\n        return -1.0f;\n    }\n    return (-half_b - sqrt(discriminant) ) / a;\n}\n\n\nHit HitSpheres(Sphere objects[2000], int NumObj, Ray r, float rayTMin, float rayTMax)\n{\n    HitRecord rec;\n    bool hitAnything = false;\n    float closestSoFar = rayTMax;\n    \n    for(int i = 0; i < NumObj; ++i)\n    {\n        Hit hitter = HitSphere(objects[i],r , rayTMin, closestSoFar);\n        if(hitter.Hit)\n        {\n            hitAnything = true;\n            closestSoFar = hitter.hitRec.t;\n            rec = hitter.hitRec;\n        }\n    }\n    return Hit(hitAnything, rec);\n}\n\nvec4 RayColor(Ray r, Sphere obj)\n{\n    HitRecord rec;\n    Hit hitter = (HitSphere(obj, r,0.0f ,1024.0f*1024.0f*1024.0f));\n    if(hitter.Hit)\n    {\n        rec = hitter.hitRec;\n        return vec4(0,0,0,1) +  (0.5f * (vec4(rec.normal,0) + vec4(1,1,1,0)));\n    }\n    vec3 unitDir = normalize(r.Direction);\n    float a = 0.5*(unitDir.y + 1.0);\n    return vec4(0,0,0,1) + ((1.0-a)*vec4(1.0, 1.0, 1.0,0) + a*vec4(0.5, 0.7, 1.0,0));\n}\n\nvec4 doThing(Ray r, Sphere objs[2000], int NumObj, inout Hit hitter)\n{\n    hitter = (HitSpheres(objs, NumObj, r,0.0f ,1024.0f*1024.0f*1024.0f*1024.0f));\n    if(!hitter.Hit)\n    {\n        vec3 unitDir = normalize(r.Direction);\n        float a = 0.5*(unitDir.y + 1.0);\n        return vec4(0,0,0,1) + ((1.0-a)*vec4(1.0, 1.0, 1.0,0) + a*vec4(0.5, 0.7, 1.0,0));    \n    }\n    return vec4(0,0.3,0,0);\n}\n\nvec4 RayColor(Ray r, Sphere objs[2000], int NumObj)\n{\n    HitRecord rec;\n    Hit hitter = (HitSpheres(objs, NumObj, r,0.0f ,1024.0f*1024.0f*1024.0f));\n    vec4 col;\n    int lim = 500;\n    while(hitter.Hit && lim > 0)\n    {\n        rec = hitter.hitRec;\n        vec3 dir = randomOnHemisphere(rec.normal);\n        col += 0.5*doThing(Ray(rec.p, dir), objs, NumObj, hitter);\n        --lim;\n    }\n    col /= (500.0 - float(lim));\n    if(lim == 500)\n    {\n        vec3 unitDir = normalize(r.Direction);\n        float a = 0.5*(unitDir.y + 1.0);\n        col = vec4(0,0,0,1) + ((1.0-a)*vec4(1.0, 1.0, 1.0,0) + a*vec4(0.5, 0.7, 1.0,0));    \n    }\n    return col;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float imageHeight = iResolution.y;\n    float imageWidth = iResolution.x;\n    \n    float aspectRatio = imageWidth/imageHeight;\n    \n    float viewPortHeight = 2.0;\n    float viewPortWidth = viewPortHeight*aspectRatio;\n    \n    float focalLength = 1.0;\n    \n    vec3 cameraCenter = vec3(0,0,0);\n    \n    vec3 viewPortU = vec3(viewPortWidth, 0, 0);\n    vec3 viewPortV = vec3(0, viewPortHeight, 0);\n    \n    vec3 pixelDeltaU = viewPortU / imageWidth;\n    vec3 pixelDeltaV = viewPortV / imageHeight;\n    \n    vec3 viewPortUpperLeft = cameraCenter - vec3(0, 0, focalLength) - viewPortU/2.0f - viewPortV/2.0f;\n    \n    vec3 pixel00_loc = viewPortUpperLeft + 0.5f * (pixelDeltaU + pixelDeltaV);\n    vec4 color = vec4(0,0,0,0);\n    Sphere sp = Sphere(vec3(0,0,-1), 0.5 * (iTime / 30.0));\n    Sphere ground = Sphere(vec3(0,-100.5,-1), 100.0f);\n\n    Sphere spheres[2000];\n    spheres[0] = sp;\n    spheres[1] = ground;\n    for(int i = 0; i < int(spp); i++)\n    {\n        float x = fragCoord.x ;\n        float y = fragCoord.y ;\n\n        vec3 pixelCenter = pixel00_loc + (x * pixelDeltaU) + (y * pixelDeltaV);\n        pixelCenter += random()*0.9;\n        vec3 rayDir = pixelCenter - cameraCenter;\n\n        Ray r = Ray(cameraCenter, rayDir);\n\n        \n    \n        color += RayColor(r, spheres, 2);\n    }\n    fragColor = color/spp;\n}\n","name":"Image","description":"","type":"image"}]}