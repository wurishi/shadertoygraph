{"ver":"0.1","info":{"id":"MtSfz1","date":"1514563289","viewed":117,"name":"Weird Thingy","username":"jchabin1","description":"I'm just testing out raymarching stuff...","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.1415926535897932384626433832795;\nconst float EPSILON = 0.0001;\n\nfloat sphere(vec3 p, vec3 pos, float size){\n    return length(p - pos) - size;\n}\n\nfloat box(vec3 p, vec3 pos, vec3 size){\n    return length(max(abs(p - pos) - size, 0.0));\n}\n\nvec3 rotateX(vec3 p, float r){\n    return vec3(p.x, p.y * cos(r) - p.z * sin(r), p.y * sin(r) + p.z * cos(r));\n}\n\nvec3 rotateY(vec3 p, float r){\n    return vec3(p.x * cos(r) - p.z * sin(r), p.y, p.x * sin(r) + p.z * cos(r));\n}\n\nvec3 rotateZ(vec3 p, float r){\n    return vec3(p.x * cos(r) - p.y * sin(r), p.x * sin(r) + p.y * cos(r), p.z);\n}\n\nfloat smin(float a, float b, float k){\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat sceneDist(vec3 p){\n    //return sphere(p, vec3(0.0), 5.0);\n    \n    p = vec3(p.x, p.y, p.z);\n    float dist = sphere(p, vec3(0.0), 5.0);\n    float spheres = 10.0;\n    for(float i = 0.0; i < spheres; i += 1.0)\n        dist = max(dist, -sphere(p, vec3(5.0 * sin(iTime + PI * 2.0 * i / spheres), sin(iTime + i), 5.0 * cos(iTime + PI * 2.0 * i / spheres)), 2.0));\n    for(float i = 0.0; i < spheres; i += 1.0)\n        dist = min(dist, sphere(p, vec3(5.0 * sin(iTime + PI * 2.0 * i / spheres), sin(iTime + i), 5.0 * cos(iTime + PI * 2.0 * i / spheres)), 1.0));\n    dist = smin(dist, box(rotateZ(rotateY(p, iTime), iTime), vec3(0.0), vec3(1.0, 7.0 + sin(iTime) * 2.0, 1.0)), 2.0);\n    dist = smin(dist, box(rotateX(rotateY(p, iTime), 2.0 - iTime), vec3(0.0), vec3(1.0, 7.0 + sin(iTime) * 2.0, 1.0)), 2.0);\n    dist = min(dist, p.y + 10.0);\n    return dist;\n}\n\nvec3 getNormal(vec3 p){\n    float EPSILON = EPSILON * 1000.0;\n    return normalize(vec3(\n        sceneDist(vec3(p.x + EPSILON, p.y, p.z)) - sceneDist(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneDist(vec3(p.x, p.y + EPSILON, p.z)) - sceneDist(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneDist(vec3(p.x, p.y, p.z  + EPSILON)) - sceneDist(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 mouse;\n    if(iMouse.z > 0.0)\n    \tmouse = vec2(iMouse.x / iResolution.x * 2.0 - 1.0, iMouse.y / iResolution.y * 2.0 - 1.0);\n    else\n        mouse = vec2(0.0);\n    vec2 cameraAngle = vec2(0.0);\n\tvec3 camera = vec3(0.0, 0.0, -10.0);\n    float fov = PI / 2.0;\n    \n    \n    vec4 color = vec4(vec3(0.0), 1.0); // Sky color\n    \n    vec2 pos = vec2((2.0 * (fragCoord.x / iResolution.x) - 1.0), (2.0 * (fragCoord.y / iResolution.y) - 1.0) / iResolution.x * iResolution.y);\n    \n    float t = 0.0;\n    vec3 direction = normalize(vec3(sin(pos.x * fov + cameraAngle.x), sin(pos.y * fov + cameraAngle.y), cos(pos.x * fov + cameraAngle.x) * cos(pos.y * fov + cameraAngle.y)));\n    \n    vec3 p = camera;\n    vec3 light = vec3(-1.0, 1.0, -1.0);\n    for(t = 0.0; t < 150.0; t++){\n        float dist = sceneDist(p);\n        if(dist < EPSILON * 10.0){\n            vec3 normal = getNormal(p);\n            color += pow(dot(normalize(light), normal), 0.5) * 0.5;\n            //color = clamp(color, 0.0, 1.0);\n            color += pow(dot(reflect(normalize(light), normal), normalize(p - camera)), 5.0) * 0.3;\n            //color = clamp(color, 0.0, 1.0);\n            if(p.y + 10.0 >= EPSILON * 10.0)\n            \tcolor += texture(iChannel0, reflect(normalize(p - camera), normal)) * 0.5;\n            p = p - dist * direction * 100.0;\n            direction = normalize(light);\n            float r = 1.0;\n            for(t = 0.0; t < 50.0; t++){\n                dist = sceneDist(p);\n                if(dist < 0.001){\n                    color *= 0.0;\n                    break;\n                }\n                r = min(r, dist / t * 16.0);\n                dist = clamp(dist, 0.5, 10.0);\n                p = p + dist * direction;\n            }\n            color *= clamp(r, 0.0, 1.0);\n            break;\n        }\n        p = p + dist * direction;\n    }\n            \n    fragColor = color;\n}","name":"Image","description":"","type":"image"}]}