{"ver":"0.1","info":{"id":"3ssGRH","date":"1544966077","viewed":118,"name":"Just another Pacman shader","username":"roobz","description":"Fragment shader that draws a simple Pacman animation. Mouse changes light position.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["pacman"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The following Fragment shader draws a Pacman character as an ellipsoid (instead of sphere) so it always \n// looks round shaped despite of screen's aspect ratio. The ellipsoid's normals are camputed so Blinn-Phong\n// shading can be performed (Light's position can be tweaked by moving the mouse).\n// Contours of the character are smooth, considering if there are any objects behind (for example shading\n// of the eye on the contours considers the body's colour at that point too. Same happens with Pacmnan's\n// contour and the background color or collectible object's colour).\n// There are also cyclic animations for a maze, collectibles and Pacman´s mouth.\n//\n// 2013\n\n// Global definitions\nconst vec4 background_color = vec4(0.0, 0.0, 0.1, 1.0);\n\nconst vec3 pacman_ambientColor = vec3(0.2, 0.2, 0.0);\nconst vec3 pacman_diffuseColor = vec3(0.5, 0.5, 0.0);\nconst vec3 pacman_specColor = vec3(0.3,0.3,0.3);\n\nconst vec3 eye_ambientColor = vec3(0.0, 0.0, 0.0);\nconst vec3 eye_diffuseColor = vec3(0.15, 0.15, 0.15);\nconst vec3 eye_specColor = vec3(0.3,0.3,0.3);\n\nconst vec4 walls_color = vec4(0.0,0.0,0.5,1.0);\nconst vec4 collectables_color = vec4(0.8,0.9,0.9,1.0);\n\n// Pacman variables, tweaking these will result in a different Pacman\nconst float radiusPacmanY = 0.15;\nconst vec2  eyeOffset = vec2(0.25,0.48); // it´s a percentage of the radius\nconst float radiusEyePercent = 0.12;     // same\nconst float collectableSize = 0.1;       // same\n\n\n// Just a modulus-type function to help with the cyclic animations\nfloat modulus( float a, float b)\n{\n\tfloat c = floor(a/b);\n\treturn a - (c*b);\n}\n\n// Calculates Blinn-Phong lighting\nvec4 blinnPhongLit(vec2 pos, vec2 posSquared, vec2 radiusSquared, vec3 amb_col, vec3 dif_col, vec3 spe_col, float spe_fac, vec3 L, vec3 V)\n{\n\tfloat z = sqrt( (1.0 - (posSquared.x/radiusSquared.x) - (posSquared.y/radiusSquared.y))*radiusSquared.x);\n\tvec3 normal =  vec3(pos.x,pos.y, z);\n\tvec3 p = normal;\n\tvec3 lightDir = normalize(L - p);\n\tnormal = normalize(normal);\n\tfloat lambertian = max(dot(lightDir,normal), 0.0);\n\tfloat specular = 0.0;\n    if(lambertian > 0.0) \n    {\n    \tvec3 viewDir = normalize(V-p);\n        vec3 halfDir = normalize(lightDir + viewDir);\n        float specAngle = max(dot(halfDir, normal), 0.0);\n        specular = pow(specAngle, spe_fac);\n    \treturn vec4(amb_col+lambertian*dif_col+specular*spe_col,1.0);\n    }\n    else\n    {\n    \treturn vec4(amb_col,1.0);\n\t}\n}\n\n   \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ratio = iResolution.y / iResolution.x; \n    vec2 position = ( fragCoord.xy / iResolution.xy );\n\n    vec2  radiusPacman = vec2(radiusPacmanY * ratio, radiusPacmanY);\n    vec2  radiusPacmanSquared = radiusPacman * radiusPacman;\n    vec2  posCentered = position - vec2(0.5,0.5);\n    vec2  posCenteredSquared = posCentered * posCentered;\n    float border = radiusPacman.y / 8.0;\n\n    vec2  radiusEye = vec2(radiusPacman.x * radiusEyePercent, radiusPacman.y * radiusEyePercent);\n    vec2  radiusEyeSquared = radiusEye * radiusEye;\n    vec2  posEye = posCentered - vec2(radiusPacman.x * eyeOffset.x, radiusPacman.y * eyeOffset.y);\n    vec2  posEyeSquared = posEye * posEye;\n    float borderEye = border * 6.0;\n\n    vec4 behindPacman_color = background_color;\n    vec4 back_color = vec4(0.0, 0.0, 0.0, 0.0);\n    vec4 front_color = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    //-------------------------------------------------------------\n    // Determine if this pixel belongs to the animated maze\n    //-------------------------------------------------------------\n    float wallYPos = radiusPacman.y * 1.25; \n    vec2 wallThickness = vec2( radiusPacman.y * 0.1 * ratio, radiusPacman.y * 0.1 );\n    if ( posCentered.y > wallYPos ) \n    {\n        float refPos = modulus(iTime,2.0);\n        float posOffset = 0.6 - posCentered.x;\n        float doorSize = 2.0 * wallYPos * ratio;\n        if ( ( refPos > posOffset && refPos < posOffset + wallThickness.x ) ||  // upper vertical corridor left\n             ( refPos > posOffset+doorSize && refPos < posOffset + doorSize + wallThickness.x ) ||  // upper vertical corridor right\n             ( posCentered.y < wallYPos+wallThickness.y && (refPos < posOffset || refPos > posOffset+doorSize) ) ) // upper wall\n        {\n        \tfragColor = walls_color;\n       \t\treturn;\n    \t}\n    }\n    else if ( posCentered.y < -wallYPos )\n    {\n        float refPos = modulus(iTime,3.0);\n        float posOffset = 1.0 - posCentered.x;\n        float doorSize = 2.0 * wallYPos * ratio;\n        if ( ( refPos > posOffset && refPos < posOffset + wallThickness.x ) ||  // lower vertical corridor left\n             ( refPos > posOffset+doorSize && refPos < posOffset + doorSize + wallThickness.x ) ||  // lower vertical corridor right\n             ( posCentered.y > -(wallYPos + wallThickness.y) && (refPos < posOffset || refPos > posOffset+doorSize) ) ) // lower wall\n        {\n        \tfragColor = walls_color;\n        \treturn;\n    \t}\n    }\n    \n    //-------------------------------------------------------------\n    // Determine if this pixel belongs to one of the collectables\n    //-------------------------------------------------------------\n    vec2 collectableDimensions = vec2( 2.0 * radiusPacman.x * collectableSize, radiusPacman.y * collectableSize );\n    if ( posCentered.x > -radiusPacman.x/3.0 && abs(posCentered.y) < collectableDimensions.y )            // -radius/3.0 so collectables die behind\n    {\n        vec2 pos = vec2(0.6 - modulus(iTime,2.0), 0.0);       // just a cyclically varying position\n        if ( (posCentered.x > pos.x && posCentered.x < pos.x + collectableDimensions.x) ||            // collectable 1\n                             (posCentered.x > 0.5 + pos.x && posCentered.x < 0.5 + pos.x + collectableDimensions.x) ) // collectable 2 (0.5 offset)\n        {\n        \tbehindPacman_color = collectables_color;\n        }\n    }\n    \n    //-------------------------------------------------------------\n    // Determine if this pixel belongs to the mouth area\n    //-------------------------------------------------------------\n    float y = posCentered.x * tan(0.6 * sin(iTime*5.0));\n    float dif = 0.0;\n    if ( (posCentered.x >= 0.0) && /*(posCentered.x <= radiusPacman.x) &&*/ (abs(posCentered.y) - abs(y)  < 0.0) )\n    {\n        dif = abs(y) - abs(posCentered.y);\n        if ( dif  < 0.005)\n        {\n        \t// colour needs to be mixed\n        \tback_color = behindPacman_color;\n        }\n        else\n        {\n        \tfragColor = behindPacman_color;\n        \treturn;\n        }\n    }\n\n    //-------------------------------------------------------------\n    // Determine if this pixel belongs to the eye area\n    //-------------------------------------------------------------\n    float d_eye = posEyeSquared.x/radiusEyeSquared.x + posEyeSquared.y/radiusEyeSquared.y;\n    if ( d_eye < 1.0 )\n    {\n    \tvec4 eye_color = blinnPhongLit(posEye, posEyeSquared, radiusEyeSquared, \n        eye_ambientColor, eye_diffuseColor, eye_specColor, 20.0, \n        vec3(((iMouse.x/iResolution.x)-0.5)*10.0,((iMouse.y/iResolution.y)-0.5)*10.0,5.0), vec3(0,0,5));\n        if ( sqrt(d_eye) > 1.0 - borderEye)\n        {\n        \t// colour needs to be mixed\n        \tfront_color = eye_color;\n        }\n        else\n        {\n        \tfragColor = eye_color;\n        \treturn;\n        }\n    }\n\n    //-------------------------------------------------------------\n    // Determine if this pixel belongs to body\n    //-------------------------------------------------------------\n    float t = 0.0; // for blending colors\n    float d_body = posCenteredSquared.x/radiusPacmanSquared.x + posCenteredSquared.y/radiusPacmanSquared.y;\n    if (d_body <= 1.0) // true when we are within Pacman's boundary (an ellipse)\n    {\n    \tvec4 body_color = blinnPhongLit(posCentered, posCenteredSquared, radiusPacmanSquared, \n        \tpacman_ambientColor, pacman_diffuseColor, pacman_specColor, 16.0, \n           \tvec3(((iMouse.x/iResolution.x)-0.5)*4.0,((iMouse.y/iResolution.y)-0.5)*4.0,4.0), vec3(0,0,5));\n\t\t\n        if ( sqrt(d_body) > 1.0 - border)\n        {\n        \t// contour of the ellipse, colours will be mixed\n        \tback_color = behindPacman_color;\n        \tfront_color = body_color;\n        \tt = (1.0-sqrt(d_body)) / border;\n        }\n        else if (front_color.w == 1.0) \n        {\n       \t\t// eye boundary, colour will be mixed\n       \t\tback_color = body_color;\n        \tt = (1.0-sqrt(d_eye)) / borderEye;\t\n        }\n        else if (back_color.w == 1.0)\n        {\n        \t// mouth boundary, colour will be mixed\n        \tfront_color = body_color;\n        \tt = 1.0 - abs(dif/0.005);\t\n        }\n        else\n        {\n        \t// rest of the body\n        \tfragColor = body_color;\n        \treturn;\n        }\n\t\t\n        fragColor = mix(back_color, front_color, t);\n        return;\n    }\n\n    fragColor = behindPacman_color;\n    return;\n}","name":"Image","description":"","type":"image"}]}