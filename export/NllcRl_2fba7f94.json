{"ver":"0.1","info":{"id":"NllcRl","date":"1648909749","viewed":70,"name":"Renge-Queen","username":"tono","description":"Renge-Queen(renge jo-oh-sama) is @IMA8MAI","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["rengequeen"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float pi = acos(-1.);\n\n#define TAU (atan(1.) * 8.)\n#define smin(a,b) (a+b-sabs(a-b))*.5\n#define smax(a,b) (a+b+sabs(a-b))*.5\n\n#define DONBURI_ID 0.\n#define TABLE_ID 1.\n#define HASHI_ID 2.\n#define RENGE_ID 3.\n\nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat sabs(float x)\n{\n    //return sqrt(x*x+1e-4);\n    return sqrt(x*x+1e-4);\n}\n\n\nmat3 RotMat(vec3 axis, float angle)\n{\n    // http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, \n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s, \n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c          );\n}\n\nvec2 min2(vec2 a,vec2 b)\n{\n    if(a.x < b.x)\n    {\n        return a;\n    }\n    return b;\n}\n\nfloat wirebox(vec3 p,vec3 s,float w)\n{\n    p=abs(p);\n    p-=s;\n    if(p.x<p.y)p.xy=p.yx;\n    if(p.x<p.z)p.xz=p.zx;\n    if(p.y<p.z)p.yz=p.zy;\n    return length(p.xy)-w;\n}\n\nfloat smoothMin(float d1, float d2, float k){\n    float h = exp(-k * d1) + exp(-k * d2);\n    return -log(h) / k;\n}\n\nvec3 random3(vec3 c) {\n    float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n    vec3 r;\n    r.z = fract(512.0*j);\n    j *= .125;\n    r.x = fract(512.0*j);\n    j *= .125;\n    r.y = fract(512.0*j);\n    return r-0.5;\n}\n\n//https://www.shadertoy.com/view/XsX3zB\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n    /* 1. find current tetrahedron T and it's four vertices */\n    /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n    /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\n    /* calculate s and x */\n    vec3 s = floor(p + dot(p, vec3(F3,F3,F3)));\n    vec3 x = p - s + dot(s, vec3(G3,G3,G3));\n\n    /* calculate i1 and i2 */\n    vec3 e = step(vec3(0.,0.,0.), x - x.yzx);\n    vec3 i1 = e*(1.0 - e.zxy);\n    vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\n    /* x1, x2, x3 */\n    vec3 x1 = x - i1 + G3;\n    vec3 x2 = x - i2 + 2.0*G3;\n    vec3 x3 = x - 1.0 + 3.0*G3;\n\n    /* 2. find four surflets and store them in d */\n    vec4 w, d;\n\n    /* calculate surflet weights */\n    w.x = dot(x, x);\n    w.y = dot(x1, x1);\n    w.z = dot(x2, x2);\n    w.w = dot(x3, x3);\n\n    /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n    w = max(0.6 - w, 0.0);\n\n    /* calculate surflet components */\n    d.x = dot(random3(s), x);\n    d.y = dot(random3(s + i1), x1);\n    d.z = dot(random3(s + i2), x2);\n    d.w = dot(random3(s + 1.0), x3);\n\n    /* multiply d by w^4 */\n    w *= w;\n    w *= w;\n    d *= w;\n\n    /* 3. return the sum of the four surflets */\n    return dot(d, vec4(52.0,52.0,52.0,52.0));\n}\n\nfloat scaleSphere( vec3 p, vec3 scale, float s )\n{\n    return (length(p/scale)-s)*min(scale.x, min(scale.y, scale.z));\n}\n\nfloat sdSolidAngle(vec3 p, vec2 c, float ra)\n{\n  // c is the sin/cos of the angle\n  vec2 q = vec2( length(p.xz), p.y );\n  float l = length(q) - ra;\n  float m = length(q - c*clamp(dot(q,c),0.0,ra) );\n  return max(l,m*sign(c.y*q.x-c.x*q.y));\n}\n\nvec2 table(vec3 p)\n{\n    vec3 op = p;\n    vec2 o = vec2(10.,TABLE_ID);\n    vec2 s = vec2(1.,10.);\n    p.z -= 4.;\n    p.y -= 5.8;\n    p.yz -= clamp(p.yz,-s,s);\n    o.x = length(p.yz)-1.;\n    \n    s = vec2(5.,10.);\n    op.z -= 16.;\n    op.y -= .5;\n    op.yz -= clamp(op.yz,-s,s);\n    // o.x = min(o.x, length(op.yz) - .5);\n\n    if(o.x < 0.1)\n    {\n        o.x -= simplex3d(op*4.)/80.;\n    }\n    return o;\n}\n\nvec2 donburi(vec3 p)\n{\n    vec3 op = p;\n    vec2 o = vec2(10.,DONBURI_ID);\n    p.y -= 5.34;\n    float a = .72;\n    float s = 8.;\n    p.xy *= rot(pi);\n    float sol = sdSolidAngle(p,vec2(sin(a),cos(a)),s);\n    sol = max(sol,-(p.y-2.) );\n    p.y -= 0.5;\n    o.x = (sdSolidAngle(p,vec2(sin(a),cos(a)),s))-.3;\n    \n    o.x = max(o.x,-(p.y-2.) );\n    o.x = max(-o.x,sol);\n    p.y -= 1.3;\n\n    float soko = length(vec2(length(p.xz)-1.6,p.y/3.))-0.1;\n    o.x = min(o.x,soko);\n    if(o.x < 0.1)\n    {\n        o.x -= simplex3d(op*vec3(10.,10.,10.))/1080.;\n    }\n    return o;\n}\n\nvec2 hashi(vec3 p){\n    vec3 op = p;\n    vec2 o = vec2(10.,HASHI_ID);\n    p.y += .8;\n    vec3 s = vec3(.05,.05,6.);\n    s.xy *= max(.1, (p.z + 7.)/1. )/107.;\n    \n    p.xz *= rot(-0.8 + iTime * 0.);\n    vec3 dp =p- clamp(p,-s,s);\n\n    float b1 = length(dp)-0.1;\n    p.y += 0.27;\n    // p.xy *= rot(-0.05);\n    p.xz *= rot(pi/2.1);\n    dp = p- clamp(p,-s,s);\n\n    float b2 = length(dp) - 0.1;\n    o.x = min(b1,b2);\n    if(o.x < 0.1)\n    {\n        o.x -= simplex3d(op*10.)/680.;\n    }\n    return o;\n}\n\nvec2 renge1(vec3 p){\n\tfloat scale = 1.22;\n\tp /= scale;\n    \n\n    vec3 op = p;\n    vec3 opp = p;\n    vec2 o = vec2(10.,RENGE_ID);\n    float a = .6;\n    float s = 1.;\n    p.z += 0.;\n    p.y -= 0.3;\n    // p.z += .2;\n    p.xz *= rot(-pi/2. - 2. + 3.+ 3.3 * 0.) ;\n    p.z += .8;\n    \n    opp = p;\n    \n    p.y += 2.06;\n    p.yz *= rot(pi/2.+ 0.2);\n    p.y += .3;\n    op = p;\n    float l = .34;\n    p.z -= clamp(p.z,-l,l);\n    float sol = sdSolidAngle(p,vec2(sin(a),cos(a)),s);\n    vec3 sp = p;\n    sol = max(sol,-(op.y - 0.4));\n    // sol = max(sol,(op.y - .8));\n    p.y += .01;\n    op = p;\n    float sol2 = sdSolidAngle(p,vec2(sin(a),cos(a)),s);\n    sol2 = max(sol2,-(op.y - 0.4));\n    sol2 = max(sol2,(op.y - .8) );\n    \n    o.x = sol2;\n    vec3 pp = opp;\n    opp.y += 3.;\n    opp.yz *= rot(-opp.y/8.); \n    opp.yz *= rot(-.5);\n    vec3 p1 = opp;\n    opp.y -= clamp(opp.y,-2.5,0.);\n    float e = length(opp)-0.15;\n    \n    pp.z -= 0.1;\n    pp.y += 2.9;\n    pp.yz *= rot(-pp.y/8.); \n    pp.yz *= rot(-.5);\n    \n    pp.y -= 0.;\n    pp.z -= 0.01;\n    pp.y -= clamp(pp.y,-4.,0.);\n    \n    \n    // o.x = max(-sol,sol2);\n    o.x = smoothMin(o.x,e,3.9);\n    \n\tfloat e2 = length(pp)-0.16;\n\te2 = smoothMin(e2 , length(p1 + vec3(0.,0.,-0.3))-0.07,2.7);\n\t// o.x = max(o.x,-( e2));\n    // o.x = e2;\n\to.x *= scale;\n    return o;\n}\n\nvec2 renge(vec3 p){\n    vec2 o = vec2(100.);\n    vec3 pp = p;\n    float s = iTime;\n    p.x -= 0.1;\n    p.xz *= rot(s);\n    o = renge1(p);\n    \n    pp.xz *= rot(s);\n    float sif = 0.14;\n    pp.x -= sif/2.;\n    pp.z -= sif ;\n    // pp.x -= sif/2.;\n    o.x = min(o.x , (renge1(pp).x));\n    o.x = max( -o.x , (renge1(p).x) );\n    return o;\n}\n\n\nvec2 map(vec3 p)\n{\n    vec3 op = p;\n    vec2 o = vec2(10.,0.);\n    // o.x = length(p) - 1.5;\n\n    o = table(p);\n    o = min2(donburi(p),o);\n    o = min2(o,hashi(p));\n    o = min2(renge(p),o);\n\n    p.xz *= rot(iTime);\n    p.yz *= rot(iTime * 1.3);\n    \n    o.x *= 0.7;\n    return o;\n}\n\nvec2 march(vec3 cp , vec3 rd)\n{\n    float depth = 0.;\n    for(int i = 0; i< 196; i++)\n    {\n        vec2 d = map(cp + rd * depth);\n        //if(abs(min(d.x,.1)) < 0.01)\n        d.x = d.x * .5;\n        if(abs(d.x) < 0.01)\n        {\n            return vec2(depth,d.y);\n        }\n        if(depth > 50.)break;\n        depth += d.x;\n    }\n    return vec2(-depth);\n}\n\nvec2 shadowmarch(vec3 cp , vec3 rd)\n{\n    float depth = 0.;\n    for(int i = 0; i< 128; i++)\n    {\n        vec2 d = map(cp + rd * depth);\n        if(abs(d.x) < 0.01)\n        {\n            return vec2(depth,d.y);\n        }\n        depth += d.x;\n    }\n    return vec2(-depth);\n}\n\nvec3 setMatCol(float index,vec3 pos,vec3 N)\n{\n    vec3 mat = vec3(1.,0.,1.);\n    if(DONBURI_ID == index)\n    {\n        mat = mix(vec3(1.,0.,0.),vec3(1.,1.,1.),step(0.1,pos.y));\n        // mat = vec3(1.,0.,0.);\n    }else if(TABLE_ID == index){\n        mat = vec3(.7,0.3,.5);\n        mat = mix( simplex3d(pos * vec3(13.,1.,0.5)) * mat , mat,.7 );\n    }else if(HASHI_ID == index){\n        mat = vec3(0.3,0.,0.);\n    }else if(RENGE_ID == index)\n    {\n        mat = vec3(1.);\n    }else{\n        mat = vec3(1.);\n    }\n    return mat;\n}\n\nvec3 getReflect(vec3 cp,vec3 rd , float intensity,vec3 lpos,vec3 light)\n{\n    vec2 d = march(cp,rd);\n    vec3 o = vec3(0.);\n    if(d.x > 0.)\n    {\n        vec3 light = normalize(vec3(0.0, 1.0, 0.)); \n\n        vec3 pos = cp + rd * d.x;\n        vec2 e = vec2(0.,0.01);\n        vec3 N = -normalize(map(pos).x - vec3(map(pos - e.xyy).x,map(pos - e.yxy).x,map(pos - e.yyx).x ) );\n        float attenuation = intensity / ( .5 + .9 * length(pos - lpos) + .8 * pow(length(lpos - pos),2.) );\n        attenuation = 1.;\n        \n        vec3 mat = setMatCol(d.y,pos,N);\n        //color = N;\n        float diff = max(0.,dot(light,N) ) * attenuation;\n        vec3 refv = reflect(light,N);\n        //ref += texture(cubemap,refv).rgb;\n        \n        float sp = max(0.,dot(refv,-rd));\n        // sp = pow(sp,16.) * 1.;\n        if(d.y == DONBURI_ID)\n        {\n            sp = pow(sp,100.) * 1.;\n        }\n\n        o = mat * diff;\n        //o *= shadow;\n    }\n    return o;\n}\n\nvoid scene(vec2 infragCoord,in vec2 shift,out vec3 outcol) {\n\tvec2 p = (infragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    p.y *= -1.;\n    vec3 f = vec3(0.);\n    vec3 cp = vec3(0.,-3.,-24.);\n    cp.yz *= rot(-10.);\n    vec3 target = vec3(0.,-.5,0.);\n    vec3 cd = normalize(target - cp);\n    vec3 cs = normalize(cross(vec3(0.,1.,0.),cd));\n    vec3 cu = normalize(cross(cd , cs));\n    \n    float fov = 3.5;\n    vec3 rd = normalize(cd * fov + cu * p.y + p.x * cs);\n\n    // cp.z += iTime/2. * morph.w;\n    vec3 col = vec3(1.);\n\n    //vec3 light = normalize(vec3(0.7, 0.8, 0.7)); \n    //light.xz *= rot(-1.4);\n    vec3 lpos = vec3(21.2523,8.08423,1.19026);\n    vec3 ltarget = vec3(-88.,98.,63.);\n    vec3 light = normalize(ltarget - lpos); \n\n    float attenuation = 0.;\n\n    vec3 color = vec3 (0.,.5,1.);\n    color = vec3(0.5);\n    vec2 d = march(cp,rd);\n\n    vec3 N = vec3(0.);\n    vec3 mat = color;\n    float tt = 1.;\n    float diff = 0.;\n    float sp = 0.;\n    vec3 l = light;\n   // l.xz *= rot(pi/3);\n    float sun = max(0.,dot(l,rd));\n    float shadow = 1.;\n    sun = pow(sun , 30.) * 2.4;\n\n    vec3 o = vec3(1.);\n    if(d.x > 0.)\n    {\n        vec3 pos = cp + rd * d.x;\n        vec2 e = vec2(0.,0.001);\n        vec3 N = -normalize(map(pos).x - vec3(map(pos - e.xyy).x,map(pos - e.yxy).x,map(pos - e.yyx).x ) );\n        float intensity = 1.;\n        float attenuation = intensity / ( .01 + .03 * length(pos - lpos) + .001 * pow(length(lpos - pos),2.) );\n        \n        mat = setMatCol(d.y,pos,N);\n        // color = N;\n        diff = max(0.,dot(light,N)) * attenuation;\n        \n        vec3 refv = reflect(light,N);\n        vec3 ref = getReflect(pos + 0.1 * N , refv,intensity,lpos,light);\n        sp = max(0.,dot(refv,-rd));\n\t    //sp = pow(sp,16.) * 1.;\n\n         mat = setMatCol(d.y,pos,N);\n        vec3 emission = step(1.8,length(mat)) * mat;\n        // color = N;\n        diff = max(0.,dot(light,N)) * attenuation;\n        sp = max(0.,dot(refv,-rd));\n        sp = pow(sp,10.) * 1.1;\n\n        if(d.y == DONBURI_ID)\n        {\n            sp = pow(sp,1.5) * 1.;\n        }else if(d.y == HASHI_ID){\n            sp = pow(sp,5.) * 1.;\n        }else if(d.y == RENGE_ID){\n            sp = pow(sp,2.) * 1.;\n        }else if(d.y == TABLE_ID){\n            sp = pow(sp,1.) * 1.0;\n        }\n\n        shadow = shadowmarch(pos + N * 0.02 ,-light).x;\n        shadow = step(shadow,0.01) * attenuation;\n        color.rgb = mat;\n        color.rgb = mat * diff + sp*1.;\n        color.rgb =color.rgb * 1. +  ref * color.rgb;\n        float tt = d.x;\n        tt = 1. - exp(-.003 * tt * tt );\n\n        //color.rgb *= shadow;\n        float t = 0.;\n        vec3 sky = vec3(1.);\n\n        color.rgb += emission * 1.;\n        if(mat.g == 1. && mat.r == 0.)\n        {\n            color = vec3(0.);\n        }\n        color.rgb = pow(color.rgb,vec3(.4545));\n        color.rgb = clamp(color.rgb , vec3(0.),vec3(1.));\n    }\n    outcol += color.rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 outcol;\n    if(!true)\n    {\n        for(int x = -1;x<2;x++)\n        {\n            for(int y = -1;y<2;y++)\n            {\n                scene(fragCoord.xy,vec2(x,y)/iResolution.xy,outcol);\n            }\n        }\n        outcol /= 9.;\n    }else{\n        scene(fragCoord.xy,vec2(0,0)/iResolution.xy,outcol);\n    }\n    \n    fragColor = vec4(outcol,1.);\n}\n","name":"Image","description":"","type":"image"}]}