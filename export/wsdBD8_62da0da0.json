{"ver":"0.1","info":{"id":"wsdBD8","date":"1605024203","viewed":67,"name":"Path Tracing Testing 10","username":"Pjbomb2","description":"Newer version of the engine I am making, but cant figure out how to do total internal reflection, can anyone provide insight to this for me?\nWASD and mouse, to switch rendering scene, comment and uncomment the #defines in common\n","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//How can I optimize this?  \n//Did I do the refraction physically correctly?(is it physically correct?)\n//Comment out the FRACTAL define in Common to get to the refraction portion\n//also what would be a good method to debug the rays in this?\n//finally, what/where would be a better place to ask questions like this?\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n    vec3 col = vec3(0.0);\n    \n   if( iFrame>0 )\n    {\n        col = texture( iChannel2, uv ).xyz;\n        //col /= float(iFrame);\n            // convert unbounded HDR color range to SDR color range\n    col = ACESFilm(col);\n\n    // convert from linear to sRGB for display\n    col = LinearToSRGB(col);\n        //col = pow( col, vec3(0.4545) );\n    }\n\n    // color grading and vigneting\n    //col = pow( col, vec3(0.8) ); col *= 1.6; col -= vec3(0.03,0.02,0.0);\n    \n    col *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 );\n    \n\n\n\n\n\n    \n    \n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//#define CorrelBox\n#define RefractTest\n#define ofst 8\n\n\nvec3 LessThan(vec3 f, float value)\n{\n    return vec3(\n        (f.x < value) ? 1.0f : 0.0f,\n        (f.y < value) ? 1.0f : 0.0f,\n        (f.z < value) ? 1.0f : 0.0f);\n}\n \nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n     \n    return mix(\n        pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,\n        rgb * 12.92f,\n        LessThan(rgb, 0.0031308f)\n    );\n}\n \nvec3 SRGBToLinear(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n     \n    return mix(\n        pow(((rgb + 0.055f) / 1.055f), vec3(2.4f)),\n        rgb / 12.92f,\n        LessThan(rgb, 0.04045f)\n    );\n}\n\n\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n\n\nvec4 texcube( sampler2D sam, in vec3 p, in vec3 n )\n{\n    vec3 m = n*n;\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n\treturn (x*m.x + y*m.y + z*m.z) / (m.x+m.y+m.z);\n}\n\n\nfloat opIntersection( float d1, float d2 ) { \nreturn (d1 > d2) ? d1:d2;\n}\n\nfloat opSubtraction( float d1, float d2 )\n{\n    return (-d1 > d2) ? -d1:d2;\n}\n\nvec2 find_nearest(vec2 d1, vec2 d2) {\n    return (d1.x < d2.x) ? d1:d2;\n}\n\n\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  return dot(p,n) + h;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat opRep( in vec3 p, in vec3 c)\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return sdBox(q,vec3(0.5, 5, 0.5));\n}\n\n\n    float sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nvec2 map(in vec3 p) {\n    \n vec2 ret = vec2(1000, 0);\n\n    \n #ifdef CorrelBox\n \n    ret = find_nearest(ret, vec2(sdBox(p - vec3(0, 4, ofst-1), vec3(1.5, 0.5, 1.5)), 14));\n    \n    ret = find_nearest(ret, vec2(sdBox(p - vec3(0, -4, ofst), vec3(5, 0.5, 3)), 12));\n    \n    ret = find_nearest(ret, vec2(opSubtraction(sdBox(p - vec3(0, 4, ofst-1), vec3(1.5, 1, 1.5)), sdBox(p - vec3(0, 4, ofst), vec3(5, 0.5, 3))), 12));\n    \n    ret = find_nearest(ret, vec2(sdBox(p - vec3(5, 0, ofst), vec3(0.5, 4, 3)), 10));\n    \n    ret = find_nearest(ret, vec2(sdBox(p - vec3(-5, 0, ofst), vec3(0.5, 4, 3)), 11));\n    \n    //ret = find_nearest(ret, vec2(sdBox(p - vec3(0, 0, ofst+2), vec3(5, 4, 0.5)), 12));\n    \n    ret = find_nearest(ret, vec2(opRep(p - vec3(0, 0, ofst+2), vec3(2,0,0)), 12));\n    ret = find_nearest(ret, vec2(opRep(p - vec3(1, 0, ofst+2), vec3(2,0,0)), 13));\n    \n    //ret = find_nearest(ret, vec2(sdBox(p - vec3(0, 0, ofst-2), vec3(5, 4, 0.5)), 12));\n    \n    \n    \n    \n   ret = find_nearest(ret, vec2(sdSphere(p - vec3(3, -2.5, ofst), 1.0), 16.0));\n    \n    ret = find_nearest(ret, vec2(sdSphere(p - vec3(0, -2.0, ofst), 1.0), 2.0));\n    \n    ret = find_nearest(ret, vec2(sdSphere(p - vec3(-3, -2.5, ofst), 1.0), 18.0));\n    \n    ret = find_nearest(ret, vec2(sdSphere(p - vec3(-3, 0, ofst), 1.0), 17.0));\n  \n    \n    \n    \n    \n #else\n    #ifdef RefractTest\n    \n        ret = find_nearest(ret, vec2(sdBox(p - vec3(0.0, -2.2, 0), vec3(0.5,0.1,0.5)), 14));\n    //ret = find_nearest(ret, vec2(opSubtraction(sdBox(p - vec3(0.2, 0, 0), vec3(0.2,1,1.0)), sdCappedCylinder(p-vec3(0,0.49,0.0), vec2(0.3,0.5))), 2.0));\n    \n    \n    ret = find_nearest(ret, vec2(sdBox((p - vec3(0.0, -2.5, -4)), vec3(1,0.1,1)), 10));\n    \n    ret = find_nearest(ret, vec2(sdBox((p - vec3(0.0, -2.5, -2)), vec3(2,0.5,0.1)), 10));\n    \n    //ret = find_nearest(ret, vec2(sdCappedCylinder(p-vec3(0,0.0,0.0), vec2(0.3,2)), 2.0));\n    \n    ret = find_nearest(ret, vec2(opSubtraction(sdBox((p - vec3(0.0, -3.5, -2)), vec3(1,1.5,3)), sdTorus((p - vec3(0,-2,-2)).zxy, vec2(2, 0.3))), 2.0)); \n    \n    //ret = find_nearest(ret, vec2(opSubtraction(sdCappedCylinder(p-vec3(0,0.0,0.0), vec2(1.4,4)), sdCappedCylinder(p-vec3(0,0.0,0.0), vec2(1.5,2))), 3.0));\n    \n    //ret = find_nearest(ret, vec2(sdBox(p - vec3(-1, 0.5, 0), vec3(0.1,1,1)), 12));\n    \n    \n    \n     ret = find_nearest(ret, vec2(opSubtraction(sdTorus((p - vec3(0,-2,-2)).zxy, vec2(2, 0.3)), sdBox(p - vec3(0, -1.8, 0), vec3(2,0.2,2))), 10));\n\n    ret = find_nearest(ret, vec2(sdBox(p - vec3(0, 2.5, 0), vec3(2,0.2,2)), 11.0));\n    \n #else\n    ret = find_nearest(ret, vec2(sdSphere(p-vec3(0,0,0.5), 0.1), 2));\n    \n        vec3 w = p;\n    vec3 q = p;\n\n    q.xz = mod( q.xz+1.0, 2.0 ) -1.0;\n    \n    float d = sdBox(q,vec3(1.0));\n    float s = 1.0;\n    for( int m=0; m<3; m++ )\n    {\n        float h = float(m)/6.0;\n\n        p =  q - 0.5*sin( abs(p.y) + float(m)*3.0+vec3(0.0,3.0,1.0));\n\n        vec3 a = mod( p*s, 2.0 )-1.0;\n        s *= 3.0;\n        vec3 r = abs(1.0 - 3.0*abs(a));\n\n        float da = max(r.x,r.y);\n        float db = max(r.y,r.z);\n        float dc = max(r.z,r.x);\n        float c = (min(da,min(db,dc))-1.0)/s;\n\n        d = max( c, d );\n   }\n\n    \n   float d1 = length(w-vec3(0.22,0.35,0.4)) - 0.09;\n   d = min( d, d1 );\n\n   float d2 = w.y + 0.22;\n   d =  min( d,d2);\n\n    \n   ret = find_nearest(ret, vec2(d, 3));\n\n    \n    ret = find_nearest(ret, vec2(opRep(p - vec3(1.1,0.0,1), vec3(2, 0.0, 2)), 4));\n    \n#endif\n    #endif\n    return ret;\n    \n}\n\n\nvec2 map2(in vec3 p) {\n    \n vec2 ret = vec2(1000, 0);\n\n    \n #ifdef CorrelBox\n\n        ret = find_nearest(ret, vec2(-sdSphere(p - vec3(0, -2.0, ofst), 1.0), 2.0));\n    \n#else\n    #ifdef RefractTest\n    //ret = find_nearest(ret, vec2(-sdCappedCylinder(p-vec3(0,0.0,0.0), vec2(0.3,2)), 2.0));\n    ret = find_nearest(ret, vec2(-opSubtraction(sdBox((p - vec3(0.0, -3.5, -2)), vec3(1,1.5,3)), sdTorus((p - vec3(0,-2,-2)).zxy, vec2(2, 0.3))), 2.0)); \n #else\n    ret = find_nearest(ret, vec2(-sdSphere(p-vec3(0,0,0.5), 0.1), 2));\n    \n#endif\n    #endif\n    return ret;\n    \n}\n\n\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.0001,0.0,0.0);\n\n    return normalize( vec3(\n      map( pos+eps.xyy ).x - map( pos-eps.xyy ).x,\n      map( pos+eps.yxy ).x - map( pos-eps.yxy ).x,\n      map( pos+eps.yyx ).x - map( pos-eps.yyx ).x ) );\n}\n\nvec3 calcNormal2( in vec3 pos )\n{\n    vec3 eps = vec3(0.0001,0.0,0.0);\n\n    return normalize( vec3(\n      map2( pos+eps.xyy ).x - map2( pos-eps.xyy ).x,\n      map2( pos+eps.yxy ).x - map2( pos-eps.yxy ).x,\n      map2( pos+eps.yyx ).x - map2( pos-eps.yyx ).x ) );\n}\n\n/*\nvec3 calcNormal(in vec3 pos) {\n    float eps = 0.0001;\n     vec4 n = vec4(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec4 s = vec4(pos, 0.0);\n        s[i] += eps;\n        n[i] = map(s.xyz).x;\n    }\n    return normalize(n.xyz-n.w);   \n    \n    \n    \n}\n*/\n\n\nfloat FresnelReflectAmount (float n1, float n2, vec3 normal, vec3 incident)\n{\n        // Schlick aproximation\n        float r0 = (n1-n2) / (n1+n2);\n        r0 *= r0;\n        float cosX = -dot(normal, incident);\n        if (n1 > n2)\n        {\n            float n = n1/n2;\n            float sinT2 = n*n*(1.0-cosX*cosX);\n            // Total internal reflection\n            if (sinT2 > 1.0)\n                return 1.0;\n            cosX = sqrt(1.0-sinT2);\n        }\n        float x = 1.0-cosX;\n        float ret = r0+(1.0-r0)*x*x*x*x*x;\n \n        // adjust reflect multiplier for object reflectivity\n        ret = (0.1 + (1.0-0.1) * ret);\n        return ret;\n}\n\n\n\nvec3 GetMatProps(in float mat, out float refl, out float refr, out float emmis) {\n    if(mat == 0.0) {\n     refl = 0.0;\n        refr = 0.0;\n        emmis = 0.0;\n        return vec3(0.5);\n        \n    }\n    if(mat == 1.0) {\n     refl = 1.0;\n        refr = 0.0;\n        emmis = 0.0;\n        return vec3(1.0, 1.0, 0.1);\n        \n    }\n    if(mat == 2.0) {\n     refl = 0.0;\n        refr = 1.0;\n        emmis = 0.0;\n        return vec3(1.0, 2.0, 3.0);    \n    }\n    if(mat == 3.0) {\n     refl = 0.9;\n        refr = 0.0;\n        emmis = 0.0;\n        return vec3(0.1, 1.0, 0.1);        \n    }\n    if(mat == 4.0) {\n     refl = 1.0;\n        refr = 0.0;\n        emmis = 5000.0;\n        return vec3(0.3, 0.1, 1.0);\n    }\n    \n    \n    \n     if(mat == 10.0) {\n     \trefl = 0.0;\n        refr = 0.0;\n        emmis = 0.0;\n        return vec3(0.7, 0.1, 0.1);\n    }\n     if(mat == 11.0) {\n     \trefl = 0.0;\n        refr = 0.0;\n        emmis = 0.0;\n        return vec3(0.1, 0.7, 0.1);\n    }\n     if(mat == 12.0) {\n     \trefl = 0.0;\n        refr = 0.0;\n        emmis = 0.0;\n        return vec3(0.7, 0.7, 0.6);\n    }\n         if(mat == 13.0) {\n     \trefl = 0.0;\n        refr = 0.0;\n        emmis = 0.0;\n        return vec3(0.2, 0.2, 0.1);\n    }\n    \n    \n     if(mat == 14.0) {\n     \trefl = 0.0;\n        refr = 0.0;\n        emmis = 2005.0;\n        return vec3(0.9, 0.9, 0.7);\n    }\n         if(mat == 16.0) {\n     \trefl = 0.0;\n        refr = 0.0;\n        emmis = 0.0;\n        return vec3(0.4, 0.7, 0.2);\n    }\n         if(mat == 17.0) {\n     \trefl = 0.5;\n        refr = 0.0;\n        emmis = 0.0;\n        return vec3(0.4, 0.7, 0.2);\n    }\n         if(mat == 18.0) {\n     \trefl = 1.0;\n        refr = 0.0;\n        emmis = 0.0;\n        return vec3(0.4, 0.7, 0.2);\n    }\n    \n    \nreturn vec3(0.2, 0.2, 1.0);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by genis sole - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.\n\n#define store(P, V) if (all(equal(ivec2(fragCoord), P))) fragColor = V\n#define load(P) texelFetch(iChannel1, ivec2(P), 0)\n#define key(K)  step(0.5, texelFetch(iChannel0, ivec2(K, 0), 0).x)\n\nconst ivec2 MEMORY_BOUNDARY = ivec2(4, 3);\n\nconst ivec2 POSITION = ivec2(1, 0);\n\nconst ivec2 VMOUSE = ivec2(1, 1);\nconst ivec2 PMOUSE = ivec2(2, 1);\n\nconst ivec2 TARGET = ivec2(0, 2);\n\nconst ivec2 RESOLUTION = ivec2(3, 1);\n\n// Keyboard constants definition\nconst int KEY_BSP   = 8;\nconst int KEY_SP    = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\nconst int KEY_COMMA = 188;\nconst int KEY_PER   = 190;\n\n#define KEY_BINDINGS(FORWARD, BACKWARD, RIGHT, LEFT) const int KEY_BIND_FORWARD = FORWARD; const int KEY_BIND_BACKWARD = BACKWARD; const int KEY_BIND_RIGHT = RIGHT; const int KEY_BIND_LEFT = LEFT;\n\n#define ARROWS  KEY_BINDINGS(KEY_UP, KEY_DOWN, KEY_RIGHT, KEY_LEFT)\n#define WASD  KEY_BINDINGS(KEY_W, KEY_S, KEY_D, KEY_A)\n#define ESDF  KEY_BINDINGS(KEY_E, KEY_D, KEY_F, KEY_S)\n\n#define INPUT_METHOD  WASD\nvec2 KeyboardInput() {\n    INPUT_METHOD\n    \n\tvec2 i = vec2(key(KEY_BIND_RIGHT)   - key(KEY_BIND_LEFT), \n                  key(KEY_BIND_FORWARD) - key(KEY_BIND_BACKWARD));\n    \n    float n = abs(abs(i.x) - abs(i.y));\n    return i * (n + (1.0 - n)*inversesqrt(2.0));\n}\n\nvec3 CameraDirInput(vec2 vm) {\n    vec2 m = vm/iResolution.x;\n    m.y = -m.y;\n    \n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n    mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n    \n    return (rotY * rotX) * vec3(KeyboardInput(), 0.0).xzy * 10.0;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    if (any(greaterThan(ivec2(fragCoord), MEMORY_BOUNDARY))) return;\n    \n    fragColor = load(fragCoord);\n    \n    vec2 resolution = load(RESOLUTION).xy;\n    store(RESOLUTION, vec4(iResolution.xy, 0.0, 0.0));\n    \n    if (iTime == 0.0 || iFrame == 0 || any(notEqual(iResolution.xy, resolution))) {\n        store(POSITION, vec4(0.0, 0.0, 0.0, 0.0));\n        store(TARGET, vec4(0.0, 0.0, 0.0, 0.0));\n        store(VMOUSE, vec4(0.0));\n        store(PMOUSE, vec4(0.0));\n        \n        return;\n    }\n\n    vec3 target      = load(TARGET).xyz;   \n    vec3 position    = load(POSITION).xyz;\n    vec2 pm          = load(PMOUSE).xy;\n    vec3 vm          = load(VMOUSE).xyz;\n    \n    vec3 ptarget = target;\n    target += CameraDirInput(vm.xy) * iTimeDelta * 5.0;\n    \n\n    \n    position += (0.1 * target - position);\n    \n    store(TARGET, vec4(target, 0.0));\n    store(POSITION, vec4(position, 0.0));\n    \n    if (any(greaterThan(iMouse.zw, vec2(0.0)))) {\n    \tstore(VMOUSE, vec4(pm + (iMouse.zw - iMouse.xy), 1.0, 0.0));\n    }\n    else if (vm.z != 0.0) {\n    \tstore(PMOUSE, vec4(vm.xy, 0.0, 0.0));\n    }\n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Camera and Keyboard input by glk7, from https://www.shadertoy.com/view/4lVXRm\n//Hash, uniformVector, cosineDirection, and some parts of the main algorithm taken from IQ's projects\n\n\n#define load(P) texelFetch(iChannel1, ivec2(P), 0)\nconst ivec2 VMOUSE = ivec2(1, 1);\n\nconst float PI = 3.141592;\n\nconst ivec2 POSITION = ivec2(1, 0);\n\n\nconst float c_pi = 3.14159265359f;\nconst float c_twopi = 2.0f * c_pi;\n\n\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat RandomFloat01(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n\nvec3 RandomUnitVector(inout uint state)\n{\n    float z = RandomFloat01(state) * 2.0f - 1.0f;\n    float a = RandomFloat01(state) * c_twopi;\n    float r = sqrt(1.0f - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\n\n\n\nfloat hash(float seed)\n{\n    return fract(sin(seed)*43758.5453 );\n}\n\nvec3 uniformVector( in float seed)\n{\n    float a = 3.141593*hash( 78.233 + seed);\n    float b = 6.283185*hash( 10.873 + seed);\n    return vec3( sin(b)*sin(a), cos(b)*sin(a), cos(a) );\n}\n\nvec3 cosineDirection( in float seed, in vec3 nor)\n{\n    float u = hash( 78.233 + seed);\n    float v = hash( 10.873 + seed);\n\n    \n    \tfloat ks = (nor.z>=0.0)?1.0:-1.0;     //do not use sign(nor.z), it can produce 0.0\n        float ka = 1.0 / (1.0 + abs(nor.z));\n        float kb = -ks * nor.x * nor.y * ka;\n        vec3 uu = vec3(1.0 - nor.x * nor.x * ka, ks*kb, -ks*nor.x);\n        vec3 vv = vec3(kb, ks - nor.y * nor.y * ka * ks, -nor.y);\n    \n        float a = 6.2831853 * v;\n        return sqrt(u)*(cos(a)*uu + sin(a)*vv) + sqrt(1.0-u)*nor;\n}\n\nfloat shadow( in vec3 ro, in vec3 rd )\n{\n    float res = 0.0;\n    \n    float tmax = 16.0;\n    \n    float t = 0.001;\n    for(int i=0; i<80; i++ )\n    {\n        float h = map(ro+rd*t).x;\n        if( h<0.0001 || t>tmax) break;\n        t += h;\n    }\n\n    if( t>tmax ) res = 1.0;\n    \n    return res;\n}\n\nfloat intersect(in vec3 ro, in vec3 rd) {\n\tfloat res = -1.0;\n    float tmax = 16.0;\n    float t = 0.01;\n    for(int i = 0; i < 128; i++) {\n    \tfloat h = map(ro+rd*t).x;\n        if((h<0.0001) || (t>tmax)) break;\n        t += h;\n            \n    }\n    if(t<tmax) res = t;\n    \n    return res;\n    \n}\n\n\n\n\n\n\nfloat antiintersect(in vec3 ro, in vec3 rd) {\n\tfloat res = -1.0;\n    float tmax = 16.0;\n    float t = 0.01;\n    for(int i = 0; i < 128; i++) {\n    \tfloat h = map2(ro+rd*t).x;\n        if((h<0.0001) || (t>tmax)) break;\n        t += h;\n            \n    }\n    if(t<tmax) res = t;\n    \n    return res;\n    \n}\n\n\n\n\n\nvec3 calcFinalColor(vec3 ro, vec3 rd, float sa) {\n    vec3 accumulatedColor = vec3(0.0);\n        vec3 colorMask = vec3(1.0);\n    float refl = 0.0;\n    float refr = 0.0;\n    float emmis = 0.0;\n            float fdis = 0.0;\n\n    \n    for(int bounce = 0; bounce < 10; bounce++) {\n        float t = intersect(ro, rd);\n        if( t < 0.0 )\n        {\n            \n            fdis=16.0; \n            accumulatedColor += mix( 0.05*vec3(0.9,1.0,1.0), vec3(texture(iChannel0, rd).rgb), smoothstep(0.1,0.25,rd.y) );\n            \n            break;\n        }\n    \tif(bounce == 0) fdis = t;\n        vec3 pos = ro + rd*t;\n        vec3 surfaceColor = GetMatProps(map(pos).y, refl, refr, emmis);\n        vec3 norm = calcNormal(pos);\n        surfaceColor *= texcube( iChannel3, pos*0.5, norm ).xyz*1.2;\n \n        vec3 iColor = vec3(0.0);\n        vec3 I = normalize(ro - pos);\n\t\tfloat rdist = 0.0;\n       \n        if(refr == 1.0) {//if material is refractive\n           //  for(int g = 0; g < 10; g++) {           \n        ro = pos;\n        rd = refract(rd, norm, 1.0/1.5);\n\n        t = antiintersect(ro, rd);\n        pos = ro + rd*t;\n rdist = length(ro-pos);\nro = pos;\n        norm = calcNormal2(pos);\n        \n        rd = refract(rd, norm, 1.5);\n            rd = mix(rd,  reflect(rd, norm), FresnelReflectAmount(1.0003, 1.5, norm, rd));\n            //colorMask *= exp(-(surfaceColor*0.3) * rdist); //coloring based on distance ray travels through transparent object\n           // }\n        }else {\n                  colorMask *= surfaceColor;\n\t\t\t\tfloat isDif = 1.0-refl;\n\n              float glossiness = 0.0;\n            rd = mix( normalize(reflect(rd, norm)) + uniformVector(sa + 111.123 + 65.2*float(bounce)) * glossiness, cosineDirection(76.2 + 73.1*float(bounce) + sa + 17.7*float(iFrame), norm), isDif);\n\n\n            ro = pos;\n\n              }\n      \n        \n        \n\n        \n        \n        \n        iColor += (emmis * surfaceColor) + 2.0 * accumulatedColor * dot(norm, rd);\n        accumulatedColor += colorMask * iColor;\n        \n\n\n        \n        \n    }\n    \n    \n    \n    \n    \n        float ff = exp(-0.01*fdis*fdis);\n    accumulatedColor *= ff; \n    accumulatedColor += (1.0-ff)*0.05*vec3(0.9,1.0,1.0);\n\n\n    \n    return accumulatedColor;\n}\n\n\n\n\nvoid Camera(in vec2 fragCoord, out vec3 ro, out vec3 rd, in vec2 jitter) \n{\n    ro = load(POSITION).xyz;\n    vec2 m = load(VMOUSE).xy/iResolution.x;\n    m.y = -m.y;\n    \n    float a = 1.0/max(iResolution.x, iResolution.y);\n    rd = normalize(vec3(((fragCoord + jitter) - iResolution.xy*0.5)*a, 0.5));\n    \n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n    mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n    \n    rd = (rotY * rotX) * rd;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    vec2 jitter = vec2(RandomFloat01(rngState), RandomFloat01(rngState)) - 0.5f;\n    \n    \n     vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 32.0 + iTime*1.5;\n    float sa = hash( dot( fragCoord, vec2(12.9898, 78.233) ) + 1113.1*float(iFrame) );\n    \n\n    vec3 ro = vec3(0.0);\n    vec3 rd = vec3(0.0);\n    Camera(fragCoord, ro, rd, jitter);\n    \n\tvec3 col = vec3(0.0);\n\n        \n            vec4 lastFrameColor = texture( iChannel2, fragCoord/iResolution.xy );\n            float blend = (lastFrameColor.a == 0.0f || iMouse.z > 1.0) ? 1.0f : 1.0f / (1.0f + (1.0f / lastFrameColor.a));\n    col = mix(lastFrameColor.rgb, calcFinalColor( ro, rd, sa ), blend);\n\n    \n    fragColor = vec4(col,blend);\n}","name":"Buffer B","description":"","type":"buffer"}]}