{"ver":"0.1","info":{"id":"XftSRf","date":"1714310953","viewed":21,"name":"Vakidioot Final","username":"rooby","description":"vakidioot","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["vakidioot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SURFACE_DIST 0.1\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define MAX_STEPS 100\n\nvec3 LIGHT_DIR = normalize(vec3(3., 8., -7.));\nvec3 MAT_COL = vec3(28., 117., 138.) / 255.;\nvec3 BG_COL = vec3(0.1);\n\n// Signed distance function of a capsule\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat smin( float a, float b, float k )\n{\n    k *= 1.0;\n    float r = exp2(-a/k) + exp2(-b/k);\n    return -k*log2(r);\n}\n\nfloat sdfScene(vec3 pos)\n{\n    float d = 0.;\n    \n    vec3 p = pos - vec3(0.15, 0., 0.);\n    vec3 a = vec3(-1.9, 1., 5.);\n    vec3 b = vec3(1.2, 1. + 0.25 * p.x*p.x, 5.);\n    float r = 0.03 * abs(p.x - a.x + b.x) + 0.15;\n    float hor_bar = sdCapsule(p, a, b, r);\n    d = hor_bar;\n\n    a = vec3(-1. - 0.05*pos.y*pos.y, -1.7, 5.);\n    b = vec3(-0.5, 0.8, 5.);\n    r = 0.05 * abs(pos.y + a.y - b.y) + 0.1;\n    float left_leg = sdCapsule(pos, a, b, r);\n    d = smin(d, left_leg, 0.1);\n\n    a = vec3(0.5 + 0.1*pos.y*pos.y, -1.7, 5.);\n    b = vec3(0.5, 0.8, 5.);\n    r = 0.05 * abs(pos.y + a.y - b.y) + 0.1;\n    float right_leg = sdCapsule(pos, a, b, r);\n    d = smin(d, right_leg, 0.1);\n\n    return d;\n}\n\nvec3 getNormal(vec3 pos)\n{\n    vec2 u = vec2(0.0001, 0.);\n\n    return normalize(vec3(\n        sdfScene(pos + u.xyy) - sdfScene(pos - u.xyy),\n        sdfScene(pos + u.yxy) - sdfScene(pos - u.yxy),\n        sdfScene(pos + u.yyx) - sdfScene(pos - u.yyx)\n    ));\n}\n\nfloat rayMarch(vec3 rayOrigin, vec3 rayDir)\n{\n    float depth = 0.;\n    \n    for (int i=0; i<MAX_STEPS; i++)\n    {\n        vec3 pos = rayOrigin + depth * rayDir;\n        float dist = sdfScene(pos);\n        depth += dist;\n        \n        if (depth > MAX_DIST)\n            break;\n        else if (abs(dist) < MIN_DIST)\n            return depth;\n    }\n    \n    return -1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (2.*fragCoord - iResolution.xy)/ iResolution.x;\n\n    // Position and direction of camera\n    vec3 rayOrigin = vec3(0.);\n    vec3 rayDir = normalize(vec3(uv, 1.));\n\n    // Compute distance to scene using ray marching\n    float depth = rayMarch(rayOrigin, rayDir);\n    \n    vec3 col = BG_COL;\n    if (depth > 0.)\n    {\n        vec3 pos = rayOrigin + depth * rayDir;\n        vec3 normal = getNormal(pos);\n        \n        float brightness = max(dot(normal, LIGHT_DIR), 0.); \n        float d = rayMarch(pos + normal*SURFACE_DIST, LIGHT_DIR);\n        if (d > 0.)\n            brightness *= 0.1;\n        \n        col = brightness * MAT_COL;\n    }\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}