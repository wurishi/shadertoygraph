{"ver":"0.1","info":{"id":"lffXzf","date":"1705548362","viewed":79,"name":"Kubelka-Munk Mix","username":"shake_n_jake","description":"Kubelka-Munk Mix ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["paint","spectral","kubelkamunk"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* ------------------------------------------------------------------------- *\n*\n*    Copyright (C) 2024 Jake Kurtz\n*\n*    This program is free software: you can redistribute it and/or modify\n*    it under the terms of the GNU General Public License as published by\n*    the Free Software Foundation, either version 3 of the License, or\n*    (at your option) any later version.\n*\n*    This program is distributed in the hope that it will be useful,\n*    but WITHOUT ANY WARRANTY; without even the implied warranty of\n*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n*    GNU General Public License for more details.\n*\n*    You should have received a copy of the GNU General Public License\n*    along with this program. If not, see <https://www.gnu.org/licenses/>.\n*\n* ------------------------------------------------------------------------- */\n\n/* pigment substrates */\n\n#define AIR\n//#define WATER\n//#define OIL\n\n/* https://dl.acm.org/doi/abs/10.1145/146443.146452 */\nvoid kubelka_munk(float l, float f, float n, float s, vec3 col_a, vec3 col_b, out float R)\n{\n    float k1 = pow2((n - 1.0) / (n + 1.0));\n    float k2 = clamp(s, 0.0, 1.0 - k1);\n\n    float Rm_a = sRGB_to_SPEC(col_a, l);\n    float Rm_b = sRGB_to_SPEC(col_b, l);\n\n    float q = 1.0 - k1 - k2;\n    float R_a = k1 + (max( Rm_a - k1, 0.0) / (q + k2*Rm_a));\n    float R_b = k1 + (max( Rm_b - k1, 0.0) / (q + k2*Rm_b));\n\n    float K_a = pow2(1.0 - R_a) / max((2.0*R_a), .05);\n    float K_b = pow2(1.0 - R_b) / max((2.0*R_b), .05);\n    \n    float K = mix(K_a, K_b, f);\n    \n    R = 1. + K - sqrt(K*K + 2.0*K);\n}\n\n/* https://www.shadertoy.com/view/MsjXRt */\nvec3 hue_shift (in vec3 color, in float shift)\n{\n    vec3 P = vec3(0.55735)*dot(vec3(0.55735),color);\n    vec3 U = color-P;\n    vec3 V = cross(vec3(0.55735),U);\n    color = U*cos(shift*6.2832) + V*sin(shift*6.2832) + P;\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 mouse = iMouse / iResolution.x;\n\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspect_ratio = iResolution.x / iResolution.y;\n    \n    float grid_tiles = 5.0;\n    vec2 step_size = vec2(floor(aspect_ratio*grid_tiles), grid_tiles);\n    \n    float grid_thickness = 0.1;\n    vec3 grid_col = vec3(0.86, 0.85, 0.75);\n    \n    vec2 uv_g = fract(uv * step_size);\n    vec2 fc = 1.0 - step(vec2(1.0-grid_thickness), abs(2.0*uv_g-1.0));\n    float grid_mask = fc.x * fc.y;\n    \n    vec2 f = ceil(uv*step_size)/step_size;\n\n    vec3 col_0 = mix(vec3(0.1), hue_shift(vec3(0.0,0.2,1.0), iTime*.05), f.y);\n    vec3 col_1 = mix(hue_shift(vec3(1.0,0.8,0.0), iTime*.05), vec3(0.9), f.y);\n\n    if (mouse.z<=0.0) {\n        f.x = 1.0 - pow(1.0-f.x, 3.0);\n\n        float ior_air = 1.0;\n        float ior_water = 1.33;\n        float ior_linseed_oil = 1.48;\n\n        vec3 seed = vec3(fragCoord, float(iFrame));\n\n        float l[LAMBDA_SAMPLES];\n        gen_lambda_samples(seed, l);\n\n        float spec_R[LAMBDA_SAMPLES];\n        for (int i = 0; i < LAMBDA_SAMPLES; i++)\n        {\n        #if defined(WATER)\n            kubelka_munk(l[i], f.x, ior_water, 0.25, col_0, col_1, spec_R[i]);\n        #elif defined(OIL)\n            kubelka_munk(l[i], f.x, ior_linseed_oil, 0.25, col_0, col_1, spec_R[i]);\n        #else\n            kubelka_munk(l[i], f.x, ior_air, 0.0, col_0, col_1, spec_R[i]);\n        #endif\n        }\n\n        vec3 R = SPEC_to_sRGB(spec_R, l);\n\n        // Output to screen\n        fragColor = vec4(mix(grid_col, R, grid_mask), 1.0);\n    } else {\n        fragColor = vec4(mix(grid_col, mix(col_0, col_1, f.x), grid_mask), 1.0);\n    }\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* ------------------------------------------------------------------------- *\n*\n*    Copyright (C) 2024 Jake Kurtz\n*\n*    This program is free software: you can redistribute it and/or modify\n*    it under the terms of the GNU General Public License as published by\n*    the Free Software Foundation, either version 3 of the License, or\n*    (at your option) any later version.\n*\n*    This program is distributed in the hope that it will be useful,\n*    but WITHOUT ANY WARRANTY; without even the implied warranty of\n*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n*    GNU General Public License for more details.\n*\n*    You should have received a copy of the GNU General Public License\n*    along with this program. If not, see <https://www.gnu.org/licenses/>.\n*\n* ------------------------------------------------------------------------- */\n\n#define FIT\n\n#define M_PI         3.1415926535897932        /* pi */\n#define M_PI_2       1.5707963267948966        /* pi/2 */\n#define M_PI_4       0.7853981633974483        /* pi/4 */\n#define M_2_PI       0.6366197723675813        /* 2/pi */\n#define M_2PI        6.2831853071795865        /* 2*pi */\n#define M_4PI        12.566370614359173        /* 4*pi */\n#define M_SQRT2PI    2.5066282746310005        /* sqrt(2*pi) */\n#define M_2_SQRTPI   1.1283791670955126        /* 2/sqrt(pi) */\n#define M_E          2.7182818284590452        /* e (Euler's number) */\n#define M_LN2        0.6931471805599453        /* ln(2) */\n#define M_LN10       2.3025850929940457        /* ln(10) */\n#define M_LOG2E      1.4426950408889634        /* log_2(e) */\n#define M_LOG10E     0.4342944819032518        /* log_10(e) */\n#define M_SQRT2      1.4142135623730950        /* sqrt(2) */\n#define M_SQRT1_2    0.7071067811865475        /* 1/sqrt(2) */\n\n#define LAMBDA_SAMPLES 20\n#define LAMBDA_MIN 380\n#define LAMBDA_MAX 780\n#define LAMBDA_STEP float(LAMBDA_MAX - LAMBDA_MIN) / float(LAMBDA_SAMPLES)\n\n#define CIE_SAMPLES 95\n#define CIE_MIN 360\n#define CIE_MAX 830\n#define CIE_STEP 5.\n\n#define CIE_Y_INTEGRAL 106.85691664936203\n#define CIE_Y_D65_INTEGRAL 98.89001078341919\n#define SCALE float(LAMBDA_MAX - LAMBDA_MIN) / (float(LAMBDA_SAMPLES) * CIE_Y_D65_INTEGRAL)\n\n/* Hash by David_Hoskins */\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat rand_range(float a, float b, vec3 p3)\n{\n    float h = hash13(p3);\n    return (a-b)*h + b;\n}\nfloat rand_range(int a, int b, vec3 p3)\n{\n    float h = hash13(p3);\n    return float(a-b)*h + float(b);\n}\n\nfloat remap(float v, float l1, float h1, float l2, float h2) \n{\n    return mix(l2, h2, (v - l1)  / (h1 - l1));\n}\n\nfloat pow2(float x)\n{\n    return x*x;\n}\nfloat gauss(float x, float a, float b, float c)\n{\n    return a*exp(-pow2((x-b)/c));\n}\nfloat sigmoidal(float x,float a,float b,float c,float d) \n{\n    return d + (a-d) / (1.0 + pow(x/c, b));\n}\nfloat sigmoidal(float x,float a,float b,float c)\n{\n    return a / (1.0 + exp(-b*(x-c)));\n}\n\nfloat CIE_X[CIE_SAMPLES] = float[](0.0001299, 0.0002321, 0.0004149, 0.0007416, 0.001368, 0.002236, 0.004243, 0.00765, 0.01431, 0.02319, 0.04351, 0.07763, 0.13438, 0.21477, 0.2839, 0.3285, 0.34828, 0.34806, 0.3362, 0.3187, 0.2908, 0.2511, 0.19536, 0.1421, 0.09564, 0.05795001, 0.03201, 0.0147, 0.0049, 0.0024, 0.0093, 0.0291, 0.06327, 0.1096, 0.1655, 0.2257499, 0.2904, 0.3597, 0.4334499, 0.5120501, 0.5945, 0.6784, 0.7621, 0.8425, 0.9163, 0.9786, 1.0263, 1.0567, 1.0622, 1.0456, 1.0026, 0.9384, 0.8544499, 0.7514, 0.6424, 0.5419, 0.4479, 0.3608, 0.2835, 0.2187, 0.1649, 0.1212, 0.0874, 0.0636, 0.04677, 0.0329, 0.0227, 0.01584, 0.01135916, 0.008110916, 0.005790346, 0.004109457, 0.002899327, 0.00204919, 0.001439971, 0.0009999493, 0.0006900786, 0.0004760213, 0.0003323011, 0.0002348261, 0.0001661505, 0.000117413, 8.307527e-05, 5.870652e-05, 4.150994e-05, 2.935326e-05, 2.067383e-05, 1.455977e-05, 1.025398e-05, 7.221456e-06, 5.085868e-06, 3.581652e-06, 2.522525e-06, 1.776509e-06, 1.251141e-06);\nfloat CIE_Y[CIE_SAMPLES] = float[](3.917e-06, 6.965e-06, 1.239e-05, 2.202e-05, 3.9e-05, 6.4e-05, 0.00012, 0.000217, 0.000396, 0.00064, 0.00121, 0.00218, 0.004, 0.0073, 0.0116, 0.01684, 0.023, 0.0298, 0.038, 0.048, 0.06, 0.0739, 0.09098, 0.1126, 0.13902, 0.1693, 0.20802, 0.2586, 0.323, 0.4073, 0.503, 0.6082, 0.71, 0.7932, 0.862, 0.9148501, 0.954, 0.9803, 0.9949501, 1.0, 0.995, 0.9786, 0.952, 0.9154, 0.87, 0.8163, 0.757, 0.6949, 0.631, 0.5668, 0.503, 0.4412, 0.381, 0.321, 0.265, 0.217, 0.175, 0.1382, 0.107, 0.0816, 0.061, 0.04458, 0.032, 0.0232, 0.017, 0.01192, 0.00821, 0.005723, 0.004102, 0.002929, 0.002091, 0.001484, 0.001047, 0.00074, 0.00052, 0.0003611, 0.0002492, 0.0001719, 0.00012, 8.48e-05, 6e-05, 4.24e-05, 3e-05, 2.12e-05, 1.499e-05, 1.06e-05, 7.4657e-06, 5.2578e-06, 3.7029e-06, 2.6078e-06, 1.8366e-06, 1.2934e-06, 9.1093e-07, 6.4153e-07, 4.51810e-07);\nfloat CIE_Z[CIE_SAMPLES] = float[](0.0006061, 0.001086, 0.001946, 0.003486, 0.006450001, 0.01054999, 0.02005001, 0.03621, 0.06785001, 0.1102, 0.2074, 0.3713, 0.6456, 1.0390501, 1.3856, 1.62296, 1.74706, 1.7826, 1.77211, 1.7441, 1.6692, 1.5281, 1.28764, 1.0419, 0.8129501, 0.6162, 0.46518, 0.3533, 0.272, 0.2123, 0.1582, 0.1117, 0.07824999, 0.05725001, 0.04216, 0.02984, 0.0203, 0.0134, 0.008749999, 0.005749999, 0.0039, 0.002749999, 0.0021, 0.0018, 0.001650001, 0.0014, 0.0011, 0.001, 0.0008, 0.0006, 0.00034, 0.00024, 0.00019, 0.0001, 4.999999e-05, 3e-05, 2e-05, 1e-05, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);\n\nfloat CIE_D65[CIE_SAMPLES] = float[](46.6383, 49.3637, 52.0891, 51.0323, 49.9755, 52.3118, 54.6482, 68.7015, 82.7549, 87.1204, 91.486, 92.4589, 93.4318, 90.057, 86.6823, 95.7736, 104.865, 110.936, 117.008, 117.41, 117.812, 116.336, 114.861, 115.392, 115.923, 112.367, 108.811, 109.082, 109.354, 108.578, 107.802, 106.296, 104.79, 106.239, 107.689, 106.047, 104.405, 104.225, 104.046, 102.023, 100.0, 98.1671, 96.3342, 96.0611, 95.788, 92.2368, 88.6856, 89.3459, 90.0062, 89.8026, 89.5991, 88.6489, 87.6987, 85.4936, 83.2886, 83.4939, 83.6992, 81.863, 80.0268, 80.1207, 80.2146, 81.2462, 82.2778, 80.281, 78.2842, 74.0027, 69.7213, 70.6652, 71.6091, 72.979, 74.349, 67.9765, 61.604, 65.7448, 69.8856, 72.4863, 75.087, 69.3398, 63.5927, 55.0054, 46.4182, 56.6118, 66.8054, 65.0941, 63.3828, 63.8434, 64.304, 61.8779, 59.4519, 55.7054, 51.959, 54.6998, 57.4406, 58.8765, 60.3125);\n\nfloat CIE_OPTIMAL_R[CIE_SAMPLES] = float[](0.028818291, 0.028818291, 0.028818291, 0.028818291, 0.028818291, 0.028818291, 0.028818291, 0.028818291, 0.028818291, 0.028770917, 0.028681031, 0.028507641, 0.028184712, 0.027613202, 0.026695068, 0.025387006, 0.023691176, 0.021683511, 0.019499471, 0.017284601, 0.015164369, 0.01322398, 0.011508938, 0.010032852, 0.008784129, 0.007733877, 0.006847712, 0.006113831, 0.005528477, 0.00508063, 0.004759755, 0.004559076, 0.004476933, 0.004518465, 0.004699746, 0.005051466, 0.005624523, 0.006507247, 0.007856514, 0.009955215, 0.013332373, 0.019050053, 0.029416764, 0.049957946, 0.09546049, 0.208235667, 0.469770292, 0.745606932, 0.868355627, 0.91904131, 0.942996767, 0.955787697, 0.963275107, 0.967568415, 0.970340909, 0.972202337, 0.973478536, 0.974362517, 0.974980528, 0.975415806, 0.975722246, 0.975937277, 0.976087481, 0.976087481, 0.976087481, 0.976087481, 0.976087481, 0.976087481, 0.976087481, 0.976087481, 0.976087481, 0.976087481, 0.976087481, 0.976087481, 0.976087481, 0.976087481, 0.976087481, 0.976087481, 0.976087481, 0.976087481, 0.976087481, 0.976087481, 0.976087481, 0.976087481, 0.976087481, 0.976087481, 0.976087481, 0.976087481, 0.976087481, 0.976087481, 0.976087481, 0.976087481, 0.976087481, 0.976087481, 0.976087481);\nfloat CIE_OPTIMAL_G[CIE_SAMPLES] = float[](0.011877002, 0.011877002, 0.011877002, 0.011877002, 0.011877002, 0.011877002, 0.011877002, 0.011877002, 0.011877002, 0.011877002, 0.011886657, 0.011959757, 0.012098436, 0.012354682, 0.012802303, 0.013531737, 0.014684282, 0.016471404, 0.019223505, 0.02351872, 0.030417962, 0.042024179, 0.062721079, 0.102044876, 0.181390517, 0.337660526, 0.556197975, 0.727519207, 0.827899667, 0.88471046, 0.917913767, 0.938146992, 0.950950467, 0.959292655, 0.96480335, 0.968407165, 0.970637837, 0.971769994, 0.971878264, 0.970838189, 0.96823842, 0.963107683, 0.953211636, 0.9330891, 0.888010848, 0.775722345, 0.51480865, 0.239773366, 0.117870335, 0.067970837, 0.044705727, 0.032499914, 0.02549641, 0.021203103, 0.018430612, 0.016569185, 0.015292988, 0.014409008, 0.013790999, 0.013355721, 0.013049283, 0.012834253, 0.01268405, 0.01268405, 0.01268405, 0.01268405, 0.01268405, 0.01268405, 0.01268405, 0.01268405, 0.01268405, 0.01268405, 0.01268405, 0.01268405, 0.01268405, 0.01268405, 0.01268405, 0.01268405, 0.01268405, 0.01268405, 0.01268405, 0.01268405, 0.01268405, 0.01268405, 0.01268405, 0.01268405, 0.01268405, 0.01268405, 0.01268405, 0.01268405, 0.01268405, 0.01268405, 0.01268405, 0.01268405, 0.01268405);\nfloat CIE_OPTIMAL_B[CIE_SAMPLES] = float[](0.959304707, 0.959304707, 0.959304707, 0.959304707, 0.959304707, 0.959304707, 0.959304707, 0.959304707, 0.959304707, 0.95935208, 0.959432313, 0.959532602, 0.959716853, 0.960032118, 0.960502632, 0.961081261, 0.961624548, 0.961845091, 0.961277031, 0.959196687, 0.954417677, 0.944751849, 0.925769991, 0.887922279, 0.809825361, 0.654605604, 0.436954319, 0.266366969, 0.166571863, 0.110208918, 0.077326487, 0.057293941, 0.044572609, 0.036188889, 0.030496912, 0.026541377, 0.023737647, 0.021722764, 0.020265225, 0.019206597, 0.018429206, 0.017842261, 0.017371594, 0.016952945, 0.016528651, 0.016041975, 0.015421044, 0.014619686, 0.013774022, 0.012987836, 0.012297489, 0.011712372, 0.011228468, 0.011228468, 0.011228468, 0.011228468, 0.011228468, 0.011228468, 0.011228468, 0.011228468, 0.011228468, 0.011228468, 0.011228468, 0.011228468, 0.011228468, 0.011228468, 0.011228468, 0.011228468, 0.011228468, 0.011228468, 0.011228468, 0.011228468, 0.011228468, 0.011228468, 0.011228468, 0.011228468, 0.011228468, 0.011228468, 0.011228468, 0.011228468, 0.011228468, 0.011228468, 0.011228468, 0.011228468, 0.011228468, 0.011228468, 0.011228468, 0.011228468, 0.011228468, 0.011228468, 0.011228468, 0.011228468, 0.011228468, 0.011228468, 0.011228468);\n\nvec3 XYZ_to_sRGB(vec3 xyz)\n{\n    vec3 rgb;\n    rgb.r = dot(xyz, vec3( 3.2404542, -1.5371385, -0.4985314));\n    rgb.g = dot(xyz, vec3(-0.9692660,  1.8760108,  0.0415560));\n    rgb.b = dot(xyz, vec3( 0.0556434, -0.2040259,  1.0572252));\n    return rgb;\n}\nvec3 sRGB_to_XYZ(vec3 rgb)\n{\n    vec3 xyz;\n    xyz.r = dot(rgb, vec3(0.4124564, 0.3575761, 0.1804375));\n    xyz.g = dot(rgb, vec3(0.212672,  0.7151522, 0.0721750));\n    xyz.b = dot(rgb, vec3(0.0193339, 0.1191920, 0.9503041));\n    return xyz;\n}\n\nvec3 CMF_to_XYZ(float l)\n{\n    vec3 xyz;\n#ifdef FIT\n    xyz.x = ( l < 500.0 ) ? gauss(l, 0.3762, 449.0573, 27.0226) : gauss(l, 0.8981, 596.7094, 44.6502) + gauss(l, 0.1214, 549.8165, 23.7826);\n    xyz.y = gauss(l, 14.0421, 540.7364, 21.3541) + gauss(l, -13.8573, 540.8008, 21.2394) + gauss(l,  0.8341,  559.4890, 60.2144);\n    xyz.z = gauss(l, 43.1393, 449.6270, 21.3703) + gauss(l,  0.4729,  469.7765, 38.1569) + gauss(l, -41.5637, 449.6359, 21.1548);\n#else\n    int _l = int((round(l) - float(CIE_MIN)) / CIE_STEP);\n    float D65 = CIE_D65[_l] / CIE_Y_INTEGRAL;\n    \n    xyz.x = CIE_X[_l]*D65;\n    xyz.y = CIE_Y[_l]*D65;\n    xyz.z = CIE_Z[_l]*D65;\n#endif\n    return xyz;\n}\n\nvec3 SPEC_to_XYZ(float spec[LAMBDA_SAMPLES], float l[LAMBDA_SAMPLES])\n{\n    vec3 XYZ;\n    for (int i = 0; i < LAMBDA_SAMPLES; i++) {\n        vec3 cmf = CMF_to_XYZ(l[i]);\n        XYZ += cmf * spec[i];\n    }\n    return XYZ * SCALE;\n}\nvec3 SPEC_to_sRGB(float spec[LAMBDA_SAMPLES], float l[LAMBDA_SAMPLES])\n{\n    return clamp(XYZ_to_sRGB(SPEC_to_XYZ(spec, l)), vec3(0.0), vec3(1.0));\n}\nvec3 SPEC_to_sRGB(float l)\n{\n    return clamp(XYZ_to_sRGB(CMF_to_XYZ(l)), vec3(0.0), vec3(1.0));\n}\n\n/* Fast RGB-to-Spectrum Conversion by Scott Burns */\n/* http://scottburns.us/fast-rgb-to-spectrum-conversion-for-reflectances/ */\nfloat sRGB_to_SPEC(vec3 rgb, float l)\n{\n    vec3 opt;\n#ifdef FIT\n    opt.x = (l > 560.0) ? sigmoidal(l, 0.0144, 135.0296, 590.4639, 0.9761) : sigmoidal(l, 0.0289, 38.6766, 454.7233, 0.0062);\n    opt.y = (l < 545.0) ? sigmoidal(l, 0.0123, 63.3450, 488.7451, 0.9711) : sigmoidal(l, 0.0127, -116.3503, 590.4987, 0.9699);\n    opt.z = (l < 500.0) ? sigmoidal(l, 0.9622, -0.1542, 489.6339) : sigmoidal(l, 0.0122, -37.0407, 405.3482, 344.2237);\n#else\n    int _l = int((round(l) - float(CIE_MIN)) / CIE_STEP);\n    opt.x = CIE_OPTIMAL_R[_l];\n    opt.y = CIE_OPTIMAL_G[_l];\n    opt.z = CIE_OPTIMAL_B[_l];\n#endif\n    return dot(rgb, opt);\n}\n\nvec3 Linear_to_sRGB(vec3 x)\n{\n  return mix(x*12.92, 1.055 * pow(x, vec3(0.41667)) - 0.055, step(0.0031308, x));\n}\nvec3 sRGB_to_Linear(vec3 x)\n{\n    return mix(x / 12.92, pow((x+0.055)/1.055,vec3(2.4)), step(0.04045, x));\n}\n\n//#define HERO\nvoid gen_lambda_samples(vec3 p, out float l[LAMBDA_SAMPLES])\n{\n#ifdef HERO\n    float lambda_r = float(LAMBDA_MAX - LAMBDA_MIN);\n    float lambda_h = rand_range(LAMBDA_MIN, LAMBDA_MAX, p);\n    for(int i = 0; i < LAMBDA_SAMPLES; i++) {\n        float x = (lambda_h - float(LAMBDA_MIN) + (float(i) / float(LAMBDA_SAMPLES)) * lambda_r);\n        l[i] = mod(x, lambda_r) + float(LAMBDA_MIN);\n    }\n#else\n    for (int i = 0; i < LAMBDA_SAMPLES; i++) {\n        l[i] = (float(LAMBDA_MIN) + (float(i) * LAMBDA_STEP));\n    }\n#endif\n}","name":"Common","description":"","type":"common"}]}