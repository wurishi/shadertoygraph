{"ver":"0.1","info":{"id":"mtBfDW","date":"1695945918","viewed":29,"name":"My Moon","username":"jaafarodgers","description":"a moon","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["baicmoon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI acos(0.)*2.\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec2 CoordsFromUV(vec2 uv)\n{\n    // remaps the uv to a coordinate system from -1 to 1\n    vec2 coords = (uv - 0.5) * 2.;\n    // remaps coordinates to [-2,2]\n    coords *= 2.;\n    // remap coordinates to reflect aspect ratio (now the coords [-2,2] are square, not skewed in a rectangle)\n    coords *= vec2(1., iResolution.y/iResolution.x);\n    \n    return coords;\n}\n\nfloat AlphaRange(float time, float minimum, float maximum, float frequency)\n{\n    return minimum + 0.5*(maximum - minimum) * (1. + cos(time * 2.*PI * frequency));\n}\n\nvec3 AverageColor(vec3 col)\n{\n    return vec3((col.x + col.y + col.z) / 3.);\n}\n\nfloat TorusMask(vec2 coords, float innerRadius, float outerRadius)\n{\n    return (length(coords) > innerRadius && length(coords) < outerRadius) ? 1.0 : 0.0;\n}\n\nvec3 MoonRainbow(vec2 coords, float alpha)\n{\n    return TorusMask(coords, .75, .9) * hsv2rgb(vec3(length(coords)*6.6, .4, 1.0)) * alpha;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Naming convention\n    //    Gradient: mathematical result that represents a blend, used by modifying it to create masks\n    //    Mask:     artistic/creative masking, used by multiplying\n    //    Color:    rgb colors, used by adding them together (most of the time)\n    float time = iTime * 0.1;\n\n    vec2 mouse = iMouse.xy/iResolution.xy; // normalized mouse coords [0,1]\n    vec2 uv = fragCoord/iResolution.xy;  // Normalized pixel coordinates (from 0 to 1)\n    \n    float animationTime = time * 0.1;\n    //uv += vec2(cos(animationTime),sin(animationTime)*3.+3.);\n    \n    \n    vec2 coords = CoordsFromUV(uv);\n    float radius = 0.5;\n    float timeAlpha = AlphaRange(time, 0., 1., 1.);\n    float radialGradient = length(coords / radius);\n    float radialMask = (radialGradient < 1.0) ? 1.0 : 0.0;\n    \n    float softEdgeMask = 1.0-pow(radialGradient, 40.);\n    \n    float shiftGradient = 0.1;\n    float moonRightHalfGradient = sqrt((radius*radius)-(coords.y*coords.y))-coords.x;\n    float moonLeftHalfGradient = -sqrt((radius*radius)-(coords.y*coords.y))-coords.x;\n    float moonPhaseGradient = mix(moonRightHalfGradient + shiftGradient, moonLeftHalfGradient, timeAlpha);\n    \n    float moonPhaseBlend = moonPhaseGradient * 6.;\n    float moonPhaseBlendMask = clamp(moonPhaseBlend, 0., 1.);\n    float moonMask = moonPhaseBlendMask * radialMask;\n    \n    // Create Moon color\n    vec3 col = AverageColor(texture(iChannel0, uv).xyz);\n    col *= moonMask * softEdgeMask;\n    col += MoonRainbow(coords, AlphaRange(time, .5, -.5, 1.));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n    //fragColor = vec4(vec3(softEdgeMask),1);\n    //fragColor = vec4(MoonRainbow(coords),1);\n}","name":"Image","description":"","type":"image"}]}