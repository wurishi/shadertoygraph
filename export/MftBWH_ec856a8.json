{"ver":"0.1","info":{"id":"MftBWH","date":"1733060421","viewed":17,"name":"Shader Advent Day-24 #1","username":"mrange","description":"// CC0: Shader Advent reflection shader example #1","likes":0,"published":3,"flags":0,"usePreview":0,"tags":["3d","shader","advent"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// CC0: Shader Advent reflection shader example #1\n\n// Macro definitions for built-in Shadertoy inputs\n#define TIME        iTime        // Current time in seconds since shader start\n#define RESOLUTION  iResolution  // Viewport resolution (width, height, 1)\n// 2D rotation matrix creation macro - creates a rotation matrix for 2D transformations\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// Material optical properties\nconst float refr_index = 0.8;    // Refractive index - determines how much light bends\n                                 // when passing through the material (< 1 means light\n                                 // bends less than in typical materials)\n\n// Mathematical and visual constants\nconst float pi      = acos(-1.);        // More precise way to define pi using arccos\nconst float tau     = 2.*pi;            // Full circle rotation (2π)\nconst float upSat   = 1.2;              // Saturation boost for color intensity\nconst float phi     = (sqrt(5.)+1.)/2.; // Golden ratio - aesthetically pleasing proportion\nconst float beerHue = 0.9;              // Hue value for coloration (Beer's law)\n\n// Global rotation matrix for dynamically rotating internal objects\nmat3 g_rot;\n\n// Ray marching configuration for internal object rendering\n// Ray marching is a technique to visualize 3D surfaces by stepping along a ray\nconst int   maxRayMarchesInsides   = 50;   // Maximum number of steps to find surface\n                                           // (prevents infinite loops)\nconst float toleranceInsides       = .001; // Minimum distance to consider a surface hit\nconst float normalEpisolonInsides  = 0.001;// Small offset for calculating surface normals\nconst int   maxBouncesInsides      = 5;    // Limit on light bounces/reflections inside object\nfloat g_glowDistanceInsides;               // Tracking glow effect distance\n\n// Ray marching settings for external box rendering\nconst int   maxRayMarchesShapes = 70;      // More steps for complex external surfaces\nconst float toleranceShapes     = .001;    // Minimum distance to surface hit\nconst float maxRayLengthShapes  = 20.;     // Maximum ray travel distance to prevent\n                                           // unnecessary computation\nconst float normalEpisolonShapes= 0.01;    // Slightly larger normal calculation precision\nfloat g_glowDistanceShapes;                // Tracking glow effect for external box\n\n// Scene composition parameters\nconst vec3 sunDir    = normalize(vec3(1.0));    // Directional light source\nconst vec3  boxDim   = vec3(1., phi*phi, phi);  // Box dimensions using golden ratio\n                                                // for aesthetically pleasing proportions\nconst float boxEdge  = 0.005;                   // Thickness of box's frame/outline\nconst float bottom   = -boxDim.y-0.033;         // Ground level, slightly below the box\n\nconst vec3 rayOrigin = normalize(vec3(0.0, 3.0, -5.))*8.; // Camera position\nconst vec3 lookAt    = vec3(0.0, 0.5*bottom, 0.0);        // Define a \"look-at\" point, where the camera is focusing\n\n// Approximate HSV to RGB conversion by XorDev\n// Creates smoother, more visually appealing color transitions compared to standard conversion\n// License: Unknown, author: XorDev, found: https://x.com/XorDev/status/1808902860677001297\nvec3 hsv2rgb_approx(vec3 hsv) {\n  // Trigonometric color transformation\n  // Uses cosine waves with offset to create non-linear color transitions\n  return (cos(hsv.x*tau+vec3(0.,4.,2.))*hsv.y+2.-hsv.y)*hsv.z/2.;\n}\n#define  HSV2RGB_APPROX(hsv) ((cos(hsv.x*tau+vec3(0.,4.,2.))*upSat*hsv.y+2.-upSat*hsv.y)*hsv.z/2.)\n\n// ACES Filmic Tone Mapping Approximation\n// Compresses high dynamic range images to display on standard screens\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  // Ensure no negative values\n  v = max(v, 0.0);\n\n  // Reduce overall intensity\n  v *= 0.6;\n\n  float a = 2.51;\n  float b = 0.03;\n  float c = 2.43;\n  float d = 0.59;\n  float e = 0.14;\n\n  // Apply tone mapping and clamp to valid color range\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0, 1.0);\n}\n\n// \"Fancy\" animated rotation matrix\n// Generates a time-dependent rotation matrix for dynamic effects\n// I got it from Chat AI so likely \"borrowed\" from shadertoy.\nmat3 animatedRotationMatrix(float time) {\n  // Define three independent angles for rotation over time\n  float angle1 = time * 0.5;       // Primary rotation (slower)\n  float angle2 = time * 0.707;     // Secondary rotation (based on √2 for variety)\n  float angle3 = time * 0.33;      // Tertiary rotation (even slower)\n\n  // Precompute trigonometric values for efficiency\n  float c1 = cos(angle1); float s1 = sin(angle1);\n  float c2 = cos(angle2); float s2 = sin(angle2);\n  float c3 = cos(angle3); float s3 = sin(angle3);\n\n  // Construct a 3x3 rotation matrix\n  // Combines rotations across multiple axes with varying speeds\n  // Rows represent the transformed basis vectors\n  return mat3(\n      c1 * c2,                // X-axis scaling with first two rotations\n      c1 * s2 * s3 - c3 * s1, // Y-axis rotation and scaling\n      s1 * s3 + c1 * c3 * s2, // Z-axis interaction with all three rotations\n\n      c2 * s1,                // X-axis influenced by secondary and tertiary rotations\n      c1 * c3 + s1 * s2 * s3, // Y-axis affected by all three angles\n      c3 * s1 * s2 - c1 * s3, // Z-axis with secondary and tertiary dependencies\n\n      -s2,                   // X-axis negation for secondary rotation\n      c2 * s3,               // Y-axis scaling for secondary and tertiary rotations\n      c2 * c3                // Z-axis scaling for the primary and secondary angles\n  );\n}\n\n// Soft minimum - smoothly interpolates between two values\n// Creates a smooth blend instead of a hard transition\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// Soft maximum - complementary to soft minimum\nfloat pmax(float a, float b, float k) {\n  // Implemented by negating soft minimum\n  return -pmin(-a, -b, k);\n}\n\n// 2D box distance function - calculates signed distance to a 2D box\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions/\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// 3D box distance function - calculates signed distance to a 3D box\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions/\nfloat box(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// Torus distance function - calculates distance to a donut-shaped object\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions/\nfloat torus(vec3 p, vec2 t) {\n  // Computes distance from point to torus surface\n  // t.x is ring radius, t.y is tube radius\n  vec2 q = vec2(length(p.xz)-t.x, p.y);\n  return length(q)-t.y;\n}\n\n// Box frame distance function - calculates distance to a wireframe box\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions/\nfloat boxFrame(vec3 p, vec3 b, float e) {\n  p = abs(p)-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n// \"Super\" sphere - a boxy looking \"sphere\". Has nice normals\nfloat ssphere4(vec3 p, float r) {\n  p *= p;\n  return pow(dot(p, p), 0.25)-r;\n}\n\n// Render the surrounding world environment\n// Responsible for creating the background scene including sky and ground plane\nvec3 renderWorld(vec3 ro, vec3 rd) {\n  vec3 col = vec3(0.0);\n\n  // Calculate distance to floor plane using ray-plane intersection\n  // Uses ray origin (ro) and ray direction (rd) to compute intersection point\n  float bt = -(ro.y-bottom)/(rd.y);\n\n  // Generate sky color using HSV approximation\n  // Color varies based on ray direction (up/down angle)\n  // - Hue is fixed at blue-cyan (0.6)\n  // - Saturation depends on vertical ray angle\n  // - Brightness uses a quadratic falloff to create gradient effect\n  col = hsv2rgb_approx(vec3(\n    0.6,                                // Fixed hue for sky color\n    clamp(0.3+0.9*rd.y, 0.0, 1.0),      // Saturation varies with vertical angle\n    1.5*clamp(2.0-2.*rd.y*rd.y, 0.0, 2.) // Brightness with non-linear falloff\n  ));\n\n  // If ray intersects ground plane, render ground details\n  if (bt > 0.) {\n    // Compute intersection point on ground plane\n    vec3 bp = ro + rd*bt;\n    vec2 bpp = bp.xz;\n\n    // Create grid coordinate system\n    // Round coordinates to snap to grid points\n    vec2 npp = round(bpp);\n    vec2 cpp = bpp - npp;\n    vec2 app = abs(cpp);\n\n    // Grid line distance field with view-angle compensation\n    // Reduces aliasing by adjusting line width based on view angle\n    float gfre = 1.+rd.y;\n    gfre *= gfre;\n    gfre *= gfre;\n\n    // Compute grid line distance\n    // Dynamically adjusts line width based on view angle to reduce aliasing\n    float gd = min(app.x, app.y) - mix(0.01, 0.0, gfre);\n\n    // Ground base color using HSV approximation macro\n    // Soft grayish tone with slight warmth\n    const vec3 bbcol = HSV2RGB_APPROX(vec3(0.7, 0.2, 1.25));\n\n    // Distance-based fade effect\n    // Reduces ground detail and brightness at far distances\n    float bfade = mix(1., 0.2, exp(-0.3*max(bt-15., 0.)));\n\n    // Anti-aliasing width adjustment\n    float aa = mix(0.0, 0.08, bfade);\n\n    // Blend ground color with fading and grid line effects\n    // Creates soft, slightly faded grid appearance\n    vec3 bcol = mix(bbcol, bbcol*bfade, smoothstep(aa, -aa, gd));\n\n    // Blend ground with sky, creating distance fog effect\n    col = mix(col, bcol, exp(-0.008*bt));\n  }\n\n  return col;\n}\n\n\nvec3 effect(vec2 p, vec2 pp) {\n  // Set the starting point of the ray in 3D space\n  vec3 ro = rayOrigin;\n\n  // Define the \"up\" direction, used for camera orientation\n  const vec3 up = vec3(0.0, 1.0, 0.0);\n\n  // Apply a slight rotation to the ray origin for dynamic effects\n  ro.xz *= ROT(0.1 * TIME);\n\n  // Compute a time-based rotation matrix for animating objects\n  g_rot = animatedRotationMatrix(0.707 * TIME);\n\n  // Set up the ray direction using a \"look-at\" camera model\n  // Normalize the direction from the ray origin to the look-at point\n  vec3 ww = normalize(lookAt - ro);\n\n  // Compute the right vector by crossing the up vector with the direction\n  vec3 uu = normalize(cross(up, ww));\n\n  // Compute the true \"up\" vector (orthogonal to both ww and uu)\n  vec3 vv = cross(ww, uu);\n\n  // Define the field of view (FOV); larger values mean a wider view\n  const float fov = 2.0;\n\n  // Compute the ray direction for this pixel\n  // Combine the perspective (FOV) and the camera's orientation\n  vec3 rd = normalize(-p.x * uu + p.y * vv + fov * ww);\n\n  // Initialize the color accumulator\n  vec3 col = vec3(0.0);\n\n  // Render the scene by tracing the ray (ro: origin, rd: direction)\n  col = renderWorld(ro, rd);\n\n  // Saturate the colors a bit\n  col -= 0.03 * vec3(2.0, 3.0, 1.0) * (length(p) + 0.25);\n\n  // Apply a vignette effect to darken edges of the screen\n  col *= smoothstep(1.7, 0.8, length(pp));\n\n  // Tone map the color from high dynamic range (HDR) to standard [0,1] range\n  col = aces_approx(col);\n\n  // Simulate a gamma correction for RGB to sRGB conversion\n  col = sqrt(col);\n\n  // Return the final color\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  // Normalize fragment coordinates to a [0,1] range\n  vec2 q = fragCoord / RESOLUTION.xy;\n\n  // Map coordinates to a [-1,1] range for ray tracing\n  vec2 p = -1.0 + 2.0 * q;\n\n  // Keep a copy of the original coordinates for effects like vignette\n  vec2 pp = p;\n\n  // Correct the aspect ratio of the coordinates\n  p.x *= RESOLUTION.x / RESOLUTION.y;\n\n  // Initialize the final color\n  vec3 col = vec3(0.0);\n\n  // Compute the color for this fragment using the effect function\n  col = effect(p, pp);\n\n  // Output the final color with full alpha (1.0)\n  fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}