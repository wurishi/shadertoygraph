{"ver":"0.1","info":{"id":"fdtSD4","date":"1633167765","viewed":144,"name":"Fork Odd-even h esnho 731","username":"esnho","description":"This shader is an illustration for an article I wrote about Pixel sorting using a vector field:\nhttps://ciphered.xyz/2020/04/08/pixel-sorting-on-shader-using-well-crafted-sorting-filters-glsl/","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["pixel","sort","sorting","odd","even"],"hasliked":0,"parentid":"wsSczw","parentname":"Odd-even horizontal pixel sort"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// @author ciphrd <https://instagram.com/ciphrd>\n//\n// This shader is used as an illustration for an article I wrote about \n// Pixel sorting using a vector field:\n// https://ciphered.xyz/2020/04/08/pixel-sorting-on-shader-using-well-crafted-sorting-filters-glsl/\n//\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// @author ciphrd <https://instagram.com/ciphrd>\n// @license MIT\n// \n// This shader is used as an example for an article I wrote about \"Pixel sorting using a well-crafted vector field\".\n// Everything is explained in the article if you're looking for explanations.\n//\n// https://ciphered.xyz/2020/04/08/pixel-sorting-on-shader-using-well-crafted-sorting-filters-glsl/\n//\n\n#define THRESHOLD 0.22\n\n\n\n// grayscale average of the colors\nfloat gscale (vec3 c) { return (c.r+c.g+c.b)/3.; }\n\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n\t// uvs\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\tif (iFrame < 60) {\n\t\tfragColor = texture(iChannel0, uv);\n\t\treturn;\n\t}\n\t\n\t\n\t// the frame number parity, -1 is odd 1 is even\n\tfloat fParity = mod(float(iFrame), 2.) * 2. - 1.;\n    \n    // we differentiate every 1/2 pixel on the horizontal axis, will be -1 or 1\n    float vp = mod(floor(uv.x * iResolution.x), 2.0) * 2. - 1.;\n    \n    \n\tvec2 dir = vec2(1, 0);\n    dir*= fParity * vp;\n\tdir/= iResolution.xy;\n\n\t// we sort\n    vec4 inputt = texture(iChannel0, uv); // fork edit\n\tvec4 curr = texture(iChannel1, uv);\n\tvec4 comp = texture(iChannel1, uv + dir);\n\t\n\tfloat gInputt = gscale(inputt.rgb); // fork edit\n\tfloat gCurr = gscale(curr.rgb);\n\tfloat gComp = gscale(comp.rgb);\n    \n    // my fork is about find a nice fx on realtime input\n    curr = mix(curr, inputt, step(sin(iTime), 1.0 - gInputt));\n    // curr = mix(curr, inputt, 2.0);\n    // curr = mix(curr, inputt, min(float(iFrame % 2), 1.0));\n    // curr = mix(curr, inputt, min(float(iFrame % 5), 1.0));\n    // curr = mix(inputt, curr, min(float(iFrame % 50), 1.0));\n\t\n    // compute gCurr again if we modify the curr data\n\tgCurr = gscale(curr.rgb);\n\t\n\t// we prevent the sort from happening on the borders\n\tif (uv.x + dir.x < 0.0 || uv.x + dir.x > 1.0) {\n\t\tfragColor = curr;\n\t\treturn;\n\t}\n\t\n\t// the direction of the displacement defines the order of the comparaison \n\tif (dir.x < 0.0) {\n\t\tif (gCurr > THRESHOLD && gComp > gCurr) {\n\t\t\tfragColor = comp;\n\t\t} else {\n\t\t\tfragColor = curr;\n\t\t}\n\t} \n\telse {\n\t\tif (gComp > THRESHOLD && gCurr >= gComp) {\n\t\t\tfragColor = comp;\n\t\t} else {\n\t\t\tfragColor = curr;\n\t\t}\n\t}\n}\n","name":"Buffer A","description":"","type":"buffer"}]}