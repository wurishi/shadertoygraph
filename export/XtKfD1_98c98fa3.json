{"ver":"0.1","info":{"id":"XtKfD1","date":"1544118057","viewed":103,"name":"lab10 - cg","username":"qzhang93","description":"ray marching","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["lab"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SPHERE 0\n#define PLANE 1\n#define NO_INTERSECT 2\n#define DISPLACEMENT_FACTOR 0.1\n\n// Data structure for raymarching results\nstruct PrimitiveDist {\n    float dist;\n    int primitive; // Can be SPHERE, PLANE, or NO_INTERSECT\n};\n\n// Helper function for tri3.\nfloat tri(in float x) {\n\treturn abs(fract(x)-.5);\n}\n\n// Triangle noise. Use it as a sample displacement map for task 7.\nvec3 tri3(in vec3 p) {\n    return vec3(tri(p.z+tri(p.y*1.)), \n                tri(p.z+tri(p.x*1.)), \n                tri(p.y+tri(p.x*1.)));\n}\n\n// TODO [Task 8] Make a displacement map\n// You can check out tri3 above and the functions in the handout as inspiration\nfloat calcDisplacement(in vec3 p) {\n    return pow(sin(p.x) + cos(p.y), 2.0);\n}\n\n// TODO [Task 6] Implement triplanar texture mapping\n// If you want, you can play around with the textures in iChannels 0 and 1\n// The textures should show no distortion\nvec3 texCube( sampler2D sam, in vec3 p, in vec3 n )\n{\n    p = vec3(p.x/10.0, p.y/10.0, p.z/10.0);\n    vec4 xtex = texture(sam, p.yz);\n    vec4 ytex = texture(sam, p.xz);\n    vec4 ztex = texture(sam, p.xy);\n    return xtex.rgb * abs(n.x) +  ytex.rgb * abs(n.y) + ztex.rgb * abs(n.z);\n}\n\n// Signed distance to the twisted sphere.\nfloat sdTwistedSphere(vec3 p) {\n    vec3 spherePosition = vec3(0.0, 0.25, 0.0);\n    float radius = 1.5;\n    float primitive = length(p - spherePosition) - radius;\n    return primitive + calcDisplacement(p);\n}\n\nfloat sdFloor(vec3 p) {\n    return p.y;\n}\n\nPrimitiveDist map(vec3 p) {\n    // TODO [Task 3] Implement distance map\n    float closest = min(sdFloor(p), sdTwistedSphere(p));\n    float planeDist = sdFloor(p);\n    float sphereDist = sdTwistedSphere(p);\n    if (planeDist < sphereDist) {\n    \treturn PrimitiveDist(planeDist, PLANE);\n    } else {\n        return PrimitiveDist(sphereDist, SPHERE); \n    }\n}\n\n// TODO [Task 4] Calculate surface normals\nconst float epsilon = 0.001;\nvec2 e = vec2(epsilon, 0.0); // For swizzling\nvec3 calcNormal(vec3 p) {\n    vec3 normal = vec3(map(p + e.xyy).dist - map(p - e.xyy).dist, \n                       map(p + e.yxy).dist - map(p - e.yxy).dist, \n                       map(p + e.yyx).dist - map(p - e.yyx).dist);\n    return normalize(normal);\n}\n\nfloat shadow(vec3 ro, vec3 rd, float k) {\n    float marchDist = 0.001;\n    float boundingVolume = 25.0;\n    float darkness = 1.0;\n    float threshold = 0.001;\n    \n    for(int i = 0; i < 30; i++) {\n        if(marchDist > boundingVolume) continue;\n        float h = map(ro + rd * marchDist).dist;\n        // TODO [Task 7] Modify the loop to implement soft shadows\n        //if (h < threshold) {\n            darkness = min(darkness, k*h/marchDist);\n        //    break;\n        //}\n        marchDist += h * 0.7;\n    }\n    \n    return darkness;\n}\n\n\nPrimitiveDist raymarch(vec3 ro, vec3 rd) {\n    \n    // TODO [Task 2] Implement ray marching algorithm\n    // Fill in parameters\n    float marchDist = 0.001;\n    float boundingDist = 50.0;\n    float threshold = 0.001;\n    \n    // Fill in the iteration count\n    for (int i = 0; i < 1000; i++) {\n        // Fill in loop body\n        PrimitiveDist currentDist = map(ro + marchDist * rd);\n        marchDist += 0.1 * currentDist.dist;\n        \n        if (currentDist.dist < threshold) {\n            return PrimitiveDist(marchDist, currentDist.primitive);\n        }\n        if (marchDist > boundingDist) {\n        \tbreak;\n        }\n    }    \n    return PrimitiveDist(-1.0, NO_INTERSECT);\n}\n\nvec3 render(vec3 ro, vec3 rd, float t, int which) {\n    \n    // Col is the final color of the current pixel.\n    vec3 col = vec3(0.);\n    vec3 pos = ro + rd * t;\n    // Light vector\n    vec3 lig = normalize(vec3(1.0,0.6,0.5));\n    \n    // Normal vector\n    vec3 nor = calcNormal(pos);\n    \n    // Ambient\n    float ambient = 0.1;\n    // Diffuse\n    float diffuse = clamp(dot(nor, lig), 0.0, 1.0);\n    // Specular\n    float shineness = 32.0; \n    float specular = pow(clamp(dot(rd, reflect(lig, nor)), 0.0, 1.0), 32.0);\n    \n    float darkness = shadow(pos, lig, 18.0);\n    // Applying the phong lighting model to the pixel.\n    col += vec3(((ambient + diffuse + specular) * darkness));\n    \n    // TODO [Task 5] Assign different intersected objects with different materials\n    // Make things pretty!\n    vec3 material = vec3(0.0);\n    if (which == PLANE) {\n        material = texCube(iChannel0, pos, nor);\n    } else if (which == SPHERE) {\n        material = texCube(iChannel1, pos, nor);\n    } else {\n        material = vec3(0.5);\n    }\n    \n    // Blend the material color with the original color.\n    col = mix(col, material, 0.8);\n    \n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n   \n    vec3 rayOrigin = vec3(6.0 * sin(iTime * .3), 4.8, 6.0 * cos(iTime * .3));\n    \n    float focalLength = 2.0;\n    \n    // The target we are looking at\n    vec3 target = vec3(0.0);\n    // Look vector\n    vec3 look = normalize(rayOrigin - target);\n    // Up vector\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    \n    // Set up camera matrix\n    vec3 cameraForward = -look;\n    vec3 cameraRight = normalize(cross(cameraForward, up));\n    vec3 cameraUp = normalize(cross(cameraRight, cameraForward)); \n  \n    // TODO [Task 1] Construct the ray direction vector\n    vec2 uv = vec2(fragCoord.x/iResolution.x*2.0 - 1.0, -1.0 + fragCoord.y/iResolution.y*2.0);\n    uv.x = uv.x * iResolution.x/iResolution.y;\n    vec3 rayDirection = vec3(uv.x, uv.y, focalLength);\n    rayDirection = cameraRight * rayDirection.x + cameraUp * rayDirection.y + cameraForward * rayDirection.z;\n    rayDirection = normalize(rayDirection);\n    \n      \n    PrimitiveDist rayMarchResult = raymarch(rayOrigin, rayDirection);\n    vec3 col = vec3(0.0);\n    if (rayMarchResult.primitive != NO_INTERSECT) {\n      col = render(rayOrigin, rayDirection, rayMarchResult.dist, rayMarchResult.primitive);\n    }\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}