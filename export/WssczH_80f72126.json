{"ver":"0.1","info":{"id":"WssczH","date":"1584159239","viewed":60,"name":"Dist Texture Test","username":"cowsed","description":"A test for multiple distance textures. soon to e expanded into 3d and support holes","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["texture","distance"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159\n#define tau 2.*PI\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float h=iResolution.x/iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x*=h;\n\t//uv.x+=1.9;\n    //uv.y+=2.5;\n    //uv/=5.8;\n    \n    vec3 col;\n    vec2 pos=vec2(1.2,.5);\n    float radius=.3;\n    \n    float d=length(uv-pos);\n    float r=d-radius;//clamp(d,-99990.,radius);\n    float a=.5+atan(uv.x-pos.x,-(uv.y-pos.y))/(tau);    //a is normalized so that it can be used in an image\n\td+=radius*texture(iChannel0,vec2(a,r)).x;\n    \n    vec2 pos1=(iMouse.xy/iResolution.xy)*vec2(h,1.);//vec2(.65,.5);\n    float radius1=.1;\n    float d1=length(uv-pos1);\n    float r1=d1-radius1;\n    float a1=.5+atan(uv.x-pos1.x,-(uv.y-pos1.y))/(tau);    //a is normalized so that it can be used in an image\n\td1+=radius1*texture(iChannel1,vec2(a1,r1)).x;\n\n    vec2 pos2=vec2(.4,.5);//vec2(.65,.5);\n    float radius2=.4;\n    float d2=length(uv-pos2);\n    float r2=d2-radius2;\n    float a2=.5+atan(uv.x-pos2.x,-(uv.y-pos2.y))/(tau);    //a is normalized so that it can be used in an image\n\td2+=radius2*texture(iChannel2,vec2(a2,r2)).x;\n\t//get the negatives working to have holez\n    d1-=.0;\n    \n    d=min(min(d,d1),d2);\n    \n    // Output to screen\n    col=vec3(d);\n    //if(col.x<=0.){col.r=1.;} else{col.b=1.;}\n\tcol=(col);//,vec3(0.));\n\n    //col = texture(iChannel2,fragCoord.xy/iResolution.xy).xyz+1.;\n    //if(col.x<=0.){col.r=1.;} else{col.b=1.;}\n\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define PI 3.14159\n#define tau 2.*PI\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float h=iResolution.x/iResolution.y;\n    vec2 a = fragCoord/iResolution.xy;\n\n    float radius,theta;\n    radius=a.y;\n    theta=a.x*tau;\n    float r=radius;\n   \n    fragColor = vec4(vec3(r)-.5,1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\n#define PI 3.14159\n#define tau 2.*PI\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float h=iResolution.x/iResolution.y;\n    vec2 a = fragCoord/iResolution.xy;\n    \n\n    float radius,theta;\n    radius=a.y;\n    theta=a.x*tau*6.64;\n    \n    \n    //Fourier transform with lists\n    \n    //This isnt quite right  but hey this part works\n    const int epicycles=2;\n    float ds[epicycles]=float[epicycles](.9/PI,-1.0/PI);\n     float s[epicycles]=float[epicycles](.8,.05);\n     float stang[epicycles]=float[epicycles](45.,45.);\n        \n    float x=0.0;\n    float y=0.0;\n    \n\n    for (int i=0; i<epicycles; i++){\n    \tx+=sin(ds[i]*theta+degrees(stang[i]))*s[i];\n    \n    \ty+=cos(ds[i]*theta+degrees(stang[i]))*s[i];\n    }\n\n    //take max of all points at theta\n    //after going through multiple this makes things hard tho bc therre are multiple times that the same theta happen\n    \n    float d=length(vec2(x,y));\n    \n    fragColor = vec4(vec3(d-1.5)*.8,1.0);\n}\n\n\n/*\n\n#define PI 3.14159\n#define tau 2.*PI\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float h=iResolution.x/iResolution.y;\n    vec2 a = fragCoord/iResolution.xy;\n\n    float radius,theta;\n    radius=a.y;\n    theta=a.x*tau;\n    float r=radius;\n\t\n\tr=abs(a.y-.5);    \n\tr*=2.;\n    r-=.5;\n    fragColor = vec4(vec3(r),1.0);\n}\n*/","name":"Buffer C","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.14159\n#define tau 2.*PI\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float h=iResolution.x/iResolution.y;\n    vec2 a = fragCoord/iResolution.xy;\n\n    float radius,theta;\n    radius=a.y;\n    theta=a.x*tau;\n    float r=radius;\n    \n    \n    //r=abs(r*2.-1.);\n    \n    fragColor = vec4(vec3(r)-.5,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}