{"ver":"0.1","info":{"id":"tldcDl","date":"1610271459","viewed":165,"name":"Cloud Boze 2","username":"kaiware007","description":"Cloud Boze 2\n\nold : https://www.shadertoy.com/view/ttfyz4","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raycasting","fbm","cloud"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ------------------------------------------------------------------------------------\n// Original \"thinking...\" created by kaneta : https://www.shadertoy.com/view/wslSRr\n// Original Character By MikkaBouzu : https://twitter.com/mikkabouzu777\n// ------------------------------------------------------------------------------------\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n\n#define MAX_DIST 100.\n#define M_HALFPI 1.5707963\n#define M_PI 3.1415926\n#define M_PI2 M_PI*2.0\n\n#define M_PI03 1.04719\n#define M_PI06 2.09439\n\n#define MAT_BLACK 1.0\n#define MAT_FACE 2.0\n#define MAT_BROW 3.0\n#define MAT_CHEEP 4.0\n#define MAT_SPHERE 5.0\n#define MAT_BG 6.0\n#define MAT_CS 7.0\n\nvec3 sinebow(float h) {\n    vec3 r = sin((.5-h)*M_PI + vec3(0,M_PI03,M_PI06));\n    return r*r;\n}\n\nfloat rand(vec2 st)\n{\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 10000.0);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise(vec3 st)\n{\n\tvec3 ip = floor(st);\n    vec3 fp = smoothstep(vec3(0.), vec3(1.), fract(st));\n    \n\tvec4 a = vec4(hash13(ip+vec3(0.)),hash13(ip+vec3(1.,0.,0.)),hash13(ip+vec3(0.,1.,0.)),hash13(ip+vec3(1.,1.,0.)));\n    vec4 b = vec4(hash13(ip+vec3(0.,0.,1.)),hash13(ip+vec3(1.,0.,1.)),hash13(ip+vec3(0.,1.,1.)),hash13(ip+vec3(1.,1.,1.)));\n    \n\ta = mix(a, b, fp.z);\n\ta.xy = mix(a.xy, a.zw, fp.y);\n    \n\treturn mix(a.x, a.y, fp.x);\n}\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p );\n    return f;\n}\n\nfloat easeInOutQuad(float t) {\n    if ((t *= 2.0) < 1.0) {\n        return 0.5 * t * t;\n    } else {\n        return -0.5 * ((t - 1.0) * (t - 3.0) - 1.0);\n    }\n}\n\n// Distance functions by iq\n// https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdRoundBox(vec3 p, vec3 size, float r)\n{\n    return length(max(abs(p) - size * 0.5, 0.0)) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - r;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n// Union, Subtraction, SmoothUnion (distance, Material) \nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 opS( vec2 d1, vec2 d2 )\n{ \n    return (-d1.x>d2.x) ? vec2(-d1.x, d1.y): d2;\n}\n\nvec2 opSU( vec2 d1, vec2 d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.x-d1.x)/k, 0.0, 1.0 );\n    return vec2(mix( d2.x, d1.x, h ) - k*h*(1.0-h), h > 0.5 ? d1.y : d2.y); }\n\nvec2 opI( vec2 d1, vec2 d2 )\n{ \n    //return (d1.x>d2.x) ? d1: vec2(d2.x, d1.y);\n    return (d1.x>d2.x) ? d1: d2;\n}\n\n// Union, Subtraction, SmoothUnion (distance only)\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\nvec3 rotate(vec3 p, float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nvec3 opTwist(in vec3 p, float k )\n{\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return vec3(q.x, q.y, q.z);\n}\n\nvec3 TwistY(vec3 p, float power)\n{\n    float s = sin(power * p.y);\n    float c = cos(power * p.y);\n    mat3 m = mat3(\n          c, 0.0,  -s,\n        0.0, 1.0, 0.0,\n          s, 0.0,   c\n    );\n    return m*p;\n}\n\nfloat ease_cubic_out(float p)\n{\n\tfloat f = (p - 1.0);\n\treturn f * f * f + 1.0;\n}\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\nvec2 opRep2D( in vec2 p, in vec2 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\n// 線分と無限平面の衝突位置算出\n// rayPos : レイの開始地点\n// rayDir : レイの向き\n// planePos : 平面の座標\n// planeNormal : 平面の法線\nfloat GetIntersectLength(vec3 rayPos, vec3 rayDir, vec3 planePos, vec3 planeNormal)\n{\n    return dot(planePos - rayPos, planeNormal) / dot(rayDir, planeNormal);\n}\n\nfloat IsHitSphere(vec3 ro, vec3 rd, vec3 sphereCenter, float radius) {\n    vec3 diff = ro - sphereCenter;\n    float xc2 = dot(diff, diff);\n    float vxc = dot(rd, diff);\n    float sq = radius * radius;\n    return vxc * vxc - xc2 + sq; \n}\n\nfloat GetIntersectSphere(vec3 rayPos, vec3 rayDir, vec3 sphereCenter, float radius) {\n    float a = length(rayDir);\n    float a2 = a * a;\n    vec3 diff = rayPos - sphereCenter;\n    float b = dot(diff, rayDir);\n    float c = length(diff);\n    float c2 = c * c - radius * radius;\n    float b2ac = sqrt(b * b - a2 * c2);\n    float t1 = (-b + b2ac) / a2;\n    float t2 = (-b - b2ac) / a2;\n    return min(t1, t2);\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// Mikka Boze Distance Function\n/////////////////////////////////////////////////////////////////////////////////////////////////\n#define RAD90 (M_PI * 0.5)\n\nfloat sdEar(vec3 p)\n{\n    p = rotate(p, RAD90+0.25, vec3(0,0,1));    \n    return sdCappedTorus(p + vec3(0.05, 0.175, 0), vec2(sin(0.7),cos(0.7)), 0.03, 0.01);\n}\n\n#define EYE_SPACE 0.04\n\nvec3 opBendXY(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\nvec3 opBendXZ(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec2 xz = m*p.xz;\n    return vec3(xz.x, p.y, xz.y);\n}\nfloat sdMouse(vec3 p, float ms)\n{\n    vec3 q = opBendXY(p, 2.0);\n    ms += 0.00001;\n    return sdEllipsoid(q - vec3(0,0,0.2), vec3(0.035, 0.01 * ms,0.05 * ms));\n}\n\nfloat sdCheep(vec3 p)\n{    \n    const float x = 0.05;\n    const float z = -0.175;\n    const float r = 0.0045;\n    const float rb1 = 100.;\n    \n    p = rotate(p, M_PI * -0.6 * (p.x - x), vec3(-0.2,0.8,0));\n\t\n    float d = sdCapsule(opBendXY(p + vec3(x, -0.01, z), rb1), vec3(-0.005,0.0,0.0), vec3(0.005, 0., 0.001), r);\n    float d1 = sdCapsule(opBendXY(p + vec3(x+0.01, -0.01, z), 200.0), vec3(-0.0026,0.0,0), vec3(0.0026, 0., 0), r);\n    float d2 = sdCapsule(opBendXY(p + vec3(x+0.019, -0.015, z), -rb1), vec3(-0.01,0.0,-0.01), vec3(0.0045, 0., 0.0), r);\n    \n    return opUnion(opUnion(d, d1), d2);\n}\n\nfloat sdEyeBrow(vec3 p)\n{\n    const float x = 0.05;\n    p = opBendXZ(p + vec3(0.02,0,-0.02), -6.5);\n    return sdRoundBox(p + vec3(0.005, -0.14,-0.11), vec3(0.003,0.0025,0.05), 0.001);\n}\n\nfloat sdBoze(vec3 p, float sc, float ms)\n{        \n    p /= sc;\n    \n    // head\n\tfloat d = sdCapsule(p, vec3(0,0.05,0), vec3(0, 0.11, 0), 0.125);\n    \n    float d1 = sdRoundedCylinder(p + vec3(0,0.025,0), 0.095, 0.05, 0.0);\n    \n    d = opSmoothUnion(d, d1, 0.1);\n    \n    vec3 mxp = vec3(-abs(p.x), p.yz);\n    \n    // ear\n    float d2 = sdEar(mxp);\n    d = opUnion(d, d2);\n\n    float head = d;\n\n\t// eye\n    float eye = sdCapsule(mxp, vec3(-EYE_SPACE, 0.06, 0.13), vec3(-EYE_SPACE, 0.08, 0.125), 0.0175);\n    \n    // mouse\n    float mouse = sdMouse(mxp, ms);\n    \n    // cheep\n    float cheep = sdCheep(mxp);\n\n    // eyebrows\n    float eyebrow = sdEyeBrow(p);\n    \n    float sub = opUnion(opUnion(eye, mouse), eyebrow);\n    \n    float result = opSubtraction(sub, head);\n    result = opUnion(cheep, result);\n    \n    result *= sc;\n    \n    return result;\n}\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// End of Mikka Boze\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\n#define BOZE(p) (sdBoze(p - vec3(0.,0.3, 0.), 5.0, (sin(iTime * 0.5) * 0.5 + 0.5)*1.5))\n\nfloat sdDome(vec3 p)\n{\n    float d1 = sdRoundBox(p, vec3(100, 6, 100), 0.01);\n    float d2 = sdSphere(p, 6.);\n    return opSubtraction(d2, d1) - (fbm(p * 0.35 + iTime * 0.1)-(p.y*0.35));\n    //return opSubtraction(d2, d1);\n}\n\nfloat map(vec3 p)\n{\n    // cloud boze\n    float r = BOZE(p);\n    \n    // cloud sea\n    float d = sdDome(p);\n    return min(r, d);\n}\n\nfloat densitycalc(vec3 p){\n    // Boze Cloud\n\tfloat r = BOZE(p);\t\n    float density = fbm(p * 15. + iTime * 0.5) - min(r, 1.) * 10.5;\n    \n    // Cloud sea\n    float d = sdDome(p);\n    float sdensity = fbm(p * 3. + iTime * 0.15) -min(d, 1.)*1.5;\n    \n    return max(density, sdensity);\n}\n\nfloat checkMap(vec3 p, vec3 ray, float depth)\n{\n    float t = 0.;\n    \n    for(int i = 0; i < 5; i++){\n        float d = map(p);\n        if(abs(d) < 0.1 || d > depth)\n            break;\n        t += d;\n        p += ray * d;\n    }\n    \n    return t;\n}\n\n#define MAX_MARCH 64\n#define MAX_MARCH_L 6\n\nvec3 raycast(vec3 p, vec3 ray, float depth)\n{\n    vec3 result = vec3(0.);\n          \n    float radius = 2.0;\n    float d = checkMap(p, ray, depth);\n    \n    if(d < depth)\n    {\n        float zstep = 7.0 / float(MAX_MARCH);\n    \tfloat lightZStep = 2.0 / float(MAX_MARCH_L);\n        \n        vec3 ro2 = p + ray * (d - zstep);\n        float t = hash13(ro2 * 2165.) * 0.001;\n        float alpha = 0.;\n        float transmittance = 1.0;\n        float absorption   = 20.;\n        //vec3 sunDir = normalize(vec3(cos(iTime),1,sin(iTime)));\n        vec3 sunDir = normalize(vec3(-1,1,-0.25));\n        vec3 col = vec3(0.0);\n        \n        for(int i = 0; i < MAX_MARCH; i++){\n            t += zstep;\n            vec3 pp = ro2 + ray * t;\n            if(t >= depth)\n                break;\n            \n            float density = densitycalc(pp);\n            \n            if(density > 0.){\n                float dd = density / float(MAX_MARCH);\n                transmittance *= 1.0 - dd * absorption;\n                if(transmittance < 0.01)\n                    break;\n                alpha += 100. * dd * transmittance;\n                \n                float transmittanceLight = 1.0;\n                \n                for(int j = 0; j < MAX_MARCH_L; j++){\n                \tfloat densityLight = densitycalc(pp + sunDir * float(j) * lightZStep);\n                    if(densityLight > 0.0){\n                    \tfloat dl = densityLight * lightZStep;\n                        transmittanceLight *= 1.0 - dl * absorption * 0.1;\n                        if(transmittanceLight < 0.01){\n                        \ttransmittanceLight = 0.;\n                            break;\n                        }\n                    }\n                }\n                \n                col += vec3(1.) * (10. * dd * transmittance); // base\n                col += vec3(1.,.7,.5) * (80. * dd * transmittance * transmittanceLight); // light\n            }\n        }\n        result = col;\n    }\n    \n    return result;\n}\n\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nfloat luminance(vec3 col)\n{\n    return dot(vec3(0.298912, 0.586611, 0.114478), col);\n}\n\nvec3 reinhard(vec3 col, float exposure, float white) {\n    col *= exposure;\n    white *= exposure;\n    float lum = luminance(col);\n    return (col * (lum / (white * white) + 1.0) / (lum + 1.0));\n}\n\nvec3 sky(vec2 p, vec3 rd)\n{\n    vec3 r = vec3(0.);\n\n    vec3 up = mix(vec3(0.25,0.5,0.8), vec3(0.001, 0.15, 0.5), saturate(abs(rd.y-0.3) * 5.0));\n    vec3 down = vec3(0.25,0.5,0.8);\n    return rd.y > 0.3 ? up : down;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    float time = iTime * 0.5;\n    float y = 0.6;\n    vec3 ro = vec3(0., -0.5, 3.5);\n    vec3 ta = vec3(0., y, 0.);\n    mat3 c = camera(ro, ta, 0.);\n    vec3 ray = c * normalize(vec3(p, 3.5));\n    vec3 col = sky(p, ray);\n    \n    col += raycast(ro, ray, 100.);\n    \n    col = reinhard(col.xyz, 2.9, 100.0);\n    col = pow(col.xyz, vec3(1.0/0.9));\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}