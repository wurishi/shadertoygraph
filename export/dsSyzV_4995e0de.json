{"ver":"0.1","info":{"id":"dsSyzV","date":"1687899506","viewed":105,"name":"Bloom by willeves07","username":"willeves07","description":"an emissive sphere that lights up a white sphere with a skybox","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["raytracing","simple","bloom","emission"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define colorRange 24.0\n\nvec3 jodieReinhardTonemap(vec3 c){\n    float l = dot(c, vec3(0.2126, 0.7152, 0.0722));\n    vec3 tc = c / (c + 1.0);\n\n    return mix(c / (l + 1.0), tc, tc);\n}\n\nvec3 bloomTile(float lod, vec2 offset, vec2 uv){\n    return texture(iChannel1, uv * exp2(-lod) + offset).rgb;\n}\n\nvec3 getBloom(vec2 uv){\n\n    vec3 blur = vec3(0.0);\n\n    blur = pow(bloomTile(2., vec2(0.0,0.0), uv),vec3(2.2))       \t   \t+ blur;\n    blur = pow(bloomTile(3., vec2(0.3,0.0), uv),vec3(2.2)) * 1.3        + blur;\n    blur = pow(bloomTile(4., vec2(0.0,0.3), uv),vec3(2.2)) * 1.6        + blur;\n    blur = pow(bloomTile(5., vec2(0.1,0.3), uv),vec3(2.2)) * 1.9 \t   \t+ blur;\n    blur = pow(bloomTile(6., vec2(0.2,0.3), uv),vec3(2.2)) * 2.2 \t   \t+ blur;\n\n    return blur * colorRange;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 color = pow(texture(iChannel0, uv).rgb * colorRange, vec3(2.2));\n    color = pow(color, vec3(2.2));\n    color += pow(getBloom(uv), vec3(2.2));\n    color = pow(color, vec3(1.0 / 2.2));\n    \n    color = jodieReinhardTonemap(color);\n    \n\tfragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"struct Material{\n    vec3 albedo;\n    vec3 emission;\n    float emission_strength;\n    float roughness;\n};\n\nstruct Sphere{\n    vec3 position;\n    float radius;\n    Material material;\n};\n\nSphere[5] spheres;\nint sphere_count;\n\nstruct Light{\n    vec3 position;\n    float radius;\n    vec3 color;\n    bool directional;\n};\n\nLight[5] lights;\nint light_count;\n\nstruct Ray{\n    vec3 origin;\n    vec3 direction;\n};\n\nvec3 Skybox(vec3 direction){\n    return vec3(0.2, 0.6, 1.0) * 1.2 * max(direction.y+0.075, 0.0) + vec3(0.4);\n}\n\n// ray.origin, ray.direction, sphere position, sphere radius\nfloat raySphereIntersect(vec3 r0, vec3 rd, vec3 s0, float sr) {\n    float a = dot(rd, rd);\n    vec3 s0_r0 = r0 - s0;\n    float b = 2.0 * dot(rd, s0_r0);\n    float c = dot(s0_r0, s0_r0) - (sr * sr);\n    if (b*b - 4.0*a*c < 0.0) {\n        return -1.0;\n    }\n    return (-b - sqrt((b*b) - 4.0*a*c))/(2.0*a);\n}\n\nvec3 Trace(Ray ray){\n    vec3 lightColor = vec3(1.0);\n    vec3 incomingLight = vec3(0.0);\n    vec3 subSurface = vec3(0.0);\n    \n    float min_distance = 10000000.0;\n    int min_index = -1;\n    for(int i = 0; i < sphere_count; i++){\n        float hit_distance = raySphereIntersect(ray.origin, ray.direction, spheres[i].position, spheres[i].radius);\n    \n        if(hit_distance == -1.0) continue;\n        \n        if(hit_distance < min_distance){\n            min_distance = hit_distance;\n            min_index = i;\n        }\n    }\n    \n    if(min_index == -1){\n        return Skybox(ray.direction);\n    }\n    \n    lightColor *= spheres[min_index].material.albedo;\n    \n    vec3 hit_point = ray.origin + ray.direction * min_distance;\n    \n    vec3 normal = normalize(hit_point - spheres[min_index].position);\n    \n    vec3 reflection_direction = ray.direction - 2.0 * dot(normal, ray.direction) * normal;\n    \n    for(int i = 0; i < light_count; i++){\n        float d;\n        if(lights[i].directional) d = distance(vec3(0.0), -lights[i].position);\n        else                      d = distance(hit_point, lights[i].position);\n        if(d < lights[i].radius || lights[i].directional){\n            vec3 incomingLightAmount;\n            if(!lights[i].directional) incomingLightAmount = (lights[i].color * (lights[i].radius - d) / lights[i].radius) * max(-dot(normal, (hit_point - lights[i].position)), 0.0);\n            else incomingLightAmount = lights[i].color * max(-dot(normal, -lights[i].position), 0.0);\n            \n            incomingLight += incomingLightAmount;\n        }\n    }\n    \n    float spec = max(dot(normal, reflection_direction), 0.0);\n    \n    incomingLight += Skybox(reflection_direction) * 0.6 * spheres[min_index].material.albedo * spec;\n    \n    vec3 emission = spheres[min_index].material.emission * spheres[min_index].material.emission_strength * spec;\n    \n    return lightColor * incomingLight + emission;\n}\n\nvoid AddSphere(vec3 position, float radius, Material material){\n    if(sphere_count == 100) return;\n    spheres[sphere_count].position = position;\n    spheres[sphere_count].radius = radius;\n    spheres[sphere_count].material = material;\n    sphere_count++;\n}\n\nvoid AddLight(vec3 position, float radius, vec3 color){\n    if(light_count == 100) return;\n    lights[light_count].position = position;\n    lights[light_count].radius = radius;\n    lights[light_count].color = color;\n    lights[light_count].directional = false;\n    light_count++;\n}\n\nvoid AddLight(vec3 position, vec3 color){\n    if(light_count == 100) return;\n    lights[light_count].position = position;\n    lights[light_count].radius = 1.0;\n    lights[light_count].color = color;\n    lights[light_count].directional = true;\n    light_count++;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // vec2 uv = fragCoord/iResolution.xy;\n    // vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    float view_size = 1.2;\n    \n    Ray ray;\n    ray.origin = vec3(cos(iTime) * 3.0, 0.0, sin(iTime));\n    ray.direction = vec3(((fragCoord.x - iResolution.x/2.0) / iResolution.y) * view_size, (fragCoord.y / iResolution.y - 0.5) * view_size, 1.0);\n    ray.direction = normalize(ray.direction);\n    \n    // directional light\n    AddLight(vec3(1.0, 1.0, -1.0), vec3(1.0));\n\n    \n    Material material1;\n    material1.albedo = vec3(0.0, 0.0, 0.0);\n    material1.emission = vec3(1.0, 0.6, 0.3);\n    material1.emission_strength = (cos(iTime) + 1.0) * 10.0;\n    AddLight(vec3(-2.0, 2.0, 5.0), 6.0, vec3(1.0, 0.6, 0.3) * material1.emission_strength * 0.6);\n    material1.roughness = 1.0;\n    \n    Material material2;\n    material2.albedo = vec3(0.5);\n    material2.roughness = 1.0;\n\n    AddSphere(vec3(-2.0,  2.0, 5.0), 1.0, material1);\n    AddSphere(vec3( 2.0, -2.0, 5.0), 1.0, material2);\n    \n    vec3 color = Trace(ray);\n    \n    color = max(color, vec3(0.0));\n    \n    fragColor = vec4(color * 0.1, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec3 makeBloom(float lod, vec2 offset, vec2 bCoord){\n    \n    vec2 pixelSize = 1.0 / vec2(iResolution.x, iResolution.y);\n\n    offset += pixelSize;\n\n    float lodFactor = exp2(lod);\n\n    vec3 bloom = vec3(0.0);\n    vec2 scale = lodFactor * pixelSize;\n\n    vec2 coord = (bCoord.xy-offset)*lodFactor;\n    float totalWeight = 0.0;\n\n    if (any(greaterThanEqual(abs(coord - 0.5), scale + 0.5)))\n        return vec3(0.0);\n\n    for (int i = -5; i < 5; i++) {\n        for (int j = -5; j < 5; j++) {\n\n            float wg = pow(1.0-length(vec2(i,j)) * 0.125,6.0);\n\n            bloom = pow(texture(iChannel0,vec2(i,j) * scale + lodFactor * pixelSize + coord, lod).rgb,vec3(2.2))*wg + bloom;\n            totalWeight += wg;\n\n        }\n    }\n\n    bloom /= totalWeight;\n\n    return bloom;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n\tvec3 blur = makeBloom(2.,vec2(0.0,0.0), uv);\n\t\tblur += makeBloom(3.,vec2(0.3,0.0), uv);\n\t\tblur += makeBloom(4.,vec2(0.0,0.3), uv);\n\t\tblur += makeBloom(5.,vec2(0.1,0.3), uv);\n\t\tblur += makeBloom(6.,vec2(0.2,0.3), uv);\n\n    fragColor = vec4(pow(blur, vec3(1.0 / 2.2)),1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}