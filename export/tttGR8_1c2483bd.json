{"ver":"0.1","info":{"id":"tttGR8","date":"1575803049","viewed":132,"name":"[GameGig2019] Infection","username":"huwb","description":"Cambridge GameGig 2019 game jam.","likes":8,"published":1,"flags":96,"usePreview":0,"tags":["fractal","game"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Mll3Ds","filepath":"https://soundcloud.com/kaleldomigo/in-motion-trent-reznor-atticus-ross","previewfilepath":"https://soundcloud.com/kaleldomigo/in-motion-trent-reznor-atticus-ross","type":"musicstream","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Final presentation\n\nfloat drawNumber(float num, vec2 pos, vec2 pixel_coords);\nfloat drawDig(vec2 pos, vec2 pixel_coords, float bitfield);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    fragColor = vec4(0.);\n    \n    float uvr = 2.2*length(uv-.5);\n    float v = pow(uvr,2.);\n    v = max(v,0.05);\n    vec3 bg = .15-.07*vec3(uvr);\n    bg.r *= .75;\n    bg = vec3(1.);\n    \n    // crude blur. not quite box, cut off the corners to reduce boxyness\n    #define R 3.\n    float twt = 0.;\n    for( float i = -R; i <= R; i++ )\n    {\n        for( float j = -R; j <= R; j++ )\n        {\n            if( abs(i)+abs(j) > 5. ) continue; // corners not welcome\n            \n            vec4 s = texture( iChannel0, uv + 1.*v*vec2(i,j)/iResolution.xy );\n            s = smoothstep(0.,.5,s); // blow it out a bit\n            \n\t\t    fragColor += s;\n            twt += 1.;\n        }\n    }\n    fragColor /= twt;\n    fragColor = max(1.0 - texture(iChannel1, uv), fragColor);\n    fragColor *= 2.;\n    \n    // bg, vign\n    fragColor.xyz = .99*vec3(1.,.98,.97) - fragColor.xyz;\n    fragColor.xyz *= pow(1. - 1.9*dot(uv-.5,uv-.5),.07);\n    \n    \n    // UI\n    float time = texture(iChannel2, vec2(11.5, 0.5) / iResolution.xy).x;\n    \n    float timeLen = 60.0;\n    if(time > .99*timeLen)\n    {\n        //float alpha = fract(2.0*(iTime-timeLen)) > 0.5 ? 0.0: 1.0;\n\t\t//fragColor = mix(fragColor, fragColor * vec4(1.0 - drawNumber(0.0, vec2(0.005,0.08), uv/10.0 )), alpha);\n        vec2 smilePos = vec2(0.046, 0.08);\n        fragColor *= vec4(1. - drawDig( smilePos, uv/10., 2607. ));\n    }\n    else\n    {\n\t\tfragColor *= vec4(1.0 - drawNumber(timeLen - time, vec2(0.08,0.08), uv/10.0 ));\n\t\n    \n        float lives = texture(iChannel2, vec2(10.5, 0.5) / iResolution.xy).x;\n        fragColor *= vec4(1.0 - drawNumber(lives, vec2(0.005,0.08), uv/10.0 ));\n    }\n    \n}\n\n\n\n\n\n\n\n\n// digits based on the nice ascii shader by movAX13h\n\nfloat drawDig( vec2 pos, vec2 pixel_coords, float bitfield )\n{\n\t// offset relative to \n\tvec2 ic = pixel_coords - pos ;\n\tic = floor(ic*iResolution.xy);\n\t// test if overlap letter\n\tif( clamp(ic.x, 0., 2.) == ic.x && clamp(ic.y, 0., 4.) == ic.y )\n\t{\n\t\t// compute 1d bitindex from 2d pos\n\t\tfloat bitIndex = ic.y*3.+ic.x;\n\t\t// isolate the bit\n\t\treturn floor( mod( bitfield / exp2( floor(bitIndex) ), 2. ) );\n\t}\n\treturn 0.;\n}\n// decimal point\nfloat drawDecPt( vec2 center, vec2 pixel_coords )\n{\n\treturn drawDig( center, pixel_coords, 1. );\n}\n// minus sign\nfloat drawMinus( vec2 center, vec2 pixel_coords )\n{\n\treturn drawDig( center, pixel_coords, 448. );\n}\n// digits 0 to 9\nfloat drawDigit( float dig, vec2 pos, vec2 pixel_coords )\n{\n\tif( dig == 1. )\n\t\treturn drawDig( pos, pixel_coords, 18724. );\n\tif( dig == 2. )\n\t\treturn drawDig( pos, pixel_coords, 31183. );\n\tif( dig == 3. )\n\t\treturn drawDig( pos, pixel_coords, 31207. );\n\tif( dig == 4. )\n\t\treturn drawDig( pos, pixel_coords, 23524. );\n\tif( dig == 5. )\n\t\treturn drawDig( pos, pixel_coords, 29671. );\n\tif( dig == 6. )\n\t\treturn drawDig( pos, pixel_coords, 29679. );\n\tif( dig == 7. )\n\t\treturn drawDig( pos, pixel_coords, 31012. );\n\tif( dig == 8. )\n\t\treturn drawDig( pos, pixel_coords, 31727. );\n\tif( dig == 9. )\n\t\treturn drawDig( pos, pixel_coords, 31719. );\n\t// 0\n\treturn drawDig( pos, pixel_coords, 31599. );\n}\n\n// max num width is 26px (minus, 3 nums, dec pt, 2 nums)\n// max height is 6px\nfloat drawNumber( float num, vec2 pos, vec2 pixel_coords )\n{\n\tfloat result = 0.;\n\tbool on = false;\n\tfloat d;\n\t\n\t// minus sign\n\tif( num < 0. )\n\t{\n\t\tresult += drawMinus( pos, pixel_coords );\n\t\tpos.x += 4. / iResolution.x;\n\t\tnum = -num;\n\t}\n\t// hundreds\n\td = floor(mod(num/100.,10.));\n\tif( on || d > 0. )\n\t{\n\t\tresult += drawDigit( d, pos, pixel_coords );\n\t\tpos.x += 4. / iResolution.x;\n\t\ton = true;\n\t}\n\t// tens\n\td = floor(mod(num/10.,10.));\n\tif( on || d > 0. )\n\t{\n\t\tresult += drawDigit( d, pos, pixel_coords );\n\t\tpos.x += 4. / iResolution.x;\n\t\ton = true;\n\t}\n\t// ones\n\td = floor(mod(num,10.));\n\tresult += drawDigit( d, pos, pixel_coords );\n\tpos.x += 4. / iResolution.x;\n\t/*// dec pt\n\tresult += drawDecPt( pos, pixel_coords );\n\tpos.x += 2. / iResolution.x;\n\t// tenths\n\td = floor(mod(num/.1,10.));\n\tif( true )\n\t{\n\t\tresult += drawDigit( d, pos, pixel_coords );\n\t\tpos.x += 4. / iResolution.x;\n\t}\n\t// hundredths\n\td = floor(.5+mod(num/.01,10.));\n\tif( d > 0. )\n\t{\n\t\tresult += drawDigit( d, pos, pixel_coords );\n\t\tpos.x += 4. / iResolution.x;\n\t}*/\n\t\n\treturn clamp(result,0.,1.);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Game state simulation\n\nvoid UpdateBug(float bugX, inout vec4 fragColor)\n{\n    vec2 pos = fragColor.xy;\n    float heading = fragColor.z;\n    if(pos.x < -10.0)\n    {\n        fragColor.x = 1000.0;// 2000.0;\n        fragColor.y = (bugX-5.) * 1000.0; //(iTime-30.0) * 100.0;\n    }\n    \n    float time = mod(iTime + bugX * 0.343, 1.0 * bugX);\n    if(time >= 1.0)\n    {\n        vec2 playerPos = texture(iChannel0, vec2(0.5, 0.5) / iResolution.xy).xy;\n        vec2 dir = playerPos - pos;\n        float angle = atan(dir.y, dir.x);\n        if(angle < 0.0) angle += 2.0*3.141592654;\n\n        float oldHeading = fragColor.z;\n        fragColor.z = mix(heading, angle, 0.051);\n\n        float headingDiff = abs(fragColor.z - oldHeading);\n        vec2 headingv = vec2(cos(heading), sin(heading));\n        fragColor.xy += headingv * 4.0 / (0.5 + 10.*headingDiff);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float lives = texture(iChannel0, vec2(10.5, 0.5) / iResolution.xy).x;\n    \n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n    if(iFrame < 35)\n    {\n        if(fragCoord.x == 0.5) fragColor = vec4(1.0);\n        if(fragCoord.x == 1.5) fragColor = vec4(10.0, 8.1, 0.0, 0.0);\n        if(fragCoord.x == 2.5) fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n        if(fragCoord.x == 3.5) fragColor = vec4(3000.0, 100.0, 0.0, 0.0);\n        if(fragCoord.x == 4.5) fragColor = vec4(4550.0, 4100.0, 0.0, 0.0);\n        if(fragCoord.x == 5.5) fragColor = vec4(0.0, 9100.0, 0.0, 0.0);\n        if(fragCoord.x == 6.5) fragColor = vec4(300.0, -5100.0, 0.0, 0.0);\n        if(fragCoord.x == 10.5) fragColor = vec4(10.0, 0.0, 0.0, 0.0);\n        if(fragCoord.x == 11.5) fragColor = vec4(iTime, 0.0, 0.0, 0.0);\n        return;\n    }\n    \n    vec2 mouseUV = iMouse.xy / iResolution.xy;\n    \n    if(fragCoord.y > 0.5)\n        return;\n    \n    if(lives <= 0.0) return;\n    \n    if(fragCoord.x == 0.5) // BLOB POS\n    {\n        vec2 vel = texture(iChannel0, vec2(1.5, 0.5) / iResolution.xy).xy;\n        fragColor.xy += vel;\n        fragColor.x = clamp(fragColor.x, 0.0, iResolution.x);\n        fragColor.y = clamp(fragColor.y, 0.0, iResolution.y);\n    }\n    if(fragCoord.x == 1.5) // BLOB VEL\n    {\n        vec2 pos = texture(iChannel0, vec2(0.5, 0.5) / iResolution.xy).xy;\n        \n        if(pos.x <= 0.0) fragColor.x = 0.0;\n        if(pos.x >= iResolution.x-1.0) fragColor.x = 0.0;\n        if(pos.y <= 0.0) fragColor.y = 0.0;\n        if(pos.y >= iResolution.y-1.0) fragColor.y = 0.0;\n        \n        if(iMouse.z > 0.)\n        {\n            // Press mouse - accel towards cursor\n\t        fragColor.xy += 0.0015*(iMouse.xy - pos);\n        }\n        else\n        {\n\t        fragColor.xy += 0.15*(0.5 - pos/iResolution.xy);\n        }\n        \n        fragColor *= 0.98;\n    }\n    if(fragCoord.x == 2.5) // CAMERA POS\n    {\n        vec2 pos = texture(iChannel0, vec2(0.5, 0.5) / iResolution.xy).xy;\n        fragColor.xy += 0.2*(pos/iResolution.xy - 0.5);\n    }\n    if(iTime > 5.0)\n    {\n        if(fragCoord.x == 3.5) // LITTLE BUG\n        {\n            UpdateBug(3.5, fragColor);\n        }\n        if(fragCoord.x == 4.5) // LITTLE BUG\n        {\n            UpdateBug(4.5, fragColor);\n        }\n        if(fragCoord.x == 5.5) // LITTLE BUG\n        {\n            UpdateBug(5.5, fragColor);\n        }\n        if(fragCoord.x == 6.5) // LITTLE BUG\n        {\n            UpdateBug(6.5, fragColor);\n        }\n    }\n    if(fragCoord.x == 10.5) // LIVES\n    {\n        vec2 pos = texture(iChannel0, vec2(0.5, 0.5) / iResolution.xy).xy;\n        vec2 bugPos0 = texture(iChannel0, vec2(3.5, 0.5) / iResolution.xy).xy;\n        vec2 bugPos1 = texture(iChannel0, vec2(4.5, 0.5) / iResolution.xy).xy;\n        vec2 bugPos2 = texture(iChannel0, vec2(5.5, 0.5) / iResolution.xy).xy;\n        vec2 bugPos3 = texture(iChannel0, vec2(6.5, 0.5) / iResolution.xy).xy;\n        \n        if(length(bugPos0 - pos) < 10.0) lives--;\n        if(length(bugPos1 - pos) < 10.0) lives--;\n        if(length(bugPos2 - pos) < 10.0) lives--;\n        if(length(bugPos3 - pos) < 10.0) lives--;\n        \n        lives = max(lives, 0.0);\n        fragColor.x = lives;\n    }\n    if(fragCoord.x == 11.5) // TIME\n    {\n        fragColor.x = iTime;\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Background fractal\n\n// From https://www.shadertoy.com/view/MlcSWl\n\n#define MAX_ITERS 14.0\n\nfloat ambPhase(vec2 uv)\n{\n    vec2 noiseUv = uv;\n    //noiseUv.x *= iResolution.x/iResolution.y;\n    noiseUv /= 250.0;\n    noiseUv += vec2(0.0002839, 0.00009289) * iTime;\n    float result = texture(iChannel1, noiseUv).x;\n    result += 0.5 * (texture(iChannel1, noiseUv*2.34386).x - 0.5);\n    result += 0.25 * (texture(iChannel1, noiseUv*4.74386).x - 0.5);\n    return result;\n}\n\nfloat intersectsLayer( vec2 fragCoord, float phase, float layer, out float smallest )\n{\n    float mo = -.4;\n    //if( iMouse.z > 0. ) mo = (.5-iMouse.x/iResolution.x)*2.;\n    //mo += sin(iTime)*0.1;\n    //mo -= iMouse.x/iResolution.x;\n    mo -= 2.*(phase-0.8);\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float time = iTime;\n    //time = 0.;\n    \n\tvec2 c = (cos(.35*time)+20.) * (2.0 * uv - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);\n    c *= 0.10;\n    //c /= 10.+5.*cos(.1*iTime);\n    c.y -= 1.2;\n    c.x -= 3.;\n\tvec2 z = vec2( 0., 0.*time );\n\tfloat escapeRadius = 44.;\n    \n\tfor (float i = 0.; i < MAX_ITERS; ++i)\n    {\n\t\tvec2 newz = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n        float div = mo*0.01*dot(newz,z) - 2.;\n        z = newz / div; // added hack, inspired by kaliset\n        \n        // is this the layer we're interested in?\n        if( i + 1. == layer )\n        {\n\t        // check for escape, if so then the pixel has hit this layer.\n            // also, vary escape radius over time to add a little more interest\n            if( dot(z,z) > escapeRadius*escapeRadius )\n            {\n                return 1.;\n            }\n            else\n            {\n                return 0.;\n            }\n        }\n        \n        smallest = min( smallest, (escapeRadius*escapeRadius - dot(z,z))*layer );\n \t}\n    \n\treturn 0.;\n}\n\nvec3 shade( vec2 fragCoord, float phase )\n{    \n    // process one layer of the fractal at a time so that we can apply different amounts of parallax to each\n    for( float layer = 2.; layer < MAX_ITERS; layer++ )\n    {\n        float parallaxZ = layer+1.; //parallaxZ = 4.5*parallaxZ*parallaxZ + zscr;\n        float time = iTime;\n        //time = 0.0;\n\n        vec2 off = texture(iChannel0, vec2(2.5, 0.5)/iResolution.xy).xy * 60.0/parallaxZ;\n        //vec2 off = vec2( cos(.33*time), sin(.133*time)) * 360./parallaxZ;\n        \n        float depth = 0., stepSz;\n        \n        \n        float sml;\n        float fractal = intersectsLayer( fragCoord + off, phase, layer, sml );\n        if( fractal > 0. )\n        {\n            float ao = 1.;\n            ao = mix(1.,exp(.0001*sml),.5);\n            return ao*vec3(1.)*mix(vec3(.2,.2,.8)*.5,vec3(.5,.7,1.), (exp(-.25*(parallaxZ-1.))) );\n        }\n    }\n    // no hit, return bg\n    return vec3(0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ambientPhase = ambPhase(uv);\n\t//fragColor = vec4(ambientPhase);\n    //return;\n    \n    // crude AA using N-Queens pattern, does the job. some kind of analytical version should be possible and could be cheaper.\n    fragColor.xyz  = shade( fragCoord + vec2(-3./8.,-1./8.), ambientPhase );\n    fragColor.xyz += shade( fragCoord + vec2(-1./8., 3./8.), ambientPhase );\n    fragColor.xyz += shade( fragCoord + vec2( 3./8., 1./8.), ambientPhase );\n    fragColor.xyz += shade( fragCoord + vec2( 1./8.,-3./8.), ambientPhase );\n    fragColor /= 4.;\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Characters \n\n// Prototyped in https://www.shadertoy.com/view/wttGz8\n\n\nfloat smoothMin(float a, float b, float k1, float k2)\n{\n    float res = exp2( -k1*a ) + exp2( -k2*b );\n    return -log2( res )/((k1+k2)/2.0);\n}\n\nvec2 screenToUv(vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv.x *= iResolution.x / iResolution.y;\n    return uv;\n}\n\nfloat jellySDF(float rot, vec2 uv, float size, float k1, float k2, vec2 camPos)\n{\n    vec2 pos0 = texture(iChannel0, vec2(0.5, 0.5)/iResolution.xy).xy;\n    \n    vec2 pos = screenToUv(pos0);\n    \n    float distBody = length(pos-uv) - size;\n    \n    float bumpSize = 1.5 * size;\n    float bumpRad = bumpSize/16.0 * smoothstep(size + 0.01, size, length(uv-pos));\n    vec2 uvRep = mod(uv + .1*camPos, bumpSize);\n    float distBump = length(0.5*bumpSize-uvRep) - bumpRad;\n    \n    return smoothMin(distBody, distBump, k1, k2);\n}\n\nfloat shade(float dist)\n{\n    //return dFdx(dist)*dFdx(dist)*10000.;\n    return smoothstep(0.0, -0.0015, dist);\n}\n\nfloat bugSDF(vec2 uv, float bugX, float size, vec2 camPos)\n{\n    size *= 0.0025;\n    \n    float k1 = 100.0, k2 = 3.0;\n    \n    vec3 data = texture(iChannel0, vec2(bugX, 0.5)/iResolution.xy).xyz;\n    \n    vec2 pos = screenToUv(data.xy);\n    float heading = data.z;\n    \n    vec2 offset = pos - uv;\n    vec2 xa = vec2(cos(heading), sin(heading));\n    vec2 ya;\n    ya.x = -xa.y;\n    ya.y = xa.x;\n    \n    float xl = dot(offset, xa);\n    float yl = dot(offset, ya);\n    yl *= 3.0;\n\n    float distBody = length(vec2(xl, yl)) - size;\n\n    float bumpSize = 15.5 * size;\n    float bumpRad = bumpSize/16.0 * smoothstep(size + 0.01, size, length(uv-pos));\n    vec2 uvRep = mod(uv + .1*camPos, bumpSize);\n    float distBump = length(0.5*bumpSize-uvRep) - bumpRad;\n    \n    return smoothMin(distBody, distBump, k1, k2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = screenToUv(fragCoord);\n\n    float size = 0.04;\n\n    vec2 camPos = texture(iChannel0, vec2(2.5, 0.5)/iResolution.xy).xy;\n\n    float dist2 = jellySDF(0.0, uv, size, 100.0, 3.0, camPos);\n    float shaded2 = shade(dist2);\n    \n    float timeLen = 60.0;\n    float time = texture(iChannel0, vec2(11.5, 0.5) / iResolution.xy).x;\n    if(time < timeLen)\n    {\n        shaded2 = max(shaded2, shade(bugSDF(uv, 3.5, 1.0, camPos)));\n        shaded2 = max(shaded2, shade(bugSDF(uv, 4.5, 1.0, camPos)));\n        shaded2 = max(shaded2, shade(bugSDF(uv, 5.5, 1.0, camPos)));\n        shaded2 = max(shaded2, shade(bugSDF(uv, 6.5, 1.0, camPos)));\n    }\n    \n    vec3 tone = mix(vec3(.2,.2,.8)*.5,vec3(.5,.7,1.), (exp(-.25*(.7))) );\n    \n    fragColor.xyz = 1.0 - shaded2 * tone;\n}\n\n","name":"Buffer C","description":"","type":"buffer"}]}