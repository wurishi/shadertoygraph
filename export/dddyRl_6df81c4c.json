{"ver":"0.1","info":{"id":"dddyRl","date":"1695374754","viewed":86,"name":"sdf soccer","username":"ljs_harbin","description":"a soccer demo","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["sdf","soccer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float pi = 3.1415926535897932384626;\nconst int faces = 12;\nvec3 normal[faces];\nfloat ratio = 0.3;\nfloat R = 0.7;\nfloat R1, Rc;\nfloat bevel_angle = pi / 60.0;\nfloat bevel = 0.015;\nfloat cam_dist = 5.0;\nconst float EPSILON = 0.001;\n\n// the getNormal function refers to https://www.shadertoy.com/view/ltsfzN\nvec3 getNormal(int i) {\n\tint block = i / 4;\n    vec3 signs = sign(vec3(i & ivec3(4, 2, 1)) - 0.1);\n    vec3 r = signs * vec3(0.0, 0.5257, 0.8507);\n    return vec3(r[block % 3], r[(block + 2) % 3], r[(block + 1) % 3]);    \n}\n\nmat3 axis_x_rotation_matrix(float angle) {\n\treturn mat3(1.0, 0.0, 0.0,\n\t\t\t\t0.0, cos(angle), -sin(angle),\n\t\t\t\t0.0, sin(angle), cos(angle));\n}\n\nmat3 axis_y_rotation_matrix(float angle) {\n\treturn mat3(cos(angle), 0.0, sin(angle),\n\t\t\t\t0.0,        1.0, 0.0,\n\t\t\t\t-sin(angle), 0.0, cos(angle));\n}\n\nfloat dist_ball(vec3 p, vec3 center, float r, out vec3 nout)\n{\n    nout = normalize(p - center);\n    return length(p - center) - r;\n}\n\nfloat dist_circle(vec3 p, vec3 center, vec3 nin, float r, out vec3 nout)\n{\n    vec3 v1 = cross(p - center, nin);\n    vec3 v2 = normalize(cross(nin, v1));\n    if (v2 == vec3(0.0))\n    {\n        nout = vec3(0.0);\n        return sqrt(pow(length(p - center), 2.0) + r * r);\n    }\n    else\n    {\n        nout = p - (center + v2 * r);\n        float ret = length(nout);\n        nout = normalize(nout);\n        return ret;\n    }\n}\n\nfloat dist_soccer(vec3 pos, out vec4 color, out vec3 nout)\n{\n    float ret;\n    float ll = length(pos);\n    vec4 c0 = vec4(0.05, 0.05, 0.05, 1.0);\n    vec4 c1 = vec4(0.55, 0.55, 0.55, 1.0);\n    vec4 c5 = vec4(0.2, 0.2, 0.2, 1.0);\n    vec4 c6 = vec4(0.6, 0.6, 0.6, 1.0);\n    float ftemp;\n    float f1 = 0.0, f2 = 0.0, f3 = 0.0;\n    int i1 = -1, i2 = -1, i3 = -1;\n    for (int i = 0; i < faces; i++)\n    {\n        ftemp = dot(pos, normal[i]);\n        if (ftemp > f1)\n        {\n            f3 = f2;\n            f2 = f1;\n            f1 = ftemp;\n            i3 = i2;\n            i2 = i1;\n            i1 = i;\n        }\n        else if (ftemp > f2)\n        {\n            f3 = f2;\n            f2 = ftemp;\n            i3 = i2;\n            i2 = i;\n        }\n        else if (ftemp > f3)\n        {\n            f3 = ftemp;\n            i3 = i;\n        }\n    }\n    vec3 e1 = normalize(mix(normal[i1], normal[i2], ratio));\n    vec3 e2 = normalize(mix(normal[i1], normal[i3], ratio));\n    vec3 n1 = normalize(cross(e1, e2));\n    float dir = sign(dot(n1, normal[i1]));\n    n1 = n1 * dir;\n    vec3 np = normalize(pos);\n    float a = asin(dot(n1, np));\n    //ret = dist_ball(pos, vec3(0.0), R, nout);\n    color = vec4(0.0);\n    if (a >= bevel_angle)\n    {\n        ret = dist_ball(pos, vec3(0.0), R, nout);\n        color = c5;\n    }\n    else if (a >= 0.0)\n    {\n        ret = ll > Rc ? dist_circle(pos, R1 * n1, n1, Rc, nout) - R1 : 0.0;\n        color = mix(c0, c5, a / bevel_angle);\n    }\n    //else if (a == 0.0)\n    //{\n    //    ret = dist_ball(pos, vec3(0.0), Rc, nout);\n    //    color = c0;\n    //}\n    else\n    {\n        vec3 n2 = normalize(cross(normal[i1], normal[i2]));\n        n2 = n2 * dir;\n        float b = asin(dot(n2, np));\n        float babs = abs(b);\n        float aabs = abs(a);\n        if (babs < bevel_angle && babs < aabs)\n        {\n            ret = ll > Rc ? dist_circle(pos, R1 * n2, n2, Rc, nout) - R1 : 0.0;\n            color = mix(c1, c6, babs / bevel_angle);\n        }\n        else if (aabs < bevel_angle)\n        {\n            ret = ll > Rc ? dist_circle(pos, -R1 * n1, -n1, Rc, nout) - R1 : 0.0;\n            color = mix(c1, c6, aabs / bevel_angle);\n        }\n        else\n        {\n            ret = dist_ball(pos, vec3(0.0), R, nout);\n            color = c6;\n        }\n    }\n    return ret;\n}\n\nfloat map(vec3 pos, out vec4 color, out vec3 nout)\n{\n    float dist = dist_soccer(pos, color, nout);\n    return dist - bevel;\n}\n\nvec4 scene(vec3 pos, vec3 dir, out vec3 nout)\n{\n    float dist = 0.0;\n    float nearest = 0.0;\n    vec4 result = vec4(0.0);\n    bool bfind = false;\n    for(int i = 0; i < 100; i++)\n    {\n        nearest = map(pos + dir * dist, result, nout);\n        if(nearest < EPSILON)\n        {\n            bfind = true;\n            break;\n        }\n        else if (nearest > cam_dist * 2.0)\n        {\n            break;\n        }\n        dist += nearest;\n    }\n\n    if (bfind == false)\n    {\n        nout = vec3(0.0);\n        result = vec4(0.0);\n    }\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float fSin = sin(bevel_angle);\n    float fCos = cos(bevel_angle);\n    R1 = R * fSin / (1.0 + fSin);\n    Rc = (R - R1) * fCos;\n\n    for (int i = 0; i < faces; i++)\n    {\n        normal[i] = getNormal(i);\n    }\n\n    vec3 camera_location = vec3(0.0, 0.0, cam_dist);\n    \n\tvec2 screen_space_coords = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\tfloat aspect_ratio = iResolution.x / iResolution.y;\n\tscreen_space_coords.x *= aspect_ratio;\n\n    vec2 screen_space_mouse_coords = (iMouse.xy / iResolution.xy) * 2.0 - 1.0;\n\tscreen_space_mouse_coords.x *= aspect_ratio;\n\tscreen_space_mouse_coords.y = -screen_space_mouse_coords.y;\n\n\tmat3 rotation = axis_y_rotation_matrix(screen_space_mouse_coords.x + iTime * 0.3);\n    rotation *= axis_x_rotation_matrix(screen_space_mouse_coords.y);\n\tvec3 view_direction = normalize(vec3(screen_space_coords, 0) - camera_location);\n\tview_direction *= rotation;\n    camera_location *= rotation;\n\n    vec3 nout;\n    fragColor = scene(camera_location, view_direction, nout);\n\n    vec3 light_dir1 = vec3(0.0, 1.0, 0.0);\n    float p1 = max(0.0, dot(light_dir1, nout));\n    vec3 light_dir2 = vec3(0.0, -1.0, 0.0);\n    float p2 = max(0.0, dot(light_dir2, nout));\n    fragColor.rgb += vec3(p1 * 0.4 + p2 * 0.04);\n}","name":"Image","description":"","type":"image"}]}