{"ver":"0.1","info":{"id":"ssdfzn","date":"1655958214","viewed":205,"name":"Lorentz transform+ Retardation","username":"Amirk","description":"Traveling at 90% speed of light. \"Distances are contracted\" in the direction of the velocity. Moreover, it takes some time for the light/information to reach our eyes, which makes an impression of non-Euclidean geometry.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["relativity","lorentz","retardation"],"hasliked":0,"parentid":"7dKyRc","parentname":"Lorentz contraction+retardation"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nIdea:\n\n1. First we choose our ray origin RO and ray direction rd in our moving frame. Since we are at rest\nin our own frame RO is just vec4(0,0,0,t) where t is proper time (our clock time). Spatial part of\nray direction is the usual. The temporal part of rd can be chosen as -c if we want to follow light rays\ninto past (retarded view), or it can be chosen 0, if we want the instantaneous coordinate geometry.\n\n2. Then we map both RO and ray direction into \"lab-frame\", the frame where\nthe objects are at rest. This is done by Lorentz transform. Then we simply perform \nusual raymarch in the lab frame using the transformed RO and rd.\n\n*/\n\n\n#define MAX_ITER 1000.\n#define MAX_DIST 40.\n#define SURF .001\n\n#define t fract(iTime/20.)*20.\n#define PI 3.14159265359\nconst float speed= 0.90; //as a fraction of the speed of light\nconst float c=1.; //speed of information and light\n\n\n//visual parameters:\nvec3 START= vec3(0.,0.,0.);\nvec3 SIZE= vec3(.1); \n\n//retardation effect ON/OFF:\nbool RETARD = true;\n//ray origin in the mooving coords.\nvec4 RO;\nfloat gamma, beta;\n\nmat2 rot(float a){ \n    return mat2(cos(a), -sin(a),sin(a),cos(a));\n}\n\nvec3 color( float c){\n    return vec3(1) - vec3(.8,.8,0)*smoothstep(.0,1., c)-\n            vec3(0.,.8,.8)*smoothstep(0.,1., -c);\n}\n\nmat4 Lorentz(float v){\n    beta= v/c;\n    gamma = pow(1.-beta*beta,-.5);\n    return mat4(gamma, 0, 0,gamma*beta,\n                0,1, 0, 0,\n                 0, 0, 1, 0,\n                 gamma*beta, 0, 0, gamma);\n}\n\n\n\nfloat sdBox(vec3 p , vec3 s){\n    p=fract(p)-.5; //this creates the grid of reference cubes\n    p= abs(p)-s;\n    return length(max(p,0.))+ min(max(p.x,max(p.y,p.z)),0.);  \n}\n\n\nfloat getDist(vec3 q){\n    float dist= sdBox(q,SIZE);\n    \n    //the ball:\n    q.x-=floor(t/20.)*speed*c*20.*gamma;\n    float sphere= length(q-vec3(15,0,0))-.5;\n    \n    \n    dist = min(dist,sphere);\n    \n    return .5*dist/gamma; //step size could probably be optimized\n}\n\n\n\nvec4 getRayDir(vec2 uv, vec4 lookAt, float zoom){\n\n    vec3 f= normalize(lookAt.xyz);\n    vec3 r= normalize(cross(vec3(0,1,0),f));\n    vec3 u= cross(f,r);\n    \n    return vec4(normalize(f*zoom+uv.x*r+uv.y*u),lookAt.w);\n    //the w-component determines how we look into past/future.\n}\n\nfloat RayMarch(vec4 ro, vec4 rd, float side){\n    float dO=0.;\n    float i=0.;\n   while(i<MAX_ITER){\n      vec4 p= ro+dO*rd; //if rd.w =-c we look back in time as we march further away\n      \n      float dS=side*getDist(p.xyz); \n\n      dO+=dS;\n  \n      if(dO>MAX_DIST||dS<SURF){\n          break;\n      }\n      i++;\n    } \n    \n      return dO;\n}\n\nvec3 getNormal(vec3 p){\n   vec2 e= vec2(0.01,0);\n   float d=getDist(p);\n   vec3 n = d-vec3(getDist(p- e.xyy),getDist(p- e.yxy),getDist(p- e.yyx));\n   \n   return normalize(n);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = (iMouse.xy-.5)/iResolution.xy;\n    \n    if(int(iTime/20.)%2==1) RETARD=false;\n    \n    //ray origin in our moving coordinates:\n    RO=vec4(START,t);\n    float zoom= 1.;\n    \n    //look at in our moving coords:\n    vec4 lookAt;\n    if(RETARD) //what we actually see as light reaches our eyes:\n        lookAt = vec4(1, 0, 0, -c);\n    else //the instantaneous geometry of spacetime/coordinates: \n        lookAt = vec4(1, 0, 0, 0);\n        \n        \n    if(t>7.)\n        lookAt.xz*=rot(-PI*smoothstep(0.,2., t-7.));\n    if(t>11.)\n        lookAt.xz*=rot(-PI*smoothstep(0.,2., t-11.));\n\n    if(sign(iMouse.z)>0.){\n        lookAt.xy*=rot((m.y-.5)*2.*PI);\n        lookAt.xz*=rot(-(m.x-.5)*2.*PI);\n    }\n    \n    //ray direction into lab coordinates\n    vec4 rd= Lorentz(speed*c)*getRayDir(uv, lookAt, zoom);    \n    \n    //ray origin into lab coordinates:\n    vec4 p=Lorentz(speed*c)*RO;\n    \n    \n    \n    //the usual raymarch in lab coords:\n    float d= RayMarch(p, rd, 1.);\n    \n    \n     if(d<MAX_DIST){ //if we hit an object:\n          p= p+ d*rd;\n          col=color(speed*dot(normalize(rd.xyz), vec3(1,0,0)));\n\n          vec3 n= getNormal(p.xyz);\n      \n          float dif= dot(n, normalize(vec3(-3,2,1)))*.5+.5;\n          col/=d*.3;\n          col*=dif*dif;            \n      \n    }\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}