{"ver":"0.1","info":{"id":"MsBfWR","date":"1500020090","viewed":126,"name":"holo 1","username":"loganz","description":"holo","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["procedural","2d","noise","perlin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_ES\nprecision mediump float;\nprecision mediump int;\n#endif\n\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\nfloat grad(float hash, vec3 pos) {\n    float h = floor(mod(hash, 16.0));\n    float u = h<8.0 ? pos.x : pos.y,\n          v = h<4.0 ? pos.y : h==12.0||h==14.0 ? pos.x : pos.z;\n    return (mod(h, 2.0) == 0.0 ? u : -u) + (mod(h, 4.0) == 0.0 ? v : -v);\n}\nhighp float rand(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\nfloat hashx(float x) {return rand(vec2(x, x * 1.121)) * 256.0;}\nfloat hash(float x) {return mod(x * 15531.13513 + x * x * 24.98981, 256.0);}\nfloat lerp(float t, float a, float b) {return a+t*(b-a);}\n\nfloat cnoise(vec3 pos){\n    vec3 ipos = mod(floor(pos), 256.0);\n    pos = fract(pos);\n    vec3 faded = fade(pos);\n    \n    float A = hash(ipos.x)+ipos.y, AA = hash(A)+ipos.z, AB = hash(A+1.0)+ipos.z;\n    float B = hash(ipos.x+1.0)+ipos.y, BA = hash(B)+ipos.z, BB = hash(B+1.0)+ipos.z;\n\n    //gradient values\n    float g0 = grad(hash(AA), pos);\n    float g1 = grad(hash(BA), pos-vec3(1.0,0.0,0.0));\n    float g2 = grad(hash(AB), pos-vec3(0.0,1.0,0.0));\n    float g3 = grad(hash(BB), pos-vec3(1.0,1.0,0.0));\n    float g4 = grad(hash(AA+1.0), pos-vec3(0.0,0.0,1.0));\n    float g5 = grad(hash(BA+1.0), pos-vec3(1.0,0.0,1.0));\n    float g6 = grad(hash(AB+1.0), pos-vec3(0.0,1.0,1.0));\n    float g7 = grad(hash(BB+1.0), pos-vec3(1.0,1.0,1.0));\n    return lerp(faded.z, lerp(faded.y, lerp(faded.x, g0, g1), lerp(faded.x, g2, g3)), lerp(faded.y, lerp(faded.x, g4, g5), lerp(faded.x, g6, g7)));\n}\n\nconst float SPARKLE_INTENSITY = 0.8;\nconst float SPARKLE_SCALE = 0.5;\nconst float SPARKLE_SPEED = 0.917;\nconst float SHIMMER_SCALE = 0.00075;\nconst float SHIMMER_SPEED = 0.21;\nconst vec3 SHIMMER_COLOR = vec3(0.9, 0.4, 0.7) * 0.6;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float dY = iTime * 0.1;\n    vec2 angle = iMouse.xy / iResolution.xy * 0.5 * vec2(12.0, 3.0) + vec2(17.12367, 91.77);\n    vec3 coord = vec3(1723.23, 91.2998, 272.122) * vec3(iResolution.xy, 1.0);\n    coord += vec3(fragCoord.xy, 0.0);\n\n    vec3 sparkle, shimmer;\n    sparkle.r = cnoise(coord * vec3(SPARKLE_SCALE) + vec3(0.9112, 0.712 + dY, angle.y*SPARKLE_SPEED + angle.x*SPARKLE_SPEED*3.0/8.0 + 0.17));\n    sparkle.g = cnoise(coord * vec3(SPARKLE_SCALE) + vec3(0.9112, 0.712*2.0 + dY, angle.y*SPARKLE_SPEED + angle.x*SPARKLE_SPEED*3.0/8.0 + 0.17));\n    sparkle.b = cnoise(coord * vec3(SPARKLE_SCALE) + vec3(0.9112, 0.712*3.0 + dY, angle.y*SPARKLE_SPEED + angle.x*SPARKLE_SPEED*3.0/8.0 + 0.17));\n    sparkle += 0.5;\n    sparkle *= sparkle;\n    sparkle *= sparkle;\n    sparkle *= SPARKLE_INTENSITY;\n\n    shimmer.r = cnoise(coord * vec3(SHIMMER_SCALE) + vec3(angle.x*SHIMMER_SPEED, 0.0 + dY, angle.y*SHIMMER_SPEED + 0.27));\n    shimmer.g = cnoise(coord * vec3(SHIMMER_SCALE) + vec3(angle.x*SHIMMER_SPEED*1.721, 1.711 + dY, angle.y*SHIMMER_SPEED + 0.27));\n    shimmer.b = cnoise(coord * vec3(SHIMMER_SCALE) + vec3(angle.x*SHIMMER_SPEED*0.914, 1.711*2.0 + dY, angle.y*SHIMMER_SPEED + 0.27));\n    shimmer += 0.5;\n    shimmer *= SHIMMER_COLOR;\n    fragColor = vec4(sparkle + shimmer, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}