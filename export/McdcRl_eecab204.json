{"ver":"0.1","info":{"id":"McdcRl","date":"1731044182","viewed":98,"name":"klhjljlkjnklojhl","username":"TestCoder","description":"wesrtdrtg","likes":1,"published":3,"flags":0,"usePreview":0,"tags":["g"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ShaderToy version\n\n// Función de ruido mejorada utilizando una textura de ruido en iChannel0\nfloat noise(vec2 p) {\n    return texture(iChannel0, p * 0.1).r;\n}\n\nfloat fbm(vec2 p) {\n    float f = 0.0;\n    float amp = 0.5;\n    for (int i = 0; i < 5; i++) {\n        f += amp * noise(p);\n        p = p * 2.0;\n        amp *= 0.5;\n    }\n    return f;\n}\n\n// Función para calcular el conjunto de Mandelbrot\nfloat mandelbrot(vec2 c) {\n    vec2 z = vec2(0.0);\n    int maxIter = 100;\n    int i;\n    for(i = 0; i < maxIter; i++) {\n        z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;\n        if(dot(z,z) > 4.0) break;\n    }\n    return float(i) / float(maxIter);\n}\n\nvec3 neonPalette(float t) {\n    // Paleta de colores brillantes\n    return vec3(0., -.2, 0.5 + 6.5 * sin(6.2831 * (t + vec3(0.0, 3.33, 99.66))));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Coordenadas normalizadas de píxel en el rango [-1, 1]\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    // Variable de tiempo\n    float t = iTime * 0.1;\n\n    // **Deformación del espacio en una forma fluida no euclidiana**\n    vec2 distortion = fbm(uv * 3.0 + t) * vec2(0.5, 0.5);\n    uv += distortion;\n\n    // **Cálculo del conjunto de Mandelbrot**\n    vec2 c = uv * vec2(3.5, 2.0) + vec2(-2.5, -1.0);\n    float m = mandelbrot(c);\n\n    // **Color de neón basado en el Mandelbrot**\n    vec3 neonColor = neonPalette(m);\n    neonColor *= pow(1.0 - m, 3.0); // Intensidad de brillo de neón\n\n    // Inicializar color\n    vec3 col = vec3(0.0);\n\n    // Coordenadas polares\n    float r = length(uv);\n    float angle = atan(uv.y, uv.x);\n\n    // Movimiento de la espiral con el tiempo\n    float spiral = angle + r * 8.0 - t * 2.0 + sin(t + r * 5.0) * 0.5;\n    float arms = sin(spiral * 3.0);\n\n    // Nebulosa nubosa usando fbm\n    float n = fbm(uv * 5.0 + vec2(t * 0.5, t * 0.3));\n\n    // Intensidad de la nebulosa y mezcla de colores\n    float nebulaIntensity = exp(-pow(r * 1.5, 2.0)) * arms * n;\n\n    // **Incorporar el valor de Mandelbrot en la intensidad de la nebulosa**\n    nebulaIntensity *= pow(1.0 - m, 2.0);\n\n    nebulaIntensity = smoothstep(0.0, 1.0, nebulaIntensity);\n\n    // Colores rosa pastel y dorado\n    vec3 pastelPink = vec3(1.0, 0.7, 0.85);\n    vec3 gold = vec3(1.0, 0.85, 0.5);\n\n    // Mezclar colores como en una pintura\n    vec3 nebulaColor = mix(pastelPink, gold, n);\n\n    // **Mezclar el color de neón con el color de la nebulosa**\n    nebulaColor = mix(nebulaColor, neonColor, 0.5);\n\n    // Aplicar color de la nebulosa\n    col += nebulaIntensity * nebulaColor;\n\n    // Brillo del núcleo\n    float coreGlow = exp(-pow(r * 4.0, 2.0));\n    vec3 coreColor = gold;\n    col += coreGlow * coreColor;\n\n    // Ajustes finales de color\n    col = pow(col, vec3(0.4545));\n\n    // Salida del color\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}