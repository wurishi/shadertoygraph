{"ver":"0.1","info":{"id":"7ltGz7","date":"1635920389","viewed":207,"name":"Voxel Ray Marcher","username":"sangolemango","description":"Ray marching voxels using signed distance fields.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["voxel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define RENDER_DISTANCE 100\n#define MIN_DISTANCE 0.02\n\n#define VOXEL_SIZE vec3(0.25, 0.25, 0.25)\n\nstruct Ray \n{\n    vec3 origin;\n    vec3 direction;\n};\n\nRay createViewRay(vec2 uv) \n{\n    Ray viewRay;\n    \n    viewRay.origin = vec3(cos(iTime) * 1.5, sin(iTime), -5);\n    viewRay.direction = normalize(vec3(uv.x, uv.y, 1));\n    \n    return viewRay;\n}\n\nfloat sphereSDF(vec3 eye, float radius) \n{\n    return length(eye) - radius;\n}\n\nfloat sceneSDF(vec3 eye) \n{\n    return sphereSDF(eye, 1.0);\n}\n\nvec3 getNormal(vec3 eye) \n{\n    vec2 epsilon = vec2(MIN_DISTANCE, 0);\n\n    vec3 normal = sceneSDF(eye) - vec3\n    (\n        sceneSDF(eye - epsilon.xyy),\n        sceneSDF(eye - epsilon.yxy),\n        sceneSDF(eye - epsilon.yyx)\n    );\n\n    return normalize(normal);\n}\n\nvec3 voxelRayMarch(Ray ray) \n{\n    vec3 position = ray.origin / VOXEL_SIZE;\n    vec3 voxelPos = floor(position);\n\n    vec3 stepDir = sign(ray.direction);\n\n    vec3 delta = VOXEL_SIZE / ray.direction;\n    \n    vec3 maxDist = vec3\n    (\n        stepDir.x > 0.0 ? voxelPos.x + 1.0 - position.x : position.x - voxelPos.x,\n        stepDir.y > 0.0 ? voxelPos.y + 1.0 - position.y : position.y - voxelPos.y,\n        stepDir.z > 0.0 ? voxelPos.z + 1.0 - position.z : position.z - voxelPos.z\n    );\n    \n    maxDist *= delta;\n\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 eye = voxelPos * VOXEL_SIZE + VOXEL_SIZE / 2.0;\n\n        float distToScene = sceneSDF(eye);\n        if (distToScene < MIN_DISTANCE)\n            return getNormal(eye); \n\n        vec3 absMax = abs(maxDist);\n        \n        if(absMax.x < absMax.y && absMax.x < absMax.z)\n        {\n            voxelPos.x += stepDir.x;\n            maxDist.x += delta.x;\n        }\n        else if(absMax.y < absMax.z)\n        {\n            voxelPos.y += stepDir.y;\n            maxDist.y += delta.y;\n        }\n        else \n        {\n            voxelPos.z += stepDir.z;\n            maxDist.z += delta.z;\n        }\n    }\n    \n    return ray.direction;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    \n    Ray viewRay = createViewRay(uv);\n    \n    fragColor = vec4(voxelRayMarch(viewRay), 1.0);\n}","name":"Image","description":"","type":"image"}]}