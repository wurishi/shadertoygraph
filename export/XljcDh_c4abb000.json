{"ver":"0.1","info":{"id":"XljcDh","date":"1509052499","viewed":1073,"name":"2d signed distance functions v2","username":"tholzer","description":"Test stuff for antialaised '2d signed distance functions' \nVersion 2 with corrected scaling and small improvements!\nSet 2nd light position with mouse.\n3nd row: sub, and, or, soft or, xor, arc. ","likes":32,"published":1,"flags":0,"usePreview":0,"tags":["2d","shadow","distance","occlusion","penumbra","ambient","soft","signed"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// 2dDistanceFunctionsV2.glsl\n\n/**\n original:   https://www.shadertoy.com/view/4dfXDn by Maarten 2015-Aug-17\n\n Hi all,\tThis is just my playground for a bunch of 2D stuff:\n Some distance functions and blend functions\n Cone marched 2D Soft shadows\n Use the mouse to control the 2nd light\n\n tags: 2d, shadow, distance, occlusion, penumbra, ambient, soft, signed \n\n v2.0  2017-10-29  improved version\n v2.1  2017-11-06  sdEllipse, pumpkin2D & flower added\n       2017-12-01  working on... \n\n references: \n \n  - 2d-Primitive collection\n      https://www.shadertoy.com/view/MssyRN \n\n  - modeling with distance functions\n      https://iquilezles.org/articles/distfunctions\n\n  - ellipse distance by Inigo Quilez\n      https://iquilezles.org/articles/ellipsedist\n*/\n\n\n#define BORDER_THICKNESS 2.5\n\nconst vec4 fillColor   = vec4(1.0, 0.4, 0.0, 1.0);   // orange\nconst vec4 borderColor = vec4(0.1, 0.1, 0.1, 1.0);   // darkgray\n\nconst float HALF_PI = 1.57079632679;\nconst float      PI = 3.14159265359;\nconst float  TWO_PI = 6.28318530718;\n\nvec2 uv = vec2(0);  // centered pixel position -1 .. 1\n\n//////////////////////////////////////\n// Combine distance field functions //\n//////////////////////////////////////\n\nfloat smoothMerge(float d1, float d2, float k)\n{\n    float h = clamp(0.5 + 0.5*(d2 - d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0-h);\n}\n\nfloat merge(float d1, float d2)\n{\n\treturn min(d1, d2);\n}\n\nfloat mergeExclude(float d1, float d2)\n{\n\treturn min(max(-d1, d2), max(-d2, d1));\n}\n\nfloat substract(float d1, float d2)\n{\n\treturn max(-d1, d2);\n}\n\nfloat intersect(float d1, float d2)\n{\n\treturn max(d1, d2);\n}\n\n//////////////////////////////\n// Rotation and translation //\n//////////////////////////////\n\nvec2 rotateCCW (vec2 pos, float angle)\n{ float ca = cos(angle),  sa = sin(angle);\n  return pos * mat2(ca, sa, -sa, ca);  }\n\n\nvec2 rotateCW (vec2 pos, float angle)\n{ float ca = cos(angle),  sa = sin(angle);\n  return pos * mat2(ca, -sa, sa, ca);  }\n\n\nvec2 translate(vec2 p, vec2 t) \n{ return p - t; }\n\n\n//////////////////////////////\n// Distance field functions //\n//////////////////////////////\n\nfloat pie(vec2 p, float angle)\n{\n  angle = radians(angle) / 2.0;\n  return abs(p.x) * sin(angle) + p.y*cos(angle);\n}\n\nfloat sdCircle (vec2 p, float radius)\n{\n  return length(p) - radius;\n}\n\nfloat triangleDist(vec2 p, float radius)\n{\n  return max( abs(p.x) * 0.866025 + p.y * 0.5, -p.y) -radius * 0.5;\n}\n\nfloat triangleDist(vec2 p, float width, float height)\n{\n  vec2 n = normalize(vec2(height, width / 2.0));\n  return max(\tabs(p).x*n.x + p.y*n.y - (height*n.y), -p.y);\n}\n\nfloat semiCircleDist(vec2 p, float radius, float angle, float width)\n{\n  width /= 2.0;\n  radius -= width;\n  return substract(pie(p, angle + sin(iTime)*55.), \n                       abs(length(p) - radius) - width);\n}\n\n//---------------------------------------------------------\nfloat lineDist(vec2 p, vec2 start, vec2 end, float width)\n{\n  vec2 dir = start - end;\n  float lngth = length(dir);\n  dir /= lngth;\n  vec2 proj = max(0.0, min(lngth, dot((start - p), dir))) * dir;\n  return length( (start - p) - proj ) - (width / 2.0);\n}\n\n//---------------------------------------------------------\n// IQ's signed distance to a 2D rounded box\n//---------------------------------------------------------\nfloat sdBox(in vec2 p, in vec2 size, in float radius)\n{\n  vec2 d = abs(p) - size + radius;\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;\n}\n\n//---------------------------------------------------------\n// IQ's signed distance to ellipse\n//---------------------------------------------------------\nfloat sdEllipse(in vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\t\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n\t\n    float m = ab.x*p.x/l; \n\tfloat n = ab.y*p.y/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\t\n    float c = (m2 + n2 - 1.0)/3.0; \n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx) + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 r = ab * vec2(co,si);\n\t\n    return length(r-p) * sign(p.y-r.y);\n}\n\n//---------------------------------------------------------\n// draw polygon with given radius n edges at pos \n//---------------------------------------------------------\nfloat polygon(vec2 p, float radius, float vertices)\n{\n  float angle = atan(p.x, -p.y) + TWO_PI;\n  float r = TWO_PI / vertices;\n  return cos(floor(0.5 + angle / r) * r - angle) * length(p) - radius;\n}\n//---------------------------------------------------------\nfloat flower(vec2 p, float radius, float leafs)\n{\n  return 25.*(length(p)/radius - 0.4*sin(leafs*(atan(p.y,p.x)-iTime)) -0.75);\n}\n//---------------------------------------------------------\n// https://www.shadertoy.com/view/4tBcRV\n//---------------------------------------------------------\nfloat pumpkin2D(vec2 p, float radius, float vertices, float curvature)\n{\n  float angle = atan(p.x, -p.y) / TWO_PI * vertices;\n  return length(p) -radius +smoothstep(0., 1., abs(fract(angle)-0.5)) *radius *curvature;\n}\n//---------------------------------------------------------\nfloat PacMan (vec2 p, float radius)  // toDo need correction\n{\n  float d = length(p);   // get distance of current coordinate\n  float circle = d - radius;   // basic circle\n  // smooth paint if coordinate is inside circle and outside the mouth\n  float mouth = smoothstep(p.x/d, p.x/d-0.1, 0.2*sin(iTime*12.)+0.84);\n  if (mouth < circle) return circle;\n  return max(circle, 4.0*mouth);  // what's wrong ???\n}\n\n\n///////////////////////\n// Masks for drawing //\n///////////////////////\n\nfloat fillMask(float dist)\n{\n\treturn clamp(-dist, 0.0, 1.0);\n}\n\nfloat innerBorderMask(float dist, float width)\n{\n\t//dist += 1.0;\n\treturn clamp(dist + width, 0.0, 1.0) - clamp(dist, 0.0, 1.0);\n}\n\nfloat outerBorderMask(float dist, float width)\n{\n\t//dist += 1.0;\n\treturn clamp(dist, 0.0, 1.0) - clamp(dist - width, 0.0, 1.0);\n}\n\n\n///////////////\n// The scene //\n///////////////\n\nfloat sceneDistance(vec2 p)  // p: position\n{\n    //=== 1st row ===\n    int yd = 340;\n    \n    float ts = sin(iTime)*.49+.49;\n    float edges = 4. + floor(8. * ts);  \n\n    float  m = polygon(\t\t\ttranslate(p, vec2(100, yd)), 40.0, edges);\n//    float  m = PacMan(\t\t\ttranslate(p, vec2(100, yd)), 35.0);\n    \n    float p1 = pumpkin2D(\t\ttranslate(p, vec2(200, yd)), 35.0, edges, -0.5);\n    float s1 = pumpkin2D(\t\ttranslate(p, vec2(300, yd)), 40.0, edges, +0.4);\n\tfloat bb = sdBox(\t\t\ttranslate(p, vec2(400, yd)), vec2(40, 20), 10.0);\n//    float e1 = sdEllipse(\t\ttranslate(p, vec2(500, yd)), vec2(40, 20));\n    float f1 = flower(          translate(p, vec2(500, yd)), 40., edges);\n    \n    vec2        pt = rotateCW ( translate(p, vec2(600, yd)), iTime);\n    float e2 = sdEllipse(\t\tpt, vec2(40, 20));\n    \n    m = merge(m, p1); // not working \n    m = merge(m, s1); \n    m = merge(m, bb); \n    m = merge(m, f1); \n    m = merge(m, e2); \n    \n    //=== 2nd row ===\n    yd = 210;\n    \n    float c1 = sdCircle(\t\ttranslate(p, vec2(100, yd)), 40.0);\n\tfloat b1 = sdBox(\t\t\ttranslate(p, vec2(200, yd)), vec2(40, 40),  0.0);\n\tfloat b2 = sdBox(\t\t\ttranslate(p, vec2(300, yd)), vec2(40, 40), 10.0);\n\n               pt = rotateCCW( translate(p, vec2(400, yd)), iTime);\n\tfloat l1 = lineDist(\t\tpt,  vec2(-30, -30),  vec2(30, 30),\t10.0);\n\n                pt = rotateCW(  translate(p, vec2(500, yd-40)), 0.5*sin(iTime));\n    float t1 = triangleDist(\tpt, 60.0, 80.0);\n\n                pt = rotateCW(  translate(p, vec2(600, yd)), iTime);\n\tfloat t2 = triangleDist(\tpt, 40.0);\n\t\n    m = merge(m, c1);  // circle\n    m = merge(m, b1);  // square\n\tm = merge(m, b2);  // rounded box\n\tm = merge(m, l1);  // line\n\tm = merge(m, t1);  // triangle 1\n\tm = merge(m, t2);  // triangle 2\n\t\n    //=== 3nd row ===\n    float yr = 80.;\n    \n\t// circle - rectangle\n    float b3 = sdBox(\t\ttranslate(p, vec2(100, yr + sin(iTime * 3.0 + 1.0) * 40.0)), \n\t\t\t\t\t   \t\tvec2(40, 15), \t0.0);\n\tfloat c2 = sdCircle(\ttranslate(p, vec2(100, yr)),\t30.0);\n\tfloat sub = substract(b3, c2);\n\t\n    // circle and rectangle\n\tfloat b4 = sdBox(\t\ttranslate(p, vec2(200, yr + sin(iTime * 3.0 + 2.0) * 40.0)), \n\t\t\t\t\t   \t\tvec2(40, 15), \t0.0);\n\tfloat c3 = sdCircle(\ttranslate(p, vec2(200, yr)), \t30.0);\n\tfloat and = intersect(b4, c3);\n\t\n\t// circle or rectangle\n    float b5 = sdBox(\t\ttranslate(p, vec2(300, yr + sin(iTime * 3.0 + 3.0) * 40.0)),\n                            vec2(40, 15), \t0.0);\n\tfloat c4 = sdCircle(\ttranslate(p, vec2(300, yr)), \t30.0);\n\tfloat or = merge(b5, c4);\n\t\n\t// soft circle or rectangle\n\tfloat b6 = sdBox(\t\ttranslate(p, vec2(400, yr + sin(iTime * 1.0) * 20.0)),\n                            vec2(40, 15), \t0.0);\n\tfloat c5 = sdCircle(\ttranslate(p, vec2(400, yr)), \t30.0);\n\tfloat sor = smoothMerge(b6, c5, 10.0);\n\t\n\t// circle xor rectangle\n    float b7 = sdBox(\t\ttranslate(p, vec2(500, yr + sin(iTime * 3.0 + 3.0) * 40.0)),\n                            vec2(40, 15), \t0.0);\n\tfloat c6 = sdCircle(\ttranslate(p, vec2(500, yr)), \t30.0);\n\tfloat xor = mergeExclude(b7, c6);\n    \n\t// arc\n\tfloat arc = semiCircleDist(translate(p, vec2(600,yr)), 40.0, 90.0, 10.0);\n    \n\tm = merge(m, sub);  // sub \n\tm = merge(m, and);  // and \n\tm = merge(m, or);   // or\n\tm = merge(m, sor);  // soft or\n    m = merge(m, xor);  // xor\n\tm = merge(m, arc);  // arc\n\n\treturn m;\n}\n\nfloat sceneSmooth(vec2 p, float r)\n{\n\tfloat accum = sceneDistance(p);\n\taccum += sceneDistance(p + vec2(0.0, r));\n\taccum += sceneDistance(p + vec2(0.0, -r));\n\taccum += sceneDistance(p + vec2(r, 0.0));\n\taccum += sceneDistance(p + vec2(-r, 0.0));\n\treturn accum; // / 5.0;\n}\n\n\n//////////////////////\n// Shadow and light //\n//////////////////////\n\nfloat shadow(vec2 p, vec2 pos, float radius)\n{\n\tvec2 dir = normalize(pos - p);\n\tfloat dl = length(p - pos);\n\t\n\t// fraction of light visible, starts at one radius (second half added in the end);\n\tfloat lf = radius * dl;\n\t\n\t// distance traveled\n\tfloat dt = 0.01;\n\n\tfor (int i = 0; i < 64; ++i)\n\t{\t\t\t\t\n\t\t// distance to scene at current position\n\t\tfloat sd = sceneDistance(p + dir * dt);\n\n        // early out when this ray is guaranteed to be full shadow\n        if (sd < -radius) \n          return 0.0;\n        \n\t\t// width of cone-overlap at light\n\t\t// 0 in center, so 50% overlap: add one radius outside of loop to get total coverage\n\t\t// should be '(sd / dt) * dl', but '*dl' outside of loop\n\t\tlf = min(lf, sd / dt);\n\t\t\n\t\t// move ahead\n\t\tdt += max(1.0, abs(sd));\n\t\tif (dt > dl) break;\n\t}\n\t// multiply by dl to get the real projected overlap (moved out of loop)\n\t// add one radius, before between -radius and + radius\n\t// normalize to 1 ( / 2*radius)\n\tlf = clamp((lf*dl + radius) / (2.0 * radius), 0.0, 1.0);\n\tlf = smoothstep(0.0, 1.0, lf);\n\treturn lf;\n}\n\nvec4 drawLight(vec2 p, vec2 pos, vec4 color, float dist, float range, float radius)\n{\n\t// distance to light\n\tfloat ld = length(p - pos);\n\t\n\t// out of range ?\n\tif (ld > range) return vec4(0.0);\n\t\n\t// shadow and falloff\n\tfloat shad = shadow(p, pos, radius);\n\tfloat fall = (range - ld)/range;\n\tfall *= fall;\n\tfloat source = fillMask(sdCircle(p - pos, radius));\n\treturn (shad * fall + source) * color;\n}\n\nfloat luminance(vec4 col)\n{\n\treturn 0.2126 * col.r + 0.7152 * col.g + 0.0722 * col.b;\n}\n\nvoid setLuminance(inout vec4 col, float lum)\n{\n\tlum /= luminance(col);\n\tcol *= lum;\n}\n\nfloat AO(vec2 p, float dist, float radius, float intensity)\n{\n\tfloat a = clamp(dist / radius, 0.0, 1.0) - 1.0;\n\treturn 1.0 - (pow(abs(a), 5.0) + 1.0) * intensity + (1.0 - intensity);\n\treturn smoothstep(0.0, 1.0, dist / radius);\n}\n\n\n/////////////////\n// The program //\n/////////////////\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float rx = iResolution.x;\n\tvec2 uv = 700. * (fragCoord.xy + vec2(0.5)) / rx;\n\tvec2 mp = (iMouse.xy) * 700. / rx;\n\t\n\tfloat dist = sceneDistance(uv);\n\t\n    // mouse light \n\tvec2 light1Pos = mp.xy;\n\tvec4 light1Col = vec4(0.75, 1.0, 0.5, 1.0);\n\tsetLuminance(light1Col, 0.4);\n\t\n\t// moving light\n    vec2 light2Pos = vec2(rx * (sin(iTime + 3.1415) + 1.2) / 2.4, 150.0);\n\tvec4 light2Col = vec4(1.0, 0.75, 0.5, 1.0);\n\tsetLuminance(light2Col, 0.5);\n\t\n//\tvec2 light3Pos = vec2(rx * (sin(iTime) + 1.2) / 2.4, 340.0);\n//\tvec4 light3Col = vec4(0.5, 0.75, 1.0, 1.0);\n//\tsetLuminance(light3Col, 0.6);\n\t\n\t// gradient\n\tvec4 col = vec4(0.5, 0.5, 0.5, 1.0) * (1.0 - length(iResolution.xy/1.4 - uv)/rx);\n\t// grid\n\tcol *= clamp(min(mod(uv.y, 10.0), mod(uv.x, 10.0)), 0.9, 1.0);\n\t// ambient occlusion\n\tcol *= AO(uv, sceneSmooth(uv, 10.0), 40.0, 0.4);\n\t//col *= 1.0-AO(uv, sceneDistance(uv), 40.0, 1.0);  // object lightning\n\n    // light\n\tcol += drawLight(uv, light1Pos, light1Col, dist, 150.0, 6.0);\n\tcol += drawLight(uv, light2Pos, light2Col, dist, 200.0, 8.0);\n//\tcol += drawLight(uv, light3Pos, light3Col, dist, 300.0, 12.0);\n\n    col = mix(col, fillColor, fillMask(dist));\n\tcol = mix(col, borderColor, innerBorderMask(dist, BORDER_THICKNESS));\n\n\tfragColor = clamp(col, 0.0, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}