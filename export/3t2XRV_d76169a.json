{"ver":"0.1","info":{"id":"3t2XRV","date":"1566456881","viewed":1085,"name":"Simple NTSC Decoder","username":"xot","description":"Analog-style NTSC decoder. Generates Apple ][-like color bars signal in Buffer A. Then decodes it like a composite television signal, producing color artifacts from the original high-frequency signal.","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["binary","video","nes","cga","apple","ntsc","composite","artifact","decoder"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//  Simple NTSC Decoder\n//\n//  Decodes composite video signal generated in Buffer A.\n//\tSimplified fork of an earlier NTSC decoder shader.\n//\n//  copyright (c) 2017-2020, John Leffingwell\n//  license CC BY-SA Attribution-ShareAlike\n\n#define TAU  6.28318530717958647693\n\n//\tColorspace conversion matrix for YIQ-to-RGB\nconst mat3 YIQ2RGB = mat3(1.000, 1.000, 1.000,\n                          0.956,-0.272,-1.106,\n                          0.621,-0.647, 1.703);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 size = iChannelResolution[0].xy;\n\tvec2 uv = fragCoord.xy / size;\n    \n    if (uv.y < 0.1 || uv.y > 0.9) {\n        \n        //  Display original signal in the margins\n    \tfragColor = vec4(texture(iChannel0, uv).rgb, 1.0);\n        \n    } else {\n        \n        //\tSample composite signal and decode to YIQ\n        vec3 YIQ = vec3(0);\n        for (int n=-2; n<2; n++) {\n            vec2 pos = uv + vec2(float(n) / size.x, 0.0);\n            float phase = (fragCoord.x + float(n)) * TAU / 4.0;\n            YIQ += texture(iChannel0, pos).rgb * vec3(1.0, cos(phase), sin(phase));\n        }\n        YIQ /= 4.0;\n        \n        //  Convert YIQ signal to RGB\n        fragColor = vec4(YIQ2RGB * YIQ, 1.0);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//  Apple II lores color bars generated by 4-bit patterns.\n//\n//  Generates a high-frequency, 1-bit deep lumanance signal.\n//  Color is generated by NTSC composite color artifacting.\n//\n//\tcopyright (c) 2017, John Leffingwell\n//  license CC BY-SA Attribution-ShareAlike\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float pixel = floor(fragCoord.x);\n   \tfloat value = floor(16.0 * fragCoord.x / iResolution.x);\n    float power = exp2(mod(pixel, 4.0));\n    float bitvalue = step(power, mod(value, 2.0 * power));\n\n    fragColor = vec4(vec3(bitvalue), 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}