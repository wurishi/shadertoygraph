{"ver":"0.1","info":{"id":"WdlGR8","date":"1544924375","viewed":102,"name":"Video Ray-March Pong","username":"Crazybytes","description":"Cool man","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","video","pong"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592653589793\n\nconst float camera_pos=-4.0;\nvec2 uv2;\nvec2 uv;\nfloat diff2;\nfloat T;\nvec2 Resolution;\nint horizon=0;\n\n//https://www.johndcook.com/blog/2010/01/20/how-to-compute-the-soft-maximum/\nfloat SoftMaximum(float x, float y)\n{\n\tfloat maximum = max(x, y);\n\tfloat minimum = min(x, y);\n\treturn maximum + log( 1.0 + exp(minimum - maximum) );\n}\n\n//https://www.johndcook.com/blog/2010/01/13/soft-maximum/\nfloat smax( float a, float b, float k )\n{\n    return log( exp(a*k) + exp(b*k) ) / k;\n}\n\n//https://iquilezles.org/articles/smin\n// polynomial smooth min (k = 0.1);\nfloat sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 );\n    return min( a, b ) - h*h*h/(6.0*k*k);\n}\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 );\n    return min( a, b ) - h*h*0.25/k;\n}\n// power smooth min (k = 8);\nfloat smin3( float a, float b, float k )\n{\n    a = pow( a, k ); b = pow( b, k );\n    return pow( (a*b)/(a+b), 1.0/k );\n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin2( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// exponential smooth min (k = 32);\nfloat smin1( float a, float b, float k )\n{\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\n\nfloat getVal(vec2 uv, vec2 delta)\n{\n//    return length(texture(texture_buffer,uv).xyz);\n    vec3 col=vec3(0.0);\n    col+=texture(iChannel0,uv).xyz*4.0;\n    col+=texture(iChannel0,uv+vec2(delta.x,0.0)        ).xyz*2.0;\n    col+=texture(iChannel0,uv+vec2(-delta.x,0.0)       ).xyz*2.0;\n    col+=texture(iChannel0,uv+vec2(0.0,delta.y)        ).xyz*2.0;\n    col+=texture(iChannel0,uv+vec2(0.0,-delta.y)       ).xyz*2.0;\n    col+=texture(iChannel0,uv+vec2(delta.x,delta.y)    ).xyz;\n    col+=texture(iChannel0,uv+vec2(-delta.x,delta.y)   ).xyz;\n    col+=texture(iChannel0,uv+vec2(delta.x,-delta.y)   ).xyz;\n    col+=texture(iChannel0,uv+vec2(-delta.x,-delta.y)  ).xyz;\n    col=col/16.0;\n    return length(col);\n}\n\nmat2 rotate(float a) {\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\n//http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/#signed-distance-functions\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nmat4 rotateXYZ(float theta_x, float theta_y, float theta_z) {\n    float c_x = cos(theta_x);\n    float s_x = sin(theta_y);\n    float c_y = cos(theta_x);\n    float s_y = sin(theta_y);\n    float c_z = cos(theta_x);\n    float s_z = sin(theta_y);\n\n    return mat4(\n        vec4(1, 0, 0, 0),\n        vec4(0, c_x, -s_x, 0),\n        vec4(0, s_x, c_x, 0),\n        vec4(0, 0, 0, 1)\n    ) *\n    mat4(\n        vec4(c_y, 0, s_y, 0),\n        vec4(0, 1, 0, 0),\n        vec4(-s_y, 0, c_y, 0),\n        vec4(0, 0, 0, 1)\n    ) *\n    mat4(\n        vec4(c_z, -s_z, 0, 0),\n        vec4(s_z, c_z, 0, 0),\n        vec4(0, 0, 1, 0),\n        vec4(0, 0, 0, 1)\n    );\n}\n\nmat4 rotateZYX(float theta_x, float theta_y, float theta_z) {\n    float c_x = cos(theta_x);\n    float s_x = sin(theta_y);\n    float c_y = cos(theta_x);\n    float s_y = sin(theta_y);\n    float c_z = cos(theta_x);\n    float s_z = sin(theta_y);\n\n    return mat4(\n        vec4(c_z, -s_z, 0, 0),\n        vec4(s_z, c_z, 0, 0),\n        vec4(0, 0, 1, 0),\n        vec4(0, 0, 0, 1)\n    ) *\n    mat4(\n        vec4(c_y, 0, s_y, 0),\n        vec4(0, 1, 0, 0),\n        vec4(-s_y, 0, c_y, 0),\n        vec4(0, 0, 0, 1)\n    ) *\n    mat4(\n        vec4(1, 0, 0, 0),\n        vec4(0, c_x, -s_x, 0),\n        vec4(0, s_x, c_x, 0),\n        vec4(0, 0, 0, 1)\n    );\n}\n\nmat4 projection(float theta) {\n\n    return mat4(\n        vec4(1, 0, 0, 0),\n        vec4(0, 1, 0, 0),\n        vec4(0, 0, 1, 0),\n        vec4(0, 0, 1.0/theta, 1)\n    );\n}\n\nmat4 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(c, 0, s, 0),\n        vec4(0, 1, 0, 0),\n        vec4(-s, 0, c, 0),\n        vec4(0, 0, 0, 1)\n    );\n}\nmat4 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(1, 0, 0, 0),\n        vec4(0, c, -s, 0),\n        vec4(0, s, c, 0),\n        vec4(0, 0, 0, 1)\n    );\n}\nmat4 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(c, -s, 0, 0),\n        vec4(s, c, 0, 0),\n        vec4(0, 0, 1, 0),\n        vec4(0, 0, 0, 1)\n    );\n}\n\n//float intersectSDF(float distA, float distB) {\n//float unionSDF(float distA, float distB) {\n//float differenceSDF(float distA, float distB) {\n\n//https://iquilezles.org/articles/distfunctions\nfloat disp(vec3 p,float n) {\n\tfloat t = T*5.0+n;\n//\tfloat f = 16.0+sin(t*0.53+1.0+n)*2.0;\n\tfloat f = 4.0;\n//\tp.xy=rotate(t*0.30)*p.xy;\n\treturn (.18) * cos( p.x * f + t ) * cos(p.z * f + t ) * cos( p.y * f + t ) ;\n//\treturn (.08+sin(t*0.67+2)/50.0) * cos( p.x * f  ) * cos(p.z * f + t ) * cos( p.y * f + t ) ;\n}\n\n//mat4 rotje=rotateXYZ(0.0,-T*0.1*2.0*PI,0.0);\n//mat4 rotje2=rotateZYX(0.0,-T*0.1*2.0*PI,0.0);\n\n\n//mat4 rotje=rotateX(-T*0.1*2.0*PI)*rotateY(0.0)*rotateZ(0.0);\n//mat4 rotje2=rotateZ(0.0)*rotateY(0.0)*rotateX(T*0.1*2.0*PI);\n\n//mat4 rotje=rotateX(0.5)*rotateY(0.5)*rotateZ(-T*0.1*2.0*PI);\n//mat4 rotje2=rotateZ(T*0.1*2.0*PI)*rotateY(5.0)*rotateX(0.5);\n\n//mat4 rotje=rotateX(-T*0.1*2.0*PI)*rotateY(0.0)*rotateZ(-T*0.1*2.0*PI);\n//mat4 rotje2=rotateZ(T*0.1*2.0*PI)*rotateY(0.0)*rotateX(T*0.1*2.0*PI);\n\n//mat4 rotje=rotateX(0.0)*rotateY(-T*0.1*2.0*PI)*rotateZ(-T*0.1*2.0*PI);\n//mat4 rotje2=rotateZ(T*0.1*2.0*PI)*rotateY(T*0.1*2.0*PI)*rotateX(0.0);\n\n//mat4 rotje2=rotateZYX(T*0.1*2.0*PI,T*0.1*2.0*PI,T*0.1*2.0*PI);\n//mat4 rotje=rotateXYZ(-T*0.1*2.0*PI,-T*0.1*2.0*PI,-T*0.1*2.0*PI);\n//mat4 rotje2=rotateZYX(T*0.1*2.0*PI,T*0.1*2.0*PI,T*0.1*2.0*PI);\n\nfloat map(vec3 p) {\n\tfloat d = 1.0E10;\n\thorizon=0;\n\tmat4 rotje=rotateX(-T*0.1*2.0*PI)*rotateY(-T*0.1*2.0*PI)*rotateZ(-T*0.1*2.0*PI);\n\tmat4 rotje2=rotateZ(T*0.1*2.0*PI)*rotateY(T*0.1*2.0*PI)*rotateX(T*0.1*2.0*PI);\n    \n//\tfloat d = 0.0;\n\tp.z=p.z+camera_pos; // keep object at origin.\n//\td = distance(p, vec3(0.0,0.0,+2.0) ) - 0.5 + disp(p);\n//\td = unionSDF(d,        sdSphere(p+vec3(0.0,0.0,0.0) ,0.5) + disp(p)/2.0)   ;\n//\td = unionSDF(d,        distance(p, vec3(0.0,0.0,-0.5 ) )  - 0.2 + disp(p.zxy)/2.0 )   ;\n\n//\td = unionSDF(d,        sdSphere(p+vec3(0.0,0.0,0.0),1.0) + disp(p) )   ;\n\n//a\td = unionSDF(d,        sdSphere(p+vec3(0.0,0.0,0.0),1.0) )   ;\n\n//    vec3 cylinder = (rotateX(-T*0.10*2.0*PI) * vec4(p.x,p.y,p.z, 1.0)).xyz;\n//\td = unionSDF( d,  sdCappedCylinder(cylinder,vec2(.50,1.15)) - 0.2 );\n\n//\td = smax( d ,- sdCappedCylinder(cylinder,vec2(.40,1.4)) - 0.0 , 8 );\n\n\n//  vec3 cylinder = (rotateX(T) * vec4(p.x,p.y,p.z, 1.0)).xyz;\n//\td = sdCappedCylinder(cylinder,vec2(.50,3.0)) - 0.3 ;\n\n/*\n    cylinder = (rotateZ(0.5*PI) * rotje2 * vec4(p.x,p.y,p.z, 1.0)).xyz;\n\tfloat d2 = sdCappedCylinder(cylinder,vec2(.50,2.0)) - 0.3 ;\n\n    d = smin( d, d2, .2);\n\n    cylinder = (rotateZ(0.5*PI) * rotateY(0.5*PI) * rotje2 * vec4(p.x,p.y,p.z, 1.0)).xyz;\n\td2 = sdCappedCylinder(cylinder,vec2(.30,2.0)) - 0.3 ;\n\n    d = smax( d, -d2, 8);\n\n//    d = smin( d, d2, .2);\n\n*/\n//    d2 = 1.0E10;\n\n//    for (int x=0; x<10; x++) {\n//        float ff=float(x);\n//        d = smin(d, sdSphere(p + (  rotje * vec4( sin(T*0.354*ff), sin(T*0.452*ff),sin(T*0.399*ff)  ,  1.0)).xyz    ,\n//                             2.0 ) +disp(p,1.0) // size sphere\n//                  ,.4)   ;\n//    }\n\n//\td =  smax ( sdSphere(p+   vec3(0.0,0.0,0.0),2.0), -d ,8);\n\td =  disp(p,0.0)*sin(T/3.0)*0.3+sdSphere(p+   vec3(0.0,0.0,0.0),2.5 + sin(T/3.0)/3.0 ) ;\n\nfor (int x=0; x<15; x++) {\n        float ff=float(x);\n        float where=mod(T*0.22+ff*ff,2.0*PI);\n        if ((where<PI*0.5 || (where>PI && where<1.5*PI)) ) {\n                float d2 = ( disp(p,1.0)*(1.0+sin(T))+1.0-(0.5+sin(2.0*where+.5*PI)/2.0) ) +sdSphere(p +  ( \n\t                rotateX(ff+T*0.33) * rotateY(ff+T*0.45) * rotateZ(ff+T*0.56) * vec4(\n                    0.0+sin(where)*1.0,\n    \t            0.0+sin(where)*1.0,\n        \t        0.0+sin(where)*10.0  ,\n            \t    2.0  )).xyz    ,\n                                    1.33*( 1.0-(0.5+sin(2.0*where+1.5*PI)/2.0) ));\n              d = smin(d,d2,0.3);\n        }\n    }\n\n/*\n    for (int x=0; x<10; x++) {\n        float ff=float(x);\n        float where=mod(T*1.22+ff*ff,2*PI);\n        if ((where<PI*0.5 || (where>PI && where<1.5*PI)) ) {\n                float d2 = ( 1.0-(0.5+sin(2.0*where+.5*PI)/2.0) )*disp(p,1.0) +sdSphere(p +  ( rotateX(ff+T*0.33) * rotateY(ff+T*0.45) * rotateZ(ff+T*0.56) * vec4( 0.0+sin(where)*2.0, 0.0+sin(where)*2.0,  0.0+sin(where)*4.0  ,  1.0  )).xyz    ,   1.33*( 1.0-(0.5+sin(2.0*where+1.5*PI)/2.0) ));    d = smin(d,d2,0.3);\n        }\n    }\n*/\n\n//    d = smax(d,-d2,12);\n\n//\td=d+extra;\n\n//    for (int x=0; x<5; x++) {\n//        float ff=float(x);\n//        d = smin(d, sdSphere(p + ( vec4( sin(T*0.345+ff*1.2)*2.5,    sin(T*0.4+PI+ff*2.332)*1.8,      -cos(T*0.532+PI/1.5  +ff*1.662   )*2.1,  1.0)).xyz    ,\n//                             0.5+sin(ff+T)/4.0 ) // size sphere\n//                  ,.8+sin(ff+T*0.778)*0.2)   ;\n//    }\n\n\n//\td = smin(d, sdSphere(p+ (rotje * vec4( sin(T*0.4+PI/2.0)*2.0,  0.0,                             -cos(T*0.432+PI/2     )*2.0,  1.0)).xyz    ,0.5) ,.5)   ;\n//\td = smin(d, sdSphere(p+ (rotje * vec4( sin(T*0.5+PI)*2.0,      0.0,                             -cos(T*0.33423+PI       )*2.0,  1.0)).xyz    ,0.5) ,.5)   ;\n//\td = smin(d, sdSphere(p+ (rotje * vec4( sin(T*0.6+PI*1.5)*2.0,  0.0,                             -cos(T*0.5433+PI*1.5   )*2.0,  1.0)).xyz    ,0.5) ,.5)   ;\n//\td = smin(d, sdSphere(p+ (rotje * vec4( sin(T*0.33)*2.0,         0.0,                             -cos(T*0.22323          )*2.0,  1.0)).xyz    ,0.5) ,.5)   ;\n//\td = smin(d, sdSphere(p+ (rotje * vec4( 0.0,                     sin(T*0.31+PI/2.0   )*2.0,       -cos(T*0.3233+PI*1.5   )*2.0,  1.0)).xyz    ,0.5) ,.5)   ;\n//\td = smin(d, sdSphere(p+ (rotje * vec4( 0.0,                     sin(T*0.34+PI*1.5   )*2.0,       -cos(T*0.43453          )*2.0,  1.0)).xyz    ,0.5) ,.5)   ;\n//\td = smin(d, sdSphere(p+ (rotje * vec4( sin(T*0.44+PI/2.0)*2.0,  0.0,                             -cos(T*0.3+PI/2     )*2.0,  1.0)).yxz    ,0.5) ,.5)   ;\n//\td = smin(d, sdSphere(p+ (rotje * vec4( sin(T*0.55+PI)*2.0,      0.0,                             -cos(T*0.32343+PI       )*2.0,  1.0)).zyx    ,0.5) ,.5)   ;\n//\td = smin(d, sdSphere(p+ (rotje * vec4( sin(T*0.22+PI*1.5)*2.0,  0.0,                             -cos(T*0.5433+PI*1.5   )*2.0,  1.0)).yzx    ,0.5) ,.5)   ;\n//\td = smin(d, sdSphere(p+ (rotje * vec4( sin(T*0.29)*2.0,         0.0,                             -cos(T*0.43          )*2.0,  1.0)).xzy    ,0.5) ,.5)   ;\n//\td = smin(d, sdSphere(p+ (rotje * vec4( 0.0,                     sin(T*0.35+PI/2.0   )*2.0,       -cos(T*0.323+PI*1.5   )*2.0,  1.0)).zxy    ,0.5) ,.5)   ;\n\n    d = min(1.0E10 , d );\n    if (d>= 1.0E10) horizon=1;\n//    if (d==1.0E10) return 0.0;\n\n\n//    d = smax( d, -d2, 8);\n\n//    cylinder = (rotateZ(PI/2.0) * vec4(p.x,p.y,p.z, 1.0)).xyz;\n//\td = smax( d ,- sdCappedCylinder(cylinder,vec2(.40,1.4)) - 0.0 , 8 );\n\n//    cylinder = (rotateY(PI/2.0) * vec4(p.x,p.y,p.z, 1.0)).xyz;\n//\td = smax( d ,- sdCappedCylinder(cylinder,vec2(.40,1.4)) - 0.0 , 8 );\n\n//\td = smin( d,  sdCappedCylinder(cylinder,vec2(.50,1.15)) - 0.2, 0.1 );\n\n//\td = smax( d,  sdCappedCylinder(cylinder,vec2(.50,1.5)) - 0.0, 8.6 );\n//\td = SoftMaximum( d,  sdCappedCylinder(cylinder,vec2(.50,1.5)) - 0.0 );\n\n//\td = unionSDF(d,sdSphere(p,0.5));\n\n//\td = min (d, distance(p, vec3( sin(iTime*0.27)/3.0 ,   sin(iTime*0.28)/3.0 , sin(iTime*0.29)/4.0 ) )   - 0.1*(2.0+sin(iTime*0.33)) + disp(p.xzy)/1.0 ) ;\n//\td = min (d, distance(p, vec3( sin(iTime*0.28+1)/2.0 , sin(iTime*0.29)/3.0 , sin(iTime*0.30+1)/4.0 ) ) - 0.1*(2.0+sin(iTime*0.43)) + disp(p.yzx)/1.5 ) ;\n//\td = min (d, distance(p, vec3( sin(iTime*0.29+2)/3.0 , sin(iTime*0.30)/2.0 , sin(iTime*0.31+2)/4.0 ) ) - 0.1*(2.0+sin(iTime*0.53)) + disp(p.yxz)/1.0 ) ;\n//\td = min (d, distance(p, vec3( sin(iTime*0.30+3)/3.0 , sin(iTime*0.31)/3.0 , sin(iTime*0.32+3)/2.0 ) ) - 0.1*(2.0+sin(iTime*0.63)) + disp(p.zxy)/1.5 ) ;\n//\td = min (d, distance(p, vec3( sin(iTime*0.31+4)/2.0 , sin(iTime*0.32)/3.0 , sin(iTime*0.33+4)/4.0 ) ) - 0.1*(2.0+sin(iTime*0.73)) + disp(p.zyx)/1.0 ) ;\n//\td = min (d, distance(p, vec3( sin(iTime*0.32+5)/3.0 , sin(iTime*0.33)/2.0 , sin(iTime*0.34+5)/4.0 ) ) - 0.1*(2.0+sin(iTime*0.83)) + disp(p.xyz)/1.5 ) ;\n//\td = min (d, distance(p, vec3( sin(iTime*0.33+6)/3.0 , sin(iTime*0.34)/3.0 , sin(iTime*0.35+6)/3.0 ) ) - 0.1*(2.0+sin(iTime*0.93)) + disp(p.xzz)/1.5 ) ;\n\treturn d;\n\n}\n\nvec3 normal(vec3 p) {\n\tvec3 n, E = vec3(.005, 0., 0.);\n\n/*\n\tfloat n1,n2,n3;\n\n\tn1=map(p);\n\tn2=map(p - 1.0 * E.xyy);\n\tn3=map(p + 1.0 * E.xyy);\n\tif (abs(n1-n2)>abs(n3-n1)) {n.x=(n3 - n1)*2.0;  }\n\telse n.x=(n1 - n2)*2.0;\n\n\tn2=map(p - 1.0 * E.yxy);\n\tn3=map(p + 1.0 * E.yxy);\n\tif (abs(n1-n2)>abs(n3-n1)) {n.y=(n3 - n1)*2.0;  }\n\telse n.y=(n1 - n2)*2.0;\n\n\tn2=map(p - 1.0 * E.yyx);\n\tn3=map(p + 1.0 * E.yyx);\n\tif (abs(n1-n2)>abs(n3-n1)) {n.z=(n3 - n1)*2.0;  }\n\telse n.z=(n1 - n2)*2.0;\n*/\n\n//\tn.x = (map(p )                 - map(p - 1.0 * E.xyy)  )*2.0;\n//\tn2 = (map(p + 1.0 * E.xyy)    - map(p)                )*2.0;\n//    n.x=min(n1,n2);\n\n//\tn.y = (map(p ) - map(p - 1.0 * E.yxy))*2.0;\n//\tif (abs(n.y-n.x) > 0.1) n.y = (map(p + 1.0 * E.yxy) - map(p))*2.0 ;\n\n//\tn.z = (map(p ) - map(p - 1.0 * E.yyx))*2.0;\n//\tif (abs(n.z-n.x) > 0.1) n.z = (map(p + 1.0 * E.yyx) - map(p))*2.0 ;\n\n//\tn.x = min( (map(p ) - map(p - 1.0 * E.xyy))*2.0      ,      (map(p + 1.0 * E.xyy) - map(p))*2.0 );\n//\tn.y = min( (map(p ) - map(p - 1.0 * E.yxy))*2.0      ,      (map(p + 1.0 * E.yxy) - map(p))*2.0 );\n//\tn.z = min( (map(p ) - map(p - 1.0 * E.yyx))*2.0      ,      (map(p + 1.0 * E.yyx) - map(p))*2.0 );\n\n//\tn.x = map(p + E.xyy) - map(p - E.xyy); if (abs(n.x)>0.1) n.x = (map(p ) - map(p - 1.0 * E.xyy))*2.0; if (abs(n.x)>0.1) n.x = (map(p + 1.0 * E.xyy) - map(p))*2.0;\n//\tn.y = map(p + E.yxy) - map(p - E.yxy); if (abs(n.y)>0.1) n.y = (map(p ) - map(p - 1.0 * E.yxy))*2.0; if (abs(n.y)>0.1) n.y = (map(p + 1.0 * E.yxy) - map(p))*2.0;\n//\tn.z = map(p + E.yyx) - map(p - E.yyx); if (abs(n.z)>0.1) n.z = (map(p ) - map(p - 1.0 * E.yyx))*2.0; if (abs(n.z)>0.1) n.z = (map(p + 1.0 * E.yyx) - map(p))*2.0;\n\n\tn.x = map(p + E.xyy) - map(p - E.xyy);\n\tn.y = map(p + E.yxy) - map(p - E.yxy);\n\tn.z = map(p + E.yyx) - map(p - E.yyx);\n\treturn normalize(n);\n}\n\nfloat getVal2(vec2 uv)\n{\n    return length( texture(iChannel0,uv).xyz);\n}\n\nvec2 getGrad(vec2 uv,vec2 delta) {\n\n     return vec2(  getVal(uv+vec2(delta.x,0),delta) - getVal(uv-vec2(delta.x,0),delta) , getVal(uv+vec2(0,delta.y),delta) - getVal(uv-vec2(0,delta.y),delta) )/delta;\n//     return vec2( getVal2(uv+vec2(delta.x,0))-getVal2(uv-vec2(delta.x,0)) , getVal2(uv+vec2(0,delta.y))-getVal2(uv-vec2(0,delta.y)) )/delta;\n}\n\n\nvec4 getpaint( vec2 Coord,vec2 uv)\n{\n//\tuv = (gl_FragCoord.xy) / iResolution.xy;\n//\tuv = (gl_FragCoord.xy-pos_correction.xy) / iResolution.xy;\n//    vec3 light = normalize(vec3(1,1,2));\n//\tfloat T = iTime/10.0;\n\t//float TT = T * 0.2 + sin(T*0.4)*3.14;\n//\tvec3 light=normalize(vec3(-cos(TT)*1.7+3.14/4.0, 1., 3.14*-0.5+0.2*cos(TT)*1.4));\n//\tvec3 light=normalize(vec3(-cos(TT)*1.7+3.14/4.0, 1., 3.14*-0.5+0.2*cos(TT)*1.4));\n    vec3 light = normalize(vec3(1,1,2));\n\n    vec3 n = vec3(getGrad(uv,1.0/iChannelResolution[0].xy),150.0);\n    n=normalize(n);\n\n    float diff=clamp(dot(n,light),0.5,1.0);\n    float spec=clamp(dot(reflect(light,n),vec3(0,0,-1)),0.0,1.0);\n    spec=pow(spec,36.0)*1.5;\n\n//\tvec4 col=texture(texture_buffer,uv);\n//\tvec4 col=texture(texture_buffer,uv)*vec4(vec3(diff),1.0)*1.2;\n\tvec4 col=texture(iChannel0,uv)*vec4(vec3(diff),1.0)*1.2+vec4(vec3(spec),0.0);\n    return col;\n}\n\nint back=0;\nfloat t;\n\n\n//vec4 main2(vec2 Coord, float zoom) {\n//void main() {\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 delta_buffer=1.0/iResolution.xy;\n//    T = PI;\n    T = iTime/5.0;\n    Resolution=iResolution.xy;\n    back=0;\n    vec4 Color=vec4(0.0);\n\tfloat zoom=1.5+sin(T*5.0)/3.0;\n    vec2 Coord=(fragCoord.xy);\n//    vec2 Coord=(gl_FragCoord.xy-pos_correction.xy);\n//    float zoom=1.0;\n\tvec3 kS = vec3(.7, .5, .9);\n\tvec3 kA = vec3(0.0, .0, .0);\n\n//\tfloat ppy = .0+sin(T*.3+cos(T*0.3)*3.14)*.1;\n//\tfloat ppx = .0+cos(T*.4+sin(T*0.5)*3.14)*.1;\n\tfloat ppy = .0;\n\tfloat ppx = .0;\n\tfloat TT = T * 0.71 + sin(T*0.1334)*3.14;\n\n    vec2 light_xy=rotate(T)*vec2(-cos(TT)*15.7+1.0, 5.0);\n\tvec3 light=vec3(light_xy.x,light_xy.y, -2.5+cos(TT)*1.0+camera_pos); // zzzzz 2.0\n\n    light_xy=rotate(T/2.0)*vec2(0.5,-cos(TT/2.0)*15.7+1.0);\n\tvec3 light2=vec3(light_xy.y,light_xy.x, -2.5+cos(TT/2.0)*1.0+camera_pos); // zzzzz 2.0\n\n    //\tvec3 light=vec3(-cos(TT)*15.7+1.0, 5., -2.5+cos(TT)*1.0+camera_pos); // zzzzz 2.0\n//\tvec3 light=vec3(-pos_abs.x*30, pos_abs.y*30, 5.5+camera_pos); // zzzzz 2.0\n\n    vec3 ro = vec3(0.0,0.0, -1.0);\n\n\tuv = zoom*rotate(T)*(Coord.xy - .5 * Resolution) / Resolution.y;\n\tvec3 rd = vec3(uv, 1.0);\n\n\tt = 0.0;\n    vec3 p;\n    p = ro + rd * t;\n    float m=map(p);\n\tfor (int i = 0; i < 512; i++) {\n        m=map(p);\n//        if (m==1.0E10) break;\n        if (horizon==1) break;\n        t += 0.9 * m;\n        p = ro + rd * t;\n \t\tif (m<0.0001) break;\n\t}\n\n    uv2= vec2(1.0,-1.0)*  (( (   ( p.xy*1.2*vec2(1.0,-1.0) +  vec2(ppx,ppy) - t/1.5  ) ) -0.5) + 0.25);\n\tif (horizon==0 || m<0.0001) {// my raymarch function must be messed?\n\n        vec4 kD=vec4(0.0);\n\n        vec2 offset=vec2(-6.0,2.5);       //yz\n\n        vec3 n = normal( p );\n        vec2 calc=(p.xy*vec2(0.6,0.6)*(1.1+p.z/1.50) +  vec2(ppx,ppy)  - (t)/2.5);\n        vec2 uv2= vec2(-4.5,4.2) * ( calc /(1.0+ p.xy/10.0) )  +  vec2(0.0,-(calc.y)*0.20)+ offset;\n        vec2 uv_adj=(uv2.xy/(1.0+sqrt(-camera_pos/1.0 + 1.0)/iChannelResolution[0].xy)*vec2(0.04,0.04)  )*vec2(1.1,-.9)+ vec2(0.6,0.2);\n//        vec2 uv_adj=(uv2.xy/(1.0+sqrt(-camera_pos/1.0 + 1.0)/iChannelResolution[0].xy)*vec2(0.4,0.4)  )*vec2(.20,-.3)+ vec2(1.6,1.5);\n//        vec2 uv_adj=(uv2.xy/(1.0+sqrt(-camera_pos/2.0 + 1.0)/iResolution.xy)*vec2(0.0126,0.0165)  )*vec2(1.0,-1.0)+ vec2(-0.4,1.45);\n\n//        vec3 n2 = vec3(getGrad(uv_adj,-1.0/iChannelResolution[0].xy),-150.0);\n//        n2=normalize(n2)*vec3(1.0,1.0,1.0);\n\n        kD = texture(iChannel0,uv_adj  );\n\n//        n=n-(n-n2)/1.0; // add texture gradient to pong....\n\n        vec3 lp = normalize(light - p);\n        float diff = 1.0 * clamp(dot( n,lp), 0.0, 1.);\n        float spec = (9.5) * pow(max(dot(reflect(-lp, n), ro), 0.), 120.);\n\n        vec3 lp2 = normalize(light2 - p);\n        float diff2 = 1.0 * clamp(dot( n,lp2), 0.0, 1.);\n        float spec2 = (9.5) * pow(max(dot(reflect(-lp2, n), ro), 0.), 120.);\n\n        diff=(diff+diff2)/1.5;\n        spec=(spec+spec2)/1.5;\n        \n//\t\tColor = clamp(vec4(kA + kD.xyz * (diff ) + kS *( spec ), 1.0), 0.0,1.0);\n//\t\tColor = clamp(vec4(kA + kD.xyz * (diff ) + kS * ( spec ), 1.0), 0.0,1.0);\n\t\tColor = clamp(vec4(kA + kD.xyz * (diff ) + kS * ( spec ), 1.0), 0.0,1.0);\n\t} else {\n\t\tColor = vec4(0.0);\n//        Color = vec4(.4, .415+cos(T*.7+uv.y*25.0+cos(T*0.4+uv.x*10.0-uv.y*15.0))*0.45, 0.1+cos(T*1.33+uv.y*5.0+cos(T*0.33+uv.x*15.0-uv.y*25.0))*0.8, 1.0)*2.0;\n//        T=T*2.5;Color += vec4( .45+cos(T*0.5+uv.y*25.0+cos(T*0.4+uv.x*10.0-uv.y*15.0))*0.45, 0.1+cos(T*1.1+uv.y*5.0+cos(T*0.73+uv.x*15.0-uv.y*25.0))*0.8,.4, 1.0)*2.0;\n        back=1;\n\t}\n\n//    if (background_plot==1) {\n//        vec4 background=texture(texture_in,(Coord.xy/vec2(1920,1080)));\n//        Color = mix(Color,background,background.a);\n//    }\n    fragColor=Color;\n//    return Color;\n}\n\n\n/*\n#define AA 1\n\nvoid main2() {\n    Resolution=iResolution;\n    float t1=0.0;\n    float tt=T;\n    if (AA<=1) {\n        gl_FragColor=main2(gl_FragCoord.xy,1.0);\n//        gl_FragColor=main2(gl_FragCoord.xy+vec2(sin(tt*0.12+PI)*Resolution.x/6.0,cos(tt*0.12+PI)*Resolution.y/6.0),1.0);\n//        t1=t;\n//        t=0.0;\n//        T+=343.34;\n//        vec4 Color2=main2(gl_FragCoord.xy+vec2(sin(tt*0.12+PI/2.0)*Resolution.x/6.0,cos(tt*0.12+PI/2.0)*Resolution.y/6.0),1.0);\n//        if (t<t1) { gl_FragColor=Color2; t1=t; }\n//        T+=343.34;\n//        Color2=main2(gl_FragCoord.xy+vec2(sin(tt*0.12+PI*1.5)*Resolution.x/6.0,cos(tt*0.12+PI*1.5)*Resolution.y/6.0),1.0);\n//        if (t<t1) { gl_FragColor=Color2; t1=t; }\n//        T+=343.34;\n//        Color2=main2(gl_FragCoord.xy+vec2(sin(tt*0.12)*Resolution.x/6.0,cos(tt*0.12)*Resolution.y/6.0),1.0);\n//        if (t<t1) { gl_FragColor=Color2; t1=t; }\n\n//        if (back==1 && back1==1) {\n//            T=T+44.24;\n//            t=0.0;\n//            gl_FragColor=main2(gl_FragCoord.xy+vec2(sin(tt*0.12+PI*1.5)*Resolution.x/4.0,cos(tt*0.12+PI*1.5)*Resolution.y/4.0),2.0-sin(tt*0.12+PI*1.5));\n//        }\n    }\n    else {\n        gl_FragColor=vec4(0.0);\n//        Resolution*=AA;\n        for (int x=0;x<AA; x++)\n            for (int y=0;y<AA; y++)\n                gl_FragColor+=main2(gl_FragCoord.xy + vec2( float(x)/(float(AA)) , float(y)/float(AA) ) , 1.0);\n        gl_FragColor/=(AA*AA);\n    }\n}\n*/\n\n\n\n\n\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}