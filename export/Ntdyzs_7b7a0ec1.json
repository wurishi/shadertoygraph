{"ver":"0.1","info":{"id":"Ntdyzs","date":"1660348190","viewed":122,"name":"Colorful electric rods","username":"techroot","description":"Colorful model of electric rods' field potential.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["metaball","vectorfield","electricity"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Rod {\n  vec2 start; // start point\n  vec2 end; // end point\n  float q; // total charge\n  vec3 color;\n};\n\nvoid rodRotate(inout Rod rod, float angle) {\n  // create horizontal rod with middle in (0, 0), then translate and rotate\n  vec2 origin = rod.start + (rod.end - rod.start) / 2.0;\n  mat2 t = mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\n  rod.start = t * (rod.start - origin) + origin;\n  rod.end = t * (rod.end - origin) + origin;\n}\n\nconst float k = 1.0/15.0;\n\nconst float velocity = 0.5;\n\nconst float netLineStep = 0.03;\nconst float netLineWidth = 0.005;\nconst float netLineMinFieldStrength = 0.0;\nconst float netLineMaxFieldStrength = 0.7;\nconst vec3 netLineColor = vec3(0.0, 1.0, 0.0);\n\nconst float rodWidthProportion = 0.05;\n\n// distance with respect to wrap over screen borders\nfloat wrapDistance(vec2 a, vec2 b, vec2 screen) {\n  vec2 direct_d = abs(a - b);\n  vec2 wrapped_d = screen - direct_d;\n  vec2 d = min(direct_d, wrapped_d);\n  \n  return sqrt(dot(d, d));\n}\n\nfloat brightness(vec3 color) {\n  vec3 n = normalize(color);\n  \n  return 0.299*color.r*color.r +\n   0.587*color.g*color.g +\n   0.114*color.b*color.b;\n}\n\n// returns 0 if x > edge, otherwise 1\nfloat negStep(float edge, float x) {\n  return step(edge, -x + 2.0*edge);\n}\n\n// field potential of point distanced y units from rod's line,\n// when rod is at OX axis, starting point x1 and end point x2\nfloat rodPotentialCanonical(float x1, float x2, float y_original, float q) {\n  float y = abs(y_original);\n  y = max(0.001, y);\n  float l = sqrt(x2 * x2 + x1 * x1);\n  float lambda = q / l;\n  return k * lambda * (-atanh(x1/sqrt(x1*x1 + y*y)) + atanh(x2/sqrt(x2*x2 + y*y)));\n}\n\nfloat rodPotentialAtP(Rod rod, vec2 p) {\n  // transform to canonical coordinate system (see above)\n  vec2 i = normalize(rod.end - rod.start);\n  vec2 j = vec2(i.y, -i.x);\n  mat2 t = mat2(i, j);\n  \n  // point of intersection between rod line and perpendicular containing p\n  vec2 origin = vec2(\n    (i.x*j.y*p.x - i.x*j.x*p.y - i.y*j.x*rod.start.x + i.x*j.x*rod.start.y)/(-i.y*j.x + i.x*j.y),\n    (p.y - (j.y * (p.x - (i.x*j.y*p.x - i.x*j.x*p.y - i.y*j.x*rod.start.x + i.x*j.x*rod.start.y)/(-i.y*j.x + i.x*j.y)))/j.x)\n  );  \n  t = inverse(t);\n  return rodPotentialCanonical((t * (rod.start - origin)).x, (t * (rod.end - origin)).x, (t * (p - origin)).y, rod.q);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord/iResolution.y;\n  vec2 screen = vec2(iResolution.x/iResolution.y, 1.0);\n\n  // sorted by radius\n  const int N = 2;\n  Rod rods[N] = Rod[N](\n    Rod(\n      vec2(0.20 * screen.x, 0.5),\n      vec2(0.40 * screen.x, 0.5),\n      2.0, vec3(0.0, 1.0, 1.0)\n    ),\n    Rod(\n      vec2(0.60 * screen.x, 0.5),\n      vec2(0.80 * screen.x, 0.5),\n      2.0, vec3(1.0, 0.0, 1.0)\n    )\n  );\n  rodRotate(rods[0], 2.0*velocity*iTime + radians(45.0));\n  rodRotate(rods[1], -2.0*velocity*iTime - radians(45.0));\n\n  float potential = 0.0;\n  vec3 fieldColor = vec3(0.0, 0.0, 0.0);\n  \n  for (int i = 0; i < rods.length(); i++) {\n    Rod rod = rods[i];\n    float d_potential = rodPotentialAtP(rod, uv);\n    potential += d_potential;\n    fieldColor += rod.color * d_potential;\n  };\n  \n  fieldColor = normalize(fieldColor);\n  \n  float fieldBrightness = clamp(smoothstep(0.3, 1.0, potential), 0.0, 0.9);\n  fieldColor *= fieldBrightness;\n  \n  // 1 if should draw equipotential line, 0 otherwise\n  float drawNetLine =\n    step(netLineMinFieldStrength, potential) *\n    negStep(netLineMaxFieldStrength, potential);\n  \n  float netLineBrightness =\n    smoothstep(netLineWidth, 0.0, mod(potential, netLineStep));\n \n  vec3 color = fieldColor + drawNetLine * netLineBrightness * fieldColor;\n  \n  for (int i = 0; i < rods.length(); i++) {\n    Rod rod = rods[i];\n    vec2 j = normalize(rod.end - rod.start);\n    vec2 k = vec2(j.y, -j.x);\n    vec2 origin = rod.start;\n    \n    mat2 t = mat2(j, k);\n    t = inverse(t);\n    \n    // current shader point in rod coordinate system, where rod is horizontal, start point at (0, 0)\n    // end point to the right of start\n    vec2 p = t * (uv - origin);\n    vec2 end = t * (rod.end - origin);\n    \n    float rodWidth = end.x * rodWidthProportion;\n    float rodEdge = step(0.0, p.x) * negStep(end.x, p.x) *\n      smoothstep(-rodWidth/2.0, 0.0, p.y) * smoothstep(rodWidth/2.0, 0.0, p.y);\n    color = mix(color, rods[i].color, rodEdge);\n  };\n\n  // lut(color);\n  fragColor = vec4(color, 1.0);\n  //fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n\n  // draw color temperature instead?\n}","name":"Image","description":"","type":"image"}]}