{"ver":"0.1","info":{"id":"43ByR1","date":"1726939892","viewed":45,"name":"Raycasting homebrew","username":"endertrekkie","description":"Raycasting but I figure out matrix math and reflections","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","raycasting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//sample world function.returns distance to surface\nfloat cubeSDF(vec3 p){\n    vec3  p2 = vec3(clamp(p.x,-1.,1.),clamp(p.y,-1.,1.),clamp(p.z,-1.,1.));\n    return length(p-p2);\n}\nfloat worldSDF(vec3 p){\n    return cubeSDF(p);\n}\n\n//voxel stuff\nbool getVoxel(vec3 pos){\n    return texture(iChannel0, (pos*scale) + vec3(0.5)).a < solidThreshold;\n}\nvec3 getVoxCol(vec3 pos){\n    return texture(iChannel0, pos*scale).rgb;\n}\n\n//raycast function. iterates through world and returns the color at that position\nvec4 raycast(vec3 pos, vec3 dir){\n    for(int i = 0; i < maxIters; i++){\n        float d = worldSDF(pos);\n        if(d < inflation){\n            return vec4(1.0/(1.0+length(pos - camPos)));\n        }\n        pos += dir * max(minStep,d);\n        if(length(pos - camPos) > renderDist){\n            return vec4(0.0);\n        }\n    }\n    return vec4(1.0/(1.0+length(pos)));\n}\nvec4 voxelCastDDA(vec3 pos, vec3 dir){\n    int iters = 0;\n    ivec3 mapPos = ivec3(floor(pos + 0.));\n\tvec3 deltaDist = abs(vec3(length(dir)) / dir);\n\tivec3 rayStep = ivec3(sign(dir));\n\tvec3 sideDist = (sign(dir) * (vec3(mapPos) - pos) + (sign(dir) * 0.5) + 0.5) * deltaDist; \n\tbvec3 mask;\n    for (int i = 0; i < maxIters; i++) {\n\t\tif (getVoxel(vec3(mapPos))) continue;\n        ivec3 oldMap = mapPos;\n        mask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));\n        sideDist += vec3(mask) * deltaDist;\n        mapPos += ivec3(vec3(mask)) * rayStep;\n        if(length(vec3(mapPos) - pos) > renderDist){\n            //return vec4(0.0);\n            break;\n        }\n        iters++;\n\t}\n    vec3 color = getVoxCol(vec3(mapPos));\n    if(mask.x){\n        color *= 0.5;\n    }\n    if(mask.y){\n        color *= 1.0;\n    }\n    if(mask.z){\n        color *= 0.75;\n    }\n    return vec4(color, 1.0);\n\n}\nvec4 voxelCastFixedStep(vec3 pos, vec3 dir){\n    for(int i = 0; i < maxIters; i++){\n        if(getVoxel(pos)){\n            return vec4(getVoxCol(pos).r / solidThreshold);\n        }\n        pos += dir * (getVoxCol(pos).r*0.3);\n    }\n    return vec4(0.0);\n}\n\n//rotate a matrix around x axis\nmat3 rotX(mat3 p, float a){\n    return p * mat3(\n        1,  0,     0,\n        0, cos(a),-sin(a),\n        0, sin(a), cos(a));\n}\n//rotate a matrix around y axis\nmat3 rotY(mat3 p, float a){\n    return p * mat3(\n        cos(a), 0, sin(a),\n          0,    1,   0,\n       -sin(a), 0, cos(a));\n}\n//rotate a matrix around z axis\nmat3 rotZ(mat3 p, float a){\n    return p * mat3(\n        cos(a),-sin(a),0,\n        sin(a), cos(a),0,\n          0,     0,    1);\n}\n\n//get direction from screen position\nvec3 dirFromScreen(vec2 uv, float d){\n    vec3 rawDir = vec3(uv,d);\n    return normalize(camDir[0] * rawDir.x + camDir[1] * rawDir.y + camDir[2] * rawDir.z);\n}\n\n//render\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    solidThreshold = (1.0 + sin(iTime/10.0))/4.0;\n    camDir = rotY(camDir, iTime/2.);\n    camDir = rotX(camDir, -sin(iTime)/3.0);\n    camPos = vec3(-sin(-iTime/2.)*19.3, sin(iTime)*5.0, -cos(-iTime/2.)*20.0);\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    //rescale such that everything is square (x values can be beyond -0.5 to 0.5)\n    uv = uv * iResolution.xy / iResolution.xx;\n    \n    vec3 dir = dirFromScreen(uv, cos(fov/180.*3.1415));\n\n    // Output to screen\n    fragColor = voxelCastDDA(camPos,dir);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//camera\nfloat fov = 60.0;//field of view, in degrees.\nvec3 camPos = vec3(3., 1.1, -3.);//position of camera\nmat3 camDir = mat3(1,0,0,0,1,0,0,0,1);//matrix rotation of camera\n\n//performance\nfloat minStep = 0.01;//min step per ray\nfloat inflation = 0.001;//distance from surface for a hit\nfloat renderDist = 146.0;//max distance to send ray\nint maxIters = 256;//max iters to send ray\\\n\n//voxel settings\nfloat solidThreshold = 0.3;//1 = all solid, 0 = all transparent. 0.1 is usually best\nfloat scale = 0.003;//how large to sample world. 0.001 = super large blocks, 0.1 = small","name":"Common","description":"","type":"common"}]}