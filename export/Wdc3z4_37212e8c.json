{"ver":"0.1","info":{"id":"Wdc3z4","date":"1568386213","viewed":124,"name":"[MXPL] Basic raymarching","username":"matexpol","description":"Few SDF objects drawn using raymarching.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"////////////////////////////////////////////// START OF CHANGEABLE CODE\n\nconst SDFSphereData[] SDF_SPHERES = SDFSphereData[](\n    SDFSphereData(vec3(-3., 1., -3.), 0.75, vec3(186., 218., 85.) / 255., 0),\n    SDFSphereData(vec3(-3., 1., 0.), 0.5, vec3(247., 52., 122.) / 255., 1),\n    SDFSphereData(vec3(-3., 1., 3.), 0.25, vec3(127., 255., 212.) / 255., 2)\n);\n\nconst SDFBoxData[] SDF_BOXES = SDFBoxData[](\n    SDFBoxData(vec3(0., 1., -3.), vec3(0.75), vec3(128., 0., 0.) / 255., 3),\n    SDFBoxData(vec3(0., 1., 0.), vec3(0.5, 0.75, 1.), vec3(255., 246., 143.) / 255., 4),\n    SDFBoxData(vec3(0., 1., 3.), vec3(1., 1.25, 0.25), vec3(102., 0., \t102.) / 255., 5)\n);\n\nconst SDFCylinderData[] SDF_CYLINDERS = SDFCylinderData[](\n    SDFCylinderData(vec3(3., 1., -3.), 0.5, 0.75, vec3(0., 0., 128.) / 255., 6),\n    SDFCylinderData(vec3(3., 1., 0.), 1.5, 0.25, vec3(6., 85., 53.) / 255., 7),\n    SDFCylinderData(vec3(3., 1., 3.), 1.5, 0.75, vec3(195., 151., 151.) / 255., 8)\n);\n\n// Helper method for getDistance. Updates new minDistance if distanceToCurSDF is smaller.\nvoid updateMinDistance(inout float minDistance, const float distanceToCurSDF,\n                       const vec3 colorOfCurSDF, const int idOfCurSDF,\n                       out vec3 colorInMinDistance, out int idOfHitSDF)\n{\n    if (distanceToCurSDF < minDistance)\n    {\n        minDistance = distanceToCurSDF;\n        colorInMinDistance = colorOfCurSDF;\n        idOfHitSDF = idOfCurSDF;\n    }\n} \n\nfloat getDistance(const vec3 pointWS, out vec3 colorInMinDistance, out int idOfHitSDF)\n{   \n    float minDistance = 1e10;\n    for (int i=SDF_SPHERES.length()-1; i>=0; i--)\n    {\n        float curDistance = getDistanceToSphereSDF(pointWS, SDF_SPHERES[i]);\n        updateMinDistance(minDistance, curDistance, SDF_SPHERES[i].color, SDF_SPHERES[i].id,\n                          colorInMinDistance, idOfHitSDF);\n    }\n    for (int i=SDF_BOXES.length()-1; i>=0; i--)\n    {\n        float curDistance = getDistanceToBoxSDF(pointWS, SDF_BOXES[i]);\n        updateMinDistance(minDistance, curDistance, SDF_BOXES[i].color, SDF_BOXES[i].id,\n                          colorInMinDistance, idOfHitSDF);\n    }\n    for (int i=SDF_CYLINDERS.length()-1; i>=0; i--)\n    {\n        float curDistance = getDistanceToCylinderSDF(pointWS, SDF_CYLINDERS[i]);\n        updateMinDistance(minDistance, curDistance, SDF_CYLINDERS[i].color, SDF_CYLINDERS[i].id,\n                          colorInMinDistance, idOfHitSDF);\n    }\n    \n    return minDistance;\n}\n\n////////////////////////////////////////////// END OF CHANGEABLE CODE\n\nfloat getDistance(const vec3 pointWS)\n{\n    vec3 dummyColor;\n    int dummyIdOfSDF;\n    return getDistance(pointWS, dummyColor, dummyIdOfSDF);\n}\n\n// Basic ray march - returns distance to closest SDF object\nfloat marchRayBasic(const vec3 rayOrigin, const vec3 rayDir, const float distanceFromRayOrigin,\n                    out vec3 hitPointColor, out int hitPointSDFId)\n{\n    for (float distanceTraveledSoFar=distanceFromRayOrigin; distanceTraveledSoFar<MAX_RAY_LENGTH;)\n    {\n        vec3 hitPoint = rayOrigin + rayDir * distanceTraveledSoFar;\n        float curPointDistance = getDistance(hitPoint, hitPointColor, hitPointSDFId);\n        if (curPointDistance < MIN_DISTANCE_TO_ASSUME_RAY_HIT)\n         \treturn distanceTraveledSoFar;\n        distanceTraveledSoFar += curPointDistance;\n    }\n    return INVALID_DISTANCE;\n}\n\n// Returns distance from ray origin to floor, also returns checkerboarded color in hit point\nfloat calculateFloorColor(const vec3 rayDir, const vec3 rayOrigin, out vec3 checkerboardColor)\n{\n    // Floor is always directed up\n    vec3 floorPlaneNormal = FLOOR_NORMAL;\n    vec3 floorPlaneCenter = vec3(0., FLOOR_Z_POSITION, 0.);\n    \n    float angle = dot(floorPlaneNormal, rayDir);\n    // If floor and ray are not parallel\n    if (angle < -EPSILON)\n    {\n        // Some math to calculate intersection point between plane and ray\n        vec3 floorRayOriginVec = rayOrigin - floorPlaneCenter;\n        float distanceToIntersectionPoint = - dot(floorRayOriginVec, floorPlaneNormal) /\n            \t\t\t\t\t\t\t\t  dot(rayDir, floorPlaneNormal);\n        vec3 hitPoint = rayOrigin + distanceToIntersectionPoint * rayDir;\n        \n        // Checkerboard index of calculated intersection point\n        ivec3 hitPointCheckerboardIndex = ivec3(greaterThanEqual(mod(hitPoint, 2.), vec3(1.)));\n    \tcheckerboardColor = bool(hitPointCheckerboardIndex.x ^ hitPointCheckerboardIndex.z) ?\n                 \t\t\t     FLOOR_FIRST_COLOR : FLOOR_SECOND_COLOR;\n        \n        return distanceToIntersectionPoint;\n    }\n    \n    // Ray hasn't hit floor\n    return INVALID_DISTANCE;\n}\n\nvec3 calculateBackgroundColor(const vec2 fragCoord)\n{\n    vec2 screenUV = fragCoord / iResolution.xy;\n    return BACKGROUND_COLOR * smoothstep(1., 0., abs(.5 - screenUV.y));\n}\n\nvec3 calculateNormal(const vec3 hitPoint)\n{    \n    float normalX = getDistance(hitPoint + vec3(EPSILON, 0., 0.)) -\n        \t\t\tgetDistance(hitPoint - vec3(EPSILON, 0., 0.));\n    float normalY = getDistance(hitPoint + vec3(0., EPSILON, 0.)) -\n        \t\t\tgetDistance(hitPoint - vec3(0., EPSILON, 0.));\n    float normalZ = getDistance(hitPoint + vec3(0., 0., EPSILON)) -\n        \t\t\tgetDistance(hitPoint - vec3(0., 0., EPSILON));\n    return normalize(vec3(normalX, normalY, normalZ));\n}\n\nvec3 calculatePhong(const vec3 rayDir, const vec3 hitPoint, const vec3 hitNormal, const vec3 hitPointColor)\n{\n    float ambientValue = MATERIAL_AMBIENT_STRENGTH;\n    \n    vec3 invLightDir = normalize(LIGHT_POSITION - hitPoint);\n    float ndotl = max(dot(hitNormal, invLightDir), 0.);\n    float diffuseValue = MATERIAL_DIFFUSE_STRENGTH * ndotl;\n    \n    vec3 reflectDir = reflect(invLightDir, hitNormal);\n    float vdotr = max(dot(rayDir, reflectDir), 0.);\n    float specularValue = MATERIAL_SPECULAR_STRENGTH * pow(vdotr, MATERIAL_SHININESS);\n    \n    vec3 resultColor = (ambientValue + diffuseValue + specularValue) * LIGHT_COLOR * hitPointColor;\n    return resultColor;\n}    \n\nfloat calculateShadow(const vec3 hitPoint, const vec3 hitNormal)\n{\n    vec3 rayDir = normalize(LIGHT_POSITION - hitPoint);\n    // Affects maximum number of ray marching iterations (we don't want to calculate shader behind the light)\n    float distanceToLight = length(LIGHT_POSITION - hitPoint);\n    float rayDotNormal = dot(rayDir, hitNormal);\n    \n    // Accumulated soft shadows factor from all objects close enough to ray\n    float accumulatedSoftShadowsFactor = 1.;\n    // Used in loop to store value of minimum soft shadows factor of single object at ray's line\n    float minSoftShadowsFactor = 1.;\n    // Stores id of SDF which was the closest to ray in previous frames\n    int idOfPreviouslyClosestSDF = -1;\n    \n    // Ray from hit point to light position\n    for (float distanceTraveledSoFar=DISTANCE_FROM_HIT_POINT_TO_START_CALCULATE_SHADOW;\n         distanceTraveledSoFar<distanceToLight;)\n    {\n        vec3 rayMarchPoint = hitPoint + rayDir * distanceTraveledSoFar;\n        vec3 rayMarchPointColor;\n        int rayMarchPointSDFId;\n        float rayMarchPointDistance = getDistance(rayMarchPoint, rayMarchPointColor, rayMarchPointSDFId);\n        \n        // If shadow ray hit something we want to have full shade\n        if (rayMarchPointDistance < MIN_DISTANCE_TO_ASSUME_RAY_HIT)\n        {\n            // Light is occluded by some objects, so we don't want soft shadows\n            accumulatedSoftShadowsFactor = 0.;\n            break;\n        }\n        \n        // Soft shadows factor of SDF identified by id idOfHitSDF\n        float curSoftShadowsFactor = PENUMBRA_FACTOR*rayMarchPointDistance/distanceTraveledSoFar;\n        \n        // We're constantly moving toward the light source\n        distanceTraveledSoFar += rayMarchPointDistance;\n        \n#if USE_SDF_IDS == 1\n        // If ID of closest SDF changes we need to reset min soft shadows factor\n        if (idOfPreviouslyClosestSDF != rayMarchPointSDFId)\n        {\n            accumulatedSoftShadowsFactor *= minSoftShadowsFactor;\n            minSoftShadowsFactor = 1.;\n            idOfPreviouslyClosestSDF = rayMarchPointSDFId;\n        }\n#endif\n        \n        minSoftShadowsFactor = min(minSoftShadowsFactor, curSoftShadowsFactor);\n    }\n    \n    accumulatedSoftShadowsFactor *= minSoftShadowsFactor;\n    \n    float shadowFactor = clamp(rayDotNormal * accumulatedSoftShadowsFactor, 1. - SHADOW_INTENSITY, 1.);\n    return shadowFactor;\n}\n\nfloat calculateAmbientOcclusion(const vec3 hitPoint, const vec3 hitNormal)\n{\n    float ambientOcclusionValue = 0.;\n    // Weight of first step is 1.\n    float curWeight = 1.;\n    for (float i=0.; i<AO_STEPS_NUMBER; i++)\n    {\n        float distanceFromHitPoint = AO_FIRST_STEP_DISTANCE_FROM_HIT_POINT +\n            \t\t\t\t\t\t AO_DISTANCE_BETWEEN_STEPS * i;\n        vec3 aoPosition = hitPoint + hitNormal * distanceFromHitPoint;\n        float aoDistance = getDistance(aoPosition);\n        float aoValueInStep = (distanceFromHitPoint-aoDistance) * curWeight;\n        ambientOcclusionValue += aoValueInStep;\n        curWeight *= AO_EACH_STEP_WEIGHT_MODIFIER;\n    }\n    ambientOcclusionValue *= AO_STRENGTH;\n    float result = clamp(1. - ambientOcclusionValue, 1. - AO_INTENSITY, 1.);\n    return result;\n}\n\nvec3 calculateReflections(const vec3 hitPoint, const vec3 hitNormal, const vec3 hitPointColorSoFar,\n                          const vec3 baseRayDir, const vec3 backgroundColor)\n{\n    vec3 reflectionRayDir = normalize(reflect(baseRayDir, hitNormal));\n    vec3 reflectionResultColor, reflectionHitPointColor;\n    int reflectionHitSDFId;\n    float distanceToReflectionRayHit = marchRayBasic(hitPoint, reflectionRayDir,\n\t\tREFLECTIONS_DISTANCE_FROM_HIT_POINT_TO_START_CALCULATE,\n        reflectionHitPointColor, reflectionHitSDFId);\n    // If we haven't hit anything, we just hit sky\n    if (distanceToReflectionRayHit == INVALID_DISTANCE)\n        reflectionResultColor = backgroundColor;\n    else\n    {\n        vec3 reflectionHitPoint = hitPoint + reflectionRayDir*distanceToReflectionRayHit;\n        vec3 reflectionHitPointNormal = calculateNormal(reflectionHitPoint);\n        reflectionResultColor = calculatePhong(reflectionRayDir, reflectionHitPoint,\n                                         \t   reflectionHitPointNormal, reflectionHitPointColor);\n        reflectionResultColor *= calculateShadow(reflectionHitPoint, reflectionHitPointNormal);\n    }\n    // We want reflections only on floor, so if we're not on floor our reflection color is\n    // hit point color so far (reflection color won't break below mix instruction)\n    return mix(hitPointColorSoFar, reflectionResultColor, REFLECTIONS_INTENSITY);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 resultColor;\n#if QUALITY >= 2\n    // Sum of colors sampled by MSAA\n    vec3 allResultColors = vec3(0.);\n    for (int i=ALL_MSAA_SAMPLE_POINTS.length()-1; i>=0; i--)\n    {\n        fragCoord = trunc(fragCoord) + ALL_MSAA_SAMPLE_POINTS[i];\n#endif\n        // Color of the background - used when nothing else hasn't been hit\n        vec3 backgroundColor = calculateBackgroundColor(fragCoord);\n        \n        // Data of our main ray\n        vec3 rayOrigin, rayDir;\n        getRayData(fragCoord, iResolution, iTime, rayOrigin, rayDir);\n        \n        // Result of our main ray\n        vec3 hitPointColor;\n        int hitPointIdOfSDF;\n        float distanceToHitPoint = marchRayBasic(rayOrigin, rayDir, 0., hitPointColor, hitPointIdOfSDF);\n        vec3 hitPoint = rayOrigin + rayDir * distanceToHitPoint;\n        \n        vec3 hitPointNormal = FLOOR_NORMAL;\n        bool floorHit = false;\n        // We haven't hit any SDF, so maybe we hit floor?\n        if (distanceToHitPoint == INVALID_DISTANCE)\n        {\n            distanceToHitPoint = calculateFloorColor(rayDir, rayOrigin, hitPointColor);\n            floorHit = distanceToHitPoint != INVALID_DISTANCE;\n            hitPoint = rayOrigin + rayDir * distanceToHitPoint;\n        }\n        else\n            hitPointNormal = calculateNormal(hitPoint);\n        \n        // Values which blends between hit point color and background\n        float backgroundBlendValue = 1.;\n        // If we have hit some SDF or floor\n        if (distanceToHitPoint != INVALID_DISTANCE)\n        {\n            resultColor = calculatePhong(rayDir, hitPoint, hitPointNormal, hitPointColor);\n#if QUALITY >= 1\n            resultColor *= calculateShadow(hitPoint, hitPointNormal);\n            resultColor *= calculateAmbientOcclusion(hitPoint, hitPointNormal);\n            // We want to have reflections only on floor\n            if (floorHit)\n            \tresultColor = calculateReflections(hitPoint, hitPointNormal, resultColor, rayDir,\n            \t\t\t\t\t\t\t\t   \t   backgroundColor);\n#endif\n            backgroundBlendValue = smoothstep(FLOOR_START_FADING_EDGE, FLOOR_STOP_FADING_EDGE, distanceToHitPoint);\n        }\n        \n        resultColor = mix(resultColor, backgroundColor, backgroundBlendValue);\n        \n#if QUALITY >= 2\n        allResultColors += resultColor;\n    }\n    resultColor = allResultColors / float(ALL_MSAA_SAMPLE_POINTS.length());\n#endif\n    \n    // Gamma correction\n    fragColor = vec4(pow(resultColor, vec3(1./ 2.2)), 0.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// From 0 to 2 (highest)\n#define QUALITY 1\n// If 1 when ray will hit some SDF, it's ID will be returned. That give us ability to\n// (among others) use cumulative soft shadows (soft shadows from more than one objects)\n#define USE_SDF_IDS 1\n// If 1 simple positions of SDF will be used instead of complex matrix transformations.\n// Beside that in SDF struct there is additional place for SDF position.\n#define USE_SIMPLE_SDF_POSITIONS 1\n\n// Max length of the ray used in basic ray marching (depends on size of the biggest SDF)\n#define MAX_RAY_LENGTH 22.\n#define RAY_ORIGIN vec3(11.0, 5.0, 11.0)\n// If distance from point to SDF shape is smaller that this, we assume ray hittted something\n#define MIN_DISTANCE_TO_ASSUME_RAY_HIT 1e-3\n\n#define CAMERA_MOVEMENT_SPEED -20.\n#define CAMERA_INV_DISTANCE_MULTIPLIER 4.\n\n#define BACKGROUND_COLOR (vec3(40., 80., 126.) / 255.)\n\n#define FLOOR_FIRST_COLOR vec3(0.9)\n#define FLOOR_SECOND_COLOR vec3(0.6)\n#define FLOOR_Z_POSITION -0.8\n#define FLOOR_NORMAL vec3(0., 1., 0.)\n#define FLOOR_START_FADING_EDGE 25.\n#define FLOOR_STOP_FADING_EDGE 50.\n\n// How many samplings ambient occlusion will have\n#define AO_STEPS_NUMBER 5.\n// How far from hit point first step of ambient occlusion needs to be performed\n#define AO_FIRST_STEP_DISTANCE_FROM_HIT_POINT 0.005\n// Value of distance between all AO steps\n#define AO_DISTANCE_BETWEEN_STEPS 0.02\n// How much weight of each step changes\n#define AO_EACH_STEP_WEIGHT_MODIFIER 0.95\n// Multiplier of AO effect\n#define AO_STRENGTH 3.\n#define AO_INTENSITY 0.99\n\n#define REFLECTIONS_INTENSITY 0.2\n\n#define SHADOW_INTENSITY 0.9\n// How soft soft-shadows will be\n#define PENUMBRA_FACTOR 12.\n\n#define LIGHT_COLOR vec3(1., 1., 1.)\n#define LIGHT_POSITION (vec3(40., 50., 60.)*0.2)\n\n#define MATERIAL_SHININESS 4.\n#define MATERIAL_AMBIENT_STRENGTH 0.04\n#define MATERIAL_DIFFUSE_STRENGTH 0.8\n#define MATERIAL_SPECULAR_STRENGTH 0.6\n\n// How smooth SDF union will be\n#define SDF_UNION_SMOOTHNESS 8.\n\n////////////////////////////////////////////// END OF CHANGEABLE CODE\n\n#define EPSILON 1e-5\n#define PI 3.1416\n\n// To start calculate soft shadows of given point, we're taking hit point and move it by this value in\n// direction of the light source\n#define DISTANCE_FROM_HIT_POINT_TO_START_CALCULATE_SHADOW 1e-2\n// To start calculate reflections of given point, we're taking hit point and move it by this value in\n// direction of reflected camera direction\n#define REFLECTIONS_DISTANCE_FROM_HIT_POINT_TO_START_CALCULATE 1e-2\n// Value used when we want to show that calculated distance is invalid\n#define INVALID_DISTANCE -1.\n\nconst vec2[] ALL_MSAA_SAMPLE_POINTS = vec2[](\n    vec2(6./16., 2./16.), vec2(14./16., 6./16.), vec2(2./16., 10./16.), vec2(10./16., 14./16.)\n);\n\n\n////////////////////////////////////////////// Basic SDF functions\n\nstruct SDFSphereData\n{\n#if USE_SIMPLE_SDF_POSITIONS == 1\n    vec3 position;\n#endif\n    float radius;\n    vec3 color;\n#if USE_SDF_IDS == 1\n    int id;\n#endif\n};\n    \nstruct SDFBoxData\n{\n#if USE_SIMPLE_SDF_POSITIONS == 1\n    vec3 position;\n#endif\n    vec3 size;\n    vec3 color;\n#if USE_SDF_IDS == 1\n    int id;\n#endif\n};\n    \nstruct SDFCylinderData\n{\n#if USE_SIMPLE_SDF_POSITIONS == 1\n    vec3 position;\n#endif\n    float height;\n    float radius;\n    vec3 color;\n#if USE_SDF_IDS == 1\n    int id;\n#endif\n};\n\nfloat getDistanceToSphereSDF(vec3 pointWS, const vec3 spherePosition, const float sphereRadius)\n{\n#if USE_SIMPLE_SDF_POSITIONS == 1\n    pointWS -= spherePosition;\n#endif\n    return length(pointWS) - sphereRadius;\n}\n    \nfloat getDistanceToSphereSDF(vec3 pointWS, const SDFSphereData sphereData)\n{\n    return getDistanceToSphereSDF(pointWS,\n#if USE_SIMPLE_SDF_POSITIONS == 1\n                                  sphereData.position,\n#else\n                                  vec3(0.),\n#endif\n                                  sphereData.radius);\n}\n\nfloat getDistanceToBoxSDF(vec3 pointWS, const vec3 boxPosition, const vec3 boxSize)\n{\n#if USE_SIMPLE_SDF_POSITIONS == 1\n    pointWS -= boxPosition;\n#endif\n    vec3 boxHalfSize = boxSize / 2.;\n    vec3 distanceToBox = abs(pointWS) - boxHalfSize;\n    return length(max(distanceToBox,0.0)) +\n           min(max(distanceToBox.x,max(distanceToBox.y,distanceToBox.z)),0.0);\n}\n\nfloat getDistanceToBoxSDF(vec3 pointWS, const SDFBoxData boxData)\n{\n    return getDistanceToBoxSDF(pointWS,\n#if USE_SIMPLE_SDF_POSITIONS == 1\n                               boxData.position,\n#else\n                               vec3(0.),\n#endif\n                               boxData.size);\n}\n\nfloat getDistanceToCylinderSDF(vec3 pointWS, const vec3 cylinderPosition,\n                               const float cylinderHeight, const float cylinderRadius)\n{\n#if USE_SIMPLE_SDF_POSITIONS == 1\n    pointWS -= cylinderPosition;\n#endif\n    float halfHeight = cylinderHeight * 0.5;\n    vec2 distanceToCylinder = abs(vec2(length(pointWS.xz),pointWS.y)) -\n        \t\t\t\t      vec2(cylinderRadius,halfHeight);\n  \treturn min(max(distanceToCylinder.x,distanceToCylinder.y),0.0) +\n           length(max(distanceToCylinder,0.0));    \n}\n\nfloat getDistanceToCylinderSDF(vec3 pointWS, const SDFCylinderData cylinderData)\n{\n    return getDistanceToCylinderSDF(pointWS,\n#if USE_SIMPLE_SDF_POSITIONS == 1\n                                    cylinderData.position,\n#else\n                                    vec3(0.),\n#endif\n                                    cylinderData.height, cylinderData.radius);\n}\n\n////////////////////////////////////////////// Functions to intersect/unite/substract different SDF\n\nfloat getSDFBlend(const float distanceA, const vec3 distanceAColor, const int distanceASDFId,\n                  const float distanceB, const vec3 distanceBColor, const int distanceBSDFId,\n                  const float blendValue, out vec3 resultColor, out int resultSDFId)\n{\n    float resultDistance = mix(distanceA, distanceB, blendValue);\n    resultColor = mix(distanceAColor, distanceBColor, blendValue);\n#if USE_SDF_IDS == 1\n    if (abs(resultDistance - distanceA) < abs(resultDistance - distanceB))\n        resultSDFId = distanceASDFId;\n    else\n        resultSDFId = distanceBSDFId;\n#endif\n    return resultDistance;\n}\n\nfloat getSDFBlend(const float distanceA, const vec3 distanceAColor,\n                  const float distanceB, const vec3 distanceBColor,\n                  const float blendValue, out vec3 resultColor)\n{\n    int dummyResultSDFId;\n    return getSDFBlend(distanceA, distanceAColor, 0, distanceB, distanceBColor, 0,\n                       blendValue, resultColor, dummyResultSDFId);\n}\n\nfloat getSDFIntersection(const float distanceA, const vec3 distanceAColor, const int distanceASDFId,\n                         const float distanceB, const vec3 distanceBColor, const int distanceBSDFId,\n                         out vec3 resultColor, out int resultSDFId)\n{\n    if (max(distanceA, distanceB) == distanceA)\n    {\n        resultColor = distanceAColor;\n        resultSDFId = distanceASDFId;\n        return distanceA;\n    }\n    resultColor = distanceBColor;\n    resultSDFId = distanceBSDFId;\n    return distanceB;\n}\n\nfloat getSDFIntersection(const float distanceA, const vec3 distanceAColor,\n                         const float distanceB, const vec3 distanceBColor,\n                         out vec3 resultColor)\n{\n    int dummyResultSDFId;\n    return getSDFIntersection(distanceA, distanceAColor, 0, distanceB, distanceBColor, 0,\n                              resultColor, dummyResultSDFId);\n}\n\nfloat getSDFUnion(const float distanceA, const vec3 distanceAColor, const int distanceASDFId,\n                  const float distanceB, const vec3 distanceBColor, const int distanceBSDFId,\n                  const bool useSmoothness, out vec3 resultColor, out int resultSDFId)\n{\n    bool distanceAIsCloser = false;\n    float resultDistance;\n    if (useSmoothness)\n    {\n     \tfloat res = exp(-SDF_UNION_SMOOTHNESS*distanceA) + exp(-SDF_UNION_SMOOTHNESS*distanceB);   \n        resultDistance = -log(max(EPSILON,res)) / SDF_UNION_SMOOTHNESS;\n        distanceAIsCloser = abs(resultDistance - distanceA) < abs(resultDistance - distanceB);\n    }\n    else\n    {\n        resultDistance = min(distanceA, distanceB);\n        distanceAIsCloser = resultDistance == distanceA;\n    }\n    \n    if (distanceAIsCloser)\n    {\n        resultColor = distanceAColor;\n        resultSDFId = distanceASDFId;\n    }\n    else\n    {\n        resultColor = distanceBColor;\n    \tresultSDFId = distanceBSDFId;\n    }\n    return resultDistance;\n}\n                              \nfloat getSDFUnion(const float distanceA, const vec3 distanceAColor,\n                  const float distanceB, const vec3 distanceBColor,\n                  const bool useSmoothness, out vec3 resultColor)\n{\n    int dummyResultSDFId;\n    return getSDFUnion(distanceA, distanceAColor, 0, distanceB, distanceBColor, 0,\n                       useSmoothness, resultColor, dummyResultSDFId);\n}\n                              \nfloat getSDFDifference(const float distanceA, const vec3 distanceAColor, const int distanceASDFId,\n                       const float distanceB, const vec3 distanceBColor, const int distanceBSDFId,\n                       out vec3 resultColor, out int resultSDFId)\n{\n    // Difference is just a intersection between shape A and inversion of shape B\n    return getSDFIntersection(distanceA, distanceAColor, distanceASDFId,\n                              -distanceB, distanceBColor, distanceBSDFId,\n                              resultColor, resultSDFId);\n}\n\nfloat getSDFDifference(const float distanceA, const vec3 distanceAColor,\n                       const float distanceB, const vec3 distanceBColor,\n                       out vec3 resultColor)\n{\n    // Difference is just a intersection between shape A and inversion of shape B\n    return getSDFIntersection(distanceA, distanceAColor, -distanceB, distanceBColor, resultColor);\n}\n\n////////////////////////////////////////////// Functions which helps with creating matrix that\n// can help with rotating/moving SDF\n\nmat4 createTranslationMatrix(vec3 position)\n{\n    mat4 translationMatrix = mat4(vec4(1., 0., 0., 0.), vec4(0., 1., 0., 0.),\n                                  vec4(0., 0., 1., 0.), vec4(position.x, position.y, position.z, 1.));\n    return translationMatrix;\n}\n\nmat4 createRotationMatrix(vec3 rotationEuler)\n{\n    // Input is in degrees, but to calculate everything property we need radians\n    vec3 rotationTheta = rotationEuler * (PI / 180.);\n    \n    vec3 cosTheta = cos(rotationTheta);\n    vec3 sinTheta = sin(rotationTheta);\n    \n    mat4 rotateAroundXMatrix = mat4(vec4(1., 0., 0., 0.), vec4(0., cosTheta.x, sinTheta.x, 0.),\n                             \t\tvec4(0., -sinTheta.x, cosTheta.x, 0.), vec4(0., 0., 0., 1.));\n    mat4 rotateAroundYMatrix = mat4(vec4(cosTheta.y, 0., -sinTheta.y, 0.), vec4(0., 1., 0., 0.),\n                                    vec4(sinTheta.y, 0., cosTheta.y, 0.), vec4(0., 0., 0., 1.));\n    mat4 rotateAroundZMatrix = mat4(vec4(cosTheta.z, sinTheta.z, 0., 0.), vec4(-sinTheta.z, cosTheta.z, 0., 0.),\n                                    vec4(0., 0., 1., 0.), vec4(0., 0., 0., 1.));\n    // Order of multiplication is crucial!\n    mat4 rotationMatrix = rotateAroundZMatrix * rotateAroundYMatrix * rotateAroundXMatrix;\n    \n    return rotationMatrix;\n}\n\n// Creates classic matrix which translates and then rotates\nmat4 createTransformationMatrix(vec3 position, vec3 rotationEuler)\n{\n    mat4 translationMatrix = createTranslationMatrix(position);\n    mat4 rotationMatrix = createRotationMatrix(rotationEuler); \n    \n    // Scale in case of ray marching needs to be applied in slightly different way, because\n    // result of getDistance function needs to be modified. So we're not adding\n    // scale matrix\n    \n    // Order of multiplication is crucial!\n    mat4 transformationMatrix = rotationMatrix * translationMatrix; // * scaleMatrix;\n    return transformationMatrix;    \n}\n\n// Creates matrix which rotates around given point\nmat4 createRotateAroundPointMatrix(vec3 point, vec3 rotationEuler)\n{\n    // When rotating around a point we need to use two translation matrices \n    mat4 translationMatrix = createTranslationMatrix(point);\n    mat4 secTranslationMatrix = createTranslationMatrix(-point);\n    mat4 rotationMatrix = createRotationMatrix(rotationEuler);\n    \n    return translationMatrix * rotationMatrix * secTranslationMatrix;\n}\n\n////////////////////////////////////////////// Function which creates basic ray\n\nvoid getRayData(const vec2 screenCoord, const vec3 iResolution, const float iTime,\n                out vec3 rayOrigin, out vec3 rayDir)\n{\n    vec2 screenUV = screenCoord / iResolution.xy;\n    vec2 screenPos = 2. * screenUV - 1.;\n    screenPos.x *= iResolution.x / iResolution.y;\n    \n    rayOrigin = RAY_ORIGIN;\n    vec3 rayTargetPoint = vec3(0.);\n    \n    // We want to move camera around center of the scene\n    float cameraAngle = iTime * CAMERA_MOVEMENT_SPEED;    \n    mat4 rotateCameraMatrix = createRotateAroundPointMatrix(vec3(0.), vec3(0., cameraAngle, 0.));\n    rayOrigin = (rotateCameraMatrix * vec4(rayOrigin, 1.)).xyz;\n        \n    vec3 worldUp = vec3(0., 1., 0.);\n    vec3 cameraForward = normalize(rayTargetPoint - rayOrigin);\n    vec3 cameraRight = normalize(cross(cameraForward, worldUp));\n    vec3 cameraUp = normalize(cross(cameraRight, cameraForward));\n    mat3 cameraMatrix = mat3(cameraRight, cameraUp, cameraForward);\n    \n    rayDir = normalize(cameraMatrix * vec3(screenPos, CAMERA_INV_DISTANCE_MULTIPLIER));\n}","name":"Common","description":"","type":"common"}]}