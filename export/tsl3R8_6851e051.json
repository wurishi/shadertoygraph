{"ver":"0.1","info":{"id":"tsl3R8","date":"1545762075","viewed":560,"name":"Glitch with RNG","username":"zeh","description":"A glitch shader using a xorshift-based random number generator.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["random","glitch","rng"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// From ShaderToy to Pixi.JS's WebGL:\n// fragCoord.xy / iResolution.xy => vTextureCoord\n// iTime => u_time\n// iMouse => u_mouse\n// iResolution.xy => u_resolution\n// fragColor => gl_FragColor\n// texture(iChannel0, uv).rgb => texture2D(uSampler, uv).rgb;\n// mainImage(...) ==> main()\n\nprecision lowp    float;\n\nint MIN = -2147483648;\nint MAX = 2147483647;\n\nint xorshift(int value) {\n    // Xorshift*32\n    // Based on George Marsaglia's work: http://www.jstatsoft.org/v08/i14/paper\n    value ^= value << 13;\n    value ^= value >> 17;\n    value ^= value << 5;\n    return value;\n}\n\nint nextInt(out int seed) {\n    seed = xorshift(seed);\n    return seed;\n}\n\nfloat nextFloat(out int seed) {\n    seed = xorshift(seed);\n    // FIXME: This should have been a seed mapped from MIN..MAX to 0..1 instead\n    return abs(fract(float(seed) / 3141.592653));\n}\n\nfloat nextFloat(out int seed, float scale) {\n    return nextFloat(seed) * scale * 2.0 - scale;\n}\n\n// Configuration parameters\nfloat glitchesPerSecond = 12.0;\nfloat maxOffset = 0.02;\nfloat maxColorOffsetX = 0.06;\nfloat maxColorOffsetY = 0.03;\nfloat chanceOfPositionOffset = 0.4;\nfloat chanceOfColorShift = 0.5;\nfloat chanceOfColorAddition = 0.3;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float time = floor(iTime * glitchesPerSecond);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    int rng = int(time * 123.12 + uv.y * 30.1789) / 10 * 10;\n    int rng2 = int((0.5 + fract(uv.y + nextFloat(rng))) * 2.7891);\n    rng = rng / rng2 * rng2;\n\n    // X offset for origin\n    float offsetX = nextFloat(rng, maxOffset);\n    vec2 uvOff = uv;\n    if (nextFloat(rng) < chanceOfPositionOffset) uvOff.x += offsetX;\n    vec3 outCol = texture(iChannel0, uvOff).rgb;\n\n    // Offset colors\n    if (nextFloat(rng) < chanceOfColorShift) {\n        vec2 colOffset = vec2(nextFloat(rng, maxColorOffsetX), nextFloat(rng, maxColorOffsetY));\n        float rnd = nextFloat(rng);\n\n        if (rnd < 0.33) {\n            outCol.r = texture(iChannel0, uv + colOffset).r;\n        } else if (rnd < 0.66) {\n            outCol.g = texture(iChannel0, uv + colOffset).g; \n        } else {\n            outCol.b = texture(iChannel0, uv + colOffset).b;  \n        }\n\t}\n\n    if (nextFloat(rng) < chanceOfColorAddition) {\n        float rnd = nextFloat(rng);\n\n        if (rnd < 0.33) {\n            outCol.r *= 1.2;\n        } else if (rnd < 0.66) {\n            outCol.g *= 1.2; \n        } else {\n            outCol.b *= 1.2;\n        }\n    }\n    \n\n\tfragColor = vec4(outCol, 1.0);\n}","name":"Image","description":"","type":"image"}]}