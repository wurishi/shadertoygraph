{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"float sphIntersect(vec3 p, vec3 c, float r)\n{\t\n\tvec3 tp = p;\n\t\t\n\ttp.x = mod(tp.x+0.,8.)-4.;\n\ttp.y = mod(tp.y+1.,4.)-2.;\n\ttp.z = mod(tp.z+0.,8.)-4.;\n\t\t\n\treturn (distance(tp,c) - r);\n\t\n\tvec3 b = vec3(1.,10.,1.);\n\tfloat temp = distance(p, c) - r;\n\tvec3 d = abs(tp) - b;\n  \tfloat d1 = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n\t\n\ttp.x *= 1.25;\n\ttp.z *= 1.25;\n\ttp.y = mod(tp.y+1., 2.) - 1.;\n\t\n\tfloat d2 = distance(tp, c) - r;\n\t\n\td1 = max(d1,-d2);\n\td2 = -p.y + 1.0;\n\t\n\td1 = min(d1,d2);\n\t\n\ttp.x = mod(p.x+4.0, 8.0) - 4.;\n\ttp.z = mod(p.z+4.0, 8.0) - 4.;\n\ttp.y = p.y;\n\td2 = distance(tp, c) - r;\n\treturn min(d1, d2);\n}\n\nvec3 march(vec3 ro, vec3 rd)\n{\n\tvec3 col = vec3(0.);\n\t\n\tfloat t = 5.;\n\tfloat prevt = 0.;\n\tfloat d = 10000000.;\n\tvec3 p;\n\tint j;\n\tconst int maxSteps = 256;\n\t\n\tvec3 light = (vec3(-1., -2., -1.5));\n\t\n\tfloat maxT = 200.;\n\tvec2 delta = vec2(0.001, 0.0);\n\tfloat radius = 1.5;\n\tvec3 center = vec3(0.0, 0.0, 0.0);\n\t\n\tfor(int i=0; i < maxSteps; i++)\n\t{\n\t\tprevt = t;\n\t\tp = ro + rd * t;\n\t\t\n\t\td = sphIntersect(p, center, radius);\n\t\t\n\t\tj = i+1;\n\t\tt += d;\n\t\t\n\t\tif(abs(d) < 0.001)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tif((j < maxSteps) && t < maxT)\n\t{\n\t\tvec3 norm = vec3(sphIntersect(p + delta.xyy, center, radius) - sphIntersect(p - delta.xyy, center, radius),\n\t\t\t\t\t\t sphIntersect(p + delta.yxy, center, radius) - sphIntersect(p - delta.yxy, center, radius),\n\t\t\t\t\t\t sphIntersect(p + delta.yyx, center, radius) - sphIntersect(p - delta.yyx, center, radius));\n\t\t\n\t\tvec3 lvec = normalize(light);\n\t\tfloat lambert = max(dot(lvec, normalize(norm)), 0.0);\n\t\t\n\t\tfloat falloff = (150. - t) / (145.);\n\t\t\n\t\tvec3 ncol = abs(rd) * lambert + vec3(0.075);\n\t\tcol = ncol * falloff + col * (1. - falloff);\n\t\t\n\t\tcol *= vec3(float(maxSteps-j) / float(maxSteps));\n\t}\n\t\n\treturn col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = uv - 0.5;\n\t\n\tuv.y *= iResolution.y / iResolution.x;\n\t\n\tvec3 cam = vec3(sin(iTime*0.125)*30.0, -10.0, cos(iTime*0.125)*30.0);\n\tvec3 dir = normalize(-cam);\n\tcam.y += sin(iTime*0.75)*2.0;\n\t\n\tvec3 v1 = cross(dir, vec3(0,1,0));\n\tvec3 v2 = cross(dir, v1);\n\t\n\tdir += v1 * uv.x;\n\tdir += v2 * uv.y;\n\t\n\tvec3 col = march(cam, dir);\n\t\n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4dfGDf","date":"1416364767","viewed":188,"name":"raymarcher","username":"zephmann","description":"recursive spheres","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["procedural","raymarching"],"hasliked":0,"parentid":"","parentname":""}}