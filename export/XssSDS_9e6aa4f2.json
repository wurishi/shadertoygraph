{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"#define RENDER_DIST 400\n#define SPEED 20.0\n#define CAM_DIST 70.0\n//montaigne scale\n#define HEIGHT 200.0\n#define WIDTH 0.3\n\nfloat rand(vec2 n)\n{\n  return 0.5 + 0.5 * fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\nfloat interpolation(float a, float b, float alpha){\n\treturn mix(a, b, 0.5-cos(alpha*3.14)/2.0);\n}\n\nfloat noise(vec2 p, vec2 size){\n\t\n\t\n\tfloat h11=rand(vec2(floor(p.x/size.x), floor(p.y/size.y)));\n\tfloat h12=rand(vec2(floor(p.x/size.x), floor(p.y/size.y+1.0)));\n\tfloat h21=rand(vec2(floor(p.x/size.x+1.0), floor(p.y/size.y)));\n\tfloat h22=rand(vec2(floor(p.x/size.x+1.0), floor(p.y/size.y+1.0)));\n\t\n\tfloat px=fract(p.x/size.x);\n\tfloat py=fract(p.y/size.y);\n\t\n\treturn interpolation(interpolation(h11, h21, px), interpolation(h12, h22, px), py);\n}\n\nfloat perlinnoise(vec2 p){\n\treturn ( noise(p*WIDTH, vec2(8.0)) * 0.25+noise(p*WIDTH, vec2(32.0)) )*HEIGHT;\t\n}\n\nfloat mymod(float value, float modulus) {\n  return mod((mod(value, modulus) + modulus), modulus);\n}\n\nfloat intbound(float s, float ds) {\n\t// Find the smallest positive t such that s+t*ds is an integer.\n\tif (ds < 0.0) {\n\t\ts=-s;\n\t\tds=-ds;\n\t}\n\ts = mod(s, 1.0);\n\t// problem is now s+t*ds = 1\n\treturn (1.0-s)/ds;\n}\n\nvec3 intbound(vec3 s, vec3 ds){\n\treturn vec3(intbound(s.x, ds.x), intbound(s.y, ds.y), intbound(s.z, ds.z));\t\n}\n\n\nvec4 raycast(vec3 camPos, vec3 rayDir, out vec3 normal){\n\tvec3 voxelPos=floor(camPos);\n\tvec3 rayStep=sign(rayDir);\n\tvec3 tMax=intbound(camPos, rayDir);\n\tvec3 delta=rayStep/rayDir;\n\t\n\tbvec3 mask;\n\t\n\tfor(int i=0; i<RENDER_DIST;i++){\n\t\tbvec3 b1 = lessThan(tMax.xyz, tMax.yzx);\n\t\tbvec3 b2 = lessThanEqual(tMax.xyz, tMax.zxy);\n\t\tmask.x = b1.x && b2.x;\n\t\tmask.y = b1.y && b2.y;\n\t\tmask.z = b1.z && b2.z;\n\t\t\n\t\ttMax += vec3(mask) * delta;\n\t\tvoxelPos += vec3(mask) * rayStep;\n\t\t\n\t\tif(voxelPos.y<perlinnoise(voxelPos.xz)){\n\t\t\tnormal = -vec3(mask)*rayStep;\n\t\t\treturn vec4(voxelPos, 1.0);\n\t\t}\n\t}\n\tnormal = vec3(mask)*rayStep;\n\treturn vec4(voxelPos, -1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//pixel coord (-1, 1)\n\tvec2 uv = (fragCoord.xy / iResolution.xy)*2.0-1.0;\n\t\n\t//camera\n\tvec3 camPos=vec3(CAM_DIST-iTime*SPEED, HEIGHT*1.4, 150.0);\n\tcamPos.y=perlinnoise(camPos.xz)+CAM_DIST*0.25;\n\t\n\tvec3 camView=vec3(-iTime*SPEED, 0.0, 50.0);\n\tcamView.y=perlinnoise(camView.xz);\n\n\tvec3 camUp=vec3(0.0, 1.0, 0.0);\n\t\n\t//ray dir\n\tvec3 camDir=normalize(camView-camPos);\n  \tvec3 u=normalize(cross(camUp,camDir));\n  \tvec3 v=cross(camDir,u);\n  \tvec3 vcv=(camPos+camDir);\n  \tvec3 scrCoord=vcv+uv.x*u*0.8+uv.y*v*0.8;\n  \tvec3 rayDir=(scrCoord-camPos)*float(RENDER_DIST);\n\t\n\t//raycast\n\tvec3 normal;\n\tvec4 ret=raycast(camPos, rayDir, normal);\n\tvec3 p=floor(ret.xyz);\n\tfloat sky=ret.w;\n\t\n\t//color\n\tvec3 light=vec3(0.0, 1.0, 0.0);\n\tvec3 color=vec3(0.3, 0.3, 1.0);\n\tfloat diff=1.0;\n\t\n\tif(sky>0.0){\n\t\t//color=vec3(p.y/HEIGHT, p.x/150.0+0.5, p.z/150.0+0.5);\n\t\tcolor=texture(iChannel0, p.xz/150.0).xyz;\n\t\tdiff=max(dot(light, normal), 0.0);\n\t\tdiff=diff*0.3+0.7;\n\t}\n\t\n\t//fin\n\tfragColor = vec4(color*diff,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XssSDS","date":"1406374308","viewed":1202,"name":"cubic desert","username":"jngl","description":"implementation of http://www.cse.yorku.ca/~amana/research/grid.pdf","likes":7,"published":1,"flags":0,"usePreview":1,"tags":["raycast","voxel"],"hasliked":0,"parentid":"","parentname":""}}