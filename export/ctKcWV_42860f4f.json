{"ver":"0.1","info":{"id":"ctKcWV","date":"1700735327","viewed":29,"name":"Improved Cloudy Mountains","username":"serioux666","description":"Improved version of my previous Cloudy Mountains shader. Uses iq's motion blur depth reprojection code, added a new camera controller and improved the lighting.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","terrain","clouds","shakycamera","okayish"],"hasliked":0,"parentid":"ctKyRd","parentname":"Cloudy Mountains"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 pixel = texture(iChannel0, uv);\n    vec3 col = vec3(0., 0., 0.);\n    if(pixel.a < 0.0 || false) {\n        col += texture(iChannel0, uv).rgb;\n    } else {\n        float ss = mod(pixel.a,1024.0)/1023.0;\n        float st = floor(pixel.a/1024.0)/1023.0;\n\n        // motion blur (linear blur across velocity vectors\n        vec2 dir = (-1.0 + 2.0*vec2( ss, st ))*0.25;\n        const float N = 16.;\n        for(float t = -.5; t <= 0.5; t += 1.0 / (N - 1.)) {\n            col += texture(iChannel0, uv + dir * t).rgb;\n        }\n        col /= N;\n   }\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int ANTIALIASING = 0; /* broken! */\n#define USE_SMOOTH_NOISE 0\n#define USE_SHADOWED_CLOUDS 0\n\nconst vec3 c = vec3(1.,0.,-1.);\nconst float pi = 3.14159265359;\nconst float MAX_DEPTH = 200.;\nvec3 LIGHT_DIR = normalize(vec3(2.0, 1.0, 3.0));\nconst vec4 COLOR_GRASS = vec4(0.4, 0.7, 0.23, 0.3);\nconst vec4 COLOR_DIRT = vec4(0.4, 0.4, 0.0, 0.1);\nconst vec4 COLOR_SNOW = vec4(0.95, 0.95, 1.0, 1.);\nconst vec4 COLOR_STONE = vec4(0.6, 0.6, 0.5, 0.7);\nconst vec3 COLOR_FOG = vec3(0.7, 0.7, 1.0);\nconst vec3 COLOR_SKY = vec3(0.4, 0.5, .8) * 0. + COLOR_FOG;\nconst vec3 COLOR_SUN = vec3(1.0, 1.0, 0.7);\nconst float CLOUD_FLOOR = 5.;\nconst float CLOUD_CEIL = CLOUD_FLOOR + 100.;\nconst float I_SUN = .8;\nconst float I_AMBIENT = .2;\nconst float SHININESS = 4.;\n\nconst float TERRAIN_SIZE = 15.;\nconst float TERRAIN_GAIN = 0.5;\nconst float TERRAIN_LACUNARITY = 1.9;\nconst float TERRAIN_SNOW_HEIGHT = 20.0;\nconst float TERRAIN_EXPONENT = 2.5;\nconst float TERREIN_SNOW_HEIGHT_BIOME_FACTOR = 7.0;\n\n\n// iq's elevated\nvec3 noised( in vec2 x )\n{\n    vec2 f = fract(x);\n    #if USE_SMOOTH_NOISE==0\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n    #else\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n    #endif\n\n#if 1\n    // texel fetch version\n    ivec2 p = ivec2(floor(x));\n    float a = texelFetch( iChannel0, (p+ivec2(0,0))&255, 0 ).x;\n\tfloat b = texelFetch( iChannel0, (p+ivec2(1,0))&255, 0 ).x;\n\tfloat c = texelFetch( iChannel0, (p+ivec2(0,1))&255, 0 ).x;\n\tfloat d = texelFetch( iChannel0, (p+ivec2(1,1))&255, 0 ).x;\n#else    \n    // texture version    \n    vec2 p = floor(x);\n\tfloat a = textureLod( iChannel0, (p+vec2(0.5,0.5))/256.0, 0.0 ).x;\n\tfloat b = textureLod( iChannel0, (p+vec2(1.5,0.5))/256.0, 0.0 ).x;\n\tfloat c = textureLod( iChannel0, (p+vec2(0.5,1.5))/256.0, 0.0 ).x;\n\tfloat d = textureLod( iChannel0, (p+vec2(1.5,1.5))/256.0, 0.0 ).x;\n#endif\n    \n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\tdu*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nmat3 rotationX( float angle ) {\n\tfloat ca = cos( angle );\n\tfloat sa = sin( angle );\n\t\n\treturn mat3(\n\t\t1., 0., 0.,\n        0., ca, sa,\n        0.0, -sa, ca\n\t);\n}\n\nconst mat2 m = mat2(0.8, -0.6, 0.6, 0.8);\nconst mat3 m3d = mat3(1., 0., 0., 0., 0.8, -0.6, 0., 0.6, 0.8);\n\nfloat fbmBiome(vec2 p)\n{\n    float f = 0.;\n    float a = 1.;\n    p /= 20.;\n\tfor(int i = 0; i < 3; ++i) {\n        f += a *  noised(p).x,\n        p *= 1.1;\n        a *= .2;\n        p = m * p;\n    }\n\treturn f;\n}\n\n\nfloat cloudFbm(vec3 p)\n{\n    float f = 0.;\n    float a = 1.;\n    //p /= 256.0 * 4.;\n    p /= 1000.;\n\tfor(int i = 0; i < 2; ++i) {\n        f += a *  texture(iChannel1, p).r,\n        p = m3d * p * 3.3;\n        a *= 0.35;\n    }\n    return f;\n}\n\nfloat cloudDensity(vec3 p)\n{\n    const float threshold = 0.8;\n    float density = cloudFbm(p + c.xyy * iTime * 2.4 + 20.0 * cloudFbm(p + iTime * .4 + 20.0 * cloudFbm(p + iTime * 1.)));\n    float bound = smoothstep(CLOUD_FLOOR, CLOUD_FLOOR + 2., p.y) * smoothstep(CLOUD_CEIL, CLOUD_CEIL - 2., p.y);\n    return max(0., density - threshold) / (1. - threshold) * bound * 1.0;\n}\n\nfloat cloudCast(vec3 p, vec3 dir, int N, out float opaque, float max_depth)\n{\n    opaque = 0.0;\n    float t = 0.;\n    float tm = max_depth;\n    if(abs(dir.y) < 0.001 && (p.y < CLOUD_FLOOR || p.y > CLOUD_CEIL)) {\n        return 0.;\n    } else if(abs(dir.y) > 0.001) {\n        t = max(min((CLOUD_FLOOR - p.y) / dir.y, (CLOUD_CEIL - p.y) / dir.y), 0.);\n        tm = min(max((CLOUD_FLOOR - p.y) / dir.y, (CLOUD_CEIL - p.y) / dir.y), max_depth);\n    }\n    if(tm < 0.0) {\n        return 0.;\n    }\n    opaque = 0.0;\n    float dt = (tm - t) / float(N);\n    float max_density = 0.0;\n    for(int i = 0; i < N && t < tm; ++i) {\n        float density = cloudDensity(p + t * dir) / float(N);\n        max_density = max(density, max_density);\n        opaque += density * dt;\n        dt = (1.0 - density) * (tm - t) / float(N - i);\n        t += dt;\n    }\n    return max_density;\n}\n\nfloat calcTerrainShadowCoarse(vec3 p0, vec3 dir, int N, float max_depth);\n\nfloat shadowedCloudCast(vec3 p, vec3 dir, int N, out float opaque, out float lightness, float max_depth)\n{\n    opaque = 0.0;\n    float t = 0.;\n    float tm = max_depth;\n    if(abs(dir.y) < 0.001 && (p.y < CLOUD_FLOOR || p.y > CLOUD_CEIL)) {\n        return 0.;\n    } else if(abs(dir.y) > 0.001) {\n        t = max(min((CLOUD_FLOOR - p.y) / dir.y, (CLOUD_CEIL - p.y) / dir.y), 0.);\n        tm = min(max((CLOUD_FLOOR - p.y) / dir.y, (CLOUD_CEIL - p.y) / dir.y), max_depth);\n    }\n    if(tm < 0.0) {\n        return 0.;\n    }\n    opaque = 0.0;\n    lightness = 0.0;\n    float dt = (tm - t) / float(N);\n    float max_density = 0.0;\n    float max_lightness = 0.;\n    for(int i = 0; i < N && t < tm && opaque < 1.0; ++i) {\n        vec3 ps = p + t * dir;\n        float density = cloudDensity(ps) / float(N);\n        max_density = max(density, max_density);\n        if(N % 8 == 0) {\n            lightness += dt * calcTerrainShadowCoarse(ps, LIGHT_DIR, 16, 50.) * density;\n            max_lightness += dt * density;\n        }\n        opaque += density * dt;\n        dt = (1.0 - density) * (tm - t) / float(N - i);\n        t += dt;\n    }\n    opaque = min(opaque, 1.);\n    if(max_lightness > 0.) {\n        lightness = max(0.3, lightness / max_lightness);\n    }\n    return max_density;\n}\n\nfloat terrainFbm(vec2 p, int N)\n{\n    float f = 0.;\n    float a = 1.;\n    //p /= 256.0 * 4.;\n    p /= 100.;\n\tfor(int i = 0; i < N; ++i) {\n        f += a *  noised(p).x,\n        p = m * p * TERRAIN_LACUNARITY;\n        a *= TERRAIN_GAIN;\n    }\n    return f;\n}\n\n\nfloat terrainHeight(vec2 p, int n)\n{\n\treturn pow(terrainFbm(p + terrainFbm(p, 4) * 5., n), TERRAIN_EXPONENT) * TERRAIN_SIZE;\n}\n\nfloat terrainHeightCoarse(vec2 p)\n{\n\n\treturn terrainHeight(p, 3);\n}\n\n\nfloat terrainHeightMedium(vec2 p)\n{\n\n\treturn terrainHeight(p, 10);\n}\n\nfloat terrainHeightFine(vec2 p)\n{\n\treturn terrainHeight(p, 14);\n}\n\nvec3 terrainNormal(vec3 p, float depth, int n)\n{\n    vec2 epsilon = vec2(0.001 * depth, 0.);\n    return normalize(vec3(\n        terrainHeight(p.xz - epsilon.xy, n) - terrainHeight(p.xz + epsilon.xy, n),\n        2. * epsilon.x,\n        terrainHeight(p.xz - epsilon.yx, n) - terrainHeight(p.xz + epsilon.yx, n)));\n}\n\n\nfloat raycastTerrain(vec3 p0, vec3 dir, out vec3 p)\n{\n    /* see iq's elevated */\n    float t = 0.;\n    for(int i = 0; i < 128 && t < MAX_DEPTH; ++i) {\n        p = p0 + t * dir;\n        float dh = p.y - terrainHeightMedium(p.xz);\n        if(abs(dh) < 0.001 * t) {\n            break;\n        }\n        t += 0.5 * dh;\n    }\n    \n    return t;\n}\n\nfloat calcTerrainShadow(vec3 p0, vec3 dir, int N, float max_depth)\n{\n    float t = 0.4;\n    float lightness = 1.0;\n    const float k = 3.0;\n    for(int i = 0; i < N && t < max_depth; ++i) {\n        vec3 p = p0 + t * dir;\n        float h = p.y - terrainHeight(p.xz, 8);\n        float dt = 0.8 * h;\n        lightness = min(lightness, max(0., k * h / t));\n        t += 0.8 * h;\n    }\n    return lightness;\n}\n\nfloat calcTerrainShadowCoarse(vec3 p0, vec3 dir, int N, float max_depth)\n{\n    float t = 0.0;\n    for(int i = 0; i < N && t < max_depth; ++i) {\n        vec3 p = p0 + t * dir;\n        float h = p.y - terrainHeightCoarse(p.xz);\n        if(h < 0.001 * t) {\n            return 0.0;\n        }\n        float dt = 0.8 * h;\n        t += 0.8 * h;\n    }\n    return 1.0;\n}\n\n\nfloat calcCloudShadow(vec3 p0, vec3 dir)\n{\n    return 1.0;\n    float cloud_density;\n    float max_density = cloudCast(p0, LIGHT_DIR, 6, cloud_density, MAX_DEPTH);\n    return clamp(1. - max_density, 0.4, 1.0);\n}\n\nvec4 renderClouds(vec3 eye, vec3 dir, float max_depth)\n{\n    /* cloud layer */\n    float density;\n    float lightness = 1.;\n#if USE_SHADOWED_CLOUDS==1\n    float greyness = shadowedCloudCast(eye, dir, 48, density, lightness, max_depth);\n#else\n    float greyness = cloudCast(eye, dir, 48, density, max_depth);\n#endif\n    greyness = min(1., greyness + max(0., density - 1.0) * 0.5);\n    //max_density += min(1.0, density + 0.4);\n    vec3 col = mix(c.xxx, c.xxx * 0.6, smoothstep(0.2, 1., greyness));\n    //col = mix(col, COLOR_FOG, smoothstep(MAX_DEPTH * 0.5, MAX_DEPTH * 4.7, dist));\n    return vec4(mix(COLOR_FOG, col, lightness), min(max(0., 1.0 - density * 0.3), density));\n}\n\nvec4 render(vec3 eye, vec3 dir)\n{\n    vec3 col = COLOR_FOG;\n    vec3 p_terrain;\n    float ambient = 0.15;\n    float dist_terrain = raycastTerrain(eye, dir, p_terrain);\n    vec2 velocity = vec2(0., 0.);\n    if(dist_terrain < MAX_DEPTH) {\n        /* terrain */\n        float biome = fbmBiome(p_terrain.xz + fbmBiome(p_terrain.xz));\n        vec3 n = terrainNormal(p_terrain, dist_terrain, 14);\n        float shadow = min(1., calcTerrainShadow(p_terrain, LIGHT_DIR, 28, MAX_DEPTH) * calcCloudShadow(p_terrain, LIGHT_DIR) + ambient);\n        vec4 col_ground = mix(COLOR_GRASS, COLOR_DIRT, smoothstep(0.3, 0.8, biome));\n        col_ground = mix(COLOR_STONE, col_ground, smoothstep(0.9, .95, n.y));\n        vec4 col_snow = mix(COLOR_STONE, COLOR_SNOW, smoothstep(0.4, .7, n.y));\n        vec4 col_terrain = mix(col_ground, col_snow, smoothstep(TERRAIN_SNOW_HEIGHT, TERRAIN_SNOW_HEIGHT + abs(biome) * 5., p_terrain.y + biome * TERREIN_SNOW_HEIGHT_BIOME_FACTOR));\n        col = I_SUN * shadow * clamp(dot(LIGHT_DIR, n), 0.0, 1.0) * col_terrain.rgb * COLOR_SUN;\n        col += I_AMBIENT * col_terrain.rgb * COLOR_SKY;\n        col += shadow * I_SUN * col_terrain.rgb * col_terrain.a * pow(clamp(dot((LIGHT_DIR - dir), n) / length(LIGHT_DIR - dir), 0., 1.), SHININESS);\n        col = mix(col, COLOR_FOG, smoothstep(MAX_DEPTH * 0.1, MAX_DEPTH * 0.95, dist_terrain));\n        //col = c.xxx * biome;\n    } else {\n        dist_terrain = MAX_DEPTH;\n    }\n    vec4 cloud = renderClouds(eye, dir, dist_terrain);\n    col = mix(col, cloud.rgb, cloud.a);\n    return vec4(col, dist_terrain);\n}\n\nstruct cameraState\n{\n    vec3 pos;\n    vec3 target;\n    float roll;\n    float focal_length;\n};\n\nfloat fovToFocalLength(float FOV)\n{\n    return tan((90. - FOV/2.)/180.* pi) * 0.5;\n}\n\nvec3 cameraPath(float time)\n{\n    float speed = 0.9;\n    vec3 pos = vec3(\n        cos(0.2 * speed * time) * 100. + cos(0.0001 * time * speed) * 500.,\n        0.5 * (cos(0.01 * time) + 1.) * 7. + 3.,\n       7.0 * time * speed);\n    pos.y += terrainHeightCoarse(pos.xz) + 7.0;\n    pos.y = max(pos.y, terrainHeightFine(pos.xz) + 0.5);\n    return pos;\n}\n\ncameraState moveCamera(float time)\n{\n    cameraState cs;\n    cs.pos = cameraPath(time);\n    cs.target = cameraPath(time + 3.);\n    cs.roll = sin(0.1 * time) * 0.1;\n    cs.focal_length = fovToFocalLength(40.);\n    return cs;\n}\n\nmat3 cameraTransform(cameraState cs)\n{\n    vec3 cw = normalize(cs.target - cs.pos);\n    vec3 up = vec3(sin(cs.roll), cos(cs.roll), 0.0);\n    vec3 cu = normalize(cross(cw, up));\n    vec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //float azimuth = iTime * 0.5;\n    //LIGHT_DIR = normalize(vec3(cos(azimuth), abs(sin(azimuth)), 0.0));\n    vec2 xy = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n    vec3 col;\n    float speed = 8.5;\n    float FOV;\n    cameraState cs = moveCamera(iTime);\n    mat3 camTransform = cameraTransform(cs);\n    float t = MAX_DEPTH;\n    vec3 dir;\n\n    // super duper super sampling    \n    const float dss = 1. / float(ANTIALIASING + 1);\n    for(float xss = 0.; xss < 1.0; xss += dss) {\n        for(float yss = 0.; yss < 1.0; yss += dss) {\n            vec3 dir = normalize(vec3(xy, cs.focal_length) + vec3(xss, yss, 0.));\n            dir = camTransform * dir;\n\n            vec4 pixel = render(cs.pos, dir);\n            col += pixel.rgb;\n            t = min(pixel.a, t);\n     }\n    }\n    //-------------------------------------\n\t// velocity vectors (through depth reprojection)\n    // from iq's elevated\n    //-------------------------------------\n    float vel = 0.0;\n    #if 1\n    if( t<0.0 || t > MAX_DEPTH )\n    {\n        vel = -1.0;\n    }\n    else\n    {\n\n        // old camera position\n        cameraState oldCs = moveCamera(iTime - 1.0/24.0);\n        mat3 oldTransform = cameraTransform(oldCs);\n\n        // world space\n        vec3 dir = camTransform * normalize(vec3(xy, cs.focal_length));\n        vec3 wpos = cs.pos + dir * t;\n        // camera space\n        vec3 cpos = vec3( dot( wpos - oldCs.pos, oldTransform[0] ),\n                          dot( wpos - oldCs.pos, oldTransform[1] ),\n                          dot( wpos - oldCs.pos, oldTransform[2] ) );\n        // ndc space\n        vec2 npos = oldCs.focal_length * cpos.xy / cpos.z;\n        // screen space\n        vec2 spos = 0.5 + 0.5*npos*vec2(iResolution.y/iResolution.x,1.0);\n\n        // compress velocity vector in a single float\n        vec2 uv = fragCoord/iResolution.xy;\n        spos = clamp( 0.5 + 0.5*(spos - uv)/0.25, 0.0, 1.0 );\n        vel = floor(spos.x*1023.0) + floor(spos.y*1023.0)*1024.0;\n    }\n    #endif\n    \n    // Output to screen\n    fragColor = vec4(col * dss * dss, vel);\n}","name":"Buffer A","description":"","type":"buffer"}]}