{"ver":"0.1","info":{"id":"tdXXWS","date":"1594050208","viewed":158,"name":"Laser smoke","username":"kvick","description":"This was an attempt to try and get a smoke-type effect with the retro look. \nWorked on this a really long time ago and I wouldn't really consider it a success but figured I'd just post it anyways.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["smoke","laser"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265358979\n#define PI2 6.28318530718\n\n//Draw line start\n#define DLS(adef) b = adef;\n//Draw line next\n#define DLN(bdef) a = b; b = bdef; color += vec3(1.0, 0., 0.) * getLine(st, a, b);\n\n//--------------------------------------------------------------------------------\n//  1 out, 1 in...\n#define HASHSCALE 3.10432424231\nfloat hash2d(vec2 p)  // replace this by something better\n{\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat Hash(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE);\n    p3 += dot(p3, p3.yzx + 15.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash2d( i + vec2(0.0,0.0) ), \n                     hash2d( i + vec2(1.0,0.0) ), u.x),\n                mix( hash2d( i + vec2(0.0,1.0) ), \n                     hash2d( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat fbm(in vec2 uv)\n{\n    uv *= 8.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    float f  = 0.5000*noise( uv ); uv = m*uv;\n    f += 0.2500*noise( uv ); uv = m*uv;\n    f += 0.1250*noise( uv ); uv = m*uv;\n    f += 0.0625*noise( uv ); uv = m*uv;\n    return f;\n}\n\n//--------------------------------------------------------------------------------\nfloat Linear(float x, float v0, float v1) \n{\n\treturn (v1-v0)*x + v0;\n}\n\n//--------------------------------------------------------------------------------\nfloat Smoothstep(float x, float v0, float v1) \n{\n\tx = x*x*(3.0-2.0*x);\n\treturn (v1-v0)*x + v0;\n}\n\nfloat Line(vec2 st, vec2 a, vec2 b, float w)\n{\n \tvec2 ab = b - a;\n    vec2 aToST = st - a;\n    float t = clamp(dot(aToST, ab) / dot(ab, ab), 0., 1.);\n    float d = length(aToST - ab * t) - w * 0.5;\n    return d;\n}\n\nfloat distToLine(vec2 st, vec2 a, vec2 b)\n{\n\tvec2 ab = b - a;\n    vec2 aToST = st - a;\n    float t = clamp(dot(ab, aToST) / dot(ab, ab), 0., 1.);\n    float d = length(a + ab * t - st);\n    \n    //doing some fudging to achieve the falloff line look for vectrex\n    //d /= t * 1.;\n    \n    return d;\n}\n\nfloat getLine(vec2 st, vec2 start, vec2 end)\n{\n    float jitterIntensity = 0.001;\n    float jitter = Hash(sin(iTime * 250.)) * jitterIntensity;\n    \n    float f = 0.;\n    float dist2Line = distToLine(st, start, end) + jitter;\n    \n    f = (0.01 / (dist2Line));\n    \n    f *= 0.1;\n    \n    return clamp(f, 0., 1.);\n}\n\nvec3 rotZ(vec3 b, float d)\n{\n    mat3 A = mat3(\n        cos(d),\t-sin(d), \t0.,\n        sin(d), cos(d), \t0.,\n        0., \t0., \t\t1.\n        );\n    \n    vec3 result = (A * b);\n    return result;\n}\n\nvec3 rotY(vec3 b, float d)\n{\n    mat3 A = mat3(\n        cos(d), \t\t0., \tsin(d), \n        0., \t\t\t1., \t0., \n        -sin(d), \t\t0., \tcos(d)\n        );\n    \n    vec3 result = (A * b);\n    return result;\n}\n\nvec3 rotX(vec3 b, float d)\n{\n    mat3 A = mat3(\n        1., \t0., \t\t0.,\n        0.,\t\tcos(d),\t\t-sin(d),\n        0.,\t\tsin(d), \tcos(d)\n        );\n    \n    vec3 result = (A * b);\n    return result;\n}\n\nvec2 rot2d(vec2 a, float d)\n{\n\tvec3 temp = vec3(a.x, a.y, 0.);\n    temp = rotZ(temp, d);\n    return vec2(temp.x, temp.y);\n}\n\nvec2 pToS(vec3 p)\n{\n    p = rotY(p, iTime * 0.);\n    p = rotX(p, -0.85 + sin(iTime * 0.2) * 0.1 + 0.1);\n    p = rotZ(p, 0.0);\n    vec3 pCenter = vec3(0.15, 0.35, -1.45);\n    p += pCenter;\n    p.x += sin(p.z * 1.0);\n    \n    return vec2(p.x / p.z, p.y / p.z);\n}\n\nvec3 Planet( in vec2 st)\n{\n    return vec3(0.0);\n}\n\nfloat getCircDist(in vec2 st, in vec2 p, in float r)\n{\n    vec2 vTo = p - st;\n    float degs = atan(vTo.y, vTo.x);\n    degs *= 0.03;\n \treturn length(vTo) - r + sin(degs) * 0.1;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdPentagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(0.809016994,0.587785252,0.726542528);\n    p.x = abs(p.x);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    return length(p-vec2(clamp(p.x,-r*k.z,r*k.z),r))*sign(p.y-r);\n}\n\n\n//================================================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float aspect = iResolution.x/iResolution.y;\n\tuv.x *= aspect;\n\tvec2 st = uv;\n    st -= vec2(0.5 * aspect, 0.5);\n    \n\tfloat f;\n    \n    float iTime = iTime * 1.0;\n    \n    vec3 color = vec3(0.);\n\t\n    float deg = iTime * PI * 0.25;\n    float halfPI = PI * 0.5;\n    \n    color += vec3(0.8, 0., 0.) * f;\n    \n    vec3 smokeColor = vec3(0.5, 1.0, 0.0);\n    vec2 a = vec2(0., 0.);\n    vec2 b = vec2(0.5, 0.);\n    \n    st *= 8.5;\n    \n    float distFunc = 1.;\n    \n    float y = mod((iTime * 0.1) + fbm(vec2(iTime * 0.001)), 2.2) - 1.1;\n    \n    float modTime = iTime * 0.3;\n    for (float i = 1.0; i <= 15.0; i += 1.0)\n    {\n        float hashi = Hash(i) * 5.0;\n        y = i * 0.2 - mod(modTime, 5.);\n        vec2 particlePos = vec2(0., y);\n        particlePos.x += fbm(vec2(modTime * 0.01, particlePos.y * 0.2 + hashi * 0.1)) * pow(y, 2.0);\n        \n        distFunc = min(distFunc,\n        //getCircDist(st, vec2(-0.3 + fbm(vec2(iTime * 0.14, y)) * 0.11, y), 0.33 + Hash(st.x + iTime) * 0.015)\n                      \n        //sdBox(st + vec2(i * 0.3, 0.0), vec2(0.01 + i * 0.02, 0.2))\n                       \n                       /*\n        sdBox(rot2d(st + particlePos, modTime * hashi), \n              vec2(0.21 + hashi * 0.06, 0.4 * (-y + 2.0))\n             )*/\n                       \n        sdPentagon(rot2d(st + particlePos, modTime * hashi), \n              //vec2(\n                  //, 0.21 + hashi * 0.06\n                  0.4 * (-y + 2.0)\n                  )\n        );\n\n    }\n    \n    float circResult = (1.2 - pow(abs(distFunc), 0.15)) * 1.1;\n    color += smokeColor * circResult;\n    \n    \n    //float gamma = Smoothstep(st.y, 1.99, 8.0);\n    float gamma = 2.7;\n    color = vec3(pow(color.x, gamma), pow(color.y, gamma), pow(color.z, gamma));\n    \n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}