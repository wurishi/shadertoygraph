{"ver":"0.1","info":{"id":"WsKSz3","date":"1574612235","viewed":131,"name":" sphere tracing test-mod3","username":"jorge2017a1","description":" sphere tracing test-mod3","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["spheretracingtestmod3"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"///Created by neur0sys in 2019-11-22\n//modificado por jorge 24-11-2019\n\nconst int NONE = 0;\nconst int SPHERE = 1;\nconst int PLANE = 2;\nconst int TORUS = 3;\nconst int BOX = 4;\nconst int LIGHT = 5;\n\nconst vec3 sphere_pos = vec3(2.0, -2.0, -5.0);\nconst vec3 box_pos = vec3(-2.0, -2.0, -5.0);\nconst vec3 torus_pos = vec3(0.0, 2.0, -5.0);\nconst vec3 plane_pos = vec3(0.0, -2.0, 0.0);\n\nstruct Obj {\n    int type;\n    float d;\n};\n\n\n// sdf primitives https://iquilezles.org/articles/distfunctions\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  float t = iTime;\n  //p.xz *= mat2(cos(t), -sin(t), sin(t), cos(t));\n  //p.yz *= mat2(cos(t), -sin(t), sin(t), cos(t));\n  //p.xy *= mat2(cos(t), -sin(t), sin(t), cos(t));\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  float t0 = iTime;\n  p.xz *= mat2(cos(t0), -sin(t0), sin(t0), cos(t0));\n  p.yz *= mat2(cos(t0), -sin(t0), sin(t0), cos(t0));\n  p.xy *= mat2(cos(t0), -sin(t0), sin(t0), cos(t0));\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nvec3 traceAmbient()\n{\n    // ambient\n    float ambientStrength = 0.1;\n    vec3 ambient = ambientStrength * vec3(1.0);\n    return ambient;\n}\n\nvec3 traceDiffuse(vec3 lightDir, vec3 n)\n{\n    // diffuse\n    float diff = max(dot(n, lightDir), 0.0);\n    vec3 diffuse = diff * vec3(1.0);\n    \n    vec3 c = vec3(1.0);\n    \n    return diffuse * c;\n}\n\nvec3 traceSpecular(vec3 lightDir, vec3 hit, vec3 l0, vec3 n)\n{\n    // specular\n    vec3 viewDir = normalize(hit - l0);\n    vec3 reflectDir = reflect(lightDir, n); \n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 64.0);\n    return vec3(spec);\n}\n\nvec3 getLightPos()\n{\n    float t0 = iTime;\n    vec3 lightPos = vec3(0.0, 2.0, -15.0);\n    lightPos.z += cos(t0) * 8.0;\n    lightPos.x += sin(t0) * 8.0;\n    return lightPos;\n}\n\n\nvec3 getLightPosv2()\n{\n    float t0 = iTime;\n    vec3 lightPos = vec3(0.0, 1.0, -2.0);\n    lightPos.x += sin(t0) * 4.0;\n    \n    return lightPos;\n}\n\n\n\n\nvec3 traceLight(vec3 n, vec3 hit, vec3 l0)\n{\n    vec3 lightDir = normalize(getLightPos() - hit);\n    \n    vec3 ambient = traceAmbient();\n\n    vec3 diffuse = traceDiffuse(lightDir, n);\n\n    vec3 spec = traceSpecular(lightDir, hit, l0, n);\n   \n    \n    //return ambient + diffuse + spec;\n    return ambient + diffuse + spec;\n     \n}\n\n\n\nvec3 traceLightLuz(vec3 n, vec3 hit, vec3 l0, vec3 luz)\n{\n    vec3 lightDir = normalize(luz - hit);\n    \n    vec3 ambient = traceAmbient();\n\n    vec3 diffuse = traceDiffuse(lightDir, n);\n\n    vec3 spec = traceSpecular(lightDir, hit, l0, n);\n    \n  \n   \n    return ambient + diffuse + spec;\n}\n\n\n\n\n#define EPSILON 1e-3\nconst vec3 e = vec3(0.01, 0, 0);\n\nvec3 nBox(vec3 p, vec3 b) {\n    float d = sdBox(p, b);\n\tvec3 n = d - vec3(\n    \tsdBox(p - e.xyy, b),\n        sdBox(p - e.yxy, b),\n        sdBox(p - e.yyx, b)\n    );\n    return normalize(n);\n}\n\nvec3 nSphere(vec3 p, float s) {\n    float d = sdSphere(p, s);\n\tvec3 n = d - vec3(\n    \tsdSphere(p - e.xyy, s),\n        sdSphere(p - e.yxy, s),\n        sdSphere(p - e.yyx, s)\n    );\n    return normalize(n);\n}\n\nvec3 nTorus(vec3 p, vec2 t) {\n    float d = sdTorus(p, t);\n\tvec3 n = d - vec3(\n    \tsdTorus(p - e.xyy, t),\n        sdTorus(p - e.yxy, t),\n        sdTorus(p - e.yyx, t)\n    );\n    return normalize(n);\n}\n\n\n\n\n\n\nvec3 mapLight(Obj obj, vec3 hit, vec3 l0)\n{\n    vec3 col;\n    vec3 n = vec3(0.0);\n    \n    if (obj.type == PLANE) {\n        n = vec3(0.0, 1.0, 0.0);\n        col=vec3(1,0,0);\n    } else if (obj.type == SPHERE) {\n    \tn = nSphere(hit - sphere_pos, 1.0);\n        col=vec3(1,1,0);\n        \n    } else if (obj.type == BOX) {\n    \tn = nBox(hit - box_pos, vec3(1.0));\n        col=vec3(1,0,1);\n            \n        \n    } else if (obj.type == TORUS) {\n    \tn = nTorus(hit - torus_pos, vec2(1.5, 0.5));\n        col=vec3(0,1,1);\n        \n    } else if (obj.type == LIGHT) {\n    \treturn vec3(1.0);\n    }\n\n    return (traceLight(n, hit, l0)*col+traceLightLuz(n, hit, l0,getLightPosv2())*col)/1.5;\n    //return traceLightLuz(n, hit, l0,vec3(0.0, 1.0, 1.0))*col;\n}\n\n\n\n\n\nObj map(vec3 p)\n{\n\n   \n    float d = 1e6;\n    float t = 0.0;\n    int type = NONE;\n    \n    t = sdSphere(sphere_pos - p, 1.0);\n    if (t < d) { type = SPHERE; d = t; }\n    \n    t = sdSphere(getLightPos() - p, 0.25);\n    if (t < d) { type = LIGHT; d = t; }\n    \n    //t = sdSphere(getLightPosv2() - p, 0.5);\n    //if (t < d) { type = LIGHT; d = t; }\n    \n    \n    t = sdBox(box_pos - p, vec3(1.0));\n    if (t < d) { type = BOX; d = t; }\n    \n    t = sdTorus(torus_pos - p, vec2(1.5, 0.5));\n    if (t < d) { type = TORUS; d = t; }\n    \n    t = sdPlane(plane_pos - p, normalize(vec4(0.0, -1.0, 0.0, 5.0)));\n\tif (t < d) { type = PLANE; d = t; }\n    \n    return Obj(type, d);\n}\n\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 1.0;\n    float t = mint;\n    Obj obj;\n    \n    for( int i=0; i<16; i++ )\n    {\n        //float h = map( ro + rd*t ).x;\n         obj= map( ro + rd*t );\n        float h=obj.d;\n            \n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n\n\n\nObj trace(vec3 o, vec3 r)\n{\n    Obj obj = Obj(NONE, 1e6);\n    \n    float t = 0.0;\n    for (int i = 0; i < 32; i++) {\n        vec3 p = o + r * t;\n        obj = map(p);\n        t += obj.d;\n        if (obj.d < 1e-3) {\n        \tbreak;\n        }\n    }\n    \n    obj.d = t;\n    \n    return obj;\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // [-1, 1]\n    uv = uv * 2.0 - 1.0;\n    \n    // aspect corrected\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 o = vec3(0.0, 0.0, 0.0);\n    vec3 r = vec3(uv, -1.0);\n    \n    Obj obj = trace(o, r);\n    \n    vec3 hit = o + obj.d * r;\n    \n    vec3 light = mapLight(obj, hit, o);\n    \n    float fog = 1.0 / (1.0 + obj.d * obj.d * 0.01);\n    \n\tvec3 c = vec3(1.0);\n    \n    \n    \n    \n\n    \tvec3 rd;\n    \t\n    \tvec3 col;\n    \tcol=vec3(0.0);\n    \tcol = 0.45 + 0.35*sin( vec3(0.05,0.08,0.10)*(obj.d-1.0) );\n    \t\n    \t//vec3 nor = calcNormal( pos );\n        vec3 nor= mapLight(obj, hit, o);\n    \t\n    \trd=r;\n    \tvec3 ref = reflect( rd, nor );\n    \t\n       \t\n    \tvec3 pos;\n    \tpos=hit;\n    \n    \n    \tfloat occ = obj.d;\n        vec3  lig = normalize( vec3(-0.4, 0.7, -0.6) );\n        float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-hit.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        float spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n\n        dif *= softshadow( pos, lig, 0.02, 2.5 );\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n        vec3 lin = vec3(0.0);\n        lin += 1.30*dif*vec3(1.00,0.80,0.55);\n        lin += 2.00*spe*vec3(1.00,0.90,0.70)*dif;\n        lin += 0.40*amb*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*dom*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n        col = col*lin;\n\n    \n\n    c = (vec3(c * fog * light)+col*fog)/2.0;\n    \n    fragColor = vec4(c, 1.0);\n}","name":"Image","description":"","type":"image"}]}