{"ver":"0.1","info":{"id":"tsd3WS","date":"1569252773","viewed":282,"name":"Case Study : Glow Glitter effect","username":"MonsieurSoleil","description":"Thx Nusan for the tips :\nUsing intersection from two kifs helped making the effect I Desired.\nI needed this matter/glowing.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["glow","kifs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\t\tDO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE\n                   Version 2, December 2004\n\nCopyright (C) 2004 Sam Hocevar <sam@hocevar.net>\n\nEveryone is permitted to copy and distribute verbatim or modified\ncopies of this license document, and changing it is allowed as long\nas the name is changed.\n\n           DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE\n  TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n\n 0. You just DO WHAT THE FUCK YOU WANT TO.\n*/\n\n#define NUM_LOOP 100\n#define MAT_LIMIT 0.01\n#define PI 3.14159265\n\nmat2 rot(float a)\n{\n    return mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\nfloat sdBox(vec3 p, vec3 s)\n{\n    p = abs(p)-s;\n    return max(p.x,max(p.y,p.z));\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}\n\nvec2 kifs(vec2 p, float t, vec2 s, int iter, vec2 prog)   \n{\n    for(int i = 0; i < iter; ++i)\n    {\n     \tp.xy *= rot(t);\n        p.xy = abs(p.xy) - s;\n\t\ts *= prog;\n    }\n    \n    return p;\n}\n\nvec3 rep(vec3 p, vec3 r)\n{\n \treturn (fract(p/r+0.5) - 0.5) * r;\n}\n\nvec2 rep(vec2 p, vec2 r)\n{\n \treturn (fract(p/r+0.5) - 0.5) * r;\n}\n\nfloat rep(float p, float r)\n{\n \treturn (fract(p/r+0.5) - 0.5) * r;\n}\n\nvec2 map(vec3 p)\n{\n  \tvec2 result = vec2(10.0, 1.0);\n    \n    \n    \n    vec3 p2 = p, p3 = p;\n    \n    \n    \n    p2.xz = kifs(p.xz, 4.0, vec2(20.5, 5.5), 5, vec2(0.4, 0.01));\n    p2.xz *= rot(((cos(iTime * 0.005) * 0.5) + 0.4) * 0.5);\n    p2.yx = kifs(p.yx, 5.0, vec2(12.5, 10.5), 15, vec2(0.45, 0.95));\n    p2.yx *= rot(cos(iTime * 0.05) * 0.001);\n \n    p2 = rep(p2, vec3(12.0));\n    \n    p.y -= sin(p.z * 1.0);\n    p.x -= sin(p.z * 0.5);\n    p.z -= sin(p.x * 1.2);\n    \n    p.xz *= rot(cos(iTime * 0.0001) * 15.0);\n    \n    p.yx *= rot(sin(iTime * 0.0001) * 25.0);\n    \n    p3.xz = kifs(p.xz, 2.0, vec2(20.5, 15.5), 25, vec2(0.5, 0.5));\n    p3.zx *= rot(((cos(iTime * 0.001) * 0.5) + 0.4) * 10.5);\n    p3.yx = kifs(p.yx, 5.0, vec2(25.5, 20.5), 20, vec2(0.1, 0.05));\n    p3.yx *= rot(cos(iTime * 0.005) * 0.001);\n    \n    p3.xyz = rep(p3.xyz, vec3(7.5));\n   \n    p3.y += cos(cos(iTime * 0.0) * 0.001) * 0.005;\n    \n    result.x = min(result.x, sdBox(p2, vec3(1.5)));\n    \n    result.x = opSmoothIntersection(result.x, sdSphere(p3, 0.1), 4.0);\n    //result.x = min(result.x, sdSphere(p3, 0.2));\n    \n   return result;\n}\n\nvec3 look(vec2 uv, vec3 pos, vec3 at)\n{\n    vec3 f = normalize(at - pos);\n    vec3 r = normalize(cross(f, vec3(0.0, 1.0, 0.0)));\n    vec3 u = normalize(cross(f, r));\n    \n    return normalize(f + r * uv.x + u * uv.y); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv = uv - 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1.0);\n    \n    vec3 col = vec3(0.0);\n    \n    vec3 pos = vec3( sin(iTime * 0.01)*100.0, 1005.0, cos(iTime * 0.01)*100.0);\n    vec3 at = vec3(0.0,0.0,0.);\n\tvec3 dir = look(uv, pos, at);\n    \n    vec3 p = pos;\n    float dist = 0.0; vec2 mat = vec2(0.0);\n    float glow = 0.0;\n    for(int i = 0; i < NUM_LOOP; ++i)\n    {\n        mat = map(p);\n        \n        if(mat.x < 1.0)\n            glow += 0.05/0.02*(mat.x+mat.x);\n        \n     \tif(mat.x <= MAT_LIMIT)\n        {\n\t\t\tdist = 1.0 - (float(i) / float(NUM_LOOP));\n            break;\n        }\n        \n        p += mat.x * dir * 0.65;\n    }\n    \n    col += vec3(1.0, 0.4, 0.0) * glow * 0.05;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}