{"ver":"0.1","info":{"id":"wllGWS","date":"1557607414","viewed":220,"name":"Asensio - First Cube Shader","username":"Asensio12","description":"This is my first shader code trying to project a cube rectangle in 3D","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","tutorial","cube"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI\t3.14159265359\n\nconst vec3 i = vec3(1.0,0.0,0.0);\nconst vec3 j = vec3(0.0,1.0,0.0);\nconst vec3 k = vec3(0.0,0.0,1.0);\n\nconst float INF = 1000000.0;\n\nbool inRectangle(in vec3 p0, in vec3 d1, in vec3 d2,\n                 in vec3 PoV, in vec3 DoV, in float d, in vec2 xy,\n                 out float dLense2Rect, out float iRect, out float jRect) {\n    // p0: \t\tVertex of the square\n    // d1, d2: \tAdjacent sides of the square\n    // PoV: \tPoint of View of the projection\n    // DoV:\t\tDirection of View\n    // d:\t\tDistance of the lense \n    // xy:\t\tCoordinates in the lense\n    \n    // Note: Lense can be a 2x2 square, or anything else\n    \n    // Plane of the rectangle: ax+by+cz+C=0  --> nRect = (a,b,c)\n    vec3 nRect = cross(d1,d2);\n    float C = - dot(p0, nRect);\n    \n    // Center of the lense\n    DoV = normalize(DoV);\n    vec3 cLense = PoV + d * DoV;\n    \n    // Lense YZ (right/up) coordinates. Limitation: Can't look straight up!\n    vec3 lenseX = cross(DoV, k);\n    vec3 lenseY = cross(lenseX, DoV);\n    \n    // Point of the lense\n    vec3 pLense = cLense + xy.x*lenseX + xy.y*lenseY;\n    \n    // Line from PoV to the point of the screen\n    vec3 pov2lense = normalize(pLense - PoV);\n    \n    // Distance from PoV to the lense\n    // float dPov2lense = length(pov2lense);\n    \n    // Intersection with the plane: line(p0 + t * pov2lense) crossing plane(nRect,C)\n    float t = - (C + dot(pLense, nRect))/dot(pov2lense, nRect);\n    vec3 px = pLense + t*pov2lense;\n    \n    // Distance from the lense to the plane\n     dLense2Rect = t;\n    \n    // Transform to unitary XY coordinates of the plane\n    vec3 d3 = px - p0;\n    \n    float d1d2 = dot(d1,d2);\n    float d1d3 = dot(d1,d3);\n    float d2d3 = dot(d2,d3);\n    float d12 = dot(d1,d1);\n    float d22 = dot(d2,d2);\n    \n    jRect = (d1d2 * d1d3 - d2d3 * d12) / (d1d2 * d1d2 - d12 * d22);\n    iRect = (d1d3 - d1d2 * jRect)/d12;\n    \n    // Return if the point in view is within the rectangle\n    return (iRect >= 0.0 && iRect <=1.0 && jRect >= 0.0 && jRect <=1.0 && t > 0.0);\n}\n\nvoid texture3D(in vec3 p0, in vec3 d1, in vec3 d2,\n                 in vec3 PoV, in vec3 DoV, in float d, in vec2 xy,\n                out vec3 col, inout float currentDistance) {\n    \n    float dLense2Rect = 0.0;\n    float iRect = 0.0;\n    float jRect = 0.0;\n    \n    bool inR = inRectangle(p0, d1, d2, PoV, DoV, d, xy, dLense2Rect, iRect, jRect);\n    \n    if(inR && dLense2Rect < currentDistance) {\n        col = texture(iChannel0,vec2(iRect,jRect)).xyz;\n        currentDistance = dLense2Rect;\n    }\n    \n}\n\nvoid cube3D(in vec3 c0, in float side, in vec3 PoV, in vec3 DoV, in float d, in vec2 xy,\n                out vec3 col, inout float currentDist) {\n    float invside = 1.0/side;\n    \n    vec3 p00 = c0 + vec3(0.5*side, -0.5*side, -0.5*side);\n    vec3 d10  = vec3( 0.0, side, 0.0);\n    vec3 d20  = vec3( 0.0, 0.0, side);\n    \n    vec3 p01  = p00 + d10;\n    vec3 d11  = cross(d20, d10)* invside;\n    vec3 d21  = d20;\n    \n    vec3 p02  = p01 + d11;\n    vec3 d12  = cross(d21, d11)* invside;\n    vec3 d22  = d21;\n    \n    vec3 p03  = p02 + d12;\n    vec3 d13  = cross(d22, d12)* invside;\n    vec3 d23  = d22;\n    \n    vec3 p04  = p00 + d20;\n    vec3 d14  = d10;\n    vec3 d24  = d11;\n    \n    vec3 p05  = p00;\n    vec3 d15  = d10;\n    vec3 d25  = d11;\n    \n    texture3D(p00, d10, d20, PoV, DoV, d, xy, col, currentDist);\n    texture3D(p01, d11, d21, PoV, DoV, d, xy, col, currentDist);\n    texture3D(p02, d12, d22, PoV, DoV, d, xy, col, currentDist);\n    texture3D(p03, d13, d23, PoV, DoV, d, xy, col, currentDist);\n    texture3D(p04, d14, d24, PoV, DoV, d, xy, col, currentDist);\n    texture3D(p05, d15, d25, PoV, DoV, d, xy, col, currentDist);\n}\n\n\nvoid mainProgram(in vec2 fragCoord, out vec4 fragColor)\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 xy = 2.0*(fragCoord/iResolution.xy - 0.5);\n    xy.x *= iResolution.x/iResolution.y;\n    \n    vec3 cubeCenter1  = vec3( 0.0);\n    vec3 cubeCenter2  = vec3( 2.0);\n    vec3 cubeCenter3  = vec3( 2.0, -2.0, 2.0);\n    vec3 cubeCenter4  = vec3(-2.0, -2.0, 2.0);\n    vec3 cubeCenter5  = vec3(-2.0,  2.0, 2.0);\n    vec3 cubeCenter6  = vec3(-2.0);\n    vec3 cubeCenter7  = vec3( 2.0, -2.0,-2.0);\n    vec3 cubeCenter8  = vec3( 2.0,  2.0,-2.0);\n    vec3 cubeCenter9  = vec3(-2.0,  2.0,-2.0);\n    float side = 2.0;\n    \n    vec3 PoV = 8.0*vec3( cos(iTime*0.3), sin(iTime*0.3), 0.7*sin(iTime));\n    vec3 DoV = - PoV;\n    float d  = 1.0;\n    \n    float currentDist = INF;\n    vec3 col = vec3(1.0);\n    \n    cube3D(cubeCenter1, side, PoV, DoV, d, xy, col, currentDist);\n    cube3D(cubeCenter2, side, PoV, DoV, d, xy, col, currentDist);\n    cube3D(cubeCenter3, side, PoV, DoV, d, xy, col, currentDist);\n    cube3D(cubeCenter4, side, PoV, DoV, d, xy, col, currentDist);\n    cube3D(cubeCenter5, side, PoV, DoV, d, xy, col, currentDist);\n    cube3D(cubeCenter6, side, PoV, DoV, d, xy, col, currentDist);\n    cube3D(cubeCenter7, side, PoV, DoV, d, xy, col, currentDist);\n    cube3D(cubeCenter8, side, PoV, DoV, d, xy, col, currentDist);\n    cube3D(cubeCenter9, side, PoV, DoV, d, xy, col, currentDist);\n    \n    fragColor = vec4(0.2+0.8*col,1.0);\n}\n\n// Antialiasing\n#define AA\t1 \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mainProgram(fragCoord, fragColor);\n    \n    if (AA > 1)\n    {\n        vec4 tempFragColor = vec4(0.0);\n        fragColor = vec4(0.0);\n        for(int i = 0; i < AA; i++)\n        {\n            float phase = 2.0*PI*float(i)/float(AA);\n            vec2 xy = fragCoord + 2.0*vec2(cos(phase), sin(phase));\n            mainProgram(fragCoord, tempFragColor);\n            fragColor += tempFragColor/float(AA);\n        }\n        //fragColor *= 0.5;\n    }\n}","name":"Image","description":"","type":"image"}]}