{"ver":"0.1","info":{"id":"tljBRz","date":"1598345840","viewed":265,"name":"Landscape Evolution","username":"j91000","description":"click and drag to rotate the camera. Arrow keys move the camera around. press 'r' to reset the simulation. 'w' key toggles water heightmap mode.\n's' toggles sediment highlight mode\nRaymarching terrain shader from: https://www.shadertoy.com/view/ltjSRD\n","likes":6,"published":1,"flags":48,"usePreview":0,"tags":["raymarching","fluid","erosion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Raymarch settings\n\n#define MIN_DIST 0.0001\n#define MAX_DIST 12.0\n#define MAX_STEPS 209\n#define STEP_MULT 0.2\n#define NORMAL_OFFS 0.002\n\n//Scene settings\n\n#define QUADS_PER_UNIT 320.0\n#define HAZE_COLOR vec3(0.15, 0.1, 0.1)\n#define HAZEAMT 0.F\n#define GRID_LINE_RADIUS 0.000000001\n//#define SHOW_RAY_COST\n\n//Derived settings\n#define QUAD_SIZE (1.0/QUADS_PER_UNIT)\n\nfloat pi = atan(1.0) * 4.0;\nfloat tau = atan(1.0) * 8.0;\n\nstruct MarchResult\n{\n    vec3 position;\n    vec3 normal;\n    float dist;\n    float steps;\n};\n    vec2 bufLookup(vec2 p){\n        return ((p+iResolution.xy/vec2(iResolution.x,iResolution.y))*.2);\n    }\n    float getH(vec2 p){\n        \n        return texture(iChannel0,(bufLookup(p))).x;\n    }\nvec3 getRGB(vec2 p){\n    return texture(iChannel0,bufLookup(p)).yzw;\n}\n    \n//Returns the height at a given position.\nfloat Height(vec2 p)\n{\n    p *= QUAD_SIZE;\n    //p+=450./80.*vec2(800.,450.)/iResolution.xy;\n    float h = getH(p);//textureLod(iChannel0, p * 0.1 + iTime * 0.01, 0.0).x * 0.5;\n    \n    //h += sin(length(p) * 2.0 + iTime) * 0.25;\n    \n\treturn h;\n}\n\n//Returns a rotation matrix for the given angles around the X,Y,Z axes.\nmat3 Rotate(vec3 angles)\n{\n    vec3 c = cos(angles);\n    vec3 s = sin(angles);\n    \n    mat3 rotX = mat3( 1.0, 0.0, 0.0, 0.0,c.x,s.x, 0.0,-s.x, c.x);\n    mat3 rotY = mat3( c.y, 0.0,-s.y, 0.0,1.0,0.0, s.y, 0.0, c.y);\n    mat3 rotZ = mat3( c.z, s.z, 0.0,-s.z,c.z,0.0, 0.0, 0.0, 1.0);\n\n    return rotX * rotY * rotZ;\n}\n\n//==== Distance field operators/functions by iq. ====\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1, d2);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p) - s;\n}\n\n//Modified to create a plane from 3 points.\nfloat sdPlane( vec3 p, vec3 p0, vec3 p1, vec3 p2 )\n{\n  return dot(p - p0, normalize(cross(p0 - p1, p0 - p2)));\n}\n//===================================================\n\n/*\nDistance to a vertical quad comprised of two triangles.\n\n1-----2\n| 0  /|\n|  /  |\n|/  1 |\n0-----3\n*/\nfloat sdVQuad( vec3 p, float h0, float h1, float h2, float h3)\n{\n    float s = QUAD_SIZE;\n       \n    float diag = sdPlane(p, vec3(0, 0, 0),vec3(s, s, 0),vec3(0, 0, s));\n    \n    float tri0 = sdPlane(p, vec3(0, 0,-h0),vec3(0, s,-h1),vec3(s, s,-h2)); //Triangle 0 (0,1,2)\n    tri0 = opS(-diag, tri0);\n    \n    float tri1 = sdPlane(p, vec3(0, 0,-h0),vec3(s, s,-h2),vec3(s, 0,-h3)); //Triangle 1 (0,2,3)\n    tri1 = opS(diag, tri1);\n    \n    float d = min(tri0,tri1);\n    \n    return d;\n}\n\n//Distance to the scene\nfloat Scene(vec3 p)\n{\n    float d = MAX_DIST;\n    \n    vec3 pm = vec3(mod(p.xy, vec2(QUAD_SIZE)), p.z);\n    \n    vec2 uv = floor(p.xy / QUAD_SIZE);\n    \n    float v0 = Height(uv + vec2(0, 0));\n    float v1 = Height(uv + vec2(0, 1));\n    float v2 = Height(uv + vec2(1, 1));\n    float v3 = Height(uv + vec2(1, 0));\n    \n    d = sdVQuad(pm - vec3(0.0 ,0.0, 0.0), v0, v1, v2, v3);\n    \n    d = opU(d, -sdSphere(p, MAX_DIST - 1.0));\n    \n\treturn d;\n}\n\n//Surface normal at the current position\nvec3 Normal(vec3 p)\n{\n    vec3 off = vec3(NORMAL_OFFS, 0, 0);\n    return normalize\n    ( \n        vec3\n        (\n            Scene(p + off.xyz) - Scene(p - off.xyz),\n            Scene(p + off.zxy) - Scene(p - off.zxy),\n            Scene(p + off.yzx) - Scene(p - off.yzx)\n        )\n    );\n}\n\n//Raymarch the scene with the given ray\nMarchResult MarchRay(vec3 orig,vec3 dir)\n{\n    float steps = 0.0;\n    float dist = 0.0;\n    \n    for(int i = 0;i < MAX_STEPS;i++)\n    {\n        float sceneDist = Scene(orig + dir * dist);\n        \n        dist += sceneDist * STEP_MULT;\n        \n        steps++;\n        \n        if(abs(sceneDist) < MIN_DIST)\n        {\n            break;\n        }\n    }\n    \n    MarchResult result;\n    \n    result.position = orig + dir * dist;\n    result.normal = Normal(result.position);\n    result.dist = dist;\n    result.steps = steps;\n    return result;\n}\n\n//Scene texturing/shading\nvec3 Shade(MarchResult hit, vec3 direction, vec3 camera)\n{\n    vec3 color = vec3(.5);\n    \n    //Triangle grid pattern\n    vec2 gridRep = mod(hit.position.xy, vec2(QUAD_SIZE)) / float(QUAD_SIZE) - 0.5;\n    \n    float grid = 0.5 - max(abs(gridRep.x), abs(gridRep.y));\n    grid = min(grid, abs(dot(gridRep.xy, normalize(vec2(-1, 1)))));\n    \n    float lineSize = GRID_LINE_RADIUS * hit.dist / iResolution.y / float(QUAD_SIZE);\n    \n   // color *= 1.0-smoothstep(lineSize, lineSize * 0.25, grid);\n    color = color * 0.75 + 0.25;\n    color+=getRGB(hit.position.xy);\n    //Lighting\n    float ambient = 0.0;\n    float diffuse = 0.5 * -dot(hit.normal, direction);\n    float specular = 1.1 * max(0.0, -dot(direction, reflect(direction, hit.normal)));\n    specular*=.7;\n    diffuse*=1.3;\n    color *= vec3(ambient + diffuse + pow(specular, 5.0));\n\t\n    //Fog / haze\n    float sky = smoothstep(MAX_DIST - 1.0, 0.0, length(hit.position));\n    float haze = 1. - (hit.steps / float(MAX_STEPS));\n    \n    vec3 skycol = mix(HAZE_COLOR, vec3(0), clamp(-hit.position.z * 0.2, 0.0, 1.0));\n    \n    //color = mix(skycol, color, .4-HAZEAMT+sky * haze);\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy / iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    \n    //Camera stuff   \n    vec3 angles = vec3(0);\n    \n    if(iMouse.xy == vec2(0,0))\n    {\n        angles.y = tau * (1.5 / 8.0);\n        angles.x = iTime * 0.1;\n    }\n    else\n    {    \n    \tangles = vec3((iMouse.xy / iResolution.xy) * pi, 0);\n        angles.xy *= vec2(2.0, 1.0);\n    }\n    \n    angles.y = clamp(angles.y, 0.0, tau / 4.0);\n    \n    mat3 rotate = Rotate(angles.yzx);\n    \n    vec3 orig = (vec3(0, 0,-2.)) * rotate;//vec3(texture(iChannel1,uv).xzy)+\n    orig -= vec3(0., 0, .2)+vec3(texture(iChannel1,uv).xy,0.);\n    \n    vec3 dir = normalize(vec3(uv - res / 2.0, 0.5)) * rotate;\n    \n    //Ray marching\n    MarchResult hit = MarchRay(orig, dir);\n    \n    //Shading\n    vec3 color = Shade(hit, dir, orig);\n    \n    #ifdef SHOW_RAY_COST\n    color = mix(vec3(0,1,0), vec3(1,0,0), hit.steps / float(MAX_STEPS));\n    #endif\n    \n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/////////////////This buffer holds the model state and performs the landscape evolution\n\n///////////////////////////////////// LANDSCAPE EVOLUTION CONSTANTS\n\nconst float RAINFALL=0.0000001;//0.000001;\nconst float EROSIONPOWER=.05;//.05\nconst float settlingVel=0.00000000001;//.00005\nconst float UPLIFT=0.;//.0001;\nconst float LUPLIFT=0.0001;\n//////////////////////////////////////\nconst int RCODE=82;\nbool resetTime(){\n return (texelFetch( iChannel1, ivec2(RCODE,0),0).x>0.)||iFrame<100;\n}\nvec4 getState(in vec2 p){\n    return texture(iChannel0,p/iResolution.xy);\n}\nfloat getLevel(in vec2 p){\n    vec4 state=getState(p);\n    float level=state.x+state.y+state.z;\n    return level;\n}\n\nfloat getW(in vec2 p){\n    vec4 state=getState(p);\n    float water=state.y;\n    return water;\n}\nfloat getH(in vec2 p){\n    vec4 state=getState(p);\n    float height=state.x;\n    return height;\n}\nfloat getS(in vec2 p){\n    vec4 state=getState(p);\n    float sediment=state.z;\n    return sediment;\n}\nvec2[8] getNeighbs(vec2 p){\n    vec2 nw=vec2(-1.,-1.)+p;\n    vec2 n=vec2(0.,-1.)+p;\n    vec2 ne=vec2(1.,-1.)+p;\n    vec2 w=vec2(-1.,0.)+p;\n    vec2 e=vec2(1.,0.)+p;\n    vec2 sw=vec2(-1.,1.)+p;\n    vec2 s=vec2(0.,1.)+p;\n    vec2 se=vec2(1.,1.)+p;\n    return vec2[8](nw,n,ne,w,e,sw,s,se);\n}\nvec2 getLowestNeighb(in vec2 p){\n    vec2[8] neighbs=getNeighbs(p);\n    vec2 lowest=p;\n    for(int i=0;i<8;i++){\n        vec2 neighb=neighbs[i];\n        if(getLevel(neighb)<getLevel(lowest)){\n            lowest=neighb;\n        }   \n    }\n    return lowest;\n}\nvec2 Water_SedDrainage(vec2 p){\n    vec2 lowest=getLowestNeighb(p);\n    float dif=getLevel(p)-getLevel(lowest);\n    if(p.x<3.||p.y<3.||p.x>iResolution.x-3.||p.y>iResolution.y-3.){dif=0.0000003;}\n    //if(p.x>iResolution.x-3.){dif=0.0001;}\n    float water=getW(p);\n    float sed=getS(p);\n    float massTransport=max(0.,min(water+sed,dif/2.));\n    float waterDrain=0.;\n    float sedDrain=0.;\n    if(massTransport>0.){\n        waterDrain=(water/(water+sed))*massTransport;\n        sedDrain=(sed/(water+sed))*massTransport;\n    }\n    return vec2(waterDrain,sedDrain);\n}\nvec2 Water_SedInFlow(vec2 p){\n    float waterIn=0.;\n    float sedIn=0.;\n    vec2[8] neighbs=getNeighbs(p);//(nw,n,ne,w,e,sw,s,se) NW=== (-1 , -1)\n    for(int i=0;i<8;i++){\n        vec2 neighb=neighbs[i];\n        vec2 target=getLowestNeighb(neighb);\n        if(target==p){//if it points to p\n           vec2 wsDrain=Water_SedDrainage(neighb);\n            waterIn+=wsDrain.x;\n            sedIn+=wsDrain.y;\n            \n\n        }\n    }\n    return vec2(waterIn+RAINFALL,sedIn);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{//x coord is topo height. y coord is water height.\n     \n    vec2 pos=fragCoord;\n    vec2 lowest=getLowestNeighb(pos);\n    float dif=getLevel(pos)-getLevel(lowest);\n    if(pos.x<3.||pos.y<3.||pos.x>iResolution.x-3.||pos.y>iResolution.y-3.){dif=.0000003;}\n    //if(pos.x>iResolution.x-3.){dif=0.0001;}\n    vec2 inF=Water_SedInFlow(pos);\n    float inflow=inF.x;\n    float sedInflow=inF.y;\n    vec2 wsDrainage=Water_SedDrainage(pos);\n    \n        \n    vec4 finalC=getState(pos);//out state same as in state\n    float streamPower=inflow;\n    \n    float erosion=EROSIONPOWER*pow(streamPower,1./3.)*pow(dif,.666);//stream power law stuff\n    float deposition=0.;\n    float se=inF.y;\n    float wa=inF.x;\n    if((se+wa)>0.){\n        deposition=clamp(settlingVel/(streamPower/(getW(pos)))*getS(pos)/((streamPower)),0.,getS(pos)-wsDrainage.y+sedInflow);\n    }\n    else{deposition=getS(pos);}\n    //deposition=se;\n    ///////////////MASS BALANCE EQUATIONS.\n    finalC.x+=UPLIFT+deposition-erosion;//basement height changes by erosion, -deposition, and the constant uplift\n    finalC.y+=inflow-wsDrainage.x;//water level changes by +in -out.\n    finalC.z+=erosion-deposition+sedInflow-wsDrainage.y;//suspended sediment from inflow,outflow, deposition and erosion.\n    /////////////////////////\n    if(resetTime()){\n        finalC=5.*texture(iChannel3,pos/iResolution.xy).xxxx;\n        finalC*=vec4(1.,0.,0.,0.);\n        finalC+=vec4(.3,.0,0.,.0);\n    }\n    if(pos.x<3.||pos.y<3.||pos.x>iResolution.x-3.||pos.y>iResolution.y-3.){finalC.y=0.;finalC.z=0.;}\n    //if(pos.x>iResolution.x-3.){finalC.y=0.;finalC.z=0.;}\n    if(pos.x<iResolution.x/2.){finalC.x+=LUPLIFT;}\n    fragColor=finalC*vec4(1.,1.,1.,1.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//this buffer is just a translation between \n//\t\t-the raw LEM state in this form:\t[vec4(basementHeight,waterHeight,suspendedSedimentHeight,1.)]\n//\tand -the textured heightmap in this form:\t[vec4(tallness,\t[0.,sedimentFullness,wetness])]\n//[0.,sediment,wetness] is the rgb tint applied to this location.\n\n\nvec4 getState(in vec2 p){\n    return texture(iChannel0,p);\n}\nfloat getLevel(in vec2 p){\n    vec4 state=getState(p);\n    float level=state.x+state.y+state.z;\n    return level;\n}\nfloat getW(in vec2 p){\n    vec4 state=getState(p);\n    float water=state.y;\n    return water;\n}\nfloat getH(in vec2 p){\n    vec4 state=getState(p);\n    float height=state.x;\n    return height;\n}\nfloat getS(in vec2 p){\n    vec4 state=getState(p);\n    float sediment=state.z;\n    return sediment;\n}\nconst int WCODE=87;\nconst int SCODE=83;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bool WATERMODE=false;\n    bool SEDMODE=false;\n    if(0.<texelFetch( iChannel1, ivec2(WCODE,2), 0 ).x){WATERMODE=true;}\n    if(0.<texelFetch( iChannel1, ivec2(SCODE,2), 0 ).x){SEDMODE=true;}\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float tallness=pow(getLevel(uv),1.)*.09+.7;\n\n    float wetness=pow(getW(uv),1.)*10000.;\n    float fullness=pow(getS(uv),1.)*5.;\n    if(WATERMODE){tallness=1.1+log(.001+getW(uv))*.06;}\n    if(SEDMODE){tallness=.8+pow(getS(uv),.5)/4.;}\n    if(fragCoord.x<4.||fragCoord.y<4.||fragCoord.y>iResolution.y-4.||fragCoord.x>iResolution.x-4.){tallness=.75;}\n \n    fragColor =vec4(tallness,0.-wetness/2000.,fullness-wetness/2000.,wetness);//.02*getState(uv).xxxx;\n    //fragColor=vec4(tallness+fullness,tallness+fullness,tallness+wetness,1.);\n    //fragColor=vec4(getLevel(uv))/.5-10.*iMouse.x/iResolution.x;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"const int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nvec2 keys(vec2 uv){\n    vec2 result=vec2(0.);\n if(0.<texelFetch( iChannel2, ivec2(KEY_LEFT,0), 0 ).x){\n result+=vec2(-1.,0.);\n }\n if(0.<texelFetch( iChannel2, ivec2(KEY_RIGHT,0), 0 ).x){\n result+=vec2(1.,0.);\n }\n if(0.<texelFetch( iChannel2, ivec2(KEY_UP,0), 0 ).x){\n     result+=vec2(0.,1.);\n }\n if(0.<texelFetch( iChannel2, ivec2(KEY_DOWN,0), 0 ).x){\n     result+=vec2(0.,-1.);\n }\n    return result/40.;\n}\n    \n    \n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{vec2 uv=fragCoord/iResolution.xy;\n    vec2 data=texture(iChannel0,uv).xy;\n    fragColor = vec4(data.xy+keys(uv),0.,.0);\n if(iFrame<100){fragColor=vec4(0.);}\n}","name":"Buf D","description":"","type":"buffer"}]}