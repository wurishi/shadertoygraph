{"ver":"0.1","info":{"id":"td33z7","date":"1568065640","viewed":1375,"name":"[twitch] Fluid Tank","username":"NuSan","description":"Shader coded live on twitch (https://www.twitch.tv/nusan_fx)\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/FluidTank.glsl","likes":37,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","fluid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/*\nShader coded live on twitch (https://www.twitch.tv/nusan_fx)\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/FluidTank.glsl\n*/\n\nfloat time = 0.;\n\nfloat cyl(vec2 p, float s) {\n  return length(p)-s;\n}\n\nfloat sph(vec3 p, float s) {\n  return length(p)-s;\n}\n\nfloat box(vec3 p, vec3 s) {\n  p=abs(p)-s;\n  return max(p.x, max(p.y,p.z));\n}\n\nvec3 repeat(vec3 p, vec3 s) {\n  return (fract(p/s-0.5)-0.5)*s;\n}\n\nvec2 repeat(vec2 p, vec2 s) {\n  return (fract(p/s-0.5)-0.5)*s;\n}\n\nfloat repeat(float p, float s) {\n  return (fract(p/s-0.5)-0.5)*s;\n}\n\nvec3 tunnel(vec3 p) {\n  vec3 off=vec3(0);\n  float dd = p.z*0.02;\n  dd = floor(dd) + smoothstep(0.,1.,smoothstep(0.,1.,fract(dd)));\n  dd *= 1.7;\n  off.x += sin(dd)*10.;\n  off.y += sin(dd*0.7)*10.;\n  \n  return off;\n}\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);  \n}\n\nfloat blue = 0.;\nfloat tmpo = 0.;\nfloat part1(vec3 p2) {\n    \n  // main tunnel\n  float d = -cyl(p2.xy,10.);\n  \n  // details holes\n  vec3 p3 = repeat(p2, vec3(2));\n  float db = d;\n  d = max(d, -sph(p3, 1.1));\n  d = min(d, db+2.);\n  \n  // electric arcs\n  vec3 p4 = p2;\n  p4.xy *= rot(p4.z*0.05);\n  p4.x = abs(p4.x) - 3.;\n  p4.z = repeat(p4.z, 10.);\n  p4.x += sin(p4.y*0.3 + p2.z*0.08)*2.;\n  float go = min(sin(p2.z*0.2 + time*3.)*0.6,0.);\n  float cy = cyl(p4.xz, 0.3+go);\n  tmpo = abs(cy);\n  d = min(d, cy);\n  \n  // polar coordinates\n  vec3 p5 = p2;\n  p5.x = atan(p2.y,p2.x) * 20. / 3.141592;\n  p5.x -= p2.z*0.5;\n  p5.y = length(p2.xy) - 10.;\n  \n  p5.xz = repeat(p5.xz, vec2(5,5));\n  // box on the side of tunnel\n  d = min(d, box(p5, vec3(1)));\n  \n  return d;\n}\n\nfloat smin(float a, float b, float h) {\n  float k=clamp((a-b)/h*.5+.5,0.,1.);\n  return mix(a,b,k) - k * (1.-k) * h;\n}\n\nfloat part2(vec3 p) {\n  \n  float d = -cyl(p.xy,25.);\n  float d1 = d;\n  \n  p.xy *= rot(sin(p.z*0.05 - time) * sin(p.z*0.07 - time)*3.);\n\n  \n  for(int i=0; i<4; ++i) {\n    \n    vec3 p3 = p;\n    \n    p3.xy *= rot(0.7*(float(i)+1.)+time*0.007);\n    p3.zy *= rot(0.9*(float(i)+1.)-time*0.009);\n    \n    p3 = repeat(p3, vec3(12 + i));\n    \n    float f = sph(p3, 1. + float(i)*1.);\n    //f = smin(f, cyl(p3.xy, 0.5), 3);\n    d = smin(d, f, 5.);\n    \n  }\n  \n  d = smin(d, d1-4., -3.);\n  \n  \n  return d;\n  \n}\n\nvec3 lpos = vec3(0,-4,0);\n\nfloat light = 0.;\n\nfloat water = 1.;\nfloat map(vec3 p) {\n  \n  p += tunnel(p);\n  \n  float d1 = part1(p);\n  float d2 = part2(p);\n  \n  vec3 p2 = p;\n  p2.z = repeat(p2.z, 120.);\n  float mi = box(p2, vec3(100,100,34));\n  \n  // mix part 1 and part 2\n  d1 = max(d1, -mi);\n  d1 = min(d1, max(d2, mi));\n  \n  // enter hatch\n  float cc = abs(cyl(p.xy,11.))-2.;\n  cc = max(cc, abs(mi)-1.);\n  d1 = min(d1, cc);\n  \n  //d1 = d2; // tmp\n  \n  // light position\n  p.z = repeat(p.z, 67.);\n  vec3 relp = lpos-p;\n  float dl = length(relp)-0.5;\n  light += 1.0/(0.2+dl*dl);\n  d1 = min(d1, dl);\n  d1 = min(d1, max(-relp.y,length(relp.xz)-0.3));\n  \n  \n  tmpo = max(tmpo, -mi);\n  blue += 0.7/(0.2+abs(tmpo));\n  \n  water = (d1 == d2) ? 0. : 1.;\n  \n  d1 *= 0.7;\n  \n  return d1;\n  \n}\n\nfloat rnd(float t) {\n  return fract(sin(t*754.652)*652.642);\n}\n\nfloat curve(float t, float d) {\n  float g=t/d;\n  return mix(rnd(floor(g)), rnd(floor(g)+1.), pow(smoothstep(0.,1.,fract(g)), 10.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  time =  mod(iTime, 200.);\n    \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec3 s=vec3(0,0,8);\n  vec3 t=vec3((curve(time, 1.8)-0.5)*5.,0,0);\n  \n  float advance = time * 12. + curve(time, 2.)*4.;\n  s.z -= advance;\n  t.z -= advance;\n  s -= tunnel(s);\n  t -= tunnel(t);\n  \n  //lpos = vec3(0,0,-30);\n  //lpos.z -= advance;\n  \n  //vec3 r=normalize(vec3(-uv, 1));\n  vec3 cz = normalize(t-s);\n  vec3 cx = normalize(cross(cz, vec3(sin(time*0.3)*0.3,1,0)));\n  vec3 cy = normalize(cross(cz, cx));\n  \n  float fov = 0.7 + curve(time, 2.8) * 0.7;\n  vec3 r = normalize(cx * uv.x + cy * uv.y + cz * fov);\n  \n  vec2 off=vec2(0.01,0);\n  //vec2 off=vec2(0,0.01); // This was a mistake made during the stream\n  \n  vec3 p=s;\n  int i=0;\n  float alpha = 1.;\n  float dd=0.;\n  for(i=0; i<100; ++i) {\n    float d=map(p);\n    if(d<0.001) {\n      if(water<0.5) {\n        vec3 n=normalize(d-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));\n        alpha *= pow(1.-abs(dot(n,r)),2.0);\n        r = reflect(r,n);\n        d = 0.2;\n        if(alpha<0.01) break;\n      } else {\n        break;\n      }\n    }\n    p+=r*d;\n    dd+=d;\n  }\n  \n  vec3 n=normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));\n  \n  vec3 lpos2 = lpos;\n  lpos2 -= tunnel(lpos2)*0.5;\n  vec3 pl = p;\n  pl.z = repeat(pl.z, 67.);\n  vec3 l = normalize(lpos2-p);\n  \n  float ao = clamp(map(p+n),0.,1.);\n  \n  vec3 col=vec3(0);\n  //col += pow(1-i/101.0, 6) * 3;\n  float falloff = 10./(1.+length(lpos-pl));\n  vec3 lightcol = vec3(1,0.7,0.3);\n  col += (dot(n,-l)*0.5+0.5) * falloff * lightcol * alpha * ao;\n  col += light*lightcol;\n  col += pow(dd * 0.007,4.) * vec3(0.5,0.7,1);\n  col += blue * 0.05 * vec3(0.4,0.5,1);\n  \n    \n  col *= 1.2-length(uv);\n  col = 1.-exp(-col * 2.);\n  col = pow(col, vec3(1.4));\n  \n  \n  fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}