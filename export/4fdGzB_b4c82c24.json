{"ver":"0.1","info":{"id":"4fdGzB","date":"1711840519","viewed":359,"name":"[Revision Jam] Spherical Object","username":"Kamoshika","description":"Shader Jam @ Revision 2024\nhttps://2024.revision-party.net/\n\n音楽は変更されています。\nThe sound is a substitute.","likes":30,"published":1,"flags":64,"usePreview":0,"tags":["raycasting","sphere","livecoding"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"ldK3RR","filepath":"https://soundcloud.com/h0ffman/wobble-and-hoffman-dope-on-wax-soundtrack","previewfilepath":"https://soundcloud.com/h0ffman/wobble-and-hoffman-dope-on-wax-soundtrack","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// イベント配信のアーカイブ動画\n// Revision 2024 - Event - H0ffman & Teo\n// https://youtu.be/dSMlBgwciAk\n\n// If you don't hear the sound, please click on ⏸→⏮→▶.\n// 音が聞こえない場合、 ⏸→⏮→▶ を順にクリックしてください\n\nconst float PI = acos(-1.);         // 円周率\nconst float PI2 = PI * 2.;\nconst float EPS = 0.0001;           // レイキャスティングなどに使う微小量\nconst float FAR = 1e5;              // レイの長さの最大値\nconst int numSamples = 8;           // モーションブラーとDOF（被写界深度）のサンプリング数\nconst int numSph = 20;              // うねうね（球殻）の枚数\nconst float lightSize = 0.1;        // 光源（球体）の半径\nconst float maxThd = 0.1;           // ノイズの最大閾値（うねうねの太さ）\nconst float minRa = 0.1;            // 最も内側のうねうね（球殻）の半径\nconst float stepNoiseFactor = 0.17; // 0に近いと、カメラが速く動く\nconst float BPM = 140.;\nconst vec3 boxSize = vec3(2, 1, 2); // BOXのサイズ\n\nfloat time;    // モーションブラー用に乱数が足された時間\nfloat Time;    // BPMで補正された時間\nvec3 lightPos; // 光源の中心座標\n\n// 3Dの回転\n// ベクトルvを、axを軸として時計回りに角度aだけ回転\nvec3 rotate3D(vec3 v, float a, vec3 ax) {\n    ax = normalize(ax);\n    return mix(dot(ax, v) * ax, v, cos(a)) - sin(a) * cross(ax, v);\n}\n\n// ref（参考）: \"Integer Hash - II\" by iq\n// https://www.shadertoy.com/view/XlXcW4\n// Code has been modified. コードは改変されています\nvec4 Hash(vec4 p) {\n    const uint k = 1103515245U;\n    uvec4 x = floatBitsToUint(p);\n    // ここでは、x.xyzw が独立していて欲しいので、x.yzwx などにはしない\n    // x = ((x >> 8U) ^ x.yzwx) * k;\n    x = ((x >> 8U) ^ x) * k;\n    //x = ((x >> 8U) ^ x) * k;\n    //x = ((x >> 8U) ^ x) * k;\n    return vec4(x);\n}\nfloat hash(float p) {\n    const uint k = 1103515245U;\n    uint x = floatBitsToUint(p);\n    x = ((x >> 8U) ^ x) * k;\n    x = ((x >> 8U) ^ x) * k;\n    x = ((x >> 8U) ^ x) * k;\n    return float(x) / float(0xFFFFFFFFU);\n}\nfloat hash12(vec2 p) {\n    return hash(dot(p, vec2(146.121, 117.232)));\n}\nvec3 hash33(vec3 p) {\n    const uint k = 1103515245U;\n    uvec3 x = floatBitsToUint(p);\n    x = ((x >> 8U) ^ x.yzx) * k;\n    //x = ((x >> 8U) ^ x.yzx) * k;\n    //x = ((x >> 8U) ^ x.yzx) * k;\n    return vec3(x) / float(0xFFFFFFFFU);\n}\n\n// ref（参考）: \"Abstract Glassy Field\" by Shane\n// https://www.shadertoy.com/view/4ttGDH\n// Code has been modified. コードは改変されています\n// 3Dのバリューノイズ\nfloat noise3D(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = p - i; // fract(p)\n    vec3 b = vec3(7, 157, 113);\n    vec4 h = vec4(0, b.yz, b.y + b.z) + dot(i, b);\n    f = f * f * (3. - 2. * f);\n    h = mix(Hash(h), Hash(h + b.x), f.x);\n    h.xy = mix(h.xz, h.yw, f.y);\n    return mix(h.x, h.y, f.z) / float(0xFFFFFFFFU);\n}\n\n// xの整数部分ずつ増加　小数部分でイージング\nfloat ease(float x, float s) {\n    return floor(x) + smoothstep(0.5 - s, 0.5 + s, fract(x));\n}\n\n// 球面とレイの交差判定関数\nvec4 sphIntersect(vec3 ro, vec3 rd, vec3 ce, float ra) {\n    float t = -1.;\n    vec3 n = vec3(0, 1, 0);\n    \n    vec3 oc = ro - ce;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - ra * ra;\n    float h = b * b - c;\n    if(h < 0.) {\n        return vec4(n, t);\n    }\n    \n    t = -b - sqrt(h);\n    n = (ro + t * rd - ce) / ra;\n    return vec4(n, t);\n}\n\n// うねうね用のノイズ\nfloat objNoise(vec3 p, float ID) {\n    float h = noise3D((p + ID * 2.) * 2.) * 2.;\n    return abs(h - 1.);\n}\n\n// バンプマップ\n// ref（参考）: \"Maze Lattice\" by Shane\n// https://www.shadertoy.com/view/llGGzh\n// Code has been modified. コードは改変されています\nvec3 bumpMap(vec3 p, vec3 n, float ref, float ID, float thd) {\n    vec2 e = vec2(0.001, 0.);\n    //float bumpFactor = 0.02;\n    float bumpFactor = 0.1;\n    vec3 grad = (vec3(objNoise(p - e.xyy, ID),\n                      objNoise(p - e.yxy, ID),\n                      objNoise(p - e.yyx, ID)) - ref) / e.x;\n    \n    // sqrt(1. - ref * ref / (thd * thd)) の微分\n    grad *= -ref / (thd * sqrt(thd * thd - ref * ref));\n    \n    grad -= n * dot(n, grad);\n    return normalize(n + grad * bumpFactor);\n}\n\n// うねうねとレイの交差判定関数\n// うねうねは、numSph枚の同心球殻をノイズでくり抜いたもの\nvec4 concSphIntersect(vec3 ro, vec3 rd, float tMax) {\n    float t = tMax;          // ro（カメラ）からオブジェクト表面に飛ばしたレイの長さ\n    vec3 n = vec3(0, 1, 0);  // 法線ベクトル\n    bool hit = false;        // レイがオブジェクトに衝突したかどうか\n    \n    // 交差判定用の変数\n    float b = dot(ro, rd);   // カメラを通りレイベクトルを法線とする平面と、原点との距離\n                             // （原点がカメラの前方にある時はマイナス）\n    float ro2 = dot(ro, ro); // 原点のカメラの距離の2乗\n    float rc = sqrt(ro2);    // 原点とカメラの距離\n    float ho = b * b - ro2;  // 判別式計算用の変数\n    \n    vec3 pos;    // 球殻の表面上の座標\n    float ID;    // 球殻のID\n    float angle; // 球殻の回転角度\n    vec3 axis;   // 球殻の回転軸\n    float noise; // ノイズの値\n    float thd;   // 球殻の描画に使用するノイズの閾値\n    \n    float T = ease(Time * 0.5 - 0.5, 0.2) + time * 0.5; // 球殻の回転に使用する時間\n    float Tr = T * 5.; // 球殻の半径方向の拡大に使用する時間\n    \n    // カメラよりも内側にある球殻の枚数\n    int numC = min(numSph, max(0, int(-log(rc / minRa) / log(minRa) * float(numSph) - fract(Tr) + 1.)));\n    \n    bool head = b < 0.; // カメラに対して最も手前にある球殻が表側なら真\n    int s = int(head) * 2 - 1; // 球殻の表側なら1、裏側なら-1\n    \n    // k：交差判定をする球殻について、中心から数えて何番目か\n    for(int k = numC + int(!head); k <= numSph; k -= s) {\n        float ra = (float(k) + fract(Tr) - 1.) / float(numSph); // 球殻の半径\n        ra = exp(-ra * log(minRa)) * minRa;\n        \n        float h = ho + ra * ra; // 判別式\n        if(k <= 0 || h < 0.) {\n            // kが0の場合は、球殻の表側の交差判定が終わったので、裏側の交差判定に移行する\n            \n            // 判別式が負の場合、レイと球殻が交点をもたない\n            // 今の球殻と交点をもたないならばそれより内側の球殻と交点をもたないことは確定するので\n            // 交点をもつ可能性のある球殻の裏側までループを飛ばす\n            s = -1;\n            continue;\n        }\n        \n        float ts = -b - float(s) * sqrt(h); // 球殻表面まで飛ばしたレイの長さ\n        if(ts > tMax) { // 球殻がカメラに対して他のオブジェクトより奥にある場合\n            break;\n        }\n        if(ts < 0.) { // 球殻がカメラの後方にある場合\n            continue;\n        }\n        \n        vec3 rp = ro + ts * rd; // レイを球殻表面まで飛ばす\n        pos = rp / ra; // 正規化\n        \n        ID = mod(float(k) - floor(Tr), 500.); // mod()は長時間経過時の精度低下対策\n        angle = T * 0.3 + ID * 2.3;\n        axis = hash33(vec3(1, 2, 3) * ID) - 0.5; // IDによって異なる回転軸\n        pos = rotate3D(pos, angle, axis);\n        noise = objNoise(pos, ID);\n        thd = mix(maxThd, 0., ra);\n        \n        if(noise < thd) { // ノイズが閾値より小さい場合、描画するためにレイの長さを更新\n            hit = true;\n            t = ts;\n            break;\n        }\n    }\n    \n    if(!hit) { // レイがオブジェクトに衝突しなかった場合\n        return vec4(n, t);\n    }\n    \n    n = bumpMap(pos, float(s) * pos, noise, ID, thd); // 法線ベクトルを計算\n    n = rotate3D(n, -angle, axis); // 回転させた座標で法線ベクトルを求めていたので、元に戻す\n    return vec4(n, t);\n}\n\n// BOXの内側とレイの交差判定関数\nvec4 insideBoxIntersect(vec3 ro, vec3 rd) {\n    vec3 srd = sign(rd);\n    vec3 v = (srd * boxSize - ro) / rd; // x方向、y方向、z方向の壁に飛ばしたレイの長さ\n    float t = min(v.x, min(v.y, v.z)); // BOXの内側に飛ばしたレイの長さ\n    \n    // 法線ベクトル (±1, 0, 0) or (0, ±1, 0) or (0, 0, ±1)\n    vec3 n = -srd * step(v, v.yzx) * step(v, v.zxy);\n    \n    return vec4(n, t);\n}\n\n// レイキャスティング　Raycasting\nvec4 castRay(vec3 ro, vec3 rd) {\n    float t = FAR; // カメラ（ro）からオブジェクト表面まで飛ばしたレイの長さ\n    vec3 n = vec3(0, 1, 0); // 法線ベクトル\n    \n    // BOXの内側\n    vec4 tmp = insideBoxIntersect(ro, rd);\n    t = tmp.w;\n    n = tmp.xyz;\n    \n    // 光源（球体）\n    tmp = sphIntersect(ro, rd, lightPos, lightSize);\n    if(tmp.w > 0. && tmp.w < t) { // カメラに対して手前にある場合、更新\n        t = tmp.w;\n        n = tmp.xyz;\n    }\n    \n    // うねうね\n    tmp = concSphIntersect(ro, rd, t);\n    if(tmp.w < t) { // カメラに対して手前にある場合、更新\n        t = tmp.w;\n        n = tmp.xyz;\n    }\n    \n    return vec4(n, t);\n}\n\n// 疑似AO\nfloat fakeAO(vec3 p) {\n    vec3 q = abs(abs(p) - boxSize);\n    float d = max(q.x, max(q.y, q.z));\n    d = q.x + q.y + q.z - d;          // 一番近いBOXの辺からの距離\n    float ao = mix(0.2, 1., d);       // BOXのAO\n    ao = min(ao, dot(p, p));          // うねうねのAO\n    ao = min(ao, length(p.xz) + 0.3); // うねうねによるBOXの天井と床のAO\n    return clamp(ao, 0., 1.);\n}\n\n// 色を描画\nvec3 render(vec3 ro, vec3 rd) {\n    vec3 col = vec3(0);\n    \n    vec4 res = castRay(ro, rd);\n    float t = res.w;\n    vec3 n = res.xyz;\n    \n    vec3 rp = ro + t * rd;\n    vec3 lv = lightPos - rp;\n    float L = length(lv);\n    if(L < lightSize + EPS) { // レイが光源に衝突した場合\n        return vec3(1);\n    }\n    \n    vec3 albedo = vec3(0.9); // アルベド（色）\n    float amp = pow(sin(fract(Time) * PI2) * 0.5 + 0.5, 3.) * 5. + 0.1; // 光の強さの係数\n    float po = amp / (L * L); // 光の強さ\n    vec3 ld = lv / L; // 光源方向の単位ベクトル\n    float diff = max(dot(n, ld), 0.); // 拡散反射\n    float spec = pow(max(dot(reflect(ld, n), rd), 0.), 30.); // 鏡面反射\n    float sh = 1.; // 影\n    if(castRay(rp + n * EPS, ld).w < L - lightSize - EPS * 2.) {\n        // 光源より手前にオブジェクトがある場合、影となる\n        sh = 0.1;\n    }\n    float metal = dot(rp, rp) < 1. ? 0.7: 0.9; // メタルネス\n    float ao = fakeAO(rp); // AO（アンビエントオクルージョン）\n    col += albedo * mix(diff, spec, metal) * po * sh; // 直接光\n    col += albedo * ao * (amp * 0.01); // 環境光\n    \n    col = clamp(col, 0., 1.);\n    return col;\n}\n\n// 範囲[-1, 1.]の間で等間隔にn個の値を取る滑らかな階段状のノイズ\nfloat stepNoise(float x, float n) {\n    float i = floor(x);\n    float f = x - i; // fract(p)\n    float u = smoothstep(0.5 - stepNoiseFactor, 0.5 + stepNoiseFactor, f);\n    float res = mix(floor(hash(i) * n), floor(hash(i + 1.) * n), u);\n    res /= (n - 1.) * 0.5;\n    return res - 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord * 2. - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec3 col = vec3(0);\n    \n    // モーションブラーとDOF（被写界深度）に使用するシードを初期化\n    float seed = hash12(uv + fract(iTime / 10.));\n    seed += hash12(uv + seed + fract(iTime / 11.));\n    \n    for(int i = 0; i < numSamples; i++) { // モーションブラーとDOF（被写界深度）のためのサンプリング\n        seed += float(i);\n        time = iTime;\n        time += hash(seed) * 0.03; // モーションブラー\n        \n        Time = time * BPM / 60.;\n        lightPos = sin(normalize(vec3(3, 5, 9)) * time * 5.) * 0.5;\n        \n        // カメラの座標\n        vec3 ro = vec3(0, 0, 2);\n        ro = rotate3D(ro, time * 0.3, vec3(0, 1, 0));\n        ro.y += stepNoise(Time * 0.5, 3.) * 0.9;\n        \n        // ターゲット座標\n        vec3 ta = vec3(0);\n        ta.x += stepNoise(Time * 0.5 -  500., 3.) * 0.5;\n        ta.y += stepNoise(Time * 0.5 - 1000., 3.) * 0.5;\n        ta.z += stepNoise(Time * 0.5 - 1500., 3.) * 0.5;\n        \n        // レイベクトルを算出\n        vec3 dir = normalize(ta - ro); // カメラの方向\n        vec3 side = normalize(cross(dir, vec3(EPS, 1, 0)));\n        vec3 up = cross(side, dir);\n        float fov = 60.;\n        fov += stepNoise(Time * 0.5 - 2000., 2.) * 30.;\n        vec3 rd = normalize(uv.x * side + uv.y * up + dir / tan(fov / 360. * PI));\n        \n        // DOF（被写界深度）\n        //float L = length(ta - ro);\n        //vec3 fp = ro + L * rd;\n        vec3 fp = ro + rd * (sin(time * 1.) * 1.2 + 2.2); // focus point\n        float r = sqrt(hash(seed * 2.)); // 円内部で一様分布させるためsqrt()\n        float a = hash(seed * 3.) * PI2;\n        vec3 v = vec3(r * vec2(cos(a), sin(a)) * 0.05, 0); // レイの原点に加算する\n        vec3 diro = normalize(vec3(EPS, 0, -1));\n        float va = acos(dot(dir, diro));\n        vec3 vax = cross(dir, diro);\n        v = rotate3D(v, va, vax); // カメラの方向に合わせて、vを回転させる\n        vec3 ros = ro + v; // ずらしたレイの原点\n        vec3 rds = normalize(fp - ros); // ずらしたレイベクトル\n        \n        col += render(ros, rds);\n    }\n    \n    col /= float(numSamples);\n    col = pow(col, vec3(1. / 2.2)); // ガンマ補正\n    fragColor = vec4(col, 1.);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// backup（バックアップ）\n\n/*\n\n//#define iTime (iTime * .2)\n//#define iTime 4.\n//#define iTime 6.\n//#define iTime 15.\n//#define iTime 453.\n\n// 乱数\n#define hash(x) fract(sin(x) * 1e4)\n\nconst float PI = acos(-1.); // 円周率\nconst float PI2 = PI * 2.;\nconst float EPS = 0.0001; // レイキャスティングなどに使う微小量\nconst float FAR = 1e5;\nconst float numSamples = 8.; // モーションブラーとDOF（被写界深度）のサンプリング数\nconst float numSph = 20.; // 球殻の枚数\nconst float lightSize = 0.1; // 光る球体の半径\nconst float maxThd = 0.1; // ノイズの最大閾値（うねうねの太さ）\nconst float minRa = 0.1; // うねうねする球殻の最小半径\n//const float stepNoiseFactor = 0.2; // stepNoise関数の定数（カメラの動きの速さに関わる）\nconst float stepNoiseFactor = 0.17; // stepNoise関数の定数（カメラの動きの速さに関わる）\n//const float BPM = 175.;\n//const float BPM = 160.;\nconst float BPM = 140.;\n//const float BPM = 132.;\nconst vec3 boxSize = vec3(2, 1, 2); // BOXのサイズ\n\nfloat time; // モーションブラー用に乱数が足された時間\nfloat Time; // BPMで補正された時間\nvec3 lightPos; // 光る球体の中心座標\n\n// 2Dの乱数\nfloat hash12(vec2 p) {\n    return hash(dot(p, vec2(14.6121, 11.7232)));\n}\n\n// 3Dの回転　軸ax 角度a\nvec3 rotate3D(vec3 v, float a, vec3 ax) {\n    ax = normalize(ax);\n    return mix(dot(ax, v) * ax, v, cos(a)) - sin(a) * cross(ax, v);\n}\n\n// 3Dのバリューノイズ\nfloat noise3D(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    vec3 b = vec3(31, 47, 37);\n    vec4 h = vec4(0, b.yz, b.y + b.z) + dot(i, b);\n    f = f * f * (3. - 2. * f);\n    h = mix(hash(h), hash(h + b.x), f.x);\n    h.xy = mix(h.xz, h.yw, f.y);\n    return mix(h.x, h.y, f.z);\n}\n\n// xの整数部分ずつ増加　小数部分でイージング\nfloat ease(float x, float s) {\n    return floor(x) + smoothstep(0.5 - s, 0.5 + s, fract(x));\n}\n\n// 球面とレイの交差判定関数\nvec4 sphIntersect(vec3 ro, vec3 rd, vec3 ce, float ra) {\n    float t = -1.;\n    vec3 n = vec3(0, 1, 0);\n    \n    vec3 oc = ro - ce;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - ra * ra;\n    float h = b * b - c;\n    if(h < 0.) {\n        return vec4(n, t);\n    }\n    \n    t = -b - sqrt(h);\n    n = (ro + t * rd - ce) / ra;\n    return vec4(n, t);\n}\n\n// うねうね用のノイズ\nfloat objNoise(vec3 p, float ID) {\n    float h = noise3D((p + ID * 2.) * 2.) * 2.;\n    return abs(h - 1.);\n}\n\n// うねうねの凹凸\nfloat bumpFunc(vec3 p, float ID, float thd) {\n    float g = objNoise(p, ID) / thd;\n    return sqrt(1. - g * g);\n}\n\n// バンプマップ\n// ref（参考）: \"Maze Lattice\" by Shane\n// https://www.shadertoy.com/view/llGGzh\nvec3 bumpMap(vec3 p, vec3 n, float ID, float thd) {\n    vec2 e = vec2(EPS, 0.);\n    float factor = 0.02;\n    float ref = bumpFunc(p, ID, thd);\n    vec3 grad = (vec3(bumpFunc(p - e.xyy, ID, thd),\n                      bumpFunc(p - e.yxy, ID, thd),\n                      bumpFunc(p - e.yyx, ID, thd)) - ref) / e.x;\n    grad -= n * dot(n, grad);\n    return normalize(n + grad * factor);\n}\n\n// うねうねとレイの交差判定関数\nvec4 concSphIntersect(vec3 ro, vec3 rd, float tMax) {\n    float t = tMax; // roからオブジェクト表面に飛ばしたレイの長さ\n    vec3 n = vec3(0, 1, 0); // 法線ベクトル\n    \n    // 交差判定用の変数\n    float b = dot(ro, rd);\n    float ro2 = dot(ro, ro);\n    float rc = sqrt(ro2);\n    float ho = b * b - ro2;\n    \n    vec3 npos;\n    float s;\n    float ID;\n    float thd;\n    float a;\n    vec3 ax;\n    \n    for(float i = 0.; i < numSph * 2.; i++) {\n        float k = numSph - i; // 中心から数えて何番目の球殻か\n        s = 1.; // 球殻の表側なら1、裏側なら-1\n        if(i >= numSph) { // 裏側の場合\n            k = i - numSph + 1.;\n            s = -1.;\n        }\n        \n        float T = ease(Time * .5 - 0.5, .2) + time * .5;\n        float Tr = T * 5.;\n        float ra = (k + fract(Tr) - 1.) / numSph; // 球殻の半径\n        ra = exp(-ra * log(minRa)) * minRa;\n        \n        float h = ho + ra * ra; // 判別式\n        if(h < 0.) { // 判別式が負の場合、レイと交点をもたない\n            //if(i < numSph) {\n                // 今の球殻と交点をもたないならばそれより内側の球殻と交点をもたないことは確定するので\n                // 交点をもつ可能性のある球殻の裏側までループを飛ばす\n                i = numSph * 2. - i - 1.;\n            //}\n            continue;\n        }\n        \n        float ts = -b - s * sqrt(h);\n        if(ts > tMax) {\n            break;\n        }\n        if(ts < 0.) { // 球殻がカメラの後方にある場合\n            continue;\n        }\n        \n        vec3 rp = ro + ts * rd;\n        float lrp = length(rp);\n        vec3 nrp = rp / lrp;\n        \n        ID = mod(k - floor(Tr), 500.); // 球殻のID\n        a = T * 0.3 + ID * 2.3;\n        ax = hash(vec3(1, 2, 3) * ID) - .5;\n        npos = rotate3D(nrp, a, ax);\n        float g = objNoise(npos, ID);\n        thd = mix(maxThd, 0., lrp);\n        \n        if(g < thd) { // ノイズが閾値より小さい場合、描画する\n            t = ts;\n            break;\n        }\n    }\n    \n    if(t < tMax) {\n        n = bumpMap(npos, s * npos, ID, thd);\n        n = rotate3D(n, -a, ax);\n    }\n    return vec4(n, t);\n}\n\n// BOXとレイの交差判定関数\nvec4 boxIntersect(vec3 ro, vec3 rd) {\n    vec3 srd = sign(rd);\n    vec3 v = (srd * boxSize - ro) / rd;\n    float t = min(v.x, min(v.y, v.z));\n    vec3 n = -srd * step(v, v.yzx) * step(v, v.zxy);\n    return vec4(n, t);\n}\n\n// レイキャスティング　Raycasting\nvec4 castRay(vec3 ro, vec3 rd) {\n    float t = FAR; // roからオブジェクト表面まで飛ばしたレイの長さ\n    vec3 n = vec3(0, 1, 0); // 法線ベクトル\n    \n    // BOX\n    vec4 tmp = boxIntersect(ro, rd);\n    t = tmp.w;\n    n = tmp.xyz;\n    \n    // 光る球体\n    tmp = sphIntersect(ro, rd, lightPos, lightSize);\n    if(tmp.w > 0. && tmp.w < t) { // レイが交差し、かつ、手前にある場合、更新\n        t = tmp.w;\n        n = tmp.xyz;\n    }\n    \n    // うねうね\n    tmp = concSphIntersect(ro, rd, t);\n    if(tmp.w < t) {\n        t = tmp.w;\n        n = tmp.xyz;\n    }\n    \n    return vec4(n, t);\n}\n\n// 疑似AO\nfloat fakeAO(vec3 p) {\n    vec3 q = abs(abs(p) - boxSize);\n    float d = max(q.x, max(q.y, q.z));\n    d = q.x + q.y + q.z - d; // 一番近いBOXの辺からの距離\n    float ao = mix(.1, .7, d); // BOXのAO\n    ao = min(ao, dot(p, p)); // うねうねのAO\n    ao = min(ao, length(p.xz) * 1. + .3); // うねうねによるBOXの天井と床のAO\n    return clamp(ao, 0., 1.);\n}\n\n// 色を描画\nvec3 render(vec3 ro, vec3 rd) {\n    vec3 col = vec3(0);\n    \n    vec4 res = castRay(ro, rd);\n    float t = res.w;\n    vec3 n = res.xyz;\n    \n    vec3 rp = ro + t * rd;\n    vec3 lv = lightPos - rp;\n    float L = length(lv);\n    if(L < lightSize + EPS) { // 光る球体\n        col = vec3(1);\n    }\n    \n    vec3 albedo = vec3(0.9);\n    //float amp = pow(sin(fract(Time) * PI2) * .5 + .5, 3.) * 3. + 0.05;\n    float amp = pow(sin(fract(Time) * PI2) * .5 + .5, 3.) * 5. + 0.1;\n    float po = amp / (L * L);\n    vec3 ld = lv / L;\n    float diff = max(dot(n, ld), 0.); // 拡散反射\n    float spec = pow(max(dot(reflect(ld, n), rd), 0.), 30.); // 鏡面反射\n    float sh = 1.;\n    if(castRay(rp + n * EPS, ld).w < L - lightSize - EPS * 2.) { // 影\n        sh = 0.1;\n    }\n    float metal = dot(rp, rp) < 1. ? 0.7: 0.9;\n    float ao = fakeAO(rp);\n    col += albedo * mix(diff, spec, metal) * po * sh; // 直接光\n    col += albedo * ao * (amp * 0.01); // 環境光\n    \n    col = clamp(col, 0., 1.);\n    \n    return col;\n}\n\n// 範囲[-1, 1.]の間で等間隔にn個の値を取る滑らかな階段状のノイズ\nfloat stepNoise(float x, float n) {\n    float i = floor(x);\n    //float s = 0.2;\n    //float s = 0.15;\n    float u = smoothstep(.5 - stepNoiseFactor, .5 + stepNoiseFactor, fract(x));\n    float res = mix(floor(hash(i) * n), floor(hash(i + 1.) * n), u);\n    res /= (n - 1.) * 0.5;\n    return res - 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1) * .5;\n    vec3 col = vec3(0);\n    \n    //col = uv.xyy;\n    //col += step(noise3D(vec3(uv * 3., fGlobalTime)), .5) * .5 + .5;\n    \n    for(float i = 0.; i < numSamples; i++) { // モーションブラーとDOF（被写界深度）のためのサンプリング\n        time = iTime;\n        vec2 seed = gl_FragCoord.xy + mod(time, 500.) * (i + 1.);\n        time += hash12(seed) * .03; // モーションブラー\n        \n        Time = time * BPM / 60.;\n        lightPos = sin(normalize(vec3(3, 5, 9)) * time * 5.) * .5;\n        \n        // カメラの座標\n        vec3 ro = vec3(0, 0, 2);\n        ro = rotate3D(ro, time * .3, vec3(0, 1, 0));\n        ro.y += stepNoise(Time * .5, 3.) * .9;\n        \n        // ターゲット座標\n        vec3 ta = vec3(0);\n        ta.x += stepNoise(Time * .5 -  500., 3.) * .5;\n        ta.y += stepNoise(Time * .5 - 1000., 3.) * .5;\n        ta.z += stepNoise(Time * .5 - 1500., 3.) * .5;\n        \n        // レイベクトルを算出\n        vec3 dir = normalize(ta - ro);\n        vec3 side = normalize(cross(dir, vec3(0, 1, 0)));\n        vec3 up = cross(side, dir);\n        float fov = 60.;\n        fov += stepNoise(Time * .5 - 2000., 2.) * 30.;\n        vec3 rd = normalize(uv.x * side + uv.y * up + dir / tan(fov / 360. * PI));\n        \n        // DOF（被写界深度）\n        float L = length(ta - ro);\n        vec3 fp = ro + L * rd;\n        vec3 ros = ro;\n        float r = sqrt(hash12(seed * 1.1));\n        float a = hash12(seed * 1.2) * PI2;\n        vec3 v = vec3(r * vec2(cos(a), sin(a)) * L * 0.03, 0);\n        vec3 diro = vec3(0, 0, -1);\n        float va = acos(dot(dir, diro));\n        vec3 vax = cross(dir, diro);\n        v = rotate3D(v, va, vax);\n        //ros.xy += r * vec2(cos(a), sin(a)) * L * 0.03;\n        ros += v;\n        vec3 rds = normalize(fp - ros);\n        \n        col += render(ros, rds);\n    }\n    \n    col /= numSamples;\n    col = pow(col, vec3(1. / 2.2)); // ガンマ補正\n    fragColor = vec4(col, 1.);\n}\n*/","name":"Common","description":"","type":"common"}]}