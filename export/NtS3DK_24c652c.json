{"ver":"0.1","info":{"id":"NtS3DK","date":"1624685175","viewed":113,"name":"Fork Interactiv leek9d 130","username":"leek9d","description":"Interactive seamless Poisson blending by Ruofei Du.\nDrag mouse to draw! Press 1 for imposing, press 2 for mixing gradients, press space to clear the canvas.\nChange background in Buf. A, Chnl. 2.\nRef: P. Pérez, M. Gangnet, A. Blake. Poisson Image Editing.","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["2d","interactive","gradient","blending","poisson","diffusion","draw","multipass","mixed","ruofei"],"hasliked":0,"parentid":"4l3Xzl","parentname":"Interactive Poisson Blending"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/** \n * Interactive Poisson Blending by Ruofei Du (DuRuofei.com)\n * Demo: https://www.shadertoy.com/view/4l3Xzl\n * Tech brief: http://blog.ruofeidu.com/interactive-poisson-blending/\n * starea @ ShaderToy,License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * https://creativecommons.org/licenses/by-nc-sa/3.0/\n * \n * Reference: \n * [1] P. Pérez, M. Gangnet, A. Blake. Poisson image editing. ACM Transactions on Graphics (SIGGRAPH'03), 22(3):313-318, 2003.\n *\n * Created 12/6/2016\n * Update 4/5/2017:\n * [1] The iteration for each pixel will automatically stop after 100 iterations of Poisson blending.\n * \n * Bugs remaining:\n * [2] Edge effect, but it's fine leaving the edge glowing\n **/\n\n// Buffer B stores the users' strokes and iteration data\n// Buffer A runs the Poisson blending algorithm\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0, q);\n    fragColor.rgb *= 0.25 + 0.75 * pow( 16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.15 );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/** \n * Interactive Poisson Blending by Ruofei Du (DuRuofei.com)\n * Demo: https://www.shadertoy.com/view/4l3Xzl\n * Tech brief: http://blog.ruofeidu.com/interactive-poisson-blending/\n * starea @ ShaderToy,License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * https://creativecommons.org/licenses/by-nc-sa/3.0/\n * \n * Reference: \n * [1] P. Pérez, M. Gangnet, A. Blake. Poisson image editing. ACM Transactions on Graphics (SIGGRAPH'03), 22(3):313-318, 2003.\n *\n * Created 12/6/2016\n * Update 4/5/2017:\n * [1] The iteration for each pixel will automatically stop after 100 iterations of Poisson blending.\n * \n * Bugs remaining:\n * [2] Edge effect, but it's kind'of cool right now.\n **/\n\n// the stroke and iterations mask\n// r for strokes\n// b for iterations\n#define BRUSH_SIZE 0.1\n#define INITIAL_CIRCLE_SIZE 0.4\nconst float KEY_1 = 49.5;\nconst float KEY_2 = 50.5;\nconst float KEY_SPACE = 32.5;\nconst float KEY_ALL = 256.0;\n\nbool getKeyDown(float key) {\n    return texture(iChannel1, vec2(key / KEY_ALL, 0.5)).x > 0.1;\n}\n\nbool getMouseDown() {\n    return iMouse.z > 0.0;\n}\n\nbool isInitialization() {\n\tvec2 lastResolution = texture(iChannel0, vec2(0.0) / iResolution.xy).yz; \n    return any(notEqual(lastResolution, iResolution.xy));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = 2.0 * (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\tfloat mixingGradients = texture(iChannel0, vec2(1.5) / iResolution.xy).y;    \n    float frameReset = texture(iChannel0, vec2(1.5) / iResolution.xy).z;    \n    vec2 prevData = texture(iChannel0, uv).xy;\n    float mask = prevData.x;\n    float iterations = prevData.y + 0.015;\n    \n    bool resetBlending = (getKeyDown(KEY_1) && mixingGradients > 0.5) || (getKeyDown(KEY_2) && mixingGradients < 0.5); \n    \n    if (getKeyDown(KEY_1)) mixingGradients = 0.0;\n    if (getKeyDown(KEY_2)) mixingGradients = 1.0;\n\n    if (isInitialization() || getKeyDown(KEY_SPACE)) {    \n        // reset canvas\n        vec2 q = vec2(-0.7, 0.5); \n        if (distance(p, q) < INITIAL_CIRCLE_SIZE) mask = 1.0;\n        if (getKeyDown(KEY_SPACE)) mask = 0.0; \n        iterations = 0.0; \n        resetBlending = true; \n    } else \n    if (getMouseDown()) {\n        // draw on canvas\n    \tvec2 mouse = 2.0 * (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n        bool isPainted = (distance(mouse, p) < BRUSH_SIZE);\n        \n        if (isPainted) {\n            mask = 1.0; \n            iterations = 0.0; \n        };\n        frameReset = float(iFrame) - 100.0; \n    } \n    \n    if (resetBlending) iterations = 0.0; \n    \n\tif (fragCoord.x < 1.0) { \n        fragColor = vec4(mask, iResolution.xy, 1.0);  \n    } else \n    if (fragCoord.x < 2.0) { \n        if (resetBlending) frameReset = float(iFrame); \n  \t\tfragColor = vec4(mask, mixingGradients, frameReset, 1.0);  \n    } else {\n        fragColor = vec4(mask, iterations, 0.5, 1.0); \n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":3,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/** \n * Interactive Poisson Blending by Ruofei Du (DuRuofei.com)\n * Demo: https://www.shadertoy.com/view/4l3Xzl\n * Tech brief: http://blog.ruofeidu.com/interactive-poisson-blending/\n * starea @ ShaderToy,License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * https://creativecommons.org/licenses/by-nc-sa/3.0/\n * \n * Reference: \n * [1] P. Pérez, M. Gangnet, A. Blake. Poisson image editing. ACM Transactions on Graphics (SIGGRAPH'03), 22(3):313-318, 2003.\n *\n * Created 12/6/2016\n * Update 4/5/2017:\n * [1] The iteration for each pixel will automatically stop after 100 iterations of Poisson blending.\n * \n * Bugs remaining:\n * [2] Edge effect, but it's kind'of cool right now.\n **/\n\n// This is the main shader for the Poisson blending process.\n#define NUM_NEIGHBORS 4\nfloat mixingGradients; \nvec2 neighbors[NUM_NEIGHBORS];\n\n#define RES(UV) (tap(iChannel0, vec2(UV)))\n#define MASK(UV) (tap(iChannel1, vec2(UV)))\n#define BASE(UV) (tap(iChannel2, vec2(UV)))\n#define SRC(UV) (tap(iChannel3, vec2(UV)))\n#define MAX_ITERATIONS 100.0\n#define EPS 0.00001\nvec3 tap(sampler2D tex, vec2 uv) { return texture(tex, uv).rgb; }\n\nbool isInitialization() {\n    vec2 lastResolution = texture(iChannel1, vec2(0.5) / iResolution.xy).yz;   \n    return any(notEqual(lastResolution, iResolution.xy));\n}\n\nbool isMasked(vec2 uv) {\n    return texture(iChannel1, uv).x > 0.5; \n}\n\nbool isIterating(vec2 uv) {\n    return texture(iChannel1, uv).y < 1.0; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor.a = 1.0; \n    \n  \tmixingGradients = texture(iChannel1, vec2(1.5) / iResolution.xy).y;  \n  \tfloat frameReset = texture(iChannel1, vec2(1.5) / iResolution.xy).z;  \n     \n    // init: resolution does not match / current frame is black / mode changes\n    if (isInitialization() || RES(vec2(1.0)).r < EPS || float(iFrame - 2) < frameReset) {\n        fragColor.rgb = BASE(uv);\n        return; \n    }\n    \n    vec2 p = uv; \n    //if (isMasked(p) && frameReset + MAX_ITERATIONS > float(iFrame)) {\n    if (isMasked(p) && isIterating(p)) {\n        vec3 col = vec3(0.0); \n        float convergence = 0.0; \n        \n        neighbors[0] = uv + vec2(-1.0 / iChannelResolution[3].x, 0.0); \n        neighbors[1] = uv + vec2( 1.0 / iChannelResolution[3].x, 0.0); \n        neighbors[2] = uv + vec2(0.0, -1.0 / iChannelResolution[3].y); \n        neighbors[3] = uv + vec2(0.0,  1.0 / iChannelResolution[3].y);\n        \n        for (int i = 0; i < NUM_NEIGHBORS; ++i) {\n            vec2 q = neighbors[i];\n            col += isMasked(q) ? RES(q) : BASE(q);\n            vec3 srcGrad = SRC(p) - SRC(q);\n            \n            if (mixingGradients > 0.5) {\n                vec3 baseGrad = BASE(p) - BASE(q);\n                col.r += (abs(baseGrad.r) > abs(srcGrad.r)) ? baseGrad.r : srcGrad.r;\n                col.g += (abs(baseGrad.g) > abs(srcGrad.g)) ? baseGrad.g : srcGrad.g;\n                col.b += (abs(baseGrad.b) > abs(srcGrad.b)) ? baseGrad.b : srcGrad.b;\n            } else {\n                col += srcGrad;     \n            }\n        }     \n        col /= float(NUM_NEIGHBORS); \n        convergence += distance(col, RES(p)); // TODO: converge\n        fragColor.rgb = col;\n        return; \n    }\n                \n    fragColor.rgb = RES(uv); \n}","name":"Buffer A","description":"","type":"buffer"}]}