{"ver":"0.1","info":{"id":"4lSfWt","date":"1517479264","viewed":216,"name":"DOOM Melt","username":"OccamsLaser","description":"Click the image to initiate the effect.\n\nThe function for timing when a column of pixels melts down could use a bit of work, but I'm happy enough with it is for now. Suggestions for better (more accurate to the game) offset functions would be helpful.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["doom","multipass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 frag_color, in vec2 frag_coord) {\n    vec2 uv = frag_coord/iResolution.xy;\n    \n    vec4 data = texelFetch(iChannel0, ivec2(frag_coord.x, 0.0), 0);\n   \t\t\n    data.y = min(data.y,100.0);\n    data.y /= 100.0;\n    \n    if(data.x == 0.0) {\n        if(uv.y < data.y) {\n\t\t\tfrag_color = texture(iChannel2, uv-vec2(0.0,data.y), 0.0);\n        } else {\n    \t\tfrag_color = texture(iChannel1, uv, 0.0);\n    \t}\n    } else {\n        if(uv.y < data.y) {\n    \t\tfrag_color = texture(iChannel1, uv-vec2(0.0,data.y), 0.0);\n    \t} else {\n        \tfrag_color = texture(iChannel2, uv, 0.0);\n    \t}\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float offsets(float x) {\n    //generated by the excellent shadershop: http://www.cdglabs.org/Shadershop/\n\treturn 35.0*((sin((x - 0.283) / 0.194 / 0.412 ) * -0.407) * ((x - 0.283) / 0.194 * 0.681 + -0.341)) + 25.0;   \n}\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n    vec4 data = texelFetch(iChannel0,ivec2(frag_coord),0);\n    \n    data.y -= 2.0;\n    data.y = max(data.y,0.0);\n    \n    int i = 0;\n    float total = 0.0;\n    for(i = 0; i < int(iResolution.x); i++)\n     \ttotal += texelFetch(iChannel0,ivec2(i,0.0),0).y;   \n    \n    if(iMouse.z > 0.0 && data.y == 0.0 && total == 0.0) {\n        data.x = float(int(data.x) ^ 0x1);\n        \n        float offset = offsets((8.0*floor(frag_coord.x/8.0))/iResolution.x);\n        \n        data.y = 100.0 + offset;\n    }\n    \n    frag_color = data;\n}","name":"Buf A","description":"","type":"buffer"}]}