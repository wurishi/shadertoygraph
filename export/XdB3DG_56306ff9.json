{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// Hazel Quantock 2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// slip between conventional & anisotropic highlights\n//#define COMPARE\n\n\nvec2 Noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec4 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0 );\n\treturn mix( rg.yw, rg.xz, f.z );\n}\n\n\nfloat DistanceField( vec3 pos )\n{\n\t//pos = abs(pos); return max( pos.x, max( pos.y, pos.z ) )-1.0;\n\t\n\tfloat p = 16.0; pos = pow(abs(pos),vec3(p/2.0)); return pow( dot( pos, pos ), 1.0/p )-1.0;\n\t\n\t//return (length(pos-vec3(0,-1,0))-2.0 + sin(sqrt(pow(atan(length(pos.xz),pos.y),2.0)+1.0)*20.0/*-iTime*/)/20.0)*.707;\n\t\n\t//return (pos.y + sin(pos.x*1.0)*sin(pos.z*1.0)/1.0)*.7;\n}\n\n\nvec3 Sky( vec3 ray )\n{\n\treturn mix( vec3(.8), vec3(0), exp2(-(1.0/max(ray.y,.01))*vec3(.4,.6,1.0)) );\n}\n\n\nvec3 Shade( vec3 pos, vec3 ray, vec3 normal, vec3 lightDir, vec3 lightCol )\n{\n\tfloat ndotl = dot(normal,lightDir);\n\tvec3 light = lightCol*max(.0,ndotl);\n\tlight += mix( vec3(.01,.04,.08), vec3(.1), (-normal.y+1.0) ); // ambient\n\t\n\tvec3 h = normalize(lightDir-ray);\n\n\t// this would work better using voronoi to get close points for aniso, then blend between them\n\t\n\tvec3 coord = pos*.6 + iTime*vec3(0,.0,0);\n\tcoord.xy = coord.xy*.7071+coord.yx*.7071*vec2(1,-1);\n\tcoord.xz = coord.xz*.7071+coord.zx*.7071*vec2(1,-1);\n\tvec3 aniso = vec3( Noise(coord), Noise(coord.yzx).x )*2.0-1.0;\n\taniso -= normal*dot(aniso,normal);\n\t\n\tfloat anisotropy = min(1.0,length(aniso));\n\taniso /= anisotropy;\n\t\n\tanisotropy = .8;\n\t\n\t#ifdef COMPARE\n\t\tanisotropy *= clamp(sin(iTime*1.0)*6.0+.5,.0,1.0); // constant magnitude => we get pinches, which actually look nice!\n\t#endif\n\n\tfloat ah = abs(dot(h,aniso)); // check if it's perpendicular to the striations\n\tfloat nh = max(.0,dot(normal,h));\n\t\n\tfloat q = exp2((1.0-anisotropy)*3.0);\n\tnh = pow( nh, q*10.0 );\n\tnh *= pow( 1.0-ah*anisotropy, 16.0 );\n\tvec3 specular = lightCol*nh*exp2((1.0-anisotropy)*1.0);\n\t\n\t// fade specular near terminator, to fake gradual occlusion of the micronormals\n\tspecular *= smoothstep(.0,.5,ndotl);\n\t\n\tvec3 reflection = Sky( reflect(ray,normal) );\n\tfloat fresnel = pow( 1.0+dot(normal,ray), 5.0 );\n\tfresnel = mix( .0, .2, fresnel );\n\t\n\treturn mix( light*vec3(.1), reflection, fresnel ) + specular;\n}\n\n\n\n// Isosurface Renderer\n\nfloat traceStart = .1; // set these for tighter bounds for more accuracy\nfloat traceEnd = 40.0;\nfloat Trace( vec3 pos, vec3 ray )\n{\n\tfloat t = traceStart;\n\tfloat h;\n\tfor( int i=0; i < 60; i++ )\n\t{\n\t\th = DistanceField( pos+t*ray );\n\t\tif ( h < .001 )\n\t\t\tbreak;\n\t\tt = t+h;\n\t}\n\t\n\tif ( t > traceEnd )//|| h > .001 )\n\t\treturn 0.0;\n\t\n\treturn t;\n}\n\nvec3 Normal( vec3 pos, vec3 ray )\n{\n\tconst vec2 delta = vec2(0,.001);\n\tvec3 grad;\n\tgrad.x = DistanceField( pos+delta.yxx )-DistanceField( pos-delta.yxx );\n\tgrad.y = DistanceField( pos+delta.xyx )-DistanceField( pos-delta.xyx );\n\tgrad.z = DistanceField( pos+delta.xxy )-DistanceField( pos-delta.xxy );\n\t\n\t// prevent normals pointing away from camera (caused by precision errors)\n\tfloat gdr = dot ( grad, ray );\n\tgrad -= max(.0,gdr)*ray;\n\t\n\treturn normalize(grad);\n}\n\n\n// Camera\n\nvec3 Ray( float zoom, vec2 fragCoord )\n{\n\treturn vec3( fragCoord.xy-iResolution.xy*.5, iResolution.x*zoom );\n}\n\nvec3 Rotate( inout vec3 v, vec2 a )\n{\n\tvec4 cs = vec4( cos(a.x), sin(a.x), cos(a.y), sin(a.y) );\n\t\n\tv.yz = v.yz*cs.x+v.zy*cs.y*vec2(-1,1);\n\tv.xz = v.xz*cs.z+v.zx*cs.w*vec2(1,-1);\n\t\n\tvec3 p;\n\tp.xz = vec2( -cs.w, -cs.z )*cs.x;\n\tp.y = cs.y;\n\t\n\treturn p;\n}\n\n\n// Camera Effects\n\nvoid BarrelDistortion( inout vec3 ray, float degree )\n{\n\tray.z /= degree;\n\tray.z = ( ray.z*ray.z - dot(ray.xy,ray.xy) ); // fisheye\n\tray.z = degree*sqrt(ray.z);\n}\n\nvec3 LensFlare( vec3 ray, vec3 light, vec2 fragCoord )\n{\n\tvec2 dirtuv = fragCoord.xy/iResolution.x;\n\t\n\tfloat dirt = 1.0-texture( iChannel1, dirtuv ).r;\n\t\n\tfloat l = max(.0,dot(light,ray));\n\t\n\treturn (pow(l,20.0)*dirt*.1 + 1.0*pow(l,100.0))*vec3(1.05,1,.95);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 ray = Ray(1.0,fragCoord);\n\tBarrelDistortion( ray, .5 );\n\tray = normalize(ray);\n\tvec3 localRay = ray;\n\n\tvec3 pos = 6.0*Rotate( ray, vec2(.4,iTime*.1+.5)+vec2(1.6,-6.3)*(iMouse.yx/iResolution.yx - .5) );\n\t\n\tvec3 col;\n\n\tvec3 lightDir = normalize(vec3(3,2,-1));\n\t\n\tfloat t = Trace( pos, ray );\n\tif ( t > .0 )\n\t{\n\t\tvec3 p = pos + ray*t;\n\t\t\n\t\t// shadow test\n\t\tfloat s = Trace( p, lightDir );\n\t\t\n\t\tvec3 n = Normal(p, ray);\n\t\tcol = Shade( p, ray, n, lightDir, (s>.0)?vec3(0):vec3(.98,.95,.92) );\n\t\t\n\t\t// fog\n\t\tfloat f = 100.0;\n//\t\tcol *= exp2(-t*vec3(.1,.6,1.0)/f);\n\t\tcol = mix( vec3(.8), col, exp2(-t*vec3(.4,.6,1.0)/f) );\n\t}\n\telse\n\t{\n\t\tcol = Sky( ray );\n\t}\n\t\n\tfloat sun = Trace( pos, lightDir );\n\tif ( sun == .0 )\n\t{\n\t\tcol += LensFlare( ray, lightDir,fragCoord );\n\t}\n\t\n\t// vignetting:\n\tcol *= smoothstep( .5, .0, dot(localRay.xy,localRay.xy) );\n\n\t// compress bright colours, ( because bloom vanishes in vignette )\n\tvec3 c = (col-1.0);\n\tc = sqrt(c*c+.01); // soft abs\n\tcol = mix(col,1.0-c,.48); // .5 = never saturate, .0 = linear\n\t\n\n\t// grain\n\tvec2 grainuv = fragCoord.xy + floor(iTime*60.0)*vec2(37,41);\n\tvec2 filmNoise = texture( iChannel0, .5*grainuv/iChannelResolution[0].xy ).rb;\n\tcol *= mix( vec3(1), mix(vec3(1,.5,0),vec3(0,.5,1),filmNoise.x), .1*filmNoise.y );\n\n\t\n\tfragColor = vec4(pow(col,vec3(1.0/2.6)),1);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XdB3DG","date":"1392753558","viewed":1802,"name":"Anisotropic Highlights","username":"TekF","description":"Use a 2D tangent space vector to bias the shape of the specular highlight. (The scene is my   shader.)","likes":35,"published":1,"flags":0,"usePreview":0,"tags":["specular"],"hasliked":0,"parentid":"","parentname":""}}