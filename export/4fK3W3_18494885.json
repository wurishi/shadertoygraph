{"ver":"0.1","info":{"id":"4fK3W3","date":"1713369736","viewed":86,"name":"forest third attempt","username":"0x177","description":"improving","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"l3XGRl","parentname":"raymarching startingpoint"},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 200\n#define MAX_DIST 150.\n#define SURF_DIST .05\n#define TAU 6.283185\n#define PI 3.141592\n\n// comment out if you only want blinn-phong\n#define blinn_phong_fresnel_bac\n\nconst float globalAmbient = 0.4; // how strong is the ambient lightning\nconst float globalDiffuse = 0.25; // how strong is the diffuse lightning\nconst float globalSpecular = 0.0; // how strong is the specular lightning\nconst float globalSpecularExponent = 512.0; // how focused is the shiny spot\nconst vec3 lightPos = vec3(0.0, 10.3, -10.5); // position of the light source\nconst vec3 lightColor = vec3(0.9, 0.9, 0.9); // color of the light source\nconst vec3 ambientColor = vec3(1.0, 1.0, 1.0); // ambient color\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat noise(vec2 p) {\n    return ((sin(p.x)+sin(p.y))+2.0)*0.25;\n}\n\n\nfloat hash13(vec3 p)\n{\n//    p  = fract( p*0.3183099+.1 );\n//\tp *= 17.0;\n//    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n    return texture(iChannel0,p*0.03).r;\n}\n\nfloat noise13( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash13(i+vec3(0,0,0)), \n                        hash13(i+vec3(1,0,0)),f.x),\n                   mix( hash13(i+vec3(0,1,0)), \n                        hash13(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash13(i+vec3(0,0,1)), \n                        hash13(i+vec3(1,0,1)),f.x),\n                   mix( hash13(i+vec3(0,1,1)), \n                        hash13(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat ellipse( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat fbm(vec2 p) {\n    float h = 0.0;\n    float a = 1.3;\n    float f = 1.0;\n    \n    for (float i = 0.0; i<8.0; i++) {\n        h += a * noise(p);\n        a *= 0.9;\n        f *= 1.05;\n        p = p*f*Rot(3.1415/4.0)-h*0.4;\n    }\n    \n    return h;\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// 32 texture samples per call \nfloat fbm(vec3 p) {\n    float h = 0.0;\n    float a = 1.3;\n    float f = 1.0;\n    \n    for (float i = 0.0; i<8.0; i++) {\n        h += a * noise13(p*f);\n        a *= 0.9;\n        f *= 1.35;\n    }\n    \n    return h;\n}\n\nvec4 GetDist(vec3 p) {    \n    float d = 999.0;\n    float mat = 0.0;\n    \n    p.y -= 18.0;\n    p.xz += 2043.;\n    \n    float h = fbm(p.xz*0.1)*7.0;\n    \n    d = p.y+h;\n    \n    vec3 q = p;\n    q.xz = mod(p.xz,4.0)-2.0;\n    vec2 id = floor(p.xz/4.0);\n    float hs = hash12(id)*0.5;\n    q.xz -= vec2(hash12(id),hash12(id+vec2(12342,1253)))*0.6;\n    q.y += h-2.0;\n    \n    float tree = ellipse(q,vec3(1.1,(hs+0.5)*4.0,1.1));//+fbm(p*6.)*0.05;\n    \n    if (tree< 0.1) {\n        tree += fbm(p*6.)*0.05;\n    }\n    \n    tree *= 0.5;\n        \n    d = min(d,tree);\n    \n    mat = (d==tree) ? 1.0 : 0.0;\n    \n    return vec4(d,mat,id);\n}\n\nvec4 RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    float mat;\n    vec2 id;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        vec4 dS = GetDist(p);\n        dO += dS.x;\n        mat = dS.y;\n        id = dS.zw;\n        \n        if(dO>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return vec4(dO,mat,id);\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = GetDist(p).x - \n        vec3(GetDist(p-e.xyy).x, GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nfloat ambientOcclusion(vec3 p, vec3 n){\n    const int steps = 1;\n    const float delta = 0.5;\n\n    float a = 0.0;\n    float weight = 0.75;\n    float m;\n    for(int i=1; i<=steps; i++) {\n        float d = (float(i) / float(steps)) * delta;\n        a += weight*(d - GetDist(p + n*d).x);\n        weight *= 0.5;\n    }\n    return clamp(1.0 - a, 0.0, 1.0);\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<100; i++ )\n    {\n\t\tfloat h = GetDist( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += h*.25;\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1. );\n}\n\n\nvec3 shade(  vec3 position,\n                           vec3 lightPosition,\n                           vec3 ambientCol,\n                           vec3 lightCol,\n                           float ambientCoeff,\n                           float diffuseCoeff,\n                           float specularCoeff,\n                           float specularExponent,\n                           vec3 camera_pos,\n                           vec3 ray_direction,\n                           vec3 normal\n)\n{\n      vec3 toEye = normalize(camera_pos - position);\n      vec3 toLight = normalize(lightPosition - position);\n      vec3 reflection = reflect(-toLight, normal);\n\n      vec3 ambientFactor = ambientCol * ambientCoeff;\n      vec3 diffuseFactor = diffuseCoeff * lightCol * max(0.0, dot(normal, toLight));\n      vec3 specularFactor = lightCol * pow(max(0.0, dot(toEye, reflection)), specularExponent)\n                     * specularCoeff;\n\n      float ao = ambientOcclusion(position+normal*0.1,normal);\n      float ss= softshadow(position,lightPos,0.1,50.0);\n       \n    diffuseFactor *= ss;\n    diffuseFactor *= ao;\n    \n    #ifdef blinn_phong_fresnel_bac\n    float bac = clamp( dot( normal, normalize(vec3(-lightPosition.x,0.0,-lightPosition.z))), 0.0, 1.0 )*clamp( 1.0-position.y,0.0,1.0);\n    float fre = pow( clamp(1.0+dot(normal,ray_direction),0.0,1.0), 2.0 );\n    return ambientFactor + diffuseFactor + specularFactor + 0.20 * bac + 0.20 * fre;\n    #else\n    return ambientFactor + diffuseFactor + specularFactor;\n    #endif\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0., 0., -iTime*3.0);\n    ro.y = GetDist(ro).x-0.5;\n    \n    vec3 col = vec3(0.0);\n    \n    vec3 rd = normalize(vec3(uv,1.0));\n    rd.yz *= Rot(-m.y*PI);\n    rd.xz *= Rot(-m.x*TAU);\n    \n    vec4 rm = RayMarch(ro, rd);\n    float d = rm.x;\n    vec3 p = ro + rd * d;\n    vec3 bg = vec3(0.,0.631,0.788);\n    col = bg;\n\n    if(d<MAX_DIST) {\n        vec3 n = GetNormal(p);\n        if (rm.y == 0.0) {\n            float lambda = smoothstep(0.59,1.0,n.y);\n            col = vec3(0.594,0.375,0.308) * (1.0-lambda)+lambda*vec3(0.71,0.71,0.055);\n        } else if (rm.y==1.0) {\n            float ne = hash12(rm.zw);\n            float lambda = smoothstep(0.3,1.0,ne);\n            col = vec3(0.51,0.61,0.035)*(1.0-lambda)+lambda*vec3(0.953,0.886,0.231);\n        }\n        col *= shade(p,lightPos,ambientColor,lightColor,globalAmbient,globalDiffuse,globalSpecular,globalSpecularExponent,ro,rd,n);\n        col = mix(col,bg,1.0 - exp(-0.0001*d*d));\n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}