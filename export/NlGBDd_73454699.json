{"ver":"0.1","info":{"id":"NlGBDd","date":"1665428273","viewed":114,"name":"Crooked Bricks","username":"Arnklit","description":"I had this idea of using voronoi cells and finding intersections to make uneven bricks. I'm guessing someone else has thought of this before, but I'm pretty pleased that the idea worked.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","bricks","uneven"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// MIT License - Kasper Arnklit Frandsen 2022\n\nvec2 perpendicular(vec2 vector) {\n\tvector = vector.yx;\n\tvector.y = -vector.y;\n\treturn vector;\n}\n\nfloat rand(vec2 x) {\n\treturn fract(cos(mod(dot(x, vec2(13.989, 8.141)), 3.14)) * 43758.5453);\n}\n\n// https://wiki.secondlife.com/wiki/Geometric#Line_and_Line.2C_intersection_point\n// Copyright 2001, softSurfer (www.softsurfer.com); 2008, LSL-port by Nexii Malthus\n// (CC BY-SA 3.0 License)\nvec2 get_line_intersection( vec2 A, vec2 B, vec2 C, vec2 D ) {\n    vec2 b = B - A;\n\tvec2 d = D - C;\n    float dotperp = b.x * d.y - b.y * d.x;\n\t// if I had to worry about parallel lines, but I shouldn't have to here\n    // if (dotperp == 0) return <-1,-1,-1>;\n\tvec2 c = C - A;\n    float t = (c.x * d.y - c.y * d.x) / dotperp;\n\treturn vec2(A.x + t * b.x, A.y + t * b.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 scale = vec2(6.0, 6.0);\n    float randomness = sin(iTime);\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    uv += iTime * .1;\n\n    vec2 scaled_uv = uv * scale;\n\t\n\tfloat x_offset = 0.5*step(0.5, fract(uv.y*scale.y*0.5));\n\t\t\n\tvec2 cell_id = floor(scaled_uv);\n\tvec2 cell_uv = fract(scaled_uv);\n\t\n\tcell_id -= vec2(x_offset, 0.0);\n\t\n\tfloat min_distance = 1.0;\n\tvec2 c_point;\n\tvec2 left_top;\n\tvec2 right_top;\n\tvec2 right_bottom;\n\tvec2 left_bottom;\n\t\n\tfor (int i = -1; i <= 1; i++) {\n\t\t// neighbor in uv space\n\t\tvec2 neighbor = vec2(float(i), 0.0);\n\t\tvec2 point = cell_id + neighbor + vec2(0.5) + (vec2(0.0, rand(mod(cell_id + neighbor, scale)) - 0.5) * randomness);\n\t\tpoint /= scale;\n\t\tfloat dist = distance(point, uv);\n\t\t\n\t\t// get left, right neighbor in here as well, to calculate perpendicular and intersect\n\t\tvec2 left = cell_id + neighbor + vec2(-1.0, 0.0) + vec2(0.5) + (vec2(0.0, rand(mod(cell_id + neighbor + vec2(-1.0, 0.0), scale)) - 0.5) * randomness);\n\t\tleft /= scale;\n\t\tvec2 right = cell_id + neighbor + vec2(1.0, 0.0) + vec2(0.5) + (vec2(0.0, rand(mod(cell_id + neighbor + vec2(1.0, 0.0), scale)) - 0.5) * randomness);\n\t\tright /= scale;\n\t\t\n\n\t\t// Find the midpoint between current and left and a vector perpendicular to the vector between the two points\n\t\tvec2 left_midpoint = (left + point) / 2.0;\n\t\tvec2 left_perpendicular = perpendicular(point - left);\n\t\tvec2 left_2 = left_midpoint + left_perpendicular;\n\t\t// Do the same for midpoint to right point\n\t\tvec2 right_midpoint = (point + right) / 2.0;\n\t\tvec2 right_perpendicular = perpendicular(right - point);\n\t\tvec2 right_2 = right_midpoint + right_perpendicular;\n\t\t\n\t\tif (dist < min_distance) {\n\t\t\tmin_distance = dist;\n\t\t\tc_point = point;\n   \t\t\tleft_top = get_line_intersection(left_midpoint, left_2, cell_id / scale, cell_id / scale + vec2(1.0, 0.0));\n\t\t\tright_top = get_line_intersection(right_midpoint, right_2, cell_id / scale, cell_id / scale + vec2(1.0, 0.0));\n\t\t\tright_bottom = get_line_intersection(right_midpoint, right_2, (cell_id + 1.0) / scale, (cell_id + 1.0) / scale + vec2(1.0, 0.0));\n\t\t\tleft_bottom = get_line_intersection(left_midpoint, left_2, (cell_id + 1.0) / scale, (cell_id + 1.0) / scale + vec2(1.0, 0.0));\n\t\t}\n\t}\n    \n    float grad = (uv.x - mix(left_top.x, left_bottom.x, cell_uv.y)) / mix(right_top.x - left_top.x, right_bottom.x - left_bottom.x, cell_uv.y);\n\n    vec2 brick_uv = vec2(grad, cell_uv.y);\n\n    // Render the bricks\n    \n    float brick_height = 1.0 / scale.y;\n\tfloat round = 0.5 / brick_height;\n\tfloat mortar = 0.01 / brick_height;\n\tfloat bevel = 0.1 / brick_height;\n\n    float color;\n\tvec2 d = (min(brick_uv.xy, 1.0 - brick_uv.xy) * -2.0)*scale.yx+vec2(round+mortar);\n    color = length(max(d,vec2(0))) + min(max(d.x,d.y),0.0)-round;\n\tcolor = clamp(-color/bevel, 0.0, 1.0);\n    \n    // Output to screen\n    fragColor = vec4(vec3(color),1.0);\n}","name":"Image","description":"","type":"image"}]}