{"ver":"0.1","info":{"id":"Xc3BDj","date":"1733498842","viewed":61,"name":"Luigi in Raymarching","username":"KivuSupremeKing","description":"luigi model in raymarching, using the sdfs on Inigo Quilez's blog. My first time sculpting a character.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float smin( float a, float b, float k )\n{\n    k *= 1.0/(1.0-sqrt(0.5));\n    return max(k,min(a,b)) -\n           length(max(k-vec2(a,b),0.0));\n}\n\nmat2 rot2D(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\nfloat opUnion( float d1, float d2 )\n{\n    return min(d1,d2);\n}\nfloat opSubtraction( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\nfloat opIntersection( float d1, float d2 )\n{\n    return max(d1,d2);\n}\nfloat opXor(float d1, float d2 )\n{\n    return max(min(d1,d2),-max(d1,d2));\n}\n\nvec3 scale( in vec3 p, in vec3 s)\n{\n    return vec3(p.x / s.x, p.y / s.y, p.z/s.z);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b + r;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n\n  vec2 q = vec2( length(p.xz), p.y );\n  float k = dot(q,vec2(-b,a));\n  if( k<0.0 ) return length(q) - r1;\n  if( k>a*h ) return length(q-vec2(0.0,h)) - r2;\n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdCutSphere( vec3 p, float r, float h )\n{\n  // sampling independent computations (only depend on shape)\n  float w = sqrt(r*r-h*h);\n\n  // sampling dependant computations\n  vec2 q = vec2( length(p.xz), p.y );\n  float s = max( (h-r)*q.x*q.x+w*w*(h+r-2.0*q.y), h*q.x-w*q.y );\n  return (s<0.0) ? length(q)-r :\n         (q.x<w) ? h - q.y     :\n                   length(q-vec2(w,h));\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdHat(in vec3 pos)\n{\n    vec3 cen = vec3(-0.1, 0.9, 0.);\n    vec3 q = pos - cen;\n    q.xy *= rot2D(0.8);\n    q = scale(q, vec3(1., 0.8, 1.2));\n    float b = sdSphere(q, 0.11);\n    \n    cen = vec3(0.1, 0.95, 0.0);\n    q = pos - cen;\n    q.xy *= rot2D(-0.2);\n    q = scale(q, vec3(1., 0.7, 1.2));\n    float f = sdSphere(q, 0.14);\n    \n    cen = vec3(0.0, 0.86, 0.0);\n    q = pos - cen;\n    q.xy *= rot2D(-0.0);\n    q = scale(q, vec3(1., 0.8, 1.1));\n    float m = sdSphere(q, 0.14);\n    \n    float p = sdRoundBox(pos - vec3(0.1, 0.85, 0.0), vec3(0.15, 0.01, 0.15), 0.03);\n    \n    return smin(smin(smin(b, f, 0.015), m, 0.018), p, 0.02);\n}\n\nfloat sdHead(in vec3 pos)\n{\n    vec3 cen = vec3(0., 0.5, 0.);\n    float h = sdRoundCone(pos - cen, 0.1, 0.15, 0.3);\n    \n    cen = vec3(0.1, 0.7, 0.0);\n    vec3 q = pos - cen;\n    q.xy *= rot2D(1.6);\n    float n = sdRoundCone(q, 0.04, 0.05, 0.2);\n    \n    pos.z = abs(pos.z);\n    q = pos - vec3(0.15, 0.7, 0.05);\n    q.yz *= rot2D(3.54);\n    q = scale(q, vec3(1., 0.8, 1.1));\n    float m = sdCutSphere(q, 0.08, 0.02);\n    \n    q = pos - vec3(0.13, 0.76, 0.05);\n    q = scale(q, vec3(1., 1.1, 1.0));\n    float e = sdSphere(q, 0.013);\n    \n    return min(min(min(h, n), m), e);\n}\n\nfloat sdBodyBase(vec3 pos)\n{\n    vec3 cen = vec3(0., 0.18, 0.1);\n    vec3 q = pos - cen;\n    q.yz *= rot2D(0.5);\n    \n    float dl = sdRoundCone(q, 0.06, 0.14, 0.2);\n    \n    cen = vec3(0., 0.18, -0.1);\n    q = pos - cen;\n    q.yz *= rot2D(-0.5);\n    float dr = sdRoundCone(q, 0.06, 0.14, 0.2);\n    float base = smin(dl, dr, 0.005);\n    return base;\n}\n\nfloat sdBody(in vec3 pos)\n{\n    float base = sdBodyBase(pos);\n    float biggerBase = base - 0.008;\n    \n    float dsub0 = sdBox(pos - vec3(0.0, 0.45, 0.0), vec3(0.3, 0.08, 0.06));\n    \n    biggerBase = opSubtraction(dsub0, biggerBase);\n    \n    base = min(base, biggerBase);\n    \n    float dc = sdTorus(pos - vec3(0., 0.45, 0.0), vec2(0.1, 0.02));\n    \n    float overall = smin(base, dc, 0.003);\n    \n    pos.z = abs(pos.z);\n    float but = sdSphere(pos - vec3(0.08, 0.38, 0.09), 0.038);\n    overall = min(overall, but);\n    float a0 = sdCapsule(pos - vec3(0., 0.4, 0.), vec3(0., 0., 0.4), vec3(0.), 0.05);\n    float h = sdSphere(pos - vec3(0.0, 0.4, 0.39), 0.07);\n    float a = min(a0, h);\n    \n    float sh0 = sdCutSphere(pos - vec3(0.07, 0.1, 0.12), 0.08, 0.02);\n    float sh1 = sdCutSphere(pos - vec3(-0.02, 0.1, 0.07), 0.06, 0.02);\n    float sh = smin(sh0, sh1, 0.02);\n    \n    return min(min(overall, a), sh);\n}\n\nfloat map(in vec3 pos)\n{\n    float dHead = sdHead(pos);\n    float dBody = sdBody(pos);\n    float dHat = sdHat(pos);\n    float d2 = pos.y + .3;\n    \n    return min(min(min(dHead, d2), dBody), dHat);\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    vec2 e = vec2(0.0001, 0.);\n    return normalize(vec3(map(pos+e.xyy)-map(pos-e.xyy),\n                          map(pos+e.yxy)-map(pos-e.yxy),\n                          map(pos+e.yyx)-map(pos-e.yyx)));\n}\n\nfloat castRay(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    for (int i = 0; i < 100; i++)\n    {\n        vec3 pos = ro + rd*t;\n        \n        float h = map(pos);\n        \n        if (h < 0.001) break;\n        \n        t += h;\n        if (t >= 20.) break;\n    }\n    if (t > 20.)\n        t = -1.;\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    float an = 10. * iMouse.x / iResolution.x;\n\n\n    //raymarching\n    vec3 ta = vec3(0., .5, 0.); //target point\n    vec3 ro = ta + vec3(1.5*sin(an), 0.0, 1.5*cos(an));\n    \n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(0., 1., 0.))); // find side\n    vec3 vv = normalize(cross(uu, ww)); //find up\n    \n    vec3 rd = normalize(vec3(uv.x*uu + uv.y*vv + 1.8*ww)); // -1.5 is the near plane position\n    \n    \n    vec3 skyCol = vec3(.4, .75, 1.) - .7*rd.y;\n    skyCol = mix(skyCol, vec3(.7, .75, .8), exp(-10. * rd.y));\n    vec3 col = skyCol;\n    \n    float t = castRay(ro, rd);\n    \n    if (t > 0.) {\n        vec3 pos = ro + rd*t;\n        vec3 normal = calcNormal(pos);\n        vec3 mate = vec3(0.18);\n        \n        vec3 sun_dir = normalize(vec3(.8, .3, .2));\n        float sun_dif = clamp(dot(normal, sun_dir), 0., 1.);\n        float sun_sha = step( castRay(pos + normal * 0.001, sun_dir), 0.0);\n        float sky_dif = clamp(0.5 + 0.5 * dot(normal, vec3(0., 1., 0.)), 0., 1.);\n        float bou_dif = clamp(0.5 + 0.5 * dot(normal, vec3(0., -1., 0.)), 0., 1.);\n        \n        col = mate*vec3(7., 5., 3.) * sun_dif * sun_sha;\n        col += mate*vec3(0.5, .8, 0.9) * sky_dif;\n        col += mate*vec3(0.7, .3, 0.2) * bou_dif;\n    }\n    \n    \n    col = pow(col, vec3(0.4545));\n    \n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}