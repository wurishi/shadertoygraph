{"ver":"0.1","info":{"id":"WsfBRs","date":"1588829631","viewed":94,"name":"mood moon","username":"hclarke","description":"diffusion\ninspired by https://www.shadertoy.com/view/WsXBzl and the corresponding paper","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["2d","sdf","diffusion","montecarlo","pde"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const mat3 XYZ_to_RGB = mat3(\n    3.2406, -0.9689, 0.0557,\n    -1.5372, 1.8758, -0.2040,\n    -0.4986, 0.0415, 1.0570);\n\nconst vec3 D65_XYZ = vec3(.95047, 1.0, 1.08883);\nconst vec3 D65_xyY = vec3(0.31271, 0.32902, 1.0);\nconst vec3 D65_Yuv = vec3(1.0, 0.19784, 0.46834);\nconst vec3 ONE = vec3(1.0,1.0,1.0);\n\nvec3 XYZ_to_xyY(vec3 XYZ) {\n \tfloat inv_sum = 1.0/dot(XYZ,ONE);\n    return XYZ.xyy * vec3(inv_sum,inv_sum,1.0);\n}\n\nvec3 xyY_to_XYZ(vec3 xyY) {\n \tfloat s = xyY.z/xyY.y;\n    float z = 1.0-dot(vec2(1.0,1.0), xyY.xy);\n    return vec3(xyY.x, xyY.z, z) * vec3(s,1.0,s);\n}\n\nvec3 LUV_to_XYZ(vec3 LUV) {\n    vec2 uv = LUV.yz / (13.0*LUV.x) + D65_Yuv.yz;\n    float Y = LUV.x > 8.0 ? \n        D65_Yuv.x * pow((LUV.x+16.0)/116.0, 3.0) : \n    \tLUV.x * D65_Yuv.x * 0.00110705645;\n    float X = Y * 9.0 * uv.x / (4.0*uv.y);\n    float Z = Y * (12.0-3.0*uv.x-20.0*uv.y)/(4.0*uv.y);\n    return vec3(X,Y,Z);\n}\n\nvec3 XYZ_to_LUV(vec3 XYZ) {\n \tvec3 xyY = XYZ_to_xyY(XYZ);\n    float e = 0.008856;\n    float k = 903.3;\n    vec2 mul = vec2(4.0, 9.0);\n    float div = dot(XYZ, vec3(1.0, 15.0, 3.0));\n    \n    vec2 uv_ = XYZ.xy * mul / div;\n    float y_ = XYZ.y / D65_Yuv.x;\n    float L = y_ > e ? \n        116.0 * pow(y_, 1./3.) - 16. :\n\t\tk*y_;\n    return vec3(L, 13. * L * (uv_ - D65_Yuv.yz));\n\n}\n\nvec3 RGB_to_LUV(vec3 RGB) {\n \treturn XYZ_to_LUV(inverse(XYZ_to_RGB) * RGB);   \n}\n\nvec3 LUV_to_RGB(vec3 LUV) {\n \treturn XYZ_to_RGB * LUV_to_XYZ(LUV);   \n}\n\nvec3 LUV_to_HCL(vec3 LUV) {\n \tfloat H = atan(LUV.z, LUV.y);\n    float C = length(LUV.yz);\n    return vec3(H, C, LUV.x);   \n}\n\nvec3 HCL_to_LUV(vec3 HCL) {\n    float u = cos(HCL.x);\n    float v = sin(HCL.x);\n    vec2 uv = vec2(u,v);\n    return vec3(HCL.z, uv * HCL.y);\n}\n\nvec3 RGB_to_HCL(vec3 RGB) {\n \tvec3 LUV = RGB_to_LUV(RGB);\n    return LUV_to_HCL(LUV);\n}\n\nvec3 HCL_to_RGB(vec3 HCL) {\n \tvec3 LUV = HCL_to_LUV(HCL);\n    return LUV_to_RGB(LUV);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec4 col = texture(iChannel0, uv);\n\tvec3 c = col.xyz/col.w;\n    c = LUV_to_RGB(c);\n    // Output to screen\n    fragColor = vec4(c,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"int rand_key = 1;\nint rand_state = 0;\n\nint rand() {\n  int val = rand_state;\n\n  int x = val ^ rand_key;\n  x *= 0xad8c49f5;\n  rand_state = x;\n\n  val ^= val>>16;\n  return val & 0xffff;\n}\n\nvoid init(int key) {\n  rand_key = key;\n  rand_state = 123456;\n  rand();\n  rand();\n}\n\nvec2 onCircle() {\n \tfloat r = float(rand())/float(0xffff) * 3.14195 * 2.;\n    return vec2(sin(r), cos(r));\n}\n\nfloat sd_circle(vec2 p, float r) {\n \treturn length(p) - r;\n}\n\nvec4 sd_col(float sd, float w, vec3 neg, vec3 pos) {\n    return vec4(sd, mix(neg, pos, smoothstep(-w, w, sd)));\n}\n\nfloat sd_union(float a, float b) {\n \treturn a<b ? a : b;   \n}\n\nvec4 d_union(vec4 a, vec4 b) {\n \treturn abs(a.x) < abs(b.x) ? a : b;   \n}\nvec4 sd_union(vec4 a, vec4 b) {\n \treturn a.x < b.x ? a : b;   \n}\n\nvec4 scene(vec2 p) {\n    vec3 ca = vec3(85., 20., 80.);\n    vec3 cb = vec3(85., -5., -50.);\n    vec2 o = vec2(sin(iTime*0.2) * 0.9, 0.);\n    vec4 cA = sd_col(sd_circle(p-o, 0.8), 0.001, ca, cb);\n    vec4 cB = sd_col(sd_circle(p+o, 0.8), 0.001, cb, ca);\n    vec4 res = d_union(cA, cB);\n    return res;\n}\n\nvec3 march(vec2 p) {\n    for(int i = 0; i < 32; ++i) {\n    \tfloat d = scene(p).x;\n        p += d * onCircle() * 0.5;\n    }\n    return scene(p).yzw;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int x = int(fragCoord.x);\n    int y = int(fragCoord.y);\n    init(x + y * int(iResolution.x) + iFrame * int(iResolution.x*iResolution.y));\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    vec4 prev = texture(iChannel0, uv);\n    \n    \n    vec4 c = prev * 0.97;\n    for(int i = 0; i < 4; ++i) {\n        c += vec4(march(p),1.);\n    }\n    fragColor = c;\n}","name":"Buffer A","description":"","type":"buffer"}]}