{"ver":"0.1","info":{"id":"stByRG","date":"1649887442","viewed":207,"name":"Hello Saturn","username":"Eltaurus","description":"mouse - move around\nspace - toggle flying","likes":9,"published":1,"flags":48,"usePreview":0,"tags":["space"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//input const\nconst float fov0=40.; //hoizontal fov, degrees\nconst vec3 l1=vec3(cos(radians(4.)),0,sin(radians(4.))); //light direction\nconst vec4 sphere[2] = vec4 [2] (vec4(0,0,0,1),vec4(2,1.5,0,.12)); // c(vec3),r\nconst vec3 n2=vec3(0,0,1); const vec2 rR=vec2(1.5,2.2); //rings (center coincides with sphere[0])\nconst int SSAA=4; //number of subsambples along each axis \n\n\n//system const\nconst float pi=radians(180.);\nconst float fov=2.*tan(radians(fov0)*.5);\nconst float e=1e-4; // precision -- increase to ~1e-2 in case of bugging shadows\n\n\n#define load(P) texelFetch(iChannel0, ivec2(P), 0)\nconst ivec2 EULEROLD = ivec2(2, 2);\nconst ivec2 EULER = ivec2(2, 1);\n\n\nmat3 RM(float psi, float theta) {\n\n    \n    float cX = cos(theta);\n    float sX = sin(theta);\n    float cZ = cos(psi);\n    float sZ = sin(psi);\n    \n    return \n  mat3( \n         cZ, sZ, 0, //wtf\n        -sZ, cZ, 0,\n          0,  0, 1\n)*mat3(\n        1,   0,  0,\n        0,  cX, sX,\n        0, -sX, cX\n      );\n}\n\n\n//struct sphere ...\n\nvec4 TraceRay(inout vec3 o, in vec3 p)\n{\n vec4 col = vec4(0,0,0,-1); //col.a = distance\n vec3 P=l1*1e4,n;\n float a,d,hchord,perp;\n \n \n //spheres intercetion test\n for (int i=0;i<(sphere.length());++i) {\n float m=float(i);\n\n    vec3 center=sphere[i].xyz;\n    float incl=radians(15.);\n    center=center*cos(.1*iTime)+length(center)*vec3(-.6*cos(incl),.8*cos(incl),sin(incl))*sin(.1*iTime);\n    \n    a = length(cross(center-o,p)); \n     \n     if (a<sphere[i].w) {\n     \n         perp=dot(center-o,p);\n         hchord=sqrt(pow(sphere[i].w,2.)-pow(a,2.));\n         d=perp-hchord; if (d<e) {d=perp+hchord;}\n            \n         if (e<d && (d<col.a || col.a<0.)) { \n             P=o+d*p; //surface point\n             n=normalize(P-center); //surface normal\n             col=vec4(0.5+.4*m)*dot(n,l1); //color with lambert shading             \n             if (i==0) {col*=texelFetch(iChannel1, ivec2(0,.1*iResolution.y*(P.z+1.+.0025*smoothstep(.5,.9,P.z)*sin(6.*atan(P.y,P.x)))), 0);} //planet texture\n             col.a=d; //z-buffer\n         }            \n     }\n }\n \n //rings intersection test\n a= dot(p,n2);\n \n if (abs(a)>e){\n     d=dot(sphere[0].xyz-o,n2)/a; vec3 P1=o+d*p;\n         if (e<d && (d<col.a || col.a<0.) && rR.x<length(P1) && rR.y>length(P1)) { \n             P=P1; //surface point\n             col=vec4(.25); //color without lambert shading             \n             col*=texelFetch(iChannel1, ivec2(0,.25*iResolution.y*length(P)), 0);//ring texture\n             col.a=d; //z-buffer\n         }  \n }\n \n \no=P; // reposition ray origin for shadow tracing\nreturn col;\n\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  //  display buffer B\n  //  fragColor=texelFetch(iChannel1, ivec2(fragCoord), 0);return;\n\n    vec2 comp = (fragCoord-.5*iResolution.xy)/iResolution.x; //comp space x: [-.5,.5], y ...\n    \n    \n    vec4 euler=load(EULER);\n    float psi=euler.x;\n    float theta=euler.y;\n    mat3 M=RM(psi,theta);\n    \n    \n    float ii,jj;\n    vec3 O0=M*vec3(0,0,10),O,V;\n    vec2 spv;//subpixel vector\n    fragColor=vec4(0);\n    \n    \n    for (int i=0;i<SSAA;++i) {\n    for (int j=0;j<SSAA;++j) { //supersampling loops\n          \n    O=O0;\n    spv=((2.*vec2(i,j)+1.)/float(SSAA)-1.)/(2.*iResolution.x);\n    V=M*normalize(vec3(0,0,-1)+fov*vec3(comp+spv,0));   \n    fragColor+=clamp(TraceRay(O,V),0.,1.)*step(0.,-TraceRay(O,l1).w);\n     \n    }}\n    \n    fragColor/=pow(float(SSAA),2.);\n}\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// bits of code from https://www.shadertoy.com/view/4lVXRm by genis sole\n#define store(P, V) if (all(equal(ivec2(fragCoord), P))) fragColor = V\n#define load(P) texelFetch(iChannel0, ivec2(P), 0)\n//\n\n\nconst ivec2 EULEROLD = ivec2(2, 2);\nconst ivec2 EULER = ivec2(2, 1);\nconst float sensitivity=.003;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ipx=ivec2(fragCoord);\n    if ((ipx!=EULEROLD)&&(ipx!=EULER)) discard;\n    \n    vec4 eulerold=load(EULEROLD);\n    vec4 euler=load(EULER); \n\n\n    if (iMouse.z>0.){\n    euler=eulerold+sensitivity*vec4(vec2(1,-1)*(abs(iMouse.zw)-iMouse.xy),0,0);\n    } else {\n    eulerold=euler;\n\n    // toggle fly\t\n    if (texelFetch( iChannel1, ivec2(32,2),0).x>0. ) {\n        euler+=vec4(0.005,0.005,0,0);\n        }\n    } \n    \n    if (iFrame==0) {\n    euler=radians(60.)*vec4(1,1,0,0);\n    }\n    \n    \n    \n    store(EULER, euler);  \n    store(EULEROLD, eulerold);\n\n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void logistic (inout float x) {\nfloat k=3.99;\nx=k*x*(1.-x);\n}\n\nfloat nest(float x0) {\nint iter=15;\nfloat x=x0;\nfor (int i=0;i<iter;i++) {logistic (x);}\nreturn x;\n}\n\nfloat tex(float y,float scale) {\n\nfloat y1=y/scale;\nfloat t1=nest(floor(y1)/iResolution.y);\nfloat t2=nest(ceil(y1)/iResolution.y);\n\nreturn t1+(t2-t1)*smoothstep(floor(y1),ceil(y1),y1);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.x>1.) discard;\n\n        \n    fragColor = .3+.6*(\n                .99*vec4(tex(fragCoord.y,50.))+\n                .8*vec4(tex(fragCoord.y,20.))+\n                .6*vec4(tex(fragCoord.y,5.))+\n                .2*vec4(tex(fragCoord.y,1.)));\n                \n}","name":"Buffer B","description":"","type":"buffer"}]}