{"ver":"0.1","info":{"id":"XdtSzs","date":"1461060239","viewed":390,"name":"CRT Overlay/Distortion/FX","username":"DissonantGuile","description":"Looks like an old CRT monitor","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926535\n#define GOLDEN_ANGLE 2.399963229728653\n\n// TODO:\n// * Actual scanlines\n// * Powering animation\n// * Move movement in the Y tracking\n\n\n// Future Uniforms\n\nconst float overlayBrightnessFactor = 2.5;\nconst float overlayCurvePower = 0.75; // Closer to 0 = more rectangular.\n\nconst float scanlineDivisor = 3.0;\nconst float scanlineBrightnessFactor = 0.5;\n\nconst float distortionPower = 1.1; // 1.0 is normal, < 1.0 is concave and > 1.0 is convex\nconst float distortionCurvePower = 1.0; // Closer to 0 = more rectangular.\n\nconst float trackingProgressFactor = 10.0;\nconst float trackingProgressPower = 5.0;\n\nconst float poweringThresholdU = 0.75;\nconst float poweringFactorU = 2.5;\nconst float poweringThresholdV = 0.5;\nconst float poweringFactorV = 0.15;\nconst float poweringBrightnessFactor = 1.5;\nconst float poweringBrightnessPower = 3.0;\n\n// Forward Declarations\n\nvec2  convertPolarToCartesian(vec2 uv);\nvec2  convertCartesianToPolar(vec2 uv);\nvec4  calculateOverlayColor(vec2 uv);\nvec4  calculateScanlineColor(vec2 uv);\nvec2  calculateBarrelDistortion(vec2 uv, float power); \nvec2  calculateTrackingOffset(vec2 uv, float progress);\nfloat calculatePoweringDistortion(float x, float progress, float threshold, float smoothness);\nvec2  calculatePoweringDistortion(vec2 uv, float progress);\nvec4  calculatePoweringBrightness(vec4 color, float progress);\n\n// Functions\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float trackingProgress = mod(iTime / 10.0, 1.0);\n    float poweringProgress = pow(cos(trackingProgress * PI), 100.0);\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n\tvec4 overlayColor = calculateOverlayColor(uv);\n    vec4 scanlineColor = calculateScanlineColor(uv);\n    \n    // DEBUGGING\n    overlayColor = vec4(1.0);\n    scanlineColor = vec4(0.0);\n    \n    uv = calculateBarrelDistortion(uv, distortionPower);\n    //uv = calculateTrackingOffset(uv, trackingProgress);\n        \n    vec4 sampleColor = texture(iChannel0, uv);\n    uv = convertCartesianToPolar(uv);\n    \n    fragColor = (sampleColor * overlayColor) - scanlineColor;\n    //fragColor = vec4(uv.x);\n}\n\nvec2 convertCartesianToPolar(vec2 uvCartesian) { \n\tvec2 uvDisplacement = uvCartesian - vec2(0.5);\n\tfloat radius = length(uvDisplacement);\n\tfloat angle = atan(uvDisplacement.y, uvDisplacement.x);\n    \n    return vec2(radius, angle);\n}\n\n// X is radius and Y is angle\nvec2 convertPolarToCartesian(vec2 uvPolar) { \n    vec2 uvCartesian;\n    \n    uvCartesian.x = 0.5 + uvPolar.x * cos(uvPolar.y);\n    uvCartesian.y = 0.5 + uvPolar.x * sin(uvPolar.y);\n    \n    return uvCartesian;\n}\n\n// Calculate the overlay color for the current fragment\nvec4 calculateOverlayColor(vec2 uv) {\n    float value = pow(sin(uv.x * PI) * sin(uv.y * PI), overlayCurvePower) * overlayBrightnessFactor;\n    \n\treturn vec4(value, value, value, 1.0);\n}\n\n// Calculate the scanline color for the current fragment\nvec4 calculateScanlineColor(vec2 uv) {\n    float value = floor(mod(uv.y * iResolution.y / scanlineDivisor, 1.0) + 0.5) * scanlineBrightnessFactor;\n    \n\treturn vec4(value);\n}\n\n// Calculate the barrel distortion UV offset.\nvec2 calculateBarrelDistortion(vec2 uvCartesian, float power) {\n    vec2 uvPolar = convertCartesianToPolar(uvCartesian);\n    \n    //uvPolar.x = 1.0 - pow(sin(uvCartesian.x * PI) * sin(uvCartesian.y * PI), distortionCurvePower);\n    uvPolar.x = pow(uvPolar.x, power);\n    //uvPolar.x = 2.84 * sin(uvPolar.y/PI);\n    \n    uvCartesian = convertPolarToCartesian(uvPolar);\n    \n    return uvCartesian;\n}\n\n// Calculate the tracking UV offset\nvec2 calculateTrackingOffset(vec2 uv, float progress) {\n  return vec2( uv.x, mod(uv.y + max(0.0, 1.0 - pow(progress * trackingProgressFactor, trackingProgressPower)), 1.0) );\n}\n\n// Displacement formula:\n//   ( (x-0.5) / (1 - (1 - max(p^s, t)) / (1-t) ) ) + 0.5\n//\n// x is coordinate\n// p is progress (percent complete/100)\n// t is threshold to start displacement\n// s is exponential smoothness\nfloat calculatePoweringDistortion(float x, float progress, float threshold, float smoothness) {\n  return ( (x - 0.5) / ( ( (1.0 - max( pow(progress, smoothness), threshold) ) / (1.0 - threshold) ) ) ) + 0.5;\n}\n\nvec2 calculatePoweringDistortion(vec2 uv, float progress) {\n  float sampleU = calculatePoweringDistortion(uv.x, progress, poweringThresholdU, poweringFactorU);\n  float sampleV = calculatePoweringDistortion(uv.y, progress, poweringThresholdV, poweringFactorV);\n\n  return vec2(sampleU, sampleV);\n}\n\n// Brightness formula:\n//\n//   vec c = vec c + vec c p s\n//\n// p is progress (percent complete/100)\n// s is brightness factor\nvec4 calculatePoweringBrightness(vec4 color, float progress) {\n  return color + (color * pow(progress, poweringBrightnessPower) * poweringBrightnessFactor);\n}\n","name":"Image","description":"","type":"image"}]}