{"ver":"0.1","info":{"id":"WdjGzV","date":"1549439162","viewed":500,"name":"Blob slice","username":"skaplun","description":"Trying to mimic the @zachlieberman's animation\nhttps://twitter.com/zachlieberman/status/1090994823245582338\nStill lot to do. In some reason the noise has discontinues when angle â‰ˆ 0. Could anybody help with this?","likes":31,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","noise","perlin","animation","blob","slice","polar","gradientnoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define UP vec3(0., -1., 0.)\n#define EPS .00001\n#define AA (10./iResolution.y)\n#define PI 3.14159265359\n#define TAU (2.*PI)\n#define PTNTS_CNT 3\n\nstruct Ray{vec3 origin, dir;};\nstruct HitRecord{float dist; vec3 point; vec3 normal;};\nstruct Plane{vec3 origin, normal;};\n\n//noise by iq\nfloat noise(in vec3 x){\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat remappedNoise(in vec3 p){\n\treturn .5 + .5 * (noise(p)/.6);\n}\n    \nbool plane_hit(in Ray inray, in Plane plane, out float dist) {\n    float denom = dot(plane.normal, inray.dir);\n    if (denom > 1e-6) {\n        vec3 p0l0 = plane.origin - inray.origin;\n        float t = dot(p0l0, plane.normal) / denom;\n        if(t >= EPS){\n\t\t\tdist = t;\n            return true;\n        }\n    }\n    return false;\n}\n    \nbool hit(in Ray inray, in Plane top, out float dist){\n    return plane_hit(inray, top, dist);\n}\n    \nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.;\n    float z = size.y / tan(radians(fieldOfView) / 2.);\n    return normalize(vec3(xy, -z));\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye),\n         s = normalize(cross(f, up)),\n         u = cross(s, f);\n    return mat4(vec4(s, 0.), vec4(u, 0.), vec4(-f, 0.), vec4(vec3(0.), 1.));\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nconst vec2[PTNTS_CNT] points = vec2[PTNTS_CNT](vec2(-2., 0.), vec2(0., -3.), vec2(2., 0.));\nfloat calcClr(in Ray ray){\n    float dist;\n    for(float i=0.; i>-10.; i-=.15){\n    \tif (hit(ray, Plane(vec3(0., i, 0.), UP), dist)) {\n    \t    float time = iTime + i * .25;\n            vec3 p = ray.origin + ray.dir * dist;\n            p *= rotateY(remappedNoise(vec3(time * 1.5)));\n            \n            for(float j=0.; j<float(PTNTS_CNT); j++){\n            \tfloat noisedRad = remappedNoise(vec3(time * 1.78 + j))\n                \t\t\t\t+ noise(vec3(p.xy + j * .25, time));\n                float l = distance(p.xz, points[int(j)]);\n                if(l < noisedRad)\n             \t   return smoothstep(.0125 + AA, .0125, abs(noisedRad - l - AA));\n            }\n        }\n    }\n    return 0.;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(7.+sin(iTime), 7., 7. + cos(iTime));\n    mat4 viewToWorld = viewMatrix(eye, vec3(1., sin(iTime) - .5, 0.), normalize(vec3(.25 + .25 * noise(vec3(iTime)), 1., 0.)));\n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.)).xyz;\n    \n    float dist;\n    Ray r = Ray(eye, worldDir);\n    fragColor = vec4(vec3(calcClr(r)), 1.);\n}","name":"Image","description":"","type":"image"}]}