{"ver":"0.1","info":{"id":"llVyRy","date":"1536849811","viewed":350,"name":"Cracks worley","username":"reven86","description":"Cracks","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","worley","pattern","cracks"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// modification of\n// https://www.shadertoy.com/view/MstGRl\n// https://www.shadertoy.com/view/MtXfDf\n\n\n// Determines how many cells there are\n#define NUM_CELLS 20.0\n\n// Arbitrary random, can be replaced with a function of your choice\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy, vec2(.24, 1.023))) * 330.5453);\n}\n\n#define MOD3 vec3(443.8975,397.2973, 491.1871)\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\nvec2 get_cell_point(vec2 cell) {\n    return (cell + hash22(cell)) / NUM_CELLS;\n}\n\n// Performs worley noise by checking all adjacent cells\n// and comparing the distance to their points\nfloat worley(vec2 coord) {\n    vec2 cell = floor(vec2(coord * NUM_CELLS));\n    float dist = 1.0;\n    vec2 dist_cell;\n    vec2 dist2_cell;\n    \n    for (int x = -1; x <=1; x++) { \n        for (int y = -1; y <=1; y++) {\n        \tvec2 cell_point = get_cell_point(cell + vec2(x, y)) - coord;\n            float len = dot(cell_point, cell_point);\n            if (len < dist)\n            {\n                dist = len;\n                dist_cell = cell_point;\n            }\n        }\n    }\n\n    dist = 1.0;\n    float dist2 = 1.0;\n    for (int x = -1; x <=1; x++) { \n        for (int y = -1; y <=1; y++) {\n        \tvec2 cell_point = get_cell_point(cell + vec2(x, y)) - coord;\n\n            dist2_cell = cell_point;\n            vec2 n = dist2_cell - dist_cell;\n            float nlenSq = dot(n, n);\n            dist = min(dist, (dot(n, dist_cell + dist2_cell) / nlenSq) * (0.3 + dist * 2.55));\n        }\n    }\n    \n    //dist *= NUM_CELLS * NUM_CELLS;\n    dist = smoothstep(4.*NUM_CELLS/iResolution.x, 8.*NUM_CELLS/iResolution.x, dist);\n    \n    return dist;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.x;\n\tfragColor = vec4(worley(uv));\n}","name":"Image","description":"","type":"image"}]}