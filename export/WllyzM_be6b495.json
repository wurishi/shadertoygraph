{"ver":"0.1","info":{"id":"WllyzM","date":"1616536058","viewed":221,"name":"Visualizing formulas","username":"LilBensson","description":"My math teacher wanted to render a graph based on an equation that she had found of a heart. I made this shader using the equation and she ended up liking it so much that she printed and framed a screenshot of it! :D","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","math","heart"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Equation: (x^2 + 9/4 * y^2 + z^2 - 1)^3 - x^2 * z^3 - 9/80 * y^2 * z^3 = 0   \n//           (-3 <= x, y, z <= 3)\n\n\n// Renderer 0: ray marching using constant small steps instead of SDF\n// Renderer 1: visualizing 2D-slices of a 3D-graph\n#define renderer 0\n\n\n// (For renderer 0)\n// Quality 0: low\n// Quality 1: medium\n// Quality 2: high\n#define quality 1\n\n\n// Renderer 0 is my second attempt and works by marching along the ray and \n// plugging the coordinates into the equation to see if the result is close enough \n// to the expected result. It's not very efficient since there need to be a \n// big number of steps, the step size and \"hit bias\" need to be fairly small \n// to get a good enough respresentation of the graph. \n// But hey, it works!\n\n// Renderer 1 is my first attempt at rendering the equation. It simply treats the 3D graph\n// as if it's 2D and stacks \"slices\" of the graph on top of eachother. It didn't look too great\n// since it could never render a true surface, but an interesting experiment nonetheless.\n\n\n#if renderer == 0\n\nfloat GetGraphDist(vec3 p)\n{\n    // Switch Y and Z\n    p = p.xzy;\n    \n    // Equation: (x^2 + 9/4 * y^2 + z^2 - 1)^3 - x^2 * z^3 - 9/80 * y^2 * z^3 = 0\n    // -3 <= x,y,z <= 3\n    float m = (p.x*p.x) + (9.0/4.0 * p.y*p.y) + (p.z*p.z) - 1.0;\n    float d = m*m*m - \n        (p.x*p.x * p.z*p.z*p.z) - \n        (9.0/80.0 * p.y*p.y * p.z*p.z*p.z);\n    \n    return d;\n}\n\nvec3 Arrow(vec3 rayOrigin, vec3 rayDirection, vec3 newP, float offset, float invTip)\n{\n    const float arrowThickness = 0.3;\n\n    // Move arrow position\n\tnewP.z += 2.3 + offset;\n    \n    // Center position\n    newP.x -= 0.025;\n    \n    // See if intersection point lays within the arrow\n    if(abs(newP.x / newP.z) <= arrowThickness && \n       newP.z * 8.0/3.0 * invTip <= 1.0 && \n       newP.z * invTip >= 0.0)\n    {\n        return vec3(0.0);\n    }\n    \n    return vec3(1.0);\n}\n\nvec3 AllArrows(vec3 rayOrigin, vec3 rayDirection)\n{\n\tvec3 col = vec3(1.0);\n    \n    // 2 arrows in xz-plane\n\tfloat t = (0.0 - rayOrigin.y) / rayDirection.y;\n    vec3 newP = rayOrigin + t * rayDirection;\n    col *= Arrow(rayOrigin, rayDirection, newP.xyz, 0.3, 1.0);\n    col *= Arrow(rayOrigin, rayDirection, newP.zyx, 0.0, 1.0);\n    \n    // 1 arrow in yz-plane\n\tt = (0.0 - rayOrigin.z) / rayDirection.z;\n    newP = rayOrigin + t * rayDirection;\n    col *= Arrow(rayOrigin, rayDirection, newP.xzy, -4.6, -1.0);\n    \n    return col;\n}\n\nvec3 AllAxes(vec3 rayOrigin, vec3 rayDirection)\n{\n    float thickness = 0.05;\n\n    // X-axis\n    float ty = (0.0 - rayOrigin.y) / rayDirection.y;\n    vec3 newPy = rayOrigin + ty * rayDirection;\n    if(newPy.x <= 2.0 && newPy.x >= -2.0 && newPy.z <= 0.0 && newPy.z >= -thickness)\n    {\n        return vec3(0.0);\n    }\n\n    // Y-axis\n    float tz = (0.0 - rayOrigin.z) / rayDirection.z;\n    vec3 newPz = rayOrigin + tz * rayDirection;\n    if(newPz.x <= thickness && newPz.x >= 0.0 && newPz.y <= 2.0 && newPz.y >= -2.0)\n    {\n        return vec3(0.0);\n    }\n\n    // Z-axis\n    ty = (0.0 - rayOrigin.y) / rayDirection.y;\n    newPy = rayOrigin + ty * rayDirection;\n    if(newPy.x <= thickness && newPy.x >= 0.0 && newPy.z <= 2.0 && newPy.z >= -2.5)\n    {\n        return vec3(0.0);\n    }\n    \n    return vec3(1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // High\n#if quality == 2\n\n    // Extreme values for a good quality\n    const float STEP_SIZE = 0.001;\n    const float MAX_NUM_STEPS = 4400.0;\n    const float HIT_DIST = 0.000001;\n   \n   \n    // Medium\n#elif quality == 1\n\n    const float STEP_SIZE = 0.003;\n    const float MAX_NUM_STEPS = 2200.0;\n    const float HIT_DIST = 0.000001;\n\n\n    // Low\n#else\n\n    const float STEP_SIZE = 0.01;\n    const float MAX_NUM_STEPS = 1000.0;\n    const float HIT_DIST = 0.0001;\n\n#endif\n    \n    vec2 uv = (fragCoord.xy - iResolution.xy*0.5)/iResolution.y;\n\n    // Camera setup\n    vec3 camOrigin = vec3(1.0 + sin(iTime)*0.1, 2.0, -4.0) * 0.95;\n    vec3 camLookAt = vec3(0.0, 0.4, 0.0);\n    \n    vec3 camForward = normalize(camLookAt - camOrigin);\n    vec3 camRight = normalize(cross(camForward, vec3(0.0, 1.0, 0.0)));\n    vec3 camUp = normalize(cross(camRight, camForward));\n    \n    float zoom = 1.0;\n    vec3 rayOrigin = camOrigin + camForward * zoom + camRight * uv.x + camUp * uv.y;\n    vec3 rayDirection = normalize(rayOrigin - camOrigin);\n    \n    \n    vec3 col = vec3(1.0);\n    vec3 p = rayOrigin;\n    \n    // Start ray marching\n    for(float i = 0.0; i <= MAX_NUM_STEPS; i += 1.0)\n    {\n        float currDist = GetGraphDist(p);\n        \n        if(currDist <= HIT_DIST)\n        {\n            // Shade\n            vec3 n = normalize(p);\n            vec3 l = normalize(vec3(-0.4, -1.0, 3.0));\n            col = vec3(1.0, 0.0, 0.0) * max(dot(n, -l), 0.2);\n            \n            // Lines on the heart\n            float rps = 6.0;\n            p.z += 0.03;\n            vec3 rp = round(p*rps);\n            vec3 diff = abs(p*rps-rp);\n            float size = 0.03;\n            \n            if(diff.x < size || diff.y < size || diff.z < size)\n                col = vec3(0.0);\n            \n            break;\n        }\n        \n        // March\n        p += rayDirection * STEP_SIZE;\n        \n        \n        // Make sure the point is within the bounding box\n        if(abs(p.x) > 3.0 || abs(p.y) > 3.0 || abs(p.z) > 3.0)\n            break;\n    }\n\t\n    // Move axes back a bit\n    rayOrigin += vec3(0.0, 0.0, -0.4);\n\t\n    // Render axes and arrows\n    col *= AllAxes(rayOrigin, rayDirection);\n    col *= AllArrows(rayOrigin, rayDirection);\n\n    fragColor = vec4(col, 1.0);\n}\n\n#else\n\nmat2x2 rot(float angle)\n{\n    float cosT = cos(iTime);\n    float sinT = sin(iTime);\n    \n\treturn mat2x2(vec2(sinT, cosT), vec2(-cosT, sinT));\n}\n\nvec3 GetSlice(vec2 uv, float z, float index)\n{\n    index -= 0.5;\n    \n    mat2x2 transform = rot(iTime);\n    uv.y *= 2.0;\n    uv *= transform;\n    \n    // Equation: (x^2 + 9/4 * y^2 + z^2 - 1)^3 - x^2 * z^3 - 9/80 * y^2 * z^3\n    float m = (uv.x*uv.x) + (9.0/4.0 * uv.y*uv.y) + (z*z) - 1.0;\n    float d = m*m*m - \n        (uv.x*uv.x * z*z*z) - \n        (9.0/80.0 * uv.y*uv.y * z*z*z);\n    float r = 0.0;\n    float t = 0.0001 * (index * index * 1000.0 - 0.08);\n    if(d < r+t && d > r-t)\n        return vec3(1.0);\n    \n    return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - iResolution.xy*0.5)/iResolution.y;\n\n    uv *= 5.0;\n    uv.y *= 1.5;\n    \n    float s = 8.0;\n    int numSlices = 200;\n    \n    // Render slices\n    vec3 col = vec3(0.0);\n    for(float i = 0.0; i <= 1.0; i += 1.0/float(numSlices))\n    {\n        // Gradient\n        vec3 c = vec3(i, 1.0-i, 0.0);\n        c = vec3(1.0, i, 1.0 - i);\n        \n    \tcol += GetSlice(vec2(uv.x, uv.y - (i-0.5)*s), (i-0.5)*5.0, i) * c;\n    }\n\n    fragColor = vec4(col,1.0) * (length(uv));\n}\n\n#endif\n\n\n","name":"Image","description":"","type":"image"}]}