{"ver":"0.1","info":{"id":"ft3BW4","date":"1663072757","viewed":107,"name":"{boldo} simple grid","username":"boldo","description":"simple rotating and moving grid","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["simple"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265\n\nmat2 rot(float a) {\n   float s=sin(a), c=cos(a);\n   return mat2(c,s,-s,c);\n}\n\nfloat hash21(vec2 p) {\n    p = fract(p * vec2(123.21, 552.53));\n    p += dot(p, p+34.21);\n    return fract(p.x * p.y);\n}\n\nvec2 hash22(vec2 p) {\n   vec3 p3 = fract(vec3(p.xyx) * vec3(231.23,423.24, 521.23));\n   p3 += dot(p3, p3.yzx + 23.42);\n   return fract((p3.xx + p3.zy) * p3.zy);\n}\n\nfloat fadeCircle(vec2 gv, float spread) {\n    vec2 p = gv * spread;\n    return 1.0/dot(p,p);\n}\n\nfloat circle(vec2 gv, float spread) {\n    return step(length(gv), spread);\n}\n\n/*\n       .P\n      /|\n   pa/ |(pa - ba*h)\n    /  |\n   A---X-----------B\n   |---|   ba\n     h \n     \n   The dot product (pa,ba) projects pa onto ba and normalizes with the length of ba.\n*/\nfloat distanceFromLine( in vec2 a, in vec2 b, in vec2 p) {\n    vec2 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa,ba) / dot(ba,ba), 0., 1.);\n    \n\treturn length(pa - ba * h);\n}\n\nfloat distanceFromWave( in vec2 a, in vec2 b, in vec2 p) {\n    vec2 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa,ba) / dot(ba,ba), 0., 1.);\n    float invH = sign(dot(vec2(-pa.y, pa.x), ba));\n\treturn length(pa - ba * h) + invH * 0.1 * sin(PI * h * 1.0) * sin(PI * h * 16.0);\n}\n\nvec2 getPos(vec2 id, vec2 gv) {\n    vec2 o = hash22(id) * .2;\n    return gv - (o + o * vec2(sin(iTime), cos(iTime)) * .8);\n}\n\nvec2 getPos(vec2 id) {\n    vec2 o = hash22(id) * .2;\n    return id + o + o * vec2(sin(iTime), cos(iTime)) * .8;\n}\n\nfloat layer(vec2 uv, float scale, float angularSpeed) {\n    uv += vec2(sin(iTime * 0.1), cos(iTime * 0.2));\n    \n    uv *= rot(iTime * angularSpeed);\n    uv *= scale;\n    \n    /*\n    float ripples = 0.03 * sin(iTime * 0.2);\n    vec2 distort = uv * scale - scale/2.0;\n    float v = sin(sqrt(distort.x*distort.x + distort.y * distort.y) + iTime + 1.0);\n    distort = vec2(sin(PI*v*ripples),cos(PI*v*ripples));\n    uv += distort;\n    */\n    \n    //local uv within the grid cell (gv)\n    vec2 gv = fract(uv) -.5;\n    //id (row/col) of current cell\n    vec2 id = floor(uv);\n    //the circle\n    //float d = circle(getPos(id, gv), 0.05);\n    float d = fadeCircle(getPos(id, gv), 30.0);\n    //lines from position of circle in cell id to cell id+(x,y)\n    d += smoothstep(.05, .02, distanceFromWave(getPos(id), getPos(id+vec2(1.0, 0.0)),  id + gv));\n    d += smoothstep(.05, .02, distanceFromWave(getPos(id), getPos(id+vec2(-1.0, 0.0)),  id + gv));\n    d += smoothstep(.05, .02, distanceFromWave(getPos(id), getPos(id+vec2(0.0, 1.0)),  id + gv));\n    d += smoothstep(.05, .02, distanceFromWave(getPos(id), getPos(id+vec2(0.0, -1.0)),  id + gv));\n    \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5 * iResolution.xy)/iResolution.y;\n    \n    float d = layer(uv, 5.0 + sin(iTime * 0.3), 0.1);\n    \n    //second layer with different opacity...\n    d+= layer(uv, 5.0 + sin(iTime * 0.4), 0.05) * 0.5;\n     \n    vec3 col = vec3(d * (0.5 + sin(iTime * 0.5) * 0.5),\n                    d * (0.5 + cos(iTime * 0.3) * 0.5),\n                    d * (0.5 + sin(1.5 + iTime * 0.4) * 0.5));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}