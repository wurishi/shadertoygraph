{"ver":"0.1","info":{"id":"4fX3Ws","date":"1703654285","viewed":65,"name":"KyleWard_Demo","username":"KyleWard","description":"test","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926\n\n// 圆柱sd函数\nfloat sdCylinder(in vec3 pos, in float r){\n    return length(pos.xz) - r;\n}\n// 球sd函数\nfloat sdBall(in vec3 pos, in float r){\n    return length(pos) - r;\n}\n// 长方体sd函数（仅限制了xz坐标，y方向无限延伸）\nfloat sdBox(in vec2 pos, in vec2 r){\n    return length(max(abs(pos) - r, 0.0));\n}\n// 长方体sd函数\nfloat sdBox(in vec3 pos, in vec3 r){\n    return length(max(abs(pos) - r, 0.0));\n}\n\n// 计算旋转矩阵\nmat2 rot(float angle){\n    float vcos= cos(angle);\n    float vsin = sin(angle);\n    return mat2(vcos, -vsin, vsin, vcos);\n}\n\n// 材质，可实现不同部位不同颜色\nstruct material{\n    float d;\n    float id;\n    vec3 col;\n    vec3 pos;\n    //其他不同的信息，读者可以自行添加。\n};\n\n\n\n\n\n\n\nfloat smax(in float a, in float b, in float k){\n    float h = max(k - abs(a - b), 0.0);\n    return max(a, b) + (0.25/k) * h * h;\n}\n// 齿轮中心交叉轴sd函数\nfloat sdCross(in vec3 p, in vec3 r){\n    p = abs(p);\n    p.xz = (p.z > p.x) ? p.zx : p.xz;\n    return sdBox(p.xyz, r);\n}\n// 连接相对齿轮的sd函数\nfloat sdVStick(in vec3 p, in float h){\n    float d = max(p.y-h, 0.0);\n    return sqrt(p.x * p.x + p.z * p.z + d * d);\n}\nvec2 rot45(in vec2 v){\n    return vec2(v.x + v.y, v.x - v.y) * 0.707107;\n}\n\n\nvec3 color = vec3(1.0, 1.0, 1.0);\n\nmaterial gear(in vec3 pos, in float time, in float offset, in float re){\n    material mat;\n    \n    float rot_angle = (time * sign(pos.y) + offset * PI / 12.0) * re;\n    pos.xz = rot(rot_angle) * pos.xz;\n    \n    pos.y = abs(pos.y);\n    float basic = PI / 6.0;  // 沿y轴的旋转角度单位\n    float sector = round(atan(pos.z, pos.x) / basic);  // 根据pos的实际位置划分sector\n    float angle = sector * basic;\n    vec3 q = pos;\n    q.xz = rot(angle) * q.xz;  // 分别得到每个长方体的专属坐标轴\n\n    // 在（0.17， 0.0）处生成0.08 * 0.036，y方向无限延伸的长方体 \n    float bs = sdBox(q.xz - vec2(0.17, 0.0), \n                            vec2(0.04, 0.018)) - 0.01;  // 作圆滑处理\n    // 在（0.0， 0.0）处生成 r = 0.155，向外向内拓宽0.018，y方向无限延伸的圆柱\n    float cy = abs(sdCylinder(pos, 0.155)) - 0.018;\n    // 生成齿轮的交叉杆\n    float cs = sdCross(pos-vec3(0.0, 0.5, 0.0), vec3(0.15, 0.005, 0.005)) - 0.003;\n    // 生成连接上下齿轮的棍子\n    float sk = sdVStick(pos, 0.5) - 0.01;\n    // 限制棍子长度，y 取值 [-0.5, 0.5]\n    sk = max(sk, abs(pos.y) - 0.5);\n    \n    if(bs <= 0.001){\n        // mat.id = 1.0;\n        // mat.col = color;\n    }\n    if(cy <= 0.001){\n        // mat.id = 2.0;\n        // mat.col = color;\n    }\n    if(cs <= 0.001){\n        // mat.id = 3.0;\n        // mat.col = color;\n    }\n    if(sk <= 0.001){\n        // mat.id = 4.0;\n        // mat.col = color;\n    }\n    bs = min(bs, cy);\n    bs = min(bs, cs);\n    \n    // 用半径0.5，厚度为0.06的球壳去切割上述图形，得到独立的上下齿轮\n    float r = length(pos);\n    bs = smax(bs, abs(r - 0.5) - 0.03, 0.005);\n    \n    // 连接棍子\n    bs = min(bs, sk);\n    mat.d = bs;\n    return mat;\n}\n\nmaterial map(in vec3 pos, in float time){\n    material mat_1 = gear(pos.xyz, time, 0.0, 1.0);\n    material mat_2 = gear(pos.yzx, time, 0.0, 1.0);\n    material mat_3 = gear(pos.zxy, time, 0.0, 1.0);\n    \n    // return mat_1;\n    \n    material mat;\n    if(mat_1.d < mat_2.d && mat_1.d < mat_3.d)\n        mat = mat_1;\n    else if(mat_2.d < mat_3.d)\n        mat = mat_2;\n    else\n        mat = mat_3;\n    \n    // return mat;\n    vec3 qx = vec3(rot45(pos.zy), pos.x);\n    if(abs(qx.x) > abs(qx.y)) qx = qx.zxy;\n    \n    vec3 qy = vec3(rot45(pos.xz), pos.y);\n    if(abs(qy.x) > abs(qy.y)) qy = qy.zxy;\n    \n    vec3 qz = vec3(rot45(pos.xy), pos.z);\n    if(abs(qz.x) > abs(qz.y)) qz = qz.zxy;\n    \n    \n    \n    material mat_4 = gear(qx, time, 1.0, -1.0);\n    material mat_5 = gear(qy, time, 1.0, -1.0);\n    material mat_6 = gear(qz, time, 1.0, 1.0);\n    \n    if(mat_4.d < mat.d) mat = mat_4;\n    if(mat_5.d < mat.d) mat = mat_5;\n    if(mat_6.d < mat.d) mat = mat_6;\n    \n    float d1 = mat.d;\n    d1 = min(d1, sdBall(pos, 0.12));\n    \n    mat.d = d1;\n    \n    return mat;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmaterial Raymarch(vec3 ro, vec3 rd, float time){\n    float d;\n    material mat;\n    for(int i = 0; i < 255; i ++){\n        vec3 p = ro + rd * d;\n        mat = map(p, time);\n        mat.col = color;\n        float d0 = mat.d;\n        if(d0 <= 0.001 || d >= 40.0) \n            break;\n        d += d0;\n    }\n    mat.d = d;\n    return mat;\n}\n\n\nvec3 GetNormal(vec3 p, float time){\n    float d = map(p, time).d;\n    vec2 e = vec2(0.001, 0.0);\n    float dx = d - map(p-e.xyy, time).d;\n    float dy = d - map(p-e.yxy, time).d;\n    float dz = d - map(p-e.yyx, time).d;\n    return normalize(vec3(dx, dy, dz));\n}\n\nmat3 CameraToWorld(vec3 ro,vec2 uv,vec3 lookAt){\n    vec3 f = normalize(lookAt - ro);\n    vec3 r = cross(vec3(0, 1, 0), f);\n    vec3 u = cross(f, r);\n    return mat3(r, u, f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    vec2 uv = fragCoord/iResolution.xy;    \n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    vec3 col = vec3(0.0);\n    \n    // 观察视角\n    vec3 ro = vec3(0.0, 1.0, -1.5);\n    // 相机旋转速度\n    ro.xz *= rot(iTime * 0.5);\n    vec3 rd = CameraToWorld(ro,uv,vec3(0.0))*(normalize(vec3(uv,1.0)));\n    \n    material mat = Raymarch(ro, rd, iTime);\n    if(mat.d < 40.0 && mat.d > 0.0){\n        vec3 p = ro + rd * mat.d;\n        vec3 n = GetNormal(p, iTime);\n        \n        // 环境光渲染\n        vec3 lightPos = vec3(2.0, 5.0, 5.0); \n        vec3 lightdir = normalize(lightPos - p);\n        float diffuse = dot(n, lightdir);\n        diffuse = diffuse * 0.5 + 0.5;\n        \n        col = mat.col * diffuse;\n    }\n   \n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}