{"ver":"0.1","info":{"id":"3tyGWw","date":"1579034515","viewed":454,"name":"Day 26 - Bubblegum river","username":"jeyko","description":"Inspired by https://www.shadertoy.com/user/victor_shepardson .\nAlso, his code is more readable than this.","likes":9,"published":3,"flags":32,"usePreview":0,"tags":["feedback"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n// Thanks to wyatt and Flexi for their awesome stuff! \n\n// Learned this buffer feedback technique from victor_shepardson\n\n// The whole thing is not very logical :D Mostly random\n// If you'd like to learn how it works, I recommend checking out victor's things.\n\n// There's no fluid dynamics here. It's only buffer feedback stuff.\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    vec2 uv = U/R.xy;\n    //U.x += 0.1*R.x;\n\t//U *= 0.92;\n    \n    vec3 colA = T(U).xyz;\n    vec3 col = T(U).xyz;\n\n    col.b = colA.r;\n    col.r = colA.b;\n    col.b *= 0.9;\n    \n    vec3 sh = abs(T(U) - T(U + 2.)).xyz;\n    \n    col = clamp(col, 0., 1.);\n    \n    col.g *= 1. - sh.g*1.;\n    col.r *= 1. - sh.r*1.;\n    //col.b *= 1. - sh.b*1.;\n    col = smoothstep(0.,1.,col);\n    \n    //col = smoothstep(0.,1.,col);\n    //col.x *= sh;\n    \n    //col *= 2.;\n    //col *= vec3(0.45);\n    C = vec4(col.xyz,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\n#define X  A += T(U  + sin(i + 3.4)*T(U - i).yz*2. * (exp(-length(uv*2.))))*0.48\n#define L(x) i*=rot(x*acos(-1.))\n#define Y  i *= 1.1*div\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    #define grad 0.25*vec2(e.x-w.x,n.x-s.x)\n    #define div 0.25*(n.x-s.x+e.x-w.x)\n\n    Neighbros; \n    U -= grad*0.4;\n    vec2 uv = U/R;\n    U += sin(uv.yx*10.5 + iTime*0.4)*0.2;\n    U -= 1.;\n    U *= rot(length(uv*1.4)*0.002 + iTime*0.00005 );\n    U += 0.5;\n    uv -= 0.5;\n\n    vec2 i = vec2(0);\n    vec4 A = T(U)*0.46;\n    U += grad*0.6;\n    X; Y;\n    X; Y;\n\tX; Y*-1.;\n    U -= grad*(0.4 + sin(iTime)*0.2);\n\tX; Y*-1.;\n\tX; Y*-1.;\n    \n\tX; Y*1.;\n\tX*0.9; Y*-1.;\n\t//X; Y;\n\t//X; Y;\n    \n    \n    \n        \n    A *= 0.78 + sin(iTime*0.25)*0.02;\n    //A.g *= 1.001 + sin(iTime)*0.004;\n    C = mix(fract(sin(A.bagr - T(U - 4.*i*cos(iTime))*0.44  -  T(U)*0.1)) ,fract(cos(uv.xyxy)*2.), 0.06);\n    \n    if(iMouse.z > 0.){\n        float dMouse = length((iMouse.xy - U.xy)/R.y );\n        C = mix(C, abs(\n            mix(vec4(1,1.,0,1), vec4(1,0.,0.,0),sin(iTime)*0.5 + 0.5 )\n        )*0.5, smoothstep(0.18,0.15,dMouse));\n    \n    }\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n#define R (iResolution.xy)\n#define T(uv) texture(iChannel0, (uv)/R)\n#define A(uv) T(uv)\n\n#define Neighbros vec4 n = A(U+vec2(0,1)), e = A(U+vec2(1,0)), s = A(U-vec2(0,1)), w = A(U-vec2(1,0)), m = 0.25*(n+e+s+w); \n\n","name":"Common","description":"","type":"common"}]}