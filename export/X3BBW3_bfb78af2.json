{"ver":"0.1","info":{"id":"X3BBW3","date":"1729967033","viewed":272,"name":"Spooky cubes","username":"PauloFalcao","description":"Generated in Material Maker. Used in a flyer for a local demoscene event Momentum #18","likes":27,"published":3,"flags":32,"usePreview":0,"tags":["pathtracing","halloween","momentum"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Spooky cubes\n//\n// By https://twitter.com/paulofalcao\n//\n// Used in a flyer for a local demoscene event Momentum #18\n// https://x.com/psenough/status/1850206933514436951\n//\n// Generated in Material Maker\n// The code is basically the generated code\n// No simplification or optimization\n//\n// Material Maker source here https://www.materialmaker.org/material?id=1032\n//\n// \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec4 color = texture(iChannel0, fragCoord / iResolution.xy);\n\n    fragColor = vec4(pow(color.xyz,vec3(1.0/2.2)), 1.0f);\n     \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Spooky cubes\n//\n// By https://twitter.com/paulofalcao\n//\n// Used in a flyer for a local demoscene event Momentum #18\n// https://x.com/psenough/status/1850206933514436951\n//\n// Generated in Material Maker\n// The code is basically the generated code\n// No simplification or optimization\n//\n// Material Maker source here https://www.materialmaker.org/material?id=1032\n//\n// \n\n\nfloat rand(vec2 x) {\n    return fract(cos(mod(dot(x, vec2(13.9898, 8.141)), 3.14)) * 43758.5453);\n}\n\nvec2 rand2(vec2 x) {\n    return fract(cos(mod(vec2(dot(x, vec2(13.9898, 8.141)),\n\t\t\t\t\t\t      dot(x, vec2(3.4562, 17.398))), vec2(3.14))) * 43758.5453);\n}\n\nfloat box3d(vec3 uv, vec3 s) {\n\tvec3 q = abs(uv) - s;\n\treturn length(max(q, 0.0))+min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nvec2 sdf3dc_union(vec2 a, vec2 b) {\n\treturn vec2(min(a.x, b.x), mix(b.y, a.y, step(a.x, b.x)));\n}\n\n//Adapted from https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm - Finite Repetition\n\nvec3 opRepLim(vec3 p,vec3 c,vec3 l){\n    p+=(c*l)/2.0;\n    return p-c*clamp(floor((p+0.0001)/c+0.5),vec3(0.0),l);\n}\n\nvec3 MFSDF_Obj_Maker_rotate3d(vec3 p, vec3 a) {\n\tvec3 rv;\n\tfloat c;\n\tfloat s;\n\tc = cos(a.x);\n\ts = sin(a.x);\n\trv.x = p.x;\n\trv.y = p.y*c+p.z*s;\n\trv.z = -p.y*s+p.z*c;\n\tc = cos(a.y);\n\ts = sin(a.y);\n\tp.x = rv.x*c+rv.z*s;\n\tp.y = rv.y;\n\tp.z = -rv.x*s+rv.z*c;\n\tc = cos(a.z);\n\ts = sin(a.z);\n\trv.x = p.x*c+p.y*s;\n\trv.y = -p.x*s+p.y*c;\n\trv.z = p.z;\n\treturn rv;\n}\n\n// https://www.shadertoy.com/view/XsX3zB\n//\n// The MIT License\n// Copyright Â© 2013 Nikita Miropolskiy\n// \n// ( license has been changed from CCA-NC-SA 3.0 to MIT\n//\n//   but thanks for attributing your source code when deriving from this sample \n//   with a following link: https://www.shadertoy.com/view/XsX3zB )\n//\n//\n// if you're looking for procedural noise implementation examples you might \n// also want to look at the following shaders:\n// \n// Noise Lab shader by candycat: https://www.shadertoy.com/view/4sc3z2\n//\n// Noise shaders by iq:\n//     Value    Noise 2D, Derivatives: https://www.shadertoy.com/view/4dXBRH\n//     Gradient Noise 2D, Derivatives: https://www.shadertoy.com/view/XdXBRH\n//     Value    Noise 3D, Derivatives: https://www.shadertoy.com/view/XsXfRH\n//     Gradient Noise 3D, Derivatives: https://www.shadertoy.com/view/4dffRH\n//     Value    Noise 2D             : https://www.shadertoy.com/view/lsf3WH\n//     Value    Noise 3D             : https://www.shadertoy.com/view/4sfGzS\n//     Gradient Noise 2D             : https://www.shadertoy.com/view/XdXGW8\n//     Gradient Noise 3D             : https://www.shadertoy.com/view/Xsl3Dl\n//     Simplex  Noise 2D             : https://www.shadertoy.com/view/Msf3WH\n//     Voronoise: https://www.shadertoy.com/view/Xd23Dh\n//\n//\n//\n\n// discontinuous pseudorandom constly distributed in [-0.5, +0.5]^3 */\nvec3 XsX3zB_oct_random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n// skew constants for 3d simplex functions\nconst float XsX3zB_oct_F3 =  0.3333333;\nconst float XsX3zB_oct_G3 =  0.1666667;\n\n// 3d simplex noise\nfloat XsX3zB_oct_simplex3d(vec3 p) {\n\t // 1. find current tetrahedron T and it's four vertices\n\t // s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices\n\t // x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices\n\t \n\t // calculate s and x\n\t vec3 s = floor(p + dot(p, vec3(XsX3zB_oct_F3)));\n\t vec3 x = p - s + dot(s, vec3(XsX3zB_oct_G3));\n\t \n\t // calculate i1 and i2\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t // x1, x2, x3\n\t vec3 x1 = x - i1 + XsX3zB_oct_G3;\n\t vec3 x2 = x - i2 + 2.0*XsX3zB_oct_G3;\n\t vec3 x3 = x - 1.0 + 3.0*XsX3zB_oct_G3;\n\t \n\t // 2. find four surflets and store them in d\n\t vec4 w, d;\n\t \n\t // calculate surflet weights\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t // w fades from 0.6 at the center of the surflet to 0.0 at the margin\n\t w = max(0.6 - w, 0.0);\n\t \n\t // calculate surflet components\n\t d.x = dot(XsX3zB_oct_random3(s), x);\n\t d.y = dot(XsX3zB_oct_random3(s + i1), x1);\n\t d.z = dot(XsX3zB_oct_random3(s + i2), x2);\n\t d.w = dot(XsX3zB_oct_random3(s + 1.0), x3);\n\t \n\t // multiply d by w^4\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t // 3. return the sum of the four surflets\n\t return dot(d, vec4(52.0));\n}\n\nvec2 rotate(vec2 uv, float rotate) {\n \tvec2 rv;\n\trv.x = cos(rotate)*uv.x + sin(rotate)*uv.y;\n\trv.y = -sin(rotate)*uv.x + cos(rotate)*uv.y;\n\treturn rv;\t\n}\n\nvec2 circle_repeat_transform_2d(vec2 p, float count) {\n\tfloat r = 6.28318530718/count;\n\tfloat pa = atan(p.x, p.y);\n\tfloat a = mod(pa+0.5*r, r)-0.5*r;\n\tvec2 rv;\n\tfloat c = cos(a-pa);\n\tfloat s = sin(a-pa);\n\trv.x = p.x*c+p.y*s;\n\trv.y = -p.x*s+p.y*c;\n\treturn rv;\n}\n\nfloat sdNgon(vec2 p, float r, float n) {\n\tfloat PI = 3.1415926535;\n\tp = circle_repeat_transform_2d(p, n);\n\tvec2 d = abs(p)-vec2(r*tan(3.14159265359/n), r);\n\treturn p.y < r ? p.y-r : length(max(d,vec2(0)))+min(max(d.x,d.y),0.0);\n}\n\nfloat sd_box(vec2 uv, vec2 size) {\n\tvec2 d = abs(uv)-size;\n\treturn length(max(d, vec2(0)))+min(max(d.x, d.y), 0.0);\n}\n\n\nfloat blend_overlay_f(float c1, float c2) {\n\treturn (c1 < 0.5) ? (2.0*c1*c2) : (1.0-2.0*(1.0-c1)*(1.0-c2));\n}\n\nvec3 blend_overlay(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*vec3(blend_overlay_f(c1.x, c2.x), blend_overlay_f(c1.y, c2.y), blend_overlay_f(c1.z, c2.z)) + (1.0-opacity)*c2;\n}\n\nfloat blend_exclusion_f(float c1, float c2) {\n\treturn c1 + c2 - 2.0 * c1 * c2;\n}\n\nvec3 blend_exclusion(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*vec3(blend_exclusion_f(c1.x, c2.x), blend_exclusion_f(c1.y, c2.y), blend_exclusion_f(c1.z, c2.z)) + (1.0-opacity)*c2;\n}\n\n\nvec2 transform2(vec2 uv, vec2 translate, float rotate, vec2 scale) {\n \tvec2 rv;\n\tuv -= translate;\n\tuv -= vec2(0.5);\n\trv.x = cos(rotate)*uv.x + sin(rotate)*uv.y;\n\trv.y = -sin(rotate)*uv.x + cos(rotate)*uv.y;\n\trv /= scale;\n\trv += vec2(0.5);\n\treturn rv;\t\n}\n\n\nvec3 blend3d_multiply(vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*c1*c2 + (1.0-opacity)*c2;\n}\n\n\nfloat blend3d_overlay_f(float c1, float c2) {\n\treturn (c1 < 0.5) ? (2.0*c1*c2) : (1.0-2.0*(1.0-c1)*(1.0-c2));\n}\n\nvec3 blend3d_overlay(vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*vec3(blend3d_overlay_f(c1.x, c2.x), blend3d_overlay_f(c1.y, c2.y), blend3d_overlay_f(c1.z, c2.z)) + (1.0-opacity)*c2;\n}\n\nfloat dots(vec2 uv, float size, float density, float seed) {\n\tvec2 seed2 = rand2(vec2(seed, 1.0-seed));\n\tuv /= size;\n\tvec2 point_pos = floor(uv)+vec2(0.5);\n\tfloat color = step(rand(seed2+point_pos), density);\n\treturn color;\n}\n\nvec2 scale(vec2 uv, vec2 center, vec2 scale) {\n\tuv -= center;\n\tuv /= scale;\n\tuv += center;\n\treturn uv;\n}\n\n//MATH\nconst float pathtracing_PI=3.14159265359;\nconst float pathtracing_TAU=6.28318530718;\n\nvoid pathtracing_Onb(in vec3 N, inout vec3 T, inout vec3 B){\n    vec3 UpVector=abs(N.z)<0.999?vec3(0,0,1):vec3(1,0,0);\n    T=normalize(cross(UpVector,N));\n    B=cross(N,T);\n}\n\nvec2 pathtracing_equirectangularMap(vec3 dir) {\n\tvec2 longlat = vec2(atan(dir.y,dir.x),acos(dir.z));\n \treturn longlat/vec2(2.0*pathtracing_PI,pathtracing_PI);\n}\n\n// RANDOM START\n//from https://www.reedbeta.com/blog/hash-functions-for-gpu-rendering/\nuint pathtracing_rand_pcg(inout uint seed){\n    uint state = seed;\n    seed = seed * uint(747796405) + uint(2891336453);\n    uint word = ((state >> ((state >> uint(28)) + uint(4))) ^ state) * uint(277803737);\n    return (word >> uint(22)) ^ word;\n}\n\nfloat pathtracing_RandomFloat01(inout uint state){\n    uint r=pathtracing_rand_pcg(state);\n    r &= uint(0x007FFFFF);\n    r |= uint(0x3F800000);\n    return uintBitsToFloat(r) - 1.0f;\n}\n\n// RANDOM END\n\n// SAMPLING START\n\nvec3 pathtracing_constSampleSphere(float r1,float r2){\n    float z=1.0-2.0*r1;\n    float r=sqrt(max(0.0,1.0-z*z));\n    float phi=pathtracing_TAU*r2;\n    return vec3(r*cos(phi),r*sin(phi),z);\n}\n\nvec3 pathtracing_cosineSampleHemissphere(inout uint state,vec3 n){\n    float u1=pathtracing_RandomFloat01(state);\n    float u2=pathtracing_RandomFloat01(state);\n    return normalize(n+pathtracing_constSampleSphere(u1,u2)); \n}\n\n// Adapted from \"Sampling the GGX Distribution of Visible Normals\",\n// http://jcgt.org/published/0007/04/01/\nvec3 pathtracing_SampleGGXVNDF(inout uint state,vec3 Ve,float alpha_x,float alpha_y){\n    float U1=pathtracing_RandomFloat01(state);\n    float U2=pathtracing_RandomFloat01(state);\n    \n    //transforming the view direction to the hemisphere configuration\n    vec3 Vh = normalize(vec3(alpha_x * Ve.x, alpha_y * Ve.y, Ve.z));\n\n    //orthonormal basis\n    vec3 T1;vec3 T2;\n    pathtracing_Onb(Vh,T1,T2);\n\n    //parameterization of the projected area\n    float r = sqrt(U1); \n    float phi = 2.0 * pathtracing_PI * U2;    \n    float t1 = r * cos(phi);\n    float t2 = r * sin(phi);\n    float s = 0.5 * (1.0 + Vh.z);\n    t2 = (1.0 - s)*sqrt(1.0 - t1*t1) + s*t2;\n\n    //reprojection onto hemisphere\n    vec3 Nh = t1*T1 + t2*T2 + sqrt(max(0.0f, 1.0f - t1*t1 - t2*t2))*Vh;\n\n    //transforming the normal back to the ellipsoid configuration\n    vec3 Ne = normalize(vec3(alpha_x * Nh.x, alpha_y * Nh.y, max(0.0f, Nh.z))); \n\n    return Ne;\n}\n\nfloat pathtracing_schlickWeight(float cosTheta) {\n    float m=clamp(1.-cosTheta,0.,1.);\n    float m2=m*m;\n    return m2*m2*m;\n}\n\n// SAMPLING END\n\nconst float p_o1720797_LookAtY = -0.050000000;\nconst float p_o1720797_CamD = 1.482000000;\nconst float p_o1720797_MaxDistance = 200.000000000;\nconst vec4 p_o1720813_BaseColor = vec4(1.000000000, 0.000000000, 0.000000000, 1.000000000);\nconst float p_o1720813_Metallic = 0.542000000;\nconst float p_o1720813_Specular = 0.815000000;\nconst float p_o1720813_Roughness = 0.000000000;\nconst float p_o1720813_Emission = 0.000000000;\nconst float p_o1720813_scale = 1.000000000;\nconst float p_o1720813_TranlateX = 0.000000000;\nconst float p_o1720813_TranlateY = 0.000000000;\nconst float p_o1720813_RotateX = 0.000000000;\nconst float p_o1720813_RotateY = 0.000000000;\nconst float p_o1720813_RotateZ = 0.000000000;\n\nvec3 o1720813_input_BaseColor_tex3d(vec4 p, float _seed_variation_) {\n    return vec3(1.0);\n}\n\nfloat o1720813_input_Metallic_tex3d(vec4 p, float _seed_variation_) {\n    return 1.0;\n}\n\nfloat o1720813_input_Specular_tex3d(vec4 p, float _seed_variation_) {\n    return 1.0;\n}\n\nfloat o1720813_input_Roughness_tex3d(vec4 p, float _seed_variation_) {\n    return 1.0;\n}\n\nvec3 o1720813_input_Emission_tex3d(vec4 p, float _seed_variation_) {\n    return vec3(1.0);\n}\n\nconst float p_o1720828_X = 0.500000000;\nconst float p_o1720828_Y = 0.500000000;\nconst float p_o1720828_Z = 1.000000000;\nconst float p_o1720828_RepX = 64.000000000;\nconst float p_o1720828_RepY = 64.000000000;\nconst float p_o1720828_RepZ = 1.000000000;\nconst float p_o1720804_x = 0.250000000;\nconst float p_o1720804_y = -0.250000000;\nconst float p_o1720804_z = 0.000000000;\nconst float p_o1720803_sx = 0.120000000;\nconst float p_o1720803_sy = 0.120000000;\nconst float p_o1720803_sz = 0.820000000;\nconst float p_o1720803_r = 0.100000000;\nconst float p_o1720807_x = -0.250000000;\nconst float p_o1720807_y = 0.250000000;\nconst float p_o1720807_z = 0.000000000;\nconst float p_o1720806_sx = 0.120000000;\nconst float p_o1720806_sy = 0.120000000;\nconst float p_o1720806_sz = 1.150000000;\nconst float p_o1720806_r = 0.100000000;\n\nfloat o1720813_input_sdf3d(vec3 p, float _seed_variation_) {\n    float o1720803_0_1_sdf3d = box3d(((opRepLim((p),vec3(p_o1720828_X,p_o1720828_Y,p_o1720828_Z)*2.0,vec3(p_o1720828_RepX-1.0,p_o1720828_RepY-1.0,p_o1720828_RepZ-1.0)))-vec3(p_o1720804_x, p_o1720804_y, p_o1720804_z)), vec3(p_o1720803_sx, p_o1720803_sy, p_o1720803_sz))-p_o1720803_r;\n    vec2 o1720804_0_1_sdf3dc = vec2(o1720803_0_1_sdf3d, 0.0);\n    float o1720806_0_1_sdf3d = box3d(((opRepLim((p),vec3(p_o1720828_X,p_o1720828_Y,p_o1720828_Z)*2.0,vec3(p_o1720828_RepX-1.0,p_o1720828_RepY-1.0,p_o1720828_RepZ-1.0)))-vec3(p_o1720807_x, p_o1720807_y, p_o1720807_z)), vec3(p_o1720806_sx, p_o1720806_sy, p_o1720806_sz))-p_o1720806_r;\n    vec2 o1720807_0_1_sdf3dc = vec2(o1720806_0_1_sdf3d, 0.0);\n    vec2 o1720805_0_1_sdf3dc = sdf3dc_union(o1720804_0_1_sdf3dc, o1720807_0_1_sdf3dc);\n    float o1720828_0_1_sdf3d = (o1720805_0_1_sdf3dc).x*0.5;\n\n    return o1720828_0_1_sdf3d;\n}\n\nvec4 PBRObjectMaker_o1720813(vec4 uv, float _seed_variation_) {\n    uv.xyz=MFSDF_Obj_Maker_rotate3d(uv.xyz-vec3(p_o1720813_TranlateX,p_o1720813_TranlateY,(sin(iTime*0.3)*0.3-0.9)),vec3(p_o1720813_RotateX,p_o1720813_RotateY,p_o1720813_RotateZ)*0.01745329251)/p_o1720813_scale;\n\tfloat sdf=o1720813_input_sdf3d(uv.xyz, _seed_variation_)*p_o1720813_scale;\n\t//13 - Emission\n\tif (uv.w>12.5&&uv.w<13.5) {\n\t\treturn vec4(p_o1720813_Emission*o1720813_input_Emission_tex3d(vec4(uv.xyz,13.0), _seed_variation_),sdf);\n\t} else\n\t//5 - Roughness\n\tif (uv.w>4.5&&uv.w<5.5) {\n\t\treturn vec4(p_o1720813_Roughness*clamp(o1720813_input_Roughness_tex3d(vec4(uv.xyz,5.0), _seed_variation_),0.0,1.0),0.0,0.0,sdf);\n\t} else\n\t//4 - Specular\n\tif (uv.w>3.5) {\n\t\treturn vec4(p_o1720813_Specular*clamp(o1720813_input_Specular_tex3d(vec4(uv.xyz,4.0), _seed_variation_),0.0,1.0),0.0,0.0,sdf);\n\t} else\n\t//2 - Metallic\n\tif (uv.w>1.5&&uv.w<2.5) {\n\t\treturn vec4(p_o1720813_Metallic*clamp(o1720813_input_Metallic_tex3d(vec4(uv.xyz,2.0), _seed_variation_),0.0,1.0),0.0,0.0,sdf);\n\t} else\n\t//1 - BaseColor\n\tif (uv.w>0.5){\n\t\treturn vec4(p_o1720813_BaseColor.rgb*clamp(o1720813_input_BaseColor_tex3d(vec4(uv.xyz,1.0), _seed_variation_),vec3(0.0),vec3(1.0)),sdf);\n\t} else\n\t//0 - SDF\n\t{\n\t\treturn vec4(vec3(0),sdf);\n\t}\n}\n\nvec4 o1720821_input_in1(vec4 p, float _seed_variation_) {\n    vec4 o1720813_0_1_v4v4 = PBRObjectMaker_o1720813((p), _seed_variation_);\n\n    return o1720813_0_1_v4v4;\n}\n\nconst vec4 p_o1720817_BaseColor = vec4(1.000000000, 1.000000000, 1.000000000, 1.000000000);\nconst float p_o1720817_Metallic = 1.000000000;\nconst float p_o1720817_Specular = 1.000000000;\nconst float p_o1720817_Roughness = 0.000000000;\nconst float p_o1720817_Emission = 3.892000000;\nconst float p_o1720817_scale = 1.000000000;\nconst float p_o1720817_TranlateX = 0.000000000;\nconst float p_o1720817_TranlateY = 0.000000000;\nconst float p_o1720817_TranlateZ = -0.100000000;\nconst float p_o1720817_RotateX = 0.000000000;\nconst float p_o1720817_RotateY = 0.000000000;\nconst float p_o1720817_RotateZ = 0.000000000;\n\nvec3 o1720817_input_BaseColor_tex3d(vec4 p, float _seed_variation_) {\n    return vec3(1.0);\n}\n\nfloat o1720817_input_Metallic_tex3d(vec4 p, float _seed_variation_) {\n    return 1.0;\n}\n\nfloat o1720817_input_Specular_tex3d(vec4 p, float _seed_variation_) {\n    return 1.0;\n}\n\nfloat o1720817_input_Roughness_tex3d(vec4 p, float _seed_variation_) {\n    return 1.0;\n}\n\nconst float p_o1769349_amount = 1.000000000;\nconst float p_o1720845_amount = 1.397100000;\nconst float p_o1720829_g_0_pos = 0.156540000;\nconst vec4 p_o1720829_g_0_col = vec4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\nconst float p_o1720829_g_1_pos = 0.947449000;\nconst vec4 p_o1720829_g_1_col = vec4(0.945312023, 0.423729002, 0.110779002, 1.000000000);\n\nvec4 o1720829_g_gradient_fct(float x) {\n  if (x < p_o1720829_g_0_pos) {\n    return p_o1720829_g_0_col;\n  } else if (x < p_o1720829_g_1_pos) {\n    return mix(p_o1720829_g_0_col, p_o1720829_g_1_col, ((x-p_o1720829_g_0_pos)/(p_o1720829_g_1_pos-p_o1720829_g_0_pos)));\n  }\n  return p_o1720829_g_1_col;\n}\n\nconst float p_o1720822_scale = 1.094000000;\nconst float p_o1720822_scale_x = 1.000000000;\nconst float p_o1720822_scale_y = 1.000000000;\nconst float p_o1720822_scale_z = 1.000000000;\nconst float p_o1720822_transx = 8.826000000;\nconst float p_o1720822_transy = 1.618000000;\nconst float p_o1720822_transz = 1.123000000;\nconst float p_o1720822_persistence = 0.766000000;\nconst float p_o1720822_brightness = 0.000000000;\nconst float p_o1720822_contrast = 6.880000000;\n\nfloat o1720822_fbm(vec3 coord, float persistence, float _seed_variation_) {\n\tfloat normalize_factor = 0.0;\n\tfloat value = 0.0;\n\tfloat scale = 1.0;\n\tfloat size = 1.0;\n\tfor (int i = 0; i < 11; i++) {\n\t\tvalue += XsX3zB_oct_simplex3d(coord*size) * scale;\n\t\tnormalize_factor += scale;\n\t\tsize *= 2.0;\n\t\tscale *= persistence;\n\t}\n\treturn value / normalize_factor;\n}\n\nfloat o1720822_bc(float f,float contrast, float brightness, float _seed_variation_) {\n\treturn f*contrast+brightness+0.5-contrast*0.5;\n}\n\nconst float p_o1720846_translate_x = 0.235000000;\nconst float p_o1720846_translate_y = 0.275000000;\nconst float p_o1720846_rotate = 180.000000000;\nconst float p_o1720846_scale_x = 0.500000000;\nconst float p_o1720846_scale_y = 0.500000000;\nconst float p_o1720847_amount1 = 0.110000000;\nconst float p_o1720843_bevel = 0.000000000;\nconst float p_o1720843_base = 0.000000000;\n\nfloat o1720838_d(vec2 uv, float _seed_variation_) {\n    vec2 _n3208639_p = uv - vec2(0.000000000, -0.050000000);\n    _n3208639_p = rotate(_n3208639_p, radians(0.000000000))/1.000000000;\n    float _n3208639;\n    vec2 _n3208640_p = _n3208639_p - vec2(-0.200000000, -0.100000000);\n    _n3208640_p = rotate(_n3208640_p, radians(0.000000000))/0.150000000;\n    float _n3208640;\n    _n3208640 = sdNgon(_n3208640_p, 0.500000000, 3.000000000);\n    _n3208640 *= 0.150000000;\n    _n3208639 = _n3208640;\n    vec2 _n3208641_p = _n3208639_p - vec2(0.200000000, -0.100000000);\n    _n3208641_p = rotate(_n3208641_p, radians(0.000000000))/0.150000000;\n    float _n3208641;\n    _n3208641 = sdNgon(_n3208641_p, 0.500000000, 3.000000000);\n    _n3208641 *= 0.150000000;\n    _n3208639 = min(_n3208639, _n3208641);\n    vec2 _n3208642_p = _n3208639_p - vec2(0.000000000, 0.150000000);\n    _n3208642_p = rotate(_n3208642_p, radians(0.000000000))/0.100000000;\n    float _n3208642;\n    _n3208642 = sdNgon(_n3208642_p, 0.500000000, 3.000000000);\n    _n3208642 *= 0.100000000;\n    _n3208639 = min(_n3208639, _n3208642);\n    vec2 _n3208643_p = _n3208639_p - vec2(0.000000000, 0.000000000);\n    _n3208643_p = rotate(_n3208643_p, radians(0.000000000))/1.000000000;\n    float _n3208643 = 0.0;vec2 _n3208644_p = _n3208643_p - vec2(0.000000000, 0.150000000);\n    _n3208644_p = rotate(_n3208644_p, radians(0.000000000))/0.700000000;\n    float _n3208644;\n    _n3208644 = length(_n3208644_p)-0.500000000;\n    _n3208644 *= 0.700000000;\n    _n3208643 = _n3208644;\n    vec2 _n3208645_p = _n3208643_p - vec2(0.000000000, -0.200000000);\n    _n3208645_p = rotate(_n3208645_p, radians(0.000000000))/1.050000000;\n    float _n3208645;\n    _n3208645 = length(_n3208645_p)-0.500000000;\n    _n3208645 *= 1.050000000;\n    _n3208643 = max(_n3208643, -(_n3208645));\n    vec2 _n3353447_p = _n3208643_p - vec2(-0.140000000, 0.200000000);\n    _n3353447_p = rotate(_n3353447_p, radians(0.000000000))/1.000000000;\n    float _n3353447;\n    _n3353447 = sd_box(_n3353447_p, vec2(0.050000000, 0.150000000));\n    _n3353447 *= 1.000000000;\n    _n3208643 = max(_n3208643, -(_n3353447));\n    vec2 _n3292137_p = _n3208643_p - vec2(0.140000000, 0.250000000);\n    _n3292137_p = rotate(_n3292137_p, radians(0.000000000))/1.000000000;\n    float _n3292137;\n    _n3292137 = sd_box(_n3292137_p, vec2(0.050000000, 0.150000000));\n    _n3292137 *= 1.000000000;\n    _n3208643 = max(_n3208643, -(_n3292137));\n    vec2 _n3458670_p = _n3208643_p - vec2(-0.019227000, 0.571533000);\n    _n3458670_p = rotate(_n3458670_p, radians(0.000000000))/1.000000000;\n    float _n3458670;\n    _n3458670 = sd_box(_n3458670_p, vec2(0.050000000, 0.150000000));\n    _n3458670 *= 1.000000000;\n    _n3208643 = max(_n3208643, -(_n3458670));\n    _n3208643 *= 1.000000000;\n    _n3208639 = min(_n3208639, _n3208643);\n    _n3208639 *= 1.000000000;\n    float return_value = _n3208639;\n    return return_value;\n}\n\nfloat o1720838_c(vec2 uv, out vec4 albedo, out float metallic, out float roughness, out vec3 emission, float _seed_variation_) {\n    albedo = vec4(0.0, 0.0, 0.0, 1.0);\n    metallic = 0.0;\n    roughness = 1.0;\n    emission = vec3(0.0);\n    vec2 _n3208639_p = uv - vec2(0.000000000, -0.050000000);\n    _n3208639_p = rotate(_n3208639_p, radians(0.000000000))/1.000000000;\n    float _n3208639;\n    vec2 _n3208640_p = _n3208639_p - vec2(-0.200000000, -0.100000000);\n    _n3208640_p = rotate(_n3208640_p, radians(0.000000000))/0.150000000;\n    float _n3208640;\n    _n3208640 = sdNgon(_n3208640_p, 0.500000000, 3.000000000);\n    _n3208640 *= 0.150000000;\n    _n3208639 = _n3208640;\n    vec2 _n3208641_p = _n3208639_p - vec2(0.200000000, -0.100000000);\n    _n3208641_p = rotate(_n3208641_p, radians(0.000000000))/0.150000000;\n    float _n3208641;\n    _n3208641 = sdNgon(_n3208641_p, 0.500000000, 3.000000000);\n    _n3208641 *= 0.150000000;\n    _n3208639 = min(_n3208639, _n3208641);\n    vec2 _n3208642_p = _n3208639_p - vec2(0.000000000, 0.150000000);\n    _n3208642_p = rotate(_n3208642_p, radians(0.000000000))/0.100000000;\n    float _n3208642;\n    _n3208642 = sdNgon(_n3208642_p, 0.500000000, 3.000000000);\n    _n3208642 *= 0.100000000;\n    _n3208639 = min(_n3208639, _n3208642);\n    vec2 _n3208643_p = _n3208639_p - vec2(0.000000000, 0.000000000);\n    _n3208643_p = rotate(_n3208643_p, radians(0.000000000))/1.000000000;\n    float _n3208643 = 0.0;vec2 _n3208644_p = _n3208643_p - vec2(0.000000000, 0.150000000);\n    _n3208644_p = rotate(_n3208644_p, radians(0.000000000))/0.700000000;\n    float _n3208644;\n    _n3208644 = length(_n3208644_p)-0.500000000;\n    _n3208644 *= 0.700000000;\n    _n3208643 = _n3208644;\n    vec2 _n3208645_p = _n3208643_p - vec2(0.000000000, -0.200000000);\n    _n3208645_p = rotate(_n3208645_p, radians(0.000000000))/1.050000000;\n    float _n3208645;\n    _n3208645 = length(_n3208645_p)-0.500000000;\n    _n3208645 *= 1.050000000;\n    _n3208643 = max(_n3208643, -(_n3208645));\n    vec2 _n3353447_p = _n3208643_p - vec2(-0.140000000, 0.200000000);\n    _n3353447_p = rotate(_n3353447_p, radians(0.000000000))/1.000000000;\n    float _n3353447;\n    _n3353447 = sd_box(_n3353447_p, vec2(0.050000000, 0.150000000));\n    _n3353447 *= 1.000000000;\n    _n3208643 = max(_n3208643, -(_n3353447));\n    vec2 _n3292137_p = _n3208643_p - vec2(0.140000000, 0.250000000);\n    _n3292137_p = rotate(_n3292137_p, radians(0.000000000))/1.000000000;\n    float _n3292137;\n    _n3292137 = sd_box(_n3292137_p, vec2(0.050000000, 0.150000000));\n    _n3292137 *= 1.000000000;\n    _n3208643 = max(_n3208643, -(_n3292137));\n    vec2 _n3458670_p = _n3208643_p - vec2(-0.019227000, 0.571533000);\n    _n3458670_p = rotate(_n3458670_p, radians(0.000000000))/1.000000000;\n    float _n3458670;\n    _n3458670 = sd_box(_n3458670_p, vec2(0.050000000, 0.150000000));\n    _n3458670 *= 1.000000000;\n    _n3208643 = max(_n3208643, -(_n3458670));\n    _n3208643 *= 1.000000000;\n    _n3208639 = min(_n3208639, _n3208643);\n    _n3208639 *= 1.000000000;\n    float return_value = _n3208639;\n\n    return return_value;\n}\n\nconst vec4 p_o1720848_color = vec4(1.000000000, 1.000000000, 1.000000000, 1.000000000);\nconst float p_o1749610_cx = 0.000000000;\nconst float p_o1749610_cy = 0.000000000;\nconst float p_o1749610_scale_x = 8.000000000;\nconst float p_o1749610_scale_y = 8.000000000;\nconst float p_o1749606_density = 0.500000000;\n\nfloat o1749606_f(vec2 uv, float _seed_variation_) {\n    return dots(uv, 1.0/16.000000000, p_o1749606_density, (floor(iTime)));\n}\n\nvec3 o1720817_input_Emission_tex3d(vec4 p, float _seed_variation_) {\n    vec3 o1720822_0_out = vec3(o1720822_bc(o1720822_fbm((p).xyz*vec3(p_o1720822_scale_x,p_o1720822_scale_y,p_o1720822_scale_z)*0.5*p_o1720822_scale+vec3(p_o1720822_transx,p_o1720822_transy,p_o1720822_transz),p_o1720822_persistence, _seed_variation_)*0.5+0.5,p_o1720822_contrast,p_o1720822_brightness, _seed_variation_));vec3 o1720822_0_1_tex3d = clamp(o1720822_0_out,vec3(0),vec3(1));\n    vec3 o1720829_0_1_tex3d = o1720829_g_gradient_fct(dot(o1720822_0_1_tex3d, vec3(1.0))/3.0).rgb;\n    float o1720838_0_0_sdf2d =  o1720838_d((fract(transform2(((p).xy+vec2(0.5)), vec2(p_o1720846_translate_x*(2.0*1.0-1.0), p_o1720846_translate_y*(2.0*1.0-1.0)), p_o1720846_rotate*0.01745329251*(2.0*1.0-1.0), vec2(p_o1720846_scale_x*(2.0*1.0-1.0), p_o1720846_scale_y*(2.0*1.0-1.0)))))-vec2(0.5), _seed_variation_);\n    float o1720843_0_1_f = clamp(p_o1720843_base-o1720838_0_0_sdf2d/max(p_o1720843_bevel, 0.00001), 0.0, 1.0);\n    vec4 o1720848_0_1_rgba = p_o1720848_color;\n    vec4 o1720847_0_b = vec4(vec3(o1720843_0_1_f), 1.0);\n    vec4 o1720847_0_l;\n    float o1720847_0_a;\n\n    o1720847_0_l = o1720848_0_1_rgba;\n    o1720847_0_a = p_o1720847_amount1*1.0;\n    o1720847_0_b = vec4(blend_exclusion((fract(transform2(((p).xy+vec2(0.5)), vec2(p_o1720846_translate_x*(2.0*1.0-1.0), p_o1720846_translate_y*(2.0*1.0-1.0)), p_o1720846_rotate*0.01745329251*(2.0*1.0-1.0), vec2(p_o1720846_scale_x*(2.0*1.0-1.0), p_o1720846_scale_y*(2.0*1.0-1.0))))), o1720847_0_l.rgb, o1720847_0_b.rgb, o1720847_0_a*o1720847_0_l.a), min(1.0, o1720847_0_b.a+o1720847_0_a*o1720847_0_l.a));\n\n    vec4 o1720847_0_2_rgba = o1720847_0_b;\n    vec4 o1720846_0_1_rgba = o1720847_0_2_rgba;\n    vec3 o1720844_0_1_tex3d = ((o1720846_0_1_rgba).rgb);\n    vec3 o1720845_0_1_tex3d = blend3d_overlay(o1720829_0_1_tex3d.rgb, o1720844_0_1_tex3d.rgb, p_o1720845_amount*dot(vec3(1.0), vec3(1.0))/3.0);\n    float o1749606_0_1_f = o1749606_f((scale(((p).xy+vec2(0.5)), vec2(0.5+p_o1749610_cx, 0.5+p_o1749610_cy), vec2(p_o1749610_scale_x, p_o1749610_scale_y))), _seed_variation_);\n    vec4 o1749610_0_1_rgba = vec4(vec3(o1749606_0_1_f), 1.0);\n    vec3 o1755989_0_1_tex3d = ((o1749610_0_1_rgba).rgb);\n    vec3 o1769349_0_1_tex3d = blend3d_multiply(o1720845_0_1_tex3d.rgb, o1755989_0_1_tex3d.rgb, p_o1769349_amount*dot(vec3(1.0), vec3(1.0))/3.0);\n\n    return o1769349_0_1_tex3d;\n}\n\nconst float p_o1720827_X = 0.500000000;\nconst float p_o1720827_Y = 0.500000000;\nconst float p_o1720827_Z = 1.000000000;\nconst float p_o1720827_RepX = 64.000000000;\nconst float p_o1720827_RepY = 64.000000000;\nconst float p_o1720827_RepZ = 1.000000000;\nconst float p_o1720810_x = -0.250000000;\nconst float p_o1720810_y = -0.250000000;\nconst float p_o1720810_z = 0.000000000;\nconst float p_o1720809_sx = 0.120000000;\nconst float p_o1720809_sy = 0.120000000;\nconst float p_o1720809_sz = 0.120000000;\nconst float p_o1720809_r = 0.100000000;\nconst float p_o1720808_x = 0.250000000;\nconst float p_o1720808_y = 0.250000000;\nconst float p_o1720808_z = 0.000000000;\nconst float p_o1720811_sx = 0.120000000;\nconst float p_o1720811_sy = 0.120000000;\nconst float p_o1720811_sz = 0.120000000;\nconst float p_o1720811_r = 0.100000000;\n\nfloat o1720817_input_sdf3d(vec3 p, float _seed_variation_) {\n    float o1720809_0_1_sdf3d = box3d(((opRepLim((p),vec3(p_o1720827_X,p_o1720827_Y,p_o1720827_Z)*2.0,vec3(p_o1720827_RepX-1.0,p_o1720827_RepY-1.0,p_o1720827_RepZ-1.0)))-vec3(p_o1720810_x, p_o1720810_y, p_o1720810_z)), vec3(p_o1720809_sx, p_o1720809_sy, p_o1720809_sz))-p_o1720809_r;\n    vec2 o1720810_0_1_sdf3dc = vec2(o1720809_0_1_sdf3d, 0.0);\n    float o1720811_0_1_sdf3d = box3d(((opRepLim((p),vec3(p_o1720827_X,p_o1720827_Y,p_o1720827_Z)*2.0,vec3(p_o1720827_RepX-1.0,p_o1720827_RepY-1.0,p_o1720827_RepZ-1.0)))-vec3(p_o1720808_x, p_o1720808_y, p_o1720808_z)), vec3(p_o1720811_sx, p_o1720811_sy, p_o1720811_sz))-p_o1720811_r;\n    vec2 o1720808_0_1_sdf3dc = vec2(o1720811_0_1_sdf3d, 0.0);\n    vec2 o1720812_0_1_sdf3dc = sdf3dc_union(o1720810_0_1_sdf3dc, o1720808_0_1_sdf3dc);\n    float o1720827_0_1_sdf3d = (o1720812_0_1_sdf3dc).x;\n\n    return o1720827_0_1_sdf3d;\n}\n\nvec4 PBRObjectMaker_o1720817(vec4 uv, float _seed_variation_) {\n    uv.xyz=MFSDF_Obj_Maker_rotate3d(uv.xyz-vec3(p_o1720817_TranlateX,p_o1720817_TranlateY,p_o1720817_TranlateZ),vec3(p_o1720817_RotateX,p_o1720817_RotateY,p_o1720817_RotateZ)*0.01745329251)/p_o1720817_scale;\n\tfloat sdf=o1720817_input_sdf3d(uv.xyz, _seed_variation_)*p_o1720817_scale;\n\t//13 - Emission\n\tif (uv.w>12.5&&uv.w<13.5) {\n\t\treturn vec4(p_o1720817_Emission*o1720817_input_Emission_tex3d(vec4(uv.xyz,13.0), _seed_variation_),sdf);\n\t} else\n\t//5 - Roughness\n\tif (uv.w>4.5&&uv.w<5.5) {\n\t\treturn vec4(p_o1720817_Roughness*clamp(o1720817_input_Roughness_tex3d(vec4(uv.xyz,5.0), _seed_variation_),0.0,1.0),0.0,0.0,sdf);\n\t} else\n\t//4 - Specular\n\tif (uv.w>3.5) {\n\t\treturn vec4(p_o1720817_Specular*clamp(o1720817_input_Specular_tex3d(vec4(uv.xyz,4.0), _seed_variation_),0.0,1.0),0.0,0.0,sdf);\n\t} else\n\t//2 - Metallic\n\tif (uv.w>1.5&&uv.w<2.5) {\n\t\treturn vec4(p_o1720817_Metallic*clamp(o1720817_input_Metallic_tex3d(vec4(uv.xyz,2.0), _seed_variation_),0.0,1.0),0.0,0.0,sdf);\n\t} else\n\t//1 - BaseColor\n\tif (uv.w>0.5){\n\t\treturn vec4(p_o1720817_BaseColor.rgb*clamp(o1720817_input_BaseColor_tex3d(vec4(uv.xyz,1.0), _seed_variation_),vec3(0.0),vec3(1.0)),sdf);\n\t} else\n\t//0 - SDF\n\t{\n\t\treturn vec4(vec3(0),sdf);\n\t}\n}\n\nvec4 o1720821_input_in2(vec4 p, float _seed_variation_) {\n    vec4 o1720817_0_1_v4v4 = PBRObjectMaker_o1720817((p), _seed_variation_);\n\n    return o1720817_0_1_v4v4;\n}\n\nvec4 o1720797_input_mfsdf(vec4 p, float _seed_variation_) {\n    vec4 o1720821_0_t = vec4(0.0,0.0,0.0,999999.0);\n    vec4 o1720821_0_n;\n\n    o1720821_0_n=o1720821_input_in1((p), _seed_variation_);\n    if (o1720821_0_n.w<o1720821_0_t.w){\n    o1720821_0_t=o1720821_0_n;\n    }\n\n    o1720821_0_n=o1720821_input_in2((p), _seed_variation_);\n    if (o1720821_0_n.w<o1720821_0_t.w){\n    o1720821_0_t=o1720821_0_n;\n    }\n    vec4 o1720821_0_1_v4v4 = o1720821_0_t;\n\n    return o1720821_0_1_v4v4;\n}\n\nvec3 o1720797_input_hdri(vec2 uv, float _seed_variation_) {\n    return vec3(0.0);\n}\n\n//tetrahedron normal by PauloFalcao\nvec3 normal_o1720797(vec3 p, float _seed_variation_) {  \n  const vec3 e=vec3(0.001,-0.001,0.0);\n  float v1=o1720797_input_mfsdf(vec4(p+e.xyy,0.0), _seed_variation_).w;\n  float v2=o1720797_input_mfsdf(vec4(p+e.yyx,0.0), _seed_variation_).w;\n  float v3=o1720797_input_mfsdf(vec4(p+e.yxy,0.0), _seed_variation_).w;\n  float v4=o1720797_input_mfsdf(vec4(p+e.xxx,0.0), _seed_variation_).w;\n  return normalize(vec3(v4+v1-v3-v2,v3+v4-v1-v2,v2+v4-v3-v1));\n}\n\nvoid raymarch_o1720797(in vec3 o,in vec3 v,out vec3 p,inout float d, float _seed_variation_) {\n  float s;\n  for(int i=0;i<512;i++){\n    p=o+v*d;\n    s=o1720797_input_mfsdf(vec4(p,0.0), _seed_variation_).w;\n    if (abs(s)<0.0001) break;\n    d+=s;\n    if (d>p_o1720797_MaxDistance) break;\n  } \n}\n\nvec3 pathtracing(inout uint rngState, vec2 uv) {\n    float _seed_variation_=0.0;\n\n    float iTime1=iTime+18.0;\n    \n\tvec3 o=vec3((-0.943+sin(iTime1*0.1)*2.0),(-2.725-sin(iTime1*0.2)*0.5),(2.943+sin(iTime1*0.12)*0.5))*(cos(iTime1*0.11)*0.5+1.0); \n    vec3 t=vec3((-1.0+sin(iTime1*0.1)*0.5),p_o1720797_LookAtY,(0.1+sin(iTime1*0.12)*0.5));\n    vec3 u=vec3(0.0,1.0,0.0);\n    vec3 c=normalize(t-o);\n    vec3 cx=normalize(cross(u,c));\n    vec3 cy=normalize(cross(cx,c));\n\n\t    vec3 v=normalize(c*p_o1720797_CamD+cx*uv.x+cy*uv.y);\n\n\t    vec3 p;\n\t    float d=0.01;\n\t    vec3 rgb=vec3(1.0);\n\t    vec3 io=o;\n\t    int i;\n\n\t    for(i=0;i<5;i++){\n\t    \n\t        raymarch_o1720797(io,v,p,d, _seed_variation_);\n\t        \n\t        vec3 n=normal_o1720797(p, _seed_variation_);\n\t        \n\t        //View direction to tangent space\n\t        vec3 ot;vec3 ob;pathtracing_Onb(n,ot,ob);\n\t        vec3 vt=vec3(dot(-v,ot),dot(-v,ob),dot(-v,n));\n\t\t\n\t        if (d<p_o1720797_MaxDistance){\t\n\t        //if (length(p-o)<p_o1720797_MaxDistance){\n\t        vec3 obj_Emission=o1720797_input_mfsdf(vec4(p,13.0), _seed_variation_).rgb;\n\t        \n\t        if ((obj_Emission.x+obj_Emission.y+obj_Emission.z)>0.001){\n\t            rgb=obj_Emission*rgb;\n\t            break;\n\t        } else {\n\t            float s=pathtracing_RandomFloat01(rngState);\n\t\t\t\t\n\t            vec3 obj_BaseColor=o1720797_input_mfsdf(vec4(p,1.0), _seed_variation_).rgb; // 1 - BaseColor  (r,g,b,sdf)\n\t            float obj_Metallic=clamp(o1720797_input_mfsdf(vec4(p,2.0), _seed_variation_).x,0.0,1.0);   // 2 - Metallic   (v,0,0,sdf)\n\t            float obj_Specular=clamp(max(o1720797_input_mfsdf(vec4(p,4.0), _seed_variation_).x,obj_Metallic),0.0,1.0);   // 4 - Specular   (v,0,0,sdf)\n\t            float obj_Roughness=o1720797_input_mfsdf(vec4(p,5.0), _seed_variation_).x;  // 5 - Roughness  (v,0,0,sdf)\n\n\t            if (s>obj_Specular*obj_Specular*0.5){\n\t                rgb=(obj_BaseColor-obj_BaseColor*obj_Metallic)*rgb;\n\t                v=pathtracing_cosineSampleHemissphere(rngState,n);\n\t            } else {\n\n\t                float r2=obj_Roughness*obj_Roughness*0.5;\n\t                vec3 vndf=pathtracing_SampleGGXVNDF(rngState,vt,r2,r2);\n\t                vec3 nv=reflect(-vt,vndf);\n\n\t                //Sample direction back to camera space\n\t                nv=nv.x*ot+nv.y*ob+nv.z*n;\n\n\t                float FH=pathtracing_schlickWeight(dot(n,nv));\n\t\t\t\t\tvec3 Cspec0=mix(vec3(obj_Specular*0.25),obj_BaseColor,obj_Metallic);\n\t                vec3 Fs=mix(Cspec0,vec3(1.0),FH);\n\t                rgb=Fs*rgb;\n\t                \n\t                v=nv;\n\t            }\n\t            io=p;\n\t            d=0.01;\n\t        }\n\t        } else {\n\t        rgb*=o1720797_input_hdri(pathtracing_equirectangularMap(v.xzy), _seed_variation_).xyz;\n\t        break;\n\t        }\n\t    }//for(int i\n\t    if (i==5) rgb=vec3(0.0);//did not hit any light source\n\n\t\treturn max(rgb,vec3(0));\n\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n\n    // Initialize random number generator state\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + \n                         uint(fragCoord.y) * uint(9277) + \n                         uint(iFrame) * uint(26699)) | uint(1);\n\n    // Calculate jittered pixel coordinates\n    vec2 xy = fragCoord + vec2(pathtracing_RandomFloat01(rngState), pathtracing_RandomFloat01(rngState));\n\n    // Calculate UV coordinates\n    vec2 UV=(xy-iResolution.xy/2.0)/iResolution.y;\n    UV.y=-UV.y;\n\n    // Perform path tracing\n    vec3 rgb = pathtracing(rngState, UV);\n\n\n    vec4 lastframe=vec4(texture(iChannel0, fragCoord / iResolution.xy));\n    fragColor = lastframe*0.80+vec4(rgb, 1)*0.2;\n\n}\n\n","name":"Buffer A","description":"","type":"buffer"}]}