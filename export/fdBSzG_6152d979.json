{"ver":"0.1","info":{"id":"fdBSzG","date":"1620419448","viewed":59,"name":"Cards of shadows","username":"Marina033","description":"many balls","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 CAMERA_POS = vec3(0, 4, -20);\n\nbool floorTrace(vec3 pos, vec3 dir, inout float t, inout vec3 normal, inout vec3 color) \n//inout - it is like ref in c++\n{\n    float floorT = floorTrace(pos, dir);\n    if (floorT >= t) return false;\n    \n    t = floorT;\n    normal = vec3(0, 1, 0);\n    color = vec3(1, 0, 0);\n    return true;\n}\n\nbool spheresTrace(vec3 pos, vec3 dir, inout float t, inout vec3 normal, inout vec3 color) {\n    bool intersected = false;\n    for (int i = 0; i < SPHERES_COUNT; i++) {\n        for (int j = 0; j < SPHERES_COUNT; j++) {\n            float sphereRad = 0.5 / float(i + 1);\n            sphereRad = abs(sin(float(i + j))) * 0.35;\n            vec3 spherePos = vec3(i - SPHERES_COUNT / 2, sphereRad, j - SPHERES_COUNT / 2);\n            vec2 rot1 = vec2(cos(iTime), -sin(iTime));\n            vec2 rot2 = vec2(sin(iTime), cos(iTime));\n            spherePos.xz = vec2(dot(spherePos.xz, rot1), dot(spherePos.xz, rot2));  \n            float sphere_t = sphereTrace(pos - spherePos, dir, sphereRad);\n            if (sphere_t == INF || sphere_t > t)\n                continue;\n            intersected = true;\n            t = sphere_t;\n            vec3 worldPos = pos + t * dir;\n            normal = normalize(worldPos - spherePos);\n            color = vec3(0, textureLod(iChannel0, normal, 8.0).g, 0);\n        }\n    }\n    return intersected;\n}\n\nfloat GetShadow(float z, vec2 uv) {\n    return 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.x;\n    vec3 forward = normalize(-CAMERA_POS);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(forward, up));\n    up = cross(right, forward);\n    vec3 viewVec = normalize(forward + up * uv.y + right * uv.x);\n    \n    float t = INF;\n    vec3 normal;\n    vec3 color;\n    bool inter;\n    vec3 worldPos;\n    \n    inter = floorTrace(CAMERA_POS, viewVec, t, normal, color);\n    inter = spheresTrace(CAMERA_POS, viewVec, t, normal, color) || inter;\n    if (inter == true) {\n        worldPos = CAMERA_POS + t * viewVec;\n        vec3 toLight = LIGHT_POS - worldPos;\n        vec3 toPoint = normalize(-toLight);\n        vec3 lightForward = normalize(-LIGHT_POS);\n        fragColor.rgb = color * max(0.0, dot(normal, normalize(toLight)));\n    }\n    else fragColor = texture(iChannel0, viewVec);\n    \n    uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel1, uv) / 10.0;\n    \n    \n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float INF = 1e10;\nconst vec3 LIGHT_POS = vec3(0, 5, 5);\nconst int SPHERES_COUNT = 5;\n\nfloat floorTrace(vec3 pos, vec3 dir)\n{\n    // (pos + t * dir) = 0 of y\n    float t = - pos.y / dir.y;\n    if (t < 0.0) return INF;\n    vec3 worldPos = pos + t * dir;\n    if (abs(worldPos.x) + abs(worldPos.z) > 5.0) return INF;\n    \n    \n    return t;\n}\n\nfloat sphereTrace(vec3 pos, vec3 dir, float r) {\n    // pos = pos - spherePos\n    float a = dot(dir, dir);\n    float b = dot(pos, dir);\n    float c = dot(pos, pos) - r * r;\n    float d = b * b - a * c;\n    if (d < 0.0) return INF;\n    float t = -b - sqrt(d);\n    if (t > 0.0) {\n        //normal = normalize(pos + t * dir);\n        return t;\n    }\n    t = -b + sqrt(d);\n    if (t < 0.0) return INF;\n    return t;\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float spheresTrace(vec3 pos, vec3 dir) {\n    float t = INF;\n    for (int i = 0; i < SPHERES_COUNT; ++i) {\n        for (int j = 0; j < SPHERES_COUNT; ++j) {\n            float sphereRad = 0.5 / float(i + 1);\n            sphereRad = abs(sin(float(i + j))) * 0.35;\n            vec3 spherePos = vec3(i - SPHERES_COUNT / 2, sphereRad, j - SPHERES_COUNT / 2);\n            vec2 rotate = vec2(sin(iTime), cos(iTime));\n            spherePos.xz = vec2(dot(spherePos.xz, rotate), dot(spherePos.xz, rotate.yx * vec2(-1, 1)));\n            float sphere_t = sphereTrace(pos - spherePos, dir, sphereRad);\n            if (sphere_t == INF || sphere_t > t) {\n                continue;\n            }\n            t = sphere_t;\n        }\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.x;\n    vec3 forward = normalize(-LIGHT_POS);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(forward, up));\n    up = cross(right, forward);\n    vec3 viewVec = normalize(forward + up * uv.y + right * uv.x);\n    \n    float t = INF;\n    vec3 normal;\n    vec3 color;\n    bool inter;\n    vec3 worldPos;\n    \n    t = floorTrace(LIGHT_POS, viewVec);\n    t = min(t, spheresTrace(LIGHT_POS, viewVec));\n    \n    fragColor = vec4(t);\n    \n  \n}","name":"Buffer A","description":"","type":"buffer"}]}