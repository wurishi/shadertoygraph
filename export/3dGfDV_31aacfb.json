{"ver":"0.1","info":{"id":"3dGfDV","date":"1607952737","viewed":50,"name":"Sphere and Plane","username":"Suika","description":"a","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["a"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Ray\n{\n    vec3 position;\n    vec3 direction;\n};\n\nstruct Intersection\n{\n    bool hit;\n    vec3 position;\n    vec3 color;\n    float k;\n};\n\nstruct Sphere\n{\n    vec3 position;\n    vec3 color;\n    float radius;\n};\n\nstruct Plane\n{\n    vec3 position;\n    vec3 normal;\n};\n\nstruct Light\n{\n    vec3 direction;\n};\n\nIntersection I_Sphere(Ray ray, Sphere sphere, Light light)\n{\n    vec3 rs = ray.position - sphere.position;\n    float drs = dot(ray.direction, rs);\n    float dd = dot(ray.direction, ray.direction);\n    float D4 = drs*drs - dd*(dot(rs, rs) - sphere.radius*sphere.radius);\n    Intersection i;\n    i.color = vec3(0.0);\n    float k = (-drs-sqrt(D4))/dd;\n    i.hit = k >= 0.0;\n    i.position = ray.position + k*ray.direction;\n    i.k = k;\n    vec3 normal = normalize(i.position - sphere.position);\n    i.color = sphere.color * clamp(-dot(normal, light.direction), 0.0, 1.0);\n    return i;\n}\n\nIntersection I_Plane(Ray ray, Sphere sphere, Plane plane, Light light)\n{\n    float dn = dot(ray.direction, plane.normal);\n    Intersection i;\n    i.hit = false;\n    i.color = vec3(0.0);\n    if (dn != 0.0)\n    {\n        float k = dot(plane.position - ray.position, plane.normal)/dn;\n        i.hit = k >= 0.0;\n        i.position = ray.position + k*ray.direction;\n        i.k = k;\n        int mx = int(mod(i.position.x, 2.0) < 1.0);\n        int mz = int(mod(i.position.z, 2.0) < 1.0);\n        if ((mx + mz) % 2 == 1) i.color = vec3(0.5);\n        else                    i.color = vec3(0.25);\n        Ray test;\n        test.position = i.position;\n        test.direction = -light.direction;\n        Intersection shadow = I_Sphere(test, sphere, light);\n        if (shadow.hit) i.color -= vec3(0.20);\n    }\n    return i;\n}\n\nIntersection I_Scene(Ray ray, Sphere sphere, Plane plane, Light light)\n{\n    Intersection i[2];\n    i[0] = I_Plane(ray, sphere, plane, light);\n    i[1] = I_Sphere(ray, sphere, light);\n    \n    Intersection result;\n    result.hit = false;\n    result.color = vec3(0.0);\n    result.k = 1000000000.0;\n    for (int n = 0; n < 2; ++n)\n    {\n        if (i[n].hit)\n        {\n            if (i[n].k < result.k)\n            {\n                result = i[n];\n            }\n        }\n    }\n    return result;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    Ray eye;\n    eye.position = vec3(0.0, 0.0, -1.0);\n    eye.direction = normalize(vec3(uv.x, uv.y, 0.0) - eye.position);\n    Light light;\n    light.direction = normalize(vec3(1.0, -1.0, 1.0));\n    Plane plane;\n    plane.position = vec3(0.0, -1.0, 0.0);\n    plane.normal = normalize(vec3(0.0, 1.0, 0.0));\n    Sphere sphere;\n    sphere.position = vec3(0.0, sin(iTime), 2.0);\n    sphere.color = vec3(1.0);\n    sphere.radius = 1.0;\n    Intersection i;\n    i = I_Scene(eye, sphere, plane, light);\n    fragColor = vec4(i.color, 1.0);\n}","name":"Image","description":"","type":"image"}]}