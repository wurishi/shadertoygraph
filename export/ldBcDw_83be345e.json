{"ver":"0.1","info":{"id":"ldBcDw","date":"1492327059","viewed":104,"name":"cube has evolev","username":"floopfloop","description":"o no","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["cube","edgerendering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv_position = (iResolution.xy - 2.0*fragCoord.xy) / iResolution.y;\n    \n    float xmod = 0.0;//sin(iTime * 1.25) * 0.75;\n    float ymod = 0.0;//cos(iTime * 2.5) * 0.25;\n    float zmod = cos(iTime * 1.75);\n    \n    vec3 velocity = vec3(xmod, ymod, zmod);\n    \n    vec3 position = (vec3(0.5, 0.5, 1.0) * vec3(uv_position, 1.0)) + velocity;\n    vec3 bounds = vec3(0.1, 0.1, 0.1) * position.z;\n\n    float cubic_field = length(max(abs(vec2(position))-vec2(bounds),0.0));\n    \n\t// sharpness is hard to control in general, its relationship\n    // with field should be defined better somehow\n    \n    // It's really interesting to have a slight breathing-esque animation to\n    // the fields though. Makes things feel more alive and less clinical.\n    float sharpness = (sin(iTime*1.25)*0.25 + 1.) * 1000.;\n    \n    // And somehow I've made edge rendering. Cool.\n    float technique = 1./(1.0-cubic_field * sharpness);\n    \n    fragColor = vec4(\n        1.0 + technique, \n        0.75 + technique, \n        0.6 + technique, \n        technique\n    );\n}","name":"Image","description":"","type":"image"}]}