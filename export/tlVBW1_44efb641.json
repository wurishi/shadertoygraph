{"ver":"0.1","info":{"id":"tlVBW1","date":"1614283787","viewed":82,"name":"My first ray tracing","username":"DosU","description":"Thanks to Roman Petrov's tutorial: https://medium.com/@megus/creativity-through-limitation-shadertoy-7dc3fa80c14e","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raytracingmouse3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define COUNT 12\n#define SIZE 2\n\n#define LIGHT_POWER 80.\n#define SPECULAR_POWER 20.\n#define AMBIENT .3\n\nvec4 spheres[] = vec4[COUNT * SIZE](\n    // Spheres: center and radius, color, movement speed, movement amplitude\n    // Light source\n    vec4(0., 0., 35., 0.25), vec4(1., 1., 1., 1.),\n    // 1.1\n    vec4(-3, 2.595, 40, 0.5), vec4(1., 0., 0., 1.),\n    // 1.2\n    vec4(-1, 2.595, 40, 0.5), vec4(.66, .33, 0., 1.),\n    // 1.3\n    vec4(1, 2.595, 40, 0.5), vec4(.33, .66, 0., 1.),\n    // 1.4\n    vec4(3, 2.595, 40, 0.5), vec4(0., 1., 0., 1.),\n    // 2.1\n    vec4(-2., 0.865, 40, 0.5), vec4(.66, .33, .33, 1.),\n    // 2.2\n    vec4(0., 0.865, 40, 0.5), vec4(.55, .55, .33, 1.),\n    // 2.3\n    vec4(2., 0.865, 40, 0.5), vec4(.33, .66, .33, 1.),\n    // 3.1\n    vec4(-1, -0.865, 40, 0.5), vec4(.33, 0., .66, 1.),\n    // 3.2\n    vec4(1, -0.865, 40, 0.5), vec4(0., .33, .66, 1.),\n    // 4.1\n    vec4(0, -2.595, 40, 0.5), vec4(0., 0., 1., 1.),\n    // \"Floor\"\n    vec4(0, 0, 800050, 800000), vec4(1.7, 1.0, .7, 1)\n);\nvec2 vel = vec2(0., 0.);\nvec2 acc = vec2(0., 0.);\nfloat oldTime = 0.;\n\nfloat random[] = float[20]( 0.95, 0.34, 0.25, 0.15, 0.91,\n                      0.55, 0.34, 0.67, 0.23, 0.38,\n                      0.12, 0.34, 0.89, 0.57, 0.11,\n                      0.98, 0.95, 0.45, 0.24, 0.87);\nint randIndex = 0;\nfloat rand() {\n    if(randIndex > 19) randIndex = 0;\n    else randIndex++;\n    return random[randIndex];\n}\n\n// Calculate a moving sphere center\nvec3 sphereCenter(int sphere) {\n    if(sphere != 0){\n        return spheres[sphere * SIZE].xyz;\n    } else {\n        //if (oldTime == 0.0){\n          //  acc.x = rand();\n            //acc.y = rand();\n            //oldTime = iTime;\n        //} else{\n            //float t = iTime - oldTime;\n            //oldTime = iTime;\n            //spheres[0].x += vel.x*t+acc.x*t*t/2.0;\n            //spheres[0].y += vel.y*t+acc.y*t*t/2.0;\n            //vel.x += acc.x*t;\n            //vel.y += acc.y*t;\n            //if(spheres[0].x > 3.0){\n                //acc.x -= rand()/10.;\n            //}else if(spheres[0].x < 3.0){\n            //    acc.x += rand()/10.;\n            //} else {\n            //    acc.x += rand()/10.-0.5;\n            //}\n            //if(spheres[0].y > 3.0){\n            //    acc.y -= rand()/10.;\n            //}else if(spheres[0].y < 3.0){\n            //    acc.y += rand()/10.;\n            //} else {\n            //    acc.y += rand()/10.-0.5;\n            //}\n        //}\n    }\n    return spheres[sphere * SIZE].xyz;\n}\n\n// Find a nearest ray-sphere intersection\n// o - ray origin\n// l - ray direction (normalized)\n// ignore - sphere to ignore when detecting intersection (used for shadows)\n// d - distance output\n// Returns sphere number, -1 if no intersection found\nint findIntersection(vec3 o, vec3 l, int ignore, out float d) {\n    int sphere = -1;\n    d = 1e5;\n    \n    for (int i = 0; i < COUNT; i++) {\n        if (i == ignore) {\n            continue;\n        }\n        vec3 c = sphereCenter(i);\n        float r = spheres[i * SIZE].w;\n\n        // Ray-sphere intersection formula\n        vec3 t1 = o - c;\n        float t1l = length(t1);\n        float t2 = dot(l, t1);\n        float s = t2 * t2 - t1l * t1l + r * r;\n        if (s >= 0.) {\n            float ss = sqrt(s);\n            float sd = min(-t2 + ss, -t2 - ss);\n            if (sd >= 0. && sd < d) {\n                sphere = i;\n                d = sd;\n            }\n        }\n    }\n    return sphere;\n}\n\n// Trace a single ray\n// camO - camera origin\n// camL - camera ray direction (normalized)\n// Returns a fragment color\nvec3 trace(vec3 camO, vec3 camL) {\n    float d = 0.;\n    int sphere = findIntersection(camO, camL, -1, d);\n    \n    if (sphere == -1) {\n        // There was no intersection, return background color\n        return vec3(0, 0, 0);\n    }\n    \n    vec3 lightColor = spheres[1].xyz;\n\n    if (sphere == 0) {\n        // It's a light source, don't need to shade it\n        return lightColor;\n    }\n    \n    vec3 lightPoint = sphereCenter(0);\n    \n    // Sphere color\n    vec3 sColor = spheres[sphere * SIZE + 1].xyz;\n    vec3 aColor = sColor * vec3(AMBIENT, AMBIENT, AMBIENT);\n\n    // Intersection point\n    vec3 iPoint = camO + camL * d;\n    vec3 iNormal = normalize(iPoint - sphereCenter(sphere));\n\n    // Light direction vector\n    vec3 lightDir = normalize(lightPoint - iPoint);\n    \n    // Check if there's another sphere between this one and the light source\n    float dShadow = 0.;\n    int shadowedBy = findIntersection(iPoint, lightDir, sphere, dShadow);\n    dShadow = float(shadowedBy + 1) / 5.0;\n    if (shadowedBy != 0) {\n        // We're under shadow, use ambient color\n        return aColor;\n    }\n    \n    // Lighting (diffusion and specular)\n    float cosA = clamp(dot(iNormal, lightDir), 0., 1.);\n    float cosS = clamp(dot(-camL, reflect(-lightDir, iNormal)), 0., 1.);\n\n    float dSquared = pow(length(iPoint - lightPoint), 2.);\n    \n    return aColor +\n        sColor * lightColor * cosA * LIGHT_POWER / dSquared +\n        lightColor * pow(cosS, SPECULAR_POWER) * LIGHT_POWER / dSquared;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n    m = m * 2.0 - 1.0;\n    m.x *= iResolution.x / iResolution.y;\n    m = m * 5.08;\n    spheres[0].xy = m.xy;\n    \n    // Camera\n    vec3 camO = vec3(0, 0, 0);\n    vec3 camL = normalize(vec3(uv.x, uv.y, 7));\n    \n    spheres[0].z = 34. + 5.*cos(iTime);\n    spheres[1].x = 0.7 + 0.3*sin(iTime);\n    spheres[1].y = 0.7 + 0.3*cos(iTime);\n    spheres[1].z = 0.7 + 0.3*(2. - sin(iTime) + cos(iTime))/2.;\n    \n    // Ray-tracing\n    fragColor = vec4(trace(camO, camL), 1.);      \n}","name":"Image","description":"","type":"image"}]}