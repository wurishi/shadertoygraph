{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"/* Compiled with Shaderforth: https://github.com/daeken/Shaderforth\n:globals\n\t@vec3 uniform =iResolution\n\t@float uniform =iTime\n\t@vec4 uniform =iDate\n;\n:m gtime iTime ;\n\n:m overlap 5 ;\n\n: split ( p:vec2 time:float -> vec3 )\n\tp cart->polar =pol\n\t[\n\t\t\tpol .y 10 / time 7.1 / + sin 10 /\n\t\t\tpol .y 100 * sin 350 /\n\t\t+\n\t\t0\n\t] pol + pi 2 * mod =pol\n\tpol .x 60 deg->rad mod 30 deg->rad - 30 deg->rad / =dist\n\n\t0 =top\n\t{ dist 30 overlap + deg->rad 30 deg->rad / / =dist 1 =top }\n\t{\n\t\t{ dist 30 overlap - deg->rad 30 deg->rad / / =dist }\n\t\t{\n\t\t\t\t1 dist abs - 1 + dist sign neg *\n\t\t\t\t30 overlap + deg->rad 30 deg->rad /\n\t\t\t/ =dist\n\t\t\t1 =top\n\t\t} dist abs 30 overlap - deg->rad 30 deg->rad / < if\n\t}\n\tpol .x 120 deg->rad mod 60 deg->rad >= if\n\n\t[\n\t\tdist abs\n\t\tpol .y\n\t\ttop\n\t]\n;\n\n: warp ( ip:vec3 time:float -> vec3 )\n\tip [\n\t\ttime 5 / ip .y + sin 10 /\n\t\t\ttime 3.7 / ip .x + sin 100 /\n\t\t\t1 ip .z - 75 /\n\t\t+\n\t\t0\n\t] +\n;\n\n:m matunion { .x } amin ;\n\n: shape ( to:float p:vec2 -> vec2 )\n\tgtime to + =time\n\n\tp time split time warp =flower\n\n\t[\n\t\tflower .y 1 flower .x 2 / - -\n\t\tflower .x\n\t]\n;\n\n: shape-deriv ( p:vec2 -> float )\n\t$[-.1:+.1:.05] !size =>len\n\t\t/{ p shape .x }\n\t\\+ len /\n;\n\n:m petal-color [ .95 .95 0 ] ;\n:m interior-color [ 1 .8 0 ] ;\n:m stamen-color [ 1 1 0 ] ;\n\n:m earth-color [ .67 .30 .05 ] ;\n:m leaf-color [ .10 .39 .08 ] ;\n:m stem-color [ .10 .70 .06 ] ;\n\n: background ( p:vec2 -> vec3 )\n\t\t{ [\n\t\t\tstem-color\n\t\t\tp .x p .y + 7.1 * sin abs .3 * .7 +\n\t\t\tp .x 3.7 * sin abs .5 * .5 +\n\t\t\tp .x 57 * p .y 13 * + sin abs .1 * .9 +\n\t\t\tp .x 2 * .5 +\n\t\t] /abs \\* }\n\t\t{ [\n\t\t\t[\n\t\t\t\tearth-color\n\t\t\t\tp .x p .y .3 + * sin\n\t\t\t\tp .x 3.7 * p .y -1.1 * + gtime 3.7 / + sin\n\t\t\t] /abs \\*\n\t\t\t[\n\t\t\t\tleaf-color\n\t\t\t\tp .x p .y .7 * + gtime 7.9 / + sin\n\t\t\t\tp .y 3.7 * sin\n\t\t\t] /abs \\*\n\t\t] /{ 0 1 clamp } \\+ }\n\t\t\tp .x p .y .3 gtime 3.7 / sin .05 * + * + abs p .y 7.9 * sin .02 * + .1 <\n\t\t\tp .y 0 <\n\t\tand if\n;\n\n: texture ( d:float p:vec2 -> vec3 )\n\t{ gtime split .x } p gradient =dist\n\tp gtime split gtime warp =flower\n\tp cart->polar =pol\n\t\t{\n\t\t\t[\n\t\t\t\tpetal-color\n\t\t\t\td neg 500 * 0 1 clamp\n\t\t\t\tdist 90 * pol .y pol .x 79 * sin * * 1 pol .y - 20 * + sin abs .05 * .95 +\n\t\t\t\tflower .z .9 + 0 1 clamp\n\t\t\t] \\*\n\t\t\td sign 1 + 2 / p background *\n\t\t+ }\n\t\t{\n\t\t\t\t{ [\n\t\t\t\t\tinterior-color\n\t\t\t\t\t.5 1 pol .y 5 * smoothstep .2 +\n\t\t\t\t\tpol .x 13 * sin pol .x 9 * sin * abs .1 * .9 +\n\t\t\t\t] \\* }\n\t\t\t\t{ [\n\t\t\t\t\tstamen-color\n\t\t\t\t\tpol .y 137 * sin pol .x 17 * sin * abs .7 * .3 +\n\t\t\t\t] \\* }\n\t\t\t\tpol .y .05 >\n\t\t\tif\n\t\t}\n\t\tpol .y pol .x p .x + 17 * sin .01 * .3 + >\n\tif\n;\n\niResolution frag->position =p\n&shape-deriv p gradient p texture ->fragcolor\n*/\n\nvec3 background(vec2 p) {\n\tvec3 temp_11;\n\tif((((abs(((p).x) + (((p).y) * (0.3 + ((sin((iTime) / 3.7)) * 0.05))))) + ((sin(((p).y) * 7.9)) * 0.02)) < 0.1) && (((p).y) < 0.0)) {\n\t\ttemp_11 = ((((abs(vec3(0.1, 0.7, 0.06))) * (abs(((abs(sin((((p).x) + ((p).y)) * 7.1))) * 0.3) + 0.7))) * (abs(((abs(sin(((p).x) * 3.7))) * 0.5) + 0.5))) * (abs(((abs(sin((((p).x) * 57.0) + (((p).y) * 13.0)))) * 0.1) + 0.9))) * (abs((((p).x) * 2.0) + 0.5));\n\t} else {\n\t\ttemp_11 = (clamp(((abs(vec3(0.67, 0.3, 0.05))) * (abs(sin(((p).x) * (((p).y) + 0.3))))) * (abs(sin(((((p).x) * 3.7) + (((p).y) * -1.1)) + ((iTime) / 3.7)))), 0.0, 1.0)) + (clamp(((abs(vec3(0.1, 0.39, 0.08))) * (abs(sin((((p).x) + (((p).y) * 0.7)) + ((iTime) / 7.9))))) * (abs(sin(((p).y) * 3.7))), 0.0, 1.0));\n\t}\n\treturn temp_11;\n}\nvec3 warp(vec3 ip, float time) {\n\treturn (ip) + (vec3((sin(((time) / 5.0) + ((ip).y))) / 10.0, ((sin(((time) / 3.7) + ((ip).x))) / 100.0) + ((1.0 - ((ip).z)) / 75.0), 0.0));\n}\nvec2 cart_polar(vec2 p) {\n\treturn vec2(atan((p).y, (p).x), length(p));\n}\nvec3 split(vec2 p, float time) {\n\tfloat dist;\n\tfloat top;\n\tvec2 pol = cart_polar(p);\n\tpol = mod((vec2(((sin((((pol).y) / 10.0) + ((time) / 7.1))) / 10.0) + ((sin(((pol).y) * 100.0)) / 350.0), 0.0)) + (pol), 6.28318);\n\tdist = ((mod((pol).x, 1.04719666667)) - 0.523598333333) / 0.523598333333;\n\ttop = 0.0;\n\tif((mod((pol).x, 2.09439333333)) >= 1.04719666667) {\n\t\tdist = (dist) / 1.16666666667;\n\t\ttop = 1.0;\n\t} else {\n\t\tif((abs(dist)) < 0.833333333333) {\n\t\t\tdist = (dist) / 0.833333333333;\n\t\t} else {\n\t\t\tdist = (((1.0 - (abs(dist))) + 1.0) * (- (sign(dist)))) / 1.16666666667;\n\t\t\ttop = 1.0;\n\t\t}\n\t}\n\treturn vec3(abs(dist), (pol).y, top);\n}\nvec2 shape(float to, vec2 p) {\n\tfloat time = (iTime) + (to);\n\tvec3 flower = warp(split(p, time), time);\n\treturn vec2(((flower).y) - (1.0 - (((flower).x) / 2.0)), (flower).x);\n}\nvec3 texture(float d, vec2 p) {\n\tvec3 temp_36;\n\tvec3 temp_32;\n\tvec2 h = vec2(1e-05, 0.0);\n\tfloat dist = ((split(p, iTime)).x) / (abs(length((vec2(((split((p) + (h), iTime)).x) - ((split((p) - (h), iTime)).x), ((split((p) + ((h).yx), iTime)).x) - ((split((p) - ((h).yx), iTime)).x))) / (2.0 * ((h).x)))));\n\tvec3 flower = warp(split(p, iTime), iTime);\n\tvec2 pol = cart_polar(p);\n\tif(((pol).y) > (((sin((((pol).x) + ((p).x)) * 17.0)) * 0.01) + 0.3)) {\n\t\ttemp_32 = ((((vec3(0.95, 0.95, 0.0)) * (clamp((- (d)) * 500.0, 0.0, 1.0))) * (((abs(sin((((dist) * 90.0) * (((pol).y) * (sin(((pol).x) * 79.0)))) + ((1.0 - ((pol).y)) * 20.0)))) * 0.05) + 0.95)) * (clamp(((flower).z) + 0.9, 0.0, 1.0))) + ((((sign(d)) + 1.0) / 2.0) * (background(p)));\n\t} else {\n\t\tif(((pol).y) > 0.05) {\n\t\t\ttemp_36 = ((vec3(1.0, 0.8, 0.0)) * ((smoothstep(0.5, 1.0, ((pol).y) * 5.0)) + 0.2)) * (((abs((sin(((pol).x) * 13.0)) * (sin(((pol).x) * 9.0)))) * 0.1) + 0.9);\n\t\t} else {\n\t\t\ttemp_36 = (vec3(1.0, 1.0, 0.0)) * (((abs((sin(((pol).y) * 137.0)) * (sin(((pol).x) * 17.0)))) * 0.7) + 0.3);\n\t\t}\n\t\ttemp_32 = temp_36;\n\t}\n\treturn temp_32;\n}\nfloat shape_deriv(vec2 p) {\n\treturn ((((((shape(-0.1, p)).x) + ((shape(-0.05, p)).x)) + ((shape(0.0, p)).x)) + ((shape(0.05, p)).x)) + ((shape(0.1, p)).x)) / 5.0;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p = (((((fragCoord).xy) / ((iResolution).xy)) * 2.0) - 1.0) * (vec2(((iResolution).x) / ((iResolution).y), 1.0));\n\tvec2 h = vec2(1e-05, 0.0);\n\tfragColor = vec4(texture((shape_deriv(p)) / (abs(length((vec2((shape_deriv((p) + (h))) - (shape_deriv((p) - (h))), (shape_deriv((p) + ((h).yx))) - (shape_deriv((p) - ((h).yx))))) / (2.0 * ((h).x))))), p), 1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lsSXz3","date":"1414254998","viewed":200,"name":"Daffodil","username":"daeken","description":"My first attempt at simulating something organic.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["flower","shaderforth"],"hasliked":0,"parentid":"","parentname":""}}