{"ver":"0.1","info":{"id":"MldSWN","date":"1479755448","viewed":199,"name":"spicy metaballs","username":"halcy","description":"with metasauce\n\n","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["balls"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// TODO metanoodles\n\n// Various knobs to twiddle\n#define MIN_DIST 0.01\n#define STEP_MULTIPLIER 0.9\n#define NORMAL_OFFSET 0.01\n#define MAX_STEPS 128\n#define MAX_STEPS_SHADOW 64\n#define SHADOW_OFFSET 0.02\n#define SHADOW_HARDNESS 32.0\n\n// Trefoil knot positions\nvec3 trefoil(float t) {\n\treturn vec3(\n        sin(t) + 2.0 * sin(2.0 * t),\n        cos(t) - 2.0 * cos(2.0 * t),\n        -sin(3.0 * t)\n    );\n}\n\n// Distance / color combiner\nvec4 distcompose(vec4 dista, vec4 distb, float softness) {\n    float mixfact = clamp(0.5 + 0.5 * (distb.a - dista.a) / softness, 0.0, 1.0);\n    return mix(distb, dista, mixfact) - vec4(0.0, 0.0, 0.0, softness * mixfact * (1.0 - mixfact));\n}\n\n// World\nvec4 distfunc(vec3 pos) {\n  \tvec4 box = vec4(0.0);\n    box.xyz = vec3(0.3);\n    box.a = min(min(pos.y, -abs(pos.z) + 2.0), -abs(pos.x) + 2.0);;\n    \n    vec4 dist = box;\n    \n    for(int i = 0; i < 3; i++) {\n    \tvec3 ballPos = trefoil(iTime * float(i + 1)) * 0.2;\n        if(i == 1) {\n        \tballPos = ballPos.zxy;  \n        }\n        \n        if(i == 2) {\n        \tballPos = ballPos.zxy;  \n        } \n       \tballPos.y += 1.2;\n       \t\n        vec3 noiseCoords = normalize(ballPos - pos);\n        float radius = 0.3;\n        \n        vec3 ballbase = vec3(185.0 / 255.0, 122.0 / 255.0, 87.0 / 255.0);\n        vec3 ballsauce = vec3(0.7, 0.15, 0.1);\n        vec3 ballcol = ballbase;\n        if(noiseCoords.y < -0.1 + sin((noiseCoords.x + float(i) * 20.0) * 20.0) * 0.03) {\n            ballcol = ballsauce;\n            radius += 0.02;\n        }\n        else {\n        \tradius += texture(iChannel0, noiseCoords.xyz).r * 0.005;\n        \tradius += texture(iChannel0, noiseCoords.zxy).r * 0.005;\n        \tradius += texture(iChannel0, noiseCoords.yzx).r * 0.005;   \n        }\n        vec4 ball = vec4(ballcol, length(ballPos - pos) - radius);\n        dist = distcompose(dist, ball, 0.3);\n    }\n \n    return(dist);\n}\n\n// Renderer\nvec4 pixel(vec2 fragCoord) {\n    // Screen -1 -> 1 coordinates\n    vec2 coords = (2.0 * fragCoord.xy  - iResolution.xy) / max(iResolution.x, iResolution.y);\n    \n    // Set up time dependent stuff\n    float wobble = sin(iTime * 0.2) * 4.8;    \n    vec3 lightpos = vec3(sin(wobble) * -1.75, 1.4 + cos(iTime * 0.3) + 2.0, cos(wobble) * -1.75);\n    \n    // Camera as eye + imaginary screen at a distance\n    vec3 eye = lightpos;\n    eye.y -= 2.0;\n    vec3 lookat = vec3(0.0, 1.0, 0.0);\n    vec3 lookdir = normalize(lookat - eye);\n    vec3 left = normalize(cross(lookdir, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(left, lookdir));\n    vec3 lookcenter = eye + lookdir;\n\tvec3 pixelpos = lookcenter + coords.x * left + coords.y * up;\n    vec3 ray = normalize(pixelpos - eye);\n    \n    // March\n    vec3 pos = eye;\n    float dist = 0.0;\n    float curdist = 1.0;\n    float iters = float(MAX_STEPS);\n    for(int i = 0; i < MAX_STEPS; i++) {\n        curdist = distfunc(pos).a;\n        dist += curdist * STEP_MULTIPLIER;\n        pos = eye + ray * dist;\n        if(curdist < MIN_DIST) {\n        \titers = float(i);\n            break;\n        }\n    }\n    \n\t// Finite-difference normals\n   \tvec2 d = vec2(NORMAL_OFFSET, 0.0);\n    vec3 normal = normalize(vec3(\n        distfunc(pos + d.xyy).a - distfunc(pos - d.xyy).a,\n        distfunc(pos + d.yxy).a - distfunc(pos - d.yxy).a,\n        distfunc(pos + d.yyx).a - distfunc(pos - d.yyx).a\n    ));\n    \n    // Offset from surface\n    vec3 shadowstart = eye + ray * dist + normal * SHADOW_OFFSET;\n    vec3 shadowpos = shadowstart;\n    \n    // Shadow ray\n    vec3 shadowray = normalize(lightpos - pos);\n    float shadowdist = length(lightpos - pos);\n    float penumbra = 1.0;\n    dist = 0.0;\n    for(int i = 0; i < MAX_STEPS_SHADOW; i++) {\n        curdist = distfunc(shadowpos).a;\n\t\tdist += curdist * STEP_MULTIPLIER;        \n        shadowpos = shadowstart + shadowray * dist;\n        \n        if(curdist < MIN_DIST) {\n            penumbra = 0.0;\n            break;\n        }\n        \n        penumbra = min(penumbra, SHADOW_HARDNESS * curdist / dist);\n        if(dist >= shadowdist) {;\n        \tbreak;   \n        }\n        \n        if(i == MAX_STEPS_SHADOW - 1) {\n        \tpenumbra = 0.0;   \n        }\n        \n    }\n    \n    // Shading\n    float light = max(0.0, dot(normal, shadowray)) * penumbra + 0.1;\n    vec3 itershade = vec3(iters / float(MAX_STEPS));\n    vec3 colorval = (light + itershade * 0.1) * distfunc(pos).rgb + itershade * 0.3;\n    \n    // \"Post-processing\"\n    return vec4(colorval, 0.0);\n}\n\n// Image\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = pixel(fragCoord);\n}","name":"Image","description":"","type":"image"}]}