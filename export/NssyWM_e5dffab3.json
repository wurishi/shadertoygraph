{"ver":"0.1","info":{"id":"NssyWM","date":"1642186409","viewed":155,"name":"4D Moire","username":"foodi","description":"Just some Moire patterns created by throwing some math on 4D-Positions while raymarching some repeating spheres","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","moire","4d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define BLUR_RAD 4\n#define BLUR_DIM (BLUR_RAD * 2 + 1)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel1, uv).rgb;\n\n    //vec3 col = vec3(0.f);\n    //float totalWeight = 0.f;\n    //for(int y = -BLUR_RAD; y <= BLUR_RAD; y++) {\n    //    for(int x = -BLUR_RAD; x <= BLUR_RAD; x++) {\n    //        vec2 uv = (fragCoord.xy + vec2(x, y)) / iResolution.xy;\n    //        float weight = exp(-length(vec2(x,y)) * 0.2f);\n    //        vec3 curCol = texture(iChannel0, uv).rgb;\n    //        if(max(curCol.r, max(curCol.g, curCol.b)) < 0.01f) {\n    //            weight = 0.f;\n    //        }\n    //        col += curCol * weight;\n    //        totalWeight += weight;\n    //    }\n    //}\n    //\n    ////col /= float(BLUR_DIM * BLUR_DIM);\n    //col = totalWeight != 0.f ? col / totalWeight : vec3(0.f);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//float SceneDist(vec4 p)\n//{\n//    vec4 origP = p;\n//    p -= 2.5f; // shift to center of a row (so we do not pass through spheres constantly)\n//    p = mod(p + 2.5f, 5.f) - 2.5f; // tile\n//    return length(p) - 0.25f;\n//    //return length(p) - log2(length(origP) * 0.001f) * 0.125f;\n//}\n\nfloat Time()\n{\n    return iTime + 258.f;\n    //return iTime + 40.f;\n}\n\nvec4 SceneDist(vec4 p)\n{\n    //float tiling = 10.f + sin(p.w * 0.001f) * 3.f;\n    float tiling = 12.f;\n    vec4 origP = p;\n    p = mod(p, tiling) - 0.5f * tiling; // tile and shift to center of a row (so we do not pass through spheres constantly)\n    return vec4(p.rgb, length(p) - 2.175f);\n    //return length(p) - log2(length(origP) * 0.001f) * 0.125f;\n}\n\n\nvec4 Normal(vec4 p)\n{\n    float v = SceneDist(p).a;\n    vec2 e = vec2(0.001f, 0.f);\n    float dx = SceneDist(p + e.xyyy).a - v;\n    float dy = SceneDist(p + e.yxyy).a - v;\n    float dz = SceneDist(p + e.yyxy).a - v;\n    float dw = SceneDist(p + e.yyyx).a - v;\n\n    return normalize(vec4(dx, dy, dz, dw));\n}\n\nvec4 MakePoint(vec4 ro, vec4 rd, float dist)\n{\n    float angle = Time() * 0.1f;\n    float angle2 = Time() * 0.033f;\n    mat4x4 rot = mat4x4(\n        1, 0, 0, 0,\n        0, cos(angle), 0, -sin(angle),\n        0, 0, 1, 0,\n        0, sin(angle), 0, cos(angle)\n    );\n    mat4x4 rot2 = mat4x4(\n        cos(angle2), 0, 0, -sin(angle2),\n        0, 1, 0, 0,\n        0, 0, 1, 0,\n        sin(angle2), 0, 0, cos(angle2)\n    );\n\n    rot = rot * rot2;\n\n    vec4 p = ro + rd * dist;\n   \n    \n    //p.w = dist * 0.5f * mod(Time(), 5.f);\n    p.w = Time() + dist;\n    p = rot * p;\n    return p;\n}\n\nvec3 Render(vec4 ro, vec4 rd)\n{\n    bool hit = false;\n    float dist = 200.f;\n    float minDist = 100.f;\n    vec4 avg = vec4(0.f);\n    float avgTotalWeight = 0.f;\n    vec3 minCol = vec3(0.f);\n    int i = 0;\n    //for(; i < 2400; i++) {\n    for(; i < 800; i++) {\n        vec4 p = MakePoint(ro, rd, dist);\n        //float d = SceneDist(p);\n        vec4 r = SceneDist(p);\n        float d = r.a;\n        if(abs(d) < minDist) {\n            minDist = abs(d);\n            minCol = r.rgb;\n        }\n        //float avgWeight = exp(-dist * 0.001f);\n        //avg += avgWeight * r;\n        //avgTotalWeight += avgWeight;\n        //minDist = min(d, minDist);\n        //float thresholdScalar = exp(dist / (1.f * Time()));\n        float thresholdScalar = dist / (0.001f * (Time() + 20.f));\n        //float thresholdScalar = dist;\n        //float thresholdScalar = dist;\n        if(abs(d) < 0.0001f * thresholdScalar) {\n            hit = true;\n            break;\n        }\n        dist += d;\n    }\n    //avg /= avgTotalWeight; //float(i + 1);\n    \n    if(hit) {\n        vec4 p = MakePoint(ro, rd, dist);\n        vec4 n = Normal(p);\n        vec3 c = 0.5 + 0.5*cos(p.wyx * 0.001f + sin(p.x * 0.0005f * vec3(3,2,1)));\n        //vec3 c = 0.5 + 0.5*cos(p.wyx * 0.001f + sin(p.x * 0.001f * vec3(1,2,3)));\n        c *= pow(clamp(max(0.f, 1.f - exp(-dist * 0.001f)), 0.f, 1.f), 2.f);\n        return c; // * (n.rgb * 0.3f + 0.7f); //* pow(abs(n.z), 2.f); // * (dot(n, normalize(vec4(.5, -.5, .1, .3))) * 0.5f + 0.5f);\n        //return n.rgb * vec3(0.3f, 0.4f, 0.5f) + vec3(0.f, 0.5f, 0.6f);\n        //return mix(vec3(0.05f, 0.7f, 0.8f), vec3(0.6f, 0.1f, 0.2f), n.rgb);\n    }\n    //return vec3(exp(minCol * 4.f));\n    return vec3(0.f); //vec3(log2(minCol));\n    //return avg.rgb;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n   \n    \n    uv = uv * 2.f - 1.f; // [-1,1]\n    uv.y *= iResolution.y / iResolution.x;\n \n\n    //ec4 ro = vec4(sin(Time()), 0.f, cos(Time()), 0);\n    //vec4 ro = vec4(Time() * 0.1f, 0.f, 0.f, 0.05f * Time());\n    vec4 ro = vec4(1.f, 0.f, 0.f, 0.f);\n    //ro.yzw += tex * 5.f;\n    //vec4 cf = -normalize(ro);\n    vec4 cf = vec4(1, 0, 0.f, 0.f);\n    vec4 cu = vec4(0, 1, 0.f, 0.f);\n    vec4 cr = vec4(normalize(cross(cf.xyz, cu.xyz)), 0.f); //vec4(0, 0, 1, 0); //normalize(cross(cf, cu));\n    //cu = normalize(cross(cr, cf));\n    float fl = 1.f;\n    vec4 rd = normalize(uv.x * cr + uv.y * cu + fl * cf);\n    vec3 col = Render(ro, rd);\n   \n    //col = pow(col, vec3(1.f / 2.2f));\n\n    //col = col * 0.5f + tex * 0.5f;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define RAD 0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.f);\n    for(int i = -RAD; i <= RAD; i++) {\n        vec2 uv = (fragCoord.xy + vec2(i, -i)) / iResolution.xy;\n        vec3 curCol = texture(iChannel0, uv).rgb;\n        col = max(col, curCol * exp(float(-i) * 0.1f));\n    }\n    \n    fragColor = vec4(col,1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"#define RAD 0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.f);\n    for(int i = -RAD; i <= RAD; i++) {\n        vec2 uv = (fragCoord.xy + vec2(i, i)) / iResolution.xy;\n        vec3 curCol = texture(iChannel0, uv).rgb;\n        col = max(col, curCol * exp(float(-i) * 0.1f));\n    }\n    \n    fragColor = vec4(col,1.0);\n}","name":"Buffer C","description":"","type":"buffer"}]}