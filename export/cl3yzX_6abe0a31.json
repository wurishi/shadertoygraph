{"ver":"0.1","info":{"id":"cl3yzX","date":"1699455079","viewed":68,"name":"Working Fractal Shader","username":"JackMcJackJack","description":"Finally got this working well","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["simple"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float pi = 3.141592;\n\nfloat Heaviside(float a)\n{\n    if(a>0. && a<1.){return 1.;}\n    else{return 0.;}\n}\n\nfloat CutOffBetween(float lower_bound, float upper_bound, float a)\n{\n    if(a>lower_bound && a<upper_bound){return 1.;}\n    else{return 0.;}\n}\n\nfloat DistBetweenPoints(vec2 Point1,vec2 Point2)\n{\n    return sqrt(pow(Point1.x - Point2.x,2.) + pow(Point1.y - Point2.y,2.));\n}\n\nvec2 SelectPointFractionOfCircle(float Numerator, float Denominator, float MasterCircleRadius, vec2 MasterCircleCentre)\n{\n    float Angle = 2.0*pi* Numerator / Denominator;\n    return MasterCircleCentre + MasterCircleRadius*vec2(cos(Angle),sin(Angle));\n}\n\n\n\n\nfloat NumberOfCirclesAboveGivenFractalLevel(\n    float CirclesPerFractalLevelNumber,\n    float FractalLevel\n)\n{\n    return CirclesPerFractalLevelNumber*(1.-pow(CirclesPerFractalLevelNumber,FractalLevel))/(1.-CirclesPerFractalLevelNumber);\n}\n\nfloat TotalNumberOfCircles(\n    float CirclesPerFractalLevelNumber, \n    float RecursionDepth)\n{// Double Check this\n    return NumberOfCirclesAboveGivenFractalLevel(CirclesPerFractalLevelNumber, RecursionDepth);\n}\n\n//Returns max fractal level from a circle number\nfloat FractalDepthFromCircleNumber(\n    float CircleNumber,\n    float CirclesPerFractalLevelNumber)\n{\n    return floor(log(1.-CircleNumber*(1.-CirclesPerFractalLevelNumber)) / log(CirclesPerFractalLevelNumber));\n}\n\n//We'll be looping over Circle Number later\n//This is the part that isn't working correctly past fractallevel >= 2\nfloat FractalCirclePositionAtCurrentFractalLevelFromCircleNumber(\n    float CurrentFractalLevel,\n    float CircleNumber, \n    float CirclesPerFractalLevelNumber)\n{\n    //CircleNumber will be converted to an array of numbers ranging from 0 to CirclesPerFractalLevelNumber - 1\n    //We'll then select the \"CurrentFractalLevel\" th entry of this array\n    \n    float FractalLevelOfCircleNumber = FractalDepthFromCircleNumber(CircleNumber, CirclesPerFractalLevelNumber);\n    float GreatestCircleNumberOfFractalLevelBelow = NumberOfCirclesAboveGivenFractalLevel(CirclesPerFractalLevelNumber,FractalLevelOfCircleNumber-1.);\n    float Difference = CircleNumber - GreatestCircleNumberOfFractalLevelBelow;\n    if(CurrentFractalLevel == FractalLevelOfCircleNumber)\n    {\n        return mod(Difference, CirclesPerFractalLevelNumber);\n    }\n    if(Difference <0.)\n    {\n        return 1.;\n    }\n    else{\n        return floor(Difference / pow(CirclesPerFractalLevelNumber,CurrentFractalLevel));\n    }\n}\n\nfloat DrawCircle(vec2 uv, float CircleRadius, float CircleThickness, vec2 CircleCentre)\n{\n    float RadialDistFromCircleCentre = DistBetweenPoints(uv, CircleCentre);\n    return CutOffBetween(CircleRadius - CircleThickness/2.,CircleRadius + CircleThickness/2., RadialDistFromCircleCentre);\n}\n//Fractal Level refers to how far in or out of each circle\n//Position level refers to how far around each size of circle a sub circle is drawn\n\nvec2 CircleCentreFromCircleNumber(\n    float CircleNumber,\n    float CirclesPerFractalLevelNumber,\n    float BaseCircleRadius,\n    vec2 BaseCircleCentre,\n    float FractalSpeedRatio,\n    float RecursionDepth)\n{   \n    vec2 CircleCentre = BaseCircleCentre;\n    float CircleRadius = BaseCircleRadius;\n    float FractalDepth = FractalDepthFromCircleNumber(CircleNumber,CirclesPerFractalLevelNumber);\n\n    for(float CurrentFractalLevel = FractalDepth; CurrentFractalLevel >= 1.; CurrentFractalLevel--)\n    {   \n        float Numerator = FractalCirclePositionAtCurrentFractalLevelFromCircleNumber(CurrentFractalLevel, CircleNumber, CirclesPerFractalLevelNumber);\n        float CircleRadiusAtFractalLevel = BaseCircleRadius*pow(sin(pi/CirclesPerFractalLevelNumber),CurrentFractalLevel);\n        \n        vec2 VectorFromPreviousCircleCentreToNextCircleCentre = SelectPointFractionOfCircle(Numerator + iTime*CurrentFractalLevel*FractalSpeedRatio, CirclesPerFractalLevelNumber, CircleRadiusAtFractalLevel/sin(pi/CirclesPerFractalLevelNumber), vec2(0.));\n        \n        CircleCentre += VectorFromPreviousCircleCentreToNextCircleCentre;\n    }\n    return CircleCentre;\n}\n\nvec3 DrawRecursiveCircle(vec2 uv, \n                         float BaseCircleRadius,\n                         float BaseCircleSpeed,\n                         float CirclesPerFractalLevelNumber, \n                         float FractalSpeedRatio,\n                         float RecursionDepth,\n                         float CircleThickness,\n                         float iTime)\n{\n    //Each pixel is defined as being off or on essentially. All circles will be added to this Circles vector to give it it's colour\n    vec3 Circles = vec3(0.);\n\n    float TotalNumOfCircles = TotalNumberOfCircles(CirclesPerFractalLevelNumber, RecursionDepth);\n    vec2 BaseCircleCentre = vec2(0.);\n\n    for(float CircleNumber = 1.; CircleNumber <= TotalNumOfCircles; CircleNumber++)\n    {\n        float FractalLevel = FractalDepthFromCircleNumber(CircleNumber, CirclesPerFractalLevelNumber);\n        float CircleRadius = BaseCircleRadius*pow(sin(pi/CirclesPerFractalLevelNumber),FractalLevel);\n        vec2 CircleCentreAtFractalLevel = CircleCentreFromCircleNumber(CircleNumber, CirclesPerFractalLevelNumber, BaseCircleRadius, BaseCircleCentre, FractalSpeedRatio, RecursionDepth);\n        Circles += vec3(DrawCircle(uv, CircleRadius, CircleThickness, CircleCentreAtFractalLevel)/FractalLevel);\n    }\n    return Circles;\n}\n\n//Image Generation\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float BaseCircleRadius = .4;\n    float BaseCircleSpeed = .3;\n    float CirclesPerFractalLevelNumber = 5.;\n    float FractalSpeedRatio = 0.02;\n    //This may crash if you set this above 4.\n    float RecursionDepth = 3.;\n    float CircleThickness = 0.005;\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord * 2.0 - 1.0*iResolution.xy) / iResolution.y;\n\n    //Set Background colour to Black\n    vec3 finalColor = vec3(0.);\n    //Draw Master Circle\n    vec3 MasterCircle = vec3(DrawCircle(uv, BaseCircleRadius,CircleThickness,vec2(0.)));\n    \n    //Create Recursive Circles\n    vec3 Circles = DrawRecursiveCircle(\n                         uv, \n                         BaseCircleRadius,\n                         BaseCircleSpeed,\n                         CirclesPerFractalLevelNumber, \n                         FractalSpeedRatio,\n                         RecursionDepth,\n                         CircleThickness,\n                         iTime);\n        \n    //Add shapes to screen\n    finalColor = MasterCircle + Circles;\n    // Output to screen\n    fragColor = vec4(finalColor, 1.0);\n    \n}\n","name":"Image","description":"","type":"image"}]}