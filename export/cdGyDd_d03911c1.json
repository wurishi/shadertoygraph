{"ver":"0.1","info":{"id":"cdGyDd","date":"1706550669","viewed":62,"name":"J/M set with Perlin Noise","username":"Elyades","description":"Regular Julia sets :)","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["juliaset"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Julia set burning ship + blend\" by Elyades. https://shadertoy.com/view/csGcWd\n// 2023-10-07 22:21:45\n\n// Fork of \"Test julia set\" by Elyades. https://shadertoy.com/view/ddBczW\n// 2023-10-07 22:21:21\nfloat PI = 3.14159265358979323846;\nfloat TWOPI = 6.28318530718;\nfloat PIONTWO = 1.57079632679;\n\n\nfloat rand3(vec2 uv, float seed)\n{\n    uv = mod(uv,1.0);\n    float rand = (uv.x+uv.y + cos(uv.x-uv.y + seed))*0.2;\n    return( rand );\n}\n\nvec2 getRandomVector (vec2 uv, float seed)\n{\n    float r1 = rand3(uv,seed);\n    vec2 v = vec2(r1,0.0-r1);\n    return (v);\n    //return( cos(2.0*floor(200.0*uv)) + sin(2.0*floor(200.0*uv)) );\n}\n\nfloat perlinNoise(vec2 uv, float seed)\n{\n    vec2 roundDown = floor(uv);\n    vec2 roundUp = roundDown + 1.0;\n    vec2 d = uv - roundDown;\n    vec2 vecBL = getRandomVector(roundDown,seed);\n    vec2 vecBR = getRandomVector(roundDown + vec2(1.0,0.0),seed);\n    vec2 vecTL = getRandomVector(roundDown + vec2(0.0,1.0),seed);\n    vec2 vecTR = getRandomVector(roundDown + 1.0,seed);\n    \n    float prod1 = dot(d, vecBL);\n    float prod2 = dot(uv - vec2(roundUp.x,roundDown.y) ,vecBR);\n    float lerp1 = mix(prod1, prod2, d.x);\n    float prod3 = dot(uv - vec2(roundDown.x,roundUp.y) ,vecTL);\n    float prod4 = dot(uv - roundUp,vecTR);\n    float lerp2 = mix(prod3, prod4,d.x);\n    \n    float final = mix(lerp1, lerp2, d.y);\n    final = mod(final,1.0);\n    return(final);\n}\n\nvec2 square(vec2 uv)\n{\n    return vec2(uv.x*uv.x - uv.y*uv.y, 2.0*uv.x*uv.y);\n}\n\nvec2 cube(vec2 uv)\n{\n    return vec2(uv.x*uv.x*uv.x - 3.0*uv.x*uv.y*uv.y , 3.0*uv.x*uv.x*uv.y - uv.y*uv.y*uv.y);\n}\n\nfloat norm(vec2 uv)\n{\n    return(float(uv.x*uv.x + uv.y*uv.y));\n}\n\nvec2 times (vec2 z1, vec2 z2)\n{\n    return vec2(z1.x*z2.x - z1.y*z2.y , z1.x*z2.y + z1.y*z2.x);\n}\n\nvec2 itimes(vec2 uv)\n{\n    return( vec2(-uv.y,uv.x) );\n}\n\nvec2 oneover(vec2 uv)\n{\n    float squaremodulus = norm(uv);\n    return( vec2(uv.x/squaremodulus, -uv.y/squaremodulus) );\n}\n\nvec2 exp2d(vec2 uv)\n{\n    return( exp(uv.x)*vec2(cos(uv.y),sin(uv.y)));\n}\n\nvec2 cos2d(vec2 uv)\n{\n    return ( vec2 (exp2d(itimes(uv)) + exp2d(itimes(-uv)))*0.5);\n}\n\nvec2 sin2d(vec2 uv)\n{\n    return ( vec2 (-itimes((exp2d(itimes(uv)) - exp2d(itimes(-uv)))*0.5)));\n}\n\n\nfloat atan2(float y, float x)\n{\n    //this computes arctan(y/x)\n    float angle = atan(y,x);\n    if(angle < 0.0){angle+= TWOPI;}\n    return(angle);\n}\n\nvec2 power(vec2 uv, float n)\n{\n    float modulus = length(uv);\n    float angle = atan2(uv.y,uv.x);\n    angle *= n;\n    \n    return( exp(n*log(modulus))*vec2(cos(angle),sin(angle)));\n}\n\nvec2 log2d(vec2 uv)\n{\n    return(vec2(log(length(uv)),atan(uv.y,uv.x)));\n}\n\nvec3 palette2( float t ) {\n    //by Inigo Quilez\n    vec3 a = vec3(0.5,0.5,0.5);\n    vec3 b = vec3(0.5,0.5,0.5);\n    vec3 c = vec3(1.0,1.0,1.0);\n    vec3 d = vec3(0.5,0.5,0.7);\n\n    return vec3(a + b*cos(6.28318530718*(c*(t) + d)));\n}\n\nvec3 palette3( float t ) {\n    //by Inigo Quilez\n    vec3 a = vec3(0.5,0.5,0.5);\n    vec3 b = vec3(0.5,0.0,0.5);\n    vec3 c = vec3(1.0,1.0,1.0);\n    vec3 d = vec3(0.5,0.5,0.7);\n\n    return vec3(a + b*cos(6.28318530718*(c*(t) + d)));\n}\n\n\nvec2 function(vec2 uv, vec2 c)\n{\n    vec2 result = square(uv) + c ;\n    return result;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv - 0.5;\n    uv.x += 0.0;\n    \n    //Scale\n    uv *= 8.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n     //Choosing the Zoom\n    vec2 zoomPoint = vec2(0.0,0.0);\n    \n    //Zoom\n    float zoomAmount = pow(10.0,-(max(iTime-1.5,0.0))/3.0);\n    uv = uv*zoomAmount;\n    uv += zoomPoint;\n    \n    float tol = pow(10.0,-6.0);\n    \n    float DistanceToPrevious = 1.0;\n    float currentModulus = length(uv);\n    vec2 previousIteration; vec3 perlinColor = vec3(0);\n    int iterationAmount = 0;\n    float k = 4.0;\n    int testAmount = int(pow(10.0,k));\n    vec2 m = 6.0*(iMouse.xy/iResolution.xy - 0.5);\n    vec2 c = m;\n    float seed = currentModulus;\n    float p = perlinNoise(uv,seed);\n    //vec2 c = uv;\n    vec2 dummyuv = uv;\n    \n    for (iterationAmount = 0; iterationAmount < testAmount; iterationAmount++)\n    {\n        previousIteration = uv;\n        uv = function(uv,c);\n        currentModulus = length(uv);\n        DistanceToPrevious = length(uv - previousIteration);\n        seed += currentModulus;\n        p += perlinNoise(uv,seed);\n        perlinColor += palette2(p);\n        \n        if(DistanceToPrevious < tol){break;}\n        if(currentModulus > 30.0){break;} \n    }\n    perlinColor /= float(iterationAmount+1);\n    //p /= float(iterationAmount+1);\n    //p = perlinNoise(uv,seed);\n    \n    if(currentModulus < 30.0)\n    {\n        fragColor = vec4(0.0,0.0,0.0,1.0);\n    }\n    \n    else\n    {\n            int i = iterationAmount;\n            iterationAmount = int(3.0*log(float(iterationAmount)+1.0)+1.0);\n            int periodFast = 10;\n            int residueFast = iterationAmount%periodFast;\n            float indexFast = float(residueFast)/float(periodFast);\n            vec3 colorFast = palette3(indexFast);\n            \n            int periodMedium = 40;\n            int residueMedium = iterationAmount%periodMedium;\n            float indexMedium = float(residueMedium)/float(periodMedium);\n            vec3 colorMedium = palette3(indexMedium);\n            \n            int periodSlow = 100;\n            int residueSlow = iterationAmount%periodSlow;\n            float indexSlow = float(residueSlow)/float(periodSlow);\n            vec3 colorSlow = palette3(indexSlow);\n           \n            float finalIndex = (indexSlow + indexMedium + indexFast)*0.333333333;\n            vec3 finalColor = (colorSlow + colorMedium + colorFast)*0.3333333333;\n            //fragColor = vec4(finalColor,1.0);\n            fragColor = vec4(0.5*(perlinColor+finalColor),1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}