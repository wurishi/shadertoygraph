{"ver":"0.1","info":{"id":"NsjSzW","date":"1619788908","viewed":544,"name":"spikes tunnel","username":"Bleuje","description":"learning from leon and iq\n\n2 seconds long perfect loop","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"ssBSRz","parentname":"tunnel blocks loop"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// by @etiennejcb\n// starting from shaders by leon :\n// https://www.shadertoy.com/view/3ltyRB\n// and https://www.shadertoy.com/view/XlfBR7\n\n// probably messy, there might be useless code\n\n// most important parameters\n#define motionBlur 1.0 // (integer)\n#define bwMode false\n\n// others\n#define largeRadius 30.0\n#define smallRadius 15.0\n#define cellLength 3.0\n#define segments 60.0 // (integer)\n#define speed 1.0\n#define zmod 9.0  // (integer)\n\n\nvec2 displaceLoop (vec2 p, float r) { return vec2(length(p.xy)-r, atan(p.y,p.x)); }\n\n// from iq https://www.shadertoy.com/view/Msf3WH\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n// from iq https://www.shadertoy.com/view/Msf3WH\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\nfloat time;\n\n// volumes description\nVolume map(vec3 pos)\n{\n    float scene = 100.;\n    float indexX, indexZ;\n    \n    vec3 p = pos;\n\n    Volume white;\n    white.mat = 1;\n    \n    Volume black;\n    black.mat = 2;\n    \n    black.dist = 1e9;\n    \n    // donut distortion\n    vec3 pDonut = p;\n    pDonut.y -= largeRadius;\n    pDonut.yz = displaceLoop(pDonut.yz, largeRadius);\n    pDonut.z *= largeRadius;\n    pDonut.xy *= rot(0.03*p.z);\n\n    p = pDonut;\n    scene = min(scene, -sdCylinder(p.xy, smallRadius+0.0));\n    \n    black.dist = scene;\n    \n    scene = 1000.0;\n    \n    p = pDonut;\n    \n    \n    vec2 p0 = p.xy;\n    \n    float pz = p.z - speed*time*zmod*cellLength;\n    indexZ = floor(0.5+pz / cellLength);\n    float cellpz =  speed*time*zmod*cellLength + indexZ*cellLength;\n    p.xy *= rot(PI/segments);\n    //if(int(indexZ)%2==0) p.xy *= rot(PI/segments);\n    p.z = repeat(pz+cellLength/2.0, cellLength)-cellLength/2.0;\n    \n    indexX = amodIndex(p.xy, segments);\n    amod(p.xy, segments);\n    \n    \n    vec2 seed = vec2(mod(indexZ,zmod), indexX);\n    vec2 seed2 = vec2(mod(indexZ,zmod)+123.123, indexX+98765.987);\n    \n    float salt = rng(seed);\n    float ns = pow(salt+0.2,2.0);\n    float salt2 = rng(seed2);\n    vec2 nsInput = vec2(987.9156*mod(indexZ,zmod)+12345.123*indexX,0.02*cellpz);\n    float nscol = pow(clamp(2.*noise(nsInput),0.,1.),1.8)*2.0+0.5;\n\n    vec3 p2 = p.xyz+vec3(-smallRadius,0.,cellLength/2.0);\n    p2.x *= -1.0;\n    float h = 3.5*nscol;\n    p2.x -= h;\n    float factor = 0.2;\n    p2.x *= factor;\n    h *= factor; \n    scene = min(scene, sdCone(p2.yxz,vec2(0.6,0.4)/factor,h));\n    \n    float width = pow((1.0+0.35*p2.x/h),10.0)*1.3;\n    float color2 = max(0.0,0.5*smoothstep(0.5-0.7*width,0.5-0.15*width,+abs(-0.5+mod(atan(p2.y,p2.z)/PI/2.0*4.0,1.0))))+max(0.0,-p2.x-0.9*h);\n    white.fc = color2;\n    \n    if(color2<=0.0) white.type = 2;\n    else if(salt2>0.25) white.type = 0;\n    else white.type = 1;\n    \n    white.ns = ns;\n    \n    white.dist = scene;\n    \n    Volume volume = select(white,black);\n    \n    volume.smallAngle = atan(p0.y,p0.x);\n\n    return volume;\n}\n\n// NuSan\n// https://www.shadertoy.com/view/3sBGzV\nvec3 getNormal(vec3 p) {\n\tvec2 off=vec2(0.001,0);\n\treturn normalize(map(p).dist-vec3(map(p-off.xyy).dist, map(p-off.yxy).dist, map(p-off.yyx).dist));\n}\n\nvec3 finishColor(float travel, float shade, float angle, vec3 col)\n{\n    float rad = 3.0;\n    float miniOffset = 1.6*noise(vec2(rad*cos(angle),rad*sin(angle)));\n    float activation = 0.19+1.2*pow((0.5+0.5*sin(0.*angle+miniOffset+TAU*(time-0.035*travel))),4.0);\n    col += 0.015*(travel+25.0)*pow(clamp(1.0*shade,0.0,1.0),2.9)*vec3(0.3,1.2,1.5)*activation; \n    \n    col += (-0.125+0.015*travel)*vec3(1.0,0.2,2.0);\n\n    vec3 toAdd = clamp(col*4.0/(20.0+travel)*10.0,0.0,1.0);\n    \n    if(bwMode) toAdd *= 1.5;\n    \n    return toAdd;\n}\n\nvoid mainImage( out vec4 color, in vec2 coordinate )\n{\n    color = vec4(0);\n    // coordinates\n    vec2 uv = coordinate / iResolution.xy;\n    vec2 p = 2.*(coordinate - 0.5 * iResolution.xy)/iResolution.y;\n    \n    // camera\n    vec3 cameraPos = vec3(0,0,-3);\n    \n    // look at\n    vec3 z = normalize(vec3(0,0.75,0)-cameraPos);\n    vec3 x = normalize(cross(z, vec3(0,1,0)));\n    vec3 y = normalize(cross(x, z));\n    vec3 ray = normalize(z * 0.9 + x * p.x + y * p.y);\n    \n    // background gradient\n    color.rgb += vec3(0.);\n    \n    float mb = motionBlur;\n    \n    for(float it=0.0;it<mb;it++){\n    \n        time = 0.5*mod(iTime,2.0) - it*0.016/mb;\n    \n        // render variables\n        float shade = 0.0;\n        vec3 normal = vec3(0,1,0);\n        float ao = 1.0;\n        float rng = hash12(coordinate + time);\n        const int count = int(floor(120.));\n        float travel = 0.0;\n        float angle;\n        \n        vec3 pos = cameraPos;\n        \n        int index;\n\n        // raymarch iteration\n        for (index = 0; index < count; ++index)\n        {\n            Volume volume = map(pos);\n            \n            angle = volume.smallAngle;\n\n            // accumulate fullness\n            shade += 0.5/float(60);\n\n            // step further on edge of volume\n            normal = getNormal(pos);\n\n            if(volume.dist>0.001){\n\n                // dithering trick inspired by Duke\n                volume.dist *= 0.85+0.05*rng;\n\n                // keep marching\n                pos += ray * volume.dist * .5;\n                travel += volume.dist * .5;\n            }\n            else\n            {\n\n                // coloring\n                vec3 col = vec3(0);\n                switch (volume.mat)\n                {\n                    case mat_bright:\n                    if(volume.type==2) break;\n                    col = 0.2*volume.fc*(volume.type==0?vec3(1.95,1.0,0.5):vec3(1.0,1.2,2.5));\n                    col *= pow(dot(vec3(1.0,0.0,0.0),normal)*0.4+0.5,0.7);\n                    col *= 4.5*pow(volume.ns,4.0);\n                    break;\n\n                    case mat_dark:\n                    break;\n                }\n                \n\n                color.rgb += finishColor(travel, shade, angle, col);\n\n                break;\n\n            }\n        }\n        \n        if(index==count)\n        {\n            color.rgb += finishColor(travel, shade, angle, vec3(0.0));\n        }\n    }\n    \n    color.rgb /= mb;\n    \n    if(bwMode) color.rgb = vec3(pow((color.r+color.g+color.b)/3.0,2.0));\n    \n    // (lol)\n    //color.rgb = vec3(1.0)-color.rgb;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n\n#define PI 3.14159\n#define TAU (2.*PI)\n\nfloat repeat (float v, float c) { return mod(v,c)-c/2.; }\nvec2 repeat (vec2 v, vec2 c) { return mod(v,c)-c/2.; }\nvec3 repeat (vec3 v, float c) { return mod(v,c)-c/2.; }\n\n// details about sdf volumes\nstruct Volume\n{\n    float dist;\n    int mat;\n    float ns;\n    float fc;\n    int type;\n    float smallAngle;\n};\n\n// union operation between two volume\nVolume select(Volume a, Volume b)\n{\n    if (a.dist < b.dist) return a;\n    return b;\n}\n\n// materials\nconst int mat_bright = 1;\nconst int mat_dark = 2;\n\n// Rotation 2D matrix\nmat2 rot(float a) { float c = cos(a), s = sin(a); return mat2(c,-s,s,c); }\n\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\nfloat sdCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n    float x = sqrt( papa - paba*paba*baba );\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdCylinder (vec2 p, float r) { return length(p)-r; }\n\nfloat amod (inout vec2 p, float count) { float an = TAU/count; float a = atan(p.y,p.x)+an/2.; float c = floor(a/an); c = mix(c,abs(c),step(count*.5,abs(c))); a = mod(a,an)-an/2.; p.xy = vec2(cos(a),sin(a))*length(p); return c; }\nfloat amodIndex (vec2 p, float count) { float an = TAU/count; float a = atan(p.y,p.x)+an/2.; float c = floor(a/an); c = mix(c,abs(c),step(count*.5,abs(c))); return c; }\n\nfloat rng (vec2 seed) { return fract(sin(dot(seed*.1684,vec2(54.649,321.547)))*450315.); }\n","name":"Common","description":"","type":"common"}]}