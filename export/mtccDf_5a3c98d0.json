{"ver":"0.1","info":{"id":"mtccDf","date":"1699765235","viewed":39,"name":"Dolphin_Camera_Movement_ZSort","username":"dolphin","description":"simple camera test with square","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["glsl"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// if this distance is larger, the size of the object is larger\nfloat c_d = 2.; // camera distance to the screen (this one can be fixed)\n\nvec3 p_c; // camera position\nvec3 p_l; // camera look at position\nvec3 v_l; // camera look at direction\nvec3 p_s; // screen position\n\n// pnt: the point to the line\n// p1: one point of the line\n// p2: another point of the line\nfloat distanceToLine(vec3 pnt, vec3 p1, vec3 p2){\n    float d = length(cross(p2-p1, pnt-p1))/length(p2-p1);\n    return d;\n}\n\nfloat Point(vec3 p_obj, float r){\n    float dist = distanceToLine(p_obj, p_c, p_s);\n    float blur = distance(p_obj, p_c)/iResolution.y;\n    float c = 1. - smoothstep(r, r+blur, dist);\n    c*= 1.-0.7*dist/r;\n    return c;\n}\n\nfloat fakeZsorting(float circles[8], vec3 poses[8]){\n    int idx = 0;\n    float c = 0.;\n    float dist = 10000.;\n    for(int i=0; i<8; i++){\n        if(circles[i] > 0.){\n            float temp_dist = length(poses[i]-p_c);\n            if(temp_dist<dist){\n                idx = i;\n                dist = temp_dist;\n                c = circles[i];\n            }\n        }\n        \n    }\n    return c;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord -.5*iResolution.xy)/iResolution.y;\n   \n    \n    float t = iTime;\n    p_c = vec3(13.*sin(t), 3.*sin(2.*t), 13.*cos(t)+11.);\n    p_l = vec3(0., 0., 11.); // look at position\n    v_l = normalize(p_l-p_c);\n    \n    // normalized camera axis\n    // v_F: Front\n    // v_R: Right\n    // v_U: Up\n    vec3 v_F = v_l;\n    vec3 v_R = cross(v_F, vec3(0., 1., 0.));\n    vec3 v_U = cross(v_R, v_F);\n    \n    p_s = p_c + c_d*v_F + uv.x*v_R + uv.y*v_U;\n\n    float c1 = Point(vec3(1., 1., 12.), .1);\n    float c2 = Point(vec3(-1., 1., 12.), .1);\n    float c3 = Point(vec3(1., -1., 12.), .1);\n    float c4 = Point(vec3(-1., -1.,12.), .1);\n    float c5 = Point(vec3(1., 1., 10.), .1);\n    float c6 = Point(vec3(-1., 1., 10.), .1);\n    float c7 = Point(vec3(1., -1., 10.), .1);\n    float c8 = Point(vec3(-1., -1., 10.), .1);\n    \n    float circles[8] = float[8](c1, c2, c3, c4, c5, c6, c7, c8);\n    vec3 poses[8] = vec3[8](vec3(1., 1., 12.), vec3(-1., 1., 12.), vec3(1., -1., 12.),vec3(-1., -1.,12.),vec3(1., 1., 10.),vec3(-1., 1., 10.),vec3(1., -1., 10.), vec3(-1., -1., 10.));\n    float c9 = Point(vec3(0., 0., 11.), .3);\n    \n    float c = fakeZsorting(circles, poses)+c9;\n        \n\n    // Output to screen\n    fragColor = vec4(vec3(c),1.0);\n}","name":"Image","description":"","type":"image"}]}