{"ver":"0.1","info":{"id":"ftyfzG","date":"1664761251","viewed":94,"name":"Poisson process","username":"Vectornaut","description":"A hash-based Poisson process. Drag to vary the density. To help show what's going on, I've made the tiles much larger than they need to be, so the average number of dots per tile is high. In applications, the tile side length should be the dot radius.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["noise","poisson"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// --- hash function ---\n\n// a fast, well-tested integer hash function\n//\n//   \"Hash Functions for GPU Rendering\"\n//   Mark Jarzynski and Marc Olano\n//   https://jcgt.org/published/0009/03/02/\n//   https://www.shadertoy.com/view/XlGcRh\n\nuvec3 pcg3d(uvec3 v) {\n    v = v * 1664525u + 1013904223u;\n    \n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n    \n    v ^= v >> 16u;\n    \n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n    \n    return v;\n}\n\n// --- Poisson process ---\n\n// basic parameters\nconst float tile_size = 0.2;\nconst int cutoff = 20;\n\n// calculated parameters\nconst float tile_area = tile_size * tile_size;\n\n// sample a Poisson dot pattern with the given mean number of dots per tile. the\n// sample position is at the given offset from the center of the given tile\nfloat poisson_dot(float mean, ivec2 tile, vec2 off) {\n    // to decide how many dots to put in this tile, we have to sample the\n    // Poisson distribution. we choose a threshold uniformly from the interval\n    // [0, 1], take the preimage of [0, threshold) under the Poisson CDF, and\n    // set the number of dots to the largest number in the preimage\n    vec3 rand = vec3(pcg3d(uvec3(tile, tile.x ^ tile.y))) * (1./float(0xffffffffu));\n    float threshold = rand.z;\n    \n    // keep adding dots until we hit the threshold (or the dot number cutoff)\n    float light = 0.;\n    float mass = exp(-mean);\n    float cumulative = mass;\n    for (int n = 1; cumulative < threshold && n <= cutoff; n++) {\n        // sample the dot\n        vec2 center = tile_size * (rand.xy - vec2(0.5));\n        vec2 dis = off - center;\n        if (400.*dot(dis, dis) < tile_area) light += 1.;\n        \n        // add to the accumulated probability\n        mass *= mean / float(n);\n        cumulative += mass;\n        \n        // get the next random vector\n        rand = vec3(pcg3d(uvec3(tile, tile.x ^ tile.y ^ n))) * (1./float(0xffffffffu));\n    }\n    return min(light, 1.);\n}\n\n// to show the tiles, we give each one a random color. notice that we're calling\n// the hash function with different arguments than in `poisson_dot`; this\n// ensures that the coloring won't be correlated with the Poisson process\nvec3 id_color(ivec2 tile) {\n    vec3 rand = vec3(pcg3d(uvec3(tile.x ^ tile.y ^ 59163, tile))) * (1./float(0xffffffffu));\n    return rand / max(max(rand.r, rand.g), rand.b);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // set the Poisson process density, based on the last mouse click\n    float density = iMouse.x / iResolution.x * 200.;\n\n    // get our position\n    float shortdim = min(iResolution.x, iResolution.y);\n    vec2 u = fragCoord / shortdim + (3. + cos(iTime/50.))*vec2(cos(iTime/90.), sin(iTime/90.));\n    \n    // find out which tile we're in and get our position relative to its center\n    // the tile is identified by its integer coordinates, which we'll cast to\n    // unsigned and pass to the hash function\n    ivec2 tile = ivec2(round(u / tile_size));\n    vec2 tile_center = tile_size * vec2(tile);\n    vec2 off = u - tile_center;\n    \n    // set the background color according to the tile we're in\n    vec3 color = 0.25*id_color(tile);\n\n    // sample the dots in the 3 x 3 block of tiles centered on the tile we're\n    // in. as long as the tile side length is at least as large as the dot\n    // radius, this will catch all the dots that could touch our position\n    ivec2 shift;\n    for (shift.x = -1; shift.x < 2; shift.x++) {\n      for (shift.y = -1; shift.y < 2; shift.y++) {\n        ivec2 nbhd_tile = tile + shift;\n        float light = poisson_dot(\n            density * tile_area,\n            nbhd_tile,\n            off - tile_size*vec2(shift)\n        );\n        if (light != 0.) color = id_color(nbhd_tile);\n      }\n    }\n    fragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"}]}