{"ver":"0.1","info":{"id":"XtfBRs","date":"1513243075","viewed":123,"name":"Road_Trip","username":"kalkas","description":"Homework, 3rd","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["homework","nothingspecial"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 skyColor = vec4(1.0, 0.3, 0.0, 1.0);\nvec4 sunColor = vec4(1.0, 1.0, 0.0, 1.0);\nvec4 sunraysColor = vec4(1.0, 0.8, 0.0, 1.0);\nvec4 groundColor = vec4(0.0, 0.3, 0.0, 1.0);\n\nvec4 BlendColors(vec4 _c1, vec4 _c2) {\n    \n    //Blend equation. c1 is over c2\n    //c1*a1 + c2*a2(1 - a1)\n    //---------------------\n    //   a1 + a2(1 - a1)\n    \n    return (_c1*_c1.a + _c2*_c2.a*(1.0 - _c1.a)) / (_c1.a + _c2.a*(1.0 - _c1.a));\n}\n\nvec4 DrawTheSun(vec2 _coords) {\n    \n    //Sun's radius is between 90% and 110% of the half vertical resolution\n    float sunRadius = (sin(iTime)/10.0 + 1.0) * iResolution.y / 2.0;\n    \n    //Current pixel's distance from screen's center\n    float currentLength = length(_coords);\n    \n    //Depending on the distance from the center, color is white at center and yellow on the edge\n    sunColor.b = 1.0 - smoothstep(0.0, sunRadius, currentLength);\n    \n    //Alpha is 1.0 at 60% of the radius inwards and drops to 0.0 on the edge\n    sunColor.a = 1.0 - smoothstep(sunRadius * 0.6, sunRadius, currentLength);\n\n    return BlendColors(sunColor, skyColor);\n}\n\nvec4 DrawTheSunrays(vec2 _coords) {\n    \n    //Angle with X axis. Range is [-π, π]\n    float angle = atan(_coords.y, _coords.x);\n    \n    //Scale the angle to get more rays\n    angle *= 16.0;\n    \n    //cos() range is [-1.0, 1.0]. Scale and translate to make it [0.0, 0.5]\n    sunraysColor.a = cos(angle) / 4.0 + 0.25;\n    \n    return sunraysColor;\n}\n\nvec4 DrawTheSky(vec2 _coords) {\n    \n    skyColor = BlendColors(DrawTheSunrays(_coords), skyColor);\n    \n    return BlendColors(DrawTheSun(_coords), skyColor);\n}\n\nvec4 DrawTheRoad(vec2 _coords) {\n    \n    float roadWidth = iResolution.x / 4.0;\n    float xLength = abs(_coords.x);\n    vec4 roadColor = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    roadWidth *= abs(_coords.y) / iResolution.y * 1.5 + 0.25;\n    \n    if(xLength > roadWidth) {\n        return vec4(0.0, 0.0, 0.0, 0.0);\n    }\n    \n    if(xLength < roadWidth*0.85 && xLength > roadWidth*0.8){\n        return vec4(1.0, 1.0, 1.0, 1.0);\n    }\n    \n    if(xLength < roadWidth*0.05 && cos((_coords.y + iTime*200.0 ) / 20.0) > 0.0){\n        return vec4(1.0, 1.0, 1.0, 1.0);\n    }\n    \n    return vec4(0.0, 0.0, 0.0, 1.0);\n}\n\nvec4 DrawTheGround(vec2 _coords) {\n    \n    vec4 sunBlend = vec4(1.0, 0.4, 0.0, 0.5);\n    sunBlend.a *= 1.0 - smoothstep(0.0, iResolution.y/2.0, abs(_coords.y));\n    groundColor = BlendColors(DrawTheRoad(_coords), groundColor);\n    \n    return BlendColors(sunBlend, groundColor);\n}\n\nvec4 GetColor(vec2 _coords) {\n    \n    if(_coords.y >= 0.0){\n        return DrawTheSky(_coords);\n    }else{\n        return DrawTheGround(_coords);\n    }\n    //return DrawSky(_coords);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n\tvec2 newCoords = fragCoord.xy - iResolution.xy / 2.0;\n\tfragColor = GetColor(newCoords);\n}","name":"Image","description":"","type":"image"}]}