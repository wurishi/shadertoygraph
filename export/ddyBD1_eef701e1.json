{"ver":"0.1","info":{"id":"ddyBD1","date":"1698188047","viewed":69,"name":"Across the browse","username":"3t13nn3","description":"Sync with the drum and bass music","likes":5,"published":1,"flags":64,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"ldtGzS","filepath":"https://soundcloud.com/culture-shock/universe","previewfilepath":"https://soundcloud.com/culture-shock/universe","type":"musicstream","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define DEPTH_LIMIT 30.0\n#define TAU 6.283185\n#define PI 3.141592\n#define BPM 174.0\n\nstruct Material {\n    float depth;\n    vec3 color;\n    float id;\n};\n\n// GPU Gems 3 - Ryan Geiss: https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n ){\n    \n    n = max(abs(n), 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n    \n}\n\nvec3 rotatePoint(vec3 p, vec3 axis, float angle) {\n    float cosA = cos(angle);\n    float sinA = sin(angle);\n    float oneMinusCosA = 1.0 - cosA;\n    \n    mat3 rotationMatrix = mat3(\n        cosA + axis.x*axis.x*oneMinusCosA,     axis.x*axis.y*oneMinusCosA - axis.z*sinA, axis.x*axis.z*oneMinusCosA + axis.y*sinA,\n        axis.y*axis.x*oneMinusCosA + axis.z*sinA, cosA + axis.y*axis.y*oneMinusCosA,     axis.y*axis.z*oneMinusCosA - axis.x*sinA,\n        axis.z*axis.x*oneMinusCosA - axis.y*sinA, axis.z*axis.y*oneMinusCosA + axis.x*sinA, cosA + axis.z*axis.z*oneMinusCosA\n    );\n\n    return rotationMatrix * p;\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nMaterial opU(in Material d1, in Material d2) {\n\tif (d2.depth < d1.depth) {\n        return d2;\n    } else {\n        return d1;\n    }\n}\n\nMaterial sMin(Material a, Material b, float k) {\n    float h = clamp(0.5 + 0.5 * (b.depth - a.depth) / k, 0.0, 1.0);\n    Material result;\n    result.depth = mix(b.depth, a.depth, h) - k * h * (1.0 - h);\n    result.color = mix(b.color, a.color, h);\n    return result;\n}\n\n\nMaterial map(in vec3 pos) {\n    float d1 = 0.0;\n    d1 = pos.y;\n    Material ground = Material(d1, vec3(0.682,0.682,0.682), 0.5);\n    \n    float d2 = 0.0;\n    d2 = sdSphere(fract(pos) - 0.5 + sin((iTime*PI*BPM/60.0)) / 60., 0.15);\n    vec3 id1 = floor(pos);\n    vec3 col = vec3(0.3,0.906,0.784);\n    col += 0.36*cos((id1.x*14.1+id1.y*32.341+id1.z*15.28) + vec3(0.0,1.0,2.0));    \n    \n    float d3 = 0.0;\n    vec3 p = vec3(pos.x, pos.y, pos.z - 0.5);\n    d3 = sdSphere(fract(p) - 0.5, 0.25);\n    vec3 id2 = floor(p);\n    vec3 col2 = vec3(0.906,0.3,0.784);\n    col2 += 0.2*cos((id2.y*14.1+id2.z*32.341+id2.x*15.28) + vec3(1.0,2.0,0.0));\n    \n    float d4 = 0.0;\n    p = vec3(pos.x, pos.y - 0.5, pos.z) ;\n    d4 = sdSphere(fract(p) - 0.5, 0.125);\n    vec3 id3 = floor(p);\n    vec3 col3 = vec3(0.784, 0.906,0.3);\n    col3 += 0.6*sin((id3.y*14.1+id3.x*32.341+id3.z*15.28) + vec3(1.0,1.5,0.5));\n    \n    Material s1 = Material(d2, col, 1.5);\n    Material s2 = Material(d3, col2, 1.5);\n    Material s3 = Material(d4, col3, 1.5);\n    \n    p = vec3(pos.x, pos.y -2.5, pos.z - -3.);\n    float torusX = sdTorus(fract(p) - 0.5, vec2(0.09, 0.09 + abs(cos(iTime * 2.0)) / 50.));\n    \n    vec3 link1 = floor(p);\n    vec3 colLink1 = vec3(0.306,0.5,0.784);\n    colLink1 += 0.36*cos((link1.z*1.1+link1.x*3.341+link1.y*0.28) + vec3(1.0,0.3,1.0));    \n    \n    Material t1 = Material(torusX, colLink1, 1.5); // vec3(0.290,0.290,0.290)\n    \n    p = vec3(pos.x, pos.y - 2., pos.z /2. - -2.);\n    float torusXX = sdTorus(fract(p) - 0.5, vec2(0.15, 0.12 + abs(sin((0.5*iTime*PI*BPM/60.0))/20.))); // vec2(0.15, 0.12 * sin((iTime*PI*BPM/60.0))/0.5)\n    \n    vec3 link2 = floor(p);\n    vec3 colLink2 = vec3(0.406,0.9,0.284);\n    colLink2 += 0.4*cos((link2.x*4.1+link2.y*2.341+link2.z*1.28) + vec3(0.5,0.5,1.5));   \n    \n    Material t2 = Material(torusXX, colLink2, 1.5); // vec3(0.102,0.275,0.212)\n    \n\n    \n    //Material res = sMin(s1, s2, 0.75-clamp(fract(0.5*iTime*BPM/60.0), 0., 0.5));\n    Material res = sMin(s1, s2, 0.45-sin((0.5*iTime*PI*BPM/60.0)) / 20.);\n    res = sMin(res, s3, 0.5);\n    res = opU(res, t1);\n    res = opU(res, t2);\n    res = opU(ground, res);\n    return res;\n}\n\nMaterial rayCast(in vec3 ro, in vec3 rd) {\n    float t = 0.0;\n    Material mat;\n    \n    for(int i = 0; i < 100; ++i) {\n        vec3 pos = ro + rd * t;\n        mat = map(pos);\n        if(abs(mat.depth) < 0.001 || mat.depth > DEPTH_LIMIT) break;\n        t+= mat.depth * 0.8;\n    }\n    \n    if (t < DEPTH_LIMIT) return Material(t, mat.color, mat.id);\n    \n    return Material(DEPTH_LIMIT, mat.color, mat.id);\n}\n\nvec3 getNormal(in vec3 pos, float t) {\n    vec2 e = vec2(0.0001, 0.0);\n    return normalize(vec3(map(pos+e.xyy).depth - map(pos-e.xyy).depth,\n                          map(pos+e.yxy).depth - map(pos-e.yxy).depth,\n                          map(pos+e.yyx).depth - map(pos-e.yyx).depth));\n}\n\n\n////////// https://www.shadertoy.com/view/cdjGWy\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n    const int maxIterationsShad = 32; \n    \n    ro += n*.0015;\n    vec3 rd = lp - ro;\n\n    float shade = 1.;\n    float t = 0.; \n    float end = max(length(rd), .0001);\n\n    rd /= end;\n\n\n    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t).depth;\n        shade = min(shade, k*d/t);\n\n        t += clamp(d, .005, .15); \n\n        if (d<0. || t>end) break; \n    }\n\n    return max(shade, 0.); \n}\n\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 3., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr).depth;\n        occ += (hr - d)*sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n}\n//////////\n\n\nvec3 render(in vec3 ro, in vec3 rd, in Material tm, in vec3 lp) {\n    vec3 col = vec3(0.4, 0.75, 1.0) - 0.7 * rd.y;\n    float t = tm.depth;\n    if(t < DEPTH_LIMIT) {\n        // Surface position and surface normal\n\t    vec3 sp = ro + rd*t;\n        vec3 sn = getNormal(sp, t);\n\n        // Light direction vector\n\t    vec3 ld = lp - sp;\n            \n        \n            // Distance from respective light to the surface point.\n            float lDist = max(length(ld), .001);\n\n            // Normalize the light direction vector.\n            ld /= lDist;\n\n            // Light attenuation, based on the distances above.\n            float atten = 1./(1. + lDist*.05);\n            \n            float sh = softShadow(sp, lp, sn, 16.);\n            float ao = calcAO(sp, sn); \n        \n        \n        // Diffuse lighting\n        float diff = max(dot(sn, ld), 0.0);\n        // Specular lighting\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 32.);\n        \n            // Fresnel term. Good for giving a surface a bit of a reflective glow.\n            //float fre = pow(clamp(1. - abs(dot(sn, rd))*.5, 0., 1.), 2.);\n\n            // Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n            // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n            // used to give a hard clay consistency... It \"kind of\" works.\n            float Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n            float freS = mix(.15, 1., Schlick);  //F0 = .2 - Glass... or close enough.\n        \n        col = tm.color;\n        \n        if(tm.id < 1.5){\n            col = dot(col, tex3D(iChannel0, sp, sn)) *.7 + col*.6;\n            col = col*(diff*sh + .3 + vec3(1, .97, .92)*spec*freS*2.0*sh);\n            \n        } else if (tm.id < 2.5) {\n            col = dot(col, tex3D(iChannel1, sp*2., sn)) *.9 + col*.25;\n            col = col*(5.*diff*sh + .3 + vec3(1, .97, .92)*7.*spec*freS*2.0*sh);\n        }\n                \n        //col = col*(diff*sh + .3 + vec3(1, .97, .92)*spec*freS*2.0*sh);\n        \n        col *= ao*atten;\n        //col = col*diff;\n    }\n    //return col;\n    vec3 back = mix(col, vec3(0.7, 0.75, 0.8), exp(-1.0*rd.y)) / 8.;\n    \n    return mix(col, back, smoothstep(0., .5, t/DEPTH_LIMIT));\n}\n\nvec3 calculateRayDirection(vec3 ro, vec3 lookAtPos, float FOV, vec2 uv) {\n    // Forward\n    vec3 fwd = normalize(lookAtPos - ro);\n    // Right\n    vec3 rgt = normalize(cross(vec3(0, 1, 0), fwd)); \n    // Up\n    vec3 up = cross(fwd, rgt);\n    // Calculate the ray direction\n    vec3 rd = normalize(uv.x * rgt + uv.y * up + fwd / FOV);\n    return rd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    float time = iTime;\n    float speed = time * min(time / 2., 4.);\n    if(iTime > 100.5) {\n        speed*=2.;\n    }\n    \n    vec3 ro = vec3(0.0 + cos(iTime * 0.83 + PI/2.) / 8.19 , 2.0 + sin(iTime) + sin((0.5*iTime*PI*BPM/60.0)) / 6., -8.0 + speed + sin((0.5*iTime*PI*BPM/60.0)) / 30.);\n    vec3 lookAtPos = vec3(0.0 + sin(iTime * 0.63) * 4. , -0.06, 0.0 + speed);  // Point vers lequel la cam√©ra regarde\n    float FOV = 1.0;  // Ajustez le champ de vision selon vos besoins\n    vec3 rd = calculateRayDirection(ro, lookAtPos, FOV, uv);  // Calcul de la direction du rayon\n    \n    Material tm = rayCast(ro, rd);\n    \n    // Light position\n    vec3 lp = vec3(2.0, 2.0, 0.0 + speed + sin(iTime/ 2.) * 6.);\n    \n    vec3 col = render(ro, rd, tm, lp);\n    \n    // sqrt gamma correction\n    fragColor = vec4(sqrt(max(col , 0.)), 1.0);\n}","name":"Image","description":"","type":"image"}]}