{"ver":"0.1","info":{"id":"ftfXWs","date":"1626774350","viewed":255,"name":"normal vs parallax fresnel","username":"nebbul","description":"fresnel effect on a flat raymarched sphere to compare normal map against parallax occlusion map","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["normal","fresnel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// original normal map shader from:\n// https://www.shadertoy.com/view/3ds3zf\n//\n// I basically just added a fresnel effect on it\n\n#define TWO_PI  6.28318530718\n#define PI      3.14159265359\n#define HALF_PI 1.57079632679\n\n#define PARALAX_INTENSITY 0.15\n#define PARALAX_QUALITY 25.0\n\n#define FRESNEL_EXPONENT 2.\n#define FRESNEL_INTENSITY 2.\n\nfloat map( in vec3 p )\n{\n    return length(p)-1.5;\n}\n\nmat3 computeTBN( in vec3 p )\n{\n    vec2 e = vec2(0.001,0);\n    \n    vec3 N = normalize( vec3( map( p + e.xyy ) - map( p - e.xyy ),\n                              map( p + e.yxy ) - map( p - e.yxy ),\n                              map( p + e.yyx ) - map( p - e.yyx ) ) );\n    \n    vec3 T = normalize( cross( vec3(0,1,0), N ) );\n    \n    vec3 B = cross( N, T );\n    \n    return mat3( T, B, N );\n}\n\nvec3 texNorm( in vec2 uv )\n{   \n    vec2 TexSize = vec2(textureSize(iChannel0,0));\n    \n    vec2 TexelCoordsC = vec2(TexSize) * uv;\n    vec2 TexelCoordsR = mod( TexelCoordsC + vec2( 1, 0), TexSize );\n    vec2 TexelCoordsT = mod( TexelCoordsC + vec2( 0, 1), TexSize );\n    vec2 TexelCoordsL = mod( TexelCoordsC + vec2(-1, 0), TexSize );\n    vec2 TexelCoordsB = mod( TexelCoordsC + vec2( 0,-1), TexSize );\n    \n    float r = texelFetch(iChannel0, ivec2(TexelCoordsR), 0).r;\n    float t = texelFetch(iChannel0, ivec2(TexelCoordsT), 0).r;\n    float l = texelFetch(iChannel0, ivec2(TexelCoordsL), 0).r;\n    float b = texelFetch(iChannel0, ivec2(TexelCoordsB), 0).r;\n    \n    float dx = l - r;\n    float dy = b - t;\n    \n    return normalize( vec3(dx, dy, 0.03) );\n}\n\nfloat sampleDepth(in vec2 uv)\n{\n\tfloat height = pow(texture(iChannel0,uv).r,2.2);\n    return 1.0 - pow(height,1.0/3.0);\n}\n\nfloat fresnel(vec3 normal, vec3 view, float exponent)\n{\n    return pow((1.0 - clamp((dot(normalize(normal), normalize(view))), 0., 1.)), exponent);\n}\n\n\nvec2 parallax( in vec2 uv, in vec3 view )\n{   \n    float numLayers = PARALAX_QUALITY;\n    float layerDepth = 1.0 / numLayers;\n    \n    vec2 p = view.xy * PARALAX_INTENSITY;\n    vec2 deltaUVs = p / numLayers;\n    \n    float Texd = sampleDepth(uv);\n\n    float d = 0.0;\n    while( d < Texd )\n    {\n        uv -= deltaUVs;\n        \n        Texd = sampleDepth(uv);\n        \n        d += layerDepth;  \n    }\n\n    vec2 lastUVs = uv + deltaUVs;\n    \n    float after = Texd - d;\n    float before = sampleDepth(lastUVs) - d + layerDepth;\n    \n    float w = after / (after - before);\n    \n    return mix( uv, lastUVs, w );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 MouseUVs = iMouse.xy/iResolution.xy;\n    MouseUVs = MouseUVs*2.0-1.0;\n    MouseUVs.x *= iResolution.x/iResolution.y;\n    float blackline = iMouse.z>0.5 ? MouseUVs.x : 0.0;\n    \n    vec2 scrPos = fragCoord/iResolution.xy;\n\tscrPos = scrPos*2.0 - 1.0;\n    scrPos.x *= iResolution.x / iResolution.y;\n    \n    vec3 o = vec3(0,0,3.5);\n    vec3 d = normalize(vec3(scrPos.xy,-2.0));\n    \n    float t=0.0;\n    float tmax = 10.0;\n    for(int i=0; i<256; ++i)\n    {\n        float dist = map( o + d * t );\n        \n        if( dist < 0.001 || dist > tmax ) break;\n        \n        t += dist;\n    }\n    \n    vec3 matNorm = vec3(0.5,0.5,1);\n    \n    vec3 col = pow(texture(iChannel0, fragCoord/iResolution.xy).rrr,vec3(2.2));\n    \n    if(t < tmax)\n    {\n        vec3 l = normalize(vec3(12));\n        vec3 p = o+d*t;\n        \n        \n        vec2 texUVs = vec2( (atan(p.x, p.z) - iTime*0.05) / (TWO_PI),\n                            (sign(p.y)*acos(dot( normalize(p), normalize(vec3(p.x,0.0,p.z)))) + HALF_PI) / PI\n                          );\n        texUVs *= 3.0;\n        \n        mat3 TBN = computeTBN( p );\n        \n        if(scrPos.x > blackline)\n        \ttexUVs = parallax( texUVs, normalize(-d * TBN) );\n        \n        vec3 matColor = mix( vec3(1.0), vec3(0.2,0.09,0.1), pow(sampleDepth(texUVs),1.0/2.0) );\n        \n        col = matColor * 0.02;\n        \n        matNorm = TBN * texNorm( texUVs );\n        col += clamp(dot(l,matNorm),0.0,1.0) * 0.5 * matColor;\n        \n        vec3 h = normalize(l - d);\n        col += pow(clamp(dot(h,matNorm),0.0,1.0),40.0) * 0.7;\n        \n        col += vec3( pow( 1.0 - clamp( dot(-d,TBN[2]) ,0.0,1.0), 5.5) * \n                     pow( 1.0 - clamp( dot(-d,matNorm),0.0,1.0), 10.0) ) * 0.3 * vec3(0.6,0.6,0.7);\n    }\n    \n\n    float f = fresnel(matNorm, vec3(0.,0.,1.), FRESNEL_EXPONENT);\n    vec3 fresnel_color = f * vec3(0.5, 0.8, 1.);\n    fresnel_color *= FRESNEL_INTENSITY;\n\n    vec3 col_final = pow(col,vec3(1.0/2.2)) + fresnel_color;\n    \n    col_final *= step(blackline+0.005, scrPos.x) + step(scrPos.x+0.005, blackline);\n    \n    fragColor = vec4(col_final,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}