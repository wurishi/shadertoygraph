{"ver":"0.1","info":{"id":"3ljyWz","date":"1594133743","viewed":666,"name":"Fractal city","username":"gaz","description":"inspired https://www.shadertoy.com/view/MtdBD8","likes":35,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// @FabriceNeyret2 thanks. \n\n// I rewrote it without a weight constant that I didn't understand.\n// Instead, a zoom constant is used to reduce color rippling\n\nstruct Data {\n    float interval;\n    vec3 pos0, pos1, dir0, dir1;\n    float up;\n};\n\nData data[] = Data[]( \n\tData(8., vec3(.9,1.2,.4), vec3(.6,1,.8),  vec3(1,0,1), vec3(1,1,0),  0.),\n    Data(9., vec3(0,.3,.6),   vec3(0,0,.6),   vec3(0,1,1), vec3(1,1,1),  2.),\n    Data(8., vec3(0,0,.4),    vec3(0,0,1.2),  vec3(1,0,1), vec3(1,1,1), -3.),\n    Data(8., vec3(0,.4,.7),   vec3(.4,0,.7),  vec3(1,1,0), vec3(0,1,1),  0.),\n    Data(7., vec3(.6,.6,.3),  vec3(.6,.8,0),  vec3(1,0,1), vec3(1,1,0),  3.),\n    Data(9., vec3(-.8,.4,.6), vec3(-.8,.6,0), vec3(0,0,1), vec3(1,0,1),  1.)\n);\n\n\n#define fold45(p)(p.y>p.x)?p.yx:p\nfloat map(vec3 p)\n{\n    float scale = 2.1,\n           off0 = .8,\n           off1 = .3,\n           off2 = .83;\n    vec3 off =vec3(2.,.2,.1);\n\tfloat s=1.0;\n\tfor(int i = 0;++i<20;)\n\t{\n\t\tp.xy = abs(p.xy);\n\t\tp.xy = fold45(p.xy);\n\t\tp.y -= off0;\n\t\tp.y = -abs(p.y);\n\t\tp.y += off0;\n\t\tp.x += off1;\n\t\tp.xz = fold45(p.xz);\n\t\tp.x -= off2;\n\t\tp.xz = fold45(p.xz);\n\t\tp.x += off1;\n\t\tp -= off;\n\t\tp *= scale;\n\t\tp += off;\n\t\ts *= scale;\n\t}\n\treturn length(p)/s;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int idx, size = data.length();\n\tfloat sam = 0.;\n    for(int i=0;i<size;i++) sam += data[i].interval;\n    float time = mod(iTime,sam);\n    sam = 0.;\n    for(idx=0; idx<size && time>sam; idx++)\n        sam += data[idx].interval;\n    Data P = data[idx-1];\n    // ++++++++++\n    // float t = (time-sam+P.interval)/P.interval;\n    // This is correct.\n    // However, I decided the camera control without noticing it, so changing it will break the picture.\n    // So this time, I'm using it while making a mistake.\n    float t = (time-sam)/P.interval;\n    const float zoom = 2.5;\n\tvec2  R = iResolution.xy,\n         uv = (2.*fragCoord-R)/R.y;\n    vec3 ro = mix(P.pos0, P.pos1, t) * zoom,\n          w = normalize(mix(P.dir0, P.dir1, t)),\n          u = normalize(cross(w,vec3(sin(P.up),cos(P.up),0))),\n         rd = mat3(u,cross(u,w),w)*normalize(vec3(uv,2));\n\n    float h = 0.0,d,i;\n    vec3 p;\n    for(i=1.;i<100.;i++)\n    {\n        p = ro+rd*h;\n        p /= zoom;\n\t    d = map(p);\n        if(d<0.001 || h>8.) break;\n        h += d;\n    }\n\tfragColor.xyz = 30.*vec3(cos(p*1.2)*.5+.5)/i;\n}\n\n\n/*\nstruct Data {\n    float interval;\n    vec3 pos0, pos1, dir0, dir1;\n    float grad, weight;\n};\n    \n//const Data Z = Data(0.,vec3(0),vec3(0),vec3(0),vec3(0),0.,0.);\nData data[] = Data[]( \n\tData(8., vec3(2.3,3,1), vec3(1.5,2.5,2),vec3(1,0,1), vec3(1,1,0),  .2, .4),\n    Data(9., vec3(0,1,2),   vec3(0,0,2),    vec3(0,1,1), vec3(1,1,1),  2., .3),\n    Data(8., vec3(0,0,1),   vec3(0,0,3),    vec3(1,0,1), vec3(1,1,1), -3., .4),\n    Data(8., vec3(0,1,1.7), vec3(1,0,1.7),  vec3(1,1,0), vec3(0,1,1),  0., .4),\n    Data(7., vec3(2,2,1),   vec3(2,2.5,0),  vec3(1,0,1), vec3(1,1,0),  3., .3),\n    Data(9., vec3(-2,1,1.5),vec3(-2,1.5,0), vec3(0,0,1), vec3(1,0,1),  1., .4)\n);\n\n#define fold45(p)(p.y>p.x)?p.yx:p\nfloat map(vec3 p)\n{\n    float scale = 2.1,\n           off0 = 0.8,\n           off1 = 0.3,\n           off2 = 0.83;\n    vec3 off = vec3(2.,.2,.1);\n\tfloat s = 1.0;\n\tfor(int i = 0;++i<20;)\n\t{\n\t\tp.xy = abs(p.xy);\n\t\tp.xy = fold45(p.xy);\n\t\tp.y -= off0;\n\t\tp.y =- abs(p.y);\n\t\tp.y += off0;\n\t\tp.x += off1;\n\t\tp.xz = fold45(p.xz);\n\t\tp.x -= off2;\n\t\tp.xz = fold45(p.xz);\n\t\tp.x += off1;\n\t\tp -= off;\n\t\tp *= scale;\n\t\tp += off;\n\t\ts *= scale;\n\t}\n\treturn length(p)/s;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int idx, size = data.length();\n\tfloat sam = 0.;\n    for(int i=0; i<size; i++) sam += data[i].interval;\n    float time = mod(iTime,sam);\n    sam = 0.;\n    for(idx=0; idx<size && time>sam; idx++)\n        sam += data[idx].interval;\n    Data P = data[idx-1];\n    float t = (time-sam)/P.interval;\n\tvec2  R = iResolution.xy,\n         uv = (2.*fragCoord-R)/R.y;\n    vec3 ro = mix(P.pos0, P.pos1, t),\n         up = vec3(sin(P.grad),cos(P.grad),0),\n          w = normalize(mix(P.dir0, P.dir1, t)),\n          u = normalize(cross(w,up)),\n         rd = mat3(u,cross(u,w),w)*normalize(vec3(uv,2));\n\n    float h = 0.0, d, i;\n    vec3 p;\n    for(i=0.; i<160.; i++)\n    {\n        p = ro+rd*h;\n        p *= P.weight;\n\t    d = map(p);\n        if(d < 0.001 || t > 20.) break;\n        h += d;\n    }\n\tfragColor.xyz = 20.*vec3(cos(p*1.2)*.5+.5)/i;\n}\n*/\n\n\n/*\n#define SIZE 10\nfloat interval[SIZE];\nvec3 pos0[SIZE];\nvec3 pos1[SIZE];\nvec3 dir0[SIZE];\nvec3 dir1[SIZE];\nfloat grad[SIZE];\nfloat weight[SIZE];\nint idx;\n\nvoid registPhase(float i,vec3 p0, vec3 p1, vec3 d0, vec3 d1, float g, float w)\n{\n interval[idx] = i;\n pos0[idx] = p0;\n pos1[idx] = p1;\n dir0[idx] = d0;\n dir1[idx] = d1;\n grad[idx] = g;\n weight[idx] = w;\n idx++;\n}\n\n#define fold45(p)(p.y>p.x)?p.yx:p\nfloat map(vec3 p)\n{\n    float scale=2.1;\n    float off0=0.8;\n    float off1=0.3;\n    float off2=0.83;\n    vec3 off =vec3(2.,.2,.1);\n\tfloat s=1.0;\n\tfor(int i = 0;++i<20;)\n\t{\n\t\tp.xy=abs(p.xy);\n\t\tp.xy=fold45(p.xy);\n\t\tp.y-=off0;\n\t\tp.y=-abs(p.y);\n\t\tp.y+=off0;\n\t\tp.x+=off1;\n\t\tp.xz=fold45(p.xz);\n\t\tp.x-=off2;\n\t\tp.xz=fold45(p.xz);\n\t\tp.x+=off1;\n\t\tp-=off;\n\t\tp*=scale;\n\t\tp+=off;\n\t\ts*=scale;\n\t}\n\treturn length(p)/s;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfor(int i=0; i<SIZE; i++)interval[i] = 0.0;\n\tidx=0;\n\tregistPhase(8.0, vec3(1.8,1.5,1.8), vec3(1.5,1.8,1.6), vec3(1,0,1), vec3(1,1,0),  0.2, 0.4);\n\tregistPhase(9.0, vec3(0,1,2), vec3(0,0,2), vec3(0,1,1), vec3(1,1,1),  2.0, 0.3);\n\tregistPhase(8.0, vec3(0,0.5,1), vec3(0,0.3,3), vec3(1,0,1), vec3(1,1,1),  -3.0, 0.4);\n    registPhase(8.0, vec3(0,1,1.7), vec3(1,0,1.7), vec3(1,1,0), vec3(0,1,1),  0.0, 0.4);\n    registPhase(7.0, vec3(2.1,-1.7,1), vec3(2,-1.4,1.8), vec3(-1,0,1), vec3(-1,.2,0.8),  3.0, 0.3);\n    registPhase(9.0, vec3(-2,1,1.2), vec3(-2,1.2,1.0), vec3(0,0,1), vec3(1,0,1),  1.0, 0.5);\n\tfloat sam = 0.0;\n\tfor(int i=0; i<SIZE; i++)sam += interval[i];\n\tfloat time=mod(iTime,sam);\n\tsam = 0.0;\n\tfor(idx=0; idx<SIZE; idx++)\n    {\n\t    if(time<=sam)break;\n\t    sam+=interval[idx];\n\t}\n    sam-=interval[idx];\n\tidx--;\n\tfloat t=(time-sam)/interval[idx];\n\t\n\t//idx=4;\n\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 ro = mix(pos0[idx], pos1[idx], t);\n    vec3 up = vec3(sin(grad[idx]),cos(grad[idx]),0);\n    vec3 w = normalize(mix(dir0[idx], dir1[idx], t));\n    vec3 u = normalize(cross(w,up));\n    vec3 rd = mat3(u,cross(u, w),w)*normalize(vec3(uv,2));\n    float h = 0.0,d;\n    float i;\n    vec3 p;\n    for(i=0.;i<160.;i++)\n    {\n        p=ro+rd*h;\n        p*=weight[idx];\n\t    d = map(p);\n        if(d < 0.001 || t > 20.) break;\n        h += d;\n    }\n\tfragColor.xyz= 20.*vec3(cos(p*1.2)*.5+.5)/i;\n}\n*/","name":"Image","description":"","type":"image"}]}