{"ver":"0.1","info":{"id":"stdcRl","date":"1660398975","viewed":128,"name":"assimilation","username":"pb","description":"dodecahedral fractal merging with a sphere","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["dodecahedron","morphing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//philip.bertani@gmail.com\n//Gaussian blur here instead of casting more rays for antialiasing\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\n    //size of one texel in iChannel0\n    vec2 texel = 1./iResolution.xy;\n\n    vec4 total_color;\n    //see 5x5 gaussian weights in Common \n    for (int i=0;i<5;i++){\n        float fi = float(i)-2.;\n        for (int j=0;j<5;j++){ \n            float fj = float(j)-2.;\n            vec4 color = texture(iChannel0, \n                uv + vec2( texel.x*fi,texel.y*fj )  );\n            total_color += color * gkhs[i*5 + j];\n        }\n    }\n    \n    fragColor = total_color;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//philip.bertani@gmail.com\n\n#define MAX_RAY_STEPS 100\n#define MAX_PRIME_RAY_DIST 10.\n#define PI 3.14159265\n\nint   max_iter;\nvec3  ifs_color;\nfloat ifs_scale;\n\nvec3 ambientL  = vec3(.2,.2,.4);\nvec3 diffuseL  = vec3(.4,.5,.4);\nvec3 specularL = vec3(.8,.7,0.);\nvec3 ambdir    = normalize(vec3(-.2,.4,1.));\n\n\nstruct RAYMARCH_RESULT {\n    vec3  raypos;\n    float dist_from_origin;\n    float object_id;\n};\n\n\nvec3  light_pos;\nvec2  myMouse;\nvec3  ro,rd;\nfloat threshold;\nvec3  adj_p;\nmat3  rot;\n\n\nfloat smoothOperator( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    float hh = k*h*(1.-h);\n    return  mix( d2, d1, h ) - hh;\n}\n\n\nmat3 rot_xz(float an) {\n    float cc = cos(an), ss=sin(an);\n    return mat3(cc,0.,ss,0.,1.,0.,-ss,0.,cc);\n\n}\n\nvec2 dist_func01(vec3 z) {\n    \n    vec3 min_vtx;\n    vec3 orig_z = z;\n    int n=0;\n    float min_dist,dist_to_vtx;\n\n    ifs_color = vec3(0.);\n\n    for (int i=0; i<30; i++) {\n       \n        if ( i > max_iter ) break;\n\n        vec3 dd_0 = d12[0];\n        min_vtx = dd_0;\n        min_dist=length(z-dd_0);\n        for (int j=1; j<20; j++) {\n            vec3 ddj = d12[j];\n            dist_to_vtx=length(z-ddj); \n            if (dist_to_vtx<min_dist) {min_vtx=ddj; min_dist=dist_to_vtx;}\n            \n        }\n        \n        z = min_vtx + ifs_scale*(z-min_vtx);\n        \n        n++;\n\n        //potentially interesting colors\n        \n        if ( z.x * z.y > 0. ) ifs_color.x ++;\n        if ( z.y * z.z > 0. ) ifs_color.y ++;\n        if ( z.z * z.x > 0. ) ifs_color.z ++;\n        \n        \n    }\n\n    ifs_color /= float(n);\n\n    float dz = pow(ifs_scale, float(n) );\n    //dz is simply the constant Scale factor to the power of number of times used\n\n    float scene_dist = length(z) / dz;  \n    float objid = 0.;\n\n    //tunnelling through when we are close enough\n    scene_dist = max( scene_dist, -(length(orig_z-ro) - .05) );\n   \n    float background = length(orig_z - .82*rot[2]  ) - .6;\n    \n    if ( background < scene_dist ) {\n        //scene_dist = background;\n        objid = 200.;\n        \n    }\n        \n    scene_dist = smoothOperator( scene_dist, background, .04);\n    \n    return vec2( scene_dist, objid );\n}\n\n\n\nvec3 estimate_normal_vec( vec3 pos, float neps, float dist ) {\n\n    \n    float norm_sign = 1.; \n\n    vec2  np = norm_sign * vec2( 1., -1);\n\n    float neps_final = neps;\n    vec2  dp = vec2( neps_final, -neps_final);\n   \n    vec3 df1 = np.xxx * dist_func01( pos + dp.xxx ).x;\n    vec3 df2 = np.xyy * dist_func01( pos + dp.xyy ).x;\n    vec3 df3 = np.yxy * dist_func01( pos + dp.yxy ).x;\n    vec3 df4 = np.yyx * dist_func01( pos + dp.yyx ).x;\n    \n    \n    return normalize( df1 + df2 + df3 + df4 );\n\n}\n\n\nRAYMARCH_RESULT raymarch( vec3 ro, vec3 rd, float eps, float initial_object_id ) {\n\n    float dist_from_origin = 0.; \n    vec3 raypos = ro;\n    RAYMARCH_RESULT result;\n    result.object_id = initial_object_id; \n    result.dist_from_origin = 0.;\n   \n    float init_threshold = eps;\n    threshold = init_threshold;\n    \n    for (int i=0; i<MAX_RAY_STEPS && dist_from_origin < MAX_PRIME_RAY_DIST; i++) {\n    \n        vec3 raypos = ro + dist_from_origin * rd;\n        vec2 dist_to_closest = dist_func01(raypos);\n        \n        float adj_dist = abs(dist_to_closest.x - threshold);\n        if ( abs(dist_to_closest.x) < threshold ) {\n        \n            result.object_id = dist_to_closest.y;\n            result.raypos = raypos;\n            result.dist_from_origin = dist_from_origin;\n            \n            adj_p = raypos - abs(dist_to_closest.x-threshold)*rd;\n            \n            break;\n        }\n        \n        if ( dist_from_origin > 1. ) {\n            result.object_id = -10.;\n            break;\n        }\n\n        raypos += dist_from_origin*rd; \n\n        dist_from_origin += dist_to_closest.x;\n        \n        threshold = init_threshold*(1.+dist_from_origin*50.);\n        \n    }\n       \n    return result;\n    \n}\n\nvec3  main_loop( vec3 ro, vec3 rd ) {\n    \n    RAYMARCH_RESULT prime_ray = raymarch( ro, rd, 2e-4, 100. );\n    \n    vec3 color = vec3(0.);\n    \n    if (prime_ray.object_id > -1. ) { \n    \n        vec3 nn = estimate_normal_vec( adj_p, 1e-4, prime_ray.dist_from_origin);\n        \n        vec3 lt_pos = light_pos;   \n        float spec_pow = 4.; \n        float spec_amp = 2.;\n        \n\n        vec3 view_dir = rd;\n        vec3 light_dir = normalize(lt_pos-prime_ray.raypos); \n        float diffuse_light = clamp(dot(light_dir, nn), 0., 1.);\n        float ambient_light =  -dot(nn, ambdir);\n     \n        vec3 refl=reflect(view_dir,nn);\n        float specular_light=pow(max(dot(refl,light_dir),0.0),spec_pow);\n        \n        vec3 fractal_color = cos( vec3(ifs_color.x*2.,\n                                       ifs_color.y*3., \n                                       ifs_color.z*5.) );\n        \n        //give a hint at what happens during function iteration\n        fractal_color = pow(fractal_color,vec3(5.) );\n        \n        if ( prime_ray.object_id == 200. ) { \n            color = ambient_light  * ambientL + \n                diffuse_light  * (diffuseL+.3*fractal_color) +\n                spec_amp*specular_light * specularL;\n            color *= 1.5;\n\n        }\n        else {\n            color = ambient_light  * ambientL + \n                diffuse_light  * (1.6*diffuseL-.5*fractal_color)  +\n                spec_amp*specular_light * specularL;\n        }       \n\n\n        color *= exp(-prime_ray.dist_from_origin*4.) ;       \n                   \n    }\n\n\n    return clamp(color, 0., 1.);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n      \n    vec2 uv = (2.0*fragCoord - iResolution.xy) / iResolution.y*2.;\n    \n    float myTime = mod(iTime,60.);\n    \n    \n    if (myTime < 30. ) {\n        ifs_scale = 1.02 + .002*myTime;\n    }\n    else {\n        float myTime2  = myTime - 30.;\n        ifs_scale = 1.02 + .002*30. - .002*myTime2;\n    }\n    \n    \n    rot = rot_xz(iTime/4.);\n    \n    max_iter = 7;\n    \n    ro = vec3(0.,0., 0.)  ;\n    rd = rot * normalize( vec3(uv, 2.2) ); \n    \n    light_pos = -rot[2] - 3.*sin(iTime/4.)*rot[0] + cos(iTime)*rot[1];\n    ;\n    vec3 color = main_loop(ro, rd);\n \n    fragColor = vec4(color,1.);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//gaussian_kernel_half_stdev\nfloat[] gkhs = float[] (\n        0.000002,0.000212,0.000922,0.000212,0.000002,\n        0.000212,0.024745,0.107391,0.024745,0.000212,\n        0.000922,0.107391,0.466066,0.107391,0.000922,\n        0.000212,0.024745,0.107391,0.024745,0.000212,\n        0.000002,0.000212,0.000922,0.000212,0.000002 );\n        \n        \n\n//hard coding the vertices for a dodecahedron\nconst float gmh=(sqrt(5.)+1.)/2.;\nconst float gmi=1./gmh;\n\nvec3[] d12 = vec3[]  (\nvec3(1.,1.,1.),\nvec3(1.,1.,-1.),\nvec3(1.,-1,1.),\nvec3(1.,-1,-1.),\nvec3(-1,1.,1.),\nvec3(-1.,1.,-1),\nvec3(-1.,-1.,1.),\nvec3(-1.,-1.,-1.),\nvec3(0.,gmh,gmi),\nvec3(0.,gmh,-gmi),\nvec3(0.,-gmh,gmi),\nvec3(0.,-gmh,-gmi),\nvec3(gmi,0.,gmh),\nvec3(gmi,0.,-gmh),\nvec3(-gmi,0.,gmh),\nvec3(-gmi,0.,-gmh),\nvec3(gmh,gmi,0.),\nvec3(gmh,-gmi,0.),\nvec3(-gmh,gmi,0.),\nvec3(-gmh,-gmi,0.)\n);\n","name":"Common","description":"","type":"common"}]}