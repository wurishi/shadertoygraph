{"ver":"0.1","info":{"id":"3lXGR7","date":"1562955541","viewed":250,"name":"My Blobby","username":"lulle","description":"My little blobby","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","blobby"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float MAX_STEPS = 32.;\nconst float EPS = .001;\nconst float END = 100.;\nconst float START = .0;\nfloat steps;\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 uni(vec2 d1, vec2 d2) { \n  float m = d1.y;\n  if (d1.x>d2.x) m = d2.y;\n  return vec2(min(d1.x, d2.x), m);\n}\n\nvec2 suni(vec2 d1, vec2 d2, float k) { \n  float h = clamp(0.5+0.5*(d2.x-d1.x)/k, 0.0, 1.0);\n  float m = d1.y;\n  if (d1.x>d2.x) m = d2.y;\n  return vec2(mix(d2.x,d1.x,h)-k*h*(1.-h), m);\n}\n\nfloat ssubs(float d1, float d2, float k) {\n  float h = clamp(0.5-0.5*(d2+d1)/k, 0.0, 1.0);\n  return mix(d2, -d1, h)+k*h*(1.0-h);\n}\n\nfloat sintsect(float d1, float d2, float k) { \n  float h = clamp(0.5-0.5*(d2-d1)/k, 0.0, 1.0);\n  return mix(d2, d1, h)+k*h*(1.0-h);\n}\n\nfloat sphere(vec3 p, float s) { \n  return length(p)-s;\n}\n\nfloat box(vec3 p, vec3 b) { \n  vec3 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\nfloat torus(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xy)-t.x,p.z);\n  return length(q)-t.y;\n}\n\nfloat elli(in vec3 p, in vec3 r) {\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.)/k1;\n}\n  \nfloat cap(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 pa = p-a, ba = b-a;\n  float h = clamp(dot(pa,ba)/dot(ba,ba), .0, 1.);\n  return length(pa-ba*h)-r;\n}\n\nfloat diss(vec3 p, float s) {\n    float d1 = sphere(p, s); \n    float d2 = (1.+sin(iTime))/2.*.05*(sin(15.*p.x)*cos(15.*p.y)*sin(15.*p.z));\n    return d1+d2;\n}\n\nvec2 sdf(in vec3 p) {\n    vec3 pos = vec3(.0,sin(iTime)*.5,.0);\n    vec2 r = vec2(diss(p-pos,1.),.0);\n    r = uni(r, vec2(sphere(p-vec3(-.3,.3,1.5)-pos, .15), 1.));\n    r = uni(r, vec2(sphere(p-vec3(.3,.3,1.5)-pos, .15), 1.));\n    r = uni(r, vec2(sphere(p-vec3(-.3,.3,1.7)-pos, .05), 2.));\n    r = uni(r, vec2(sphere(p-vec3(.3,.3,1.7)-pos, .05), 2.));\n    r = uni(r, vec2(torus(p-vec3(.0,-.3,1.3)-pos, vec2(max(.05, (1.+sin(iTime))*.2)/2., .03)), 3.));\n    r = suni(r, vec2(elli(p-vec3(.9*(1.+sin(iTime/30.)/4.),-.9*(1.2-sin(iTime)/6.),0.5)-pos, vec3(.2,.3,.4)), 0.), .7);\n    r = suni(r, vec2(elli(p-vec3(-.9*(1.+sin(iTime/30.)/4.),-.9*(1.2-sin(iTime)/6.),0.5)-pos, vec3(.2,.3,.4)), 0.), .7);\n    r = uni(r, vec2(cap(p-vec3(.1,.5,1.0)-pos, vec3(.1,.1,1.0), vec3(.35,.05,1.0), .03), 2.));\n    r = uni(r, vec2(cap(p-vec3(-.1,.5,1.0)-pos, vec3(-.1,.1,1.0), vec3(-.35,.05,1.0), .03), 2.));\n    return r;\n}\n\nvec2 march(vec3 eye, vec3 dir, float s, float e) {\n    float d = s;\n    for (float i = 0.; i < MAX_STEPS; i++) {\n        vec2 res = sdf(eye + d * dir);\n        steps = i;\n        if (res.x < EPS) return vec2(d, res.y);\n        d += res.x;\n        if (d >= e) return vec2(e, .0);\n    }\n    return vec2(e, .0);\n}\n\nvec3 rayDir(float fov, vec2 uv) {\n    vec2 xy = uv * 2. - 1.;\n    xy.y = xy.y / (16. / 9.);\n    float z = 2. / tan(radians(fov / 2.));\n    return normalize(vec3(xy, -z));\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sdf(vec3(p.x + EPS, p.yz)).x - sdf(vec3(p.x - EPS, p.yz)).x,\n        sdf(vec3(p.x, p.y + EPS, p.z)).x - sdf(vec3(p.x, p.y - EPS, p.z)).x,\n        sdf(vec3(p.xy, p.z + EPS)).x - sdf(vec3(p.xy, p.z - EPS)).x\n    ));\n}\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye, vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    if (dotLN < 0.) return vec3(0., 0., 0.);\n    if (dotRV < 0.) return lightIntensity * (k_d * dotLN);\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 amb = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = amb * k_a;\n    vec3 pos1 = vec3(0.0, 1.0*iTime/10.0, 30.0*iTime/20.0);\n    vec3 ints1 = vec3(0.4, 0.4, 0.4);\n    vec3 phong = phongContribForLight(k_d, k_s, alpha, p, eye, pos1, ints1);\n    color += phong;\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n    vec3 eye = vec3(.0,.0,10.);\n    vec3 dir = rayDir(60.0, uv);\n    vec2 res = march(eye, dir, START, END);\n    vec3 color = vec3(.0);\n    if (res.x >= END-EPS) {\n        float glow = min(max(0.,(steps-15.)*0.08), 1.);\n        fragColor = vec4(vec3(glow), 1.0);\n        return;\n    }\n    vec3 p = eye + dir * res.x;\n    color = vec3(uv, .5+.5*sin(iTime)); \n    if(res.y == 1.) color = vec3(.9);\n    if(res.y == 2.) color = vec3(.0);\n    if(res.y == 3.) color = vec3(.9,.0,.0);\n    color = phongIllumination(color, color, normalize(vec3(1.0, 1.0, 1.0)), 10.0, p, eye);\n    fragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"}]}