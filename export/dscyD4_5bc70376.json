{"ver":"0.1","info":{"id":"dscyD4","date":"1695058198","viewed":45,"name":"Twin Peaks","username":"airatlovesmusic","description":"I'll see you in 30 frames","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision mediump float;\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\nconst int MAX_MARCHING_STEPS=255;\nconst float MIN_DIST=0.;\nconst float MAX_DIST=100.;\nconst float PRECISION=.001;\nconst float EPSILON=.0005;\nconst float PI=3.14159265359;\n\nconst int FLOOR_ID=1;\nconst int CURTAINS_ID=2;\nconst int CEILING_ID=3;\nconst int LAMP_ID=4;\nconst int SOFA_ID=5;\nconst int BULB_ID=6;\n\nconst vec2 lamp=vec2(1.,.9);\n\nstruct Surface{\n  float sd;\n  int id;\n};\n\nfloat max2(vec2 v){return max(v.x,v.y);}\n\nmat2 rotate2d(float theta){\n  float s=sin(theta),c=cos(theta);\n  return mat2(c,-s,s,c);\n}\n\nSurface sMin(Surface s1,Surface s2){\n  if(s1.sd<s2.sd){\n    return s1;\n  }\n  return s2;\n}\n\nfloat sdBox(in vec2 p,in vec2 b)\n{\n  vec2 d=abs(p)-b;\n  return length(max(d,0.))+min(max(d.x,d.y),0.);\n}\n\nfloat sdBox(vec3 p,vec3 b){\n  vec3 q=abs(p)-b;\n  return length(max(q,0.))+min(max(q.x,max2(q.yz)),0.);\n}\n\nfloat sdPlane(vec3 p,vec3 n,float h)\n{\n  return dot(p,n)+h;\n}\n\nfloat sdRoundBox(vec3 p,vec3 b,float r)\n{\n  vec3 q=abs(p)-b;\n  return length(max(q,0.))+min(max(q.x,max(q.y,q.z)),0.)-r;\n}\n\nSurface sLamp(vec3 p){\n  float radius=length(p.xz-vec2(4.,6.));\n  float stem=max(p.y-.5,radius-.1);\n  float con = max(p.y - 2., max(.5 - p.y, radius - .1 - .4 * p.y));\n  float cone = max(p.y - 1.5, max(.5 - p.y, .5 * (radius - .1 - pow(p.y - .5, 2.))));\n\n  Surface support = Surface(min(stem, con), LAMP_ID);\n  Surface bulb = Surface(length(p - vec3(4.0, 1.5, 6.)) - 0.5, BULB_ID);\n  return sMin(support, bulb);\n}\n\nfloat sdSofa(vec3 p){\n  p.x=abs(p.x);\n  float box1=sdRoundBox(p+vec3(0.,1.,0.),vec3(3.,1.,1.),1.);\n  float box2=sdRoundBox(p-vec3(.5,0.,-1.5),vec3(2,3.,.1),1.);\n  float box3=sdRoundBox(p-vec3(3.5,0.,.5),vec3(.01,1.5,1.),.9);\n  \n  return min(box1,min(box2,box3));\n}\n\nSurface scene(vec3 p){\n  Surface floor=Surface(p.y+8.5,FLOOR_ID);\n  Surface room=Surface(-sdBox(p-vec3(0.,0.,5.),vec3(60.,30.,20.)),CEILING_ID);\n  Surface wall1=Surface((-p.x-.3*sin(p.z*4.)-.2*sin(p.z*8.)+8.)*.6,CURTAINS_ID);\n  Surface wall2=Surface((p.z+.3*sin(p.x*4.)-+.2*sin(p.x*8.)+13.)*.6,CURTAINS_ID);\n  \n  Surface lamp1=sLamp(p-vec3(-13.,0,-15.));\n  Surface lamp2=sLamp(p-vec3(1.5,0,-15.));\n  \n  Surface sofa1=Surface(sdSofa(p-vec3(-2.,-7,-8.)),SOFA_ID);\n  Surface sofa2=Surface(sdSofa(p-vec3(-15.,-7,-8.)),SOFA_ID);\n  \n  Surface co=sMin(floor,room);\n  co=sMin(co,wall1);\n  co=sMin(co,wall2);\n  co=sMin(co,lamp1);\n  co=sMin(co,lamp2);\n  co=sMin(co,sofa1);\n  co=sMin(co,sofa2);\n  \n  return co;\n}\n\nSurface rayMarch(vec3 ro,vec3 rd){\n  float depth=MIN_DIST;\n  Surface d;\n  \n  for(int i=0;i<MAX_MARCHING_STEPS;i++){\n    vec3 p=ro+depth*rd;\n    d=scene(p);\n    depth+=d.sd;\n    if(d.sd<PRECISION||depth>MAX_DIST)break;\n  }\n  \n  d.sd=depth;\n  \n  return d;\n}\n\nvec3 calcNormal(in vec3 p){\n  vec2 e=vec2(1,-1)*EPSILON;\n  return normalize(\n    e.xyy*scene(p+e.xyy).sd+\n    e.yyx*scene(p+e.yyx).sd+\n    e.yxy*scene(p+e.yxy).sd+\n    e.xxx*scene(p+e.xxx).sd);\n  }\n  \nmat3 camera(vec3 cameraPos,vec3 lookAtPoint){\n    vec3 cd=normalize(lookAtPoint-cameraPos);\n    vec3 cr=normalize(cross(vec3(0,1,0),cd));\n    vec3 cu=normalize(cross(cd,cr));\n    \n    return mat3(-cr,cu,-cd);\n  }\n  \nvec3 phong(vec3 lightDir,vec3 normal,vec3 rd,vec3 col){\n    // ambient\n    float k_a=.7;\n    vec3 i_a=col;\n    vec3 ambient=k_a*i_a;\n    \n    // diffuse\n    float k_d=.5;\n    float dotLN=clamp(dot(lightDir,normal),0.,1.);\n    vec3 i_d=vec3(1.);\n    vec3 diffuse=k_d*dotLN*i_d;\n    \n    // specular\n    float k_s=.9;\n    float dotRV=clamp(dot(reflect(lightDir,normal),-rd),0.,1.);\n    vec3 i_s=vec3(1,1,1);\n    float alpha=10.;\n    vec3 specular=k_s*pow(dotRV,alpha)*i_s;\n    \n    return ambient+diffuse+specular;\n  }\n  \nvec3 applyLightning(vec3 p,vec3 rd,Surface d){\n    vec3 col=vec3(0.);\n    if(d.sd>MAX_DIST){\n      col=vec3(0.);// ray didn't hit anything\n    }else{\n      vec3 normal=calcNormal(p);// surface normal\n      \n      vec3 lightPosition=vec3(0,3,-4);\n      vec3 lightDirection=normalize(lightPosition-p);\n      \n      vec3 lightPosition1=vec3(-13.,5.,-10.);\n      vec3 lightDirection1=normalize(lightPosition1-p);\n      \n      if(d.id==FLOOR_ID){\n        p.xz/=4.;\n        p.x=abs(mod(p.x,1.)-.5);\n        float a=mod(p.z-p.x,.5);\n        if(a<.25)col=vec3(.1,0.,0.);\n        else col=vec3(1.);\n      }else if(d.id==CURTAINS_ID){\n        col=vec3(1.,0.,0.);\n      }else if(d.id==CEILING_ID){\n        col=vec3(1.);\n      }else if(d.id==LAMP_ID){\n        col=vec3(1.);\n      } else if (d.id == BULB_ID) {\n        col = vec3(1.,1.,0.);\n      }\n      \n      col=.3*phong(lightDirection,normal,rd,col);\n      col+=.3*phong(lightDirection1,normal,rd,col);\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv=(fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    vec2 mouseUV=iMouse.xy/iResolution.xy;\n    \n    vec3 col=vec3(0);\n    vec3 lp=vec3(0);// lookat point\n    vec3 ro=vec3(0,0,10.);// ray origin that represents camera position\n    \n    float cameraRadius=2.;\n    ro.yz=ro.yz*cameraRadius*rotate2d(mix(-PI/8.,PI/8.,mouseUV.y));\n    ro.xz=ro.xz*rotate2d(mix(-PI/16.,PI/8.,mouseUV.x+.2*sin(iTime * 2.)))+vec2(lp.x,lp.z);\n    \n    vec3 rd=camera(ro,lp)*normalize(vec3(uv,-1));// ray direction\n    \n    Surface d=rayMarch(ro,rd);// signed distance value to closest object\n    \n    vec3 p=ro+rd*d.sd;// point on surface found by ray marching\n    col=applyLightning(p,rd,d);\n    \n    fragColor=vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}