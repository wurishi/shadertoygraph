{"ver":"0.1","info":{"id":"dlKcDt","date":"1700824042","viewed":18,"name":"Timing Function","username":"barton","description":"This shader shows how to work with timing curves.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["timing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Timing Function\n//\n// This shader shows possible implementation for handling animations using timing function.\n// This demo shows 5 timing functions in action (linear, easy, easy-in, easy-out, easy-in-out).\n//\n// Linear: Linear timing function has a constant speed throughout the animation. Its Bézier curve control points are:\n// Point 1: (0.0, 0.0)\n// Point 2: (1.0, 1.0)\n//\n// Ease-In (Accelerating): This timing function starts slow and accelerates. Its Bézier curve control points are:\n// Point 1: (0.42, 0.0)\n// Point 2: (1.0, 1.0)\n//\n// Ease-Out (Decelerating): This timing function starts fast and slows down at the end. Its Bézier curve control points are:\n// Point 1: (0.0, 0.0)\n// Point 2: (0.58, 1.0)\n//\n// Ease-In-Out (Smooth Start and End): This timing function combines aspects of both ease-in and ease-out. Its Bézier curve control points are:\n// Point 1: (0.42, 0.0)\n// Point 2: (0.58, 1.0)\n//\n// These control points define the shape of the curve used for the timing function. \n// In iOS development, you can use these parameters to create custom animations with different timing functions \n// to suit your app's needs.\n//\n// I found some examples of different possible timiming curves here: \n// https://easings.net/#\n// https://felarmir.com/post/05_creat_easy/\n//\n// ----------------------\n// Standard Timing Curves\n// ----------------------\n// constant TimingFunction kLinear         = { 0.0, 0.0,   0.0,   0.0,   1.0,   1.0, 1.0, 1.0 };\n// constant TimingFunction kEase           = { 0.0, 0.0,  0.25,   0.1,  0.25,   0.1, 1.0, 1.0 };\n// constant TimingFunction kEaseIn         = { 0.0, 0.0,  0.42,   0.0,   1.0,   1.0, 1.0, 1.0 };\n// constant TimingFunction kEaseOut        = { 0.0, 0.0,   0.0,   0.0,  0.58,   1.0, 1.0, 1.0 };\n// constant TimingFunction kEaseInOut      = { 0.0, 0.0,  0.42,   0.0,  0.58,   1.0, 1.0, 1.0 };\n//\n// --------------------\n// Custom Timing Curves\n// --------------------\n// constant TimingFunction kEaseInSine     = { 0.0, 0.0,  0.47,     0, 0.745, 0.715, 1.0, 1.0 };\n// constant TimingFunction kEaseOutSine    = { 0.0, 0.0,  0.39, 0.575, 0.565,     1, 1.0, 1.0 };\n// constant TimingFunction kEaseInOutSine  = { 0.0, 0.0, 0.445,  0.05,  0.55,  0.95, 1.0, 1.0 };\n// constant TimingFunction kEaseInQuad     = { 0.0, 0.0,  0.55, 0.085,  0.68,  0.53, 1.0, 1.0 };\n// constant TimingFunction kEaseOutQuad    = { 0.0, 0.0,  0.25,  0.46,  0.45,  0.94, 1.0, 1.0 };\n// constant TimingFunction kEaseInOutQuad  = { 0.0, 0.0, 0.455,  0.03, 0.515, 0.955, 1.0, 1.0 };\n// constant TimingFunction kEaseInCubic    = { 0.0, 0.0,  0.55, 0.055, 0.675,  0.19, 1.0, 1.0 };\n// constant TimingFunction kEaseOutCubic   = { 0.0, 0.0, 0.215,  0.61, 0.355,     1, 1.0, 1.0 };\n// constant TimingFunction kEaseInOutCubic = { 0.0, 0.0, 0.645, 0.045, 0.355,     1, 1.0, 1.0 };\n// constant TimingFunction kEaseInQuart    = { 0.0, 0.0, 0.895,  0.03, 0.685,  0.22, 1.0, 1.0 };\n// constant TimingFunction kEaseOutQuart   = { 0.0, 0.0, 0.165,  0.84,  0.44,     1, 1.0, 1.0 };\n// constant TimingFunction kEaseInOutQuart = { 0.0, 0.0,  0.77,     0, 0.175,     1, 1.0, 1.0 };\n// constant TimingFunction kEaseInQuint    = { 0.0, 0.0, 0.755,  0.05, 0.855,  0.06, 1.0, 1.0 };\n// constant TimingFunction kEaseOutQuint   = { 0.0, 0.0,  0.23,     1,  0.32,     1, 1.0, 1.0 };\n// constant TimingFunction kEaseInOutQuint = { 0.0, 0.0,  0.86,     0,  0.07,     1, 1.0, 1.0 };\n// constant TimingFunction kEaseInExpo     = { 0.0, 0.0,  0.95,  0.05, 0.795, 0.035, 1.0, 1.0 };\n// constant TimingFunction kEaseOutExpo    = { 0.0, 0.0,  0.19,     1,  0.22,     1, 1.0, 1.0 };\n// constant TimingFunction kEaseInOutExpo  = { 0.0, 0.0,     1,     0,     0,     1, 1.0, 1.0 };\n// constant TimingFunction kEaseInCirc     = { 0.0, 0.0,   0.6,  0.04,  0.98, 0.335, 1.0, 1.0 };\n// constant TimingFunction kEaseOutCirc    = { 0.0, 0.0, 0.075,  0.82, 0.165,     1, 1.0, 1.0 };\n// constant TimingFunction kEaseInOutCirc  = { 0.0, 0.0, 0.785, 0.135,  0.15,  0.86, 1.0, 1.0 };\n// constant TimingFunction kEaseInBack     = { 0.0, 0.0,   0.6, -0.28, 0.735, 0.045, 1.0, 1.0 };\n// constant TimingFunction kEaseOutBack    = { 0.0, 0.0, 0.175, 0.885,  0.32, 1.275, 1.0, 1.0 };\n// constant TimingFunction kEaseInOutBack  = { 0.0, 0.0,  0.68, -0.55, 0.265,  1.55, 1.0, 1.0 };\n//\n// P.S. In Metal I prefer to use timing constants instead of functions. In GLES I could not create more elegant way.\n\n\nstruct TimingFunction {\n    float c0x, c0y, c1x, c1y, c2x, c2y, c3x, c3y;\n};\n\nTimingFunction getLinear()    { \n    TimingFunction f; \n    f.c0x = 0.0;\n    f.c0y = 0.0;\n    f.c1x = 0.0; \n    f.c1y = 0.0; \n    f.c2x = 1.0; \n    f.c2y = 1.0; \n    f.c3x = 1.0; \n    f.c3y = 1.0;\n    return f; \n}\n\nTimingFunction getEase()    { \n    TimingFunction f; \n    f.c0x = 0.0;\n    f.c0y = 0.0;\n    f.c1x = 0.25; \n    f.c1y = 0.0; \n    f.c2x = 0.25; \n    f.c2y = 0.1; \n    f.c3x = 1.0; \n    f.c3y = 1.0;\n    return f; \n}\n\nTimingFunction getEaseIn()    { \n    TimingFunction f; \n    f.c0x = 0.0;\n    f.c0y = 0.0;\n    f.c1x = 0.42; \n    f.c1y = 0.0; \n    f.c2x = 1.0; \n    f.c2y = 1.0; \n    f.c3x = 1.0; \n    f.c3y = 1.0;\n    return f; \n}\n\nTimingFunction getEaseOut()    { \n    TimingFunction f; \n    f.c0x = 0.0;\n    f.c0y = 0.0;\n    f.c1x = 0.0; \n    f.c1y = 0.0; \n    f.c2x = 0.58; \n    f.c2y = 1.0; \n    f.c3x = 1.0; \n    f.c3y = 1.0;\n    return f; \n}\n\nTimingFunction getEaseInOut()    { \n    TimingFunction f; \n    f.c0x = 0.0;\n    f.c0y = 0.0;\n    f.c1x = 0.42; \n    f.c1y = 0.0; \n    f.c2x = 0.58; \n    f.c2y = 1.0; \n    f.c3x = 1.0; \n    f.c3y = 1.0;\n    return f; \n}\n\n\nfloat evaluateAtParameterWithCoefficients(float t, float coefficients[4]) {\n    return coefficients[0] + t * coefficients[1] + t * t * coefficients[2] + t * t * t * coefficients[3];\n}\n\nfloat evaluateDerivationAtParameterWithCoefficients(float t, float coefficients[4]) {\n    return coefficients[1] + 2.0 * t * coefficients[2] + 3.0 * t * t * coefficients[3];\n}\n\nfloat calcParameterViaNewtonRaphsonUsingXAndCoefficientsForX(float x, float coefficients[4]) {\n    float t = x;\n\n    for (int i = 0; i < 10; i++) {\n        float x2 = evaluateAtParameterWithCoefficients(t, coefficients) - x;\n        float d = evaluateDerivationAtParameterWithCoefficients(t, coefficients);\n        float dt = x2/d;\n        t = t - dt;\n    }\n\n    return t;\n}\n\nfloat calcParameterUsingXAndCoefficientsForX(float x, float coefficients[4]) {\n    return calcParameterViaNewtonRaphsonUsingXAndCoefficientsForX(x, coefficients);\n}\n\nfloat evaluateYAtX(float x, float cX[4], float cY[4]) {\n    if (((cX[1] == cY[1] && cX[2] == cY[2]) || x == 0.0 || x == 1.0)) {\n        return x;\n    }\n\n    float t = calcParameterUsingXAndCoefficientsForX(x, cX);\n    float y = evaluateAtParameterWithCoefficients(t, cY);\n    \n    return y;\n}\n\nfloat evaluateYAtX(float x, TimingFunction t) {\n    float cX[4];\n    cX[0] = t.c0x;                                       // t^0\n    cX[1] = -3.0 * t.c0x + 3.0 * t.c1x;                  // t^1\n    cX[2] = 3.0 * t.c0x - 6.0 * t.c1x + 3.0 * t.c2x;     // t^2\n    cX[3] = -t.c0x + 3.0 * t.c1x - 3.0 * t.c2x + t.c3x;  // t^3\n\n    float cY[4];\n    cY[0] = t.c0y;                                       // t^0\n    cY[1] = -3.0 * t.c0y + 3.0 * t.c1y;                  // t^1\n    cY[2] = 3.0 * t.c0y - 6.0 * t.c1y + 3.0 * t.c2y;     // t^2\n    cY[3] = -t.c0y + 3.0 * t.c1y - 3.0 * t.c2y + t.c3y;  // t^3\n    \n    return evaluateYAtX(x, cX, cY);\n}\n\nfloat sdCircle(vec2 uv, vec2 p, float r) {\n    return length(uv -p) - r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float duration = 2.0; \n    float t = mod(iTime, duration) / duration;\n    \n    float t1 = evaluateYAtX(t, getLinear());\n    float t2 = evaluateYAtX(t, getEase());\n    float t3 = evaluateYAtX(t, getEaseIn());\n    float t4 = evaluateYAtX(t, getEaseOut());\n    float t5 = evaluateYAtX(t, getEaseInOut());\n    \n    float x1 = mix(0.05, 0.95, t1);\n    float x2 = mix(0.05, 0.95, t2);\n    float x3 = mix(0.05, 0.95, t3);\n    float x4 = mix(0.05, 0.95, t4);\n    float x5 = mix(0.05, 0.95, t5);\n    \n    float d1 = sdCircle(uv, vec2(x1, 0.9), 0.05);\n    float d2 = sdCircle(uv, vec2(x2, 0.7), 0.05);\n    float d3 = sdCircle(uv, vec2(x3, 0.5), 0.05);\n    float d4 = sdCircle(uv, vec2(x4, 0.3), 0.05);\n    float d5 = sdCircle(uv, vec2(x5, 0.1), 0.05);\n\n    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 red = vec4(1.0, 0.0, 0.0, 1.0);\n    vec4 col = black;\n    col = mix(col, red, 1.0 - smoothstep(0.0, 0.02, d1));\n    col = mix(col, red, 1.0 - smoothstep(0.0, 0.02, d2));\n    col = mix(col, red, 1.0 - smoothstep(0.0, 0.02, d3));\n    col = mix(col, red, 1.0 - smoothstep(0.0, 0.02, d4));\n    col = mix(col, red, 1.0 - smoothstep(0.0, 0.02, d5));\n\n    fragColor = col;\n}","name":"Image","description":"","type":"image"}]}