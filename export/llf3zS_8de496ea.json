{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"precision highp float;\n\nconst float idAbyss = -1.0;\nconst float idMirror0 = 0.0;\nconst float idMirror1 = 1.0;\nconst float idMirrorEdge0 = 2.0;\nconst float idMirrorEdge1 = 3.0;\n\nconst float mirrorX = 1.0;\nconst float mirrorWidth = 0.5;\nfloat mirrorHeight;\nconst float mirrorEdgeWidth = 0.01;\nconst float fireflyRadius = 0.005;\nconst float fireflyLightRadius = 0.05;\n\nconst vec3 edgeColor1 = vec3(0.75, 0.75, 0.75);\nconst vec3 edgeColor0 = vec3(1.0, 0.84, 0.0);\nconst vec3 abyssColor = vec3(0.0, 0.0, 0.0);\nconst vec3 errorColor = vec3(1.0, 0.0, 0.0);\n\nconst float INFINITY = 1000.0;\nconst float EPS = 0.000001;\nconst float minDistance = 0.001;\nconst float PI = 3.14159265359;\nconst float START_MOVING_TIME = 10.0;\nconst float ACCELERATION_MOVING_TIME = 5.0;\n\n\nfloat iAntialising = 1.0; // Can be 0/1/2/3/4 (0X / 4X / 16X / 64X / 256X)\n\n\nfloat cameraRollAngle;  // Camera rotation angle around its ray of view.\nvec3 cameraOffset;\nvec3 cameraPosition;  // This is relative camera position. Real world camera position is (cameraOffset + cameraPosition).\n\nconst int firefliesCount = 4;\n\nvec3 firefliesPosition[firefliesCount];\nvec3 firefliesColor[firefliesCount];\n\n\nvoid initFireflies(float time) {\n    firefliesPosition[0] = vec3(-0.7 + sin(time * 5.0) * 0.05, sin(time + PI/2.0)*0.3-0.2, cos(time + PI/2.0)*0.2-0.1);\n    firefliesPosition[1] = vec3(-0.7 + sin(time * 5.0) * 0.05,\n        (mod(time, 4.0 * PI) > 2.0 * PI) ? sin(time + PI/2.0)*0.3-0.2 : sin(-time - PI/2.0)*0.1+0.2,\n        cos(time + PI/2.0)*0.2-0.1);\n    firefliesPosition[2] = vec3(sin(time) * 0.4, sin(time) * 0.1, cos(time) * 0.2);\n    firefliesPosition[3] = vec3(cos(time) * 1.8, sin(time) * mirrorWidth, -0.3);\n\n    firefliesColor[0] = vec3(0.0, 0.0, 1.0);\n    firefliesColor[1] = vec3(1.0, 0.0, 0.0);\n    firefliesColor[2] = vec3(0.0, 1.0, 0.0);\n    firefliesColor[3] = vec3(0.1, 0.3, 0.1);\n}\n\nvoid updateWorld(float time) {\n    time /= 500.0;\n    initFireflies(time);\n    mirrorHeight = mirrorWidth * iResolution.y / iResolution.x;\n\n    if (time < START_MOVING_TIME) {\n        time = 0.0;\n    } else {\n        time -= START_MOVING_TIME;\n        float p = 4.0;\n        float a = 1.0 / (p * pow(ACCELERATION_MOVING_TIME, p - 1.0));\n        if (time < ACCELERATION_MOVING_TIME) {\n            time = a * pow(time, p);\n        } else {\n            time = a * pow(ACCELERATION_MOVING_TIME, p) + (time - ACCELERATION_MOVING_TIME);\n        }\n    }\n    float t = sin(time*0.3);\n    cameraOffset = vec3(0.5 - 0.3 * t * t, t * (mirrorWidth + 0.1), 0.1*t*t);\n    vec2 xMotionNormal = normalize(vec2(2.0*0.3*t, 1.0));\n    cameraPosition = vec3(0.1*xMotionNormal.y, 0.1*xMotionNormal.x, 0.0);\n    cameraRollAngle = 5.0 * sin(time*0.8);\n}\n\nfloat projectPointOnTheSegment(in vec3 position, in vec3 a, in vec3 b) {\n    vec3 ap = position - a;\n    vec3 ab = b - a;\n    return dot(ap, ab) / dot(ab, ab);\n}\n\nfloat segment(in vec3 position, in vec3 a, in vec3 b) {\n    vec3 ap = position - a;\n    vec3 ab = b - a;\n    float t = dot(ap, ab) / dot(ab, ab);\n    return length(ap - ab * clamp(t, 0.0, 1.0));\n}\n\nfloat intersectRayWithYZPlane(in vec3 position, in vec3 direction, in float planeX) {\n    return (planeX - position.x) / direction.x;\n}\n\n\nvec2 update(in vec2 nearest, in vec2 candidate) {\n    return (candidate.x < nearest.x) ? candidate : nearest;\n}\n\nvec2 findNearest(in vec3 position, in vec3 direction) {\n    direction = normalize(direction);\n    float mirrorId = (direction.x < 0.0) ? idMirror0 : idMirror1;\n    float curMirrorX = (mirrorId == idMirror0) ? -mirrorX : mirrorX;\n    float toGoMirror = intersectRayWithYZPlane(position, direction, curMirrorX);\n    if (toGoMirror < -EPS) {\n        return vec2(INFINITY, idAbyss);\n    }\n    vec3 intersection = position + direction * toGoMirror;\n    if (abs(intersection.y) < mirrorWidth + EPS && abs(intersection.z) < mirrorHeight + EPS) {\n        return vec2(toGoMirror, mirrorId);\n    } else if (abs(intersection.y) < mirrorWidth + mirrorEdgeWidth + EPS && abs(intersection.z) < mirrorHeight + mirrorEdgeWidth + EPS) {\n        return vec2(toGoMirror, (mirrorId == idMirror0) ? idMirrorEdge0 : idMirrorEdge1);\n    } else {\n        return vec2(INFINITY, idAbyss);\n    }\n}\n\nvec3 getColor(float id) {\n    if (id == idMirrorEdge0) {\n        return edgeColor0;\n    } else if (id == idMirrorEdge1) {\n        return edgeColor1;\n    } else if (id == idAbyss) {\n        return abyssColor;\n    } else {\n        return errorColor;\n    }\n}\n\nvec3 calcNormal(float id) {\n    if (id == idMirror0 || id == idMirrorEdge0) {\n        return vec3(+1.0, 0.0, 0.0);\n    } else if (id == idMirror1 || id == idMirrorEdge1) {\n        return vec3(-1.0, 0.0, 0.0);\n    } else {\n        return vec3(0.0, 0.0, 1.0);\n    }\n}\n\nvec2 castRay(in vec3 rayStart, in vec3 rayDirection, inout vec3 haloColor) {\n    rayDirection = normalize(rayDirection);\n    vec2 nearest = findNearest(rayStart, rayDirection);\n    float depth = nearest.x;\n\n    for (int j = 0; j < firefliesCount; j++) {\n        float t = projectPointOnTheSegment(firefliesPosition[j], rayStart, rayStart + depth * rayDirection);\n        float dist = segment(firefliesPosition[j], rayStart, rayStart + depth * rayDirection);\n        if (t >= 0.0 && t < 1.0) {\n            if (dist < fireflyRadius) {\n                haloColor += firefliesColor[j];\n            } else if (dist < fireflyLightRadius) {\n                float fraction = 1.0 - sqrt(dist - fireflyRadius) / sqrt(fireflyLightRadius - fireflyRadius);\n                haloColor += firefliesColor[j] * fraction;\n            }\n        }\n    }\n    return nearest;\n}\n\nvec3 render(in vec3 rayStart, in vec3 rayDirection) {\n    const int maxReflections = 4096;\n\n    vec3 halo = vec3(0.0, 0.0, 0.0);\n    float nearestObjectId;\n    vec3 position;\n    for (int i = 0; i < maxReflections; i++) {\n        vec2 res = castRay(rayStart, rayDirection, halo);\n\n        position = rayStart + rayDirection * res.x;\n        nearestObjectId = res.y;\n        if (nearestObjectId == idMirror0 || nearestObjectId == idMirror1) {\n            rayStart = position;\n            rayDirection.x *= -1.0;\n        } else {\n            break;\n        }\n    }\n\n\n    vec3 objectColor = getColor(nearestObjectId);\n    vec3 objectNormal = calcNormal(nearestObjectId);\n\n    float globalAmbient = 0.8;\n    vec3 color = objectColor * globalAmbient;\n\n    color += halo;\n    return min(color, vec3(1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    updateWorld(iTime * 1000.0);\n\n    float cameraAngleOfView = 90.0 * PI / 180.0;\n    float cameraFocalDistance = 1.0 / tan(cameraAngleOfView / 2.0);\n\n    vec3 cameraDirection = normalize(-cameraPosition);\n    vec3 cameraScreenXAxis = normalize( cross(cameraDirection, (cameraDirection.xy != vec2(0.0, 0.0)) ? vec3(0.0, 0.0, 1.0): vec3(0.0, 1.0, 0.0)) );\n    vec3 cameraScreenYAxis = normalize( cross(cameraScreenXAxis, cameraDirection) );\n    vec3 screenCenter = cameraDirection * cameraFocalDistance;\n    float subPixels = pow(4.0, iAntialising);\n    vec3 color = vec3(0.0);\n    for (float i = 0.0; i < 256.0; i++) {\n        if (i >= subPixels) {\n            break;\n        }\n        float subPixelsInRow = pow(2.0, iAntialising);\n        vec2 pixel = fragCoord.xy + vec2(mod(i, subPixelsInRow), mod(i / subPixelsInRow, subPixelsInRow)) / subPixelsInRow;\n        pixel = (pixel / iResolution.xy - 0.5) * 2.0;\n        pixel.y *= iResolution.y / iResolution.x;\n\n        float cosRoll = cos(-cameraRollAngle*PI/180.0);\n        float sinRoll = sin(-cameraRollAngle*PI/180.0);\n        mat2 cameraRollRotation = mat2(cosRoll, -sinRoll, sinRoll, cosRoll);\n        pixel = cameraRollRotation * pixel;\n\n        vec3 rayDirection = normalize( screenCenter + (pixel.x * cameraScreenXAxis) + (pixel.y * cameraScreenYAxis) );\n        color += render(cameraOffset + cameraPosition, rayDirection);\n    }\n\n    fragColor.rgb = color / subPixels;\n    fragColor.a = 1.0;\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"llf3zS","date":"1422900528","viewed":307,"name":"Fireflies in mirrors corridor","username":"PolarNick239","description":"In fact raymarching here is not raymarching - because of explicit calculation of accurate distance for every march (for performance reasons).","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","antialiasing","reflections"],"hasliked":0,"parentid":"","parentname":""}}