{"ver":"0.1","info":{"id":"3dlSRn","date":"1550487278","viewed":185,"name":"evolutive landscape height map","username":"Myro","description":"study on 3D perlin noise, drawing level lines on a map\n previously ... : https://www.shadertoy.com/view/3sfSRn","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["studyon3dperlinnoise","drawinglevellinesonamap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 2D landscape height map generator made using noise\n\n// noise function from https://www.shadertoy.com/view/4sfGzS\n\nfloat hash(vec3 p) {\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(p+vec3(0,0,0)), \n                        hash(p+vec3(1,0,0)),f.x),\n                   mix( hash(p+vec3(0,1,0)), \n                        hash(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(p+vec3(0,0,1)), \n                        hash(p+vec3(1,0,1)),f.x),\n                   mix( hash(p+vec3(0,1,1)), \n                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n//----------------------------------------\n\n\n// biome colors from \n// https://www.shadertoy.com/view/3sfSRn\n\n//return a color from a to b when h goes from m to n (and divide the color by 255)\nvec3 colormix (vec3 a, vec3 b, float h, float m, float n) {\n    return mix(a/255.0, b/255.0, (h-m)/(n-m));\n}\n               \n//return a color from a to b to c when h goes from m to n (and divide the color by 255)\nvec3 tricolormix (vec3 a, vec3 b, vec3 c,float h, float m, float n) {\n\tfloat t = (h-m)/(n-m);\n    if (t<0.5) {\n    \treturn mix(a/255.0, b/255.0,t*2.0);\n    }\n    else {\n    \treturn mix(b/255.0, c/255.0,(t-0.5)*2.0);\n    }\n}\n\nvec3 biomeColor (float h) {\n\n    //vec3 fog=vec3(197.0,219.0,211.0);\n    float oceanh = 0.2;\n    vec3 ocean1 =vec3(8.0,42.0,79.0);\n    vec3 ocean2 =vec3(23.0,79.0,114.0);\n    float seah = 0.32;\n    vec3 sea1 =vec3(6.0,104.0,133.0);\n    vec3 sea2 =vec3(56.0,104.0,133.0);\n    float bayh = 0.4;\n    vec3 bay1 =vec3(79.0,176.0,159.0);\n    vec3 bay2 =vec3(93.0,204.0,167.0);\n    float shoreh = 0.45;\n    vec3 shore1 =vec3(131.0,246.0,191);\n    vec3 shore2 =vec3(234.0,246.0,191);\n    float beachh = 0.5;\n    vec3 beach1 =vec3(210.0,173.0,128.0);\n    vec3 beach2 =vec3(255.0,236.0,181.0);\n    float fieldh = 0.74;\n    vec3 field1 =vec3(31.0,122.0,4.0);\n    vec3 field2 =vec3(140.0,191.0,28.0);\n    float dirth = 0.92;\n    vec3 dirt1 =vec3(154.0,148.0,9.0);\n    vec3 dirt2 =vec3(204.0,170.0,31.0);\n    float rockh = 0.97;\n    vec3 rock1 =vec3(133.0,140.0,112.0);\n    vec3 rock2 =vec3(72.0,114.0,104.0);\n    vec3 snow1 =vec3(197.0,219.0,211.0);\n    vec3 snow2 =vec3(224.0,255.0,255.0);\n\n    if (h<oceanh)    \treturn colormix(ocean1, ocean2,h,0.0,oceanh);\n    if (h<seah)     \treturn tricolormix(ocean2,sea1,sea2,h,oceanh,seah);\n    if (h<bayh)         return tricolormix(sea2, bay1, bay2,h,seah,bayh);\n    if (h<shoreh)       return tricolormix(bay2, shore1, shore2,h,bayh,shoreh);\n    if (h<beachh)       return colormix(beach1, beach2,h,shoreh,beachh);\n    if (h<fieldh)       return colormix(field1,field2,h,beachh,fieldh);\n    if (h<dirth)        return tricolormix(field2, dirt1, dirt2,h,fieldh,dirth);\n    if (h<rockh)        return tricolormix(dirt2, rock1, rock2,h,dirth,rockh);\n\telse/*snow*/\t\treturn tricolormix(rock2,snow1, snow2,h,rockh,1.0);\t\n}\n// ------------------------------------\n// ORIGINAL TO THIS SHADER \n\n\nconst float dh = 0.2; // delta height between 2 level lines\n\n\n// returns the height for a given point \n// (x,y : coordinates, z : noise time offset)\nfloat height( in vec3 x ) {\n    float octaveFreq = 2.0;\n    float octaveAmp = 0.8;\n    \n\tfloat h = 1.0-2.0*noise(x);\n    for (int i=1; i<3; i++) {\n\t\th += octaveAmp*(1.0-2.0*noise(x*octaveFreq));\n    \toctaveAmp *= octaveAmp;\n        octaveFreq *= octaveFreq;\n    }\n    return 0.5+h*0.5;\n}\n    \n// return 1 if x is beween min and max, else 0 \nfloat band(float min, float max, float x) {\n\treturn step(min,x)*(1.0-step(max,x));\n}\n\nfloat heightLines(vec3 x) {\n    float c = 0.0; // color to be returned (black or white)\n    float hmin = dh*fract(iTime*0.5);\n    for (float i=hmin-dh; i<hmin+1.0+dh; i+=dh) {\n    \tc += band(i, i+0.005,height(x));\n    }\n    return c;\n}\n\n\n// retuns a color for a given point on the map, and time offset\nvec3 getColor (vec2 uv, float t) {\n\treturn biomeColor(height(vec3(uv,t))) * (1.0- vec3(heightLines(vec3(uv,t))));\n}\n\n\nconst float SCALE = 3.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized screen pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord/iResolution.xy-0.5)*2.0;\n    \n    vec2 mapuv = uv;// coordinate on the map\n    \n    if (iMouse.y <= 0.0) mapuv *= SCALE;\n    else mapuv *= SCALE *iMouse.y / iResolution.y;\n    \n    // vignette & vertical gradient\n    float postfx = 0.05*(uv.y)-0.02*length(uv)*length(uv);\n    // Output to screen\n    fragColor = vec4(getColor(mapuv+vec2(15.2,-8.2), iTime * 0.05) + postfx,1.0);\n}","name":"Image","description":"","type":"image"}]}