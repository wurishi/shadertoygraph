{"ver":"0.1","info":{"id":"XfSGWV","date":"1704628726","viewed":27,"name":"Raymarching Demo - Lighting","username":"SardineMilk","description":"The brightness of the object depends on the dot product of the normal to the light.\nIf the length of a ray from the point to the light source is less than the distance between the point and the light source,\nit has hit something, so it's shadowed.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float FOV = 90.;\n\n// Different operations on signed distance fields\nvec2 sdfSmoothUnionID(vec2 a, vec2 b, float k) {\n    float h = clamp(0.5 + 0.5*(a.x - b.x)/k, 0.0, 1.0);\n    float dist = mix(a.x, b.x, h) - k*h*(1.0-h);\n    \n    float id = (a.x < b.x) ? a.y : b.y;\n    \n    return vec2(dist, id);   \n    \n}\n\n\nvec2 sdfUnionID(vec2 a, vec2 b) {\n    float dist = min(a.x, b.x);\n    \n    return (a.x < b.x) ? vec2(dist, a.y) : vec2(dist, b.y);\n}\n\n\nvec2 sdfDifferenceID(vec2 a, vec2 b) {\n    float dist = min(a.x, -b.x);\n    \n    return (a.x < -b.x) ? vec2(dist, a.y) : vec2(dist, b.y);   \n}\n\n\nvec2 sdfIntersectionID(vec2 a, vec2 b) {\n    float dist = max(a.x, b.x);\n    \n    return (a.x > b.x) ? vec2(dist, a.y) : vec2(dist, b.y);   \n}\n\n\n// Different signed distance functions\nfloat sdSphere(vec3 point, vec3 centre, float radius) {\n    return length(point - centre) - radius;\n}\n\n\nfloat sdTiledSphere(vec3 point, vec3 centre, float radius) {\n    vec3 tiledPoint = mod(point - centre + 0.5, 1.) - 0.5;\n    return length(tiledPoint) - radius;\n}\n\n\nfloat sdTiltedPlane( vec3 point, vec3 normal, float height )\n{\n  // normal must be normalized\n  return dot(point, normal) + height;\n}\n\n\nfloat sdFlatPlane(vec3 point, float height) {\n    \n    return point.y + height;\n}\n\n\nfloat sdBox( vec3 point, vec3 centre, vec3 size) {\n  vec3 q = abs(point - centre) - size;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdWorms(vec3 p) {\n\tfloat s1 = length(mod(p.xy + vec2(sin((p.z + p.x) * 2.0) * 0.3, cos((p.z + p.x) * 1.0) * 0.5), 2.) - 1.0) - 0.2;\n\tfloat s2 = length(mod(0.5+p.yz + vec2(sin((p.z + p.x) * 2.0) * 0.3, cos((p.z + p.x) * 1.0) * 0.3), 2.) - 1.0) - 0.2;\n    return min(s1, s2);\n}\n\n\n// Calculate the Signed Distance Field for the scene\n\nvec2 map(vec3 point) {\n    vec2 result;  // result = vec2(signedDistance, objectID)\n\n    // Define Sphere1\n    vec3 sphere1Position = vec3(.8, -sin(iTime+iTime/2.)*1.5 - 1., 7.);\n    float sphere1Radius = .5;\n    float sphere1Distance = sdSphere(point, sphere1Position, sphere1Radius); \n    float sphere1ID = 1.;  // Index into colour switch statement\n    vec2 sphere1 = vec2(sphere1Distance, sphere1ID);\n    \n    // Define Sphere2\n    vec3 sphere2Position = vec3(sin(iTime) * 2., .75, cos(iTime)*2. + 7.);\n    float sphere2Radius = .75;\n    float sphere2Distance = sdSphere(point, sphere2Position, sphere2Radius); \n    float sphere2ID = 2.;\n    vec2 sphere2 = vec2(sphere2Distance, sphere2ID);\n    \n    // Define Box\n    vec3 boxPosition = vec3(-1.5, -1.25, 7.5);\n    vec3 boxSize = vec3(1., 1., 1.);\n    float boxDistance = sdBox(point, boxPosition, boxSize);\n    float boxID = 3.;\n    vec2 box = vec2(boxDistance, boxID);\n    \n    // Define Plane\n    float planeHeight = 1.5;\n    float planeDistance = sdFlatPlane(point, planeHeight);\n    float planeID = 4.;\n    if (mod(point.x, 5.0) < 2.5 ^^ mod(point.z, 5.0) < 2.5) planeID = 5.;\n    vec2 plane = vec2(planeDistance, planeID);\n    \n    result = sdfSmoothUnionID(sphere1, sphere2, 0.5);\n    result = sdfSmoothUnionID(result, box, 0.5);\n    result = sdfSmoothUnionID(result, plane, 0.5);\n    \n    result = sdfUnionID(sphere1, sphere2);\n    result = sdfUnionID(result, box);\n    result = sdfSmoothUnionID(result, plane, 0.75);\n    \n    return result;\n}\n\n\nvec4 rayMarch(vec3 point, vec3 direction) {\n    vec2 signedDistance;\n    vec4 result;\n    \n    const int maxMarchingSteps = 2555;  // Maximum number of times ray is marched until loop breaks\n    const float maxDistance = 1000.0;  // Maximum distance to object for a miss\n    const float minDistance = 0.00005;  // Minimum distance to object for a hit\n    \n    vec3 rayPosition = point;\n    \n    for (int i = 0; i < maxMarchingSteps; i++)  // March the ray forwards  \n    {        \n        // Distance to nearest object\n        vec2 signedDistance = map(rayPosition);\n\n        rayPosition += direction * signedDistance.x;  // Move the ray\n        \n        result = vec4(rayPosition, 0.0);\n        if (signedDistance.x > maxDistance) break;  // If the ray misses\n        if (signedDistance.x < minDistance) {\n            result = vec4(rayPosition, signedDistance.y);\n            break;  // If the ray hits something\n            }\n    }\n    \n    return result;\n}\n\n\nvec3 calculateNormal(vec3 position) {\n    const float EPSILON = 0.001;\n    \n    vec3 v1 = vec3(\n        map(position + vec3(EPSILON, 0.0, 0.0)).x,\n        map(position + vec3(0.0, EPSILON, 0.0)).x,\n        map(position + vec3(0.0, 0.0, EPSILON)).x);\n    vec3 v2 = vec3(\n        map(position - vec3(EPSILON, 0.0, 0.0)).x,\n        map(position - vec3(0.0, EPSILON, 0.0)).x,\n        map(position - vec3(0.0, 0.0, EPSILON)).x);\n    \n    return normalize(v1 - v2);\n        \n}\n\n\nvec3 getObjectColor(float id) {\n    if (id == 1.) return vec3(1.0, 0.0, 0.0);  // Red\n    if (id == 2.) return vec3(0.0, 1.0, 0.0);  // Green\n    if (id == 3.) return vec3(0.0, 0.0, 1.0);  // Blue\n    if (id == 4.) return vec3(0.5, 0.5, 0.5);  // Dark Grey\n    if (id == 5.) return vec3(0.25, 0.25, 0.25);  // Dark Grey\n    \n    return vec3(1.0, 0.0, 1.0);  // Default missing texture \n}\n\n\nvec3 calculateLighting(vec3 point, vec3 materialColor) {\n    vec3 color;\n    \n    vec3 lightPos = vec3(5.0, 5.0, 5.0);\n    vec3 lightColor = vec3(1.0, 1.0, 1.0);\n    \n    // Lighting\n    vec3 lightVector = normalize(lightPos - point);\n    vec3 pointNormal = calculateNormal(point);\n    float diffuseBrightness = dot(lightVector, pointNormal); \n    \n    // Shadows\n    // If the ray's distance is less than the distance between the light and the point\n    // Then it has hit something, and the pixel is shadowed\n    float shadowIntensity; // 1 = light, 0 = dark\n    float dist = length(rayMarch(point + lightVector * 0.001, lightVector).xyz - point);\n    \n    if (dist < length(lightPos - point)) shadowIntensity = 0.25;\n    else shadowIntensity = 1.;\n    \n    color = materialColor;\n    color *= vec3(diffuseBrightness) * lightColor;\n    color *= shadowIntensity;\n\n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Normalized pixel coordinates (from 0 to 1)\n    // Shifted so (0, 0) is the centre rather than bottom-left\n    vec2 shiftedCoord = fragCoord - (iResolution.xy / 2.0);\n    vec2 uv = shiftedCoord / iResolution.y;   \n    \n    vec3 rayPosition = vec3(uv.x, uv.y, 0.0);\n    vec3 rayDirection = vec3(0.0, 0.0, 1.0);\n    rayDirection.xy = uv.xy * atan(radians(FOV / 2.));\n    rayDirection = normalize(rayDirection);\n    \n    // Default colour for a miss\n    vec3 col = vec3(0., 0., 0.);\n    \n    vec4 hitPosID = rayMarch(rayPosition, rayDirection);\n\n    vec3 hitPosition = hitPosID.xyz;\n    float objectID = hitPosID.w;\n    \n    // If the ray hit, calculate lighting\n    if (objectID != 0.0) {\n        vec3 objectColor = getObjectColor(objectID);\n        col = calculateLighting(hitPosition, objectColor);\n    }\n    \n    // Gamma correction\n    float gamma = 2.2;\n    col = pow(col, vec3(1.0 / gamma));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}