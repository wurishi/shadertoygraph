{"ver":"0.1","info":{"id":"XttSRs","date":"1486057378","viewed":862,"name":"Lava Archipelgo","username":"TheSodOfGod","description":"Made by combining approaches from [url] https://www.shadertoy.com/view/4slGD4 [/url](Terrain) and [url]https://www.shadertoy.com/view/lslXRS[/url] / [url]https://www.shadertoy.com/view/MdBSRW[/url] for the lava.\n\nFrom my point of view the Jedi are evil.\n","likes":21,"published":1,"flags":0,"usePreview":1,"tags":["raymarching","perlinnoise","lava","islands"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGRr","filepath":"/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","previewfilepath":"/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","type":"music","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Constants\n#define PI 3.1415\n#define MOD2 vec2(3.07965, 7.4235)\n\n// Raymarching\nfloat minPrimStepSize = 0.4 ;\nconst int primNumSamples = 150 ;\n\n// Colours\nconst vec3 obsidianCol = vec3(30./255., 31./255., 30./255.) ;\nconst vec3 sunCol = vec3(1.0,1.0,1.0) ;\nconst vec3 skyCol = vec3(206./255., 146./255., 14./255.) ;\nconst float ambientCol = 0.3 ;\n\n// Sun\nconst float lightElev = 20. * 3.14/180. ;\nconst float lightAzi = 100. * 3.14/180. ;\nconst vec3 lightDir = vec3(cos(lightAzi)*cos(lightElev),sin(lightElev),sin(lightAzi)*cos(lightElev));\n\n// Terrain\nconst int octavesTerrain =  12 ;\nconst float sharpness = 0.35 ;\nconst float offset = 0.85 ;\n\n// Lava\n\nvec2 rot2D(vec2 p, float angle) {\n    angle = radians(angle);\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return p * mat2(c,s,-s,c);  \n}\n\nfloat rand(vec2 c){\n    return fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat hash12(vec2 p) {\n\tp  = fract(p / MOD2);\n    p += dot(p.xy, p.yx+19.19);\n    return fract(p.x * p.y);\n}\n\nconst vec2 add = vec2(1.0, 0.0);\n\nfloat noise( in vec2 x ) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float res = mix(mix( hash12(p),          hash12(p + add.xy),f.x),\n                    mix( hash12(p + add.yx), hash12(p + add.xx),f.x),f.y);\n    return res;\n}\n\nfloat noiseEmber(vec2 p) {\n    return hash12(p);\n}\n\nfloat smoothNoiseEmber(vec2 p) {\n    vec2 p0 = floor(p + vec2(0.0, 0.0));\n    vec2 p1 = floor(p + vec2(1.0, 0.0));\n    vec2 p2 = floor(p + vec2(0.0, 1.0));\n    vec2 p3 = floor(p + vec2(1.0, 1.0));\n    vec2 pf = fract(p);\n    return mix( mix(noise(p0), noise(p1), pf.x),mix(noise(p2), noiseEmber(p3), pf.x), pf.y);\n}\n\nconst int octavesEmber = 5 ;\n\nfloat fbmEmber(in vec2 p) {\n    float f=0.0;\n    for(int i=0; i < octavesEmber; ++i)\n        f+=smoothNoiseEmber(2.0*p*exp2(float(i)))/exp2(float(i+1));\n    return f;\n}\n\nfloat sampleField(vec3 position) {\n  float noiseVal = 0.0 ;\n  float amplitude = 1.0 ;\n  float scaling = 75. ;\n  float freq = 0.009 ;\n  float lac = 2.0 ;\n  for (int i = 0 ; i < octavesTerrain ; ++i) {\n    noiseVal += amplitude * noise(freq*position.xz) ;\n    amplitude /= lac ;\n    freq *= lac ;\n  }\n    \n  // Islandise terrain //\n  noiseVal -= offset ;\n  noiseVal = clamp(noiseVal,0.,1.5) ;\n  noiseVal = pow(sharpness, noiseVal) ;\n  noiseVal = 1.0 - (noiseVal) ;\n  return noiseVal * scaling ;\n}\n\n#define time iTime*0.1\n\nfloat hash21(in vec2 n){ return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453); }\nmat2 makem2(in float theta){float c = cos(theta);float s = sin(theta);return mat2(c,-s,s,c);}\nfloat noiseLava( in vec2 x ){return texture(iChannel0, x*0.02).x;}\n\nfloat sampleFreq = 0.2 ;\nvec2 gradn(vec2 p) {\n\tfloat ep = .09;\n\tfloat gradx = noiseLava(sampleFreq*vec2(p.x+ep,p.y))-noiseLava(sampleFreq*vec2(p.x-ep,p.y));\n\tfloat grady = noiseLava(sampleFreq*vec2(p.x,p.y+ep))-noiseLava(sampleFreq*vec2(p.x,p.y-ep));\n\treturn vec2(gradx,grady);\n}\n\n\n// ...... Taken from https://www.shadertoy.com/view/MdBSRW\n#define TEMPERATURE 2200.0\n\nvec3 blackbody(float t)\n{\n    t *= TEMPERATURE;\n    \n    float u = ( 0.860117757 + 1.54118254e-4 * t + 1.28641212e-7 * t*t ) \n            / ( 1.0 + 8.42420235e-4 * t + 7.08145163e-7 * t*t );\n    \n    float v = ( 0.317398726 + 4.22806245e-5 * t + 4.20481691e-8 * t*t ) \n            / ( 1.0 - 2.89741816e-5 * t + 1.61456053e-7 * t*t );\n\n    float x = 3.0*u / (2.0*u - 8.0*v + 4.0);\n    float y = 2.0*v / (2.0*u - 8.0*v + 4.0);\n    float z = 1.0 - x - y;\n    \n    float Y = 1.0;\n    float X = Y / y * x;\n    float Z = Y / y * z;\n\n    mat3 XYZtoRGB = mat3(3.2404542, -1.5371385, -0.4985314,\n                        -0.9692660,  1.8760108,  0.0415560,\n                         0.0556434, -0.2040259,  1.0572252);\n\n    return max(vec3(0.0), (vec3(X,Y,Z) * XYZtoRGB) * pow(t * 0.0004, 4.0));\n}\n\n\n// ..... Taken from https://www.shadertoy.com/view/lslXRS\nfloat flowFBM(in vec2 p)\n{\n\tfloat z=2.;\n\tfloat rz = 0.;\n\tvec2 bp = p;\n\tfor (float i= 1.;i < 9.;i++ ){\n\t\t//primary flow speed\n\t\tp += time*.006;\n\t\t//secondary flow speed (speed of the perceived flow)\n\t\tbp += time*0.00009;\n\t\t//displacement field (try changing time multiplier)\n\t\tvec2 gr = gradn(i*p*1.4+time*0.1);\n\t\t//rotation of the displacement field\n\t\tgr*=makem2(time*2.-(0.05*p.x+0.03*p.y)*40.);\n\t\t//displace the system\n\t\tp += gr*.5;\n\t\t//add noise octave\n\t\trz+= (sin(noise(p)*7.)*0.5+0.5)/z;\n\t\t//blend factor (blending displaced system with base system)\n\t\t//you could call this advection factor (.5 being low, .95 being high)\n\t\tp = mix(bp,p,.77);\n\t\t//intensity scaling\n\t\tz *= 1.4;\n\t\t//octave scaling\n\t\tp *= 3.1;\n\t\tbp *= 1.5;\n\t}\n\treturn rz;\t\n}\n\n\nvec3 getFieldNormal(in vec3 cameraPos, in vec3 direction, float dist) {\n  float p = min(.3, .0005+.00005 * dist*dist);\n  vec3 position = cameraPos + direction * dist ;\n  vec3 nor = vec3(0.0,sampleField(position), 0.0);\n  vec3 v2 = nor-vec3(p,sampleField(position+vec3(p,0.0,0.0)), 0.0);\n  vec3 v3 = nor-vec3(0.0,sampleField(position+vec3(0.0,0.0,-p)), -p);\n  nor = cross(v2, v3);\n  return normalize(nor);   \n}\n\nvec3 calcSkyCol(in vec3 direction)\n{\n\tfloat sunAmount = max( dot(direction, lightDir), 0.0 );\n\tfloat v = pow(1.0-max(direction.y,0.0),5.)*.5;\n\tvec3  sky = vec3(v*sunCol.x*0.4+skyCol.x, v*sunCol.y*0.4+skyCol.y, v*sunCol.z*0.4+skyCol.z);\n\tsky = sky + sunCol * pow(sunAmount, 6.5)*.32;\n\tsky = sky+ sunCol * min(pow(sunAmount, 1600.), .3)*.65;\n\treturn sky;\n}\n\nfloat fineRayMarchBinarySearch(vec3 startPos, vec3 direction, in vec2 rayDists, out float height) {\n    float halfwayT;\n\tfor (int n = 0; n < 4; n++)\n\t{\n\t\thalfwayT = (rayDists.x + rayDists.y) * .5;\n\t\tvec3 p = startPos + halfwayT*direction;\n\t\tif ((height = sampleField(p)) - p.y > 0.5) {\n\t\t\trayDists.x = halfwayT;\n\t\t} else {\n\t\t\trayDists.y = halfwayT;\n\t\t}\n\t}\n\treturn rayDists.x;\n}\n\nbool coarseRayMarch(vec3 startPos, vec3 direction, out float rayDist, out float height) {\n    vec3 position = startPos ;\n    bool intersected = false ;\n    rayDist = 0.0 ;\n    float oldRayDist = rayDist ;\n    \n    for (int i = 0 ; i < primNumSamples ; ++i) {\n        if (position.y > 66.) {\n            break ;\n        }\n\t\tif ((height = sampleField(position)) - position.y > 0.5) {            \n            intersected = true ;\n            break ;\n        } else {\n            oldRayDist = rayDist ;\n            float delta = max(minPrimStepSize,height*0.001) + (rayDist*0.025);\n\t\t    rayDist += delta;\n            position = (rayDist)*direction + startPos ;\n        }\n    }\n    \n    if (intersected) {\n       rayDist = fineRayMarchBinarySearch(startPos,direction,vec2(rayDist,oldRayDist),height) ;   \n    }\n    \n    return intersected ;\n}\n\n// Calculate sun light...\nvec3 calcColour(in vec3 pos, in vec3 normal, in vec3 eyeDir, float dis, float height)\n{\n  \tfloat h = dot(lightDir,normal);\n\tfloat c = max(h, 0.0)+ambientCol;\n    vec2 samplePosition = (eyeDir * dis + pos).xz  ;\n    vec3 lavCol = blackbody(flowFBM(samplePosition*0.005)) ;\n    float specular = 0.0 ;\n    vec3 col ;\n    if (height > 0.0) {\n        specular = 0.6 ;\n        col = obsidianCol ;\n        col = col * (sunCol + lavCol * 6.0/(height)) * c ;\n        if (h  > 0.0) {\n          vec3 R = reflect(lightDir, normal);\n\t  \t  float specAmount = pow( max(dot(R, normalize(eyeDir)), 0.0), 3.0)*specular;\n\t\t  col = mix(col, sunCol , specAmount);\n        }\n    } else {\n        col = lavCol ;\n    }\n    \n    return col ;\n}\n\nvec3 calcFog( in vec3  rgb, in float dis, in vec3 dir) {\n\tfloat fogAmount = exp(-dis* 0.002);\n\treturn mix(calcSkyCol(dir), rgb, fogAmount);\n}\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{    \n    vec2 uv = (fragCoord.xy - iResolution.xy * .5) / iResolution.y;\n    vec2  m = 2.*((iMouse.xy / iResolution.xy) - 0.5);\n    \n    if (iMouse.xy == vec2(0)) {\n       m.y = 0.0 ;   \n    }\n    \n    vec3 dir = vec3(uv, 1.);\n    dir.yz = rot2D(dir.yz,  90. * m.y);\n    dir.xz = rot2D(dir.xz, 180. * m.x + 180.);\n    dir = normalize(dir) ;\n\n    float offset = iTime ;\n    vec3 cameraPos = vec3(0.0,0.0,3.0*offset) ;\n    float heightOffset = sampleField(cameraPos) ;\n    cameraPos.y = 20.0 + heightOffset ;\n    float rayInterDist = -1.0 ;\n    float height = 0.0 ;\n\tbool hasIntersected = coarseRayMarch(cameraPos,dir,rayInterDist,height) ;\n    vec3 col = vec3(0.0) ;\n    if (hasIntersected) {\n      vec3 normal = getFieldNormal(cameraPos,dir,rayInterDist) ;\n      col = calcColour(cameraPos + dir*rayInterDist, normal, dir, rayInterDist, height) ;\n    } else {\n      col = calcSkyCol(dir) ;     \n    }\n    col =  calcFog(col,rayInterDist,dir) ;\n    \n    // Taken from \n    vec3 embers=vec3(1.0,0.35,0.04)*smoothstep(0.77+sin(time*5.0)*0.01+sin(time)*0.01,1.0,fbmEmber(uv*10.0+vec2(cos(uv.y*0.8+time*1.0)*10.0,time*40.0)));\n    embers+=vec3(1.0,0.35,0.04)*smoothstep(0.77+sin(time*82.0)*0.01+sin(time*1.2)*0.01,1.0,fbmEmber(vec2(100.0)+uv*8.0+vec2(time*1.0+cos(uv.y*0.3+time*1.0)*10.0,time*30.0)));\n\n\tfragColor = vec4(col + 8.*embers,1) ;\n}","name":"Image","description":"","type":"image"}]}