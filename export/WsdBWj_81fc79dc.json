{"ver":"0.1","info":{"id":"WsdBWj","date":"1606462115","viewed":176,"name":"a simple RT","username":"imagire","description":"A sample of ray tracing","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nuniform struct Sphere {\n    vec3 center;\n    float radius;\n\n    vec3 albedo;\n    float reflection;\n    float transmission;\n    float refraction_index;\n    \n};\n\nconst int OBJS_NUM = 4;\nSphere obj[OBJS_NUM];\n\n\nvoid initialize_global_object()\n{\n    obj[0] = Sphere(vec3(0,-100000.0,  0), 100000.0, vec3(0.76,0.64,0.44)*5.0, 0.0, 0.0, 100.0);// 地面\n    obj[1] = Sphere(vec3( 0, 0.5,   1), 0.5, vec3(1.00,0.00,0.00)*10.0, 0.05, 0.0, 1.0);// 赤\n    obj[2] = Sphere(vec3( 2, 0.5,  -1), 0.5, vec3(0.02,0.80,0.10)*10.0, 0.02, 0.93, 2.4);// 屈折\n    obj[3] = Sphere(vec3(-2, 0.5,  -1), 0.5, vec3(0.00,0.00,0.00)*10.0, 0.6, 0.0, 1.0);// 反射\n//    obj[4] = Sphere(vec3(1000.0,10000.0,500.0),1000.0, vec3(1000.00,990.0, 980.0), 0.0, 0.0, 100.0);// 太陽\n}\n\nvec3 sample_envmap(vec3 dir)\n{\n\treturn 15.0 * texture(iChannel0, dir).xyz;\n}\n\nfloat fresnel(float f0, float nv)\n{\n\treturn f0 + (1.0 - f0) * pow(1.0 - max(0.0, abs(nv)), 5.0);\n}\n\n\nfloat is_collide(const Sphere p, const vec3 pos, const vec3 dir)\n{\n\tvec3 oc = pos - p.center;\n\tfloat a = dot(dir, dir);\n\tfloat b = dot(oc, dir);\n\tfloat c = dot(oc, oc) - p.radius * p.radius;\n\tfloat discriminant = b * b - a * c;\n\n\tif (discriminant < 0.0f) return -1.0f; //衝突しませんでした\n\n\t// 手前の交点を返す\n\tfloat t = (-b - sqrt(discriminant)) / a;\n\tif (0.0f < t) return t; // 正でなければだめ\n\n\treturn (-b + sqrt(discriminant)) / a;// 奥の交点を返す\n\n}\n\n\nvec3 ray_trace3(vec3 pos, vec3 dir, int depth, float index)\n{\n\tfloat min_t = 100000000000.0f;// 十分遠い場所\n\tint min_idx = -1;\n    \n\tfor (int i = 0; i < OBJS_NUM; i++) \n\t{\n\t\t// 一番近いオブジェクトを検索\n\t\tfloat t = is_collide(obj[i], pos, dir);\n\t\tif (0.0001f < t && t < min_t) {// 何度も衝突するのを防ぐために少し前の値を採用\n\t\t\tmin_t = t;\n\t\t\tmin_idx = i;\n\t\t}\n\t}\n\n\t// 衝突しなかったら、空な色を返す\n\tif (min_idx < 0) return sample_envmap(dir);\n    \n\t// 色計算\n\tSphere p = obj[min_idx];\n\tvec3 new_pos = pos + dir * min_t;// 少し前に出して再判定されるのを防ぐ\n\tvec3 normal = normalize(new_pos - p.center);\n    float r = fresnel( p.reflection, -dot(normal, dir));\n    float t = (1.0 - r) * p.transmission;\n\n\t// 発光\n\tfloat emmisive = 1.0f - r - t;\n\tvec3 color = vec3( 0.0f, 0.0f, 0.0f );// 発光がなければ黒\n\tif (0.0f < emmisive) {\n\t\tcolor = p.albedo * emmisive;\n        if(min_idx == 0){\n            if(mod(floor(new_pos.x) + floor(new_pos.z), 2.0) < 1.0){\n\t\t\t\tcolor = p.albedo * emmisive * vec3(0.1, 0.4, 0.2);\n            }\n        }\n\t}\n    \n    \t// 反射\n\tif (0.0f < r) {\n\t\tvec3 reflect = dir + normal * (-2.0f * dot(normal, dir));\n\t\tcolor = color + sample_envmap(dir) * r;\n        return color;\n\t}\n    \n\tif (0.0f < t) {\n\t\tfloat new_index = (0.0f < dot(dir, normal)) ? 1.0f : p.refraction_index; // 出ていくか入っていくか?\n\t\tvec3 vert = normal * dot(dir, normal);// 垂直成分\n\t\tvec3 pall = dir - vert;// 平行成分\n\t\tvec3 reflact = normalize(vert + pall * index / new_index);\n\t\tnew_pos = new_pos + reflact * 0.01f;\n\t\tcolor = color + sample_envmap(dir) * t;\n\t}\n\n    return color;\n}\n\nvec3 ray_trace2(vec3 pos, vec3 dir, int depth, float index)\n{\n\tfloat min_t = 100000000000.0f;// 十分遠い場所\n\tint min_idx = -1;\n    \n\tfor (int i = 0; i < OBJS_NUM; i++) \n\t{\n\t\t// 一番近いオブジェクトを検索\n\t\tfloat t = is_collide(obj[i], pos, dir);\n\t\tif (0.0001f < t && t < min_t) {// 何度も衝突するのを防ぐために少し前の値を採用\n\t\t\tmin_t = t;\n\t\t\tmin_idx = i;\n\t\t}\n\t}\n\n\t// 衝突しなかったら、空な色を返す\n\tif (min_idx < 0) return sample_envmap(dir);\n    \n\t// 色計算\n\tSphere p = obj[min_idx];\n\tvec3 new_pos = pos + dir * min_t;// 少し前に出して再判定されるのを防ぐ\n\tvec3 normal = normalize(new_pos - p.center);\n    float r = fresnel( p.reflection, -dot(normal, dir));\n    float t = (1.0 - r) * p.transmission;\n\n\t// 発光\n\tfloat emmisive = 1.0f - r - t;\n\tvec3 color = vec3( 0.0f, 0.0f, 0.0f );// 発光がなければ黒\n\tif (0.0f < emmisive) {\n\t\tcolor = p.albedo * emmisive;\n        if(min_idx == 0){\n            if(mod(floor(new_pos.x) + floor(new_pos.z), 2.0) < 1.0){\n\t\t\t\tcolor = p.albedo * emmisive * vec3(0.1, 0.4, 0.2);\n            }\n        }\n\t}\n    \n    \t// 反射\n\tif (0.0f < r) {\n\t\tvec3 reflect = dir + normal * (-2.0f * dot(normal, dir));\n\t\tcolor = color + ray_trace3(new_pos, reflect, depth, index) * r;\n\t}\n    \n\t// 屈折\n\tif (0.0f < t) {\n\t\tfloat new_index = (0.0f < dot(dir, normal)) ? 1.0f : p.refraction_index; // 出ていくか入っていくか?\n\t\tvec3 vert = normal * dot(dir, normal);// 垂直成分\n\t\tvec3 pall = dir - vert;// 平行成分\n\t\tvec3 reflact = normalize(vert + pall * index / new_index);\n\t\tnew_pos = new_pos + reflact * 0.01f;\n\t\tcolor = color + ray_trace3(new_pos, reflact, depth, new_index) * t;\n\t}\n\n    return color;\n}\n\n\nvec3 ray_trace(vec3 pos, vec3 dir, int depth, float index)\n{\n\tfloat min_t = 100000000000.0f;// 十分遠い場所\n\tint min_idx = -1;\n    \n\tfor (int i = 0; i < OBJS_NUM; i++) \n\t{\n\t\t// 一番近いオブジェクトを検索\n\t\tfloat t = is_collide(obj[i], pos, dir);\n\t\tif (0.0001f < t && t < min_t) {// 何度も衝突するのを防ぐために少し前の値を採用\n\t\t\tmin_t = t;\n\t\t\tmin_idx = i;\n\t\t}\n\t}\n\n\t// 衝突しなかったら、空な色を返す\n\tif (min_idx < 0) return sample_envmap(dir);\n    \n\t// 色計算\n\tSphere p = obj[min_idx];\n\tvec3 new_pos = pos + dir * min_t;// 少し前に出して再判定されるのを防ぐ\n\tvec3 normal = normalize(new_pos - p.center);\n    float r = fresnel( p.reflection, -dot(normal, dir));\n    float t = (1.0 - r) * p.transmission;\n\n\t// 発光\n\tfloat emmisive = 1.0f - r - t;\n\tvec3 color = vec3( 0.0f, 0.0f, 0.0f );// 発光がなければ黒\n\tif (0.0f < emmisive) {\n\t\tcolor = p.albedo * emmisive;\n        \n        if(min_idx == 0){\n            if(mod(floor(new_pos.x) + floor(new_pos.z), 2.0) < 1.0){\n\t\t\t\tcolor = p.albedo * emmisive * vec3(0.1, 0.4, 0.2);\n            }\n        }\n\t}\n    \n    \t// 反射\n\tif (0.0f < r) {\n\t\tvec3 reflect = dir + normal * (-2.0f * dot(normal, dir));\n\t\tcolor = color + ray_trace2(new_pos, reflect, depth, index) * r;\n\t}\n    \n\t// 屈折\n\tif (0.0f < t) {\n\t\tfloat new_index = (0.0f < dot(dir, normal)) ? 1.0f : p.refraction_index; // 出ていくか入っていくか?\n\t\tvec3 vert = normal * dot(dir, normal);// 垂直成分\n\t\tvec3 pall = dir - vert;// 平行成分\n\t\tvec3 reflact = normalize(vert + pall * index / new_index);\n\t\tnew_pos = new_pos + reflact * 0.01f;\n\t\tcolor = color + ray_trace2(new_pos, reflact, depth, new_index) * t;\n\t}\n\n    return color;\n}\n\nvec3 uncharted2ToneMapping(vec3 x)\n{\n\tconst float A = 0.15;\n\tconst float B = 0.50;\n\tconst float C = 0.10;\n\tconst float D = 0.20;\n\tconst float E = 0.02;\n\tconst float F = 0.30;\n\treturn ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tinitialize_global_object();\n\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // projection space\n    vec2 pos_proj = uv * 2.0 - 1.0;\n    vec3 dir_view = vec3(pos_proj * vec2(iResolution.x/iResolution.y, 1.0) * 0.5, 1);\n    \n    // camera space\n    float theta = 2.0 * 3.141592 * fract(0.1 * iTime);\n    vec3 cam_pos = vec3(2.5 * sin(theta), 1.0, 2.5*cos(theta));\n    vec3 look_at = vec3(0.0, 0.7, 0.0);\n    vec3 cam_z = normalize(look_at - cam_pos);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 cam_x = normalize(cross(up, cam_z));\n    vec3 cam_y = normalize(cross(cam_z, cam_x));\n    \n    // world space;\n    vec3 pos_world = cam_pos;\n    vec3 dir_world = normalize(cam_x * dir_view.x + cam_y * dir_view.y + cam_z * dir_view.z);\n    \n    vec3 col = ray_trace(pos_world, dir_world, 0, 1.0f);\n    \n    // Output to screen\n    fragColor = vec4(uncharted2ToneMapping(col),1.0);\n}","name":"Image","description":"","type":"image"}]}