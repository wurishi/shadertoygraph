{"ver":"0.1","info":{"id":"Mc3yDl","date":"1731331100","viewed":18,"name":"Projet_Info_Graphique","username":"Siham","description":"Représentation des différentes primitives en respectant l'énoncé du TP.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["tpimage"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Ray {\n    vec3 o; // Origin\n    vec3 d; // Direction\n};\n\nstruct Val {\n    float v; // Signed distance\n    int c; // Cost\n};\n\nstruct ShadeResult {\n    vec3 color;\n    float reflectivity;\n};\n\n// Compute point on ray\nvec3 Point(Ray ray, float t) {\n    return ray.o + t * ray.d;\n}\n\n// Random direction in a hemisphere\nvec3 Hemisphere(int seed, vec3 n) {\n    float a = fract(sin(176.19 * float(seed))); // Uniform randoms\n    float b = fract(sin(164.19 * float(seed)));\n   \n    float u = 2. * 3.1415 * a; // Random angle\n    float v = acos(2. * b - 1.); // Arccosine distribution to compensate at poles\n   \n    vec3 d = vec3(cos(u) * cos(v), sin(u) * cos(v), sin(v)); // Direction\n    if (dot(d, n) < 0.) { d = -d; } // Hemisphere\n   \n    return d;\n}\n\n// Camera -------------------------------------------------------------------------------\n\n// Rotation matrix around z axis\nmat3 Rz(float a) {\n    float sa = sin(a); float ca = cos(a);\n    return mat3(ca, sa, 0., -sa, ca, 0.0, 0.0, 0.0, 1.);\n}\n\n// Compute the ray\nRay CreateRay(vec2 m, vec2 p) {\n    float a = 3. * 3.14 * m.x;\n    float le = 4.5; // Increased length\n \n    // Origin\n    vec3 ro = vec3(70., -4, 20.); // Increased position\n    ro *= Rz(a);\n \n    // Target point\n    vec3 ta = vec3(0., 0., 1.);\n \n    // Orthonormal frame\n    vec3 w = normalize(ta - ro);\n    vec3 u = normalize(cross(w, vec3(0., 0., 1.)));\n    vec3 v = normalize(cross(u, w));\n    vec3 rd = normalize(p.x * u + p.y * v + le * w);\n    return Ray(ro, rd);\n}\n\n// Primitives -------------------------------------------------------------------------------\n\n// Sphere\nVal Sphere(vec3 p, vec3 c, float r) {\n    return Val(length(p - c) - r, 1);\n}\n\n// Plane\nVal Plane(vec3 p, vec3 n, vec3 o) {\n    return Val(dot((p - o), n), 1);\n}\n\n// Donut (Torus)\nfloat sdTorus(vec3 p, float r1, float r2) {\n    vec2 q = vec2(length(p.xz) - r1, p.y);\n    return length(q) - r2;\n}\n\n// Roundbox\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b + r;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n\n\n// Torus ( 2nd definition )\nfloat sdTorus2( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n// Fonction de torsion\nfloat opTwist(in float d, in vec3 p) {\n    const float k = 10.0; // Force de la torsion\n    float c = cos(k * p.y);\n    float s = sin(k * p.y);\n    mat2 m = mat2(c, -s, s, c);\n    vec3 q = vec3(m * p.xz, p.y);\n    return d; // Retourne la distance signée pour la primitive\n}\n\n\n// Rubik's Cube\nfloat sdCube(vec3 p, float size) {\n    vec3 d = abs(p) - vec3(size); // Distance to the cube\n    return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\n// Fonction de rotation autour de l'axe Z\nmat3 rotateZ(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        c, -s, 0.0,\n        s, c,  0.0,\n        0.0, 0.0, 1.0\n    );\n}\n\n\n\n\n//rotation\nmat2 Rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\n\n// Function to rotate a point p around the X-axis by an angle theta\nvec3 rotateAroundX(vec3 p, float theta) {\n    mat3 rotationMatrix = mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(theta), -sin(theta),\n        0.0, sin(theta), cos(theta)\n    );\n    return rotationMatrix * p; // Apply rotation\n}\n\n// Donut with animation\nfloat sdTorusAnimated(vec3 p, float r1, float r2) {\n    // Positionner le donut avec un mouvement sur l'axe Y (ou un autre axe)\n    p.y += mod(iTime, 10.0) - 5.0;  // Mouvement oscillant dans la scène\n\n    // Calcul de la distance signée du donut\n    float d = sdTorus(p, r1, r2);\n    // Appliquer la torsion\n    return opTwist(d, p); // Applique la fonction de torsion\n}\n\n// Cylinder\nfloat sdCylinder(vec3 p, float r, float h) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\n// Box Frame\nfloat sdBoxFrame(vec3 p, vec3 b, float e) {\n    p = abs(p) - b;\n    vec3 q = abs(p + e) - e;\n    return min(min(\n        length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n        length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n        length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n// Cone with rotation on Z axis\nVal sdCone(vec3 p, vec2 c, float ra) {\n    // Rotation sur l'axe Z pour faire rouler le cône\n    float angle = iTime;  // Utilisation de iTime pour créer l'animation\n    p = p * rotateZ(angle);\n\n    // Calcul de la forme du cône\n    vec2 q = vec2(length(p.xz), p.y);\n    float l = length(q) - ra;\n    float m = length(q - c * clamp(dot(q, c), 0.0, ra));\n    return Val(max(l, m * sign(c.y * q.x - c.x * q.y)), 1);\n}\n\n//boite ondulée\nfloat sdBox(vec3 p, vec3 s) {\n    float angle = iTime;  \n    p = p * rotateZ(angle);\n    p = abs(p)-s;\nreturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdBoxT(vec3 p, vec3 s) {\n    p = abs(p)-s;\nreturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n//Donut imbriquée\nfloat sdDonut(vec3 p, float r1, float r2) {\n    float angle = iTime;  // Utilisation de iTime pour créer l'animation\n    p = p * rotateZ(angle);\n    vec2 q = vec2(length(p.xz) - r1, p.y);\n    q *= Rot(iTime);\n    q.y = abs(q.y) -.3;\n    return length(q) - r2;\n}\n\n//torsade\nfloat sdTorsade(vec3 p, float r1, float r2) {\n     float angle = iTime;\n    p.xz = Rot(angle) * p.xz;\n    vec2 q = vec2(length(p.xz) - r1, p.y);\n    float a = atan(p.x, p.z); //polar angle between -pi and pi\n    q *= Rot(a*2.5);\n    q.y = abs(q.y) -.3;\n    return length(q) - r2;\n}\n\n// Operators\n\n// Union\nVal Union(Val a, Val b) {\n    return Val(min(a.v, b.v), a.c + b.c + 1);\n}\n\n// Fonction de rotation autour de l'axe Y\nmat3 Ry(float a) {\n    float sa = sin(a); float ca = cos(a);\n    return mat3(ca, 0.0, -sa,\n                0.0, 1.0, 0.0,\n                sa, 0.0, ca);\n}\n\n// Mise à jour de la fonction de l'octaèdre pour inclure la rotation\nfloat sdOctahedron(vec3 p, float s) {\n    // Rotation autour de l'axe Y\n    float angle = iTime; // Utilisation de iTime pour l'animation\n    p = p * Ry(angle);\n\n    p = abs(p);\n    float m = p.x + p.y + p.z - s;\n    vec3 r = 3.0 * p - m;\n   \n    vec3 q;\n    if (r.x < 0.0) q = p.xyz;\n    else if (r.y < 0.0) q = p.yzx;\n    else if (r.z < 0.0) q = p.zxy;\n    else return m * 0.57735027;\n   \n    float k = clamp(0.5 * (q.z - q.y + s), 0.0, s);\n    return length(vec3(q.x, q.y - s + k, q.z - k));\n}\n\n\n//deformations\n\n// Displacement function\nfloat displacement(vec3 p) {\n    return 0.1 * sin(5.0 * p.x) * sin(10.0 * p.y) * sin(10.0 * p.z);\n}\n\n\n// WoodDisplacement function\nfloat woodDisplacement(vec3 p) {\n    float frequency = 3.0;  // Grain frequency\n    float scale = 0.1;      // Depth of the grain\n    return scale * sin(frequency * p.x + 10.0 * sin(frequency * p.y + frequency * p.z));\n}\n\n// brownianNoise\nfloat brownianNoise(vec3 p) {\n    float amplitude = 0.5;\n    float frequency = 1.0;\n    float noiseValue = 0.0;\n   \n    // Add multiple layers of noise\n    for (int i = 0; i < 4; i++) {\n        noiseValue += amplitude * sin(frequency * p.x) * sin(frequency * p.y) * sin(frequency * p.z);\n        frequency *= 2.0; // Increase frequency\n        amplitude *= 0.5; // Decrease amplitude\n    }\n    return noiseValue;\n}\n\n\n\n//vec3 brownColor = vec3(0.55, 0.27, 0.07); // Base brown color\n\n// Function to apply brownian noise for color variation\n//vec3 applyBrownianColor(vec3 p) {\n    // Get noise value from brownianNoise function\n    //float noiseValue = brownianNoise(p);\n\n    // Vary the brown color based on the noise value for a wood grain effect\n    //vec3 color = brownColor + noiseValue * vec3(0.2, 0.1, 0.05);\n\n    // Clamp the color to keep it within valid RGB range\n    //return clamp(color, 0.0, 1.0);\n//}\n\n\n// Pseudo-random noise function (for GLSL shaders, use a 3D noise function if available)\nfloat noise(vec3 p) {\n    return sin(p.x * 12.9898 + p.y * 78.233 + p.z * 37.719) * 43758.5453;\n}\n\n\n\n// Fractal Brownian Motion (fBm) function for a cloud-like effect\n//float cloudDisplacement(vec3 p) {\n    //float amplitude = 0.5;\n    //float frequency = 2.0;\n    //float cloudValue = 0.0;\n\n    // Apply several octaves of noise\n    //for (int i = 0; i < 5; i++) {\n        //cloudValue += amplitude * noise(frequency * p);\n        //frequency *= 2.0;   // Increase frequency for smaller details\n        //amplitude *= 0.5;   // Decrease amplitude for smoother blending\n    //}\n    //return cloudValue * 0.1; // Adjust the scale of the displacement\n//}\n\n\nfloat opTwist2(vec3 p, vec2 torusParams) {\n    const float k = (2.0); // Twist intensity\n    float c = cos(k * p.y);\n    float s = sin(k * p.y);\n    mat2 m = mat2(c, -s, s, c);\n    vec3 q = vec3(m * p.xz, p.y); // Apply twist transform\n    return sdTorus2(q, torusParams); // Specific to torus\n}\n\n\n// Mise à jour de la fonction object() pour inclure l'octaèdre\nVal object(vec3 p) {\n    // Plan\n    Val v = Plane(p, vec3(0., 0., 1.), vec3(0.0, 0.0, -4.0));\n   \n    // Donut animé\n    v = Union(v, Val(sdTorusAnimated(p - vec3(10., 6., 0.), 2.5, 0.5), 5));\n\n    // Cylindre\n    v = Union(v, Val(sdCylinder(p - vec3(10., 6., 0.), 1.0, 4.0), 1));\n\n    // Cône qui roule\n    v = Union(v, sdCone(p - vec3(-10., 7., 0.), vec2(0.707, 0.707), 4.0));\n\n    // Cube avec rotation\n    vec3 cubeP = p - vec3(0., 6., 0.);\n    cubeP = cubeP * rotateZ(iTime);\n    v = Union(v, Val(sdCube(cubeP, 1.0), 10));\n\n    // Cadre en forme de boîte\n    vec3 boxP = p - vec3(0., 6., 0.);\n    boxP = boxP * rotateZ(iTime);\n    v = Union(v, Val(sdBoxFrame(boxP, vec3(3., 3., 3.), 0.2), 1));\n\n    // Ajout de l'octaèdre\n    vec3 octaP = p - vec3(1.0, 16., 0.);\n    v = Union(v, Val(sdOctahedron(octaP, 3.5), 2));\n   \n    //boite ondulée\n    float boxD = sdBox(p - vec3(-10.0, -10.0, 0.0), vec3(2))-sin(p.x*7.5+iTime*2.)*.05;\n    Val box = Val(boxD,1);\n    v=Union(v, box);\n   \n    // Plateau de la table\n    float tableTopD = sdBoxT(p - vec3(0.0, -6.0, 0.0), vec3(3.0, 0.2, 2.0));\n    Val tableTop = Val(tableTopD, 1);\n    v = Union(v, tableTop);\n   \n     // Pied avant gauche\n    float legFLD = sdCylinder(p - vec3(-2.8, -8.0, -1.8), 0.1, 2.0);\n    Val legFL = Val(legFLD, 1);\n    v = Union(v, legFL);\n   \n    // Pied avant droit\n    float legFRD = sdCylinder(p - vec3(2.8, -8.0, -1.8), 0.1, 2.0);\n    Val legFR = Val(legFRD, 1);\n    v = Union(v, legFR);\n   \n    // Pied arrière gauche\n    float legBLD = sdCylinder(p - vec3(-2.8, -8.0, 1.8), 0.1, 2.0);\n    Val legBL = Val(legBLD, 1);\n    v = Union(v, legBL);\n   \n    // Pied arrière droit\n    float legBRD = sdCylinder(p - vec3(2.8, -8.0, 1.8), 0.1, 2.0);\n    Val legBR = Val(legBRD, 1);\n    v = Union(v, legBR);\n   \n    // Torsade\n    v = Union(v, Val(sdTorsade(p - vec3(8., -8.0, 0.), 1.7, 0.3), 1));\n   \n    // Donut imbriquée\n    v = Union(v, Val(sdDonut(p - vec3(-10., -2., 0.), 1.7, 0.2), 1));\n   \n    // Distorted Sphere\n    float sphereDist = length(p - vec3(15., -7., 2.)) - 3.0;\n    float distortedSphereDist = sphereDist + displacement(p);\n    v = Union(v, Val(distortedSphereDist, 1));\n   \n    // Box with displacement\n    float boxDist = sdRoundBox(p - vec3(20.0, 5.0, 2.0), vec3(3, 2.0, 1.0), 0.2);\n    float displacedBoxDist = boxDist + brownianNoise(p);\n   \n    v = Union(v, Val(displacedBoxDist, 1));\n   \n    // Twisted Torus\n    float torusDist = opTwist2(p - vec3(8.0, -18.0, 1.0), vec2(2.0, 0.5));\n    v = Union(v, Val(torusDist, 2));\n   \n    return v;\n   \n}\n\n// Deformations\n\n\n\n// Analysis of the scalar field -----------------------------------------------------------------\n\nconst int Steps = 200; // Number of steps\nconst float Epsilon = .01; // Marching epsilon\n\n// Object normal\nvec3 ObjectNormal(vec3 p) {\n    const float eps = .001;\n    vec3 n;\n    Val val = object(p);\n    float v = val.v;\n    n.x = object(vec3(p.x + eps, p.y, p.z)).v - v;\n    n.y = object(vec3(p.x, p.y + eps, p.z)).v - v;\n    n.z = object(vec3(p.x, p.y, p.z + eps)).v - v;\n    return normalize(n);\n}\n\n// Trace ray using ray marching\nbool SphereTrace(Ray ray, float e, out float t, out int s, out int c) {\n    bool h = false;\n    t = 0.0;\n    c = 0;\n \n    for (int i = 0; i < Steps; i++) {\n        s = i;\n        vec3 p = Point(ray, t);\n        Val val = object(p);\n        float v = val.v;\n        c += val.c;\n        // Hit object\n        if (v < 0.) {\n            h = true;\n            break;\n        }\n        // Move along ray\n        t += max(Epsilon, v);\n        // Escape marched too far away\n        if (t > e) {\n            break;\n        }\n    }\n    return h;\n}\n\n// Lighting -------------------------------------------------------------------------------\n\n// Background color\nvec3 background(Ray ray) {\n    return mix(vec3(.5, .55, .99), vec3(0., .69, .99), ray.d.z * .5 + .1);\n}\n\n// Shadowing\nfloat Shadow(vec3 p, vec3 n, vec3 l) {\n    float t;\n    int s;\n    int c;\n    bool hit = SphereTrace(Ray(p + Epsilon * n, l), 100., t, s, c);\n    if (!hit) {\n        return 1.;\n    }\n    return 0.;\n}\n\nvec3 WoodTexture(vec3 p) {\n    float noise = sin(p.x * 10.0 + sin(p.y * 10.0)) * 0.5 + 0.5;\n    vec3 woodColor = mix(vec3(0.5, 0.3, 0.1), vec3(0.7, 0.5, 0.3), noise);\n    return woodColor;\n}\n\n// Shading and lighting\n// Shading and lighting\nShadeResult Shade(vec3 p, vec3 n, Ray eye) {\n    const vec3 lp = vec3(2., 1., 25.); // Point light\n    vec3 l = normalize(lp - p); // Light direction to point light\n     \n    // Material properties\n    vec3 matteColor = vec3(0.0, 0.3, 0.2); // Default material color (teal)\n    vec3 mirrorColor = vec3(0.9, 0.9, 0.9); // Mirror color (light gray)\n     float reflectivity = 0.0;\n     // color of sphere\n    float threshold = 0.2;\n    if (abs(length(p - vec3(15., -7., 2.)) - 3.0) < threshold) {\n        matteColor = vec3(1., 0.3, 0.9); // Apply purple color (yellowish) for this specific region\n    }\n   \n    // color of deformed torus\n    float torusDist = opTwist2(p - vec3(8.0, -18.0, 1.0), vec2(2.0, 0.5)); // Assuming opTwist2 defines the torus distance\n    float torusThreshold = 0.2;\n    if (abs(torusDist) < torusThreshold) {\n        matteColor = vec3(2.0, 0.5, 0.0); // Apply orange color for the torus\n    }\n   \n    // color of roundbox\n    float boxDist = sdRoundBox(p - vec3(20.0, 5.0, 2.0), vec3(3.0, 2.0, 1.0), 0.2);\n    float displacedBoxDist = boxDist + brownianNoise(p);\n    float boxThreshold = 0.2;\n    if (abs(displacedBoxDist) < boxThreshold) {\n        // Apply a gradient  based on position\n        float gradientFactor = 0.5 + 0.5 * sin(p.x + p.y + p.z); // Create a smooth gradient effect\n        matteColor = vec3(0.5, 0., gradientFactor); // Blue gradient\n    }\n   \n   \n   \n   \n     \n     \n    // Determine the color based on the object type\n    if (dot(n, vec3(0., 0., 1.)) > 0.99) { // Plane\n        //matteColor = vec3(0.5, 0.5, 0.5); // Gray\n         // Checkerboard pattern on the floor (assuming floor is along z = -4.0 plane)\n    if (abs(p.z + 4.0) < 0.1) { // Adjust for the floor height as needed\n        // Adjust the scaling factor to control the size of the chess squares\n        float scale = 2.0;\n        vec2 coord = floor(p.xy / scale);\n\n        // Alternate between two colors based on the checker pattern\n        if (mod(coord.x + coord.y, 2.0) < 1.0) {\n            matteColor = vec3(0.9, 0.9, 0.9); // Light color for the squares\n        } else {\n            matteColor = vec3(0.1, 0.1, 0.1); // Dark color for the squares\n       \n    }\n }  \n   \n \n   \n\n    } else if (length(p - vec3(-10.0, -10.0, 0.0)) < 0.5){//Boîte\n        matteColor = vec3(0.0, 0.0, 1.0); // Couleur Bleue\n    } else if (length(p - vec3(10., 6., 0.)) < 2.5) { // Donut\n        matteColor = vec3(1.0, 0.5, 0.0); // Orange\n    } else if (abs(p.y) < 5.0 && length(p.xz - vec2(10., 6.)) < 1.0) { // Cylinder\n        matteColor = vec3(0.0, 0.0, 1.0); // Blue\n    } else if (length(p - vec3(-1.5, 5., 6.)) < 0.5) { // Cube 1\n        matteColor = vec3(0.8, 0.2, 0.2); // Red\n    } else if (length(p - vec3(-5, 5., 0.)) < 0.5) { // Box frame 1\n        matteColor = vec3(0.2, 0.8, 0.2); // Green\n    } else if (length(p - vec3(2, 5., 0.)) < 0.5) { // Box frame 2\n        matteColor = vec3(0.2, 0.2, 0.8); // Blue\n    } else if (length(p - vec3(10., 20., 0.)) < 5.0) { // Cone\n        matteColor = vec3(0.9, 0.7, 0.1); // Yellow\n    } else if (length(p - vec3(0., -8., 0.)) < 0.5) { // Cone\n        matteColor = vec3(0.9, 0.7, 0.1); // Yellow\n    }else if (length(p - vec3(0.0, -6.0, 0.0)) < 3.5) { // Plateau de la table\n        // Texture en bois pour le plateau\n        matteColor = WoodTexture(p - vec3(0.0, -4.0, 0.0));\n        reflectivity = 0.2; // Légèrement réfléchissant\n    } else if (length(p - vec3(-2.8, -8.0, -1.8)) < 2.0 || // Pied avant gauche\n               length(p - vec3(2.8, -8.0, -1.8)) < 2.0 ||  // Pied avant droit\n               length(p - vec3(-2.8, -8.0, 1.8)) < 2.0 ||  // Pied arrière gauche\n               length(p - vec3(2.8, -8.0, 1.8)) < 2.0) {   // Pied arrière droit\n        // Texture en bois pour les pieds\n        matteColor = WoodTexture(p);\n        reflectivity = 0.2;\n    }else if (length(p - vec3(8., -8.0, 0.)) < 4.0) { //Torsade\n        matteColor = vec3(1.0, 0.5, 0.0); // Orange\n    }else if (length(p - vec3(-10., -2., 0.)) < 4.0) { //Donut imbriquée\n        matteColor = vec3(1.0, 0.5, 0.0); // Orange\n    }\n   \n    vec3 ambient = 0.1 * matteColor + 0.1 * background(Ray(p, n));\n    //vec3 ambient = 0.1 * matteColor + 0.05 * background(Ray(p, n));\n   \n   \n    float shadow = Shadow(p, n, l);\n \n    vec3 diffuse = 1.5 * max(dot(l, n), 0.) * matteColor;\n    vec3 h = normalize(l - eye.d); // Halfway vector\n    vec3 specular = 2.3 * pow(max(dot(h, n), 0.), 64.) * mirrorColor;\n \n    vec3 color = shadow * (ambient + diffuse + specular);\n    return ShadeResult(color, reflectivity);\n}\n\n//reflexivity\nfloat GetReflectivity(vec3 p) {\n    float reflectivity = 0.0;\n\n    if (length(p - vec3(0.0, -6.0, 0.0)) < 2.0) { // Boîte\n        reflectivity = 0.8; // La boîte est réfléchissante à 80%\n    }\n    return reflectivity;\n}\n\n// Render scene\nvec3 Render(Ray eye) {\nconst int MAX_REFLECTION_DEPTH = 3;\n    vec3 col = vec3(0.0);\n    vec3 attenuation = vec3(1.0);\n    Ray currentRay = eye;\n    float t;\n    int steps;\n    int cost;\n   \n   \n     for (int depth = 0; depth < MAX_REFLECTION_DEPTH; depth++) {\n\n        bool hit = SphereTrace(currentRay, 100., t, steps, cost);\n        if (!hit) {\n            col += attenuation * background(currentRay); // Ajout de la couleur du fond\n            break;\n        }\n\n        vec3 p = Point(currentRay, t); // Point d'intersection\n        vec3 n = ObjectNormal(p); // Normale à la surface\n        ShadeResult shadeResult = Shade(p, n, currentRay);\n        vec3 localColor = shadeResult.color;\n        float reflectivity = shadeResult.reflectivity;\n\n        col += attenuation * localColor * (1.0 - reflectivity);\n\n        if (reflectivity > 0.0) {\n            // Calculer la direction du rayon réfléchi\n            vec3 reflectedDir = reflect(currentRay.d, n);\n            currentRay = Ray(p + n * Epsilon, reflectedDir);\n            attenuation *= reflectivity;\n        } else {\n            break; // Pas de réflexion supplémentaire\n        }\n    }\n\n    return col;\n}\n\n// Main -------------------------------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    Ray eye = CreateRay(iMouse.xy / iResolution.xy, p);\n   \n    vec3 col = Render(eye);\n    fragColor = vec4(sqrt(col), 1.0); // Gamma correction\n   \n}\n","name":"Image","description":"","type":"image"}]}