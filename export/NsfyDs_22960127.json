{"ver":"0.1","info":{"id":"NsfyDs","date":"1642878319","viewed":371,"name":"optimized grid neighborhood","username":"FabriceNeyret2","description":"People usually check the central cell + the 8 neighbors.\nBut you can eval only 3 neighbors, chosen depending on the side the current pixel is in the central cell.\n\nclick to see the full Voronoi. small parts are missed.\n","likes":18,"published":3,"flags":0,"usePreview":0,"tags":["voronoi","grid","worley","tuto","loopless"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define hash(p) fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n#define rot 1   // 1 : additionnal displacement + rotation\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    \n    vec2 R = iResolution.xy,\n         U = 10.*u/iResolution.y + iTime, \n         I = floor(U), F = fract(U), P,H,S,A;\n    float d = 1e9;\n    \n#if 0                                 // --- the classical 9-cells loop\n    for( int k=0; k<9; k++) {   \n        P = vec2(k%3,k/3)-1.;         // variant: P = I+...; P+= hash(P) - U\n        H = hash(I+P);                // random point in cell\n        A = hash(I+P+.5);             // for random rotation\n  #if rot    \n        A = .3*cos(5.*(A.x-.5)*iTime +6.3*A.y +vec2(0,11));\n        P += .1+.8*H -F + A;\n  #else\n        P += H - F;\n  #endif\n        d = min(d, dot(P,P) );\n    }\n\n#else                                 // --- the alternate 4-cells loop\n/* // loopless form\n#define C(i,j) P = vec2(i,j); H = hash(I+P); A = hash(I+P+.5);     \\\n               A = .3*cos(5.*(A.x-.5)*iTime +6.3*A.y +vec2(0,11)); \\\n               P += rot>0 ?.1+.8*H - F + A : H - F;                \\\n               d = min(d, dot(P,P) );\n    C(0,0);\n    S = sign(F-.5);                   // neighbors can win only on the side the pixel is in the cell\n    C(S.x,0); C(0,S.y); C(S.x,S.y); \n*/ \n    S = sign(F-.5);                   // <<\n    for( int k=0; k<4; k++) {         // << only changes compare to 9-cells\n        P = S*vec2(k%2,k/2);          // <<\n        H = hash(I+P);                // random point in cell\n        A = hash(I+P+.5);             // for random rotation\n  #if rot    \n        A = .3*cos(5.*(A.x-.5)*iTime +6.3*A.y +vec2(0,11));\n        P += .1+.8*H -F + A;\n  #else\n        P += H - F;\n  #endif\n        d = min(d, dot(P,P) );\n    }\n\n#endif\n\n    O = vec4( iMouse.z>0. \n                ? sqrt(d)                                  // show Vorono√Ø\n                : smoothstep( 15./R.y,0., sqrt(d)-.3 )  ); // show dots\n    O.rg += .2*mod(I,2.);                                  // show tiling\n // O += .2* ( .6 + .6 * cos( 6.3*hash(I).x  + vec4(0,23,21,0)  ) );\n}","name":"Image","description":"","type":"image"}]}