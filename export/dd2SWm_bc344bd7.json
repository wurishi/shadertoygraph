{"ver":"0.1","info":{"id":"dd2SWm","date":"1670418845","viewed":111,"name":"bessel chladni demo","username":"ulyssesp","description":"Implementation of the bessel functions described by http://paulbourke.net/geometry/chladni/","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["chladni","bessel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// plot first few integer order Bessel functions of the first kind J_n(x) (https://en.wikipedia.org/wiki/Bessel_function)\n// plotter forked from https://www.shadertoy.com/view/4tB3WV\n\n// some constants\n#define PI 3.14159265359\n\n#define BLACK vec3(0.0)\n#define WHITE vec3(1.0)\n\n// dark and light colors from Solarized (https://ethanschoonover.com/solarized/)\n#define DARK vec3(0.0, 0.169, 0.212)\n#define LIGHT vec3(0.992, 0.965, 0.89)\n#define GRAY vec3(0.396, 0.482, 0.514)\n\n// Solarized \"accent colors\"\n#define YELLOW vec3(0.71, 0.537, 0.0)\n#define RED vec3(0.863, 0.196, 0.184)\n#define MAGENTA vec3(0.827, 0.212, 0.512)\n#define VIOLET vec3(0.424, 0.443, 0.769)\n#define BLUE vec3(0.149, 0.545, 0.824)\n#define GREEN vec3(0.522, 0.6, 0.0)\n\n// uncomment to switch to dark mode\n// #define DARK_MODE\n\n// XY range of the display.\n#define DISP_SCALE 16.0\n\n// Line thickness (in pixels).\n#define LINE_SIZE 2.0\n\n// Tick thickness (in pixels).\n#define TICK_SIZE 1.0\n\n// Tick length.\n#define TICK_LENGTH 0.015 * DISP_SCALE\n\n// Grid line & axis thickness (in pixels).\n#define GRID_LINE_SIZE 1.0\n#define GRID_AXIS_SIZE 2.0\n\n// Number of grid lines per unit.\n#define GRID_LINES 0.5\n\n// evaluate integer-order Bessel function of the first kind using the midpoint rule; https://doi.org/10.1002/sapm1955341298\n// see also https://doi.org/10.2307/2695765 and https://doi.org/10.1137/130932132 for more details\nfloat besselJ(int n, float x)\n{\n\tint m = 14;\n    float mm = float(m), nn = float(n);\n    float s = 0.0, h = 0.5 * PI/mm;\n    \n    for (int k = 0; k < m; k++)\n    {\n        float t = h * (float(k) + 0.5);\n        s += (((n & 1) == 1) ? (sin(x * sin(t)) * sin(nn * t)) : (cos(x * cos(t)) * cos(nn * t)))/mm;\n    }\n    \n    return ((n & 1) == 1) ? s : (((((n >> 1) & 1) == 1) ? -1.0 : 1.0) * s);\n}\n\nfloat Bessel(int n, vec2 p)\n{\n\treturn p.y - 0.25 * DISP_SCALE * besselJ(n, p.x); // slight distortion of scale for better display\n}\n\n// derivative; apply same distortion\n#define GRAD_BESS(n, p) vec2(0.125 * DISP_SCALE * (besselJ(n - 1, p.x) - besselJ(n + 1, p.x)), -1.0)\n\n// PLOT_Bessel(Order, Color, Destination, Screen Position)\n#define PLOT_Bessel(n, c, d, p) d = mix(c, d, smoothstep(0.0, (LINE_SIZE / iResolution.y * DISP_SCALE), abs(Bessel(n, p) / length(GRAD_BESS(n, p)))))\n\n#define MAKETICK(c) (clamp(1.0 + 0.5 * TICK_LENGTH - c, 0.0, 1.0) * clamp(c + 1.0 + 0.5 * TICK_LENGTH, 0.0, 1.0))\n\nfloat grid(vec2 p, bool showAxes, bool showTicks, bool showGrid)\n{\n\tvec2 uv = mod(p, 1.0 / GRID_LINES);\n\tfloat halfScale = 0.5 / GRID_LINES;\n    \n    float grid = 1.0, tick = 1.0, axis = 1.0;\n\t\n    if (showTicks) {\n\tfloat tickRad = (TICK_SIZE / iResolution.y) * DISP_SCALE;\n\ttick = halfScale - max( MAKETICK(p.y) * abs(uv.x - halfScale), MAKETICK(p.x) * abs(uv.y - halfScale));\n\ttick = smoothstep(0.0, tickRad, tick);\n    }\n    \n    if (showGrid) {\n\tfloat gridRad = (GRID_LINE_SIZE / iResolution.y) * DISP_SCALE;\n\tgrid = halfScale - max(abs(uv.x - halfScale), abs(uv.y - halfScale));\n\tgrid = smoothstep(0.0, gridRad, grid);\n    }\n\t\n    if (showAxes) {\n\tfloat axisRad = (GRID_AXIS_SIZE / iResolution.y) * DISP_SCALE;\n\taxis = min(abs(p.x), abs(p.y));\n\taxis = smoothstep(axisRad - 0.05, axisRad, axis);\n    }\n\t\n\treturn min(tick, min(grid, axis));\n}\n\nfloat zeros(int n, int k){\n  float[] zs = float[](2.4048,\t3.8317,\t5.1356,\t6.3802,\t7.5883,\t8.7715,\n5.5201,\t7.0156,\t8.4172,\t9.7610,\t11.0647,\t12.3386,\n8.6537,\t10.1735,\t11.6198,\t13.0152,\t14.3725,\t15.7002,\n\t11.7915,\t13.3237,\t14.7960,\t16.2235,\t17.6160,\t18.9801,\n\t14.9309,\t16.4706,\t17.9598,\t19.4094,\t20.8269,\t22.2178);\n\nreturn zs[(k - 1) * 6 + (n)];\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 aspect = iResolution.xy / iResolution.y;\n\t//vec2 uv = ( fragCoord.xy / iResolution.y ) - 0.5 * aspect;\n\t//uv *= DISP_SCALE;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy  ;uv -= 0.5;uv.x *= (iResolution.x /iResolution.y);\n\t\n    vec3 col = WHITE;\n    \n    vec2 RadUv = vec2(0.,0.);    \n\tRadUv.x = PI * atan(uv.x, uv.y); //((atan(uv.x,uv.y) * 0.15915494309189533576888376337251 /*OneOverTau*/) ) +0.5;\n    RadUv.y = length(uv);\n    \n    float C1 = mod(float(iTime), 2.0);\n    float C2 = mod(float(iTime) * 0.5, 2.0);\n    int n =  int(mod(floor(iTime * 0.33), 6.));\n    int m = int(mod(floor(iTime * 0.1666), 5.));\n    float chladni = C1 * cos(float(n) * RadUv.x) + C2 * sin(float(n) * RadUv.x);\n    float R = 32.0;\n    float K = (zeros(n, m) * (RadUv.y * R)) / R;\n    col = vec3(step(abs(besselJ(n, K) * 16. * chladni), .8));\n\t\n\tfragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}