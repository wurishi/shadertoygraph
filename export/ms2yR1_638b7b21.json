{"ver":"0.1","info":{"id":"ms2yR1","date":"1687441913","viewed":35,"name":"raymarching rot","username":"calc","description":"b","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"  const int MAX_MARCHING_STEPS = 255;\n  const float MIN_DIST = 0.0;\n  const float MAX_DIST = 100.0;\n  const float PRECISION = 0.001;\n  const vec3 BACKGROUND_COLOR = vec3(0.0, 0.0, 0.0);\n\n  mat2 rotate(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, s, -s, c);\n  }\n\n    mat3 yaxis_rot(float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n        return mat3(c, 0, s, \n                    0, 1, 0, \n                    -s, 0, c);\n    }\n\n  float sdSphere(vec3 p, float r )\n  {\n    vec3 offset = vec3(0, 0, -2);\n    return length(p - offset) - r;\n  }\n  float sdRoundBox( vec3 p, vec3 b, float r )\n  {\n    // b *= rotateVector(b , vec3(0, 1, 0), iTime);// BOXが伸び縮みする\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n  }\n\n  float map(vec3 p) {\n    // p.xy *= rotate(iTime) ;\n    // p.yz *= rotate(iTime) ;\n      vec3 b = vec3(.3,.8, .2); // radius of sphere\n      float d = sdRoundBox(p, b, .2);\n    return d;\n  }\n\n  vec3 calcNormal(vec3 p) {\n      vec2 e = vec2(1.0, -1.0) * 0.0005; // epsilon\n      vec3 b = vec3(.3,.8, .2); // radius of box\n      return normalize(\n        e.xyy * sdRoundBox(p + e.xyy, b, .2) +\n        e.yyx * sdRoundBox(p + e.yyx, b, .2) +\n        e.yxy * sdRoundBox(p + e.yxy, b, .2) +\n        e.xxx * sdRoundBox(p + e.xxx, b, .2));\n  }\n\n  vec3 ApplyGammaCorrection(vec3 color){\n      float gamma =2.2;\n      return pow(color, vec3(1. / gamma));\n  }\n\n  void mainImage( out vec4 fragColor, in vec2 fragCoord )\n  {\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    vec3 ro = vec3(0, 0, -3); // ray origin that represents **camera position**\n    vec3 camera_dir = normalize(vec3(0 , 0 , 1.0)); // ray direction\n    vec3 camera_up = vec3(0, 1, 0); // ray up vector\n    vec3 camera_side = cross(camera_dir,camera_up ); // ray side vector\n\n    vec3 rd = normalize(camera_dir + uv.x * camera_side + uv.y * camera_up); // ray direction\n\n\n\n\n    // ray marching\n    float d = 0.0;\n    vec3 p = ro; // p is now pos\n    mat3 rot = yaxis_rot(mod(iTime, 360.)); //!\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n      d = map(p* rot); //!\n      p += d * rd;\n    }\n      // light\n    vec3 li_pos = vec3(2, 3, -4);\n    vec3 li_dir = normalize(li_pos - p*rot);\n\n\n\n\n\n    if (d > MAX_DIST) {\n      col = vec3(BACKGROUND_COLOR); // ray didn't hit anything\n    } else {\n      vec3 normal = calcNormal(p*rot); //!\n\n      // Calculate diffuse reflection by taking the dot product of \n      // the normal and the light direction.\n      float dif = dot(normal, li_dir);\n\n      col = ApplyGammaCorrection( vec3(dif) );\n    }\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n  }","name":"Image","description":"","type":"image"}]}