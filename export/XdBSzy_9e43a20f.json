{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// Created by Seung Joon Choi - erucipe/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// This is the shader that i used in my installation for an exhibition\n// In the real exhibition the head part of the animal is substituted by shadow of hands from users\n\nconst float pi = 3.141592653589793;\n\nfloat hash(vec2 p) {\n  return fract(sin(p.x*15.73 + p.y*35.28) * 43758.23);\n}\n\nvec2 hash2(vec2 p) {\n  mat2 m = mat2(15.73, 35.28, 75.43, 153.26);\n  return fract(sin(m * p) * 43758.23);\n}\n\nfloat shash(vec2 p) {\n  return hash(p) * 2.0 - 1.0;\n}\n\nvec2 shash2(vec2 p) {\n  return hash2(p) * 2.0 - 1.0;\n}\n\nfloat noise(vec2 p) {\n  vec2 g = floor(p);\n  vec2 f = fract(p);\n  vec2 k = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n\n  float lb = dot(shash2(g + vec2(0.0, 0.0)), vec2(0.0, 0.0) - f);\n  float rb = dot(shash2(g + vec2(1.0, 0.0)), vec2(1.0, 0.0) - f);\n  float lt = dot(shash2(g + vec2(0.0, 1.0)), vec2(0.0, 1.0) - f);\n  float rt = dot(shash2(g + vec2(1.0, 1.0)), vec2(1.0, 1.0) - f);\n\n  float b = mix(lb, rb, k.x);\n  float t = mix(lt, rt, k.x);\n  return 0.5 + 0.5 * mix(b, t, k.y);\n}\n\nfloat fbm( vec2 p ) {\n  float f = 0.0;\n  mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n  f += 0.50000*noise( p ); p = m*p*2.02;\n  f += 0.25000*noise( p ); p = m*p*2.03;\n  f += 0.12500*noise( p ); p = m*p*2.01;\n  f += 0.06250*noise( p ); p = m*p*2.04;\n  f += 0.03125*noise( p );\n\n  return f/0.984375;\n}\n\nfloat voronoi_tile(vec2 p) {\n    vec2 g = floor(p);\n    vec2 f = fract(p);\n    vec2 k = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n\n    f -= vec2(0.5);\n    g -= vec2(0.5);\n    float res = 1.0;\n    for(int i = -1; i <= 1; i++) {\n        for(int j = -1; j <= 1; j++) {\n            vec2 b = vec2(i, j);\n            float d = length(hash2(g + b) - abs(f) + b);\n            res = min(res, d);\n        }\n    }\n    return res;\n}\n\n// from iq\nfloat smin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// from iq\nfloat sdCapsule( vec2 p, vec2 a, vec2 b, float r ) {\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa, ba) / dot(ba , ba), 0.0, 1.0 );\n    \treturn length( pa - ba * h ) - r;\n}\n\nfloat motor(float _min, float _max, float time) {\n\tfloat t = 0.5 + 0.5 * sin(time);\n\treturn mix(_min, _max, t);\n}\n    \nvoid rotate_from_origin(vec2 origin, out vec2 target, float r, float angle) {\n\ttarget.x = origin.x + r * cos(angle);\n\ttarget.y = origin.y + r * sin(angle);\n}\n\nvec2 preserve(vec2 p0, vec2 p1, float len) {\n\tvec2 v = p1 - p0;\n\tvec2 u = normalize(v);\n\treturn p0 + len * u;\n}\n\nvec4 light(vec2 p) {\n  vec3 light_color = vec3(0.9, 0.5, 0.1);\n  float master_scale = 0.04 + 0.001 * sin(iTime * 20.0);\n  float aspect = iResolution.x / iResolution.y; \n  float c = 0.0;\n  c += master_scale / length(p);\n  vec4 l = smoothstep(0.95, 1.05, c) * vec4(1.0) + vec4(vec3(c) * light_color, 1.0);\n  l.a = c;\n  return l;\n}\n\nvec4 animal(vec2 p) {\n    p.y *= -1.0;\n\tfloat t = iTime * 2.0;\n\tfloat cx = 0.25;\n\tvec2 p0 = vec2(-cx, 0.0);\n\tvec2 p1 = vec2(-cx, -0.2);\n\tvec2 p2 = vec2(-cx, -0.4);\n\tvec2 p3 = vec2(-cx, 0.2);\n\tvec2 p4 = vec2(-cx, -0.4);\n\t\n\tvec2 p5 = vec2(cx, 0.0);\n\tvec2 p6 = vec2(cx, -0.2);\n\tvec2 p7 = vec2(cx, -0.4);\n\tvec2 p8 = vec2(cx, 0.2);\n\tvec2 p9 = vec2(cx, -0.4);\n\t\n\tvec2 p10 = vec2(0.0, 0.0);\n\tvec2 p11 = vec2(cx, -0.2);\n    vec2 p12 = vec2(p0.x - 0.2, -0.1);\n\t\n\tfloat angle0 = 0.0;\n\tfloat angle1 = 0.0;\n\tp0.y = motor(-0.05, 0.05, t * 4.0);\n\tangle0 = motor(pi * 0.15, pi * 0.65, t * 2.0 - pi * 0.5);\n\tangle1 = motor(pi * 0.15, pi * 0.65, t * 2.0 + pi * 0.5);\n\trotate_from_origin(p0, p1, 0.2, angle0); \n\trotate_from_origin(p0, p3, 0.2, angle1); \n\tangle0 += motor(0.0, pi * 0.5, t * 2.0 + pi);\n\tangle1 += motor(0.0, pi * 0.5, t * 2.0 + pi + pi);\n\trotate_from_origin(p1, p2, 0.2, angle0);\n\trotate_from_origin(p3, p4, 0.2, angle1);\n\t\n\tp5.y = motor(-0.05, 0.05, t * 4.0);\n\tangle0 = motor(pi * 0.15, pi * 0.65, t * 2.0 - pi * 0.5);\n\tangle1 = motor(pi * 0.15, pi * 0.65, t * 2.0 + pi * 0.5);\n\trotate_from_origin(p5, p6, 0.2, angle0); \n\trotate_from_origin(p5, p8, 0.2, angle1); \n\tangle0 += motor(0.0, pi * 0.5, t * 2.0 + pi);\n\tangle1 += motor(0.0, pi * 0.5, t * 2.0 + pi + pi);\n\trotate_from_origin(p6, p7, 0.2, angle0);\n\trotate_from_origin(p8, p9, 0.2, angle1);\n\t\n\tp10.y = motor(-0.02, 0.02, t * 4.0 - pi * 0.5);\n\tp11 = preserve(p5, p11, 0.3);\n    p12 = preserve(p0, p12, 0.2);\n\t\n\tvec4 col = vec4(0.0);\n\tfloat d = 0.0;\n\tfloat w = 0.05;\n\td = sdCapsule(p, p0, p1, w);\n\td = min(d, sdCapsule(p, p1, p2, w));\n\td = min(d, sdCapsule(p, p0, p3, w));\n\td = min(d, sdCapsule(p, p3, p4, w));\n\t\n\td = min(d, sdCapsule(p, p5, p6, w));\n\td = min(d, sdCapsule(p, p6, p7, w));\n\td = min(d, sdCapsule(p, p5, p8, w));\n\td = min(d, sdCapsule(p, p8, p9, w));\n\t\n\td = min(d, sdCapsule(p, p0, p10, w));\n\td = min(d, sdCapsule(p, p10, p5, w));\n\td = min(d, sdCapsule(p, p5, p11, w));\n    d = min(d, sdCapsule(p, p0, p12, w * 0.5));\n\t\n\tcol.a = smoothstep(0.01, 0.0, d);\n    t = iTime * 0.1;\n    col.rgb = vec3(0.5 + 0.5 * sin(t), 0.5 + 0.5 * sin(t * 0.3), 0.5 + 0.5 * sin(t * 0.2));\n    vec4 lig = light(p + p11 * -1.0);\n    col += lig;\n    return col;\n}\n\nvec4 c_eye(vec2 p) {\n  vec2 q = p;\n  q.x += 0.5;\n  float dur = 0.5;\n\n  float flick_a = -1.0 + 2.0 * noise( floor(vec2(iTime - dur)) * 0.1 );\n  float flick_b = -1.0 + 2.0 * noise( floor(vec2(iTime)) * 0.1 );\n\n  float t = mod(iTime, dur) / dur;\n  float flick = mix(flick_a, flick_b, t);\n\n  float h = 3.0*(q.x*q.x*q.x)*(1.0-q.x) * (0.5 + 0.5*flick);\n  float e = abs(q.y) - h * 0.55 + 0.03;\n\n  vec2 ep = vec2(0.15 + sin(iTime * 1.0) * 0.15, -0.04 * (0.5 + 0.5 * sin(iTime * 1.5)) );\n\n  float d1 = smoothstep(0.005, 0.0, e);\n  vec3 col = mix(vec3(0.9, 0.8, 0.7), vec3(1.0, 1.0, 0.9), d1);\n  float r2 = length(p - ep) - 0.17; // outer ball\n  float d2 = smoothstep(0.005, 0.0, r2);\n  col = mix(col, vec3(0.0, 0.4 - r2 * 2.0, 0.5), d2 * d1);\n\n\n  float k = 0.5 + 0.5 * atan(p.y - ep.y, p.x - ep.x) / pi;\n  k = 0.5 + 0.5 * sin(k * pi * 18.0 + iTime);\n  float ll = noise(vec2(0.1 / length(p - ep), k) * 4.0 + iTime);\n\n  d2 = d2 * ll;\n  col = mix(col, vec3(0.0, 1.0, 0.7), d2 * d1);\n\n  float flick_eye = noise( floor(vec2(iTime * 100.0)) * 0.1 );\n  d2 = smoothstep(0.005, 0.0, length(p - ep) - (0.05 + 0.01 * flick_eye));\n  col = mix(col, vec3(0.0, 0.0, 0.0), d2 * d1);\n\n  return vec4(col, d1);\n}\n\nfloat c_box(vec2 p, vec2 b) {\n  return length(max(abs(p) - b, 0.0));\n}\n\nvec4 c_mouth(vec2 p, vec2 b) {\n  float eat = length(p - vec2(0.0, -0.5)) * 1.5;\n  eat = pow(eat, 2.5);\n  p.y += 0.05 * abs(fract(p.x * 20.0) - 0.5);\n  float  mcurve = p.x*p.x*3.0;\n  b.y *= cos(mcurve * 2.0 * pi) * 2.0 * (0.5 + 0.5 * sin(iTime * 0.4));\n  float bx = c_box(p, b);\n  bx = smoothstep(0.01, 0.0, bx);\n  vec4 c = vec4(0.0);\n  c = mix(c, vec4(0.7, 0.1 * (1.0 - eat), 0.8 * (1.0 - eat), 1.0), bx);\n  return c;\n}\n\nvec4 c_monster(vec2 p, vec3 body_color) {\n  float dur = 1.0;\n  float flick_a = -1.0 + 2.0 * noise( floor(vec2(iTime - dur)) * 0.1 );\n  float flick_b = -1.0 + 2.0 * noise( floor(vec2(iTime)) * 0.1 );\n  float t = mod(iTime, dur) / dur;\n  float flick = mix(flick_a, flick_b, t*t*(3.0 - 2.0*t));\n  float theta = pi * 0.1 * flick;\n  \n  mat2 m = mat2(cos(theta), -sin(theta), sin(theta), cos(theta));\n  p = m * p;\n  float a = length(p + vec2(0.0, 0.0)) - (0.42 + 0.02 * sin(iTime * 0.2));\n  float b = length(p - vec2(0.0, 0.6)) - (0.3 + 0.04 * cos(iTime * 0.2));\n  float body = smin(a, b, 0.3);\n  body = smoothstep(0.01, 0.0, body);\n  vec4 eye = c_eye((p - vec2(-0.1, 0.65)) * 1.35);\n  vec4 mth = c_mouth(p - vec2(0.0, 0.34), vec2(0.27, 0.06));\n\n  vec4 c = vec4(0.0);\n  c = mix(c, vec4(body_color, 1.0), body);\n  c = mix(c, eye, eye.a);\n  c = mix(c, mth, mth.a);\n  return c;\n}\n\nfloat cloud(vec2 p) { \n  float col = -0.2 + fbm(p * 5.0 + vec2(iTime * 0.5, 0.0)) * 1.5;\n  col = smoothstep(0.8, 0.0, col);\n  col *= smoothstep(0.5, 1.0, 0.3 + 0.7 * (p.y - 0.25));\n  \n  return col;\n}\n\nvec4 overlay(vec2 p) {\n   vec2 q = p;\n  vec2 o = vec2(0.0 + sin(iTime * 0.1) * 3.0, 1.75);\n  p = p - o;\n  float k = length(p) - 0.5;\n  float a = 0.5 + 0.5 * atan(p.y, p.x) / pi;\n  float d = (0.5 + 0.5 * sin(a * pi * 30.0 - iTime * 3.0 + k * 5.0));\n  vec4 col = vec4(1.0);\n  k = 0.8 - k;\n  float cld = cloud(q);\n  col.rgb = clamp(vec3(d * k), 0.0, 1.0) + cld;\n  col.a = d * k;\n  return vec4(col);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) { \n  vec2 p = fragCoord.xy / iResolution.xy;\n  p = 2.0 * p - 1.0;\n  p.x *= iResolution.x / iResolution.y;\n  \n  float dur = 0.5;\n  float t = mod(iTime, dur) / dur;\n  \n  float c = 0.0;\n  \n  float y = smoothstep(0.5, 1.0, 0.3 + 0.7 * (p.y));\n  c = voronoi_tile(p * 5.0 + vec2(iTime, 0.0));\n  float body_pattern = voronoi_tile(p * 5.0 + vec2(iTime * 0.25, 0.0)) * 0.5;\n  vec4 col = vec4(0.0);\n  if(p.y < 0.0) {\n    vec3 ground_a = vec3(0.282, 0.651, 0.647);\n    vec3 ground_b = vec3(0.231, 0.231, 0.486);\n    vec3 ground = vec3(0.5, 0.2, 0.8) * c * 0.6;\n    col.rgb = ground;\n  }\n  else {\n    float flick_a = -1.0 + 2.0 * noise( floor(vec2(iTime - dur)) * 0.1 );\n    float flick_b = -1.0 + 2.0 * noise( floor(vec2(iTime)) * 0.1 );\n    float flick = mix(flick_a, flick_b, t*t*(3.0 - 2.0*t));\n  \n    vec4 mon = c_monster(p * 0.8 - vec2(flick, -0.1), vec3(0.5, 0.2, 0.8) * body_pattern);\n    vec3 sky_u = vec3(0.282, 0.651, 0.647);\n    vec3 sky_d = vec3(0.231, 0.231, 0.486);\n    float k = p.y - 0.5;\n    vec3 sky = mix(sky_d, sky_u, k*k*(3.0 - 2.0*k));\n    col.rgb = mix(sky, mon.rgb, mon.a);\n    \n    float at = mod(iTime, 6.0) / 6.0;\n    vec2 ap = p * 2.0 - vec2((at*2.0 - 1.0)*5.0, 0.43); \n    vec4 anima = animal(ap);\n    \n    vec4 ovl = overlay(p);\n    col = col + ovl;\n    col = mix(col, anima, anima.a);\n  }\n  fragColor = vec4(col.rgb, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XdBSzy","date":"1413035762","viewed":410,"name":"A monster and an animal","username":"erucipe","description":"This is the shader that i used in my installation for an exhibition.\nIn the real exhibition the head part of the animal is substituted by shadow of hands from users.\nI have some problem with clouds for now. it's getting jaggy as time goes.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["2d","monster","fairytail","chracter"],"hasliked":0,"parentid":"","parentname":""}}