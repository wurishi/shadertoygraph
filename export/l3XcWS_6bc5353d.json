{"ver":"0.1","info":{"id":"l3XcWS","date":"1727551601","viewed":67,"name":"Snowy World","username":"fishe","description":"inspired by https://digitoxin.github.io/snowworld/\nshader theme: https://www.youtube.com/watch?v=4lyI7O7kLP0","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["snow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float pi = atan(1.0, 1.0) * 4.0;\nconst float epsilon = 0.001;\nconst float far = 7.0;\n\n// https://iquilezles.org/articles/distfunctions/\n\nfloat solidangle(vec3 p, float a, float r){\n    vec2 c = vec2(sin(a), cos(a));\n    vec2 q = vec2(length(p.xz), p.y);\n    float l = length(q) - r;\n    float m = length(q - c*clamp(dot(q,c),0.0,r));\n    return max(l,m*sign(c.y*q.x-c.x*q.y));\n}\n\n// https://www.shadertoy.com/view/4djSRW\n\nvec3 hash33(vec3 p3){\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nfloat hash13(vec3 p3){\n\tp3 = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// https://www.shadertoy.com/view/4sfGzS\n\nfloat noise(vec3 x){\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    x = floor(x);\n    return mix(mix(mix(hash13(x+vec3(0,0,0)), \n                       hash13(x+vec3(1,0,0)),f.x),\n                   mix(hash13(x+vec3(0,1,0)), \n                       hash13(x+vec3(1,1,0)),f.x),f.y),\n               mix(mix(hash13(x+vec3(0,0,1)), \n                       hash13(x+vec3(1,0,1)),f.x),\n                   mix(hash13(x+vec3(0,1,1)), \n                       hash13(x+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat octave(vec3 p){\n    float n = 0.0;\n    n += noise(p * 2.0) * 2.0;\n    n += noise(p * 4.0) * 1.0;\n    n += noise(p * 8.0) * 0.5;\n    return n / 3.5;\n}\n\nfloat tree(vec3 p){\n    p.y *= -1.0;\n    float t = solidangle(p + vec3(0.0, 0.38, 0.0), 0.2, 0.4);\n    float theta = atan(p.x, p.z);\n    p.y += sin(theta * 20.0) * min(1.0, length(p.xz)) * 0.05;\n    t = min(t, solidangle(p + vec3(0.0, 0.5, 0.0), 0.74, 0.4));\n    t = min(t, solidangle(p + vec3(0.0, 0.62, 0.0), 0.68, 0.38));\n    t = min(t, solidangle(p + vec3(0.0, 0.72, 0.0), 0.63, 0.34));\n    t = min(t, solidangle(p + vec3(0.0, 0.80, 0.0), 0.61, 0.28));\n    return t;\n}\n\nfloat snow(vec3 p, vec3 d, float s, float r){\n    vec3 q = p / s;\n    vec3 f = fract(q);\n    vec3 tmax = vec3(\n        d.x < 0.0 ? f.x : 1.0 - f.x,\n        d.y < 0.0 ? f.y : 1.0 - f.y,\n        d.z < 0.0 ? f.z : 1.0 - f.z\n    ) / abs(d);\n    float t = min(tmax.x, min(tmax.y, tmax.z)) + 0.02;\n    vec3 n = hash33(floor(q));\n    n = r + (1.0 - r - r) * n;\n    float k = (length(f - n) - r);\n    return min(t, k) * s;\n}\n\nfloat forest(vec3 p, vec3 d, float s, float h){\n    vec2 q = p.xz / s;\n    vec2 f = fract(q);\n    vec2 tmax = vec2(\n        d.x < 0.0 ? f.x : 1.0 - f.x,\n        d.z < 0.0 ? f.y : 1.0 - f.y\n    ) / abs(d.xz);\n    float o = 0.2;\n    vec3 n = hash33(floor(vec3(q, h)));\n    n = o + (1.0 - o - o) * n;\n    float t = min(tmax.x, tmax.y) + 0.02;\n    float k = tree(vec3(f.x - n.x, p.y/s, f.y - n.y) * s) / s;\n    return min(t, k) * s;\n}\n\nvec2 map(vec3 p, vec3 d){\n    vec2 r = vec2(far);\n    if(p.y < 0.0) return r;\n    float t;\n    t = snow(p + vec3(0.0, 0.0 + iTime * 0.5, 0.0), d, 0.4, 0.03);\n    t = min(t, snow(p + vec3(0.3, 0.3 + iTime * 0.25, 0.3), d, 0.7, 0.015));\n    if(t < r.x) r = vec2(t, 0.0);\n    t = forest(p, d, 2.0, 0.0);\n    t = min(t, forest(p, d, 4.0, 1.0));\n    if(t < r.x) r = vec2(t, 1.0);\n    return r;\n}\n\nvec2 march(vec3 p, vec3 d){\n    float t = 0.0;\n    for(int i = 0; i < 150; i++){\n        if(t > far) break;\n        vec2 k = map(p + d * t, d);\n        if(k.x < epsilon) return vec2(t, k.y);\n        t += k.x;\n    }\n    return vec2(far);\n}\n\nvec3 gen(vec2 p, float fov, vec3 from, vec3 to){\n    p = p / iResolution.xy * 2.0 - 1.0;\n    p.x *= iResolution.x/iResolution.y;\n    vec3 n = normalize(vec3(p, -1.0 / tan(fov / 2.0))); \n    vec3 z = normalize(from - to);\n    vec3 x = normalize(cross(vec3(0.0, 1.0, 0.0), z));\n    vec3 y = cross(z, x);\n    return x * n.x + y * n.y + z * n.z;\n}\n\nvec3 nor(vec3 p, vec3 d){\n    float e = 0.001;\n    return normalize(\n        map(p, d).x - vec3(map(p - vec3(e, 0.0, 0.0), d).x,\n                           map(p - vec3(0.0, e, 0.0), d).x,\n                           map(p - vec3(0.0, 0.0, e), d).x)\n    );\n}\n\nvec3 C1 = vec3(0.28, 0.3, 0.35);\nvec3 C2 = vec3(0.85, 0.85, 1.0);\nvec3 C3 = vec3(0.7, 0.6, 0.75);\nvec3 C4 = vec3(1.0, 0.5, 0.5);\nvec3 C5 = vec3(0.8, 0.8, 0.95);\nvec3 C6 = vec3(0.95, 0.94, 1.0);\n\nvoid mainImage(out vec4 c, in vec2 p){\n\n    float theta = iMouse.z > 0.0 ? -iMouse.x/iResolution.x * 2.0 * pi + pi : sin(iTime/8.0);\n    vec3 origin  = vec3(0.0, sin(iTime * 6.0) * 0.03 + 0.35, iTime * 0.5);\n    vec3 direction = gen(p, 1.4, vec3(0.0), vec3(sin(theta), 0.0, cos(theta)));\n\n    vec2 k = march(origin, direction);\n\n    float j = dot(origin / direction, vec3(0.0, -1.0, 0.0));\n    if(j < k.x && j > 0.0) k = vec2(j, 0.0);\n\n    vec3 bg = mix(C4, C5, max(0.0, direction.y) + 0.2);\n\n    if(k.x < far){\n\n        vec3 p = origin + direction * k.x;\n        vec3 C = k.y < 1.0 ? C6\n               : mix(C2, C3, octave(p * vec3(13.0, 0.0, 13.0)))\n                 * (max(0.0, dot(nor(origin + direction * k.x, direction), vec3(0.0, 1.0, 0.0))) * 0.2 + 0.8);\n        C = mix(mix(C6, C1, octave(vec3(p.xz * 4.0, 0.0)) * 0.2), C, clamp(0.0, 1.0, p.y * 16.0));\n        C = mix(C, bg, clamp(pow(k.x / far, 0.7), 0.0, 1.0));\n        c = vec4(C, 1.0);\n\n    }else c = vec4(bg, 1.0);\n\n}","name":"Image","description":"","type":"image"}]}