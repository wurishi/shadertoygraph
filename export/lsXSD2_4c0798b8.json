{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"struct Ray{\n\tvec3 origin;\n\tvec3 direction;\n};\n    \nstruct Material{\n\tfloat specular;\n\tfloat diffuse;\n\tfloat ambient;\n\tfloat shininess;\n    float reflectivity;\n    float transparency;\n};\n    \nstruct Sphere{\n\tvec3 position;\n\tvec3 colour;\n\tfloat radius;\n};\n\t\nstruct PointLight{\n\tvec3 position;\n\tvec3 colour;\n};\n\n\nstruct Output{\n\tvec3 origin;\n\tvec3 normal;\n\tfloat dis;\n\tMaterial material;\n    vec3 colour;\n};\n    \n#define minT 1.0\n#define delT 0.01\n#define maxT 10.0\n    \n#define numSphere 3\nSphere sphere[numSphere];\n\n#define numLight 6\nPointLight pointlight[numLight];\n\n#define numMaterial 8\nMaterial material[numMaterial];\n\n#define PI 3.14159\nvec3 backgroundColour = vec3(0.0, 0.0, 0.7);\nvec3 eye;\n\nRay castRay(vec3 lookat){\n\tvec2 uv = (gl_FragCoord.xy * 2.1 - iResolution.xy) / iResolution.xx;\n\n\tvec3 forward = normalize(lookat - eye);\n\tvec3 up = vec3(0.0, 1.0, 0.0);\n\t\n\tvec3 right = cross(up, forward);\n\tup = cross(forward, right);\n\t\n\tRay ray;\n\t\n\tray.origin = eye;\n\tray.direction = normalize(right * uv.x + up * uv.y + forward);\n\t\n\teye = ray.origin;\n\t\n\treturn ray;\n}\n\nfloat getTerrain(vec2 point){\n    return cos(point.y) * 0.5 + sin(point.x) * 0.5 - 1.5;\n}\n\nvec3 getNormal(vec3 point){\n    float eps = 0.01;\n\tvec3 n = vec3( getTerrain(vec2(point.x-eps,point.z)) - getTerrain(vec2(point.x+eps,point.z)),\n                         2.0 * eps,\n                         getTerrain(vec2(point.x,point.z-eps)) - getTerrain(vec2(point.x,point.z+eps)) );\n    return normalize( n );\n}\n\nvoid rayMarch(Ray ray, Material mat, inout Output o){\n    \n    for (float t = minT; t < maxT; t+= delT){\n    \tvec3 p = ray.origin + ray.direction * t;\n        if (p.y <= getTerrain(p.xz)){\n            if (t < o.dis){\n            \to.material = mat;\n                o.normal = getNormal(p);\n                o.dis = t;\n                o.colour = vec3(1.0);\n                o.origin = p;\n            }\n            break;\n        }\n    }\n}\n\n\nvoid sphereIntersect(const Sphere sphere, const Ray ray, in Material mat, inout Output o) {\n\tvec3 d = ray.origin - sphere.position;\n\t\n\tfloat a = dot(ray.direction, ray.direction);\n\tfloat b = dot(ray.direction, d);\n\tfloat c = dot(d, d) - sphere.radius * sphere.radius;\n\t\n\tfloat g = b*b - a*c;\n\t\n\tif(g > 0.0) {\n\t\tfloat dis = (-sqrt(g) - b) / a;\n\t\tif(dis > 0.0 && dis < o.dis) {\n\t\t\to.dis = dis;\n\t\t\to.origin = ray.origin + ray.direction * dis;\n\t\t\to.normal = (o.origin - sphere.position) / sphere.radius;\n            o.colour = sphere.colour;\n\t\t\to.material = mat;\n\t\t}\n\t}\n}\n\nSphere makeSphere(float offset, float radius){\n    float t = iTime + offset;\n    float x = cos(t);\n    float z = sin(t * 2.0) * 3.5;\n    float y = getTerrain(vec2(x,z)) + radius;//sin(t * 1.5);\n\t\n\treturn Sphere(vec3(x, y, z),\n\t\t\t\t  vec3(sin(offset) + 1.0 / 2.0, cos(offset) + 1.0 / 2.0, 0.2),\n\t\t\t\t  radius);\n}\n\nvoid makeScene(){\n\t\n    material[0] = Material(0.1, 0.6, 0.1, 0.0, 0.2, 0.0);\n    material[1] = Material(0.0, 0.8, 0.0, 0.0, 0.1, 0.0);\n    material[2] = Material(0.2, 0.6, 0.5, 0.0, 0.7, 0.0);\n    material[3] = Material(0.1, 0.6, 0.1, 1.0, 0.3, 0.0);\n    material[4] = Material(0.1, 0.6, 0.7, 0.0, 0.2, 0.0);\n    material[5] = Material(0.0, 0.8, 0.0, 0.0, 0.1, 0.0);\n    material[6] = Material(0.2, 0.6, 0.5, 0.0, 0.7, 0.0);\n    material[7] = Material(0.1, 0.6, 0.1, 1.0, 0.3, 0.0);\n    \n\tfor (int i = 0; i < numSphere; i++){\n\t\tsphere[i] = makeSphere(float(i), float(i) / 3.0 + 0.5);\n\t}\n    \n    float r = 6.0;\n\tfloat y = 0.0;\n\t\n\tfloat t0 = -iTime + PI * 0.0;\n\tpointlight[0].position = vec3(cos(t0) * r, y, sin(t0) * r);\n\tpointlight[0].colour = vec3(0.0, 0.0, 0.5);\n\tfloat t1 = -iTime + PI * 0.333333;\n\tpointlight[1].position = vec3(cos(t1) * r, y, sin(t1) * r);\n\tpointlight[1].colour = vec3(0.4, 0.0, 0.4);\n\n\tfloat t2 = -iTime + PI * 0.666666;\n\tpointlight[2].position = vec3(cos(t2) * r, y, sin(t2) * r);\n\tpointlight[2].colour = vec3(0.3, 0.3, 0.3);\n\n\tfloat t3 = -iTime + PI * 1.0;\n\tpointlight[3].position = vec3(cos(t3) * r, y, sin(t3) * r);\n\tpointlight[3].colour = vec3(0.0, 0.4, 0.4);\n\n\tfloat t4 = -iTime + PI * 1.333333;\n\tpointlight[4].position = vec3(cos(t4) * r, y, sin(t4) * r);\n\tpointlight[4].colour = vec3(0.5, 0.0, 0.0);\n\n\tfloat t5 = -iTime + PI * 1.666666;\n\tpointlight[5].position = vec3(cos(t5) * r, y, sin(t5) * r);\n\tpointlight[5].colour = vec3(0.4, 0.4, 0.0);\n    \n\t//pointlight[0] = PointLight(vec3(-4.0, 4.0, -8.0), vec3(0.5, 0.5, 0.5));\n\t//pointlight[1] = PointLight(vec3(4.0, -4.0, 5.0), vec3(0.5, 0.5, 0.5));\n    //pointlight[2] = PointLight(vec3(2.0, 5.0, 0.0), vec3(1.0, 0.0, 1.0));\n\n}\n\nvec3 illuminatePointLight(PointLight light, Output o){\n    vec3 brightness = vec3(0.0);\n    \n\tvec3 pointToLight = o.origin - light.position;\n    for (int j = 0; j < 3; j++){\n\t\tbrightness[j] += light.colour[j] * o.material.diffuse * dot(normalize(pointToLight), normalize(o.normal));\n\t\tbrightness[j] += light.colour[j] * o.material.specular * dot(normalize(2.0 * dot(normalize(pointToLight), normalize(o.normal))\n\t\t\t\t\t\t\t\t\t\t\t\t * normalize(o.normal) - normalize(pointToLight)),\n\t\t\t\t\t\t\t\t\t   eye - o.origin);\n    }\n    return brightness;\n}\n\nvec3 shade(Output o){\n    vec3 brightness = vec3(o.material.ambient);\n\t\n\tfor (int i = 0; i < numLight; i++){\n\t\tbrightness += illuminatePointLight(pointlight[i], o);\n\t}\n\tbrightness[0] = clamp(brightness[0], 0.0, 1.0);\n    brightness[1] = clamp(brightness[1], 0.0, 1.0);\n    brightness[2] = clamp(brightness[2], 0.0, 1.0);\n\t\n    float dis = length(eye - o.origin);\n\t\n\tdis -= 10.0;\n\tdis *= 0.07;\n\tdis = clamp(dis, 0.0, 1.0);\n    brightness *= o.colour;\n\treturn brightness * (1.0 - dis);\n}\n\nOutput traceStep(in Ray ray){\n    Output o  = Output(vec3(0.0), \n                       vec3(0.0, 0.0, 0.1), \n                       1.0e4,\n                       Material(\n\t\t\t\t\t\t0.0,\n\t\t\t\t\t\t0.0,\n\t\t\t\t\t \t0.0,\n\t\t\t\t\t\t0.0,\n\t\t\t\t\t\t0.0,\n                        0.0),\n                       vec3(0.0));\n                      \n\tvec3 colour = vec3(0.0);\n\tfor (int i = 0; i < numSphere; i++){\n\t\tsphereIntersect(sphere[i], ray, material[3], o);\n    }\n    \n    rayMarch(ray, material[2], o);\n    \n    return o;\n}\n\nvec3 getSky(in Ray ray){\n    vec3 colour = vec3(0.0);\n    //if (ray.direction.y >= 0.01){\n\t\tcolour += vec3(0.529, 0.807, 0.980);\n        colour += vec3(1.0)/10.0 * ray.direction.x * ray.direction.z/ray.direction.y;\n    //}\n    return colour;\n}\n\nvec3 trace(in Ray ray){\n\tvec3 colour = vec3(0.0);\n    float reflectivity = 1.0;\n    Output o;\n    \n    for (int i = 0; i < 4; i++){\n    \to = traceStep(ray);\n        \n        if (o.dis > 1.0e3) break;\n        \n        colour += shade(o) * reflectivity;\n        \n        reflectivity *= o.material.reflectivity;\n        \n        float l = length(ray.origin - o.origin) + 0.0001;\n\t\tcolour -= 0.02 / l;\n\n\t\treflectivity *= o.material.reflectivity;\n        \n\t\tif(reflectivity < 0.05) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tray = Ray(o.origin + o.normal * 0.0001, reflect(normalize(o.origin - ray.origin), o.normal));\n    }\n    \n    if(o == Output(vec3(0.0), \n \t           vec3(0.0, 0.0, 0.1), \n               1.0e4,\n               Material(\n               0.0,\n               0.0,\n               0.0,\n               0.0,\n               0.0,\n               0.0),\n               vec3(0.0))) {\n        colour += getSky(ray);\n    }\n    \n    \n    return colour;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tmakeScene();\n\t//eye = vec3(5.0, 4.0, -2.0);\n    eye = vec3(sin(iTime) * 4.0, cos(iTime) + 2.0, -4.0 + cos(iTime) * 2.0);\n    Ray ray = castRay(vec3(0.0));\n\t\n\tvec3 color = trace(ray);\n\tfragColor = vec4(color, 1.0);\n\t\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lsXSD2","date":"1406988331","viewed":206,"name":"Simple Trig Ray Marcher","username":"twitchingace","description":"Simple rayMarcher displaying Trig terrain","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarch"],"hasliked":0,"parentid":"","parentname":""}}