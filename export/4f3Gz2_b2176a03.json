{"ver":"0.1","info":{"id":"4f3Gz2","date":"1712747515","viewed":109,"name":"Part de calendos","username":"necroborg","description":"-","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["marching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define t iTime\nconst float TAU = 6.2831853071;\n\nconst float CYLINDER_HEIGHT = 0.15;\nconst float CYLINDER_RADIUS_INTERNAL = 0.4;\nconst float CYLINDER_RADIUS_EXTERNAL = 1.2;\nconst float LINE_THICKNESS = 0.015;\n\nconst float MARCHING_HIT = 0.001;\n\n// Camera roll yaw and pitch\nfloat ROLL;\nfloat YAW;\nfloat PITCH;\nmat3 camera;\nmat3 inverseCamera;\n\nconst int MAX_SUBCATS = 6;\nvec3 colors[MAX_SUBCATS];\nfloat percentiles[] = float[MAX_SUBCATS](0.35, 0.6, 0.8, 0.9, 0.95, 1.);\nfloat selectedShift[] = float[MAX_SUBCATS](0.0, 0.0, 0.0, CYLINDER_RADIUS_EXTERNAL / 4., 0., 0.);\n\nmat2 rot(float a) { return mat2(cos(a), sin(a), -sin(a), cos(a)); }\n\n// Function from Iñigo Quiles\n// www.iquilezles.org/www/articles/functions/functions.htm\nfloat parabola(float x, float k) {\n  return pow(4.0 * x * (1.0 - x), k);\n}\n\nvec2 polarToCartesian(float r, float a) {\n  return r * vec2(cos(TAU * a), sin(TAU * a));\n}\n\n// Distance from P to segment AB.\nfloat distPointToSegment(vec2 p, vec2 a, vec2 b) {\n  vec2 ap = p - a;\n  vec2 ab = b - a;\n  float dotP = dot(ap, ab) / length(ab) / length(ab); // Dot product is the length of AB multiplied by the length of the projection of AP on AB. The needed value is the length(projection)/length(AB), so need to divide twice by length(ab)\n\n  if (dotP > 1.) return distance(b, p); // B is the closest point\n  if (dotP < 0.) return distance(a, p); // A is the closest point\n  return distance(a + ab * dotP, p); // Projection of P over AB is the closest point and that is a + dotP * ab (since dotP is the proportion of AB on which the orthogonal line hits)\n}\n\n// Distance from P to arc\nfloat distPointToArc(vec2 p, vec2 center, float r, float angleMin, float angleMax) {\n  vec2 q = p - center; // Translate q in a referential centered on |center|\n  float angle = atan(q.y, q.x) / TAU; // Angle in polar for q\n  float angleCenter = (angleMax + angleMin) / 2.; // Center angle of the arc\n  // Rotate angle to bring 0 to the center of the arc and normalize it between -TAU/2 and TAU/2. % operator only works on integers.\n  angle -= angleCenter;\n  while (angle > 0.5) angle -= 1.;\n  while (angle < -0.5) angle += 1.;\n  // If angle is between angleMin and angleMax, then the point is inside the disc arc. Under angleMin and it's outside, closest to angleMin ; over angleMax and it's outside, closest to angleMax.\n  if (angle < angleMin - angleCenter) return distance(p, (polarToCartesian(r, angleMin) + center)); // P is closest to the angleMin end (angleMin end is its cartesian coordinates in the shifted referential, minus the center to go back to the unshifted referential)\n  if (angle > angleMax - angleCenter) return distance(p, (polarToCartesian(r, angleMax) + center)); // P is closest to the angleMax end\n  return abs(length(q) - r); // P is closest to some point on the arc that's on a straight line from |center| to |p|, distance is radius - radius(q) in polar\n}\n\nbool insidePart(vec2 p, float rMin, float rMax, float angleMin, float angleMax) {\n  float r = length(p); \n  float angle = atan(p.y, p.x) / TAU;\n  angle = mod(angle, 1.);\n  return r >= rMin && r <= rMax && angle >= angleMin && angle <= angleMax;\n}\n\n// returns the distance from point p to a camembert part delimited by min and max radius and min and max angle shifted by outwardShift in [0][0]\n// returns the smallest distance from point p to any of the 4 corners of the part in [0][1]\n// also returns the norm of the surface at the closest point in [1]\n// outwardShift is a scalar in the same dimension as |rMin| and |rMax| describing how far outward the part is shifted\nmat3 distToPart(vec2 p, float rMin, float rMax, float angleMin, float angleMax, float outwardShift) {\n  // vector of the shift in cartesian. Shifted out by a radius of outwardShift along the bisector of the angle\n  vec2 shift = polarToCartesian(outwardShift, (angleMin + angleMax) / 2.);\n\n  float distToInternalArc = distPointToArc(p, shift /* center */, rMin, angleMin, angleMax);\n  float distToExternalArc = distPointToArc(p, shift /* center */, rMax, angleMin, angleMax);\n\n  vec2 internalStart = polarToCartesian(rMin, angleMin) + shift;\n  vec2 internalEnd = polarToCartesian(rMin, angleMax) + shift;\n  vec2 externalStart = polarToCartesian(rMax, angleMin) + shift;\n  vec2 externalEnd = polarToCartesian(rMax, angleMax) + shift;\n  float distToInternalSegment = distPointToSegment(p, internalStart, externalStart);\n  float distToExternalSegment = distPointToSegment(p, internalEnd, externalEnd);\n\n  bool inside = insidePart(p - shift, rMin, rMax, angleMin, angleMax);\n\n  // Distance to any edge of the part\n  float dist = distToInternalSegment;\n  vec3 norm = vec3(externalStart.y - internalStart.y, externalStart.x - internalStart.x, 0.);\n  if (dist > distToExternalSegment) {\n    dist = distToExternalSegment;\n    norm = vec3(externalEnd.y - internalEnd.y, externalEnd.x - internalEnd.x, 0.);\n  }\n  if (dist >= distToInternalArc) {\n    dist = distToInternalArc;\n    norm = vec3(-p.y, -p.x, 0.);\n  }\n  if (dist >= distToExternalArc) {\n    dist = distToExternalArc;\n    norm = vec3(p.y, p.x, 0.);\n  }\n\n  // Distance to any of the 4 corners\n  float distToCorner = min(min(distance(p, internalStart), distance(p, internalEnd)), min(distance(p, externalStart), distance(p, externalEnd)));\n\n  if (inside) {\n    dist = -dist;\n    distToCorner = -distToCorner;\n  }\n  return mat3(dist, distToCorner, 0.,\n              norm,\n              0., 0., 0.);\n}\n\n// Return\n// [ distance, 0, 0,\n//   norm.x, norm.y, norm.z\n//   color.r, color.g, color.b ]\nmat3 scene(vec3 p) {\n//  p.yz *= rot(PITCH);\n//  p.xy *= rot(ROLL);\n//  p.yz *= rot(YAW);\np *= inverseCamera;\n\n  float zdist = abs(p.z) - CYLINDER_HEIGHT / 2.;\n  if (zdist > MARCHING_HIT) return mat3(zdist, 0., 0,\n                                        0., 1., 0.,\n                                        0., 0., 0.);\n\n\n  float startAngle = 0.;\n  float endAngle = 0.;\n  float xydist = 1000000000.;\n  float distToCorner = 1000000000.;\n  vec3 xynorm = vec3(1., 1., 0.);\n  vec3 color = vec3(0.);\n  for (int i = 0; i < MAX_SUBCATS; ++i) {\n    endAngle = percentiles[i];\n    float shift = selectedShift[i];\n    mat3 partSpec = distToPart(p.xy, CYLINDER_RADIUS_INTERNAL, CYLINDER_RADIUS_EXTERNAL, startAngle, endAngle, shift);\n    float d = partSpec[0][0];\n    if (d < xydist) {\n      xydist = d;\n      xynorm = partSpec[1];\n      color = colors[i];\n    }\n    d = partSpec[0][1];\n    if (d < distToCorner) {\n      distToCorner = d;\n    }\n    startAngle = endAngle;\n    if (startAngle >= 1.) break;\n  }\n\n  // Norm on the top and bottom surfaces\n  if (abs(zdist) < MARCHING_HIT && xydist <= 0.) xynorm = vec3(0., 0., 1.);\n\n  float distToClosestBorder = distToCorner;\n  if (abs(zdist) < 0.001) distToClosestBorder = abs(xydist);\n  if (abs(xydist) < 0.001) distToClosestBorder = min(distToClosestBorder, abs(zdist));\n\n  float prop = max(parabola(0.5 + distToClosestBorder / LINE_THICKNESS, 1.), 0.);\n  color = mix(color, vec3(1.), prop);\n\n  return mat3(xydist, prop, 0.,\n              xynorm,\n              color);\n}\n\nvoid init() {\n  if (iMouse.x == 0. && iMouse.y == 0.) {\n    ROLL = iResolution.x / 2.;\n    YAW = 0.;\n    PITCH = TAU / 6.;\n  } else {\n    ROLL = ((iMouse.x / iResolution.y) * 4.5);\n    YAW = 0.;\n    PITCH = ((iMouse.y / iResolution.y) * 1.5);\n  }\n  float x = PITCH;\n  float y = ROLL;\n  float z = YAW;\n  camera = mat3(1., 0., 0.,\n                 0., cos(x), -sin(x),\n                 0., sin(x), cos(x));\n  camera *= mat3(cos(y), 0., sin(y),\n                0., 1., 0.,\n                -sin(y), 0., cos(y));\n  camera *= mat3(cos(z), -sin(z), 0.,\n                sin(z), cos(z), 0.,\n                0., 0., 1.);\n  inverseCamera = inverse(camera);\n  colors[0] = vec3(0.8, 0.7, 0.3);\n  colors[1] = vec3(0.1, 0.6, 0.7);\n  colors[2] = vec3(0.4, 0.8, 0.1);\n  colors[3] = vec3(0.0, 0.2, 0.9);\n  colors[4] = vec3(0.9, 0.4, 0.2);\n  colors[5] = vec3(0.4, 0.2, 0.7);\n  selectedShift[2] = max(0., sin(t * 2. + TAU/4.) * CYLINDER_RADIUS_EXTERNAL / 4.);\n  selectedShift[3] = max(0., sin(t) * CYLINDER_RADIUS_EXTERNAL / 4.);\n}\n\nvec4 colorForScreenCoord(vec2 uv) {\n  vec3 ro = vec3(0., 0., -5);\n  vec3 rd = normalize(vec3(uv, 1.));\n  vec3 lPos = vec3(2.5 * sin(t * 1.3), 2. * cos(t * 1.5), 0.2);\n  vec3 lColor = vec3(0.5, 0.5, 0.5);\n  vec3 p = ro;\n  int i = 0;\n  for (i = 0; i < 100; i++) {\n    mat3 dc = scene(p);\n    float d = dc[0][0];\n    if (d < MARCHING_HIT) {\n      vec3 norm = dc[1];\n            \n      p.yz *= rot(PITCH);\n      p.xy *= rot(ROLL);\n      vec3 lDir = normalize(p - lPos);\n      vec3 h = -normalize(rd + lDir);\n      float blinnPhong = dot(h, norm);\n\n      float specular = pow(clamp(blinnPhong, 0., 1.), 5.);\n      float diffuse = dot(norm, -lDir);\n\n      return vec4(dc[2] + vec3(diffuse) * lColor + vec3(specular) * lColor, 1.);\n    }\n    if (p.z > 2.) break;\n    p += d * rd;\n  }\n  return vec4(0., 0., 0., 1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  init();\n  vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.x;\n  fragColor = colorForScreenCoord(uv);\n// Supersampling\n/*\n  float fracPixel = (1./3.) / iResolution.x;\n\n  vec4 sample1 = colorForScreenCoord(vec2(uv.x - fracPixel, uv.y - fracPixel));\n  vec4 sample2 = colorForScreenCoord(vec2(uv.x            , uv.y - fracPixel));\n  vec4 sample3 = colorForScreenCoord(vec2(uv.x + fracPixel, uv.y - fracPixel));\n  vec4 sample4 = colorForScreenCoord(vec2(uv.x - fracPixel, uv.y            ));\n  vec4 sample5 = colorForScreenCoord(vec2(uv.x            , uv.y            ));\n  vec4 sample6 = colorForScreenCoord(vec2(uv.x + fracPixel, uv.y            ));\n  vec4 sample7 = colorForScreenCoord(vec2(uv.x - fracPixel, uv.y + fracPixel));\n  vec4 sample8 = colorForScreenCoord(vec2(uv.x            , uv.y + fracPixel));\n  vec4 sample9 = colorForScreenCoord(vec2(uv.x + fracPixel, uv.y + fracPixel));\n\n  fragColor = (sample1 + sample2 + sample3 + sample4 + sample5 + sample6 + sample7 + sample8 + sample9) / 9.;\n/* */\n}\n","name":"Image","description":"","type":"image"}]}