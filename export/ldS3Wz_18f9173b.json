{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"//\n// Configuration\n//\n#define MANDELBROT\n#define JULIA\n\n//#define INVERT\n//#define EXP\n\n#define JULIA_MULTS 1\n#define JULIA_ITERATIONS 30\n#define JULIA_SIZE 6.\n\n//\n// Constants\n//\n#define PI 3.1415\n\n//\n// Operations on complex numbers.\n//\nvec2 cpx_mult(vec2 a, vec2 b) {\n\treturn vec2(\n\t\ta.x*b.x - a.y*b.y,\n\t\ta.x*b.y + a.y*b.x);\n}\n\nfloat cpx_arg(vec2 c) {\n\tif(c.x > 0.) {\n\t\treturn atan(c.y / c.x);\n\t}\n\telse if(c.x < 0.) {\n\t\tif(c.y >= 0.) {\n\t\t\treturn atan(c.y / c.x) + PI;\n\t\t}\n\t\telse {\n\t\t\treturn atan(c.y / c.x) - PI;\n\t\t}\n\t}\n\telse if(c.x == 0.) {\n\t\tif(c.y > 0.) {\n\t\t\treturn PI / 2.;\n\t\t}\n\t\telse if(c.y < 0.) {\n\t\t\treturn -PI / 2.;\n\t\t}\n\t\telse {\n\t\t\treturn 0.; // Doesn't exist.\n\t\t}\n\t}\n}\n\nvec2 cpx_sqrt(vec2 c) {\n\tfloat sq = sqrt(length(c));\n\tfloat arg = cpx_arg(c) / 2.;\n\treturn vec2(sq*cos(arg), sq*sin(arg));\n}\n\nvec2 cpx_inv(vec2 c) {\n\tfloat modsq = dot(c, c);\n\treturn vec2(\n\t\tc.x / modsq,\n\t\t-c.y / modsq);\n}\n\nvec2 cpx_exp(vec2 c) {\n\treturn vec2(exp(c.x) * cos(c.y), exp(c.x) * sin(c.y));\n}\n\n//\n// 2D Scene\n//\nvec3 scene(vec2 pos) {\n\treturn vec3(exp(length(pos)));\n}\n\n//\n// Julia fractal\n//\nvec2 julia(vec2 pos, vec2 c) {\n\tfor(int i = 0; i < JULIA_ITERATIONS; i++) {\n\t\tvec2 oldpos = pos;\n\t\tfor(int j = 0; j < JULIA_MULTS; j++) {\n\t\t\tpos = cpx_mult(pos, oldpos);\n\t\t}\n\t\tpos += c;\n\t}\n\treturn pos;\n}\n\n//\n// Main\n//\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 pos = fragCoord.xy - iResolution.xy * 0.5;\n\tvec2 mpos = iMouse.xy - iResolution.xy * 0.5;\n\t\n\tpos *= JULIA_SIZE / length(iResolution.xy);\n\tmpos *= JULIA_SIZE / length(iResolution.xy);\n\t\n\t#ifdef INVERT\n\tpos = cpx_inv(pos);\n\t#endif\n\t\n\t#ifdef EXP\n\tpos = cpx_exp(pos);\n\t#endif\n\t\n\t#ifdef MANDELBROT\n\tvec4 mcol = vec4(scene(julia(vec2(0, 0), pos)), 1.);\n\t#endif\n\t\n\t#ifdef JULIA\n\tvec4 jcol = vec4(scene(julia(pos, mpos)), 1.);\n\t#endif\n\t\n\t#ifdef MANDELBROT\n\t\t#ifdef JULIA\n\t\t\t// BOTH\n\t\t\tfragColor = vec4(jcol.x, mcol.y, (mcol.z + jcol.z) / 2., 1.);\n\t\t#else\n\t\t\t// ONLY MANDELBROT\n\t\t\tfragColor = mcol;\n\t\t#endif\n\t#else\n\t\t// ONLY JULIA\n\t\tfragColor = jcol;\n\t#endif\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldS3Wz","date":"1385981229","viewed":209,"name":"Mandelbrot/Julia Fractal","username":"lumirayz","description":"Define MANDELBROT to get a Mandelbrot fractal.\nDefine JULIA to get a Julia fractal.\nJULIA_MULT is the amount of times that the complex number will be multiplied by itself.\nWith the Julia fractal, you can click and drag the mouse to get multiple.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["fractal","julia","mandelbrot"],"hasliked":0,"parentid":"","parentname":""}}