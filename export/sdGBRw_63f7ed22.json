{"ver":"0.1","info":{"id":"sdGBRw","date":"1657825868","viewed":72,"name":"Trig-wrestling with a sphere","username":"turnipGod","description":"Originally posted on glslsandbox. I decided to move it here","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPSILON 0.001\n#define MAX_STEP 255\n#define CLIP_DIST 1000.0\n\nmat3 rotate_x(float theta) {\n\treturn mat3(\n\t\tvec3(1.0, 0.0, 0.0),\n\t\tvec3(0.0, cos(theta), -sin(theta)),\n\t\tvec3(0.0, sin(theta), cos(theta))\n\t);\n}\n\nmat3 rotate_z(float theta) {\n\treturn mat3(\n\t\tvec3(cos(theta), -sin(theta), 0.0),\n\t\tvec3(sin(theta), cos(theta), 0.0),\n\t\tvec3(0.0, 0.0, 1.0)\n\t);\n}\n\nfloat cactus_sdf( vec3 p, float h, float r, float rel_y ) {\n\tfloat min_ratio = 0.25;\n\tfloat min_r = r * 0.75;\n\tfloat max_delta_r = r - min_r;\n\tfloat varying_r = min_r + (max_delta_r * (1.0 + sin(iTime + rel_y * 20.0)/2.0));\n\tp.y -= clamp( p.y, 0.0, h );\n\treturn length( p ) - varying_r;\n}\n\nfloat distance_estimator(vec3 p) {\n\tvec3 translate = vec3(0.0, 0.25, 0.0);\n\treturn cactus_sdf(rotate_z(iTime/3.0) * rotate_x(iTime/2.5) * p + translate, 0.5, 0.3, p.y);\n}\n\nvec3 estimate_normal(vec3 p) {\n\treturn normalize(vec3(\n\t\tdistance_estimator(vec3(p.x + EPSILON, p.y, p.z)) - distance_estimator(vec3(p.x - EPSILON, p.y, p.z)),\n\t\tdistance_estimator(vec3(p.x, p.y + EPSILON, p.z)) - distance_estimator(vec3(p.x, p.y - EPSILON, p.z)),\n\t\tdistance_estimator(vec3(p.x, p.y, p.z  + EPSILON)) - distance_estimator(vec3(p.x, p.y, p.z - EPSILON))\n\t));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    //pixel location, trasformed to NDC (-1.0, 1.0)\n\tvec2 p = (2.0*(fragCoord.xy + 0.5)-iResolution.xy)/ iResolution.y;\n\t// default (background) color\n\tvec3 color = vec3(0.3);\n\t//camera (ray) origin\n\tvec3 ro = vec3(0.0, 0.0, -1.5);\n\t//ray direction (ignoring FOV for time being)\n\tvec3 rd = normalize(vec3(p, 1.0));\n\t//light pos\n\tvec3 light_pos = vec3(1.5, 2.0, -2.0);\n\t\n\t//start marching\n\tfloat dist = CLIP_DIST;\n\tfor (int i = 0; i < MAX_STEP; i++) {\n\t\tdist = distance_estimator(ro);\n\t\tro += rd * dist;\n\t}\n\t\n\tif (dist < EPSILON) {\n\t\tcolor = vec3(46.0/255.0,96.0/255.0,33.0/255.0);\n\t\t\n\t\t//calculate illumination\n\t\t\n\t\t//light direction\n\t\tvec3 light_dir = normalize(ro - light_pos);\n\t\tcolor *= max(0.0, dot(light_pos, estimate_normal(ro)) + 0.5);\n        /* cel shading */\n        color.xyz = round(color.xyz*3.0)/3.0;\n\t}\n\t\n\tfragColor = vec4(color, 1.0 );\n}","name":"Image","description":"","type":"image"}]}