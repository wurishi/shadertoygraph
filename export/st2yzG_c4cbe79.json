{"ver":"0.1","info":{"id":"st2yzG","date":"1649887096","viewed":93,"name":"WavyNoiseExperiment","username":"codeisrad","description":"Trying out a kind of noise based off of gyroids for terrain height-maps, but it looks fun just by itself! I'm finally diving into shaders after dabbling for years, any feedback is welcome. Please let me know if I'm being a doofus, thanks for stopping by!","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["noise","experiment","heightmap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n    MIT License\n\n    Copyright (c) 2022 (shadertoy.com user codeisrad)\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the \"Software\"), to deal\n    in the Software without restriction, including without limitation the rights\n    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all\n    copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n    SOFTWARE.\n\n*/\n\n\n// ----------------------------------------------------------------\n// functions relevant to this experiment\n// ----------------------------------------------------------------\n\n\n// wavy(uv, uvwarp, pz) - base gyroid-ish function\n// - uv: uv, scaled as desired\n// - uvwarp: influence of uv warping on the x & y axis\n// - pz: the base z component of the gyroid, since we're taking in a vec2 instead of a vec3\n\nfloat wavy(in vec2 uv, in vec2 uvwarp, in float pz) {\n    \n    // create a vec3 to use with a usual 3d gyroid approach\n    vec3 p = vec3(uv, pz);\n\n    // \"warp\" the z coordinate around based on the uv x & y coordinates\n    // having different offsets (the first numbers: 17, 13) & multipliers helps keep things organic\n    // any other approach that warps p.z should be viable as well\n    p.z += sin(17.0 + uv.x * uvwarp.x);\n    p.z += sin(13.0 + uv.y * uvwarp.y);\n\n    \n    // usual gyroid function, taking the abs() of it to create ridges\n    // other approaches could produce intersting results such as fract() or sin()/cos()\n    return abs(dot(sin(p), cos(p.yzx)));   \n}\n\n// wavyOctaves(uv, uvwarp, pz, octaves)\n// - uv, uvwarp, pz: see wavy()\n// - octaves: number of octaves, each octave scales the uvs by 2\nfloat wavyOctaves(in vec2 uv, in vec2 uvwarp, in float pz, in float octaves) {\n    float result = 0.0;\n    \n    // base \"frequency\", what the uvs are scaled by \n    float fq = 1.0;\n    \n    // TODO: might be interesting to skip the first octave, as it is a bit over-bearing \n    //       or it could be that the way of calculating infl below is incorrect\n    \n    for(float o = 1.0; o <= octaves; o += 1.0) {\n        // the \"influence\" this octave has on the overall result\n        // TODO: really unsure if this is the best way to handle this\n        //       need to look at other fractal noise examples\n        //       was trying for an approach that bound the results between 0-1\n        float infl = 1.0 / (fq * 2.0);\n        \n        // use wavy() with uvs scaled by fq, the output then scaled by infl\n        result += wavy(uv * fq, uvwarp, pz) * infl;\n        \n        // shift the uvs around by an arbitrary amount (borrwing uvwarp here) to keep things organic\n        uv += uvwarp;\n        \n        // by default, fq is doubled each iteration\n        fq *= 2.0;\n    }\n    \n    return result;\n}\n\n\n// ----------------------------------------------------------------\n// preset values, including a few to play around with\n// ----------------------------------------------------------------\n\n\n// default scale of uvs\n#define UV_SCALE 2.0\n\n// time preset, change to slow/speed-up animation\n#define TIME (iTime * 0.5)\n\n// how many octaves to use for noise\n// note that due to the way later octaves fall off in influence, higher octaves might not be noticable\n#define OCTAVES 8.0\n\n// color schemes, inteded to be used as the first two parameters to mix(a, b, x)\n#define COLOR_CLOUDS vec3(0.2, 0.25, 0.35), vec3(0.9, 0.85, 0.8)\n#define COLOR_WB vec3(0.0), vec3(1.0)\n#define COLOR_BW vec3(1.0), vec3(0.0)\n#define COLOR_FIRE vec3(0.7, 0.1, 0.1), vec3(0.9, 0.8, 0.3)\n\n// various uvwarp presets, although more could be achieved by altering how wavy() distorts pz \n#define UVWARP_EVEN vec2(1.1, 1.9)\n#define UVWARP_ODDITY vec2(7.2, 8.3)\n#define UVWARP_NONE vec2(0.0)\n\n// choose presets here, or define new ones or whatever. \n#define COLOR COLOR_BW\n#define UVWARP UVWARP_EVEN\n\n\n// ----------------------------------------------------------------\n// main shader, example usage of wavyOctaves()\n// ----------------------------------------------------------------\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // dividing by .y rather than .xy to preserve aspect ratio\n    vec2 uv = fragCoord/iResolution.y;\n    \n    // result of wavyOctaves *should* be in range of [0,1]\n    float h = wavyOctaves(uv * UV_SCALE, UVWARP, TIME, OCTAVES);\n\n    // use h to blend between colors defined above\n    vec3 col = mix(COLOR, h);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}