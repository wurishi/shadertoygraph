{"ver":"0.1","info":{"id":"MXGXWK","date":"1720482916","viewed":91,"name":"Octree Ray Tracer 2.0","username":"cboltjes","description":"This is an octree traversal ray-tracing algorithm I am developing for a VR voxel game. Includes chunk based LOD.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","experimental"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define T iTime * 0.1\n// Maximum steps rays will take\n#define MAX_STEPS 1000\n\n// Maximum degree that can be set (go to error and adjust variable to increase max_degree)\n#define MAX_DEGREE 8\n// Depth of octree traversal (go to error and adjust variable to increase traversal degree)\n#define DEGREES 6\n\nvec3 global_pos = vec3(0.0);\n\nmat2 Rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nstruct ray {\n    vec3 pos;\n    vec3 dir;\n    vec3 sDir; // Step(dir), saved for quick calculations\n    vec3 inverseDir; // 1.0/abs(dir), saved for quick calculations\n    \n    vec3 color;\n    vec3 norm;\n    \n    int steps;\n    vec3 dist_vec;\n};\n\nray initRay(vec2 uv, vec3 origin, vec3 dir) {\n    vec3 d = normalize(vec3(uv,1.0));\n    d.yz *= Rot(dir.y);\n    d.xz *= Rot(dir.x);\n    return ray(\n        origin,\n        d,\n        step(0.0, d),\n        1.0/abs(d),\n        \n        vec3(0.0),\n        vec3(0.0),\n        \n        0,\n        vec3(0.0)\n    );\n}\n\nstruct camera {\n    vec3 origin;\n    vec3 dir;\n};\n\ncamera initCamera(vec3 origin, vec3 dir){\n    return camera(\n        origin,\n        dir\n    );\n}\n\nvec3 voxNorm(inout vec3 pos, inout vec3 sDir) {\n    vec3 dist = fract(pos);\n    dist = (1.0 - sDir) * (1.0 - dist) + (sDir) * dist;\n    if (dist.x < dist.y && dist.x < dist.z) {\n        return vec3(2.0*sDir.x - 1.0, 0.0, 0.0);\n    }\n    else if(dist.y < dist.z) {\n        return vec3(0.0, 2.0*sDir.y - 1.0, 0.0);\n    }\n    return vec3(0.0, 0.0, 2.0*sDir.z - 1.0);\n}\n\nint hitCheck(inout ray r, inout vec3 position[MAX_DEGREE], int degree, int tree_degree) {\n    if(floor(r.pos.x) == 0.0 && floor(r.pos.y) == 0.0)\n        return 0;\n    r.steps++;\n    vec3 pos = vec3(0.0);\n    for(int d = 1; d <= degree; d++)\n        pos += floor(position[d]) * pow(0.5, float(d));\n    vec3 p = pos + floor(r.pos) + floor(global_pos) + 0.5;\n    vec3 q = p / iChannelResolution[0].xyz;\n    vec4 result = texture(iChannel0, q).rgba;\n    if(result.a < 0.5)// && degree < 1 || result.a < 0.2)\n        return 0;\n    else if(result.a < 0.9 && degree < tree_degree){// || degree != DEGREES){\n        return 2;\n    }\n    r.color = result.rgb;\n    return 1;\n}\n\nfloat nextVoxDist(inout ray r, inout vec3 p) {\n    vec3 dist = fract(p);\n    dist = (1.0-r.sDir)*dist + (1.0-dist)*r.sDir;\n    dist *= r.inverseDir;\n    if (dist.x < dist.y && dist.x < dist.z) {\n        return dist.x + 0.00009765625;\n    }\n    else if(dist.y < dist.z) {\n        return dist.y + 0.00009765625;\n    }\n    return dist.z + 0.00009765625;\n}\n\nint marchOctree(inout ray r, int degree) {\n    vec3 position[MAX_DEGREE] = vec3[](vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n    position[0] = fract(r.pos);\n    int oHit = hitCheck(r, position, 0, degree);\n    if(oHit == 1) {\n        r.norm = voxNorm(position[0], r.sDir);\n        return 1;\n    }\n    else if(oHit == 0)\n        return 0;\n    for(int d = 1; d <= degree && r.steps < MAX_STEPS;) {\n        //if(r.steps >= 8){r.color = vec3(0.0); return 1;}\n        position[d] = fract(position[d-1]) * 2.0f;\n        switch(hitCheck(r, position, d, degree)) {\n            case 0:\n                // Move Forward\n                vec3 move = nextVoxDist(r, position[d]) * r.dir;\n                int i = d;\n                while(i > -1) {\n                    position[i--] += move;\n                    move *= 0.5;\n                }\n                r.dist_vec += move;\n                while(position[d].x < 0.0 || position[d].x >= 2.0 ||\n                   position[d].y < 0.0 || position[d].y >= 2.0 ||\n                   position[d].z < 0.0 || position[d].z >= 2.0\n                ) {\n                    if(--d == 0)\n                        return 0;\n                }\n                break;\n            case 1:\n                // Hit\n                r.norm = voxNorm(position[d], r.sDir);\n                \n                return 1;\n            default:\n                // Else go up a degree\n                d++;\n        }   \n    }\n    return 0;\n}\n\nvoid marchRay(inout ray r, float radii[DEGREES]){\n    int degree = DEGREES;\n    float max_dist = 0.0;\n    float radius = 0.0;\n    for(int i = 0; i < DEGREES; i++)\n        max_dist += radii[i];\n    while(degree > 0) {\n        radius = 0.0;\n        for(int i = degree; i <= DEGREES; i++)\n            radius += radii[i-1];\n        while(length(floor(r.pos)) < radius && r.steps < MAX_STEPS) {\n            if(marchOctree(r, degree) == 1) {\n                float dist = length(r.dist_vec);\n                float gradiant = dist/max_dist;;\n                r.color *= 1.0 - gradiant * gradiant;\n                return;\n            }\n            else {\n                vec3 move = nextVoxDist(r, r.pos) * r.dir;\n                r.pos += move;\n                r.dist_vec += move;\n            }\n        }\n        degree--;\n    }\n    r.color = vec3(0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    // The radii of rendering precision\n    float radii[DEGREES] = float[](2.0, 2.0, 2.0, 2.0, 2.0, 15.0);\n    vec3 pos = vec3(0.1, 1.2, -20.6-T);\n    global_pos = floor(pos);\n    camera cam = initCamera(fract(pos), vec3(-m.x*5.0 - 0.4, 2.9-m.y*5.0, 0.0));\n    \n    ray r = initRay(uv, cam.origin, cam.dir);\n    marchRay(r, radii);\n    vec3 light1 = normalize(vec3(-0.5, -0.9, -0.7));\n    vec3 light2 = normalize(vec3(0.5, 0.9, 0.7));\n    if(length(r.norm) > 0.0)\n        r.color *= abs(dot(light1, r.norm)) + abs(dot(light2, r.norm)) * 0.8;\n    \n    fragColor = vec4(r.color, 1.0);\n}","name":"Image","description":"","type":"image"}]}