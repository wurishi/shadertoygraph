{"ver":"0.1","info":{"id":"7tGSRc","date":"1641495363","viewed":143,"name":"Low-discrepancy sequence","username":"kenhu","description":"https://en.wikipedia.org/wiki/Low-discrepancy_sequence\n\n---- Halton(2,3) -------- Hammersley --------------------------- Sobol'(0,1) ----------------\n---- R2 ------------------- Hash-based Owen Scrambling ------ Cascaded Sobol'(0,1) ---","likes":8,"published":1,"flags":48,"usePreview":0,"tags":["halton","hammersley","discrepancy","sobol"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Low-discrepancy sequences(sets), colored by hue, red to violet\n// - Top Row\n//     - Halton(2,3)                  https://en.wikipedia.org/wiki/Low-discrepancy_sequence#Halton_sequence\n//     - Hammersley                   https://en.wikipedia.org/wiki/Low-discrepancy_sequence#Hammersley_set\n//     - Sobol'(0,1)                  https://en.wikipedia.org/wiki/Sobol_sequence\n// - Bottom Row\n//     - R2                           http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\n//     - Hash-based Owen Scrambling   https://jcgt.org/published/0009/04/01/\n//     - Cascaded Sobol'              https://perso.liris.cnrs.fr/david.coeurjolly/publication/cascaded2021/\n// - Keys\n//     - '1' = 16, '2' = 64, '3' = 256, '4' = 1024 Samples\n//     - 'R' = Restart\n//     - 'P' = Hold to print first 10 samples\n// - Code\n//     - Common:   Configurations, Sequence generator, Helper functions\n//     - Buffer A: Sample generation, Layout, State\n//     - Image:    Composite, Print\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    // Load state\n    vec4 state = texelFetch(iChannel0, ivec2(iResolution.xy - 1.0), 0);\n    int frame_start = int(state.x);\n    uint sample_count = uint(state.y);\n    \n    // Print\n    float pivot_x = 0.0;\n    float pivot_y = 0.0;\n\n    float stride_x = iResolution.y / 2.0;\n    float stride_y = iResolution.y / 2.0;\n\n    float offset_x = 0.0;\n    float offset_y = 5.0;\n    \n    if (PRINT_SAMPLE || KeyHold(80)) // 'P'\n    {\n        // Halton\n        pivot_x = 0.0 * stride_x + offset_x; pivot_y = 1.0 * stride_y + offset_y;\n        for (uint i = 0u; i < PRINT_N; i++)\n        {\n            Print(0u, i, pivot_x, pivot_y, HaltonFloat(i, 2u), fragCoord, fragColor);\n            Print(1u, i, pivot_x, pivot_y, HaltonFloat(i, 3u), fragCoord, fragColor);\n        }\n        \n        // Hammersley\n        pivot_x = 1.0 * stride_x + offset_x; pivot_y = 1.0 * stride_y + offset_y;\n        for (uint i = 0u; i < PRINT_N; i++)\n        {\n            vec2 xy = HammersleyFloat(i, sample_count);\n            Print(0u, i, pivot_x, pivot_y, xy.x, fragCoord, fragColor);\n            Print(1u, i, pivot_x, pivot_y, xy.y, fragCoord, fragColor);\n        }\n        \n        // Sobol\n        pivot_x = 2.0 * stride_x + offset_x; pivot_y = 1.0 * stride_y + offset_y;\n        for (uint i = 0u; i < PRINT_N; i++)\n        {\n            Print(0u, i, pivot_x, pivot_y, SobolFloat(i, 0u), fragCoord, fragColor);\n            Print(1u, i, pivot_x, pivot_y, SobolFloat(i, 1u), fragCoord, fragColor);\n        }\n        \n        // R2\n        pivot_x = 0.0 * stride_x + offset_x; pivot_y = 0.0 * stride_y + offset_y;\n        for (uint i = 0u; i < PRINT_N; i++)\n        {\n            vec2 xy = R2(i);\n            Print(0u, i, pivot_x, pivot_y, xy.x, fragCoord, fragColor);\n            Print(1u, i, pivot_x, pivot_y, xy.y, fragCoord, fragColor);\n        }\n        \n        // Hash-based Owen Scrambling\n        pivot_x = 1.0 * stride_x + offset_x; pivot_y = 0.0 * stride_y + offset_y;\n        for (uint i = 0u; i < PRINT_N; i++)\n        {\n            Print(0u, i, pivot_x, pivot_y, HashOwenFloat(i, 0u), fragCoord, fragColor);\n            Print(1u, i, pivot_x, pivot_y, HashOwenFloat(i, 1u), fragCoord, fragColor);\n        }\n        \n        // Cascaded Sobol'\n        pivot_x = 2.0 * stride_x + offset_x; pivot_y = 0.0 * stride_y + offset_y;\n        for (uint i = 0u; i < PRINT_N; i++)\n        {\n            Print(0u, i, pivot_x, pivot_y, CascadedSobolFloat(i, 0u, sample_count), fragCoord, fragColor);\n            Print(1u, i, pivot_x, pivot_y, CascadedSobolFloat(i, 1u, sample_count), fragCoord, fragColor);\n        }\n    }\n    \n    pivot_x = 3.2 * stride_x + offset_x; pivot_y = 0.0 * stride_y + offset_y;\n    bool debug_state = false;\n    if (debug_state)\n    {\n        Print(0u, 3u, pivot_x, pivot_y, state.w, fragCoord, fragColor);\n        Print(0u, 2u, pivot_x, pivot_y, state.z, fragCoord, fragColor);\n        Print(0u, 1u, pivot_x, pivot_y, state.y, fragCoord, fragColor);\n        Print(0u, 0u, pivot_x, pivot_y, state.x, fragCoord, fragColor);\n    }\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    vec2 uv = fragCoord / iResolution.yy;\n    fragColor.rgb = vec3(0.);\n\n    // Initialize or load state\n    vec4 state = vec4(0.0f);\n    state.x = 0.0f;                   // frame_start\n    state.y = float(SAMPLE_COUNT);    // sample_count\n    if (iFrame >= 1)\n        state = texelFetch(iChannel0, ivec2(iResolution.xy - 1.0), 0);\n    int frame_start = int(state.x);\n    uint sample_count = uint(state.y);\n    \n    // Generate points\n    for (uint i = 0u; i < SAMPLE_PER_FRAME; i++)\n    {\n        // Index\n        uint index = uint(iFrame - frame_start) * SAMPLE_PER_FRAME + i;\n        if (index >= sample_count)\n            break;\n        \n        // Color (by index)\n        vec3 color = vec3(1.0, 1.0, 1.0);\n        if (DRAW_COLOR_SCHEME == 0) // Hue: red to violet\n        {\n            color = HSV2RGB(vec3(0.75 * float(index) / float(sample_count - 1u), 1.0, 1.0));\n        }\n        if (DRAW_COLOR_SCHEME == 1) // Red:[1,10], Green:[11, 90], Blue:[91, 256] as on wikipedia\n        {\n            color = vec3(1.0, 0.0, 0.0);\n            if (index >= 11u)\n                color = vec3(0.0, 0.0, 1.0);\n            if (index >= 101u)\n                color = vec3(0.0, 1.0, 0.0);\n        }\n\n        // Layout\n        vec2 scale = vec2(0.5, 0.5);\n\n        // Halton\n        {\n            float x = HaltonFloat(index, 2u);\n            float y = HaltonFloat(index, 3u);\n            \n            vec2 offset = vec2(0.0, 0.5);    \n            vec2 p = vec2(x, y) * scale + offset;\n            fragColor.rgb += color * DrawPoint(p, uv);\n        }\n        \n        // Hammersley       \n        {\n            vec2 xy = HammersleyFloat(index, sample_count);\n            float x = xy.x;\n            float y = xy.y;\n    \n            vec2 offset = vec2(0.5, 0.5);\n            vec2 p = ApplyStrataOffset(x, y, sample_count) * scale + offset;\n            fragColor.rgb += color * DrawPoint(p, uv);\n        }\n        \n        // Sobol\n        {\n            float x = SobolFloat(index, 0u);\n            float y = SobolFloat(index, 1u);\n    \n            vec2 offset = vec2(1.0, 0.5);\n            vec2 p = ApplyStrataOffset(x, y, sample_count) * scale + offset;\n            fragColor.rgb += color * DrawPoint(p, uv);\n        }\n        \n        // R2\n        {\n            vec2 xy = R2(index);\n            float x = xy.x;\n            float y = xy.y;\n    \n            vec2 offset = vec2(0.0, 0.0);\n            vec2 p = vec2(x, y) * scale + offset;\n            fragColor.rgb += color * DrawPoint(p, uv);\n        }\n        \n        // Hash-based Owen Scrambling\n        {\n            float x = HashOwenFloat(index, 0u);\n            float y = HashOwenFloat(index, 1u);\n    \n            vec2 offset = vec2(0.5, 0.0);\n            vec2 p = vec2(x, y) * scale + offset;\n            fragColor.rgb += color * DrawPoint(p, uv);\n        }\n        \n        // Cascaded Sobol\n        {\n            float x = CascadedSobolFloat(index, 0u, sample_count);\n            float y = CascadedSobolFloat(index, 1u, sample_count);\n    \n            vec2 offset = vec2(1.0, 0.0);\n            vec2 p = ApplyStrataOffset(x, y, sample_count) * scale + offset;\n            fragColor.rgb += color * DrawPoint(p, uv);\n        }\n    }\n\n    // Accumulate points across frames\n    fragColor.rgb += texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n    fragColor.a = 1.;\n    \n    // Keyboard\n    bool reset = false;\n    if (KeyDown(82)) // 'R' for reset\n    {\n        reset = true;\n    }\n    if (KeyDown(49) || KeyDown(97)) // '1' for 16 samples\n    {\n        state.y = 16.0;\n        reset = true;\n    }\n    if (KeyDown(50) || KeyDown(98)) // '2' for 64 samples\n    {\n        state.y = 64.0;\n        reset = true;\n    }\n    if (KeyDown(51) || KeyDown(99)) // '3' for 256 samples\n    {\n        state.y = 256.0;\n        reset = true;\n    }\n    if (KeyDown(52) || KeyDown(100)) // '4' for 1024 samples\n    {\n        state.y = 1024.0;\n        reset = true;\n    }\n    if (reset)\n    {\n        state.x = float(iFrame + 1);\n        fragColor = vec4(0.0);\n    }\n    \n    // Draw lines\n    if (iFrame - frame_start == 0)\n    {\n        const vec3 grid_color = vec3(0.5);\n        fragColor.rgb += grid_color * DrawLine(vec2(0.5, -1.0), uv);\n        fragColor.rgb += grid_color * DrawLine(vec2(1.0, -1.0), uv);\n        fragColor.rgb += grid_color * DrawLine(vec2(1.5, -1.0), uv);\n        fragColor.rgb += grid_color * DrawLine(vec2(-1.0, 0.5), uv);\n        \n        if (SHOW_STRATA)\n        {\n            const vec3 div_color = vec3(0.2);\n        \n            uint div_x = STRATA_DIV_X; \n            for (uint i = 1u; i < div_x; i++)\n            {\n                fragColor.rgb += div_color * DrawLine(vec2(0.0 + 0.5 * float(i) / float(div_x), -1.0), uv);\n                fragColor.rgb += div_color * DrawLine(vec2(0.5 + 0.5 * float(i) / float(div_x), -1.0), uv);\n                fragColor.rgb += div_color * DrawLine(vec2(1.0 + 0.5 * float(i) / float(div_x), -1.0), uv);\n            }\n            uint div_y = STRATA_DIV_Y; \n            for (uint i = 1u; i < div_y; i++)\n            {\n                fragColor.rgb += div_color * DrawLine(vec2(-1.0, 0.0 + 0.5 * float(i) / float(div_y)), uv);\n                fragColor.rgb += div_color * DrawLine(vec2(-1.0, 0.5 + 0.5 * float(i) / float(div_y)), uv);\n            }\n        }\n    }\n    \n    // Store state\n    if (fragCoord.x > iResolution.x - 1.0 && fragCoord.y > iResolution.y - 1.0)\n        fragColor = state;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Configuration\nconst uint  SAMPLE_COUNT      = 16u;\nconst uint  SAMPLE_PER_FRAME  = 4u;\n\n// Show strata to check against (0,m,2)-Nets (better with SAMPLE_COUNT = 16)\nconst bool  SHOW_STRATA       = true;\nconst bool  STRATA_OFFSET     = true; // Prevent sample from lying on line. For Hammersley and non-scrambled Sobol' only.\nconst uint  STRATA_DIV_X      = 4u;\nconst uint  STRATA_DIV_Y      = 4u;\n\n// Print first N samples in number\nconst bool  PRINT_SAMPLE      = false;\nconst uint  PRINT_N           = 10u;\n\n// Draw\nconst float DRAW_POINT_SIZE   = 0.00005f;\nconst int   DRAW_COLOR_SCHEME = 0; // 0: Hue, 1: Wikipedia\n\n// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n// From: https://www.shadertoy.com/view/sd2Xzm\nuint ReverseBits(uint x) {\n    x = ((x & 0xaaaaaaaau) >> 1) | ((x & 0x55555555u) << 1);\n    x = ((x & 0xccccccccu) >> 2) | ((x & 0x33333333u) << 2);\n    x = ((x & 0xf0f0f0f0u) >> 4) | ((x & 0x0f0f0f0fu) << 4);\n    x = ((x & 0xff00ff00u) >> 8) | ((x & 0x00ff00ffu) << 8);\n    return (x >> 16) | (x << 16);\n}\n// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\nfloat LinearFloat(uint n, uint sample_count)\n{\n    return float(n) / float(sample_count);\n}\n// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n// RadicalInverse (Van der Corput)\n// From PBRT https://pbr-book.org/3ed-2018/Sampling_and_Reconstruction/The_Halton_Sampler\nfloat RadicalInverseFloat(uint n, uint base)\n{\n    float val = 0.0;\n    float invBase = 1.0 / float(base), invBi = invBase;\n    while (n > 0u)\n    {\n        // Compute next digit of radical inverse\n        uint d_i = (n % base);\n        val += float(d_i) * invBi;\n        n = uint(float(n) * invBase);\n        invBi *= invBase;\n    }\n    return val;\n}\n// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n// Hammersley\nvec2 HammersleyFloat(uint n, uint sample_count)\n{\n    return vec2(LinearFloat(n, sample_count), float(ReverseBits(n)) / float(0xffffffffu));\n}\n// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n// Halton\nfloat HaltonFloat(uint n, uint base)\n{\n    return RadicalInverseFloat(n, base);\n}\n// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n// Sobol\n// Based on https://www.shadertoy.com/view/3ldXzM\n// See also Kollig, Thomas and Keller, Alexander. Efficient multidimensional sampling\nuint Sobol(uint n, uint dim)\n{\n    if (dim == 0u)\n        return ReverseBits(n);\n        \n    if (dim == 1u)\n    {\n        uint r = 0u;\n        for(uint v = 1u << 31; n != 0u; n >>= 1u, v ^= v >> 1u)\n        if ((n & 1u) != 0u)\n            r ^= v;\n        return r;\n    }\n    \n    // Higher dimensions need corresponding generator matrics\n\n    return 0u;\n}\n\nfloat SobolFloat(uint n, uint dim)\n{\n    return float(Sobol(n, dim)) / float(0xffffffffu);\n}\n// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n// LarcherPillichshammer\n// Based on Kollig, Thomas and Keller, Alexander. Efficient multidimensional sampling\nuint LarcherPillichshammer(uint n)\n{\n    uint r = 0u;\n    for(uint v = 1u << 31; n != 0u; n >>= 1u, v |= v >> 1u)\n        if ((n & 1u) != 0u)\n            r ^= v;\n    \n    return r;\n}\n// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n// R2 Sequence\n// http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\nvec2 R2(uint n)\n{\n    n = n + 1u; // start at 1 not 0\n\n    float g = 1.32471795;\n    float a1 = 1.0 / g;\n    float a2 = 1.0 / (g * g);\n    float x = fract((a1 * float(n))); //float x = mod((0.5+a1*n),1.0);\n    float y = fract((a2 * float(n))); //float y = mod((0.5+a2*n),1.0);\n    return vec2(x, y);\n}\n// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n// Hash-based Owen Scrambling\n// http://www.jcgt.org/published/0009/04/01/\nuint LaineKarrasPermutation(uint x, uint seed)\n{\n    x += seed;\n    x ^= x * 0x6c50b47cu;\n    x ^= x * 0xb82f1e52u;\n    x ^= x * 0xc7afe638u;\n    x ^= x * 0x8d22f6e6u;\n    return x;\n}\n\nuint NestedUniformScrambleBase2(uint x, uint seed)\n{\n    x = ReverseBits(x);\n    x = LaineKarrasPermutation(x, seed);\n    x = ReverseBits(x);\n    return x;\n}\n\nuint HashCombine(uint seed, uint v)\n{\n    return seed ^ (v + (seed << 6) + (seed >> 2));\n}\n\nuint Hash(uint x)\n{\n    // finalizer from murmurhash3\n    x ^= x >> 16;\n    x *= 0x85ebca6bu;\n    x ^= x >> 13;\n    x *= 0xc2b2ae35u;\n    x ^= x >> 16;\n    return x;\n}\n\nuint HashOwen(uint n, uint dim)\n{\n    uint seed = 1u;\n    seed = Hash(seed);\n    uint index = NestedUniformScrambleBase2(n, seed);\n    return NestedUniformScrambleBase2(Sobol(index, dim), HashCombine(seed, dim));\n}\n\nfloat HashOwenFloat(uint n, uint dim)\n{\n    return float(HashOwen(n, dim)) / float(0xffffffffu);\n}\n// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n// Cascaded Sobol'\n// https://perso.liris.cnrs.fr/david.coeurjolly/publication/cascaded2021/\nuint CascadedSobol(uint n, uint dim, uint sample_count)\n{\n    if (dim == 0u)\n        return Sobol(n, dim);\n\n    // Shift to ensure both index are in same range\n    uint bits = uint(log2(float(sample_count)));\n    return Sobol(Sobol(n, dim - 1u) >> (32u - bits), dim);\n}\nfloat CascadedSobolFloat(uint n, uint dim, uint sample_count)\n{\n    return float(CascadedSobol(n, dim, sample_count)) / float(0xffffffffu);\n}\n// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n// ---- 8< ---- GLSL Number Printing - @P_Malin ---- 8< ----\n// Creative Commons CC0 1.0 Universal (CC-0) \n// https://www.shadertoy.com/view/4sBSWW\n\nfloat DigitBin( const int x )\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue( vec2 vStringCoords, float fValue, float fMaxDigits, float fDecimalPlaces )\n{       \n    if ((vStringCoords.y < 0.0) || (vStringCoords.y >= 1.0)) return 0.0;\n    \n    bool bNeg = ( fValue < 0.0 );\n\tfValue = abs(fValue);\n    \n\tfloat fLog10Value = log2(abs(fValue)) / log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCoords.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n\t\tif(fDigitIndex > fBiggestIndex) {\n\t\t\tif((bNeg) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n\t\t} else {\t\t\n\t\t\tif(fDigitIndex == -1.0) {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;\n\t\t\t} else {\n                float fReducedRangeValue = fValue;\n                if(fDigitIndex < 0.0) { fReducedRangeValue = fract( fValue ); fDigitIndex += 1.0; }\n\t\t\t\tfloat fDigitValue = (abs(fReducedRangeValue / (pow(10.0, fDigitIndex))));\n                fCharBin = DigitBin(int(floor(mod(fDigitValue, 10.0))));\n\t\t\t}\n        }\n\t}\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCoords.x) * 4.0) + (floor(vStringCoords.y * 5.0) * 4.0))), 2.0));\n}\n\n// ---- 8< -------- 8< -------- 8< -------- 8< ----\n// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n// Utilities\n\nvec2 ApplyStrataOffset(float x, float y, uint sample_count)\n{\n    float strata_offset = 0.0f;\n    if (STRATA_OFFSET)\n        strata_offset = 0.5f / float(sample_count);\n    return vec2(x + strata_offset, y + strata_offset);\n}\n\nfloat DrawPoint(vec2 p, vec2 uv) \n{\n    vec2 v = (p - uv);\n\treturn 1. - smoothstep(0., DRAW_POINT_SIZE, dot(v, v));\n}\n\nfloat DrawLine(vec2 p, vec2 uv) \n{\n    vec2 v = (p - uv);\n    \n    if (p.x < 0.0)\n        v.x = 0.0;\n    if (p.y < 0.0)\n        v.y = 0.0;\n        \n\treturn (1. - smoothstep(0., 0.00001, dot(v, v)));\n}\n\nvoid Print(uint i, uint j, float pivot_x, float pivot_y, float value, in vec2 fragCoord, inout vec4 fragColor)\n{\n    // Multiples of 4x5 work best\n    const vec2 vFontSize = vec2(8.0, 15.0);\n    const float fDigits = 1.0;\n    const float fDecimalPlaces = 4.0;\n    \n    const float fStrideX = vFontSize.x * (fDigits + 1.0 + fDecimalPlaces + 2.0);\n    const float fStrideY = vFontSize.y + 4.0;\n    \n    vec2 offset = vec2(pivot_x + fStrideX * float(i), pivot_y + fStrideY * float(j));\n    vec4 color = vec4(1.0, 0.0, 0.0, 1.0);\n    \n    float bias = 0.00001; // See comments in https://www.shadertoy.com/view/4sBSWW\n    \n    fragColor = mix(fragColor, color,\n        PrintValue((fragCoord - offset) / vFontSize, value + bias, fDigits, fDecimalPlaces));\n}\n\n// From https://qiita.com/kitasenjudesign/items/c8ba019f26d644db34a8\nvec3 HSV2RGB(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// From https://www.shadertoy.com/view/llySRh\n#define KeyToggle(ascii)  ( texelFetch(iChannel3,ivec2(ascii,2),0).x > 0.)\n#define KeyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define KeyHold(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<","name":"Common","description":"","type":"common"}]}