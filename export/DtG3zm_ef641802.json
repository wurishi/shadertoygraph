{"ver":"0.1","info":{"id":"DtG3zm","date":"1683738919","viewed":48,"name":"[nr] koch tutorial ","username":"darkdivan","description":"based on ArtOfCode's tutorial:\nhttps://www.youtube.com/watch?v=il_Qg9AqQkE&ab_channel=TheArtofCode\n","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["kifsfractaltutorial"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 N(float angle){\n    return vec2(sin(angle), cos(angle));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    //mouse = getCoord();\n    //uv *= 3.0;\n    uv *= 1.65;\n\n    uv += texelFetch( iChannel0, ivec2(0,0), 0 ).xy * 0.01 ;\n    float zoom_scale = texelFetch( iChannel2, ivec2(0,0), 0 ).x   ;\n    zoom_scale = zoom_scale/100. ;\n    zoom_scale = clamp(zoom_scale, 0.5, 5.0);\n    \n    //uv -= zoom.x-zoom.y;\n    //uv += getCoord();\n    uv *= zoom_scale;\n    vec3 col = vec3(0.);\n    \n\n    uv.y += 0.5*(tan( 5./6.*3.141 ) );\n    \n    uv.x = abs(uv.x);\n    vec2 n = N(5./6.*3.1415);\n    float d = dot(uv-vec2(0.5,0.),n);\n    uv -= n*max(0., d)*2.0;\n    \n\n    n = N(mouse.y*2./3.*3.1415) ;\n    float scale = 1.;\n    uv.x += 0.5 ;\n    const int N_ITER = 80;\n    for (int i=0; i<N_ITER; i++) {\n        uv *= 3.0;\n        scale *= 3.0;\n        uv.x -= 1.5;\n\n        uv.x = abs(uv.x);\n        uv.x -= 0.5;\n        uv -= n*min(0., dot(uv, n))*2.;\n    }\n    \n    \n    \n\n    \n    d = length(uv - vec2(clamp(uv.x, -1., 1.), 0.0) );\n    d = smoothstep(1.0/iResolution.y, .0, d/scale /5. );\n    //col.rg += uv/scale;\n    uv /= scale;\n    col += texture(iChannel1, uv*2.  - iTime*0.003).rgb;\n    //col += vec3(d);\n    \n    \n    //col += mix( vec3(d), vec3(uv/scale,0), 0.7);\n    \n    //col.rg += uv;\n    //col.rg = mix(col.rg, uv, 0.5);\n    // Output to screen\n    //col = vec3(zoom,0.);\n    //col = vec3(zoom.x, 0., 0.);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// For details on how the keyboard input works, see iq's tutorial: https://www.shadertoy.com/view/lsXGzf\n\n// Numbers are based on JavaScript key codes: https://keycode.info/\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_Q     = 81;\nconst int KEY_W     = 87;\n\n\nvec2 handlePosition(vec2 offset) {\n    float velocity = 1. / 10.; // This will cause offset to change by 0.01 each time an arrow key is pressed\n    //velocity = 1.0;\n    // texelFetch(iChannel1, ivec2(KEY, 0), 0).x will return a value of one if key is pressed, zero if not pressed\n    vec2 left = texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).x * vec2(-1, 0);\n    vec2 up = texelFetch(iChannel1, ivec2(KEY_UP,0), 0).x * vec2(0, 1);\n    vec2 right = texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).x * vec2(1, 0);\n    vec2 down = texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).x * vec2(0, -1);\n    //vec2 q = texelFetch(iChannel1, ivec2(KEY_Q, 0), 0).x * vec2(1, 0);\n    //vec2 w = texelFetch(iChannel1, ivec2(KEY_W, 0), 0).x * vec2(-1, 0);\n    \n    offset += (left + up + right + down)  * velocity;\n\n    return offset;\n}\n\nvec2 handleScale(vec2 scale) {\n    float velocity = 1. / 10.; // This will cause offset to change by 0.01 each time an arrow key is pressed\n    //velocity = 1.0;\n    // texelFetch(iChannel1, ivec2(KEY, 0), 0).x will return a value of one if key is pressed, zero if not pressed\n\n    vec2 q = texelFetch(iChannel1, ivec2(KEY_Q, 0), 0).x * vec2(1, 0);\n    vec2 w = texelFetch(iChannel1, ivec2(KEY_W, 0), 0).x * vec2(-1, 0);\n    \n    scale += (q+w)  * velocity;\n\n    return scale;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Return the offset value from the last frame (zero if it's first frame)\n    //vec2 offset = texelFetch( iChannel0, ivec2(0, 0), 0).xy;\n    //vec3 a = vec3(iChannel0.xy,0);\n    vec2 offset = texelFetch( iChannel0, ivec2(0, 0), 0).xy ;\n    vec2 scale  = texelFetch(iChannel0, ivec2(0,0), 1 ).yz;\n    //vec3 offset = vec3(0.0);\n    // Pass in the offset of the last frame and return a new offset based on keyboard input\n    offset = handlePosition(offset);\n    scale = handleScale(scale);\n\n    // Store offset in the XY values of every pixel value and pass this data to the \"Image\" shader and the next frame of Buffer A\n    fragColor = vec4(offset,0.,0.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// For details on how the keyboard input works, see iq's tutorial: https://www.shadertoy.com/view/lsXGzf\n\n// Numbers are based on JavaScript key codes: https://keycode.info/\n\nconst int KEY_Q     = 81;\nconst int KEY_W     = 87;\n\n\n\nvec2 handleKeyboard(vec2 scale) {\n    float velocity = 1. / 1.; // This will cause offset to change by 0.01 each time an arrow key is pressed\n    //velocity = 1.0;\n    // texelFetch(iChannel1, ivec2(KEY, 0), 0).x will return a value of one if key is pressed, zero if not pressed\n\n    vec2 q = texelFetch(iChannel1, ivec2(KEY_Q, 0), 0).x * vec2(1, 0);\n    vec2 w = texelFetch(iChannel1, ivec2(KEY_W, 0), 0).x * vec2(-1,0);\n    \n    scale += (q+w)  * velocity;\n\n    return scale;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Return the offset value from the last frame (zero if it's first frame)\n\n    vec2 scale  = texelFetch(iChannel0, ivec2(0,0), 0 ).xy;\n    scale = handleKeyboard(scale);\n\n    // Store offset in the XY values of every pixel value and pass this data to the \"Image\" shader and the next frame of Buffer A\n    fragColor = vec4(scale,0.,0.);\n}","name":"Buffer B","description":"","type":"buffer"}]}