{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"cubemap","id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"cubemap","id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"channel":2,"type":"texture","id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// Protoype by Morgan of some implicit surface content for the ray tracing\n// tutorial in the Graphics Codex http://graphicscodex.com\n\nconst float pi          = 3.1415926535;\nconst float degrees     = pi / 180.0;\n\nfloat square(float x) { return x * x; }\nvec3 square(vec3 v) { return v * v; }\nfloat max3(float a, float b, float c) { return max(a, max(b, c)); }\nfloat min3(float a, float b, float c) { return min(a, min(b, c)); }\nfloat maxComponent(vec2 v) { return max(v.x, v.y); }\nfloat maxComponent(vec3 v) { return max3(v.x, v.y, v.z); }\nfloat saturate(float x) { return clamp(x, 0.0, 1.0); }\n\nstruct Ray {\n\tvec3        origin;\n\tvec3        direction;\n};\n\t\nstruct Material {\n    vec3       lambertian;\n\tfloat       glossy;\n\tfloat       glossyExponent;\n};\n\nstruct Surfel {\n\tvec3\t\tposition;\n\tvec3\t\tnormal;\n\tMaterial    material;\n};\n\t\n\nconst float \tverticalFieldOfView = 40.0 * degrees;\nconst float \trayBumpEpsilon \t\t= 0.02;\nconst int \t\tMAX_STEPS \t\t\t= 80;\nconst float \tSURFACE_DISTANCE \t= 0.02;\n#define radianceMap iChannel0\n#define irradianceMap iChannel1\n#define ENABLE_TILES 1\nconst float TILE = 4.0;\n\t\nstruct Lego {\n\tmat3        orientation;\n    float       radius;\n} lego;\n\n\n\n// Box distance\nfloat legoLogoBox(vec2 p, vec2 b) {\n  return length(max(abs(p) - b, 0.0));\n}\n\n\n// Lego logo distance field. -2 <= uv.x <= 2\n// The math is based on https://www.shadertoy.com/view/MsX3W2 by mmalex.  Morgan\n// altered the logic to favor conditional assignments over large branches\n// and fmul/ intrinsics over explicit math\nfloat logo(vec2 uv) { \n\t// italic\n    uv.x += uv.y * -0.15;\n\n    // Clip to the bounds of the logo\n    if ((abs(uv.x) > 2.0) || (abs(uv.y) > 1.0)) { return 0.0; }\n\n    float GorE = float(abs(uv.x) >= 1.0);\n\n    float oldx = uv.x;\n\n    // Tile the letters\n    uv.x = fract(uv.x) - 0.5;\n\n    // Distance values\n    float a, b = 1.0;\n    if (oldx < 0.0) {\n        // L and E\n\n        // Vertical parts\n        a = legoLogoBox(uv - vec2(-0.35, 0.0), vec2(0.0, 0.75));\n\n        // Reflect the bottom to the top of the E as well\n        uv.y *= sign(uv.y) * (GorE - 1.0) + GorE;\n\n        // If not an E, make midHorizontalLine large so that it is ignored by min\n        float midHorizontalLine = legoLogoBox(uv - vec2(-0.15, 0.0), vec2(0.2, 0.0));\n        float horizontalLine = legoLogoBox(uv - vec2(0.0, -0.75), vec2(0.35, 0.0)) - GorE;\n        b = min(midHorizontalLine, horizontalLine);\n    } else {\n        // G and O\n\n        // Top and bottom arcs\n        a = abs(legoLogoBox(uv, vec2(0.1, 0.5)) - 0.25);\n\n        if ((oldx < 1.0) && (uv.x > 0.0) && (uv.y > 0.0) && (uv.y < 0.5)) {\n            // Cutout on the G\n\t\t\ta = 1.0;\n\t\t\t// This gives nicer rounding but miscompiles in WebGL:\n            //  a = legoLogoBox(uv - vec2(0.35, 0.6), vec2(0.0, 0.1));\n        }\n\n        // Sides of the ellipse, with a cutout for the right side of the G\n        b = legoLogoBox(uv - vec2(0.2, 0.0), vec2(0.15, 0.0));\n    }\n\n    // Was factored out of the above to reduce code in the branches\n    b += GorE;\n\n    // Smooth a lot for ray marching\n    return smoothstep(0.2, 0.0, min(a, b)); \n}\n\n\nfloat distanceEstimate(Lego lego, vec3 P) {\n    // http://www.robertcailliau.eu/Lego/Dimensions/zMeasurements-en.xhtml\n    const vec3      brickExtent                 = vec3(32.0, 9.6, 15.8);\n    const float     bottomCylinderRadius        = 6.51 / 2.0;\n    const float     bottomCylinderInnerRadius   = 4.8 / 2.0;\n    const float     bottomCylinderPeriod        = 8.0;\n    const vec3      supportExtent               = vec3(0.8, 6.5, 5.0);\n    const float     studHeight                  = 1.8;\n    const float     studRadius                  = 2.4;\n    const float     studPeriod                  = 8.0;\n\t\n    float sceneDistance = length(max(abs(P - TILE / 2.0) - vec3(12.0), 0.0));\n\t\n\tfloat yaw = iTime * sign(sin(floor((P.z - TILE / 2.0) / TILE))) + floor((P.x - TILE / 2.0) / TILE);\n\tfloat pitch = iTime / 7.0 + floor((P.y - TILE / 2.0) / TILE) * pi / 2.0;\n\tlego.radius = 1.0;\n    lego.orientation =\n\t\tmat3(cos(yaw), 0.0, -sin(yaw), 0.0, 1.0, 0.0, sin(yaw), 0.0, cos(yaw)) *\n\t\tmat3(1.0, 0.0, 0.0, 0.0, cos(pitch), sin(pitch), 0.0, -sin(pitch), cos(pitch));\n\n\t\t\n\t\n#\tif\tENABLE_TILES\n\t\tP = mod(P - TILE / 2.0, TILE) - TILE / 2.0;\n#\tendif\t\n    // Convert to millimeter scale, at the origin, in canonical orientation\n\tP = (P * lego.orientation) * (16.0 / lego.radius);\n\t\n    float boundingBoxDistance = length(max(abs(P) - (brickExtent / 2.0 + vec3(0, studHeight, 0)), 0.0));\n    if (boundingBoxDistance > 1.0) return boundingBoxDistance * lego.radius / 16.0;\n\n\tvec3 s = abs(P + vec3(0, 1.2 * 2.0, 0)) - (brickExtent / 2.0 - vec3(1.2, -1.2, 1.0));\n\tfloat t = min(maxComponent(s), 0.0) + length(max(s, 0.0));\n    float bodyDistance = length(max(abs(P) - brickExtent / 2.0 + 0.1, 0.0)) - 0.1;\n    bodyDistance = min(max(-t, bodyDistance), length(max(abs(vec3(P.x, P.y - 1.0, mod(P.z, 10.0) - 0.5 * 10.0)) - supportExtent / 2.0, 0.0)));\n\n    vec3 bottomP = vec3(mod(P.x - 0.5 * bottomCylinderPeriod, bottomCylinderPeriod) - 0.5 * bottomCylinderPeriod, P.yz);\n    float bottomPLen = length(bottomP.xz);\n    float bottomDistance = max3(bottomPLen - bottomCylinderRadius, bottomCylinderInnerRadius - bottomPLen, abs(bottomP.y) - brickExtent.y / 2.0); \n    bottomDistance = max(abs(P.x) - 12.0, bottomDistance);\n\tbodyDistance = min(bodyDistance, bottomDistance);\n\n    vec3 studP = vec3(mod(P.xz, studPeriod) - 0.5 * studPeriod, P.y).xzy;\n\tfloat logoHeight = logo(studP.zx) * 0.1;\n\t\n    return max(sceneDistance, (lego.radius / 16.0) * min(bodyDistance, max(length(studP.xz) - studRadius, (abs(studP.y - 9.6 / 2.0 - studHeight / 2.0) - studHeight / 2.0 - logoHeight))));\n}\n\n\nbool intersectScene(Ray eyeRay, inout float maxDist, inout Surfel surfel) {\n\tfloat t = 0.0;\n\tfor (int i = 0; i < MAX_STEPS; ++i) {\n\t\tvec3 P = eyeRay.direction * t + eyeRay.origin;\n\t\tfloat d = distanceEstimate(lego, P);\n\t\t#if ENABLE_TILES\n\t\t// Never jump between tiles\n\t\td = min(d, TILE / 4.0);\n\t\t#endif\n\t\t\n\t\tif (d < SURFACE_DISTANCE) {\n\t\t\tsurfel.position = P;\n\t\t\t// Back up before computing the normal\n\t\t\tP -= eyeRay.direction * SURFACE_DISTANCE;\n\t\t\tconst float eps = 0.0005;\n\t\t\tsurfel.normal = normalize(\n\t\t\t\tvec3(distanceEstimate(lego, P + vec3(eps, 0.0, 0.0)),\n\t\t\t\t\t\tdistanceEstimate(lego, P + vec3(0.0, eps, 0.0)),\n\t\t\t\t\t\tdistanceEstimate(lego, P + vec3(0.0, 0.0, eps))) -\n\t\t\t\tvec3(distanceEstimate(lego, P)));\n\t\t\treturn true;\n\t\t} else if (t > maxDist) {\n\t\t\treturn false;\n\t\t}\n\t\tt += d;\n\t}\n\treturn false;\n}\n\n\n// Based on http://dl.acm.org/citation.cfm?id=1185834 and https://iquilezles.org/www/material/nvscene2008/rwwtt.pdf\nfloat ambientVisibility(vec3 P, vec3 n) {\n    const int   steps    = 3;\n    float a = 0.0;\n    float weight = 3.0;\n\n    for (int i = 1; i <= steps; ++i) {\n        float d = 0.25 * square((float(i) + 0.5) / (0.5 + float(steps)));\n        float r = distanceEstimate(lego, P + n * d);\n\n        a += weight * max(d - r, 0.0);\n        weight *= 0.5;\n    }\n    return clamp(square(1.0 - a), 0.4, 1.0);\n}\n\n\nmat3 lookAt(vec3 target, vec3 translation) {\n    vec3 z = normalize(translation - target);\n    vec3 up = normalize(vec3(0.0, 1.0, 0.0) + z * z.y);\n    vec3 x = normalize(cross(up, z));\n    return mat3(x, cross(z, x), z);\n}\n\n\nvec3 trace(Ray eyeRay) {\n\t// Directional light source\n    vec3     w_i     = normalize(vec3(1, 1, 1));\n\tvec3\t B_i     = vec3(2.0); \n\t\n\t// Outgoing light\n\tvec3 L_o;\n\t\n\tSurfel surfel;\t\n\tsurfel.material.glossy         = 0.1;\n\tsurfel.material.glossyExponent = 500.0;\n\t\n\tfloat maxDist = 1e30;\t\n\t\t\n\tif (intersectScene(eyeRay, maxDist, surfel)) {\n\t\tvec3 vox = floor((surfel.position - TILE / 2.0) / TILE);\n\t\tsurfel.material.lambertian = square(1.25 * texture(iChannel2, (vox.xz + vox.y * 3.0) / 64.0).rgb);\n\t\t// Mirror reflection vector\n\t\tvec3 w_m = -reflect(-eyeRay.direction, surfel.normal);\n\t\t\n\t\t// Integrate over the hemisphere, so there is no factor of 1/pi\n\t\tL_o = texture(irradianceMap, surfel.normal).rgb * surfel.material.lambertian;\n\n\t\t// Glossy environment reflection\n\t\tL_o += texture(irradianceMap, w_m).rgb * surfel.material.glossy;\n\t\t\t\t\t\n\t\tL_o *= ambientVisibility(surfel.position, surfel.normal);\n\t\t\n\t\t// Cast a shadow ray\n\t\tSurfel shadowSurfel;\n\t\tRay shadowRay;\n\t\tshadowRay.direction = w_i;\n\t\tshadowRay.origin = surfel.position + surfel.normal * rayBumpEpsilon;\n\t\tfloat shadowDist = TILE / 2.0;\n\t\tif ((dot(surfel.normal, w_i) > 0.0) && ! intersectScene(shadowRay, shadowDist, shadowSurfel)) {\n\t\t\tvec3 w_o = -eyeRay.direction;\n\t\t\tvec3 w_h = normalize(w_i + w_o);\n\t\t\t\n\t\t\t// Compute the light contribution from the directional source\n\t\t\tL_o += max(0.0, dot(surfel.normal, w_i)) * B_i * \n\t\t\t\t(surfel.material.lambertian / pi + \n\t\t\t\t pow(max(0.0, dot(surfel.normal, w_h)), surfel.material.glossyExponent) * surfel.material.glossy * (surfel.material.glossyExponent + 8.0) / (8.0 * pi));\n\t\t}\n\t} else {\n\t\t// Hit the skybox\n\t\tL_o = texture(radianceMap, eyeRay.direction).rgb;\n\t}\n\t\n\treturn L_o;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tRay eyeRay;\n\teyeRay.origin = vec3((iMouse.xy - iResolution.xy / 2.0 + vec2(sin(iTime * 0.7), cos(iTime * 0.25)) * 150.0) * 10.0 / max(iResolution.x, iResolution.y) + vec2(0.0, 4.0), 10.0);\n\tmat3 M = lookAt(vec3(0.0), eyeRay.origin);\n\teyeRay.direction = M * normalize(vec3(fragCoord.xy - iResolution.xy / 2.0, iResolution.y / ( -2.0 * tan(verticalFieldOfView / 2.0))));\n\t\n\tfragColor.xyz = sqrt(trace(eyeRay));\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Xdl3Dj","date":"1379649244","viewed":1562,"name":"Legos","username":"morgan3d","description":"A Lego brick. There are actually at least four slightly different Lego bottom designs. This is the one from my youth. ","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","lego"],"hasliked":0,"parentid":"","parentname":""}}