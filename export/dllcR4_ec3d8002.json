{"ver":"0.1","info":{"id":"dllcR4","date":"1690478294","viewed":16,"name":"Volumetric Cloud Layered ","username":"DenZ33","description":"The goal: make realistic volume rendering (like blender Cycles) but on GPU shader, and make it faster\nFeature: volumetric light dispersion\n\nNot finished / dirty code\n\ndrag mouse to change point of view (on next render pass)\n","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["clouds","volumetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 ACES(vec3 x) {\n  const float a = 2.51;\n  const float b = 0.03;\n  const float c = 2.43;\n  const float d = 0.59;\n  const float e = 0.14;\n  return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    if(getDiscard(iFrame, renderMaxSteps)){\n        discard;\n    }\n    // Time varying pixel color\n    vec4 td = texture(iChannel0, uv);\n    \n    vec3 col = td.rgb;\n    \n    col = mix(color_ambient, col,td.a);\n\n    //vec3 colexp = pow((1.0-exp(-col)), vec3(1.0));\n    //vec3 colpow = vec3(1)*pow(col, vec3(1.0));\n    //col = mix(colexp,colpow, 0.0);\n    col = ACES(col);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define M1 1597334677U     //1719413*929\n#define M2 3812015801U     //140473*2467*11\n\n// https://www.shadertoy.com/view/MdcfDj\n\nfloat fastHash( uvec2 q )\n{\n    q *= uvec2(M1, M2); \n    uint n = (q.x ^ q.y) * M1;\n    return float(n) * (1.0/float(0xffffffffU));\n}\n\n\n\nvec3 jitter1(vec3 d, vec2 sd, float k){\n    float rx = hash12(sd*1.)-0.5;\n    float ry = hash12(sd*2.)-0.5;\n    float rz = hash12(sd*3.)-0.5;\n    vec3 rndvec = (vec3(rx,ry,rz));\n    return mix(d, (rndvec), k);\n}\n\nvec3 jitter2(vec3 d, uvec2 sd, float k){\n    float rx = fastHash(sd*2U)-0.5;\n    float ry = fastHash(sd*3U)-0.5;\n    float rz = fastHash(sd*4U)-0.5;\n    vec3 rndvec = (vec3(rx,ry,rz));\n    return mix(d, (rndvec), k);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(getDiscard(iFrame, renderMaxSteps)){\n        discard;\n    }\n\n    // Normalized pixel   coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    //vec4 cacc = texture(iChannel1, uv);\n//\n   // if(cacc.a < 1./64.){\n       // discard;\n   // }\n    \n    // Time varying pixel color\n    vec3 col = vec3(0);\n    \n    vec2 mousev = (iMouse.xy-iResolution.xy*0.5)*0.2;\n    \n    \n    vec3 rayDir = rayDirection(120.0, iResolution.xy, fragCoord);\n    //rayDir /= -rayDir.z;\n    \n    vec3 viewDir = vec3(0,0,-1);\n    rayDir = ( vec4(rayDir,1.0) * rotationX(-mousev.y*0.1) * rotationY(mousev.x*0.1) ).xyz;\n    viewDir = ( vec4(viewDir,1.0) * rotationX(-mousev.y*0.1) * rotationY(mousev.x*0.1) ).xyz;\n    \n    vec3 eye = vec3(0,0,0);\n    \n\n\n    const float numSamplesFloat = float(numSamples);\n\n    vec3 camPos = eye  - viewDir*4.5;\n\n    float rayDepth = getRayDepth(iFrame, renderMaxSteps, renderMaxDist) + renderOffset;\n\n\n    //float sTime = floor(iTime*0.25);\n    //vec3 lightPos = vec3(cos(sTime*3.)*0.3,0.1 + sin(sTime)*1.0 ,cos(sTime*3.)*0.3);\n    //vec3 lightPos = vec3(0.0 ,0.1 + sin(iTime)*1.0 ,0.0);\n    vec3 lightPos = vec3(0.0,1.2,0.);\n    \n    const float absorbFactor = K_Absorb;\n    const float outscatterFactor = K_Scatter; //dont touch\n      \n    vec3 ambient = color_ambient;\n    \n    vec4 flux = vec4(0.0);\n    \n\n\n    \n    float rTime = iTime*1.0;\n    \n    //DirectLoop\n    for(int i = 0; i < numSamples; i++){\n        vec3 sampleDir1 = rayDir;\n        vec3 samplePos1 = camPos + rayDir * rayDepth;\n    \n    \n      float dl = renderMaxDist / float(renderMaxSteps);\n      \n      float sd = sceneDensity(samplePos1, iChannel2) * K_Density;\n      \n      float lambertFactor0 = 1.0 - beersLambert(dl, sd);\n\n      //Jitter Loop\n        vec2 rnd0 = hash22(uv*1501.+rTime + float(i*19));      \n\n\n        const int jitterIters = jitterMaxSteps;\n        const float jitterItersInvFloat = 8. / float(jitterIters);\n     \n\n        vec3 rayDirection = normalize(jitter1(rayDir, rnd0, 1.0));        \n        \n        //float jitterFactorL = pow(rnd0.y * rnd0.x, 1.) * jitterItersInvFloat * jitterMaxDistance;\n        float jitterFactorL = jitterItersInvFloat * jitterMaxDistance;\n        \n        float jitterIntegral0 = 0.0;\n        vec3  jitterIntegral1 = vec3(1.0);\n        \n        vec3 jitterK = vec3(1.0);\n        \n        \n        for(int i = 0; i < jitterIters; i++){\n            vec3 rnd = hash32(rnd0 + float(i*4129));\n            \n            \n            float dl = jitterFactorL * rnd.x * rnd.y * rnd.z; \n            \n            float sd2 = sceneDensity(samplePos1, iChannel2)*K_Density;\n            \n            float lambertFactor = beersLambert(dl, sd2);\n            \n            float scatterFactor = step(lambertFactor,rnd.z);\n            \n            rayDirection = normalize(jitter2(rayDirection, uvec2(rnd.xy), scatterFactor ));\n            \n            samplePos1 += rayDirection * dl;\n\n            \n            vec3 absorb = jitterK * (1.0 - lambertFactor);\n            jitterK += -absorb*absorbFactor;\n        }\n    \n      \n      // Light loop\n      \n      vec3 lightDir = (lightPos-samplePos1);\n      float lightInvLen = 1./length(lightDir);\n      lightDir = lightDir * lightInvLen;\n\n      \n      vec3 lightPower = min(pow(lightInvLen,2.0)*vec3(1,1,1)*4., 1000.0);\n\n      const int lightIters = lightMaxSteps;\n      const float lightItersInvFloat = 1. / float (lightIters);\n      vec3 lameInscatter = lightPower;\n      \n      \n      for(int j = 0; j < lightIters; j++){\n          int offset = lightIters - j;\n          \n          float dl = lightItersInvFloat / lightInvLen;\n          float dshift = float(offset)*dl;\n          \n          vec3 samplePos2 = samplePos1 + lightDir*dshift;\n          float sd2 = sceneDensity(samplePos2, iChannel2)*K_Density;\n          \n          vec3 absorb = lameInscatter * (1.0 - beersLambert(dl, sd2));\n          lameInscatter += 0.0 - absorb*(outscatterFactor*0. + absorbFactor);\n      }\n      \n      vec3 anisotropy = scatterAnisotropicShift(dot(rayDir, lightDir), 0.9);\n      lameInscatter *= anisotropy;\n      \n      // Ambient ray\n      \n      \n      const int ambientIters = ambientSteps;\n\n      vec3 ambientDir = normalize(jitter1(rayDir, rnd0, 1.0));\n      //vec3 texcub = texture(iChannel2, ambientDir).rgb;\n      vec3 lameAmbient = ambient;\n      \n      \n      for(int j = 0; j < ambientIters; j++){\n          int offset = ambientIters - j;\n          const float dl =  ambientMaxDistance / float(ambientIters);\n          float dshift = float(offset)*dl;\n          vec3 samplePos2 = samplePos1 + ambientDir*dshift;\n          float sd2 = sceneDensity(samplePos2, iChannel2)*K_Density;\n          \n          vec3 absorb = lameAmbient * (1.0 - beersLambert(dl, sd2));\n          lameAmbient += 0.0 - absorb*(outscatterFactor*0. + absorbFactor);\n      }\n      \n      \n      \n      //vec3 inscatter = (lameInscatter + lameAmbient) * jitterK * lambertFactor0;\n      vec3 inscatter = (lameInscatter + lameAmbient) * jitterK;\n      //vec3 outscatter = lumeInput * lambertFactor0;\n      \n      //float absorb = lumeInput * clamp(sd*dl*2. , 0.0, 1.0);\n      //lumeInput += inscatter - outscatter*outscatterFactor;\n      \n      //vec3 emmit = vec3(0.0) * lambertFactor0;\n      //vec3 absorb = lumeInput * lambertFactor0;\n      //lumeInput += emmit - absorb*absorbFactor;\n      flux += vec4(inscatter, lambertFactor0);\n    }\n    \n    flux /= numSamplesFloat;\n\n\n    // Output to screen\n    \n    \n    \n    fragColor = flux;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    const int depthFrames = renderMaxSteps;\n    \n    \n    if(getDiscard(iFrame, renderMaxSteps)){\n       // discard;\n    }\n    \n    int nFrame = iFrame % depthFrames;\n    \n    float clearCond = 1.0 - min(float(nFrame), 1.0);\n    const vec4 clearColor = vec4(color_ambient, 1.0);\n    \n\n    // Time varying pixel color\n    vec4 genColor = texture(iChannel0, uv);\n    vec4 curColor = texture(iChannel1, uv);\n    \n    float beersLambertFactor = genColor.a;\n    //float beersLambertFactor = curColor.a;\n    \n    vec3 flux = curColor.rgb;\n    \n    \n    vec3 inscatter = genColor.rgb * beersLambertFactor;\n    vec3 outscatter = flux * beersLambertFactor;\n\n    //flux += emmit + inscatter - outscatter - absorb;\n    flux += inscatter - outscatter;\n    \n    \n    vec3 emmit = vec3(0.0);\n    vec3 absorb = flux * beersLambertFactor * K_Absorb;\n    flux += emmit - absorb;\n   \n    vec4 finalColor = mix(vec4(flux, 1.0), clearColor, clearCond);\n    \n    \n    fragColor = finalColor;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"mat4 rotationX( in float angle ) {\n\treturn mat4(\t1.0,\t\t0,\t\t\t0,\t\t\t0,\n\t\t\t \t\t0, \tcos(angle),\t-sin(angle),\t\t0,\n\t\t\t\t\t0, \tsin(angle),\t cos(angle),\t\t0,\n\t\t\t\t\t0, \t\t\t0,\t\t\t  0, \t\t1);\n}\n\nmat4 rotationY( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t0,\t\tsin(angle),\t0,\n\t\t\t \t\t\t\t0,\t\t1.0,\t\t\t 0,\t0,\n\t\t\t\t\t-sin(angle),\t0,\t\tcos(angle),\t0,\n\t\t\t\t\t\t\t0, \t\t0,\t\t\t\t0,\t1);\n}\n\nmat4 rotationZ( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t-sin(angle),\t0,\t0,\n\t\t\t \t\tsin(angle),\t\tcos(angle),\t\t0,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t1,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t0,\t1);\n}\n\nfloat mapRangeClamp(float value, float min1, float max1, float min2, float max2) {\n  return min2 + clamp( (value - min1) / (max1 - min1), 0.0, 1.0) * (max2 - min2);\n  \n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\nvec3 hash33(vec3 p3){\n    p3 = fract(p3 * vec3(.1031,.11369,.13787));\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nfloat perlinNoise3D(vec3 p){\n    vec3 pi = floor(p);\n    vec3 pf = p - pi;\n\n    vec3 w = pf * pf * (3.0 - 2.0 * pf);\n\n    return \tmix(\n        mix(\n            mix(dot(pf - vec3(0, 0, 0), hash33(pi + vec3(0, 0, 0))), \n                dot(pf - vec3(1, 0, 0), hash33(pi + vec3(1, 0, 0))),\n                w.x),\n            mix(dot(pf - vec3(0, 0, 1), hash33(pi + vec3(0, 0, 1))), \n                dot(pf - vec3(1, 0, 1), hash33(pi + vec3(1, 0, 1))),\n                w.x),\n            w.z),\n        mix(\n            mix(dot(pf - vec3(0, 1, 0), hash33(pi + vec3(0, 1, 0))), \n                dot(pf - vec3(1, 1, 0), hash33(pi + vec3(1, 1, 0))),\n                w.x),\n            mix(dot(pf - vec3(0, 1, 1), hash33(pi + vec3(0, 1, 1))), \n                dot(pf - vec3(1, 1, 1), hash33(pi + vec3(1, 1, 1))),\n                w.x),\n            w.z),\n        w.y);\n}\n\nfloat checkSphere(vec3 pos, vec3 sphere, float radius){\n    vec3 delta = sphere - pos;\n    return 1.0 - step(radius, length(delta));\n}\n\nfloat checkBox(vec3 pos, vec3 box, float radius){\n    vec3 delta = abs(box - pos);\n    float len2 = max(max(delta.x,delta.y),delta.z);\n    return 1.- step(radius, len2);\n}\nfloat checkBox2(vec3 pos, vec3 box, float radius){\n    vec3 delta = abs(box - pos);\n    float len2 = max(max(delta.x,delta.y),delta.z);\n    return 1.- smoothstep(radius, radius*1.05 , len2);\n}\n\nfloat hash( ivec3 p )    // this hash is not production ready, please\n{                        // replace this by something better\n\n    // 3D -> 1D\n    int n = p.x*3 + p.y*113 + p.z*311;\n\n    // 1D hash by Hugo Elias\n\tn = (n << 13) ^ n;\n    n = n * (n * n * 15731 + 789221) + 1376312589;\n    return float( n & ivec3(0x0fffffff))/float(0x0fffffff);\n}\n\nfloat noise2( in vec3 x )\n{\n    ivec3 i = ivec3(floor(x));\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+ivec3(0,0,0)), \n                        hash(i+ivec3(1,0,0)),f.x),\n                   mix( hash(i+ivec3(0,1,0)), \n                        hash(i+ivec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+ivec3(0,0,1)), \n                        hash(i+ivec3(1,0,1)),f.x),\n                   mix( hash(i+ivec3(0,1,1)), \n                        hash(i+ivec3(1,1,1)),f.x),f.y),f.z);\n}\n\nconst mat3 mmm = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nfloat sceneDensity(vec3 pos, sampler3D iChannel1){\n    vec3 itemPos1 = vec3(0,0,0);\n    vec3 itemPos2 = vec3(0.5,0.5,0.5);\n    float s1 = checkBox(pos, itemPos1, 1.);\n    \n    //pos = mod(pos,0.99);\n    float s2 = checkSphere(pos, itemPos2, 0.4);\n    \n    \n    //return clamp(s2,0.0,1.0)*s1 + s1*0.25*0.5;\n    \n    //float d = textureLod(iChannel1, (pos+2.0)*0.125, 0.8).x;\n    \n        float f = 0.0;\n        \n        vec3 q = 0.02*pos+0.256;\n        \n        float k = 1.;\n        float oct = 2.01;\n        \n        \n        //f  = 0.5000*textureLod(iChannel1, q, 0.0).x; q = mmm*q*2.01;\n        //f += 0.2500*textureLod(iChannel1, q, 0.0).x; q = mmm*q*2.02;\n        //f += 0.1250*textureLod(iChannel1, q, 0.0).x; q = mmm*q*2.03;\n        //f += 0.0625*textureLod(iChannel1, q, 0.0).x; q = mmm*q*2.01;\n        \n        //f += 0.0312*textureLod(iChannel1, q, 0.0).x; q = mmm*q*2.04;\n        //f += 0.0156*textureLod(iChannel1, q, 0.0).x; q = mmm*q*2.05;\n        //f += 0.0078*textureLod(iChannel1, q, 0.0).x; q = mmm*q*2.01;\n        //f += 0.0040*textureLod(iChannel1, q, 0.0).x; q = mmm*q*2.02;\n        \n        const float persistence = 0.7;\n        float ks = 0.;\n        for(int i = 0; i < 8; i++){\n            f += k * textureLod(iChannel1, q, 0.0).x;\n            ks += k;\n            \n            q = mmm*q*oct;\n            \n            k *= persistence;\n        }\n        \n        \n        //float kg = persistence * (pow(persistence, 4.) - 1.0) / (persistence - 1.0);\n         \n       // f  = 0.5000*noise2(q); q = mmm*q*2.01;\n       // f += 0.2500*noise2(q); q = mmm*q*2.02;\n       // f += 0.1250*noise2(q); q = mmm*q*2.03;\n       // f += 0.0625*noise2(q); q = mmm*q*2.01;\n        //f += 0.0625*noise2(q)*0.5; q = mmm*q*2.05;\n        //f += 0.0625*noise2(q)*0.25; q = mmm*q*2.04;\n        \n    float d = f/ks;\n\n    return (mapRangeClamp(d, 0.5,0.75, 0.125*0.01,1.0) )*8.0 ;\n    //return (mapRangeClamp(d, 0.0,1.0, 0.125*0.005,1.0) )*8.0 ;\n    \n}\n\nfloat HenyeyGreenstein(float cos_theta, float g)\n{\n  return (1.0 - g * g) / pow(1.0 + g * g - 2.0 * g * cos_theta, 1.5) * 0.5f ;\n}\n\nfloat rainbow(float ct, float d){\n    //return exp(-pow(ct+d-0.5,2.0)*1000.);\n    return pow(smoothstep(0.3,0.5, ct+d) * smoothstep(0.55, 0.5, ct+d), 8.0);\n}\n\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 scatterAnisotropicShift(float vd, float d){\n    //vec3 sp1 = vec3(vd*0.33+0.33, dispersion, 1.0);\n    //return hsv2rgb(sp1);\n    d = 0.2;\n    float k0 = HenyeyGreenstein(vd, d);\n    float k1 = HenyeyGreenstein(vd, d*0.5);\n    float k2 = HenyeyGreenstein(vd, 0.);\n    float k3 = HenyeyGreenstein(vd, -d*0.5);\n    float k4 = HenyeyGreenstein(vd, -d);\n    \n    \n    vec3 c = vec3(k0, k2, k4);\n    vec3 c2 = vec3(k0+k1, k1 + k2 + k3, k3+k4)*vec3(0.5,0.33,0.5);\n    \n    \n    float rb0 = rainbow(vd, -0.02);\n    float rb1 = rainbow(vd, -0.01);\n    float rb2 = rainbow(vd, 0.0);\n    float rb3 = rainbow(vd, 0.01);\n    float rb4 = rainbow(vd, 0.02);\n    vec3 g2 = vec3(rb0+rb1, rb1 + rb2 + rb3, rb3+rb4)*vec3(0.5,0.33,0.5) + 1.0;\n    return c2 * g2;\n}\n\n\nfloat beersLambert(float len, float sigma){\n    return exp(-len*sigma);\n}\n\n\nfloat getRayDepth(int frame, int maxFrames, float maxDepth){\n    float fr = float(frame%maxFrames) / float(maxFrames);\n    return (1.-fr) * maxDepth;\n}\n\nbool getDiscard(int frame, int maxFrames){\n    return (frame%(maxFrames*2)) >= maxFrames;\n}\n\n\nconst float K_Absorb = 0.1;\nconst float K_Scatter = 1.0; //dont touch\nconst float K_Density = 32.; // Clouds density multiplier\n\nconst vec3 color_ambient = vec3(0.5,0.5,0.99);\nconst int renderMaxSteps = 256;\nconst float renderMaxDist = 6.;\n\nconst float renderOffset = 1.0; //render offset from camera \n\nconst int numSamples = 4; // 1 min !!\n\nconst int lightMaxSteps = 64;\nconst int jitterMaxSteps = 8;  //0 - for disable random walk\nconst int ambientSteps = 16;  //Ambient Occlusion\n\nconst float jitterMaxDistance = 0.25; \nconst float ambientMaxDistance = 2.0; \n\n","name":"Common","description":"","type":"common"}]}