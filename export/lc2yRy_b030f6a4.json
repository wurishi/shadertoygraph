{"ver":"0.1","info":{"id":"lc2yRy","date":"1722543011","viewed":39,"name":"raymarching fractal spin","username":"shader_joyz","description":"raymarching fractal spin","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fractal","cube"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// the following code was inspired by a tutorial by\n// kishimisu on YouTube found here: https://www.youtube.com/watch?v=khblXafu7iA\n\nfloat sdSphere(in vec3 p, in float r) {\n   return length(p) - r;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0f)) + min(max(q.x, max(q.y, q.z)), 0.0f);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = max(k - abs(a-b), 0.0f) / k;\n    return min(a,b) - h*h*h*k*(1.0f/6.0f);\n}\n\nvec3 rot3D(vec3 p, vec3 axis, float angle) {\n    // Rodrigues' rotation formula\n    return mix(dot(axis, p) * axis, p, cos(angle)) + cross(axis, p) * sin(angle);\n}\n\nmat2 rot2D(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return mat2(c, -s, s, c);\n}\n\nfloat map(vec3 p) {\n    vec3 q = p;\n    // move the cubes towards you in the z direction over time\n    q.z += .2* iTime;\n    //q = fract(q) - 0.5f;\n    q.xy = fract(q.xy) - 0.5f;\n    q.z = mod(q.z, 0.25f * (abs(sin(iTime * 0.2)) + 0.5f)) - (0.25f * (abs(sin(iTime * 0.2)) + 0.5f)) / 2.0f;\n    q.xy *= rot2D(iTime * 0.005f * p.z);\n    q.yz *= rot2D(-iTime*2.0f);\n    \n    // render box\n    float box = sdBox(q, vec3(0.1f));\n    \n    return box;\n}\n\n// kishimisu's palette function with a differing palatte\nvec3 palette(in float t) {\n    // weight towards one particular color\n    vec3 a = vec3(0.5, 0.5, 0.7);\n    // add to reach a max of 1, 1, 1\n    vec3 b = vec3(1.0f) - a;\n    // tint\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    // color to blend, normalized to make adjustments easier\n    vec3 d = normalize(vec3(0.3, 0.1, 0.8));\n    return a + b * cos(6.21318f * (c * t + d));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord * 2.0f - iResolution.xy) /iResolution.y;\n    // get mouse coordinates in clip space\n    vec2 m =(iMouse.xy * 2.0f - iResolution.xy) / iResolution.y;\n    \n    vec3 ro = vec3(0, 0, -3);  // ray origin\n    vec3 rd = normalize(vec3(uv * 1.5, 1));  // ray direction\n    vec3 color = vec3(0);\n    \n    float t = 0.; // distance traveled\n    \n    // extract iteration count\n    int i;\n    // begin raymarching\n    for (i = 0; i < 120; i++) {\n        vec3 p = ro + rd * t; // calculate the position of the current ray\n        // distort the rays to create an interesting effect\n        p.x += sin(t)*0.3f;\n        p.y += cos(t + iTime*0.1f)*0.3f;\n        float d = map(p); // current distance to the scene\n        t += d; // move the ray forwards by d, which is the minimum distance needed to hit an object\n        \n        if (d < 0.001 || t > 100.0) break; // early exit if rays miss the object\n    }\n    \n    color = palette(t*0.02f + float(i) * 0.008f);\n\n    fragColor = vec4(color, 1);\n}","name":"Image","description":"","type":"image"}]}