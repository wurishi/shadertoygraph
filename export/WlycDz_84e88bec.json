{"ver":"0.1","info":{"id":"WlycDz","date":"1610767208","viewed":268,"name":"[S1C005] Stairway to Heaven","username":"Kamoshika","description":"I made this as a Shader1weekCompo entry.\nhttp://www.shader1weekcompo.org/\n\nI also posted this on NEORT.\nhttps://neort.io/art/c00rj2k3p9f30ks58e50","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","cloud","staircase","stairs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define saturate(x) clamp(x, 0., 1.)\n\nconst float pi = acos(-1.);\n\nmat3 rotate3D(float angle, vec3 axis) {\n    vec3 n = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    return mat3(\n        n.x * n.x * r + c,\n        n.x * n.y * r - n.z * s,\n        n.z * n.x * r + n.y * s,\n        n.x * n.y * r + n.z * s,\n        n.y * n.y * r + c,\n        n.y * n.z * r - n.x * s,\n        n.z * n.x * r - n.y * s,\n        n.y * n.z * r + n.x * s,\n        n.z * n.z * r + c\n    );\n}\n\nfloat rand(float x) {\n    return fract(sin(x) * 43758.5453);\n}\n\nfloat noise(vec3 x) {\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f * f * (3.0 - 2.0 * f);\n\tvec3 b = vec3(173, 61, 3);\n\tfloat n = dot(p, b);\n\treturn mix(\tmix(\tmix(rand(n), rand(n+b.x), f.x),\n\t\t   \t\t\t\tmix(rand(n+b.y), rand(n+b.x+b.y), f.x),\n\t\t   \t\t\t\tf.y),\n\t\t  \t \tmix(\tmix(rand(n+b.z), rand(n+b.x+b.z), f.x),\n\t\t   \t\t\t\tmix(rand(n+b.y+b.z), rand(n+b.x+b.y+b.z), f.x),\n\t\t   \t\t\t\tf.y),\n\t\t  \t \tf.z);\n}\n\nfloat fbm(vec3 p) {\n    float s = 0.;\n    float a = 0.5;\n    for(int i=0; i<5; i++) {\n        s += a*noise(p);\n        a *= 0.5;\n        p *= 2.01;\n    }\n    return s;\n}\n\nfloat sampleDensity(vec3 p) {\n    float n = fbm(p*0.1)-0.5;\n    return saturate(n*17.5);\n}\n\nfloat distStairway(vec3 p) {\n    p.z = mod(p.z, sqrt(2.)) - sqrt(2.)/2.;\n    p.zx = abs(p.zx);\n    float d1 = dot(p, normalize(vec3(0, 1, 1))) - 0.5;\n    float d2 = dot(p, normalize(vec3(0, -1, -1))) - 0.5;\n    return max(p.x - 5., max(d1, d2));\n}\n\nvec4 genAmbientOcclusion(vec3 ro, vec3 rd) {\n    vec4 totao = vec4(0.);\n    float sca = 1.;\n    for(int aoi=0; aoi<10; aoi++) {\n        float hr = 0.01 + 0.02 *float(aoi*aoi);\n        vec3 aopos = ro + rd * hr;\n        float dd = distStairway(aopos);\n        float ao = saturate(hr-dd);\n        totao += ao * sca * vec4(1);\n        sca *= 0.75;\n    }\n    const float aoCoef = 0.5;\n    totao.w = 1.0 - saturate(aoCoef * totao.w);\n    return totao;\n}\n\nvec3 getStairwayNormal(vec3 p) {\n    vec3 normal = vec3(0, 1, 1);\n    if(p.x > 4.995) {\n        normal = vec3(1, 0, 0);\n    } else if(p.x < -4.995) {\n        normal = vec3(-1, 0, 0);\n    } else {\n        p.z = mod(p.z, sqrt(2.)) - sqrt(2.)/2.;\n        if(p.y > 0.) {\n            if(p.z > 0.) {\n                normal = vec3(0, 1, 1);\n            } else {\n                normal = vec3(0, 1, -1);\n            }\n        } else {\n            if(p.z > 0.) {\n                normal = vec3(0, -1, -1);\n            } else {\n                normal = vec3(0, -1, 1);\n            }\n        }\n    }\n    return normalize(normal);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (fragCoord * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    vec3 cPos = vec3(0, 16, 16);\n    cPos *= rotate3D(iTime*0.1+3.5, vec3(0, 1, -1));\n    vec3 cDir = normalize(-cPos);\n    cPos += vec3(0, 0, -1)*iTime*5.;\n    vec3 cUp = normalize(vec3(0, 1, -1));\n    vec3 cSide = normalize(cross(cDir, cUp));\n    \n    vec3 ray = normalize(p.x*cSide + p.y*cUp + cDir*2.5);\n    vec3 lightDir = normalize(vec3(3., 2., 0.4));\n    \n    // sky and sun\n    vec3 col = vec3(0.5, 0.6, 0.9)*0.1;\n    float s = max(dot(lightDir, ray), 0.);\n    col = mix(col, vec3(1), pow(s, 40.)*0.7);\n    \n    // stairway\n    vec3 rayPos = cPos;\n    float d = 0.;\n    for(int i=0; i<100; i++) {\n        d = distStairway(rayPos);\n        if(abs(d) < 0.0001 || length(rayPos-cPos) > 100.) {\n            break;\n        }\n        rayPos += ray * d;\n    }\n    if(abs(d) < 0.1) {\n        vec3 normal = getStairwayNormal(rayPos);\n        float diff = max(dot(lightDir, normal), 0.1);\n        vec4 ao = genAmbientOcclusion(rayPos, normal);\n        col = vec3(1. - ao.xyz * ao.w) * diff;\n    }\n    \n    // cloud\n    // Reference article(Japanese):\n    // https://qiita.com/aa_debdeb/items/eabc92aaee4ae226b4d5\n    float rayStepSize = 4.;\n    vec3 rayStep = ray * rayStepSize;\n    float shadowStepSize = 2.;\n    vec3 shadowStep = lightDir * shadowStepSize;\n    vec3 accum = vec3(0);\n    int maxItr = int(length(rayPos-cPos)/rayStepSize) + 1;\n    rayPos = cPos;\n    float T = 1.;\n    for(int i=0; i<20; i++) {\n        if(i >= maxItr) {\n            break;\n        }\n        float density = sampleDensity(rayPos);\n        if(density > 0.001) {\n            density = saturate(density * 0.1);\n            vec3 shadowPos = rayPos;\n            float shadowDensity = 0.;\n            for(int j=0; j<2; j++) {\n                shadowPos += shadowStep;\n                shadowDensity += sampleDensity(shadowPos);\n            }\n            vec3 ATT = exp(-shadowDensity * vec3(0.7, 0.8, 0.7) * 1.);\n            accum += vec3(1) * ATT * T * density;\n            T *= 1.-density;\n        }\n        if(T < 0.001) {\n            break;\n        }\n        rayPos += rayStep;\n    }\n    col += accum + T*col;\n    col = pow(col, vec3(1./2.2));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}