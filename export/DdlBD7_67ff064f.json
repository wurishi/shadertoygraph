{"ver":"0.1","info":{"id":"DdlBD7","date":"1688826197","viewed":27,"name":"raymarched rings/torii","username":"garrisonhh","description":"wanted to use this technique for a little web demo I'm working on, seems successful!","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"msXXD4","parentname":"figuring out raymarching"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// --- helpers ---\n\n// lograthmic-ish 1d transform (curve where 0 -> 0, 1 -> 1, 0.5 -> ~0.7)\nfloat transformLoggish(float v) {\n    return -pow(v, 2.) + 1.;\n}\n\n// --- world ---\nstruct Torus {\n    vec3 pos;\n    float radius;\n    float ringRadius;\n    vec3 color;\n};\n\n\nconst int TORUS_COUNT = 3;\nconst Torus[] TORII = Torus[TORUS_COUNT](\n    Torus(vec3(0.0, 0.0, 70.0), 10.0, 5.0, vec3(1.0, 0.0, 0.0)),\n    Torus(vec3(20.0, 0.0, 50.0), 10.0, 3.0, vec3(0.0, 1.0, 0.0)),\n    Torus(vec3(-10.0, 10.0, 60.0), 8.0, 1.0, vec3(0.0, 0.0, 1.0))\n);\n\n// --- raymarch impl ---\nconst int ITERATIONS = 100;\nconst float RENDER_DIST = 100.0;\nconst float HIT_EPSILON = 0.1;\n\nstruct HitResult {\n    bool hit;\n    vec3 color;\n    float travelDist;\n    float borderDist;\n};\n\n// signed distance to a torus\n// stealing from https://www.youtube.com/watch?v=Ff0jJyyiVyw&t=491s\nfloat sdTorus(Torus torus, vec3 pos) {\n    vec3 rel = pos - torus.pos;\n    float x = length(rel.xz) - torus.radius;\n    return length(vec2(x, rel.y)) - torus.ringRadius;\n}\n\nHitResult raymarch(vec3 pos, vec3 dir) {\n    float travelled = 0.0;\n    float minBorderDist = RENDER_DIST;\n\n    for (int i = 0; i < ITERATIONS; ++i) {\n        // find closest safe move distance\n        float closestDist = RENDER_DIST;\n        \n        for (int j = 0; j < TORUS_COUNT; ++j) {\n            Torus torus = TORII[j];\n            float signedDist = sdTorus(torus, pos);\n            \n            // check border\n            if (signedDist > 0. && signedDist < minBorderDist) {\n                minBorderDist = signedDist;\n            }\n\n            // test for hit\n            if (signedDist < HIT_EPSILON) {\n                return HitResult(true, torus.color, travelled, minBorderDist);\n            }\n\n            closestDist = min(signedDist, closestDist);\n        }\n        \n        // hit, iterate\n        pos += dir * closestDist;\n        travelled += closestDist;\n        \n        // check if outside of range\n        if (travelled > RENDER_DIST) {\n            break;\n        }\n    }\n\n    // no hit\n    return HitResult(false, vec3(0), travelled, minBorderDist);\n}\n\n// --- main ---\nconst float CAMERA_POV = 0.5;\nconst float CAMERA_DIST = 1.0 / tan(CAMERA_POV); // distance of camera to screen\nconst vec3 BACKGROUND_COLOR = vec3(0.2);\nconst float BORDER_VALUE = 0.5; // epsilon for drawing cell-shaded borders\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // calculate pixel coord scaled to [-1.0, 1.0] and adjusted to resolution\n    vec2 coord = (fragCoord / iResolution.xy) * 2.0 - vec2(1.0);\n    coord.y = -coord.y;\n    coord.y *= iResolution.y / iResolution.x;\n\n    // raymarch\n    vec3 pos = vec3(0, -30, 0);\n    vec3 dir = normalize(vec3(coord.x, coord.y + 1.0, CAMERA_DIST));\n    HitResult res = raymarch(pos, dir);\n    \n    // determine color\n    fragColor = vec4(BACKGROUND_COLOR, 1);\n    \n    if (res.hit) {\n        // draw color\n        float lum = 1.0 - (res.travelDist / RENDER_DIST);\n        lum = transformLoggish(lum);\n        fragColor.xyz = res.color * lum;\n    } else if (res.borderDist < BORDER_VALUE) {\n        // draw border\n        fragColor.xyz = vec3(0.);\n    }\n}","name":"Image","description":"","type":"image"}]}