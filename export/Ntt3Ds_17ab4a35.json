{"ver":"0.1","info":{"id":"Ntt3Ds","date":"1652490330","viewed":130,"name":"The method of steepest descent","username":"Vectornaut","description":"Steepest descent contours for exponential integrals. Click and drag over the display to change the direction. Notice that when a contour flips, its homology class changes by the classes of the neighboring contours.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["holomorphic"],"hasliked":0,"parentid":"WtdyzS","parentname":"Smooth contours"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//----------------------sRGB----------------------\n// from nmz's 3d color space visualization\n// https://www.shadertoy.com/view/XddGRN\n\n// map colors from RGB space to sRGB space. in RGB space, color value is\n// proportional to light intensity, so linear color-vector interpolation\n// corresponds to physical light mixing. in sRGB space, the color encoding\n// used by many monitors, we use more of the value interval to represent low\n// intensities, and less of the interval to represent high intensities. this\n// improves color quantization. see explore-lab/explore-lab-l.frag to learn more\n\nfloat sRGB(float t){ return mix(1.055*pow(t, 1./2.4) - 0.055, 12.92*t, step(t, 0.0031308)); }\nvec3 sRGB(in vec3 c) { return vec3 (sRGB(c.x), sRGB(c.y), sRGB(c.z)); }\n\n//----------------------CIE Lab----------------------\n// from nmz's 3d color space visualization\n// https://www.shadertoy.com/view/XddGRN\n\n// map colors from Lab space to RGB space. see explore-lab/explore-lab-l.frag\n// to learn more\n\nconst vec3 wref =  vec3(.95047, 1.0, 1.08883);\n\nfloat xyzR(float t){ return mix(t*t*t , 0.1284185*(t - 0.139731), step(t,0.20689655)); }\n\nvec3 lab2rgb(in vec3 c)\n{\n    float lg = 1./116.*(c.x + 16.);\n    vec3 xyz = vec3(wref.x*xyzR(lg + 0.002*c.y),\n                    wref.y*xyzR(lg),\n                    wref.z*xyzR(lg - 0.005*c.z));\n    vec3 rgb = xyz*mat3( 3.2406, -1.5372,-0.4986,\n                        -0.9689,  1.8758, 0.0415,\n                         0.0557, -0.2040, 1.0570);\n    return rgb;\n}\n\n// --- chromasphere ---\n// adapted from endolith's complex_colormap code\n// https://github.com/endolith/complex_colormap/tree/master/complex_colormap\n\n// endolith created this palette for phase plots of complex functions, like the\n// ones in this article. (the article uses a different palette---possibly based\n// on a CMYK color wheel?)\n// https://www.ams.org/notices/201106/rtx110600768p.pdf\n\n// at each lightness `l`, we want to use a constant-chroma color wheel with the\n// most saturated colors an RGB monitor can display. this function approximates\n// the radius of that color wheel using an efficient piecewise-linear formula\nfloat appx_chromawheel(in float l) {\n    if (l <= 0.0 || 100.0 <= l) return 0.0;\n    float lpts [5];\n    float cpts [5];\n    lpts[0] =   0.0; lpts[1] =   9.2; lpts[2] =  73.8; lpts[3] =  90.0; lpts[4] = 100.0;\n    cpts[0] =   0.0; cpts[1] =  10.8; cpts[2] =  39.9; cpts[3] =  12.5; cpts[4] =   0.0;\n    float lbot; float ltop;\n    float cbot; float ctop;\n    if      (l < lpts[1]) { lbot = lpts[0]; ltop = lpts[1]; cbot = cpts[0]; ctop = cpts[1]; }\n    else if (l < lpts[2]) { lbot = lpts[1]; ltop = lpts[2]; cbot = cpts[1]; ctop = cpts[2]; }\n    else if (l < lpts[3]) { lbot = lpts[2]; ltop = lpts[3]; cbot = cpts[2]; ctop = cpts[3]; }\n    else                  { lbot = lpts[3]; ltop = lpts[4]; cbot = cpts[3]; ctop = cpts[4]; }\n    float t = (l - lbot) / (ltop - lbot);\n    return (1.0-t)*cbot + t*ctop;\n}\n\n// --- automatic differentiation ---\n\n// a 1-jet of a map R^2 --> R^2, with image point `pt` and derivative `push`\nstruct jet2 {\n    vec2 pt;\n    mat2 push;\n};\n\n// a 1-jet of a map R^2 --> R, with image point `pt` and derivative `push`\nstruct jet21 {\n    float pt;\n    vec2 push;\n};\n\njet2 scale(float a, jet2 f) {\n    return jet2(a*f.pt, a*f.push);\n}\n\njet21 scale(float a, jet21 f) {\n    return jet21(a*f.pt, a*f.push);\n}\n\njet21 proj_x(jet2 f) {\n    return jet21(f.pt.x, transpose(f.push)[0]);\n}\n\njet21 proj_y(jet2 f) {\n    return jet21(f.pt.y, transpose(f.push)[1]);\n}\n\njet21 add(jet21 f, float c) {\n    return jet21(f.pt + c, f.push);\n}\n\njet21 dmod(jet21 t, float period) {\n    return jet21(mod(t.pt, period), t.push);\n}\n\n// --- complex arithmetic ---\n\nconst vec2 ONE = vec2(1., 0.);\n\n//  the complex conjugate of `z`\nvec2 conj(vec2 z) {\n    return vec2(z.x, -z.y);\n}\n\n// the sum of `z` and `w`\njet2 add(jet2 z, vec2 c) {\n    return jet2(z.pt + c, z.push);\n}\n\n// the sum of `z` and `w`\njet2 add(jet2 z, jet2 w) {\n    return jet2(z.pt + w.pt, z.push + w.push);\n}\n\n// multiplication by `z`\nmat2 mul(vec2 z) {\n    return mat2(z, conj(z).yx);\n}\n\n// the product of `z` and `w`\nvec2 mul(vec2 z, vec2 w) {\n    return mul(z) * w;\n}\n\njet2 mul(vec2 a, jet2 z) {\n    mat2 mul_a = mul(a);\n    mat2 mul_z = mul(z.pt);\n    return jet2(mul_a*z.pt, mul_a*z.push);\n}\n\njet2 mul(jet2 z, jet2 w) {\n    mat2 mul_z = mul(z.pt);\n    mat2 mul_w = mul(w.pt);\n    return jet2(mul_z*w.pt, mul_z*w.push + mul_w*z.push);\n}\n\n// the reciprocal of `z`\nvec2 rcp(vec2 z) {\n  // 1/z = z'/(z'*z) = z'/|z|^2\n  return conj(z) / dot(z, z);\n}\n\n// --- complex square root ---\n//\n// from the complex arithmetic code listing in Appendix C of _Numerical Recipes_\n//\n// William Press, Saul Teukolsky, William Vetterling, and Brian Flannery,\n// _Numerical Recipes in C_, 2nd edition. Cambridge University Press, 1992\n//\nvec2 csqrt(vec2 z) {\n    // sqrt(0) = 0\n    if (z.x == 0. && z.y == 0.) {\n        return vec2(0.);\n    }\n    \n    // calculate w\n    vec2 a = abs(z);\n    float w;\n    if (a.x >= a.y) {\n        float sl = a.y / a.x;\n        w = sqrt(a.x) * sqrt(0.5*(1. + sqrt(1. + sl*sl)));\n    } else {\n        float sl = a.x / a.y;\n        w = sqrt(a.y) * sqrt(0.5*(sl + sqrt(1. + sl*sl)));\n    }\n    \n    // construct output\n    if (z.x >= 0.) {\n        return vec2(w, z.y / (2.*w));\n    } else if (z.y >= 0.) {\n        return vec2(z.y/(2.*w), w);\n    } else {\n        return -vec2(z.y/(2.*w), w);\n    }\n}\n\njet2 csqrt(jet2 z) {\n    vec2 out_pt = csqrt(z.pt);\n    return jet2(out_pt, mul(0.5*rcp(out_pt))*z.push);\n}\n\n// --- pixel sampling ---\n\nconst float A1 = 0.278393;\nconst float A2 = 0.230389;\nconst float A3 = 0.000972;\nconst float A4 = 0.078108;\n\n// Abramowitz and Stegun, equation 7.1.27\nfloat erfc_appx(float t) {\n  float r = abs(t);\n  float p = 1. + A1*(r + A2*(r + A3*(r + A4*r)));\n  float p_sq = p*p;\n  float erfc_r = 1. / (p_sq*p_sq);\n  return t < 0. ? (2. - erfc_r) : erfc_r;\n}\n\n// how much of a pixel's sampling distribution falls on the negative side of an\n// edge. `disp` is the pixel's displacement from the edge in pattern space\nfloat neg_part(float pattern_disp, float scaling, float r_px) {\n  // find the displacement to the edge in the screen tangent space\n  float screen_disp = pattern_disp / scaling;\n  \n  // integrate our pixel's sampling distribution on the screen tangent space to\n  // find out how much of the pixel falls on the negative side of the edge\n  return 0.5*erfc_appx(screen_disp / r_px);\n}\n\n// find the color of a pixel near an edge between two colored regions.\n// `neg` and `pos` are the colors on the negative and positive sides of the\n// edge. `disp` is the displacement from the edge\n\nfloat edge_mix(float neg, float pos, float pattern_disp, float scaling, float r_px) {\n  return mix(pos, neg, neg_part(pattern_disp, scaling, r_px));\n}\n\nvec3 edge_mix(vec3 neg, vec3 pos, float pattern_disp, float scaling, float r_px) {\n  return mix(pos, neg, neg_part(pattern_disp, scaling, r_px));\n}\n\n// how much of a pixel's sampling distribution falls on a thickened line.\n// `width` is the line thickness, in pixels. `pattern_disp` is the pixel's\n// displacement from the line in pattern space\nfloat line_part(float width, float pattern_disp, float scaling, float r_px) {\n  // find the displacement to the edge in the screen tangent space\n  float screen_disp = pattern_disp / scaling;\n  float screen_disp_px = screen_disp / r_px;\n  \n  // integrate our pixel's sampling distribution on the screen tangent space to\n  // find out how much of the pixel falls within `width/2` of the line\n  float lower = erfc_appx(screen_disp_px - 0.5*width);\n  float upper = erfc_appx(screen_disp_px + 0.5*width);\n  return 0.5*(lower - upper);\n}\n\nvec3 line_mix(vec3 stroke, vec3 bg, float width, float pattern_disp, float scaling, float r_px) {\n  return mix(bg, stroke, line_part(width, pattern_disp, scaling, r_px));\n}\n\n// --- thimble coloring ---\n\nconst int N = 4;\n\nconst float GRAT = 0.5;\n\nconst vec2 axis = 0.5*vec2(1., sqrt(3.));\n\n// paint check pattern, dark \"end zone\" near infinity, and grid lines\nvec3 surface_color(float end_zone, jet2 zeta, float r_px) {\n    jet21 y = proj_y(zeta);\n    float scaling = length(y.push);\n    \n    // paint the surface blue where exp(-f) is small and orange where it's large\n    float growth = edge_mix(0., 1., -zeta.pt.x + end_zone, scaling, r_px);\n    \n    // paint the surface light in upper half-plane and dark in the lower half-plane\n    float width = min(2., 0.05 / (scaling * r_px));\n    float shading = mix(0.59, 1., growth);\n    vec3 grid = lab2rgb(vec3(90., -4., -9.));\n    const float check = 0.92;\n    vec3 color = lab2rgb(vec3(edge_mix(shading*check*95., shading*95., y.pt, scaling, r_px), 0., 0.));\n    if (y.pt < -0.5*GRAT) {\n        color = line_mix(lab2rgb(vec3(shading*check*90., -4., -9.)), color, width, mod(y.pt - 0.5*GRAT, GRAT) - 0.5*GRAT, scaling, r_px);\n    } else if (0.5*GRAT < y.pt) {\n        color = line_mix(lab2rgb(vec3(shading*90., -4., -9.)), color, width, mod(y.pt - 0.5*GRAT, GRAT) - 0.5*GRAT, scaling, r_px);\n    }\n    return color;\n}\n\nvec3 thimble_color(vec2 crit_val, vec2 phase_rcp, vec3 pen_color, vec3 bg, jet2 zeta, float r_px) {\n    jet2 dis = mul(phase_rcp, add(zeta, -crit_val));\n    jet21 t = proj_x(csqrt(dis));\n    float width = max(6., 0.008*min(iResolution.x, iResolution.y));\n    return line_mix(pen_color, bg, width, t.pt, length(t.push), r_px);\n}\n\n// --- maps ---\n\njet2 chebyshev(jet2 z, int n) {\n    jet2 curr = z;\n    jet2 prev = jet2(ONE, mat2(0.));\n    for (int k = 1; k < n; k++) {\n        jet2 temp = curr;\n        curr = add(mul(scale(2., z), curr), scale(-1., prev));\n        prev = temp;\n    }\n    return curr;\n}\n\njet2 dcosh(jet2 z) {\n    vec2 cs_x = vec2(cosh(z.pt.x), sinh(z.pt.x));\n    vec2 cs_y = vec2(cos(z.pt.y), sin(z.pt.y));\n    vec2 cosh_z = vec2(cs_x.x * cs_y.x, cs_x.y * cs_y.y);\n    vec2 sinh_z = vec2(cs_x.y * cs_y.x, cs_x.x * cs_y.y);\n    return jet2(cosh_z, mul(sinh_z) * z.push);\n}\n\njet2 alg_cosh(jet2 z) {\n    vec2 pt = z.pt;\n    return scale(0.5, jet2(\n        pt + rcp(pt),\n        mat2(1.) - mul(rcp(mul(pt, pt)))\n    ));\n}\n\n// (n-1)^(n-1)*z^n - n*z\njet2 critigon(jet2 z, int n) {\n    jet2 lead = z;\n    for (int k = 0; k < n-2; k++) {\n        lead = mul(z, lead);\n    }\n    float nf = float(n);\n    return mul(z, add(scale(pow(nf-1., nf-1.), lead), -nf*ONE));\n}\n\n// --- root finding ---\n\nvec2 newton_step(jet21 f) {\n    return (-f.pt / dot(f.push, f.push)) * f.push;\n}\n\nconst int CHEBYSHEV = 0;\nconst int CRITIGON = 1;\n\nvec2 horizontal_flow(\n    vec2 start_pt,\n    vec2 target_val,\n    vec2 phase_rcp,\n    int fn_name,\n    int fn_index,\n    float speed,\n    float tol,\n    int step_max\n) {\n    jet2 u = jet2(start_pt, mat2(1.));\n    for (int step_cnt = 0; step_cnt < step_max; step_cnt++) {\n        // evaluate the map\n        jet2 zeta;\n        if (fn_name == CHEBYSHEV) zeta = scale(-1., chebyshev(u, fn_index));\n        else zeta = scale(-1., critigon(u, fn_index));\n        \n        // find the horizontal displacement to the target critical value. if\n        // we're close enough, stop. if not, step closer\n        jet21 dis_h = proj_x(mul(phase_rcp, add(zeta, -target_val)));\n        if (abs(dis_h.pt) < tol) {\n            break;\n        } else {\n            u = add(u, speed * newton_step(dis_h));\n        }\n    }\n    return u.pt;\n}\n\n// --- thimble plots ---\n\nconst float PI = 3.141592653589793;\n\nconst vec3 blue_lab = vec3(62., -15., -38.);\nconst vec3 aqua_lab = vec3(40., 30., -71.);\n\nvec3 airy_lucas_plot(int n, vec2 phase_rcp, float view, vec2 fragCoord) {\n    // find screen point\n    float small_dim = min(iResolution.x, iResolution.y);\n    float r_px = view / small_dim; // the inner radius of a pixel in the Euclidean metric of the screen\n    jet2 u = jet2(r_px * (2.*fragCoord - iResolution.xy), mat2(1.));\n    \n    // color surface\n    jet2 zeta = scale(-1., chebyshev(u, n));\n    vec3 color = surface_color(0.75*pow(1.5, float(n)), zeta, r_px);\n    \n    // color thimbles over 1\n    /*color = thimble_color(ONE, phase_rcp, lab2rgb(blue_lab), color, zeta, r_px);*/\n    float penultimate = cos(PI/float(n));\n    vec2 flowed = horizontal_flow(u.pt, ONE, phase_rcp, CHEBYSHEV, n, 0.1, 0.01, 40);\n    if (-penultimate < flowed.x || n % 2 == 0) {\n        /*color = mix(color, lab2rgb(blue_lab), 0.8);*/\n        color = thimble_color(ONE, phase_rcp, lab2rgb(blue_lab), color, zeta, r_px);\n    }\n    \n    // color thimbles over -1\n    /*color = thimble_color(-ONE, phase_rcp, lab2rgb(aqua_lab), color, zeta, r_px);*/\n    flowed = horizontal_flow(u.pt, -ONE, phase_rcp, CHEBYSHEV, n, 0.1, 0.01, 40);\n    if ((-penultimate < flowed.x || n % 2 == 1) && flowed.x < penultimate) {\n        /*color = mix(color, lab2rgb(aqua_lab), 0.8);*/\n        color = thimble_color(-ONE, phase_rcp, lab2rgb(aqua_lab), color, zeta, r_px);\n    }\n    \n    return color;\n}\n\nvec3 bessel_zero_unrolled_plot(vec2 phase_rcp, float view, vec2 fragCoord) {\n    // find screen point\n    float small_dim = min(iResolution.x, iResolution.y);\n    float r_px = view / small_dim; // the inner radius of a pixel in the Euclidean metric of the screen\n    jet2 u = jet2(r_px * (2.*fragCoord - iResolution.xy), mat2(1.));\n    \n    // color surface\n    jet2 zeta = dcosh(u);\n    vec3 color = surface_color(535.5, zeta, r_px);\n    \n    // color thimbles\n    color = thimble_color( ONE, phase_rcp, lab2rgb(blue_lab), color, zeta, r_px);\n    color = thimble_color(-ONE, phase_rcp, lab2rgb(aqua_lab), color, zeta, r_px);\n    \n    return color;\n}\n\nvec3 bessel_zero_cylinder_plot(vec2 phase_rcp, float view, vec2 fragCoord) {\n    // find screen point\n    float small_dim = min(iResolution.x, iResolution.y);\n    float r_px = view / small_dim; // the inner radius of a pixel in the Euclidean metric of the screen\n    jet2 u = jet2(r_px * (2.*fragCoord - iResolution.xy), mat2(1.));\n    \n    // get pixel color\n    jet2 zeta = alg_cosh(u);\n    vec3 color = surface_color(1.1, zeta, r_px);\n    color = thimble_color( ONE, phase_rcp, lab2rgb(blue_lab), color, zeta, r_px);\n    color = thimble_color(-ONE, phase_rcp, lab2rgb(aqua_lab), color, zeta, r_px);\n    return color;\n}\n\nvec3 higher_airy_plot(int n, vec2 phase_rcp, float view, vec2 fragCoord) {\n    float crit_dens = 1. / float(n-1);\n    float crit_angle = 2.*PI*crit_dens;\n    vec2 root = vec2(cos(crit_angle), sin(crit_angle));\n    vec2 crit_pt_disp = crit_dens*(root - ONE);\n    float crit_pt_sep_sq = dot(crit_pt_disp, crit_pt_disp);\n    \n    // find screen point\n    float small_dim = min(iResolution.x, iResolution.y);\n    float r_px = view * crit_dens / small_dim; // the inner radius of a pixel in the Euclidean metric of the screen\n    jet2 u = jet2(r_px * (2.*fragCoord - iResolution.xy), mat2(1.));\n    \n    // get pixel color\n    jet2 zeta = scale(-1., critigon(u, n));\n    vec3 color = surface_color(2.53, zeta, r_px);\n    vec2 crit_val = (n % 2 == 0 ? 1. : -1.) * root;\n    for (int k = 0; k < n-1; k++) {\n        /*vec3 label = lab2rgb(vec3(49., 29.*crit_val));\n        color = thimble_color(crit_val, phase_rcp, label, color, zeta, r_px);*/\n        vec2 flowed = horizontal_flow(u.pt, crit_val, phase_rcp, CRITIGON, n, 0.1, 0.01, 40);\n        vec2 flow_disp = flowed - crit_dens*crit_val;\n        if (dot(flow_disp, flow_disp) < crit_pt_sep_sq) {\n            float lite = mix(65., 80., float(k)*crit_dens);\n            vec3 label = lab2rgb(vec3(lite, appx_chromawheel(lite)*crit_val));\n            color = thimble_color(crit_val, phase_rcp, label, color, zeta, r_px);\n            /*if (k == 0) color = mix(color, label, 0.8);*/\n        }\n        crit_val = mul(root, crit_val);\n    }\n    \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // try setting the first argument of chebyshev_plot to 1, 2, 3, 4, 5...\n    float angle = 4.*PI*(iMouse.x / iResolution.x + 1./3.);\n    vec2 phase_rcp = vec2(cos(-angle), sin(-angle));\n    vec3 color = airy_lucas_plot(5, phase_rcp, 0.8, fragCoord);\n    /*vec3 color = bessel_zero_unrolled_plot(phase_rcp, 2.75*PI, fragCoord);*/\n    /*vec3 color = bessel_zero_cylinder_plot(phase_rcp, 1.2, fragCoord);*/\n    /*vec3 color = higher_airy_plot(6, phase_rcp, 2., fragCoord);*/\n    fragColor = vec4(sRGB(color), 1.);\n}","name":"Image","description":"","type":"image"}]}