{"ver":"0.1","info":{"id":"mstSDB","date":"1680386332","viewed":98,"name":"SDF Collision Take 3","username":"mikolalysenko","description":"This has turned into a way more complex project than I would have liked.  V3 iteratively looks for the maximum value of the smoothed intersection of the SDFS using gradient descent + linear search, then pushes the shapes apart using their blended gradient","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["collision","sdf","intersection","separation","contact"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Contact detection code by Mikola Lysenko\n//\n//\n// Rendering code based on \"RayMarching starting point\" https://www.shadertoy.com/view/WtGXDD\n//      Martijn Steinrucken aka The Art of Code/BigWings - 2020\n\n\n#define CONTACT_ITERS 10\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define TAU 6.283185\n#define PI 3.141592\n\n// animation state\nfloat offset = 0.;\nbool hit = false;\nvec3 posA = vec3(0., 0., 0.);\nmat3 rotA = mat3(\n    1., 0., 0.,\n    0., 1., 0.,\n    0., 0., 1.);\n\nvec3 posB = vec3(0., 0., 0.);\nmat3 rotB = mat3(\n    1., 0., 0.,\n    0., 1., 0.,\n    0., 0., 1.);\nvec3 qA = vec3(0);\nvec3 qB = vec3(0);\nvec3 ab = vec3(0.);\n\nvec3 minHit = vec3(0.);\n\n\n// standard sdf stuff\nfloat sdSphere( vec3 p, vec3 c, float s ) {\n  return length(p - c)-s;\n}\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ) {\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\nfloat sdPlane (vec3 p) {\n    return p.y;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\n// shape signed distance functions\nfloat sdA (vec3 p) {\n    return sdBox(rotA * (p - posA), vec3(1.));\n    // return sdTorus(rotA * (p - posA), vec2(1.2, 0.35));\n    // return sdPlane(p + 0.5);\n}\nfloat sdB (vec3 p) {\n    return sdBox(rotB * (p - posB), vec3(1.));\n    // return sdTorus(rotB * (p - posB), vec2(1.2, 0.35));\n    // return sdSphere(p, posB, 0.3);\n}\n\n// gradients for shape sdfs\nvec3 gradA (vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = sdA(p) - \n        vec3(sdA(p-e.xyy), sdA(p-e.yxy),sdA(p-e.yyx));    \n    return normalize(n);\n}\nvec3 gradB (vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = sdB(p) - \n        vec3(sdB(p-e.xyy), sdB(p-e.yxy),sdB(p-e.yyx));    \n    return normalize(n);\n}\n\n// helper: project a point p along the direction n to the offset surface within a ball of radius r\nvec3 supA (vec3 n, vec3 p, float r, float offset) {\n    vec3 x = p + n * r;\n    float f = sdA(x) - offset;\n    vec3 df = gradA(x);\n    if (dot(df, n) < 0.) {\n        df = -df;\n    }\n    return x - min(abs(f), r) * df;\n}\nvec3 supB (vec3 n, vec3 p, float r, float offset) {\n    vec3 x = p + n * r;\n    float f = sdB(x) - offset;\n    vec3 df = gradB(x);\n    if (dot(df, n) < 0.) {\n        df = -df;\n    }\n    return x - min(abs(f), r) * df;\n}\n\n\n#define SMOOTH_K 20.\nfloat smoothedSDF (vec3 p, vec3 shift) {\n    return log(exp(SMOOTH_K * sdA(p)) + exp(SMOOTH_K * sdB(p + shift))) / SMOOTH_K;\n}\n\nvec3 smoothedGrad(vec3 p, vec3 k) {\n    vec2 d = vec2(0.001, 0.0);\n    return normalize(vec3(\n        smoothedSDF(p + d.xyy, k) - smoothedSDF(p - d.xyy, k),\n        smoothedSDF(p + d.yxy, k) - smoothedSDF(p - d.yxy, k),\n        smoothedSDF(p + d.yyx, k) - smoothedSDF(p - d.yyx, k)\n    ));\n}\n\nfloat intersectSDF (vec3 p, vec3 shift) {\n    return max(sdA(p), sdB(p + shift));\n}\n\nvec3 findMin(vec3 startPos, vec3 k) {\n    vec3 position = startPos;\n    vec3 minPos = position;\n    float minValue = smoothedSDF(position, k);\n    \n    float stepSize = 0.2;\n    float alpha = 0.5;\n    float beta = 0.9;\n\n    for (int i = 0; i < 10; ++i) {\n        vec3 grad = smoothedGrad(position, k);\n        float currentValue = intersectSDF(position, k);\n        vec3 newPosition;\n        float newValue;\n        if (currentValue > 0.) {\n            newPosition = position - grad * (currentValue + 0.1);\n            newValue = intersectSDF(newPosition, k);\n        } else {\n            float stepSizeCandidate = stepSize;\n            newPosition = position - stepSizeCandidate * grad;\n            newValue = intersectSDF(newPosition, k);\n            for (int lineSearchIter = 0; lineSearchIter < 10; ++lineSearchIter) {\n                if (newValue <= currentValue - alpha * stepSizeCandidate * dot(grad, grad)) {\n                    break;\n                }\n                stepSizeCandidate *= beta;\n                newPosition = position - stepSizeCandidate * grad;\n                newValue = intersectSDF(newPosition, k);\n            }\n        }\n        position = newPosition;\n        if (newValue < minValue) {\n            minPos = position;\n            minValue = newValue;\n        }\n    }\n    \n    return minPos;\n}\n\n\n//\n// begin actually interesting code\n//\nvoid solveContact () {\n    vec3 shift = vec3(0., 0, 0.);\n    \n    minHit = 0.5 * (posA + posB);\n\n    for (int outerIter = 0; outerIter < 5; ++outerIter) {\n        minHit = findMin(minHit, shift);\n        \n        float fa = sdA(minHit);\n        float fb = sdB(minHit + shift);\n        \n        float rad = max(fa, fb);\n        if (rad > 0.) {\n            break;\n        }\n        \n        hit = true;\n        vec3 d = normalize(fa * gradA(minHit) - fb * gradB(minHit + shift));\n        \n        shift -= 2. * rad * d;\n   }\n   \n   qA = minHit - 0.5 * shift;\n   qB = minHit + 0.5 * shift;\n   \n   ab = shift;\n}\n//\n// end actually interesting code\n//\n\n\n// standard rendering stuff.  do 3 passes for each of the transparent layers, whatever.\nfloat GetDistSolid(vec3 p) {\n    float d = 10000.;\n    d = min(d, sdSphere(p, qA, 0.05));\n    d = min(d, sdSphere(p, qB, 0.005));\n    d = min(d, sdCapsule(p, qA, qB, 0.005));\n    d = min(d, sdSphere(p, minHit, 0.07));\n    return d;\n}\nfloat RayMarchSolid(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDistSolid(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\nvec3 GetNormalSolid(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = GetDistSolid(p) - \n        vec3(GetDistSolid(p-e.xyy), GetDistSolid(p-e.yxy),GetDistSolid(p-e.yyx));    \n    return normalize(n);\n}\n\nfloat GetDistAlphaC(vec3 p) {\n    return smoothedSDF (p, ab);\n}\nfloat RayMarchAlphaC(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDistAlphaC(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\nvec3 GetNormalAlphaC(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = GetDistAlphaC(p) - \n        vec3(GetDistAlphaC(p-e.xyy), GetDistAlphaC(p-e.yxy),GetDistAlphaC(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\nfloat GetDistAlpha(vec3 p) {\n    float d = min(sdA(p) - offset, sdB(p + ab) - offset);\n    return d;\n}\nfloat RayMarchAlpha(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDistAlpha(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\nvec3 GetNormalAlpha(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = GetDistAlpha(p) - \n        vec3(GetDistAlpha(p-e.xyy), GetDistAlpha(p-e.yxy),GetDistAlpha(p-e.yyx));\n    \n    return normalize(n);\n}\n\n// camera\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // update animation\n    float tt = 0.1 * iTime;\n    posB = vec3(3. * cos(tt), sin(3.3 * tt), 0.);\n    mat2 rr = Rot(tt * 0.5);\n    rotB = mat3(\n        rr[0].x, rr[0].y, 0.,\n        rr[1].x, rr[1].y, 0.,\n        0., 0., 1.);\n    mat2 qq = Rot(tt * 0.311);\n    rotB = rotB * mat3(\n        qq[0].x, 0., qq[0].y,\n        0., 1., 0.,\n        qq[1].x, 0., qq[1].y);\n\n    // solve for intersections\n    solveContact();\n    \n    // do the usual rendering stuff\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 3, -3);\n    ro.yz *= Rot(-m.y*PI+1.);\n    ro.xz *= Rot(-m.x*TAU);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    vec3 col = vec3(0);\n    \n    float dSolid = RayMarchSolid(ro, rd);\n    if (dSolid < MAX_DIST) {\n        col = vec3(2., 0., 0.);\n    } else {\n        dSolid = MAX_DIST;\n    }\n    float dAlpha0 = RayMarchAlphaC(ro, rd);\n    if(dAlpha0<dSolid) {\n        vec3 p = ro + rd * dAlpha0;\n        vec3 n = GetNormalAlphaC(p);\n        vec3 r = reflect(rd, n);\n\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        \n        if (hit) {\n            col = mix(col, dif * vec3(1., 0.5, 0.2), 0.4);\n        } else {\n            col = mix(col, dif * vec3(0., 1., 1.), 0.3);\n        }\n    }\n    float dAlpha1 = RayMarchAlpha(ro, rd);\n    if(dAlpha1<dSolid) {\n        vec3 p = ro + rd * dAlpha1;\n        vec3 n = GetNormalAlpha(p);\n        vec3 r = reflect(rd, n);\n\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = mix(col, vec3(dif), 0.2);\n    }\n    \n    col = pow(col, vec3(.4545));\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}