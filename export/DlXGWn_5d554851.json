{"ver":"0.1","info":{"id":"DlXGWn","date":"1671558563","viewed":92,"name":"cardsAnim","username":"karanbpathak","description":"card anim","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["card","trapezium3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// inspired by : https://iquilezles.org/articles/distfunctions/\n\n// Rotation matrix around the X axis.\n// inspired by https://inspirnathan.com/posts/54-shadertoy-tutorial-part-8/\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n// Identity matrix.\nmat3 iy() {\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n\nfloat dot2(in vec2 v ) { return dot(v,v); }\n\nfloat dot3(in vec3 v ) { return dot(v,v); }\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n// trapezoid / capped cone, specialized for Y alignment\nfloat sdTrapezoid( in vec3 p, in float r1, float r2, float he, vec3 offset, mat3 transform)\n{\n    p = (p - offset) * transform;\n    float dp = 0.1;\n    float dp1 = dp;\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n\n\tp.x = abs(p.x);\n    p.z = abs(p.z);\n    vec3 ca = vec3(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he,max(0.0,p.z-dp1));\n    \n    vec3 cb = vec3(p.xy - k1 + k2*clamp( dot(k1-p.xy,k2)/dot2(k2), 0.0, 1.0 ),max(0.0,p.z-dp));\n    \n    float s = (cb.x < 0.0 && ca.y < 0.0 && cb.z < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(dot3(ca.xyz),dot3(cb.xyz)) );\n}\nfloat map(in vec3 p)\n{\n    float an = sin(iTime);\n    float r1 = 0.3*cos(an);\n    float r2 = 0.3*(an);\n    float he = p.y < 0.0 ? r1:r2;\n    float t = sdTrapezoid( p, r1, r2, he, vec3(-0.7,-0.3,0.0),iy());\n    t = min(t,sdTrapezoid( p, r1, r2, he, vec3(-1.,-0.3,0.0),iy()));\n    t = min(t,sdTrapezoid( p, r1, r2, he, vec3(-0.85,-0.03,0.0),iy()));\n    t = min(t,sdTrapezoid( p, r1, r2, he, vec3(-0.4,-0.3,0.0),iy()));\n    t = min(t,sdTrapezoid( p, r1, r2, he, vec3(-0.54,-0.03,0.0),iy()));\n    t = min(t,sdTrapezoid( p, r1, r2, he, vec3(-0.1,-0.3,0.0),iy()));\n    t = min(t,sdTrapezoid( p, r1, r2, he, vec3(-0.243,-0.03,0.0),iy()));\n    t = min(t,sdTrapezoid( p, r1, r2, he, vec3(-0.69,0.23,0.0),iy()));\n    t = min(t,sdTrapezoid( p, r1, r2, he, vec3(-0.39,0.23,0.0),iy()));\n    t = min(t,sdTrapezoid( p, r1, r2, he, vec3(-0.54,0.48,0.0),iy()));\n    \n    return t;\n}\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.15*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - occ*1.5, 0.0, 1.0 );\n}\n\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 3\n#endif\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.3*iTime;\n    float taa = smoothstep(0.1,0.001,1.0/an);\n\tvec3 ro = vec3( -.5, 0.2*cos(taa), -2.0 );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv =          ( cross(uu,ww));\n    \n    \n    // render\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 5.0;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            vec3 lig = normalize(vec3(0.6,0.2,0.4));\n            vec3 hal = normalize(lig-rd);\n            float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n            float occ = calcOcclusion( pos, nor );\n            if( dif>0.001 ) dif *= calcSoftshadow( pos, lig, 0.01, 1.0 );\n            float spe = pow(clamp(dot(nor,hal),0.0,1.0),16.0)*dif*(0.04+0.96*pow(clamp(1.0-dot(hal,-rd),0.0,1.0),5.0));\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col =  vec3(0.5,1.0,1.2)*amb*occ*pos.z;\n            col += vec3(2.8,2.2,1.8)*dif;\n            \n            col += (pos.z > 0.0 ? 0.05*smoothstep(0.1,0.001,spe):1.0-smoothstep(0.1,0.001,spe));\n            \n            col += vec3(2.8,2.2,1.8)*spe*3.0;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"}]}