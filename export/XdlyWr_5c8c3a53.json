{"ver":"0.1","info":{"id":"XdlyWr","date":"1487702981","viewed":1603,"name":"Test blobs","username":"BattleJohnFantastica","description":"Blobs","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["blobs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define time iTime\nfloat shade;\n\nfloat dist(vec2 x, vec3 y) {\n    float a = abs(sqrt(pow((x.x - y.x),2.0) + pow((x.y - y.y),2.0)));\n    return a;\n\n}\nvec3 position(vec3 deft, vec2 alternative, float speed){\n    float move = abs(sin(time * speed));\n    vec2 difference = deft.xy - alternative.xy;\n    vec2 factor = difference * vec2(move);\n    vec2 position = deft.xy - factor;\n    return vec3(position,deft.z);\n}\n\nfloat shader(vec3 point, vec2 uv, vec3 post) {\n    vec2 lightDist;\n\tlightDist.x = clamp(abs(point.x - post.x), 0.0, point.z);\n    lightDist.y = clamp(abs(point.y - post.y), 0.0, point.z) * -1.0;\n\tvec2 lightCentre = vec2(point.x,point.y)- vec2(lightDist.x, lightDist.y);\n   // lightCentre.x  = point.x - (point.z * 1.6); //this needs to be determined by the part of the shpere closest to the light\n    //lightCentre.y = point.y + (point.z * 1.6);\n    float diss = dist(lightCentre, vec3(uv, 1.0));\n    float percent = diss/ point.z;\n    float square = pow(percent,2.0);\n    float sha = ((sqrt(square))*-1.0)+1.0;\n\treturn sha;\n}\n\nvec4 layer1(vec2 uv, out float shade, vec3 post){\n    #define NUM 4\n    vec3 point[NUM];\n    point[0] = position(vec3(0.1,0.5,0.03),vec2(0.1, 0.1),0.5);\n    point[1] = position(vec3(0.3,0.5,0.05),vec2(0.3, 0.1),0.9);\n    point[2] = position(vec3(0.5,0.1,0.03),vec2(0.5, 0.5),3.14159);\n    point[3] = position(vec3(0.8,0.4,0.09),vec2(0.8, 0.1),0.5);\n    shade = 0.0;\n    vec4 color = vec4(uv,0.5+0.5*sin(iTime),1.0);\n        for(int i = 0; i < NUM; i++){\n            float borderSize = 1.02;\n            float fixedBorder = 0.002;\n            float totalRadius = point[i].z * borderSize;\n            float totalRadiusFixedBorder = point[i].z + fixedBorder;\n            float different = sqrt(pow((uv.x - point[i].x),2.0) + pow((uv.y - point[i].y),2.0));\n            vec4 main = vec4(1.0,1.0,1.0,1.0);\n            if(different < point[i].z){   \n            \tcolor = main;\n                shade = shader(point[i], uv, post);\n            } else if(different < totalRadiusFixedBorder) {\n                shade = shader(point[i], uv, post);\n            \tfloat radius = point[i].z;\n            \tvec4 diff = abs(vec4(uv,0.5+0.5*sin(iTime),1.0) -  main);\n                float a = dist(uv, point[i]) - point[i].z;\n            \tfloat b = a / (totalRadiusFixedBorder - point[i].z);\n            \tcolor = main - (diff *vec4(b));\n\n            }\n        }\n    return color;\n}\n\n\nvec4 layer2(vec4 x, vec2 y, vec3 post) {\n    float size = 0.3;\n    float total = size + 0.3;\n    vec4 bright = x + vec4(vec3(0.4), 1.0)  + vec4(vec3(shade),1.0);\n    vec4 dark = x - vec4(vec3(1.0), 1.0);\n    if (dist(y, post) <= size){   \n\t\treturn bright;\n    } else if (dist(y, post) <= total) {\n    \tfloat percent = (dist(y, post) - size) / (total - size);\n    \tvec3 difference = bright.xyz - dark.xyz;\n        vec3 color = bright.xyz - (difference * pow(percent, 1.4));\n        return vec4( color ,1.0);\n    } else {\n    \treturn dark;\n    }\n\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 post = vec3(0.2,0.5,1.0);//position(vec3(0.9, 0.9, 1.0), vec2(0.1, 0.1), 0.2);\n    vec2 uv = fragCoord.xy / iResolution.x;\n    fragColor = layer2(layer1(uv, shade, post), uv, post);\n}","name":"Image","description":"","type":"image"}]}