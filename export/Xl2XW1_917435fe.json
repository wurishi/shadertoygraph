{"ver":"0.1","info":{"id":"Xl2XW1","date":"1443356952","viewed":682,"name":"Raytracer PBR study","username":"valentingalea","description":"yet another raytracer","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raytrace","pbr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// ----------------------------------------------------------------------------\n// https://github.com/valentingalea/shaderbox\n// ----------------------------------------------------------------------------\n\n// GLSL/C++ compatibility layer\n#ifdef __cplusplus\n#define _in(T) const T &\n#define _inout(T) T &\n#define _out(T) T &\n#define _begin {\n#define _end }\n#else\n#define _in(T) const in T\n#define _inout(T) inout T\n#define _out(T) out T\n#define _begin (\n#define _end )\n#endif\n\n#define PI 3.14159265359\n\n// Shadertoy specific uniforms\n#define u_res iResolution\n#define u_time iTime\n#define u_mouse iMouse\n\nstruct ray_t {\n\tvec3 origin;\n\tvec3 direction;\n};\n#define BIAS 1e-4 // small offset to avoid self-intersections\n\nstruct hit_t {\n\tfloat t;\n\tint material_id;\n\tfloat material_param;\n\tvec3 normal;\n\tvec3 origin;\n};\n#define max_dist 1e8 // TODO: precision issues\nhit_t no_hit = hit_t _begin\n\t(max_dist + 1e1), -1, 1., vec3(0), vec3(0)\n_end;\n\n// camera system\nvec3 eye, look_at;\n\n// ----------------------------------------------------------------------------\n// Various 3D utilities functions\n// ----------------------------------------------------------------------------\n\nmat3 rotate_around_z(_in(float) angle_degrees)\n{\n\tfloat angle = radians(angle_degrees);\n\tfloat _sin = sin(angle);\n\tfloat _cos = cos(angle);\n\treturn mat3(_cos, -_sin, 0, _sin, _cos, 0, 0, 0, 1);\n}\n\nmat3 rotate_around_y(_in(float) angle_degrees)\n{\n\tfloat angle = radians(angle_degrees);\n\tfloat _sin = sin(angle);\n\tfloat _cos = cos(angle);\n\treturn mat3(_cos, 0, _sin, 0, 1, 0, -_sin, 0, _cos);\n}\n\nmat3 rotate_around_x(_in(float) angle_degrees)\n{\n\tfloat angle = radians(angle_degrees);\n\tfloat _sin = sin(angle);\n\tfloat _cos = cos(angle);\n\treturn mat3(1, 0, 0, 0, _cos, -_sin, 0, _sin, _cos);\n}\n\nvec3 corect_gamma(_in(vec3) color, _in(float) gamma)\n{\n\tfloat p = 1.0 / gamma;\n\treturn vec3(pow(color.r, p), pow(color.g, p), pow(color.b, p));\n}\n\n// ----------------------------------------------------------------------------\n// Optics related utility functions\n// ----------------------------------------------------------------------------\n\nfloat fresnel_factor( // using Schlickâ€™s approximation\n\t_in(float) n1,\n\t_in(float) n2,\n\t_in(float) VdotH // angle between View and half-dir between Light and View\n){  \n\tfloat Rn = (n1 - n2) / (n1 + n2);\n\tfloat R0 = Rn * Rn; // reflection coeff. for light incoming parallel to the normal\n\tfloat F = 1. - VdotH;\n\treturn R0 + (1. - R0) * (F * F * F * F * F);\n}\n\n// ----------------------------------------------------------------------------\n// Materials system definitions\n// ----------------------------------------------------------------------------\n\nstruct material_t {\n\tvec3 base_color;\n\tfloat metallic;\n\tfloat roughness;\n\tfloat ior; // index of refraction\n\tfloat reflectivity;\n\tfloat translucency;\n};\n\n#define num_materials 8\n#define mat_invalid -1\n#define mat_debug 0\nmaterial_t materials[num_materials];\n\nmaterial_t get_material(\n\t_in(int) index\n){\n\tmaterial_t mat;\n\n\tfor (int i = 0; i < num_materials; ++i) {\n\t\tif (i == index) {\n\t\t\tmat = materials[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn mat;\n}\n\n// ----------------------------------------------------------------------------\n// Lighting models\n// ----------------------------------------------------------------------------\n\n#define LIGHT_POINT 1\n#define LIGHT_DIR 2\n\nstruct light_t {\n\tint type;\n\tvec3 L; // origin for point lights, direction otherwise\n\tvec3 color;\n};\n\nlight_t lights[8];\n\nvec3 ambient_light = vec3(.01, .01, .01);\n\nvec3 get_light_direction(\n\t_in(light_t) light,\n\t_in(hit_t) point\n){\n\tif (light.type == LIGHT_DIR) {\n\t\treturn light.L;\n\t} else {\n\t\treturn normalize(light.L - point.origin);\n\t}\n}\n\n//     R       V    N    H      L         L dir to light       \n//      ^      ^    ^    ^     ^          V dir to eye\n//        .     \\   |   /    .            N normal\n//          .    \\  |  /   .              H half between L and V\n//            .   \\ | /  .                R reflected\n//  n1          .  \\|/ .                  O hit point             \n// -----------------O----------------     T refracted\n//  n2             .                      n1 index of refraction of outgoing medium\n//                .                       n2 index of refraction of incoming medium\n//               .\n//              .\n//             .\n//           \\/_ T\n//\n\nvec3 illum_blinn_phong(\n\t_in(vec3) V,\n\t_in(vec3) L,\n\t_in(hit_t) hit,\n\t_in(material_t) mat\n){\n\tvec3 diffuse = max(0., dot(L, hit.normal)) * (mat.base_color * hit.material_param);\n\n\tfloat spec_factor = 50.;\n#if 0 // Blinn specular\n\tvec3 H = normalize(L + V);\n\tvec3 specular = pow(max(0., dot(H, hit.normal)), spec_factor); // * light.color * specular color\n#else // Phong specular\n\tvec3 R = reflect(-L, hit.normal);\n\tvec3 specular = pow(max(0., dot(R, V)), spec_factor) * vec3(1); // * light.color * specular color\n#endif\n\n\treturn diffuse + specular;\n}\n\nvec3 illum_cook_torrance(\n\t_in(vec3) V,\n\t_in(vec3) L,\n\t_in(hit_t) hit,\n\t_in(material_t) mat\n){\n\tvec3 H = normalize(L + V);\n\tfloat NdotL = dot(hit.normal, L);\n\tfloat NdotH = dot(hit.normal, H);\n\tfloat NdotV = dot(hit.normal, V);\n\tfloat VdotH = dot(V, H);\n\n\t// geometric term\n\tfloat geo_a = (2. * NdotH * NdotV) / VdotH;\n\tfloat geo_b = (2. * NdotH * NdotL) / VdotH;\n\tfloat geo_term = min(1., min(geo_a, geo_b));\n\n\t// roughness term -using Beckmann Distribution\n\tfloat rough_sq = mat.roughness * mat.roughness;\n\tfloat rough_a = 1. / (rough_sq * NdotH * NdotH * NdotH * NdotH);\n\tfloat rough_exp = (NdotH * NdotH - 1.) / (rough_sq * NdotH * NdotH);\n\tfloat rough_term = rough_a * exp(rough_exp);\n\n\t// Fresnel term\n\tfloat fresnel_term = fresnel_factor(1., mat.ior, VdotH);\n\n\tfloat specular = (geo_term * rough_term * fresnel_term) / (PI * NdotV * NdotL);\n\treturn max(0., NdotL) * (specular + (mat.base_color * hit.material_param));\n}\n\n// ----------------------------------------------------------------------------\n// Analytical surface-ray intersection routines\n// ----------------------------------------------------------------------------\n\nstruct sphere_t {\n\tvec3 origin;\n\tfloat radius;\n\tint material;\n};\n\nstruct plane_t {\n\tvec3 direction;\n\tfloat distance;\n\tint material;\n};\n\nvoid intersect_sphere(\n\t_in(ray_t) ray,\n\t_in(sphere_t) sphere,\n\t_inout(hit_t) hit\n){\n\t// geometrical solution\n\t// info: http://www.scratchapixel.com/old/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-sphere-intersection/\n\tvec3 rc = sphere.origin - ray.origin;\n\tfloat radius2 = sphere.radius * sphere.radius;\n\tfloat tca = dot(rc, ray.direction);\n\tif (tca < 0.) return;\n\tfloat d2 = dot(rc, rc) - tca * tca;\n\tfloat thc = sqrt(radius2 - d2);\n\tfloat t0 = tca - thc;\n\tfloat t1 = tca + thc;\n\n\tif (t0 < hit.t) {\n\t\tvec3 impact = ray.origin + ray.direction * t0;\n\n\t\thit.t = t0;\n\t\thit.material_id = sphere.material;\n\t\thit.material_param = 1.;\n\t\thit.origin = impact;\n\t\thit.normal = (impact - sphere.origin) / sphere.radius;\n\t}\n}\n\n// Plane is define by normal N and distance to origin P0 (which is on the plane itself)\n// a plane eq is: (P - P0) dot N = 0\n// which means that any line on the plane is perpendicular to the plane normal\n// a ray eq: P = O + t*D\n// substitution and solving for t gives:\n// t = ((P0 - O) dot N) / (N dot D)\nvoid intersect_plane(\n\t_in(ray_t) ray,\n\t_in(plane_t) p,\n\t_inout(hit_t) hit\n){\n\tfloat denom = dot(p.direction, ray.direction);\n\tif (denom > 1e-6)\n\t{\n\t\tfloat t = dot(vec3(p.distance) - ray.origin, p.direction) / denom;\n\t\tif (t >= 0.0 && t < hit.t)\n\t\t{\n\t\t\tvec3 impact = ray.origin + ray.direction * t;\n\n\t\t\t// checkboard pattern\t\t\t\n\t\t\t//vec2 pattern = floor (impact.xz * 0.5);\n\t\t\t//float cb = mod (pattern.x + pattern.y, 2.0);\n\n\t\t\thit.t = t;\n\t\t\thit.material_id = p.material;\n\t\t\thit.material_param = 1.; // cb; // Disabled for now\n\t\t\thit.origin = impact;\n\t\t\thit.normal = faceforward(p.direction, ray.direction, p.direction);\n\t\t}\n\t}\n}\n\n// ----------------------------------------------------------------------------\n// Raytracer\n// ----------------------------------------------------------------------------\n\n#define num_planes 6\nplane_t planes[num_planes];\n\n#define num_spheres 3\nsphere_t spheres[num_spheres];\n\nvec3 background(_in(ray_t) ray)\n{\n\treturn vec3(0);\n}\n\n// ----------------------------------------------------------------------------\n// Cornell Box definition\n// http://www.graphics.cornell.edu/online/box/\n// ----------------------------------------------------------------------------\n\nvoid setup_cornell_box()\n{\n#define cb_mat_white 1\n#define cb_mat_red 2\n#define cb_mat_blue 3\n#define cb_mat_reflect 4\n#define cb_mat_refract 5\n#define cb_mat_green 6\n\tmaterials[cb_mat_white] = material_t _begin\n\t\tvec3(0.7913), .0, .5, 1., 0., 0.\n\t_end;\n\tmaterials[cb_mat_red] = material_t _begin\n\t\tvec3(0.6795, 0.0612, 0.0529),\n\t\t0., .5, 1., 0., 0.\n\t_end;\n\tmaterials[cb_mat_blue] = material_t _begin\n\t\tvec3(0.1878, 0.1274, 0.4287),\n\t\t0., .5, 1., 0., 0.\n\t_end;\n\tmaterials[cb_mat_reflect] = material_t _begin\n\t\tvec3(0.95, 0.64, 0.54),\n\t\t1., .1, 1.0, 1., 0.\n\t_end;\n\tmaterials[cb_mat_refract] = material_t _begin\n\t\tvec3(1., 0.77, 0.345),\n\t\t1., .05, 1.333, 1., 1.\n\t_end;\n\n#define cb_plane_ground 0\n#define cb_plane_behind 1\n#define cb_plane_front 2\n#define cb_plane_ceiling 3\n#define cb_plane_left 4\n#define cb_plane_right 5\n#define cb_plane_dist 2.\n\tplanes[cb_plane_ground] = plane_t _begin vec3(0, -1, 0), 0., cb_mat_white _end;\n\tplanes[cb_plane_ceiling] = plane_t _begin vec3(0, 1, 0), 2. * cb_plane_dist, cb_mat_white _end;\n\tplanes[cb_plane_behind] = plane_t _begin vec3(0, 0, -1), -cb_plane_dist, cb_mat_white _end;\n\tplanes[cb_plane_front] = plane_t _begin vec3(0, 0, 1), cb_plane_dist, cb_mat_white _end;\n\tplanes[cb_plane_left] = plane_t _begin vec3(1, 0, 0), cb_plane_dist, cb_mat_red _end;\n\tplanes[cb_plane_right] = plane_t _begin vec3(-1, 0, 0), -cb_plane_dist, cb_mat_blue _end;\n\n#define cb_sphere_light 0\n#define cb_sphere_left 1\n#define cb_sphere_right 2\n\tspheres[cb_sphere_light] = sphere_t _begin vec3(0, 2.5 * cb_plane_dist + 0.4, 0), 1.5, mat_debug _end;\n\tspheres[cb_sphere_left] = sphere_t _begin vec3(0.75, 1, -0.75), 0.75, cb_mat_reflect _end;\n\tspheres[cb_sphere_right] = sphere_t _begin vec3(-0.75, 0.75, 0.75), 0.75, cb_mat_refract _end;\n\n\tlights[0] = light_t _begin\n\t\tLIGHT_POINT,\n\t\tvec3(0, 2. * cb_plane_dist - 0.2, 0),\n\t\tvec3(1., 1., 1.)\n\t_end;\n}\n\nvoid setup_scene()\n{\n\tmaterials[mat_debug] = material_t _begin vec3(1., 1., 1.), 0., 0., 1., 0., 0. _end;\n\n\tsetup_cornell_box();\n\n#if 1\n\tfloat _sin = sin(u_time);\n\tfloat _cos = cos(u_time);\n\tspheres[cb_sphere_left].origin += vec3(0, abs(_sin), _cos + 1.);\n\tspheres[cb_sphere_right].origin.z = 0.;// += vec3(0, abs(_cos), _cos);\n\tlights[0].L.z = 1.5;\n#endif\n}\n\nvoid setup_camera(_inout(vec3) eye, _inout(vec3) look_at)\n{\n\tvec2 mouse = u_mouse.x < BIAS ? vec2(0) : 2. * (u_res.xy / u_mouse.xy) - 1.;\n\tmat3 rot_y = rotate_around_y(mouse.x * 30.);\n\teye = rot_y * vec3(0, cb_plane_dist, 2.333 * cb_plane_dist);\n\tlook_at = vec3(0, cb_plane_dist, 0);\n}\n\nvec3 illuminate(_in(hit_t) hit) // TODO: find a way to account for more light types\n{\n\tmaterial_t mat = get_material(hit.material_id);\n\n\t// special case for debug stuff - just solid paint it\n\tif (hit.material_id == mat_debug) {\n\t\treturn materials[mat_debug].base_color;\n\t}\n\n\tvec3 accum = ambient_light; // really cheap equivalent for indirect light\n\n\tvec3 V = normalize(eye - hit.origin); // view direction\n\tvec3 L = get_light_direction(lights[0], hit);\n\n\t// TODO: more lights\n#if 0\n\t\taccum += illum_blinn_phong(V, L, hit, mat);\n#else\n\t\taccum += illum_cook_torrance(V, L, hit, mat);\n#endif\n\n\treturn accum;\n}\n\nhit_t raytrace_iteration(_in(ray_t) ray, _in(int) mat_to_ignore)\n{\n\thit_t hit = no_hit;\n\n\tfor (int i = 0; i < num_planes; ++i) {\n\t\tintersect_plane(ray, planes[i], hit);\n\t}\n\n\tfor (int i = 0; i < num_spheres; ++i) {\n\t\tif (spheres[i].material != mat_to_ignore) {\n\t\t\tintersect_sphere(ray, spheres[i], hit);\n\t\t}\n\t}\n\n\treturn hit;\n}\n\nvec3 render(_in(ray_t) primary_ray)\n{\n\tvec3 color = vec3(0);\n\tvec3 accum = vec3(1);\n\tray_t ray = primary_ray;\n\n\tfor (int i = 0; i < 2; i++) {\n\t\thit_t hit = raytrace_iteration(ray, mat_invalid);\n\n\t\tif (hit.t >= max_dist) {\n\t\t\tcolor += accum * background(ray);\n\t\t\tbreak;\n\t\t}\n\n\t\tfloat f = fresnel_factor(1., 1., dot(hit.normal, -ray.direction));\n\t\tcolor += (1. - f) * accum * illuminate(hit);\n\n#if 1 // shadow ray\n\t\tif (i == 0) {\n\t\t\tvec3 shadow_line = lights[0].L - hit.origin; // TODO: more light types\n\t\t\tvec3 shadow_dir = normalize(shadow_line);\n\n\t\t\tray_t shadow_trace = ray_t _begin\n\t\t\t\thit.origin + shadow_dir * BIAS,\n\t\t\t\tshadow_dir\n\t\t\t\t_end;\n\t\t\thit_t shadow_hit = raytrace_iteration(shadow_trace, mat_debug);\n\n\t\t\tif (shadow_hit.t < length(shadow_line)) {\n\t\t\t\tcolor *= 0.1;\n\t\t\t}\n\t\t}\n#endif\n\n\t\tmaterial_t mat = get_material(hit.material_id);\n\t\tif (mat.reflectivity > 0.) {\n\t\t\taccum *= f;\n\t\t\tvec3 reflect_dir = normalize(reflect(hit.normal, ray.direction));\n\t\t\tray = ray_t _begin\n\t\t\t\thit.origin + reflect_dir * BIAS,\n\t\t\t\treflect_dir\n\t\t\t_end;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn color;\n}\n\n// ----------------------------------------------------------------------------\n// Main Rendering function\n// ----------------------------------------------------------------------------\n\nray_t get_primary_ray(\n\t_in(vec3) cam_local_point,\n\t_inout(vec3) cam_origin,\n\t_inout(vec3) cam_look_at\n){\n\tvec3 fwd = normalize(cam_look_at - cam_origin);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 right = cross(up, fwd);\n\tup = cross(fwd, right);\n\n\treturn ray_t _begin\n\t\tcam_origin,\n\t\tnormalize(fwd + up * cam_local_point.y + right * cam_local_point.x)\n\t_end;\n}\n\nvoid mainImage(\n\t_out(vec4) fragColor,\n\tvec2 fragCoord)\n{\n\t// The pipeline transform\n\t//\n\t// 1. fragCoord is in raster space [0..resolution]\n\t// 2. convert to NDC [0..1] by dividing to the resolution\n\t// 3. convert to camera space:\n\t//  a. xy gets [-1, +1] by 2 * NDC - 1; z fixed at -1\n\t//  c. apply aspect & fov\n\t//  d. apply the look-at algoritm which will\n\t//     produce the 3 camera axis:\n\t//\n\t//      R   ^ +Y                  ^ +Y             E eye/ray origin\n\t//       .  |\\                    |     . R        R primary ray\n\t//         .| \\                   |   .            @ fov angle\n\t//   -Z     | .\\   +Z             | .\n\t//    ------0---E--->   +X -------0-------> -X\n\t//          | @/                  |\n\t//          | /                   |\n\t//          |/                    | -Y\n\t//           -Y\n\t//\n\t// NOTE: everything is expressed in this space, NOT world\n\n\t// assuming screen width is larger than height \n\tvec2 aspect_ratio = vec2(u_res.x / u_res.y, 1);\n\t// field of view\n\tfloat fov = tan(radians(30.0));\n\n\t// antialising\n#if 0\n#define MSAA_PASSES 4\n\tfloat offset = 0.25;\n\tfloat ofst_x = offset * aspect_ratio.x;\n\tfloat ofst_y = offset;\n\tvec2 msaa[MSAA_PASSES];\n\tmsaa[0] = vec2(-ofst_x, -ofst_y);\n\tmsaa[1] = vec2(-ofst_x, +ofst_y);\n\tmsaa[2] = vec2(+ofst_x, -ofst_y);\n\tmsaa[3] = vec2(+ofst_x, +ofst_y);\n#else\n#define MSAA_PASSES 1\n\tvec2 msaa[MSAA_PASSES];\n\tmsaa[0] = vec2(0.5);\n#endif\n\n\tvec3 color = vec3(0);\n\n\tsetup_camera(eye, look_at);\n\n\tsetup_scene();\n\n\tfor (int i = 0; i < MSAA_PASSES; i++) {\n\t\tvec2 point_ndc = (fragCoord.xy + msaa[i]) / u_res.xy;\n\t\tvec3 point_cam = vec3(\n\t\t\t(2.0 * point_ndc - 1.0) * aspect_ratio * fov,\n\t\t\t-1.0);\n\n\t\tray_t ray = get_primary_ray(point_cam, eye, look_at);\n\n\t\tcolor += render(ray) / float(MSAA_PASSES);\n\t}\n\n\tfragColor = vec4(corect_gamma(color, 2.25), 1);\n}\n","name":"","description":"","type":"image"}]}