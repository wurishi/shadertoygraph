{"ver":"0.1","info":{"id":"ttfXD4","date":"1562886145","viewed":213,"name":"[TWITCH] Shader101 - Raymarching","username":"Flopine","description":"This is a shader I made during a live session on Twitch, about teaching people the basics of raymarching. You can watch them here: https://www.twitch.tv/flopine","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","course","twitch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n\n// This was a Twitch session where I gave people a course about the basics\n// of raymarching\n\n#define time iTime\nfloat iteration_number = 64.; \n\n// taken from YX here : https://www.shadertoy.com/view/tdlXW4\n// rough shadertoy approximation of the bonzomatic noise texture\nvec4 texNoise(vec2 uv)\n{\n    float f = 0.;\n    f += texture(iChannel0, uv*.125).r*.5;\n    f += texture(iChannel0, uv*.25).r*.25;\n    f += texture(iChannel0, uv*.5).r*.125;\n    f += texture(iChannel0, uv*1.).r*.125;\n    f=pow(f,1.2);\n    return vec4(f*.45+.05);\n}\n\nfloat hash (vec2 x)\n{return fract(sin(dot(x, vec2(22.45,16.451)))*1257.44);}\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\n// Just for fun!\n// analitycal description of sphere provided by xor0110\n// played with the sign in the return line to display hyperboloid\nfloat analitycal_sphere (vec3 p, float radius)\n{ \n    float lx = length(p.x);\n    float ly = length(p.y);\n    float lz = length(p.z);\n    return sqrt(lx*lx + ly*ly + lz*lz) - radius;  \n}\n\nfloat sphere (vec3 p, float radius)\n{ return length(p)-radius; }\n\nfloat cylinder (vec3 p, float radius, float height)\n{ return max(length(p.xy)-radius, abs(p.z)-height); }\n\nfloat unsigned_box (vec3 p, vec3 corner)\n{ \n    vec3 q = abs(p)-corner;\n    return length(max(q,0.)); \n}\n\nfloat signed_box (vec3 p, vec3 corner)\n{ \n    vec3 q = abs(p)-corner;\n    return  min(0.,max(q.x,max(q.y,q.z))) + length(max(q,0.)); \n}\n\n// Signed Distance Function or map\nfloat SDF (vec3 p)\n{\n    float room = -signed_box(p, vec3(6.,3.,6.));\n\n\t// period for the repetition of the space\n    float per = 2.;\n    // id of each repetition cells in the x and z axis\n    vec2 id_xz = floor(p.xz/per);\n    p.xz = mod(p.xz, per)-per*0.5;\n    // cylinders that cut holes in floor and ceiling\n    float c = cylinder(p.xzy, 0.4, 1e10);\n\n\t// use the texnoise texture (in Bonzomatic) instead of typing a random function\n    p.y += time*texNoise(id_xz*0.1).r;\n    p.y = mod(p.y,per)-per*0.5;\n    // sphere changing to cube\n    float s = mix(sphere(p, 0.3), signed_box(p, vec3(0.25)), sin(time)*0.5+.5);\n\n    p.xz = mod(p.xz, per)-per*0.5;\n    // columns\n    float c1 = cylinder(p.xzy, 0.15, 1e10);\n\n    // room + holes and columns\n    float d = min(c1, max(-c, room));\n    // adding moving spheres\n    d = min(d,s );\n    \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    float dither = hash(uv);\n\n    // ro\n    vec3 ray_origin = vec3(1.,0.,-4.); // step back\n    // rd\n    vec3 ray_direction = normalize(vec3(uv,1.)); //look forward\n    // p\n    vec3 position = ray_origin; // start from the origin\n\n    vec3 color = vec3(0.);\n\n    bool hit = false;\n\n    float shad = 0.;\n\n    for(float i=0.; i<iteration_number; ++i)\n    {\n        // d \n        float _distance = SDF(position);\n        \n        if (_distance < 0.01)\n        {\n            // store normaized iterations to colour shapes later\n            shad = i / iteration_number;\n            hit = true;\n            break;\n        }\n        \n        // replace banding by nice noise render\n        _distance *= 0.9 + dither*0.1;\n        \n        position += _distance*ray_direction;\n    }\n\n    if (hit) color = vec3(1.-shad); \n\n    //fragColor = vec4(color.r, color.g, color.b, 1.);\n    fragColor = vec4(color,1.);\n}","name":"Image","description":"","type":"image"}]}