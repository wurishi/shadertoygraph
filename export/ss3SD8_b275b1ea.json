{"ver":"0.1","info":{"id":"ss3SD8","date":"1633018431","viewed":16772,"name":"20210930_CLUB-CAVE-09","username":"0b5vr","description":"Live coding sesh @ CLUB CAVE. Coded in 45 minutes.\n\nhttps://twitter.com/CLUBCAVE_/status/1442436938921701378?s=20","likes":184,"published":1,"flags":32,"usePreview":1,"tags":["3d","pathtracer","livecoding"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define fs(i) (fract(sin((i)*114.514)*1919.810))\n#define lofi(i,j) (floor((i)/(j))*(j))\n\nconst float PI=acos(-1.);\n\n// CAVE 09\n// ENTER THE CAVE\n//\n// DJ: Pinieon\n\nfloat time;\nfloat seed;\n\nmat2 r2d(float t){\n  return mat2(cos(t),sin(t),-sin(t),cos(t));\n}\n\nmat3 orthBas(vec3 z){\n  z=normalize(z);\n  vec3 up=abs(z.y)>.999?vec3(0,0,1):vec3(0,1,0);\n  vec3 x=normalize(cross(up,z));\n  return mat3(x,cross(z,x),z);\n}\n\nfloat random(){\n  seed++;\n  return fs(seed);\n}\n\nvec3 uniformLambert(vec3 n){\n  float p=PI*2.*random();\n  float cost=sqrt(random());\n  float sint=sqrt(1.0-cost*cost);\n  return orthBas(n)*vec3(cos(p)*sint,sin(p)*sint,cost);\n}\n\nvec4 tbox(vec3 ro,vec3 rd,vec3 s){\n  vec3 or=ro/rd;\n  vec3 pl=abs(s/rd);\n  vec3 f=-or-pl;\n  vec3 b=-or+pl;\n  float fl=max(f.x,max(f.y,f.z));\n  float bl=min(b.x,min(b.y,b.z));\n  if(bl<fl||fl<0.){return vec4(1E2);}\n  vec3 n=-sign(rd)*step(f.yzx,f.xyz)*step(f.zxy,f.xyz);\n  return vec4(n,fl);\n}\n\nstruct QTR {\n  vec3 cell;\n  vec3 pos;\n  float len;\n  float size;\n  bool hole;\n};\n\nbool isHole(vec3 p){\n  if(abs(p.x)<.5&&abs(p.y)<.5){return true;}\n  float dice=fs(dot(p,vec3(-2,-5,7)));\n  if(dice<.3){return true;}\n  return false;\n}\n\nQTR qt(vec3 ro,vec3 rd){\n  vec3 haha=lofi(ro+rd*1E-2,.5);\n  float ha=fs(dot(haha,vec3(6,2,0)));\n  ha=smoothstep(-0.2,0.2,sin(0.5*time+PI*2.*(ha-.5)));\n  \n  ro.z+=ha;\n  \n  QTR r;\n  r.size=1.;\n  for(int i=0;i<4;i++){\n    r.size/=2.;\n    r.cell=lofi(ro+rd*1E-2*r.size,r.size)+r.size/2.;\n    if(isHole(r.cell)){break;}\n    float dice=fs(dot(r.cell,vec3(5,6,7)));\n    if(dice>r.size){break;}\n  }\n  \n  vec3 or=(ro-r.cell)/rd;\n  vec3 pl=abs(r.size/2./rd);\n  vec3 b=-or+pl;\n  r.len=min(b.x,min(b.y,b.z));\n  \n  r.pos=r.cell-vec3(0,0,ha);\n  r.hole=isHole(r.cell);\n  \n  return r;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv=fragCoord.xy/iResolution.xy;\n  vec2 p=uv*2.-1.;\n  p.x*=iResolution.x/iResolution.y;\n  \n  time=iTime;\n  \n  seed=texture(iChannel0,p).x;\n  seed+=fract(time);\n\n  float haha=time*62.0/60.0;\n  float haha2=floor(haha)-.2*exp(-fract(haha));\n\n  p=r2d(time*.2+.2*floor(haha))*p;\n  \n  vec3 ro0=vec3(0,0,1);\n  ro0.z-=haha2;\n  ro0+=.02*vec3(sin(time*1.36),sin(time*1.78),0);\n\n  vec3 rd0=normalize(vec3(p,-1.));\n  \n  vec3 ro=ro0;\n  vec3 rd=rd0;\n  vec3 fp=ro+rd*2.;\n  ro+=vec3(0.04*vec2(random(),random())*mat2(1,1,-1,1),0);\n  rd=normalize(fp-ro);\n  \n  float rl=.01;\n  vec3 rp=ro+rd*rl;\n  \n  vec3 col=vec3(0);\n  vec3 colRem=vec3(1);\n  float samples=1.;\n\n  for(int i=0;i<200;i++){\n    QTR qtr=qt(rp,rd);\n    \n    vec4 isect;\n    if(qtr.hole){\n      isect=vec4(1E2);\n    }else{\n      float size=qtr.size*.5;\n      size-=.01;\n      size-=.02*(.5+.5*sin(5.0*time+15.0*qtr.cell.z));\n      isect=tbox(rp-qtr.pos,rd,vec3(size));\n    }\n\n    if(isect.w<1E2){\n      float fog=exp(-.2*rl);\n      colRem*=fog;\n      \n      rl+=isect.w;\n      rp=ro+rd*rl;\n      \n      vec3 mtl=fs(cross(qtr.cell,vec3(4,8,1)));\n\n      vec3 n=isect.xyz;\n      \n      if(mtl.x<.1){\n        col+=colRem*vec3(10,1,1);\n        colRem*=0.;\n      }else if(mtl.x<.2){\n        col+=colRem*vec3(6,8,11);\n        colRem*=0.;\n      }else{\n        colRem*=0.3;\n      }\n      \n      ro=ro+rd*rl;\n      rd=mix(uniformLambert(n),reflect(rd,n),pow(random(),.3));\n      rl=.01;\n    } else{\n      rl+=qtr.len;\n      rp=ro+rd*rl;\n    }\n    \n    if(colRem.x<.01){\n      ro=ro0;\n      rd=rd0;\n      vec3 fp=ro+rd*2.;\n      ro+=vec3(0.04*vec2(random(),random())*mat2(1,1,-1,1),0);\n      rd=normalize(fp-ro);\n      rl=.01;\n      rp=ro+rd*rl;\n      colRem=vec3(1);\n      samples++;\n    }\n  }\n  \n  col=pow(col/samples,vec3(.4545));\n  col*=1.0-0.4*length(p);\n  col=vec3(\n    smoothstep(.1,.9,col.x),\n    smoothstep(.0,1.0,col.y),\n    smoothstep(-.1,1.1,col.z)\n  );\n  \n  // col=mix(texture(iChannel1,uv).xyz,col,.5);\n  //\n  // fragColor = vec4(col,1);\n  \n  // Slightly modified for shadertoy: to make thumbnail not dimmed\n  vec4 prev=texture(iChannel1,uv);\n  fragColor = mix(vec4(col,1),prev,.5*prev.w);\n}","name":"Buffer A","description":"","type":"buffer"}]}