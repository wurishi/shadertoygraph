{"ver":"0.1","info":{"id":"4l3XRN","date":"1478326558","viewed":164,"name":"fBm cube","username":"A2K","description":"The cube consists of layers of fBm noise generated in buffer A. The layers are tiled onto regular 2D texture, which is displayed in background, and then assembled back into a cube in image shader.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","fbm","cube"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define STEPS 128\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n\nfloat cube(vec3 p) {\n    \n    return length(max(abs(p)-1.0,0.0));\n}\n\n\nfloat opTx( vec3 p, mat4 m , out vec3 po)\n{\n    vec3 q = (inverse(m) * vec4(p, 1.0)).xyz;\n    po = q;\n    return cube(q);\n}\n#define PI 3.1415\nfloat map(vec3 pi, out vec3 po) {\n    vec2 m = iMouse.xy / iResolution.xy;\n    m.x = cos(fract(iTime * 0.1) *2.0 * PI);\n    vec3 pt;\n    float res = opTx(pi, rotationMatrix(vec3(-m * 4.0, 1.0), 10.0), pt);\n    po = pt;\n    return res;\n}\n\nvec3 getColor(vec3 p) {\n    vec3 pn = p * 0.5 + 1.0;\n    \n    vec3 pp = pn.xzy;\n    \n    if (pp.x < 0.0) pp.x += 1.0;\n    if (pp.y < 0.0) pp.y += 1.0;\n    if (pp.z < 0.0) pp.z += 1.0;\n\n    float Resolution = 64.0;\n\n    float grid = sqrt(Resolution) / Resolution;\n\n    float layer = pp.z * Resolution;\n    \n    float n = pp.z / grid;\n    \n    float y1 = floor(n) / Resolution;\n    float x1 = (floor(n) - y1 * Resolution) / Resolution;\n    \n    float y2 = ceil(n) / Resolution;\n    float x2 = (ceil(n) - y2 * Resolution) / Resolution;\n    \n    vec2 uv1 = vec2(x1, y1)*2.0 + pp.xy * grid;\n    vec2 uv2 = vec2(x2, y2)*2.0 + pp.xy * grid;    \n    \n    return abs(vec3(texture(iChannel0, uv1).r) * (1.0 - fract(n)) + vec3(texture(iChannel0, uv2).r) * fract(n));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    float t = 1.0;\n    float d;\n    vec3 c = vec3(0.0);\n    \n    vec3 o = vec3(0., 0., -3.0);\n    float z = sqrt(1.0 + pow(length(uv), 2.0));\n    vec3 r = normalize(vec3(uv, z));\n    \n    vec3 po;\n    \n    for(int i = 0; i < STEPS; ++i) {\n        vec3 p = r * t + o;\n        d = map(p, po);\n        t += 0.05;\n        if (d <= 0.0) {\n            c += getColor(po);\n        }\n    }\n    \n    vec4 bg = max(texture(iChannel0, fragCoord.xy / iResolution.xy), 0.0);\n    \n    fragColor = vec4(mix(bg.rgb, c.rgb, c.r), 1.0);// + vec4(c, 1.0);\n\t\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvec3 mod289(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\nfloat pnoise(vec3 P, vec3 rep)\n{\n  vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\n  vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\nfloat noise(vec3 x, float scale) {\n    return pnoise(x * scale, vec3(scale));\n}\n\n#define NUM_OCTAVES 5\n\nfloat fbm(vec3 x, float scale) {\n    float v = 0.0;\n    float a = 0.5;\n    vec3 shift = vec3(100);\n    for (int i = 0; i < NUM_OCTAVES; ++i) {\n        v += a * noise(x, scale);\n        x = x * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nfloat Resolution = 64.0;\n\nfloat cube(vec2 uv) \n{\n    float grid = sqrt(Resolution) / Resolution;\n\n    vec2 gp = uv / grid;\n\n    float z = gp.x * gp.y / Resolution;\n\n    vec2 xy = smoothstep(0.0, grid, mod(uv, grid));\n\n    return fbm(vec3(xy, z), 10.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float SCALE = 10.0;\n    fragColor = vec4(cube(uv));    \n}","name":"Buf A","description":"","type":"buffer"}]}