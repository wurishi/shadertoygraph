{"ver":"0.1","info":{"id":"7lySz3","date":"1663575082","viewed":90,"name":"BeamPattern","username":"EdgarDorausch","description":"Realtime beam pattern calculation","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["beampattern"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define product(a, b) vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x)\n#define conjugate(a) vec2(a.x,-a.y)\n#define divide(a, b) vec2(((a.x*b.x+a.y*b.y)/(b.x*b.x+b.y*b.y)),((a.y*b.x-a.x*b.y)/(b.x*b.x+b.y*b.y)))\n\n#define PI 3.14159265359\n#define BLACK vec3(0)\n#define WHITE vec3(1)\n#define GRAY vec3(.5)\n#define RED vec3(1.,.3,.3)\n#define BLUE vec3(.3,.3,1.)\n#define GREEN vec3(.3,1.,.3)\n#define YELLOW vec3(1.,1.,.3)\n\n// From: https://www.shadertoy.com/view/4sBfRd\nvec4 char(vec2 p, int c) {\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) );\n}\n\n// From: https://www.shadertoy.com/view/Md23DV\nfloat disk(vec2 r, vec2 center, float radius) {\n    return 1. - smoothstep(radius - .002, radius + .002, length(r - center));\n}\n\n// Modified from: https://www.shadertoy.com/view/Md23DV\nfloat coordinateGrid(vec2 r) {\n\tfloat result;\n\tfor(float i = -2.; i <= 2.; i += .1) for(int j = 0; j < 2; j++) {\n\t\tresult += 1. - smoothstep(.0, .003, abs(r[j] - i));\n\t\tif(mod(i, 2.) < .01) result += 1. - smoothstep(.0, .004, abs(r[j] - i - 1.));\n\t\tif(abs(i) < .01) result += 1. - smoothstep(.0, .005, abs(r[j]));\t\n\t}\n\treturn result;\n}\n\nfloat printNumber(vec2 fragCoord, float number) {\n\tfloat fontSize = 16.;\n\t// init digits\n\tint digits[12];\n\t// numbers start at 48 in font map\n\tfor(int i = 0; i <= 9; i++) digits[i] = 48 + i;\n\tdigits[10] = 46; // .\n\tdigits[11] = 45; // -\n\n\tint a[15]; // array for digits of number\n\tint c = 0; // counter for array = length\n\tfloat tmp = abs(number);\n\t// do not display numbers higher than this due to precision issues\n\tif (tmp > 999999.) {\n\t\twhile(c < 8) a[c++] = 11; // --------\n\t} else {\n\t\tif(number < 0.) a[c++] = 11; // add - if number is negative\n\t\tint v; // current digit\n\t\tbool f; // true if first digit > 0 found\n\t\tfor(int i = 8; i >= -4; i--) {\n\t\t\tv = int(tmp / pow(10., float(i))); // calculate digit\n\t\t\t// omit leading zeros\n\t\t\tif(v > 0 || f) {\n\t\t\t\ta[c++] = v; // add digits 0-9\n\t\t\t\ttmp -= float(v) * pow(10., float(i)); // subtract\n\t\t\t\tf = true;\n\t\t\t}\n\t\t\t//decimal point\n\t\t\tif(i == 0 && abs(number) < 1.) a[c++] = 0; // add 0\n\t\t\tif(i == 0) a[c++] = 10; // add .\n\t\t}\n\t\twhile(a[c-1] == 0) c--; // strip 0\n\t\tif(a[c-1] == 10) c--; // strip .\n\t}\n\t// coordinate system that starts at bottom left\n\t// which is independent of aspect ratio\n\tvec2 p = fragCoord.xy / iResolution.y;\n\tfloat result;\n\t// output number\n\tfor(int i = 0; i < c; i++) {\n\t\tresult += char(p * 256. / fontSize + vec2(-.5 * float(i), 0.0), digits[a[i]]).x;\n\t}\n\treturn result;\n}\n\n\nvec3 inferno(float t) {\n\n    const vec3 c0 = vec3(0.0002189403691192265, 0.001651004631001012, -0.01948089843709184);\n    const vec3 c1 = vec3(0.1065134194856116, 0.5639564367884091, 3.932712388889277);\n    const vec3 c2 = vec3(11.60249308247187, -3.972853965665698, -15.9423941062914);\n    const vec3 c3 = vec3(-41.70399613139459, 17.43639888205313, 44.35414519872813);\n    const vec3 c4 = vec3(77.162935699427, -33.40235894210092, -81.80730925738993);\n    const vec3 c5 = vec3(-71.31942824499214, 32.62606426397723, 73.20951985803202);\n    const vec3 c6 = vec3(25.13112622477341, -12.24266895238567, -23.07032500287172);\n\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n\n}\n\nvec3 viridis(float t) {\n\n    const vec3 c0 = vec3(0.2777273272234177, 0.005407344544966578, 0.3340998053353061);\n    const vec3 c1 = vec3(0.1050930431085774, 1.404613529898575, 1.384590162594685);\n    const vec3 c2 = vec3(-0.3308618287255563, 0.214847559468213, 0.09509516302823659);\n    const vec3 c3 = vec3(-4.634230498983486, -5.799100973351585, -19.33244095627987);\n    const vec3 c4 = vec3(6.228269936347081, 14.17993336680509, 56.69055260068105);\n    const vec3 c5 = vec3(4.776384997670288, -13.74514537774601, -65.35303263337234);\n    const vec3 c6 = vec3(-5.435455855934631, 4.645852612178535, 26.3124352495832);\n\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n\n}\n\nconst float eps = 0.001;\n\nconst float c = 1.0;\n\nconst vec2 ap1 = vec2(0.1, 0.45);\nconst vec2 ap2 = vec2(0.1, 0.55);\nconst vec2 ap_d = ap2 - ap1;\nconst int N = 1000;\nconst float Nf = float(N);\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y; // /iResolution.xy;\n    \n\n    \n    float f = 50.f * iTime;\n    vec2 val = vec2(0.0, 0.0);\n    \n    \n    for(int i=0;i<N;++i){\n        vec2 ap = ap1 + (float(i)/Nf)* ap_d;\n        float r = length(ap-uv);\n        float t = c*r;\n        val += vec2(cos(t*f), sin(t*f))/(t+eps)/Nf;\n    }\n    \n    float i = length(val)*eps*100.0;\n    \n    float ic = -log(i)/log(eps)+0.8f;\n    \n    vec3 col = inferno(clamp(ic, 0.0f, 1.0f));\n    \n    col = mix(col, GREEN, printNumber(fragCoord, f));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}