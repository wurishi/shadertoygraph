{"ver":"0.1","info":{"id":"43S3RW","date":"1708223621","viewed":30,"name":"Ray marching slime tutorial","username":"toriikyuu","description":"Went through https://www.youtube.com/watch?v=khblXafu7iA&pp=ygUMcmF5IG1hcmNoaW5n\nand then experimented a lot","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["turitorial"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define BPM 68.0\n#define PI 3.1415926535\n\nfloat frequency(float f) {\n    return f * BPM/60. * iTime;\n}\n\n// cosine based palette, 4 vec3 params\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nmat2 rot2D(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\n// distance to the scene\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat sdOctahedron( vec3 p, float s )\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nfloat smin(float a, float b, float k) {\n    float h = max(k - abs(a - b), 0.) / k;\n    return min(a, b) - h*h*h*k*(1.0/6.0);\n}\n\nfloat opSmoothIntersection( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\n\nfloat map(vec3 p, int version) {\n    if (version > 0 && p.y > 2.) return 10000000.000;\n    vec3 spherePos = vec3(sin(frequency(0.5)*PI)*3., 0, 0);\n    float sphere = sdSphere(p - spherePos, 1.);\n    float sphere2 = sphere;\n    float ground = p.y + 1.5;\n    vec3 q = p;\n    float box;\n    if (version < 1 || 3 <= version) {\n        q.y -= fract(frequency(1.));\n        q = fract(q) - .5;\n        box = sdBox(q, vec3(.05));\n        if (version >= 5) {\n            sphere2 = 1./sphere;\n        } else if (version >= 9) {\n            box = 1./(box*frequency(1.));\n        }\n    } else if (version < 3) {\n        q.xz *= rot2D(frequency(1./3.)*PI);\n        q = fract(q) - .5;\n        box = sdOctahedron(q, .05);\n    }\n    \n    return smin(ground, smin(smin(sphere, box, 1.3), sphere2, 1.), 1.);\n}\n\nvec3 notr(int c) {\n    return vec3(0, c, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2. - iResolution.xy)/iResolution.y;\n    vec2 m = (iMouse.xy*2. - iResolution.xy)/iResolution.y;\n    \n    // Initialisation\n    vec3 ro = vec3(0, 0, -3); // Ray origin\n    vec3 rd = normalize(vec3(1.*uv, 1)); // Ray direction\n    vec3 col = vec3(0);\n    \n    float t = 0.; // total distance travelled\n    int version = floor(frequency(.5));\n    \n    //Horizontal camera rotation\n    if version >\n    //ro.xz *= rot2D(-m.x*2.);\n    //rd.xz *= rot2D(-m.x*2.);\n    \n    // Raymarching\n    for (int i = 0; i < 200; i++) {\n        vec3 p = ro + rd * t; // position along the ray\n        float d = map(p, int(version));\n        t += d;    \n        col = notr(i)/300.;\n        if (d < .001 || t > 100.) break;\n    }\n    //col = vec3(0, vec2(t));\n    //col = 1. - 2./col;\n    col = palette(col.g, vec3(0, vec2(0.5)), vec3(0, vec2(.7)), vec3(0., 1., 1.), vec3(0, 0.5, 0.3));\n    fragColor = vec4(col, 0);\n}","name":"Image","description":"","type":"image"}]}