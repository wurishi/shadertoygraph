{"ver":"0.1","info":{"id":"lfGGzD","date":"1712472354","viewed":156,"name":"Temple ruins path traced","username":"FifthStateOfMatter","description":"Path traced version of \"Temple ruins\" shader (https://www.shadertoy.com/view/ld2GWy)","likes":1,"published":3,"flags":32,"usePreview":0,"tags":["3d","raymarch","dof","pathtrace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float aberrationScale = 0.0;\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 uvNorm = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    vec3 col = vec3(\n        texture(iChannel0, uv + vec2(-aberrationScale * sign(uvNorm) * length(uvNorm))).r,\n        texture(iChannel0, uv).g,\n        texture(iChannel0, uv + vec2(aberrationScale * sign(uvNorm) * length(uvNorm))).b\n    );\n    \n    fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Hash borrowed from Poisson (https://www.shadertoy.com/view/dssXRj)\nfloat seed;\n\nfloat hash1() {\n    return fract(sin(seed += 0.1) * 4568.7564);\n}\n\nvec2 hash2() {\n    return vec2(hash1(), hash1());\n}\n\nvec3 hash3() {\n    return vec3(hash1(), hash1(), hash1());\n}\n\nvec2 randomDirection2D() {\n    vec2 d;\n    while(true) {\n        d = hash2() * 2.0 - 1.0;\n        if(length(d) <= 1.0) return d;\n    }\n}\n\nvec3 randomDirection() {\n    vec3 d;\n    while(true) {\n        d = hash3() * 2.0 - 1.0;\n        if(length(d) <= 1.0) return normalize(d);\n    }\n}\n\nvec3 rotate2D(vec3 p, vec2 t){\n    float stx = sin(t.x);\n    float ctx = cos(t.x);\n    float sty = sin(t.y);\n    float cty = cos(t.y);\n    mat3 xRotation;\n    xRotation[0] = vec3(1, 0, 0);\n    xRotation[1] = vec3(0, ctx, -stx);\n    xRotation[2] = vec3(0, stx, ctx);\n    \n    mat3 yRotation;\n    yRotation[0] = vec3(cty, 0, -sty);\n    yRotation[1] = vec3(0, 1, 0);\n    yRotation[2] = vec3(sty, 0, cty);\n    return p*xRotation*yRotation;\n}\n\n// SDF code from original (https://www.shadertoy.com/view/ld2GWy)\nfloat sdrBox(vec3 p, vec3 b, float r) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0)) - r;\n}\n\nfloat sdCylinder(vec3 p, vec2 h) {\n    return max(length(p.xz) - h.x, abs(p.y) - h.y);\n}\n\nfloat ruins(vec3 p) {\n    vec3 q = p;\n    \n    //bumps\n    float o = texture(iChannel1, p.xy * 0.1).r * texture(iChannel1, p.yz * 0.1).r * texture(iChannel1, p.xz* 0.1).r * 0.1;\n\n    //pillars bottom\n    p.x = clamp(p.x, -8.0, 8.0);                                     //limit x\n    if((p.z < 2.0 && p.z > -2.0) && (p.x < 0.0 && p.x > -4.0)) p.x = 0.0; //chop hole in middle \n\n    p.x = mod(p.x, 2.0) - 0.5 * 2.0;                                    //rep x\n\n    p.z = clamp(p.z, -4.0, 4.0);                                     //limit z\n    if(q.x > 2.0 || q.x < -6.0) p.z = clamp(p.z, -2.0, 2.0);\n    p.z = mod(p.z, 2.0) - 0.5 * 2.0;                                    //rep z\n\n    float r = 0.5 - clamp(sin(p.y * 1.2 + 1.58) * 0.5, 0.0, 0.05);\n    float d = sdCylinder(p, vec2(r, 1.5)) - o;\n\n    //pillars top\n    p.y -= 2.8;\n    r = 0.4 - clamp(sin(p.y * 1.8 + 0.8) * 0.5, 0.0, 0.05);\n    \n    float h = 1.5;\n    if(q.x > 2.0) {\n        p.y -= 0.5;\n        h = 2.0;\n        r = 0.4 - clamp(sin(p.y * 1.15 + 1.1) * 0.5, 0.0, 0.05);\n    } //pull first 3x2 pillars up\n    float t = sdCylinder(p, vec2(r, h)) - o;    \n\n    //mid platform\n    q.y -= 1.8;\n    float c = sdrBox(q, vec3(7.45, 0.25, 1.45), 0.05) - o;\n    q.x += 2.0;\n    c = min(c, sdrBox(q, vec3(3.45, 0.25, 3.45), 0.05) - o);\n\n    //bottom platform\n    q.y += 3.55;\n    c = min(c, sdrBox(q, vec3(3.65, 0.2, 3.65), 0.05) - o);\n    q.x -= 2.0;\n    c = min(c, sdrBox(q, vec3(7.65, 0.2, 1.65), 0.05) - o);\n    \n    //ground platform\n    q.x += 2.0;\n    q.y += 0.8;\n    c=min(c, sdrBox(q, vec3(4.65, 0.6, 4.65), 0.05) - o);\n    q.x -= 2.0;\n    c = min(c, sdrBox(q, vec3(8.65, 0.6, 2.65), 0.05) - o);\n    \n    //top part\n    q.y -= 8.0;\n    q.x -= 5.0;\n    c = min(c, sdrBox(q, vec3(2.45, 0.15, 1.45), 0.05) - o);\n    c = max(c, -sdrBox(q, vec3(1.45, 0.25, 0.45), 0.05) - o);    //left hole\n    \n    //top right part\n    q.y += 1.0;\n    q.x += 6.0;\n    c = min(c, sdrBox(q, vec3(4.50, 0.15, 1.65), 0.05) - o);\n    q.x += 1.0;\n    q.z -= 0.85;\n    c = min(c, sdrBox(q, vec3(3.45, 0.15, 2.5), 0.05) - o);\n    q.z += 0.85;\n    c = max(c, -sdrBox(q, vec3(2.25, 4.5, 2.25), 0.05) - o);    \n    \n    d = min(min(c, d), t);\n\t\n    return d * 0.8;\n}\n\n// Just used a flat surface here because it was starting to get laggy\nfloat terrain(vec3 p) {\n    return sdrBox(p - vec3(0, -6, 0), vec3(50, 3, 50), 0.0) * 0.7;\n}\n\nfloat scene(vec3 p) {\n    return min(terrain(p), ruins(p));\n}\n\n// Triplanar mapping function from original (https://www.shadertoy.com/view/ld2GWy)\nvec3 tex3D(vec3 pos, vec3 nor, sampler2D s) {\n\treturn texture(s, pos.yz).xyz * abs(nor.x) +\n\t       texture(s, pos.xz).xyz * abs(nor.y) +\n\t       texture(s, pos.xy).xyz * abs(nor.z);\n}\n\nfloat raymarch(vec3 o, vec3 d, inout bool hit) {\n    float t = 0.0;\n    for(int i = 0; i < 100 && t <= 30.0 && !hit; i++) {\n        float s = scene(o + d * t);\n        t += s;\n        if(abs(s) <= 0.003 * t && t >= 0.0) hit = true;\n    }\n    return t;\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(0, 0.001);\n    return normalize(vec3(\n        scene(p + e.yxx) - scene(p - e.yxx),\n        scene(p + e.xyx) - scene(p - e.xyx),\n        scene(p + e.xxy) - scene(p - e.xxy)\n    ));\n}\n\nvec3 pathtrace(vec3 o, vec3 d) {\n    vec3 col = vec3(1);\n    vec3 mat;\n    float t;\n    float initT;\n    bool hit = false;\n    vec3 p;\n    vec3 n;\n    for(int i = 0; i < 6; i++) {\n        hit = false;\n        t = raymarch(o, d, hit);\n        if(i < 1) initT = t;\n        if(hit) {\n            p = o + d * t;\n            n = getNormal(p);\n            o = p + n * 0.005;\n            d = randomDirection();\n            d *= sign(dot(n, d));\n            if(p.y <= -3.0 + 0.1) {\n                mat = mix(vec3(0.5, 0.1, 0), vec3(0.1, 0.5, 0), texture(iChannel2, p.xz * 0.01).r);\n            } else {\n                mat = (tex3D(p * 0.3, n, iChannel1) * 0.75 + tex3D(p * 0.3, n, iChannel2).grb) / 2.0;\n            }\n            col *= mat * 0.5 * dot(n, d);\n        } else {\n            col *= (i > 1 ? 8.0 : 1.0) * vec3(0.8, 0.9, 1);\n            break;\n        }\n    }\n    return mix(col, vec3(0.8, 0.9, 1), 1.0 - exp(-initT * vec3(0.005, 0.0051, 0.0054)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    seed = iTime + dot(sin(fragCoord), vec2(443.712, 983.234));\n    seed += hash1() * 434.251;\n    \n    vec2 uv = ((fragCoord + hash2() - 0.5) - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 o = rotate2D(vec3(0, 0, -14), -iMouse.yx * 0.005 + vec2(radians(60.0), radians(0.0)));\n    vec3 d = rotate2D(normalize(vec3(uv, 1.0)), -iMouse.yx * 0.005 + vec2(radians(60.0), radians(0.0)));\n    \n    bool h;\n    float focalLength = raymarch(o, rotate2D(normalize(vec3(0, 0, 1)), -iMouse.yx * 0.005 + vec2(radians(60.0), radians(0.0))), h);\n    vec3 focalPoint = o + d * focalLength;\n    \n    o += rotate2D(vec3(randomDirection2D(), 0), -iMouse.yx * 0.005 + vec2(radians(60.0), radians(0.0))) * 0.1;\n    vec3 shiftedDir = normalize(focalPoint - o);\n    \n    // Progression borrowed from Poisson (https://www.shadertoy.com/view/dssXRj)\n    vec3 col = pathtrace(o, shiftedDir);\n    vec4 data = texelFetch(iChannel3, ivec2(fragCoord), 0);\n    if(iMouse.z > 0.0){\n        data *= 0.0;\n    }\n    data += vec4(col, 1);\n    \n    fragColor = data;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*\nI noticed the \"Temple ruins\" shader on shader of the week so I decided to try path tracing it\n\nI only spent a couple hours on this\nand I have the attention span of a carrot\nso there is much room for improvement that\nI will never find motivation to add.\nI may or may not implement suggestions\n\nCurrently running at around 40fps on RTX 4060 at 1800 x 1013\n\nCredit to the original shader by avix for the temple model and triplanar mapping (https://www.shadertoy.com/view/ld2GWy)\nCredit to Poisson for utility functions (https://www.shadertoy.com/user/Poisson)\n*/\n\n// ACES color space mapping from Poisson (https://www.shadertoy.com/view/dssXRj)\nvec3 ACES(vec3 x) {\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.1;\n    float d = 0.7;\n    float e = 0.12;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec4 col = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    col.rgb /= col.a;\n    col.rgb = ACES(col.rgb);\n    fragColor = vec4(pow(col.rgb, vec3(1.0 / 2.2)), 1);\n}","name":"Buffer B","description":"","type":"buffer"}]}