{"ver":"0.1","info":{"id":"Mt2XDD","date":"1443934432","viewed":10399,"name":"Flight over Bespin","username":"yamahabob","description":"My first published shader, which is borrowing heavily from other great works on this fantastic site.  I have no idea what I'm doing...","likes":99,"published":1,"flags":0,"usePreview":1,"tags":["clouds","flight","millenniumfalcon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// Flight over Bespin - yamahabob\n// Borrowed most of this code from inigo quilez et al\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define PI 3.141592654\n\n// General functions\n\nmat3 rx90 = mat3(1.0, 0.0, 0.0,\n\t\t\t     0.0, 0.0, 1.0,\n\t\t\t     0.0,-1.0, 0.0 );\nmat3 ry90 = mat3(0.0, 0.0,-1.0,\n\t\t\t     0.0, 1.0, 0.0, \n\t\t\t     1.0, 0.0, 0.0 );\nmat3 rz90 = mat3(0.0,-1.0, 0.0,\n\t\t\t     1.0, 0.0, 0.0, \n\t\t\t     0.0, 0.0, 1.0 );\n\nmat3 rotX( float a )\n{\n\treturn mat3(1.0,    0.0,    0.0,\n                0.0, cos(a),-sin(a),\n                0.0, sin(a), cos(a) );\n}\n\nmat3 rotY( float a )\n{\n\treturn mat3(cos(a), 0.0, sin(a),\n                   0.0, 1.0,    0.0, \n               -sin(a), 0.0, cos(a) );\n}\n\nmat3 rotZ( float a )\n{\n\treturn mat3(cos(a),-sin(a), 0.0,\n                sin(a), cos(a), 0.0,\n                   0.0,    0.0, 1.0 );\n}\n\nmat2 rot(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\n// -------------------------------------\n// Cloud Calculations\n// (borrowed from iq)\n// -------------------------------------\n\n#define SPEED 5.\n\nfloat speed;\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\t//f = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy + vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel0, 0.00390625*uv ).yx;\n\treturn 1.5*mix( rg.x, rg.y, f.z ) - 0.75;\n}\n\nfloat map5( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0)*speed;\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q ); q = q*2.01;\n    f += 0.06250*noise( q ); q = q*2.02;\n    f += 0.03125*noise( q );\n\treturn clamp( -p.y - 0.5 + 1.75*f, 0.0, 1.0 );\n}\n\nfloat map4( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0)*speed;\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q ); q = q*2.01;\n    f += 0.06250*noise( q );\n\treturn clamp( -p.y - 0.5 + 1.75*f, 0.0, 1.0 );\n}\nfloat map3( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0)*speed;\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q );\n\treturn clamp( -p.y - 0.5 + 1.75*f, 0.0, 1.0 );\n}\nfloat map2( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0)*speed;\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q );;\n\treturn clamp( -p.y - 0.5 + 1.75*f, 0.0, 1.0 );\n}\n\nvec3 sundir = normalize( vec3(-0.5,-0.1,-1.0) );\n\nvec4 integrate( in vec4 sum, in float dif, in float den, in vec3 bgcol, in float t )\n{\n    // lighting\n    vec3 lin = vec3(0.65,0.68,0.7)*1.2 + 0.5*vec3(0.7, 0.5, 0.3)*dif;        \n    vec4 col = vec4( mix( 1.15*vec3(1.0,0.95,0.8), vec3(0.65), den ), den );\n    col.xyz *= lin;\n    col.xyz = mix( col.xyz, bgcol, 1.0-exp(-0.004*t*t) );\n    // front to back blending    \n    col.a *= 0.4;\n    col.rgb *= col.a;\n    return sum + col*(1.0-sum.a);\n}\n\n#define MARCH(STEPS,MAPLOD) for(int i=0; i<STEPS; i++) { vec3  pos = ro + t*rd; if( pos.y<-3. || pos.y>1.2 || sum.a > 0.99 ) break; float den = MAPLOD( pos ); if( den>0.1 ) { float dif = clamp((den - MAPLOD(pos+0.5*sundir))*2., 0.0, 1.0 ); sum = integrate( sum, dif, den, bgcol, t ); } t += max(0.2,0.03*t); }\n\nvec4 raymarch( in vec3 ro, in vec3 rd, in vec3 bgcol )\n{\n\tvec4 sum = vec4(0.0);\n\n\tfloat t = 0.0;\n\n    MARCH(25,map4);\n    MARCH(20,map3);\n    MARCH(15,map2);\n    MARCH(15,map2);\n\n    return clamp( sum, 0.0, 1.0 );\n}\n\nmat3 lookat( vec3 fw, vec3 up ){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,normalize(up)));return mat3(rt,cross(rt,fw),fw);\n}\n\nmat3 setCamera( in vec3 fw )\n{\n\tvec3 cw = normalize( fw );\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = vec3( -cw.z, 0.0, cw.x );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 cloudRender( in vec3 ro, in vec3 rd )\n{\n    // background sky     \n\tfloat sun = clamp( dot(sundir,rd), 0.0, 1.0 );\n\tvec3 col = 0.9*vec3(0.949,0.757,0.525) - rd.y*0.2*vec3(0.949,0.757,0.525);// + 0.15*0.5;\n\tcol += 0.8*vec3(1.0,.6,0.1)*pow( sun, 20.0 );\n\n    // clouds    \n    vec4 res = raymarch( ro, rd, col );\n    col = col*(1.0-res.w) + res.xyz;\n    \n    // sun glare    \n\tcol += 0.1*vec3(0.949,0.757,0.525)*pow( sun, 3.0 );\n\n    return col;\n}\n\n\n// =========== Ship Calculations ===========\n\nfloat time;\nvec3 shippos;\nmat3 shipltow;\nmat2 shiptilt;\n\n// the flight path\n\nvec3 shippath( float t )\n{\n    return vec3( 5.*sin( 0.9*t ), 2.5*sin( 0.6*t ), 0. );\n}\n\nvec3 shipvel( float t )\n{\n    return vec3( 5.*0.9*cos( 0.9*t ), 2.5*0.6*cos( 0.6*t ), 15. );\n}\n\nvec3 shipacc( float t )\n{\n    return vec3( -4.*0.9*0.9*sin( 0.9*(t)), -2.5*0.6*0.6*sin( 0.6*t ), 0. );\n}\n\n\n// distance functions for basic shapes\n\nfloat sdPlane( vec3 p, vec4 n ) { return dot(p,n.xyz) + n.w; }\n\nfloat sdSphere( vec3 p, float s ) { return length(p)-s; }\n\nfloat sdBox( vec3 p, vec3 b ) { vec3 d = abs(p) - b; return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)); }\n\nfloat sdHexPrism( vec3 p, vec2 h ) { vec3 q = abs(p); return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x); }\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ) { vec3 pa = p-a, ba = b-a; return length( pa - ba*clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 )) - r; }\n\nfloat sdConeSection( in vec3 p, in float h, in float r1, in float r2 )\n{\n    float d1 = -p.y - h;\n    float q = p.y - h;\n    float si = 0.5*(r1-r2)/h;\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat length8( vec3 d ) { vec3 q = pow( d, vec3(8.) ); return pow( q.x + q.y + q.z, 0.125 ); }\n\nfloat sdTorus82( vec3 p, vec2 t ) { vec2 q = vec2(length(p.xz)-t.x,p.y); return length8(vec3(q,0.))-t.y; }\n\nfloat sdCylinder( vec3 p, vec3 c ) { return length(p.xz-c.xy)-c.z; }\n\nfloat sdCappedCylinder( vec3 p, vec2 h ) { vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\nvec2 min2( vec2 d1, vec2 d2 ) { return ( d1.x < d2.x ) ? d1 : d2; }\n\nvec2 max2( vec2 d1, vec2 d2 ) { return ( d1.x > d2.x ) ? d1 : d2; }\n\nfloat smin( float a, float b, float k ) { float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 ); return mix( b, a, h ) - k*h*(1.0-h); }\n\nvec2 smin( vec2 a, vec2 b, float k ) { float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 ); return mix( b, a, h ) - k*h*(1.0-h); }\n\n\n// texture functions\n\nfloat noise( float s )\n{\n    vec2 uv = vec2( s, s );\n    return texture( iChannel0, uv ).x;\n}\n\nfloat cubicPulse( float c, float w, float x )\n{\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\n// plate texture\nfloat texPlates( vec2 uv )\n{\n    vec2 n = vec2( 10., 4. );\n    vec2 sec = floor( uv*n );\n    vec2 suv = uv*n - sec;\n    \n    float s1 = noise( 0.3*( uv.x + sec.y/n.y ) );\n    float s2 = 0.3*s1+0.5;\n    float s3 = noise( 0.4*sec.y/n.y );\n    float luma = 0.5*(1. - cubicPulse( s3, 0.03, suv.x )) + 0.5;\n    luma *= mix(1.0, s2, smoothstep(0.0, 1.0, suv.y));\n    luma *= 0.5*smoothstep( 0.0, 0.005*n.y, min( suv.y, 1.-suv.y)) + 0.5;\n\treturn clamp(luma, 0., 1.);\n}\n\n// circular hull texture\nvec3 texHull( vec3 p )\n{\n    vec2 uv;\n    uv.x = atan(p.z, p.x)/PI;\n    float d = length(p.xz);\n    uv.y = 0.925 - 0.5*d;\n    vec3 shipCol1 = 0.9*vec3(0.729, 0.694, 0.627);\n    vec3 shipCol2 = 0.4*vec3(0.6, 0.537, 0.447);\n    return texPlates( uv ) * mix(shipCol1, shipCol2, cubicPulse( 0., 0.5, uv.x ));\n}\n\n// ship world to local transformation\n\nvec3 shipw2l( vec3 p )\n{\n    p.z = -p.z;\n    p = shipltow*(p - shippos);\n    p.zy *= shiptilt;\n\treturn p;\n}\n\n// ship distance evaluation where p is in world coords\n\nvec2 shipDE(vec3 p)\n{\n    float d1, d2, d3, d4;\n    p = shipw2l( p );\n    d1 = sdSphere( p, 3.3 ); // the bounding 'hit' sphere\n    if ( d1 > 0.2 ) return vec2( d1, 0. );\n\t\n    // main disk\n    vec3 q = p;\n    q.y = abs(q.y);\n\td1 = sdSphere( q + vec3( 0., 14.78, 0. ), 15. );\n    d1 = max( d1, sdSphere( q, 2. ));\n    d1 = max( -q.y + 0.06, d1 );\n\td2 = max(  q.y - 0.06, sdSphere( q, 1.95 ));\n    vec2 vres = vec2( min( d1, d2 ), 1.);\n    \n    // centre pylon\n  \tvres = smin( vres, vec2( sdCappedCylinder( p, vec2( 0.45, 0.28 )), 2.), 0.1);\n    \n    // front forks\n    q = p;\n    q.z = abs(q.z);\n    q += vec3(1.45, 0., -1.1);\n    float front = sdBox( q, vec3( 1.8, 0.09, 0.8 )); // front\n    vec3 norm = normalize(vec3(-1.1, 0.0, 2.3));\n    q = p;\n    q.z = abs(q.z);\n    float plane = sdPlane( q, vec4(-norm, 1.92) );\n    d1 = max( -plane, front );\n    vres = min2( vres, vec2( d1, 3. ));\n\t\n    // Z crossbar\n    d1 = sdHexPrism( p, vec2( 0.26, 2.0 ));\n  \td2 = sdBox( p, vec3( 0.8, 0.8, 0.6 ));\n    vres = min2( vres, vec2( max( -d2, d1 ), 4.));\n    \n    // X crossbar\n    q = p;\n    q.y = abs(q.y);\n    q = ry90 * rotZ(0.07) * q + vec3( 0., 0.02, -1.5);\n    vres = min2( vres, vec2( max( -abs(p.y) + 0.07, sdHexPrism( q, vec2(0.36, 0.9 ))), 5.));\n\n    // cockpit walkway\n    vec3 p1 = vec3(-0.8*sin(0.524), 0.1, -0.8*cos(0.524));\n    vec3 p2 = vec3(-2.1*sin(0.524), 0.07, -2.1*cos(0.524));\n    vec3 p3 = p2 + vec3(-0.2, 0., 0.);\n    vres = min2( vres, vec2( sdCapsule( p, p1, p2, 0.18 ), 6.));\n    vres = min2( vres, vec2( sdCapsule( p, p2, p3, 0.18 ), 6.1));\n\n    // cockpit\n    q = rz90*(p - p3 + vec3(0.2, 0., 0.));\n    vres = min2( vres, vec2( sdConeSection( q, 0.15, 0.18, 0.08), 7. ));\n    \n    // side cylinders\n    q = vec3( 0., 3.87, 0. );\n    q = mod( rx90 * p, q ) - 0.5*q;\n    vres = max2( vres, vec2( -sdTorus82( q, vec2( 0.26, 0.09 )), 8.));\n\n    // exhaust ports\n    p1 = vec3(0.75, 0., 0.);\n    p2 = vec3(0.45, 0., 0.);\n    q = p - p1;\n  \tvres = smin( vres, vec2( sdCappedCylinder( q, vec2( 0.14, 0.255 )), 9.), 0.044);\n    q -= p2;\n  \tvres = smin( vres, vec2( sdCappedCylinder( q, vec2( 0.14, 0.225 )), 9.), 0.044);\n\tq = p;\n    q.z = -abs(q.z); // reflect\n    q = rotY(0.45)*q - p1;\n    vres = smin( vres, vec2( sdCappedCylinder( q, vec2( 0.14, 0.255 )), 9.), 0.044);\n    q -= p2;\n    vres = smin( vres, vec2( sdCappedCylinder( q, vec2( 0.14, 0.225 )), 9.), 0.044);\n\n    // gun port\n    q = p + vec3(0.22, 0., 0.);\n  \tvres = min2( vres, vec2( sdCappedCylinder( q, vec2( 0.14, 0.32 )), 9.));\n    \n    // gun\n    p1 = vec3(-0.22, 0., 0.);\n    p2 = p1 + vec3( 0., 0.35, 0.0);\n    p3 = vec3(-0.22, 0.33, 0.03);\n    vec3 p4 = p3 + vec3(-0.25, 0.04, 0.);\n    vec3 p5 = vec3(0., 0.03, 0.);\n    q = p;\n    q.z = abs(q.z);\n    q.y = abs(q.y);\n    d1 = sdCapsule( q, p1, p2, 0.06 ); // gun pod\n    d1 = min( d1, sdCapsule( q, p3, p4, 0.01 )); // gun 1\n    d1 = min( d1, sdCapsule( q, p3 + p5, p4 + p5, 0.01 )); // gun 2\n    vres = min2( vres, vec2( d1, 10.));\n    \n    // upper dish\n    p1 = vec3( -1.1, 0.4, 0.83 );\n    p2 = p1 - vec3( -0.05, 0.0, 0.0 );\n    p3 = p2 - vec3( -0.1, 0.25, 0.0 );\n    q = p - p1;\n    d1 = sdSphere( q, 0.2 );\n   \tq = q + vec3( 0.75, -0.1, 0.0 );\n    d2 = sdSphere( q, 0.8 );\n\td3 = sdSphere( q, 0.81 );\n    d4 = sdCapsule( p, p2, p3, 0.03 );\n    vres = min2( vres, vec2( min( d4, max( d3, max( -d2, d1 ))), 10.));\n    \n    return vres;\n}\n\n// ray marching and rendering\n\nvec2 shipCastRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n    \n\tconst float precis = 0.001;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<50; i++ )\n    {\n\t    vec2 res = shipDE( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if ( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = shipDE( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    shipDE(pos+eps.xyy).x - shipDE(pos-eps.xyy).x,\n\t    shipDE(pos+eps.yxy).x - shipDE(pos-eps.yxy).x,\n\t    shipDE(pos+eps.yyx).x - shipDE(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = shipDE( aopos ).x;\n        occ -= (dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 shipRender( in vec3 ro, in vec3 rd, in vec3 col )\n{ \n    vec2 res = shipCastRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m >-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        vec2 uv = vec2(0.);\n        float luma = 0.;\n        \n        vec3 shipCol = 0.9*vec3(0.729, 0.694, 0.627);//vec3(0.5, 0.45, 0.45);\n\n        vec3 q = shipw2l( pos );\n        bool isExhaust = false;\n        \n        if ( abs(q.y) < 0.06 && m < 3.5 )\n        {\n            if (q.x < 1.6)\n            \tcol = mix(vec3(0.1), shipCol, 0.5 * texture( iChannel0, 0.2*q.xy ).x);\n            else\n                isExhaust = true;\n        } else if ( m < 1.1 ) // main disk\n        {\n        \tcol = texHull( q );\n        } else if ( m < 2.1 ) // centre pylon\n        {\n            q = 1.5*(q + vec3(0.22, 0., 0.));\n\t\t\tuv.x = 0.5*(atan(q.z, q.x)/PI);\n\t\t\tuv.y = 1. - length(q.xz);\n            luma = texPlates( uv );\n        \tcol = luma * shipCol;\n        } else if ( m < 3.1 ) // front forks\n        {\n            uv.x = 0.3*abs(q.z);\n            uv.y = 0.25*q.x+0.4;\n            luma = texPlates( uv );\n        \tcol = luma * shipCol;\n        } else if ( m < 4.1 ) // Z crossbar\n        {\n            uv.x = 0.5*q.x;\n            uv.y = -0.8*abs(q.z);\n            float luma = texPlates( uv );\n        \tcol = luma * shipCol;\n        } else if ( m < 5.1 ) // X crossbar\n        {\n            uv.x = 0.5*q.z;\n            uv.y = q.x;\n            if (abs(q.z) < 0.12 && abs(q.x) > 0.8 && abs(q.x) < 2.3)\n            {\n                uv.y *= 0.5;\n                col = shipCol * mix( 0.5, 1., 0.5 * texture( iChannel0, 0.2*uv ).x);\n            } else\n                col = shipCol * texPlates( uv );\n        } else if ( m < 6.6 ) // cockpit walkway\n        {\n            uv = rot(0.524)*q.xz;\n            uv.x = 0.5*uv.x;\n            uv.y = uv.y;\n            luma = texPlates( uv );\n        \tcol = luma * shipCol;\n        } else if ( m < 7.1 ) // cockpit\n        {\n            if ( q.y > 0.12 )\n        \t\tcol = vec3(0.03);\n            else\n                col = shipCol;\n        } else if ( m < 8.1 ) // side ports\n        {\n            col = shipCol;\n        } else if ( m < 9.9 ) // exhaust ports and gun port\n        {\n            col = vec3(0.05);\n        } else\n        {\n        \tcol = shipCol;\n        }\n\n        if ( isExhaust )\n        {\n            // ship exhaust\n            float blume = pow( clamp( dot(nor,-rd), 0.0, 1.0), 10. );\n            col = clamp( blume + vec3( 0.215, 0.945, 1. ) * (0.5 * cos( 80.*q.z ) + 0.5), 0., 1.);\n        } else\n        {\n            // ship hull lighting        \n            float occ = calcAO( pos, nor );\n            vec3  lig = sundir;\n            float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n            float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n            float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n            float dom = smoothstep( -0.1, 0.1, ref.y );\n            float fre = pow( clamp( 1.0+dot(nor,rd),0.0,1.0), 2.0 );\n            float spe = pow( clamp( dot( ref, lig ), 0.0, 1.0 ), 16.0 );\n\n            dif *= softshadow( pos, lig, 0.02, 2.5 );\n            dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n            vec3 brdf = vec3(0.0);\n            brdf += 1.20*dif*vec3(1.00,0.90,0.60);\n            brdf += 1.10*spe*vec3(1.00,0.90,0.60)*dif;\n            brdf += 0.30*amb*vec3(0.50,0.70,1.00)*occ;\n            brdf += 0.40*dom*vec3(0.50,0.70,1.00)*occ;\n            brdf += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n            brdf += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n            brdf += 0.02;\n            col = clamp(col*brdf, 0.0, 1.0);\n            \n            // Gamma correction\n\t\t\tcol = pow( col, vec3(0.4545) );\n        }\n    }\n\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n//    vec2 md = iMouse.xy/iResolution.xy - 0.5;\n\n    // render clouds and sky\n    speed = iTime * SPEED;\n    vec3 ro = 4.0*normalize(vec3( 0.0, 0.3, 5.0));\n\tvec3 ta = vec3(0.0, -1.0, 0.0);\n    mat3 ca = setCamera( ta - ro );\n    vec3 rd = ca * normalize( vec3(p.xy,1.0) );\n    vec3 col = cloudRender( ro, rd );\n\n    // animate\n\ttime = iTime;\n\tshippos = shippath( time );\n    vec3 shipv = shipvel( time );\n    vec3 shipa = shipacc( time );\n\n\t// camera\t\n    //ro = rotY(2.*PI*md.x) * rotX(-0.99*PI*md.y) * vec3( 0.0, 0.0, 9.);\n    ro = vec3( 0.0, 0.0, 5.*sin( 0.5*time ) + 13.);\n\t\n\t// camera-to-world transformation\n    ca = setCamera( ta - ro );\n    \n    // ship direction\n    shiptilt = rot( 0.4*shipa.x );\n    shipltow = ry90 * setCamera( -normalize( shipv ) );\n    \n    // ray direction\n\trd = ca * normalize( vec3(p.xy, 1.0) );\n\n    // render ship\n    col = shipRender( ro, rd, col );\n\n    fragColor = vec4(col, 1.);\n}","name":"","description":"","type":"image"}]}