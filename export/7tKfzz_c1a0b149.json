{"ver":"0.1","info":{"id":"7tKfzz","date":"1664154597","viewed":106,"name":"Hexagon coordinates","username":"scudly","description":"Compute hexagon coordinates by finding the id and distance to the nearest pair of hexes. The integer hex id coordinates, returned in h.zw, are either both even or both odd.  h.xy is the local coordinates relative to hex h.zw.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["2d","hexagon","tiling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// based on hex tiling by lomateron\n// https://www.shadertoy.com/view/MlXyDl\n// with added hex IDs and vectorization by Shane\n// https://www.shadertoy.com/view/MtlBDs\n\n// The hex mappings here provide easy to use integer hex coordinates\n// based on the doubled coordinates described by\n// https://www.redblobgames.com/grids/hexagons/#coordinates-doubled\n// where each hex's integer coordinates are either both even or both odd\n// based on a square grid that passes through the hex centers.  The grid\n// spacing is based on the vec2 s and gives either flat-topped or flat-\n// sided hexagons depending on which coordinate is sqrt(3) times the other.\n// A hex's center point is located at s * the hex coordinates.\n\n// The grid cells have a hex center at two diagonally opposite corners and\n// a point is in the hex whose center it is closer to.  The hexParity functions\n// use the parity of the grid cell to identify which pair of corners have the\n// hex centers.  The hexEvenOdd function separately uses the twice as large grid\n// cells around the even-coordinate and odd-coordinate hexes.  The parity\n// version is more efficient on the CPU with just two floor() calls, but the\n// hexEvenOdd one is more compact and vectorizes better on the GPU.\n\n\nvec2 s = vec2( sqrt(3.), 1. );\n\nvec4 hexParityFloat( vec2 p ) {\n    //  id.xy are the left hex, id.zw are the right hex\n    vec2 ij = floor( p/s );\n    float parity = mod( ij.x+ij.y, 2. );\n    vec4 id = vec4( ij.x, ij.y+parity, ij.x+1., ij.y+1.-parity );\n    vec4 d = p.xyxy - s.xyxy * id;\n    return dot(d.xy,d.xy) < dot(d.zw,d.zw) ? vec4(d.xy, id.xy) : vec4(d.zw, id.zw);\n}\n\nvec4 hexParityInt( vec2 p ) {\n    //  id.xy are the left hex, id.zw are the right hex\n    ivec2 ij = ivec2( floor( p/s ) );\n    int parity = (ij.x+ij.y) & 1;\n    vec4 id = vec4( ij.x, ij.y+parity, ij.x+1, ij.y+1-parity );\n    vec4 d = p.xyxy - s.xyxy * id;\n    return dot(d.xy,d.xy) < dot(d.zw,d.zw) ? vec4(d.xy, id.xy) : vec4(d.zw, id.zw);\n}\n\nvec4 hexEvenOdd( vec2 p ) {\n    // integer id coords are either both even (xy) or both odd (zw)\n    vec4 id = floor( vec4( p+s, p )/(2.*s.xyxy) ) * 2.0 + vec4(0, 0, 1, 1);\n    vec4 d = p.xyxy - s.xyxy * id;\n    return dot(d.xy,d.xy) < dot(d.zw,d.zw) ? vec4(d.xy, id.xy) : vec4(d.zw, id.zw);\n}\n\n#define TAU 6.2831853\nfloat cs(float x) { return cos(TAU*x); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = 42.*(fragCoord-0.333*iResolution.xy)/iResolution.y;\n    float t = iTime*.1;\n    s = mix( s, s.yx, 0.5-0.5*cs(t+0.04*cs(4.*t+0.25)) );\n    \n    //vec4 h = hexParityFloat( p );\n    //vec4 h = hexParityInt( p );\n    vec4 h = hexEvenOdd( p );\n\n    vec3 c = vec3(0.);\n    c.rb = fract( h.zw/8. );\n    c.g = fract( length(h.zw*s)/12.01 );              // h.zw*s is the tile center pos\n    if( h.z * h.w == 0. ) c = mix(c, vec3(1.), 0.8);  // brighten the axes\n    c *= (1.-0.5*mod(h.z,2.));                        // dim the odd coordinate tiles\n    c *= (1.-0.4*dot(h.xy,h.xy));                     // make them spherical\n    fragColor = vec4(c,1.0);\n}\n","name":"Image","description":"","type":"image"}]}