{"ver":"0.1","info":{"id":"7d23Dm","date":"1619593317","viewed":81,"name":"Mario Galaxy (wip)","username":"linlin64","description":"directional arrow to move the red ball\nspace to jump","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["3d","game","camera"],"hasliked":0,"parentid":"NsS3zw","parentname":"test circle alain"},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float M_PI = 3.14159265358979323846264338327950288;\n\n/*vec3 latLonTo3D(vec2 latlon) {\n    vec3 ret;\n    ret.x = sin(latlon.y) * cos(latlon.x);\n    ret.z = cos(latlon.y) * cos(latlon.x);    \n    ret.y = sin(latlon.x);\n    return ret;\n}*/\n\nvec4 render(in vec3 ray, in vec3 m, in vec3 normal, Sphere material) {\n    if (material.channel == 0 || material.channel == 1) {\n        vec3 P = m - material.center;\n\n        float lat = asin(P.y/length(P));\n        float v = (lat + M_PI/2.0) / M_PI;\n\n        float lon = -atan(P.z, P.x);\n        float test = lon + M_PI + M_PI/2.0;\n        if (test > M_PI * 2.0) {\n            test = test - M_PI*2.0;\n        }\n\n        float u =  test / (2.0*M_PI); \n\n        vec2 uv = vec2(u, v);\n        if (material.channel == 0) {\n            return texelFetch(iChannel2, ivec2(uv.x*1024.0f,uv.y*1024.0f),0);\n        } else {\n            return texelFetch(iChannel3, ivec2(uv.x*512.0f,uv.y*512.0f),0);\n        }\n    }\n    \n    vec3 Ptemp = m - material.center;\n    \n    /*float angle = iTime;\n    P.x = cos(angle)*Ptemp.x - sin(angle)*Ptemp.z;\n    P.y = Ptemp.y;\n    P.z = sin(angle)*Ptemp.x + cos(angle)*Ptemp.z;*/\n    mat3 mat = mat3 (\n        vec3(1,0,0),\n        vec3(0,1,0),\n        vec3(0,0,1)\n    );\n    vec3 P = mat * Ptemp;\n    \n    float lat = asin(P.y/length(P));\n    float v = (lat + M_PI/2.0) / M_PI;\n    \n    float lon = -atan(P.z, P.x);\n    float test = lon + M_PI + M_PI/2.0;\n    if (test > M_PI * 2.0) {\n        test = test - M_PI*2.0;\n    }\n    \n    float u =  test / (2.0*M_PI); \n    \n    vec2 uv = vec2(u, v);\n    \n    return vec4(1,0,0,1);//texelFetch(iChannel3, ivec2(uv.x*512.0f,uv.y*512.0f),0);\n}\n\nfloat map(in vec3 m, out Sphere sp) {\n    sp = spheres[0];\n    float mindist = length(m - spheres[0].center) - spheres[0].radius;\n    \n    for(int i = 0; i < 2; ++i) {\n        float dist = length(m - spheres[i].center) - spheres[i].radius;\n        if(dist < mindist) {\n            sp = spheres[i];\n            mindist = length(m - spheres[i].center) - spheres[i].radius;\n        }\n    }\n\n    vec3 mario = texelFetch(iChannel1, ivec2(0.0,0.0),0).xyz;\n\n    float distmario = length(m - mario) - 0.3;\n\n    if (distmario < mindist) {\n        sp.center = mario;\n        sp.radius = 0.3;\n        sp.channel = 2;\n        return distmario;\n    } else {\n        return mindist;\n    }\n    \n}\n\nbool rayMarching(in vec3 origin, in vec3 ray, out vec3 m, out Sphere material) {\n    \n    float\tmarchingDist = 0.0;\n    float \tnbIter \t\t = 0.0;\n\n    for(int i = 0; i<100; i++) {\n        \n        m = origin + ray * marchingDist;    \n        \n    \tfloat dist = map(m, material);\n        \n        if(dist < 0.01) {\n            return true;\n        }\n        else {\n            marchingDist += dist;\n            \n            if(marchingDist >= 500.) {\n                break;\n            }\n        }\n    }\n    \n\treturn false;    \n}\n\nvec3 computeNormal(in vec3 pos)\n{\n    Sphere material;\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t     map(pos+eps.xyy, material) - map(pos-eps.xyy, material),\n\t     map(pos+eps.yxy, material) - map(pos-eps.yxy, material),\n\t     map(pos+eps.yyx, material) - map(pos-eps.yyx, material));\n\treturn normalize(nor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ratio\t= iResolution.x/iResolution.y;\n    vec2 p1 = fragCoord.xy/iResolution.y - vec2(ratio/2.0, 0.5);\n\n    vec3 mario = texelFetch(iChannel1, ivec2(0.0,0.0),0).xyz;\n    int sphere = int(texelFetch(iChannel1, ivec2(1.0,0.0),0).x);\n\n    vec3 testperp = texelFetch(iChannel1, ivec2(2.0,0.0),0).xyz;\n\n    vec3 up = texelFetch(iChannel1, ivec2(4.0,0.0),0).xyz;\n\n    vec3 target = mario;\n\n    //vec2 test = normalize(spheres[0].center.yz - mario.yz);\n    //vec3 up = normalize(mario - spheres[sphere].center);\n    \n    //vec2 testperp = vec2(cos(angle), sin(angle));//test.y, -test.x);\n\n\n    vec3 ro = mario + normalize(mario - spheres[sphere].center)*1.5+ vec3(testperp.x, testperp.y, testperp.z) * 3.0;//vec3(0,4,2);\n\n    vec3 rd = normalize(vec3(p1, 1.));\n    vec3 k = normalize(target - ro);\n    vec3 i = normalize(cross(k, up));\n    vec3 j = cross(i, k);\n    \n    mat3 camera = mat3(i, j, k);\n    rd = camera * rd;\n    \n    vec3 p;\n    \n    Sphere material;\n    if(rayMarching(ro, rd, p, material)) {\n        vec3 normal = computeNormal(p);\n        fragColor = render(rd, p, normal, material);\n    } else {\n        fragColor = vec4(0.0, 0, 0, 1.0);        \n    }\n}\n    \n    \n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_SPACE  = 32;\n\nbool isPressed(int key) {\n   return bool(texelFetch( iChannel1, ivec2(key,0),0 ).x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 mario = texelFetch(iChannel0, ivec2(0.0,0.0),0).xyz;\n    int sphere = int(texelFetch(iChannel0, ivec2(1.0,0.0),0).x);\n    vec3 dir = texelFetch(iChannel0, ivec2(2.0,0.0),0).xyz;\n    int init = int(texelFetch(iChannel0, ivec2(3.0,0.0),0).x);\n    vec3 up = texelFetch(iChannel0, ivec2(4.0,0.0),0).xyz;\n    int state = int(texelFetch(iChannel0, ivec2(5.0,0.0),0).x);\n    float angle1 = texelFetch(iChannel0, ivec2(6.0,0.0),0).x;\n    int presspace = int(texelFetch(iChannel0, ivec2(7.0,0.0),0).x);\n    float angletarget = texelFetch(iChannel0, ivec2(8.0,0.0),0).x;\n    vec3 speed = texelFetch(iChannel0, ivec2(9.0,0.0),0).xyz;\n    vec3 accel = texelFetch(iChannel0, ivec2(10.0,0.0),0).xyz;\n\n    if (init == 0) {\n        mario = vec3(0,3.3,0);\n        dir = vec3(0,0,1);\n        sphere = 0;\n        up = normalize(mario - spheres[sphere].center);\n        state = 2;\n    }\n\n    bool moveallow = length(spheres[sphere].center - mario) - 0.3 - spheres[sphere].radius < 0.01\n      && isPressed(KEY_SPACE) == false;\n\n    bool move = false;\n    bool inv = false;\n    vec3 marionew = mario;\n    if(moveallow) {\n        if(isPressed(KEY_UP)) {\n            marionew = mario - dir * 0.016;\n            inv = true;\n            move = true;\n        } else if(isPressed(KEY_DOWN)) {\n            marionew = mario + dir * 0.016;\n            move = true;\n        }\n    }\n\n    float angle = 0.0;\n    if(isPressed(KEY_RIGHT)) {\n        angle = 0.1;\n    } else if(isPressed(KEY_LEFT)) {\n        angle = -0.1;\n    }\n\n\n    accel = -normalize(mario - spheres[sphere].center) * 1.08f;\n    if(isPressed(KEY_SPACE) /*&& length(spheres[sphere].center - marionew) - 0.3 - spheres[sphere].radius < 0.5*/) {\n        //speed += 0.08;\n        accel += normalize(mario - spheres[sphere].center) * 10.1f;\n    }\n    speed += accel * 0.016;\n    marionew += speed * 0.016;// * normalize(marionew - spheres[sphere].center);// * 1.7;\n\n\n    //if (sphere == 0) {\n        //marionew += normalize(spheres[sphere].center - mario) * 0.08;\n\n        if (length(spheres[sphere].center - marionew) - 0.3 - spheres[sphere].radius < 0.0) {\n            marionew = spheres[sphere].center + normalize(marionew-spheres[sphere].center)*(spheres[sphere].radius + 0.3);\n            accel = vec3(0);\n            speed = vec3(0);\n        }\n    //}    \n    \n    if (sphere == 1 && length(marionew-spheres[0].center) < length(marionew-spheres[1].center) - 0.1) {\n        state = 0;\n    }\n    if (sphere == 0 && length(marionew-spheres[1].center) < length(marionew-spheres[0].center) - 0.1) {\n        state = 0;\n    }\n    \n    if (length(marionew-spheres[0].center) < length(marionew-spheres[1].center) - 0.1) {\n        sphere = 0;\n        //state = 0;\n    }\n    if (length(marionew-spheres[1].center) < length(marionew-spheres[0].center) - 0.1) {\n        sphere = 1;\n        //state = 0;\n    }\n    \n    if (move)\n        dir = normalize(marionew - mario);\n    \n\n    if(inv)\n        dir *= -1.;\n\n    vec3 axis = marionew - spheres[sphere].center;\n    mat3 mat = mat3 (\n        vec3(cos(angle)+(1.0-cos(angle))*axis.x*axis.x,\n            (1.0-cos(angle))*axis.x*axis.y-sin(angle)*axis.z,\n            (1.0-cos(angle))*axis.x*axis.z+sin(angle)*axis.y),\n            \n            \n            \n        vec3((1.0-cos(angle))*axis.x*axis.y+sin(angle)*axis.z,\n            cos(angle)+(1.0-cos(angle))*axis.y*axis.y,\n            (1.0-cos(angle))*axis.y*axis.z-sin(angle)*axis.x),\n            \n        vec3(\n            (1.0-cos(angle))*axis.x*axis.z-sin(angle)*axis.y,\n            (1.0-cos(angle))*axis.y*axis.z+sin(angle)*axis.x,\n               cos(angle)+(1.0-cos(angle))*axis.z*axis.z)\n    );\n\n    dir = normalize(mat * dir);\n\n        \n\nif(sphere == 1) {\n                up = normalize(mario - spheres[1].center);\n    if(state == 0) {\n        angle1 = 0.0;\n        angletarget = acos(dot(normalize(mario - spheres[1].center), normalize(mario-spheres[0].center)));\n        //cross(normalize(spheres[1].center- mario), normalize(spheres[0].center-mario));\n        //up = normalize(mario - spheres[1].center);\n        state = 1;\n    } else if (state == 1) {\n        //state = 2;\n        up = normalize(mario - spheres[1].center);\n\n        if (angle1 < angletarget) {\n            vec3 crosspro = dir;//vec3(0,1,0);\n            angle1 += 0.1;\n            //vec3 axis = marionew - spheres[sphere].center;\n            mat3 mat = mat3 (\n                vec3(cos(angle1)+(1.0-cos(angle1))*crosspro.x*crosspro.x,\n                    (1.0-cos(angle1))*crosspro.x*crosspro.y-sin(angle1)*crosspro.z,\n                    (1.0-cos(angle1))*crosspro.x*crosspro.z+sin(angle1)*crosspro.y),\n\n\n\n                vec3((1.0-cos(angle1))*crosspro.x*crosspro.y+sin(angle1)*crosspro.z,\n                    cos(angle1)+(1.0-cos(angle1))*crosspro.y*crosspro.y,\n                    (1.0-cos(angle1))*crosspro.y*crosspro.z-sin(angle1)*crosspro.x),\n\n                vec3(\n                    (1.0-cos(angle1))*crosspro.x*crosspro.z-sin(angle1)*crosspro.y,\n                    (1.0-cos(angle1))*crosspro.y*crosspro.z+sin(angle1)*crosspro.x,\n                       cos(angle1)+(1.0-cos(angle1))*crosspro.z*crosspro.z)\n            );\n\n            up = normalize(mario - spheres[0].center);\n\n            up = normalize(mat * up);\n            //dir = vec3(0,1,0);\n        } else {\n            state = 2;\n            up = normalize(mario - spheres[1].center);\n        }\n    } /*else {\n        up = normalize(mario - spheres[1].center);*/\n        /*state = 2;*/\n    //}\n    \n} else {\n    if(state == 0) {\n        angle1 = 0.0;\n        angletarget = acos(dot(normalize(mario - spheres[0].center), normalize(mario-spheres[1].center)));\n        state = 1;\n    } else if (state == 1) {\n        if (angle1 < angletarget) {\n            vec3 crosspro = dir;//vec3(0,1,0);\n            angle1 += 0.1;\n            //vec3 axis = marionew - spheres[sphere].center;\n            mat3 mat = mat3 (\n                vec3(cos(angle1)+(1.0-cos(angle1))*crosspro.x*crosspro.x,\n                    (1.0-cos(angle1))*crosspro.x*crosspro.y-sin(angle1)*crosspro.z,\n                    (1.0-cos(angle1))*crosspro.x*crosspro.z+sin(angle1)*crosspro.y),\n\n\n\n                vec3((1.0-cos(angle1))*crosspro.x*crosspro.y+sin(angle1)*crosspro.z,\n                    cos(angle1)+(1.0-cos(angle1))*crosspro.y*crosspro.y,\n                    (1.0-cos(angle1))*crosspro.y*crosspro.z-sin(angle1)*crosspro.x),\n\n                vec3(\n                    (1.0-cos(angle1))*crosspro.x*crosspro.z-sin(angle1)*crosspro.y,\n                    (1.0-cos(angle1))*crosspro.y*crosspro.z+sin(angle1)*crosspro.x,\n                       cos(angle1)+(1.0-cos(angle1))*crosspro.z*crosspro.z)\n            );\n\n            up = normalize(mario - spheres[1].center);\n\n            up = normalize(mat * up);\n            //dir = vec3(0,1,0);\n        } else {\n            state = 2;\n            up = normalize(mario - spheres[0].center);\n        }\n    } else {\n        up = normalize(mario - spheres[0].center);\n    }\n}\n\n\n//(1 - c) * x * z + s * y\n//(1 - c) * y * z - s * x\n//c + (1 - c) * z²\n\n//|   c + (1 - c) * x²           (1 - c)* x * y - s * z      (1 - c) * x * z + s * y  | \n//|   (1 - c) * x * y + s * z    c + (1 - c) * y²            (1 - c) * y * z - s * x  | \n//|   (1 - c) * x * z - s * y    (1 - c) * y * z + s * x     c + (1 - c) * z²         |\n\n    if (fragCoord.x >= 0.0 \n        && fragCoord.x < 1.0\n        && fragCoord.y >= 0.0 \n        && fragCoord.y < 1.0) {\n        fragColor = vec4(marionew, 1);\n        return;\n    } else if (fragCoord.x >= 1.0 \n        && fragCoord.x < 2.0\n        && fragCoord.y >= 0.0 \n        && fragCoord.y < 1.0) {\n        fragColor = vec4(sphere,0,0, 1);\n        return;\n     } else if (fragCoord.x >= 2.0 \n        && fragCoord.x < 3.0\n        && fragCoord.y >= 0.0 \n        && fragCoord.y < 1.0) {\n        fragColor = vec4(dir, 1);\n        return;\n     } else if (fragCoord.x >= 3.0 \n        && fragCoord.x < 4.0\n        && fragCoord.y >= 0.0 \n        && fragCoord.y < 1.0) {\n        fragColor = vec4(1,0,0, 1);\n        return;\n     } else if (fragCoord.x >= 4.0 \n        && fragCoord.x < 5.0\n        && fragCoord.y >= 0.0 \n        && fragCoord.y < 1.0) {\n        fragColor = vec4(up, 1);\n        return;\n     } else if (fragCoord.x >= 5.0 \n        && fragCoord.x < 6.0\n        && fragCoord.y >= 0.0 \n        && fragCoord.y < 1.0) {\n        fragColor = vec4(state, 0,0, 1);\n        return;\n     } else if (fragCoord.x >= 6.0 \n        && fragCoord.x < 7.0\n        && fragCoord.y >= 0.0 \n        && fragCoord.y < 1.0) {\n        fragColor = vec4(angle1, 0,0, 1);\n        return;\n     } else if (fragCoord.x >= 7.0 \n        && fragCoord.x < 8.0\n        && fragCoord.y >= 0.0 \n        && fragCoord.y < 1.0) {\n        fragColor = vec4(presspace, 0,0, 1);\n        return;\n     } else if (fragCoord.x >= 8.0 \n        && fragCoord.x < 9.0\n        && fragCoord.y >= 0.0 \n        && fragCoord.y < 1.0) {\n        fragColor = vec4(angletarget, 0,0, 1);\n        return;\n     } else if (fragCoord.x >= 9.0 \n        && fragCoord.x < 10.0\n        && fragCoord.y >= 0.0 \n        && fragCoord.y < 1.0) {\n        fragColor = vec4(speed, 1);\n        return;\n     } else if (fragCoord.x >= 10.0 \n        && fragCoord.x < 11.0\n        && fragCoord.y >= 0.0 \n        && fragCoord.y < 1.0) {\n        fragColor = vec4(accel, 1);\n        return;\n     }\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"struct Sphere {\n    vec3 center;\n    int channel;\n    float radius;\n};\n\nSphere spheres [] = Sphere[2] (\n    Sphere(vec3(0,0,0), 0, 2.),\n    Sphere(vec3(0,0,-7), 1, 2.)\n);\n","name":"Common","description":"","type":"common"}]}