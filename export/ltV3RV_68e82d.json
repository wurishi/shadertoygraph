{"ver":"0.1","info":{"id":"ltV3RV","date":"1475709600","viewed":165,"name":"Remarch v1.0","username":"efairbanks","description":"A rewrite of my variation on ray-marching, which is honestly not very innovative and is probably pretty inefficient. Cut me some slack, I started learning about fragment shaders six days ago. Couldn't have done it without the awesome ShaderToy community.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarcher"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MARCH_STEPS 128.0\n#define MARCH_EPSILON 0.001\n#define SHADOW_STEPS 40.0\n#define SHADOW_EPSILON 0.01\n#define GRADIENT_STEP 0.02\n\n#define M_PI 3.1415926535897932384626433832795\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat torus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat box(vec3 p, vec3 b, float roundness)\n{\n\treturn length(max(abs(p)-(b-vec3(roundness)),0.0))-roundness;\n}\n\nfloat cylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat cone( vec3 p, vec2 c )\n{\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat plane( vec3 p, vec4 n )\n{\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat hexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\nfloat triPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat capsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat cappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat cappedCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 v = vec2( c.z*c.y/c.x, -c.z );\n    vec2 w = v - q;\n    vec2 vv = vec2( dot(v,v), v.x*v.x );\n    vec2 qv = vec2( dot(v,w), v.x*w.x );\n    vec2 d = max(qv,0.0)*qv/vv;\n    return sqrt( dot(w,w) - max(d.x,d.y) ) * sign(max(q.y*v.x-q.x*v.y,w.y));\n}\n\nfloat ellipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat triangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat quad( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 dc = d - c; vec3 pc = p - c;\n    vec3 ad = a - d; vec3 pd = p - d;\n    vec3 nor = cross( ba, ad );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(dc,nor),pc)) +\n     sign(dot(cross(ad,nor),pd))<3.0)\n     ?\n     min( min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n     dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\n// --- //\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp(0.5+0.5*(b-a)/k,0.0,1.0);\n    return mix(b,a,h)-k*h*(1.0-h);\n}\n\n// ----------------------------------------------- //\n// --- NOTES ON DISTANCE FIELD TRANSFORMATIONS --- //\n// ----------------------------------------------- //\n\n// UNION:\t\tmin(d1,d2)\n// SUBTRACT:\tmax(-d1,d2)\n// INTERSECT:\tmax(d1,d2)\n// REPEAT:\t\tmap(mod(p,c)-0.5*c)\n// SCALE:\t\tmap(p/s)*s\n// ROTATE:\t\tmap(invert(m)*p)\t// where m == 4x4 rot matrix\n/*\n\nfloat twist( vec3 p )\n{\n    float c = cos(20.0*p.y);\n    float s = sin(20.0*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return primitive(q);\n}\n\nfloat bend( vec3 p )\n{\n    float c = cos(20.0*p.y);\n    float s = sin(20.0*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    return primitive(q);\n}\n\n*/\n\n// ----------------------------------------------- //\n// ----------------------------------------------- //\n// ----------------------------------------------- //\n\n// field of view of camera\n#define FOV 0.001\n// generate combined distance field\nfloat map(vec3 p)\n{\n    vec3 q = p;\n    q.xyz = mod(p.xyz,vec3(5.0))-2.5;\n    \n    // draw rounded box\n    float boxSize = 2.;\n\tfloat d = box(q,vec3(boxSize), boxSize/3.);\n    d = max(d,sphere(p,boxSize*10.));\n\n\treturn d;\n}\n\n// raymarching procedure with lots of output info\nvoid march(vec3 origin, vec3 direction, out vec3 rayHead, out bool hit, out float dist, out float steps)\n{\n    float distanceTraveled = 0.;\n    hit = true;\n    for(float step=0.; step<MARCH_STEPS; step++)\n    {\n        rayHead = origin + (direction*distanceTraveled);\n        dist = map(rayHead);\n        steps = step;\n        if(dist<MARCH_EPSILON||step>=MARCH_STEPS) return;\n        distanceTraveled += dist;\n    }\n    hit = false;\n}\n\n// get origin and direction of ray to be cast for camera/screen xy (pixel) coordinate\nvoid cameraRay(vec2 scanLines, vec3 cameraPosition, vec3 target, float fov, out vec3 pos, out vec3 dir)\n{\n\tvec3 forward = normalize(target-cameraPosition);\n    vec3 up = vec3(0.,1.,0.);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(forward,right));\n    \n    right = right*scanLines.x*fov;\n    up = up*scanLines.y*fov;\n    \n    pos = cameraPosition;\n    dir = (right+up+forward);\n}\n\n// get surface normal of point on distance field for shading\nvec3 gradient( vec3 pos )\n{\n\tconst vec3 dx = vec3( GRADIENT_STEP, 0.0, 0.0 );\n\tconst vec3 dy = vec3( 0.0, GRADIENT_STEP, 0.0 );\n\tconst vec3 dz = vec3( 0.0, 0.0, GRADIENT_STEP );\n\treturn normalize(vec3(\n\t\tmap( pos + dx ) - map( pos - dx ),\n\t\tmap( pos + dy ) - map( pos - dy ),\n\t\tmap( pos + dz ) - map( pos - dz )\n\t));\n}\n\n// calculate diffuse lighting for point on distance field given surface normal\nfloat diffuse(vec3 normal, vec3 lightPosition)\n{\n\treturn max(dot(normal,normalize(lightPosition)),0.);\n}\n\n// calculate diffuse lighting for point on distance field\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<int(SHADOW_STEPS); i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<SHADOW_EPSILON || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// calculate combined lighting for point on distance field\nfloat shadePoint(vec3 position, vec3 normal, vec3 lightPosition)\n{\n    float diffuseLight = diffuse(normal, lightPosition);\n\t// speculative light - it might be specular, but we're not really sure\n    float specularLight = pow(diffuseLight,30.);\n\tfloat shadow = softshadow(position, normalize(lightPosition), 0.02, 2.25);\n    return (diffuseLight+specularLight)*shadow;\n}\n\n// generate background color\nvec3 background(vec2 uv)\n{\n\treturn vec3(0.5,0.5,0.5)*uv.y;\n}\n\n// compose image\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    // scale coordinates to -1 -> +1, adjusted for screen aspect ratio\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = uv*2.-1.;\n    uv.x = uv.x*iResolution.x/iResolution.y;\n    \n    // get mouse coords\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    \n    // get ray representing camera scanline position and direction\n    float cameraRotationSpeed = 0.2;\n    vec3 cameraPosition = normalize(vec3(sin(iTime*cameraRotationSpeed),\n                                         sin(iTime*cameraRotationSpeed),\n                                         cos(iTime*cameraRotationSpeed)));\n    if(iMouse.z>0.)\n        cameraPosition = normalize(vec3(\tsin(mouse.x*2.*M_PI),\n                                        \t(mouse.y*2.-1.),\n                                        \tcos(mouse.x*2.*M_PI)));\n    cameraPosition *= 20000.;\n    vec3 cameraOrigin;\n    vec3 cameraDirection;\n    cameraRay(uv, cameraPosition, vec3(0.,0.,0.), FOV, cameraOrigin, cameraDirection);\n    \n    // calculate distance, hit point, etc of distance field via raymarching\n    vec3 rayHead;\n    bool hit;\n    float dist;\n    float steps = 40.;\n    march(cameraOrigin, cameraDirection, rayHead, hit, dist, steps);\n    \n    // calculate normal for point on distance field\n    vec3 normal = gradient(rayHead);\n    \n    // calculate light for point\n\tvec3 rotLightPos = vec3(-0.5,-1.,0.);\n    vec3 latRotLightPos = vec3(0.,-1.,-1.);\n    vec3 lightPos = vec3(cos(iTime),sin(iTime),cos(iTime));\n    float light = 0.;\n    light += shadePoint(rayHead, normal, rotLightPos);\n    light += shadePoint(rayHead, normal, latRotLightPos);\n    light += shadePoint(rayHead, normal, lightPos);\n    light /= 3.;\n    \n    // specify color of entire distance field\n    vec3 fieldColor = vec3(1.0,0.4,0.4);\n    \n    // final steps and background\n    vec3 color = fieldColor*light;\n    if(!hit) color = background(uv);\n    \n    // set fragment shader color\n    fragColor = vec4(color,1.);\n}\n\n","name":"Image","description":"","type":"image"}]}