{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"keyboard","id":"4dXGRr","filepath":"/presets/tex00.jpg","sampler":{"filter":"nearest","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// \"Near enough\" threshold for hit testing\nconst float epsilon = 1.;\n\n// This one you've seen before.\nconst float pi = 3.14159265358;\n\n// Light source intensity\nconst float i_a = 0.3;\nconst float i_d = 0.6;\nconst float i_s = 0.4;\n\n// Material reflectiveness and color\nconst float k_a = 0.6;\nconst float k_d = 0.7;\nconst float k_s = 0.8;\nconst float alpha = 8.;\nconst vec3 matColor = vec3(1, 0.8, 0.3);\n\n// Mnemonic synonyms for field combinators.\n// Without these, I keep mixing them up. :-\\\n\n// \"union\" is apparently reserved, hence the underscore.\nfloat _union(float d1, float d2) {\n\treturn min(d1, d2);\n}\n\nfloat intersection(float d1, float d2) {\n\treturn max(d1, d2);\n}\n\n// Rounded version of min/union.  Hat tip to colah.\n// This produces a \"rolled ball\" blend of radius r.\nfloat runion(float r, float x, float y) {\n\treturn (abs(x - y) < r)\n\t\t? y + r * sin(pi / 4. + asin((x - y) / r / sqrt(2.))) - r\n\t\t: min(x, y);\n}\n\n// Rotates a vector by a radians around Y.\nvec3 roty(float a, vec3 p) {\n\treturn p * mat3(cos(a), 0, sin(a),\n\t\t\t\t\t0,      1, 0,\n\t\t\t\t\t-sin(a), 0, cos(a));\n}\n\n// Distance field of a sphere at c with radius r, sampled at p.\nfloat sphere(vec3 c, float r, vec3 p) {\n\treturn length(p - c) - r;\n}\n\n// Distance field of a halfspace.  The closest point to the origin is\n// d units away along normal vector n.\nfloat halfspace(vec3 n, float d, vec3 p) {\n\treturn dot(p, n) - d;\n}\n\n// Distance field of a cube, centered at the origin, with width w.\n// Computed by intersection of bounding halfspaces.\nfloat cube(float w, vec3 p) {\n\tfloat d = w/2.;\n\t\n\tfloat d0 = halfspace(vec3( 1,  0,  0), d, p);\n\tfloat d1 = halfspace(vec3(-1,  0,  0), d, p);\n\tfloat d2 = halfspace(vec3( 0,  1,  0), d, p);\n\tfloat d3 = halfspace(vec3( 0, -1,  0), d, p);\n\tfloat d4 = halfspace(vec3( 0,  0,  1), d, p);\n\tfloat d5 = halfspace(vec3( 0,  0, -1), d, p);\n\t\n\treturn intersection(\n\t\tintersection(intersection(d0, d1), \n\t\t\t\t\t intersection(d2, d3)), \n\t\tintersection(d4, d5));\n}\n\n// The Scene\nfloat distanceField(vec3 pos) {\n\tfloat t = (sin(iTime)) * 150.;\n\t\n\tfloat s1 = sphere(vec3(t,0,0), 100., pos);\n\tfloat s2 = cube(200., roty(iTime, pos - vec3(-t, 0, 0)));\n\t\n\tfloat tx = (sin(iTime)) * 230.;\n\tfloat ty = (cos(iTime)) * 230.;\n\tfloat s3 = sphere(vec3(tx,ty,0), 30., pos);\n\t\n\treturn runion(10., runion(70., s1, s3), s2);\n}\n\n// Approximates the normal vector at pos.\nvec3 distanceFieldNormal(vec3 pos) {\n\t// Method of central differences.\n\tconst float s = 1. / 2.;\n\t\n\tvec3 n = vec3(distanceField(pos + vec3(s, 0, 0)) - distanceField(pos - vec3(s, 0, 0)),\n\t\t\t\t  distanceField(pos + vec3(0, s, 0)) - distanceField(pos - vec3(0, s, 0)),\n\t\t\t\t  distanceField(pos + vec3(0, 0, s)) - distanceField(pos - vec3(0, 0, s)));\n\treturn normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat near = -iResolution.x * 1.2 / 2.;\n\tfloat far  =  iResolution.x * 1.2 / 2.;\n\t\n\tvec3 cameraPosition = vec3(0, 0, -1);\n\t\n\tvec3 pos = vec3(fragCoord.xy - iResolution.xy / 2., near);\n\t\n\tvec3 npos = pos / iResolution.x;\n\t\n\tvec3 dir = normalize(npos - cameraPosition);\n\tvec3 toEye = -dir;\n\t\n\tvec2 nmouse = (iMouse.xy - iResolution.xy / 2.) / iResolution.x * 5.;\n\tvec3 l_m = vec3(nmouse, -1);\n\t\n\tfloat theta = iTime / 5.;\n\tvec3 toEyeRot = roty(theta, toEye);\n\t\n    int stepsTaken = 0;\n    for (int steps = 0; steps < 50; ++steps) {\n\t    \n\t\tstepsTaken = steps;\n\t\tvec3 qp = roty(theta, pos);\n\t\tfloat d = distanceField(qp);\n\t\t\n\t\tif (d < epsilon) {\n\t\t\t// Hit!  Light the surface using Phong reflectance.\n\t\t\tvec3 normal = distanceFieldNormal(qp);\n\t\t\tvec3 nl_m = normalize(l_m);\n\t\t\tvec3 r_m = -reflect(nl_m, normal);\n\t\t\t\n\t\t\tfloat ambient = i_a * k_a;\n\t\t\tfloat diffuse = i_d * k_d * max(dot(nl_m, normal), 0.);\n\t\t\tfloat spec    = i_s * k_s * pow(max(dot(r_m, toEyeRot), 0.), alpha);\n\t\t\t\n\t\t\tvec3 light = matColor * (ambient + diffuse) + spec;\n\t\t\tfragColor = vec4(light, 1);\n\t\t\treturn;\n\t\t} else {\n\t\t\tpos += d * dir;\n\t\t}\n\t}\n\t\n\tvec4 complexity = vec4(sin(float(stepsTaken - 8) / 8.),\n\t\t\t\t\t\t   sin(float(stepsTaken) / 8.),\n\t\t\t\t\t\t   sin(clamp(float(stepsTaken) / 4. + pi/2., pi/2., pi)),\n\t\t\t\t\t\t   1);\n\t\n\tvec4 color = mix(vec4(0.1, 0.1, 0.3, 1),\n\t\t\t\t     complexity,\n\t\t\t\t     texture(iChannel0, vec2(83.5/256., 0.75)).x);\n\tcolor = sqrt(color);  // Approximate gamma correction\n\tfragColor = color;\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":true,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MsXGRl","date":"1376493976","viewed":563,"name":"Simple Implicit Surface","username":"cbiffle","description":"A very basic implicit surface raytracer, showing blended interaction of three primitives.\n\nDrag the mouse around the image to move the light source.  Press S to toggle the raymarching complexity display -- blue means few steps, red means many.","likes":3,"published":1,"flags":16,"usePreview":0,"tags":["raytracing","raymarching","implicitsurface","spheretracing","implicit"],"hasliked":0,"parentid":"","parentname":""}}