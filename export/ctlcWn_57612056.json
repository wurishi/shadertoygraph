{"ver":"0.1","info":{"id":"ctlcWn","date":"1692268711","viewed":81,"name":"Halftone Zoom haleyhalcy 719","username":"HaleyHalcyon","description":"Loops in 8 seconds (Change length in “Buffer A” tab).\nCan dither randomly, cross-hatch, or not at all. Change dither mode in “Image” tab.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["halftone"],"hasliked":0,"parentid":"dlXczN","parentname":"halftone zoom inspired by posy"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// For GIF export: enable dither to reduce color count te 8\n#define DITHER 1\n#if DITHER == 1\nfloat thres(vec2 xyf, int t) {\n    ivec2 xy = ivec2(xyf) & 3;\n    return (float(\n        + ((xy.y >> 1) & 1)\n        + ((xy.x & 2) ^ (xy.y & 2))\n        + ((xy.y & 1) << 2)\n        + ((((xy.x) & 1) ^ (xy.y & 1)) << 3)\n    ) + 0.5) / 16.;\n}\n#endif\n#if DITHER == 2\n// random ints from 0 to 255\nint rand[] = int[] (\n244,\t69,\t224,\t39,\t208,\t151,\t201,\t255,\t189,\t202,\t157,\t92,\t206,\t154,\t199,\t194,\t232,\t101,\t216,\t134,\t62,\t242,\t163,\t248,\t140,\t183,\t120,\t90,\t215,\t30,\t211,\t186,\t150,\t100,\t57,\t106,\t118,\t142,\t61,\t246,\t11,\t230,\t141,\t55,\t147,\t180,\t27,\t226,\t99,\t125,\t122,\t13,\t2,\t112,\t192,\t60,\t137,\t80,\t198,\t252,\t94,\t245,\t162,\t113,\t24,\t146,\t49,\t110,\t253,\t81,\t10,\t165,\t109,\t115,\t218,\t0,\t254,\t129,\t71,\t88,\t187,\t114,\t176,\t243,\t7,\t87,\t45,\t209,\t23,\t168,\t103,\t121,\t93,\t153,\t22,\t133,\t34,\t78,\t241,\t182,\t221,\t38,\t136,\t104,\t18,\t105,\t164,\t65,\t91,\t25,\t132,\t119,\t174,\t173,\t15,\t170,\t29,\t37,\t212,\t210,\t44,\t169,\t181,\t251,\t4,\t8,\t229,\t79,\t32,\t21,\t203,\t214,\t75,\t12,\t225,\t97,\t40,\t35,\t28,\t64,\t231,\t19,\t185,\t123,\t236,\t77,\t238,\t5,\t128,\t179,\t127,\t48,\t72,\t156,\t190,\t54,\t124,\t250,\t205,\t161,\t228,\t56,\t158,\t207,\t148,\t17,\t95,\t52,\t111,\t126,\t36,\t74,\t197,\t152,\t160,\t20,\t219,\t130,\t66,\t239,\t240,\t6,\t108,\t47,\t116,\t213,\t237,\t138,\t70,\t33,\t26,\t46,\t96,\t53,\t41,\t200,\t59,\t58,\t135,\t83,\t235,\t31,\t131,\t63,\t42,\t1,\t149,\t139,\t247,\t9,\t159,\t73,\t98,\t222,\t68,\t51,\t67,\t144,\t82,\t233,\t177,\t155,\t178,\t50,\t143,\t84,\t184,\t85,\t217,\t166,\t193,\t145,\t89,\t107,\t172,\t76,\t117,\t196,\t86,\t220,\t3,\t171,\t223,\t16,\t167,\t195,\t191,\t102,\t14,\t188,\t227,\t234,\t204,\t249,\t43,\t175\n);\nfloat thres(vec2 xyf, int t) {\n    ivec2 xy = ivec2(xyf);\n    \n    return (0.5 + float(\n        rand[\n            (t + rand[\n                ((xy.x >> 4) + xy.y + rand[\n                    ((xy.y >> 4) + xy.x) & 255\n                ]) & 255\n            ]) & 255\n        ]\n    )) / 256.;\n}\n#endif\n\n#define HEX(x) vec3((ivec3(x) >> ivec3(16, 8, 0)) & 255) / 255.\n\nvec3 colormap(vec3 rgb) {\n    const vec3 c000 = HEX(0x010a31);\n    const vec3 c001 = HEX(0x000068);\n    const vec3 c011 = HEX(0x009be8);\n    const vec3 c010 = HEX(0x20a220);\n    const vec3 c110 = HEX(0xfff100);\n    const vec3 c100 = HEX(0xcb1018);\n    const vec3 c101 = HEX(0xeb0072);\n    const vec3 c111 = HEX(0xffffff);\n    \n    vec3 c00x = mix(c000, c001, rgb.b);\n    vec3 c01x = mix(c010, c011, rgb.b);\n    vec3 c10x = mix(c100, c101, rgb.b);\n    vec3 c11x = mix(c110, c111, rgb.b);\n    \n    vec3 c0xx = mix(c00x, c01x, rgb.g);\n    vec3 c1xx = mix(c10x, c11x, rgb.g);\n    \n    return mix(c0xx, c1xx, rgb.r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec4 cmyk = texture(iChannel0, fragCoord / iResolution.xy);\n    cmyk = mix(cmyk, (\n        texture(iChannel0, (vec2(1, 0) + fragCoord) / iResolution.xy) +\n        texture(iChannel0, (vec2(-1, 0) + fragCoord) / iResolution.xy) +\n        texture(iChannel0, (vec2(0, 1) + fragCoord) / iResolution.xy) +\n        texture(iChannel0, (vec2(0, -1) + fragCoord) / iResolution.xy)\n    ) / 4., 0.75);\n    \n    cmyk = 1. - cmyk;\n    vec3 col = cmyk.xyz * cmyk.w;\n#if DITHER != 0\n    float thres = thres(fragCoord, iFrame);\n    const float STEPS = 1.;\n    col = (\n        floor(col * STEPS) +\n        step(vec3(thres), fract(col * STEPS))\n    ) / STEPS;\n#endif\n    col = colormap(col);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float PI_2 = acos(-1.) * .5;\n#define ZIG(x) (1. - abs(1. - 2. * fract(x)))\n#define ROT(x) mat2x2(cos(x + PI_2 * vec4(0, 1, -1, 0)))\n\nfloat depthFunc( float depth ) {\n    return smoothstep(\n        0.2, 0.8, min(depth, 2. - depth)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2. * fragCoord - iResolution.xy) / length(iResolution.xy);\n\n    float t = fract(0.5 + iTime / 8.);\n    \n    // zoom level per layer\n    const float LEVEL = 5.;\n    \n    uv *= exp2(5. - t * LEVEL);\n    \n    // Time varying pixel color\n    vec4 cmyk = vec4(0);\n    \n    float rotOffset = 0.4 * PI_2;\n    mat2x2[] rots = mat2x2[](\n        ROT(rotOffset + (t + 1. / 6.) * PI_2),\n        ROT(rotOffset + (t - 1. / 6.) * PI_2),\n        ROT(rotOffset +  t            * PI_2),\n        ROT(rotOffset + (t + 1. / 2.) * PI_2)\n    );\n    \n    const float DENSITY = 0.8;\n    for (int channel = 0; channel < 4; channel++) {\n        for (float depth = 0.; depth < 2.; depth++) {\n            vec2 thisUV = uv * rots[channel] * exp2(-depth * LEVEL);\n            float layerAlpha = depthFunc(depth + t);\n            float radiusCircle = length(ZIG(thisUV));\n            radiusCircle = smoothstep(\n                -0.2, 0.2,\n                DENSITY - radiusCircle\n            );\n            \n            float radiusDot = length(ZIG(thisUV * exp2(LEVEL)));\n            \n            radiusDot = smoothstep(\n                -0.2, 0.2,\n                -0.1 + (DENSITY - radiusDot) - (1. - radiusCircle)\n            );\n            float v = radiusDot;\n            cmyk[channel] += smoothstep(\n                0.0,\n                0.2,\n                v\n            ) * layerAlpha;\n        }\n    }\n\n    // Output to screen\n    fragColor = cmyk;\n}","name":"Buffer A","description":"","type":"buffer"}]}