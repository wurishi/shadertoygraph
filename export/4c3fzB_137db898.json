{"ver":"0.1","info":{"id":"4c3fzB","date":"1733212649","viewed":214,"name":"Height Field Testbed","username":"ShadingKnight","description":"Height Field Testbed","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["terrian"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Terrian Created by evilryu https://www.shadertoy.com/view/Xd3fR7 (License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.)\n\n#define OUTPUT_HEIGHT_MAP 0\n#define OUTPUT_BASE_COLOR 0\n\nvec3 sun_dir = normalize(vec3(2., 1.5, -0.6));\nvec3 sun_col = 2. * vec3(1.);\n\nfloat bump(vec3 p, vec3 n)\n{\n    return dot(texcube(iChannel0, 0.25*p, n).xyz, vec3(0.299, 0.587, 0.114)); \n}\n\nvec3 bump_mapping(vec3 p, vec3 n, float weight)\n{\n    vec2 e = vec2(2./iResolution.y, 0); \n    vec3 g=vec3(bump(p-e.xyy, n)-bump(p+e.xyy, n),\n                bump(p-e.yxy, n)-bump(p+e.yxy, n),\n                bump(p-e.yyx, n)-bump(p+e.yyx, n))/(e.x*2.);  \n    g=(g-n*dot(g,n));\n    return normalize(n+g*weight);\n}\n\nfloat terrian_shadow(vec3 ro, vec3 rd, vec2 fragCoord)\n{\n    float res=1.0;\n    float t= .5 + 0.5 * hash1(fragCoord);\n\n    float h;    \n    for(int i=0; i<20; i++)\n    {\n        vec3 p=ro + t * rd;\n        h=p.y-terrian(p.xz);\n        res=min(16.0*h/t, res);\n        t+=clamp(h,1.+.1*t,30.);\n        if(res<0.001*t)\n            break;\n    }\n    \n    return clamp(res, 0., 1.);\n}     \n\nvec3 terrian_material(vec3 pos, vec3 n)\n{\n    float tree_pdf=smoothstep(0.,.5,n.y);\n    tree_pdf*=1.-smoothstep(20.,50.,pos.y);\n    vec3 mate=pow(texcube(iChannel0, pos*0.008, n).xyz,vec3(3.));\n    mate=mix(mate, .05*vec3(.7, 1., .2), tree_pdf);\n    tree_pdf=smoothstep(0.2,.3,n.y)*smoothstep(50.,200.,pos.y);\n    mate=mix(mate, .08*vec3(.5, 1., .2), tree_pdf);\n\treturn mate;\n}\n\nvec3 render_terrian(vec3 ro, vec3 rd, float t, vec2 fragCoord)\n{\n    vec3 pos=ro+t*rd;\n    vec3 n=terrian_normal(pos.xz, t);\n\n    vec3 sky = vec3(0.2,0.7,1.);\n    \n    vec3 mate=terrian_material(pos, n);\n    n=bump_mapping(pos*.1,n,0.15);\n    float sha=terrian_shadow(pos+.5*n, sun_dir, fragCoord);\n    float dif=max(0.,dot(n,sun_dir));\n    float bac=max(0.,dot(n,-sun_dir));\n    vec3 Lo= 6.0*dif*sun_col*sha;\n#if OUTPUT_BASE_COLOR\n    return mate;\n#else\n    return Lo * mate * 0.2;      \n#endif\n}\n\nvec3 scene(vec3 ro, vec3 rd, vec2 fragCoord, out float t)\n{\n    vec3 bg=vec3(.6,.8,1.1);\n    vec3 col= vec3(0.0, 0.0, 0.0);\n\n    float t1 = march_terrian(ro, rd, 50., 2000.);\n    \n  \tif(t>=2000.) return col;\n        \n    col = render_terrian(ro, rd, t1, fragCoord);  \n#if OUTPUT_BASE_COLOR\n    return col;\n#else\n    float sun=clamp(dot(sun_dir,rd), 0.0, 1.0);\n    col+=0.25*vec3(1.0,0.4,0.2)*pow(sun, 4.0);\n    col=mix(col,bg, 1.0-exp(-1.5e-7*t*t) );\n    return col;\n#endif\n}\n\nvec3 tonemap(vec3 x) \n{\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = q * 2. - 1.;\n    vec3 ro = vec3(380., 400.,960.);\n    vec3 ta = vec3(380., 0, 960.);\n    mat3 basis = orthBas(ro - ta);\n       \n    ro = ro + (basis * vec3(2. * p * 100.0 ,0));\n    vec3 rd = basis * normalize(vec3(p * .0, -1));\n\n    vec3 col=vec3(0.6,0.8,1.1);\n\n    float t=0.;\n    \n#if OUTPUT_HEIGHT_MAP\n    float height = 400.0 - march_terrian(ro, rd, 50., 2000.);\n    col = vec3(height / 400.0, height / 400.0, height / 400.0);\n#elif OUTPUT_BASE_COLOR\n    col = scene(ro, rd, fragCoord.xy, t);\n    col = pow(clamp(col, 0.0, 1.0), vec3(0.45)); \n#else\n    col = scene(ro, rd, fragCoord.xy, t);\n    col = tonemap(col);\n    col = pow(clamp(col, 0.0, 1.0), vec3(0.45)); \n    col = pow(col,vec3(0.85,1.,0.95));\n#endif\n    fragColor.xyz = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265\n\nvec2 hash2(vec2 p) \n{\n    const vec2 k = vec2(0.3183099, 0.3678794);\n    p = p*k + k.yx;\n    return fract( 16.0 * k*fract( p.x*p.y*(p.x+p.y)) );\n}\n\nvec2 hash2(float n) \n{ \n    return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123)); \n}\n\nfloat hash1(vec2 p)\n{\n    p  = 50.0*fract( p*0.3183099 );\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\n\nfloat noise(vec2 x)\n{\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    \n    float a = hash1(p+vec2(0,0));\n    float b = hash1(p+vec2(1,0));\n    float c = hash1(p+vec2(0,1));\n    float d = hash1(p+vec2(1,1));\n    \n    return -1.0+2.0*(a + (b-a)*u.x + (c-a)*u.y + (a - b - c + d)*u.x*u.y);\n}\n\nconst mat2 m2 = mat2(  0.80,  0.60,\n                      -0.60,  0.80 );\n\nfloat terrian(vec2 p)\n{    \n    p*=0.0045;\n    float f = 2.;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for(int i = 0; i< 9; i++)\n    {\n        float n = noise(p);\n        a += b*n;\n        b *= s;\n        p = f*m2*p;\n    }\n\t\n    a=smoothstep(-0.5,0.7,a);\n    \n    return a*300.;\n}\n\n\nvec3 terrian_normal(vec2 pos, float t)\n{   \n    vec2 e = vec2(0.001*t,0.0);\n\treturn normalize(vec3(terrian(pos-e.xy)-terrian(pos+e.xy),\n                           2.0*e.x,\n                           terrian(pos-e.yx)-terrian(pos+e.yx)));\n}\n\n// log-bisection tracing from Nimitz: https://www.shadertoy.com/view/4sSXz\nfloat march_terrian(vec3 ro, vec3 rd, float tmin, float tmax)\n{\n    float t = tmin;\n    vec3 p=ro+t*rd;\n    float d=p.y-terrian(p.xz);\n\n    float sgn=sign(d);\n    float told=t;\n    bool bisect=false;\n        \n    for (int i = 0;i < 256; i++)\n    {\n        if(abs(d)<0.002*t || t>tmax) break;            \n       \tif(sign(d)!=sgn)\n        {\n            bisect=true;\n            break;\n        }\n        \n        told=t;\n        if(d>1.)t+=d*0.4;\n        else t+=log(abs(d)+1.1)*1.;\n        p=ro+t*rd;\n       \td=p.y-terrian(p.xz);\n    }\n    \n    if(bisect)\n    {\n        float m = 0.;\n        p=ro+told*rd;\n        sgn=sign(p.y-terrian(p.xz));\n        for(int i=0; i<6; i++)\n        { \n            m=(told+t)*.5;\n            p=ro+rd*m;\n            d=p.y-terrian(p.xz);\n            if(abs(d)<0.002*t)break;\n            d*sgn<0. ? t=m : told=m;\n        }\n        t=(told+t)*.5;\n    }\n    return t;\n}\n\nvec4 texcube(sampler2D sam, vec3 p, vec3 n)\n{\n    vec4 p1=texture(sam, p.xy);\n    vec4 p2=texture(sam, p.xz);\n    vec4 p3=texture(sam, p.yz);\n    return p1*abs(n.z)+p2*abs(n.y)+p3*abs(n.x);\n}\n\nmat3 orthBas(vec3 z){\n  z=normalize(z);\n  vec3 up=abs(z.y)>.999?vec3(0,0,1):vec3(0,1,0);\n  vec3 x=normalize(cross(up,z));\n  return mat3(x,cross(z,x),z);\n}\n","name":"Common","description":"","type":"common"}]}