{"ver":"0.1","info":{"id":"tltGW8","date":"1576217676","viewed":606,"name":"A Basic SDF Raymarcher","username":"aeva","description":"Everyone has a vanity SDF raymarcher these days, and now YOU CAN, TOO!\n\nThis code is public domain via CC0.  Stick your name on it, sell it to people, don't give me credit - I DON'T CARE!  Print it out and use it to clean your toilet!","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","cc0"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// Written in 2019 by Aeva Palecek\n//\n// To the extent possible under law, the author has dedicated all copyright\n// and related and neighboring rights to this software to the public domain\n// worldwide.  This software is distributed without any warranty.\n//\n// See http://creativecommons.org/publicdomain/zero/1.0/ for more information.\n//\n\n//\n// Some notes about this renderer:\n//\n//  - The coordinate system is right handed with Z up, like Blender.\n//  - View space and world space are the same.\n//  - Ray tracing is relative to world space (or view space).\n//\n\n\nconst vec4 MissColor = vec4(0.6, 0.1, 0.2, 1.0);\nconst float AlmostZero = 0.001;\n\n\nfloat Sphere(vec3 Local, float Radius)\n{\n    return length(Local) - Radius;\n}\n\n\nfloat Union(float LHS, float RHS)\n{\n    return min(LHS, RHS);\n}\n\n\nfloat Subtract(float LHS, float RHS)\n{\n    return max(LHS, -RHS);\n}\n\n\nfloat SceneSDF(vec3 View)\n{\n    float Shape = Sphere(View - vec3(0.0, 10.0, 0.0), 1.0);\n    Shape = Subtract(Shape, Sphere(View - vec3(-0.5, 9.5, 0.0), 1.0));\n    Shape = Union(Shape, Sphere(View - vec3(-2.0, 10.0, 0.0), 1.0));\n    Shape = Union(Shape, Sphere(View - vec3(2.0, 10.0, 0.0), 1.0));\n    return Shape;\n}\n\n\nvec3 GetRayDir(vec2 FragCoord, vec2 Resolution, float FOV)\n{\n    float Aspect = Resolution.y / Resolution.x;\n    vec2 NDC = FragCoord / iResolution.xy * 2.0 - 1.0;\n    vec2 Angle = NDC * vec2(FOV, FOV * Aspect) * 0.5;\n    vec3 RayDir = vec3(sin(radians(Angle)), 0.0).xzy;\n    RayDir.y = sqrt(1.0 - (RayDir.x * RayDir.x) - (RayDir.z * RayDir.z));\n    return RayDir;\n}\n\n\nbool RayMarch(vec3 RayDir, float TravelStart, float TravelEnd, out vec3 Position)\n{\n    float Traveled = TravelStart;\n    bool bHit = false;\n    for (int i=0; i<100; ++i)\n    {\n    \tPosition = RayDir * Traveled;\n        float Dist = SceneSDF(Position);\n\t\tTraveled += Dist;\n        bHit = Dist < AlmostZero;\n        if (bHit || Traveled >= TravelEnd)\n        {\n            break;\n        }\n    }\n    return bHit;\n}\n\n\nvec3 Gradient(vec3 Position)\n{\n    float Dist = SceneSDF(Position);\n    return normalize(vec3(\n    \tSceneSDF(vec3(Position.x + AlmostZero, Position.y, Position.z)) - Dist,\n        SceneSDF(vec3(Position.x, Position.y + AlmostZero, Position.z)) - Dist,\n    \tSceneSDF(vec3(Position.x, Position.y, Position.z + AlmostZero)) - Dist));\n}\n\n\nvoid mainImage( out vec4 FragColor, in vec2 FragCoord )\n{\n    vec3 RayDir = GetRayDir(FragCoord.xy, iResolution.xy, 45.0);\n    vec3 Position;\n    if (RayMarch(RayDir, 1.0, 1000.0, Position))\n    {\n        vec3 Normal = Gradient(Position);\n        FragColor = vec4(texture(iChannel0, Normal.xzy).xyz, 1.0);\n    }\n    else\n    {\n        FragColor = MissColor;\n    }\n}\n","name":"Image","description":"","type":"image"}]}