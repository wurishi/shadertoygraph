{"ver":"0.1","info":{"id":"fttGzf","date":"1636475113","viewed":263,"name":"Battlefield 2042 #WeAreNoPats","username":"omegasbk","description":"Made the Battlefield 2042 NoPat logo for fun.","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["logo","battlefield2042","nopat"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 09.11.2021.\n// Made by Darko Supe (omegasbk)\n// Messy code disclaimer :D \n\n#define MAX_STEPS 100\n\n#define MAX_DIST 100.\n#define MIN_DIST 0.0002\n\n#define PI 3.14159265359\n\n#define ROUGHNESS 0.01;\n\nvec3 rotate(in vec3 p, in float angle)\n{\n    mat3 m = mat3(\n        cos(angle),  sin(angle), 0.,  \n        -sin(angle), cos(angle), 0.,  \n        0.,                  0., 1.  \n    ); \n    \n    return p * m;\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdPrism(vec3 p, vec2 h)\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sub(float d1, float d2) \n{ \n    return max(d1, -d2); \n}\n\nfloat add(float d1, float d2) \n{ \n    return min(d1, d2); \n}\n\nfloat nLeft(vec3 p)\n{\n    p += vec3(0.57, 0., 0.);\n    float top = sub(sdBox(p, vec3(0.2, 0.95, 0.1)), sdPrism(rotate(p + vec3(-0.2, -0.79, 0.0), PI - 1.85), vec2(0.8, 0.2)));\n    float bottom = sub(top, sdPrism(rotate(p + vec3(0.05, 1.6, 0.0), PI - 0.9), vec2(1.2, 0.2)));\n    \n    return bottom + vec3(texture(iChannel2, p.xy + p.zz)).r * ROUGHNESS;\n}\n\nfloat nMid(vec3 p)\n{    \n    float top = sub(sdBox(rotate(p + vec3(-0.1, -0.2, 0.), 0.75), vec3(0.2, 1.4, 0.1)), sdPrism(p + vec3(0.5, -1.25, 0.0), vec2(0.8, 0.2)));\n    float bottom = sub(top, sdPrism(rotate(p + vec3(-0.8, 0.91, 0.0), PI), vec2(0.7, 0.2)));\n    return bottom + vec3(texture(iChannel2, p.xy + p.zz)).r * ROUGHNESS;\n}\n\nfloat nRight(vec3 p)\n{    \n    float top = sub(sdBox(p + vec3(-0.89, -0.2, 0.), vec3(0.2, 0.8, 0.1)), sdPrism(p + vec3(-0.8, -1.25, 0.0), vec2(0.8, 0.2)));\n    float bottom = sub(top, sdPrism(rotate(p + vec3(-0.8, 0.59, 0.0), PI - 0.85), vec2(0.7, 0.2)));\n    return bottom + vec3(texture(iChannel2, p.xy + p.zz)).r * ROUGHNESS;\n}\n\nfloat getDist(vec3 p)\n{\n    p.x += 0.2;\n    return min(min(nLeft(p), nMid(p)), nRight(p)) ;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd)\n{\n    float dist = 0.;\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 itPos = ro + rd * dist;\n        float itDist = getDist(itPos);\n        \n        dist += itDist;\n        \n        if (dist > MAX_DIST || dist < MIN_DIST)  \n            break;\n    }    \n    \n    return dist;\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec2 e = vec2(0.01, 0.);    \n    return normalize(vec3(getDist(p + e.xyy), getDist(p + e.yxy), getDist(p + e.yyx)));    \n}\n\nfloat getLight(vec3 p)\n{\n    vec3 lightPos = vec3(-1., 3., -2.2);\n    vec3 lightDir = normalize(p - lightPos);\n    \n    vec3 lightPos2 = vec3(1., 3., 2.2);\n    vec3 lightDir2 = normalize(p - lightPos2);\n    \n    return mix(-dot(getNormal(p), lightDir), -dot(getNormal(p), lightDir2), 0.5);    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float focalDist = 0.6;\n    vec3 ro = vec3(0., 0., -1.6);\n    vec3 rd = vec3(uv.x, uv.y, focalDist);   \n    \n    float rotation = iMouse.x / iResolution.x  * 2. * PI + iTime / 2.;\n    \n    ro = rotate(ro.xzy, rotation).xzy;\n    rd = rotate(rd.xzy, rotation).xzy;    \n    \n    vec3 col = vec3(0.);    \n      \n    float dist = rayMarch(ro, rd);\n    if (dist < MAX_DIST)\n    {\n        vec3 pHit = ro + rd * dist;\n        col = vec3(0.5, 0.6, 0.6);\n        col *= vec3(getLight(pHit)) + vec3(0.1);\n        \n        vec3 rdRef = reflect(rd, getNormal(pHit) + vec3(texture(iChannel2, pHit.xy + pHit.zz)).rgb);\n        col = mix(col, texture(iChannel1, rdRef).rgb, 0.96) * 1.1;\n    }   \n    else \n    {\n        //col = texture(iChannel1, rd).rgb * 0.8;\n    }\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}