{"ver":"0.1","info":{"id":"MctXz2","date":"1714212158","viewed":89,"name":"Circle perspective projection II","username":"celifan","description":"Drawing projected circles. ","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["circle","ellipse","perspective"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// *************************\n// \n// Experimenting drawing projected circles by :\n// 1 ) Constructing an involution relating pairs of conjugate diameters.\n// 2 ) Finding the minor axis orientation by projecting the disk normal.\n// \n// Use the #define CONJ to switch between 1 & 2 \n//\n// Related shaders :\n// https://www.shadertoy.com/view/mltyDN\n// https://www.shadertoy.com/view/lX2SRm\n// \n// *************************\n\n//#define CONJ\n\n// For convenience positions are expressed as integers in a [_n x _n] grid \nconst float s = .9; //  grid width in normalize pix coordinates\n\n// transformation to apply to vec2 in [_n X _n ] -->  normalize pix coordinates\n#define O (vec2(_ar/2.0,.1))\n#define V(x,y) (vec2(float(x),float(y))*s/_n)\n#define S(x) ((float(x))*s/_n) \n///\nconst float PI = 3.1415926;\nfloat _ar; //aspect ratio.\nconst float _n = 12.0; // grid num subdivision.\nfloat _pixSize ;\nconst float _lw =1.0; // default line width in pixels\nconst float _ps =3.0; // default point size in pixels\nint _duFade = 20; // default line fade duration.\nint _du = 25; //default line tracing duration.\nint _duPt = 20; // default point tracing duration.\nfloat _ff = .5; // default fade factor.\n// projection\nvec3 _eyePos = vec3(S(0),S(0),S(12));\nvec3 _aimPos = vec3(S(0),S(0),S(0));\nfloat _frameScale = 2.0;\nvec2  _frameCenter = vec2(.7,.5);\n//\nvec3 _eyeDir; // _aimPos-_eyePos\nvec3 _eyeDir01; // normalize(_eyeDir)\nvec3 _up= vec3(0.0,0.0,1.0);\n\nvec3  _frameI,_frameJ; //frame (i,j) vectors\nfloat _eyePlaneDist = S(4);\n// working plane \nvec3 _wpO= vec3(0.0,0.0,0.0); // current working plane origin and normal for 2d drawing \nvec3 _wpN =vec3(0.0,0.0,1.0);\nvec3 _wpI= vec3(1.0,0.0,0.0); // wp frameI\nvec3 _wpJ = vec3(0.0,1.0,0.0); // wp frameJ\n// default colors.\nconst vec3 _c0 = vec3(.95,.92,.9);\nconst vec3 _c1 =  vec3(0.4,0.4,0.4);\nconst vec3 _cBlue = vec3(0.0,0.36,1.0);\nconst vec3 _c2 = vec3(.9,.9,.9);\nconst vec3 _pc = vec3( .9,0.3,0.0); \nfloat _f ;\n#define CS(a) vec2(cos(a), sin(a))\n// cs = vec2(cos(rotAngle), sin(rotAngle));\nvec2 R(vec2 v, vec2 cs)\n{\n    return mat2(cs.x, cs.y, -cs.y, cs.x)*v;\n}\n\n// signed distance to segment\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// solid stroke for the boundary of shape described by sd\nvoid strokeSolid( float sd, vec3 color,float lineWidth ,inout vec3 pixel  )\n{\n    lineWidth = mix( lineWidth/1.1, lineWidth*1.1,_f);\n    pixel =  mix(pixel,color, (1.0 - sqrt(smoothstep((lineWidth-1.0)*_pixSize,_pixSize*(lineWidth +.5), abs(sd)))));\n}\n\n//** projections \n\n//perspective/orthographic proj\n// output in ([0.0,_ar], [0.0,1.0])\nvec2 proj(vec3 p3)\n{\n    vec3 ep =p3-_eyePos;\n    float d =length(ep);\n    float z = dot(ep,_eyeDir01);\n    vec3  pj = z*_eyeDir01;\n    float ra =  _eyePlaneDist/z;\n    vec3 pjpe = (ep-pj)*_frameScale*ra;\n    return _frameCenter +vec2(dot(_frameI,pjpe),dot(_frameJ,pjpe));\n}\n\n// input in ([0.0,_ar], [0.0,1.0])\n// output ws \nbool invProj(vec2 p,out vec3 p3)\n{\n  vec2 pin = (p-_frameCenter)/_frameScale;\n  vec3 fc =(_eyePos +(_eyeDir01*_eyePlaneDist )) ;\n  vec3 pip = fc+  (_frameI*pin.x +_frameJ*pin.y);\n  vec3 rayDir = pip-_eyePos;\n  float b =dot(_wpN,rayDir);\n  float ab = dot(_wpN,_wpO-_eyePos)/b;\n  \n  p3 = _eyePos +rayDir*ab;\n  return ab >01e-4 && ab<10.0;\n}\n\n// drawPoint\nvoid drawPoint(vec2 p, float pointSize, vec3 color, inout vec3 pixel )\n{\n   float sd =length(p);\n   pixel =  mix(pixel, color, (1.0 -sqrt(smoothstep((pointSize-1.0)*_pixSize, _pixSize*(pointSize +.5), abs(sd))))); \n}\n\nvoid drawSegment(vec2 p, vec2 a, vec2 b,float lineWidth,\n                 vec3 color,\n                 inout vec3 pixel )\n{\n   float d =    sdSegment(p,a, b );\n   strokeSolid(d, color, lineWidth,pixel);\n}\n\n\n// working plane ->word space transformation.\n#define W(p) (_wpO + (p).x*_wpI + (p).y*_wpJ)\n\n// `c` coordinate in the current woking plane \nvoid drawCircle(vec2 p, float r,vec2 c,\n                float lineWidth,vec3 color,inout vec3 pixel )\n{   \n\n    //vec2 cp = proj(W(c));\n    //drawPoint(p-cp,_ps,_pc,pixel);\n    \n    //start with the square the given circle is inscribed in\n    vec2 u1 = proj(W(c+r*vec2(1.0,1.0)));\n    vec2 u2= proj(W(c+r*vec2(-1.0,1.0)));\n    vec2 u3= proj(W(c+r*vec2(1.0,-1.0)));\n    vec2 u4 = proj(W(c+r*vec2(-1.0,-1.0)));\n\n    vec2 p1 = proj(W(c+r*vec2(0.0,1.0)));\n    vec2 p2= proj(W(c+r*vec2(1.0,0.0)));\n    vec2 p3= proj(W(c+r*vec2(0.0,-1.0)));\n    vec2 p4 = proj(W(c+r*vec2(-1.0,0.0)));\n\n    drawPoint(p-u1,_ps,_pc,pixel);drawSegment(p,u1,u3,_lw,_c1,pixel);\n    drawPoint(p-u2,_ps,_pc,pixel);drawSegment(p,u2,u1,_lw,_c1,pixel);\n    drawPoint(p-u3,_ps,_pc,pixel);drawSegment(p,u3,u4,_lw,_c1,pixel);\n    drawPoint(p-u4,_ps,_pc,pixel);drawSegment(p,u2,u4,_lw,_c1,pixel);\n    //drawSegment(p,u2,u3,_lw,vec3(1.0,1.0,0.0),pixel);\n   // drawSegment(p,u1,u4,_lw,vec3(1.0,1.0,0.0),pixel);\n\n    //Find the center of the ellipse from the projected points [ec]\n    vec2 p1p2m = (p2+p1)/2.0;\n    vec2 p1p2d = p1p2m-u1;\n    vec2 p1p2dp = vec2(p1p2d.y, -p1p2d.x);\n    vec2 p1p2dConj = p2-p1;\n    //\n    vec2 p2p3m = (p2+p3)/2.0;\n    vec2 p2p3d = p2p3m-u3;\n    vec2 p2p3dp = vec2(p2p3d.y, -p2p3d.x);\n    vec2 p2p3dConj = p3-p2;\n    \n    float ab = dot(p2p3dp, u3-u1)/dot(p2p3dp, p1p2d);\n    vec2 ec = u1 +p1p2d*ab; // [ec]\n    \n    vec3 eci;\n    bool ok = invProj(ec,eci);\n    vec2 ecw = vec2(dot(eci-_wpO,_wpI),dot(eci-_wpO,_wpJ));\n    \n    //drawPoint(p-p1p2m,_ps,_pc,pixel);\n    //drawPoint(p-p2p3m,_ps,_pc,pixel);\n    #ifdef CONJ\n    //Draw the couple of conjugate diameters / [ blue & orange ]\n    drawSegment(p,ec-p1p2d*6.0,ec+p1p2d*6.0,_lw,vec3(1.0,.5,.5),pixel);\n    drawSegment(p,ec-p1p2dConj*6.0,ec+p1p2dConj*6.0,_lw,vec3(1.0,.5,.5),pixel);\n    drawSegment(p,ec-p2p3d*6.0,ec+p2p3d*6.0,_lw,vec3(0.5,.5,1.0),pixel);\n    drawSegment(p,ec-p2p3dConj*6.0,ec+p2p3dConj*6.0,_lw,vec3(0.5,.5,1.0),pixel);\n\n    //Locate minor and major axis by constructing the involution relating pairs of conjugate diameters.\n    // Chose this circle.\n    strokeSolid(length(p-u4)-distance(u4,ec),_c1,_lw,pixel);\n    //\n    vec2 t1 = ec +2.0*dot(u4-ec,normalize(p2p3dConj))*normalize(p2p3dConj);\n    vec2 t2 = ec +2.0*dot(u4-ec,normalize(p2p3d))*normalize(p2p3d);\n    vec2 s1 = ec +2.0*dot(u4-ec,normalize(p1p2dConj))*normalize(p1p2dConj);\n    vec2 s2 = ec +2.0*dot(u4-ec,normalize(p1p2d))*normalize(p1p2d);\n    // draw [t1,t2], [s1,s2]\n    drawSegment(p,s1,s2,_lw,_c1,pixel);\n    drawSegment(p,t1,t2,_lw,_c1,pixel);\n    // determine [ic] the center of involution is the intersection of [t1,t2] & [s1,s2]\n    // any line passing by ic will defines a pair of conjugate diameter.\n    vec2 t12 = t2-t1;\n    vec2 s12 = s2 -s1;\n    \n    vec2 t12p = vec2(t12.y,-t12.x);\n    ab = dot(t12p, t1-s1)/dot(t12p,s12);\n    vec2 ic = s1+s12*ab; //[ic]\n    // plot [ic]\n    drawPoint(p-(ic),_ps,vec3(1.0),pixel);\n    //The line passing by the center of the circle and [ic] will define the minor and major axis.\n    //[ Unique line passing by [ic] yielding orthogonal conjugate diameters. ]\n    vec2 d=u4-ic;\n    drawSegment(p, ic-d*3.0, ic+d*3.0,_lw, _c1,pixel);\n    vec2 mp = u4 + length(ec-u4)*normalize(d);\n    drawPoint(p-mp,_ps,_c1,pixel);\n    vec2 Mp = u4 -length(ec-u4)*normalize(d);\n    drawPoint(p-Mp,_ps,_c1,pixel);\n    //\n    vec2 md = mp-ec;\n    vec2 mdp = vec2(-md.y, md.x);\n    // draw minor & major axis.\n    drawSegment(p, ec-mdp*100.0,ec+mdp*100.0,_lw,_c1,pixel);\n    drawSegment(p, ec-md*100.0,ec+md*100.0,_lw,_c1,pixel);\n    #else\n    \n    vec3 c_ = W(c);\n    vec2 cs = proj(c_);\n    vec2 ns = proj(c_+_wpN);\n    vec2 cns = ns-cs;\n    vec2 mp =ec+cns;\n    vec2 md = mp-ec;\n    vec2 mdp = vec2(md.y,-md.x);\n    vec2 Mp = ec + mdp;\n    \n    \n    #endif\n    \n    // Calculate the aspect ratio of the ellipse.\n    // [ Locate the intersection of the ellipse and the major/minor axis in screen space ]  \n    \n    vec3 mpi;\n     ok = ok && invProj(mp,mpi);\n    vec2 mpw = vec2(dot(mpi-_wpO,_wpI),dot(mpi-_wpO,_wpJ));\n    \n    \n    // find minor and major axis [ ea ,eao ] by\n    // ** minor axis intersection points [ em ,emo ]\n    //\n    vec2 dir = normalize(mpw-ecw);\n    vec2 dirp = vec2(dir.y, -dir.x);\n    float x = dot(dirp,mpw-ecw);\n    float y = sqrt(r*r-x*x);\n    vec2 em = proj(W(c+dirp*x+dir*y)); //[em]\n    //\n    dir = normalize(ecw-mpw);\n    dirp = vec2(dir.y, -dir.x);\n    x = dot(dirp,ecw-c);\n    y = sqrt(r*r-x*x);\n    vec2 emo = proj(W(c+dirp*x+dir*y)); //[emo]\n\n    drawPoint(p-em,_ps,vec3(1.0), pixel);\n    drawPoint(p-emo,_ps,vec3(1.0), pixel);\n    \n    // ** major axis intersection points [ eM ,eMo ]\n    \n    vec3 Mpi;\n    ok =  invProj(Mp,Mpi);\n    vec2 Mpw = vec2(dot(Mpi-_wpO,_wpI),dot(Mpi-_wpO,_wpJ));\n    \n    dir = normalize(Mpw-ecw);\n    dirp = vec2(dir.y, -dir.x);\n    x = dot(dirp,ecw-c);\n    y = sqrt(r*r-x*x);\n    vec2 eM = proj(W(c+dirp*x+dir*y)); //[eM]\n    drawPoint(p-eM,_ps, vec3(1.0),pixel);\n    //\n    dir = normalize(ecw-Mpw);\n    dirp = vec2(dir.y, -dir.x);\n    x = dot(dirp,ecw-c);\n    y = sqrt(r*r-x*x);\n    vec2 eMo = proj(W(c+dirp*x+dir*y)); //[eMo]\n    drawPoint(p-eMo,_ps, vec3(1.0),pixel);\n\n   \n    //draw.\n    if (ok)\n    {\n        vec2 m=  (em-emo);// minor axis\n        vec2 M= (eM-eMo);// major axis.\n\n        vec2 m01 = normalize(m);\n        vec2 M01 = normalize(M);\n        vec2 pmM =  vec2(dot(m01, p-ec),dot(M01,p-ec));\n\n        vec2 ra = max(vec2(0.03),vec2(length(M),length(m)));\n\n        float mi = min(ra.x,ra.y);\n        float ma = max(ra.x,ra.y);\n        pmM*= ra/mi;\n        float de = length(pmM)-ma*.5;\n        float imp = abs(de)/(length(vec2(dFdx(de),dFdy(de))/_pixSize));\n\n       // float de =sdEllipse(pmM, .5*vec2(length(m),length(M)));\n        pixel =  de <0.0 ?pixel + _pc/2.0 :pixel;\n        strokeSolid(imp,color,lineWidth,pixel); \n\n         #ifndef CONJ\n        drawSegment(p,ec,ec+cns*.3,_lw,_pc,pixel);\n        #endif\n    }\n}\n              \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   // Normalized pixel coordinates (from 0 to 1)\n   vec2 uv = fragCoord/iResolution.y;\n   _pixSize = 1.0/iResolution.y;\n   _ar = iResolution.x/iResolution.y;\n\n   \n   // background. \n   vec3 pixel =vec3(.1);\n  \n   _frameCenter = vec2(_ar/2.0,1.0/2.0);\n    \n   // setup projection.\n   #if !defined(TOP_VIEW)\n   _aimPos =vec3(V(3,3),0.0);\n   _eyePos =_aimPos+ vec3(V(12,12)*vec2(cos(iTime), sin(iTime)),sin(iTime)+S(6));\n   _eyePlaneDist =S(6);\n   #else\n   _eyePos =vec3(V(3,3),S(6));\n   _eyePlaneDist =S(1);\n   _up = normalize(vec3(0.0,1.0,0.0));\n   #endif\n   \n   // set the projection frame \n   _eyeDir = _aimPos -_eyePos;\n   _eyeDir01 = normalize(_eyeDir);\n   \n    _frameI = normalize(cross(_eyeDir01,_up));\n    _frameJ = normalize(cross(_frameI,_eyeDir01));\n    \n   drawCircle(uv,S(4),V(3,3),_lw,_c1, pixel);\n  \n   // vignette\n   vec2 q = fragCoord/iResolution.xy;\n   float vi= 0.5 + 0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.15);\n\n   // Output to screen\n   fragColor = vec4(pixel*vi,1.0);\n   \n}","name":"Image","description":"","type":"image"}]}