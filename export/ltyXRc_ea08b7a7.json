{"ver":"0.1","info":{"id":"ltyXRc","date":"1485237949","viewed":111,"name":"GR - Rotating Wavy Line","username":"bradleygriffith","description":"Note: the aliasing shouldnt be hard to fix but Im done with this one for now.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["wavy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265358\n\nbool isinfin(float val) {\n    return (val != 0.0 && val * 2.0 == val) ? true : false;\n}\n\n// Fix a floating point number to two decimal places\nfloat toFixedTwo(float f) {\n    return float(int(f * 100.0)) / 100.0;\n}\n\n// Given x, a slope, and another point, find y for x.\nfloat yForXOnSlope(float x, float slope, vec2 p2) {\n    return -1.0 * ((slope * (p2.x - x)) - p2.y);\n}\n\n// Given y, a slope, and another point, find x for y.\nfloat xForYOnSlope(float y, float slope, vec2 p2) {\n    return ((y - p2.y) + (slope * p2.x)) / slope;\n}\n\n// Returns the slope of a line given the degrees of the angle on which that line is rotated;\nfloat slopeForDegrees(float deg) {\n\t// Ensure degrees stay withing 0.0 - 360.0\n    deg = mod(deg, 360.0);\n    \n    float radians = deg * (PI / 180.0);\n\n    return tan(radians);\n}\n\n// Returns slope adjusted for screen ratio.\nfloat normalizedSlope(float slope) {\n    vec2 p = vec2(1.0) / iResolution.xy;\n\treturn ((slope * 100.0) / p.x) / (100.0 / p.x);\n}\n\n// Returns offsets (+/-) for any coordinate at distance given slope.\n//   Note: This function does not normalize distance.\n//   Note: This function does not adjust slope for screen ratio.\nvec2 offsetsForCoordAtDistanceOnSlope(float d, float slope) {\n\treturn vec2(\n        (d * cos(atan(slope))),\n        (d * sin(atan(slope)))\n    );\n}\n\n// Returns a boolean designating whether or not an infinite line intersects with an infinite line, and sets an `out` variable for the intersection point if it is found.\n//   Note: This function does not adjust slope for screen ratio.\nbool lineLineIntersection (out vec2 intersect, in vec2 p1, in float m1, in vec2 p2, in float m2) {\n\t// See: http://gamedev.stackexchange.com/questions/44720/line-intersection-from-parametric-equation\n\t//      http://stackoverflow.com/questions/41687083/formula-to-determine-if-an-infinite-line-and-a-line-segment-intersect/41687904#41687904\n\n\tbool isIntersecting = false;\n\n\tfloat dx = 1.0;\n\tfloat dy = m1;\n\n\tfloat dxx = 1.0;\n\tfloat dyy = m2;\n\n\tfloat denominator = ((dxx * dy) - (dyy * dx));\n\tif (denominator == 0.0) {\n\t\t// Lines are parallel\n\t\treturn isIntersecting;\n\t}\n    \n   \tif (isinfin(dy)) {\n\t\tisIntersecting = true;\n\t\tintersect = vec2(p1.x, p2.y);\n\t\treturn isIntersecting;\n\t}\n\n\tif (isinf(dyy)) {\n\t\tisIntersecting = true;\n\t\tintersect = vec2(p2.x, p1.y);\n\t\treturn isIntersecting;\n\t}\n\n\tfloat u = ((dx * (p2.y - p1.y)) + (dy * (p1.x - p2.x))) / denominator;\n\n\tisIntersecting = true;\n\tintersect = p2 + (u * vec2(dxx, dyy));\n\n\treturn isIntersecting;\n}\n\n// Returns a boolean designating whether or not an infinite line intersects with a line segment, and sets an `out` variable for the intersection point if it is found.\n//   Note: This function does not adjust slope for screen ratio.\nbool lineLineSegmentIntersection (out vec2 intersect, in vec2 point, in float m, in vec2 pA, in vec2 pB) {\n    // See: http://gamedev.stackexchange.com/questions/44720/line-intersection-from-parametric-equation\n    //      http://stackoverflow.com/questions/41687083/formula-to-determine-if-an-infinite-line-and-a-line-segment-intersect/41687904#41687904\n\n    bool isIntersecting = false;\n\n    float dx = 1.0;\n    float dy = m;\n\n    float dxx = pB.x - pA.x;\n    float dyy = pB.y - pA.y;\n\n    float denominator = ((dxx * dy) - (dyy * dx));\n    if (denominator == 0.0 || (isinf(dyy / dxx) && isinf(dy))) {\n        // Lines are parallel\n        return isIntersecting;\n    }\n\n    if (isinf(dy)) {\n        float m2 = dyy / dxx;\n        float y = yForXOnSlope(point.x, m2, pB);\n        isIntersecting = true;\n        intersect = vec2(point.x, y);\n        return isIntersecting;\n    }\n\n    float u = ((dx * (pA.y - point.y)) + (dy * (point.x - pA.x))) / denominator;\n\n    if (u >= 0.0 && u <= 1.0) {\n        // Intersection occured on line segment\n        isIntersecting = true;\n        intersect = pA + (u * vec2(dxx, dyy));\n    }\n\n    return isIntersecting;\n}\n\n// Dev Note: Terrible code. Needs refactor. Just trying to find \n//   which two edges of the rect the intersections occur at.\nvoid intersectsOnRectForLine(out vec2 iA, out vec2 iB, in vec2 rMinXY, in vec2 rMaxXY, in vec2 point, in float slope) {\n\tbool firstIntersectFound = false;\n\n\tvec2 intersectA = vec2(0.0);\n\tvec2 intersectB = vec2(0.0);\n\tvec2 intersectC = vec2(0.0);\n\tvec2 intersectD = vec2(0.0);\n\n\tbool intersectsLeft = lineLineSegmentIntersection(intersectA, point, slope, rMinXY, vec2(rMinXY.x, rMaxXY.y));\n\tbool intersectsTop = lineLineSegmentIntersection(intersectB, point, slope, vec2(rMinXY.x, rMaxXY.y), rMaxXY);\n\tbool intersectsRight = lineLineSegmentIntersection(intersectC, point, slope, rMaxXY, vec2(rMaxXY.x, rMinXY.y));\n\tbool intersectsBottom = lineLineSegmentIntersection(intersectD, point, slope, rMinXY, vec2(rMaxXY.x, rMinXY.y));\n\n\tif (intersectsLeft) {\n\t\tiA = intersectA;\n\t\tfirstIntersectFound = true;\n\t}\n    \n\tif (intersectsTop) {\n\t\tif (firstIntersectFound) {\n\t\t\tiB = intersectB;\n\t\t}\n\t\telse {\n\t\t\tiA = intersectB;\n\t\t\tfirstIntersectFound = true;\n\t\t}\n\t}\n    \n\tif (intersectsRight) {\n\t\tif (firstIntersectFound) {\n\t\t\tiB = intersectC;\n\t\t}\n\t\telse {\n\t\t\tiA = intersectC;\n\t\t\tfirstIntersectFound = true;\n\t\t}\n\t}\n    \n\tif (intersectsBottom) {\n\t\tif (firstIntersectFound) {\n\t\t\tiB = intersectD;\n\t\t}\n\t\telse {\n\t\t\tiA = intersectD;\n\t\t}\n\t}\n}\n\nfloat isWave(vec2 uv, vec2 centerUv, float deg, float width, float wavelength, float amplitude) {\n    \n    // Setup\n    // -------------------------------\n    \n    // Dev Note: I've seen some strange artifacting when the input degrees have\n    //   a high number of decimal places. Fixing degrees to a max of two decimal places\n    //   fixes this bug. Not sure that it's the full solution but the problem is mitigated.\n\tdeg = toFixedTwo(deg);\n    \n    float halfWidth = width / 2.0;\n\tfloat slope = normalizedSlope(slopeForDegrees(deg));\n    float perpendicularDeg = mod(deg + 90.0, 360.0); // Offset angle by 90.0, but keep it from exceeding 360.0\n    float perpendicularSlope = normalizedSlope(slopeForDegrees(perpendicularDeg));\n   \n    \n    // Get uv for center point, offset by half of wavelength so that edges do not overlap\n    // -------------------------------\n    \n    vec2 kCenter = offsetsForCoordAtDistanceOnSlope(wavelength / 2.0, slope);\n    vec2 offsetCenterUv = centerUv * iResolution.xy;\n    if (deg <= 90.0 || deg >= 270.0) {\n        offsetCenterUv += kCenter;\n    }\n    else {\n        offsetCenterUv -= kCenter;\n    }\n    offsetCenterUv /= iResolution.xy;\n    \n    \n\n    // Get offset UVs for width of line, adjacent to center point\n    // -------------------------------\n\n    float angleA = perpendicularDeg;\n    float angleB = mod(perpendicularDeg + 180.0, 360.0); // Offset angle by 180.0, but keep it from exceeding 360.0\n    \n    float slopeA = normalizedSlope(slopeForDegrees(angleA));\n    float slopeB = normalizedSlope(slopeForDegrees(angleB));\n    \n    vec2 kA = offsetsForCoordAtDistanceOnSlope(halfWidth, slopeA);\n    vec2 kB = offsetsForCoordAtDistanceOnSlope(halfWidth, slopeB);\n    \n    vec2 offsetCoordA = offsetCenterUv * iResolution.xy;\n    vec2 offsetCoordB = centerUv * iResolution.xy;\n    \n    if (angleA <= 90.0 || angleA >= 270.0) {\n        offsetCoordA += kA;\n    }\n    else {\n        offsetCoordA -= kA;\n    }\n\n    if (angleB <= 90.0 || angleB >= 270.0) {\n        offsetCoordB += kB;\n    }\n    else {\n        offsetCoordB -= kB;\n    }\n\t\n    // Denormalize uvs and uv offsets and find closest point on line for our uv, then renormalize.\n    vec2 uvA = vec2(0.0);\n\tlineLineIntersection(uvA, offsetCoordA, slope, uv * iResolution.xy, perpendicularSlope);\n\tuvA /= iResolution.xy;\n    vec2 uvB = vec2(0.0);\n\tlineLineIntersection(uvB, offsetCoordB, slope, uv * iResolution.xy, perpendicularSlope);\n\tuvB /= iResolution.xy;\n\n\n\t// Find intersects for line with edges of viewport\n    // -------------------------------\n\n    vec2 uvAIntersectA = vec2(0.0);\n    vec2 uvAIntersectB = vec2(0.0);\n    intersectsOnRectForLine(uvAIntersectA, uvAIntersectB, vec2(0.0), iResolution.xy, offsetCoordA, slope);\n    \n    vec2 uvBIntersectA = vec2(0.0);\n    vec2 uvBIntersectB = vec2(0.0);\n    intersectsOnRectForLine(uvBIntersectA, uvBIntersectB, vec2(0.0), iResolution.xy, offsetCoordB, slope);\n    \n    vec2 perpendicularIntersectA = vec2(0.0);\n    vec2 perpendicularIntersectB = vec2(0.0);\n    // Note: We use `uvA` here. `uvB` would have same effect and what we want is to\n    //   find the intersect perpedicular to the uv's closest point on the line.\n    intersectsOnRectForLine(perpendicularIntersectA, perpendicularIntersectB, vec2(0.0), iResolution.xy, uvA * iResolution.xy, perpendicularSlope); \n\t\n    \n    // Prepare wave\n    // -------------------------------\n    \n    // Find length of each edge of line in relation to the viewport, and to the\n    //   perpendicular line cutting through each uv's closest point on the line.\n    float aLength = distance(uvAIntersectA, uvAIntersectB);\n    float bLength = distance(uvBIntersectA, uvBIntersectB);\n    float perpendicularIntersectionLength = distance(perpendicularIntersectA, perpendicularIntersectB);\n\n    // Find percent of edge length that the uv's closest point on the line constitutes\n    //   for each edge of the line.\n    float aDistance = (distance(offsetCoordA, uvA * iResolution.xy) / aLength) - (amplitude / aLength);\n    float bDistance = (distance(offsetCoordB, uvB * iResolution.xy) / bLength) - (amplitude / bLength);\n\n    // Create wave, adjusting input wavelength and amplitude (in pixels) in accordance with\n    //   resolution of line edges along the line's slope. This is kind of convuluted so \n    //   consider a value between 0 and 1 on a diagonal line. That's the value on which each\n\t//   'pixel' of the wave's edge must be based. \n    float varianceA = sin(aDistance * PI * (aLength / (wavelength / 2.0))) * (amplitude / perpendicularIntersectionLength);\n    float varianceB = sin(bDistance * PI * (bLength / (wavelength / 2.0))) * (amplitude / perpendicularIntersectionLength);\n    varianceA *= perpendicularIntersectionLength;\n    varianceB *= perpendicularIntersectionLength;\n\n    // Use wave variance as offsets of each point along our line and adjust each uv's closest\n    //   point on the line accordingly.\n    vec2 kVA = offsetsForCoordAtDistanceOnSlope(varianceA, slopeA);\n    vec2 kVB = offsetsForCoordAtDistanceOnSlope(varianceB, slopeB);\n    \n    if (angleA <= 90.0 || angleA >= 270.0) {\n        offsetCoordA += kVA;\n    }\n    else {\n        offsetCoordA -= kVA;\n    }\n    \n    if (angleB <= 90.0 || angleB >= 270.0) {\n\t\toffsetCoordB += kVB;\n    }\n    else {\n    \toffsetCoordB -= kVB;\n    }\n  \t\n\tlineLineIntersection(uvA, offsetCoordA, slope, uv * iResolution.xy, perpendicularSlope);\n\tuvA /= iResolution.xy;\n\tlineLineIntersection(uvB, offsetCoordB, slope, uv * iResolution.xy, perpendicularSlope);\n\tuvB /= iResolution.xy;\n    \n\n    // Define wave edges\n    // -------------------------------\n    \n   \tfloat distX = abs(step(uvB, uv).x - step(uvA, uv).x);\n   \tfloat distY = abs(step(uvB, uv).y - step(uvA, uv).y);\n   \tfloat wave = max(distX, distY);\n\n\n    return wave;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n    // Setup\n    // -------------------------------\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    lowp vec2 position = vec2(0.5, 0.5);\n    lowp float deg = 90.0;\n    if (iMouse.z > 1.0) {\n  \t\tposition = iMouse.xy / iResolution.xy;\n  \t\tdeg = (position.x * 360.0);\n    }\n    \n    float width = 4.0;\n    float wavelength = 100.0;\n    float amplitude = 25.0;\n\tfloat speed = 0.025;\n    \n\n    // Prepare edge details \n    // -------------------------------\n\n\t//deg = fract(iTime * speed) * 360.0;\n    float wave = isWave(uv, position, deg, width, wavelength, amplitude);\n    \n    fragColor = 1.0 - vec4(wave);\n}","name":"Image","description":"","type":"image"}]}