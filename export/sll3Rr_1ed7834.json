{"ver":"0.1","info":{"id":"sll3Rr","date":"1621508746","viewed":96,"name":"REWORK","username":"waifutaker","description":"aaaa","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["aaaa"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 600\n#define MAX_DIST 600.\n#define SURF_DIST .001\n//Второй обЬект повороты цвета мягкие тени;\n\n\n/*void sphereFold(inout vec3 z, inout float dz) {\n\tfloat r2 = dot(z,z);\n\tif (r<minRadius2) { \n\t\t// linear inner scaling\n\t\tfloat temp = (fixedRadius2/minRadius2);\n\t\tz *= temp;\n\t\tdz*= temp;\n\t} else if (r2<fixedRadius2) { \n\t\t// this is the actual sphere inversion\n\t\tfloat temp =(fixedRadius2/r2);\n\t\tz *= temp;\n\t\tdz*= temp;\n\t}\n}\n*/\n\n\n\nvoid boxFold(inout vec3 z, inout float dz) {\n\tz = clamp(z, -3., 3.) * 2.0 - z;\n}\n\n\nmat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c,-s,s,c);\n}\n    \n\nvoid ry(inout vec3 p, float a){  \n \tfloat c,s;vec3 q=p;  \n  \tc = cos(a); s = sin(a);  \n  \tp.y = c * q.y- s * q.z;  \n  \tp.z = s * q.y + c * q.z; \n }  \n \n void ry2(inout vec3 p, float a){  \n \tfloat c,s;vec3 q=p;  \n  \tc = cos(a); s = sin(a);  \n  \tp.x = c * q.x- s * q.z;  \n  \tp.z = s * q.x + c * q.z; \n }  \n \nfloat DE3(vec3 z)\n{\n\tvec3 offset = z;\n\tfloat dr = 1.0;\n\tfor (int n = 0; n <35; n++) {\n\t\tboxFold(z,dr);       // Reflect\n\t\t//sphereFold(z,dr);    // Sphere Inversion\n \t\tfloat Scale =2.;\n                z=Scale*z + offset;  // Scale & Translate\n                dr = dr*abs(Scale)+1.0;\n\t}\n\tfloat r = length(z);\n\treturn r/abs(dr);\n}\n\n\nfloat TetraFOUR(vec3 p) {//Tetraброт\n\t//vec3 z = p;\n    p = vec3(1.*p.x,1.*p.y,1.*p.z);\n    vec4 p_vec4 = vec4(1.*p.x,p.y,p.z,0.0);\n    vec4 z = vec4(p_vec4.x,p_vec4.y,p_vec4.z,p_vec4.w);\n    \n    float t = iTime/3.0;\n\tvec4 c = 0.5*vec4(sin(t),sin(t),sin(t),sin(t));\n    \n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (float i = 0.; i < 14. ; i++) {\n\t\tr = length(z);\n        \n\t\tif (r>2.) break;\n       \n        float Power = 2.;\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;//pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = vec4(z.x*z.x-z.y*z.y-z.z*z.z+z.w*z.w, 2.*(z.x*z.y-z.z*z.w),2.*(z.x*z.z-z.y*z.w),2.*(z.x*z.w+z.y*z.z));\n\t\tz+=p_vec4;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\n\n/*\nfloat TetraFOUR(vec3 p) {//Tetraброт\n\n    p = vec3(1.*p.x,1.*p.y,1.*p.z);\n    vec4 p_vec4 = vec4(1.*p.x,p.y,p.z,0.0);\n    vec4 z = vec4(p_vec4.x,p_vec4.y,p_vec4.z,p_vec4.w);\n    \n    float t = iTime/3.0;\n\tvec4 c = 0.5*vec4(sin(t),sin(t),sin(t),sin(t));\n    vec4 nz;\n    \n\tfloat mz2 = dot(z,z);\n    float md2 = 1.0;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (float i = 0.; i < 14. ; i++) {\n\t\tr = length(z);\n        \n\t\tif (r>2.) break;\n        md2*=4.0*mz2;\n        \n        float Power = 2.;\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = c+vec4(z.x*z.x-z.y*z.y-z.z*z.z+z.w*z.w, 2.*(z.x*z.y-z.z*z.w),2.*(z.x*z.z-z.y*z.w),2.*(z.x*z.w+z.y*z.z));\n\t\tz+=p_vec4;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n*/\n/*\nfloat julia(vec3 pos)\n{\n    float t = iTime/3.0;\n    \n\tvec4 c = 0.5*vec4(cos(t),cos(t*1.1),cos(t*2.3),cos(t*3.1));\n    vec4 z = vec4( pos, 0.0 );\n\tvec4 nz;\n    \n\tfloat md2 = 1.0;\n\tfloat mz2 = dot(z,z);\n\n\tfor(int i=0;i<13;i++)\n\t{\n\t\tmd2*=4.0*mz2;\n\t    nz.x=z.x*z.x-dot(z.yzw,z.yzw);\n\t\tnz.yzw=2.0*z.x*z.yzw;\n\t\tz=nz+c;\n\n\t\tmz2 = dot(z,z);\n\t\tif(mz2>4.0)\n        {\n\t\t\tbreak;\n        }\n\t}\n\n\treturn 0.25*sqrt(mz2/md2)*log(mz2);\n}\n*/\nfloat MandelFOUR(vec3 p) {//Мандельброт 4d\n\t\n    p = vec3(1.*p.x,1.*p.y,1.*p.z);\n    vec4 p_vec4 = vec4(p.x,p.y,p.z,0.);\n    vec4 z = vec4(p,0);\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n    float r2 = 0.0;\n    float r3 = 0.0;\n\tfor (float i = 0.; i < 10. ; i++) {\n\t\tr = length(z);\n        r2 = sqrt(z.x*z.x+z.y*z.y);\n        r3 = sqrt(z.x*z.x+z.y*z.y+z.z*z.z);\n\t\tif (r>2.) break;\n\t\t\n       \n\t\t// convert to polar coordinates\n\t\tfloat phi = atan(z.z,r2);\n        float psi = atan(z.w,r3);\n\t\tfloat theta = atan(z.y,z.x);//float phi = atan(z.y,z.x);\n        float Power = 2.;\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\t\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec4(cos(2.*psi)*cos(2.*theta), cos(2.*psi)*cos(2.*phi), -cos(2.*psi)*sin(2.*phi),sin(2.*psi));\n\t\tz+=vec4(p,0);\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\n\n\n\n\n\nfloat atan3(in float y, in float x) {\n    return x == 0.0 ? sign(y)*(1.5708) : atan(y, x);\n}\nfloat DEQ(in vec3 position){\nint iterations = 26;\nfloat bailout = 8.0;\nfloat power =8.0*abs(sin(iTime/3.))+1.;\n\tvec3 z = position;\n    float dr = 1.0;\n    float r = 0.0;\n    float theta,phi,zr;\n    for(int i=0;i<iterations;i++) {\n    \tr = length(z);\n        if(r>bailout) break;\n        \n        theta = power*atan3(sqrt(z.x*z.x+z.y*z.y),z.z);\n        phi = power*atan3(z.y,z.x);\n        zr = pow(r,power);\n\t\tz = vec3( zr*sin(theta)*cos(phi) + position.x,\n                  zr*sin(phi)*sin(theta) + position.y,\n                  zr*cos(theta) + position.z\t\t );\n    \tdr = ( pow(r, power-1.0)*power*dr ) + 1.0;        \n    }\n    return 0.5*log(r)*r/dr;\n}\n\n\nfloat Quadra(vec3 p) {//quadratics\n\t//vec3 z = p;\n    vec4 p_vec4 = vec4(p.x,p.y,p.z,0);\n    vec4 z =vec4(1.*p.x,p.y,p.z,0);\n\tfloat dr = 1.;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < 50 ; i++) {\n\t\tr = length(z);\n\t\tif (r>400.) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = 2.*acos(z.z/r);\n\t\tfloat phi = 2.*atan(2.*z.y,2.*z.x);//float phi = atan(z.y,z.x);\n        float Power = 2.;\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\t\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec4(cos(theta)*cos(phi), sin(phi)*cos(theta), -sin(theta),0);\n\t\tz+=p_vec4;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\n\nfloat Mandel(vec3 p) {//Мандельброт\n\t\n    vec4 p_vec4 = vec4(p.x,p.y,p.z,0);\n    vec4 z =vec4(p.x,p.y,p.z,0);\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < 100 ; i++) {\n\t\tr = length(z);\n\t\tif (r>40.) break;\n        \n       \t\tfloat t = iTime/30.0;\n        \n        \n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(2.*z.y,2.*z.x);//float phi = atan(z.y,z.x);\n        float Power = abs(cos(t))*10.+1.5;\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec4(cos(theta)*cos(phi), sin(phi)*cos(theta), sin(theta),0);\n\t\tz+=p_vec4;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\nfloat Mandelbub(vec3 p) {//Мандельбуб \n\t//vec3 z = p;\n    vec4 p_vec4 = vec4(p.x,p.y,p.z,0);\n    vec4 z =vec4(p.x,p.y,p.z,0);\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < 100 ; i++) {\n\t\tr = length(z);\n\t\tif (r>3.) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.x,z.y);//float phi = atan(z.y,z.x);\n        float Power =8.*(abs(sin(iTime/2.)))+2.;\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec4(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta),0);\n\t\tz+=p_vec4;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\nfloat julia(vec3 pos)\n{\n    float t = iTime/3.0;\n    \n\tvec4 c = 0.5*vec4(cos(t),cos(t*1.1),cos(t*2.3),cos(t*3.1));\n    vec4 z = vec4( pos, 0.0 );\n\tvec4 nz;\n    \n\tfloat md2 = 1.0;\n\tfloat mz2 = dot(z,z);\n\n\tfor(int i=0;i<21;i++)\n\t{\n\t\tmd2*=4.0*mz2;\n\t    nz.x=z.x*z.x-dot(z.yzw,z.yzw);\n\t\tnz.yzw=2.0*z.x*z.yzw;\n\t\tz=nz+c;\n\n\t\tmz2 = dot(z,z);\n\t\tif(mz2>4.0)\n        {\n\t\t\tbreak;\n        }\n\t}\n\n\treturn 0.25*sqrt(mz2/md2)*log(mz2);\n}\n\nfloat DE(vec3 z)// Треугольник серпинского \n{\n vec3 n1 = vec3(-z.y,z.x,z.z);\n \n //float t = dot(z,n1); if (t<0.0) { z-=2.0*t*n1; }\n \n float r;\n \n \n int n = 0;\n float Scale=2.0;\n float Offset =8.;\n while (n < 15) {\n if(z.x+z.y<0.) z.xy = -z.yx; // fold 1  -z.yx*.8*cos(iTime)\n if(z.x+z.z<0.) z.xz = -z.zx; // fold 2\n if(z.y+z.z<0.) z.zy = -z.yz; // fold 3 \n float t = dot(z,n1); \n //if (t<0.0){ \n //z-=2.0*t*n1; \n \n z = z*Scale - Offset*(Scale-1.0);\n \n n++;\n }\n \n return (length(z) ) * pow(Scale, -float(n));\n}\n\n\n\n\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n\n\nfloat sphereDist( vec3 p )\n    {\n  vec4 s = vec4(0., 0.1, 0.1, 1);\n  \n  return length(p-s.xyz)-s.w;\n}\n\n\n float f(vec3 p){\n\n\n     return DEQ(1.*p);//TetraFOUR(p);  Quadra\n } \n\n\nfloat opTwist( in vec3 p )//Спираль \n{\n    float k = 0.*sin(iTime); // or some other amount\n    float c = sin(k*p.y);\n    float s = cos(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);//vec3(m*p.xz,p.x);\n    return f(q);\n}\n\nfloat opRep( in vec3 p, in vec3 c )// зеркало \n{\n    vec2 t = vec2(1);//vec2\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return  f(q); //зеркало premitive change \n}\n\n\nfloat opDisplace( in vec3 p )//sin \n{\n    \n    float d2 = (sin(5.*sin(iTime)*p.x)*sin(1.*sin(iTime)*p.y)*sin(sin(iTime)*p.z));\n    return f(p)+d2;\n}\n\n\nfloat GetDist(vec3 p) {\n\tvec3 b = vec3(10);\n    float s = 1.;\n    \n    float planeDist =0.*p.y+11.;//high\n    \n    float dg= opTwist(.4*p);//opDisplace opTwist opRep(p,b) and size \n    \n    float d = min(dg,planeDist);\n\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(1., 1.,1.);\n    lightPos.xyz += vec3(0.,10., 10.5)*6.;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l);\n    if(d<length(lightPos-p)) dif *= .01;\n    \n    return dif;\n}\n\n\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    float nrm = (s + 9.0) / (3.1415 * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\n\n\n\nconst vec3 RED = vec3(3.,0.001103,0.08);\nconst vec3 ORANGE = vec3(0.032,0.01,0.09);\nconst vec3 GREEN = vec3(.0,3.0,3.00);\nconst vec3 BLUE = vec3(0.0,0.0,7.00);\n\n\n///////////\nvec3 GetSky(in vec3 rd, in vec3 sunDir, in vec3 sunCol)\n{\n\tfloat sunAmount = max( dot( rd, sunDir), 0.0 );\n\tfloat v = pow(1.0-max(rd.y,0.0),6.);\n\tvec3  sky = mix(vec3(.14, .24, .39), vec3(.8732, .8732, .8732), v);\n\tsky = sky + sunCol * sunAmount * sunAmount * .25;\n\tsky = sky + sunCol * min(pow(sunAmount, 800.0)*1.5, .3);\n\treturn clamp(sky, 0.0, 1.0);\n}\n///////////\n\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0,5.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n      vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    float t = iTime;\n    vec3 ro = vec3(0, 3, -3);\n    ro.zy *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    \n    \n    float zoom =  .3;\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), zoom);//zoom\n    vec3 col = vec3(0);\n   \n   \n    float d = RayMarch(ro, rd);\n vec3 ld = vec3(0,.102, 0);\n \nvec3 sky = 1.*GetSky(rd, ld, vec3(1.1,1.4,1.2));\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n       // vec3 r = reflect(rd, n);\n\n    \n        float dif = dot(n, normalize(vec3(2)))*.73+.35;\n     \n        col = vec3(dif);\n     \n     \n     \n\n  col *= RED * 0.3;\n    float r = 2.7;\n    float ao = smoothstep(r*.6, r, length(p));\n    col = col*ao*5.0;\n\n\nvec3 l0 = normalize(vec3(-1.0,0.0,-1.0));\n    vec3 l1 = normalize(vec3(.3,.5,0.5));\n    vec3 l2 = normalize(vec3(1.0,1.0,0.4));  \n    \n  col += specular(n,l0,rd,1.1) * BLUE*vec3(.3,.3,.4);//*vec3(cos(iTime)*.5,sin(iTime)*0.4,cos(iTime)*.5);\n   col += specular(n,l1,rd,1.2) *1.1*GREEN;//* vec3(sin(iTime)*1.,cos(iTime)*1.,sin(iTime)*1.) * 1.1; \n  // col += specular(n,l2,rd,1.0) * 1.2;\n //*vec3(sin(iTime)*1.,cos(iTime)*1.,sin(iTime)*1.);\n   col = col*.50;\n   col *= hsv2rgb(col);\n   col *= vec3(dif);\n    }\n    \n  \n   \n // 0убери\n\n    //col += specular(n,l0,rd,1.1) * BLUE;//*vec3(cos(iTime)*.5,sin(iTime)*0.4,cos(iTime)*.5);\n    //col += specular(n,l1,rd,1.2) *1.1*GREEN;//* vec3(sin(iTime)*1.,cos(iTime)*1.,sin(iTime)*1.) * 1.1; \n    //col += specular(n,l2,rd,1.0) * 1.2; //*vec3(sin(iTime)*1.,cos(iTime)*1.,sin(iTime)*1.);\n    //col = col*.20;\n    \n   // col = col*vec3(dif);//col = col*vec3(dif)**vec3(dif2)\n    \n    \n   // col = col*vec3(0.9, 0.8, 0.6) *  0.2 * tc0;\n \t//col=mix(col,sky, 1.0-exp(-0.001*p.x*p.x));\n  // col = mix(hsv2rgb(col), vec3(.323), smoothstep(0., 40., d));\n  // col = pow(col, vec3(.4545));\t// gamma correction   col = pow(col, vec3(.4545)); \n    fragColor = vec4(pow(col,vec3(0.4545)),0.0);//hs2v function\n    fragColor.xyz = mix( fragColor.xyz, sky,1.0-exp( -0.01*d*d ) );//fog (*1.0-exp( -0.01*d*d )\n  }","name":"Image","description":"","type":"image"}]}