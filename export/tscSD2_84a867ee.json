{"ver":"0.1","info":{"id":"tscSD2","date":"1576398422","viewed":280,"name":"interstellar_chase","username":"skaplun","description":"Starfield by @HamzaHutchinson","likes":26,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","noise","sdf","raymatch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_MARCHING_STEPS 96\n#define MIN_DIST 0.\n#define MAX_DIST 20.\n#define EPSILON 0.0001\n#define GAMMA 2.2\n#define map(p) texture(iChannel0, p)\n#define r(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n#define C_MOON 10\n#define C_UFO_MAIN 11\n#define C_UFO_SECOND 12\n#define C_UFO_ENGINE 13\n#define C_SHUTTLE_EX 14\n//#define BEZIER_ANTENNA\n#define WINGS\n#define NONE vec3(0.)\n\nstruct Hit{\n\tfloat dist;\n    int matID;\n    vec3 normal;\n};\n    \nconst Hit miss = Hit(-1., -1, NONE);\nvec3 albedoByID(int matID){\n    switch(matID){\n    \tcase 10:\n        \treturn vec3(.6);\n        case 11:\n        \treturn vec3(.7);\n        case 12:\n        \treturn vec3(24., 28., 60.)/255. * .5;\n        case 13:\n        \treturn vec3(253., 237., 136.)/255. * .5;\n        default:\n            return vec3(0.); \n    }\n}\n\nfloat smin( float a, float b, float k ){\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat det( vec2 a, vec2 b ) { return a.x*b.y-b.x*a.y; }\nvec3 getClosest(vec2 b0, vec2 b1, vec2 b2){\n  float a =     det(b0,b2);\n  float b = 2.0*det(b1,b0);\n  float d = 2.0*det(b2,b1);\n  float f = b*d - a*a;\n  vec2  d21 = b2-b1;\n  vec2  d10 = b1-b0;\n  vec2  d20 = b2-b0;\n  vec2  gf = 2.0*(b*d21+d*d10+a*d20); gf = vec2(gf.y,-gf.x);\n  vec2  pp = -f*gf/dot(gf,gf);\n  vec2  d0p = b0-pp;\n  float ap = det(d0p,d20);\n  float bp = 2.0*det(d10,d0p);\n  float t = clamp( (ap+bp)/(2.0*a+b+d), 0.0 ,1.0 );\n  return vec3( mix(mix(b0,b1,t), mix(b1,b2,t),t), t );\n}\n\nvec2 sdBezier( vec3 a, vec3 b, vec3 c, vec3 p )\n{\n\tvec3 w = normalize( cross( c-b, a-b ) );\n\tvec3 u = normalize( c-b );\n\tvec3 v =          ( cross( w, u ) );\n\n\tvec2 a2 = vec2( dot(a-b,u), dot(a-b,v) );\n\tvec2 b2 = vec2( 0.0 );\n\tvec2 c2 = vec2( dot(c-b,u), dot(c-b,v) );\n\tvec3 p3 = vec3( dot(p-b,u), dot(p-b,v), dot(p-b,w) );\n\n\tvec3 cp = getClosest( a2-p3.xy, b2-p3.xy, c2-p3.xy );\n\n\treturn vec2( sqrt(dot(cp.xy,cp.xy)+p3.z*p3.z), cp.z );\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r){\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdTorus(vec3 p, vec2 t){\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\nHit opMin(Hit a, Hit b) {\n    if (a.dist < b.dist) return a; else return b;\n}\n\nHit UFO(vec3 p){\n\tHit ufo = Hit(sdEllipsoid(p, vec3(1., 0.175, 1.)), C_UFO_MAIN, NONE);\n    ufo = opMin(ufo,\n              Hit(opSubtraction(p.y, sdEllipsoid(p, vec3(.6, .5, .6))), C_UFO_SECOND, NONE));\n    {\n        float delta = PI/4.;\n        float l = length(p.xz);\n    \tfloat a = mod(atan(p.z, p.x), delta) - delta/2.;\n        vec3 mp = vec3(l * sin(a), p.y, l * cos(a));\n    \tufo = opMin(ufo, Hit(length(mp - vec3(0., 0.075, .8)) - .06, C_UFO_SECOND, NONE));\n        ufo = opMin(ufo, Hit(sdCapsule(mp,vec3(0., -.135, .25), vec3(0., -.025, .8), .025 + l * .1), C_UFO_ENGINE, NONE));\n    }\n    \n    {\n        float antenna = length(p - vec3(.15, .7, 0.)) - .04;\n#ifdef BEZIER_ANTENNA\n        vec3 a = vec3(0., .5, 0.);\n        vec3 b = vec3(0., .7, 0.);\n        vec3 c = vec3(.15, .7, 0.);\n\n        float th = 0.0;\n        vec2 h = sdBezier( a, b, c, p );\n        float kh = h.y;\n\t\tfloat d = h.x - (.025 - smoothstep(.5, .85, p.y) * .015);\n\t\t\n        antenna = min(antenna, d);\n#endif\n    \tantenna = min(antenna, opSubtraction(p.y, length(p - vec3(0., .23, 0.)) - .3));\n        ufo = opMin(ufo, Hit(antenna, C_UFO_MAIN, NONE));\n    }\n    \n    return ufo;\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat udQuad( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 dc = d - c; vec3 pc = p - c;\n    vec3 ad = a - d; vec3 pd = p - d;\n    vec3 nor = cross( ba, ad );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(dc,nor),pc)) +\n     sign(dot(cross(ad,nor),pd))<3.0)\n     ?\n     min( min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n     dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat rounding(in float d, in float h){\n    return d - h;\n}\n\nHit spaceShuttle(vec3 p){\n    float mainBody = opSubtraction(.8 - p.x, smin(sdEllipsoid(p, vec3(1., .35, .4)), length(p - vec3(.8, 0., 0.)) - .35, .15));\n#ifdef WINGS\n    {\n    \tmainBody = min(mainBody,\n                       rounding(udQuad(vec3(p.xy, abs(p.z)), vec3(-.4, 0., 0.), vec3(.2, 0., .8), vec3(.4, 0., .9), vec3(.5, 0., 0.)), .075));\n        mainBody = min(mainBody,\n                       rounding(udQuad(p, vec3(0.), vec3(.3, -.4, 0.), vec3(.6, -.5, 0.), vec3(.6, 0., 0.)), .075));\n    }\n#endif\n    float second = sdEllipsoid(p + vec3(.4, .25, 0.), vec3(.25, 0.15, .25));\n    {\n        vec3 mp = p * 3.;\n        mp.xy *= r(radians(90.));\n    \tsecond = min(second, sdTorus(mp - vec3(0., 2.4, 0.), vec2(.85, .35)));\n    }\n    \n    return opMin(Hit(mainBody, C_UFO_MAIN, NONE), Hit(second, C_UFO_SECOND, NONE));\n}\n\nHit world(vec3 p){\n    vec4 moon = map(p);\n\tHit result = Hit(length(p) - 2. + moon.x, C_MOON, NONE);\n    \n    {\n        vec3 mp = p;\n        float a = iTime;\n        mp.xy *= r(radians(-45.));\n        mp.xz *= r(a);\n        mp.xy *= r(radians(90.));\n        mp.xz *= r(a * 2.);\n        mp -= vec3(0., 2.5, 0.);\n        \n    \tresult = opMin(result, UFO(mp));\n    }\n    \n    {\n        vec3 mp = p;\n        float a = iTime;\n        mp.xy *= r(radians(-45.));\n        mp.xz *= r(a);\n        mp.xz *= r(radians(30.));\n        mp.xy *= r(radians(90.));\n        mp.xz *= r(radians(90.));\n        mp += vec3(0., 2.5, 0.);\n        \n    \tresult = opMin(result, spaceShuttle(mp));\n    }\n    \n    {\n        float ang;\n        float size = .2;\n        {\n            vec2 mp = p.xz * r(iTime + PI/1.7);\n        \tang = atan(mp.x, mp.y)/(PI*2.) + .5;\n        \tsize *= min(smoothstep(.7, .95, ang),\n                        smoothstep(1.05, .95, ang)) * 1.25;\n        }\n        \n        vec3 mp = p;\n        float a = iTime;\n        mp.xz *= r(radians(90.));\n        mp.yz *= r(radians(-45.));\n        float delta = PI/25.;\n        float l = length(mp.xy);\n    \ta = mod(atan(mp.y, mp.x), delta) - delta/2.;\n        float id = floor(atan(mp.y, mp.x)/PI * 25.);\n        mp = vec3(l * sin(a), l * cos(a), mp.z);\n        \n        vec3 pos1 = vec3(0., 2.7, 0.) + vec3(0., shiftAtPos(id*10., iTime) * min(smoothstep(.6, .85, ang), smoothstep(1., .85, ang)) * .5);\n        pos1.y += smoothstep(1., .6, ang);\n        result = opMin(result, Hit(length(mp - pos1) - size, C_SHUTTLE_EX, normalize(mp - pos1)));\n        \n        vec3 pos2 = vec3(0., 2.7, 0.) + vec3(0., shiftAtPos(id * 10. + 137.17, iTime) * min(smoothstep(.6, .85, ang), smoothstep(1., .85, ang)) * .5);\n        pos2.y += smoothstep(1., .6, ang);\n        result = opMin(result, Hit(length(mp - pos2) - size, C_SHUTTLE_EX, normalize(mp - pos2)));\n    }\n    \n    return result;\n}\n\nHit march(vec3 eye, vec3 marchingDirection) {\n\tconst float precis = 0.001;\n    float t = 0.0;\n\tfloat l = 0.0;\n    for(int i=0; i<MAX_MARCHING_STEPS; i++){\n\t    Hit hit = world( eye + marchingDirection * t );\n        if( hit.dist < precis ) return Hit(t, hit.matID, hit.normal);\n        t += hit.dist * .5;\n    }\n    return miss;\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        world(vec3(p.x + EPSILON, p.y, p.z)).dist - world(vec3(p.x - EPSILON, p.y, p.z)).dist,\n        world(vec3(p.x, p.y + EPSILON, p.z)).dist - world(vec3(p.x, p.y - EPSILON, p.z)).dist,\n        world(vec3(p.x, p.y, p.z  + EPSILON)).dist - world(vec3(p.x, p.y, p.z - EPSILON)).dist\n    ));\n}\n\nfloat orenNayarDiffuse(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float roughness,\n  float albedo) {\n  \n  float LdotV = dot(lightDirection, viewDirection);\n  float NdotL = dot(lightDirection, surfaceNormal);\n  float NdotV = dot(surfaceNormal, viewDirection);\n\n  float s = LdotV - NdotL * NdotV;\n  float t = mix(1.0, max(NdotL, NdotV), step(0.0, s));\n\n  float sigma2 = roughness * roughness;\n  float A = 1.0 + sigma2 * (albedo / (sigma2 + 0.13) + 0.5 / (sigma2 + 0.33));\n  float B = 0.45 * sigma2 / (sigma2 + 0.09);\n\n  return albedo * max(0.0, NdotL) * (A + B * s / t) / PI;\n}\n\nfloat gaussianSpecular(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float shininess) {\n  vec3 H = normalize(lightDirection + viewDirection);\n  float theta = acos(dot(H, surfaceNormal));\n  float w = theta / shininess;\n  return exp(-w*w);\n}\n\nvec3 doLighting(in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec3 mal){\n    vec3 lin = vec3(0.0);\n\n    // key light\n    //-----------------------------\n    vec3  view = normalize(-rd);\n    const vec3 lig1 = normalize(vec3(-5., 5., 5.));\n\tconst vec3 lig2 = normalize(vec3(5., -5., 0.));\n    \n    float spc1 = gaussianSpecular(lig1, view, nor, 0.95)*0.5;\n    float dif1 = max(0., orenNayarDiffuse(lig1, view, nor, -20.1, 1.0));\n    vec3  col1 = vec3(2.,4.2,4.) * .75;\n    lin += col1*spc1+dif1*col1;\n    \n    float spc2 = gaussianSpecular(lig2, view, nor, 0.95);\n    float dif2 = max(0., orenNayarDiffuse(lig2, view, nor, -20.1, 1.0));\n    vec3  col2 = vec3(2., .05, .15) * 1.;\n    lin += col2*spc2+dif2*col2;\n\n    // ambient light\n    //-----------------------------\n    lin += vec3(0.05);\n\n    \n    // surface-light interacion\n    //-----------------------------\n    vec3 col = mal*lin;\n\n    return col;\n}\n\nvec3 doMaterial(in vec3 pos, in vec3 nor){\n    return vec3(0.125,0.1,0.2) + (vec3(.6,0.9,.4) * 3. * clamp(length(pos) - 2.1, 0., 1.));\n}\n\nconst int star_iterations = 10;\nfloat doBackgroundStars(in vec3 dir){\n    vec3 n  = abs( dir );\n    vec2 uv = ( n.x > n.y && n.x > n.z ) ? dir.yz / dir.x: \n              ( n.y > n.x && n.y > n.z ) ? dir.zx / dir.y:\n                                           dir.xy / dir.z;\n    \n    float f = 0.0;\n    \n    for( int i = 0 ; i < star_iterations; ++i )\n    {\n        uv = rotate( 1.07 * uv + vec2( 0.7 ), 0.5 );\n        \n        float t = 10. * uv.x * uv.y + iTime;\n        vec2 u = cos( 100. * uv ) * fbm( 10. * uv, 0.0 );\n        f += smoothstep( 0.5, 0.55, u.x * u.y ) * ( 0.25 * sin( t ) + 0.75 );\n    }\n    return f;\n}\n\nconst vec3 lightPos1 = vec3(-5., 5., 5.);\nconst vec3 lightPos2 = vec3(5., -5., 0.);\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tfloat a = (iResolution.x - iMouse.x) * .05;\n    a = smoothstep(0., .5, sin(iTime * .5)) * PI;\n    vec3 eye = vec3(15. * sin(a), /*sin(a) * 4. + 1.*/0., 15. * cos(a));\n    vec3 viewDir = rayDirection(45., iResolution.xy, fragCoord);\n    vec3 worldDir = viewMatrix(eye, vec3(0.), vec3(0., 1., 0.)) * viewDir;\n\tvec3 color = vec3(doBackgroundStars(worldDir));\n    Hit hit = march(eye, worldDir);\n    if (hit.matID != -1) {\n        vec3 p = (eye + hit.dist * worldDir);\n    \t\n        vec3 norm = estimateNormal(p);\n        vec3 albedo = hit.matID!=10?albedoByID(hit.matID):doMaterial(p, norm);\n        color = vec3(abs(dot(worldDir, norm)));\n\n        if (hit.matID == C_UFO_ENGINE || hit.matID == C_SHUTTLE_EX){\n        \tcolor = mix(vec3(1., 0., 0.), vec3(253., 237., 136.)/255., pow(abs(dot(worldDir, norm)), .5));\n        }else{\n        \tcolor = doLighting(eye, norm, worldDir, hit.dist, albedo);\n        }\n    }\n    \n    fragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MIN_FLOAT 1e-6\n#define MAX_FLOAT 1e6\n\nstruct Ray{vec3 origin, direction;};\nstruct HitRecord{float dist[2];vec3 ptnt[2];vec3 nrm[2];};\n    \nbool plane_hit(in vec3 ro, in vec3 rd, in vec3 po, in vec3 pn, out float dist) {\n    float denom = dot(pn, rd);\n    if (denom > MIN_FLOAT) {\n        vec3 p0l0 = po - ro;\n        float t = dot(p0l0, pn) / denom;\n        if(t >= MIN_FLOAT && t < MAX_FLOAT){\n\t\t\tdist = t;\n            return true;\n        }\n    }\n    return false;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\n#define PI 3.14159265359\n\n// https://www.shadertoy.com/view/XdBGzd\n// The MIT License\n// Copyright © 2014 Inigo Quilez\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n\n\n// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n\n// https://www.shadertoy.com/view/4djSRW\n// Trying to find a Hash function that is the same on ALL systens\n// and doesn't rely on trigonometry functions that change accuracy \n// depending on GPU. \n// New one on the left, sine function on the right.\n// It appears to be the same speed, but I suppose that depends.\n\n// * Note. It still goes wrong eventually!\n// * Try full-screen paused to see details.\n\n\n#define ITERATIONS 4\n\n\n// *** Change these to suit your range of random numbers..\n\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(.1031, .1030, .0973, .1099)\n\n// For smaller input rangers like audio tick or 0-1 UVs use these...\n//#define HASHSCALE1 443.8975\n//#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n//#define HASHSCALE4 vec3(443.897, 441.423, 437.195, 444.129)\n\n\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n        vec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n        vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n        p3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n        vec3 p3 = fract(vec3(p) * HASHSCALE3);\n        p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n        vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n        p3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n        vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n        p3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p){\n        vec4 p4 = fract(vec4(p) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p){\n        vec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p){\n        vec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4){\n        p4 = fract(p4  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n\n// By David Hoskins, May 2014. @ https://www.shadertoy.com/view/4dsXWn\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat Noise(in vec3 p){\n    vec3 i = floor(p);\n        vec3 f = fract(p); \n        f *= f * (3.0-2.0*f);\n\n    return mix(\n                mix(mix(hash13(i + vec3(0.,0.,0.)), hash13(i + vec3(1.,0.,0.)),f.x),\n                        mix(hash13(i + vec3(0.,1.,0.)), hash13(i + vec3(1.,1.,0.)),f.x),\n                        f.y),\n                mix(mix(hash13(i + vec3(0.,0.,1.)), hash13(i + vec3(1.,0.,1.)),f.x),\n                        mix(hash13(i + vec3(0.,1.,1.)), hash13(i + vec3(1.,1.,1.)),f.x),\n                        f.y),\n                f.z);\n}\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 ) * 1.7;\n\nfloat FBM( vec3 p ){\n    float f;\n\n        f = 0.5000 * Noise(p); p = m*p;\n        f += 0.2500 * Noise(p); p = m*p;\n        f += 0.1250 * Noise(p); p = m*p;\n        f += 0.0625   * Noise(p); p = m*p;\n        f += 0.03125  * Noise(p); p = m*p;\n        f += 0.015625 * Noise(p);\n    return f;\n}\n\nfloat hash( float n ) { return fract(sin(n)*123.456789); }\n\nfloat noise( in vec3 p )\n{\n    vec3 fl = floor( p );\n    vec3 fr = fract( p );\n    fr = fr * fr * ( 3.0 - 2.0 * fr );\n\n    float n = fl.x + fl.y * 157.0 + 113.0 * fl.z;\n    return mix( mix( mix( hash( n +   0.0), hash( n +   1.0 ), fr.x ),\n                     mix( hash( n + 157.0), hash( n + 158.0 ), fr.x ), fr.y ),\n                mix( mix( hash( n + 113.0), hash( n + 114.0 ), fr.x ),\n                     mix( hash( n + 270.0), hash( n + 271.0 ), fr.x ), fr.y ), fr.z );\n}\n\nfloat fbm( in vec2 p, float t )\n{\n    float f;\n    f  = 0.5000 * noise( vec3( p, t ) ); p *= 2.1;\n    f += 0.2500 * noise( vec3( p, t ) ); p *= 2.2;\n    f += 0.1250 * noise( vec3( p, t ) ); p *= 2.3;\n    f += 0.0625 * noise( vec3( p, t ) );\n    return f;\n}\n\nfloat fbm1x(float x, float time){\n\tfloat amplitude = 1.;\n    float frequency = 1.;\n    float y = sin(x * frequency);\n    float t = 0.01*(-time * 130.0);\n    y += sin(x*frequency*2.1 + t)*4.5;\n    y += sin(x*frequency*1.72 + t*1.121)*4.0;\n    y += sin(x*frequency*2.221 + t*0.437)*5.0;\n    y += sin(x*frequency*3.1122+ t*4.269)*2.5;\n    y *= amplitude*0.06;\n    return y;\n}\n\nvec2 shiftAtPos(float x, float time){\n\treturn vec2(fbm1x(x, time), fbm1x(x + 78.233, time));\n}\n\nvec2 rotate( in vec2 uv, float a)\n{\n    float c = cos( a );\n    float s = sin( a );\n    return vec2( c * uv.x - s * uv.y, s * uv.x + c * uv.y );\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"vec2 voronoi(in vec3 x){\n    vec3 p = floor( x );\n    vec3 f = fract( x );\n\n\tfloat id;\n    vec2 res = vec2( 100.0 );\n    for( int k=-1; k<=1; k++ )\n    \tfor( int j=-1; j<=1; j++ )\n    \t\tfor( int i=-1; i<=1; i++ ){\n                vec3 b = vec3( float(i), float(j), float(k) );\n                vec3 r = vec3( b ) - f + hash33( p + b );\n                float d = dot( r, r );\n\n                if( d < res.x ){\n                    id = dot(p + b, vec3(20.31, 517., 113.));\n                    res = vec2(d, res.x);\n                }else if(d < res.y){\n                    res.y = d;\n                }\n    }\n    return vec2(res.x, abs(id));\n}\n\nfloat height(vec3 p){\n\tvec4 h;\n    h.xy = voronoi(p * 3.);\n    h.z = FBM(10. * p);\n    h.w = FBM(3. * p);\n    float craterSize = mix(.01, .1, h.y * .001);\n    return - h.w * .3 + h.z * .04\n           + mix(-pow(smoothstep(craterSize * 2., craterSize, h.x), 16.) * .005,\n                  pow(smoothstep(craterSize, 0., h.x), .75) * .1, smoothstep(craterSize + .005, craterSize - .005, h.x));\n}\n\n#define EPSILON 0.01\nvec3 normal(vec3 p) {\n    return normalize(vec3(\n        height(vec3(p.x + EPSILON, p.y, p.z)) - height(vec3(p.x - EPSILON, p.y, p.z)),\n        height(vec3(p.x, p.y + EPSILON, p.z)) - height(vec3(p.x, p.y - EPSILON, p.z)),\n        height(vec3(p.x, p.y, p.z + EPSILON)) - height(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir ) {\n    if (iFrame > 1) discard;\n    fragColor -= fragColor;\n    fragColor.x = height(rayDir);\n    fragColor.gba = normal(rayDir);\n}","name":"Cube A","description":"","type":"cubemap"}]}