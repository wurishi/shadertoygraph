{"ver":"0.1","info":{"id":"WdtGWs","date":"1574495182","viewed":62,"name":"CDA_Test006","username":"Cephalopodium","description":"Part6 Shader from YT tutorial (the art of code )","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["smileyanimation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Title: Cda_Test006\n// Tag: Smiley Animation\n// Desc: Part6 Shader from YT tutorial (the art of code )\n// 27/9/19 15:58 thru video\n\n#define S(a,b,t) smoothstep(a,b,t)\n#define sat(x) clamp(x,0.,1.)\n\n// smoothstep() returns 0 to 1 S curve interpolation. Eg 3x^2-2*x^3 ~=Logistic curve internally\n// mix(a,b,x) Accepts a min \"a\", & max \"b\" range as input plus the value \"x\" implicitly between \n// 0 & 1 and returns the linear interpolation in the range a:b. Using the fn() (1-x)*a+x*b \n// This built in fn ops on vectors etc too.\n\nfloat cdamax (float a, float b) {\n   if (a>=b) { \n       return a; \n    } else { \n       return b;\n   }\n}\n\nfloat remap01(float a,float b,float t) {\n    // remaps t from range a-b to a Normalised range 0-1\n    return sat((t-a) / (b-a));   // extra sat() clamps result to 0..1\n}\n\nfloat remap(float a,float b,float c,float d,float t) {\n    // maps t from range a-b to into range c-d (linear map)\n    return sat((t-a) / (b-a)) * (d-c) + c;\n}\n\nvec2 within(vec2 uv,vec4 rect) {\n    // like remap01 but in two dimensions \n    return (uv-rect.xy) / (rect.zw-rect.xy);   //  sat() clamps result to 0..1\n}\n\nvec4 Brow(vec2 uv, float smile) { \n   float offs = mix(.2,0.,smile);\n   uv.y += offs;\n\n   float y = uv.y;\n   uv.y += uv.x*mix(.5,0.8,smile) - mix(0.1,0.3,smile); // skew + raise\n   uv.x -= mix(.0,0.1,smile);             // separate brows \n   uv -= .5;                              // normalize\n   vec4 col = vec4(0.);\n\n  float blur = .1;\n\n  float d1 = length(uv);                 // 1st circle\n  float s1 = S(.45,.45-blur,d1);         // \n  float d2 = length(uv-vec2(.1,-.2)*.7); // 2nd circle\n  float s2 = S(.5,.5-blur,d2);\n\n  float browMask = sat(s1-s2);           // Sub 2nd from 1st (force +ve)\n\n  float colMask = remap01(.7,.8,y)*.75;\n  colMask *= S(.6,.9,browMask);          // gradient to brow top too \n  colMask *= smile;                   // Adds brow gradient if smiling\n\n  vec4 browCol = mix(vec4(.4,.2,.2,1.),vec4(0.),colMask); // guessed post vec... tried d1\n\n     uv.y += .15-offs*.5;   // Create shadow under eyebrows - prevent shadow smile\n     blur += mix(.0,.1,smile);         // blur brow shadow less when brow is lower\n\n     d1 = length (uv);\n     s1 = S(.45,.45-blur,d1);          \n     d2 = length(uv-vec2(.1,-.2)*.7);\n     s2 = S(.5,.5-blur,d2);\n     float shadowMask = sat(s1-s2);          \n     col = mix(col,vec4(0.,0.,0.,1.),S(.0,1.,shadowMask)); // guessing..shadowMask));\n\n  col = mix(col,browCol,S(.2,.4,browMask)); // guessing... );\n  return col;\n}\n\nvec4 Eye(vec2 uv, float side, vec2 m, float smile) {\n   uv -= .5;                       // recenter\n   uv.x *= side;                   // suppress mirroring \n   float d = length(uv);           // distance from centre of eye  \n   vec4 irisCol = vec4(.3,.5,1.,1.);                // blue iris\n   vec4 col = mix(vec4(1.),irisCol,S(.17,.7,d)*.5); // S(.n sets whiteness \n   col.a = S(.5,.48,d);               // mask all outside eye \n\n   col.rgb *= 1. -S(.45,.5,d)*.5*sat(-uv.y-uv.x*side); // eye outline bottom edge, sat()=1 lid\n                                              // -uv.x shifts it to centre, *side renables mirror\n   d = length(uv - m*.5);                     // use different distance to \"see\" mouse with eye\n   col.rgb = mix(col.rgb,vec3(0.),S(.3,.28,d));      // black iris outline\n\n   irisCol.rgb *= 1. + S(.3,.05,d);                   // iris colour brighter centre\n   float irisMask = S(.28,.25,d);                // irisMask\n   col.rgb = mix(col.rgb,irisCol.rgb,irisMask);  // inner iris pupil (try 1- above)\n\n   d = length(uv - m*.57);                           // d moves pupil > eye to \"see\" mouse\n   float pupilSize = mix(.28,.16,smile);             // defines max smile size and original value\n   float pupilMask = S(pupilSize,pupilSize*.85,d);\n   pupilMask *= irisMask;                            // restricts pupil to iris,if psmax=.4,!= .28\n   col.rgb = mix(col.rgb,vec3(0.),pupilMask);        // blend in pupil\n\n   float t = iTime*3.;\n   vec2 offs = vec2(sin(t+uv.y*25.),sin(t+uv.x*25.));\n   offs *= .021*(1.-smile);                // cda Nice bug: val>.01 gives cloudy hlights try .52\n   uv+=offs;\n\n   float highlight = S(.1,.09,length(uv-vec2(-.15,.15))); // eye highlight\n   highlight += S(.07,.05,length(uv+vec2(-.08,.08)));     // smaller highlight\n   col.rgb = mix(col.rgb,vec3(1.),highlight);\n\n  // col.a = S(.5,.48,d);\n    return col;\n}\n\nvec4 Mouth(vec2 uv, float smile ) {\n   uv -= .5;                         // normalize coords \n   vec4 col = vec4(0.5,.18,.05,1.);  // define inner flat mouth colour \n   uv.y *= 1.5;              // scale down effect below - lowers mouth corners\n   uv.y -= pow(uv.x,2.)*2.59*smile;   // pow <= 2 grin ? bulge ellipse down \n   uv.x *= mix(2.5,1.,smile);         // widen and narrow smile \n \n   float d = length(uv);     // defines circular region squashed by within() box\n   col.a = S(.5,.48,d);      // set mask, blur distance .5 is mouth size \n   vec2 tuv = uv;\n   tuv.y += (abs(uv.x)*.5+.1)*(1.-smile);         // abs-> buck teeth  tongue shape\n   float td = length(tuv-vec2(0.,.6));             // define teeth length <.6 = longer\n\n   vec3 toothCol = vec3(1.)*S(.6,.35,d);          // set toothCol white with fade using d shape\n   col.rgb = mix(col.rbg, toothCol,S(.4,.37,td)); // set toothCol , blur distance teeth edge\n   td = length(uv+vec2(0.,.5));            // define tongue depth <.5 = longer\n   col.rgb = mix(col.rbg, vec3(1.,.5,.5),S(.5,.2,td));  // set tongue Col, blur dist tongue edge\n   return col;\n}\n\nvec4 Head(vec2 uv, int debug) {\n    vec4 col = vec4(0.9,.65,.1,.1);    // define initial flat head colour \n    float d = length(uv);              // d varies with distance from centre \n    col.a = S(.5,.49,d);               // macro smoothstep sets alpha range to blur\n                            // from 0 black outside when d>=0.5 to 1 inside circum - d<=0.49\n    float edgeShade = remap01(.35,.5,d);  // define edge as ring from .35 to .5\n    edgeShade *= pow(edgeShade,1.1);      // smoothen linear interpolation (with finer control)\n    col.rgb *= 1. - edgeShade*.5;         // apply fade to orange to circle edge \n                                          // * rgb vals by  0.9387 at centre to 0.875 at d=1\n    // add dark orange outline\n    col.rgb = mix(col.rgb,vec3(.6,.3,.1),S(.47,.48,d));  // merges Orange to rgb for d .47-.48 \n\n    float hlight = S(.41,.405, d);       // hlight value defines a blurred edge .41 at .405  \n    float hlHi  =  0.41;  float hlLow = -0.1;                // top and  bottom of highlight\n    hlight *= remap(hlHi,hlLow,0.75,0., cdamax(uv.y,hlLow)); // CDA Using uv.y to vary vertically\n    hlight *= S(.18,.19,length(uv-vec2(.21,.0875)));       // adds eye sockets\n    if (debug>0) {\n      hlight *= S(.067,.073,length(uv-vec2(.001,.255)));   // cda Cyclops socket\n    }\n  // col = mix(col, vec4(1.), 0.); // S(.41,.405,uv.y));   // CDA guessed vec4 needed\n    col.rgb = mix(col.rgb,vec3(1.),hlight);                  // defines highlight colour white\n  \n    d = length(uv-vec2(.25,-.2));                  // defines centre position\n    float cheek = S(.2,.01,d)*.4;                  // defines mask radius .2 \n    cheek *= S(.17,.16,d);                         // sharpens edge of cheek\n    col.rgb = mix(col.rgb, vec3(1.,.1,.1),cheek);  // defines cheek colour pink\n    return col;\n}\n\nvec4 Smiley(vec2 uv, vec2 m, float smile) {\n\n   int debug = 0; bool CDA=false;      // CDA my tweaks\n   // iTime % -> to blink debug \n   if (int(iTime)%int(5.)==0) { CDA = !CDA; } // fire trigger every 5th go\n   if (CDA) {debug = 1;} else {debug = 0;}    // CDA trigger cyclops\n\n  \n   vec4 col = vec4(0.);    // initialise screen to black, with 0 alpha\n   float side = sign(uv.x); // returns plus or minus 1\n   uv.x = abs(uv.x);       // mirrors x coord to create 2 cheeks & eyes etc \n   vec4 head= Head(uv,debug);   // get head \n\n   // iLeft,iBottom,iRight,iTop using same coords as uv\n   float iLeft=.03; float iBottom = -.1; float iRight = .37; float  iTop = .25;\n   vec4 eye = Eye(within(uv,vec4(iLeft,iBottom,iRight,iTop)),side,m,smile);  // Def. eye box\n\n   float icyLeft=-.069; float icyBottom = .197; float icyRight = .069; float icyTop = .314;\n   vec4 cy_eye = Eye(within(uv,vec4(icyLeft,icyBottom,icyRight,icyTop)),side,m,smile);  // cda Def. Cyclops\n\n   float mLeft=-.3; float mBottom = -.43; float mRight = .3; float  mTop = -.13;\n   vec4 mouth = Mouth(within(uv,vec4(mLeft,mBottom,mRight,mTop)),smile);  // Def. Mouth box\n   float bLeft=.03; float bBottom = .2; float bRight = .4; float bTop = .45; \n   vec4 brow = Brow(within(uv,vec4(bLeft,bBottom,bRight,bTop)),smile);  // Def. Brow box\n\n   col = mix(col,head,head.a);  // Blends 1st 2 params based on 3rd - range (0..1)\n   col = mix(col,eye,eye.a);    // Blends eye after head\n   if (debug>0) {\n      col = mix(col,cy_eye,cy_eye.a); // Blends cyclops \n   }\n   col = mix(col,mouth,mouth.a);      // Blends mouth \n   col = mix(col,brow,brow.a);        // Blends brow \n\n   return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n  vec2 uv= fragCoord.xy/iResolution.xy;\n  uv-=.5;\n  uv.x *= iResolution.x / iResolution.y ;\n  vec2 m = iMouse.xy /iResolution.xy;\n  m -= .5;\n  uv -= m * (.25 - dot(uv,uv));           // uses dot product to simulate rotation via distortion\n\n  float smile = (cos(iTime)*0.5) + 0.5;   // starts at 1 surfs to 0 n back..\n  fragColor=Smiley (uv,m,smile);\n}\n\n\n","name":"Image","description":"","type":"image"}]}