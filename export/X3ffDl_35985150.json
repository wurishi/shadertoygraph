{"ver":"0.1","info":{"id":"X3ffDl","date":"1729445738","viewed":89,"name":"Ray-Tracer Made by Mohammed","username":"sadekguerrah2","description":"RT Shadows reflections and AO made in a weekend","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["pathtracers"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n         vec2 st = uv;\n        st.x = st.x * (iResolution.x/iResolution.y);   \n           \n      float comp = clamp(iTime,1.,1000.);\n      vec3 Bnoise = texture(iChannel1,uv).rgb;\n\n    st = .01*(Bnoise.xy -.5)+ uv;\n    \n    // Time varying pixel color\n    vec3 col = texture(iChannel0,uv).rgb;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n////بِسْمِ ٱللَّٰهِ ٱلرَّحْمَٰنِ ٱلرَّحِيمِ//\n\n\n\n\n\n   #define PI 3.14159265359\n   #define TWO_PI 6.28318530718\n   #define EYEPATHLENGTH 1\n   #define FOV 60\n   #define SAMPLES 8\n     \n\n   //Global Varriables\n   float c = .1;\n   const float limit = float(EYEPATHLENGTH)*1000.;\n   ////Uniform////\n \n const int KEY_LEFT  = 65;\n const int KEY_UP    = 87;\n const int KEY_RIGHT = 68;\n const int KEY_DOWN  = 83;\n const int KEY_ELV  = 69;\n const int KEY_DELV  = 81;\n\n\nvec3 handleKeyboard(vec3 offset) {\n    vec3 velocity = vec3(1.); // This will cause offset to change by 0.01 each time an arrow key is pressed\n    \n    // texelFetch(iChannel1, ivec2(KEY, 0), 0).x will return a value of one if key is pressed, zero if not pressed\n    vec3 left = texelFetch(iChannel0, ivec2(KEY_LEFT, 0), 0).x * vec3(-1, 0,0);\n    vec3 up = texelFetch(iChannel0, ivec2(KEY_ELV,0), 0).x * vec3(0, 1,0);\n    vec3 right = texelFetch(iChannel0, ivec2(KEY_RIGHT, 0), 0).x * vec3(1, 0,0);\n    vec3 down = texelFetch(iChannel0, ivec2(KEY_DELV, 0), 0).x * vec3(0, -1,0);\n    vec3 fowr = texelFetch(iChannel0, ivec2(KEY_UP, 0), 0).x * vec3(0, 0,1);\n    vec3 bowr = texelFetch(iChannel0, ivec2(KEY_DOWN, 0), 0).x * vec3(0, 0,-1);    \n\n\n      \n    \n            \n         offset += (left+right) * velocity;\n         offset += (bowr+fowr) * velocity;\n         offset += (down+up) * velocity;\n\n\n\n    return offset;\n}\n\n       \n\n// Filmic Tonemapping Operators http://filmicworlds.com/blog/filmic-tonemapping-operators/\nvec3 filmic(vec3 x) {\n  vec3 X = max(vec3(0.0), x - 0.004);\n  vec3 result = (X * (6.2 * X + 0.5)) / (X * (6.2 * X + 1.7) + 0.06);\n  return pow(result, vec3(2.2));\n}\n\nvec3 aces(vec3 x) {\n  const float a = 2.51;\n  const float b = 0.03;\n  const float c = 2.43;\n  const float d = 0.59;\n  const float e = 0.14;\n  return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\n  \n\n\n\n\n      ///uniformic Function\n        ///hitPoint Function////\n           vec3 hitpoint(vec3 ray, vec3 rayo, float dist) {\n              return rayo+(ray*vec3(dist));\n           }\n           \n           ///vector to light function////\n\n            vec4 vectorlight(vec3 pos, vec3 hp) {\n            float len = length(pos-hp);\n               return vec4((normalize(pos-hp)),len);\n            }\n\n\n\n            ///White Noise///\n         float rand(vec2 st) {\n    return fract(sin(dot(2.*st.xy,\n                         vec2(12.9898,78.233))+iMouse.x-iMouse.y)*\n        4372238.5453123);\n         }\n      \n\n       ////Unifrom 3D RGB Noise////\n      vec3 Noise(in vec2 st){\n\n\n          float x = rand(st.xy);\n          float y = rand(st.yx);\n          float z = rand(vec2(-st.x,st.y));\n\n          return hash3(st.x);\n      }\n\n//3D Rotational metric Equations\n\n\nmat3 rotatex(float theta) {\n  return mat3(1.,0.,0.,\n              0., cos(theta), -sin(theta),\n              0., sin(theta), cos(theta));\n}\n  mat3 rotatey(float theta) {\n  return mat3(cos(theta),0.,sin(theta),\n              0., 1., 0.,\n              -sin(theta), 0., cos(theta));  }\n\n///2D Metric Rotational equation\n\nmat2 rotate(float th) {\n\n  return mat2(\n    cos(th), -sin(th),\n    sin(th), cos(th)\n  );\n}\n\n\n      ////Global Function////\n       ///LightFunction/// \n                   ///type Function////\n         vec4 Pointlight(in vec3 rd,in vec3 ro,in vec3 normal, float d,in vec3 lightposition,in vec4 Lightcolor) {\n                vec3 hp = hitpoint(rd,ro,d);  \n                 vec3 glvectorlight = normalize(lightposition-hp);\n                   float len = length(lightposition-hp);\n                    float lm = max(dot(normal,glvectorlight),0.);\n                    float glshade = Lightcolor.w*(lm/(pow(len,2.)));\n                     \n\n\n                     vec3 col = Lightcolor.xyz*vec3(glshade);\n                     \n            return vec4(vec3(col),lm);           ////the lightmap ---> .w // and LightColor ----> .rgb is Stored in a vec4 information: \n                              }  \n\n                      ////General Direct LightSource////\n                         vec4 DirLight(in vec3 normal, in vec3 lightpostion, in vec4 Lightcolor) {\n\n                      vec3 gldirVector = normalize(lightpostion);\n                    \n                       float lm = Lightcolor.w*(dot(normal,gldirVector));\n                      \n                      vec3 col = Lightcolor.xyz*vec3(lm);\n                      return vec4(vec3(col),lm);\n                             }\n\n\n\n    ///Sphere Functions////\n\n     vec4 intsphere(in vec3 ray,in vec3 rayo, vec3 pos,const float radius,in vec3 Normal,in float WSdist) {\n         ///length intersection//\n        float l = max((dot((pos-rayo),ray)),0.);\n        float b = distance(pos,hitpoint(ray,rayo,l));  \n         float f = float(bool(distance(rayo,pos)>radius));\n         float i = float(bool(b < radius));    \n             i = i*f;\n\n          float a = l-(sqrt((radius*radius)-(b*b))); \n           \n             float dist = a;\n                if (float(i) < 1.){dist = limit;}\n                  bool n = (dist<WSdist);\n               vec3 normal = normalize(hitpoint(ray,rayo,dist)-pos);\n                  if (float(n)<1.) {normal=Normal;}\n                    \n                      dist = min(dist,WSdist);  \n\n\n       return vec4(vec3(normal),dist);\n     }\n       ///Global Generate Point on Hemisphere////\n         vec3 coshemfun(in vec3 n,in vec2 st) {\n\n           float r1 = hash1(st.x);\n           float r2 = hash1(st.y); \n              ///unifrom distribution///\n                float ud = sqrt(r2);  \n              ///Shoot 2D point from r1 \n              vec2 net1 = vec2(cos(TWO_PI*r1),sin(TWO_PI*r1));\n                net1.x *= ud;\n                net1.y *= ud;\n              //pick hem///\n               float net2 = sqrt(1.-r2);\n                  vec3 hnet = vec3(net1.x,net2,net1.y);\n                  \n            const vec3 in1 = vec3(-1.,-1.,1.);\n            const vec3 in2 = vec3(0.,1.,0.);\n\n             vec3 c1 = normalize(cross(n,in2));\n\n\n\n             vec3 v1 = hnet*in1;\n             vec3 v2 = n*in2;\n             float dp = dot(v1,v2)/v2.z;\n             vec3 normal = dp*n;\n\n            return normal-v1;\n         }\n  \n       ///Intersection Function\n     ///Visual matrix\n     \n       const float radi1 = .8;\n       const vec3 pos2 = vec3(-0.3294, 0.60, 2.20745); float radi2 = 0.7;\n        const vec3 pos3 = vec3(0.8,1.0,1.8); float radi3 = .8;\n        const vec3 pos4 = vec3(0.28,2.0,2.3); float radi4 = 0.8;\n        const vec3 pos5 = vec3(-2.2,1.0,2.9); float radi5 = 0.8;\n\n         const vec3 GlobalNormal = vec3(0.);\n\n\n\n          \n         \n         vec4 intscene(in vec3 rd, in vec3 ro){\n\n\n            vec3 pos1 = vec3(0.+sin(iTime), -0.6706, 3.2+cos(iTime));\n\n                     vec3 pos6 = vec3(0.8,1.0,(3.8-sin(iTime))); float radi6 = 0.8;\n            vec4 isphere1 = intsphere(rd,ro,pos1,radi1,GlobalNormal,limit);\n            vec4 isphere2 = intsphere(rd,ro,pos2,radi2,isphere1.xyz,isphere1.w);\n            vec4 isphere3 = intsphere(rd,ro,pos3,radi3,isphere2.xyz,isphere2.w);\n            vec4 isphere4 = intsphere(rd,ro,pos4,radi4,isphere3.xyz,isphere3.w);\n            vec4 isphere5 = intsphere(rd,ro,pos5,radi5,isphere4.xyz,isphere4.w);\n            vec4 isphere6 = intsphere(rd,ro,pos6,radi6,isphere5.xyz,isphere5.w);\n\n\n            vec3 Normal = isphere6.xyz;   \n            float dist = isphere6.w; \n\n\n\n          return vec4(Normal,dist); \n         }     \n\n         mat2 Mintid(in vec3 rd, in vec3 ro){\n\n              vec3 pos1 = vec3(0.+sin(iTime), -0.6706, 3.2+cos(iTime));\n \n            vec4 isphere1 = intsphere(rd,ro,pos1,radi1,GlobalNormal,limit);\n               bool i1 = (isphere1.w<limit);         \n            vec4 isphere2 = intsphere(rd,ro,pos2,radi2,isphere1.xyz,isphere1.w);\n               bool i2 = (isphere2.w<isphere1.w);\n            vec4 isphere3 = intsphere(rd,ro,pos3,radi3,isphere2.xyz,isphere2.w);\n               bool i3 = (isphere3.w<isphere2.w);\n            vec3 Normal = isphere3.xyz;   \n            float dist = isphere3.w; \n\n\n\n          return mat2(float(i1),float(i2),float(i3),0.); \n         }     \n\n\n        \n             ////Material Index////\n        vec4 MatData(vec3 rd,vec3 ro) {\n            vec4 index0 = vec4(vec3(0.1176, 0.1882, 0.5294),float (.0)); \n            vec4 index1 = vec4(vec3(1.0, 1.0, 1.0),float (.3)); \n            vec4 index2 = vec4(vec3(0.4196, 0.8667, 0.0549),float (.6)); \n             \n               mat2 id = Mintid(rd,ro);\n              \n              vec3 c1 = index0.rgb * vec3(id[0][0]);\n                vec3 c2 = index1.rgb * vec3(id[1][0]);\n                 vec3 c3 = index2.rgb * vec3(id[0][1]);\n                     \n               vec3 col = c1+c2+c3;\n                 if ( float(id[0][0]) < float(id[1][0])) {col = c2;}\n                 if ( float(id[1][0]) < float(id[0][1])) {col = c3;}\n               \n\n\n\n            return vec4(col,1.);\n        }\n\n                   ///Light Source Matrix////\n              \n         const vec3 plightpos1 = vec3(1.8706, 02.6667, -0.9667); const vec4 icol1 = vec4(vec3(1.0, 1.0, 1.0),40.1);  \n         const vec3 plightpos2 = vec3(0.2627, 0.0784, 1.22849); const vec4 icol2 = vec4(vec3(0.5294, 0.1333, 0.0549),0.1);   \n         const vec3 plightpos3 = vec3(-1.2627, 01.0784, 0.849); const vec4 icol3 = vec4(vec3(0.3275, 0.33, 0.3024),1.142);\n         const vec3 plightpos4 = vec3(-2.2627, -2.0784, 0.5849); const vec4 icol4 = vec4(vec3(0.1608, 0.1608, 0.1608),1.612);\n      ///gldiffuse_function_Direct+indirect///\n        vec4 gldiffuse(in vec3 rd, in vec3 ro,in vec3 normal,const float dist,in vec3 glhp,in vec2 st1){\n             \n\n            //Hitpoint\n            vec3 hp = hitpoint(rd,ro,dist);\n            vec3 hemdir1 = coshemfun(normal,st1);\n               \n                 vec4 gi = intscene(hemdir1,hp);\n                 vec3 hp2 = hitpoint(hemdir1,hp,gi.w);\n\n\n\n             /// Light Jitter Offsets \n               vec3 jit = 1.*Noise(st1);\n             ///vector to light\n                   //Direct Light \n                vec4 ilight1 = Pointlight(rd,ro,normal,dist,plightpos1+jit,icol1);\n                vec4 ilight2 = Pointlight(rd,ro,normal,dist,plightpos2+jit,icol2);\n                vec4 ilight3 = Pointlight(rd,ro,normal,dist,plightpos3+jit,icol3); \n                vec4 ilight4 = Pointlight(rd,ro,normal,dist,plightpos4+jit,icol4); \n                      \n                      ///indirect Light\n                vec4 gilight1 = Pointlight(hemdir1,hp,normal.xyz,gi.w,hemdir1+jit,icol1);\n                vec4 gilight2 = Pointlight(hemdir1,hp,normal.xyz,gi.w,hemdir1+jit,icol2);\n                vec4 gilight3 = Pointlight(hemdir1,hp,normal.xyz,gi.w,hemdir1+jit,icol3); \n                vec4 gilight4 = Pointlight(hemdir1,hp,normal.xyz,gi.w,hemdir1+jit,icol4);\n\n                     \n\n\n\n                  vec4 vectorData1 = vectorlight(plightpos1+jit,glhp);\n                  vec4 vectorData2 = vectorlight(plightpos2+jit,glhp);\n                  vec4 vectorData3 = vectorlight(plightpos3+jit,glhp);\n                  vec4 vectorData4 = vectorlight(plightpos4+jit,glhp);\n                  //indirect data\n                  vec4 giData1 = vectorlight(plightpos1+jit,hp2);\n                  vec4 giData2 = vectorlight(plightpos2+jit,hp2);\n                  vec4 giData3 = vectorlight(plightpos3+jit,hp2);\n                  vec4 giData4 = vectorlight(plightpos4+jit,hp2);\n\n\n                     vec4 iShadow1 = intscene(vectorData1.xyz,glhp);\n                       bool cs1 = (iShadow1.w > vectorData1.w);\n                        ilight1 = ilight1*vec4(cs1);\n                      vec4 iShadow2 = intscene(vectorData2.xyz,glhp);\n                        bool cs2 = (iShadow2.w > vectorData2.w);\n                         ilight2 = ilight2*vec4(cs2);\n                      vec4 iShadow3 = intscene(vectorData3.xyz,glhp);\n                        bool cs3 = (iShadow3.w > vectorData3.w);\n                         ilight3 = ilight3*vec4(cs3);\n                      vec4 iShadow4 = intscene(vectorData4.xyz,glhp);\n                        bool cs4 = (iShadow4.w > vectorData4.w);\n                         ilight4 = ilight4*vec4(cs4);\n\n\n\n                     vec4 giShadow1 = intscene(vectorData1.xyz,glhp);\n                       float gcs1 = float(giShadow1.w > 3000.);\n                        gilight1 = gilight1*vec4(gcs1);\n                      vec4 giShadow2 = intscene(vectorData2.xyz,glhp);\n                        bool gcs2 = (giShadow2.w > 3000.);\n                         gilight2 = gilight2*vec4(gcs2);\n                      vec4 giShadow3 = intscene(vectorData3.xyz,glhp);\n                        bool gcs3 = (giShadow3.w > 3000.);\n                        gilight3 = gilight3*vec4(gcs3);\n                      vec4 giShadow4 = intscene(vectorData4.xyz,glhp);\n                        bool gcs4 = (giShadow4.w > 3000.);\n                         gilight4 = gilight4*vec4(gcs4);\n\n\n              vec4 sumgili = gilight1+gilight2+gilight3+gilight4;\n              vec4 SumLight = ilight1+ilight2+ilight3+ilight4;\n\n              vec4 final = sumgili+SumLight;\n            return final;\n        }\n\n\n\n    ///Reflections\n\n    vec4 RTReflection(vec3 ro, vec3 hp,vec3 normal,vec3 rd, vec2 st, vec3 diff,in float r){\n\n\n    float roughness = r;\n        vec3 jit = 1.*Noise(st*12.);   \n      \n        vec3 ref = reflect(rd,normal+roughness*jit);\n        vec4 refhit = intscene(ref,hp);\n         vec3 hhp = hitpoint(rd,ro,refhit.w); \n             \n           vec4 ColBuffer = MatData(rd,ro);\n\n           vec4 refdiff = gldiffuse(rd,ro,refhit.xyz,refhit.w,hhp,st);\n\n            ///Frenel Effect\n            float a =.11;\n            float f =  0.;\n             if ( a > .001) {f = pow((dot(normal,rd)+1.),4.54);}\n                 refdiff.xyz = refdiff.xyz*7.*diff;\n\n            return vec4(refdiff.xyz,f);\n    }\n\n\n\n\n ////Render Buffer Function/////\n\n\n vec3 rBuffer(vec3 RayD, vec3 RayO, vec2 st,vec2 seed) {\n\n\n\n          vec4 tod; \n          vec3 col;\n          vec3 glNormal;\n\n           ///Scene \n          tod = intscene(RayD,RayO);\n           glNormal = tod.xyz;    vec3 glHitPoint = hitpoint(RayD,RayO,tod.w);\n        vec4 ColBuffer = MatData(RayD,RayO);  \n         vec4 DiffBuffer = gldiffuse(RayD,RayO,glNormal,tod.w,glHitPoint,st+seed);\n          vec4 RefBuffer = RTReflection(RayO,glHitPoint,glNormal,RayD,st+seed,DiffBuffer.xyz,float(0.1));  \n            vec3 glrender = mix(DiffBuffer.rgb,RefBuffer.rgb,RefBuffer.w);\n\n  return glrender;\n }\n\n\n\n\n              \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n           \n         ///THIS IS NOW 3D space Screen the idea is no longer using the SCREENuv we are using the object space to shootrays;\n        \nbool reset = iFrame == 0;\n    ivec2 f = ivec2(fragCoord);\n\n\n\n    vec2 mo = abs(iMouse.xy)/iResolution.xy - .5;\n    if (iMouse.xy == vec2(0)) mo = vec2(.05,.1);\n\n    vec4 data1 = texelFetch(iChannel3, ivec2(0), 0);\n    vec4 data2 = texelFetch(iChannel2, ivec2(0), 0);\n    \n    if (floor(mo*iResolution.xy*10.) != data1.yz) {\n        reset = true;\n    }\n    if (data2.xy != iResolution.xy) {\n        reset = true;\n    }\n\n\n              vec2 st = fragCoord.xy/iResolution.xy;\n              st = 2.*(st-.5);\n              st.x *= iResolution.x/iResolution.y;    \n\n\n         \n\n          //RayConst \n          vec3 RayO = vec3(0.0, 0.0, -02.0);\n\n               //RayO = rotatey(iTime)*RayO;  \n                  \n              RayO = handleKeyboard(RayO);\n              \n           //Fov to e \n         float e = 1./(tan((radians(float(FOV)))/2.));\n         float ef = e; \n          \n                   vec3 RayA = (vec3(st.x,st.y,ef));\n                     \n                              RayA = rotatey(.003*(.5-iMouse.x)+.5)*RayA;\n                              RayA = rotatex(.003*iMouse.y-1.)*RayA;\n                      vec3 RayD = normalize(RayA);\n                           \n             float seed = st.x + st.y * 3.43121412313;        \n               \n\n\n\n\n\n             ///Final Pipline Render/////   \n\n              vec3 bufferA = vec3(0.0);\n               for( int i = 1; i <= SAMPLES; i++ )\n               \n               \n                bufferA = mix(bufferA, rBuffer(RayD,RayO,vec2(st),vec2(seed+float(i )+iTime)).xyz, 1.0/float(i));\n                   \n\n                   \n         \n\n             vec3 col = aces(bufferA);\n\n             col = pow(col,vec3(1./2.2));\n                                      \n    if (reset) {\n       fragColor = vec4(col, 1.0);\n    } else {\n       fragColor = vec4(col, 1.0) + texelFetch(iChannel3, ivec2(fragCoord), 0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n//\n// Hash functions by Nimitz:\n// https://www.shadertoy.com/view/Xt3cDn\n//\n\nuint baseHash(uvec2 p) {\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nfloat hash1(inout float seed) {\n    uint n = baseHash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    return float(n)/float(0xffffffffU);\n}\n\nvec2 hash2(inout float seed) {\n    uint n = baseHash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 hash3(inout float seed) {\n    uint n = baseHash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\n    return vec3(rz & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\n\n","name":"Common","description":"","type":"common"}]}