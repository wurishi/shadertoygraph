{"ver":"0.1","info":{"id":"mddfR8","date":"1696880562","viewed":43,"name":"09. Bounce","username":"Ladus","description":"Inktober 2023 Day 9. A bouncing ball, my first attempt at using a buffer. The square in the bottom left is the color that is contained in the memory buffer which contains the position and velocity.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["bounce","bouncingball","inktober"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// For how to use memory I used \"Variables with ShaderToy Buffers\" by oneshade - https://www.shadertoy.com/view/tdGBDG\nconst ivec2 POSVEL_ADDR = ivec2(0, 0);\n#define fetchData(buf, addr) texelFetch(buf, addr, 0)\n#define storeData(buf_pos, addr) ivec2(buf_pos) == addr\n\nfloat sdCircle(vec2 p, float r) {\n    return distance(vec2(0), p)-r;\n}\n\nvec2 normalizeScreenSpace(vec2 fragCoord, out float aa) {\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    uv.x -= 1.-(iResolution.y/iResolution.x);\n    uv = (uv - vec2(0.5))*2.;\n    aa = 0.003; // I should probably calculate the anti aliasing res with the iResolution...\n    return uv;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    const float floorHeight = 0.7;\n    const float ballRadius = 0.2;\n       \n    float aa = 0.;\n    vec2 p = normalizeScreenSpace(fragCoord, aa);\n   \n    // Get position from memory buffer\n    vec4 posvel = fetchData(iChannel0, POSVEL_ADDR);\n    vec2 position = posvel.xy;\n    vec2 velocity = posvel.zw;\n   \n    vec2 circleSpace = p;\n    circleSpace += position;\n    float circleSdf = sdCircle(circleSpace, ballRadius);\n    float ballMask = 1.-smoothstep(0.-aa,0.+aa,circleSdf);\n    float floorMask = 1.-step(0., p.y + floorHeight + ballRadius); \n    \n    // Colors\n    vec3 backgroundColor = vec3(0.2) * (1.-(pow(distance(vec2(p.x,p.y-0.8),vec2(0,0))*.6,2.)*0.2));\n    vec3 floorColor = vec3(0.,0.3,0.6) * clamp(0.,1.,(2.*(1.-(pow(p.y,8.)))+.3));\n    vec3 ballColor = vec3(1.,.5,0.) * ((abs(circleSdf)*5.)+0.6);\n    \n    float v = max(ballMask, floorMask);\n    \n    vec3 sceneColor = mix(backgroundColor, floorColor, floorMask);\n    sceneColor = mix(sceneColor, ballColor, ballMask);\n    \n    //sceneColor = floorColor;\n    \n    //show memoryBuffer (improved by comment from elenzil)\n    float memoryMask = 1.0 - step(100.0, max(fragCoord.x, fragCoord.y));\n    vec3  memoryColor = posvel.xyz;\n    \n    // Mix memory and circle\n    vec3 sphereAndMemory = mix(sceneColor, memoryColor, memoryMask);\n    \n    fragColor = vec4(sphereAndMemory,1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const ivec2 POSVEL_ADDR = ivec2(0, 0);\n#define fetchData(buf, addr) texelFetch(buf, addr, 0)\n#define storeData(buf_pos, addr) ivec2(buf_pos) == addr\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    const float floorHeight = 0.7;\n    const float gravity = 10.;\n    const float drag = 0.4;\n\n    if(storeData(fragCoord, POSVEL_ADDR)) {\n        // Set initial velocity and position\n        fragColor = vec4(0.9,-0.75,.8,-0.0001);\n    }\n\n    if (iFrame > 0) { // After initialization       \n        \n        if (storeData(fragCoord, POSVEL_ADDR)) {\n            vec4 posvel = fetchData(iChannel0, POSVEL_ADDR);\n            vec2 position = posvel.xy;\n            vec2 velocity = posvel.zw;\n            \n            // Bounce flip velocity\n            if (position.y >= floorHeight) {\n                position.y = floorHeight-0.0001;\n                velocity.y *= 0.9;\n                velocity.y = 0. - velocity.y;\n            }\n            if (position.y < floorHeight){ \n                velocity.x *= 1.-drag*iTimeDelta;\n                velocity -= vec2(0.,gravity*iTimeDelta);\n            }\n            \n            position = position - velocity*iTimeDelta;\n\n            fragColor = vec4(position, velocity);\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}