{"ver":"0.1","info":{"id":"Mct3R7","date":"1711541332","viewed":83,"name":"loading ui","username":"cesor","description":"an implementation about loading ui.\nreference ue5 lyra's M_UI_Base_AmmoCounter material.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","loading","ui"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    reference: UE5 Lyra's M_UI_Base_AmmoCounter material.\n*/\n\n#define PI 3.1415926\n#define TPI (PI * 2.)\n\n// UVs\n#define NORM_UV_X 0.\n#define NORM_UV_Y 1.\n#define UV_SCALE 1.\n\n// TIME\n#define SPEED 1.6\n\n// ARC\n#define ARC_RANGE .5\n\n// ARC SEGMENT\n#define USE_SEGS 0.\n#define ARC_SEGS 6.\n#define ARC_SEGS_POW 1.\n#define ARC_SEGS_SPACE .0\n#define ARC_SEGS_HARDNESS 1.\n\n// ARC EDGE\n#define USE_EDGE 1.\n#define ARC_EDGE_IN .8\n#define ARC_EDGE_OUT .23\n#define ARC_EDGE_HARDNESS 64.\n\n// angle between 0-1\nvec2 rotator(vec2 uv, vec2 center, float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    mat2 rot_mat = mat2(c, -s, s, c);\n    vec2 v = uv - center;\n    return rot_mat * v;\n}\n\nfloat vec2radial(vec2 uv)\n{\n    return fract(atan(uv.y,uv.x) / TPI);\n}\n\nvec2 normuv(vec2 co)\n{\n    vec2 uvnorm = vec2(\n        iResolution.x * NORM_UV_X + iResolution.y * (1.-NORM_UV_X),\n        iResolution.y * NORM_UV_Y + iResolution.x * (1.-NORM_UV_Y));\n    vec2 uv = co / uvnorm;\n    uv.y = 1. - uv.y; // revert uv.y\n    uv *= UV_SCALE;\n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv_base = fragCoord;\n    vec2 uv = normuv(fragCoord);\n    vec2 uv_cen = normuv(iResolution.xy*.5);\n    vec2 uv_rot = rotator(uv, uv_cen, iTime * SPEED);\n    \n    // 1. arc base\n    float mask_arc_base = vec2radial(uv_rot);\n    \n    // 1.1 arc mask\n    float mask_arc = clamp( (mask_arc_base+mix(-1.,1.,ARC_RANGE)-ARC_RANGE) / ARC_RANGE, 0., 1. );\n    \n    // 1.2 subsection\n    mask_arc = mask_arc * mix(1., ARC_SEGS, USE_SEGS);\n    mask_arc += .5;\n    mask_arc = pow(1.-abs(sin(mask_arc*PI)), ARC_SEGS_POW) - mix(0., 1., ARC_SEGS_SPACE);\n\n    // 1.3 dist mask\n    float mask_dist = 1. - length(uv_rot - uv_cen);\n    mask_dist = (mask_dist - .5) * 2.;\n\n    // 1.4 summary\n    float arc = mask_arc * mix(ARC_SEGS_HARDNESS, 0., mask_dist);\n    arc = clamp(arc, 0., 1.);\n    \n    \n    // 2. edge mask\n    // 2.1 dist mask\n    mask_dist = 1. - length(uv - uv_cen);\n    mask_dist = (mask_dist - .5) * 2.;\n    \n    // 2.2 dist mask - inner\n    float mask_dist_in = mask_dist + (ARC_EDGE_IN - 1.);\n    mask_dist_in = clamp(mask_dist_in * ARC_EDGE_HARDNESS, 0., 1.);\n    \n    // 2.3 disk mask - outer\n    float mask_dist_out = (1. - mask_dist) + (ARC_EDGE_OUT - 1.);\n    mask_dist_out = clamp(mask_dist_out * ARC_EDGE_HARDNESS, 0., 1.);\n    \n    // 2.3 blend inner and outer dist mask\n    float edge = clamp(mask_dist_in * mix(1., mask_dist_out, USE_EDGE), 0., 1.);\n\n\n    float ret = arc * edge;\n    vec3 col = vec3(ret);\n    //col = vec3(mask_arc);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}