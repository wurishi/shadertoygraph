{"ver":"0.1","info":{"id":"ctBBDG","date":"1694419597","viewed":34,"name":"Sierpinski w/ binomial theorem","username":"DanielKh","description":"It generates the Sierpinski triangle on a pixel by pixel basis with the binomial theorem.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fractal","triangle","sierpinki","sierpinskitirangle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"int twosinfactorial(float x) {\n    int twocount=0;\n    for (float k = 0.0; k < x;k++) {\n        float t=2.0;\n        while (t!=0.0) {\n            twocount=twocount+1;\n            if ((mod(2.0*(k+1.0),(pow(2.0,t))))==0.0) {\n                t=t+1.0;\n            } else {\n                t=0.0;\n            }\n        }\n    }\n    return twocount;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int twosum =1;\n    vec3 col;\n    float screenconstant = (iResolution.x-iResolution.y)/2.0;\n    float newx = fragCoord.x-screenconstant-0.5*fragCoord.y; //the coefficient for fragCoord.y should be 0.5 for straight, 0.0 for crooked\n    float newy = iResolution.y-fragCoord.y;\n    \n    \n    twosum=twosinfactorial(newy)-twosinfactorial(newx)-twosinfactorial(newy-newx);\n\n    if (twosum<0) { //less than for straight, equal to for crooked\n        col = vec3 (0.0,0.0,0.0);\n    } else {\n        col = vec3 (1.0,1.0,1.0);\n    }\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}