{"ver":"0.1","info":{"id":"tt2GWV","date":"1561228469","viewed":139,"name":"Ray Tracing in a Weekend, Ch. 5","username":"fhecht","description":"This is a tutorial style implementation of classic ray tracing following the \"Ray Tracing in One Weekend\" course by Peter Shirley. This is the code up to chapter 5.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// -------------------------------------------------------------------------\n// Struct definitions and scene setup\n// -------------------------------------------------------------------------\n\n// Camera parameters\nvec3 lower_left_corner = vec3(-1.0, -1.0, -1.0);\nvec3 horizontal = vec3(2, 0, 0);\nvec3 vertical = vec3(0, 2, 0);\nvec3 origin = vec3(0, 0, 0);\n\n// Ray struct\nstruct Ray {\n    vec3 o;\n    vec3 d;\n    float mint;\n    float maxt;\n};\n\n// Scene\nstruct Sphere {\n    vec3 c;\n    float r;\n};\nSphere sphere = Sphere(vec3(0.0, 0.0, -1.0), 0.5);\n\nconst int NUM_SPHERES = 2;\nconst Sphere spheres[NUM_SPHERES] = Sphere[NUM_SPHERES](\n    Sphere(vec3(0.0, 0.0, -1.0), 0.5),\n    Sphere(vec3(0.0, -100.5, -1.0), 100.)\n);\n\n// Hit record information\nstruct HitRecord {\n    float t;\n    vec3 P;\n    vec3 N;\n};\n\n// -------------------------------------------------------------------------\n// Intersection code\n// -------------------------------------------------------------------------\n\n// intersect a ray with a single sphere\n// returns true if there was a valid intersection, which includes checks\n// against the mint and maxt range of the ray. In case of a valid\n// intersection the information in the HitRecord is filled in\nbool hitSphere(Ray r, Sphere s, out HitRecord hit)\n{\n    vec3 oc = r.o - s.c;\n    float a = dot(r.d, r.d);\n    float b = 2.0 * dot(oc, r.d);\n    float c = dot(oc, oc) - s.r * s.r;\n    float det = b*b - 4.0*a*c;\n    if (det < 0.0) {\n        return false;\n    }\n    \n    // first possible intersection\n    float t = (-b - sqrt(det)) / (2.0 * a);\n    if (r.mint <= t && t < r.maxt) { \n        hit.t = t;\n        hit.P = r.o + t * r.d;\n        hit.N = normalize(hit.P - s.c);\n        return true;\n    }\n\n    // second possible intersection\n    t = (-b + sqrt(det)) / (2.0 * a);\n    if (r.mint <= t && t < r.maxt) { \n        hit.t = t;\n        hit.P = r.o + t * r.d;\n        hit.N = normalize(hit.P - s.c);\n        return true;\n    }\n\n    return false;\n}\n\n// intersect against all spheres and return the first hit\nbool hitSpheres(Ray r, Sphere spheres[NUM_SPHERES], out HitRecord hit)\n{\n    bool hitSomething = false;\n    for (int i = 0; i < spheres.length(); ++i) {\n        if (hitSphere(r, spheres[i], hit)) {\n            hitSomething = true;\n            // if we hit a sphere we update maxt on the ray to only find\n            // intersections that are even closer\n            r.maxt = hit.t;\n        }\n    }\n    \n    return hitSomething;\n}\n\n// -------------------------------------------------------------------------\n// Core integrator\n// -------------------------------------------------------------------------\n\nvec3 missedColor(vec3 rayDir)\n{\n    vec3 unitDir = normalize(rayDir);\n    float t = 0.5 * (unitDir.y + 1.0);\n    return mix(vec3(1.0,1.0,1.0), vec3(.5, .7, 1.0), t);\n}\n\nvec3 traceRay(Ray r)\n{\n    HitRecord hit;\n    //if (hitSphere(r, sphere, hit)) {\n    if (hitSpheres(r, spheres, hit)) {\n        return 0.5 * (hit.N + 1.0);\n    }\n    return missedColor(r.d);\n}\n\n// -------------------------------------------------------------------------\n// Camera code\n// -------------------------------------------------------------------------\n\nRay computeCameraRay(vec2 uv)\n{\n    float aspectRatio = iResolution.x / iResolution.y;\n    Ray r;\n    r.o = origin;\n    r.d = lower_left_corner * vec3(aspectRatio, 1.0, 1.0) +\n          uv.x * horizontal * aspectRatio +\n          uv.y * vertical;\n    r.mint = 0.0;\n    r.maxt = 1e20;\n    return r;\n}\n\n// -------------------------------------------------------------------------\n// Main image computation\n// -------------------------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // Compute ray for pixel\n    Ray r = computeCameraRay(uv);\n    \n    // Compute pixel color\n    vec3 col = traceRay(r);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}