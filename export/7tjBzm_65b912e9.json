{"ver":"0.1","info":{"id":"7tjBzm","date":"1652044210","viewed":141,"name":"D12 Madness","username":"pb","description":"look inside a dodecahedral ifs to find cool stuff","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["fractal","ifs","dodecahedron"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//philip.bertani@gmail.com\n//trying some cheap antialiasing here\n//by averaging pixels instead of casting more rays\n//seems to work ok in this case\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\n    //size of one texel in iChannel0\n    vec2 texel = 1./iResolution.xy;\n\n    vec4 total_color;\n    //see 5x5 gaussian weights in Common \n    for (int i=0;i<5;i++){\n        float fi = float(i)-2.;\n        for (int j=0;j<5;j++){ \n            float fj = float(j)-2.;\n            vec4 color = texture(iChannel0, \n                uv + vec2( texel.x*fi,texel.y*fj )  );\n            total_color += color * gkhs[i*5 + j];\n        }\n    }\n    \n    fragColor = total_color;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//gaussian_kernel_one_stdev\nfloat[] gk1s = float[] (\n        0.003765,0.015019,0.023792,0.015019,0.003765,\n        0.015019,0.059912,0.094907,0.059912,0.015019,\n        0.023792,0.094907,0.150342,0.094907,0.023792,\n        0.015019,0.059912,0.094907,0.059912,0.015019,\n        0.003765,0.015019,0.023792,0.015019,0.003765 );\n        \n        \n//gaussian_kernel_half_stdev\nfloat[] gkhs = float[] (\n        0.000002,0.000212,0.000922,0.000212,0.000002,\n        0.000212,0.024745,0.107391,0.024745,0.000212,\n        0.000922,0.107391,0.466066,0.107391,0.000922,\n        0.000212,0.024745,0.107391,0.024745,0.000212,\n        0.000002,0.000212,0.000922,0.000212,0.000002 );\n        \n        \nfloat[] params = \n            float[](-.6,-.49,0.,0.,0.,0.,2.,0.,4.,2.\n                   ,17.,0.,0.,.4,-2.,0.,-0.8,0.,0.,0.\n                   ,0.,0.,0.,2.,60.,0.,0.,.1,0.,0.\n                   ,0.,0.,0.4,1.1,.04,-0.5,0.,0.,0.,0.\n                   ,0.,0.,0.,0.,1.,0.,0.,0.,1.);\n\n\n//hard coding the vertices for a dodecahedron\nconst float gmh=(sqrt(5.)+1.)/2.;\nconst float gmi=1./gmh;\n\nvec3[] d12 = vec3[]  (\nvec3(1.,1.,1.),\nvec3(1.,1.,-1.),\nvec3(1.,-1,1.),\nvec3(1.,-1,-1.),\nvec3(-1,1.,1.),\nvec3(-1.,1.,-1),\nvec3(-1.,-1.,1.),\nvec3(-1.,-1.,-1.),\nvec3(0.,gmh,gmi),\nvec3(0.,gmh,-gmi),\nvec3(0.,-gmh,gmi),\nvec3(0.,-gmh,-gmi),\nvec3(gmi,0.,gmh),\nvec3(gmi,0.,-gmh),\nvec3(-gmi,0.,gmh),\nvec3(-gmi,0.,-gmh),\nvec3(gmh,gmi,0.),\nvec3(gmh,-gmi,0.),\nvec3(-gmh,gmi,0.),\nvec3(-gmh,-gmi,0.)\n);\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//lots of credit to Kali for: hit tolerance as function of distance, glow logic\n//shadows, ao\n\nconst   float     one_third = 1./3.;\nconst   float     PI = 3.14159;\n\nconst   int       RAY_STEPS = 200;\nconst   int       SHADOW_STEPS = 50;\n\nvec3    lightpos,lightpos2,moon_pos;\nvec3    ambdir=normalize(vec3(0.,0.,1.));\nconst   vec3 origin=vec3(0.,0.,0.);\n\nfloat   det    = 0.0;  //tolerance for hitting an object increases with distance\nfloat   detail = .00010; // * (1.+params[0]);\n\n//corners of tetrahedron for distance to sierpinksi 3d\nvec3    s1 = vec3(1.,1.,1.);\nvec3    s2 = vec3(-1.,-1.,1.);\nvec3    s3 = vec3(1.,-1.,-1.);\nvec3    s4 = vec3(-1.,1.,-1.);\nfloat   ifs_scale = 1.666;\n\nvec3    center_of_hollow_sphere;\nvec3    ifs_color;\nfloat   norm_dist;\nfloat   max_dist = 100000.;\nfloat   max_march = 500.;\nfloat   max_shadow_dist = 4000.;\n\nfloat   floor = -.5;\nvec3    floor_vec=normalize(vec3(0.5,-0.3,-1.));\n\nfloat   night_start=PI+.5,night_end=2.*PI-.5;\nfloat   thetaL, phiL; //light altitude, azimuth\nfloat   sun_rnd;\nfloat   angle_time;\nfloat   myTime;\nfloat   night;\nfloat   glow_horizon_mult;\nfloat   global_ldiff;\nvec3    global_lightdir;\nvec3    global_light;\nfloat   global_totdist;\nfloat   global_floor_variation;\nfloat   global_lum;\nvec3    ro;\nfloat   rnd_ref1, rnd_ref2;\n\nfloat   pi = PI;\nfloat   pi_over_2 = 1.57079632;\nfloat   two_pi = 6.28318530;\nfloat   too_small = 1.e-6;\n\nconst   vec3    center_of_earth = vec3(0.,-1000.,0.);\nfloat   radius_of_earth;\nfloat   sky_angle, adjust_sky_angle;\n\nfloat just_a_sphere( vec3 p, float r ) {\n     return length(p) - r;\n}\n\n//the random function everyone uses\nfloat rand( vec2 co ) {\n    return fract( sin( dot( co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n    \nmat3 rot_xz( float an ) {\n    float can = cos(an);\n    float san = sin(an);\n\n    return mat3( can, 0., -san,\n                 0. , 1.,   0.,\n                 san, 0.,  can );\n\n}    \n\nmat3 rot_yz( float an ) {\n    float can = cos(an);\n    float san = sin(an);\n\n    return mat3( 1., 0., 0.,\n                 0., can, -san,\n                 0., san,  can );\n\n}  \n\nfloat atanyx(float y, float x) {\n\n        float sign_y = 1.0;\n        if (y < 0.0) sign_y = -1.0;\n        \n        if (abs(x) < too_small) return sign_y * pi_over_2;\n\n        float atanyx = atan(y/x);\n\n        //we need to add multiple of pi depending on the quadrant\n        if (x>0.0 && y>=0.0) {\n            return atanyx;\n        }\n        else if (x<0.0) {\n            return pi + atanyx;\n        }\n        else {\n            return two_pi + atanyx;\n        } \n\n}\n\nfloat earth_dist( vec3 p ) {\n    return length(p-center_of_earth ) - radius_of_earth ;\n}\n\n\nvec2 de_d12(vec3 z) {\n    \n    vec3 min_vtx;\n    vec3 orig_z = z;\n    int n=0;\n    float min_dist,dist_to_vtx;\n\n    vec3 floor_z;\n    int floor_iter = 5+int(params[21]);\n\n    if ( params[41] != 0. ) {\n       z.xz = sin( z.xz / params[41] );         //repeat using sin instead of mod, more interesting\n       //z.y += global_totdist/(10.+params[40]) + 3.*sin(global_totdist/3.);  //reduce height as we get farther away\n    }\n\n    if ( params[42] != 0. ) {\n        z.xz = mod( z.xz - 5., 10. ) - 5.;\n        //z.y += 3.*sin(global_totdist/10.) + global_totdist/(10.+params[40]);\n    }\n\n    //we can make a ring around the equator by adjusting height\n    z.y += params[35]; // + sin(iTime/2.);\n    \n    ifs_color = vec3(0.);\n\n    for (int i=0; i<100; i++) {\n       \n        if ( float(i) > params[10] ) break;\n\n        min_vtx = d12[0];\n        min_dist=length(z-d12[0]);\n        for (int j=1; j<20; j++) {\n        \n            dist_to_vtx=length(z-d12[j]); \n            if (dist_to_vtx<min_dist) {min_vtx=d12[j]; min_dist=dist_to_vtx;}\n            \n        }\n        \n        z = min_vtx + ifs_scale*(z-min_vtx);\n        \n        n++;\n\n        if ( z.x * z.y > 0. ) ifs_color.x ++;\n        if ( z.y * z.z > 0. ) ifs_color.y ++;\n        if ( z.z * z.x > 0. ) ifs_color.z ++;\n\n        if ( i == floor_iter) floor_z = z;\n\n    }\n\n    if ( n < floor_iter ) floor_z = z;\n\n    ifs_color /= float(n);\n\n    float dz = pow(ifs_scale, float(n) );\n    //dz is simply the constant Scale factor to the power of number of times used\n\n    float scene_dist = length(z) / dz;  \n    float objid = 0.;\n\n    //float floor_dist = orig_z.y + 1.;//earth_dist(orig_z);\n    float floor_dist = earth_dist(orig_z);\n\n    if ( floor_dist < scene_dist ) {\n        scene_dist = floor_dist;\n\n        global_floor_variation = (1.+params[20]) * length(cross(floor_z,floor_vec))/100.;\n        scene_dist -= clamp(  global_floor_variation,-.2,.2);\n\n        objid = 100. ;\n    }\n\n    return vec2( scene_dist, objid );\n}\n\nvec2 de(vec3 p) {\n   \n    //the negative sign on the sphere gets us on the inside of a hollow sphere\n    return max( de_d12(p), -just_a_sphere(p-center_of_hollow_sphere, params[13]) );\n}\n\n\n//tetrahedral gradient (normal vector)\nvec3 normal(vec3 p, float normal_expand) {\n\n    float normal_dist_expand = params[22] * norm_dist*norm_dist*norm_dist;\n    vec2 dpn = vec2(1.,-1.);\n    vec2 dp  = (.001 + normal_expand + normal_dist_expand) * dpn; \n\n    vec3 df = dpn.xxx * de(p+dp.xxx).x +\n              dpn.yyx * de(p+dp.yyx).x +\n              dpn.xyy * de(p+dp.xyy).x +\n              dpn.yxy * de(p+dp.yxy).x ;\n\n    return normalize(df); \n\n}\n\n\nfloat shadow(vec3 pos, vec3 sdir) {\n\n    float sh=1.0;\n    float totdist = 2.0*det;\n    float dist=10.;\n        \n    for (int steps=0; steps<SHADOW_STEPS; steps++) {\n            \n        //this picks up the detail from raymarch which is a function of distance\n        if (totdist<max_shadow_dist && dist>detail) {\n                vec3 p = pos - totdist * sdir;  //sdir is lightdir and we march in the opposite direction\n                dist = de(p).x;\n                sh = min( sh, max(50.*dist/totdist,0.0) );\n                totdist += max(.01,dist);    \n        }\n        \n    }\n    \n         \n    return clamp(sh,0.1*(params[27]),1.0);\n}\n\n\nfloat calcAO( const vec3 pos, const vec3 nor ) {\n\n      float aodet=detail*40.;\n      float totao = 0.0;\n      float sca = 14.0;\n      for( int aoi=0; aoi<40; aoi++ ) {\n        if ( float(aoi) > params[2]) break;\n        float hr = aodet*float(aoi*aoi);        \n        vec3 aopos =  pos + nor * hr;\n        float dd = de( aopos ).x;\n        totao += -(dd-hr)*sca;\n        sca *= 0.7;\n      }\n\n      return clamp( 1.0 - 3.0*totao, 0., 1.0 );\n}\n\n\n\nvec3 light(in vec3 p, in vec3 dir, in vec3 vn, in float hid) {\n\n      vec3 lightdir;\n\n      if ( night == 1. ) {\n          lightdir = normalize( moon_pos - p );\n      }\n      else {\n          lightdir = normalize( lightpos - p );\n      }\n\n      global_lightdir = lightdir;\n\n      float sh = 1.;\n    \n      //if ( night == 0.)\n          if ( params[27] > 0. ) sh = shadow(p, lightdir) ;\n    \n      float ao=calcAO(p,vn);\n\n      vec3 col = vec3(.06,.08,.14);\n\n      if ( hid == 100. )  //this gives a lower depth a browner color and higher green\n          col = .8*vec3( .3+.3*rand(p.xy), .1+.3*rand(p.yz) +clamp(global_floor_variation,-.1,.4), 0.);\n\n      vec3 refl = reflect(-dir,vn);\n      float diffuse  = max( dot(lightdir,-vn), 0. );\n\n      float reflect_power = max( dot(lightdir,refl), 0. );\n      float specular = pow( reflect_power, 2. + params[6]); \n      float specular2 = pow ( reflect_power, 2. );\n\n      float amb = max(.5,dot(dir,-vn)); \n\n      float total_light = global_lum*3.;\n      //if (night == 1. ) total_light = 1.; \n\n      total_light *= (1. + .10*sun_rnd);  //add some random fluctuation to total light level\n\n      //amb and specular are just pure variations in brightness right now, no color changes\n      if ( hid == 100. ) {\n\n          float night_mult = 1.;\n          if  (night == 1. ) night_mult = .2;\n      \n          {\n              float lum = diffuse + .25*amb + .6*specular2;\n              col *= lum*night_mult;\n          }\n      }\n      \n      else {\n\n          float night_mult = 1.;\n          if ( night == 1. ) night_mult = 0.5;\n\n          col *=   (1.+params[8]) * (diffuse + .25*amb) * night_mult;\n\n          col +=   (1.+params[9]) * (specular + night/4.);\n\n          if ( night == 0. ) col += global_light * specular;\n\n          col *=   total_light;\n\n      }                    \n        \n      //we need some extra contrast but not for shadows on the ground\n      if ( hid !=100.) col = .5 +  1.1*(col-.5);\n        \n      return min(sh,ao)*col;\n\n}\n\nfloat check_if_night_time() {\n\n    if ( angle_time > night_start && angle_time < night_end ) {\n\n        float extra = adjust_sky_angle  + 1.;  //PI/2.;\n        float expand = -(PI+2.*extra) / (night_end-night_start);\n        float nthetaL = angle_time - night_start;\n        nthetaL *= expand;\n        nthetaL += extra;\n\n        float nphiL   = phiL + 10./180.*PI;  //moon is 5 degrees from sun (ecliptic) but let's make it more dramatic\n        moon_pos = max_dist * vec3( sin(nthetaL)*sin(nphiL), sin(nthetaL)*cos(nphiL), cos(nthetaL) ) ; \n\n        return 1.;\n    }\n    else {\n        return 0.;\n    }\n}\n\nvec3 sky_color( vec3 dir, vec3 lightpos, vec3 p ) {\n  \n    vec3 skypos  = dir*max_dist - center_of_earth;\n    vec3 sky;\n\n    night = check_if_night_time();\n  \n    float moondiff = length( -moon_pos - skypos ); \n    float moon_outline = 1e10;\n\n    if ( moondiff < 8000. )     \n        moon_outline = moondiff*moondiff;\n\n    moondiff *= moondiff;\n \n\n    float ldiff = length( -lightpos - skypos ); \n    float sun_outline = 1e10;\n\n    if (ldiff < 9000. )\n        sun_outline = ldiff*ldiff;\n\n    ldiff *= ldiff;\n\n    float blue_subtract = 0.;\n\n    float adj = adjust_sky_angle;\n    //we are not accounting for the height of the atmosphere so it is a little wonky\n\n    float yellow_start = pi + pi - .01 - adj;  //.01;     \n    float yellow_end   = two_pi + .7  - adj;     \n\n    float yellow_start2 = pi - .7 + adj;  \n    float yellow_end2   = two_pi - pi + .01 + adj; //.01;\n\n    float t1 =angle_time;\n    if ( angle_time < pi && yellow_start > pi) t1 += two_pi;\n\n    if ( t1 > yellow_start && t1 < yellow_end ) {\n        blue_subtract = -(1.-smoothstep(two_pi-adj, yellow_end, t1));\n    }\n    else if ( t1 <= yellow_start && t1 > yellow_start-1. ) {\n        blue_subtract = -smoothstep( yellow_start-1., yellow_start, t1 );\n    }\n    \n\n    float t2 = angle_time;\n    if ( t2 > yellow_start2 && t2 < yellow_end2 ) {\n        blue_subtract = -smoothstep(yellow_start2, pi+adj, t2);\n    }\n    else if ( t2 >= yellow_end2 && t2 < yellow_end2 +.8) {\n        blue_subtract = -(1.-smoothstep(yellow_end2,  yellow_end2+.8, t2 ) );\n    }\n \n    //need to adjust blue_subtract so the horizon opposite the sunset is not colored\n\n    float sun_lum  = exp( -ldiff/1e10 );\n    float sun_lum2 = exp( -ldiff/5e8);\n    float sun_lum3 = exp( -sun_outline/1e8  );\n    \n    float moon_lum = exp( -moondiff/4e9 );\n    float moon_lum2 = exp( -moon_outline/1e8 );\n\n    float skypos_theta = acos( skypos.y / length(skypos) );\n    skypos_theta /= 2.;\n    float s2 = pow((1.+skypos_theta),.4);\n    skypos_theta *= skypos_theta; \n\n    sky += vec3(skypos_theta, skypos_theta, s2 + 2.*blue_subtract*skypos_theta*skypos_theta );   //horizon luminance \n\n    global_lum = max( min((1.+.85*sin(angle_time)),1.3), 0.);\n\n    sky *= global_lum;\n\n    global_light = vec3( sun_lum2, sun_lum2, sun_lum2 + blue_subtract);\n\n\n    sky = (1.-sun_lum)*sky +  .76*vec3( sun_lum, sun_lum , 1.3*(1.+blue_subtract/2.)*sun_lum  ) \n                           +  .30*global_light \n                           +  max(.08*(-blue_subtract),.01)*vec3(sun_lum3);  //the outline of the sun becomes sharper as it descends into sunset\n   \n    sky = (1.-moon_lum)*sky + .6*vec3( moon_lum2 ) + .4*vec3(moon_lum, moon_lum, 2.3*moon_lum);\n\n    global_light = .5 + .7*(global_light - .5);\n\n    return  sky;\n\n}\n\n\nvec4 raymarch(in vec3 from, in vec3 dir) \n{\n\n    float totdist=0.;\n    vec2  d = vec2(1.,0.);\n    vec3  p, col=vec3(0.);\n    float glow = 0.;\n    norm_dist = 0.;\n    float alpha = 0.;\n    float glow_threshold = .01*(1.+params[44]);\n\n    for (int i=0; i<RAY_STEPS; i++) {\n\n        if (d.x>det && totdist<max_march) {\n\n            global_totdist = totdist;\n\n            p = from + totdist*dir;\n            d = de(p);\n\n            //prevent some aliasing effects by adding some noise to the fading with distance\n\n            //this works well when we are close but washes out detail too quickly as we \n            //move farther out\n            det = detail*(1.+totdist*40.*(1.+params[23]))\n                              *(1. + rand( mod(p.xy-1.,2.)-1. )/ (6.+params[24]) );\n\n            totdist+=d.x; \n\n           \n            if (d.x<glow_threshold) glow += max(0.,glow_threshold-d.x)*exp(-totdist);\n\n        }\n        else { break; }\n\n    }\n\n    //the \"sky\" is always max_dist away\n    vec3 backg = sky_color( dir, lightpos, p );\n\n    if (d.x<=det) {\n\n            alpha = 1.;\n  \n            float normal_expand;\n            float color_mult;\n            if ( d.y == 0. )  { \n                col *= exp(-2.*totdist*totdist);\n                color_mult = params[7];\n                normal_expand = params[12];\n             \n            }      \n            else {\n                col *= exp(-totdist/20.);\n                color_mult = params[29];\n                normal_expand = params[31];\n            }     \n\n            norm_dist = totdist;\n\n            vec3 adjusted_p = p - abs(d.x-det)*dir;                \n            vec3 norm=normal( adjusted_p, normal_expand );\n\n            col = light( adjusted_p, dir, norm, d.y ); \n\n            float a2 = angle_time;\n            if (angle_time > PI) a2 = -(2.*PI - angle_time);\n\n            {\n\n                if ( params[39] != 0. && d.y == 0. )\n                \n                {\n\n\n                  if ( params[45] == 0. ) {\n                    vec3 glow_source = s1;  //glow coming from s1 vertex of tetrahedron - for now\n\n                    float glow_source_dist = length(p-glow_source);\n                    vec3 local_glowdir = normalize(p-glow_source);\n\n                    float gtheta = acos( local_glowdir.z/glow_source_dist );\n                    gtheta *= gtheta;\n \n                    float glow_lum = exp( -glow_source_dist/1.e6 );\n\n                    //this kind of glow is only effective if we are in the middle \n                    //of a bunch of objects\n\n                    vec3 backg   = vec3(  1.+glow_lum, glow_lum, glow_lum + gtheta);\n\n                    //float lfac=pow(max(0.,dot(normalize(-dir.xz),normalize(global_lightdir.xz))),2.);\n\n                    col += glow * ( backg )* params[39];\n\n                    col -= .3*backg * max(0.,dot(dir,-norm)) * exp(-totdist/1e2); //subtracting some ambient makes the detail pop out!\n\n             \n                  }\n                  else {\n\n\n                    float lfac = max(0.0, dot( -dir, global_lightdir ) );          \n                    col += glow * (.5+.8*(global_light-.5)) * (8.+params[39]);\n                    \n                    //vec3 lglow = pow(lfac,2.+params[30]) * vec3(1.);\n                    //col += lglow*min(1.,totdist*totdist*.3)*(1.+params[45]);\n\n                    \n                  }\n\n                }\n\n            }\n\n            //this is not the best place to add color from ifs iteration\n            col += color_mult*vec3(cos(params[17])*ifs_color.x,\n                                   cos(params[18])*ifs_color.y,\n                                   cos(params[19])*ifs_color.z);\n\n            \n    } else { \n\n            col=backg;\n\n    }\n\n    return vec4(col, 1.) ; //alpha); \n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    mat3 rot;\n    vec3 movement;\n    \n    myTime = mod(iTime , 120.) ; \n    \n    rot = rot_xz( 0. );  //myTime/3.);\n    \n    movement = vec3( 0., .5, .65);\n    if (myTime > 35. )  {\n        myTime -=35.;\n        movement = vec3(0.,.5,min(4.65,.65+myTime/10.)  );\n        params[8] = max( params[8] - myTime/2., -4. );\n        params[1] = max( params[1] - myTime/30., -.6 );\n        \n        params[48] = 0.;\n        if ( myTime > 40. ) {\n            myTime -= 40.;\n            params[0] = min( params[0] + myTime/3., -.1 );\n            params[1] = min( params[1] + myTime/7., 2.6 );\n            movement = vec3( 0., .5, max(.65, 4.65 - myTime/8. ) ); \n            \n            if ( myTime > 35. ) {\n                myTime -= 35.;\n                params[0] =  max( -.6, .1 - myTime/3. );\n                params[1] = max( -.49, 3.- myTime );\n                params[48]  = 1.;\n            }\n\n        }\n        \n\n    }\n\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n   \n    ro = vec3( movement[0] , movement[1]  , movement[2] );\n        \n    float  focal_point = params[14];\n\n    vec3   rd =  rot * normalize(vec3(uv,focal_point));\n\n    //camera_direction is simply the \"z\" axis of rot (the rotation matrix)\n\n    vec3 dir = rot[2];\n\n    angle_time = mod(iTime/5., 2.*PI);\n    //angle_time = mod(params[36], 2.*PI);\n\n    //angle_time -= ro.z/50.;  //sun gets higher as we move \"east\" which is 0,0,-1 direction\n\n    thetaL    = -angle_time;\n\n    phiL      = params[4];\n    lightpos  = max_dist * vec3( sin(thetaL)*sin(phiL), sin(thetaL)*cos(phiL), cos(thetaL) )  + center_of_earth;       \n    sun_rnd   = cos(iTime+rand(lightpos.xy));  //to add some shimmering to sun\n\n    center_of_hollow_sphere = ro;\n\n    floor += params[28];\n   \n    adjust_sky_angle = 0.;\n    if ( ro.y < 0. )  \n        adjust_sky_angle = -ro.y/5.;  //kluged using simply the linear height   \n\n    night_start += adjust_sky_angle;\n    night_end   -= adjust_sky_angle;\n    \n    detail *= (1.+params[0]);\n    ifs_scale += params[1];\n    floor_vec += vec3(params[32],params[33],params[34]);        \n    radius_of_earth = length( center_of_earth ) - 1.;\n    \n    vec4 color=raymarch(ro,rd);\n \n    color.xyz=clamp(color.xyz,0.,1.);\n    \n    if ( params[48] == 1.  ) color.xyz = .9*pow(color.xyz, vec3(.4) );\n    \n    fragColor = color;\n}\n        ","name":"Buffer A","description":"","type":"buffer"}]}