{"ver":"0.1","info":{"id":"4tKfWG","date":"1543874984","viewed":115,"name":"Stairs with Ball","username":"SolidTux","description":"Stairs with hopping ball","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","stairs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n#define TIME mod(iTime, float(10))\n\nprecision highp float;\n\nconst float MIN_DEPTH = float(1);\nconst float MAX_DEPTH = float(100);\nconst int MAX_ITER = 100;\nconst float EPS = float(0.001);\nconst float SHADOW = float(0);\nconst float SHADOW_EPS = float(0.1);\nconst float SHADOW_DEPTH = float(3);\nconst float SHADOW_SMOOTH = float(15);\nconst float PI = 3.14159265359;\nconst float KEYFRAME_0 = float(0);\nconst float KEYFRAME_1 = float(5);\nconst float KEYFRAME_2 = float(10);\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\nstruct RayResult {\n    float depth;\n    int object;\n    vec3 norm;\n};\nstruct SdfResult {\n    float distance;\n    vec3 pos;\n    vec2 uv;\n    int object;\n};\nstruct Camera {\n    vec3 position;\n    vec3 target;\n    vec3 up;\n    float zoom;\n};\nfloat rand(float n){\n    return fract(sin(n) * 43758.5453123);\n}\nvec2 norm_coord(in vec2 coord, in vec2 res) {\n    vec2 uv = coord.xy/res.xy;\n    uv = 2.*uv - 1.;\n    if (res.x > res.y) {\n        uv.x *= res.x/res.y;\n    } else {\n        uv.y *= res.y/res.x;\n    }\n    return uv;\n}\nvec3 ray_direction(in Camera cam, in vec2 coord, in vec2 res) {\n    vec2 uv = norm_coord(coord, res);\n    vec3 dir = normalize(cam.target - cam.position);\n    vec3 right = normalize(cross(dir, cam.up));\n    vec3 u = normalize(cross(right, dir));\n    vec3 target = cam.position + normalize(dir)/cam.zoom + uv.x*right + uv.y*u;\n    return normalize(target - cam.position);\n}\nRay get_ray(in Camera cam, in vec2 coord, in vec2 res) {\n    return Ray(cam.position, ray_direction(cam, coord, res));\n}\nvec2 sphere_map(in vec3 pos) {\n    // TODO\n    return vec2(0.);\n}\nfloat box(vec3 p, vec3 b) {\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\nSdfResult sdf_union(in SdfResult a, in SdfResult b) {\n    if (a.distance < b.distance) {\n        return a;\n    } else {\n        return b;\n    }\n}\nmat3 rotx(in float a) {\n    return mat3(\n            1., 0., 0.,\n            0., cos(a), -sin(a),\n            0., sin(a), cos(a)\n            );\n}\nmat3 roty(in float a) {\n    return mat3(\n            cos(a), 0., -sin(a),\n            0., 1., 0.,\n            sin(a), 0., cos(a)\n            );\n}\nmat3 rotz(in float a) {\n    return mat3(\n            cos(a), -sin(a), 0.,\n            sin(a), cos(a), 0.,\n            0., 0., 1.\n            );\n}\nSdfResult sdf(in vec3 pos) {\n    SdfResult res = SdfResult(MAX_DEPTH, vec3(0.), vec2(0.), -1);\n    vec3 p = pos;\n    \n    if (p.y < 5.5) {\n    p.xy += mod(TIME, 1.)*vec2(2., 1.);\n    p.xy = vec2(p.x - 2.*floor(p.y), mod(p.y, 1.));\n    res = SdfResult(box(p, vec3(float(2), float(1), float(4))), p, vec2(0., 0.), 0);\n    p += vec3(float(2), float(1), float(0));\n    res = sdf_union(res, SdfResult(box(p, vec3(float(2), float(1), float(4))), p, vec2(0., 0.), 0));\n    p += vec3(float(-4), float(-2), float(0));\n    res = sdf_union(res, SdfResult(box(p, vec3(float(2), float(1), float(4))), p, vec2(0., 0.), 0));\n    }\n    ;\n    p = pos;\n    p += vec3(float(0), float(3), float(0));\n    res = sdf_union(res, SdfResult(p.y, p, vec2(0., 0.), 0));\n    ;\n    p = pos;\n    p += vec3(float(-108), float(-5.5), float(0));\n    res = sdf_union(res, SdfResult(box(p, vec3(float(100), float(1), float(400))), p, vec2(0., 0.), 0));\n    ;\n    p = pos;\n    p += vec3(float(1.75), float(-1.5), float(0));\n    p += vec3(0., -8.*(mod(TIME, 1.) - mod(TIME, 1.)*mod(TIME, 1.)), 0.);\n    res = sdf_union(res, SdfResult(length(p) - float(0.5), p, vec2(0., 0.), 1));\n    return res;\n}\nvec3 norm(in vec3 p) {\n    return normalize(vec3(\n        sdf(vec3(p.x + EPS, p.y, p.z)).distance - sdf(vec3(p.x - EPS, p.y, p.z)).distance,\n        sdf(vec3(p.x, p.y + EPS, p.z)).distance - sdf(vec3(p.x, p.y - EPS, p.z)).distance,\n        sdf(vec3(p.x, p.y, p.z + EPS)).distance - sdf(vec3(p.x, p.y, p.z - EPS)).distance\n    ));\n}\nRayResult raymarcher(in Ray ray) {\n    float depth = MIN_DEPTH;\n    for (int i=0; i<MAX_ITER; i++) {\n        vec3 pos = ray.origin + depth*ray.direction;\n        SdfResult res = sdf(pos);\n        if (res.distance < EPS) {\n            return RayResult(depth, res.object, norm(pos));\n        }\n        depth += min(float(1), res.distance);\n        if (depth > MAX_DEPTH) {\n            return RayResult(MAX_DEPTH, -1, vec3(0.));\n        }\n    }\n    return RayResult(MAX_DEPTH, -1, vec3(0.));\n}\nfloat lightmarch(in Ray ray, in float maxd, in float k) {\n    float depth = 0.;\n    float r = 1.;\n    for (int i=0; i<MAX_ITER; i++) {\n        vec3 pos = ray.origin + depth*ray.direction;\n        SdfResult res = sdf(pos);\n        if (res.distance < SHADOW_EPS) {\n            return 0.;\n        }\n        r = min(r, k*res.distance/depth);\n        depth += res.distance;\n        if (depth >= (maxd - SHADOW_DEPTH)) {\n            return r;\n        }\n    }\n    return r;\n}\nvec4 color(in vec2 coord, in vec2 resolution) {\n    Camera cam = Camera(mix(mix(vec3(float(-15), float(30), float(10)), vec3(float(-10), float(30), float(10)), smoothstep(KEYFRAME_0, KEYFRAME_1, TIME)), vec3(float(-15), float(30), float(10)), smoothstep(KEYFRAME_1, KEYFRAME_2, TIME)), vec3(float(0), float(0), float(0)), vec3(float(0), float(1), float(0)), float(1));\n    Ray ray = get_ray(cam, coord, resolution);\n    RayResult res = raymarcher(ray);\n    vec3 pos = ray.origin + res.depth*ray.direction;\n    vec3 col;\n    if (res.object == 0) {\n        vec3 amb = vec3(float(1), float(1), float(0.8));\n        vec3 spec = vec3(0.);\n        vec3 diff = vec3(0.);\n        vec3 h;\n        vec3 l;\n        vec3 lpos;\n        vec3 ldir;\n        float bright = 1.;\n        lpos = vec3(15.*cos(0.2*PI*TIME), 4., 15.*sin(0.2*PI*TIME));\n        l = normalize(lpos - pos);\n        h = normalize(-ray.direction + l);\n        spec += vec3(float(1), float(1), float(1))*pow(dot(res.norm, h), float(4));\n        diff += amb * clamp(dot(l, res.norm), 0., 1.);\n        if (SHADOW > 0.) {\n            Ray light_ray = Ray(lpos, -l);\n            float s = SHADOW*lightmarch(light_ray, length(lpos - pos), SHADOW_SMOOTH) + 1. - SHADOW;\n            spec *= s;\n            diff *= s;\n        }\n        col = float(0.3)*amb + float(0.7)*diff + float(0)*spec;\n    }\n    \n    if (res.object == 1) {\n        vec3 amb = vec3(float(1), float(0), float(0));\n        vec3 spec = vec3(0.);\n        vec3 diff = vec3(0.);\n        vec3 h;\n        vec3 l;\n        vec3 lpos;\n        vec3 ldir;\n        float bright = 1.;\n        lpos = vec3(15.*cos(0.2*PI*TIME), 4., 15.*sin(0.2*PI*TIME));\n        l = normalize(lpos - pos);\n        h = normalize(-ray.direction + l);\n        spec += vec3(float(1), float(1), float(1))*pow(dot(res.norm, h), float(4));\n        diff += amb * clamp(dot(l, res.norm), 0., 1.);\n        if (SHADOW > 0.) {\n            Ray light_ray = Ray(lpos, -l);\n            float s = SHADOW*lightmarch(light_ray, length(lpos - pos), SHADOW_SMOOTH) + 1. - SHADOW;\n            spec *= s;\n            diff *= s;\n        }\n        col = float(0.3)*amb + float(0.7)*diff + float(0)*spec;\n    }\n    col -= float(1) * smoothstep(float(50), float(70), res.depth);\n    col = clamp(col, 0., 1.);\n    return vec4(col, 1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = color(fragCoord, iResolution.xy);\n}\n","name":"Image","description":"","type":"image"}]}