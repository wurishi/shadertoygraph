{"ver":"0.1","info":{"id":"DdVcWy","date":"1696606862","viewed":58,"name":"plane - azavier","username":"azavier","description":"i can't find a box sdf function that isnt buggy for my ray marcher. it must be an issue with my code. does anybody know why?","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"cdKczd","parentname":"tiles - azavier"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision mediump float;\nvec2 scene_info(in vec3 p) {\n vec2 ci = vec2(FAR, -1.0);\n \n // tiles\n vec3 boxp = p;\n vec2 boxid = floor(boxp.xz);\n float g_cd = length(boxid);\n boxp.xz = fract(boxp.xz);\n boxp.y += 0.25+0.125*sin(boxid.x*boxid.x - boxid.y - iTime) + 0.125*sin(g_cd - 2.0*iTime);\n vec3 q = abs(boxp) - vec3(0.95, 0.8, 0.95) + 0.1;\n float boxes = min(max(q.x, max(q.y,q.z)), 0.0) + length(max(q, 0.0)) - 0.1;\n \n // place in scene with material\n #define rectify(obj, matID) ci = mix(ci, vec2(obj, matID), step(obj, ci.x)) \n \n rectify(boxes*0.6, 0.0);\n return ci;\n}\n\nvec3 surface_normal(in vec3 p) {\n const vec2 h = vec2(HIT, 0.0);\n return normalize(vec3(scene_info(p+h.xyy).x - scene_info(p-h.xyy).x\n                      ,scene_info(p+h.yxy).x - scene_info(p-h.yxy).x\n                      ,scene_info(p+h.yyx).x - scene_info(p-h.yyx).x ));\n}\n\nvec2 march_scene(in vec3 ro, in vec3 rd) { // fancy innit\n vec2 mi = vec2(0.0);\n \n for(vec3 msi = vec3(scene_info(ro + rd*mi.x), 0.0); step(abs(msi.x), HIT)+step(FAR, mi.x)+step(TRACESTEPS, msi.z++) == 0.0; msi.xy = scene_info(ro + rd*mi.x))\n  mi = vec2(mi.x + msi.x, msi.y);\n  \n return mi;\n}\n\nvec3 parse_material(in float m, in vec3[2] data) {\n switch(int(m)) {\n  case 0:\n   vec2 id = floor(data[0].xz);\n   float g_cd = length(id);\n   return mix(vec3(0.33, 0.1, 0.1), vec3(0.05, 0.06, 0.02), 0.5+0.35*sin(g_cd-2.0*iTime)+0.15*sin(id.x*id.y+10.0*iTime));\n }\n}\n\nvoid lighting(inout vec3 col, in vec3 hitp, in vec3 hitn, in vec3 lightp) {\n // lighting calculations\n vec4 pointL = vec4(lightp, 32.0);\n vec3 to = pointL.xyz - hitp;\n col *= smoothstep(-1.0, 1.0, dot(normalize(to), hitn)); // diffuse\n col *= sqrt(pointL.w/length(to)); // squirt attenuation\n col = sqrt(col); // gamma correction\n}\n\nvec3 PixelColor(in vec2 uv) {\n vec3 ro = vec3(25.0, 5.0, 25.0);\n float t = iTime*0.33;\n ro.xz *= rot(t);\n vec3 focus = ro + vec3(0.0, -1.0, 0.0);\n focus.xz += vec2(sin(t), cos(t));\n vec3 rd = lookTo(uv, ro, focus);\n\n vec2 traceout = march_scene(ro, rd);\n vec3 hitp = ro+rd*traceout.x, hitn = surface_normal(hitp);\n float fcheck = step(traceout.x, FAR); // fcheck is 1.0 if we did not reach the far plane\n \n vec3 col = vec3(fcheck);\n col *= parse_material(traceout.y, vec3[](hitp, hitn));\n \n lighting(col, hitp, hitn, focus);\n \n vec3 bgc = vec3(0.2)*(0.65+0.35*rd.y); // far plane color\n return mix(col, bgc, smoothstep(0.0, FAR*FAR, traceout.x*traceout.x));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n vec2 uv = (fragCoord * 2.0 - iResolution.xy)/iResolution.y;\n vec3 col = vec3(0.0);\n \n#if AA > 1\n const float AA_INCREMENT = 1.0/float(AA);\n  \n for(vec2 AAO = vec2(-0.5); AAO.x < 0.5; AAO.x += AA_INCREMENT)\n  for(AAO.y = -0.5; AAO.y < 0.5; AAO.y += AA_INCREMENT)\n   col += PixelColor(uv + AAO/iResolution.y);\n  \n col /= float(AA*AA);\n#else\n col += PixelColor(uv);\n#endif\n \n fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define AA 2\n\n#define HIT 0.001\n#define FAR 35.0\n#define TRACESTEPS 250.0\n\nprecision mediump float;\n\n#define rot(th) mat2x2(cos(th), -sin(th), sin(th), cos(th))\n\nvec3 lookTo(in vec2 uv, in vec3 o, in vec3 f) {\n vec3 fwd = normalize(f-o);\n vec3 rgt = normalize(cross(fwd, vec3(0.0,1.0,0.0)));\n vec3 up = cross(rgt, fwd);\n \n return normalize(1.0*(uv.x*rgt + uv.y*up) + fwd);\n}","name":"Common","description":"","type":"common"}]}