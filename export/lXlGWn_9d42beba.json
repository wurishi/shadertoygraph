{"ver":"0.1","info":{"id":"lXlGWn","date":"1707364745","viewed":171,"name":"Depth Approximation","username":"Fuergu","description":"system is the same to 5.2, different scene","likes":4,"published":1,"flags":48,"usePreview":0,"tags":["3d","pathtracing","pathtracing","physics","dispersion","optic","render"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float calculateClearness(float depth, float center, float range) {\n    float lowerBound = center - range;\n    float upperBound = center + range;\n    float clearness = 0.;\n    if (depth<lowerBound)\n    clearness = smoothstep(1.,0., depth/lowerBound);\n    if (depth>upperBound)\n    clearness = smoothstep(0.,1., map(depth,upperBound,1.,0.,1.));\n    return clearness;\n}\nvec3 blur( int index, vec2 fragCoord )\n{\n    //https://xorshaders.weebly.com/tutorials/blur-shaders-5-part-2\n      vec2 uv = fragCoord/iResolution.xy;\n    // GAUSSIAN BLUR SETTINGS {{{\n    float Directions = 10.; // BLUR DIRECTIONS (Default 16.0 - More is better but slower)\n    float Quality = 4.0; // BLUR QUALITY (Default 4.0 - More is better but slower)\n    float Size = Blur; // BLUR SIZE (Radius)\n    // GAUSSIAN BLUR SETTINGS }}}\n    vec3 Color = vec3(0.);\n    if(index == 0)\n    Color = texture( iChannel0,uv).rgb;\n    if(index == 1)\n    Color = texture( iChannel1,uv).rgb;\n    \n    vec2 Radius = Size/iResolution.xy;\n   \n    \n    // Blur calculations\n    for( float d=0.0; d<c_twopi; d+=c_twopi/Directions)\n    {\n\t\tfor(float i=1.0/Quality; i<=1.0; i+=1.0/Quality)\n        {\n            if(index == 0)\n\t\t\tColor += texture( iChannel0, uv+vec2(cos(d),sin(d))*Radius*i).rgb;\t\t\n            if(index == 1)\n\t\t\tColor += texture( iChannel1, uv+vec2(cos(d),sin(d))*Radius*i).rgb;\t\t\n        \n        }\n    }\n    \n    // Output to screen\n    Color /= Quality * Directions - 15.0;\n    return Color;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 col = texture(iChannel0, uv).rgb;\n    \n    \n    vec3 meanColor  = blur(0,fragCoord);\n    \n    float depth = texture(iChannel1,uv).r;\n    float clearness = calculateClearness(depth,(clearDistance-minDistance)/(maxDistance-minDistance),DOF/(maxDistance-minDistance));\n    fragColor.rgb = col*(1.-clearness) + meanColor*clearness;\n    //fragColor.rgb =meanColor;\n    if (iMouse.z>0.)\n    fragColor = vec4(vec3(clearness), 1.0f);\n    //fragColor = vec4(col, 1.0f);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"struct SMaterialInfo\n{\n    vec3  albedo;\n    vec3  emissive;\n    float specular;\n    float specularRoughness;\n    vec3  specularColor;\n    float IOR;\n    float refraction;\n    float refractionRoughness;\n    vec3  refractionColor;\n};\n\nSMaterialInfo GetZeroedMaterial()\n{\n    SMaterialInfo ret;\n    ret.albedo = vec3(0.0, 0.0, 0.0);\n    ret.emissive = vec3(0.0, 0.0, 0.0);\n    ret.specular = 0.0;\n    ret.specularRoughness = 0.0;\n    ret.specularColor = vec3(0.0, 0.0, 0.0);\n    ret.IOR = 1.0;\n    ret.refraction = 0.0;\n    ret.refractionRoughness = 0.0;\n    ret.refractionColor = vec3(0.0, 0.0, 0.0);\n    return ret;\n}\n\nstruct SRayHitInfo\n{\n    bool fromInside;\n    float dist;\n    vec3 normal;\n    SMaterialInfo material;\n};\n\nfloat ScalarTriple(vec3 u, vec3 v, vec3 w)\n{\n    return dot(cross(u, v), w);\n}\n\n\nbool TestQuadTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec3 a, in vec3 b, in vec3 c, in vec3 d)\n{\n    vec3 normal = normalize(cross(c - a, c - b));\n    if (dot(normal, rayDir) > 0.0)\n    {\n        normal *= -1.0;\n\n        vec3 temp = d;\n        d = a;\n        a = temp;\n\n        temp = b;\n        b = c;\n        c = temp;\n    }\n\n    vec3 p = rayPos;\n    vec3 q = rayPos + rayDir;\n    vec3 pq = q - p;\n    vec3 pa = a - p;\n    vec3 pb = b - p;\n    vec3 pc = c - p;\n\n    vec3 m = cross(pc, pq);\n    float v = dot(pa, m);\n    vec3 intersectPos;\n    if (v >= 0.0)\n    {\n        float u = -dot(pb, m);\n        if (u < 0.0) return false;\n        float w = ScalarTriple(pq, pb, pa);\n        if (w < 0.0) return false;\n        float denom = 1.0 / (u + v + w);\n        u *= denom;\n        v *= denom;\n        w *= denom;\n        intersectPos = u * a + v * b + w * c;\n    }\n    else\n    {\n        vec3 pd = d - p;\n        float u = dot(pd, m);\n        if (u < 0.0) return false;\n        float w = ScalarTriple(pq, pa, pd);\n        if (w < 0.0) return false;\n        v = -v;\n        float denom = 1.0 / (u + v + w);\n        u *= denom;\n        v *= denom;\n        w *= denom;\n        intersectPos = u * a + v * d + w * c;\n    }\n\n    float dist;\n    if (abs(rayDir.x) > 0.1)\n    {\n        dist = (intersectPos.x - rayPos.x) / rayDir.x;\n    }\n    else if (abs(rayDir.y) > 0.1)\n    {\n        dist = (intersectPos.y - rayPos.y) / rayDir.y;\n    }\n    else\n    {\n        dist = (intersectPos.z - rayPos.z) / rayDir.z;\n    }\n\n    if (dist > c_minimumRayHitTime && dist < info.dist)\n    {\n        info.fromInside = false;\n        info.dist = dist;\n        info.normal = normal;\n        return true;\n    }\n\n    return false;\n}\n\nbool TestBoxTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec3 startPoint, in vec3 endPoint)\n{\n    vec3 minPoint = min(startPoint, endPoint);\n    vec3 maxPoint = max(startPoint, endPoint);\n\n    float t1 = (minPoint.x - rayPos.x) / rayDir.x;\n    float t2 = (maxPoint.x - rayPos.x) / rayDir.x;\n    float t3 = (minPoint.y - rayPos.y) / rayDir.y;\n    float t4 = (maxPoint.y - rayPos.y) / rayDir.y;\n    float t5 = (minPoint.z - rayPos.z) / rayDir.z;\n    float t6 = (maxPoint.z - rayPos.z) / rayDir.z;\n\n    float tmin = max(max(min(t1, t2), min(t3, t4)), min(t5, t6));\n    float tmax = min(min(max(t1, t2), max(t3, t4)), max(t5, t6));\n\n    if (tmax < 0. || tmin > tmax)\n    {\n        return false;\n    }\n\n    float dist;\n    vec3 normal;\n\n    if (tmin > 0.)\n    {\n        dist = tmin;\n        vec3 hitPoint = rayPos + rayDir * tmin;\n\n        vec3 hitNormal;\n\n        if (abs(hitPoint.x - minPoint.x) < 0.001)\n        {\n            hitNormal = vec3(-1.0, 0.0, 0.0);\n        }\n        else if (abs(hitPoint.x - maxPoint.x) < 0.001)\n        {\n            hitNormal = vec3(1.0, 0.0, 0.0);\n        }\n        else if (abs(hitPoint.y - minPoint.y) < 0.001)\n        {\n            hitNormal = vec3(0.0, -1.0, 0.0);\n        }\n        else if (abs(hitPoint.y - maxPoint.y) < 0.001)\n        {\n            hitNormal = vec3(0.0, 1.0, 0.0);\n        }\n        else if (abs(hitPoint.z - minPoint.z) < 0.001)\n        {\n            hitNormal = vec3(0.0, 0.0, -1.0);\n        }\n        else if (abs(hitPoint.z - maxPoint.z) < 0.001)\n        {\n            hitNormal = vec3(0.0, 0.0, 1.0);\n        }\n\n        normal = normalize(hitNormal);\n    }\n    else\n    {\n        dist = tmax;\n        normal = vec3(0.0);\n    }\n    bool fromInside = false;\n    if (dist > c_minimumRayHitTime && dist < info.dist)\n    {\n        info.fromInside = fromInside;\n        info.dist = dist;\n        info.normal = normal;\n        return true;\n    }\n\n    return false;\n}\n\nbool TestSphereTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec4 sphere)\n{\n    vec3 m = rayPos - sphere.xyz;\n    float b = dot(m, rayDir);\n    float c = dot(m, m) - sphere.w * sphere.w;\n\n    if (c > 0.0 && b > 0.0)\n        return false;\n\n    float discr = b * b - c;\n\n    if (discr < 0.0)\n        return false;\n\n    bool fromInside = false;\n    float dist = -b - sqrt(discr);\n    if (dist < 0.0)\n    {\n        fromInside = true;\n        dist = -b + sqrt(discr);\n    }\n\n    if (dist > c_minimumRayHitTime && dist < info.dist)\n    {\n        info.fromInside = fromInside;\n        info.dist = dist;\n        info.normal = normalize((rayPos + rayDir * dist) - sphere.xyz) * (fromInside ? -1.0 : 1.0);\n        return true;\n    }\n\n    return false;\n}\n\n\nvoid TestSceneTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo hitInfo)\n{    \n    // to move the scene around, since we can't move the camera yet\n    vec3 sceneTranslation = vec3(0.0f, -3., -10.f);\n    vec4 sceneTranslation4 = vec4(sceneTranslation, 0.0f);\n    vec2 mouse = (iMouse.xy/iResolution.xy-.5)*2.;\n    \n    {\n        //light ball array\n        for (int i = 1;i<=36;i++)\n        {\n            vec3 A = GenerateArrayPosition(vec3(-22.5f-15., -8., 15.),vec3(6.,1.,6.),vec3(15.),i);\n            if (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(A, 1.75f)+sceneTranslation4))\n            {\n                hitInfo.material.albedo = vec3(1.0f, 1.0f, 1.0f);\n                if(i ==1||i==3||i==5||i==8||i==10||i==12||i==13||i==15||i==17||i==20||i==22||i==27||i==29||i==32||i==34||i==36)\n                hitInfo.material.emissive = vec3(0.933,0.000,1.000); \n                else\n                hitInfo.material.emissive = vec3(0.,0.,1.);\n                hitInfo.material.specular = 1.0f;\n                hitInfo.material.specularRoughness = 0.0f;\n                hitInfo.material.specularColor = vec3(0.3f, 1.0f, 0.3f);\n            }\n        }\n        \n        //glass ball array\n        for (int i = 1;i<=25;i++)\n        {\n            vec3 A = GenerateArrayPosition(vec3(-22.5-7.5, -11., 27.5f+7.5),vec3(5.,1.,5.),vec3(15.),i);\n            if (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(A, 3.)+sceneTranslation4))\n            {\n                hitInfo.material.albedo = vec3(1.);\n                hitInfo.material.emissive = vec3(0.);   \n                hitInfo.material.specular = .1;\n                hitInfo.material.specularRoughness = 0.;\n                hitInfo.material.specularColor = vec3(1.); \n                hitInfo.material.IOR =1.3;\n                hitInfo.material.refraction = 1.f;\n                hitInfo.material.refractionRoughness = 0.;\n                hitInfo.material.refractionColor = vec3(0.,0.,0.);\n                }\n        }\n        \n        //matt glass ball array\n        for (int i = 1;i<=25;i++)\n        {\n            vec3 A = GenerateArrayPosition(vec3(-22.5, -11.-5., 27.5f+7.5),vec3(5.,1.,5.),vec3(15.),i);\n            if (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(A, 3.)+sceneTranslation4))\n            {\n                hitInfo.material.albedo = vec3(1.);\n                hitInfo.material.emissive = vec3(0.);   \n                hitInfo.material.specular = .8;\n                hitInfo.material.specularRoughness = 0.4;\n                hitInfo.material.specularColor = vec3(0.278,1.000,0.784); \n                hitInfo.material.IOR =1.5;\n                hitInfo.material.refraction = 1.0f;\n                hitInfo.material.refractionRoughness = 0.7;\n                hitInfo.material.refractionColor = vec3(1.000,0.000,0.000);\n            }\n        }\n        \n        \n        // floor\n        {\n            vec3 A = vec3(-100., -20.f, 200.f) + sceneTranslation;\n            vec3 B = vec3( 100., -20.f, 200.f) + sceneTranslation;\n            vec3 C = vec3( 100., -20.f, 15.0f) + sceneTranslation;\n            vec3 D = vec3(-100., -20.f, 15.0f) + sceneTranslation;\n            if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n            {\n                vec3 hitPos = rayPos + rayDir * hitInfo.dist;\n                float shade = floor(mod(hitPos.y, 1.f) * 2.f);\n                hitInfo.material.albedo = vec3(shade, shade, shade);\n                hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n                hitInfo.material.specular = .5f;\n                hitInfo.material.specularRoughness = 0.3f;\n                hitInfo.material.specularColor = vec3(1.);  \n                hitInfo.material.IOR =1.;\n                hitInfo.material.refraction = 1.0f;\n                hitInfo.material.refractionRoughness = 0.7;\n                hitInfo.material.refractionColor = vec3(1.000,1.000,1.000);\n            \n            }        \n        }\n        \n        // ceiling light\n        {\n            vec3 A = vec3(-5.0f, 12.4f,  22.5f) + sceneTranslation;\n            vec3 B = vec3( 5.0f, 12.4f,  22.5f) + sceneTranslation;\n            vec3 C = vec3( 5.0f, 12.4f,  17.5f) + sceneTranslation;\n            vec3 D = vec3(-5.0f, 12.4f,  17.5f) + sceneTranslation;\n            if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n            {\n                hitInfo.material.albedo = vec3(0.0f, 0.0f, 0.0f);\n                hitInfo.material.emissive = vec3(1.0f, 0.9f, 0.7f) * 10.0f;\n                hitInfo.material.specular = 0.0f;\n                hitInfo.material.specularRoughness = 0.0f;\n                hitInfo.material.specularColor = vec3(0.0f, 0.0f, 0.0f);            \n            }        \n        }\n\t}\n    \n    \n    \n}\n\nfloat GetRedColorForRay(in vec3 startRayPos, in vec3 startRayDir, inout uint rngState)\n{\n    float ret = 0.0;\n    float throughput = 1.0;\n    vec3 rayPos = startRayPos;\n    vec3 rayDir = startRayDir;\n\n    for (int bounceIndex = 0; bounceIndex <= c_numBounces; ++bounceIndex)\n    {\n        SRayHitInfo hitInfo;\n        hitInfo.material = GetZeroedMaterial();\n        hitInfo.dist = c_superFar;\n        hitInfo.fromInside = false;\n        TestSceneTrace(rayPos, rayDir, hitInfo);\n\n        if (hitInfo.dist == c_superFar)\n        {\n            ret += environmentBrightness * SRGBToLinear(texture(iChannel1, rayDir).rgb).r * throughput;\n            break;\n        }\n\n        if (hitInfo.fromInside)\n            throughput *= exp(-hitInfo.material.refractionColor.r * hitInfo.dist);\n\n        float specularChance = hitInfo.material.specular;\n        float refractionChance = hitInfo.material.refraction;\n\n        float rayProbability = 1.0;\n\n        if (specularChance > 0.0)\n        {\n            specularChance = FresnelReflectAmount(\n                hitInfo.fromInside ? hitInfo.material.IOR - DispersionIOR : 1.0,\n                !hitInfo.fromInside ? hitInfo.material.IOR - DispersionIOR : 1.0,\n                rayDir, hitInfo.normal, hitInfo.material.specular, 1.0);\n\n            float chanceMultiplier = (1.0 - specularChance) / (1.0 - hitInfo.material.specular);\n            refractionChance *= chanceMultiplier;\n        }\n\n        float doSpecular = 0.0;\n        float doRefraction = 0.0;\n        float raySelectRoll = RandomFloat01(rngState);\n\n        if (specularChance > 0.0 && raySelectRoll < specularChance)\n        {\n            doSpecular = 1.0;\n            rayProbability = specularChance;\n        }\n        else if (refractionChance > 0.0 && raySelectRoll < specularChance + refractionChance)\n        {\n            doRefraction = 1.0;\n            rayProbability = refractionChance;\n        }\n        else\n        {\n            rayProbability = 1.0 - (specularChance + refractionChance);\n        }\n\n        rayProbability = max(rayProbability, 0.001);\n\n        if (doRefraction == 1.0)\n        {\n            rayPos = (rayPos + rayDir * hitInfo.dist) - hitInfo.normal * c_rayPosNormalNudge;\n        }\n        else\n        {\n            rayPos = (rayPos + rayDir * hitInfo.dist) + hitInfo.normal * c_rayPosNormalNudge;\n        }\n\n        vec3 diffuseRayDir = normalize(hitInfo.normal + RandomUnitVector(rngState));\n        vec3 specularRayDir = reflect(rayDir, hitInfo.normal);\n        specularRayDir = normalize(mix(specularRayDir, diffuseRayDir, hitInfo.material.specularRoughness * hitInfo.material.specularRoughness));\n        vec3 refractionRayDir = refract(rayDir, hitInfo.normal, hitInfo.fromInside ? (hitInfo.material.IOR - DispersionIOR) : 1.0 / (hitInfo.material.IOR - DispersionIOR));\n        refractionRayDir = normalize(mix(refractionRayDir, normalize(-hitInfo.normal + RandomUnitVector(rngState)), hitInfo.material.refractionRoughness * hitInfo.material.refractionRoughness));\n        rayDir = mix(diffuseRayDir, specularRayDir, doSpecular);\n        rayDir = mix(rayDir, refractionRayDir, doRefraction);\n\n        ret += hitInfo.material.emissive.r * throughput;\n\n        if (doRefraction == 0.0)\n            throughput *= mix(hitInfo.material.albedo.r, hitInfo.material.specularColor.r, doSpecular);\n\n        throughput /= rayProbability;\n\n        {\n            float p = throughput;\n            if (RandomFloat01(rngState) > p)\n                break;\n\n            throughput *= 1.0 / p;\n        }\n    }\n    return ret;\n}\n\nfloat GetGreenColorForRay(in vec3 startRayPos, in vec3 startRayDir, inout uint rngState)\n{\n    float ret = 0.0;\n    float throughput = 1.0;\n    vec3 rayPos = startRayPos;\n    vec3 rayDir = startRayDir;\n\n    for (int bounceIndex = 0; bounceIndex <= c_numBounces; ++bounceIndex)\n    {\n        SRayHitInfo hitInfo;\n        hitInfo.material = GetZeroedMaterial();\n        hitInfo.dist = c_superFar;\n        hitInfo.fromInside = false;\n        TestSceneTrace(rayPos, rayDir, hitInfo);\n\n        if (hitInfo.dist == c_superFar)\n        {\n            ret += environmentBrightness * SRGBToLinear(texture(iChannel1, rayDir).rgb).g * throughput;\n            break;\n        }\n\n        if (hitInfo.fromInside)\n            throughput *= exp(-hitInfo.material.refractionColor.g * hitInfo.dist);\n\n        float specularChance = hitInfo.material.specular;\n        float refractionChance = hitInfo.material.refraction;\n\n        float rayProbability = 1.0;\n\n        if (specularChance > 0.0)\n        {\n            specularChance = FresnelReflectAmount(\n                hitInfo.fromInside ? hitInfo.material.IOR : 1.0,\n                !hitInfo.fromInside ? hitInfo.material.IOR : 1.0,\n                rayDir, hitInfo.normal, hitInfo.material.specular, 1.0);\n\n            float chanceMultiplier = (1.0 - specularChance) / (1.0 - hitInfo.material.specular);\n            refractionChance *= chanceMultiplier;\n        }\n\n        float doSpecular = 0.0;\n        float doRefraction = 0.0;\n        float raySelectRoll = RandomFloat01(rngState);\n\n        if (specularChance > 0.0 && raySelectRoll < specularChance)\n        {\n            doSpecular = 1.0;\n            rayProbability = specularChance;\n        }\n        else if (refractionChance > 0.0 && raySelectRoll < specularChance + refractionChance)\n        {\n            doRefraction = 1.0;\n            rayProbability = refractionChance;\n        }\n        else\n        {\n            rayProbability = 1.0 - (specularChance + refractionChance);\n        }\n\n        rayProbability = max(rayProbability, 0.001);\n\n        if (doRefraction == 1.0)\n        {\n            rayPos = (rayPos + rayDir * hitInfo.dist) - hitInfo.normal * c_rayPosNormalNudge;\n        }\n        else\n        {\n            rayPos = (rayPos + rayDir * hitInfo.dist) + hitInfo.normal * c_rayPosNormalNudge;\n        }\n\n        vec3 diffuseRayDir = normalize(hitInfo.normal + RandomUnitVector(rngState));\n        vec3 specularRayDir = reflect(rayDir, hitInfo.normal);\n        specularRayDir = normalize(mix(specularRayDir, diffuseRayDir, hitInfo.material.specularRoughness * hitInfo.material.specularRoughness));\n        vec3 refractionRayDir = refract(rayDir, hitInfo.normal, hitInfo.fromInside ? (hitInfo.material.IOR) : 1.0 / (hitInfo.material.IOR));\n        refractionRayDir = normalize(mix(refractionRayDir, normalize(-hitInfo.normal + RandomUnitVector(rngState)), hitInfo.material.refractionRoughness * hitInfo.material.refractionRoughness));\n        rayDir = mix(diffuseRayDir, specularRayDir, doSpecular);\n        rayDir = mix(rayDir, refractionRayDir, doRefraction);\n\n        ret += hitInfo.material.emissive.g * throughput;\n\n        if (doRefraction == 0.0)\n            throughput *= mix(hitInfo.material.albedo.g, hitInfo.material.specularColor.g, doSpecular);\n\n        throughput /= rayProbability;\n\n        {\n            float p = throughput;\n            if (RandomFloat01(rngState) > p)\n                break;\n\n            throughput *= 1.0 / p;\n        }\n    }\n    return ret;\n}\n\nfloat GetBlueColorForRay(in vec3 startRayPos, in vec3 startRayDir, inout uint rngState)\n{\n    float ret = 0.0;\n    float throughput = 1.0;\n    vec3 rayPos = startRayPos;\n    vec3 rayDir = startRayDir;\n\n    for (int bounceIndex = 0; bounceIndex <= c_numBounces; ++bounceIndex)\n    {\n        SRayHitInfo hitInfo;\n        hitInfo.material = GetZeroedMaterial();\n        hitInfo.dist = c_superFar;\n        hitInfo.fromInside = false;\n        TestSceneTrace(rayPos, rayDir, hitInfo);\n\n        if (hitInfo.dist == c_superFar)\n        {\n            ret += environmentBrightness * SRGBToLinear(texture(iChannel1, rayDir).rgb).b * throughput;\n            break;\n        }\n\n        if (hitInfo.fromInside)\n            throughput *= exp(-hitInfo.material.refractionColor.b * hitInfo.dist);\n\n        float specularChance = hitInfo.material.specular;\n        float refractionChance = hitInfo.material.refraction;\n\n        float rayProbability = 1.0;\n\n        if (specularChance > 0.0)\n        {\n            specularChance = FresnelReflectAmount(\n                hitInfo.fromInside ? hitInfo.material.IOR + DispersionIOR : 1.0,\n                !hitInfo.fromInside ? hitInfo.material.IOR + DispersionIOR : 1.0,\n                rayDir, hitInfo.normal, hitInfo.material.specular, 1.0);\n\n            float chanceMultiplier = (1.0 - specularChance) / (1.0 - hitInfo.material.specular);\n            refractionChance *= chanceMultiplier;\n        }\n\n        float doSpecular = 0.0;\n        float doRefraction = 0.0;\n        float raySelectRoll = RandomFloat01(rngState);\n\n        if (specularChance > 0.0 && raySelectRoll < specularChance)\n        {\n            doSpecular = 1.0;\n            rayProbability = specularChance;\n        }\n        else if (refractionChance > 0.0 && raySelectRoll < specularChance + refractionChance)\n        {\n            doRefraction = 1.0;\n            rayProbability = refractionChance;\n        }\n        else\n        {\n            rayProbability = 1.0 - (specularChance + refractionChance);\n        }\n\n        rayProbability = max(rayProbability, 0.001);\n\n        if (doRefraction == 1.0)\n        {\n            rayPos = (rayPos + rayDir * hitInfo.dist) - hitInfo.normal * c_rayPosNormalNudge;\n        }\n        else\n        {\n            rayPos = (rayPos + rayDir * hitInfo.dist) + hitInfo.normal * c_rayPosNormalNudge;\n        }\n\n        vec3 diffuseRayDir = normalize(hitInfo.normal + RandomUnitVector(rngState));\n        vec3 specularRayDir = reflect(rayDir, hitInfo.normal);\n        specularRayDir = normalize(mix(specularRayDir, diffuseRayDir, hitInfo.material.specularRoughness * hitInfo.material.specularRoughness));\n        vec3 refractionRayDir = refract(rayDir, hitInfo.normal, hitInfo.fromInside ? (hitInfo.material.IOR + DispersionIOR) : 1.0 / (hitInfo.material.IOR + DispersionIOR));\n        refractionRayDir = normalize(mix(refractionRayDir, normalize(-hitInfo.normal + RandomUnitVector(rngState)), hitInfo.material.refractionRoughness * hitInfo.material.refractionRoughness));\n        rayDir = mix(diffuseRayDir, specularRayDir, doSpecular);\n        rayDir = mix(rayDir, refractionRayDir, doRefraction);\n\n        ret += hitInfo.material.emissive.b * throughput;\n\n        if (doRefraction == 0.0)\n            throughput *= mix(hitInfo.material.albedo.b, hitInfo.material.specularColor.b, doSpecular);\n\n        throughput /= rayProbability;\n\n        {\n            float p = throughput;\n            if (RandomFloat01(rngState) > p)\n                break;\n\n            throughput *= 1.0 / p;\n        }\n    }\n    return ret;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    uint rngState = uint(uint(fragCoord.x) * uint(2003) + uint(fragCoord.y) * uint(200306) + uint(iFrame) * uint(20030608)) | uint(1);\n\n    vec3 rayPosition = vec3(0.0f, .5f, 0.0f);\n    vec2 jitter = vec2(RandomFloat01(rngState), RandomFloat01(rngState)) - 0.5f;\n    vec2 uv = (fragCoord + jitter - 0.5 * iResolution.xy) / iResolution.y;\n    float cameraDistance = 1.0f / tan(c_FOVDegrees * 0.5f * c_pi / 180.0f);\n    vec3 rayTarget = vec3(uv, cameraDistance);\n    \n    vec3 rayDir = normalize(rayTarget - rayPosition);\n    \n    vec3 color = vec3(0.);\n    \n    float c_numRendersPerFrame = texture(iChannel3,uv).z;\n    float doRefresh = texture(iChannel3,uv).a;\n    \n    for (float index = 0.; index < c_numRendersPerFrame; index++)\n    {\n        color.r += GetRedColorForRay(rayPosition, rayDir, rngState) / float(c_numRendersPerFrame);\n        color.g += GetGreenColorForRay(rayPosition, rayDir, rngState) / float(c_numRendersPerFrame);\n        color.b += GetBlueColorForRay(rayPosition, rayDir, rngState) / float(c_numRendersPerFrame);\n    }\n\n    bool spacePressed = (texture(iChannel2, vec2(KEY_SPACE, 0.25)).x > 0.1);\n    \n    vec4 lastFrameColor = texture(iChannel0, fragCoord / iResolution.xy);\n    float blend = (doRefresh==1.||iFrame < 2 || iMouse.z > 0.0 || lastFrameColor.a == 0.0f || spacePressed) ? 1.0f : 1.0f / (1.0f + (1.0f / lastFrameColor.a));\n    color = mix(lastFrameColor.rgb, color, blend);\n\n    fragColor = vec4(color, blend);\n}\n\n \n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define DispersionIOR 0.005\nconst float c_minimumRayHitTime = 0.01f;\nconst float c_rayPosNormalNudge = 0.01f;\nconst float c_superFar = 100.0f;\nconst float c_FOVDegrees = 90.0f;\nconst int c_numBounces = 8;\nconst float environmentBrightness = 1.3;\nconst float c_exposure = 1.f; \n\nconst float c_pi = 3.14159265359f;\nconst float c_twopi = 2.0f * c_pi;\nconst float KEY_SPACE = 32.5/256.0;\n\nconst float minDistance = 0.;\nconst float maxDistance = 25.;\nconst float clearDistance = 6.;\nconst float DOF = 2.;\nconst float Blur = 8.;\n\nuint hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(56)) ^ uint(seed >> uint(12));\n    seed *= uint(8);\n    seed = seed ^ (seed >> 5);\n    seed *= uint(0x18b3ce5f);\n    seed = seed ^ (seed >> 6);\n    return seed;\n}\n\nfloat RandomFloat01(inout uint state)\n{\n    return float(hash(state)) / 4294967296.0;\n}\n\nvec3 RandomUnitVector(inout uint state)\n{\n    float z = RandomFloat01(state) * 2.0f - 1.0f;\n    float a = RandomFloat01(state) * c_twopi;\n    float r = sqrt(1.0f - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\n\nfloat FresnelReflectAmount(float n1, float n2, vec3 normal, vec3 incident, float min_reflectance, float max_reflectance)\n{\n    float R = (n1 - n2) *(n1 - n2)/ (n1 + n2)*(n1 + n2);\n    float cosI = -dot(normal, incident);\n    \n    if (n1 > n2)\n    {\n        float n = n1 / n2;\n        float sinT2 = n * n * (1.0 - cosI * cosI);\n        if (sinT2 > 1.0)\n            return max_reflectance;\n            \n        cosI = sqrt(1.0 - sinT2);\n    }\n    \n    float x = 1.0 - cosI;\n    float ret = R + (1.0 - R) * x * x * x * x * x;\n\n    return mix(min_reflectance, max_reflectance, ret);\n}\n\nvec3 LessThan(vec3 f, float value)\n{\n    return vec3(\n        (f.x < value) ? 1.0f : 0.0f,\n        (f.y < value) ? 1.0f : 0.0f,\n        (f.z < value) ? 1.0f : 0.0f);\n}\n\nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n    \n    return mix(\n        pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,\n        rgb * 12.92f,\n        LessThan(rgb, 0.0031308f)\n    );\n}\n\nvec3 SRGBToLinear(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n    \n    return mix(\n        pow(((rgb + 0.055f) / 1.055f), vec3(2.4f)),\n        rgb / 12.92f,\n        LessThan(rgb, 0.04045f)\n\t);\n}\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n\n\nfloat map(float value, float in_min, float in_max, float out_min, float out_max) {\n    return out_min + (out_max - out_min) * (value - in_min) / (in_max - in_min);\n}\n\n\nvec3 GenerateArrayPosition(vec3 position, vec3 size, vec3 interval, int index) {\n    index=index-1;\n    index = clamp(index,0,int(size.x*size.y*size.z));\n    int totalElements = int(size.x * size.y * size.z);\n    int elementsPerRow = int(size.y * size.z);\n    int row = index / elementsPerRow;\n    int remaining = index - row * elementsPerRow;\n    int col = remaining / int(size.z);\n    int layer = remaining - col * int(size.z);\n    \n    vec3 arrayPosition;\n    arrayPosition.x = position.x + float(row) * interval.x;\n    arrayPosition.y = position.y + float(col) * interval.y;\n    arrayPosition.z = position.z + float(layer) * interval.z;\n\n    return arrayPosition;\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"struct SMaterialInfo\n{\n    vec3  albedo;\n    vec3  emissive;\n    float specular;\n    float specularRoughness;\n    vec3  specularColor;\n    float IOR;\n    float refraction;\n    float refractionRoughness;\n    vec3  refractionColor;\n};\n\nSMaterialInfo GetZeroedMaterial()\n{\n    SMaterialInfo ret;\n    ret.albedo = vec3(0.0, 0.0, 0.0);\n    ret.emissive = vec3(0.0, 0.0, 0.0);\n    ret.specular = 0.0;\n    ret.specularRoughness = 0.0;\n    ret.specularColor = vec3(0.0, 0.0, 0.0);\n    ret.IOR = 1.0;\n    ret.refraction = 0.0;\n    ret.refractionRoughness = 0.0;\n    ret.refractionColor = vec3(0.0, 0.0, 0.0);\n    return ret;\n}\n\nstruct SRayHitInfo\n{\n    bool fromInside;\n    float dist;\n    vec3 normal;\n    SMaterialInfo material;\n};\n\nfloat ScalarTriple(vec3 u, vec3 v, vec3 w)\n{\n    return dot(cross(u, v), w);\n}\n\n\nbool TestQuadTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec3 a, in vec3 b, in vec3 c, in vec3 d)\n{\n    vec3 normal = normalize(cross(c - a, c - b));\n    if (dot(normal, rayDir) > 0.0)\n    {\n        normal *= -1.0;\n\n        vec3 temp = d;\n        d = a;\n        a = temp;\n\n        temp = b;\n        b = c;\n        c = temp;\n    }\n\n    vec3 p = rayPos;\n    vec3 q = rayPos + rayDir;\n    vec3 pq = q - p;\n    vec3 pa = a - p;\n    vec3 pb = b - p;\n    vec3 pc = c - p;\n\n    vec3 m = cross(pc, pq);\n    float v = dot(pa, m);\n    vec3 intersectPos;\n    if (v >= 0.0)\n    {\n        float u = -dot(pb, m);\n        if (u < 0.0) return false;\n        float w = ScalarTriple(pq, pb, pa);\n        if (w < 0.0) return false;\n        float denom = 1.0 / (u + v + w);\n        u *= denom;\n        v *= denom;\n        w *= denom;\n        intersectPos = u * a + v * b + w * c;\n    }\n    else\n    {\n        vec3 pd = d - p;\n        float u = dot(pd, m);\n        if (u < 0.0) return false;\n        float w = ScalarTriple(pq, pa, pd);\n        if (w < 0.0) return false;\n        v = -v;\n        float denom = 1.0 / (u + v + w);\n        u *= denom;\n        v *= denom;\n        w *= denom;\n        intersectPos = u * a + v * d + w * c;\n    }\n\n    float dist;\n    if (abs(rayDir.x) > 0.1)\n    {\n        dist = (intersectPos.x - rayPos.x) / rayDir.x;\n    }\n    else if (abs(rayDir.y) > 0.1)\n    {\n        dist = (intersectPos.y - rayPos.y) / rayDir.y;\n    }\n    else\n    {\n        dist = (intersectPos.z - rayPos.z) / rayDir.z;\n    }\n\n    if (dist > c_minimumRayHitTime && dist < info.dist)\n    {\n        info.fromInside = false;\n        info.dist = dist;\n        info.normal = normal;\n        return true;\n    }\n\n    return false;\n}\n\nbool TestBoxTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec3 startPoint, in vec3 endPoint)\n{\n    vec3 minPoint = min(startPoint, endPoint);\n    vec3 maxPoint = max(startPoint, endPoint);\n\n    float t1 = (minPoint.x - rayPos.x) / rayDir.x;\n    float t2 = (maxPoint.x - rayPos.x) / rayDir.x;\n    float t3 = (minPoint.y - rayPos.y) / rayDir.y;\n    float t4 = (maxPoint.y - rayPos.y) / rayDir.y;\n    float t5 = (minPoint.z - rayPos.z) / rayDir.z;\n    float t6 = (maxPoint.z - rayPos.z) / rayDir.z;\n\n    float tmin = max(max(min(t1, t2), min(t3, t4)), min(t5, t6));\n    float tmax = min(min(max(t1, t2), max(t3, t4)), max(t5, t6));\n\n    if (tmax < 0. || tmin > tmax)\n    {\n        return false;\n    }\n\n    float dist;\n    vec3 normal;\n\n    if (tmin > 0.)\n    {\n        dist = tmin;\n        vec3 hitPoint = rayPos + rayDir * tmin;\n\n        vec3 hitNormal;\n\n        if (abs(hitPoint.x - minPoint.x) < 0.001)\n        {\n            hitNormal = vec3(-1.0, 0.0, 0.0);\n        }\n        else if (abs(hitPoint.x - maxPoint.x) < 0.001)\n        {\n            hitNormal = vec3(1.0, 0.0, 0.0);\n        }\n        else if (abs(hitPoint.y - minPoint.y) < 0.001)\n        {\n            hitNormal = vec3(0.0, -1.0, 0.0);\n        }\n        else if (abs(hitPoint.y - maxPoint.y) < 0.001)\n        {\n            hitNormal = vec3(0.0, 1.0, 0.0);\n        }\n        else if (abs(hitPoint.z - minPoint.z) < 0.001)\n        {\n            hitNormal = vec3(0.0, 0.0, -1.0);\n        }\n        else if (abs(hitPoint.z - maxPoint.z) < 0.001)\n        {\n            hitNormal = vec3(0.0, 0.0, 1.0);\n        }\n\n        normal = normalize(hitNormal);\n    }\n    else\n    {\n        dist = tmax;\n        normal = vec3(0.0);\n    }\n    bool fromInside = false;\n    if (dist > c_minimumRayHitTime && dist < info.dist)\n    {\n        info.fromInside = fromInside;\n        info.dist = dist;\n        info.normal = normal;\n        return true;\n    }\n\n    return false;\n}\n\nbool TestSphereTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec4 sphere)\n{\n    vec3 m = rayPos - sphere.xyz;\n    float b = dot(m, rayDir);\n    float c = dot(m, m) - sphere.w * sphere.w;\n\n    if (c > 0.0 && b > 0.0)\n        return false;\n\n    float discr = b * b - c;\n\n    if (discr < 0.0)\n        return false;\n\n    bool fromInside = false;\n    float dist = -b - sqrt(discr);\n    if (dist < 0.0)\n    {\n        fromInside = true;\n        dist = -b + sqrt(discr);\n    }\n\n    if (dist > c_minimumRayHitTime && dist < info.dist)\n    {\n        info.fromInside = fromInside;\n        info.dist = dist;\n        info.normal = normalize((rayPos + rayDir * dist) - sphere.xyz) * (fromInside ? -1.0 : 1.0);\n        return true;\n    }\n\n    return false;\n}\n\nvoid TestSceneTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo hitInfo)\n{    \n    // to move the scene around, since we can't move the camera yet\n    vec3 sceneTranslation = vec3(0.0f, -3., -10.f);\n    vec4 sceneTranslation4 = vec4(sceneTranslation, 0.0f);\n    vec2 mouse = (iMouse.xy/iResolution.xy-.5)*2.;\n    \n    {\n        //light ball array\n        for (int i = 1;i<=36;i++)\n        {\n            vec3 A = GenerateArrayPosition(vec3(-22.5f-15., -8., 15.),vec3(6.,1.,6.),vec3(15.),i);\n            if (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(A, 1.75f)+sceneTranslation4))\n            {\n                hitInfo.material.albedo = vec3(1.0f, 1.0f, 1.0f);\n                if(i ==1||i==3||i==5||i==8||i==10||i==12||i==13||i==15||i==17||i==20||i==22||i==27||i==29||i==32||i==34||i==36)\n                hitInfo.material.emissive = vec3(0.933,0.000,1.000); \n                else\n                hitInfo.material.emissive = vec3(0.,0.,1.);\n                hitInfo.material.specular = 1.0f;\n                hitInfo.material.specularRoughness = 0.0f;\n                hitInfo.material.specularColor = vec3(0.3f, 1.0f, 0.3f);\n            }\n        }\n        \n        //glass ball array\n        for (int i = 1;i<=25;i++)\n        {\n            vec3 A = GenerateArrayPosition(vec3(-22.5-7.5, -11., 27.5f+7.5),vec3(5.,1.,5.),vec3(15.),i);\n            if (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(A, 3.)+sceneTranslation4))\n            {\n                hitInfo.material.albedo = vec3(1.);\n                hitInfo.material.emissive = vec3(0.);   \n                hitInfo.material.specular = .1;\n                hitInfo.material.specularRoughness = 0.;\n                hitInfo.material.specularColor = vec3(1.); \n                hitInfo.material.IOR =1.3;\n                hitInfo.material.refraction = 1.f;\n                hitInfo.material.refractionRoughness = 0.;\n                hitInfo.material.refractionColor = vec3(0.,0.,0.);\n                }\n        }\n        \n        //matt glass ball array\n        for (int i = 1;i<=25;i++)\n        {\n            vec3 A = GenerateArrayPosition(vec3(-22.5, -11.-5., 27.5f+7.5),vec3(5.,1.,5.),vec3(15.),i);\n            if (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(A, 3.)+sceneTranslation4))\n            {\n                hitInfo.material.albedo = vec3(1.);\n                hitInfo.material.emissive = vec3(0.);   \n                hitInfo.material.specular = .8;\n                hitInfo.material.specularRoughness = 0.4;\n                hitInfo.material.specularColor = vec3(0.278,1.000,0.784); \n                hitInfo.material.IOR =1.5;\n                hitInfo.material.refraction = 1.0f;\n                hitInfo.material.refractionRoughness = 0.7;\n                hitInfo.material.refractionColor = vec3(1.000,0.000,0.000);\n            }\n        }\n        \n        \n        // floor\n        {\n            vec3 A = vec3(-100., -20.f, 200.f) + sceneTranslation;\n            vec3 B = vec3( 100., -20.f, 200.f) + sceneTranslation;\n            vec3 C = vec3( 100., -20.f, 15.0f) + sceneTranslation;\n            vec3 D = vec3(-100., -20.f, 15.0f) + sceneTranslation;\n            if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n            {\n                vec3 hitPos = rayPos + rayDir * hitInfo.dist;\n                float shade = floor(mod(hitPos.y, 1.f) * 2.f);\n                hitInfo.material.albedo = vec3(shade, shade, shade);\n                hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n                hitInfo.material.specular = .5f;\n                hitInfo.material.specularRoughness = 0.3f;\n                hitInfo.material.specularColor = vec3(1.);  \n                hitInfo.material.IOR =1.;\n                hitInfo.material.refraction = 1.0f;\n                hitInfo.material.refractionRoughness = 0.7;\n                hitInfo.material.refractionColor = vec3(1.000,1.000,1.000);\n            \n            }        \n        }\n        \n        // ceiling light\n        {\n            vec3 A = vec3(-5.0f, 12.4f,  22.5f) + sceneTranslation;\n            vec3 B = vec3( 5.0f, 12.4f,  22.5f) + sceneTranslation;\n            vec3 C = vec3( 5.0f, 12.4f,  17.5f) + sceneTranslation;\n            vec3 D = vec3(-5.0f, 12.4f,  17.5f) + sceneTranslation;\n            if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n            {\n                hitInfo.material.albedo = vec3(0.0f, 0.0f, 0.0f);\n                hitInfo.material.emissive = vec3(1.0f, 0.9f, 0.7f) * 10.0f;\n                hitInfo.material.specular = 0.0f;\n                hitInfo.material.specularRoughness = 0.0f;\n                hitInfo.material.specularColor = vec3(0.0f, 0.0f, 0.0f);            \n            }        \n        }\n\t}\n    \n    \n    \n}\n\nvec3 GetColorForRay(in vec3 startRayPos, in vec3 startRayDir, inout uint rngState)\n{\n    vec3 ret = vec3(0.);\n    vec3 throughput = vec3(1.);\n    vec3 rayPos = startRayPos;\n    vec3 rayDir = startRayDir;\n    float totalDistance = 0.;\n\n    for (int bounceIndex = 0; bounceIndex <= 0; ++bounceIndex)\n    {\n        SRayHitInfo hitInfo;\n        hitInfo.material = GetZeroedMaterial();\n        hitInfo.dist = c_superFar;\n        hitInfo.fromInside = false;\n        TestSceneTrace(rayPos, rayDir, hitInfo);\n\n        if (hitInfo.dist == c_superFar)\n        {\n            return vec3(1.);\n            break;\n        }\n\n        if (hitInfo.fromInside)\n            throughput *= exp(-hitInfo.material.refractionColor * hitInfo.dist);\n\n        float specularChance = hitInfo.material.specular;\n        float refractionChance = hitInfo.material.refraction;\n\n        float rayProbability = 1.0f;\n\n        if (specularChance > 0.)\n        {\n            specularChance = FresnelReflectAmount(\n                hitInfo.fromInside ? hitInfo.material.IOR : 1.,\n                !hitInfo.fromInside ? hitInfo.material.IOR : 1.,\n                rayDir, hitInfo.normal, hitInfo.material.specular, 1.);\n            float chanceMultiplier = (1. - specularChance) / (1. - hitInfo.material.specular);\n            refractionChance *= chanceMultiplier;\n        }\n\n        float doSpecular = 0.;\n        float doRefraction = 0.;\n        float raySelectRoll = RandomFloat01(rngState);\n\n        rayProbability = 1. - (specularChance + refractionChance);\n\n        rayProbability = max(rayProbability, 0.001);\n\n        if (doRefraction == 1.0f)\n        {\n            rayPos = (rayPos + rayDir * hitInfo.dist) - hitInfo.normal * c_rayPosNormalNudge;\n        }\n        else\n        {\n            rayPos = (rayPos + rayDir * hitInfo.dist) + hitInfo.normal * c_rayPosNormalNudge;\n        }\n\n        vec3 diffuseRayDir = normalize(hitInfo.normal + RandomUnitVector(rngState));\n        rayDir = diffuseRayDir;\n\n        if (dot(rayDir, vec3(0., 0., 1.)) > 0.)\n            totalDistance += dot(hitInfo.dist * normalize(rayDir), vec3(0., 0., 1.));\n        if (dot(rayDir, vec3(0., 0., 1.)) < 0.)\n            totalDistance += dot(hitInfo.dist * normalize(rayDir), vec3(0., 0., -1.));\n\n        if (doRefraction == 0.0f)\n            throughput *= mix(hitInfo.material.albedo, hitInfo.material.specularColor, doSpecular);\n\n        throughput /= rayProbability;\n\n        {\n            float p = max(throughput.r, max(throughput.g, throughput.b));\n            if (RandomFloat01(rngState) > p)\n                break;\n\n            throughput *= 1.0f / p;\n        }\n    }\n\n    totalDistance = clamp(totalDistance, minDistance, maxDistance);\n    totalDistance = map(totalDistance, minDistance, maxDistance, 0., 1.);\n    totalDistance = pow(totalDistance, 2.);\n    ret = vec3(totalDistance);\n    return ret;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n\n    vec3 rayPosition = vec3(0.0f, .5f, 0.0f);\n    vec2 jitter = vec2(RandomFloat01(rngState), RandomFloat01(rngState)) - 0.5f;\n    vec2 uv = (fragCoord + jitter - 0.5 * iResolution.xy) / iResolution.y;\n    float cameraDistance = 1.0f / tan(c_FOVDegrees * 0.5f * c_pi / 180.0f);\n\n    vec3 rayTarget = vec3(uv, cameraDistance);\n    \n    vec3 rayDir = normalize(rayTarget - rayPosition);\n\n    vec3 color = vec3(0.);\n    \n    float c_numRendersPerFrame = texture(iChannel3,uv).z;\n    float doRefresh = texture(iChannel3,uv).a;\n    \n    for (float index = 0.; index < c_numRendersPerFrame; index++)\n        color += GetColorForRay(rayPosition, rayDir, rngState) / float(c_numRendersPerFrame);\n\n    bool spacePressed = (texture(iChannel2, vec2(KEY_SPACE, 0.25)).x > 0.1);\n\n    vec4 lastFrameColor = texture(iChannel0, fragCoord / iResolution.xy);\n    float blend = (doRefresh==1.||iFrame < 2 || iMouse.z > 0.0 || lastFrameColor.a == 0.0f || spacePressed) ? 1.0f : 1.0f / (1.0f + (1.0f / lastFrameColor.a));\n    color = mix(lastFrameColor.rgb, color, blend);\n\n    fragColor = vec4(color, blend);\n}\n\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// This buffer keeps track of the screen resolution and adapts the number of samples\n// per frame depending on hardware(fps) performaces.\n// It enables Buffer A & B to invalidate previously computed samples in case the screen is\n// resized.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{       \n\tvec2 uv = fragCoord/iResolution.xy;\n\n    vec4 prevParams = texture(iChannel0, uv);\n\n    // Ensure the buffer is first initialized with null \n    // parameters and checks for resolution changes   \n    if (abs(prevParams.x - iResolution.x) > 1. ||\n        abs(prevParams.y - iResolution.y) > 1.) {        \n        fragColor = vec4(\n            iResolution.xy,\n            1.,   \n            1);\n    } else {\n        fragColor = vec4(\n            iResolution.xy, \n            prevParams.z, \n            0);\n    }\n\n    // Adaptative samples per frame, updates each 10 frames\n    if (fragColor.w > 0.5 && iFrame%20 == 0) {\n        if (iFrameRate >= 25.0) {\n            fragColor.z = prevParams.z+1.;\n        } else if (iFrameRate <= 15.0 && prevParams.z>=1.) {\n            fragColor.z = prevParams.z-1.;\n            \n        }\n    }\n}\n","name":"Buffer C","description":"","type":"buffer"}]}