{"ver":"0.1","info":{"id":"XdVyDm","date":"1522283871","viewed":1397,"name":"sky with halos","username":"expertmouser","description":"very minor modification to https://www.shadertoy.com/view/llffzM to include a fake 22ยบ halo and a fake parHelic arc.\n\npress space to change the projection","likes":7,"published":1,"flags":16,"usePreview":0,"tags":["sun","atmosphere","halos"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n\t            fork of \"Still non-accurate atmosphere\"             by Ultraviolet\n\twhich was a fork of \"Non physical based atmospheric scattering\" by robobo1221\n\n*/\n\nconst float pi = 3.14159265359;\nconst float kDegToRad = pi * 2.0 / 360.0;\n\nconst float zenithOffset = 0.0;\nconst float multiScatterPhase = 0.1;\nconst float density = 0.7;\nconst float arcDistHalo22 = 22.0 * kDegToRad;\n\nconst vec3 skyColor = vec3(0.39, 0.57, 1.0); //Make sure one of the conponents is never 0.0\n\n\nfloat greatCircleDist(vec2 p, vec2 lp)\n{\n    float phi_1 = p.y;\n    float phi_2 = lp.y;\n    float delta_lambda = p.x-lp.x;\n    return acos(sin(phi_1)*sin(phi_2) + cos(phi_1)*cos(phi_2)*cos(delta_lambda));\n}\n\nfloat  zenithDensity(float x)\n{\n    return density / pow(max(x - zenithOffset, 0.35e-2), 0.75);\n}\n\nvec3 getSkyAbsorption(vec3 x, float y){\n\t\n\tvec3 absorption = x * -y;\n\t     absorption = exp2(absorption) * 2.0;\n\t\n\treturn absorption;\n}\n\nfloat getSunPoint(vec2 p, vec2 lp){\n    float dist = greatCircleDist(p, lp)/pi*2.;\n\treturn smoothstep(0.03, 0.026, dist) * 50.0;\n}\n\nfloat getHalos(vec2 p, vec2 lp){\n    const float haloWidth = 10.0 * kDegToRad;\n    float dist  = greatCircleDist(p, lp)/pi*2. - arcDistHalo22;\n    float haloDist = 1.0 - dist / haloWidth;\n    float f = 1.0 - abs(clamp(haloDist, -1.0, 1.0));\n    \n    float parHelicAmt = 0.0;\n    //if (haloDist < 0.1) {\n      parHelicAmt = 1.0;\n      float parHelicDistPnt = greatCircleDist( p, vec2(pi/2.0));\n      float parHelicDistSun = greatCircleDist(lp, vec2(pi/2.0));\n      float diff = parHelicDistPnt - parHelicDistSun;\n      parHelicAmt = 1.0 - abs(diff);\n      parHelicAmt *= parHelicAmt;\n      parHelicAmt *= parHelicAmt;\n      parHelicAmt *= parHelicAmt;\n   // }\n\n    f = f * f;\n    f *= f * f;\n    f += (f + 1.0) * parHelicAmt;\n    return mix(0.0, 0.1, f);\n}\n\n\nfloat getRayleigMultiplier(vec2 p, vec2 lp)\n{\n    float dist = greatCircleDist(p, lp)/pi*5.;\n\treturn 1.0 + pow(1.0 - clamp(dist, 0.0, 1.0), 2.0) * pi * 0.5;\n}\n\nfloat getMie(vec2 p, vec2 lp){\n    float dist = greatCircleDist(p, lp)/pi*2.;\n\tfloat disk = clamp(1.0 - pow(dist, 0.1), 0.0, 1.0);\n\t\n\treturn disk*disk*(3.0 - 2.0 * disk) * 2.0 * pi;\n}\n\nvec3 getAtmosphericScattering(vec2 p, vec2 lp)\n{\n    \n\tfloat zenith = zenithDensity(p.y);\n\tfloat sunPointDistMult =  clamp(length(max(lp.y + multiScatterPhase - zenithOffset, 0.0)), 0.0, 1.0);\n\t\n\tfloat rayleighMult = getRayleigMultiplier(p, lp);\n\t\n\tvec3 absorption = getSkyAbsorption(skyColor, zenith);\n    vec3 sunAbsorption = getSkyAbsorption(skyColor, zenithDensity(lp.y + multiScatterPhase));\n\tvec3 sky = skyColor * zenith * rayleighMult;\n\tvec3 sun = getSunPoint(p, lp) * absorption;\n    vec3 halo = getHalos(p, lp) * absorption;\n\tvec3 mie = getMie(p, lp) * sunAbsorption;\n\t\n\tvec3 totalSky = mix(sky * absorption, sky / (sky + 0.5), sunPointDistMult);\n         totalSky += sun + mie + halo;\n\t     totalSky *= sunAbsorption * 0.5 + 0.5 * length(sunAbsorption);\n\t\n\treturn totalSky;\n}\n\nvec3 jodieReinhardTonemap(vec3 c)\n{\n    float l = dot(c, vec3(0.2126, 0.7152, 0.0722));\n    vec3 tc = c / (c + 1.0);\n\n    return mix(c / (l + 1.0), tc, tc);\n}\n\nvec2 screen2world(vec2 pos)\n{\n    if(texelFetch(iChannel0, ivec2(32,2),0).x < .5)\n    {\n        pos = (pos.xy / iResolution.xy - .5)*vec2(iResolution.x/iResolution.y, 1.);\n        return vec2(atan(pos.y, pos.x), (.5-length(pos))*pi);\n    }\n    \n    return (pos / iResolution.xy - .5) * vec2(2., 1.) * pi;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 position      = screen2world(fragCoord);\n\tvec2 lightPosition = screen2world(iMouse.xy);\n    \n    if(length(iMouse.xy)<10.)\n        lightPosition = fract(iTime*.1+0.2)<.5?vec2(0., (.5-fract(iTime*.2+0.4))*pi) : vec2(pi, -(.5-fract(iTime*.2+0.4))*pi);\n\t\n\tvec3 color = getAtmosphericScattering(position, lightPosition) * pi;\n\tcolor = jodieReinhardTonemap(color);\n    color = pow(color, vec3(2.2)); //Back to linear\n    \n\t\n\tfragColor = vec4(color, 1.0 );\n\n}\n","name":"Image","description":"","type":"image"}]}