{"ver":"0.1","info":{"id":"MfKyDG","date":"1732337061","viewed":44,"name":"Espacion latice","username":"kukovisuals","description":"Hyperbolic tessallation with some movement ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["tessellation","hyperbolic","hyperbolictessellation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Part of this code is adapted from \"Layers of Poincare Disks\" by  Kamoshika i\n// Link: https://www.shadertoy.com/view/sssBz2\n\n#define PI 3.14159265359\n#define PI2 6.28318530718\n\n\n// Hash function for pseudo-random numbers\nfloat hash(float n) {\n    return fract(sin(n) * 43758.5453);\n}\n\n// Hash function for vec2\nfloat hash(vec2 p) {\n    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n}\n\n\nfloat noise(vec2 uv) {\n    vec2 p = floor(uv);\n    vec2 f = fract(uv);\n    float a = hash(p.x + p.y * 57.0);\n    float b = hash(p.x + 1.0 + p.y * 57.0);\n    float c = hash(p.x + (p.y + 1.0) * 57.0);\n    float d = hash(p.x + 1.0 + (p.y + 1.0) * 57.0);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n\n// Rotate 2D vector\nmat2 rotate2D(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, -s, s, c);\n}\n\n// Get pattern numbers n1 and n2\nvoid getPatternNum(in float ID, out int n1, out int n2){\n    n1 = 3 + int(pow(hash(ID), 3.0) * 10.0); // range [3, 12]\n    n2 = int(4.0 / float(n1 - 2)) + 3 + int(pow(hash(ID * 1.1), 3.0) * 10.0);\n}\n\n// Prepare for Hyperbolic Tessellation\nvoid prepare(in int n1, in int n2, out float a1, out float a2, out float radius, out vec2 center){\n    a1 = PI / float(n1); // Angle between line L1 and L2\n    a2 = PI / float(n2); // Angle of intersection between line L1 and circle C\n\n    float cosa2 = cos(a2);\n    float sina1 = sin(a1);\n    float coeff = 1.0 / sqrt(cosa2 * cosa2 - sina1 * sina1);\n    radius = sina1 * coeff; // Radius of circle C used for inversion\n    center = vec2(cosa2 * coeff, 0.0); // Center of circle C used for inversion\n}\n\n// Implement Hyperbolic Tessellation with stochastic elements\nvec2 cartesianToPolar(vec2 p) {\n    return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 polarToCartesian(vec2 polar) {\n    return polar.x * vec2(cos(polar.y), sin(polar.y));\n}\n\nvec2 tessellate(in vec2 p, in float a1, in float a2, in float radius, in vec2 center){\n    float p2 = dot(p, p);\n    if(p2 > 1.0){\n        p /= p2; // Inversion about unit circle\n    }\n\n    float da1 = a1 * 2.0;\n    float cosda1 = cos(da1);\n    float sinda1 = sin(da1);\n    float tana1 = tan(a1);\n    float radius2 = radius * radius;\n\n    for(int j = 0; j < 40; j++){\n        vec2 ctop = p - center;\n        float ctop2 = dot(ctop, ctop);\n\n        // Add time-based motion to noise\n        vec2 noiseOffset = vec2(\n            noise(p * 5.0 + float(j) + iTime * 0.1),\n            noise(p * 10.0 + float(j) + iTime * 0.2)\n        ) * 0.1;\n        p += noiseOffset;\n\n        if(p.y > tana1 * p.x){\n            p *= mat2(cosda1, sinda1, sinda1, -cosda1); // Inversion about line L1\n        } else if(p.y < 0.0){\n            p.y = -p.y; // Inversion about line L2\n        } else if(ctop2 < radius2){\n            p = ctop * radius2 / ctop2 + center; // Inversion about circle C\n        } else {\n            break;\n        }\n    }\n\n    return p;\n}\n\n\n\n// HSV to custom color blend conversion\nvec3 hsvToCustomColor(float h, float s, float v) {\n    vec3 colorA = vec3(0.996, 0.345, 0.345); // Red-like color\n    vec3 colorB = vec3(0.631, 0.184, 0.173); // Darker red-like color\n\n    // Blend between colorA and colorB based on h (hue)\n    vec3 blendedColor = mix(colorA, colorB, fract(h));\n\n    // Adjust saturation and value\n    blendedColor = mix(vec3(1.0), blendedColor, s); // Apply saturation\n    return blendedColor * v;                        // Apply value (brightness)\n}\n\nvec3 hsv(in float h, in float s, in float v){\n    vec3 res = abs(fract(h + vec3(2.5, 1.0, 1.0) / 2.0) * 5.0 - 3.0);\n    res = clamp(res - 1.0, 0.0, 1.0);\n    return v * mix(vec3(1.0), res, s);\n}\n\n\n// Get height used for shading\nfloat getHeight(in vec2 p, in float radius, in vec2 center) {\n    float tmp = length(p - center) - radius;\n    return exp(-tmp * tmp * 60.0);\n}\n\nconst float layerInterval = 1.0;\nconst vec3 lightDir = normalize(vec3(0.5, 1.0, -0.5));\nconst vec3 background = vec3(0.0);\n\n// Raycasting and shading with stochastic tessellation\nvec3 render(in vec3 ro, in vec3 rd){\n    vec3 col = vec3(0.0);\n    \n    int n1;\n    int n2;\n    float ID;\n    float t;\n    float a1;\n    float a2;\n    float rotA;\n    float radius;\n    vec2 center;\n    vec2 pt;\n    vec3 rp;\n    \n    // Detect collision between ray and a plane cut out by a pattern.\n    bool hit = false;\n    for(int i = 0; i < 7; i++){\n        float z = ro.z / layerInterval;\n        float flz = floor(z);\n        ID = flz - float(i);\n        t = (ID * layerInterval - ro.z) / rd.z;\n        rp = ro + t * rd;\n        \n        getPatternNum(ID, n1, n2);\n        prepare(n1, n2, a1, a2, radius, center);\n        \n        // Apply stochastic rotation to the tessellation\n        rotA = 0.0;\n\n        pt = tessellate(rp.xy * rotate2D(rotA), a1, a2, radius, center);\n        \n        if(length(pt - center) < radius + 0.03){\n            hit = true;\n            break;\n        }\n    }\n    \n    // Perform shading\n    if(hit){\n        float ho = getHeight(pt, radius, center);\n        \n        vec2 eps = vec2(0.001, 0.0);\n        float hx = getHeight(tessellate((rp.xy + eps.xy) * rotate2D(rotA), a1, a2, radius, center), radius, center);\n        float hy = getHeight(tessellate((rp.xy + eps.yx) * rotate2D(rotA), a1, a2, radius, center), radius, center);\n        \n        vec3 normal = normalize(vec3(-(hx - ho)/eps.x, -(hy - ho)/eps.x, 1.0));\n        \n        float diff = max(dot(normal, lightDir), 0.0);\n        float spec = pow(max(dot(reflect(lightDir, normal), rd), 0.0), 10.0);\n        float metal = 0.6;\n        float lightPwr = 8.0;\n        float amb = 0.5;\n        \n        col = hsv(ID * PI * 2.5, 0.7, 1.0);\n        col *= diff * (1.0 - metal) * lightPwr + spec * metal * lightPwr + amb;\n    }\n    \n    float tmp = t / layerInterval;\n    col = mix(background, col, exp(-tmp * tmp * 0.2));\n    \n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float time = iTime * 0.1;\n    \n    // Camera setup\n    vec3 ro = vec3(0.0, 0.0, -5.0 + time);\n    vec3 rd = normalize(vec3(uv, 1.5));\n    \n    // Apply camera rotation\n    float angle = time * 0.1;\n    mat2 rot = rotate2D(angle);\n    ro.xy = rot * ro.xy;\n    rd.xy = rot * rd.xy;\n    \n    vec3 color = render(ro, rd);\n    \n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}