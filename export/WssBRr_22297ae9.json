{"ver":"0.1","info":{"id":"WssBRr","date":"1587610046","viewed":54,"name":"Alex Goodisman - Subsurface","username":"agoodisman","description":"Subsurface scattering - the light is above the sphere but some light is emitted out the front, through the sphere itself. The subsurface scattering does not change the light color, only the light amount.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["hw9"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int RAY_STEPS = 256;\n\n#define GI 1\n\nstruct Intersection\n{\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\n};\n    \nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\nvec3 rotateX(vec3 p, float amt) {\n    return vec3(p.x, cos(amt) * p.y - sin(amt) * p.z, sin(p.y) + cos(p.z));\n}\n\nvec3 rotateZ(vec3 p, float amt) {\n    \n    return vec3(cos(amt)* p.x - sin(amt)*p.y, cos(amt) * p.y + sin(amt) * p.x, p.z);\n}\n\n\nvoid raycast(vec2 uv, out vec3 dir, out vec3 eye, out vec3 ref) {\n    eye = vec3(0.0, 5.5, -20.0);\n    ref = vec3(0.0, 2.5, 0.0);\n    \n    float len = tan(3.14159 * 0.125) * distance(eye, ref);\n    vec3 H = normalize(cross(vec3(0.0, 1.0, 0.0), ref - eye));\n    vec3 V = normalize(cross(H, eye - ref));\n    V *= len;\n    H *= len * iResolution.x / iResolution.y;\n    vec3 p = ref + uv.x * H + uv.y * V;\n    dir = normalize(p - eye);\n}\n\nfloat sphere(vec3 p, float r, vec3 c)\n{\n    return distance(p, c) - r;\n}\n\nfloat torus(vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q) - t.y;\n}\n\nfloat cone(vec3 p, vec2 c)\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n// Box with side lengths b\nfloat box(vec3 p, vec3 b)\n{\n  return length(max(abs(p) - b, 0.0));\n}\n\nfloat plane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n\n\nvoid sceneMap3D(vec3 pos, out float t, out int obj, vec3 lightPos)\n{\n    t = plane(pos+vec3(5.0,2.5,0.0), vec4(1.0, 0.0, 0.0, 0.0));\n    float t2;\n    obj = 0; // 0 is center sphere\n    if((t2 = plane(pos+vec3(-5.0,2.5,0.0), vec4(-1.0, 0.0, 0.0, 0.0))) < t) {\n        t = t2;\n        obj = 1;\n    }\n    float t3;\n    if((t3 = plane(pos+vec3(0.0, -7.5, 0.0), vec4(0.0, -1.0, 0.0, 0.0))) < t) {\n        t = t3;\n        obj = 2;\n    }\n    float t4;\n    if((t4 = plane(pos+vec3(0.0,2.5,0.0), vec4(0.0,1.0,0.0,0.0))) < t) {\n    \tt = t4;\n        obj = 3;\n    }\n    float t5;\n    if((t5 = plane(pos+vec3(0.0,2.5,-5.0), vec4(0.0,0.0,-1.0,0.0))) < t) {\n        t = t5;\n        obj = 4;\n    }\n    float t7;\n    if((t7 = sphere(pos, 4.0, vec3(0.0,0.0,0.0))) < t) {\n        t = t7;\n        obj = 6;\n    }\n}\n\nfloat sceneMap3D(vec3 pos, vec3 lightPos)\n{\n    float t;\n    int obj;\n    sceneMap3D(pos, t, obj, lightPos);\n    return t;\n}\n\nvoid march(vec3 origin, vec3 dir, out float t, out int hitObj, vec3 lightPos)\n{\n    t = 0.001;\n    for(int i = 0; i < RAY_STEPS; ++i)\n    {\n        vec3 pos = origin + t * dir;\n    \tfloat m;\n        sceneMap3D(pos, m, hitObj, lightPos);\n        if(m < 0.01)\n        {\n            return;\n        }\n        t += m;\n    }\n    t = -1.0;\n    hitObj = -1;\n}\n\nvec3 computeNormal(vec3 pos, vec3 lightPos)\n{\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( sceneMap3D(pos + epsilon.yxx, lightPos) - sceneMap3D(pos - epsilon.yxx, lightPos),\n                            sceneMap3D(pos + epsilon.xyx, lightPos) - sceneMap3D(pos - epsilon.xyx, lightPos),\n                            sceneMap3D(pos + epsilon.xxy, lightPos) - sceneMap3D(pos - epsilon.xxy, lightPos)));\n}\n\nfloat subsurfaceColor(vec3 lightDir, vec3 normal, vec3 viewVec, float thin) {\n\tvec3 scatterDir = lightDir + normal * 0.1; // Last term is tunable\n\tfloat lightReachingEye = pow(clamp(dot(viewVec, -scatterDir),\n\t\t\t\t\t\t\t     0.0, 1.0), 0.8) * 3.0;\n\tfloat attenuation = max(0.0, dot(normal, lightDir)\n                             + dot(viewVec, -lightDir));\n\tfloat totalLight = (lightReachingEye);\n\treturn totalLight;\n}\n\n\nvec3 computeMaterial(int hitObj, vec3 p, vec3 n, vec3 light, vec3 view, vec3 lightPos) {\n    \n    float ao = 1.0;\n\n    for(int j = 1; j <= 5; j++)\n    {\n        ao -= (2.0 / pow(2.0, float(j))) * (float(j) * 0.15 - sceneMap3D(p + -n * float(j) * 0.15, lightPos)); \n    }\n    float subsurface = subsurfaceColor(normalize(lightPos - p), n, view, ao);\n    float t;\n    switch(hitObj) {\n        case 0:\n        // Red wall\n        vec3 color = vec3(0.63, 0.065, 0.05) * max(0.0, dot(n, light));\n        return color;\n        break;\n        case 1:\n        // Green wall\n        vec3 color2 = vec3(0.14, 0.45, 0.091) * max(0.0, dot(n, light));\n        return color2;\n        break;\n        \n        case 2:\n        case 3:\n        case 4:\n        case 5:\n        // floor\n        vec3 color3 = vec3(0.85, 0.81, 0.78) * max(0.0, dot(n, light));\n        return color3;\n        break;\n        \n        case 6: \n        vec3 color4 = vec3(1.0, 0.54, 0.47) * (max(0.0, dot(n, light)) + subsurface);\n        return color4;\n        break;\n        \n        \n        case -1:\n        // Background\n        return vec3(0.0);\n        break;\n    }\n    return vec3(1.0);\n}\n\nIntersection sdf3D(vec3 dir, vec3 eye, vec3 lightPos)\n{\n    float t;\n    int hitObj;\n    march(eye, dir, t, hitObj, lightPos);\n\n    vec3 isect = eye + t * dir;\n    vec3 nor = computeNormal(isect, lightPos);\n    vec3 lightDir = normalize(lightPos - isect);\n    \n    vec3 surfaceColor = computeMaterial(hitObj, isect, nor, lightDir, normalize(eye - isect), lightPos);\n    \n    \n    return Intersection(t, surfaceColor, isect, hitObj);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 lightPos = vec3(0.0, 7.45, 0.0);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // [-1, 1]\n    vec2 uv2 = 2.0 * uv - vec2(1.0);\n    \n    Intersection aaIsects[4];\n    vec3 dir, eye, ref;\n    int idx = 0;\n    for(float i = 0.0; i < 1.0; i += 0.5) {\n        for(float j = 0.0; j < 1.0; j += 0.5) {\n            raycast(uv2 + vec2(i, j) / iResolution.xy, dir, eye, ref);\n            aaIsects[idx++] = sdf3D(dir, eye, lightPos);\n        }\n    }\n    vec3 avgColor = vec3(0.0);\n    for(int i = 0; i < 4; ++i) {\n        avgColor += aaIsects[i].color;\n    }\n    avgColor *= 0.25;\n    fragColor = vec4(avgColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}