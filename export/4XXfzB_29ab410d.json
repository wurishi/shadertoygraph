{"ver":"0.1","info":{"id":"4XXfzB","date":"1728512110","viewed":22,"name":"CorruptionVoronoi","username":"ksastro","description":"voronoi","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["voronoi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision mediump float;\n\nuniform vec2 u_resolution;\nuniform float u_time;\nconst vec3 PATTERN_SHIFT = vec3(1252534.,943675.,715713.);\n\nvec3 paletteRainbow( float t ) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.0,0.33,0.67);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 paletteBlueMagenta( float t ) {\n    vec3 a = vec3(0.6, 0., 0.8);\n    vec3 b = vec3(0.4, 0., 0.2);\n    vec3 c = vec3(.5, .0, .5);\n    vec3 d = vec3(.5,0.,0.);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n} \n\nuint hashUint (in uint seed){ //murmur type of hash from https://t.ly/bKdP7\n    seed ^= seed >> 17;\n    seed *= 0xed5ad4bbU;\n    seed ^= seed >> 11;\n    seed *= 0xac4c1b51U;\n    seed ^= seed >> 15;\n    seed *= 0x31848babU;\n    seed ^= seed >> 14;\n    return seed;\n}\n\nuvec3 hashUint(in uvec3 seed){\n    return uvec3(hashUint(seed.x),hashUint(seed.y),hashUint(seed.z));\n}\n\n\nvec3 hashVec3(in vec3 seed){\n    uvec3 uintSeed = uvec3(seed + PATTERN_SHIFT.xyz);\n    uvec3 hashOnce = hashUint(uintSeed);\n    uvec3 hashTwice = hashUint(hashOnce + uintSeed.yzx);\n    vec3 hashTrice = vec3(hashUint(hashTwice + uintSeed.zxy));\n    return hashTrice / float(0xffffffffu);\n}\n\nvec4 voronoi3d(vec3 position){ //.xy is closest voronoi2d gridcell, .z is the distance to it\n    vec3 cellOrigin = floor(position); //cell where position is\n    vec3 positionRelative = fract(position);\n    vec3 cellOffset;    //Offset to the cell that is currently being calculated\n    vec3 pointOffset;   //Offset to the voronoi2d point in current cell\n    float dist;\n    vec4 result = vec4 (0., 0., 0., 1000.);\n    for(float x = -2.; x <= 2. ; x++){\n        for(float y = -2.; y <= 2.; y++){\n            for(float z = -2.; z <= 2.; z++){\n            cellOffset = vec3(x,y,z);\n            pointOffset = cellOffset + hashVec3(cellOffset + cellOrigin);\n            dist = length(positionRelative - pointOffset);\n            if (dist < result.w) (result = vec4(cellOffset + cellOrigin,dist));\n            }\n        }\n    }\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime * .3; //anim speed\n    vec2 uv = (fragCoord.xy * 2. - iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.,0.,.0);\n    uv *= 5.;\n    vec2 pavedUv = fract(uv);\n    vec4 voronoi3d = voronoi3d(vec3(uv+vec2(0.2*t),t));\n    float dist;\n    dist = voronoi3d.w;\n    \n    //col = 1.2*dist*paletteBlueMagenta(1.*dist);\n    col = paletteRainbow(.2)*0.15/dist;\n    \n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}