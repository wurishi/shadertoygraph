{"ver":"0.1","info":{"id":"mltGWH","date":"1682456670","viewed":139,"name":"boingfest 2d","username":"valalalalala","description":"This is a pretty straight ahead verlet integration model. \nStill quite some quirks, but so it goes, pretty happy with the pastel candy \"Trix\" look :-)          \n\nSpace bar will drop all the balls, relatable... You can drag the line endpoints around.","likes":10,"published":1,"flags":48,"usePreview":0,"tags":["2d","physics"],"hasliked":0,"parentid":"dtd3Wr","parentname":"physical balalalala"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"        //////////////////////////////////////////////////////////////////////\n       //                                                                 ////\n      // \"boingfest 2d\"                                                  // //\n     //                                                                 //  //\n    //  This is a pretty straight ahead verlet integration model.      //   //\n   //  There are still quite some quirks, but so it goes...           //    //\n  // I'm pretty happy with the pastel candy \"Trix\" look :-)          //     //\n //                                                                 //     //\n/////////////////////////////////////////////////////////////////////     //\n//                                                                 //    //\n// Creative Commons Attribution-NonCommercial-ShareAlike           //   //\n// 3.0 Unported License                                            //  //\n//                                                                 // //\n// by Val \"valalalalala\" GvM ðŸ’ƒ 2023                               ////\n//                                                                 ///\n/////////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 result, in vec2 st ){    \n    result = texelFetch(iChannel0, ivec2(st), 0);\n    result.w = EINS;\n}\n\n/////////////////////////////////////////////////////////////////////\n// party is at Buffer A's house\n/////////////////////////////////////////////////////////////////////","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/////////////////////////////////////////////////////////////////////\n//\n// This is a pretty straight ahead verlet integration model.\n//\n// It still has a number of problems which are likely to remain on the\n// todo list:\n//\n// - line test ignores radius\n// - line test is very temperamental\n// - line test updates position instead of \"impulse\"\n// - algorighthm features thrilling n^2 complexity\n//\n// I think adding code to break up the divisions spatially would be\n// neat (ala wdG3Wd).,\n//\n/////////////////////////////////////////////////////////////////////\n\nconst float COUNT      =  256.;\nconst float RADIUS     = .0136310;\nconst float GRAVITY    = -.00055000;\nconst float STEPS      = 8.;\nconst float DAMPENING  = .939;\nconst float BOUNCE     = .8;\nconst float LINE_COUNT = 3.;\n\nconst float SCALE      = EINS / STEPS;\nconst float DIAMETER   = 2. * RADIUS;\nconst float END_COUNT  = 2. * LINE_COUNT;\nconst float ENDPOINTS  = COUNT + EINS;\n\n/////////////////////////////////////////////////////////////////////\n\nvec4 fetch( in vec2 us, in sampler2D aShrubbery ) {\n    return texelFetch( aShrubbery, ivec2(us), 0 );\n}\n\nvec4 fetch( in vec2 st ) {\n    return fetch( st, iChannel0 );\n}\n\nvec4 mausHaus() {\n    return fetch( vec2( COUNT, ZED ) );\n}\n\nbool spaced() {\n    return .0 < fetch( vec2(32.,ZED), iChannel1 ).x;\n}\n\n/////////////////////////////////////////////////////////////////////\n\nvec2 initialBallPosition( in vec2 st ) {\n    return triangleHash2( st / COUNT * V101.zx + .4 * st );\n}\n\nvec4 initialEndpointPosition( int index ) {\n    float x = .075 + .17 * float( index );\n    float y = abs( x - HALB ) * HALB + .1441;\n    return vec4( x, y, V101.yy );\n}\n\n/////////////////////////////////////////////////////////////////////\n// physics simulation \n\nvec2 ballsAreTouching( in vec2 a, vec2 b ) {    \n    float d = length( a - b );\n    if ( d > DIAMETER ) return V101.yy;\n\n    vec2 midpoint = mix( a, b, HALB );\n    return normalize( a - midpoint ) * DIAMETER;\n}\n\nvec2 ballBuster( in float x, in vec2 now ) {\n    vec2 impulse = vec2( ZED );\n    \n    for ( float i = ZED ; i < COUNT ; i++ ) {\n        if ( HALB > i - x ) continue;\n        vec2 other = fetch( vec2( i, ZED ) ).xy;\n        impulse += ballsAreTouching( now, other );\n    }\n    \n    iMinnie;\n    if ( ms.x > ZED ) impulse += ballsAreTouching( now, ms );\n    \n    return impulse;\n}\n\n#define UPDATE_POS 1\nvec2 lineOfAttack( in vec2 now, in vec2 old ) {\n    vec2 impulse = vec2( ZED );\n    \n    #if 0\n    // was not able to account for the radius like this...\n    vec2 on = normalize( now - old );\n    vec2 tnow = now + on * RADIUS;\n    vec2 told = old - on * RADIUS;\n    old = told;\n    #endif\n\n    for ( float l = ZED ; l < END_COUNT ; l += 2. ) {\n        vec2 a = fetch( vec2( l + ENDPOINTS + ZED,  ZED ) ).xy;\n        vec2 b = fetch( vec2( l + ENDPOINTS + EINS, ZED ) ).xy;\n        \n        vec2 ab = normalize( b - a );\n\n        vec3 hit = intersectLines( a, b, old, now ); \n        if ( hit.z < ZED ) continue;\n        \n            vec2 d = normalize( hit.xy - old );\n            vec2 n = normalize( b - a ).yx * V101.zx; \n\n            vec2 r = reflect( d, n );\n            vec2 p = hit.xy + r * RADIUS * 1.; // not quite right\n            \n            //impulse -= p - now;\n            impulse += r * RADIUS * 1.5;\n#if UPDATE_POS            \n            now = mix( now, p, DAMPENING );\n            //now = p;\n            //vec2 diff = p - now;\n            //float dl = length( diff );\n            //now += normalize( diff ) * min( dl, RADIUS * 1. );\n#endif\n    }\n\n#if UPDATE_POS\n    return now;\n#endif  \n        \n    return impulse;\n}\n\nvec2 boundo( in vec2 now ) {\n    return clamp( now, vec2( RADIUS ), RZ.xy-RADIUS ) - now;\n}\n\nvec4 verletStep( float x, vec2 now, vec2 old ) {\n    vec2 impulse = vec2( ZED );   \n    \n#if UPDATE_POS\n    // can't get it to work just updating the \"impulse\"\n    now = lineOfAttack( now, old ); \n#else\n    impulse += lineOfAttack( now, old ); \n#endif\n\n    impulse += ballBuster( x, now );\n    impulse += boundo( now );\n                \n    // BRRR...\n    if ( dot(impulse,impulse) < .033 ) impulse *= .1;        \n                \n    return vec4( impulse, now );\n}\n\nvec4 simulation( in vec2 st ) {\n    vec4 last = fetch( st );\n    \n    vec2 now = last.xy;\n    vec2 old = last.zw;\n    \n    if ( ZED == dot( last, last ) ||  spaced() ) {\n        now = old = initialBallPosition( st.xx  );\n    }\n    \n    vec2 b4 = now;\n\n    old.y -= GRAVITY;\n    now += ( now - old ) * DAMPENING;\n    \n    // jiggle-jiggly constraint enforcement        \n    for( float s = ZED ; s < STEPS ; s++  ) {\n        vec4 v = verletStep( st.x, now, b4 ); \n        now = v.zw; // :-(\n        now += v.xy * SCALE * DAMPENING;\n    }\n\n    return vec4( now, b4 );   \n}\n\n/////////////////////////////////////////////////////////////////////\n// drag and drop \n\nvec4 enders( in vec2 st ) {\n    vec4 last = fetch( st );\n    int index = int( st.x - ENDPOINTS ) + 1;\n    \n    if ( iFrame < 10 || ZED == dot( last, last ) ) {\n        last = initialEndpointPosition( index - 1 );\n    }\n    \n    vec4 maus = mausHaus();\n    int it = int( maus.z * END_COUNT );\n    \n    // update if selected in mauslein \n    // and mouse is still down\n    \n    iMinnie;\n    if ( it == index && sign( ms.x ) > ZED ) {\n        last.xy = ms.xy;\n    }\n    \n    return last;\n}\n\nvec4 mauslein( in vec2 st ) {\n    vec4 maus = mausHaus(); // da ich bin\n    \n    iMinnie;\n    if ( ms.x < ZED ) {\n        return maus * V101.yyyy;\n    }\n    \n    // already selected an index\n    \n    if ( maus.z > EPSILON ) return maus;\n    \n    // find closest endpoint\n    \n    vec2 closest = mino();\n\n    for ( float i = ZED ; i < END_COUNT ; i++ ) {            \n        vec2 ball = fetch( vec2( ENDPOINTS + i, ZED ) ).xy;        \n        closest = mino( closest, ball, ms, RADIUS, i + EINS );\n    }\n  \n    // scale the index (0 indicates a miss)\n    \n    maus.z = max( ZED, closest.y / END_COUNT );\n    \n    return maus;\n}\n\n/////////////////////////////////////////////////////////////////////\n// drawing code\n\nvec4 presentation( in vec2 st ) {\n    vec2 uv = pixelToUv( st, RZ.xy );\n    vec2 closest = mino();\n    \n    // check your balls\n        \n    for ( float i = ZED ; i < COUNT ; i++ ) {\n       vec2 ball = fetch( vec2( i, ZED ) ).xy;\n       closest = mino( closest, ball, uv, RADIUS, i );\n    }\n    \n    // walk the lines\n    \n    for ( float l = ZED ; l < END_COUNT ; l += 2. ) {\n        vec2 a = fetch( vec2( l + ENDPOINTS + ZED,  ZED ) ).xy;\n        vec2 b = fetch( vec2( l + ENDPOINTS + EINS, ZED ) ).xy;\n        vec3 p = onLine( uv, a, b );\n\n        closest = mino( closest, a, uv, RADIUS * HALB, l * 33. );\n        closest = mino( closest, b, uv, RADIUS * HALB, l * 88. );        \n        closest = mino( closest, p.xy, uv, RADIUS * HALB * HALB, 222. * p.z );\n    }    \n\n    // background color\n    \n    if ( closest.y < ZED ) {\n        return colorF( -uv.y * 9.9 + 99.99 ).rgbr * .22 + .11;\n    }\n    \n    // foreground color\n    \n    vec2 v = closest / vec2( RADIUS, COUNT );\n        \n    vec3 c = colorF( v.y * 7.7 );\n    c = .11 + .88 * mix( c, c * .11,  v.x );\n    c = mix( c, V101.yyy, step( .77, v.x ) );\n    \n    return vec4( c , EINS );\n}\n\n/////////////////////////////////////////////////////////////////////\n// demo and main\n\nvec4 demo( in vec2 st ) {    \n    if ( EINS > st.y ) {\n        if ( st.x < COUNT ) return simulation( st );\n        if ( st.x < ENDPOINTS ) return mauslein( st );\n        if ( st.x < ENDPOINTS + END_COUNT ) return enders( st );         \n    }\n    return presentation( st );\n}\n\nvoid mainImage( out vec4 result, in vec2 st ) {   \n    result = demo( st );\n}\n\n/////////////////////////////////////////////////////////////////////\n//\n// BTW, here are some other things that are pretty cool!\n//\n// https://www.shadertoy.com/view/XdtSWn ... heh!\n// https://www.shadertoy.com/view/MtSXR1\n// https://www.shadertoy.com/view/MdXBD8\n// https://www.shadertoy.com/view/MldXWX\n// https://www.shadertoy.com/view/Msy3WD\n// https://www.shadertoy.com/view/wdG3Wd\n// https://www.shadertoy.com/view/lsy3R1\n// https://www.shadertoy.com/view/tstSz7\n// https://www.shadertoy.com/view/llXXz4\n// https://www.shadertoy.com/view/XlfyzN\n// https://www.shadertoy.com/view/llyBDW\n// https://www.shadertoy.com/view/lsG3Wd\n// https://www.shadertoy.com/view/lt3Xz7\n// https://www.shadertoy.com/view/XsyGDc\n//\n/////////////////////////////////////////////////////////////////////","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"////////////////////////////////////////////////////////////////////////////////////\n\nconst float TAU = 99733. / 15873., ZED = .0, HALB = .5, EINS = 1., PI  = HALB * TAU;\nconst vec3 V101 = vec3( -EINS, ZED, +EINS );\nconst float EPSILON = .001, ZFAR = 199., VIEW_DISTANCE = 5.5;\n\n#define RZ iResolution\n\n////////////////////////////////////////////////////////////////////////////////////\n\n#define SCALE_AND_OFFSET(v,o)   (o + (v * o)) \n\n////////////////////////////////////////////////////////////////////////////////////\n\nvec2 pixelToUv( vec2 st, vec2 resolution ) {\n    return st / max( resolution.x, resolution.y );\n}\n\nfloat modScale( float f, float s ) {\n    return mod( f, s ) / s;\n}\n\n#define cost( x ) triangle( x )\n#define tcos( x ) triangle( x + TAU * .25 )\n#define sint( x ) triangle( x + TAU * .75 )\nfloat triangle( float x ) {\n    return 4. * abs( modScale( x, TAU ) - .5 ) -1.;\n}\n \nvec3 colorF( float f ) {\n    return SCALE_AND_OFFSET( vec3( cost( f ), tcos( f ), sint( f ) ), .5 );\n}\n\n/////////////////////////////////////////////////////////////////////\n\n#define iMinnie vec2 ms = pixelToUv( minnie( iMouse ), iResolution.xy )\nvec2 minnie( in vec4 mouse ) {\n    return mix( V101.xx, mouse.xy, step( EPSILON, max( mouse.z, mouse.w ) ) );\n}\n\n/////////////////////////////////////////////////////////////////////\nconst vec3 MAGIC = vec3( TAU * 3.3, 99.733, 15873. );\n\nfloat magicFloat( vec2 uv ) {\n    return dot( uv, MAGIC.xy );\n}\n\nfloat triangleHash( float f ) {\n    return fract( triangle( f * MAGIC.x ) * f * MAGIC.z * .133 );\n}\n\nfloat triangleHash( vec2 uv ) { \n    return triangleHash( magicFloat( uv ) );\n}\n\nvec2 triangleHash2( vec2 uv ) {\n    return vec2( triangleHash( uv.x ), triangleHash( uv.y ) );\n}\n\n/////////////////////////////////////////////////////////////////////\n\nvec2 mino() {\n    return vec2( 3e3, -EINS );\n}\n\nvec2 mino( in vec2 closest, in vec2 test ) {\n    return mix( closest, test, step( test.x, closest.x ) );\n}\n\nvec2 mino( in vec2 closest, in vec2 test, in float threshold ) {\n    return mix( closest, mino( closest, test ), step( test.x, threshold ) );\n}\n\nvec2 mino( in vec2 closest, in vec2 a, in vec2 b, in float threshold, in float y ) {\n    return mino( closest, vec2( distance( a, b ), y ), threshold );\n}\n\n/////////////////////////////////////////////////////////////////////\n\nfloat cross2(vec2 a, vec2 b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nvec3 intersectLines( in vec2 start1, in vec2 end1, in vec2 start2, in vec2 end2 ) {\n    vec2 dir1 = end1 - start1;\n    vec2 dir2 = end2 - start2;\n\n    float det = determinant(mat2(dir1,dir2));\n    \n    // maybe this is sketchy...\n    if (abs(det) < EPSILON * EPSILON * EPSILON ) {\n        return vec3(-1.);\n    }\n    \n    vec2 v = start2 - start1;\n    \n    float t1 = cross2(v, dir2) / det;\n    float t2 = cross2(v, dir1) / det;\n    \n    if (t1 < .0 || t1 > 1. || t2 < .0 || t2 > 1. ) {\n        return vec3(-1.);\n    }\n    \n    vec2 intersectionPoint = start1 + t1 * dir1;\n    // idk... float t = dot(intersectionPoint - start2, dir2) / dot(dir2, dir2);\n    \n    return vec3(intersectionPoint, t2);\n}\n\nvec3 onLine( in vec2 uv, in vec2 a, in vec2 b ) {\n    vec2 ab = b - a;\n    float t = clamp(dot(uv - a, ab) / dot(ab, ab), .0, 1.); \n    return vec3( a + ab * t, t);\n}\n\n/////////////////////////////////////////////////////////////////////","name":"Common","description":"","type":"common"}]}