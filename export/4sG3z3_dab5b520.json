{"ver":"0.1","info":{"id":"4sG3z3","date":"1455509318","viewed":509,"name":"Edge Detect (fixed)","username":"ming","description":"The original Edge Detect shader was created by mu6k (be found at https://www.shadertoy.com/view/4s23WV#).\nThis fork fixed the compile errors caused by ShaderToy update.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","edge","derivative","toon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*by musk License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\tDerivative based edge detection. \n\tdFdx() and dFdy() are applied to the surface normal. \n\tIt will detect discontinuities in the normal.\n\n*/\n\n//functions that build rotation matrixes\nmat2 rotate_2D(float a){float sa = sin(a); float ca = cos(a); return mat2(ca,sa,-sa,ca);}\nmat3 rotate_x(float a){float sa = sin(a); float ca = cos(a); return mat3(1.,.0,.0,    .0,ca,sa,   .0,-sa,ca);}\nmat3 rotate_y(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,.0,sa,    .0,1.,.0,   -sa,.0,ca);}\nmat3 rotate_z(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,sa,.0,    -sa,ca,.0,  .0,.0,1.);}\n\nfloat t()\n{\n    return iTime - 4.0;\n}\nfloat df_back(vec3 p)\n{\n\treturn (16.0-length(p));\n}\n\nmat3 rot()\n{\n    return rotate_x(t()*.5)*rotate_y(t()*.5)*rotate_z(t()*.5);\n}\nvec3 trans()\n{\n    return vec3(sin(t()),cos(t()),sin(t()))*.1;\n}\n\n//2D texture based 3 component 1D, 2D, 3D noise\nvec3 noise(float p){return texture(iChannel0,vec2(p/iChannelResolution[0].x,.0)).xyz;}\nvec3 noise(vec2 p){return texture(iChannel0,p/iChannelResolution[0].xy).xyz;}\nvec3 noise(vec3 p){float m = mod(p.z,1.0);float s = p.z-m; float sprev = s-1.0;if (mod(s,2.0)==1.0) { s--; sprev++; m = 1.0-m; };return mix(texture(iChannel0,p.xy/iChannelResolution[0].xy+noise(sprev).yz).xyz,texture(iChannel0,p.xy/iChannelResolution[0].xy+noise(s).yz).xyz,m);}\n\nvec3 noise(float p, float lod){return texture(iChannel0,vec2(p/iChannelResolution[0].x,.0),lod).xyz;}\nvec3 noise(vec2 p, float lod){return texture(iChannel0,p/iChannelResolution[0].xy,lod).xyz;}\nvec3 noise(vec3 p, float lod){float m = mod(p.z,1.0);float s = p.z-m; float sprev = s-1.0;if (mod(s,2.0)==1.0) { s--; sprev++; m = 1.0-m; };return mix(texture(iChannel0,p.xy/iChannelResolution[0].xy+noise(sprev,lod).yz,lod).xyz,texture(iChannel0,p.xy/iChannelResolution[0].xy+noise(s,lod).yz,lod).xyz,m);}\n\n\nfloat df_obj(vec3 p)\n{\n\tp += trans();\n\tp *= rot();\n\t\n\t//p = mod(p+vec3(2.0),4.0)-vec3(2.0);\n\tfloat s0 = dot(abs(p),vec3(1.0))-1.5;\n\ts0*=.5;\n\t\n\t//p*=rot;\n\t\n\tfloat s1 = length(p+vec3(1.,.0,.0))-.5;\n\tfloat s2 = length(p+vec3(.0,1.,.0))-.5;\n\tfloat s3 = length(p+vec3(.0,.0,1.))-.5;\n\tfloat s4 = length(p-vec3(1.,.0,.0))-.5;\n\tfloat s5 = length(p-vec3(.0,1.,.0))-.5;\n\tfloat s6 = length(p-vec3(.0,.0,1.))-.5;\n\ts0 = min(s0,s1);\n\ts0 = min(s0,s2);\n\ts0 = min(s0,s3);\n\ts0 = max(s0,-s4);\n\ts0 = max(s0,-s5);\n\ts0 = max(s0,-s6);\n\t\n\tp*=rot();\n\t\n\ts0 = min(s0,max(max(abs(p.x+2.0),abs(p.y)),abs(p.z))-.25);\n\ts0 = min(s0,max(max(abs(p.x-2.0),abs(p.y)),abs(p.z))-.25);\n\ts0 = min(s0,max(max(abs(p.y+2.0),abs(p.z)),abs(p.x))-.25);\n\ts0 = min(s0,max(max(abs(p.y-2.0),abs(p.z)),abs(p.x))-.25);\n\ts0 = min(s0,max(max(abs(p.z+2.0),abs(p.x)),abs(p.y))-.25);\n\ts0 = min(s0,max(max(abs(p.z-2.0),abs(p.x)),abs(p.y))-.25);\n\t\n\tp*=rot();\n\t\n\ts0 = min(s0,max(max(abs(p.x+4.0),abs(p.y)),abs(p.z))-.25);\n\ts0 = min(s0,max(max(abs(p.x-4.0),abs(p.y)),abs(p.z))-.25);\n\ts0 = min(s0,max(max(abs(p.y+4.0),abs(p.z)),abs(p.x))-.25);\n\ts0 = min(s0,max(max(abs(p.y-4.0),abs(p.z)),abs(p.x))-.25);\n\ts0 = min(s0,max(max(abs(p.z+4.0),abs(p.x)),abs(p.y))-.25);\n\ts0 = min(s0,max(max(abs(p.z-4.0),abs(p.x)),abs(p.y))-.25);\n\t\n\treturn s0;\n}\n\n\nfloat df(vec3 p)\n{\n\treturn min(df_obj(p),df_back(p));\n}\n\n\nvec3 nf(vec3 p)\n{\n\tfloat e = .01;\n\tfloat dfp = df(p);\n\treturn vec3(\n\t\t(dfp+df(p+vec3(e,.0,.0)))/e,\n\t\t(dfp+df(p+vec3(.0,e,.0)))/e,\n\t\t(dfp+df(p+vec3(.0,.0,e)))/e);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n\tuv.x *= iResolution.x/iResolution.y;\n\t\n\tvec2 mouse = iMouse.xy/ iResolution.xy*2.0-1.0;\n\tmouse.x *= iResolution.x/iResolution.y*4.0;\n\t\n\tmat3 rotmat = rotate_y(mouse.x) * rotate_x(mouse.y);\n\t\n\tvec3 pos = vec3(.0,.0,-3.0)*rotmat ;\n\tvec3 dir = normalize(vec3(uv*.5,1.0-length(uv)*.25))*rotmat;\n\t\n\tvec3 light_dir = normalize(vec3(.4,.5,.6));\n\tvec3 light_color = vec3(.6,.5,.4);\n\t\n\tfloat dist;\n\t\n\tfor (int i=0; i<80; i++)\n\t{\n\t\tdist = df(pos);\n\t\tpos+=dir*dist;\n\t\tif (dist<.00001) break;\n\t}\n\n\tvec3 color = vec3(1.0);\n\tvec3 n = nf(pos);\n\t\n\tvec3 dfdxn = dFdx(n);\n\tvec3 dfdyn = dFdy(n);\n\t\n\tfloat lines = length((abs(dfdxn)+abs(dfdyn))*3.0);\n\tlines = lines*3.75;\n\tlines = lines-1.0;\n\tlines = clamp(lines,.0,1.0);\n\tif (lines>1.0)lines = 1.0;\n\t\n\tif (length(pos)>5.0)\n\t{\n\t\tcolor = vec3(1.0);\n\t}\n\telse\n\t{\n\t\tfloat oa = 0.5;//df(pos+n)*.5+.5;\n\t\tfloat od = 1.0;\n\t\t\n\t\tfor (int i=0; i<30; i++)\n\t\t{\n\t\t\tfloat fi = float(i);\n\t\t\toa += df_obj(pos+noise(fi)-vec3(.5))*.15;\n\t\t}\n\t\t\n\t\toa = min(1.0,oa);\n\t\t\n\t\tvec3 ocdir = light_dir;\n\t\tvec3 ocpos = pos+ocdir*.1;\n\t\tfor (int i=0; i<60; i++)\n\t\t{\n\t\t\tfloat dist = df_obj(ocpos);\n\t\t\tod = min(od,dist*10.);\n\t\t\tocpos += ocdir*dist*.3;\n\t\t\tif (dist<.0||dist>10.0) break;\n\t\t}\n\t\t\n\n\t\tod = max(.0,od);\n\t\t\n\t\t//oa -= mod(oa,.33);\n\t\t\n\t\tfloat diffuse = max(.0,dot(n,light_dir)*.8+.2)*od*oa*1.5;\n\t\n\n\t\t\n\t\tcolor = vec3(.1,.2,.3)*oa + diffuse*light_color;\n\t\t\n\t\n\t}\n\t\n\tvec3 color0 = mix(color,vec3(.0),lines);\n\tvec3 color1 = n*.4+.4;\n\tvec3 color2 = dfdxn+dfdyn;\n\tvec3 color3 = vec3(lines);\n\t\n\tfloat mt = mod(t(),32.0);\n\tfloat mti = mod(t(),1.0);\n\t\n\tif (mt<7.0){color = color0;}\n\telse if (mt<8.0){color = mix(color0,color1,mti);}\n\telse if (mt<11.0){color = color1;}\n\telse if (mt<12.0){color = mix(color1,color2,mti);}\n\telse if (mt<13.0){color = color2;}\n\telse if (mt<14.0){color = mix(color2,color3,mti);}\n\telse if (mt<18.0){color = color3;}\n\telse if (mt<19.0){color = mix(color2,color1-color3,mti);}\n\telse if (mt<24.0){color = color1-color3;}\n\telse if (mt<25.0){color = mix(color1-color3,color,mti);}\n\telse if (mt<29.0){;}\n\telse if (mt<30.0){color = mix(color,color0,mti);}\n\telse if (mt<32.0){color = color0;}\n\t\n\tcolor += noise(vec3(fragCoord.xy,t()*60.0))*0.01;\n\t\n\t\n\t\n\tfragColor = vec4(pow(color,vec3(.5)),1.0);\n}","name":"Image","description":"","type":"image"}]}