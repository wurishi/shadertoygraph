{"ver":"0.1","info":{"id":"7lyXRW","date":"1640256875","viewed":70,"name":"bayi_logo","username":"bayi","description":"trial","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\nmat2 Rot(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat mysmooth(float a, float b, float k)\n{\n    float h = clamp(0.5+0.5*(b-a)/k, 0., 1.);\n    return mix(b, a, h) - k*h*(1.0 - h);\n}\n\nfloat opSmoothIntersection( float d1, float d2, float k )\n{\n    float h = max(k-abs(d1-d2),0.0);\n    return max(d1, d2) + h*h*0.25/k;\n\t//float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n\t//return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\nfloat Capsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    \n    float t = dot(ab, ap)/dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    vec3 c = a + t*ab;\n    return length(p-c) - r;\n}\n\nfloat Torus(vec3 p, vec2 r)\n{\n    float x = length(p.xz)- r.x;\n    return length(vec2(x,p.y)) -r.y;\n}\n\nfloat Box(vec3 p, vec3 s)\n{\n    return length(max(abs(p) -s, 0.));\n}\n\nfloat GetDist(vec3 p)\n{\n    float cd1 = Capsule(p,vec3(5.5,-2,0), vec3(5.5, 2, 0), .3);\n    vec3 tp1 = p-vec3(4.5, -1, 0);\n    tp1.yz *= Rot(-1.57);\n    float td1 = Torus(tp1, vec2(.95, .3));\n    float aa1 = mysmooth(cd1,td1,0.06);\n    \n    \n    vec3 tp2 = p-vec3(1, -1, 0);\n    tp2.yz *= Rot(-1.57);\n    float td2 = Torus(tp2, vec2(.95, .3));\n    float cd5 = Capsule(p,vec3(0,-2,0), vec3(0, 0, 0), .3);\n    float aa2 = mysmooth(td2,cd5,0.06);\n    \n    \n    float cd3 = Capsule(p,vec3(-1.5,0,0), vec3(-2.5, -1.9, 0), .3);\n    float cd4 = Capsule(p,vec3(-3.5,0,0), vec3(-1.5, -4, 0), .3);\n    float aa3 = mysmooth(cd4,cd3,0.06);\n    \n    \n    float cd2 = Capsule(p,vec3(-5,-2,0), vec3(-5, 0, 0), .3);\n    vec4 s1 = vec4(-5,1,0,.3);\n    vec3 sp1 = p-s1.xyz;\n    float sd1 = length(sp1) - s1.w;\n    float aa4 = min(cd2, sd1);\n    \n    \n    vec3 fp1 = p - vec3(0, -1, 0);\n    float ff1 = Box(fp1,vec3(6, 4, .1));\n    float ff2 = min(aa1,aa2);\n    ff2 = min(ff2,aa3);\n    ff2 = min(ff2,aa4);\n    ff1 = opSmoothIntersection(ff2,ff1,.14)-0.01;\n    \n\n    float pd = p.y + 5.;\n    ff1 = min(ff1,pd);\n    \n    return ff1;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n    float dO = 0.;\n    for(int i=0; i<MAX_STEPS; i++)\n    {\n        vec3 p = ro + rd*dO;\n        float ds = GetDist(p);\n        dO += ds;\n        if(dO>MAX_DIST || ds<SURF_DIST) break;\n    }\n    return dO;\n}\n\nvec3 GetNormal(vec3 p)\n{\n    float d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    vec3 n = d - vec3(\n        GetDist(p - e.xyy),\n        GetDist(p - e.yxy),\n        GetDist(p - e.yyx));\n    return normalize(n);\n}\n\nfloat GetLight(vec3 p)\n{\n    //vec3 lightPos = vec3(3, 5, 4);\n    vec3 lightPos = vec3(0, 5, 6);\n    lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 l = normalize(lightPos - p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n,l), 0., 1.);\n    float d = RayMarch(p + n*SURF_DIST*2.,l);\n    if(d<length(lightPos - p)) dif *= .1;\n    return dif;\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec3 Bg(vec3 rd) {\n\tfloat k = rd.y*.5+.5;\n    \n    vec3 col = mix(vec3(.2, .1, .1), vec3(.2, .5, 1), k);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 ro = vec3(0, 9, -6);\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    \n\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec3 col = vec3(0);\n    \n    \n    float d = RayMarch(ro,rd);\n    vec3 p = ro + rd * d;\n    vec3 n = GetNormal(p);\n    vec3 r = reflect(rd, n);\n    float spec = pow(max(0., r.y), 30.);\n    \n    float dif = GetLight(p);\n\n    col = mix(Bg(r), vec3(dif)*vec3(.8,.8,1), .5)+spec;\n    \n    \n    fragColor = vec4(col*1.2,1.0);\n}","name":"Image","description":"","type":"image"}]}