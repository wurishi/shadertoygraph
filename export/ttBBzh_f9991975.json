{"ver":"0.1","info":{"id":"ttBBzh","date":"1598289039","viewed":114,"name":"Encaged","username":"Vectornaut","description":"One of my ray-marching practice projects from the CODAME shaders workshops, Aprilâ€“May 2020. The five platonic solids are scaled to interlock as described in the summary comments. (Updated September 2021 to improve the antialiasing.)","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","polyhedra","codame"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// in this demo, the five platonic solids are scaled to interlock as follows.\n// - the dodecahedron encages the icosahedron\n// - the icosahedron encages the tetrahedron and the cube\n// - the intersection of the cube and the dodecahedron encages the octahedron\n\n// --- euler angles ---\n\nmat3 rot_xy(float t) {\n    return mat3(\n         cos(t), sin(t), 0.0,\n        -sin(t), cos(t), 0.0,\n            0.0,    0.0, 1.0\n    );\n}\n\nmat3 rot_yz(float t) {\n    return mat3(\n        1.0,     0.0,    0.0,\n        0.0,  cos(t), sin(t),\n        0.0, -sin(t), cos(t)\n    );\n}\n\n// attitude = vec3(precession, nutation spin)\nmat3 euler_rot(vec3 attitude) {\n    return rot_xy(attitude[0]) * rot_yz(attitude[1]) * rot_xy(attitude[2]);\n}\n\n// --- augmented signed distances ---\n\nstruct aug_dist {\n    float dist;\n    vec3 normal;\n    vec3 color;\n};\n\naug_dist dmin(aug_dist a, aug_dist b) {\n    if (a.dist < b.dist) return a; else return b;\n}\n\naug_dist dmax(aug_dist a, aug_dist b) {\n    if (a.dist > b.dist) return a; else return b;\n}\n\n// --- polyhedra ---\n\nvec3 msign(vec3 v) {\n    return vec3(\n        v.x > 0. ? 1. : -1.,\n        v.y > 0. ? 1. : -1.,\n        v.z > 0. ? 1. : -1.\n    );\n}\n\nfloat argmax(vec3 v) {\n   return max(v.x, max(v.y, v.z));\n}\n\naug_dist plane_sdf(vec3 p, vec3 normal, float offset, vec3 color) {\n    return aug_dist(\n        dot(p, normal) - offset,\n        normal,\n        color\n    );\n}\n\nconst float pi = 3.141592653589793;\nconst float sqrt3 = sqrt(3.);\n\n// tetrahedron\naug_dist tetra_sdf(vec3 p_scene, float inradius, vec3 color) {\n    vec3 attitude = vec3(1./(2.+pi), 1./pi, 1./2.) * vec3(iTime);\n    mat3 orient = euler_rot(attitude);\n    vec3 p = p_scene * orient; // = transpose(orient) * p_scene\n    \n    // write down normals\n    vec3 normals [4];\n    normals[0] = vec3(-1., -1., -1.) / sqrt3;\n    normals[1] = vec3(-1.,  1.,  1.) / sqrt3;\n    normals[2] = normals[1].zxy;\n    normals[3] = normals[2].zxy;\n    \n    // find the side closest to p\n    aug_dist dist =  plane_sdf(p, normals[0], inradius, color);\n    for (int j = 1; j < 4; j++) {\n        dist = dmax(dist, plane_sdf(p, normals[j], inradius, color));\n    }\n    dist.normal = orient * dist.normal;\n    return dist;\n}\n\n// cube. inspired by Inigo Quilez's box SDF,\n//\n//   https://iquilezles.org/articles/distfunctions\n//   https://iquilezles.org/articles/boxfunctions\n//\n// but different. in particular, this one is only a bound\naug_dist cube_sdf(vec3 p_scene, float inradius, vec3 color) {\n    vec3 attitude = vec3(1./(2.+pi), 1./pi, 1./2.) * vec3(iTime);\n    mat3 orient = euler_rot(attitude);\n    vec3 p = p_scene * orient; // = transpose(orient) * p_scene\n    \n    vec3 p_abs = abs(p);\n    vec3 normal = msign(p) * vec3(\n        p_abs.x >= p_abs.y && p_abs.x >= p_abs.z ? 1. : 0.,\n        p_abs.y >= p_abs.z && p_abs.y >= p_abs.x ? 1. : 0.,\n        p_abs.z >= p_abs.x && p_abs.z >= p_abs.y ? 1. : 0.\n    );\n    \n    return aug_dist(\n        argmax(p_abs - vec3(inradius)),\n        orient * normal,\n        color\n    );\n}\n\n// octahedron\naug_dist octa_sdf(vec3 p_scene, float inradius, vec3 color) {\n    vec3 attitude = vec3(1./(2.+pi), 1./pi, 1./2.) * vec3(iTime);\n    mat3 orient = euler_rot(attitude);\n    vec3 p = p_scene * orient; // = transpose(orient) * p_scene\n    \n    // take the side normal in the positive orthant\n    vec3 normal = vec3(1.) / sqrt3;\n    \n    // reflect it into the orthant of p\n    normal *= msign(p);\n    \n    // now it's the normal of the side closest to p\n    aug_dist dist = plane_sdf(p, normal, inradius, color);\n    dist.normal = orient * dist.normal;\n    return dist;\n}\n\nconst float phi = (1.+sqrt(5.))/2.;\nconst float hyp = sqrt(2.+phi); // = sqrt(1+phi^2)\n\n// dodecahedron\naug_dist dodeca_sdf(vec3 p_scene, float inradius, vec3 color) {\n    vec3 attitude = vec3(1./(2.+pi), 1./pi, 1./2.) * vec3(iTime);\n    mat3 orient = euler_rot(attitude);\n    vec3 p = p_scene * orient; // = transpose(orient) * p_scene\n    \n    // take the side normals in the positive orthant\n    vec3 normals [3];\n    normals[0] = vec3(0., 1., phi) / hyp;\n    normals[1] = normals[0].zxy;\n    normals[2] = normals[1].zxy;\n    \n    // reflect them into the orthant of p\n    for (int k = 0; k < 3; k++) {\n        normals[k] *= msign(p);\n    }\n    \n    // now, one of them is the normal of the side closest to p\n    aug_dist dist =  plane_sdf(p, normals[0], inradius, color);\n    dist = dmax(dist, plane_sdf(p, normals[1], inradius, color));\n    dist = dmax(dist, plane_sdf(p, normals[2], inradius, color));\n    dist.normal = orient * dist.normal;\n    return dist;\n}\n\n// icosahedron\naug_dist icosa_sdf(vec3 p_scene, float inradius, vec3 color) {\n    vec3 attitude = vec3(1./(2.+pi), 1./pi, 1./2.) * vec3(iTime);\n    mat3 orient = euler_rot(attitude);\n    vec3 p = p_scene * orient; // = transpose(orient) * p_scene\n    \n    // take the side normals in the positive orthant\n    vec3 normals [4];\n    normals[0] = vec3(1.) / sqrt3;\n    normals[1] = vec3(0., phi-1., phi) / sqrt3;\n    normals[2] = normals[1].zxy;\n    normals[3] = normals[2].zxy;\n    \n    // reflect them into the orthant of p\n    for (int k = 0; k < 4; k++) {\n        normals[k] *= msign(p);\n    }\n    \n    // now, one of them is the normal of the side closest to p\n    aug_dist dist =  plane_sdf(p, normals[0], inradius, color);\n    for (int j = 1; j < 4; j++) {\n        dist = dmax(dist, plane_sdf(p, normals[j], inradius, color));\n    }\n    dist.normal = orient * dist.normal;\n    return dist;\n}\n\n// --- marcher ---\n\nconst int steps = 256;\nconst float eps = 0.001;\nconst float horizon = 30.0;\n\nfloat plateau(float t, float width) {\n    const float margin = 1./12.;\n    t = mod(t, 3.);\n    if (t < margin) {\n        float s = 1.-t/margin;\n        return 1. - s*s;\n    } else if (t < width-margin) {\n        return 1.;\n    } else if (t < width) {\n        float s = 1. - (width-t)/margin;\n        return 1. - s*s;\n    } else {\n        return 0.;\n    }\n}\n\nvec3 radiance(aug_dist dist, vec3 sky_color) {\n    return mix(sky_color, dist.color, (1.+dot(dist.normal, vec3(1.)/sqrt3))/2.);\n}\n\nconst vec3 sky_color = vec3(0.1, 0.1, 0.3);\nconst vec3 dark = vec3(0.5);\nconst vec3 neonlime = vec3(0.75, 0.90, 0.00);\nconst vec3 light = vec3(1.0);\n\nconst float sqrt5 = 2.*phi-1.;\n\n// with these inradii, the platonic solids interlock as desired\nconst float r_icosa = sqrt5/sqrt3;\nconst float r_dodeca = sqrt5/(hyp*(phi-2./3.));\nconst float r_octa = r_icosa/(phi-2./3.) - 1./(phi*sqrt3);\nconst float r_tetra = 5.*(2./phi-1.)/sqrt3;\n\nvec3 ray_color(vec3 place, vec3 dir) {\n    float r = 0.0;\n    for (int step_cnt = 0; step_cnt < steps; step_cnt++) {\n        // calculate easing functions\n        float t = iTime / 10.;\n        float dodeca_pop = plateau(t,    2.);\n        float octa_pop   = plateau(t,    1.);\n        float icosa_pop  = plateau(t-1., 2.);\n        float cube_pop   = plateau(t-2., 2.);\n        float tetra_pop  = plateau(t-2., 1.);\n        \n        // find scene distance\n        vec3 p_scene = place + r*dir;\n        aug_dist poly = dodeca_sdf(p_scene, r_dodeca * dodeca_pop, neonlime);\n        poly = dmin(poly, octa_sdf(p_scene, r_octa * octa_pop,  light));\n        poly = dmin(poly, icosa_sdf(p_scene, r_icosa * icosa_pop, light));\n        poly = dmin(poly, cube_sdf(p_scene, (1.-eps)*cube_pop, dark));\n        poly = dmin(poly, tetra_sdf(p_scene, r_tetra * tetra_pop, neonlime));\n        \n        // march\n        if (poly.dist < eps) {\n            return radiance(poly, sky_color);\n        } else if (r > horizon) {\n            return sky_color;\n        } else {\n            r += poly.dist;\n        }\n    }\n    return sky_color;\n}\n\n// --- main ---\n\nconst vec3 place = vec3(0., 0., 9.);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // NVIDIA GF100 multisampling pattern\n    // https://www.anandtech.com/show/2918/5\n    vec2 jiggle[8];\n    jiggle[0] = vec2( 0.500,  0.125);\n    jiggle[1] = vec2( 0.625,  0.875);\n    jiggle[2] = vec2(-0.125,  0.500);\n    jiggle[3] = vec2(-0.875,  0.625);\n    jiggle[4] = vec2(-0.500, -0.000);\n    jiggle[5] = vec2(-0.625, -0.875);\n    jiggle[6] = vec2( 0.000, -0.500);\n    jiggle[7] = vec2( 0.875, -0.625);\n    \n    float small_dim = min(iResolution.x, iResolution.y);\n    vec3 color_sum = vec3(0.);\n    for (int k = 0; k < 8; k++) {\n        vec2 screen_pt = (2.*fragCoord + jiggle[k] - iResolution.xy)/small_dim;\n        vec3 dir = normalize(vec3(screen_pt, -3.5));\n        color_sum += ray_color(place, dir);\n    }\n    fragColor = vec4(color_sum/8., 1.);\n}","name":"Image","description":"","type":"image"}]}