{"ver":"0.1","info":{"id":"3tKXzR","date":"1582069626","viewed":128,"name":"Non-integer pixel art #1","username":"tiagosr","description":"This shader renders pixels in a similar fashion as nearest-neighbour sampling, but avoids hard edges between texel barriers, taking into account coverage area of the neighbouring texels for a specific pixel - avoiding shimmering and uneven pixel columns.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["pixelart","noninteger"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale = 1.0; // <--------- pixel lens scale\n    vec2 sourceSize = iChannelResolution[0].xy;\n    \n    vec2 texcoords = fragCoord / scale;\n    \n    vec2 uv = floor(texcoords) + 0.5;\n    fragColor = texture(iChannel0, uv / sourceSize);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float pixelSize = 3.37; // an odd non-integer scale to demonstrate how pixel columns/rows still appear even\nconst float maxZoom = 3.91;\nconst float radius = 128.0;\nconst float speed = 0.02319;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime * speed;\n    vec2 scale = vec2(pixelSize) + ((cos((time * 8.0) / 3.7) + 1.0) / 2.0) * (maxZoom - 1.0) * pixelSize;\n    vec2 offset = vec2(cos(time), sin(time)) * radius;\n    \n    vec2 sourceSize = iChannelResolution[0].xy;\n    vec2 outputSize = sourceSize*scale;\n    vec2 texelSize = 1.0/sourceSize;\n    vec2 range = 0.4999/outputSize;\n    \n    vec2 center = sourceSize - iResolution.xy * 0.5;\n    \n    vec2 texcoords = (fragCoord + offset - center) / outputSize + center;\n    \n    // Calculating texture lookup offsets\n    float left   = texcoords.x - range.x;\n    float top    = texcoords.y + range.y;\n    float right  = texcoords.x + range.x;\n    float bottom = texcoords.y - range.y;\n    \n    // sampling them pixels at the borders of this fragment\n    vec4 topLeft     = texture(iChannel0, (floor(vec2(left, top)     / texelSize) + 0.5) * texelSize);\n    vec4 topRight    = texture(iChannel0, (floor(vec2(right, top)    / texelSize) + 0.5) * texelSize);\n    vec4 bottomLeft  = texture(iChannel0, (floor(vec2(left, bottom)  / texelSize) + 0.5) * texelSize);\n    vec4 bottomRight = texture(iChannel0, (floor(vec2(right, bottom) / texelSize) + 0.5) * texelSize);\n    \n    // calculating the contributions of each pixel through the border coordinates\n    vec2 border = clamp(round(texcoords/texelSize) * texelSize, vec2(left, bottom), vec2(right, top));\n    float totalArea = 4.0 * range.x * range.y;\n    \n    // applying each pixel's contribution as a function of their area\n    fragColor  = ((border.x - left)  * (top - border.y)    / totalArea) * topLeft;\n    fragColor += ((right - border.x) * (top - border.y)    / totalArea) * topRight;\n    fragColor += ((border.x - left)  * (border.y - bottom) / totalArea) * bottomLeft;\n    fragColor += ((right - border.x) * (border.y - bottom) / totalArea) * bottomRight;\n}\n","name":"Buf A","description":"","type":"buffer"}]}