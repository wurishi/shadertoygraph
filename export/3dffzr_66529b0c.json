{"ver":"0.1","info":{"id":"3dffzr","date":"1587587609","viewed":113,"name":"Subsurface Scatter @ Chess Board","username":"fakeljl","description":"Subsurface Scattering on Chess Board with Raymarching and Softshadow.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["subsurfacescattering","softshadow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int RAY_STEPS = 256;\nconst float FOV = 45.0 * 3.14159 / 180.0;\n\nconst float SHADOW_SHARPNESS = 10.0;\nconst float FIVETAP_K = 2.0;\nconst float AO_DELTA = 0.085;\n\n// The larger the DISTORTION, the smaller the glow\nconst float DISTORTION = 0.1;\n// The higher GLOW is, the smaller the glow of the subsurface scattering\nconst float GLOW = 1.5;\n// The higher the BSSRDF_SCALE, the brighter the scattered light\nconst float BSSRDF_SCALE = 3.8;\n\n\nstruct Intersection {\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\n};\n    \nmat4 scale(vec3 s){\n    return mat4(\n        vec4(s.x,   0.0, 0.0, 0.0),\n        vec4(0.0, s.y,   0.0, 0.0),\n        vec4(0.0, 0.0, s.z,   0.0),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n}\n\nmat4 translate(vec3 t){\n    return mat4(\n        vec4(1.0, 0.0, 0.0, 0.0),\n        vec4(0.0, 1.0, 0.0, 0.0),\n        vec4(0.0, 0.0, 1.0, 0.0),\n        vec4(t.x,   t.y,   t.z,   1.0)\n    );\n}\n\nmat4 rotateX(float theta){\n    theta *= 3.14159 / 180.0;\n    return mat4(\n        vec4(1.,0.,0.,0),\n        vec4(0.,cos(theta),-sin(theta),0.),\n        vec4(0.,sin(theta),cos(theta),0.),\n        vec4(0.,0.,0.,1.));\n}\n\nmat4 rotateY(float theta){\n    theta *= 3.14159 / 180.0;\n    return mat4(\n        vec4(cos(theta),0.,-sin(theta),0),\n        vec4(0.,1.,0.,0.),\n        vec4(sin(theta),0.,cos(theta),0.),\n        vec4(0.,0.,0.,1.));\n}\n\nmat4 rotateZ(float theta){\n    theta *= 3.14159 / 180.0;\n    return mat4(\n        vec4(cos(theta),-sin(theta),0.,0),\n        vec4(sin(theta),cos(theta),0.,0.),\n        vec4(0.,0.,1.,0.),\n        vec4(0.,0.,0.,1.));\n}\n\nfloat plane(vec3 p, vec4 n) {\n    return dot(p, n.xyz) + n.w;\n}\n    \nfloat sphere(vec3 p, float r, vec3 c) {\n    return distance(p, c) - r;\n}\n\nfloat dot2( vec3 v ) { return dot(v,v); }\nfloat udQuad( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d ) {\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 dc = d - c; vec3 pc = p - c;\n  vec3 ad = a - d; vec3 pd = p - d;\n  vec3 nor = cross( ba, ad );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(dc,nor),pc)) +\n     sign(dot(cross(ad,nor),pd))<3.0)\n     ?\n     min( min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n     dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat box(vec3 pos, vec3 t, vec3 r, vec3 s) {\n    mat4 worldInverse = inverse(translate(t) * rotateX(r.x) * rotateY(r.y) * rotateZ(r.z) * scale(s));\n    vec3 p = vec3(worldInverse * vec4(pos, 1));\n    float sFactor = min(min(abs(s.x), abs(s.y)), abs(s.z));\n    float dX = 0.0;\n    float dY = 0.0;\n    float dZ = 0.0;\n    if (p.x > 0.5) {\n        dX = p.x - 0.5;\n    }\n    else if (p.x < -0.5) {\n        dX = -0.5 - p.x;\n    }\n    if (p.y > 0.5) {\n        dY = p.y - 0.5;\n    }\n    else if (p.y < -0.5) {\n        dY = -0.5 - p.y;\n    }\n    if (p.z > 0.5) {\n        dZ = p.z - 0.5;\n    }\n    else if (p.z < -0.5) {\n        dZ = -0.5 - p.z;\n    }\n    if (dX == 0.0 && dY == 0.0 && dZ == 0.0) {\n        float xmin = min(0.5 - p.x, p.x + 0.5);\n        float ymin = min(0.5 - p.y, p.y + 0.5);\n        float zmin = min(0.5 - p.z, p.z + 0.5);\n        return -min(min(xmin, ymin), zmin) * sFactor;\n    }\n    else {\n        return sqrt(dX * dX + dY * dY + dZ * dZ) * sFactor;\n    }\n}\n\nvoid rayCast(vec2 uv, out vec3 dir, out vec3 eye, out vec3 ref) {\n    eye = vec3(-10.0, 2.5, -10.0);\n    ref = vec3(0.0, 0.0, 0.0);\n    \n    float len = tan(FOV * 0.5) * distance(eye, ref);\n    vec3 H = normalize(cross(ref - eye, vec3(0.0, 1.0, 0.0)));\n    vec3 V = normalize(cross(H, ref - eye));\n    V *= len;\n    H *= len * iResolution.x / iResolution.y;\n    vec3 p = ref + uv.x * H + uv.y * V;\n    dir = normalize(p - eye);\n}\n\nvec3 computeMaterial(int hitObj, vec3 p, vec3 d, vec3 n) {\n    switch(hitObj) {\n        case 0: // Floor\n        float t = mod(floor(0.25 * p.x), 2.0) == mod(floor(0.25 * p.z), 2.0) ? 1.0 : 0.0;\n        return mix(vec3(0.5), vec3(1.0), t);\n        break;\n        case 1: // Sphere Center\n        return vec3(0.03, 0.865, 0.65);\n        break;\n        case 2: // Short Cube\n        return vec3(0.85, 0.81, 0.78);\n        break;\n        case 3: // Light Source\n        return vec3(0.47, 0.7, 0.9);\n        break;\n        case -1:\n        return vec3(0.0);\n        break;\n    }\n    return vec3(0.0);\n}\n\nvoid sceneMap3D(vec3 pos, out float t, out int obj) {\n    t = plane(pos, vec4(0.0, 1.0, 0.0, 2.5));\n    obj = 0; // Floor\n    float t2;\n    \n    if ((t2 = sphere(pos, 2.0, vec3(-2.0, 2.5, 0.75))) < t) {\n        t = t2;\n        obj = 1; // Sphere Center\n    }\n    if ((t2 = box(pos, vec3(-2.0, -1.0, 0.75), vec3(0.0, -17.5, 0.0), vec3(3, 3, 3))) < t) {\n        t = t2;\n        obj = 2; // Short Cube\n    }\n    if ((t2 = sphere(pos, 1.0, vec3(15.0 * sin(0.4 * iTime), 5.45, 15.0 * cos(0.4 * iTime)))) < t) {\n        t = t2;\n        obj = 3; // Light Source\n    }\n}\n\nfloat sceneMap3D(vec3 pos) {\n    float t;\n    int o;\n    sceneMap3D(pos, t, o);\n    return t;\n}\n\nfloat shadowMap3D(vec3 pos) {\n    float t = plane(pos, vec4(0.0, 1.0, 0.0, 2.5));\n    t = min(t, sphere(pos, 2.0, vec3(-2.0, 2.5, 0.75)));\n    t = min(t, box(pos, vec3(-2.0, -1.0, 0.75), vec3(0.0, -17.5, 0.0), vec3(3, 3, 3)));\n    return t;\n}\n\nvoid march(vec3 origin, vec3 dir, out float t, out int hitObj) {\n    t = 0.001;\n    for(int i = 0; i < RAY_STEPS; ++i)\n    {\n        vec3 pos = origin + t * dir;\n    \tfloat m;\n        sceneMap3D(pos, m, hitObj);\n        if(m < 0.01)\n        {\n            return;\n        }\n        t += m;\n    }\n    t = -1.0;\n    hitObj = -1;\n}\n\nvec3 computeNormal(vec3 pos) {\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( sceneMap3D(pos + epsilon.yxx) - sceneMap3D(pos - epsilon.yxx),\n                            sceneMap3D(pos + epsilon.xyx) - sceneMap3D(pos - epsilon.xyx),\n                            sceneMap3D(pos + epsilon.xxy) - sceneMap3D(pos - epsilon.xxy)));\n}\n\nfloat softShadow(vec3 dir, vec3 origin, float min_t, float k) {\n    float res = 1.0;\n    float t = min_t;\n    for (int i = 0; i < RAY_STEPS; i++ ) {\n        float m = shadowMap3D(origin + t * dir);\n        if (m < 0.0001) {\n            return 0.0;\n        }\n        res = min(res, k * m / t);\n        t += m;\n    }\n    return res;\n}\n\nfloat ambientOcclusion(vec3 p, vec3 n, float k) {\n    float ao = 1.0;\n    float expo = 0.5;\n    for (float i = 1.0; i <= 5.0; i += 1.0) {\n        ao -= k * expo * (i * AO_DELTA - sceneMap3D(p + i * AO_DELTA * n));\n        expo *= 0.5;\n    }\n    return ao;\n}\n\nfloat subSurface(vec3 lightVec, vec3 nor, vec3 viewVec, float thickness) {\n    vec3 scatterDir = lightVec + nor * DISTORTION;\n    float lightReachingEye = pow(clamp(dot(viewVec, -scatterDir), 0.0, 1.0), GLOW) * BSSRDF_SCALE;\n    float attenuation = max(0.0, dot(nor, lightVec) + dot(viewVec, -lightVec));\n    float totalLight = attenuation * lightReachingEye * thickness;\n    return totalLight;\n}\n\nIntersection sdf3D(vec3 dir, vec3 eye) {\n    float t;\n    int hitObj;\n    march(eye, dir, t, hitObj);\n    if (t == -1.0) {\n        return Intersection(t, vec3(0.0), eye + 1000.0 * dir, -1);\n    }\n    vec3 isect = eye + t * dir;\n    vec3 nor = computeNormal(isect);\n    vec3 material = computeMaterial(hitObj, isect, dir, nor);\n    \n    if (hitObj == 3) {\n        return Intersection(t, material, isect, hitObj);\n    }\n    \n    vec3 light = vec3(15.0 * sin(0.4 * iTime), 5.45, 15.0 * cos(0.4 * iTime));\n    float lambert = dot(normalize(light - isect), nor);\n    \n    float shadow = softShadow(normalize(light - isect), isect, 0.1, SHADOW_SHARPNESS);\n    \n    float thickness = ambientOcclusion(isect, -nor, FIVETAP_K);\n    float ss = subSurface(normalize(light - isect), nor, normalize(eye - isect), thickness);\n    \n    vec3 col = (ss + shadow * lambert)* material;\n    \n    return Intersection(t, col, isect, hitObj);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // [-1, 1]\n    uv = 2.0 * uv - vec2(1.0);\n    \n    vec3 dir, eye, ref;\n    rayCast(uv, dir, eye, ref);\n    vec3 col = sdf3D(dir, eye).color;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}