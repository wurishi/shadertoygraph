{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// https://www.shadertoy.com/view/XlVGRz\n\nconst float FXAA_SPAN_MAX = 8.0;\nconst float FXAA_REDUCE_MUL = 1.0/8.0;\nconst float FXAA_REDUCE_MIN = 1.0/128.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 offset = 1.0/iResolution.xy;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 nw = texture(iChannel0, uv + vec2(-1.0, -1.0) * offset).rgb;\n    vec3 ne = texture(iChannel0, uv + vec2( 1.0, -1.0) * offset).rgb;\n    vec3 sw = texture(iChannel0, uv + vec2(-1.0,  1.0) * offset).rgb;\n    vec3 se = texture(iChannel0, uv + vec2( 1.0,  1.0) * offset).rgb;\n    vec3 m  = texture(iChannel0, uv).rgb;\n\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(nw, luma);\n    float lumaNE = dot(ne, luma);\n    float lumaSW = dot(sw, luma);\n    float lumaSE = dot(se, luma);\n    float lumaM  = dot(m,  luma);\n\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n    vec2 dir = vec2(\n        -((lumaNW + lumaNE) - (lumaSW + lumaSE)),\n        ((lumaNW + lumaSW) - (lumaNE + lumaSE)));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(FXAA_SPAN_MAX), max(vec2(-FXAA_SPAN_MAX), dir * rcpDirMin)) * offset;\n\n    vec3 rgbA = 0.5 * (texture(iChannel0, uv + dir * (1.0 / 3.0 - 0.5)).xyz + texture(iChannel0, uv + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (texture(iChannel0, uv + dir * -0.5).xyz + texture(iChannel0, uv + dir * 0.5).xyz);\n    float lumaB = dot(rgbB, luma);\n    if (lumaB < lumaMin || lumaB > lumaMax) {\n        fragColor = vec4(rgbA, 1.0);\n    } else {\n        fragColor = vec4(rgbB, 1.0);\n    }\n}","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"// TODO:\n// - voronoi tracking for more efficient rendering of lights\n\n#define PI 3.1415926535\n#define UP vec3(0,0,1)\n\n#define MARCH_STEPS 512\n#define MARCH_SURF 0.001\n#define MARCH_MISS 1000.\n\n#define RAY_BOUNCES 2\n\n#define VFOV 60.0\n\n#define SKY_TOP vec3(.46, .84, .92)*0.01\n#define SKY_BOTTOM (SKY_TOP * 2.0)\n#define SKY_HORIZ vec3(.5, .1, .1)\n\n    // integrate the sky function\n#define AMBIENT ((SKY_BOTTOM - SKY_TOP + PI*SKY_TOP/2.0 + SKY_HORIZ/9.0) * (2.0 / PI))\n\nstruct Camera {\n    vec3 eye;\n    vec3 forward, right, up;\n};\n\nstruct Ray {\n    vec3 origin, direction;\n};\n\nstruct Material {\n    vec3 albedo;\n    float specular, ior;\n};\n\nstruct Hit {\n    vec3 position, normal;\n    float rayt;\n    Material mat;\n};\n\n// point light\nstruct Light {\n    vec3 position, emission;\n    float radius;\n};\n\n\n// functions from https://www.shadertoy.com/view/Xds3zN\n// for about the next 300 lines\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdOctogonPrism( in vec3 p, in float r, float h )\n{\n  const vec3 k = vec3(-0.9238795325,   // sqrt(2+sqrt(2))/2 \n                       0.3826834323,   // sqrt(2-sqrt(2))/2\n                       0.4142135623 ); // sqrt(2)-1 \n  // reflections\n  p = abs(p);\n  p.xy -= 2.0*min(dot(vec2( k.x,k.y),p.xy),0.0)*vec2( k.x,k.y);\n  p.xy -= 2.0*min(dot(vec2(-k.x,k.y),p.xy),0.0)*vec2(-k.x,k.y);\n  // polygon side\n  p.xy -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  vec2 d = vec2( length(p.xy)*sign(p.y), p.z-h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    const float k = sqrt(3.0);\n    h.x *= 0.5*k;\n    p.xy /= h.x;\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    float d1 = length(p.xy)*sign(-p.y)*h.x;\n    float d2 = abs(p.z)-h.y;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\n// vertical\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n    vec2 q = h*vec2(c.x,-c.y)/c.y;\n    vec2 w = vec2( length(p.xz), p.y );\n    \n\tvec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n    float k = sign( q.y );\n    float d = min(dot( a, a ),dot(b, b));\n    float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n\treturn sqrt(d)*sign(s);\n}\n\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\n// c is the sin/cos of the desired cone angle\nfloat sdSolidAngle(vec3 pos, vec2 c, float ra)\n{\n    vec2 p = vec2( length(pos.xz), pos.y );\n    float l = length(p) - ra;\n\tfloat m = length(p - c*clamp(dot(p,c),0.0,ra) );\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    float m = p.x + p.y + p.z - s;\n\n    // exact distance\n    #if 0\n    vec3 o = min(3.0*p - m, 0.0);\n    o = max(6.0*p - m*2.0 - o*3.0 + (o.x+o.y+o.z), 0.0);\n    return length(p - s*o/(o.x+o.y+o.z));\n    #endif\n    \n    // exact distance\n    #if 1\n \tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n    #endif\n    \n    // bound, not exact\n    #if 0\n\treturn m*0.57735027;\n    #endif\n}\n\nfloat sdPyramid( in vec3 p, in float h )\n{\n    float m2 = h*h + 0.25;\n    \n    // symmetry\n    p.xz = abs(p.xz);\n    p.xz = (p.z>p.x) ? p.zx : p.xz;\n    p.xz -= 0.5;\n\t\n    // project into face plane (2D)\n    vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n    float s = max(-q.x,0.0);\n    float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n\tfloat b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n    float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n    // recover 3D and scale, and add sign\n    return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));;\n}\n\n// la,lb=semi axis, h=height, ra=corner\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n    p = abs(p);\n    vec2 b = vec2(la,lb);\n    float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n\tvec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\nfloat sdHorseshoe( in vec3 p, in vec2 c, in float r, in float le, vec2 w )\n{\n    p.x = abs(p.x);\n    float l = length(p.xy);\n    p.xy = mat2(-c.x, c.y, \n              c.y, c.x)*p.xy;\n    p.xy = vec2((p.y>0.0 || p.x>0.0)?p.x:l*sign(-c.x),\n                (p.x>0.0)?p.y:l );\n    p.xy = vec2(p.x,abs(p.y-r))-vec2(le,0.0);\n    \n    vec2 q = vec2(length(max(p.xy,0.0)) + min(0.0,max(p.x,p.y)),p.z);\n    vec2 d = abs(q) - w;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdU( in vec3 p, in float r, in float le, vec2 w )\n{\n    p.x = (p.y>0.0) ? abs(p.x) : length(p.xy);\n    p.x = abs(p.x-r);\n    p.y = p.y - le;\n    float k = max(p.x,p.y);\n    vec2 q = vec2( (k<0.0) ? -k : length(max(p.xy,0.0)), abs(p.z) ) - w;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\nfloat checkerboardPattern(vec2 uv) {\n    int checker = int(floor(uv.x)) + int(floor(uv.y));\n    \n    return checker%2 == 0 ? 1.0 : 0.0;\n}\n\nvoid opUnion(inout float d1, inout Material m1, in float d2, in Material m2) {\n    if (d2 < d1) {\n        d1 = d2; m1 = m2;\n    }\n}\n\n#define map(p, mat) _map_impl(p, mat, iTime)\nfloat _map_impl(in vec3 p, out Material mat, in float iTime) {\n    float ground = p.z;\n    float checker = checkerboardPattern(p.xy)*exp(-dot(p.xy,p.xy)/200.0);\n    mat.albedo = mix(vec3(.2, .2, .2), vec3(.9, .9, .9), checker);\n    mat.specular = mix(0.9, 0.2, checker);\n    mat.ior = 1.45;\n    float dist = ground;\n    \n    float frame = sdBoxFrame(p-vec3(0,0,1), vec3(1, 1, 1), 0.1);\n    Material box_mat;\n    box_mat.albedo = vec3(0,1,0);\n    box_mat.specular = 0.0;\n    \n    opUnion(dist, mat, frame, box_mat);\n    \n    \n    return dist;\n}\n\n#define N_LIGHTS 1\n#define get_lights(lights) _get_lights_impl(lights, iTime)\nvoid _get_lights_impl(out Light[N_LIGHTS] lights, in float iTime) {\n    lights[0].position = vec3(0.0, -2.0, 2.0);\n    lights[0].emission = vec3(1,1,1) * 100.0;\n    lights[0].radius = 0.1;\n}\n\n#define map_grad(pos) _map_grad_impl(pos, iTime)\nvec3 _map_grad_impl(in vec3 pos, in float iTime) {\n    Material _m;\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy, _m ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, _m ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, _m ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx, _m ) );\n}\n\n#define march(r, hit) _march_impl(r, hit, iTime)\nbool _march_impl(in Ray r, out Hit hit, in float iTime) {\n    float t = 0.0, s;\n    \n    for (int i = 0; i < MARCH_STEPS; ++i) {\n        s = map(r.origin + r.direction*t, hit.mat);\n        \n        if (s < 0.0) ++i; // take less steps if we're in a surface\n        if (abs(s) < MARCH_SURF || s > MARCH_MISS || t > MARCH_MISS) break;\n        \n        t += s;\n    }\n    hit.position = r.origin + r.direction*t;\n    hit.rayt = t;\n    hit.normal = map_grad(hit.position);\n    \n    return (s < MARCH_SURF) && (t < MARCH_MISS);\n}\n\nvec3 sky_color(vec3 rd) {\n    vec3 atmos = mix(SKY_BOTTOM, SKY_TOP, rd.z);\n    atmos += SKY_HORIZ * pow(1.0 - rd.z, 8.0);\n    \n    vec3 col = atmos * step(-0.1, rd.z);\n    \n    return col;\n}\n\n#define shadow(shadedPos, lightPos, lightSize) _shadow_impl(shadedPos, lightPos, lightSize, iTime)\nfloat _shadow_impl(in vec3 ro, in vec3 lightPos, in float w, in float iTime)\n{\n    vec3 rd = normalize(lightPos-ro);\n    float maxt = length(lightPos-ro) - w;\n    float res = 1.0;\n    float t = 0.01;\n    Material _m;\n    for( int i=0; i<256 && t<maxt; i++ )\n    {\n        float h = map(ro + t*rd, _m);\n        res = min( res, h/(w*t) );\n        t += clamp(h, 0.005, 0.50);\n        if( res<-1.0 || t>maxt ) break;\n    }\n    res = max(res,-1.0);\n    return 0.25*(1.0+res)*(1.0+res)*(2.0-res);\n}\n\n#define sky_occlusion(point, norm) _sky_occlusion_impl(point, norm, iTime)\nfloat _sky_occlusion_impl(vec3 point, vec3 norm, float iTime) {\n    return shadow(point, point + norm * 1000.0, 1.0);\n}\n\nfloat fresnel(vec3 normal, vec3 view_dir, float ior) {\n    float F0 = pow((1.0-ior)/(1.0+ior), 2.0);\n    float cos_theta = clamp(dot(normalize(normal), normalize(view_dir)), 0.0, 1.0);\n    return F0 + (1.0 - F0) * pow(1.0 - cos_theta, 5.0);\n}\n\nbool ray_sphere(Ray r, vec3 center, float radius, out float t) {\n    vec3 oc = center - r.origin;\n    float a = dot(r.direction, r.direction);\n    float h = dot(r.direction, oc);\n    float c = dot(oc, oc) - radius * radius;\n    float discriminant = h * h - a * c;\n\n    if (discriminant < 0.0) {\n        t = 0.0;\n        return false;\n    } else {\n        t = (h - sqrt(discriminant)) / a;\n        return t > 0.0;\n    }\n}\n\n#define shade(r) _shade_impl(r, iTime)\nvec3 _shade_impl(Ray r, in float iTime) {\n    Hit hit;\n    \n    vec3 reflectance = vec3(1);\n    vec3 light = vec3(0);\n    \n    Light lights[N_LIGHTS];\n    get_lights(lights);\n    \n    for (int bounce = 0; bounce < RAY_BOUNCES; ++bounce) {\n        bool scene_hit = march(r, hit);\n        \n        bool light_hit = false;\n        Light closest;\n        float mint = hit.rayt;    \n        for (int i = 0; i < N_LIGHTS; ++i) {\n            Light light = lights[i];\n            float t;\n            if (ray_sphere(r, light.position, light.radius, t)) {\n                if (t < mint) {\n                    light_hit = true;\n                    closest = light;\n                }\n            }\n        }\n        \n        if (!(scene_hit || light_hit)) {\n            light += sky_color(r.direction) * reflectance;\n            break;\n        }\n        \n        if (light_hit) {\n            light += reflectance * closest.emission;\n            break;\n        }\n        \n        vec3 incoming_light = AMBIENT * sky_occlusion(hit.position, hit.normal);\n        \n        for (int i = 0; i < N_LIGHTS; ++i) {\n            Light light = lights[i];\n            float occlusion = shadow(hit.position, light.position, light.radius);\n            \n            float d2 = dot2(light.position - hit.position);\n            float cos_theta = max(0.00001, dot(normalize(light.position-hit.position), hit.normal));\n            float A = 2.0 * PI * light.radius*light.radius;\n            float solid_angle = (cos_theta * A) / d2;\n            \n            incoming_light += occlusion * light.emission * solid_angle;\n        }\n        \n        light += reflectance * incoming_light * hit.mat.albedo * (1.0 - hit.mat.specular);\n        \n        if (hit.mat.specular < 0.01) {\n            break;\n        }\n        \n        r.origin = hit.position + hit.normal * MARCH_SURF * 2.0;\n        r.direction = reflect(r.direction, hit.normal);\n        \n        float f = fresnel(hit.normal, r.direction, hit.mat.ior);\n        \n        reflectance *= hit.mat.specular * f;\n    }\n    \n    return light;\n}\n\n// saw this #define trick in a different shader, i don't remember where but it's really cool\n#define gen_camera(cam) _gen_camera_impl(cam, iTime, iResolution.xy)\nvoid _gen_camera_impl(out Camera cam, float iTime, vec2 iResolution) {\n    cam.eye = vec3(3.0*cos(iTime/2.0),3.0*sin(iTime/2.0),1.1+sin(iTime/PI));\n    \n    cam.forward = -normalize(cam.eye);\n    cam.right = normalize(cross(cam.forward, UP));\n    cam.up = cross(cam.right, cam.forward);\n    \n    cam.right *= iResolution.x / iResolution.y;\n    \n    float focal = 1.0 / (2.0 * tan(radians(VFOV)/2.0));\n    cam.forward *= focal;\n}\n\nvoid camera_ray(out Ray r, in vec2 uv, in Camera cam) {\n    r.origin = cam.eye;\n    \n    r.direction = normalize(cam.forward + uv.x * cam.right + uv.y * cam.up);\n}\n\n/*\n * FBCT - Fred's Basic Color Transform\n */\n \nconst float FBCT_DESATURATION = 0.02;\nconst float FBCT_EXPOSURE = 1.0;\n\nconst float FBCT_RED_BIAS = 1.0;\nconst float FBCT_GRN_BIAS = 1.0;\nconst float FBCT_BLU_BIAS = 1.0;\n\nconst mat4 fbct_color_matrix = \nmat4(\n    FBCT_RED_BIAS, FBCT_GRN_BIAS*FBCT_DESATURATION, FBCT_BLU_BIAS*FBCT_DESATURATION, 0.00,\n    FBCT_RED_BIAS*FBCT_DESATURATION, FBCT_GRN_BIAS, FBCT_BLU_BIAS*FBCT_DESATURATION, 0.00,\n    FBCT_RED_BIAS*FBCT_DESATURATION, FBCT_GRN_BIAS*FBCT_DESATURATION, FBCT_BLU_BIAS, 0.00,\n    0.0, 0.0, 0.0, FBCT_EXPOSURE\n\n);\n\nvec3 fbct_transform(vec3 color) {\n    vec4 mmr = (vec4(color, 1) * fbct_color_matrix);\n    vec3 cc = mmr.xyz * mmr.w;\n    \n    cc = cc / (cc + 1.0);\n    \n    cc = pow(cc, vec3(1.0 / 2.2));\n\n    return cc;\n}\n\n// End FBCT","name":"Common","description":"","type":"common"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy) * 2.0 - 1.0;\n    Camera cam;\n    gen_camera(cam);\n    \n    Ray cam_ray;\n    camera_ray(cam_ray, uv, cam);\n    \n    vec3 col = vec3(0);\n\n    col = shade(cam_ray);\n\n    col = abs(col);\n    col = fbct_transform(col);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"lcKBzW","date":"1733847997","viewed":93,"name":"Raymarching template v4","username":"FrederickAmpsUp","description":"A fast and capable ray-marching engine with support for reflections, fresnel, and sky lighting. Feel free to fork and build your own stuff off of it!","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["raymarch","template"],"hasliked":0,"parentid":"","parentname":""}}