{"ver":"0.1","info":{"id":"fs3fRn","date":"1655883108","viewed":173,"name":"Sticky Sparks","username":"fenix","description":"Based on FabriceNeyret2's https://www.shadertoy.com/view/wlcXRS. I was trying to create some kind of simulation using the voronoi tracking idea, and this isn't quite what I had originally intended but it's pretty cool anyway.","likes":7,"published":1,"flags":48,"usePreview":0,"tags":["2d","voronoi","simulation","particles"],"hasliked":0,"parentid":"WltSz7","parentname":"Basic : Voronoi Tracking"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Lava Volcano SDF\" by fenix. https://shadertoy.com/view/NdyyRt\n// 2022-06-16 07:08:11\n\n// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2022\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Based on FabriceNeyret2's https://www.shadertoy.com/view/wlcXRS. I was trying to\n//  create some kind of simulation using the voronoi tracking idea, and this isn't quite\n//  what I had originally intended but it's pretty cool anyway.\n// \n//  The voronoi tracking is slightly extended, searching over the nearest 25 neighbors\n//  instead of just 4, allowing the particles to move faster. All the rendering and\n//  particle interactions are new also.\n// ---------------------------------------------------------------------------------------\n\nvoid renderParticle(in vec2 newPos, in vec2 oldPos, in vec3 color, in float density, in vec2 fragCoord, inout vec4 fragColor)\n{    \n    vec2 closest;\n    float dist = linePointDist2(newPos, oldPos, fragCoord, iResolution, closest);\n    \n    if (dist < PARTICLE_SIZE * PARTICLE_SIZE)\n    {\n        fragColor.xyz += color * ((PARTICLE_SIZE - sqrt(dist)) * density / 300.0) / (PARTICLE_SIZE);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n    \n    fragColor = vec4(0);\n  \tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.xy;\n\n    //get the id's of the 4 particles that (should be) closest.\n    //the 4 ids are stored in .x, .y, .z, .w\n    ivec4 ids = fxGetClosest(ivec2(fragCoord));\n    \n    //draw the particles\n    for(int i = 0; i < 4; i++){\n        //get the particles position\n        int id = ids[i];\n        fxParticle particle = fxGetParticle(id);\n        vec2 pos = particle.pos;\n        vec2 vel = particle.vel;\n\n        renderParticle(pos, pos - vel, particle.color, particle.density, p, fragColor);\n    }  \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const int PARTICLES = 20000; \nconst int PARTICLE_INIT_X = 10;\nconst float PARTICLE_SIZE = 0.01;\nconst float PARTICLE_REPEL_SIZE = 0.002;\n\n//hashing noise by IQ\nfloat hash( int k ) {\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\nvec2 world2screenInternal(in vec2 p, in vec2 resolution)\n{\n    return (p + 1.0) * 0.5 * resolution;\n}\n\n#define world2screen(X) world2screenInternal(X, iResolution.xy)\n\nvec2 screen2worldInternal(in vec2 p, in vec2 resolution)\n{\n    return (p / resolution) * 2.0 - 1.0;\n}\n\n#define screen2world(X) screen2worldInternal(X, iResolution.xy)\n\nconst vec4 SCENE_WALLS[4] = vec4[]( vec4(-1.0, -1.0, 1.0, -1.0),\n    vec4(1.0, 1.0, -1.0, 1.0),\n    vec4(-1.0, 1.0, -1.0, -1.0),\n    vec4(1.0, -1.0, 1.0, 1.0));\n    \nconst int NUM_SCENE_WALLS = 4;\n\nfloat linePointDist2(in vec2 newPos, in vec2 oldPos, in vec2 fragCoord, in vec3 resolution, out vec2 closest)\n{\n    vec2 pDelta = (fragCoord - oldPos);\n    vec2 delta = newPos - oldPos;\n    float deltaLen2 = dot(delta, delta);\n\n    // Find the closest point on the line segment from old to new\n    closest;\n    if (deltaLen2 > 0.0000001)\n    {\n        float deltaInvSqrt = inversesqrt(deltaLen2);\n        vec2 deltaNorm = delta * deltaInvSqrt;\n        closest = oldPos + deltaNorm * max(0.0, min(1.0 / deltaInvSqrt, dot(deltaNorm, pDelta)));\n    }\n    else\n    {\n        closest = oldPos;\n    }\n\n    // Distance to closest point on line segment\n    vec2 closestDelta = closest - fragCoord;\n    closestDelta *= resolution.xy / resolution.y;\n    return dot(closestDelta, closestDelta);\n}\n\nfloat halfSpaceDist(vec2 sceneFrom, vec2 sceneTo, vec2 point, vec3 resolution)\n{\n    vec2 dir = normalize(sceneTo - sceneFrom);\n    vec2 normal = vec2(-dir.y, dir.x) * resolution.xy / resolution.y;\n    return dot(point - sceneTo, normal);\n}\n\nfloat distanceFromWalls(vec2 point, vec3 resolution)\n{\n    float minDist = 1e30;\n    for (int index = 0; index < NUM_SCENE_WALLS; ++index)\n    {\n        vec2 sceneFrom = SCENE_WALLS[index].xy;\n        vec2 sceneTo = SCENE_WALLS[index].zw;\n        \n        float dist = halfSpaceDist(sceneFrom, sceneTo, point, resolution);\n        \n        if (dist < minDist)\n        {\n            minDist = dist;\n        }\n    }\n    return minDist;\n}\n\nvec2 getNormalFromWalls( vec2 point, vec3 resolution )\n{\n\tvec2 tinyChangeX = vec2( 0.001, 0.0 );\n    vec2 tinyChangeY = vec2( 0.0 , 0.001 );\n    \n   \tfloat upTinyChangeInX   = distanceFromWalls( point + tinyChangeX, resolution ); \n    float downTinyChangeInX = distanceFromWalls( point - tinyChangeX, resolution ); \n    \n    float tinyChangeInX = upTinyChangeInX - downTinyChangeInX;\n    \n    \n    float upTinyChangeInY   = distanceFromWalls( point + tinyChangeY, resolution ); \n    float downTinyChangeInY = distanceFromWalls( point - tinyChangeY, resolution ); \n    \n    float tinyChangeInY = upTinyChangeInY - downTinyChangeInY;\n    \n    \n\tvec2 normal = vec2(\n         \t\t\ttinyChangeInX,\n        \t\t\ttinyChangeInY\n    \t \t\t  );\n    \n\treturn normalize(normal);\n}\n\n//returns the ids of the four closest particles from the input\nivec4 fxGetClosestInternal(sampler2D sampler, ivec2 xy)\n{\n    return ivec4(texelFetch(sampler, xy, 0));\n}\n\n#define fxGetClosest(X) fxGetClosestInternal(iChannel1, X)\n\n#define POS_VEL 0\n#define DENSITY 1\n#define NUM_PARTICLE_DATA_TYPES 2\n\n//returns the location of the particle within the particle buffer corresponding with the input id \nivec2 fxLocFromIDInternal(int width, int id, int dataType)\n{\n    int index = id * NUM_PARTICLE_DATA_TYPES + dataType;\n    return ivec2( index % width, index / width);\n}\n\n#define fxLocFromID(X, Y) fxLocFromIDInternal(int(iResolution.x), X, Y)\n\nstruct fxParticle\n{\n    vec2 pos;\n    vec2 vel;\n    vec3 color;\n    float density;\n};\n\n//get the particle corresponding to the input id\nfxParticle fxGetParticleInternal(sampler2D sampler, int resolutionWidth, int id)\n{\n    vec4 particleData0 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, POS_VEL), 0);\n    vec4 particleData1 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, DENSITY), 0);\n    \n    fxParticle particle;\n    particle.pos = particleData0.xy;\n    particle.vel = particleData0.zw;\n    particle.color = particleData1.xyz;\n    particle.density = particleData1.w;\n    \n    return particle;\n}\n\n#define fxGetParticle(X) fxGetParticleInternal(iChannel0, int(iResolution.x), X)\n\nvec2 fxGetParticlePosInternal(sampler2D sampler, int resolutionWidth, int id)\n{\n    vec4 particleData0 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, POS_VEL), 0);\n    \n    return particleData0.xy;\n}\n\n#define fxGetParticlePos(X) fxGetParticlePosInternal(iChannel0, int(iResolution.x), X)\n\nconst float PI = 3.141592653589793;\n\nfloat SPHkernel (float x)\n{\n    return cos(x) + cos(x + x);\n}\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Particle Buffer\n// in this buffer every pixel represents a particle\n// the particles positions is stored in .xy\n//           its velocity  is stored in .zw\n// Only the first PARTICLES amount of pixels are actually used.\n\nconst vec2 GRAVITY = vec2(0.0000, -0.000);\nconst float MAX_SPEED = 0.002;\nconst float DAMPING = 0.99;\nconst float PARTICLE_REPEL = 0.00002;\nconst float WALL_REPEL = 0.0;\n\nvec4 saveParticle(fxParticle particle, int dataType);\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n    ivec2 iFragCoord = ivec2(fragCoord);\n    \n    //we only simulate PARTICLES amount of particles\n    int index = iFragCoord.x + iFragCoord.y*int(iResolution.x);\n    int id = index / 2;\n    if(id>=PARTICLES) return;\n    \n    fxParticle oldData = fxGetParticle(id);\n    fxParticle newData = oldData;\n    \n    if(iFrame==0 || oldData.pos == vec2(0.0, 0.0) || keyClick(32)){\n       \t//pick a \"random\" starting position\n        float h1 = hash(id);\n        float h2 = hash(int(h1*41343.));\n        float h3 = hash(int(h2*488232.));\n        float h4 = hash(int(h3*99399.));\n        float h5 = hash(int(h4*399424.));\n        newData.pos = vec2(h1,h2) * vec2(2.0, 2.0) - vec2(1.0, 1.0);\n        newData.vel = vec2(0);\n        if (newData.pos.x < -0.33)\n        {\n            newData.color = vec3(1.0, 0.0, 0.0);\n        }\n        else if (newData.pos.x < 0.33)\n        {\n            newData.color = vec3(0.0, 1.0, 0.0);\n        }\n        else\n        {\n            newData.color = vec3(0.0, 0.0, 1.0);\n        }\n        newData.density = 0.0;\n    }\n    else\n    {\n        newData.vel = oldData.vel * DAMPING + GRAVITY * 0.033;\n        if (iMouse.z > 0.0 && iMouse.w < 0.0)\n        {\n            const float MOUSE_FIELD_SIZE = 0.15;\n            const float MOUSE_FIELD_STRENGTH = 0.02;\n            float dist = distance(newData.pos * iResolution.xy / iResolution.y, ((2.0 * iMouse.xy / iResolution.xy) - 1.0) * vec2(iResolution.x / iResolution.y, 1.0));\n            if (dist < MOUSE_FIELD_SIZE)\n            {\n                vec2 mouseDelta = (iMouse.xy - vec2(iMouse.z, -iMouse.w));\n                mouseDelta = clamp(mouseDelta, -100.0, 100.0);\n                newData.vel += (MOUSE_FIELD_SIZE - dist) * MOUSE_FIELD_STRENGTH * mouseDelta / iResolution.xy;\n            }\n        }\n\n        ivec4 closest = fxGetClosest(ivec2(world2screen(oldData.pos)));\n        float density = 0.0;\n        for(int i = 0; i < 4; i++)\n        {\n            int cid = closest[i];\n            if(cid==id) continue;\n\n            fxParticle otherData = fxGetParticle(cid);\n            vec2 otherPos = otherData.pos + otherData.vel;\n            vec2 delta = otherPos - newData.pos;\n            float dist = length(delta);\n\n            density += 1.0 / dist;\n            if (dist < (PARTICLE_SIZE + PARTICLE_SIZE))\n            {\n                if (dist < 0.00000000001)\n                {\n                    delta = vec2(0.0, sign(id - cid));\n                }\n                else\n                {\n                    delta = delta / dist;\n                }\n                \n                newData.pos -= delta * PARTICLE_SIZE * 0.5;\n            }\n            \n            newData.vel -= PARTICLE_REPEL * SPHkernel(dist / PARTICLE_REPEL_SIZE) * normalize(delta);\n        }\n\n\n        for(int i = 0; i < 4; i++)\n        {\n            int cid = closest[i];\n            if(cid==id) continue;\n\n            fxParticle otherData = fxGetParticle(cid);\n            vec2 otherPos = otherData.pos + otherData.vel;\n            vec2 delta = otherPos - newData.pos;\n            float dist = length(delta);\n\n            float densityGrad = (otherData.density - newData.density);\n            //if (abs(densityGrad) > 10.0)\n            {\n                newData.vel -= 0.0000003 * densityGrad * delta;\n            }\n         }\n\n        newData.density = density;\n\n        float distToScene = distanceFromWalls(newData.pos, iResolution);\n        vec2 distNormal = getNormalFromWalls(newData.pos, iResolution);\n\n        if (distToScene < PARTICLE_SIZE * 2.0)\n        {\n            newData.pos += distNormal * (distToScene - PARTICLE_SIZE - PARTICLE_SIZE);\n            \n            float dp = dot(newData.vel, distNormal);\n            if (dp < 0.0)\n            {\n                newData.vel -= distNormal * dp;\n            }\n        }\n        \n        newData.vel = clamp(newData.vel, -MAX_SPEED, MAX_SPEED);\n        \n        newData.pos = oldData.pos + newData.vel;\n    }\n    \n    fragColor = saveParticle(newData, index - id * NUM_PARTICLE_DATA_TYPES);\n}\n\nvec4 saveParticle(fxParticle p, int dataType)\n{    \n    switch(dataType)\n    {\n    case 0:  \n        return vec4(p.pos, p.vel);\n    case 1:\n        return vec4(p.color, p.density);\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Voronoi Buffer\n// every pixel stores the 4 closest particles to it\n// every frame this data is shared between neighbours\n\nfloat distance2Particle(int id, vec2 fragCoord){\n    if(id==-1) return 1e20;\n    vec2 delta = fxGetParticlePos(id)-fragCoord;\n    return dot(delta, delta);\n}\n\nvoid insertion_sort(inout ivec4 i, inout vec4 d, int i_, float d_){\t\n    if(any(equal(ivec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = ivec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = ivec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = ivec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = ivec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n   \tivec2 iFragCoord = ivec2(fragCoord);\n\n    //in this vector the four new closest particles' ids will be stored\n    ivec4 new = ivec4(-1);\n    //in this vector the distance to these particles will be stored \n    vec4 dis = vec4(1e20);\n    \n    for(int x=-2; x<=2; x++){\n        for(int y=-2; y<=2; y++){\n            ivec4 old   = fxGetClosest( iFragCoord + ivec2( x, y) );      \n\n            for(int j=0; j<4; j++){\n                int id = old[j];\n                float dis2 = distance2Particle(id, screen2world(fragCoord));\n                insertion_sort( new, dis, id, dis2 );\n            }\n        }\n    }\n    \n    int searchIterations = 3;\n    if (iFrame < 5)\n    {\n        searchIterations = 100;\n    }\n    for(int k = 0; k < searchIterations; k++){\n        //random hash. We should make sure that two pixels in the same frame never make the same hash!\n        float h = hash(\n            iFragCoord.x + \n            iFragCoord.y*int(iResolution.x) + \n            iFrame*int(iResolution.x*iResolution.y) +\n            k\n        );\n        //pick random id of particle\n        int p = int(h*float(PARTICLES));\n        insertion_sort(new, dis, p, distance2Particle(p, screen2world(fragCoord)));\n    }\n    \n    fragColor = vec4(new); \n    \n}","name":"Buffer B","description":"","type":"buffer"}]}