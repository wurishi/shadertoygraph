{"ver":"0.1","info":{"id":"ls3yRN","date":"1591664092","viewed":140,"name":"Refractive Planes","username":"stb","description":"Just something I never posted... until now!","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["2d","fractal","refraction","shading","parallax","25d","planes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\tRefractive Planes (Fractal Planes)\n\t201x-2020 stb\n\tMessy code is messy.\n\n\tNotes: bumbed the trace level up to 12... sorry for any burning GPUs :/\n\n*/\n\n\nfloat s, c;\n#define rotate(p, a) mat2(c=cos(a), s=-sin(a), -s, c) * p\n\nvec2 cInv(vec2 p, vec2 o, float r) {\n    return (p-o) * r * r / dot(p-o, p-o) + o;\n}\n\nvec2 cInvMir(vec2 p, vec2 o, float r, float flip){\n    return (length(p-o)<r ^^ flip==1. ? cInv(p, o, r) : p);\n}\n\nfloat map(in vec2 p, float z) {\n    for(int i=0; i<8; i++) {\n        p *= 1.1;\n        p.x = max(0., abs(mod(p.x, 4.)-2.)-.1);\n        p.y = max(0., abs(mod(p.y, 4.)-2.)+.5);\n        p -= vec2(.5, .83);\n        \n        p = rotate(p, radians(45.-3.*z));\n        p.y = abs(p.y+.03)-.03;\n        \n        p = cInvMir(p, vec2(.3, .3), 1.4, 1.);\n    }\n    return length(p);\n}\n\nvec3 getNorm(vec2 p, float z) {\n    vec3 acc = vec3(-1., 0., 1.) / iResolution.y * 2.;\n    return\n        normalize(\n            vec3(\n                map(p+acc.zy, z) - map(p+acc.xy, z),\n            \tmap(p+acc.yz, z) - map(p+acc.yx, z),\n            \tacc.z\n\t\t\t)\n\t\t);\n}\n\nvoid mainImage( out vec4 fo, in vec2 fc ) {\n    vec2 res = iResolution.xy;\n    vec2 p = 2. * (fc-res/2.) / res.y;\n    vec2 m = 8. * (iMouse.xy-res.xy/2.) / res.xy;\n    \n    vec3 pos = vec3(0., 0., .25);\n    vec3 dir = vec3(p.xy, 1.);\n    vec3 hit;\n    \n    float fSky = clamp(pow(1.-.3*abs(p.y), 3.), 0., 1.);\n    float alpha=0.;\n    vec3 col = vec3(0.);\n    \n    vec3 rgbSolid = vec3(1., .8, .5);\n    vec3 rgbClear = vec3(.5, .7, 1.);\n    vec3 rgbSky = fSky * vec3(.4, .5, .8);\n    \n    vec3 lPos = (vec3(1., .25, -1.3));\n    \n    float T = -.3*iTime;\n    \n    pos.z -= fract(T);\n    \n    const int I = 12;\n    for(int i=0; i<=I; i++) {\n        \n        pos.z += dir.z;\n        \n        hit = dir*pos.z;\n        hit.xy += vec2(sin(T), cos(T));\n        \n        if(iMouse.x>0.)\n    \t\thit.xy += m.xy;\n        \n        float pattern = clamp(1.-map(hit.xy, hit.z), 0., 1.);\n        \n        float mask = clamp(smoothstep(.35, .4, pattern), 0., 1.);\n        \n        vec3 norm = getNorm(hit.xy, pos.z);\n        \n        vec3 diffuse = vec3(1.) * clamp(dot(norm, lPos), 0., 1.);\n        diffuse += 2. * vec3(.5, .75, 1.) * clamp(dot(norm, vec3(-1., 0., -.3)), 0., 1.);\n        \n        col = mix(mix(rgbSolid*vec3(pattern*.5+1.*diffuse), rgbSky, (float(i)-fract(T))/float(I)), col, alpha);\n        \n        float fade = i==0 ? (1.-fract(T)) : 1.;\n        \n        // refraction\n        dir = refract(dir, norm*.1*fade, 1./1.03);\n        \n        dir /= dir.z;\n        \n        alpha += mask;\n        alpha = clamp(alpha*fade, 0., 1.);\n        \n        if(alpha>=1.) break;\n    }\n    \n    col = mix(col, rgbSky, max(0., 1.-alpha));\n    \n    fo = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}