{"ver":"0.1","info":{"id":"3t3yW7","date":"1609181538","viewed":144,"name":"Happy New Year 2021","username":"Shcherbakov","description":"Shader from last stream in 2020.\nhttps://www.youtube.com/watch?v=ZDb9q4vjwwg&ab_channel=GraphicsMonster","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["winter"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float landSDF(vec3 pos) {\n    return pos.y - texture(iChannel0, pos.xz * 0.05).x * 0.2;\n}\n\nvec3 calcNormal( in vec3 p) // for function f(p)\n{\n    const float h = 0.1; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*landSDF( p + k.xyy*h ) + \n                      k.yyx*landSDF( p + k.yyx*h) + \n                      k.yxy*landSDF( p + k.yxy*h) + \n                      k.xxx*landSDF( p + k.xxx*h ) );\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec3 calcNormalBox( in vec3 p, vec3 b) // for function f(p)\n{\n    const float h = 0.1; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*sdBox( p + k.xyy*h, b ) + \n                      k.yyx*sdBox( p + k.yyx*h, b) + \n                      k.yxy*sdBox( p + k.yxy*h, b) + \n                      k.xxx*sdBox( p + k.xxx*h, b ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float CAMERA_RADIUS = 17.0;\n    vec3 cameraPos = vec3(sin(iTime * 0.2) * CAMERA_RADIUS, 7.5, cos(iTime * 0.2) * CAMERA_RADIUS);\n    vec3 targetPoint = vec3(0, 0, 0);\n    vec3 front = normalize(targetPoint - cameraPos);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(front, up));\n    up = cross(right, front);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy / 2.0) / iResolution.x;\n    vec3 viewVec = normalize(front + up * uv.y + right * uv.x);\n    \n    fragColor = texture(iChannel2, fragCoord / iResolution.xy);\n    \n    // cameraPos.y + viewVec.y * t = 0.2;\n    float t = (0.2 - cameraPos.y) / viewVec.y;\n    vec3 worldPos = cameraPos + viewVec * t;\n    \n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n    \n    const float MARCH_SIZE = 0.05;\n    float snowT = 0.0;\n    vec3 currentPos;\n    bool intFound = false;\n    bool tex = false;\n    float size = 0.0;\n    vec3 color;\n    vec3 normal;\n    snowT = MARCH_SIZE * 100.0;\n    for (int i = 100; i < 700; ++i) {\n        if (snowT > t) {\n            break;\n        }\n        snowT += MARCH_SIZE;\n        currentPos = cameraPos + viewVec * snowT;\n        vec3 showCoord = currentPos * 0.2 + vec3(0, iTime * 0.2, 0);\n        if (texture(iChannel1, showCoord).x > 0.999) {\n            vec3 center = floor(showCoord * 32.0) + 0.5;\n            float dist = length(center - showCoord * 32.0);\n            if (dist > 0.15) {\n                continue;\n            }\n            fragColor.xyz = mix(vec3(1, 1, 1), fragColor.xyz, 0.3);\n            break;\n        }\n    }\n    \n    fragColor.xyz = mix(fragColor.xyz, texture(iChannel2, fragCoord / iResolution.xy).xyz,\n    texture(iChannel2, fragCoord / iResolution.xy).w);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    float star = texture(iChannel0, uv * 4.0).x;\n    float threshold = 0.96;\n    star = step(threshold, star);\n    fragColor = vec4(star);\n    float radius = 12.0 * texture(iChannel1, fragCoord / iResolution.x + vec2(iTime * 0.02, 0)).x;\n    int RADIUS = int(radius);\n    for (int i = -RADIUS; i <= RADIUS; ++i) {\n        for (int j = -RADIUS; j <= RADIUS; ++j) {\n            vec2 dir = vec2(i, j) / radius;\n            float pw = 0.5;\n            float weight = pow(pow(abs(dir.x), pw) + pow(abs(dir.y), pw), 1.0 / pw);\n            if (weight >= 1.0) {\n                continue;\n            }\n            vec2 uv1 = (fragCoord + vec2(i, j)) / iResolution.xy;\n            float star1 = texture(iChannel0, uv1 * 4.0).x;\n            star1 = step(threshold, star1) * texture(iChannel0, uv1).x;\n            fragColor.xyz += vec3(star1) * (1.0 - weight);\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"float landSDF(vec3 pos) {\n    return pos.y - texture(iChannel0, pos.xz * 0.05).x * 0.2;\n}\n\nvec3 calcNormal( in vec3 p) // for function f(p)\n{\n    const float h = 0.1; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*landSDF( p + k.xyy*h ) + \n                      k.yyx*landSDF( p + k.yyx*h) + \n                      k.yxy*landSDF( p + k.yxy*h) + \n                      k.xxx*landSDF( p + k.xxx*h ) );\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec3 calcNormalBox( in vec3 p, vec3 b) // for function f(p)\n{\n    const float h = 0.001; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*sdBox( p + k.xyy*h, b ) + \n                      k.yyx*sdBox( p + k.yyx*h, b) + \n                      k.yxy*sdBox( p + k.yxy*h, b) + \n                      k.xxx*sdBox( p + k.xxx*h, b ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float CAMERA_RADIUS = 17.0;\n    vec3 cameraPos = vec3(sin(iTime * 0.2) * CAMERA_RADIUS, 7.5, cos(iTime * 0.2) * CAMERA_RADIUS);\n    vec3 targetPoint = vec3(0, 0, 0);\n    vec3 front = normalize(targetPoint - cameraPos);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(front, up));\n    up = cross(right, front);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy / 2.0) / iResolution.x;\n    vec3 viewVec = normalize(front + up * uv.y + right * uv.x);\n    \n    fragColor = texture(iChannel2, fragCoord / iResolution.xy);\n    \n    // cameraPos.y + viewVec.y * t = 0.2;\n    float t = (0.2 - cameraPos.y) / viewVec.y;\n    vec3 worldPos = cameraPos + viewVec * t;\n    if (t < 30.0) {\n        for (int i = 0; i < 30; ++i) {\n            if (landSDF(worldPos) < 0.0) {\n                break;\n            }\n            t += 0.05;\n            worldPos = cameraPos + viewVec * t;\n        }\n        vec3 normal = calcNormal(worldPos);\n        vec3 n1 = normalize(texture(iChannel1, worldPos.xz * 0.2).xyz * 2.0 - 1.0);\n        if (dot(n1, normal) < 0.0) {\n            n1 = -n1;\n        }\n\n        float spec = pow(max(dot(reflect(normalize(normal + n1), vec3(0, 1, 0)), viewVec), 0.0), 64.0);\n        if (spec > 0.0) {\n            normal = normalize(normal + n1);\n        }\n\n        vec3 snowColor = vec3(0.8, 0.9, 0.95) * 1.7;\n        float diffuse = max(normal.y, 0.0) * 0.5;\n\n        vec3 H = normalize(vec3(0, 1, 0) + normal * 0.6);\n        vec3 VdotH = pow(max(0.0, dot(viewVec, -H)), 0.25) * 0.25 * snowColor;\n\n        float height = texture(iChannel0, worldPos.xz * 0.05).x;\n\n        // Output to screen\n        fragColor = vec4(diffuse * snowColor + VdotH + spec,1.0);\n    }\n    \n    const float MARCH_SIZE = 0.05;\n    float boxT = 0.0;\n    vec3 currentPos;\n    bool intFound = false;\n    bool tex = false;\n    float size = 0.0;\n    vec3 color;\n    vec3 normal;\n    for (int i = 0; i < 700; ++i) {\n        if (boxT > t) {\n            break;\n        }\n        boxT += MARCH_SIZE;\n        currentPos = cameraPos + viewVec * boxT;\n        if (sdBox(currentPos, vec3(1, 1, 1)) < 0.0) {\n            intFound = true;\n            size = 1.0;\n            color = vec3(0.5, 0.1, 0.1);\n            normal = calcNormalBox(currentPos, vec3(1, 1, 1));\n            break;\n        }\n        \n        if (sdBox(currentPos - vec3(4.0, 0, 0), vec3(1, 2, 1)) < 0.0) {\n            intFound = true;\n            size = 2.0;\n            color = vec3(0.0, 0.6, 0.0);\n            normal = calcNormalBox(currentPos - vec3(4.0, 0, 0), vec3(1, 2, 1));\n            break;\n        }\n        \n        if (sdBox(currentPos - vec3(0.0, 0, 4.0), vec3(2, 1, 1)) < 0.0) {\n            intFound = true;\n            size = 1.0;\n            color = vec3(0.0, 0.6, 0.0);\n            tex = true;\n            normal = calcNormalBox(currentPos - vec3(0.0, 0.0, 4.0), vec3(2, 1, 1));\n            break;\n        }\n    }\n    if (intFound) {\n        float phi = atan(currentPos.y, currentPos.x);\n        float theta = acos(currentPos.z / length(currentPos));\n        vec3 star = texture(iChannel2, vec2(phi, theta) * 0.1).xxx;\n        if (tex) {\n            color = texture(iChannel3, vec2(phi / 3.14, theta / 3.14)).xyz;\n            star = vec3(0.0);\n        }\n        if (min(min(abs(currentPos.x), abs(currentPos.y)), abs(currentPos.z)) < 0.15 * size) {\n            color = vec3(0.7, 0.7, 0.1) * 2.0;\n            star = vec3(0.0);\n        }\n        fragColor.xyz = color * (normal.y + 0.5) / 1.5 + star;\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,0.0);\n    \n    {\n        int y = min(int(fragCoord.y) - 10, int(iResolution.y - fragCoord.y) - 10);\n        vec2 uv = vec2(int(fragCoord.x) % 100 - 30, y) / 5.0;\n        int tm = int(iTime) + int(fragCoord.x) / 100;\n        if (length(uv) < 1.0) {\n            fragColor = vec4(tm % 2, (tm + 1) % 2, 0.0, 1.0);\n        } else if (length(uv) < 8.0) {\n            fragColor = vec4(tm % 2, (tm + 1) % 2, 0.0, pow(1.0 - length(uv) / 8.0, 2.0));\n        }\n    }\n    \n    {\n        int x = min(int(fragCoord.x) - 10, int(iResolution.x - fragCoord.x) - 10);\n        vec2 uv = vec2(x, int(fragCoord.y) % 100 - 30) / 5.0;\n        int tm = int(iTime) + int(fragCoord.y) / 100;\n        vec4 col;\n        if (length(uv) < 1.0) {\n            col = vec4(tm % 2, (tm + 1) % 2, 0.0, 1.0);\n        } else if (length(uv) < 8.0) {\n            col = vec4(tm % 2, (tm + 1) % 2, 0.0, pow(1.0 - length(uv) / 8.0, 2.0));\n        }\n        if (col.w > fragColor.w) {\n            fragColor = col;\n        }\n    }\n}","name":"Buffer C","description":"","type":"buffer"}]}