{"ver":"0.1","info":{"id":"NlK3RD","date":"1637268193","viewed":151,"name":"FEZ Shader - Rain / Clouds","username":"sterlingsowards","description":"Another Fez inspired shader, this one drawing inspiration from a section in the game that flickers randomly between daytime and night time.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["stars","rain","night","flicker","scroll","videogame","flash","day","fez"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NUM_LAYERS 3.\n#define WIDTH .008\n#define ZOOM_FAR 10.\n#define ZOOM_CLOSE 5.\n#define NUM_RAIN_LAYERS 10.\n#define RAIN_SPEED 2.\n#define RAIN_WIDTH .007\n#define RAIN_LENGTH .3\n#define CLOUD_LAYERS 4.\n#define CLOUD_ZOOM_CLOSE 1.\n#define CLOUD_ZOOM_FAR 1.5\n\nfloat rand( float n )\n{\n    return fract(sin(n * 52.48965902) * 247.1294857);\n}\n\nfloat rainLayer( vec2 uv, float layer )\n{\n    vec2 gv;\n    gv.x = fract((uv.x + iTime * .04 * (NUM_LAYERS + 1.)) * 5.)-.5;\n    float x_id = floor((uv.x + iTime * .04 * (NUM_LAYERS + 1.)) * 5.);\n    \n    gv.y = fract((uv.y + iTime * RAIN_SPEED) * 2.);\n    float y_id = floor((uv.y + iTime * RAIN_SPEED) * 2.);\n    \n    // randomly offset the raindrop\n    // x can range + or - .9\n    // y can range 0 to 1-RAIN_LENGTH\n    float n = rand(58. * x_id + 2.465 * y_id + 9.465 * layer);\n    vec2 offset = vec2(1.8 * n - 1., (1.-RAIN_LENGTH) * fract(n * 79.));\n    gv -= offset;\n    \n    float a = min(smoothstep(RAIN_WIDTH + 1./iResolution.x, RAIN_WIDTH, abs(gv.x)), smoothstep(RAIN_LENGTH, 0., gv.y));\n    a *= smoothstep(-.001, 0., gv.y);\n    //a += abs(gv.x) < .01 || abs(gv.y) < .01 ? .2  : 0.;\n    return a;\n}\n\nfloat starLayer( vec2 uv, float zoom )\n{\n    // Create grid coordinates based on zoom\n    vec2 gz = fract(uv * zoom) - .5;\n    float id = floor(uv * zoom).x * 67. + floor(uv * zoom).y * 13.;\n    \n    return min(smoothstep(WIDTH + 1./iResolution.x, WIDTH, abs(gz.x)), smoothstep(WIDTH + 1./iResolution.y, WIDTH, abs(gz.y)));\n}\n\nfloat cloud( vec2 uv, float n)\n{\n    uv *= 1.7;\n    float a;\n    // Each cloud is a rounded box with a random height between 1 and 2\n    float height = rand(n)+1.;\n    n = fract(n * 97.);\n    vec2 offset = vec2(0., 0.1);\n    float d = length(max(abs((uv - offset)*vec2(.5, height)),.2) - .2);\n    a = smoothstep(0.55, 0.5, abs(d / .6) * 5.0);\n    \n    // Then there's a cloud that's going to be a rounded box that's shorter and skinnier\n    offset = vec2(rand(n)*.6-.3, -.14*(2.7-height));\n    n = fract(n * 73.);\n    height = rand(n) * 2. + 4.;\n    n = fract(n * 32.);\n    float width = rand(n)+.5;\n    n = fract(n * 21.);\n    d = length(max(abs((uv - offset)*vec2(width, height)),.2) - .2);\n    a = max(a, smoothstep(0.55, 0.5, abs(d / .6) * 5.0));\n    \n    // little bit of cloud connecting the two\n    offset.y += .1;\n    offset.x *= .9;\n    height = 2.;\n    width = 4.;\n    d = length(max(abs((uv - offset)*vec2(width, height)),.2) - .2);\n    a = max(a, smoothstep(0.55, 0.5, abs(d / .6) * 5.0));\n    \n    a *= 1.5*(uv.y + .7);\n    return clamp(pow(a, 8.), 0., 1.);\n}\n\nfloat cloudLayer( vec2 uv, float zoom, float layer )\n{\n    float a;\n    vec2 gv = fract(uv * zoom)-.5;\n    float id = floor(uv * zoom).x * 46.23 + floor(uv * 1.5).y * 9.567;\n    // calculate random offset based on grid coordinate\n    float n = rand(id + 24.354 * layer);\n    vec2 offset = vec2((n*2.-1.) * .2, (fract(n * 25.)*2.-1.) * .3);\n    a = cloud(gv-offset, n);\n    return smoothstep(.5, .50001, n) * a;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1) irrespective of aspect ratio\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    \n    vec3 night_col = vec3(0.043, 0.003, 0.074);\n    \n    float timeOffset = iTime * .04;\n    \n    // Star Layers\n    for (float i = 0.; i < NUM_LAYERS; i++) {\n        // Calculate the zoom factor\n        float zoom = mix(ZOOM_FAR, ZOOM_CLOSE, i/(NUM_LAYERS - 1.));\n        \n        // Calculate a parallax offset\n        vec2 offset = vec2((i+1.) * timeOffset, 0.);\n        \n        // Draw the star layer\n        float sl = starLayer(uv + offset, zoom) * (i + 1.)/(NUM_LAYERS);\n        night_col = sl + night_col * (1. - sl);\n    }\n    \n    // Rain Layer\n    for (float i = 0.; i < NUM_RAIN_LAYERS; i++) {\n        vec3 rainColor = vec3(0.180, 0.192, 0.325);\n        float rl = rainLayer(uv, i);\n        night_col = rainColor * rl + night_col * (1. - rl);\n    }\n    \n    vec3 day_col = mix(vec3(0.486, 0.988, 0.988), vec3(0.121, 0.956, 1.), uv.y);\n    \n    // Cloud Layers\n    for (float i = 0.; i < CLOUD_LAYERS; i++) {\n        float zoom = mix(CLOUD_ZOOM_FAR, CLOUD_ZOOM_CLOSE, i/(CLOUD_LAYERS - 1.));\n        vec2 offset = vec2(iTime * .01 * (i+1.), 0.2 * (i / (CLOUD_LAYERS - 1.)));\n        float cl = cloudLayer(uv+offset, zoom, i) * (i + 1.) / (CLOUD_LAYERS);\n        day_col = cl * vec3(1.) + day_col * (1. - cl);\n    }\n\n    // Decide if we're looking at day or night\n    // 1 = night, 0 = day\n    float day_night = smoothstep(.2, .2001, rand(floor(iTime*2.)+76.83));\n    vec3 col = night_col * day_night + day_col * (1. - day_night);\n    // Output to screen\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}