{"ver":"0.1","info":{"id":"wdl3WM","date":"1546552326","viewed":189,"name":"[Twitch] Harvest of pills","username":"Flopine","description":"Coded during a live session on Twitch (my first, yay! :D) and heavily inspired by the Matrix movie ;) \nYou can see the Twitch video here : (sorry for my english) https://www.twitch.tv/videos/358355842","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","matrix","twitch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui and Coyhot for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Cookie Collective rulz \n\n#define ITER 64.\n#define time iTime\n#define PI 3.141592\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a), cos(a));}\n\n\nvec2 moda (vec2 p, float per)\n{\n  float a = atan(p.y,p.x);\n  float l = length(p);\n  a = mod(a-per*0.5, per) - per*0.5;\n  return vec2(cos(a), sin(a))*l;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat cyl (vec2 p, float r)\n{return length(p)-r;}\n\nfloat sbox(vec3 p, vec3 c)\n{\n  vec3 q = abs(p)-c;\n  return min(max(q.x,max(q.y, q.z)), 0.)+length(max(q, 0.));\n}\n\nfloat cocoon (vec3 p)\n{\n  float d = length(vec3(p.x*0.5, p.y, p.z))-0.5;\n  // Onion skin operation by iq\n  d = abs(d)- 0.02;\n  return max(- sbox(vec3(p.x, p.y-0.7, p.z),vec3(.8)),d);\n}\n\nfloat g1 = 0.;\nfloat egg (vec3 p)\n{\n  float d = length(vec3(p.x*0.5, p.y, p.z))- 0.45;\n  g1 = 0.01/(0.01+d*d);\n  return d;\n}\n\nfloat cocoons (vec3 p, float spread)\n{\n  p.xz = moda(p.xz, PI/7.);\n  p.x -= spread;\n  float d = min(egg(p), cocoon(p));\n  return d;\n}\n\nfloat g2 = 0.;\nfloat helix(vec3 p, float spread)\n{\n  p.xz *= rot(time*0.5);\n   p.xz *= rot(p.y*0.5);\n  p.xz = moda(p.xz, 2.*PI/5.);\n  p.x -= spread;\n  float d = cyl(p.xz, 0.5);\n  g2 = 0.01/(0.01+d*d); \n  return d;\n}\n\nfloat towers (vec3 p)\n{\n  vec3 pp = p;\n  float per = 1.7;\n  float width_tower = 3.;\n\n  float tower = cyl(p.xz, width_tower);\n  float h = helix(p, width_tower);\n\n  float id = floor(p.y/per);\n  p.y = mod(p.y, per)-per*0.5;\n\n  float t1 = fract(time*0.5);\n  float t0 = floor(time*0.5);\n\n  t1 = pow(t1, 4.);\n  float animation = PI/7.*(t0+t1);\n\n  if (mod (id, 2.) == 0.) \n  {\n    p.xz *= rot(PI/2.);\n    p.xz *= rot(-animation);\n  }\n  else p.xz *= rot(animation);\n  return smin(h,min(cocoons(p, width_tower + 1.), tower), 0.2);\n}\n\nfloat SDF (vec3 p)\n{\n    float per = 12.;\n    p.xz = mod(p.xz-per*0.5, per) - per*0.5;\n  \treturn towers(p);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    vec3 ro = vec3(-5.,0.001, -8.); vec3 p = ro;\n    vec3 rd = normalize(vec3(uv,1.));\n    float shad = 0.;\n\n    for (float i = 0.; i<ITER; i++)\n    {\n        float d = SDF(p);\n        if (d<0.001)\n        {\n            shad = i/ITER;\n            break;\n        }\n        p += d*rd*0.5;\n    }\n    float t = length(ro-p);\n    vec3 col = vec3(shad)*0.6;\n    col += g1 * vec3(1.,0.,0.);\n    col += g2*vec3(0.,0.5,0.7)*2.;\n    col = mix(col, vec3(0.1,0.2,0.1), 1.-exp(-0.001*t*t));\n  \tfragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}