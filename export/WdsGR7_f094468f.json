{"ver":"0.1","info":{"id":"WdsGR7","date":"1545580749","viewed":229,"name":"try fbm noise 02","username":"cailuming","description":"Still, the noise function doesn't have analytic normals, and one more thing is that something wrong with the striated sky, I have no idea about this","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["noise","fbm","volumetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRr","filepath":"/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","previewfilepath":"/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define pi 3.1415926\n\n\nfloat h_cube = 0.;\n\nstruct Ray {\n   vec3 o;\n   vec3 d;\n};\n\nmat2 rot2D(float a){\n   float c = cos(a);\n   float s = sin(a);\n   return mat2(c,s,-s,c); \n}\n\nmat3 rot3D(vec4 a){\n   float c  = cos(a.w);\n   float s  = sin(a.w);\n   float rc = 1.0-c;\n   \n   float m00 = a.x*a.x*rc+c;\n   float m01 = a.y*a.x*rc+a.z*s;\n   float m02 = a.z*a.x*rc-a.y*s;\n   \n   float m10 = a.x*a.y*rc-a.z*s;\n   float m11 = a.y*a.y*rc+c;\n   float m12 = a.z*a.y*rc+a.x*s;\n   \n   float m20 = a.x*a.z*rc+a.y*s;\n   float m21 = a.y*a.z*rc-a.x*s;\n   float m22 = a.z*a.z*rc+c;\n    \n   return mat3(\n      m00,m01,m02,\n      m10,m11,m12,\n      m20,m21,m22\n   ); \n}\n\n\nfloat hash1(float x){\n    \n\treturn fract(sin(dot(vec2(x),vec2(pi,2.73461)))*327672.0);\n}\n\nfloat hash1(vec2 v){\n   return fract(sin(dot(v,vec2(1623713,1241701)))*3267137.0);\n}\n\nvec2 hash2(vec2 v){\n   float x =  fract(sin(dot(v,vec2(1.4623713,0.734566)))*100000.0*pi);\n    \n   float y =  fract(sin(dot(v,x*vec2(0.923713,-0.7441701)))*100000.0*pi);\n    \n   return vec2(x,y);\n}\n\nvec3 hash3(vec3 v){\n   float x =  fract(sin(dot(v,vec3(1.4623713,0.734566,0.334566)))*100000.0*pi);\n   float y =  fract(sin(dot(v,x*vec3(0.923713,-0.7441701,-0.334566)))*100000.0*pi);\n   float z =  fract(sin(dot(v,y*vec3(-0.223713,1.4441701,0.634566)))*100000.0*pi);\n    //*rot3D(vec4(0.5,0.5,0,iTime*0.1+y))\n   return vec3(x,y,z);\n}\n\n\nfloat curve_cubic(float v){\n   return v*v*(3.0-2.0*v);\n}\n\nvec2 curve_cubic(vec2 v){\n   return v*v*(3.0-2.0*v);\n}\n\nfloat curve_pro(float v){\n   return v*v*v*(v*(6.0*v-15.0)+10.0);\n}\n\nvec2 curve_pro(vec2 v){\n   return v*v*v*(v*(6.0*v-15.0)+10.0);\n}\n\nvec3 curve_pro(vec3 v){\n   return v*v*v*(v*(6.0*v-15.0)+10.0);\n}\n\n\nvec3 getColor(float v){\n   float r = cos((v-0.78)*pi*1.66);\n   float g = cos((v-0.58)*pi*1.66);\n   float b = cos((v-0.28)*pi*1.66);\n   return vec3(r,g,b); \n}\n\n    \nfloat noise1D(float x){\n   float p  = floor(x);\n   float f  = fract(x); \n    \n   float v1 = hash1(p);\n   float v2 = hash1(p+1.0);\n    \n   f  = curve_pro(f);\n    \n   return mix(v1,v2,f); \n}\n\nfloat noise2D(vec2 v){\n   vec2 p = floor(v);\n   vec2 f = fract(v); \n   vec2 e = vec2(1,0);\n    \n   vec2 h00 = hash2(p);\n   vec2 h01 = hash2(p+e.xy);\n   vec2 h10 = hash2(p+e.yx);\n   vec2 h11 = hash2(p+e.xx);\n     \n   float d00 = dot(h00,f);\n   float d01 = dot(h01,f-e.xy);\n   float d10 = dot(h10,f-e.yx);\n   float d11 = dot(h11,f-e.xx);\n    \n   f = curve_pro(f);\n   \n   return mix(mix(d00,d01,f.x),mix(d10,d11,f.x),f.y); \n}\n\n\n// 3d noise ,inspired by iq ,but without the gradient\nfloat noise3D(vec3 p){\n   vec3 x000 = floor(p);\n   //evaluate the eight corner first \n   vec3 x001 = x000+vec3(0,0,1);\n   vec3 x010 = x000+vec3(0,1,0);\n   vec3 x011 = x000+vec3(0,1,1);\n   \n   vec3 x100 = x000+vec3(1,0,0);\n   vec3 x101 = x000+vec3(1,0,1);\n   vec3 x110 = x000+vec3(1,1,0);\n   vec3 x111 = x000+vec3(1,1,1);\n   \n   // get the interpolation coe  \n   vec3 cp  = fract(p);\n   \n   //get each random vector of the corner \n   vec3 v000 = hash3(x000);\n   vec3 v001 = hash3(x001);\n   vec3 v010 = hash3(x010);\n   vec3 v011 = hash3(x011);\n   vec3 v100 = hash3(x100);\n   vec3 v101 = hash3(x101);\n   vec3 v110 = hash3(x110);\n   vec3 v111 = hash3(x111);\n    \n   //do the projection \n   float d000 = dot(v000,p-x000);\n   float d001 = dot(v001,p-x001);\n   float d010 = dot(v010,p-x010);\n   float d011 = dot(v011,p-x011);\n    \n   float d100 = dot(v100,p-x100);\n   float d101 = dot(v101,p-x101);\n   float d110 = dot(v110,p-x110);\n   float d111 = dot(v111,p-x111);\n    \n   //interpolation curve vector \n   cp = curve_pro(cp);\n   \n    \n   d000 = mix(d000,d010,cp.y);\n   d100 = mix(d100,d110,cp.y);\n   \n   d001 = mix(d001,d011,cp.y);\n   d101 = mix(d101,d111,cp.y);\n   \n   return mix(mix(d000,d100,cp.x),mix(d001,d101,cp.x),cp.z);\n    \n}\n\nfloat fbm1(float x){\n   float freq = 0.5;\n   float am   = 1.0;\n   float ret  = 0.0;\n   \n   for(int i=0;i<5;i++){\n       ret+=noise1D(x*freq)*am;\n       freq *=2.0;\n       am   *=0.5;\n   }\n    \n   return ret; \n}\n\nfloat fbm2(vec2 x){\n   float freq = 0.5;\n   float am   = 5.0;\n   float ret  = 0.0;\n    \n   for(int i=0;i<9;i++){\n       ret+=noise2D(x*freq)*am;\n       freq *=2.;\n       am   *=.4;\n       x    *=rot2D(freq);\n   } \n    \n   return ret; \n}\n\nfloat fbm3(vec3 x){\n   float freq = 0.5;\n   float am   = 1.0;\n   float ret  = 0.0;\n   x*=0.3;\n   for(int i=0;i<8;i++){\n       //ret+=noise3D(x*freq)*am;\n       ret+=texture(iChannel1,x*freq).x*am;\n       freq *=2.0;\n       am   *=.4;\n   } \n    \n   return ret; \n}\n \n\nvec2 ground(vec3 p ,vec3 c){\n   p-=c;\n\n   float r = fbm2(p.xz*0.1)*3.4;\n   \n   return vec2(p.y-r,0.0);\n}\n\n\nvec2 cube(vec3 p ,vec3 c){\n    p-=c;\n    vec3 axis = normalize(vec3(1,1,0.5));\n    p*=rot3D(vec4(axis,iTime));\n    float r =0.3;\n    float s =0.5;\n    \n    vec3 f = vec3(clamp(p.x,-s,s),clamp(p.y,-s,s),clamp(p.z,-s,s));\n    \n    return vec2(length(p-f)-r,2.0);\n}\n\n\nvoid cmp(inout vec2 a,vec2 b){\n   a = a.x>b.x? b:a;\n}\n\nvec2 map(vec3 p){\n   vec2 r = vec2(1000.0);\n\n   cmp(r,ground(p,vec3(0,-2,-iTime*2.)));\n   cmp(r,cube(p,vec3(0.,h_cube+texture(iChannel0,vec2(0.2,0.5)).x,0)));\n    \n   return r;\n}\n\nvec3 grad(vec3 p){\n   float m = map(p).x;\n   vec2 e= vec2(1,0)*0.0001; \n   return normalize(vec3(map(p+e.xyy).x-m,map(p+e.yxy).x-m,map(p+e.yyx).x-m)); \n}\n\nvoid flash(Ray r,vec3 lp,inout vec3 col){\n    vec3 p = r.o+r.d*100.;\n    float s = 5.0;\n    float x = p.y*0.1;\n    float t = iTime *40.0;\n    float m = mod(t,pi*4.0);\n    float d = floor(t/pi/4.0); \n    float h = (hash1(d)*2.0-1.0)*100.0;\n    vec2 f = vec2(fbm1(x+hash1(d))*s,p.y);\n    vec3 c = getColor(0.8+smoothstep(0.2,0.4,hash1(d)));\n    if(mod(h,10.0)!=5.) return ;\n    \n    p.x-= h;\n    \n    float v = 0.3*clamp(sin(m),0.,1.0)/length(p.xy-f);\n    v = pow(v,0.3);  \n    col += (c+0.5)*v;\n     \n}\n\n\nvec3 flashLight(){\n   \n    float s = 5.0;\n  \n    float t = iTime *40.0;\n    float m = mod(t,pi*4.0);\n    float d = floor(t/pi/4.0); \n    float h = (hash1(d)*2.0-1.0)*100.0;\n    \n    vec3 c = vec3(0);\n    if(mod(h,10.0)!=5.) return vec3(0);\n    c = getColor(0.8+smoothstep(0.2,0.4,hash1(d)));\n    return c;\n}\n\nvoid render(Ray r,vec3 lp,inout vec3 col,vec3 fc, vec2 res,float ldens){\n    vec3 fogc = ldens*vec3(0.6,0.7,0.9);\n    if(res.x>128.0){\n       col +=fogc; \n       return;\n    }\n    \n    vec3 p = r.o+r.d*res.x;\n    vec3 n = grad(p);\n    vec3 ld = normalize(lp); \n    vec3 hv = normalize(ld-r.d); \n    float nl = smoothstep(0.,1.,dot(ld,n));\n    \n    float fl = 0.3+0.7*pow(1.0-clamp(dot(hv,n),0.,1.),5.);\n    \n    if(res.y==0.){\n       col +=mix(vec3(nl+fl)*fc,fogc,0.8);\n    \n    }else if(res.y==2.){\n       col +=ldens;\n    }\n}\n\n\nvoid rayMarch(inout Ray r,inout vec2 res,inout vec3 col,vec3 lp){\n    float t = 0.0;\n    vec2  h = vec2(0);\n    vec3  p = vec3(0);\n    vec3  p1 = vec3(0);\n    vec3  t1 = vec3(iTime*0.4,0,iTime*0.4)*0.5; \n    vec3  fc = vec3(0); \n    \n    float d =0.0;\n    float v =0.0;\n    float t2 =0.0;\n    for(int i=0;i<128;i++){\n        p = r.o+r.d*t;\n        h = map(p);\n        t+=h.x; \n        p1 =r.o+r.d*t2;\n        v = fbm3(vec3(p1)*.6+t1)/26.0;\n        d+= clamp(v,0.0,1.0);\n        t2+=0.1;\n        \n        if(t>=128.){\n           flash(r,lp,col);\n           \n           break;\n        }\n        \n        if(h.x<=0.0001){\n            break; \n        }\n    }\n    \n    fc = flashLight();\n    \n    render(r,lp,col,fc,vec2(t,h.y),d);\n    \n}\n\n\nvoid setCamera(inout Ray r,vec3 eye,vec3 tar,vec3 uv){\n   vec3 look = normalize(tar-eye);\n   vec3 right = normalize(cross(vec3(0,1,0),look));\n   vec3 up    = normalize(cross(look,right)); \n   r.o = eye;\n\n   r.d = normalize(uv.x*right+uv.y*up+look);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 cuv = uv - vec2(0.5);\n    cuv.x*=iResolution.x/iResolution.y; \n    // Time varying pixel color\n    vec3 col = vec3(0);\n    vec3 tar = vec3(0,0.5, 1);\n    float h  = fbm2(vec2(0,-6.0+iTime*2.)*0.1)*3.+1.0;\n    h_cube = fbm2(vec2(0,iTime*2.)*0.1)*3.+0.2;\n    \n    vec3 eye = vec3(0,h,-6);\n    vec3 lp  = vec3(.0,10,100.0);\n    vec2 res = vec2(0);\n    Ray r;\n    \n    setCamera(r,eye,tar,vec3(cuv,0));\n    rayMarch(r,res,col,lp);\n    \n        \n    col = smoothstep(0.,1.,col);\n    col = pow(col,vec3(1.7));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}