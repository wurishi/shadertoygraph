{"ver":"0.1","info":{"id":"XtyyDh","date":"1536084667","viewed":887,"name":"procedural solid wood","username":"antovsky","description":"Center shape shows a 3D slice through the solid texture.\nFloorboards are created by taking slices through random regions of the same volume.\nDifferent textures (straight vs knotty) can be obtained by taking slices through different parts of the wood.","likes":21,"published":1,"flags":0,"usePreview":0,"tags":["procedural","wood","solidtexture"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define TAU (2.0*PI)\n\nvec4 quat(vec3 axis, float angle) { return vec4(axis*sin(angle*0.5), cos(angle*0.5)); }\nvec4 quat_i() { return vec4(0,0,0,1); }\nvec4 quat_conj(vec4 q) { return vec4(-q.xyz,q.w); }\nvec4 quat_mul(vec4 a, vec4 b) { return vec4(cross(a.xyz,b.xyz) + a.xyz*b.w + b.xyz*a.w, a.w*b.w - dot(a.xyz,b.xyz)); }\nvec3 quat_mul(vec4 q, vec3 v) { return v-2.0*cross(cross(q.xyz,v)-q.w*v,q.xyz); }\n\nfloat hash(vec2 p)  // replace this by something better\n{\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat noise( in float p )\n{\n    return noise(vec2(p, 0.0));        \n}\n\n\nfloat hash(vec3 p)  // replace this by something better\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat luma(vec3 c) {\n\treturn c.r*0.2 + c.g*0.7 + c.b*0.1;\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(p+vec3(0,0,0)), \n                        hash(p+vec3(1,0,0)),f.x),\n                   mix( hash(p+vec3(0,1,0)), \n                        hash(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(p+vec3(0,0,1)), \n                        hash(p+vec3(1,0,1)),f.x),\n                   mix( hash(p+vec3(0,1,1)), \n                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat sdSphere(vec3 pos, float rad) {\n\treturn length(pos) - rad;\n}\nfloat sdFloor(vec3 pos) {\n\treturn pos.y;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat smin(float a, float b, float k) {\n\tfloat x = exp(-a*k) + exp(-b*k);\n    return -log(x)/k;\n}\nfloat wave() {\n\treturn (1.0 + sin(iTime))*0.5;\n}\nvoid repeat(inout vec3 pos, float s) {\n\tpos.xz = mod(pos.xz, s)-s*0.5;\n}\nfloat field(vec3 pos) {\n    float f = 10000.0;\n\n    f = min(f, sdFloor(pos - vec3(0,-1,0)));\n    f = min(f, sdBox(pos, vec3(1.0)));\n    //f = min(f, sdSphere(pos, 1.0));\n   \t//f = min(f, sdCappedCylinder(pos.xzy, vec2(1,1)));\n    \n    return f;\n}\n\nfloat trace(vec3 ray_ori, vec3 ray_dir,\n            float t_min, float t_max,\n            int max_iter) {\n\t\n    float t = t_min;\n    for (int i = 0; i < max_iter; ++i) {\n\t\tvec3 pos = ray_ori + ray_dir*t;\n        float f = field(pos);\n        if (f < 0.001) return t;\n        if (t > t_max) return -1.0;\n        t += f;\n    }\n    return -2.0;\n}\n\nvec3 shade(vec3 pos, vec3 nor, vec3 sur_col,\n           vec3 lig_dir, vec3 lig_col,\n           vec3 vie) {\n\tfloat ndotl = max(0.0, dot(nor,lig_dir));\n    float vdotr = max(0.0, dot(vie,reflect(lig_dir,nor)));\n    vec3 dif = sur_col * lig_col;\n    vec3 spe = lig_col * vdotr*0.5;\n    vec3 amb = sur_col*lig_col*0.03;\n    \n    float t = trace(pos,lig_dir, 0.1,5.0,50);\n    float sdw = t > 0.0 ? 0.0 : 1.0;\n    dif *= sdw;\n    spe *= sdw;\n    return sur_col;\n    //return (dif+spe) * ndotl + amb;\n    //return (nor+1.0)*0.5;\n}\n\nvec3 normal(vec3 pos) {\n\tfloat e = 0.001;\n    vec3 n;\n    n.x = (field(pos+vec3(e,0,0)) - field(pos-vec3(e,0,0)))/(2.*e);\n    n.y = (field(pos+vec3(0,e,0)) - field(pos-vec3(0,e,0)))/(2.*e);\n    n.z = (field(pos+vec3(0,0,e)) - field(pos-vec3(0,0,e)))/(2.*e);\n    return n;\n}\n\nvec3 texture_wood(vec3 pos) {\n    pos = quat_mul(quat(vec3(1,0,0),-0.0), pos);\n   \t//pos.z -= 1.0;\n    vec2 core = vec2(cos(pos.z), sin(pos.z))*0.1;\n    pos.xy -= core;\n    \n\tfloat r = length(pos.xy);\n    float a = (TAU/2.0 + atan(pos.x,pos.y)) / TAU;\n    \n    float r_noise = noise(vec2(cos(a*TAU*2.0), sin(a*TAU*2.0)));\n    r_noise += noise(vec2(10.0) + vec2(cos(a*TAU*4.0), sin(a*TAU*4.0))) * 0.5; // squigglyness\n    r_noise += noise(vec2(100.0) + vec2(cos(a*TAU*8.0), sin(a*TAU*8.0))) * 0.4; // squigglyness\n    r_noise += noise(vec2(1000.0) + vec2(cos(a*TAU*16.0), sin(a*TAU*16.0))) * 0.2; // squigglyness\n    \n    r_noise += noise(pos.z*0.5)*3.0; // knottyness\n    \n    r_noise *= noise(r*3.0)*5.0; // whorlyness\n    r += r_noise*0.05*clamp(r,0.0,1.0); // scale and reduce at center\n    \n    vec3 col = vec3(1.0,0.8,0.35);\n    //float c = 0.5 + 0.5*sin(r*100.0); // 100 rings per meter ~ 1cm rings\n    float c = fract(r*5.0);\n    //c = smoothstep(0.0,1.0, c/0.15) * smoothstep(1.0,0.0, (c-0.15)/0.85);\n    c = smoothstep(0.0,1.0, c/0.15) * smoothstep(1.0,0.0, sqrt(clamp((c-0.15)/0.85,0.0,1.0)));\n    //c = smoothstep(0.0,1.0, c/0.15) * smoothstep(1.0,0.0, pow(clamp((c-0.15)/0.85,0.0,1.0), 0.25));\n    col = mix(col, vec3(0.5,0.25,0.1)*0.4, c); // ring gradient\n    col = mix(col, col*0.8, noise(r*20.0)); // ring-to-ring brightness\n    \n    return col;\n}\n\nvec3 material(vec3 pos) {\n    vec3 P = pos;\n    if (pos.y < -0.99) {\n        \n     \t\n        float s = 6.0;\n        pos.z /= s;\n        vec2 f = floor(pos.xz);\n        pos.z += mod(f.x, 2.0)*0.5;\n        f = floor(pos.xz);\n        vec2 c = fract(vec2(pos.x,pos.z));\n        c = (c-0.5)*2.0;\n        c.y *= s;\n       \n        vec2 b = vec2(1.0,s);\n        vec2 d = abs(c) - b;\n \t\tfloat l = min(max(d.x,d.y),0.0);\n        l = smoothstep(0.0,0.05, -l)*0.9 + 0.1;\n        //return vec3(l);\n        //return abs(vec3(f.x,f.y,0)*0.1);\n        //vec3 w = texture_wood(pos + vec3(sin(f.x),sin(f.y),f.y));\n        //vec3 w = texture_wood(pos+vec3(0,sin(iTime),0));\n        float idx = f.y*10.0+f.x*10.0;\n        vec3 w = texture_wood(vec3(c.x,0,c.y) + vec3(vec2(cos(idx*0.1),sin(idx*0.1))*sin(idx),idx));\n        //w = mix(w, vec3(luma(w)), mix(0.2, 0.4, 0.5+0.5*noise(f)));\n        w = mix(w, vec3(0.7), mix(0.2, 0.4, 0.5+0.5*noise(f)));\n        w *= mix(0.7, 1.0, 0.5+0.5*noise(f));\n        //return vec3(mod(f.x, 2.0));\n        return w * l;\n        //float l = length(c);\n        //return texture_wood(pos + vec3(f.x,f.y*3.0,f.x)*10.0);\n        //return vec3(0,0,f.y/10.0);\n\t\t//return vec3(c.x,c.y,f.x/10.0);\n    } else {\n    \treturn texture_wood(pos);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = (uv - 0.5)*2.0;\n    float aspect = iResolution.x/iResolution.y;\n    uv.x *= aspect;\n    \n    float elev = TAU/10.0;//TAU/12.0;\n    //float azim = -TAU/12.0;\n    float azim = sin(iTime)*TAU/32.0;//-TAU/12.0;\n    vec4 rot = quat(vec3(1,0,0), elev);\n    rot = quat_mul(rot, quat(vec3(0,1,0), azim));\n    vec3 ray_ori = quat_mul(rot, vec3(0,0,3));\n    vec3 ray_dir = quat_mul(rot, normalize(vec3(uv,-1.0)));\n    \n    vec3 col = vec3(1.0,0.8,0.3);\n    \n    const float near = 0.1;\n    const float far = 10.0;\n    \n    float t = trace(ray_ori, ray_dir, near, far, 100);\n    if (t > 0.0) {\n        vec3 pos = ray_ori + ray_dir*t;\n        vec3 nor = normal(pos);\n        vec3 sur_col = material(pos);\n        vec3 lig_col = vec3(1.0,0.9,0.85);\n        vec3 lig_dir = normalize(vec3(1,1,1));\n        col = shade(pos, nor, sur_col, lig_dir, lig_col, ray_dir);\n    }\n    else if (t == -2.0) col = vec3(1,0,1);\n    \n    fragColor = vec4(pow(col,vec3(1.0/2.2)), 1.0);\n}","name":"Image","description":"","type":"image"}]}