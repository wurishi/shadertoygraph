{"ver":"0.1","info":{"id":"MflyR7","date":"1720980995","viewed":68,"name":"Rotation Construction Diagram","username":"chronos","description":"This shows a construction for iterative rotation by only using two lengths and perpendiculars","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["2d","circle","approximation","geometry","rotation","construction","diagram"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/*\n    Rotation Construction Diagram by chronos\n    ------------------------------------------------------\n    \n    Not sure why I made this, I was just doodling with some geometry :)\n    \n    \n    This shows a construction for iterative rotation by only using two lengths and perpendiculars:\n    \n    1. Draw radius of length x  ( this is the base line )\n    2. Then perpendicular line of length y from the endpoint\n    3. Then draw line from origin towards endpoint in step 2 of length x. ( This is the new base line )\n    4. repeat from step 2 using new base line\n    \n    It doesn't make use of sin/cos directly, but if you have coordinates it's kinda useless to do more than one\n    normalization, since the coordinates of the point after the first iteration is the radius * vec2(cos(angle), sin(angle))\n    that you can just put in a matrix mat2(cos, sin, -sin, cos), and use that to iteratively rotate from there.\n    So this is more of a unmarked right angle ruler kind of geometric construction :)\n*/\n\n\nconst float PI = 3.14159265;\n\nconst float line_thickness = 0.005;\nconst float dotsize = 0.015;\n\nvec3 drawcolor = vec3(1);\n\nconst vec3 drawcolor_AB    = vec3(0.1, 0.4, 0.8);\nconst vec3 drawcolor_BC    = vec3(0.1, 0.8, 0.4);\nconst vec3 drawcolor_point = vec3(0.8, 0.1, 0.4);\n\nfloat sRGBencode(float C_linear) { return C_linear > 0.0031308 ? (1.055 * pow(C_linear, 1./2.4) - 0.055) : (12.92 * C_linear); }\nvec3 sRGBencode(vec3 C_linear) { C_linear = clamp(C_linear, 0., 1.); return vec3(sRGBencode(C_linear.x), sRGBencode(C_linear.y), sRGBencode(C_linear.z)); }\n\nfloat disc(vec2 a, float r, vec2 p)\n{\n    return length(p - a) - r;\n}\n\nfloat circle(vec2 a, float r, vec2 p)\n{\n    return abs(length(p - a) - r) - line_thickness;\n}\n\nfloat seg(vec2 a, vec2 b, vec2 p)\n{\n    b-=a; p-=a;\n    return length(clamp(dot(p, b)/dot(b,b), 0., 1.) * b - p) - line_thickness;\n}\n\nfloat dash(vec2 a, vec2 b, vec2 p)\n{\n    b-=a; p-=a;\n    float dots_per_dist = 30.;\n    float scalar_proj = dot(p, b)/dot(b,b);\n    float proj = round(dots_per_dist * scalar_proj * length(b)) / (length(b) * dots_per_dist);\n    \n    float gate = mod(floor(dots_per_dist * scalar_proj * length(b)), 2.);\n    \n    proj = mix(scalar_proj, proj, gate);\n    \n    return length(clamp(proj, 0., 1.) * b - p) - line_thickness;\n}\n\n// Super hacky and bad, don't use this :)\nfloat tri(vec2 a, vec2 b, vec2 c, vec2 p)\n{\n    float dist = min(min(seg(a, b, p), seg(b, c, p)), seg(c, a, p)) + 4./iResolution.y;\n\n    b-=a; c-=a; p-=a;\n\n    float detC = determinant(mat2(b, p)); \n    float detB = determinant(mat2(p, c)); \n    float detA = determinant(mat2(c-b, p-b)); \n\n    float sgn = \n        sign(detA) == sign(detB) && sign(detB) == sign(detC)\n    ? -1. : 1.;\n\n    return sgn * dist;\n}\n\nfloat to_alpha(float ps, float sdf)\n{\n    return smoothstep(ps, -ps, sdf);\n}\n\nvec3 draw(vec3 prevcolor, float ps, float sdf, vec3 drawcolor)\n{\n    float alpha = to_alpha(ps, sdf);\n    return mix(prevcolor, drawcolor, alpha);\n}\n\nvec3 draw(vec3 prevcolor, float ps, float sdf, vec3 drawcolor, float alpha)\n{\n    alpha *= to_alpha(ps, sdf);\n    return mix(prevcolor, drawcolor, alpha);\n}\n\nvec2 rot90(vec2 v) { return vec2(-1, 1) * v.yx; } \n\nfloat anim_interp(float timestep, float substep, float loop_iteration, float subtime)\n{\n    if(timestep > loop_iteration) return 1.;\n    \n    return smoothstep(substep, substep+1., subtime);\n}\n\n#define USE_SUBDIV 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord-iResolution.xy)/iResolution.y;\n\n    float ps = 2. / iResolution.y;\n\n    vec3 color = vec3(0);\n    \n    float num_sections = 14.;\n    \n    #if USE_SUBDIV\n    float num_subdivs = 4.; // cannot be less than 3\n    \n    num_sections = pow(2., num_subdivs);\n    #endif\n    \n    float num_substeps = 9.;\n    float num_timesteps = num_sections;\n\n    //\n    // Setup time for animation\n    //\n    float time = iTime / num_substeps;\n\n    float timestep = mod(floor(time), num_timesteps);\n    float subtime  = fract(time) * num_substeps;\n    \n    //\n    // Paramters for edge sidelengths\n    // \n    float x = .75; // length of blue line, radius\n    \n        // length of green line, tangent/'height'\n        // Can put any number here, really, but using this formula ensures that it divides the circle evenly.\n        // The construction does not depend on it though.\n        // From this you can also see that the angle of the sections becomes the familiar formula:\n        // angle = atan(y/x)\n    float y = x * tan(2. * PI / num_sections);\n    \n    \n    \n    #if USE_SUBDIV\n    \n    // This essenially computes tan(angle),\n    // Which allows to get an even subdivision of the circle without using the tan() function directly ( it's ofc not faster or anything :P )\n    \n    vec2 v = vec2(0,1);\n    for(float i = 0.; i < num_subdivs-2.; i++)\n    {\n        v = normalize(v + vec2(1,0));\n    }\n    float TAN = v.y/v.x;\n    y = x * TAN;\n    \n    #endif\n    \n    vec2 base_dir = vec2(1, 0);\n    vec2 orthogonal_dir = vec2(0, 1);\n    \n    for(float i = 0.; i <= timestep; i++)\n    {        \n        // Line segment vectors, with length x, and y respectively\n        vec2 AB = base_dir * x;\n        vec2 BC = orthogonal_dir * y;\n\n        // Point positions\n        vec2 A = vec2(0, 0);\n        vec2 B = A + AB;\n        vec2 C = B + BC;\n    \n        //\n        // Animate\n        //\n        vec2 AB_animated = mix(vec2(0), AB, anim_interp(timestep, 2., i, subtime));\n        vec2 BC_animated = mix(vec2(0), BC, anim_interp(timestep, 4., i, subtime));\n    \n        float A_alpha  = .75 * anim_interp(timestep, 1., i, subtime); \n        float B_alpha  = .75 * anim_interp(timestep, 3., i, subtime); \n        float C_alpha  = .75 * anim_interp(timestep, 5., i, subtime); \n        \n        float AB_alpha = .75 * anim_interp(timestep, 1., i, subtime); \n        float BC_alpha = .75 * anim_interp(timestep, 3., i, subtime); \n        float AC_alpha = .25 * anim_interp(timestep, 6., i, subtime); \n\n        float circle_alpha = .5 * anim_interp(timestep, 7., i, subtime);\n        \n        float tri_alpha = .125 * .125 * anim_interp(timestep, 8., i, subtime);\n        \n        //\n        // Draw\n        //\n        color = draw(color, ps, tri(A, B, C, uv), drawcolor, tri_alpha);\n\n        color = draw(color, ps, circle(A, x, uv), drawcolor_AB, circle_alpha * to_alpha(ps, tri(A, B, C, uv)));\n\n        color = draw(color, ps, seg(A, A + AB_animated, uv), drawcolor_AB, AB_alpha);\n        color = draw(color, ps, seg(B, B + BC_animated, uv), drawcolor_BC, BC_alpha);\n        color = draw(color, ps, dash(A, C, uv), drawcolor, AC_alpha);\n\n        color = draw(color, ps, disc(A, dotsize, uv), drawcolor_point, A_alpha);\n        color = draw(color, ps, disc(B, dotsize, uv), drawcolor_point, B_alpha);\n        color = draw(color, ps, disc(C, dotsize, uv), drawcolor_point, C_alpha);\n        \n        //\n        // Setup next iteration:\n        //\n        \n        base_dir = normalize(C);\n        orthogonal_dir = rot90(base_dir);\n    }\n    \n    color = sRGBencode(color);\n    fragColor = vec4(color, 1);\n}","name":"Image","description":"","type":"image"}]}