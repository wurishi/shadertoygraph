{"ver":"0.1","info":{"id":"sd2cRy","date":"1643821151","viewed":140,"name":"Simple raytracing PROGER","username":"Proger","description":"simple raytracing ","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float PI = 3.14159265;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 col = vec3(1.);\n    vec3 ro = vec3(0, 0, -10);\n    vec3 rd = normalize(vec3(uv.xy, 1.));\n    vec3 cl;\n    float alb = 1.;\n    float otr = 1.;\n    float ay = iMouse.y / iResolution.y * PI * 3. - PI * 1.5;\n    float ax = iMouse.x / iResolution.x * PI * 3. - PI * 1.5;\n    rd.yz *= mrot(-ay);\n    rd.xz *= mrot(-ax);\n    ro.yz *= mrot(-ay);\n    ro.xz *= mrot(-ax);\n    for (float i = 0.; i < 3.; i++) {\n\n        float inters = 0.;\n        float min_int = 99999.;\n        vec3 norm = vec3(0);\n        //plane\n        inters = plane(ro, rd, vec3(0, 1, 0), 1.);\n        if (inters > 0.) {\n            min_int = inters;\n            norm = vec3(0, 1, 0);\n            cl = vec3(0.1, 0.1, 0.1);\n            vec3 p = ro + rd * inters;\n            if (mod(float((int(p.x + 100.5) + int(p.z + 100.5))), 2.) == 0.)\n                cl = vec3(0.2, 0.2, 0.2);\n            else\n                cl = vec3(1, 1, 1);\n            alb = 1.;\n            otr = 2.;\n        }\n        //sphere\n        inters = sphere(ro - vec3(0, 0.5, 0), rd, 1.).x;\n        vec3 point = ro - vec3(0, 0.5, 0) + rd * inters;\n        vec3 sp_n = normalize(point);\n        if (inters > 0. && inters < min_int) {\n            min_int = inters;\n            norm = sp_n;\n            cl = vec3(0.1, 1, 0.1);\n            alb = 1.;\n            otr = 1.;\n        }\n\n        inters = sphere(ro - vec3(0, 0.5, 4), rd, 1.5).x;\n        vec3 point1 = ro - vec3(0, 0.5, 4) + rd * inters;\n        vec3 sp_n1 = normalize(point1);\n        if (inters > 0. && inters < min_int) {\n            min_int = inters;\n            norm = sp_n1;\n            cl = vec3(1, 0.1, 0.1);\n            alb = 1.;\n            otr = 1.;\n        }\n\n        //box\n        vec3 box_n;\n        inters = box(ro - vec3(4, 0.5, 0), rd, vec3(1), box_n, iTime).x;\n        if (inters > 0. && inters < min_int) {\n            min_int = inters;\n            norm = box_n;\n            cl = vec3(0.1, 0.1, 1);\n            alb = 1.;\n            otr = 1.;\n        }\n        float a = -1.;\n        vec3 light = vec3(sin(a) * 5., 5, cos(a) * 5.);\n\n        if (min_int < 99999.) {\n           float sp = pow(max(dot(reflect(norm, rd), normalize(light)), 0.), 32.)*2.;\n           float df = max(dot(norm, normalize(light)), 0.1);\n            col *= ((vec3((sp+df))) * cl * alb);\n            col = pow(col, vec3(otr));\n            if (i != 0.)\n                col /= i*1.5;\n                col *= 10. / min_int;\n            ro = ro + rd * (min_int - 0.01);\n            rd = reflect(rd, norm);\n            if(otr == 2.) break;\n        }\n    }\n    if(col == vec3(1.)) col = vec3(0.7,0.7,1);\n    col = pow(col, vec3(0.45));\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"mat2 mrot(float a){\n  float c = cos(a);\n  float s = sin(a);\n  return mat2(c,-s,s,c);\n}\nvec2 box(vec3 ro, vec3 rd, vec3 boxSize, out vec3 outNormal, float theta) {\n    mat2 rot = mrot(theta);\n    ro.xz *= rot;\n    rd.xz *= rot;\n    vec3 m = vec3(1.0) / rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m) * boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    if (tN > tF || tF < 0.0) return vec2(-1.0);\n    vec3 yzx = vec3(t1.y, t1.z, t1.x);\n    vec3 zxy = vec3(t1.z, t1.x, t1.y);\n    outNormal = -sign(rd) * step(yzx, t1) * step(zxy, t1);\n    outNormal.xz = rot * outNormal.xz;\n    return vec2(tN, tF);\n\n}\nvec2 sphere(vec3 ro, vec3 rd, float r) {\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - r * r;\n    float h = b * b - c;\n    if (h < 0.0) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2(-b - h, -b + h);\n}\nfloat plane(vec3 ro, vec3 rd, vec3 p, float w) {\n    return -(dot(ro, p) + w) / dot(rd, p);\n}\n","name":"Common","description":"","type":"common"}]}