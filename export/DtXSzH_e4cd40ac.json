{"ver":"0.1","info":{"id":"DtXSzH","date":"1674246399","viewed":85,"name":"Rocks on grass","username":"ianertson","description":"Rocks on grass, with smoke/fog","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","rays","smoke","rocks","rock","stone"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define STEPS 64\n#define NEAR 0.02\n#define FAR 200.0\n\n#define SMOKE_STEPS 16.\n#define SMOKE_STEPSIZE 0.33\n\n\n#define TAU 6.283185\n#define ONE(g) clamp(g, 0.0, 1.0)\n#define T (iTime*0.3)\n\nvec3 noise(vec3 p, float seed) {\n    float x = abs(cos(seed)) + fract(seed)*10.0;\n    float y = abs(sin(seed)) + fract(x/1.6)*10.0;\n    float z = abs(tan(seed)) + fract(y/1.983715)*10.0;\n    \n    p += vec3(x, y, z);\n    \n    vec3 n0 = texture(iChannel1, p).rgb;\n    vec3 n1 = texture(iChannel1, (p+n0)*0.1).rgb;\n    vec3 n2 = texture(iChannel1, p*1.6).rgb;\n    vec3 n3 = texture(iChannel1, p*2.6).rgb;\n    vec3 n4 = texture(iChannel1, p*3.6).rgb;\n    \n    return (n0+n1+n2+n3+n4)/5.0;\n}\n\nvec3 grass(vec2 uv) {\n    vec3 col1 = vec3(0.,154.,23.) / 255.0;\n    vec3 col2 = vec3(177.,188.,85.) / 255.0;\n    vec3 n0 = texture(iChannel0, uv).rgb;\n    vec3 n1 = texture(iChannel0, (uv+vec2(0.01, -0.03))*1.5).rgb; \n    float l0 = length(n0);\n    float l1 = length(n1);\n    vec3 col = mix(col1, col2, l1);\n    return col*l0;\n}\n\nvec3 extractBumpGrass(float scale, vec2 uv, vec3 normal) {\n    vec3 color = grass(uv).rgb;\n    vec2 texelSize = 1.0 / vec2(FAR);\n    vec3 dx = grass(uv + vec2(texelSize.x, 0)).rgb - color;\n    vec3 dy = grass(uv + vec2(0, texelSize.y)).rgb - color;\n    float l = (abs(dy.r - dx.r) + abs(dx.g - dy.g)) / 2.0;\n    vec3 n = normalize(vec3(dy.r - dx.r, dx.g - dy.g, 0.033*0.6));\n    return mix(normal, normalize(normal+n), 0.5);\n}\n\nvec3 stone(vec2 uv) {\n    vec3 col1 = vec3(183.0,176.0,156.0) / 255.0;\n    vec3 col2 = vec3(99.0,102.0,106.0) / 255.0;\n    vec3 n0 = texture(iChannel0, uv).rgb;\n    vec3 n1 = texture(iChannel0, (uv+vec2(0.01, -0.03))*1.5).rgb; \n    float l0 = length(n0);\n    float l1 = length(n1);\n    vec3 col = mix(col1, col2, l1);\n    return col*l0;\n}\n\nvec3 extractBumpStone(float scale, vec2 uv, vec3 normal) {\n    vec3 color = stone(uv).rgb;\n    vec2 texelSize = 1.0 / vec2(FAR);\n    vec3 dx = stone(uv + vec2(texelSize.x, 0)).rgb - color;\n    vec3 dy = stone(uv + vec2(0, texelSize.y)).rgb - color;\n    float l = (abs(dy.r - dx.r) + abs(dx.g - dy.g)) / 2.0;\n    vec3 n = normalize(vec3(dy.r - dx.r, dx.g - dy.g, 0.033*0.6));\n    return mix(normal, normalize(normal+n), 0.3);\n}\n\n\nmat2 rot(float a) {\n    float s = sin(a); \n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\n#define ENTITY_NONE 0\n#define ENTITY_GRASS 1\n#define ENTITY_ROCK 2\n\nstruct Data {\n    vec3 point;\n    vec3 normal;\n    vec2 uv;\n    float dist;\n    int entity;\n};\n\nstruct Light {\n    vec3 pos;\n    vec3 color;\n    float strength;\n};\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat getDistCylinder(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    \n    return length(p-c)-r;\n}\n\nfloat getDistPlane(vec3 p, vec3 normal, vec3 pos) {\n    return dot(p, normal) + length(pos * normal);\n}\n\nfloat getDistSphere(vec3 p, float radius, vec3 pos) {\n    return length(p - pos) - radius;\n}\n\nfloat getDist(vec3 p, inout int entity) {\n    int num_rocks = 3;\n    \n    \n    float minRock = FAR;\n    vec3 n0 = noise(p / 32.0,  9.232151);\n    vec3 n1 = noise(p / 16.0,  9.291826);\n    \n    \n    for (int i = 0; i < num_rocks; i+= 1) {\n        float rand = fract(cos(float(i)*20.6)) * 10.0;\n        float radius = mix(0.2, 1.0, fract(rand));\n        vec3 rockPos = vec3(0.0);\n        rockPos.x += cos(rand*1.1)*radius*M_PI;\n        rockPos.z -= sin(rand*1.1)*radius*M_PI;\n        rockPos.y = (radius+0.5)+(-1.6);\n        vec3 rockP = p;\n        \n \n       \n        \n        vec3 n = ((n0 + n1) / 2.0);\n        \n        \n        rockP += n;\n        float rock = getDistSphere(rockP, radius, rockPos);\n        rock /= length(n)*3.0;\n        \n        minRock = min(minRock, rock);\n    }\n    \n    float plane = getDistPlane(p, vec3(0, 1, 0), vec3(0, -1.6, 0));\n    \n    \n    \n    entity = ENTITY_GRASS;\n    if (minRock < plane) entity = ENTITY_ROCK;\n    \n    \n    \n    return min(plane, minRock);\n    \n}\n\nfloat getDist(vec3 p) {\n    int entity = 0;\n    return getDist(p, entity);\n\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(0.1, 0.0);\n    \n    return normalize(getDist(p) - vec3(\n        getDist(p+e.xyy),\n        getDist(p+e.yxy),\n        getDist(p+e.yyx)\n    ));\n}\n\nvec2 getUv(vec3 p, in Data data, int entity) {\n    if (entity == ENTITY_ROCK) {\n        p = data.normal;\n        float u = atan(p.x, -p.z) / (2. * M_PI) + .5;\n        float v = p.y * .5 + .5;\n        return vec2(u, v);\n    }\n    vec3 uv = p / FAR;\n    \n    return (uv.xz + uv.y);\n}\n\nData getData(vec3 p) {\n    Data data;\n    data.dist = getDist(p, data.entity);\n    data.normal = getNormal(p);\n    data.uv = getUv(p, data, data.entity);\n    \n    return data;\n}\n\n\nbool march(vec3 ro, vec3 rd, inout Data data) {\n    float dist = 0.0;\n    \n    for (int i = 0; i < STEPS; i++) {\n        vec3 p = ro+rd*dist;\n        data = getData(p);\n        dist += data.dist;\n        \n        if (abs(data.dist) <= NEAR || abs(dist) >= FAR) break;\n    }\n    \n    data.dist = dist;\n    data.point = ro+rd*dist;\n    return data.dist < FAR;\n}\n\n\nfloat smokeSDF(vec3 p, vec3 rd, in Light light) {\n   // p = abs(p);\n    vec3 L = normalize(p - light.pos);\n    vec3 offset = vec3(cos(T), sin(T), sin(T+3.2918));\n    float seed = 3.29151;\n    float freq = 0.03;\n    vec3 n0 = noise((p+offset)*freq, seed);\n    vec3 n1 = noise((p-offset)*freq, seed+5.29151);\n    \n    vec3 s = mix(vec3(-1.0), vec3(1.0), n1);\n    \n    vec3 n = normalize(n0 * s);\n    \n    vec3 np = normalize(p);\n    float dotL = max(0.0, dot(np, L));\n    \n   // float sphere = getDistSphere(abs(n+p)*0.5, 2.6, vec3(0.0));\n   // n *= (0.5+sphere);\n    float dcent = length(p - vec3(0.0, 0.0, 0.0));\n    \n    float dist = (abs(dot(np, n))) * dotL;\n    \n    \n    \n    return (((p.y+n.y)-dist) - dotL) / (length(n)*3.0);\n}\n\nfloat marchSmoke(vec3 ro, vec3 rd, in Light light) {\n    float dist = 0.0;\n    float count = 0.0;\n    for (float i = 0.; i < SMOKE_STEPS; i+= SMOKE_STEPSIZE) {\n        count += 1.0;\n        vec3 p = ro+rd*dist;\n        float d = smokeSDF(p, rd, light);\n        dist += d;\n        if (abs(dist) >= FAR) break;\n    }\n    \n    dist = abs(dist);\n    return count <= 0.0 || (dist <= NEAR || dist >= FAR) ? 0.0 : abs(dist/count);\n}\n\nvec3 getRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\nvec3 render(vec3 ro, vec3 rd, in Light light) {\n    vec3 col = vec3(0.0);\n    Data data;\n    \n    \n    if (march(ro, rd, data)) {\n        vec2 uv = data.uv;\n        \n        vec3 albedo = vec3(0.0);\n        \n        vec3 normal = data.normal;\n        \n        if (data.entity == ENTITY_GRASS) {\n            float uvScale = 32.0;\n            albedo = grass(data.uv*uvScale);\n            normal = extractBumpGrass(uvScale, data.uv*uvScale, data.normal);\n        } else if (data.entity == ENTITY_ROCK) {\n            float uvScale = 32.0;\n            albedo = stone(data.uv);\n            normal = extractBumpStone(uvScale, data.uv*uvScale, data.normal);\n        }\n        \n        float distLight = distance(data.point, light.pos);\n        vec3 L = normalize(data.point - light.pos);\n        float NdotL = max(0.0, dot(normal, L));\n        float att = NdotL * (pow(light.strength, 2.0) / max(0.0001, pow(distLight, 2.0)));\n        \n        float occlusion = 0.0;\n        vec3 ocPos = light.pos;\n        Data ocData;\n        if (march(ocPos, L, ocData) && ocData.entity != data.entity && ocData.dist < distLight) {\n            occlusion = distLight / max(0.0001, ocData.dist);\n            occlusion *= 0.64;\n        }\n        \n        att *= (1.0 - occlusion);\n        \n        \n        col += albedo * att;\n    }\n    return col;\n}\n\nvec3 tonemap(vec3 col) {\n    vec3 x = col;\n    vec3 vio = vec3(0.607843, 0.149019, 0.713725);\n    float dotVio = clamp(dot(col, vio), 0.0, 1.0);\n    \n    x = clamp(\n        (x * (2.51 * x + 0.03)) /\n        (x * (2.23 * x + 1.0392) + 0.98),\n    0.0, 1.0);\n   \n    x = saturate(x, dotVio);\n    x = mix(x, pow(x, vec3(2.0)), 0.3491*pow(dotVio, 2.0));\n    x += luma(x)/6.28;\n    x = clamp(x+(x/6.28), 0.0, 1.0);\n    \n    return pow(x, vec3(0.5125));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = (fc-0.5*iResolution.xy)/iResolution.x;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 ro = vec3(0.0, 3., -10.0);\n    \n    Light light = Light(vec3(1.0, 6.0, -2.0), vec3(1.0), 8.0);\n    \n    if (iMouse.z > 0.01) {\n        ro.yz *= rot(-m.y*M_PI+1.);\n        ro.xz *= rot(-m.x*TAU);\n        ro.y = max(ro.y, 2.5);\n    } else {\n        ro.xz *= rot(T);\n    }\n    vec3 rd = getRayDir(uv, ro, vec3(0,0.,0), 1.);\n    \n    col += render(ro, rd, light);\n    \n    float smoke = marchSmoke(ro, rd, light);\n    \n    col += smoke*0.5;\n    \n    col = tonemap(col);\n\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define M_PI 3.14159265359\n\nfloat noise0(vec2 uv) {\n    uv += 0.5;\n    uv.y = fract(uv.y * 10.033415);\n    uv.x = fract(uv.x * 10.082715);\n    float a = fract(cos(uv.x*256.0))*10.0;\n    float b = fract(sin(uv.y*256.0))*10.0;\n    float c = fract(dot(vec2(a, b), uv));\n    float d = fract(tan(a+b+c) * dot(uv, vec2(c, b*c)));\n    float e = fract(sin(d*10.0) * dot(uv, vec2(d, c)));\n    float f = fract(cos(c*10.0+a-b) * dot(vec2(c, d), vec2(e, b)));\n    float ma = 23516.0;\n    return float(int((113.023123+(f*10.0)*ma))%int(ma)) / ma;\n}\n\nfloat noise1(vec2 uv) {\n    float x = noise0(uv+vec2(0.0213, 1.2013))*10.0;\n    float y = noise0(uv-vec2(9.2132, 3.7938))*10.0;\n    return fract(sin((x+y+uv.x+uv.y)*3.161246)*dot(uv, vec2(x,y)));\n}\n\nfloat noise(vec2 uv) {\n    vec2 id = floor(uv);\n    vec2 lv = smoothstep(0.0, 1.0, fract(uv));\n    float a = noise1(id);\n    float b = noise1(id+vec2(1.0, 0.0));\n    float c = noise1(id+vec2(0.0, 1.0));\n    float d = noise1(id+vec2(1.0, 1.0));\n    return mix(mix(a, b, lv.x), mix(c, d, lv.x), lv.y);\n}\n\nfloat luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nvec3 saturate(vec3 color, float amnt) {\n  float l = color.r * 0.2 + color.g * 0.7 + color.b * 0.1;\n  vec3 gray = vec3(l,l,l);\n  vec3 diff = color.rgb - gray.rgb;\n  diff *= (1.0 + amnt);\n  vec3 saturated = clamp(gray + diff,0.0,1.0);\n  return mix(color, saturated, clamp(amnt, 0.0, 1.0));\n}","name":"Common","description":"","type":"common"}]}