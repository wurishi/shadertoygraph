{"ver":"0.1","info":{"id":"McfGzN","date":"1702816505","viewed":59,"name":"cosmic flower2","username":"nayk","description":"Copypast and combination ","likes":3,"published":1,"flags":1,"usePreview":0,"tags":["flower","rotate","stars","neon","cosmic","colorfu"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* orginals https://www.shadertoy.com/view/cttXRl https://www.shadertoy.com/view/4tyfWy https://www.shadertoy.com/view/lfXGRN*/\n#define iterations 13\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.000 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\n\nfloat grayscale(float x) {\n    // Apply a non-linear transformation to x to increase contrast\n    // This example uses a simple quadratic curve for the contrast effect\n    x = clamp(x, 0.0, 1.0); // ensure x is in the range [0, 1]\n    float contrastFactor = 3.5; // adjust this value to increase or decrease contrast\n    x = 0.5 - contrastFactor * (x - 1.5) * (x - 0.5);\n\n    return clamp(x, 0.0, 1.0); // re-clamp x to the range [0, 1]\n}\n\nvec4 colormap(float x) {\n    float gray = grayscale(x);\n    return vec4(gray, gray, gray, 1.0);\n}\n\nfloat rand(vec2 n) { \n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n    vec2 ip = floor(p);\n    vec2 u = fract(p);\n    u = u*u*(3.0-2.0*u);\n\n    float res = mix(\n        mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n        mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n    return res*res;\n}\n\nconst mat2 mtx = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n\n    f += 0.500000*noise( p + iTime  ); p = mtx*p*2.02;\n    f += 0.031250*noise( p ); p = mtx*p*2.01;\n    f += 0.250000*noise( p ); p = mtx*p*2.03;\n    f += 0.125000*noise( p ); p = mtx*p*2.01;\n    f += 0.062500*noise( p ); p = mtx*p*2.04;\n    f += 0.015625*noise( p + sin(iTime) );\n\n    return f/0.96875;\n}\n\nfloat pattern( in vec2 p )\n{\n\treturn fbm( p + fbm( p + fbm( p ) ) );\n}\n\nfloat glow(vec3 color, float baseRadius, float time, float alpha) {\n    // Calculate the brightness of the color\n    float brightness2 = dot(color, vec3(0.299, 0.587, 0.114));\n\n    // Sinusoidal variation of the radius\n    float radius = baseRadius + sin(time) * 0.5; // Adjust 0.5 to change the amplitude of the radius variation\n\n    // Adjust glow based on the alpha value from color3\n    float adjustedGlow = brightness2 * max(radius, 0.0) * alpha;\n\n    return adjustedGlow; // Return the adjusted glow intensity\n}\n\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n\t//get coords and direction\n\tvec3 dir=rd;\n\tvec3 from=ro;\n\t\n\t//volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam;\n            p.xy*=mat2(cos(iTime*0.02),sin(iTime*0.02),-sin(iTime*0.02),cos(iTime*0.02)); // the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.011); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.2-dm;\n       // dark matter, don't render near\n\t\t\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\tfragColor = vec4(v*.03,1.);\t\n}\n\n#define PI 3.14159265359\n#define TWO_PI 2. * PI\n#define ITERATIONS 33.\n\nvoid Koleidoscope(inout vec2 uv, float ka)\n{\n  float angle = abs (mod (atan (uv.x, uv.y), 2.0 * ka) - ka) + 0.01*iTime;\n  uv = length(uv) * vec2(cos(angle), sin(angle));\n}\n\nvec4 k_orb(vec2 uv, float size, vec2 position, vec3 color, float contrast) \n{\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nvec3 k_rainbow(float progress, float stretch, float offset) \n{\n  return vec3(cos(vec3(-2, 0, -1) * TWO_PI / 3. + TWO_PI * (progress * stretch) + offset) * 0.5 + 0.5);\n}\n\n// counter clockwise rotation matrix: pos*= [ca, sa, -sa, ca]\nmat2 k_rotate2d(float angle) \n{ float ca = cos(angle);\n  float sa = sin(angle);\n  return mat2(ca, sa, -sa, ca);\n}\n\n#define R iResolution\n#define R2(p,a,r) mix(a*dot(p,a),p,cos(r)) + abs(sin(r)*cross(p,a))\n#define H(h) (cos((h)*6.3+vec3(0,23,21))*.5+.5)\n\nvec3 color(float t) {\n  vec3 c1 = vec3(1.0, 0.0, 0.0);\n  vec3 c2 = vec3(0.0, 1.0, 0.0);\n  vec3 c3 = vec3(0.0, 0.0, 1.0);\n  vec3 c4 = vec3(1.0, 1.0, 0.0);\n  vec3 c5 = vec3(1.0, 0.0, 1.0);\n  vec3 c6 = vec3(0.0, 1.0, 1.0);\n\n  float r = cos(t) * 0.5 + 0.5;\n  if (r < 0.23) return mix(c1, c2, r * 5.0);\n  if (r < 0.44) return mix(c2, c3, (r - 0.2) * 5.0);\n  if (r < 0.65) return mix(c3, c4, (r - 0.4) * 5.0);\n  if (r < 0.86) return mix(c4, c5, (r - 0.6) * 5.0);\n  return mix(c5, c6, (r - 0.8) * 7.0);\n}\nfloat nice_friendly_beautiful_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//get coords and direction\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n    vec2 uv3=fragCoord.xy/iResolution.xy-.5;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 dir=vec3(uv*zoom,1.);\n\tfloat time=iTime*speed+.25;\ndir.xy*=mat2(cos(iTime*0.03),sin(iTime*0.03),-sin(iTime*0.03),cos(iTime*0.03));\n\t//mouse rotation\nvec4  fragColor3;\n    vec3 p, r = iResolution, d = normalize(vec3((fragCoord-.5*r.xy)/r.y,0.7));  \n    for(float i = 0., g = 0., e, s; i < 99.; ++i)\n    {\n        p = g * tan(d);\n        p.z -= 0.60*tan(iTime*0.1);\n        p = R2(p, normalize(vec3(1,2,3)), iTime * 0.0);\n        s = 2.;\n p.xy*=mat2(cos(iTime*1.03),sin(iTime*1.03),-sin(iTime*1.03),cos(iTime*1.03));\n        for(int j = 0; j++ < 14;)\n        {\n            p = abs(p);\n            p = p.x < p.y ? p.zxy : p.zyx;\n            s *= e = 1.9 / min(dot(p, p), 1.3);\n          \n            p = p * e - vec3(5,3,2);\n        }\n\n        g += e = length(p.xz) / s;\n       \n        fragColor3.rgb += color(iTime * 0.1 + cos(i)) * mix(r / r, H(log(s)), 0.7) * 0.08 * exp(-i * i * e);\n    }\n    \n \n\n    // Get texture colors\n    vec4 color1 = vec4(dir,1.);\n    vec4 color2 = vec4(dir,1.);\n    vec4 color3 = vec4(dir,1.);\n\tfloat shade = pattern(uv);\n    fragColor+= vec4(colormap(shade).rgb, shade);\n\n    vec2 uv2 =  (2.0 * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    for(float i = 1.0; i < 10.0; i++){\n        uv2.x += 0.6 / i * cos(i * 2.5* uv2.y + iTime);\n        uv2.y += 0.6 / i * cos(i * 10.5 * uv2.x + iTime);\n    }\n    \n    vec4 fragColor2 = vec4(vec3(0.1)/abs(sin(iTime-uv2.y-uv2.x)),1.0);\n\n    // Mix the two colors based on noise alpha\n    vec4 mixedColor = mix(color1, color2, fragColor);\n\n    // Output the final color\n    // fragColor = mixedColor;\n    vec4 color = vec4(colormap(shade).rgb, shade);\n\n\n    // Calculate glow\n    // Apply the glow effect with sinusoidal radius\n    float glowStrength = glow(mixedColor.rgb, 2.5, iTime, shade ); // Using color3's alpha\n    float glowStrength2 = glow(mixedColor.rgb,1.5, iTime*2.0, shade ); // Using color3's alpha\n\n    // Apply glow effect\n    vec3 glowColor = mixedColor.rgb + glowStrength *glowStrength2;\n\n    // Final color output\n    \n  uv /= dot(uv, uv);\n\n  vec2 mp = iMouse.xy / R.xy;\n  float sideCount = 1.0 + round(mp.y * 11.0);\n  if (sideCount == 1.0) sideCount = 5.0;\n  Koleidoscope (uv, PI / sideCount);\n\n  uv *= k_rotate2d(0.0321*iTime); \n  fragColor = vec4(0.);\n  \n  float s = 0.3;\n  for (float i = 0.; i < ITERATIONS; i++)\n  {\n    uv.x += s*1.5 * cos(0.53 * uv.y);\n    uv.y += s*0.84 * cos(0.42 * uv.x + iTime);\n    vec3 color = k_rainbow(i / (ITERATIONS * 25.0), sin(iTime*0.5+uv.y*0.15)*4., iTime*0.5);\n    fragColor += k_orb(uv, 2.2, vec2(0, 0), color, 0.7);\n  }\n  fragColor.xyz = 1. - abs(1.-log(abs(fragColor.xyz)));\n\n\n uv3 *= 2.0 * ( cos(iTime * 2.0) -2.5);\n    \n    // anim between 0.9 - 1.1\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;    \n\n\n\tvec3 from=vec3(1.,.5,0.5)*glowColor* fragColor.xyz*fragColor3.rgb ;\n\tfrom+=vec3(time*2.,time,-2.);\n\t\n\t\n\tmainVR(fragColor, fragCoord, from, dir);\t\n    \n    fragColor+= vec4(nice_friendly_beautiful_star(uv3,anim) * vec3(0.05,0.1,0.55)*.51, 1.0);\n      fragColor*=fragColor3;\n     \n}\n\n","name":"Image","description":"","type":"image"}]}