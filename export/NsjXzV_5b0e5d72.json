{"ver":"0.1","info":{"id":"NsjXzV","date":"1620605646","viewed":118,"name":"Raymarching blah 123","username":"tttttt","description":"stuff","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 plane(vec3 point, float height, float col){\n    return vec2(point.y-height, col);\n}\n\nvec2 sphere(vec3 point, float radius, float col){\n    return vec2(length(point)-radius, col);\n}\n\nvec2 vec_min(vec2 a, vec2 b){\n    return a.x > b.x ? b : a;\n}\n\nvec2 scene(vec3 point){\n    vec2 ground = plane(point, -0.8, 1.);\n    vec2 sphere1 = sphere(point-vec3(-0.5, -0.3, 2.3), 1., 2.);\n    vec2 sphere2 = sphere(point-vec3(0.8, -0.3, 2), 1., 3.);\n    vec2 sphere3 = sphere(point-vec3(-1.5, -0.3, 2.5), 1., 4.);\n    return vec_min(ground, vec_min(sphere1,\n               vec_min(sphere2, sphere3)));\n}\n\nvec2 march(vec3 ray_origin, vec3 ray_direction){\n    vec3 current_point = ray_origin;\n    float dist_total = 0.;\n    float col;\n    for(int i = 0; i < 3000; i++){\n        current_point = ray_origin+ray_direction*dist_total;    \n        vec2 s = scene(current_point);\n        col = s.y;\n        float dist = s.x;\n        dist_total += dist;\n        if(dist < 0.00001){\n            break;\n        }\n        if(dist_total > 1000.){\n            col = 0.;\n            break;\n        }\n    }\n    return vec2(dist_total, col);\n}\n\nvec3 material(float index){\n    if(index >= 0.9 && index <= 1.1){\n        return vec3(0.59607843137, 0.41960784314, 0.35686274510);\n    }\n    else if(index >= 1.9 && index <= 2.1){\n        return vec3(1., 0.1, 0.);\n    }\n    else if(index >= 2.9 && index <= 3.1){\n        return vec3(0.1, 1., 0.0);\n    }\n    else if(index >= 3.9 && index <= 4.1){\n        return vec3(0., 0.2, 1.);\n    }\n}\n\nvec3 normal(vec3 point){\n    if(point.z > 1000.) return vec3(0.);\n    float dist = scene(point).x;\n    float delta = 0.00001;\n    vec2 dir = vec2(delta, 0.);\n    float dx = scene(point+dir.xyy).x-dist;\n    float dy = scene(point+dir.yxy).x-dist;\n    float dz = scene(point+dir.yyx).x-dist;\n    return normalize(vec3(dx, dy, dz));\n}\n\nfloat lighting(vec3 point, vec3 normal, vec3 light_pos){\n    vec3 direction_to_light = normalize(light_pos);//-point);\n    if(march(point+normal*0.001, direction_to_light).x < length(light_pos-point)){\n        return 0.;\n    }\n    return max(0., dot(normal, direction_to_light));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-(iResolution.xy*0.5))/iResolution.y;\n    float camera_fov = 0.35;\n    vec3 camera_origin = vec3(0., 0., 0.);\n    vec3 camera_direction = normalize(vec3(uv, camera_fov)-camera_origin);\n    vec2 m = march(camera_origin, camera_direction);\n    float depth = m.x;\n    vec3 col = material(m.y);\n    \n    if(m.y < 0.9){\n        fragColor = mix(vec4(0.80, 0.94, 0.99, 1.), vec4(0., 0.72, 0.96, 1.), uv.y*3.);\n        return;\n    }\n\n    vec3 point = camera_origin+camera_direction*depth;\n    vec3 norm = normal(point);\n    float directional_light = lighting(point, norm, vec3(cos(iTime)*2., 3., 1.));\n    vec3 ambient_light = vec3(0.2, 0.1, 0.);\n    col *= directional_light+ambient_light;\n    col = pow(col, vec3(0.4545));\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}