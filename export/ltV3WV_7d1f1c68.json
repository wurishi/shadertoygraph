{"ver":"0.1","info":{"id":"ltV3WV","date":"1476947849","viewed":230,"name":"i've done something terrible...","username":"jcolicchio","description":"i decided i'd rotate my rays around the z axis as they march... oh boy","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","reflection","texture","noneuclidean","conicalspiral"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI (3.14159)\n#define FOV (75.0)\n#define THRESHOLD (0.03)\n\n#define TEXTURE_ACCURACY (0.02)\n//#define CURVINESS (0.003)\n\nstruct Sphere {\n    vec3 position;\n    float radius;\n    vec3 color;\n};\n\nstruct Box {\n    vec3 position;\n    vec3 size;\n    vec3 color;\n};\n\nstruct RoundBox {\n    vec3 position;\n    vec3 size;\n    float rounding;\n    vec3 color;\n};\n    \nfloat sdSphere(vec3 p, float s) {\n\treturn length(p)-s;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat udRoundBox(vec3 p, vec3 b, float r) {\n    return length(max(abs(p)-b,0.0))-r;\n}\n\n// uv maps to uv\n#define STRETCH (0)\n\n#define TILE_SMALL (1)\n#define TILE_BIG (2)\nvec3 uvFromBox(in Box box, in vec3 position, in int mode) {\n\tvec3 relativePosition = position - box.position;\n    vec3 normalRel = relativePosition / box.size;\n\n    //fragColor = vec4(box.color, 1);\n    float maxFactor = max(max(abs(normalRel.x), abs(normalRel.y)), abs(normalRel.z));\n    if(maxFactor < 1.0-TEXTURE_ACCURACY) {\n        return vec3(0);\n    }\n    normalRel /= maxFactor;\n\n    float x = normalRel.x;\n    float y = normalRel.y;\n    float z = normalRel.z;\n    float boxXY = box.size.x/box.size.y;\n    float boxYZ = box.size.y/box.size.z;\n    float boxXZ = box.size.x/box.size.z;\n    float boxYX = 1.0/boxXY;\n    float boxZY = 1.0/boxYZ;\n    float boxZX = 1.0/boxXZ;\n    \n    if(mode == STRETCH) {\n        boxXY = boxYX = boxXZ = boxZX = boxYZ = boxZY = 1.0;\n    }\n    else if(mode == TILE_BIG) {\n        if(boxXY > 1.0) {\n            boxXY = 1.0;\n        } else if(boxYX > 1.0) {\n            boxYX = 1.0;\n        }\n        if(boxXZ > 1.0) {\n            boxXZ = 1.0;\n        } else if(boxZX > 1.0) {\n            boxZX = 1.0;\n        }\n        if(boxZY > 1.0) {\n            boxZY = 1.0;\n        } else if(boxYZ > 1.0) {\n            boxYZ = 1.0;\n        }\n    }\n    else if(mode == TILE_SMALL) {\n        if(boxXY < 1.0) {\n            boxXY = 1.0;\n        } else if(boxYX < 1.0) {\n            boxYX = 1.0;\n        }\n        if(boxXZ < 1.0) {\n            boxXZ = 1.0;\n        } else if(boxZX < 1.0) {\n            boxZX = 1.0;\n        }\n        if(boxZY < 1.0) {\n            boxZY = 1.0;\n        } else if(boxYZ < 1.0) {\n            boxYZ = 1.0;\n        }\n    }\n\n    if(abs(abs(x)-1.0) < TEXTURE_ACCURACY) {\n        return vec3(mod((-z*0.5+0.5)*boxZY,1.0),mod((y*0.5+0.5)*boxYZ,1.0),1);\n    }\n    else if(abs(abs(y)-1.0) < TEXTURE_ACCURACY) {\n        return vec3(mod((x*0.5+0.5)*boxXZ,1.0),mod((z*0.5+0.5)*boxZX,1.0),1);\n    }\n    else if(abs(abs(z)-1.0) < TEXTURE_ACCURACY) {\n        return vec3(mod((x*0.5+0.5)*boxXY,1.0),mod((y*0.5+0.5)*boxYX,1.0),1);\n    }\n    return vec3(0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float CURVINESS = 0.0001*iTime;\n\tvec2 uv = fragCoord.xy / iResolution.xy - 0.5;\n    \n    vec3 pixel = vec3(uv*iResolution.xy, 0);\n    vec3 viewer = vec3(0,0,-tan(FOV/2.0*PI/180.0)*iResolution.x/2.0);\n    \n    vec3 ray = normalize(pixel-viewer);\n    \n    Sphere sphere = Sphere(vec3(-200.0*cos(iTime),0,100),100.0,vec3(1,0,0));\n    Box box = Box(vec3(200,-100,500),vec3(40,100,500),vec3(0,1,0));\n    Box box2 = Box(vec3(-400,80,500),vec3(60,40,500),vec3(0,1,1));\n    Box box3 = Box(vec3(0,-280.0+cos(iTime)*50.0,800),vec3(1600,5,1000),vec3(1,0,1));\n    RoundBox roundBox = RoundBox(vec3(200.0*cos(iTime),200.0*sin(iTime),100),vec3(40,50,60),20.0,vec3(0,0,1));\n   \n    fragColor = vec4(vec3(0.5),1);\n    \n    vec3 position = pixel;\n    bool hitSphere = false;\n    for(float i=0.0;i<100.0;i+=1.0) {\n        // starting at position, find the min safe distance\n        float minSphere = sdSphere(sphere.position-position, sphere.radius);\n        float minBox = sdBox(box.position-position, box.size);\n        float minBox2 = sdBox(box2.position-position, box2.size);\n        float minBox3 = sdBox(box3.position-position, box3.size);\n        float minRoundBox = udRoundBox(roundBox.position-position, roundBox.size, roundBox.rounding);\n        \n        if(minSphere < THRESHOLD) {\n            vec3 normal = normalize(position-sphere.position);\n            float x = dot(normal, vec3(1,0,0))*0.5+0.5;\n            float y = dot(normal, vec3(0,1,0))*0.5+0.5;\n            fragColor = vec4(texture(iChannel3,vec2(x,y)).rgb, 1);\n            hitSphere = true;\n            break;\n        }\n        else if(minBox < THRESHOLD || minBox2 < THRESHOLD || minBox3 < THRESHOLD) {\n            Box activeBox = box;\n            if(minBox2 < THRESHOLD) {\n                activeBox = box2;\n            }\n            else if(minBox3 < THRESHOLD) {\n                activeBox = box3;\n            }\n            \n            vec3 boxUV = uvFromBox(activeBox, position, TILE_SMALL);\n            if(boxUV.z == 1.0) {\n                if(minBox2 < THRESHOLD) {\n                \tfragColor = vec4(texture(iChannel2,boxUV.xy).rgb, 1);\n                }\n                else if(minBox3 < THRESHOLD) {\n                \tfragColor = vec4(texture(iChannel0,boxUV.xy).rgb, 1);\n                }\n                else {\n                \tfragColor = vec4(texture(iChannel1,boxUV.xy).rgb, 1);\n                }\n            }\n            \n            break;\n        }\n        else if(minRoundBox < THRESHOLD) {\n            fragColor = vec4(roundBox.color, 1);\n            break;\n        }\n        \n        float minDist = min(minSphere, min(min(minBox, min(minBox3, minBox2)), minRoundBox));\n        \n        if(CURVINESS > 0.0) {\n            // let's try to estimate a min march when curving\n            float radius = length(position.xy);\n            // so we plan to move by an arc length of angle*radius + someDistance\n            \n            // someDistance + angle*radius = minDist\n            // someDist*(1 + CURVINESS * ray.z*radius) = minDist\n            float someDist = minDist / (1.0 + CURVINESS * ray.z * radius);\n        \t\n            // to just say fuck it and go with it, do this\n            position += ray*someDist;\n            // rotate position around z axis based on dist advanced\n            float spin = CURVINESS * (ray*someDist).z;\n            float angle = atan(position.y, position.x) + spin;\n            float len = length(position.xy);\n            position.x = cos(angle)*len;\n            position.y = sin(angle)*len;\n            angle = atan(ray.y, ray.x) + spin;\n            len = length(ray.xy);\n            ray.x = cos(angle)*len;\n            ray.y = sin(angle)*len;\n            \n            // to actually validate that your estimate is safe, do this\n            /*float adjustedMinDist = someDist;\n            vec3 advancedPosition = position + ray*adjustedMinDist;\n            float spin = CURVINESS * ray.z*adjustedMinDist;\n            float angle = atan(advancedPosition.y, advancedPosition.x) + spin;\n            float len = length(advancedPosition.xy);\n            advancedPosition.x = cos(angle)*len;\n            advancedPosition.y = sin(angle)*len;\n            vec3 delta = advancedPosition - position;\n            if(length(delta) > minDist) {\n            \tfragColor = vec4(1);\n                break;\n            } else {\n                position = advancedPosition;\n                angle = atan(ray.y, ray.x) + spin;\n                len = length(ray.xy);\n                ray.x = cos(angle)*len;\n                ray.y = sin(angle)*len;\n            }*/\n        }\n        else {\n        \tposition += ray*minDist;\n        }\n    }\n    \n    // now that we've hit the sphere\n    // let's reflect the point\n    \n    if(hitSphere) {\n        vec3 normal = normalize(position-sphere.position);\n        vec3 reflected = reflect(ray, normal);\n        for(float i=0.0;i<100.0;i+=1.0) {\n            // starting at position, find the min safe distance\n            //float minSphere = sdSphere(sphere.position-position, sphere.radius);\n            float minBox = sdBox(box.position-position, box.size);\n            float minBox2 = sdBox(box2.position-position, box2.size);\n            float minBox3 = sdBox(box3.position-position, box3.size);\n            float minRoundBox = udRoundBox(roundBox.position-position, roundBox.size, roundBox.rounding);\n\n            //if(minSphere < THRESHOLD) {\n            //    fragColor = vec4(sphere.color, 1);\n            //    hitSphere = true;\n            //    break;\n            //}\n            //else \n        \tif(minBox < THRESHOLD || minBox2 < THRESHOLD || minBox3 < THRESHOLD) {\n                Box activeBox = box;\n                if(minBox2 < THRESHOLD) {\n                    activeBox = box2;\n                }\n                else if(minBox3 < THRESHOLD) {\n                    activeBox = box3;\n                }\n                \n                vec3 color = activeBox.color;\n                vec3 boxUV = uvFromBox(activeBox, position, TILE_SMALL);\n                if(boxUV.z == 1.0) {\n                    if(minBox2 < THRESHOLD) {\n                        color = texture(iChannel2,boxUV.xy).rgb;\n                    }\n                    else if(minBox3 < THRESHOLD) {\n                        color = texture(iChannel0,boxUV.xy).rgb;\n                    }\n                    else {\n                        color = texture(iChannel1,boxUV.xy).rgb;\n                    }\n                }\n\n                fragColor = vec4(fragColor.rgb*0.2+color*0.8, 1);\n                break;\n                \n            }\n            else if(minRoundBox < THRESHOLD) {\n                fragColor = vec4(fragColor.rgb*0.1+roundBox.color*0.9, 1);\n                break;\n            }\n\n            float minDist = min(min(minBox, min(minBox3, minBox2)), minRoundBox);\n\n            position += reflected*minDist;\n            if(CURVINESS > 0.0) {\n                // rotate position around z axis based on dist advanced\n                float angle = atan(position.y, position.x) + CURVINESS * (reflected*minDist).z;\n                float len = length(position.xy);\n                position.x = cos(angle)*len;\n                position.y = sin(angle)*len;\n            }\n        }\n    }\n}","name":"Image","description":"","type":"image"}]}