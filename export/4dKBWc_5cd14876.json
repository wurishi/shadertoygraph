{"ver":"0.1","info":{"id":"4dKBWc","date":"1530830947","viewed":185,"name":"Merging Particles","username":"tlambert","description":"My first raymarching shader.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int STEP_NB = 128;\nconst float DIST_ESPILON = 1e-4;\nconst float MAX_DIST = 100.;\n\nconst float DERIV_EPSI = 1e-4;\n\nconst float FIELD_OF_VIEW = 120.;\n\nconst float M_PI = 3.1415;\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\nfloat noise(vec2 n) {\n\tconst vec2 d = vec2(0.0, 1.0);\n  vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nfloat sphereDist(vec3 center, float radius, vec3 pos) {\n \treturn length(center-pos) - radius;\n}\n\n//Benjamin Keinert, Matthias Innmann, Michael SÃ¤nger, and Marc Stamminger. 2015. Spherical fibonacci mapping. ACM Trans. Graph. 34, 6, Article 193 (October 2015), 7 pages.\nvec3 sphericalFibonacciMapping(float i, float n) {\n    const float PHI = sqrt(5.)*0.5 + 0.5;\n    float phi = 2.*M_PI*(i*(PHI-1.)- floor(i*(PHI-1.)));\n    float cosTheta = 1. - (2.*i + 1.)*1./n;\n\n    float sinTheta = sqrt(clamp(1. - cosTheta*cosTheta,0.,1.));\n    return vec3(\n        cos(phi)*sinTheta,\n        sin(phi)*sinTheta,\n        cosTheta);\n}\n\n\nfloat smoothMin(float a, float b, float k) {\n        float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat evalSceneDist(vec3 pos) {\n    float min_dist = MAX_DIST;\n    \n    // Main Particle\n    const int s_nb = 16;\n    for(int i=0; i<s_nb; i++){\n        vec3 c = sphericalFibonacciMapping(float(i),float(s_nb));\n        const float fc = 1.7;\n        const float fr = 1.3;\n        float tc = mod((iTime+fc*rand(float(i))),fc) / fc;\n        float tr = mod((iTime+fr*rand(float(i*i))),fr) / fr;\n    \tmin_dist = smoothMin(min_dist,sphereDist(abs(sin(tc*M_PI))*c,  abs(sin(tr*M_PI))*.5+.5, pos),.2);\n    }\n    \n    // Small Particles\n    const int ss_nb = 64;\n    for(int i=0; i<ss_nb; i++){\n        float d = rand(float(i))*5.+5.;\n    \tconst float f = 3.;\n        float t0 = mod((iTime+f*rand(float(i))),f) / f;\n        float t = 1.-t0;\n        vec3 c = sphericalFibonacciMapping(float(i),float(ss_nb));\n    \tmin_dist = smoothMin(min_dist,sphereDist(c*d*t,  (1.-t)*0.1, pos),0.4);\n    }\n    \n    \n    return min_dist;\n}\n\nvec3 evalSceneNormal(vec3 pos) {\n    return normalize(vec3(\n        evalSceneDist(vec3(pos.x+DERIV_EPSI,pos.yz))-evalSceneDist(vec3(pos.x-DERIV_EPSI,pos.yz)),\n        evalSceneDist(vec3(pos.x,pos.y+DERIV_EPSI,pos.z))-evalSceneDist(vec3(pos.x,pos.y-DERIV_EPSI,pos.z)),\n        evalSceneDist(vec3(pos.xy,pos.z+DERIV_EPSI))-evalSceneDist(vec3(pos.xy,pos.z-DERIV_EPSI))\n    ));\n}\n\nvec3 rayDirection( vec2 frag_coord) {\n    vec2 xy = frag_coord - iResolution.xy/2.;\n    float z = iResolution.y /tan(radians(FIELD_OF_VIEW)/ 2.0);\n    return normalize(vec3(xy,-z));\n}\n\nfloat rayMarching(vec3 start, vec3 ray) {    \n    float depth = 0.f;\n    for(int s=0;s<STEP_NB; s++) {\n        float dist = evalSceneDist(start+depth*ray);\n        if(dist < DIST_ESPILON)\n            return depth;\n        depth += dist;\n        if(depth > MAX_DIST)\n            return -1.;\n    }\n    return -1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cam = vec3(0.,0.,4.);\n    vec3 ray = rayDirection(fragCoord);\n    \n    float dist = rayMarching(cam,ray);\n    \n    if (dist < 0.f) {\n        float d = length(ray.xy);\n        const float f = 2.;\n        float noise = noise(ray.xy+iTime*f)*0.2;\n        fragColor = vec4(0.5*(1.- d)+noise,0.,0.,1.);\n    } else {  \n        vec3 pos = cam+ray*dist;\n        vec3 nor = evalSceneNormal(pos);\n        float f = abs(dot(nor,ray));\n        \n            \n        fragColor = vec4(max(f,(0.3-f)*10.),\n                         max(0.,max((0.3-f)*10.,10.*(f-0.9))),\n                         max(0.,max((0.3-f)*10.,10.*(f-0.9))),\n                             1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}