{"ver":"0.1","info":{"id":"mdsXWM","date":"1669042066","viewed":118,"name":"DistanceTransform2D","username":"Mario8664","description":"distance transform algorithm.\nMouse down and move to find nearest.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["sdf","distancetransform"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy / SCALE;\n    vec3 col = texture(iChannel0, uv).rgb;\n    float d = sqrt(col.b);\n    \n    float unit = iResolution.y * UNIT;\n    vec2 m = iMouse.xy / SCALE / iResolution.y + iResolution.y / iResolution.xy - 1.0;\n    vec2 st = fragCoord / SCALE / iResolution.y + iResolution.y / iResolution.xy - 1.0;\n    float dm = sqrt(texture(iChannel0, iMouse.xy / SCALE / iResolution.xy).b);\n    float c = length(m - st) * unit - dm;\n    c = 1.0 - c;\n    c = floor(c) - clamp(floor(c - 0.005 / SCALE * unit), 0.0, 1.0);\n    c = clamp(c, 0.0, 1.0);\n    //d = pow(d, 0.4); \n    d = ceil(d);\n    \n    // Output to screen\n    vec3 ddd = vec3(d);\n    vec3 ccc = vec3(1.0, 1.0 - c, 1.0 - c);\n    fragColor = vec4(ccc * ddd,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float sdCircle(vec2 pos, vec2 uv, float r)\n{\n    return distance(uv, pos) - r;\n}\n\nfloat sdBox(vec2 pos, vec2 uv, vec2 s)\n{\n    vec2 p = abs(uv - pos);\n    vec2 q = max(p - s, 0.0);\n    return length(q);\n}\n\nfloat sdTriangle(vec2 pos, vec2 uv, vec2 p0, vec2 p1, vec2 p2 )\n{\n    vec2 p = uv - pos;\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = e0.x*e2.y - e0.y*e2.x;\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\nvec4 sdf(vec2 uv)\n{\n    float b1 = sdBox(vec2(0.5), uv, vec2(0.1));\n    float c1 = sdCircle(vec2(0.8), uv, 0.2);\n    float c2 = sdCircle(vec2(0.1, 0.8), uv, 0.2);\n    float t1 = sdTriangle(vec2(0.0, 0.2), uv, vec2(0.0, 0.3), vec2(0.1, 0.1), vec2(-0.1, 0.1));\n    float d = min(b1, c1);\n    d = min(d, c2);\n    d = min(d, t1);\n    return vec4(ceil(d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 sdfuv = fragCoord * SCALE / iResolution.y + iResolution.y / iResolution.xy - 1.0;\n    vec2 uv = fragCoord / iResolution.xy;\n    float aspect = iResolution.x / iResolution.y;\n    if(sdfuv.x > aspect || sdfuv.y > 1.0)\n    {\n        fragColor = vec4(0.0);\n        return;\n    }\n    vec4 col;\n    \n    if(iFrame == 0)\n    {\n        col = sdf(sdfuv);\n    }\n    else if(iFrame % int(SCALE) == 0)\n    {\n        \n        vec3 os = vec3(-1.0, 0.0, 1.0);\n        vec2 o = vec2(1.0) / iResolution.xy;\n        vec3 cn = texture(iChannel0, uv).rgb;\n        \n        vec2 c0 = texture(iChannel0, uv + o * os.xy).rg + 1.0 * UNIT * os.zy;\n        vec2 c1 = texture(iChannel0, uv + o * os.yx).rg + 1.0 * UNIT * os.yz;\n        vec2 c2 = texture(iChannel0, uv + o * os.zy).rg + 1.0 * UNIT * os.zy;\n        vec2 c3 = texture(iChannel0, uv + o * os.yz).rg + 1.0 * UNIT * os.yz;\n        \n        float cc0 = dot(c0, c0);\n        float cc1 = dot(c1, c1);\n        float cc2 = dot(c2, c2);\n        float cc3 = dot(c3, c3);\n        \n        vec2 c = c0;\n        float cc = cc0;\n        if(cc1 < cc)\n        {\n            c = c1;\n            cc = cc1;\n        }\n        if(cc2 < cc)\n        {\n            c = c2;\n            cc = cc2;\n        }\n        if(cc3 < cc)\n        {\n            c = c3;\n            cc = cc3;\n        }\n        \n        if(cc < cn.b)\n        {\n            col = vec4(c, cc, 0.0);\n        }\n        else\n        {\n            col = vec4(cn, 0.0);\n        }\n    }\n    else\n    {\n        col = texture(iChannel0, uv);\n    }\n    \n\n    fragColor = col;//vec4(uv, 0.0, 0.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define UNIT 0.005\n#define SCALE 1.0","name":"Common","description":"","type":"common"}]}