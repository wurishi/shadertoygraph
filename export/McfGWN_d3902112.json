{"ver":"0.1","info":{"id":"McfGWN","date":"1703065910","viewed":29,"name":"ki-4","username":"tono","description":"nuno","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["cloth"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PETAL 1.\n\nfloat pi = acos(-1.);\nfloat pi2 = acos(-1.)*2.;\n\nvec2 min2(vec2 a,vec2 b){\n\treturn mix(a,b,step(b.x,a.x));\n}\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat noise (vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\nvec3 pmod_id(vec2 p, float r,float l)\n{\n    float a = atan(p.x, p.y) + pi / r;\n    float n = pi2 / r;\n    a = floor((a + sin(l*3. + iTime/50.)/2.) / n) * n;\n\n    return vec3(p * rot(-a),a);\n}\n\nvec3 pmod(vec2 p, float r)\n{\n    float a = atan(p.x, p.y) + pi / r;\n    float n = pi2 / r;\n    a = floor(a / n) * n;\n\n    return vec3(p * rot(-a),a);\n}\nfloat smoothmin(float d1, float d2, float k){\n    float h = exp(-k * d1) + exp(-k * d2);\n    return -log(h) / k;\n}\n//https://iquilezles.org/articles/distfunctions/\n//https://www.shadertoy.com/view/Ds2czG\nfloat sdVerticalVesicaSegment( in vec3 p, in float h, in float w )\n{\n    // shape constants\n    h *= 0.5;\n    w *= 0.5;\n    float d = 0.5*(h*h-w*w)/w;\n    \n    // project to 2D\n    vec2  q = vec2(length(p.xz), abs(p.y-h));\n    \n    // feature selection (vertex or body)\n    vec3  t = (h*q.x < d*(q.y-h)) ? vec3(0.0,h,0.0) : vec3(-d,0.0,d+w);\n    \n    // distance\n    return length(q-t.xy) - t.z;\n}\n\nvec2 petal(vec3 p){\n\tfloat o = 10.;\n    o = sdVerticalVesicaSegment(p * vec3(1.,1.,1.),1.,.5);\n    return vec2(o,PETAL);\n}\n\nvec2 map(vec3 p){\n\tvec2 o = vec2(0.);\n    \n    p.xy *= rot(p.z / 53. * sin(p.z / 60.));\n    \n    vec3 pid = pmod_id(p.xy,5.,p.y);\n    p.xy = pid.xy;\n    p.y -= 9.5;\n    float id = floor(p.z / 4.);\n    p.xy *= rot(p.z / 7.);\n    p.z = mod(p.z,4.) - 2.;\n    p.y += sin(p.z/100.)+1.;\n    p.y -= 0.5;\n    p.xy *= rot(iTime/2. + noise(pid.zz) * 100.);\n    p.zy *= rot(iTime/2. + noise(pid.zz) * 140.);\n    p.y += 0.5;\n    for(int i = 0; i <2;i++){\n    \tp.x = abs(p.x) - .7;\n        p.y = abs(p.y) - 0.1;\n        p.zy *= rot(0.01);\n        p.yz *= rot(-.01);\n        p.z = abs(p.z) -0.3;\n        \n    }\n    o = petal(p);\n    return o;\n}\n\nfloat nearest = 0.;\nvec2 march(vec3 cp,vec3 rd){\n    float depth = 0.;\n    for(int i = 0; i < 180; i++)\n    {\n        vec3 rp = rd * depth + cp;\n        vec2 d = map(rp);\n        \n        nearest = (d.x < nearest)?d.x:nearest;\n        if(abs(d.x) < 0.0001){\n        \treturn vec2(depth , d.y);\n        }\n        depth += d.x;\n    }\n    return vec2(-depth);\n}\n\nvec3 getMat(float id,vec3 p){\n    vec3 mat = vec3(1.,0.,1.);\n    if(PETAL == id){\n    \tmat = vec3(1.,0.8,0.);\n    }\n    return mat;\n}\nfloat sdUnevenCapsule( vec2 p, float r1, float r2, float h )\n{\n    p.x = abs(p.x);\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(p,vec2(-b,a));\n    if( k < 0.0 ) return length(p) - r1;\n    if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n    return dot(p, vec2(a,b) ) - r1;\n}\n\n#define TT(x,y) floor(x) + pow(fract(x),y)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\t\n    vec3 cp = vec3(0.3,-0.7,-33.);\n    \n    vec3 target = vec3(0.,0.,0.);\n    vec3 cd = normalize(target -cp);\n    vec3 cs = normalize(cross(cd,vec3(0.,1.,0.)));\n    vec3 cu = normalize(cross(cd,cs));\n\n    float fov = 6.5 - dot(p,p)*6.;\n    vec2 pp = floor(p * 190.)/190.;\n    vec3 rd = normalize(pp.x * cs + pp.y * cu + cd * fov);\n    \n    vec3 col = vec3(.6,0.,1.) * (noise(p*noise(p * 1000.))*0.2 + 0.75);\n    vec3 bcol = col;\n    vec2 d = march(cp,rd);\n    \n    if(d.x > 0.)\n    {\n        vec3 pos = cp + rd * d.x;\n        vec2 e = vec2(0.,.01);\n        vec3 n = -normalize(map(pos).x - vec3(map(pos - e.xyy).x,map(pos - e.yxy).x,map(pos - e.yyx).x));\n        col = n;\n        vec3 sun = normalize(vec3(2.,4.,8.));\n        \n        vec3 mat = getMat(d.y,pos);\n        float diff= max(dot(sun,n) ,0.6);\n        float sp = max(0.,dot(rd,reflect(-n,sun)));\n        sp = pow(sp,31.6);\n        float rim = clamp(1. - dot(n,-rd),0.,1. );\n        rim = pow(rim , 10.);\n        col = mat * diff + sp * mat;\n        \n        \n        col += rim * mat;\n        float t = 1.-exp(-0.0003 * d.x * d.x);\n    }\n    else{\n        float line = 1.;\n        p = sin(p* 6.1 + iTime/6. + TT(p.x,3.) ) * sin(p * 6.1- iTime/6.+pi/2. + TT(p.y,3.) );\n        vec3 pid = pmod(p.xy,100.);\n        p.xy = pid.xy;\n        p.y = abs( sin(p.y*3.) );\n        for(int i = 0; i <2;i++){\n            p.x = abs(p.x) - .7;\n            p.y = abs(p.y) - 0.1;\n        }\n        p.x += noise(p * noise(p * vec2(noise(p ),noise(p.yx * 3.) )));\n        line = sdUnevenCapsule(p,0.013,0.01,0.03);\n        line = step(line , 0.06) * step(0.01,line);\n        col += line * vec3(1.);\n    }\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}