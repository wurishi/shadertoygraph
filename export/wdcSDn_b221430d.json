{"ver":"0.1","info":{"id":"wdcSDn","date":"1571760294","viewed":67,"name":"tomcilo GOD LIKE DOMINATION","username":"tomcilo","description":"Some desc","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sdf","supervision"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926535897932384626433832795\n#define RENDER_DEPTH 800\n#define CLOSE_ENOUGH 0.00001\n\n#define GRADIENT(pt, func) vec3( \\\n    func(vec3(pt.x + 0.0001, pt.y, pt.z)) - func(vec3(pt.x - 0.0001, pt.y, pt.z)), \\\n    func(vec3(pt.x, pt.y + 0.0001, pt.z)) - func(vec3(pt.x, pt.y - 0.0001, pt.z)), \\\n    func(vec3(pt.x, pt.y, pt.z + 0.0001)) - func(vec3(pt.x, pt.y, pt.z - 0.0001)))\n\n//Array of lights in our scene\nconst vec3 LIGHT_POS[] = vec3[](vec3(5.0));\n\n//---------------------------------------------------------------------------------------\n// Transformations\n//---------------------------------------------------------------------------------------\n\nmat4 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(c, s, 0, 0),\n        vec4(-s, c, 0, 0),\n        vec4(0, 0, 1.0, 0),\n        vec4(0, 0, 0, 1.0)\n    );\n}\n\nmat4 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(c, 0, s, 0),\n        vec4(0.0, 1.0, 0, 0),\n        vec4(-s, 0, c, 0),\n        vec4(0, 0, 0, 1.0)\n    );\n}\n\n//---------------------------------------------------------------------------------------\n// Signed Distance Functions\n//---------------------------------------------------------------------------------------\n\n/* sphere centred at 0, with radius r */\nfloat sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\n/* cube centred at 0, parallel to xyz axis, with side length 2a */\nfloat cube(vec3 p, float a) {\n    return max(abs(p.x), max(abs(p.y), abs(p.z))) - a;\n}\n\n/* cylinder along x axis, with radius r */\nfloat cylinder_x(vec3 p, float r) {\n\treturn length(vec2(p.y, p.z)) - r;\n}\n\n/* cylinder along x axis, with radius r, x coordinate [0, l] */\nfloat bounded_cylinder_x(vec3 p, float r, float l) {\n\treturn max(cylinder_x(p, r), cube(vec3(p.x - l / 2.0, 0, 0), l / 2.0));\n}\n\n/* vertical cone, with peak at 0 pointing upwards, with radius r at depth 1 and with height h*/\nfloat one_bounded_cone_y(vec3 p, float r, float h) {\n\tfloat dist = length(vec2(p.x, p.z));\n\n    return max(\n        (r * p.y + dist) / (r * r + 1.0),\n        cube(vec3(0.0, p.y + h / 2.0, 0.0), h / 2.0)\n    );\n}\n\n/*\n * R  - radius of outer sphere\n * r  - radius of inner sphere\n *\n * l  - lenght of entry (measured from the center, assumed to be greater than R\n * Re - outer radius of entry\n * re - inner radius of entry\n */\nfloat igloo(vec3 p, float R, float r, float l, float Re, float re) {\n    return\n        max(\n        \tmax(\n                max(\n                \tmin(\n               \t    \tsphere(p, R),\n                    \tbounded_cylinder_x(p, Re, l)\n                \t),\n\t\t\t\t\t-bounded_cylinder_x(p, re, l + 0.1)\n                ),\n                -sphere(p, r)\n            ),\n            -cube(vec3(p.x, p.y + l, p.z), l + 0.1)\n        );\n}\n\nvec3 cross_prod(vec3 a, vec3 b) {\n\treturn vec3(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);\n}\n\nfloat scalar_prod(vec3 a, vec3 b) {\n\treturn a.x * b.x + a.y * b.y + a.z * b.z;\n}\n\n/* returns halfspace determined by the plane abc, that contains d*/\nfloat halfspace(vec3 p, vec3 a, vec3 b, vec3 c, vec3 d) {\n\tvec3 n = cross_prod(b - a, c - a);\n    if (scalar_prod(n, d - a) > 0.0)\n        n = -1.0 * n;\n    return scalar_prod(n, p - a) / length(n);\n\n}\n\n/* r - inner radius\n * w - offset\n * h - height\n * t - twisting factor\n */\nfloat corkscrew(vec3 p, float r, float w, float h, float t) {\n    float theta = t * p.y;\n//    float _x = (p.x) * cos(p.y) + p.z * sin(p.y);\n//    float _y =-(p.x) * sin(p.y) + p.z * cos(p.y);\n    float _x = p.x + sin(t * p.y);\n    float _y = p.z + cos(t * p.y);\n\treturn bounded_cylinder_x(vec3(p.y + h, _x, _y), r, 2.0 * h) / 1.2;\n}\n\n/* returns tetrahedron determined by its 4 vertices */\nfloat tetrahedron(vec3 p, vec3 a, vec3 b, vec3 c, vec3 d) {\n\treturn\n        max(\n        \tmax(\n\t\t\t\thalfspace(p, a, b, c, d),\n\t\t\t\thalfspace(p, b, c, d, a)\n            ),\n            max(\n\t\t\t\thalfspace(p, c, d, a, b),\n\t\t\t\thalfspace(p, d, a, b, c)\n            )\n        );\n}\n\nfloat scene1(vec3 p) {\n    return one_bounded_cone_y(vec3(p.x, p.y - 1.0, p.z), 0.7, 3.0);\n}\nfloat scene2(vec3 p) {\n\treturn igloo(vec3(p.x, p.y - 1.0, p.z),\n    \t2.0,  // R\n        1.75, // r\n        2.5,  // l\n        1.0,  // Re\n        0.75);// re\n}\nfloat scene3(vec3 p) {\n\treturn tetrahedron(p,\n    \tvec3(-1.0, -1.0, -1.0),\n    \tvec3(-1.0, 1.0, 1.0),\n    \tvec3(1.0, 1.0, -1.0),\n    \tvec3(1.0, -1.0, 1.0));\n}\n\nfloat scene4(vec3 p) {\n\treturn corkscrew(p,\n                     1.1,  // r\n                     1.0,  // w\n                     3.0,  // h\n                     3.0); // t\n}\n\nfloat scene(vec3 p) {\n    // Change this to sceneN for N <- {1, 2, 3, 4}\n    return scene4(p);\n}\n\n//---------------------------------------------------------------------------------------\n// Auxiliary helper functions\n//---------------------------------------------------------------------------------------\n\nvec3 getNormal(vec3 pt) {\n    return normalize(GRADIENT(pt, scene));\n}\n\n//---------------------------------------------------------------------------------------\n// Illumination and Shading\n//---------------------------------------------------------------------------------------\n\nfloat shade(vec3 eye, vec3 pt, vec3 n) {\n    float val = 0.0;\n\n    //Ambient Lighting\n    val += 0.2;\n\n    //Cast ray towards our light sources and add it to the illumination depending\n    //on the angle with the normal to the surface\n    for (int i = 0; i < LIGHT_POS.length(); i++) {\n        vec3 l = normalize(LIGHT_POS[i] - pt);\n        val += max(dot(n, l), 0.0);\n    }\n\n    return val;\n}\n\nvec3 illuminate(vec3 camPos, vec3 rayDir, vec3 pt) {\n    vec3 c, n;\n    //Using the SDF normal approximation\n    n = getNormal(pt);\n\n    //Everything is white\n    c = vec3(1.0);\n    return shade(camPos, pt, n) * c ;\n}\n\n//---------------------------------------------------------------------------------------\n// Ray Marching Algorithm\n//---------------------------------------------------------------------------------------\n\nvec3 castRay(vec3 camPos, vec3 rayDir) {\n    //Using the ray marching approach\n    int step = 0;\n    float t = 0.0;\n\n    for (float d = 1000.0; step < RENDER_DEPTH && abs(d) > CLOSE_ENOUGH; t += abs(d)) {\n        d = scene(camPos + t * rayDir)/2.0;\n        step++;\n    }\n\n    if (step == RENDER_DEPTH) {\n        return vec3(0.0, 0.0, 0.0); //getBackground(rayDir);\n    } else {\n        return illuminate(camPos, rayDir, camPos + t * rayDir);\n    }\n}\n\n//---------------------------------------------------------------------------------------\n// Set-up\n//---------------------------------------------------------------------------------------\n\nmat3 setCamera(in vec3 origin, in vec3 target, float rotation) {\n    //The direction in which the camera is pointing\n    vec3 forward = normalize(target - origin);\n    vec3 orientation = vec3(sin(rotation), cos(rotation), 0.0);\n    vec3 left = normalize(cross(forward, orientation));\n    vec3 up = normalize(cross(left, forward));\n    return mat3(left, up, forward);\n}\n\n//---------------------------------------------------------------------------------------\n// Output\n//---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //Normalize the 2d coordinates [-1, 1]\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\n    //Fix the x axis to original resolution\n    p.x *= iResolution.x / iResolution.y;\n\n    //Setting the camera - origin, lookat\n    vec3 origin = vec3(10.0*sin(iTime), 1.8, 10.0*cos(iTime));\n    vec3 look = vec3(0.0);\n\n\n    mat3 camera = setCamera(origin, look, 0.0);\n    vec3 direction = camera * normalize(vec3(p.xy, 2.0));\n\n    vec3 color = castRay(origin, direction);\n\n    fragColor = vec4(color, 0.0);\n}\n","name":"Image","description":"","type":"image"}]}