{"ver":"0.1","info":{"id":"wlfXWM","date":"1563204031","viewed":304,"name":"colorful city","username":"ankd","description":"raymarching billding\ni try to repeat the object and get id for each object. \nid is used to get color and height","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","vivid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n\n#define MARCH_MIN 1e-3\n#define MARCH_MAX 1000.\n#define MARCH_ITR 512\n#define MARCH_THR 1e-5\n\n#define BILL_W 1.0\n#define BILL_H 4.0\n\n// utils function -----------------------------------------------------------------\nvec3 hsv(in float h, in float s, in float v) { return ((clamp(abs(fract(h+vec3(0., 2., 1.)/3.)*6.-3.)-1., 0., 1.)-1.)*s+1.)*v; }\nmat2 rotate(in float r) { float c=cos(r), s=sin(r); return mat2(c, -s, s, c); }\nvec2 rotate(in vec2 p, in float r) { return rotate(r) * p; }\nvec3 rotate(in vec3 p, in vec3 r) {\n  vec3 q = p;\n  q.xy = rotate(q.xy, r.z);\n  q.yz = rotate(q.yz, r.x);\n  q.zx = rotate(q.zx, r.y);\n  return q;\n}\n\nfloat hash(in float x) { return fract(sin(x) * 43237.5324); }\nfloat hash(in vec2 x) { return fract(sin(dot(x, vec2(12.9898, 78.233)))*43237.5324); }\nfloat hash(in vec3 x) { return fract(sin(dot(x, vec3(12.9898, 78.233, 49.256)))*43237.5324); }\nvec3 hash3(in float x) { return vec3(hash(x), hash(x+999.), hash(x+99999.)); }\n\n// distance function ----------------------------------------------------------------------------------------------\nfloat box(in vec3 p, in vec3 b) { vec3 d=abs(p)-b; return length(max(d, 0.))+min(max(d.x, max(d.y, d.z)), 0.); }\nfloat plane(in vec3 p, in vec3 n, in float h) { return dot(p, n) - h; }\n\n// operator ------------------------------------------------------------------------------------------------------\nvec2 opU(in vec2 d1, in vec2 d2) { return d1.x<d2.x ? d1 : d2; }\nfloat smin(in float a, in float b, in float k) {\n\tfloat h = max(k - abs(a-b), 0.);\n    return min(a, b) - h*h/(4.0*k);\n}\nvec4 opRep(in vec3 p, in vec3 c) {\n    vec3 id = floor(p / c) * vec3(\n    \tc.x>0. ? 1. : 0.,\n    \tc.y>0. ? 1. : 0.,\n    \tc.z>0. ? 1. : 0.\n    );\n\treturn vec4(mod(p, c) - 0.5*c, hash(id));\n}\n\n// map ------------------------------------------------------------------------------------------------------------\nfloat tile(in vec3 p, in vec3 n, in vec2 h) {\n    float d = plane(p, n, h.x);\n    vec3 q = p; q.xz = mod(q.xz, 2.0) - 1.0;\n    d = smin(d, box(q, vec3(0.95, h.y, 0.95)), .1);\n    return d;\n}\nfloat boxs(in vec3 p, in vec3 b, in float r) {\n\tvec3 q = p;\n    q.xz = abs(q.xz);\n    q.xz = q.z<q.x ? q.xz : q.zx;\n    float d = box(q-vec3(r, 0., 0.), b);\n    return d;\n}\nfloat bill(in vec3 p, in vec2 b) {\n    float d = box(p, b.xyx);\n    float s = boxs(p, vec3(b.x*0.1, b.y*0.9, b.x*0.8), b.x);\n    d = max(d, -s);\n    //d = s;\n    return d;\n}\n\nvec2 map( in vec3 p ) {\n    vec2 res = vec2(1e8, -1.);\n    res = opU(res, vec2(tile(p, vec3(0., 1., 0.), vec2(0., 0.08)), 0.));\n    \n    vec3 q = p;\n    vec4 qtmp = opRep(q, vec3(BILL_W*7., 0., BILL_W*4.0));\n    float h = BILL_H - qtmp.w*3.0;\n    q.y -= h;\n    q = vec3(qtmp.x, q.y, qtmp.z);\n    q.x -= 1.0*(qtmp.w*2.0-1.0);\n    res = opU(res, vec2(bill(q, vec2(BILL_W, h)), qtmp.w));\n    return res;\n}\n\n// lighting --------------------------------------------------------------------------------------------------\nvec3 calcNormal(in vec3 p) {\n  vec2 e = vec2(1., -1.) * 2e-5;\n  return normalize(\n      e.xyy * map(e.xyy+p).x +\n      e.yxy * map(e.yxy+p).x +\n      e.yyx * map(e.yyx+p).x +\n      e.xxx * map(e.xxx+p).x\n    );\n}\nfloat diffuse(in vec3 n, in vec3 l, in float s) { return pow(clamp(dot(n, l), 0., 1.), s); }\nfloat specular(in vec3 r, in vec3 l, in float s) { return pow(clamp(dot(r, l), 0., 1.), s); }\n\n// ray marching  --------------------------------------------------------------------------------------------------\nvec2 rayMarch(in vec3 ro, in vec3 rd) {\n    float d=MARCH_MIN, m=-1.;\n    for(int i=0;i<MARCH_ITR;i++) {\n    \tvec2 tmp = map(ro + rd*d);\n        if(tmp.x<MARCH_THR || MARCH_MAX<tmp.x) break;\n        d += tmp.x*0.3;\n        m = tmp.y;\n    }\n    if(MARCH_MAX<d) m=-1.;\n    return vec2(d, m);\n}\n\n// color  --------------------------------------------------------------------------------------------------\nvec3 getSkyColor(in vec3 rd) {\n\treturn mix(vec3(1.), vec3(0.4, 0.6, 1.0), exp(rd.y));\n}\n\n// rendering  --------------------------------------------------------------------------------------------------\nvec4 render(vec3 ro, vec3 rd) {\n    vec4 result = vec4(0.);\n\n    vec2 tmp = rayMarch(ro, rd);\n    if(tmp.y<0.) {\n        result = vec4(getSkyColor(rd), 1.);\n    } else {\n        // get surface info\n\t    vec3 surfaceP = ro + rd*tmp.x;\n\t    vec3 surfaceN = calcNormal(surfaceP);\n\t    vec3 surfaceR = reflect(rd, surfaceN);\n        \n        // vec3 lp = vec3(5.);\n        vec3 lp = ro - vec3(0., 0., -15.);\n        vec3 directionalLight = normalize(vec3(1.));\n        vec3 pointLight = normalize(lp - surfaceP);\n\n        result = vec4(hsv(tmp.y, 0.<tmp.y?1.:0., 1.), 1.0);\n        \n        float diff = //diffuse(surfaceN, directionalLight, 1.);\n            \t\t\t+ diffuse(surfaceN, pointLight, 1.);\n        float spec = specular(surfaceR, pointLight, 100.);\n\n        result *= 0.02+0.98*diff;\n        result += spec;\n\t}\n    \n    result += clamp(1.0-exp(-0.01*tmp.x), 0., 1.);\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (gl_FragCoord.xy*2.-iResolution.xy)/min(iResolution.x, iResolution.y);\n    vec3 color = vec3(0.);\n\n    // set camera\n    vec3 ro = vec3(0., .3, -iTime*15.0);\n    vec3 tar = ro + vec3(1., 2.5, -6.);\n    vec3 cz = normalize(tar - ro);\n    float cr = iTime*0.;\n    vec3 cx = normalize(cross(cz, vec3(sin(cr), cos(cr), 0.)));\n    vec3 cy = normalize(cross(cx, cz));\n    vec3 rd = normalize(mat3(cx, cy, cz) * vec3(p, 2.));\n\n    // rendering\n    vec4 col = render(ro, rd);\n    color = col.rgb;\n\n    // screen space post effect\n    color = pow(color, vec3(0.4545));\n\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}