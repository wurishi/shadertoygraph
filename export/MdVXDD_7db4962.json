{"ver":"0.1","info":{"id":"MdVXDD","date":"1464685401","viewed":239,"name":"2 tweet raytracing","username":"LaBodilsen","description":"inspired by: [url=https://www.shadertoy.com/view/4sKSD1]Compact Raymarcher[/url]\nBut done with raytracing. \n\nGoal: what could be done in 2 tweets,  not how small it could be.  so if you suggest changes, please make it a full 280 chars.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","2tweets"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* \nn = normal\no = origin, reused as Pos and Normal\nr = raydir\n*/\n\n// Added ambient and variable reuse suggestions from nexor. \n// Simplfied 11 chars with the help of Fabrice.\n// more minimizing by Fabrice, and added Color again. \n\n// Rearranged vec3 and float init.  removed /1. in normal calc.\n// Fixed a bug with t > 0.  +2 chars. \n// Changed floor back.\n\nvoid mainImage( out vec4 C, vec2 u )\n{\n    vec3 o = vec3(sin(iDate.w), 1., 7), n,\t\t\t   //Origin\n   \t\t r = normalize(vec3(u=u/iResolution.y-1.,-3));     //Ray direction \n\n    float b = dot(o, r),\t\t\t\t\t\t\t //sphere.xyz = 0., so dont substract center from o.\n          t = b*b - dot(o,o) + 1.;\t    \t\t\t //Sphere size = 1.  so 1.*1. = 1.\n\t  \n    C = t > 0. \n       \t?  \tn = o += (-b-sqrt(t))*r,\t\t\t\t\t\t//Normal += Intersection point\n\t    \to = normalize(9. - o),          \t\t\t\t// light.xyz = 9. and direction        \t\n        \t    pow(max(dot(reflect(o, n), r), .9), 20.)\n        \t\t-r.zyyy*dot(o, n)\t\t\t\t\t\t\t// specular - Diffuse  \n        :\n    \t\tsin(5.*u.xxxx/u.y)*sin(5./u.y);\t\t\t\t\t// Checkerboard floor.\n}\n\n\n\n/* Original shader\n\nvoid mainImage( out vec4 C, vec2 u )\n{\n    vec3 o = vec3(sin(iDate.w), 1.1, 7.), L, n, r, p; //Origin\n    r = normalize(vec3(u=u/iResolution.y-1.,-3.));    //Ray direction \n\n    float b = -dot(o, r), t;\t\t\t\t\t \t  //sphere.xyz = 0., so dont substract center from o.\n    t = (b-sqrt(b*b - (dot(o,o) - 1.))); \t\t\t  //Sphere size = 1.  so 1.*1. = 1.\n\n    t > 0. \n       \t?\tp = o + t*r,\t\t\t\t\t// Intersection point\n\t    \tL = normalize(9. - p),          // light = 9. and direction\n        \tn = p/1., \t\t\t\t\t\t// Normal, sphere.xyz = 0.  so no need to subtract from p.\n        \tC.r = dot(L, n),\t\t\t\t// Red Diffuse \n        \tC += pow(max(dot(reflect(L, n), r), 0.), 20.) // *Specular\n        :\n    \t\tC = vec4(u+1.,0,1);\n    \n}\n*/\n","name":"Image","description":"","type":"image"}]}