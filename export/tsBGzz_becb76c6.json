{"ver":"0.1","info":{"id":"tsBGzz","date":"1558848280","viewed":88,"name":"Broken phong","username":"bitsofcode","description":"play","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 4.7;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\nfloat sphereSDF( vec3 samplePoint ) {\n    return length( samplePoint ) - 1.0;\n}\n\nfloat sceneSDF( vec3 samplePoint ) {\n    return sphereSDF( samplePoint );\n}\n\nfloat shortestDistanceToSurface( vec3 eye, vec3 marchingDirection, float start, float end ) {\n    float depth = start;\n    for ( int i = 0; i < MAX_MARCHING_STEPS; i++ ) {\n        float dist = sceneSDF( eye + depth * marchingDirection );\n        if ( dist < EPSILON ) {\n            return depth;\n        }\n        depth += dist;\n        if ( depth >= end ) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec3 rayDirection( float fieldOfView, vec2 size, vec2 fragCoord ) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan( radians( fieldOfView ) / 2.0 );\n    return normalize( vec3( xy, -z ));\n}\n\nvec3 estimateNormal( vec3 p ) {\n    return normalize( vec3 (\n        sceneSDF(vec3(p.x + EPSILON,p.y,p.z)) - sceneSDF(vec3(p.x - EPSILON,p.y,p.z)),\n        sceneSDF(vec3(p.x,p.y + EPSILON,p.z)) - sceneSDF(vec3(p.x,p.y - EPSILON,p.z)),\n        sceneSDF(vec3(p.x,p.y,p.z + EPSILON)) - sceneSDF(vec3(p.x,p.y,p.z - EPSILON))\n    ));\n}\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L,N));\n    \n    float dotLN = dot(L,N);\n    float dotRV = dot(R,V);\n    \n   // if (dotLN < 0.0) {\n   //     return vec3(0.0);\n   // }\n    \n  //  if (dotRV < 0.0) {\n   //     return lightIntensity * (k_d * dotLN);\n   // }\n    \n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.4,0.6,0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye, light1Pos, light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    vec3 light2Intensity = vec3(0.2);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye, light2Pos, light2Intensity);\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 dir = rayDirection( 45.0, iResolution.xy, fragCoord );\n    vec3 eye = vec3( 0.0, 0.0, 5.0 );\n    float dist = shortestDistanceToSurface( eye, dir, MIN_DIST, MAX_DIST);\n    \n    if( dist > MAX_DIST - EPSILON ) {\n        fragColor = vec4( 0.0 );\n        return;\n    }\n    \n    vec3 p = eye + dist * dir;\n    vec3 K_a = vec3( 0.2 );\n    vec3 K_d = vec3( 0.7, 0.2, 0.2 );\n    vec3 K_s = vec3( 1.0 );\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination( K_a, K_d, K_s, shininess, p, eye );\n    fragColor = vec4(color, 1.0);\n}\n    \n    \n    \n    \n    \n    \n    \n        \n        ","name":"Image","description":"","type":"image"}]}