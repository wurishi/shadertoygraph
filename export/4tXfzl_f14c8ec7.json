{"ver":"0.1","info":{"id":"4tXfzl","date":"1512832418","viewed":115,"name":"Mandelbrot Set Zooming","username":"neur0sys","description":"fractal","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n\tfragColor = vec4(texture(iChannel0, uv));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n/*\n\tMandelbrot set images may be created by sampling the complex \nnumbers and determining, for each sample point {\\displaystyle c} c,\nwhether the result of iterating the above function goes to infinity. \n\nTreating the real and imaginary parts of {\\displaystyle c} c as image \ncoordinates {\\displaystyle (x+yi)} {\\displaystyle (x+yi)} on the complex\nplane, pixels may then be colored according to how rapidly the \nsequence {\\displaystyle z_{n}^{2}+c} {\\displaystyle z_{n}^{2}+c}\ndiverges, with the color 0 (black) usually used for points where\nthe sequence does not diverge. If {\\displaystyle c} c is held constant \nand the initial value of {\\displaystyle z} z—denoted by \n{\\displaystyle z_{0}} z_{0}—is variable instead, one obtains the \ncorresponding Julia set for each point {\\displaystyle c} c in the parameter\nspace of the simple function.\n*/\n\n// z = z^2 + c\n\nconst float deg = 0.0174533;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    uv = uv * 2.0 - 1.0f;\n    uv.x *= iResolution.x / iResolution.y;\n\n    uv += vec2(-1.0f, 0.0);\n\n    int counter = 0;\n    float zr = 0.0f;\n    float zi = 0.0f;\n\n    float cr = uv.x;\n    float ci = uv.y;\n\n    int MAX_ITER = 500;\n    \n    // loop until counter > MAX_ITER or abs(z) < 2.0\n    while (true)\n    {\n        // z = z * z + c;\n        // (x + yi)(u + vi) = (xu - yv) + (xv + yu)i\n\n        // z * z\n        float z2r = zr * zr - zi * zi;\n        float z2i = zr * zi + zi * zr;\n        \n        // z_dot_z + c;\n        // (x + yi) + (u + vi) = (x + u) + (y + v)i\n        \n        zr = z2r + cr;\n        zi = z2i + ci;\n        \n        // |a + bi| = sqrt(a^2 + b^2)\n        \n        float zabs = sqrt(zr * zr + zi * zi);\n        \n        if (zabs >= 2.0f || counter++ > MAX_ITER) {\n            break;\n        }\n    }\n\n    float m = float(counter) / float(MAX_ITER);\n \n    m = 1.0 - (1.0 - m * 10.0);\n    \n\tfragColor = vec4(vec3(m), 1.0f);\n}","name":"Buf A","description":"","type":"buffer"}]}