{"ver":"0.1","info":{"id":"wtlBWB","date":"1597674643","viewed":157,"name":"Colorless Field","username":"JacobC","description":"Playing around with ray marching","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","sdf","smoothdistance"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define T iTime * .5\n#define Pi 3.14159\n\n#define R 4.5\n\n#define sp0 vec3(0., sin(T), 0.) * R\n#define sp1 vec3(sin(T), cos(T), 0.) * R\n#define sp2 vec3(-sin(T), cos(T), 0.) * R\n\n#define sp3 vec3(0., -sin(T), 0.) * R\n#define sp4 vec3(0., sin(T), cos(T)) * R\n#define sp5 vec3(0., sin(T), -cos(T)) * R\n\n#define sp6 vec3(-sin(T), 0., 0.) * R\n#define sp7 vec3(cos(T), sin(T), cos(T)) * R\n#define sp8 vec3(-cos(T), sin(T), -cos(T)) * R\n\n#define sp9 vec3(sin(T), 0., 0.) * R\n#define sp10 vec3(sin(T), sin(T), sin(T)) * R\n#define sp11 vec3(-sin(T), sin(T), -sin(T)) * R\n\n#define gr vec4(0., -101., 0., 100.)\n\n#define sc2 vec3(1., .5, 0.)\n#define sc1 vec3(.5, 0., 1.)\n#define sc0 vec3(0., 1., .5)\n\n#define sc3 vec3(.5, 1., 0.)\n#define sc4 vec3(1., 0., .5)\n#define sc5 vec3(0., .5, 1.)\n\n#define sc6 vec3(1., 1., 0.)\n#define sc7 vec3(1., 0., 1.)\n#define sc8 vec3(0., 1., 1.)\n\n#define sc9 vec3(1., 0., 0.)\n#define sc10 vec3(0., 0., 1.)\n#define sc11 vec3(0., 1., 0.)\n\n#define grc vec3(1., 1., 1.)\n\n\n#define sky vec3(.5, .7, 1.)\n#define ground vec3(0.)\n\nstruct mat\n{\n    float depth;\n    vec3 color;\n    float ref;\n};\n\nfloat sphere(in vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat torus(in vec3 p, in vec2 r)\n{\n    vec3 c = vec3(0.);\n    c.xz = p.xz / length(p.xz) * r.x;\n    return length(p - c) - r.y;\n}\n\nmat softUop(mat a, mat b, float k, float l)\n{\n    float f = min(a.depth, b.depth);\n    float g = max(.5 - abs((a.depth - b.depth))* .5, 0.) * k;\n    float h = clamp((a.depth - b.depth) * .5 + .5, .0, 1.) * (1. - l);\n    return mat(\n        mix(f, f - g, g), \n        mix(a.color, b.color, h),\n        mix(a.ref, b.ref, h)\n    );\n}\n\nmat scene(in vec3 p)\n{\n    p = mod(p, 14.) - 7.;\n    float rs = 1.;\n    \n    mat s0 = mat(sphere(p - sp0, rs), sc0, 1.);\n    mat s1 = mat(sphere(p - sp1, rs), sc1, 1.);\n    mat s2 = mat(sphere(p - sp2, rs), sc2, 1.);\n    \n    mat s3 = mat(sphere(p - sp3, rs), sc3, 1.);\n    mat s4 = mat(sphere(p - sp4, rs), sc4, 1.);\n    mat s5 = mat(sphere(p - sp5, rs), sc5, 1.);\n    \n    mat s6 = mat(sphere(p - sp6, rs), sc6, 1.);\n    mat s7 = mat(sphere(p - sp7, rs), sc7, 1.);\n    mat s8 = mat(sphere(p - sp8, rs), sc8, 1.);\n    \n    mat s9 = mat(sphere(p - sp9, rs), sc9, 1.);\n    mat s10 = mat(sphere(p - sp10, rs), sc10, 1.);\n    mat s11 = mat(sphere(p - sp11, rs), sc11, 1.);\n    \n    float rt = max(sin(T)*2.5, 0.);\n    mat t0 = mat(torus(p, vec2(rt, .5)), vec3(1.), 0.);\n    mat t1 = mat(torus(p.xzy, vec2(rt, .5)), vec3(1.), 0.);\n    mat t2 = mat(torus(p.zxy, vec2(rt, .5)), vec3(1.), 0.);\n    \n    mat s = softUop(s0, softUop(s1, s2, 1., 0.), 1., 0.);\n    s = softUop(s, softUop(s3, softUop(s4, s5, 1., 0.), 1., 0.), 1., 0.);\n    s = softUop(s, softUop(s6, softUop(s7, s8, 1., 0.), 1., 0.), 1., 0.);\n    s = softUop(s, softUop(s9, softUop(s10, s11, 1., 0.), 1., 0.), 1., 0.);\n    \n    mat t = softUop(t0, softUop(t1, t2, 1., 0.), 1., .0);\n    s = softUop(s, t, 1., .0);    \n    \n    return s;\n}\n\nvec3 normal(in vec3 p)\n{\n    vec2 e = vec2(.01, .0);\n    float d = scene(p).depth;\n    vec3 n = d - vec3(scene(p - e.xyy).depth, scene(p - e.yxy).depth, scene(p - e.yyx).depth);\n    return normalize(n);\n}\n\nmat marcher(in vec3 o, in vec3 d)\n{\n    float t = 0.;\n    for (int i = 0; i < 99; i++)\n    {\n        mat s = scene(o + d * t);\n        t += s.depth * .45;\n        if (s.depth < .025)\n            return mat(t, s.color, s.ref);\n        if (t > 30.)\n            return mat(t, vec3(-1.), -1.);\n    }\n    return mat(t, vec3(-1.), -1.);\n}\n\nvec3 camera(in vec2 p, in vec3 o, in vec3 t)\n{\n    vec3 w = normalize(o - t);\n    vec3 u = normalize(cross(vec3(0., 1., 0.), w));\n    vec3 v = cross(w, u);\n    return p.x * u + p.y * v - w;\n}\n\n#define AA 2. // Improve Detail(drawback: gets slow)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 f_col = vec3(0.);\n    vec2 st = fragCoord;\n    for (float y = 0.; y < AA; y++)\n    {\n        for (float x = 0.; x < AA; x++)\n        {\n            vec2 n = vec2(x, y) / AA - .5;\n            vec2 uv = ((st + n) - iResolution.xy * .5) / iResolution.y;\n            vec2 ms = (iMouse.xy - iResolution.xy * .5) / iResolution.y;\n\n            float sn = sin(ms.x * Pi);\n\n            vec3 o = vec3(sn, ms.y * 6., T * 3.);\n            vec3 t = vec3(0., 0., 1. + T * 3.);\n            vec3 d = camera(uv, o, t);\n            \n            vec3 back = mix(ground, sky, d.y * .5 + .5);\n            vec3 col = back;\n\n            mat m = marcher(o, d);\n            if(m.ref > -1.)\n            {\n                vec3 p = o + d * m.depth;\n                vec3 n = normal(p) * .5 + .5;\n                vec3 ambient = mix(ground, sky, n.y * .5 + .5);\n                col = mix(m.color * ambient, back, clamp(m.depth / 30., 0., 1.));\n            }\n            f_col += col;\n        }\n    }\n    f_col /= AA * AA;\n\n    fragColor = vec4(sqrt(f_col),1.0);\n}","name":"Image","description":"","type":"image"}]}