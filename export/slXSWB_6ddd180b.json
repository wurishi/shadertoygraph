{"ver":"0.1","info":{"id":"slXSWB","date":"1626422525","viewed":70,"name":"Pivot Point calcule","username":"iuryBorgesRodrigues","description":"I'm providing the pivot point calculation, useful for those who want to make day trader, very accurate strategy","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["pivotpoint"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// GPU printf\n// Inspired by https://www.shadertoy.com/view/Mt2GWD\n// Thanks to morimea, FabriceNeyret2 for suggestions.\n//\n// Usage: see drawText() for quick-start and API section for all available functions\n\n// Options\n#define GPF_MACROS\t\t\t\t1\t\t// use macros to ease writing text/numbers\n#define GPF_PRINT_FLOAT_USE_INT\t1\n#define GPF_SCALE\t\t\t\t2.0\t\t// scale the font\n#define GPF_MAX_INT_DIGITS\t\t10\n#define GPF_MAX_DECIMAL_DIGITS\t6\n\n///////////////////////////////////////////////////////////////\n// Data\n///////////////////////////////////////////////////////////////\n\n// Automatically generated from the 8x12 font sheet here:\n// http://www.massmind.org/techref/datafile/charset/extractor/charset_extractor.htm\n\n\nvec4 gpf_digits[10] = vec4[]\n(\n    vec4(0x007CC6,0xD6D6D6,0xD6D6C6,0x7C0000), // 0\n    vec4(0x001030,0xF03030,0x303030,0xFC0000), // 1\n    vec4(0x0078CC,0xCC0C18,0x3060CC,0xFC0000), // 2\n    vec4(0x0078CC,0x0C0C38,0x0C0CCC,0x780000), // 3\n    vec4(0x000C1C,0x3C6CCC,0xFE0C0C,0x1E0000), // 4\n    vec4(0x00FCC0,0xC0C0F8,0x0C0CCC,0x780000), // 5\n    vec4(0x003860,0xC0C0F8,0xCCCCCC,0x780000), // 6\n    vec4(0x00FEC6,0xC6060C,0x183030,0x300000), // 7\n    vec4(0x0078CC,0xCCEC78,0xDCCCCC,0x780000), // 8\n    vec4(0x0078CC,0xCCCC7C,0x181830,0x700000)  // 9\n);\n\n// ascii table starting from 32\nvec4 ch_spc = vec4(0x000000,0x000000,0x000000,0x000000); // (space)\nvec4 ch_exc = vec4(0x003078,0x787830,0x300030,0x300000); // !\nvec4 ch_quo = vec4(0x006666,0x662400,0x000000,0x000000); // \"\nvec4 ch_hsh = vec4(0x006C6C,0xFE6C6C,0x6CFE6C,0x6C0000); // #\nvec4 ch_dol = vec4(0x30307C,0xC0C078,0x0C0CF8,0x303000); // $\nvec4 ch_pct = vec4(0x000000,0xC4CC18,0x3060CC,0x8C0000); // %\nvec4 ch_amp = vec4(0x0070D8,0xD870FA,0xDECCDC,0x760000); // &\nvec4 ch_apo = vec4(0x003030,0x306000,0x000000,0x000000); // '\nvec4 ch_lbr = vec4(0x000C18,0x306060,0x603018,0x0C0000); // (\nvec4 ch_rbr = vec4(0x006030,0x180C0C,0x0C1830,0x600000); // )\nvec4 ch_ast = vec4(0x000000,0x663CFF,0x3C6600,0x000000); // *\nvec4 ch_crs = vec4(0x000000,0x18187E,0x181800,0x000000); // +\nvec4 ch_com = vec4(0x000000,0x000000,0x000038,0x386000); // ,\nvec4 ch_dsh = vec4(0x000000,0x0000FE,0x000000,0x000000); // -\nvec4 ch_per = vec4(0x000000,0x000000,0x000038,0x380000); // .\nvec4 ch_lsl = vec4(0x000002,0x060C18,0x3060C0,0x800000); // /\nvec4 ch_0   = vec4(0x007CC6,0xD6D6D6,0xD6D6C6,0x7C0000); // 0\nvec4 ch_1   = vec4(0x001030,0xF03030,0x303030,0xFC0000); // 1\nvec4 ch_2   = vec4(0x0078CC,0xCC0C18,0x3060CC,0xFC0000); // 2\nvec4 ch_3   = vec4(0x0078CC,0x0C0C38,0x0C0CCC,0x780000); // 3\nvec4 ch_4   = vec4(0x000C1C,0x3C6CCC,0xFE0C0C,0x1E0000); // 4\nvec4 ch_5   = vec4(0x00FCC0,0xC0C0F8,0x0C0CCC,0x780000); // 5\nvec4 ch_6   = vec4(0x003860,0xC0C0F8,0xCCCCCC,0x780000); // 6\nvec4 ch_7   = vec4(0x00FEC6,0xC6060C,0x183030,0x300000); // 7\nvec4 ch_8   = vec4(0x0078CC,0xCCEC78,0xDCCCCC,0x780000); // 8\nvec4 ch_9   = vec4(0x0078CC,0xCCCC7C,0x181830,0x700000); // 9\nvec4 ch_col = vec4(0x000000,0x383800,0x003838,0x000000); // :\nvec4 ch_scl = vec4(0x000000,0x383800,0x003838,0x183000); // ;\nvec4 ch_les = vec4(0x000C18,0x3060C0,0x603018,0x0C0000); // <\nvec4 ch_equ = vec4(0x000000,0x007E00,0x7E0000,0x000000); // =\nvec4 ch_grt = vec4(0x006030,0x180C06,0x0C1830,0x600000); // >\nvec4 ch_que = vec4(0x0078CC,0x0C1830,0x300030,0x300000); // ?\nvec4 ch_ats = vec4(0x007CC6,0xC6DEDE,0xDEC0C0,0x7C0000); // @\nvec4 ch_A   = vec4(0x003078,0xCCCCCC,0xFCCCCC,0xCC0000); // A\nvec4 ch_B   = vec4(0x00FC66,0x66667C,0x666666,0xFC0000); // B\nvec4 ch_C   = vec4(0x003C66,0xC6C0C0,0xC0C666,0x3C0000); // C\nvec4 ch_D   = vec4(0x00F86C,0x666666,0x66666C,0xF80000); // D\nvec4 ch_E   = vec4(0x00FE62,0x60647C,0x646062,0xFE0000); // E\nvec4 ch_F   = vec4(0x00FE66,0x62647C,0x646060,0xF00000); // F\nvec4 ch_G   = vec4(0x003C66,0xC6C0C0,0xCEC666,0x3E0000); // G\nvec4 ch_H   = vec4(0x00CCCC,0xCCCCFC,0xCCCCCC,0xCC0000); // H\nvec4 ch_I   = vec4(0x007830,0x303030,0x303030,0x780000); // I\nvec4 ch_J   = vec4(0x001E0C,0x0C0C0C,0xCCCCCC,0x780000); // J\nvec4 ch_K   = vec4(0x00E666,0x6C6C78,0x6C6C66,0xE60000); // K\nvec4 ch_L   = vec4(0x00F060,0x606060,0x626666,0xFE0000); // L\nvec4 ch_M   = vec4(0x00C6EE,0xFEFED6,0xC6C6C6,0xC60000); // M\nvec4 ch_N   = vec4(0x00C6C6,0xE6F6FE,0xDECEC6,0xC60000); // N\nvec4 ch_O   = vec4(0x00386C,0xC6C6C6,0xC6C66C,0x380000); // O\nvec4 ch_P   = vec4(0x00FC66,0x66667C,0x606060,0xF00000); // P\nvec4 ch_Q   = vec4(0x00386C,0xC6C6C6,0xCEDE7C,0x0C1E00); // Q\nvec4 ch_R   = vec4(0x00FC66,0x66667C,0x6C6666,0xE60000); // R\nvec4 ch_S   = vec4(0x0078CC,0xCCC070,0x18CCCC,0x780000); // S\nvec4 ch_T   = vec4(0x00FCB4,0x303030,0x303030,0x780000); // T\nvec4 ch_U   = vec4(0x00CCCC,0xCCCCCC,0xCCCCCC,0x780000); // U\nvec4 ch_V   = vec4(0x00CCCC,0xCCCCCC,0xCCCC78,0x300000); // V\nvec4 ch_W   = vec4(0x00C6C6,0xC6C6D6,0xD66C6C,0x6C0000); // W\nvec4 ch_X   = vec4(0x00CCCC,0xCC7830,0x78CCCC,0xCC0000); // X\nvec4 ch_Y   = vec4(0x00CCCC,0xCCCC78,0x303030,0x780000); // Y\nvec4 ch_Z   = vec4(0x00FECE,0x981830,0x6062C6,0xFE0000); // Z\nvec4 ch_lsb = vec4(0x003C30,0x303030,0x303030,0x3C0000); // [\nvec4 ch_rsl = vec4(0x000080,0xC06030,0x180C06,0x020000); // right slash\nvec4 ch_rsb = vec4(0x003C0C,0x0C0C0C,0x0C0C0C,0x3C0000); // ]\nvec4 ch_pow = vec4(0x10386C,0xC60000,0x000000,0x000000); // ^\nvec4 ch_usc = vec4(0x000000,0x000000,0x000000,0x00FF00); // _\nvec4 ch_a   = vec4(0x000000,0x00780C,0x7CCCCC,0x760000); // a\nvec4 ch_b   = vec4(0x00E060,0x607C66,0x666666,0xDC0000); // b\nvec4 ch_c   = vec4(0x000000,0x0078CC,0xC0C0CC,0x780000); // c\nvec4 ch_d   = vec4(0x001C0C,0x0C7CCC,0xCCCCCC,0x760000); // d\nvec4 ch_e   = vec4(0x000000,0x0078CC,0xFCC0CC,0x780000); // e\nvec4 ch_f   = vec4(0x00386C,0x6060F8,0x606060,0xF00000); // f\nvec4 ch_g   = vec4(0x000000,0x0076CC,0xCCCC7C,0x0CCC78); // g\nvec4 ch_h   = vec4(0x00E060,0x606C76,0x666666,0xE60000); // h\nvec4 ch_i   = vec4(0x001818,0x007818,0x181818,0x7E0000); // i\nvec4 ch_j   = vec4(0x000C0C,0x003C0C,0x0C0C0C,0xCCCC78); // j\nvec4 ch_k   = vec4(0x00E060,0x60666C,0x786C66,0xE60000); // k\nvec4 ch_l   = vec4(0x007818,0x181818,0x181818,0x7E0000); // l\nvec4 ch_m   = vec4(0x000000,0x00FCD6,0xD6D6D6,0xC60000); // m\nvec4 ch_n   = vec4(0x000000,0x00F8CC,0xCCCCCC,0xCC0000); // n\nvec4 ch_o   = vec4(0x000000,0x0078CC,0xCCCCCC,0x780000); // o\nvec4 ch_p   = vec4(0x000000,0x00DC66,0x666666,0x7C60F0); // p\nvec4 ch_q   = vec4(0x000000,0x0076CC,0xCCCCCC,0x7C0C1E); // q\nvec4 ch_r   = vec4(0x000000,0x00EC6E,0x766060,0xF00000); // r\nvec4 ch_s   = vec4(0x000000,0x0078CC,0x6018CC,0x780000); // s\nvec4 ch_t   = vec4(0x000020,0x60FC60,0x60606C,0x380000); // t\nvec4 ch_u   = vec4(0x000000,0x00CCCC,0xCCCCCC,0x760000); // u\nvec4 ch_v   = vec4(0x000000,0x00CCCC,0xCCCC78,0x300000); // v\nvec4 ch_w   = vec4(0x000000,0x00C6C6,0xD6D66C,0x6C0000); // w\nvec4 ch_x   = vec4(0x000000,0x00C66C,0x38386C,0xC60000); // x\nvec4 ch_y   = vec4(0x000000,0x006666,0x66663C,0x0C18F0); // y\nvec4 ch_z   = vec4(0x000000,0x00FC8C,0x1860C4,0xFC0000); // z\nvec4 ch_lpa = vec4(0x001C30,0x3060C0,0x603030,0x1C0000); // {\nvec4 ch_bar = vec4(0x001818,0x181800,0x181818,0x180000); // |\nvec4 ch_rpa = vec4(0x00E030,0x30180C,0x183030,0xE00000); // }\nvec4 ch_tid = vec4(0x0073DA,0xCE0000,0x000000,0x000000); // ~\nvec4 ch_lar = vec4(0x000000,0x10386C,0xC6C6FE,0x000000); // DEL\n\n\n///////////////////////////////////////////////////////////////\n// API\n///////////////////////////////////////////////////////////////\n\n// globals\nvec2 gpf_gRes      = vec2(0); // by default init to top-left\nvec2 gpf_gPrintPos = vec2(0);\nvec2 gpf_gUV       = vec2(0);\n\nvec2  gpf_char_size()                   { return vec2(8, 12); }\nfloat gpf_char_size_x()                 { return gpf_char_size().x; }\nfloat gpf_char_size_y()                 { return gpf_char_size().y; }\nvec2  gpf_char_spacing()                { return vec2(8, 12); }\nfloat gpf_char_spacing_x()              { return gpf_char_spacing().x; }\nfloat gpf_char_spacing_y()              { return gpf_char_spacing().y; }\nvoid  gpf_reset_pos()                   { gpf_gPrintPos = vec2(0.0, gpf_gRes.y - gpf_char_spacing_y()); }\nvoid  gpf_set_pos(float x, float y)     { gpf_gPrintPos = vec2(x, y); }\nvoid  gpf_newline()                     { gpf_gPrintPos.x = 0.0; gpf_gPrintPos.y -= gpf_char_spacing_y(); }\nvoid  gpf_init(vec2 res, vec2 scrcoord) { gpf_gRes = res / GPF_SCALE; gpf_reset_pos(); gpf_gUV = floor(scrcoord.xy / GPF_SCALE); }\nfloat gpf_char(vec4 ch);\nfloat gpf_print_number(float number);\nfloat gpf_print_integer(float number, int zeros);\n\n\n///////////////////////////////////////////////////////////////\n// Implementation\n///////////////////////////////////////////////////////////////\n\n// Extracts bit b from the given number.\n// Shifts bits right (num / 2^bit) then ANDs the result with 1 (mod(result,2.0)).\nfloat _gpf_extract_bit(float n, float b)\n{\n    b = clamp(b,-1.0,24.0);\n\treturn floor(mod(floor(n / pow(2.0,floor(b))),2.0));   \n}\n\n// Returns the pixel at uv in the given bit-packed _gpf_sprite.\nfloat _gpf_sprite(vec4 spr, vec2 size, vec2 uv)\n{\n    uv = floor(uv);\n    \n    //Calculate the bit to extract (x + y * width) (flipped on x-axis)\n    float bit = (size.x-uv.x-1.0) + uv.y * size.x;\n    \n    //Clipping bound to remove garbage outside the _gpf_sprite's boundaries.\n    bool bounds = all(greaterThanEqual(uv,vec2(0))) && all(lessThan(uv,size));\n    \n    float pixels = 0.0;\n    pixels += _gpf_extract_bit(spr.x, bit - 72.0);\n    pixels += _gpf_extract_bit(spr.y, bit - 48.0);\n    pixels += _gpf_extract_bit(spr.z, bit - 24.0);\n    pixels += _gpf_extract_bit(spr.w, bit - 00.0);\n    \n    return bounds ? pixels : 0.0;\n}\n\n// Returns the digit _gpf_sprite for the given number.\nvec4 _gpf_get_digit(int index)\n{\n    return 0 <= index && index < 10 ? gpf_digits[index] : gpf_digits[0];\n}\n\n// value >= 0\nint _gpf_count_digits(int value, int maxDigits)\n{\n    int count = 1;\n    \n    for (int i=0; i<maxDigits; i++)\n    {        \n        value /= 10;\n        if (value == 0)\n            break;\n        count++;\n    }\n    \n    return count;\n}\n\n// value >= 0\n// NOTE: modifies value\nivec2 _gpf_count_decimal_digits(inout int value, int maxDigits)\n{\n    int zeros = 0;\n    for (int i=0; i<maxDigits; i++)\n    {\n        if (value == 0)\n            break;\n        if (value % 10 > 0)\n            break;\n        value /= 10;\n        zeros++;\n    }\n    return ivec2(_gpf_count_digits(value, maxDigits), zeros);\n}\n\n// draw from last digit to first\nfloat _gpf_int_positive(int value, int digitCount)\n{\n    float result = 0.0;\n    \n    gpf_gPrintPos.x += gpf_char_spacing_x() * float(digitCount - 1);\n\n    for (int i=0; i<digitCount; i++)\n    {\n        result += gpf_char(_gpf_get_digit(value % 10));\n        value /= 10;\n        gpf_gPrintPos.x -= 2.0 * gpf_char_spacing_x();\n    }\n    gpf_gPrintPos.x += gpf_char_spacing_x() * float(digitCount + 1);\n\n    return result;\n}\n\n// Prints a character and moves the print position forward by 1 character width.\nfloat gpf_char(vec4 ch)\n{\n\tvec2 uv = gpf_gUV;\n\t\n    float px = _gpf_sprite(ch, gpf_char_size(), uv - gpf_gPrintPos);\n    gpf_gPrintPos.x += gpf_char_spacing_x();\n    return px;\n}\n\n\nfloat gpf_int(int value)\n{\n    float result = 0.0;\n    \n    if (value == -2147483648)\n    {\n        result += gpf_char(ch_dsh);\n        result += gpf_char(ch_2);\n        result += gpf_char(ch_1);\n        result += gpf_char(ch_4);\n        result += gpf_char(ch_7);\n        result += gpf_char(ch_4);\n        result += gpf_char(ch_8);\n        result += gpf_char(ch_3);\n        result += gpf_char(ch_6);\n        result += gpf_char(ch_4);\n        result += gpf_char(ch_8);        \n    }\n    else\n    {\n        if (value < 0)\n        {\n            result += gpf_char(ch_dsh); // add -\n            value = -value;\n        }\n\n        int digitCount = _gpf_count_digits(value, GPF_MAX_INT_DIGITS);\n        result += _gpf_int_positive(value, digitCount);\n    }\n        \n    return result;\n}\n\nint _gpf_int_pow(int a, int b)\n{\n    int ret = 1;\n    for (int i=0; i<b; i++)\n        ret *= a;\n    return ret;\n}\n\nfloat _gpf_float_frac(float value, int maxDecimalDigits)\n{\n    float result = 0.0;       \n    \n    int decimalValue = int(fract(abs(value)) * float(_gpf_int_pow(10, maxDecimalDigits)));\n    if (decimalValue == 0)\n    {\n        result += gpf_char(ch_0);\n    }\n    else\n    {\n        ivec2 decimalDigits = _gpf_count_decimal_digits(decimalValue, maxDecimalDigits);\n        int lzeros = maxDecimalDigits - decimalDigits.x - decimalDigits.y;\n        for (int i=0; i<lzeros; i++)\n            result += gpf_char(ch_0);\n        result += _gpf_int_positive(decimalValue, decimalDigits.x);\n    }    \n    \n    return result;\n}\n\nfloat gpf_float(float value, int maxDecimalDigits)\n{\n    float result = 0.0;\n    \n    if (isnan(value))\n    {\n        result += gpf_char(ch_N);\n        result += gpf_char(ch_a);\n        result += gpf_char(ch_N);\n    }    \n    else if (isinf(value))\n    {\n        result += gpf_char(ch_I);\n        result += gpf_char(ch_n);\n        result += gpf_char(ch_f);\n    }\n    else\n    {\n    #if GPF_PRINT_FLOAT_USE_INT\n        // TODO: Since we are working with bits, we can actually detect nan/inf manually\n        uint bits = floatBitsToUint(value);\n        bool isNegative = (bits >> 31) != 0u;\n        uint mantissa = bits & ((1u << 23) - 1u);\n        uint exponent = (bits >> 23) & ((1u << 8) - 1u);\n                \n        if (isNegative)\n        {\n            result += gpf_char(ch_dsh);\n        }\n        \n        if (mantissa == 0u && exponent == 0u)\n        {\n            result += gpf_char(ch_0);\n            result += gpf_char(ch_per);\n            \n            for (int i=0; i<maxDecimalDigits; i++)\n                result += gpf_char(ch_0);\n        }\n        else\n        {\n            uint m2 = (1u << 23) | mantissa;\n            int e2 = 23 - (int(exponent) - 127);\n\n            // separate m2 into integer part/fractional part\n            uint i = m2 >> e2;\n            uint f = m2 - (i << e2);\n\n            result += gpf_int(int(i));\n            result += gpf_char(ch_per);\n\n            uint fmask = (1u << e2) - 1u;\n\t\t\tfor (int i = 0; i < maxDecimalDigits; i++)\n\t\t\t{\n\t\t\t\tf *= 10u;\n                result += gpf_char(_gpf_get_digit(int(f >> e2)));\n\t\t\t\tf &= fmask;\n\n\t\t\t\tif (f == 0u)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n    #else\n        result += gpf_int(int(value));\n        result += gpf_char(ch_per); // .\n        result += _gpf_float_frac(value, maxDecimalDigits);    \n    #endif\n    }\n    \n    return result;\n}\n\n///////////////////////////////////////////////////////////////\n// Macros\n///////////////////////////////////////////////////////////////\n#if GPF_MACROS\n\t#define _a    col += gpf_char(ch_a);\n\t#define _b    col += gpf_char(ch_b);\n\t#define _c    col += gpf_char(ch_c);\n\t#define _d    col += gpf_char(ch_d);\n\t#define _e    col += gpf_char(ch_e);\n\t#define _f    col += gpf_char(ch_f);\n\t#define _g    col += gpf_char(ch_g);\n\t#define _h    col += gpf_char(ch_h);\n\t#define _i    col += gpf_char(ch_i);\n\t#define _j    col += gpf_char(ch_j);\n\t#define _k    col += gpf_char(ch_k);\n\t#define _l    col += gpf_char(ch_l);\n\t#define _m    col += gpf_char(ch_m);\n\t#define _n    col += gpf_char(ch_n);\n\t#define _o    col += gpf_char(ch_o);\n\t#define _p    col += gpf_char(ch_p);\n\t#define _q    col += gpf_char(ch_q);\n\t#define _r    col += gpf_char(ch_r);\n\t#define _s    col += gpf_char(ch_s);\n\t#define _t    col += gpf_char(ch_t);\n\t#define _u    col += gpf_char(ch_u);\n\t#define _v    col += gpf_char(ch_v);\n\t#define _w    col += gpf_char(ch_w);\n\t#define _x    col += gpf_char(ch_x);\n\t#define _y    col += gpf_char(ch_y);\n\t#define _z    col += gpf_char(ch_z);\n\t#define _A    col += gpf_char(ch_A);\n\t#define _B    col += gpf_char(ch_B);\n\t#define _C    col += gpf_char(ch_C);\n\t#define _D    col += gpf_char(ch_D);\n\t#define _E    col += gpf_char(ch_E);\n\t#define _F    col += gpf_char(ch_F);\n\t#define _G    col += gpf_char(ch_G);\n\t#define _H    col += gpf_char(ch_H);\n\t#define _I    col += gpf_char(ch_I);\n\t#define _J    col += gpf_char(ch_J);\n\t#define _K    col += gpf_char(ch_K);\n\t#define _L    col += gpf_char(ch_L);\n\t#define _M    col += gpf_char(ch_M);\n\t#define _N    col += gpf_char(ch_N);\n\t#define _O    col += gpf_char(ch_O);\n\t#define _P    col += gpf_char(ch_P);\n\t#define _Q    col += gpf_char(ch_Q);\n\t#define _R    col += gpf_char(ch_R);\n\t#define _S    col += gpf_char(ch_S);\n\t#define _T    col += gpf_char(ch_T);\n\t#define _U    col += gpf_char(ch_U);\n\t#define _V    col += gpf_char(ch_V);\n\t#define _W    col += gpf_char(ch_W);\n\t#define _X    col += gpf_char(ch_X);\n\t#define _Y    col += gpf_char(ch_Y);\n\t#define _Z    col += gpf_char(ch_Z);\n\t#define _0    col += gpf_char(ch_0);\n\t#define _1    col += gpf_char(ch_1);\n\t#define _2    col += gpf_char(ch_2);\n\t#define _3    col += gpf_char(ch_3);\n\t#define _4    col += gpf_char(ch_4);\n\t#define _5    col += gpf_char(ch_5);\n\t#define _6    col += gpf_char(ch_6);\n\t#define _7    col += gpf_char(ch_7);\n\t#define _8    col += gpf_char(ch_8);\n\t#define _9    col += gpf_char(ch_9);\n\t#define _    col += gpf_char(ch_spc);\n\t\n\t#define _newline_    gpf_newline();\t\n\t#define println_i(x)   col += gpf_int(x); _newline_\n\tfloat println_f(float x){ return  gpf_float(x, GPF_MAX_DECIMAL_DIGITS); }\n\t#define print_i(x)     col += gpf_int(x)\n\t#define print_f(x)     col += gpf_float(x, GPF_MAX_DECIMAL_DIGITS)\n#endif // #if GPF_MACROS\n\n\nfloat nome(vec2 screenCoord)\n{\n\tgpf_init(iResolution.xy, screenCoord.xy);\n\t\n\t\n\tfloat char=gpf_char(ch_E);\n    char+=gpf_char(ch_N);\n    char+=gpf_char(ch_G);\n    char+=gpf_char(ch_O);\n    char+=gpf_char(ch_L);\n    char+=gpf_char(ch_F);\n    char+=gpf_char(ch_O);\n    char+=gpf_char(ch_spc);\n    char+=gpf_char(ch_D);\n    char+=gpf_char(ch_E);\n    char+=gpf_char(ch_spc);\n    char+=gpf_char(ch_A);\n    char+=gpf_char(ch_L);\n    char+=gpf_char(ch_T);\n    char+=gpf_char(ch_A);\n        \n    return  char;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCicle(vec2 p,float r){\n\nreturn length(p)-r;\n\n}\n\nfloat pivoPoint(vec2 screenCoord,float MAX, float MIN,float CLOSE){\n\ngpf_init(iResolution.xy, screenCoord.xy);\n\nfloat P=(MAX+MIN+CLOSE)/3.0;\nfloat R1 = (2.0*P)-MIN;\nfloat S1 = (2.0*P)-MAX;\nfloat R2 = (P+MAX - MIN);\nfloat S2 = (P-MAX - MIN);\nfloat R3 = ((2.0*P)+MAX-(2.0*MIN));\nfloat S3 = (2.0*P)-((2.0* MAX)-MIN);\n\n\n\n\t\n\t\nfloat char=gpf_char(ch_P);\nchar+=gpf_char(ch_I);\nchar+=gpf_char(ch_V);\nchar+=gpf_char(ch_O);\nchar+=gpf_char(ch_T);\n\nchar+=gpf_char(ch_spc);\nchar+=gpf_char(ch_P);\nchar+=gpf_char(ch_O);\nchar+=gpf_char(ch_I);\nchar+=gpf_char(ch_N);\nchar+=gpf_char(ch_T);\n\n\ngpf_newline();\ngpf_newline();\n\nchar+=gpf_char(ch_P);\nchar+=gpf_char(ch_col);\nchar+= println_f(P);\ngpf_newline();\n\nchar+=gpf_char(ch_R);\nchar+= gpf_char(ch_1);\nchar+=gpf_char(ch_col);\nchar+= println_f(R1);\ngpf_newline();\n\nchar+=gpf_char(ch_S);\nchar+= gpf_char(ch_1);\nchar+=gpf_char(ch_col);\nchar+= println_f(S1);\ngpf_newline();\n\nchar+=gpf_char(ch_R);\nchar+= gpf_char(ch_2);\nchar+=gpf_char(ch_col);\nchar+= println_f(R2);\ngpf_newline();\n\nchar+=gpf_char(ch_S);\nchar+= gpf_char(ch_2);\nchar+=gpf_char(ch_col);\nchar+= println_f(S2);\ngpf_newline();\n\nchar+=gpf_char(ch_R);\nchar+= gpf_char(ch_3);\nchar+=gpf_char(ch_col);\nchar+= println_f(R3);\ngpf_newline();\n\nchar+=gpf_char(ch_S);\nchar+= gpf_char(ch_3);\nchar+=gpf_char(ch_col);\nchar+= println_f(S3);\ngpf_newline();\n\nreturn char;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    //price day candlestick max\n    float Max=33206.2;\n    //price day candlestick min\n    float Min=31145.3;\n    //price day candlestick close\n    float Close=31870.8;\n    \n    \n\tfloat pixel =  pivoPoint(fragCoord-vec2(iResolution.x/2.8,(iResolution.y/18.0)*-1.0),Max,Min,Close);\n   \n    \n    \n\n    \n    vec3 col=vec3(0.0);\n     \n    col+=vec3(pixel)*vec3(1.0,1.0,0.0);\n    \n\n    \n    \n\tfragColor = vec4(col, 1.0);\n    \n}","name":"Image","description":"","type":"image"}]}