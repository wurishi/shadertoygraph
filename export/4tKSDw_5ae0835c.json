{"ver":"0.1","info":{"id":"4tKSDw","date":"1484599109","viewed":97,"name":"Raymarching 2 - Lights On!","username":"ptrgags","description":"Part two of my series of learning how to raymarch. Again following http://9bitscience.blogspot.com/2013/07/raymarching-distance-fields_14.html.\n\nControl the light position with the mouse.\n\nNext time I'll add shadows.\n\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 300\n#define EPSILON 0.0001\n#define CENTER (iResolution.xy / 2.0)\n\n//Translate a point in space\nvec3 translate(vec3 point, vec3 displacement) {\n    return point - displacement;\n}\n\n//Distance estimators from https://iquilezles.org/articles/distfunctions\n//Distance to sphere centered at the origin\nfloat sphere_dist(vec3 ray, float radius) {\n    return length(ray) - radius;\n}\n\n//Distance from the infinte plane y = ground_y\nfloat ground_dist(vec3 ray, float ground_y) {\n    return abs(ray.y - ground_y);\n}\n\n//Distance to a box centered at the origin with given dimensions.\n//This is the unsigned implementation\nfloat box_dist(vec3 ray, vec3 box_dims) {\n    return length(max(abs(ray) - box_dims, 0.0));\n}\n\nfloat scene_dist(vec3 ray_pos) {\n    //Sphere of radius 0.5 centered at the origin\n    float sphere1 = sphere_dist(ray_pos, 0.5);\n    \n    //Sphere of radius 0.5 centered at (1, 0, 1)\n    vec3 sphere2_pos = translate(ray_pos, vec3(1.0, 0.0, 1.0));\n    float sphere2 = sphere_dist(sphere2_pos, 0.5);\n    \n    //Infinte plane of the ground\n    float ground = ground_dist(ray_pos, -0.4);\n    \n    //box centered at (-2, 1, 1)\n    vec3 box_pos = translate(ray_pos, vec3(-1.5, 0.5, 1.0));\n    vec3 box_dims = vec3(0.5, 1.0, 0.5);\n    float box = box_dist(box_pos, box_dims);\n    \n    //carve a hole in the box\n    float hole = sphere_dist(box_pos, 0.6);\n    box = max(box, -hole);\n    \n    //Union of all the elements\n    float spheres = min(sphere1, sphere2);\n    float plus_box = min(spheres, box);\n   \tfloat plus_ground = min(plus_box, ground);\n    \n    //Return the whole scene\n    return plus_ground;\n}\n\n/** \n * Calculate the normal direction based on the\n * distance function.\n * Based on https://github.com/lightbits/ray-march/blob/master/data/raymarch.fs#L136\n */\nvec3 calc_normal(vec3 p) {\n    //small change in each component\n    float h = 0.0001;\n    \n    //Calculate the components of the gradient. Ignore the bottom part of the\n    //fraction since we're normalizing anyway\n    float grad_x = scene_dist(p + vec3(h, 0, 0)) - scene_dist(p - vec3(h, 0, 0));\n    float grad_y = scene_dist(p + vec3(0, h, 0)) - scene_dist(p - vec3(0, h, 0));\n    float grad_z = scene_dist(p + vec3(0, 0, h)) - scene_dist(p - vec3(0, 0, h));\n    \n    //Create the gradient vector and normalize\n    vec3 gradient = vec3(grad_x, grad_y, grad_z);\n    return normalize(gradient);\n}\n\nstruct RaymarchResults {\n    //Number of iterations to reach the surface\n    //or -1 if no surface point was found\n    float iterations;\n    //Point on the surface. Invalid if \n    //iterations is -1\n    vec3 surface_point;\n};\n\n//Following tutorial from http://9bitscience.blogspot.com/2013/07/raymarching-distance-fields_14.html\n//however, this function returns the iteration count for coloring\nRaymarchResults raymarch(vec3 origin, vec3 direction) {\n    RaymarchResults results;\n    float t = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        //Current position of ray\n        vec3 ray_pos = origin + t * direction;\n        \n        //Distance from ray to nearest point in scene\n        float dist = scene_dist(ray_pos);\n        \n        //If we're close to the surface, return the results\n        if (dist < EPSILON) {\n            results.iterations = float(i);\n            results.surface_point = ray_pos;\n            return results;\n        }\n       \t//Otherwise, march forwards \n        else\n       \t\tt += dist;\n    }\n    results.iterations = -1.0;\n    return results;\n}\n\n/*\n * Simple Shade function taken from \n * http://9bitscience.blogspot.com/2013/07/raymarching-distance-fields_14.html\n */\nvec4 shade(vec3 p, vec3 light_pos, vec4 light_color) {\n    vec3 normal = calc_normal(p);\n    vec3 light_dir = normalize(light_pos - p);\n    float intensity = dot(normal, light_dir);\n    return intensity * light_color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \t//UV Coordinates, accounting for aspect ratio\n\tvec2 uv = (fragCoord.xy - CENTER) / iResolution.y;\n    \n    //Pretend the screen coordinate is on a plane\n    //at z=-0.5\n    vec3 image = vec3(uv, -0.6);\n    \n    //Camera's eye, looking in the +z direction\n    vec3 eye = vec3(0.0, 0.0, -1.0);\n    \n    //Direction from eye to screen\n    vec3 direction = normalize(image - eye);\n    \n    //Raymarch\n    RaymarchResults results = raymarch(eye, direction);\n    if (results.iterations > -1.0) {\n        //get a range from few iterations -> many iterations\n        float mix_percent = results.iterations / float(MAX_STEPS);\n                \n        //Get mouse position. choose a sensible default point.\n        vec2 mouse_uv;\n        if (iMouse.xy == vec2(0.0))\n            mouse_uv = vec2(-0.25, 0.25);\n        else \n            mouse_uv = (iMouse.xy - CENTER) / iResolution.y;\n        \n        //Move the light based on mouse position\n        vec3 light = vec3(mouse_uv, -0.7);\n            \n        //Shade in the raymarching results. Shadows are omitted \n        vec4 light_color = vec4(0.5, 1.0, 0.0, 1.0);\n        fragColor = shade(results.surface_point, light, light_color);\n        \n    }\n}","name":"Image","description":"","type":"image"}]}