{"ver":"0.1","info":{"id":"tsjSzw","date":"1553290825","viewed":340,"name":"Repetition","username":"gyabo","description":"Repetition of simple primitive and ground.","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define time iTime\n\n\n//https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n \nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n \n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n \n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n \n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n \n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n \n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n  \nvec2 rot(vec2 p, float a) {\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn vec2(\n\t\tc * p.x - s * p.y,\n\t\ts * p.x + c * p.y);\n}\n \n \nfloat map(vec3 p) {\n\tfloat t = length(mod(p.xz, 0.5) - 0.25) - 0.01;\n\tt = min(t, length(mod(p.xy, 0.5) - 0.25) - 0.01);\n\tt = min(t, length(mod(p.yz, 0.5) - 0.25) - 0.01);\n    vec3 tp = p + 0.15;\n    //tp.xy = rot(tp.xy, mod(tp.z * 0.5, 0.5 * 3.141592));\n    t = min(t, length(mod(tp.xz, 0.5) - 0.25) - 0.01);\n\tt = min(t, length(mod(tp.xy, 0.5) - 0.25) - 0.01);\n\tt = min(t, length(mod(tp.yz, 0.5) - 0.25) - 0.01);\n\n\tt = min(t, 5.0 - dot((p), vec3(0, 1, 0)));\n\tt = max(t, -(length(mod(p, 10.0) - 5.0) - 6.5));\n\tt = min(t, length(mod(p + vec3(0, 0, time), 4.0) - 2.0) - 0.25);\n\treturn t;\n}\n \nvec3 getnor(vec3 p) {\n\tfloat a = map(p);\n\tvec2 d = vec2(0.001, 0.0);\n\tvec3 N = vec3(0.0);\n\tN.x = a - map(p + d.xyy);\n\tN.y = a - map(p + d.yxy);\n\tN.z = a - map(p + d.yyx);\n\treturn normalize(N);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = (2.0 * fragCoord.xy - iResolution.xy ) / min(iResolution.x, iResolution.y);\n\tvec3 dir = normalize(vec3(uv, 1.0));\n\tfloat tm = 60.0 + time * 0.1;\n\tdir.xy = rot(dir.xy, tm);\n\tdir.zx = rot(dir.zx, tm);\n\tvec3 pos = vec3(-time * 0.333, 2.0 + sin(tm), time);\n\t//vec3 pos = vec3(0.0, 0.0 + sin(tm) * 5.0, time);\n\tfloat t = 0.0;\n\tfor(int i = 0 ; i < 128; i++) {\n\t\tt += map(t * dir + pos);\n\t}\n\tvec3 IP = t * dir + pos;\n\tfloat M = 64.0;\n\tvec3 grain = vec3(0.5) * vec3(\n\t\tnoise(IP.xyz * M) * 0.5,\n\t\tnoise(IP.zxy * M) * 0.5,\n\t\tnoise(IP.yzx * M) * 0.5);\n\t\t\n\tvec3 N = normalize(getnor(IP) + grain);\n\tvec3 V = normalize(IP + grain);\n\tvec3 H = normalize(N + V);\n\tvec3 L = normalize(vec3(1, -2, 3));\n\tfloat D = max(0.0, dot(N, L));\n\tfloat S = max(0.0, pow(dot(H, N), 64.0)) * 4.0;\n\tvec3 C = normalize(vec3(1,2,3));\n\tvec3 col = vec3(0.0);\n\tcol += C * D;\n\tcol += C * S;\n\tcol += vec3(t * 0.01) * vec3(3,2,1) + map(IP + 0.1);\n\tfragColor = vec4( (col + dir * 0.3) * 0.5, 1.0);\n \n}\n","name":"Image","description":"","type":"image"}]}