{"ver":"0.1","info":{"id":"3l2SRh","date":"1565025549","viewed":154,"name":"Transmissions","username":"Nocks_on","description":"This is my first shader program as an art.\nI really enjoy it!","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592\n#define eps 0.0001\n\nfloat sdBox(vec3 pos, vec3 size) {\n  vec3 d = abs(pos) - size;\n  return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\nfloat sdCircle(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat distFunc(vec3 pos) {\n  float T = 5.0;\n  float interval = 1.0;\n  float cube_size = 0.18;\n  float frame = 0.025;\n  float sphere_size = 0.1;\n  vec3 fold = pos;\n  float ret, d;\n  \n  //frame cube\n  fold = mod(fold, interval) - interval/2.0;\n  d = sdBox(fold, vec3(cube_size-0.01));\n  ret = d;\n  d = sdBox(fold, vec3(cube_size, cube_size-frame, cube_size-frame));\n  ret = max(ret, -d);\n  d = sdBox(fold, vec3(cube_size-frame, cube_size, cube_size-frame));\n  ret = max(ret, -d);\n  d = sdBox(fold, vec3(cube_size-frame, cube_size-frame, cube_size));\n  ret = max(ret, -d);\n  \n  //sphere\n  float t = mod(iTime + floor(pos.y/interval) + 0.5*floor(pos.z/interval), T) - T/2.0;\n  fold = pos;\n  fold.y = mod(fold.y, interval);\n  fold.z = mod(fold.z, interval) - interval/2.0;\n  d = sdCircle(fold - vec3(interval/2.0, interval/2.0, 0.0)  - vec3(sign(t)*pow(t, 3.), 0.0, 0.0), sphere_size);\n  ret = min(ret, d);\n  \n  return ret;\n}\n\nvec3 getNormal(vec3 pos) {\n  return normalize(vec3(\n      distFunc(vec3(pos.x+eps, pos.y, pos.z)) - distFunc(pos),\n      distFunc(vec3(pos.x, pos.y+eps, pos.z)) - distFunc(pos),\n      distFunc(vec3(pos.x, pos.y, pos.z+eps)) - distFunc(pos)\n    ));\n}\n\nmat2 rotateMat(float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvec3 transform(vec3 v) {\n  vec3 ret = v;\n  ret.xz *= rotateMat(PI/2.0);\n  ret.yz *= rotateMat(iTime/5.0);\n  return ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  float d, b;\n  vec3 col = vec3(0.0, 0.0, 0.0);\n  vec3 transformed, normal;\n  \n  vec3 cameraPos = vec3(0.0, 0.0, 1.0);\n  vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n  \n  vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n  vec3 cur = transform(cameraPos) + vec3(0.0, 0.0, iTime/2.0);\n  vec3 ray = normalize(transform(vec3(uv, 0.0) - cameraPos));\n  \n  for (float i = 0.; i < 64.; i+=1.0) {        \n    d = distFunc(cur);\n    if (d < eps) {\n      normal = getNormal(cur);\n      b = pow(1.0 - i/70.0, 2.0);\n      vec3 m = abs(mod(cur, 5.0) - 2.5)/2.0;\n      col = clamp(b, 0., 0.95)*m;\n      break;\n    }\n    cur += d * ray;\n  }\n\n  fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}