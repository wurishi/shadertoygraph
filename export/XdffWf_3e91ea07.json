{"ver":"0.1","info":{"id":"XdffWf","date":"1498424681","viewed":261,"name":"Why spectrum is differrent?","username":"revers","description":"I'm trying to calculate by hand (using DFT) frequency spectrum of played music. I've compared my version with Shadertoy's input spectrum and it looks quite different. Highier frequencies look way to small. What am I doing wrong?","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["spectrum","fourier","dft"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n * I'm trying to calculate by hand (using DFT) spectrum of played music. \n * I've compared my version with Shadertoy's input spectrum and it looks quite different\n * (ignoring lower resolution). Highier frequencies look way to small.  \n * \n * I've tried to window data before calculating DFT, using various windowing functions\n * (like Hamming, Blackman or Tukey) but it didn't help either.\n *\n * What am I doing wrong?\n */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec3 col = vec3(0.95);\n\n\tvec2 px = 1.0 / iResolution.xy; // pixel size\n\n\t{ /* background lines */\n\n\t\tfloat mul = 25.0;\n\t\tfloat grd = fract(uv.x * mul);\n\t\tfloat k = px.x * 0.75 * mul;\n\t\tcol = mix(vec3(0.88), col, smoothstep(k, k * 3.0, abs(grd - 0.5 / mul)));\n\t}\n\n\t{ /* original Shadertoy's frequency spectrum (top blue) */\n\n\t\tfloat freq = texture(iChannel1, vec2(uv.x, 0.15)).r * 0.5;\n\n\t\tcol = mix(vec3(0.18, 0.561, 0.851), col, smoothstep(freq, freq + px.y,\n\t\t\t\tuv.y - 0.5) + (1.0 - step(0.5, uv.y)));\n\t}\n\n\t{ /* Calculated frequency spectrum (bottom green) */\n\n\t\tfloat freq = texture(iChannel1, vec2(uv.x, 0.0)).r * 0.5;\n\n\t\tcol = mix(vec3(0.294, 0.827, 0.353), col, smoothstep(freq, freq + px.y, uv.y));\n\t}\n\t/* middle line */\n\tcol = mix(vec3(0.133, 0.188, 0.188), col, smoothstep(px.y, px.y * 2.0, abs(uv.y - 0.5)));\n\n\tcol = pow(col, vec3(0.4545));\n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","previewfilepath":"/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/**\n *  Frequency bands below this value will be ignored.\n */\nconst float MinDB = -60.0;\n\n/**\n * Blend factor with old spectrum. (0..1) \n * Bigger the value, smoother the animation.\n */\nconst float Mix = 0.8;\n\n/**\n * Determines how much of the spectrum will be visible. (0..1)\n */\n#define SPECTRUM_RANGE 0.15\n\n/*\n * Uncomment to add signal windowing.\n * It doesn't seem to give good results, though.\n * To see anything at all you must decrease MinDB to at least -100.0.\n */\n//#define DO_WINDOWING\n\n#define PI     3.1415926\n#define TWO_PI 6.2831852\n\nfloat log10(float f) \n{\n\treturn log(f) * 0.43429448190325176;\n}\n\nfloat window(float x) \n{\n#if 0\n\t// Blackman window\n\tfloat alpha = 0.;\n\tfloat a0 = 0.5 * (1.0 - alpha);\n\tfloat a1 = 0.5;\n\tfloat a2 = 0.5 * alpha;\n\n\treturn a0 - a1 * cos(2.0 * PI * x) + a2 * cos(4.0 * PI * x);\n#else\n\t// Hamming Window\n\treturn 0.54 - 0.46 * cos(2.0 * PI * x);\n#endif\n}\n\nfloat calcFrequency(float x) \n{\n\tfloat size = iChannelResolution[0].x;\n\tfloat invs = 1.0 / size;\n\n\tvec2 res = vec2(0.0);\n    \n    x *= SPECTRUM_RANGE; // limit spectrum\n    \n\tfloat k = floor(x);\n\n\tif (k > size) {\n\t\treturn 0.0;\n\t}\n    \n\t// DFT\n\tfor (float t = 0.0; t < size; t++) {\n\t\tfloat an = TWO_PI * k * t * invs;\n\t\tvec2  ex =  vec2(cos(an), sin(an));\n\n\t\tfloat inp = texture(iChannel0, vec2((t + 0.5) * invs, 0.75)).r;\n        \n    #ifdef DO_WINDOWING\n\t\tinp *= window(k * invs);\n    #endif\n\t\tres += inp * ex;\n\t}\n\tres *= invs;\n\tfloat pwr = length(res);\n\n    // logarithmic scale\n\tfloat db = 20.0 * log10(pwr);\n\t\n    db = max(db, MinDB); \n\tdb /= MinDB;\n\n\treturn 1.0 - db;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    if (uv.y > 0.2) {\n\t\tdiscard;\n\t}\n    float freq;\n    \n    if (uv.y > 0.1) {\n        // original spectrum from Music iChannel0\n    \tfreq = texture(iChannel0, vec2(uv.x, 0.25)).r;\n    } else {\n        // spectrum calculated from waveform\n        freq = calcFrequency(gl_FragCoord.x);\n        \n        // multiplying by some scale factor doesn't help much:\n        //freq = min(freq * 4.0, 1.0);\n        \n        float oldf = texture(iChannel1, vec2(uv.x, 0.0)).r;\n\n        // blend with old spectrum to remove sudden jumps\n        freq = mix(freq, oldf, Mix);\n    }\n\tfragColor = vec4(vec3(freq), 1.0);\n}\n","name":"Buf A","description":"","type":"buffer"}]}