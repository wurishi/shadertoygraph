{"ver":"0.1","info":{"id":"clsGDs","date":"1673045960","viewed":64,"name":"bezier curve exercise","username":"valalalalala","description":"Interactive demo based on BigWings bezier tutorial incorporating a few other implementations.\n\nYou can drag the end and controls, toggle guide lines with space, toggle implementations with 't' and 'r' and reset points with enter.","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["bezier"],"hasliked":0,"parentid":"DtsGDs","parentname":"new base (vlllll)"},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"       //////////////////////////////////////////////////////////////////////\n      //                                                                 ////\n     //  \"bezier curve exercise\"                                        // //\n    //                                                                 //  //\n   //  Started with BigWing's tutorial and made an interactive        //   //\n  //  version including some other implementations.                  //    //\n //                                                                 //     //\n/////////////////////////////////////////////////////////////////////     //\n//                                                                 //    //\n// Creative Commons Attribution-NonCommercial-ShareAlike           //   //\n// 3.0 Unported License                                            //  ///\n//                                                                 // ////\n// by Val \"valalalalala\" GvM 💃 2023                               //// //\n//                                                                 ///  //\n/////////////////////////////////////////////////////////////////////   //\n     //                                                                 //\n     // controls:                                                       //\n     //                                                                 //\n     // ​ drag the end and control points to change the curve           //\n     // ​ space : toggle guide lines                                    //\n     // ​ enter : reset end and control points                          //\n     // ​ 't'   : toggle tutorial vs ajs15822 / iq distance function    //\n     // ​ 'r'   : toggle \"ravg\" distance function                       //\n     //                                                                 //\n     /////////////////////////////////////////////////////////////////////\n     //                                                                 //\n     // links:                                                          //\n     //                                                                 //\n     // ​ BigWings's Video https://www.youtube.com/watch?v=a4zMX6dDVXI  //\n     // ​ https://www.shadertoy.com/view/ltXSDB Adam Simmons            //\n     // ​ https://www.shadertoy.com/view/MslSDN Sebastien Durand        //\n     // ​ https://www.shadertoy.com/view/XsX3zf Tay Holliday            //\n     // ​ https://www.shadertoy.com/view/3dKSDc iq's X                  //\n     // ​ https://hhoppe.com/ravg.pdf           Nehab & Hoppe (2008)    //\n     //                                                                 //\n     /////////////////////////////////////////////////////////////////////\n     //                                                                 //\n     // notes:                                                          //\n     //                                                                 //\n     // ​ the tutorial version with guide lines uses fewer points to    //\n     //   showcase the technique.                                       //\n     // ​ the distance field for \"ravg\" can be pretty wild.             //\n     // ​ lists with less than 3 items just look kinda weird to me...   //\n     //                                                                 //\n     /////////////////////////////////////////////////////////////////////\n\nvec3 bezierDemo( vec2 uv, vec2 a, vec2 c, vec2 z, bool showGuideLines, bool useTutorial, bool useRavg ) {\n\n    float r = .033;\n    float s = r * .77;\n    float l = r * .077;\n    \n    // use viewer points to show the magic!\n    int steps = showGuideLines ? 6 : 66;\n\n    ////////////////////////////////////\n      \n    vec2 bd = useTutorial\n        ? bezierDistance( uv, a, c, z, steps )\n        : abs( sdBezier( uv, a, c, z ) );\n        \n    if ( useRavg ) {\n        bd = ravgBezier( uv, a, c, z );\n    }\n    \n    ////////////////////////////////////\n    \n    float distanceToCurve = bd.x;\n    float distanceAlongCurve = bd.y;\n    \n    ///////////////////\n    \n    // background shows distance to curve and length along path\n    vec3 color = colorF( distanceToCurve * 6.6 ) * max( distanceAlongCurve, .33) * .33;\n    //color = vec3( distanceAlongCurve, min( distanceToCurve, distanceAlongCurve ), d * 3.3 ) * .33;\n\n    // show the curve\n    color += colorF( distanceAlongCurve ) *  shape( distanceToCurve, l );\n    \n    ////////////////////////////////////\n    // show the end and control points\n    \n    float d1 = circleDistance( uv, a ); // <><\n    float d2 = circleDistance( uv, z ); //     <><\n    float d3 = sdRoundedX( uv - c, 1.77 * r , -.02); // <><\n    float mino = min( d1, min( d2, d3 ) ); // <>< \n    \n    if ( mino < r ) {\n        vec3 colorC = colorF( uv.x + uv.y * 2. );\n        color = mix( INVERT(color), colorC, INVERT(mino) ); // ><>\n    }\n\n    ////////////////////////////////////\n    // show guide lines\n    \n    if ( showGuideLines ) {\n        float t = HALBER( sin( iTime ) );\n        vec2 ca = mix( a, c, t );\n        vec2 cb = mix( c, z, t );\n        vec2 ct = mix( ca, cb, t );\n    \n        color += V101.zzy * circle( uv, ca, r );\n        color += V101.yzz * circle( uv, cb, r );\n        color += V101.zyz * circle( uv, ct, r );\n            \n        color += line( uv, a, c, l );\n        color += line( uv, z, c, l );\n        color += line( uv, ca, cb, l );\n    }\n    \n    ////////////////////////////////////\n    \n    return color;\n}\n\nvec3 demo( vec2 uv, vec2 ms ) {\n    bool showGuideLines = !keyToggle( 32, iChannel0 );\n    bool useTutorial = !keyToggle( 84, iChannel0 );\n    bool useRavg = keyToggle( 82, iChannel0 );\n    \n    vec2 c0 = ball( 0, iChannel1 ).xy;\n    vec2 c1 = ball( 1, iChannel1 ).xy;\n    vec2 c2 = ball( 2, iChannel1 ).xy;\n    \n    return bezierDemo( uv, c0, c1, c2, showGuideLines, useTutorial, useRavg );\n}\n\n////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    INIT_SHADER_INPUTS( fragCoord );\n    fragColor = vec4( demo( SHADER_INPUTS.uv, SHADER_INPUTS.ms ), EINS );\n}\n\n////////////////////////////////////////////////////////////////////////////////////","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"////////////////////////////////////////////////////////////////////////////////////\n\nconst float ZED  = .0;\nconst float EINS = 1.;\nconst float HALB = .5;\nconst float TAU  = 99733. / 15873.;\n\nconst vec3 V101 = vec3( -EINS, ZED, +EINS );\n\n////////////////////////////////////////////////////////////////////////////////////\n\n#define HALBER(v) (v * HALB + HALB)\n#define INVERT(v) (EINS-v)\n\n////////////////////////////////////////////////////////////////////////////////////\n\nvec4 gimme( in ivec2 st, sampler2D  sampler) {\n    return texelFetch( sampler, ivec2( st ), 0 );\n}\n\nvec4 gimme( in vec2 st, sampler2D  sampler) {\n    return gimme( ivec2( st ), sampler );\n}\n\nbool keyDown( int key, sampler2D keyboardChannel ) {\n    return ZED < gimme( ivec2(key,ZED), keyboardChannel ).x;\n}\n\nbool keyToggle( int key, sampler2D keyboardChannel ) {\n    return ZED < gimme( ivec2(key,2), keyboardChannel ).x;\n}\n\n////////////////////////////////////////////////////////////////////////////////////\n\nconst int BALL_COUNT = 3; // just need 3 for this...\n\nbool noBalls( in ivec2 st ) {\n    return 0 != st.y && st.x >= BALL_COUNT;\n}\n\nvec4 ball( in int i, sampler2D sampler ) { \n     return gimme( ivec2( i, 0), sampler );\n}\n\n////////////////////////////////////////////////////////////////////////////////////\n// make this magic a bit easier to deal with\n\nconst int MOUSE_UP = -1;\nconst int MOUSE_DOWN = 1;\nconst int MOUSE_CLICKED = 2;\n\nstruct ShaderInputs { vec3 iResolution;float iTime;float iTimeDelta;float iFrameRate;int iFrame;float iChannelTime[4];vec3 iChannelResolution[4];vec4 iMouse;vec4 iDate;float iSampleRate;vec2 fragCoord;vec2 uv;vec2 ms;vec2 trigTime;int mouseStatus;};\nShaderInputs SHADER_INPUTS;\n\n#define INIT_SHADER_INPUTS(fragCoord) \\\n{\\\n    vec2 uv = pixelToUv( fragCoord, iResolution.xy ); \\\n    vec2 trigTime = trig( iTime ); \\\n    int mouseStatus = MOUSE_UP + int( 2. * step( ZED, iMouse.z ) + step( ZED, iMouse.w ) ); \\\n    vec2 ms = (MOUSE_UP == mouseStatus) ? trigTime : pixelToUv( iMouse.xy, iResolution.xy ); \\\n    SHADER_INPUTS = ShaderInputs( iResolution, iTime, iTimeDelta, iFrameRate, iFrame, iChannelTime, iChannelResolution, iMouse, iDate, iSampleRate, fragCoord, uv, ms, trigTime, mouseStatus ); \\\n}\n\n////////////////////////////////////////////////////////////////////////////////////\n\nvec2 trig( float angle ) {\n    return vec2( cos(angle), sin(angle) );\n}\n\nvec2 pixelToUv( vec2 st, vec2 resolution ) {\n    return ( st * 2. - resolution.xy ) / resolution.y;\n}\n\nvec2 pixelToUv( vec2 st ) {\n    return pixelToUv( st, SHADER_INPUTS.iResolution.xy );\n}\n\n////////////////////////////////////////////////////////////////////////////////////\n\nvec3 colorF( float f ) {\n    return vec3( f, HALBER( trig( 6.6 * f ) ) );\n}\n\n////////////////////////////////////////////////////////////////////////////////////\n\nfloat shape( float d, float radius ) {\n    return smoothstep( fwidth( d ), ZED, d - radius );\n}\n\nfloat circleDistance( vec2 p, vec2 center ) {\n    return distance( p, center );\n}\n\nfloat circle( vec2 p, vec2 center, float radius ) {\n    return shape( circleDistance( p, center ), radius );\n}\n\nvec2 lineDistance2( vec2 p, vec2 a, vec2 b ) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec2( length( pa - ba*h ), h );\n}\n\nfloat lineDistance( vec2 p, vec2 a, vec2 b ) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat line( vec2 p, vec2 a, vec2 b, float thickness ) {\n    return shape( lineDistance( p, a, b ), thickness );\n}\n\n////////////////////////////////////////////////////////////////////////////////////\n// https://www.youtube.com/watch?v=a4zMX6dDVXI&ab_channel=TheArtofCode\n\nvec2 bezierPoint( in vec2 c1, in vec2 cc, in vec2 c2, float t ) {\n    vec2 ca = mix( c1, cc, t );\n    vec2 cb = mix( cc, c2, t );\n    return mix( ca, cb, t );\n}\n\nvec2 bezierDistance( in vec2 p, in vec2 c1, in vec2 cc, in vec2 c2, in int steps ) {\n    float d = 3e3;\n    float t = ZED;\n    vec2 last = c1;\n    \n    for ( int i = 1 ; i <= steps ; i++ ) {\n        float f = float( i ) / float( steps );\n        vec2 current = bezierPoint( c1, cc, c2, f );\n        float dt = lineDistance( p, current, last );\n        \n        //d = min( d, dt );\n        if ( dt < d ) {\n            d = dt;\n            t = f;\n        }\n        \n        last = current;\n    }\n    \n    return vec2( d, t );\n}\n\n////////////////////////////////////////////////////////////////////////////////////\n// https://research.microsoft.com/en-us/um/people/hoppe/ravg.pdf\n// via https://www.shadertoy.com/view/ldj3Wh, MslSDN and XsX3zf\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; } // aka 2d cross product\n// Find vector 𝑣𝑖 given pixel 𝑝=(0,0) and Bézier points 𝑏0,𝑏1,𝑏2.\nvec4 get_distance_vector(vec2 b0, vec2 b1, vec2 b2) {\n    float a=det(b0,b2), b=2.*det(b1,b0), d=2.*det(b2,b1); // 𝛼,𝛽,𝛿(𝑝)\n    float f=b*d-a*a; // 𝑓(𝑝)\n    vec2 d21=b2-b1, d10=b1-b0, d20=b2-b0;\n    vec2 gf=2.*(b*d21+d*d10+a*d20);\n    gf=vec2(gf.y,-gf.x); // ∇𝑓(𝑝)\n    vec2 pp=-f*gf/dot(gf,gf); // 𝑝 ′\n    vec2 d0p=b0-pp; // 𝑝′ to origin\n    float ap=det(d0p,d20), bp=2.*det(d10,d0p); // 𝛼,𝛽(𝑝 ′)\n    // (note that 2*ap+bp+dp=2*a+b+d=4*area(b0,b1,b2))\n    float t=clamp((ap+bp)/(2.*a+b+d), .0,1.); // 𝑡̅\n    vec2 og = mix(mix(b0,b1,t),mix(b1,b2,t),t); // 𝑣𝑖 = 𝑏(𝑡̅ ) \n    return vec4(length(og),t,og);\n}\n\nfloat area( vec2 a, vec2 b, vec2 c ) {\n    return a.x * (b.y - c.y) + b.x * (c.y - a.y) + c.x * (a.y - b.y);\n}\n\nvec2 ravgBezier(vec2 p, vec2 b0, vec2 b1, vec2 b2) {\n    return \n        ( abs( det( b1-b0, b2-b0 ) ) < .029)\n        ? lineDistance2( p, b0, b2 )\n        : get_distance_vector( b0-p, b1-p, b2-p ).xy;\n}\n\n////////////////////////////////////////////////////////////////////////////////////\n// https://www.shadertoy.com/view/ltXSDB\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat testCross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat signBezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{ \n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0, \n        step(testCross(A, B, p) * testCross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * testCross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 solveCubic(float a, float b, float c)\n{\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) { \n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a bezier curve\nvec2 sdBezier(vec2 p, vec2 A, vec2 B, vec2 C )\n{    \n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);      \n    vec3 t = clamp(solveCubic(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return vec2( dis * signBezier(A, B, C, p), t );\n}\n\n////////////////////////////////////////////////////////////////////////////////////\n\n// iq: https://www.shadertoy.com/view/3dKSDc\nfloat sdRoundedX( in vec2 p, in float w, in float r ) {\n    p = abs(p);\n    return length(p-min(p.x+p.y,w)*0.5) - r;\n}\n\n////////////////////////////////////////////////////////////////////////////////////","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// simple interactive balls\n// buffer reset key is ENTER\n\nbool isDragging( vec4 ball ) {\n    return ball.w > HALB;\n}\n\nbool alreadyDragging( sampler2D sampler ) {\n    for ( int i = 0 ; i < BALL_COUNT ; i++ ) {\n        vec4 ball = ball( i, sampler );\n        if ( isDragging( ball ) ) return true;\n    }\n    return false;\n}\n\nfloat ballToFloat( int n ) {\n    return float( n ) / float( BALL_COUNT ); \n}\n\nbool reset() {\n    return keyDown( 13, iChannel1 ) || iFrame < 33;\n}\n\nvec4 init( in ivec2 st ) {\n    if ( noBalls( st ) ) return V101.yyyy;\n    float x = 1.5 * sign( float( st.x % 2 ) - .5 );\n    float y = 0.8 * sign( float( st.x / 2 ) - .5 );\n    return vec4( x, y, .066, ZED );\n}\n\nvec4 interact( in ivec2 st, inout vec4 ball ) {\n    if ( noBalls( st ) )  return ball;\n\n    vec4 mouse = SHADER_INPUTS.iMouse;\n    vec2 ms = SHADER_INPUTS.ms;\n    int status = SHADER_INPUTS.mouseStatus;  \n    \n    if ( status == MOUSE_UP ) {\n        ball.w = ZED;\n        return ball;\n    }   \n\n    if ( isDragging( ball ) ) {\n        ball.xy = ms.xy;\n        return ball;\n    }\n\n    float d = distance( ms.xy, ball.xy );\n    if ( d > ball.z ) return ball;\n    \n    if ( alreadyDragging(iChannel0) ) { \n        return ball; \n    }\n \n    ball.xy = ms.xy;\n    ball.w = EINS;\n         \n    return ball;\n}\n\nvoid mainImage( out vec4 val, in vec2 st ) {\n    INIT_SHADER_INPUTS( st );\n\n    ivec2 ij = ivec2( st );\n    val = reset() ? init( ij ) : gimme( ij, iChannel0 );   \n    val = interact( ij, val );\n}","name":"Buffer A","description":"","type":"buffer"}]}