{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"float mandelbox(vec3 w) {\n    float scale = 2.0;\n    float c = 2.0;\n    float r = 0.5;\n\n    for (int i = 0; i < 20; i++) {\n        if (w.x > 1.0) {\n            w.x = 2.0 - w.x;\n        } else if (w.x < -1.0) {\n            w.x = -2.0 - w.x;\n        }\n        if (w.y > 1.0) {\n            w.y = 2.0 - w.y;\n        } else if (w.y < -1.0) {\n            w.y = -2.0 - w.y;\n        }\n        if (w.z > 1.0) {\n            w.z = 2.0 - w.z;\n        } else if (w.z < -1.0) {\n            w.z = -2.0 - w.z;\n        }\n        float lw = length(w);\n        \n        if (lw > 1000.0) {\n            return float(i)/2.0;\n        }\n\n        if (lw < r) {\n            w = w / (r*r);;\n        } else if (lw < 1.0) {\n            w = w / (lw*lw);\n        }\n        w = scale * w + c;\n    }\n    return 0.0;\n}\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);  \n}\n\nvec3 shadeBg(vec3 nml, vec2 fragCoord)\n{\n\tvec2 aspect = vec2(iResolution.x/iResolution.y, 1.0);\n\tvec2 uv = (2.0 * fragCoord.xy / iResolution.xy - 1.0) * aspect;\n\tvec3 bgLight = normalize(vec3(\n\t\tcos(iTime*0.2/0.954929658551372)*4.0, \n\t\t-sin(iTime/1.1936620731892151)*3.0 + 4.0, \n\t\tsin(iTime*0.2/0.954929658551372)*8.0\n\t));\n\tvec3 sun = vec3(2.0, 2.5, 2.0)*0.5;\n\tfloat bgDiff = dot(nml, vec3(0.0, -1.0, 0.0));\n\tfloat sunPow = dot(nml, bgLight);\n\tfloat sp = max(sunPow, 0.0);\n\tvec3 bgCol = max(0.0, bgDiff)*2.0*vec3(0.5,0.4,0.35);\n\tbgCol += max(0.0, -bgDiff)*vec3(0.5, 0.55, 0.6);\n\tbgCol += vec3(0.65, 0.55, 0.5)*((1.5*pow(1.0-abs(bgDiff), 7.0)));\n\tbgCol += sun*(0.5*pow( sp, 3.0)+pow( sp, 256.0));\n\tbgCol += vec3(0.5, 0.2, 0.15)*(pow( sp, 8.0) + pow( sp, abs(bgLight.y)*128.0));\n    //bgCol += vec3(1.9,0.,0.9) * ((1.0-pow(abs(bgDiff), 0.6)) * 0.5);\n\treturn pow(max(vec3(0.0), bgCol), vec3(1.9));\n}\n\nfloat mandelbox_dist(vec3 pos) {\n    vec4 p = vec4(pos, 1.0), p0 = p;\n    float minRad2 = 0.25;\n    vec4 scale = vec4(2.0) / minRad2;\n    float absScalem1 = abs(2.0 - 1.0);\n    float AbsScaleRaisedTo1mIters = pow(abs(2.0), (1.0 - 10.0));\n    for (int i=0; i<10; i++) {\n        p.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;\n        float r2 = dot(p.xyz, p.xyz);\n        p *= clamp(max(minRad2/r2, minRad2), 0.0, 1.0);\n        p = p * scale + p0;\n    }\n    return ((length(p.xyz) - absScalem1) / p.w - AbsScaleRaisedTo1mIters);\n}\n\nfloat scene(vec3 q) {\nmat3 rot = rotationMatrix(normalize(vec3(1.0, -0.5, 0.5)),-iTime*0.5);\nmat3 rot2 = rot*rotationMatrix(normalize(vec3(1.0, 1.5, 0.5)),iTime*4.5);\nvec3 offset = vec3(5.0*sin(iTime*1.7), 5.0*cos(iTime), -5.0+7.0*sin(iTime*1.5));\n    vec3 p = q + offset;\n    float d = length(p)-7.5;\n    if (d > 0.05) {\n        return d;\n    } else {\n    \treturn min(length(p)-5.0, max(-(d+0.5), max(d, mandelbox_dist(rot*p))));\n    }\n}\n\nvec3 normal(vec3 p, float d)\n{\n\tfloat e = 0.005;\n\tfloat dx = scene(vec3(e, 0.0, 0.0) + p) - d;\n\tfloat dy = scene(vec3(0.0, e, 0.0) + p) - d;\n\tfloat dz = scene(vec3(0.0, 0.0, e) + p) - d;\n\treturn normalize(vec3(dx, dy, dz));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = (0.5 - uv) * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n    float time = 406.9;\n    float a = 0.0;//cos(/3.53423*0.5);\n    float ca = cos(a), sa = sin(a);\n    uv *= mat2(ca, sa, -sa, ca);\n    vec3 ro = vec3(uv*5.0,0.0)+vec3(0,0,-15.0);\n    vec3 rd = normalize(vec3(uv, 2.7));\n    ro += rd * 4.0;\n    vec3 transmit = vec3(1.0);\n    float bounce = 0.0;\n\n    for (int i=0; i<100; i++) {\n        float t = scene(ro);\n        if (t < 0.005+float(i)/100.0*0.15) {\n\t        vec3 nml = normal(ro, t);\n            rd = normalize(reflect(rd, nml));\n            ro += rd * 0.01;\n            transmit *= vec3(0.85, 0.76, 0.85)*0.7 - (bounce == 0.0 ? float(i)/100.0 : 0.0);\n            bounce++;\n            //if (bounce > 1.0 || abs(length(ro) - 5.5) > 0.1) {\n                break;\n            //}\n        } else {\n\t        ro += rd * t;\n        }\n        if (t > 29.0) {\n            break;\n        }\n    }\n\tfragColor = pow(vec4(transmit*shadeBg(-rd, fragCoord), 1.0), vec4(1.2));\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4tlGRl","date":"1424301490","viewed":278,"name":"Mandelbox cored","username":"kig","description":"Crawling towards realtime, shadeADay for 2015-02-18","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["shadeaday"],"hasliked":0,"parentid":"","parentname":""}}