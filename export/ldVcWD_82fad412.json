{"ver":"0.1","info":{"id":"ldVcWD","date":"1522105404","viewed":184,"name":"rounded rect v8 (piecewise)","username":"matkatmusic","description":"piecewise v2\nadjust radius(13), gradThickness(12), TYGap, BYGap, LXGap, RXGap and hollow(22) to move the rectangle around within the window. ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["roundedrect"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float distanceFromPointToCircle(vec2 p, vec2 origin, float radius)\n{\n\t//return abs(sqrt( (p.x-origin.x)*(p.x-origin.x) + (p.y-origin.y)*(p.y-origin.y) ) - radius);\n    return abs( length( p - origin ) - radius );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord;\n    \n    vec2 bounds = iResolution.xy;\n    float gradThickness = 2.;\n    float radius = 90.;\n    float TYGap = 150.; //(radius - gradThickness) * 0.5 + gradThickness*2.;\n    float BYGap = 120.;\n    float LXGap = 90.;\n    float RXGap = 280.;\n    \n    vec4 innerColor = vec4(1, 0, 0, 1); //red\n    vec4 outerColor = vec4(1, 1, 1, 0); //teal\n       \n    bool hollow = true;\n    float dist = 1.;\n    fragColor = innerColor;\n    if( hollow )\n    {\n        dist = 0.;\n    }\n    \n    float a;\n   \tfloat b;\n    float c;\n    float d;\n    vec2 circle;\n   \n    bool isCorner = true; \n    bool isLeft = false;\n    bool isRight = false;\n    bool isTop = false;\n    bool isBottom = false;\n    \n    if( p.y < bounds.y-TYGap && p.y > BYGap) //sides\n    {\n        isCorner = false;\n        if( p.x < LXGap ) //left side\n        {\n            isLeft = true;\n            a = LXGap;\n            b = a - (radius - gradThickness)*0.5;\n            c = a - (radius - gradThickness)*0.5 - gradThickness;\n            d = a - radius;\n        }\n        else if( p.x > bounds.x - RXGap ) //right side\n        {\n            isRight = true;\n            a = bounds.x - RXGap;\n            b = a + (radius - gradThickness)*0.5;\n            c = a + (radius - gradThickness)*0.5 + gradThickness;\n            d = a + radius;\n        }\n    }\n    else if( p.x > LXGap && p.x < bounds.x - RXGap ) //top and bottom\n    {\n        isCorner = false;\n        if( p.y > bounds.y - TYGap )\n        {\n            isTop = true;\n            a = bounds.y - TYGap;\n            b = a + (radius - gradThickness)*0.5;\n            c = a + (radius - gradThickness)*0.5 + gradThickness;\n            d = a + radius;\n        }\n        else if( p.y < BYGap ) //bottom\n        {\n            isBottom = true;\n            a = BYGap;\n            b = BYGap - (radius - gradThickness)*0.5;\n            c = BYGap - (radius - gradThickness)*0.5 - gradThickness;\n            d = BYGap - radius;\n        }\n    }\n    else //corners\n    {\n        if( p.x < LXGap && p.y > bounds.y - TYGap ) { circle = vec2(LXGap, bounds.y-TYGap); }\n        else if( p.x < LXGap && p.y < BYGap ) \t\t{ circle = vec2( LXGap, BYGap ); }\n        else if( p.x > RXGap && p.y > bounds.y - TYGap ) {circle = vec2( bounds.x - RXGap, bounds.y - TYGap );}\n        else if( p.x > RXGap && p.y < BYGap )    \t{circle = vec2( bounds.x - RXGap, BYGap );}\n        a = 0.;\n        b = (radius - gradThickness)*0.5;\n        c = (radius - gradThickness)*0.5 + gradThickness;\n        d = radius;\n    }\n    \n    if( isCorner )\n    {\n        if( hollow )\n        {\n           \tif( distanceFromPointToCircle(p, circle, a) < b ) //inner\n        \t{\n        \t    dist = distance(p, circle) / b;   \n        \t}\n        \telse if( distanceFromPointToCircle(p, circle, b) < c-b ) //middle\n        \t{\n        \t    dist = 1.;\n        \t}\n        \telse if( distanceFromPointToCircle(p, circle, c) < d-c ) //outer\n        \t{\n            \tdist = 1. - distanceFromPointToCircle(p, circle, c) / (d-c);\n        \t}  \n        }\n        else\n        {\n            float distToC = distanceFromPointToCircle(p, circle, c);\n            if( distToC < d-c && distanceFromPointToCircle(p, circle, a) > c) //outer\n        \t{\n            \tdist = 1. - distanceFromPointToCircle(p, circle, c) / (d-c);\n        \t}  \n            else if( distToC > d-c && distanceFromPointToCircle(p, circle, a) > d)\n            {\n                dist = 0.;\n            }\n        }\n    }\n    else\n    {\n        if( hollow )\n        {\n         \tif( isLeft )\n        \t{\n            \tif( p.x < a && p.x > b ) //inner side\n        \t\t{\n            \t    dist = distance( vec2(a, p.y), p ) / distance( vec2(a, p.y), vec2(b, p.y));\n           \t\t}\n            \telse if(p.x < b && p.x > c )\n        \t\t{\n            \t\tdist = 1.;\n        \t\t}\n        \t\telse if(p.x < c && p.x > d)\n        \t\t{\n            \t    dist = 1. - distance(vec2(c, p.y), p) / distance(vec2(c, p.y), vec2(d, p.y));\n            \t}\n        \t}\n        \telse if( isRight )\n        \t{\n            \tif( p.x > a && p.x < b )\n            \t{\n            \t    dist = distance(vec2(a, p.y), p) / distance(vec2(a, p.y), vec2(b, p.y) );\n            \t}\n            \telse if( p.x > b && p.x < c)\n            \t{\n            \t   dist = 1.;\n            \t}\n            \telse if( p.x > c && p.x < d )\n            \t{\n            \t    dist = 1. - distance(vec2(c,p.y), p) / distance(vec2(c,p.y), vec2(d,p.y));\n            \t}\n        \t}\n        \telse if( isTop )\n        \t{\n            \tif( p.y > a && p.y < b )\n            \t{\n            \t    dist = distance(vec2(p.x, a),  p) / distance(vec2(p.x, a),  vec2(p.x, b));\n            \t}\n            \telse if( p.y > b && p.y < c )\n            \t{\n            \t    dist = 1.;\n            \t}\n            \telse if( p.y > c && p.y < d )\n            \t{\n            \t    dist = 1. - distance(vec2(p.x, c), p) / distance(vec2(p.x, c), vec2(p.x, d));\n            \t}\n        \t}\n        \telse if( isBottom )\n        \t{\n            \tif( p.y < a && p.y > b )\n            \t{\n            \t    dist = distance(vec2(p.x,a),p) / distance(vec2(p.x,a), vec2(p.x,b));\n            \t}\n            \telse if( p.y > c && p.y < b )\n            \t{\n            \t \tdist = 1.;\n            \t}\n            \telse if( p.y > d && p.y < c )\n            \t{\n            \t    dist = 1. - distance(vec2(p.x, c), p) / distance(vec2(p.x, c), vec2(p.x, d));\n            \t}\n        \t}\t   \n        }\n        else\n        {\n            if( isLeft )\n            {\n                if(p.x < c && p.x > d)\n        \t\t{\n            \t    dist = 1. - distance(vec2(c, p.y), p) / distance(vec2(c, p.y), vec2(d, p.y));\n            \t}\n                else if( p.x < d )\n                {\n                    dist = 0.;\n                }\n            }\n            else if( isRight )\n            {\n               \tif( p.x > c && p.x < d )\n            \t{\n            \t    dist = 1. - distance(vec2(c,p.y), p) / distance(vec2(c,p.y), vec2(d,p.y));\n            \t}\n                else if( p.x > d )\n                {\n                    dist = 0.;\n                }\n            }\n            else if( isTop )\n            {\n                if( p.y > c && p.y < d )\n            \t{\n            \t    dist = 1. - distance(vec2(p.x, c), p) / distance(vec2(p.x, c), vec2(p.x, d));\n            \t}\n                else if( p.y > d )\n                {\n                    dist = 0.;\n                }\n            }\n            else if( isBottom )\n            {\n                if( p.y > d && p.y < c )\n            \t{\n            \t    dist = 1. - distance(vec2(p.x, c), p) / distance(vec2(p.x, c), vec2(p.x, d));\n            \t}\n                else if( p.y < d )\n                {\n                    dist = 0.;\n                }\n            }\n        }\n    }\n    fragColor = mix(outerColor, innerColor, dist );\n    fragColor = sqrt(fragColor);\n}","name":"Image","description":"","type":"image"}]}