{"ver":"0.1","info":{"id":"ltySR1","date":"1482782864","viewed":488,"name":"Basic : Descartes Planets","username":"Gijs","description":"Use your mouse.","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["descartes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 Scale(vec2 p){\n    float MinRes = min(iResolution.y,iResolution.x);\n\treturn (p.xy*2.-iResolution.xy)/MinRes*2.;\n}\n\nvec2 complexMultiply(vec2 a, vec2 b){\n    return vec2(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);\n}\n\nvec2 complexSqrt(vec2 z){\n    float r = sqrt(length(z));\n    float a = atan(z.y,z.x)*.5;\n    return r*vec2(cos(a),sin(a));\n}\n\nmat2 getRotationMatrix(float a){\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    float MinRes = min(iResolution.y,iResolution.x);\n    \n    mat2  r = getRotationMatrix(iTime*.3);\n    \n    float  LineEpsilon =  1./MinRes;\n    \n\tvec2 z = Scale(fragCoord);\n    \n    //midpoint circles\n    vec2 m1 = (iMouse.z>0.)?Scale(iMouse.xy):vec2(.36602540378,0);\n    vec2 m2 = vec2(-.5, .5);\n    vec2 m3 = vec2(-.5,-.5);\n    \n    //distance from i to next\n    float d1 = distance(m1,m2);\n    float d2 = distance(m2,m3);\n    float d3 = distance(m3,m1);\n    \n    //radius circles\n    float r1 = ( d1-d2+d3)*.5;\n    float r2 = ( d1+d2-d3)*.5;//d1-r1\n    float r3 = (-d1+d2+d3)*.5;//d3-r1\n    \n    //curvature circles\n    float k1 = 1./r1;\n    float k2 = 1./r2;\n    float k3 = 1./r3;\n    \n    //curvature descarte circle\n    float k4 = k1+k2+k3-2.*sqrt(k1*k2+k2*k3+k3*k1);\n    \n    //radius descartes circles \n    float r4 = abs(1./k4);\n\n    //descarte circle midpoint, surprisingly difficult...\n    vec2 m4 = (m1*k1 \n             + m2*k2 \n             + m3*k3 \n             + 2.*complexSqrt(\n                 complexMultiply(m1,m2)*k1*k2 \n               + complexMultiply(m2,m3)*k2*k3 \n               + complexMultiply(m1,m3)*k1*k3 \n             ))/k4;\n    \n    \n    //fractal loop, basic scaling\n    //s keeps track of total scaling\n    float its = 0.;\n    float s = 1.;\n    for(int i=0;i<4;i++){\n        \n        if(distance(z,m1)<r1){\n             z = (z-m1)/r1;\n             s =      s/r1;\n            \n        }else if(distance(z,m2)<r2){\n             z = (z-m2)/r2; \n             s =      s/r2;\n            \n        }else if(distance(z,m3)<r3){\n             z = (z-m3)/r3;  \n             s =      s/r3;\n            \n        }else{\n            \n            break;\n            \n        }\n        \n                \n\t\tz *= r;\n           \n        z = m4 + z*r4;\n        s =    + s*r4;\n      \n        its++;\n    }\n\n    //get distance to the four circle edges\n    float dis = 1e20;\n    dis = min(dis,abs(distance(z,m1)-r1));\n    dis = min(dis,abs(distance(z,m2)-r2));\n    dis = min(dis,abs(distance(z,m3)-r3));\n    dis = min(dis,abs(distance(z,m4)-r4));\n    \n    dis /= s;//scale distance back to actual distance\n   \n    float smoothed = smoothstep(1./LineEpsilon,0.,1./dis)/(its*.1+1.);\n    \n\n    fragColor = vec4(smoothed);\n}","name":"Image","description":"","type":"image"}]}