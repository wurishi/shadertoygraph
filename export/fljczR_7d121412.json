{"ver":"0.1","info":{"id":"fljczR","date":"1649087647","viewed":130,"name":"LandscapeGenerateByNoiseTest","username":"akkz","description":"generate landscape by noise.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["noise","landscape"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SNOW_HEIGHT 0.3\n#define ROCK_HEIGHT 0.5\n\n\n// 法线计算\nvec3 normal( in vec3 pos, in int resolutionLevel )\n{\n    float torrX = 10.0 / float(resolutionLevel);\n    float torrZ = 10.0 / float(resolutionLevel);\n    \n    float sampleH1 = terrain(vec2(pos.x + torrX, pos.z), MAX_HEIGHT, resolutionLevel);\n    float sampleH0 = terrain(vec2(pos.x - torrX, pos.z), MAX_HEIGHT, resolutionLevel);\n    float sampleV1 = terrain(vec2(pos.x, pos.z + torrZ), MAX_HEIGHT, resolutionLevel);\n    float sampleV0 = terrain(vec2(pos.x, pos.z - torrZ), MAX_HEIGHT, resolutionLevel);\n    \n    vec3 horizontal = vec3(torrX * 2.0, sampleH1 - sampleH0, 0);\n    vec3 vertical = vec3(0, sampleV1 - sampleV0, torrZ * 2.0);\n    \n    return normalize(cross(vertical, horizontal).xzy);\n}\n\n// 渲染\nvec4 render( in vec3 ro, in vec3 rd, in vec2 uv )\n{\n    vec3 light1 = normalize( vec3(-0.8,0.4,-0.3) );\n\n\tvec3 color;\n    \n    // 计算深度图\n    float deep = texture( iChannel0, uv ).x;\n    if (deep == STEP_START)\n    {\n        color = vec3(0.08,0.05,0.03);\n    }\n    else if( deep < STEP_END)\n    {\n        vec3 nor = normal( ro + deep*rd, TERRAIN_NORMAL_LAYER_AMOUNT );\n        \n        // surface\n        color = vec3(0.08,0.05,0.03);\n        \n        // rock\n        if (nor.z < ROCK_HEIGHT)\n        {\n            color = mix( vec3(0.03,0.03,0.02), color, nor.z / ROCK_HEIGHT);\n        }\n        \n        // snow\n        if (nor.z > SNOW_HEIGHT)\n        {\n            color = mix( vec3(0.31,0.3,0.35), color, (1.0 - nor.z) / (1.0 - SNOW_HEIGHT));\n        }\n        \n        nor = normal( ro + deep*rd, TERRAIN_LAYER_AMOUNT );\n\t\t\n        // lighting\t\n        float amb = clamp(0.5+0.5*nor.z,0.0,1.0) * 4.0;\n\t\tfloat dif = clamp( dot(light1, nor), 0.0, 1.0 ) * 10.0;\n\t\t\n\t\tcolor *= (amb  + dif);\n        \n        // fog\n        float fogRatio = deep / STEP_END;\n        fogRatio = fogRatio * fogRatio * fogRatio * 3.0 - fogRatio * fogRatio * 2.0; // 写错的平滑公式，但是效果感觉不错\n        color = mix(color, vec3(0.5,0.5,0.5) - rd.y*0.5, fogRatio);\n        \n        /*\n        float fogRatio = 1.0 - clamp((STEP_END - deep) / 100000.0, 0.0, 1.0);\n        fogRatio = fogRatio * fogRatio * 3.0 - fogRatio * fogRatio * fogRatio * 2.0;\n        color = mix(color, vec3(0.5,0.5,0.5) - rd.y*0.5, fogRatio);\n        */\n        \n        // color = nor;\n        // color = vec3(nor.x, nor.x, nor.x);\n\t}\n\telse\n\t{\n        // sky\t\t\n        color = vec3(0.5,0.5,0.5) - rd.y*0.5;\n\t}\n    \n    \n    return vec4(color, 1.0);\n\t// return vec4(  deep / STEP_END);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // 映射到 0~1的区间\n    vec2 uv = fragCoord /iResolution.xy;\n    \n    // 绘制预览噪声\n    if (uv.x < 0.25)\n    {\n        fragColor = vec4(noise(fragCoord.xy));\n        return;\n    }\n    \n    float fov = 1.72;\n\n    // 设置相机位置\n    vec3 ro;\n    vec3 rd;\n    \n    getCameraPosition(ro, rd, SIZE, CAMERA_HEIGHT, fragCoord, iResolution.xy, iMouse.xy);\n   \n    vec4 res = render( ro, rd, uv );\n    \n\n    fragColor = vec4( res.xyz, 0.0 );\n    \n    // DeepMap 预览\n    // fragColor = vec4(texture( iChannel0, uv ).x) / STEP_END;\n    // 山脉高度预览\n    // fragColor = vec4(texture( iChannel0, uv ).y) / STEP_END;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\n// 深度测试\nvoid deepmap(out float deep, out float height, in vec3 ro, in vec3 rd, in float maxHeight, in int layerAmount )\n{\n    float dt = STEP_START;\n    float terrainHeight;\n\tfor( int i=0; i<DEEP_TEST_ROUND; i++ )\n\t{\n        // 当前探测的位置\n        vec3 pos = ro + dt*rd;\n        // 探测位置距离地面的高度\n        terrainHeight = terrain( pos.xz, maxHeight, layerAmount );\n\t\tfloat h = pos.y - terrainHeight;\n        // 射线是否已经命中地面\n        if( h < 10.0 || dt > STEP_END ) break;\n        // 下个步长\n        dt += 0.2 * h;\n\t}\n\n\n    deep = dt;\n    if (dt > STEP_END)\n    {\n        height = 0.0;\n    }\n    else\n    {\n        height = terrainHeight;\n    }\n}\n\n// DeepMap\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // 设置相机位置\n    vec3 ro;\n    vec3 rd;\n    getCameraPosition(ro, rd, SIZE, CAMERA_HEIGHT, fragCoord, iResolution.xy, iMouse.xy);\n    \n    float deep;\n    float height;\n    deepmap( deep, height, ro, rd, MAX_HEIGHT, TERRAIN_NORMAL_LAYER_AMOUNT );\n    \n    fragColor = vec4( deep, height, 0.0, 0.0 );\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define TERRAIN_SCALE_RATIO 0.00003\n\n#define TERRAIN_LAYER_AMOUNT 9\n#define TERRAIN_NORMAL_LAYER_AMOUNT 4\n\n// 深度测试参数\n#define STEP_START 1000.0\n#define STEP_END 500000.0\n#define DEEP_TEST_ROUND 1000\n\n\n#define MAX_HEIGHT 131072.0\n#define CAMERA_HEIGHT 100000.0\n\n#define SIZE 484288.0\n\nfloat hash(vec2 p)  // replace this by something better\n{\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\n\n// 噪声采样\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// 高度计算\nfloat terrain( in vec2 pos, in float height, in int resolutionLevel)\n{\n    \n    float f = 0.0;\n\n    pos *= TERRAIN_SCALE_RATIO;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    \n    float heightRatio = 0.5f;\n    \n    \n    for( int i=0; i<resolutionLevel; i++ )\n\t{\n        f += heightRatio*noise( pos ); \n        pos = m*pos;\n        heightRatio *= 0.5f;\n    }\n\n\tf = 0.5 + 0.5*f;\n\t\t\n\t\n\treturn f * height;\n}\n\n// 摄像机控制\nvoid getCameraPosition(out vec3 ro, out vec3 rd, in float size, in float cameraHeight, in vec2 fragCoord, in vec2 resolution, in vec2 position)\n{\n    // 映射到 -1~1的区间\n    vec2 uv = (-resolution.xy + 2.0*fragCoord)/resolution.xy;\n    float fov = 1.72;\n\n    // 设置相机位置\n    float offsetX = size*position.x / resolution.x;\n    float offsetY = cameraHeight * position.y / resolution.y;\n    float rotatorPitch = 1.57 * position.y/resolution.y;\n    ro = vec3( offsetX, cameraHeight + offsetY, 0.0 );\n    rd = normalize(vec3(uv.x, uv.y, fov) - vec3(0.0, rotatorPitch, 0.0));\n}","name":"Common","description":"","type":"common"}]}