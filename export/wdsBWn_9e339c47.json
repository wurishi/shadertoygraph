{"ver":"0.1","info":{"id":"wdsBWn","date":"1625625873","viewed":122,"name":"通过射线推进的方式从灰度图生成法线图","username":"ligaobo","description":"通过射线推进的方式从灰度图生成法线图","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define P(h, v) vec3((h * 2.0 - iResolution.xy) / iResolution.y * 5.0, v)\n\nvec3 calNormal(vec2 fragCoord)\n{    \n    vec3 p0 = P(fragCoord, texelFetch(iChannel0, ivec2(fragCoord), 0).w);\n\t\n    const float u_eps = 1.0;\n    \n\tvec2 t_c[4] = vec2[](\n\t\tfragCoord + vec2(   0.0,  u_eps),\n\t\tfragCoord + vec2(-u_eps,    0.0),\n\t\tfragCoord + vec2(   0.0, -u_eps),\n\t\tfragCoord + vec2( u_eps,    0.0)\n\t\t);\n\t\n\tvec4 h[4] = vec4[](\n\t\t\ttexelFetch(iChannel0, ivec2(t_c[0]), 0),\n\t\t\ttexelFetch(iChannel0, ivec2(t_c[1]), 0),\n\t\t\ttexelFetch(iChannel0, ivec2(t_c[2]), 0),\n\t\t\ttexelFetch(iChannel0, ivec2(t_c[3]), 0));\n    \n\t\n\tvec3 normalv = vec3(0.0);\n\tfor(int i = 0; i < 4; ++i)\n\t{\n\t\tint i_n = i == 3 ? 0 : i + 1;\n\t\t\n\t\tnormalv += normalize(cross(P(t_c[i_n], h[i_n].w) - P(t_c[i], h[i].w),\n\t\t\t\tp0 - P(t_c[i], h[i].w)));\n\t}\n    \n\treturn normalize(normalv);\n}\n\n//-----------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = texture(iChannel0, fragCoord.xy / iResolution.xy).www;\n    \n    vec4 h_n = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n    \n    vec3 ro = vec3(p * 5.0, 10.0);\n    const vec3 rd = vec3(0.0, 0.0, -1.0);\n    \n    \n    vec3 l_d = normalize(vec3(0.0, 1.0, 1.0));\n    \n#if 1\n    col = vec3(dot(l_d, calNormal(fragCoord)));\n#else\n    col = vec3(dot(l_d, h_n.xyz));\n#endif\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nfloat opUnion( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat opSubtraction( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat opIntersection( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = max(k-abs(d1-d2),0.0);\n    return min(d1, d2) - h*h*0.25/k;\n\t//float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n\t//return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k )\n{\n    float h = max(k-abs(-d1-d2),0.0);\n    return max(-d1, d2) + h*h*0.25/k;\n\t//float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n\t//return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat opSmoothIntersection( float d1, float d2, float k )\n{\n    float h = max(k-abs(d1-d2),0.0);\n    return max(d1, d2) + h*h*0.25/k;\n\t//float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n\t//return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\n//-------------------------------------------------\n\nfloat sdSphere(vec3 p)\n{\n    float t = mod(iTime, 50.0);\n    if(t > 25.0)\n        t = 50.0 - t;\n    float r0 = t * 0.15 + 0.25;\n    vec3 c = vec3(cos(t), sin(t), 0.0) * r0;\n\n    return length(p - c) - 0.7;\n    return length(p - c) - (0.3 + 0.2 * sin(t));\n}\n\nfloat sdPlane(vec3 p)\n{\n    return p.z;\n}\n\nfloat map(vec3 p, float refh)\n{\n    //return p.z - refh;\n    //return min(p.z, sdSphere(p));\n    //return min(p.z - refh, sdSphere(p));\n    return opSmoothUnion(p.z - refh, sdSphere(p), 0.25);\n}\n\nvec3 calcNormal( in vec3 pos, float refh )\n{\n    const float ep = 0.0001;\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n\n#if 1\n    vec3 p[4] = vec3[]( pos + e.xyy*ep,\n                        pos + e.yyx*ep, \n                        pos + e.yxy*ep,\n                        pos + e.xxx*ep);\n    float h[4];\n    for(int i = 0; i < 4; ++i)\n    {\n        vec2 uv = (p[i].xy / 5.0 * iResolution.y + iResolution.xy) / 2.0 / iResolution.xy;\n        h[i] = texture(iChannel0, uv).w;\n    }\n\n    return normalize( e.xyy*map( p[0], h[0] ) + \n\t\t\t\t\t  e.yyx*map( p[1], h[1] ) + \n\t\t\t\t\t  e.yxy*map( p[2], h[2] ) + \n\t\t\t\t\t  e.xxx*map( p[3], h[3] ) );\n#endif\n\n    return normalize( e.xyy*map( pos + e.xyy*ep, refh ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*ep, refh ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*ep, refh ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*ep, refh ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 h_n = vec4(0.0);\n    if(iFrame % 1500 == 1)\n    {\n        h_n.w = texture(iChannel1, fragCoord.xy / iResolution.xy).x * 0.5;\n    }\n    else\n    {\n        h_n = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n    \n    \t//--------------------------------------------------------\n        vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n        uv *= 5.0;\n\n        vec3 ro = vec3(uv.xy, 3.0);\n        vec3 rd = vec3(0.0, 0.0, -1.0);\n\n        bool isTrue = false;\n        float t = 0.0;\n        for(int i = 0; i < 50; ++i)\n        {\n            vec3 p = ro + t * rd;\n            float h = map(p, h_n.w);\n            if(abs(h) < 0.0001)\n            {\n                isTrue = true;\n                break;\n            }\n\n\n            t += h;\n        }\n\n\n        //if(t < 3.0)\n        if(isTrue)\n        {\n            vec3 pos = ro + t * rd;\n            vec3 nor = calcNormal(pos, h_n.w);\n\n            if(pos.z >= h_n.w)\n            {\n                h_n.w = pos.z;\n                h_n.xyz = nor;\n            }\n\n        }\n    }\n    \n\n    fragColor = vec4(h_n);    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Transformations\n\nvec3 rotateZ(vec3 p, float a)\n{\n\tfloat sa = sin(a);\n\tfloat ca = cos(a);\n\treturn vec3(ca*p.x + sa*p.y, -sa*p.x + ca*p.y, p.z);\n}\n\nvec3 rotateY(vec3 p, float a)\n{\n\tfloat sa = sin(a);\n\tfloat ca = cos(a);\n\treturn vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\n}\n\nvec3 rotateX(vec3 p, float a)\n{\n\tfloat sa = sin(a);\n\tfloat ca = cos(a);\n\treturn vec3(p.x, ca*p.y - sa*p.z, sa*p.y + ca*p.z);\n}\n","name":"Common","description":"","type":"common"}]}