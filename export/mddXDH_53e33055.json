{"ver":"0.1","info":{"id":"mddXDH","date":"1679754015","viewed":55,"name":"LGOT","username":"dvquentincarrel","description":"My first shader, done for a uni project.\nThe music influences the cube in the middle.\nMusic is uwuntu by Ex-Lyd. Also works with Pink Sand by Ex-Lyd (https://soundcloud.com/ex-lyd/1-pink-sand). Comment / uncomment lines 182-190 and 141-142 to switch.\n\n","likes":1,"published":1,"flags":64,"usePreview":0,"tags":["3d","soundcloud"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XddGzr","filepath":"https://soundcloud.com/dvquentincarrel/uwuntu/s-46ALx61Y414?si=963be026ad2a4a2e84c9a2e4154559e4&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","previewfilepath":"https://soundcloud.com/dvquentincarrel/uwuntu/s-46ALx61Y414?si=963be026ad2a4a2e84c9a2e4154559e4&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// General params\n#define R iResolution.xy\n#define DIST_MIN 3.5 // minimum distance to objects\n#define DIST_MAX 50.0 // maximum distance to objects. Beware, it's used for color calculations inside the march function\n#define RAY_MARCH_STEPS 150 // Max steps. Designed for 500\n#define RAY_MARCH_PRECI 0.005 // Max preci. Designed for 0.001\n#define PI 3.14159265359 // Self-explanatory\n\n// Floats\n#define WARPDELAY 2.0 // If warp, how \"slow\" it is\n#define TWISTDELAY 2.0 // If twist, how \"slow\" it is\n#define MOVESPEED 2.0 // If moving, speed\n#define SPIRALBOUND 1.7 // When the spiral becomes a circle\n#define SPIRALFORCE 35.0 // How much of a Gerbe-o-tron the spiral can be\n#define PATTERNSIZE 1.0 // Factor for the domain and cubes inside\n#define ZFOCUS +1.0 // Which way to look. Changes direction for MOVE. Should be 1 or -1\n#define CORRIDORSIZE 1.8 // Size of the hole\n#define ROTATION_FACTOR 2.0 // How far the space rotation can go either way\n#define BREATH_FACTOR 0.05 // Self-explanatory\n#define CUBE_DIST 20.0 // How far away is the music cube\n\n// Booleans\n#define FREE_AIM 0 // Move target point with mouse\n#define MOVE 1 // Everything is moving\n#define TWIST 0 // Twists corridor\n#define WARP 1 // Warps corridor\n#define BREATHING 1 // The walls are alive ( ͡° ͜ʖ ͡°) (noise-generated perturbation to corridor size)\n#define KALEIDOSCOPE 0 // Self-explanatory\n#define SPACE_ROTATION 0 // Rotates everything back and forth, not the cam\n#define SPIRAL 0 // Everything goes in a spiral (until it's a circle)\n\nstruct Ray\n{\n    vec3 o; // origin\n    vec3 d; // direction\n};\n\nstruct Surface\n{\n    float t; // surface distance\n    vec3 c; // surface color\n    int type; // 1 for tunnel, 2 for music cube\n};\n\n// True pseudo-random noise\nfloat hash13(vec3 p) // Taken from Romain Vergne\n{\n    return fract(sin(dot(p,vec3(12.9898,78.233,45.5432)))*43758.5453123);\n}\n\n// Populated grid with interpolated values for noise (?)\nfloat vnoise(in vec3 x) // Taken from Romain Vergne\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\n    return mix(\n            mix(mix(hash13(p+vec3(0.,0.,0.)),hash13(p+vec3(1.,0.,0.)),f.x),\n                mix(hash13(p+vec3(0.,1.,0.)),hash13(p+vec3(1.,1.,0.)),f.x),f.y),\n            mix(mix(hash13(p+vec3(0.,0.,1.)),hash13(p+vec3(1.,0.,1.)),f.x),\n                mix(hash13(p+vec3(0.,1.,1.)),hash13(p+vec3(1.,1.,1.)),f.x),f.y),f.z);\n}\n\n// Grid repetitions/stacking (?)\nfloat fnoise(in vec3 p,in float amplitude,in float frequency,in float persistence, in int nboctaves) // Taken from Romain Vergne\n{ \n    float a = amplitude;\n    float f = frequency;\n    float n = 0.0;\n\n    for(int i=1;i<nboctaves;++i) {\n        n = n+a*vnoise(p*f);\n        f = f*2.;\n        a = a*persistence;\n    }\n\n    return n;\n}\n\nfloat audio_freq(in float f) // For given freq [0,1], returns amplitude [0,1]\n{\n    // 0.25 is where the FFTs supposedly are, only the x coord of the texture contains info.\n    return texture(iChannel0, vec2(f, 0.25) ).x; \n}\n\nfloat sdBox( vec3 p, vec3 b ) // Taken from Inigo Quilez\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec2 rotate(in vec2 p, float a) // Taken from Romain Vergne\n{\n    float ca = cos(a);\n    float sa = sin(a);\n    return vec2(ca*p.x-sa*p.y, sa*p.x+ca*p.y);\n}\n\n// Infinite box along one axis, \"corridor\"\nfloat sdCorridor(vec3 point, float size, float elongator)\n{\n    float angle;\n#if WARP == 1\n    angle = sin(point.z/WARPDELAY);\n    point.xy = rotate(point.xy, angle);\n#endif\n#if TWIST == 1\n    angle = point.z/TWISTDELAY;\n    point.xy = rotate(point.xy, angle);\n#endif\n    vec3 corridor = vec3(size, size, DIST_MAX*1.5 + elongator);\n    vec3 q = abs(point) - corridor;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// Domain repetition\nfloat opRep( in vec3 p, in vec3 c, float cubeSize) // Taken from Inigo Quilez\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return sdBox(q, vec3(cubeSize));\n}\n\n// Render at a given point\nSurface scene(in vec3 p) // Inspired by code from Romain Vergne\n{\n    float posMod = iTime/10.0;\n#if SPIRAL\n    // Rotation around center\n    p.y -= min(posMod, SPIRALBOUND)*sin(posMod * SPIRALFORCE);\n    p.x += min(posMod, SPIRALBOUND)*cos(posMod * SPIRALFORCE);\n#endif\n#if SPACE_ROTATION\n    // Cube rotation\n        p.xy = rotate(p.xy, cos(iTime/2.0)*ROTATION_FACTOR);\n#endif\n    vec3 t = p*5.;\n    float v1 = cos(t.x)*cos(t.y)*cos(t.z)/5.;\n    float v2 = (sin(t.x+t.y)+cos(iTime))/5.;\n\n    //float sizeMod = pow(audio_freq(0.02), 5.0)/3.0; // Pow to narrow frequencies\n    float sizeMod = pow(audio_freq(0.01), 5.0)/3.0; // Pow to narrow frequencies\n    float domainSize = 0.3 * PATTERNSIZE;\n    float cubeSize = 0.12 * PATTERNSIZE;\n    float perturbation = 0.0;\n    float corridorSize = CORRIDORSIZE;\n#if BREATHING == 1\n    /* Never quite as good as I had envisioned\n    float breath = 1.5 + cos(iTime/3.0)/2.0;\n    domainSize *= breath;\n    cubeSize *= breath;\n    */\n    // p, amp, freq, pers, oct\n    perturbation = fnoise(p+iTime, 1.5 * p.z / 2.0, 0.1, 1.0, 3) * BREATH_FACTOR;\n#endif\n#if MOVE == 1\n    vec3 shiftedPoint = vec3(p.xy, p.z+iTime*MOVESPEED);\n    /* Was nice until everything started moving. \n       vec3 antiSP = vec3(p.xy, p.z+iTime*MOVESPEED);\n       float d2 = sdCorridor(antiSP, corridorSize, antiSP.z);\n       */\n    float d1 = opRep(shiftedPoint, vec3(domainSize), cubeSize);\n    float d2 = sdCorridor(shiftedPoint, corridorSize, shiftedPoint.z);\n#else\n    float d1 = opRep(p, vec3(domainSize), cubeSize);\n    float d2 = sdCorridor(p, corridorSize, 0.0);\n#endif\n    vec3 octaPoint = p;\n    octaPoint.z -= CUBE_DIST;\n    octaPoint.yz = rotate(octaPoint.yz, sin(iTime));\n    octaPoint.xy = rotate(octaPoint.xy, cos(iTime));\n\n    d2 -= perturbation;\n    float d3 = sdBox(octaPoint, vec3(0.5+sizeMod));\n    //float d3 = sdOctahedron(octaPoint, 0.5+sizeMod);\n\n    vec3 color = vec3(0.5);\n\n    float dist = max(-d2, d1);\n    if(d3 < dist){\n        // Color constructed with certain frequencies\n        /* Pink sand\n        float red = 0.5 + audio_freq(0.0) * 2.0 * fnoise(p*2.0-iTime, 1.0, 0.5, 0.5, 2);\n        float green = 0.5 + pow(audio_freq(0.02), 5.0) * fnoise(p*4.0+iTime*2.0, 1.0, 0.5, 0.5, 5);\n        float blue = 0.5 + pow(audio_freq(0.01), 8.0) * fnoise(p*2.0+iTime*3.0, 2.0, 0.5, 0.5, 3);\n        */\n        // Uwuntu\n        float red = 0.5 + audio_freq(0.0) * 2.0 * fnoise(p*2.0-iTime, 1.0, 0.5, 0.5, 2);\n        float green = 0.5 + pow(audio_freq(0.0075), 15.0) * fnoise(p*4.0+iTime*2.0, 1.0, 0.5, 0.5, 5);\n        float blue = 0.5 + pow(audio_freq(0.145), 5.0)* 2.0 * fnoise(p*2.0+iTime*3.0, 2.0, 0.5, 0.5, 3);\n        color = vec3(red, green, blue);\n        \n        return Surface(d3, color, 2);\n    }\n    dist = min(dist, d3);\n    return Surface(dist, color, 1);\n}\n\n// Raymarching\nSurface march(in Ray r) // Inspired by code from Romain Vergne\n{\n    float t = DIST_MIN;\n\n    for(int i=0;i<RAY_MARCH_STEPS && t<=DIST_MAX;++i) {\n        Surface s = scene(r.o+t*r.d);\n\n        if(s.t<RAY_MARCH_PRECI) {\n            // The less green the further away the object \n            s.c.y /= t / DIST_MAX * 4.0;\n            return Surface(t+s.t,s.c, s.type);\n        }\n\n        t = t+s.t;\n    }\n\n    return Surface(DIST_MAX,vec3(0), 0);\n}\n\n// Gets normal vect at the surface of an object for light itensity calculations\nvec3 normalAt(in Surface s,in Ray r) // Taken from Romain Vergne\n{\n    const float e = 0.01;\n    vec3 p = r.o+s.t*r.d;\n    float nx = scene(vec3(p.x+e,p.y,p.z)).t-scene(vec3(p.x-e,p.y,p.z)).t;\n    float ny = scene(vec3(p.x,p.y+e,p.z)).t-scene(vec3(p.x,p.y-e,p.z)).t;\n    float nz = scene(vec3(p.x,p.y,p.z+e)).t-scene(vec3(p.x,p.y,p.z-e)).t;\n\n    return normalize(vec3(nx,ny,nz));\n}\n\n// Casts ray for a given position (for a single pixel, bends for perspective)\nRay camRay(in vec2 p) // Inspired by code from Romain Vergne\n{\n    // p is the current pixel coord, in [-1,1]\n\n    // normalized mouse position\n    vec2 m = iMouse.xy/R.xy;\n    float mx = iMouse.x/R.x;\n    float my = iMouse.y/R.y;\n\n    // camera position\n    vec3 ro = vec3(0.0);\n\n    // target point\n#if FREE_AIM == 1\n    vec3 ta = vec3(\n            sin(mx*PI),\n            -cos(my*PI)*2.,\n            cos(mx*PI));\n#else\n    vec3 ta = vec3(0.0);\n    ta.z += ZFOCUS;\n#endif\n\n    // camera view vector\n    vec3 cw = normalize(ta-ro);\n\n    // camera up vector\n    vec3 cp = vec3(0.0,1.0,0.0);\n\n    // camera right vector\n    vec3 cu = normalize(cross(cw,cp));\n\n    // camera (normalized) up vector\n    vec3 cv = normalize(cross(cu,cw));\n\n    float fovDeg = 45.;\n    float fovRad = radians(fovDeg);\n    float zf = 1./tan(fovRad/2.);\n\n    // view vector, including perspective (the more you multiply cw, the less fovy)\n    vec3 rd = normalize(p.x*cu + p.y*cv*(R.y/R.x) + 2.*cw);\n\n    return Ray(ro,rd);\n}\n\n// Calculates light intensity / specular spots\nvec3 shade(in Surface surf, in Ray ray) // Inspired by code from Romain Vergne\n{\n\n    // parametres du materiau\n    vec3 kd = surf.c;\n    vec3 ks = vec3(0.8);\n    float s = 10.0;\n\n    vec3 n = normalAt(surf,ray);\n    vec3 l;\n    // If corridor\n    if(surf.type == 1){\n        l = normalize(vec3(1.0));\n        n = 0.3 + n / 3.0; // Desaturates / flattens lighting\n        return kd * max(dot(n,l),0.0);\n    }\n\n    l = normalize(vec3(cos(iTime*3.0), sin(iTime*3.0), -2.0));\n    vec3 v = ray.d;\n    vec3 r = reflect(l,n);\n\n    // coeficients diffus et spéculaires\n    float diff = max(dot(n,l),0.0);\n    float spec = pow(max(dot(r,v),0.),s);\n\n    return kd*diff + ks*spec;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord / R.xy)*2.-1.;\n#if KALEIDOSCOPE\n    if(uv.x < 0.0){\n        uv.x = -uv.x;\n    }\n    if (uv.y < 0.0){\n        uv.y = -uv.y;\n    }\n    uv = mod(uv, 1.);\n#endif\n\n    Ray r = camRay(uv);\n    Surface s = march(r);\n    vec3 c = s.c;\n    c = vec3(0.5, 0.0, 0.5);\n    // Purple gradient background\n    c *= length(vec2(uv.x*(R.x/R.y), uv.y)) ;\n\n    if(s.t<DIST_MAX) {\n        c = shade(s,r);\n    }\n\n    fragColor = vec4(c,1.0);\n}\n","name":"Image","description":"","type":"image"}]}