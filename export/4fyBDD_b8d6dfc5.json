{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"/*\nTo find the distance to a spline B, we optimize for the parameter `t` such that B(t) is the closest point to the query point Q. \n\nThis can be done in two different ways:\n\n1 (left) Treat the problem as a nonlinear least squares objective where we are minimizing the 2D objective B(t) - Q\n    - we solve this using Gauss-Newton iteration\n\n2 (right) Treat this as a root finding problem to find the critical point of the squared error ||B(t) - Q||^2\n    - we solve this using regular Newton iteration, on the DERIVATIVE of the squared error function (which requires second derivatives of B). \n\nBy dragging the mouse up / down, you can also see the effect (left) of damping Gauss-Newton as in the Marquardt Method.\nSome things to consider: Does it make more sense to clamp t to [0, 1] at each iteration, or only at the end?\n*/\n\n\n#define NEWTON_STEPS 25\n#define MAX_DAMPING 2.5\n#define MARGIN 0.2\nfloat DAMPING = 0.2;\n\nconst mat4 c_matrixCubicBez =\n    mat4(\n        1.0, 0.0,  0.0, 0.0,\n        -3.0,  3.0, 0.0,  0.0,\n\t\t3.0,  -6.0,  3.0, 0.0,\n        -1.0,  3.0,  -3.0,  1.0\n\t);\n    \nconst mat3x4 c_MatrixCubicBezDeriv = mat3x4(c_matrixCubicBez[1], c_matrixCubicBez[2] * 2., c_matrixCubicBez[3] * 3.);\nconst mat2x4 c_MatrixCubicBezSecondDeriv = mat2x4(c_matrixCubicBez[2] * 2., c_matrixCubicBez[3] * 6.);\n\nvec2 bezierSecondDerivative(in mat4x2 V, in float t) {\n    vec2 poly = vec2(1., t);\n    return V * c_MatrixCubicBezSecondDeriv * poly;\n}\n\nvec2 bezierDerivative(in mat4x2 V, in float t) {\n    vec3 poly = vec3(1., t, t*t);\n    return V * c_MatrixCubicBezDeriv * poly;\n}\n\nvec2 bezier(in mat4x2 V, in float t) {\n    vec4 poly = vec4(1., t, t*t, t*t*t);\n    return V * c_matrixCubicBez * poly;\n}\n\n\nfloat gaussNewton(in vec2 Q, in mat4x2 V) {\n    float t = 0.5;\n    \n    for (int i=0; i<NEWTON_STEPS; ++i) {\n        vec2 B = bezier(V, t);\n        vec2 Bprime = bezierDerivative(V, t);\n        \n        vec2 diff = B-Q;\n        float denom = dot(Bprime, Bprime);\n        float num = dot(Bprime, diff);\n        t -= num / (denom + DAMPING);\n        t = clamp(t, 0., 1.);\n    }\n    \n    return t;\n}\n\nfloat NewtonRaphson(in vec2 Q, in mat4x2 V) {\n    float t = 0.5;\n    \n    for (int i=0; i<NEWTON_STEPS; ++i) {\n        vec2 B = bezier(V, t);\n        vec2 Bp = bezierDerivative(V, t);\n        vec2 Bpp = bezierSecondDerivative(V, t);\n        vec2 res = B - Q;\n        float loss = dot(res, res);\n        float ddt = dot(res, Bp);\n        float d2dt2 = dot(Bp, Bp) + dot(res, Bpp);\n        t -= ddt / d2dt2;\n        t = clamp(t, 0., 1.);\n    }\n    \n    return t;\n}\n\n\n// d'image\n\n\nfloat timenoise(int seed) {\n    float newtime = iTime;\n    float t = fract(newtime);\n    int t0 = int(floor(newtime));\n    int t1 = int(ceil(newtime));\n    float val0 = pcg2d(uvec2(t0, seed)).x;\n    float val1 = pcg2d(uvec2(t1, seed)).x;\n    float tt = smoothstep(1., 0., t);\n    return tt * val0 + (1.-tt) * val1;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float pressed = iMouse.z > 0. ? 1.0 : 0.0;\n    float marginPix = MARGIN * iResolution.y;\n    if (iMouse.z > 0.) {\n        DAMPING = max((iMouse.y-marginPix) / (iResolution.y-marginPix), 0.) * MAX_DAMPING;\n    }\n\n    /*mat4x2 points = transpose(mat2x4(0.1, 0.6, 1., 1.4,\n                            0.2, 0.8, 0.6, 0.1)); */\n    \n    float horizscale = 2.;\n    float vertscale = 2.;\n    mat4x2 points = mat4x2(timenoise(1) / horizscale, timenoise(2) * vertscale,\n                            (timenoise(3) + 1.) /horizscale, timenoise(4) * vertscale,\n                            (timenoise(5) + 2.) /horizscale, timenoise(6) * vertscale,\n                            (timenoise(7) + 3.) /horizscale, timenoise(8) * vertscale);\n    float zoom = 0.25;\n    vec2 center = vec2(0.8, 0.5);\n    for (int i=0; i<4; ++i) {\n        points[i] -= center;\n        points[i] *= zoom;\n        points[i] += center;\n    }\n    //vec2 uv = (fragCoord / iResolution.y - vec2(.5, 0.2)) * 5.;\n    vec2 uv_base = fragCoord / iResolution.xy;\n    vec2 uv = fragCoord / iResolution.y;\n    \n    // debug\n    /*float t = 0.;\n    float dist = 1000000.;\n    for (float ti = 0.; ti<1.; ti+=0.05) {\n        float disti = length(bezier(points, ti) - uv);\n        if (disti < dist) {\n            t = ti;\n            dist = disti;\n        }\n    }*/\n    \n    float t_gaussnewton = gaussNewton(uv, points);\n    float t_newton = NewtonRaphson(uv, points);\n    float divider = 0.5;\n    if (iMouse.x > 0.) {\n        divider = iMouse.x / iResolution.x;\n    }\n    float t = mix(t_gaussnewton, t_newton, step(divider, uv_base.x));\n    vec2 closest = bezier(points, t);\n    float d = length(closest - uv);\n    \n    float pointdist = 10000000.;\n    for (int i=0; i<4; ++i) {\n        float disti = length(points[i] - uv);\n        if (disti < pointdist) {\n            pointdist = disti;\n        }\n    }\n    //d -= 0.05;\n    float ridgescale = 280.;\n    vec3 col = vec3(1.0) - sign(d)*viridis_quintic(t);\n    col *= (1.0 - exp(-4.0*abs(d))) * (0.8 + 0.2*cos(ridgescale*d));\n    col = mix(col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n    \n    float indicatorWidth = 0.02;\n    col = mix(vec3(0.2, 1., 0.2), col, smoothstep(0.01, 0.015, pointdist));\n    col = mix(col, vec3(1.), step(abs(uv_base.x + indicatorWidth - divider), indicatorWidth) * smoothstep(divider - indicatorWidth, divider, uv_base.x) * DAMPING / MAX_DAMPING);\n    col = mix(vec3(0.), col, step(0.001, abs(uv_base.x - divider)));\n    \n    col = mix(col, vec3(1.), pressed * step(uv_base.x, divider) * 0.2);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"vec3 viridis_quintic( float x )\n{\n\tx = clamp( x, 0.,1. );\n\tvec4 x1 = vec4( 1.0, x, x * x, x * x * x ); // 1 x x2 x3\n\tvec4 x2 = x1 * x1.w * x; // x4 x5 x6 x7\n\treturn vec3(\n\t\tdot( x1.xyzw, vec4( +0.280268003, -0.143510503, +2.225793877, -14.815088879 ) ) + dot( x2.xy, vec2( +25.212752309, -11.772589584 ) ),\n\t\tdot( x1.xyzw, vec4( -0.002117546, +1.617109353, -1.909305070, +2.701152864 ) ) + dot( x2.xy, vec2( -1.685288385, +0.178738871 ) ),\n\t\tdot( x1.xyzw, vec4( +0.300805501, +2.614650302, -12.019139090, +28.933559110 ) ) + dot( x2.xy, vec2( -33.491294770, +13.762053843 ) ) );\n}\n\n\n//https://www.shadertoy.com/view/XlGcRh\nvec2 pcg2d(in uvec2 v)\n{\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    return vec2(v) * (1.0/float(0xffffffffu));\n}","name":"Common","description":"","type":"common"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4fyBDD","date":"1734079486","viewed":111,"name":"Spline w/ GaussNewton vs. Newton","username":"ShnitzelKiller","description":"Comparing Gauss-Newton iteration for nonlinear least squares (left) and Newton-Raphson on the distance gradient to find critical points (right). \nDrag up / down to control damping of Gauss-Newton (left). Colored by parameter of closest point along curve.","likes":3,"published":3,"flags":0,"usePreview":0,"tags":["bezier","spline","distance","optimization","newton","leastsquares"],"hasliked":0,"parentid":"","parentname":""}}