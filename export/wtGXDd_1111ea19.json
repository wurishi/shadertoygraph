{"ver":"0.1","info":{"id":"wtGXDd","date":"1583971446","viewed":445,"name":"KiraKiraâ˜†Particle","username":"latel88","description":"Rotate to mouse click.","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["multipass","culling","particel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 getColor ( const in vec2 uv )\n{\n    return getCheckerPixel( iChannel1, uv, iResolution.xy ).rgb;\n    \n}\n\nfloat calcUV ( const in vec2 uv, const in float m )\n{\t\n\tfloat vig = (0.0 + 1.0 * 16.0 * uv.x * uv.y * (1.0 - uv.x) * (1.0 - uv.y));\n\t\n\treturn max( m, 1. - pow( vig, 0.25 ) );\n\n}\n\nvec3 bloom ( const in vec3 color, const in int count, const in float radius, const in float force, const in vec2 uv )\n{\n\tfloat f = float(count);\n\t\n    vec3 col = vec3(0.);\n\tfloat totalw = 0.;\n\t\n\tfor (int x = 0; x < count; x++)\n\t{\n\t\tvec2 p = uv;\n\t\tfloat fi1 = float(x) / f;\n\t\tfloat dir = fi1 * CIRCLE;\n\n\t\tp += vec2(sin( dir ), cos( dir )) * radius;\n\t\t\n\t\tfor (int x = 0; x < count; x++)\n\t\t{\n\t\t\tvec2 u = p;\n\t\t\tfloat fi2 = mod( (f - float(x)) / f * 2., 1. );\n\t\t\tfloat dir = fi2 * CIRCLE;\n\n\t\t\tu += vec2(cos( dir ), sin( dir )) * (radius * fi2);\n            \n            if (hasInResolution(u, iResolution.xy))\n            {\n                col += getColor( u ) * force;\n                totalw += 1.;\n\n            }\n\t\t\n\t\t}\n\n\t}\n\n\treturn color + (totalw > 0. ? col / totalw : col);\n\n}\n\nvoid mainImage ( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    #ifdef DEBUG_LIGHTLIST\n    \tfragColor = texture(iChannel0, uv);\n    \n    #else\n        vec3 color = getColor( uv );\n\n        #ifdef EFFECT_BLOOM\n    \t    float force = calcUV( uv, 0.0 );\n    \n            color = bloom( color, 5, 0.25 * force, 0.75 + 0.75 * (1. - force), uv );\n    \t\tcolor *= 1. - force;\n    \n        #endif\n\n        fragColor = vec4(color, 1.0);\n    \n    #endif\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Copy to https://wickedengine.net/2018/01/10/optimizing-tile-based-light-culling/\nbool hasAABB ( const in vec3 rdX, const in vec3 rdY, const in vec3 rdZ, const in vec3 ro, const in int index, const in int count, const in float fov, const in vec2 AABB_size, const in vec2 AABB_center )\n{\n    Light light = getLight( index, iTime, count );\n    \n    Project proj = projectSphere( rdX, rdY, rdZ, ro, light.position, light.radius, fov );\n    \n    vec2 so = proj.uv;\n    float sr = proj.radius;\n    vec2 bo = AABB_center;\n    vec2 br = AABB_size;\n    \n\tvec2 vDelta = max( vec2(0.0), abs( bo - so ) - br );\n\n\treturn dot( vDelta, vDelta ) <= sr * sr;\n\n}\n\nvec4 compute ( const in vec3 rdX, const in vec3 rdY, const in vec3 rdZ, const in vec3 ro, const in float fov, const in vec2 uv, const in vec2 coord )\n{\n    vec2 tile = vec2(TileSize);\n    ivec2 tile_resolution = ivec2(listResolution / tile);\n    \n    vec2 fix = iResolution.xy / min( iResolution.x, iResolution.y );\n\n\tivec2 AABB_coord = ivec2(coord) / tile_resolution;\n    vec2 AABB_size = 1.0 / tile * fix;\n\tvec2 AABB_center = vec2(AABB_coord) * AABB_size + AABB_size / 2.0 - fix * 0.5;\n    \n    ivec2 tile_start_coord = AABB_coord * tile_resolution;\n    ivec2 tile_end_coord =  (AABB_coord + 1) * tile_resolution;\n    \n    ivec2 tile_fix_resolution = tile_end_coord - tile_start_coord;\n    ivec2 tile_coord = ivec2(coord) - tile_start_coord;\n    \n  \tint index = tile_coord.y * tile_fix_resolution.x + tile_coord.x;\n    int count = LightCount;\n    int light_index = index * 4;\n    \n    if (light_index < count)\n    {\n        int r = hasAABB( rdX, rdY, rdZ, ro, light_index + 0, count, fov, AABB_size, AABB_center ) ? 1 : 0;\n        int g = hasAABB( rdX, rdY, rdZ, ro, light_index + 1, count, fov, AABB_size, AABB_center ) ? 1 : 0;\n        int b = hasAABB( rdX, rdY, rdZ, ro, light_index + 2, count, fov, AABB_size, AABB_center ) ? 1 : 0;\n        int a = hasAABB( rdX, rdY, rdZ, ro, light_index + 3, count, fov, AABB_size, AABB_center ) ? 1 : 0;\n        \n        return vec4(r, g, b, a);\n        \n    }\n    \n    return vec4(0.0, 0.0, 0.0, 0.0);//none\n\t\n}\n\nvoid mainImage ( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 resolution = listResolution;\n    vec2 coord = fragCoord;\n    \n    if (coord.x >= resolution.x || coord.y >= resolution.y)\n    {\n        fragColor = vec4(0.0);\n        \n        return;\n        \n    }\n\n    vec2 uv = coord.xy / resolution.xy;\n    Camera cam = createCamera( iMouse, iTime );\n    vec3 rdZ = yawPitchToDirection( cam.direction, vec2(0.5), 1.0 );\n    vec3 rdY = yawPitchToDirection( vec2(cam.direction.x, cam.direction.y - HALF), vec2(0.5), 1.0 );\n    vec3 rdX = normalize( cross( rdZ, rdY ) );\n\n    fragColor = compute( rdX, rdY, rdZ, cam.position, cam.fov, uv, coord );\n\t\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//#define DEBUG_CULLING\n//#define DEBUG_LIGHTLIST\n#define EFFECT_BLOOM\n\n#define FOV 0.5\n#define LightMax 5000\n\n#define QUATER 0.7853981633974483\n#define HALF 1.5707963267948966\n#define PI 3.141592653589793\n#define CIRCLE 6.283185307179586\n\n#define TS max( 1.0, sqrt( (iResolution.x * iResolution.y * 4.0) / float(LightMax) ) )\n#define TileSize (TS - mod(TS, 2.0))\n#define listResolution (iResolution.xy - mod( iResolution.xy, vec2(TileSize) ))\n#define LightCount int(min( float(LightMax), floor( (listResolution.x * listResolution.y * 4.0) / float(pow(TileSize, 2.0)) ) ))\n\n#define hasInResolution(pos,rez) all(bvec2(all(greaterThanEqual(ivec2(pos),ivec2(0.0))),bvec2(all(lessThan(ivec2(pos),ivec2(rez))))))\n\nstruct Camera {\n\tvec3 position;\n\tvec2 direction;//pitch yaw\n\tfloat fov;\n\n};\n    \nstruct Light {\n\tvec3 position;\n    float radius;\n    \n};\n\nstruct Project {\n    vec2 uv;\n    float radius;\n    \n};\n\nconst vec2 checkerOffset[4] = vec2[4](\n\tvec2( 0, 0),\n    vec2(-1, 0),\n    vec2( 0, 1),\n    vec2( 0,-1)\n);\n\nfloat hash ( float p )\n{\n    return (fract( sin( p ) * CIRCLE ) - 0.5) / 0.5;\n    \n}\n  \nfloat hashAbs ( float p )\n{\n    return fract( sin( p ) * CIRCLE );\n    \n}\n\nfloat modI ( float a, float b )\n{\n    float m = a - floor( (a + 0.5) / b ) * b;\n    \n    return floor( m + 0.5 );\n    \n}\n\nvec2 compactCheckerUV ( const in vec2 coord, const in vec2 rez )\n{\n    vec2 r = vec2(rez.x / 2.0, rez.y);\n\n    return coord / r - 1.0 / r * vec2(modI( coord.y, 2.0 ) == modI( coord.x, 2.0 ), 0.0);\n    \n}\n\nvec4 getCheckerPixel ( const in sampler2D tex, const in vec2 uv, const in vec2 rez )\n{\n    vec2 coord = floor( uv * vec2(rez.x / 2.0, rez.y) );\n    \n\tif (modI( coord.x, 2.0 ) == modI( coord.y, 2.0 ))\n\t{\n\t\tvec4 outCol = vec4(0.0);\n\n\t\tfor (int i = 0; i < 4; i++)\n\t\t{\n\t\t\tvec4 pix = texelFetch(\n\t\t\t\ttex,\n\t\t\t\tivec2(floor( max( vec2(0.0), coord.xy + checkerOffset[i] ) )),\n\t\t\t\t0\n            );\n\n\t\t\toutCol += pix;\n\t\t\n\t\t}\n\t\t\n\t\treturn outCol / 4.0;\n\t}\n\telse\n\t{\n\t\treturn texelFetch(\n\t\t\ttex,\n\t\t\tivec2(floor( max( 0.0, coord.x ) ), coord.y),\n\t\t\t0\n\t\t);\n\n\t}\n\n}\n\n//Copy to https://www.shadertoy.com/view/MdlGz4\nvec3 yawPitchToDirection ( const in vec2 dir, const in vec2 uv , const in float fov )\n{\n\tfloat xCos = cos( dir.x );\n\tfloat xSin = sin( dir.x );\n\tfloat yCos = cos( dir.y );\n\tfloat ySin = sin( dir.y );\n\t\n\tfloat gggxd = uv.x - 0.5;\n\tfloat ggyd = uv.y - 0.5;\n\tfloat ggzd = fov;\n\t\n\tfloat gggzd = ggzd * yCos + ggyd * ySin;\n\t\n\treturn normalize( vec3(\n\t\tgggzd * xCos - gggxd * xSin,\n\t\tggyd * yCos - ggzd * ySin,\n\t\tgggxd * xCos + gggzd * xSin\n\t\t\n\t) );\n\n}\n\nvec2 getAspect ( const in vec2 resolution )\n{\n    return resolution.xy / min( resolution.x, resolution.y );\n    \n}\n\n//Copy to https://www.shadertoy.com/view/MscSRr\nProject projectSphere ( const in vec3 rdX, const in vec3 rdY, const in vec3 rdZ, const in vec3 ro, const in vec3 so, const in float sr, const in float fov )\n{\n\tvec3 vel = so - ro;\n\n\tfloat cx = dot( vel, rdX );\n\tfloat cy = dot( vel, rdY );\n\tfloat cz = dot( vel, rdZ );\n\n    return Project(\n\t\tvec2(\n            (cx / cz),\n\t\t\t(cy / cz)\n            \n        ) * fov,\n\t\t(sr * distance(vec2(1.0), vec2(0.0)) / cz) * fov\n\t\t\n\t);\n\n}\n\nCamera createCamera ( const in vec4 mouse, const in float time )\n{\n    vec2 dir = mouse.z > 0.0 ? vec2(-mouse.x, mouse.y) / 100.0 + vec2(0.0, -HALF) : vec2(0.0, 0.0);\n    \n    return Camera(\n        vec3(0.0, 0.0, 0.0),\n        dir,\n        FOV\n\n    );\n    \n}\n\nLight getLight ( const in int index, const in float time, const in int count )\n{\n    float tiny_sorting = float(index) / float(count) + time * 0.1;\n    float animationX =  cos( (time + 2.5 * float(index)) * cos( HALF + 0.123 * float(index) ) ) * hashAbs(float(index) * 0.123);\n    float animationY =  sin( (time + 2.5 * float(index)) * (0.25 + 0.75 * sin( HALF + 0.0789 * float(index) ) ));\n    \n    float y = hash( float(index) * 0.4 * float(index) ) + (1.0 * animationX);\n    float r = hashAbs( float(index) * 0.8 * float(index) ) * (0.25 + 0.25 * (1.0 - sin( animationY * 3.75 * CIRCLE )));\n    \n    return Light(\n     \tvec3(\n            sin( tiny_sorting * CIRCLE ) * (1.0 - abs( y )),\n            y,\n            cos( tiny_sorting * CIRCLE ) * (1.0 - abs( y ))\n            \n        ) * vec3(15.0, 10.0, 15.0),\n        0.25 + r\n       \n    );\n    \n}\n\nvec3 getLightColor ( const in int index )\n{\n    return vec3(\n     \thashAbs( float(index) * 0.25 * float(index) ),\n     \thashAbs( float(index) * 0.5 * float(index) ),\n     \thashAbs( float(index) * 0.75 * float(index) )\n        \n    );\n    \n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"float drawLight ( const in vec3 rd, const in vec3 ro, const in vec3 lo, const in float lr )\n{\n    return clamp( 1.0 - (length( cross( rd, lo - ro ) ) / lr), 0.0, 0.75 );\n    \n}\n\nbool draw ( const in vec3 rd, const in vec3 ro, const in int index, inout vec3 col )\n{\n    int light_index = int(index);\n\n    Light light = getLight( light_index, iTime, LightCount );\n    vec3 color = getLightColor( light_index );\n\n    col += drawLight( rd, ro, light.position, light.radius ) * color;\n\t\n    return true;\n}\n\nvec4 rendering ( const in vec3 rd, const in vec3 ro, const in vec2 uv, const in vec2 resolution )\n{\n    vec3 col = vec3(0.0);\n    vec2 tile = vec2(TileSize);\n    \n\tivec2 AABB_coord = ivec2(floor(uv * resolution) / floor(resolution / tile));\n    \n    vec2 tile_resolution = vec2(ivec2(listResolution / tile));\n    \n    ivec2 tile_start_coord = ivec2(vec2(AABB_coord) * tile_resolution);\n    ivec2 tile_end_coord =  ivec2(vec2(AABB_coord + 1) * tile_resolution);\n    \n    ivec2 tile_fix_resolution = tile_end_coord - tile_start_coord;\n    \n    int count = LightCount;\n    \n    for (int index = 0, len = count / 4; index < len; index++)\n    {\n        ivec2 tile_coord = ivec2(\n           modI( float(index), float(tile_fix_resolution.x) ),\n           index / tile_fix_resolution.x\n            \n        );\n        \n        vec4 pixel = texelFetch( iChannel0, tile_start_coord + tile_coord, 0 );\n        \n        int i = index * 4;\n        \n        pixel.r == 1.0 && draw( rd, ro, i + 0, col );\n        pixel.g == 1.0 && draw( rd, ro, i + 1, col );\n        pixel.b == 1.0 && draw( rd, ro, i + 2, col );\n        pixel.a == 1.0 && draw( rd, ro, i + 3, col );\n        \n    }\n    \n    return vec4(col, 1.0);\n    \n}\n\nvoid mainImage ( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 resolution = iResolution.xy;\n    vec2 coord = fragCoord;\n\n    if (coord.x <= resolution.x / 2.0)\n    {\n        vec2 uv = compactCheckerUV( coord, resolution );\n        Camera cam = createCamera( iMouse, iTime );\n        vec3 rd = yawPitchToDirection( cam.direction, (uv - 0.5) * getAspect( resolution.xy ) + 0.5, cam.fov );\n\n        fragColor = rendering( rd, cam.position, uv, resolution );\n        \n    }\n    else\n    {\n        discard;\n        \n    }\n}","name":"Buffer B","description":"","type":"buffer"}]}