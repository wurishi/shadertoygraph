{"ver":"0.1","info":{"id":"4dsfzS","date":"1496740861","viewed":164,"name":"atmospheres","username":"nexor","description":"raymarching","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define resolution iResolution.xy\n#define time iTime\n\n#define touch iMouse.xy\n\n#define pi 3.141569\n#define up vec3(.0,1.,.0)\n#define sin1(x) (sin(x)*.5+.5)\n#define cos1(x) (cos(x)*.5+.5)\n\n#define AA 1\n\nmat2 rot2(float a)\n{\n\tfloat c=cos(a),s=sin(a);\n\treturn mat2(c,-s,s,c);\n}\n\nmat3 rot(float a,float x,float y,float z)\n{\n\tfloat s=sin(a),c=cos(a);\n\treturn mat3(\n\t\tx+c*y+c*z,s*z,s*y,\n\t\t-s*z,y+c*x+c*z,s*x,\n\t\t-s*y,-s*x,z+c*x+c*y);\n}\n\nfloat plane(vec3 p,vec3 n,float d)\n{\n\treturn dot(p,n)+d;\n}\n\nvec2 opU(vec2 a, vec2 b)\n{\n \treturn mix(b,a,step(a.x,b.x));\n}\n\nvec2 map(vec3 p)\n{\n\tvec3 q=p;\n\tvec2 res=vec2(-1.);\n\tfloat t=smoothstep(.0,1.\n\t\t,fract(time))+floor(time);\n\tp.y-=\n\t\t-abs(\n\t\t\tsin(p.x)\n\t\t\t);\n\tres=vec2(100.,.0);\n\tres=opU(res,vec2(plane(p,up,1.),1.));\n\tq.y-=3.;\n\tq.xz*=rot2(pi*.25);\n\tq.xz=mod(q.xz,2.)-1.;\n\tres=opU(res,vec2(length(q)-.5,2.));\n\treturn res;\n}\n\nvec3 norm(vec3 p)\n{\n\tvec2 e=vec2(1.,-1.)*.5773*.00125;\n\treturn normalize(\n\t\te.xyy*map(p+e.xyy).x+\n\t\te.yxy*map(p+e.yxy).x+\n\t\te.yyx*map(p+e.yyx).x+\n\t\te.xxx*map(p+e.xxx).x);\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n\trd=normalize(rd);\n\tfloat res = 1.0;\n\tfor( float t=mint; t < maxt; )\n\t{\n\t\tfloat h = map(ro + rd*t).x;\n\t\tif( h<0.0005 ) return 0.0;\n\t\tres = min( res, k*h/t );\n\t\tt += h*.5;\n\t}\n\treturn res;\n}\n\nvec3 render(vec3 ro, vec3 rd)\n{\n\tvec3 col=vec3(.5);\n\n\tfloat tmin=.0;\n\tfloat tmax=90.;\n\n\tfloat t=tmin;\n\tfloat m=-1.;\n\tfor(float i=0.;i<600.;i++)\n\t{\n\t\tfloat precis=.00125*t;\n\t\tvec2 res=map(ro+t*rd);\n\t\tif(res.x<precis||t>tmax)break;\n\t\tt+=res.x*.15;\n\t\tm=res.y;\n\t}\n\tif(t>tmax)m=-1.;\n\n\t\tvec3 p=ro+t*rd;\n\t\tvec3 nor=norm(p);\n\t\tvec3 lig=normalize(vec3(.5,.1,.5));\n\t\tfloat amb=clamp(.7,.0,1.);\n\t\tfloat dif=clamp(dot(nor,lig),.0,1.);\n\t\tvec3 lin=\n\t\t\t.9*dif*vec3(1.,.4,.0).bgr+\n\t\t\t.2*amb*vec3(.3,1.,.3);\n\t\t\n\t\tcol=mix(col,lin,step(-.5,m));\n\t\tcol*=softshadow(p,1.-lig,tmin,tmax,16.);\n\t\tcol=mix(vec3(.8,.9,1.),col\n\t\t\t,exp(-t*t*.0007));\n\treturn col;\n}\n\nmat3 camera(vec3 ro, vec3 ta, float cr)\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr),cos(cr),.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = normalize(cross(cu,cw));\n\treturn mat3(cu,cv,cw);\n}\n\nvec3 render( vec2 coord )\n{\n\tvec2 uv = coord.xy/resolution.xy;\n\tvec3 col = vec3(.0);\n\tvec2 p=(-resolution+2.*coord.xy)/resolution.y;\n\n\tvec2 k = touch/resolution;\n    k=-1.+2.*k;\n\tvec3 ro =vec3(.0,1.,5.);\n\tro.xz*=rot2(pi*2.*k.x);\n\tvec3 to = vec3(.0,1.+k.y*2.,.0);\n\tmat3 ca = camera(ro,to,.0);\n\tvec3 rd = ca*normalize(vec3(p,3.));\n\tcol=render(ro,rd);\n\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(.0);\n    #if AA\n    for(int x=-AA;x<AA;++x)\n    for(int y=-AA;y<AA;++y)\n    {\n    \tcol+=render(fragCoord+vec2(x,y)/float(AA));\n    }\n    col /= float(4*AA*AA);\n    #else\n    col = render(fragCoord);\n    #endif\n    \n\tfragColor = vec4( col, 1.);\n}","name":"Image","description":"","type":"image"}]}