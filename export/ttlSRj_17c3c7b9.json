{"ver":"0.1","info":{"id":"ttlSRj","date":"1563583675","viewed":167,"name":"FractalSmerityCircles","username":"Smerity","description":"FractalSmerityCircles with strong inspiration from Otavio Good ^_^\n\nClicking down the mouse activates the hyperbola version ;)","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["fractalsmeritycircles"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/lds3z7\nfloat hash( float n )\n{\n\treturn fract(sin(n) * 54671.57391);\n}\n\nfloat noise( vec2 p )\n{\n\treturn 2.0 * hash( iTime * p.x + p.y * 57.1235 ) - 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ratio = iResolution.y / iResolution.x;\n    vec2 uv = fragCoord / iResolution.xy;\n    uv.y *= ratio;\n    vec2 center = vec2(0.5, 0.5 * ratio);\n    uv -= center;\n    \n    // Anti-aliasing samples\n    float samples = 4.0;\n    \n    float finalCol = 0.0;\n    \n    for (int a = 0; a < int(samples); ++a) {\n        vec2 uv = fragCoord / iResolution.xy;\n       \tfloat noiseScale = 0.25;\n        uv.x += noiseScale * noise(float(a) * uv) / iResolution.x;\n        uv.y += noiseScale * noise(float(a) * uv) / iResolution.y;\n        uv.y *= ratio;\n        vec2 center = vec2(0.5, 0.5 * ratio);\n        uv -= center;\n        \n        vec2 coord = uv;\n\n        for (int i = 0; i < 5; ++i) {\n            // Causes the swipe to the bottom / top left\n            float yfuzz = sin(0.005 * iTime) * 0.001;\n            float xfuzz = cos(0.005 * iTime) * 0.4;\n            xfuzz -= 1.0;\n            yfuzz *= 1.0;\n            // Dictates the mirroring of the coordinates once it passes a threshold\n            // Smaller fstop means brighter image\n            float fstop = 0.38;\n            // If you want a hyperbola version centered around origin \n            fstop /= iMouse.z > 0.0 ? 28.0 * (uv.x * uv.y): 1.0;\n            coord = fract(coord * fstop * sin(0.4 * iTime) * xfuzz + 0.5 + yfuzz) * 2.0 - 1.0;\n            // Mirrored\n            float len = (2.0 - sin(0.3 * iTime)) * dot(coord, coord);\n            // Mirrorlen produces a scanline like effect\n            //float mirrorlen = (2.0 - sin(0.75 * iTime) - cos(uv.x * iTime)) * dot(coord, coord);\n            //coord = coord / len + 0.05 * coord / mirrorlen;\n            coord = coord / len;\n        }\n\n        //float circle = length(coord);\n        // Elongate the circle to form odd distorted smooth boxes\n        // See unit circles in various norms:\n        // https://en.wikipedia.org/wiki/Lp_space#/media/File:Vector-p-Norms_qtl1.svg\n        float circle = length(coord * coord * coord);\n\n        // The radius of the circle we're interested in shifts over time\n        float radius = 1.5 + sin(iTime);\n        // Otavio's neat-o trick for signed distance function\n        float scale = dFdx(uv.x);\n\n        float col = float((circle - radius) / scale > 0.0 ? 1.0 : 0.0);\n        finalCol += col;\n    }\n    \n    finalCol /= samples;\n    \n    // Debug mode makes it easy to see the circle start and end\n    //col = texture(iChannel0, coord).xyz;\n    \n    fragColor = vec4(finalCol, finalCol, finalCol, 1.0);\n\n}","name":"Image","description":"","type":"image"}]}