{"ver":"0.1","info":{"id":"4c2GRy","date":"1704367774","viewed":27,"name":"Rounded Hexagon Ripples","username":"obarbs","description":"Based heavily on https://www.shadertoy.com/view/WtySRc by iq.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["ripples","sdf","hexagon","rounded"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Simple shader for hexagonal ripples. Based heavily on https://www.shadertoy.com/view/WtySRc by iq.\n\nvec3 sdgHexagon( in vec2 p, in float r ) \n{\n    // Constants for hexagon geometry\n    const vec3 k = vec3(-0.866025404, 0.5, 0.577350269);\n    \n    // Compute the sign of the input coordinates\n    vec2 s = sign(p);\n    \n    // Take the absolute value of the input coordinates\n    p = abs(p);\n    \n    // Compute the dot product of the input coordinates with a constant vector\n    float w = dot(k.xy, p);    \n    \n    // Modify the input coordinates based on the dot product\n    p -= 2.0 * min(w, 0.0) * k.xy;\n    p -= vec2(clamp(p.x, -k.z * r, k.z * r), r);\n    \n    // Compute the length of the modified coordinates and adjust the sign\n    float d = length(p) * sign(p.y);\n    \n    // Rotate the gradient vector based on the dot product\n    vec2 g = (w < 0.0) ? mat2(-k.y, -k.x, -k.x, k.y) * p : p;\n\n    // Return the signed distance and the gradient vector\n    return vec3(d, s * g / d);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1) corrected for landscape aspect ratio\n\n    vec2 p = fragCoord - iResolution.xy *.5;\n    p /= iResolution.y;\n\n    // size\n\tfloat si = 0.3 + 0.15 * -1.3;\n    // corner radius\n    float ra = 0.684 * (0.5 + 0.5 * 0.36);\n    // sdf(p) and gradient(sdf(p))\n\tvec3 dg = sdgHexagon(p, si);\n    float d = dg.x - ra;\n    \n    // normalise sdf\n    float nrmSDF = (d / -0.03);\n\n    // animate\n    float t = iTime * 10.;\n    nrmSDF += t;\n    \n    // create the ripple effect and multiply by a falloff factor \n    float sine = (sin(nrmSDF) + 1.0) / 1.5 ;\n    float fallOff = smoothstep(d, 1.248, 0.5);\n    vec3 col = vec3(sine * fallOff);\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}