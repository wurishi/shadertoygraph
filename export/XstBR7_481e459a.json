{"ver":"0.1","info":{"id":"XstBR7","date":"1524784026","viewed":373,"name":"Talking Head","username":"Loeizd","description":"head like catmull\n\neverything is home made: I don't know how to raycast or rasterize or even check if lines intersect!\nI found hacky solutions for everything, probably extremely ugly and not optimized. Done in 10h.\n\n980Ti 60fps\n\nFULLSCREEN = IMMERSION!","likes":13,"published":1,"flags":32,"usePreview":0,"tags":["3d","ray","mesh","head"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//higher is longer bleeds on x\n#define bleed .6\n\n//higher to regain a bit of detail\n#define sharpness 10.0\n\n//higher is less bleeding\n#define exp_k 5.\n\n\nfloat bleedcurve (float x)\n{\n    return (sin(x*3.1415) + exp(-exp_k*2.*x))/3.;\n    //could also just retun the exp\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    float iterations = 15.;\n    \n    float one_x = 1./iResolution.x;\n    float img = texture(iChannel0, uv).x * sharpness; //channel\n    float norm = sharpness;    \n    \n    for (float i = 0.; i<iterations; i++)\n    {\n\t\timg += texture(iChannel0, uv + vec2(i*one_x*bleed, 0.)).x //channel\n               * bleedcurve (i/iterations)\n\t\t\t   + texture(iChannel0, uv + vec2(-i*one_x*bleed, 0.)).x //channel\n               * bleedcurve (i/iterations);\n        \n        norm += bleedcurve (i/iterations) * 2. \n                + (texture(iChannel1, uv+sin(iTime*209.1)).x - 1. /*not -.5 because we use pow below*/) * 0.05; //adds grain\n    }\n    \n    img /= norm;\n\timg = pow(img, 1.1);\n    \n    \n    \n    fragColor = vec4(img);\n\t//fragColor = vec4( texture(iChannel0, uv).x );\n\n    //fragColor += vec4( textureGrad(iChannel0, uv, vec2(.005, 0.0), vec2(0.0, 0.0)).x * 0.5 + texture(iChannel0, uv).x );\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","previewfilepath":"/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","type":"music","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec3 mesh[47] = vec3[47](\n    vec3(-1.152940,2.552450,0.177251),\n    vec3(-0.698816,3.444185,0.109775),\n    vec3(-0.839334,3.726782,0.365431),\n    vec3(-0.458062,4.710423,0.500109),\n    vec3(-0.893986,2.394851,0.153747),\n    vec3(-0.532704,3.306298,0.207785),\n    vec3(-0.738027,2.532285,0.361475),\n    vec3(-0.077562,3.231834,1.214475),\n    vec3(-0.386751,3.616470,0.996774),\n    vec3(-0.278559,2.648373,1.064389),\n    vec3(-0.950757,2.038831,0.205998),\n    vec3(-0.903147,1.945160,0.214279),\n    vec3(-0.940692,1.840482,0.186415),\n    vec3(-0.628136,1.899919,0.506625),\n    vec3(-0.441451,1.988568,0.801644),\n    vec3(-0.810483,1.558185,0.169535),\n    vec3(-0.696884,1.235353,0.187433),\n    vec3(-0.071023,4.411631,1.121373),\n    vec3(0.899424,5.193982,0.686098),\n    vec3(1.034624,4.818672,1.255598),\n    vec3(1.011895,3.218396,1.350783),\n    vec3(-0.321450,1.210431,0.358372),\n    vec3(0.221359,1.649179,0.867349),\n    vec3(0.478290,2.130947,1.151507),\n    vec3(0.736438,1.700514,0.827421),\n    vec3(0.352639,1.317390,0.391678),\n    vec3(1.092173,0.522025,0.900177),\n    vec3(0.679813,0.104170,0.423261),\n    vec3(-0.839334,3.726782,-0.000000),\n    vec3(-0.458062,4.756799,-0.000000),\n    vec3(0.899424,5.258102,-0.000000),\n    vec3(0.615332,0.012392,0.000000),\n    vec3(0.286447,1.271030,0.000000),\n    vec3(-0.380493,1.129629,0.000000),\n    vec3(-0.758537,1.211881,0.000000),\n    vec3(-0.810483,1.558185,0.000000),\n    vec3(-0.940692,1.840482,0.000000),\n    vec3(-0.903147,1.945160,0.000000),\n    vec3(-0.944442,2.040097,0.000000),\n    vec3(-0.858333,2.383469,0.000000),\n    vec3(-1.097475,2.413804,0.000000),\n    vec3(-1.233176,2.552450,-0.000000),\n    vec3(-0.767953,3.444185,-0.000000),\n    vec3(1.018715,3.931593,1.347352),\n    vec3(-0.270974,3.250521,0.961848),\n    vec3(-0.556656,3.485581,0.453407),\n    vec3(-0.444951,3.124634,0.481815)\n);\n\nstruct line {\n    int a;\n    int b;\n};\n\nconst line edges[81] = line[81](\n\tline(30, 18),\n\tline(18, 19),\n\tline(19, 43),\n\tline(43, 20),\n\tline(20, 23),\n\tline(23, 22),\n\tline(22, 24),\n\tline(24, 26),\n\tline(26, 27),\n\tline(27, 31),\n\tline(31, 32),\n\tline(32, 33),\n\tline(33, 34),\n\tline(34, 35),\n\tline(35, 36),\n\tline(36, 37),\n\tline(37, 38),\n\tline(38, 39),\n\tline(39, 40),\n\tline(40, 41),\n\tline(41, 42),\n\tline(42, 28),\n\tline(28, 29),\n\tline(29, 30),\n\tline(29, 3),\n\tline(3, 18),\n\tline(3, 17),\n\tline(17, 19),\n\tline(3, 2),\n\tline(28, 2),\n\tline(2, 8),\n\tline(8, 17),\n\tline(8, 43),\n\tline(1, 2),\n\tline(42, 1),\n\tline(8, 7),\n\tline(7, 20),\n\tline(1, 0),\n\tline(41, 0),\n\tline(0, 6),\n\tline(5, 6),\n\tline(6, 9),\n\tline(9, 7),\n\tline(9, 23),\n\tline(1, 5),\n\tline(40, 0),\n\tline(40, 4),\n\tline(39, 4),\n\tline(4, 6),\n\tline(32, 25),\n\tline(25, 27),\n\tline(25, 24),\n\tline(33, 21),\n\tline(21, 25),\n\tline(22, 21),\n\tline(34, 16),\n\tline(16, 21),\n\tline(16, 14),\n\tline(14, 22),\n\tline(14, 9),\n\tline(13, 14),\n\tline(6, 13),\n\tline(4, 10),\n\tline(38, 10),\n\tline(37, 11),\n\tline(36, 12),\n\tline(35, 15),\n\tline(15, 16),\n\tline(12, 15),\n\tline(10, 11),\n\tline(11, 12),\n\tline(12, 13),\n\tline(11, 13),\n\tline(10, 13),\n\tline(5, 45),\n\tline(5, 46),\n\tline(5, 44),\n\tline(45, 44),\n\tline(46, 44),\n\tline(44, 7),\n\tline(15, 13)\n);\n\n#define FOV .05\n\n#define CamLoc vec3(-12.+ .5*abs(cos(iTime+0.5)), 3.+3.*sin(iTime*1.233), 8.*sin(iTime))\n//#define CamLoc vec3(-0. + 12.*cos(iMouse.x/iResolution.x * 10.), 3., 0. + 12.*sin(iMouse.x/iResolution.x * 10.) )\n\nconst vec3 CamHorizontalVec = vec3(0., 0., .5*FOV);\nconst vec3 CamVerticalVec = vec3(0., .45*FOV, 0.);\n\nvec3 RenderPlane(vec2 uv) \n{\n  return CamLoc + (CamHorizontalVec*uv.x*16. + CamVerticalVec*uv.y*10. + /* camFwdVec here: */ normalize(vec3(0., 3., 0.)-CamLoc));\n}\n\n/*\nfloat dotSize = 0.00001;\n\nfloat CheckPn (vec3 p, vec2 uv) {\n      vec2 uvCenter = (uv -.5)*2.;\n\n      vec3 dotVec = normalize(CamLoc - p);\n      vec3 camRay = normalize(CamLoc - Plane(uvCenter));\n      return (dot(dotVec, camRay) > 1.-dotSize)? 0.: 1.;\n}\n*/\n\nfloat drawLine3D (int vert1, int vert2, float inv, vec3 camRay)\n{\n    vec3 i = vec3(1, 1., inv);\n    float line = 0.;\n    \n    float d = 0.007 * distance(mesh[vert1], mesh[vert2]); // modulate by dist\n    float a = 1. + dot ( cross(CamLoc-mesh[vert1]*i, CamLoc-mesh[vert2]*i), camRay );\n    line += floor( d + a ) - floor ( a - d );\n    \n    float circle = floor( 1.- 0.01 * dot( cross(CamLoc-mesh[vert1]*i, camRay), cross(CamLoc-mesh[vert2]*i, camRay) ));\n    line *= circle;\n    \n    return line;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //float highlight = 1.;\n    //float points = 1.;\n    float lines = 0.;\n    \n    vec3 disp = vec3(0., pow(texture(iChannel1, vec2(0.255 /*song sample*/, 0.)).x, 3.) * -0.75 +.1 /*mouth scale*/, 0.);\n    mesh[12] += disp;\n    mesh[15] += disp;\n\tmesh[16] += disp;\n    mesh[21] += disp;\n    \n    mesh[33] += disp;\n    mesh[34] += disp;\n    mesh[36] += disp;\n    mesh[35] += disp;\n    \n    mesh[38] -= disp*.5;\n    mesh[10] -= disp*.5;\n    \n    // Eyes\n    mesh[45] -= clamp(vec3( 0., pow((sin(iTime*2.)*.999+.001), 50.) * 0.3, 0.), 0.001, 1.);\n    \n    // Draw points\n    /*\n    for (int i = 0; i <= mesh.length(); i++)\n    {\n        points *= CheckPn(mesh[i], uv);\n        \n        //point to highlight\n        highlight *= CheckPn(mesh[28], uv);\n        \n        // Mirror verticies\n        points *= CheckPn(mesh[i]*vec3(1, 1., -1.), uv);\n    }\n\t*/\n    \n    vec2 uvCenter = (uv -.5)*2.;\n    vec3 camRay = CamLoc - RenderPlane(uvCenter);\n    \n    // Draw lines\n    for (int i = 0; i < edges.length(); i++)\n    {\n        lines += drawLine3D(edges[i].a, edges[i].b, 1., camRay);\n        // Mirror lines\n        lines += drawLine3D(edges[i].a, edges[i].b, -1., camRay);\n    }\n \n    fragColor = vec4(lines + texture(iChannel0, uv*2.-iTime)*0.05 * abs(uv.x*2. - 1.) +\n                    texture(iChannel1, uv)*.15\n                    );\n \n    //fragColor = vec4((1.-points)*.2 + 1.-highlight + lines*0.2, 0., highlight, 1.);\n}\n","name":"Buf A","description":"","type":"buffer"}]}