{"ver":"0.1","info":{"id":"wdySRc","date":"1574625041","viewed":105,"name":"mandelbrot renderer","username":"sklappal","description":"mandelbrot ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["mandelbrot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define M_PI   3.14159265358979323846264338327950288\n\nfloat ComplexNorm2(vec2 c) {\n  return c.x*c.x + c.y*c.y;\n}\nvec2 ComplexSum(vec2 c1, vec2 c2) {\n  return vec2(c1.x + c2.x, c1.y + c2.y);\n}\nvec2 ComplexSquare(vec2 c) {\n  return vec2(c.x * c.x - c.y * c.y, 2.0 * c.x * c.y);\n}\nfloat DivergenceSpeed(vec2 pos) {\n  vec2 zn = vec2(0.0, 0.0);\n  \n  for(int i = 0; i < 1000; i++)\n  {\n    float cn = ComplexNorm2(zn);\n    \n    if (cn > 4.0) {\n      return (float(i) + 1.0 - (log(log(sqrt(cn))) / log(2.0))) / (1000.0 + 1.0);\n    }\n    zn = ComplexSum(ComplexSquare(zn), pos);\n  }\n  return 0.0;\n}\n\nvec4 grayScale(float ds) {\n return vec4(ds, ds, ds, 1.0);   \n    \n}\n\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\n\nvec4 rainbow(float ds) {\n  \treturn vec4(hsl2rgb(vec3(ds, 1.0, 0.5)), 1.0);\n}\n\nvec4 calcColor(float ds, float zoom) {\n    return mix(grayScale(ds), rainbow(ds), zoom*2.0 - 1.0);\n    \n}\n\n\nfloat myRound (float f) {\n \treturn floor(f + 0.5);   \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n    float aspect = iResolution.x/iResolution.y;\n    vec2 uv = 2.0*fragCoord/iResolution.y - vec2(aspect*1.0, 1.0);\n\n\n    float zoomSpeed = 0.01;\n    float zoomRound = zoomSpeed * iTime;\n    float nearestWhole = myRound(zoomRound);\n    float zoomStep = sin(distance(zoomRound, nearestWhole)*M_PI);\n    float zoom = mix(1.5, 50000.0, pow(zoomStep, 10.0));\n    \n    vec2 cameras[5];\n    cameras[0] = vec2(-0.77682, -0.13576); // good\n    cameras[1] = vec2(0.2599, 0.002); // good\n    cameras[2] = vec2(-0.761560,-0.0847570); // good\n    cameras[3] = vec2(-1.6301, 0.001); // good\n    cameras[4] = vec2(-0.81152, -0.18453); // good\n    \n    \n \t\n    int cameraIndex = int(nearestWhole);\n    vec2 prevCamera = cameras[((cameraIndex-1) % cameras.length())];\n    vec2 curCamera = cameras[((cameraIndex) % cameras.length())];\n\n    \n    float t = 0.0;\n    \n    if (distance(nearestWhole, zoomRound) < 0.1)\n    {\n     \tt = (zoomRound - nearestWhole + 0.1) / 0.2;\n    }\n    \n    if (zoomRound - nearestWhole > 0.1)\n    {\n     \tt = 1.0;   \n    }\n    \n    vec2 camera = mix(prevCamera, curCamera, t);\n\n    vec2 jitter = vec2(cos(40.0*iTime*zoomSpeed), sin(20.0*iTime* zoomSpeed));\n    //vec2 jitter = vec2(0.0);\n\n    vec2 mappedPos = (camera + (1.0/zoom)*(uv + jitter));\n\n    fragColor = calcColor(sqrt(DivergenceSpeed(mappedPos)), zoomStep);\n}","name":"Image","description":"","type":"image"}]}