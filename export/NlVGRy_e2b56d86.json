{"ver":"0.1","info":{"id":"NlVGRy","date":"1637906744","viewed":128,"name":"simple AA","username":"kinonik","description":"a simple example of using SSAA in shaders. easy refactoring for use in your glsl shaders.\n\"if\" does not reduce performance here, because int SSAA is a global constant. also, in functions, only the arguments change.\nI didn't want to use \"define\"","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["antialiasing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// uniform int SSAA; \nconst int SSAA = 16; // setting\n// 1 2 3 4 5 9 16 64 256\n\nvec2 FragCoord;\n\nvec3 render(vec2 LocalPixelPos) { // here your a rendering dunction\n    vec2 uv = (gl_FragCoord.xy + LocalPixelPos) / iResolution.y;\n\tvec3 c = vec3(0.);\n    \n    \n    c = vec3(length(uv - 0.5) < 0.2 ? 0. : float(int(uv.x*2000.) & int(uv.y*2000.)));\n    \n    \n\treturn(clamp(c, 0., 1.)); // out color in RGB\n}\n\nvoid mainImage(out vec4 FragColor, in vec2 st_FragCoord) {\nfloat bxy = float(int(st_FragCoord.x + st_FragCoord.y) & 1);\nfloat nbxy = 1. - bxy;\n\nFragCoord = st_FragCoord;\n\nFragColor = vec4(vec3(0.), 1.);\n\n// NAA\n///=========\nif (SSAA == 1) {\n\tFragColor.rgb = render(vec2(0.0));\n} else\n// SSAA x2\n///=========\nif (SSAA == 2) {\n\tFragColor.rgb = (render(vec2(0.33 * nbxy, 0.)) + render(vec2(0.33 * bxy, 0.33))) / 2.;\n} else\n// SSAA x3\n///=========\nif (SSAA == 3) {\n\tFragColor.rgb = (render(vec2(0.66 * nbxy, 0.)) + render(vec2(0.66 * bxy, 0.66)) + render(vec2(0.33, 0.33))) / 3.;\n} else\n// SSAA x4\n///=========\nif (SSAA == 4) { // rotate grid\n\tFragColor.rgb = (render(vec2(0.33, 0.1)) + render(vec2(0.9, 0.33)) + render(vec2(0.66, 0.9)) + render(vec2(0.1, 0.66))) / 4.;\n} else\n// SSAA x5\n///=========\nif (SSAA == 5) { // centre rotate grid\n\tFragColor.rgb = (render(vec2(0.33, 0.2)) + render(vec2(0.8, 0.33)) + render(vec2(0.66, 0.8)) + render(vec2(0.2, 0.66)) + render(vec2(0.5, 0.5))) / 5.;\n} else\n// SSAA x9\n///=========\nif (SSAA == 9) {  // centre grid 3x3\n\tFragColor.rgb = (\n\trender(vec2(0.17, 0.2)) + render(vec2(0.17, 0.83)) + render(vec2(0.83, 0.17)) + render(vec2(0.83, 0.83)) + \n\trender(vec2(0.5, 0.17)) + render(vec2(0.17, 0.5)) + render(vec2(0.5, 0.83)) + render(vec2(0.83, 0.5)) + \n\trender(vec2(0.5, 0.5)) * 2.) / 10.;\n} else\n// SSAA x16\n///=========\nif (SSAA == 16) { // classic grid 4x4\n\tFragColor.rgb = (\n\trender(vec2(0.00, 0.00)) + render(vec2(0.25, 0.00)) + render(vec2(0.50, 0.00)) + render(vec2(0.75, 0.00)) + \n\trender(vec2(0.00, 0.25)) + render(vec2(0.25, 0.25)) + render(vec2(0.50, 0.25)) + render(vec2(0.75, 0.25)) + \n\trender(vec2(0.00, 0.50)) + render(vec2(0.25, 0.50)) + render(vec2(0.50, 0.50)) + render(vec2(0.75, 0.50)) + \n\trender(vec2(0.00, 0.75)) + render(vec2(0.25, 0.75)) + render(vec2(0.50, 0.75)) + render(vec2(0.75, 0.75))) / 16.;\n}  else\nif (SSAA == 64) { // crazy grid 8x8\nfor (float lx = 0.; lx < 0.99; lx += 0.125)\n\tfor (float ly = 0.; ly < 0.99; ly += 0.125){\n\tFragColor.rgb += render(vec2(lx, ly));\n}\nFragColor /= 64.;\n}\n else\nif (SSAA == 256) { // OMG grid 16x16\nfor (float lx = 0.; lx < 0.999; lx += 0.0625)\n\tfor (float ly = 0.; ly < 0.999; ly += 0.0625){\n\tFragColor.rgb += render(vec2(lx, ly));\n}\nFragColor /= 256.;\n}\n}","name":"Image","description":"","type":"image"}]}