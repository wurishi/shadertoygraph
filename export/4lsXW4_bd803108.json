{"ver":"0.1","info":{"id":"4lsXW4","date":"1436870894","viewed":400,"name":"Secret Wall","username":"vladstorm","description":"Learning pathtracing\nForked from https://www.shadertoy.com/view/MdfGW8\nanimated diffuse ","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["3d","reflection","globalillumination","pathtracing","pathtracer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"//forked from\n//https://www.shadertoy.com/view/MdfGW8\n\n// hm...\n// Unroll is 1.5x faster on osx.\n// Unroll is 1.5x slower on linux.\n// Not unrolling breaks on windows.\n#define UNROLL 1\n\n\n\n#define SAMPLES 16\n#define REFLECTIONS 4\n\n#define PI 3.14159265359\n#define SCENE_RADIUS 100.\n#define INFINITY 31337.\n#define ISEC_EPSILON .01\n#define REFLECT_EPSILON .01\n\n\nfloat t = iTime * .7;\n\nstruct ray_t { vec3 origin, dir; };\n\t\nstruct material_t {\n\tvec3 color, emission;\n\tfloat specular;\n};\n\nstruct plane_t {\n\tvec3 normal;\n\tfloat offset;\n\tmaterial_t material;\n};\n\nstruct sphere_t {\n\tvec3 center;\t\n \tfloat radius2; // square of a radius\n\tmaterial_t material;\n};\n\n// The objects \n#define NUM_PLANES 6\n#define NUM_SPHERES 3    \nplane_t planes[NUM_PLANES];\nsphere_t spheres[NUM_SPHERES];\n\n// Initialize objects\nvoid init_stuff() {\n    \n\n\tplanes[0] = plane_t(vec3( 1.,0.,0.), 1.,material_t(vec3(.91, .0, .275),vec3(0.), .4*sin(t+PI)+.6));\n\tplanes[1] = plane_t(vec3(-1.,0.,0.), 1.,material_t(vec3(.91, .0, .275),vec3(0.), .4*sin(t+PI)+.6)); //vec3(.100, .894, .0)\n\n    planes[4] = plane_t(vec3(0.,0., 1.), 1.,material_t(vec3(1.,1.,1.),vec3(0.), .5*sin(t)+.5));\n    planes[5] = plane_t(vec3(0.,0.,-1.), 1.,material_t(vec3(1.,1.,1.),vec3(0.), .5*sin(t)+.5));\n\n   \tplanes[2] = plane_t(vec3(0., 1.,0.), 1.,material_t(vec3(.47, .38, .702),vec3(0.), .2)); //vec3(.47, .38, .702)\n\tplanes[3] = plane_t(vec3(0.,-1.,0.), 1.,material_t(vec3(1.,1.,1.),vec3(1.), .2));\n \n\n    //ball animation https://www.shadertoy.com/view/4slGzl\n    float time = iTime;\n\tfloat t2 = sin(time*.1)*40.0;\n\ttime += sin(time)*0.9;\n\tfor (int i=0; i<NUM_SPHERES; i++){\n\t\tfloat I = float(i)*(1./float(NUM_SPHERES));\n\t\tfloat t = I*2.0*3.1415927 + time;\n\t\tvec3 A = .5*vec3(sin(t+t2),-.8+sin(t*3.0)*0.4,cos(t+t2));\n\t\tfloat R = (1.3-I)*0.2 - 0.1;\n        float t3 = time * 1.;\n\t\tspheres[i] = sphere_t(A,R,material_t(vec3(1.),vec3(.0), .8+.2*sin(t3 + 2.*PI*(float(i)/float(NUM_SPHERES))) ));\n        \n\t}    \n    \n}\n\n// gotta try another hash\n//float hash(float x) { \treturn fract(sin(x)*265871.1723);} //original hash\nfloat seed = 0.;\nfloat hash(float x) { return fract(sin(seed++)*43758.5453123); }\n\n// Intersect a plane with a ray\n// This is trivial, go get a pen and do it yourself.\nfloat isec_plane(in ray_t ray, in plane_t plane) {\n \tfloat ND = -dot(plane.normal, ray.dir);\n \tif (ND < ISEC_EPSILON) return INFINITY;\n \tfloat t = (dot(plane.normal, ray.origin) + plane.offset) / ND;\n \tif (t < 0.) return INFINITY;\n \treturn t;\n}\n\n// Intersect a sphere with a ray\n// Also trivial, but I didn't consider any funny cases like being inside a sphere\nfloat isec_sphere(in ray_t ray, in sphere_t sphere) {\n\tvec3 v = sphere.center - ray.origin;\n\tfloat b = dot(v, ray.dir);\n\tfloat c = dot(v, v) - sphere.radius2;\n\tfloat det2 = b * b - c;\n\tif (det2 < 0.) return INFINITY;\n\tfloat t = b - sqrt(det2);\n\tif (t < 0.) return INFINITY;\n\treturn t;\n}\n\n// Make a ray using normalized pixel position, eye position and focus point\nray_t lookAtDir(in vec3 uv_dir, in vec3 pos, in vec3 at) {\n\tvec3 f = normalize(at - pos);\n\tvec3 r = cross(f, vec3(0.,1.,0.));\n\tvec3 u = cross(r, f);\n\treturn ray_t(pos, normalize(uv_dir.x * r + uv_dir.y * u + uv_dir.z * f));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tinit_stuff();\n\t\n\t// Calculate normalized and aspect-corrected pixel position \n\tfloat aspect = iResolution.x / iResolution.y;\n\tvec2 uv = (fragCoord.xy / iResolution.xy * 2. - 1.) * vec2(aspect, 1.);\n  \n\t// Calculate main eye ray\n\tray_t oray;\n\tif (iMouse.z > 0.) {\n\t\t// Don't mind me i r pretty controls\n\t\tvec2 click = iMouse.zw / iResolution.xy * 2. - 1.;\n\t\tvec2 pos = iMouse.xy / iResolution.xy * 2. - 1.;\n\t\tvec2 dif = click - pos;\n\t\tvec3 origin = vec3(-.1, .0, -.5)+ vec3(.6, .6 ,-1.5);//.8*vec3(cos(click.x), 0., sin(click.x));\n\t\tvec3 at = origin + vec3(sin(3.*dif.x), pos.y * 2., cos(3.*dif.x));\n\t\toray = lookAtDir(normalize(vec3(uv, 2.)), origin, at);\n\t} else {\n        vec3 origin = vec3(.7, .6, -2.);\n\n        \n\t\toray = lookAtDir(normalize(vec3(uv, 2.)),\n\t\t\t\t\t\t origin, //.9*vec3(cos(t), .8*sin(t*.7), sin(t)),\n\t\t\t\t\t\t vec3(0.,0.,1.)); //origin+dir//(spheres[0].center+spheres[1].center)*.5);\n\t}\n\n\t// Where all the rays will end up accumulated to\n\tvec3 sumcolor = vec3(0.);\n\n\t// A pathetic attempt at seeding some randomness\n\t//float seed = float(t)*.24 + fragCoord.x + fragCoord.y;\n    seed = iTime + iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;\n\n\t// For all pixel samples\n\tfor (int sample = 0; sample < SAMPLES; ++sample) {\n\t\t// This is ridiculous and no fun, but I don't know better :(\n\t\t//seed += float(sample);\n\n\t\t// Start with primary eye ray\n\t\tray_t ray = oray;\n\n\t\t// color coefficient for current bounce segment\n\t\tvec3 kcolor = vec3(1.);\n\n\t\t// For all bounces/reflections\n\t\tfor (int i = 0; i < REFLECTIONS; ++i) {\n\t\t\t// Current and new intersections and materials. Current is set to infinity.\n\t\t\tfloat cp = INFINITY, np;\n\t\t\tvec3 n = vec3(0.);\n\t\t\tmaterial_t cm, nm;\n\n#if !UNROLL // Broken on win32/firefox\n\t\t\t// For all planes\n\t\t\tfor (int j = 0; j < NUM_PLANES; ++j) {\n\t\t\t\t// Find intersecion\n\t\t\t\tni = isec_plane(ray, planes[j]);\n\t\t\t\t// If it is closer than the current one, accept as the new current\n\t\t\t\tif (ni.path < ci.path) { ci = ni; cm = planes[j].material; }\n\t\t\t}\n\n\t\t\t// Same for all spheres\n\t\t\tfor (int j = 0; j < NUM_SPHERES; ++j) {\n\t\t\t\tni = isec_sphere(ray, spheres[j]);\n        \t\tif (ni.path < ci.path) { ci = ni; cm = spheres[j].material; }\n      \t\t}\n#else //if UNROLL\n#define PLANESECT(idx) np=isec_plane(ray,planes[idx]);if(np<cp){cp=np;cm=planes[idx].material;n=planes[idx].normal;}\n\t\t\tPLANESECT(0);\n\t\t\tPLANESECT(1);\n\t\t\tPLANESECT(2);\n\t\t\tPLANESECT(3);\n\t\t\tPLANESECT(4);\n\t\t\tPLANESECT(5);\n#define TR(l) (ray.origin + l * ray.dir)\n\t\t\tvec3 newpos = TR(cp);\n#define SPHERESECT(idx) np=isec_sphere(ray,spheres[idx]);if(np<cp){cp=np;cm=spheres[idx].material;newpos=TR(cp);n=normalize(newpos-spheres[idx].center);}\n\t\t\t//SPHERESECT(0);\n\t\t\t//SPHERESECT(1);\n            for (int j = 0; j < NUM_SPHERES; ++j) {\n                SPHERESECT(j);\n            }\n#endif\n\t\t\t// If the current interseciont doesn't exist, everything is lost\n\t\t\t// commented out in v.02. consequences are:\n\t\t\t// (a) black screen on osx is fixed on non-unrolled stuff\n\t\t\t// (b) speed on osx is improved ~30%\n\t\t\t// Why's that is still a mystery to me.\n\t\t\t// Go home, GLSL, you are drunk!\n\t\t\t//if (cp > SCENE_RADIUS) break;\n\n\t\t\t// collect emission with current coefficient\n\t\t\tsumcolor += kcolor * cm.emission;\n\t\t\t\n\t\t\t// all following bounces will be affected by current material's color\n\t\t\tkcolor *= cm.color;\n\n\t\t\t// Make a random vector\n\t\t  \tvec3 nvec = normalize(vec3(hash(seed+=newpos.x),\n\t\t\t\t\t\t\t \t\t   hash(seed+=newpos.y),\n\t\t\t\t\t\t\t \t\t   hash(seed+=newpos.z))*2. - vec3(1.));\n\t\t\t// Make it point to the same hemisphere as a current intersetion's normal\n\t\t\t// (\\todo DOES THIS REALLY WORK?!?!)\n\t\t\tnvec *= dot(nvec, n);\n\n\t\t\t// Construct a new reflected ray.\n\t\t\t// Specular is used to lerp between correct reflection and random nonsense.\n\t\t\tray.dir = mix(nvec, reflect(ray.dir, n), cm.specular);\n\n\t\t\t// New ray's origin is set just a bit outside of intersection point, so\n\t\t\t// that the new ray is not immediately intersects at the same point.\n\t\t\tray.origin = newpos + n * REFLECT_EPSILON;\n\t\t} // for all bounces\n\t} // for all samples\n\n\t// We're done, weight accumulated pixel and write it to users' eyes\n\t// (\\todo do I need to gamma-correct here? I know nothing about gamma correction, but\n\t//        everyone else seem to do it. Oh what to do!)\n\tfragColor = vec4(pow(max(vec3(0.), sumcolor) / float(SAMPLES), vec3(.7)), 1.);\n}","name":"","description":"","type":"image"}]}