{"ver":"0.1","info":{"id":"mtcBDl","date":"1705870433","viewed":109,"name":"Harnack Dipole Bounds","username":"mgillesp","description":"draw a point cloud by Harnack tracing the level sets of a sum of dipoles, uses actual lower bounds on the function values (https://markjgillespie.com/Research/harnack-tracing/)","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["3d","distancefield","sdf"],"hasliked":0,"parentid":"ddccWN","parentname":"Harnack Dipoles"},"renderpass":[{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const bool use_harnack_tracing = true;\nconst float domain_shrink = 0.75;\nconst int max_iterations = 250;\nconst float epsilon = 0.1;\nconst float sphere_termination_size = 0.000015;\n\nconst bool draw_vertices = false;\nconst float vertex_radius = .01;\nconst bool draw_hit_points = false;\nconst bool draw_ground_plane = false;\nconst bool draw_shadow = false;\nconst vec3 groundNormal = normalize( vec3( 0., 1., 0. ) );\nconst float groundLevel = -0.8;\n\n// 0 : white\n// 1 : light tan\n// 2 : dark tan\nconst int backgroundColor = 0;\n\n//== Scene Options: ICOSPHERE or SPOT\n#define SPOT\n\n// WARNING: trying to raymarch or sphere trace spot crashes my computer\n// 0 : harnack tracing\n// 1 : fixed-step ray marching\n// 2 : sphere tracing with bogus Lipschitz bound\nconst int render_mode = 0;\n\n//== Harnack tracing accelerations\n// #define GRAD_TERMINATION\n// #define R3_TERMINATION\n#define SPHERE_TERMINATION\n\n#ifdef ICOSPHERE\n//== Icosphere\n// http://blog.andreaskahler.com/2009/06/creating-icosphere-mesh-in-code.html\nconst float tIco = ( 1. + sqrt( 5. ) ) / 2.;\n#define N 12\nvec3 points[N] = vec3[](\n\tvec3( -1,  tIco,  0 ),\n\tvec3(  1,  tIco,  0 ),\n\tvec3( -1, -tIco,  0 ),\n\tvec3(  1, -tIco,  0 ),\n\n\tvec3(  0, -1,  tIco ),\n\tvec3(  0,  1,  tIco ),\n\tvec3(  0, -1, -tIco ),\n\tvec3(  0,  1, -tIco ),\n\n\tvec3(  tIco,  0, -1 ),\n\tvec3(  tIco,  0,  1 ),\n\tvec3( -tIco,  0, -1 ),\n\tvec3( -tIco,  0,  1 )\n);\n\nvec3 normals[N] = vec3[](\n\tnormalize( vec3( -1,  tIco,  0 ) ),\n\tnormalize( vec3(  1,  tIco,  0 ) ),\n\tnormalize( vec3( -1, -tIco,  0 ) ),\n\tnormalize( vec3(  1, -tIco,  0 ) ),\n\n\tnormalize( vec3(  0, -1,  tIco ) ),\n\tnormalize( vec3(  0,  1,  tIco ) ),\n\tnormalize( vec3(  0, -1, -tIco ) ),\n\tnormalize( vec3(  0,  1, -tIco ) ),\n\n\tnormalize( vec3(  tIco,  0, -1 ) ),\n\tnormalize( vec3(  tIco,  0,  1 ) ),\n\tnormalize( vec3( -tIco,  0, -1 ) ),\n\tnormalize( vec3( -tIco,  0,  1 ) )\n);\n\n\nfloat levelset = 20. / (4. * PI); // icosphere\n#endif // ICOSPHERE\n#ifdef SPOT\n//== Spot\n#define N 100\nvec3 points[N] = vec3[](\n\tvec3( 0.306682, -0.404653, 0.383932),\tvec3( 0.358149, -0.171814, -0.0067112),\tvec3( -0.19394, -0.449722, 0.557741),\tvec3( -0.365797, -0.345487, 0.183516),\tvec3( 0.297829, -0.475641, -0.117192),\tvec3( 0.102813, -0.590646, 0.884883),\tvec3( 0.340888, 0.019913, 0.0839484),\tvec3( 0.294191, -0.561968, 0.676349),\tvec3( 0.0924641, -0.26676, 0.942342),\tvec3( 0.205547, -0.568616, 0.180048),\tvec3( 0.250984, -0.169652, 0.897166),\tvec3( 0.351356, -0.63048, 0.0736117),\tvec3( -0.148554, -0.254757, -0.137669),\tvec3( -0.00320457, 0.313508, 0.263692),\tvec3( 0.234424, -0.546378, 0.925362),\tvec3( -0.146923, -0.505335, 0.149239),\tvec3( 0.109633, -0.465052, -0.0387675),\tvec3( -0.131672, -0.149403, 0.958545),\tvec3( -0.240129, -0.578025, -0.119354),\tvec3( 0.361912, -0.0642679, 0.398502),\tvec3( -0.28464, -0.408323, 0.900592),\tvec3( 0.00294226, -0.447451, 0.139488),\tvec3( -0.115035, -0.624938, 0.698428),\tvec3( -0.0332526, -0.0243671, -0.227731),\tvec3( 0.00878529, -0.492536, 0.58569),\tvec3( 0.105753, 0.317392, 0.186009),\tvec3( 0.0500551, 0.609591, 0.00245756),\tvec3( -0.295486, 0.474562, -0.288572),\tvec3( 0.324769, -0.389326, 0.501175),\tvec3( -0.357239, -0.0836032, 0.51056),\tvec3( 0.276488, 0.0759707, 0.661792),\tvec3( 0.192402, -0.0642831, -0.155336),\tvec3( -0.0412089, 0.10166, -0.421542),\tvec3( -0.170017, 0.169369, 0.715236),\tvec3( -0.327356, -0.589277, 0.804906),\tvec3( 0.230041, -0.639426, -0.103619),\tvec3( -0.110596, -0.535272, 0.902005),\tvec3( -0.342371, 0.036362, 0.145877),\tvec3( 0.24905, -0.293581, 0.906185),\tvec3( -0.247021, 0.45102, -0.552863),\tvec3( -0.32145, -0.426584, 0.673947),\tvec3( 0.122936, -0.663889, 0.0508158),\tvec3( -0.161405, 0.151953, -0.127951),\tvec3( 0.051275, 0.058084, 0.943437),\tvec3( -0.121045, 0.046851, 0.926983),\tvec3( -0.206236, 0.759014, -0.323287),\tvec3( 0.126489, 0.183638, 0.750458),\tvec3( -0.0362124, 0.231166, 0.504113),\tvec3( -0.354147, -0.0147716, 0.334118),\tvec3( -0.296698, -0.246412, 0.859819),\tvec3( 0.136865, -0.506635, 0.456064),\tvec3( -0.209169, 0.157045, 0.527834),\tvec3( 0.00367757, -0.0867345, 0.992075),\tvec3( -0.383434, -0.324812, 0.0641477),\tvec3( -0.365795, -0.612288, 0.0439601),\tvec3( 0.0277583, 0.378706, 0.0416162),\tvec3( 0.355872, -0.112496, 0.605408),\tvec3( -0.360554, -0.324764, 0.40733),\tvec3( 0.277368, 0.417234, -0.151495),\tvec3( -0.186198, -0.469504, 0.346607),\tvec3( 0.342467, -0.296243, 0.680109),\tvec3( 0.374423, -0.219038, 0.390429),\tvec3( -0.236825, -0.711007, 0.851152),\tvec3( 0.384589, -0.194908, 0.281083),\tvec3( 0.252692, 0.0750571, -0.0412684),\tvec3( 0.373658, -0.305609, -0.024758),\tvec3( 0.350413, -0.453177, 0.158818),\tvec3( 0.224368, 0.208949, 0.339743),\tvec3( 0.07022, -0.226575, -0.174293),\tvec3( 0.184936, 0.541373, -0.529854),\tvec3( -0.323632, -0.047496, 0.758027),\tvec3( 0.306797, 0.57648, -0.208208),\tvec3( 0.1775, -0.710941, 0.714975),\tvec3( -0.161812, 0.252072, -0.650599),\tvec3( -0.228639, 0.498725, -0.0642101),\tvec3( -0.206675, 0.179157, -0.290203),\tvec3( 0.212557, 0.254618, -0.642058),\tvec3( -0.349235, -0.0977347, 0.00828974),\tvec3( -0.343705, -0.211543, 0.691228),\tvec3( -0.0639344, 0.413, -0.623514),\tvec3( -0.0835288, -0.361608, 0.905793),\tvec3( -0.215308, 0.214672, 0.0460902),\tvec3( 0.0122909, -0.444126, 0.705749),\tvec3( 0.168202, 0.163275, -0.26553),\tvec3( -0.24705, 0.0290526, -0.080353),\tvec3( 0.0406593, 0.790636, -0.421032),\tvec3( -0.248916, 0.602213, -0.466259),\tvec3( 0.330574, 0.279548, -0.470598),\tvec3( -0.248857, 0.188787, 0.307984),\tvec3( 0.242355, 0.209323, 0.100013),\tvec3( -0.210851, 0.137126, -0.50908),\tvec3( 0.207829, 0.162209, 0.503176),\tvec3( -0.389944, 0.692829, -0.149178),\tvec3( -0.165372, -0.712837, 0.0543033),\tvec3( 0.307525, 0.433808, -0.344528),\tvec3( 0.209844, 0.898253, -0.315469),\tvec3( -0.324978, 0.296029, -0.379304),\tvec3( -0.12576, 0.901885, -0.276456),\tvec3( 0.427666, 0.708736, -0.158823),\tvec3( -0.108179, -0.417472, -0.0443039));\nvec3 normals[N] = vec3[](\nvec3( 0.0212774, -0.0397249, -0.00342002 ), vec3( 0.0455036, 0.00902576, -0.012068 ), vec3( -0.00585578, -0.0496358, -0.00566438 ), vec3( -0.0539768, -0.0132934, 0.0095523 ), vec3( 0.00459174, 0.00113014, -0.051305 ), vec3( -0.0469749, -0.0104663, 0.0290918 ), vec3( 0.0454696, 0.0207964, -0.00924527 ), vec3( 0.0356246, -0.0113618, -0.0513739 ), vec3( 0.00279562, -0.0138246, 0.041756 ), vec3( -0.0119436, -0.00493423, 0.0481967 ), vec3( 0.0382477, 0.00289402, 0.0382439 ), vec3( 0.0443289, -0.0205023, 0.0100126 ), vec3( -0.0114938, -0.0239121, -0.0601678 ), vec3( 0.000350158, 0.0534932, 0.0086926 ), vec3( 0.0109953, 0.00139644, 0.0579494 ), vec3( 0.0516461, -0.00602569, 0.0261386 ), vec3( -0.0471449, -0.00211527, -0.0246048 ), vec3( -0.0113289, -0.00418179, 0.0403076 ), vec3( 0.014313, -0.0047053, -0.0622136 ), vec3( 0.049128, 0.0114733, 0.00572083 ), vec3( -0.0231286, 0.00327868, 0.0355347 ), vec3( 0.00273637, -0.060561, -0.00926066 ), vec3( 0.0482899, -0.0127304, -0.0264988 ), vec3( -0.0074129, -0.00655602, -0.0571484 ), vec3( 0.00194113, -0.0430499, 0.0186571 ), vec3( 0.00683859, 0.0442481, 0.00204294 ), vec3( 0.0202528, 0.051899, 0.0884584 ), vec3( -0.0593763, 0.0140165, 0.00256623 ), vec3( 0.0259218, -0.0313197, 0.00203968 ), vec3( -0.0530126, 0.0108312, 0.00248999 ), vec3( 0.0447382, 0.0356156, 0.00411775 ), vec3( 0.0242896, 0.00718514, -0.0458273 ), vec3( -0.000683226, -0.0685248, 0.00204236 ), vec3( -0.0335113, 0.0476678, 0.01156 ), vec3( -0.0447612, -0.0097683, 0.00488457 ), vec3( -0.0103534, -0.0148802, -0.0409723 ), vec3( 0.0238009, -0.00238066, 0.0423585 ), vec3( -0.0439338, 0.018764, -0.00411555 ), vec3( 0.0174852, -0.000302541, 0.0435886 ), vec3( -0.0237241, 0.0295965, -0.0393156 ), vec3( -0.0464752, -0.0104914, -0.0130654 ), vec3( -0.042495, -0.0165667, 0.0076455 ), vec3( -0.0478837, -0.00898249, -0.0120354 ), vec3( 0.00941528, 0.0298118, 0.0466209 ), vec3( -0.016632, 0.026514, 0.0385766 ), vec3( -0.0513158, 0.0563523, -0.00636187 ), vec3( 0.0228992, 0.0564498, 0.0144727 ), vec3( -0.00203309, 0.0578667, 0.00618644 ), vec3( -0.0495979, 0.0187583, 0.00649695 ), vec3( -0.0348142, 0.00691696, 0.0191992 ), vec3( 0.0184715, -0.0564764, 0.00302029 ), vec3( -0.0344308, 0.03721, 0.00606153 ), vec3( 0.00243128, -0.0116385, 0.0403036 ), vec3( -0.0633785, 0.00366645, 0.000440917 ), vec3( -0.0624072, -0.0130914, 0.014063 ), vec3( 0.00297943, -0.0204744, 0.0712136 ), vec3( 0.0505951, 0.00206382, 0.00257907 ), vec3( -0.057713, -0.0159993, 0.00417189 ), vec3( 0.0681323, 0.00483552, 0.0196974 ), vec3( -0.031742, -0.0486934, -0.0181414 ), vec3( 0.054915, -0.00364689, 0.0014087 ), vec3( 0.0345874, -0.00096455, 0.00392787 ), vec3( -0.0118723, -0.0348696, 0.0262827 ), vec3( 0.0452695, -0.00122308, 0.00238879 ), vec3( 0.0320358, 0.0222737, -0.0290898 ), vec3( 0.0490324, 0.00551338, -0.00890749 ), vec3( 0.0491054, -0.0084688, 0.0116501 ), vec3( 0.0412602, 0.0293401, 0.0159441 ), vec3( 0.00853802, -0.0246645, -0.0498397 ), vec3( 0.0170239, 0.0352458, -0.0792775 ), vec3( -0.0497358, 0.0169414, 0.0131035 ), vec3( 0.0217735, -0.0665065, -0.0133725 ), vec3( -0.0135265, -0.049363, -0.0298498 ), vec3( -0.0101087, -0.0239935, -0.0539918 ), vec3( -0.0649998, 0.0309267, 0.0493468 ), vec3( -0.0309947, -0.0365213, 0.0147654 ), vec3( 0.0141954, -0.0328864, -0.0717119 ), vec3( -0.0529795, 0.00856261, -0.0176625 ), vec3( -0.0448678, -0.00340417, 0.00600355 ), vec3( -0.00024463, 0.0373593, -0.0542115 ), vec3( 0.0187066, -0.00822814, 0.0395811 ), vec3( -0.0442883, 0.0302891, -0.0247831 ), vec3( -0.000322743, -0.0469232, 0.0192592 ), vec3( 0.0343079, -0.0686826, 0.0249815 ), vec3( -0.0292944, 0.0187654, -0.0324314 ), vec3( 0.00486245, 0.0630406, -0.0645362 ), vec3( -0.0526186, 0.0179827, -0.0239661 ), vec3( 0.0647893, -0.00706675, -0.00338258 ), vec3( -0.0499983, 0.0282822, 0.0129363 ), vec3( 0.0416118, 0.0275984, -0.0157652 ), vec3( -0.0152704, -0.0477058, -0.00926725 ), vec3( 0.0310399, 0.0400531, 0.00621876 ), vec3( 0.00400425, 0.0276121, 0.0788667 ), vec3( 0.0367541, -0.0466116, 0.00772416 ), vec3( 0.0561654, 0.0132585, 0.00242745 ), vec3( 0.0507244, 0.0183201, -0.0575629 ), vec3( -0.0480082, -0.0152239, 0.0103222 ), vec3( 0.0545452, 0.0344843, -0.0228192 ), vec3( 0.0115359, 0.042364, 0.0611195 ), vec3( 0.0522649, -0.00824981, -0.0250422 ) );\nfloat levelset = 5.; // spot  \n#endif // SPOT\n\n\nconst vec3 light = vec3( 5., 10., 0. );\n                        \n// only intersect from positive direction\nbool intersectPlane( vec3 ro, vec3 rd, vec3 n, vec3 origin, float d, out float t ) {\n    // dot(n, ro + t rd - origin) == d\n    t = ( d - dot( n, ro - origin ) ) / dot( n, rd );\n    return dot( rd, n ) < 0. && t >= 0.;\n}\n\n// find time t when point (ro + t rd) hits the tangent plane to point x with normal n\nfloat projToTangent( in vec3 x, in vec3 n, in vec3 ro, in vec3 rd ) {\n    float t;\n    intersectPlane( ro, rd, n, x, 0., t );\n    return t;\n}\n\nfloat normalDistance( in vec3 x, in vec3 n, in vec3 p ) {\n    return abs( dot( p - x, n ) );\n}\n\nfloat dist2( in vec3 pt1, in vec3 pt2 ){ return dot( pt1 - pt2, pt1 - pt2 ); }\n\n// measure distance from p to point x, squashed in distance n\nfloat ellipse_dist2( in vec3 p, in vec3 x, in vec3 n ) {\n    float s = 5.;\n    vec3 d = p - x;\n    vec3 dn = dot( d, n ) * n / dot( n, n );\n    d = ( d + s * dn ) / ( s + 1. );\n    return dot( d, d );\n}\n\nfloat closestPoint( in vec3 pt, out int iP ) {\n    float minD2 = 1e10;\n    iP = -1;\n    for (int i = 0; i < N; i++){\n        float d2 = dist2( pt, points[i] );\n        if ( d2 < minD2 ) iP = i;\n        minD2 = min( minD2, d2 );\n     }\n     return sqrt( minD2 );\n\n}\n\n// find the potential for a dipole at position x with direction n evaluated at point p\nfloat dipolePotential( in vec3 x, in vec3 n, in vec3 p ) {\n    vec3 q = x - p;\n    return dot( q, n ) / pow( dot( q, q ), 1.5 );\n\n}\n\nvec3 dipoleGradient( in vec3 x, in vec3 n, in vec3 p ) {\n    vec3 q = x - p;\n    float q2 = dot( q, q );\n    return 3. * dot( q, n ) * q / pow( q2, 2.5 ) - n / pow( q2, 1.5 );\n}\n\nfloat totalPotential( in vec3 p ) {\n    float potential = 0.;\n    for ( int i = 0; i < N; i++ ) {\n        // potential += dipolePotential( points[i], normals[i], p );\n        vec3 q = points[i] - p;\n        potential += dot( q, normals[i] ) / pow( dot( q, q ), 1.5 );\n    }\n    \n    return potential;\n}\n\nvec3 gradient( in vec3 p ) {\n    vec3 grad = vec3( 0, 0, 0 );\n    for (int i = 0; i < N; i++){\n        grad += dipoleGradient( points[i], normals[i], p );\n    }\n    \n    return grad;\n}\n\n// takes in a plane with origin x and normal n,\n// and a sphere at point p with radius r,\n// and returns the minimum of <p - x, n> over all points p on the sphere\nfloat sphereDistToPlane(  in vec3 x, in vec3 n, in vec3 p, in float r ) {\n    return dot( x - p, n ) - r * sqrt( dot( n, n ) );\n}\n\n// takes in a point x and a sphere centered at point p with radius r,\n// and returns the min distance from the sphere to x\nfloat sphereMinDistToPoint( in vec3 x, in vec3 p, in float r ) {\n    return sqrt( dist2( x, p ) ) - r;\n}\n\n// takes in a point x and a sphere centered at point p with radius r,\n// and returns the max distance from the sphere to x\nfloat sphereMaxDistToPoint( in vec3 x, in vec3 p, in float r ) {\n    return sqrt( dist2( x, p ) ) + r;\n}\n\n// lower bound the potential of a dipole at position x with direction n,\n// over all points on the sphere centered at point p with radius r\nfloat dipoleLowerBound( in vec3 x, in vec3 n, in vec3 p, in float r ) {\n    float d_plane = sphereDistToPlane( x, n, p, r );\n    float r_bound = d_plane < 0. ? sphereMinDistToPoint( x, p, r ) : sphereMaxDistToPoint( x, p, r );\n    return d_plane / pow( r_bound, 3.);\n}\n\nfloat totalBound( in vec3 p, in float r ) {\n    float bound = 0.;\n    for ( int i = 0; i < N; i++ ) {\n        bound += dipoleLowerBound( points[i], normals[i], p, r );\n    }\n    \n    return bound;\n}\n\n//For harnack's checks if we're close to our desired level set\nbool closeToLevelset( float val, float levelset, float tol, float gradNorm, float R ) {\n#ifdef GRAD_TERMINATION    \n    float eps = tol * gradNorm;\n#elif defined( R3_TERMINATION )\n    // TODO: figure out a good termination condition\n    float e2 = tol * tol;\n    float e4 = e2 * e2;\n    float R2 = R * R;\n    float R4 = R2 * R2;\n    float R6 = R2 * R4;\n    float f2 = levelset * levelset;\n    float eps = -levelset * e2 / R2 + sqrt( 4. * R2 * e2 - 4. * f2 * R6 * e2 - e4 + f2 * R4 * e4 ) / R4;\n    if ( false && R > tol ) {\n        eps = tol;\n    }\n    // eps = min( tol, eps );\n    // float eps = tol * min(1., 1. / pow( R, 3. ) );\n#else\n    float eps = tol;\n#endif // GRAD_TERMINATION\n    return abs( val - levelset ) < eps;\n}\n\nbool raymarch( vec3 ro, vec3 rd, float tmax, out float t, out vec3 n, out vec3 pos ) {\n    t = 0.0;\n    bool didHit = false;\n    \n    float t_closest = 0.;\n    float v_closest = 99999.; // infinity\n    float dt = tmax / float( max_iterations );\n    \n    for( int i = 0; i < max_iterations && t < tmax; i++ ) {\n        pos = ro + t * rd;\n        \n        float val = totalPotential( pos );\n        if ( abs( val - levelset ) < epsilon ) {\n            n = normalize( gradient( pos ) );\n            return true;\n        }\n        t += dt;\n    }\n    \n    return false;\n}\n\nbool spheretrace( vec3 ro, vec3 rd, float tmax, out float t, out vec3 n, out vec3 pos ) {\n    t = 0.0;\n    bool didHit = false;\n    float L = 100.;\n    \n    float t_closest = 0.;\n    float v_closest = 99999.; // infinity\n    float dt = tmax / float( max_iterations );\n    \n    for( int i = 0; i < max_iterations && t < tmax; i++ ) {\n        pos = ro + t * rd;\n        \n        float val = totalPotential( pos );\n        float valDiff = abs( val - levelset );\n        \n        if ( valDiff < epsilon ) {\n            n = normalize( gradient( pos ) );\n            return true;\n        }\n        t += valDiff / L;\n    }\n    \n    return false;\n}\n\nfloat getMaxStep( float fx, float levelset, float R, float shift ){\n    float a = ( fx + shift ) / ( levelset + shift );\n    return R * abs( a + 2. - sqrt( a * a + 8. * a ) );\n}\n\nbool harnack( vec3 ro, vec3 rd,  inout vec3 pos, inout bool maxSteps, float tmax, out vec3 n, out bool hit_point ) {\n    \n    int i = 0;\n    float t = 0.;\n    maxSteps = false;\n    hit_point = false;\n    \n    float v_closest = 99999.; // infinity\n    float t_closest = 0.;\n    \n    float t_overstep = 0.;\n    \n    while ( t + t_overstep < tmax ) {\n        pos = ro + t * rd + t_overstep * rd;\n        if ( i >= max_iterations ) {\n            maxSteps = true;\n            if ( abs( v_closest - levelset ) < 2. * epsilon ) {\n                pos = ro + t_closest * rd;\n                n = normalize( gradient( pos ) );\n                return true;\n            } else {\n                n = vec3(1, 0, 0);\n                return false;\n            }\n        }\n        \n#ifdef GRAD_TERMINATION\n        float gradLen = length( gradient( pos ) );\n#else\n        float gradLen = 1.;\n#endif // GRAD_TERMINATION\n        float val = totalPotential( pos );\n\n        int iClosest;\n        float R = closestPoint( pos, iClosest );\n\n        if ( closeToLevelset( val, levelset, epsilon, gradLen, R ) ) {\n            float k = 100.;\n            if (false&& R < k * epsilon && iClosest >= 0 ) {\n                vec3 gn = normalize( gradient( pos ) );\n                vec3 pn = -normalize( normals[iClosest] );\n                float s = smoothstep(.75 * k * epsilon, k * epsilon, R);\n                n = normalize( (1. - s) * pn + s * gn );\n            } else {\n                n = normalize( gradient( pos ) );\n            }\n            return true;\n        }\n        \n        if ( abs( val - levelset ) < abs( v_closest - levelset ) ) {\n            v_closest = val;\n            t_closest = t;\n        }\n        \n#ifdef SPHERE_TERMINATION\n        if ( iClosest >= 0 ) {\n            vec3 p_closest = points[iClosest];\n            vec3 n_closest = normals[iClosest];\n            if ( ellipse_dist2( pos, p_closest, n_closest ) < sphere_termination_size ) {\n                n = -normalize( n_closest );\n                hit_point = true;\n                return true;\n            }\n        }\n#endif\n        \n        float offset = R * domain_shrink;\n        R -= offset;\n        \n        // float shift = 5. * PI  + .025 / ( offset * offset );\n        float shift = -totalBound( pos, R );\n        float r = getMaxStep( val, levelset, R, shift );\n        \n        // overstep was valid if r >= t_overstep\n        float stepSize = (r >= t_overstep) ? t_overstep + r : 0.;\n        t_overstep = (r >= t_overstep) ? r * .75 : 0.;\n        t += stepSize;\n        \n        i++;\n        \n     }\n     \n     // this doesn't seem important, but weird background artifacts appear without it\n     n = vec3(1, 0, 0);\n     return false;\n}\n\nbool intersect_sphere( in vec3 ro, in vec3 rd, in vec3 p, in float r, out float t, out vec3 n ) {\n    t = dot( rd, p-ro ) / dot( rd, rd );\n    float d = length( ro + t * rd - p );\n    \n    if ( d > r ) return false;\n    \n    float s = sqrt( r * r - d * d );\n    if ( t - s >= 0. ) {\n        t -= s;\n    } else {\n        t += s;\n    }\n    \n    n = normalize( ro + t * rd - p );\n    \n    return t > 0.;\n}\n\nbool traceVertices(vec3 ro, vec3 rd, out vec3 position, out vec3 normal, out float t){\n    vec3 n; \n    for (int i = 0; i < N; i ++){\n        bool didHit = intersect_sphere( ro, rd, points[i], vertex_radius, t, n );\n        if (didHit){\n            position = ro + t * rd;\n            normal = normalize( position - points[i] );\n            return true;\n        }\n    }\n    \n    return false;\n}\n\nvec3 diffuseShade( vec3 pos, vec3 normal, vec3 light, vec3 materialColor ) {\n    return materialColor * max( dot( normalize( light - pos ), normal ), 0.3 );\n}\n\nvec3 fresnelShade( vec3 pos, vec3 ray, vec3 normal, vec3 materialColor ) {\n    return vec3( pow( 1. - abs( dot( ray, normal ) ), 4. ) );\n}\n\n// ( from https://www.shadertoy.com/view/7tKfz1 )\nvec3 normalShade(vec3 ray, vec3 normal, vec3 materialColor) {\n    // material\n    float metallic = 0.07;\n    float roughness = 0.1;\n    float fresnel_pow = mix(5.0, 3.5, metallic);\n    vec3 color_mod = vec3(1.0);\n    vec3 light_color = pow(texture(iChannel1,vec3(1.0,0.0,0.0)).xyz * 1.2, vec3(2.2));\n\n\n    // IBL\n    vec3 ibl_diffuse = pow(textureBlured(iChannel1,normal), vec3(2.2));\n    vec3 ibl_reflection = pow(textureBlured(iChannel1,reflect(ray,normal)), vec3(2.2));\n\n    // fresnel\n    float fresnel = max(1.0 - dot(normal,-ray), 0.0);\n    fresnel = pow(fresnel,fresnel_pow);    \n\n    // reflection        \n    vec3 refl = pow(texture(iChannel1,reflect(ray,normal)).xyz, vec3(2.2));\n    refl = mix(refl,ibl_reflection,(1.0-fresnel)*roughness);\n    refl = mix(refl,ibl_reflection,roughness);\n\n    // specular\n    vec3 light = normalize(vec3(-0.5,1.0,0.0));\n    float power = 1.0 / max(roughness * 0.4,0.01);\n    vec3 spec = light_color * GGX(normal,-ray,light,roughness*0.7, 0.2);\n    refl -= spec;\n\n    // diffuse\n    vec3 diff = ibl_diffuse * pow(materialColor, vec3(2.2));\n    diff = mix(diff * color_mod,refl,fresnel);        \n\n    vec3 color = min( mix(diff,refl * color_mod,metallic) + spec, vec3(1., 1., 1.) );\n    return pow(color, vec3(1.0/2.2));\n}\n\nvec3 shade(vec3 pos, vec3 ray, vec3 normal, vec3 materialColor) {\n    return min(\n            diffuseShade( pos, normal, light, materialColor )\n             + 0.3 * normalShade( ray, normal, materialColor )\n             + 0.6 * fresnelShade( pos, ray, normal, materialColor ),\n            vec3(1., 1., 1.)\n        );\n}\n    \n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 1\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // Calculate camera configuration from keyboard & mouse input buffer\n    // (from https://www.shadertoy.com/view/7tKfz1)\n    vec2 camRot = texelFetch(iChannel0, ivec2(0, 0), 0).xy;\n    vec2 cr = cos(camRot);\n    vec2 sr = sin(camRot);\n    mat3 v2wRotMat = mat3(\n            cr.y,         0.0,  -sr.y,\n            sr.x * sr.y,  cr.x,  cr.y * sr.x,\n            cr.x * sr.y, -sr.x,  cr.x * cr.y);\n    vec4 camPosD = texelFetch(iChannel0, ivec2(1, 0), 0);\n    vec3 camPos = (camPosD.xyz + v2wRotMat * vec3(0.0, 0.0, 0.85) * camPosD.w); \n    float fovY = 50.0;\n    vec2 tanHalfFov = vec2(tan(radians(fovY) * 0.5)); \n    tanHalfFov.x *= iResolution.x / iResolution.y;\n\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n         // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        // vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        vec2 cCoord = fragCoord / iResolution.xy * 2.0 - 1.0 + o / iResolution.y;\n        vec3 vDir = normalize(vec3(cCoord * tanHalfFov, -1.0));\n        #else    \n        // vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        vec2 cCoord = fragCoord / iResolution.xy * 2.0 - 1.0;\n        vec3 vDir = normalize(vec3(cCoord * tanHalfFov, -1.0));\n        #endif\n\n\t    // create view ray\n        // vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n        vec3 rd = v2wRotMat * vDir;\n        vec3 ro = camPos;\n        \n        // ground shading\n        float tGround;\n        bool hitGround = draw_ground_plane && intersectPlane( ro, rd, groundNormal, vec3(0,0,0), groundLevel, tGround );\n        bool groundShadowed = false; float groundDist;\n        if ( hitGround ) {\n            vec3 groundPos = ro + tGround * rd, vIgnore;\n            vec3 lightDir = normalize( light - groundPos );\n            bool maxSteps, ignore_hit_point;\n            groundShadowed = draw_shadow && harnack( groundPos + 0.001 * lightDir, lightDir,\n                             groundPos, maxSteps, length( light - groundPos ), vIgnore, ignore_hit_point );\n        }\n\n        // raymarch\n        const float tmax = 4.0;\n        vec3 pos;\n        bool didHit = false;\n        \n        vec3 vertexPos, vertexNormal;\n        float tVertex;\n        bool hitVertex = draw_vertices && traceVertices(ro, rd, vertexPos, vertexNormal, tVertex);\n       \n        float ray_tmax = hitVertex ? min( tmax, tVertex - 0.01 ) : tmax;  \n       \n        bool maxSteps, hit_point = false;\n        float t;\n        vec3 nor = vec3(0, 0, 0);\n        if  ( render_mode == 1 ) {\n            didHit = raymarch(ro, rd, ray_tmax, t, nor, pos );\n        } else if ( render_mode == 2 ) {\n            didHit = spheretrace(ro, rd, ray_tmax, t, nor, pos );\n        } else {\n            didHit = harnack(ro, rd, pos, maxSteps, ray_tmax, nor, hit_point);\n        }\n        \n        if ( didHit && hitVertex && tVertex < t ) didHit = false;\n    \n        // shading/lighting\t\n        vec3 col = vec3( 1 ); \n        if ( backgroundColor == 1 ) {\n            col = vec3(245., 243., 225.) / 255.; col *= col; /* for gamma */\n        } else if ( backgroundColor == 2 ) {\n            col = vec3(244., 238., 216.) / 255.; col *= col; /* for gamma */\n        }\n        if ( false && maxSteps ) {\n            col =  vec3(1.f,0.0,0.0);\n        } else if ( hitVertex && !didHit ) {\n            vec3 baseColor = vec3( 230, 187, 98 ) / 255.;\n            col = shade( vertexPos, rd, vertexNormal, baseColor );\n        } else if( didHit ) {\n            vec3 baseColor = vec3(148, 17, 32) / 255.;\n            if ( draw_hit_points && hit_point ) baseColor = vec3( 0 );\n            vec3 outwardNormal = dot( nor, rd ) > 0. ? -nor : nor;\n            col = shade( pos, rd, outwardNormal, baseColor );\n        } else if ( hitGround ) {\n            if ( groundShadowed ) {\n                col *= 0.6;\n            }\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// =============== Alternative scenes\n\n/*\n#define N 12\nvec3[N] points = vec3[](\n    vec3( 1.,  0.,  0.),\n    vec3( 0.,  1.,  0.),\n    vec3(-1.,  0.,  0.),\n    vec3( 0., -1.,  0.),\n    vec3( 1.,  0.,  .05),\n    vec3( 0.,  1.,  .05),\n    vec3(-1.,  0.,  .05),\n    vec3( 0., -1.,  .05),\n    vec3( 1.,  0.,  .1),\n    vec3( 0.,  1.,  .1),\n    vec3(-1.,  0.,  .1),\n    vec3( 0., -1.,  .1)\n);/*\n//vec3[N] points = vec3[](vec3(1., 0., 0.), vec3(0., 1., 0.), vec3(-1., 0., 0.), vec3(0., 0., 1.));\n/* vec3 points[N] = vec3[N]( vec3(.833,.1667,0.333),\n                        vec3(0.875,.25,0.0),\n                        vec3(.5,0.,.0),\n                        vec3(.125,.125,.25),\n                        vec3(0.1667,.333,0.0),\n                        vec3(0.75,.5,0.),\n                        vec3(0.6667,.3333,0.6667),\n                        vec3(0.375,.375,0.25),\n                        vec3(0.5,0.75,0.5),\n                        vec3(0.625,.25,0.0),\n                        vec3(0.333,0.6667,0.),\n                        vec3(0.25,0.25,0.5)\n                        ); */\n\nconst float PI = 3.14159265358979323846;\n\n// find a vector orthogonal to v\nvec3 orthogonal( vec3 v ) {\n    if ( abs( v.x ) <= abs( v.y ) && abs( v.x ) <= abs( v.z ) ) {\n        return normalize( vec3( 0., -v.z, v.y ) );\n    } else if ( abs( v.y ) <= abs( v.x ) && abs( v.y ) <= abs( v.z ) ) {\n        return normalize( vec3( v.z, 0., -v.x ) );\n    } else {\n        return normalize( vec3( -v.y, v.x, 0. ) );\n    }\n}\n\n\n//===== Complex arithmetic (from https://www.shadertoy.com/view/NlG3DD)\nvec2 cexp( float s ) {\n    return vec2( cos( s ), sin( s ) );\n}\n\nfloat arg( vec2 z ) {\n    return atan( z.y, z.x );\n}\n\n// complex multiplication\nvec2 mul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y,\n                a.x * b.y + a.y * b.x);\n}\n\n// complex conjugation\nvec2 conj(vec2 a) {\n    return vec2(a.x, -a.y);\n}\n\n// complex inverse\nvec2 inv(vec2 a) {\n   return conj(a)/dot(a,a);\n}\n\n// complex division\nvec2 div(vec2 a, vec2 b) {\n    return mul(a,inv(b));\n}\n\n//============================================================\n// \n//                          Quaternions\n//\n//============================================================\n\nvec4 q1 = vec4( 1., 0., 0., 0. );\nvec4 qi = vec4( 0., 1., 0., 0. );\nvec4 qj = vec4( 0., 0., 1., 0. );\nvec4 qk = vec4( 0., 0., 0., 1. );\n\nfloat re( vec4 q ) {\n    return q.x;\n}\n\nvec3 im( vec4 q ) {\n    return q.yzw;\n}\n\nvec4 mul( vec4 a, vec4 b ) {\n    return vec4(\n        re( a ) * re( b ) - dot( im( a ), im( b ) ),\n        re( a ) * im( b ) + re( b ) * im( a ) + cross( im( a ), im( b ) )\n    );\n}\n\nvec4 conj( vec4 q ) {\n    return vec4( q.x, -q.y, -q.z, -q.w );\n}\n\nvec4 inv( vec4 q ) {\n    return conj( q ) / dot( q, q );\n}\n\nvec4 div( vec4 a, vec4 b ) {\n    return mul( a, inv( b ) );\n}\n\nvec3 arg( vec4 q ) {\n    float theta = atan( length( im( q ) ), re( q ) );\n    return theta * normalize( im( q ) );\n}\n\nvec4 qLog( vec4 q ) {\n    return vec4(\n        log( length( q ) ),\n        arg( q )\n    );\n}\n\nvec4 qExp( vec4 q ) {\n    float norm = length( q );\n    return exp( re( q ) ) * vec4(\n        cos( norm ),\n        sin( norm ) * normalize( im( q ) )\n    );\n}\n\n// dihedral of two points on the unit sphere, as defined by Chern & Ishida https://arxiv.org/abs/2303.14555\nvec4 dihedral( vec3 p1, vec3 p2 ) {\n    // float s = sqrt( 2. + 2. * dot( p1, p2 ) );\n    // return vec4( s / 2., cross( p1, p2 ) / s );\n    \n    // https://stackoverflow.com/a/11741520\n    float lengthProduct = length( p1 ) * length( p2 );\n    \n    if ( abs( dot( p1, p2 ) / lengthProduct + 1. ) < 0.0001 ) {\n        // antiparallel vectors\n        return vec4( 0., orthogonal( p1 ) );\n    }\n    \n    vec4 result;\n    result.x   = dot( p1, p2 ) + lengthProduct;\n    result.yzw = cross( p1, p2 );\n    // return normalize( result ); // can skip normalization since we don't care about magnitude\n    return result; \n}\n\n// arg(\\bar{q2} q1) as defined by Chern & Ishida https://arxiv.org/abs/2303.14555\nfloat fiberArg( vec4 q1, vec4 q2 ) {\n    vec4 s = mul( conj( q2 ), q1 );\n    return atan( s.y, s.x );\n}\n\n//============================================================================//\n\n// Start of modified PBR code from https://www.shadertoy.com/view/XsfXWX\n// (taken from https://www.shadertoy.com/view/7tKfz1)\n\nfloat somestep(float t) {\n    return pow(t,4.0);\n}\n\nvec3 textureAVG(samplerCube tex, vec3 tc) {\n    const float diff0 = 0.35;\n    const float diff1 = 0.12;\n \tvec3 s0 = texture(tex,tc).xyz;\n    vec3 s1 = texture(tex,tc+vec3(diff0)).xyz;\n    vec3 s2 = texture(tex,tc+vec3(-diff0)).xyz;\n    vec3 s3 = texture(tex,tc+vec3(-diff0,diff0,-diff0)).xyz;\n    vec3 s4 = texture(tex,tc+vec3(diff0,-diff0,diff0)).xyz;\n    \n    vec3 s5 = texture(tex,tc+vec3(diff1)).xyz;\n    vec3 s6 = texture(tex,tc+vec3(-diff1)).xyz;\n    vec3 s7 = texture(tex,tc+vec3(-diff1,diff1,-diff1)).xyz;\n    vec3 s8 = texture(tex,tc+vec3(diff1,-diff1,diff1)).xyz;\n    \n    return (s0 + s1 + s2 + s3 + s4 + s5 + s6 + s7 + s8) * 0.111111111;\n}\n\nvec3 textureBlured(samplerCube tex, vec3 tc) {\n   \tvec3 r = textureAVG(tex,vec3(1.0,0.0,0.0));\n    vec3 t = textureAVG(tex,vec3(0.0,1.0,0.0));\n    vec3 f = textureAVG(tex,vec3(0.0,0.0,1.0));\n    vec3 l = textureAVG(tex,vec3(-1.0,0.0,0.0));\n    vec3 b = textureAVG(tex,vec3(0.0,-1.0,0.0));\n    vec3 a = textureAVG(tex,vec3(0.0,0.0,-1.0));\n        \n    float kr = dot(tc,vec3(1.0,0.0,0.0)) * 0.5 + 0.5; \n    float kt = dot(tc,vec3(0.0,1.0,0.0)) * 0.5 + 0.5;\n    float kf = dot(tc,vec3(0.0,0.0,1.0)) * 0.5 + 0.5;\n    float kl = 1.0 - kr;\n    float kb = 1.0 - kt;\n    float ka = 1.0 - kf;\n    \n    kr = somestep(kr);\n    kt = somestep(kt);\n    kf = somestep(kf);\n    kl = somestep(kl);\n    kb = somestep(kb);\n    ka = somestep(ka);    \n    \n    float d;\n    vec3 ret;\n    ret  = f * kf; d  = kf;\n    ret += a * ka; d += ka;\n    ret += l * kl; d += kl;\n    ret += r * kr; d += kr;\n    ret += t * kt; d += kt;\n    ret += b * kb; d += kb;\n    \n    return ret / d;\n}\n\n// GGX code from https://www.shadertoy.com/view/MlB3DV\nfloat G1V ( float dotNV, float k ) {\n\treturn 1.0 / (dotNV*(1.0 - k) + k);\n}\nfloat GGX(vec3 N, vec3 V, vec3 L, float roughness, float F0) {\n    \tfloat alpha = roughness*roughness;\n\tvec3 H = normalize (V + L);\n\n\tfloat dotNL = clamp (dot (N, L), 0.0, 1.0);\n\tfloat dotNV = clamp (dot (N, V), 0.0, 1.0);\n\tfloat dotNH = clamp (dot (N, H), 0.0, 1.0);\n\tfloat dotLH = clamp (dot (L, H), 0.0, 1.0);\n\n\tfloat D, vis;\n\tfloat F;\n\n\t// NDF : GGX\n\tfloat alphaSqr = alpha*alpha;\n\tfloat pi = 3.1415926535;\n\tfloat denom = dotNH * dotNH *(alphaSqr - 1.0) + 1.0;\n\tD = alphaSqr / (pi * denom * denom);\n\n\t// Fresnel (Schlick)\n\tfloat dotLH5 = pow (1.0 - dotLH, 5.0);\n\tF = F0 + (1.0 - F0)*(dotLH5);\n\n\t// Visibility term (G) : Smith with Schlick's approximation\n\tfloat k = alpha / 2.0;\n\tvis = G1V (dotNL, k) * G1V (dotNV, k);\n\n\treturn /*dotNL */ D * F * vis;\n}\n\n\n// End of modified PBR code from https://www.shadertoy.com/view/XsfXWX\n\n//============================================================================//","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// (from https://www.shadertoy.com/view/7tKfz1)\n//-----------------------Keyboard & Mouse Input Handler-----------------------//\n\n// Settings: \nconst float MOUSE_SENSITIVITY = 5.0;  \nconst float MOVEMENT_SPEED = 4.0; // Units per second\n\n// Controls:\nconst float KEY_W = 87.0;     // forwards\nconst float KEY_A = 65.0;     // left\nconst float KEY_S = 83.0;     // backwards\nconst float KEY_D = 68.0;     // right\nconst float KEY_UP = 38.0;    // forwards\nconst float KEY_LEFT = 37.0;  // left\nconst float KEY_DOWN = 40.0;  // backwards\nconst float KEY_RIGHT = 39.0; // right\nconst float KEY_SPACE = 32.0; // up\nconst float KEY_SHIFT = -1.; // down\nconst float KEY_J = 74.0;     // up\nconst float KEY_N = 78.0;     // down\nconst float KEY_K = 75.0;     // decrease orbit radius\nconst float KEY_M = 77.0;     // increase orbit radius\n\n\n\n//============================================================================//\n\n\n\nbool keyPressed(float keyCode) {\n    return texture(iChannel0, vec2((keyCode + 0.5) / 256.0, 0.5 / 3.0)).r > 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0, 0.0, 1.0, 1.0);\n    \n    if (fragCoord == vec2(0.5, 0.5)) {\n        if (iMouse.z > 0.0) {\n            vec2 oldCamRot = texelFetch(iChannel1, ivec2(0, 0), 0).zw;\n            float mouseSens = -MOUSE_SENSITIVITY / iResolution.x;\n            fragColor = vec4(clamp(oldCamRot.x - (iMouse.y - abs(iMouse.w)) * mouseSens, -PI * 0.5, PI * 0.5),\n                                   oldCamRot.y + (iMouse.x - abs(iMouse.z)) * mouseSens,\n                                   oldCamRot);\n        } else {\n            vec2 camRot = texelFetch(iChannel1, ivec2(0, 0), 0).xy;\n            fragColor = camRot.xyxy;\n        }\n        \n        if (iFrame == 0 || iMouse.x == 0.0 && iMouse.z == 0.0) {\n            fragColor.x = mix(-0.3, 0.1, 0.5 - 0.5 * cos(iTime * 0.5));\n            fragColor.y = -0.5 + iTime * 0.3;\n        }\n    } else if (fragCoord == vec2(1.5, 0.5)) {\n        fragColor = texelFetch(iChannel1, ivec2(1, 0), 0);\n        float camRotY = texelFetch(iChannel1, ivec2(0, 0), 0).y;\n        float c = cos(camRotY);\n        float s = sin(camRotY);\n        mat3 rotMat = mat3(\n                c,   0.0,  -s,\n                0.0, 1.0,  0.0,\n                s,   0.0,  c\n            ) * MOVEMENT_SPEED * iTimeDelta;\n        vec3 right = vec3(1.0, 0.0, 0.0);\n        vec3 up = vec3(0.0, 1.0, 0.0);\n        vec3 forward = vec3(0.0, 0.0, -1.0);\n        \n        if (keyPressed(KEY_W) || keyPressed(KEY_UP)) {\n            fragColor.xyz += rotMat * forward;\n        }\n        if (keyPressed(KEY_S) || keyPressed(KEY_DOWN)) {\n            fragColor.xyz -= rotMat * forward;\n        }\n        \n        if (keyPressed(KEY_D) || keyPressed(KEY_RIGHT)) {\n            fragColor.xyz += rotMat * right;\n        }\n        if (keyPressed(KEY_A) || keyPressed(KEY_LEFT)) {\n            fragColor.xyz -= rotMat * right;\n        }\n        \n        if (keyPressed(KEY_SPACE) || keyPressed(KEY_J)) {\n            fragColor.xyz += rotMat * up;\n        }\n        if (keyPressed(KEY_SHIFT) || keyPressed(KEY_N)) {\n            fragColor.xyz -= rotMat * up;\n        }\n            \n        if (keyPressed(KEY_K)) {\n            fragColor.w   -= MOVEMENT_SPEED * iTimeDelta;\n        }\n        if (keyPressed(KEY_M)) {\n            fragColor.w   += MOVEMENT_SPEED * iTimeDelta;\n        }\n        \n        fragColor.w = iFrame == 0 ? 4.0 : max(fragColor.w, 0.0);\n    } else if (fragCoord == vec2(0.5, 1.5)) {\n        if (keyPressed(KEY_W)     || keyPressed(KEY_A)     || \n            keyPressed(KEY_S)     || keyPressed(KEY_D)     || \n            keyPressed(KEY_UP)    || keyPressed(KEY_LEFT)  || \n            keyPressed(KEY_DOWN)  || keyPressed(KEY_RIGHT) || \n            keyPressed(KEY_SPACE) || keyPressed(KEY_SHIFT) || \n            keyPressed(KEY_J)     || keyPressed(KEY_N)     || \n            keyPressed(KEY_K)     || keyPressed(KEY_M)     || \n            \n            iMouse.z > 0.0) {\n            fragColor.x = 1.0;\n        } else {\n            fragColor.x = texelFetch(iChannel1, ivec2(0, 1), 0).x + 1.0;\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}