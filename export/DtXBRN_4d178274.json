{"ver":"0.1","info":{"id":"DtXBRN","date":"1692656684","viewed":232,"name":"Bicycle Chain on Sprockets","username":"fizzer","description":"Animated SDF model of a chain made from links fitted to a pair of sprockets.","likes":48,"published":1,"flags":0,"usePreview":0,"tags":["gears","sdf","domainrepetition","chain","mechanism"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Some things to note:\n//\n// * The chain SDF is formed from 4 parts and each part consists of domain repetition (no loops).\n// * The teeth of the sprockets match up with the links in the chain.\n// * Four different configurations are shown one after another during playback.\n// * I tried to make the SDF as correct as I could, but there may still be errors in places.\n// * The number of evaluations of the chain SDF could be reduced, as well as the amount of code.\n//\n\nconst float pi = 3.14159265358979323;\n\n// Pre-determined configurations specifying the number of teeth on each sprocket,\n// the total number of links in the chain, the pitch width of the chain, and the displacement\n// between the centers of the sprockets (which was calculated offline by using a numerical\n// root-finding method).\nconst float[5] config0 = float[5](  8., 20., .15, 35.,  0.1860792205513077  );\nconst float[5] config1 = float[5]( 10., 16., .15, 40.,  0.05800424389849348 );\nconst float[5] config2 = float[5]( 26., 10., .15, 40., -0.2403969642129493  );\nconst float[5] config3 = float[5]( 20., 21., .15, 35.,  0.02195938472947117 );\n\n// Let n₀ and n₁ be the numbers of teeth in the sprockets, and n₂ be the number of links\n// in the chain. Let p be the pitch width. Then the radii of the sprockets are\n//\n// r₀ = p * n₀ / (2 * pi)\n// r₁ = p * n₁ / (2 * pi)\n//\n// Let L be the total length of the chain. L = n₂ * p\n//\n// pi / 2 * (r₁ + r₀) + (r₁ - r₀) / tan(θ) = L / 2 - (r₁ - r₀) * θ\n//\n// Solving this equation for θ gives the angle that the a line forms with\n// the line joining the sprocket centers when it is extended from the straight parts\n// of the chain.\n//\n// The displacement between the sprocket centers is given by s = (r₁ - r₀) / sin(θ)\n//\n\n\n// https://www.shadertoy.com/view/mlByzD\nvec2 radialRepeat(vec2 p, float th_offset, float dth, int i)\n{    \n    if(i > 0)\n    {\n        p = mat2(cos(-th_offset), sin(-th_offset), -sin(-th_offset), cos(-th_offset)) * p;\n    \n        float th0 = dth * .5;\n        float th1 = th0 + float(i) * dth;\n        float thm = (th0 + th1) / 2.;\n\n        vec2 v0 = vec2(sin(th0), -cos(th0));\n        vec2 w  = vec2(sin(thm), -cos(thm));\n\n        if(dot(p, w) < 0.)\n            p -= dot(p, w) * w * 2.;\n\n        float th;\n        \n        if(dot(p, w) < 0.)\n            th = -th1 - dth / 2.;\n        else if(dot(p, v0) < 0.)\n            th = floor(atan(p.y, p.x) / dth + .5) * -dth;\n        \n        p = mat2(cos(th), sin(th), -sin(th), cos(th)) * p;\n    }\n    \n    return p; \n}\n\n// https://www.shadertoy.com/view/wdXGDr\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r, h);\n    return min(max(d.x,d.y), 0.) + length(max(d, 0.));\n}\n\n// Profile distance for the curved outer part of the links.\n// It is made of three circles tangent to each other.\nfloat linkCurveDistance(float r, float s, float angle, vec2 uv)\n{\n    float o = tan(angle) * s;\n    float r2 = sqrt(o * o + s * s) - r;\n\n    uv = abs(uv);\n    \n    if(uv.y < (s - uv.x) * tan(angle))\n        return r2 - length(uv - vec2(0, o));\n    else\n        return length(uv - vec2(s, 0)) - r;\n}\n\nfloat linkDistance(vec3 p, float scale, float hscale)\n{\n    float r = .5 * scale, s = .7 * scale, angle = 1.2, h = .5 * scale * hscale;\n    float bevel = .05 * scale;\n    float d = 1e5;\n\n    p.x = abs(p.x);\n    \n    d = min(d, sdCappedCylinder(p.xzy - vec3(s, 0, 0), h * 1.2, r / 2. / hscale) - bevel / 2.);\n\n    p.z = abs(p.z) - h;\n    float cd = linkCurveDistance(r, s, angle, p.xy);\n    vec2 q = vec2(cd, abs(p.z));\n\n    d = min(d, length(max(q - h * .1, 0.)) + min(max(abs(p.z), cd), 0.) - bevel);\n        \n    return d;\n}\n\nfloat sprocketProfile(vec2 p, float r1, float r2, float r3, float r4, float n, float rotation)\n{\n    float dth = 2. * pi / n;\n    float adj = r2 / tan(dth / 2.);\n    float hyp = sqrt(r2 * r2 + adj * adj);\n    float hyp2 = hyp + r3 / sin(dth / 2.);\n    float adj2 = sqrt(hyp2 * hyp2 - pow(r2 + r3, 2.));\n    float th = atan(p.y, p.x) + rotation + dth / 2.;\n    \n    th = mod(th, dth);\n    \n    vec2 q = vec2(cos(th - dth / 2.), sin(th - dth / 2.)) * length(p);\n    vec2 q2 = vec2(cos(th), sin(th)) * length(p);\n    vec2 v = vec2(sin(dth / 2.), -cos(dth / 2.));\n    \n    if(dot(q2, v) < 0.)\n        q2 -= dot(q2, v) * v * 2.;\n        \n    float d = 1e5;\n\n    if(q.x > adj2)\n        d = distance(q, vec2(min(q.x, r1),0.))-r2;\n    else\n        d = r3 - distance(q2, vec2(hyp2, 0.));\n\n    return max(d, r4 - length(q));\n}\n\nfloat sprocketDistance(vec3 p, float r, float n, float rotation)\n{\n    float profile = sprocketProfile(p.xy, r, .01 / 1., .25 * .16 / 1.5, .05, n, rotation);\n    vec2 q = vec2(profile, abs(p.z) - .012);\n    return min(max(q.x, q.y), 0.) + length(max(q, 0.)) - .005;\n}\n\n\nfloat chainDistance(vec3 p, float r0, float r1, float s,\n        float chain_pos, float relative_offset, float scale, float hscale, float a, float pitch)\n{\n    float ri = r1 - r0;\n    float d = 1e5;\n\n    p.x += s / 2.;\n\n    vec3 pa = vec3(cos(a + pi / 2.), sin(a + pi / 2.), 0) * r0;\n    vec3 pb = vec3(s, 0, 0) + vec3(cos(a + pi / 2.), sin(a + pi / 2.), 0) * r1;\n\n    vec2 pa2 = pb.xy * vec2(1, -1), pb2 = pa.xy * vec2(1, -1);\n\n    float l1 = 2. * r0 * (pi / 2. - a);\n    float l2 = 2. * r1 * (pi / 2. + a);\n    float l3 = sqrt(s * s - ri * ri);\n    float chain_length = l1 + l2 + l3 * 2.;\n\n    chain_pos += pitch * relative_offset;\n\n    float chain_p0 = 0., chain_p1 = chain_p0 + l1, chain_p2 = chain_p1 + l3;\n    float chain_p3 = chain_p2 + l2;\n\n    int i;\n\n    // Chain section around first sprocket\n    i = int((l1 - mod(chain_pos, pitch)) / pitch) - 1;    \n    if(i > 0)\n    {\n        float at = mod(chain_pos, pitch) / r0;\n        vec2 q = radialRepeat(p.xy * vec2(1, -1), pi / 2. + a + at, pitch / r0, i) - vec2(r0, 0);\n        d = min(d, linkDistance(vec3(q.yx, p.z), pitch * scale, hscale));\n    }\n\n\n    // Chain section around second sprocket\n    i = int((l2 - mod(chain_pos - chain_p2, pitch)) / pitch) - 1;\n    if(i > 0)\n    {\n        float at = mod(chain_pos - chain_p2, pitch) / r1;\n        vec2 q = radialRepeat(vec2(p.x - s, -p.y), at - pi / 2. - a, pitch / r1, i) - vec2(r1, 0);\n        d = min(d, linkDistance(vec3(q.yx, p.z), pitch * scale, hscale));\n    }\n\n    vec2 v, p2, q;\n    float at, n, t;\n    mat2 m;\n\n    // Upper straight chain section\n    v = normalize(pb.xy - pa.xy);\n    at = mod(chain_pos - chain_p1, pitch);\n    n = floor((l3 - at) / pitch);\n    p2 = p.xy - v * (at - pitch / 2.);\n    t = (clamp(floor(dot(p2 - pa.xy, v) / pitch), 0., n) + .5) * pitch;\n    m = mat2(v.xy, v.yx * vec2(1, -1));\n    d = min(d, linkDistance(vec3(m * (p2 - pa.xy - v * t).xy, p.z), pitch * scale, hscale));\n\n    // Lower straight chain section\n    v = normalize(pb2 - pa2);\n    at = mod(chain_pos - chain_p3, pitch);\n    n = floor((l3 - at) / pitch);\n    p2 = p.xy - v * (at - pitch / 2.);\n    t = (clamp(floor(dot(p2 - pa2, v) / pitch), 0., n) + .5) * pitch;\n    q = pa2 + v * t;\n    m = mat2(v.xy, v.yx * vec2(1, -1));\n    d = min(d, linkDistance(vec3(m * (p2 - q).xy, p.z), pitch * scale, hscale));\n    \n    return d;\n}\n\nfloat configCycleTime()\n{\n    return mod(iTime / 5. + .1, 4.);\n}\n\nfloat sceneDistance(vec3 p)\n{    \n    float t = floor(configCycleTime());\n    float[5] config;\n\n    if(t < 1.)\n        config = config0;\n    else if(t < 2.)\n        config = config1;\n    else if(t < 3.)\n        config = config2;\n    else\n        config = config3;\n    \n    float nteeth0 = config[0];\n    float nteeth1 = config[1];\n    float pitch = config[2];\n    float N = config[3];\n    float a = config[4];\n    \n    float r0 = pitch * nteeth0 / (2. * pi);\n    float r1 = pitch * nteeth1 / (2. * pi);\n    float ri = r1 - r0;\n    float chain_length = N * pitch;\n    float s = ri / sin(a);\n\n    float chain_pos = iTime / 3.;\n\n    float sprocket0_rotation = chain_pos / r0 + a;\n    float sprocket1_rotation = (chain_pos - 2. * r0 * (pi / 2. - a) - sqrt(s * s - ri * ri)) / r1 + pi / 2. - a;\n\n    float chain0 = chainDistance(p, r0, r1, s, chain_pos, 0., .35, 1., a, pitch);\n    float chain1 = chainDistance(p, r0, r1, s, chain_pos, .5, .35, 1.5, a, pitch);\n    \n    float sprocket0 = sprocketDistance(p + vec3(s / 2., 0, 0), r0 + .01, nteeth0 * 2., sprocket0_rotation);\n    float sprocket1 = sprocketDistance(p - vec3(s / 2., 0, 0), r1 + .01, nteeth1 * 2., sprocket1_rotation);\n    \n    return min(min(sprocket0, sprocket1), min(chain0, chain1));\n}\n\nvec3 grad(vec3 p)\n{\n    vec3 e = vec3(1e-3, 0, 0);\n    return vec3(sceneDistance(p + e.xyy), sceneDistance(p + e.yxy), sceneDistance(p + e.yyx)) -\n                sceneDistance(p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y * 2.;\n    \n    // Ray setup and camera\n    vec3 ro = vec3(0, 0, 1.5), rd = normalize(vec3(uv, -1.6));\n\n    float crz = (iMouse.x - iResolution.x / 2.) / iResolution.x * pi;\n    float crx = (iMouse.y - iResolution.y / 2.) / iResolution.y * pi;\n    \n    mat3 m = mat3(cos(crz), 0., sin(crz), 0., 1., 0., -sin(crz), 0., cos(crz)) *\n             mat3(1., 0., 0., 0., cos(crx), sin(crx), 0., -sin(crx), cos(crx));\n\n    if(iMouse.z > 0.)\n    {\n        ro = m * ro;\n        rd = m * rd;\n    }\n    \n    vec3 col = vec3(.1);\n    float maxt = 4.;\n\n    // SDF raymarch\n    float t = 0.;\n    for(int i = 0; i < 256; ++i)\n    {\n        vec3 rp = ro + rd * t;\n        float d = sceneDistance(rp);\n        if(abs(d) < 1e-5 || t > maxt)\n            break;\n        t += d;\n    }\n    \n    if(t < maxt)\n    {\n        // Shading\n        vec3 n = normalize(grad(ro + rd * t));\n        vec3 r = reflect(rd, n);\n\n        float t = fract(configCycleTime());\n        float w = .1;\n        float a = smoothstep(0., w, t) - smoothstep(1. - w, 1., t);\n\n        col = mix(col, pow(textureLod(iChannel0, r, 6.).rgb, vec3(2)) * 1.3, a);\n    }\n    \n    fragColor = vec4(sqrt(col), 1.0);\n}","name":"Image","description":"","type":"image"}]}