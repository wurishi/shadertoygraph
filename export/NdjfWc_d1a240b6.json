{"ver":"0.1","info":{"id":"NdjfWc","date":"1647269784","viewed":285,"name":"EdgeDetection Sobel Operator","username":"raja_k","description":"Here I used the Edge Detection algorithm to filter the Image (Texture) from ichannel0\nReferences:\nhttps://www.youtube.com/watch?v=am36dePheDc\nhttps://www.youtube.com/watch?v=lOEBsQodtEQ&t=11s\nhttps://www.youtube.com/watch?v=fhDBy-wV3ic&t=9s\n","likes":2,"published":1,"flags":0,"usePreview":1,"tags":["sobel","filter","edgedetection","convolution"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//The following is a fragment shader, we know It is executes for every pixel on the screen, \n//so in the voidImage(), argument fragCoord has the co-ordinates at the given instance.\n\n\n//Taking the sobel edge for the convolution opeartion 3x3 filter(Kernel).\n// X = [ -1,  0,  +1]   Y = [ 1,  2,  1]\n//     [ -2,  0,  +2]       [ 0,  0,  0]\n//     [ -1,  0,  +1]       [-1, -2, -1]\n\n// Output = [topleft   , top   , topright]\n//          [left      ,       ,    right]  \n//          [bottomleft, bottom, bottomright]\n\n\n\n//References:\n//https://gamedevelopment.tutsplus.com/tutorials/a-beginners-guide-to-coding-graphics-shaders--cms-23313\n//https://www.youtube.com/watch?v=am36dePheDc\n//https://www.youtube.com/watch?v=lOEBsQodtEQ&t=11s\n//https://www.youtube.com/watch?v=fhDBy-wV3ic&t=9s\n//https://en.wikipedia.org/wiki/Sobel_operator\n\n\n//Pro-tip - Below the editor you find an iChannel0, From there you can even select any random texture.\n\n\n\nfloat intensity(in vec4 incolor){\n\treturn sqrt((incolor.x*incolor.x)+(incolor.y*incolor.y)+(incolor.z*incolor.z));\n}\n\nvec3 sobel_edge_detect(float x, float y, vec2 mainPixel) {\n    float tleft  = intensity(texture(iChannel0, mainPixel + vec2(-x, y)) );\n    float left   = intensity(texture(iChannel0, mainPixel + vec2(-x, 0)) );\n    float bleft  = intensity(texture(iChannel0, mainPixel + vec2(-x,-y)) );\n    float top    = intensity(texture(iChannel0, mainPixel + vec2( 0, y)) );\n    float bottom = intensity(texture(iChannel0, mainPixel + vec2( 0,-y)) );\n    float tright = intensity(texture(iChannel0, mainPixel + vec2( x, y)) );\n    float right  = intensity(texture(iChannel0, mainPixel + vec2( x, 0)) );\n    float bright = intensity(texture(iChannel0, mainPixel + vec2( x,-y)) );\n    \n    float gx = tleft  + 2.0*left + bleft - tright - 2.0*right - bright;\n    float gy = -left  - 2.0*top - tright + bleft + 2.0*bottom + bright;\n    \n    float color = sqrt( (gx*gx) + (gy*gy) );\n    return vec3(color, color, color);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float step = 1.0;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy; //So, now the whole screen is a unit square having left bottom as Origin.\n    \n    //In the bottom of the editor we have channel to select, we can select any and change the passing argument.\n    vec4 textureColor = texture(iChannel0, uv.xy);\n    \n    //so for each and evey pixel to be colored on the screen I'm sending the co-ordinates.\n    //Here iResolution is used for the dynamic nature of the screen size, even you do full screen there is no deformation.\n    vec3 col = sobel_edge_detect( step/iResolution[0], step/iResolution[1], uv); //Normalizing the values to 0-1 by using the step.\n    \n    // Output to screen\n    //The last co-ordinate is the alpha channel\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}