{"ver":"0.1","info":{"id":"ss23Dm","date":"1617988824","viewed":41,"name":"World in a bauble","username":"Tezza48","description":"Something i did a while ago and now converting it to webgl.\n\n- Written a while ago and just made public!","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["bauble"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_DIST 5.0\n#define PI 3.1415927\n// Ease the components of a normalized genType using a cosine function.\n#define cosEase(a) (1.0 - cos(a * PI)) / 2.0\n\n#define lightDirection normalize(vec3(cos(iTime), -3.0, -sin(iTime)))\n#define lightColor vec3(1.0, 1.0, 0.7)\n#define ambientColor vec3(0.3, 0.5, 0.9) * 0.3\n\n// From https://www.shadertoy.com/view/4djSRW\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Generate value noise from a vec3. TODO WT: Sample the noise texture for random numbers\nfloat valueNoise31(vec3 p)\n{\n\tvec3 lerpFactor = fract(p - 0.5);\n\n\tfloat\tc000, c100,\n\t\t\tc010, c110,\n\t\t\tc001, c101,\n\t\t\tc011, c111;\n\n\t// TODO: Figure a way to remove these branches (slower than it could be)\n\tif (lerpFactor.x >= 0.5) // use this cellPos and one to the right\n\t{\n\t\tp.x -= 1.0;\n\t}\n\tif (lerpFactor.y >= 0.5)\n\t{\n\t\tp.y -= 1.0;\n\t}\n\tif (lerpFactor.z >= 0.5)\n\t{\n\t\tp.z -= 1.0;\n\t}\n\n\tlerpFactor = cosEase(lerpFactor);\n\n\t// front plane\n\t// bottom line\n\tc000 = hash13(floor((p + vec3(0, 0, 0))));\n\tc100 = hash13(floor((p + vec3(1, 0, 0))));\n\n\tfloat fbottom = mix(c000, c100, lerpFactor.x);\n\n\t// top line\n\tc010 = hash13(floor((p + vec3(0, 1, 0))));\n\tc110 = hash13(floor((p + vec3(1, 1, 0))));\n\t\n\tfloat ftop = mix(c010, c110, lerpFactor.x);\n\n\tfloat front = mix(fbottom, ftop, lerpFactor.y);\n\n\t// back plane\n\t// bottom line\n\tc001 = hash13(floor((p + vec3(0, 0, 1))));\n\tc101 = hash13(floor((p + vec3(1, 0, 1))));\n\n\tfloat bbottom = mix(c001, c101, lerpFactor.x);\n\n\t// top line\n\tc011 = hash13(floor((p + vec3(0, 1, 1))));\n\tc111 = hash13(floor((p + vec3(1, 1, 1))));\n\t\n\tfloat btop = mix(c011, c111, lerpFactor.x);\n\n\tfloat back = mix(bbottom, btop, lerpFactor.y);\n\n\treturn mix(front, back, lerpFactor.z);\n}\n\n// Generate fractal value noise from a vec3.\nfloat fractalValueNoise31(vec3 p)\n{\n\tfloat value = 0.0;\n\tfloat amp = 0.5;\n\n\tfor (int i = 0, l = 2; i < l; i++)\n\t{\n\t\tvalue += valueNoise31(p) * amp;\n\t\tamp *= 0.5;\n\t\tp *= 2.0;\n\t}\n\n\treturn value;\n}\n\nfloat sdf(vec3 p) { // Distance to surface\n    float sphere = length(p) - 1.5;\n\tfloat vol = fractalValueNoise31(p + iTime * 0.1) - 0.35;\n    \n    float noiseInSphere = max(sphere, vol);\n    return noiseInSphere;\n}\n\n#define f sdf\nvec3 calcNormal( in vec3 p ) // for function f(p)\n{\n    const float eps = 0.0001; // or some other value\n    const vec2 h = vec2(eps,0);\n    return normalize( vec3(f(p+h.xyy) - f(p-h.xyy),\n                           f(p+h.yxy) - f(p-h.yxy),\n                           f(p+h.yyx) - f(p-h.yyx) ) );\n}\n\nvec2 march(vec3 ro, vec3 rd) {\n    float trace = 0.001;\n    int steps = 0;\n    float closest = MAX_DIST;\n    for(; steps < 512; steps++) {\n        if (trace < 0.001 || trace > MAX_DIST) break;\n        \n        vec3 p = ro + rd * trace;\n        float dist = sdf(p);\n        closest = min(dist, closest);\n        \n        trace += dist;\n    }\n    \n    return vec2(trace, closest);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    \n    vec3 eyePos = vec3(0.0, 0.0, -2.5);\n    vec3 eyeDir = normalize(vec3(uv, 1.0));\n    \n    //fragColor = vec4(hash13(eyePos + eyeDir * iTime * 0.01));\n    //return;\n    \n    vec2 traceResult = march(eyePos, eyeDir);\n    float dist = traceResult.x;\n    \n    if (dist - MAX_DIST > 0.0) {\n        fragColor = vec4(0.5, 0.5, 0.5, 1.0);\n        return;\n    }\n    \n    vec3 hitPos = eyePos + eyeDir * dist;\n    vec3 normal = calcNormal(hitPos);\n    vec3 toLight = -lightDirection;\n    vec3 toEye = -eyeDir;\n    \n    vec3 col = ambientColor;\n    \n    // trace to light dir\n    float toLightDist = march(hitPos, toLight).x;\n    if (toLightDist - MAX_DIST < 0.0 && false) {\n        fragColor = vec4(0);\n    } else {\n        vec3 halfAngle = normalize(toLight + toEye);\n        float blinn = dot(halfAngle, normal);\n\n\n\n        col += vec3(dot(normal, toLight) * lightColor);\n    }\n    \n    \n    //col = vec3(traceResult.x / MAX_DIST);\n    \n    //vec3 col = vec3(uv, 0);\n    \n    \n    \n    //col = eyeDir;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}