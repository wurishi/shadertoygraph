{"ver":"0.1","info":{"id":"Mcy3Ry","date":"1712938900","viewed":35,"name":"Rippling Neon Lake colors v2","username":"FatLenny","description":"Messing around with random noise generation","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fractal","basic","tutorial","rainbow","commented"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Rippling Neon Lake rand\" by FatLenny. https://shadertoy.com/view/lcy3RG\n// 2024-04-12 08:18:38\n\n// Fork of \"Rippling Neon Lake\" by FatLenny. https://shadertoy.com/view/lfyGRG\n// 2024-04-12 03:25:52\n\n// Fork of \"Rippling Glow\" by FatLenny. https://shadertoy.com/view/Mc3Gz4\n// 2024-04-12 02:11:00\n\n// Fork of \"Circular Bing Bong\" by FatLenny. https://shadertoy.com/view/Mcc3R4\n// 2024-03-26 07:15:28\n\n// Fork of \"4th eye blind\" by None. https://shadertoy.com/view/-1\n// 2024-03-26 07:15:07\n\n// Fork of \"4th eye blind\" by FatLenny. https://shadertoy.com/view/Mf3GR4\n// 2024-03-26 06:28:26\n\n// Fork of \"Intro Tutorial Pastel Glitter\" by FatLenny. https://shadertoy.com/view/Xfc3zN\n// 2024-03-26 06:26:26\n\n// Fork of \"Intro Tutorial Mega Commented\" by FatLenny. https://shadertoy.com/view/Xc33z4\n// 2024-03-26 06:06:28\n\n// 0: integer hash\n// 1: float hash (aliasing based)\n#define METHOD 0\n\n// 0: cubic\n// 1: quintic\n#define INTERPOLANT 1\n\n\n#if METHOD==0\nvec3 hash( ivec3 p )     // this hash is not production ready, please\n{                        // replace this by something better\n\tivec3 n = ivec3( p.x*127 + p.y*311 + p.z*74,\n                     p.x*269 + p.y*183 + p.z*246,\n                     p.x*113 + p.y*271 + p.z*124);\n\n\t// 1D hash by Hugo Elias\n\tn = (n << 13) ^ n;\n    n = n * (n * n * 15731 + 789221) + 1376312589;\n    return -1.0+2.0*vec3( n & ivec3(0x0fffffff))/float(0x0fffffff);\n}\n#else\nvec3 hash( vec3 p )      // this hash is not production ready, please\n{                        // replace this by something better\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n#endif\n\n\n// return value noise (in x) and its derivatives (in yzw)\nvec4 noised( in vec3 x )\n{\n    // grid\n    #if METHOD==0\n    ivec3 i = ivec3(floor(x));\n    #else\n    vec3 i = floor(x);\n    #endif\n    vec3 f = fract(x);\n    \n    #if INTERPOLANT==1\n    // quintic interpolant\n    vec3 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec3 du = 30.0*f*f*(f*(f-2.0)+1.0);\n    #else\n    // cubic interpolant\n    vec3 u = f*f*(3.0-2.0*f);\n    vec3 du = 6.0*f*(1.0-f);\n    #endif    \n    \n    // gradients\n    #if METHOD==0\n    vec3 ga = hash( i+ivec3(0,0,0) );\n    vec3 gb = hash( i+ivec3(1,0,0) );\n    vec3 gc = hash( i+ivec3(0,1,0) );\n    vec3 gd = hash( i+ivec3(1,1,0) );\n    vec3 ge = hash( i+ivec3(0,0,1) );\n\tvec3 gf = hash( i+ivec3(1,0,1) );\n    vec3 gg = hash( i+ivec3(0,1,1) );\n    vec3 gh = hash( i+ivec3(1,1,1) );\n    #else\n    vec3 ga = hash( i+vec3(0.0,0.0,0.0) );\n    vec3 gb = hash( i+vec3(1.0,0.0,0.0) );\n    vec3 gc = hash( i+vec3(0.0,1.0,0.0) );\n    vec3 gd = hash( i+vec3(1.0,1.0,0.0) );\n    vec3 ge = hash( i+vec3(0.0,0.0,1.0) );\n\tvec3 gf = hash( i+vec3(1.0,0.0,1.0) );\n    vec3 gg = hash( i+vec3(0.0,1.0,1.0) );\n    vec3 gh = hash( i+vec3(1.0,1.0,1.0) );\n    #endif\n    \n    // projections\n    float va = dot( ga, f-vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, f-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, f-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, f-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, f-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, f-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, f-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, f-vec3(1.0,1.0,1.0) );\n\t\n    // interpolations\n    return vec4( va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z,    // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.z*(ge-ga) + u.x*u.y*(ga-gb-gc+gd) + u.y*u.z*(ga-gc-ge+gg) + u.z*u.x*(ga-gb-ge+gf) + (-ga+gb+gc-gd+ge-gf-gg+gh)*u.x*u.y*u.z +   // derivatives\n                 du * (vec3(vb,vc,ve) - va + u.yzx*vec3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + u.zxy*vec3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh) ));\n}\n\n\n//RNG\n\n//END RNG\n\n\n// NOISE\n\n\n\n// GRADIENTS    \nvec3 palette( float t ) {\n\n    /*\n    [[0.608 0.698 0.500] [2.068 -0.582 0.500] [-0.072 -0.782 1.000] [0.000 0.408 0.667]]\n    */\n\n    vec3 a = vec3(0.608, 0.698, 0.5);//DEFAULT\n    //vec3 a = vec3(1.000,1.000,1.000);//MORE PASTEL AND BRIGHTER\n    vec3 b = vec3(1.068, -0.582, 0.5);//DEFAULT\n    //vec3 c = vec3(-0.072, -0.782, 1.0);//DEFAULT\n    vec3 c = vec3(-0.072, -1.0, 1.0);//SOFTER GRADIENT MORE PASTEL\n    vec3 d = vec3(0.000,0.275,0.008);//DEFAULT\n\n    return a + b*cos( 6.28318*(c*t+d) );\n\n        // This funnction takes 3 vec3 inputs, totaling 12 paramaters to create CUSTOM GRADIENTS\n\n        // Site explaining the function: \n        // https://iquilezles.org/articles/palettes/ \n\n        // Tool to create gradients:\n        // http://dev.thi.ng/gradients/\n\n        // We can replace set *col* to the palette() function to get dynamic colors instead of static \n        // It can take the distance from the center of the canvas *d* as a parameter (among other things)\n        // We just modify a, b, c and d within the function to specify the gradient\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n        // fragColor holds RGB and Aplpha values\n        // fragCoord holds the coordinates of every pixel,\n        // the default minimum being 1 and the maximum being the max size of the canvas\n        // eg. with a 640 by 480 canvas fragCoord.x is anywhee from 1 to 640\n        // each shader is defined inside of mainImage function\n\n    /*\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0; \n    */\n        // uv contains transformed pixel coords normalizd by dividing\n        // fragCoord by a vector containing the current canvas size.\n        \n        // the current canvas size in pixels (x = width, y = height z = depth) \n        // z which is only used when rendering to 3d textures.\n        \n        // iResolution.xy syntax isolates x and y components and assigning assigning them to a new vec2\n        \n        // It's possible to reverse the coords by using iResolution.yx (this is called SWIZZLING)\n        // resulting in a vec2(iResolution.y, iResolution.x) where x vecomes y and vice-versa \n        \n        // This can also be used as a shortcut when performing operation between vectors that have the same number\n        // of components, applying the same operation to every corresponding component of the vectors\n            \n        // Example - \n        // 'vec2 v1,v2;'\n        // 'v1 / v2' results in 'vec2(v1.x/v2.x, v1.y/v2.y)'\n        // *or*\n        // 'v1 - 0.5' results in 'vec2(v1.x-0.5, v1.y-0,5x)'\n        \n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n        // this multiplies the real pixel size of the canvas by 2, then subtracts the real pixel size so the \n        // center is at coordinate 0, then divides by the y resolution to keep a consistent aspect ratio for \n        // our effect despite the aspect ratio of the canvas\n        \n        \n    // USING FRACT() TO REPEAT OR TILE OUR SHADER\n    \n    /*\n    uv = fract(uv);\n    */\n        // by default, fract() extracts the digits after the decimal point in the passed arument (in our case *uv*)\n        // resultin in it never returning a number greater than 1 cinse when the decimals go past 0.99 it resets to 0.01\n        // this means we need to apply transformations to center the pattern like we did before when correcting for aspect ratio\n        // in other words, each repetition is confined to the 0.0-1.0 range instead of our clip space\n    \n    // FIXING OR MODIFYING TILING\n    \n    /*\n    uv *= 1.0;\n    */\n        // like before we scale the UVs by 2 \n        // this step IS NOT NECESSARY but it can be very useful for resizing things\n    \n    /*\n    uv = fract(uv);\n    */\n        // then we apply the fract() tiling\n    \n    /*\n    uv -= 0.5;\n    */\n        // finally we subtract 0.5 to recenter our pattern\n        \n    vec2 uv0 = uv; // *uv0* is the GLOBAL center of the canvas\n        // here we are storing the UVs of the center of the canvas\n        // before modifying the for the purpose of tiling\n        // allowing us modify the colors independently from the tiled patterns\n        // to do this, instead of using *d* as the argument when we call palette eg. palette(d)\n        // we use *length(uv0) eg. palette(length(uv0))\n        // resulting in the color changes originating from the center of the canvas rather than from the \n        // center of each tile\n        // we are currently ONLY using *uv0* for COLORS\n        \n    vec3 finalColor = vec3(0.0);\n        // here we create a new vec3 initialized as all black\n        // this will be used later to bring everything together and make it possible to do many more things\n        // now instead of updating *col* directly, we will add the result of the operation \n        // performed on *col* to the new *finalColor* variable\n        \n    //float c = 1.5;    \n    \n\nfor(float i = 0.0; i < 1.5; i++){ \n// by putting ALL of ouut color calculation code inside of a for loop\n// we can iterate on our pattern to begin creating fractals and much more\n    \n    \n    vec3 uvNoise = vec3(uv,0.0);                            //This multiplication is modifying the noise density\n    vec4 fullNoise = noised(uvNoise+iTime*0.005+(iTime*0.05))*2.0;//adding iTime to the input of noise makes it change over time\n    //uvNoise = fullNoise.yzw*rand;//implementing random noise generation\n    uvNoise = fullNoise.yzw;\n    //c += i*10.0;\n    //uv = (fract(uv * 1.2) - 0.5);ORIGINAL\n    //uv = (uv- 0.5);//VERY COOL\n    //uv = uv*uvNoise.yz-(0.5)*cos(i);//VERY COOL A LITTLE COPMPLEX\n    //uv = (uv*uvNoise.yz)*tan(tan(iTime)/5.);//HOLY SHIT\n    uv = ((uv*uvNoise.yz));\n        // this combines the previous 3 lines of code into one expression\n        // after applying this *d* now represents the distance \n        // relative to the center of EACH REPETITION\n        // no we need to create a new vec2 so we can still keep track of the \n        // distance to the CENTER of the CANVAS like we were before\n    \n\n\n\n    //float d = length(uv);\n\n        // *length* - takes a vector as input and calculates the magnitude of that vector \n        // (the distance between the vector and the origin)\n        // Since we have entered the origin we can use this to calculate the distance between\n        // any given pizel and the center of the screen by passing in our 'uv' vector\n    \n    \n    float d = length(uv) * exp(-length(uv)+(0.15+(i/3.5))); // THIS CHANGES THINGS BASED ON THE DISTANCE TO THE CENTER OF THE CANVAS \n        // MULTIPLYING *d* (the local distance to the center of each repetetiton)\n        // by an EXPONENTIAL FUNCTION depending on the GLOBAL distance to the center of the canvas \n        // (uv0 is the global center of the canvas)\n        // resource thet graphs glsl functions to maybe begin to unedrstand this:\n        // https://graphtoy.com/\n        // part of the tuutorial explaining this:\n        // https://youtu.be/f4s1h2YETNY?t=1213\n        \n    // INTRODUCING COLOR\n    /*\n    vec3 col = vec3(1.0, 0.0, 0.0); // this is a new vec 3 containing the color red\n    */\n        // to introduce color we need to make a new vec3 containing the color we want to use\n        // we can then use this new *col* variable to modify *d* or other things\n        \n    /*           \n    vec3 col = vec3(1.0, 2.0, 3.0);\n    */\n        // the RGB values in *col* are ratios thus,\n        // we can use numbers GREATER than 1.0 to get very VIBRANT colors\n        // higher values = more intense colors\n        \n    /*\n    vec3 col = palette(d);\n    */\n        // implements the palette function to create color gradients in our shader\n        // this makes the color changes originate from the center of each tile\n     \n    /*\n    vec3 col = palette(length(uv0) + iTime);\n    */\n        // this instead retains the color changes origination from the center of the canvas while \n        // still keeping the tiling pattern\n        // we can then add an iTime offset to in the input of palette() to make the colors change as iTime changes    \n\n    vec3 col = palette(length(uv0) + i*5.6 + iTime*0.1);\n        // rducing frequency of time offset ca make overly complicated or overwhelming visuals much more pleasing\n        // just multiply *iTime* by a decimal (iTime*0.4)\n        // adding *i* into the palette() function will dynamically change the colors based on ho it is implemented\n        // for this one I added 'i*0.4'\n\n    /*    \n    d -= 0.5;\n    */\n        // subtracts 0.5 from distance so now our fragColor values are using a distance 0.5 units closer \n        // to the origin, now fragColor will reach a value of 1 farther away from the origin than before\n        \n        // this leads into what a Sign Distance function is, thich is actually what is represented here\n        // we can think of the value of fragColor as the distance away from a circle with a radius of 0.5 units\n        // an SDF is a function that takes a position in space as input and returns the distance of that\n        // position from the boundary of a goven shape, \n        // with positive values being ouside of the shape and negative values being inside of the shape\n        // values at the boundary of the shape are exactly zero\n        \n        // there are SDFs for MANY shapes and a lot of 2D SDFs can be found at:\n        // https://iquilezles.org/articles/distfunctions2d/ \n        // (also has info and many tutorials about shader coding\n    /*    \n    d = sin(d * 8.0);\n    */\n        // we can apply functions to d that make its value change to create more interesting patterns\n        // such as the sin function here which increases and decreases d based on multiplying it by a frequency\n        // where higher frequencies create more oscillations\n    /*    \n    d = sin(d * 8.0)/8.0; \n    */\n        // simply increasing the frequency to 8 however will affect the abruptness of the transition\n        // to fiz this all we have to do is divide the output of the sin function by the same factor (8 in this case)\n        \n    d = sin(d *8.8 + iTime*0.4)/8.0;         \n        // we can take advantage of the repetetive nature of the sin function!\n        // *iTime* is a component we can introduce and offset the distance by iTime to create rings that\n        // continually shring towards the center as iTime is changing\n        \n        // iTime is a global constant that represents the number of seconds that have passed since\n        // the beginning of the animation\n        \n    d = abs(d);\n        // abs() returns the absolute values of d (turning negative values into positiove ones\n    /*    \n    d = step(0.1, d);\n    */\n        // step() can be used for more abrupt transitions of color \n        // step(threshold, value) accepts 2 inputs. Its output can only have 2 states, \n        // it returns 0.0 when the value is less than the threshold and 1.0 when it is greater\n        // in this implementation all values less than 0.1 will be black, greater than 0.1 will be white\n    /*\n    d = smoothstep(0.0, 0.1, d);\n    */\n        // smoothstep() can be used for a more gradual transition\n        // smoothstep(lowthreshold, highthreshold, value)\n        // this assigns black when value is below the first threshold and white when it is above the second\n        // but creates a gradient for values inbetween the two thresholds\n        // closer thresholds mean more abrupt transitions\n    /*    \n    d = 1.0 / d;\n    */\n        // using the inverse function 1/x to create more vibrant colors that seem to glow\n        // instead of calculating the final color using smoothstep()\n        // we can take the inverse of d, which initially makes the screen entirely white\n        // this is because low input values now create extremely high output values\n        // and as the input values increase the output gradually decreases, \n        // but since we are using clip space and now or output never goes below 1 we see only white\n    \n    /*\n    d = 0.02 / d;\n    */\n        // this happens because when taking the inverse of any positive number less than 1 we always get\n        // a number greater than 1\n        // to resolve this we simply scale down the inverse function so that the falloff is within 0 to 1\n        // the more we scale it down, the more vibrant the rings become\n        \n   \n    \n    // POWER FUNCTION\n          //d = pow(0.003 / d, 0.2);//BRIGHT\n          d = pow(0.002 / d, 0.4);//NORMAL NICE\n          //d = pow(0.005 / d, 2.5);//FULL DARK\n    \n        // when the input ranged from 0.0 to 1.0, the pow() function accentuates the darker colors closer to 0.0\n        // while having a lesser effect on the lighter colors\n        // the power of 2.0 (second arg in pow function) has very pronounced effects but\n        // values lower than 2 can enchance the contrast in a less extreme way \n        // creating a more pleasing and impactful visualization\n        // negative values do the opposite, accentuating bright colors\n        \n    /*    \n    col *= d;\n    */\n        // Here we are multiplying our red *col* by *d*\n        // this means that the distance *d* will only affect the red channel, leaving the black parts black\n        // since col has 3 values representing RGB (1.0, 0.0, 0.0) only the red value will be modified by d \n        // because 0.0 times any number is still zero (or black in our case)\n    \n    finalColor += col * d;\n        // since we created *finalColor* we no longer need to edit *col* directly like we did above\n        // now we add the result of the operation we performed on *col* making sure to remove the = sign\n        // and since we initialized *finalColor* as all black, adding 'col * d' to it will essentially\n        // make it equal to what we added to it\n    \n}// termination of for loop added at the very end    \n    \n    \n    /*\n    fragColor = vec4(col, 1.0);\n    */\n    // since *col* contains 3 values we can just pass it once to *fragColor* as long as we still define the alpha\n    \n    fragColor = vec4(finalColor, 1.0);\n    // now instead of passing *col* as we did above, we just pass *finalColor* instead\n    \n    // NOW WE CAN ADD ITERATIONS TO OUR CODE!!!\n    // it becomes possible to use loops and all kinds of other operations to open up an infinite\n    // number of NEW POSSIBILITIES!\n    \n    /*\n    fragColor = vec4(d, d, d, 1.0)  // This is from before we modified the colors\n    */\n        // since 'dst' now represents the distance of each pixel from the origin of the canvas\n        // and we put it in the red channel\n        // the farther away the pixel is from the center the more red it is until it reaches\n        // a distance of 1.0 away, meaning it will be fully red\n        // but notice that the gradient circle is streatched since the distance from every side is 1\n        // we can fix this!    \n    \n    /*    \n    uv.x *= iResolution.x / iResolution.y;\n    */\n        // This multiplies the x valu of out UVs by the current aspect ratio of the canvas (width / height)\n        // This assures that our effect does not get distorted no matter the aspect ration of the canvas\n        // we can now integrate this into our initial definition of UV to further simplify\n    \n    /*\n    uv = uv-0.5; \n    */\n        // this makes 1.o the center of our coordinates so we can better interact with the \n        // exact middle of the canvas but a problem arises where\n        // the far left is now -.05 and the far right is 0.5\n    \n    /*\n    uv = uv*2.0;\n    */\n        // This returns the center to being 0.0 like the center of a graph\n        // with the far left being -1.0 and the far right being 1.0\n        // making sure the values of all the pixels on the canvas remain in the clip space\n        // we defined earlier on line 3\n        \n    /*\n    uv = (uv-0.5)*2.0);\n    */\n        //is a simplified version combining lines 26 and 32\n        \n    /*  \n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n    */\n        // combines line 38 and line 5 to accomplish this all in one line of code\n        // because it condenses this all into one line of code\n        // by making the range of the clip space go from\n        // 0.0 to 2.0 then subrtracting 1 so it ends up as\n        // -1.0 to 1.0\n                                                  \n    /*    \n    fragColor = vec4(uv.x, uv.y, 0.0, 1.0); \n    */\n        // is run for every pixel (0.0=black, 1.0=white)\n        // uv.x starts at 0.0 (black) \n        // and ends at 1.0 (red at the the right)\n        // since it's in the red channel going in the x direction\n        // because the 'uv' vec2 we made earlier is being calculated \n        // pizel by pixel in the x direction, starting at the right\n        // and changing in increments until the left side ends up being 1.0\n        \n    /*     \n    fragColor = vec4(uv, 0.0, 1.0);        \n    */        \n        // is a simplified verison where we do not have to change \n        // x and y individually since our 'uv' variable contains both coordinates\n                   \n      \n        // fragCoord Depends on size of canvas (ie. 640x480 res. means fragCoord.x range is 0-640, y is 0-480)\n\n        // FragCoord = input paramater of type vec2 (a vector containing 2 values, the X and Y coordiate of current pixel)\n\n        // fragColor = output parameter of type vec4 (holds RGB and Alpha channels - Alpha has no effect in Shadertoy)\n\n        // When working with shaders, coordinates should be in clip space, meaning coords ange from 0 to 1\n        // so that they do not depend on the surrent resolution of the canvas\n        \n    /* \n    Inbuilt Functions:\n    \n        *length* - takes a vector as input and calculates the magnitude of that vector \n            (the distance between the vector and the origin)\n        Since we have entered the origin we can use this to calculate the distance between\n            any given pizel and the center of the screen by passing in our 'uv' vector\n        \n    */\n}   \n","name":"Image","description":"","type":"image"}]}