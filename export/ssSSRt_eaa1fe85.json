{"ver":"0.1","info":{"id":"ssSSRt","date":"1620771918","viewed":195,"name":"Walk Cycle","username":"msiddeek","description":"Walk cycle test. Feedback welcome!","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","sdf","animation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n\n    fragColor = texture(iChannel0, uv);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define SMAX true\n\n#define PI 3.14159265359\n#define rad(a) ((a) * PI / 180.)\nmat2 rot(float a) {\n    return mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\n#define PREC  .005\n#define PREC1 .010\n#define MAX_DIST 4.5\nvec4 min_hit(vec4 hit, float m, float d) {\n    return (d < hit.x ? vec4(d, m, 0., 0.) : hit);\n}\n\n\n// MATH\nfloat smin( float a, float b) {\n    if (!SMAX) return min(a, b);\n    float k = .005;\n    float h = clamp(.5 + .5 * (b - a) / k, .0, 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n#define smax(a, b) -smin(-a, -b)\nvec2 r22(vec2 v) {\n    return fract(sin(vec2(\n        v.x * 654.123 + v.y * 123.123,\n        v.x * 321.123 + v.y * 98.123)));\n}\n// SDF\nfloat sdPlane(vec3 p, vec4 n) {\n    return dot(p, normalize(n.xyz)) - n.w;\n}\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\nfloat sdCapsule(vec3 p, float h, float r) {\n    p.y -= clamp(p.y, 0.0, h);\n    return length(p) - r;\n}\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q, .0)) + min(max(q.x, max(q.y ,q.z)), .0);\n}\n// ANIMATION\nfloat time;\nfloat tf;\nint ti;\nint ph;\nconst vec4[] anim_data = vec4[] (\n    vec4(.09, .08, .09, .1), vec4(.09, .08, .09, .1), // pelvis\n    vec4(20., 20., 0., -10.), vec4(-15., 5., 15., 40.), // leg0\n    vec4(0., -20., 0., 0.), vec4(0., -40., -65., -70.), // leg1\n    vec4(-20., -10., 0., 10.), vec4(20., 10., 0., -10.), // arm0\n    vec4(10., 0., 0., .0), vec4(.0, 0., 0., 10.), // arm1\n    vec4(1., -2., -4., -3.), vec4(-1., 2., 4., 3.) // hip\n);\n#define anim_get(bone, sa, ti) anim_data[bone * 2 + (ti >= 4 ? 1 - sa : sa)][(ti) % 4]\nfloat anim(int bone, int s) {\n    int sa = (ph == 0 ? s : -s) >= 0 ? 0 : 1;\n    float a0 = anim_get(bone, sa, ti);\n    float a1 = anim_get(bone, sa, ti + 1);\n    return a0 + (a1 - a0) * tf;\n}\n\n// BODY\nfloat body(vec3 p) {\n    float d = MAX_DIST;\n    time = iTime * 4. * 1.5;\n    ti = int(time) % 4;\n    tf = time - floor(time);\n    ph = int(time / 4.) % 2;\n\n    // spine\n    float hipSwing = rad(anim(5, 1));\n\n    vec3 pPelvis = p + vec3(0., -.33 + anim(0, 1), 0.);\n    pPelvis.xy *= rot(rad(hipSwing));\n    vec3 pPelvis_temp = pPelvis;\n    pPelvis_temp.xy *= rot(PI / .4);\n    d = min(d, sdCapsule(pPelvis_temp - vec3(.0, -.04, .0), .08, .05));\n    \n    vec3 pWaist = pPelvis + vec3(0., -.06, -.02);\n    pWaist.xy *= rot(-hipSwing);\n    pWaist.yz *= rot(0.);\n    d = smin(d, sdSphere(pWaist - vec3(.0, .0, -.04), .1));\n\n    vec3 pNavel = pWaist + vec3(0., .05, .15);\n    d = smax(d, -sdSphere(pNavel, .025));\n\n    vec3 pChest = pWaist + vec3(0., -.1, .0);\n    pChest.yz *= rot(0.);\n    vec3 pChest_temp = pChest;\n    pChest_temp.xy *= rot(PI / .4);\n    d = smin(d, sdCapsule(pChest_temp - vec3(.0, -.06, .0), .12, .05));\n    \n    vec3 pNeck = pChest + vec3(0., -.04, 0.);\n    pNeck.yz *= rot(-.5 + anim(0, 1) * 5.);\n    d = smin(d, sdCapsule(pNeck - vec3(.0, .01, .0), .08, .02));\n    \n    vec3 pHead = pNeck + vec3(0., -0.1, 0.);\n    pHead.yz *= rot(1.);\n    d = smin(d, sdCapsule(pHead - vec3(.0, -.08, -.04), .08, .06));\n    \n    vec3 pEye = pHead;\n    pEye.x = abs(pEye.x);\n    d = smax(d, -sdSphere(pEye - vec3(.03, -.13, -.07), .025));\n    //d = min(d, sdSphere(pEye - vec3(.01, -.11, -.05), .025));\n    \n    // legs\n\n    vec3 pLeg0L = pPelvis + vec3(+.06, .025, .0);\n    pLeg0L.xy *= rot(-hipSwing);\n    pLeg0L.yz *= rot(rad(180. + anim(1, 1)));\n    d = smin(d, sdCapsule(pLeg0L, .1, .025));\n\n    vec3 pLeg1L = pLeg0L + vec3(+.005, -.1, .015);\n    pLeg1L.yz *= rot(rad(anim(2, 1)));\n    d = smin(d, sdCapsule(pLeg1L, .1, .015));\n\n    vec3 pLeg0R = pPelvis + vec3(-.06, .025, .0);\n    pLeg0R.xy *= rot(-hipSwing);\n    pLeg0R.yz *= rot(rad(180. + anim(1, -1)));\n    d = smin(d, sdCapsule(pLeg0R, .1, .025));\n\n    vec3 pLeg1R = pLeg0R + vec3(-.005, -.1, .015);\n    pLeg1R.yz *= rot(rad(anim(2, -1)));\n    d = smin(d, sdCapsule(pLeg1R, .1, .015));\n    \n    // arms\n\n    vec3 pArm0L = pChest + vec3(+.11, .0, .0);\n    pArm0L.yz *= rot(rad(180. + anim(3, 1)));\n    pArm0L.xy *= rot(rad(15.));\n    d = smin(d, sdCapsule(pArm0L, .08, .02));\n\n    vec3 pArm1L = pArm0L + vec3(0., -.1, -.01);\n    pArm1L.yz *= rot(rad(anim(4, 1)));\n    pArm1L.xy *= rot(rad(-20.));\n    d = smin(d, sdCapsule(pArm1L, .08, .01));\n\n    vec3 pArm0R = pChest + vec3(-.11, .0, .0);\n    pArm0R.yz *= rot(rad(180. + anim(3, -1)));\n    pArm0R.xy *= rot(rad(-15.));\n    d = smin(d, sdCapsule(pArm0R, .08, .02));\n\n    vec3 pArm1R = pArm0R + vec3(0., -.1, -.01);\n    pArm1R.yz *= rot(rad(anim(4, -1)));\n    pArm1R.xy *= rot(rad(20.));\n    d = smin(d, sdCapsule(pArm1R, .08, .01));\n\n\n    return d;\n}\n\n// SCENE\nvec4 map(vec3 p) {\n    vec4 hit = vec4(MAX_DIST, 0., 0., 0.);\n    // floor\n    hit = min_hit(\n        hit, .1,\n        sdSphere(p - vec3(0., -2., 0.), 2.));\n    // body\n    vec4 bound = min_hit(\n        hit, -.1,\n        sdCapsule(p - vec3(0., .18, 0.), .3, .18));\n    //hit = bound;\n    if (bound.y < .0) {\n        hit = min_hit(\n            hit, .2,\n            body(p));\n    }\n\n\treturn hit;\n}\n\n// MATERIALS\nvec3 color(float m, vec3 h) {\n    if (m < .1) {\n    \treturn vec3(1., 0., 1.);\n    } else if (m < .2) {\n    \treturn vec3(.6, .8, .3)\n            * pow(h.y + 1., 2.)\n            * (.6 - .1 * floor(fract(acos(h.z / 2.) * 8. + iTime * .6) * 2.)); // stripes\n    } else if (m < .3) {\n    \treturn vec3(1.0, 0.6, 0.9)\n            * min(1., .5 + h.y * h.y * 8.);\n    } else if (m < .4) {\n    \treturn vec3(0., 0., 1.);\n    }\n}\n\n// RAY MARCH\nvec4 march(vec3 ro, vec3 rd, float maxD) {\n    vec4 res;\n    float d = 0.;\n    float newD = PREC;\n    while (newD >= PREC && d < maxD) {\n        res = map(ro + rd * d);\n        newD = res.x;\n        d = min(maxD, d + newD);\n    }\n \treturn vec4(d, res.yzw);\n}\nvec3 normal(vec3 pos) {\n    vec3 eps = vec3(0.001, 0., 0.);\n\tvec3 nor = vec3(0.);\n\tfloat invert = 1.;\n\tfor (int i = 0; i < 6; i++) {\n\t\tnor += map(pos + eps * invert).x * eps * invert;\n\t\teps = eps.zxy;\n\t\tinvert *= -1.;\n\t}\n\treturn normalize(nor);\n}\nvec4 sky(vec3 rd) {\n    //float lights = max(0., sin(fract(atan(rd.z, rd.y + 1.) * 16. - iTime * .2) * PI * 2.));\n    rd.xz = rot(rad(40.)) * rd.xz;\n    vec4 grad = mix(vec4(.05), vec4(.7, .8, .9, 1.), clamp(-rd.z - .00, 0., 1.))\n             + mix(vec4(.05), vec4(.8, .6, .4, 1.), clamp(+rd.z - .25, 0., 1.));\n    return mix(vec4(1.), clamp(rd.y + .5, 0., 1.) * (grad), clamp(-rd.y + 1.35, 0., 1.));\n}\nfloat light(vec3 l, vec3 n, vec3 h, bool sh) {\n    vec3 lh = normalize(l - h);\n    float diff = dot(n, lh);\n    float shadow = 0.;\n    if (sh) shadow = 1. - march(h, lh, MAX_DIST).x / MAX_DIST;\n    return clamp(diff - shadow, 0., 1.);\n}\nvec4 render(vec3 ro, vec3 rd) {\n    vec4 m = march(ro, rd, MAX_DIST); \n    float hd = m.x;\n    vec3 h = ro + rd * (hd - PREC1);\n    vec3 n = normal(h);\n\n    vec4 col = vec4(0);\n    if (hd < MAX_DIST - PREC1) {\n        col.xyz = color(m.y, h);\n        col.xyz *= vec3(.2, .2, .2) +\n            vec3(.0, .2, .1) * light(vec3(0., -100., 0.), n, h, false) +\n            vec3(.4, .3, .2) * light(vec3(+50., 100., +100.), n, h, false) +\n            vec3(.6, .7, .8) * light(vec3(-50., 100., -100.), n, h, true);\n        //col.xyz = (sky(n).xyz * (march(h, n, MAX_DIST).x / MAX_DIST)) * color(m.y, h);\n        col.w = 1.;\n    }\n    \n\n    return col;\n}\n\n// MAIN\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy - .5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 ro = vec3(-.4, .3, -1.);\n    float a = PI + 1. + (.5 - iMouse.x / iResolution.x) * PI * 2.;\n    ro.xz = rot(a) * ro.xz;\n    float cp = 1.;\n    vec3 rd = normalize(vec3(uv.x, uv.y, cp));\n    rd.xz = rot(a) * rd.xz;\n\n    vec4 col = render(ro, rd);\n    if (col.w < PREC) {\n        col = sky(rd);\n    }\n    //col = pow(col, vec4(0.4545));\n    fragColor = col;\n}\n","name":"Buffer A","description":"","type":"buffer"}]}