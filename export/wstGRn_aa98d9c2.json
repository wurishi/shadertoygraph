{"ver":"0.1","info":{"id":"wstGRn","date":"1567670922","viewed":143,"name":"spiralsNova","username":"foran","description":"spiralsNova","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["spiralsnova"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define time iTime\n#define STEP 1./30.\n\nfloat sphere(vec3 p, float r) { return length(p)-r; }\n\nfloat cylinder(vec2 p, float r) { return length(p)-r; }\n//----------\n//Box-exact    \nfloat sdBox(vec3 p,vec3 b) {vec3 d=abs(p)-b;return length(max(d,0.))+min(max(d.x,max(d.y,d.z)),0.); }\n//----------\nfloat amod (inout vec2 p, float count) {//       сколько штук 12  5  5        my 1  1  111\n\n  float an = 3.14159*2./count;\n  float a = atan(p.y,p.x)+an/2.;\n  a = mod(a,an)-an/2.;\n  p = vec2(cos(a),sin(a))*length(p);\n  return 0.;\n}\n\nmat2 rot (float a) {//             вращение\nfloat c=cos(a),s=sin(a);\nreturn mat2(c,-s,s,c);\n}\n\nfloat repeat (float v, float c) { return mod(v,c)-c/2.; }\n\nfloat smin (float a, float b, float r) {\nfloat h = clamp(.5+.5*(b-a)/r,0.,1.);\nreturn mix(b,a,h)-r*h*(1.-h);\n}\n\nvoid orbit (inout vec3 p) {\n\n  p.xz *= rot(iTime);//     вращение\n  p.yz *= rot(iTime*.7);//  вращение\n p.xy *= rot(iTime*.4);//   вращение\n  p.xy *= rot(length(p)*.2);//    вращение\n  p.xz *= rot(length(p)*.5);//  вращение\n  p.yz *= rot(length(p)*.3);//    вращение\n}\n\nfloat rand (vec2 s) { return fract(sin(dot(s, vec2(55.,100.)))*440545.); }\n\nfloat map (vec3 pos) \n{\n  float scene = 1000.;\n  vec3 p = pos;//       обнуление p\n  orbit(p);//           вращение всей p (ось)\n//----------ось  \n  p.xz *= rot(p.y*.3);//            вращение  оси .3\n  amod(p.xz, 1.);//       12 отростки на оси my 1.\n  float wave = sin(time+p.y*2.);//   wave оси по y\n  p.x -= 1. + .2*wave;//   wave оси по x .2\n  //p.x = repeat(p.x, 1.);//   повтор wave оси по x много до 1.\n  scene = min(scene, cylinder(p.xz, .21));//  цилиндр оси радиус .1\n  p.y = repeat(p.y + time, .2);//  движение оси вниз по y .2\n  scene = smin(scene, cylinder(p.xy, .032), .31);//  отростки на оси по xy подножие к оси .02 радиус .1\n  scene = smin(scene, cylinder(p.yz, .032), .31);//  отростки на оси по yz подножие к оси .02 радиус .1\n//--------\n//float box=sdBox(p.xyz-vec3(p.y,-wave,0),vec3(2.*.125));\n//float box1=sdBox(p-vec3(0,0,0),vec3(.3+.8*(.5+.5*sin(time*10.))));\n//float sph1=sphere(p,.2+.2*(.5+.5*sin(p.y+time*10.)));\n//float cyl1=cylinder(p.xz,.2*wave+.02);\n//scene=smin(scene,sdBox(p-vec3(0,-wave,0),vec3(2.*.125)));//  отростки на оси по yz подножие к оси .02 радиус .1\n//scene=smin(cyl1,scene,.3);\n//--------\n\n  p = pos;//                обнуление p новая ось\n  orbit(p);//               вращение всей оси p\n  p.xz *= rot(p.y*5.);//    вращение  оси 5.0 по xz\n  amod(p.xz, 21.);////       5 отростки на оси my 1.      по хребту   5 ?\n  p.x -= .2 + wave * .2;//  wave оси по x\n  p.y = repeat(p.y, .5);//  движение оси вниз по y .5\n  scene = smin(scene, sphere(p, .2 + .1 * wave), .1);//  отростки sphere на оси по xyz подножие к оси .02 радиус .1\n\n  p = pos;//                обнуление p новая ось\n  amod(p.xz, 51.);//       5 отростки на оси my 111.\n  orbit(p);//               вращение всей оси p\n  p.xz*=rot(p.y*1.);//    вращение  оси 5.0 по xz\n  p.x = repeat(p.x, 1.);//  движение оси вниз по x .5\n  p.z=repeat(p.z,.015);//       движение оси вниз по y .5\n  //p.y = repeat(p.y, .015);//  движение оси вниз по y .5\n  //p.y=repeat(p.y,.55);//      движение оси вниз по y .5\n  scene = smin(scene, sphere(p, .2 + .1 * wave), .1);//  отростки sphere на оси по xyz подножие к оси .02 радиус .1\n  return scene;\n}\n\nvec3 getNormal (vec3 p) {\nvec2 e = vec2(.01,.0);\nreturn normalize(vec3(map(p+e.xyy)-map(p-e.xyy),map(p+e.yxy)-map(p-e.yxy),map(p+e.yyx)-map(p-e.yyx)));\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n//void main(void)\n{\nvec2 uv=vec2(fragCoord.x/iResolution.x,fragCoord.y/iResolution.y);\nuv-=.5;\nuv/=vec2(iResolution.y/iResolution.x,1);\n   vec3 eye = vec3(0,0,-4);\nvec3 ray = normalize(vec3(uv, .2));\nvec3 pos = eye;\nfloat shade = 0.;\nfor (float i =0.; i <= 1.; i += STEP) {\nfloat dist = map(pos);\nif (dist < .1) {\n  shade += 1./STEP;\n}\nif (shade >= 1.) break;\ndist = max(dist, .001);\ndist *= .6 + .1 * rand(uv);\npos += ray * dist;\n}\n\n  vec4 out_color=vec4(1.);//\n  vec3 color = vec3(1);\n  vec3 normal = getNormal(pos);\n  color = normal*1.5+.35;\n  color *= shade;\n  out_color = vec4(color, 1);\n  fragColor=vec4(out_color);//\n}","name":"Image","description":"","type":"image"}]}