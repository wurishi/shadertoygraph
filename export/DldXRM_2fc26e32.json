{"ver":"0.1","info":{"id":"DldXRM","date":"1685182627","viewed":79,"name":"electric field revised 3","username":"Fuergu","description":"Remained BUG: Incomplete electric field lines of the movable charge","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["electric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define h 0.01\n#define MAX_STEPS 300\n#define TAU 6.28318530718\n#define LINES 20.\n#define LINESS_WIDTH 0.03\n\nfloat phi(vec2 p, vec2 q, vec2 q1, vec2 q2, vec2 q3) {\n    return   q.x / length( q1 - p ) \n           + q.y / length( q2 - p ) \n           + q.y / length( q3 - p ); \n}\n\n#define e(q) (p - q) / pow( dot(q - p, q - p), 1.5 )\n\nvec2 E(vec2 p, vec2 q, vec2 q1, vec2 q2, vec2 q3) {\n    return normalize(  q.x * e(q1) \n                     + q.y * e(q2) \n                     + q.y * e(q3));\n}\n\nfloat line(vec2 p, vec2 a, vec2 b ) {\n    p -= a, b -= a;\n    return length(p - b * clamp(dot(p, b) / dot(b, b), 0., 1.) ); \n}\n\n\nvec2 RK4(vec2 p, vec2 q, vec2 q1, vec2 q2, vec2 q3) {\n    vec2 k1 = E(p, q, q1, q2, q3);\n    vec2 k2 = E(p + 0.5 * h * k1, q, q1, q2, q3);\n    vec2 k3 = E(p + 0.5 * h * k2, q, q1, q2, q3);\n    vec2 k4 = E(p + h * k3, q, q1, q2, q3);\n    return h / 3. * (0.5 * k1 + k2 + k3 + 0.5 * k4);\n}\n\n\n\nbool integrate(inout float d, vec2 p, vec2 q, vec2 q1, vec2 q2, vec2 q3, vec2 start, vec2 end) {\n    d = min(d, line(p, mix(q1, q2, float(length(q1 - start) > h * 1.001)), start));\n    vec2 pn;\n    vec2 po = start;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        pn = po + RK4(po, q, q1, q2, q3);\n        d = min(d,line(p, po, pn));\n        po = pn;\n        if (length(end - po) < h) {\n            d = min(d,line(p, po, end));\n            return false;\n        }\n        if (abs(po.x) > iResolution.x / iResolution.y || abs(po.y) > 1.0)\n            return true;\n    }\n    return true;\n}\n\n\nvoid mainImage(out vec4 O, vec2 C) {\n    vec2 R = iResolution.xy,\n        uv = ( 2. * C       - R ) / R.y,\n     mouse = ( 2.*iMouse.xy - R ) / R.y,\n        q1 = vec2(-.5, 0),\n        q2 = vec2( .4, 0),\n        q3 = mouse,\n         q = .2* vec2(1, mouse.y );\n    float idle = float( iMouse.z < 0. || iMouse.x <= 0.) * .1,\n          d = 1.;\n          \n    for (float o = 0.; o < LINES; o ++ ) {\n        float angle = iTime * idle + TAU *( o + .5 ) / LINES;\n        vec2 os = vec2(cos(angle), sin(angle)) * .01;\n        if (integrate(d, uv, q, q1, q2, q3, q1 + os, q2) && abs(q.y) > 0.)\n            integrate(d, uv, sign(q.y) * q, q1, q2, q3, q2 + vec2(-os.x,os.y), q1);\n    }\n\n    float f = phi(uv, q, q1, q2, q3);\n    O = .3* vec4( max(f, 0.), max(-f, 0.), 0,0)\n         +  smoothstep(3./iResolution.y,.0, d);\n    O.b += smoothstep(LINESS_WIDTH, 0., abs( fract( -f / .1 ) - .5 ) );      \n}","name":"Image","description":"","type":"image"}]}