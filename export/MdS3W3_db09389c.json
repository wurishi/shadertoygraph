{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"cubemap","id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"#define RENDERCLOUDS 1\n#define RENDERWATER 1\n#define RENDERREFLECTIONS 1\n\n#define gtx960970gpu\t1\n\n/*****************************************************************************\n   Updated shader a bit and squeezed reflections into it.\n   Original shader was without them but i wanted a bit more metallic look of ship.\n   To see original set rendereflection in line 3 to 0\n/*****************************************************************************/ \n\n\n#if RENDERREFLECTIONS \n\t#define MARCHSTEPS \t 90\n\t#define MARCHCLOUDS \t 60\n\t#define MARCHREFLECTIONS 12\n#else\n\t#define MARCHSTEPS \t 120\n\t#define MARCHCLOUDS  60\n#endif\n\n\n#define FARCLIP    45.0\n\n#define AOSTEPS    8\n#define SHSTEPS    \t 10\n#define SHPOWER    3.0\n\n#define PI         3.14\n#define PI2        PI*0.5    \n\n#define AMBCOL     vec3(1.0,0.97,1.0)\n#define BACCOL     vec3(1.0,1.0,1.0)\n#define DIFCOL     vec3(1.0,1.0,1.0)\n\n#define MAT1       1.0\n#define MAT2       2.0\n/***********************************************/\n/* variables for ship morphing */\nfloat ms=32.0;\nfloat msp=0.0;\n/* variable for motion speed */\nfloat gspeed;\n/* fbm matrices */\nmat2 m2 = mat2(1.6,-1.2,1.2,1.6);\nmat3 m3 = mat3( 0.00,  1.60,  1.20, -1.60,  0.72, -0.96, -1.20, -0.96,  1.28 );\n/* ship tmap coord */\nvec3 suvw;\n\n/***********************************************/\nfloat sdBox2( vec3 p, vec3 b ) {\n    vec3 di = abs(p) - b;\n    return max(max(di.x, di.y), di.z);\n}\n/***********************************************/\nfloat texnoise( vec2 x ) {\n    return texture(iChannel0, x*0.002).x*1.2;\n}\n/***********************************************/\nfloat fbm2( vec2 p ) {\n    p*=100.;\n    float f= 0.5000*texnoise(p); p = m2*p*2.02;\n          f+=0.2500*texnoise(p); p = m2*p*2.03;\n          f+=0.0625*texnoise(p);\n    return f*0.3;      \n}\n/***********************************************/\nfloat fbm3( vec3 p ) {\n     float f = 0.5000*texnoise(p.xz);  p = m3*p*1.1;\n          f += 0.2500*texnoise(p.xy); p = m3*p*1.2;\n          f += 0.0625*texnoise(p.xz); \n  return f;\n}\n/***********************************************/\nvec3 Water(vec3 p) {\n#if RENDERWATER      \n    p.x+=gspeed;\n    float wave=0.0;\n    float h = sin(p.y*0.01 + iTime*0.3)*0.2;      //loong wave -> ship y pos\n          h-=sin(p.x*0.1 + iTime*0.4)*0.2;\n    wave+=h+ fbm2(p.xz*0.1+iTime*0.01)*0.5;\n    wave+= fbm2(p.xz*0.22-iTime*0.02)*0.26;\n    return vec3( p.y+1.4-wave,MAT2, h);\n#else \n    return vec3(p.y+1.4,MAT2,0.0);\n#endif\n}\n/***********************************************/\nvec2 Trimaxion(vec3 p) {\n/* morph */\n    float morph=0.0;\n    float morph2=0.0;\n    float flaps=1.0;\n    if (msp>0.0) {\n    float mp=msp/ms;\n    if (p.x>0.0) {\n        p.x*=1.-0.45*mp;  \n\t\tp.z+=smoothstep(0.0,1.0,sign(p.z)*(p.x*0.1)*mp);\n        p.y+=smoothstep(0.0,1.0,sign(p.y)*(p.x*0.1)*mp);\n    }\t\t\n    morph=0.3*mp;   \n    morph2=0.08*mp;   \n    flaps+=1.0*mp;\n    p.z*=1.0+0.2*mp;\n    }\n    /* morph */\n    vec3 q=p;\n    float tt=0.0;\n    if(p.y<0.0) tt=-0.1;\n    //body\n    p.z+=sin(p.z);\n    p.y+=sin(p.y)*0.6;\n    float r=length(p+vec3(0.0,tt-sign(p.y)*morph*0.2,0.0))-1.+morph*0.1;\n    //+body\n    p.z+=sin(q.z)*-0.6;\n    p.y+=sin(q.y)*0.5;\n    r=min(r, length(p+vec3(0.0,tt,0.0))-1.05);\n    //center\n    p.x-=0.025;\n    p.y+=0.3 -morph;\n    p.z+=sin(q.z)*-0.4 +0.2;\n    p.y+=sin(q.y)*0.5;\n        float tb=sdBox2(q+vec3(0.0,0.5,0.0),vec3(1.5,0.5,1.5)) + cos(q.x*4.0+flaps)*0.025;\n        float b=max(-tb, length(p)-1.2+morph2); \n        float c=sdBox2(q+vec3(0.0,0.0,1.0),vec3(1.5,0.5,1.0));\n        r=min(r,max(b,-c));\n    p.z-=0.4;    \n        b=max(-tb, length(p)-1.2+morph2);\n        c=sdBox2(q+vec3(0.0,0.0,-1.0),vec3(1.5,0.5,1.0));\n        r=min(r, max(b,-c));\n    p.z+=0.2+sin(q.z*0.2);\n    p.y-=0.55;\n        tb=sdBox2(q+vec3(0.0,-0.5,0.0),vec3(1.5,0.5,1.5)) - cos(q.x*4.0+flaps)*0.025;\n        b=max(-tb, length(p+vec3(0.0,3.*morph2,0.0))-1.10);  \n       \n        r=min(r,b );\n\t/*hack !*/\n\tsuvw=p;\n    //distance fix\n    r=r*0.85;\n\treturn vec2( r , MAT1);    \n}\n/***********************************************/\nvec2 opU(vec2 a, vec2 b) {\n\treturn mix(a, b, step(b.x, a.x));\n}\n/***********************************************/\nvoid rX(inout vec3 p, float a) {\n    float c,s;\n    vec3 q=p;\n    c = cos(a); s = sin(a);\n    p.y = c * q.y - s * q.z;\n    p.z = s * q.y + c * q.z;\n}\n/***********************************************/\nvec2 DE(vec3 p) {\n    vec3 w=Water(p);\n    rX(p,sin(PI+iTime*0.5)*0.35);\n    p.y-=w.z-0.5;\n    p.z+=sin(iTime*0.5);\n    return opU(Trimaxion(p),w.xy);\n}\n/***********************************************/\nvec3 normal(vec3 p) {\n\tvec3 e=vec3(0.01,-0.01,0.0);\n\treturn normalize( vec3(\te.xyy*DE(p+e.xyy).x +\te.yyx*DE(p+e.yyx).x +\te.yxy*DE(p+e.yxy).x +\te.xxx*DE(p+e.xxx).x));\n}\n/***********************************************/\nfloat calcAO(vec3 p, vec3 n ){\n\tfloat ao = 0.0;\n\tfloat sca = 1.0;\n\tfor (int i=0; i<AOSTEPS; i++) {\n        \tfloat h = 0.01 + 1.2*pow(float(i)/float(AOSTEPS),1.5);\n        \tfloat dd = DE( p+n*h ).x;\n        \tao += -(dd-h)*sca;\n        \tsca *= 0.65;\n    \t}\n   return clamp( 1.0 - 1.0*ao, 0.0, 1.0 );\n //  return clamp(ao,0.0,1.0);\n}\n/***********************************************/\nfloat calcSh( vec3 ro, vec3 rd, float s, float e, float k ) {\n\tfloat res = 1.0;\n    for( int i=0; i<SHSTEPS; i++ ) {\n    \tif( s>e ) break;\n        float h = DE( ro + rd*s ).x;\n        res = min( res, k*h/s );\n    \ts += 0.02*SHPOWER;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n/***********************************************/\n\n#if gtx960970gpu\nvec3 BG(vec3 ro, vec3 rd, vec3 sun) {\n    float sd=dot(rd,sun);\n\tfloat t = clamp( pow(1.0-0.5*rd.y, 15.0), 0.0,1.0);\n\tvec3 col=mix( vec3( 0.74,0.78,0.98 ),vec3(1.0,0.98,0.98), 0.5-rd.y);\n    if(rd.x>0.2) {\n        col+= 0.4*vec3(1.6,1.4,1.0)*pow( sd, 350.0 );\n        col+= vec3(1.0) *pow( abs(dot(rd,sun+vec3(0.0,-1.5,0.0))), 8.0 )*0.12;\n    }    \n#if RENDERCLOUDS\n    ro.x-=gspeed*100.0;\n    vec4 sum = vec4(0.0); \n    for (int q=0; q<MARCHCLOUDS; q++) {\n        float c = (float(q-MARCHSTEPS)*10.0+3.0-ro.y) / rd.y;\n        vec3 cpos = ro + rd*c;\n         cpos*=vec3(0.007,0.025,0.0062);\n        float a = smoothstep(0.5, 1.0, fbm3( cpos ))*0.9; \n        vec3 lc = mix(vec3( 1.0, 1.0, 1.0 ), vec3( 0.2,0.2,0.15 ), a); \n        a = (1.0-sum.w)*a; \n        sum += vec4(lc*a, a); \n       if (sum.w>0.9) break;\n    }\n    float a = smoothstep(0.7, 1.0, sum.w);\n    sum.rgb /= sum.w+0.001;\n    sum.rgb -= abs( 0.65*vec3(0.8, 0.75, 0.7)*pow(rd.y,13.0)*a );\n    sum.rgb += abs( 0.35*vec3(1.3, 1.2, 1.0)* pow(rd.y,5.0)*(1.0-a) );\n    sum.rgb=clamp(sum.rgb,0.0,1.0);\n    return mix( col, sum.rgb , sum.w*(1.0-t) );\n#else\n    return col;\n#endif\n}\n\n#else\n\nvec3 BG(vec3 ro, vec3 rd, vec3 sun) {\n    float sd=dot(rd,sun);\n    float t = clamp( pow(1.0-0.5*rd.y, 15.0), 0.0,1.0);\n    vec3 col=mix( vec3( 0.74,0.78,0.98 ),vec3(1.0,0.98,0.98), 0.5-rd.y);\n    if(rd.x>0.0) {\n        col+= 0.4*vec3(1.6,1.4,1.0)*pow( sd, 350.0 );\n        col+= vec3(1.0) *pow( abs(dot(rd,sun+vec3(0.0,-1.5,0.0))), 8.0 )*0.12;\n    }    \n#if RENDERCLOUDS\n    ro.x-=gspeed*100.0;\n    vec4 sum = vec4(0.0); \n    for (int q=0; q<MARCHCLOUDS; q++) {\n        float c = (float(q-MARCHSTEPS)*10.0+3.0-ro.y) / rd.y;\n        vec3 cpos = ro + rd*c;\n         cpos*=vec3(0.007,0.025,0.0062);\n        float a = smoothstep(0.5, 1.0, fbm3( cpos ))*0.9; \n        vec3 lc = mix(vec3( 1.0, 1.0, 1.0 ), vec3( 0.2,0.2,0.15 ), a); \n        a = (1.0-sum.w)*a; \n        sum += vec4(lc*a, a); \n      if (sum.w>0.9) break;\n    }\n    float a = smoothstep(0.7, 1.0, sum.w);\n    sum.rgb /= sum.w+0.001;\n    sum.rgb -= abs( 0.65*vec3(0.8, 0.75, 0.7)*pow(sd,13.0)*a );\n    sum.rgb += abs( 0.35*vec3(1.3, 1.2, 1.0)* pow(sd,5.0)*(1.0-a) );\n    sum.rgb=clamp(sum.rgb,0.0,1.0);\n    return mix( col, sum.rgb , sum.w*(1.0-t) );\n#else\n    return col;\n#endif\n}\n\n#endif\n/***********************************************/\nvoid rot( inout vec3 p, vec3 r) {\n\tfloat sa=sin(r.y); float sb=sin(r.x); float sc=sin(r.z);\n\tfloat ca=cos(r.y); float cb=cos(r.x); float cc=cos(r.z);\n\tp*=mat3( cb*cc, cc*sa*sb-ca*sc, ca*cc*sb+sa*sc,\tcb*sc, ca*cc+sa*sb*sc, -cc*sa+ca*sb*sc,\t-sb, cb*sa, ca*cb );\n}\n/***********************************************/\nvec3 colorize(vec3 ww, vec2 r, vec3 ro, vec3 rd, vec3 nor, vec3 lig, vec3 sun ){ \n    vec3 col;\n    if (r.x>FARCLIP) {\n        return BG(ro,rd,sun);\n    } else {\n    \n\t    vec2 rs=vec2(1.0,1.0);  //rim and spec\n\t\tif (r.y==MAT1) { \n\t\t        col=vec3(0.89,0.93,1.11)+(texture(iChannel1,suvw).xyz*0.05);\n\t\t        rs=vec2(0.1,1.4); \n\t\t}    \n\t\tif (r.y==MAT2) col=vec3(0.2,0.25,0.4);\n\n\n    \tfloat amb= 1.0;\t\t\n    \tfloat dif= clamp(dot(nor, lig), 0.0,1.0);\n    \tfloat bac= clamp(dot(nor,-lig), 0.0,1.0);\n    \tfloat rim= pow(1.+dot(nor,rd), 3.0);\n    \tfloat spe= pow(clamp( dot( lig, reflect(rd,nor) ), 0.0, 1.0 ) ,16.0 );\n    \tfloat ao= calcAO(ww, nor);\n    \tfloat sh= calcSh(ww, lig, 0.01, 2.0, 4.0);\n\n\t    col *= 0.5*amb*AMBCOL*ao + 0.4*dif*DIFCOL*sh + 0.05*bac*BACCOL*ao;\n\t    col += 0.3*rim*amb * rs.x;\n    \tcol += 0.5*pow(spe,1.0)*sh * rs.y;\n//    \tcol = clamp(col,0.0,1.0);\n\n        if (r.y==MAT2) {\n            float fo=pow(0.023*r.x, 1.1);\n            col=mix(col,vec3(0.91,0.88,0.98),fo);\n            if(rd.x>0.0) col+= vec3(1.0) *pow( abs(dot(rd,sun)), 32.0 )*0.5;\n\t    }\n    }\n    return col;\n}\n/***********************************************/\n\n/***********************************************/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\t\n\tvec3 ta = vec3(0.0, 0.0, 0.0);\n\tvec3 ro =vec3(-5.0, 0.0, 0.0);\n//\tvec3 ro =vec3(0.0, 1.0, -6.0);\n\tvec3 lig=normalize(vec3(6.0, 3.0, 1.0));\n\tvec3 sun=normalize(vec3(2.0,0.3,0.3));\n\t\n//\tvec2 mp=iMouse.xy/iResolution.xy;\n//\trot(ro,vec3(mp.x,0.0,mp.y));\n//\trot(lig,vec3(mp.x,mp.y,0.0));\n    /* animate camera */\n    rot(ro,vec3(iTime*0.2,0.0,sin(iTime*0.2)*0.4));\n\n\n\tvec3 cf = normalize( ta - ro );\n    vec3 cr = normalize( cross(cf,vec3(0.0,1.0,0.0) ) );\n    vec3 cu = normalize( cross(cr,cf));\n\tvec3 rd = normalize( p.x*cr + p.y*cu + 2.5*cf );\n\n/* anim */\n    /* morph*/    \n        float n=mod(iTime,20.0);\n        if (n>9.0) msp= floor((n-9.0)*32.0);\n        if (n>10.0) msp=32.0;\n        if (n>19.0) msp= 32.0-floor((n-19.0)*32.0); \n   \n    /* move */\n        float pos=iTime*2.0;\n        float boost=8.0;\n        pos+=(10.0*boost)*floor(iTime/20.0);\n        if(n>10.0) pos+=(floor(n)-10.0)*boost+boost*fract(n);\n        gspeed=pos;\n    \n\n\tvec3 col=vec3(0.0);\n\t/* trace */\n\tvec2 r=vec2(0.0);\t\n\tfloat d=0.0;\n\tvec3 ww;\n\tfor(int i=0; i<MARCHSTEPS; i++) {\n\t\tww=ro+rd*d;\n\t\tr=DE(ww);\t\t\n        if( r.x<0.0 || r.x>FARCLIP ) break;\n        d+=r.x;\n\t}\n\tr.x=d;\n\t/* draw */\n\t\tvec3 nor=normal(ww);\n        col=colorize(ww, r, ro, rd, nor, lig, sun);\n        \n#if RENDERREFLECTIONS\n        if (r.y==MAT1) {\n            ro=ww;\n            rd=reflect(rd,nor);\n            d=r.x*0.5;\n            float s=.1/abs(dot(rd,nor));\n            \tr=vec2(0.0);\t\n\t            for(int i=0; i<MARCHREFLECTIONS; i++) {\n\t                ww=ro+rd*d;\n            \t\tr=DE(ww);\t\t\n                    if( r.x<0.0 || r.x>s ) break;\n                    d+=r.x;\n\t            }\n\t            r.x=d;\n            /*col*/\n            nor=normal(ww);\n\t\t\tif( d<FARCLIP ) {\n\t        \tro=0.25*colorize(ww, r,ro,rd,nor,lig,sun);\n\t        //    col=mix(col,ro,0.75);\n\t\t\t\tcol=col+ro-col*ro;\t\n            }\n        }\n#endif\n\n\tfragColor = vec4( col.rgb, 1.0 );\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MdS3W3","date":"1394156929","viewed":1541,"name":"Flight of the navigator","username":"avix","description":"Got inspiration from the 'Flight of the navigator' movie.  Model is not 'exactly' the same but oh whatever.","likes":26,"published":1,"flags":0,"usePreview":0,"tags":["procedural","raymarch","sea","water","sky"],"hasliked":0,"parentid":"","parentname":""}}