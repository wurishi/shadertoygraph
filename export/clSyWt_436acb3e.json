{"ver":"0.1","info":{"id":"clSyWt","date":"1692388653","viewed":15,"name":"Product of functions visualized","username":"HalbFettKaese","description":"The area of one xy slice represents the product of the two functions at that z position.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","math"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The visualized functions\n\nfloat f(float x) {\n    return 1./x;\n}\nfloat g(float x) {\n    return x*x;\n}\n\n// Settings\n\nfloat minDist = 0.01;\n\nfloat normalSharpness = 0.001;\n\nvec3 lightDir = normalize(vec3(1.0,2.0,-1.0));\n\n// Code\n\n#define PI 3.14159265359\nvec2 v01 = vec2(0.0, 1.0);\n\nmat3 Rot3D(float yaw, float pitch) {\n    float cy = cos(yaw);\n    float sy = sin(yaw);\n    float cp = cos(pitch);\n    float sp = sin(pitch);\n    return mat3(cy,0.0,sy,0.0,1.0,0.0,-sy,0.0,cy) * mat3(1.0,0.0,0.0,0.0,cp,-sp,0.0,sp,cp);\n}\n\nfloat getInfiniteCuboidSdf(vec3 p, vec2 cuboidSize) { // cuboid with infinte z-size\n    p.xy -= min(vec2(0.0), cuboidSize);\n    cuboidSize = abs(cuboidSize);\n    vec2 dist = max(-p.xy, p.xy-cuboidSize);\n    return max(dist.x,dist.y);\n}\n\nfloat getSdf(vec3 p) {\n    vec2 size = vec2(f(p.z), g(p.z));\n    return getInfiniteCuboidSdf(p, size) * 0.4; // 0.4 adjusts for somewhat rapid changes in function.\n}\n\nvec3 getNormal(vec3 p) {\n    float d0 = getSdf(p);\n    float d1 = getSdf(p+v01.yxx*normalSharpness);\n    float d2 = getSdf(p+v01.xyx*normalSharpness);\n    float d3 = getSdf(p+v01.xxy*normalSharpness);\n    return normalize((vec3(d1, d2, d3) - d0));\n}\n\nfloat rayTrace(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    for (int i = 0; i < 200; i++) {\n        float dist = getSdf(ro+t*rd);\n        if (dist<minDist)\n            break;\n        t += dist;\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 M = iMouse.xy/iResolution.xy * vec2(-PI*2.0,PI)-vec2(PI,PI*0.5);\n    mat3 CamRot = Rot3D(M.x,M.y);\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = (fragCoord - iResolution.xy * 0.5)/iResolution.yy;\n    vec3 left = CamRot[0];\n    vec3 up = CamRot[1];\n    vec3 forward = CamRot[2];\n    float FOV = 70.0;\n    vec3 rd = normalize((uv.x * left + uv.y * up)*(2.*tan(radians(FOV*0.5))) + forward);\n    \n    vec3 ro = vec3(3.0,3.0,0.0); // ray origin\n    \n    float t = rayTrace(ro, rd);\n    vec3 p = ro + t*rd; // final point of ray trace\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(sin(iTime)-3.+uv.xyx+vec3(0,2,4));\n    \n    vec3 backgroundColor = col * 0.1;\n    if (getSdf(p)<minDist) { // hit object\n        if (f(p.z)*g(p.z)<0.0) // area negative (invert color)\n            col = 1. - col;\n        // add shading\n        vec3 normal = getNormal(p);\n        col *= 0.5+0.5*max(0.0, dot(normal,lightDir));\n        \n        col = mix(col, backgroundColor, 1./(1.+exp(-(t-40.)*0.4))); // add fog\n    } else { // hit nothing\n        col = backgroundColor;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}