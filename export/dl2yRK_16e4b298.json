{"ver":"0.1","info":{"id":"dl2yRK","date":"1692035755","viewed":104,"name":"CloudTunnel","username":"ayaha401","description":"I wanted to bend the tube enough to move the camera, but I couldn't...","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["3d","cloud"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nconst float PI=3.1415926536;\nconst float TAU=PI*2.;\nconst float eps=0.01;\nconst float DEG2RAD = PI/180.;\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64);\n\nfloat hash(float n)\n{\n    return fract(sin(n) * 43758.5453);\n}\n\nfloat noise(in vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f * f * (3.0 - 2.0 * f);\n\n    float n = p.x + p.y * 57.0 + 113.0 * p.z;\n\n    float res = mix(mix(mix(hash(n +   0.0), hash(n +   1.0), f.x),\n                        mix(hash(n +  57.0), hash(n +  58.0), f.x), f.y),\n                    mix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n                        mix(hash(n + 170.0), hash(n + 171.0), f.x), f.y), f.z);\n    return res;\n}\n\nfloat fbm(vec3 p)\n{\n    float f;\n    f  = 0.5000 * noise(p); p = m * p * 2.02;\n    f += 0.2500 * noise(p); p = m * p * 2.03;\n    f += 0.1250 * noise(p);\n    return f;\n}\n\nvec2 path(float t)\n{\n    return vec2(sin(t), cos(t))*.1;\n}\n\nfloat sdTube(vec3 p, vec3 s)\n{\n    float sdf2d = abs(length(p.xy) - s.x) - s.y;\n    float d = abs(p.z) - s.z;\n    return max(sdf2d, d);\n}\n\nfloat map(vec3 p)\n{\n    p.z = mod(p.z, 15.) - 7.5;\n    float d0 = -sdTube(p, vec3(20., 1., 1.)) * 0.08 + fbm(p * 0.3 + p.z * 0.08);\n   \n    return d0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n    float zfac = ((1.0-dot(uv, uv))*.1 + 1.);\n    float dist, hit, i = 0.;\n    vec3 cPos = vec3(0., 0., 35. + iTime * 10.);\n    vec3 lookAt = cPos + vec3(0., 0., .5);\n    lookAt.xy += path(lookAt.z * .1) * .5;\n    float fov = PI/3.5;\n    vec3 forward = normalize(lookAt - cPos);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x));\n    vec3 up = cross(forward, right);\n    vec3 cUp = vec3(0., 1., 0.);\n    vec3 ray = normalize(forward*zfac + fov*uv.x*right + fov*uv.y*up); \n    vec3 L = normalize(vec3(1));\n    vec3 col=vec3(0);\n    float sampleCount = 64.0;\n    float zMax = 65.0;\n    float zStep = zMax / sampleCount;\n    float absorption = 100.0;\n    float T = 1.0;\n    \n    for(;i<64.;i++)\n    {\n        vec3 rp = cPos + ray * hit;\n        rp.xy += -path(rp.z)*4.5;\n        dist=map(rp);\n        hit+=zStep;\n        if(dist > eps)\n        {\n            float tmp = dist / sampleCount;\n            T *= 1.0 - (tmp * absorption);\n            if (T <= 0.01)\n            {\n                break;\n            }\n            float opaity = 50.0;\n            float k = opaity * tmp * T;\n            vec3 cloudColor = vec3(1.0);\n            col += cloudColor * k;\n        }\n    }\n    vec3 bg = mix(vec3(0.3, 0.1, 0.8), vec3(0.7, 0.7, 1.0), 1.0 - (uv.y + 1.0) * 0.5);\n    col += bg;\n    \n    fragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}