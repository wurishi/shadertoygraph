{"ver":"0.1","info":{"id":"3l2yDG","date":"1595264904","viewed":115,"name":"Bees (жъжъь)","username":"CyanMARgh","description":"Russian postironic meme called \"жъжъь\".","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","meme","bees"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 cameraPos = vec3(0., 2., -6.5);\nfloat softShadow = 10.;\nfloat depthmax = 50.; \nconst float eps = 1e-3;\nvec3 backcol = vec3(.6,.7,1.);\nfloat inf = 1e20;\nfloat pi=3.14159265;\n\n//additioanal operations\nmat2 ro (float a) {\n\tfloat s = sin(a), c = cos(a);\n    return mat2(c,-s,s,c);\n}\n//SDF operations\n//colored\nvec4 cun(vec4 d1, vec4 d2){\n    return d1.w<d2.w?d1:d2;\n}\nvec4 cdif(vec4 d1, vec4 d2){\n    d2.w*=-1.;\n    return d1.w>d2.w?d1:d2;\n}\nvec4 cmix(vec4 d1, vec4 d2, float k) {\n    float h = clamp( 0.5 + 0.5*(d2.w-d1.w)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n//uncolored\nfloat un(float d1, float d2){\n    return d1<d2?d1:d2;\n}\nfloat smix( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n//SDF\nfloat sphere(vec3 pos){\n    return length(pos);\n}\nfloat capsule(vec3 a, vec3 b, float r1, float r2, vec3 p){\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n\t\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot( pa*l2 - ba*y, pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                           return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\nfloat box(vec3 b, vec3 p){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat disk(vec3 p0, vec3 n, float r,vec3 p){\n    p-=p0;\n    float d = length(p);\n    float h = abs(dot(p,n));    \n    float R = sqrt(d*d-h*h)-r;\n    return (R>0.)?sqrt(h*h+R*R):h;\n}\n\n//texturing functions\nbool cb3(vec3 p){\n    ivec3 d = ivec3(floor(p));\n    return (d.x+d.y+d.z)%2==0;\n}\nbool cb1(float p, int i){\n    int d = int(floor(p));\n    return d%i==0;\n}\n\n//bee SDF with color\nvec4 bee(vec3 p0, float a, float b, float c, float s, vec3 p){    \n    p-=p0;s/=2.;\n    p/=s;\n    p.xz*=ro(a);\n    p.xy*=ro(b);\n    p.yz*=ro(c);\n\tvec4 body = vec4(cb1(p.z * 5. + .8 ,3)?vec3(.3,.3,.2):vec3(.7,.7,.3), sphere(p-vec3(.0,.0,0.))-1.3);        \n\n    //sting    \n    vec4 sting = vec4(.15,.15,.15,capsule(vec3(0.,0.,0.),vec3(0.,0.,-2.2),.3,.01,p));\n    body = cun(body,sting);\n    \n    //legs\n    p.x=abs(p.x);    \n    vec3 p_=p;  \n\tfloat leg=1e20;\n\tfor(int i=0;i<3;i++){\n\t\tleg = un(leg,capsule(vec3(.5,-1.5,.5),vec3(.4,-.9,.5),.15,.2,p_));\n\t\tp_.z+=.5;\n    }\n    p_=p;        \n    body = cun(body,vec4(.1,.1,.1,leg));\n        \n    //eyes    \n    vec4 eye = vec4(1.,1.,1.,sphere(p_-vec3(.6,0.8,1.))-.7);\n    eye = cun(eye,vec4(.1,.1,.1,sphere(p_-vec3(.6,0.8,1.2))-.55));\n    p_-=vec3(.7,1.5,1.);\n    p_.xy*=ro(-.25);\n    eye = cun(eye,vec4(.2,.2,.2,box(vec3(.6,.1,.2),p_)));        \n\tbody = cun(body,eye);\n    p_=p;\n    \n    //wings    \n    p_.xy *= ro(.1*sin(iTime*30.));\n\tvec4 wing = vec4(.9,.9,1.,disk(vec3(.9,1.,-0.8),normalize(vec3(-1.,1.,0.3)),.8,p_)-.07);        \n\tbody = cun(body,wing);\n    \n    return body*s;\n\n}\n\n//scene SDF\nvec4 map(vec3 p){\n    vec4 d0 = vec4(.9,.9,1.,-box(vec3(20.,20.,20.),p-vec3(0.,18.,0.)));\n    d0.xyz *= vec3(cb3(p)?.6:.8);\n    //d0.xyz *= vec3(0.,0.,inf);\n    //greenscreen\n    \n    float t1 = .1*sin(iTime*.3);\n    float t2 = .1*sin(iTime*.26);\n    float t3 = .1*sin(iTime*.22);\n    \n    d0 = cun(d0, bee(vec3(-0.3,0.8+t1,-1.8),2.3,0.0+t2,-.3,1.5,p));\n\td0 = cun(d0, bee(vec3(-1.3,4.0-t2,0.5),1.2,0.0-t3,-0.4,1.5,p));\n\td0 = cun(d0, bee(vec3(0.9,3.9+t3,3.2),3.3,0.0-t1,-0.4,1.5,p));\n    \n    return d0;\n}\n//normals\nvec3 norm(vec3 p){\n    const vec2 e = vec2(eps,0.);\n    float d = map(p).w;\n    return normalize(vec3(\n        map(p + e.xyy).w-d,\n        map(p + e.yxy).w-d,\n        map(p + e.yyx).w-d\n    ));\n}\n// color of lighting for point\nvec3 getLight(vec3 p, vec3 lp, vec3 n, vec3 lc, float po, bool mode){\n    p += n * eps;\n    vec3 ld=mode?lp:lp-p;\n    float l = length(ld);ld/=l;\n\tfloat diff = dot(ld,n);\n    \n    float h, c=eps, r=1.;\n    \n    for (float t = 0.0; t < 50.0; t++){\n        h = map(p + ld * c).w;\n        if (h < eps){\n            return vec3(0.);\n        }\n        r = min(r, h * softShadow / c);\n        c += clamp(h,0.02,2.0);\n        if(c>l)break;\n    }\n    \n    return lc*po*r*diff/(l*l);\n}\n// ambient occlusion by point\nfloat getOcc(vec3 ro, vec3 rd){\n    float totao = 0.0;\n    float sca = 1.0;\n\n    for (int aoi = 0; aoi < 5; aoi++){\n        float hr = 0.01 + 0.02 * float(aoi * aoi);\n        vec3 aopos = ro + rd * hr;\n        float dd = map(aopos).w;\n        float ao = clamp(-(dd - hr), 0.0, 1.0);\n        totao += ao * sca;\n        sca *= 0.75;\n    }\n\n    const float aoCoef = 0.5;\n\n    return totao*(1.0 - clamp(aoCoef * totao, 0.0, 1.0));\n}\n//light from all sources + occlusion by point\nvec3 getFullLight(vec3 pos, vec3 n){   \n    pos+=eps*n;\n    vec3 col;\n    //vec3 col = map(pos).xyz;\n    vec3 lighting = vec3(.25);\n\n    if (length(pos) < depthmax){\n        // adding 3 point lights and one directional light\n\t\tlighting += getLight(pos, vec3(6., 6., 6.), n, vec3(1.,.9,.9), 50.,false);\n        lighting += getLight(pos, vec3(6., 10., -6.), n, vec3(1.,1.,1.), 50.,false);\n        lighting += getLight(pos, vec3(-6., 6., 6.), n, vec3(1.,1.,1.), 50.,false);\n        lighting += getLight(pos, vec3(3., 3., -6.), n, vec3(1.,.9,.9), 50.,false);\n        \n\t\tcol = lighting;\n    }else{\n        col = backcol;\n    }\n    return col;\n}\n//direction of ray by pixel coord\nvec3 getDir(vec2 fragCoord, float angle){\n\tvec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);    \n    vec3 eye = cameraPos;\n    float targetDepth = 2.;\n    vec3 dir = normalize(vec3(p,targetDepth));\n    dir.xz*=ro(angle);\n    return dir;\n}\n//raymarching\nvec3 rayCast(vec3 eye, vec3 dir){\n    vec3 col = vec3(0.);\n    float k=1.;\n    \n    vec3 pos; float depth=0., sdepth=0., dist;\n    vec4 rc;\n    const int maxsteps = 500;\n    for (int i = 0; i < maxsteps; i++){\n        pos = eye + dir * depth;\n        rc = map(pos);\n        dist = rc.w;\n\n        depth += dist;\n        \n        if(dist < eps){ //intersection with object\n            break; \n        }else if(length(pos)>depthmax){ //ray \n            depth = depthmax+eps;\n            break;\n        }\n    } \n    vec3 n = norm(pos);\n    pos+=eps*n;\n    col+=map(pos).xyz*k*getFullLight(pos,n);\n    return col * exp(-0.003*sdepth);\n}\n//full render\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    //direction calculation\n    float angle = 1.32;    \n    vec3 eye = cameraPos;\n    eye.xz*=ro(angle); // rotating camera\n    vec3 dir = getDir(fragCoord,angle);\n    //raymarching\n    vec3 col = rayCast(eye, dir);    \n    fragColor = vec4(1.5*log(1.+ col), 1.0);\n}","name":"Image","description":"","type":"image"}]}