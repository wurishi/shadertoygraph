{"ver":"0.1","info":{"id":"td2fzy","date":"1590321752","viewed":70,"name":"Little sun","username":"Stenator","description":"a cute little sun :)","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//Random\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n\n\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\nmat2 scale(vec2 _scale){\n    return mat2(_scale.x,0.0,\n                0.0,_scale.y);\n}\n\n\n\n//fbm anim\nfloat FbmVariation( float value) {\n\nfloat amplitude = 0.04;\nfloat frequence = 3.;\nfloat y = sin(value*frequence);\nfloat t = 0.01*(-iTime * 130.);\ny+= sin(value*frequence*2.1+t)*4.5;\ny+= sin(value*frequence*1.4842+t)*3.;\ny+= sin(value*frequence*4.55858+t)*4.5;\ny*=amplitude*0.07;\n\nreturn y; }\n\n\n\n//donne la distance pour raymarch\nfloat GetDist(vec3 p) {\n\n    vec3 pnoise = p ;\n    //pnoise.y *= 1;\n    \n    float variation = noise((pnoise.xy* pnoise.z));\n    pnoise = pnoise *0.02;\n    pnoise.z += iTime*0.05;\n    float minvar = noise(pnoise.xy * pnoise.z);\n    pnoise *= 6.;\n    float maxvar = noise(pnoise.xy * pnoise.z);\n\n\n    variation = variation*0.15 +  FbmVariation(minvar) ;\n    variation += 0.008 * (maxvar);\n    \n    vec4 s = vec4(0., 1., 6., 1.5 +  variation );\n    \n    float sphereDist = length(p-s.xyz) -s.w;\n    \n    \n    return sphereDist;\n    }\n\n\n\n//on definit des valeur ici afin de les retrouver plus facilement\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\n\n\n//fonction raymarch\nfloat RayMarch(vec3 ro,vec3 rd) {\nfloat dO =0. ;\n\nfor(int i=0; i<MAX_STEPS; i++) {\nvec3 p = ro + rd*dO; //c'est le point qui marque la distance \nfloat dS = GetDist(p);\ndO += dS;\nif(dO>MAX_DIST ||dS<SURF_DIST) break; \n\n}\nreturn dO;\n}\n\n\n\n//recuperation des normal\nvec3 GetNormal(vec3 p) {\nfloat d = GetDist(p);\nvec2 e = vec2(.01, 0.);\n\nvec3 n = d - vec3(\n    GetDist(p- e.xyy),\n    GetDist(p- e.yxy),\n    GetDist(p- e.yyx));\n\n    return normalize(n);\n}\n\n\n// la rimlight\nfloat RimLight (vec3 p, vec3 rd) {\nvec3 normal = GetNormal(p);\n\nfloat rim =  1.- dot(normal, normalize(vec3(0.,0.,-1.)));\nrim = clamp(rim,0.,1.)*6.;\nreturn max(0.2,rim*0.2);\n\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 uv = -1. + 2. * v_texcoord;\n    //vec2 uv = gl_FragCoord.xy / resolution;\n    vec2 uv = (gl_FragCoord.xy-.5* iResolution.xy) / iResolution.y;\n    \n    \n    \n    //camera\n    vec3 ro = vec3(0., 1., 0.); //ray origin, c'est la position de la camÃ©ra\n    vec3 rd  = normalize(vec3(uv.x,uv.y,1.)); // direction du rayon/ camera?\n    \n    \n    float d = RayMarch(ro, rd);\n    vec3 p = ro + rd * d; //les coord des point par rapport a la zdepth\n    \n    \n    //on enleve tout la partie du fond du calcul de la rim\n    float gradientlight =0.2;\n    float light = 0.;\n    if (d<50.) {\n    light = RimLight(p, rd); }\n    \n    float varcolor = noise(p.xy * p.z);\n    \n    \n    vec3 seccolor = vec3(0.7,0.2,0.1)*(varcolor*9.);\n    vec3 color = vec3(0.3,0.15,0.05) ;//*seccolor;\n    color = mix(color,seccolor,varcolor)*2.;\n    \n    color *= light*6.;\n    fragColor = vec4(color,\n        1.0);\n}","name":"Image","description":"","type":"image"}]}