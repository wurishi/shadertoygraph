{"ver":"0.1","info":{"id":"Ds3fRN","date":"1696906403","viewed":316,"name":"2D Liquid Fill Inside Sphere v2","username":"Mirza","description":"ENHANCED 2D liquid inside 'sphere' shader.\n\nThe actually readable version of\n> https://www.shadertoy.com/view/Ds3BRN\n\nFeel free to use this however you want.\nModify, learn from it, copy-paste, etc...","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["game","sdf","sphere","circle","progress","colour","mask","liquid","fill","loader","health","hp"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ENHANCED 2D liquid inside 'sphere' shader.\n\n// Author: Mirza Beig\n\n// https://twitter.com/TheMirzaBeig\n// https://www.youtube.com/@MirzaBeig\n\n// Feel free to use this however you want.\n// Modify, learn from it, copy-paste, etc...\n\n// This is the expanded version of:\n// > https://www.shadertoy.com/view/Ds3BRN\n\n// Variables use descriptive names- things should be self-explanatory for the most part.\n\n#define PI 3.14159\n\n// https://iquilezles.org/articles/distfunctions2d/\n\nfloat sdArc(in vec2 p, in vec2 sc, in float ra, float rb)\n{\n    // sc is the sin/cos of the arc's aperture\n    p.x = abs(p.x);\n    return ((sc.y*p.x>sc.x*p.y) ? length(p-sc*ra) : \n                                  abs(length(p)-ra)) - rb;\n}\n\nmat2 Get2DRotationMatrix(float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n\n    return mat2(c, -s, s, c);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Centered, aspect ratio-corrected, normalized pixel coordinates [0.0, 1.0].\n       \n    vec2 normalizedCenteredUV = ((fragCoord / iResolution.xy) - 0.5) * 2.0;\n    \n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 uv = vec2(normalizedCenteredUV.x * aspectRatio, normalizedCenteredUV.y);\n            \n    // Get circle SDF -> clip 3x circles.\n            \n    float circleSDF = length(uv);\n    \n    const float ringWidth = 0.1;\n    const float innerCircleRadiusOffset = 0.05;\n    \n    float oneMinusRingWidth = 1.0 - ringWidth;\n    \n    // 2x circles used to generate outer ring.\n    \n    float circleA = step(circleSDF, 1.0);\n    float circleB = step(circleSDF, oneMinusRingWidth);\n        \n    float ring = circleA - circleB;\n    \n    // 1x circle used for the actual container/shell (as its mask).\n    \n    float fillMaskCircle = step(circleSDF, oneMinusRingWidth - innerCircleRadiusOffset);\n    \n    // Ring glow.\n        \n    float ringGlowCircleSDF = circleSDF - 1.0;\n    const float innerRingGlowRadiusOffset = 0.15;\n    \n    float innerRingGlow = ringGlowCircleSDF + innerRingGlowRadiusOffset;    \n    float outerRingGlow = ringGlowCircleSDF;   \n    \n    const float outerRingGlowWidth = 0.01;\n    float outerRingGlowPower = 0.8;\n    \n    const float innerRingGlowWidth = 0.01;\n    const float innerRingGlowPower = 1.2;\n    \n    const float outerRingGlowAnimation = 12.0;\n    const float outerRingGlowAnimationRange = 0.2;    \n    \n    innerRingGlow = pow(innerRingGlowWidth / innerRingGlow, innerRingGlowPower);\n    innerRingGlow = clamp(innerRingGlow - fillMaskCircle, 0.0, 1.0); \n    \n    outerRingGlowPower += (sin(iTime * outerRingGlowAnimation) * outerRingGlowAnimationRange);\n    \n    outerRingGlow = pow(outerRingGlowWidth / outerRingGlow, outerRingGlowPower);\n    outerRingGlow = clamp(outerRingGlow - fillMaskCircle, 0.0, 1.0);\n    \n    // Progress/fill. Animated.\n    \n    const float fillAnimationFrequency = 4.0;\n    const float fillAnimationAmplitude = 0.05;\n        \n    float fillAnimationPhase = iTime * fillAnimationFrequency;\n    \n    float fillAnimation = sin(fillAnimationPhase) * fillAnimationAmplitude;\n    \n    const float waveFrequency = 2.0;\n    const float waveAmplitude = 0.05;\n    \n    const float waveAnimation = 2.0;\n    \n    // Waves as repeating sine/band offsets to the horizontal gradient.\n    \n    float frontWavePhase = (iTime * waveAnimation) + uv.x;\n    float backWavePhase = (iTime * -waveAnimation) + uv.x;\n        \n    frontWavePhase *= waveFrequency;\n    backWavePhase *= waveFrequency;\n        \n    const float backWavesPhaseOffset = PI;\n    \n    float frontWaves = sin(frontWavePhase) * waveAmplitude;\n    float backWaves = sin(backWavePhase + backWavesPhaseOffset) * waveAmplitude;\n            \n    float verticalBand = sin(uv.x + (PI * 0.5)) - 0.3;\n    verticalBand = smoothstep(0.1, 0.9, verticalBand);\n   \n    // Stretch waves up/down near center, synced as they bob up/down.\n    \n    const float animatedVerticalBandStrength = 0.125;\n    float animatedVerticalBand = verticalBand * animatedVerticalBandStrength;\n            \n    animatedVerticalBand *= sin(iTime * fillAnimationFrequency);\n            \n    frontWaves += animatedVerticalBand;\n    backWaves -= animatedVerticalBand;\n    \n    // Pinch sides (mask by the vertical gradient band) so they don't move.\n    \n    fillAnimation *= verticalBand;\n            \n    // Centered fill progress.\n    // 0.0 = center, -0.5 = bottom, 0.5 = top.\n    \n    float fillProgressAnimationFrequency = 1.0;\n    float fillProgressAnimationAmplitude = 0.1;\n    \n    float fillProgress = -0.2;\n    \n    fillProgress += sin((iTime * fillProgressAnimationFrequency) * PI) * fillProgressAnimationAmplitude;\n    //fillProgress = (fillProgress - 0.5) * 2.0; \n    \n    float frontFill = step(uv.y, (fillAnimation + frontWaves) + fillProgress);\n    float backFill = step(uv.y, (-fillAnimation + backWaves) + fillProgress);\n    \n    frontFill *= fillMaskCircle;\n    backFill *= fillMaskCircle;\n    \n    // Mask back fill to only parts that would be visible separate from frontFill.\n    \n    backFill = clamp(backFill - frontFill, 0.0, 1.0);\n    \n    float fillMask = 1.0 - (frontFill + backFill);\n    fillMask *= fillMaskCircle;\n        \n    float fill = frontFill + backFill;\n    \n    // Simple edge glow using radial gradient (circle SDF).\n    \n    const float fresnelOffset = 0.01;\n    float fresnel = (circleSDF + fresnelOffset) * fillMask;    \n    \n    const float fresnelPower = 5.0;\n    fresnel = clamp(pow(fresnel, fresnelPower), 0.0, 1.0);\n    \n    const float frontFillFresnelPower = 5.0;\n    const float frontFillFresnelOffset = 0.02;\n    \n    float frontFillFresnel = (circleSDF + frontFillFresnelOffset) * (1.0 - fillMask);\n    frontFillFresnel = clamp(pow(frontFillFresnel, frontFillFresnelPower), 0.0, 1.0);\n    \n    // Specular reflection, drawn (stylized, like a cartoon) as two arcs.\n        \n    float specularArcAngle1 = radians(15.0);\n    float specularArcAngle2 = radians(2.0);\n    \n    float specularArcRotation1 = radians(60.0);\n    float specularArcRotation2 = radians(28.0);\n    \n    vec2 specularArcSC1 = vec2(sin(specularArcAngle1), cos(specularArcAngle1));\n    vec2 specularArcSC2 = vec2(sin(specularArcAngle2), cos(specularArcAngle2));\n    \n    const float specularArcOffset = 0.35;\n    const float specularArcWidth = 0.07;\n    \n    vec2 specularArcUV1 = Get2DRotationMatrix(specularArcRotation1) * uv;\n    vec2 specularArcUV2 = Get2DRotationMatrix(specularArcRotation2) * uv;\n    \n    float specularArc1 = sdArc(specularArcUV1, specularArcSC1, 1.0 - specularArcOffset, specularArcWidth);\n    float specularArc2 = sdArc(specularArcUV2, specularArcSC2, 1.0 - specularArcOffset, specularArcWidth);\n        \n    specularArc1 = step(specularArc1, 0.0);\n    specularArc2 = step(specularArc2, 0.0);\n    \n    const float specularStrength = 0.2;\n    float specular = specularArc1 + specularArc2;\n    \n    specular *= specularStrength;\n    \n    // Final mask. Can be used as alpha.\n    \n    float mask = ring + fill + fresnel + specular;\n    \n    // Per-mask RGB colour.\n    \n    const vec3 ringColour = vec3(1.0, 0.9, 0.8);\n    \n    const vec3 frontFillInnerColour = vec3(1.0, 0.2, 0.1);\n    const vec3 frontFillOuterColour = vec3(0.0, 0.0, 0.0);\n    \n    vec3 frontFillColour = mix(frontFillInnerColour, frontFillOuterColour, frontFillFresnel);\n    \n    const vec3 backFillColour = vec3(0.5, 0.0, 0.0);\n    \n    const vec3 specularColour = vec3(1.0, 1.0, 0.9);\n    const vec3 fresnelColour = vec3(0.5, 0.0, 0.3);\n    \n    const vec3 innerRingGlowColour = vec3(1.0, 0.3, 0.1);\n    const vec3 outerRingGlowColour = vec3(1.0, 0.8, 0.1);\n             \n    vec3 rgb =\n    \n        (ring * ringColour) +\n        \n        (innerRingGlow * innerRingGlowColour) +\n        (outerRingGlow * outerRingGlowColour) +\n        \n        \n        (frontFill * frontFillColour) +\n        (backFill * backFillColour) +\n        (fresnel * fresnelColour) +\n        (specular * specularColour);\n    \n    // Background gradient. Just for presentation.\n    \n    const float backgroundGradientPower = 0.6;\n    \n    float backgroundGradient = length(normalizedCenteredUV);\n    \n    backgroundGradient = pow(backgroundGradient, backgroundGradientPower);\n    backgroundGradient = smoothstep(0.0, 1.0, backgroundGradient);\n    \n    vec3 backgroundGradientInnerColour = vec3(0.13, 0.0, 0.4);\n    vec3 backgroundGradientOuterColour = vec3(0.0, 0.0, 0.0);\n    \n    vec3 background = mix(backgroundGradientInnerColour, backgroundGradientOuterColour, backgroundGradient);\n    \n    // Simply add the background to the composite so far.\n        \n    background = clamp(background - (fill + ring), 0.0, 1.0);\n         \n    const float backgroundStrength = 0.65;    \n    background *= backgroundStrength;\n    \n    rgb += background;\n    \n    // Output to screen.\n    \n    fragColor = vec4(rgb, mask);\n}","name":"Image","description":"","type":"image"}]}