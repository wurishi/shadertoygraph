{"ver":"0.1","info":{"id":"ftByz3","date":"1649983207","viewed":110,"name":"Lorenz and Aizawa Attractors","username":"Envy24","description":"Orthographic projection of Lorenz and Aizawa attractors.\n\nMouse.y - zoom in/out.\n\nMore attractors: http://www.3d-meier.de/tut19/Seite0.html","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["attractor","chaos","dynamic","lorenz"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    SC  - Screen Coordinates,\n    NDC - Normalized Device Coordinates.\n*/\n\n#define R                        iResolution\n#define CENTER_NDC(SC)         ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define NMY                    ( iMouse.y / R.y )                 // in range [0.0; 1.0]\n#define LMB_IS_HOLD            ( iMouse.z > 0.0 )\n\n#define TO_RAD                   0.017453292519943295        // Convert degrees to radians\n\n#define INITIALLY_FAR            9e30\n\nvec3 LorenzAttractor(in vec3 P)\n{\n    const float dt = 0.01;\n\tconst float SIGMA = 10.0;   // 1.0\n\tconst float RO = 28.0;     // 16.8\n\tconst float BETA = 8.0 / 3.0;\n\n    return vec3(\n        P.x + SIGMA * (P.y - P.x) * dt,\n\t\tP.y + (P.x * (RO - P.z) - P.y) * dt,\n\t\tP.z + (P.x * P.y - BETA * P.z) * dt\n    );\n}\n\nvec3 attractor0(in vec3 P)\n{\n    const float dt = 0.1;\n\tconst float SIGMA = 1.0;\n\tconst float RO = 16.8;\n\tconst float BETA = 8.0 / 3.0;\n\n    return vec3(\n        P.x + SIGMA * (P.y - P.x) * dt,\n\t\tP.y + (P.x * (RO - P.z) - P.y) * dt,\n\t\tP.z + (P.x * P.y - BETA * P.z) * dt\n    );\n}\n\nvec3 AizawaAttractor(in vec3 P)\n{\n    const float dt = 0.01;   \t\n    const float a = 0.95;\t\n    const float b = 0.7;\n    const float c = 0.6;\n    const float d = 3.5;\n    const float e = 0.25; \t\n    const float f = 0.1;\n    \n    return vec3(\n        P.x + ((P.z - b) * P.x - d * P.y) * dt,\n\t\tP.y + (d * P.x + (P.z - b) * P.y) * dt,\n\t\tP.z + (c + a * P.z - P.z* P.z*P.z/3.0 - (P.x*P.x + P.y*P.y)*(1.0 + e*P.z) + f * P.z * P.x*P.x*P.x) * dt\n    );\n}\n\nfloat scene(\n    in vec2 SC,\n    int attractor,  // 0, 1, 2\n    float zoom,\n    float speed)\n{\n    zoom = \n        LMB_IS_HOLD == true ? \n        NMY * 2.0 :\n        zoom;\n        \n    // FC - fragment center\n    vec2 FC = CENTER_NDC(SC) * 30.0 * zoom; // Map x,y from [0; R.x], [0; R.y] to [-30.0 * zoom; -30.0 * zoom] both.\n    \n    //FC.y += 25.0; // shift for static orthographic projection at XZ and YZ planes.\n    \n    vec3 P = vec3(1.0, 1.0, 1.0);         // Initial point coordinates\n    \n    float minSqDist = INITIALLY_FAR;\n    vec3 P_ = P;\n    \n    int numOfSteps = 2000;                // Number of steps = number of tested points\n    for (int s = 0; s < numOfSteps; ++s)\n    {\n        // Make step at attractor.\n        switch (attractor)\n        {\n        case 0: P = AizawaAttractor(P); break;\n        case 1: P = LorenzAttractor(P); break;\n        case 2: P = attractor0(P); break;\n        default: P = LorenzAttractor(P); break;\n        }\n        \n        /* Projections without rotation. *\n        vec2 O = P.xy; // Orthographic projection at XY plane\n        //vec2 O = P.xz; // Orthographic projection at XZ plane\n        //vec2 O = P.yz; // Orthographic projection at YZ plane\n        /* */\n         \n        /* Generalized projections (with rotations). */\n        vec3 T = P;\n        float t = iTime * speed;\n        T = rotateAroundZ(T, mod(t * 1.0, 360.0) * TO_RAD);\n        T = rotateAroundY(T, mod(t * 1.33, 360.0) * TO_RAD);\n        T = rotateAroundX(T, mod(t * 0.66, 360.0) * TO_RAD);   \n        vec2 O = T.xy;\n        /* */\n        \n        /* With feedback distortion. *\n        float t = iTime * speed;\n        P = rotateAroundZ(P, mod(t * 1.0, 360.0) * TO_RAD);\n        P = rotateAroundY(P, mod(t * 1.33, 360.0) * TO_RAD);\n        P = rotateAroundX(P, mod(t * 0.66, 360.0) * TO_RAD);   \n        vec2 O = P.xy;\n        /* */\n         \n        vec2 diff = FC - O;             // Difference between fragment center and projected point\n        float sqDist = dot(diff, diff);\n        minSqDist = min(minSqDist, sqDist);\n                \n        P_ = \n            minSqDist == sqDist ? // find closer point?\n                vec3(O, 0.0):     // save new coordinates\n                P_;               // save old coordinates\n    }    \n \n    return circleSQSDF(P_.xy, FC, 0.2 * zoom, 0.18 * zoom);\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{    \n    //O = vec4(scene(SC, 0, 0.05, 1.0)); // Aizawa attractor\n    O = vec4(scene(SC, 1, 1.5, 15.0)); // Lorenz attractor\n    //O = vec4(scene(SC, 2, 1.5, 3.0)); // Unknown attractor\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float circleSQSDF(\n    in vec2 S,           // sample coordinates\n    in vec2 C,           // circle center\n    in float r,          // circle radius\n    in float smoothness) // AA parameter\n{\n    // Sample coordinates relative to circle center.\n    float _x = S.x - C.x; float _y = S.y - C.y;\n    \n    // Signed distance of areas (squared distancies).\n    float sds = _x * _x + _y *_y - r * r;\n    \n    float ss = smoothness * smoothness;\n    \n    // Smoothstep interpolation.\n    return smoothstep(-ss, ss, sds);\n    //return smoothstep(-ss, ss, sds * sds); // outline\n}\n\nvec3 rotateAroundX(vec3 p, float a)\n{\n    float s = sin(-a);\n    float c = cos(-a);\n\n    return vec3(\n        p.x,\n        p.y * c + p.z * s,\n        p.z * c - p.y * s);\n}\n\nvec3 rotateAroundY(vec3 p, float a)\n{\n    float s = sin(-a);\n    float c = cos(-a);\n\n    return vec3(\n        p.x * c + p.z * s,\n        p.y,\n        p.z * c - p.x * s);\n}\n\nvec3 rotateAroundZ(vec3 p, float a)\n{\n    float s = sin(-a);\n    float c = cos(-a);\n\n    return vec3(\n        p.x * c + p.y * s,\n        p.y * c - p.x * s,\n        p.z);\n}","name":"Common","description":"","type":"common"}]}