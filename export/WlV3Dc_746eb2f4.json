{"ver":"0.1","info":{"id":"WlV3Dc","date":"1580097964","viewed":385,"name":"Clay ball","username":"onlinerocker","description":"Wanted to try and render something that resembled clay...\n","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["phong","raymarch","sdf","lighting","diffuse","clay"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Obj\n{\n    int r;\n\tfloat w;\n    vec3 col;\n    \n};\n\n//IQ - https://www.shadertoy.com/view/XsX3RB\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n#ifndef HIGH_QUALITY_NOISE\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0. ).yx;\n#else\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z);\n\tvec2 rg1 = textureLod( iChannel0, (uv+ vec2(0.5,0.5))/256.0, 0. ).yx;\n\tvec2 rg2 = textureLod( iChannel0, (uv+ vec2(1.5,0.5))/256.0, 0. ).yx;\n\tvec2 rg3 = textureLod( iChannel0, (uv+ vec2(0.5,1.5))/256.0, 0. ).yx;\n\tvec2 rg4 = textureLod( iChannel0, (uv+ vec2(1.5,1.5))/256.0, 0. ).yx;\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\n#endif\t\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n//https://www.shadertoy.com/view/4dS3Wd\nfloat fbm(vec3 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < 5; ++i) {\n\t\tv += a * noise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\nfloat map(vec3 p)\n{\n \treturn length(p) - 1.0;   \n}\n\nvec3 normal(vec3 p)\n{\n    float e = 0.01;\n    float x = map(p + vec3(e,0,0)) - map(p - vec3(e,0,0));\n    float y = map(p + vec3(0,e,0)) - map(p - vec3(0,e,0));\n    float z = map(p + vec3(0,0,e)) - map(p - vec3(0,0,e));\n    \n    return normalize(vec3(x,y,z));\n}\t\n\nObj mapBump(vec3 p)\n{\n    int r = 0;\n    vec3 col = vec3(0,0.55,0.9);\n    float minD = 1000.0;\n    vec3 pBall = p + normal(p)*0.02*fbm(p*5.0);\n    \n    float d = length(pBall) - 1.0;\n    if(d < minD)\n    {\n     \tminD = d;\n    }  \n    \n    d = p.y + 1.0;\n    if(d < minD)\n    {\n     \tminD = d;\n        col = vec3(2);\n        r = 1;\n    }\n    \n    Obj o;\n    o.w = minD;\n    o.col = col;\n    o.r = r;\n    return o;\n}\n\n\nvec3 normalBump(vec3 p)\n{\n    float e = 0.01;\n    float x = mapBump(p + vec3(e,0,0)).w - mapBump(p - vec3(e,0,0)).w;\n    float y = mapBump(p + vec3(0,e,0)).w - mapBump(p - vec3(0,e,0)).w;\n    float z = mapBump(p + vec3(0,0,e)).w - mapBump(p - vec3(0,0,e)).w;\n    \n    return normalize(vec3(x,y,z));\n}\t\n\nvec3 calcSpecLight(vec3 p, vec3 light, vec3 cam, vec3 normal, float specKs, float specVal)\n{\n\tvec3 dir = normalize(light - p);\n    vec3 viewDir = normalize(cam - p);\n    vec3 specR = 2.0*clamp( dot(normal, dir), 0.0, 1.0) * normal - dir;\n    float spec = clamp( dot(viewDir, specR), 0.0, 1.0);\n\n    vec3 col = specKs*(vec3(1)*pow(spec, specVal));\n    return col;\n}\n\nvec3 refCol(vec3 p, vec3 dir)\n{\n    vec3 o = p;\n    vec3 col = vec3(0);\n    float d = 0.01;\n    vec3 light = vec3(-1.5,0,-5);\n    for(int x=0; x<10; x++)\n    {\n        p = o + dir*d;\n     \tObj map = mapBump(p);   \n        if(abs(map.w) < 0.01)\n        {\n            vec3 norm =normalBump(p);\n            float z = clamp(-length(o.xz), -1., 0.0);\n            float val = smoothstep(-1., 0.0, z);\n            //val = clamp(val, 0.0, 1.0);\n            col += mix(vec3(0), map.col * dot(norm, normalize(light-p)), val);\n            col *= 2.5;\n            break;\n        }\n        d += map.w;\n    } \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n\n    float d = 0.01;\n    vec3 cam = vec3(0,0,-2);\n    vec3 dir = vec3(uv,1);\n    vec3 p;\n    vec3 light = vec3(-1.5,0,-5);\n\n    for(int x=0; x<60; x++)\n    {\n        p = cam + dir*d;\n     \tObj map = mapBump(p);   \n        if(map.w < 0.01)\n        {\n            vec3 norm = normalBump(p);\n            if(map.r < 1)\n            {\n            \tcol = map.col * dot(norm, normalize(light-p));\n                col += calcSpecLight(p, light, cam, norm, 0.3, 2.0);\n            \t\n        \t}else\n                col = refCol(p, norm);\n            break;\n        }\n        d += map.w;\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}