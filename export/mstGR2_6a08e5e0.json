{"ver":"0.1","info":{"id":"mstGR2","date":"1677571463","viewed":136,"name":"blue perlin noise?","username":"Carandiru","description":"blue noise single octave perlin noise with seed *experimental*","likes":1,"published":3,"flags":0,"usePreview":0,"tags":["perlin"],"hasliked":0,"parentid":"cdtGzj","parentname":"Variable Size Perlin Noise"},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define u_octaveCount 6\n\n// implementation of MurmurHash (https://sites.google.com/site/murmurhash/) for a \n// single unsigned integer.\n\nuint hash(uint x, uint seed) {\n\n    return uint(texelFetch(iChannel0, ivec2(x ^ (seed)) & 1023, 0).r * 65535.0f);\n    /*\n    const uint m = 0x5bd1e995U;\n    uint hash = seed;\n    // process input\n    uint k = x;\n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n    // some final mixing\n    hash ^= hash >> 13;\n    hash *= m;\n    hash ^= hash >> 15;\n    return hash;\n    */\n}\n\n// implementation of MurmurHash (https://sites.google.com/site/murmurhash/) for a  \n// 2-dimensional unsigned integer input vector.\n\nuint hash(uvec2 x, uint seed){\n\n    return uint(texelFetch(iChannel0, ivec2(x ^ (seed)) & 1023, 0).r * 65535.0f);\n    //return uint(textureLod(iChannel0, (vec2(x ^ (seed >> 16u)) + 0.5f) / 1024.0f, 0.0f).r * 65535.0f);\n    /*const uint m = 0x5bd1e995U;\n    uint hash = seed;\n    // process first vector element\n    uint k = x.x; \n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n    // process second vector element\n    k = x.y; \n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n\t// some final mixing\n    hash ^= hash >> 13;\n    hash *= m;\n    hash ^= hash >> 15;\n    return hash;*/\n}\n\n\nvec2 gradientDirection(uint hash) {\n    switch (int(hash) & 3) { // look at the last two bits to pick a gradient direction\n    case 0:\n        return vec2(1.0, 1.0);\n    case 1:\n        return vec2(-1.0, 1.0);\n    case 2:\n        return vec2(1.0, -1.0);\n    case 3:\n        return vec2(-1.0, -1.0);\n    }\n}\n\nfloat interpolate(float value1, float value2, float value3, float value4, vec2 t) {\n    return mix(mix(value1, value2, t.x), mix(value3, value4, t.x), t.y);\n}\n\nvec2 fade(vec2 t) {\n    // 6t^5 - 15t^4 + 10t^3\n\treturn t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\nfloat perlinNoise(vec2 position, uint seed) {\n    vec2 floorPosition = floor(position);\n    vec2 fractPosition = position - floorPosition;\n    uvec2 cellCoordinates = uvec2(floorPosition);\n    \n    float value1 = dot(round(vec2(hash(cellCoordinates, seed))/65535.0f) * 2.0f - 1.0f, fractPosition);\n    float value2 = dot(round(vec2(hash(cellCoordinates + uvec2(1,0), seed))/65535.0f) * 2.0f - 1.0f, fractPosition - vec2(1.0, 0.0));\n    float value3 = dot(round(vec2(hash(cellCoordinates + uvec2(0,1), seed))/65535.0f) * 2.0f - 1.0f, fractPosition - vec2(0.0, 1.0));\n    float value4 = dot(round(vec2(hash(cellCoordinates + uvec2(1,1), seed))/65535.0f) * 2.0f - 1.0f, fractPosition - vec2(1.0, 1.0));\n    return interpolate(value1, value2, value3, value4, fade(fractPosition));\n}\n\nfloat perlinNoise(vec2 position,float scale, float frequency, float persistence, float lacunarity, uint seed) {\n    float value = 0.0;\n    float amplitude = 1.0;\n    float currentFrequency = float(frequency);\n    uint currentSeed = seed;\n    \n//replace this with a uniform array index!!!    \n    for(int i = 0; i < int(floor(scale)); ++i)\n    {\n        currentSeed = hash(currentSeed, 0x0U);\n    }\n\n    currentFrequency *= pow(lacunarity, floor(scale));\n\n    currentSeed = hash(currentSeed, 0x0U);\n    value += perlinNoise(position * currentFrequency, currentSeed) * amplitude * (1.0 - fract(scale));\n    amplitude = mix(amplitude, amplitude * persistence, 1.0 - fract(scale));\n    currentFrequency *= lacunarity;\n    \n    for (int i = 1; i < u_octaveCount; i++)\n    {\n        currentSeed = hash(currentSeed, 0x0U);\n        value += perlinNoise(position * currentFrequency, currentSeed) * amplitude;\n        amplitude *= persistence;\n        currentFrequency *= lacunarity;\n    }\n \n    currentSeed = hash(currentSeed, 0x0U);\n    value += perlinNoise(position * currentFrequency, currentSeed) * amplitude * (fract(scale));\n\n    return value;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 position = fragCoord / iResolution.xy;\n    vec2 uv = position;\n    position.x *= iResolution.x / iResolution.y;\n    //position += iTime * 0.25f;\n    uint seed = 0x1U + (uint(iTime * 3.5f)); // can be set to something else if you want a different set of random values\n    float frequency = (1.0f+iTime*iTime);\n    float value = perlinNoise(position * frequency, seed); // single octave perlin noise\n    //float value = perlinNoise(position, uv.x * 6.0f, 1.0f, 0.5, 2.0, seed); // multiple octaves\n    value = value * 0.5f + 0.5f; // convert from range [-1, 1] to range [0, 1]\n    fragColor = vec4(vec3(value), 1.0);\n}","name":"Image","description":"","type":"image"}]}