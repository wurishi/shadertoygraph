{"ver":"0.1","info":{"id":"ldBBWy","date":"1510152100","viewed":145,"name":"asdf test2","username":"yumcyawiz","description":".test","likes":5,"published":1,"flags":48,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 dmin(vec2 d1, vec2 d2) {\n    if(d1.x < d2.x) {\n        return d1;\n    }\n    else {\n        return d2;\n    }\n}\n\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\nfloat sdPlane(vec3 p, vec4 n) {\n    return dot(p, n.xyz) + n.w;\n}\nvec2 DF(vec3 p) {\n    vec2 d = vec2(sdPlane(p - vec3(0, -2, 0), vec4(0, 1, 0, 1)), 1);\n    p = mod(p, 4.0) - 2.0;\n    d = dmin(d, vec2(sdSphere(p, 1.0) + 0.05*sin(20.0*p.x)*sin(20.0*p.y)*sin(20.0*p.z), 2));\n    return d;\n}\n\n\nvec3 calcNormal(vec3 p) {\n    float eps = 0.001;\n    return normalize(vec3(\n        DF(p + vec3(eps, 0, 0)).x - DF(p + vec3(-eps, 0, 0)).x,\n        DF(p + vec3(0, eps, 0)).x - DF(p + vec3(0, -eps, 0)).x,\n        DF(p + vec3(0, 0, eps)).x - DF(p + vec3(0, 0, -eps)).x\n    ));\n}\n\n\nstruct Ray {\n    bool hit;\n    vec3 hitPos;\n    vec3 hitNormal;\n    int steps;\n    float t;\n    float hitObj;\n};\n    \n    \nconst int maxSteps = 100;\nRay trace(vec3 from, vec3 rayDir) {\n    bool hit = false;\n    vec3 hitPos = vec3(0);\n    vec3 hitNormal = vec3(0);\n    int steps = 0;\n    float hitObj = 0.0;\n    float t = 0.1;\n    for(int i = 0; i < maxSteps; i++) {\n        vec3 p = from + t*rayDir;\n        float d = DF(p).x;\n        if(d < 0.001) {\n            hit = true;\n            hitPos = p;\n            hitNormal = calcNormal(p);\n            steps = i;\n            hitObj = DF(p).y;\n            break;\n        }\n        t += d;\n    }\n    return Ray(hit, hitPos, hitNormal, steps, t, hitObj);\n}\n\n\nfloat softShadow(vec3 hitPos, vec3 lightPos, float k) {\n    vec3 lightDir = normalize(lightPos - hitPos);\n    float t = 1.0;\n    float ss = 0.0;\n    for(int i = 0; i < 100; i++) {\n        vec3 p = hitPos + t*lightDir;\n        float d = DF(p).x;\n        if(d < 0.001 && distance(lightPos, p) > 1.0) {\n            return 0.0;\n        }\n        ss += d * k/t;\n    }\n    return clamp(ss, 0.0, 1.0);\n}\n\n\nfloat SSS(vec3 hitPos, vec3 hitNormal, float k) {\n    float sss = 0.0;\n    for(int i = 1; i <= 5; i++) {\n        float d1 = float(i)/float(5) * k;\n        vec3 p = hitPos + d1*(-hitNormal);\n        sss += exp(-d1) * (d1 - abs(DF(p).x));\n    }\n    sss = clamp(sss, 0.0, 1.0);\n    return sss;\n}\n\n\nvec3 checkerboard(float u, float v) {\n    float interval = 1.0;\n    u = floor(u/interval*2.0);\n    v = floor(v/interval*2.0);\n    float p = mod(u + v, 2.0);\n    return vec3(0.1 + 0.9*p);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.0*fragCoord.xy - iResolution.xy)/iResolution.y;\n    vec2 mouse = (2.0*iMouse.xy - iResolution.xy)/iResolution.xy;\n    \n    vec3 camPos = texture(iChannel0, fragCoord.xy/iResolution.xy).xyz;\n    float theta1 = -(mouse.x + 1.0)/2.0*3.14*2.0 + 3.14/2.0;\n    float theta2 = -(mouse.y + 1.0)/2.0*3.14;\n    vec3 camFront = normalize(vec3(cos(theta1)*sin(theta2), cos(theta2), sin(theta1)*sin(theta2)));\n    vec3 camRight = normalize(cross(vec3(0, 1, 0), camFront));\n    vec3 camUp = -cross(camRight, camFront);\n    vec3 rayDir = normalize(2.0*camFront + uv.x*camRight + uv.y*camUp);\n    \n    vec3 lightPos = vec3(cos(iTime), sin(iTime) + 0.5, 5.0 + sin(iTime));\n    \n    vec3 color = vec3(0);\n    Ray tr = trace(camPos, rayDir);\n    if(tr.hit) {\n        float sAO = 1.0 - float(tr.steps)/float(maxSteps);\n        float ss = softShadow(tr.hitPos, lightPos, 0.1);\n        float geo = 20.0 / pow(distance(tr.hitPos, lightPos), 2.0);\n        vec3 lightDir = normalize(lightPos - tr.hitPos);\n        float diffuse = max(dot(tr.hitNormal, lightDir), 0.0);\n        float specular = pow(max(dot(-rayDir, reflect(-lightDir, tr.hitNormal)), 0.0), 8.0);\n        float sss = SSS(tr.hitPos, tr.hitNormal, 0.1);\n        \n        vec3 mat = vec3(0);\n        if(tr.hitObj == 2.) {\n            mat = (tr.hitNormal + 1.0)/2.0;\n            color = 0.9 * geo * ss * (0.9*diffuse*mat + 0.1*specular*vec3(1) + sss*mat) +  0.1*sAO * mat;\n        }\n        else if(tr.hitObj == 1.) {\n            mat = checkerboard(tr.hitPos.x, tr.hitPos.z);\n            color = 0.9*geo*ss* (0.9*diffuse*mat + 0.1*specular*vec3(1)) + 0.1*sAO*mat;\n        }\n        \n        float fog = exp(-0.05*tr.t);\n        color *= fog;\n    }\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\n\nconst int KEY_W = 87;\nconst int KEY_A = 65;\nconst int KEY_S = 83;\nconst int KEY_D = 68;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = (2.0*iMouse.xy - iResolution.xy)/iResolution.y;\n    float theta1 = -(mouse.x + 1.0)/2.0*3.14*2.0 + 3.14/2.0;\n    float theta2 = -(mouse.y + 1.0)/2.0*3.14;\n    vec3 camFront = normalize(vec3(cos(theta1)*sin(theta2), cos(theta2), sin(theta1)*sin(theta2)));\n    vec3 camRight = normalize(cross(vec3(0, 1, 0), camFront));\n    vec3 camUp = -cross(camRight, camFront);\n    \n    vec3 camPos = texture(iChannel1, vec2(0)).xyz;\n    if(texelFetch(iChannel0, ivec2(KEY_W, 1), 0).x > 0.0) {\n        camPos += 0.1*camFront;\n    }\n    if(texelFetch(iChannel0, ivec2(KEY_A, 1), 0).x > 0.0) {\n        camPos += -0.1*camRight;\n    }\n    if(texelFetch(iChannel0, ivec2(KEY_S, 1), 0).x > 0.0) {\n        camPos += -0.1*camFront;\n    }\n    if(texelFetch(iChannel0, ivec2(KEY_D, 1), 0).x > 0.0) {\n        camPos += 0.1*camRight;\n    }\n        \n    fragColor = vec4(camPos, 0);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame == 0) {\n    \tfragColor = vec4(0.0,0.0,-5.0,1.0);\n    }\n    else {\n        fragColor = texture(iChannel0, vec2(0));\n    }\n}","name":"Buf B","description":"","type":"buffer"}]}