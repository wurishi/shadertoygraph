{"ver":"0.1","info":{"id":"dsKBWG","date":"1698617849","viewed":51,"name":"231028_fractal","username":"anonymousAntelope","description":"Just followed a youtube tutorial to get the basics down","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["fractal","test","tutorial"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec3 palette(float distance) {\n\n    vec3 a = vec3(0.5);\n    vec3 b = vec3(0.5);\n    vec3 c = vec3(1.0);\n    vec3 d = vec3(0.263, 0.416, 0.557);\n    \n    //vec3 a = vec3(0.8);\n    //vec3 b = vec3(10.5);\n    //vec3 c = vec3(10);\n    //vec3 d = vec3(0.2, 0.416, 0.557);\n    \n    return a + b * cos( 6.28318*(c*distance+d) );\n\n}\n\nfloat slowdown = 0.5;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    //float slowdown = sin(iTime / (iTime * 0.4));\n    // the number changed to below 0.4 makes it go in reverse\n    //float slowdown = sin(iTime / (iTime * 0.25));\n\n    \n    \n    // 1.\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n\n    \n    // 2.\n    // subtracting 0.5 from uv will shift the 0.0 \n    // position to the cetner of the canvas\n    uv = uv - 0.5;\n    \n    // 14. \n    // Save a copy of the original centered UVs so we always have a reference to the center\n    vec2 uvOriginal = uv;\n    \n    // 3.\n    // Now the uv ranges from -0.5 to 0.5\n    // Double the uv to ensure the values \n    // range from -1.0 to 1.0\n    //uv = uv * 2.0;\n    \n    // 4.\n    // If the canvas is not a square, renders will be distorted\n    // because of the clip space ranging between -1 and 1 on the x axis.\n    // To fix this, multiply the x component of the uv by the \n    // aspect ratio of the canvas\n    uv.x *= iResolution.x / iResolution.y;\n    \n    \n    // 15.\n    // By including everything in a for loop\n    // we can perform iterations\n    vec3 finalColor = vec3(0.0);\n    \n    for (float i = 0.0; i < 2.0; i += 0.6) {\n        // 12. fract(value)\n        // returns the fractional component of a value\n        // eg: value of 1.25 will return 0.25;\n        // this can be used in conjunction with UVs to create tiled effects\n        uv = fract(uv * 1.2);\n\n        // 13.\n        // to get each circle's centre appearing in the center of the tile, subtract 0.5 from the uv\n        uv = uv - 0.5;\n\n        // 5.\n        // length(uv) - calculates the magnitude of a vector\n        // calculates the distance between a point and the \n        // origin(center of canvas)\n        float distance = length(uv);\n        \n        float originalDistance = distance;\n        \n        // 16. \n        // Multiplying distance by an exponential function \n        distance = distance * exp(-length(uvOriginal));\n\n        // 10.\n        // Can set a static colour\n        // vec3 color = vec3(1.0, 1.5, 3.0);\n\n        // or can use a palette function\n        // this will change the colours based on how close the circle is to the centre\n        // vec3 color = palette(distance);\n\n        // Can add the time to the distance to increase dynamism\n        // vec3 color = palette(distance + iTime * slowdown);\n\n        // or you can use the distance of the orignal uvs to \n        // calculate the colours based on the centre of the whole canvas\n        vec3 color = palette(length(uvOriginal) + i * slowdown  + iTime * slowdown);\n\n\n        // 6.\n        // Creates a circle of radius 0.5\n        // The values are positive outside the circle\n        // and negative inside the circle\n        // distance -= 0.5; \n\n        // can also do this to repeat the circles\n        // distance = sin(distance * 8.0) / 8.0;\n\n        // can also animate the circles\n        distance = sin(distance * 8.0 + iTime * slowdown) / 8.0;\n\n        // 7.\n        // abs function changes any negative value to a positive\n        distance = abs(distance);\n\n        // 8.\n        // step(threshold, value)\n        // If the value is below the threshold, the output is 0.0\n        // If the value is above the threshold, the output is 1.0\n        // distance = step(0.1, distance);\n\n        // 9.\n        // smoothstep(lower, upper, value)\n        // if the value is below the lower threshold, the output is 0.0\n        // if the value is above the upper threshold, the output is 1.0\n        // if the anything in between is interpolated between 0.0 and 1.0\n        //distance = smoothstep(0.97, 1.0 , distance);\n        //distance = smoothstep(0.1, 0.2, distance);\n\n        // Can also take the inverse of distance to create the color\n        distance = 0.01 / distance / 2.0;\n        \n        // can also use pow() to change the contrast of the image\n        //distance = pow(0.015 / distance, 1.3);\n\n        // 11.\n        // Can create vibrant colours by multiplying the distance\n        // by a colour on certain channels\n        finalColor += color * distance;\n        \n        // trying to make the colours disappear on the edges of the screen\n        //float colorReduction = smoothstep(0.5, 0.9, 1.0-length(uvOriginal));\n        //finalColor *= colorReduction;\n        \n        // or make the colors less intense in the center of the screen\n        //float colorReduction = smoothstep(0.5, 1.0, 1.0-length(uvOriginal));\n        //finalColor -= colorReduction * 5.0;\n        \n        // or make the colors less intense on the edges of the screen\n        //float colorReduction = smoothstep(-0.05, 1.0, length(uvOriginal));\n        //finalColor -= colorReduction * 5.0;\n        \n        //finalColor -= 0.2;\n        \n    }\n\n    // Output to screen\n    fragColor = vec4(finalColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}