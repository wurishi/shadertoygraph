{"ver":"0.1","info":{"id":"ct2XWW","date":"1676078207","viewed":70,"name":"Perpendicular Julia Morph","username":"Mandelbrot837","description":"A collection of Julia Fractals for the Perpendicular Mandelbrot.  The formula itself is slowly rotating.\nFeel free to modify the constants from line 67 to 75.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["fractal","mandelbrot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Palette\n\nstruct palette {\n    vec3 c0, c1, c2, c3, c4, c5;\n};\n\npalette blue() {\n    palette p;\n    p.c0 = vec3(0,0,0)/255.;\n    p.c1 = vec3(0,0,140)/255.;\n    p.c2 = vec3(0,0,255)/255.;\n    p.c3 = vec3(140,140,255)/255.;\n    p.c4 = vec3(192,192,255)/255.;\n    p.c5 = vec3(255,255,255)/255.;\n    return p;\n}\n\npalette green() {\n    palette p;\n    p.c0 = vec3(0,0,0)/255.;\n    p.c1 = vec3(0,140,0)/255.;\n    p.c2 = vec3(0,255,0)/255.;\n    p.c3 = vec3(140,255,140)/255.;\n    p.c4 = vec3(192,255,192)/255.;\n    p.c5 = vec3(255,255,255)/255.;\n    return p;\n}\n\npalette red() {\n    palette p;\n    p.c0 = vec3(0,0,0)/255.;\n    p.c1 = vec3(140,0,0)/255.;\n    p.c2 = vec3(255,0,0)/255.;\n    p.c3 = vec3(255,140,140)/255.;\n    p.c4 = vec3(255,192,192)/255.;\n    p.c5 = vec3(255,255,255)/255.;\n    return p;\n}\n\n// Random\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat randSeed = 0.;\nvec2 nextRand2() {\n    vec2 v = vec2( randSeed++, randSeed++ );\n\treturn vec2( random( v+0.34 ), random( v+0.75 ) );    \n}\n\n// Mapping\n\nvec3 cmap( float t, palette p ) {\n    vec3 col = vec3(0);\n    col = mix( p.c0,  p.c1, smoothstep(0. , .2, t));\n    col = mix( col, p.c2, smoothstep(.2, .4 , t));\n    col = mix( col, p.c3, smoothstep(.4 , .6, t));\n    col = mix( col, p.c4, smoothstep(.6,  .8, t));\n    col = mix( col, p.c5, smoothstep(.8, 1.,  t));\n    col = sqrt(sqrt(col));\n    return col;\n}\n\n#define MAX_ITER 512.\n#define THRESHOLD 4096.\n#define VARIATION_FACTOR 0.625\n#define SPEED 1.0\n#define ILLUMINATION_FACTOR 0.03125\n#define ILLUMINATION_POWER 0.8\n#define RAINBOW_FACTOR 0.4\n#define ROTATE_SPEED 0.003\n#define CENTER vec2(-0.5,0)\n\n// The rotate speed controls how fast the formula rotates.\n\nfloat pbrot(vec2 uv, float time) {\n    float angle = time * ROTATE_SPEED;\n    vec2 zmul = vec2(cos(angle),sin(angle));\n    \n    // z = ( |Re(z)| + i|Im(z)| )^2\n    \n\tvec2 c = vec2(VARIATION_FACTOR*(sin(0.1073*iTime*SPEED)-0.8*sin(0.1238*iTime*SPEED)+0.3*sin(0.0592*iTime*SPEED)),\n        VARIATION_FACTOR*(sin(0.1636*iTime*SPEED)+0.8*sin(0.1433*iTime*SPEED)-0.4*sin(0.05781*iTime+SPEED))); \n    c += CENTER;\n    vec2 z = 3.*(uv - vec2(0,0));\n    float cinterior = 0.;\n    float i = 0.;\n    \n    for(; ++i <= MAX_ITER ;) {\n        cinterior += ILLUMINATION_FACTOR / dot(z,z);\n        if(z.x > 0. && true)\n        {\n            z = vec2(z.x, -z.y);\n        }\n        \n        if(false)\n        {\n            z = abs(z);\n        }\n        \n        z = mat2(z, -z.y, z.x) * z + c;\n        \n        z = vec2((z.x * zmul.x) - (z.y * zmul.y),\n                 (z.x * zmul.y) + (z.y * zmul.x));\n    \tif( dot(z,z) > THRESHOLD ) break;\n\t}\n\n    return pow(cinterior,ILLUMINATION_POWER);\t    \n}\n\n// Main\n\n#define SAMPLES 6.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 R = iResolution.xy;\n    float rb = mod(iTime * RAINBOW_FACTOR,1.0);\n    \n    vec3 rcol = vec3(0);\n    vec3 gcol = vec3(0);\n    vec3 bcol = vec3(0);\n    \n    palette r = red();\n    palette s = r;\n    palette g = green();\n    palette b = blue();\n    \n    r.c1 = mix(r.c1, g.c1,smoothstep(0.,0.33333333,rb));\n    r.c1 = mix(r.c1, b.c1,smoothstep(0.33333333,0.66666667,rb));\n    r.c1 = mix(r.c1, s.c1,smoothstep(0.66666667,1.,rb));\n    r.c2 = mix(r.c2, g.c2,smoothstep(0.,0.33333333,rb));\n    r.c2 = mix(r.c2, b.c2,smoothstep(0.33333333,0.66666667,rb));\n    r.c2 = mix(r.c2, s.c2,smoothstep(0.66666667,1.,rb));\n    r.c3 = mix(r.c3, g.c3,smoothstep(0.,0.33333333,rb));\n    r.c3 = mix(r.c3, b.c3,smoothstep(0.33333333,0.66666667,rb));\n    r.c3 = mix(r.c3, s.c3,smoothstep(0.66666667,1.,rb));\n    r.c4 = mix(r.c4, g.c4,smoothstep(0.,0.33333333,rb));\n    r.c4 = mix(r.c4, b.c4,smoothstep(0.33333333,0.66666667,rb));\n    r.c4 = mix(r.c4, s.c4,smoothstep(0.66666667,1.,rb));\n\n    for(float i=0.; i < SAMPLES; i++) {\n        vec2 p = 0.5*(2.*fragCoord-R+nextRand2())/R.y ;\n        p.y = -p.y;\n        float orbit = pbrot(p, iTime) / MAX_ITER;\n    \trcol += cmap( orbit   , r); \n        gcol += cmap( orbit   , g); \n        bcol += cmap( orbit   , b); \n    }\n    \n    rcol *= (1./SAMPLES);\n    gcol *= (1./SAMPLES);\n    bcol *= (1./SAMPLES);\n    \n    vec3 col = rcol;\n    \n    col = mix(col, gcol, smoothstep(0., 0.333333, mod(rb, 1.)));\n    col = mix(col, bcol, smoothstep(0.333333, 0.666667, mod(rb, 1.)));\n    col = mix(col, rcol, smoothstep(0.666667, 1., mod(rb, 1.)));\n\n    fragColor = vec4(rcol, 1.);\n}","name":"Image","description":"","type":"image"}]}