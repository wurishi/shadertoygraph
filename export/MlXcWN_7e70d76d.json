{"ver":"0.1","info":{"id":"MlXcWN","date":"1505412564","viewed":192,"name":"Audio Image","username":"DjinnKahn","description":"Proof-of-concept: Displaying a 640x360 image encoded in audio.\n","likes":5,"published":1,"flags":64,"usePreview":0,"tags":["audio","image","photograph"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"MssSWX","filepath":"https://soundcloud.com/tom-sirgedas/test26","previewfilepath":"https://soundcloud.com/tom-sirgedas/test26","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Proof-of-concept: Displaying a 640x360 image encoded in audio (by Tom Sirgedas)\n\n// This might not work for everyone. Even on my machine, I often need to hit the \"Reset Time\"\n// button, if the image starts coming in a bit scrambled. [Update: It now works every time for me, \n// but image quality varies]\n\n// ** Explanation: **\n\n// Each frame, we'll receive 512 samples of (NOISY!) wave data from the audio stream (iChannel0).\n// Consecutive frames will NOT continue the wave data from the previous frame. In fact,\n// the sample offset will jump an average of exactly 800 samples between frames.\n// This is because 800 samples * 60 fps => 48000 samples/sec of audio data (48000Hz mono audio)\n\n// So, there are gaps in the wave data. Also, consecutive frames aren't exactly 800 samples apart.\n// They randomly seem to be 384, 512, 640, 768, 896, or 1024 samples apart. (The \"jitter\")\n\n// My approach is to create the wave data in \"packets\" of 200 samples. Each packet is repeated \n// 4 times, to work around the \"jitter\". Each packet starts with 14 samples like 00001111110000.\n// The rest of the packet is the payload, and I scale it so that the payload samples don't exceed\n// .75. Now, when we get 512 samples from iChannel0, we can find the sync point, and display the\n// payload.\n\n// The payloads are just 186 consecutive pixels of the image, with 4 consecutive payloads forming\n// one row of the output image. 4 payloads = 4 frames = 1 row. So, 360 rows means 360*4 frames,\n// which is 360*4/60 seconds (24 seconds) to load the whole image. [Update: switched this to\n// column-major order, and trimmed the last 6 values of the payload] [Update: last 6 samples of\n// payload are now discarded, since they tend to be garbage]\n\n\nfloat AUDIO_LEVEL( int pos )\n{\n \treturn texelFetch( iChannel0, ivec2( pos, 1 ), 0 ).r;\n}\n\nfloat syncScore( int pos )\n{\n    return AUDIO_LEVEL( pos )   * -2.0\n        \n         + AUDIO_LEVEL( pos+2 ) *  1.0 \n         + AUDIO_LEVEL( pos+3 ) *  1.0\n         + AUDIO_LEVEL( pos+4 ) *  1.0\n         + AUDIO_LEVEL( pos+5 ) *  1.0\n         + AUDIO_LEVEL( pos+6 ) *  1.0\n        \n         + AUDIO_LEVEL( pos+8 ) * -2.0;\n}\n\nint findSyncOffset()\n{        \n    int bestX = -99999;\n    float bestScore = 2.5;\n    \n    for ( int x = 0; x < 200; x++ )\n    {\n        float score = syncScore( x );\n        if ( syncScore( x ) > bestScore )\n        {\n            bestX = x;\n            bestScore = score;\n        }\n    }\n        \n    return bestX;\n}\n\nvoid decodeImages( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 POS = ivec2( fragCoord );\n    int PANEL_ROTATION = 1; // rotates the 4 vertical panels, not sure why, but 1 works best for me\n    int packetIndex = int( iChannelTime[0] * 60. ) + PANEL_ROTATION;\n    int PAYLOAD_SIZE = 180;\n    int SYNC_DATA_SIZE = 14;\n    int startX = packetIndex / 360 % 4 * PAYLOAD_SIZE;\n    int startY = packetIndex % 360;\n    \n    if ( startX / PAYLOAD_SIZE != POS.x / PAYLOAD_SIZE )\n        discard;\n    //if ( POS.y < startY )\n    if ( POS.y != startY && POS.y != startY+1 )\n        discard;\n    \n    int offsetInPacket = POS.x - startX;\n      \n    int syncOffset = findSyncOffset();        \n    float val = AUDIO_LEVEL( offsetInPacket + syncOffset + SYNC_DATA_SIZE );\n    \n    fragColor = vec4( val ) / .75;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{                \n    if ( iChannelTime[0] < .02 ) { fragColor = vec4( 0. ); return; } // clear\n    \n    decodeImages( fragColor, fragCoord );\n}\n\n//void decodeImagesButShowSyncData( out vec4 fragColor, in vec2 fragCoord )\n//{\n//    ivec2 POS = ivec2( fragCoord );\n//    int PANEL_ROTATION = 1; // rotates the 4 vertical panels, not sure why, but 1 works best for me\n//    int packetIndex = int( iChannelTime[0] * 60. ) + PANEL_ROTATION;\n//    int PAYLOAD_SIZE = 200;\n//    int SYNC_DATA_SIZE = 0;\n//    int startX = packetIndex / 360 % 4 * PAYLOAD_SIZE;\n//    int startY = packetIndex % 360;\n//    \n//    if ( startX / PAYLOAD_SIZE != POS.x / PAYLOAD_SIZE )\n//        discard;\n//    if ( POS.y != startY && POS.y != startY+1 )\n//        discard;\n//    \n//    int offsetInPacket = POS.x - startX;\n//      \n//    int syncOffset = findSyncOffset();        \n//    float val = AUDIO_LEVEL( offsetInPacket + syncOffset + SYNC_DATA_SIZE );\n//    \n//    fragColor = vec4( val ) / .75;\n//}\n//\n//void showRawSyncData( out vec4 fragColor, in vec2 fragCoord )\n//{\n//    ivec2 POS = ivec2( fragCoord );\n//    int packetIndex = int( iChannelTime[0] * 60. );\n//    int PAYLOAD_SIZE = 200;\n//    int SYNC_DATA_SIZE = 0;\n//    int startX = packetIndex % 1 * PAYLOAD_SIZE;\n//    int startY = packetIndex / 1 % 360;\n//    \n//    if ( POS.y != startY )\n//        discard;\n//    \n//    int offsetInPacket = POS.x - startX;\n//      \n//    int syncOffset = findSyncOffset();        \n//    float val = AUDIO_LEVEL( offsetInPacket + syncOffset + SYNC_DATA_SIZE );\n//    \n//    fragColor = vec4( val ) / .75;\n//}\n//\n//void showRawData( out vec4 fragColor, in vec2 fragCoord )\n//{\n//    ivec2 POS = ivec2( fragCoord );\n//    int packetIndex = int( iChannelTime[0] * 60. );\n//    int startY = packetIndex % 360;\n//    \n//    if ( POS.y != startY )\n//        discard;\n//    \n//    int offsetInPacket = POS.x;\n//          \n//    float val = AUDIO_LEVEL( offsetInPacket );\n//    \n//    fragColor = vec4( val ) / .75;\n//}\n//\n//void mainImage( out vec4 fragColor, in vec2 fragCoord )\n//{                \n//    if ( iChannelTime[0] < .02 ) { fragColor = vec4( 0. ); return; } // clear\n//    \n//    int mode = int( -4. * iMouse.z / iResolution.x );\n//    if      ( mode == 0 ) showRawData( fragColor, fragCoord );\n//    else if ( mode == 1 ) showRawSyncData( fragColor, fragCoord );\n//    else if ( mode == 2 ) decodeImagesButShowSyncData( fragColor, fragCoord );    \n//    else                  decodeImages( fragColor, fragCoord );\n//}","name":"Image","description":"","type":"image"}]}