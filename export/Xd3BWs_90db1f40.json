{"ver":"0.1","info":{"id":"Xd3BWs","date":"1560875436","viewed":135,"name":"Perlin Voronoi Splotches","username":"oalpha","description":"Voronoi cells modulated with perlin noise.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","perlin","pattern","splotch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mat4 s = mat4(\n        //67.2, 0.0, 0.0, 0.0,\n        8442.39141, 7216.23789, 5425.39214, 9482.33014,\n        4580.97063, 1966.03408, 4198.81591, 1775.13314,\n        7064.92482, 7282.28071, 3199.41736, 2977.93959,\n        6896.14210, 3330.00043, 3886.02285, 6709.07920\n    );\n    mat4 d4 = mat4(\n        84.4239141, 72.1623789, 54.2539214, 94.8233014,\n        45.8097063, 19.6603408, 41.9881591, 17.7513314,\n        70.6492482, 72.8228071, 31.9941736, 29.7793959,\n        68.9614210, 33.3000043, 38.8602285, 67.0907920\n    );\n    mat3 d3 = mat3(\n        14.4239141, 22.1623789, 14.2539214,\n        45.8097063, 19.6603408, 21.9881591,\n        20.6492482, 32.8228071, 31.9941736\n    );\n    mat3 d3b = randSin(d3, 12.3456, 67.8901, s[0]);\n    mat3 d3c = randSin(d3b, 12.3456, 67.8901, s[0]);\n    mat2 d2 = mat2(\n        84.4239141, 72.1623789,\n        45.8097063, 19.6603408\n    );\n    mat2 d2b = randSin(d2, 12.3456, 67.8901, s[0]);\n    mat2 d2c = randSin(d2b, 12.3456, 67.8901, s[0]);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    vec2 p = uv * 4.0;\n    float t = iTime;\n    //t *= 0.125;\n    t *= 45. / 10.;\n    t = fract(t / 90.) * 90.;\n    if(t > 45.) t = 90. - t;\n    //fragColor = vec4(vec3(rand3(p, 0.0, 1.0, d3, fract(iTime) * 0.25).x),1.0);\n    //fragColor = vec4(vec3(rand1(p, 0.0, 1.0, d2[0], iTime)),1.0);\n    //fragColor = vec4(vec3(perlinGradient1(p, d2[0], s[0])),1.0);\n    //fragColor = vec4(vec3(perlinGradient1(vec3(p, t), d3, 67.2)),1.0);\n    //fragColor = vec4(vec3(perlinGradient1(vec4(p, cos(t), sin(t)), d4, 67.2)),1.0);\n    //fragColor = vec4(perlinGradient3(vec3(p, t), d3, d3b, d3c, s[0]),1.0);\n    //fragColor = vec4(vec3(simplexGradient1(p, d2[0], s[0]) * 0.5 + 0.5),1.0);\n    //fragColor = vec4(vec3(simplexGradient1(vec3(p, t), d3, s[0]) * 0.5 + 0.5),1.0);\n    //fragColor = vec4(vec3(simplexGradient1(vec4(p, t, t), d4, s[0]) * 0.5 + 0.5),1.0);\n    //fragColor = vec4(vec3(simplexGradient2(p, d2[0], d2b[0], s[0]), 0.0),1.0);\n    //fragColor = vec4(simplexGradient3(p, d2[0], d2b[0], d2b[0], s[0]),1.0);\n    //fragColor = vec4(simplexGradient3(vec3(p, t), d3, d3b, d3c, s[0]),1.0);\n    //fragColor = vec4(vec3(rectvoronoi(p, 0.125, iTime * 0.5, d2[0], d2, s[0]).x),1.0);\n    //fragColor = vec4(vec3(rectvoronoi(vec3(p, t), 0.125, iTime * 0.5, d3, d3, s[0]).x),1.0);\n    //fragColor = vec4(vec3(rectvoronoi(vec4(p, t, t), 0.125, iTime * 0.5, d4, d4, s[0]).x),1.0);\n    //fragColor = vec4(vec3(hexvoronoi(p, 0.125, iTime * 0.5, d2[0], d2, s[0]).x),1.0);\n    //fragColor = vec4(vec3(fbm1(p, mat2(2.0) * rot(1.0), 0.5, d2[0], s[0]) * 0.5 + 0.5),1.0);\n    //fragColor = vec4(vec3(fbm1(vec3(p, t), mat3(2.0), 0.5, d3, s[0]) * 0.5 + 0.5),1.0);\n    //fragColor = vec4(vec3(fbm3(vec3(p, t), mat3(2.0), 0.5, d3, d3b, d3c, s[0]) * 0.5 + 0.5),1.0);\n    //fragColor = vec4(vec3(hexvoronoi(p, t, 0.125, 0.0, mat3(2.0), 0.5, d2[0], d3b, d3c, s[0]).x),1.0);\n    float v = 0.0;\n    vec2 p2 = p + simplexGradient2(p * 2.5, d2[0], d2b[0], s[0]) * 0.15;\n    float voro1 = 1.0 - rectvoronoi(p2, 0.125, t * 0.5, d2[0], d2, s[0]).y;\n    float perl = perlinGradient1(p, d2[0], s[0]) * 0.02 + 0.98;\n    v += smoothstep(0.977, 0.985, voro1 * perl);\n    p = mat2(\n        2.0, 1.1,\n        -0.3, 1.9\n    ) * p;\n    p2 = p + simplexGradient2(p * 2.5, d2[0], d2b[0], s[0]) * 0.15;\n    float voro2 = 0.1 - rectvoronoi(p2, 0.125, iTime * 0.5, d2[0], d2, s[0]).y;\n    perl = perlinGradient1(p, d2[0], s[0]) * 0.06;\n    //v += smoothstep(0.98, 1.09, voro1 + voro2);\n    fragColor = vec4(vec3(v),1.0);\n    //mat4 ss = mat4(2.0);\n    //mat4 ss = mat4(\n    //    2.0, vec3(0.0),\n    //    0.0, 2.0, 0.0, 0.0,\n    //    0.0, 0.0, 1.25, 0.0,\n    //    vec3(0.0), 1.25\n    //);\n    //ss = ss * rot(vec4(1.0, 2.0, 3.0, 4.0));\n    //fragColor = vec4(vec3(fbm(vec4(p, t, t), ss, 0.5, d4, s[0]) * 0.5 + 0.5),1.0);\n    //fragColor.xyz = fragColor.xyz * 0.5 + 0.5;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI  3.141592653589793238462643383279\n#define PI2 6.283185307179586476925286766559\n\n#define o2 vec2(0.0, 0.0)\n#define i2 vec2(1.0, 0.0)\n#define j2 vec2(0.0, 1.0)\n#define o3 vec3(0.0, 0.0, 0.0)\n#define i3 vec3(1.0, 0.0, 0.0)\n#define j3 vec3(0.0, 1.0, 0.0)\n#define k3 vec3(0.0, 0.0, 1.0)\n#define o4 vec4(0.0, 0.0, 0.0, 0.0)\n#define i4 vec4(1.0, 0.0, 0.0, 0.0)\n#define j4 vec4(0.0, 1.0, 0.0, 0.0)\n#define k4 vec4(0.0, 0.0, 1.0, 0.0)\n#define l4 vec4(0.0, 0.0, 0.0, 1.0)\n#define O2 ivec2(0.0, 0.0)\n#define I2 ivec2(1.0, 0.0)\n#define J2 ivec2(0.0, 1.0)\n\n#define MaximumRaySteps 10\n#define MaximumDistance 100.0\n#define MinimumDistance 0.001\n#define MaximumRadius 100.0\n#define Center o3\n\n#define DOTC(it, ot) \\\nfloat Dot(it a, it b) { \\\n    return dot(ot(a), ot(b)); \\\n}\n#define DOTS(t) \\\nfloat Dot(t v) { \\\n    return dot(v, v); \\\n}\n#define DOT2(t) \\\nfloat Dot2(t a, t b) { \\\n    float d = dot(a, b); \\\n    return d * d; \\\n}\nDOTC(ivec2, vec2)\nDOTC(ivec3, vec3)\nDOTC(ivec4, vec4)\nDOTS(vec2)\nDOTS(vec3)\nDOTS(vec4)\nDOT2(vec2)\nDOT2(vec3)\nDOT2(vec4)\nfloat Triple(vec3 a, vec3 b, vec3 c) {\n    return dot(a, cross(b, c));\n}\n\n#define REDE(t) float red_e(t v, float f) {return dot(v, t(f));}\n#define REDEC(t) float red_e(t v, float f) {return Dot(v, t(f));}\nREDE(vec2)\nREDE(vec3)\nREDE(vec4)\nREDEC(ivec2)\nREDEC(ivec3)\nREDEC(ivec4)\n#define SUME(t) float sum_e(t v) {return red_e(v, 1.0);}\nSUME(vec2)\nSUME(vec3)\nSUME(vec4)\nSUME(ivec2)\nSUME(ivec3)\nSUME(ivec4)\nfloat prod_e(vec2 v) {return v.x * v.y;}\nfloat prod_e(vec3 v) {return v.x * v.y * v.z;}\nfloat prod_e(vec4 v) {return v.x * v.y * v.z * v.w;}\n#define MOD(a, b) (a - floor(a / b) * b)\n#define MODFUNC(t) t Mod(t a, t b) {return MOD(a, b);}\nMODFUNC(float)\nMODFUNC(vec2)\nMODFUNC(vec3)\nMODFUNC(vec4)\n#define MODFUNC2(t1, t2) t1 Mod(t1 a, t2 b) {return MOD(a, b);}\nMODFUNC2(vec2, float)\nMODFUNC2(vec3, float)\nMODFUNC2(vec4, float)\n\n#define CURVE3(a) (a * a * (3.0 - 2.0 * a))\n#define CURVE3FUNC(t) t curve3(t a) {return CURVE3(a);}\nCURVE3FUNC(float)\nCURVE3FUNC(vec2)\nCURVE3FUNC(vec3)\nCURVE3FUNC(vec4)\n#define CURVE5(a) (a * a * a * (10.0 + a * (6.0 * a - 15.0)))\n#define CURVE5FUNC(t) t curve5(t a) {return CURVE5(a);}\nCURVE5FUNC(float)\nCURVE5FUNC(vec2)\nCURVE5FUNC(vec3)\nCURVE5FUNC(vec4)\n\nfloat triangle(vec2 a, vec2 b, vec2 c) {\n    vec2 B = b - a, C = c - a;\n    vec2 u = normalize(B), v = normalize(C);\n    float t = acos(dot(u, v)), s = sin(t);\n    return length(B) * length(C) * s / 2.0;\n}\nfloat tetrahedron(vec3 a, vec3 b, vec3 c, vec3 d) {\n    vec3 B = b - a, C = c - a, D = d - a;\n    return abs(Triple(B, C, D)) / 6.0;\n}\nfloat pentachoron(vec4 a, vec4 b, vec4 c, vec4 d, vec4 e) {\n    vec4 B = b - a, C = c - a, D = d - a, E = e - a;\n    return (\n        B.x * Triple(C.yzw, D.yzw, E.yzw) -\n        C.x * Triple(B.yzw, D.yzw, E.yzw) +\n        D.x * Triple(B.yzw, C.yzw, E.yzw) -\n        E.x * Triple(B.yzw, C.yzw, D.yzw)\n    ) / 24.0;\n}\n\nivec3 sortD(vec3 v) {\n    ivec3 i = ivec3(1, 2, 3);\n    if(v.x < v.y) {\n        v = v.yxz;\n        i = i.yxz;\n    }\n    if(v.y < v.z) {\n        v = v.xzy;\n        i = i.xzy;\n        if(v.x < v.y) {\n            v = v.yxz;\n            i = i.yxz;\n        }\n    }\n    return i;\n}\nivec4 sortD(vec4 v) {\n    ivec4 i = ivec4(1, 2, 3, 4);\n    if(v.x < v.y) {\n        v = v.yxzw;\n        i = i.yxzw;\n    }\n    if(v.y < v.z) {\n        v = v.xzyw;\n        i = i.xzyw;\n        if(v.x < v.y) {\n            v = v.yxzw;\n            i = i.yxzw;\n        }\n    }\n    if(v.z < v.w) {\n        v = v.xywz;\n        i = i.xywz;\n        if(v.y < v.z) {\n            v = v.xzyw;\n            i = i.xzyw;\n            if(v.x < v.y) {\n                v = v.yxzw;\n                i = i.yxzw;\n            }\n        }\n    }\n    return i;\n}\n\nmat2 Sin(mat2 m) {return mat2(sin(m[0]), sin(m[1]));}\nmat3 Sin(mat3 m) {return mat3(sin(m[0]), sin(m[1]), sin(m[2]));}\nmat4 Sin(mat4 m) {return mat4(sin(m[0]), sin(m[1]), sin(m[2]), sin(m[3]));}\nmat2 Fract(mat2 m) {return mat2(fract(m[0]), fract(m[1]));}\nmat3 Fract(mat3 m) {return mat3(fract(m[0]), fract(m[1]), fract(m[2]));}\nmat4 Fract(mat4 m) {return mat4(fract(m[0]), fract(m[1]), fract(m[2]), fract(m[3]));}\nmat2 Floor(mat2 m) {return mat2(floor(m[0]), floor(m[1]));}\nmat3 Floor(mat3 m) {return mat3(floor(m[0]), floor(m[1]), floor(m[2]));}\nmat4 Floor(mat4 m) {return mat4(floor(m[0]), floor(m[1]), floor(m[2]), floor(m[3]));}\n#define RANDSIN(x, a, b, c, d) fract(sin(x * a + b) * c + d)\n#define RANDSINM(x, a, b, c, d) Fract(Sin(x * a + b) * c + d)\n#define RANDSINR(x, o, r, a, b, c, d) o + r * RANDSIN(x, a, b, c, d)\n#define RANDSINMR(x, o, r, a, b, c, d) o + r * RANDSINM(x, a, b, c, d)\n#define RANDSINFUNC(t) t randSin(t x, vec4 ss) {return RANDSIN(x, ss.x, ss.y, ss.z, ss.z);}\n#define RANDSINRFUNC(t) t randSin(t x, float o, float r, vec4 ss) {return RANDSINR(x, o, r, ss.x, ss.y, ss.z, ss.z);}\n#define RANDSINMRFUNC(t) t randSin(t x, float o, float r, vec4 ss) {return RANDSINMR(x, o, r, ss.x, ss.y, ss.z, ss.z);}\nRANDSINRFUNC(float)\nRANDSINRFUNC(vec2)\nRANDSINRFUNC(vec3)\nRANDSINRFUNC(vec4)\nRANDSINMRFUNC(mat2)\nRANDSINMRFUNC(mat3)\nRANDSINMRFUNC(mat4)\n#define MODEXP(x, y) x - floor(x * (1.0 / y)) * y\n#define MODEXPM(x, y) x - Floor(x * (1.0 / y)) * y\n#define MOD289(t) \\\nt mod289(t x) {\\\n    return MODEXP(x, 289.0);\\\n}\n#define MOD289M(t) \\\nt mod289(t x) {\\\n    return MODEXPM(x, 289.0);\\\n}\n#define PERMUTE(x) (mod289(((x*34.0)+1.0)*x))\n#define PERMUTER(x, o, r) (PERMUTE(x)/289.0*r+o)\n#define PERMUTEFUNC(t) \\\nt permute(t x) {\\\n    return PERMUTE(x);\\\n}\n#define PERMUTERFUNC(t) \\\nt permute(t x, float o, float r) {\\\n    return PERMUTER(x, o, r);\\\n}\n#define INTFUNC(f) \\\nfloat f(int x) {\\\n    return f(float(x));\\\n}\n#define SEEDEDPERMUTEFUNC(t1, t2) \\\nt1 permute(t1 x, t2 seed){\\\n    x = PERMUTE(x);\\\n    float s = PERMUTE(seed[0]);\\\n    t1 xseed = x * s;\\\n    return PERMUTE(xseed);\\\n}\n#define SEEDEDPERMUTERFUNC(t1, t2) \\\nt1 permute(t1 x, float o, float r, t2 seed){\\\n    x = PERMUTE(x);\\\n    float s = PERMUTE(seed[0]);\\\n    t1 xseed = x * s;\\\n    return PERMUTER(xseed, o, r);\\\n}\nMOD289(float)\nINTFUNC(mod289)\nMOD289(vec2)\nMOD289(vec3)\nMOD289(vec4)\nMOD289M(mat2)\nMOD289M(mat3)\nMOD289M(mat4)\nPERMUTEFUNC(float)\nINTFUNC(permute)\nPERMUTEFUNC(vec2)\nPERMUTEFUNC(vec3)\nPERMUTEFUNC(vec4)\nPERMUTERFUNC(vec2)\nPERMUTERFUNC(vec3)\nPERMUTERFUNC(vec4)\nSEEDEDPERMUTEFUNC(float, vec4)\nSEEDEDPERMUTEFUNC(vec2, vec4)\nSEEDEDPERMUTEFUNC(vec3, vec4)\nSEEDEDPERMUTEFUNC(vec4, vec4)\nSEEDEDPERMUTERFUNC(float, vec4)\nSEEDEDPERMUTERFUNC(vec2, vec4)\nSEEDEDPERMUTERFUNC(vec3, vec4)\nSEEDEDPERMUTERFUNC(vec4, vec4)\nSEEDEDPERMUTERFUNC(mat2, vec4)\nSEEDEDPERMUTERFUNC(mat3, vec4)\nSEEDEDPERMUTERFUNC(mat4, vec4)\n\n//#define RAND permute\n#define RAND randSin\nvec2  rand2(float v, float o, float r, vec2 d, vec4 s) {return RAND( d * v, o, r, s);}\nvec3  rand3(float v, float o, float r, vec3 d, vec4 s) {return RAND( d * v, o, r, s);}\nvec4  rand4(float v, float o, float r, vec4 d, vec4 s) {return RAND( d * v, o, r, s);}\n\nfloat rand1(vec2  v, float o, float r, vec2 d, vec4 s) {return RAND( dot(d, RAND(v, 0.0, 1.0, s)), o, r, s);}\nfloat rand1(vec3  v, float o, float r, vec3 d, vec4 s) {return RAND( dot(d, RAND(v, 0.0, 1.0, s)), o, r, s);}\nfloat rand1(vec4  v, float o, float r, vec4 d, vec4 s) {return RAND( dot(d, RAND(v, 0.0, 1.0, s)), o, r, s);}\n\nvec2  rand2(vec2  v, float o, float r, mat2 d, vec4 s) {return RAND( d * RAND(v, 0.0, 1.0, s), o, r, s);}\nvec3  rand3(vec3  v, float o, float r, mat3 d, vec4 s) {return RAND( d * RAND(v, 0.0, 1.0, s), o, r, s);}\nvec4  rand4(vec4  v, float o, float r, mat4 d, vec4 s) {return RAND( d * RAND(v, 0.0, 1.0, s), o, r, s);}\n\nvec2  rand2(vec3  v, float o, float r, mat3 d, vec4 s) {return RAND((d * v).xy, o, r, s);}\nvec2  rand2(vec4  v, float o, float r, mat4 d, vec4 s) {return RAND((d * v).xy, o, r, s);}\nvec3  rand3(vec4  v, float o, float r, mat4 d, vec4 s) {return RAND((d * v).xyz, o, r, s);}\n\nvec3  rand3(vec2  v, float o, float r, mat3 d, vec4 s) {return RAND( d * vec3(v, 0.0), o, r, s);}\nvec4  rand4(vec2  v, float o, float r, mat4 d, vec4 s) {return RAND( d * vec4(v, 0.0, 0.0), o, r, s);}\nvec4  rand4(vec3  v, float o, float r, mat4 d, vec4 s) {return RAND( d * vec4(v, 0.0), o, r, s);}\n\n#define ROT(t, n, i, j) \\\nt n(float a) {\\\n    float c = cos(a), s = sin(a);\\\n    t m = t(1.0);\\\n    m[i][i] = m[j][j] = c;\\\n    m[i][j] = s;\\\n    m[j][i] = -s;\\\n    return m;\\\n}\nROT(mat2, rot, 0, 1)\nROT(mat3, rotX, 1, 2)\nROT(mat3, rotY, 2, 0)\nROT(mat3, rotZ, 0, 1)\nROT(mat4, rotXY, 2, 3)\nROT(mat4, rotYZ, 3, 0)\nROT(mat4, rotZW, 0, 1)\nROT(mat4, rotWX, 1, 2)\nROT(mat4, rotYW, 2, 0)\nROT(mat4, rotZX, 3, 1)\nmat3 euler_zyx(vec3 a) {return rotX(a.x) * rotY(a.y) * rotZ(a.z);}\nmat4 rot(vec4 a) {return rotXY(a.x) * rotYZ(a.y) * rotZW(a.z) * rotWX(a.w);}\n\nvec2  randRot2(float v, vec4 s) {return rot(RAND(v, 0.0, PI2, s)) * i2;}\nvec3  randRot3(float v, vec3 d, vec4 s) {return euler_zyx(rand3(v, 0.0, PI2, d, s)) * i3;}\nvec4  randRot4(float v, vec4 d, vec4 s) {return rot(rand4(v, 0.0, PI2, d, s)) * i4;}\n\nvec2  randRot2(vec2  v, vec2 d, vec4 s) {return rot(rand1(v, 0.0, PI2, d, s)) * i2;}\nvec3  randRot3(vec3  v, mat3 d, vec4 s) {return euler_zyx(rand3(v, 0.0, PI2, d, s)) * i3;}\nvec4  randRot4(vec4  v, mat4 d, vec4 s) {return rot(rand4(v, 0.0, PI2, d, s)) * i4;}\n\nvec2  randRot2(vec3  v, vec3 d, vec4 s) {return rot(rand1(v, 0.0, PI2, d, s)) * i2;}\nvec2  randRot2(vec4  v, vec4 d, vec4 s) {return rot(rand1(v, 0.0, PI2, d, s)) * i2;}\nvec3  randRot3(vec4  v, mat4 d, vec4 s) {return euler_zyx(rand3(v, 0.0, PI2, d, s)) * i3;}\n\nvec3  randRot3(vec2  v, mat3 d, vec4 s) {return euler_zyx(rand3(v, 0.0, PI2, d, s)) * i3;}\nvec4  randRot4(vec2  v, mat4 d, vec4 s) {return rot(rand4(v, 0.0, PI2, d, s)) * i4;}\nvec4  randRot4(vec3  v, mat4 d, vec4 s) {return rot(rand4(v, 0.0, PI2, d, s)) * i4;}\n\n#define CURVE(h) curve3(h)\n//#undef CURVE\n//#define CURVE(h) h\nfloat perlinGradient1(vec2 p, vec2 d, vec4 s) {\n    vec2 r = floor(p);\n    vec2 f = CURVE(fract(p)), F = 1.0 - f;\n    float o = 0.0;\n    for(float i = 0.0; i < 2.0; i++)\n    for(float j = 0.0; j < 2.0; j++) {\n        vec2 b = vec2(i, j);\n        vec2 B = 1.0 - b;\n        vec2 R = r + b;\n        o += dot(randRot2(R, d, s), p - R) * CURVE(prod_e(b * f + B * F));\n    }\n    return o * 1.625;\n}\nfloat perlinGradient1(vec3 p, mat3 d, vec4 s) {\n    vec3 r = floor(p);\n    vec3 f = CURVE(fract(p)), F = 1.0 - f;\n    float o = 0.0;\n    for(float i = 0.0; i < 2.0; i++)\n    for(float j = 0.0; j < 2.0; j++)\n    for(float k = 0.0; k < 2.0; k++) {\n        vec3 b = vec3(i, j, k);\n        vec3 B = 1.0 - b;\n        vec3 R = r + b;\n        o += dot(randRot3(R, d, s), p - R) * CURVE(prod_e(b * f + B * F));\n    }\n    return o * 1.625;\n}\nfloat perlinGradient1(vec4 p, mat4 d, vec4 s) {\n    vec4 r = floor(p);\n    vec4 f = CURVE(fract(p)), F = 1.0 - f;\n    float o = 0.0;\n    for(float i = 0.0; i < 2.0; i++)\n    for(float j = 0.0; j < 2.0; j++)\n    for(float k = 0.0; k < 2.0; k++)\n    for(float l = 0.0; l < 2.0; l++) {\n        vec4 b = vec4(i, j, k, l);\n        vec4 B = 1.0 - b;\n        vec4 R = r + b;\n        o += dot(randRot4(R, d, s), p - R) * CURVE(prod_e(b * f + B * F));\n    }\n    return o * 1.75;\n}\nvec2 perlinGradient2(vec2 p, vec2 d1, vec2 d2, vec4 s) {\n    vec2 r = floor(p);\n    vec2 f = CURVE(fract(p)), F = 1.0 - f;\n    vec2 o = vec2(0.0);\n    for(float i = 0.0; i < 2.0; i++)\n    for(float j = 0.0; j < 2.0; j++) {\n        vec2 b = vec2(i, j);\n        vec2 B = 1.0 - b;\n        vec2 R = r + b;\n        o.x += dot(randRot2(R, d1, s), p - R) * CURVE(prod_e(b * f + B * F));\n        o.y += dot(randRot2(R, d2, s), p - R) * CURVE(prod_e(b * f + B * F));\n    }\n    return o * 1.625;\n}\nvec2 perlinGradient2(vec3 p, mat3 d1, mat3 d2, vec4 s) {\n    vec3 r = floor(p);\n    vec3 f = CURVE(fract(p)), F = 1.0 - f;\n    vec2 o = vec2(0.0);\n    for(float i = 0.0; i < 2.0; i++)\n    for(float j = 0.0; j < 2.0; j++)\n    for(float k = 0.0; k < 2.0; k++) {\n        vec3 b = vec3(i, j, k);\n        vec3 B = 1.0 - b;\n        vec3 R = r + b;\n        o.x += dot(randRot3(R, d1, s), p - R) * CURVE(prod_e(b * f + B * F));\n        o.y += dot(randRot3(R, d2, s), p - R) * CURVE(prod_e(b * f + B * F));\n    }\n    return o * 1.625;\n}\nvec2 perlinGradient2(vec4 p, mat4 d1, mat4 d2, vec4 s) {\n    vec4 r = floor(p);\n    vec4 f = CURVE(fract(p)), F = 1.0 - f;\n    vec2 o = vec2(0.0);\n    for(float i = 0.0; i < 2.0; i++)\n    for(float j = 0.0; j < 2.0; j++)\n    for(float k = 0.0; k < 2.0; k++)\n    for(float l = 0.0; l < 2.0; l++) {\n        vec4 b = vec4(i, j, k, l);\n        vec4 B = 1.0 - b;\n        vec4 R = r + b;\n        o.x += dot(randRot4(R, d1, s), p - R) * CURVE(prod_e(b * f + B * F));\n        o.y += dot(randRot4(R, d2, s), p - R) * CURVE(prod_e(b * f + B * F));\n    }\n    return o * 1.75;\n}\nvec3 perlinGradient3(vec2 p, vec2 d1, vec2 d2, vec2 d3, vec4 s) {\n    vec2 r = floor(p);\n    vec2 f = CURVE(fract(p)), F = 1.0 - f;\n    vec3 o = vec3(0.0);\n    for(float i = 0.0; i < 2.0; i++)\n    for(float j = 0.0; j < 2.0; j++) {\n        vec2 b = vec2(i, j);\n        vec2 B = 1.0 - b;\n        vec2 R = r + b;\n        o.x += dot(randRot2(R, d1, s), p - R) * CURVE(prod_e(b * f + B * F));\n        o.y += dot(randRot2(R, d2, s), p - R) * CURVE(prod_e(b * f + B * F));\n        o.z += dot(randRot2(R, d3, s), p - R) * CURVE(prod_e(b * f + B * F));\n    }\n    return o * 1.625;\n}\nvec3 perlinGradient3(vec3 p, mat3 d1, mat3 d2, mat3 d3, vec4 s) {\n    vec3 r = floor(p);\n    vec3 f = CURVE(fract(p)), F = 1.0 - f;\n    vec3 o = vec3(0.0);\n    for(float i = 0.0; i < 2.0; i++)\n    for(float j = 0.0; j < 2.0; j++)\n    for(float k = 0.0; k < 2.0; k++) {\n        vec3 b = vec3(i, j, k);\n        vec3 B = 1.0 - b;\n        vec3 R = r + b;\n        o.x += dot(randRot3(R, d1, s), p - R) * CURVE(prod_e(b * f + B * F));\n        o.y += dot(randRot3(R, d2, s), p - R) * CURVE(prod_e(b * f + B * F));\n        o.z += dot(randRot3(R, d3, s), p - R) * CURVE(prod_e(b * f + B * F));\n    }\n    return o * 1.625;\n}\nvec3 perlinGradient3(vec4 p, mat4 d1, mat4 d2, mat4 d3, vec4 s) {\n    vec4 r = floor(p);\n    vec4 f = CURVE(fract(p)), F = 1.0 - f;\n    vec3 o = vec3(0.0);\n    for(float i = 0.0; i < 2.0; i++)\n    for(float j = 0.0; j < 2.0; j++)\n    for(float k = 0.0; k < 2.0; k++)\n    for(float l = 0.0; l < 2.0; l++) {\n        vec4 b = vec4(i, j, k, l);\n        vec4 B = 1.0 - b;\n        vec4 R = r + b;\n        o.x += dot(randRot4(R, d1, s), p - R) * CURVE(prod_e(b * f + B * F));\n        o.y += dot(randRot4(R, d2, s), p - R) * CURVE(prod_e(b * f + B * F));\n        o.z += dot(randRot4(R, d3, s), p - R) * CURVE(prod_e(b * f + B * F));\n    }\n    return o * 1.75;\n}\n\n#define SKEW\n//#define WEIGHT3\nfloat simplexGradient1(vec2 p, vec2 d, vec4 s) {\n    float skew = (sqrt(3.0) - 1.0) / 2.0, unskew = (1.0 - 1.0 / sqrt(3.0)) / 2.0;\n    vec2 P = p + sum_e(p) * skew;\n    vec2 L = floor(P);\n    vec2 f = fract(P);\n    vec2 c1 = L;\n    vec2 c2 = c1 + (f.x > f.y ? i2 : j2);\n    vec2 c3 = L + 1.0;\n    c1 -= sum_e(c1) * unskew;\n    c2 -= sum_e(c2) * unskew;\n    c3 -= sum_e(c3) * unskew;\n    float A = triangle(c1, c2, c3);\n    float w1 = CURVE(triangle(p, c2, c3) / A);\n    float w2 = CURVE(triangle(c1, p, c3) / A);\n    float w3 = CURVE(triangle(c1, c2, p) / A);\n    #ifdef WEIGHT2\n    return (w1 + w2 + w3) * 0.5;\n    #else\n    #define GRADIENT2\n    #ifdef GRADIENT2\n    float v1 = dot(randRot2(c1, d, s), p - c1);\n    float v2 = dot(randRot2(c2, d, s), p - c2);\n    float v3 = dot(randRot2(c3, d, s), p - c3);\n    return (v1 * w1 + v2 * w2 + v3 * w3) / (w1 + w2 + w3) * 1.625;\n    return w2 / (w1 + w2 + w3);\n    #else\n    float v1 = rand1(c1, 0.0, 1.0, d, s);\n    float v2 = rand1(c2, 0.0, 1.0, d, s);\n    float v3 = rand1(c3, 0.0, 1.0, d, s);\n    //return (w1 > w2 && w1 > w3 ? v1 : w2 > w1 && w2 > w3 ? v2 : v3);\n    //return (w1 > w2 && w1 > w3 ? v1 * w1 : w2 > w1 && w2 > w3 ? v2 * w2 : v3 * w3) / (w1 + w2 + w3);\n    return w2;\n    #endif\n    #endif\n}\nfloat simplexGradient1(vec3 p, mat3 d, vec4 s) {\n    //p.z = 0.0;\n    float skew = 1.0 / 3.0, unskew = 1.0 / 6.0;\n    #ifdef SKEW\n    vec3 P = p + sum_e(p) * skew;\n    #else\n    vec3 P = p;\n    #endif\n    vec3 L = floor(P);\n    vec3 f = fract(P);\n    ivec3 o = sortD(f);\n    vec3 c1 = L;\n    vec3 c2 = c1 + (o.x == 1 ? i3 : o.x == 2 ? j3 : k3);\n    vec3 c3 = c2 + (o.y == 1 ? i3 : o.y == 2 ? j3 : k3);\n    vec3 c4 = L + 1.0;\n    #ifdef SKEW\n    c1 -= sum_e(c1) * unskew;\n    c2 -= sum_e(c2) * unskew;\n    c3 -= sum_e(c3) * unskew;\n    c4 -= sum_e(c4) * unskew;\n    #endif\n    float V = tetrahedron(c1, c2, c3, c4);\n    float w1 = CURVE(tetrahedron(p, c2, c3, c4) / V);\n    float w2 = CURVE(tetrahedron(c1, p, c3, c4) / V);\n    float w3 = CURVE(tetrahedron(c1, c2, p, c4) / V);\n    float w4 = CURVE(tetrahedron(c1, c2, c3, p) / V);\n    #ifdef WEIGHT3\n    //if(o.x == 1)\n    //    return o.y == 2 ? i3 : 1.0 - i3;\n    //else if(o.x == 2)\n    //    return o.y == 3 ? j3 : 1.0 - j3;\n    //else if(o.x == 3)\n    //    return o.y == 1 ? k3 : 1.0 - k3;\n    return (w1 + w2 + w3 + w4) * 0.5;\n    #else\n    #define GRADIENT3\n    #ifdef GRADIENT3\n    vec3 g1 = randRot3(c1, d, s);\n    vec3 g2 = randRot3(c2, d, s);\n    vec3 g3 = randRot3(c3, d, s);\n    vec3 g4 = randRot3(c4, d, s);\n    vec3 d1 = p - c1;\n    vec3 d2 = p - c2;\n    vec3 d3 = p - c3;\n    vec3 d4 = p - c4;\n    float v1 = dot(g1, d1);\n    float v2 = dot(g2, d2);\n    float v3 = dot(g3, d3);\n    float v4 = dot(g4, d4);\n    //return (w1 > w2 && w1 > w3 && w1 > w4 ? d1 : w2 > w1 && w2 > w3 && w2 > w4 ? d2 : w3 > w1 && w3 > w2 && w3 > w4 ? d3 : d4) * 0.5 + 0.5;\n    //return w1 > w2 && w1 > w3 && w1 > w4 ? g1 : w2 > w1 && w2 > w3 && w2 > w4 ? g2 : w3 > w1 && w3 > w2 && w3 > w4 ? g3 : g4;\n    //return vec3(w1 > w2 && w1 > w3 && w1 > w4 ? v1 : w2 > w1 && w2 > w3 && w2 > w4 ? v2 : w3 > w1 && w3 > w2 && w3 > w4 ? v3 : v4);\n    //return vec3(w1 > w2 && w1 > w3 && w1 > w4 ? v1 * w1 : w2 > w1 && w2 > w3 && w2 > w4 ? v2 * w2 : w3 > w1 && w3 > w2 && w3 > w4 ? v3 * w3 : v4 * w4);\n    return (v1 * w1 + v2 * w2 + v3 * w3 + v4 * w4) / (w1 + w2 + w3 + w4) * 1.625;\n    #else\n    float v1 = rand(c1, 0.0, 1.0, d[0], s);\n    float v2 = rand(c2, 0.0, 1.0, d[0], s);\n    float v3 = rand(c3, 0.0, 1.0, d[0], s);\n    float v4 = rand(c4, 0.0, 1.0, d[0], s);\n    //return vec3(v1 * w1, v2 * w2, v3 * w3);\n    return (w1 > w2 && w1 > w3 && w1 > w4 ? v1 : w2 > w1 && w2 > w3 && w2 > w4 ? v2 : w3 > w1 && w3 > w2 && w3 > w4 ? v3 : v4);\n    #endif\n    #endif\n    //return vec3(w2, w3, w4);\n}\nfloat simplexGradient1(vec4 p, mat4 d, vec4 s) {\n    //p.z = 0.0;\n    float skew = (sqrt(5.0) - 1.0) / 4.0, unskew = (1.0 - 1.0 / sqrt(5.0)) / 4.0;\n    #ifdef SKEW\n    vec4 P = p + sum_e(p) * skew;\n    #else\n    vec4 P = p;\n    #endif\n    vec4 L = floor(P);\n    vec4 f = fract(P);\n    ivec4 o = sortD(f);\n    vec4 c1 = L;\n    vec4 c2 = c1 + (o.x == 1 ? i4 : o.x == 2 ? j4 : o.x == 3 ? k4 : l4);\n    vec4 c3 = c2 + (o.y == 1 ? i4 : o.y == 2 ? j4 : o.y == 3 ? k4 : l4);\n    vec4 c4 = c3 + (o.z == 1 ? i4 : o.z == 2 ? j4 : o.z == 3 ? k4 : l4);\n    vec4 c5 = L + 1.0;\n    #ifdef SKEW\n    c1 -= sum_e(c1) * unskew;\n    c2 -= sum_e(c2) * unskew;\n    c3 -= sum_e(c3) * unskew;\n    c4 -= sum_e(c4) * unskew;\n    c5 -= sum_e(c5) * unskew;\n    #endif\n    float V = pentachoron(c1, c2, c3, c4, c5);\n    float w1 = CURVE(pentachoron(p, c2, c3, c4, c5) / V);\n    float w2 = CURVE(pentachoron(c1, p, c3, c4, c5) / V);\n    float w3 = CURVE(pentachoron(c1, c2, p, c4, c5) / V);\n    float w4 = CURVE(pentachoron(c1, c2, c3, p, c5) / V);\n    float w5 = CURVE(pentachoron(c1, c2, c3, c4, p) / V);\n    #ifdef WEIGHT3\n    if(o.x == 1)\n        return o.y == 2 ? i3 : 1.0 - i3;\n    else if(o.x == 2)\n        return o.y == 3 ? j3 : 1.0 - j3;\n    else if(o.x == 3)\n        return o.y == 1 ? k3 : 1.0 - k3;\n    return (w1 + w2 + w3 + w4 + w5) * 0.5;\n    #else\n    #define GRADIENT3\n    #ifdef GRADIENT3\n    vec4 g1 = randRot4(c1, d, s);\n    vec4 g2 = randRot4(c2, d, s);\n    vec4 g3 = randRot4(c3, d, s);\n    vec4 g4 = randRot4(c4, d, s);\n    vec4 g5 = randRot4(c5, d, s);\n    vec4 d1 = p - c1;\n    vec4 d2 = p - c2;\n    vec4 d3 = p - c3;\n    vec4 d4 = p - c4;\n    vec4 d5 = p - c5;\n    float v1 = dot(g1, d1);\n    float v2 = dot(g2, d2);\n    float v3 = dot(g3, d3);\n    float v4 = dot(g4, d4);\n    float v5 = dot(g5, d5);\n    //return (w1 > w2 && w1 > w3 && w1 > w4 ? d1 : w2 > w1 && w2 > w3 && w2 > w4 ? d2 : w3 > w1 && w3 > w2 && w3 > w4 ? d3 : d4) * 0.5 + 0.5;\n    //return w1 > w2 && w1 > w3 && w1 > w4 ? g1 : w2 > w1 && w2 > w3 && w2 > w4 ? g2 : w3 > w1 && w3 > w2 && w3 > w4 ? g3 : g4;\n    //return vec3(w1 > w2 && w1 > w3 && w1 > w4 ? v1 : w2 > w1 && w2 > w3 && w2 > w4 ? v2 : w3 > w1 && w3 > w2 && w3 > w4 ? v3 : v4);\n    //return vec3(w1 > w2 && w1 > w3 && w1 > w4 ? v1 * w1 : w2 > w1 && w2 > w3 && w2 > w4 ? v2 * w2 : w3 > w1 && w3 > w2 && w3 > w4 ? v3 * w3 : v4 * w4);\n    return (v1 * w1 + v2 * w2 + v3 * w3 + v4 * w4 + v5 * w5) / (w1 + w2 + w3 + w4 + w5) * 1.625;\n    #else\n    float v1 = rand(c1, 0.0, 1.0, d[0], s);\n    float v2 = rand(c2, 0.0, 1.0, d[0], s);\n    float v3 = rand(c3, 0.0, 1.0, d[0], s);\n    float v4 = rand(c4, 0.0, 1.0, d[0], s);\n    float v5 = rand(c5, 0.0, 1.0, d[0], s);\n    //return vec3(v1 * w1, v2 * w2, v3 * w3);\n    return (w1 > w2 && w1 > w3 && w1 > w4 ? v1 : w2 > w1 && w2 > w3 && w2 > w4 ? v2 : w3 > w1 && w3 > w2 && w3 > w4 ? v3 : v4);\n    #endif\n    #endif\n    //return vec3(w2, w3, w4);\n}\nvec2 simplexGradient2(vec2 p, vec2 d1, vec2 d2, vec4 s) {\n    float skew = (sqrt(3.0) - 1.0) / 2.0, unskew = (1.0 - 1.0 / sqrt(3.0)) / 2.0;\n    vec2 P = p + sum_e(p) * skew;\n    vec2 L = floor(P);\n    vec2 f = fract(P);\n    vec2 c1 = L;\n    vec2 c2 = c1 + (f.x > f.y ? i2 : j2);\n    vec2 c3 = L + 1.0;\n    c1 -= sum_e(c1) * unskew;\n    c2 -= sum_e(c2) * unskew;\n    c3 -= sum_e(c3) * unskew;\n    float A = triangle(c1, c2, c3);\n    float w1 = CURVE(triangle(p, c2, c3) / A);\n    float w2 = CURVE(triangle(c1, p, c3) / A);\n    float w3 = CURVE(triangle(c1, c2, p) / A);\n    float v1;\n    float v2;\n    float v3;\n    vec2 o = vec2(0.0);\n    v1 = dot(randRot2(c1, d1, s), p - c1);\n    v2 = dot(randRot2(c2, d1, s), p - c2);\n    v3 = dot(randRot2(c3, d1, s), p - c3);\n    o.x = (v1 * w1 + v2 * w2 + v3 * w3) / (w1 + w2 + w3);\n    v1 = dot(randRot2(c1, d2, s), p - c1);\n    v2 = dot(randRot2(c2, d2, s), p - c2);\n    v3 = dot(randRot2(c3, d2, s), p - c3);\n    o.y = (v1 * w1 + v2 * w2 + v3 * w3) / (w1 + w2 + w3);\n    return o * 1.625;\n}\nvec3 simplexGradient3(vec2 p, vec2 d1, vec2 d2, vec2 d3, vec4 s) {\n    float skew = (sqrt(3.0) - 1.0) / 2.0, unskew = (1.0 - 1.0 / sqrt(3.0)) / 2.0;\n    vec2 P = p + sum_e(p) * skew;\n    vec2 L = floor(P);\n    vec2 f = fract(P);\n    vec2 c1 = L;\n    vec2 c2 = c1 + (f.x > f.y ? i2 : j2);\n    vec2 c3 = L + 1.0;\n    c1 -= sum_e(c1) * unskew;\n    c2 -= sum_e(c2) * unskew;\n    c3 -= sum_e(c3) * unskew;\n    float A = triangle(c1, c2, c3);\n    float w1 = CURVE(triangle(p, c2, c3) / A);\n    float w2 = CURVE(triangle(c1, p, c3) / A);\n    float w3 = CURVE(triangle(c1, c2, p) / A);\n    float v1;\n    float v2;\n    float v3;\n    vec3 o = vec3(0.0);\n    v1 = dot(randRot2(c1, d1, s), p - c1);\n    v2 = dot(randRot2(c2, d1, s), p - c2);\n    v3 = dot(randRot2(c3, d1, s), p - c3);\n    o.x = (v1 * w1 + v2 * w2 + v3 * w3) / (w1 + w2 + w3);\n    v1 = dot(randRot2(c1, d2, s), p - c1);\n    v2 = dot(randRot2(c2, d2, s), p - c2);\n    v3 = dot(randRot2(c3, d2, s), p - c3);\n    o.y = (v1 * w1 + v2 * w2 + v3 * w3) / (w1 + w2 + w3);\n    v1 = dot(randRot2(c1, d3, s), p - c1);\n    v2 = dot(randRot2(c2, d3, s), p - c2);\n    v3 = dot(randRot2(c3, d3, s), p - c3);\n    o.z = (v1 * w1 + v2 * w2 + v3 * w3) / (w1 + w2 + w3);\n    return o * 1.625;\n}\nvec3 simplexGradient3(vec3 p, mat3 d1, mat3 d2, mat3 d3, vec4 s) {\n    //p.z = 0.0;\n    float skew = 1.0 / 3.0, unskew = 1.0 / 6.0;\n    vec3 P = p + sum_e(p) * skew;\n    vec3 L = floor(P);\n    vec3 f = fract(P);\n    ivec3 o = sortD(f);\n    vec3 c1 = L;\n    vec3 c2 = c1 + (o.x == 1 ? i3 : o.x == 2 ? j3 : k3);\n    vec3 c3 = c2 + (o.y == 1 ? i3 : o.y == 2 ? j3 : k3);\n    vec3 c4 = L + 1.0;\n    c1 -= sum_e(c1) * unskew;\n    c2 -= sum_e(c2) * unskew;\n    c3 -= sum_e(c3) * unskew;\n    c4 -= sum_e(c4) * unskew;\n    float V = tetrahedron(c1, c2, c3, c4);\n    float w1 = CURVE(tetrahedron(p, c2, c3, c4) / V);\n    float w2 = CURVE(tetrahedron(c1, p, c3, c4) / V);\n    float w3 = CURVE(tetrahedron(c1, c2, p, c4) / V);\n    float w4 = CURVE(tetrahedron(c1, c2, c3, p) / V);\n    float v1;\n    float v2;\n    float v3;\n    float v4;\n    vec3 O = vec3(0.0);\n    v1 = dot(randRot3(c1, d1, s), p - c1);\n    v2 = dot(randRot3(c2, d1, s), p - c2);\n    v3 = dot(randRot3(c3, d1, s), p - c3);\n    v4 = dot(randRot3(c4, d1, s), p - c4);\n    O.x = (v1 * w1 + v2 * w2 + v3 * w3 + v4 * w4) / (w1 + w2 + w3 + w4);\n    v1 = dot(randRot3(c1, d2, s), p - c1);\n    v2 = dot(randRot3(c2, d2, s), p - c2);\n    v3 = dot(randRot3(c3, d2, s), p - c3);\n    v4 = dot(randRot3(c4, d2, s), p - c4);\n    O.y = (v1 * w1 + v2 * w2 + v3 * w3 + v4 * w4) / (w1 + w2 + w3 + w4);\n    v1 = dot(randRot3(c1, d3, s), p - c1);\n    v2 = dot(randRot3(c2, d3, s), p - c2);\n    v3 = dot(randRot3(c3, d3, s), p - c3);\n    v4 = dot(randRot3(c4, d3, s), p - c4);\n    O.z = (v1 * w1 + v2 * w2 + v3 * w3 + v4 * w4) / (w1 + w2 + w3 + w4);\n    return O * 1.625;\n}\n/*\nfloat simplexGradient1(vec3 p, mat3 d, vec4 s) {\n    //p.z = 0.0;\n    float skew = 1.0 / 3.0, unskew = 1.0 / 6.0;\n    #ifdef SKEW\n    vec3 P = p + sum_e(p) * skew;\n    #else\n    vec3 P = p;\n    #endif\n    vec3 L = floor(P);\n    vec3 f = fract(P);\n    ivec3 o = sortD(f);\n    vec3 c1 = L;\n    vec3 c2 = c1 + (o.x == 1 ? i3 : o.x == 2 ? j3 : k3);\n    vec3 c3 = c2 + (o.y == 1 ? i3 : o.y == 2 ? j3 : k3);\n    vec3 c4 = L + 1.0;\n    #ifdef SKEW\n    c1 -= sum_e(c1) * unskew;\n    c2 -= sum_e(c2) * unskew;\n    c3 -= sum_e(c3) * unskew;\n    c4 -= sum_e(c4) * unskew;\n    #endif\n    float V = tetrahedron(c1, c2, c3, c4);\n    float w1 = CURVE(tetrahedron(p, c2, c3, c4) / V);\n    float w2 = CURVE(tetrahedron(c1, p, c3, c4) / V);\n    float w3 = CURVE(tetrahedron(c1, c2, p, c4) / V);\n    float w4 = CURVE(tetrahedron(c1, c2, c3, p) / V);\n    #ifdef WEIGHT3\n    //if(o.x == 1)\n    //    return o.y == 2 ? i3 : 1.0 - i3;\n    //else if(o.x == 2)\n    //    return o.y == 3 ? j3 : 1.0 - j3;\n    //else if(o.x == 3)\n    //    return o.y == 1 ? k3 : 1.0 - k3;\n    return (w1 + w2 + w3 + w4) * 0.5;\n    #else\n    #define GRADIENT3\n    #ifdef GRADIENT3\n    vec3 g1 = randRot3(c1, d, s);\n    vec3 g2 = randRot3(c2, d, s);\n    vec3 g3 = randRot3(c3, d, s);\n    vec3 g4 = randRot3(c4, d, s);\n    vec3 d1 = p - c1;\n    vec3 d2 = p - c2;\n    vec3 d3 = p - c3;\n    vec3 d4 = p - c4;\n    float v1 = dot(g1, d1);\n    float v2 = dot(g2, d2);\n    float v3 = dot(g3, d3);\n    float v4 = dot(g4, d4);\n    //return (w1 > w2 && w1 > w3 && w1 > w4 ? d1 : w2 > w1 && w2 > w3 && w2 > w4 ? d2 : w3 > w1 && w3 > w2 && w3 > w4 ? d3 : d4) * 0.5 + 0.5;\n    //return w1 > w2 && w1 > w3 && w1 > w4 ? g1 : w2 > w1 && w2 > w3 && w2 > w4 ? g2 : w3 > w1 && w3 > w2 && w3 > w4 ? g3 : g4;\n    //return vec3(w1 > w2 && w1 > w3 && w1 > w4 ? v1 : w2 > w1 && w2 > w3 && w2 > w4 ? v2 : w3 > w1 && w3 > w2 && w3 > w4 ? v3 : v4);\n    //return vec3(w1 > w2 && w1 > w3 && w1 > w4 ? v1 * w1 : w2 > w1 && w2 > w3 && w2 > w4 ? v2 * w2 : w3 > w1 && w3 > w2 && w3 > w4 ? v3 * w3 : v4 * w4);\n    return (v1 * w1 + v2 * w2 + v3 * w3 + v4 * w4) / (w1 + w2 + w3 + w4) * 1.625;\n    #else\n    float v1 = rand(c1, 0.0, 1.0, d[0], s);\n    float v2 = rand(c2, 0.0, 1.0, d[0], s);\n    float v3 = rand(c3, 0.0, 1.0, d[0], s);\n    float v4 = rand(c4, 0.0, 1.0, d[0], s);\n    //return vec3(v1 * w1, v2 * w2, v3 * w3);\n    return (w1 > w2 && w1 > w3 && w1 > w4 ? v1 : w2 > w1 && w2 > w3 && w2 > w4 ? v2 : w3 > w1 && w3 > w2 && w3 > w4 ? v3 : v4);\n    #endif\n    #endif\n    //return vec3(w2, w3, w4);\n}\nfloat simplexGradient1(vec4 p, mat4 d, vec4 s) {\n    //p.z = 0.0;\n    float skew = (sqrt(5.0) - 1.0) / 4.0, unskew = (1.0 - 1.0 / sqrt(5.0)) / 4.0;\n    #ifdef SKEW\n    vec4 P = p + sum_e(p) * skew;\n    #else\n    vec4 P = p;\n    #endif\n    vec4 L = floor(P);\n    vec4 f = fract(P);\n    ivec4 o = sortD(f);\n    vec4 c1 = L;\n    vec4 c2 = c1 + (o.x == 1 ? i4 : o.x == 2 ? j4 : o.x == 3 ? k4 : l4);\n    vec4 c3 = c2 + (o.y == 1 ? i4 : o.y == 2 ? j4 : o.y == 3 ? k4 : l4);\n    vec4 c4 = c3 + (o.z == 1 ? i4 : o.z == 2 ? j4 : o.z == 3 ? k4 : l4);\n    vec4 c5 = L + 1.0;\n    #ifdef SKEW\n    c1 -= sum_e(c1) * unskew;\n    c2 -= sum_e(c2) * unskew;\n    c3 -= sum_e(c3) * unskew;\n    c4 -= sum_e(c4) * unskew;\n    c5 -= sum_e(c5) * unskew;\n    #endif\n    float V = pentachoron(c1, c2, c3, c4, c5);\n    float w1 = CURVE(pentachoron(p, c2, c3, c4, c5) / V);\n    float w2 = CURVE(pentachoron(c1, p, c3, c4, c5) / V);\n    float w3 = CURVE(pentachoron(c1, c2, p, c4, c5) / V);\n    float w4 = CURVE(pentachoron(c1, c2, c3, p, c5) / V);\n    float w5 = CURVE(pentachoron(c1, c2, c3, c4, p) / V);\n    #ifdef WEIGHT3\n    if(o.x == 1)\n        return o.y == 2 ? i3 : 1.0 - i3;\n    else if(o.x == 2)\n        return o.y == 3 ? j3 : 1.0 - j3;\n    else if(o.x == 3)\n        return o.y == 1 ? k3 : 1.0 - k3;\n    return (w1 + w2 + w3 + w4 + w5) * 0.5;\n    #else\n    #define GRADIENT3\n    #ifdef GRADIENT3\n    vec4 g1 = randRot4(c1, d, s);\n    vec4 g2 = randRot4(c2, d, s);\n    vec4 g3 = randRot4(c3, d, s);\n    vec4 g4 = randRot4(c4, d, s);\n    vec4 g5 = randRot4(c5, d, s);\n    vec4 d1 = p - c1;\n    vec4 d2 = p - c2;\n    vec4 d3 = p - c3;\n    vec4 d4 = p - c4;\n    vec4 d5 = p - c5;\n    float v1 = dot(g1, d1);\n    float v2 = dot(g2, d2);\n    float v3 = dot(g3, d3);\n    float v4 = dot(g4, d4);\n    float v5 = dot(g5, d5);\n    //return (w1 > w2 && w1 > w3 && w1 > w4 ? d1 : w2 > w1 && w2 > w3 && w2 > w4 ? d2 : w3 > w1 && w3 > w2 && w3 > w4 ? d3 : d4) * 0.5 + 0.5;\n    //return w1 > w2 && w1 > w3 && w1 > w4 ? g1 : w2 > w1 && w2 > w3 && w2 > w4 ? g2 : w3 > w1 && w3 > w2 && w3 > w4 ? g3 : g4;\n    //return vec3(w1 > w2 && w1 > w3 && w1 > w4 ? v1 : w2 > w1 && w2 > w3 && w2 > w4 ? v2 : w3 > w1 && w3 > w2 && w3 > w4 ? v3 : v4);\n    //return vec3(w1 > w2 && w1 > w3 && w1 > w4 ? v1 * w1 : w2 > w1 && w2 > w3 && w2 > w4 ? v2 * w2 : w3 > w1 && w3 > w2 && w3 > w4 ? v3 * w3 : v4 * w4);\n    return (v1 * w1 + v2 * w2 + v3 * w3 + v4 * w4 + v5 * w5) / (w1 + w2 + w3 + w4 + w5) * 1.625;\n    #else\n    float v1 = rand(c1, 0.0, 1.0, d[0], s);\n    float v2 = rand(c2, 0.0, 1.0, d[0], s);\n    float v3 = rand(c3, 0.0, 1.0, d[0], s);\n    float v4 = rand(c4, 0.0, 1.0, d[0], s);\n    float v5 = rand(c5, 0.0, 1.0, d[0], s);\n    //return vec3(v1 * w1, v2 * w2, v3 * w3);\n    return (w1 > w2 && w1 > w3 && w1 > w4 ? v1 : w2 > w1 && w2 > w3 && w2 > w4 ? v2 : w3 > w1 && w3 > w2 && w3 > w4 ? v3 : v4);\n    #endif\n    #endif\n    //return vec3(w2, w3, w4);\n}\nfloat simplexGradient1(vec3 p, mat3 d, vec4 s) {\n    //p.z = 0.0;\n    float skew = 1.0 / 3.0, unskew = 1.0 / 6.0;\n    #ifdef SKEW\n    vec3 P = p + sum_e(p) * skew;\n    #else\n    vec3 P = p;\n    #endif\n    vec3 L = floor(P);\n    vec3 f = fract(P);\n    ivec3 o = sortD(f);\n    vec3 c1 = L;\n    vec3 c2 = c1 + (o.x == 1 ? i3 : o.x == 2 ? j3 : k3);\n    vec3 c3 = c2 + (o.y == 1 ? i3 : o.y == 2 ? j3 : k3);\n    vec3 c4 = L + 1.0;\n    #ifdef SKEW\n    c1 -= sum_e(c1) * unskew;\n    c2 -= sum_e(c2) * unskew;\n    c3 -= sum_e(c3) * unskew;\n    c4 -= sum_e(c4) * unskew;\n    #endif\n    float V = tetrahedron(c1, c2, c3, c4);\n    float w1 = CURVE(tetrahedron(p, c2, c3, c4) / V);\n    float w2 = CURVE(tetrahedron(c1, p, c3, c4) / V);\n    float w3 = CURVE(tetrahedron(c1, c2, p, c4) / V);\n    float w4 = CURVE(tetrahedron(c1, c2, c3, p) / V);\n    #ifdef WEIGHT3\n    //if(o.x == 1)\n    //    return o.y == 2 ? i3 : 1.0 - i3;\n    //else if(o.x == 2)\n    //    return o.y == 3 ? j3 : 1.0 - j3;\n    //else if(o.x == 3)\n    //    return o.y == 1 ? k3 : 1.0 - k3;\n    return (w1 + w2 + w3 + w4) * 0.5;\n    #else\n    #define GRADIENT3\n    #ifdef GRADIENT3\n    vec3 g1 = randRot3(c1, d, s);\n    vec3 g2 = randRot3(c2, d, s);\n    vec3 g3 = randRot3(c3, d, s);\n    vec3 g4 = randRot3(c4, d, s);\n    vec3 d1 = p - c1;\n    vec3 d2 = p - c2;\n    vec3 d3 = p - c3;\n    vec3 d4 = p - c4;\n    float v1 = dot(g1, d1);\n    float v2 = dot(g2, d2);\n    float v3 = dot(g3, d3);\n    float v4 = dot(g4, d4);\n    //return (w1 > w2 && w1 > w3 && w1 > w4 ? d1 : w2 > w1 && w2 > w3 && w2 > w4 ? d2 : w3 > w1 && w3 > w2 && w3 > w4 ? d3 : d4) * 0.5 + 0.5;\n    //return w1 > w2 && w1 > w3 && w1 > w4 ? g1 : w2 > w1 && w2 > w3 && w2 > w4 ? g2 : w3 > w1 && w3 > w2 && w3 > w4 ? g3 : g4;\n    //return vec3(w1 > w2 && w1 > w3 && w1 > w4 ? v1 : w2 > w1 && w2 > w3 && w2 > w4 ? v2 : w3 > w1 && w3 > w2 && w3 > w4 ? v3 : v4);\n    //return vec3(w1 > w2 && w1 > w3 && w1 > w4 ? v1 * w1 : w2 > w1 && w2 > w3 && w2 > w4 ? v2 * w2 : w3 > w1 && w3 > w2 && w3 > w4 ? v3 * w3 : v4 * w4);\n    return (v1 * w1 + v2 * w2 + v3 * w3 + v4 * w4) / (w1 + w2 + w3 + w4) * 1.625;\n    #else\n    float v1 = rand(c1, 0.0, 1.0, d[0], s);\n    float v2 = rand(c2, 0.0, 1.0, d[0], s);\n    float v3 = rand(c3, 0.0, 1.0, d[0], s);\n    float v4 = rand(c4, 0.0, 1.0, d[0], s);\n    //return vec3(v1 * w1, v2 * w2, v3 * w3);\n    return (w1 > w2 && w1 > w3 && w1 > w4 ? v1 : w2 > w1 && w2 > w3 && w2 > w4 ? v2 : w3 > w1 && w3 > w2 && w3 > w4 ? v3 : v4);\n    #endif\n    #endif\n    //return vec3(w2, w3, w4);\n}\nfloat simplexGradient1(vec4 p, mat4 d, vec4 s) {\n    //p.z = 0.0;\n    float skew = (sqrt(5.0) - 1.0) / 4.0, unskew = (1.0 - 1.0 / sqrt(5.0)) / 4.0;\n    #ifdef SKEW\n    vec4 P = p + sum_e(p) * skew;\n    #else\n    vec4 P = p;\n    #endif\n    vec4 L = floor(P);\n    vec4 f = fract(P);\n    ivec4 o = sortD(f);\n    vec4 c1 = L;\n    vec4 c2 = c1 + (o.x == 1 ? i4 : o.x == 2 ? j4 : o.x == 3 ? k4 : l4);\n    vec4 c3 = c2 + (o.y == 1 ? i4 : o.y == 2 ? j4 : o.y == 3 ? k4 : l4);\n    vec4 c4 = c3 + (o.z == 1 ? i4 : o.z == 2 ? j4 : o.z == 3 ? k4 : l4);\n    vec4 c5 = L + 1.0;\n    #ifdef SKEW\n    c1 -= sum_e(c1) * unskew;\n    c2 -= sum_e(c2) * unskew;\n    c3 -= sum_e(c3) * unskew;\n    c4 -= sum_e(c4) * unskew;\n    c5 -= sum_e(c5) * unskew;\n    #endif\n    float V = pentachoron(c1, c2, c3, c4, c5);\n    float w1 = CURVE(pentachoron(p, c2, c3, c4, c5) / V);\n    float w2 = CURVE(pentachoron(c1, p, c3, c4, c5) / V);\n    float w3 = CURVE(pentachoron(c1, c2, p, c4, c5) / V);\n    float w4 = CURVE(pentachoron(c1, c2, c3, p, c5) / V);\n    float w5 = CURVE(pentachoron(c1, c2, c3, c4, p) / V);\n    #ifdef WEIGHT3\n    if(o.x == 1)\n        return o.y == 2 ? i3 : 1.0 - i3;\n    else if(o.x == 2)\n        return o.y == 3 ? j3 : 1.0 - j3;\n    else if(o.x == 3)\n        return o.y == 1 ? k3 : 1.0 - k3;\n    return (w1 + w2 + w3 + w4 + w5) * 0.5;\n    #else\n    #define GRADIENT3\n    #ifdef GRADIENT3\n    vec4 g1 = randRot4(c1, d, s);\n    vec4 g2 = randRot4(c2, d, s);\n    vec4 g3 = randRot4(c3, d, s);\n    vec4 g4 = randRot4(c4, d, s);\n    vec4 g5 = randRot4(c5, d, s);\n    vec4 d1 = p - c1;\n    vec4 d2 = p - c2;\n    vec4 d3 = p - c3;\n    vec4 d4 = p - c4;\n    vec4 d5 = p - c5;\n    float v1 = dot(g1, d1);\n    float v2 = dot(g2, d2);\n    float v3 = dot(g3, d3);\n    float v4 = dot(g4, d4);\n    float v5 = dot(g5, d5);\n    //return (w1 > w2 && w1 > w3 && w1 > w4 ? d1 : w2 > w1 && w2 > w3 && w2 > w4 ? d2 : w3 > w1 && w3 > w2 && w3 > w4 ? d3 : d4) * 0.5 + 0.5;\n    //return w1 > w2 && w1 > w3 && w1 > w4 ? g1 : w2 > w1 && w2 > w3 && w2 > w4 ? g2 : w3 > w1 && w3 > w2 && w3 > w4 ? g3 : g4;\n    //return vec3(w1 > w2 && w1 > w3 && w1 > w4 ? v1 : w2 > w1 && w2 > w3 && w2 > w4 ? v2 : w3 > w1 && w3 > w2 && w3 > w4 ? v3 : v4);\n    //return vec3(w1 > w2 && w1 > w3 && w1 > w4 ? v1 * w1 : w2 > w1 && w2 > w3 && w2 > w4 ? v2 * w2 : w3 > w1 && w3 > w2 && w3 > w4 ? v3 * w3 : v4 * w4);\n    return (v1 * w1 + v2 * w2 + v3 * w3 + v4 * w4 + v5 * w5) / (w1 + w2 + w3 + w4 + w5) * 1.625;\n    #else\n    float v1 = rand(c1, 0.0, 1.0, d[0], s);\n    float v2 = rand(c2, 0.0, 1.0, d[0], s);\n    float v3 = rand(c3, 0.0, 1.0, d[0], s);\n    float v4 = rand(c4, 0.0, 1.0, d[0], s);\n    float v5 = rand(c5, 0.0, 1.0, d[0], s);\n    //return vec3(v1 * w1, v2 * w2, v3 * w3);\n    return (w1 > w2 && w1 > w3 && w1 > w4 ? v1 : w2 > w1 && w2 > w3 && w2 > w4 ? v2 : w3 > w1 && w3 > w2 && w3 > w4 ? v3 : v4);\n    #endif\n    #endif\n    //return vec3(w2, w3, w4);\n}\n*/\n\n#define NOISE1 perlinGradient1\n#undef  NOISE\n#define NOISE simplexGradient\n#define NOISEITERATIONS 7\n#define FBM1FUNC(t, st, dt) \\\nfloat fbm1(t p, st ss, float as, dt d, vec4 s) {\\\n    float o = 0.0, a = 1.0;\\\n    vec4 cs = s;\\\n    for(int i = 0; i < NOISEITERATIONS; i++) {\\\n        o += NOISE1(p, d, s) * a;\\\n        p *= ss;\\\n        a *= as;\\\n        cs = RAND(cs, 1234.5678, 5678.9012, s);\\\n    }\\\n    return o;\\\n}\nFBM1FUNC(vec2, mat2, vec2)\nFBM1FUNC(vec3, mat3, mat3)\nFBM1FUNC(vec4, mat4, mat4)\n#define NOISE2 perlinGradient2\n#define FBM2FUNC(t, st, dt) \\\nvec2 fbm2(t p, st ss, float as, dt d1, dt d2, vec4 s) {\\\n\tvec2 o = vec2(0.0);\\\n    float a = 1.0;\\\n    vec4 cs = s;\\\n    for(int i = 0; i < NOISEITERATIONS; i++) {\\\n        o += NOISE2(p, d1, d2, s) * a;\\\n        p *= ss;\\\n        a *= as;\\\n        cs = RAND(cs, 1234.5678, 5678.9012, s);\\\n    }\\\n    return o;\\\n}\nFBM2FUNC(vec2, mat2, vec2)\nFBM2FUNC(vec3, mat3, mat3)\nFBM2FUNC(vec4, mat4, mat4)\n#define NOISE3 perlinGradient3\n#define FBM3FUNC(t, st, dt) \\\nvec3 fbm3(t p, st ss, float as, dt d1, dt d2, dt d3, vec4 s) {\\\n\tvec3 o = vec3(0.0);\\\n    float a = 1.0;\\\n    vec4 cs = s;\\\n    for(int i = 0; i < NOISEITERATIONS; i++) {\\\n        o += NOISE3(p, d1, d2, d3, s) * a;\\\n        p *= ss;\\\n        a *= as;\\\n        cs = RAND(cs, 1234.5678, 5678.9012, s);\\\n    }\\\n    return o;\\\n}\nFBM3FUNC(vec2, mat2, vec2)\nFBM3FUNC(vec3, mat3, mat3)\nFBM3FUNC(vec4, mat4, mat4)\n\nfloat smin( float a, float b, float k ) {\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\n#define VORORANGE 2\nvec2 rectvoronoi(in vec2 x, float w, float a, vec2 d1, mat2 d2, vec4 s) {\n    ivec2 p = ivec2(floor( x ));\n    vec2 f = fract( x );\n\n    ivec2 mb;\n    vec2 mr;\n    float id = 1.0e20;\n    const int range = 3;\n    for( int j=-VORORANGE; j<=VORORANGE; j++ )\n    for( int i=-VORORANGE; i<=VORORANGE; i++ )\n    {\n        ivec2 b = ivec2( i, j );\n        vec2 B = vec2(p + b);\n        vec2 rv = rand2(B, 0.0, 1.0, d2, s );\n        //vec2 rv = RAND(B, 0.0, 1.0, s);\n        vec2 r = vec2(b) - f + rv;\n        float R = a * perlinGradient1(B * w, d1, s);\n        float dis = length( r ) + R;\n\n        if(dis < id) {\n            mb = b;\n            mr = r;\n            id = dis;\n        }\n    }\n    float bd = 1.0e20;\n    for( int j=-VORORANGE; j<=VORORANGE; j++ )\n    for( int i=-VORORANGE; i<=VORORANGE; i++ )\n    {\n        ivec2 b = mb + ivec2( i, j );\n        vec2 B = vec2(p + b);\n        vec2 rv = rand2(B, 0.0, 1.0, d2, s );\n        //vec2 rv = RAND(B, 0.0, 1.0, s);\n        vec2 r = vec2(b) - f + rv;\n        float R = a * perlinGradient1(B * w, d1, s);\n        float dis = dot( 0.5*(mr+r), normalize(r-mr) );\n\n        bd = min(bd, dis);\n    }\n    return vec2(id, bd);\n}\nvec2 rectvoronoi(in vec3 x, float w, float a, mat3 d1, mat3 d2, vec4 s) {\n    ivec3 p = ivec3(floor( x ));\n    vec3 f = fract( x );\n\n    ivec3 mb;\n    vec3 mr;\n    float id = 1.0e20;\n    const int range = 3;\n    for( int k=-VORORANGE; k<=VORORANGE; k++ )\n    for( int j=-VORORANGE; j<=VORORANGE; j++ )\n    for( int i=-VORORANGE; i<=VORORANGE; i++ )\n    {\n        ivec3 b = ivec3( i, j, k );\n        vec3 B = vec3(p + b);\n        vec3 rv = rand3(B, 0.0, 1.0, d2, s );\n        //vec3 rv = RAND(B, 0.0, 1.0, s);\n        vec3 r = vec3(b) - f + rv;\n        float R = a * perlinGradient1(B * w, d1, s);\n        float dis = length( r ) + R;\n\n        if(dis < id) {\n            mb = b;\n            mr = r;\n            id = dis;\n        }\n    }\n    float bd = 1.0e20;\n    for( int k=-VORORANGE; k<=VORORANGE; k++ )\n    for( int j=-VORORANGE; j<=VORORANGE; j++ )\n    for( int i=-VORORANGE; i<=VORORANGE; i++ )\n    {\n        ivec3 b = mb + ivec3( i, j, k );\n        vec3 B = vec3(p + b);\n        vec3 rv = rand3(B, 0.0, 1.0, d2, s );\n        //vec3 rv = RAND(B, 0.0, 1.0, s);\n        vec3 r = vec3(b) - f + rv;\n        float R = a * perlinGradient1(B * w, d1, s);\n        float dis = dot( 0.5*(mr+r), normalize(r-mr) );\n\n        bd = min(bd, dis);\n    }\n    return vec2(id, bd);\n}\nvec2 rectvoronoi(in vec4 x, float w, float a, mat4 d1, mat4 d2, vec4 s) {\n    ivec4 p = ivec4(floor( x ));\n    vec4 f = fract( x );\n\n    ivec4 mb;\n    vec4 mr;\n    float id = 1.0e20;\n    for( int l=-VORORANGE; l<=VORORANGE; l++ )\n    for( int k=-VORORANGE; k<=VORORANGE; k++ )\n    for( int j=-VORORANGE; j<=VORORANGE; j++ )\n    for( int i=-VORORANGE; i<=VORORANGE; i++ )\n    {\n        ivec4 b = ivec4( i, j, k, l );\n        vec4 B = vec4(p + b);\n        vec4 rv = rand4(B, 0.0, 1.0, d2, s );\n        //vec4 rv = RAND(B, 0.0, 1.0, s);\n        vec4 r = vec4(b) - f + rv;\n        float R = a * perlinGradient1(B * w, d1, s);\n        float dis = length( r ) + R;\n\n        if(dis < id) {\n            mb = b;\n            mr = r;\n            id = dis;\n        }\n    }\n    float bd = 1.0e20;\n    for( int l=-VORORANGE; l<=VORORANGE; l++ )\n    for( int k=-VORORANGE; k<=VORORANGE; k++ )\n    for( int j=-VORORANGE; j<=VORORANGE; j++ )\n    for( int i=-VORORANGE; i<=VORORANGE; i++ )\n    {\n        ivec4 b = ivec4( i, j, k, l );\n        vec4 B = vec4(p + b);\n        vec4 rv = rand4(B, 0.0, 1.0, d2, s );\n        //vec4 rv = RAND(B, 0.0, 1.0, s);\n        vec4 r = vec4(b) - f + rv;\n        float R = a * perlinGradient1(B * w, d1, s);\n        float dis = dot( 0.5*(mr+r), normalize(r-mr) );\n\n        bd = min(bd, dis);\n    }\n    return vec2(id, bd);\n}\nvec2 hexvoronoi(in vec2 p, float w, float a, vec2 d1, mat2 d2, vec4 s) {\n    float skew = (sqrt(3.0) - 1.0) / 2.0, unskew = (1.0 - 1.0 / sqrt(3.0)) / 2.0;\n    vec2 P = p + sum_e(p) * skew;\n    ivec2 L = ivec2(floor(P));\n    vec2 f = fract(P);\n    ivec2 c1 = L;\n    ivec2 c2 = c1 + (f.x >= f.y ? I2 : J2);\n    ivec2 c3 = L + 1;\n    ivec2 c;\n    int b = L.y - L.x * 2;\n    b -= int(floor(float(b) / 3.0) * 3.0);\n    if(b == 0) c = c3;\n    if(b == 1) c = c2;\n    if(b == 2) c = c1;\n    vec2 C = vec2(c) - sum_e(c) * unskew;\n    f = p - C;\n\n    ivec2 mb;\n    vec2 mr;\n    float id = 1.0e20;\n    const int range = 3;\n    for( int j=-VORORANGE; j<=VORORANGE; j++ )\n    for( int i=-VORORANGE; i<=VORORANGE; i++ )\n    {\n        if(abs(i + j) < VORORANGE + 1) {\n            ivec2 b = ivec2( i * 2 + j, i + j * 2 );\n            vec2 B = vec2(c + b) - sum_e(c + b) * unskew;\n            vec2 rv = rand2(B, 0.0, 1.0, d2, s );\n            vec2 r = B - C - f + rv;\n            float R = a * perlinGradient1(B * w, d1, s);\n            float dis = length( r ) + R;\n\n            if(dis < id) {\n                mb = ivec2(i, j);\n                mr = r;\n                id = dis;\n            }\n        }\n    }\n    float bd = 1.0e20;\n    for( int j=-VORORANGE; j<=VORORANGE; j++ )\n    for( int i=-VORORANGE; i<=VORORANGE; i++ )\n    {\n        if(abs(i + j) < 2) {\n            ivec2 b = ivec2( (i + mb.x) * 2 + (j + mb.y), (i + mb.x) + (j + mb.y) * 2 );\n            vec2 B = vec2(c + b) - sum_e(c + b) * unskew;\n            vec2 rv = rand2(B, 0.0, 1.0, d2, s );\n            vec2 r = B - C - f + rv;\n            float R = a * perlinGradient1(B * w, d1, s);\n        \tfloat dis = dot( 0.5*(mr+r), normalize(r-mr) );\n\n        bd = min(bd, dis);\n        }\n    }\n    return vec2(id, bd);\n}\nvec2 hexvoronoi(in vec2 p, float t, float w, float a, mat3 ss, float as, vec2 d1, mat3 d2, mat3 d3, vec4 s) {\n    float skew = (sqrt(3.0) - 1.0) / 2.0, unskew = (1.0 - 1.0 / sqrt(3.0)) / 2.0;\n    vec2 P = p + sum_e(p) * skew;\n    ivec2 L = ivec2(floor(P));\n    vec2 f = fract(P);\n    ivec2 c1 = L;\n    ivec2 c2 = c1 + (f.x >= f.y ? I2 : J2);\n    ivec2 c3 = L + 1;\n    ivec2 c;\n    int b = L.y - L.x * 2;\n    b -= int(floor(float(b) / 3.0) * 3.0);\n    if(b == 0) c = c3;\n    if(b == 1) c = c2;\n    if(b == 2) c = c1;\n    vec2 C = vec2(c) - sum_e(c) * unskew;\n    f = p - C;\n\n    ivec2 mb;\n    vec2 mr;\n    float id = 1.0e20;\n    const int range = 3;\n    for( int j=-VORORANGE; j<=VORORANGE; j++ )\n    for( int i=-VORORANGE; i<=VORORANGE; i++ )\n    {\n        if(abs(i + j) < VORORANGE + 1) {\n            ivec2 b = ivec2( i * 2 + j, i + j * 2 );\n            vec2 B = vec2(c + b) - sum_e(c + b) * unskew;\n            vec2 rv = fbm2(vec3(B, t), ss, as, d2, d3, s );\n            vec2 r = B - C - f + rv;\n            float R = a * perlinGradient1(B * w, d1, s);\n            float dis = length( r ) + R;\n\n            if(dis < id) {\n                mb = ivec2(i, j);\n                mr = r;\n                id = dis;\n            }\n        }\n    }\n    float bd = 1.0e20;\n    for( int j=-VORORANGE; j<=VORORANGE; j++ )\n    for( int i=-VORORANGE; i<=VORORANGE; i++ )\n    {\n        if(abs(i + j) < 2) {\n            ivec2 b = ivec2( (i + mb.x) * 2 + (j + mb.y), (i + mb.x) + (j + mb.y) * 2 );\n            vec2 B = vec2(c + b) - sum_e(c + b) * unskew;\n            vec2 rv = fbm2(vec3(B, t), ss, as, d2, d3, s );\n            vec2 r = B - C - f + rv;\n            float R = a * perlinGradient1(B * w, d1, s);\n        \tfloat dis = dot( 0.5*(mr+r), normalize(r-mr) );\n\n        bd = min(bd, dis);\n        }\n    }\n    return vec2(id, bd);\n}","name":"Common","description":"","type":"common"}]}