{"ver":"0.1","info":{"id":"tldyWl","date":"1610234270","viewed":310,"name":"Mandelbrot-Truchet","username":"NivBehar","description":"use the mouse to control the light","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["truchet","mandelbrotset"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 3\n#define ITERATIONS 70.\n#define COLOR_REPEAT 0.3\n// shapes of mandelbrot set. run from 0 to 10\n#define SHAPE 7\n// reduce to get deeper\n#define ZOOM 1.1\n#define time iTime\n\n// truchet code by BigWings.\nvec3 truchet(vec2 uv, float fraciter, float m_angle)\n{\n    vec3 col = vec3(0);\n    uv *= 1.15;\n    \n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n    \n    float n = Hash21(id); // random number between 0 and 1\n    \n    float width = 0.3*smoothstep(1., 0., fraciter);//0.2*(1.-fraciter);//.003*uv.y;\n    \n    if(n<.5) gv.x *= -1.;\n    float d = abs(abs(gv.x+gv.y)-.5);\n    vec2 cUv = gv-sign(gv.x+gv.y+.001)*.5;\n    d = length(cUv);\n    float mask = smoothstep(.01, -.01, abs(d-.5)-width);\n\tfloat angle = atan(cUv.x, cUv.y); // -pi to pi\n    float checker = mod(id.x+id.y, 2.)*2.-1.;\n    float flow = sin(iTime+checker*angle*10.);\n    \n    float x = (checker*angle/1.57-iTime*.3);\n    float y = (d-(.5-width))/(2.*width);\n    y = abs(y-.5)*2.;\n    vec2 tUv = vec2(x, y);\n    col += pow(texture(iChannel1, tUv).rgb, vec3(1.3))*mask;\n    col *= 1.-tUv.y;\n    \n    return col;\n}\n\n// calculate light\n// https://www.math.univ-toulouse.fr/~cheritat/wiki-draw/index.php/Mandelbrot_set#Normal_map_effect\nfloat calc_light(vec2 z, vec2 der, float h, float angle)\n{\n    // h - height factor of the incoming light  \n    // angle - incoming direction of light\n    vec2 v = vec2 (cos(angle), sin(angle)); // unit 2D vector in this direction\n    vec2 u = (1./(der.x*der.x + der.y*der.y))*vec2(z.x*der.x + z.y*der.y, z.y*der.x - z.x*der.y);// = z/der\n    u = u/length(u); // normal vector: (u.re,u.im,1)\n    float t = (u.x*v.x + u.y*v.y) + h; // dot product with the incoming light\n    t = t/(1.+h); // rescale so that t does not get bigger than 1\n    if(t<0.)\n        t = 0.;\n    float light = mix(1.,0.,t);\n    return light;\n}\nfloat GetEvenSpeed(float i, float is_even)\n{\n    //float even_speed = is_even*2.*sin(q8*5. + (q5)*0.1 + i*0.5);\n    float even_speed = -is_even*time;\n    return even_speed;\n}\nfloat GetOddSpeed(float i, float is_odd)\n{\n    float odd_speed = is_odd*time;//is_odd*2*sin(q8*5 + (q6)*0.1 + i*0.5);\n    return odd_speed;\n}\nfloat GetAllSpeed(float i)\n{\n    float all_speed = 2.*sin(time*0.3);//2.*sin(q8*5. + (q6+q5)*0.05 + i*0.5);\n    return all_speed;\n}\nvec2 GetRotatedZB(vec2 zB, float iB, float speed_mul)\n{\n    float is_odd = mod(iB,2.) == 0. ? 0. : 1.;\n    float is_even = 1. - is_odd;    \n    float even_speed = GetEvenSpeed(iB, is_even); // is_even*2*sin(q8*5 + (q5)*0.1 + iB*0.5);\n    float odd_speed = GetOddSpeed(iB, is_odd); // is_odd*2*sin(q8*5 + (q6)*0.1 + iB*0.5);\n    float all_speed = GetAllSpeed(iB); // 2*sin(q8*5 + (q6+q5)*0.05 + iB*0.5);\n    zB = rot(zB, vec2(0.), speed_mul * (0.*all_speed + even_speed + odd_speed) );\n    return zB;\n}\n\nvec3 iterate(vec2 UV)\n{\n    vec3 col;\n\tvec3 end_col = vec3(0.);\n    vec3 end_colB = vec3(0.);\n    float uv_rot_speed = time*0.1;\n\n    //vec2 orig_zB = UV;\n    vec2 zB = UV;\n    \n    // move and rotate the screen\n    zB = rot(zB,vec2(0.), time*0.08);\n    zB.x += 0.4*sin(time*0.19);\n    zB.x += 0.3*cos(time*0.39);\n    \n    \n    vec2 prev_zB = zB;\n    vec2 rot_zB;\n    float is_odd;\n    float is_even;\n    // shape = z for regular mandelbrot set\n    // a; 0       ; (GOLDEN-2); 0.285; 0.285; 0.45  ; -0.70176; -0.835 ; -0.8 ; -0.7269; -0.754\n    // b; 1-GOLDEN; (GOLDEN-1); 0    ; 0.01 ; 0.1428; -0.3842 ; -0.2321; 0.156; 0.1889; -0.066\n    float GOLDEN = 0.;\n    float[] x = float[] (zB.x, 0.       , GOLDEN-2., 0.285, 0.285 , 0.45  , -0.70176, -0.835 , -0.8 , -0.7269, -0.754);\n    float[] y = float[] (zB.y, 1.-GOLDEN, GOLDEN-1., 0.01 , 0.01  , 0.1428, -0.3842 , -0.2321, 0.156, 0.1889 , -0.066);\n    \n    vec2 shape;\n    shape = vec2(x[SHAPE], y[SHAPE]);// + 0.00013*vec2(cos(q5*0.2),sin(q6*0.2));\n\n    vec2 dc = vec2(1.,0.);\n    vec2 derB = dc;\n    vec2 prev_derB;\n    \n    float rB_even = 30.;\n    float rB_odd = 30.;\n\n    float iB = 0.;\n\n    float breakloopB = 0.;\n    float k = 0.;\n    while(k < ITERATIONS)\n    {\n        if(breakloopB == 0.)\n        { \n            derB = 2. * vec2(derB.x*zB.x - derB.y*zB.y, derB.x*zB.y + derB.y*zB.x) + dc;\n            //der_orig_zB = 2. * vec2(der_orig_zB.x*orig_zB.x - der_orig_zB.y*orig_zB.y, der_orig_zB.x*orig_zB.y + der_orig_zB.y*orig_zB.x) + dc;\n            prev_zB = zB;\n            zB = vec2(zB.x * zB.x - zB.y * zB.y, 2. * zB.x * zB.y) + shape;\n            //orig_zB = vec2(orig_zB.x * orig_zB.x - orig_zB.y * orig_zB.y, 2. * orig_zB.x * orig_zB.y) + shape;\n            iB++;\n\n            is_odd = mod(iB,2.) == 0. ? 0. : 1.;\n            is_even = 1. - is_odd;\n\n            if(length(zB) > rB_odd || length(zB) > rB_even)\n            {\n                breakloopB = 1.;\n            }\n        }\n        \n        k++;\n    }\n\n    if(iB >= ITERATIONS)\n    {\n        end_colB *= 0.;\n    }\n    else\n    {\n        float fraciterB;\n        if(is_odd == 1.)\n            fraciterB = log2( log(length(zB)) / log(rB_odd) );\n        else\n            fraciterB = log2( log(length(zB)) / log(rB_even) );\n        float jB = iB;\n        //jB -= fraciterB;\n        \n        rot_zB = GetRotatedZB(zB, iB, 2.);\n        float angle = atan(rot_zB.x, rot_zB.y);\n        \n        //float light_speed_mul = 0.13;\n\n        // define white light\n        vec2 mouse = (iMouse.xy-iResolution.xy*0.5)/iResolution.y + vec2(0.,0.65);\n        float light3 = calc_light(zB, derB, 1., 10.*mouse.x + time * (iMouse.z > 0. ? 0. : 1.));\n        light3 = pow(light3,400.*mouse.y*mouse.y);\n        light3 = clamp(light3,0.,1.);\n        light3 *= 0.5 + 0.5*sin(fraciterB*1.5);\n\n        // define lighting for odd_col\n        float light_odd = calc_light(zB, derB, 1., time*2.);\n        light_odd = pow(light_odd, 4.);\n        light_odd = clamp(light_odd,0.,1.);\n\n        // define lighting for even_col\n        float light_even = calc_light(zB, derB, 1., 1.5);\n        light_even = pow(light_even, 20.);\n        light_even = clamp(light_even,0.,1.);\n\n        // define shading for odd_col - with fraciter\n        float shade_odd = smoothstep(0.1, 2.,fraciterB) * is_odd;\n        shade_odd = smoothstep(0., 0.2,fraciterB) * is_odd;\n        shade_odd *= smoothstep(-0.5, 2.,fraciterB) * is_odd;\n        float shade_even = smoothstep(0.05,0.25,fraciterB) * is_even;\n        \n        // define ripples for odd_col\n        float odd_ripples = 0.5+0.5*sin(angle*7.);\n        odd_ripples = smoothstep(0.15, 0.23, odd_ripples);\n        float even_ripples = 0.5 + 0.5*sin(fraciterB*25. + time*10.);//0.5+0.5*sin(5.*angle);\n        even_ripples = smoothstep(0.15, 0.23, even_ripples);\n\n        // define color of main ripples\n        vec3 end_colB_odd = col_2(jB, COLOR_REPEAT*1.4, vec3(time*0.453))*is_odd; \n        // define color of truchet\n        vec3 end_colB_even = col_1(jB, COLOR_REPEAT*1.2, vec3(0.66*time))*is_even; \n        \n        vec2 uv = vec2(fraciterB*3., angle);\n        uv = 5.*uv/dot(uv,uv);\n        end_colB_even = truchet(uv, fraciterB, angle)*is_even;\n        end_colB_odd *= 2.*shade_odd * odd_ripples * light_odd;\n        end_colB_even *= 10.*shade_even  * light3;// * light_even;\n        \n\n        // add ripples on truchet\n        angle = ((angle/PI)+1.)/2.; // normalize angle to [0,1]\n        float ripples_mask = smoothstep(0.01, 0.005, fraciterB*angle);\n        //ripples_mask += smoothstep(0.9, 0.95, 1.-fraciterB*angle);\n        ripples_mask += smoothstep(0.01, 0.005, fraciterB*(1.-angle));\n        float ripples = 0.5 + 0.5*sin(fraciterB*45. + time*10.);\n        //end_colB.x = ripples*is_even;\n        end_colB_even *= 1.-ripples_mask; // add mask to the final even_col\n        end_colB_even += 1.5*col_1(jB, COLOR_REPEAT*10., vec3(0.66*time))*ripples_mask*ripples*is_even; // add ripples col to the mask\n        \n\n        \n        // define the final color to be the combination of odd_col and even_col\n        end_colB = end_colB_odd + end_colB_even;\n        \n        // add the white light to the final color, such that it looks different for the odd_col and even_col \n        end_colB += is_odd * light3 * vec3(1.,0.9,0.95);\n        end_colB += is_even * light3 * vec3(0.9,0.93,1.)*0.2;\n\n    }\n    end_colB = clamp(end_colB, 0., 1.);\n\n    return end_colB;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv;\n    \n    float zoom = ZOOM;\n\n    #if AA\n    vec3 col = vec3(0.);\n    // anti-aliasing from https://www.shadertoy.com/view/Mss3R8\n\tfor( int j=0; j<AA; j++ )\n\tfor( int i=0; i<AA; i++ )\n\t{\n\t\tvec2 of = -0.5 + vec2( float(i), float(j) )/float(AA);\n\n        uv = (fragCoord+of)/iResolution.y;\n        uv*=zoom;\n        uv.x-= zoom/2.;\n        uv.y -= zoom/2.;\n\n\t   col += iterate( uv);\n\t}\n\tcol /= float(AA*AA);\n    \n    #else\n    \n        uv = fragCoord/iResolution.y;\n        uv*=zoom;\n        uv.x-= zoom/2.;\n        uv.y -= zoom/2.;\n        vec3 col = iterate(uv);\n    \n    #endif\n    \n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.141592654\nvec3 col_1(float j, float repeat, vec3 offset)\n{\n    // Color 1\n    vec3 a1 = vec3(0.5, 0.5, 0.5);\n    vec3 b1 = vec3(0.75, 0.55, 0.85);\n    vec3 d1 = vec3(0.0, 0.1, 0.2);\n\n    return a1 + b1 * cos(2.*PI*(sqrt(j) * repeat + d1 + offset));\n}\nvec3 col_2(float j, float repeat, vec3 offset)\n{\n    // Color 2\n    vec3 a2 = vec3(0.5, 0.5, 0.5);\n    vec3 b2 = vec3(0.75, 0.55, 0.85);\n    vec3 d2 = vec3(0.8, 0.9, 0.3);\n    return a2 + b2 * cos(2.*PI*(sqrt(j) * repeat + d2 + offset));\n}\nvec3 col_3(float j, float repeat, vec3 offset)\n{\n    // Color 3 - blue to gray\n    vec3 a3 = vec3(0.5, .5, 1.);\n    vec3 b3 = vec3(0.5, 0.5, 0.);\n    vec3 d3 = vec3(0., 0., 0.);\n    return a3 + b3 * cos(2.*PI*(sqrt(j) * repeat + d3 + offset));\n}\nvec3 col_4(float j, float repeat, vec3 offset)\n{\n    // Color 4 - black and white\n    vec3 a4 = vec3(1, 1, 1);\n    vec3 b4 = vec3(1.0, 1.0, 1.0);\n    vec3 d4 = vec3(1.0, 1.0, 1.0);\n    return a4 + b4 * cos(2.*PI*(sqrt(j) * repeat + d4 + offset));\n}\nvec3 col_5(float j, float repeat, vec3 offset)\n{\n    // Color 5 - \n    vec3 a5 = vec3(0.5, 0.4, 0.56);\n    vec3 b5 = vec3(0.5, 0.7, 0.8);\n    vec3 d5 = vec3(0.6, 0.7, 0.79);\n    return a5 + b5 * cos(2.*PI*(sqrt(j) * repeat + d5 + offset));\n}\nfloat lum(vec3 col)\n{\n    return 0.21 * col.r + 0.71 * col.g + 0.07 * col.b;\n}\n\nvec2 rot(vec2 p, vec2 pivot, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n\n    p -= pivot;\n    p = vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n    p += pivot;\n\n    return p;\n}\nfloat HexDist(vec2 p) {\n    p = abs(p);\n\n    float c = dot(p, normalize(vec2(1,1.73)));\n    c = max(c, p.x);\n\n    return c;\n}\nvec4 HexCoords(vec2 UV) \n{\n    vec2 r = vec2(1, 1.73);\n    vec2 h = r*.5;\n\n    vec2 a = mod(UV, r)-h;\n    vec2 b = mod(UV-h, r)-h;\n\n    vec2 gv = dot(a, a) < dot(b,b) ? a : b;\n\n    float x = atan(gv.x, gv.y);\n    float y = .5-HexDist(gv);\n    vec2 id = UV - gv;\n    return vec4(x, y, id.x,id.y);\n}\nfloat TriangleDist(vec2 p, vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float k = sign( q.y );\n    float d = min(dot( a, a ),dot(b, b));\n    float s = max( k*(p.x*q.y-p.y*q.x),k*(p.y-q.y)  );\n    return sqrt(d)*sign(s);\n}\nfloat Hash21(vec2 p) {\n\tp = fract(p*vec2(234.34, 435.345));\n    p += dot(p, p+34.23);\n    return fract(p.x*p.y);\n}","name":"Common","description":"","type":"common"}]}