{"ver":"0.1","info":{"id":"mtycWV","date":"1700665747","viewed":125,"name":"disco ball 2024","username":"Efim","description":"simple disco ball","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","ball","disco"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//used https://www.shadertoy.com/view/mtdyD2 as a short template\n\n#define rot2(a)      mat2(cos(a+vec4(0,11,33,0)))                 // rotation\n#define TAU 6.283185\n#define PI 3.14159265359\n\nfloat aafi(vec2 p) {\n    float fi = atan(p.y, p.x);\n    fi += step(p.y, 0.0)*TAU;\n    return fi;\n}\n\n//converts a vector on a sphere to longitude and latitude\nvec2 lonlat (vec3 p)\n{\n    float lon = aafi(p.xy)/TAU;\n    float lat = aafi(vec2(p.z, length(p.xy)))/PI;\n    return vec2(lon, lat);\n}\n\nvec3 point(vec2 ll, float r)\n{\n    float f1 = ll.x * TAU;\n    float f2 = ll.y * PI;\n    float z = r*cos(f2);\n    float d = abs(r*sin(f2));\n    float x = d*cos(f1);\n    float y = d*sin(f1);\n    return vec3(x, y, z);\n}\n\nfloat sdDiscoBall(vec3 pos, float r)\n{\n    vec2 ll = lonlat(pos);\n    float n = 15.;\n    float n2 = 30.;\n    ll.x = floor(ll.x*n2);\n    ll.y = floor(ll.y*n);\n    vec3 a = point(vec2(ll.x/n2, ll.y/n), r);\n    vec3 b = point(vec2(ll.x/n2, (ll.y+1.)/n), r);\n    vec3 c = point(vec2((ll.x + 1.)/n2, (ll.y+1.)/n), r);\n    float d = dot(normalize(cross(b-a, c-a)), (pos - a));\n    return abs(d*0.9);\n}\n\nfloat sdf(vec3 pos) {\n    \n    return sdDiscoBall(pos, .6);\n\n}\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9.,r;\n    vec3  R = iResolution, e = vec3(1e-3,0,0), N,\n          D = normalize(vec3(U+U, -18.*R.y) - R),          // ray direction\n          p = vec3(0,0,15), q,                             // marching point along ray \n          C = iMouse.z > 0. ? 8.*iMouse.xyz/R -4.             // camera control\n                          : 3.* cos(.3*iTime + vec3(0,11,0)); // demo mode\n    p.yz *= rot2(-C.y),                                    // rotations\n    p.xz *= rot2(-C.x-1.57),\n    D.yz *= rot2(-C.y),                              \n    D.xz *= rot2(-C.x-1.57);\n    for ( O=vec4(1); O.x > 0. && t > .01; O-=.01 )         // march scene\n        q = p, \n        t = min(t, sdf(q) ),                               // soleno√Ød\n        p += .5*t*D;                                       // step forward = dist to obj    \n    \n    N = vec3( sdf(q+e), sdf(q+e.yxy), sdf(q+e.yyx) ) - t ; // normal\n    O.x < 0. ? O = .5*texture(iChannel0, D) :              // uncomment to display environment \n    O = texture(iChannel0, reflect(D,N/length(N) ) ); // reflect of environment map\n}\n\n","name":"Image","description":"","type":"image"}]}