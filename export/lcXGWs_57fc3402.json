{"ver":"0.1","info":{"id":"lcXGWs","date":"1704218136","viewed":68,"name":"Outer wilds solar system","username":"Miolith","description":"Click to rotate the camera.\nIf you have no clue what is being referenced here, you're missing something big.\n\nAnyway\nThe dark bramble planet is gitched sometimes but I don't understand why.\nThe giant planet has also some visual glitches on Android phone.\n","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","sun","planets","solar","system","outer","wilds"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Reproduction of Outer Wilds solar system by Miolith\n// I am currently learning shaders so there's nothing ground breaking here\n\n#define PI 3.14159265\n#define TWO_PI 6.28318531\n\n#define DEGREES_180 3.14159265\n#define DEGREES_90 1.57079633\n\n#define TIME_OFFSET 20.0\n#define TIME (iTime + TIME_OFFSET)\n\n#define SUN_COLOR_INDEX 0\n#define SUN_STATION_COLOR_INDEX 1\n#define EMBER_TWIN_COLOR_INDEX 2\n#define ASH_TWIN_COLOR_INDEX 3\n#define TIMBER_HEARTH_COLOR_INDEX 4\n#define ATTLEROCK_COLOR_INDEX 5\n#define BRITTLE_HOLLOW_COLOR_INDEX 6\n#define HOLLOW_BLACK_HOLE_COLOR_INDEX 7\n#define HOLLOWS_LANTERN_COLOR_INDEX 8\n#define GIANTS_DEEP_COLOR_INDEX 9\n#define DARK_BRAMBLE_COLOR_INDEX 10\n#define INTERLOPER_COLOR_INDEX 11\n#define WHITE_HOLE_COLOR_INDEX 12\n\nstruct VFXObj\n{\n    vec3 color;\n    float opacity;\n    float dist;\n};\n\nstruct Obj\n{\n    int color_index;\n    float dist;\n    vec3 relative_pos;\n};\n\nmat2x2 rotation(float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(\n        c, -s,\n        s, c\n    );\n}\n\nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\n\nfloat noise3d(vec3 x) {\n    const vec3 step = vec3(110, 241, 171);\n\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n \n    // For performance, compute the base input to a 1D\n    // hash from the integer part of the argument and the \n    // incremental change to the 1D based on the 3D -> 1D wrapping\n    float n = dot(i, step);\n\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\n\n// Credit to inigo quilez https://iquilezles.org/articles/\n\nfloat smin( float a, float b)\n{\n    float k = 0.05;\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n    p.y -= clamp( p.y, 0.0, h );\n    return length( p ) - r;\n}\n\nfloat sdCone( vec3 p, vec2 c, float h )\n{\n    float q = length(p.xz);\n    return max(dot(c.xy,vec2(q,p.y)),-h-p.y);\n}\n\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n    // sampling independent computations (only depend on shape)\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n\n    // sampling dependant computations\n    vec2 q = vec2( length(p.xz), p.y );\n    float k = dot(q,vec2(-b,a));\n    if( k<0.0 ) return length(q) - r1;\n    if( k>a*h ) return length(q-vec2(0.0,h)) - r2;\n    return dot(q, vec2(a,b) ) - r1;\n}\n\nvec2 ellipseRot(vec2 pos, float angle, vec2 distances)\n{\n    pos.x += cos(angle) * distances.x;\n    pos.y += sin(angle) * distances.y;\n    return pos;\n}\n\nObj closestObject(in Obj obj1, in Obj obj2)\n{\n    // You can't use ternary operators on struct...\n    // return (obj1.dist < obj2.dist) ? obj1 : obj2;\n    \n    if (obj1.dist < obj2.dist)\n        return obj1;\n    return obj2;\n}\n\nVFXObj closestObject(in VFXObj obj1, in VFXObj obj2)\n{\n    // You can't use ternary operators on struct...\n    // return (obj1.dist < obj2.dist) ? obj1 : obj2;\n    \n    if (obj1.dist < obj2.dist)\n        return obj1;\n    return obj2;\n}\n\n\nfloat rand(vec2 p)\n{\n\tp+=.2127+p.x+.3713*p.y;\n\tvec2 r=4.789*sin(789.123*(p));\n\treturn fract(r.x*r.y);\n}\n\nfloat noise(vec2 p)\n{\n\tvec2 i=floor(p-.5);\n\tvec2 f=fract(p-.5);\n\tf = f*f*f*(f*(f*6.0-15.0)+10.0);\n\tfloat rt=mix(rand(i),rand(i+vec2(1.,0.)),f.x);\n\tfloat rb=mix(rand(i+vec2(0.,1.)),rand(i+vec2(1.,1.)),f.x);\n\treturn mix(rt,rb,f.y);\n}\n\nfloat sphereSdf(vec3 pos, float radius)\n{\n    return length(pos) - radius;\n}\n\nObj sun(vec3 pos)\n{\n    vec3 sphere_pos = pos;\n    sphere_pos.xz *= rotation(-TIME *0.01);\n    \n    float waves = 0.015 \n                 * sin(pos.x * 20.0 + TIME)\n                 * sin(pos.y * 20.0  + TIME)\n                 * sin(pos.z * 20.0  + TIME);\n                 \n    float radius = 0.4 + waves;\n             \n    float dist = sphereSdf(sphere_pos, radius);\n        \n    return Obj(SUN_COLOR_INDEX, dist, sphere_pos);\n}\n\n\nObj sunStation(vec3 pos)\n{\n    vec3 sphere_pos = pos;\n    \n    float radius = 0.4;\n    sphere_pos.yz *= rotation(-TIME);\n    sphere_pos += vec3(0.0, 0.45, 0.0);\n    float dist = sdCone(sphere_pos, vec2(sin(1.2), cos(1.2)), 0.08);\n    sphere_pos.x -= 0.05;\n    float dist2 = sdCone(sphere_pos, vec2(sin(1.1), cos(1.1)), 0.06);\n    \n    dist = min(dist, dist2);\n        \n    return Obj(SUN_STATION_COLOR_INDEX, dist, sphere_pos);\n}\n\n\n\nObj hourglassTwins(vec3 pos)\n{\n    vec3 ash_pos = pos;\n    ash_pos.xy *= rotation(-TIME);\n    ash_pos += vec3(0.0, 0.6, 0.0);\n    ash_pos.xz *= rotation(TIME);\n    float black_dist = sphereSdf(ash_pos, 0.09);\n    vec3 black_color = vec3(1.000,0.871,0.220);\n    \n    vec3 ember_pos = pos;\n    ember_pos.xy = rotation(TIME) * ember_pos.xy;\n    ember_pos += vec3(0.0, 0.85, 0.0);\n    float radius = (abs(ember_pos.x) > 0.015) ? 0.11 : 0.08;\n    float ember_dist = sphereSdf(ember_pos, radius);\n    \n    Obj final = closestObject(\n        Obj(ASH_TWIN_COLOR_INDEX, black_dist, ash_pos),\n        Obj(EMBER_TWIN_COLOR_INDEX, ember_dist, ember_pos)\n    );\n    \n    vec3 sand_pos = pos;\n    sand_pos.xy = rotation(TIME) * sand_pos.xy;\n    sand_pos += vec3(0.0, 0.8, 0.0);\n    float sand_dist = sdVerticalCapsule(sand_pos, 0.25, 0.02);\n\n    \n    return closestObject(\n        final,\n        Obj(ASH_TWIN_COLOR_INDEX, sand_dist, sand_pos)\n    );\n}\n\nObj timberHearth(vec3 pos)\n{\n    const float distance_from_sun = 1.2;\n    const float size = 0.1;\n    \n    vec3 sphere_pos = pos;\n    sphere_pos.xy *= rotation(-TIME/1.2);\n    sphere_pos += vec3(0.0, 1.2, 0.0);\n    vec3 planet_pos = sphere_pos;\n    planet_pos.yz *= rotation(-TIME/1.5);\n    float dist = sphereSdf(planet_pos, 0.10);\n    \n    vec3 plant_pos = planet_pos;\n    float sand_dist = sdVerticalCapsule(plant_pos, 0.105, 0.02);\n    dist = smin(dist, sand_dist);\n    \n    vec3 moon_pos = sphere_pos;\n    moon_pos.xy += vec2(0.0, 0.2) * rotation(-TIME*2.0);\n    float moon_dist = sphereSdf(moon_pos, 0.02);\n    \n    return closestObject(\n        Obj(ATTLEROCK_COLOR_INDEX, moon_dist, moon_pos),\n        Obj(TIMBER_HEARTH_COLOR_INDEX, dist, sphere_pos)\n    );\n}\n\nObj brittleHollow(vec3 pos)\n{\n    const float distance_from_sun = 1.5;\n    const float size = 0.1;\n    \n    vec3 sphere_pos = pos;\n    sphere_pos.xy *= rotation(-TIME/distance_from_sun);\n    sphere_pos.y += distance_from_sun;    \n    float dist = abs(sphereSdf(sphere_pos, 0.1)) - 0.01;\n    \n    dist = max(-sphereSdf(sphere_pos - vec3(0.1,0.0,0.0), 0.05), dist);\n    \n    float black_hole_dist = sphereSdf(sphere_pos, 0.05);\n    \n    vec3 moon_pos = sphere_pos;\n    moon_pos.xy += vec2(0.0, 0.2) * rotation(TIME);\n    float moon_dist = sphereSdf(moon_pos, 0.02);\n            \n    return closestObject(\n        Obj(HOLLOWS_LANTERN_COLOR_INDEX, moon_dist, moon_pos),\n        closestObject(\n            Obj(BRITTLE_HOLLOW_COLOR_INDEX, dist, sphere_pos),\n            Obj(HOLLOW_BLACK_HOLE_COLOR_INDEX, black_hole_dist, sphere_pos)\n        )\n    );\n}\n\nObj giantsDeep(vec3 pos)\n{\n    const float distance_from_sun = 2.1;\n    const float size = 0.25;\n    \n    vec3 sphere_pos = pos;\n    sphere_pos.xy *= rotation(-TIME/distance_from_sun);\n    sphere_pos.y += distance_from_sun;   \n    float dist = sphereSdf(sphere_pos, 0.25);\n            \n    return Obj(GIANTS_DEEP_COLOR_INDEX, dist, sphere_pos);\n}\n\nObj darkBramble(vec3 pos)\n{\n    vec3 sphere_pos = pos;\n    sphere_pos.xy *= rotation(-TIME/2.8);\n    sphere_pos += vec3(0.0, 2.8, 0.0);\n    float dist = sphereSdf(sphere_pos, 0.09);\n    \n    vec3 plant_pos = sphere_pos;\n    \n    plant_pos.xy *= rotation(-DEGREES_90);\n    plant_pos.xz += 0.1 * vec2(cos(plant_pos.y * 12.0), sin(plant_pos.y*10.0));\n    float sand_dist = sdVerticalCapsule(plant_pos, 0.30, 0.01);\n    dist = min(dist, sand_dist);\n    \n    plant_pos = sphere_pos;\n    plant_pos.xy *= rotation(DEGREES_90);\n    plant_pos.xz += -0.1 * vec2(cos(plant_pos.y * 12.0), sin(plant_pos.y*10.0));\n    sand_dist = sdVerticalCapsule(plant_pos, 0.30, 0.01);\n    dist = min(dist, sand_dist);\n    \n    plant_pos = sphere_pos;\n    plant_pos.yz *= rotation(-DEGREES_90);\n    plant_pos.xz += -0.05 * vec2(cos(plant_pos.y * 12.0 + 1.0), sin(plant_pos.y*10.0 + 1.0));\n    sand_dist = sdVerticalCapsule(plant_pos, 0.30, 0.01);\n    dist = min(dist, sand_dist);\n    \n    plant_pos = sphere_pos;\n    plant_pos.yz *= rotation(DEGREES_90);\n    plant_pos.xz += -0.05 * vec2(cos(plant_pos.y * 10.0 + 1.0), sin(plant_pos.y*10.0 + 1.0));\n    sand_dist = sdVerticalCapsule(plant_pos, 0.35, 0.01);\n    dist = min(dist, sand_dist);\n    \n    plant_pos = sphere_pos;\n    plant_pos.yz *= rotation(DEGREES_90);\n    plant_pos.xz += -0.02 * vec2(cos(plant_pos.y * 15.0 + 3.0), sin(plant_pos.y*15.0 + 3.0));\n    sand_dist = sdVerticalCapsule(plant_pos, 0.35, 0.01);\n    dist = min(dist, sand_dist);\n    \n    plant_pos = sphere_pos;\n    plant_pos.yz *= rotation(DEGREES_90);\n    plant_pos.xz += 0.08 * vec2(cos(plant_pos.y * 35.0), sin(plant_pos.y*35.0));\n    sand_dist = sdVerticalCapsule(plant_pos, 0.35, 0.01);\n    dist = min(dist, sand_dist);\n    \n    dist *= 0.25;\n            \n    return Obj(DARK_BRAMBLE_COLOR_INDEX, dist, sphere_pos);\n}\n\nObj theInterloper(vec3 pos)\n{\n    const float size = 0.06;\n\n    vec3 sphere_pos = pos;\n    sphere_pos.xy = ellipseRot(\n        sphere_pos.xy + vec2(-1.3, 0.0),\n        TIME+sin(TIME)*0.5,\n        vec2(2.0, 0.7)\n    );\n    sphere_pos.xy *= rotation(-TIME - DEGREES_90);\n    float sphere_dist = sphereSdf(sphere_pos, size);\n    float dist = smin(sphere_dist,\n                sphere_dist + 0.03\n                * (sphere_pos.x > 0. ? 1. : 0.)\n                * sin(sphere_pos.y * 60.0)\n                * sin(sphere_pos.z * 70.0));\n                \n    return Obj(INTERLOPER_COLOR_INDEX, dist, sphere_pos);\n}\n\nObj whiteHole(vec3 pos)\n{\n    const float size = 0.02;\n    \n    vec3 planet_pos = pos;\n    planet_pos += vec3(2.4, -2.4, 0.0);\n    float dist = sphereSdf(planet_pos, size);\n    \n    return Obj(WHITE_HOLE_COLOR_INDEX, dist, planet_pos);\n}\n\nVFXObj InterloperVFX(vec3 pos)\n{\n    const float size = 0.06;\n\n    vec3 sphere_pos = pos;\n    sphere_pos.xy = ellipseRot(\n        sphere_pos.xy + vec2(-1.3, 0.0),\n        TIME+sin(TIME)*0.5,\n        vec2(2.0, 0.7)\n    );\n    sphere_pos.xy *= rotation(-TIME);\n    sphere_pos.y -= 0.09;\n    float dist = sdRoundCone(sphere_pos, 0.09, 0.01, 0.4);\n\n    vec3 color = vec3(0.659,0.851,1.000);\n    sphere_pos.y += 0.09;\n    float opacity = exp(-length(sphere_pos)*4.0 + 0.5);\n            \n    return VFXObj(color, opacity, dist);\n}\n\nVFXObj VFX(vec3 ray_pos)\n{\n    return InterloperVFX(ray_pos);\n}\n\nObj scene(vec3 ray_pos)\n{\n    Obj objects = closestObject(sun(ray_pos), hourglassTwins(ray_pos));\n    objects = closestObject(objects, sunStation(ray_pos));\n    objects = closestObject(objects, timberHearth(ray_pos));\n    objects = closestObject(objects, brittleHollow(ray_pos));\n    objects = closestObject(objects, giantsDeep(ray_pos));\n    objects = closestObject(objects, darkBramble(ray_pos));\n    objects = closestObject(objects, theInterloper(ray_pos));\n    objects = closestObject(objects, whiteHole(ray_pos));\n\n    return objects;\n}\n\n\n// ************** COLORIZE ************** //\n\n\nvec3 emberTwinColor() { return vec3(1.000,0.596,0.220); }\n\nvec3 ashTwinColor() { return vec3(1.000,0.871,0.220); }\n\nvec3 sunColor(vec3 relative_pos)\n{\n    vec3 color1 = vec3(1.000,0.494,0.220);\n    vec3 color2 = vec3(1.000,0.671,0.102);\n    \n    return mix(\n        color1,\n        color2,\n        smoothstep(0.8, 0.0, noise3d(relative_pos*20. +TIME*0.2))\n    );\n}\n\nvec3 sunStationColor() { return vec3(0.388,0.212,0.212); }\n\nvec3 timberHearthColor() { return vec3(0.196,0.404,0.275); }\n\nvec3 attleRockColor() { return vec3(0.612,0.612,0.612); }\n\nvec3 brittleHollowColor(vec3 relative_pos)\n{\n    vec3 color1 = vec3(0.282,0.282,0.439);\n    vec3 color2 = vec3(0.788,0.788,0.788);\n    \n    float color_rate = smoothstep(0.05, 0.045, length(relative_pos - vec3(0.0, 0.0, -0.1)));\n    return mix(color1, color2, color_rate);\n}\n\nvec3 hollowBlackHoleColor(vec3 relative_pos)\n{\n    vec3 black_hole_color = vec3(0.000,0.000,0.000);\n    vec3 border_color = vec3(1.000,0.400,0.000);\n    \n    float border = smoothstep(0.05, 0.052, length(relative_pos));\n    \n    return mix(black_hole_color, border_color, border);\n}\n\nvec3 hollowLanternColor() { return vec3(1.000,0.702,0.420); }\n\nvec3 giantsDeepColor(vec3 relative_pos)\n{\n    vec3 color1 = vec3(0.196,0.376,0.180);\n    vec3 color2 = vec3(0.196,0.384,0.314);\n    \n    vec3 color = mix(color1, color2,0.5 + 0.5*sin((relative_pos.y+relative_pos.x)*40.0));\n    \n    float period1 = min(1.0, mod(TIME*0.8, 6.11));\n    float period2 = min(1.0, mod(TIME*0.8+0.5, 4.11));\n    float lightning_frequency = max(\n            smoothstep(0.0, 0.1, period1) - smoothstep(0.18, 0.4, period1),\n            smoothstep(0.0, 0.1, period2) - smoothstep(0.18, 0.4, period2)\n    ) * 0.6;\n    \n    lightning_frequency = clamp(lightning_frequency, 0.0, 1.0);\n    vec3 lightning_color = vec3(1.000,0.380,0.380);\n    \n    float lightning_shape = noise(relative_pos.xy * 5. + mod(TIME, 15.11));\n    \n    return mix(color, lightning_color, lightning_frequency * lightning_shape);\n}\n\nvec3 darkBrambleColor(vec3 relative_pos)\n{\n    vec3 color = vec3(0.176,0.125,0.125);\n    vec3 hole_color = vec3(1.000,0.953,0.722);\n    \n    float hole_position = smoothstep(0.05, 0.04, length(relative_pos - vec3(0.0,0.09,0.0)));\n    return mix(color, hole_color, hole_position);\n}\n\nvec3 interloperColor() { return vec3(0.200,0.655,1.000); }\n\nvec3 whiteHoleColor() { return vec3(1.0); }\n\nvec3 colorize(Obj obj)\n{\n    vec3 col = vec3(0.0);\n    \n    switch(obj.color_index)\n    {\n        case SUN_COLOR_INDEX: col = sunColor(obj.relative_pos); break;\n        \n        case SUN_STATION_COLOR_INDEX: col = sunStationColor(); break;\n        \n        case EMBER_TWIN_COLOR_INDEX: col = emberTwinColor(); break;\n        \n        case ASH_TWIN_COLOR_INDEX: col = ashTwinColor(); break;\n        \n        case TIMBER_HEARTH_COLOR_INDEX: col = timberHearthColor(); break;\n        \n        case ATTLEROCK_COLOR_INDEX: col = attleRockColor(); break;\n        \n        case BRITTLE_HOLLOW_COLOR_INDEX: col = brittleHollowColor(obj.relative_pos); break;\n\n        case HOLLOW_BLACK_HOLE_COLOR_INDEX: col = hollowBlackHoleColor(obj.relative_pos); break;\n\n        case HOLLOWS_LANTERN_COLOR_INDEX: col = hollowLanternColor(); break;\n        \n        case GIANTS_DEEP_COLOR_INDEX: col = giantsDeepColor(obj.relative_pos); break;\n        \n        case DARK_BRAMBLE_COLOR_INDEX: col = darkBrambleColor(obj.relative_pos); break;\n        \n        case INTERLOPER_COLOR_INDEX: col = interloperColor(); break;\n        \n        case WHITE_HOLE_COLOR_INDEX: col = whiteHoleColor(); break;\n        \n        default: col = vec3(0.0); break;\n    }\n    \n    return col;\n}\n\nvec3 background(vec2 uv)\n{\n    // Star background\n    // I can't believe this actually works\n    float wave = sin(uv.x * 55.0 + 50.0)\n               * sin(uv.y * 48.0 + 37.)\n               * cos((uv.y * uv.x) * 45.0 + 85.);\n    \n    vec3 black = vec3(0.0);\n    vec3 white = vec3(1.0);\n    \n    return mix(black, white, smoothstep(0.99, 1.0, wave));\n}\n\n#define ZERO (min(iFrame,0)) // non-constant zero\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float h = 0.0001;\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*scene(pos+e*h).dist;\n    }\n    return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / min(iResolution.y, iResolution.x);\n    vec2 m = (iMouse.xy * 2.0 - iResolution.xy) / min(iResolution.y, iResolution.x);\n    if (iMouse.x <= 0.0 && iMouse.y <= 0.0)\n        m = vec2(0.0, 0.0);\n        \n    vec3 col = vec3(0.0, 0.0, 0.0);\n    \n    col = background(uv + m)+ background(uv + m +15.0);\n    \n    vec3 ray_origin = vec3(0.0, 0.0, -4.0);\n    \n    vec2 start_xy = uv;\n    vec3 ray_dir = normalize(vec3(start_xy, 1.5));\n    \n    ray_origin.yz *= rotation(-m.y);\n    ray_dir.yz *= rotation(-m.y);\n    \n    ray_origin.xz *= rotation(-m.x);\n    ray_dir.xz *= rotation(-m.x);\n\n    float t = 0.0;\n    vec3 ray_pos = ray_origin;\n    Obj atmosphere_info = Obj(-1, 0.0, vec3(0.0));\n    \n    Obj object;\n    \n    for (int i = 0; i < 132; i++)\n    {\n        ray_pos = ray_origin + ray_dir * t;\n\n        object = scene(ray_pos);\n        \n        t += object.dist;\n        \n        if (object.dist < 0.015)\n            atmosphere_info = object;\n        \n        if (t > 10.0 || object.dist < 0.001) break;\n    }\n    \n\n    vec3 color = colorize(object);\n    vec3 atmosphere_color = colorize(atmosphere_info);\n    \n    vec3 sun_light = vec3(1.000,0.686,0.141);\n    float sun_ray = 0.015/dot(uv,uv);\n\n    if (t < 10.0)\n    {\n        vec3 normal = calcNormal(ray_pos);\n        col = color;\n        \n        // We keep some objects bright\n        if (object.color_index != SUN_COLOR_INDEX \n            && object.color_index != WHITE_HOLE_COLOR_INDEX\n            && object.color_index != HOLLOWS_LANTERN_COLOR_INDEX)\n                col *= (clamp(dot(ray_pos, -normal), 0.0, 1.0) + 0.5);\n    }\n    else\n    {\n        col = mix(col, sun_light, sun_ray);\n        if (atmosphere_info.color_index == GIANTS_DEEP_COLOR_INDEX)\n            col = mix(col, atmosphere_color, 0.008/atmosphere_info.dist);\n            \n        if (atmosphere_info.color_index == TIMBER_HEARTH_COLOR_INDEX)\n            col = mix(col, vec3(1.0), 0.004/atmosphere_info.dist);\n    }\n    \n    \n    // Second ray march for visual effects (VFX)\n    float vfx_t = 0.0;\n    vec3 vfx_ray_pos = ray_origin;\n    VFXObj obj;\n    \n    for (int j = 0; j < 40; j++)\n    {\n        vfx_ray_pos = ray_origin + ray_dir * vfx_t;\n\n        obj = VFX(vfx_ray_pos);\n        \n        float dist = obj.dist;\n               \n        vfx_t += dist;\n        \n        if (vfx_t > 10.0 || dist < 0.001) break;\n    }\n    if (vfx_t < 10.0 && vfx_t < t)\n    {\n        col = mix(col, obj.color, obj.opacity);\n    }\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}