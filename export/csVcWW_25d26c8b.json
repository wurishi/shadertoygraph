{"ver":"0.1","info":{"id":"csVcWW","date":"1696133638","viewed":51,"name":"SciFi Panel Texture","username":"sdfgeoff","description":"Procedural texture for spaceships","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["texture","panel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n\n\nfloat chebyshev(vec3 coords) {\n    vec3 absd = abs(coords);\n    return max(max(absd.x, absd.y), absd.z);\n}\n\n\n/// Returns the distance to the cell point\nvec4 voroni(vec3 position) {\n    vec4 min_dist = vec4(100.0, 0.0, 0.0, 0.0);\n\n    for (float i=-1.0; i<=1.0; i+=1.0) {\n        for (float j=-1.0; j<=1.0; j+=1.0) {\n            for (float k=-1.0; k<=1.0; k+=1.0) {\n                \n                vec3 this_cell_id = floor(position) + 0.5 + vec3(i, j, k);\n                vec3 this_cell_offset = hash33(this_cell_id);\n                vec3 this_cell_point = this_cell_id + this_cell_offset;\n                vec3 offset_vec = position - this_cell_point;\n                float dist_to_this_cell_point = chebyshev(offset_vec);\n                if (dist_to_this_cell_point < min_dist.x) {\n                    min_dist = vec4(\n                        dist_to_this_cell_point,\n                        this_cell_offset\n                    );\n                }\n            }\n        }\n    }\n    return min_dist;\n}\n\n\n\nfloat bricks(vec2 uv, float mortar_size, float width, float height) {\n  float rownum = floor(uv.y / height);\n  float offset = width * 0.5 * float(int(rownum) % 2);\n  float bricknum = floor((uv.x + offset) / width);\n\n  float x = (uv.x + offset) - width * bricknum;\n  float y = uv.y - height * rownum;\n\n  float min_dist = min(min(x, y), min(width - x, height - y));\n  if (min_dist >= mortar_size) {\n    return hash12(vec2(rownum, bricknum)) * 0.9 + 0.1;\n  }\n  else {\n    return 0.0;\n  }\n}\n\n\n\nvec3 sampleTex(\n        vec2 uv,\n        \n        vec2 tile_size,\n        vec2 primary_size,\n        \n        vec3 tile1_color,\n        vec3 tile2_color,\n        vec3 primary_color,\n        vec3 grooves_color\n) {\n    const float bias = 0.05;\n    \n\tvec4 data = voroni(vec3(uv * primary_size, 0.5));\n    float primary_panels = clamp(mix(-20.0, 20.0, data.x + bias), -1.0, 1.0);\n    \n    float joiners = abs(primary_panels - 0.5);    \n    if (primary_panels < 0.0) {\n        return primary_color;\n    }\n    if (joiners < 0.2) {\n        return grooves_color;\n    }\n    \n    float texramp = bricks(uv, 0.0, (0.5 + data.y) * tile_size.x, (0.5 + data.y) * tile_size.y);\n    \n    return mix(\n            grooves_color,\n            mix(tile1_color, tile2_color, texramp),\n            step(0.1, texramp)\n        );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    uv.y += sin(iTime) * 0.2;\n    uv.y -= 0.5;\n    uv = abs(uv);\n    uv *= 3.0;\n    uv.x += iTime;\n    \n    \n    vec3 col = vec3(0.0);\n\n    col += sampleTex(\n        uv, \n        vec2(1.0),\n        vec2(1.0),\n        vec3(0.0, 0.1, 0.2),\n        vec3(0.4, 0.4, 0.5),\n        vec3(0.7, 0.5, 0.0),\n        vec3(0.0, 0.0, 0.0)\n    );\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}