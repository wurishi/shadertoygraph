{"ver":"0.1","info":{"id":"lXlfR2","date":"1729021730","viewed":40,"name":"Light in infinite cosmos","username":"cesio","description":"Raymarching, flare","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","spheres","flare"],"hasliked":0,"parentid":"4XXfRS","parentname":"Flying blobs"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#define a 0.021\n#define PI 3.1415\n#define EPSILON 0.0005\n// a number of small spheres\n#define N 12.\n// radius of small spheres\n//#define R 0.12 \n#define NO_HIT 100.\n#define LIGHT_ID 100000\n#define MIN_DISTANCE 0.0\n#define MAX_DISTANCE 50. \n#define PRECISION 0.01\n\nvec3 lightVector;\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 identity() {\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nstruct Surface {\n    vec3 col; // color\n    float d; // distance\n    int id;\n};\n\n// return a distance from point p and a sphere with center c and radius r and tm (transform matrix)\nSurface sdSphere(vec3 p, vec3 c, float r, vec3 color, mat3 tm, int id) {\n    vec3 pt = p * tm;\n    Surface res; res.col = color; res.d = length(pt - c) - r; res.id = id;\n  \n    return res;\n}\n    \n    \n// y - height of which the floor starts\nSurface sdFloor(vec3 p, float y, vec3 color) {\n    Surface res; \n    res.col = color;\n    res.d = p.y + y;\n    res.id = 0;\n    return res;\n}\n\nSurface minSurface(Surface s1, Surface s2) {\n    Surface res = s1;\n    if (res.d > s2.d) res = s2;\n    return res;\n}\n\n\nSurface roundMerge(Surface surface1, Surface surface2, float radius) {\n    float item1 = surface1.d;\n    float item2 = surface2.d;\n    \n    vec2 intersection = vec2(item1 - radius, item2 - radius);\n    intersection = min(intersection, 0.0);\n    float insideDistance = -length(intersection);\n    float simpleUnion = min(item1, item2);\n    float outsideDistance = max(simpleUnion, radius);\n    Surface res; res.d = insideDistance + outsideDistance;\n    res.id = surface1.id;\n    res.col = mix(surface1.col, surface2.col, item1-radius);\n    //res.col = surface1.col;\n    return  res;\n}\n\nSurface scene(vec3 pr) {\n    // multiply pattern by mod'uling x,y,z coordinates\n    float cx = 6.;\n    float cy = 0.;\n    float cz = 10.;\n    float nx = cx > 0. ? mod(pr.x + 0.5 * cx, cx) - 0.5 * cx : pr.x;\n    float ny = cy > 0. ? mod(pr.y + 0.5 * cy, cy) - 0.5 * cy : pr.y;\n    float nz = cz > 0. ? mod(pr.z + 0.5 * cz, cz) - 0.5 * cz : pr.z;\n    vec3 p = vec3(nx, ny, nz);\n    \n    //vec3 p = mod(pr + 0.5 * c, c) - 0.5 * c;\n    float rX = 45. + sin(iTime) / 5.;\n    Surface res = sdSphere(p, vec3(0., 0.5, -0.), 0.5, vec3(0.98, 0.87, 0.), identity(), 0);\n    float dR = 2. / N * PI; // N spheres around a big one with 360 degrees / N distance between them\n    float offset = 0.;\n    float dd = 0.24 / N;\n            \n    for (int i = 0; i < int(N); i++) {\n        offset += dR;\n        float x = cos(iTime + offset) * 0.6;;\n        float y = sin(iTime + offset) * 1.9 + 0.6;\n        float z = 0.2;//x + y;\n        float r = 0.03 + float(i) * dd;//R * abs(sin(iTime + mod(float(i),4.)));\n        \n\n        //res = roundMerge(res, sdSphere(p, vec3(x, y, z), r, vec3(0., 0.6, 1.), rotateX(rX), 0), 0.23);\n        res = minSurface(res, sdSphere(p, vec3(x, y, z), r, vec3(0., 0.6, 1.), rotateX(rX), 0));\n    }\n    \n    // floor\n    vec3 floorColor = vec3(0.3 + 1.*mod((floor(pr.x) + floor(pr.z)) , 2.0)); // think about interesting color pattern for the floor\n    res = minSurface(res,sdFloor(pr, 1., floorColor));\n    \n    // light source\n    res = minSurface(res, sdSphere(pr, lightVector, 0.05, vec3(1., 1., 1.), identity(), LIGHT_ID));\n  \n\n    return res;\n}\n\n\n// vector normal to sphere with cener c and radius r\nvec3 calcNormal(vec3 p) {\n  vec2 e = vec2(1.0, -1.0) * EPSILON;\n  return normalize(\n    e.xyy * scene(p + e.xyy).d +\n    e.yyx * scene(p + e.yyx).d +\n    e.yxy * scene(p + e.yxy).d +\n    e.xxx * scene(p + e.xxx).d);\n}\n\n\nstruct RaymarchRes {\n    Surface s;\n    float l; // light\n    float d; // distance\n};\n\nRaymarchRes raymarch(vec3 ro, vec3 rd, vec3 lightVector) {\n    float t = MIN_DISTANCE; \n    RaymarchRes res; res.l = NO_HIT;\n        \n    for (int i = 0; i < 255; i++) {\n        vec3 p = ro + t * rd;\n        Surface sf = scene(p); \n        t += sf.d;\n        //t += 1.1 * min(sf.d, 5.0 );\n        \n        if (sf.d < PRECISION) { // we hit the surface at point p\n            vec3 normalToSurfaceVector = calcNormal(p);\n            res.l = clamp(dot(normalToSurfaceVector, normalize(lightVector - p)), 0.1, 1.);\n            if (sf.id == LIGHT_ID) res.l = 1.0; // special case when we draw a source of light\n            res.s = sf;\n            break;\n        } else if (sf.d > MAX_DISTANCE) break; // we did not hit anything but are to far away from camera \n            //t += sf.d; // we did not hit anything, keep on trying\n    }\n    \n    res.d = t;\n    return res;\n}\n    \nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n    vec3 cd = normalize(lookAtPoint - cameraPos);\n    vec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n    vec3 cu = normalize(cross(cd, cr));\n\n    return mat3(-cr, cu, -cd);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n\n    vec3 lookAt = vec3(0.0,0.4, -1.);\n    float cameraTime = iTime * 0.2;\n    float lightTime = iTime * 1.;\n\n    // calculate position of the camera\n    float cameraRadius = 2. * sin(cameraTime) + 4.;\n    vec3 ro; ro.x = cameraRadius * cos(cameraTime) + lookAt.x;\n    ro.y = 0.8;\n    ro.z = cameraRadius * sin(cameraTime) + lookAt.z; \n    \n    vec3 rd = camera(ro, lookAt) * normalize(vec3(uv, -1.));\n   \n    // calculate position of the light\n    float lightRadius = 2.;\n    lightVector.x = lightRadius * cos(lightTime);\n    lightVector.y = 0.4;\n    lightVector.z = lightRadius * sin(lightTime); \n    \n    //lightPos = vec3(-0.6 + 2. * cos(lightTime), 1.5, 1.0);\n    //vec3 lightVector = lightPos;//vec3(-0.6, 0.5, 1.0);\n    //lightVector = vec3(-0.25, 0., 8.);\n\n    RaymarchRes rr = raymarch(ro, rd, lightVector);\n   \n   \n    vec3 bgColor = vec3(0., 0., 0.);\n    vec3 color = bgColor;\n \n    // fog\n    color = mix(rr.l * rr.s.col, bgColor, 1.0  - 1. * exp(-0.0002 *  rr.d * rr.d * rr.d));\n     \n    // sun\n    vec3 sun = vec3(1., 0.8, 0.6) * pow(clamp(dot(0.5 - lightVector, 0.5 - rd), 0.0, 1.), 1.0);\n    color+= sun;\n    \n    // vigniete 1 type\n    //fragColor = vec4(vec3(color * exp(-1.1 * (length(uv)))), 1.0);\n\n    // vigniete 2 type\n    vec2 q = fragCoord.xy / iResolution.xy;\n    fragColor = vec4(vec3(color * pow(20. * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.9)), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}