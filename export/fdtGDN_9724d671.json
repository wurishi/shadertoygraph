{"ver":"0.1","info":{"id":"fdtGDN","date":"1629915714","viewed":308,"name":"Tone mapping experiments","username":"tiusic","description":"Playing with tone mapping. I'm not aiming for realism, I want cartoonishly extravagant colors. In particular, I want red to fade to orange/yellow before fading to white.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["hdr","tonemapping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Experimenting with tone mapping. I'm not aiming for realism, I want\n// cartoonishly extravagant colors. In particular, I want red to fade to orange\n// or yellow before fading to white, whereas most tone mappers just fade from\n// red to white. Similarly, green should fade through cyan, and blue should fade\n// through magenta.\n\n// The function commented as \"Old HDR function\" did this, but had patches where\n// the color didn't change. This produced ugly results in the final image. It's\n// easy to do smooth tone mapping, and it's easy to bleed one channel into\n// another in the asymmetric way I want, but it turns out to be really hard to\n// do both of those things at the same time.\n\n// After a bunch of failed experiments I settled on the hdr function it's\n// running now. This is a complicated piecewise function that essentially has\n// six hard coded gradients, for different hues, and lerps between them (plus a\n// bunch of corrections and hacks).\n\n\nvec3 mid3_(vec3 v) { return v.y < v.z ? vec3(0, v.y, 0) : v.x < v.z ? vec3(0, 0, v.z) : vec3(v.x, 0, 0); }\nvec3 mid3(vec3 v) { return v.x < v.y ? mid3_(v) : mid3_(v.yxz).yxz; }\nvec3 max3v(vec3 v) { return v.x < v.y ? (v.y < v.z ? vec3(0, 0, v.z) : vec3(0, v.y, 0)) : (v.x < v.z ? vec3(0, 0, v.z) : vec3(v.x, 0, 0)); }\nfloat max3(vec3 v) { return max(max(v.x, v.y), v.z); }\nvec3 lerp(vec3 a, vec3 b, float t) { return (1. - t) * a + t * b; }\nvec3 qerp(vec3 a, vec3 b, float t) { return sqrt(1. - t * t) * a + t * b; }\n\nfloat tri(float x) {\n  x = mod(2. * x, 2.);\n  return x < 1. ? 3. * x - 1. : 5. - 3. * x;\n}\n\nvec3 hue(float h) {\n  return clamp(vec3(tri(h+0.5), tri(h+1./6.), tri(h-1./6.)), 0., 1.);\n}\n\nvec3 baseColor(vec2 uv) {\n  return 3. * uv.y * lerp(hue(uv.x), vec3(1), 0.5 + 0.5 * sin(iTime));\n}\n\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// Uchimura is copied from https://www.shadertoy.com/view/llXyWr\nfloat Tonemap_Uchimura(float x, float P, float a, float m, float l, float c, float b) {\n    // Uchimura 2017, \"HDR theory and practice\"\n    // Math: https://www.desmos.com/calculator/gslcdxvipg\n    // Source: https://www.slideshare.net/nikuque/hdr-theory-and-practicce-jp\n    float l0 = ((P - m) * l) / a;\n    float L0 = m - m / a;\n    float L1 = m + (1.0 - m) / a;\n    float S0 = m + l0;\n    float S1 = m + a * l0;\n    float C2 = (a * P) / (P - S1);\n    float CP = -C2 / P;\n\n    float w0 = 1.0 - smoothstep(0.0, m, x);\n    float w2 = step(m + l0, x);\n    float w1 = 1.0 - w0 - w2;\n\n    float T = m * pow(x / m, c) + b;\n    float S = P - (P - S1) * exp(CP * (x - S0));\n    float L = m + a * (x - m);\n\n    return T * w0 + L * w1 + S * w2;\n}\n\nfloat Tonemap_Uchimura(float x) {\n    const float P = 1.0;  // max display brightness\n    const float a = 1.0;  // contrast\n    const float m = 0.22; // linear section start\n    const float l = 0.4;  // linear section length\n    const float c = 1.33; // black\n    const float b = 0.0;  // pedestal\n    return Tonemap_Uchimura(x, P, a, m, l, c, b);\n}\n\nvec3 Tonemap_Uchimura_RGB(vec3 v) {\n  return vec3(Tonemap_Uchimura(v.r), Tonemap_Uchimura(v.g), Tonemap_Uchimura(v.b));\n}\n\n\nfloat uchi(float x) {\n  float w0 = 1.0 - smoothstep(0.0, 0.22, x);\n  float w2 = step(0.532, x);\n  float S = 1. - 0.468 * exp((0.532 - x) / 0.468);\n  return 0.22 * pow(x / 0.22, 1.33) * w0 + S * w2 + x * (1.0 - w0 - w2);\n}\nvec3 uchi(vec3 v) { return vec3(uchi(v.r), uchi(v.g), uchi(v.b)); }\n\n\n// Old HDR function\n//vec3 hdr(vec3 c) { return c + max(c - 1., 0.).brg + max(c - 2., 0.).gbr; }\n\n\n// Experiments\n// vec3 hdr(vec3 c) { return c + max(max3(c) - 1., 0.); }\n// vec3 hdr(vec3 c) { return c + max(length(c) - 1., 0.); }\n// vec3 hdr(vec3 c) { return Tonemap_Uchimura_RGB(c); }\n\n/*vec3 hdr(vec3 c) {\n  float k = max3(c);\n  float k1 = max(k - 1., 0.);\n  float k2 = max(k - 2., 0.);\n  vec3 d = clamp(c, 0., 1.);\n  return d + k1 * d.brg + k2 * vec3(1.);\n}*/\n\n/*vec3 hdrc(vec3 v) {\n  const float p = 1.;\n  return vec3(pow(v.b, p), pow(v.r, p), pow(v.g, p));\n}\n\nvec3 hdr(vec3 c) {\n  float k = max3(c);\n  float k1 = max(k - 1., 0.);\n  float k2 = clamp(k - 2., 0., 1.);\n  vec3 d = clamp(c, 0., 1.);\n  return lerp(d + k1 * hdrc(d), vec3(1.), k2);\n}*/\n\n/*vec3 hdr(vec3 c) {\n  vec3 k = max3v(c);\n  //float p = mid3(c);\n  //float k1 = max(k - 1., 0.);\n  //float k2 = max(k - 2., 0.);\n  //return vec3(p);\n  //return c + max(k - 1., 0.);\n  \n  return c + max(k - 1., 0.).brg;\n}*/\n\n/*vec3 hdr(vec3 c) {\n  float k = max3(c);\n  if (k < 1.) return c;\n  c = c / k + max(k - 1., 0.);\n  return c;\n}*/\n\n/*vec3 hdr(vec3 c) {\n  float m = max3(c);\n  if (m <= 1.) return c;\n  float k = 0.5 * (m - 1.);\n  float q = clamp(k, 0., 1.);\n  c = lerp(c / m, vec3(1.), q);\n  vec3 z = c - max3v(c);\n  return c + q * z;\n}*/\n\n/*vec3 hdr(vec3 c) {\n    float brightest = max(max(c.x, c.y), c.z);\n\n    const float kBrightBlendStart = .5;\n    const float kBrightBlendEnd = 3.5;\n\n    float super_bright = smoothstep(kBrightBlendStart, kBrightBlendEnd, brightest);\n\n    return mix(c, vec3(1), super_bright);\n}*/\n\n/*vec3 hdr(vec3 c) {\n    float brightest = max(max(c.x, c.y), c.z);\n\n    const float kBrightHueStart = .5;\n    const float kBrightHueEnd = 2.;\n    float hue_super_bright = smoothstep(kBrightHueStart, kBrightHueEnd, brightest);\n\n    const float kBrightSatStart = 2.;\n    const float kBrightSatEnd = 3.5;\n    float sat_super_bright = smoothstep(kBrightSatStart, kBrightSatEnd, brightest);\n\n    vec3 hsv = rgb2hsv(c);\n\n    float mapped_hue = mix(hsv.x, hsv.x + .1, hue_super_bright);\n    float mapped_sat = mix(hsv.y, 0., sat_super_bright);\n\n    return hsv2rgb(vec3(mapped_hue, mapped_sat, hsv.z));\n}*/\n\n/*vec3 hdr1(vec3 c) {\n  vec3 d0 = vec3(c.r + max(c.b - 0.8, 0.), c.g + 0.8 * max(c.b - 1.6, 0.), c.b);\n  float k = max(c.r, c.g) / c.b;\n  if (c.r > c.g) {\n    vec3 d1 = vec3(c.r, c.g + 0.8 * max(c.r - 0.8, 0.), c.b);\n    return lerp(d0, d1, k);\n  } else {\n    vec3 d1 = vec3(c.r + 0.8 * max(c.g - 0.8, 0.), c.g, c.b);\n    return lerp(d0, d1, k);\n  }\n}*/\n\n\n// Nicest algorithm I've got so far. Super complicated piecewise approach.\nfloat qq(float q, float p) { return pow(p, 4. * q * (q - 1.)); }\nvec3 hdrr(vec3 c) {\n  float l = min(c.g, c.b);\n  float m = (c.r - l);\n  if (m < 1e-6) return c;\n  float k = (max(c.g, c.b) - l) / m;\n  vec3 d = c + (1. - k) * vec3(0, 1.1 * max(c.r - 0.7, 0.), max(c.r - 1.2, 0.));\n  if (c.g > c.b) {\n    d.b += k * max(c.g - 0.8, 0.);\n  } else {\n    d.g += k * max(c.b - 0.8, 0.);\n  }\n  float j = 0.5 + 0.5 * (c.g > c.b ? k : -k);\n  float g = clamp(log(m / l), 0., 1.);\n  const float J = 0.38;\n  if (j < J) {\n    d.g *= qq(j / J, 1. - g * 0.2);\n    d.b /= qq(j / J, 1. - g * 0.2);\n  } else {\n    d.b *= qq((j - J) / (1. - J), 1. - g * 0.4);\n    d.g /= qq((j - J) / (1. - J), 1. - g * 0.2);\n  }\n  if (m < 0.3) {\n    return lerp(c, d, m / 0.3);\n  }\n  return d;\n}\n\nvec3 hdr(vec3 c) {\n  if (c.r > c.g && c.r > c.b) {\n    c = hdrr(c);\n  } else if (c.g > c.b && c.g > c.r) {\n    c = hdrr(c.gbr).brg;\n  } else if (c.b > c.r && c.b > c.g) {\n    c = hdrr(c.brg).gbr;\n  }\n  return uchi(c) * 1.05;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    //uv.x = 1./6.;\n    //uv.x = 1./12.;\n    //uv.x = 0.;\n    //uv.x = 11./12.;\n    //uv.x = 5./6.;\n    //uv.x = iTime / 30.;\n    vec3 c = baseColor(uv);\n    c = hdr(c);\n    //if (c.r >= 1. && c.g >= 1. && c.b >= 1.) c = vec3(0);\n    fragColor = vec4(c,1.0);\n}","name":"Image","description":"","type":"image"}]}