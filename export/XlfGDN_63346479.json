{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// Optimized version by Michael Pohoreski\n// Copyleft {c} 2015 Michael Pohoreski\n//\n// Original version by Sam\n// GPU version: http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\n// CPU version: http://lolengine.net/blog/2013/01/13/fast-rgb-to-hsv\n//\n// For a slower HSV2RB version also see: http://ploobs.com.br/?p=1499\n\n    // HueSaturationValue to RGB\n    // Input:\n    //    c.x Hue\n    //    c.y Saturation\n    //    c.z Value\n#if 0 // Original\n    vec3 hsv2rgb(vec3 c)\n    {\n        vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n        vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n        return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n    }\n#else // Minified/Optimized\n    vec3 hsv2rgb(vec3 c)\n    {\n        //vec3 K = vec3(3,2,1)/3.;\n        //return c.z * mix(K.xxx, clamp(abs(fract(c.xxx + K)*6. - vec3(3.)) - K.xxx, 0., 1.), c.y);\n        // Which can be further optimized to:\n        // Thanks to las @ http://www.pouet.net/user.php?who=4548\n        return mix(vec3(1.),clamp((abs(fract(c.x+vec3(3,2,1)/3.)*6.-3.)-1.),0.,1.),c.y)*c.z;\n    }\n\n    vec3 hue2rgb(float normalizedHueAngle)\n    {\n        return clamp(abs(fract(vec3(normalizedHueAngle)+vec3(3,2,1)/3.)*6.-3.)-1., 0., 1.);\n    }\n#endif\n\n// Thanks yakoudbz for this idea to minimize the discontinuity!\n// Unfortunately there is no good way to remove the discontinuity as it needs to be an _integer_ multiple.\n// See this version which does a straight linear blend between N an N+1\n// https://www.shadertoy.com/view/XtfGDN\n#define MIN_DISCONTUINITY\n//    const float PI = 3.14159265358979323846264;\n//    float N = 2.+cos(iTime);\n//    float d = atan(p.y,p.x) * N/PI;\n// To \"single step\" the rainbow\n//     float N = floor(iTime);\n//\n// Legend:\n//   d = angle (was originally in degrees)\n//   c = color\n//   m = mix\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2  p = 2.*fragCoord.xy/iResolution.xy - 1.; // uv coordinates -1 .. +1\n    float d = atan(p.y,p.x) + iTime; // angle\n#ifdef MIN_DISCONTUINITY\n    const float PI = 3.14159265358979323846264;\n    float N = 2.+cos(iTime);\n    d -= iTime;\n    d *= N/PI; // Technically should be N/(2.0*PI), but N/PI looks better with twice the rings\n#endif\n    vec3  c = hsv2rgb( vec3(d,1.0,1.0) ); // hsv\n    vec3  m = vec3(c.r,c.g,c.b);\n    fragColor = vec4(m, 1.0 );\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XlfGDN","date":"1421960933","viewed":496,"name":"HSV2RGB Minified","username":"MichaelPohoreski","description":"A cleaned up version of Sam's HSV2RGB()","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["color","optimization","conversion"],"hasliked":0,"parentid":"","parentname":""}}