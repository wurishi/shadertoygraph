{"ver":"0.1","info":{"id":"MstGRn","date":"1447803503","viewed":1035,"name":"Smooth Terrain Mesh","username":"huwb","description":"Collaboration with Beibei Wang. View adaptive mesh suitable for terrain rendering. LOD levels are smoothly transitioned (turns on and off every 5s). Inspired by McGuire's nice terrain rendering blog post (see comments). Click mouse to move detail focus.","likes":45,"published":1,"flags":0,"usePreview":0,"tags":["terrain","lod","sampling","smooth"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nThe MIT License (MIT)\n\nCopyright (c) 2015 Huw Bowles & Beibei Wang\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\n// Some work I did recently in collaboration with Beibei Wang.\n//\n// This is follow up work to Morgan McGuire's excellent blog post on best practices in terrain\n// rendering:\n// http://casual-effects.blogspot.co.uk/2014/04/fast-terrain-rendering-with-continuous.html\n//\n// The problem we address is that the transitions between lods are not perfect. there are verts\n// in a LOD level that are located in the middle of an edge in the next LOD. this can lead to\n// artifacts in the render. to combat this one can manually sample at both LOD levels and\n// then interpolate the result. this still doesn't get a 100% accurate result - to get a vert\n// to match the middle of an edge, it needs to take the average of the 2 verts that are connected\n// by the edge, not the average of all 4 surrounding verts.\n//\n// We eliminate this issue by gradually transitioning the vert layout. just before LODs change,\n// the verts match exactly. this means that one can simply do a single trilinear sample from the\n// terrain data texture and know the the transition will be 100% smooth.\n//\n// Most of the complexity in this shader comes from drawing a mesh. the novel code here\n// is small and concise - see the lod transition function smoothTransVert and surrounding\n// comments. this can be added to a vertex shader, leading to a very nice, simple and robust\n// terrain renderer. \n//\n\nbool doSmoothLods;\n\nfloat vert_spacing_at_1m = 0.1;\nfloat min_vert_spacing = exp2(-5.);\n// interpolation to next lod\nfloat frac_high;\n\nfloat line( vec2 p, vec2 start, vec2 end, float wp );\nvoid smoothTransVert( inout vec2 v, float ss );\n\n#define SCALE 10.\nvec2 uvToWorld( vec2 uv );\n\n// this function just generates geometry - not necessary with a mesh\nvoid emit( vec2 uv, vec2 v0, float ss, inout float l )\n{\n    vec2 v1 = v0+vec2(ss,0.);\n    vec2 v2 = v0+vec2(0.,ss);\n    vec2 v3 = v0+vec2(ss,ss);\n\n    bool odd = mod( v0.y, 2. * ss ) > 0.25*ss;\n    if( mod( v0.x, 2. * ss ) > 0.25*ss )\n        odd = !odd;\n    \n    // the magic sauce to transition lod levels is in this fn\n    smoothTransVert( v0, ss );\n    smoothTransVert( v1, ss );\n    smoothTransVert( v2, ss );\n    smoothTransVert( v3, ss );\n\n    float w = 3.;\n    l = max( l, line( uv, v0, v1, w ) );\n   \tl = max( l, line( uv, v2, v3, w ) );\n    l = max( l, line( uv, v0, v2, w ) );\n    l = max( l, line( uv, v1, v3, w ) );\n\n    if( odd )\n\t    l = max( l, line( uv, v1, v2, w ) );\n    else\n\t    l = max( l, line( uv, v0, v3, w ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    doSmoothLods = mod(iTime, 10.) < 5.;\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uvToWorld( uv );\n    \n    vec2 camPos = vec2(SCALE/2.,SCALE/4.)+vec2(cos(iTime),sin(iTime));\n    \n    // player can posess detail center using mouse action\n    if( iMouse.z > 0. )\n        camPos = uvToWorld( iMouse.xy/iResolution.xy);\n    \n    float dist = max( abs(camPos.x-uv.x),abs(camPos.y-uv.y) );\n    \n    float desSS = max( dist * vert_spacing_at_1m, min_vert_spacing );\n    float desSS2 = exp2( floor( log2( desSS ) ) );\n    \n    // this is pure hackery to make the output look like a mesh when smoothing is\n    // NOT enabled (this can be knocked out for simplicity)\n    if( !doSmoothLods )\n    {\n        // trial and error programming at its best\n        vec2 camPos2 = camPos - mod( camPos, desSS2*2. );\n        float dist2 = max( abs(camPos2.x-uv.x),abs(camPos2.y-uv.y) );\n        if( \n            !(exp2(floor(log2(max(dist2*vert_spacing_at_1m, min_vert_spacing )))) > desSS2\n           ||exp2(floor(log2(max((dist2+desSS2*2.)*vert_spacing_at_1m, min_vert_spacing )))) > desSS2 ))\n            desSS2 /= 2.;\n    }\n    \n    // blend factor between LODs\n    frac_high = doSmoothLods ? clamp( desSS/desSS2-1.,0.,1.) : 1.;\n    \n    desSS = desSS2;\n    \n    vec2 uvf = desSS*floor(uv/desSS);\n    vec2 v0 = uvf;\n\n    float l = 0.;\n    \n    // emit the local neighbourhood of \"quads\" (sets of 2 triangles)\n    emit( uv, v0, desSS, l );\n    emit( uv, v0-vec2(desSS,0.), desSS, l );\n    emit( uv, v0+vec2(desSS,0.), desSS, l );\n    emit( uv, v0-vec2(0.,desSS), desSS, l );\n    emit( uv, v0+vec2(0.,desSS), desSS, l );\n    emit( uv, v0+vec2( desSS, desSS), desSS, l );\n    emit( uv, v0+vec2(-desSS, desSS), desSS, l );\n    emit( uv, v0+vec2( desSS,-desSS), desSS, l );\n    emit( uv, v0+vec2(-desSS,-desSS), desSS, l );    \n    \n    fragColor.rgb = 1. - mix( vec3(.8), vec3(.1), l );\n}\n\n// this does the smooth transitions between lods. for each set of 4x4 patches\n// as shown below, the close neighbour verts labelled N will be transitioned\n// towards the center vert labelled C:\n// x--x--x--x--x\n// |  |  |  |  |\n// x--N--N--N--x\n// |  |  |  |  |\n// x--N--C--N--x\n// |  |  |  |  |\n// x--N--N--N--x\n// |  |  |  |  |\n// x--x--x--x--x\nvoid smoothTransVert( inout vec2 v, float desSS )\n{\n    // size of 4x4 patch\n\tfloat squareSize_4 = 4. * desSS;\n    // vert fractional position in patch (0-1)\n\tvec2 m = fract(v/squareSize_4);\n    // offset from center of patch (at 0.5 fractionally)\n\tvec2 offset = m - 0.5;\n    // if offset is less than a radius of ~1 square, shift it towards the center\n\tfloat minRadius = 0.25*1.1; //1.1 is \"epsilon\" for numerical issues\n\tif( abs(offset.x) < minRadius ) v.x += offset.x*frac_high*squareSize_4;\n\tif( abs(offset.y) < minRadius ) v.y += offset.y*frac_high*squareSize_4;\n    // thats it!\n}\n\n// distance from p to line from v to w. sorry i've lost the reference, if this looks\n// like your code let me know and i'll cite you!\n// iq gives a condensed version in the comments.\nfloat line_d(vec2 p, vec2 v, vec2 w)\n{\n  // Return minimum distance between line segment vw and point p\n  float l2 = dot(v-w, v-w);  // i.e. |w-v|^2 -  avoid a sqrt\n  if (l2 == 0.0) return distance(p, v);   // v == w case\n  // Consider the line extending the segment, parameterized as v + t (w - v).\n  // We find projection of point p onto the line. \n  // It falls where t = [(p-v) . (w-v)] / |w-v|^2\n  float t = dot(p - v, w - v) / l2;\n  if (t < 0.0) return distance(p, v);       // Beyond the 'v' end of the segment\n  else if (t > 1.0) return distance(p, w);  // Beyond the 'w' end of the segment\n  vec2 projection = v + t * (w - v);  // Projection falls on the segment\n  return distance(p, projection);\n}\n// line helper\nfloat line( vec2 p, vec2 start, vec2 end, float wp )\n{\n    float d = line_d( p, start, end );\n    float w = wp/iResolution.x;\n    return smoothstep(w+5./iResolution.x,w,d);\n}\n\nvec2 uvToWorld( vec2 uv )\n{\n    uv.y *= iResolution.y/iResolution.x;\n    uv *= SCALE;\n    return uv;\n}\n","name":"Image","description":"","type":"image"}]}