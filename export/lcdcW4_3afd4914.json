{"ver":"0.1","info":{"id":"lcdcW4","date":"1730681005","viewed":31,"name":"Working Blob Grid","username":"felipesbs","description":"blob grid","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["blob"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float random(vec2 st)\n{\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat random_time(vec2 st)\n{\n    return fract(iTime + sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nfloat circle(vec2 uv, vec2 center, float r, float k)\n{\n    return smoothstep(r + k, r, length(uv - center));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 gridSize = vec2(9.0, 5.0);\n    vec2 uv = fragCoord / iResolution.xy;\n    uv *= gridSize;\n    vec2 cell = floor(uv);\n    uv = fract(uv) - 0.5;\n\n    float noiseValue = random(cell);\n    float num = 5.0;\n    float circ = 0.0;\n    float maxRadius = min(1.0 / gridSize.x, 1.0 / gridSize.y) * 0.6;\n\n    // Use noise to influence orbit and phase parameters\n    float baseOrbitRadiusX = maxRadius * (0.1 + noiseValue);\n    float baseOrbitRadiusY = maxRadius * (0.9 + noiseValue * 0.5);\n    float basePhaseOffset = noiseValue * 3.1415 * 2.0;\n    float baseSpeed = 0.3 + noiseValue;\n\n    // Introduce an \"attraction center\" that all orbits are slightly pulled toward\n    vec2 attractionCenter = vec2(0.0);\n    for (float i = 0.0; i < num; i++)\n    {\n        float orbitRadiusX = baseOrbitRadiusX * (1.0 + 0.7 * i);\n        float orbitRadiusY = baseOrbitRadiusY * (1.0 + 0.6 * i);\n        float phaseOffset = basePhaseOffset + i * 3.1415 / 2.0;\n\n        // Calculate center position with a circular motion for \"wobble\"\n        float direction = mod(i, 2.0) == 0.0 ? 1.0 : -1.0;\n        vec2 center = vec2(\n            orbitRadiusX * cos(direction * baseSpeed * iTime + phaseOffset),\n            orbitRadiusY * sin(direction * baseSpeed * iTime + phaseOffset)\n        );\n\n        // Slight circular motion for the center of the orbits\n        center += vec2(\n            0.02 * cos(iTime + noiseValue * 3.1415),\n            0.02 * sin(iTime + noiseValue * 3.1415)\n        );\n\n        // Accumulate centers to calculate an \"average\" for attraction effect\n        attractionCenter += center;\n\n        float radius = maxRadius * (0.5 + 0.2 * i);\n        circ += circle(uv, center, radius, 0.1);\n    }\n\n    // Average position to pull circles toward\n    attractionCenter /= num;\n\n    // Re-calculate each circle with an attraction effect toward attractionCenter\n    for (float i = 0.0; i < num; i++)\n    {\n        float radius = maxRadius * (0.5 + 0.2 * i);\n        float orbitRadiusX = baseOrbitRadiusX * (1.0 + 0.1 * i);\n        float orbitRadiusY = baseOrbitRadiusY * (1.0 + 0.9 * i);\n        float phaseOffset = basePhaseOffset + i * 3.1415 / 2.0;\n\n        // Calculate original center position\n        float direction = mod(i, 2.0) == 0.0 ? 1.0 : -1.0;\n        vec2 center = vec2(\n            orbitRadiusX * cos(direction * baseSpeed * iTime + phaseOffset),\n            orbitRadiusY * sin(direction * baseSpeed * iTime + phaseOffset)\n        );\n\n        // Circular motion for the orbit center\n        center += vec2(\n            0.02 * cos(iTime + noiseValue * 3.1415),\n            0.02 * sin(iTime + noiseValue * 3.1415)\n        );\n\n        // Attraction effect toward the average center\n        center = mix(center, attractionCenter, 0.1); // 0.1 is the attraction strength\n\n        circ += circle(uv, center, radius, 0.1);\n    }\n\n    fragColor = vec4(smoothstep(0.2, 0.25, circ));\n}\n","name":"Image","description":"","type":"image"}]}