{"ver":"0.1","info":{"id":"ctjcRc","date":"1692162838","viewed":91,"name":"light2d_5_refraction","username":"shicz86","description":"2d ray marching\nthis demo can be optimised,but i just want to translate the orginal c version to shadertoy.","likes":6,"published":1,"flags":32,"usePreview":1,"tags":["2d","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord)/iResolution.xy;\n    vec4 data = texture(iChannel0,uv);\n    vec3 col = data.xyz/data.w;\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// ref:https://zhuanlan.zhihu.com/p/31127076\n\n// light2d_1_basic        https://www.shadertoy.com/view/DtSczR\n// light2d_2_csg          https://www.shadertoy.com/view/mlSyzz\n// light2d_3_shape        https://www.shadertoy.com/view/ctjyzR\n// light2d_4_reflection   https://www.shadertoy.com/view/dtSyzh\n// light2d_5_refraction   https://www.shadertoy.com/view/ctjcRc\n// light2d_6_fresnel      https://www.shadertoy.com/view/Dl2czt\n// light2d_7_beer-lambert https://www.shadertoy.com/view/dl2yWG\n\n#define TWO_PI 6.28318530718f\n#define N 8\n#define MAX_STEP 64\n#define MAX_DISTANCE 5.0f\n#define EPSILON 1e-6f\n#define MAX_DEPTH 3\n#define BIAS 1e-4f\n#define SHOW_NORMAL 0\n\nfloat trace(vec2 pos,vec2 dir,int depth);\nfloat trace2(vec2 pos,vec2 dir,int depth);\nfloat trace3(vec2 pos,vec2 dir,int depth);\nfloat trace4(vec2 pos,vec2 dir,int depth);\n\nstruct Result\n{\n    float sd;\n    float emissive;\n    float reflectivity;\n    float eta;\n};\n\nfloat random (vec2 pos) \n{\n    return fract(sin(dot(pos.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\n\n// n should be a normalized vector\nvec2 Reflect(vec2 i,vec2 n)\n{\n    return i-2.0f*dot(i,n)*n;\n}\n\nint Refract(vec2 i,vec2 n,float eta,inout vec2 r)\n{\n    float idotn = dot(i,n);\n    float k = 1.0f-eta*eta*(1.0f-idotn*idotn);\n    if(k<0.0f)\n        return 0; // total internal reflection\n    float a = eta*idotn+sqrt(k);\n    r.x = eta*i.x-a*n.x;\n    r.y = eta*i.y-a*n.y;\n    return 1;\n}\n\nResult unionOp(Result a,Result b)\n{\n    if(a.sd<b.sd)\n        return a;\n    else\n        return b;\n}\n\nResult intersectOp(Result a,Result b)\n{\n    Result r;\n    float sd;\n    if(a.sd>b.sd)\n    {\n        r = b;\n        sd = a.sd;\n    }\n    else\n    {\n        r = a;\n        sd = b.sd;\n    }\n    r.sd = sd;\n    return r;\n}\n\nResult subtractOp(Result a,Result b)\n{\n    Result r = a;\n    float sd;\n    if(a.sd>-b.sd)\n        sd = a.sd;\n    else\n        sd = -b.sd;\n    r.sd = sd;\n    return r;\n}\n\nfloat CircleSDF(vec2 pos,vec2 center,float r)\n{\n    return length(pos-center)-r;\n}\n\nfloat PlaneSDF(vec2 pos,vec2 p,vec2 n)\n{\n    return dot(pos-p,n);\n}\n\nfloat SegmentSDF(vec2 pos,vec2 a,vec2 b)\n{\n    vec2 v = pos-a;\n    vec2 u = b-a;\n    float t = max(min(dot(v,u)/dot(u,u),1.0f),0.0f);\n    return length(v-u*t);\n}\n\nfloat CapsuleSDF(vec2 pos,vec2 a,vec2 b,float r)\n{\n    return SegmentSDF(pos,a,b)-r;\n}\n\nfloat BoxSDF(vec2 pos,vec2 c,float theta,vec2 s)\n{\n    float costheta = cos(theta);\n    float sintheta = sin(theta);\n    float dx = abs((pos.x-c.x)*costheta+(pos.y-c.y)*sintheta)-s.x;\n    float dy = abs((pos.y-c.y)*costheta-(pos.x-c.x)*sintheta)-s.y;\n    float ax = max(dx,0.0f);\n    float ay = max(dy,0.0f);\n    return min(max(dx,dy),0.0f)+sqrt(ax*ax+ay*ay);\n}\n\nfloat TriangleSDF(vec2 pos,vec2 a,vec2 b,vec2 c)\n{\n    float d = min(min(SegmentSDF(pos,a,b),SegmentSDF(pos,b,c)),SegmentSDF(pos,c,a));\n    float sd;\n    if((b.x-a.x)*(pos.y-a.y)>(b.y-a.y)*(pos.x-a.x) &&\n        (c.x-b.x)*(pos.y-b.y)>(c.y-b.y)*(pos.x-b.x) &&\n        (a.x-c.x)*(pos.y-c.y)>(a.y-c.y)*(pos.x-c.x))\n    {\n        sd = -d;\n    }\n    else\n        sd = d;\n    return sd;\n}\n\nResult scene(vec2 pos)\n{\n    //Result a = Result( CircleSDF(pos, vec2(-0.7f, 0.7f), 0.1f), 10.0f, 0.0f, 0.0f );\n    //Result b = Result(    BoxSDF(pos, vec2(0.0f, 0.0f), 0.0f, vec2(0.3, 0.2f)), 0.0f, 0.2f, 1.5f );\n    Result c = Result( CircleSDF(pos, vec2(0.0f, 1.0f), 0.05f), 20.0f, 0.0f, 0.0f );\n    //Result d = Result( CircleSDF(pos, vec2(0.0f, 0.3f), 0.35f), 0.0f, 0.2f, 1.5f );\n    //Result e = Result( CircleSDF(pos, vec2(0.0f, -0.3f), 0.35f), 0.0f, 0.2f, 1.5f );\n    Result f = Result(    BoxSDF(pos, vec2(0.0f, 0.0f), 0.0f, vec2(0.2, 0.1f)), 0.0f, 0.2f, 1.5f );\n    Result g = Result( CircleSDF(pos, vec2(0.0f, 0.38f), 0.35f), 0.0f, 0.2f, 1.5f );\n    Result h = Result( CircleSDF(pos, vec2(0.0f, -0.37f), 0.35f), 0.0f, 0.2f, 1.5f );\n    //Result i = Result( CircleSDF(pos, vec2(0.0f, 0.0f), 0.2f), 0.0f, 0.2f, 1.5f );\n    //Result j = Result(  PlaneSDF(pos, vec2(0.0f, 0.0f), vec2(0.0f, 1.0f)), 0.0f, 0.2f, 1.5f );\n    //return unionOp(a, b);\n    //return unionOp(c, intersectOp(d, e));\n    return unionOp(c, subtractOp(f, unionOp(g, h)));\n    //return unionOp(c, intersectOp(i, j));\n}\n\nvec2 estimateNormal(vec2 p)\n{\n    return normalize(vec2(\n        (scene(vec2(p.x+EPSILON,p.y)).sd-scene(vec2(p.x-EPSILON,p.y)).sd),\n        (scene(vec2(p.x,p.y+EPSILON)).sd-scene(vec2(p.x,p.y-EPSILON)).sd)\n    ));\n}\n\nfloat trace4(vec2 origin,vec2 dir,int depth)\n{\n    float t = 1e-3;\n    float inOrOutSign = scene(origin).sd>0.0f?1.0f:-1.0f;\n    for(int i=0;i<MAX_STEP&&t<MAX_DISTANCE;i++)\n    {\n        vec2 pos = origin+dir*t;\n        Result r = scene(pos);\n        if(r.sd*inOrOutSign<EPSILON)\n        {\n            float sum = r.emissive;\n            return sum;\n        }\n        t += r.sd*inOrOutSign;\n    }\n    return 0.0f;\n}\n\nfloat trace3(vec2 origin,vec2 dir,int depth)\n{\n    float t = 1e-3;\n    float inOrOutSign = scene(origin).sd>0.0f?1.0f:-1.0f;\n    for(int i=0;i<MAX_STEP&&t<MAX_DISTANCE;i++)\n    {\n        vec2 pos = origin+dir*t;\n        Result r = scene(pos);\n        if(r.sd*inOrOutSign<EPSILON)\n        {\n            float sum = r.emissive;\n            if (depth<MAX_DEPTH && (r.reflectivity>0.0f || r.eta>0.0f)) \n            {\n                float refl = r.reflectivity;\n                vec2 normal = estimateNormal(pos);\n                normal *= inOrOutSign;\n                if(r.eta>0.0f)\n                {\n                    vec2 refractDir;\n                    if(Refract(dir,normal,inOrOutSign<0.0f?r.eta:1.0f/r.eta,refractDir)>0)\n                    {\n                        sum += (1.0f-refl)*trace4(pos-normal*BIAS,refractDir,depth+1);\n                    }\n                    else\n                        refl = 1.0f; // total inner reflection\n                }\n                if(refl>0.0f)\n                {\n                    vec2 reflectDir = Reflect(dir,normal);\n                    sum += refl*trace4(pos+normal*BIAS,reflectDir,depth+1);\n                }\n            }\n            return sum;\n        }\n        t += r.sd*inOrOutSign;\n    }\n    return 0.0f;\n}\n\nfloat trace2(vec2 origin,vec2 dir,int depth)\n{\n    float t = 1e-3;\n    float inOrOutSign = scene(origin).sd>0.0f?1.0f:-1.0f;\n    for(int i=0;i<MAX_STEP&&t<MAX_DISTANCE;i++)\n    {\n        vec2 pos = origin+dir*t;\n        Result r = scene(pos);\n        if(r.sd*inOrOutSign<EPSILON)\n        {\n            float sum = r.emissive;\n            if (depth<MAX_DEPTH && (r.reflectivity>0.0f || r.eta>0.0f)) \n            {\n                float refl = r.reflectivity;\n                vec2 normal = estimateNormal(pos);\n                normal *= inOrOutSign;\n                if(r.eta>0.0f)\n                {\n                    vec2 refractDir;\n                    if(Refract(dir,normal,inOrOutSign<0.0f?r.eta:1.0f/r.eta,refractDir)>0)\n                    {\n                        sum += (1.0f-refl)*trace3(pos-normal*BIAS,refractDir,depth+1);\n                    }\n                    else\n                        refl = 1.0f; // total inner reflection\n                }\n                if(refl>0.0f)\n                {\n                    vec2 reflectDir = Reflect(dir,normal);\n                    sum += refl*trace3(pos+normal*BIAS,reflectDir,depth+1);\n                }\n            }\n            return sum;\n        }\n        t += r.sd*inOrOutSign;\n    }\n    return 0.0f;\n}\n\nfloat trace(vec2 origin,vec2 dir,int depth)\n{\n    float t = 1e-3;\n    float inOrOutSign = scene(origin).sd>0.0f?1.0f:-1.0f;\n    for(int i=0;i<MAX_STEP&&t<MAX_DISTANCE;i++)\n    {\n        vec2 pos = origin+dir*t;\n        Result r = scene(pos);\n        if(r.sd*inOrOutSign<EPSILON)\n        {\n            float sum = r.emissive;\n            if (depth<MAX_DEPTH && (r.reflectivity>0.0f || r.eta>0.0f)) \n            {\n                float refl = r.reflectivity;\n                vec2 normal = estimateNormal(pos);\n                normal *= inOrOutSign;\n                if(r.eta>0.0f)\n                {\n                    vec2 refractDir;\n                    if(Refract(dir,normal,inOrOutSign<0.0f?r.eta:1.0f/r.eta,refractDir)>0)\n                    {\n                        sum += (1.0f-refl)*trace2(pos-normal*BIAS,refractDir,depth+1);\n                    }\n                    else\n                        refl = 1.0f; // total inner reflection\n                }\n                if(refl>0.0f)\n                {\n                    vec2 reflectDir = Reflect(dir,normal);\n                    sum += refl*trace2(pos+normal*BIAS,reflectDir,depth+1);\n                }\n            }\n            return sum;\n        }\n        t += r.sd*inOrOutSign;\n    }\n    return 0.0f;\n}\n\n// https://stackoverflow.com/questions/33270823/how-to-cast-int-to-float-in-glsl-webgl\nfloat lightSample(vec2 pos)\n{\n    float sum = 0.0f;\n    float rand = random(pos)+iTime;\n    int n = 0;\n    if(iFrame%2 == 0)\n        n = N;\n    else\n        n = N*2;\n    float n_float = float(n);\n    for(int i=0;i<n;i++)\n    {\n        float i_float = float(i);\n        //float rand = random(pos+random(vec2(i_float,i_float)));\n        //float a = TWO_PI*rand;// uniform sampling\n        //float a = TWO_PI*i_float/n_float; // stratified sampling\n        float a = TWO_PI*(i_float+rand)/n_float; // jittered sampling\n        sum += trace(pos,vec2(cos(a),sin(a)),0);\n    }\n    return sum/n_float;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n#if SHOW_NORMAL\n    vec2 normal = estimateNormal(uv);\n    normal.y = -normal.y;\n    normal = normal*0.5+0.5;\n    vec3 col = vec3(normal.x,normal.y,0.0);\n    fragColor = vec4(col,1.0);\n#else\n    float col = lightSample(uv);\n    vec4 data = texture(iChannel0,fragCoord/iResolution.xy);\n    if(iFrame==0)\n    {\n        data=vec4(0.);\n    }\n    data += vec4(vec3(col),1.0);\n    fragColor = data;\n#endif\n}","name":"Buffer A","description":"","type":"buffer"}]}