{"ver":"0.1","info":{"id":"dltyDN","date":"1699277277","viewed":85,"name":"Protozoomer double precision","username":"Longinus","description":"Prototype of autonomous mandelbrot zoomer. Zoomer samples smaller pictures and calculates with boxcounting Minkowski-Bouligand dimension of sampled pictures and zooms in where it is highest. This uses double precision https://www.shadertoy.com/view/WsXGzj","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["mandelbrot","animation","zoomer","automatic","proto","minkowskibouliganddimension","boxcounting"],"hasliked":0,"parentid":"ctdcDN","parentname":"ProtoZoomerBW poc"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec2 cubicInterpolateDP(vec2 y0, vec2 y1, vec2 y2, vec2 y3,vec2 mu){\n\n    vec2 a0 = add(sub(sub(y3,y2),y0),y1),\n    a1 =sub(sub(y0,y1),a0),\n    a2 = sub(y2,y0),\n    a3 = y1;\n    return add(add(add(mul(a0,mul(mul(mu,mu),mu)), mul(a1,mul(mu,mu)) ),mul(a2,mu)), a3);\n}\n\n\nfloat logInterpolate(float y1,float y2,float mu){\n    return y1 * pow(2.,mu*log2(y2 / y1));\n}\n\nfloat mandel(vec2 tc,vec4 fc,vec2 fz) {\n    vec2 ratiofix = fz.x*tc*vec2(float(iResolution.x)/float(iResolution.y),1.);\n    vec4 c = vec4(add(fc.xy,set(ratiofix.x)),add(fc.zw,set(ratiofix.y)));\n    vec4 z = c;\n    for (int n = 0; n < iterations; n++) {\n        z = dcAdd(dcMul(z,z),c);\n        vec2 square = add(mul(z.xy,z.xy),mul(z.zw,z.zw));\n        if (cmp(square,set(8.0))==1.0) return (float(n) + 1. - log(log(square.x)/(logOf2*8.)) / logOf2);\n    }\n    return 0.0;\n}\n\nvec4 color(vec2 tc, vec4 fc, vec2 fz){\n    float n= mandel(tc,fc,fz);\n    return n==0.0?vec4(0, 0, 0, 1):vec4(vec3(float(n)/float(iterations)),1);\n}\n\n\nhighp vec4 colorss2(vec2 tc) {\n    int offset=(iFrame%interpolationFrames>=(interpolationFrames/2))?0:-1;\n    int numCoord = numCoords+offset;\n    vec2 offsetX0 =texelFetch(iChannel1,ivec2(numCoord-1,0),0).xy;\n    vec2 offsetX1 = texelFetch(iChannel1,ivec2(numCoord-3,0),0).xy;\n    vec2 offsetX2 = texelFetch(iChannel1,ivec2(numCoord-5,0),0).xy;\n    vec2 offsetX3 = texelFetch(iChannel1,ivec2(numCoord-7,0),0).xy;\n    vec2 offsetY0 =texelFetch(iChannel1,ivec2(numCoord-1,1),0).xy;\n    vec2 offsetY1 = texelFetch(iChannel1,ivec2(numCoord-3,1),0).xy;\n    vec2 offsetY2 = texelFetch(iChannel1,ivec2(numCoord-5,1),0).xy;\n    vec2 offsetY3 = texelFetch(iChannel1,ivec2(numCoord-7,1),0).xy;\n    vec2 zoom1 = texelFetch(iChannel1,ivec2(numCoord-3,2),0).xy;\n    vec2 zoom2 = texelFetch(iChannel1,ivec2(numCoord-5,2),0).xy;\n    vec2 dt=set(float(iFrame%(interpolationFrames))/float((interpolationFrames)));\n    vec2 offsetX = cubicInterpolateDP(offsetX0,offsetX1,offsetX2,offsetX3,dt);\n    vec2 offsetY = cubicInterpolateDP(offsetY0,offsetY1,offsetY2,offsetY3,dt);\n    vec2 zoom = set(logInterpolate(abs(zoom1.x),abs(zoom2.x),dt.x));\n    vec4 fc = vec4(offsetX,offsetY);\n\n    vec2 dxy =tc/iResolution.xy;\n    vec4 sum = color(tc,fc,zoom);\n    return sum;\n/*\n    for(int i=0; i<3; i++){\n        float angle = float(i)*2.*PI/12.;\n        sum += color(tc+dxy*vec2(sin(angle),cos(angle)),fc, zoom);\n    }\n    return sum/(6.0);\n    */\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n/*\n    int  picsize = int(iResolution.x)/(frames);\n    vec4 col = colorss2(2.*fragCoord/iResolution.xy-1.0);\n    if (fragCoord.y>iResolution.y-100.){\n        fragColor = texelFetch(iChannel2,ivec2((fragCoord.x)/30.,(iResolution.y-fragCoord.y)/30.),0);\n    }\n    else if(fragCoord.y>float(picsize+3)){\n    \n        fragColor = vec4(col);\n        \n        \n    }\n    else {\n    \n        fragColor = texelFetch(iChannel0, ivec2(fragCoord),0);\n    }\n    */\n    fragColor = colorss2(2.*fragCoord/iResolution.xy-1.);\n    \n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n//calculate small pictures\n//fractal formula:\nvec3 formulaBW(vec4 oc,vec2 os, vec2 zomg) {\n    float sum = 0.;\n    if(abs(os.x*os.x+os.y*os.y)>1.0) return vec3(0);\n    vec4 step = vec4(set(1./iResolution.x),set(1./iResolution.y));\n    for(int j=0;j<2;j++){\n        for(int k=0;k<2;k++){\n            vec4 ij = vec4(set(float(j)),set(float(k)));\n            vec4 diff = vec4(mul(mul(ij.xy,step.xy),zomg),mul(mul(ij.xy,step.xy),zomg));\n            vec4 c = dcAdd(oc,diff);\n            vec4 z = vec4(set(0.),set(0.));\n            for (int i=0;i<iterations;i++) {\n                //z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;\n                z = dcAdd(dcMul(z,z),c);\n                vec2 square = add(mul(z.xy,z.xy),mul(z.zw,z.zw));\n                if (cmp(square,set(8.0)) ==1.){ \n                    sum+=1.0;\n                    break;\n                }\n            }\n        }\n    }  \n    return sum>0.1&&sum<3.9?vec3(1):vec3(0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int  picsize = int(iResolution.x)/(frames);\n    if(fragCoord.y> float(picsize+3)){\n        discard;\n    }\n    int frame = int(fragCoord.x)/picsize;\n    float xc = ((fragCoord.x-float(frame*picsize))/float(picsize)-.5)*2.;\n    float yc = ((fragCoord.y)/float(picsize)-.5)*2.;\n    vec2 offsetX = texelFetch(iChannel0,ivec2(0,0),0).xy;\n    vec2 offsetY = texelFetch(iChannel0,ivec2(0,1),0).xy;\n    vec2 z = texelFetch(iChannel0,ivec2(0,2),0).xy;\n    vec2 zomg = cmp(z,set(0.0))>0.0?z:mul(set(-1.),z);\n    float angle = float(frame)*2.*PI/float(frames-2);\n    float frameFactor = frame==frames-1?0.:1.;\n    vec4 fxy = vec4(set(sin(angle)*frameFactor),set(cos(angle)*frameFactor));\n    vec2 uv = vec2(xc,yc);\n    vec4 oc =vec4(mul(set(uv.x),zomg.xy),mul(set(uv.y),zomg.xy));\n    vec4 offset = vec4(offsetX,offsetY);\n\n    vec4 pc = vec4(add(mul(fxy.xy,zomg.xy),offset.xy),add(mul(fxy.zw,zomg.xy),offset.zw));\n    oc = vec4(add(oc.xy,pc.xy),add(oc.zw,pc.zw));\n\n    if(int(fragCoord.y) < picsize){\n        fragColor = vec4(formulaBW(oc,uv, zomg),1.);\n        return;\n    }else if(int(fragCoord.y) == picsize){\n        fragColor = vec4(pc.xy,0.,1.);\n        return;\n    }else if(int(fragCoord.y)== picsize+1){\n        fragColor = vec4(pc.zw,0.,1.);\n        return;\n    }else if(int(fragCoord.y) ==picsize+2){\n        fragColor = vec4(z,0.,1.);\n        return;\n    }\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Calculate row sums for small pics\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int  picsize = int(iResolution.x)/(frames);\n    int frame = int(fragCoord.x)/picsize;\n    int xc = int(fragCoord.x)-frame*picsize;\n    ivec2 texCoord =ivec2(fragCoord);\n    \n    if(texCoord.y<picsize && xc<1){\n        float sum = 0.0;\n        for(int i=0; i< picsize; i++){\n            vec4 color = texelFetch(iChannel0, ivec2(texCoord)+ivec2(i,0),0);\n            sum = sum + color.r;\n        }\n        fragColor = vec4(sum,sum,sum,1.0);\n        return;\n    }\n    discard;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//calculate column sums for small pictures\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int  picsize = int(iResolution.x)/(frames);\n    int frame = int(fragCoord.x)/picsize;\n    ivec2 texCoord = ivec2(fragCoord);\n    if(texCoord.y<1 && texCoord.x<frames){\n        float sum = 0.0;\n        for(int i=0; i< picsize; i++){\n            sum += texelFetch(iChannel0, ivec2(texCoord.x*picsize,i),0).r;\n        }\n        fragColor = vec4(sum,sum,sum,1.0);\n        return;\n    }\n    discard;\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int  picsize = int(iResolution.x)/(frames);\n    int frame = int(fragCoord.x)/picsize;\n    if(fragCoord.x<float(numCoords+1)&& fragCoord.y < 5.){\n        int coord = int(fragCoord.x);\n        int coordy = int(fragCoord.y);\n        if(iFrame<1){\n            if(coordy==0){\n                fragColor = vec4(set(startX),0.,1.);\n                return;\n            }else if(coordy==1){\n                fragColor = vec4(set(startY),0.,1.);\n                return;\n            }else if(coordy==2){\n                fragColor = vec4(set(startZoom),0.,1.);\n                return;\n            }\n        }\n        \n        int frame = 0;\n        float count = 0.;\n        float maxCount = 0.;\n        for(int i=0;i<frames;  i++){\n            vec4 pixColor = texelFetch(iChannel0, ivec2(i,0),0);\n            count = pixColor.r;\n            if(count>=maxCount) frame = i;\n            maxCount=max(count,maxCount);\n        }\n        \n        \n        vec2 mzoom = texelFetch(iChannel1, ivec2(picsize*(frames-1),picsize+2),0).xy;\n        bool direction = cmp(mzoom,set(0.0)) ==1.0;\n        vec2 zoom = direction?mzoom:mul(mzoom,set(-1.));\n        \n        if(cmp(zoom,set(1.2))==1.) direction=true;\n        if(cmp(zoom,set(0.000000000000001))==-1.) direction=false;\n        zoom=direction ? mul(zoom,set(0.833)):mul(zoom,set(1.2));\n\n        vec2 m = set(0.4);//maxCount/(1.+maxCount+count);\n        vec2 m1 = sub(set(1.),m);\n        \n        vec2 x = texelFetch(iChannel1,ivec2(picsize*frame, picsize),0).xy;\n        vec2 y = texelFetch(iChannel1,ivec2(picsize*frame, picsize+1),0).xy;\n        vec2 offsetX = texelFetch(iChannel1,ivec2(picsize*(frames-1),picsize),0).xy;\n        vec2 offsetY = texelFetch(iChannel1,ivec2(picsize*(frames-1),picsize+1),0).xy;\n        x = add(mul(x,m),mul(offsetX,m1));\n        y = add(mul(y,m),mul(offsetY,m1));\n        if(iFrame%(interpolationFrames/2) == 0){\n            if(coord == 0){\n                if(coordy == 0){\n                    fragColor = vec4(x,0.0,1.);\n                    return;\n                }else if(coordy == 1){\n                    fragColor = vec4(y,0.0,1.);\n                    return;\n                }else if(coordy == 2){\n                    fragColor = vec4(direction?zoom:mul(zoom,set(-1.0)),0.,1.);\n                    return;\n                }\n                discard;\n            }else{\n                //move coords forward\n                vec4 value = texelFetch(iChannel2, ivec2(coord-1,coordy),0);\n                fragColor = value;\n                return;\n            }\n           \n        }else{\n            vec4 value = texelFetch(iChannel2, ivec2(coord,coordy),0);\n            fragColor = value;\n            return;\n        }\n    }\n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// borrowed double precision from here https://www.shadertoy.com/view/WsXGzj\n\t// Double emulation based on GLSL Mandelbrot Shader by Henry Thasler (www.thasler.org/blog)\n\t//\n\t// Emulation based on Fortran-90 double-single package. See http://crd.lbl.gov/~dhbailey/mpdist/\n\t// Substract: res = ds_add(a, b) => res = a + b\nfloat times_frc(float a, float b) {\n  return mix(0.0, a * b, b != 0.0 ? 1.0 : 0.0);\n}\n\nfloat plus_frc(float a, float b) {\n  return mix(a, a + b, b != 0.0 ? 1.0 : 0.0);\n}\n\nfloat minus_frc(float a, float b) {\n  return mix(a, a - b, b != 0.0 ? 1.0 : 0.0);\n}\n\n// Double emulation based on GLSL Mandelbrot Shader by Henry Thasler (www.thasler.org/blog)\n//\n// Emulation based on Fortran-90 double-single package. See http://crd.lbl.gov/~dhbailey/mpdist/\n// Substract: res = ds_add(a, b) => res = a + b\nvec2 add (vec2 dsa, vec2 dsb) {\n  vec2 dsc;\n  float t1, t2, e;\n\n  t1 = plus_frc(dsa.x, dsb.x);\n  e = minus_frc(t1, dsa.x);\n  t2 = plus_frc(plus_frc(plus_frc(minus_frc(dsb.x, e), minus_frc(dsa.x, minus_frc(t1, e))), dsa.y), dsb.y);\n  dsc.x = plus_frc(t1, t2);\n  dsc.y = minus_frc(t2, minus_frc(dsc.x, t1));\n  return dsc;\n}\n\n// Substract: res = ds_sub(a, b) => res = a - b\nvec2 sub (vec2 dsa, vec2 dsb) {\n  vec2 dsc;\n  float e, t1, t2;\n\n  t1 = minus_frc(dsa.x, dsb.x);\n  e = minus_frc(t1, dsa.x);\n  t2 = minus_frc(plus_frc(plus_frc(minus_frc(minus_frc(0.0, dsb.x), e), minus_frc(dsa.x, minus_frc(t1, e))), dsa.y), dsb.y);\n\n  dsc.x = plus_frc(t1, t2);\n  dsc.y = minus_frc(t2, minus_frc(dsc.x, t1));\n  return dsc;\n}\n\n// Compare: res = -1 if a < b\n//              = 0 if a == b\n//              = 1 if a > b\nfloat cmp(vec2 dsa, vec2 dsb) {\n  if (dsa.x < dsb.x) {\n    return -1.;\n  }\n  if (dsa.x > dsb.x) {\n    return 1.;\n  }\n  if (dsa.y < dsb.y) {\n    return -1.;\n  }\n  if (dsa.y > dsb.y) {\n    return 1.;\n  }\n  return 0.;\n}\n\n// Multiply: res = ds_mul(a, b) => res = a * b\nvec2 mul (vec2 dsa, vec2 dsb) {\n  vec2 dsc;\n  float c11, c21, c2, e, t1, t2;\n  float a1, a2, b1, b2, cona, conb, split = 8193.;\n\n  cona = times_frc(dsa.x, split);\n  conb = times_frc(dsb.x, split);\n  a1 = minus_frc(cona, minus_frc(cona, dsa.x));\n  b1 = minus_frc(conb, minus_frc(conb, dsb.x));\n  a2 = minus_frc(dsa.x, a1);\n  b2 = minus_frc(dsb.x, b1);\n\n  c11 = times_frc(dsa.x, dsb.x);\n  c21 = plus_frc(times_frc(a2, b2), plus_frc(times_frc(a2, b1), plus_frc(times_frc(a1, b2), minus_frc(times_frc(a1, b1), c11))));\n\n  c2 = plus_frc(times_frc(dsa.x, dsb.y), times_frc(dsa.y, dsb.x));\n\n  t1 = plus_frc(c11, c2);\n  e = minus_frc(t1, c11);\n  t2 = plus_frc(plus_frc(times_frc(dsa.y, dsb.y), plus_frc(minus_frc(c2, e), minus_frc(c11, minus_frc(t1, e)))), c21);\n\n  dsc.x = plus_frc(t1, t2);\n  dsc.y = minus_frc(t2, minus_frc(dsc.x, t1));\n\n  return dsc;\n}\n\n// create double-single number from float\nvec2 set(float a) {\n  return vec2(a, 0.0);\n}\n\nfloat rand(vec2 co) {\n  // implementation found at: lumina.sourceforge.net/Tutorials/Noise.html\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 complexMul(vec2 a, vec2 b) {\n  return vec2(a.x*b.x -  a.y*b.y,a.x*b.y + a.y * b.x);\n}\n\n// double complex multiplication\nvec4 dcMul(vec4 a, vec4 b) {\n  return vec4(sub(mul(a.xy,b.xy),mul(a.zw,b.zw)),add(mul(a.xy,b.zw),mul(a.zw,b.xy)));\n}\n\nvec4 dcAdd(vec4 a, vec4 b) {\n  return vec4(add(a.xy,b.xy),add(a.zw,b.zw));\n}\n\n// Length of double complex\nvec2 dcLength(vec4 a) {\n  return add(mul(a.xy,a.xy),mul(a.zw,a.zw));\n}\n\nvec4 dcSet(vec2 a) {\n  return vec4(a.x,0.,a.y,0.);\n}\n\nvec4 dcSet(vec2 a, vec2 ad) {\n  return vec4(a.x, ad.x,a.y,ad.y);\n}\n\n// Multiply double-complex with double\nvec4 dcMul(vec4 a, vec2 b) {\n  return vec4(mul(a.xy,b),mul(a.wz,b));\n}\n\n\tvec4 dcSub(vec4 a, vec4 b) {\n\t\treturn vec4(sub(a.xy,b.xy),sub(a.zw,b.zw));\n\t}\n\t\n\t\nconst float PI = 3.14159265358979323846264;\n\nconst float logOf2 = log(2.0);\nconst int iterations = 512; // Iterations for mandelbrot calculation\nconst int frames = 16; //This is amount of small pictures used for sampling should be dividable by picture width\nconst int numCoords = 10; // buffer size of zooming path\nconst int interpolationFrames = 20; // how many frames interpolated between path points\nconst float startX = 0.012;\nconst float startY = 0.25;\nconst float startZoom = 0.8; // sign of startZoom is also direction - is out and + is in","name":"Common","description":"","type":"common"}]}