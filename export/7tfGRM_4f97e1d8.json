{"ver":"0.1","info":{"id":"7tfGRM","date":"1621782445","viewed":226,"name":"Cellular garden","username":"elefAntti","description":"Flying around a cellullar automaton \"garden\"","likes":4,"published":1,"flags":96,"usePreview":0,"tags":["ca"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n//Just quickly hacked together \"preview image\" for the shader\n//It used to be black, because the initial buffer was empty\nvec3 getCellColor(vec2 fragCoord)\n{\n    vec2 fcBackup = fragCoord;\n    \n    //Render a walker pattern\n    fragCoord *= 20.0;\n    fragCoord.y -= 0.5;\n    fragCoord = round(fragCoord);\n    \n    if( fragCoord == vec2(0.0, -1.0)\n     || fragCoord == vec2(0.0, 0.0)\n     || fragCoord == vec2(1.0, 0.0)\n     || fragCoord == vec2(-1.0, -1.0)\n     || fragCoord == vec2(-1.0, 1.0)\n    )\n    {\n        return vec3(1.0,1.0,0.0);\n    }\n    \n    //Render a heart\n    fragCoord = round(fcBackup * 15.0);\n    \n    //Symmetry along middle\n    fragCoord.x = abs(fragCoord.x);\n    if( fragCoord == vec2(3.0, 2.0)\n     || fragCoord == vec2(3.0, 1.0)\n     || fragCoord == vec2(2.0, 3.0)\n     || fragCoord == vec2(2.0, 0.0)\n     || fragCoord == vec2(2.0, -1.0)\n     || fragCoord == vec2(1.0, 3.0)\n     || fragCoord == vec2(1.0, -2.0)\n     || fragCoord == vec2(0.0, 2.0)\n     || fragCoord == vec2(0.0, -3.0))\n    {\n        return vec3(1.0,0.0,0.0);\n    }\n    \n    return vec3(0.0);\n}\n\nfloat rnd(float x)\n{\n    //These are just some random sines to produce pseudo rnd numbers\n    //(least significant digits of this function)\n    return fract(sin(x * 1001.0 + 5.0) * 999.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iTime > 0.03)\n    {\n        // Output to screen\n        fragColor = vec4(texture(iChannel0, fragCoord/iResolution.xy).rgb, 1.0);\n    }\n    else\n    {\n        //Rendering a splash screen for the preview....\n        vec3 newColor = vec3(0.1, 0.1, 0.1);\n        \n        float colorScale = 2.0;\n        \n        //Some spatial color variation nicked from buffer B \n        float colorMix = (sin(fragCoord.x  / iResolution.x / colorScale * 30.0) \n            * sin(fragCoord.y  / iResolution.x / colorScale * 20.0) + 1.0) / 2.0;  \n        \n        vec2 normalCoords = (fragCoord - iResolution.xy * 0.5 ) / iResolution.x;\n        vec3 cellColor = getCellColor(normalCoords);\n        \n        //\"Raycast\" to the middle of the pick to produce kind of glow effect \n        vec2 dir = -0.005 * normalize(normalCoords);\n        dir *= (0.5 + 0.3 * rnd(dir.x));\n        float alpha = 1.0;\n        for(int i = 0; i < 70; ++i)\n        {\n          if(cellColor.r == 1.0)\n          {\n             break;\n          }\n          alpha *= 0.9;\n          normalCoords += dir;\n          cellColor = getCellColor(normalCoords);\n        }\n        \n        //Some color variation, copied from Buffer B (no pulsating in still image)\n        newColor += min(1.0 - cellColor.g, cellColor.r) *\n            mix(vec3(191.0, 81.0, 138.0)/ 255.0,\n            vec3(89.0, 116.0, 151.0) / 255.0,\n            abs(colorMix)\n            ) * 1.5 * alpha;\n\n        //Yellowish green bits\n        newColor += min(cellColor.g, cellColor.r) * vec3(247.0, 212.0, 69.0) / 255.0 * alpha;\n\n        fragColor = vec4(newColor, 1.0);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"MtfXzX","filepath":"https://soundcloud.com/shponglemusic/the-aquatic-garden-of-extra","previewfilepath":"https://soundcloud.com/shponglemusic/the-aquatic-garden-of-extra","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define SINELESS_HASH\n\nfloat getCell(vec2 fragCoord)\n{\n    return texture(iChannel0, fragCoord/iResolution.xy).r;\n}\n\nfloat sumNeighbors(vec2 fragCoord)\n{\n    float sum = 0.0;\n    for(int dx = -1; dx < 2; ++dx)\n    {\n        for(int dy = -1; dy < 2; ++dy)\n        {\n            if(dx != 0 || dy != 0)\n            {\n                sum += getCell(fragCoord + vec2(dx, dy));\n            }\n        }\n    }\n    return sum;\n}\n\n//The randomness pulse, slow onset, steep decline\nfloat pulse(float x, float len)\n{\n    x *= 1.1/len;\n    return smoothstep(0.0, 1.0, x) * smoothstep(1.1, 1.0, x);\n}\n\n#ifndef SINELESS_HASH\nfloat rnd(vec2 coord, float time)\n    {\n        //These are just some random sines to produce pseudo rnd numbers\n        //(least significant digits of this function)\n        return fract(sin(coord.x * 1001.0 -coord.y*7.0 + 5.0) * 999.0\n        + sin(coord.y * 607.0 + 11.0) * 513.0\n        + fract(sin(time * 711.0 + 7.0) * 1011.0));\n    }\n#else\n// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n    float hash13(vec3 p3)\n    {\n        p3  = fract(p3 * .1031);\n        p3 += dot(p3, p3.yzx + 33.33);\n        return fract((p3.x + p3.y) * p3.z);\n    }\n\n    float rnd(vec2 coord, float time)\n    {\n        return hash13(vec3(coord, time));\n    }\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //The randomness kicks down the sandcastle every 47 secs, so it lines up with the music a bit\n    float pError = pulse(mod(iTime, 47.0),5.0) * 0.02;\n    float newState = getCell(fragCoord);\n    float neighbors = sumNeighbors(fragCoord);\n    float born = 0.0;\n    float die = 0.0;\n    if(neighbors < 2.0)\n    {\n        newState = 0.0;\n    }\n    \n    if(neighbors >= 4.0)\n    {\n        newState = 0.0;\n    }\n    \n    if(neighbors == 3.0)\n    {\n        born = 1.0;\n        newState = 1.0;\n    }\n    \n    //I was experimenting with various \"fuzzified\" CA, this code was left over,\n    //but doesn't actually do anything with  a \"crisp\" CA \n    /*if(rnd(fragCoord * 5.0, iTime) >= born)\n    {\n        born = 0.0;\n    }\n    else\n    {\n        born = 1.0;\n    }*/\n    \n    \n    //newState = clamp(newState, born, 1.0-die);\n    if(rnd(fragCoord, iTime) > 1.0 - pError)\n    {\n        newState = 1.0 - newState;\n    }\n    \n    \n    vec3 newColor = vec3(newState, born, 0.0); \n    if(iFrame < 30)\n    {\n        newColor = vec3(0.0);\n    }\n    fragColor = vec4(newColor, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"llfXzX","filepath":"https://soundcloud.com/shponglemusic/the-aquatic-garden-of-extra","previewfilepath":"https://soundcloud.com/shponglemusic/the-aquatic-garden-of-extra","type":"musicstream","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"float pulse(float x, float len)\n{\n    x *= 1.1/len;\n    return smoothstep(0.0, 1.0, x) * smoothstep(1.1, 1.0, x);\n}\n\nmat2 rot(float a)\n{\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\n//Used to rotate the screen at pre specified times\nfloat twist(float t, float l)\n{\n    return smoothstep(t, t+l, iTime) * 2.0 * 3.14159;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float low_freq  = texture( iChannel2, vec2(0.05, 0.25) ).x; \n    float mid_freq  = texture( iChannel2, vec2(0.25, 0.25) ).x; \n    float hi_freq  = texture( iChannel2, vec2(0.9, 0.25) ).x; \n    \n    //At first don't react to beat as there is so much else going on\n    //Let the viewer adjust a bit\n    float beatScale = smoothstep(45.0,47.0, iTime) * 0.6;\n    float scale = (sin(iTime * 0.2) *6.0 +7.0) + low_freq * beatScale;\n    \n    //The multiplies are picked so they are not divisible by each other\n    vec2 center = vec2(sin(iTime * 0.7)*iResolution.x, sin(iTime * 0.5)*iResolution.y);\n    vec3 oldColor = texture(iChannel1, fragCoord/iResolution.xy).rgb;\n    if(iFrame < 30)\n    {\n        oldColor = vec3(0.0);\n    }\n    fragCoord -= center;\n    \n    //Special twists at special moments in the song.\n    //Placed lovingly by hand\n    float twists = twist(139.0, 10.0) \n        + twist(165.0, 20.0)*-1.0\n        + twist(208.0, 5.0)\n        + twist(252.0, 30.0)*-1.0\n        + twist(369.0, 60.0)\n        ;\n    fragCoord *= rot(twists);\n\n    //Some spatial color variation \n    float colorMix = (sin(fragCoord.x  / iResolution.x / scale * 30.0) \n        * sin(fragCoord.y  / iResolution.x / scale * 20.0) + 1.0) / 2.0;    \n    vec3 cellColor = texture(iChannel0, fragCoord/iResolution.xy/scale).rgb;\n    \n    \n    //Color remapping\n    //------------------\n    \n    //Background gradient\n    vec3 newColor = mix(vec3(138.0, 182.0, 40.0) / 255.0,\n        vec3(66.0, 121.0, 67.0)/255.0,\n        length(fragCoord/iResolution.x));\n    \n    //Partially mask out the background color for non empty cells\n    newColor *= 1.0 - max(cellColor.g, cellColor.r) * 0.5;\n    //Some color variation + pulsating color with music\n    newColor += min(1.0 - cellColor.g, cellColor.r) *\n        mix(vec3(191.0, 81.0, 138.0)/ 255.0,\n        vec3(89.0, 116.0, 151.0) / 255.0,\n        abs(colorMix - mid_freq)\n        ) * (hi_freq*5.0 +0.5);\n   \n    //Yellowish green bits (cells with three neighbors)\n    newColor += min(cellColor.g, cellColor.r) * vec3(247.0, 212.0, 69.0) / 255.0;\n    \n    //pError copypasted here like a boss\n    //just so the image is bit crisper when those waves of destruction fall\n    float pError = pulse(mod(iTime, 47.0),5.0) * 0.6;\n    \n    float blurr = max(0.8 - mid_freq, 0.1);\n    blurr = max(pError, blurr); \n    \n    //In the end, fade to black\n    float fadeBlack = 1.0 - smoothstep( 621.0, 623.0, iTime);\n    \n    newColor *= fadeBlack;\n\n    //Motion blur\n    fragColor = vec4(mix(oldColor, newColor, blurr), 1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}