{"ver":"0.1","info":{"id":"4fByDV","date":"1722969446","viewed":85,"name":"Drop 01a explained","username":"Elsio","description":"Acho que agora eu mesmo entendi o que tá acontecendo kkkk\njá fizeram alguma coisa antes mesmo de entendê-la? \n\n","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["grid","tutorial","block","shape","traversal","slength"],"hasliked":0,"parentid":"XfScDz","parentname":"Drop 01a"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// -20 @Elsio (h is a vec2)\n\nvoid mainImage(out vec4 o, vec2 u) {\n    vec2   r = iResolution.xy,\n           h = vec2(1, 14),  \n           p = 4. * vec2(u + u - r) / r.y;\n           \n    float  c = floor(p.x),\n           t = h.y * fract(sin(c * 453.2734) * 994.3434) + iTime, \n           f = fract(t);\n           \n     p.y += sin(c + t) + f;    \n     \n     p.y < 0. \n         ? h.y = 1. \n         : c;\n     \n     o = vec4(\n             // rain\n             smoothstep(c = 12. / r.y, .0,  \n                length(\n                    mod(p + (h * f - f) / 2., h) - h / 2.\n                ) - .45\n             ) * .9\n\n             // grid\n           + smoothstep(0., c,  \n                   length(\n                       max(r = abs(mod(p, 1.) - .5) - .5, 0.)\n                   ) \n                   + max(r.x, r.y)  // box\n                   + .05\n             ) * .2\n         );\n}\n\n/**/\n\n\n/*\n// @Fabrice golf 371 - 5\n \nvoid mainImage(out vec4 o, vec2 u) {\n    vec2   r = iResolution.xy, q,\n           p = 4. * vec2(u + u - r) / r.y;\n    \n    float  h = 14., w = 12. / r.y,\n           c = floor(p.x),\n           t = iTime + h* fract(sin(c * 453.2734) * 994.3434), \n           f = fract(t);\n     \n     p.y +=  sin(c + t) + f + 1.;\n     p.y < 0. ? h = 1. : h;            \n     \n     o = vec4( // rain\n               smoothstep(w, .0, \n                   (\n                       length(\n                           vec2(\n                               mod(p.y + (h * f - f) / 2., h) - h/2.,\n                               u = fract(p) - .5\n                           )\n                       )\n                       -.5\n                   ) + .05) * .9 \n                   \n               // grid\n             + smoothstep(0., w,  \n                     length( \n                         max(r = abs(u) -.5, 0.)\n                     ) \n                     + min(0., max(r.x, r.y))  + .05) * .2 \n            );\n}\n\n\n*/\n\n\n/*\n    Eternamente grato ao @Hyeve\n    que me possibilitou chegar nesse algoritmo\n\n        Crystal Ball Rainfall \n        https://www.shadertoy.com/view/NdV3Dw\n            \n                with is a fork of @tater\n                Sea of Pearls \n                https://www.shadertoy.com/view/fsV3WD\n\n\n    ...eu sei, tá irreconhecível, mas\n    o algoritmo atual é uma refatoração dele\n*/\n\n\n\n\n\n\n\n\n\n/*          ORIGINAL VERSION WITH EXPLAIN\n\n\n#define h11(a) fract(sin(a * 453.2734) * 994.3434)\n\nfloat box(vec2 p){\n    p = abs(p) - vec2(.52);\n    return length(max(p, 0.)) + min(0., max(p.x, p.y));\n}\n\nfloat rain(vec2 p){\n    float h, col, t;\n    \n    col = floor(p.x);\n    t = iTime + h11(col) * 14.;\n    h = 14.; \n    \n    // ok, that's p.x. let's define p.y\n    p.x = fract(p.x) - .5;\n          \n    // como sabem, esse código é executado para cada pixel da tela.\n    // a linha abaixo pega a coordenada y atual do pixel\n    // e soma um valor referente a onda que depende da coluna e do tempo,\n    // uma fração do tempo, que, na verdade, é o espaço do objeto,\n    // e um índice 1, que depende de onde você quer que o nível de transição fique\n    // note, no caso de grid() que esse índice não influencia nada.\n    // expreimente tirar t do seno para ver as colunas se comportando igual.\n    // expreimente variar o índice 1 para zero ou -2 e veja o que acontece.\n    p.y += sin(col + t) + fract(t) + 1.;\n    \n    // caso o cálculo da coordenada y do pixel atual esteja abaixo de zero (depois de somadas as outras coisas)\n    // significa que o objeto já caiu e agora está deslizando para o fundo.\n    // nesse caso, h = 1 faz com que a próxima linha simplesmente seja anulada.\n    // e o retorno seja simplesmente a coluna dividida pelo numero de objetos, \n    // deslocado lentamente para baixo com o tempo t. \n    \n    p.y < .0       \n        ? h = 1.   \n        : h;        \n    \n    // caso y for maior que zero significa que ainda estamos em queda.\n    // nesse caso, a próxima linha adicionará o valor da fração do bloco,\n    // proporcional a altura da queda. E essa é a parte mais difícil de entender.\n    \n    p.y += (h / 2. - .5) * fract(t);\n    \n    // vamo lá\n    // se não houvesse a queda, cada coluna seria dividida \n    // em um número de blocos de tamanho 1. certo? \n    // então imagine aí essa grade se movendo pra baixo \n    // com o tempo t (que foi somado lá nas primeiras linhas).\n    // pra facilitar eu coloquei a grade pra ser visualizada.\n    \n    // o que a linha acima faz é: para cada pixel atual eu somo \n    // a fração da altura do objeto proporcional a altura da queda.\n    // já sabemos que se o pixel estiver abaixo de um limite, \n    // essa altura será 1 e nada será somado; mas, \n    // se o pixel estiver acima do nível, a soma será de (h - 1)/2 * fract(t)\n    // esse fract(t) está nos dizendo é, em qual algura da célula o pixel atual está. \n    // multiplicando esse valor pela metade da altura da queda\n    // teremos um valor numerico único entre o ponto mais alto (altura da queda)\n    // e o ponto mais baixo (altura = 1). \n    // E esse valor pode ser usado para posicionar um único objeto (e, não uma fila de objetos) nesse espaço.\n    \n    // Esse valor agora precisa ser traduzido em \n    // um deslocamento da origem na coordenada y do espaço da coluna.\n    // lembrando que o deslocamento de origem da coordenada x já foi feito nas primeiras linhas dessa função.\n    // o que se faz com mod() ou fract().\n    p.y = mod(p.y, h) - h / 2.;\n    \n    // agora pronto!\n    // aquele pixel (atual) deslocou a coordenada da tela \n    // para que possamos desenhar alguma coisa, por ex, um disco.\n    return length(p) - .5;\n}\n\n\n// grid() foi feita exatamente como rain()\n// eliminando apenas a parte da queda\n// talvez sirva pra entender a movimentação da coluna.\nfloat grid(vec2 p) {\n    float col, t;\n    col = floor(p.x);\n    t = iTime + h11(col) * 14.;\n    p.y += sin(col + t) + fract(t);\n    p = fract(p) - .5;\n    \n    return box(p);\n}\n\n\n// exibindo grid() e rain() ao mesmo tempo\nvoid mainImage(out vec4 o, vec2 u) {\n    vec2 r = iResolution.xy; \n         u = 4. * vec2(u + u - r) / r.y;\n    \n    o = smoothstep(12./r.y,  .0, rain(u) + .05) * vec4(.9);\n    o += smoothstep( .0, 12./r.y, grid(u) + .05) * vec4(.2);\n}\n\n*/","name":"Image","description":"","type":"image"}]}