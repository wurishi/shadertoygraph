{"ver":"0.1","info":{"id":"4cBcDw","date":"1722378635","viewed":22,"name":"RAYMRACH","username":"Lost_Sky404","description":"this is just a try to see the beauty from 2D into 3D using cartesian coordinates","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","terrain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_DISTs 70.\n#define MAX_STEPS 70\n#define SURF_DIST .001\n\nconst float PI = acos(-1.0);\nconst int NUM_OCTAVES = 7;\n\nmat2 rotate(float angle){\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\nfloat noise(vec2 p){\n    return cos(p.x) + sin(p.y);\n}\nfloat fbm(vec2 p) {\n    float res = 0.0;\n    float amp = 0.5;\n    float freq = 1.95;\n    for( int i = 0; i < NUM_OCTAVES; i++) {\n        res += amp * noise(p);\n        amp *= 0.5;\n        p = p * freq * rotate(PI / 4.0) - res * 0.4;\n    }\n    return res;\n}\nfloat terrain(vec3 p){\n    float d =0.;\n    p.xz *= rotate(90.);\n   \n    d += noise(p.xy*.5);\n    d += fbm(p.xz*.7);\n\n    d += p.y+.5;\n    return clamp(0.1,1.,d);\n}\nfloat sdSphere(vec3 p, float s){\n    return length(p) -s;\n}\nfloat sdoctahedron(vec3 p ,float s){\n    p.xz *= rotate(-iTime*.6);\n    p.yz *= rotate(iTime*.8);\n    p = abs(p);\n    return(p.x + p.y + p.z -s) * 0.57735027;\n}\nfloat map(vec3 p){\n    \n    vec3 t = p;\n    //t.xz += mod(t.xz,4. )-2.;\n    float alt = 2.;\n    \n    float octa = sdoctahedron(t-vec3(0,alt,0),1.3);\n    float sr = sdSphere(t-vec3(0,alt,0 ),.8);\n    float tr = terrain(p);\n    \n    float c = max(-octa,sr);\n    return min(c/2.,tr);\n}\n\nfloat raymarch(vec3 ro , vec3 rd){\n    float dO = 0.;\n    for(int i=0; i< MAX_STEPS ; i++) {\n        vec3 p = ro + rd * dO;\n        \n        float ds = map(p);\n        dO += ds;\n        if(ds < SURF_DIST || dO > MAX_DISTs)   break;  \n    }\n    return dO;\n}\nvec3 palette (float t){\n    vec3 a = vec3(0.5569, 0.3216, 0.3216); \n    vec3 b = vec3(0.8, 0.5, 0.5); \n    vec3 c = vec3(0.5, 0.9, 0.5); \n    vec3 d = vec3(0.3922, 0.5451, 0.6863);\n\n    return a + b * cos(6.28318*(c*t+d)); \n}\nvec3 GetNormal(vec3 p){\n    float d = map(p);\n    vec2 e = vec2(.01 , 0);\n    vec3 n = d  - vec3(map(p-e.xyy),map(p-e.yxy) ,map(p-e.yyx) );\n    return normalize(n);\n}\n\nfloat GetLight (vec3 p) {\n    vec3 q = p;\n    vec3 lightPos = vec3(0,5,0);\n    //lightPos.xz += vec2(0,2 ) *2.;\n    vec3 l = normalize(lightPos - p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n , l),0.,1.);\n    float d = raymarch(p + n * SURF_DIST *2., l);\n    if(d < length(lightPos - p) ) dif *= .6;\n    //else dif = 1.;\n    //float dp = q.y+.75;\n    \n    return dif;//return min(dif,dp);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 coord = (fragCoord.xy * 2. - iResolution.xy) /iResolution.y;\n    vec3 ro = vec3(0,1 ,-3);\n    vec3 rd = normalize(vec3(coord-vec2(0.,-.3) ,.5 ));\n    vec3 col = vec3(0);\n    \n    ro.xz *= rotate(iTime*.1);//x\n    rd.xz *= rotate(iTime*.1);\n    \n    float d = raymarch(ro,rd);\n    vec3 p = ro +rd*d;\n    \n    float m = map(p);\n    float occ = GetLight(p);\n    \n    col +=palette(m);\n    col += occ*.5;\n    if (d > 20.) col = m*vec3(.2,.5,.8);\n    // i know that we colorize depending on the distance so this is the best i can do :)\n    // i saw fog effect and stuff that optmise performance in an expo way and lighting .\n    // if u know someone covering these topic let me know . tnx :3\n    // i will enahnce it ASAP\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}