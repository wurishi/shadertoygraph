{"ver":"0.1","info":{"id":"ftSXW3","date":"1628713372","viewed":122,"name":"parametric bounce + drop shadow","username":"archrona","description":"not quite right physically but it does sort of bounce","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["sdf","bounce"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define PI 3.1415926535897\n#define DD 0.001\n\nvec4 circle(vec2 p, float radius, vec3 color) {\n    return vec4(length(p) - radius, color);\n}\n\nvec4 pentagon( in vec2 p, in float r, vec3 color )\n{\n    const vec3 k = vec3(0.809016994,0.587785252,0.726542528);\n    p.x = abs(p.x);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    p -= vec2(clamp(p.x,-r*k.z,r*k.z),r);    \n    return vec4(length(p)*sign(p.y), color);\n}\n\nvec4 subtract(vec4 d1, vec4 d2) {\n    return d1.x > -d2.x ? d1 : vec4(-d2.x, d2.yzw);\n}\n\nvec4 smooth_union(float k, vec4 a, vec4 b)\n{\n    float diff = abs(a.x - b.x);\n    float h = max(k - diff, 0.0) / k;\n    if (a.x < b.x) {\n        return vec4(a.x - h*h*h*k/6.0, b.yzw * (h/2.0) + a.yzw * (1.0-h/2.0));\n    } else {\n        return vec4(b.x - h*h*h*k/6.0, b.yzw * (1.0-h/2.0) + a.yzw * (h/2.0));\n    }\n}\n\nvec4 map(vec2 p) {\n    vec4 sdf = vec4(1e5, 0, 0, 0);\n\n    for (float th = 0.0; th < 6.28; th += 2. * PI / 3.) {\n        float r = 0.5;\n        float rc =  0.5 + 0.07 * cos(3.0 * th + 3.0 * iTime);\n        sdf = smooth_union(clamp(0.5 + 1.0 * pow(sin(iTime), 3.0), 0.001, 1.0), sdf, \n            pentagon(\n                p - r * vec2(cos(th), sin(th)),\n                rc,\n                vec3(\n                    0.4 + 0.3 * pow(sin(th + 2.), 2.),\n                    0.2 + 0.2 * sin(iTime + 5.0),\n                    0.2 + 0.7 * pow(sin(iTime), 2.)\n                )\n            )\n        );\n    }\n\n    sdf = smooth_union(0.1, sdf, \n        circle(p + vec2(cos(iTime), sin(iTime)), 0.3, vec3(0.2, 0.1, 0.3)));\n\n    return sdf;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    vec2 aspectRatio = vec2(iResolution.x / iResolution.y, 1.0);\n    vec2 uv = aspectRatio * (fragCoord.xy / iResolution.xy - 0.5) * 4.0;\n    \n    float p = max(0.0, (52.0 - pow(max(0.0, mod(iTime, 10.0) + 0.0), 2.0)) / 5.778);\n    float a = floor(p);\n    float bounce = a * (1.0 - 4.0 * pow(p - a - 0.5, 2.0));\n    bounce *= 0.1;\n    bounce += 0.005;\n\n    vec4 sdf = map(uv - vec2(0.0, bounce));\n\n    vec3 color;\n\n    if (sdf.x > 0.0) {\n        vec4 shadow = map(uv);\n        color = clamp(0.1 + shadow.x / (0.1 + bounce * 1.5), 0.02 + 0.10 * bounce, 0.25) \n            * vec3(0.32, 0.35, 0.41) \n            * (3.0 / (3.0 + dot(uv,uv)))\n            * (3.0 + pow(sin(iTime + uv.x * 3.0 + sin(iTime + uv.y * 2.3 + uv.x * -2.7)), 5.0));\n    } else if (sdf.x > -0.02) {\n        color = vec3(0);  \n    } else {\n        color = sdf.yzw;\n    }\n\n    fragColor = vec4(pow(color, vec3(0.4545)), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}