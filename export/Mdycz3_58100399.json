{"ver":"0.1","info":{"id":"Mdycz3","date":"1522765257","viewed":415,"name":"Running out of time","username":"Flopine","description":"When you've planned too much things and you end up in a timeless vortex of permanent running","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","tunnel","fog"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n// Thanks to wsmind, leon, lsdlive, lamogui and XT95 for teaching me! :) <3\n\n#define ITER 100.\n\nvec2 moda (vec2 p, float per)\n{\n    float a = atan(p.y,p.x);\n    float l = length(p);\n    a = mod(a-per/2.,per)-per/2.;\n    return vec2(cos(a),sin(a))*l;\n}\n\nvec2 mo (vec2 p, vec2 d)\n{\n    p.x = abs(p.x)-d.x;\n    p.y = abs(p.y)-d.y;\n    if (p.y>p.x) p.xy = p.yx;\n    return p;\n}\n\nmat2 rot (float a)\n{\n\tfloat c = cos(a);\n    float s = sin(a);\n    return mat2(c,s,-s,c);    \n}\n\nfloat smin(float a, float b, float k) {\n\tfloat h = clamp(.5 + .5*(b - a) / k, 0., 1.);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat stmin(float a, float b, float k, float n) {\n\tfloat s = k / n;\n\tfloat u = b - k;\n\treturn min(min(a, b), .5 * (u + a + abs((mod(u - a + s, 2. * s)) - s)));\n}\n\nvec2 path(float t) \n{\n\tfloat a = sin(t*.2 + 1.5), b = sin(t*.2);\n\treturn vec2(a, a*b);\n}\n\n// iq's palette\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 2.*3.141592*(c*t+d) );\n}\n\nfloat cyl (vec2 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat od(vec3 p, float s) {\n\treturn dot((p), normalize(sign(p))) - s;\n}\n\nfloat adn (vec3 p)\n{\n    p.xz *= rot(p.y*0.5+iTime);\n    p.xz = moda(p.xz, 2.*3.141592/5.);\n\n    p.x -= 2.;\n        \n    return cyl(p.xz,.3);\n}\n\nfloat prim1 (vec3 p, float per)\n{\n    float ad = adn(p);\n    //p.y += iTime;\n    p.y = mod(p.y-per/2.,per)-per/2.;\n    return stmin(ad,od(p, 1.),0.7,4.);\n}\n\nfloat tunnel (vec3 p)\n{\n    p.yz *= rot(3.141592/2.);\n    p.xz *= rot(p.y*0.3);\n    p.xz  = moda(p.xz, 2.*3.141592/5.);\n    p.x -= 6.;\n    return prim1(p,2.5);\n}\n\nfloat map (vec3 p)\n{\n    p.xy += path(p.z);\n    return tunnel(p);\n}\n\nvec3 camera(vec3 ro, vec2 uv, vec3 ta) {\n\tvec3 fwd = normalize(ta - ro);\n\tvec3 left = cross(vec3(0, 1, 0), fwd);\n\tvec3 up = cross(fwd, left);\n\treturn normalize(fwd + uv.x*left + up*uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.*(fragCoord/iResolution.xy)-1.;\n\tuv.x *= iResolution.x/iResolution.y;\n    \n    float dt = iTime * 3.;\n\tvec3 ro = vec3(0.001, 0.5, -9. + dt);\n\tvec3 ta = vec3(0, 0, dt);\n    vec3 rd;\n    \n\tro.xy += path(ro.z);\n\tta.xy += path(ta.z);\n\trd = camera(ro, uv, ta);\n    \n    vec3 p;\n    float t;\n\tfloat shad = 0.;\n    \n    for (float i=0.;i<ITER; i++)\n    {\n        p = ro+rd*t;\n        float d = map(p);\n        if (d<(2./iResolution.y)*(1./3.)*t)\n        {\n            shad = i/ITER;\n            break;\n        }\n        t+=d*0.12;\n    }\n    \n    // Time varying pixel color\n    vec3 col = vec3(1.-shad);\n    vec3 palette = pal(uv.y*0.6,\n                      vec3(0.5),\n                      vec3(0.5),\n                      vec3(1.),\n                      vec3(0.3,0.2,0.2));\n col = mix(col,palette*0.8, 1.-exp(-0.003*t*t));\n    // Output to screen\n    fragColor = vec4(pow(col,vec3(2.2)),1.0);\n}","name":"Image","description":"","type":"image"}]}