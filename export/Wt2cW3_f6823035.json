{"ver":"0.1","info":{"id":"Wt2cW3","date":"1595547803","viewed":150,"name":"stb - Semitransparent Voxels","username":"stb","description":"Semitransparent voxels!","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["3d","transparency","voxels","out","adc","bailout","bail"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\tSemitransparent Voxels\n\t2020 stb (2015 BeyondTheStatic)\n\n\tThe renderer will stop tracing if RGBA.a < ADC. Set ADC to 0.0 to disable it. This\n\timplementation is imperfect, but still effective.\n\t\n\tThe mouse controls the camera. Play with the three consts!\n\n\tChanges:\n\t\t- fixed fog blending\n\t\t- updated volumetric fog (add this between lines 82-83):\n            else {\n                float f = clamp(map(LV-.5+7.*lPos)*1., 0., 1.);\n                vec3 vCol = f * vec3(.7, .8, 1.) * clamp(map(LV-.5+2.7*lPos)/3.+.5, 0., 1.); \n                float alph = .025;\n                RGBA.rgb += RGBA.a * alph * vCol;\n                RGBA.a *= 1.00001 - alph;\n            }\n*/\nconst float ADC\t\t= .1;\t// 0.0-1.0\nconst float alpha\t= .1;\t// 0.0-1.0\nconst float maxDist\t= 80.;\t// 0.0-?.?\n\nfloat s, c;\n#define rotate(p, a) mat2(c=cos(a), s=-sin(a), -s, c) * p\n\nfloat map(in vec3 p) {\n    float f;\n    p.x += 10.*(.5-float(mod(p.z-0., 40.)<20.)) - 5.;\n    p.xz = mod(p.xz, 20.)-10.;\n    f = length(p)-8.;\n    f = min(f, p.y+7.);\n    return f;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 res\t= iResolution.xy;\n    vec2 uv\t\t= (fragCoord-.5*res) / res.y;\n\t\n    vec3 camPos\t= vec3(.0, .0, -15.);\n    vec3 rayDir\t= normalize(vec3(uv, .5));\n    \n    vec2 nav = vec2(.8*cos(.1*iTime), -.337*iTime);\n    camPos.yz = rotate(camPos.yz, nav.x);\n    camPos.xz = rotate(camPos.xz, nav.y);\n    rayDir.yz = rotate(rayDir.yz, nav.x);\n    rayDir.xz = rotate(rayDir.xz, nav.y);\n    \n    vec3 adj, xV, yV, zV, V_;\n    vec3 po\t= sign(rayDir);\n    vec3 V\t= camPos, LV;\n    float dist;\n    \n    // light pos, background\n    vec3 lPos\t= normalize(vec3(.5, 1., .25));\n    vec3 bg\t\t= vec3(.3, .5, 1.) + pow(length(rayDir+lPos)/2.5, 2.);\n    \n    vec4 RGBA\t= vec4(vec3(0.), 1.);\n    \n    for(int i=0; i<150; i++) {\n        dist = length(V-camPos);\n        \n        LV = V;\n        \n        adj = mix(floor(V+po), ceil(V+po), .5-.5*po) - V;\n        \n        xV = adj.x * vec3(1., rayDir.yz/rayDir.x);\n        yV = adj.y * vec3(rayDir.xz/rayDir.y, 1.);\n        zV = adj.z * vec3(rayDir.xy/rayDir.z, 1.);\n\n        V_ = vec3(length(xV)<length(yV) ? xV : yV.xzy);\n    \tV_ = vec3(length(V_)<length(zV) ? V_ : zV);\n        \n        V += V_;\n        if(dist>maxDist || RGBA.a<ADC) break;\n        if(map(floor((V+LV)/2.))<0.){\n            vec3 vCol = vec3(.1, 1., .1) * clamp(map(LV-.5+2.7*lPos)/3.+.5, 0., 1.);\n            RGBA.rgb += RGBA.a * alpha * mix(vCol, bg, dist/maxDist);\n            RGBA.a *= 1.00001 - alpha;\n        }\n    }\n    \n    RGBA.rgb += bg * RGBA.a;\n    \n    fragColor = vec4(RGBA.rgb, 1.0);\n}","name":"Image","description":"","type":"image"}]}