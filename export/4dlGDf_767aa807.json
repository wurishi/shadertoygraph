{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"float hash( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\n\n// return heightmap of wall\nint wallMap(ivec2 p)\n{\n\treturn int(10.0*hash(float(p.x+100*p.y)));\n}\n\nbool notEmpty(ivec3 p)\n{\n\tivec3 walls[3];\n\twalls[0] = p.xyz; // front\n\twalls[1] = p.zxy; // roof\n\twalls[2] = p.yzx; // left\n\n\tfor (int i=0;i<3;i++) {\n\t\tp = walls[i];\n\t\tp.z = abs(p.z); // to get opposite walls too\n\t\tint samp = wallMap(p.xy);\n\t\tif (p.z >= samp+10)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\n// return location of first non-empty block\n// marching accomplished with fb39ca4's non-branching dda: https://www.shadertoy.com/view/4dX3zl\nvec3 intersect(vec3 ro, vec3 rd, out ivec3 ip, out ivec3 n)\n{\n\tivec3 mapPos = ivec3(floor(ro + 0.));\n\tvec3 deltaDist = abs(vec3(length(rd)) / rd);\n\tivec3 rayStep = ivec3(sign(rd));\n\tvec3 sideDist = (sign(rd) * (vec3(mapPos) - ro) + (sign(rd) * 0.5) + 0.5) * deltaDist; \n\t\n\tbvec3 mask;\n\tfor (int i = 0; i < 55; i++) {\n\t\tif (notEmpty(mapPos)) continue;\n\t\t\n\t\tbvec3 b1 = lessThan(sideDist.xyz, sideDist.yzx);\n\t\tbvec3 b2 = lessThanEqual(sideDist.xyz, sideDist.zxy);\n\t\tmask.x = b1.x && b2.x;\n\t\tmask.y = b1.y && b2.y;\n\t\tmask.z = b1.z && b2.z;\n\t\t\n\t\t//All components of mask are false except for the corresponding largest component\n\t\t//of sideDist, which is the axis along which the ray should be incremented.\t\t\t\n\t\tsideDist += vec3(mask) * deltaDist;\n\t\tmapPos += ivec3(mask) * rayStep;\n\t}\n\tip = mapPos;\n\tn = ivec3(mask)*ivec3(sign(-rd));\n\t\n\t// intersect the cube (copied from iq :] )\n\tvec3 mini = (vec3(mapPos)-ro + 0.5 - 0.5*sign(rd))/rd;\n\tfloat t = max ( mini.x, max ( mini.y, mini.z ) );\n\t\n\treturn ro+rd*t;\n}\n\n\nvoid cameraTransform( inout vec3 ro, inout vec3 rd )\n{\n\tfloat c = cos(iTime/10.0);\n\tfloat s = sin(iTime/10.0);\n    mat3 rot = mat3(\n\t\t  c,  0.0,   s,\n\t\t0.0,  1.0,  0.0,\n\t\t -s,  0.0,   c\n\t);\n\tro *= rot;\n\trd *= rot;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy-iResolution.xy/2.0) / iResolution.yy;\n\tuv.y = -uv.y;\n\t\n\t// perspective projection\n\tvec3 ro1 = vec3(0.01,0.01,0.01);\n\tvec3 rd1 = normalize(vec3(uv,1.0));\n\t\n\t// parallel projection\n\tvec3 ro2 = vec3(uv*10.0,0.01);\n\tvec3 rd2 = vec3(0.01,0.001,1.0);\n\t\n\tfloat a = 0.5+0.5*sin(iTime);\n\ta *= max(0.0,sin(iTime/2.0));\n\tvec3 ro = a*ro1 + (1.0-a)*ro2;\n\tvec3 rd = a*rd1 + (1.0-a)*rd2;\n\tnormalize(rd);\n\tcameraTransform(ro,rd);\n\t\n\tivec3 ip;\n\tivec3 n;\n\tvec3 pos = intersect(ro,rd, ip,n);\n\tvec3 col = vec3(hash(float(ip+10*ip.y+100*ip)));\n\t\n\tvec3 cubeP = mod(pos-0.001,1.0);\n\tvec3 edgeD = 0.5-abs(cubeP-0.5);\n\tedgeD += abs(vec3(n));\n\tfloat closest = min(edgeD.x,min(edgeD.y,edgeD.z));\n\tfloat glow = smoothstep(0.1,0.0,closest);\n\tcol.rg += glow;\n\n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4dlGDf","date":"1381409227","viewed":621,"name":"perception glitch","username":"SudoNhim","description":"I'm experimenting with scenes that transition between 2d and 3d looking using parallel projection.","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["2d","3d","cubes","dda"],"hasliked":0,"parentid":"","parentname":""}}