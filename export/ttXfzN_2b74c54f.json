{"ver":"0.1","info":{"id":"ttXfzN","date":"1596149526","viewed":208,"name":"buffer experimentation","username":"manu210404","description":"sadly, it is unperformant as hell but it was a nice coding excercise","likes":6,"published":1,"flags":48,"usePreview":0,"tags":["noise","perlin","turbulence","buffer","curling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.y);// + vec2((iResolution.y - iResolution.x) / iResolution.y / 2.0, 0));\n\n    \n    // vec2 val = texelFetch(iChannel0, ivec2(fragCoord), 0).xy/;\n    float minDist = 10.0;\n    for (int i = 0; i < DOTS; i++) {\n        vec2 p = texelFetch(iChannel0, nToIdx(i, int(iResolution.y)), 0).xy;\n        if (minDist > length(uv - p)) {\n            minDist = length(uv - p);\n        }\n    }\n    \n\n    vec4 col = vec4(vec3(distortion(uv)/3.0), 1.0);\n\n    col += vec4(smoothstep(0.003, 0.005, minDist)-0.5);\n    \n    \n    // col = vec3(texelFetch(iChannel0, ivec2(fragCoord), 0));\n\n    fragColor = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// press r to reset the points\n\nconst int RESET = 82;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    int n = idxToN(ivec2(fragCoord), int(iResolution.y));\n\n    if (bool(texelFetch(iChannel1, ivec2(RESET, 0), 0).x) || iTime <= 0.2) {\n        fragColor = vec4(hash22(uv+fract(iTime / 32.0))*vec2(iResolution.x/iResolution.y, 1.0), 0.0, 1.0);\n    } else if (n < DOTS){\n        vec2 position = texelFetch(iChannel0, ivec2(fragCoord), 0).xy;\n        vec2 c = curl(position);\n        vec2 velocity = c*STEP_SIZE;\n        position += velocity;\n#if EDGE_CASE\n        position = vec2(clamp(position.x, 0.0, iResolution.x/iResolution.y), C(position.y));\n#elif !EDGE_CASE\n        vec2 rand = hash22(uv+fract(iTime / 32.0));\n        if (position.x > iResolution.x/iResolution.y || position.x < 0.0) {\n            position.x = rand.x;\n        }\n        if (position.y > 1.0 || position.y < 0.0) {\n            position.y = rand.y;\n        }\n#endif\n        fragColor = vec4(position,0.0,1.0);\n    } else {\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    }\n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// -- tweakable parameters --\n// amount of dots\n#define DOTS 512\n// step size per frame\n#define STEP_SIZE 0.0015\n// scale of the noise function used for curling\n#define CURL_SCALE 4.0\n// offset of the noise function for variety\n#define CURL_OFFSET vec2(0, 12)\n// if 0, the points get a random position when out of the square, if 1 the position gets clamped\n#define EDGE_CASE 0\n// define the height and width of the square (1.0 and bigger)\n#define BOUNDARYSIZE 1.0\n// if 2 the mouseposition modifies the distortion if 1 it doesn't and if 0 it is the only distortion\n#define MOUSE 1\n\n// -- helper functions and definitions --\n\n#define C(a) clamp(a, 0.0, 1.0)\n\n\n// indexing of the position buffer (Buffer A)\nivec2 nToIdx(int i, int width) {return ivec2(i / width, i % width);}\nint idxToN(ivec2 i, int width) {return i.x * width + i.y;}\n\n\n// -- noise functions --\n\nfloat noise1d(float n) {\n    return fract(cos(n*89.42)*343.42);\n}\n\nfloat noise2d(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(1.0,73))) * 43758.5453);\n}\n\nvec2 hash22(vec2 co) {\n    return fract(sin(vec2(dot(co,vec2(167.1,311.7)),dot(co,vec2(269.5,183.3))))*737.5453);\n}\n\nfloat smoother(float t) {\n    t = C(t);\n    // 6t^{5}-15t^{4}+10t^{3}; polynomial used for smooth interpolation (from the same family of curves as the smoothstep function)\n    // this function has a continuous second derivative which makes it very useful for many applications\n    return 6.0*(t*t*t*t*t) - 15.0*(t*t*t*t) + 10.0*(t*t*t);\n}\n\nfloat perlin1d(float t) {\n    float i0 = floor(t);\n    float i1 = ceil(t);\n    \n    float g0 = noise1d(i0)*4.0 - 2.0;\n    float g1 = noise1d(i1)*4.0 - 2.0;\n    \n    float u = fract(t);\n    float su = smoother(u);\n    \n    float n0 = g0 * u;\n    float n1 = g1 * (u - 1.0);\n    \n    float n = (1.0 - su) * n0 + su * n1;\n    \n    return n;\n    // return (1.0 - su) * g0 + su * g1;\n}\n\nfloat perlin2d(vec2 co) {\n    float i0 = floor(co.x);\n    float j0 = floor(co.y);\n    float i1 = ceil(co.x);\n    float j1 = ceil(co.y);\n\n    vec2 g00 = normalize(hash22(vec2(i0, j0)) * 2.0 - 1.0);\n    vec2 g10 = normalize(hash22(vec2(i1, j0)) * 2.0 - 1.0);\n    vec2 g01 = normalize(hash22(vec2(i0, j1)) * 2.0 - 1.0);\n    vec2 g11 = normalize(hash22(vec2(i1, j1)) * 2.0 - 1.0);\n    \n    vec2 uv = fract(co);\n    \n    float n00 = dot(g00, vec2(uv.x, uv.y));\n    float n10 = dot(g10, vec2(uv.x - 1.0, uv.y));\n    float n01 = dot(g01, vec2(uv.x, uv.y - 1.0));\n    float n11 = dot(g11, vec2(uv.x - 1.0, uv.y - 1.0));\n    \n    float su = smoother(uv.x);\n    float sv = smoother(uv.y);\n\n    float nx0 = (1.0 - su) * n00 + n10 * su;\n    float nx1 = (1.0 - su) * n01 + n11 * su;\n    \n    float n = (1.0 - sv) * nx0 + nx1 * sv;\n\n    return n;\n}\n\n// had to define them as macros because iMouse and iResolution is not defined yet\n#define mouse_to_world(p) (iMouse.xy/iResolution.xy-(p)/vec2(iResolution.x/iResolution.y, 1.0))*vec2(iResolution.x/iResolution.y, 1.0)\n#if MOUSE == 2\n#define distortion(p) (perlin2d((p).xy * CURL_SCALE + CURL_OFFSET)*(clamp(length(mouse_to_world(p)), 0.0,0.4)*2.5-1.)*2.0)\n#elif MOUSE == 1\n#define distortion(p) (perlin2d((p).xy * CURL_SCALE + CURL_OFFSET))\n#else\n#define distortion(p) (clamp(length(mouse_to_world(p)), 0.0, 0.5)*2.-.5)\n#endif\n/*\nfloat distortion(vec2 p) {\n    return perlin2d(vec2(p.x, p.y) * CURL_SCALE + CURL_OFFSET);\n}*/\n\n#define EPS 0.0001\n#define curl(p) vec2((distortion((p) + vec2(0,EPS)) - distortion((p) - vec2(0,EPS)))/(2.0 * EPS), -(distortion((p) + vec2(EPS,0)) - distortion((p) - vec2(EPS,0)))/(2.0 * EPS))\n\n/*\nvec2 curl(vec2 p) {\n    // source: https://al-ro.github.io/projects/curl/\n    \n    float eps = 0.0001;\n    vec2 r = vec2(0);\n    \n    float n1 = distortion(vec2(p.x + eps, p.y));\n    float n2 = distortion(vec2(p.x - eps, p.y));\n    \n    r.y = (n1 - n2)/(2.0 * eps);\n\n    n1 = distortion(vec2(p.x, p.y + eps));\n    n2 = distortion(vec2(p.x, p.y - eps));\n\t\n    r.x = (n1 - n2)/(2.0 * eps);\n    return vec2(r.x, -r.y);\n}*/","name":"Common","description":"","type":"common"}]}