{"ver":"0.1","info":{"id":"WlVXz3","date":"1583262204","viewed":108,"name":"Circular Audio Visualizer","username":"BEN1JEN","description":"A circular audio visualizer test. I think there might be a bug in my noise, but I can't quite pin point it.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["visualization","circle","audio","audiovisualizer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","previewfilepath":"/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 colour = vec3(239.0/255.0, 98.0/255.0, 237.0/255.0);\n\n#define PI 3.1415926535\n\nfloat rand(vec3 pos) {\n\tpos = pos + vec3(2.35219, 1.51092, 3.01246);\n    vec2 pos2d = pos.xy*1.0231 + pos.yz*1.7423 + pos.xz*0.9854;\n\tfloat rand = fract(sin(dot(pos2d, vec2(12.9898, 78.233))) * 43758.5453123);\n\trand = rand - floor(rand);\n\treturn rand;\n}\n\nfloat noise(vec3 pos, int octaves) {\n\tfloat total = 0.0;\n\tfloat multiplier = 0.0;\n\tfor (int o = 1; o <= octaves; o++) {\n\t\tvec3 lin = pos/float(o);\n        lin -= floor(lin);\n\n        float lll = rand(vec3( floor(pos.x/float(o)),     floor(pos.y/float(o)),     floor(pos.z/float(o)) ));\n\t\tfloat llh = rand(vec3( floor(pos.x/float(o)),     floor(pos.y/float(o)),     floor(pos.z/float(o))+1.0 ));\n\t\tfloat llz = lll * (1.0 - lin.z) + llh * lin.z;\n\t\tfloat lhl = rand(vec3( floor(pos.x/float(o)),     floor(pos.y/float(o))+1.0, floor(pos.z/float(o)) ));\n\t\tfloat lhh = rand(vec3( floor(pos.x/float(o)),     floor(pos.y/float(o))+1.0, floor(pos.z/float(o))+1.0 ));\n\t\tfloat lhz = lhl * (1.0 - lin.z) + lhh * lin.z;\n\t\tfloat lyz = llz * (1.0 - lin.y) + lhz * lin.y;\n\n\t\tfloat hll = rand(vec3( floor(pos.x/float(o))+1.0, floor(pos.y/float(o)),     floor(pos.z/float(o)) ));\n\t\tfloat hlh = rand(vec3( floor(pos.x/float(o))+1.0, floor(pos.y/float(o)),     floor(pos.z/float(o))+1.0 ));\n\t\tfloat hlz = hll * (1.0 - lin.z) + hlh * lin.z;\n\t\tfloat hhl = rand(vec3( floor(pos.x/float(o))+1.0, floor(pos.y/float(o))+1.0, floor(pos.z/float(o)) ));\n\t\tfloat hhh = rand(vec3( floor(pos.x/float(o))+1.0, floor(pos.y/float(o))+1.0, floor(pos.z/float(o))+1.0 ));\n\t\tfloat hhz = hhl * (1.0 - lin.z) + hhh * lin.z;\n\t\tfloat hyz = hlz * (1.0 - lin.y) + hhz * lin.y;\n\n        float val = lyz * (1.0 - lin.x) + hyz * lin.x;\n\t\tmultiplier = multiplier + float(o);\n\t\ttotal = total + val * float(o);\n\t}\n\treturn total/multiplier;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n\n    float valueB = noise(vec3(uv*45.0, iTime*4.0), 6)*0.4+0.6;\n    float valueS = noise(vec3(uv*45.0, iTime*5.0+10.0), 6)*0.8;\n    vec3 col = colour*valueB + (1.0-colour)*valueS*valueB;\n\n    float pos = atan(uv.y/abs(uv.x))/PI + 0.5;\n    float vol = texture(iChannel0, vec2(pos, 0.0)).x*(pos*0.3+0.1)*5.0;\n\n    float dist = sqrt(uv.x*uv.x + uv.y*uv.y);\n    float shadow = dist - (vol*0.2+0.3);\n    if (dist <= 0.25) {\n    \tshadow = 0.25 - dist;\n    }\n    if (shadow < 0.0) {\n\t    fragColor = vec4(col, 1.0);\n    } else if (dist <= 0.25) {\n        shadow = 1.0-shadow;\n        shadow *= shadow;\n        shadow *= shadow;\n        shadow -= 0.2;\n        fragColor = vec4(1.0, 1.0, 1.0, 1.0)*(1.0-shadow) + vec4(col, 1.0)*shadow;\n    } else {\n        shadow = 1.0-shadow;\n        shadow *= 0.8;\n        shadow *= shadow;\n        shadow *= shadow;\n        shadow -= 0.2;\n        fragColor = vec4(1.0-shadow, 1.0-shadow, 1.0-shadow, 1.0);\n    }\n}\n","name":"Image","description":"","type":"image"}]}