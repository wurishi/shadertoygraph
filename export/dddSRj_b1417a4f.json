{"ver":"0.1","info":{"id":"dddSRj","date":"1681476765","viewed":47,"name":"P1- Ray Tracing by Telmo Beroiz","username":"Telmo","description":"Implementation of a 3D Ray Tracer.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","gamedev"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// / I used the following tutorial as inspiration: https://youtu.be/WlhvXi7pfbA?list=PLBcM5rKQcF8tFTxyEYPp99jd4QRVG5kxO&t=1447\n\nstruct Camera {\n\tvec3 position;\n\tvec3 direction;\n\n\tfloat zoom;\n\tfloat renderDistance;\n\n} camera;\n\nstruct Material {\n\tvec3 color;\n\n\tfloat diffuse;\n\tfloat ambience;\n\tfloat specular;\n\tfloat shininess;\n};\n\nstruct Sphere {\n\tvec3 position;\n\n\tfloat radius;\n\n\tMaterial material;\n\n};\n\nstruct Light {\n\tvec3 direction;\n} light;\n\nstruct Sky {\n\tvec3 color;\n\tvec3 cloudColor;\n} sky;\n\nstruct Grid {\n\tfloat width;\n\tfloat height;\n} grid;\n\nvoid initScene(vec2 uv, inout Sphere spheres[3]) {\n\tcamera.position = vec3(0., 0., 3.5);\n\tcamera.direction = vec3(0., 0., -1.);\n\tcamera.zoom = 0.1;\n\tcamera.renderDistance = 15.;\n\n\tvec3 r = vec3(0.9, 0.2, 0.1);\n\tvec3 g = vec3(0.0, 0.8, 0.2);\n\tvec3 b = vec3(0.2, 0.0, 0.7);\n\n\tlight.direction = normalize(vec3(0., -1, -0.8));\n\n\tspheres[0] = Sphere(vec3(0., 0., 0.), 0.1, Material(r, 0.2, 0.2, 0.1, 5.0));\n\tspheres[1] = Sphere(vec3(-0.2, 0., -0.9), 0.1, Material(g, 0.2, 0.2, 0.1, 5.0));\n\tspheres[2] = Sphere(vec3(0.2, 0., -0.9), 0.1, Material(b, 0.7, 0.2, 0.05, 5.0));\n\n\tvec3 topColor = vec3(0.4, 0.6, 1.0);\n\tvec3 bottomColor = vec3(0.68f, 0.93f, 1.0f);\n\tvec3 skyColor = mix(bottomColor, topColor, uv.y);\n\n\tsky.color = skyColor;\n\tsky.cloudColor = vec3(0.6, 0.7, 0.8);\n\n}\n\nbool solveQuadratic(float a, float b, float c, out float t0, out float t1) {\n\n\t// The discriminant of the, it determines the solutions the equation will have\n\tfloat disc = b * b - 4. * a * c;\n\n\tif(disc < 0.) {\n\t\treturn false;\n\t}\n\n\tif(disc == 0.) {\n\t\tt0 = t1 = -b / (2. * a);\n\t\treturn true;\n\t}\n\n\tt0 = (-b + sqrt(disc)) / (2. * a);\n\tt1 = (-b - sqrt(disc)) / (2. * a);\n\n\treturn true;\n}\n\nbool intersectsSphere(vec3 rayDirection, out vec3 surfaceNormal, Sphere sphere) {\n\n\tvec3 L = camera.position - sphere.position;\n\n\tfloat a = dot(rayDirection, rayDirection);\n\tfloat b = 2. * dot(rayDirection, L);\n\tfloat c = dot(L, L) - pow(sphere.radius, 2.);\n\n\t// The two points the ray intersects on the sphere\n\tfloat t0;\n\tfloat t1;\n\tif(solveQuadratic(a, b, c, t0, t1)) {\n\t\t// We use the point that is closer to calculate the normal(reflection)\n\t\t// Based on that if the angle is lower, the brighter the reflection will be.\n\t\tfloat t = t1 < t0 ? t1 : t0;\n\n\t\tvec3 angle = camera.position + t * rayDirection;\n\t\tsurfaceNormal = normalize(angle - sphere.position);\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nvec3 rayTrace(vec3 rayDirection, Sphere spheres[3]) {\n\tvec3 surfaceNormal;\n\tvec3 color = sky.color;\n\n\tfor(int i = 0; i < 3; ++i) {\n\t\tif(spheres[i].position.z >= camera.renderDistance) {\n\t\t\treturn sky.color;\n\t\t}\n\n\t\tif(intersectsSphere(rayDirection, surfaceNormal, spheres[i])) {\n\t\t\tfloat coeff = -dot(light.direction, surfaceNormal);\n\n\t\t\tvec3 ambient = spheres[i].material.ambience * spheres[i].material.color;\n\t\t\tvec3 diffuse = spheres[i].material.diffuse * max(coeff, 0.) * spheres[i].material.color;\n\n\t\t\tfloat shininess = pow(max(-dot(rayDirection, reflect(light.direction, surfaceNormal)), 0.), spheres[i].material.shininess);\n\t\t\tvec3 specular = spheres[i].material.specular * spheres[i].material.shininess * spheres[i].material.color;\n\n\t\t\tcolor = ambient + diffuse + specular + shininess;\n\t\t\tbreak; // exit the loop after finding the first intersecting sphere\n\t\t}\n\t}\n\n\treturn color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Normalized pixel coordinates (from -0.5 to 0.5)\n\tvec2 uv = fragCoord / iResolution.xy - 0.5;\n\n\t// Aspect Ration\n\tuv.x *= (iResolution.x / iResolution.y);\n\tSphere spheres[3];\n\tinitScene(uv, spheres);\n\t// The canvas is on 2D coordinates and we use the zoom of the camera as the third dimension.\n\tvec3 rayDirection = normalize(vec3(uv, camera.zoom) - camera.position);\n\n\tlight.direction.x = -(iMouse.x / iResolution.x - 0.5);\n\tlight.direction.y = -(iMouse.y / iResolution.y - 0.5);\n\n\tlight.direction = normalize(light.direction);\n\n    // Time varying pixel color\n\tvec3 col = rayTrace(rayDirection, spheres);\n\n    // Output to screen\n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}