{"ver":"0.1","info":{"id":"X3ByDD","date":"1727264033","viewed":90,"name":"simple cloud ocean effect","username":"ruochen","description":"a really simple cloud over the ocean effect, made with perlin noise.\nMaybe improve cloud shape with perlin-worley noise.\nAlso needs to improve the ocean reflection effect.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["cloud"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 1: show cloud noise, 0:show scene\n#define show_noise 0\n\nfloat noise_frequency = 24.0;\nfloat noise_amplitude = 1.0;\nfloat lacunarity = 2.0;\nfloat gain = 0.5;\nfloat noise_scale = 0.01;\n\n\n// From GLM (gtc/noise.hpp & detail/_noise.hpp)\nvec4 Mod289(vec4 x)\n{\n\treturn x - floor(x * vec4(1.0) / vec4(289.0)) * vec4(289.0);\n}\n\nvec4 Permute(vec4 x)\n{\n\treturn Mod289(((x * 34.0) + 1.0) * x);\n}\n\nvec4 TaylorInvSqrt(vec4 r)\n{\n\treturn vec4(1.79284291400159) - vec4(0.85373472095314) * r;\n}\n\nvec4 Fade(vec4 t)\n{\n\treturn (t * t * t) * (t * (t * vec4(6) - vec4(15)) + vec4(10));\n}\n\nfloat Remap(float origin_val, float origin_min, float origin_max, float new_min, float new_max)\n{\n    return new_min + ((origin_val - origin_min) / (origin_max - origin_min)) * (new_max - new_min);\n}\n\n\nfloat GlmPerlin4D(vec4 Position, vec4 rep)\n{\n\t\tvec4 Pi0 = mod(floor(Position), rep);\t// Integer part for indexing\n\t\tvec4 Pi1 = mod(Pi0 + vec4(1), rep);\t\t// Integer part + 1\n\t\t//Pi0 = mod(Pi0, vec4(289));\n\t\t//Pi1 = mod(Pi1, vec4(289));\n\t\tvec4 Pf0 = fract(Position);\t// Fractional part for interpolation\n\t\tvec4 Pf1 = Pf0 - vec4(1);\t\t// Fractional part - 1.0\n\t\tvec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n\t\tvec4 iy = vec4(Pi0.y, Pi0.y, Pi1.y, Pi1.y);\n\t\tvec4 iz0 = vec4(Pi0.z);\n\t\tvec4 iz1 = vec4(Pi1.z);\n\t\tvec4 iw0 = vec4(Pi0.w);\n\t\tvec4 iw1 = vec4(Pi1.w);\n\n\t\tvec4 ixy = Permute(Permute(ix) + iy);\n\t\tvec4 ixy0 = Permute(ixy + iz0);\n\t\tvec4 ixy1 = Permute(ixy + iz1);\n\t\tvec4 ixy00 = Permute(ixy0 + iw0);\n\t\tvec4 ixy01 = Permute(ixy0 + iw1);\n\t\tvec4 ixy10 = Permute(ixy1 + iw0);\n\t\tvec4 ixy11 = Permute(ixy1 + iw1);\n\n\t\tvec4 gx00 = ixy00 / vec4(7);\n\t\tvec4 gy00 = floor(gx00) / vec4(7);\n\t\tvec4 gz00 = floor(gy00) / vec4(6);\n\t\tgx00 = fract(gx00) - vec4(0.5);\n\t\tgy00 = fract(gy00) - vec4(0.5);\n\t\tgz00 = fract(gz00) - vec4(0.5);\n\t\tvec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);\n\t\tvec4 sw00 = step(gw00, vec4(0.0));\n\t\tgx00 -= sw00 * (step(vec4(0), gx00) - vec4(0.5));\n\t\tgy00 -= sw00 * (step(vec4(0), gy00) - vec4(0.5));\n\n\t\tvec4 gx01 = ixy01 / vec4(7);\n\t\tvec4 gy01 = floor(gx01) / vec4(7);\n\t\tvec4 gz01 = floor(gy01) / vec4(6);\n\t\tgx01 = fract(gx01) - vec4(0.5);\n\t\tgy01 = fract(gy01) - vec4(0.5);\n\t\tgz01 = fract(gz01) - vec4(0.5);\n\t\tvec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);\n\t\tvec4 sw01 = step(gw01, vec4(0.0));\n\t\tgx01 -= sw01 * (step(vec4(0), gx01) - vec4(0.5));\n\t\tgy01 -= sw01 * (step(vec4(0), gy01) - vec4(0.5));\n\n\t\tvec4 gx10 = ixy10 / vec4(7);\n\t\tvec4 gy10 = floor(gx10) / vec4(7);\n\t\tvec4 gz10 = floor(gy10) / vec4(6);\n\t\tgx10 = fract(gx10) - vec4(0.5);\n\t\tgy10 = fract(gy10) - vec4(0.5);\n\t\tgz10 = fract(gz10) - vec4(0.5);\n\t\tvec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);\n\t\tvec4 sw10 = step(gw10, vec4(0));\n\t\tgx10 -= sw10 * (step(vec4(0), gx10) - vec4(0.5));\n\t\tgy10 -= sw10 * (step(vec4(0), gy10) - vec4(0.5));\n\n\t\tvec4 gx11 = ixy11 / vec4(7);\n\t\tvec4 gy11 = floor(gx11) / vec4(7);\n\t\tvec4 gz11 = floor(gy11) / vec4(6);\n\t\tgx11 = fract(gx11) - vec4(0.5);\n\t\tgy11 = fract(gy11) - vec4(0.5);\n\t\tgz11 = fract(gz11) - vec4(0.5);\n\t\tvec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);\n\t\tvec4 sw11 = step(gw11, vec4(0.0));\n\t\tgx11 -= sw11 * (step(vec4(0), gx11) - vec4(0.5));\n\t\tgy11 -= sw11 * (step(vec4(0), gy11) - vec4(0.5));\n\n\t\tvec4 g0000 = vec4(gx00.x, gy00.x, gz00.x, gw00.x);\n\t\tvec4 g1000 = vec4(gx00.y, gy00.y, gz00.y, gw00.y);\n\t\tvec4 g0100 = vec4(gx00.z, gy00.z, gz00.z, gw00.z);\n\t\tvec4 g1100 = vec4(gx00.w, gy00.w, gz00.w, gw00.w);\n\t\tvec4 g0010 = vec4(gx10.x, gy10.x, gz10.x, gw10.x);\n\t\tvec4 g1010 = vec4(gx10.y, gy10.y, gz10.y, gw10.y);\n\t\tvec4 g0110 = vec4(gx10.z, gy10.z, gz10.z, gw10.z);\n\t\tvec4 g1110 = vec4(gx10.w, gy10.w, gz10.w, gw10.w);\n\t\tvec4 g0001 = vec4(gx01.x, gy01.x, gz01.x, gw01.x);\n\t\tvec4 g1001 = vec4(gx01.y, gy01.y, gz01.y, gw01.y);\n\t\tvec4 g0101 = vec4(gx01.z, gy01.z, gz01.z, gw01.z);\n\t\tvec4 g1101 = vec4(gx01.w, gy01.w, gz01.w, gw01.w);\n\t\tvec4 g0011 = vec4(gx11.x, gy11.x, gz11.x, gw11.x);\n\t\tvec4 g1011 = vec4(gx11.y, gy11.y, gz11.y, gw11.y);\n\t\tvec4 g0111 = vec4(gx11.z, gy11.z, gz11.z, gw11.z);\n\t\tvec4 g1111 = vec4(gx11.w, gy11.w, gz11.w, gw11.w);\n\n\t\tvec4 norm00 = TaylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));\n\t\tg0000 *= norm00.x;\n\t\tg0100 *= norm00.y;\n\t\tg1000 *= norm00.z;\n\t\tg1100 *= norm00.w;\n\n\t\tvec4 norm01 = TaylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));\n\t\tg0001 *= norm01.x;\n\t\tg0101 *= norm01.y;\n\t\tg1001 *= norm01.z;\n\t\tg1101 *= norm01.w;\n\n\t\tvec4 norm10 = TaylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));\n\t\tg0010 *= norm10.x;\n\t\tg0110 *= norm10.y;\n\t\tg1010 *= norm10.z;\n\t\tg1110 *= norm10.w;\n\n\t\tvec4 norm11 = TaylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));\n\t\tg0011 *= norm11.x;\n\t\tg0111 *= norm11.y;\n\t\tg1011 *= norm11.z;\n\t\tg1111 *= norm11.w;\n\n\t\tfloat n0000 = dot(g0000, Pf0);\n\t\tfloat n1000 = dot(g1000, vec4(Pf1.x, Pf0.y, Pf0.z, Pf0.w));\n\t\tfloat n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.z, Pf0.w));\n\t\tfloat n1100 = dot(g1100, vec4(Pf1.x, Pf1.y, Pf0.z, Pf0.w));\n\t\tfloat n0010 = dot(g0010, vec4(Pf0.x, Pf0.y, Pf1.z, Pf0.w));\n\t\tfloat n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));\n\t\tfloat n0110 = dot(g0110, vec4(Pf0.x, Pf1.y, Pf1.z, Pf0.w));\n\t\tfloat n1110 = dot(g1110, vec4(Pf1.x, Pf1.y, Pf1.z, Pf0.w));\n\t\tfloat n0001 = dot(g0001, vec4(Pf0.x, Pf0.y, Pf0.z, Pf1.w));\n\t\tfloat n1001 = dot(g1001, vec4(Pf1.x, Pf0.y, Pf0.z, Pf1.w));\n\t\tfloat n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));\n\t\tfloat n1101 = dot(g1101, vec4(Pf1.x, Pf1.y, Pf0.z, Pf1.w));\n\t\tfloat n0011 = dot(g0011, vec4(Pf0.x, Pf0.y, Pf1.z, Pf1.w));\n\t\tfloat n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.z, Pf1.w));\n\t\tfloat n0111 = dot(g0111, vec4(Pf0.x, Pf1.y, Pf1.z, Pf1.w));\n\t\tfloat n1111 = dot(g1111, Pf1);\n\n\t\tvec4 fade_xyzw = Fade(Pf0);\n\t\tvec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);\n\t\tvec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);\n\t\tvec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);\n\t\tvec2 n_yzw = mix(vec2(n_zw.x, n_zw.y), vec2(n_zw.z, n_zw.w), fade_xyzw.y);\n\t\tfloat n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);\n\t\treturn float(2.2) * n_xyzw;\n}\n\nfloat PerlinNoise3D(vec3 pIn, float frequency, int octaveCount, float scale, float amplitude)\n{\n\tfloat octave_frenquency_factor = 2.0;\t\t\t// noise frequency factor between octave, forced to 2\n    pIn *= scale;\n\t// Compute the sum for each octave\n\tfloat sum = 0.0f;\n\tfloat weight_sum = 0.0f;\n\tfloat weight = 0.5f;\n\tfor (int oct = 0; oct < octaveCount; oct++)\n\t{\n\t\tvec4 p = vec4(pIn.x, pIn.y, pIn.z, 0.0) * vec4(frequency);\n\t\tfloat val = GlmPerlin4D(p, vec4(frequency)) * amplitude;\n\n\t\tsum += val * weight;\n\t\tweight_sum += weight;\n\n\t\tweight *= weight;\n\t\tfrequency *= octave_frenquency_factor;\n\t}\n\n\tfloat noise = (sum / weight_sum);// *0.5 + 0.5;;\n\tnoise = min(noise, 1.0f);\n\tnoise = max(noise, 0.0f);\n\treturn noise;\n}\n\nfloat ray_height_intersection(vec3 ray_origin, vec3 ray_direction, float target_height)\n{\n    float ro_height = ray_origin.y;\n    float rd_height = ray_direction.y;\n    // parallel\n    if(abs(rd_height) < 1e-3)\n    {\n        return 1e8;\n    }\n    float dist = (target_height - ro_height) / rd_height;\n    \n    return dist;\n}\n\n// get atmosphere density, according to sea level\n// 获取大气密度\n// 传入位置离海平面的高度，以及散射的相关基准高度\n// 大气中任意一点的散射系数的计算，简化拆解为散射在海平面的散射系数，乘以基于海平面高度的该散射的大气密度计算公式\nfloat get_atmos_density(float height_to_sea_level, float scale_height)\n{\n    return exp(-height_to_sea_level / scale_height);\n}\n\nfloat create_cloud_noise(vec3 pIn, float frequency, int octaveCount, float scale, float amplitude)\n{\n\tfloat noise_result = PerlinNoise3D(pIn, frequency, octaveCount, scale*0.1, amplitude/5.0);\n    noise_result += PerlinNoise3D(pIn, frequency, octaveCount, scale*0.15, amplitude/2.75);\n    noise_result += PerlinNoise3D(pIn, frequency, octaveCount, scale*0.2, amplitude/5.5);\n\n\treturn noise_result;\n}\n\nfloat create_water_noise(vec3 pIn, float frequency, int octaveCount, float scale, float amplitude)\n{\n\tfloat noise_result = PerlinNoise3D(pIn, frequency*1.3, octaveCount, scale*0.1, amplitude/2.0);\n    noise_result += PerlinNoise3D(pIn, frequency, octaveCount, scale*0.2, amplitude/1.3);\n    noise_result += PerlinNoise3D(pIn, frequency, octaveCount, scale*0.5, amplitude/0.8);\n\n\treturn noise_result;\n}\n\nvec3 cloud_calulation(vec3 ray_dir, vec3 ray_origin, float iTime)\n{\n\tbool b_is_water = false;\n\tif(ray_dir.y < 1e-5)\n\t{\n\t\tray_dir.y *= -1.;\n\t\tb_is_water = true;\n\t}\n\t\n    float cloud_bottom = 15000.0, cloud_top = 75000.0;\n    // cloud sample\n    // ray cast to cloud layer\n    float cloud_dist0 = ray_height_intersection(ray_origin, ray_dir, cloud_bottom);\n    float cloud_dist1 = ray_height_intersection(ray_origin, ray_dir, cloud_top);\n\n    float cloud_opacity = 0.0;\n    vec3 cloud_color = vec3(5.0);\n\tfloat dist_threshold = 1e7;\n\n\t// too far\n\tif(cloud_dist0 > dist_threshold)\n\t{\n\t\treturn cloud_color;\n\t}\n\n\n\tvec3 start_pos = ray_origin + ray_dir*cloud_dist0;\n\tstart_pos.x += iTime*(1.0/10.0);\n\tint sample_steps = 32;        \n\tfloat in_cloud_ds= (cloud_dist1 - cloud_dist0) / float(sample_steps);\n\n\tfor(int i = 0; i < sample_steps; ++i)\n\t{\n\t\tvec3 cloud_pos = start_pos + ray_dir*in_cloud_ds*float(i);\n\t\t\n\t\tfloat cloud_percentage = (cloud_pos.y - cloud_bottom) / (cloud_top - cloud_bottom);\n\t\tcloud_pos *= 0.000003;\n\t\tcloud_pos.y += iTime / 50.0;\n\t\tcloud_pos.xz += vec2(iTime / 50.0);\n\t\tfloat noise_result = create_cloud_noise(cloud_pos, noise_frequency, 1, 0.95, noise_amplitude*1.2);\t\t\t\n\t\tnoise_result /= 3.;\n\t\t//float tmp_density = fbm(cloud_pos, noise_scale, noise_frequency, noise_amplitude) * cloud_percentage * ds;            \n\t\tfloat tmp_density = noise_result * in_cloud_ds * cloud_percentage ;                        \n\t\tcloud_opacity += tmp_density;\n\t}\n\n\t//cloud_color = vec3(1.5) + cloud_opacity; \n\tcloud_opacity /= (cloud_top - start_pos.y);\n\n\t// below is ocean\n\tif(b_is_water)\n\t{\n\t\t// if is water, mask with another noise for water look\n\t\tvec3 water_sample_pos = start_pos*0.00001;\n\t\twater_sample_pos.yz += iTime/10.0;\n\t\t// cloud_opacity += PerlinNoise3D(water_sample_pos, noise_frequency*1.3, 3, 1.0, 1.3);\n\t\tfloat water_reflection_noise = create_water_noise(water_sample_pos, noise_frequency, 5, 1.0, noise_amplitude*1.4);\n\t\t// water reflection noise's range is relative to the view direction, and also there should be dark area\n\t\twater_reflection_noise *= pow(dot(ray_dir, vec3(0,0,1)), 96.0) - 0.04;\n\t\t// i want ocean reflect cloud shape in a degree, so add cloud noise and water noise\n\t\tcloud_opacity = mix(cloud_opacity+water_reflection_noise, water_reflection_noise, 0.75);    \n\t}\n\t\n    cloud_opacity = 1.0 - exp(-cloud_opacity);     \n    // Calculate and return the final color.\n    vec3 sky_color = vec3(0.0, 0.2, 0.65);\n\n    return mix(sky_color, cloud_color, cloud_opacity);\n}\n\n\n/////////////////////////////////////////////////////////////////\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv*2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 fragPos = vec3(uv, 0.5);\n    \n#if show_noise==1\n    fragPos += vec3(0, iTime/10.0, iTime/10.0);\n    //fragColor = vec4(vec3(fbm(fragPos, noise_scale, noise_frequency, noise_amplitude)), 1.0);\n    float noise_result = create_cloud_noise(fragPos, noise_frequency, 5, 2.0, noise_amplitude);    \n    noise_result = 1.0 - exp(-noise_result);\n    fragColor = vec4(noise_result);\n#else\n    vec3 ro = vec3(0., 0., -2.);\n    vec3 rd = normalize(fragPos - ro);\n    \n    // camera is a little bit higher than ground\n    vec3 camPos = vec3(0.0, 0.0, 0.0);\n    \n    vec3 color = cloud_calulation(rd, camPos, iTime);\n    // Output to screen\n    // fragColor = vec4(color,1.0);\n\t// return;\n    \n    float exposure = 1.0;\n    vec3 mapped = vec3(1.0) - exp(-color * exposure);\n    // gamma correction\n    const float gamma = 2.2;\n    mapped = pow(mapped, vec3(1.0 / gamma));\n    fragColor = vec4(mapped, 1.0);\n#endif          \n}","name":"Image","description":"","type":"image"}]}