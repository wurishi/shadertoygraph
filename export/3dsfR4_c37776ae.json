{"ver":"0.1","info":{"id":"3dsfR4","date":"1639722676","viewed":89,"name":"My first raymarch","username":"lil_chickehh","description":"Use mouse to move camera","likes":4,"published":1,"flags":16,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*Thanks Jamie Wong for your awesome tutorial\nhttp://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n*/\nvec3 position=vec3(0.0,0.0,10.0);\nfloat field_of_view=80.0;//in degrees\nfloat EPSILON=0.002;\nfloat m=5.;\nvec3 rayDirection(float fOv, vec2 fragCoord, vec2 size){\n\tvec2 actual= fragCoord-(size/2.0);\n    float z=size.y/(2.0*tan(radians(fOv)/2.0));\n    return normalize(vec3(actual,z));\n}\nmat2 rotate(float a){\n    return mat2(cos(a),-sin(a),sin(a),cos(a));\n}\n//Distance Functions\nfloat sphereDEF(vec3 p, float r,vec3 sp){\n    return length(p-sp)-r;\n}\nfloat cubeDEF(vec3 p, vec3 w,vec3 disp){\n    \n\treturn length(max(abs((p-disp))-w,0.0));\n}\nfloat diamondDEF(vec3 p, float s){\n      p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nfloat sceneDEF(vec3 pos){\n\tpos=mod(pos-m,m*2.)-m;\n    //repeat space\n    \n    //rotini\n    pos.xy=rotate(1.8632*pos.z*sin(iTime))*pos.xy;\n\n    return diamondDEF(pos,2.);\n}\n\n\nmat3 from_lookat(vec3 ca,vec3 p){\n    vec3 dir=normalize(p-ca);\n    vec3 x=normalize(cross(dir,vec3(0.0,1.0,0.0)));\n    vec3 y=normalize(cross(x,dir));\n    return mat3(x,y,dir);\n}\nvec3 estimate_surface_normal(vec3 p)\n{\n    return normalize\n        (vec3(\n        sceneDEF(vec3(p.x + EPSILON, p.y, p.z)) - sceneDEF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneDEF(vec3(p.x, p.y + EPSILON, p.z)) - sceneDEF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneDEF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneDEF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    m=5.+sin(iTime);\n    vec3 ray=rayDirection(field_of_view,fragCoord,iResolution.xy);\n    vec2 rotation=iMouse.yx/iResolution.y;\n    position=vec3(7.0*sin(rotation.y*2.),7.0*cos(rotation.x*4.),7.0*cos(rotation.y*2.));\n    mat3 viewTransformation=from_lookat(position,vec3(0.0,0.0,0.0));\n    vec3 o=position;\n    float distance_from_camera=0.;\n\tfloat min_dist=100000000.0;\n    ray=viewTransformation*ray;\n    \n    bool hit_surface=false;\n    float n_steps=0.0;\n    for(int i=0;i<60;i++){\n    \tfloat d=sceneDEF(position);\n        if(d<min_dist){\n            min_dist=d;\n        }\n        if(abs(d)<0.001){\n        \thit_surface=true;\n            n_steps=float(i);\n            distance_from_camera=length(o-position);\n            break;\n        }\n        if(d>1000.0){\n            distance_from_camera=length(o-position);\n        \tbreak;\n        }\n        position=position+(normalize(ray)*d);\n    }\n    vec3 s_n=estimate_surface_normal(position);\n        float b=abs(dot(s_n,ray));\n        s_n=((inverse(viewTransformation)*s_n)+vec3(1.0))/2.0;\n    \ts_n.z=1.0-s_n.z;\n    if(hit_surface){\n        s_n=(s_n+(vec3(1.,1.0,1.)*distance_from_camera*(0.005)));\n        \n        fragColor=vec4(s_n,1.0);\n    } else {\n       \tmin_dist*=10.1;\n    fragColor = vec4(s_n.x/min_dist,s_n.y/min_dist,s_n.z/min_dist,1.0);\n        vec3 col=vec3(1.0);\n        fragColor=vec4(col,1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}