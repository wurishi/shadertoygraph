{"ver":"0.1","info":{"id":"WdKfRc","date":"1607626790","viewed":128,"name":"Cubemap CA","username":"kastorp","description":"experimenting Shane Cubemap functions with CA by Zolozulman on Iq cubemap raytracing demo","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["cubemap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// mixed code from these shaders (thanks to the authors):\n//   \"Geometric Cellular Surfaces\" by Shane https://www.shadertoy.com/view/Wt33zH\n//   \"Cubemaps\" by iq. https://shadertoy.com/view/MsXGz4\n//   \"Cyclic cellular automaton\" by Zolozulman  https://www.shadertoy.com/view/4tV3Wd\n//\n// I strictly applied Shane's instructions, especially the VFLIP trick! \n// I was surprised by high framerate, considering the fact that CA is executed on a 2048x3072 resolution\n// The cubemap faces don't interact, should write a function to detect cross-face neightbours\n// When a forked the shader another Image file was created, I don't know how to delete it \n\n\n//All raytracing code is  copied and andaped from Iq shader\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec2 map( vec3 p )\n{\n    vec2 d2 = vec2( p.y+1.0, 2.0 );\n\n    vec2 d1 = vec2( length(p ) - 1., 1.0 );\n\n    if( d2.x<d1.x) d1=d2;\n\n\tp = vec3( length(p.xz)-2.0, p.y, mod(iTime + 6.0*atan(p.z,p.x)/3.14,1.0)-0.5 );\n\t//p -= vec3( 1.5, 0.0, 0.0 );\n    vec2 d3 = vec2( 0.5*(-.2 +sdBox(p*vec3(cos(iTime)*2.,2., sin(iTime)*2.),vec3( 0.1))), 3.0 );\n    if( d3.x<d1.x) d1=d3;\n\n\t\n\treturn d1;\n}\n\n\n\n\nvec4 floorColor( in vec3 pos, in vec3 nor )\n{\n    vec3 col = texture( iChannel2, 0.5*pos.xz ).xyz;\n\t\n    // fake ao\n    float f = smoothstep( 0.1, 1.75, length(pos.xz) );\n\n\treturn vec4( col, 0.5*f+0.5*f*f );\n}\n\nconst float precis = 0.001;\nvec2 intersect( in vec3 ro, in vec3 rd )\n{\n\tfloat h=precis*2.0;\n    vec3 c;\n    float t = 0.0;\n\tfloat maxd = 9.0;\n    float sid = -1.0;\n    for( int i=0; i<100; i++ )\n    {\n        if( abs(h)<precis||t>maxd ) continue;//break;\n        t += h;\n\t    vec2 res = map( ro+rd*t );\n        h = res.x;\n\t    sid = res.y;\n    }\n\n    if( t>maxd ) sid=-1.0;\n    return vec2( t, sid );\n}\n\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3  eps = vec3(precis,0.0,0.0);\n    vec3 nor;\n    nor.x = map(pos+eps.xyy).x - map(pos-eps.xyy).x;\n    nor.y = map(pos+eps.yxy).x - map(pos-eps.yxy).x;\n    nor.z = map(pos+eps.yyx).x - map(pos-eps.yyx).x;\n    return normalize(nor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\n    // camera\n\tfloat an1 = 0.2*iTime-6.2831*mo.x;\n\tfloat an2 = clamp( 0.8 + 0.6*sin(2.2+iTime*0.11)  + 1.0*mo.y, 0.3, 1.35 );\n    vec3 ro = 2.5*normalize(vec3(sin(an2)*cos(an1), cos(an2)-0.5, sin(an2)*sin(an1)));\n    vec3 ww = normalize(vec3(0.0,0.0,0.0) - ro);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.4*ww );\n\n    // raymarch\n    vec3 col = texture( iChannel0, rd ).xxx;\n\t\n    vec2 tmat = intersect(ro,rd);\n    if( tmat.y>0.5 )\n    {\n        // geometry\n        vec3 pos = ro + tmat.x*rd;\n        vec3 nor = calcNormal(pos);\n        vec3 ref = reflect(rd,nor);\n\n\t\tfloat rim = pow(clamp(1.0+dot(nor,rd),0.0,1.0),4.0);\n\n        col = vec3(.2);\n\n        // color\n        vec4 mate = vec4(0.0);\n        if( tmat.y<1.5 )\n            mate = vec4(.6) * dot(vec3(1.,1,1),nor);\n        else if( tmat.y<2.5 )\n            mate = vec4(.2);\n        else\n            mate = vec4(.8) * dot(vec3(1.,1,1),nor);\n\t\t\n        col += 2.0*rim*pow(mate.w,3.0);\n\t\tcol *= mate.w;\n\t\tcol *= mate.xyz;\n\n\t\t// reflection occlusion\t\t\n\t\tvec2 tref = intersect(pos+nor*0.001,ref);\n\t\t\n\t\t\n\t\tfloat fre = 0.3 + 0.7*pow( clamp( 1.0 + dot( rd, nor ), 0.0, 1.0 ), 5.0 );\n\t    vec3 sss = texture( iChannel0, ref ).yyy;\n        if( tref.y>0.5 ) sss=mix(1.-sss,vec3(.0),.4);\n\t\n\t    col += 2.0*mate.w*pow(sss,vec3(4.0))*fre;\n\t\t\n\n        col = sqrt(col);\n    }\n\n    col *= 0.25 + 0.75*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.15 );\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"//The following cubemap functions are copied from Shane shader\n\n// The cubemap texture resolution.\n#define cubemapRes vec2(1024)\n\nvec4 tx(samplerCube tx, vec2 p, int id){    \n  \n    vec2 uv = fract(p) - .5;\n    // It's important to snap to the pixel centers.\n    //p = (floor(p*cubemapRes) + .5)/cubemapRes; \n    \n    vec3[6] fcP = vec3[6](vec3(-.5, uv.yx), vec3(.5, uv.y, -uv.x), vec3(uv.x, -.5, uv.y),\n                          vec3(uv.x, .5, -uv.y), vec3(-uv.x, uv.y, -.5), vec3(uv, .5));\n    \n    return texture(tx, fcP[id]);\n}\n\n\n\n// Cube mapping - Adapted from one of Fizzer's routines. \nint CubeFaceCoords(vec3 p){\n\n    // Elegant cubic space stepping trick, as seen in many voxel related examples.\n    vec3 f = abs(p); f = step(f.zxy, f)*step(f.yzx, f); \n    \n    ivec3 idF = ivec3(p.x<.0? 0 : 1, p.y<.0? 2 : 3, p.z<0.? 4 : 5);\n    \n    return f.x>.5? idF.x : f.y>.5? idF.y : idF.z; \n}\n\n\n\n/////////////////////////////////\n// CA Rules by Zolozulman\n/////////////////////////////////\nvec4 getNeibor(vec2 neibor, vec2 fragCoord, int faceID){\n    vec2 uv = (fragCoord+neibor) / iResolution.xy;\n    return tx( iChannel0, uv,faceID);\n}\n\nvec4 getDominant(vec4 n){\n     vec4 o = vec4(0,0,0,1);\n     if(n.x > n.y && n.x > n.z){\n         o=vec4(1,0,0,1);\n     }else if(n.y > n.x && n.y > n.z){\n         o=vec4(0,1,0,1);\n     }else if(n.z > n.x && n.z > n.y){\n         o=vec4(0,0,1,1);\n     }else{\n         if(n.x == n.y){\n            if(n.x > n.z){\n                o=vec4(1,0,0,1);\n            }else{\n                o=vec4(0,0,1,1);\n            }\n        }else if(n.y == n.z){\n            if(n.y > n.x){\n                o=vec4(0,1,0,1);\n            }else{\n                o=vec4(1,0,0,1);\n            }\n        }else if(n.z == n.x){\n            if(n.z > n.y){\n                o=vec4(0,0,1,1);\n            }else{\n                o=vec4(0,1,0,1);\n            }\n        }else{\n            o = vec4(0,0,0,1);\n        }\n     }\n     //o *= (n * 2.);\n     return o;\n}\n\nvec4 neiborhood(vec2 fragCoord,int faceID){\n   \n    vec4 o = vec4(0,0,0,1);\n    \n    for(int i = -1;i<2;i++){\n        for(int j = -1;j<2;j++){\n            if(i == 0 && j==0){\n                continue;\n            }\n            o+=getDominant(getNeibor(vec2(i,j),fragCoord,faceID));\n        }\n    }\n    \n   return o;\n}\n\nvec4 rule(vec2 fragCoord,int faceID){\n    vec4 n = neiborhood(fragCoord,faceID);\n    vec4 md = getDominant(getNeibor(vec2(0,0),fragCoord,faceID));\n\n    vec4 nd = md;\n    \n    if(md.x == 1.0){\n        if(n.y>2.0){\n            nd = vec4(0,1,0,1);\n        }\n    }\n    if(md.y == 1.0){\n        if(n.z>2.0){\n            nd = vec4(0,0,1,1);\n        }\n    }\n    if(md.z==1.0){\n        if(n.x>2.0){\n            nd = vec4(1,0,0,1);\n        }\n    }\n    \n    return nd;\n}\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){\n    return fract(sin(dot(p, vec2(27.609, 157.583)))*43758.5453); \n}\n\nvoid mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir){\n      \n    // Shane said, and I confirm every word! :)  \n    // \"For whatever reason (which I'd love expained), the Y coordinates flip each\n    // frame if I don't negate the coordinates here -- I'm assuming this is internal, \n    // a VFlip thing, or there's something I'm missing. If there are experts out there, \n    // any feedback would be welcome.\" \n    vec2 uv = fract(fragCoord/iResolution.y*vec2(1, -1) );\n    int faceID = CubeFaceCoords(rayDir);\n    \n    fragColor =vec4(0.);\n    \n    if(iFrame==0){       \n\n       //if((faceID&1)==0)\n      \tfragColor = vec4(hash21( uv),hash21( uv*2.1),hash21( uv*3.2),1.);\n    }\n    else {\n                \n         fragColor = vec4(0,0,0,1)+rule(uv*cubemapRes,faceID);\n                   \n    }    \n   \n    \n}\n\n","name":"Cube A","description":"","type":"cubemap"}]}