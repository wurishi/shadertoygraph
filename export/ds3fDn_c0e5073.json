{"ver":"0.1","info":{"id":"ds3fDn","date":"1697183855","viewed":26,"name":"Outrun road","username":"derangedlines","description":"Quick and dirty test to generate an old outrun-esque background, by faking 3d.\nBeware, code is full magic constants and is not cleaned/optimized.\nDrawing a car model in the center would've been a nice addition, maybe in the future... :)","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d","retro","pixel","arcade"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Better random from https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return -1.0 + 2.0 * fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//Simplex noise by iq\nfloat noise(in vec2 p)\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash22(i+0.0)), dot(b,hash22(i+o)), dot(c,hash22(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\nfloat integral = 0.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float speed = 20.0;\n    float roadWidth = 2.0;\n    float laneWidth = 0.4;\n    float stripeWidth = 0.1;\n    float landscapeSize = 0.3;\n    float skySize = 0.3;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    float scale = 4.0;\n    vec2 uv = floor(fragCoord/scale)*scale/iResolution.xy;\n    \n    float time = 0.01*floor(speed*iTime);\n\n    // Background\n    // Sky\n    vec3 col = vec3(0.2+0.6*pow(2.0-2.0*uv.y,3.0), 0.8*pow(2.0-2.0*uv.y,3.0), 1.0);\n    // Clouds\n    col += 0.6*vec3(max((2.0-2.0*uv.y)*noise(vec2((0.3*noise(vec2(time-0.2))+uv.x),uv.y*2.0)/skySize),0.2));\n    // Mountains + Grass\n    if(uv.y < max(0.5, 0.51 + 0.05 * noise(vec2((0.5*noise(vec2(time-0.2))+uv.x)/landscapeSize))))\n        col = vec3(0.6, 0.8, 0.4) + 0.1*float(fract(pow(0.5-uv.y,0.1)*20.0+40.0*time)>=0.5);\n\n    // Road\n    float center = 0.5 + pow(1.5*uv.y,4.0)*noise(vec2(time)); //default center + curvature\n    if(abs(center-uv.x)<roadWidth*(0.5-uv.y))\n    {\n        // Light\n        col = vec3(0.5);\n        // Dark\n        if(fract(pow(0.5-uv.y,0.1)*20.0-40.0*time)>=0.5)\n            //stripes\n            col = 0.4 + vec3(0.5*stripeWidth*(0.5-uv.y)-mod(abs((0.25*roadWidth/(stripeWidth+laneWidth))*(center-uv.x)),0.5-uv.y)>0.00);\n    }\n    \n    // Dithering with Bayer\n    float bayer = texture(iChannel0, uv*scale*iChannelResolution[0].xy).r-0.5;\n    col += bayer * 0.4;\n    // Quantizing palette\n    float q = 4.0;\n    col = floor(col*(q-1.0)+0.5)/(q-1.0);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}