{"ver":"0.1","info":{"id":"mtGczd","date":"1701525061","viewed":78,"name":"ch3ck3r3","username":"gamsas","description":"My first shader at creating an IG AR filter [ch3ck3r]\nhttps://www.instagram.com/ar/709155497587738\n\nThe code's a bit messy :X  I'll tidy it up gradually :D","likes":1,"published":1,"flags":2,"usePreview":0,"tags":["texture","checkerboard"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// [ch3ck3r] \n// https://www.instagram.com/ar/709155497587738\n\n// PUBLIC DOMAIN CRT STYLED SCAN-LINE SHADER by Timothy Lottes\n// https://www.shadertoy.com/view/XsjSzR\n\n#define PI 3.1415926535897932384626433832795\n\n//short special case of smoothstep(), turn gratient to sharpened border.\nfloat ssf(float a,float d){return smoothstep(-a,a,d);}\n\n  //triangle-function.\n  //x includes phase and x*n has n adjust \"range\" \nfloat waveTri(float x,float d){d*=2.;\n  return min(mod(x,d),mod(-x,d));\n} //return abs((x)/w);//waveSaw saw-function\n\nconst float hardScan=-8.0;\nconst float hardPix=-2.;\n\n// Display warp.\nconst vec2 warp=vec2(1.0/32.0,1.0/24.0); \n\n// Amount of shadow mask.\nconst float maskDark=0.4;\n\n\n// Nearest emulated sample given floating point position and texel offset.\n// Also zero's off screen.\nvec3 Fetch(vec2 pos,vec2 off, float psize){\n    vec2 res = iResolution.xy/psize;\n    pos=floor(pos*res+off)/res;\n    if(max(abs(pos.x-0.5),abs(pos.y-0.5))>0.5)return vec3(0.0,0.0,0.0);\n    return texture(iChannel0,pos.xy).rgb;}\n\n\n// Distance in emulated pixels to nearest texel.\nvec2 Dist(vec2 pos, float gap){\n  pos=pos*(iResolution.xy/gap);\n  return -((pos-floor(pos))-vec2(0.5));}\n    \n// 1D Gaussian.\nfloat Gaus(float pos,float scale){return exp2(scale*pos*pos);}\n\n// 3-tap Gaussian filter along horz line.\nvec3 Horz3(vec2 pos,float off,float gap, float psize){\n  vec3 b=Fetch(pos,vec2(-1.0,off),psize);\n  vec3 c=Fetch(pos,vec2( 0.0,off),psize);\n  vec3 d=Fetch(pos,vec2( 1.0,off),psize);\n  float dst=Dist(pos,gap).x;\n  // Convert distance to weight.\n  float scale=hardPix;\n  float wb=Gaus(dst-1.0,scale);\n  float wc=Gaus(dst+0.0,scale);\n  float wd=Gaus(dst+1.0,scale);\n  // Return filtered sample.\n  return (b*wb+c*wc+d*wd)/(wb+wc+wd);}\n\n// 5-tap Gaussian filter along horz line.\nvec3 Horz5(vec2 pos,float off, float gap, float psize){\n  vec3 a=Fetch(pos,vec2(-2.0,off),psize);\n  vec3 b=Fetch(pos,vec2(-1.0,off),psize);\n  vec3 c=Fetch(pos,vec2( 0.0,off),psize);\n  vec3 d=Fetch(pos,vec2( 1.0,off),psize);\n  vec3 e=Fetch(pos,vec2( 2.0,off),psize);\n  float dst=Dist(pos,gap).x;\n  // Convert distance to weight.\n  float scale=hardPix;\n  float wa=Gaus(dst-2.0,scale);\n  float wb=Gaus(dst-1.0,scale);\n  float wc=Gaus(dst+0.0,scale);\n  float wd=Gaus(dst+1.0,scale);\n  float we=Gaus(dst+2.0,scale);\n  // Return filtered sample.\n  return (a*wa+b*wb+c*wc+d*wd+e*we)/(wa+wb+wc+wd+we);}\n\n// Return scanline weight.\nfloat Scan(vec2 pos,float off, float gap){\n  float dst=Dist(pos,gap).y;\n  return Gaus(dst+off,hardScan);}\n\n// Allow nearest three lines to effect pixel.\nvec3 Tri(vec2 pos, float gap , float psize){\n  vec3 a=Horz3(pos,-1.0,gap, psize);\n  vec3 b=Horz5(pos, 0.0,gap,psize);\n  vec3 c=Horz3(pos, 1.0,gap,psize);\n  float wa=Scan(pos,-1.0, gap);\n  float wb=Scan(pos, 0.0, gap);\n  float wc=Scan(pos, 1.0, gap);\n  return a*wa+b*wb+c*wc;}\n\n// Distortion of scanlines, and end of screen alpha.\nvec2 Warp(vec2 pos){\n  pos=pos*2.0-1.0;    \n  pos*=vec2(1.0+(pos.y*pos.y)*warp.x,1.0+(pos.x*pos.x)*warp.y);\n  return pos*0.5+0.5;}\n\n// Shadow mask.\nvec3 Mask(vec2 pos, float maskLight){\n  \n  pos.x+=pos.y*3.0;\n  vec3 mask=vec3(maskDark,maskDark,maskDark);\n  pos.x=fract(pos.x/6.0);\n  if(pos.x<0.333)mask.r=maskDark;\n  else if(pos.x<0.666)mask.g=maskLight;\n  else mask.b=maskLight;\n  return mask;}    \n\n// Draw dividing bars.\nfloat Bar(float pos,float bar){pos-=bar;return pos*pos<4.0?0.0:1.0;}\n\nvec3 pixelize(vec2 p, float light, in vec2 fragCoord,float gap, float psize){\n    float maskLight =light;\n    float maskDark=light;\n    vec2 pos = p;\n    return Tri(pos,gap, psize) * Mask(fragCoord.xy, maskLight); \n}\n\nfloat squareEdgeSoftness(vec2 st, float size) {\n  vec2 square = abs(fract(st - 0.5) - 0.5) / fwidth(st) * size;\n  return clamp(min(square.x, square.y), 0.0, 1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n\n    // speed\n    float S = 0.12;\n    float ds[9];\n  \n    // wavy effect\n    uv.x += sin(uv.y*1.+iTime*S*PI*3.)*0.5;\n    \n    // x-axis movement\n    uv.x += cos(iTime*S*PI*1.)*1.5*0.5;\n  \n    float dist = 0.58;\n\n    // move the layers\n    for (int i = 0; i < ds.length(); i++) {\n        ds[i] = (dist - mod(iTime * S, dist)) + float(i) * dist;\n    }\n\n    // Modify displacement for x-axis for each layer\n    float dx = sin(iTime)*0.1;\n    float dy = -S*8.;\n\n    \n    for (int i = 0; i < ds.length(); i++) {\n\n        float d = ds[i];\n        float size = d*6.;\n        // float modd = mod(float(i),3.);\n\n        float x0 = uv.x;\n        float y0 = uv.y;\n\n        // Modify displacement for x-axis for each layer\n        x0 += d * dx;\n        y0 += d * dy;\n\n        // change freq for layer\n        float x1 = x0 * d;\n        float y1 = y0 * d;\n   \n        // center vertical\n        y1 += PI / 1.0;\n        \n        int xon = cos(x1*size) > 0.0 ? 1 : 0;\n        int yon = sin(y1*size) > 0.0 ? 1 : 0;\n        int c = (xon != yon) ? 1 : 0;\n        if (size < 2.) {c = 1;}\n          \n        // float test =float(xon)*floor(x1);\n\n        if (c != 1) {\n            float c1 = 1.0 - (d / (float(ds.length())));\n            // c1 +=0.1;\n            c1 = pow(c1+0.15, 4.);\n\n            vec2 ch_uv = fract(vec2(x1 *size* (1./PI) - 0.5, y1 *size* (1./PI)));\n            float smoothedge = squareEdgeSoftness(ch_uv, 0.3);\n            \n            ch_uv = Warp(ch_uv);\n            \n            float gap = size*4.;\n            vec3 img = pixelize(ch_uv, pow(d,1.8)-d+0.5, fragCoord,gap,1.);                      \n\n            vec3 r;\n            float blur = 6.;\n            blur/=16.;//lessen blur\n    \n            float shape = -(length(ch_uv-0.5)-0.5);     \n           \n            //tricolor:                                    \n            float rr=ssf(blur,shape*1.20);\n            float rg=ssf(blur,shape*1.20);\n            float rb=ssf(blur,shape*fract(ch_uv.y+iTime*8.)*(fract(iTime*2.)*0.5+1.));\n            r.rgb=vec3(rr,rg,rb);\n\n            fragColor = vec4(img*r*c1*(vec3(2.5,2.5,3.2)-d*d*size*0.03),smoothedge);\n            break;\n        }\n      }\n}\n","name":"Image","description":"","type":"image"}]}