{"ver":"0.1","info":{"id":"fd2yRw","date":"1643251139","viewed":274,"name":"Fractal Trip","username":"namanonamako","description":"raymarch","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define resolution iResolution \n#define time iTime \n\nfloat speed;\n\nvec3 spherePos1;\nvec3 spherePos2;\n\n\nvec3 lightCol1 = vec3(0.8, 0.5, 0.2);\nvec3 lightCol2 = vec3(0.2, 0.2, 0.8);\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 cam(float t){\n\treturn vec3(sin(t * .3) * 1. , cos(t * .5 + 1.5), t); \n}\n\nfloat sdCross(vec3 p, float c){\n\tp = abs(p);\n\tvec3 d = max(p.xyz, p.yzx);\n\treturn min(min(d.x, d.y), d.z) - c;\n}\n\nfloat sdSphere(vec3 p, float r){\n\treturn length(p) - r;\n}\n\nfloat sdMenger(vec3 p, float size, float width){\n\tfloat s = 1.;\n\tfloat d = 0.;\n\tfor(int i = 0; i < 4; i++){\n\t\tvec3 q = mod(p * s, 2.) - 1.;\n\t\ts *= size;\n\t\tq = 1. - size * abs(q);\n\t\tfloat c = sdCross(q, width) / s;\n\t\td = max(d, c);\n\t}\n\treturn d;\n}\n\nfloat map(vec3 p){\n\tfloat d1 = sdMenger(p, 3.8, .7);\n\t\n\tfloat d2 = length(p.xy - cam(p.z).xy) - .2;\n\t\n\treturn max(d1, -d2);\n}\n\nvec4 spheres(vec3 p){\n\tspherePos1 = cam(time + 1.) + vec3(cos(time * 1.3) * .6, sin(time) * .6, exp(sin(time)) * .5);\n\t//spherePos2 = cam(time + sin(time) * .3 + 1.) + vec3(cos(time * .6 + 1.6) * .5, sin(time *  1.2 + .6) * .5, exp(sin(time + 1.6)) * .5);\n\tfloat d3 = sdSphere(p - spherePos1, .0);\n\t//float d4 = sdSphere(p - spherePos2, .0);\n\t//lightCol1 = pal( time * .01, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );\n\tvec3 col = 3. * (exp(-d3 * 3.) * lightCol1);// + exp(-d4 * 3.) * lightCol2);\n\t\n\treturn vec4(col, d3);// min(d3,d4));\t\n}\n\nvec3 genNormal(vec3 p){\n\tvec2 d = vec2(0.001, 0.);\n\treturn normalize(vec3(\n\t\tmap(p + d.xyy) - map(p - d.xyy),\n\t\tmap(p + d.yxy) - map(p - d.yxy),\n\t\tmap(p + d.yyx) - map(p - d.yyx)\n\t\t));\n}\n\t\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n\tvec2 p = ( gl_FragCoord.xy * 2. - resolution.xy ) / min(resolution.x, resolution.y);\n\n\tvec3 color = vec3(0.0);\n\t//color.xy = p;\n\t\n\tspeed = time;\n\t\n\tvec3 cPos = vec3(0., 0., -4. + speed);\n\tcPos = cam(time);\n\tvec3 t = vec3(0., 0., 0. + speed);\n\tt = cam(time + .5);\n\tvec3 fwd = normalize(t - cPos);\n\tvec3 side = normalize(cross(vec3(sin(time*.6) * .6, 1., cos(time * .3 + 1.6) * .4), fwd));\n\tvec3 up = normalize(cross(fwd, side));\n\tvec3 rd = normalize(p.x * side + p.y * up + fwd * (1. + .3 * (1. - dot(p,p))));\n\t\n\tfloat d, dd;\n\tvec3 ac;\n\tint k;\n\t\n\tfor(int i = 0; i < 100; i++){\n\t\tvec4 s = spheres(cPos + d * rd);\n\t\tdd = map(cPos + d * rd);\n\t\tif(dd < 0.001){\n\t\t\t//color += 1.;\n\t\t\tbreak;\n\t\t}\n\t\tac += s.xyz;\n\t\tdd = min(dd, s.w);\n\t\tk = i;\n\t\td += dd;\n\t}\n\t\n\tvec3 ip = cPos + d * rd;\n\t\n\t\n\tif(dd < 0.001){\n\t\tvec3 normal = genNormal(ip);\n\t\t\n\t\tfloat ao = 1. - (float(k) + dd / 0.001) / 100.;\n\t\t\n\t\tfloat diff1 = clamp(dot(normalize(spherePos1 - ip), normal), 0., 1.) / pow(length(spherePos1 - ip), 3.);\n\t\t//float diff2 = clamp(dot(normalize(spherePos2 - ip), normal), 0., 1.) / pow(length(spherePos2 - ip), 3.);\n\n\t\tcolor += diff1 * lightCol1;\n\t\t//color += diff2 * lightCol2;\n\t\t\n\t\tcolor *= ao;\n\t}\n\t\n\tcolor += ac * .03;\n\t\n\tp = gl_FragCoord.xy / resolution.xy;\n\tcolor = sqrt(color);\n\tcolor *= pow(p.x * p.y * (1. - p.x) * (1. - p.y) * 16., .5);\n\t\n\t\n\n\tfragColor = vec4(color, 1.0 );\n\n}","name":"Image","description":"","type":"image"}]}