{"ver":"0.1","info":{"id":"lc2czd","date":"1722877978","viewed":32,"name":"Formas 4.3","username":"jpupper","description":"\n//4.3\n//Formas\n//Circulo inicial, Funcion step.\n","likes":0,"published":3,"flags":0,"usePreview":0,"tags":["mix","tutorial","sin","color","cos","shaders","shaders","livecoding","functions","taller","tutoriales","osciladores"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define resolution iResolution\n#define time iTime\n//4.3\n//Formas\n//Circulo inicial, Funcion step.\n\n//Taller de Livecoding con visuales en GLSL 4.0 \n\n \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = gl_FragCoord.xy / resolution.xy; // De esta manera obtenemos las coordenadas cartesianas\n    \n    //ESTO ES PARA ARREGLAR EL ASPECT RADIO. \n    //Es decir para que no importa la resolución que tenga, el circulo siempre sea un circulo perfecto.\n    float fix = resolution.x/resolution.y; //Creo la variable que me permite arreglar esto.\n    uv.x*=fix;\n    \n    \n    //EN EL P también lo tengo que multiplicar por el fix.\n    vec2 p = vec2(0.5*fix,0.5) - uv; //Genero un punto en el espacio(en este caso en el medio.\n    float r = length(p);  //Obtengo el radio\n    float a = atan(p.x,p.y);//obtengo el angulo. \n    \n    \n    \n    //LA FUNCIÓN STEP FUNCIONA COMO SI FUERA UN UMBRAL. \n    //TODOS LOS VALORES DEBAJO DE 0.9 LOS TRANSFORMA EN 0. \n    //TODOS LOS VALORES ARRIBA DE 0.9 LOS TRANSFORMA EN 1.\n    \n    //LO MISMO SI LO HAGO CON uv.x , uv.y , a , o cualquier valor que yo le pase. \n    float e = step(0.9,1.-r); //aca uso 1.-r para que me de el valor invertido, entonces negro pasa a blanco y blanco a negro.\n          //e = step(0.9,uv.y);\n          //e = step(0.9,uv.x); //Este se ve mitad negro mitad blanco porque cuando utilizamos fix pasan estas cosas.\n          //e = step(0.9,a);\n    \n       \n    fragColor = vec4(vec3(e),1.0); \n\n}","name":"Image","description":"","type":"image"}]}