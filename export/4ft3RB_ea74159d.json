{"ver":"0.1","info":{"id":"4ft3RB","date":"1711837226","viewed":81,"name":"Revision 2024 - shader jam","username":"Exca","description":"My jam shader for shader jam of Revision 2024.\nAll effects would be driven by bonzomatics ffti + ffts, currently ran by just time.","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["revision","jam"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = texture(iChannel0, uv).rgb;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGRr","filepath":"/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","previewfilepath":"/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nfloat time = 0.0;\nfloat fft = 0.0;\nfloat ffts = 0.0;\nfloat ffti = 0.0;\nfloat glow1 = 0.0;\nfloat glow2 = 0.0;\nfloat glow3 = 0.0;\nfloat beat = 0.0;\nfloat beatstep = 0.0;\nfloat bar = 0.0;\nfloat barstep = 0.0;\nvec2 uv = vec2(0.0);\n\nvec3 getcam(vec3 cam, vec3 target, vec2 uv, float fov)\n{\n  vec3 forward = normalize(target - cam);\n  vec3 right = normalize( cross(vec3(0,1,0), forward));\n  vec3 up = normalize( cross(forward, right));\n  return normalize( forward * fov + uv.x * right +  uv.y * up);\n}\nvec3 rotate( vec3 p, float x, float y, float z)\n{\n  mat3 rotx = mat3( 1.0, 0.0, 0.0, 0.0, cos(x), -sin(x), 0.0, sin(x), cos(x));\n  mat3 roty = mat3( cos(y), 0.0, sin(y), 0.0, 1.0, 0.0, -sin(y), 0.0, cos(y));\n  mat3 rotz = mat3( cos(z), -sin(z), 0.0, sin(z), cos(z), 0.0, 0.0, 0.0, 1.0);\n  return rotx*roty*rotz * p;\n}\n\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 color1 = vec3(0.0);\n\nvec2 rot2d( float a, vec2 p)\n{\n  return mat2( cos(a), -sin(a), sin(a), cos(a)) * p;\n}\n\nvec3 repeat( vec3 p, vec3 q)\n{\n  return mod(p + q*0.5, q)-q*0.5;\n}\n\n\nfloat hexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat octahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\n\n\nfloat sphere(vec3 p, float r)\n{\n  return length(p) - r;\n}\n\nfloat ground(vec3 p, float h)\n{\n  return p.y - h;\n}\n\nvec3 unions(vec3 a, vec3 b)\n{\n  return a.x < b.x ? a : b;\n}\n\nvec3 map( vec3 p )\n{\n  vec2 ruv = rot2d( (ffti*0.3-ffts*2.0)*0.1, uv)+vec2(ffti*0.7, ffti*0.3);\n  \n  if(ffts > 0.85) p = rotate( p, floor(ruv.x*15.0)-0.5*ffti,floor(ruv.y*5.0)+floor(uv.x*5.0),0.0);\n  else if(ffts > 0.4) p = rotate( p, floor(ruv.x*3.0)-0.5*ffti,floor(uv.y*0.0)+floor(uv.x*3.0),0.0);\n  else if(ffts > 0.3) p = rotate( p, floor(ruv.x*1.0)-0.5*ffti,floor(ruv.y*10.0)+floor(uv.x*5.0),0.0);\n  else if(ffts > 0.2) p = rotate( p, floor(ruv.x*1.0)-0.5*ffti,floor(uv.y*5.0)+floor(uv.x*2.0),0.0);\n  else if(ffts > 0.1) p = rotate( p, floor(uv.x*4.0)-0.5*ffti,floor(uv.y*2.0)+floor(ruv.x*5.0),0.0);\n  else p = rotate( p, floor(uv.x*1.0)-1.5*ffti,floor(uv.y*1.0)+floor(ruv.x*1.0),0.0);\n  \n  vec3 sphereP = repeat( p, vec3( 1.0, 0.0,1.0));\n  \n  float distanceFromCenter = length( p);\n  float distanceSize = 1.0 - smoothstep(1.0, 5.0, distanceFromCenter);\n  \n  float bm = mod(beat,4.0);\n  \n  float s1 = sphere(sphereP, 0.5 * distanceSize);\n  if(bm < 1.0) s1 = hexPrism(sphereP, vec2(0.2,0.4) * distanceSize);\n  else if(bm < 2.0) s1 = octahedron(sphereP, 0.8 * distanceSize);\n  \n  float innerRadius = (0.2+ 0.2 * ffts)*distanceSize;\n  float innerOffset = (0.25 + ffts*0.25)*distanceSize;\n  float sx1 = sphere(sphereP - vec3(innerOffset, 0.0,0.0), innerRadius);\n  float sx2 = sphere(sphereP - vec3(-innerOffset, 0.0,0.0), innerRadius);\n  float sy1 = sphere(sphereP - vec3(0.0, -innerOffset,0.0), innerRadius);\n  float sy2 = sphere(sphereP - vec3(-0.0, innerOffset,0.0), innerRadius);\n  float sz1 = sphere(sphereP - vec3(0.0, 0.0,-innerOffset), innerRadius);\n  float sz2 = sphere(sphereP - vec3(-0.0, 0.0,innerOffset), innerRadius);\n  \n  float si = min(sx1, sx2);\n  si = min(si, sy1);\n  si = min(si, sy2);\n  si = min(si, sz1);\n  si = min(si, sz2);\n  \n  s1 = max(s1, -si);\n  \n  float lightSphere = sphere(sphereP, 0.07*ffts + 0.05*(sin(floor(p.x+0.5)+ffti*4.0) + cos(ffti*10.0-floor(p.z+0.5))));\n  \n  float g1 = ground(p, -2.0);\n  \n  glow1 += 1.0/lightSphere;\n  //glow1 += smoothstep(0.0, 0.5, lightSphere);\n  \n  \n  vec3 S1 = vec3(s1, 1.0, 0.0);\n  vec3 LS1 = vec3(lightSphere, 2.0, 0.0);\n  vec3 GROUND1 = vec3( g1, 3.0, 0.0);\n  \n  \n  vec3 OUT = unions(GROUND1, unions(S1, LS1));\n  \n  return OUT;\n}\n\nvec3 march( vec3 cam, vec3 rd, out vec3 p, out float travel)\n{\n  float minim = 99.0;\n  for(int i = 0; i < 100; i++)\n  {\n    p = cam + rd*travel;\n    vec3 r = map(p);\n    travel += r.x;\n    minim = min(r.x, minim);\n    if(r.x < 0.001){\n      return r;\n    }\n    if(travel > 90.0){\n      travel = 90.0;\n      return vec3( minim, 0.0, 0.0);\n    }\n  }\n  return vec3( minim ,0.0, 0.0);\n}\n\nvec3 normal( vec3 p )\n{\n  vec3 c = map(p);\n  vec2 e = vec2(0.001, 0.0);\n  return normalize( vec3(\n    map(p+e.xyy).x,\n    map(p+e.yxy).x,\n    map(p+e.yyx).x\n  )-c.x);\n}\n\nfloat diffuse( vec3 p, vec3 n, vec3 l)\n{\n  return max( 0.0, dot(n, normalize(l-p)));\n}\n\nvec2 barrelDistortion(vec2 uv, float k)\n{\n  float rd = length(uv);    \n  float ru = rd * (1.0 + k * rd * rd);\n  uv /= rd;\n  uv *= ru;\n  return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    color1 =  palette( time, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.3,0.20,0.20));\n    time = iTime;\n\tuv = vec2(gl_FragCoord.x / iResolution.x, gl_FragCoord.y / iResolution.y);\n  vec2 ouv = uv;\n\tuv -= 0.5;\n\t\n    fft = texture(iChannel0,vec2(0.2,0.5)).r;\n  // Use time instead of continous fft\n  ffti = time;// texture(iChannel0,0.2).r;\n  // Use  time to get some kind of faked smoothed fft\n  ffts = abs(sin(time)*0.85);// texture(texFFTSmoothed, 0.15).r*30.0;\n  \n  uv = barrelDistortion(uv, 0.10 + smoothstep(0.0, 0.75, ffts)*0.5 * smoothstep(0.08, 0.2, length(uv-0.5)));\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  beat = floor(time * 110.0 / 60.0);\n  beatstep = fract( time * 130.0 / 60.0*1.0);\n  bar = floor(beat/4.0);\n  barstep = fract(beat/4.0);\n  \n  \n  vec3 col = vec3(0.0);\n  \n  vec3 target = vec3(\n    sin(ffti*0.05)*1.3,\n    cos(ffti*0.01)*0.3+0.8,\n    cos(ffti*0.02)*1.3 +  cos(time*0.3)*1.0\n   );\n  vec3 cam = vec3(\n    sin(time*0.1)*1.3,\n    cos(time*0.1)*0.3+0.8,\n    cos(time*0.2)*1.3 +  cos(time*0.3)*1.0\n  );\n  float fov = 0.5;\n  \n  vec3 light1 = vec3( \n    sin(time)*2.3,\n    cos(time)*0.3+3.0,\n    cos(time)*2.3 +  cos(time*0.3)*1.0\n  );\n  \n  vec3 rd = getcam( cam, target, uv, fov);\n  \n  vec3 marchP = cam;\n  float marchT = 0.0;\n  vec3 res = march( cam , rd, marchP, marchT);\n  \n  if(res.y < 0.5 ){\n    // bg \n    \n  }\n  else if(res.y < 1.5){\n    // balls\n    vec3 n = normal(marchP);\n    vec3 l = color1 * diffuse( marchP, n, light1);\n    col =vec3(1.0) * l;\n    \n    // balls reflection\n    vec3 ref = reflect( rd, n);\n    vec3 refP = marchP;\n    float refT = 0.0;\n    vec3 refR = march( marchP - n*0.1, ref, refP, refT);\n    vec3 refC = vec3(0.0);\n    if(refR.y < 0.5 ){\n      // ref1 bg \n      refC = vec3(0.0);\n    }\n    else if(refR.y < 1.5){\n      // ref1 balls\n      vec3 n = normal(refP);\n      vec3 l = color1 * diffuse( refP, n, light1);\n      refC =vec3(1.0) * l;\n    }\n    else if(refR.y < 2.5){\n      // ref1 inner light\n      refC =vec3(1.0);\n    }\n    else if(refR.y < 3.5){\n      // ref1 ground\n      refC = vec3(1.0);\n    }\n    col = mix(col, refC,0.4);\n    \n    \n  }\n  else if(res.y < 2.5){\n    // inner light\n    col =vec3(1.0);\n  }\n  else if(res.y < 3.5){\n    // ground\n    float xl = length( mod(marchP.x*3.0,4.0)-2.0);\n    float zl = length( mod(marchP.z*3.0,4.0)-2.0);\n    col = vec3( 0.1,0.2,0.3) * (1.0-xl * zl)*1.1;\n    \n    // ground reflection\n    vec3 n = normal(marchP);\n    vec3 ref = reflect( rd, n);\n    vec3 refP = marchP + n*0.1;\n    float refT = 0.0;\n    vec3 refR = march( marchP + n*0.1, ref, refP, refT);\n    vec3 refC = vec3(0.0);\n    if(refR.y < 0.5 ){\n      // ref1 bg \n      refC = vec3(0.0);\n    }\n    else if(refR.y < 1.5){\n      // ref1 balls\n      vec3 n = normal(refP);\n      vec3 l = color1 * diffuse( refP, n, light1);\n      refC =vec3(1.0) * l;\n    }\n    else if(refR.y < 2.5){\n      // ref1 inner light\n      refC =vec3(1.0);\n    }\n    else if(refR.y < 3.5){\n      // ref1 ground\n      refC = vec3(1.0);\n    }\n    col = refC;\n  }\n  \n  col += glow1*0.002;\n  \n  col = mix( col, vec3(0.0), smoothstep(10.0, 15.0, marchT));\n  \n  float bm = mod(bar,4.0);\n  if(bm < 1.0) col.rgb = col.grb;\n  else if(bm < 2.0) col.rgb = col.brg;\n  else if(bm < 3.0) col.rgb = col.rbg;\n  else if(bm < 4.0) col.rgb = col.gbr;\n  \n  \n  ouv -= 0.5;\n  ouv *= 1.05-ffts*0.15;\n  ouv += 0.5;\n  vec3 prev = texture( iChannel3, rot2d(ffti, ouv)).rgb + texture( iChannel3, ouv).rgb;\n  prev *=0.5;\n  col = mix( \n    col, \n    col + palette(time*0.3,vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.3,0.20,0.20))*  prev*0.5, smoothstep(0.005, 0.2, ffts));\n  \n  fragColor = vec4(col, 1.0);\n  \n  \n}\n\n","name":"Buffer A","description":"","type":"buffer"}]}