{"ver":"0.1","info":{"id":"XdSBD1","date":"1500185504","viewed":1378,"name":"[SH17A] Starfall / KaliSet","username":"unbird","description":"Minimal KaliSet shader to generate falling stars. No textures.\nOriginal:[url=https://www.shadertoy.com/view/4ljGDd]Magic Fractal[/url] by dgreensp.\n[url=http://casual-effects.blogspot.ch/2013/08/starfield-shader]Article about the KaliSet[/url].","likes":27,"published":1,"flags":64,"usePreview":0,"tags":["star","kaliset","storm","minimal","competition","alu","sh17a"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXSDS","filepath":"https://soundcloud.com/jensemann-jr/depeche-mode-waiting-for-the","previewfilepath":"https://soundcloud.com/jensemann-jr/depeche-mode-waiting-for-the","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// [SH17A] Starfall / minimal KaliSet by unbird\n// Someone complained about the load of comments, so here's another switch.\n// Bare minimum first, so it fits into the page's view.\n// /*  <- uncomment to switch to commented version further below\n\n\n// \"canonical\" loop: change step size for fidelity and performance\n#define F for(float i = .1; i <.9; i+=.04)\nvoid mainImage( out vec4 f, in vec2 u )\n{\t\n    u /= iResolution.y;\n    f -= f;    \n    F \n    {\n        // vec2 on the next line defines direction and speed of the animation\n        vec3 p = vec3(u + (iTime/i - i)/vec2(30,10), i);\n\t\t            \t\n        p = abs(1.-mod(p, 2.));\n        float a = length(p),\n              b,\n              c = 0.;\n        F\n          p = abs(p)/a/a - .57,   // <- Kali magic constant (between .5 .. .6 gives good results)\n          b = length(p),\n          c += abs(a-b),\n          a = b;        \n        \n        c*=c;\n                \n        f += c*vec4(i, 1, 2, 0) / 3e4 ; // <- overall scaling constant, play here if you're \"blind\"\n    }\t\n}\n\n// - Thanks to Bananaft for the comma trick in the inner loop.\n// - Cleaned a bit and commented the knobs for deadline (only short version above)\n\n\n// careful: switch comment, don't touch\n/*/\n// careful: switch comment, don't touch\n\n///////////////////////////////////////////////////////////////////////////////////////////////////\n// \n// [SH17A] Starfall / minimal KaliSet\n// Shadertoy 2017 Competition contribution\n// by unbird\n// July 2017\n// License : Use at your own risk, do whatever you want, gimme the least headache license 1.0.\n//\n// Original used: \n// Magic Fractal by dgreensp \n// https://www.shadertoy.com/view/4ljGDd\n// I would like to thank dgreensp for this pearl.\n// It's a bare Kaliset variant, has little fluff, so I chose this to work from.\n// He didn't put a license, so I hope it's ok.\n// \n// I left the original comments somewhat, marked as //--\n// \n// \n// Goal: \n// Meteorite/Shooting star storm animation \n// 1Get it down to reach the 280 character limit (competition rule round 1)\n// Mostly code jugglery, renaming, inlining etc. so far\n// I now got it down, though saving more space would let me play with polishing/effects.\n// \n//\n// Current problems:\n// - Delicate. No convincing central knob (and too many) or even autoexposure. \n//   Missing the spot means black or white.\n// - Potentian platform problems. Not yet run on different hardware/compilers, need feedback.\n//   Here NVidia GTX 960.\n// - Still too big... Nope, as of now at 280... Hooray. But it looks boring.\n//   The pow accentuation was better, but maybe one can fake something else.\n// - Minor: Initial looks regular, needs about 15 sec to disperse the planes.\n//          I can't use offsets now.\n// - It's messy, but hey.\n// \n// \n// Reference: Technical/math read about Kaliset : http://casual-effects.blogspot.ch/2013/08/starfield-shader.html\n//            \n// History:\n// 2017-07-15 Created. Brought down to 320 chars.\n// 2017-07-16 Cleanup, somments, further reductions. 302 chars.\n//            Oh. Wow I have 280 chars!!!\n\n\n  // <- put switch comment start here (/*) for sompetition vs older, more convenient code later\n\n// Attempt at a \"canonical\" loop. Idea: provides approx. unit range (without surprises). \n// Loop count/resolution controlled through stepsize (last constant). I nest then two of them.\n// \n// Also performance control. Increase step size if it runs too slow for you.\n#define F for(float i = .1; i <.9; i+=0.04){\n\nvoid mainImage( out vec4 f, in vec2 u )\n{\t\n    u = u.xy / iResolution.yy;\n    \n    //uv.x = (uv.x - 1.0)*(1.0 + uv.y*uv.y * 0.4) + 1.0;\n    //--scroll a certain number of screenfuls/second\n    //uv.y += iTime*vec2(-0.1,0.05);\n    \n    // Clear. \n    f *= 0.;\n    \n    // I'd like to add background (planet/atmosphere) but I got no place yet.\n \n\n    // Here I eliminated a 3D rotation. \"Expensive\" source code wise,\n    // Doesn't seem to be needed. Problem: Takes some time to \n    // \"mix the planes\" at the start.\n    //vec3 p = 0.5*M*vec3(uv, z);\n\n\n    // No longer needed, time is used only once, so inlined\n    // float t = .1 * iTime;\n    \n    \n    // outer/planes loop\n    //for(float i = 0.1; i <= 0.9; i+= 0.05)\n      F  \n    //{\n        // \n        //\n        // scaling the planes, including \"perspective\" (/i)  \n        vec3 p = vec3(u + (.1 * iTime/i - i) * vec2(.4,.5), 0\n                          //sin(t*.4)*.2  // <- wobbling z gives the stars some \"burning\". Too costly for now\n                          );\n        \n        // abs is enough\n        //p = 1. - abs(1. - mod(p, 2.));\n    \tp = abs(1.-mod(p, 2.));\n\n        float a = length(p),\n              b = a,\n              c = 0.;\n        //--This is the fractal.  More iterations gives a more detailed\n        //--fractal at the expense of more computation.\n        F\n        //{\n          //--The number subtracted here is a \"magic\" paremeter that\n          //--produces rather different fractals for different values.\n            \n\t\t  // The magic number below (the constant) controls the overall shape. \n          // Again somewhat delicate: Viable values aroung 0.5..0.6. \n          // Annoyingly, those two numbers \n          p = abs(p)/(a*a) - .57;    \n          b = length(p);\n          c += abs(a-b);\n          a = b;\n    \n          // tricky problem: can I remove a variable here ? it's all interlocked it seems.\n              \n        }\n        \n        // Nope, if I clamp the thing is gone, and I somehow need pow though to accentuate.\n\t\t// I need stats to normalize this :P\n        //v = clamp(v, 0., 1.);\n        \n\t\t// Accentuate. Disable for now, too costly.\n\t\t//c = pow(c, 5.);\n\t\t// If you enable this, choose 4e-4 for the later constant\n        //c*=c;\n\n        f.rgb +=                   \n                 // Color. This sort of gives a fiery fireball storm.\n                 // Not what I'm after, but it's a start.\n                 vec3(c, .5*c, i * c) \n                 // Here's currently the \"central\" knob, a scale constant. Play here if you're blind.\n                 // division saves 1 char\n                 / 4e2;\n             \t \n    }\n\t\n}\n\n// careful: switch comment, don't touch\n/*\n// careful: switch comment, don't touch\n\n///////////////////////////////////////////////////////////////////////////////////////////////////\n// working, older variant.\n\n\nfloat finish (float x)\n{\n    x *= 0.3;\n    x = pow(x, 5.0);\n    //result = pow(result, 5.);\n    //result -= 0.5;\n    return x-10.0;\n}\n\nfloat m(vec3 p) {\n    // The fractal lives in a 1x1x1 box with mirrors on all sides.\n    // Take p anywhere in space and calculate the corresponding position\n    // inside the box, 0<(x,y,z)<1\n    p = 1. - abs(1. - mod(p, 2.));\n    \n    float r = length(p),\n          s = r,\n          t = 0.0;\n    // This is the fractal.  More iterations gives a more detailed\n    // fractal at the expense of more computation.\n    for (int i=0; i < 12; i++) {\n      // The number subtracted here is a \"magic\" paremeter that\n      // produces rather different fractals for different values.\n      p = abs(p)/(r*r) - 0.57;\n      s = length(p);\n      t += abs(s-r);\n      r = s;\n    }\n\n    return t;\n}\n\nvoid mainImage( out vec4 f, in vec2 u )\n{\n\t//vec2 u = fragCoord.xy / iResolution.yy;\n    u = u.xy / iResolution.yy;\n    \n    //uv.x = (uv.x - 1.0)*(1.0 + uv.y*uv.y * 0.4) + 1.0;\n    // scroll a certain number of screenfuls/second\n    //uv.y += iTime*vec2(-0.1,0.05);\n    \n    \n    float t = 0.1 * iTime;\n    float z = t*0.01;\n    z = sin(t*0.4)*0.2;\n\tf *= 0.;\n    // Rotate uv onto the random axes given by M, and scale\n    // it down a bit so we aren't looking at the entire\n    // 1x1x1 fractal volume.  Making the coefficient smaller\n    // \"zooms in\", which may reduce large-scale repetition\n    // but requires more fractal iterations to get the same\n    // level of detail.\n    \n    //vec3 p = 0.5*M*vec3(uv, z);\n    \n    \n    for(float i = 0.1; i <= 0.9; i+= 0.05)\n    {\n        vec2 xy = u + i * vec2(11.,-26.);\n        xy.xy += t*0.05/i;        \n        vec3 p = 0.5*vec3(xy, z);\n        \n        p *= 1.1;\n        p.yz += 2.;        \n        \n        float v = m(p);\n        v = pow(v, 3.0);        \n        f.rgb += 0.00001 * v * mix(vec3(1.,1.,.8), vec3(.3, .1, .2), i);\n    }\n        \n     \n\t\n}\n/* */","name":"Image","description":"","type":"image"}]}