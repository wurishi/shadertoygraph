{"ver":"0.1","info":{"id":"WsGcRG","date":"1603065505","viewed":137,"name":"SDF Playground for CPSC479","username":"edorobek","description":"A space to play around with implicit surfaces","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision mediump float;\n\n\n#define ANIMATE 0\n#define MAX_STEPS 255\n#define MIN_DIST 0.0\n#define MAX_DIST 100.0\n#define EPSILON 0.0001\n\nfloat dot2(in vec2 v) { return dot(v,v); }\n\n\n/* SIGNED DISTANCE FUNCTIONS */\n// ============================================================== //\nfloat sphereSDF(vec3 p,  float r) \n{\n    return length(p) - r;\n}\n\n\nfloat boxSDF(vec3 p, vec3 b)\n{\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.0)) + min(max(q.x, max(q.y,q.z)), 0.0);\n}\n\nfloat roundBoxSDF(vec3 p, vec3 b, float r)\n{\n\tvec3 q = abs(p) - b;\n\treturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.x)),0.0) - r;\n}\n\nfloat boundingBoxSDF( vec3 p, vec3 b, float e )\n{\n    p = abs(p) - b;\n    vec3 q = abs(p + e) - e;\n\treturn min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat torusSDF(vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat cappedTorusSDF(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat linkSDF( vec3 p, float le, float r1, float r2 )\n{\n  vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n  return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\nfloat cylinderSDF( vec3 p, vec3 c )\n{\n  return length(p.xz - c.xy)-c.z;\n}\n\nfloat coneSDF( in vec3 p, in vec2 c, float h )\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp(w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y - w.y*q.x), k*(w.y - q.y));\n  return sqrt(d) * sign(s);\n}\n\nfloat infConeSDF( vec3 p, vec2 c )\n{\n    vec2 q = vec2( length(p.xz), -p.y );\n    float d = length( q - c*max(dot(q,c), 0.0) );\n    return d*( (q.x*c.y - q.y*c.x < 0.0) ? -1.0 : 1.0);\n}\n\nfloat planeSDF( vec3 p, vec3 n, float h )\n{\n  // n must be normalized!!\n  return dot(p,n) + h;\n}\n\nfloat sdfHexPrime( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat triPrismSDF( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z - h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat capsuleSDF( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp( dot(pa,ba) / dot(ba,ba), 0.0, 1.0 );\n  return length(pa - ba*h) - r;\n}\n\nfloat cappedCylinderSDF( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat roundCylinderSDF( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat cappedConeSDF( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat roundConeSDF( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\n// NOTE: approximation\nfloat ellipsoidSDF( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p / (r*r));\n  return k0*(k0 - 1.0)/k1;\n}\n\nfloat octahedronSDF( vec3 p, float s)\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nfloat pyramidSDF( vec3 p, float h)\n{\n  float m2 = h*h + 0.25;\n    \n  p.xz = abs(p.xz);\n  p.xz = (p.z > p.x) ? p.zx : p.xz;\n  p.xz -= 0.5;\n\n  vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n  float s = max(-q.x,0.0);\n  float t = clamp( (q.y - 0.5*p.z)/(m2 + 0.25), 0.0, 1.0 );\n    \n  float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n  float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n  float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n  return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n}\n\n\n\n// Combinations\nfloat unionOp(float d1, float d2) { return min(d1,d2); }\nvec2 unionOp(vec2 d1, vec2 d2) { return (d1.x<d2.x) ? d1 : d2; }\nfloat subtractOp(float d1, float d2) { return max(-d1,d2); }\nvec2 subtractOp(vec2 d1, vec2 d2) { return (-d1.x > d2.x) ? -d1 : d2; }\nfloat intersectOp(float d1, float d2) { return max(d1,d2); }\nvec2 intersectOp(vec2 d1, vec2 d2) { return (d1.x > d2.x) ? d1 : d2; }\n\nfloat smoothUnionOp( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\nvec2 smoothUnionOp( vec2 d1, vec2 d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2.x-d1.x)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat smoothSubOp( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nvec2 smoothSubOp( vec2 d1, vec2 d2, float k ) \n{\n    float h = clamp(0.5 - 0.5*(d2.x + d1.x)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0 - h); \n}\n\nfloat smotherIntersectOp( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(d2 - d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0 - h); \n}\n\nvec2 smotherIntersectOp( vec2 d1, vec2 d2, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(d2.x - d1.x)/k, 0.0, 1.0 );\n\treturn mix( d2, d1, h ) + k*h*h*(1.0 - h); \n}\n\n\n\n\n/* Experimental smooth minimum function s*/\nfloat smin( float a, float b, float k )\n{\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\n// polynomial smooth min (k = 0.1);\nfloat sminA( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\n// polynomial smooth min (k = 0.1);\nfloat sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\n// power smooth min (k = 8);\nfloat sminB( float a, float b, float k )\n{\n    a = pow( a, k ); b = pow( b, k );\n    \n    \n    return pow( (a*b)/(a+b), 1.0/k );\n}\n\n/* Transformations */\n\n// rotation and scaling\nvec3 linearTOp(vec3 p, mat4 transform)\n{\n\treturn (inverse(transform)*vec4(p,1.0)).xyz;\n}\n\nvec3 translateOp(vec3 p, vec3 h)\n{\n\treturn p - h;\n}\n\n// NOTE: YOU MUST MULTIPLY RESULTING DISTANCE BY 's'\nvec3 scaleOp(vec3 p, float s)\n{\n\treturn p / s;\n}\n\n/* Deformations */\n\n// Displacement: SDF(p) + displace(p)\n\n// ALTERATIONS\n\nvec4 elongateOP(vec3 p, vec3 h)\n{\n\tvec3 q = abs(p)-h;\n\treturn vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0));\n}\n\nfloat roundOp(float d, float h)\n{\n    return d - h;\n}\n\nvec3 twistOp(vec3 p, float k)\n{\n\tfloat c = cos(k*p.y);\n\tfloat s = sin(k*p.y);\n\tmat2 m = mat2(c,-s,s,c);\n\treturn vec3(m*p.xz,p.y);\n\t\n}\n\nvec3 bendOp(vec3 p)\n{\n\tconst float k = 10.;\n\tfloat c =  cos(k*p.x);\n\tfloat s = sin(k*p.x);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn vec3(m*p.xy, p.z);\n}\n\n\n// ============================================================== //\n// PLAY WITH CODE HERE\n// ============================================================== //\n\n/* SDF FOR THE ENTIRE SCENE */\n\nvec2 map(vec3 p)\n{\n\tvec2 result = vec2(1e10, 0.0);\n\t{\n\t\t// PLANE COLOR CODE MUST BE < 1.5\n\t\tresult = unionOp(result, vec2(boxSDF(p - vec3(0.0,-1.1 ,0.0), vec3(15,.01,15)), 1.1)); \n\t\tresult = unionOp(result, vec2(sphereSDF(p, 1.05), 2.));\n\t\tresult = smoothUnionOp(result, vec2(sphereSDF(p + vec3(2.0, -0.40, 0.0), 1.), 3.), .7);\n\t\tresult = unionOp(result, vec2(boxSDF(twistOp(p - vec3(-0.5,3.,0.0), 1.6), vec3(1.)), 26.));\n\t}\n\t\n\treturn result;\n}\n\nconst float sunIntensity = 1.2;\nconst vec3 sunColor = sunIntensity*vec3(1.30,1.00,0.60);\n\nvec3 background(vec3 q)\n{\n\treturn mix( vec3(0.3,0.3,0.8)*0.5, vec3(0.6, 0.8, 1.0), 0.7 + 0.5*q.y );\n}\n\n// ============================================================== //\n\n// intersect ray with the scene\nvec2 raycast(vec3 ro, vec3 rd)\n{\n\tvec2 result = vec2(-1.0);\n\tfloat t = MIN_DIST;\n\tfor (int i =0; i < MAX_STEPS && t < MAX_DIST; i++) {\n\t\tvec2 h = map(ro + t*rd);\n\t\tif (abs(h.x) < (EPSILON*t)) {\n\t\t\tresult = vec2(t, h.y);\n\t\t\tbreak;\n\t\t}\n\t\tt += h.x;\n\t}\n\t\n\treturn result;\n}\n\n// get direction of ray with just device coordinates\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\n// calculate the normal via finite differences\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<24; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.2 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n\n\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\nvec3 light = normalize( vec3(-0.5, 0.4, 0.6) );\n\n\nvec3 render(vec3 ro, vec3 rd, vec3 rdx, vec3 rdy)\n{\n\t// background\n\tvec3 col = background(rd);\n\t\n\tvec2 tmat = raycast(ro, rd);\n\tfloat t = tmat.x;\n\tfloat m = tmat.y;\n\tif (m > -1.) {\n\t\n\t\t\n\t\tcol = 0.2 + 0.2*sin( m*2.0 + vec3(0.0,1.0,2.0) );\n        float ks = 1.0;\n\t\n\t\tvec3 pos = ro + tmat.x*rd;\n\t\tvec3  hal = normalize(light - rd );\n\t\tvec3 norm = (m < 1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n\t\tvec3 ref = reflect( rd, norm );\n\t\t\n\t\tif( m<1.5 )\n        {\n            // project pixel footprint into the plane\n            //vec3 dpdx = ro.y*(rd/rd.y-rdx/rdx.y);\n            //vec3 dpdy = ro.y*(rd/rd.y-rdy/rdy.y);\n\n            col = vec3(0.30);\n            ks = 0.1;\n        }\n\t\t\n\t\tfloat occ = calcAO(pos, norm); \n\t\tvec3 lin = vec3(0.0);\n\t\t\n\t\t// sun\n\t\t{\n            vec3  hal = normalize( light-rd );\n            float dif = clamp( dot( norm, light ), 0.0, 1.0 );\n        \t      dif *= calcSoftshadow( pos, light, 0.02, 2.5 );\n\t\t\tfloat spe = pow( clamp( dot( norm, hal ), 0.0, 1.0 ),16.0);\n                  spe *= dif;\n                  spe *= 0.04+0.16*pow(clamp(1.0-dot(hal,light),0.0,1.0),2.0);\n            lin += col*2.20*dif*sunColor;\n            lin +=     5.00*spe*sunColor*ks;\n        }\n        \n        // sky\n        {\n            float dif = sqrt(clamp( 0.5+1.5*norm.y, 0.0, 1.0 ));\n            dif *= occ;\n            float spe = smoothstep( -0.2, 0.2, ref.y );\n            spe *= dif;\n            spe *= 0.04+0.96*pow(clamp(1.0+dot(norm,rd),0.0,1.0), 5.0 );\n            spe *= calcSoftshadow( pos, ref, 0.02, 4.2 );\n            lin += col*0.70*dif*background(rd);\n            lin +=     1.30*spe*background(rd)*ks;\n        }\n        col = lin;\n\n\t\t// falloff (fakes a depth blur)\n        col = mix( col, vec3(0.7,0.7,0.9), 1.0-exp( -0.00002*t*t*t ) );\n\t}\n\t\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(8.0, 6.0, 18.0);\n    \n    mat4 viewToWorld = viewMatrix(eye, vec3(-1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n  \t// ray derivatives\n    vec2 px = (2.0*(fragCoord+vec2(1.0,0.0))-iResolution.xy)/iResolution.y;\n    vec2 py = (2.0*(fragCoord+vec2(0.0,1.0))-iResolution.xy)/iResolution.y;\n    vec3 rdx = (viewToWorld * normalize( vec4(px,2.5, 1.0) )).xyz;\n    vec3 rdy = (viewToWorld * normalize( vec4(py,2.5, 1.0) )).xyz;\n    \n    vec3 col = render(eye, worldDir, rdx, rdy);\n\n\tfragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}