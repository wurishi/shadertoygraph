{"ver":"0.1","info":{"id":"slfGDj","date":"1622845284","viewed":97,"name":"Trunchet pattern __","username":"Envy24","description":"Source: https://thebookofshaders.com/10/","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["pattern","maze","trunchet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Returns hash in range [0.0; 1.0].\n*/\nfloat sample2DHashUI32(uint x, uint y)\n{\n    // Pick some enthropy source values.\n    // Try different values.\n    const uint enthropy0 = 123u;\n    const uint enthropy1 = 456u;\n    const uint enthropy2 = 789u;\n\n    // Use linear offset method to mix coordinates.\n    uint value = y * enthropy2 + x;\n\n    // Calculate hash.\n\tvalue += enthropy1;\n\tvalue *= 445593459u;\n\tvalue ^= enthropy0;\n    \n    // 1.0f / 4294967295.0f = 2.32830644e-10\n\n    return float(value * value * value) * 2.32830644e-10;\n}\n\nvec2 trunchetPattern(vec2 uv, float random)\n{\n    // random = [0.0; 1.0]\n    // uv = ([0.0; 1.0], [0.0; 1.0])\n\n    uv.x = mix(uv.x, 1.0 - uv.x, float(random > 0.66));\n    uv.y = mix(uv.y, 1.0 - uv.y, float(random > 0.33));\n    \n    // some smoothstep distortion.\n    //uv.x = uv.x * uv.x * (3.0 - 2.0 * uv.x);\n    //uv.y = uv.y * uv.y * (3.0 - 2.0 * uv.y);\n    \n    return uv;\n}\n\nfloat lines(const vec2 tile, const float width)\n{\n    float p0 = float(tile.x > width);\n    float p1 = float(tile.y > width);\n\n    return p0 > p1 ? 0.0 : p0;\n}\n\nfloat triangles(const vec2 tile)\n{\n    //if (tile.y < tile.x) { return 1.0; }\n    //else { return 0.0; }\n    return float(tile.y < tile.x);\n}\n\nfloat circles(\n    vec2 tile,\n    float innerRadius,\n    float outerRadius)\n{\n    float length0 = length(tile);\n    float length1 = length(tile - vec2(1.0));\n               \n    return (float(length0 < outerRadius && length0 > innerRadius)) +\n           (float(length1 < outerRadius && length1 > innerRadius));\n}\n\nfloat howCirclesWork(\n    const vec2 tile,\n    const float outerRadius)\n{\n    float length0 = length(tile);\n    float length1 = length(tile - vec2(1.0));\n              \n    return float((length0 < outerRadius) || (length1 < outerRadius));\n}\n\nfloat maze(const vec2 tile, const float width)\n{\n    float xMin = tile.x - width;\n    float xMax = tile.x + width;\n    \n    // Inverse linear interpolation.\n    float t0 = (tile.y - xMin) / (tile.x - xMin);\n    float t1 = (tile.y - tile.x) / (xMax - tile.x);\n    \n    // Smoothstep interpolation\n    t0 = t0 * t0 * (3.0 - 2.0 * t0);\n    t1 = t1 * t1 * (3.0 - 2.0 * t1);\n            \n    return t0 - t1;  \n}\n\nfloat rectangles(vec2 tile, const float fractU)\n{\n    tile.x = smoothstep(fractU - 1.0, fractU + 1.0, fractU);\n    return triangles(tile);\n}\n\nvec2 makeTiles(\n    const vec2 uv,\n    const float pixelWidth)\n{\n    return vec2(\n        uv.x * pixelWidth,\n        uv.y * pixelWidth);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.x;\n    \n    float _u = uv.x;\n    \n    float scale = 20.0 + (iMouse.y / iResolution.y * 30.0);\n    uv = makeTiles(uv, 1.0 * scale);\n    \n    vec2 ipos = floor(uv);\n    vec2 fpos = fract(uv);\n    \n    vec2 tile = \n        trunchetPattern(\n            fpos,\n            sample2DHashUI32(uint(ipos.x), uint(ipos.y + iTime * 0.5)));\n\n    float gray = 0.0;\n    \n    if (_u < 0.16) { gray = lines(tile, 0.15); }\n    else if (_u >= 0.16 && _u < 0.33) { gray = triangles(tile); }\n    else if (_u >= 0.33 && _u < 0.5) { gray = howCirclesWork(tile, 0.6); }\n    else if (_u >= 0.5 && _u < 0.66) { gray = circles(tile, 0.4, 0.6); }\n    else if (_u >= 0.66 && _u < 0.83) { gray = rectangles(tile, fpos.x); }\n    else { gray = maze(tile, 0.1); }\n    \n\n    // Output to scren\n    fragColor = vec4(vec3(gray),1.0);\n}","name":"Image","description":"","type":"image"}]}