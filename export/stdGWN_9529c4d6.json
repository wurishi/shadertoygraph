{"ver":"0.1","info":{"id":"stdGWN","date":"1636158091","viewed":428,"name":"Granular Synthesis","username":"paniq","description":"combining cosine shaped grains, see granular() in Common","likes":16,"published":3,"flags":24,"usePreview":0,"tags":["sound","adsr","granular"],"hasliked":0,"parentid":"MdfSW7","parentname":"Sound ADSR Demo"},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int y = int(fragCoord.y);\n    float s = fragCoord.x / iSampleRate;\n    vec2 a = music(0, s + iTime);\n    \n    ivec2 ay = ivec2((a*0.5+0.5)*iResolution.y + 0.5);\n    \n    fragColor = vec4(0.0);\n    if (y == ay.x) {\n        fragColor.rb = vec2(1.0);\n    }\n    if (y == ay.y) {\n        fragColor.g = 1.0;\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec2 mainSound( in int samp,float t) {\n    return music(samp, t);\n}","name":"Sound","description":"","type":"sound"},{"inputs":[],"outputs":[],"code":"\nconst float pi = 3.14159265359;\nconst float pi2 = 6.283185307179586;\n\nfloat hz(float c) {\n    return 13.75 * pow(2.0, (c+3.0)/12.0);\n}\n\n// returns note index, fract\nvec2 seq(float t, float s) {    \n    return vec2(floor(t/s),mod(t, s));\n}\n\nfloat index(float a, float b, float x) {\n    return mix(a, b, step(1.0,x));\n}\n\nfloat index(float a, float b, float c, float x) {\n    return index(index(a, b, x),c,x-1.0);\n}\n\nfloat index(float a, float b, float c, float d, float x) {\n    return index(index(a, b, x),index(c, d,x-2.0),x-1.0);\n}\n\nfloat sqrosc(float p) {\n\treturn step(fract(p),0.5)*2.0-1.0;\n}\n\nfloat sinosc(float p) {\n    return sin(pi2*p);\n}\n\nfloat sawosc(float p) {\n    return 1.0 - 2.0*fract(p);\n}\n\nfloat triosc(float p) {\n    return 1.0 - abs(2.0 - 4.0 * fract(p + 0.25));\n}\n \n// normalizes arguments so the sum is 1\nvec4 normsum(vec4 p) {\n    return p / (p.x+p.y+p.z+p.w);\n}\n\n// v = vec4(attack,decay,hold,release), s = sustain amplitude\nfloat adsr(float t, vec4 v, float s) {\n    v.xyw = max(vec3(2.2e-05),v.xyw);\n    // attack term\n    float ta = t/v.x;\n    // decay / sustain amplitude term\n    float td = max(s, 1.0-(t-v.x)*(1.0-s)/v.y);\n    // length / release term\n    float tr = (1.0 - max(0.0,t-(v.x+v.y+v.z))/v.w);\n    return max(0.0, min(ta, tr*td));\n}\n\nfloat pops(float t) {\n    vec2 a = seq(t,1.0/4.0);\n    a.x = mod(a.x,3.0);\n    \n    vec3 r = vec3(0.0,-2.0,7.0);\n    \n    float q = index(r.x, r.y, r.z, a.x);\n    \n    vec2 w = seq(t,1.0/4.0);\n    float n = 30.0+24.0+q+12.0*mod(floor(w.x*0.5),2.0);\n    \n    float vib_f = hz(0.3*sinosc(4.0*t));\n    \n    return triosc(hz(n)*t + vib_f)\n        * adsr(w.y,vec4(0.01,0.1,0.0,0.2),0.3) * 0.5;\n}\n\nfloat lead(float t) {\n    vec2 a = seq(t,2.0);\n    a.x = mod(a.x,4.0);\n    \n    vec4 r = vec4(0.0,2.0,3.0,0.0);\n    \n    float q = index(r.x, r.y, r.z, r.w, a.x);\n    \n    vec2 w = seq(t,2.0);\n    float n = 30.0+24.0+q;\n    \n    float amp = adsr(w.y,vec4(1.0,0.0,0.0,1.0),1.0);\n    float vib_f = hz(amp*0.5*sinosc(5.0*t));\n    \n    return sinosc(hz(n)*t + vib_f)\n        * amp;\n}\n\n// returns note, amp\nfloat bassline(float t) {\n    vec2 a = seq(t,2.0);\n    a.x = mod(a.x,4.0);\n    \n    vec4 r = vec4(0.0,-2.0,-7.0,3.0);\n    \n    float q = index(r.x, r.y, r.z, r.w, a.x);\n    \n    vec2 w = seq(t,1.0/4.0);\n    float n = 30.0+q+12.0*mod(floor(w.x*0.5),2.0);\n    \n    return triosc(hz(n)*t)\n        * adsr(w.y,vec4(0.001,0.0,0.0,0.2),1.0);\n}\n\nvec2 granular_src(float t) {\n    vec2 q = seq(t,8.0);\n    q.x = mod(q.x,7.0);\n    \n    vec2 s = vec2(bassline(t));\n    \n    s += lead(t)*vec2(0.75,0.25)*step(1.0,q.x);\n    \n    // 4-tap delay\n    float delay = 0.256;\n    float d_f = 0.75;\n    float d_t = t - 24.0;\n    float p_amp = step(3.0,q.x);\n    s += pops(d_t)*p_amp;\n    s += vec2(0.0,1.0)*pops(max(0.0,d_t-delay))*d_f*p_amp;\n    s += vec2(1.0,0.0)*pops(max(0.0,d_t-2.0*delay))*d_f*d_f*p_amp;\n    s += vec2(0.0,1.0)*pops(max(0.0,d_t-3.0*delay))*d_f*d_f*d_f*p_amp;\n    s += vec2(1.0,0.0)*pops(max(0.0,d_t-4.0*delay))*d_f*d_f*d_f*d_f*p_amp;\n    \n    return vec2( s/3.0 );\n}\n\nvec2 granular(float t) {\n    vec2 o = vec2(0.0);\n    const int N = 2;\n    for (int i = 0; i < N; ++i) {\n        float rcpN = 1.0/float(N);\n        float n = float(i);\n        float hz = 20.0;\n        // cosines form a partition of unity\n        float amp = (cos(max(0.0,t*hz-n*rcpN)*2.0*pi+pi)*0.5+0.5)*2.0*rcpN;\n        float gtime = (floor(t*hz-n*rcpN)+n*rcpN)/hz;\n        float ltime = t - gtime;\n        float slodown = exp2(-t*0.01);\n        float pitchup = exp2(-t*0.005);\n        // slow music down while pitching sound up\n        o += granular_src(gtime*slodown + ltime/pitchup)*amp;\n    }\n    return o;\n}\n\n\nvec2 music( in int samp,float t) {\n    return granular(t);\n}","name":"Common","description":"","type":"common"}]}