{"ver":"0.1","info":{"id":"wljGzd","date":"1560821495","viewed":128,"name":"ray tracing sphere v4-color","username":"jorge2017a1","description":"ray tracing sphere v4-color","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["ray","sphere","color","tracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst vec4 u_WaveStrengthX=vec4(4.15,4.66,0.3016,0.1015);\nconst vec4 u_WaveStrengthY=vec4(2.54,6.33,0.20102,0.2025);\n\n\nvec2 OtroColor(vec2 uv) {\n    //float uTime = iTime * iMouse.x/iResolution.x;\n    float uTime = iTime ;\n    //float uTime = 1.0 ;\n    float noise = uTime + uv.x/0.5;\n    \n    \n    uv.y += (cos((uv.y + uTime * u_WaveStrengthY.y + u_WaveStrengthY.x * noise)) * u_WaveStrengthY.z) +\n        (cos((uv.y + uTime) * 10.0) * u_WaveStrengthY.w);\n\n    uv.x += (sin((uv.y + uTime * u_WaveStrengthX.y + u_WaveStrengthX.x * noise)) * u_WaveStrengthX.z) +\n        (sin((uv.y + uTime) * 15.0) * u_WaveStrengthX.w);\n    return uv;\n}\n\n\nfloat sphere(vec3 ray, vec3 dir, vec3 center, float radius)\n{\n\tvec3 rc = ray-center;\n\tfloat c = dot(rc, rc) - (radius*radius);\n\tfloat b = dot(dir, rc);\n\tfloat d = b*b - c;\n\tfloat t = -b - sqrt(abs(d));\n\tfloat st = step(0.0, min(t,d));\n\treturn mix(-1.0, t, st);\n}\n\nvec3 background(float t, vec3 rd)\n{\n\tvec3 light = normalize(vec3(sin(t), 0.6, cos(t)));\n\tfloat sun = max(0.0, dot(rd, light));\n    \n    \n    vec3 tmp3;\n    vec2 tmp2;\n    tmp2=vec2(rd.x, rd.y);\n    tmp2=OtroColor(tmp2);\n    tmp3=vec3(tmp2.x, tmp2.y, 1.0);\n    \n    \n    \n\tfloat sky = max(0.0, dot(rd, vec3(0.0, 1.0, 0.0)));\n    //float sky = max(0.0, dot(rd, tmp3));\n    \n    \n    \n\tfloat ground = max(0.0, -dot(rd, vec3(0.0, 1.0, 0.0)));\n\n    \n    \n\treturn \n\t\t(pow(sun, 256.0)+0.2*pow(sun, 2.0))*vec3(3.0, 2.6, 2.0) +\n\t\tpow(ground, 0.5)*vec3(0.5, 0.6, 0.2) +\n\t\tpow(sky, 1.0)*tmp3;\n}\n\n\nvec3 colorplaneta( vec2 fragCoord )\n{\n    vec2 uv;\n    //Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n    \n    //Equalize the aspect ratio\n    ///uv.y /= iResolution.x/iResolution.y;\n    uv=fragCoord;\n    \n    //Zoom out\n    uv *= 5.0;\n    \n    //Add distortion\n    for(float i = 1.0; i < 4.0; i+=1.0){ \n    \tuv.x += sin(iTime + uv.y * i);\n    \tuv.y += cos(iTime + uv.x * i);\n    }\n\n    //Time varying pixel colour\n    vec3 col = 0.5 + 0.5*cos(4.0*iTime + uv.xyx + vec3(0,2,4));\n\n    //Fragment colour\n    return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (-1.0 + 2.0*fragCoord.xy / iResolution.xy) * \n\t\tvec2(iResolution.x/iResolution.y, 1.0);\n    \n    \n\tvec3 ro = vec3(0.0, 0.0, -3.0);\n\tvec3 rd = normalize(vec3(uv, 1.0));\n\tvec3 p = vec3(0.0, 0.5, 0.0);\n\tfloat t = sphere(ro, rd, p, 1.25);\n\tvec3 nml = normalize(p - (ro+rd*t));\n    \n    \n\tvec3 bgCol = background(iTime, rd);\n\trd = reflect(rd, nml);\n    \n\t//vec3 col = background(iTime, rd) * vec3(0.9, 0.8, 1.0);\n    \n    \n    vec3 tmp3;\n    vec2 tmp2;\n    tmp2=vec2(uv.x, uv.y);\n    tmp3=colorplaneta(tmp2);\n    \n    vec3 col = background(iTime, rd) * tmp3;\n    \n    \n\tfragColor = vec4( mix(bgCol, col, step(0.0, t)), 1.0 );\n}\n\n\n","name":"Image","description":"","type":"image"}]}