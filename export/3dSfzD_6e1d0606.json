{"ver":"0.1","info":{"id":"3dSfzD","date":"1589757878","viewed":109,"name":"Ray Marching 1 KPH","username":"kpharri","description":"Copy of Art of Code's tutorial code.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nGeneral comments:\n\nEverything is vectors. Whenever a point is mentioned below, I actually mean a vector drawn \nfrom some location to that point. Distance between points is really just the difference\nbetween the two vectors representing those points, i.e. everything is vector addition or\nsubtraction, and dot and cross products can be used to obtain useful information.\n\n*/\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST 0.01\n\nfloat GetDist(vec3 p) {\n// Returns the shortest distance from point p to any of the shapes in the field.\n// This function also contains definitions of the shapes themselves. This is probably\n// not the best place for these...\n    \n\tvec4 s = vec4(0, 1, 6, 1); // Sphere parameters. First three are coords of center. Last\n                               // is radius. \n    \n    // Distance to sphere's surface is the distance between point p and the sphere's center,\n    // minus the radius of the sphere.\n    float sphereDist = length(p-s.xyz)-s.w; \n    \n    // We assume a horizontal plane in the x-z plane, so the distance from p to the plane\n    // is just the y-coord of p.\n    float planeDist = p.y;\n    \n    return min(sphereDist,planeDist);\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n// Marches along a ray with origin at ro and direction rd. Returns the\n// distance along the ray from ro to the first intersection with any shape in the view.\n    \n\tfloat dO = 0.; // Distance to origin from current point in the marching process.\n    \n    for (int i=0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO; // Point that's a distance dO along the ray.\n        float dS = GetDist(p); // Shortest distance from p to the object.\n        dO += dS; // Add the shortest distance to the ray location.\n        if (dO>MAX_DIST || dS<SURF_DIST) break; // Check for stopping conditions\n    }\n    return dO;\n}\n\n\nvec3 GetNormal(vec3 p) {\n// Finds the normal vector to the surface of the object at point p.\n    \n\tfloat d = GetDist(p); // Find the shortest distance to the object surface from point p.\n                          // This will not be exactly zero because of the error cushion built\n                          // into the ray marching algorithm.\n    vec2 e = vec2(0.01, 0); // Set up a perturbation vector.\n    vec3 n = d - vec3(    // This line of code hides quite a bit of clever geometry. Draw yourself\n        GetDist(p - e.xyy), // some diagrams in 2D, and do the necessary trig to convince yourself \n        GetDist(p - e.yxy), // that it is correct.\n        GetDist(p - e.yyx));\n    \n    return normalize(n);\n}\n\n\nfloat GetLight(vec3 p) {\n// Diffuse lighting and shadow function. \n    \n    vec3 lightPos = vec3(0, 5, 6); // Defines the position of the light source.\n    lightPos.xz += vec2(sin(iTime),cos(iTime))*2.; // Moves the light source in a horizontal circle.\n    vec3 l = normalize(lightPos-p); // Vector pointing from p to the light source.\n    vec3 n = GetNormal(p); // Unit vector normal to the object's surface.\n    \n    float dif = clamp(dot(n,l),0.,1.); // Brightness is set to the dot product between the surface\n                                       // normal and the ray pointing from the object to the light.\n                                       // clamp function ensures no brightnesses less than zero.\n    \n    float d = RayMarch(p+n*SURF_DIST*2., l); // Use ray marching to determine the distance from the\n                                             // the current point on the object to the light source.\n                                             // Use a location slightly offset from the current point\n                                             // else the ray marching algorithm will exit right away,\n                                             // because we're too close to the object.\n                                       \n    if (d < length(lightPos - p)) dif *= .1; // If the distance traveled by the ray marching algorithm\n                                             // from the the current point toward the light source is \n                                             // less than the full distance to the light, then we've\n                                             // encountered an object between us and the light, and we're\n                                             // therefore in shadow, so lower the brightness.    \n        \n    return dif; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    // Black screen:\n    vec3 col = vec3(0);\n    \n    // Camera:\n    vec3 ro = vec3(0, 1, 0);\n    \n    // Rays drawn from camera through each pixel of screen:\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    // Find the distance along each ray at which we bump into the first shape.\n    // Since rd is a vector of rays passing through the screen pixels, d is going\n    // to be a vector of distances.\n    float d = RayMarch(ro, rd);\n    \n    vec3 p = ro + rd*d;\n    float dif = GetLight(p);\n    col = vec3(dif);\n    \n    // The distances are all going to be greater than 1, given the location of ro and\n    // the shapes we've defined. This means that the color used to depict d will be\n    // white for all pixels, which is not very interesting. Therefore, divide d by 6\n    // to make d values smaller. We use 6 because that's how far away the sphere is.\n    //d /= 6.;\n    //col = vec3(d);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}