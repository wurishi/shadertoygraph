{"ver":"0.1","info":{"id":"dss3D2","date":"1668683912","viewed":61,"name":"Raymarching Study(LimSeungWoo)","username":"tmddn0326","description":"Procedural","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["procedural"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define T_MAX 10000.\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  vec3 transform = vec3(5, 1.5, 5);\n  p = abs(p - transform);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 transform = vec3(-2, 1.2, 4);\n  vec3 q = abs(p - transform) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n\nfloat sdCutHollowSphere( vec3 p, float r, float h, float t )\n{\n  vec3 transform = vec3(-4.0, 1.0, 0.0);\n  \n  float w = sqrt(r*r-h*h);\n  \n  vec2 q = vec2( length(p.xz - transform.xz), p.y - transform.y );\n  return ((h*q.x<w*q.y) ? length(q-vec2(w,h)) : \n                          abs(length(q)-r) ) - t;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    vec3 transform = vec3(4.0, 0.5, 0.0);\n    vec2 q = vec2(length(p.xz - transform.xz)-t.x, p.y - transform.y);\n    return length(q)-t.y;\n}\n\n\n\n\nfloat sdf(vec3 p, out int matid) // 오브젝트 계산\n{\n    // 구 : p와 구 중심까지의 거리 - 반지름\n    float sphere_sdf = length(p - vec3(0., 1., 0.)) - 1.0;\n    \n    // 도넛\n    vec2 t = vec2(1.5, 0.5);\n    float Torus_sdf = sdTorus(p, t) ; \n    \n    // 뚫린 구\n    float HollowSphere = sdCutHollowSphere(p, 1.0, 0.1, 0.05);\n    \n    \n    // 라운드 박스\n    vec3 b = vec3(1.0, 2.0, 1.0);\n    float RoundBox = sdRoundBox(p, b, 0.2);\n    \n    //정8면체\n    float Octahedron = sdOctahedron(p, 1.5);\n    \n    // 바닥 : 높이 0에 있는 무한한 바닥\n    float floor_sdf = clamp(p.y, 0.0, T_MAX);\n    \n    float sdf = min(sphere_sdf, floor_sdf);\n    sdf = min(sdf, Torus_sdf); \n    sdf = min(sdf, HollowSphere);\n    sdf = min(sdf, RoundBox);\n    sdf = min(sdf, Octahedron);\n    \n    \n    if(sdf == sphere_sdf) //머테리얼 구분\n    {\n    \n        matid = 1;\n    }\n    else\n    {\n        matid = 0;\n    }\n    \n    return sdf;\n}\n\n\nfloat intersect(vec3 ro, vec3 rd, out int matid)\n{\n    float t = 0.0;\n    \n    matid = -1;\n    \n    //Depth는 각 픽셀이 ro에서 떨어져있는 거리의 합\n    for(int i = 0; i < 256; i++)\n    {\n        int curr_matid = -1;\n        float d = sdf(ro + t*rd, curr_matid); // ray 길이\n        if(d < 0.0001)\n        {\n            matid = curr_matid;\n            break;\n        }\n        t += d;\n    }\n    return t;\n}\n\nvec3 GetPixelPos(vec3 ro, vec3 rd, float d)\n{\n    return ro + d*rd;\n}\n\nvec3 GetNormal(vec3 ro, vec3 rd)\n{\n    vec2 e = vec2(0.0001, 0.0); //미분 정확도(Floor 미분정확도가 떨어지면 노이즈 생김 ro에서 가까울수록 심하다)\n    int matid = -1;\n    float depth = intersect(ro, rd, matid);\n    vec3 PixelPos = GetPixelPos(ro, rd, depth);\n    float d = sdf(PixelPos, matid);\n    \n    vec3 N = vec3\n    (\n   d - vec3(\n    sdf(PixelPos-e.xyy, matid),\n    sdf(PixelPos-e.yxy, matid),\n    sdf(PixelPos-e.yyx, matid)\n    )\n    ); \n    return normalize(N);\n\n    return vec3(0,0,0);\n}\n\n\nfloat softshadow(in vec3 p, in vec3 l)\n{\n    float t = 0.15;\n    float t_max = T_MAX;\n    \n    float res = 1.0; //umbra\n    for(int i = 0; i < 256; i++)\n    {\n        if(t> t_max)\n        {\n        break;\n        }\n        \n        int ignored;\n        float d = sdf(p + t*l, ignored);\n        if(d < 0.001)\n        {\n            return 0.0;\n        }\n        t += d; //penumbra\n        res = min(res, 6.0 * d / t);\n    }\n\n    return res;\n}\n\nfloat SSAO(vec3 P , vec3 N)\n{\n    float e = 0.1;\n    float res = 0.0;\n    float weight = 0.5;\n    \n    int ignored;\n    \n#define AO_Sample 8\n    \n    for(int i = 1; i <= AO_Sample; i++)\n    {\n        float d = e * float(i);\n        res += weight * (1.0 - (d - sdf(P + d * N, ignored)));\n        weight *= 0.5;\n    }\n\n     \n    return clamp(res, 0., 1.);\n}\n\n\nvec3 RayCamera(vec3 ro, vec3 at, float zoom, vec2 uv)\n{\n    vec3 cam_z = normalize(at- ro); //카메라 z 방향\n    vec3 cam_x = normalize(cross(vec3(0,1,0), cam_z)); // 카메라 x방향 : vector cross하면 90도 회전함(x축은 rotation 하지 않기때문에 이렇게 구한다)\n    vec3 cam_y = cross(cam_z, cam_x); // 카메라 y방향 : 위에서 구한 x, z 값의 90도 방향\n\n    vec3 rd = normalize(uv.x * cam_x + uv.y * cam_y + zoom*cam_z); //RayDirection\n    \n    return rd;\n}\n\nvec3 Rendering(vec3 ro, vec3 rd) // 최종 렌더링\n{\n    vec3 color = vec3(0, 0, 0);\n    \n    int matid = 1;\n    float depth = intersect(ro, rd, matid); // Depth 구하기\n\n    if(matid != -1) // 머테리얼 색깔 나누기\n    {\n        if(matid == 0)\n        {\n            color = vec3(1);\n        }\n        else\n        {\n            color = vec3(1,0,0);\n        }\n    }\n    \n    // 노말계산\n    vec3 PixelPos = GetPixelPos(ro,rd,depth);\n    vec3 N = GetNormal(ro, rd);\n    \n    //라이트 계산\n    vec3 L = vec3(sin(iTime)*5., 8, cos(iTime)*5.);\n    vec3 LV = normalize(L-PixelPos);\n    vec3 light_intensity = vec3(1);\n    float Shade = (dot(LV, N) + 1.0) * 0.5;\n        \n    //쉐도우 계산\n    float shadow = softshadow(PixelPos, LV);\n    shadow = max(0.5, shadow);\n    \n    //최종 라이트\n    vec3 Direct_Light = shadow * light_intensity * Shade;\n    float AO = SSAO(PixelPos, N);\n    AO = pow(AO, 5.);\n    \n    \n    vec3 Albedo = vec3(0.9);\n    \n    color = Albedo * Direct_Light * AO;\n    \n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //화면 중심을 0,0으로 이동\n    vec2 uv = 2.0 * fragCoord / iResolution.xy - 1.0; // UV 정사각형으로 변환, 화면 가운데를 0,0으로\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 color = vec3(0, 0, 0);\n    \n    \n    // 카메라 구성요소\n    vec3 ro = vec3(cos(iTime*0.5)*12.0, 5, sin(iTime*0.5)*12.0); //Ray기준점, 카메라위치, w 줌\n    vec3 at = vec3(0, 0, 0);\n    float zoom = 1.73;\n    \n    vec3 rd = RayCamera(ro, at, zoom, uv);\n    \n    color = Rendering(ro, rd); // 최종 렌더링\n\n    fragColor = vec4(color, 1.0); \n}","name":"Image","description":"","type":"image"}]}