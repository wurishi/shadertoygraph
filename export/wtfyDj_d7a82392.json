{"ver":"0.1","info":{"id":"wtfyDj","date":"1634610459","viewed":208,"name":"Preconvolved lightmap test","username":"KylBlz","description":"WASD, Shift, Space, arrow keys. Playing around with light map convolution, buffer B samples the environment map, buffer C samples the inside of the sphere. Move the camera around to the back of the ball to see the magenta transmitted light","likes":8,"published":1,"flags":48,"usePreview":0,"tags":["light","map","cosine","convolved"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nmat3 ImageBasedLighting(in ray r, in hit h) {\n    // approx reflectivity using IOR and angle\n    float f = Schlick(materials[r.m].ior, materials[obj2mat[h.o]].ior, dot(-r.d, h.n));\n    // reflection vector\n    vec3 rfl = normalize(reflect(r.d, h.n));\n    // get colors\n    vec3 diff = textureLod(iChannel1, rap(-h.n), 1.33).rgb,\n         spec = srgb_linear(textureLod(iChannel3, rfl, 0.3).rgb);\n    // artificial light specular\n    spec += pow(max(0., 1.025*dot(rfl, normalize(lit1.l))), 64.) * vec3(80., 30., 10.);\n    // sd ao\n    float smpd = sdSmp(h.l, h.o).d + 0.1;\n    float ao = min(1., 4. * smpd * smpd );\n\t// just return the colors\n    return mat3(\n        diff * (1. - f),\n        spec * f,\n        vec3(f, ao, 0.)\n    );\n}\n\nvec3 shade(in ray r, in hit h) {\n    // shading\n    vec3 col = v30;\n    if (h.o > 0) {\n        // calculate diffuse[0] and specular[1]\n\t    mat3 res = ImageBasedLighting(r, h);\n        // take AO away from both diffuse and specular\n        res[0] *= res[2].y;\n        res[1] *= res[2].y;\n\n        if (h.o == _pln1) {\n            // get transmission color\n            vec3 nn = normalize(h.l - sph1.l);\n            vec3 t = textureLod(iChannel2, rap(nn), 1.33).rgb;\n            // mul by surface color \n            vec2 a = map(h.l, sph1) * vec2(6., 1.);\n            int ind = int(floor(a.x) * step(a.y, 0.9) * step(0.1, a.y));\n            // surface color\n            col = srgb_linear(textureLod(iChannel3, normalize(-h.n + h.l), 0.).rgb);\n            // emission from beach ball bound by AO\n            res[0] += t * ballColors[ind] * (1. - res[2].y);\n\t\t\t// surface reflection strength\n            res[1] *= col.r;\n            // soft shadows\n            float rosa = ROSA(h.l, lit1, sph1);\n            // final color\n            col = col * res[0] * (rosa * 0.75 + 0.25) + res[1] * rosa;\n        } else if (h.o == _sph1) {\n            // ball color\n            vec2 a = map(h.l, sph1) * vec2(6., 1.);\n            int ind = int(floor(a.x) * step(a.y, 0.9) * step(0.1, a.y));\n            // transmission color\n            vec3 t = textureLod(iChannel2, rap(h.n), 1.33).rgb * 0.5;\n            // final color\n\t        col = ballColors[ind] * (res[0] + t) + res[1];\n        } else {\n            // final color\n\t        col = res[0] + res[1];\n        }\n    } else {\n        col = 0.25 * srgb_linear(textureLod(iChannel3, r.d, 0.).rgb) + step(0.99, dot(r.d, normalize(lit1.l)));\n    }\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // pixel coordinates accounting for aspect\n    float aspect = iResolution.y / iResolution.x;\n    vec2 iiResolution = 1./iResolution.xy;\n    vec2 uv = fragCoord * iiResolution;\n    //get input\n\tvec3 l = textureLod(iChannel0, POS * iiResolution, 0.).xyz,\n\t\t o = textureLod(iChannel0, ROT * iiResolution, 0.).xyz,\n\t\t d = rotateXY(normalize(vec3((uv * 2. - 1.) * vec2(1., aspect), 1.5)), o.xy),\n         col = vec3(0.),\n         up, rt;\n    // ortho\n    basis(d, up, rt);\n    // rotate 30 deg\n    up *= iiResolution.x * 0.8;\n    rt *= iiResolution.x * 0.8;\n    up += rt * 0.25;\n    rt -= up * 0.25;\n    vec3[4] smp = vec3[4] (up, -up, rt, -rt);\n    for (int i = 0; i < 4; i++) {\n        // camera\n        vec3 ro = l;\n        vec3 rd = normalize(d + smp[i]);\n        // raytrace scene\n        ray r = ray(ro, rd, v31, _air);\n        hit h = scene(r);\n        // shading\n        col += shade(r, h);\n    }\n    // tone mapping\n    col = ACESFitted(pow(col * EXPOSURE, vec3(GAMMA)) * BRIGHTNESS);\n   \tfragColor = vec4(col, 1.);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// color settings\n#define GAMMA\t\t0.45\n#define EXPOSURE\t2.0\n#define BRIGHTNESS\t1.0\n// geometry settings\n#define SD_SAMPLES\t255\n\n// Some shortcuts\n#define v20 vec2(0.)\n#define v21 vec2(1.)\n#define v30 vec3(0.)\n#define v31 vec3(1.)\n#define v40 vec4(0.)\n#define v41 vec4(1.)\n// trick by klems\n#define ZERO (min(iFrame,0))\n\nconst float\teps = .0001, ieps = .9999, sml = .001, isml = .999, zfar = 25.,\n\t\t\tpi_rcp = .3183098, pi2_rcp = .1591549, pi4_rcp = .0795775,\n    \t\tpi_5 = 1.5707963, pi = 3.1415926, pi2 = 6.2831853, pi4 = 12.56637,\n\t\t\tsc45 = .7071067, s60 = .866025, sqrt2 = 1.4142135, sqrt3 = 1.732050808;\nconst vec2\tVEL = vec2(0.5), POS = vec2(1.5, 0.5), ROT = vec2(2.5, 0.5), MOU = vec2(3.5, 0.5);\n\n//Reflect, Transmit, Emit rgb wavelengths, Surface scatter, sUbsurface scatter, refractive index, Emission Uniformity, iDentifier\nstruct mat { vec3 r, t, e; float s, u, ior, eu; int d; };\n//Location, Normal, segment, Object identifier\nstruct hit { vec3 l, n; float t; int o; };\n//Origin, Direction, Color, current Material\nstruct ray { vec3 o, d, c; int m; };\n//Distance, Object identifier\nstruct sdf { float d; int o; };\n\nconst mat nullMat = mat(v30, v31, v30, 0., 0., 0., 0., -1);\nconst hit nullHit = hit(v30, v30, zfar, -1);\nconst sdf nullSdf = sdf(zfar, -1);\n\n//center Location, Radius, iDentifier\nstruct sph { vec3 l; float r; int d; };\n//Location, Normal, size, iDentifier\nstruct pln { vec3 l; mat3 o; int d; };\n\n// common functions\nfloat hash12( in vec2 p ) {\n\tfloat h = dot(p,vec2(101.7, 683.11));\n    return fract(sin(h)*467.709);\n}\nfloat hash13( in vec3 p ) {\n\tfloat h = dot(p,vec3(571.127, 467.311, 881.521));\n    return fract(sin(h)*467.197);\n}\nvec2 hash22( in vec2 p ) {\n\tvec2 h = vec2(dot(p,vec2(467.127, 881.311)),\n                  dot(p,vec2(7.101, 11.683)));\n    return fract(sin(h)*467.281);\n}\nvec3 hash33( in vec3 p ) {\n\tvec3 h = vec3(dot(p,vec3(467.127, 881.311, 571.521)),\n                  dot(p,vec3(7.101, 11.683, 13.331)),\n                  dot(p,vec3(683.331, 761.101, 823.127)));\n    return fract(sin(h)*467.281);\n}\nvec2 rap(in vec3 n) {\n    vec3 _n = n * 0.999;\n    return vec2(atan(_n.z, _n.x) + pi, acos(-_n.y)) / vec2(pi2, pi);\n}\nvec3 rotateXY(in vec3 p, in vec2 angle) {\n\tvec2 c = cos(angle), s = sin(angle); vec3 o = p;\n\to.yz *= mat2(c.x, s.x, -s.x, c.x); \n    o.xz *= mat2(c.y, s.y, -s.y, c.y);\n\treturn o;\n}\nvec3 rap(in vec2 ap) {\n    vec2 t = ap * vec2(pi2, -pi);\n    return -rotateXY(vec3(0., 1., 0.), t.yx).zyx;\n}\nvoid basis(in vec3 n, out vec3 f, out vec3 r) {\n    float a = 1. / (1. + n.z);\n    float b = -n.x*n.y*a;\n    f = vec3(1. - n.x*n.x*a, b, -n.x);\n    r = vec3(b, 1. - n.y*n.y*a, -n.y);\n}\nvec3 slerp(in vec3 start, in vec3 end, in float percent) {\n\tfloat dt = dot(start, end),\n        theta = acos(dt)*percent;\n\treturn start*cos(theta) + normalize(end - start*dt)*sin(theta);\n}\nfloat Schlick(in float r1, in float r2, in float vn) {\n\tfloat r0 = (r1 - r2) / (r1 + r2);\n\treturn mix(r0*r0, 1., pow(1. - vn, 5.));\n}\n// Thanks Paniq\nvec3 linear_srgb(vec3 x) {\n    return mix(1.055*pow(x, vec3(1./2.4)) - 0.055, 12.92*x, step(x,vec3(0.0031308)));\n}\nvec3 srgb_linear(vec3 x) {\n    return mix(pow((x + 0.055)/1.055,vec3(2.4)), x / 12.92, step(x,vec3(0.04045)));\n}\n// Paniq's ACES fitted from https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\nvec3 ACESFitted(vec3 color) {\n\t// ODT_SAT => XYZ => D60_2_D65 => sRGB\n    color = color * mat3(\n        0.59719, 0.35458, 0.04823,\n        0.07600, 0.90834, 0.01566,\n        0.02840, 0.13383, 0.83777\n    );\n    // Apply RRT and ODT\n    vec3 a = color * (color + 0.0245786) - 0.000090537;\n    vec3 b = color * (0.983729 * color + 0.4329510) + 0.238081;\n    color = a / b;\n\t// Back to color space\n    color = color * mat3(\n         1.60475, -0.53108, -0.07367,\n        -0.10208,  1.10813, -0.00605,\n        -0.00327, -0.07276,  1.07602\n    );\n    // Clamp to [0, 1]\n    return clamp(color, 0.0, 1.0);\n}\n//linear angle of sphere at distance D with radius R\nfloat linearAngle(float d, float r) {\n    return min(pi_5, abs(asin(r/d)));\n}\nfloat ROSA(in vec3 l, in sph lit, in sph occ) {\n    vec3 lv = lit.l - l,\n         ov = occ.l - l;\n    float ld = sqrt(dot(lv, lv)),\n          od = sqrt(dot(ov, ov)),\n          sal = linearAngle(ld, lit.r),\n          sao = linearAngle(od, occ.r),\n          fsa = sal;\n    if (od < ld) {\n        float theta = acos(dot(lv / ld, ov / od));\n\t    fsa *= 1. - clamp((sao - theta) / sal, 0., 1.);\n    }\n    fsa /= sal;\n    return fsa * fsa;\n}\n// thanks Reinder\nvec3 cosWeightedHemisphereDirection( const vec3 n, in vec2 r) {\n\tvec3  uu = normalize(cross(n, vec3(0.,1.,0.)));\n\tvec3  vv = cross(uu, n);\n\tfloat ra = sqrt(r.y);\n\tfloat rx = ra*cos(6.2831*r.x); \n\tfloat ry = ra*sin(6.2831*r.x);\n\tfloat rz = sqrt( abs(1.0-r.y) );\n\tvec3  rr = vec3( rx*uu + ry*vv + rz*n );\n    return normalize(rr);\n}\n\n// Signed distance operators (thanks IQ)\n#define sdIntersect(l, r) max(d1, d2)\n#define sdUnion(l, r) min(l, r)\n#define sdDiff(l, r) max(-l, r)\nvoid lt(inout sdf l, in sdf r) {\n    if (r.d < l.d)\n        l = r;\n}\n\nsdf sd(in vec3 l, in sph s) {\n    return sdf(length(l - s.l) - s.r, s.d);\n}\nsdf sd(in vec3 l, in pln p) {\n    return sdf(dot(p.o[1], l - p.l), p.d);\n}\n\n// Normal functions\nvec3 nrm(in vec3 l, in sph s) {\n    return (l - s.l) / s.r;   \n}\nvec3 nrm(in vec3 l, in pln p) {\n    return p.o[1];\n}\n\n// UV map functions\nvec2 map(in vec3 l, in sph s) {\n    vec3 n = nrm(l, s);\n    return rap(n);\n}\nvec2 map(in vec3 l, in pln p) {\n    return vec2(dot(l, p.o[0]), dot(l, p.o[2]));\n}\n\n// Hit functions\nvoid lt(inout hit o, in hit h) {\n    if (h.t < o.t && h.t > 0.)\n        o = h; \n}\n\n//////////////////////////////////////////////// 3D scene ////////////////////////////////////////////////\n\n// Geometry (start at 1, -1 means undefined)\nconst int _lit1 = 1, _sph1 = 2, _pln1 = 3;\nsph lit1 = sph(vec3(-200., 80., 60.), 50., _lit1),\n    sph1 = sph(vec3(0., -.5, 0.), .5, _sph1);\npln pln1 = pln(vec3(0., -1., 0.), mat3(1.), _pln1);\n\n// Materials (start at 0, -1 means undefined)\nconst int _air = 0, _wht_e = 1, _wht = 2, _flr = 3;\nconst mat[] materials = mat[] (\n    mat(v30, v31, v30, .01, .01, 1.0003, 0., _air),\n\tmat(v31, v30, vec3(256.), 1., 1., 2., 0., _wht_e),\n    mat(vec3(.5,.5,.5), v30, v30, .66, 0., 1.33, 0., _wht),\n    mat(vec3(.5,.5,.5), v30, v30, .66, 0., 1.99, 0., _flr)\n);\n// Object ID to material index\nconst int[] obj2mat = int[] (\n    _air,\n    _wht_e,\n    _wht,\n    _flr\n);\n\n// IBL settings\nconst float IBL_samples = 10.;\nconst float IBL_smp = 1./IBL_samples;\nconst float IBL_smp2 = 1./(IBL_samples*IBL_samples);\n// beach ball colors\nconst vec3[] ballColors = vec3[] (\n    vec3(0.3), vec3(0.01, 0.33, 0.33),\n    vec3(0.3), vec3(0.33, 0.33, 0.01),\n    vec3(0.3), vec3(0.33, 0.01, 0.33)\n);\n\n// SD scene contents\nsdf sdSmp(in vec3 l) {\n\tsdf d = nullSdf;\n    lt(d, sd(l, sph1));\n    lt(d, sd(l, pln1));\n\treturn d;\n}\n// whole scene except o\nsdf sdSmp(in vec3 l, in int o) {\n    sdf d = nullSdf;\n    if (o != _sph1) lt(d, sd(l, sph1));\n    if (o != _pln1) lt(d, sd(l, pln1));\n\treturn d;\n}\n\nvec3 sdNrm(in vec3 l) {\n\tvec2 s = vec2(0, sml);\n    float d = sdSmp(l).d;\n    return normalize( d - vec3(\n        sdSmp(l - s.yxx).d,\n        sdSmp(l - s.xyx).d,\n        sdSmp(l - s.xxy).d\n    ));\n}\n\nhit sdScene(in ray r, in float end) {\n    vec3 l = r.o;\n    float t = 0.;\n    sdf d = nullSdf;\n    for (int i = 0; i < SD_SAMPLES; ++i) {\n        d = sdSmp(l);\n        if (d.d < sml)\n            return hit(l, sdNrm(l), t, d.o);\n        t += d.d;\n        if (t > end)\n            return nullHit;\n        l = r.o + r.d * t;\n    }\n    return nullHit;\n}\n\nhit scene(in ray r) {\n    hit ret = nullHit;\n    lt(ret, sdScene(r, ret.t));\n\treturn ret;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// controls\n\n#define tex(a,b) textureLod(a,b,0.)\n\n#define MAX_ACCELERATION      4.\n#define MAX_VELOCITY          4.\n#define FRICTION              2.\n\n#define VALUE_VELOCITY        0\n#define VALUE_POSITION        1\n#define VALUE_ROTATION        2\n#define VALUE_MOUSE           3\n\n//controls\nconst vec2 KEY_W \t = vec2(87.5 / 256., 0.),\n    \t   KEY_S \t = vec2(83.5 / 256., 0.),\n    \t   KEY_A \t = vec2(65.5 / 256., 0.),\n    \t   KEY_D \t = vec2(68.5 / 256., 0.),\n\t\t   KEY_LEFT  = vec2(37.5 / 256., 0.),\n\t\t   KEY_UP    = vec2(38.5 / 256., 0.),\n\t\t   KEY_RIGHT = vec2(39.5 / 256., 0.),\n\t\t   KEY_DOWN  = vec2(40.5 / 256., 0.),\n    \t   KEY_SHIFT = vec2(16.0 / 256., 0.),\n    \t   KEY_SPACE = vec2(32.0 / 256., 0.);\n\nconst vec4 INIT_POS = vec4(-4.4, 1.5, -4.4, 0.),\n    \t   INIT_VEL = vec4(0., 0., 0., 0.),\n    \t   INIT_ROT = vec4(-.3, .75, 0., 0.),\n    \t   INIT_MOU = vec4(0.);\n\nvec3 vRotateY(vec3 p, float angle) {\n    float c = cos(angle), s = sin(angle);\n    return vec3(c*p.x + s*p.z, p.y, -s*p.x + c*p.z);\n}\n\nvec3 getAcceleration() {\n    return vec3(\n        tex(iChannel1, KEY_D).x - tex(iChannel1, KEY_A).x + tex(iChannel1, KEY_RIGHT).x - tex(iChannel1, KEY_LEFT).x,\n        tex(iChannel1, KEY_SPACE).x - tex(iChannel1, KEY_SHIFT).x,\n        tex(iChannel1, KEY_W).x - tex(iChannel1, KEY_S).x + tex(iChannel1, KEY_UP).x - tex(iChannel1, KEY_DOWN).x\n    );\n}\n\nvec4 getValue(int a) {\n    vec2 q = vec2(float(a) + 0.5, 0.0) / iResolution.x;\n    return tex(iChannel0, q);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    if (fragCoord.y > 1.)\n        discard;\n    \n    int a = int(fragCoord.x);\n    float q = fragCoord.x / iResolution.x;\n    vec4 value = tex(iChannel0, vec2(q, 0.));\n    \n    //set initial values\n    if (iFrame == 0) {\n        if (a == VALUE_ROTATION) {\n            value = INIT_ROT;\n        } else if (a == VALUE_MOUSE) {\n            value = INIT_ROT;\n        } else if (a == VALUE_VELOCITY) {\n            value = INIT_VEL;\n        } else if (a == VALUE_POSITION) {\n            value = INIT_POS;\n        }    \n    } else if (a == VALUE_ROTATION && iMouse.z > 0.) {\n        vec4 mouse = 2.0 * abs(iMouse) / iResolution.y;\n        vec4 rot = getValue(VALUE_MOUSE);\n      \tvalue.y = mouse.x - mouse.z + rot.y;\n      \tvalue.x = clamp(mouse.y - mouse.w + rot.x, -pi_5, pi_5);\n        \n    } else if (a == VALUE_MOUSE && iMouse.z < 0.) {\n        value = getValue(VALUE_ROTATION);\n        \n    } else if (a == VALUE_VELOCITY) {\n        float rot = getValue(VALUE_ROTATION).y;\n        vec3 acc = vRotateY(getAcceleration(), rot);\n        value.xyz += acc * MAX_ACCELERATION * iTimeDelta;\n        float speed = length(value.xyz);\n        //limit speed\n        if (speed > MAX_VELOCITY) {\n            value.xyz *= MAX_VELOCITY / speed;\n        } else if (speed > FRICTION * iTimeDelta) {\n            value.xyz *= (speed - FRICTION * iTimeDelta) / speed;\n        } else {\n            value.xyz = vec3(0.0, 0.0, 0.0);\n        }\n    } else if (a == VALUE_POSITION) {\n        vec3 velocity = getValue(VALUE_VELOCITY).xyz;\n        value.xyz += velocity * iTimeDelta;\n        //collision detection?\n        value.y = max(value.y, -.95);\n    }\n    \n    fragColor = vec4(value);\n    return;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// render diffuse cosine weighted cubemap\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // write image size\n    if (ivec2(fragCoord.xy) == ivec2(0)) {\n\t    fragColor = vec4(iResolution.xy, iChannelResolution[1].xy);\n\t    return;\n    }\n    \n    // get image size\n    vec4 wh = texelFetch(iChannel0, ivec2(0), 0);\n    \n    // no change in resolution and iChannel size?\n    if (wh == vec4(iResolution.xy, iChannelResolution[1].xy)) {\n    \tfragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        return;\n    }\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    // back to normal\n    vec3 rayDir = -rap(uv);\n    vec3 col = vec3(0.);\n    for (float i = float(ZERO); i < 1.; i += IBL_smp) {\n        for (float j = float(ZERO); j < 1.; j += IBL_smp) {\n            // sample cosine weighted hemisphere\n            vec3 smp = cosWeightedHemisphereDirection(rayDir, vec2(i, j));\n            col += srgb_linear(textureLod(iChannel1, smp, 2.6).rgb);\n        }\n    }\n    \n    // add more sunlight\n    col += max(0., dot(rayDir, normalize(lit1.l))) * vec3(500., 200., 100.);\n    \n\t// normalize distribution\n    fragColor = vec4(col * IBL_smp2, 1.);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// inside sphere of beach ball\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // write image size\n    if (ivec2(fragCoord.xy) == ivec2(0)) {\n\t    fragColor = vec4(iResolution.xy, iChannelResolution[1].xy);\n\t    return;\n    }\n    \n    // get image size\n    vec4 wh = texelFetch(iChannel0, ivec2(0), 0);\n    \n    // no change in resolution and iChannel size?\n    if (wh == vec4(iResolution.xy, iChannelResolution[1].xy)) {\n    \tfragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        return;\n    }\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    // back to normal\n    vec3 rayDir = -rap(uv);\n    vec3 col = vec3(0.);\n    for (float i = float(ZERO); i < 1.; i += IBL_smp) {\n        for (float j = float(ZERO); j < 1.; j += IBL_smp) {\n            // sample cosine weighted colors inside sphere\n            vec3 smp = cosWeightedHemisphereDirection(rayDir, vec2(i, j));\n            // get ball color where sampling\n            vec2 smpUV = rap(smp) * vec2(6., 1.);\n    \t\tint ind = int(floor(smpUV.x) * step(smpUV.y, 0.9) * step(0.1, smpUV.y));\n            // assume perfect transmissoin (we'll have our fresnel later)\n            col += ballColors[ind] * srgb_linear(textureLod(iChannel1, smp, 2.6).rgb);\n        }\n    }\n\t// normalize distribution\n    fragColor = vec4(col * IBL_smp2, 1.);\n}\n","name":"Buffer C","description":"","type":"buffer"}]}