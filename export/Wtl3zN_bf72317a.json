{"ver":"0.1","info":{"id":"Wtl3zN","date":"1555803071","viewed":570,"name":"Raymarching Shapes","username":"batman","description":"This is my first cube and first positioning in raymarching. Second time I coded it, making progress as I got this result in 40min.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["basic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ITERATIONS 1000\n#define MIN_D 0.0001\n#define MAX_D 30.\n\n// collection of distances to each object.\nfloat distS[10];\n\n// adapted from http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\nvec3 rotation(vec3 point, vec3 axis, float angle){\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    mat4 rot= mat4(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,0.0,0.0,1.0);\n    return (rot*vec4(point,1.)).xyz;\n}\n\n/*\n Collection of signed distance functions.\n\n*/\n// signed distance to a sphere\nfloat sdSphere( vec3 p, float r) {\n \treturn length(p) -r;   \n}\n\n// signed distance to the plan y=0\nfloat sdPlan(vec3 p) {\n    return abs(p.y);\n}\n\n// signed distance to a cube of dimension b\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0));\n}\n\n// compute distance to each object and returns the minimum (aka the distance to each object)\nfloat sdScene(vec3 pos) {\n    vec3 cubePos = rotation(pos - vec3(0.,1.,-3.5), vec3(0.,.5,0.5), iTime);\n    distS[0] = sdSphere(pos-vec3(.5,.5,-5.), 1.);\n    distS[1] = sdPlan(pos);\n    distS[2] = sdBox(cubePos, vec3(.5,.6,.5));\n    distS[3] = sdBox(pos - vec3(2.,0.,-3.), vec3(.5,.6,.5));\n    int oid = 0;\n    float d = distS[0];\n    for(int i=1;i<=3;i++) {\n        if(distS[i] < d) {\n          oid = i;\n          d = distS[i];\n        }\n    }\n\treturn d;\n}\n\n// raymarch algorithm\nfloat rayMarch(vec3 ro, vec3 rd) {\n\tvec3 pos = ro;\n    float inc = 0.;\n    float d = 0.;\n    for(int i=0;i<ITERATIONS;i++) {\n    \tpos = ro + d*rd;\n        inc = sdScene(pos);\n        d += inc;\n        if(inc < MIN_D || d > MAX_D) break;\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -=0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    // basic cam\n    vec3 camPos = vec3(0.,1.,0.);\n    vec3 ro = camPos + vec3(0.,0.,1.);\n    vec3 rd = normalize(camPos+ vec3(uv, 0.) - ro);\n    \n    float d = rayMarch(ro, rd);\n    // here I only display the distance, not trying to shade with normal and light vectors.\n    vec3 col = vec3(smoothstep(MAX_D,0.,pow(d-1.,2.)));\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}