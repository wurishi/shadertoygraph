{"ver":"0.1","info":{"id":"ttVGDW","date":"1579002510","viewed":123,"name":"automata_4 (Byl loop)","username":"balkhan","description":"Another replicator :) \n\nusing this site for transition rule : http://cafaq.com/apps/index.php","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["automata","replication","selfreplication","bylloop"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define S3(A) vec3(sin(A+0.00),sin(A+1.04),sin(A+2.08))\n\n#define ZOOM_FACTOR 5.\n#define Z 1./(ZOOM_FACTOR)\n\nvoid mainImage(out vec4 O, in vec2 u)\n{\n\tO = (t0(Z*u/R).xxxx);\n    O.xyz = S3(O.x*8.);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n// So I don't really want to explain myself about these 2 defines\n// Let's just say it tidy things up a bit and I like it\n#define K vec2\n#define V vec4\n\nvoid  rotate(inout vec4 p)\n{\n    p = p.wxyz;\n    // p.abcd, p.dabc p.cdab p.bcda p.abcd\n    // it works\n}\n\nfloat rule_state_0(K u, float curr)\n{\n    float next_state = curr;\n    \n    float n,e,s,w;\n    \n    n = t0((u+K(+0.0, +1.0))/R).x;\n    e = t0((u+K(+1.0, +0.0))/R).x;\n    s = t0((u+K(+0.0, -1.0))/R).x;\n    w = t0((u+K(-1.0, +0.0))/R).x;\n    \n    vec4 neigh = vec4(n,e,s,w);\n    for(float k = .0; k < 4.; k++)\n    {\n    if (\n    V(0.,0.,3.,3) == neigh ||\nV(0.,0.,3.,5) == neigh ||\nV(0.,0.,4.,4) == neigh ||\nV(0.,0.,4.,5) == neigh ||\nV(0.,0.,5.,0) == neigh ||\nV(0.,1.,4.,4) == neigh ||\nV(0.,2.,3.,5) == neigh ||\nV(0.,3.,1.,0) == neigh ||\nV(0.,3.,3.,5) == neigh ||\nV(0.,3.,4.,3) == neigh ||\nV(0.,3.,4.,5) == neigh ||\nV(0.,4.,0.,5) == neigh ||\nV(0.,4.,1.,0) == neigh ||\nV(0.,4.,1.,5) == neigh ||\nV(0.,4.,3.,5) == neigh ||\nV(0.,5.,0.,1) == neigh ||\nV(0.,5.,0.,2) == neigh ||\nV(0.,5.,0.,3) == neigh ||\nV(0.,5.,0.,5) == neigh ||\nV(0.,5.,1.,5) == neigh ||\nV(0.,5.,2.,0) == neigh ||\nV(0.,5.,2.,5) == neigh ||\nV(0.,5.,5.,0) == neigh ||\nV(0.,5.,5.,2) == neigh ||\nV(0.,5.,5.,5) == neigh ||\nV(1.,0.,0.,0) == neigh ||\nV(2.,0.,0.,0) == neigh ||\nV(2.,0.,2.,0) == neigh ||\nV(3.,0.,1.,0) == neigh ||\nV(3.,0.,3.,0) == neigh\n    )\n    \t{\n\t        next_state = 0.;\n            break;\n        }\n    else if (\nV(5.,0.,0.,2) == neigh ||\nV(0.,3.,4.,0) == neigh\n        )\n    \t{\n            next_state = 2.;\n            break;\n        }\n    else if (\nV(0.,0.,4.,3) == neigh ||\nV(0.,0.,0.,4) == neigh\n        )\n    \t{\n\t\t\tnext_state = 3.;\n            break;\n        }\n    else if (\nV(0.,0.,5.,4) == neigh\n        )\n    \t{\n\t\t\tnext_state = 4.;\n            break;\n        }\n    else if (\nV(0.,0.,5.,1) == neigh ||\nV(3.,0.,0.,2) == neigh ||\nV(3.,0.,0.,5) == neigh\n    )\n    \t{\n\t\t\tnext_state = 5.;\n            break;\n        }\n        \n        \n\t    rotate(neigh);\n\t}\n    return next_state;\n}\n\nfloat rule_state_1(K u, float curr)\n{\n    float next_state = curr;\n    \n    float n,e,s,w;\n    \n    n = t0((u+K(+0.0, +1.0))/R).x;\n    e = t0((u+K(+1.0, +0.0))/R).x;\n    s = t0((u+K(+0.0, -1.0))/R).x;\n    w = t0((u+K(-1.0, +0.0))/R).x;\n    \n    vec4 neigh = vec4(n,e,s,w);\n    for(float k = .0; k < 4.; k++)\n    {\n    if (\nV(2.,5.,0.,5) == neigh\n    )\n    \t{\n\t        next_state = 0.;\n            break;\n        }\n    else if (\nV(1.,5.,0.,5) == neigh ||\nV(3.,5.,0.,5) == neigh ||\nV(4.,5.,0.,5) == neigh\n    )\n    {\n        next_state = 1.;\n        break;\n    }\n    else if (\nV(0.,2.,5.,4) == neigh\n    )\n    {\n        next_state = 2.;\n        break;\n    }\n    else if (\nV(0.,0.,5.,4) == neigh ||\nV(0.,3.,5.,4) == neigh ||\nV(3.,2.,5.,4) == neigh ||\nV(3.,3.,5.,4) == neigh ||\nV(3.,5.,2.,4) == neigh ||\nV(5.,3.,1.,4) == neigh ||\nV(5.,5.,4.,3) == neigh\n    )\n    {\n        next_state = 4.;\n        break;\n    }\n    rotate(neigh);\n\t}\n    return next_state;\n}\n\nfloat rule_state_2(K u, float curr)\n{\n    float next_state = curr;\n    \n    float n,e,s,w;\n    \n    n = t0((u+K(+0.0, +1.0))/R).x;\n    e = t0((u+K(+1.0, +0.0))/R).x;\n    s = t0((u+K(+0.0, -1.0))/R).x;\n    w = t0((u+K(-1.0, +0.0))/R).x;\n    \n    vec4 neigh = vec4(n,e,s,w);\n    for(float k = .0; k < 4.; k++)\n    {\n    if (\nV(0.,5.,5.,4) == neigh ||\nV(5.,5.,0.,5) == neigh\n    )\n    \t{\n\t        next_state = 0.;\n            break;\n        }\n    else if (\nV(3.,5.,0.,5) == neigh\n\t)\n    {\n        next_state = 1.;\n        break;\n    }\n    else if (\nV(4.,0.,0.,5) == neigh ||\nV(5.,0.,0.,5) == neigh\n    )\n    {\n        next_state = 2.;\n        break;\n    }\n    else if (\nV(0.,3.,4.,0) == neigh ||\nV(1.,0.,0.,5) == neigh ||\nV(1.,5.,0.,0) == neigh ||\nV(5.,0.,1.,1) == neigh ||\nV(5.,4.,5.,1) == neigh\n    )\n    {\n        next_state = 5.;\n        break;\n    }\n    rotate(neigh);\n\t}\n    return next_state;\n}\n\nfloat rule_state_3(K u, float curr)\n{\n    float next_state = curr;\n    \n    float n,e,s,w;\n    \n    n = t0((u+K(+0.0, +1.0))/R).x;\n    e = t0((u+K(+1.0, +0.0))/R).x;\n    s = t0((u+K(+0.0, -1.0))/R).x;\n    w = t0((u+K(-1.0, +0.0))/R).x;\n    \n    vec4 neigh = vec4(n,e,s,w);\n    for(float k = .0; k < 4.; k++)\n    {\n    if (\nV(0.,0.,0.,0) == neigh ||\nV(0.,0.,0.,3) == neigh ||\nV(0.,0.,4.,4) == neigh\n    )\n    \t{\n\t        next_state = 0.;\n            break;\n        }\n    else if (\nV(0.,4.,5.,1) == neigh ||\nV(3.,3.,5.,1) == neigh ||\nV(3.,4.,5.,1) == neigh ||\nV(3.,5.,1.,0) == neigh ||\nV(4.,4.,5.,1) == neigh ||\nV(5.,4.,1.,1) == neigh ||\nV(5.,5.,1.,3) == neigh ||\nV(5.,5.,1.,4) == neigh\n\t)\n    {\n        next_state = 1.;\n        break;\n    }\n    else if (\nV(0.,4.,1.,0) == neigh ||\nV(5.,3.,4.,2) == neigh\n    )\n    {\n        next_state = 3.;\n        break;\n    }\n    else if (\nV(0.,0.,0.,4) == neigh ||\nV(0.,3.,5.,4) == neigh ||\nV(5.,4.,2.,1) == neigh\n    )\n    {\n        next_state = 4.;\n        break;\n    }\n    rotate(neigh);\n\t}\n    return next_state;\n}\n\nfloat rule_state_4(K u, float curr)\n{\n    float next_state = curr;\n    \n    float n,e,s,w;\n    \n    n = t0((u+K(+0.0, +1.0))/R).x;\n    e = t0((u+K(+1.0, +0.0))/R).x;\n    s = t0((u+K(+0.0, -1.0))/R).x;\n    w = t0((u+K(-1.0, +0.0))/R).x;\n    \n    vec4 neigh = vec4(n,e,s,w);\n    for(float k = .0; k < 4.; k++)\n    {\n    if (\nV(0.,0.,3.,0) == neigh ||\nV(0.,0.,4.,0) == neigh ||\nV(0.,3.,3.,0) == neigh\n    )\n    \t{\n\t        next_state = 0.;\n            break;\n        }\n    else if (\nV(2.,4.,5.,3) == neigh ||\nV(5.,2.,1.,3) == neigh\n\t)\n    {\n        next_state = 2.;\n        break;\n    }\n    else if (\nV(0.,0.,5.,3) == neigh ||\nV(0.,3.,5.,3) == neigh ||\nV(0.,4.,5.,3) == neigh ||\nV(3.,4.,5.,2) == neigh ||\nV(3.,4.,5.,3) == neigh ||\nV(3.,5.,5.,3) == neigh ||\nV(4.,4.,5.,3) == neigh ||\nV(5.,3.,2.,3) == neigh ||\nV(5.,3.,4.,5) == neigh ||\nV(5.,4.,1.,3) == neigh\n    )\n    {\n        next_state = 3.;\n        break;\n    }\n    else if (\nV(0.,0.,5.,4) == neigh ||\nV(0.,1.,5.,4) == neigh ||\nV(0.,4.,5.,4) == neigh ||\nV(0.,5.,5.,4) == neigh ||\nV(1.,1.,5.,4) == neigh ||\nV(1.,4.,5.,4) == neigh ||\nV(3.,1.,5.,4) == neigh ||\nV(3.,3.,5.,4) == neigh ||\nV(4.,1.,5.,5) == neigh ||\nV(5.,0.,2.,4) == neigh ||\nV(5.,1.,1.,4) == neigh ||\nV(5.,3.,1.,4) == neigh\n    )\n    {\n        next_state = 4.;\n        break;\n    }\n    else if (\nV(2.,3.,5.,0) == neigh\n    )\n    {\n        next_state = 5.;\n        break;\n    }\n    rotate(neigh);\n\t}\n    return next_state;\n}\n\nfloat rule_state_5(K u, float curr)\n{\n    float next_state = curr;\n    \n    float n,e,s,w;\n    \n    n = t0((u+K(+0.0, +1.0))/R).x;\n    e = t0((u+K(+1.0, +0.0))/R).x;\n    s = t0((u+K(+0.0, -1.0))/R).x;\n    w = t0((u+K(-1.0, +0.0))/R).x;\n    \n    vec4 neigh = vec4(n,e,s,w);\n    for(float k = .0; k < 4.; k++)\n    {\n    if (\nV(0.,0.,0.,0) == neigh ||\nV(5.,0.,0.,5) == neigh\n    )\n    \t{\n\t        next_state = 0.;\n            break;\n        }\n    else if (\nV(3.,5.,0.,2) == neigh ||\nV(0.,0.,2.,3) == neigh ||\nV(2.,5.,0.,5) == neigh\n    )\n    {\n        next_state = 2.;\n        break;\n    }\n    else if (\nV(5.,0.,2.,4) == neigh\n    )\n    {\n        next_state = 4.;\n        break;\n    }\n    else if (\nV(0.,0.,0.,1) == neigh ||\nV(0.,0.,0.,4) == neigh ||\nV(0.,0.,0.,5) == neigh ||\nV(0.,0.,1.,1) == neigh ||\nV(0.,0.,3.,3) == neigh ||\nV(0.,0.,3.,5) == neigh ||\nV(0.,0.,4.,1) == neigh ||\nV(0.,0.,4.,4) == neigh ||\nV(0.,0.,5.,1) == neigh ||\nV(0.,0.,5.,3) == neigh ||\nV(0.,3.,2.,0) == neigh ||\nV(0.,4.,5.,0) == neigh ||\nV(0.,5.,4.,0) == neigh ||\nV(1.,1.,0.,5) == neigh ||\nV(1.,2.,0.,5) == neigh ||\nV(1.,5.,0.,1) == neigh ||\nV(1.,5.,0.,5) == neigh ||\nV(2.,1.,5.,0) == neigh ||\nV(2.,2.,0.,1) == neigh ||\nV(3.,0.,0.,1) == neigh ||\nV(3.,1.,0.,5) == neigh ||\nV(3.,2.,0.,5) == neigh ||\nV(3.,5.,0.,1) == neigh ||\nV(3.,5.,0.,5) == neigh ||\nV(4.,0.,0.,2) == neigh ||\nV(4.,1.,0.,5) == neigh ||\nV(4.,2.,0.,0) == neigh ||\nV(4.,2.,0.,5) == neigh ||\nV(4.,5.,0.,1) == neigh ||\nV(4.,5.,0.,5) == neigh ||\nV(5.,0.,0.,1) == neigh ||\nV(5.,3.,2.,2) == neigh\n    )\n    {\n        next_state = 5.;\n        break;\n    }\n    rotate(neigh);\n\t}\n    return next_state;\n}\n\nvoid update(vec2 u, inout vec4 o)\n{\n   switch(int(o.x)+0)\n    {\n        case 0 :\n        o.y = rule_state_0(u, o.x);\n        break;\n        case 1:\n        o.y = rule_state_1(u, o.x);\n        break;\n        case 2:\n        o.y = rule_state_2(u, o.x);\n        break;\n        case 3:\n        o.y = rule_state_3(u, o.x);\n        break;\n        case 4:\n        o.y = rule_state_4(u, o.x);\n        break;\n        case 5:\n        o.y = rule_state_5(u, o.x);\n        break;\n    }\n    o = o.yyyy;\n}\n\n\t   /*\nbyl : 6 states, using this rule table : http://cafaq.com/apps/index.php\nthe table is on \"What are Byl's rules for a self reproducing CA?\"\nI translate\n. -> 0\n+ -> 1\n* -> 2\nO -> 3\nL -> 4\nX -> 5\n\ninitial configuration\n 55\n5435\n5415\n 52\n       */\n\n\nvoid init(vec2 u, inout V o)\n{\n    K iu = floor((u-.0*R));\n    if (\n        (iu.y == 8. && iu.x == 8.)\n       )\n        o = V(3.);\n    else if (\n\t\t(iu.y == 7. && iu.x == 8.)\n       )\n        o = V(1.);\n    else if (\n        (iu.y == 6. && iu.x == 8.)\n    )\n\t\to = V(2.);\n    else if (\n        (iu.y == 8. && iu.x == 7.) ||\n        (iu.y == 7. && iu.x == 7.)\n    )\n\t\to = V(4.);\n    else if (\n        (iu.y == 8. && iu.x == 6.) ||\n        (iu.y == 7. && iu.x == 6.) ||\n        (iu.y == 8. && iu.x == 9.) ||\n        (iu.y == 7. && iu.x == 9.) ||\n        (iu.y == 9. && iu.x == 7.) ||\n        (iu.y == 9. && iu.x == 8.) ||\n        (iu.y == 6. && iu.x == 7.)\n    )\n\t\to = V(5.);\n}\n\nvoid mainImage(out vec4 o, in vec2 u)\n{\n    K    cd, v = (u - R*.0) / R.y;\n    o -= o;\n    o = t0(u/R);\n\n    if (iFrame == 0)\n    {\n\t    init(u, o);\n       \treturn;\n    }\n    if(iFrame % 10 == 1)\n    update(u, o);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n#define R iResolution.xy\n#define t0(u) texture(iChannel0, u)\n\n/*\ntemplate function for rules\nfloat rule_state_(K u, float curr)\n{\n    float next_state = curr;\n    \n    float n,e,s,w;\n    \n    n = t0((u+(+0.0, +1.0))/R).x;\n    e = t0((u+K(-1.0, +0.0))/R).x;\n    s = t0((u+K(+0.0, -1.0))/R).x;\n    w = t0((u+K(-1.0, +0.0))/R).x;\n    \n    vec4 neigh = vec4(n,e,s,w);\n    for(float k = .0; k < 4.; k++)\n    {\n    if (\n    \n    )\n    \t{\n\t        next_state = 0.;\n            break;\n        }\n    else if (\n\t\n\t)\n    {\n        next_state = 1.;\n        break;\n    }\n    else if (\n\t\n    )\n    {\n        next_state = 2.;\n        break;\n    }\n    else if (\n    \n    )\n    {\n        next_state = 3.;\n        break;\n    }\n    else if (\n\t\n    )\n    {\n        next_state = 4.;\n        break;\n    }\n    else if (\n\t\n    )\n    {\n        next_state = 5.;\n        break;\n    }\n    else if (\n\t\n    )\n    {\n        next_state = 6.;\n        break;\n    }\n    else if (\n\t\n    )\n    {\n        next_state = 7.;\n        break;\n    }\n    rotate(neigh);\n\t}\n    return next_state;\n}\n*/\n\n","name":"Common","description":"","type":"common"}]}