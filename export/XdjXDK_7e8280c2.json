{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// Original code by inigo quilez - iq/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define PI 3.1415926535897932384626433832795\n\nconst float halfPI = 0.5 *PI;\nconst mat2 m2 = mat2(1.6,-1.2,1.2,1.6);\n\nfloat terrain( vec2 p ) {\n    p.x *= iResolution.x/iResolution.y;\n    p *= 0.0013;\n    float s = 1.0;\n    float t = 0.0;\n    for ( int i=0; i<4; i++ ) {\n        t += 0.5*(cos(6.2831*p.x) + sin(6.2831*p.y))*s;\n        s *= 0.5 + 0.1*t;\n        p = 0.97*m2*p + (t-0.5)*0.2;\n    }\n    return t*55.0;\n}\n\nfloat skier( vec2 p ) {\n    p.x *= iResolution.x/iResolution.y;\n    p *= 0.0013;\n    float s = 1.0;\n    float t = 0.0;\n    for ( int i=0; i<7; i++ ) {\n        t += 0.5*(cos(6.2831*p.x) + sin(6.2831*p.y))*s;\n        s *= 0.5 + 0.1*t;\n        p = 0.97*m2*p + (t-0.5)*0.2;\n    }\n    return t*55.0;\n}\n\nfloat map( in vec3 pos ) {\n    return pos.y - terrain(pos.xz);\n}\n\nfloat intersect( in vec3 ro, in vec3 rd, in float tmin, in float tmax, in float time ) {\n    float t = tmin;\n    for ( int i=0; i<160; i++ ) {\n        vec3 pos = ro + t*rd;\n        float h = map( pos );\n        if ( h < (0.001*t) || t>tmax ) break;\n        t += h * 0.5;\n    }\n    return t;\n}\n\nfloat calcShadow(in vec3 ro, in vec3 rd ) {\n    vec2 eps = vec2( 150.0, 0.0 );\n    float h1 = terrain( ro.xz );\n    float h2 = terrain( ro.xz );\n    float d1 =  10.0;\n    float d2 =  80.0;\n    float d3 = 200.0;\n    float s1 = clamp( 1.0*(h1 + rd.y*d1 - terrain(ro.xz + d1*rd.xz)), 0.0, 1.0 );\n    float s2 = clamp( 0.5*(h1 + rd.y*d2 - terrain(ro.xz + d2*rd.xz)), 0.0, 1.0 );\n    float s3 = clamp( 0.2*(h2 + rd.y*d3 - terrain(ro.xz + d3*rd.xz)), 0.0, 1.0 );\n    return min(min(s1,s2),s3);\n}\n\nvec3 calcNormal( in vec3 pos, float t ) {\n    float e = 0.005*t;\n    vec2 eps = vec2( e, 0.0 );\n    float h = terrain( pos.xz );\n    return normalize( vec3( terrain(pos.xz-eps.xy)-h, e, terrain(pos.xz-eps.yx)-h ));\n}\n\nvec3 camPath( float time ) {\n    vec2 p = 1200.0*vec2( cos(0.0+0.23*time), cos(1.5+0.205*time) );\n    return vec3( p.x, 0.0, p.y );\n}\n\nvec3 dome( in vec3 rd, in vec3 light1 ) {\n    float sda = clamp(0.5 + 0.5*dot(rd,light1),0.0,1.0);\n    float cho = max(rd.y,0.0);\n    vec3 bgcol = mix( mix(vec3(0.00,0.40,0.60)*0.7, \n                          vec3(0.80,0.70,0.20),                        pow(1.0-cho,3.0 + 4.0-4.0*sda)), \n                          vec3(0.43+0.2*sda,0.4-0.1*sda,0.4-0.25*sda), pow(1.0-cho,10.0+ 8.0-8.0*sda) );\n    bgcol *= 0.8 + 0.2*sda;\n    return bgcol*0.75;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 xy = -1.0+2.0*fragCoord.xy/iResolution.xy;\n    vec2 sp = xy*vec2(iResolution.x/iResolution.y,1.0);\n\n    // animate    \n    float time = 16.5 + (0.0+iTime-0.0)*0.1;\n\n    // ray origin\n    vec3  ro = camPath( time + 0.0 );\n    ro.y = skier( ro.xz ) + 24.0;\n\n    // target\n    vec3  ta = camPath( time + 2.0 );\n    ta.y = ro.y - 180.0;\n\n    vec3 light1 = normalize( vec3(-0.8,0.2,0.5) );\n\n    // calc control point\n    vec3 dv = ta-ro;\n    vec3 tmp = vec3(dv.x*cos(-halfPI)+dv.z*sin(-halfPI), dv.y, dv.z*cos(-halfPI)-dv.x*sin(-halfPI));\n    vec3 cpr = ro + normalize(dv)*4.0;\n    cpr.y = skier( cpr.xz );\n    if ( cpr.y < ro.y ) {\n        // downward slope\n        cpr *= vec3(1.0, 0.25*(ro.y-cpr.y), 1.0);\n    } else {\n        // upward slope\n        cpr *= vec3(1.0, 0.25*(cpr.y-ro.y), 1.0);\n    }\n\n    // camera\n    vec3  cw = normalize(ta-ro);                 // forward direction\n    vec3  cp = normalize( cross(cpr,cw) );       // roll  (rot on Z-axis)\n    vec3  cu = normalize( cross(cw,cp ) );       // pitch (rot on X-axis)\n    //vec3  cv = normalize( cross(cu,cw) );      // yaw   (rot on Y-axis)\n\n    // ray direction\n    vec3  rd = normalize( sp.x*cu + sp.y*cp + 1.5*cw );\n    \n    // background    \n    vec3 bgcol = dome( rd, light1 );\n\n    // raymarch\n    float tmin = 10.0;\n    float tmax = 2000.0;\n\n    float sundotc = clamp( dot(rd,light1), 0.0, 1.0 );\n    vec3 col = bgcol;\n\n    float t = intersect( ro, rd, tmin, tmax, time );\n    if ( t>tmax ) {\n        // sky      \n        col += 0.2*0.12*vec3(1.0,0.5,0.1)*pow( sundotc,5.0 );\n        col += 0.2*0.12*vec3(1.0,0.6,0.1)*pow( sundotc,64.0 );\n        col += 0.2*0.12*vec3(2.0,0.4,0.1)*pow( sundotc,512.0 );\n\n        // clouds\n        vec2 sc = ro.xz + rd.xz*(1000.0-ro.y)/rd.y;\n        col = mix( col, 0.25*vec3(0.5,0.9,1.0), 0.4*smoothstep(0.0,1.0,texture(iChannel0,0.000005*sc).x) );\n\n        // sun scatter\n        col += 0.2*0.2*vec3(1.5,0.7,0.4)*pow( sundotc, 4.0 );\n    }\n    else {\n        // mountains        \n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, t );\n        vec3 sor = calcNormal( pos, t );\n        vec3 ref = reflect( rd, nor );\n\n        // rock\n        col = vec3(0.07,0.06,0.05);\n        col *= 0.2 + sqrt( texture( iChannel0, 0.01*pos.xz*vec2(0.5,1.0) ).x *\n                           texture( iChannel0, 0.01*pos.xz*vec2(0.5,1.0) ).x );\n        vec3 col2 = vec3(1.0,0.2,0.1)*0.01;\n        col = mix( col, col2, 0.0 );\n        \n        // grass\n        float s = smoothstep(0.6,0.7,nor.y - 0.01*(pos.y-20.0));        \n        s *= smoothstep( 0.15,0.2,0.01*nor.x+texture(iChannel0, 0.001*pos.xz).x);\n        vec3 gcol = 0.13*vec3(0.22,0.23,0.04);\n        gcol *= 0.3+texture( iChannel0, 0.03*pos.xz ).x*1.4;\n        col = mix( col, gcol, s );\n        nor = mix( nor, sor, 0.3*s );\n        vec3 ptnor = nor;\n\n        // trees\n        s = smoothstep(0.9,0.95,nor.y - 0.01*(pos.y-20.0));        \n        s *= smoothstep( 0.1,0.13,-0.17+texture(iChannel0, 0.0025*pos.xz).x);\n        vec3 tor = -1.0 + 2.0*texture( iChannel0, 0.015*pos.xz ).xyz;\n        tor.y = 1.5;\n        tor = normalize(tor);\n        col = mix( col, 0.11*vec3(0.22,0.25,0.02)*1.0, s );\n        nor = mix( nor, tor, 0.7*s );\n        \n        // snow\n        s = ptnor.y + 0.008*pos.y - 0.2 + 0.2*(texture(iChannel0,0.00015*pos.xz+0.0*sor.y).x-0.5);\n        float sf = fwidth(s) * 1.5;\n        s = smoothstep(0.84-sf, 0.84+sf, s );\n        col = mix( col, 0.15*vec3(0.42,0.6,0.8), s);\n        nor = mix( nor, sor, 0.5*smoothstep(0.9, 0.95, s ) );\n\n        // lighting     \n        float amb = clamp( nor.y,0.0,1.0);\n        float dif = clamp( dot( light1, nor ), 0.0, 1.0 );\n        float bac = clamp( dot( normalize( vec3(-light1.x, 0.0, light1.z ) ), nor ), 0.0, 1.0 );\n        float sha = mix( calcShadow( pos, light1 ), 1.0, 0.0 );\n        \n        vec3 lin  = vec3(0.0);\n        lin += dif*vec3(11.0,6.00,3.00)*vec3( sha, sha*sha*0.5+0.5*sha, sha*sha*0.8+0.2*sha );\n        lin += amb*vec3(0.25,0.30,0.40);\n        lin += bac*vec3(0.35,0.40,0.50);\n        col *= lin;\n\n        // fog\n        col = mix( col, 0.25*mix(vec3(0.4,0.75,1.0),vec3(0.3,0.3,0.3), sundotc*sundotc), 1.0-exp(-0.0000008*t*t) );\n\n        // sun scatter\n        col += 0.15*vec3(1.0,0.8,0.3)*pow( sundotc, 8.0 )*(1.0-exp(-0.003*t));\n\n        // background\n        col = mix( col, bgcol, 1.0-exp(-0.00000004*t*t) );\n    }\n\n    // gamma\n    col = pow( col, vec3(0.45) );\n\n    // color grading    \n    col = col*1.4*vec3(1.0,1.0,1.02) + vec3(0.0,0.0,0.11);\n    col = clamp(col,0.0,1.0);\n    col = col*col*(3.0-2.0*col);\n    col = mix( col, vec3(dot(col,vec3(0.333))), 0.25 );\n\n    // panoramic viewport\n    float bw = iResolution.y-(iResolution.x/16.0*9.0);\n    if ( any( bvec2( fragCoord.y < 2.0*bw, fragCoord.y > iResolution.y-bw) ) ) col = vec3( 0.0 );\n\n\tfragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XdjXDK","date":"1416059850","viewed":523,"name":"fp.skiView","username":"joates","description":"procedural terrain code by inigo quilez - iq/2014\n\ni've added a few of my own mods (unfinished)\n","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["procedural","terrain","panoramic","viewport","ski","skier","skiing"],"hasliked":0,"parentid":"","parentname":""}}