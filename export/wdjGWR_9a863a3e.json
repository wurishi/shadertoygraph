{"ver":"0.1","info":{"id":"wdjGWR","date":"1548637075","viewed":2921,"name":"mandelbulb raymarched","username":"Myro","description":"a study on rendering 3D fractals with a basic raymarching renderer (mandelbulb)","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","fractal","mandelbrot","mandelbulb","animated","red","blue"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// controls : click and drag to navigate\n\n// base raymarching rendering thing\n// https://www.youtube.com/watch?v=yxNnRSefK94\n\n\n// fractal by\n// http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/\n\n\n#define MARCHINGITERATIONS 64\n\n#define MARCHINGSTEP 0.5\n#define SMALLESTSTEP 0.1\n\n#define DISTANCE 3.0\n\n#define MAXMANDELBROTDIST 1.5\n#define MANDELBROTSTEPS 64\n\n// cosine based palette, 4 vec3 params\nvec3 cosineColor( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nvec3 palette (float t) {\n    return cosineColor( t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(0.01,0.01,0.01),vec3(0.00, 0.15, 0.20) );\n}\n\n// distance estimator to a mandelbulb set\n// returns the distance to the set on the x coordinate \n// and the color on the y coordinate\nvec2 DE(vec3 pos) {\n    float Power = 3.0+4.0*(sin(iTime/30.0)+1.0);\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < MANDELBROTSTEPS ; i++) {\n\t\tr = length(z);\n\t\tif (r>MAXMANDELBROTDIST) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n\t}\n\treturn vec2(0.5*log(r)*r/dr,50.0*pow(dr,0.128/float(MARCHINGITERATIONS)));\n}\n\n// MAPPING FUNCTION ... \n// returns the distance of the nearest object in the direction p on the x coordinate \n// and the color on the y coordinate\nvec2 map( in vec3 p )\n{\n    //p = fract(p); \n   \tvec2 d = DE(p);\n\n  \n\n   \treturn d;\n}\n\n\n// TRACING A PATH : \n// measuring the distance to the nearest object on the x coordinate\n// and returning the color index on the y coordinate\nvec2 trace  (vec3 origin, vec3 ray) {\n\t\n    //t is the point at which we are in the measuring of the distance\n    float t =0.0;\n    float c = 0.0;\n    \n    for (int i=0; i<MARCHINGITERATIONS; i++) {\n    \tvec3 path = origin + ray * t;\t\n    \tvec2 dist = map(path);\n    \t// we want t to be as large as possible at each step but not too big to induce artifacts\n        t += MARCHINGSTEP * dist.x;\n        c += dist.y;\n        if (dist.y < SMALLESTSTEP) break;\n    }\n    \n    return vec2(t,c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\t// Pixel coordinates from -1 to 1\n    uv = uv * 2.0 - 1.0;\n    // Adjusting aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //ray direction (camera is at (0,0,0), view plane is at 0,0,1)\n    vec3 ray = normalize(vec3 (uv,1.0));\n\n    //ROTATING THE CAMERA (rotating the ray)\n    float rotAngle = 0.4+iTime/40.0 + 6.28*iMouse.x / iResolution.x;\n    //rotation matrix around the y axis\n    ray.xz *= mat2(cos(rotAngle), -sin(rotAngle), sin(rotAngle), cos(rotAngle));\n    \n    //camera position (rays origin)\n    float camDist = DISTANCE * iMouse.y / iResolution.y;\n    if (iMouse.xy==vec2(0)) camDist = DISTANCE*0.55;\n    vec3 origin = vec3 (camDist * sin(rotAngle),0.0,-camDist *cos(rotAngle));           \n    \n    //tracing the ray (getting the distance of the closest object in the ray direction)\n\tvec2 depth = trace(origin,ray);\n\t\n    //rendering with a fog calculation (further is darker)\n\tfloat fog = 1.0 / (1.0 + depth.x * depth.x * 0.1);\n\t\n    //frag color\n    vec3 fc = vec3(fog);\n    \n    \n    // Output to screen\n    fragColor = vec4(palette(depth.y)*fog,0.0);\n}","name":"Image","description":"","type":"image"}]}