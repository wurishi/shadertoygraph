{"ver":"0.1","info":{"id":"4lB3Ry","date":"1429801995","viewed":185,"name":"Trace proto1","username":"luutifa","description":"Why does the sphere think it's in shadow all the time???\nAlso all other suggestions would be highly appreciated.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","pleasehelp"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"precision highp float;\n\n#define RADIUS 3.0\n#define PI 3.14159265\n#define EPSILON 0.001\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nmat3 getXRotMat(float a) {\n    return mat3(\n         1.0,  0.0,     0.0,\n         0.0,  cos(a), -sin(a),\n         0.0,  sin(a),  cos(a)\n    );\n}\n\nmat3 getYRotMat(float a) {\n    return mat3(\n         cos(a),  0.0,  sin(a),\n         0.0,     1.0,  0.0,\n        -sin(a),  0.0,  cos(a)\n    );\n}\n\nmat3 getZRotMat(float a) {\n    return mat3(\n         cos(a), -sin(a),  0.0,\n         sin(a),  cos(a),  0.0,\n         0.0,     0.0,     1.0\n    );\n}\n\nvec3 amigaTexture(vec2 pos, float n) {\n    float l = clamp(sin(pos.x*n)*sin(pos.y*n)*10000.0, 0.0, 1.0);\n    return vec3(1.0, 0.0, 0.0)*l+(vec3(1.0, 1.0, 1.0)*(1.0-l));\n}\n\nfloat getTunnelDist(vec3 origin, vec3 direction) {\n    float a = direction.x*direction.x + direction.y*direction.y;\n    float b = 2.0*(origin.x*direction.x + origin.y*direction.y);\n    float c = origin.x*origin.x + origin.y*origin.y - RADIUS*RADIUS;\n    float disc = b*b - 4.0*a*c;\n    float t = 0.0;\n    /*if (disc < 0.0)\n        return 1000000.0;\n    else if (disc < EPSILON)\n        return -b/(2.0*a);\n    else*/\n        return /*min(*/(-b+sqrt(disc))/(2.0*a)/*, (-b-sqrt(disc))/(2.0*a))*/;\n    //We're only interested in positive z intersections so this is OK, I guess.\n}\n\nfloat getBoxDist(vec3 origin, vec3 direction) {\n    return 0.;\n}\n\nfloat getSphereDist(vec3 origin, vec3 direction, vec3 pos, float r) {\n    float a = direction.x*direction.x + direction.y*direction.y + direction.z*direction.z;\n    float b = 2.0 * (direction.x * (origin.x - pos.x) + direction.y * (origin.y - pos.y) + direction.z * (origin.z - pos.z));\n    float c = (origin.x - pos.x)*(origin.x - pos.x) + (origin.y - pos.y)*(origin.y - pos.y) + (origin.z - pos.z)*(origin.z - pos.z) - r*r;\n    float disc = b*b - 4.0*a*c;\n    if (disc<0.0)\n        return 1000000.0;\n    if (disc<EPSILON)\n        return -b/(2.0*a);\n    else\n        return min((-b+sqrt(disc))/(2.0*a), (-b-sqrt(disc))/(2.0*a));\n}\n\nvec3 sphereCenter = vec3(0.0, 0.0, 6.0+iTime);\n\nfloat render(vec3 origin, vec3 direction) {\n    return min(\n    \tgetTunnelDist(origin, direction),\n    \tgetSphereDist(origin, direction, sphereCenter, 0.8)\n    );\n}\n\nvec3 scene(vec3 origin, vec3 direction, out vec3 normal, out vec2 uv) { //Does depth testing\n    float tunnel = getTunnelDist(origin, direction);\n    float sphere = getSphereDist(origin, direction, sphereCenter, 0.8);\n    \n    vec3 pos = vec3(0.0);\n    if (tunnel < sphere) {\n    \tpos = origin + tunnel*direction;\n        normal = normalize(vec3(vec2(0.0), pos.z)-pos);\n        uv = vec2(atan(pos.y, pos.x), pos.z * 0.4);\n    } else {\n        pos = origin + sphere*direction;\n        normal = normalize(pos-sphereCenter);\n        uv = pos.xy-sphereCenter.xy;\n    }\n    return pos;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenPos = fragCoord.xy / iResolution.yy - vec2(0.5) - vec2(((iResolution.x - iResolution.y)/iResolution.y)/2.0, 0.0);\n    \n    vec3 light1 = vec3(sin(iTime)*2.0, cos(iTime*0.1)*2.0, 4.0+iTime-sin(iTime*0.22)*3.0);\n    vec3 cam = vec3(sin(iTime*0.3), cos(iTime*0.4), iTime);\n    vec3 rayDir = getXRotMat(-cos(iTime*0.6)*0.2) * getYRotMat(-sin(iTime*0.6)*0.2) * normalize(vec3(screenPos, 1.0));\n    \n    vec3 normal;\n    vec2 uv;\n    vec3 pos = scene(cam, rayDir, normal, uv);\n\n    vec3 shadowDir = normalize(light1-pos);\n    vec3 shadowPos = pos + render(pos+shadowDir*EPSILON, shadowDir)*shadowDir;\n    float shadow = 1.0;\n    if (length(shadowPos-pos)-EPSILON < length(light1-pos))\n        shadow = 0.0;\n    \n    float light = (1./length(pos-light1))\n        * max(dot(normal, -normalize(pos-light1)), 0.0);\n    light *= shadow;\n\n    fragColor = vec4(light*amigaTexture(uv, 6.0), 1.0);\n    //gl_FragColor = vec4(light*texture(iChannel0, uv/PI).rgb, 1.0);\n}\n","name":"","description":"","type":"image"}]}