{"ver":"0.1","info":{"id":"MtcSzr","date":"1477759170","viewed":722,"name":"Song of the Lightgrid","username":"4onen","description":"Simple beginner raymarcher following a youtube tutorial. Also two hours of tweaking and one of Shadertoy's brilliant audio tracks. Enjoy!\n(Restart using the GL shader's restart button. Restarting the song directly breaks sync.)","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["procedural","raymarching","audiovisual"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rn","filepath":"/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","previewfilepath":"/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Made by Matthew Dupree for fun. No credit, no profit.\n\n//This shader creates a giant grid of white spheres through raytracing,\n//which jump and shimmer according to the beat of the iChannel0 music track.\n#define MAX_ITERATIONS 32\n\n//Matrix generation function to\n//rotate a given vector by theta.\nmat2 rotation(float theta){\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, -s,\n                s,  c);\n}\n\n//This map function defines the distance field for the raytracer\nfloat map(vec3 p)\n{\n    //This function converts the single sphere I map into a\n    //repeating grid that goes off into infinity.\n    vec3 q = fract(p)*2.1 - 1.0;\n    \n    //This function defines the sphere (length(q)) and the radius\n    //The radius is defined by one of the lower middle-range frequencies\n    //of the audio track.\n    //The brightness is handled elsewhere...\n    return length(q) - (texture(iChannel0, vec2(0.21, 0.25)).x)/4.0;\n}\n\n//This is the raytracing function. It traces a ray as close as possible to some\n//surface ahead of it in the map function.\n//o is the origin of our search, r is the normalized ray we're looking along.\nfloat trace(vec3 o, vec3 r){\n    //Our current check distance.\n    //Technically this calls one iteration before beginning the loop.\n    float t = map(o)*0.5;\n    \n    //The tracing loop.\n    for(int i = 0; i<MAX_ITERATIONS; i++){\n        //First, get our current checking point.\n        vec3 p = o + r * t;\n        //Next, get the distance from this point\n        //to the closest piece of geometry.\n        float d = map(p);\n        //If it's super tiny, we're close enough. Stop iterating.\n        if(abs(d)<0.001) break;\n        //Otherwise, get closer.\n        t += d*0.5;\n    }\n    //Return the distance to the geometry.\n    //(Whether we found any or not.)\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Establishing coordinate system, nothing fancy\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0; //Centering origin\n    uv.x *= iResolution.x / iResolution.y; //Fixing aspect ratio\n    \n    //Pick a color for any rendered geometry. I went with white because... ehh...\n    const vec3 fogColor = vec3(1.0,1.0,1.0);\n    //This'll be our output color.\n    vec3 ret = vec3(0.0);\n    \n    //Time modulo the track length. This allows the shader to loop.\n    float time = mod(iTime, 258.07);\n    \n    //This is FOV control for the whole thing. 1.0 is 90 degree FOV, 0.0 is an infinite FOV.\n    //The setup here starts the FOV at 0.0, then swings upward to 1.0 at 180 seconds.\n    //At 180 seconds, it begins to swing back to 0.0, which it reaches at 240 seconds.\n    float fov = smoothstep(0.0,180.0,time)*(1.0-smoothstep(180.0,240.0,time));\n    \n    //Generate our origin and facing vector. The origin flies through the grid as the video\n    //goes along, the facing ray slowly spins. Fun!\n    vec3 r = normalize(vec3(uv, fov));\n    r.xz *= rotation(time/15.0);\n    vec3 o = vec3(0.0, time/1.5, time/1.5);\n    \n    //Locate the geometry for this ray.\n    float t = trace(o, r);\n    //Calculate the brightness we should apply.\n    //(How close is this geometry? Super close? 1.0)\n    //(How close is this geometry? Super far? 0.0)\n    float fog = 1.0 / (1.0 + t * t * 0.06);\n    \n    //Base drawing. Mix the background color with the fog color according to our brightness.\n    ret = mix(ret, fogColor, fog);\n    \n    //Fade-in.\n    //ret = mix(vec3(0.0), ret, smoothstep(0.0,5.0,time)*(1.0-smoothstep(250.0,254.0,time)));\n    \n    //Flashy lights.\n    //This is what makes the brightness increase and decrease in time with the music.\n    ret = mix(vec3(0.0), ret*2.0, (texture(iChannel0, vec2(0.01, 0.25)).x));\n    \n    //Output\n\tfragColor = vec4(ret, 1.0);\n}","name":"Image","description":"","type":"image"}]}