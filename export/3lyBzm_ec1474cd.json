{"ver":"0.1","info":{"id":"3lyBzm","date":"1614064919","viewed":141,"name":"BRDF Sandbox (Copo)","username":"coposuke","description":"// Mouse Up-Down  : Metallic     (D:0.0 ~ U:1.0)\n// Mouse Left-Right : Roughness (L:0.0 ~ R:1.0)\n\nSandbox for copo\n\nreferences:\n - WlffWB (kaneta san)\n - Mt3XWj (Pheema san)\n - 3tsGW2 (ivansafrin san)\n - XssBDr (piluve san)","likes":12,"published":1,"flags":32,"usePreview":0,"tags":["sandbox","brdf","pbr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec3 acesFilm(const vec3 x)\n{\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 onePixel = 1.0 / iResolution.xy;\n    vec2 uv = fragCoord * onePixel;\n    \n    fragColor = texture(iChannel0, uv);\n    \n    // bloom\n    float blm = bloom(iChannel0, uv, vec2(1,-1), onePixel);\n    fragColor.rgb += vec3(blm);\n    \n    // tonemap\n    fragColor.rgb = acesFilm(fragColor.rgb);\n    \n    // degamma\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0 / 2.2));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define saturate(value) (clamp(value, 0.0, 1.0))\n\nconst float PI = 3.1415926535798;\nconst float TAU = PI * 2.0;\n\nfloat hash(vec2 uv)\n{\n    return fract(sin(dot(uv, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nvec2 hash2(vec2 uv)\n{\n    return vec2(hash(uv), hash(uv + vec2(63.357, 234.346)));\n}\n\nfloat luminance(vec3 color)\n{\n    const vec3 PERCEPTION = vec3(0.2126, 0.7152, 0.0722);\n    return max(0.0, dot(PERCEPTION, color));\n}\n\nfloat bloom(sampler2D channel, vec2 uv, vec2 dir, vec2 onePixel)\n{\n    vec4 color = vec4(0.0);\n    dir = normalize(dir) * 5.0;\n    \n    const float INTENSITY = 0.005;\n    const int LOOPS = 128;\n    for(int i = -LOOPS / 2; i < LOOPS / 2; ++i)\n    {\n        float dist = 1.0 - abs(float(i) / float(LOOPS / 2));\n        vec4 sampleColor = texture(channel, uv + (dir * onePixel * float(i)));\n        \n        float lumi = sampleColor.a;\n        lumi = clamp(lumi, 0.0, 5.0) * dist * dist * INTENSITY;\n        \n        color.a += sampleColor.a * lumi;\n    }\n    \n    return color.a;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/\n//                     BRDF\n//_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/\nstruct BRDFDesc\n{\n    vec3 lightDir; // L\n    vec3 viewDir;  // V\n    vec3 normal;   // N\n    vec3 anisoX;   // X\n    vec3 anisoY;   // Y\n    float shadowAttenuation;\n    float aoAttenuation;\n};\n\nstruct Material\n{\n    vec3 diffuseColor;\n    vec3 specularColor;\n    vec3 reflectionColor;\n    vec3 emissiveColor;\n    float roughness;\n    float metallic;\n};\n\n\nvec3 fresnel(vec3 f0, float u)\n{\n    // Schlick Approximation\n    return f0 + (vec3(1.0) - f0) * pow(1.0 - u, 5.0);\n}\n\nvec3 fresnelRoughness(vec3 F0, float u, float roughness)\n{\n\t// Schlick Approximation (with roughness)\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - u, 5.0);\n}\n\nfloat distribution(float dotNH, float roughness)\n{\n    // GGX(Trowbridge-Reitz)\n    float a = roughness * roughness;\n    float a2 = a * a;\n    float dotNH2 = dotNH * dotNH;\n    float f = 1.0 - (1.0 - a2) * dotNH2;\n    return a2 / (PI * f * f);\n}\n\nfloat maskingAndShadowing(float dotNL, float dotNV, float roughness)\n{\n    //Smith Joint GGX(Height-Correlated Masking and Shadowing)\n    float a = roughness * roughness;\n    float a2 = a * a;\n    float lambdaNL = (-1.0 + sqrt(1.0 + a2 * (1.0 / (dotNL * dotNL) - 1.0))) / 2.0;\n    float lambdaNV = (-1.0 + sqrt(1.0 + a2 * (1.0 / (dotNV * dotNV) - 1.0))) / 2.0;\n    return 1.0 / (1.0 + lambdaNL + lambdaNV);\n}\n\nvec3 directLightingBRDF(Material param, BRDFDesc desc)\n{\n    vec3 halfDir = normalize(desc.lightDir + desc.viewDir);\n    float dotNV = dot(desc.normal, desc.viewDir);\n    float dotNH = abs(dot(desc.normal, halfDir));\n    float dotNL = abs(dot(desc.normal, desc.lightDir));\n    float dotLH = abs(dot(desc.lightDir, halfDir));\n\n    // Normal Distribution Function\n    float dTerm = distribution(dotNH, param.roughness);\n    \n    // Fresnel\n  \tvec3 f0 = mix(vec3(0.04), param.diffuseColor.rgb, param.metallic);\n    vec3 fTerm = fresnel(f0, dotLH);\n    \n    // Masking And Shadowing(Geometry Term)\n    float gTerm = maskingAndShadowing(dotNL, dotNV, param.roughness);\n    \n    // Diffuse BRDF\n\tvec3 kd = mix(vec3(1.0) - fTerm, vec3(0.0), param.metallic);\n    vec3 diffuse = param.diffuseColor;\n    diffuse = (diffuse / PI) * kd * dotNL;\n    \n    // Specular BRDF\n    vec3 specular = param.specularColor;\n    specular *= dTerm * fTerm * gTerm;\n    \n    // Fr = Fd + Fs\n    return (diffuse + specular) * desc.shadowAttenuation;\n}\n\nvec3 ambientLightingBRDF(Material param, BRDFDesc desc)\n{\n    // Fresnel with Roughness\n    float dotNV = dot(desc.normal, desc.viewDir);\n    vec3 f0 = 0.04 * (1.0 - param.metallic) + param.diffuseColor.rgb * param.metallic;\n    vec3 fTerm = fresnelRoughness(f0, dotNV, param.roughness);\n\n    vec3 kS = fTerm;\n    vec3 kD = (1.0 - kS) * (1.0 - param.metallic);\n    \n    // IBL\n    vec3 diffuseIrradiance = texture(iChannel2, desc.normal).rgb * param.diffuseColor * 0.1 * kD; //param.reflectionColor;\n    vec3 diffuseIBL = diffuseIrradiance * param.diffuseColor * (1.0 - param.metallic) * desc.aoAttenuation;\n    \n    float soAttenuation = saturate(pow(dotNV + desc.aoAttenuation, exp2(-16.0 * param.roughness - 1.0)) - 1.0 + desc.aoAttenuation);\n    vec3 specularIrradiance = param.reflectionColor;\n    vec3 specularIBL = specularIrradiance * fTerm * soAttenuation;\n    \n    return diffuseIBL + specularIBL;\n}\n\nvec3 computeBRDF(Material param, BRDFDesc desc)\n{\n    return directLightingBRDF(param, desc) + ambientLightingBRDF(param, desc) + param.emissiveColor;\n}\n\n//_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/\n//                     Main\n//_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/\nstruct Result\n{\n    float dist;\n    float type;\n    vec3 position;\n    vec3 local;\n    vec3 normal;\n    vec3 dir;\n    vec3 gridID;\n    bool isOvershoot;\n};\n\nMaterial Materials[5] = Material[](\n    Material(vec3(0.0),                 vec3(1.0),           vec3(0.0), vec3(0.0), 0.0, 0.0),   // 0: sky sphere\n    Material(vec3(1.022, 0.782, 0.344), vec3(1.0),           vec3(0.0), vec3(0.0), 0.4, 1.0),   // 1: gold\n    Material(vec3(0.0, 0.0, 0.0),       vec3(0.9, 0.9, 1.0), vec3(0.0), vec3(0.0), 0.25, 0.15), // 3: urushi black\n    Material(vec3(1.0, 0.08, 0.05),     vec3(1.0, 0.9, 0.9), vec3(0.0), vec3(0.0), 0.3, 0.15),  // 4: urushi vermilion\n    Material(vec3(0.7, 0.9, 1.0),       vec3(1.0),           vec3(0.0), vec3(0.0), 0.1, 0.05)   // 5: uruchi wood\n);\n\nmat2 rotate(float angle)\n{\n    float s = sin(angle), c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\n// IQ's opSmoothUnion\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nResult map(vec3 rayPos, vec3 rayDir)\n{\n    Result result;\n    result.dist = length(rayPos) - 1.0;\n    result.type = 1.0;\n    \n    for(float i=0.0 ; i<4.0 ; i++)\n    {\n        vec3 pos = vec3(1.0 + sin(iTime * 10.0 + i * PI * 0.5) * 0.35 + 0.5, 0.0, 0.0);\n        pos.xy *= rotate(i * TAU * 0.25 + iTime);\n        pos.xz *= rotate(i * TAU * 0.25 + iTime * 0.25);\n        \n        result.dist = opSmoothUnion(result.dist, length(rayPos + pos) - 0.25, 0.5);\n    }\n    \n    return result;\n}\n\nvec3 computeNormal(vec3 rayPos, vec3 rayDir)\n{\n    const vec2 EPSILON = vec2(1e-3, 0.0);\n    return normalize(vec3(\n        map(rayPos + EPSILON.xyy, rayDir).dist - map(rayPos - EPSILON.xyy, rayDir).dist,\n        map(rayPos + EPSILON.yxy, rayDir).dist - map(rayPos - EPSILON.yxy, rayDir).dist,\n        map(rayPos + EPSILON.yyx, rayDir).dist - map(rayPos - EPSILON.yyx, rayDir).dist\n    ));\n}\n\nResult march(vec3 cameraPos, vec3 cameraDir, int iteration)\n{\n    Result result;\n    result.dir = cameraDir;\n    result.type = result.dist = 0.0;\n    result.position = result.position = result.gridID = vec3(0.0);\n    \n    vec3 rayPos = cameraPos;\n    float rayDist = 0.0;\n\n    for(int i = 0; i < iteration; ++i)\n    {\n        rayPos = cameraPos + cameraDir * rayDist;\n        \n        Result mapResult = map(rayPos, cameraDir);\n        rayDist += mapResult.dist;\n\n        if(5e+1 < mapResult.dist)\n            break;\n            \n        if(mapResult.dist < 1e-3)\n        {\n            result.type = mapResult.type;\n            result.type = 100.0 <= result.type ? result.type - 100.0 : result.type;\n            result.dist = rayDist;\n            result.local = mapResult.local;\n            result.position = cameraPos + cameraDir * rayDist;\n            result.normal = computeNormal(result.position, cameraDir);\n            break;\n        }\n    }\n\n    return result;\n}\n\nfloat shadow(vec3 rayPos, vec3 rayDir, float rayMin, float rayMax, float k)\n{\n    float attenuation = 1.0;\n    \n    for(float dist = rayMin; dist < rayMax; )\n    {\n        vec3 pos = rayPos + rayDir * dist;\n        Result mapResult = map(pos, rayDir);\n        dist += mapResult.dist;\n        \n        if(!mapResult.isOvershoot)\n            attenuation = min(attenuation, k * mapResult.dist / dist);\n        \n        if(mapResult.dist < 1e-3)\n            break;\n    }\n    \n    return attenuation;\n}\n\nvec2 computeUV(vec3 position, vec3 normal)\n{\n    vec2 uv = vec2(0.0);\n    vec3 enableNormal = step(vec3(0.5), abs(normal));\n\n    uv = mix(uv, enableNormal.x * position.zy, enableNormal.x);\n    uv = mix(uv, enableNormal.y * position.xz, enableNormal.y);\n    uv = mix(uv, enableNormal.z * position.xy, enableNormal.z);\n\n    return uv;\n}\n\nMaterial getMaterial(Result result, vec2 uvc)\n{\n    int type = int(round(result.type));\n    if(1 <= type)\n    {\n        type = int(step(0.5, fract(result.position.y * 2.1))) + 1;\n    }\n\n    Material material = Materials[type];\n    \n    if(1 == type)\n    {\n        material.roughness = iMouse.x / iResolution.x;\n        material.metallic = iMouse.y / iResolution.y;\n    }\n    else\n    {\n        material.roughness = 1.0 - iMouse.x / iResolution.x;\n        material.metallic = 1.0 - iMouse.y / iResolution.y;\n    }\n    \n    return material;\n}\n\nvec3 materialize(in Result result, in vec2 uv, in vec3 reflectionColor, in vec3 cameraDir, in vec3 lightDir, in float shadow, in float aoShadow)\n{\n    Material material = getMaterial(result, uv);\n    material.emissiveColor += float(result.type == 0.0) * texture(iChannel1, result.dir).rgb * 0.5;\n    material.reflectionColor += float(result.type == 1.0) * (reflectionColor * 1.0);\n    material.reflectionColor += float(result.type == 2.0) * (reflectionColor * 1.0);\n    material.emissiveColor += float(result.type != 0.0) * float(smoothstep(0.1, 0.08, 0.95 - abs(result.position.y))) * vec3(7.0);\n    \n    material.roughness = clamp(material.roughness * 0.8 + 0.2, 0.1, 1.0);\n    material.metallic = clamp(material.metallic, 0.0, 1.0);\n    \n    BRDFDesc desc;\n    desc.lightDir = lightDir;\n    desc.viewDir = -cameraDir;\n    desc.normal = result.normal;\n    desc.anisoX = vec3(0.0, 0.0, 0.0);\n    desc.anisoY = vec3(0.0, 0.0, 0.0);\n    desc.shadowAttenuation = shadow;\n    desc.aoAttenuation = aoShadow;\n    \n    if(result.type == 0.0)\n        return material.emissiveColor;\n    \n    return computeBRDF(material, desc);\n}\n\nResult reflection(Result result, int generation, vec3 refDirOffset)\n{\n    vec4 ret = vec4(0.0);\n    \n    vec3 reflectionPosition = result.position - result.dir * 1e-2;\n    vec3 reflectionDirection = reflect(result.dir, result.normal);\n    \n    vec2 dir = vec2(1.0, 0.0);\n    vec3 tangent = normalize(cross(result.normal, vec3(0.0,1.0,0.0))); // (´；ω；｀)\n    vec3 binormal = cross(result.normal, tangent);\n    tangent = cross(result.normal, binormal);\n\n    // angle noise in tangent space\n    reflectionDirection *= mat3(tangent, result.normal, binormal);\n    reflectionDirection = normalize(reflectionDirection + refDirOffset);\n    reflectionDirection = mat3(tangent, result.normal, binormal) * reflectionDirection;\n    \n    return march(reflectionPosition, reflectionDirection, 25 - 5 * generation);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec4 color = vec4(0.0);\n    \n    //for(float aaX = -1.0; aaX <= 1.0; aaX += 2.0)\n    //for(float aaY = -1.0; aaY <= 1.0 ; aaY += 2.0)\n    {\n        // Render\n        vec3 cameraPos = vec3(0.0, sin(iTime * 0.2) * 2.0, -3.0);\n        vec3 cameraDir = normalize(vec3(uv, 2.0));\n        vec3 lightDir = normalize(vec3(0.2, 0.3, -0.5));\n\n        float cameraAngle = -TAU + iTime * 0.3;\n        float cameraAngle2 = sin(iTime * 0.2) * 0.625;\n        //cameraPos.xy += vec2(aaX, aaY) * (4.0 / float(iResolution.xy));\n        cameraPos.xz *= rotate(cameraAngle);\n        cameraDir.yz *= rotate(cameraAngle2);\n        cameraDir.xz *= rotate(cameraAngle);\n\n        Result result = march(cameraPos, cameraDir, 120);\n\n        // Reflection\n        Material material = getMaterial(result, uv);\n\n        vec3 reflectionColor = vec3(0.0);\n        float reflectionCount = 0.0;\n        for(int t=0 ; t<4 ; t++)\n        {\n            Result refResult = result;\n\n            for(int i=0 ; i<1; i++)\n            {\n                vec3 seed = floor(refResult.position * 400.0);\n                vec2 offset = hash2(seed.xz * (seed.y + 1e+3) + float(t+1)) * 2.0 - 1.0;\n                refResult = reflection(refResult, i, pow(material.roughness, 4.0) * normalize(vec3(offset, 0.0)));\n\n                vec3 color = materialize(refResult, uv, vec3(0.0), cameraDir, lightDir, 1.0, 1.0);\n                reflectionColor += abs(color); // minus number for reflection direction (some reason)\n                reflectionCount ++;\n\n                if(refResult.type <= 0.0)\n                    break;\n            }\n        }\n\n        // Shadow\n        float shadowAttenuation = shadow(result.position, lightDir, 0.1, 10.0, 20.0);\n        shadowAttenuation = clamp(shadowAttenuation, 0.5, 1.0);\n\n        // AmbientOcclusion\n        Result aoResult = map(result.position + result.normal * 5.0, cameraDir);\n        float aoAttenuation = mix(clamp(aoResult.dist / 5.0, 0.5, 1.0), 1.0, float(aoResult.isOvershoot));\n\n        color.rgb += materialize(result, uv, reflectionColor / reflectionCount, cameraDir, lightDir, shadowAttenuation, aoAttenuation);// * 0.25;\n        color.a += luminance(color.rgb);// * 0.25;\n    }\n    \n    // Result\n    fragColor = color;\n}\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 onePixel = 1.0 / iResolution.xy;\n    vec2 uv = fragCoord * onePixel;\n    \n    // bloom\n    fragColor = texture(iChannel0, uv);\n    fragColor.a = bloom(iChannel0, uv, vec2(1,1), onePixel);\n}","name":"Buffer B","description":"","type":"buffer"}]}