{"ver":"0.1","info":{"id":"XcKyD1","date":"1731850125","viewed":137,"name":"Twinkle Hop","username":"Pentan","description":"Code Graphics Compo entry at SESSIONS 2024\nhttps://sessions-party.com/","likes":12,"published":3,"flags":0,"usePreview":0,"tags":["raytracing","raymarching","sessions"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define kPI05    1.5707963267949\n#define kPI      3.1415926535898\n#define kPI2     6.2831853071796\n\n//\nvec3 rotZ(vec3 p, float a) {\n    vec2 sc = sin(vec2(a, a + kPI05));\n    return vec3(\n        p.x * sc.y + p.y * -sc.x,\n        p.x * sc.x + p.y * sc.y,\n        p.z\n    );\n}\n\nvec3 lookAt(vec3 o, vec3 t, vec3 u, vec3 d) {\n    vec3 f = normalize(o - t);\n    vec3 s = normalize(cross(u, f));\n    vec3 h = normalize(cross(f, s));\n    return vec3(\n        dot(vec3(s.x, h.x, f.x), d),\n        dot(vec3(s.y, h.y, f.y), d),\n        dot(vec3(s.z, h.z, f.z), d));\n}\n\n// Hash without Sine https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p) {\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nfloat hash13(vec3 p3) {\n    p3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash22(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nvec3 hash33(vec3 p3) {\n    p3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n//\nvec3 voro3(vec3 p, vec3 r) {\n    vec3 ret;\n    vec3 ip = floor(p);\n    const int N = 1;\n    float lmax = 10.0;\n    vec3 minip;\n    vec3 mintp;\n    \n    for(int iz = -N; iz <= N; iz++) {\n        for(int iy = -N; iy <= N; iy++) {\n            for(int ix = -N; ix <= N; ix++) {\n                vec3 tp = ip + vec3(ivec3(ix, iy, iz));\n                tp += (hash33(tp) - vec3(0.5)) * r;\n                float l = length(tp - p);\n                if(l < lmax) {\n                    lmax = l;\n                    minip = ip + vec3(ivec3(ix, iy, iz));\n                    mintp = tp;\n                }\n            }\n        }\n    }\n    ret.x = lmax;\n    ret.z = hash13(minip);\n    \n    lmax = 10.0;\n    vec3 minvp;\n    for(int iz = -N; iz <= N; iz++) {\n        for(int iy = -N; iy <= N; iy++) {\n            for(int ix = -N; ix <= N; ix++) {\n                vec3 tp = minip + vec3(ivec3(ix, iy, iz));\n                tp += (hash33(tp) - vec3(0.5)) * r;\n                vec3 vp = tp - mintp;\n                float l = length(vp);\n                if(l > 0.0) {\n                    vec3 mp = (tp + mintp) * 0.5;\n                    l = abs(dot(p - mp, vp / l));\n                    if(l < lmax) {\n                        lmax = l;\n                        minvp = vp;\n                    }\n                }\n            }\n        }\n    }\n    ret.y = lmax;\n    return ret;\n}\n\nfloat star(vec2 p) {\n    float a = atan(p.y, p.x) / kPI2 + 0.5;\n    a = abs(fract(a * 5.0) * 2.0 - 1.0) * kPI2 / 10.0;\n    float r = length(p);\n    vec2 q = cos(vec2(a, a - kPI05)) * r;\n    float s = kPI / 180.0 * 55.0;\n    vec2 n = cos(vec2(s, s - kPI05));\n    return 0.5 - dot(q, n);\n}\n\nfloat flower(vec2 p, float w) {\n    vec2 tt = vec2(1e2);\n    for(float i = 0.0; i < 5.0; i+=1.0) {\n        float a = kPI2 * i / 5.0;\n        vec2 o = cos(vec2(a, a - kPI05));\n        float to = length(p - o);\n        tt = min(tt, vec2(to, abs(to - 1.1756)));\n    }\n    return w - (length(p) > 1.0 ? tt.x : tt.y);\n}\n\n//\nfloat smin(float a, float b, float k) {\n    k *= 4.0;\n    float h = max(k - abs(a - b), 0.0) / k;\n    return min(a, b) - h * h * k * 0.25;\n}\n\nfloat sphere(vec3 p, vec3 o, float r) {\n    return length(p - o) - r;\n}\n\nvec2 tsphere(vec3 ro, vec3 rd, vec3 sc, float sr, out vec3 ret0, out vec3 ret1) {\n    vec3 oc = ro - sc;\n    float a = dot(rd, rd);\n    float b = 2.0 * dot(rd, oc);\n    float c = dot(oc, oc) - sr * sr;\n    float d = b * b - 4.0 * a * c;\n    if(d < 0.0) return vec2(-1.0);\n    vec2 t = (vec2(-b) + vec2(-1.0, 1.0) * sqrt(d)) * 0.5 / a;\n    ret0 = rd * t.x + ro;\n    ret1 = rd * t.y + ro;\n    return t;\n}\n\nfloat tplane(vec3 o, vec3 d, vec3 n, vec3 p, out vec3 ret) {\n    vec3 po = p - o;\n    float nd = dot(n, d);\n    float t = dot(n, po) / nd;\n    if(t < 0.0 || abs(nd) <= 1e-8) return -1.0;\n    ret = d * t + o;\n    return t;\n}\n\n// \nvec3 bg(vec3 p) {\n    vec3 d = normalize(p);\n    vec3 c = vec3(0.0, 0.0, 0.02);\n\n    vec3 vr = voro3(d * 120.0, vec3(1.0));\n    float f = 10.0 + abs(sin((vr.z * 24.0 + iTime) * 2.0)) * 20.0;\n    vec3 s = mix(vec3(1.0, 0.6, 0.4), vec3(0.4, 0.9, 1.0), fract(vr.z * vr.z * 1e3));\n    c += pow(vec3(1.0 - sqrt(vr.x)), vec3(10.0)) * f * s;\n\n    vec4 hc = mix(vec4(0.1, 0.15, 0.05, 25.0),\n                    vec4(0.0, 0.2, 0.8, 50.0),\n                    smoothstep(-0.03, 0.03, d.y));\n    c += pow(1.0-abs(d.y), hc.w) * hc.rgb;\n    c += exp(d.y * -d.y * 3e4) * pow(-d.z, 12.0) * vec3(1.0);\n\n    return c;\n}\n\n// scene\nconst float kDz = 4.0;\nconst float kIntro = 4.0;\nconst float kSeq = 16.0;\n\nvec2 i2p(vec2 p, float i, inout float y) {\n    if(i > kIntro) {\n        float iseq = mod(i - kIntro, kSeq);\n        if(iseq == 0.0) {\n            p = vec2(0.0, -1.0);\n            y *= 2.0;\n        } else if(iseq > kSeq - 4.0) {\n            p = vec2(p.x * 0.1, 2.0 - (kSeq - iseq));\n        }\n    }\n    return p;\n}\n\nvec2 pos2(float t) {\n    float i = floor(t);\n    float f = fract(t);\n\n    vec2 xx = vec2(-1.0, 1.0) * (fract(i * 0.5) * 4.0 - 1.0);\n    float y = 4.0 * f * (1.0 - f);\n\n    vec2 o0 = hash22(vec2(i) + vec2(0.0, 0.3456789));\n    vec2 o1 = hash22(vec2(i + 1.0) + vec2(0.0, 0.3456789));\n\n    o0 = o0 * 2.0 - vec2(1.0);\n    o1 = o1 * 2.0 - vec2(1.0);\n\n    vec2 p0 = vec2(xx.x, 0.0) + o0;\n    vec2 p1 = vec2(xx.y, 0.0) + o1;\n\n    p0 = i2p(p0, i, y);\n    p1 = i2p(p1, i + 1.0, y);\n\n    return mix(p0, p1, f) + vec2(0.0, y);\n}\n\nfloat map(vec3 p, vec3 tbif) {\n    float tb = tbif.x;\n    float ti = tbif.y;\n    float tf = tbif.z;\n\n    const float N = 16.0;\n    const float r0 = 0.01;\n    float d = sphere(p, vec3(pos2(tb), 0.0), r0);\n    float dt = 0.0;\n    for(float i = 1.0; i < N; i+=1.0) {\n        float f = sqrt(i / (N - 1.0));\n        f = 4.0 * f * (1.0 - f);\n        dt += mix(0.02, 0.05, f);\n        vec2 sp = pos2(tb - dt);\n        float r = 0.1 * f + r0;\n        float s = mix(0.03, 0.05, f);\n        d = smin(d, sphere(p, vec3(sp, dt * kDz), r), s);\n    }\n    return d;\n}\n\nvec3 normal(vec3 p, vec3 t) {\n    int id;\n    vec2 e = vec2(1.0, -1.0) * 0.5773;\n    const float eps = 0.00025;\n    return normalize( e.xyy * map(p + e.xyy * eps, t) + \n\t\t\t\t\t  e.yyx * map(p + e.yyx * eps, t) + \n\t\t\t\t\t  e.yxy * map(p + e.yxy * eps, t) + \n\t\t\t\t\t  e.xxx * map(p + e.xxx * eps, t) );\n}\n\nvec3 fxs(vec3 ro, vec3 rd, float maxt, vec3 tbif) {\n    float tb = tbif.x;\n    float ti = tbif.y;\n    float tf = tbif.z;\n\n    vec3 ret = vec3(0.0, 0.0, 0.0);\n\n    for(float i = 0.0; i < 4.0; i+=1.0) {\n        float pti = ti - i;\n        if(pti < 0.0) break;\n\n        float ft = (tb - pti);\n        vec3 fp = vec3(pos2(pti), ft * kDz);\n        if(pti < kIntro) maxt = 100.0;\n\n        {\n            vec3 hp;\n            float ht = tplane(ro, rd, vec3(0.0, 1.0, 0.0), fp, hp);\n            if(ht >= 0.0 && ht < maxt) {\n                float r = ft * 1.2;\n                float t = length(fp - hp);\n                float f = smoothstep(0.95, 1.0, 1.0 - abs(t - r));\n                f *= max(0.0, 1.0 - t * t * 1.0);\n                ret += vec3(1.0, 1.0, 1.0) * f;\n            }\n        }\n\n        if(pti < kIntro) continue;\n        float scl = (mod(pti - kIntro, kSeq) == 0.0) ? 4.0 : 1.0;\n        scl = (pti == kIntro) ? 1.0 : scl;\n\n        for(float k = 0.0; k < 2.0; k+=1.0) {\n            float fd = 1.0 - smoothstep(1.0, 1.5, ft);\n            float sr = (0.5 * ft * ft + 1e-1) * (1.0 + k * 2.0) * scl;\n            vec3 sp = fp + vec3(0.0, sr, 0.0);\n            vec3 shp0, shp1;\n            vec2 sht = tsphere(ro, rd, sp, sr, shp0, shp1);\n            for(int j = 0; j < 2; j++) {\n                float st = (j == 0) ? sht.x : sht.y;\n                if(st < 0.0 || st > maxt) continue;\n                vec3 lp = rd * st + ro - sp;\n\n                float a = atan(lp.z, lp.x) + pti * 0.7 + k * 0.6;\n                float r = acos(clamp(-lp.y / sr, -1.0, 1.0)) / kPI;\n\n                r *= max(1.0, sr * 5.0 / scl);\n                vec2 uv = cos(vec2(a, a - kPI05)) * r;\n                // ret += vec3(fract(length(uv)));\n                float tx = flower(uv, 0.04);\n                ret += vec3(4.0, 3.0, 2.0) * smoothstep(-0.02, 0.04, tx) * fd;\n            }\n        }\n\n        float strrng = fract(sin(pti + 1.7654321));\n        for(float k = 0.0; k < 20.0; k+= 1.0) {\n            strrng = fract(strrng * (1.23456 + strrng) * 100.0);\n            float rnd = strrng;\n            float a = (k + pti) * 2.4 + rnd;\n            vec3 pp = fp;\n            pp.xz += cos(vec2(a, a - kPI05)) * ft * (0.4 + rnd * 0.8) * scl;\n            pp.y += ft * (0.9 + rnd * 0.5 - ft) * 2.0 * scl;\n\n            vec3 hp;\n            float ht = tplane(ro, rd, vec3(0.0, 0.0, -1.0), pp, hp);\n            if(ht >= 0.0 && ht < maxt) {\n                vec2 uv = (hp.xy - pp.xy) * 12.0 / scl;\n                uv = rotZ(uv.xyy, k * 2.4).xy;\n                float tx = star(uv);\n                float fd = 1.0 - smoothstep(1.0, 1.5, ft);\n                ret += vec3(1.5, 1.0, 0.6) * fd * smoothstep(-0.1, 0.1, tx);\n            }\n        }\n    }\n\n    return ret;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 t;\n    t.x = iTime * 120.0 / 60.0;\n    t.y = floor(t.x);\n    t.z = fract(t.x);\n\n    vec3 color = vec3(0.0);\n    vec2 sc = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    vec3 ro = vec3(0.0, 0.0, 10.0);\n    vec3 rd = normalize(vec3(sc.xy, -4.0));\n    ro.xy += vec2(0.0, 0.4 + sin(iTime * 1.3) * 0.03) + sin(vec2(iTime) * vec2(0.7, 1.15)) * 0.04;\n    vec3 lp = vec3(pos2(t.x - 0.6) * vec2(0.02, 0.002), sin(iTime * 0.2) * 0.05);\n    rd = lookAt(ro, lp, vec3(0.0, 1.0, 0.0), rd);\n\n    color = bg(rd);\n\n    float td = 0.0;\n    float blm = 0.0;\n    for(int i = 0; i < 64; i++) {\n        vec3 rp = rd * td + ro;\n        float d = map(rp, t);\n        if(d < 1e-2) {\n            vec3 nv = normal(rp, t);\n            color = mix(vec3(0.4, 0.4, 0.55), vec3(0.8), (nv.y * 0.5 + 0.5));\n            color += vec3(0.2, 0.3, 0.0) * (1.0 - abs(nv.y));\n            break;\n        }\n        blm += pow(max(0.0, 1.0 - d * 8.0), 10.0); \n        td += d;\n    }\n    color += vec3(0.1, 0.2, 0.2) * blm;\n\n    if(t.y < kIntro) {\n        color = vec3(0.0);\n    } else {\n        color += max(0.0, 1.0 - (t.x - kIntro) * 2.0);\n    }\n\n    color += fxs(ro, rd, td, t);\n    fragColor = vec4(pow(color, vec3(1.0/2.2)), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}