{"ver":"0.1","info":{"id":"fsjXWz","date":"1620126137","viewed":78,"name":"libyan flag pre-2011","username":"rockstep","description":"it's so beautiful","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_RAY_MARCH_STEPS 100\n#define MAX_DIST 100.\n#define EPSILON 0.01\n#define LIGHT_FACTOR 10.\n#define PI 3.14159\n\nstruct Camera {\n    vec3 pos;\n    vec3 lookat;\n    float zoom;\n};\n\nstruct Light {\n    vec3 pos;\n};\n\nfloat dBox(vec3 p, vec3 s) {\n    return length(max(abs(p)-s, 0.));\n}\n\nfloat dCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = clamp(dot(ap, ab) / dot(ab, ab), 0., 1.);\n    vec3 c = a + t * ab;\n    return length(p - c) - r;\n}\n\nfloat dSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat distToPlane(vec3 p) {\n    return p.y; // axis-aligned\n}\n\nfloat distToPoleTop(vec3 p) {\n    return dSphere(p - vec3(0., 3., 0.), .1);\n}\n\nfloat distToFlag(vec2 uv, vec3 p) {\n    float wave = sin(uv.x * 10. + iTime) * smoothstep(0., .3, uv.x);\n    return dBox(p - vec3(.5, 2.5, wave), vec3(.6, .4, .01));\n}\n\nfloat distToPole(vec3 p) {\n    return dCapsule(p, vec3(0., -1., 0.), vec3(0., 3., 0.), .05);\n}\n\nfloat distToScene(vec2 uv, vec3 p) {\n    float dist = min(distToPlane(p), distToPoleTop(p));\n    dist = min(dist, distToFlag(uv, p));\n    dist = min(dist, distToPole(p));\n    return dist;\n}\n\nbool approx(float a, float b) {\n    return abs(a - b) < EPSILON;\n}\n\nvec3 color(vec2 uv, vec3 p) {\n    float d = distToScene(uv, p);\n    if (approx(distToPlane(p), d)) {\n        return vec3(0,1,0);\n    }\n    if (approx(distToPoleTop(p), d)) {\n        return vec3(1,1,0);\n    }\n    if (approx(distToFlag(uv, p), d)) {\n        return vec3(0,1,0);\n    }\n    if (approx(distToPole(p), d)) {\n        return vec3(1,1,1);\n    }\n    return vec3(0,0,1);\n}\n\nfloat distToSceneAlong(vec2 uv, vec3 ro, vec3 rd) {\n    float distSoFar = 0.;\n    for (int i = 0; i < MAX_RAY_MARCH_STEPS; i++) {\n        vec3 pointAlongRay = ro + distSoFar*rd;\n        float increment = distToScene(uv, pointAlongRay);\n        distSoFar += increment;\n        if (increment <= EPSILON || distSoFar > MAX_DIST) {\n            break;\n        }\n    }\n    return distSoFar;\n}\n\nvec3 normal(vec2 uv, vec3 p) {\n    vec2 delta = vec2(EPSILON, 0);\n    float dist = distToScene(uv, p);\n    return normalize(vec3(\n        dist - distToScene(uv, p - delta.xyy),\n        dist - distToScene(uv, p - delta.yxy),\n        dist - distToScene(uv, p - delta.yyx)\n    ));\n}\n\nfloat lighting(vec2 uv, Light lamp, vec3 p) {\n    vec3 lightVector = normalize(lamp.pos - p);\n    vec3 n = normal(uv, p);\n\n    float dif = clamp(dot(lightVector, n), 0., 1.) ;\n    float d = distToSceneAlong(uv, p + n * LIGHT_FACTOR * EPSILON , lightVector);\n    if (d < length(lamp.pos - p)) {\n        dif *= 0.1; // in shadow\n    }\n    return dif;\n}\n\nvec3 rayDirection(Camera cam, vec2 uv) {\n    vec3 f = normalize(cam.lookat - cam.pos);\n    vec3 r = normalize(cross(vec3(0., 1., 0.), f));\n    vec3 u = cross(f, r);\n    vec3 screenCenter = cam.pos + f * cam.zoom;\n    vec3 i = screenCenter + uv.x * r + uv.y * u;\n    return i - cam.pos;\n}\n\nmat2 rot(float t) {\n    float s = sin(t);\n    float c = cos(t);\n    return mat2(c, -s, s, c);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n\n    float t = iTime;\n    t = 0.;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    Camera cam;\n    cam.pos = vec3(6.*sin(t), .5, -6.*cos(t));\n    cam.lookat = vec3(0, 1, 0);\n    cam.zoom = 1.;\n    Light lamp;\n    lamp.pos = vec3(-2, 6, -2);\n    \n    //cam.pos.yz *= rot(-m.y*PI + 1.);\n    //cam.pos.xz *= rot(-m.x*2.*PI);\n\n    vec3 rd = rayDirection(cam, uv);\n    float dist = distToSceneAlong(uv, cam.pos, rd);\n    vec3 p = cam.pos + dist * rd;\n    float dif = lighting(uv, lamp, p);\n    \n    //vec3 col = mix(vec3(0,0,1), vec3(dif) * color(uv, p), dif*10.);\n    vec3 col = vec3(dif) * color(uv, p);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}