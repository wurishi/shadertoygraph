{"ver":"0.1","info":{"id":"NsBcW1","date":"1643423580","viewed":146,"name":"CRT Experiment 3","username":"Makeavoy","description":"crt test 2.\nPixels are divided by rgb to separate \"lights\" in the screen, in this iteration a higher luminance merges the pixel lights more easily.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["pixel","crt","weird"],"hasliked":0,"parentid":"NdByW1","parentname":"CRT experiment 2"},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define RESOLUTION 32.\n#define LOW_RANGE 0.45\n#define HIGH_RANGE 0.8\n#define DARK_FACTOR 0.1\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float AR = iResolution.x / iResolution.y;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //float xv=cos(length(uv-0.5));\n    //vec2 fake=vec2(uv.x,uv.y+xv);\n    //uv.y+=(xv);\n    \n    \n    \n    //resolution factor\n    float res=RESOLUTION;\n    vec2 res2=vec2(res,res/AR);\n    vec2 res3=res2;\n    vec2 res4=res2;\n\n    \n    vec2 pre_i=floor(uv*res2);\n    \n    vec2 i=pre_i/res2;\n    \n    float even=0.;\n    \n    if(mod(pre_i.y,2.)==0.){\n        even=0.5/res2.x;//2./res;\n\n        //i.y+=even;\n        uv.x+=even;\n        float pre_y=floor(uv.x*res2.x);\n        i.y=pre_y/res2.x;\n        //if(mod(pre_y,2.)==0.){\n        //    uv.x+=0.125/res;\n        //}\n        \n        i=floor(uv*res2)/res2;\n    }\n    \n    \n    \n    vec4 tex = texture(iChannel0, i);\n    float lum=(0.2126*tex.r + 0.7152*tex.g + 0.0722*tex.b);\n    \n    //this calculation is very particular\n    float value=smoothstep(LOW_RANGE,HIGH_RANGE,1.-lum);\n    \n    float v=min(value,1.);\n    \n    //first factor to determine how much rgb pixels split up\n    //1. is complete seperation, 0. is merged\n    float split=max(.33,v);\n    \n\n    \n    vec2 uv2=uv+vec2(-split*0.2/res,0.);\n    vec2 uv3=uv+vec2(-split*0.4/res,0.);\n    \n    \n    \n    //vec2 c=mod(uv,1./res)*res;\n    vec2 cr=mod(uv,1./res2)*res2;\n    vec2 cg=mod(uv2,1./res3)*res3;\n    vec2 cb=mod(uv3,1./res4)*res4;\n\n//cr.y+=even;\n//cg.y+=even;\n//cb.y+=even;\n    \n    //stutter vec2 i2=vec2(i.x-mod(iTime,0.002),i.y);\n    \n    \n    //float t2=min(4.*uv.y/mod(iTime,4.),1.0);\n    //sin(uv.y*10.+iTime)*\n    \n    //float t2=((uv.y-0.5)*(uv.x-0.5))*cos(iTime);\n    \n    \n    float t=  0.;\n    //////////////////\n    //////////////////\n    \n    bool boundary=true;\n    float circle_time=1.+cos(iTime*3.);\n    \n    //higher is less, lower is more\n    float boundary_effect=circle_time;\n    \n    \n    float dx=1.-abs(2.*i.x -1.);\n    float dy=1.-abs(2.*i.y -1.);\n    //float degree=(dx*dy)*256.*(1.+20.*boundary_effect); //lower is more dramatic\n    float degree=(dx*dy)*64.;\n    float wave=1./(degree);\n    //cos(8.*uv.y+2.)\n    \n    if (boundary){\n    t=wave;\n    }\n    \n    \n    //////////////////\n    //////////////////\n    \n    //t=sin(3.14+3.14*cos(( mod(iTime,20.)+uv.y)*6.))/64.;\n    \n    \n    \n    //////////////////\n    //////////////////\n    \n    \n    \n    vec2 i2=floor(uv2*res3)/res3;//vec2(i.x+t*3.,i.y-t);\n    vec2 i3=floor(uv3*res4)/res4;//vec2(i.x-t*6.,i.y+t);\n    //i2.x-=t*0.2;\n    //i3.x+=t*0.2;\n\n    \n    vec4 tex2 = texture(iChannel0, i2);\n    vec4 tex3 = texture(iChannel0, i3);\n\n    //float n=length(fv);\n    //if(n<0.5 && abs(fv.x)<0.45 && abs(fv.y)<0.45){\n\n    \n    //darkness factor (between 0 and 1 or higher, higher means dark barely splits\n    \n    float ar=1.;\n    float ag=1.;\n    float ab=1.;\n    \n    if(t<0.){\n        ar=0.;\n        ag=0.;\n        ab=0.;\n    }else{\n    \n    float pixel_size=(DARK_FACTOR+1.-split)*20.;\n    \n\n    cr.x*=0.66+split;\n    cg.x*=0.66+split;\n    cb.x*=0.66+split;\n    \n    if(split>0.33 ){\n     ar=(0.5-abs(cr.x-.5))*(0.5-abs(cr.y-0.5))*pixel_size;\n     ag=(0.5-abs(cg.x-.5))*(0.5-abs(cg.y-0.5))*pixel_size;\n     ab=(0.5-abs(cb.x-.5))*(0.5-abs(cb.y-0.5))*pixel_size;\n     }\n    //ar=step(0.1,ar);\n    //ag=step(0.9,ag);\n    //ab=step(0.9,ab);\n    \n    ar=min(floor(ar+0.97),1.0);\n    ag=min(floor(ag+0.97),1.0);\n    ab=min(floor(ab+0.97),1.0);\n    }\n\n    // Time varying pixel color\n    vec3 col = vec3(tex.r*ar,tex2.g*ag,tex3.b*ab); //vec3(r);//\n    \n    vec3 backup=vec3(tex.r,tex2.g,tex3.b);\n    // Output to screen\n    fragColor = vec4(col,1.);//vec4(cos(i2.x*100.),1.0,1.,1.0);\n}","name":"Image","description":"","type":"image"}]}