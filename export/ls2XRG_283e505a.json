{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"const float radius = 8.0;\nconst float lightingConstant = 16.0;\nfloat sphereRad;\n \nfloat intersectSphere(vec3 oc, vec3 dir)\n{\n    oc = oc - vec3(0.5,0.0,0.5);\n    float b = 2.0 * dot(dir, oc);\n    float c = dot(oc, oc) - sphereRad*sphereRad;\n    float disc = b * b - 4.0 * c;\n \n    if (disc < 0.0)\n        return -1.0;\n \n    // compute q as described above\n    float q;\n    if (b < 0.0)\n        q = (-b - sqrt(disc))/2.0;\n    else\n        q = (-b + sqrt(disc))/2.0;\n \n    float t0 = q;\n    float t1 = c / q;\n \n    // make sure t0 is smaller than t1\n    if (t0 > t1) {\n        // if t0 is bigger than t1 swap them around\n        float temp = t0;\n        t0 = t1;\n        t1 = temp;\n    }\n \n    // if t1 is less than zero, the object is in the ray's negative direction\n    // and consequently the ray misses the sphere\n    if (t1 < 0.0)\n        return -1.0;\n \n    // if t0 is less than zero, the intersection point is at t1\n    if (t0 < 0.0) {\n        return t1;\n    } else {\n        return t0; \n    }\n}\nvec4 realColorForRay(vec3 origin, vec3 direction, bool isSpherePass) {\n    vec3 skyCol = clamp(vec3(direction.y*0.5),0.0,1.0) + vec3(0.0,0.05,0.3);\n    vec4 col = vec4(skyCol,99999999999.0);\n    for (int i=0; i<=2; i++) {\n        for (float j=-radius; j<=radius; j+= 1.0) {\n            highp float dist = (j-origin[i])/direction[i];\n            if (dist > 0.0 && dist < col[3]) {\n                vec3 impactLocation = origin+direction*dist;\n                if (abs(impactLocation.x-0.5)>0.6 || abs(impactLocation.y-0.5)>0.6 || isSpherePass)\n                if (abs(impactLocation.x)<=9.0 && abs(impactLocation.y)<=9.0 && abs(impactLocation.z)<=9.0)\n                if ((i==0 || mod(impactLocation[0],2.0) < 1.0) && (i==1 || mod(impactLocation[1],2.0) < 1.0) && (i==2 || mod(impactLocation[2],2.0) < 1.0)) {\n                    col = vec4(vec3(0.8-length(impactLocation)/lightingConstant)+vec3(0.1,0.1,0.1),dist);\n                }\n            }\n        }\n    }\n    return col;\n}\nvec3 colorForRay(vec3 origin, vec3 direction) {\n    vec4 col = realColorForRay(origin,direction,false);\n\t\n    float sphereHitDist = intersectSphere(origin,direction);\n    if ((sphereHitDist < col[3]) && sphereHitDist != -1.0) {\n        col = vec4(vec3(0.07*sin(-iTime*0.5)+0.07)+realColorForRay(origin+direction*(sphereHitDist-0.1),refract(direction,normalize(origin+direction*sphereHitDist),sin(iTime*0.5)/4.0+0.75),true).rgb,sphereHitDist);\n    }\n    \n    return vec3(col.rgb)+vec3(0.1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nsphereRad = sin(iTime*0.4)*0.5+4.0;\n\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    highp vec3 cameraOrigin = vec3(-sin(sin(iTime*2.1)*0.2)*9.0+0.5,0.5+cos(iTime*2.1)*1.0,-18.0+sin(iTime*0.04)*10.0);\n    highp vec3 cameraDirection  = normalize(vec3( (fragCoord.x/iResolution.x*512.0-256.0),(fragCoord.y/iResolution.x*512.0-(iResolution.y/iResolution.x*256.0)), 300.0));\n\n    \n\tfragColor = vec4(colorForRay(cameraOrigin,cameraDirection),1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ls2XRG","date":"1413408109","viewed":169,"name":"Insert a Hidden Meaning Here","username":"caaaaaaarter","description":"A little demo with some raymarched cubes.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","reflection","cubes"],"hasliked":0,"parentid":"","parentname":""}}