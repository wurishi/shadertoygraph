{"ver":"0.1","info":{"id":"Wltczl","date":"1609770364","viewed":167,"name":"Gourd-Phong&&BlinnPhong","username":"Learner_CC","description":"on a gourd model","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","phongandblinphong"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// -------- define const para -------- //\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\n// -------- basic tool function -------- //\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n// ---- Rotation ---- //\nmat3 rot3_X(float theta) {\n    return mat3(1, 0,          0,\n                0, cos(theta), -sin(theta),\n                0, sin(theta), cos(theta));\n}\n\nmat3 rot3_Y(float theta) {\n    return mat3(cos(theta), 0,  sin(theta),\n                0,     1,     0,\n                -sin(theta), 0 , cos(theta));\n}\n\nmat3 rot3_Z(float theta) {\n    return mat3(-sin(theta), cos(theta), 0,\n                cos(theta),  sin(theta), 0,\n                0,           0,          1);\n}\n\n// -------- basic object SDF function -------- //\nfloat sphereSDF(vec3 samplePoint) {\n    return length(samplePoint) - 1.0;\n}\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sceneSDF(vec3 samplePoint) {\n    samplePoint.y -= 1.0;\n    float sphereDist1 = sphereSDF(samplePoint / 1.2) * 1.2;\n    vec3 morph = vec3(1.0, 1.25, 1.0);\n    float sphereDist2 = sphereSDF(samplePoint / 1.6  * morph + vec3(0.0, 1.4, 0.0)) * 1.2;\n    float cover = sdCappedCylinder(samplePoint - vec3(0.0, 1.4, 0.0), 0.22, 0.5);\n\n    float result = 0.0;\n    result = opSmoothUnion(sphereDist1, sphereDist2, 0.3);\n    result = opSmoothUnion(result, cover, 0.5);\n\n    return result;\n}\n\n// -------- rayMarching -------- //\nfloat rayMarching(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n            return depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec3 rayDirection(float fov, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n// -------- shading function -------- //\n\nstruct LightProperty {\n    float k_a;\n    float k_d;\n    float k_s;\n    float shiness;\n    \n    vec4 ambient;\n    vec4 diffuse;\n    vec4 specular;\n\n    vec3 lightPos;\n    float lightIntensity;\n};\n// ------- Phong -------- //\nvec4 PhongContribForLight(LightProperty light, vec3 p, vec3 eye) {\n    vec4 color = vec4(0.0);\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(light.lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n\n    float dotLN = max(dot(L, N), 0.0);\n    float dotRN = max(dot(R, N), 0.0);\n    // -------- Diffuse -------- //\n    color += light.k_d * dotLN * light.diffuse;\n    // -------- Specular -------- //\n    color += light.k_s * pow((dotRN), light.shiness) * light.specular;\n    color *= light.lightIntensity;\n    \n    return color;\n}\nvec4 PhongIllumination(LightProperty light, vec3 p, vec3 eye) {\n    vec4 color = vec4(1.0);\n    // Ambient\n    color = light.ambient * light.k_a;\n    \n    // -------- Light1 -------- //\n    light.lightPos = vec3(4.0 * sin(iTime),2.0,4.0 * cos(iTime));\n    light.lightIntensity = 0.8;\n    color += PhongContribForLight(light, p, eye);\n    \n    // -------- Light2 -------- //\n    light.lightPos = vec3(2.0 * sin(0.37 * iTime),2.0 * cos(0.37 * iTime), 2.0);\n    light.lightIntensity = 0.4;\n    color += PhongContribForLight(light, p, eye);\n\n    return color;\n}\n// ------- Blinn_Phong -------- //\nvec4 blinnPhongContribForLight(LightProperty light, vec3 p, vec3 eye) {\n    vec4 color = vec4(0.0);\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(light.lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 H = normalize(L + V);\n\n    float dotLN = max(dot(L, N), 0.0);\n    float dotNH = max(dot(N, H), 0.0);\n    // -------- Diffuse -------- //\n    color += light.k_d * dotLN * light.diffuse;\n    // -------- Specular -------- //\n    color += light.k_s * pow((dotNH), light.shiness) * light.specular;\n    color *= light.lightIntensity;\n    \n    return color;\n}\nvec4 blinnPhongIllumination(LightProperty light, vec3 p, vec3 eye) {\n    vec4 color = vec4(1.0);\n    // Ambient\n    color = light.ambient * light.k_a;\n    \n    // -------- Light1 -------- //\n    light.lightPos = vec3(4.0 * sin(iTime),2.0,4.0 * cos(iTime));\n    light.lightIntensity = 0.8;\n    color += blinnPhongContribForLight(light, p, eye);\n    \n    // -------- Light2 -------- //\n    light.lightPos = vec3(2.0 * sin(0.37 * iTime),2.0 * cos(0.37 * iTime), 2.0);\n    light.lightIntensity = 0.4;\n    color += blinnPhongContribForLight(light, p, eye);\n\n    return color;\n}\n// -------- camera view transform -------- //\nmat4 viewMatrix_MY(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // 从视点沿每个像素点设出光线 \n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, 10.0, 20.0);\n    mat4 viewToWorld;\n    viewToWorld = viewMatrix_MY(eye, vec3(0.0), vec3(0.0, 1.0, 0.0));\n\n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    float dist = rayMarching(eye, worldDir, MIN_DIST, MAX_DIST);\n\n    // 给空间中的点着色\n    vec3 p = eye + dist * worldDir;\n        \n    LightProperty light;\n    light.ambient = vec4(0.1, 0.1, 0.1, 1.0);\n    light.diffuse = vec4(0.7, 0.2, 0.2, 1.0);\n    light.specular = vec4(1.0, 1.0, 1.0, 1.0);\n    light.shiness = 20.0;\n    light.k_a = 1.0;\n    light.k_d = 1.0;\n    light.k_s = 1.0;\n\n\n    vec2 pic1 = gl_FragCoord.xy / iResolution.xy;\n    vec4 color =  blinnPhongIllumination(light, p, eye) * step(pic1.x, 0.5);\n    color += PhongIllumination(light, p, eye) * step(0.5, pic1.x);\n\n    fragColor = color;\n}","name":"Image","description":"","type":"image"}]}