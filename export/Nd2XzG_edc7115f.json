{"ver":"0.1","info":{"id":"Nd2XzG","date":"1620491333","viewed":502,"name":"8x8 No Texture Dither effect","username":"Shorakie","description":"Testing 8x8 dithering effect using internal array instead of using a texture.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["effect","dither"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 rotateUV(vec2 uv, float rotation)\n{\n    float mid = 0.5;\n    return vec2(\n        cos(rotation) * (uv.x - mid) + sin(rotation) * (uv.y - mid) + mid,\n        cos(rotation) * (uv.y - mid) - sin(rotation) * (uv.x - mid) + mid\n    );\n}\n\n// Cant initialize 2d array\nint dither0[8] = int[](0, 32, 8, 40, 2, 34, 10, 42);\nint dither1[8] = int[](48, 16, 56, 24, 50, 18, 58, 26); /* pattern. Each input pixel */\nint dither2[8] = int[](12, 44, 4, 36, 14, 46, 6, 38); /* is scaled to the 0..63 range */\nint dither3[8] =int[](60, 28, 52, 20, 62, 30, 54, 22); /* before looking in this table */\nint dither4[8] =int[]( 3, 35, 11, 43, 1, 33, 9, 41); /* to determine the action. */\nint dither5[8] =int[](51, 19, 59, 27, 49, 17, 57, 25);\nint dither6[8] =int[](15, 47, 7, 39, 13, 45, 5, 37);\nint dither7[8] =int[](63, 31, 55, 23, 61, 29, 53, 21);\n\nfloat find_closest(int x, int y, float c0)\n{\n    float limit = 0.0;\n    if(x == 0) limit = float(dither0[y]+1)/64.0;\n    else if(x == 1) limit = float(dither1[y]+1)/64.0;\n    else if(x == 2) limit = float(dither2[y]+1)/64.0;\n    else if(x == 3) limit = float(dither3[y]+1)/64.0;\n    else if(x == 4) limit = float(dither4[y]+1)/64.0;\n    else if(x == 5) limit = float(dither5[y]+1)/64.0;\n    else if(x == 6) limit = float(dither6[y]+1)/64.0;\n    else if(x == 7) limit = float(dither7[y]+1)/64.0;\n    \n    if (c0<limit) return 0.0;\n    return 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Rotation test\n    uv = rotateUV(uv, mod(iTime*1.0,2.0*3.14));\n\n    vec3 col = vec3(mix( -0.02, 1.02, uv.x));\n    \n    int x = int(mod(fragCoord.x,8.0));\n    int y = int(mod(fragCoord.y,8.0));\n    float bit = find_closest(x,y, col.r);\n    //col = vec3(x,y,0.0);\n    \n    \n    //col -= step(mod(uv.x+1.0/16.0, 1.0/8.0), 0.0025);\n    // Output to screen\n    fragColor = vec4(vec3(bit),1.0);\n}","name":"Image","description":"","type":"image"}]}