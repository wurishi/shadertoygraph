{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"float rand(vec2 n) {return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);}\n\nvec2 rotateVec(vec2 v, float b) {\n  return vec2(cos(b) * v.x + sin(b) * v.y, cos(b) * v.y - sin(b) * v.x);\n}\n\nvec4 get(vec2 coord) {\n  return texture(iChannel0, coord/iResolution.xy);\n}\n\nbool getFractal(vec2 pos, float t, vec4 modify){\n  for(int i = 0; i < int(10.0 + t * 10.0); i ++) {\n    pos *= 2.0;\n    if(pos.x < 1.0){\n      if(pos.y < 1.0){\n        return false;\n      } else {\n        pos = vec2(mod(pos.y, 1.0), mod(-pos.x, 1.0));\n      }\n    } else {\n      if(pos.y < 1.0){\n        pos = vec2(mod(pos.x * modify.x, 1.0), mod(pos.y * modify.y, 1.0));\n      } else {\n        pos = vec2(mod(pos.x * modify.z, 1.0), mod(pos.y * modify.w, 1.0));\n      }\n  }\n  }\n  if(pos.x < 0.5 && pos.y < 0.5) return false;\n  else return true;\n}\n\nvec2 transformPos(vec2 pos, float zoom, float t, float maxi) {\n  pos = (pos - iResolution.xy / 2.0) / (2.0 * maxi) / zoom;\n  pos = rotateVec(pos, -t * 6.2831853);\n  pos += vec2(0.2, 0.6);\n  return pos;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  float maxi = max(iResolution.x, iResolution.y);\n  float t = mod(iTime / 30.0, 1.0);\n  float zoom = pow(2.0, t * 8.0);\n  vec2 pos = gl_FragCoord.xy;\n\n  pos = transformPos(pos, zoom, t, maxi);\n\n  float modTimer = mod(iTime / 500.0, 1.0);\n  vec4 modifier = vec4(\n    step(1.0, mod(modTimer * 16.0, 2.0)),\n    step(1.0, mod(modTimer * 8.0, 2.0)),\n    step(1.0, mod(modTimer * 4.0, 2.0)),\n    step(1.0, mod(modTimer * 2.0, 2.0))\n  );\n  modifier = modifier * 2.0 - 1.0;\n  //modifier = vec4(-1.0, 1.0, -1.0, -1.0);\n\n  bool onFractal = getFractal(pos, t, modifier);\n  if(onFractal) { fragColor = vec4(1.0, 0.0, 0.5, 1.0); return;}\n  else {\n    fragColor = vec4(1.0);\n    vec4 sampleColor;\n    float r = 20.0 * rand(pos * 2.0) + 20.0;\n    for(int i = 1; i < int(r); i ++) {\n      if(fragCoord.x + float(i) > iResolution.x || fragCoord.y + float(i) > iResolution.y) return;\n      sampleColor = get(gl_FragCoord.xy + vec2(float(i)));\n      if(sampleColor.r - sampleColor.g > 0.9) {\n        fragColor = 0.5 * (1.0 - float(i) / r) * vec4(1.0, 0.0, 0.5, 1.0);\n        if(i > int(r - 2.0)) {fragColor = vec4(1.0, 0.0, 0.5, 1.0);}\n        break;\n      }\n    }\n  }\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MfdyRj","date":"1734020979","viewed":34,"name":"Infinite Fractals","username":"Rizzi001","description":"Some fractals that repeat infinitely","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["zoom","fractals"],"hasliked":0,"parentid":"","parentname":""}}