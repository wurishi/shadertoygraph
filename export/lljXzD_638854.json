{"ver":"0.1","info":{"id":"lljXzD","date":"1442246091","viewed":327,"name":"Funny Blob","username":"denosya","description":"Some fun, again.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["displacement"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"\nfloat map(in vec3 m) {\n    \n\tvec3 sphereCenter = vec3(cos(iTime*0.5)*sin(iTime*0.125)*4.0, 0.0, 20.0);\n    float radius = 4.0+sin(iTime*2.)*sin(iTime*0.125)*2.0;\n    \n    return length(m - sphereCenter) - radius + sin(m.x)*sin(m.y)*sin(m.z);\n}\n\nbool rayMarching(in vec3 origin, in vec3 ray, out vec3 m) {\n    \n    float\tmarchingDist = 0.0;\n    float \tnbIter \t\t = 0.0;\n\n    for(int i = 0; i<100; i++) {\n        \n        m = origin + ray * marchingDist;    \n        \n    \tfloat dist = map(m);\n        \n        if(dist < 0.01) {\n            return true;\n        }\n        else {\n            marchingDist += dist;\n            \n            if(marchingDist >= 30.0) {\n                break;\n            }\n        }\n    }\n    \n\treturn false;    \n}\n\n\nvec4 computeColor(in vec3 ro, in vec3 rd, in vec3 m, in vec3 normal) {\n    \n    vec3 light1 = normalize(vec3(1,1,1));\n    vec3 light2 = normalize(vec3(-1,1,1));\n\n    float diffuse1 = dot(normal, -light1);\n    float diffuse2 = dot(normal, -light2);    \n    \n    vec3 reflectedLight1  = reflect(light1, normal);\n    float hilight1 \t\t = pow(max(dot(reflectedLight1, -rd),0.0), 20.0);\n    \n    vec3 reflectedLight2  = reflect(light1, normal);\n    float hilight2 \t\t = pow(max(dot(reflectedLight2, -rd),0.0), 20.0);\n    \n    vec3 diffuseComponent1 = vec3(1.0, 0.0, 0.0) * diffuse1;\n    vec3 diffuseComponent2 = vec3(0.0, 0.0, 1.0) * diffuse2;    \n    vec3 hilightComponent = vec3(1.0, 1.0, 1.0) * max(hilight1, hilight2);    \n    vec3 ambiantComponent = vec3(0.2, 0.0, 0.0);       \n    \n    vec3 reflectray = reflect(m-ro, normal);\n    vec3 envmap \t= texture( iChannel0, reflectray).xyz;\n    \n    vec3 sphereColor = diffuseComponent1 + diffuseComponent2 + hilightComponent + ambiantComponent;\n    \n//    return vec4(mix(sphereColor, envmap, 0.0), 1.0);\n    return vec4(mix(sphereColor, envmap, 0.125), 1.0);\n}\n\n\n// IQ func <3\nvec3 computeNormal(in vec3 pos)\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t     map(pos+eps.xyy) - map(pos-eps.xyy),\n\t    map(pos+eps.yxy) - map(pos-eps.yxy),\n\t    map(pos+eps.yyx) - map(pos-eps.yyx));\n\treturn normalize(nor);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    vec3 rd\t= normalize(vec3(uv, 1.25));\n    vec3 ro =vec3(0);\n    \n    vec3\tm;\n    \n    if(rayMarching(ro, rd, m)) {\n        fragColor = computeColor(ro, rd, m, computeNormal(m));\n    }\n    else {\n        fragColor = texture(iChannel0, rd);        \n    }\n}","name":"Image","description":"","type":"image"}]}