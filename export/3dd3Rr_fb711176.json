{"ver":"0.1","info":{"id":"3dd3Rr","date":"1567652385","viewed":198,"name":"Grid Pattern Bombing - Scratches","username":"gressettd","description":"Written for clarity, not optimization. How to bomb a pattern (like a scratch) and hide the fact you're using grids with rotation, scaling, offsets, etc for each layer.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["grid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// with respect to https://www.shadertoy.com/view/4syXRD -- though this shader works\n// very differently\n\nfloat Random1D(float seed)\n{\n\treturn fract(sin(seed)*32767.0);\n}\n\nfloat Random1DB(float seed)\n{\n\treturn fract(sin(seed)* (65536.0*3.14159265359));\n}\n\nfloat Random3D(vec3 p)\n{\n    \n    vec3 comparator = vec3(\n\t\tfract(123456.34 * p.x), \n\t\tfract(78956.789 * p.y),\n\t\tfract(234512.987 * p.z));\n    \n\tfloat alignment = dot(p, comparator);\n\tfloat amplitude = sin(alignment) * 32767.0;\n\tfloat random = fract(amplitude + 0.001);\n\treturn random;\n}\n\nfloat Random2D(vec2 p)\n{\n\tvec2 comparator = vec2(\n\t\tfract(123456.34 * p.x), \n\t\tfract(78956.789 * p.y));\n    \n\tfloat alignment = dot(p, comparator);\n\tfloat amplitude = sin(alignment) * 32767.0;\n\tfloat random = fract(amplitude);\n\treturn random;\n}\n\nvec2 Random2DVector(vec2 p, float s)\n{\n    float x = fract(sin(dot(p,vec2(127.1,311.7)))*18.5453 * (1.0+s));\n    float y = fract(sin(dot(p,vec2(113.7,217.1)))*54.1853 * (2.0+s));\n    return vec2(x,y);\n}\n\nvec2 RandomVector2(float p) \n{\n    vec3 p3 = fract(p * vec3(443.8975, 397.2973, 491.1871));\n    p3 += dot(p3.xyz, p3.yzx + 19.19);\n    return fract(vec2(p3.x * p3.y, p3.z * p3.x));\n}\n\nvec2 Rotate2D(vec2 v, float a) \n{\n\t\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\n// IQ: https://iquilezles.org/articles/distfunctions2d\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b, float r )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n// IQ: https://iquilezles.org/articles/functions\nfloat Gain(float x, float k) \n{\n    float a = 0.5*pow(2.0*((x<0.5)?x:1.0-x), k);\n    return (x<0.5)?a:1.0-a;\n}\n\n// make a scratch in a grid cell\nfloat CellScratch(vec3 cell, vec2 ext, float seed, float waviness)\n{\n    \n    float cellID = cell.x;\n    vec2 cellCoord = cell.yz;\n    \n    float rnd = Random1D(cellID + seed);\n    float rnd2 = Random1DB(cellID);\n    \n    // some cells are empty\n    if(rnd > rnd2)\n        return 0.0;\n        \n    // make a random line in this cell\n    \n    // get a couple of random points we can shape\n    vec2 ra = Random2DVector(vec2(cellID,cellID), seed + (cellID * seed));\n    vec2 rb = Random2DVector(vec2(cellID,cellID), rnd + (cellID * rnd2));\n    \n    // let waviness randomly vary, but favor extremes of straighter or more bent\n    waviness = Gain(waviness * rnd2,1.4) * 6.28;\n    \n    // let's make this line mostly horizontal or vertical across the cell\n    // compute bending params based on h or v\n    vec2 pa,pb;\n    vec2 off;\n    float rot;\n    \n    // random pick\n    if(ra.x < rb.x)\n    {\n        // line will be horizontal\n        pa = vec2(0.0,ra.y);\n        pb = vec2(1.0,rb.y);\n        \n        \n        float waveAmp = pow(0.5,6.28*cellCoord.x);\n        float waveFreq = 3.14 * pow(waviness, cellCoord.x);\n        off = vec2(0.0, 0.5 + waveAmp * sin(waveFreq));\n        \n        rot = 1.2 * cos(cellCoord.x+ pa.y + pb.y);\n    } else\n    {\n        // line will be vertical\n        pa = vec2(ra.x, 0.0);\n        pb = vec2(rb.x, 1.0);\n        \n        float waveAmp = pow(0.5,6.28*cellCoord.y);\n        float waveFreq = 3.14 * pow(waviness, cellCoord.y);\n        off = vec2(0.5 + waveAmp * sin(waveFreq),0.0);\n        \n        rot = 1.2 * cos(cellCoord.y+ pa.x + pb.x);\n    }\n       \n    // make sure the line is visible\n    float pen = 2.0 / (float(iResolution.x) * ext.x);\n    \n    // distort the line for bending    \n    cellCoord = Rotate2D(cellCoord, rot);\n    cellCoord += off;\n    \n    // get distance to line\n    float dLine = sdLine(cellCoord, pa, pb, pen);\n    \n    float intensity = pow(clamp(-dLine,0.0,1.0), 0.05);\n    return intensity;\n}\n\n// apply multiple layers of scratches\nfloat BombScratches(\n    vec2 uv, float seed, float waviness,\n    int iterations, float lacunarity)\n{\n        \n    float intensity = 0.0;\n    float bombSeed = seed;\n    float scale = 1.0;\n    \n    for(int it = 0; it < 8; it++) \n    {\n        // rotate, scale, and offset a grid for this iteration.\n        vec2 pos = uv + vec2(3.0 * float(it+1) * Random1D(bombSeed));\n        float angle = 3.14159 * Random1D(bombSeed);\n        pos = Rotate2D(pos, angle);        \n        pos = pos * scale;\n                \n        // get current cell\n       \tvec2 cell = floor(pos);\n        float cellID = (10.0*Random2D(cell)) + (Random2D(floor(uv*scale)));\n\t\tvec2 cellCoords = fract(pos);\n        \n        vec2 extents = vec2(1.0/scale);\n\n        // get a scratch\n        float scratch = \n            CellScratch(\n                vec3(cellID, cellCoords), \n                extents,\n                bombSeed,\n            \twaviness);\n        \n        // dampen by layer depth\n        float depthScratch = scratch / scale;\n\n        intensity = max(depthScratch,intensity);       \n\n        // set up for next iteration\n        bombSeed = Random1D(bombSeed + seed +1.618);\n        scale *= lacunarity;\n    }\n                        \n    return intensity;\n}\n\nvec4 ComputeWaveGradientRGB(float t, vec4 bias, vec4 scale, vec4 freq, vec4 phase)\n{\n\tvec4 rgb = bias + scale * cos(3.14159 * 2.0 * (freq * t + phase));\n\treturn vec4(clamp(rgb.xyz,0.0,1.0), 1.0);\n}\n\n// antialias.\nfloat SmoothScratches(\n    vec2 uv, \n    float seed,\n    int iterations, \n    float lacunarity,\n    float waviness,\n\tfloat res)\n{\n    // using AA by Shane:\n    // https://www.shadertoy.com/view/4d3SWf\n    \n    const float AA = 4.0; \n\tconst int AA2 = int(AA*AA);\n\tfloat col = 0.0;\n\tvec2 pix = 2.0 / vec2(res,res) / AA; \n\n\tfor (int i = 0; i < AA2; i++) \n    {\n\n\t\tfloat k = float(i);\n        \n\t\tvec2 uvOffs = uv + vec2(floor(k / AA), mod(k, AA)) * pix;\n\t\tcol += BombScratches(uvOffs,seed,waviness,iterations,lacunarity);\n        \n\t}\n\n\tcol /= (AA*AA);\n\treturn col;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    \n    vec2 pos = fragCoord.xy / iResolution.x;\n    pos *= 2.0;\n   \tpos += vec2(1.0);\n    \n    // scroll right\n    pos.x += mod(iTime/6.0,12.0);\n    \n    // change random seed \n    const float duration = 6.0;\n    float seed = floor(iTime / duration);\n     \n    vec3 color;\n    \n    // shape   \n    float cc = SmoothScratches(pos, seed, 4, 1.2, 0.6, iResolution.y);\n    \n    // coloring\n    vec4 bias = vec4(0.5, 0.5, 0.5, 1.0);\n    vec4 scale = vec4(1.0, 1.0, 1.0, 1.0);\n    vec4 freq = vec4(1.0, 1.0, 1.0, 1.0);\n    vec4 phase = vec4(0.0, 0.3333, 0.6666, 1.0);\n    \n    vec4 col = vec4(0.0);\n    if(cc > 0.0) \n        col= cc * ComputeWaveGradientRGB(cc,bias,scale,freq,phase);\n    \n    col = pow(col,vec4(0.6));\n    \n       \n\tfragColor = vec4(col.xyz, 1.0);\n}","name":"Image","description":"","type":"image"}]}