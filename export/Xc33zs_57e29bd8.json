{"ver":"0.1","info":{"id":"Xc33zs","date":"1712006678","viewed":29,"name":"augub_sdf5","username":"augub","description":"s","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat2 rotation2D(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat dist_to_circle(vec2 p, float r){\n    return length(p) - r;\n}\n\nfloat dist_to_circle_at(vec2 p, vec2 c, float r){\n    return length(p-c) - r;\n}\n\nfloat dist_to_square(vec2 p, float b){\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nfloat dist_to_rotated_square(vec2 p, float theta, float b){\n    mat2 rotation = rotation2D(theta);\n    p = inverse(rotation)*p;\n    return dist_to_square(p, b);\n}\n\nfloat smoothmax(float a, float b, float l){\n    return log(exp(a*l)+exp(b*l))/l;\n}\n\nfloat dist_to_circle_and_square(vec2 p){\n    float d_square = dist_to_square(p, 0.5);\n    \n    // We translate the circle so it doesn't overlap with the square\n    float d_circle = dist_to_circle_at(p, vec2(sin(3.*iTime/7.) ,0.0), 0.5);\n    \n    float mini = min(d_square,d_circle);\n    float maxi = max(d_square, d_circle);\n    float sini = sin(3.*iTime/5.);\n    sini *= sini;\n    \n    return sini*mini + (1.-sini)*maxi;\n}\n\nfloat dist(vec2 p){\n    //float dist_to_box = sdBox(p+vec2(1.0,0.0), vec2(0.5, 0.5));\n    //float d_circle = dist_to_circle(p - vec2(sin(iTime),0.0), 0.4);\n    //return min(dist_to_box, d_circle);\n    //float d_circle_at = dist_to_circle_at(p, vec2(1.0,0.0), 0.5);\n    //float d_rotated_square = dist_to_rotated_square(p, 1.0, 0.5);\n    float d_both = dist_to_circle_and_square(p);\n    return d_both;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy*2. -1.;\n    \n    float maxDim = iResolution.x/iResolution.y;\n    if (maxDim < 1.){\n        maxDim /= 1./maxDim;\n    }\n    // Make the grid isotropic\n    uv.x *= iResolution.x/iResolution.y;\n\n   \n    // get the distance\n    float d = dist(uv);\n    \n    // Draw a black line at the edges\n    if (abs(d) < 0.01 || (mod(d, 0.1) < 0.005)){\n        fragColor = vec4(0.0);\n    }\n    else\n    {\n        if (d < 0.){\n            d = -mod(-d, 0.1)*10.;\n\n            fragColor = vec4(1.+0.5*d/maxDim,0.0,0.0,0.0);\n        }else{\n            d = mod(d, 0.1)*10.;\n\n            fragColor = vec4(0.0,1.-0.5*d/maxDim,0.0,0.0);\n\n        }\n    }\n    // Output to screen\n    \n}","name":"Image","description":"","type":"image"}]}