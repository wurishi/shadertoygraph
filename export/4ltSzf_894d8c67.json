{"ver":"0.1","info":{"id":"4ltSzf","date":"1480911548","viewed":107,"name":"Bryan's mushroom","username":"bsugiarto","description":"mushroom","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["mushroom"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float MATH_PI = float( 3.14159265359 );\n\n/* documented in sun */\nfloat VisibilityTerm( float roughness, float ndotv, float ndotl )\n{\n    float m2    = roughness * roughness;\n    float visV  = ndotl * sqrt( ndotv * ( ndotv - ndotv * m2 ) + m2 );\n    float visL  = ndotv * sqrt( ndotl * ( ndotl - ndotl * m2 ) + m2 );\n    return 0.5 / max( visV + visL, 0.00001 );\n}\n\n/*documented in sun */\nfloat DistributionTerm( float roughness, float ndoth )\n{\n    float m2    = roughness * roughness;\n    float d     = ( ndoth * m2 - ndoth ) * ndoth + 1.0;\n    return m2 / ( d * d * MATH_PI );\n}\n\n/* documented in sun */\nvec3 FresnelTerm( vec3 specularColor, float vdoth )\n{\n    vec3 fresnel = clamp( 50.0 * specularColor.y, 0.0, 1.0 ) * specularColor + ( 1.0 - specularColor ) * pow( ( 1.0 - vdoth ), 5.0 );\n    return fresnel;\n}\n\n/* documented in sun */\nvec3 LightSpecular( vec3 normal, vec3 viewDir, vec3 lightDir, vec3 lightColor, float roughness, vec3 specularColor )\n{\n    vec3 halfVec = normalize( viewDir + lightDir );\n\n    float vdoth = clamp( dot( viewDir,  halfVec  ), 0.0, 1.0 );\n    float ndoth = clamp( dot( normal,   halfVec  ), 0.0, 1.0 );\n    float ndotv = clamp( dot( normal,   viewDir  ), 0.0, 1.0 );\n    float ndotl = clamp( dot( normal,   lightDir ), 0.0, 1.0 );\n    \n    vec3    f = FresnelTerm( specularColor, vdoth );\n    float   d = DistributionTerm( roughness, ndoth );\n    float   v = VisibilityTerm( roughness, ndotv, ndotl );\n    \n    vec3 specular;\n    specular = lightColor * f * ( d * v * MATH_PI * ndotl );\n    return specular;\n}\n\n/* documented in sun */\nfloat Sphere( vec3 p, float s )\n{\n    return length( p ) - s;\n}\n\n/* used to create a box function */\nfloat Box( vec3 p, vec3 b )\n{\n    vec3 d = abs( p ) - b;\n    return min( max( d.x, max( d.y, d.z ) ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\n/* removes fu*/\nfloat Substract( float a, float b )\n{\n    return max( a, -b );\n}\n\n/* documented in sun */\nfloat UnionRound( float a, float b, float k )\n{\n    float h = clamp( 0.5 + 0.5 * ( b - a ) / k, 0.0, 1.0 );\n    return mix( b, a, h ) - k * h * ( 1.0 - h );\n}\n\n\n\n/* scene to make a mushroom */\nfloat Scene( vec3 p, mat3 localToWorld )\n{\n    p = p * localToWorld;\n    \n    float a = Sphere( p + vec3( -0.5, 0.0, 0.0 ), 1.6 );\n    float c = Box( p + vec3( -1.5, 0.0, 0.0 ), vec3( 1.5, 2.5, 2.5 ) );\n    float stem = Box( p + vec3( -1., 0.0, 0.0 ), vec3( .8, .2, .2 ) );\n    float ring2 = Substract( a, c );\n    float ring3 = UnionRound(ring2, stem, 1.);\n    return ring3;\n}\n\n/* documented in sun */\nfloat CastRay( in vec3 ro, in vec3 rd, mat3 localToWorld )\n{\n    const float maxd = 5.0;\n    \n    float h = 0.5;\n    float t = 0.0;\n   \n    for ( int i = 0; i < 50; ++i )\n    {\n        if ( h < 0.001 || t > maxd ) \n        {\n            break;\n        }\n        \n        h = Scene( ro + rd * t, localToWorld );\n        t += h;\n    }\n\n    if ( t > maxd )\n    {\n        t = -1.0;\n    }\n    \n    return t;\n}\n\n/* documented in sun */\nvec3 SceneNormal( in vec3 pos, mat3 localToWorld )\n{\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        Scene( pos + eps.xyy, localToWorld ) - Scene( pos - eps.xyy, localToWorld ),\n        Scene( pos + eps.yxy, localToWorld ) - Scene( pos - eps.yxy, localToWorld ),\n        Scene( pos + eps.yyx, localToWorld ) - Scene( pos - eps.yyx, localToWorld ) );\n    return normalize( -nor );\n}\n\n/* same main as sun except texture is modified */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x / iResolution.y;\n\n    vec3 rayOrigin  = vec3( 0.0, -0.28, -3.5 );\n    vec3 rayDir     = normalize( vec3( p.x, p.y, 2.0 ) );\n    \n    float theta = -0.5 * MATH_PI  ;\n    mat3 rotX = mat3(\n        vec3( cos( theta ), sin( theta ), 0.0 ),\n        vec3( -sin( theta ), cos( theta ), 0.0 ),\n        vec3( 0.0, 0.0, 1.0 )\n        );    \n    \n    vec2 mo = iMouse.xy / iResolution.xy;    \n    float phi = 0.25 * MATH_PI + 2.0 * iTime + 10.0 * mo.x;  \n    \n    mat3 rotY = mat3(\n        vec3( 1.0, 0.0, 0.0 ),\n        vec3( 0.0, cos( phi ), sin( phi ) ),\n        vec3( 0.0, -sin( phi ), cos( phi ) )\n        );\n    \n    mat3 localToWorld = rotX * rotY;    \n\n\n    vec3 color = texture( iChannel1, q ).yyy * 0.3;\n    \n    float t = CastRay( rayOrigin, rayDir, localToWorld );\n    if ( t > 0.0 )\n    {\n        vec3 pos = rayOrigin + t * rayDir;\n        vec3 normal = SceneNormal( pos, localToWorld );\n        vec3 lightDir = normalize( vec3( 0.5, 0.3, 1.0 ) );\n        vec3 lightColor = vec3( 1.6 );\n        \n        vec3 posLS = pos * localToWorld;\n        vec3 nrmLS = normal * localToWorld;\n        vec2 uvX = posLS.yz;\n        vec2 uvY = posLS.xz;\n        vec2 uvZ = posLS.xy;\n        \n        vec3 textureX = texture( iChannel0, uvX ).xyz;\n        vec3 textureY = texture( iChannel0, uvY ).xyz;\n        vec3 textureZ = texture( iChannel0, uvZ ).xyz;\n        \n        vec3 weights = max( abs( nrmLS ), 0.00001 );\n        weights /= weights.x + weights.y + weights.z;\n        \n        vec3 texture = textureX * weights.x + textureY * weights.y + textureZ * weights.z;\n     \n        vec3 diffuseColor = texture + vec3(.1,.1,.5);\n        diffuseColor *= diffuseColor * vec3( 0.94, 0.72, 0.47 ) * 1.5;\n        vec3 specularColor =  vec3( 0.04 ) ;\n        float roughness =  1.3 ;\n        \n        vec3 diffuse = lightColor * clamp( dot( normal, lightDir ), 0.0, 1.0 );\n        color = diffuseColor * ( diffuse + 0.2 );\n        color += LightSpecular( normal, rayDir, lightDir, lightColor, roughness, specularColor );\n\n    }\n    \n    fragColor = vec4( color, 1.0 );\n}\n\n","name":"Image","description":"","type":"image"}]}