{"ver":"0.1","info":{"id":"7tSyDw","date":"1649770933","viewed":72,"name":"20220412ray_sphere_intersections","username":"yoquo","description":"ray sphere intersections","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["etude"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float remap01(float a, float b, float t){\n    return (t-a)/(b-a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0.);\n    vec3 ro = vec3(0.);\n    vec3 rd = normalize(vec3(uv.x,uv.y,1.));\n    //vec3 rd = vec3(uv.x,uv.y,1.);\n    //正規化した値を出しているらしいけど、正規化ってなに\n    \n    //正規化しなくてもできる！？ちょっと汚くなる！！\n    \n    vec3 s = vec3(0.,0.,4.);//球の中心??を表すベクター\n    float r = 1.;\n    \n    float t = dot(s-ro,rd);\n    //dotメソッドは内積を出す。\n    //なんでこの二つの内積を出せばtが求まるのか分からん。\n    //vec3 p = ro + rd*t;　//ray-directionに媒介変数のtを掛けている。\n    vec3 p = ro + rd * t;\n    \n    float y = length(s-p);\n    \n    if(y<r){\n        float x = sqrt(r*r-y*y);//べくろる\n        //float t1 = t-x;　//t1とt2は球とrdベクトルの交わっている点。\n        float t1 = t-x;\n        float t2 = t+x;\n        \n        //float c = remap01(s.z-r,s.z,t1);\n        float c = remap01(s.z,s.z-r,t1);\n        col = vec3(c);\n    }\n    \n    fragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}