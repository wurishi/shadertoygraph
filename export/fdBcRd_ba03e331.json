{"ver":"0.1","info":{"id":"fdBcRd","date":"1643931807","viewed":310,"name":"ShallowWaterEqu_3b1d","username":"harry7557558","description":"My second attempt in buffer simulation. Try to simulate water ripples by solving the shallow water equation, which produces more details than the wave equation. However, it requires a much smaller time step to be stably integrated by the forward Euler.","likes":18,"published":1,"flags":32,"usePreview":0,"tags":["ripples","wave","simulation","water","equation","shallow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"WaveEquation_9ec8\" by harry7557558. https://shadertoy.com/view/sdBczG\n// 2022-02-03 15:29:13\n\n// Common: parameters and differential equation\n// Buffer A/B/C/D: forware Euler integration\n// Image: rendering\n\n\n// get vec4(u, dudx, dudy, 1)\nvec4 getVal(sampler2D sampler, vec2 xy) {\n    float h = getH(xy);\n    float hx1 = getH(xy+nds.xz);\n    float hx0 = getH(xy-nds.xz);\n    float hy1 = getH(xy+nds.zy);\n    float hy0 = getH(xy-nds.zy);\n    float hx = (hx1-hx0) / (2.*nds.x);\n    float hy = (hy1-hy0) / (2.*nds.y);\n    return vec4(h, hx, hy, 1);\n}\n\n// ray intersection with a box\nbool boxIntersection(vec3 ro, vec3 rd, out float tn, out float tf) {\n    vec3 inv_rd = 1. / rd;\n    vec3 n = inv_rd*(ro);\n    vec3 k = abs(inv_rd)*view_box;\n    vec3 t1 = -n - k, t2 = -n + k;\n    tn = max(max(t1.x, t1.y), t1.z);\n    tf = min(min(t2.x, t2.y), t2.z);\n    if (tn > tf) return false;\n    return true;\n}\n\n// raymarhing, return RGB\nvec3 render(vec3 ro, vec3 rd, float t0, float t1) {\n    float t = t0;\n    for (int i=0; i<64; i++) {\n        vec3 p = ro+rd*t;\n        vec4 vn = getVal(iChannel0, p.xy);\n        float dt = 0.6*(p.z-vn.x) / length(vn.yzw);\n        t += dt;\n        if (t<=t0 || t>=t1) return vec3(0.1);\n        if (abs(dt)<.001) break;\n    }\n    vec3 n = normalize(getVal(iChannel0, (ro+rd*t).xy).yzw);\n    rd = reflect(rd, n);\n    return vec3(0.5,0.5,1.0)*(.1+.5*n.z+.5*max(rd.z,0.));\n}\n\n// main\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0,0,0,1);\n#if 0\n    // 2D\n    vec2 xy = vec2(width,height)*fragCoord/iResolution.xy;\n    vec3 col = vec3(normalize(getVal(iChannel0,xy).yzw).z);\n    fragColor = vec4(col,1);\n#else\n    // 3D\n    float perspective = 4.0;\n    float scale = 0.6*height;\n    float rx = 0.15*PI;\n    float rz = -0.3*PI;\n    vec3 w = vec3(cos(rx)*vec2(cos(rz),sin(rz)), sin(rx));\n    vec3 u = vec3(-sin(rz),cos(rz),0);\n    vec3 v = cross(w,u);\n    vec3 ro = scale*perspective*w + view_box-vec3(0,0,0.1);\n    vec2 uv = 2.*fragCoord.xy/iResolution.xy - 1.;\n    vec3 rd = mat3(u,v,-w)*vec3(uv*iResolution.xy, perspective*iResolution.y);\n    rd = normalize(rd);\n    float t0, t1;\n    if (boxIntersection(ro-view_box, rd, t0, t1)) {\n        fragColor.xyz = render(ro, rd, t0, t1);\n    }\n#endif\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Forward Euler\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 xy = vec2(width,height)*fragCoord/iResolution.xy;\n\n    vec3 huv, huvt;\n    diffequ(iChannel0, time, xy, huv, huvt, uniforms_call);\n\n    huv += huvt * delta_t;\n\n    fragColor = vec4(huv, 0);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PI 3.1415927\n\n// pass uniform variables to common\n#define uniforms_params vec3 iResolution, vec4 iMouse, int iFrame\n#define uniforms_call iResolution, iMouse, iFrame\n\n// simulation dimension in meters\n#define height (2.)\n#define width (height*(iResolution.x/iResolution.y))\n#define view_box (.5*vec3(width,height,1))\n\n// time in seconds (60 fps)\n#define delta_t (0.01/60.)\n#define time (float(iFrame)*(delta_t))\n\n// sampling buffer\n#define getH(xy) (texture(sampler,(xy)/vec2(width,height)).x)\n#define getU(xy) (texture(sampler,(xy)/vec2(width,height)).y*((xy).x<=0.||(xy).x>=width?-1.:1.))\n#define getV(xy) (texture(sampler,(xy)/vec2(width,height)).z*((xy).y<=0.||(xy).y>=height?-1.:1.))\n\n// numerical differentiation step in meters\n#define nds vec3(vec2(width,height)/iResolution.xy,0)\n\n// used in initial condition and mouse interaction, integrates to 0\n#define bump(r) (cos(1.8483*(r))*exp(-(r)*(r)))\n\n\n// outputs (h,u,v), (∂h/∂t,∂u/∂t,∂v/∂t)\n// sampler wrap needs to be \"clamp\"\nvoid diffequ(sampler2D sampler, float t, vec2 xy,\n             out vec3 huv, out vec3 huvt,\n             uniforms_params) {\n\n    // parameters\n    const float h0 = 0.5;  // mean height (m)\n    const float g = 9.8;  // acceleration due to gravity (m/s²)\n    const float f = .0001;  // Coriolis coefficient (rad/s)\n    const float k = 0.1;  // viscous drag for velocity\n    const float nu = .001;  // kinematic viscosity (m²/s), 1e-6 in reality\n\n    // height of water surface\n    float h = getH(xy);\n    float hx1 = getH(xy+nds.xz);\n    float hx0 = getH(xy-nds.xz);\n    float hy1 = getH(xy+nds.zy);\n    float hy0 = getH(xy-nds.zy);\n    float hx = (hx1-hx0) / (2.*nds.x);\n    float hy = (hy1-hy0) / (2.*nds.y);\n\n    // horizontal velocity\n    float u = getU(xy);\n    float ux1 = getU(xy+nds.xz);\n    float ux0 = getU(xy-nds.xz);\n    float uy1 = getU(xy+nds.zy);\n    float uy0 = getU(xy-nds.zy);\n    float ux = (ux1-ux0) / (2.*nds.x);\n    float uy = (uy1-uy0) / (2.*nds.y);\n    float ulap = (ux1+ux0-2.*u)/(nds.x*nds.x) + (uy1+uy0-2.*u)/(nds.y*nds.y);\n\n    // vertical velocity\n    float v = getV(xy);\n    float vx1 = getV(xy+nds.xz);\n    float vx0 = getV(xy-nds.xz);\n    float vy1 = getV(xy+nds.zy);\n    float vy0 = getV(xy-nds.zy);\n    float vx = (vx1-vx0) / (2.*nds.x);\n    float vy = (vy1-vy0) / (2.*nds.y);\n    float vlap = (vx1+vx0-2.*v)/(nds.x*nds.x) + (vy1+vy0-2.*v)/(nds.y*nds.y);\n\n    // https://en.wikipedia.org/wiki/Shallow_water_equations#Non-conservative_form\n    float ht = -h*(ux+vy) -u*hx-v*hy;\n    float ut = -g*hx -u*ux-v*uy +nu*ulap -k*u+f*v;\n    float vt = -g*hy -u*vx-v*vy +nu*vlap -k*v-f*u;\n\n    // mouse interaction\n    if (iMouse.z > 0.) {\n        float r = 20.*length(xy-vec2(width,height)*iMouse.xy/iResolution.xy);\n        h += 8.*bump(r)*delta_t;\n    }\n\n    // initial state\n    if (iFrame < 1) {\n        float r = 20.*length(xy-vec2(.4,.3)*vec2(width,height));\n        h = h0 + .2*bump(r);\n        u = v = 0.;\n        ht = ut = vt = 0.;\n    }\n\n    // output\n    huv = vec3(h, u, v);\n    huvt = vec3(ht, ut, vt);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Forward Euler\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 xy = vec2(width,height)*fragCoord/iResolution.xy;\n\n    vec3 huv, huvt;\n    diffequ(iChannel0, time, xy, huv, huvt, uniforms_call);\n\n    huv += huvt * delta_t;\n\n    fragColor = vec4(huv, 0);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Forward Euler\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 xy = vec2(width,height)*fragCoord/iResolution.xy;\n\n    vec3 huv, huvt;\n    diffequ(iChannel0, time, xy, huv, huvt, uniforms_call);\n\n    huv += huvt * delta_t;\n\n    fragColor = vec4(huv, 0);\n}\n","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// Forward Euler\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 xy = vec2(width,height)*fragCoord/iResolution.xy;\n\n    vec3 huv, huvt;\n    diffequ(iChannel0, time, xy, huv, huvt, uniforms_call);\n\n    huv += huvt * delta_t;\n\n    fragColor = vec4(huv, 0);\n}\n","name":"Buffer D","description":"","type":"buffer"}]}