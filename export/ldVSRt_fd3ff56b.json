{"ver":"0.1","info":{"id":"ldVSRt","date":"1466096770","viewed":206,"name":"Cellular tunnel","username":"Tapisama","description":"A shader made for class by a clasmate and myself.\nBased on game Entwined. use left and right arrows to move one ball and up and down to move the other and go through the rings.\nCredits to iq, as most code is based on his exaples.","likes":7,"published":1,"flags":112,"usePreview":0,"tags":["raymarching","tunnel","worley","cellular","multipass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Points steps\n#define F_STEP 10.0\n#define S_STEP 20.0\n#define T_STEP 30.0\n\n#define ANG1 3.24\n#define ANG2 2.15\n#define ANG3 0.15\n#define ANG4 4.47\n#define ANG5 1.30\n\nfloat points;\n\n//Number of cell in X and Y\nvec2 cell=vec2(15.0,5.0);\n\n// storage register/texel addresses\nconst vec2 txBall1Angle = vec2(0.0,0.0);\nconst vec2 txBall2Angle  = vec2(1.0,0.0);\nconst vec2 txPoints  = vec2(3.0,0.0);\n\nfloat angle1;//for the ball position\nfloat angle2;//for the ball position\n\n/**************************************************\n Hash table(point position for each laittece cell)\n***************************************************/\nvec2 hash2(vec2 p)\n{\n    p.x = mod( p.x, 5.0 );\n    p.y = mod( p.y, 4.0 );\n\tfloat r = 523.0*sin(dot(p, vec2(53.3158, 43.6143)));\n\treturn vec2(fract(25.32354 * r), fract(15.25865 * r))*cos(cos(iTime));\n}\n\n\n\n/*******************************\n    \tDistances ecuations\n********************************/\n//Eculidean distance âˆšxÂ²+yÂ²\nfloat eDistance(vec2 s1, vec2 s2)\n{\n\treturn (sqrt((s2.x - s1.x) * (s2.x - s1.x) + (s2.y - s1.y) *(s2.y - s1.y)));\n}\n//Manhatan distance |x2-x1|+|y2-y1|\nfloat mDistance(vec2 s1, vec2 s2)\n{\n\treturn(abs(s2.x-s1.x)+abs(s2.y-s1.y));\n}\n//chebyshev distance max|x2-x1|+|y2-y1|\nfloat cDistance(vec2 s1, vec2 s2)\n{\n\treturn max(abs(s2.x-s1.x),abs(s2.y-s1.y));\n}\n\n\n/********************************\n\t\t   Worley noise\n*********************************/\nvec3 cellNoise(vec2 cell)\n{\n\tvec2 cellPoint = hash2(cell);\n\tvec2 fract = fract (cell);\n\tcell = floor(cell);\n\n    //Least distances to our point\n\tfloat sDis1 = 1.0/0.0;//Infity value\n\tfloat sDis2 = 1.0/0.0;//Infinity value\n\n\tfor (int i = -1; i < 2; ++i)\n    {     \n        for (int j = -1; j < 2; ++j)\n    \t{\n     \t\n     \t\tvec2 thisPoint = vec2(i,j)+hash2(cell+vec2(i,j));\n            \n            //--Choose scene level--//\n     \t\tfloat thisD;\n    \t\tif(points < F_STEP)\n            thisD = mDistance(thisPoint,fract);\n            else if(points < S_STEP)\n            thisD = eDistance(thisPoint,fract);     \n            else if(points < T_STEP)\n            thisD = mDistance(thisPoint,fract);\n            else \n            thisD = mDistance(thisPoint,fract);\n                \n                \n     \tif(thisD < sDis1)\n     \t{\n     \t\tsDis2 = sDis1;\n     \t\tsDis1= thisD;\n     \t}\n     \telse if(thisD < sDis2)\n     \t{\n     \t\tsDis2 = thisD;\n     \t}\n    }\n}\n\n     vec3 fcolor = vec3(sDis2-sDis1);\n     \t\n     return fcolor*5.0;\n}\n\n/****Functions for drawing a digit***********/\nfloat SampleDigit(const in float n, const in vec2 vUV)\n{\n    if( abs(vUV.x-0.5)>0.5 || abs(vUV.y-0.5)>0.5 ) return 0.0;\n\n    // digit data by P_Malin (https://www.shadertoy.com/view/4sf3RN)\n    float data = 0.0;\n         if(n < 0.5) data = 7.0 + 5.0*16.0 + 5.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n    else if(n < 1.5) data = 2.0 + 2.0*16.0 + 2.0*256.0 + 2.0*4096.0 + 2.0*65536.0;\n    else if(n < 2.5) data = 7.0 + 1.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n    else if(n < 3.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n    else if(n < 4.5) data = 4.0 + 7.0*16.0 + 5.0*256.0 + 1.0*4096.0 + 1.0*65536.0;\n    else if(n < 5.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n    else if(n < 6.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n    else if(n < 7.5) data = 4.0 + 4.0*16.0 + 4.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n    else if(n < 8.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n    else if(n < 9.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n    \n    vec2 vPixel = floor(vUV * vec2(4.0, 5.0));\n    float fIndex = vPixel.x + (vPixel.y * 4.0);\n    \n    return mod(floor(data / pow(2.0, fIndex)), 2.0);\n}\n\nfloat printInt( in vec2 uv, in float value )\n{\n    float res = 0.0;\n    float maxDigits = 1.0+ceil(.01+log2(value)/log2(10.0));\n    float digitID = floor(uv.x);\n    if( digitID>0.0 && digitID<maxDigits )\n    {\n        float digitVa = mod( floor( value/pow(10.0,maxDigits-1.0-digitID) ), 10.0 );\n        res = SampleDigit( digitVa, vec2(fract(uv.x), uv.y) );\n    }\n    else if(mod(points,10.0)==0.0 &&digitID==maxDigits )\n    {\n        float digitVa = mod( floor( value/pow(0.0,maxDigits-1.0-digitID) ), 1.0 );\n        res = SampleDigit( digitVa, vec2(fract(uv.x), uv.y) );\n    }\n    return res;\n}\n\n\n\n//smooth min function\nfloat smin( float a, float b, float k ){\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\n//sphere function\nfloat sphere( vec3 p)\n{\n  vec3 c1=vec3(3.0*cos(angle1),1.8*sin(angle1),0.0);\n  vec3 c2=vec3(3.0*cos(angle2),1.8*sin(angle2),0.0);\n    \n  return smin(length(p-c1)-0.5,length(p-c2)-0.5,5.0);\n}\n\n//torus function\nfloat torus( vec3 p, vec2 t )\n{\n  vec3 p1=p-vec3(3.0*cos(ANG1),1.8*sin(ANG1),30.0-mod(8.0*iTime,60.0));\n  vec3 p2=p-vec3(3.0*cos(ANG2),1.8*sin(ANG2),30.0-mod(7.0*iTime,50.0));\n  vec3 p3=p-vec3(3.0*cos(ANG3),1.8*sin(ANG3),30.0-mod(10.0*iTime,40.0));\n  vec3 p4=p-vec3(3.0*cos(ANG4),1.8*sin(ANG4),30.0-mod(5.0*iTime,80.0));\n  vec3 p5=p-vec3(3.0*cos(ANG5),1.8*sin(ANG5),30.0-mod(12.0*iTime,60.0));\n    \n  vec2 q1 = vec2(length(p1.xy)-t.x,p1.z);\n  vec2 q2 = vec2(length(p2.xy)-t.x,p2.z);\n  vec2 q3 = vec2(length(p3.xy)-t.x,p3.z);\n  vec2 q4 = vec2(length(p4.xy)-t.x,p4.z);\n  vec2 q5 = vec2(length(p5.xy)-t.x,p5.z);\n    \n  return min(length(q5)-t.y,\n             min(length(q4)-t.y,\n                 min(length(q3)-t.y,\n                     min(length(q1)-t.y,length(q2)-t.y)\n                    )\n                )\n            );\n}\n\n//raymarching function\nbool rayMarch(in vec3 origin, in vec3 direction,out vec3 point){//raymarching algorithm\n    float dist;//distance to object\n    float t=0.0;\n    for(int i=0; i<125/*lod*/; i++){\n        point=origin+direction*t;\n        //new point is distance since the origin in the direction\n     \tdist=min(sphere(point),torus(point,vec2(0.8,0.1)));//evaluate collision function (this will converge to 0)\n        t+=dist;//keep walking\n        if(dist<0.05){\n            return true;\n        }\n    }\n    return false;\n}\n\n//shading function\nvec3 light(in vec3 point, in vec3 camera, in vec3 normal){\n    vec3 light=camera;\n    vec3 albedo=vec3(0.6,0.3,0.83);//222,184,135\n    float lightInt=0.4;\n    vec3 lightDir;\n    vec3 reflected;\n    vec3 vision;\n    float n=50.0;\n    lightDir=normalize(light-point); //light font direction\n    reflected=reflect(-lightDir,normal); //reflected ray\n    vision=normalize(camera-point); //eye direction\n    vec3 ambientComp=albedo*lightInt;\n    vec3 diffuseComp=lightInt*albedo*clamp(dot(normal,lightDir),0.0,1.0);\n    vec3 specComp=albedo*pow(clamp(dot(reflected,vision),0.00001,3.0),n);\n    return ambientComp+diffuseComp+specComp;               \n}\n\n//obtain the normal of a depth function\nvec3 calcNormal( in vec3 x, in float eps )\n{\n    vec2 e = vec2( eps, 0.0 );\n    vec3 n = vec3(0.0,1.0,0.0);\n    return normalize( vec3( sphere(x+e.xyy) - sphere(x-e.xyy),\n                            sphere(x+e.yxy) - sphere(x-e.yxy),\n                            sphere(x+e.yyx) - sphere(x-e.yyx) ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 fragment = vec2(fragCoord.xy/iResolution.xy);\n    \n    //Setting up the center\n    vec2 p = fragment+vec2(-0.5,-0.5);\n    p.x*=iResolution.x/iResolution.y;\n    vec2 q = fragment -vec2(0.5,0.5);\n    \n    //load state from buffer\n    angle1=texture( iChannel1, (txBall1Angle+0.5)/iChannelResolution[1].xy ).x;//for the ball position\n\tangle2=texture( iChannel1, (txBall2Angle+0.5)/iChannelResolution[1].xy ).x;//for the ball position\n    points=texture( iChannel1, (txPoints+0.5)/iChannelResolution[1].xy ).x;\n    \n    //Radius for the tunnel \n    float r = length(p) * 0.9;\n    \n    //Angle for each pixel to the screen center\n    float a =  atan( p.x, p.y );\n    a *= (6.0 / 3.141596);\n    \n    //whatever, texture coords.\n\tvec2 uvp = vec2( 0.4/r + mod(iTime,cell.x), a);\t\n    if(uvp.x>cell.x) uvp.x=uvp.x-cell.x;\n\n\t//Number of cell in X and Y\n\tfragment.x*= cell.x;\n\tfragment.y*= cell.y;\n\n\t//Color of each fragment\n    vec3 color=cellNoise(uvp)+cos(iTime)*sin(iTime);\n\tif(color.x > 0.5)\n        color -= 0.5;\n    \n    \n    if(points < 16.0)\n    {\n    float colorScene = float(points)*0.10;\n    color = vec3(colorScene,0.0,1.0-colorScene)-color;\n    }\n    else if(points < 31.0)\n    {\n        float colorScene = float(points)*0.10-1.5;\n        color = vec3(1.5-colorScene,colorScene,0.0)-color;\n    }\n    else if(points < 46.0)\n    {\n        float colorScene = float(points)*0.10-3.0;\n        color = vec3(0.0,3.0-colorScene,colorScene)-color;\n    }\n\t else if(points < 61.0)\n    {\n        float colorScene = float(points)*0.10-4.5;\n        color = vec3(0.0,0.0,4.0-colorScene)-color;\n    }\n    \n    //vec3 finalColor\n    color *= r * 10.0;\n    color *= smoothstep(0.0,0.1, length(q));\n    \n    //raymarching\n    vec3 ray= normalize(vec3(p,1.0));//mapping 2D coord to 3D\n    vec3 camera= vec3(0.0, 0.0, -5.0);//camera moved back\n    vec3 point;\n    bool found;\n    \n    if(rayMarch(camera, ray, point)){\n        vec3 normal=calcNormal(point,0.05);\n       \tfragColor = vec4(light(point,camera,normal),1.0); \n    }\n    else        \n\t\tfragColor = vec4(color,1.0);\n    \n    float f = printInt( (fragment-vec2(-0.7,3.8)), points/10.0 );    \n    fragColor = vec4(mix( fragColor.xyz, vec3(1.0,1.0,1.0), f ),1.0);\n    f = printInt( (fragment-vec2(0.2,3.8)), mod(points,10.0) );    \n    fragColor = vec4(mix( fragColor.xyz, vec3(1.0,1.0,1.0), f ),1.0);\n\t\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Msf3WX","filepath":"https://soundcloud.com/freehiphopbeatsforyou/free-the-passion-hifi-chill","previewfilepath":"https://soundcloud.com/freehiphopbeatsforyou/free-the-passion-hifi-chill","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define ANG1 3.24\n#define ANG2 2.15\n#define ANG3 0.15\n#define ANG4 4.47\n#define ANG5 1.30\n\n// storage register/texel addresses\nconst vec2 txBall1Angle = vec2(0.0,0.0);\nconst vec2 txBall2Angle  = vec2(1.0,0.0);\nconst vec2 txPoints  = vec2(3.0,0.0);\n\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\n\nfloat isInside( vec2 p, vec2 c ) {//no idea\n    vec2 d = abs(p-0.5-c) - 0.5; \n    return -max(d.x,d.y); \n}\n\nfloat isInside( vec2 p, vec4 c ) {//idem \n    vec2 d = abs(p-0.5-c.xy-c.zw*0.5) - 0.5*c.zw - 0.5;\n    return -max(d.x,d.y);\n}\n\nvec4 loadValue( in vec2 re )//reads the texture\n{\n    return texture( iChannel2, (0.5+re) / iChannelResolution[2].xy, -100.0 );\n}\n\nvoid storeValue( in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )//writes the texture\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n\nvoid storeValue( in vec4 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float angle1=loadValue(txBall1Angle).x;//for the ball position\n\tfloat angle2=loadValue(txBall2Angle).x;//for the ball position\n  \tfloat points=loadValue(txPoints).x;\n    \n    if( iFrame==0 ){\n      angle1=3.141516;\n      angle2=0.0;\n      points=0.0;\n    }\n    \n    float moveRight1 = texture( iChannel0, vec2(KEY_RIGHT, 0.25) ).x;\n    float moveLeft1  = texture( iChannel0, vec2(KEY_LEFT, 0.25) ).x;\n    float moveRight2 = texture( iChannel0, vec2(KEY_UP, 0.25) ).x;\n    float moveLeft2 = texture( iChannel0, vec2(KEY_DOWN, 0.25) ).x;\n    \n    angle1 += 0.05*(moveRight1 - moveLeft1);\n    angle2 += 0.05*(moveRight2 - moveLeft2);\n    \n    /*Points control*/\n    if((pow(angle1-ANG1,2.0)<0.05 || pow(angle2-ANG1,2.0)<0.05)  \n       && pow(30.0-mod(8.0*iTime,60.0),2.0)<0.006){\n     \tpoints+=1.0;   \n    }\n    if((pow(angle1-ANG2,2.0)<0.05 || pow(angle2-ANG2,2.0)<0.05)  \n       && pow(30.0-mod(7.0*iTime,50.0),2.0)<0.006){\n     \tpoints+=1.0;   \n    }\n    if((pow(angle1-ANG3,2.0)<0.05 || pow(angle2-ANG3,2.0)<0.05)  \n       && pow(30.0-mod(10.0*iTime,40.0),2.0)<0.006){\n     \tpoints+=1.0;   \n    }\n    if((pow(angle1-ANG4,2.0)<0.05 || pow(angle2-ANG4,2.0)<0.05)  \n       && pow(30.0-mod(5.0*iTime,80.0),2.0)<0.006){\n     \tpoints+=1.0;   \n    }\n    if((pow(angle1-ANG5,2.0)<0.05 || pow(angle2-ANG5,2.0)<0.05)  \n       && pow(30.0-mod(12.0*iTime,60.0),2.0)<0.006){\n     \tpoints+=1.0;   \n    }\n    \n    fragColor = vec4(0.0);\n \n    storeValue( txBall1Angle, vec4(angle1,0.0,0.0,0.0), fragColor, fragCoord );\n    storeValue( txBall2Angle, vec4(angle2,0.0,0.0,0.0), fragColor, fragCoord );\n    storeValue( txPoints,     vec4(points,0.0,0.0,0.0), fragColor, fragCoord );\n   \n}","name":"Buf A","description":"","type":"buffer"}]}