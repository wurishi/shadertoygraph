{"ver":"0.1","info":{"id":"WtGGW1","date":"1578772537","viewed":145,"name":"celshading ? - #004","username":"Cewein","description":"a way to do celshading , done right ? still got error with the blue color","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["video","celshading","image","sobelfilter"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//we need to kernel for a proper sober filter image processing\n\n/*\nmat3 Gy = mat3(1.,0.,-1.,\n     2.,0.,-2.,\n     1.,0.,-1.);\n\nmat3 Gx = mat3(1.,2.,1.,\n     0.,0.,0.,\n     -1.,-2.,-1.);\n*/\n\nfloat pixelIntensity(vec3 color)\n{\n    return sqrt( color.x*color.x + color.y*color.y + color.z*color.z);\n}\n\n\nfloat mag(vec2 pixel, vec2 spacing)\n{\n\n    float magX = 0.;\n    float magY = 0.;\n    \n    float tl= pixelIntensity(texture(iChannel0,pixel + vec2(-spacing.x,spacing.y)).rgb);\n    float tm= pixelIntensity(texture(iChannel0,pixel + vec2(0,spacing.y)).rgb);\n    float tr= pixelIntensity(texture(iChannel0,pixel + vec2(spacing.x,spacing.y)).rgb);\n    \n    float ml= pixelIntensity(texture(iChannel0,pixel + vec2(-spacing.x,0)).rgb);\n    float mr= pixelIntensity(texture(iChannel0,pixel + vec2(spacing.x,0)).rgb);\n    \n    float bl= pixelIntensity(texture(iChannel0,pixel + vec2(-spacing.x,-spacing.y)).rgb);\n    float bm= pixelIntensity(texture(iChannel0,pixel + vec2(0,-spacing.y)).rgb);\n    float br= pixelIntensity(texture(iChannel0,pixel + vec2(spacing.x,-spacing.y)).rgb);\n    \n    float x =  tl + 2. * ml +  bl - tr - 2. * mr - br;\n    float y =  tl + 2. * tm +  tr - bl - 2. * bm - br;\n    \n    return sqrt((x*x)+(y*y));\n}\n\nfloat space = 0.75;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float magnitude = mag(uv, vec2(space/iResolution.x, space/iResolution.y)); \n    \n\tvec3 col = texture(iChannel0, uv).rgb * (1. - magnitude);\n    //col = texture(iChannel0, uv).rgb;\n    //col = vec3(magnitude);\n    \n    fragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MARCHING_STEP 64\n\n/////\n// SDF Operation function\n/////\n\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return q;\n}\n\n/////\n// Scene and primitive SDF function\n/////\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sceneSDF(vec3 samplePoint) {\n\n    samplePoint = opRep(samplePoint, vec3(5.));\n  \n    float res =sdBox(samplePoint, vec3(0.5));\n    res = min(res,sdTorus(samplePoint, vec2(1.25, 0.1)));\n    return res;\n   \n}\n\n\n/////\n// Ray function\n/////\n\nvec3 getCameraRayDir(vec2 uv, vec3 camPos, vec3 camTarget)\n{\n    // Calculate camera's \"orthonormal basis\", i.e. its transform matrix components\n    vec3 camForward = normalize(camTarget - camPos);\n    vec3 camRight = normalize(cross(vec3(0.0, 1.0, 0.0), camForward));\n    vec3 camUp = normalize(cross(camForward, camRight));\n     \n    float fPersp = 2.0;\n    vec3 vDir = normalize(uv.x * camRight + uv.y * camUp + camForward * fPersp);\n \n    return vDir;\n}\n\nvec3 rayDir(float fov, vec2 size, vec2 fragCoord)\n{\n    vec2 xy = fragCoord - size/2.0;\n    float z = size.y * 0.5 / tan(radians(fov)/ 2.0);\n    return normalize(vec3(xy,-z));\n}\n\nvec2 normalizeScreenCoords(vec2 screenCoord)\n{\n    vec2 result = 2.0 * (screenCoord/iResolution.xy - 0.5);\n    result.x *= iResolution.x/iResolution.y;\n    return result;\n}\n\n/////\n// Marching function\n/////\n\nfloat march(vec3 pos, vec3 direction, float start, float end, inout int i)\n{\n    float depth = start;\n    for(i = 0; i < MARCHING_STEP; i++)\n    {\n        float dist =  sceneSDF(pos + direction * depth);\n        if(dist < 0.001f)\n        {\n            //return depth;\n            break;\n        }\n        depth += dist;\n        if(depth >= end)\n            return end;\n    }\n    return depth;\n}\n\n\n/////\n// Main function\n/////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 at = vec3(0, 0, 0);\n    vec2 uv = normalizeScreenCoords(fragCoord);\n    vec3 pos = vec3(cos(iTime/10.) * 1.75 ,sin(iTime/15.),sin(iTime/10.) * 1.75);\n    \n    int i = 0;\n    \n    vec3 dir = getCameraRayDir(uv, pos, at);\n    \n    float dist = march(pos, dir, 0.f,200.f, i);\n    vec3 col = vec3(dist);\n    \n    col = vec3(0.75 + sin(iTime/10.), 0.515, 0.053 + cos(iTime/10.)) * float(i)/float(MARCHING_STEP);\n\n    \n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}