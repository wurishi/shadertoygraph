{"ver":"0.1","info":{"id":"DltGRB","date":"1682777283","viewed":215,"name":"Analytic Volumetric Lighting","username":"AkiAoki","description":"Volumetric Lighting is a popular 3D graphics technique used in game development which is usually implemented using Raymarching. However, Raytracing method can be used instead in some specific cases.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["volumetriclightingfograytracingraymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n* Copyright Aki Aoki, 2023\n*\n* This is a demo shader showing the difference between Raymarched and Raytraced versions of Volumetric Lighting\n* Article explaining all the math and idea can be found here: \n* https://medium.com/@akidevcat/analytic-volumetric-lighting-9d02cc6a95c7\n*/\n\n#define RAYTRACING_1D_OPTIMIZATION 1\n#define APPLY_HDR_CORRECTION 1\n#define HDR_EXPOSURE 5.0\n\nstruct Ray \n{\n    vec3 Origin;\n    vec3 Dir;\n};\n\nstruct Light\n{\n    vec4 Color;\n    vec3 Origin;\n    float Intensity;\n};\n\nfloat hash(float x)\n{\n    return fract(x * 5491.5916947 + 89.1280513);\n}\n\nmat4 ConstructWorldToLocalMatrix4x4(vec3 xAxis, vec3 yAxis, vec3 zAxis, vec3 wsOrigin)\n{\n    mat4 result;\n    result[0][0] = xAxis.x;\n    result[0][1] = yAxis.x;\n    result[0][2] = zAxis.x;\n    result[1][0] = xAxis.y;\n    result[1][1] = yAxis.y;\n    result[1][2] = zAxis.y;\n    result[2][0] = xAxis.z;\n    result[2][1] = yAxis.z;\n    result[2][2] = zAxis.z;\n    result[3][3] = 1.0;\n    vec3 translation = (result * vec4(wsOrigin, 0.0)).xyz;\n    result[0][3] = -translation.x;\n    result[1][3] = -translation.y;\n    result[2][3] = -translation.z;\n    return result;\n}\n\nfloat IntersectFloor(Ray ray, float floorHeight)\n{\n    float time = floorHeight - ray.Origin.y / ray.Dir.y;\n    return time;\n}\n\nfloat CalculateL0(vec3 point, Light light, float gamma)\n{\n    const float U = 0.0;\n    vec3 diff = point - light.Origin;\n    return gamma * light.Intensity / (dot(diff, diff) + U);\n}\n\nfloat CalculateL_3D(float x0, float y0, float z0, float x1, float y1, float z1, float dt, Light light, float gamma)\n{\n    const float U = 0.0;\n    float x0s = x0*x0;\n    float y0s = y0*y0;\n    float z0s = z0*z0;\n    float x1s = x1*x1;\n    float y1s = y1*y1;\n    float z1s = z1*z1;\n    float A = x0*x1+y0*y1+z0*z1;\n    float sqrt = sqrt(x1s*(U+y0s+z0s)+z1s*(x0s+y0s+U)+y1s*(x0s+z0s+U)-2.0*x0*x1*(y0*y1+z0*z1)-2.0*y0*y1*z0*z1);\n    return gamma * light.Intensity * (atan((A+dt*x1s+dt*y1s+dt*z1s)/sqrt) - atan(A/sqrt))/sqrt;\n}\n\nfloat CalculateL_1D(float x0, float y0, float dt, Light light, float gamma)\n{\n    const float U = 0.0;\n    float J = 1.0 / sqrt(U + y0*y0);\n    return gamma * light.Intensity * J * (atan(J*(dt+x0)) - atan(J*x0));\n}\n\nfloat RaytraceLight(Ray ray, float rayLength, Light light, float gamma)\n{\n#if RAYTRACING_1D_OPTIMIZATION\n    ray.Origin -= light.Origin;\n    vec3 xAxis = ray.Dir;\n    vec3 zAxis = normalize(cross(ray.Dir, -ray.Origin));\n    vec3 yAxis = normalize(cross(xAxis, zAxis));\n    \n    mat4 worldToLight = ConstructWorldToLocalMatrix4x4(xAxis, yAxis, zAxis, light.Origin);\n    ray.Origin = (worldToLight * vec4(ray.Origin, 1.0)).xyz;\n    \n    return CalculateL_1D(ray.Origin.x, ray.Origin.y, rayLength, light, gamma);\n#else\n    ray.Origin -= light.Origin;\n    return CalculateL_3D(ray.Origin.x, ray.Origin.y, ray.Origin.z, ray.Dir.x, ray.Dir.y, ray.Dir.z, rayLength, light, gamma);\n#endif\n}\n\nfloat RaymarchLight(Ray ray, float rayLength, Light light, float gamma)\n{\n    const int raymarchingSteps = 48;\n    float stepLength = rayLength / float(raymarchingSteps);\n    float offset = stepLength * hash(ray.Dir.x+ray.Origin.x + hash(ray.Dir.y+ray.Origin.y + hash(ray.Dir.z+ray.Origin.z)));\n    ray.Origin += ray.Dir * offset;\n    float result = 0.0;\n    for (int i = 0; i < raymarchingSteps; i++)\n    {\n        result += CalculateL0(ray.Origin, light, gamma) * stepLength;\n        ray.Origin += ray.Dir * stepLength;\n    }\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 skyColor = vec4(0.0, 0.0, 0.0, 1.0);\n    Light light = Light(vec4(1.0, 0.7, 0.6 + (sin(2.1 * iTime + 0.58125) + 1.0) * 0.5 * 0.4, 1.0), vec3(0,0,0), 1.0);\n    float gamma = 0.5;\n\n    float screenRatio = iResolution.x/iResolution.y;\n    float fovRatio = 1.0;\n    vec2 uv = 2.0 * fragCoord/iResolution.xy - 1.0;\n    vec3 camPos = vec3(0, 0, -(sin(iTime)+1.0)*10.0 - 0.1);\n    light.Origin.x = sin(iTime * 3.0) * 10.0;\n\n    vec3 rayDirection = normalize(vec3(screenRatio * uv.x, uv.y, fovRatio));\n    Ray ray = Ray(camPos, rayDirection);\n    \n    vec4 resultColor = skyColor;\n    \n    float depth = 300.0;\n    \n    // Raytrace floor\n    float floorHeight = -1.0;\n    float floorIntersectionTime = IntersectFloor(ray, floorHeight);\n    if (floorIntersectionTime > 0.0) \n    {\n        depth = min(floorIntersectionTime, depth);\n        skyColor = vec4(1.0);\n    }\n    \n    \n    float lightLuminance = 0.0;\n    \n    if (uv.x < 0.0)\n    {\n        // Left Part of Screen - Raytracing\n        lightLuminance = RaytraceLight(ray, depth, light, gamma);\n    }\n    else\n    {\n        // Right Part of Screen - Raymarching\n        lightLuminance = RaymarchLight(ray, depth, light, gamma);\n    }\n    \n    fragColor = vec4(light.Color*lightLuminance) + skyColor;\n    \n#if APPLY_HDR_CORRECTION\n    // Apply simple HDR correction\n    fragColor.rgb = 1.0 - exp(-HDR_EXPOSURE * fragColor.rgb);\n#endif\n}","name":"Image","description":"","type":"image"}]}