{"ver":"0.1","info":{"id":"Mssczj","date":"1489010462","viewed":462,"name":"water ripples","username":"t91","description":"click in the center of viewport","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["waterripples"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3  v_cam_pos = vec3(0.0, 1.0, -6.0);\nvec3  v_cam_forward = vec3(0.0, 0.0, 1.0);\nvec3  v_cam_right = vec3(1.0, 0.0, 0.0);\nvec3  v_cam_up = vec3(0.0, 1.0, 0.0);\nvec3  v_sundir = normalize(vec3(0.0, 0.3, 1.0));\nfloat f_near = 2.3;\n\n#define FLOOR 999\n#define INFINITY 99999.0\n#define NUM_SRC 5\n\nvec3 ToRay(in vec2 fragCoord, in mat3 m)\n{\n    float aspect = iResolution.x / iResolution.y;\n    vec2 invResolution = 1.0 / iResolution.xy;\n\tvec2 ndc = (fragCoord.xy * invResolution) * 2.0 - 1.0; \n\tvec3 ray = vec3(aspect * ndc.x, ndc.y, f_near);\n    \n\treturn m * normalize(ray);\n}\n\nfloat HeightAt(vec2 pos, int i)\n{\n    vec4 src[NUM_SRC];\n    src[0] = vec4(-20.0, 0.0, 10.0, 10.0);\n    src[1] = vec4(30.0, 0.0, 10.0, 10.0);\n    src[2] = vec4(0.0, -20.0, 10.0, 10.0);\n    src[3] = vec4(0.0, 40.0, 10.0, 10.0);\n    src[4] = vec4(10.0, 10.0, 15.0, 10.0);\n    \n    vec2 center = src[i].xy;\n    \n    float dist2center = 10.0 + distance(pos, center);\n    float attenuation = exp(-dist2center * 0.031);\n    \n    float strength = src[i].z * attenuation;\n    float freq = src[i].w;\n\n    float H =  sin( dist2center - (iTime * freq) ) * strength / dist2center;\n    \n    return H;\n}\n\nfloat HeightAt(vec2 pos)\n{\n    float sum = 0.0;\n    \n    for (int i = 0; i < NUM_SRC; ++i)\n    {\n        sum += HeightAt(pos, i);\n    }\n    \n    return sum;\n}\n\nfloat Scene(vec3 point, out int id)\n{\n    id = 0;\n    float distance = INFINITY;\n\n    float dist = point.y - HeightAt(point.xz);\n    \n\treturn dist;\n}\n\nvec4 March(vec3 start, vec3 ray, out int id)\n{   \n    float step = 0.0;\n    \n\tfor (int i = 0; i < 100; ++i)\n    {\n        start = start + (step * ray);\n        step = Scene( start, id );\n\n        if (step < 0.0005)\n        {\n            return vec4(start, float(i));\n        }  \n        \n        if (step > 30.0)\n        {\n        \tbreak;\n        }\n\n    }\n    \n    return vec4(0,0,0,-1);\n}\n\n\nfloat ShadowSample(vec3 pos)\n{\n    int id = -1;\n    float shadow = 1.0;\n    vec4 shadow_pos = March(pos + v_sundir * 80.0, -v_sundir, id);\n\n    if (shadow_pos.w < 0.0)\n        return 1.0;\n    \n    float distToShadowCaster = length(shadow_pos.xyz - pos.xyz);\n    \n    shadow = min(1.0, max(0.0, 1.0 - distToShadowCaster));\n    \n    \n    return shadow;\n}\n\nfloat Shadow(vec3 pos)\n{\n    return ShadowSample(pos);\n}\n\nvec3 Ambient()\n{\n\treturn vec3(1.0, 1.0, 1.0) * 0.3;\n}\n\nvec3 Diffuse(vec3 nrm)\n{\n\treturn dot(nrm, v_sundir) * vec3(1.0, 1.0, 1.0);\n}\n\nvec3 Opq(vec3 pos, int id)\n{\n\treturn vec3(1.0, 0.8, 0.3) * 2.0;\n}\n\nvec3 Reflection(vec3 ray, vec4 pos, vec3 nrm, int surface_id)\n{  \n    vec3 reflected = reflect(ray, nrm);\n    \n    int id = -1;\n    vec4 hit = March(pos.xyz + nrm*0.01, reflected, id);\n    \n    vec3 value = Opq(hit.xyz, id);\n    \n    if (hit.w < 0.0)\n    {\n        float sun = dot(reflected, v_sundir);\n        \n        vec3 a = vec3(0.0, 0.3, 1.0) * 2.0;\n        vec3 b = vec3(0.0, 0.3, 1.0) * 5.0;\n        \n\t\tvalue *= mix(a, b, 1.0 - sun);\n    }\n    \n    return value;\n}\n\nvec3 Fog(vec4 pos)\n{\n    if (pos.w < 0.0)\n        return vec3(0.0, 0.0, 0.0);\n    \n    float distance = length(pos.xyz - v_cam_pos);\n\n\treturn max(0.0, exp(-distance * 0.0014 )) * vec3(1.0, 1.0, 1.0);\n}\n\nvec3 Specular(vec3 pos, vec3 nrm)\n{\n    vec3 VertexToEye = normalize(v_cam_pos - pos);\n    vec3 LightReflect  = normalize(reflect(-v_sundir, nrm));\n    \n    float str = max(0.0, dot(VertexToEye, LightReflect));\n    \n\tvec3 spc = pow(str, 100.0) * vec3(1.0, 1.0, 1.0);\n    \n    return spc;\n}\n\nfloat AmbientOcclusion(vec4 pos)\n{\n\treturn (1.0-clamp(pow(pos.w / 100.0, 0.2), 0.0, 1.0));\n}\n\nmat3 CameraMatrix()\n{\n\tfloat radius = 30.0;\n    float param = iMouse.x * 0.6;//obalTime * 0.3;\n    \n    if (iMouse.z > 0.0)\n    {\n        v_cam_pos.x = 0.5 * iResolution.x - iMouse.x; //sin(param) * radius;\n    \tv_cam_pos.y = 20.0;//1.0 + iMouse.y * 0.01;\n    \tv_cam_pos.z = iMouse.y - 0.5 * iResolution.y;//cos(param) * radius;\n    }\n    else\n    {\n    \tv_cam_pos = vec3(0.0, 20.0, -50.0);\n    }\n    \n\n    v_cam_forward = vec3(0.0, -0.5, 1.0);//= -normalize(v_cam_pos);\n    v_cam_forward = normalize(v_cam_forward);\n\n    v_cam_right   = cross(v_cam_forward, v_cam_up);\n \n    mat3 m;\n    m[0] = v_cam_right;\n    m[1] = v_cam_up;\n    m[2] = v_cam_forward;\n    \n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tmat3 cam = CameraMatrix();\n\n    int id = -1;\n    \n    vec3 ray   = ToRay(fragCoord, cam);\n    vec4 pos   = March(v_cam_pos, ray, id);\n    \n    \n    \n    int id_alt = -1;\n    vec3 ray_A = ToRay(fragCoord + vec2(0.2, 0.0), cam);\n    vec3 ray_B = ToRay(fragCoord + vec2(0.0, 0.2), cam);\n    vec3 pos_A = March(v_cam_pos, ray_A, id_alt).xyz;\n    vec3 pos_B = March(v_cam_pos, ray_B, id_alt).xyz;\n    vec3 diff1 = normalize(pos.xyz - pos_A);\n    vec3 diff2 = normalize(pos.xyz - pos_B);\n    vec3 nrm = normalize(cross(diff1, diff2));\n\n    vec3  opq = Opq(pos.xyz, id);\n    vec3  rfl = Reflection(ray, pos, nrm, id);\n    vec3  spc = Specular(pos.xyz, nrm);\n    vec3  amb = Ambient();\n    vec3  dif = Diffuse(nrm);\n    vec3  fog = Fog(pos);\n    float shd = Shadow(pos.xyz);\n    \n    vec3 color;\n\n    color = (amb + dif * shd + (spc + rfl)) * opq;\n\n    color *= AmbientOcclusion(pos);\n    fragColor.xyz = color * fog;\n\n    //fragColor.xyz = opq.xyz;\n    fragColor.w = 1.0;  \n    \n}","name":"Image","description":"","type":"image"}]}