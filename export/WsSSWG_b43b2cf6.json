{"ver":"0.1","info":{"id":"WsSSWG","date":"1554795872","viewed":494,"name":"Gabor:  principle","username":"FabriceNeyret2","description":"Accumulation of Gabor splats (gauss*sin at random locations), optionally with some variation of orientation.\nmouse.x:  freq\nmouse.y: number of splats\n                key S:  then, mouse.y tunes spread of orientations instead. + key F: freq spread instead.","likes":10,"published":3,"flags":16,"usePreview":0,"tags":["complex","gabor"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// variant of https://shadertoy.com/view/XlsGDs\n// note that this is absolutely not a reference implementation:\n// no acceleration structure here, and thus very unnefficient !\n// For this, rather see https://www.shadertoy.com/view/ltByWc\n\nfloat NB = 10.;         // number or gabor blobs\nfloat SIZE   = 0.0566;  // .22 size of gabor blobs\nfloat SPREAD = 0.;      // .5  angular variation\n\n// --- utilities ------------------------------\n\n#define PI     3.14159265358979\n#define ISQRT2 0.7071067811865\n\nbool keyToggle(int ascii) {\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\n}\n\nfloat gauss(float x,float s) {\n    return exp(-.5*(x*x)/(s*s)); \n}\nfloat gauss(vec2 v,float s) { return gauss(v.x,s)*gauss(v.y,s); }\n\n\nfloat rndi(float i, float j) {\n    return fract(1e5*sin(i+3.*j+0.567));\n}\n\n\n// --- complex Gabor ------------------------------\nvec2 Gabor(vec2 pos, float freq, float a) {\n    float t = (keyToggle(64+20))? 0. : iTime; // 'T'\n    float g = gauss(pos,SIZE);\n    if (g < 1e-3) return vec2(0.);\n    vec2 dir = ISQRT2*(cos(a)*vec2(1.,1.)+ sin(a)*vec2(-1.,1.));\n    float phi = freq*dot(pos,dir) * 2.*PI - 10.*t;\n\n    return g*vec2(cos(phi),sin(phi)); // NB: only the real part is used, classically\n}\n\n// --- complex Gabor noise = kernel * point distrib\nvec2 GaborNoise(vec2 uv, float freq, float dir) {\n    vec2 f=vec2(0.); float fa=0.;\n\tfor (float i=0.; i<NB; i++) { \n\t\tvec2 pos = vec2(1.8*rndi(i,0.),rndi(i,1.));\n        float a = dir, F = freq;\n        if (!keyToggle(64+6))    // \"'F' key\n              a += SPREAD *PI * (2.*i/NB-1.);\n        else  F *= 1. + SPREAD *(2.*i/NB-1.) *.5;\n\t\tf += Gabor(uv-pos, F, a);\n\t}\n\treturn f *sqrt(200./NB); // /6.;\n}\n\n// ------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 U )\n{\n    // --- controls \n    vec2 R = iResolution.xy,\n        uv = U / R.y,\n     mouse = iMouse.xy / R;\n\tfloat freq = mix(10., R.x/10., mouse.x);\n    if (length(iMouse.xy)<10.) mouse.y = .5+.5*sin(iTime);\n    NB = 10. + 600. *pow( mouse.y, 3.);\n    if (keyToggle(64+19)) NB=600., SPREAD = mouse.y;      // 'S' key\n\t    \n    // --- Gabor noise = kernel * point distrib\n\tvec2 f  = .5 * GaborNoise(uv,freq,0.); \n    \n    // --- Normalize and display Gabor noise\n    fragColor = vec4(.5+.5*f.x);\n    \n}\n\n","name":"Image","description":"","type":"image"}]}