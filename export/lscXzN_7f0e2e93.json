{"ver":"0.1","info":{"id":"lscXzN","date":"1457993035","viewed":1399,"name":"Audio visualizer test","username":"pixartist","description":"Testing audio visualization","likes":22,"published":1,"flags":32,"usePreview":0,"tags":["test","audio","visualizer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy / iResolution.xy);\n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGRr","filepath":"/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3","previewfilepath":"/media/ap/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//settings\n\n#define volLo 0.0\n#define volHi 0.6\n#define bassMalus 0.3\n#define bassWiggleStart 0.7\n#define bassWiggleStrength 0.03\n\n#define samples 12\n\n#define baseSize 0.4\n#define ringSize 0.03\n#define outerGrowth 0.1\n#define innerGrowth 0.3\n\n#define colorDistortion 0.025\n#define colorDistortionSmooth 0.02\n\n#define downSampleSteps 220\n\n\nconst float pi = 3.14159265359;\nfloat volMin = 0.3;\nfloat volMax = 0.0;\nstruct sampler\n{\n    float s[samples];\n};\n\nvec3 map(float v, float edge, vec3 c1, vec3 c2, float t)\n{\n    float m = t / iResolution.x;\n    float d = v-edge;\n    float a = abs(d);\n    if(a <= m)\n    {\n        float b = ((d + m) * 0.5) / m;\n        return mix(c1, c2, smoothstep(0.0, 1.0, b));\n    }\n    else if ( d < 0.0)\n        return c1;\n    else\n        return c2;\n}\nvoid downSampled(out sampler res)\n{\n    \n    const int steps = downSampleSteps;\n    const int sps = steps / samples;\n    res;\n    float s = 1.0 / float(steps);\n    for(int j = 0; j < samples; j++)\n    {\n        for(int i = 0; i < sps; i++)\n        {\n            res.s[j] += texture(iChannel0, vec2(float(j * sps + i) * s, 0.25)).x;\n            \n        }\n        float n = sqrt(float(j) / float(samples));\n        float k = (1.0 - bassMalus) + n * bassMalus;\n        res.s[j] = (res.s[j] / float(sps)) * k;\n        if(res.s[j] < volMin)\n            volMin = res.s[j];\n        if(res.s[j] > volMax)\n            volMax = res.s[j];\n    }\n    volMin = max(volLo, volMin);\n    volMax = max(volHi, volMax);\n    for(int j = 0; j < samples; j++)\n    {\n        res.s[j] = pow(smoothstep(volMin, volMax, res.s[j]), 2.0);\n    }\n}\nfloat getSample(sampler s, float v)\n{\n    float at = max(0.0, v * float(samples));\n    int k = int(at);\n    float f = fract(at);\n    float a = 0.0;\n    for(int i = 0; i < samples + 1; i++)\n    {\n        if(i == k)\n        {\n            a = s.s[i];\n        }\n        else if(i == k + 1)\n        {\n            return mix(a, s.s[i], smoothstep(0.0, 1.0, f));\n        }\n    }\n    return s.s[samples-1];\n}\nfloat avgFrq(float from, float to)\n{\n    float st = (to - from) / 3.0;\n    float s = texture(iChannel0, vec2(from, 0.25)).x +\n                  texture(iChannel0, vec2(from + st, 0.25)).x +\n                  texture(iChannel0, vec2(from + st * 2.0, 0.25)).x +\n                  texture(iChannel0, vec2(from + st * 3.0, 0.25)).x;\n    return s * 0.25;\n}\nfloat normalizeAngle(float a)\n{\n    if(a > pi * 0.5)\n        a = pi - a;\n    if(a < -pi * 0.5)\n        a = - pi - a;\n    return 1.0 - ((a / (pi * 0.5)) + 1.0) * 0.5;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float bass = avgFrq(0.0, 0.1);\n    float s1 = min(pow((avgFrq(volLo, volHi) + bass) * 0.5, 8.0) * 10.0, 1.0);\n    \n    float wiggle =  max(0.0, bass - bassWiggleStart) * bassWiggleStrength;\n    vec2 uv = (fragCoord.xy / iResolution.xy) + vec2(sin(iTime * 180.0), cos(iTime * 173.0)) * wiggle;\n    vec2 ar = vec2(iResolution.x / iResolution.y, 1.0);\n    vec2 p = uv * ar;\n    p = p * 2.0 - ar;\n    float angle = atan(p.y, p.x);\n    float angle2 = angle - pi * 0.25;\n    angle = normalizeAngle(angle);\n    angle2 = normalizeAngle(angle2);\n    float d = length(p);\n    vec3 bg = vec3(0.0, 0.0, 0.0);\n    \n    sampler ds;\n    downSampled(ds);\n    \n    \n    float so = getSample(ds, angle);\n    float shadowIntens = 6.0;\n   \tfloat minCol = 0.02;\n    float maxCol = 0.2;\n    float innerBorder = s1 * innerGrowth * 0.7 * 0.3 + baseSize * 0.3;\n    float outerBorder = s1 * innerGrowth * 0.7 + baseSize;\n    vec3 sub = vec3(s1*0.2 * sqrt(d));\n    vec3 grad1 = vec3(0.01) + vec3(minCol + max(0.0, (0.5 - angle2)) * maxCol) * 2.0 * (pow(d / innerBorder, 2.0)) - sub;\n    vec3 grad2 = vec3(0.01) + vec3(minCol + max(0.0, (angle2 - 0.5)) * maxCol) * 2.0 * (d / outerBorder) - sub;\n    \n    float cds = colorDistortionSmooth * iResolution.x;\n    vec3 col1 = grad1;\n    float ring = ringSize + ringSize * sqrt(s1);\n    col1 = map(d, innerBorder, col1, grad2, 0.004 * iResolution.x); \n    col1 = map(d, outerBorder, col1, vec3(1.0), 0.003 * iResolution.x); \n    col1 = map(d, s1 * innerGrowth + baseSize + ring + so * (outerGrowth), col1 , vec3(1.0, 1.0, 0.0), 2.0 + so * cds);\n    col1 = map(d, s1 * innerGrowth + baseSize + ring + so * (outerGrowth + colorDistortion), col1 , vec3(1.0, 0.0, 0.0), 2.0 + so * cds);\n    col1 = map(d, s1 * innerGrowth + baseSize + ring + so * (outerGrowth + colorDistortion * 2.0), col1 , vec3(0.0, 0.0, 1.0), 2.0 + so * cds);\n    col1 = map(d, s1 * innerGrowth + baseSize + ring + so * (outerGrowth + colorDistortion * 3.0), col1 , vec3(0.0, 1.0, 0.0), 2.0 + so * cds);\n    col1 = map(d, s1 * innerGrowth + baseSize + ring - 0.002 + so * (outerGrowth + colorDistortion * 4.0), col1 , bg, 2.0 + so * cds);\n    \n    float m = 1.0;\n    for(int i = 0; i < 3; i++)\n    {\n        if(m < col1[i])\n            m = col1[i];\n    }\n    if(m > 0.0)\n    {\n        m = 1.0 / m;\n        col1.x *= m;\n        col1.y *= m;\n        col1.z *= m;\n    }\n    if(wiggle <= 0.0)\n\t\tfragColor = vec4(col1, 1.0);\n    else\n        fragColor = mix(texture(iChannel1, (fragCoord.xy / iResolution.xy)), vec4(col1, 1.0), 0.8);\n}","name":"Buffer A","description":"","type":"buffer"}]}