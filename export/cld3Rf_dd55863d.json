{"ver":"0.1","info":{"id":"cld3Rf","date":"1682878995","viewed":54,"name":"1 bounce ray tracer","username":"mooddood235","description":"wat","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Ray{\n    vec3 o;\n    vec3 d;\n};\n\nstruct Sphere{\n    vec3 o;\n    float r;\n};\n\nstruct HitInfo{\n    float t;\n    vec3 p;\n    vec3 n;\n};\n\nconst float PI = 3.14159265359;\nconst HitInfo NoHit = HitInfo(-1.0f, vec3(0.0f), vec3(0.0f));\nconst Sphere s = Sphere(vec3(0.0f, 0.0f, 2.0f), 1.0f);\n\nvec3 At(Ray ray, float t){\n    return ray.o + ray.d * t;\n}\n\nRay GenCameraRay(vec2 uv){\n    const float yFov = 60.0f;\n\n    float focalLength = iResolution.y / (2.0f * atan(yFov / 2.0f * PI/180.0f));\n\n    vec3 d = vec3(\n    -iResolution.x + 2.0f * iResolution.x * uv.x,\n    -iResolution.y + 2.0f * iResolution.y * uv.y, focalLength);\n    return Ray(vec3(0.0f), d);\n}\n\nHitInfo IntersectSphere(Ray ray, Sphere s){\n    vec3 oc = ray.o - s.o;\n    float a = dot(ray.d, ray.d);\n    float b = 2.0f * dot(oc, ray.d);\n    float c = dot(oc, oc) - s.r*s.r;\n    float discriminant = b*b - 4.0f*a*c;\n    \n    \n    if (discriminant < 0.0f) return NoHit;\n    else{\n        float t = (-b - sqrt(discriminant)) / (2.0f*a);\n        vec3 p = At(ray, t);\n        vec3 n = normalize(p - s.o);\n        return HitInfo(t, p, n);\n    }\n}\n\n// In Radians\nmat3 GetRotateY(float theta){\n    return mat3(\n        cos(theta), 0.0f, sin(theta),\n        0.0f, 1.0f, 0.0f,\n        -sin(theta), 0.0f, cos(theta)\n    );\n}\n\n// In Radians\nmat3 GetRotateX(float theta){\n    return mat3(\n        1.0f, 0.0f, 0.0f,\n        0.0f, cos(theta), -sin(theta),\n        0.0f, sin(theta), cos(theta)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    Ray ray = GenCameraRay(uv);\n    \n    HitInfo hitInfo = IntersectSphere(ray, s);\n    \n    mat3 yRot = GetRotateY(iTime * 13.0f * PI / 180.0f);\n    mat3 xRot = GetRotateX(iTime * 13.0f * PI / 180.0f);\n    \n    if (hitInfo.t >= 0.0f){\n        vec3 reflection = xRot * yRot * reflect(ray.d, hitInfo.n);\n        fragColor = texture(iChannel0, reflection);\n    }\n    else fragColor = texture(iChannel0, xRot * yRot * ray.d);\n}","name":"Image","description":"","type":"image"}]}