{"ver":"0.1","info":{"id":"Ns2GDt","date":"1618141456","viewed":1052,"name":"Surface Nets II","username":"kastorp","description":"buffered version of [url]https://www.shadertoy.com/view/3tKyzt[/url]\n\n","likes":46,"published":1,"flags":32,"usePreview":0,"tags":["voxel","gyroid","surfacenets"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Surface Nets II by Kastorp\n//\n//algorithm https://www.shadertoy.com/view/3tKyzt\n//rendering https://www.shadertoy.com/view/7djGDw\n//\n//TODO: make isosurface editable\n//------------------------------------------------\n\nint gFrame=0;\nfloat csz;\n//--------------------------\n\n\nconst vec3 dir[6] =vec3[6]\n(\n   vec3(1,0,0), vec3(0,1,0),vec3(0,0,1),\n   vec3(-1,0,0), vec3(0,-1,0),vec3(0,0,-1)\n);\n\nint     g_dirs;\nvec3[6] g_ng;\nvec3    g_m;\n\nconst float TK=.12; //edge thickness \nconst bool cover=true;\nvec2 mmin(vec2 a, vec2 b) {return (a.x<b.x?a:b);}\n\nvec2 mapVoxel(in vec3 p) {\n\n\n       vec2 shape = vec2(100.,0.);\n       if(g_dirs>=64) return vec2(sdBox(p- g_m,vec3(.5*csz)),1.);\n       for(int k =gFrame;k<6;k++) {\n          //show  surface edges      \n          if((g_dirs & (1<<k))>0) shape=mmin(shape, vec2( sdCapsule(p,g_m,g_ng[k] )-csz*TK/2. ,2.));\n       } \n\n        //show surface vertex \n       shape=mmin(shape,vec2( length(p- g_m)- csz*TK ,3.)); \n      \n       //simple coloring\n       return shape;\n}\n\nvec3 getNormal(in vec3 p) {\n    vec3 n=vec3(0.);\n    for(int i=gFrame;i<=2;i++){\n        vec3 e=  0.001* ((i==0)?vec3(1,0,0):(i==1)?vec3(0,1,0):vec3(0,0,1));\n        for(float j=-1.;j<=1.;j+=2.) n+= j*e* mapVoxel(p + j* e).x ;\n    }\n    return normalize(n);\n}\n\nvec4 VoxelHitPos(vec3 pos, vec3 ro, vec3 rd){\n    vec3 ri = 1.0/rd;\n\tvec3 rs = sign(rd);\n    vec3 mini = (pos-ro + 0.5*csz - csz*0.5*vec3(rs))*ri;\n    float t=  max ( mini.x, max ( mini.y, mini.z ) );\n    return vec4(t*rd+ro,t);\n}\n\nvec3 rayDirection(vec3 cameraDir, vec2 uv){\n    \n    vec3 cameraPlaneU = vec3(normalize(vec2(cameraDir.y, -cameraDir.x)), 0);\n    vec3 cameraPlaneV = cross(cameraPlaneU, cameraDir) ;\n\treturn normalize(cameraDir + uv.x * cameraPlaneU + uv.y * cameraPlaneV);\n\n}\n\nvec4 trace(vec3 ro,vec3 rd)\n{\n    //RAYTRACING BOUNDING BOX\n    vec2 tb= boxIntersection(  ro,  rd, vec3(csz*N*.50+.00001) ) ;\n    if(tb.y<0.) return vec4(0.);\n    \n    \n    //VOXEL TRAVERSAL\n    vec3 rs= sign(rd);\n    vec3 ri = 1./rd;\n\tvec3 rp=ro +  max(tb.x,0.)*rd;  \n    vec3 mp=floor(rp/csz)*csz;\n    vec3 sd = (mp-rp + 0.5*csz + sign(rd)*0.5*csz) *ri;\n    vec3 mask=vec3(0.);     \n    for (int i = 0; i < 200; i++) {\n         \n        mask = step(sd.xyz, sd.yzx) * step(sd.xyz, sd.zxy);\n\t\tsd += mask *  rs *ri*csz;\n        mp += mask *  rs*csz;\n        \n        rp = VoxelHitPos(mp,rp,rd).xyz+rd*.0001; \n        if(length(rp-ro)>tb.y) break; //outside bounding box\n        \n\n       vec4 data = getVoxel( mp/csz,iChannel0,iChannelResolution[0]); \n        g_dirs =int(data.a); \n        if(g_dirs>0 )  {\n            \n            g_m= data.xyz;       \n            \n           if(g_dirs<64) for(int k =gFrame;k<6;k++) {\n                     \n              if((g_dirs & (1<<k))>0) {\n              \n                  //get neighbour surface vertex along each direction\n                  g_ng[k] = getVoxel( mp/csz-dir[k],iChannel0,iChannelResolution[0]).xyz; \n                                                  \n               } \n           }\n            \n            //SDF RAYMARCHING INSIDE VOXEL\n            float t = 0.0;          \n            for (int iters=gFrame; iters < 30; iters++) {\n\n                vec3 p = rp + rd * t;\n\n                if(sdBox(p-mp-.5*csz,vec3(.5*csz))>0.) break;\n               \n                vec2 d = mapVoxel(p);\n                if (d.x < 0.001 ) return vec4(p,d.y);\n \n                t += d.x;\n            }\n        }\n\t} \n    return vec4(tb.x,tb.y,0.,0.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    csz = .5;\n\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2  m =  iMouse.x<=0. ? vec2(-0.3): (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y*3.14;\n    \n    gFrame=min(iFrame,0);\n\n    vec3 ro = vec3(sin(m.y+.76) * cos(-m.x), sin(m.y+.76) * sin(-m.x), cos(m.y +.76))*15.;\n    vec3 cd = -normalize(ro); \n    vec3 rd = rayDirection(cd ,uv);\n    \n    vec4 r= trace(ro,rd);\n    \n    if(r.a>0. ){\n            vec3 p =r.xyz, \n                 n = getNormal(p);\n                          \n             fragColor.rgb = (.3+ normalize(p)*.7)*(r.a>2.?1.:.5);\n                         \n             //https://www.shadertoy.com/view/ttGfz1\n             fragColor.rgb *= length(sin(n*2.)*.5+.5)/sqrt(3.)*smoothstep(-1.,1.,n.z);\n             fragColor = vec4(sqrt(clamp(fragColor, 0., 1.)));      \n    }\n    \n    else fragColor =mix(vec4(0.4,0.4,0.7,1.0),vec4(.2), (r.y-r.x)/L*1.2);\n    \n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//ISOSURFACE FUNCTION \n\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k)\n{\n    return smin(a, b, -k);\n}\n\n//https://www.shadertoy.com/view/4tVSzR\nfloat map(vec3 p)\n{\n    p*=.5;\n    float time=mod(iTime, 15.0)+2.;\n  \n    // Shane's variation\n    float d0=dot(sin(p),cos(p.yzx));\n       \n    float d2=length(p)-min(8.,time);\n    float d=smax(-d0,d2,3.);\n\n    return d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec3 voxelCoord = texToVoxCoord(floor(fragCoord), offset); \n   \n    if(iFrame<300) { \n        // gyroiid for the first 5 seconds\n        float data =map(voxelCoord);\n  \n        fragColor = vec4(data);\n    }\n    else\n    {\n        //pulsating after 5 secs\n        fragColor = getVoxel( voxelCoord,iChannel0,iChannelResolution[0]) +sin(float(iFrame)/60.)*.01;\n    }\n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\nconst float L= 30., //cube size\n            N= 30.; //number of voxel x side (TOT=N^3)\n\nvec3 offset = floor(vec3(0.,0.,-L/2.));\nconst vec2 packedChunkSize= ceil(sqrt(N) * vec2(1.25 ,0.8)); // iResolution.xy/iResolution.yx \nconst float heightLimit = packedChunkSize.x * packedChunkSize.y; //must be > N\n\n//-----------------------------------------\n// VOXEL CACHE FUNCTIONS from fb39ca4\n\nvec2 unswizzleChunkCoord(vec2 storageCoord) {\n \tvec2 s = floor(storageCoord);\n    float dist = max(s.x, s.y);\n    float o = floor(dist / 2.);\n    float neg = step(0.5, mod(dist, 2.)) * 2. - 1.;\n    return neg * (s - o);\n}\n\nvec2 swizzleChunkCoord(vec2 chunkCoord) {\n    vec2 c = chunkCoord;\n    float dist = max(abs(c.x), abs(c.y));\n    vec2 c2 = floor(abs(c - 0.5));\n    float o = max(c2.x, c2.y);\n    float neg = step(c.x + c.y, 0.) * -2. + 1.;\n    return (neg * c) + o;\n}\n\nfloat calcLoadDist(vec2 iResolutionxy) {\n    vec2  chunks = floor(iResolutionxy / packedChunkSize); \n    float gridSize = min(chunks.x, chunks.y);    \n    return floor((gridSize - 1.) / 2.);\n}\n\nvec3 texToVoxCoord(vec2 textelCoord, vec3 offset) {\n\n    vec2 packedChunkSize= packedChunkSize;\n\tvec3 voxelCoord = offset;\n    voxelCoord.xy += unswizzleChunkCoord(textelCoord / packedChunkSize);\n    voxelCoord.z += mod(textelCoord.x, packedChunkSize.x) + packedChunkSize.x * mod(textelCoord.y, packedChunkSize.y);\n    return voxelCoord;\n}\n\nvec2 voxToTexCoord(vec3 voxCoord) {\n    vec2 packedChunkSize= packedChunkSize;\n    vec3 p = floor(voxCoord);\n    return swizzleChunkCoord(p.xy) * packedChunkSize + vec2(mod(p.z, packedChunkSize.x), floor(p.z / packedChunkSize.x));\n}\n\nvec4  getVoxel(vec3 p,sampler2D iChannel,vec3 resolution) {\n    p.z-= offset.z;\n    if(p.z>heightLimit || p.z<0.){return vec4(0.);}  \n    return texelFetch(iChannel, ivec2(voxToTexCoord(p))  , 0); \n    //return texture(iChannel, (floor(voxToTexCoord(p)) + 0.5) /  (floor (resolution.xy)), 0.0);\n\n}\n\n//-----------------------------\n\n//Iq\nvec2 boxIntersection( in vec3 ro, in vec3 rd, in vec3 rad) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN>tF || tF<0.0) return vec2(-1.0); \n    \n    //vec3 normal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n    return vec2( tN, tF );\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b)\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) ;\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// SURFACE NET BUFFER\n\n\n struct GRIDCELL{     //calculated for each cube in the following sequence:\n   vec3 p[8];         //  1. cube vertex positions\n   float val[8];      //  2. isosurface value at each cube vertex\n   float nVertex;     //  3. number of vertex where val[]>0; if 0<nVertex<8  => surface cube\n   float nEdge;       //  4. number of cube edges with crossing \n   vec3 m;            //  5. surface vertex, as an average of all crossing edge positions\n   int dirs;          //  6. 6bit bitmask of surface edges from each cube;                        \n} ;\n\n\nconst vec3 v[8] =vec3[8]\n(\n   vec3(0,0,0), vec3(1,0,0),vec3(1,1,0),vec3(0,1,0),\n   vec3(0,0,1), vec3(1,0,1),vec3(1,1,1),vec3(0,1,1)\n);\n\nconst int  e[24] =int[24](\n   0,1,   1,2,  2,3,   3,0, \n   4,5,   5,6,  6,7,   7,4,   \n   0,4,   1,5,  2,6,   3,7);\n\nconst vec3 dir[6] =vec3[6]\n(\n   vec3(1,0,0), vec3(0,1,0),vec3(0,0,1),\n   vec3(-1,0,0), vec3(0,-1,0),vec3(0,0,-1)\n);\n\n\nint gFrame=0; \nvoid  getSurface(vec3 c, inout GRIDCELL g,float csz)\n{\n    \n    g.m=vec3(0.);\n    g.nVertex=0.;\n    g.nEdge=0.;\n    g.dirs=0;\n\n    //gFrame unrolling fails here...\n    for(int i=0;i<8;i++)\n    {\n\n        //1. cube vertex positions\n        vec3 vp=c*csz+  v[i]*csz ;\n        g.p[i]=vp;\n\n        //  2. isosurface value at each cube vertex\n        float val = //map(vp);\n                    getVoxel( c+  v[i] ,iChannel0,iChannelResolution[0]).x;\n         g.val[i]=val;\n        \n        //3. number of vertex where val[]>0;\n        g.nVertex+= (val<=0.?1.:0.);\n\n    }\n\n    c*=csz;\n    \n     if(g.nVertex>0. && g.nVertex<8.)\n     {\n\n          for(int i=gFrame;i<24;i+=2)\n          {\n              //  isosurface weights at each cube edge vertexes\n              float d1 = g.val[e[i]],\n                  d2 = g.val[e[i+1]],\n                  d= d1/(d1-d2);\n\n            //  4. number of cube edges with crossing \n             if(d1*d2<0.){\n                 g.nEdge++;\n                 g.m+= g.p[e[i+1]]*d + g.p[e[i]]*(1.-d);\n                 \n                 for(int k =gFrame;k<6;k++) {\n                     \n                     //  6. 6bit bitmask of surface edges from  each cube\n                     if(dot((g.p[e[i+1]] +g.p[e[i]])/2.- c -csz/2. , dir[k] )<0. )  g.dirs=g.dirs | (1<<k); \n                     \n                 }\n             }\n          }\n         \n        //  5. surface vertex, as an average of all crossing edge positions\n         g.m/= g.nEdge;\n         g.m = min(max(g.m,c),c+csz); //must be inside the cube\n         //g.m=c+csz/2.; //orthogonal connections\n    } else if(g.nVertex==8. ){\n        g.dirs=64;g.m=c+csz/2.;\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 voxelCoord = texToVoxCoord(floor(fragCoord), offset); \n       \n    GRIDCELL g;     \n    getSurface(voxelCoord,g,.5);  \n    fragColor = vec4(g.m,g.dirs);\n\n}","name":"Buffer B","description":"","type":"buffer"}]}