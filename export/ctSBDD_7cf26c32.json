{"ver":"0.1","info":{"id":"ctSBDD","date":"1694050149","viewed":163,"name":"wispy fog pixel city","username":"Carandiru","description":"isometric-ish\nexperimental\nnot optimized\nlooks good","likes":5,"published":3,"flags":32,"usePreview":1,"tags":["layers"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 color = texture(iChannel0, uv).rgb;\n    \n    fragColor = vec4(pow(color, vec3(1.0f/2.2f)),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// wispy fog pixel city\n\n#define RESOLUTION 256.0\n#define MAX_HEIGHT 0.25\n\n#define pi (3.141592653589793)\n#define GOLDEN_RATIO (1.618033988749894848204586834365638117720309179805762862135448622705260462818902449707207204189391137484754088075386891752126633862223536931793180060766726354433389086595939582905638322661319928290267880675208766892501711696207032221043216269548626296313614438149758701220340805887954454749246185695364864449241044320771344947049565846788509874339442212544877066057189033788811218482216986198774837979833214457138687519435064302184531910484810053706146806749192781911979399520614196634287544406437451237181921799983910159195618146751426912397489409071864942319615679452080980526767303517699677977504091090378155646968210243) // 1618033988\n#define GOLDEN_RATIO_ZERO (0.618033988749894848204586834365638117720309179805762862135448622705260462818902449707207204189391137484754088075386891752126633862223536931793180060766726354433389086595939582905638322661319928290267880675208766892501711696207032221043216269548626296313614438149758701220340805887954454749246185695364864449241044320771344947049565846788509874339442212544877066057189033788811218482216986198774837979833214457138687519435064302184531910484810053706146806749192781911979399520614196634287544406437451237181921799983910159195618146751426912397489409071864942319615679452080980526767303517699677977504091090378155646968210243)\n#define phi GOLDEN_RATIO\n#define iphi GOLDEN_RATIO_ZERO\n\nuvec2 murmur3( in uvec2 u )\n{\n  u ^= ( u >> 16 ); u *= 0x85EBCA6Bu;\n  u ^= ( u >> 13 ); u *= 0xC2B2AE35u;\n  u ^= ( u >> 16 );\n\n  return u;\n}\nvec2 unorm(uvec2 n) { return(fract(vec2(n) * (1.0 / float(0xffffffffU)))); }\n\nvec2 hash22(in vec2 m) \n{\n    uvec2 mu = floatBitsToUint(m * GOLDEN_RATIO) | 0x1u;\n\n    mu = murmur3(mu);\n\n    return(1.0f - unorm(mu));\n}\n\nfloat rand(in vec2 st) {\n  vec2 r = hash22(st) * GOLDEN_RATIO_ZERO;\n  return fract(abs(r.y-r.x) * 111.111111 * 111.111111 + r.y * 111.111111 + r.x);\n}\n\n#define saturate(a) clamp(vec3(0), vec3(1), a)\n\n//Sources: https://gist.github.com/yiwenl/745bfea7f04c456e0101, https://gist.github.com/sugi-cho/6a01cae436acddd72bdf\nvec3 hsv2rgb(vec3 c){\n\tvec4 K=vec4(1.,2./3.,1./3.,3.);\n\treturn c.z*mix(K.xxx,saturate(abs(fract(c.x+K.xyz)*6.-K.w)-K.x),c.y);\n}\n\n#define R iResolution.xy\n#define t iTime\n#define dt iTimeDelta\n#define ff float(iFrame)\n\n#define fma(a,b,c) (a*b+c)\nvec2 rotate( in vec2 p, in vec2 cossin )\n{\n\t#define c_ x\n\t#define s_ y\n\n\treturn( vec2(fma(p.x, cossin.c_, p.y * cossin.s_), fma(p.x, -cossin.s_, p.y * cossin.c_)) );\n\n\t#undef c_\n\t#undef s_\n}\nvec2 rotate( in vec2 p, in float angle )\n{\n    return rotate(p, vec2(cos(angle), sin(angle)));\n}\n\nvec2 diamondize(in vec2 uv, in float resolution) // original - dominionxvii - https://www.shadertoy.com/view/dlBfz1\n{\n    vec2 diamondUV = rotate(uv, radians(45.));\n    diamondUV = floor(diamondUV * resolution) / resolution;\n    diamondUV = rotate(diamondUV, -radians(45.));\n    \n    return diamondUV;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0f * fragCoord.xy / R - 1.0f;\n    uv.x *= iResolution.x / iResolution.y;\n    uv.x *= (1.0f - iphi);\n    uv.y *= iphi;\n    uv = rotate(uv - vec2(0.5f, -0.25f), radians(45.));\n\n    float bn = textureLod(iChannel0, (uv * R) / 1024.0f, 0.0f).r;\n    \n    vec2 diamond_resolution = diamondize(R, RESOLUTION);\n    float st = phi / length(diamond_resolution);\n    vec2 p = uv;\n    p = p * iphi;\n    p = floor(p * R) / diamond_resolution;\n    p += vec2(0.0f, st * bn);\n    \n    p.y += t * 0.1f;\n    \n    p = diamondize(p, RESOLUTION);\n    \n    vec2 ro = p;\n    \n    float l = 0.0f;\n    \n    float h0 = 0.0f;\n    for (float i = st; i < 1.0f; i += st) {\n    \n        float k = abs(sin(p.y * pi * 0.25f * t)) + 0.5f;\n        k = 1.0f - (0.5 + 0.5 * clamp(k, -1.0, 1.0));\n        float n = textureLod(iChannel1, p, 0.0f).r;\n        float h = (1.0f - n);\n        \n        h0 += (1.0f - h) * st + k * st;\n        l += step(h*n, 0.5f) * st * float(bool(int(p.y * R.y) & 1));\n        \n        p = rotate(p, radians(-45.0));\n        p += vec2(0, h * MAX_HEIGHT * st);        \n        p = rotate(p, radians(45.0));\n    }\n    \n    p = ro;\n    \n    float h1 = 0.0f;\n    for (float i = st; i < 1.0f; i += st) {\n    \n        float k = abs(sin(p.y * pi * 0.25f * t)) + 0.5f;\n        k = 1.0f - (0.5 + 0.5 * clamp(k, -1.0, 1.0));\n        float n = textureLod(iChannel1, p, 0.0f).r;\n        float h = (1.0f - n);\n       \n        h1 += (1.0f - h) * st + k * st;\n        l += step(h*n, 0.5f) * st * float(bool(int(p.y * R.y) & 1));\n        \n        p = rotate(p, radians(-45.0));\n        p += vec2(0, -h * MAX_HEIGHT * st);        \n        p = rotate(p, radians(45.0));\n    }\n    \n    p = ro;\n    \n    float dd = 0.0f;\n    \n    dd += abs(h1 - mix(h1, h0, 0.5f));\n    dd += abs(h0 - mix(h1, h0, 0.5f));\n    dd *= 0.5f;\n    dd = 1.0f - dd;\n    \n    dd = mix(h1, h0, dd);\n    \n    l = dd * dd * (1.0f - l);\n    l = l * rand(floor(iTime/p.x/25.0f + rand(p)) * p) * rand(p);\n\n    vec3 color = vec3(dd * iphi * 0.01f);\n    \n    const vec3 light_color = vec3(0.99f, 0.5f, 0.1f);\n    \n    color += light_color * l;\n    color += (1.0f - dd) * (1.0f - l);\n    color = color * color;\n    color = color * color;\n    color = color * color;\n    color += (1.0f - dd) * 0.02f;\n    color += light_color * l * dd;\n    color = color + color * color;\n    \n    fragColor = vec4(color,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}