{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"video","id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"//2013, George Toledo. Based on tons of glsl sandbox code with additions to make it a filter.\n//change lightMode and mess with N to change lighting. displaceMode lets cell noise be affected by texture brightness.\n//distance formula sets up a mix between linear and manhattan.\n//webGL and desktop both seem to optimize all conditional stuff fine on this computer.\n\n//webGL v0.1 Sep. 3, 2013 (desktop, 4/2/13)\n//webGL v0.2 Sep. 3, 2013 (desktop, 4/2/13). - set uv in main\n//webGL v0.3 Sep. 3, 2013 (desktop, 4/5/13). - adjust for vid\n\n#define density 35.00\n#define displaceMode 1\n#define displaceAmt .75\n#define lightMode 2\n//distFormula 0 is linear, 1 is manhattan, you can mix between\n#define distFormula 0.0\n#define uvOffset vec2(0.07,0.02)\n#define zoom 0.01\n//N vec4(0.) for no holes on facet\n#define N vec4(0.0,0.0,0.0,0.)\n\nfloat jitter;\n\nfloat jit(float jitter, float lum){\nif (displaceMode==0)\nreturn jitter=lum*displaceAmt;//more jitter in brighter areas\nelse if (displaceMode==1)\nreturn jitter=1.-lum*displaceAmt;//more jitter in darker areas\nelse\nreturn jitter=displaceAmt;//disregard texture in jitter creation\n}\n\n//uses cellular noise for jitter basis\n\n// Cellular noise (\"Worley noise\") in 2D in GLSL.\n// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.\n// This code is released under the conditions of the MIT license.\n// See LICENSE file for details, located in ZIP file here:\n// http://webstaff.itn.liu.se/~stegu/GLSL-cellular/\n\n// Permutation polynomial: (34x^2 + x) mod 289\nvec3 permute(vec3 x) {\n  return mod((34.0 * x + 1.0) * x, 289.0);\n}\n// Cellular noise, returning F1 and F2 in a vec2.\n// Standard 3x3 search window for good F1 and F2 values\nvec2 cellular(vec2 P, float jitter, float lum) {\n#define K 0.142857142857 // 1/7\n#define Ko 0.428571428571 // 3/7\n\n\tvec2 Pi = mod(floor(P), 289.0);\n \tvec2 Pf = fract(P);\n\tvec3 oi = vec3(-1.0, 0.0, 1.0);\n\tvec3 of = vec3(-0.5, 0.5, 1.5);\n\tvec3 px = permute(Pi.x + oi);\n\tvec3 p = permute(px.x + Pi.y + oi); // p11, p12, p13\n\tvec3 ox = fract(p*K) - Ko;\n\tvec3 oy = mod(floor(p*K),7.0)*K - Ko;\n\tvec3 dx = Pf.x + 0.5 + jit(jitter, lum)*ox;\n\tvec3 dy = Pf.y - of + jit(jitter, lum)*oy;\n\t\n\tvec3 d1 = mix(dx * dx + dy * dy,  abs(dx) + abs(dy), distFormula); // d11, d12 and d13, squared, mixed with not squared\n\tp = permute(px.y + Pi.y + oi); // p21, p22, p23\n\tox = fract(p*K) - Ko;\n\toy = mod(floor(p*K),7.0)*K - Ko;\n\tdx = Pf.x - 0.5 + jit(jitter, lum)*ox;\n\tdy = Pf.y - of + jit(jitter, lum)*oy;\n\tvec3 d2 = mix(dx * dx + dy * dy,  abs(dx) + abs(dy), distFormula); // d21, d22 and d23, squared\n\tp = permute(px.z + Pi.y + oi); // p31, p32, p33\n\tox = fract(p*K) - Ko;\n\toy = mod(floor(p*K),7.0)*K - Ko;\n\tdx = Pf.x - 1.5 + jit(jitter, lum)*ox;\n\tdy = Pf.y - of + jit(jitter, lum)*oy;\n\tvec3 d3 = mix(dx * dx + dy * dy,  abs(dx) + abs(dy), distFormula); // d31, d32 and d33, squared\n\t// Sort out the two smallest distances (F1, F2)\n\tvec3 d1a = min(d1, d2);\n\td2 = max(d1, d2); // Swap to keep candidates for F2\n\td2 = min(d2, d3); // neither F1 nor F2 are now in d3\n\td1 = min(d1a, d2); // F1 is now in d1\n\td2 = max(d1a, d2); // Swap to keep candidates for F2\n\td1.xy = (d1.x < d1.y) ? d1.xy : d1.yx; // Swap if smaller\n\td1.xz = (d1.x < d1.z) ? d1.xz : d1.zx; // F1 is in d1.x\n\td1.yz = min(d1.yz, d2.yz); // F2 is now not in d2.yz\n\td1.y = min(d1.y, d1.z); // nor in  d1.z\n\td1.y = min(d1.y, d2.x); // F2 is in d1.y, we're done.\n\treturn mix(sqrt(d1.xy),d1.xy,distFormula);\n}\n\nvec2 cellularID(vec2 P, float jitter, float lum) {\n\tvec2 Pi = mod(floor(P), 289.0);\n \tvec2 Pf = fract(P);\n\tvec3 oi = vec3(-1.0, 0.0, 1.0);\n\tvec3 of = vec3(-0.5, 0.5, 1.5);\n\tvec3 px = permute(Pi.x + oi);\n\tvec3 p = permute(px.x + Pi.y + oi); // p11, p12, p13\n\tvec3 ox = fract(p*K) - Ko;\n\tvec3 oy = mod(floor(p*K),7.0)*K - Ko;\n\tvec3 dx = Pf.x + 0.5 + jit(jitter, lum)*ox;\n\tvec3 dy = Pf.y - of + jit(jitter, lum)*oy;\n\tvec3 d1 = mix(dx * dx + dy * dy,  abs(dx) + abs(dy), distFormula); // d11, d12 and d13, squared, mixed with not squared\n\tp = permute(px.y + Pi.y + oi); // p21, p22, p23\n\tox = fract(p*K) - Ko;\n\toy = mod(floor(p*K),7.0)*K - Ko;\n\tdx = Pf.x - 0.5 + jit(jitter, lum)*ox;\n\tdy = Pf.y - of + jit(jitter, lum)*oy;\n\tvec3 d2 = mix(dx * dx + dy * dy,  abs(dx) + abs(dy), distFormula); // d21, d22 and d23, squared\n\tp = permute(px.z + Pi.y + oi); // p31, p32, p33\n\tox = fract(p*K) - Ko;\n\toy = mod(floor(p*K),7.0)*K - Ko;\n\tdx = Pf.x - 1.5 + jit(jitter, lum)*ox;\n\tdy = Pf.y - of + jit(jitter, lum)*oy;\n\tvec3 d3 = mix(dx * dx + dy * dy,  abs(dx) + abs(dy), distFormula); // d31, d32 and d33, squared\n  \n  \tfloat f1 = d1.x;\n\tvec2 ci = vec2(Pi.x - 1.0, Pi.y - 1.0);\n\tif (d1.y < f1) { f1 = d1.y; ci = vec2(Pi.x - 1.0, Pi.y); }\n\tif (d1.z < f1) { f1 = d1.z; ci = vec2(Pi.x - 1.0, Pi.y + 1.0); }\n\tif (d2.x < f1) { f1 = d2.x; ci = vec2(Pi.x      , Pi.y - 1.0); }\n\tif (d2.y < f1) { f1 = d2.y; ci = vec2(Pi.x      , Pi.y); }\n\tif (d2.z < f1) { f1 = d2.z; ci = vec2(Pi.x      , Pi.y + 1.0); }\n\tif (d3.x < f1) { f1 = d3.x; ci = vec2(Pi.x + 1.0, Pi.y - 1.0); }\n\tif (d3.y < f1) { f1 = d3.y; ci = vec2(Pi.x + 1.0, Pi.y); }\n\tif (d3.z < f1) { f1 = d3.z; ci = vec2(Pi.x + 1.0, Pi.y + 1.0); }\n\treturn mod(ci, 289.0);\n}\n\nvec3 hsv(const in float h, const in float s, const in float v) {\n\treturn mix(vec3(1.),clamp((abs(fract(h+vec3(3.,2.,1.)/3.)*6.-3.)-1.),0.,1.),s)*v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = (fragCoord.xy / iResolution.xy)*(1.-zoom)+uvOffset;\n\t//vec2 uv=(2.-vec2(-fragCoord.x,fragCoord.y)/iResolution.xy)*(1.-zoom)+uvOffset;\n\tvec4 tx=texture(iChannel0,uv);\n\tfloat lum=length(tx.rgb);\n\n\tvec2 position = uv * density;\n\tvec2 Fid = cellularID(position, jitter, lum);\n\tvec4 tx2=texture(iChannel0,Fid/density); \n \tvec2 F = cellular(position, jitter, lum);\n\tvec2 Fx = cellular(position-vec2(0.05,0.0), jitter, lum);\n\tvec2 Fy = cellular(position-vec2(0.0,0.05), jitter, lum);\n\n \t\n \tfloat nBasic = 0.1+(F.y-F.x);\n\n\tfloat facets = 0.1+abs(F.y*(N.x+N.y)-F.x);\n\tfloat facetsX = 0.1+abs(Fx.y*(N.x+N.z)-Fx.x);\n\tfloat facetsY = 0.1+abs(Fy.y*(N.x+N.w)-Fy.x);\n    \n\tvec3 normalFacet = vec3(facets - facetsX, facets - facetsY, 0.1);\n    vec4 fc = vec4(-dot(normalize(normalFacet),normalize(vec3((uv)-.5,-1.0))));\n\n\tif(lightMode==0){\n\tvec3 color = vec3(tx2.rgb);\n\tfragColor = vec4( color, 1.0);\n\t}\n\telse if(lightMode==1){\n\tvec3 color = vec3(tx2.rgb) * nBasic;\t\n\tfragColor = vec4( color, 1.0);\n\t}\n\telse if(lightMode==2){\n\tvec3 color = vec3(tx2.rgb) * fc.rgb;\t\n\tfragColor = vec4( color, 1.0);\n\t}\t\n\telse if(lightMode==3){\n\tvec3 color = normalize(normalFacet)+.5;\t\n\tfragColor = vec4( color, 1.0);\n\t}\n\n\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lsf3DS","date":"1378187189","viewed":1713,"name":"Voronoi Filter","username":"gtoledo3","description":"Takes input texture and \"voronoi\"-izes it. Based on code from glsl sandbox of unknown origin. From basic voronoi generation, I got input tex sampling going, the mix between formulas (manhattan, linear), and normal gen modes.","likes":24,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","linear","manhattan"],"hasliked":0,"parentid":"","parentname":""}}