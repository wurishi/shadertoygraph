{"ver":"0.1","info":{"id":"wltyRB","date":"1611140158","viewed":162,"name":"Heartbeat - ModelingTest","username":"willis","description":"Heartbeat ","likes":8,"published":1,"flags":64,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"llfXRN","filepath":"https://soundcloud.com/user-877012218/she-choos-type-beat-chill-rap-peep-lofi-sad-angry-beat-2019","previewfilepath":"https://soundcloud.com/user-877012218/she-choos-type-beat-chill-rap-peep-lofi-sad-angry-beat-2019","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Willis\n// Email: pingdaye@gmail.com\n// ArtStation: https://www.artstation.com/williswei\n// Youtube channel: https://www.youtube.com/channel/UCEJFX2S7ylhkLhtYAZM8hJw\n\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURF_DIST 0.01\n#define PI 3.141592\n#define TUA 6.283184\n#define saturate(a) clamp(a, 0., 1.)\n\n#define ENABLE_MOUSE 0\n#define AA 1\n\nmat2 Rot(float angle){\n    float s = sin(angle), c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\n\nfloat noise(vec3 x) {\n    const vec3 step = vec3(110, 241, 171);\n\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(dot(step, i + vec3(0, 0, 0))), hash(dot(step, i + vec3(1, 0, 0))), u.x),\n               mix( hash(dot(step, i + vec3(0, 1, 0))), hash(dot(step, i + vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(dot(step, i + vec3(0, 0, 1))), hash(dot(step, i + vec3(1, 0, 1))), u.x),\n               mix( hash(dot(step, i + vec3(0, 1, 1))), hash(dot(step, i + vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\nfloat fbm(vec3 x, int step) {\n    float v = 0.0;\n    float a = 0.5;\n    vec3 shift = vec3(100.);\n    \n    for (int i = 0; i < step; ++i) {\n        v += a * noise(x);\n        x = x * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nfloat smin(float a, float b, float t){\n    float h = clamp(0.5 + 0.5 * (b - a) / t, 0., 1.);\n    return mix(b, a, h) - t * h * (1.0 - h);\n\n}\n\nfloat sdBox( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdTorus(vec3 p, vec2 t){\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat sdSphere(vec3 p, vec4 s) {\n    return length(p - s.xyz) - s.w;\n}\n\nfloat sdGyroid(vec3 p, float scale, float bias, float Thickness){\n    p *= scale;\n    return abs(dot(sin(p), cos(p.zxy)) - bias) /scale - Thickness;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r ){\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n\nfloat sdRoundCone( vec3 p, float r1, float r2, float h ){\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat vessel(vec3 p, vec3 h, vec2 t){\n    vec3 q = p - clamp(p, -h, h);\n    //q = max(q,vec3(0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n    return sdTorus(q, t);\n}\n\nvec3 bend(vec3 p, float a){\n    vec3 q = vec3(Rot(a*p.y) * p.xy, p.z);\n    return q;\n}\nvec3 Twist(vec3 p, float a){\n    vec3 q = vec3(Rot(a*p.z) * p.xz, p.y);\n    return q;\n}\n\nvec2 GetDist(vec3 p){\n    vec2 d = vec2(0., 1.);\n    float t = iTime * 2. ;\n    float n = fbm(p + t*0.2, 1) * 0.5;\n    float n1 = fbm(p,3);\n    \n    float BoundingBox = sdBox(p, vec3(5., 5, 5)) ;\n    \n    float HeartBeat = max(sin(3.*t), -cos(6.*t-0.5)-1.);\n    float HeartPart1 = sdRoundCone(p+vec3(0., .8, 0.), 0.18, mix(0.58, 0.62, HeartBeat), 0.8) ;\n    float HeartPart2 = sdEllipsoid(p+vec3(0., -0.2, 0.2), vec3(mix(0.38, 0.4, HeartBeat), mix(0.38, 0.4, HeartBeat), 0.5)) ;\n    float Heart = smin(HeartPart1, HeartPart2, 0.02) ;\n    \n\n\n    float Gd1 = sdGyroid(p , 1.6 , 0.5 , 0.01 );\n    float Gd2 = sdGyroid(p , 0.6 , 0. , 0.02 );\n    Gd1 = max(Gd1, Gd2) ;\n    \n    float Gd3 = sdGyroid(p + n * 0.2, 3.6 , 0.5 , 0.0 );\n    float Gd4 = sdGyroid(p + n * 0.3 , 2.6 , 0.32 , 0.0 );//small vessel\n    Gd2 = max(Gd3, Gd4) * 0.7;\n\n    //Heart = smin(Heart, Gd2, 0.05);\n    //d.x = Heart;\n    //return d;\n    \n    float Gd = min(Gd1, Gd2)  ; \n   \n\n    d.x = max(BoundingBox, Gd); \n    \n    d.x = smin(d.x, Heart,0.1);\n    \n    // vessel(vec3 p, vec3 h, vec2 t)\n    \n    float Td = vessel(p - vec3(-0.2, 0.5, 0.), vec3(0., 0.5, 0.), vec2(0.12, 0.01));\n    float Td2 = vessel(bend(p - vec3(0.32, 0.45, 0.), -1.), vec3(0., 0.3, 0.0), vec2(0.10, 0.01));\n    float Td3 = vessel(Twist(bend(p - vec3(-0.08, 0.4, -0.2) , -1.5), -1.), vec3(0., 0.6, 0.0), vec2(0.08, 0.01));\n    \n    \n    Td = min(Td, min(Td3, Td2));\n    \n    if(Td < SURF_DIST) d.y = 2.;\n    \n    d.x = smin(d.x, Td, 0.1);\n    \n    return d;\n}\n\nvec3 GetNormal(vec3 p){\n    float d = GetDist(p).x;\n    vec2 e = vec2(0.001, 0);\n    vec3 n = normalize(d - vec3(\n                        GetDist(p - e.xyy).x,\n                        GetDist(p - e.yxy).x,\n                        GetDist(p - e.yyx).x\n                        ));\n    return n;\n}\n\nvec2 RayMarching(vec3 ro, vec3 rd){\n    vec2 d = vec2(0.,1.);\n    vec2 sd;\n    vec3 p = ro;\n    for(int i = 0; i < MAX_STEPS; i++){\n        p = ro + rd * d.x;\n        sd = GetDist(p);\n        if(sd.x < SURF_DIST || d.x > MAX_DIST) {\n            d.y = sd.y;\n            break;\n        }\n        d.x += sd.x;\n    }\n    return d;\n}\n\nvec3 Shading(vec2 d, vec3 ro, vec3 rd, vec2 uv){\n    vec3 p = ro + rd * d.x;\n    vec3 difCol = vec3(0.98, 0.03, 0.01) ;//* smoothstep(0.05, 0.08 ,fbm(p, 4));\n    vec3 difCol2 = vec3(0.98,0.35 ,0.15);\n    vec3 specCol = vec3(0.65, 0.2, 0.1);\n    vec3 col = difCol;\n    vec3 lightPos = vec3(5., 5. , -3.);\n    vec3 LightDir = normalize(lightPos - p);\n    vec3 DirToViewer = normalize(ro - p);\n    \n    vec3 normal = GetNormal(p);\n    vec3 HalfDir  = normalize(LightDir + DirToViewer);\n    vec3 reflDir = reflect(-LightDir, normal);\n    vec3 reflCol = texture(iChannel0, reflDir).rgb * mix(difCol, difCol2, smoothstep(1., 2. , d.y));\n  \n    /*vec3 texXZ = texture(iChannel2, p.xz*.5+.5).rgb;\n    vec3 texYZ = texture(iChannel2, p.yz*.5+.5).rgb;\n    vec3 texXY = texture(iChannel2, p.xy*.5+.5).rgb;\n    \n    vec3 n = abs(normal);\n    //n *= pow(n, vec3(1));\n    n /= n.x + n.y + n.z;\n    */\n    uv = vec2(atan(p.x, p.z)/TUA, p.y/5.)+0.5;\n    vec4 tex = texture(iChannel2, uv);\n\n    float dif = saturate(dot(normal, LightDir)) * 0.5 + 0.5;\n    dif *= dif*dif;\n    \n    difCol *= tex.rgb;//texXZ*n.x + texYZ*n.y + texXY*n.z;\n    difCol2 *= tex.rgb;\n    \n    vec3 spec = pow(saturate(dot(HalfDir, normal)), 50.) * specCol;\n    float fresnel = saturate(pow(1. - dot(normal, DirToViewer), 5.0)) ;\n    \n    col = vec3(dif) * mix(difCol, difCol2, smoothstep(1., 2. , d.y));//+ spec * specCol ;\n    \n    col = mix(col, reflCol, fresnel) + spec  ;\n    \n    //col = vec3(dif) * mix(difCol, difCol2, smoothstep(1., 2. , d.y)) + spec * specCol ;\n    \n    //col = col *(1. - fresnelTerm) + (reflCol) * fresnelTerm;\n    \n    vec2 ds = RayMarching(p + normal*SURF_DIST*2., LightDir);\n    if( ds.x < length(LightDir) ) col *= 0.65;\n    \n    return col;\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n    \n    #if ENABLE_MOUSE\n        vec2 M = iMouse.xy /iResolution.xy;\n    #endif\n    \n    float t = iTime;\n    \n    vec3 bg =  vec3(0.08, 0.001, 0.001) * (-uv.y + 0.5);\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(cos(iTime*0.1-0.5)*5.-1., 0, sin(iTime*0.1-0.5)*5.);//vec3(sin(iTime*0.2) * 0.3, cos(iTime) *0.05, -6.);\n    \n    #if ENABLE_MOUSE\n        ro.yz *= Rot(-M.y * PI + 1.);\n        ro.xz *= Rot(M.x * TUA);\n    #endif\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0,0), 1.);//normalize(vec3(uv , sin(iTime) * 0.05 + 1.05 ));\n   \n\n    vec2 d = RayMarching(ro, rd);\n    \n    float depth = d.x / MAX_DIST;\n    \n    if(d.x < MAX_DIST && depth < 0.1){\n    #if AA < 2\n        col = Shading(d, ro, rd, uv);\n    #else\n    \n        #define ZERO (min(iFrame,0))\n        for( int j=ZERO; j<AA; j++ )\n            for( int i=ZERO; i<AA; i++ )\n            {\n                vec2 uvoffs = ((vec2(i,j) - 0.5*iResolution.xy) / iResolution.y)/float(AA);\n                uvoffs = (uv + uvoffs);\n                col += Shading(d, ro, rd, uvoffs);\n            }   \n        col /= float(AA*AA);\n    #endif\n    }\n    col = mix(bg, col, smoothstep(0.01, 0.08, depth));\n    col = mix(bg, col, smoothstep(0.13, 0.01 ,depth));\n    \n    col = pow(col, vec3(.4545)); //gamma correction\n    \n\n    fragColor = vec4(col,0.0);\n}","name":"Image","description":"","type":"image"}]}