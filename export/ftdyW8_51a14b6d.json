{"ver":"0.1","info":{"id":"ftdyW8","date":"1659749694","viewed":205,"name":"Camel walking with castle v2","username":"tono","description":"Camel walking with castle","likes":6,"published":1,"flags":64,"usePreview":1,"tags":["camel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"MlBXRw","filepath":"https://soundcloud.com/tonoshake/castmele","previewfilepath":"https://soundcloud.com/tonoshake/castmele","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float pi = acos(-1.);\nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\nvec2 pmod(vec2 p, float r){float a = atan(p.x,p.y)+pi/r;float n = (pi*2.)/r;return p*rot(-(floor(a/n)*n));}\n\n//https://neort.io/art/bpu6m8c3p9fefb925910?index=182&origin=my_profile\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n                   dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\nfloat noise(vec2 st) \n{\n    vec2 p = floor(st);\n    vec2 f = fract(st);\n    vec2 u = f*f*(3.0-2.0*f);\n\n    vec2 v00 = random2(p+vec2(0,0));\n    vec2 v10 = random2(p+vec2(1,0));\n    vec2 v01 = random2(p+vec2(0,1));\n    vec2 v11 = random2(p+vec2(1,1));\n\n    return mix( mix( dot( v00, f - vec2(0,0) ), dot( v10, f - vec2(1,0) ), u.x ),\n                 mix( dot( v01, f - vec2(0,1) ), dot( v11, f - vec2(1,1) ), u.x ), \n                 u.y)+0.5;\n}\n\nfloat fbm (vec2 st) \n{\n    float f = 0.;\n    vec2 q = st/2.;\n    for(int i = 0 ;i < 2;i++){\n        f += noise(q)/pow(2.,float(i));\n        q = q * (2.00+float(i)/100.);\n    }\n\n    return f;\n}\n//-----------------------------------------------------\nvec2 smoothpmod(vec2 p, float r,float e)\n{\n    float a = atan(p.x,p.y)+pi/r;\n    float n = (pi*2.)/r;\n    float angle = floor(a/n)*n;\n    float x = a/n * n;\n    x = a/n;\n    angle = floor(x) + pow(fract(x),e);\n    vec2 rp = p * rot(-( angle * n ));\n    \n    //rp.x = sin(a * pi);\n    return rp;\n}\n//https://iquilezles.org/articles/smin/\nfloat sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nvec2 sminCubic2( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    float m = h*h*h*0.5;\n    float s = m*k*(1.0/3.0); \n    return (a<b) ? vec2(a-s,m) : vec2(b-s,1.0-m);\n}\n//https://iquilezles.org/articles/distfunctions/\nfloat sdCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n  float rba  = rb-ra;\n  float baba = dot(b-a,b-a);\n  float papa = dot(p-a,p-a);\n  float paba = dot(p-a,b-a)/baba;\n  float x = sqrt( papa - paba*paba*baba );\n  float cax = max(0.0,x-((paba<0.5)?ra:rb));\n  float cay = abs(paba-0.5)-0.5;\n  float k = rba*rba + baba;\n  float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n  float cbx = x-ra - f*rba;\n  float cby = paba - f;\n  float s = (cbx<0.0 && cay<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(cax*cax + cay*cay*baba,\n                     cbx*cbx + cby*cby*baba) );\n}\n\n// https://gam0022.net/blog/2019/06/25/unity-raymarching/\n#define ITERATIONS 4\nfloat deMengerSponge2(vec3 p, vec3 offset, float scale) {\n    vec4 z = vec4(p, 1.0);\n    for (int i = 0; i < ITERATIONS; i++) {\n        z = abs(z);\n        //if (z.x < z.y) z.xy = z.yx;\n        if (z.x < z.z) z.xz = z.zx;\n        if (z.y < z.z) z.yz = z.zy;\n        z *= scale;\n        z.xyz -= offset * (scale - 1.0);\n        if (z.z < -0.5 * offset.z * (scale - 1.0))\n            z.z += offset.z * (scale - 1.0);\n    }\n    return (length(max(abs(z.xyz) - vec3(1.0, 1.0, 1.0), 0.0))) / z.w;\n}\n\n//ID list\n#define GROUND 0.\n#define CAMEL 1.\n#define CASTLE 2.\n\nvec2 ground(vec3 p){\n\tfloat o = -p.y - 1.2;\n    o -= noise(p.xz * .1) * .4;\n    p.xy *= rot(3.3);\n    \n    o -= noise(p.xz * .05)*6.;\n    //o -= fbm(p.xz / 30.) * 7. - 4.5;\n    \n    if(o < .3)\n    {\n        p.xz *= rot(length(p)/20. + 0.3);\n        o -= fbm(p.xz * 4.)/19.;\n        p.xz *= rot(length(p)/20.);\n        //p.xz *= rot(sin(length(p.xz)/10. + sin( sin(length(p.xz * 1.) + 50.3) * 2.1 ) ) / 2.);\n        o -= fbm(p.xz * 2. + fbm(p.xz * 1.))/20.;\n    }\n    return vec2(o,GROUND);\n}\n\nfloat camelLeg(vec3 p ,float a0, float a1,float a2 ,float a3)\n{\n    float o = 10.;\n    p.y -= 1.;\n    p += vec3(-1.,6.1,0.);\n    \n    vec3 op = p;\n    vec3 fp = p;\n    fp += vec3(-1.1,-1.,0.);\n    fp.xz *= rot(-0.7);\n    fp.yz *= rot(-0.6);\n    fp.xz *= rot(a0);\n    o = sdCappedCone(fp,vec3(-.6),vec3(1.9),0.3,2.3);\n    p.xz *= rot(a0);\n    \n    o = max(o,p.y - .8);\n    p = op;\n    p.y += 2.5;\n    float shift1 = 1.8;\n    p.xy = (p.xy - vec2(0.,shift1)) * rot(a1) + vec2(0.,shift1);\n    p.xy *= rot(-.2);\n    \n    \n    vec3 up = p;\n    p.y -= clamp(p.y , -6.,3.);\n    o = sminCubic(length(p) - 0.4,o ,1.5);\n    \n    up.y += 9.3;\n    up.x -= 1.3;\n    up.xy *= rot(.6);\n    \n    vec2 shift2 = vec2(-0.6,1.7);\n    up.xy = (up.xy - (shift2)) * rot(a2) + (shift2);\n    vec3 uup = up;\n    up.xy *= rot(-up.y/40. );\n    up.y -= clamp(up.y , -4.,2.3);\n    //o = length(up) - 0.3;\n    \n    o = sminCubic(o,length(up) - 0.8,3.);\n    \n    uup.y += 6.;\n    uup.x += 0.8;\n    \n    vec2 shift3 = vec2(-0.,1.3);\n    \n    uup.xy = (uup.xy - (shift3)) * rot(a3) + (shift3);\n    vec3 momo = uup;\n    uup.xy *= rot(-.5);\n    \n    uup.y -=clamp(uup.y , -2.,2.);\n    \n    o = sminCubic(o ,length(uup) -.8 , 2.);\n    \n    momo += vec3(1.,1.,0.);\n    momo /= vec3(1.8,1.4,1.);\n    o = sminCubic(o ,length(momo) -1.8 , 4.5);\n    return o;\n}\n\nfloat camelhead(vec3 p){\n    float o = 10.;\n    vec3 hp = p;\n    hp -= vec3(42.,-10.6,0.);\n    \n    hp.xy *= rot(.2);\n    hp.yz *= rot(pi/4.);\n    vec3 headSize = vec3(3.,.01,.02);\n    hp -= clamp(hp,-headSize,headSize);\n    o = length(hp) - 0.01;\n    float neck = 10.;\n    vec3 np = p;\n    np -= vec3(35.,-2.6, 0.);\n    vec3 neckSize = vec3(.2,8.6,0.2);\n    np.xy *= rot(pi/2.);\n    //np.x -= sin(np.y/2. - iTime)/2.;\n    np.xy *= rot(-p.x /12. - 1.2);\n    np -= clamp(np,-neckSize,neckSize);\n    neck = length(np) - 2.3;\n    o = sminCubic(o,neck , 3.);\n    \n    o = sminCubic(o,length(hp + vec3(1.5,0.,0.)) - 2.4 , 5.);\n    return o;\n}\n\nfloat camelBody(vec3 p){\n    \n    float o = 10.;\n    p.y += 29.;\n    o = length(p + vec3(-19.,0.,0.)) - 4.;\n    o = sminCubic(o , length(p + vec3(-8.,2.,0.)) - 4.,9.);\n    o = sminCubic(o , length(p + vec3(2.,2.,0.)) - 2.6,11.);\n    o = sminCubic(o , length(p + vec3(0.,-2.1,0.)) - 4.,8.);\n    \n    o = sminCubic(o , length(p + vec3(3.5,0.,0.)) - 4.,6.);\n    o = sminCubic(o , length(p - vec3(21.,0.,0.)) - 4.,8.);\n    o = sminCubic(o,camelhead(p),5.);\n    return o;\n}\n\nvec2 camel(vec3 p)\n{\n    float o = 10.;\n    o = length(p) - 10.5;\n    \n    \n    vec3 p1 = p;\n    vec3 p2 = p;\n    vec3 p3 = p;\n    vec3 p4 = p;\n    //p1.xy *= rot(sin(p.y/2.)/100. + 0.4);\n    p1 +=  vec3(-.7,0.,4.);\n    p2 +=  vec3(-.7,0.,-4.);\n    p3 += vec3(-19.,0.,4.);\n    p4 += vec3(-19.,0.,-4.);\n    \n    float ot = iTime * 2.;\n    float spi = 6./pi;\n    float fine = 1.1;\n    float t = floor(ot/spi) + pow(fract(ot/spi),fine);\n    \n    float scale = 10.;\n\tp.y += sin(t + p.x/6.)/1.;\n    p.y += (noise(vec2(t) + p.x / 3.)-.5) * .3;\n    o = camelBody(p - vec3(2.,0.,0.));\n\n    float a0 = .9 *  scale;\n    vec2 shift = vec2(0.,-20.);\n    float a = sin(t) * pi * 0.1;\n    float a1 = (3.3 ) * scale;\n    float a2 = (.98) * scale;\n    float a3 = (2.6 ) * scale;\n    \n    p1.xy = (p1.xy - shift)*rot(sin(t)/a0 *pi) +shift;\n    float leg = camelLeg(p1 ,a,( sin(-t) - 0.3)/a1*pi,(sin(-t) - .8)/a2*pi,sin(-t)/a3*pi )/3.;\n    \n    //t *= -1.;\n    ot += 4.9;\n    t = floor(ot/spi) + pow(fract(ot/spi),fine);\n    p2.xy = (p2.xy - shift)*rot(sin(t)/a0 * pi) +shift;\n    leg = min(leg,camelLeg(p2,a, ( sin(-t) - 0.3)/a1*pi,(sin(-t)+ .4)/a2*pi,sin(-t)/a3*pi)/3.);\n    \n    //ot *= -1.;\n    \n    ot += 4.9;\n    t = floor(ot/spi) + pow(fract(ot/spi),fine);\n    p3.xy = (p3.xy - shift)*rot((sin(t)/a0 - 0.01) *pi) +shift;\n    leg = min(leg,camelLeg(p3,a, ( sin(-t) - 0.3)/a1*pi,(sin(-t)- .7)/a2*pi,sin(-t)/a3*pi)/4.3);\n    \n    //t *= -1.;\n    \n    ot += 4.9;\n    t = floor(ot/spi) + pow(fract(ot/spi),fine);\n    p4.xy = (p4.xy - shift)*rot((sin(t)/a0 - 0.01) * pi) +shift;\n    leg = min(leg,camelLeg(p4 ,a, ( sin(-t) - 0.3)/a1*pi,(sin(-t)- .4)/a2*pi,sin(-t)/a3*pi)/4.3);\n    o = sminCubic(o,leg,3.);\n    return vec2(o,CAMEL);\n}\n\nvec2 min2(vec2 o1,vec2 o2)\n{\n    if(o1.x < o2.x)\n    {\n        return o1;\n    }\n    return o2;\n}\nvec3 castlepos;\n\nvec2 castle(vec3 p){\n    \n    float o = 10.;\n    float ot = iTime * 2.;\n    float spi = 6./pi;\n    float fine = 1.1;\n    float t = floor(ot/spi) + pow(fract(ot/spi),fine);\n    \n    float scale = 10.;\n\tp.y += sin(t + p.x/36.)/1.;\n    p.xz *= rot(sin(t)/20.);\n    p.yz *= rot(sin(t)/20.);\n    \n    castlepos = p;\n    p.y += 36.;\n    p.x -= 10.;\n    vec3 shift = vec3(2.5,6.5,3.2);\n    for(int i = 0; i < 3;i++){\n        p = abs(p) - 2.3;\n        p.xz *= rot(.3);\n        p.xy *= rot(0.2);\n        p.yz *= rot(0.9);\n    }\n    for(int i = 0; i < 3;i++){\n        p.xz = abs(p.xz) - .1;\n        p.xz *= rot(.01);\n        p.xy *= rot(-0.2);\n    }\n    p.x = abs(p.x)-4.3;\n    o = deMengerSponge2(p,shift,1.8);\n    //o = length(p)- 10.;\n    return vec2(o,CASTLE);\n}\n\nvec2 map(vec3 p)\n{\n    vec2 o = vec2(10.);\n    vec3 op = p;\n    o = camel(p);\n    if(o.x < 0.3){\n        o.x -= fbm(p.xy * 100. + p.z)/100.;\n    }\n    \n    float ot = iTime * 10.;\n    float spi = 10./pi;\n    float fine = 1.2;\n    float t = floor(ot/spi) + pow(fract(ot/spi),fine);\n    op.x += t * 2.;\n    vec2 go = ground(op + vec3(0.,2.,0.));\n    vec2 co = castle(p);\n    \n    o = min2(o,castle(p));\n    \n    vec2 o2 = o;\n    o = min2(o,go);\n        \n    o.x = sminCubic(o2.x,go.x,0.3);\n    return o;\n}\n\nvec2 march(vec3 cp , vec3 rd){\n\tfloat depth = 0.;\n    for(int i = 0; i < 128; i++)\n    {\n        vec3 rp = cp + rd * depth;\n        vec2 d = map(rp);\n        if(abs(d.x) < 0.06)\n        {\n            return vec2(depth , d.y);\n        }\n        if(depth > 150.)break;\n        depth += d.x;\n    }\n    return vec2(-depth);\n}\n\nfloat rand(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise(vec3 p)\n{\n    vec3 fp = floor(p);\n\tvec3 fs = fract(p);\n    vec3 sf = vec3(1.,0.,0.);\n    \n    float a = rand(fp);\n    float b = rand(fp + sf);\n    float c = rand(fp + sf.yxz);\n    float d = rand(fp + sf.xxz);\n    float e = rand(fp + sf.yyx);\n    float f = rand(fp + sf.xyx);\n    float g = rand(fp + sf.yxx);\n    float h = rand(fp + sf.xxx);\n    \n    vec3 u = smoothstep(0.,1.,fs);\n  //  u = pow(fs,vec3(3.));\n    \n    return mix(mix(\n        \t\tmix(a,b,u.x),\n        \t\tmix(c,d,u.x),u.y),\n               mix(\n                mix(e,f,u.x),\n                mix(g,h,u.x),u.y),u.z\n            );\n}\n\nfloat fbm(vec3 p)\n{\n    float v = 0.;\n    float a = .5;\n    float f = 0.;\n    for(int i=0;i<3;i++)\n    {\n        v+=a*noise(p);\n        p*=2.;\n        a*=.5;\n    }\n    return v;\n}\n\nvec3 skyColor(vec3 rd,vec3 sun,float starToggle,float sunToggle)\n{\n    vec3 sky = rd;\n    rd.y = abs(rd.y);\n    vec3 sunPos = sun;\n    sky = vec3(0.);\n    float ld = dot(sun,vec3(0.,1.,0.));\n    float sd = abs( dot(sun,vec3(0.,0.,1.)) );\n    vec3 rd2 = rd;\n    rd2.xz *= rot(iTime/18.);\n    vec3 star = vec3(0.,0.5,1.) + sin( rand(rd2 * 10.)*10. );\n    star *= step(fbm(rd2*300.), 0.2);\n    star *= (sin(iTime*1. + fbm(rd2*150.)*30. ) + 1.)/2.;\n    star = clamp( star - .05,vec3(0.),vec3(1.)) * starToggle;\n    \n    //sky += vec3(0.,0.34,.9);\n    //sky += vec3(0.8,0.35,0.95) * ld;\n    //sky += max(0.,pow((1. - ld),8.) ) * star;\n    //sky += vec3(0.8,0.0,-0.1) * sd;\n    sky += vec3(0.,0.1,.4);\n    sky += vec3(0.9,0.4,0.9) * ld;\n    sky += max(0.,pow((1. - ld),8.) ) * star;\n    sky += vec3(0.6,0.0,-0.1) * sd;\n    float siz = .1;\n    float srd = clamp(dot(sunPos,rd) - siz,0.,1.) + siz;\n    float s = mix(.3,1.3,ld);\n    srd = pow( srd , 3.) - .7 + pow( srd , 120.);\n    sky += max(0.05 , srd * 10.) * sunToggle;\n    //sky += vec3(0.01,0.01,0.01);\n    return sky;\n}\n\nvec2 random22(vec2 st)\n{\n    st = vec2(dot(st, vec2(127.1, 311.7)),\n                dot(st, vec2(269.5, 183.3)));\n    return -1.0 + 2.0 * fract(sin(st) * 43758.5453123);\n}\n\nvec3 celler2D(vec2 i,vec2 sepc)\n{\n    vec2 sep = i * sepc;\n    vec2 fp = floor(sep);\n    vec2 sp = fract(sep);\n    float dist = 5.;\n    vec2 mp = vec2(0.);\n\n        for (int y = -1; y <= 1; y++)\n        {\n            for (int x = -1; x <= 1; x++)\n            {\n                vec2 neighbor = vec2(x, y );\n                vec2 pos = vec2(random22(fp+neighbor));\n                pos = sin( (pos*6.) )* 0.5 + 0.5;\n                float divs = length(neighbor + pos - sp);\n                mp = (dist >divs)?pos:mp;\n                dist = (dist > divs)?divs:dist;\n            }\n    }\n    return vec3(mp,dist);\n}\n\nfloat getEdge2(vec2 p,vec2 s,float edgeRange)\n{\n    vec3 e = vec3(1.0, -1.0,0.) * edgeRange;\n    vec2 edge = celler2D(p + e.xy,s).xy +\n                celler2D(p + e.yx,s).xy -\n                celler2D(p + e.xx,s).xy -\n                celler2D(p + e.yy,s).xy +\n                celler2D(p + e.zx,s).xy -\n                celler2D(p + e.zy,s).xy +\n                celler2D(p + e.xz,s).xy -\n                celler2D(p + e.yz,s).xy;\n    edge = abs(edge);\n    return step(max(edge.x,edge.y),0.);\n}\n\nvec3 random33(vec3 st)\n{\n    st = vec3(dot(st, vec3(127.1, 311.7,811.5)),\n                dot(st, vec3(269.5, 183.3,211.91)),\n                dot(st, vec3(511.3, 631.19,431.81))\n                );\n    return -1.0 + 2.0 * fract(sin(st) * 43758.5453123);\n}\n\nvec4 celler3D(vec3 i,vec3 sepc)\n{\n    vec3 sep = i * sepc;\n    vec3 fp = floor(sep);\n    vec3 sp = fract(sep);\n    float dist = 5.;\n    vec3 mp = vec3(0.);\n\n    for (int z = -1; z <= 1; z++)\n    {\n        for (int y = -1; y <= 1; y++)\n        {\n            for (int x = -1; x <= 1; x++)\n            {\n                vec3 neighbor = vec3(x, y ,z);\n                vec3 pos = vec3(random33(fp+neighbor));\n                pos = sin( (pos*6.) )* 0.5 + 0.5;\n                float divs = length(neighbor + pos - sp);\n                mp = (dist >divs)?pos:mp;\n                dist = (dist > divs)?divs:dist;\n            }\n        }\n    }\n    return vec4(mp,dist);\n}\n\nfloat getEdge3(vec3 p,vec3 s,float edgeRange)\n{\n    vec3 e = vec3(1.0, -1.0,0.) * edgeRange;\n    vec3 edge = celler3D(p + e.xyz,s).xyz +\n                celler3D(p + e.yxz,s).xyz -\n                celler3D(p + e.xxz,s).xyz -\n                celler3D(p + e.yyz,s).xyz +\n                celler3D(p + e.zxz,s).xyz -\n                celler3D(p + e.zyz,s).xyz +\n                celler3D(p + e.xzz,s).xyz -\n                celler3D(p + e.yzz,s).xyz +\n                celler3D(p + e.zxy,s).xyz -\n                celler3D(p + e.zyx,s).xyz ;\n    edge = abs(edge);\n    return step(max(edge.x,edge.y),0.);\n}\n\nvec3 getTile2(vec3 pos){\n    vec3 cell = celler2D(pos.xy,vec2(.3) );\n    vec3 tile = vec3(1.);\n    tile *= getEdge2(pos.xy , vec2(.3),0.07 );\n    //tile *= step(sin(tile.z * 1.),0. );\n    tile *= 1. - step ( (1. - getEdge2(pos.xy , vec2(.3),0.3 ) ) + (getEdge2(pos.xy , vec2(.3),0.6 ) ) ,0.5);\n    //tile = 1. - tile;\n    tile *= cell.yxx * 3.;\n    return tile;\n}\n\nvec3 getTile3(vec3 pos){\n    vec4 cell = celler3D(pos.xyz,vec3(.3) );\n    vec3 tile = vec3(1.);\n    tile *= getEdge3(pos , vec3(.3),0.07 );\n    //tile *= step(sin(tile.z * 1.),0. );\n    tile *= 1. - step ( (1. - getEdge3(pos , vec3(.3),0.3 ) ) + (getEdge3(pos , vec3(.3),0.6 ) ) ,0.5);\n   // tile = 1. - tile;\n    tile *= cell.xyz * 3.;\n    return tile;\n}\n\nvec3 getMat(vec2 d , vec3 pos){\n    //turquoise blue\n    vec3 o =  vec3(0.,175.,204.)/255.;\n    if(d.y == GROUND)\n    {\n        o = vec3(.9,0.67,0.)/1.35;\n    }else if(d.y == CAMEL){\n    \to *= 1.012; \n        o.rgb = getTile2(pos) * 1.;\n    }else if(d.y == CASTLE){\n        o = vec3(1.);\n        o *= fbm(castlepos)*.5 + .5;\n        //o.rgb = getTile3(castlepos) * 1.;\n    }\n    return o;\n}\n\nvoid scene( out vec3 ocolor, in vec2 fg ) {\n    vec2 p = (fg.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\tvec3 cp = vec3(17.,-17.,-50.);\n    //cp.xz *= rot(iTime);\n    vec3 target = vec3(17.,-27.,0.);\n    \n    vec3 col = vec3(0.);\n    vec3 cd = normalize(target - cp);\n    vec3 cs = normalize(cross(cd,vec3(0.,1.,0.)));\n    vec3 cu = normalize(cross(cd , cs));\n    \n    float fov = 1.5 - dot(p,p)/7.;\n    vec3 rd = normalize(p.x * cs + p.y * cu + cd * fov);\n    \n    vec3 sun = normalize(vec3(0.5,8.,8.));\n    sun.yz *= rot(iTime/2.);\n    vec3 sky  = skyColor(rd,sun,1.,1.);\n    col = vec3(0.9,0.9,1.);\n    col = sky;\n    vec3 bg = col;\n    vec2 d = march(cp , rd);\n    if(d.x > 0.)\n    {\n        vec2 e = vec2(-1.,1.) * .05;\n        vec3 pos = cp + rd * d.x;\n        vec3 N = normalize(\n                  e.xyy * map(pos + e.xyy).x +\n                  e.yyx * map(pos + e.yyx).x +\n                  e.yxy * map(pos + e.yxy).x +\n                  e.xxx * map(pos + e.xxx).x);\n        col = N;\n        \n        col = getMat(d , pos);\n        // sun.xz *= rot(iTime);\n        float odiff = max(0.,dot(sun,N));\n        float diff = max(0.,dot(-sun,N));\n        float daynight = mix(1.,0.,max(0.,dot(sun,vec3(0.,-1.,0.))));\n        diff *= daynight;\n        \n        float rim = pow(clamp(1. - dot(N, -rd), 0., 1.), 3.);\n        //rim = 0.;\n        float sp = 0.;\n        if(d.y != CAMEL){\n        \tdiff = pow(diff , 2.);\n            sp = max(0.,dot(rd,reflect(N,sun)));\n        \tsp = pow(sp,3.);\n            rim = pow(clamp(1. - dot(N, -rd), 0., 1.), 63.);\n           // rim = 1. - rim;\n        }\n        col = col * diff + sp + rim * col;\n        if(d.y == CAMEL)\n        {\n            col = getMat(d ,pos);\n        }\n        \n        float t = 1. - exp(-.0001 * d.x * d.x );\n        bg = skyColor(rd,sun,0.,0.);\n        col = mix(col,bg,t);\n        \n        col = mix(vec3(0.001,0.031,0.2) * pow(odiff,3.),col,daynight);\n        //col = rim * vec3(0.,0.7,0.7) /3.;\n    }\n    ocolor = col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec3 color = vec3(0.);\n    \n    scene(color,fragCoord + vec2( .25, .25));\n    scene(color,fragCoord + vec2(-.25, .25));\n    scene(color,fragCoord + vec2(-.25,-.25));\n    scene(color,fragCoord + vec2( .25,-.25));\n    color/=3.;\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}