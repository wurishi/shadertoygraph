{"ver":"0.1","info":{"id":"dss3R7","date":"1665907114","viewed":132,"name":"Parametric plotter __","username":"Envy24","description":".","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["antialiasing","graph","plot","parametric","thickness"],"hasliked":0,"parentid":"msf3RM","parentname":"Better explicit graphs"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ORIGIN                    ( vec2(0) )\n#define SCENE_SCALE               ( 1.5 )\n#define UNIT                      ( 5.0*SCENE_SCALE / iResolution.y  )\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n#define HASH(x,y)                 ( h_u2f2(uint(x), uint(y)) )\n\nfloat y_axisSDF(vec2 NDC) { return abs(NDC.x); }\nfloat x_axisSDF(vec2 NDC) { return abs(NDC.y); }\nfloat vertical_lineSDF(vec2 NDC, float x0) { return abs(NDC.x-x0); }\nfloat horizontal_lineSDF(vec2 NDC, float y0) { return abs(NDC.y-y0); }\nfloat cellsSDF(vec2 NDC)\n{\n    //NDC *= 2.; // Finer cells\n    NDC = fract(NDC);\n    NDC = fract(min(NDC, 1. - NDC));\n    return\n        min(vertical_lineSDF(NDC, 0.), horizontal_lineSDF(NDC, 0.));\n}\nfloat diskSDF(vec2 NDC, vec2 C, float R) { return length(C - NDC)-R; }\nfloat segmentSDF(in vec2 NDC, in vec2 B, in vec2 E, in float R)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - R;\n}\n\nvec2 func(float t) // sexticBezier for demo\n{\n    const float count = 7.;\n    float T = 4.*iTime, F = T+1.;\n    vec2 P[int(count)];\n    for (float i = 0.; i < count; i += 1.) { P[int(i)] = HASH(T+i,F+i); }\n\n    float tt = t, ttt = tt*t, f = 1.-t, ff = f*f, fff = ff * f;\n    return P[0]*ttt*ttt+6.*P[1]*tt*ttt*f+15.*P[2]*tt*tt*ff+20.*P[3]*ttt*fff+15.*P[4]*tt*ff*ff+6.*P[5]*t*fff*ff+P[6]*fff*fff;\n}\n\nfloat linear_remap(\n    float val,\n    vec2 from,\n    vec2 to)\n{\n    // inverse linear map from [from.x; from.y] to [0; 1].\n    val = (val - from.x) / (from.y - from.x);\n    // linear map from [0; 1] to [to.x; to.r].\n    return val * (to.y - to.x) + to.x;        \n}\n\n// Parametric function definition.\nfloat x(float t) { return t - sin(t); }\nfloat y(float t) { return 1. - cos(t); }\nvec2 parametric(float t)\n{\n    return func(t); // for demo;\n    return vec2(x(t), y(t));\n}\n\n// https://www.shadertoy.com/view/NtVfWG\nfloat parametricSDF(\n    in vec2 NDC,\n    in vec2 from, // NDC.x range\n    in vec2 to,   // t range\n    in float count)\n{\n    float dt = (from.y - from.x) / (count - 1.);\n    \n    float minimal_distance = 99.;\n    vec2 B = parametric(linear_remap(from.x, from, to));\n      \n    for (float i = 1.; i < count; i += 1.)\n    {\n        float t = linear_remap(from.x + dt * i, from, to);\n    \n        vec2 E = parametric(t);\n        minimal_distance = \n            min(minimal_distance, segmentSDF(NDC, B, E, 0.));\n        B = E;\n    }\n    \n    float thickness = sinOSC(-5., 20., iTime)/iResolution.y;\n    return minimal_distance-thickness;\n}\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse)\n{\n    vec2 M = MOUSE_OFFSET * (mouse == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale - origin;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, ORIGIN, true);\n\n    vec3 color = vec3(1.);\n         color = mix( color, vec3(0.8), SMAA(cellsSDF(NDC)) );\n         color = mix( color, vec3(0), SMAA(x_axisSDF(NDC)) );\n         color = mix( color, vec3(0), SMAA(y_axisSDF(NDC)) );\n         \n    /* Parametric function (x,y)=f(t) */\n    float AR = iResolution.x/iResolution.y;\n    vec2 from = vec2(-AR, AR)*SCENE_SCALE, to = vec2(0, 1);\n         color = mix( color, vec3(1,0,0), SMAA(parametricSDF(NDC, from, to, 64.)) );\n         \n    /* Knots and convex hull (only for demo) */\n    float T = 4.*iTime, F = T+1.;\n    vec2 P; P = HASH(T,F);\n    color = mix( color, vec3(0,0,1), SMAA(diskSDF(NDC, P, UNIT)) );\n    for (float i = 1.; i < 7.; i += 1.)\n    {\n        vec2 Pn = HASH(T+i,F+i);\n        \n        color = mix( color, vec3(0,0,1), SMAA(diskSDF(NDC, Pn, UNIT)) );\n        color = mix( color, vec3(0,1,0), 0.2*SMAA(segmentSDF(NDC, P, Pn, 0.)) );\n        \n        P = Pn;\n    }\n    /**/\n\n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\n/* Returns random vec2([-1.0; 1.0], [-1.0; 1.0]). */\nvec2 h_u2f2( // u2 - in 2 unsigneds, f2 - out to floats.\n    const uint x,\n    const uint y)\n{\n    // Try different seeds.\n    const uint seed0 = 123u;\n    const uint seed1 = 456u;\n    const uint seed2 = 789u;\n\n    // Use linear offset method to mix coordinates.\n    uint value0 = y * seed2 + x;\n    uint value1 = x * seed2 + y;\n\n    // Calculate hash.\n\tvalue0 += seed1; value0 *= 445593459u; value0 ^= seed0;\n    value1 += seed1; value1 *= 445593459u; value1 ^= seed0;\n    \n    // 2.0f / 4294967295.0f = 4.6566128730773926e-10\n\n    return \n        vec2(\n            float(value0 * value0 * value0) * 4.6566128730773926e-10f - 1.0f,\n            float(value1 * value1 * value1) * 4.6566128730773926e-10f - 1.0f);\n}\n\n","name":"Common","description":"","type":"common"}]}