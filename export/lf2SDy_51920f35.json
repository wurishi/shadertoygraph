{"ver":"0.1","info":{"id":"lf2SDy","date":"1706810974","viewed":157,"name":"butterflies_shining","username":"nnniiannn","description":"butterfly test","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["butterfly"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//modified from https://www.shadertoy.com/view/ld23z3 fizzer\n\n#define NUM_BUTTERFLIES 23\n\n//----------------------------------------\n\nvec3 a, b, c, mm, n;\n\n// curve\nvec3 mapD0(float t)\n{\n    return 0.25 + a*cos(t+mm)*(b+c*cos(t*7.0+n));\n}\n// curve derivative (velocity)\nvec3 mapD1(float t)\n{\n    return -7.0*a*c*cos(t+mm)*sin(7.0*t+n) - a*sin(t+mm)*(b+c*cos(7.0*t+n));\n}\n// curve second derivative (acceleration)\nvec3 mapD2(float t)\n{\n    return 14.0*a*c*sin(t+mm)*sin(7.0*t+n) - a*cos(t+mm)*(b+c*cos(7.0*t+n)) - 49.0*a*c*cos(t+mm)*cos(7.0*t+n);\n}\n\n//----------------------------------------\n\nfloat curvature( float t )\n{\n    vec3 r1 = mapD1(t); // first derivative\n    vec3 r2 = mapD2(t); // second derivative\n    return length(cross(r1,r2))/pow(length(r1),3.0);\n}\n\n//-----------------------------------------\n\n// unsigned squared distance between point and segment\nvec2 usqdPointSegment( in vec3 p, in vec3 a, in vec3 b )\n{\n\tvec3  pa = p - a;\n\tvec3  ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\tvec3  q = pa - ba*h;\n\treturn vec2( dot(q,q), h );\n}\n\n\n// unsigned squared distance between ray and segment\nvec2 usqdLineSegment( vec3 a, vec3 b, vec3 o, vec3 d )\n{\n//#if 1\n\tvec3 oa = a-o;\n    vec3 ob = b-o;\n\tvec3 va = oa-d*dot(oa,d);\n    vec3 vb = ob-d*dot(ob,d);\n    \n    vec3 ba = va-vb;\n    float h = clamp( dot(va,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec3  q = va - ba*h;\n    return vec2( dot(q,q), h );\n/*#else\n    return usqdPointSegment( vec3(0.0), o+d*dot(a-o,d)-a, o+d*dot(b-o,d)-b );\n#endif*/\n}\n\n\nfloat time;\n\n// Noise functions from IQ.\nfloat hash( float n ) { return fract(sin(n)*43758.5453123); }\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0;\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y);\n}\n\nfloat fbm2(vec2 p)\n{\n   float f = 0.0, x;\n   for(int i = 1; i <= 9; ++i)\n   {\n      x = exp2(float(i));\n      f += (noise(p * x) - 0.5) / x;\n   }\n   return f;\n}\n\n\nfloat sq(float x)\n{\n\treturn x*x;\n}\n\nvec2 rotate(float a,vec2 v)\n{\n\treturn vec2(cos(a)*v.x+sin(a)*v.y, cos(a)*v.y-sin(a)*v.x);\n}\n\nmat3 rotateXMat(float a)\n{\n\treturn mat3(1.0, 0.0, 0.0, 0.0, cos(a), -sin(a), 0.0, sin(a), cos(a));\n}\n\nmat3 rotateYMat(float a)\n{\n\treturn mat3(cos(a), 0.0, -sin(a), 0.0, 1.0, 0.0, sin(a), 0.0, cos(a));\n}\n\nvec3 wing0Node(int i) //upper wing pattern\n{\n\tif(i<1)\n\t\treturn vec3(-0.63,0.0,1.0);\n\tif(i<2)\n\t\treturn vec3(-0.8,0.25,1.0);\n\tif(i<3)\n\t\treturn vec3(-0.6,0.9,1.0);\n\tif(i<4)\n\t\treturn vec3(-0.46,0.24,1.3);\n\treturn vec3(-0.05,-0.05,1.0);\n}\n\nvec3 wing1Node(int i)\n{\n\tif(i<1)\n\t\treturn vec3(0.31,0.3,1.0);\n\tif(i<2)\n\t\treturn vec3(-0.53,0.4,1.0);\n\treturn vec3(0.53,-0.2,1.0);\n}\n\nvec3 wing0NodeTransformed(int i)\n{\n\treturn (wing0Node(i)+vec3(-0.57,-0.05,0.0))*vec3(vec2(0.2,0.7)*0.73,0.9);\n}\n\nvec3 wing1NodeTransformed(int i)\n{\n\treturn (wing1Node(i)+vec3(-0.7,-0.05,0.0))*vec3(vec2(1.2,1.0)*0.37,0.89);\n}\n\nvec3 wing0Tex(vec2 p)\n{\n\tp=rotate(-0.79,p+vec2(0.35,0.0)); //upper wing angle\n\t\n\tfloat a=1e3;\n\tfloat b=1e3;\n\t\n\tint cn=0;\n\tfloat cnd=1e3;\n\tfor(int i=0;i<4;i+=1)\n\t{\n\t\tfloat d=distance(p,wing0NodeTransformed(i).xy);\n\t\tif(d<cnd)\n\t\t{\n\t\t\tcnd=d;\n\t\t\tcn=i;\n\t\t}\n\t}\n\t\n\tfloat s=0.04+pow(max(0.0,-p.x*0.1),1.3)+pow(max(0.0,-p.y+1.0),1.3)*0.1; //edge\n\t\n\ts+=0.12*(1.0-smoothstep(0.0,0.14,distance(p.xy,vec2(-0.2,2.2))));\n\t\n\tfloat c=0.0;\n\tfor(int j=0;j<4;j+=1)\n\t{\n\t\tif(j==cn)\n\t\t\tcontinue;\n\t\t\n\t\tvec3 n0=wing0NodeTransformed(cn);\n\t\tvec3 n1=wing0NodeTransformed(j);\n\t\tvec2 nd=n1.xy-n0.xy;\n\t\tfloat d=dot(p-(n0.xy+nd*0.5),normalize(nd))+s*n0.z;\n\t\tc+=sq(max(0.0,d));\n\t}\n\t\n\tfloat p0=sq(max(0.0,dot(p-vec2(-0.47,0.0),normalize(vec2(1.0,-1.0)))));\n\t\n\tc+=sq(max(0.0,(distance(p+vec2(0.6,1.42),vec2(0.0))-2.+s))) + p0 * 0.5+\n\t\tsq(max(0.0,dot(p-vec2(-0.6,-0.2),normalize(vec2(-0.3,-0.9)))));\n\t\n\tfloat c2=sq(max(0.0,(distance(p+vec2(0.6,1.55),vec2(0.0))-2.0))) + p0 +\n\t\tsq(max(0.0,dot(p-vec2(-0.6,-0.2),normalize(vec2(-0.19,-0.9)))-0.1));\n\t\n\t\n \tfloat x=max(1.0-smoothstep(0.26,0.87,distance(p,vec2(-0.5,0.5))),\n\t\t\t\t1.0-smoothstep(0.02,0.025,length((p)-vec2(0.05,0.01))));\n\t\n\treturn vec3(1.0-smoothstep(s-0.0975,s-0.015+0.116,sqrt(c)),1.0-smoothstep(0.01,0.106,sqrt(c2)-0.03), x*0.53 - p * 0.05);\n}\n\nvec3 wing1Tex(vec2 p)\n{\n\tp=p+vec2(0.0,0.16);\n\t\n\tfloat a=1e3;\n\tfloat b=1e3;\n\t\n\tint cn=0;\n\tfloat cnd=1e3;\n\tfor(int i=0;i<7;i+=1)\n\t{\n\t\tfloat d=distance(p,wing1NodeTransformed(i).xy);\n\t\tif(d<cnd)\n\t\t{\n\t\t\tcnd=d;\n\t\t\tcn=i;\n\t\t}\n\t}\n\t\n\tfloat s=0.04+pow(max(0.0,-p.y*0.4),1.3)+pow(max(0.0,-p.x-1.0),1.3)*0.1;\n\t\n\tfloat c=0.0;\n\tfor(int j=0;j<7;j+=1)\n\t{\n\t\tif(j==cn)\n\t\t\tcontinue;\n\t\t\n\t\tvec3 n0=wing1NodeTransformed(cn);\n\t\tvec3 n1=wing1NodeTransformed(j);\n\t\tvec2 nd=n1.xy-n0.xy;\n\t\tfloat d=dot(p-(n0.xy+nd*0.5),normalize(nd))+s*n0.z;\n\t\tc+=sq(max(0.0,d));\n\t}\n\t\n\tfloat p0=sq(max(0.0,dot(p-vec2(-0.5,-0.4),normalize(vec2(1.0,-0.7)))));\n\tfloat p1=sq(max(0.0,dot(p-vec2(-0.53,0.3),normalize(-vec2(0.1,-0.9)))));\n\t\n\tc+=sq(max(0.0,(distance(p+vec2(0.52,-0.1),vec2(0.0))-0.5))) + p0 + p1;\n\t\n\tfloat c2=sq(max(0.0,(distance(p+vec2(0.5,-0.0),vec2(0.0))-0.53))) + p0 + p1;\n\n\treturn vec3(1.0-smoothstep(s-0.025,s-0.005+0.0716,sqrt(c)),1.0-smoothstep(0.1,0.106,sqrt(c2)-0.03),c2*0.025);\n}\n\nvec4 wing(vec2 p)\n{\n\tp+=fbm2(p*vec2(1.2,0.9))*0.15; //shape noise\n\tvec3 wc=mix(vec3(1.15,1.125,1.65)*0.63, vec3(0.79,0.97,1.47)*1.51, \n\t\t\t\tclamp(pow(fbm2(rotate(-0.537, p)*vec2(100,300.0))*1.85 + 0.3, 3.), 0.0, 1.0));\n\t\n\twc=pow(wc,vec3(1.9));\n\t\n\tvec3 c0=wing0Tex(p);\n\tvec3 c1=wing1Tex(p);\n\n\tvec3 col=vec3(0.0);\n\t\n\tcol.rgb=mix(mix(vec3(0.0),c0.x*wc,c0.y),c1.x*wc,c1.y);\n\tcol.rgb=mix(col.rgb,vec3(1.0),c0.z);\n\tcol.rgb=mix(col.rgb,vec3(1.0),c1.z);\n\t\n\treturn vec4(col,max(c0.y,c1.y));\n}\n\nvec3 traceButterflyWing(vec3 ro,vec3 rd,vec3 bo,vec3 bd,float flap)\n{\n\tvec3 up=vec3(0.1,1.0,0.0);\n\tvec3 c=cross(bd,up);\n\tfloat flapangle=mix(radians(30.0),radians(170.0),flap);\n\tvec3 w=cos(flapangle)*c+sin(flapangle)*up;\n\tfloat t=-dot(ro,w)/dot(rd,w);\n\tvec3 s=cross(w,bd);\n\tvec3 rp=ro+rd*t;\n\treturn vec3(dot(rp,s),dot(rp,bd),t);\n}\n\nvec4 traceButterfly(vec3 ro,vec3 rd,vec3 bo,vec3 bd,float flap)\n{\n\tflap=pow(flap,0.55);\n\tbo.y-=flap*0.25;\n\tro-=bo;\n\tvec3 up=vec3(0.0,1.0,0.0);\n\tvec3 c=cross(bd,up);\n\t\n\tvec3 w0=traceButterflyWing(ro,rd,bo,bd,flap);\n\t\n\tro-=dot(ro,c)*2.0*c;\n\trd-=dot(rd,c)*2.0*c;\n\t\n\tvec3 w1=traceButterflyWing(ro,rd,bo,bd,flap);\n\n\tif ( max(abs(w0.x),abs(w0.y)) > 2.0 && max(abs(w1.x),abs(w1.y)) > 2.0 )\n\t\treturn vec4(0,0,0,1e4);\n\t\n\tvec4 c0=wing(w0.xy);\n\tvec4 c1=wing(w1.xy);\n\t\n\tbool u0=c0.a>0.0 && w0.z>0.0;\n\tbool u1=c1.a>0.0 && w1.z>0.0;\n\t\n\tif(!u0 && !u1)\n\t\treturn vec4(0.0,0.0,0.0,1e4);\n\telse if(u0 && !u1)\n\t\treturn vec4(c0.rgb,w0.z);\n\telse if(!u0 && u1)\n\t\treturn vec4(c1.rgb,w1.z);\n\telse\n\t\treturn mix(vec4(c0.rgb,w1.z),vec4(c1.rgb,w0.z),smoothstep(0.25 - w1.z, 0.25 + w1.z, 0.79));\n}\n\nvec3 butterflyPath(float t)\n{\n\treturn vec3(1.7*cos(t),cos(t*0.22)*1.1+sin(t*4.0)*0.1,sin(t*1.7))*4.0;\n}\n\nvec3 colormapping(vec2 uv)\n{\n    a = vec3(0.85,1.25,1.85) + 0.1*cos(9.0+0.7*iTime + vec3(0.5,1.0,2.0) );\n    b = vec3(0.10,0.60,0.60) + 0.1*cos(5.0+0.5*iTime + vec3(2.5,5.0,3.0) );\n    c = vec3(0.90,0.40,0.40) + 0.1*cos(1.0+0.3*iTime + vec3(6.0,2.0,7.2) );\n    mm = cos( 0.11*iTime + vec3(0.0,2.0,5.0) );\n    n = cos( 0.7*iTime + vec3(0.50,1.0,4.0) );\n\n\tvec2 p = (2.*uv-iResolution.xy)/iResolution.y;\n \n    vec3 ro0 = vec3( 0.0, 0.0, 4.0 );\n    vec3 rd0 = normalize( vec3(p.xy, -2.0) );\n\n    vec3 col = vec3(0.0);\n    \n    vec3  gp = vec3(0.0);\n    \n    const int kNum = 9;\n    \n    float dt = 6.2831/float(kNum);\n\tfloat t = 0.0;\n    vec3  xb = mapD0(t); t += dt;\n\n    vec3 xc = mapD0(t);\n    xc.y = max(-1.0,xc.y); // clip to ground\n    vec2 ds = usqdLineSegment( xb, xc, ro0, rd0 );\n\n    col = vec3(ds,0.0);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 q=uv;\n\tuv=uv*2.0-vec2(1.0);\n\tuv.x*=iResolution.x/iResolution.y;\n\ttime=iTime;\n\tmat3 m=rotateYMat(time*0.02)*rotateXMat(cos(time*0.12)*0.47);\n\t\n\tvec3 ro=m*vec3(0.0,0.0,7.0),rd=m*normalize(vec3(uv,-1.2));\n\n    vec3 col = colormapping(fragCoord);\n    \n\tcol = col.grr*vec3(1.15, 0.87, 0.35)*0.2; //magic color\n    \n\tfloat d=1e3;\n\t\n\tfor(int i=0;i<NUM_BUTTERFLIES;i+=1)\n\t{\n\t\tfloat t=time+float(i)*10.2;\n\t\tvec3 bo=butterflyPath(t);\n\t\tvec4 b=traceButterfly(ro,rd,bo,vec3(normalize(butterflyPath(t+1e-2).xz-bo.xz),0.0).xzy,0.5+0.5*cos(t*9.0));\n\t\tc=mix(c,b.rgb,step(b.a,d));\n\t\td=min(d,b.a);\n\t}\n\t\n    vec3 dc = mix(c,c+0.05*d,0.01+0.2*dot(c,vec3(1.0/5.0)));\n\tfragColor.rgb=mix(c*0.5,dc,d*0.25);\n    fragColor.rgb = mix(vec3(0.0), dc*(col*0.35 + 0.17), 3.-fragColor.r*vec3(0.01,0.11,0.21));\n\n\tfragColor.rgb *= pow( 22.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.5 );\n    fragColor.rgb = clamp(fragColor.rgb, 0.0, 1.0);\n    //fragColor.rgb = dc;\n}\n","name":"Image","description":"","type":"image"}]}