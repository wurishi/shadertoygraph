{"ver":"0.1","info":{"id":"7tySDW","date":"1640865222","viewed":203,"name":"Frozen Waterfalls","username":"kastorp","description":"freeze with mouse\n","likes":16,"published":1,"flags":32,"usePreview":0,"tags":["voronoi","particles","ice","snow"],"hasliked":0,"parentid":"NlKSWz","parentname":"waterfalls"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Frozen Waterfalls by Kastorp\n//-----------------------------------------------------\n\nGETTERS\n\nvec4 Voronoi(in vec2 pos){\n    ivec4 nb = getClosest(ivec2(pos/ZOOM));\n  \n    bool ghost;\n    vec4 pi0 = getParticle(nb[0],ghost);\n    vec4 pi1 = getParticle(nb[1],ghost);\n    vec4 pi2 = getParticle(nb[2],ghost);\n\n    float d0 = distance(pos/ZOOM,pi0.xy)*ZOOM;\n    float d1 = distance(pos/ZOOM,pi1.xy)*ZOOM;  \n    float d2 = distance(pos/ZOOM,pi2.xy)*ZOOM; \n    float v= length(pi0.zw);\n    return vec4(d0,d1,d2,v);\n}\n\nvoid mainImage( out vec4 O, in vec2 p ){\n\n    //float cid = fract(float(i2xy(idn).x)  /10.);\n    float vol=RRADIUS*ZOOM*(1.+MB);\n    \n    vec4 d = Voronoi(p);\n    float  df=smin(smin(d.x,d.y,vol*MB),d.z,vol*MB);\n    \n    float foam= clamp(0.,1.,1.-.2*smoothstep(vol,vol*.8 ,d.y)-.3*smoothstep(vol,vol*.8 ,d.z));\n    vec3  col = d.w<.001? vec3(1): vec3(.9*foam,.3+.7*foam,1.-.1*foam);\n\n    \n    col *= smoothstep(vol,vol*.8,df);   \n    col=mix(col,vec3(.4,.1,.1), smoothstep(vol*.03,vol*.0,(map(p/ZOOM,size,iTime).x)));\n\tO = vec4(col, 1);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//configurable settings:\n#define NP 10000. \n#define GRIDSIZE 400. //grid size\n#define dt 1.5\n#define RADIUS 2. //particle radius\n#define UNFREEZING vec3(.2,.0,0.) //unfreezing factor 0-1\n#define GR -.02 //gravity\n#define MB 1.  //metaball effect\n\n//-----------------------\n//#define N8  //interact with 8 particles (default is with 4 particle)\n#define FREEZE\n#define NGH 1000 \n#define ZERO  min(iFrame,0)\n#define N ivec2(int(sqrt(NP)),int(sqrt(NP)))\n#define size min(vec2(GRIDSIZE*iResolution.x/iResolution.y,GRIDSIZE),vec2(iResolution.xy))\n#define RRADIUS RADIUS *  min(iResolution.y/GRIDSIZE,1.)\n#define ZOOM (iResolution.y/size.y)\n#define mouse (iMouse/ZOOM)\n#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define GETTERS ivec4 getClosest(ivec2 p){ return floatBitsToInt(texel(iChannel2, p));} \\\nivec4 getNeighbor(int id){ return floatBitsToInt(texel(iChannel1, i2xy(id)));} \\\nivec4[2] getNeighbor2(int id){ uvec4 v= floatBitsToUint(texel(iChannel1, i2xy(id))); return ivec4[2](ivec4(v&65535u), ivec4(v>>16)); }\\\nvec4 getParticle(int id,out bool ghost){ vec4 p= texel(iChannel0, i2xy(id));ghost=min(p.x,p.y)<0.;return vec4(abs(p.xy),p.zw); }\n\nconst int tot_n = N.x*N.y;\n\n\nivec2 i2xy(int id)\n{\n    return ivec2(id%N.x, id/N.x);\n}\n\nint xy2i(ivec2 p)\n{\n    return p.x + p.y*N.x;\n}\n\n\n// https://iquilezles.org/articles/smin\nfloat smin(in float a, in float b, in float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n//https://iquilezles.org/articles/distgradfunctions2d\nvec3 sdgCircle( in vec2 p, in float r ) \n{\n    float d = length(p);\n    return vec3( d-r, p/d );\n}\n\nvec3 sdgSegment( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\n    vec2 ba = b-a, pa = p-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec2  q = pa-h*ba;\n    float d = length(q);\n    return vec3(d-r,q/d);\n}\nvec3 sdgBox( in vec2 p, in vec2 b )\n{\n    vec2 w = abs(p)-b;\n    vec2 s = vec2(p.x<0.0?-1:1,p.y<0.0?-1:1);\n    float g = max(w.x,w.y);\n    vec2  q = max(w,0.0);\n    float l = length(q);\n    return vec3(   (g>0.0)?l  :g,\n                s*((g>0.0)?q/l:((w.x>w.y)?vec2(1,0):vec2(0,1))));\n}\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\nvec3 sdgRBox( in vec2 p, float a , in vec2 b ){\n    p*=rot(a);\n    vec3 d= sdgBox( p,  b );\n    return vec3(d.x, d.yz*rot(-a));\n\n}\n\n#define mmax(a,b) (a.x>b.x?a:b)\n#define mmin(a,b) (a.x<b.x?a:b)\nvec3 map(vec2 p,vec2 sz,float t){\n     t*=dt/4.;\n     vec3 df = vec3(1e5,0,0);\n     //df=mmin(df,sdgCircle(p.xy -vec2(sz.x*.3,0),sz.y*.15));\n     df=mmin(df,-sdgBox(p-sz*.5*vec2(1,1.),sz*.49*vec2(1,1.)));\n     //df=mmin(df,sdgBox(p-vec2(sz.x*.8,0),vec2(sz.x*.2,sz.y*.1)));\n     df=mmin(df,sdgBox(p-vec2(sz.x*.2,sz.y*.45),vec2(sz.x*.02,sz.y*.3)));\n     df=mmin(df,sdgSegment(p,vec2(.2,.7)*sz,vec2(.6,.6+sin(t)*.1)*sz,sz.y*.01));\n     df=mmin(df,sdgSegment(p,vec2(.6,.5)*sz,vec2(.9,.8)*sz,sz.y*.01));\n     float c=sz.y/7., q = mod(p.y - t*.15*sz.y +0.5*c,c)-0.5*c;\n     df=mmin(df,mmax(\n         sdgBox(p-vec2(sz.x*.1,sz.y*.33+mod(t*.15*sz.y,c)),vec2(sz.x*.1,sz.y*.45)),\n         sdgRBox(vec2(p.x,q),-.2,vec2(sz.x*.2,sz.y*.01))));\n    return df;\n\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//particle physics\n\nGETTERS\n\nint cid;\n\nfloat hits=0.,hmin=1.;\n\nvec4 Fv(vec4 p0, int pid)\n{\n    if(pid < 0 || pid >= tot_n || pid == cid) return vec4(0);\n    bool ghost;\n   \tvec4 p1 = getParticle(pid,ghost);\n    float d = distance(p1.xy,p0.xy),\n          x=d/RRADIUS;\n\n#ifndef FREEZE\n    vec2 n= normalize(p1.xy-p0.xy),\n         rp=  n* min(0.,d-RADIUS*2.)*.6,\n         rv=p1.zw-p0.zw,\n         v=  -max(-dot(rv,n),.0) *n/dt*smoothstep(2.1,1.9, x)*1.01;    \n     hits+= d<RADIUS*2.?1.:0.;\n\n    return vec4(v,rp);\n#else               \n    vec2 p0n= p0.xy+p0.zw*dt+GR*dt, p1n=p1.xy+p1.zw*dt+GR*dt;\n    float dn= distance(p1n.xy,p0n.xy);\n    vec2 n= normalize(p1.xy-p0.xy),\n         rp=  n* min(0.,d-RRADIUS*2.)*.6,\n         rv=p1.zw-p0.zw,\n         v=  -max(-dot(rv,n),.0) *n/dt*smoothstep(2.01,1.99, x)*1.01;    \n          hits= 1.;\n     if(dn>2.*RRADIUS || dot(rv,n)>0.) return vec4(0);\n     \n     float ht=clamp(( dn-2.*RRADIUS) /(dn-d),0.,1.);\n     if(ht<hmin){\n         hmin=ht;\n          return vec4(v,rp*1.01);\n     }    \n    return vec4(v,rp*1.01);  \n#endif\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    if(p.x < N.x && p.y < N.y)\n    {\n        pos = floor(pos); \n        //this pixel value\n        U = texel(iChannel0, pos);\n        U.xy=abs(U.xy);\n        int id = xy2i(p);\n        cid = id;\n        \n        //this pixel value\n        if(iFrame<10 || U==vec4(0))\n        {\n            U.xy = size*vec2(p)/vec2(N);\n\t\t\tU.zw = vec2(0);\n      \t\treturn;\n        }\n        \n#ifdef N8       \n   \t\tivec4[2] cp = getNeighbor2(id);\n   \t  \n        vec4 F = Fv(U, cp[0].x) +\n            \t Fv(U, cp[0].y) +\n            \t Fv(U, cp[0].z) +\n                 Fv(U, cp[0].w) +\n                 Fv(U, cp[1].x) +\n            \t Fv(U, cp[1].y) +\n            \t Fv(U, cp[1].z) +\n                 Fv(U, cp[1].w);\n#else\n   \t\tivec4 cp = getNeighbor(id);\n   \t  \n        vec4 F = (Fv(U, cp.x) +\n            \t Fv(U, cp.y) +\n            \t Fv(U, cp.z) +\n                 Fv(U, cp.w));\n#endif\n        \n        bool gh;\n        vec4 p0 = getParticle(id,gh);\n\n         \n        if(iMouse.z > 0.) \n        {\n            float d = distance(mouse.xy, U.xy);\n            if(d<size.y*.2) U.zw=vec2(0);// F.xy += 2.*normalize(mouse.xy - U.xy)/(sqrt(d)+2.);\n        } \n \n         \n        //border conditions\n        vec3 df= map(U.xy,size,iTime), dfn= map(U.xy+dt*U.zw+GR*dt,size,iTime);\n        if(df.x<RRADIUS*1.) {            \n            F.xy+= (dot(U.zw,df.yz)<0.) ? \n                  -df.yz*2.*dot(U.zw,df.yz)/dt: \n                   vec2(0.); \n            F.zw+= (-df.x +RRADIUS*1.)*(df.yz );\n                        \n            hits+= 1.;\n         }  else if(dfn.x<RRADIUS){\n             float ht=clamp(( dfn.x-RRADIUS) /(dfn.x-df.x),0.,1.);\n             hmin=min(hmin,ht);\n         }\n         \n        //STABILIZERS:       \n        F.w=abs(F.w)*1.+F.w;\n        F.zw/=max(hits,1.);        \n        //F.zw=sign(F.zw)*RRADIUS*(1.- exp(-abs(F.zw)*2.7));\n        F.zw=clamp(F.zw,-vec2(RRADIUS*1.),vec2(RRADIUS*1.));\n        F.xy=clamp(F.xy,-vec2(RRADIUS/dt*2.),vec2(RRADIUS/dt*2.)); \n                  \n   \n   \n        //apply velocity and impulse\n        U.xy += U.zw*dt*hmin +F.zw*max(hmin,UNFREEZING.x);    \n        U.xy = mod(U.xy, size);\n \n        //friction\n        U.zw*= pow(.99,dt);  \n         //apply forces\n        U.zw += F.xy *dt*max(hmin,UNFREEZING.y) +vec2(0,GR)*dt*max(hmin,UNFREEZING.z); \n         \n        \n        bool ghost=true;\n        ivec4 nb = getClosest(ivec2(U.xy));\n        for(int i = 0; i<4; i++)\n        {\n            if(nb[i]==id) {ghost=false; break;}\n        }\n        if(ghost) U.xy=-U.xy;\n        \n    }\n    else discard;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//particcle connection\n\nGETTERS\n\n#ifndef N8\n//sorting closest 4 particles\n\n\nivec4 u; //ids\nvec4 d; //distances\nvec2 pos; //this particle position\nint tid;\nbool ghost;\n\n//insertion sort\nvoid sort(int utemp)\n{\n    if(utemp == tid || utemp < 0) return;\n       \n   \tvec4 part = getParticle(utemp,ghost);\n    vec2 dx = part.xy - pos;\n    float dtemp = length(dx);\n    //sorting\n    if(dx.x > abs(dx.y))\n    {\n        if(d.x > dtemp) \n        {\n            d.x = dtemp;\n        \tu.x = utemp;\n        }\n    }\n    else if(dx.x < -abs(dx.y))\n    {\n        if(d.y > dtemp) \n        {\n            d.y = dtemp;\n        \tu.y = utemp;\n        }\n    }\n    else if(dx.y > abs(dx.x))\n    {\n        if(d.z > dtemp) \n        {\n            d.z = dtemp;\n        \tu.z = utemp;\n        }\n    }\n    else if(d.w > dtemp) \n    {\n        d.w = dtemp;\n        u.w = utemp;\n    }\n}\n\nvoid sortneighbor(int id)\n{\n    ivec4 nb = getNeighbor(id);\n    for(int j = 0; j < 4; j++)\n    {\n        sort(nb[j]);\n    }\n}\n\nvoid mainImage( out vec4 U, in vec2 fragCoord )\n{  \n    \n    ivec2 p = ivec2(fragCoord);\n\n    if(p.x > N.x || p.y > N.y) discard;\n    \n    int id = xy2i(p);\n     \n    u = ivec4(-1); d = vec4(1e10); \n   \n    tid = id;\n    pos = getParticle(id,ghost).xy;\n    \n    sortneighbor(id); \n    \n    for(int i = 0; i < NGH; i++)\n    {\n        //sort(hash(ivec4(p, iFrame, i)).x%tot_n); //random sort  \n        int id=(iFrame*NGH+i) % tot_n;\n        vec4 pp= getParticle(id,ghost);\n        if(ghost) sort(id); //random sort \n    }\n    ivec4 nc = getClosest(ivec2(pos));\n    for(int i = ZERO; i < 4; i++)\n    {\n        sort(nc[i]); \n    }\n    \n    ivec4 nb = getNeighbor(id);\n    for(int i = 0; i < 4; i++)\n    {\n        //sort 4x4  particles \n        sortneighbor(nb[i]); \n         ivec4 nbb = getNeighbor(nb[i]);\n        for(int j = 0; j < 4; j++)\n    \t{\n            //sort 4x4x4  particles\n            sortneighbor(nbb[j]); \n        }\n    }\n    \n    if( any(lessThan(u, ivec4(-1))) || any(greaterThan(u, ivec4(tot_n))))\n    {\n        u = ivec4(0);\n    }\n    \n    \n    U = intBitsToFloat(u);\n}\n#else\n\n//sorting closest 8 particles \n\nuvec4[2] u; //ids\nvec4[2] d; //distances\nvec2 pos; //this particle position\nuint tid;\nbool ghost;\n\n//insertion sort\nvoid sort(uint utemp)\n{\n    if(utemp == tid || utemp >=65536u) return; \n     if(  any(equal(u[0], uvec4(utemp))) ||  any(equal(u[1], uvec4(utemp)))) return;\n     \n       \n   \tvec4 part = getParticle(int(utemp),ghost);\n    vec2 dx = part.xy - pos;\n    float dtemp = length(dx);\n     \n\n    //sorting\n    if(d[0].x > dtemp )\n    {\n     \n        d[1]= vec4(d[0].w, d[1].xyz);\n        u[1]= uvec4(u[0].w, u[1].xyz);         \n        d[0] = vec4(dtemp, d[0].xyz);\n        u[0] = uvec4(utemp, u[0].xyz);\n    }\n    else if(d[0].y > dtemp && dtemp > d[0].x)\n    {\n     \n        d[1]= vec4(d[0].w, d[1].xyz);\n        u[1]= uvec4(u[0].w, u[1].xyz);\n         \n        d[0].yzw = vec3(dtemp, d[0].yz);\n        u[0].yzw = uvec3(utemp, u[0].yz);\n    }\n    else if(d[0].z > dtemp && dtemp > d[0].y)\n    {\n     \n        d[1]= vec4(d[0].w, d[1].xyz);\n        u[1]= uvec4(u[0].w, u[1].xyz);\n        \n        d[0].zw = vec2(dtemp, d[0].z);\n        u[0].zw = uvec2(utemp, u[0].z);\n    }\n    else if(d[0].w > dtemp && dtemp > d[0].z)\n    {\n  \n        d[1]= vec4(d[0].w, d[1].xyz);\n        u[1]= uvec4(u[0].w, u[1].xyz);\n          \n        d[0].w = dtemp;\n        u[0].w = utemp;\n    }\n     \n    else if(d[1].x > dtemp && dtemp > d[0].w)\n    {\n        d[1] = vec4(dtemp, d[1].xyz);\n        u[1] = uvec4(utemp, u[1].xyz);\n\n    }   \n    else if(d[1].y > dtemp && dtemp > d[1].x)\n    {\n        d[1].yzw = vec3(dtemp, d[1].yz);\n        u[1].yzw = uvec3(utemp, u[1].yz);\n    }\n    else if(d[1].z > dtemp && dtemp > d[1].y)\n    {\n        d[1].zw = vec2(dtemp, d[1].z);\n        u[1].zw = uvec2(utemp, u[1].z);\n    }\n    else if(d[1].w > dtemp && dtemp > d[1].z)\n    {\n        d[1].w = dtemp;\n        u[1].w = utemp;\n    }\n\n}\n\n\nvoid sortneighbor(int id)\n{\n    ivec4[2] nb = getNeighbor2(id);\n    for(int n=min(iFrame,0);n<2;n++)\n    for(int j = min(iFrame,0); j < 4; j++)\n    {\n        sort(uint(nb[n][j]));\n    }\n}\n\nvoid mainImage( out vec4 U, in vec2 fragCoord )\n{  \n    \n    ivec2 p = ivec2(fragCoord);\n\n    if(p.x > N.x || p.y > N.y) discard;\n    \n    int id = xy2i(p);\n     \n    u = uvec4[2](uvec4(65536u),uvec4(65536u));\n    \n    d = vec4[2](vec4(1e10),vec4(1e10)); \n   \n    tid = uint(id);\n    pos = getParticle(id,ghost).xy;\n    \n    sortneighbor(id); \n    \n    for(int i = ZERO; i < NGH + ZERO; i++)\n    {\n \n        int id=(iFrame*NGH+i) % tot_n;\n        vec4 pp= getParticle(id,ghost);\n        if(ghost) sort(uint(id)); //random sort \n    }\n    ivec4 nc = getClosest(ivec2(pos));\n    for(int i = ZERO; i < 4; i++)\n    {\n        sort(uint(nc[i])); \n    }\n    \n    ivec4[2] nb = getNeighbor2(id);\n    for(int n1= ZERO;n1<2;n1++)\n    for(int i =ZERO; i < 4; i++)\n    {\n        //sort 4x4  particles \n        sortneighbor(int(nb[n1][i])); \n         ivec4[2] nbb = getNeighbor2(nb[n1][i]);\n         for(int n2=ZERO;n2<2;n2++)\n        for(int j = ZERO; j < 4; j++)\n    \t{\n            //sort 4x4x4  particles\n            sortneighbor(nbb[n2][j]); \n        }\n    }\n    \n\n\n    \n   \n    U = uintBitsToFloat(u[0]+(u[1]*65536u));\n}\n\n\n#endif","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//4th order voronoi particle tracking for each screen position\n\nGETTERS\n\nivec2 cross_distribution(int i)\n{\n    return (1<<(i/4)) * ivec2( ((i&2)/2)^1, (i&2)/2 ) * ( 2*(i%2) - 1 );\n}\n\nivec4 u; //ids\nvec4 d; //distances\nvec2 pos; //pixel position\nbool ghost;\n\nfloat particleDistance(int id, vec2 p)\n{\n    return distance(getParticle(id,ghost).xy, p);\n}\n\n//insertion sort\nvoid sort(int utemp)\n{\n    if(utemp <0) return; \n   \tfloat dtemp = particleDistance(utemp, pos);\n    //sorting\n    if(d.x > dtemp)\n    {\n        d = vec4(dtemp, d.xyz);\n        u = ivec4(utemp, u.xyz);\n    }\n    else if(d.y > dtemp && dtemp > d.x)\n    {\n        d.yzw = vec3(dtemp, d.yz);\n        u.yzw = ivec3(utemp, u.yz);\n    }\n    else if(d.z > dtemp && dtemp > d.y)\n    {\n        d.zw = vec2(dtemp, d.z);\n        u.zw = ivec2(utemp, u.z);\n    }\n    else if(d.w > dtemp && dtemp > d.z)\n    {\n        d.w = dtemp;\n        u.w = utemp;\n    }\n}\n\nvoid sortpos(ivec2 p)\n{\n    ivec4 nb = getClosest(p);\n    for(int j = ZERO; j < 4; j++)\n    {\n        sort(nb[j]);\n    }\n}\n\nvoid sortPart(int id)\n{\n#ifdef N8  \n    ivec4[2] nb = getNeighbor2(id);\n    for(int n = ZERO; n < 2; n++)\n    for(int j = ZERO; j < 4; j++)\n    {\n        sort(nb[n][j]);\n    }\n#else\n    ivec4 nb = getNeighbor(id);\n    for(int j = ZERO; j < 4; j++)\n    {\n        sort(nb[j]);\n    }\n#endif\n}\n\nvoid mainImage( out vec4 U, in vec2 fragCoord )\n{\n    pos = fragCoord;\n    \n    if (any(greaterThan(pos,ceil(size) ))) { discard;} //skip pixels out of screen\n    \n    ivec2 p = ivec2(pos);\n     \n    u = ivec4(-1); d = vec4(1e10); \n   \n    sortpos(p); //resort this position, cause particles are moving\n    \n    //jump flood sorting; minimized gere, raising to 12 or 16 has small effect and  high impact on framerate  \n    for(int i = ZERO; i < 16; i++)\n    {\n        ivec2 p2 =p+cross_distribution(i);\n        \n        //if (! any(greaterThan(p2,ivec2(ceil(size)) )) && ! (! any(lessThan(p2,ivec2(0u) )))) \n        sortpos(p2); \n    }\n    \n    \n    // sort neighbors of closest particles\n    for(int i = ZERO; i<4; i++)\n    {\n        if(u[i]<0) continue;\n        sortPart(u[i]);       \n    }\n    \n    // if( any(lessThan(u, ivec4(-1))) || any(greaterThan(u, ivec4(tot_n))) )  u = ivec4(0); \n    \n    \n    U = intBitsToFloat(u);\n}\n","name":"Buffer C","description":"","type":"buffer"}]}