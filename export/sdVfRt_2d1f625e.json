{"ver":"0.1","info":{"id":"sdVfRt","date":"1658783492","viewed":121,"name":"Fourier approximation","username":"Envy24","description":"Fourier approximation on interval [-L; L].\nIt is normal that odd functions have oscillations.\nCompare with WolframAlpha to see, that this is correct.\nhttps://www.wolframalpha.com/input?i=Fourier+series+calculator&assumption=%7B%22F%22%2C+%22FourierSeries%","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["approximation","fourier","integration","numeric"],"hasliked":0,"parentid":"7dVfD1","parentname":"Plotter template_"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                           iResolution\n#define AR                        ( R.x / R.y )                      // Aspect ratio (AR > 1.0).\n#define TO_CENTERED_NDC(SC)       ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define UNIT                      (  8.0 / R.y  )\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n#define LMB_IS_HOLD               ( iMouse.z > 0.0 )\n#define PI                          3.1415926535897932\n#define NZMX                      ( (iMouse.x+iMouse.x-R.x) / R.x )  // in range [-1.0; 1.0]\n\nfloat vertical_line(vec2 NDC, float x0) { return SMAA(abs(NDC.x-x0)); }\nfloat horizontal_line(vec2 NDC, float y0) { return SMAA(abs(NDC.y-y0)); }\nfloat y_axis(vec2 NDC) { return SMAA(abs(NDC.x)); }\nfloat x_axis(vec2 NDC) { return SMAA(abs(NDC.y)); }\nfloat draw_func(vec2 NDC, float f, float dfdx)\n{\n    float df   = NDC.y - f;\n    return SMAA(abs(df) / sqrt(1.0 + dfdx * dfdx));\n}\n\n// Function that you want to approximate in interval [-L; L].\n/* odd, N = 64, num_of_knots = 32 *\n#define func(x)  ( (x) )\n#define deriv(x) ( 1. )\n/* even, N = 64, num_of_knots = 32 *\n#define func(x)  ( (x)*(x) )\n#define deriv(x) ( 2.*(x) )\n/* odd, N = 64, num_of_knots = 32 *\n#define func(x)  ( (x)*(x)*(x) ) \n#define deriv(x) ( 3.*(x)*(x) )\n/* even, N = 64, num_of_knots = 32 */\n#define func(x)  ( abs(x) ) \n#define deriv(x) ( x/abs(x) )\n/**\nfloat pulseOsc(\n    float amplitude,   // in range [0.0; 1.0]\n    float frequency,   // > 0.0\n    float time,        \n    float phase_shift,\n    float pulse_width)\n{\n    float TAU = 2.*PI;\n    float phase = phase_shift + time * TAU * frequency;\n    \n    float sign_ = fract(phase / TAU) >= pulse_width ? 1.0 : -1.0;\n\n    return sign_ * amplitude;\n}\n#define func(x) ( pulseOsc(1., 1., x, 0., 0.5) )\n#define deriv(x) ( 0. )\n/**/\n\nconst int min_treshold = 2;\nconst int num_of_knots = max(32,  min_treshold); // pick number of knots.\nconst int N = 2*num_of_knots;                    \nconst int num_of_coefs = num_of_knots * 2 + 1;\nfloat coefs[num_of_coefs];\n\nvoid calculate_coefs0(\n    inout float coefs[num_of_coefs],\n    in float L, // defines interval [-L, L].\n    in float n)\n{   \n    float dx = (2.*L)/n, invL = 1./L, invMAP = PI*invL;\n    \n    int a_offset = 1;\n    int b_offset = 1 + num_of_knots;\n    \n    for (float i = 0.; i < n; i+=1.)\n    {\n        coefs[0] += func(-L+i*dx); \n    }\n    coefs[0] *= dx*0.5*invL; \n\n    for (int c = 0; c < num_of_knots; ++c)\n    { \n        coefs[a_offset] = 0.0; coefs[b_offset] = 0.0;\n    \n        for (float i = 0.0; i < n; i+=1.) // good for even functions\n        //for (float i = 0.0; i <= n; i+=1.) // good for odd functions, because with i==n sum contains f(-L) + f(L) == -f(L) + f(L) == 0.\n        { \n            float x = -L + i * dx;\n            coefs[a_offset] += func(x)*cos(float(c+1) * x * invMAP);\n            coefs[b_offset] += func(x)*sin(float(c+1) * x * invMAP); \n        }   \n\n        coefs[a_offset] *= dx*invL; coefs[b_offset] *= dx*invL;      \n        ++a_offset; ++b_offset;\n    }\n}\n\nvoid calculate_coefs1(\n    inout float coefs[num_of_coefs],\n    in float L, // defines interval [-L, L].\n    in int num_of_samples)\n{                                 \n    float ys[N]; // N == num_of_samples  \n    float dx = (2.*L) / float(num_of_samples),\n          invN = 1. / float(num_of_samples),                // Normalization coefficient for Ai, Bi.\n          invMAP = PI / L;                                  // Normalization coefficient for x.\n     \n    int a_offset = 1;\n    int b_offset = 1 + num_of_knots;\n    \n    for (int j = 0; j < num_of_samples; ++j)\n    {      \n        ys[j] = func(-L + float(j) * dx);                   // Sample function at equispaced points.\n        coefs[0] += ys[j];                                  // Calculate A0.\n    }\n    coefs[0] *= invN;                                       // Normalize A0.\n    \n    for (int i = 0; i < num_of_knots; ++i)                  // Loop through pairs (Ai, Bi).\n    { \n        for (int j = 0; j < num_of_samples; ++j)            // Loop through sampled values.\n        {\n            float x = (-L + float(j) * dx);                 // Calculate x.\n                  x *= invMAP;                              // Map x from [-L; L] to [-PI; PI]\n            coefs[a_offset] += ys[j] * cos(float(i+1) * x); // Calculate Ai.\n            coefs[b_offset] += ys[j] * sin(float(i+1) * x); // Calculate Bi.\n        }\n        \n        coefs[a_offset] *= 2. * invN;                       // Normalize Ai.\n        coefs[b_offset] *= 2. * invN;                       // Normalize Bi.\n        \n        ++a_offset; ++b_offset;\n    }    \n}\n\nfloat eval(\n    in float coefs[num_of_coefs],\n    in float L, // defines interval [-L, L].\n    float x)\n{\n    float sum = coefs[0];\n    \n    int a_offset = 1;\n    int b_offset = 1 + num_of_knots;\n    \n    x = x*PI/L;\n    for (int i = 0; i < num_of_knots; ++i)\n    {\n        sum += \n            coefs[a_offset + i] * cos(float(i+1) * x) +\n            coefs[b_offset + i] * sin(float(i+1) * x);\n    }\n    \n    return sum;\n}\n\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n#define GSCALE 3.0\n#define YSCALE 1.0\n#define OFFSET vec2(0., 0.)\n\n    vec2 NDC = \n        LMB_IS_HOLD ?\n            GSCALE*(TO_CENTERED_NDC(SC-(iMouse.xy-R.xy*0.5))+OFFSET) :\n            GSCALE*(TO_CENTERED_NDC(SC)+OFFSET);\n\n    vec3 color = vec3(1.);\n         color -= x_axis(NDC); color -= y_axis(NDC);\n         color.rb -= draw_func(NDC, YSCALE*func(NDC.x), YSCALE*deriv(NDC.x));\n\n    float n = float(N), L = 1.0;\n    \n         color.gb -= vertical_line(NDC, -L); color.gb -= vertical_line(NDC, L);\n    \n    /**\n    if (func(-1.) != func(1.)) { calculate_coefs0(coefs, L, n); }\n    else { calculate_coefs1(coefs, L, N); }\n    /**/\n    \n    //calculate_coefs0(coefs, L, n);\n    calculate_coefs1(coefs, L, N); \n\n    /* All values of approximated function */\n    float dx = 0.01,\n          f  = YSCALE*eval(coefs, L, NDC.x),\n          fn = YSCALE*eval(coefs, L, NDC.x+dx);  \n    color.rg -= draw_func(NDC, f, (fn-f)/dx);\n    \n    /* One value of approximated function */\n    float x = sinOSC(-L, L, iTime*.5);\n          f = YSCALE*eval(coefs, L, x);\n    color = mix(color, vec3(1, 0, 1), SMAA(diskSDF_L2(NDC, vec2(x, f), UNIT*2.2)));\n    /**/\n        \n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nfloat diskSDF_L2(vec2 NDC, vec2 C, float R)\n{\n    return length(C - NDC)-R;\n}\n\nfloat segmentSDF_L2(\n    in vec2 NDC,\n    in vec2 B,   \n    in vec2 E)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0));\n}","name":"Common","description":"","type":"common"}]}