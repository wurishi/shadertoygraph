{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"XdfGR8","filepath":"/media/previz/buffer03.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"channel":2,"type":"texture","id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"channel":3,"type":"texture","id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// fork of Cloth Flag https://shadertoy.com/view/ttlcD7\n// someone else has the name 'Old Glory' already, but not public?\n\n// TODO soundcloud of Star Spangled Banner\n// should use this one hehe:\n// https://soundcloud.com/nedluberecki/star-spangled-banner\n// might have to put it in\n// one of the channels of one of the buffers,\n// since Image tab nas no channels left.\n\n// since I'm publicizing this around 4th of July,\n// and I live in USA, I made it a U.S. flag with\n// firework-like lights.  \n// can be swapped out for any flag colors you like.\n// the original Cloth Flag has an animated nyancat!\n\n// Redo of a cloth sim I made a long time ago.\n// But never had to do it all in a frag shader before!  ;)\n// honestly the WebGL frag shader situation is not ideal for this task;\n// Uses analytical intersections because ray marching many triangles was too slow!\n\n// Probably not the best cloth physics or rendering,\n// but it's what I've got going in WebGL atm.\n// Definitely not the best fireworks! \n\n// borrows heavily from reinder & iq's \n// compilation at https://shadertoy.com/view/tl23Rm\n\n// FIXME the flag physics seems a little spastic\n\n// TODO fireworks!!  idk maybe small ones off in the distance?\n// for now has moving colored point lights\n// which simulate moving fireworks?  good enough for this.\n// The fireworks display isn't really the point,\n// it's only there since it happens to be that time of year,\n// and to show off the specular colored lighting a bit.\n// TODO it's gonna be dark, so may need a spot light\n// to highlight the flag & pole area\n// TODO clouds? smoke? razzle dazzle?  lens flares? \n// how slow do you want to make this thing?!\n// proper bloom needs buffers and I've none left!\n\n#define FIREWORKS 0\n#define ClothBuf iChannel0\n\nconst vec3 sunDir = normalize(vec3(.5,.04,.8))\n, skyColor = .05*vec3(.1,.4,.7) //vec3(.1,.5,.9) //\n, sunColor = vec3(2.2)\n, glowColor = vec3(2.,1.4,1.1)*1.4;\n\nconst float ambient = .01\n, specpower = 64.\n;\n\n// TODO Having some sort of acceleration structure,\n// such as a spatial index of closest nearby particle,\n// would help with rendering.\n\n// I figure since we're brute forcing it all anyway\n// and having to iterate over the particles more than once\n// may as well just load them all into a big array, right?\n// on cpu that would be a fine strategy, but on gpu probably not.\n// It'll be ok up to a certain total particle count,\n// but then again, the alternative, re-reading them\n// and relying on compiler to discard duplicates,\n// seems more unwise.  For now it seems ok up to 12x9 or so.\n\n// loading all particles at once at start of mainImage\n// seems wise, otherwise we'd wind up needing to do it all\n// multiple times per pixel per frame, as it's all referenced\n// inside the main raymarch loop to draw the links!\nvec3[nlinkx*nlinky] ps;\n\nvec3 flagbblo, flagbbhi; // world AABB bounding box of flag particles\n    \nint pidx(int i, int j) \n{ \n    return i + j * nlinkx; \n}\n\nvec3 vnormal(ivec2 p)\n{\n    ivec2 i = p;\n    i = clamp(i, ivec2(0), ivec2(nlinkx, nlinky)-2);\n    int j = pidx(i.x,i.y);\n    vec3 n0 = ps[j]; // must normalize prior to blending\n    return normalize(cross(ps[j+1]-n0, ps[j+nlinkx]-n0));\n}\n\nvec3 vnormal(vec2 q)\n{\n    ivec2 i = ivec2(floor(q));\n    vec2 f = q - vec2(i);\n    // now should be a simple matter of bilinear interpolation\n    // but doing it this way means we need 4 normals to lerp between, not 3\n    vec3 sn00 = vnormal(i)\n    , sn01 = vnormal(i + ivec2(1,0))\n    , sn10 = vnormal(i + ivec2(0,1))\n    , sn11 = vnormal(i + ivec2(1));\n    return mix(mix(sn00, sn01, f.x)\n             , mix(sn10, sn11, f.x), f.y);\n}\n\n// my intersection interface uses out args\n// out args are only valid if returned time\n// indicates a valid intersection (is positive)\n\n// Ray/Triangle through vertices v0, v1 and v2, reworked by spalmer\n// original by iq from https://iquilezles.org/articles/intersectors\n// just reusing the same variables, made all relative to v0 implicitly\n// changed interface to use out args\nfloat iTri(vec3 ro, vec3 rd          // ray org and dir\n         , vec3 v0, vec3 v1, vec3 v2 // vertices\n         , out vec3 n, out vec2 uv)  // normal and uv at hit point, returns hit time\n{\n    v1 -= v0; v2 -= v0; ro -= v0;\n          n = cross(v1, v2);\n    vec3  q = cross(ro, rd);\n    float d = 1.0 / dot(rd, n)\n    , u = -d * dot(q, v2)\n    , v =  d * dot(q, v1)\n    , t = -d * dot(n, ro);\n    if (u < 0.0/* || u > 1.0*/ || v < 0.0 || u+v > 1.0) t = -1.0;\n    if (dot(n, rd) > 0.) n = -n; //, u = -u; // double-sided, use whichever side faces ray origin\n    // FIXME flat shaded normals; should gouraud shade at least; interpolate between 3 normals\n    // maybe only after final closest hit determined?  Think it could still be done then.\n    //else n = normalize(n); // will be normalized at end of scene trace pass once all objects considered\n    uv = vec2(1.-u, v); // FIXME straighten out these sign HACKS\n    return t;\n}\n// see also https://shadertoy.com/view/MlGcDz which has several MIT licensed variations\n\n// Ray/Plane - modified from reinder's compilation at https://shadertoy.com/view/tl23Rm\nfloat iPlane(vec3 ro, vec3 rd//, vec2 distBound\n           , vec3 planeNormal, float planeDist\n           , out vec3 normal, out vec2 uv)\n{\n    float a = dot(rd, planeNormal);\n    float t = -(dot(ro, planeNormal) + planeDist) / a;\n    if (a > 0.0 || t < 0.0) // || t < distBound.x || t > distBound.y)\n        t = -1.0;\n\telse \n        normal = planeNormal, uv = (ro + rd * t).xz;\n\treturn t;\n}\n\n// Ray/Sphere - modified from reinder's compilation at https://shadertoy.com/view/tl23Rm\n// https://shadertoy.com/view/4d2XWV\nfloat iSphere(vec3 ro, vec3 rd\n              , vec3 center, float sphereRadius\n              , out vec3 normal, out vec2 uv)\n{\n    ro -= center;\n    float b = dot(ro, rd)\n    , c = dot(ro, ro) - sphereRadius*sphereRadius\n    , h = b*b - c\n    , d = -1.0;\n    if (h >= 0.) {\n\t    h = sqrt(h);\n        float d1 = -b-h\n        , d2 = -b+h;\n        if (d1 >= 0.) {\n            normal = ro + rd*d1;\n            d = d1;\n        } else if (d2 >= 0.) {\n            normal = ro + rd*d2;            \n            d = d2;\n        }\n    }\n    uv = vec2(.5); // TODO unused though\n    return d;\n}\n\n// Ray/Cylinder - modified from reinder's compilation at https://shadertoy.com/view/tl23Rm\n// Capped Cylinder: https://shadertoy.com/view/4lcSRn\nfloat iCylinder(vec3 ro, vec3 rd\n               , vec3 A, vec3 B, float r\n               , out vec3 normal, out vec2 uv)\n{\n    vec3 ca = B-A\n       , oc = ro-A;\n    float caca = dot(ca,ca)\n        , card = dot(ca,rd)\n        , caoc = dot(ca,oc)\n    , a = caca - card*card\n    , b = caca * dot(oc, rd) - caoc*card\n    , c = caca * dot(oc, oc) - caoc*caoc - r*r*caca\n    , h = b*b - a*c\n\t, d = -1.0;\n    if (h >= 0.) {\n\t    h = sqrt(h);\n\t    d = (-b-h)/a;\n\t    float y = caoc + d*card;\n\t    if (y > 0. && y < caca)\n\t        normal = oc+d*rd-ca*y/caca, uv = vec2(atan((oc+d*rd).x, (oc+d*rd).z), 2. / pi / r * length(ca) * y / caca);\n\t    else {\n\t\t    d = ((y < 0. ? 0. : caca) - caoc) / card;    \n\t\t    if (abs(b+a*d) < h && d >= 0.0)\n\t\t\t\tnormal = ca*sign(y)/caca, uv = (oc+d*rd).xz;\n\t\t\telse\n\t\t\t\td = -1.0;\n\t    }\n    }\n\treturn d;\n}\n\n// for a fake building or something for some scenery, also for bounding box of flag\n// Box: - modified from reinder's compilation at https://shadertoy.com/view/tl23Rm\n// derived from https://shadertoy.com/view/ld23DV\nfloat iBox(vec3 ro, vec3 rd\n           //, vec2 distBound\n           , vec3 boxSize\n           , out vec3 normal, out vec2 uv) \n{\n    vec3 m = sign(rd)/max(abs(rd), 1e-8);\n    vec3 n = m*ro;\n    vec3 k = abs(m)*boxSize;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max(max(t1.x, t1.y), t1.z);\n\tfloat tF = min(min(t2.x, t2.y), t2.z);\n\tfloat d = -1.;\n    normal = vec3(0,1,0); uv = vec2(.5);\n    if (tN <= tF && tF > 0.) {\n        //if (tN >= distBound.x && tN <= distBound.y) {\n        \tnormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n            d = tN;\n        //} else if (tF >= distBound.x && tF <= distBound.y) { \n        //\tnormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n        //    d = tF;\n        //}\n    }\n    return d;\n}\n\nconst int\n  mSky  = 0\n, mLand = 1\n, mPole = 2\n, mFlag = 3\n;\n\nvec3 texcol(sampler2D ch, vec2 uv)\n{\n    return pow(texture(ch, uv).rgb, vec3(2.2));\n}\n\nconst vec2 phase90 = vec2(.5*pi, 0);\n// I worked this star all out in my Dist 2D toy, \n// copied relevant primitive ops here\n// TODO should inline it all now\nvec2 lathe(vec2 p, vec2 b) // unrotate any axis to +Y\n{\n\tfloat l = length(b);\n\tfloat y = dot(p, b) / l;\n\tfloat x = length(p - y / l * b);\n\treturn vec2(x, y);\n}\n// without vertex voronoi test\nfloat dpieYsharp(vec2 p, vec2 cs)\n{\n\tp.x = abs(p.x);\n\treturn length(p - cs.yx * dot(p, cs.yx)) \n\t    * sign(cs.x*p.x - cs.y*p.y);\n}\n// along +Y\nfloat dpieY(vec2 p, vec2 cs)\n{\n    float x = dpieYsharp(p, cs);\n    return -abs(p.x)*cs.y > p.y ? max(length(p), x) : x;\n}\n\nfloat dpie(vec2 p, vec2 d, vec2 cs) // arc? cone2D? cs = cos&sin of the aperture\n{\n    return dpieY(lathe(p, d), cs); // unrotate so d -> y\n}\n// my star using my dpie\nfloat dstar5(vec2 q)\n{\n    q.x = abs(q.x); // symmetry\n    const vec2 cs = sin(phase90 + radians(18.))\n    , po0 = vec2(0,1)\n    , po1 = sin(phase90.yx + .4*pi)\n    , po2 = sin(phase90.yx + .8*pi);\n    float d1 = dpie(q - po1, -po1, cs)\n        , d2 = max(q.y-.5, dpie(q - po2, -po2, cs))\n        , d0 = dpieY(po0 - q, cs)\n    , d = 3.4e38;\n    if (dot(q, po1) > 0.) d = d1;\n    if (dot(q, po2) > 0.) d = min(d, d2);\n    if (dot(q, po0) > 0.) d = min(d, d0);\n    return d;\n}\n/* * /\n// almost used star shape from 'Psycho dots' by Nrx at https://shadertoy.com/view/XlsSR4\nfloat dstarNrx(vec2 q)\n{\n    return length(q) - .45 * (1. + .15 * cos(atan(q.x, q.y) * 5.));\n}\n/**/\nfloat dStar(vec2 q)\n{\n    q.y *= -1.; // otherwise they'd be upside down\n    return dstar5(q * 2.) / 2.;\n//    return dstarNrx(q);\n//    return length(q) - .3; // simple dots\n}\n\n// given world space position, return closest voxel id\nivec2 starid(vec2 p)\n{\n    ivec2 i = ivec2(round(p));\n    // FCC cell tiling\n    if (((i.x^i.y)&1) != 0) {\n        vec2 d = p - vec2(i);\n        vec2 a = abs(d);\n        if (a.x > a.y) i.x += int(sign(d.x));\n        else           i.y += int(sign(d.y));\n    }\n    return i;\n}\n\n// FIXME antialias!\nvec3 FlagColor(vec2 uv)\n{\n    uv.y = 1.-uv.y; // vertical flip\n    // USA flag\n    vec2 slocal = uv*vec2(24., 19.) + vec2(-.5,-1.);\n    ivec2 sid = starid(slocal);\n    bool in50 = all(lessThanEqual(uvec2(sid), uvec2(10,8)));\n    slocal -= vec2(sid); //fract(slocal)-.5\n    float starcov = in50 ? clamp(.5-5.*dStar(slocal * vec2(2,1)), 0., 1.) : 0.;\n    //float tatters = step(.1, texture(iChannel1, uv*2.).r); // meh - needs alpha, too complicated :(\n    vec3 c = all(lessThan(uv, vec2(.465, .538)))\n      ? mix(vec3(.1,.1,.4), vec3(.7), starcov)\n      : mix(vec3(.5,.1,.1), vec3(.7), step(.5, fract(uv.y*6.5))); // stripes\n    // TODO smoothstep stripes\n    return c; // * tatters;\n}\n\nvec3 albedo(int m, vec2 uv)\n{\n    vec3 c = vec3(.5);\n    switch(m) {\n        case mSky:  c = skyColor; break;\n        case mLand: c = texcol(iChannel1, uv / 2.).r * vec3(.5,.3,.1); break;\n        case mPole: c = texcol(iChannel2, uv / 8.); break;\n        case mFlag: c = FlagColor(uv); break;\n    }\n    return c;\n}\n\nvoid checkT(inout int id, inout float t, inout vec3 n, inout vec2 uv\n          , int idl, float tl, vec3 nl, vec2 uvl)\n{\n    if (tl > 0. && tl < t) id = idl, t = tl, n = nl, uv = uvl;\n}\n\nfloat raytraceScene(vec3 ro, vec3 rd, float maxd, out int m, out vec3 n, out vec2 uv)\n{\n    int id; float t = 3.4e38, t0; vec3 n0; \n    n = n = rd; //vec3(0); //vec3(0,1,0); // fine, just don't light sky normally  // botches sky lighting\n    vec2 uv0, uvnorm = 1.0 / vec2(nlinkx-1,nlinky-1);\n    // bounding sphere to cull the flag detail, or full screen perf tanks\n    if (iSphere(ro, rd, vec3(0, orbitheight*.95, 0) + globalwind * .6, flagLength * 1.25, n0, uv0) > 0.)\n    // in fact that sphere is so loose it doesn't help all that much,\n    // and it seems worth it to build a tighter AABB for culling rays\n\tif (iBox(ro - .5*(flagbblo+flagbbhi), rd, .5*(flagbbhi-flagbblo), n0, uv0) >= 0.)\n    for (int j = 0; j < nlinky-1; ++j)\n\tfor (int i = 0; i < nlinkx-1; ++i) {\n        t0 = iTri(ro, rd, ps[pidx(i+1, j)], ps[pidx(i+1, j+1)], ps[pidx(i, j)], n0, uv0);\n        uv0.x = 1.-uv0.x; uv0.y = 1.-uv0.y;\n        checkT(m, t, n, uv, mFlag, t0, n0, (uv0.yx + vec2(i,j)) * uvnorm);\n        t0 = iTri(ro, rd, ps[pidx(i, j+1)], ps[pidx(i, j)], ps[pidx(i+1, j+1)], n0, uv0);\n        checkT(m, t, n, uv, mFlag, t0, n0, (uv0.yx + vec2(i,j)) * uvnorm);\n    } // triangles\n    // TODO BVH or some other spatial acceleration structure\n  #if 1\n    if (m == mFlag) {\n\t    // if we hit any triangle so far, we'll have its normal and uv now\n\t    // now it a great time to compute the smooth surface normal\n\t    // so we don't have to do it more than once\n\t    vec2 uvpt = uv * vec2(nlinkx-1,nlinky-1); // address in terms of cloth particle grid index\n\t    n = vnormal(uvpt);\n        if (dot(n, rd) > 0.) n = -n; // always facing viewer\n    }\n  #endif\n    t0 = iPlane(ro, rd, vec3(0,1,0), 0., n0, uv0);\n    checkT(m, t, n, uv, mLand, t0, n0, uv0);\n    t0 = iCylinder(ro, rd, vec3(0), vec3(0,poleheight,0), .03, n0, uv0); // FIXME hard-coded oradius or hoist\n    checkT(m, t, n, uv, mPole, t0, n0, uv0);\n  #if 1 \n    // \"buildings\" for some simple modern-ish scenery\n    t0 = iBox(ro - vec3(-20,2,8), rd, vec3(15,2,3), n0, uv0);\n    checkT(m, t, n, uv, mPole, t0, n0, uv0);\n\tt0 = iBox(ro - vec3(8,2,-20), rd, vec3(3,2,15), n0, uv0);\n    checkT(m, t, n, uv, mPole, t0, n0, uv0);\n\tt0 = iBox(ro - vec3(2,1.5,-35), rd, vec3(8,1.5,13), n0, uv0);\n    checkT(m, t, n, uv, mPole, t0, n0, uv0);\n  #endif\n\tif (t < 0. || t > maxd) t = maxd;\n    else n = normalize(n);\n    return t;\n}\n\n// monochrome light only does falloff for one channel,\n// but you can use it for all rgb channels\nfloat pointLight(vec3 surfpos, vec3 n, vec3 lp, float lumin)\n{\n    lp -= surfpos; float l2 = dot(lp, lp);\n    float d = dot(n, lp) / sqrt(l2); //l2;\n    float nl = max(d, 0.);\n    return nl * exp2(-l2); // * lumin\n}\n\nfloat pointGlare(vec3 ro, vec3 rd, vec3 lp, float lumin)\n{ // extreme HACK just so I can see the light sources directly\n    // TODO need a better falloff computation\n    lp -= ro;\n    float d = dot(rd, lp) / length(lp);\n    float c = max(d, 0.); //(d+1.)/2.;\n    //float g = acos(clamp(d, -1., 1.));\n    //float s = sqrt(max(0., 1. - c*c));\n    return 4.*pi* lumin * pow(c, 256.) / dot(lp,lp); //  4.*exp2(-2.*pi*g*g); // lumin\n}\n\n#if FIREWORKS\n    // my \"fireworks\" are just colored point lights\n    // whizzing through the sky with a fakie\n    // animated texture noisy modulated flashy effect\n    // nothing fancy, and I didn't want to get into\n    // a full-blown particle sim because the toy\n    // is already getting too slow with just the flag\nconst int nlights = 1;\nvec3[nlights] lightpos;\nvec3[nlights] lightcolor;\n\nvec3 hue(float h)\n{ // bad rainbow palette\n    return max(cos(vec3(0,2,4) + 2. * pi * h), 0.);\n}\n\nvoid InitLights(vec2 p)\n{\n    float t0 = iTime * .2, t1 = iTime * .3, t2 = iTime * 1.;\n    lightpos[0] = vec3(sin(t0), 0, cos(t0))*.8 \n        + vec3(0, sin(t2) * 6., 0);\n    //lightpos[0] = vec3(sin(t0), 0, cos(t0))*1.3 + vec3(0,.9,0);\n//    lightpos[1] = vec3(sin(t1), 0, cos(t1))*1.2 + vec3(0,.8,0);\n//    lightpos[2] = vec3(sin(t2), 0, cos(t2))*1.1 + vec3(0,.7,0);\n//    lightcolor[0] = vec3(1,0,0);\n//    lightcolor[1] = vec3(0,1,0);\n//    lightcolor[2] = vec3(0,0,1);\n    float flarephase = max(0., fract(t2 / 2./pi - .35) * 2.-1.)\n        * step(.5, lightpos[0].y);\n    lightcolor[0] = hue(iTime * .05 / pi)\n         // above ground?\n        * 1. * flarephase // timing\n        * mix(1., max(0., sin(72.*iTime)), flarephase*flarephase)\n        // + 4. * texture(iChannel3, p / iChannelResolution[3].y).b))\n        * exp2(1.+12.*flarephase*flarephase)\n        // FIXME Needs bigger pop, fadeout\n        /// (.01+.05*max(lightpos[0].y,.0))\n        ;\n}\n\nvec3 pointLightsShade(vec3 v, vec3 hp, vec3 n, float spec)\n{\n    vec3 lite = vec3(0);\n    for (int i = nlights; i-- > 0; ) {\n        lite += pointLight(hp, n, lightpos[i], length(lightcolor[i])) * lightcolor[i];\n        vec3 tol = lightpos[i] - hp;\n        float nl = dot(n, normalize(tol));\n        if (nl > 0. && spec > 0.) { // fake specular\n            vec3 h = normalize(sunDir+v);\n            float nh = dot(n,h), ll = dot(tol, tol);\n            nh = max(nh, 0.);\n            lite += nl\n                * (\n                exp2(-1.*ll) // diffuse attenuates quickly\n                + (pow(nh, specpower) * specpower * spec * .038)\n                * exp2(-.17*ll) // spec attenuates slower\n                ) * lightcolor[i];\n        }\n    }\n\treturn lite;\n}\n\nvec3 pointLightsGlare(vec3 ro, vec3 rd, vec2 uv, float t)\n{\n    vec3 lite = vec3(0);\n    for (int i = nlights; i-- > 0; ) // FIXME need lumi? HACK using length\n        lite += pointGlare(ro, rd, lightpos[i], length(lightcolor[i])) * lightcolor[i];\n    lite *= 1.-exp2(-.5*t); // HACK using total optical depth instead of depth thru the medium in range of the light\n    // probably should limit somehow\n    // anyway this whole thing is a big ol' hack atm, don't worry,\n    // I plan on replacing it with something better if I can find my old glare stuff\n    //float flarephase = .5; //max(0., fract(t2 / 2./pi - .35) * 2.-1.)\n    //    * step(.5, lightpos[0].y);\n    lite *= texture(iChannel1, 2.*uv / iResolution.y// * (.1+flarephase)\n                   ).r;\n    lite *= fract(texture(iChannel3, .05*uv/iChannelResolution[3].y).r + 2.*iTime);\n    return lite;\n}\n#endif\n\nvoid InitParticles()\n{\n\t// Because pold isn't reference here,\n\t// compiler should eliminate fetches of\n\t// unused second pixel of each particle.  I hope!\n    flagbblo = vec3(9e9); flagbbhi = vec3(-9e9);\n    for (int j = 0; j < nlinky; ++j)\n        for (int i = 0; i < nlinkx; ++i) {\n\t\tvec3 p = ps[pidx(i, j)] = particle(ClothBuf, ivec2(i, j)).pnew;\n        flagbblo = min(flagbblo, p); flagbbhi = max(flagbbhi, p);\n    }   \n}\n\nvec3 RenderScene(vec2 p, vec3 ro, vec3 rd)\n{\n    InitParticles();\n  #if FIREWORKS\n    InitLights(p);\n  #endif\n    // TODO antialiasing, probably simple SSAA\n    const float maxd = 16.; //64.; //32.; //12.; \n    vec3 n; vec2 uv; int m;\n    float t1 = raytraceScene(ro, rd, maxd, m, n, uv)\n    //, t2 = traceScene(ro, rd, maxd, 64)\n    , t = t1 //min(t1, t2)\n    , d;\n    if (!(t >= 0.) || t > maxd) { t = maxd; n = rd; d = maxd; }\n    //else {\n        //n = normalScene(h, .01, d);\n    //}\n    //if (dot(n, rd) > 0.) return vec3(1,0,1);\n\tvec3 h = ro + rd * t;\n    float nl = dot(n, sunDir), onl = max(0., nl), nv = clamp(dot(rd, sunDir), 0., 1.);\n    //if (nl < 0.) return vec3(1,1,0);\n    vec3 c = albedo(m, uv)\n    , glare = vec3(0);\n    float spec = 0.;\n    if (m == mFlag || m == mPole) spec = .04;    \n    else if (m == mSky) nl = 1.;\n    if (nl > 0. && spec > 0.) { // fake specular from sun\n        vec3 h = normalize(sunDir-rd);\n        float nh = dot(n,h);\n        nh = max(nh, 0.);\n        c += pow(nh, specpower) * specpower * .038 * nl * spec * mix(c, vec3(1), .3);\n    }\n    if (m == mFlag) {\n        nl = nl * (nl < 0. ? -.2 : 1.); //abs(nl); //mix(nl, 1., .7); // double-sided lighting\n        nl += .4 * pow(max(dot(rd, sunDir), 0.), 4.); // fake back-lit SSS\n    }\n//    nl = mix(nl, 1., .02); // ambient wrap lighting hack\n    if (m == mSky) {\n    //    nl += 1. * pow(max(onl, 0.), 16.);\n    //    nl = mix(nl, 1., .1); // sky lighting hack\n        // stars - use blue noise - that'll do for now\n        vec2 suv = rd.xz;\n        suv *= inversesqrt(max(.02,rd.y)); // fix stars texcoords stretched at horizon\n    \tglare += smoothstep(.96,.98,\n            texture(iChannel3, suv * .0625).r) * max(0.,rd.y); //sqrt(max(0.,rd.y));\n        //c += vec3(0,0,2);\n    }\n    nl = max(0., nl);\n    nl = mix(nl, 1., ambient); // main ambient hack\n    if (m == mSky || m == mLand) {\n        glare += pow(max(0., 1.-abs(rd.y)), 8.) * (1.-exp2(-.03*t)); // fake horizon fog\n\t    // * (1.-exp2(-.6 * t))\n        vec3 gl = glowColor * (m == mLand ? .8 : 1.) * .25; // sun halo\n        glare += gl * 1. * pow(nv, 64.)\n               + gl *  .6 * pow(nv, 16.);\n    }\n  #if FIREWORKS\n    if (m != mSky && dot(n, rd) < 0.)\n        c += pointLightsShade(-rd, h, n, spec);\n   \tglare += pointLightsGlare(ro, rd, p, t);\n  #endif\n    return sunColor * nl * c + glare;\n}\n\nvoid mainImage(out vec4 c, vec2 p)\n{\n    c = vec4(0,0,0,1);\n    vec2 R = iResolution.xy\n    , M = iMouse.xy\n    , q = StoQ(   p, R)\n    , m = StoQ(M.xy, R);\n    if (length(M.xy) <= 1.)\n        m = vec2(.2 - .02*iTime,.15); // unattended, mouse in bottom left corner?\n    vec3 object_pos = vec3(0, orbitheight, 0) + globalwind * .4\n    , camera_dir = OrbitCamera(m)\n    , camera_pos = object_pos - orbit_scale * orbitheight * camera_dir; // LookAt\n    camera_pos.y = max(camera_pos.y, 1e-2); // do not go beneath ground\n    camera_dir = normalize(object_pos - camera_pos); // redo LookAt after clamp\n    mat3 cam = CameraMatrix(camera_dir, vec3(0, 1, 0));\n    float hfovy = pi/6.\n    , rnd = texelFetch(iChannel3, ivec2(p) % ivec2(iChannelResolution[3].xy), 0).r; //hash(p);\n    if (iMouse.z > 0.) hfovy *= .5; // zoom while mousing\n    vec3 vd = normalize(vec3(q, 1./sin(hfovy)))\n    , ro = camera_pos, rd = normalize(cam * vd); // view ray\n    c.rgb = RenderScene(p, ro, rd);\n//    c.rgb = texelFetch(BufferA, ivec2(p)/16, 0).rgb; // debug particles\n    c.rgb = pow(c.rgb, vec3(1./2.2)); // srgb gamut\n    c.rgb += vec3(.75/256. * (rnd * 2. - 1.)); // dither quantization bands\n}\n\n","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"#define IZERO min(0, iFrame)\n\nconst float\n  pi = acos(-1.) //3.141592\n, orbit_scale = 1.3\n, poleheight = 2.\n, drag = .13 // hack, really; should flow with wind if anything\n, hoist = .8 // height on pole of attachment\n, orbitheight = poleheight * hoist * .9\n, linksag = .01 // squishiness of link constraints\n, ropesag = .2\n, flutter = 100.\n, diagmul = .6\n, unfold = 12.\n, windvar = .1 //.2\n, windgust = .1 //.3\n, gravity = 9.8; // m/s/s\n\nconst vec3 globalwind = vec3(1.,.01,.01) * .15;\n\nconst int\n  nlinkx = 12 //15 //10 //\n, nlinky = 7  //9  //6  //\n;\n\nconst float\n  flagLength = poleheight / 3.\n, flagWidth = flagLength * float(nlinky) / float(nlinkx)\n, llen = flagLength / float(nlinkx-1);\n\n// to signed aspect correct uv given screen pixel and resolution\nvec2 StoQ(vec2 s, vec2 r)\n{\n\treturn (2. * s - r) / r.y;\n}\n\nvec2 cossin(float rads)\n{\n    return vec2(cos(rads), sin(rads)); //sin(vec2(.5*pi,0) + rads); //\n}\n\n// build a 3x3 camera orientation matrix given forward direction vector, assuming up is +Y\nmat3 CameraMatrix(vec3 camFwd, vec3 camUp)\n{\n    vec3 w = normalize(camFwd)\n       , u = normalize(cross(camUp, w))\n       , v = normalize(cross(w, u));\n    return mat3(u, v, w);\n}\n// then transform by pw = MC * pv;\n\nvec3 sph2cart(vec3 a) // spherical radians theta, psi, radius -> cartesian\n{\n    vec2 u = cossin(a.x), v = cossin(a.y);\n    return vec3(u.y*v.x, v.y, u.x*v.x) * a.z;\n}\n\nvec3 OrbitCamera(vec2 angles)\n{ // angles is yaw, pitch in radians\n    angles.x *= 2.; // kludge because Shadertoys clip mouse to window\n    angles.y = clamp(angles.y, -.4, .3);\n    return sph2cart(vec3(angles * pi, 1.));\n} // returns forward vector camera aims along\n\n// https://stackoverflow.com/questions/12964279/whats-the-origin-of-this-glsl-rand-one-liner\nfloat hash(float x)\n{\n    return fract(sin(x*7.) * 43708.8672);\n}\n\nfloat hash(vec2 x) \n{ \n    return hash(dot(x, vec2(11.07,10.71)));\n}\n\nstruct Particle \n{\n    vec3 pnew, pold;\n};\n\nParticle particle(sampler2D bufA, ivec2 i)\n{\n    i.x += i.x;\n    vec4 d0 = texelFetch(bufA, i, 0)\n    , d1 = texelFetch(bufA, i + ivec2(1, 0), 0);\n    return Particle(d0.xyz, d1.xyz);\n}\n\nvec3 velocity(Particle p, float dt)\n{\n    return (p.pnew - p.pold) / dt;\n}\n\nvoid setVelocity(inout Particle p, vec3 v, float dt)\n{\n    p.pold = p.pnew - v * dt;\n}\n\n\n// verlet particle cloth\n\n// arrange links in 2d same as buffer \n// nlinkx * nlinky\n\n// verlet integration uses new & old particle positions \n// instead of position & velocity.\n// it's much simpler to work with \n// (except that one must compute velocity)\n\n// FIXME breaks at low framerates despite the implicit integration\n\n// FIXME changing nlinks makes flag go past top of pole etc.\n\n// for stiffer links, must\n// copy entire buffer code to more buffers\n// to pipeline multiple passes of the constraints\n// to increase wavefront propagation speed\n// (speed of sound) in the cloth.\n// Otherwise it is limited to being fairly stretchy\n// or must animate slower than seems natural.\n// using all 4 now!\n\n// convert relative signed to zero-based for 3x3 array of neighbors\nint lidx(int i, int j)\n{\n    return 1 + 3 + i + j * 3;\n}\n\nvoid CheckLink(inout vec3 p, inout vec3 po, int i, int j, float dt, vec3 wind, sampler2D ch)\n{\n    float squish = exp2(-linksag*dt)\n        , squish2 = exp2(-ropesag*dt); // how squishy are constraints?\n    #define CHECK(q, i_, j_, f_) { \\\n\t\tfloat d = distance(p, q) \\\n    \t, l = llen * length(vec2(i_,j_)); \\\n        p += (q - p) * (d - l) * (f_); \\\n    }\n    #define SPRING(q, i_, j_, f_) { \\\n\t\tfloat d = distance(p, q) \\\n    \t, l = llen * length(vec2(i_,j_)); \\\n        po -= (q - p) * (d - l) * (f_) * dt; \\\n    }\n    // only really need to check the immediate neighbors\n\tParticle[9] ps;\n    for (int j0 = 1; j0 >= -1; --j0)\n    for (int i0 = 1; i0 >= -1; --i0)\n        ps[lidx(i0,j0)] = particle(ch, ivec2(i+i0, j+j0));\n    // compute local normal here, since we have the neighbors loaded and need it for wind application\n    vec3 n = normalize(cross(ps[lidx(i == nlinkx-1 ? 0 : 1,0)].pnew - ps[lidx(i == 0 ? 0 : -1,0)].pnew\n                           , ps[lidx(0,j == nlinky-1 ? 0 : 1)].pnew - ps[lidx(0,j == 0 ? 0 : -1)].pnew));\n    // do wind forces\n\t//wind -= velocity(ps[lidx(0,0)], dt); // now relative to vertex motion - breaks things, mostly\n    po -= n * dot(n, wind) * dt * dt * flutter;\n    #if 1\n    // some weak self-unfolding \n    // spring forces to neighbors of neighbors\n    // to make up for lack of self-collision\n    // cannot use ps until I have the lidx and lut extended to support 5x5 samples or something\n    if (i > 1)\n    \tSPRING(particle(ch, ivec2(i-2, j+0)).pnew,-2, 0, unfold * squish)    \n    if (j > 1)\n    \tSPRING(particle(ch, ivec2(i+0, j-2)).pnew, 0,-2, unfold * squish)\n    if (i < nlinkx-2)\n    \tSPRING(particle(ch, ivec2(i+2, j+0)).pnew, 2, 0, unfold * squish)    \n\tif (j < nlinky-2)\n    \tSPRING(particle(ch, ivec2(i+0, j+2)).pnew, 0, 2, unfold * squish)\n    #endif\n    #if 1\n    // soft diagonal links\n    if (i > 0 && j > 0)\n    \tSPRING(ps[lidx(-1,-1)].pnew,-1,-1, diagmul*squish)\t\n    if (i < nlinkx-1 && j < nlinky-1)\n    \tSPRING(ps[lidx( 1, 1)].pnew, 1, 1, diagmul*squish)\t\n    #endif\n    #if 1\n\tif (i > 0)\n    \tCHECK(ps[lidx(-1, 0)].pnew,-1, 0, 1.*squish)    \n    if (j > 0)\n    \tCHECK(ps[lidx( 0,-1)].pnew, 0,-1, 1.*squish)\n    if (i < nlinkx-1)\n    \tCHECK(ps[lidx( 1, 0)].pnew, 1, 0, 1.*squish)    \n\tif (j < nlinky-1)\n    \tCHECK(ps[lidx( 0, 1)].pnew, 0, 1, 1.*squish)\t\n\t#endif\n    #if 0\n    // FIXME not even doing diagonal links rn, was preventing cloth from bending\n    if (i > 0 && j > 0)\n    \tCHECK(ps[lidx(-1,-1)].pnew,-1,-1, diagmul*squish)\t\n    if (i < nlinkx-1 && j < nlinky-1)\n    \tCHECK(ps[lidx( 1, 1)].pnew, 1, 1, diagmul*squish)\n    #endif\n    if (i == 0 && (j == 0 || j == nlinky-1)) // attach to pole\n    \tCHECK(vec3(llen*.25, llen * float(j) + poleheight * hoist,0), 0, 0, 1.*squish2)\n    #undef CHECK\n}\n\nvoid DoPhysics(inout Particle part, ivec2 i, float dt, vec3 wind, sampler2D ch)\n{    \n        vec3 pn = part.pnew, po = pn; // original new pos -> new old pos\n    \tvec3 v = velocity(part, dt);\n\t\tv *= exp2(-drag * dt); // drag forces\n        //v.y -= gravity * .5 * dt; // 'gravity'\n    \tpo.y += gravity * dt * dt;\n\t\tpn += v * dt;\n        for (int j = 3; j-- > 0; ) // multiple iterations helps a bit probably? idk anymore w 4 buffers\n\t\t\tCheckLink(pn, po, i.x, i.y, dt, wind, ch); // constraint links\n        part.pnew = pn;\n        part.pold = po;\n}\n\nvoid DoPhysicsInit(inout Particle part, ivec2 i, float dt, float time, int frame, sampler2D ch)\n{\n    if (frame == 0) {\n        // by setting old and new to same position,\n        // velocity is initialized to zero.\n\t\tpart.pold = part.pnew =\n            vec3(vec2(i)*llen + vec2(llen*1.2, poleheight * hoist), 0);\n    } else {\n\t    vec3 wind = globalwind;\n\t \twind += windvar * vec3(1,.01,.02) * sin(vec3(3,5,2)/6.*time);\n\t\twind *= mix(1., sin(time*.4), windgust); // overall strength waxes and wanes with time, in gusts\n\t\t// wind is a velocity\n    \tDoPhysics(part, i, dt, wind, ch);\n    }\n}\n\n// per-particle data does not fit in one vec4 pixel\nvec4 Store(Particle p, int pixelsection)\n{\n    vec4 o;\n    switch (pixelsection) {\n      case 0:\n\t\to = vec4(p.pnew, 0);\n        break;\n      case 1:\n\t\to = vec4(p.pold, 0);\n        break;\n      default:\n        o = vec4(0);\n        break;\n    }\n    return o;\n}\n\nvoid computeBuffer(out vec4 o, vec2 p, float timeDelta, float time, int frame, sampler2D ch)\n{\n    ivec2 i = ivec2(p);\n    int psection = i.x & 1;\n    i.x >>= 1;\n    if (i.x >= nlinkx || i.y >= nlinky) discard;\n    float dt = clamp(timeDelta, 1./480., 1./240.);\n    Particle part = particle(ch, i);\n    DoPhysicsInit(part, i, dt, time, frame, ch);\n    o = Store(part, psection);\n}\n\n// macro shim for verlet physics buffers\n#define mainBuffer(nbuf) \\\nvoid mainImage(out vec4 o, vec2 p) { \\\n    computeBuffer(o, p, iTimeDelta/float(nbuf), iTime, iFrame, iChannel0); \\\n}\n\n","name":"Common","description":"","type":"common"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"XdfGR8","filepath":"/media/previz/buffer03.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// see Common tab\nmainBuffer(4)\n\n","name":"Buffer A","description":"","type":"buffer"},{"outputs":[{"channel":0,"id":"XsXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// see Common tab\nmainBuffer(4)\n\n","name":"Buffer B","description":"","type":"buffer"},{"outputs":[{"channel":0,"id":"4sXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// see Common tab\nmainBuffer(4)\n\n","name":"Buffer C","description":"","type":"buffer"},{"outputs":[{"channel":0,"id":"XdfGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4sXGR8","filepath":"/media/previz/buffer02.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// see Common tab\nmainBuffer(4)\n\n","name":"Buffer D","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"ttXyD2","date":"1593879651","viewed":169,"name":"Old Glory 2020","username":"spalmer","description":"A nickname for US flag, simple verlet particle cloth physics demo of flag flapping in the wind, recreating a demo I made a long long time ago, celebrating my country's Independence Day holiday.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["flag","stars","stripes","lights","physics","verlet","cloth"],"hasliked":0,"parentid":"","parentname":""}}