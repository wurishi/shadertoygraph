{"ver":"0.1","info":{"id":"4XfyDl","date":"1726939845","viewed":29,"name":"Saturns","username":"Neyrad","description":"homework 1","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["planet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3  eye      = vec3(0, 2, 10);\nconst vec3  light    = vec3(0, 6, 5);\nconst int   maxSteps = 70;\nconst float eps      = 0.01;\nconst float maxDist = 300.0;\nconst float fov = 0.5;\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nfloat sdThickDisk( in vec3 p, in vec3 n, in float r, in float thick, in vec3 pos )  \n{\n    vec3 d = dot(p - pos, n) * n;\n    vec3 o = (p - pos) - d;\n    o -= normalize( o ) * min( length( o ), r );\n    return length( d + o ) - thick;\n}\n\nfloat dSphere(vec3 p, float r, vec3 pos) {\n    return length(p - pos) - r;\n}\n\nfloat opSubtraction( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat dRing(in vec3 q, float inR, float outR, in vec3 pos)\n{\n    float disk = sdThickDisk(q, vec3(0.0, 1.0, 0.0), outR, 0.01, pos);\n    float ring = opSubtraction(dSphere(q - vec3(0.0, 0.0, 0.0), inR, pos), disk);\n    return ring;\n}\n\nconst float INF = 1e9;\nvec3 dRings(in vec3 q, int n, float dist, float shift, in vec3 pos, float id)\n{\n    float step = dist * (1.0 / float(n));\n    float ret = INF;\n    float curRing = 0.0;\n    for (int i = 0; i < n; ++i)\n    {\n        float inR  = shift + step * float(i);\n        float outR = shift + step * (float(i) + 0.5);\n        float ring = dRing(q, inR, outR, pos);\n        if (ring < ret)\n        {\n            ret = ring;\n            curRing = float(i);\n        }\n        \n    }\n    return vec3(ret, curRing, id);\n}\n\nfloat noisySphere(in vec3 p, vec2 uv, float r, vec3 pos)\n{\n    vec3 pn = normalize(vec3(p.x, p.y, abs(p.z)));\n    float u = pn.x / (1. + pn.z);\n    float v = pn.y / (1. + pn.z);\n    vec4 color = texture(iChannel0, vec2(u, v));\n    return length(p - pos) - r + color.r * 0.02;\n}\n\nvec3 saturnSdf(in vec3 p, in vec2 uv, in mat3 m, in vec4 pos, float id)\n{\n    vec3 q = m * p;\n\n    // Ring\n    vec3 pos3 = vec3(pos.x, pos.y, pos.z);\n    int nRings = int(pos.w);\n    vec3 ringsSdf = dRings(q, nRings, 2.0, 1.5, pos3, id);\n    \n    // Sphere\n    //float sphereSdf = dSphere(q, 1.1, pos.xyz);\n    float sphereSdf = noisySphere(q, uv, 1.1, pos.xyz);\n    \n    if (ringsSdf.x < sphereSdf)\n    {\n        return ringsSdf;\n    }\n    else return vec3(sphereSdf, 0, id);\n}\n\n\nvec3 sdf(in vec3 p, in vec2 uv, in mat3 m)\n{\n    vec4 planet[6];\n    int nPlanets = 5;\n    \n    float orbitRadius = 9.0;\n    float orbitSpeed = iTime * (1. / 5.);\n    float coss = orbitRadius * cos(orbitSpeed);\n    float sinn = orbitRadius * sin(orbitSpeed);\n    float mcoss = coss * (1. / 5.);\n    float msinn = sinn * (1. / 5.);\n    planet[0] = vec4(2.*coss, 5. + mcoss, sinn, 3.);\n    planet[1] = vec4(-coss, -3. + mcoss, -sinn, 1.);\n    planet[2] = vec4(3.*sinn, msinn, coss, 2.);\n    planet[3] = vec4(1. + coss, -5. + msinn, 2.*sinn, 2.);\n    planet[4] = vec4(-2. - mcoss, -3. + mcoss, -1.5*coss, 0.);\n\n    vec3 ret = vec3(INF, 0, 0);\n    int id = 0;\n    for (int i = 0; i < nPlanets; ++i)\n    {\n        vec3 saturn = saturnSdf(p, uv, m, planet[i], float(id));\n        if (saturn.x < ret.x) ret = saturn;    \n        ++id;\n    }\n    return ret;\n}\n\nvec3 trace(in vec2 uv, in vec3 from, in vec3 dir, out bool hit, out float id, in mat3 m) {\n    vec3 p = from;\n    float totalDist = 0.0;\n    id = -1.0;\n    hit = false;\n\n    for (int steps = 0; steps < maxSteps; steps++) {\n        vec3 distAndID = sdf(p, uv, m);\n        float dist = abs(distAndID.x);\n        \n        if (dist < eps) {\n            hit = true;\n            id = distAndID.z; \n            break;\n        }\n        \n        totalDist += dist;\n        if (totalDist > maxDist) {\n            break;\n        }\n        p += dist * dir;\n    }\n    return p;\n}\n\nvec3 generateNormal(in vec2 uv, vec3 z, float d, in mat3 m) {\n    float e = max(d * 0.5, eps);\n    float dx1 = sdf(z + vec3(e, 0, 0), uv, m).x;\n    float dx2 = sdf(z - vec3(e, 0, 0), uv, m).x;\n    float dy1 = sdf(z + vec3(0, e, 0), uv, m).x;\n    float dy2 = sdf(z - vec3(0, e, 0), uv, m).x;\n    float dz1 = sdf(z + vec3(0, 0, e), uv, m).x;\n    float dz2 = sdf(z - vec3(0, 0, e), uv, m).x;\n\n    return normalize(vec3(dx1 - dx2, dy1 - dy2, dz1 - dz2));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    bool hit;\n    float id;\n    \n    vec3 mouse = vec3(iMouse.xy / iResolution.xy - 0.5, iMouse.z - 0.5);\n    mat3 m = rotateX(6.0 * mouse.y) * rotateY(6.0 * mouse.x);\n    \n    vec2 scale = 9.0 * iResolution.xy / max(iResolution.x, iResolution.y);\n    vec2 uv = scale * (fragCoord / iResolution.xy - vec2(0.5));\n    \n    //vec3 dir = normalize(vec3(uv, 0) - eye);\n    vec3 dir = normalize(vec3(uv * fov, -1.0));\n   \n    vec3 p = trace(uv, eye, dir, hit, id, m);\n\n    vec3 backgroundTexture = texture(iChannel1, fragCoord / iResolution.xy).rgb;\n    \n    vec3 color = backgroundTexture;//vec3(0.1, 0.1, 0.1);\n    \n    vec3 l = normalize(light - p);\n    vec3 v = normalize(eye - p);\n    vec3 n = generateNormal(uv, p, 0.001, m);\n    vec3 h = normalize(l + v);\n    \n    float nl = max(0.0, dot(n, l));\n    float sp = pow(max(0.0, dot(h, n)), 150.0);\n\n    if (hit) {\n\n        vec3 objColor;\n        switch (int(id) % 4)\n        {\n            case 0:\n                objColor = vec3(0.851, 0.839, 0.255);\n                //objColor = vec3(1., 0., 0.);\n                break;\n            case 1:\n                objColor = vec3(0.788, 0.631, 0.263);\n                //objColor = vec3(0., 1., 0.);\n                break;\n            case 2:\n                objColor = vec3(0.757, 0.278, 0.831);\n                //objColor = vec3(0., 0., 1.);\n                break;\n            case 3:\n                objColor = vec3(0.255, 0.808, 0.851);\n                //objColor = vec3(0., 0., 1.);\n                break;\n            default:\n                objColor = vec3(0.408, 0.71, 0.416);\n                //objColor = vec3(1., 1., 0.);\n                break;\n        }\n\n        // Lighting model\n        int lightingModel = 1;\n        switch (lightingModel) {\n            case 0: // Lambert\n                color = objColor * nl;\n                break;\n            case 1: // Lambert + Phong\n                color = objColor * nl + 3.5 * sp * vec3(1, 1, 1);\n                break;\n        }\n    }\n\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}