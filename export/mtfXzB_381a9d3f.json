{"ver":"0.1","info":{"id":"mtfXzB","date":"1700607113","viewed":50,"name":"box attack","username":"pb","description":"using techniques from https://www.shadertoy.com/view/4tGGRV zackpudil Library for lighting and shadows","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","volumetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//volumetric lighting/shadows is from: https://www.shadertoy.com/view/4tGGRV zackpudil Library\n\nvec3 ro;\n\nfloat hash(float n) {\n    return fract(sin(n)*43578.5453);\n}\n\nfloat box(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nmat2 rot(float an) {  return mat2(cos(an),sin(an),-sin(an),cos(an)); }\n\nfloat de(vec3 p) {\n    vec4 q = vec4(p, 1);\n    \n    float nn=.8;\n\tq.y = mod(q.y + nn, 2.*nn) - nn;\n    \n    q.xyz -= 1.;\n    \n    float twist =  (.08*sin(p.y*2.));\n    \n    p.xz *= rot(twist*2.);\n    q.xz *= rot(twist*3.);\n    \n    \n    for(int i = 0; i < 3; i++) {\n        q.xyz = abs(q.xyz + 1.0) - .7;\n        \n        float sc = 4. ;\n        q = sc*q/clamp(dot(q.xyz, q.xyz), .8, 1.);\n       \n    }\n    \n    float bx = 2.;\n    float f = box(q.xyz, vec3(1.0))/q.w;\n \n    f = min(f, min(p.x + bx, -p.x + bx));\n    f = min(f, min(p.z + bx, -p.z + bx));\n    \n    \n    return f;\n}\n\n//\nfloat trace(vec3 ro, vec3 rd, float mx) {\n    float t = 0.0;\n    for(int i = 0; i < 100; i++) {\n        float d = de(ro + rd*t);\n        if(d < 0.0002*(1.+t/2.) || t >= mx) break;\n        t += d;\n    }\n    \n    if(t < mx) return t;\n    return -1.0;\n}\n\n\n// from: https://www.shadertoy.com/view/4tGGRV zackpudil Library\n// Improvement thanks to Shane. vstrace= shadow trace in volumentric loop.\n// less detailed, dithering and breaks quicker.\nfloat vstrace(vec3 ro, vec3 rd, float mx) {\n    float t = 0.2*hash(dot(ro, rd));\n    for(int i = 0; i < 30; i++) {\n        float d = de(ro + rd*t);\n        if(d < 0.001 || t >= mx) break;\n        t += d;\n    }\n    \n    if(t < mx) return t;\n    return -1.0;\n}\n\n// from: https://www.shadertoy.com/view/4tGGRV zackpudil Library \nvec3 normal(vec3 p, out float e) {\n    vec2 h = vec2(0.001, 0.0);\n    \n    vec3 n1 = vec3(\n        de(p + h.xyy),\n        de(p + h.yxy),\n        de(p + h.yyx)\n\t);\n    \n    vec3 n2 = vec3(\n        de(p - h.xyy),\n        de(p - h.yxy),\n        de(p - h.yyx)\n\t);\n    \n    // edge detection.\n    float d = de(p);\n    \n    vec3 e3 = abs(d - 0.5*(n1 + n2));\n    e = min(1.0, pow(e3.x + e3.y + e3.z, 0.55)*10.0);\n    return normalize(n1 - n2);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 4.*(-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    \n    ro = vec3(-1., -1.4, 0.);\n    \n    vec3 ww = normalize(vec3(0, .5, 0)-ro);\n    vec3 uu = normalize(cross(vec3(0, 1, 0), ww));\n    vec3 vv = normalize(cross(ww, uu));\n    vec3 rd = normalize(uv.x*uu + uv.y*vv + 4.*ww);\n    \n    ro.y += .5+iTime/3.;\n    ro.x += +.7;\n    ro.z -=.2;\n    \n    vec3 col = vec3(0);\n    \n    vec3 lightPos = vec3(0);\n    \n    lightPos.y += ro.y + 1.9; \n    lightPos.x += + .5 + .5*cos(iTime/2.); \n    lightPos.z += - .2 +  .5*sin(iTime/2.); \n\n    float t = trace(ro, rd, 20.0);\n    if(t > 0.0) {\n        float edg;\n        vec3 pos = ro + rd*t;\n        vec3 nor = normal(pos, edg);  //not using edg but leave it for future reference\n        \n        \n        vec3 lig = normalize(lightPos - pos);\n        float dis = length(pos - lightPos);\n        \n        vec3 rf = reflect(nor, ro);\n        float sh = smoothstep(0., 1., -trace(pos + nor*.01, lig, dis));\n        // direct lighting with hard shadows.\n        col += clamp(dot(lig, nor), 0., 1.) *vec3(0,.2,1.);\n        \n        col *= exp(-t*t/30.);\n            \n        col += pow(max(0.,dot(reflect(rd,nor),lig)),32.)*sh*vec3(1.5,1.,.2);\n        \n        col *= sh ; \n                \n\n    }\n    \n    // from: https://www.shadertoy.com/view/4tGGRV zackpudil Library and modified a great deal\n    \n    // volumetric shadows\n    float s = hash(dot(uv, vec2(12.23, 39.343)))*0.05;\n    float vol = 0.0;\n    // need less light strength the closer you are to the light.\n    \n    float lk = length(lightPos-ro);\n    float e = lk*lk;\n    for(int i = 0; i < 40; i++) {\n    \n        vec3 pos = ro + rd*s;\n        \n        vec3 lig = normalize(lightPos - pos);\n        float dis = length(lightPos - pos);\n        \n        // shadow trace at each position along the march.\n        //float l = step(0.0, -vstrace(pos, lig, dis));\n        float l = -vstrace(pos, lig, dis);\n        // light strength is proportional to distance from light.\n        l *= e/dis/dis;\n        \n        vol += l;\n        s += 0.05;\n    }\n    \n    \n    col += .002*vec3(vol)*(1.+lk*lk/6.);\n    col = sqrt(col);\n    \n\n\tfragColor = vec4(col, 1);\n    \n}","name":"Image","description":"","type":"image"}]}