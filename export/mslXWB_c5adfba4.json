{"ver":"0.1","info":{"id":"mslXWB","date":"1670539810","viewed":245,"name":"Conveyor System pt.3","username":"kastorp","description":"added JFA acceleration and editor  (see image comments )\nmaybe next version in 3d","likes":21,"published":1,"flags":48,"usePreview":0,"tags":["game","simulation","conveyors"],"hasliked":0,"parentid":"mslXR2","parentname":"Conveyor System pt.2"},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Conveyor System pt.3 by Kastorp\n//-----------------------------------------------\n// BLACK circles are target\n// WHITE circles are source  \n// \n// ACTIONS:\n//   space: hold pressed for maximum speed\n//   mouse on target/source gauge:  change its power (red=full, green=stopped)\n//   mouse drag on node to move it\n//   mouse click on conveyor to invert its direction\n//   R: reset \n//   S + mouse click : add/remove conveyor\n//   A + mouse click: add/remove node (only disconected nodes can be removed)\n//\n// NOTE: the editor allow inconsistent topology, which leads to strange behaviour\n//-----------------------------------------------\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    if(iFrame<1) return;    \n    vec2 u =pos(I,R);\n    vec2 M =pos(iMouse.xy,R);    \n    vec4 bgcol=mix(vec4(.55,.4,.4,0),vec4(.5,.4,.6,0),step(0.,sign(sin(u.x*PI)*sin(u.y*PI)))),\n        col=bgcol; \n    uvec4 vf= V(I); //get closest conveyors\n\n#if 0\n    //debug Voronoi   \n    bgcol.xyz+= .1*float(vf.w)*cos(vec3(0,2,4)+float(vf.x)*2.5);\n    if(any(greaterThanEqual(vf.xyz,uvec3(NCO)))) bgcol=vec3(1,0,0);\n    col=bgcol;\n#endif  \n\n    for(int j=0;j<int(vf.w);j++){ //number o\n        int jj=int(vf[j]);       \n        ivec2 cd=C(jj);\n        int cIn=cd.x,cOut=cd.y;\n        uvec4 data = L(jj);\n        vec2 s1=N(cOut),s2=N(cIn);\n\n        if(cIn >=0 && cOut>=0)\n        {           \n            if(E(0).w!=0u) {\n                //node number\n                pInt((u-s1+vec2(.1,.05)) *10., float(cOut));\n                pInt((u-s2+vec2(.1,.05)) *10., float(cIn));\n            }\n            vec3 s =segment(u,s1,s2);\n            if(s.x>.6) continue;\n            if((data.z&1u)>0u) {\n                //red semaphore\n                s1=s2+(s1-s2)*(1.- .06/length(s2-s1));\n                if(col.w<2. &&  abs(s.y-.1)<.03 && abs(s.z-.03)<.03) col=vec4(.4,0,0,2);\n                s =segment(u,s1,s2);\n            }\n            if((data.z&2u)>0u) {\n                //green semaphore\n                s2=s1+(s2-s1)*(1.- .04/length(s2-s1));\n                if(col.w<2.  &&  abs(s.z-.03)<.03 && abs(s.z-s.y+ .8)<.03) col=vec4(0,.4,0,2);\n                s =segment(u,s1,s2);\n            }\n\n            if(s.x<.06){\n                float shh=float(iFrame%FR)/float(FR);\n                //conveyor\n                if(col.w<1.) {\n                    col.xyz=vec3(.25)*(1.-0.*step(.01,s.x))*(.95+.05*sign(sin((s.y*32.+float(iFrame)/float(FR)))));\n                    col.w=1.;\n                }\n                int x=int(s.y*32./SHBITF)*SHBIT;               \n                for(int i=x-SHBIT*2;i<x+SHBIT*2;i+=SHBIT){ //items                   \n                    if(i<0||i>31)continue;\n                    float type= float((data.x &(MINBIT<<i))>>i)/float(MINBIT);\n                    bool a=  ((data.x &(MINBIT<<i))>0u);  //item in current slot?\n                    bool b=  ((data.y &(MINBIT<<i))>0u);  //item is moving\n                    float sh=  !b? shh*SHBITF:SHBITF; //horizontal shift if moving\n                    float bc=float(i)+SHBITF-sh; //item center\n                    float item=max(abs(s.y*32.-bc)-min(.3,.15/length(s1-s2)) *SHBITF,s.z-.03); //item sdf\n                    if(a &&item<0.) {col.xyz= .5+.5*cos(type*6.+vec3(0,2,4));  col.w=3.;}           \n                }\n\n            }\n            if((data.z&12u)>0u)\n            {\n                //target/source\n                float an=float(data.w)*PI/MAXW-PI*.5; \n                vec3 gcol= .6 + .6 * cos( float(data.w)/MAXW*2.  + vec3(4,0,2) ) ;\n                bool isTarget=  (data.z&4u)>0u;\n                vec2 c=N(isTarget?cOut:cIn);\n                if( length(c-u-vec2(cos(an),sin(an))*.16)<.05) col=vec4(gcol,4);\n            }\n        } \n        else {\n            bool isTarget=cOut<0;\n            vec2 c=N(isTarget?cIn:cOut);            \n            uvec4 td = E(cOut<0?-cOut:-cIn);\n            if(col.w<1. && length(c-u)<.15) col=vec4(isTarget?vec3(0):vec3(1),0);               \n            if(iMouse.z>0. &&max(length(c-u),length(c-M))<.2 ) col.xyz+=vec3(0,0,.5);\n\n            //node statistics\n            pInt((u-c+vec2(.25,.35)) *5., float(isTarget?td.x:td.y));        \n        }    \n    }\n    uvec4 td = E(0); \n    //global statistics\n    pInt((u-vec2(-3.5,1.6)) *5., float(td.x)); //not arrived\n    pInt((u-vec2(-3.5,1.4)) *5., float(td.y)); //arrived\n    pInt((u-vec2(-3.5,1.8)) *5., float(td.z)); //created\n    \n    //pInt((u-vec2(-3.5,1.)) *5., float(NVE)); //nodes\n    //pInt((u-vec2(-3.5,.8)) *5., float(NCO)); //connections\n    //pInt((u-vec2(-3.5,.6)) *5., float(LAC)); //last action\n    \n    \n    O = col;\n    \n    if(iMouse.z>0. || E(0).w!=0u\n    ){\n        /*\n        for(int j =1;j<= NCO;j++) {\n             ivec2 nd =C(j).xy;\n            if(any(lessThan(nd,ivec2(0)))) continue;\n            float d = segment(u, N(nd.x).xy, N(nd.y).xy).x;\n            if( d<.01) O=vec4(0,1,0,0);\n        }*/\n       for(int i =1;i<=NVE;i++) {\n            float d = length(u-N(i).xy);\n            if(d<.07) O=vec4(1,0,0,0);\n         } \n    }\n    O += draw_char(iChannel3).xxxx;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// circuit configuration:\n//----------------------------\n// endpoint positions\nconst vec2[] NOD=vec2[](\n    vec2(-3,-1.5),vec2(-2,-2),vec2(-1,-1.5),vec2(-1,-.5),vec2(-1,1), //1-5\n    vec2(-1,2),vec2(0,2),vec2(3.,2),vec2(0,-.5),vec2(2,1),        //6-10\n    vec2(-3,1),vec2(-2,2), vec2(3.,1.),vec2(2.,-1.),vec2(3.,-1.5), //11-15\n    vec2(2.,-2.),vec2(-1,-2),vec2(0,-1.5),vec2(-2,-1.5),vec2(-2,-.5), //16-20\n    vec2(1,-2),vec2(2,2),vec2(0,1),vec2(3,-1),vec2(-2,1),\n    vec2(0,-2),vec2(1,1),vec2(1,-1.5),vec2(1,-.5),vec2(1,2),\n    vec2(-1.5,.5),vec2(-.5,.5),vec2(.5,0),vec2(1.5,0),vec2(3,0)\n    );\n    \n// connections \nconst vec2[] CON=vec2[](\n    vec2(1,2),vec2(2,3),vec2(3,4),vec2(5,6),vec2(6,7),\n    vec2(7,30),vec2(8,-4),vec2(-1,1),vec2(4,5),vec2(25,5),\n    vec2(-2,11),vec2(15,-6),vec2(12,6),vec2(-3,12),vec2(9,18),\n    vec2(29,14),vec2(16,15),vec2(13,-5),vec2(22,10),vec2(23,9),\n    vec2(10,13),vec2(14,16),vec2(16,21),vec2(21,18),vec2(17,19),\n    vec2(19,20),vec2(18,3),vec2(20,4),vec2(22,8),vec2(27,23),\n    vec2(11,25),vec2(26,17),vec2(10,27),vec2(9,29),vec2(34,35),\n    vec2(29,28),vec2(28,26),vec2(7,23),vec2(30,22),vec2(20,31),\n    vec2(31,32),vec2(32,33),vec2(24,14),vec2(33,34),vec2(35,24),\n    vec2(27,34)\n    \n    );\nconst   vec2[] NOD2=vec2[](vec2(-3,-.3),vec2(-3,.3),vec2(3,-.3),vec2(3,.3), vec2(-.3,2),vec2(.3,2),vec2(-.3,-2),vec2(.3,-2));\nconst   vec2[] CON2=vec2[](vec2(1,-1),vec2(-2,2),vec2(-3,3),vec2(4,-4), vec2(5,-5),vec2(-6,6),vec2(-7,7),vec2(8,-8));\n    \nvoid mainImage( out vec4 O, in vec2 I )\n{\n    O=vec4(0);\n    ivec2 c=ivec2(I);\n    if(iFrame==0  ){\n        if(c.y>1 || c.x>max(NOD.length(),CON.length())) {O*=0.;return;};\n        if(c.y==1 && c.x==0) O.xy= vec2(CON.length()+1,0);\n        else if(c.y==0 && c.x==0) O.xy= vec2(NOD.length(),0);\n        else if(c.y==1) O.xy=CON[c.x-1];\n        else if(c.y==0) O.xy=NOD[c.x-1];        \n    }\n    else if(pressed(82) ){\n        if(c.y>1 || c.x>max(NOD2.length(),CON2.length())) {O*=0.;return;};\n        if(c.y==1 && c.x==0) O.xy= vec2(CON2.length()+1,0);\n        else if(c.y==0 && c.x==0) O.xy= vec2(NOD2.length(),0);\n        else if(c.y==1) O.xy=CON2[c.x-1];\n        else if(c.y==0) O.xy=NOD2[c.x-1];       \n    }\n    else {\n        int N = NVE;\n        int M = NCO;\n        int LA = LAC; //last action\n        int LV = LVC; //last selected vertex\n        if(c.y>1 || c.x>max(N,M)+1) discard; \n        if(c.y==1) O.xy=vec2(C(c.x));\n        if(c.y==0) O.xy=N(c.x);\n        if(iMouse.z<=0.) return;\n        vec2 m =vec2(0,1e8);\n        vec2 MO =pos(iMouse.xy,R); \n         \n        //get closest vertex \n        for(int i =1;i<=N;i++) {\n            float d = length(MO-N(i).xy);\n            if(m.y>d) m=vec2(i,d);\n            if( LV==i  && (iFrame - LA)<WAIT) m=vec2(i,0.);\n         } \n         \n        //get closest potential edge\n        vec3 ms =vec3(0,0,1.2);\n        for(int i =1;i<= N;i++) for(int j =i+1;j<= N;j++){\n            float d = segment(MO, N(i).xy, N(j).xy).x,\n                  l = length(N(i).xy -N(j).xy);\n            if(d<.05 && l<ms.z) ms=vec3(i,j,l);\n        }\n        //get closest existing edge\n        int  id=0;\n        for(int j =1;j<= M;j++) {\n            ivec2 nd =C(j).xy;\n            if(any(lessThan(nd,ivec2(0)))) continue;\n            float d = segment(MO, N(nd.x).xy, N(nd.y).xy).x;\n            if( d<.05) id=j;\n        }\n        \n        //drag vertex\n        vec2 d =MO-N(c.x).xy;\n        \n        if( int(m.x)>0 && m.y<.1 && iMouse.z>0. &&!pressed(EDGE_MODE) && !pressed(VERTEX_MODE) ) {\n            if(c.y==0 && c.x==int(m.x) ) O.xy += d;\n            if(c.y==1 && c.x==0) O.xyz=vec3(M,iFrame,m.x);    \n        }\n        else if( !pressed(EDGE_MODE) && !pressed(VERTEX_MODE) && m.y>.1 && iMouse.z>0. && (iFrame - LA)>WAIT ) {           \n            //invert edge\n            ivec2 nd =C(id).xy;\n            uvec4 data = L(id);\n            if(id>0 \n                && (data.z&12u)==0u\n                && (iFrame - LA)>WAIT){                           \n                if(c.y==1  && c.x== id ) O.xy= vec2(nd.yx);\n                if(c.y==1  && c.x==0) O.xy=vec2(M,iFrame); \n            }\n         }\n        //add vertex\n        if( pressed(VERTEX_MODE)  && iMouse.z>0.  && m.y> .2 && (iFrame - LA)>WAIT) { \n                  \n            if(c.y==0 && c.x==N+1)  O.xy =vec2(MO); \n            if(c.y==0 && c.x==0) O.xy=vec2(N+1,iFrame);\n            if(id>0 && c.y==1){\n                if( c.x==id) O.x=float(N+1);\n                if( c.x==M+1) O.xy =vec2(C(id).x, N+1);\n                if( c.x==0) O.xy=vec2(M+1,iFrame);                 \n            }            \n        }\n        //remove unconnected vertex\n         if(  pressed(VERTEX_MODE)  && iMouse.z>0. && m.y< .3  && (iFrame - LA)>WAIT ) { \n           int  id=0;\n            for(int j =1;j<= M;j++) {\n                ivec2 nd =C(j).xy;\n                if(any(lessThan(nd,ivec2(0)))) continue;\n                if(float(nd.x)==m.x || float(nd.y)==m.x ) id=j;\n            }\n            if(id==0){\n                if(c.y==0 && c.x>= int(m.x) ) O.xy= N(c.x+1).xy;\n                if(c.y==0 && c.x==0) O.xy=vec2(N-1,iFrame);\n                if( c.y==1 && c.x>0 && O.x>m.x) O.x-=1.;\n                if( c.y==1 && c.y>0 && O.y>m.x) O.y-=1.;\n            }\n        } \n        if( pressed(EDGE_MODE)  && iMouse.z>0. && (iFrame - LA)>WAIT ) {\n           \n            uvec4 data = L(id);\n            //remove edge\n            if( id>0 // && (data.z&12u)==0u \n                && (iFrame - LA)>WAIT){                           \n                if(c.y==1  && c.x>= id ) O.xy= vec2(C(c.x+1).xy);\n                if(c.y==1  && c.x==0) O.xy=vec2(M-1,iFrame);\n            }\n            //add edge\n            else if(id==0 && ms.x!=0. && (iFrame - LA)>WAIT){\n                if(c.y==1  && c.x==M+1)  O.xy = ms.xy;\n                if(c.y==1  && c.x==0) O.xy=vec2(M+1,iFrame); \n            } \n            else if(m.y> .5 && m.y<1.5 &&N>0){           \n                if(c.y==0 && c.x==N+1)  O.xy =vec2(MO); \n                if(c.y==0 && c.x==0) O.xy=vec2(N+1,iFrame); \n                if(c.y==1  && c.x==M+1) O.xy = vec2(N+1,m.x);\n                if(c.y==1  && c.x==0) O.xy=vec2(M+1,iFrame); \n            }\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//CONFIGURATION SETTINGS:\n#define FR 4 //number of frames between updates (1==max speed)\n#define SHBIT 2  // number of bits per slot (4: 15 item types, 2: 3 item types,1:no types)\n#define VOR_DIST 2.4\n//--------------------------\n//GLOBAL CONSTANTS & MACRO:\nconst float SHBITF=float(SHBIT),\n            MAXW=32.;\nconst uint FULLBIT=0xFFFFFFFFu,\n           MINBIT=(1u<<(SHBIT))-1u,\n           MAXBIT=(MINBIT<<(32-SHBIT)); \n    \n#define PI 6.2830\n#define R iResolution.xy\n#define ZERO min(iFrame,0)\n#define ONE min(iFrame,1)\n#define pressed( k)  (texelFetch(iChannel3, ivec2(k, 0), 0).x > 0.5)\n#define NCO  int(texelFetch(iChannel0,ivec2(0,1),0).x)\n#define NVE  int(texelFetch(iChannel0,ivec2(0,0),0).x)\n#define LAC  int(max(texelFetch(iChannel0,ivec2(0,0),0).y,texelFetch(iChannel0,ivec2(0,1),0).y))\n#define LVC  int(texelFetch(iChannel0,ivec2(0,1),0).z)\n#define L(i) floatBitsToUint(texelFetch(iChannel2,ivec2(0,i),0))\n#define E(i) floatBitsToUint(texelFetch(iChannel2,ivec2(1,i),0))\n#define C(i) ivec2(texelFetch(iChannel0,ivec2(i,1),0).xy)\n#define N(i) texelFetch(iChannel0,ivec2(i,0),0).xy\n#define V(c) floatBitsToUint(texelFetch(iChannel1,ivec2(c),0))\n#define VERTEX_MODE 65\n#define EDGE_MODE 83\n#define RESET 82\n#define WAIT 15\n//------------------------------\n//SHARED FUNCTIONS:\n\nvec2 pos(vec2 I,vec2 r) {return (I/r.y *2.- r/r.y)*2.2 ;}\n\nvec3 segment(vec2 p,vec2 a,vec2 b) {\n    float l= length(b - a);\n    vec2 n=normalize(b - a),\n         cp=mix(a, b, clamp(dot(p - a, n) / l, 0., 1.));\n    float x = dot(p-a,n), y = length(p-a-x*n);\n    return vec3(distance(p, cp),x/l,y);\n}\n//--------------------------------\n\n//FabriceNeyret\nint char_id = -1; vec2 char_pos, dfdx, dfdy; \nvec4 char(vec2 p, int c) {\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\n    if ( p.x>.25&& p.x<.75 && p.y>.1&& p.y<.85 ) \n    char_id = c, char_pos = p, dfdx = dFdx, dfdy = dFdy;\n    return vec4(0);\n}\nvec4 draw_char(sampler2D ch) {\n    int c = char_id; vec2 p = char_pos;\n    return c < 0  ? vec4(0,0,0,1e5) : textureGrad( ch, p/16. + fract( vec2(c, 15-c/16) / 16. ), dfdx, dfdy );\n}\nvec4 pInt(vec2 p, float n) {\n    vec4 v = vec4(0);\n    if (n < 0.)  v += char(p - vec2(-.5,0), 45 ), n = -n;\n    for (float i = 3.; i>=0.; i--)  n /=  9.999999, v += char(p - .5*vec2(i,0), 48+ int(fract(n)*10.) );\n    return v;\n}\n//----------------------\n//Iq https://www.shadertoy.com/view/XlXcW4\nvec3 hash( uvec3 x )\n{\n    const uint k = 1103515245U;  // GLIB C\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Voronoi, get 3 closest segments\n\nconst uint EMPTY=0xFFFFu;\nconst float MAXD=1e10;\n\nfloat getDist(vec2 u, uint id){\n    if(id==EMPTY) return MAXD;\n    ivec2 cd=C(id);\n    \n    vec2 s1=N(cd.y),s2=N(cd.x); \n    if(cd.x<0 ) return length(u-s1);\n    if(cd.y<0 ) return length(u-s2);\n    vec3 s =segment(u,s1,s2);\n    return s.x;\n}\nvec4 getDists(vec2 u, uvec4 d){\n   vec4 ds;\n   for(int i=0;i<3;i++) ds[i]=getDist(u,d[i]);\n   return ds;\n}\nvoid clean(inout uvec4 d,int NC){\n    if(any(greaterThan(d.xyz,uvec3(NC)))) d.xyz=uvec3(EMPTY);\n     if(any(lessThan(d.xyz,uvec3(1u)))) d.xyz=uvec3(EMPTY);\n   \n    if(d.y==d.x) d.y=EMPTY;\n    if(d.z==d.x || d.z==d.y ) d.z=EMPTY;\n}\nvoid insert(inout uvec4 d,inout vec4 df,uint id, float f){\n    if(id==0u || id==d.x ||id==d.y ||id==d.z ) return;\n    if(f<df.x){\n        d=uvec4(id,d.xyz); df=vec4(f,df.xyz);\n    }\n    else if(f<df.y){\n        d=uvec4(d.x,id,d.yz); df=vec4(df.x,f,df.yz);\n    }\n    else if(f<df.z){\n        d=uvec4(d.xy,id,d.z); df=vec4(df.xy,f,df.z);\n    }\n   \n} \n\nivec2 cross_distribution(int i,int lv)\n{\n    return (1<<lv) * ivec2( ((i&2)/2)^1, (i&2)/2 ) * ( 2*(i%2) - 1 );\n}\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n   int fr=iFrame;\n   if(fr==0 ||pressed(82))  {O=uintBitsToFloat(uvec4(EMPTY));return;}\n   if((iFrame-LAC)>WAIT && (iFrame&7)!=0) { O= uintBitsToFloat(V(I)); return;}\n   //fr/=2;\n   ivec2 c=ivec2(I);\n   int NC=NCO;\n   uvec4 d= V(c);\n   clean(d,NC);\n   vec2 u =pos(I,R);\n   vec4 ds = getDists(u,d);\n   //SORT\n   if(ds.z<ds.y){d.w=d.y;d.yz=d.zw;ds.w=ds.y;ds.yz=ds.zw;}\n   if(ds.y<ds.x){d.w=d.x;d.xy=d.yw;ds.w=ds.x;ds.xy=ds.yw;}\n   if(ds.z<ds.y){d.w=d.y;d.yz=d.zw;ds.w=ds.y;ds.yz=ds.zw;}\n   \n   //if((fr&2)==0)\n   for(int i=ZERO;i<4;i++){\n       uint id = 1u+ uint(hash(uvec3(iFrame,c)).x *float(NC));\n       float f = getDist(u,id);\n       insert(d,ds,id,f);\n   }\n   //else\n   for(int i=ZERO;i<4;i++){\n       int l=fr&7;\n       ivec2 nc = clamp(ivec2(0),ivec2(R), c+ cross_distribution(i,l));\n       uvec4 n  = V(nc);\n       vec4  nd =getDists(u,n);\n       for(int j=0;j<3;j++) insert(d,ds,n[j],nd[j]);\n   }\n   d.w=0u;\n    ds = getDists(u,d);\n   for(int j=0;j<3;j++) if(ds[j]<VOR_DIST)d.w++; //number of close point\n\n   O=uintBitsToFloat(d);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//conveyor logic\n\nuint tra(int c,uint pw){\n       //source/target power \n       vec3 rnd=hash(uvec3(iFrame,c,1.));\n       return rnd.x< float(pw)/MAXW ?uint(rnd.y*float(MINBIT)+1.):0u; \n}\n\nuint mask(uint x){\n#if (SHBIT==4)\n    uint t =((x&0x88888888u) >>3)\n           |((x&0x44444444u) >>2)\n           |((x&0x22222222u) >>1)\n           | (x&0x11111111u);\n    return (t<<3)|(t<<2)|(t<<1)|t; \n#else\n#if (SHBIT==2) \n    uint t =((x&0xAAAAAAAAu) >>1)|(x&0x55555555u);\n    return (t<<1)|t; \n#else \n    return x;\n#endif\n#endif\n}\n\nuint count(uint x){\n    uint t=0u;\n    for(int i=ZERO;i<32;i++) t+=((x>>i)&1u);\n    return t;\n}\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n   int NC=NCO;\n   int NV=NVE;\n   \n   int id= int (I.y);\n   uvec4 d;\n   if(iFrame<10 ||pressed(82) ) {\n       d= uvec4(0u,0u,0u,uint(MAXW)/4u);\n       \n   }\n   else if(I.x>3. || id>max(NC,NV)+1) discard;\n   else if( id>0  && I.x<1.){\n       if(I.y>float(NC)+1.) discard;\n       \n       d=L(id);\n       int cIn=C(id).x,cOut=C(id).y;\n       if(cIn<0 || cOut<0) return; //unused yet      \n       vec2 s1=N(cOut),s2=N(cIn);\n\n       uint last= MINBIT,first=0u,secIn=0u,secOut=0u;\n       int ,sec=0,secV=0,type=0;\n       \n       bool rr=true, //todo user defined\n            pr= rr?hash(uvec3(iFrame)).x<.5:false; \n\n       for(int i=ONE;i<=NC+1;i++){\n           if(i==id)continue;\n           int nIn=C(i).x,nOut=C(i).y;\n            \n           if(nOut==cIn) { //entering \n               uint f2=(L(i).x & MINBIT);\n               if(nIn<0) {f2=tra(nIn,d.w); type|=2;}\n               \n               if(first==0u)  first= f2;\n               else if((i<id ^^ pr) && f2!=0u) first= f2;\n           }\n           if(nIn==cOut) { //exiting                           \n               if(nOut<0) {last= (tra(nOut,d.w)!=0u?MINBIT:0u); type|=1;}\n               else if(last!=0u) last =  (L(i).x & MAXBIT)>>(32-SHBIT);\n          }\n           if(nOut==cOut &&(i<id ^^ pr) ){ //junction Out               \n               sec|=1;\n               if(nIn<0) secOut|=(MINBIT-tra(nIn,d.w));\n               else secOut|=(L(i).x & MINBIT );    \n           } \n           if(nIn==cIn &&(i<id ^^ pr)){ //junction in\n               sec|=2;\n               if(nOut<0) secIn|=tra(nOut,d.w);\n               else secIn|= (L(i).x & MAXBIT)>>(32-SHBIT);    \n           }\n           if(rr && nOut==cOut)secV|=1;\n           if(rr && nIn==cIn)secV|=2;\n        }\n        if((sec&2)>0  && (secIn==0u)) first=0u;\n        if(secOut>0u ) last=MINBIT;  \n        sec=sec|secV;\n\n       uint next= ((d.x& (FULLBIT-MAXBIT))<<SHBIT) | (last), \n            prev= ((d.x& (FULLBIT-MINBIT))>>SHBIT) | (first<<(32-SHBIT)),\n            free= FULLBIT-mask(d.x), \n            move=free & prev, //move the item in current pos if previous has item and current is free\n            stay=d.x & mask(next); //don't move if there is item in the current and next pos\n\n       //power gauge\n       vec2 m=pos(iMouse.xy,R);\n       vec2 c = (type&1)>0?s1:s2;\n       float w=(atan(-m.y+c.y,-m.x+c.x)+PI*.5);\n\n\n       //update every FR frames\n       if(iFrame%FR==0|| pressed(32)){\n           d.x=move|stay; //x=update item  in the position\n           d.y=stay;      //y=item is stopped  \n           d.z= uint(sec + type*4);\n       }\n       if(type>0 && abs(length(m-c)-.2)<.1) d.w=uint(w*MAXW/PI); \n       if((d.z&31u)==0u) d.w=uint(MAXW)/4u; //hack for resolution change\n   \n   }else if(id>0){\n       d=E(id);\n       \n       for(int j=ONE;j<=NC+1;j++){\n           int uIn=C(j).x,uOut=C(j).y;\n           if(uOut==-id) { //target \n              \n              for(int i=ONE;i<NC;i++){\n                  int nIn=C(i).x,nOut=C(i).y;\n                  if(uIn==nOut)\n                   if(iFrame%FR==0|| pressed(32)){\n                      uvec4 cd=L(i);\n                      uint first =  (cd.x & MINBIT);\n                      if(tra(-id,cd.w)==0u && first!=0u) d.x++;\n                      // \n                   }\n               }\n          }\n          if(uIn==-id) { //source \n              for(int i=ONE;i<=NC+1;i++){\n                  int nIn=C(i).x,nOut=C(i).y;\n                  if(uOut==nIn)\n                   if(iFrame%FR==0|| pressed(32)){\n                      uvec4 cd=L(i);\n                      uint last =  (cd.x & MAXBIT);\n                      if(tra(-id,cd.w)!=0u && last==0u) d.y++;                      \n                   }\n               }\n          }\n       }\n   }else if(id==0){\n      d=uvec4(0u);\n       for(int i=ONE;i<=NC+1;i++){\n           int nIn=C(i).x,nOut=C(i).y;\n           \n           if(nIn>=0 && nOut>=0) {\n               uint cd = L(i).x;\n               d.x+=count(mask(cd))/uint(SHBIT);\n           }\n           if(nIn<0){\n               d.z+=E(-nIn).y;\n           }\n           else if(nOut<0){\n               d.y+=E(-nOut).x;\n           }\n       }\n       d.w=pressed(VERTEX_MODE)|| pressed(EDGE_MODE)?1u:0u;\n       \n       \n   }\n    O=uintBitsToFloat(d);\n}\n\n","name":"Buffer C","description":"","type":"buffer"}]}