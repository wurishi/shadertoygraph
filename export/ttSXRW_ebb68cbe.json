{"ver":"0.1","info":{"id":"ttSXRW","date":"1565182910","viewed":658,"name":"Enchanted forest","username":"peet","description":"Tried writing an IFS from the ground up, works super nice with SDF primitives.\nI'm blown away that this actually works!","likes":32,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","reflection","ifs","tree","forest","softshadow","selfillumination"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"///////////////////////////////////////////////////////////////////////////////////\n// Raymarching an IFS forest ////////////////////////////////////////////// peet //\n///////////////////////////////////////////////////////////////////////////////////\n\n#define MARCH_ITERATIONS 60\t\t\n\n#define REFLECT_ITERATIONS 2\t\t// Drop me to 2 for more speed!\t\n#define MSAA_X 1.0\n#define MSAA_Y 1.0\n\n///////////////////////////////////////////////////////////////////////////////////\n// optionals\n\n#define LIGHTBULB\n#define SOFTSHADOWS\t\n//#define DITHER\n\n///////////////////////////////////////////////////////////////////////////////////\n\n#define BASIC 0\n#define GRASS 1\n#define TREES 2\n#define MAGEN 3\n\nconst Material g_basic = Material(vec3(0.0, 1.5, 0.0), 0.0, 0.0, 1.0);\nconst Material g_grass = Material(vec3(0.0, 0.0, 0.0), 0.0, 0.25, 0.0);\nconst Material g_trees = Material(vec3(0.7, 0.3, 0.1), 0.2, 0.1, 0.0);\nconst Material g_magen = Material(vec3(1.5, 0.0, 1.5), 1.0, 0.1, 0.0);\n\nMaterial g_mats[10];\n\n///////////////////////////////////////////////////////////////////////////////////\n\n#ifdef LIGHTBULB\nconst vec3 g_lightpivot = vec3(1.0, 3.75, 0.0);\nconst vec3 g_lightpos = vec3(1.0, 0.75, 0.0);\n\nLight g_light = Light(vec3(1.3, 1.0, -0.5), vec3(100.0, 80.0, 60.0)*1.5);\n#else\nLight g_light = Light(normalize(vec3(1.0, -1.0, 1.0)), vec3(100.0, 100.0, 100.0));\n#endif\n\n///////////////////////////////////////////////////////////////////////////////////\n    \nfloat blerp(float x, float y0, float y1, float y2, float y3) {\n\tfloat a = y3 - y2 - y0 + y1;\n\tfloat b = y0 - y1 - a;\n\tfloat c = y2 - y0;\n\tfloat d = y1;\n\treturn a * x * x * x + b * x * x + c * x + d;\n}\n\nfloat rand(vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat perlin(float x, float h) {\n\tfloat a = floor(x);\n\treturn blerp(mod(x, 1.0),\n\t\trand(vec2(a-1.0, h)), rand(vec2(a-0.0, h)),\n\t\trand(vec2(a+1.0, h)), rand(vec2(a+2.0, h)));\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// IQ's texture based noise function (37,17) FTW!\n\nfloat noise( in vec3 x )\n{\n    x *= 5.0;\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0. ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// composite SDF's\n\nSDFResult backgroundSDF( vec3 p )\n{\n    // floor at y=-1.0\n    SDFResult res = planeSDF(Plane(vec3(0.0, -0.1, 0.0), vec3(0.0, 1.0, 0.0), TREES), p);\n    // back wall at z=4.0\n    //res = opAdd(res, boxSDF2(RoundBox(vec3(0.0, 0.0, 4.1), vec3(20.0, 20.0, 0.1), 0.0, BASIC), p));\n    return res;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// IFS test\n\nSDFResult testSDF(vec3 p)\n{\n    const vec3 basepos = vec3(0.0, 0.0, 0.0);\n    vec3 porig = p;\n    const float space = 2.2;\n    p.xz = mod(p.xz + vec3(space*0.5).xz, space) - vec3(space*0.5).xz;\n    vec3 delta = p - basepos;\n    \n    float thingy = sin(iTime+porig.x+porig.z*1.41);\n    \n    mat3 mat = rotaxis(vec3(-1.0, 0.0, 1.0)*0.85, 0.4+thingy*0.1);\n    mat3 matt = rotaxis(vec3(0.0, 1.0, 0.0), sin(iTime*0.6)*0.5);\n    mat = mat*matt;\n    \n    float baselen = 0.5;\n    float baseradius = 0.1;\n    SDFResult res = vertcapSDF( VertCap(basepos, baselen, baseradius, TREES), delta );\n    \n    for (int i=0; i<6; i++)\n    {\n        baselen *= 0.9;\n        baseradius *= 0.8;\n        delta.x = abs(delta.x);\n        delta.z = abs(delta.z);     \n        delta.y -= baselen;\n        delta = delta*mat;    \n        res = opSmoothAdd(res, vertcapSDF( VertCap(basepos, baselen, baseradius, TREES), delta ), baseradius);                \n    }\n\n    if (porig.z<5.0)\n    \tres = opAdd(sphereSDF( Sphere(basepos + vec3(0.0, baselen*1.1, 0.0), baseradius*1.5, BASIC), delta ), res);                \n       \n\treturn res;    \n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// SDF scene\n\nSDFResult sceneSDF(vec3 p )\n{\n    SDFResult res = backgroundSDF(p);   \n    res = opSmoothAdd( res, testSDF(p), 0.5 );\n\treturn res;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// SDF system\n\nResult resultSDF(vec3 p)\n{\n    Result result = Result(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), TOO_FAR, TOO_FAR, 0.0, g_magen);\n    SDFResult res2 = SDFResult(TOO_FAR, MAGEN);\n    res2 = sceneSDF(p);\n\n    // normal calculation\n    result.normal = vec3(0.0);\n    for( int i=min(iFrame,0); i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1), ((i>>1)&1), (i&1))-1.0);\n        result.normal += e*sceneSDF(p+EPSILON*e).dist;\n    }\n    result.normal = normalize(result.normal);        \n    \n    SDFResult res = SDFResult(TOO_FAR, MAGEN);    \n    res = sceneSDF(p);\n                \n    result.mat=g_mats[res.matindex];\n        \n    result.pos = p;\n    result.t = res2.dist;\n    return result;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// quick light visualisation\n\nvec3 drawlights( Ray ray )\n{   \n    vec3 delta = g_light.pos - ray.pos;\n    vec3 closest = ray.pos + ray.dir*dot(delta, ray.dir);\n    float len = length(g_light.pos-closest);\n\n    vec3 colour = 0.5*g_light.colour/(len*300.0);\n    return colour;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// raymarch world query\n\nResult raymarch_query(Ray ray, float maxdist)\n{\n    float mint=TOO_FAR;\n    float maxt=0.0;\n\tfloat travelled=0.0;\n    for (int i=0; i<MARCH_ITERATIONS; i++)\n    {\n    \tSDFResult res = sceneSDF(ray.pos);\n        \n      \tmaxt = max(maxt, res.dist);    \n       \tif (res.dist<maxt)    \n        {\n\t        mint = min(mint, res.dist);            \n        }\n                \n        ray.pos += res.dist*ray.dir; \n        travelled += res.dist;\n        \n        if (travelled>maxdist)\n            break;\n    }     \n    \n    Result result = resultSDF(ray.pos);\n    result.mint = mint;\n    result.travelled=travelled;\n    return result;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// environment colour\n\nvec3 environment(vec3 d)\n{\n\treturn mix(vec3(1.0, 1.0, 1.0), vec3(0.2, 0.2, 0.5), pow(abs(d.y), 0.5))*100.0;    \n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// raymarch light integrator\n\nvec3 raymarch(Ray inputray)\n{\n    const float exposure = 1e-2;\n    const float gamma = 2.2;\n    const float intensity = 100.0;\n    vec3 ambient = vec3(0.2, 0.3, 0.6) *6.0* intensity / gamma;\n\n    vec3 prevcolour = vec3(0.0, 0.0, 0.0);\n    vec3 colour = vec3(0.0, 0.0, 0.0);\n    vec3 mask = vec3(1.0, 1.0, 1.0);\n    vec3 fresnel = vec3(1.0, 1.0, 1.0);\n    \n    Ray ray=inputray;\n        \n    vec3 lightpos = g_light.pos;\n    \n    for (int i=0; i<REFLECT_ITERATIONS; i++)\n    {\n        Result result = raymarch_query(ray, 10.0);\n\n        vec3 tolight = lightpos - result.pos;\n        tolight = normalize(tolight);\n                \n        if (result.t > NOT_CLOSE)\n        {\n            vec3 spotlight = drawlights(ray)*3000.0;\n            \n//          ambient = texture(iChannel1, ray.dir).xyz*100.0;\n            ambient = vec3(0.0);\n//            ambient = environment(ray.dir);\n                       \n            colour += mask * (ambient + spotlight);                             \n            break;\n        }\n        else\n        {   \n\t\t\tprevcolour = result.mat.colour.rgb;\n            \n            vec3 r0 = result.mat.colour.rgb * result.mat.specular;\n            float hv = clamp(dot(result.normal, -ray.dir), 0.0, 1.0);\n            fresnel = r0 + (1.0 - r0) * pow(1.0 - hv, 5.0);\n            mask *= fresnel;            \n            \n            vec3 possiblelighting = clamp(dot(result.normal, tolight), 0.0, 1.0) * g_light.colour\n                    * result.mat.colour.rgb * result.mat.diffuse\n                    * (1.0 - fresnel) * mask / fresnel;\n            \n            possiblelighting += environment(reflect(ray.dir, result.normal)) * dot(result.normal, -ray.dir)*0.35;\n            \n            float falloff = 1.0 - clamp(length(ray.pos)*0.1, 0.0, 1.0);\n            possiblelighting *= falloff;\n            \n            if (length(possiblelighting) > 0.01f)\n            {\n                Ray shadowray = Ray(result.pos+result.normal*0.01, tolight);\n                Result shadowresult = raymarch_query(shadowray, length(lightpos - result.pos)*0.9);\n#ifdef SOFTSHADOWS                \n                colour += possiblelighting*clamp(shadowresult.mint*4.0, 0.0, 1.0);\n#else\n                if (shadowresult.travelled >= length(lightpos - result.pos)*0.9)\n                \tcolour += possiblelighting;\n#endif\n            }\n            \n            float falloff2 = 1.0 - clamp(length(ray.pos)*0.3, 0.0, 1.0);\n            vec3 selfillum = result.mat.selfillum*result.mat.colour.rgb*40.0*clamp(dot(result.normal, -ray.dir), 0.0, 1.0);            \n            colour += selfillum*falloff2;\n            \n            Ray reflectray;\n            reflectray.pos = result.pos + result.normal*0.02f;\n            reflectray.dir = reflect(ray.dir, result.normal);\n            ray = reflectray;\n        }\n    }\n        \n    colour.xyz = vec3(pow(colour * exposure, vec3(1.0 / gamma)));    \n    return colour;    \n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// main loop, iterate over the pixels, doing MSAA\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{               \n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    float factor = 1.0/(MSAA_X*MSAA_Y);\n        \n    // light\n    vec3 pivot = g_lightpivot;\n    vec3 pos = g_lightpos;\n    pos.x += sin(iTime*2.0*1.5)*0.5;\n    pos.z += cos(iTime*1.5)*0.5;\n    pos = normalize(pos-pivot)*3.0 + pivot;\n    g_light.pos=pos;\n    \n    // materials\n    g_mats[BASIC]=g_basic;\n    g_mats[GRASS]=g_grass;\n    g_mats[TREES]=g_trees;\n    g_mats[MAGEN]=g_magen;\n    \n    for (float x=0.0; x<MSAA_X; x++)\n    {\n        for (float y=0.0; y<MSAA_Y; y++)\n        {\n            vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n            uv.y *= iResolution.y / iResolution.x;\n\n            uv.x += (1.0/(iResolution.x*MSAA_X))*x;\n            uv.y += (1.0/(iResolution.y*MSAA_Y))*y;\n            \n            \n            vec3 p0 = vec3(0.5, 0.25, -2.0);\n            vec3 p1 = vec3(0.0+sin(iTime*0.5), 1.0+cos(iTime*0.75)*0.1, 0.0);\n            vec3 dir = (p1-p0);\n            dir = normalize(dir);\n            vec3 up = vec3(0.0, 1.0, 0.0);\n            up = normalize(up);\n            vec3 right = -cross(dir, up);\n            right = normalize(right);\n            up = -cross(right, dir);\n            up = normalize(up);  \n            \n            Ray ray;\n            ray.pos = p0;\n            ray.dir = dir*0.9 + up*(uv.y + (1.0/(iResolution.y*MSAA_Y))*y) + right*(uv.x + (1.0/(iResolution.x*MSAA_X))*x);\n    \t\tray.dir = normalize(ray.dir);                       \n                        \n#ifdef DITHER            \n            float dither = hashfloat(uint(fragCoord.x+iResolution.x*fragCoord.y)+uint(iResolution.x*iResolution.y)*uint(iFrame));//Updated with iFrame dimension    \n            ray.pos += ray.dir*dither*0.01;\n#endif //DITHER            \n            \n            fragColor.xyz += raymarch(ray)*factor;            \n\t\t\t//fragColor.xyz += drawlights(ray)*factor;\n    \t}        \n    }    \n}\n\n///////////////////////////////////////////////////////////////////////////////////\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"///////////////////////////////////////////////////////////////////////////////////\n\n#define TOO_FAR 100000000.0\n#define NOT_CLOSE 1.0\n#define EPSILON 0.001\n#define PI 3.14159\n\n///////////////////////////////////////////////////////////////////////////////////\n\nstruct AnimObj\n{\n\tvec3 pos;\n    vec3 scale;\n    vec3 rot;\n    vec3 centre;\n    float radius;\n};\n\nstruct Material {\n    vec3 colour;\n    float diffuse;\n    float specular;\n    float selfillum;\n};\n    \nstruct Ray {\n    vec3 pos;\n    vec3 dir;\n};\n\nstruct Sphere {\n    vec3 pos;\n    float radius;\n    int matindex;\n};\n\nstruct Torus {\n    vec3 pos;\n    float ring;\n    float radius;\n    int matindex;\n};\n        \nstruct Light {\n    vec3 pos;\n    vec3 colour;\n};\n\nstruct Plane {\n    vec3 pos;\n    vec3 norm;\n    int matindex;\n};\n\nstruct RoundBox {\n    vec3 pos;\n    vec3 dimensions;\n    float radius;\n    int matindex;\n};\n\nstruct VertCap {\n    vec3 pos;\n    float height;\n    float radius;\n    int matindex;\n};\n        \nstruct Result {\n    vec3 pos;\n    vec3 normal;\n    float t;\n    float mint;\n    float travelled;\n    Material mat;\n};\n    \nstruct SDFResult\n{\n\tfloat dist;\n    int matindex;\n};\n\n///////////////////////////////////////////////////////////////////////////////////\n    \nmat3 rotationmatrix(vec3 a)\n{\n    float cp=cos(a.x);\n    float sp=sin(a.x);\n    float cy=cos(a.y);\n    float sy=sin(a.y);\n    float cr=cos(a.z);\n    float sr=sin(a.z);\n    mat3 pitch = mat3(1, 0, 0, 0, cp, sp, 0, -sp, cp);\n    mat3 yaw = mat3(cy, 0, -sy, 0, 1, 0, sy, 0, cy);\n\tmat3 roll = mat3(cr, sr, 0, -sr, cr, 0, 0, 0, 1);\n    mat3 rotation = pitch*yaw*roll;    \n    return rotation;\n}\n\nmat3 rotaxis(vec3 axis, float a) \n{\n    float s=sin(a);\n    float c=cos(a);\n    float oc=1.0-c;\n    vec3 as=axis*s;\n    mat3 p=mat3(axis.x*axis,axis.y*axis,axis.z*axis);\n    mat3 q=mat3(c,-as.z,as.y,as.z,c,-as.x,-as.y,as.x,c);\n    return p*oc+q;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// SDF's & other spatial query functions\n\nSDFResult opAdd( SDFResult r1, SDFResult r2 ) \n{\n\treturn SDFResult((r1.dist<r2.dist)?r1.dist:r2.dist, (r1.dist<r2.dist)?r1.matindex:r2.matindex);\n}\n\nSDFResult opSmoothAdd( SDFResult r1, SDFResult r2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(r2.dist-r1.dist)/k, 0.0, 1.0 );\n    SDFResult res;\n    res.dist = (mix( r2.dist, r1.dist, h ) - k*h*(1.0-h));\n    res.matindex = ((r2.dist>r1.dist)?r1.matindex:r2.matindex);\n    return res; \n}\n\nSDFResult opSmoothSub( SDFResult r1, SDFResult r2, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(r2.dist+r1.dist)/k, 0.0, 1.0 );\n    SDFResult res;\n    res.dist = (mix( r2.dist, -r1.dist, h ) + k*h*(1.0-h));\n    res.matindex = ((r2.dist>r1.dist)?r1.matindex:r2.matindex);\n    return res; \n}\n\nSDFResult sphereSDF(Sphere sphere, vec3 p) \n{\n    vec3 diff = (sphere.pos - p);\n    diff.y *= 0.65;\n    return SDFResult(length(diff) - sphere.radius, sphere.matindex);\n}\n\nSDFResult sphereSDF2(Sphere sphere, vec3 p) \n{\n    vec3 delta = sphere.pos - p;\n    delta.xz += delta.y*delta.y*delta.y*10.0;\n    return SDFResult(length(delta) - sphere.radius, sphere.matindex);\n}\n\nSDFResult torusSDF( Torus torus, vec3 p )\n{\n    p -= torus.pos;\n    \n\tvec2 q = vec2(length(p.xz)-torus.ring,p.y);\n\treturn SDFResult(length(q)-torus.radius, torus.matindex);\n}\n\nSDFResult torusSDF2( Torus torus, vec3 p )\n{\n    p -= torus.pos;\n    \n    const float scale = 0.05;\n    float topdiff = clamp((0.1 - p.y), 0.0, scale);\n    float botdiff = clamp((p.y - ((p.x*p.x*2.0)-scale)), 0.0, scale);\n    \n    if ( topdiff>0.0 && botdiff>0.0 )\n    {\n        float v = min(topdiff, botdiff)/scale;\n        v = 3.0*v*v - 2.0*v*v*v;\n        p.z-=v*scale*0.5;\n    }\n    \n\tvec2 q = vec2(length(p.xz)-torus.ring,p.y);\n\treturn SDFResult(length(q)-torus.radius, torus.matindex);\n}\n\nSDFResult planeSDF( Plane plane, vec3 p )\n{\n    return SDFResult(dot(plane.norm, p) - dot(plane.pos, plane.norm), plane.matindex);\n}\n\nSDFResult roundboxSDF( RoundBox box, vec3 p )\n{\n    p -= box.pos;\n    vec3 d = abs(p) - box.dimensions;\n    SDFResult res;\n    res.dist = length(max(d,0.0)) - box.radius + min(max(d.x,max(d.y,d.z)),0.0);\n    res.matindex = box.matindex;\n    return res;\n}\n\nSDFResult vertcapSDF( VertCap cap, vec3 p )\n{\n    p -= cap.pos;\n    p.y -= clamp( p.y, 0.0, cap.height );\n    return SDFResult(length( p ) - cap.radius, cap.matindex);\n}\n\nSDFResult vertcapSDF2( VertCap cap, vec3 axis, vec3 p )\n{\n    p -= cap.pos;\n    float y = dot(axis, p);\n    p -= axis*clamp( y, 0.0, cap.height);\n    return SDFResult(length( p ) - cap.radius, cap.matindex);\n}\n\nSDFResult planeSDF2( Plane plane, vec3 p )\n{\n    float ly = dot((p-plane.pos), plane.norm);\n    vec3 local = p - (plane.pos + plane.norm*ly);\n    \n    float ridgex = mod(local.x, 1.0)-0.5;\n    float ridgey = mod(local.y, 1.0)-0.5;\n    float ridgez = mod(local.z, 1.0)-0.5;\n    ridgex = clamp(ridgex*ridgex*10.0, 0.0, 0.005)*0.5;\n    ridgey = clamp(ridgey*ridgey*10.0, 0.0, 0.005)*0.5;\n    ridgez = clamp(ridgez*ridgez*10.0, 0.0, 0.005)*0.5;\n    \n    return SDFResult(ly - ridgex - ridgey - ridgez, plane.matindex);\n}\n\nSDFResult boxSDF2( RoundBox box, vec3 p )\n{    \n    p -= box.pos;\n    vec3 d = abs(p) - box.dimensions;\n    float l = length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n\n    float ridgex = mod(p.x, 1.0)-0.5;\n    float ridgey = mod(p.y, 1.0)-0.5;\n    float ridgez = mod(p.z, 1.0)-0.5;\n    ridgex = clamp(ridgex*ridgex*10.0, 0.0, 0.005)*0.5;\n    ridgey = clamp(ridgey*ridgey*10.0, 0.0, 0.005)*0.5;\n    ridgez = clamp(ridgez*ridgez*10.0, 0.0, 0.005)*0.5;    \n \n    return SDFResult((l - ridgex - ridgey - ridgez), box.matindex);\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n\nfloat hashfloat( uint n ) \n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return float( n & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// IQ's sierpinski\n\nconst vec3 g_va = vec3(  0.0, -0.95,  0.0 );\nconst vec3 g_vb = vec3(  0.0, 0.55,  1.15470 );\nconst vec3 g_vc = vec3(  1.0, 0.55, -0.57735 );\nconst vec3 g_vd = vec3( -1.0, 0.55, -0.57735 );\n\nSDFResult sierSDF( vec3 p, int matindex, float time )\n{\n    mat3 rot = rotationmatrix(vec3(time, time*1.1, time*1.22));\n    vec3 va = rot * g_va * 0.7;\n    vec3 vb = rot * g_vb * 0.7;\n    vec3 vc = rot * g_vc * 0.7;\n    vec3 vd = rot * g_vd * 0.7;\n    \n    p -= vec3(2.0, 1.9, 2.0);\n    \n    if (length(p) > 1.2)\n        return SDFResult(TOO_FAR, matindex);\n    \n\tfloat a = 0.0;\n    float s = 1.0;\n    float r = 1.0;\n    float dm;\n    vec3 v;\n    for( int i=0; i<6; i++ )\n\t{\n\t    float d, t;\n\t\td = dot(p-va,p-va);              v=va; dm=d; t=0.0;\n        d = dot(p-vb,p-vb); if( d<dm ) { v=vb; dm=d; t=1.0; }\n        d = dot(p-vc,p-vc); if( d<dm ) { v=vc; dm=d; t=2.0; }\n        d = dot(p-vd,p-vd); if( d<dm ) { v=vd; dm=d; t=3.0; }\n\t\tp = v + 2.0*(p - v); r*= 2.0;\n\t}\n\t\n\treturn SDFResult(((sqrt(dm)-1.0)/r), matindex);\n}","name":"Common","description":"","type":"common"}]}