{"ver":"0.1","info":{"id":"WtyczG","date":"1611178208","viewed":302,"name":"Testing volumetric marching","username":"darkeclipz","description":"time to melt my brain again\n\nhttps://www.shadertoy.com/view/MdGSzt","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["volumetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.youtube.com/watch?v=8OrvIQUFptA\n// https://shaderbits.com/blog/creating-volumetric-ray-marcher\n\n\n/*\n\n trying to figure out how volumetric rendering works... wish me luck\n \n just some notes:\n     so if i get it right, to create volumetric cloud like thingies, we need:\n\n     1. Perlin-Worley noise to create a cloud like noise \n     2. Adjust the raymarcher to takes fixed steps when inside the volume.\n     3. Take sample points by checking the density?\n     \n     \n     (not used in implementation)\n     4. Calculate light energy at that point?\n          - Beer's Law\n          - Henyey Greenstein\n          - In-scattering probabilities\n          \n          E : energy\n          d : depth in cloud\n          \n          E = 2e^{-d} * (1 - e^{-2d})      \"Beer's-Powder\"\n          \n          - Powder effect?\n*/\n#define MIN_MARCH_DIST 0.001\n#define MAX_MARCH_DIST 20.\n#define MAX_MARCH_STEPS 100.\n#define MAX_VOLUMETRIC_STEPS 64.\n\n// noise function from another shader, https://www.shadertoy.com/view/MdGSzt\n// copy from https://www.shadertoy.com/view/4l2GzW\nfloat random(float n)\n{\n \treturn fract(cos(n*89.42)*343.42);\n}\nvec3 random(vec3 n)\n{\n \treturn vec3(\n        random(n.x*23.62-300.0+n.y*34.35),\n        random(n.x*45.13+256.0+n.y*38.89),\n        random(n.x*76.13+311.0+n.y*42.15)); \n}\nfloat worley(vec3 n,float s)\n{\n    float dis = 2.0;\n    for(int x = -1;x<=1;x++)\n    {\n        for(int y = -1;y<=1;y++)\n        {\n            for(int z = -1; z <= 1; z++) {\n                vec3 p = floor(n/s)+vec3(x,y,z);\n                float d = length(random(p)+vec3(x,y,z)-fract(n/s));\n                if (dis>d)\n                {\n                    dis = d;   \n                }\n            }\n            \n        }\n    }\n    return 1.0 - dis;\n\t\n}\n\n// copy from https://www.shadertoy.com/view/4sc3z2\n#define MOD3 vec3(.1031,.11369,.13787)\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\nfloat perlin_noise(vec3 p)\n{\n    vec3 pi = floor(p);\n    vec3 pf = p - pi;\n    \n    vec3 w = pf * pf * (3.0 - 2.0 * pf);\n    \n    return \tmix(\n        \t\tmix(\n                \tmix(dot(pf - vec3(0, 0, 0), hash33(pi + vec3(0, 0, 0))), \n                        dot(pf - vec3(1, 0, 0), hash33(pi + vec3(1, 0, 0))),\n                       \tw.x),\n                \tmix(dot(pf - vec3(0, 0, 1), hash33(pi + vec3(0, 0, 1))), \n                        dot(pf - vec3(1, 0, 1), hash33(pi + vec3(1, 0, 1))),\n                       \tw.x),\n                \tw.z),\n        \t\tmix(\n                    mix(dot(pf - vec3(0, 1, 0), hash33(pi + vec3(0, 1, 0))), \n                        dot(pf - vec3(1, 1, 0), hash33(pi + vec3(1, 1, 0))),\n                       \tw.x),\n                   \tmix(dot(pf - vec3(0, 1, 1), hash33(pi + vec3(0, 1, 1))), \n                        dot(pf - vec3(1, 1, 1), hash33(pi + vec3(1, 1, 1))),\n                       \tw.x),\n                \tw.z),\n    \t\t\tw.y);\n}\n\n// not so worley anymore\nfloat perlinworley3d(vec3 p) {\n    float noise = perlin_noise(20.*p + iTime) * .8 + .05\n                + perlin_noise(40.*p + iTime) * .5\n                + perlin_noise(70.*p + iTime) * .25\n      //          * worley(12.*p, 1.0);\n      ;\n    //noise += perlin_noise(12.*p) * .5;\n    return noise;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n# define BBOX 1\nfloat sdBoundingBox( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nint id = 0;\n\nfloat map(vec3 p) {\n    id = 0;\n    float volBox = sdBox(p, vec3(0.27));\n    float bBox = sdBoundingBox(p, vec3(0.27), 0.005);\n    if(bBox < volBox) {\n        id = BBOX;\n    }\n    \n    return min(volBox, bBox);\n}\n\nvec3 normal(in vec3 p) {\n    float eps = MIN_MARCH_DIST;\n    vec2 h = vec2(eps, 0);\n    return normalize(vec3(map(p+h.xyy) - map(p-h.xyy),\n                          map(p+h.yxy) - map(p-h.yxy),\n                          map(p+h.yyx) - map(p-h.yyx)));\n}\n\nmat2 rotate(float a) {\n    float si = sin(a), co = cos(a);\n    return mat2(co, si, -si, co);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(0,0,-1.);\n    ro.xz *= rotate(iTime/8.);\n    vec3 ta = vec3(0,0,0);\n    vec3 ww = normalize(ta-ro);\n    vec3 uu = normalize(cross(ww, vec3(0,1,0)));\n    vec3 vv = normalize(cross(uu,ww));\n    vec3 rd = normalize(uv.x*uu + uv.y*vv + 1.0*ww);\n    \n    vec3 col = vec3(0,0,0);\n    vec3 p = vec3(0);\n    float t = 0.;\n    float i = 0.;\n    float sampleDensity = 0.;\n    bool inside = false;\n    float StepSize = 1. / MAX_VOLUMETRIC_STEPS;    \n    vec3 C = vec3(0,0,0);\n    vec3 C2 = vec3(0);\n    \n    for(i=0.; i < MAX_MARCH_STEPS; i++) {\n        p = ro + t*rd;\n        float d = map(p);\n        if(inside && d > 0.) {\n            // there is nothing behind the volume atm\n            // so just break when we exit the volume.\n            break;\n        }\n        if(d < MIN_MARCH_DIST) {\n            if(id == BBOX) {\n                break;\n            }\n            if(!inside) {\n                // fix weird plane visuals\n                t += random(dot(p, p) + iTime) * StepSize;\n                p = ro + t*rd;\n            }\n            inside = true;\n            float density = perlinworley3d(p);\n            \n            \n            // method1\n            sampleDensity += clamp(density, 0., 1.) * StepSize;\n            // Cout(v) = Cin(v) * (1 - Opacity(x)) + Color(x) * Opacity(x)\n            C = C * (1. - density * StepSize) + vec3(1,0,0) * density * StepSize;\n            \n            \n            // method2\n            float absorbance = exp(-density * StepSize);\n            C2 += vec3(1,0,0) * (1.-absorbance);\n            \n            \n            t += StepSize;\n        }\n        else {\n            t += d;\n        }\n        if(t > MAX_MARCH_DIST)\n            break;\n    }\n    if(i >= MAX_MARCH_STEPS) {\n        t = MAX_MARCH_DIST;\n    }\n    \n    float strength = 14.;\n    sampleDensity *= strength;\n    C *= strength;\n    \n    if(t < MAX_MARCH_DIST) {\n        if(id == BBOX) {\n            vec3 L = normalize(ro-rd - cross(vec3(0,1,0),rd)*.2);\n            vec3 N = normal(p);            \n            vec3 c = vec3(.7) * clamp(dot(L, N), 0., 1.) + vec3(0.1);\n            col = mix(c, C, sampleDensity);\n        }\n        else col = C2*14.;// C2*14.;\n    }\n    \n    fragColor = vec4(pow(col, 1./vec3(2.2)), 1);\n}","name":"Image","description":"","type":"image"}]}