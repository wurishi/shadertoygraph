{"ver":"0.1","info":{"id":"cdSGzc","date":"1667922793","viewed":86,"name":"Question2_GoheungChoi","username":"ga1oxi4ng","description":"Starting point for Question 2 - Basic Shading\n\nDrag mouse for orbit camera.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["shading"],"hasliked":0,"parentid":"XlffR2","parentname":"Question 2 - Basic Shading"},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n * Blinn-Phong illumination model based Raytracer\n * used a little bit of tricks to make it realistic.\n * the total internal refraction and reflection after refraction are not handled properly.\n * it doens't do actual refraction, so the result won't be perfectly photorealistic.\n */\n\n//=======================================================================================\nbool RayIntersectAABox  (in vec3 boxMin, in vec3 boxMax, in vec3 rayPos, in vec3 rayDir, out vec3 hitPos, out vec3 normal, inout float maxTime)\n{\n    vec3 boxCenter = (boxMin+boxMax)*0.5;\n\tvec3 roo = rayPos - boxCenter;\n    vec3 rad = (boxMax - boxMin)*0.5;\n\n    vec3 m = 1.0/rayDir;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    vec2 time = vec2( max( max( t1.x, t1.y ), t1.z ),\n                 min( min( t2.x, t2.y ), t2.z ) );\n    \n    // if the time is beyond the maximum allowed bail out (we hit somethign else first!)\n    if (time.x > maxTime)\n        return false;\n    \n    // if time invalid or we hit from inside, bail out\n    if (time.y < time.x || time.x < 0.0)\n        return false;\n\t\n    // calculate surface normal\n    hitPos = rayPos + rayDir * time.x;   \n    vec3 hitPosRelative = hitPos - boxCenter;\n    vec3 hitPosRelativeAbs = abs(hitPosRelative);\n    vec3 distToEdge = abs(hitPosRelativeAbs - rad);\n\n    float closestDist = 1000.0;\n    for(int axis = 0; axis < 3; ++axis)\n    {\n        if (distToEdge[axis] < closestDist)\n        {\n            closestDist = distToEdge[axis];\n            normal = vec3(0.0);\n            if (hitPosRelative[axis] < 0.0)\n                normal[axis] = -1.0;\n            else\n                normal[axis] = 1.0;\n        }\n    }        \n\n    // store the collision time as the new max time\n    maxTime = time.x;\n    return true;\n}\n\n//=======================================================================================\nbool RayIntersectSphere (in vec4 sphere, in vec3 rayPos, in vec3 rayDir, out vec3 hitPos, out vec3 normal, inout float maxTime)\n{\n    if (sphere.w <= 0.0)\n        return false;\n    \n\t//get the vector from the center of this circle to where the ray begins.\n\tvec3 m = rayPos - sphere.xyz;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn false;\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn false;\n\n\t//ray now found to intersect sphere, compute smallest t value of intersection\n\tfloat collisionTime = -b - sqrt(discr);\n\n\t//if t is negative, ray started inside sphere so clamp t to zero and remember that we hit from the inside\n\tif(collisionTime < 0.0)\n        return false;\n    \n    // if the time is beyond the maximum allowed bail out (we hit something else first!)\n    if (collisionTime > maxTime)\n        return false;\n    \n    // store the collision time as the new max time\n    maxTime = collisionTime;\n    \n\t//compute the point of intersection\n\thitPos = rayPos + rayDir * collisionTime; \n    \n    // if hitPos == rayPos\n    if (distance(hitPos, rayPos) < 0.001) {\n        if (abs(discr) < 0.001) {\n            return false;\n        } else {\n            collisionTime = -b + sqrt(discr);\n            // if the time is beyond the max\n            if (collisionTime > maxTime)\n                return false;\n            maxTime = collisionTime;\n            hitPos = rayPos + rayDir * collisionTime; \n        }\n    }\n    \n    vec3 unit_n = normalize(hitPos-sphere.xyz);\n   \t// calculate the normal\n    if (acos(dot(-rayDir, unit_n)) > acos(dot(-rayDir,-unit_n)))\n      normal = -unit_n;\n    else\n      normal = unit_n;\n    \n\t//normal = hitPos - sphere.xyz;\n\t//normal = normalize(normal); \n\n\treturn true;\n}\n//=======================================================================================\nbool DetectCollision (in vec3 rayPos, in vec3 rayDir, \n                      out vec3 hitPos, out vec3 normal, out vec3 Od, out vec3 k, out float n,\n                      out float opacity, out float eta,\n                      inout bool isLight) {\n    float maxRayHitTime = 1000.0;\n    bool hit = false;\n        \n\t// green box\n    if (RayIntersectAABox(vec3(0.4,-0.3,-0.5), vec3(1.4,0.3,0.5), rayPos, rayDir, hitPos, normal, maxRayHitTime))\n    {\n        hit = true;\n        Od = vec3(0.1, 0.9, 0.1);\n        k = vec3(0.4, 0.8, 0.4);\n        n = 10.f;\n        opacity = 1.0;\n        eta = 1.f;\n    }\n\t\n    // red sphere\n    if (RayIntersectSphere(vec4(-0.4, 0.4, 0.5, 0.5), rayPos, rayDir, hitPos, normal, maxRayHitTime))\n    {\n        hit = true;\n        Od = vec3(0.9, 0.1, 0.1);   \n        k = vec3(0.4, 0.8, 0.4);\n        n = 10.f;\n        opacity = 1.0;\n        eta = 1.f;\n    }\n    \n    // blue sphere\n    if (RayIntersectSphere(vec4(-0.8, 0.4, -0.75, 0.25), rayPos, rayDir, hitPos, normal, maxRayHitTime))\n    {\n        hit = true;\n        Od = vec3(0.1, 0.1, 0.9);   \n        k = vec3(0.0, 0.1, 0.01f);\n        n = 10.f;\n        opacity = 0.f;\n        eta = 1.6f;\n    }\n    \n    // emissive light bulb\n    if (RayIntersectSphere(vec4(0.f, 0.f, 0.f, 0.1), rayPos, rayDir, hitPos, normal, maxRayHitTime))\n    {\n        hit = true;\n        Od = vec3(1.f, 1.f, 1.f);    \n        k = vec3(.99f, .0f, .01f);\n        n = 100.f;\n        opacity = 1.f;\n        isLight = true;\n        eta = 1.f;\n    }\n    \n    return hit;\n}\n\n//=======================================================================================\nfloat CastShadow (in vec3 rayPos, in vec3 rayDir) {\n    float S = 1.f; // no shadow\n    vec3 hitPos;    \n    vec3 j1, j2, j3; // junk vars\n    float j4;\n    float opacity;\n    float eta;\n    bool isLight = false;\n    if (DetectCollision(rayPos, rayDir, hitPos, j1, j2, j3, j4, opacity, eta, isLight)) {\n        if (!isLight) { // set shadow constant S\n            S = S * (1.f - opacity);\n        }\n    }\n    \n    return S;\n}\n\n//=======================================================================================\nvec3 ShadePixel (in vec3 camPos, in vec3 rayPos, in vec3 rayDir, in vec3 hitPos, in vec3 normal, \n                in vec3 Od, in vec3 k, in float n, in float opacity, in float eta)\n{\n    // light info\n    vec3 Il = vec3(1.f, 1.f, 1.f);\n    vec3 pointLight = vec3(0.f, 0.f, 0.f); float rad = 0.1f;\n    vec3 c = vec3(0.f, 0.1f, 0.5f);\n    float att;\n    vec3 dirLight = normalize(vec3(1.f, -1.f, 1.f));\n    // hit info\n    float maxHit = 1000.0;\n    float numHits = 0.0;\n    bool hit = false;\n    // init\n    vec3 I = vec3(0.f);\n    float tempks = 1.f;\n    float eta_i = 1.f;\n    float eta_t = eta;\n    vec3 Ir;\n    do {\n        // ambient\n        vec3 I_hat = k[0] * Od;\n        numHits = numHits + 1.f;\n        /* phong illumination: diffuse + specular shading */\n        vec3 V = normalize(camPos - hitPos); // hitPos to camPos\n        vec3 L; // hitPos to a lightPos\n        \n        // i=0: point light\n        // i=1: directional light\n        float S = 1.f; // shadow flag\n        for (int i = 0; i < 2; i++) {\n            if (i == 0) {\n                L = normalize(pointLight - hitPos);\n                float dist = distance(pointLight+rad*1.01f, hitPos);\n                att = 1.f / (c[0] + c[1]*dist + c[2]*dist*dist); // attenuation\n                S = CastShadow(hitPos*1.01f, L); // get shadow flag\n            } else if (i == 1) {\n                L = normalize((-1.f) * dirLight);\n                att = .8f;\n                S = CastShadow(hitPos*1.01f, L); // get shadow flag\n            }\n\n            vec3 H = (L + V) / length(L + V);\n            float N_dot_L = max(0.f, dot(normal, L));\n            float N_dot_H = max(0.f, dot(normal, H));\n            float N_dot_H_sq_n = pow(N_dot_H, n);\n\n            vec3 Id = k[1] * N_dot_L * Od; // diffuse\n            vec3 Is = k[2] * N_dot_H_sq_n * Il; // specular\n            I_hat = I_hat + ((Id + Is) * att * S); // local illumination\n        }\n        \n        // global illumination\n        I = I + I_hat * tempks;\n        /* end of phong illumination */\n        \n        // update ks\n        tempks *= k[2];\n        \n        /******** get Fr ********/\n        if (abs(eta_t - eta_i) < 0.00001) {\n            eta_t = 1.0;\n        }\n        float F0_00 = eta_t - eta_i;\n        float F0_01 = eta_t + eta_i;\n        float F0_1 = F0_00 / F0_01;\n        float F0 = F0_1 * F0_1;\n        float cos_incoming_theta = dot(normal, -rayDir);\n        float Fr_0 = pow(1.0 - cos_incoming_theta, 5.f);\n        float Fr = F0 + (1.0 - F0) * Fr_0;\n        \n        float angle_of_i = acos(dot(-rayDir, normal));\n        float temp_r = eta_t / eta_i;\n        float critical_angle = asin(temp_r);\n\n        bool internal_reflection = sin(angle_of_i) > temp_r && angle_of_i >= critical_angle;\n        if (!internal_reflection && opacity < 0.98f) {\n            /** get T vector**/\n            float ratio = eta_i / eta_t;\n            vec3 T = refract(rayDir, normal, ratio);\n            // check whether there is an intersection\n            // and get the closest intersection point\n            // get the color of the reflection\n            // if not, no reflection.\n            bool isLight = false;\n            tempks = (1.f - Fr) * (1.f - opacity);\n            // default color is the background\n            Ir = texture(iChannel0, T).rgb;\n            // get refraction info\n            eta_i = eta_t;\n            hit = DetectCollision (hitPos, T, hitPos, normal, Od, k, n, opacity, eta_t, isLight);\n            if (!hit) break; // if no collision, stop tracing\n            if (isLight) { // set color of the light\n                Ir = Od;\n                tempks = 0.9f;\n                break;\n            }\n        } else if (internal_reflection && opacity < 0.98f) {\n            // reflected rayDir\n            float ratio = eta_i / eta_t;\n            vec3 R = refract(rayDir, normal, ratio);\n            // default color is the background\n            Ir = texture(iChannel0, R).rgb;\n            tempks = (1.f - Fr) * (1.f - opacity);\n            // check for reflection\n            \n            rayDir = normalize(R);\n            vec4 sphere = vec4(-0.8, 0.4, -0.75, 0.25);\n            vec3 m = rayPos - sphere.xyz;\n            float b = dot(m, rayDir);\n            float c = dot(m, m) - sphere.w * sphere.w;\n            float discr = b * b - c;\n            float t = -b + sqrt(discr);\n            hitPos = hitPos + rayDir * t; \n            \n            normal = -normalize(hitPos-sphere.xyz);\n        } else {\n            // reflected rayDir\n            vec3 R = reflect(rayDir, normal);\n            // default color is the background\n            Ir = texture(iChannel0, R).rgb;\n            bool isLight = false;\n            // check for reflection\n            hit = DetectCollision (hitPos, R, hitPos, normal, Od, k, n, opacity, eta_t, isLight);\n            if (!hit) break; // if no collision, stop tracing\n            if (isLight) { // set color of the light\n                tempks = 0.9f;\n                break;\n            }\n            if (opacity < 0.99f) {\n                normal = -normal;\n            }\n        }\n        // if intensity is too small, break the loop\n        if (all(lessThan(I_hat * tempks, vec3(0.00001)))) break;\n    } while (hit && numHits < maxHit);\n    I = I + Ir * tempks;\n    \n\treturn I;\n}\n\n//=======================================================================================\nvoid TraceRay (in vec3 camPos, in vec3 rayPos, in vec3 rayDir, inout vec3 pixelColor)\n{   \n    float maxRayHitTime = 1000.0;\n    \n    vec3 hitPos;    \n    vec3 normal; \n    vec3 Od;\n    vec3 k;\n    float n;\n    float opacity;\n    float eta;\n    bool isLight = false;\n    bool hit = DetectCollision (rayPos, rayDir, hitPos, normal, Od, k, n, opacity, eta, isLight);\n    \n    // default background\n    pixelColor = texture(iChannel0, rayDir).rgb;\n    if (!hit)\n\t\treturn;\n        \n    if (isLight) { // set the color of the point light\n        pixelColor = Od;\n        return;\n    }\n    \n    pixelColor = ShadePixel(camPos, rayPos, rayDir, hitPos, normal, Od, k, n, opacity, eta);\n}\n\n//=======================================================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    //----- camera setup\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\n    vec3 cameraAt \t= vec3(0.0,0.0,0.0);\n\n    float angleX = iMouse.z > 0.0 ? 6.28 * mouse.x : 0.0;\n    float angleY = iMouse.z > 0.0 ? (mouse.y * 6.28) : 0.0;\n\n    vec3 cameraPos\t= (vec3(sin(angleX)*cos(angleY), sin(angleY), cos(angleX)*cos(angleY))) * 4.0;\n\n    vec3 cameraFwd  = normalize(cameraAt - cameraPos);\n    vec3 cameraLeft  = normalize(cross(normalize(cameraAt - cameraPos), vec3(0.0,sign(cos(angleY)),0.0)));\n    vec3 cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n\n    float cameraViewWidth\t= 6.0;\n    float cameraViewHeight\t= cameraViewWidth * iResolution.y / iResolution.x;\n    float cameraDistance\t= 6.0;  // intuitively backwards!    \n    \n\tvec2 rawPercent = (fragCoord.xy / iResolution.xy);\n\tvec2 percent = rawPercent - vec2(0.5,0.5);\n\t\n\tvec3 rayPos;\n\tvec3 rayTarget;\n\t   \n\t// if the mouse button is down do orbit camera\n\tif( iMouse.z > 0.0 ) {\n\t\trayTarget = (cameraFwd * cameraDistance)\n\t\t\t\t  + (cameraLeft * percent.x * cameraViewWidth)\n\t\t          + (cameraUp * percent.y * cameraViewHeight);\n\t\t\n\t\trayPos = cameraPos;\n\t}\n\t// else handle the case of the mouse button not being down\n\telse {\n\t\trayPos = vec3(0.0,3.0,-3.0);\n\t\tvec3 f = normalize(cameraAt - rayPos);\n\t\tvec3 l = normalize(cross(f,vec3(0.0,1.0,0.0)));\n\t\tvec3 u = normalize(cross(l,f));\n\t\t\n\t\trayTarget = (f * cameraDistance)\n\t\t\t\t  + (l * percent.x * cameraViewWidth)\n\t\t          + (u * percent.y * cameraViewHeight);\t\t\n\t}\n    \n\t//----- ray trace\n\tvec3 rayDir = normalize(rayTarget);\n    \n    // initialze ray color to the cube map\n    vec3 pixelColor = texture(iChannel0, rayDir).rgb;\n    \n    // ray trace\n\tTraceRay(cameraPos, rayPos, rayDir, pixelColor);\n    \n    // output sRGB corrected pixel\n    pixelColor = pow(pixelColor, vec3(1.0/2.2));   \n\tfragColor = vec4(pixelColor, 1.0);\n}\n\n/*\n\nAdd:\n* point light and directional light (diffuse + specular. Doesn't need to be PBR. Lambert / phong is ok!)\n* ambient lighting\n* emissive lighting\n* environment mapped reflections\n\n* One other feature to make it unique / show off your stuff. Some ideas:\n * shadows\n * Normal or bump mapping\n * ray based reflections\n * anti aliasing\n * lens effects\n * post processing effects\n * warping geometry, more complex geometry\n * animating the camera, lights or geometry.\n * refraction or transparency\n * anything else you can think of\n*/\n\n","name":"Image","description":"","type":"image"}]}