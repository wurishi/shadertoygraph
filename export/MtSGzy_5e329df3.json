{"ver":"0.1","info":{"id":"MtSGzy","date":"1429888656","viewed":777,"name":"hex sphere with simple godrays","username":"public_int_i","description":"aiekicks hex spherewith added godrays and changed the camera movement. now it just needs something in the center.","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["sphere","godrays","hex"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// Created by Stephane Cuillerdier - Aiekick/2015, godrays added by ethan shulman/public_int_i\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// use mouse y to change pattern\n// use mouse x to change camera distance\n\nconst vec2 RMPrec = vec2(0.5, 0.001); // ray marching tolerance precision // low, high\nconst vec2 DPrec = vec2(1e-5, 10.); // ray marching distance precision // low, high\n    \nfloat pattern = 3.; // pattern value 1. to 5. use mouse y to change\n\nfloat sphereThick = 0.02; // thick of sphere plates\nfloat sphereRadius = 6.; // radius of sphere before tex displace\n\nfloat norPrec = 0.01; // normal precision \n\n// light\nconst vec3 LCol = vec3(0.8,0.5,0.2);\nconst vec3 LPos = vec3(-0.6, 0.7, -0.5);\nconst vec3 LAmb = vec3( 0. );\nconst vec3 LDif = vec3( 1. , 0.5, 0. );\nconst vec3 LSpe = vec3( 0.8 );\n\n// material\nconst vec3 MCol = vec3(0.);\nconst vec3 MAmb = vec3( 0. );\nconst vec3 MDif = vec3( 1. , 0.5, 0. );\nconst vec3 MSpe = vec3( 0.6, 0.6, 0.6 );\nconst float MShi =30.;\n    \n#define mPi 3.14159\n#define m2Pi 6.28318\n\nvec2 uvs(vec3 p)\n{\n    p = normalize(p);\n    vec2 tex2DToSphere3D;\n    tex2DToSphere3D.x = 0.5 + atan(p.z, p.x) / (m2Pi*1.1547);\n    tex2DToSphere3D.y = 0.5 - asin(p.y) / (mPi*1.5);\n    return tex2DToSphere3D;\n}\n\n// Hex Pattern based on IQ Shader https://www.shadertoy.com/view/Xd2GR3\nfloat hex(vec2 p, int i)\n{\n    vec2 q = vec2( p.x*2.0*0.5773503, p.y + p.x*0.5773503 );\n\tvec2 pi = floor(q);\n\tvec2 pf = fract(q);\n\n    // 3. => hexagon\n    // 4. => brain pattern\n\tfloat v = mod(pi.x + pi.y, pattern);\n\n    float ca = step(1.,v);\n\tfloat cb = step(2.,v);\n\tvec2  ma = step(pf.xy,pf.yx);\n\t\n    float e = dot( ma, 1.0-pf.yx + ca*(pf.x+pf.y-1.0) + cb*(pf.yx-2.0*pf.xy) );\n\n    float hex = i==0?clamp(0.,0.2,e):1.-smoothstep(e, 0.1, 0.0);\n    \n    return hex*.2;\n}\n\nvec2 map(vec3 p)\n{\n    vec2 res = vec2(0.);\n    \n    float t = sin(iTime*.5)*.5+.5;\n    \n    float sphereOut = length(p) -sphereRadius - hex(uvs(p.xyz)*50.,0);\n    res = vec2(sphereOut, 1.);\n    \n    float sphereIn = length(p) - sphereRadius - sphereThick;\n    if (-sphereIn>res.x) \n        res = vec2(-sphereIn, 2.);\n    \n    return res;\n}\n\nvec3 nor(vec3 p, float prec)\n{\n    vec2 e = vec2(prec, 0.);\n    \n    vec3 n;\n    \n    n.x = map(p+e.xyy).x - map(p-e.xyy).x; \n    n.y = map(p+e.yxy).x - map(p-e.yxy).x; \n    n.z = map(p+e.yyx).x - map(p-e.yyx).x;  \n    \n    return normalize(n); \n}\n\nvec3 ads( vec3 p, vec3 n )\n{\n    vec3 ldif = normalize( LPos - p);\n    vec3 vv = normalize( vec3(0.,0.,0.) - p );\n    vec3 refl = reflect( vec3(0.,0.,0.) - ldif, n );\n    \n    vec3 amb = MAmb*LAmb;\n    vec3 dif = max(0.0, dot(ldif, n.xyz)) * MDif * LDif;\n    vec3 spe = vec3( 0.0, 0.0, 0.0 );\n    if( dot(ldif, vv) > 0.0)\n        spe = pow(max(0.0, dot(vv,refl)),MShi)*MSpe*LSpe;\n    \n    return amb*1.2 + dif*1.5 + spe*0.8;\n}\n\nvec4 scn(vec4 col, vec3 ro, vec3 rd)\n{\n    vec2 s = vec2(DPrec.x);\n    float d = 0.;\n    vec3 p = ro+rd*d;\n    vec4 c = col;\n    \n    float b = 0.35;\n    \n    float t = 1.1*(sin(iTime*.3)*.5+.6);\n    \n    for(int i=0;i<200;i++)\n    {\n    \tif(s.x<DPrec.x||s.x>DPrec.y) break;\n        s = map(p);\n        d += s.x*(s.x>DPrec.x?RMPrec.x:RMPrec.y);\n        p = ro+rd*d;\n    }\n    \n    if (s.x<DPrec.x)\n    {\n        vec3 n = nor(p, norPrec); \n      \tvec3 ray = reflect(rd, n);\n\t\t\n        if ( s.y < 1.5) // ext\n        {\n            vec3 cuberay = texture(iChannel0, ray).rgb * 0.5;\n            c.rgb = MCol + cuberay + pow(b, 15.);\n        }\n        else if ( s.y < 2.5) // int\n        {\n            c.rgb = ads(p,n);\n        }\n    }\n    else\n    {\n       \tc = texture(iChannel0, rd);\n    }\n    \n    \n    return c;\n}\n\nvec3 cam(vec2 uv, vec3 ro, vec3 cu, vec3 org, float persp)\n{\n\tvec3 rorg = normalize(org-ro);\n    vec3 u =  normalize(cross(cu, rorg));\n    vec3 v =  normalize(cross(rorg, u));\n    vec3 rd = normalize(rorg + u*uv.x + v*uv.y);\n    return rd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 s = iResolution.xy;\n    vec2 g = fragCoord.xy;\n    vec2 uv = (2.*g-s)/s.y;\n    vec2 m = iMouse.xy;\n    \n    float t = iTime*0.2;\n    float ts = sin(t)*.5+.5;\n    \n    float axz = -t; // angle XZ\n    float axy = .8; // angle XY\n    float cd = 10.*(ts*.3+.7); // cam dist to scene origine\n    \n    //if ( iMouse.z>0.) cd = 10. * m.x/s.x; // mouse x axis \n    if ( iMouse.z>0.) pattern = floor(6. * m.y/s.y); // mouse y axis \n    \n    float ap = 1.; // angle de perspective\n    vec3 cu = vec3(0.,1.,0.); // cam up \n    vec3 org = vec3(0., 0., 0.); // scn org\n    vec3 ro = vec3(cos(axz),sin(axy),sin(axz))*cd; // cam org\n    \n    vec3 rd = cam(uv, ro, cu, org, ap);\n    \n    vec4 c = vec4(0.,0.,0.,1.); // col\n    \n    c = scn(c, ro, rd);\n    \n//godrays - public_int_i/ethan\nfloat sc = dot(ro, ro) - 48.;\nfloat sb = dot(rd, ro);\n\nfloat sd = sb*sb - sc;\nfloat st = -sb - sqrt(abs(sd));\n\nif (!(sd < 0.0 || st < 0.0)) {\n    \nconst int godrayIter = 64;\nconst float godrayIntensity = .05;\nconst float godrayPrecision = .05;\n\nfloat gr = 0.;\n        \nro += rd*st;\nfloat rlen = 6.928203-length(ro);\n        \nrd *= godrayPrecision;\nfor (int i = 0; i < godrayIter; i++) {\n            \n     if (hex(uvs(ro)*50.,0) < .04) gr+=rlen;\n       ro += rd;\n       rlen = 6.928203-length(ro);\n       if (!(rlen > 0. && rlen < 1.)) break;\n}\n        \nc.xyz += LCol*godrayIntensity*gr;\n}\n//end of godrays\n\t\n    fragColor = c;\n}","name":"","description":"","type":"image"}]}