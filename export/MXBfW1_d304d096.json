{"ver":"0.1","info":{"id":"MXBfW1","date":"1729694303","viewed":54,"name":"nova fractal","username":"CuleGamer","description":"mess with the values at the top of code for fun\nreference: https://www.hpdz.net/","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["2d","fractal","complex"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//the nova fractal rendered by orbit traps\n//R is controlled by mouse\n\n//if defined, pixel determines starting value rather than addition value\n//#define JULIA_MODE\n\n//if defined, use sin instead of roots of unity as function\n//#define FUNC_SIN\n\n//starting value, useless if JULIA_MODE is defined\nconst vec2 z_0 = vec2(-1., 0.);\n\n//exponent for z^p - 1, useless if FUNC_SIN is defined\nconst float p = 5.;\n\n//scale of image\nconst float sc = 2.;\n\n//iteration steps\nconst uint steps = 256u;\n\n//color profile\nconst vec3 colfac = 1.5 * vec3(0.004, 0.04, 0.06);\n\nvec2 cmul(vec2 z, vec2 w)\n{\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec2 cinv(vec2 c)\n{\n    return vec2(c.x, -c.y) / dot(c, c);\n}\n\nvec2 cdiv(vec2 z, vec2 w)\n{\n    return cmul(z, cinv(w));\n}\n\nvec2 cpowr(vec2 z, float p)\n{\n    float t = p * atan(z.y, z.x);\n    return pow(length(z), p) * vec2(cos(t), sin(t));\n}\n\nfloat trap(vec2 z)\n{\n    return length(z);\n}\n\nvec2 csin(vec2 z)\n{\n    return vec2(sin(z.x) * cosh(z.y), cos(z.x) * sinh(z.y));\n}\n\nvec2 ccos(vec2 z)\n{\n    return vec2(cos(z.x) * cosh(z.y), -sin(z.x) * sinh(z.y));\n}\n\nvec2 f(vec2 z)\n{\n    #ifdef FUNC_SIN\n    return csin(z);\n    #else\n    return cpowr(z, p) - vec2(1., 0.);\n    #endif\n}\n\nvec2 df(vec2 z)\n{\n    #ifdef FUNC_SIN\n    return ccos(z);\n    #else\n    return p * cpowr(z, p - 1.);\n    #endif\n}\n\nvoid mainImage(out vec4 O, in vec2 I)\n{\n    vec2 R = sc * (2. * iMouse.xy - iResolution.xy) / iResolution.y;\n    vec2 c = sc * (2. * I - iResolution.xy) / iResolution.y;\n    vec2 z = z_0;\n    #ifdef JULIA_MODE\n    z = c;\n    #endif\n    float dist = 1000.;\n    for(uint i; i < steps; i++)\n    {\n        z -= cmul(R, cdiv(f(z), df(z)));\n        #ifndef JULIA_MODE\n        z += c;\n        #endif\n        dist = min(dist, trap(z));\n    }\n    vec3 col = colfac * vec3(1. / (dist * dist), 1. / (dist), 1. / log(dist + 1.));\n    O = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}