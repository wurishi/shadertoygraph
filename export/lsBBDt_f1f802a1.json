{"ver":"0.1","info":{"id":"lsBBDt","date":"1502716107","viewed":435,"name":"Basic Knot Shader","username":"Akko","description":"A basic knot shader.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["knot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926535894932384626\n#define DELTA_X vec3(0.001, 0, 0)\n#define DELTA_Y vec3(0, 0.001, 0)\n#define DELTA_Z vec3(0, 0, 0.001)\n#define LIGHT_POS vec3(20.0, 30.0, 30.0)\n#define LIGHT_SIZE 3.0\n#define LIGHT_COLOR vec3(0.7, 0.7, 0.7)\n#define AMBIENT vec3(0.2, 0.2, 0.2)\n\nvec3 cylinder2cartesian(float r, float phi, float z)\n{\n    return vec3(r * cos(phi), r * sin(phi), z);\n}\n\nfloat dist_estimator(in vec3 pos)\n{\n    float r = length(pos);\n    float phi = atan(pos.y, pos.x);\n    float r1 = sin(1.5 * phi) + 1.5;\n    float z1 = cos(1.5 * phi);\n    float r2 = sin(1.5 * phi + PI) + 1.5;\n    float z2 = cos(1.5 * phi + PI);\n   \tvec3 p1 = cylinder2cartesian(r1, phi, z1);\n    vec3 p2 = cylinder2cartesian(r2, phi, z2);\n    return (min(distance(pos, p1), distance(pos, p2)) - 0.3) / 4.0;\n}\n\nvec3 get_normal(in vec3 pos)\n{\n    return normalize(vec3(dist_estimator(pos + DELTA_X) - dist_estimator(pos - DELTA_X),\n                          dist_estimator(pos + DELTA_Y) - dist_estimator(pos - DELTA_Y),\n                          dist_estimator(pos + DELTA_Z) - dist_estimator(pos - DELTA_Z)));\n}\n\n// For more accurate shadow.\nfloat shadow_round2(in vec3 src, in vec3 drt, float dist)\n{\n    float res = 0.0, t = 0.1;\n    for (int i = 0; i < 5; ++i)\n    {\n        float delta = dist_estimator(src + t * drt);\n        float radius = LIGHT_SIZE * t / dist;\n        t += delta + radius;\n        res = max(res, clamp(-delta / radius, 0.0, 1.0));\n    }\n    return res;\n}\n\n// Using cone tracing to calculate the soft shadow.\nfloat shadow(in vec3 src, in vec3 drt)\n{\n    float res = 1.0, t = 0.1, dist = distance(src, LIGHT_POS), res_pos;\n    for (int i = 0; i < 50; ++i)\n    {\n        float delta = dist_estimator(src + t * drt);\n        float radius = LIGHT_SIZE * t / dist;\n        if (delta < -radius)\n            return 0.0;\n        t += delta + radius;\n        float cur_res = clamp(delta / radius, -1.0, 1.0);\n        if (cur_res < res)\n        {\n            res = min(res, clamp(delta / radius, -1.0, 1.0));\n            res_pos = t;\n        }\n        if (t > dist)\n        {\n            float size1 = (acos(res) - res * sqrt(1.0 - res * res)) / PI;\n            if (size1 < 0.1)\n                return 1.0 - size1;\n            // shadow round 2.\n            vec3 normal = get_normal(src + drt * res_pos);\n            vec3 drt2 = normalize(drt + normal * LIGHT_SIZE / dist);\n            float res2 = 1.0 - shadow_round2(src, drt2, dist);\n            float size2 = (acos(res2) - res2 * sqrt(1.0 - res2 * res2)) / PI;\n            return max(1.0 - size1 - size2, 0.0);\n        }\n    }\n    return 0.0;\n}\n\nfloat intersects(in vec3 src, in vec3 drt)\n{\n    float t;\n   \tfor (int i = 0; i < 150; ++i)\n    {\n       \tfloat delta = dist_estimator(src + t * drt);\n        t += delta;\n        if (delta < 1e-6)\n            break;\n    }\n   \treturn t;\n}\n\nvec4 trace(in vec3 src, in vec3 dst)\n{\n    vec3 drt = normalize(dst - src);\n    vec3 light = vec3(0, 0, 3.0);\n    float t = intersects(src, drt);\n    if (t <= 20.0)\n    {\n    \tvec3 surface_pos = src+ drt * t;\n        vec3 light_drt = normalize(LIGHT_POS - surface_pos);\n        float strenth = shadow(surface_pos, light_drt) * max(dot(get_normal(surface_pos), light_drt), 0.0);\n        return vec4(LIGHT_COLOR * strenth + AMBIENT, 1);\n    }\n    else\n        return vec4(0, 0, 0, 1);\n}\n\nvec3 camera(in vec3 src, in vec3 lookat, in vec3 up, in vec2 uv)\n{\n    vec3 lookat_ = normalize(lookat - src);\n    vec3 right_ = normalize(cross(lookat_, up));\n    vec3 up_ = normalize(cross(right_, lookat_));\n    return src + lookat_ + (right_ * uv.x + up_ * uv.y) * 0.4;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (vec2(fragCoord.x - iResolution.x / 2.0, fragCoord.y - iResolution.y / 2.0) / max(iResolution.x, iResolution.y)) * 2.0;\n    vec3 src = vec3(6.0 * cos(iTime / 2.0), 6.0 * sin(iTime / 2.0), 12.0);\n    vec3 lookat = vec3(0.0, 0.0, 0.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    fragColor = trace(src, camera(src, lookat, up, uv));\n}\n","name":"Image","description":"","type":"image"}]}