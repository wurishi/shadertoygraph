{"ver":"0.1","info":{"id":"XfcyWH","date":"1730543726","viewed":22,"name":"Shader Advent Day-16","username":"mrange","description":"Shader Advent Day-16\nCC0: Faking Wave Function Collapse in Shaders\n\nhttps://github.com/mrange/shader-advent-2024/tree/main/day-16","likes":2,"published":3,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// https://github.com/mrange/shader-advent-2024/tree/main/day-16\n\n// Undefine to draw the basic cells building up the board\n// #define DRAW_ALL_CELLS\n\n// Undefine to just show the cells that are generated randomly\n// #define ONLY_RANDOM_CELLS\n\n// Undefine to show debug graphcs\n// #define DEBUG\n\n// Undefine to skip rotation of shapes\n// #define NOROT\n\n#define RESOLUTION iResolution\n#define TIME       iTime\n#define SCA(a)     vec2(sin(a),cos(a))\n\nconst float\n    pi  = acos(-1.)\n  , tau = 2.*pi\n  , lw  = 0.04\n  ;\n\n// Basic functions\n\n// Generates a pseudo-random number from 2D vector\nfloat hash(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\n// Reflects p using normal r\nfloat ref(inout vec2 p, vec2 r) {\n  float d = dot(p, r);\n  p -= r*min(0., d)*2.;\n  return d < 0. ? 0. : 1.;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n// Distance field for a 2D box with size 2*b\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// Distance field for a circle with radius r\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n// Distance field for a line across that ends in (0,0)\nfloat segmentx(vec2 p, float r) {\n  float d0 = length(p) - r;\n  float d1 = abs(p.y) - r;\n  return p.x > 0. ? d0 : d1;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n// Distance fields for a wave of circles\nfloat circleWave(vec2 p, float tb, float ra) {\n  tb = pi*5.0/6.0*max(tb,0.0001);\n  vec2 co = ra*vec2(sin(tb),cos(tb));\n  p.x = abs(mod(p.x,co.x*4.0)-co.x*2.0);\n  vec2  p1 = p;\n  vec2  p2 = vec2(abs(p.x-2.0*co.x),-p.y+2.0*co.y);\n  float d1 = ((co.y*p1.x>co.x*p1.y) ? length(p1-co) : abs(length(p1)-ra));\n  float d2 = ((co.y*p2.x>co.x*p2.y) ? length(p2-co) : abs(length(p2)-ra));\n  return min(d1, d2);\n}\n\n// Define distance fields and connection configurations for each cell type.\n// Connections are specified in a vec4, with each component representing a side:\n// vec4(left, top, right, bottom). For example, vec4(1.0, 0.0, 1.0, 0.0)\n// indicates connections on the left and right sides only.\n\n\n// Distance field and connections for cell with 0 connections\nconst vec4 cell0Cons = vec4(0.);\nfloat cell0(vec2 p) {\n  float d0 = circle(p, 0.15+0.06);\n  d0 = abs(d0) - lw;\n  d0 = abs(d0) - lw*0.5;\n  return d0;\n}\n\n// Distance field and connections for cell with 1 connection\nconst vec4 cell1Cons = vec4(1.,0.,0.,0.);\nfloat cell1(vec2 p) {\n  float d0 = circle(p, 0.15);\n  float d1 = segmentx(p,lw);\n  float d = min(d0,d1);\n  return d;\n}\n\n// Distance field and connections for cell with 2 connections. This forms a corner\nconst vec4 cell2cCons = vec4(1.,0.,0.,1.);\nfloat cell2c(vec2 p) {\n  vec2 p0 = p;\n  float d = abs(circle(p0+0.5,0.5))-lw;\n  return d;\n}\n\n// Distance field and connections for cell with 2 connections. This forms straight line\nconst vec4 cell2tCons = vec4(1.,0.,1.,0.);\nfloat cell2t(vec2 p) {\n  float d = abs(p.y)-lw;\n  return d;\n}\n\n// Distance field and connections for cell with 3 connections.\nconst vec4 cell3Cons = vec4(1.,0.,1.,1.);\nfloat cell3(vec2 p) {\n  vec2 p0 = -p;\n  p0.y -= -0.25;\n  vec2 p2 = p.yx;\n\n  float d0 = circleWave(p0, 0.5, 0.25)-lw;\n  float d2 = segmentx(p2, lw);\n  float d3 = circle(p2,0.15);\n  float d = d0;\n  d = min(d, d2);\n  d = min(d, d3);\n\n  return d;\n}\n\n// Distance field and connections for cell with 3 connections.\nconst vec4 cell4Cons = vec4(1.);\nfloat cell4(vec2 p) {\n  const vec2 ref45 = SCA(radians(-45.));\n  p = -abs(p);\n  ref(p, ref45);\n  p.x -= -0.3;\n  float d0 = circle(p, 0.15);\n  float d1 = segmentx(p, lw);\n  float d = min(d0,d1);\n  return d;\n}\n\n// Draw all cells for easier visualization while refining or tweaking cell designs.\nvec3 drawAllCells(vec3 col, vec2 p) {\n  const float tz = 2.0/3.0;\n  float aa = sqrt(2.)/RESOLUTION.y;\n  vec2 tp = p/tz;\n  vec2 np = round(tp);\n  vec2 cp = tp - np;\n  float d0 = 1E3;\n  if (np == vec2(0.,0.)) {\n    d0 = cell4(cp);\n  } else if (np == vec2(1.,0.)) {\n    d0 = cell1(cp);\n  } else if (np == vec2(-1.,0.)) {\n    d0 = cell2t(cp);\n  } else if (np == vec2(-0.,1.)) {\n    d0 = cell2c(cp);\n  } else if (np == vec2(0.,-1.)) {\n    d0 = cell3(cp*-1.);\n  } else if (abs(np) == vec2(1.,1.)) {\n    d0 = cell0(cp);\n  }\n\n  // A box surrounding each cell make the cells easier to see\n  float d1 = box(cp, vec2(0.5));\n  d1 = abs(d1) - 0.0125;\n  float d = d0;\n  d = min(d, d1);\n  d *= tz;\n  col = mix(col, vec3(0.8), smoothstep(aa, -aa, d));\n  return col;\n}\n\n// Generate two pseudo-random values from a cell identifier:\n// - v.x determines the cell type\n// - v.y determines the cell rotation\nvec2 selection(vec2 np) {\n  float h0 = hash(np+123.4);\n  float h1 = fract(h0*8667.0);\n  return vec2(h0,h1);\n}\n\n// For a given cell identifier, return a random cell's connections, accounting for rotation\nvec4 connections(vec2 np) {\n  vec2 sel = selection(np);\n\n  vec4 c = cell0Cons;\n\n  // CELL_DISTRIBUTION_MUST_MATCH: This distribution needs to be kept in sync\n  if (sel.x > 0.95) {\n    c = cell4Cons;\n  } else if (sel.x > 0.7) {\n    c = cell3Cons;\n  } else if (sel.x > 0.5) {\n    c = cell2cCons;\n  } else if (sel.x > 0.3) {\n    c = cell2tCons;\n  } else if (sel.x > 0.05) {\n    c = cell1Cons;\n  } else {\n  }\n\n#ifndef NOROT\n  // ROTATION_DISTRIBUTION_MUST_MATCH: This distribution needs to be kept in sync\n  if (sel.y > 0.75) {\n    c = c.yzwx;\n  } else if (sel.y > 0.5) {\n    c = c.zwxy;\n  } else if (sel.y > 0.25) {\n    c = c.wxyz;\n  } else {\n  }\n#endif\n\n  return c;\n}\n\n// For a given cell identifier, return a random cell's distance field\nfloat randomCell(vec2 np, vec2 cp) {\n  float d0 = 1E3;\n  vec2 sel = selection(np);\n#ifndef NOROT\n  // ROTATION_DISTRIBUTION_MUST_MATCH: This distribution needs to be kept in snc\n  if (sel.y > 0.75) {\n    cp = vec2(cp.y, -cp.x);\n  } else if (sel.y > 0.5) {\n    cp = -cp;\n  } else if (sel.y > 0.25) {\n    cp = vec2(-cp.y, cp.x);\n  } else {\n  }\n#endif\n\n  // CELL_DISTRIBUTION_MUST_MATCH: This distribution needs to be kept in sync\n  if (sel.x > 0.95) {\n    d0 = cell4(cp);\n  } else if (sel.x > 0.7) {\n    d0 = cell3(cp);\n  } else if (sel.x > 0.5) {\n    d0 = cell2c(cp);\n  } else if (sel.x > 0.3) {\n    d0 = cell2t(cp);\n  } else if (sel.x > 0.05) {\n    d0 = cell1(cp);\n  } else {\n    d0 = cell0(cp);\n  }\n  return d0;\n}\n\n// Distance field for a fixed cell, which samples neighboring cells to\n//  determine its shape and rotation\nfloat fixedCell(vec2 np, vec2 cp) {\n  vec4 cons;\n  // Peek at neighboring random cells by passing in their cell IDs.\n  // Each neighboring cell is pseudo-randomly generated from its ID.\n  // Our cell mirrors the connections of neighboring cells.\n  cons.x = connections(np-vec2( 1., 0.)).z;\n  cons.y = connections(np-vec2( 0.,-1.)).w;\n  cons.z = connections(np-vec2(-1., 0.)).x;\n  cons.w = connections(np-vec2( 0., 1.)).y;\n\n  // How many connections do we need?\n  float c = dot(vec4(1.), cons);\n  vec4 tcons;\n  // Pick a cell type that match the connections needed\n  // SELECTION_DISTRIBUTION_MUST_MATCH: This distribution needs to be kept in sync\n  if (c == 0.) {\n    tcons = cell0Cons;\n  } else if (c == 1.) {\n    tcons = cell1Cons;\n  // Two shapes have two connections each,\n  //  so we need to check the connections to identify the correct shape.\n  } else if (c == 2. && cons.x == cons.z) {\n    tcons = cell2tCons;\n  } else if (c == 2.) {\n    tcons = cell2cCons;\n  } else if (c == 3.) {\n    tcons = cell3Cons;\n  } else {\n    tcons = cell4Cons;\n  }\n\n  // The selected cell may have incorrect orientation, so we rotate its connections\n  //  until they align correctly.\n  //  Simultaneously, we apply the same rotation to the cell's coordinates.\n  for (int i = 0; i < 4; ++i) {\n    // Do we have a match?\n    if (tcons == cons) {\n      break;\n    }\n    // Rotate connections\n    tcons = tcons.wxyz;\n    // Rotate cell coordinates\n    cp = vec2(-cp.y, cp.x);\n  }\n\n  float d = 1E3;\n\n  // SELECTION_DISTRIBUTION_MUST_MATCH: This distribution needs to be kept in sync\n  if (c == 0.) {\n    d = cell0(cp);\n  } else if (c == 1.) {\n    d = cell1(cp);\n  // Two shapes have two connections each,\n  //  so we need to check the connections to identify the correct shape.\n  } else if (c == 2. && cons.x == cons.z) {\n    d = cell2t(cp);\n  } else if (c == 2.) {\n    d = cell2c(cp);\n  } else if (c == 3.) {\n    d = cell3(cp);\n  } else {\n    d = cell4(cp);\n  }\n\n  return d;\n}\n\n#ifdef DEBUG\n\n// Aligning the cells is tricky, so I added some debugging functions.\n//  These might be useful for others, and they also add a cool visual effect.\n\n// Generates distance fields for debugging a randomly selected cell.\n//  Displays a small red dot at connection points, allowing you to verify\n//  whether the cell shape aligns with its intended configuration.\nfloat debugRandomCell(vec2 np, vec2 cp) {\n  const vec2 offs[4] = vec2[4](vec2(1.,0.), vec2(0.,-1.),vec2(-1.,0.), vec2(0.,1.));\n\n  float dd = 1E3;\n  vec4 cons = connections(np);\n  for (int i = 0; i < 4; ++i) {\n    vec2 off = offs[i];\n    float con = cons[i];\n    if (con > 0.) {\n      dd = min(dd, circle(cp+0.45*off,0.03));\n    }\n  }\n  return dd;\n}\n\n// Generates distance fields for debugging a fixed cell.\n//  The fixed cell's properties are influenced by its neighboring random cells.\n//  It peeks at the neighbors to determine the number of connections,\n//  rotating one connection toward the fixed cell.\n//  The effect enhances the onion layer appearance based on the neighbor's connections.\n//  If a connection points directly to the fixed cell, only a half-circle is displayed.\nfloat debugFixedCell(vec2 np, vec2 cp) {\n  const vec2 offs[4] = vec2[4](vec2(1.,0.), vec2(0.,-1.),vec2(-1.,0.), vec2(0.,1.));\n\n  float dd = 1E3;\n\n  for (int i=0; i < 4; ++i) {\n    vec2 off = offs[i];\n    vec4 cons = connections(np-off);\n    float con = cons[(i+2)%4];\n    float c = dot(cons, vec4(1.));\n    float ddd = circle(cp+(0.3+0.2*con)*off,0.1);\n    float w = 0.05;\n    for (float ii = 0.; ii < c; ++ii) {\n      ddd = abs(ddd)-w;\n      w *= 0.5;\n    }\n\n    dd = min(dd, ddd);\n  }\n\n  return dd;\n}\n#endif\n\n// Draw the \"circuit\" board\nvec3 drawBoard(vec3 col, vec2 p) {\n  const float tz = 2.0/9.0;\n  float aa = sqrt(2.)/RESOLUTION.y;\n  vec2 tp = p/tz;\n  const float ar = 25.;\n  // A smooth moment across the board\n  tp += ar*sin(vec2(sqrt(0.5), 1.0)+100.0+TIME/ar);\n\n  // Computes cell id\n  vec2 np = round(tp);\n  // Computes cell coordinate from (-0.5,-0.5 to (0.5,0.5)\n  vec2 cp = tp - np;\n\n  float d0 = 1E3;\n#ifdef DEBUG\n  float dd = 1E3;\n#endif\n\n  if (fract((np.x + np.y)*0.5) > 0.25) {\n    // Random cells only touches neighboring random cells at their corners.\n    // This means that they cannot influence each other's connections directly,\n    // eliminating the possibility of connection conflicts between them.\n    // The randomness of each cell is determined by its unique cell ID.\n    d0 = randomCell(np, cp);\n#ifdef DEBUG\n    dd = debugRandomCell(np,cp);\n#endif\n  } else {\n#ifndef ONLY_RANDOM_CELLS\n    // Similar to random cells, a fixed cell only touches other fixed cells at their corners.\n    // This means that any neighboring cells that could cause connection conflicts are random cells.\n    // Since the randomness is derived from the cell ID, a fixed cell can peek at its neighbors\n    // by passing the corresponding cell ID.\n    d0 = fixedCell(np, cp);\n#ifdef DEBUG\n    dd = debugFixedCell(np, cp);\n#endif\n#endif\n\n  }\n\n  float d = d0;\n  d *= tz;\n  // Draw the board using white color\n  col = mix(col, vec3(0.8), smoothstep(aa, -aa, d));\n#ifdef DEBUG\n  float d1 = box(cp, vec2(0.5));\n  d1 = abs(d1) - 0.005;\n  dd = min(dd, d1);\n  dd *= tz;\n  // Draw the debugging of board using red color\n  col = mix(col, vec3(0.8, 0.0,0.0), smoothstep(aa, -aa, dd));\n#endif\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = vec3(0.00);\n#ifdef DRAW_ALL_CELLS\n  col = drawAllCells(col, p);\n#else\n  col = drawBoard(col, p);\n#endif\n  col = sqrt(col);\n\n  fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}