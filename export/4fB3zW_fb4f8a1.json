{"ver":"0.1","info":{"id":"4fB3zW","date":"1703945819","viewed":107,"name":"Drunken walk","username":"mrboggieman","description":"A walk across a grid with some randomisation in deciding the next path. Note: not efficient. Click and drag the mouse to control the end point.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["walk"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int max_steps = 5000;\n\nconst float distance_angle_factor = 0.6;\n\nconst float angle_range = PI;\n\n//bell curve from 0-1 so we can get more random paths in the middle\nfloat bell_curve(float t) {\n    return exp(-5.0*pow(2.0*t - 1.0, 2.0));\n}\n\n// START\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 from = ivec2(100, 100);\n    ivec2 to = ivec2(iMouse.xy);//ivec2(iResolution.xy) - ivec2(100);\n\n    //trace a line through the grid until we arrive at the destination\n    ivec2 next = from;\n    float total_distance = distance(vec2(to), vec2(from));\n    \n    for (int i=0; i<max_steps; i++) {\n        vec2 direct_dir = vec2(to) - vec2(next);\n        \n        float distance_factor = bell_curve(length(direct_dir) / total_distance) * distance_angle_factor + 1.0;\n        \n        //perturb the direction vector by a random amount\n        vec2 dir = rotate(direct_dir, rand_between(iTime+float(i), -1.0, 1.0) * distance_factor * (angle_range / 2.0));\n        \n        //decide which neighbour to visit based on which direction is closest\n        float dot_up = dot(dir, up);\n        float dot_down = dot(dir, down);\n        float dot_left = dot(dir, left);\n        float dot_right = dot(dir, right);\n\n        float max_product = max(max(max(dot_up, dot_down), dot_left), dot_right);\n        \n        if (max_product == dot_up) {\n            next.y++;\n        } else if (max_product == dot_down) {\n            next.y--;\n        } else if (max_product == dot_right) {\n            next.x++;\n        } else if (max_product == dot_left) {\n            next.x--;\n        }\n        \n        //since we are already running this for every pixel to shade a pixel for the demo just check this cell\n        if (next == ivec2(fragCoord)) {\n            fragColor = vec4(0.0, 1.0, 0.0, 1.0);\n            return;\n        }\n        \n        //if we have arrived at the destination then we are done\n        if (next == to) {\n            break;\n        }\n    }\n\n    //plot the points\n    if (distance(fragCoord, vec2(from)) < 10.0 || distance(fragCoord, vec2(to)) < 10.0) {\n        fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n        return;\n    }\n    \n    fragColor = vec4(0.0, 0.0, 0.0 ,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI  = 3.14159265358979323846264;\n\nconst vec2 up = vec2(0.0, 1.0);\nconst vec2 down = vec2(0.0, -1.0);\nconst vec2 right = vec2(1.0, 0.0);\nconst vec2 left = vec2(-1.0, 0.0);\n\n// Noise\n// https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nfloat rand(in float n) {\n    return fract(sin(n) * 43758.5453123);\n}\n\nfloat rand(in int n) {\n    return rand(float(n));\n}\n\nfloat rand_between(in float n, in float min_val, in float max_val) {\n    return (rand(n) * (max_val-min_val)) + min_val;\n}\n\n// Angle from pos\nfloat det2(in vec2 a, in vec2 b) {\n    return a.x*b.y - b.x*a.y;\n}\n\nfloat abs_angle(in vec2 a, in vec2 b) {\n    //gives a number from 0 to 2PI in an anti-clockwise rotation from right vec\n    return atan(det2(-a, b), dot(a, -b)) + PI;\n}\n\nvec2 rotate(in vec2 a, in float angle) {\n    return mat2(\n        cos(angle), -sin(angle),\n        sin(angle), cos(angle)\n    ) * a;\n}\n","name":"Common","description":"","type":"common"}]}