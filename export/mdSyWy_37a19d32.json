{"ver":"0.1","info":{"id":"mdSyWy","date":"1688104780","viewed":70,"name":"PageScrollEffect","username":"zjglwt","description":"Page Scroll Effect\nAll directions supported\nEasy to implement in Unreal/Unity\nsee also:\nhttps://www.shadertoy.com/view/XlX3RS","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["uieffect"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float pillarRadius = 0.1;\nconst float pillarAngle = 30.0;  // (0, 360), scroll direction\n\nconst float PI = 3.141592653589793;\n\nvec4 getUnderColor(vec2 point)\n{\n    //background\n    return vec4(0.2);\n}\n\nvec4 getFrontColor(vec2 point)\n{\n    if (point.x < 0.0 || point.y < 0.0\n        || point.x > 1.0 || point.y > 1.0)\n    {\n        return getUnderColor(point);\n    }\n    else\n    {\n        return texture(iChannel0, point);\n    }\n}\n\nvec4 getBackColor(vec2 point)\n{\n    return getFrontColor(point).bgra * 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0;\n    uv -= 0.5;\n    \n    float amount = sin(iTime*0.5)*0.5+0.5;\n    if (iMouse.z>0.) amount = iMouse.y/iResolution.y;\n    \n    float angle = pillarAngle * PI / 180.0;\n    float c = cos(angle);\n    float s = sin(angle);\n    mat2 rotation = mat2(c, -s, s, c);\n    mat2 rrotation = mat2(c, s, -s, c);\n\n\tfloat start = min(min(0.0, -s), min(c, c-s));\n\tfloat end = max(max(0.0, -s), max(c, c-s)) + pillarRadius;\n\n    float pillarCenter = (end - start) * amount + start;\n    float pillarRotAngle = (end - start) * amount / pillarRadius;\n    \n    vec2 point = rotation * uv;\n    float yc = point.y - pillarCenter;\n    \n    if (yc < -pillarRadius)\n    {\n        fragColor = getUnderColor(uv);\n        return;\n    }\n    else if (yc < pillarRadius)\n    {\n        float ycAngle = acos(yc / pillarRadius);\n        float ycUpAngle = PI * 3.0 / 2.0 - ycAngle;\n        if (pillarRotAngle > ycUpAngle)\n        {\n            float backLength = ycUpAngle * pillarRadius;\n            float newY = pillarCenter - backLength;\n            vec2 backPointR = rrotation * vec2(point.x, newY);\n            if (backPointR.x > 0.0 && backPointR.y > 0.0\n            && backPointR.x < 1.0 && backPointR.y < 1.0)\n            {\n                fragColor = getBackColor(backPointR);\n                return;\n            }\n        }\n        \n        if (yc < 0.0)\n        {\n            float ycDownAngle = ycAngle - PI / 2.0;\n            float backLength = ycDownAngle * pillarRadius;\n            float newY = pillarCenter - backLength;\n            vec2 frontPointR = rrotation * vec2(point.x, newY);\n            fragColor = getFrontColor(frontPointR);\n            return;\n        }\n    }\n    \n    fragColor = getFrontColor(uv);\n}","name":"Image","description":"","type":"image"}]}