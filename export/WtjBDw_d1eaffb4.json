{"ver":"0.1","info":{"id":"WtjBDw","date":"1599082402","viewed":108,"name":"Voronoi Cell Tiles","username":"DavidQChuang","description":"Generates a seamlessly repeating square of Voronoi cells with colors based on the index of the closest Voronoi point, using distances that wrap on the x and y axes.\nCreated as a texture generator.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["voronoi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// show red dots at middle of voronoi cells\n//#define SHOW_POINTS\n\n// show grid between tiles\n//#define SHOW_GRID\n\n// tile origin (begins at bottom left)\nvec2 offset = vec2(0.0,0.0);\n\n// extend past one tile\n#define EXTEND\n\n// shades of gray\n#define MONOCHROME\n\n#define MINSHADE 0.6 \n#define MAXSHADE 1.0\n\n#define DIFFSHADE MAXSHADE - MINSHADE\n\n// amount of cells\n#define POINTS 100\n\n// multiplier for how often the texture changes\n#define SPEED 0.2\n\n// width in pixels of voronoi wrapping edge\n#define WIDTH 256.0\n// height in pixels of voronoi wrapping edge\n#define HEIGHT WIDTH\n\n// effects width of grid and cell centers\n#define epsilon 0.005\n\n// rounds cell positions\n#define UNIFORMITY 25.0\n\nfloat wrapDist(vec2 uv1, vec2 uv2){\n    float dx = abs(uv1.x-uv2.x);\n    if (dx > 0.5)\n      dx = 1.0 - dx;\n    \n    float dy = abs(uv1.y-uv2.y);\n    if (dy > 0.5)\n      dy = 1.0 - dy;\n    \n\treturn length(vec2(dx,dy));\n}\n\n#define DISTRIBUTE(uv) (round(UNIFORMITY * uv)/UNIFORMITY)\n\n// returns the index of the closest point.\nint voronoi(vec2 uv){\n    \n    int c;\n       \n    float dist = wrapDist(uv,rand12(float(0)));\n    for(int i = 0; i < POINTS; i++){\n        // add 1.0 so that the rand function doesn't produce all zero output at 0\n        vec2 point = DISTRIBUTE(rand12(float(i) * round(iTime*SPEED + 1.0)));\n        float cDist = wrapDist(uv, point);\n        \n    #ifdef SHOW_POINTS\n        // if showing voronoi points, return -1 if it's close enough to a point.\n        if(cDist < epsilon){\n            c = -1;\n        \tbreak;\n        }\n    #endif\n        if(cDist < dist){\n        \tdist = cDist;\n            c = i;\n        }\n    }\n       \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #ifdef EXTEND\n    vec2 coord = mod(fragCoord - offset, WIDTH);\n    #else\n    vec2 coord = fragCoord - offset;\n    #endif\n    \n    vec2 uv = coord/WIDTH;\n    \n    #ifdef SHOW_GRID\n    \tif(mod(uv, 1.0).x > 1.0 - epsilon || mod(uv, 1.0).x < epsilon ||\n           mod(uv, 1.0).y > 1.0 - epsilon || mod(uv, 1.0).y < epsilon){\n            fragColor = vec4(0.0,1.0,0.0,1.0);\n            return;\n        }\n    #endif\n    \n    \n    float col = float(voronoi(uv));\n    \n    // Output to screen\n    #ifndef MONOCHROME\n        float r = rand11(col);\n        float g = rand11(r);\n        float b = rand11(g);\n\n        fragColor = vec4(r,g,b,1.0);\n    #else \n        col /= float(POINTS);\n    \n    \tcol *= DIFFSHADE;\n    \t\n    \tcol += MINSHADE;\n    \n        fragColor = vec4(col,col,col,1.0);\n    #endif\n            \n    #ifdef SHOW_POINTS\n    if(col < 0.0)\n        fragColor = vec4(1.0,0.0,0.0,1.0);\n    #endif\n    \n    #ifndef EXTEND\n    if(coord.x < offset.x || coord.x > WIDTH + offset.x || coord.y > HEIGHT + offset.y || coord.y <  offset.y){\n        fragColor = vec4(0,0,0,1);\n    }\n    #endif\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float rand11(float x)\n{\n    return fract(sin(x * 35.7313) * 437.5453);\n}\n\nvec2 rand12(float x)\n{\n    vec2 res;\n\n    res.x = rand11(x);\n    res.y = rand11(res.x);\n\n    return res;\n}","name":"Common","description":"","type":"common"}]}