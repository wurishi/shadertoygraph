{"ver":"0.1","info":{"id":"l3lfzf","date":"1728811327","viewed":105,"name":"Interferometry Rendering","username":"rcmz","description":"Rendering by interferometry of a UV sphere made of points\nPinhole camera projection is simulated by the interference of light waves\nUses temporal accumulation to improve performance\nMouse consoles the camera","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["interferometry","pinholecamera"],"hasliked":0,"parentid":"M3sBzf","parentname":"Fork Fork Fork  rcmz 648"},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, vec2 fragCoord) {\n    fragColor.rgb = vec3(pow(texelFetch(iChannel0, ivec2(fragCoord), 0).x, 2.));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, vec2 fragCoord) {\n    int k = int(fragCoord.x) + int(fragCoord.y) * int(iResolution.x);\n    \n    if (k == K) {\n        vec2 previousMouse = texelFetch(iChannel0, ivec2(K, 0), 0).xy;\n        bool mouseMoved = any(notEqual(iMouse.xy, previousMouse));\n        fragColor.xy = iMouse.xy;\n        fragColor.z = mouseMoved ? 1. : 0.;\n        return;\n    }\n    \n    if (k >= K) return;\n    \n    int q = k / (I*J);\n    k = k % (I*J);\n    float j = float(k / I) / float(J);\n    float i = float(k % I) / float(I);\n    \n    vec3 o = vec3(0);\n\n    if (q == 0) {\n        float t = i * pi*2.;\n        float a = j * pi;\n        o = rotMatY(a) * vec3(cos(t), sin(t), 0);\n    } else {\n        if (j == 0.) { fragColor.xyz = vec3(10000); return; }\n        float t = i * pi*2.;\n        float z = j * 2.-1.;\n        float w = sqrt(abs(cos(z * pi/2.)));\n        o = vec3(cos(t) * w, z, sin(t) * w);\n    }\n\n    vec2 c = (iMouse.xy / iResolution.xy) * 2.-1.;\n    o = rotMatX(-c.y) * rotMatY(c.x) * o + vec3(0, 0, 6);\n    \n    fragColor.xyz = o;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float pi = 3.14159265358979;\n\nfloat mapRange(float x, float fromMin, float fromMax, float toMin, float toMax) {\n    return (x - fromMin) / (fromMax - fromMin) * (toMax - toMin) + toMin;\n}\n\nmat3 rotMatX(float a) {\n    return mat3(1, 0, 0, 0, cos(a), sin(a), 0, -sin(a), cos(a));\n}\n\nmat3 rotMatY(float a) {\n    return mat3(cos(a), 0, -sin(a), 0, 1, 0, sin(a), 0, cos(a));\n}\n\nuint randstate;\n\nuint randu() {\n    randstate = randstate * 747796405u + 2891336453u;\n    uint value = ((randstate >> ((randstate >> 28u) + 4u)) ^ randstate) * 277803737u;\n    return (value >> 22u) ^ value;\n}\n\nfloat randf() {\n    return float(randu()) / 4294967296.;\n}\n\nconst int I = 40;\nconst int J = 2;\nconst int K = I * J * 2;\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv * 2.-1.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    const int G = 25;\n    const int H = 50;\n    \n    randstate = uint(fragCoord.x + fragCoord.y * iResolution.x) * 1000000u + uint(iFrame);\n    \n    float l = 0.;\n    \n    for (int g = 0; g < G; g++) {\n        int k = int(randu() % uint(K));\n        vec3 o = texelFetch(iChannel0, ivec2(k, 0), 0).xyz;\n        float z = distance(o, vec3(0));\n        float w = mapRange(z, 5., 7., 1., 0.5);\n\n        for (int h = 0; h < H; h++) {\n            vec3 p = vec3((vec2(randf(), randf()) - 0.5) * 0.001, 0);\n            vec3 s = vec3(uv / 10., -0.4);\n            float d = distance(o, p) + distance(p, s);\n            l += w * sin(d * 1000000.);\n        }\n    }\n    \n    l /= float(G * H) / float(K);\n    \n    //fragColor.x = mix(texelFetch(iChannel1, ivec2(fragCoord), 0).x, l, 0.99);\n\n    \n    vec2 state = texelFetch(iChannel1, ivec2(fragCoord), 0).xy;\n    if (texelFetch(iChannel0, ivec2(K, 0), 0).z == 1.) state.xy = vec2(0);\n    fragColor.x = (state.x * state.y + l) / (state.y + 1.);\n    fragColor.y = state.y + 1.;\n}","name":"Buffer B","description":"","type":"buffer"}]}