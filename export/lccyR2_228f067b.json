{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"/*\n\n    Rhombic Dodecahedral Traversal\n    ------------------------------\n\n    See \"Buffer A\" for an explanation.\n\n*/\n\n/* \n\n// Just a very basic depth of field routine -- I find a lot of it is\n// common sense. Basically, you store the scene distance from the camera \n// in the fourth channel, then use it to determine how blurry you want\n// your image to be at that particular distance.\n//\n// For instance, in this case, I want pixels that are 6.25 units away from \n// the camera to be in focus (not blurred) and for things to get more \n// blurry as you move away from that point -- aptly named the focal point \n// for non camera people. :)\n//\n// I based this on old code of mine, but adopted things that I found in \n// IQ and Nesvi7's examples, which you can find here:\n//\n// Ladybug - IQ\n// https://www.shadertoy.com/view/4tByz3\n//\n// Cube surface II - Nesvi7\n// https://www.shadertoy.com/view/Mty3DV\n//\nvec3 DpthFld(sampler2D iCh, vec2 uv){\n\t\n    // Focal point and circle of confusion.\n    const float focD = 6.5, coc = 2.;\n    // Linear distance from either side of the focal point.\n    float l = abs(texture(iCh, uv).w - focD) - coc;\n    // Using it to calculate the DOF.\n    float dof = clamp(l/coc, 0., 2.)*2.; \n    \n    // Combine samples. Samples with a larger DOF value are taken further \n    // away from the original point, and as such appear blurrier.\n    vec3 acc = vec3(0);\n\n    for(int i = 0; i<25; i++){\n        // Accumulate samples.\n        acc += texture(iCh, uv + (vec2(i/5, i%5) - 2.)/iResolution.y*dof).xyz;\n        //acc.x *= dof/2.;\n    }\n\n    // Return the new variably blurred value.\n    return acc /= 25.;\n    // Visual debug representation of DOF value.\n    //return vec3(length(dof)*450./2.5);\n}\n\n*/ \n\n// Standard 2D rotation formula.\n//mat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's float to float hash. I've added an extra sine wrapping modulo to\n// cater for my annoying AMD based system, which can't wrap sine with a \n// proper degree of accuracy.\nfloat hash11B(float x){ return fract(sin(mod(x, 6.2831853))*43758.5453); }\n\n// This is an amalgamation of old blur and DOF functions with a heap of borrowed \n// lines from Dave Hoskins's much nicer Fibonacci based \"Bokeh disc\" function, which \n// you can find here: https://www.shadertoy.com/view/4d2Xzw\n//\n// If you're interested in bokeh, Dave's function above and some of Shadertoy user, \n// Hornet's, are probably the ones you should be looking at. Xor has some cool simple \n// ones on here too.\n//\nvec4 bokeh(sampler2D iCh, vec2 uv){\n\n\n    // UV based DOF. Focused on the horizontal line, then blurring further away.\n    //float r = smoothstep(0., 1., abs(uv.y - .57)/.57)*2.;\n    // Focal point and circle of confusion.\n    const float focD = 6.5, coc = 2.;\n    // Linear distance from either side of the focal point.\n    float l = abs(texture(iCh, uv).w - focD) - coc;\n    // Using it to calculate the DOF.\n    float ra = clamp(l/coc, 0., 2.);\n    //float ra = smoothstep(.1, .9, abs(uv.y - .5)*2.)*2.;\n    //float ra = mix(clamp(l/coc, 0., 2.), smoothstep(.3, 1., abs(uv.y - .5)*2.), .25);\n    //float ra = (smoothstep(.2, 1., length(uv - .5)));\n\n    // Standard Fibonacci distribution calculations, compliments of Dave Hoskins.\n    const int iter = 96;\n    float rad = 1.6;//max(2.*ra, .5); // Bokeh radius.\n    float r = 1.;\n\tvec4 tot = vec4(0), div = tot;\n    vec2 vangle = vec2(0., rad*.01/sqrt(float(iter)));\n    #define GA 2.3999632 // Golden angle.\n    const mat2 rot = mat2(cos(GA), sin(GA), -sin(GA), cos(GA));\n\n    // Aspect ratio.\n    vec2 aspect = vec2(iResolution.y/iResolution.x, 1);\n    // Trying to reduce the sample spread at larger resolutions.\n    //if(iResolution.y>450.) aspect *= mix(iResolution.y, 450., .5)/iResolution.y;\n    \n    \n\tfor (int i = 0; i<iter; i++){\n        \n        #if 1\n        \n        // Dave Hoskin's Fibonacci based scattering. Cheaper and much nicer, so\n        // it's set as the default.\n        // The approx increase in the scale of sqrt(0, 1, 2, 3...).\n        r += 1./r;\n\t    vangle = rot*vangle;\n        vec4 col = texture(iCh, uv - (r - 1.)*vangle*aspect, iResolution.y/450.*1.5); \n        \n        #else\n        \n        // A hash based random distribution, for anyone who wants to try it.\n        //int ii = i%10; // For square bokeh.\n        //int jj = i/10;\n    \n        // Random offset contained within a disk or radius n.\n        float fi = float(i) + fract(iTime);\n        //vec2 fi = vec2(ii, jj) - 5. + fract(iTime);\n        vec2 rnd2 = vec2(hash11B(fi), hash11B(fi + .1)*6.2831);\n        vec2 offs = 6.*sqrt(rnd2.x)*vec2(cos(rnd2.y), sin(rnd2.y));\n        ////////\n        /*\n        // Polygons, if desired. Comment out the line above and comment in\n        // the \"rot2\" formula above, if using it.\n        const float N = 6.;\n        float ra = rnd2.y;\n        float a = (floor(ra*N) + .5)*6.2831859/N;\n        vec2 offs  = mix(rot2(a)*vec2(0, 1), rot2(a + 6.2831859/N)*vec2(0, 1), fract(ra*N));\n        offs *= 6.*sqrt(rnd2.x);\n        */\n        ////////\n        offs *= rad;\n        //offs = rad*(offs + (vec2(hash11B(fi), hash11B(fi + .21)) - .5));\n        vec4 col = texture(iCh, uv - offs/iResolution.xy, iResolution.y/450.*1.5);  \n  \n        #endif\n         \n        // Thanks to Dave for figuring out how to tweak the colors to produce brighter \n        // contrast. It's common sense... once someone figures it out for you. :D \n        vec4 bokeh = pow(col, vec4(4));\n\t\ttot += bokeh*col*col;\n\t\tdiv += bokeh;\n        \n\t}\n    \n    \n    // Mixing the original value with the bokeh tweaked value according\n    // to the depth of field.\n    vec4 colOrig = texture(iCh, uv);\n    // Not entirely correct, but no one will notice here. :)\n\treturn mix(colOrig, colOrig*.25 + tot/div*4., ra);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n\n    // Screen oordinates.\n    vec2 uv = fragCoord/iResolution.xy;\n\n\n    // Retrieving the stored color.\n    //vec4 col = texture(iChannel0, uv);\n\n    // Depth of field.\n    //vec4 col = DpthFld(iChannel0, uv).xyzz;\n \n    // Bokeh function.\n    vec4 col = bokeh(iChannel0, uv);\n    \n    /*\n    // Hardware bloom that I made up on the spot. It's\n    // not as nice as software bloom, but it's way cheaper\n    // and definitely easier to implement.\n    //col = vec4(0);\n    float a = 0., w = 1.;\n    for (int i = 1; i<6; i++){\n        col += texture(iChannel0, uv, float(i))*w;\n        a += w;\n        w *= .7071;\n    }\n    col /= a;\n    */ \n \n\n    // Rough Reinhard tone mapping.\n    //col /= 1. + col/2.5;\n    \n    // Subtle vignette.\n    //col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , 1./16.);\n\n    // Rough gamma correction and screen presentation.\n    fragColor = pow(max(col, 0.), vec4(1./2.2)); \n    \n}\n\n","name":"Image","description":"","type":"image"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"texture","id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"cubemap","id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"/*\n\n    Rhombic Dodecahedral Traversal\n    ------------------------------\n    \n    Traversing a rhombic dodecahedon field. There are already a few\n    examples on Shadertoy, but I like this particular 3D polyhedral \n    packing, so wanted to post one. I started this way too long ago, \n    but was inspired to complete it after looking at Gelami's really\n    nice rhombic dodecahedral traversal efforts. The dark tones with \n    colorfully lit block material scheme directly influenced the \n    aesthetics here.\n     \n    This differs from other examples in the sense that it's a raymarched \n    traversal, but packed polyhedral examples tend to be the same. In \n    particular, you determine the best way in which the 3D objects pack \n    togther, then perform a ray to object intersection in order to jump \n    the ray from cell to cell.    \n    \n    Rhombic dodecahedrons pack together in a very similar way to which\n    hexagons fit together in a 2D grid. Hexagon grids consist of two\n    overlapping rectangle grids spaced out by a half cell, whereas a \n    rhombic dodecahedral grid consists of two overlapping cuboid grids\n    spaced out by half a cell dimension.\n    \n    A 2D hexagon traversal involves additionl ray to polygon edge \n    intersections, and a rhombic dodecahedral traversal involves ray\n    to polyhedron wall intersections... It's all very similar, but you'd\n    probably want to become acquainted with the 2D traversal first. :)\n    \n    The traveral and intersection code itself was written from scratch\n    some time ago, so I don't know how it compares to other methods on \n    here, but it feels reasonably efficient, if that counts. :D For all \n    I know, there might be some really cool skewed grid method out \n    there that I'm not aware of that is faster and more elegant. \n    \n    I'm aware that the code is drawn out. However, the raymarched \n    traversal itself is pretty straight forward. At some stage, I'll \n    post a much, much simpler version. I'll also make a few changes here\n    to increase the frame rate a bit.\n    \n    I've provided links to examples below. All, including mine, have\n    similar names. I guess there are only so many ways in which you can\n    name a popular generic process. :)\n    \n    \n    \n    Other examples:\n    \n    // Awesome visuals, and the inspiration for the color scheme I'm\n    // using. It also runs faster on account of the fact that it's a\n    // straight up traversal... and, more than likely, coded better. :D\n    Rhombic Dodecahedron Traversal - gelami\n    https://www.shadertoy.com/view/mlK3DD\n    \n    // I've always admired this shader. Cleverly written too.\n    Packed Spheres SDF - blackle\n    https://www.shadertoy.com/view/3djBDh\n    \n    // A really nice straight forward traversal.\n    Rhombic Dodecahedral Honeycomb - Polygon\n    https://www.shadertoy.com/view/tl2BD3\n    \n    // If you're not sure how rhombic dodecahedrons pack together,\n    // this is definitely the best way to understand it.\n    rhombic dodecahedra offset grids - jt\n    https://www.shadertoy.com/view/mlfczN\n    \n    // I think Spalmer may have taken a neighbor approach, which\n    // comes in handy when requiring neighbor information. I'll be\n    // consulting it when making a more difficult variation.\n    Rhombic Dodecahedron Voxels - spalmer\n    https://www.shadertoy.com/view/WdXBR8\n \n\n*/\n\n\nvec4 gObjD;\n \n// Maximum ray distance.\n#define FAR  15.\n\n// Global cell scale. Values of about \"1./2.\" to \"1./6\" work, \n// but it's designed to work with the currect value.\nvec3 GSCALE = vec3(1, sqrt(2.), 1)/2.;\n\n// Light type: Point: 0, Direct: 1\n#define LIGHT_TYPE 0\n\n// Square holes, or round holes. I forgot to include the \n// no hole version, but I'll code that in later.\n#define SQUARE_HOLES\n\n \n\n//////////////\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\n \n// Tri-Planar blending function: Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D tex, in vec3 p, in vec3 n){    \n    \n    // Ryan Geiss effectively multiplies the first line by 7. It took me a while to realize that \n    // it's largely redundant, due to the division process that follows. I'd never noticed on \n    // account of the fact that I'm not in the habit of questioning stuff written by Ryan Geiss. :)\n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n); \n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n/*\n// 3D texture lookup. Sometimes faster.\nfloat hash31(vec3 f){\n \n    return texture(iChannel2, f/32.).x;\n}\n*/\n\n// IQ's \"uint\" based uvec3 to float hash with Fabrice's modification.\nfloat hash31(vec3 f){\n\n   \n    uvec3 p = floatBitsToUint(f);\n    p = 1664525U*((p >> 2U)^(p.yzx>>1U)^p.zxy);\n    uint h32 = 1103515245U*(((p.x)^(p.y>>3U))^(p.z>>6U));\n\n    uint n = h32^(h32 >> 16);\n    return float(n & uint(0x7fffffffU))/float(0x7fffffff);\n    \n}\n\n\n// Texture sample.\n//\nvec3 getTex(sampler2D iCh, vec2 p){\n    \n    // Strething things out so that the image fills up the window. You don't need to,\n    // but this looks better. I think the original video is in the oldschool 4 to 3\n    // format, whereas the canvas is along the order of 16 to 9, which we're used to.\n    // If using repeat textures, you'd comment the first line out.\n    //p *= vec2(iResolution.y/iResolution.x, 1);\n    vec3 tx = texture(iCh, p/8.).xyz;\n    return tx*tx; // Rough sRGB to linear conversion.\n}\n\n\n\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, \n// and amplitudes.\nvec2 path(in float z){ \n\n    //return vec2(0);\n    float s = sin(z/9.);\n    float c = cos(z/13.); \n    return vec2(s*c*8., (s + c)*4.); \n}\n\n// Height map value.\nfloat hm(in vec3 p){ \n\n    // This is a very basic 3D surface with a camera-path directed tunnel\n    // carved out of it. Pretty standard for tunnels.\n    vec2 pth = path(p.z);\n    float h = (dot(sin(p - cos(p.yzx*2.)), vec3(1./6.)) + .5)*8. - 0.;\n    \n    // Carving out the tunnel.\n    h = max(h, -(length(p.xy - pth) - 5.5));\n    return h; // floor(h/GSCALE.y)*GSCALE.y;\n\n \n}\n\nvec3 getCol(vec3 id){\n\n    vec3 col = .5 + .45*cos(6.2831*hash31(id + .12)/12. + vec3(0, 1, 2)*1.6 + 3.35);\n    \n    // Leftover effect from another shader. Interesting... but I'll pass. :)\n    //id = floor(id/2.);\n    //if(mod(id.x + id.y + id.z, 2.)<.5) col = col.zxy;\n      \n    return col;\n}\n\n\n\n// Rhombic dodecahedron, edges and face centers: I put this together\n// without much of a plan, so there'd definitely be better ways to \n// achieve the same. The logic is all over the place, so I wouldn't\n// pay too much attention to it. Normally, you'd just render the main\n// shape, which is just a few lines.\n//\nvec2 rhomDodeca(vec3 p, vec3 sc, int type){\n\n    // Construction vectors: It's probably helpful to look at a \n    // rhombic dodecahedron with labelled vertices and so forth.\n    const vec3 v0 = normalize(vec3(0, 1, 1));\n    const vec3 v1 = normalize(vec3(1, 0, 1));\n    const vec3 v2 = normalize(vec3(1, 1, 0));\n    \n    const vec3 v00 = vec3(1, 0, 0);\n    const vec3 v11 = vec3(0, 1, 0);\n    const vec3 v22 = vec3(0, 0, 1);\n  \n    // The rhombic dodecahedron is rotated inside the cuboid \n    // about the XZ axis by 45 degrees to fit into it nicely. \n    // I'll attempt to get rid of this at some stage.\n    const float a = sqrt(.5);\n    const mat2 m2 = mat2(a, a, -a, a);// rot2(3.14159265/4.);\n    p.xz *= m2;\n    // Taking advantage of the polyhedron's symmetry. Doing this\n    // allows us to render a few sides at once. You use a similar\n    // trick when rendering cuboids, etc.\n    p = abs(p);\n   \n    float r = sc.x*.5;\n    //float r2 = r/sqrt(2.);\n    \n    // Mid face points distance.\n    float face;\n    \n   \n    #ifndef SQUARE_HOLES\n    face = min(min(length(p - v0*r), length(p - v1*r)), \n                     length(p - v2*r));\n    face -= sc.x*.1;\n    #endif\n    \n    // Rhombic dodecahedron plane distances. Relying on\n    // mirroring, which is possible on account of the\n    // object's symmetry.\n    vec3 d3 = vec3(dot(p, v0), dot(p, v1), dot(p, v2));\n    \n    // Rhombic dodecahedron.\n    float d;\n    \n    // Edge lines.\n    vec3 e3 = vec3(max(d3.x, d3.y), max(d3.y, d3.z), max(d3.z, d3.x)) - r;\n    \n    \n    #ifdef SQUARE_HOLES\n    if(type==0){\n       // Thick edges, or holes carved out, depending on your take.\n       e3 = abs(e3 + .05) - .05;\n       d = max(max(e3.x, e3.y), e3.z); \n       face = 1e5;\n    }\n    else {\n       // The colored cubes aren't transparent, but they're designed\n       // to look that way.\n       d = max(max(d3.x, d3.y), d3.z) - r; \n       e3 = abs(e3 + .05) - .05;\n       // The main polyhedron husk with edges taken away, make 12\n       // squarish dots for each face... After a bit of confusion, I\n       // was able to figure that out.\n       face = max(abs(d + .05) - .05, -max(max(e3.x, e3.y), e3.z) + .01);\n       d = max(max(e3.x, e3.y), e3.z); \n    }\n    #else\n    d = max(max(d3.x, d3.y), d3.z) - r; \n    #endif\n   \n    // Edges.\n    e3 = abs(e3);\n    float edge = max(max(e3.x, e3.y), e3.z) - .005;\n  \n  \n    //if(type==0) edge = min(edge, max(-d, abs(face)) - .005); // Adding the face line to the edge. \n    //else edge = min(edge, abs(face) - .005); // Adding the face cup to the edge.\n    edge = min(edge, abs(face) - .005); // Adding the face cup to the edge.\n       \n    \n    d = max(d, -face); // Carving out the face point.\n \n    return vec2(d, edge);\n    \n}\n\n// The rhombic dodecahedron grid: The objects fit into two overlapping cuboid \n// grids (of dimension vec3(1, sqrt(2.), 1)*scale) that are spaced out by half \n// a dimension. Produce them then determine the closest one. Hexagons are \n// calculated in very similar fashion.\n//\n// I could group a lot of this and make it much faster, but I'll leave it as\n// is for readability sake.\nvec3 getGrid(inout vec3 p, inout vec3 sc){    \n\n    // Coordinate copy.\n    vec3 oP = p;\n    \n    // First grid. ID and local coordinates.\n    vec3 ip = floor(p/sc) + .5;\n    p -= ip*sc;\n    float d = dot(p, p); // Distance.\n    vec3 id = ip;        // Position based ID.\n    vec3 gP = p;         // Local coordinates.\n    \n    // Second grid. ID and local coordinates.\n    p = oP - .5*sc;\n    ip = floor(p/sc) + .5;\n    p -= ip*sc;\n    float d2 = dot(p, p);\n    \n    // Determine the closest and update the \n    // ID and local coordinates if necessary.\n    if(d2<d){\n       d = d2;\n       id = ip + .5;\n       gP = p;\n    \n    }\n    \n    // Update the local coordinates. \n    p = gP;\n    \n    // Return the position based ID.\n    return id;\n    \n    \n}\n\n\n// Plane function.\nfloat plane(vec3 p, vec3 n, float d){ return dot(p, n) + d; }\n\n// Ray origin, ray direction, point on the line, normal. \nfloat rayLine(vec3 ro, vec3 rd, vec3 p, vec3 n){\n   \n   // This it trimmed down, and can be trimmed down more. Note that \n   // \"1./dot(rd, n)\" can be precalculated outside the loop.\n   //return dot(p - ro, n)/dot(rd, n);\n   float dn = dot(rd, n);\n   return dn>0.? dot(p - ro, n)/dn : 1e8;   \n\n} \n\nvec3 lp, ld;\n\n// Global cell boundary distance variables.\nvec3 gDir; // Cell traversing direction.\nvec3 gRd; // Ray direction.\nfloat gCD; // Cell boundary distance.\n// Box dimension and local XY coordinates.\nvec3 gSc; \nvec3 gP;\nvec4 gID;\n\n\n// A simple glow variable.\nvec3 glow;\n\nfloat map(vec3 q3) {\n\n\n    // Floor. Redundant here.\n    vec2 pth = path(q3.z);\n    float fl = q3.y + 1.5 - pth.y;\n \n \n    vec3 sc = GSCALE; // Scale.\n    // Local coordinates and cell ID.\n    vec3 p = q3;\n    vec3 p3 = getGrid(p, sc); \n  \n    vec3 id = p3;\n      \n    \n    // CELL INTERSECTION.\n    \n    \n    // The 3D equivalent of the following.\n    const float a = sqrt(.5);\n    // const mat2 m2 = mat2(a, a, -a, a);// rot2(3.14159265/4.);\n    const mat3 m3 = mat3(a, 0, a, 0, 1, 0, -a, 0, a);\n\n    // Vector directions and normals to the object's planes...\n    // In this case, it's half of all 12 planes, since we intend \n    // to take advantage of the object's symmetrical nature to \n    // double up on some intersection calculations.\n    //\n    // By the way, I vaguely recall that it's possible to cut this \n    // down to three or even two checks by using some step trickery \n    // on the direction ray... which I'll attempt later, but not now. :)\n    //\n    // The rhombic dodecahedron is rotated inside the cuboid about \n    // the XZ axis by 45 degrees to fit into it properly. Hence, the\n    // \"m3\" rotation. \n    const vec3[6] fP = vec3[6](\n\n        m3*vec3(0, 1, 1), m3*vec3(0, -1, 1), m3*vec3(1, 0, 1),\n        m3*vec3(-1, 0, 1), m3*vec3(1, 1, 0), m3*vec3(-1, 1, 0)\n    );\n\n    // Maximize the ray distance.\n    float t = 1e8;\n\n    // You could calculate the field distance to the object\n    // inside the following loop, but we'll use other methods.\n    //float rh2 = -1e5; \n    \n\n    for(int i = 0; i<6; i++){\n\n         vec3 fR = fP[i];\n      \n        // Using a traversal trick for symmetric objects. In particular\n        // reversing the point direction if the ray is heading in the\n        // opposite direction. This cuts down calculations from 12\n        // to six in this case, which is pretty helpful inside a \n        // raymarching loop.\n        fR = dot(gRd, fR)<0.? -fR : fR;\n        \n        // Distance to the cell wall of the plane in the direction of\n        // the ray.\n        //\n        // Ray origin, ray direction, point on the line, normal. \n        float ti = rayLine(p, gRd, fR*sc.x/2./sqrt(2.), normalize(fR));\n        // Record the minimum distance.\n        t = min(ti, t);\n\n        // Object field distance... Not to be confused with the\n        // directional ray to cell wall intersection above.\n        //rh2 = max(rh2, -plane(p, normalize(fR), sc.x/2.));\n    }\n\n\n    // Distance to the next cell in the direction of the ray.\n    gCD = max(t, 0.) + .0015;\n\n\n    // RAYMARCHING.\n    \n    \n    // The rhombic dodecahedron, or something similar that fits into\n    // the cell space.\n    float d = 1e5;\n \n    // A thin frame that encased the object above.\n    float dFrame = 1e5;\n   \n    // Block type. Opaque, or faux transparent.\n    int type = hash31(id + .22)<.9? 0 : 1;\n\n   \n    // The 3D field value.\n    float h = hm(id*sc);\n    \n    // Using the field value to perturb the floor a little.\n    fl += h*.1;\n    //fl = 1e5; // Taking the floor out.\n  \n\n    // Floor height, if you wich to replace the floor with\n    // blocks for a purer voxel aesthetic.\n    //float flH = id.y*sc.y - path(id.z*sc.z).y + 1.5;\n    \n    // Render blocks for anything under the field value threshold.\n    if(h<4.){\n    // Taking out the raymarched floor, if you're strickly voxel. :)\n    //if(h<4.|| flH<0.){ \n\n\n        // Rouding factor: Between zero and one, \n        // but things like \".05\" make more sense.\n\n        vec2 vrh = rhomDodeca(p, sc - .0, type);\n        //float rh = rhomDodeca(p, sc - .025, .2);//sBoxS(p, sc/2. - .0, 0.);\n        //float rh = length(p) - sc.x/2.;\n        d = vrh.x + .005 + .0015;\n        \n        // The thin frame that encases the object.\n        dFrame = vrh.y - .005 + .0015;\n \n    }\n       \n\n    \n   \n\n    // Add some gradient glow to faux transparent blocks.\n    if(h<4. && type==1){\n        //float dd = d;\n        vec3 oCol = getCol(id);\n        float dd = length(p);//length(q3 - id*sc);\n        \n        // Glow color.\n        // Sometimes, \"pow(vec3(2.71828), x)\" can be faster than \"exp(x)\".\n        // I'm not sure why.\n        // The exponential stuff related to Beer's law. It's fake in this\n        // context, but adds a bit of refractive color variation.\n        oCol = exp(-oCol*(dd - d)*18.); \n        oCol = oCol*(1. - oCol);\n        // Adding the glow.\n        glow += oCol/(.1 + dd*dd*4.);//max(1. - dd, 0.);  \n        \n        d = 1e5;\n    } \n     \n    \n    \n    // Saving the object dimensions, local coordinates and ID.\n    gSc = sc; \n    gP = p;\n    gID = vec4(1e5, id);\n    \n    // Saving the individual distance fields for sorting later.\n    // Sorting things inside the loop can sometimes be more costly.\n    // Not always, but with lots of objects, it usually is.\n    gObjD = vec4(fl, d, dFrame, 1e5);\n \n \n    // Scene distance.\n    return min(fl, min(d, dFrame));\n}\n\n\nfloat gEdge;\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n    \n    float d, t = hash31(ro + rd)*.25; // Glow jitter.\n    //const float tol = TOLERANCE;\n    vec2 dt = vec2(1e8, 0); // IQ's edge desparkle trick.\n\n\n    // Set the global ray direction varibles -- Used to calculate\n    // the cell boundary distance inside the \"map\" function.\n    gDir = step(0., rd) - .5; // sign(rd)*.5;\n    gRd = rd;\n    \n    #define EDGE_THICKNESS .03\n    gEdge = 1.;\n    float edgeLength = 1.;//1e5;\n    \n    // Initialize the glow to zero.\n    glow = vec3(0);\n\n    const int iter = 128;\n    int i = 0;\n     \n    for (i = 0; i<iter; i++) {\n       \n        d = map(ro + rd*t);\n        \n \n            \n        //if(edgeLength<EDGE_THICKNESS && d>edgeLength) gEdge = edgeLength;\n        //edgeLength = min(d, edgeLength);\n\n        \n        // IQ's clever edge desparkle trick. :)\n        if (d<dt.x) { dt = vec2(d, t); } \n\n        if (d<.001 || t > FAR) {\n            break;\n        }\n        \n    \n        t += min(d*.9, gCD);//min(min(d*.9, gCD), .1);\n    }\n    \n    if(i == iter - 1) { t = dt.y; }\n\n\n    return min(t, FAR);\n}\n\nfloat softShadow(in vec3 p, in vec3 ld, in float lDist, in float k) {\n    \n    float res = 1.;\n    float t = 0.;\n\n    // Set the global ray direction varibles -- Used to calculate\n    // the cell boundary distance inside the \"map\" function.\n    gDir = step(0., ld) - .5;\n    gRd = ld; \n\n    for (int i=0; i<64; i++){\n\n        float d = map(p + ld*t);\n        res = min(res, k*d/t);\n        if (d<0. || t>lDist) break;\n\n        t += clamp(min(d*.9, gCD), .01, .25);\n    }\n    return clamp(res, 0., 1.);\n}\n\n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 normal(in vec3 p) {\n\t\n    //return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map\n    //                      map(p + e.yxy) - map(p - e.yxy),\t\n    //                      map(p + e.yyx) - map(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    vec3 e = vec3(.002, 0, 0), mp = e.zzz; // Spalmer's clever zeroing.\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp.x += map(p + sgn*e)*sgn;\n        sgn = -sgn;\n        if((i&1)==1){ mp = mp.yzx; e = e.zxy; }\n    }\n    \n    return normalize(mp);\n}\n\n// A slight variation on a function from Nimitz's hash collection, here: \n// Quality hashes collection WebGL2 - https://www.shadertoy.com/view/Xt3cDn\nvec2 hash23(vec3 f){\n\n    uvec3 p = floatBitsToUint(f);\n    p = 1103515245U*((p >> 2U)^(p.yzx>>1U)^p.zxy);\n    uint h32 = 1103515245U*(((p.x)^(p.y>>3U))^(p.z>>6U));\n\n    uint n = h32^(h32>>16);\n\n    uvec2 rz = uvec2(n, n*48271U);\n    // Standard uvec2 to vec2 conversion with wrapping and normalizing.\n    return vec2((rz>>1)&uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\n \n// A nice random hemispherical routine taken out of one of IQ's examples.\n// The routine itself was written by Fizzer.\nvec3 cosDir(in vec3 p, in vec3 n){\n\n    vec2 rnd = hash23(p);\n    float u = rnd.x;\n    float v = rnd.y;\n    \n    // Method 1 and 2 first generate a frame of reference to use with an arbitrary\n    // distribution, cosine in this case. Method 3 (invented by fizzer) specializes \n    // the whole math to the cosine distribution and simplfies the result to a more \n    // compact version that does not depend on a full frame of reference.\n\n    // Method by fizzer: http://www.amietia.com/lambertnotangent.html\n    float a = 6.2831853*v;\n    u = 2.*u - 1.;\n    return normalize(n + vec3(sqrt(1. - u*u)*vec2(cos(a), sin(a)), u));\n    \n}\n\n \n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n \n\tfloat sca = 2., occ = 0.;\n    for(int i = 0; i<12; i++){\n    \n        float hr = (float(i) + 1.)*.35/12.; \n        //float fi = float(i + 1);\n        //vec3 rnd = vec3(hash31(p + fi), hash31(p + fi + .1), hash31(p + fi + .3)) - .5;\n        //vec3 rn = normalize(n + rnd*.15);\n        vec3 rn = cosDir(p + n*hr, n); // Random half hemisphere vector.\n        float d = map(p + rn*hr);\n        \n        occ = occ + max(hr - d, 0.)*sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);    \n    \n}\n \n/*\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 2., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        \n        // Deliberately redundant line that may or may not stop the \n        // compiler from unrolling.\n        //if(sca>1e5) break;\n    }\n    \n    return clamp(1. - occ, 0., 1.);\n}\n*/\n\t\n\n\nfloat lDist;\nfloat t0;\nfloat objRefF;\n\nvec2 svUV;\n\nvec4 render(inout vec3 ro, inout vec3 rd, int iter){\n\n    \n    // Surface distance.\n    float t = rayMarch(ro, rd);\n    \n    // Saving the first pass hit distance for things like fog, and so forth.\n    if(iter==0) t0 = t;\n\n    // Saving the global scale, local cell coorinates and cell ID.\n    vec3 svSc = gSc;\n    vec3 svP = gP;\n    vec4 svGID = gID;\n    \n    \n    // Object ID: The block, the block frame and the floor.\n    int objID = gObjD.x<gObjD.y && gObjD.x<gObjD.z? 0 : gObjD.y<gObjD.z? 1 : 2;\n    \n    \n    float svEdge = (gEdge);\n    \n    vec3 svGlow = glow;\n    \n    vec3 gAtt = vec3(0);\n\n    // Initializing.\n    vec3 fog = vec3(1.2, .48, .3); // Background fog.\n    vec3 col = fog;\n    \n    // Position.\n    vec3 p = ro + rd*t;\n   \n    if (t < FAR){\n  \n        // Normal.\n        vec3 n = normal(p);\n        \n        // Light: Point or directional. The directional light\n        // doesn't really belong in this particular dark cavernous\n        // setting, but it's there anyway.\n        #if LIGHT_TYPE == 0\n        ld = lp - p;\n        lDist = length(ld);\n        ld /= lDist;\n        #else\n        lDist = FAR;\n        #endif\n        \n         \n        // Shadow and ambient occlusion.\n        float shd = softShadow(p + n*.0015, ld, lDist, 8.);\n        float ao = calcAO(p, n);\n        \n \n        // Block ID and corresponding height.\n        vec3 id = svGID.yzw;\n     \n\n    \n        // Polyhedral color. \n        vec3 oCol = getCol(id);\n        oCol = exp(-oCol*length(svP)*18.);\n        oCol = oCol*(1. - oCol)*4.;\n \n        // Object reflectance variables for multipasses. I'm pretty sure\n        // they're not used here, but I'll leave them in, just in case. :)\n        objRefF = 1.;\n        //float lD = length(p - id*gSc);\n        //gAtt = oCol/(.01 + lD*.2);\n        \n        // Darkening about 90 percent of the polyhedral blocks.\n        if(hash31(id + .22)<.9 && objID!=0){\n        \n           oCol = vec3(.15)*dot(oCol, vec3(.299, .587, .114));\n           objRefF = 0.; //hash31(id + .32)*.25;\n           gAtt *= 0.;\n         \n        }\n        \n        // Darkening the raymarched edge strip object... I should probably\n        // find a way to take the edges out of the raymarhing loop to speed\n        // things up, but it's easier like this for now.\n        if(objID==2) oCol = vec3(.02)*dot(oCol, vec3(.299, .587, .114)); \n        \n        if(objID==0){ \n        \n            // Floor.\n        \n            oCol = vec3(.025)*dot(oCol, vec3(.299, .587, .114)) + .025;  \n            objRefF = .5; \n            gAtt *= 0.; \n        }\n        \n     \n        // Texture coordinates.\n        vec3 tx = tex3D(iChannel0, p/2. + .5, n);\n        \n\n\n        float difSt = .5;\n        // Diffuse value.\n        float dif = max(dot(ld, n), 0.);\n        //dif = pow(dif, 2. + 2.*tx.x); // Diffusivity based on texture.\n        \n        // Specular value.\n        float spe = pow(max(dot(reflect(ld, n), rd), 0.), 16.);\n\n  \n    \n        //oCol += gAtt/8.;//\n        \n        // Subtle texture color.\n        oCol *= tx*3. + .1;\n        \n        \n        /*\n        // Dark rhombic dodecahedron edges.\n        // Block type. Opaque, or faux transparent.\n        int type = hash31(id + .22)<.9? 0 : 1;\n\n        vec2 vrh = rhomDodeca(svP, gSc, type);\n        float frame = vrh.y;// + .0015;\n        oCol = mix(oCol, vec3(0), 1. - smoothstep(0., .01, frame));\n        */\n    \n      \n       \n        // Cheap specular reflections.\n        float speR = pow(max(dot(normalize(ld - rd), n), 0.), 5.);\n        vec3 rf = reflect(rd, n); // Surface reflection.\n        vec3 rTx = texture(iChannel1, rf).xyz; rTx *= rTx;\n        oCol += oCol*speR*rTx*2.;\n        \n        \n       \n        \n        // I wanted to use a little more than a constant for ambient light this \n        // time around, but without having to resort to sophisticated methods, then I\n        // remembered Blackle's example, here:\n        // Quick Lighting Tech - blackle\n        // https://www.shadertoy.com/view/ttGfz1\n        //\n        // Studio.\n        float am = pow(length(sin((n)*3.14159/4.)*.5 + .5)/sqrt(3.), 2.)*1.5; \n        // Outdoor.\n        //float am = length(sin(sn*2.)*.5 + .5)/sqrt(3.)*smoothstep(-1., 1., -sn.z); \n        \n\n\n        // Lit color.\n        col = oCol*(am + dif*shd + vec3(1, .7, .4)*spe*shd*4.)*ao;\n        \n\n \n        // Applying the edges to the prism.\n        //col = mix(col, col*.05, 1. - smoothstep(0., .005, objEdge));\n        //objRefF = mix(objRefF, 0., 1. - smoothstep(0., .005, objEdge));\n       \n\n\n        // Light attenuation. Barely visible, but it's there\n        float rt = t/FAR;\n        col *= 1.5/(1. + rt*.2); \n        \n        \n        ro = p + n*.0015;\n        rd = reflect(rd, n);\n\n    }\n    \n    svGlow = mix(svGlow.xzy, svGlow, smoothstep(.2, .8, svUV.y + .5));\n   \n    \n    col += svGlow/16.;\n    //fog = exp(-fog*t/FAR/1.5); fog = fog*(1. - fog)*3.;\n    fog = mix(fog.xzy, fog, smoothstep(.2, .8, svUV.y + .5));\n    \n    // Fog.\n    col = mix(col, fog, smoothstep(.3, .99, t0/FAR));\n    \n     //    col = mix(col.xzy, col, smoothstep(.2, .8, svUV.y + .5));\n       \n    // Returning the final color for this pass... There's only one\n    // pass here, but a render function is useful when you want to\n    // bounce light around.\n    return vec4(col, t0);\n  \n}\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n \n    // Coordinates.\n    vec2 u = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    svUV = u;\n    \n    vec3 lSc = GSCALE;\n    // Look vector and camera origin.\n    vec3 lk = vec3(0, -.6, iTime*2.);\n    vec3 ro = lk + vec3(0, 0, -2.5);\n    \n    \n    #if LIGHT_TYPE == 0\n    lp = ro + vec3(0, 0, 4);\n    lp.xy += path(lp.z);\n    #else\n    ld = normalize(vec3(0, 4, 4));\n    lDist = FAR;\n    #endif\n    \n    lk.xy += path(lk.z);\n\tro.xy += path(ro.z);\n \n    // Setting up a camera using the usual process. The variable names\n    // here suggest that this lot came from one of IQ's examples.\n    vec3 ww = normalize(lk - ro);\n    vec3 uu = normalize(cross(vec3(0, 1, 0), ww ));\n    vec3 vv = cross(ww, uu);\n    const float FOV = 3.14159/3.; // Field of view.\n    vec3 rd = normalize(u.x*uu + u.y*vv + ww/FOV); // Unit direction vector.\n    \n    \n    // Swiveling the camera from left to right when turning corners.\n    rd.xy = rot2(path(lk.z).x/24.)*rd.xy; \n    \n   // Mouse movement.\n    if(iMouse.z>1.){\n        vec2 ms = -(iMouse.xy - iResolution.xy*.5)/iResolution.y;\n        rd.yz *= rot2(ms.y*3.1459);  \n        rd.xz *= rot2(ms.x*3.1459);  \n    } \n     \n\n    // Render... I was going to perform a couple of passes, but decided against \n    // it. However, it's usually a good idea to have a separate render function.\n    \n    \n   \n    \n    float tt, refF = 1.;\n    vec4 c4 = vec4(1);\n    vec4 c42 = vec4(1);\n    vec4 acc = vec4(0);\n    for(int j = 0; j<1; j++){\n \n        vec4 layer = render(ro, rd, j);\n        \n        //c4 *= layer;\n        //acc += mix(c4, layer, .5)*refF;\n        //acc = acc + layer - acc*layer;\n        \n        vec4 layer2 = layer;\n        if(objRefF>0. && j>0) layer2.xyz = layer2.xyz*2.;\n        //if(j>0) layer.xyz += refF*.5;\n        c42 *= layer2;\n\n        float oRef = j==0? 1. : objRefF;\n        acc += mix(layer, c42, .5)*refF*oRef;\n        \n        if(j==0) tt = layer.w;\n        if(objRefF<.001) break;\n        refF *= .75;\n        \n    }\n    \n    c4.xyz = acc.xyz;\n    \n    \n    vec3 col = c4.xyz;\n    \n    \n    // Faux anitaliasing trick... Not really necessary here.\n    // Requires \"Buffer A\" in \"iChannel2\".\n    //vec4 tCol = texelFetch(iChannel2, ivec2(fragCoord), 0);\n    //col = mix(tCol.xyz, col, 1./3.);\n    \n    // Rough gamma correction.\n    //fragColor = vec4(pow(max(col, 0.), vec3(.4545)), 1);\n    fragColor = vec4(max(col, 0.), acc.w);\n    \n    \n}\n","name":"Buffer A","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"lccyR2","date":"1734014447","viewed":757,"name":"Rhombic Dodecahedral Traversal","username":"Shane","description":"A rhombic dodecahedron raymarching traversal of a 3D cavernous tunnel.","likes":65,"published":3,"flags":32,"usePreview":1,"tags":["raymarching","tunnel","bokeh","dodecahedron","polyhedron","traversal","rhomboid","rhombic"],"hasliked":0,"parentid":"","parentname":""}}