{"ver":"0.1","info":{"id":"7s2yzK","date":"1643826120","viewed":191,"name":"Fourier Transform Implementation","username":"yuempek","description":"discrete fourier transform, discrete inverse fourier transform ","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["fft","dft","ifft","idft"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 color, in vec2 XY)\n{\n    XY = floor(XY) + 0.5;\n    // inverse fourier\n    vec2 f = fourier_X(iChannel3, XY - 0.5, iResolution, -1.0) / N;\n    color = vec4(vec3(length(f)), 1.0);\n    \n    //color = vec4(texture(iChannel0, XY/iResolution.xy).rgb, 1.0);\n    //color = vec4(texture(iChannel1, XY/iResolution.xy).rgb, 1.0);\n    //color = vec4(texture(iChannel2, XY/iResolution.xy).rgb, 1.0);\n    //color = vec4(texture(iChannel3, XY/iResolution.xy).rgb, 1.0);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage(out vec4 color, in vec2 XY)\n{\n    XY = floor(XY);\n    vec2 uv = XY/iResolution.xy;\n    vec3 c = texture(iChannel0, uv).rgb;  \n    float g = (c.r+c.g+c.b)/3.0; //average of colors \n    color = vec4(g, 0.0, 0.0, 1.0);\n}\n\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265\n#define period 1.0\n\n//#define FOURIER_WINDOW iResolution.x\n//#define FOURIER_WINDOW resolution.x\n#define FOURIER_WINDOW 64.0\n\nfloat N = FOURIER_WINDOW;\n    \n// e^(i * alpha) = cos(alpha) * i*sin(alpha)\nvec2 ei(float alpha){\n    return vec2(cos(alpha), sin(alpha));\n}\n\n//complex multiplication\nvec2 muli(vec2 a, vec2 b){\n    // (x1+i*y1)(x2+i*y2) \n    // [X Y] = [x1 y1]*[x2 y2]\n    // X = (x1x2 - y1y2)\n    // Y = (x1y2 + y1x2)\n    float X = a.x*b.x - a.y*b.y;\n    float Y = a.x*b.y + a.y*b.x;\n    return vec2(X, Y);\n}\n\n//complex division\nvec2 divi(vec2 a, vec2 b){\n    // (x1+i*y1)/(x2+i*y2) \n    // [X Y] = [x1 y1]/[x2 y2]\n    // [X Y] = (x1, y1)*(x2, -y2) / (x2x2+y2y2)\n    // X = (x1x2 + y1y2)/(x2x2+y2y2)\n    // Y = (-x1y2 + y1x2)/(x2x2+y2y2)\n\n    float d = dot(b, b);\n    b.y *= -1.0;\n    \n    return muli(a,b)/d;\n}\n\n\n//   For length N input vector x, the DFT is a length N vector X,\n//   with elements\n//                   N-1\n//      X(k) =       sum x(n)*exp(-i*2*pi*k*n/N), 0 <= k <= N-1\n//                   n=0\n//   The inverse DFT is given by\n//                   N-1\n//      x(n) = (1/N) sum X(k)*exp( i*2*pi*k*n/N), 0 <= n <= N-1\n//                   k=0\n//\n\nvec2 fourier_X(sampler2D channel, vec2 XY, vec3 resolution, float direction)\n{\n    vec2 uv;\n    float X = XY.x;\n    float Y = XY.y;\n    \n    vec2 fourier = vec2(0.0);\n    \n    float section = floor(X/N);\n    float index = mod(X, N);\n\n    for (float n = 0.0; n < N; n+= period)\n    {\n        uv = vec2(n + 0.5 + section*N, Y + 0.5)/resolution.xy;\n        vec3 val = texture(channel, uv).rgb; //get n'th pixel on y'th line   \n        \n        fourier += muli(val.xy, ei(direction*index*2.0*PI*n/N));\n    }\n    \n    \n    return fourier;\n}\n\n\nvec2 fourier_Y(sampler2D channel, vec2 XY, vec3 resolution, float direction)\n{\n    vec2 uv;\n    float X = XY.x;\n    float Y = XY.y;\n    \n    vec2 fourier = vec2(0.0);\n    \n    float section = floor(Y/N);\n    float index = mod(Y, N);\n\n    for (float n = 0.0; n < N; n+= period)\n    {\n        uv = vec2(X + 0.5, n + 0.5 + section*N)/resolution.xy;\n        vec3 val = texture(channel, uv).rgb; //get n'th pixel on y'th line   \n        \n        fourier += muli(val.xy, ei(direction*index*2.0*PI*n/N));\n    }\n    \n    \n    return fourier;\n}\n\n\n\n/*\nf       : value on frequency domain \nwindow  : should be less than N/2.0 \nfilterId: 1: between, 2:higer, 3:lower\n*/\nvec2 frequencyFilter(float X, vec2 f, float window, float inWindowCoef, float outWindowCoef, int filterId){\n    \n    X = mod(X, N); \n    \n    if(filterId == 1){\n        if(window < X && X < (N - window)) \n            f *= inWindowCoef; \n        else \n            f *= outWindowCoef; \n    }\n    \n    \n    if(filterId == 2){\n        if(window < X) \n            f *= inWindowCoef; \n        else \n            f *= outWindowCoef; \n    }\n    \n       \n    if(filterId == 3){\n        if(X < (N - window)) \n            f *= inWindowCoef; \n        else \n            f *= outWindowCoef; \n    }\n     \n    return f;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage(out vec4 color, in vec2 XY)\n{\n    XY = floor(XY) + 0.5;\n    vec2 f = fourier_X(iChannel0, XY - 0.5, iResolution, 1.0);\n    \n    \n    //* low pass filter\n    float window = N/32.0;\n    float inWindowCoef = 0.0; \n    float outWindowCoef = 1.0;\n    int filterId = 1; //1: between, 2:higer, 3:lower\n    \n    f = frequencyFilter(XY.x, f, window, inWindowCoef, outWindowCoef, filterId);\n    //*/\n    \n    color = vec4(f.x, f.y, 0.0, 1.0);\n}\n\n\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage(out vec4 color, in vec2 XY)\n{\n    XY = floor(XY) + 0.5;\n    vec2 f = fourier_Y(iChannel0, XY - 0.5, iResolution, 1.0);\n\n    \n    //* low pass filter\n    float window = N/32.0;\n    float inWindowCoef = 0.0; \n    float outWindowCoef = 1.0;\n    int filterId = 1; //1: between, 2:higer, 3:lower\n    \n    f = frequencyFilter(XY.y, f, window, inWindowCoef, outWindowCoef, filterId);\n    //*/\n    \n    color = vec4(f.x, f.y, 0.0, 1.0);\n}\n","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"void mainImage(out vec4 color, in vec2 XY)\n{\n    XY = floor(XY) + 0.5;\n    // inverse fourier\n    vec2 f = fourier_Y(iChannel0, XY - 0.5, iResolution, -1.0) / N;\n    \n    color = vec4(f.x, f.y, 0.0, 1.0);\n}\n\n","name":"Buffer D","description":"","type":"buffer"}]}