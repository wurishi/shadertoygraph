{"ver":"0.1","info":{"id":"4s2yRm","date":"1676605490","viewed":129,"name":"Analytic cubic raytracer","username":"nilrem","description":"Raytracer for arbitrary cubic implicit surfaces using numerically stable analytic root finding\nBased on an algorithm by Jim Blinn, see https://www.shadertoy.com/view/XdjcRm\nWASD, space, shift, mouse drag outside gui area\nBottom sliders for clipping","likes":8,"published":1,"flags":48,"usePreview":0,"tags":["raytracer","interactive","ui","cubic","surface","analytic","widgets"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// --- Start Global Defines -------------------------------------------------------------\n// These #defines must be manually synchronized between shaders\n\n#define ID_MOUSESTATE       58.\n#define ID_MOUSESTATE_PREV  59.\n#define ID_MOUSE            60.\n#define ID_CAMERA_POSITION  61.\n#define ID_CAMERA_FORWARD   62.\n#define ID_CAMERA_LEFT      63.\n#define ID_CAMERA_UP        64.\n// last and largest ID, to skip as many fragments as possible (dummy id, largest previous id + 1)\n#define ID_LARGEST          65.\n\n#define NUM_SLIDERS\t\t\t56.\n#define SLIDER_GRID_X\t\t4.\n#define SLIDER_GRID_Y\t\t14.\n#define SLIDER_INSET\t\t0.032\n#define SLIDER_GRID_SIZE\tvec2( 1./SLIDER_GRID_X, 1./SLIDER_GRID_Y )\n#define SLIDER_PROPORTIONAL 1\n// --- End Global Defines ---------------------------------------------------------------\n\nhighp float;\n\n#define invRes ( 1.0 / iResolution.xy )\n#define UI(x) texture(iChannel0,(vec2(x,0)+.5)*invRes)\n\n// Draw Options\n//#define DRAW_CURVATURE\n//#define DRAW_GRID\n \n#define COEFF_MIN\t-2.0\n#define COEFF_MAX\t 2.0\n#define CLIP_MIN     0.0\n#define CLIP_MAX    30.0\n\n#define CLIP_DISTANCE_NEAR  0.0\n#define GRID_INSET\t\t\t0.1\n#define DISTANCE_INF\t\t100000.0\n#define DISTANCE_MAX\t\t1000.0\n\n\n// --- Function Plotting -----------------------------------------------------------------------------\n#define x_axis_scale    3.0\n#define y_axis_scale    2.0\n#define line_thickness  1.0\n\n#define black   vec3( 0 )\n#define grey    vec3( 0.4 )\n#define red     vec3( 0.9, 0.2, 0.1 )\n#define green   vec3( 0.2, 0.8, 0.2 )\n#define blue    vec3( 0.2, 0.2, 0.7 )\n#define orange  vec3( 0.9, 0.6, 0.1 )\n#define violet  vec3( 0.8, 0.1, 0.7 )\n\n// --- Math Functions --------------------------------------------------------------------------------\n\n// Sign function (deliberately returns 1 for x=0)\nfloat sgn( in float x )\n{\n    return x < 0.0 ? -1.0 : 1.0;\n}\n\n// Cubic root using pow (works on [-inf; inf]\nfloat cbrt( in float x )\n{\n    float sign = sgn(x);\n    return sign * pow( sign*x, 0.333333333333 );\n}\n\n// Evaluates cubic polynomial Ax³ + Bx² + Cx + D at x, given it's coefficients A B C D\nfloat eval_cubic( in float x, in float A, in float B, in float C, in float D )\n{\n    return A*x*x*x + B*x*x + C*x + D;\n}\n\n// Finds roots of homogeneous cubic polynomial Ax³ + 3Bx² + 3Cx + D   (Ax³ + 3Bx²w + 3Cxw² + Dw³)\n// Algorithm by Jim Blinn, see https://courses.cs.washington.edu/courses/cse590b/13au/lecture_notes\n// This implementation directly converts the roots from homogeneous to cartesian space\nfloat solve_cubic( out vec3 roots, in float A, in float B, in float C, in float D )\n{\n    // Hessian coefficients\n    float d_1 = A*C - B*B;\n    float d_2 = A*D - B*C;\n    float d_3 = B*D - C*C;\n\n    // Hessian determinant ( = cubic discriminant)\n    float d   = (4.0 * d_1 * d_3) - (d_2 * d_2);\n\n\n    if ( d <= 0.0 )     // one real root (a double root if d=0, a triple root if d_1=d_2=d_3=d=0)\n    {\n        // Subscript b for \"bar\", t for \"tilde\"\n\n        // Depressed polynomial coefficients\n        float A_t;  // A or D\n        float C_b;  // 1/2 H(t, u)\n        float D_b;  // J(t, u)\n\n        // save predicate B³D >= AC³ to avoid multiple evaluations\n        bool B3D_ge_AC3 = B*B*B*D >= A*C*C*C;\n\n        if ( B3D_ge_AC3 )\n        {\n            // Algorithm A, t = 1, u = 0\n            A_t = A;\n            C_b = d_1;\n            D_b = -2.0 * B * d_1 + A * d_2;\n        } else\n        {\n            // Algorithm D, t = 0, u = 1  (reversed order of coefficients)\n            A_t = D;\n            C_b = d_3;\n            D_b = -D * d_2 + 2.0 * C * d_3;\n        }\n\n        float T0   = -sgn(D_b) * abs(A_t) * sqrt(-d);\n        float T1   = -D_b + T0;\n        float p    = cbrt( T1*0.5 );\n        float q    = T1 == T0  ? -p : -C_b/p;\n        float x_t1 = C_b <= 0. ? p + q : -D_b / (p*p + q*q + C_b);\n\n        // Get back from tilde'ed space to homogeneous space and invert result if algorithm D\n        float x1   = B3D_ge_AC3 ? x_t1 - B : -D;\n        float w1   = B3D_ge_AC3 ? A : x_t1 + C;\n\n        // Convert from homogeneous to cartesian space\n        roots.x    = x1/w1;\n    }\n    else    // d > 0    // three real roots (with potentially one double root)\n    {\n        // variables subscripted with A and D according to algorithms A and D\n        // t is the angle theta\n        // x_L/w_L is the first root, x_S/w_S the second root, x_M/w_M the third root\n\n        // Use both algorithms A and D to find the first two roots\n        // Same C_b and D_b as before, according to algorithm A's and D's choices of t,u\n\n        // 0.866025403784 -> sqrt(3)/2\n\n        // Algorithm A\n        float C_bA  = d_1;\n        float D_bA  = -2.0 * B * d_1 + A*d_2;\n\n        float t_A   = 0.333333333333 * abs( atan( A*sqrt(d), -D_bA) );\n        float x_t1A = 2.0 * sqrt(-C_bA) * cos( t_A );\n        float x_t3A = 2.0 * sqrt(-C_bA) * ( -0.5 * cos(t_A) - 0.866025403784 * sin(t_A) );\n        float x_tL  = (x_t1A + x_t3A > 2.0 * B) ? x_t1A : x_t3A;\n\n        // Get back from tilde'ed space, same as before\n        float x_L   = x_tL - B;\n        float w_L   = A;\n\n        roots.x     = x_L/w_L;\n\n\n        // Algorithm D\n        // same as Algorithm A except for choice of t,u (and thus inverted result)\n        float C_bD  = d_3;\n        float D_bD  = -D * d_2 + 2.0 * C * d_3;\n\n        float t_D   = 0.333333333333 * abs( atan( D*sqrt(d), -D_bD) );\n        float x_t1D = 2.0 * sqrt(-C_bD) * cos( t_D );\n        float x_t3D = 2.0 * sqrt(-C_bD) * ( -0.5 * cos(t_D) - 0.866025403784 * sin(t_D) );\n        float x_tS  = (x_t1D + x_t3D < 2.0 * C) ? x_t1D : x_t3D;\n\n        // Get back from tilde'ed space, same as before\n        float x_S   = -D;\n        float w_S   = x_tS + C;\n\n        roots.y     = x_S/w_S;\n\n\n        // Third root from the first two (no more to and from tilde'ed space here)\n        float E   =  w_L * w_S;\n        float F   = -x_L * w_S - w_L * x_S;\n        float G   =  x_L * x_S;\n\n        float x_M =  C*F - B*G;\n        float w_M = -B*F + C*E;\n\n        roots.z   = x_M/w_M;\n    }\n\n    return d;   // return discriminant after setting roots.xyz\n}\n\n// Returns cubic polynomial coefficients ABCD for the new polynomial (At³ + Bt² + Ct + D),\n// after substituting ray equation into implicit cubic surface polynomial.\n// Takes ray origin, ray direction and\n// cubic surface coefficients A through T in the following form:\n//   Ax³ + By³ + Cz³\n// + Dx²y + Ex²z + Fy²x + Gy²z + Hz²x + Iz²y + Jxyz\n// + Kx² + Ly² + Mz² + Nxy + Oxz + Pyz\n// + Qx + Ry + Sz + T\nvoid get_ray_cubic_coeffs( out vec4 coeffs, in vec3 ray_o, in vec3 ray_d,\n    in float A, in float B, in float C, in float D, in float E, in float F, in float G,\n    in float H, in float I, in float J, in float K, in float L, in float M, in float N,\n    in float O, in float P, in float Q, in float R, in float S, in float T )\n{\n    #define x_d ray_d.x\n    #define y_d ray_d.y\n    #define z_d ray_d.z\n    #define x_o ray_o.x\n    #define y_o ray_o.y\n    #define z_o ray_o.z\n    \n    // Solved and simplified using open-source computer algebra system Maxima and converted to C code\n    // see https://maxima.sourceforge.io\n\n    float A_t = C*z_d*z_d*z_d+(I*y_d+H*x_d)*z_d*z_d+(G*y_d*y_d+J*x_d*y_d+E*x_d*x_d)*z_d+B*y_d*y_d*y_d\n    +F*x_d*y_d*y_d+D*x_d*x_d*y_d+A*x_d*x_d*x_d;\n\n    float B_t = (3.0*C*z_d*z_d+(2.0*I*y_d+2.0*H*x_d)*z_d+G*y_d*y_d+J*x_d*y_d+E*x_d*x_d)*z_o\n    +(I*y_o+H*x_o+M)*z_d*z_d\n    +((2.0*G*y_d+J*x_d)*y_o+(J*x_o+P)*y_d+2.0*E*x_d*x_o+O*x_d)*z_d\n    +(3.0*B*y_d*y_d+2.0*F*x_d*y_d+D*x_d*x_d)*y_o+(F*x_o+L)*y_d*y_d+(2.0*D*x_d*x_o+N*x_d)*y_d\n    +3.0*A*x_d*x_d*x_o+K*x_d*x_d;\n\n    float C_t = (3.0*C*z_d+I*y_d+H*x_d)*z_o*z_o+((2.0*I*y_o+2.0*H*x_o+2.0*M)*z_d\n    +(2.0*G*y_d+J*x_d)*y_o+(J*x_o+P)*y_d+2.0*E*x_d*x_o+O*x_d)\n    *z_o+(G*y_o*y_o+(J*x_o+P)*y_o+E*x_o*x_o+O*x_o+S)*z_d\n    +(3.0*B*y_d+F*x_d)*y_o*y_o\n    +((2.0*F*x_o+2.0*L)*y_d+2.0*D*x_d*x_o+N*x_d)*y_o\n    +(D*x_o*x_o+N*x_o+R)*y_d+3.0*A*x_d*x_o*x_o+2.0*K*x_d*x_o+Q*x_d;\n\n    float D_t = C*z_o*z_o*z_o+(I*y_o+H*x_o+M)*z_o*z_o+(G*y_o*y_o+(J*x_o+P)*y_o+E*x_o*x_o+O*x_o+S)*z_o\n    +B*y_o*y_o*y_o+(F*x_o+L)*y_o*y_o+(D*x_o*x_o+N*x_o+R)*y_o+A*x_o*x_o*x_o+K*x_o*x_o+Q*x_o+T;\n\n    coeffs = vec4( A_t, B_t, C_t, D_t );\n}\n\nvec3 derive_cubic( in vec3 p,\n    in float A, in float B, in float C, in float D, in float E, in float F, in float G,\n    in float H, in float I, in float J, in float K, in float L, in float M, in float N,\n    in float O, in float P, in float Q, in float R, in float S, in float T )\n{\n    float dx = H*p.z*p.z+J*p.y*p.z+2.0*E*p.x*p.z+O*p.z+F*p.y*p.y+2.0*D*p.x*p.y+N*p.y+3.0*A*p.x*p.x+2.0*K*p.x+Q;\n    float dy = I*p.z*p.z+2.0*G*p.y*p.z+J*p.x*p.z+P*p.z+3.0*B*p.y*p.y+2.0*F*p.x*p.y+2.0*L*p.y+D*p.x*p.x+N*p.x+R;\n    float dz = 3.0*C*p.z*p.z+2.0*I*p.y*p.z+2.0*H*p.x*p.z+2.0*M*p.z+G*p.y*p.y+J*p.x*p.y+P*p.y+E*p.x*p.x+O*p.x+S;\n\n    return vec3( dx, dy, dz );\n}\n\n// Returns 3rd order power series polynomial coefficients from 3rd order Bernstein polynomial coefficients\nvec4 get_power_from_bernstein_coeffs( in float b0, in float b1, in float b2, in float b3 )\n{\n\tfloat p0 = b0;\n    float p1 = b1 - b0;\n    float p2 = b2 - b1;\n    float p3 = b3 - b2 - 2.0*p2;\n    p2 -= p1;\n    p1 *= 4.0;\n    p2 *= 6.0;\n    p3 *= 4.0;\n    \n    return vec4( p0, p1, p2, p3 );\n}\n\n// Returns the gaussian curvature and normal vector of a trivariate cubic polynomial\n// at a given point, given coefficients A through T in the form stated above\nfloat gaussian_curvature( out vec3 normal, in vec3 point,\n    in float A, in float B, in float C, in float D, in float E, in float F, in float G,\n    in float H, in float I, in float J, in float K, in float L, in float M, in float N,\n    in float O, in float P, in float Q, in float R, in float S, in float T )\n{\n    float x = point.x;\n    float y = point.y;\n    float z = point.z;\n    \n    float x_2\t = x*x;\n    float y_2\t = y*y;\n    float z_2\t = z*z;\n    \n    // Partially solved using Maxima, see above\n    float f_dx\t = z_2*H + J*y*z + 2.0*E*x*z + O*z + F*y_2 + 2.0*D*x*y + N*y + 3.0*A*x_2 + 2.0*K*x + Q;\n    float f_dy\t = I*z_2 + 2.0*G*y*z + J*x*z + P*z + 3.0*B*y_2 + 2.0*F*x*y + 2.0*L*y + D*x_2 + N*x + R;\n    float f_dz\t = 2.0*x*z*H + 3.0*C*z_2 + 2.0*I*y*z + 2.0*M*z + G*y_2 + J*x*y + P*y + E*x_2 + O*x + S;\n\n    float f_d_2  = f_dx*f_dx + f_dy*f_dy + f_dz*f_dz;\n\n    normal = vec3( f_dx, f_dy, f_dz ) * inversesqrt( f_d_2 );\n    \n    float t_7\t = 2.0*I*z + 2.0*G*y + J*x + P;\n    float t_8\t = 2.0*G*z + 6.0*B*y + 2.0*F*x + 2.0*L;\n    float t_9\t = 2.0*x*H + 6.0*C*z + 2.0*I*y + 2.0*M;\n    float t_10\t = J*z + 2.0*F*y + 2.0*D*x + N;\n    float t_11\t = 2.0*z*H + J*y + 2.0*E*x + O;\n    float t_12\t = t_7*t_10 - t_8*t_11;\n    float t_13\t = t_7*t_11 - t_10*t_9;\n    float t_14\t = 2.0*E*z + 2.0*D*y + 6.0*A*x + 2.0*K;\n    float t_15\t = t_10*t_11 - t_14*t_7;\n\n    return (  f_dy*( f_dy*(t_14*t_9 - t_11*t_11) + f_dz*t_15 + f_dx*t_13 )\n            + f_dz*( f_dy*t_15 + f_dx*t_12 + (t_14*t_8 - t_10*t_10)*f_dz )\n            + f_dx*( f_dy*t_13 + f_dz*t_12 + f_dx*(t_8*t_9 - t_7*t_7) )   ) / (f_d_2 * f_d_2);\n}\n\nvec4 get_cubic_curvatures( out vec3 normal, in vec3 point,\n    in float A, in float B, in float C, in float D, in float E, in float F, in float G,\n    in float H, in float I, in float J, in float K, in float L, in float M, in float N,\n    in float O, in float P, in float Q, in float R, in float S, in float T )\n{\n    float x     = point.x;\n    float y     = point.y;\n    float z     = point.z;\n\n    float x_2\t= x*x;\n    float y_2\t= y*y;\n    float z_2\t= z*z;\n\n    // Partially solved using Maxima, see above\n    float f_x\t= z_2*H + J*y*z + 2.0*E*x*z + O*z + F*y_2 + 2.0*D*x*y + N*y + 3.0*A*x_2 + 2.0*K*x + Q;\n    float f_y\t= I*z_2 + 2.0*G*y*z + J*x*z + P*z + 3.0*B*y_2 + 2.0*F*x*y + 2.0*L*y + D*x_2 + N*x + R;\n    float f_z\t= 2.0*H*x*z + 3.0*C*z_2 + 2.0*I*y*z + 2.0*M*z + G*y_2 + J*x*y + P*y + E*x_2 + O*x + S;\n\n    float t_7   =     J*x + 2.0*G*y + 2.0*I*z +     P;\n    float t_12  = 2.0*F*x + 6.0*B*y + 2.0*G*z + 2.0*L;\n    float t_17  = 2.0*H*x + 2.0*I*y + 6.0*C*z + 2.0*M;\n    float t_18  = 2.0*D*x + 2.0*F*y +     J*z +     N;\n    float t_19  = 2.0*E*x +     J*y + 2.0*z*H +     O;\n    float t_26  = 6.0*A*x + 2.0*D*y + 2.0*E*z + 2.0*K;\n\n    float t_20\t= t_7*t_18 - t_12*t_19;\n    float t_21\t= t_7*t_19 - t_18*t_17;\n    float t_27\t= t_18*t_19 - t_26*t_7;\n\n    // Squared norm of gradient\n    float f_n_2\t= f_x*f_x + f_z*f_z + f_y*f_y;\n    \n    float f_n   = sqrt( f_n_2 );\n    \n    normal = vec3( f_x, f_y, f_z ) / f_n;\n\n    float k_gauss = (   f_x*( f_x*( t_12*t_17 - t_7 *t_7  ) + f_y*t_21 + f_z*t_20 )\n                      + f_y*( f_y*( t_26*t_17 - t_19*t_19 ) + f_x*t_21 + f_z*t_27 )\n                      + f_z*( f_z*( t_26*t_12 - t_18*t_18 ) + f_x*t_20 + f_y*t_27 )\n                    )\n        \t\t    / ( f_n_2*f_n_2 );\n\n    float k_mean  = (   f_x*( t_26*f_x + t_18*f_y + t_19*f_z )\n                      + f_y*( t_18*f_x + t_12*f_y + t_7 *f_z )\n                      + f_z*( t_19*f_x + t_7 *f_y + t_17*f_z )\n                      - f_n_2*( t_17 + t_12 + t_26 )\n                    )\n                \t/ ( 2.0 * f_n_2 * f_n );\n\n    float sqrt_mean_2_minus_gauss = sqrt( k_mean*k_mean - k_gauss );\n\n    float k_1     = k_mean + sqrt_mean_2_minus_gauss;\n    float k_2     = k_mean - sqrt_mean_2_minus_gauss;\n    \n    return vec4( k_gauss, k_mean, k_1, k_2 );\n}\n\nbool is_point_clipped( vec3 point, vec4 clip_range, bool clip_sphere )\n{\n    bool result;\n    \n    if (clip_sphere)\n    {\n        result = point.x*point.x + point.y*point.y + point.z*point.z > clip_range.w;\n    }\n    else\n    {\n    \tresult = ( point.x < -clip_range.x\n                || point.x >  clip_range.x\n                || point.y < -clip_range.y\n                || point.y >  clip_range.y\n                || point.z < -clip_range.z\n                || point.z >  clip_range.z );\n    }\n    \n    return result;\n}\n\nfloat interpolate_catmull_rom( float y0, float y1, float y2, float y3, float mu )\n{\n   float a0, a1, a2, a3, mu2;\n\n   mu2 = mu*mu;\n   \n   // Catmull-Rom:\n   a0 = -0.5*y0 + 1.5*y1 - 1.5*y2 + 0.5*y3;\n   a1 = y0 - 2.5*y1 + 2.0*y2 - 0.5*y3;\n   a2 = -0.5*y0 + 0.5*y2;\n   a3 = y1;\n   \n   // \"Regular\" cubic:\n   a0 = y3 - y2 - y0 + y1;\n   a1 = y0 - y1 - a0;\n   a2 = y2 - y0;\n   a3 = y1;\n\n   return ( a0*mu*mu2 + a1*mu2 + a2*mu + a3 );\n}\n\n// ------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    uv.x   *= iResolution.x / iResolution.y;\n    \n    vec3 cam_position  = UI(ID_CAMERA_POSITION).xyz;\n    vec3 cam_forward   = UI(ID_CAMERA_FORWARD).xyz;\n    vec3 cam_left      = UI(ID_CAMERA_LEFT).xyz;\n    vec3 cam_up        = UI(ID_CAMERA_UP).xyz;\n\n    // --- Read slider values ----------------------------------------------------------\n\n    #define READ_SLIDER(i,min,max)\t\t\t( UI(i).a * (max-min) + min )\n    #define READ_SLIDER_GRID(x,y,min,max)\t( UI(x*int(SLIDER_GRID_Y)+y).a * (max-min) + min )\n    \n    // Read cubic polynomial coefficients from sliders\n\tfloat A = READ_SLIDER_GRID( 0,  1, COEFF_MIN, COEFF_MAX );\n    float B = READ_SLIDER_GRID( 0,  2, COEFF_MIN, COEFF_MAX );\n    float C = READ_SLIDER_GRID( 0,  3, COEFF_MIN, COEFF_MAX );\n    float D = READ_SLIDER_GRID( 0,  4, COEFF_MIN, COEFF_MAX );\n    float E = READ_SLIDER_GRID( 0,  5, COEFF_MIN, COEFF_MAX );\n    float F = READ_SLIDER_GRID( 0,  6, COEFF_MIN, COEFF_MAX );\n    float G = READ_SLIDER_GRID( 0,  7, COEFF_MIN, COEFF_MAX );\n    float H = READ_SLIDER_GRID( 0,  8, COEFF_MIN, COEFF_MAX );\n    float I = READ_SLIDER_GRID( 0,  9, COEFF_MIN, COEFF_MAX );\n    float J = READ_SLIDER_GRID( 0, 10, COEFF_MIN, COEFF_MAX );\n    float K = READ_SLIDER_GRID( 1,  1, COEFF_MIN, COEFF_MAX );\n    float L = READ_SLIDER_GRID( 1,  2, COEFF_MIN, COEFF_MAX );\n    float M = READ_SLIDER_GRID( 1,  3, COEFF_MIN, COEFF_MAX );\n    float N = READ_SLIDER_GRID( 1,  4, COEFF_MIN, COEFF_MAX );\n    float O = READ_SLIDER_GRID( 1,  5, COEFF_MIN, COEFF_MAX );\n    float P = READ_SLIDER_GRID( 1,  6, COEFF_MIN, COEFF_MAX );\n    float Q = READ_SLIDER_GRID( 1,  7, COEFF_MIN, COEFF_MAX );\n    float R = READ_SLIDER_GRID( 1,  8, COEFF_MIN, COEFF_MAX );\n    float S = READ_SLIDER_GRID( 1,  9, COEFF_MIN, COEFF_MAX );\n    float T = READ_SLIDER_GRID( 1, 10, COEFF_MIN, COEFF_MAX );\n    \n    // --- Raytracer -------------------------------------------------------------------\n\n    vec3 ray_origin    = cam_position;\n    vec3 ray_direction = normalize( vec3(   cam_forward * 1.6\n                                          - cam_left    * uv.x\n                                          + cam_up      * uv.y   ) );\n\n    vec4 ray_cubic_coeffs;\n    get_ray_cubic_coeffs( ray_cubic_coeffs, ray_origin, ray_direction,\n                         A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T );\n\n    ray_cubic_coeffs.y *= 0.3333333333;\n    ray_cubic_coeffs.z *= 0.3333333333;\n\n    vec3 roots;\n\n    float discriminant = solve_cubic( roots,\n          ray_cubic_coeffs.x, ray_cubic_coeffs.y, ray_cubic_coeffs.z, ray_cubic_coeffs.w );\n\n    vec4 clip_range;\n    clip_range.x\t = READ_SLIDER_GRID( 0, 12, CLIP_MIN, CLIP_MAX );\n    clip_range.y\t = READ_SLIDER_GRID( 0, 13, CLIP_MIN, CLIP_MAX );\n    clip_range.z\t = READ_SLIDER_GRID( 0, 14, CLIP_MIN, CLIP_MAX );\n    clip_range.w\t = READ_SLIDER_GRID( 1, 13, CLIP_MIN, CLIP_MAX );\tclip_range.w *= clip_range.w; // Squared radius\n    bool clip_sphere = ( READ_SLIDER_GRID( 1, 12, 0.0, 1.0 ) > 0.5 );\n    \n    vec3 ray_intersection;\n    float ray_distance = DISTANCE_INF;\n    \n    if (discriminant <= 0.)\n    {\n        if (roots.x > CLIP_DISTANCE_NEAR)\n        {\n            vec3 point = ray_origin + (ray_direction * roots.x);\n            if (!is_point_clipped( point, clip_range, clip_sphere ))\n            {\n                ray_intersection = point;\n                ray_distance = roots.x;\n            }\n        }\n    }\n    else\n    {\n        if (roots.x > CLIP_DISTANCE_NEAR)\n        {\n            vec3 point = ray_origin + (ray_direction * roots.x);\n            if (!is_point_clipped( point, clip_range, clip_sphere ))\n            {\n                ray_intersection = point;\n                ray_distance = roots.x;\n            }\n        }\n        if (roots.y > CLIP_DISTANCE_NEAR)\n        {\n            vec3 point = ray_origin + (ray_direction * roots.y);\n            if (!is_point_clipped( point,clip_range, clip_sphere ) && roots.y < ray_distance)\n            {\n                ray_intersection = point;\n                ray_distance = roots.y;\n            }\n        }\n        if (roots.z > CLIP_DISTANCE_NEAR)\n        {\n            vec3 point = ray_origin + (ray_direction * roots.z);\n            if (!is_point_clipped( point, clip_range, clip_sphere ) && roots.z < ray_distance)\n            {\n                ray_intersection = point;\n                ray_distance = roots.z;\n            }\n        }\n    }\n\t\n    float background_grayscale = READ_SLIDER_GRID( 1, 14, 0.0, 1.0 );\n    vec4 bufColor = texture( iChannel0, fragCoord / iResolution.xy );\n    \n    float sigmoid_exponent_factor = READ_SLIDER_GRID( 2, 1, 0.0, 10.0 );\n    \n    if ( ray_distance < DISTANCE_MAX )\n    {\n        vec3 normal;\n        \n    #ifndef DRAW_CURVATURE\n        \n        // Get surface normal\n        normal = derive_cubic( ray_intersection,\n                                   A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T );\n        normal = normalize(normal);\n        \n        fragColor = vec4( normal*0.5 + 0.5, 1 );\n        \n\t#else\n        // Get gaussian, mean and principal curvatures, and surface normal\n        vec4 K = get_cubic_curvatures(normal, ray_intersection,\n                                        A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T );\n        \n        fragColor = vec4( vec3( 1.0 / (1.0 + exp2( sigmoid_exponent_factor*K.y ) ) ), 1 );\n        \n    #endif\n        \n        // Flip normal if pointing away from screen\n        if ( dot(ray_direction, normal) < 0. )\n        {\n            normal = -normal;\n        }\n        \n        \n    #ifdef DRAW_GRID\n        \n        #define TRIANGLE_WAVE(x, size)\t(abs( x*size - floor(0.5 + x*size) ) * 2.0)\n        \n        float temp = 0.0;\n        if( clip_range.x - abs(ray_intersection.x) > GRID_INSET )\n        {\n            temp += exp2( -TRIANGLE_WAVE(ray_intersection.x, 2.) * 30. );\n        }\n        if( clip_range.y - abs(ray_intersection.y) > GRID_INSET )\n        {\n            temp += exp2( -TRIANGLE_WAVE(ray_intersection.y, 2.) * 30. );\n        }\n        if( clip_range.z - abs(ray_intersection.z) > GRID_INSET )\n        {\n            temp += exp2( -TRIANGLE_WAVE(ray_intersection.z, 2.) * 30. );\n        }\n\t\ttemp = min( temp, 1.0 );\n        \n        fragColor = vec4( mix( fragColor.rgb, vec3(0), temp ), 1 );\n        \n    #endif\n    \n    }\n    else\n    {\n        fragColor = vec4( background_grayscale );\n    }\n    \n    if (fragCoord.y == 0.5)\n    {\n        // Assume alpha=0 (and black) for first pixel row (holding data)\n        bufColor = vec4(0);\n    }\n    \n#ifdef DRAW_CURVATURE\n    fragColor = vec4( sqrt( fragColor.rgb ), fragColor.a );\n#endif\n    \n    fragColor = mix( fragColor, bufColor, bufColor.a * 0.5 );\n    \n    return;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n// --- Start Global Defines -------------------------------------------------------------\n// These #defines must be manually synchronized between shaders\n\n#define ID_MOUSESTATE       58.\n#define ID_MOUSESTATE_PREV  59.\n#define ID_MOUSE            60.\n#define ID_CAMERA_POSITION  61.\n#define ID_CAMERA_FORWARD   62.\n#define ID_CAMERA_LEFT      63.\n#define ID_CAMERA_UP        64.\n// last and largest ID, to skip as many fragments as possible (dummy id, largest previous id + 1)\n#define ID_LARGEST          65.\n\n#define NUM_SLIDERS\t\t\t56.\n#define SLIDER_GRID_X\t\t4.\n#define SLIDER_GRID_Y\t\t14.\n#define SLIDER_INSET\t\t0.032\n#define SLIDER_GRID_SIZE\tvec2( 1./SLIDER_GRID_X, 1./SLIDER_GRID_Y )\n#define SLIDER_PROPORTIONAL 1\n// --- End Global Defines ---------------------------------------------------------------\n\n\n// --- Modified version comments --------------------------------------------------------\n// Performance is now independent of the number of UI widgets\n// Additional mouse state is now saved in the first pixel UI(0)\n// UI(ID_MOUSE).xy specifies where a mouse click originated from\n\n\n// Right and above these coordinates used for mouseview\n#define MOUSEVIEW_AREA_X 0.75\n#define MOUSEVIEW_AREA_Y 0.001\n\n// Mouse sensitivity for mouseview\n#define MOUSEVIEW_SENSITIVITY 1.7\n\n// Camera speed\n#define CAMERA_SPEED 5.\n\n\n// Both world and camera spaces: right handed coordinate system\n// See http://i.stack.imgur.com/0hxY1.png (taken from http://stackoverflow.com/questions/19747082/how-does-coordinate-system-handedness-relate-to-rotation-direction-and-vertices\n// Both coordinate systems start out oriented the same way\n// Camera is defined by the 3 basis vectors forward, left, up\n// x axis: forward\n// y axis: left     (yes, left, see image)\n// z axis: up\n\n#define FAKE_MOUSE 0       // fake mouse motion if no user input\n#define SLIDER_RADIUS .025 // influence radius for sliders\n\n#define UI(x) texture(iChannel0,(vec2(x,0)+.5)/iResolution.xy)\n\n\n// --- Keyboard ---------------------------------------------------------\n// Sole parameter is a keycode (corresponding to event.keyCode)\n// These are *not* ASCII codes, see http://www.javascripter.net/faq/keycodes.htm\n// Use the KEY_s #defined above\n\n// replaced /256. with *0.00390625 (exact binary float)\n#define KEYTOGGLE(keyCode)  ( texture(KEYBOARD_CHANNEL, vec2( (.5+keyCode)*0.00390625, 0.75) ).x > 0. )\n#define KEYCLICK(keyCode)   ( texture(KEYBOARD_CHANNEL, vec2( (.5+keyCode)*0.00390625, 0.25) ).x > 0. )\n\n#define KEYBOARD_CHANNEL    iChannel2\n\n#define KEY_SHIFT       16.\n#define KEY_SPACE       32.\n#define KEY_PAGEUP      33.\n#define KEY_PAGEDOWN    34.\n#define KEY_END         35.\n#define KEY_HOME        36.\n#define KEY_LEFT        37.\n#define KEY_UP          38.\n#define KEY_RIGHT       39.\n#define KEY_DOWN        40.\n// 0-9 48-57\n#define KEY_0           48.\n#define KEY_1           49.\n#define KEY_2           50.\n#define KEY_3           51.\n#define KEY_4           52.\n#define KEY_5           53.\n#define KEY_6           54.\n#define KEY_7           55.\n#define KEY_8           56.\n#define KEY_9           57.\n// A-Z 65-90\n#define KEY_A           65.\n#define KEY_D           68.\n#define KEY_S           83.\n#define KEY_W           87.\n\n//#define ADD_SLIDER(x,y,l,v0) { nbS++; if (fragCoord==vec2(nbS,0.))    fragColor = vec4(x,y,l,v0); }\n#define ADD_SLIDER(v0)\t\t\t\t{ nbS++; if (fragCoord == vec2(nbS,0.))    fragColor = vec4(0.0, 0.0, 1.0, v0); }\n#define SKIP_SLIDERS(num)\t\t\t{ nbS += num; }\n#define SKIP_SLIDER_COLUMNS(num)\t{ nbS += num*SLIDER_GRID_Y; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n// Wrap everything inside smallest possible if-clause\n// to discard most fragments as early as possible\nif (fragCoord.y != 0.5 || fragCoord.x > ID_LARGEST)\n{\n    discard;\n}\nelse\n{\n\tfragColor = texture( iChannel0, fragCoord / iResolution.xy );\n    \n    // Offset each pixel's fragCoord by half a pixel left and down\n\t// Places the lower-left pixel at (0.0, 0.0) instead of the OpenGL default (0.5, 0.5)\n\tfragCoord -= .5;\n    \n    // First frame: initialization\n    if (iFrame==0) {\n        \n        fragColor = vec4(0);\n\n        // --- Sliders and Buttons ------------------------------------------------------\n        int nbS = 0, nbB = 0;\n\n        ADD_SLIDER ( 0.5 );\n        ADD_SLIDER ( 0.5 );\n        ADD_SLIDER ( 0.5 );\n        ADD_SLIDER ( 0.5 );\n        ADD_SLIDER ( 0.5 );\n        ADD_SLIDER ( 0.5 );\n        ADD_SLIDER ( 0.5 );\n        ADD_SLIDER ( 0.5 );\n        ADD_SLIDER ( 0.5 );\n        ADD_SLIDER ( 0.5 );\n        \n        SKIP_SLIDERS( 1 );\n        \n        // clip range\n        ADD_SLIDER ( 0.2 );\n        ADD_SLIDER ( 0.2 );\n        ADD_SLIDER ( 0.2 );\n        \n        // cubic coefficients\n        // ADD_SLIDER ( 0.5 );\n        // ADD_SLIDER ( 0.5 );\n        // ADD_SLIDER ( 0.5 );\n        // ADD_SLIDER ( 0.5 );\n        // ADD_SLIDER ( 0.5 );\n        // ADD_SLIDER ( 0.5 );\n        // ADD_SLIDER ( 0.5 );\n        // ADD_SLIDER ( 0.5 );\n        // ADD_SLIDER ( 0.5 );\n        // ADD_SLIDER ( 0.0 );\n        \n        // cubic coefficients\n        ADD_SLIDER ( 1.0 );\n        ADD_SLIDER ( 0.0 );\n        ADD_SLIDER ( 1.0 );\n        ADD_SLIDER ( 0.8 );\n        ADD_SLIDER ( 0.9 );\n        ADD_SLIDER ( 0.1 );\n        ADD_SLIDER ( 0.1 );\n        ADD_SLIDER ( 0.5 );\n        ADD_SLIDER ( 1.0 );\n        ADD_SLIDER ( 0.0 );\n        \n        SKIP_SLIDERS( 1 );\n        \n        // do clip sphere\n        ADD_SLIDER ( 1.0 );\n        \n        // clip range radius\n        ADD_SLIDER ( 0.2 );\n        \n        // background\n        ADD_SLIDER ( 0.0 );\n        \n        // curvature sigmoid exponent factor\n        ADD_SLIDER ( 0.5 );\n        \n        // if (fragCoord.x==0.) fragColor.xy = vec2(nbS, nbB);      // Removed, see comments at the top\n\n\n        // --- Mouse state --------------------------------------------------------\n        if (fragCoord.x == ID_MOUSE)\n        {\n                fragColor = vec4( 0 );     // Reset click origin\n        }\n\n        // --- Camera state  ------------------------------------------------------------\n        if (fragCoord.x == ID_CAMERA_POSITION)\n        {\n                fragColor = vec4( -8, 0, 0, 0 );\n        }\n        else if (fragCoord.x == ID_CAMERA_FORWARD)\n        {\n                fragColor = vec4( 1, 0, 0, 0 );\n        }\n        else if (fragCoord.x == ID_CAMERA_LEFT)\n        {\n                fragColor = vec4( 0, 1, 0, 0 );\n        }\n        else if (fragCoord.x == ID_CAMERA_UP)\n        {\n                fragColor = vec4( 0, 0, 1, 0 );\n        }\n\n        // --- Initialization finished --------------------------------------------------\n        return;\n    }\n\n\n    // --- Mouse state handling ------------------------------------------------\n\n    if (fragCoord.x == ID_MOUSESTATE)       // Set current mouse state\n    {\n        vec4 m = iMouse;\n\n    #if FAKE_MOUSE\n        if (length(m.xy) < 10. && m.z <= 0.)\n        {   // fake mouse motion if no user input\n            float t = iTime;          // you can reset this state by putting the mouse back in the corner\n            m.xy = (.5+.4*vec2(cos(t),sin(t)))*iResolution.xy;\n        }\n    #endif\n\n        fragColor = m;\n        return;\n    }\n    \n    if (fragCoord.x == ID_MOUSESTATE_PREV)     // Set previous mouse state\n    {\n        vec4 new_prev_mouse_state;\n\n        if (iMouse.z > 0. && UI(ID_MOUSESTATE_PREV).z <= 0.)\n        {\n            // If the mouse button was *just* pressed, reset previous mouse state to the current one\n            // This allows relative mouseview dragging, instead of \"jumping\"\n            new_prev_mouse_state = iMouse;\n        }\n        else\n        {\n            new_prev_mouse_state = UI(ID_MOUSESTATE);\n        }\n\n        fragColor = new_prev_mouse_state;\n        return;\n    }\n    \n    if (fragCoord.x == ID_MOUSE)       // Set additional mouse state\n    {\n        // Normalized mouse coordinates\n        vec2 M = iMouse.xy/iResolution.y;\n\n        if (iMouse.z > 0. && UI(ID_MOUSESTATE_PREV).z <= 0.)        // mouse button down\n        {\n            // set UI(0).xy to normalized mouse coordinates of first click position\n            fragColor.xyz = vec3( M.xy, 1 );\n        }\n        else if (iMouse.z <= 0. && UI(ID_MOUSESTATE_PREV).z > 0.)   // mouse button up\n        {\n            fragColor.z = 0.;\n        }\n        return;\n    }\n\n\n    // --- Process mouse input ----------------------------------------------------------\n    \n    if (UI(ID_MOUSE).z > 0.)        // mouse button down\n    {\n        // Normalized mouse coordinates\n        vec2 M = iMouse.xy/iResolution.y;\n        //vec2 M = UI(ID_MOUSESTATE).xy/iResolution.y;\n\n        if (    UI(ID_MOUSE).x < MOUSEVIEW_AREA_X\n             || UI(ID_MOUSE).y < MOUSEVIEW_AREA_Y  )   // click originates from UI area\n        {\n            // Handle sliders\n            vec2 uv    = M;\n            \n            #ifndef SLIDER_PROPORTIONAL\n            \tuv.x *= iResolution.y / iResolution.x;\n            #endif\n            \n            if (fragCoord.x <= NUM_SLIDERS)\n            {\n                float slider_id\t\t= fragCoord.x;\n                vec4 slider\t\t\t= UI( slider_id );\n                \n                vec2 grid_coords;\n                grid_coords.x\t\t= floor( (slider_id - 1.0) / SLIDER_GRID_Y );\n    \t\t\tgrid_coords.y\t\t= SLIDER_GRID_Y - (slider_id - grid_coords.x*SLIDER_GRID_Y);\n                \n                vec2 slider_pos     = grid_coords * SLIDER_GRID_SIZE + SLIDER_INSET;\n                \n                //float slider_length = abs(slider.z);\n                float slider_length = SLIDER_GRID_SIZE.x - (2.0 * SLIDER_INSET);\n                \n                if (   slider.z > 0.0\t// slider defined\n                    && abs( uv.y - slider_pos.y ) < SLIDER_RADIUS\n                    && abs( uv.x - slider_pos.x - 0.5*slider_length ) < 0.52*slider_length  )\n                {\n                    fragColor.a = (uv.x - slider_pos.x) / slider_length;\n                    fragColor.a = max(fragColor.a, 0.);\n                    fragColor.a = min(fragColor.a, 1.);\n                }\n                \n                /*\n                if (   slider.z > 0.0\t// slider defined\n                    && abs( M.y - slider.y ) < SLIDER_RADIUS\n                    && abs( M.x - slider.x - 0.5*slider_length ) < 0.52*slider_length  )\n                {\n                    fragColor.a = (M.x - slider.x) / slider_length;\n                    fragColor.a = max(fragColor.a, 0.);\n                    fragColor.a = min(fragColor.a, 1.);\n                }\n\t\t\t\t*/\n            }\n            \n            /*\n            // Handle sliders\n            if (fragCoord.x <= NUM_SLIDERS)\n            {\n                vec4 S = UI(fragCoord.x);\n                float l = abs(S.z);\n\n                //  if (S.z<0. && abs(M.x-S.x)<Sradius /*&& abs(M.y-S.y-l*.5)<l*.5*/ /*) fragColor.a = (M.y-S.y)/l; // vertical\n                if (S.z>0. && abs(M.y-S.y) < Sradius && abs(M.x-S.x-l*.5) < l*.52 )\n                {\n                    fragColor.a = (M.x-S.x)/l;\n                    fragColor.a = max(fragColor.a, 0.);\n                    fragColor.a = min(fragColor.a, 1.);\n                }\n            }\n        \t*/\n        }\n        else    // click originates from mouseview area\n        {\n            // update camera view\n\n            // Normalized mouse coordinates of last frame\n            vec2 Mprev = UI(ID_MOUSESTATE_PREV).xy/iResolution.y;\n\n            vec2 Mdiff = (M - Mprev) * MOUSEVIEW_SENSITIVITY;\n\n            if (fragCoord.x == ID_CAMERA_FORWARD)\n            {\n                vec3 cam_forward = UI(ID_CAMERA_FORWARD).xyz;\n                vec3 cam_left    = UI(ID_CAMERA_LEFT).xyz;\n                vec3 cam_up      = UI(ID_CAMERA_UP).xyz;\n\n                fragColor.xyz = normalize( vec3(   cam_forward * 1.0\n                                                 - cam_left    * Mdiff.x\n                                                 + cam_up      * Mdiff.y   ) );\n\n                // fragColor.xyz = normalize( UI(ID_CAMERA_FORWARD).xyz + vec3( 0, -Mdiff.x, Mdiff.y ) );\n                /*\n                fragColor.xyz = normalize( vec3(    Mdiff.y*( f.y*f.z - f.x*f.z) + Mdiff.x*f.y + f.x,\n                                            Mdiff.y*(-f.y*f.z - f.x*f.z) - Mdiff.x*f.x + f.y,\n                                            Mdiff.y*( f.y*f.y + f.x*f.x) - Mdiff.x*f.z + f.z    ) );\n                */\n            }\n            else if (fragCoord.x == ID_CAMERA_LEFT)\n            {\n                vec3 cam_forward = UI(ID_CAMERA_FORWARD).xyz;\n                // Left vector is the cross product of global z axis with forward vector\n                // Normalization is necessary since forward vector isn't perpendicular to z axis\n                fragColor.xyz = normalize( vec3(- cam_forward.y,\n                                                  cam_forward.x,\n                                                  0.0  ) );\n            }\n            else if (fragCoord.x == ID_CAMERA_UP)\n            {\n                // up vector is the cross product of forward and left vectors\n                vec3 cam_forward = UI(ID_CAMERA_FORWARD).xyz;\n                vec3 cam_left    = UI(ID_CAMERA_LEFT).xyz;\n\n                fragColor.xyz = normalize( cross( cam_forward, cam_left ) );\n                \n                /*\n                vec3 f = UI(ID_CAMERA_FORWARD).xyz;\n                fragColor.xyz = normalize( vec3( f.y*f.z - f.x*f.z,\n                                        -f.y*f.z - f.x*f.z,\n                                         f.y*f.y + f.x*f.x  ) );\n                */\n            }\n        }\n    }\n\n    \n    // --- Process keyboard input ----------------------------------------------------------\n\n    if (fragCoord.x == ID_CAMERA_POSITION)\n    {\n        vec3 cam_position = UI(ID_CAMERA_POSITION).xyz;\n        vec3 cam_forward  = UI(ID_CAMERA_FORWARD).xyz;\n        vec3 cam_left     = UI(ID_CAMERA_LEFT).xyz;\n        vec3 cam_up       = UI(ID_CAMERA_UP).xyz;\n\n        if ( KEYCLICK( KEY_W ) )\n        {\n            fragColor.xyz = cam_position + cam_forward * CAMERA_SPEED * iTimeDelta;\n        }\n        else if ( KEYCLICK( KEY_S ) )\n        {\n            fragColor.xyz = cam_position - cam_forward * CAMERA_SPEED * iTimeDelta;\n        }\n        else if ( KEYCLICK( KEY_A ) )\n        {\n            fragColor.xyz = cam_position + cam_left * CAMERA_SPEED * iTimeDelta;\n        }\n        else if ( KEYCLICK( KEY_D ) )\n        {\n            fragColor.xyz = cam_position - cam_left * CAMERA_SPEED * iTimeDelta;\n        }\n        else if ( KEYCLICK( KEY_SPACE ) )\n        {\n            fragColor.xyz = cam_position + cam_up * CAMERA_SPEED * iTimeDelta;\n        }\n        else if ( KEYCLICK( KEY_SHIFT ) )\n        {\n            fragColor.xyz = cam_position - cam_up * CAMERA_SPEED * iTimeDelta;\n        }\n    }\n}\n\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n// --- Start Global Defines -------------------------------------------------------------\n// These #defines must be manually synchronized between shaders\n\n#define ID_MOUSESTATE       58.\n#define ID_MOUSESTATE_PREV  59.\n#define ID_MOUSE            60.\n#define ID_CAMERA_POSITION  61.\n#define ID_CAMERA_FORWARD   62.\n#define ID_CAMERA_LEFT      63.\n#define ID_CAMERA_UP        64.\n// last and largest ID, to skip as many fragments as possible (dummy id, largest previous id + 1)\n#define ID_LARGEST          65.\n\n#define NUM_SLIDERS\t\t\t56.\n#define SLIDER_GRID_X\t\t4.\n#define SLIDER_GRID_Y\t\t14.\n#define SLIDER_INSET\t\t0.032\n#define SLIDER_GRID_SIZE\tvec2( 1./SLIDER_GRID_X, 1./SLIDER_GRID_Y )\n#define SLIDER_PROPORTIONAL 1\n// --- End Global Defines ---------------------------------------------------------------\n\n\nhighp float;\n\n\n#define UI(x) texture(iChannel0,(vec2(x,0)+.5)/iResolution.xy)\n\n#define SLIDER_WIDTH  .002\n#define SLIDER_RADIUS .0002\n\n\n// define your sliders in BufA.  value [0,1]  = UI(i).a    , i=1..16\n// get mouse position enriched by demo-mode in UI(ID_MOUSESTATE)\n// get prev mouse position in UI(ID_MOUSESTATE_PREV) (e.g.: detect move, get velocity, direction...)\n\n// --- Digit display ----------------------------------------------------\n// all functions return true or seg number if something was drawn -> caller can then exit the shader.\n\nfloat segment(vec2 uv, bool On)\n{\n    return (On) ?  (1.-smoothstep(0.08,0.09+float(On)*0.02,abs(uv.x)))*\n                   (1.-smoothstep(0.46,0.47+float(On)*0.02,abs(uv.y)+abs(uv.x)))\n                : 0.;\n}\n\nfloat digit(vec2 uv,int num)\n{\n    float seg= 0.;\n    seg += segment(uv.yx+vec2(-1., 0.), num!=-1 && num!=1 && num!=4                     );\n    seg += segment(uv.xy+vec2(-.5,-.5), num!=-1 && num!=1 && num!=2 && num!=3 && num!=7 );\n    seg += segment(uv.xy+vec2( .5,-.5), num!=-1 && num!=5 && num!=6                     );\n    seg += segment(uv.yx+vec2( 0., 0.), num!=-1 && num!=0 && num!=1 && num!=7           );\n    seg += segment(uv.xy+vec2(-.5, .5), num== 0 || num==2 || num==6 || num==8           );\n    seg += segment(uv.xy+vec2( .5, .5), num!=-1 && num!=2                               );\n    seg += segment(uv.yx+vec2( 1., 0.), num!=-1 && num!=1 && num!=4 && num!=7           );\n    return seg;\n}\n\n// val: 2 digits + sign     zeroTrim: trim leading \"0\"\nfloat showNum(vec2 uv, float val, bool zeroTrim)\n{\n    int nr = int(val);\n    if (abs(uv.x)>2.*1.5 || abs(uv.y)>1.2) return 0.;\n    if (val<0.) {\n        nr = -nr;\n        if (uv.x>1.5) {\n            uv.x -= 2.;\n            return segment(uv.yx,true); // minus sign.\n        }\n    }\n    if (uv.x>0.) {\n        nr /= 10; if (nr==0 && zeroTrim) nr = -1;\n        uv -= vec2(.75,0.);\n    } else {\n        uv += vec2(.75,0.);\n        nr = int(mod(float(nr),10.));\n    }\n    return digit(uv,nr);\n}\n\nfloat dots(vec2 uv, int dot)    // dot: bit 0 = bottom dot; bit 1 = top dot\n{\n    float point0 = float(dot/2),\n          point1 = float(dot)-2.*point0;\n    uv.y -= .1; float l0 = 1.-point0+length(uv); if (l0<.13) return (1.-smoothstep(.11,.13,l0));\n    uv.y += 1.; float l1 = 1.-point1+length(uv); if (l1<.13) return (1.-smoothstep(.11,.13,l1));\n    return 0.;\n}\n\n#define STEPX .875\n#define STEPY 2.33\nfloat _offset = 0.; // auto-increment useful for successive \"display\" call\n\n// 2 digit int + sign   dot: draw separator\nfloat display_digit(vec2 uv, float scale, float offset, float number, int dot, bool zeroTrim )\n{\n    uv    = (uv-0.)/scale*2.;\n    uv.x  = .5-uv.x + STEPX*offset;\n    uv.y -= 1.;\n    float seg = showNum(uv, number, zeroTrim);\n    offset += 2.;\n    if (dot>0) {\n        uv.x   += STEPX*offset;\n        seg    += dots(uv,dot);\n        offset += 2.;\n    }\n    _offset = offset;\n    return seg;\n}\n\n// 2.2 float + sign     dot: draw separator\nfloat display_float(vec2 pos, float scale, float offset, float val)\n{\n    float return_val = 0.;\n    if (display_digit( pos, scale, 0., val, 1, true ) > 0.) return_val = 1.;\n    else if (display_digit( pos, scale, _offset, fract(abs(val))*100., 0, false ) > 0.) return_val = 1.;\n    return return_val;\n}\n\n// --- sliders and mouse widgets -------------------------------------------\n\nfloat display_sliders( vec2 uv )\n{\n    #ifndef SLIDER_PROPORTIONAL\n\t\tuv.x *= iResolution.y / iResolution.x;\n    #endif\n    \n    \n    vec2 grid_coords = floor( uv * vec2(SLIDER_GRID_X, SLIDER_GRID_Y) );\n    \n    float slider_id\t\t= SLIDER_GRID_Y - grid_coords.y + (grid_coords.x * SLIDER_GRID_Y);\n    if (slider_id > NUM_SLIDERS) return 0.0;\n    \n    vec4 slider\t\t\t= UI( slider_id );\n    \n    vec2 slider_pos     = grid_coords * SLIDER_GRID_SIZE + SLIDER_INSET;\n    float slider_length = SLIDER_GRID_SIZE.x - (2.0 * SLIDER_INSET);\n    \n    float result = 0.0;\n    \n    if (slider.z > 0.0)\t// slider defined\n    {\n        vec2 distance_temp = uv - slider_pos - vec2(slider.a*slider_length, 0);\n        float distance = dot( distance_temp, distance_temp );\n        \n        if ( abs( uv.y - slider_pos.y ) < SLIDER_WIDTH && abs(uv.x - slider_pos.x - 0.5*slider_length) < 0.5*slider_length )\n        {\n            result = 1.0;\n        }\n        if ( distance < SLIDER_RADIUS )\n        {\n            result = 1.0;\n        }\n    }\n    \n    return result;\n}\n\n/*\nfloat aff_sliders(vec2 uv)\n{\n    float result = 0.0;\n    \n    for (float i = 1.; i <= NUM_SLIDERS; i++)\n    {\n        vec4 slider = UI(i);\n        vec2 distance_temp = uv - slider.xy - vec2(slider.a*slider.z, 0);\n        float distance = dot( distance_temp, distance_temp );\n        \n        if ( abs( uv.y - slider.y ) < SLIDER_WIDTH && abs(uv.x - slider.x - 0.5*slider.z) < 0.5*slider.z )\n        {\n            result = 1.0;\n        }\n        if ( distance < SLIDER_RADIUS )\n        {\n            result = 1.0;\n        }\n    }\n    \n    return result;\n}\n*/\n/*\nfloat aff_sliders(vec2 U)\n{\n    float result = 0.0;\n    \n    for (float i = 1.; i <= NUM_SLIDERS; i++)\n    {\n        vec4 slider = UI(i);\n        float l = abs(slider.z);\n        vec2 dist = U - slider.xy - vec2(slider.a*l,0);\n        if (slider.z > 0. && abs( U.y - slider.y ) < SLIDER_WIDTH && abs(U.x - slider.x - l*0.5) < l*0.5 )\n        {\n            result = 1.0;\n        }\n        if (slider.z > 0. && dot( dist, dist ) < SLIDER_RADIUS )\n        {\n            result = 1.0;\n        }\n    }\n    \n    return result;\n}\n*/\n\n/*\n#define Swidth  .002\n#define Sradius .015\nfloat aff_sliders(vec2 U)\n{\n    for (float i = 1.; i <= NUM_SLIDERS; i++) {\n        vec4 S = UI(i);\n        float l = abs(S.z);\n        if (S.z>0. && abs(U.y-S.y)<Swidth && abs(U.x-S.x-l/2.)<l/2. ) return 1.;\n    //  if (S.z<0. && abs(U.x-S.x)<Swidth && abs(U.y-S.y-l/2.)<l/2. ) return 1.;    // vertical\n        if (S.z>0. && length(U-S.xy-vec2(S.a*l,0))<Sradius ) return 1.;\n    //  if (S.z<0. && length(U-S.xy-vec2(0,S.a*l))<Sradius ) return 1.;             // vertical\n    }\n    return 0.;\n}\n*/\n\n\n\n\n// --- Function Plotting -----------------------------------------------------------------------------\n\n#define x_axis_scale    3.0\n#define y_axis_scale    2.0\n#define line_thickness  1.0\n\n#define black   vec3( 0 )\n#define grey    vec3( 0.4 )\n#define red     vec3( 0.9, 0.2, 0.1 )\n#define green   vec3( 0.2, 0.8, 0.2 )\n#define blue    vec3( 0.2, 0.2, 0.7 )\n#define orange  vec3( 0.9, 0.6, 0.1 )\n#define violet  vec3( 0.8, 0.1, 0.7 )\n\n\n// ------------------------------------------------------------------------\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\nif (fragCoord.y == 0.5)\n{\n    // Pass through the first row of pixels (holding data)\n    fragColor = texture( iChannel0, fragCoord / iResolution.xy );\n}\nelse\n{\n    // black background with alpha = 0\n    fragColor = vec4(0);\n    \n    // --- Draw UI -------------------------------------------------------------------\n    {\n        vec2 uv = fragCoord.xy / iResolution.y;\n        vec4 mouse = UI(ID_MOUSESTATE) / iResolution.y;\n\n        float scale = 0.03;\n\n        // Display sliders and buttons\n        if (display_sliders(uv)>0.) { fragColor = vec4(.1,.7,.1,1); return;}\n\n\n        vec3 cam_position  = UI(ID_CAMERA_POSITION).xyz;\n        vec3 cam_forward   = UI(ID_CAMERA_FORWARD).xyz;\n        vec3 cam_left      = UI(ID_CAMERA_LEFT).xyz;\n        vec3 cam_up        = UI(ID_CAMERA_UP).xyz;\n\n    }\n}\n\nreturn;\n}\n","name":"Buffer B","description":"","type":"buffer"}]}