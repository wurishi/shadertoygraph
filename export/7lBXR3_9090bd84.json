{"ver":"0.1","info":{"id":"7lBXR3","date":"1628203404","viewed":75,"name":"Terrain sphere","username":"treize","description":"test ","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","noise","terrain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ITERATION_NUM 99\nconst float MAT_A=1.0;\nconst float MAT_B=2.0;\nvec2 map(vec3 p) \n{\n    vec2 d;\n    d=vec2(sphere(p, 0.9),MAT_A);\n\treturn d;\n}\nvec3 getnormal(vec3 p)\n{\n    vec2 d =vec2(0.0001,0.0);\n    return normalize(vec3(map(p +d.xyy).x -map(p -d.xyy).x,map(p +d.yxy).x -map(p -d.yxy).x,map(p +d.yyx).x -map(p -d.yyx).x));\n}\nvec3 lighting(vec3 lp,vec3 n)\n{\n     return vec3(Lambert(lp,n));\n}\nvec3 materialize(vec3 p, float depth,vec2 mat)\n{\n    vec3 col=vec3(1.0);\n    if (depth > 10.0)\n    {\n    }\n    else\n    {\n         col=vec3(Lambert(vec3(cos(iTime),0.0,sin(iTime)), getnormal(p)));\n         if(mat.y== MAT_A)\n         {\n            float col2 =FBM34_2(p*3.,1.0,1.0);\n            //col2=mix(0.0,1.0,col2);\n            vec3 tcol;\n            if(col2<0.05)\n            {\n                tcol = vec3(0.0,0.7,1.0);\n            }\n            else if(col2<0.1)\n            {\n                tcol = vec3(0.87, 0.72, 0.5);\n            }\n            else\n            {\n                tcol = vec3(0.13, 0.54, 0.13);\n            }\n\n            col*=tcol;\n         }\n\n     }\n     return col;\n}\nvec3 raymarch(vec3 ro, vec3 rd) \n{\n\tvec3 p;\n    vec2 d;\n\tfloat depth;\n\tfor(int i=0; i<ITERATION_NUM; i++) \n\t{\n        p=ro+rd*depth;\n\t\td = map(p);\n\t\tif(d.x<0.00001)\n\t\t{\n\t\t    break;\n\t\t}\n\t\tdepth += d.x;\n\t}\n\treturn  materialize(p,depth,d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec3 origin =vec3(cos(iTime)*5.,3.0,sin(iTime)*5.);\n  //vec3 origin = vec3(0.0, 3.0, -5.0);\n    vec3 target = vec3(0.0);\n    mat3 camera = SetCamera(origin, target, 0.0);\n    vec3 rd = camera * normalize(vec3(p,3.5));\n\tvec3 col=raymarch(origin , rd);    \n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//Noise\nfloat hash13(vec3 p)\n{\n\tvec3 p3 = fract(p * .1031);\n\tp3 += dot(p3, p3.yzx + 33.33);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\nfloat ValueNoise31(vec3 p) \n{\n    vec3 i = floor(p);\n    float v000 = hash13(i);\n    float v100 = hash13(i + vec3(1.0,0.0,0.0));\n    float v010 = hash13(i + vec3(0.0,1.0,0.0));\n    float v110 = hash13(i + vec3(1.0,1.0,0.0));\n    float v001 = hash13(i + vec3(0.0,0.0,1.0));\n    float v101 = hash13(i + vec3(1.0,0.0,1.0));\n    float v011 = hash13(i + vec3(0.0,1.0,1.0));\n    float v111 = hash13(i + vec3(1.0,1.0,1.0));\n    vec3 f = fract(p);\n    f = f * f * (3.0 -2.0 * f); \n    return mix(mix(mix( v000,v100,f.x),mix( v010,v110,f.x),f.y),                        \n               mix(mix(v001, v101,f.x),mix(v011, v111,f.x),f.y),f.z)-0.5;\n}\nfloat FBM34_2(vec3 p, float amplitude, float frequency)\n{\n\tfloat result = 0.;\n\tfloat amplitude2 = amplitude;\n\tfloat frequency2 = frequency;\n\tfor (int i = 0; i < 4; i++)\n\t{\n        result += ValueNoise31(p * frequency2) * amplitude2;\n\t\tamplitude2 *= 0.5;\n\t\tfrequency2 *= 2.0;\n\t}\n\treturn result;\n}\n//SDF\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n\nvec2 opUnion(vec2 d1,vec2 d2 ) { return (d1.x<d2.x) ? d1 : d2; }\nfloat sphere(vec3 rayPos, float r) \n{\n    float d=length(rayPos)-r;\n\treturn d;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n//Lighting\nfloat Lambert(vec3 l,vec3 n)\n{\n    return max(0.0,dot(n,l));\n}\n\nmat3 SetCamera(in vec3 origin, in vec3 target, float rotation)\n{\n    vec3 forward = normalize(target - origin);\n    vec3 orientation = vec3(sin(rotation), cos(rotation), 0.0);\n    vec3 left = normalize(cross(forward, orientation));\n    vec3 up = normalize(cross(left, forward));\n    return mat3(left, up, forward);\n}","name":"Common","description":"","type":"common"}]}