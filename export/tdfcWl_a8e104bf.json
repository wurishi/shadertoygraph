{"ver":"0.1","info":{"id":"tdfcWl","date":"1585816818","viewed":171,"name":"PCD@Tokyo DCC2 'Dead-end'","username":"ankd","description":"dissolved dead end\n---\n#dailycodingchallenge is a project of PCD(ProcessingCommunityDay)@Tokyo\nhttps://twitter.com/PCD_Tokyo","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","pcd"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\tPCD@Tokyo #dailycodingchallenge\n\tauthor: ankd\n\ttheme : Dead-end (行き止まり)\n*/\nvec3 ro, rd;\n\nfloat tunnel(in vec3 p) { \n\tfloat t = circle(p.xy, 1.2);\n    float f = .3*fbm(rotate(p, vec3(0., 0., 0.3*noise(p.z*1.4)))*4.);\n    return abs(t+f);\n}\n\nfloat door(in vec3 p) {\n    float curt = length((p-ro) / rd);\n\n    p.z = repeat(p.z, 10.);\n\n    float b = box(p, vec3(1., 1., 0.1)) + 0.1*fbm(p.xy*10.);\n    float b2 = sphere(p, mix(4., 0., clamp(curt*0.15, 0., 1.))) + 1.5*fbm(rotate(p.xy*8., p.z));\n\n    return opSS(vec2(b2), vec2(b), 0.5).x;\n}\n\nvec2 particle(in vec3 p) {\n    vec3 c = vec3(1.2);\n    float r = 0.02;\n    p = p - 0.5*c;\n    vec3 id = repeatid(p,c);\n    p = repeat(p, c);\n    vec3 offset = (hash3(id.x + id.y + id.z)-0.5) * (0.9*c - r);\n    \n\tfloat d = sphere(p-offset, r);\n    return vec2(d, 2.);\n}\n\nvec2 map(in vec3 p) {\n\tvec2 m = vec2(tunnel(p), 0.);\n    m = opSU(m, vec2(door(p), 1.), 0.5);\n    m = opU(m, particle(p));\n    return m;\n}\n\nvec2 castRay(in vec3 ro, in vec3 rd, in vec2 tmm) {\n\tfloat t = tmm.x;\n    float c = -1.;\n    for(int i=0;i<256;i++) {\n    \tvec2 m = abs(map(ro + rd*t));\n        if (m.x < 5e-4 || tmm.y<t) {\n        \tbreak;\n        }\n        t += m.x*0.4;\n        c = m.y;\n    }\n    if (tmm.y<t) {\n    \tt = -1.;\n        c = -1.;\n    }\n    return vec2(t, c);\n}\n\nvec3 calcNormal(in vec3 p) {\n\tvec2 e = vec2(1., -1.)*5e-4;\n    return normalize(\n    \te.xyy * map(p + e.xyy).x +\n    \te.yxy * map(p + e.yxy).x +\n    \te.yyx * map(p + e.yyx).x +\n    \te.xxx * map(p + e.xxx).x\n    );\n}\n\n#define FOG_ITR 64\nvec3 addFog(in vec3 ro, in vec3 rd, in vec2 tmm) {\n\tfloat t = tmm.x;\n    float s = (tmm.y - tmm.x) / float(FOG_ITR);\n    float v = 0.;\n    for(int i = 0;i<FOG_ITR;i++) {\n        vec3 p = ro + rd*t;\n        p *= 1.2;\n        v += pow(clamp(fbm(p)*0.8, 0., 1.), 8.);\n        if (.8<v) break;\n        t += s;\n    }\n    return vec3(v);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float z = iTime;\n    z *= 5.;\n    ro = vec3(0.1, -0.8, -z);\n    vec3 ta = ro + 2.*normalize(vec3(-.1, .2, -1.));\n    rd = camera(\n        ro,\n        ta,\n        60.,\n        0.01*(noise(iTime*20.5)*2.-1.),\n        fragCoord.xy,\n        iResolution.xy\n    );\n\n    vec2 frustum = vec2(0., 100.);\n    vec2 m = castRay(ro, rd, frustum);\n    float t = m.x, c = m.y;\n    vec3 pos = ro + rd*t;\n    vec3 nor = calcNormal(pos);\n    vec3 ref = reflect(rd, nor);\n\n    // material\n    vec3 col = vec3(1.);\n\tcol *= exp(-0.1*t);\n    \n    // lighting\n    vec3 lp = ta;\n    vec3 ld = normalize(lp - pos);\n    float ll = length(lp - pos);\n\t\n    col *= clamp(dot(nor, ld), 0., 1.) * exp(-0.1*ll);// diffuse\n    \n    // add fog\n    vec3 fog = addFog(ro, rd, vec2(0., t));\n\n    // Output to screen\n    vec2 st = (fragCoord.xy*2.-iResolution.xy) / min(iResolution.x, iResolution.y);\n    col = pow(col, vec3(3.));\n    col = mix(vec3(0.02, 0.05, 0.06), vec3(0.6, 0.7, 0.8), grayScale(col));\n    col += fog;\n    col *= clamp(2.-0.5*dot(st, st), 0., 1.);\n\n    if (c<0.) col = vec3(0., 0., 1.);\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\n\tmy common funcitons\n*/\n\n// constant\n#define PI 3.14159265359\n#define INF (1./0.)\n\n// time\n#define TT (iTime)\n#define FT fract(TT)\n#define IT floor(TT)\n\n// u_circular function\n#define usin(v) (sin(v)*0.5-0.5)\n#define ucos(v) (cos(v)*0.5-0.5)\n\n// rotation\nmat2 rotate(in float r) { float c=cos(r), s=sin(r); return mat2(c,-s,s,c); }\nvec2 rotate(in vec2 p, in float r) { return rotate(r)*p; }\nvec3 rotate(in vec3 p, in vec3 r) {\n\tp.xy = rotate(p.xy, r.z);\n\tp.yz = rotate(p.yz, r.x);\n\tp.zx = rotate(p.zx, r.y);\n    return p;\n}\n\n// random and noise\n// reference and please add if you need from:\n// - https://github.com/hughsk/glsl-noise\n// - https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nfloat hash(in float v) { return fract(sin(v)*43758.5453); }\nvec3 hash3(in float v) { return vec3(hash(v-999.), hash(v), hash(v+999.)); }\nfloat hash(in vec2 v) { return fract(sin(dot(v, vec2(12.9898, 78.233)))*43758.5453); }\nvec3 hash3(in vec2 v) { return vec3(hash(v-999.9), hash(v), hash(v+999.9)); }\nfloat noise(in float v) { float f=fract(v),i=floor(v),u=f*f*(3.-2.*f); return mix(hash(i), hash(i+1.), u); }\nfloat noise(in vec2 v) {\n    vec2 f=fract(v),i=floor(v),u=f*f*(3.-2.*f);\n    return mix(\n        mix(hash(i+vec2(0.,0.)), hash(i+vec2(1.,0.)), u.x),\n        mix(hash(i+vec2(0.,1.)), hash(i+vec2(1.,1.)), u.x),\n        u.y\n    );\n}\nfloat noise(in vec3 v) {\n    vec3 f=fract(v),i=floor(v),u=f*f*(3.-2.*f);\n    float n = i.x + i.y*53. + i.z*117.;\n    return mix(\n        mix(mix(hash(n+  0.), hash(n+  1.), u.x), mix(hash(n+ 53.), hash(n+ 54.), u.x), u.y),\n        mix(mix(hash(n+117.), hash(n+118.), u.x), mix(hash(n+170.), hash(n+171.), u.x), u.y),\n        u.z\n    );\n}\nconst mat2 m2 = mat2(0.8,-0.6,0.6,0.8);\nfloat fbm(in vec2 p){\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m2*p*2.02;\n    f += 0.2500*noise( p ); p = m2*p*2.03;\n    f += 0.1250*noise( p ); p = m2*p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\nfloat fbm(in vec3 p) {\n\tfloat f = 0.;\n    f += 0.5000*noise( p ); p = rotate(p*2.02, vec3(0.3, 0.4, 0.5));\n    f += 0.2500*noise( p ); p = rotate(p*2.03, vec3(0.3, 0.4, 0.5));\n    f += 0.1250*noise( p ); p = rotate(p*2.01, vec3(0.3, 0.4, 0.5));\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\n\n// color filter\nvec3 hsv(in float h, in float s, in float v) { return ((clamp(abs(fract(h+vec3(0.,2.,1.)/3.)*6.-3.)-1., 0., 1.)-1.)*s+1.)*v;  }\nvec3 hsv(in vec3 c) { return hsv(c.x, c.y, c.z); }\nfloat grayScale(in vec3 rgb) { return dot(rgb, vec3(0.298912, 0.586611, 0.114478)); }\nvec3 invert(in vec3 rgb) { return 1.-rgb; }\nvec3 gamma(in vec3 rgb) { return pow(rgb, vec3(0.4545)); }\n\n// easing\nfloat easeIn(in float v, in float e) { return pow(v, e); }\nfloat easeOut(in float v, in float e) { return 1.-pow(1.-v, e); }\nfloat easeInOut(in float v, in float e) { return v<0.5 ? 0.5*easeIn(v,e) : 0.5+0.5*easeOut(v,e); }\nfloat easeOutIn(in float v, in float e) { return v<0.5 ? 0.5*easeOut(v,e) : 0.5+0.5*easeIn(v,e); }\n\n/*\n\tray marching function\n*/\n// 2d sdf\nfloat circle(in vec2 p, in float r) { return length(p) - r; }\nfloat rect(in vec2 p, in vec2 b) { vec2 d = abs(p)-b; return length(max(d,0.)) + min(max(d.x, d.y), 0.); }\nfloat rect(in vec2 p, in float b) { return rect(p, vec2(b)); }\n\n// 3d sdf\nfloat sphere(in vec3 p, in float r) { return length(p) - r; }\nfloat box(in vec3 p, in vec3 b) { vec3 d = abs(p)-b; return length(max(d, 0.)) + min(max(d.x, max(d.y, d.z)), 0.); }\nfloat box(in vec3 p, in float b) { return box(p, vec3(b)); }\nfloat plane(in vec3 p, in vec3 n, in float h) { return dot(p, n) - h; }\n\n// operation\nvec2 opU(in vec2 d1, in vec2 d2) { return d1.x<d2.x  ? d1 : d2; }// d1 or d2\nvec2 opS(in vec2 d1, in vec2 d2) { return d1.x>-d2.x ? d1 : d2; }// d1 - d2\nvec2 opI(in vec2 d1, in vec2 d2) { return d1.x>d2.x  ? d1 : d2; }// d1 and d2\nvec2 opSU(in vec2 d1, in vec2 d2, in float k) {\n\tfloat h = clamp(0.5+0.5*(d2.x-d1.x)/k, 0., 1.);\n    return vec2(mix(d2.x, d1.x, h) - k*h*(1.-h), d1.y);\n}\nvec2 opSS(in vec2 d1, in vec2 d2, in float k) {\n\tfloat h = clamp(0.5-0.5*(d2.x+d1.x)/k, 0., 1.);\n    return vec2(mix(d2.x, -d1.x, h) + k*h*(1.-h), d1.y);\n}\nvec2 opSI(in vec2 d1, in vec2 d2, in float k) {\n\tfloat h = clamp(0.5-0.5*(d2.x-d1.x)/k, 0., 1.);\n    return vec2(mix(d2.x, d1.x, h) + k*h*(1.-h), d1.y);\n}\n\n#define repeat(p,c) (mod(p,c)-0.5*c)\n#define repeatid(p,c) (floor(p/c))\n\n// camera\n// ex)\n// vec3 rd = camera(ro, vec3(0.), 60., 0., fragCoord.xy, iResolution.xy);\nmat3 lookat(in vec3 eye, in vec3 target, in float cr) {\n\tvec3 cz = normalize(target - eye);\n    vec3 cx = normalize(cross(cz, vec3(sin(cr), cos(cr), 0.)));\n    vec3 cy = normalize(cross(cx, cz));\n    return mat3(cx, cy, cz);\n}\nvec3 camera(\n    in vec3 eye,\n    in vec3 target,\n    in float fov,// [deg]\n    in float cr,// [deg]\n    in vec2 coord,// = fragCoord.xy\n    in vec2 res// = iResolution.xy\n) {\n    vec2 p = (coord*2.-res) / min(res.x, res.y);\n    float fovRad = fov / 180. * PI;\n    float aspect = res.x / res.y;\n    vec3 dir = normalize(vec3(p, aspect/tan(0.5*fovRad)));\n    return lookat(eye, target, cr) * dir;\n}","name":"Common","description":"","type":"common"}]}