{"ver":"0.1","info":{"id":"Xf3GWB","date":"1712054737","viewed":36,"name":"Adnan-A3-3","username":"adnankhan","description":"Force Field, Pendulum Motion, Expanding Circles, Sun Simulation","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["continue"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Section 3: Uncomment each part to see the output\n\n/*\n// Part 1: Force Field\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalize coordinates\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Create animated distortion effect using sine waves\n    float distortionX = sin(uv.y * 10.0 + iTime) * 0.05;\n    float distortionY = cos(uv.x * 10.0 + iTime) * 0.05;\n    \n    // Apply distortion to UV coordinates\n    vec2 distortedUV = uv + vec2(distortionX, distortionY);\n    \n    // Define colors for the force field\n    vec3 baseColor = vec3(0.0, 0.2, 0.8); // Base color of the force field\n    vec3 highlightColor = vec3(1.0, 1.0, 1.0); // Color for highlights\n    \n    // Apply color blending based on UV coordinates\n    vec3 finalColor = mix(baseColor, highlightColor, length(distortedUV - 0.5) * 2.0);\n    \n    // Output final color\n    fragColor = vec4(finalColor, 1.0);\n}\n*/\n\n\n/*\n// Part 2: Pendulum Motion\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // Create swinging pendulum effect\n    float pendulumX = sin(uv.y * 10.0 + iTime) * 0.1;\n    float pendulumY = cos(uv.x * 15.0 + iTime * 1.5) * 0.1;\n    uv += vec2(pendulumX, pendulumY);\n\n    // Output color\n    fragColor = vec4(uv, 0.0, 1.0);\n}\n\n*/\n\n/*\n// Part 3: Expanding Circles\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // Modulate radius with sine wave\n    float radius = 0.2 + sin(iTime) * 0.1;\n\n    // Calculate distance to center\n    float dist = length(uv - 0.5);\n\n    // Inside the circle, output white color\n    if (dist < radius) {\n        fragColor = vec4(1.0);\n    } else {\n        fragColor = vec4(0.0);\n    }\n}\n*/\n\n\n\n// Part 4: Sun simulation / Sun Rise and Sun set\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalize fragCoord\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Calculate time (you may adjust the speed by multiplying iTime with a constant)\n    float time = iTime * 0.5;\n    \n    // Calculate the color gradient for sunrise/sunset\n    vec3 skyColor = vec3(0.5, 0.2, 0.2); // Base sky color\n    vec3 horizonColor = vec3(0.9, 0.6, 0.2); // Color at the horizon\n    float gradient = uv.y * 2.0 - 1.0; // Calculate the gradient from bottom to top\n    \n    // Blend between sky color and horizon color based on gradient\n    vec3 finalColor = mix(skyColor, horizonColor, smoothstep(-0.1, 0.1, gradient));\n    \n    // Add a sun\n    vec2 sunPosition = vec2(0.5 + 0.3 * sin(time), 0.7 + 0.2 * cos(time)); // Sun moves in a circular path\n    float sunSize = 0.05; // Adjust the size of the sun\n    float sunIntensity = smoothstep(sunSize, sunSize * 0.8, length(uv - sunPosition)); // Create a soft edge for the sun\n    \n    // Blend sun color with the sky\n    finalColor += vec3(1.0, 0.8, 0.0) * sunIntensity; // Yellowish sun color\n    \n    // Output final color\n    fragColor = vec4(finalColor, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}