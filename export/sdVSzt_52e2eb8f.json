{"ver":"0.1","info":{"id":"sdVSzt","date":"1701964135","viewed":97,"name":"Tumbler 2D","username":"spalmer","description":"simple physics collision demo, trying old semi-recursive SDF-based collision algo on few round box.  No shock propagation yet.  Uses various physical collision resolution methods by TDM, fenix, myself\n","likes":14,"published":1,"flags":32,"usePreview":1,"tags":["collision","physics","overlap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// demo old semi-recursive collision detection algo based on SDFs.\n// physics mostly borrowed from TDM http://shadertoy.com/view/NtlGz7\n// I probably botched some of it!\n// WIP toy still doesn't work with very thin 'boxes' / capsules\n// TODO needs shock propagation to have any hope of stacking properly\n// TODO the collision detection / nearest points thing still needs work\n// I know I had it working better at one point in the past,\n// by estimating nearest points as (potentially large) spheres\n// to help the algo deal with flat surfaces.\n// anyway it's entertaining enough already that I may go ahead and public.\n// Any assistance improving any of it would be highly appreciated!\n\n// FIXME something now wrong w inertia tensor or something,\n// was working better the other day.  Now debugging and\n// trying to re-integrate improvements from http://shadertoy.com/view/DtGBDW\n\n// simply shows BufferA but hides data pixels\nvoid mainImage(out vec4 o, vec2 p)\n{\n    ivec2 q = ivec2(p);\n    while (q.y < NDR && q.x < NOBJ) ++q.y;\n    o = texelFetch(iChannel0, q, 0);\n}\n\n// TODO if I can get a few round box working, I can probably\n// get Voroshapes 2D working.  http://shadertoy.com/view/WdXcRN","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"struct Obj\n{\n    vec2 p; // position\n    vec2 v; // velocity (could do old position instead for Verlet integration)\n    float s; // orientation fullturns\n    float a; // angular velocity, spin, rotation rate in radians/second\n    float r; // radial size, bounding 'radius', determines mass\n    float h; // second radius factor\n    float c; // fillet rounding radius\n    float imass; // 1./mass\n    float imom; // inverse moment of inertia tensor (just a scalar for 2D)\n};\n\nconst float hpi = acos(0.); // pi/2\nconst float tau = hpi * 4.; //acos(-1.) * 2.;\n\nmat2 spin(float turns)\n{\n    return mat2(cos((vec4(0,-1,1,0) + 4. * turns) * hpi));\n}\n\nfloat cross2(vec2 a, vec2 b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\nvec2 perp(vec2 v) { return vec2(1,-1) * v.yx; }\n\nvec2 VelAt(Obj b, vec2 q) // q is local/relative to b\n{\n    return b.v - b.a * perp(q);\n}\n//if (length(q) > abs(b.r)) q = b.r * normalize(q);\n\nvec2 bodyrel(Obj b, vec2 p)\n{\n    p -= b.p; \n    return p;\n}\n\nvec2 bodylocal(Obj b, vec2 p)\n{\n    p -= b.p; \n    p *= spin(b.s); // spin to object local\n    return p;\n}\n/*\nfloat dBox(vec2 q, vec2 e)\n{\n    q = abs(q) - e;\n    return any(lessThan(q, vec2(0))) ? max(q.x, q.y) : length(q);\n}\n\nfloat dShape(vec2 q, vec2 e, float r)\n{\n    return dBox(q, vec2(e)) - r;\n}\n\n// if dBox handled negative extents, draw wouldn't need\n// quite so much kludge to handle them, besides,\n// collision will wind up needing the same kludges.\n// should just make dBox handle negative size gracefully.\n\nfloat dObj(Obj o, vec2 p)\n{\n    p = bodylocal(o, p);\n    float z = o.r,\n      s = sign(z),\n      a = abs(z),\n      c = o.c,\n      l = a - c,\n      w = l * o.h,\n      d = dShape(p, vec2(w, l), c);\n    return d * s;\n}\n\nvec2 gObj(Obj o, vec2 p)\n{\n    vec2 e = vec2(.02,0);\n    return (vec2(dObj(o, p + e.xy), dObj(o, p + e.yx)) - dObj(o, p)) / e.x;\n}\n*/\n// returns normal in xy and distance in z\nvec3 sBox(vec2 q, vec2 e)\n{\n    vec2 s = sign(q);\n    q = abs(q) - e;\n    float l = length(q);\n    return any(lessThan(q, vec2(0))) \n        ? vec3(step(q.yx, q) * s, max(q.x, q.y)) \n        : vec3(s / (l + 1e-14) * q, l);\n}\n    // don't absolutely need to normalize the gradient here btw\n    // caller doesn't expect it fully normalized, just 'in the ballpark' if possible\n    // so could get away with much cheaper length approximations or just not divide by length at all\n    // but had length handy anyway for returning distance, so...\n    // suppose by convention I could return signed squared distance and save the sqrt for later consolidation\nvec3 sObj(Obj o, vec2 p)\n{\n    p = bodylocal(o, p);\n    float z = o.r,\n      s = sign(z),\n      a = abs(z),\n      c = o.c,\n      l = a - c,\n      w = l * o.h;\n    vec3 v = sBox(p, vec2(w, l)) - vec3(0,0,c); //sShape(p, vec2(w, l), c);\n    return vec3(spin(o.s) * v.xy, v.z) * s;\n}\n// should really just change negative radius sphere to a couple of capsule conveyor belts,\n// so I don't have to deal with inverted shapes anymore; they're not convex anyway.\n\n// btw an SDF by itself isn't truly enough data for this algorithm anyway\n// always needs augmented by a gradient function on that field\n\nfloat dObj(Obj o, vec2 p)\n{\n    return sObj(o, p).z;\n}\n// result may not be unit length, necessarily\nvec2 gObj(Obj o, vec2 p)\n{\n    return sObj(o, p).xy; // analytical normal\n}\n//    vec2 e = vec2(1./iResolution.y /*.005*/, 0);\n//    return (vec2(dObj(o, p + e.xy), dObj(o, p + e.yx)) - dObj(o, p)) / e.x; // discrete gradient (still needs normalized)\n\nvec2 Clamp(Obj o, vec2 q)\n{\n    vec3 v = sObj(o, q); return q - max(v.z, 0.) / length(v.xy) * v.xy;\n}\nvec2 Snap(Obj o, vec2 q)\n{\n    vec3 v = sObj(o, q); return q - v.z / length(v.xy) * v.xy;\n}\n\n// FIXME names\nvec2 reject(vec2 q, vec2 d)\n{\n    return - dot(q, d) / dot(d, d) * d;\n}\n\nvec2 remove(vec2 q, vec2 d)\n{\n    return q - max(dot(q, d) / dot(d, d), 0.) * d;\n}\n\nvec2 Snap2(Obj o, vec2 q, vec2 d, vec2 o2p)\n{\n    q += d; // directional bias\n    //q = remove(q - o2p, d) + o2p; // might actually still want this\n    vec2 r = Snap(o, q); //Clamp(o, q); //\n    // tried various ways of guarding against proceeding too far into object past its center where scan would wind up on the back side\n    // luckily, in practice, such tunneling should be rare if physics/scene are tuned/working correctly, and can be dealt with elsewhere\n    //r = remove(r - o2p, o2p-o.p) + o2p;\n    r = remove(r - o.p, o.p - o2p) + o.p;\n    return r;\n}\n// if we ever get a result that's on the wrong side of the shape\n// vs expected (not on side facing other shape) just ignore that result!\n// happens when queries get embedded too deeply in the other shape.\n\n// anti-inlining uniform\n#define IZERO min(0, iFrame)\n\n// goal is to find points on respective objects with\n// gradients facing each other, directly, with minimal distance\n\n// although it's not all that terrible now, it's still not perfect.\n// outputs closest points on respective objects (in world space)\n\n// debugged at http://shadertoy.com/view/DtGBDW\nfloat DistanceBetween(Obj a, Obj b, out vec2 p_a, out vec2 p_b)\n{\n    // could easily devise some early outs if centers are further apart than sum of radii, etc.\n    // or close enough that they surely touch each other's centers, etc.\n    // once one is completely inside the other's radius, it may pay to just use the difference of centers.\n    vec2 bp = b.p;\n    float obr = b.r;\n    if (b.r < 0.) b.r -= .7 * a.r;// + .001; // HACK kludge for outer negated sphere\n    if (b.r < 0.) bp = normalize(a.p - b.p) * (a.r-b.r) + a.p;\n    \n    // use sObj on each, semi-recursive algo\n    vec2 qa = a.p, // + normalize(b.p - a.p) * b.r * sign(a.r)\n      qb = bp;\n    vec2 abias = qa - qb;\n    abias = normalize(abias);\n    abias *= a.r + b.r;\n    abias *= 4.; // or maybe like *= clamp(max(a.r, abs(b.r)), 0., 1e2); or *= b.r < 0. ? 1e2 : b.r + 1.;\n    // for the first query at least, pretend that the object is really far away\n    // which turns it into more of a directional query than a point query\n    // really helps to find pointy corners on flat planar shapes!\n    vec2 qb2 = qb;\n    qb = Snap2(b, qa, abias, a.p);\n    qa = Snap2(a, qb2, -abias, bp);\n    //if (dot(a.p - bp, a.p - bp) > (a.r - b.r)*(a.r - b.r)) {\n    if (dot(a.p - bp, a.p - bp) > .5 * min(a.r * a.r, b.r * b.r)) {\n        // helps when not penetrating, otherwise makes things worse; or does it?  helps find maximal penetration, seems.\n        // but it's good at finding nearest points if separated.\n        for (int l = IZERO + 4; l-- > 0; ) {\n            abias *= .9; // tunable softening factor;  keep it above 0.6 or so? we need the abias to remain about object radius or more here\n            // it doesn't work though if it gets small enough, smaller than the object size or so, can make problems!\n            //if (dObj(a, qb) < 0. && dObj(b, qa) < 0.) break;\n            qb = Snap2(b, qa, abias, a.p);\n            //if (dObj(a, qb) < 0. && dObj(b, qb) < 0.) break;\n            qa = Snap2(a, qb, -abias, bp);\n        }\n        bool isin = dObj(a, qb) < 0. && dObj(b, qa) < 0.; // did we find a penetration?\n        float si = isin ? -1. : 1.; // sign if inside\n        if (isin)\n            for (int l = IZERO + 8; l-- > 0; ) {\n                // remove offsets perpendicular minkowski difference gradient, seek uphill points of max penetration\n                abias = normalize(gObj(a, qa) - gObj(b, qb)) * -2. * (a.r + b.r);\n                vec2 abp = perp(abias);\n                qa += .3 * reject(qa - qb, abp);// * (exp2(-4.*abs(dObj(b, qa)))); // seems needs a relative penetration factor or it's not worth doing\n                qb = Snap2(b, qb, .1 * abias, a.p);\n                qb += .3 * reject(qb - qa, abp);// * (exp2(-4.*abs(dObj(a, qb))));\n                qa = Snap2(a, qa, -.1 * abias, bp);\n                // anyway this loop aligns the points better to the minkowski difference field\n                // but winds up adjusting the point maximally penetrating as much as the other one,\n                // so can cause counterproductive motion of points in certain situations,\n                // which idk what to do about yet\n            }\n        else\n            for (int l = IZERO + 3; l-- > 0; ) {\n                // remove offsets perpendicular minkowski difference gradient, align the points better\n                abias = normalize(gObj(a, qa) - gObj(b, qb)) * .5 * (a.r + b.r);\n                if (isin) abias = -abias;\n                vec2 abp = perp(abias);\n                qa += .2 * reject(qa - qb, abp);\n                qb = Snap2(b, qa, -.02*abias, a.p);\n                qb += .2 * reject(qb - qa, abp);\n                qa = Snap2(a, qb, .02*abias, bp);\n            }\n        b.r = obr; // restore\n        // now one last time with correct radius for b and no abias\n        qb = Snap(b, qb); //Clamp(b, qb); //qb = Snap2(b, qa, abias, a.p); //\n        // just ensure points are on respective surfaces finally\n        qa = Snap(a, qa); //Clamp(a, qa); //\n    }\n    p_a = qa; p_b = qb;\n    bool pen = dObj(a, p_b) <= 0.;\n    return (pen ? -1. : 1.) * distance(p_a, p_b);\n}\n\n// btw an SDF by itself isn't truly enough data for this algorithm anyway\n// always needs augmented by a gradient function on that field\n/* // old\nvec2 Snap(Obj o, vec2 q)\n{\n//    return q - normalize(gObj(o, q)) * max(dObj(o, q), 0.); // try Clamp instead .. doesn't work though\n    return q - normalize(gObj(o, q)) * dObj(o, q);\n}\n\n#define IZERO min(0, iFrame)\n\n// this algorithm as stated only really works for spheres\n// BUT if the shape function were slightly augmented so that\n// Snap were provided slightly more data (the query as a sphere\n// instead of as a point) it would be able to handle\n// planar convex shapes just fine; then the 'shape'\n// would need a function to compute the nearest point\n// on the shape (like a GJK support point) but with additional\n// information about the surface curvature radius at that point.\n// I did this long ago and it works out great.\n\n// TODO replace with GJK, this isn't reliable enough.\n// although it's not all that terrible now, it's still not perfect.\n// outputs closest points on respective objects (in world space)\nfloat DistanceBetween(Obj a, Obj b, out vec2 p_a, out vec2 p_b)\n{\n    float obr = b.r;\n    if (b.r < 0.) b.r -= .7 * a.r;// + .001; // HACK kludge for 'infinite' outer negated sphere\n    \n    // use dShape on each, semi-recursive algo\n    vec2 qa = a.p, // + normalize(b.p - a.p) * b.r * sign(a.r)\n      qb = b.p;\n    // for the first query at least, pretend that the object is really far away\n    // which turns it into more of a directional query than a point query\n    vec2 abias = qa - qb;\n    abias *= 4.; //16.; //32.; //256.; // or maybe like *= clamp(max(a.r, abs(b.r)), 0., 1e2); or *= b.r < 0. ? 1e2 : b.r + 1.;\n    qa += abias; // just do this once.\n    qb = Snap(b, qa);\n    qb -= (a.p - qb) * 2.; //4.; //16.; //abias; // just do this once.\n    qa = Snap(a, qb);\n    for (int l = IZERO + 2; l-- > 0; ) {\n        //qa += abias;\n        qb = Snap(b, qa);\n        //vec2 oqa = qa;\n        qa = Snap(a, qb);\n        //qa = mix(oqa, qa, exp2(-float(l))); // idk if this helps either\n    }\n    b.r = obr; // restore\n    qb = Snap(b, qa); // now one last time with correct radius for b and no abias\n    p_a = qa; p_b = qb;\n    return dObj(a, p_b);//dObj(b, p_a); // * sign(b.r); //length(p_a - p_b); //\n}\n*/\n// it might be simpler to try to identify a separating axis,\n// a normal to a separating plane\n\n// TDM from http://shadertoy.com/view/NtlGz7\n\n// hitpoint is midpoint between nearest points on bodies to each other\n// elasticity is b0.kRest * b1.kRest\n// penetration is -distance between bodies, assumed positive here\n// only resolves collision that was previously detected elsewhere\nvec2 collision(inout Obj b0, in Obj b1, vec2 vrel, float elasticity, float friction, vec2 hitpoint, vec2 normal, float penetration) // normal faces b0\n{\n    vec2 r0 = bodyrel(b0, hitpoint);\n    vec2 r1 = bodyrel(b1, hitpoint); // caller already computed these, optimizer should handle combining them\n\n    float w0 = cross2(r0, normal);\n    float w1 = cross2(r1, normal);\n\n    float imass0 = b0.imass, //.2 / b0.r / b0.r, //1., //\n          imass1 = b1.imass; //0.; //b1.r < 0. ? 0. : 1.;//\n    // inverse mom of inertia for cylinder or box\n    //float b0a2 = b0.r * max(b0.h, .001); // handle box\n    //float btens = 4. / b0.r / b0a2, //1. / (.5 * (1./(imass0+1e-9)) * b0.r), //3.5 / b0.r / b0.r, //99.1, //b0.imom,\n    //    ctens = 2. / b0.r / b0.r;\n    float imom0 = b0.imom, //imass0 * mix(btens, ctens, b0.c/b0.r),\n          imom1 = b1.imom; //0.; //b1.r < 0. ? 0. : 1. / (.5 * (1./(imass1+1e-9)) * b1.r); //b1.imom;\n\n    float a = (1. + elasticity) * dot(normal, vrel);\n    float b = imass0 + imass1 + w0 * w0 * imom0 + w1 * w1 * imom1;\n    float vin = max(-a / b, 0.); // restitution impulse along contact normal\n\n    vec2 tangent = perp(normal);\n    // turns out the perps cancel; sign doesn't matter a lot because gets squared anyway, but u0 does matter.\n    // seems important to sim stability.\n    float u0 = -dot(r0, normal);\n    float u1 = -dot(r1, normal);\n\n    a = (0. + friction) * dot(tangent, vrel); //a = (1. + elasticity) * dot(tangent, vrel); // * friction; //\n    b = imass0 + imass1 + u0 * u0 * imom0 + u1 * u1 * imom1;\n    float vit = clamp(-a / b, -vin, vin); // limit friction impulse to restitution impulse\n    // combined\n    b0.v += imass0 * (normal * vin + tangent * vit);\n\n    b0.a += imom0 * (w0 * vin + u0 * vit); // vin here only applies to off-axis collisions like for boxes\n\n    return imass0 / (imass0 + imass1) //.5 // should handle relative mass\n        * penetration * normal;\n}\n\n// fenix from http://shadertoy.com/view/csVyWw\n// works great, much simpler, but think it does not consider angular impulses at contact as completely\n// resolve velocity errors against another particle or the boundary\n// designed for scene where all bodies were identical discs\n//\n//  rv   - relative velocity\n//  n    - contact normal\n//  nav  - neighbor angular velocity\n//  elas - elasticity\n//  lv   - linear velocity\n//  av   - angular velocity (radians/s)\nvoid constraint(vec2 rv, vec2 n, float nav, float elas, float fric, float radius, inout vec2 lv, inout float av)\n{\n    vec2 t = vec2(n.y, -n.x); // tangent = perp\n    float nv = -dot(rv, n); // normal velocity\n    float ni = (elas + 1.) * max(0., nv); // normal impulse\n    float tv = -dot(rv, t) - (av + nav) * radius; // tangent velocity\n    float fi = clamp(tv, -fric * ni, fric * ni); // friction impulse\n    lv += ni * n + fi * t;// * radius; // linear impulses normal and tangential\n    av += fi; // / radius; //  angular impulse due to friction\n}\n\n// mine, old crap, barely works\n// p = pos of a center relative impact pt, v = vel, a = angvel radians/s, n = normal direction, d = distance between surfaces,\n// x = radius, relmass = relative mass, kRest = restitution/bounce, dt = delta time\n// ASSUMES d < 0.\nbool bounce(vec2 p, vec2 v, float a,\n    vec2 n, float d, float x, float relmass, float kRest, float dt,\n    out vec2 ml, out vec2 il, out float ma, out float ia)\n{\n    ml = il = vec2(0); ma = ia = 0.;\n    bool r = true;\n    float omrm = 1. - relmass;\n    ml -= d * omrm * n;\n    float nv = dot(n, v);\n    //if (nv <= 0.) {\n        float boing = (1. + kRest) * omrm,\n          f = cross2(v, n),\n          cv = f, // * 1./tau / x; // * x; // f * -x / dt\n          fric = .8;\n        //a = mix(cv, a, exp2(-.6*dt)); // \"friction\" due to motion perpendicular to normal\n        ia -= (cv + a) * length(p) * (1.-exp2(-32.*dt)) * omrm; //  / exp2(2. * dt); //\n        //float ac = dot(p, n) / x, as = sqrt(max(0., 1.-ac*ac)); //sin2cos(ac); //\n        il -= boing * nv * n;// * ac;\n        //ma += cross2(p, v) * d * omrm;\n        //ia += a * boing * nv * length(p) / x; // just reduces ang vel\n        //ia += omrm * nv * tau * 1. * cross2(p, n) / x; // * as\n        //ia += omrm * cross2(p, v) / x * tau * 1. * as; // * tau;// * 2.; //(nv) * // * (1.+nv); // * boing;\n        //ia -= 2. * f * dt; //* as;//  unreliable force friction method\n        //v += (cv - a)/* * x*/ * 522.4 * dt * perp(n); //vec2(1,-1) * n.yx; // * length(v); // reaction\n    //} else r = false;\n    return r;\n}\n\nvoid Collide(inout Obj a, Obj b, float dt)\n{\n    vec2 p_b, p_a;\n    float db = DistanceBetween(a, b, p_a, p_b);\n    if (db > 0.)\n        return;\n    float kRest = .5; //0.; //1.; //a.k * b.k; // restitution/elasticity\n    float kFric = 1.*.98; // friction\n    bool hit = true; \n    //vec2 h = normalize(p_a - p_b), //oi.p - oj.p),\n    //  n = -h; // hardcode obj[0] delta\n    vec2 hpw = (p_a + p_b) * .5;\n    //if (dot(n, a.p - b.p) < 0.) n = -n;\n    vec2 n = normalize(a.p - b.p); //normalize(gObj(b, hpw/*p_b*/) - gObj(a, hpw/*p_a*/));\n      // normal faces a\n    if (b.r < 0.) n = -n;\n    float pen = -db;\n    if (pen > 0.) {\n        vec2 rv = VelAt(a, bodyrel(a, p_a)) - VelAt(b, bodyrel(b, p_b));\n\n       // I borrowed from TDM and fenix to try to help debug my crap,\n       // but they work way better than mine (so far) so just use them.\n       // FIXME at least consolidate the interfaces!\n     #if 1\n        // use TDM tech\n        vec2 m = collision(a, b, rv, kRest, kFric, hpw, n, pen);\n        a.p += m;\n     #elif 1\n        // use fenix tech\n        a.a *= tau;\n        constraint(rv, n, 0., kRest, kFric, a.r, a.v, a.a);\n        a.p += n * pen;\n        a.a /= tau;\n     #else\n        // use spalmer tech (not nearly as good quality yet)\n        // FIXME my collisions are losing energy\n        // FIXME need contact forces to resist gravity\n        vec2 ml, il;\n        float ma, ia;\n        bool hit = bounce(a.p - p_a, rv, a.a, n, \n            db, \n            a.r,\n            0., kRest, dt,\n            ml, il, ma, ia);\n        //v += rb;\n        //float ac = a.a;\n        //ia += cross2(f, a.p - p_a) * f;\n        // TODO should definitely consider position force/impulse applied to\n        // relative object center, should affect angular momentum\n        a.p += ml;\n        if (hit) { // only update rest if collided\n            a.v += il; // * dt\n            a.s += ma;\n            a.a += ia; // * dt\n        }\n     #endif\n    }\n}\n\n\nObj load(int q)\n{\n    // NDR data pixel rows\n    vec4 d = texelFetch(iChannel0, ivec2(q,0), 0);\n    vec4 e = texelFetch(iChannel0, ivec2(q,1), 0);\n    vec4 f = texelFetch(iChannel0, ivec2(q,2), 0);\n    Obj o;\n    o.p = d.xy;\n    o.v = d.zw; //vec2(0);\n    o.s = e.x;\n    o.a = e.y;\n    o.r = e.z; //q == 0 ? 1. : .25; //d.w;\n    o.h = e.w;\n    o.c = f.x;\n    o.imass = f.y;\n    o.imom = f.z;\n    return o;\n}\n\nvec4 store(Obj o, int di) // di is which row of data pixel\n{\n    return di == 0 ? vec4(o.p, o.v) : \n           di == 1 ? vec4(o.s, o.a, o.r, o.h) :\n                     vec4(o.c, o.imass, o.imom, 0);\n}\n\n// HACK global variables for body state\nObj os[NOBJ];\n\nvec4 Physics(ivec2 q)\n{\n    float dt = clamp(iTimeDelta, 1./144., 1./30.);\n    //dt *= .25; // HACK slow motion\n    float nssiter = 3. - min(0., iTime); // substeps\n    dt /= nssiter;\n    for (; nssiter-- > 0.; )\n    {\n    // we might need to predict all the objects,\n    // but could probably arrange so we don't have to.\n    // FIXME should ideally only need to process the one body, q!\n    for (int i = IZERO + NOBJ; i-- > 1; ) {\n    //int i = q.x; // was only updating 'this' object at one point\n        Obj o = os[i];\n        // for the substeps to help, must actually simulate the other objects!\n        // that'll get expensive quick.\n        if (o.r >= 0.) { // not infinite mass\n            vec2 f = vec2(0,-1.); // gravity\n            if (iMouse.z > 0.)\n                o.v += vec2(.001,.007);\n            o.v += dt * f;\n            o.p += dt * o.v + .5 * dt * f; // midpoint integration\n            o.s += dt * o.a; // rotate (no torque to integrate, here)\n            o.s = fract(o.s);\n            //vec2 v = oi.v;\n            //vec2 m = vec2(0);\n            for (int j = NOBJ; j-- > 0; ) {\n                if (i == j) continue;\n                Collide(o, os[j], dt);\n                //m += ...; // TODO sum all contact impulses\n            }\n            //o.p += m;\n            //o.v = v;\n            //o.a = mix(5.1, o.a, exp2(-44.1*dt)); //oi.a += 4.1 * dt; // limited motor torque\n            o.a *= exp2(-.01*dt); // fake angular damping (not a proper force / torque)\n            os[i] = o;\n        }\n    }\n    //return store(o, q.y); // was only updating 'this' object at one point\n    }\n    return store(os[q.x], q.y);\n}\n\n// NOTE that the big hollow disc is NOT a convex shape,\n// and my collision/object separation distance stuff\n// assumes convexity, so it only really works halfway well\n// on the container when the moving objects are relatively small.\nvoid Setup()\n{\n    if (iFrame < 3) {\n        for (int i = IZERO + NOBJ; i-- > 0; ) {\n            float j = float(i);\n            Obj o;\n            o.p = vec2(-1.7,-.5) + .2 * j;\n            o.v = spin(j * .1)[1] * (-.1 + mod(iDate.w, .2));\n            o.s = float(i) * .1;\n            o.a = 1.02 + mod(iDate.w, .4);\n            o.r = .15 - mod(iDate.w * 7. + j * .11, .1); // keep them small so the non-convex container doesn't cause too much trouble\n            o.h = 1. - mod(iDate.w + j * .2, .7);\n            o.c = o.r * mix(.02, .98, mod(iDate.w * 3. + j * .31, 1.)); //.125;\n            os[i] = o;\n        }\n        os[1].p = vec2(0. * -1.6, -.80); //- os[1].r; //\n        os[1].v = vec2(0);\n        os[1].a = 0.;\n        //os[1].h = .0; // make capsule\n        //os[1].c = .0; // make unrounded\n        os[1].c = os[1].r; // make disc\n        for (int i = IZERO + NOBJ; i-- > 0; ) {\n            Obj o = os[i];\n        float imass0 = 1.; //.2 / o.r / o.r; //\n        //      imass1 = 0.; //b1.r < 0. ? 0. : 1.; //\n        // inverse mom of inertia for cylinder or box\n        float oa2 = o.r * max(o.h, .001); // handle box\n        float btens = 4. / o.r / oa2, //1. / (.5 * (1./(imass0+1e-9)) * b0.r), //3.5 / b0.r / b0.r, //99.1, //b0.imom,\n            ctens = 2. / o.r / o.r;\n        float imom0 = imass0 * mix(btens, ctens, o.c/o.r); // hopefully handles round box!\n        //      imom1 = 0.; //b1.r < 0. ? 0. : 1. / (.5 * (1./(imass1+1e-9)) * b1.r); //b1.imom;\n           //1. / (.5 * (1./o.imass) * body.r * body.r); // for solid disc\n            o.imass = imass0;\n            o.imom = imom0;\n            os[i] = o;\n        }\n    } else {\n        for (int i = IZERO + NOBJ; i-- > 0; )\n            os[i] = load(i);\n    }\n    os[0].r = -8.; //-1.; // inside-out\n    os[0].p = vec2(0, .02 -1. - os[0].r); //0,0); // container at fixed location\n    os[0].c = abs(os[0].r);\n    os[0].v = vec2(0); // unmoving\n    os[0].a = 0.3 / os[0].r; // container fixed rotation rate\n    os[0].s = iTime * os[0].a;\n//    os[0].s = sin(iTime) * .5/acos(-1.); // animate container\n//    os[0].a = cos(iTime) * 2.;\n    //os[0].a = cos(iTime) / acos(1.);\n    \n    // if one of the objects is a disc, it drastically simplifies the interaction\n    // because simple discs, like, work fine w these algorithms\n    //os[2].c = os[2].r; // make disc\n}\n\nvec3 draw(Obj o, int i, vec2 p, float aa)\n{\n    vec2 p_l = (p - o.p) * spin(o.s);\n    return clamp(.5 - aa * dObj(o, p), 0., 1.)\n        * texture(iChannel1, 2. * p_l).r\n        * mix(max(cos(vec3(0,2,4) + .31*3.14*float(i)), 0.), vec3(1), .5)\n        //* mix(vec3(normalize(gObj(o, p)), 0), vec3(1), .5)\n        ;\n}\n\nfloat dSeg(vec2 q, vec2 a, vec2 b)\n{\n    q -= a; b -= a;\n    return length(q - b * clamp(dot(q,b) / dot(b,b), 0., 1.));\n}\n\nvec3 Draw(vec2 p)\n{\n    vec2 R = iResolution.xy;\n    vec2 q = p;\n    q -= R * .5; // centered\n    float aa = R.y * .5;\n    q /= aa; // DI coords\n    vec3 c = vec3(0);\n\n    // brute force is fine for now\n    for (int i = IZERO + NOBJ; i-- > 0; )\n        c += draw(os[i], i, q, aa);\n\n    c = vec3(min(c, 1.));\n\n    vec2 g_a, g_b;\n    Obj o = os[1];\n    float rx = DistanceBetween(o, os[0], g_a, g_b);\n    vec2 v_a = VelAt(o, bodyrel(o, g_a)); //o.v;\n    //v_a += perp(o.p - g_a)/o.r * o.a;\n    // antialiased debug dots / lines\n    c = mix(c, vec3(0,1,1), clamp(.5 - 2. * (aa * length(q - g_a) - 2.5), 0., 1.));\n    c = mix(c, vec3(0,.6,.6), clamp(.5 - 2. * (aa * dSeg(q, g_a, g_a + v_a * 50./aa) - 1.), 0., 1.));\n    vec2 Q = vec2(.2,-.95); o = os[0]; // debug the container\n    c = mix(c, vec3(1,0,1), clamp(.5 - 2. * (aa * length(q - g_b) - 2.5), 0., 1.));\n    c = mix(c, vec3(.6,0,.0), clamp(.5 - 2. * (aa * dSeg(q, Q, Q + VelAt(o, bodyrel(o, Q)) * 50./aa) - 1.), 0., 1.));\n    c = mix(c, vec3(1,0,0), clamp(.5 - 2. * (aa * length(q - Q) - 2.5), 0., 1.));\n    return c; // linear color\n}\n\nvoid mainImage(out vec4 bufa, vec2 p)\n{\n    ivec2 q = ivec2(p);\n    Setup();\n    if (q.y < NDR && q.x < NOBJ) { // data pixels\n        bufa = Physics(q);\n    } else { // non-data pixels - draw the scene\n        bufa = vec4(sqrt(Draw(p)), 1);\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// num objects\n#define NOBJ 2\n// num data rows\n#define NDR  3","name":"Common","description":"","type":"common"}]}