{"ver":"0.1","info":{"id":"7sdBRn","date":"1655946665","viewed":121,"name":"Sea of Fire","username":"fenix","description":"*Drag with mouse*\n\nAdded density transport via gaussian blur from FabriceNeyret2's smart gaussian blur: https://www.shadertoy.com/view/WtKfD3\n\nStill have some serious issues e.g. volume loss to look into, but this seemed like a fun enough toy to share.","likes":4,"published":1,"flags":48,"usePreview":0,"tags":["2d","voronoi","simulation","particles"],"hasliked":0,"parentid":"fs3fRn","parentname":"Sticky Sparks"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float MAX_TEMP = 0.135;\n\nvec3 BlackBody(float _t)\n{\n    vec3 temp = vec3(min(1.0, _t / (1.5 * MAX_TEMP)), min(1.0, _t / (3.0 * MAX_TEMP)), min(1.0, _t / (5.0 * MAX_TEMP)));\n    return temp * temp * temp * temp;\n}\n\nvoid renderParticle(in vec2 newPos, in vec2 oldPos, float density, in vec2 fragCoord, inout vec4 fragColor)\n{    \n    vec2 closest;\n    float dist = linePointDist2(newPos, oldPos, fragCoord, iResolution, closest);\n    \n    if (dist < 25.0* PARTICLE_SIZE * PARTICLE_SIZE)\n    {\n        fragColor.xyz += BlackBody((5.0*PARTICLE_SIZE - sqrt(dist)) * density * 0.5 ) / (PARTICLE_SIZE);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n    \n    fragColor = vec4(0);\n  \tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.xy;\n\n    //get the id's of the 4 particles that (should be) closest.\n    //the 4 ids are stored in .x, .y, .z, .w\n    ivec4 ids = fxGetClosest(ivec2(fragCoord));\n    \n    //draw the particles\n    for(int i = 0; i < 4; i++){\n        //get the particles position\n        int id = ids[i];\n        fxParticle particle = fxGetParticle(id);\n        vec2 pos = particle.pos;\n        vec2 vel = particle.vel;\n\n        renderParticle(pos, pos - vel, particle.density, p, fragColor);\n    }\n    //fragColor = texture(iChannel2, fragCoord / iResolution.xy);   \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// The code is not optimized for speed; it turns out programming with integers can be slow on some GPU's.\n// The reason I still use them is readability of the code.\n\n\n//amount of particles\nconst int PARTICLES = 10000; \nconst int PARTICLE_INIT_X = 10;\nconst float PARTICLE_SIZE = 0.011;\nconst float PARTICLE_REPEL_SIZE = 0.02;\n\n//percentage of maximum allowed speed\nconst float SPEED = 1.;\n\n//hashing noise by IQ\nfloat hash( int k ) {\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\nvec2 world2screenInternal(in vec2 p, in vec2 resolution)\n{\n    return (p + 1.0) * 0.5 * resolution;\n}\n\n#define world2screen(X) world2screenInternal(X, iResolution.xy)\n\nvec2 screen2worldInternal(in vec2 p, in vec2 resolution)\n{\n    return (p / resolution) * 2.0 - 1.0;\n}\n\n#define screen2world(X) screen2worldInternal(X, iResolution.xy)\n\nconst vec4 SCENE_LINES[5] = vec4[]( vec4(-1.0, -1.0, 1.0, -1.0),\n    vec4(1.0, 1.0, -1.0, 1.0),\n    vec4(-1.0, 1.0, -1.0, -1.0),\n    vec4(1.0, -1.0, 1.0, 1.0),\n    vec4(-0.4, 0.7, -0.4, -0.5));\n    \nconst int NUM_SCENE_LINES = 4;\nconst int NUM_SCENE_WALLS = 4;\n\nfloat cross2(vec2 a, vec2 b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\nbool intersectPlane(vec2 p0, vec2 p1, vec2 p2, vec2 p3, in float minT, out float t, out vec2 n)\n{ \n    vec2 CmP = p2 - p0;\n    vec2 r = p1 - p0;\n    vec2 s = p3 - p2;\n\n    float CmPxr = cross2(CmP, r);\n    float CmPxs = cross2(CmP, s);\n    float rxs = cross2(r, s);\n\n    if (CmPxr == 0.0)\n    {\n        // Lines are collinear, and so intersect if they have any overlap\n        return false;\n        //return ((C.X - A.X < 0f) != (C.X - B.X < 0f))\n          //  || ((C.Y - A.Y < 0f) != (C.Y - B.Y < 0f));\n    }\n\n    if (rxs == 0.0)\n        return false; // Lines are parallel.\n\n    float rxsr = 1.0 / rxs;\n    t = CmPxs * rxsr;\n    float u = CmPxr * rxsr;\n\n    if (t >= 0.0 && t <= minT && u >= 0.0 && u <= 1.0)\n    {\n        n = normalize(vec2(-s.y, s.x));\n        \n        if (rxs < 0.0) n = -n;\n        \n        return true;\n    }\n    \n    return false;\n} \n\nbool intersectScene(vec2 from, vec2 to, out float t, out vec2 n)\n{\n    float intersectT;\n    vec2 intersectNormal;\n\n    float minT = 1.0;\n    bool hit = false;\n    for (int index = 0; index < NUM_SCENE_LINES; ++index)\n    {\n        vec2 sceneFrom = SCENE_LINES[index].xy;\n        vec2 sceneTo = SCENE_LINES[index].zw;\n        \n        if(intersectPlane(from, to, sceneFrom, sceneTo, minT, intersectT, intersectNormal))\n        {\n            t = minT = intersectT;\n            n = intersectNormal;\n            hit = true;\n        }\n    }\n\n    return hit;\n}\n\nfloat linePointDist2(in vec2 newPos, in vec2 oldPos, in vec2 fragCoord, in vec3 resolution, out vec2 closest)\n{\n    vec2 pDelta = (fragCoord - oldPos);\n    vec2 delta = newPos - oldPos;\n    float deltaLen2 = dot(delta, delta);\n\n    // Find the closest point on the line segment from old to new\n    closest;\n    if (deltaLen2 > 0.0000001)\n    {\n        float deltaInvSqrt = inversesqrt(deltaLen2);\n        vec2 deltaNorm = delta * deltaInvSqrt;\n        closest = oldPos + deltaNorm * max(0.0, min(1.0 / deltaInvSqrt, dot(deltaNorm, pDelta)));\n    }\n    else\n    {\n        closest = oldPos;\n    }\n\n    // Distance to closest point on line segment\n    vec2 closestDelta = closest - fragCoord;\n    closestDelta *= resolution.xy / resolution.y;\n    return dot(closestDelta, closestDelta);\n}\n\nfloat halfSpaceDist(vec2 sceneFrom, vec2 sceneTo, vec2 point, vec3 resolution)\n{\n    vec2 dir = normalize(sceneTo - sceneFrom);\n    vec2 normal = vec2(-dir.y, dir.x) * resolution.xy / resolution.y;\n    return dot(point - sceneTo, normal);\n}\n\nfloat distanceFromWalls(vec2 point, vec3 resolution)\n{\n    float minDist = 1e30;\n    for (int index = 0; index < NUM_SCENE_WALLS; ++index)\n    {\n        vec2 sceneFrom = SCENE_LINES[index].xy;\n        vec2 sceneTo = SCENE_LINES[index].zw;\n        \n        float dist = halfSpaceDist(sceneFrom, sceneTo, point, resolution);\n        \n        if (dist < minDist)\n        {\n            minDist = dist;\n        }\n    }\n    return minDist;\n}\n\nvec2 getNormalFromWalls( vec2 point, vec3 resolution )\n{\n\tvec2 tinyChangeX = vec2( 0.001, 0.0 );\n    vec2 tinyChangeY = vec2( 0.0 , 0.001 );\n    \n   \tfloat upTinyChangeInX   = distanceFromWalls( point + tinyChangeX, resolution ); \n    float downTinyChangeInX = distanceFromWalls( point - tinyChangeX, resolution ); \n    \n    float tinyChangeInX = upTinyChangeInX - downTinyChangeInX;\n    \n    \n    float upTinyChangeInY   = distanceFromWalls( point + tinyChangeY, resolution ); \n    float downTinyChangeInY = distanceFromWalls( point - tinyChangeY, resolution ); \n    \n    float tinyChangeInY = upTinyChangeInY - downTinyChangeInY;\n    \n    \n\tvec2 normal = vec2(\n         \t\t\ttinyChangeInX,\n        \t\t\ttinyChangeInY\n    \t \t\t  );\n    \n\treturn normalize(normal);\n}\n\nfloat distanceFromScene(vec2 point, vec3 resolution, out vec2 n)\n{\n    float number = 0.0;\n    \n    float minDist = distanceFromWalls(point, resolution);\n    n = getNormalFromWalls(point, resolution);\n    for (int index = NUM_SCENE_WALLS; index < NUM_SCENE_LINES; ++index)\n    {\n        vec2 sceneFrom = SCENE_LINES[index].xy;\n        vec2 sceneTo = SCENE_LINES[index].zw;\n        \n        vec2 closest;\n        float dist = linePointDist2(sceneFrom, sceneTo, point, resolution, closest);\n        if (dist < minDist)\n        {\n            minDist = sqrt(dist);\n            n += normalize(point - closest);\n            ++number;\n        }\n    }\n    \n    n = normalize(n);\n    return minDist;\n}\n\n//returns the ids of the four closest particles from the input\nivec4 fxGetClosestInternal(sampler2D sampler, ivec2 xy)\n{\n    return ivec4(texelFetch(sampler, xy, 0));\n}\n\n#define fxGetClosest(X) fxGetClosestInternal(iChannel1, X)\n\n#define POS_VEL 0\n#define DENSITY 1\n#define NUM_PARTICLE_DATA_TYPES 2\n\n//returns the location of the particle within the particle buffer corresponding with the input id \nivec2 fxLocFromIDInternal(int width, int id, int dataType)\n{\n    int index = id * NUM_PARTICLE_DATA_TYPES + dataType;\n    return ivec2( index % width, index / width);\n}\n\n#define fxLocFromID(X, Y) fxLocFromIDInternal(int(iResolution.x), X, Y)\n\nstruct fxParticle\n{\n    vec2 pos;\n    vec2 vel;\n    float density;\n};\n\n//get the particle corresponding to the input id\nfxParticle fxGetParticleInternal(sampler2D sampler, int resolutionWidth, int id)\n{\n    vec4 particleData0 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, POS_VEL), 0);\n    vec4 particleData1 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, DENSITY), 0);\n    \n    fxParticle particle;\n    particle.pos = particleData0.xy;\n    particle.vel = particleData0.zw;\n    particle.density = particleData1.x;\n    \n    return particle;\n}\n\n#define fxGetParticle(X) fxGetParticleInternal(iChannel0, int(iResolution.x), X)\n\nvec2 fxGetParticlePosInternal(sampler2D sampler, int resolutionWidth, int id)\n{\n    vec4 particleData0 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, POS_VEL), 0);\n    \n    return particleData0.xy;\n}\n\n#define fxGetParticlePos(X) fxGetParticlePosInternal(iChannel0, int(iResolution.x), X)\n\nconst float PI = 3.141592653589793;\n\nfloat SPHkernel (float x)\n{\n    //return (0.5 - smoothstep(0.0, 1.0, (dist - PARTICLE_SIZE))) * 0.001;\n//    return -(PARTICLE_SIZE - dist);\n//if (x > 0.4)\n//    return min(0.9, max(0.1, x));\n    \n    //return 4.0 * cos(x * PI * 0.25) + cos(x * PI * 0.5) - 3.0;\n    //if (x > 3.0) return 0.0;\n    //if (x < 0.0) return 1.0;\n    //return -4.0 * sin(x * PI * 2.0) + 0.5 * cos(x * PI * 1.0);\n    //const float h = 0.21/0.4;\n    //return exp(-sqr(x/h))/(PI*sqr(h));    //x*=2.0;\n    //float y = ( 1.0 / ( 1.0 * sqrt(2.0*PI) ) ) * exp( -0.5 * pow( (x), 2.0 ) ) * 0.5 + 0.1;\n    //return max(0.0, 0.0);\n    //return 2.*x*Kernel(x,h)/sqr(h);\n    return cos(x) + cos(x + x) - 1.0 / (x * x + 2.0);\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Particle Buffer\n// in this buffer every pixel represents a particle\n// the particles positions is stored in .xy\n//           its velocity  is stored in .zw\n// Only the first PARTICLES amount of pixels are actually used.\n\nconst vec2 GRAVITY = vec2(0.0000, -0.015);\nconst float MAX_SPEED = 0.003;\nconst float DAMPING = 0.99;\nconst float PARTICLE_REPEL = 0.00002;\nconst float WALL_REPEL = 0.0;\n\nvec4 saveParticle(fxParticle particle, int dataType);\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n    ivec2 iFragCoord = ivec2(fragCoord);\n    \n    //we only simulate PARTICLES amount of particles\n    int index = iFragCoord.x + iFragCoord.y*int(iResolution.x);\n    int id = index / 2;\n    //if(id>=PARTICLES) return;\n    \n    fxParticle oldData = fxGetParticle(id);\n    fxParticle newData = oldData;\n    \n    if(iFrame==0 || oldData.pos == vec2(0.0, 0.0)){\n       \t//pick a \"random\" starting position\n        float h1 = hash(id);\n        float h2 = hash(int(h1*41343.));\n        newData.pos = vec2(h1,h2) * vec2(2.0, 2.0) - vec2(1.0, 1.0);\n        newData.vel = vec2(0);\n        newData.density = 0.0;\n    }\n    else\n    {\n        newData.vel = oldData.vel * DAMPING + GRAVITY * 0.033;\n        vec2 disturbPos = vec2(0.0, 0.0);\n        vec2 disturbDelta = vec2(0.0, 0.0);\n        if (iMouse.z > 0.0 && iMouse.w < 0.0)\n        {\n            disturbPos = ((2.0 * iMouse.xy / iResolution.xy) - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);\n            disturbDelta = (iMouse.xy - vec2(iMouse.z, -iMouse.w));\n            disturbDelta = clamp(disturbDelta, -100.0, 100.0);\n        }\n        else\n        {\n            disturbPos = vec2(sin(iTime * 0.5), sin(iTime * 1.0))* vec2(1.2, 0.2) + vec2(0.0, -0.4);\n            disturbDelta = 100.0 * vec2(cos(iTime * 0.5), cos(iTime * 1.0));\n        }\n        const float MOUSE_FIELD_SIZE = 0.3;\n        const float MOUSE_FIELD_STRENGTH = 0.25;\n        float dist = distance(newData.pos * iResolution.xy / iResolution.y, disturbPos);\n        if (dist < MOUSE_FIELD_SIZE)\n        {\n            newData.vel += (MOUSE_FIELD_SIZE - dist) * MOUSE_FIELD_STRENGTH * disturbDelta / iResolution.xy;\n        }\n\n    #if 1\n        ivec4 closest = fxGetClosest(ivec2(world2screen(oldData.pos)));\n        float density = texture(iChannel2, newData.pos * 0.5 + 0.5).x;\n        float densityU = texture(iChannel2, newData.pos * 0.5 + 0.5 + vec2( 0.0,  1.0) / iResolution.xy).x;\n        float densityD = texture(iChannel2, newData.pos * 0.5 + 0.5 + vec2( 0.0, -1.0) / iResolution.xy).x;\n        float densityL = texture(iChannel2, newData.pos * 0.5 + 0.5 + vec2(-1.0,  0.0) / iResolution.xy).x;\n        float densityR = texture(iChannel2, newData.pos * 0.5 + 0.5 + vec2( 1.0,  0.0) / iResolution.xy).x;\n        vec2 densityGrad = vec2(densityR - densityL, densityU - densityD);\n        newData.density = density;\n        for(int i = 0; i < 4; i++){\n            int cid = closest[i];\n            if(cid==id) continue;\n\n            fxParticle otherData = fxGetParticle(cid);\n            vec2 otherPos = otherData.pos + otherData.vel;\n            vec2 delta = otherPos - newData.pos;\n            float dist = length(delta);\n\n            //density += 1.0 / dist;\n            if (dist < (PARTICLE_SIZE + PARTICLE_SIZE))\n            {\n                if (dist < 0.0000001)\n                {\n                    delta = vec2(sign(id - cid), 0.0);\n                }\n                else\n                {\n                    delta = delta / dist;\n                }\n                newData.pos -= delta * PARTICLE_SIZE;\n            }\n            {\n                newData.vel -= PARTICLE_REPEL * SPHkernel(dist / PARTICLE_REPEL_SIZE) * normalize(delta);\n                newData.vel -= densityGrad * 0.005;\n            }\n        }\n    #endif\n\n        vec2 distNormal;\n        float distToScene = distanceFromScene(newData.pos, iResolution, distNormal);\n \n        if (distToScene < PARTICLE_SIZE * 2.0)\n        {\n            newData.pos += distNormal * (distToScene - PARTICLE_SIZE - PARTICLE_SIZE);\n            \n            float dp = dot(newData.vel, distNormal);\n            if (dp < 0.0)\n            {\n                newData.vel -= distNormal * dp;\n            }\n        }\n        newData.pos = oldData.pos + newData.vel;\n        newData.vel = clamp(newData.vel, -MAX_SPEED, MAX_SPEED);\n    }\n    \n    fragColor = saveParticle(newData, index - id * NUM_PARTICLE_DATA_TYPES);\n}\n\nvec4 saveParticle(fxParticle p, int dataType)\n{    \n    switch(dataType)\n    {\n    case 0:  \n        return vec4(p.pos, p.vel);\n    case 1:\n        return vec4(p.density, 0.0, 0.0, 0.0);\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Voronoi Buffer\n// every pixel stores the 4 closest particles to it\n// every frame this data is shared between neighbours\n\nfloat distance2Particle(int id, vec2 fragCoord){\n    if(id==-1) return 1e20;\n    vec2 delta = fxGetParticlePos(id)-fragCoord;\n    return dot(delta, delta);\n}\n\nvoid insertion_sort(inout ivec4 i, inout vec4 d, int i_, float d_){\t\n    if(any(equal(ivec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = ivec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = ivec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = ivec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = ivec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n   \tivec2 iFragCoord = ivec2(fragCoord);\n\n    //in this vector the four new closest particles' ids will be stored\n    ivec4 new = ivec4(-1);\n    //in this vector the distance to these particles will be stored \n    vec4 dis = vec4(1e20);\n    \n    for(int x=-3; x<=3; x++){\n        for(int y=-3; y<=3; y++){\n            ivec4 old   = fxGetClosest( iFragCoord + ivec2( x, y) );      \n\n            for(int j=0; j<4; j++){\n                int id = old[j];\n                float dis2 = distance2Particle(id, screen2world(fragCoord));\n                insertion_sort( new, dis, id, dis2 );\n            }\n        }\n    }\n    \n    int searchIterations = 10;\n    if (iFrame < 5)\n    {\n        searchIterations = 100;\n    }\n    for(int k = 0; k < searchIterations; k++){\n        //random hash. We should make sure that two pixels in the same frame never make the same hash!\n        float h = hash(\n            iFragCoord.x + \n            iFragCoord.y*int(iResolution.x) + \n            iFrame*int(iResolution.x*iResolution.y) +\n            k\n        );\n        //pick random id of particle\n        int p = int(h*float(PARTICLES));\n        insertion_sort(new, dis, p, distance2Particle(p, screen2world(fragCoord)));\n    }\n    \n    fragColor = vec4(new); \n    \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"const float MAX_TEMP = 0.015;\n\nvec3 BlackBody(float _t)\n{\n    vec3 temp = vec3(min(1.0, _t / MAX_TEMP), min(1.0, _t / (2.0 * MAX_TEMP)), min(1.0, _t / (3.0 * MAX_TEMP)));\n    return temp * temp * temp * temp;\n}\n\nvoid renderParticle(in vec2 newPos, in vec2 oldPos, float density, in vec2 fragCoord, inout vec4 fragColor)\n{    \n    vec2 closest;\n    float dist = linePointDist2(newPos, oldPos, fragCoord, iResolution, closest);\n    \n    if (dist < PARTICLE_SIZE * PARTICLE_SIZE)\n    {\n        fragColor.xyz += BlackBody((PARTICLE_SIZE - sqrt(dist)) /** density / 300.0*/) / (PARTICLE_SIZE);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n    \n    fragColor = vec4(0);\n  \tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.xy;\n\n    //get the id's of the 4 particles that (should be) closest.\n    //the 4 ids are stored in .x, .y, .z, .w\n    ivec4 ids = fxGetClosest(ivec2(fragCoord));\n    \n    //draw the particles\n    for(int i = 0; i < 4; i++){\n        //get the particles position\n        int id = ids[i];\n        fxParticle particle = fxGetParticle(id);\n        vec2 pos = particle.pos;\n        vec2 vel = particle.vel;\n\n        renderParticle(pos, pos - vel, particle.density, p, fragColor);\n    }\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"int           N = 13; // 7                              // target sampling rate\nfloat         w = .1,                                   // filter width\n              z;                                        // LOD MIPmap level to use for integration \n#define init  w = .02; \\\n              z = ceil(max(0.,log2(w*R.y/float(N))));   // N/w = res/2^z\n#define R     iResolution.xy\n\n\nvec4 convol2D(vec2 U) {                                                     \n    vec4  O = vec4(0);                                                      \n    float r = float(N-1)/2., g, t=0.;                                       \n    for( int k=0; k<N*N; k++ ) {                                            \n        vec2 P = vec2(k%N,k/N) / r - 1.;                                    \n        t += g = exp(-2.*dot(P,P) );                                        \n        O += g * textureLod(iChannel0, (U+w*P) *R.y/R, z );                 \n    }                                                                       \n    return O/t;                                                             \n}      \n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    init \n    vec2 U = u / R.y;  \n    \n  O = convol2D(U); return;\n}\n\n","name":"Buffer D","description":"","type":"buffer"}]}