{"ver":"0.1","info":{"id":"DscBWX","date":"1697672378","viewed":47,"name":"Analytical approx. - IBL BRDF","username":"sciecode","description":"novel analytical approximation for specular split-sum integral environment BRDF.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["approximation","specular","brdf","environment"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* \n\n  Analytical approximation for specular split-sum integral environment BRDF\n    \n    ====== - ============================================================\n    AVILA  - G. Avila's approximation\n    NONE   - B. Karis'  approximation\n    ====== - ============================================================\n    RED    - F0  scale - red channel\n    NONE   - F90 bias  - green channel\n    ====== - ============================================================\n    DIFF   - difference between approximation & pre-computed RG_16 LUT\n    ====== - ============================================================\n    \n*/\n\n#define AVILA\n#define RED\n//#define DIFF\n\nvec2 avila( const in vec2 q ) {\n    \n    const vec4 co = vec4( - 0.064, 0.564, - 0.192, 1.319 );\n    const vec4 cm = vec4( 0.873, 0.488, 1.63, 1.2 );\n    const mat2 ro = mat2( cm.x, cm.y, - cm.y, cm.x );\n\n    vec4 p = ( ro * q ).xyyy - co, p2 = p * p;\n    float v = max( 1.76 * p.x, 0. );\n    \n    vec3 t = vec3( 0.82 + 15.5 * p2.w, ( p.y > 0. ) ? 0.683 : 2.42, 4.8 );\n    vec3 s = exp( - ( p2.xyz + vec3( 0, 0, v * v ) ) * t );\n    vec2 m = cm.zw * vec2( 1. - s.y, s.z );\n   \n    return vec2( 1. - ( 0.235 + m.x ) * s.x, m.y );\n    \n}\n\nvec2 karis( const in vec2 q ) {\n\n    const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n    \n\tvec4 r = q.y * c0 + c1;\n    \n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * q.x ) ) * r.x + r.y;\n    \n\treturn vec2( - 1.04, 1.04 ) * a004 + r.zw;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 p = fragCoord/iResolution.xy - .5;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 q = p + .5;\n    \n    vec2 og = texture( iChannel0, q ).rg;\n    \n    #ifdef AVILA\n      vec2 ap = avila( q );\n    #else\n      vec2 ap = karis( q );\n    #endif\n    \n    #ifdef RED\n      float v = og.r;\n      float z = ap.r;\n    #else\n      float v = og.g;\n      float z = ap.g;\n    #endif\n    \n    vec3 col = vec3(z);\n    \n    #ifdef DIFF\n      if (v >= z) col = mix( vec3(.15), vec3(1,.15,.15), clamp((v-z),0., 1.) );\n      else col = mix( vec3(.15), vec3(.15,1,.15), clamp((z-v), 0., 1.) );\n    #endif\n\n    if (iMouse.z > 0.) col = vec3(v);\n    if (abs(p.x)>.5 || abs(p.y)>.5) col = vec3(0.2);\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI  3.1415926535897932\n\n#define u_sampleCount 512\n\nfloat saturate(in float x) {\n    return clamp(x, 0., 1.);\n}\n\n// Hammersley Points on the Hemisphere\n// CC BY 3.0 (Holger Dammertz)\n// http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html\n// with adapted interface\nfloat radicalInverse_VdC(uint bits) {\n    bits = (bits << 16u) | (bits >> 16u);\n    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n    return float(bits) * 2.3283064365386963e-10; // / 0x100000000\n}\n\n// hammersley2d describes a sequence of points in the 2d unit square [0,1)^2\n// that can be used for quasi Monte Carlo integration\nvec2 hammersley2d(int i, int N) {\n    return vec2(float(i)/float(N), radicalInverse_VdC(uint(i)));\n}\n\n// Hemisphere Sample\n\n// TBN generates a tangent bitangent normal coordinate frame from the normal\n// (the normal must be normalized)\nmat3 generateTBN(vec3 normal) {\n    vec3 bitangent = vec3(0.0, 1.0, 0.0);\n\n    float NdotUp = dot(normal, vec3(0.0, 1.0, 0.0));\n    float epsilon = 0.0000001;\n    if (1.0 - abs(NdotUp) <= epsilon)\n    {\n        // Sampling +Y or -Y, so we need a more robust bitangent.\n        if (NdotUp > 0.0)\n        {\n            bitangent = vec3(0.0, 0.0, 1.0);\n        }\n        else\n        {\n            bitangent = vec3(0.0, 0.0, -1.0);\n        }\n    }\n\n    vec3 tangent = normalize(cross(bitangent, normal));\n    bitangent = cross(normal, tangent);\n\n    return mat3(tangent, bitangent, normal);\n}\n\n\nstruct MicrofacetDistributionSample {\n    float pdf;\n    float cosTheta;\n    float sinTheta;\n    float phi;\n};\n\nfloat D_GGX(float NdotH, float roughness) {\n    float a = NdotH * roughness;\n    float k = roughness / (1.0 - NdotH * NdotH + a * a);\n    return k * k * (1.0 / PI);\n}\n\n// GGX microfacet distribution\n// https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.html\n// This implementation is based on https://bruop.github.io/ibl/,\n//  https://www.tobias-franke.eu/log/2014/03/30/notes_on_importance_sampling.html\n// and https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch20.html\nMicrofacetDistributionSample GGX(vec2 xi, float roughness) {\n    MicrofacetDistributionSample ggx;\n\n    // evaluate sampling equations\n    float alpha = roughness * roughness;\n    ggx.cosTheta = saturate(sqrt((1.0 - xi.y) / (1.0 + (alpha * alpha - 1.0) * xi.y)));\n    ggx.sinTheta = sqrt(1.0 - ggx.cosTheta * ggx.cosTheta);\n    ggx.phi = 2.0 * PI * xi.x;\n\n    // evaluate GGX pdf (for half vector)\n    ggx.pdf = D_GGX(ggx.cosTheta, alpha);\n\n    // Apply the Jacobian to obtain a pdf that is parameterized by l\n    // see https://bruop.github.io/ibl/\n    // Typically you'd have the following:\n    // float pdf = D_GGX(NoH, roughness) * NoH / (4.0 * VoH);\n    // but since V = N => VoH == NoH\n    ggx.pdf /= 4.0;\n\n    return ggx;\n}\n\n// getImportanceSample returns an importance sample direction with pdf in the .w component\nvec4 getImportanceSample(int sampleIndex, vec3 N, float roughness) {\n    // generate a quasi monte carlo point in the unit square [0.1)^2\n    vec2 xi = hammersley2d(sampleIndex, u_sampleCount);\n\n    MicrofacetDistributionSample importanceSample;\n\n    // generate the points on the hemisphere with a fitting mapping for\n    // the distribution (e.g. lambertian uses a cosine importance)\n        // Trowbridge-Reitz / GGX microfacet model (Walter et al)\n        // https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.html\n        importanceSample = GGX(xi, roughness);\n\n    // transform the hemisphere sample to the normal coordinate frame\n    // i.e. rotate the hemisphere to the normal direction\n    vec3 localSpaceDirection = normalize(vec3(\n        importanceSample.sinTheta * cos(importanceSample.phi), \n        importanceSample.sinTheta * sin(importanceSample.phi), \n        importanceSample.cosTheta\n    ));\n    mat3 TBN = generateTBN(N);\n    vec3 direction = TBN * localSpaceDirection;\n\n    return vec4(direction, importanceSample.pdf);\n}\n\n// From the filament docs. Geometric Shadowing function\n// https://google.github.io/filament/Filament.html#toc4.4.2\nfloat V_SmithGGXCorrelated(float NoV, float NoL, float roughness) {\n    float a2 = pow(roughness, 4.0);\n    float GGXV = NoL * sqrt(NoV * NoV * (1.0 - a2) + a2);\n    float GGXL = NoV * sqrt(NoL * NoL * (1.0 - a2) + a2);\n    return 0.5 / (GGXV + GGXL);\n}\n\n// Compute LUT for GGX distribution.\n// See https://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\nvec2 IntegrateBRDF(const in vec2 q) {\n\n    float NdotV = q.x, roughness = q.y;\n    // Compute spherical view vector: (sin(phi), 0, cos(phi))\n    vec3 V = vec3(sqrt(1.0 - NdotV * NdotV), 0.0, NdotV);\n\n    // The macro surface normal just points up.\n    vec3 N = vec3(0.0, 0.0, 1.0);\n\n    // To make the LUT independant from the material's F0, which is part of the Fresnel term\n    // when substituted by Schlick's approximation, we factor it out of the integral,\n    // yielding to the form: F0 * I1 + I2\n    // I1 and I2 are slighlty different in the Fresnel term, but both only depend on\n    // NoL and roughness, so they are both numerically integrated and written into two channels.\n    float A = 0.0;\n    float B = 0.0;\n    float C = 0.0;\n\n    for(int i = 0; i < u_sampleCount; ++i) {\n        // Importance sampling, depending on the distribution.\n        vec4 importanceSample = getImportanceSample(i, N, roughness);\n        vec3 H = importanceSample.xyz;\n        // float pdf = importanceSample.w;\n        vec3 L = normalize(reflect(-V, H));\n\n        float NdotL = saturate(L.z);\n        float NdotH = saturate(H.z);\n        float VdotH = saturate(dot(V, H));\n        if (NdotL > 0.0) {\n            // LUT for GGX distribution.\n\n            // Taken from: https://bruop.github.io/ibl\n            // Shadertoy: https://www.shadertoy.com/view/3lXXDB\n            // Terms besides V are from the GGX PDF we're dividing by.\n            float V_pdf = V_SmithGGXCorrelated(NdotV, NdotL, roughness) * VdotH * NdotL / NdotH;\n            float Fc = pow(1.0 - VdotH, 5.0);\n            A += (1.0 - Fc) * V_pdf;\n            B += Fc * V_pdf;\n            C += 0.0;\n        }\n    }\n\n    // The PDF is simply pdf(v, h) -> NDF * <nh>.\n    // To parametrize the PDF over l, use the Jacobian transform, yielding to: pdf(v, l) -> NDF * <nh> / 4<vh>\n    // Since the BRDF divide through the PDF to be normalized, the 4 can be pulled out of the integral.\n    return vec2(4.0 * A, 4.0 * B) / float(u_sampleCount);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 rg = ( iFrame == 0 ) ?  IntegrateBRDF( uv ) : texture( iChannel0, uv ).rg;\n    fragColor = vec4( rg, 1, 1 );;\n}","name":"Buffer A","description":"","type":"buffer"}]}