{"ver":"0.1","info":{"id":"ltVfWG","date":"1543945623","viewed":343,"name":"Cookie 2018 NuSan - Round 01","username":"NuSan","description":"Shader made live in 25 minutes during Cookie Demo Party 2018, round 01","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["3d","cookie"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","previewfilepath":"/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Cookie 2018 NuSan - Round 01\n// Shader made live by NuSan in 25 minutes\n// during Cookie Demo Party 2018, round 01\n\n#define time iTime\n\nfloat sph(vec3 p, float r) {\n  return length(p) - r;\n\n}\n\n\nfloat cyl(vec3 p, float r) {\n  return length(p.xy) - r;\n\n}\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nfloat smin(float a, float b, float h) {\n  float k = clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b, k) - k * (1.0-k) * h;\n}\n\nfloat rnd(float t) {\n  return fract(sin(t*234.231)*7423.215);\n}\n\nfloat curve(float t, float d) {\n  float g=t/d;\n  return mix(rnd(floor(g)), rnd(floor(g)+1.0), pow(smoothstep(0.0,1.0, fract(g) ), 10.0));\n\n}\n\nfloat map(vec3 p) {\n\n  float d = 10000.0;\n  float j = 10000.0;\n\n  for(int i=0;i<8; ++i) {\n\n    float t1 = time + float(i)*2.354 + curve(time+85.24, 20.9*float(i)+0.2)*3.0;\n    p.xy *= rot(t1);\n    p.yz *= rot(t1*0.7);\n\n    d = smin(d, sph(p, 0.1 * float(i)+.1), 0.2);\n\n    p -= 0.2;\n    p = abs(p);\n\n    p.xy *= rot(t1*1.3);\n    \n    d = smin(d, -cyl(p, 0.05), -0.3);\n    j = min(j, cyl(p.yzx, 0.05));\n  }\n\n  j = smin(j, sph(p, 1.0), 0.3);\n\n  return min(j,d);\n}\n\nvec3 norm(vec3 p) {\n  float base=map(p);\n  vec2 off=vec2(0.01,0);\n  return normalize( vec3(base-map(p-off.xyy), base-map(p-off.yxy), base-map(p-off.yyx) ));\n}\n\nvec3 cam(vec3 p) {\n  float t2 = time + curve(time, 0.9)*3.0;\n  p.xy *= rot(t2);\n  p.xz *= rot(t2*1.2);\n  return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  uv.x += (curve(time+85.0,0.8)-0.5) * 0.4;\n  uv.y += (curve(time+85.0,0.7)-0.5) * 0.3;\n\n  vec3 ro = vec3(0,0,-3);\n  vec3 rd = normalize(vec3(-uv,0.1 + curve(time+52.0, 1.2)));\n\n  ro=cam(ro);\n  rd=cam(rd);\n\n  vec3 p = ro;\n  float dd = 0.0;\n  float at = 0.0;\n  for(int i=0;i<100; ++i) {\n    float d = map(p);\n    if(d<0.001) {\n      break;\n    }\n    if(dd>100.0) {\n      dd = 100.0;\n      break;\n    }\n\n    p+=rd*d;\n    dd+=d;\n    at += exp(-d);\n  }\n\n\n  vec3 n = norm(p);\n  vec3 l = normalize(vec3(-1));\n  vec3 h = normalize(l-rd);\n\n\n  vec3 col = vec3(0);\n  \n  float lum = max(0.0, dot(n, l));\n  float amb = -n.y*0.5+0.5;\n  col += vec3(0.8,0.7,0.2) * lum;\n  col += vec3(0.2,0.3,1.0) * amb;\n\n  col += vec3(0.8,0.9,1.0) * 0.4 * lum * pow(max(0.0,dot(n,h)), 10.0);\n  col += vec3(0.1,0.2,1.0) * 4.7 * amb * pow(1.0-max(0.0,dot(n,-rd)), 3.0);\n\n  col *= 4.0/dd;\n\n  col += pow(at*0.02,0.3) * 0.7;\n  \n  col += pow(abs(fract(at)-0.5) * (1.0-step(dd,50.0)), 5.0) * 10.2 * curve(time+81.0,1.4);\n\n  float t3 = time + curve(time+85.0,1.5);\n  col.xy *= rot(t3);\n  col.yz *= rot(t3*1.2);\n  col.xz *= rot(t3*0.7);\n  col = abs(col);\n\n  col *= pow(clamp(1.0-length(uv),0.0,1.0),2.0);\n\n  fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}