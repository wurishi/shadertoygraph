{"ver":"0.1","info":{"id":"lscXWl","date":"1462062309","viewed":171,"name":"Flow Library v1","username":"sillsm","description":"Sources, sinks, and vortices on a rotating tile.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","raymarching","flow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Copyright Max Sills, released under the MIT license.\n// Flow Library v.1\nconst float divs = 10.0;\nconst float pi = 3.14159265358979;\n// Superposition of elementary flows.\n//http://www-mdp.eng.cam.ac.uk/web/library/enginfo/aerothermal_dvd_only/aero/fprops/poten/node34.html\n    \n// if mag > 0, source.\n// if mag < 0, sink.\nvec2 sourceandsink(vec2 pos, float mag)\n{\n    float potential  = (mag/(2.0*pi)) * log(dot(pos,pos));\n    float streamline = (mag/(2.0*pi)) * atan(pos.y,pos.x);\n    return vec2(potential, streamline);\n}\n\nvec2 vortex(vec2 pos, float K)\n{\n    float potential  = K * atan(pos.y,pos.x);\n    float streamline = -K* log(dot(pos,pos));\n    return vec2(potential, streamline);\n}\n\n// Quaternion rotation around axis, of angle, centered at center.\nvec3 qRotate(vec3 axis, float angle, vec3 center, vec3 point)\n{\n  axis = normalize(axis);\n  float x = axis.x * sin(angle / 2.);\n  float y = axis.y * sin(angle / 2.);\n  float z = axis.z * sin(angle / 2.);\n  float w = cos(angle / 2.);\n\n  mat3 rotation = mat3(1. - 2.*y*y - 2.*z*z, 2.*(x*y+w*z), 2.*(x*z-w*y),\n                       2.*(x*y-w*z), 1. - 2.*x*x - 2.*z*z, 2.*(y*z +w*x),\n                       2.*(x*z + w*y), 2.*(y*z-w*x),1. - 2.*x*x - 2.*y*y);\n     \n  return center + (rotation * (point-center));\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  p = qRotate(vec3(1,0.,0.),iTime/2.,vec3(0.), p);\n  p = qRotate(vec3(0,1.,0.),iTime/2.,vec3(0.), p);\n  return length(max(abs(p)-b,0.0));\n}\n\n\nvec4 trace(vec3 eye, vec3 viewportxy)\t\t\t\t\n{\n    vec3 p = vec3(0);\n    float t = 0.0;\n    for (int i = 0; i < 16; ++i)\t\t\t\t\n    {\t\n        p = viewportxy + (t* normalize(viewportxy-eye));\t\t\t\t \n        float dist = udBox(p, vec3(1,1,1));\n        t += dist * .9999;\t\t\t\t\n    }\n    return vec4(p,t);\t\t\t\t\t\t\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\t\n    uv = uv * 2.0 - 1.0;\t\t\t\t\t\t\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // assuming viewing plane \n    // Image plane is at (0, 0, -2)\n    vec3 viewportxy = vec3(uv , -2.0);\t\t\n    vec3 eye = vec3(0, 0, -15);\t\t\t// Camera origin at 0,0,-3\n    \n    vec4 tr     = trace(eye, viewportxy);\t\t\n    float t     = tr.w;\n\n    \n    vec3 coords = tr.xyz;\n    coords = qRotate(vec3(1,0.,0.),iTime/2.,vec3(0.), coords);\n    coords = qRotate(vec3(0,1,0.),iTime/2.,vec3(0.), coords);    \n    \n    // Flow Position Calc  \n    // Reallign xy coordinates of flow to cube face.\n    uv = coords.xy;\n    \n    vec2 div = vec2( divs, divs*iResolution.y/iResolution.x );\n    vec2 p = div*uv;\n    vec2 d = vec2( 8.0, 0.0 );\n    \n\t// Velocity Potential in x, Stream fn in y, \n    vec2 S;\n    \n    // init with position to get horizontal flow\n    S = p;\t\n    \n    // Source\n    S += sourceandsink(p + d, 16.022122);\n    \n    // Vortex\n    S += vortex(p, 5.0);\n\n    // Sink\n    S += sourceandsink(p - d, -16.022122);\n    \n    S.x -= iTime*5.0;\t\n    fragColor = (1./t) * texture( iChannel0, S/div + .5 );\n    if (coords.z > -.999) fragColor = vec4(0);\n}","name":"Image","description":"","type":"image"}]}