{"ver":"0.1","info":{"id":"3dSyzD","date":"1586169287","viewed":752,"name":"Black hole gravitational lens","username":"Krafpy","description":"Gravitational lens effect produced by a black hole.","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","lensing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Used resources :\n// https://en.wikipedia.org/wiki/Rotation_matrix\n// https://en.wikipedia.org/wiki/Schwarzschild_radius\n// https://en.wikipedia.org/wiki/Gravitational_lens#Explanation_in_terms_of_spacetime_curvature\n// https://thebookofshaders.com/11/\n// https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula\n\n\n\n// 2D rotation matrix\n\nmat2 rot(float a){\n\treturn mat2(cos(a), -sin(a),\n               sin(a), cos(a));\n}\n\n\n// 3D roation matrix around an axis\n/*mat3 rot(vec3 u, float a){\n    float x = u.x;\n    float y = u.y;\n    float z = u.z;\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(\n    \tc + x*x*(1.-c), x*y*(1.-c)-z*s, x*z*(1.-c)+y*s,\n        y*x*(1.-c)+z*s, c+y*y*(1.-c), y*z*(1.-c)-x*s,\n        z*x*(1.-c)-y*s, z*y*(1.-c)+x*s, c+z*z*(1.-c)\n    );\n}*/\n\n// Rodrigues' rotation formula : rotates v around u\nvec3 rot(vec3 v, vec3 u, float a){\n    float c = cos(a);\n    float s = sin(a);\n    return v * c + cross(u, v) * s + u * dot(u, v) * (1. - c);\n}\n\n// random and noise functions\n\nfloat hash(float p) {\n    p = fract(p * 0.011); p *= p + 7.5; p *= p + p;\n    return fract(p);\n}\n\nfloat noise(vec3 x) {\n    const vec3 st = vec3(110, 241, 171);\n\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n \n    float n = dot(i, st);\n\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(n + dot(st, vec3(0, 0, 0))), hash(n + dot(st, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(st, vec3(0, 1, 0))), hash(n + dot(st, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(st, vec3(0, 0, 1))), hash(n + dot(st, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(st, vec3(0, 1, 1))), hash(n + dot(st, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\n// fractal brownian motion : noise with octaves\nfloat fbm(vec3 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < 4; ++i) { // 4 octaves\n\t\tv += a * noise(x);\n\t\tx = x * 2.5 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n// generate the background map\nvec3 background(in vec3 rd){\n    \n    vec3 gc = vec3(0., 0., 1.); // galaxy center\n    \n    float i = (1.- abs(rd.y - gc.y));\n    \n    vec3 val = vec3(pow(i, 8.)) * fbm((rd+vec3(2., 1, -4.))*10.)*0.5;\n    val *= clamp(dot(rd.xz, gc.xz), 0.,1.);\n    \n    val *= 0.5/distance(vec3(rd.x/2.5, rd.y*6., rd.z), gc);\n    \n    val.r *= 1./distance(rd, gc);\n    val.b *= distance(rd, gc);\n    \n    val.g = (val.r + val.b) / 4.;\n    \n    val /= fbm(-rd);\n    \n    // add dust\n    val = clamp(val, 0., 1.);\n    if(abs(gc.y - rd.y) <= 0.1)\n        val -= fbm(rd*30.)*vec3(1.-abs(gc.y - rd.y)*10.) * vec3(0.2, 0.8, 0.9) * pow(clamp(dot(rd, gc), 0., 1.), 1.5);\n    \n    // stars\n    float s = fbm(rd * 100.);\n    s = pow(s*1.18, 15.0);\n    val += s;\n    \n    val.b += 0.05 * length(val) + 0.2;\n    \n    return val;\n}\n\n\n\n\nconst float G = 0.01;\nconst float c = 100.;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 ro = vec3(5., 0., -10); // origin of the ray\n    vec3 rd = normalize(vec3(uv, 1.)); // inital direction of the ray\n    \n    float time = iTime;\n    \n    vec3 col = vec3(0.); // pixel color\n    \n    vec4 bh = vec4(3., 0., 0., 100000.); // black hole (x, y, z, mass)\n    // animate black hole\n    float k = 4.;\n    bh.x += cos(time)*k;\n    bh.y += sin(time)*k;\n    \n    \n    // rotate towards the black hole\n    vec3 cam = vec3(0., 0., 1.);\n    \n    rd.xy *= rot(0.7*sin(time*0.25));\n    rd.xz *= rot(0.2*sin(time*0.25));\n    \n    vec3 rb = bh.xyz - ro;\n    \n    float a = acos(dot(rb, cam) / length(rb));\n    vec3 rn = normalize(cross(rb, cam));\n    \n    rd = rot(rd, rn, -a*0.8+sin(time)*0.1);\n    \n    \n    \n    // calculate the distance to the closest point between the ray and the black hole\n    float t = dot(rd, bh.xyz - ro);\n    \n    vec3 v = ro + rd * t - bh.xyz; // vector between closest point and blackhole\n    float r = length(v); // its distance\n\n\n    // Schwarzfield radius\n    float rs = 2. * G * bh.w / (c*c);\n    if(r >= rs){\n        vec3 nml = normalize(cross(v, rd)); // axis of rotation of the ray\n        float a = 4. * bh.w * G / (r * c * c); // angle of deflection caused by gravitational field\n\n        rd = rot(rd, nml, a);\n\n        col = background(rd);//texture(iChannel0, rd).rgb;\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}