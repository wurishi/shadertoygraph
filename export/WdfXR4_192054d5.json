{"ver":"0.1","info":{"id":"WdfXR4","date":"1550664571","viewed":438,"name":"Apollonian Dreams","username":"krakel","description":"Based on a project I did for a seminar.\nThe distance field is ultimately based on https://www.shadertoy.com/view/4ds3zn\n\nThe results of that seminar (incl. interactive version of this):\nhttps://geo.ma.tum.de/de/lehrveranstaltungen/visualisation-gpu.html","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","fractal","distancefield","kleinian","inversion","apollonian"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by krakel, 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define sqrt3 sqrt(3.)\n#define pixelRadius .5/iResolution.x\n#define Time .1*float(iFrame)/30.\n\n//this AA is expensive and rather ineffective\n#define AA 0\n\nvec3 sunDir = normalize(vec3(0, 0, 1));\nfloat viewDist = 30.;\nvec3 sunLight = vec3(2.,2.,1.6);\nvec3 ambLight = vec3(.5, .8, .9);\nvec3 fogColor = vec3(.8,.8,.9);\n\nvec3 triangles(vec3 p){\n    float zm = 1.;\n    p.x = p.x-sqrt3*(p.y+.5)/3.;\n\tp = vec3(mod(p.x+sqrt3/2.,sqrt3)-sqrt3/2., mod(p.y+.5,1.5)-.5 , mod(p.z+.5*zm,zm)-.5*zm);\n\tp = vec3(p.x/sqrt3, (p.y+.5)*2./3. -.5 , p.z);\n\tp = p.y>-p.x ? vec3(-p.y,-p.x , p.z) : p;\n\tp = vec3(p.x*sqrt3, (p.y+.5)*3./2.-.5 , p.z);\n\treturn vec3(p.x+sqrt3*(p.y+.5)/3., p.y , p.z);\n}\nfloat sdf(vec3 p){\n    float scale = 1.;\n\tfloat s = 1./3.;\n\tfor( int i=0; i<10;i++ )\n\t{\n\t\tp = triangles(p);\n\t\tfloat r2= dot(p,p);\n\t\tfloat k = s/r2;\n\t\tp = p * k;\n\t\tscale=scale*k;\n    }\n\treturn .3*length(p)/scale\t\t-.001/sqrt(scale);\n}\n\nfloat march(vec3 ro, vec3 rd){\n    float t = 0.03;\n    float h = 5.;\n    for( int i=0; i<80; i++ )\n    {\n        if(h<t*pixelRadius || t>viewDist){break;}\n\t    h = sdf( ro+rd*t );\n        t += h;\n    }\n    if(h>t*pixelRadius){t=viewDist*2.;}\n    return t;\n}\n\nvec3 getNormal( in vec3 p, in float t )\n{\n    float precis = 0.0001 * t;\n\n    vec2 e = vec2(1.0,-1.0)*precis;\n    return normalize( e.xyy*sdf( p + e.xyy ) + \n\t\t\t\t\t  e.yyx*sdf( p + e.yyx ) + \n\t\t\t\t\t  e.yxy*sdf( p + e.yxy ) + \n                      e.xxx*sdf( p + e.xxx ) );\n}\nfloat ao(vec3 p,vec3 n){\n\tfloat r=0.;\n    float t=0.;\n\tfor( int i=0; i<3;i++ )\n\t{\n\t\tt=t+.01;\n\t\tr=r + sdf(p+n*t)/t;\n    }\n    return smoothstep(.0,1.7,r);\n}\n\nfloat shadowRay(vec3 p,vec3 n,vec3 ld){\n    p = p + n*.1;\n    float t = .1;\n    float h = 5.;\n    for( int i=0; i<50; i++ )\n    {\n        if(h<t*pixelRadius || t>2.){break;}\n\t    h = sdf( p+ld*t );\n        t += h;\n    }\n    return smoothstep(0.,1.,t/2.);\n}\n\nvec3 fog(float t, vec3 col, float density){\n   return  mix(col , fogColor, 1.-exp(-t*density));\n}\n\nfloat pulse(float t){\n    return pow(t,3.);\n}\n\nvec3 render(vec3 ro, vec3 rd){\n    float t= march(ro,rd);\n    vec3 col = vec3(0);\n    if(t<viewDist){\n        vec3 p = ro+t*rd;\n    \tvec3 n = getNormal(p, t);\n        col = sunLight*vec3 ( dot(n, sunDir ) );\n        col *= shadowRay(p,n,sunDir);\n        float ao = ao(p,n);\n        col += ambLight*mix(ao,.2+.8/ao, pulse(.5+sin(p.z+10.*Time)*.5));\n        col *= .6;\n        col = fog(t, col, .3);\n    }else{\n        col = fogColor;\n    }\n    return col;\n}\n\nvec3 jitter( int i){\n    return pixelRadius* fract(123.*sin(vec3(15,17,19)*float(i)));\n}\n\nvec3 AArender(vec3 ro, vec3 rd){\n    if(AA>1){\n    vec3 col = vec3(0);\n    for( int i=0; i<AA; i++){\n        col += render(ro, normalize(rd+jitter(i)));\n    }\n        return col/float(AA);}\n    else{return render(ro,rd);}\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x - .5*iResolution.xy/iResolution.x;\n    \n    vec3 camPos = vec3(0,1,.5) + Time*vec3(1) + .5*vec3(sin(Time), cos(Time) ,0 );\n    vec3 camDir = normalize(vec3(1,0,1) + vec3(0, cos(Time),sin(Time)) );\n    vec3 camRi  = normalize(cross(camDir, vec3(0,sin(Time),cos(Time))));\n    vec3 camUp  = normalize(cross(camDir, camRi));\n    \n    sunDir = normalize(vec3(0, sin(Time),cos(Time)));\n    sunLight = vec3(sin(Time),cos(Time),0);\n    \n    fragColor = vec4(AArender(camPos, normalize(camDir + camRi*uv.x + camUp*uv.y) ), 1.0);\n}","name":"Image","description":"","type":"image"}]}