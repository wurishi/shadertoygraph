{"ver":"0.1","info":{"id":"XXBSRw","date":"1710347358","viewed":49,"name":"Command-R  Visualiser","username":"miscend","description":"Abstract square shapes visualiser","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["neon","ai","llm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Custom function to create the circle shape\nfloat circleShape(vec2 u, float intensity) {\n    return .02/(abs(length(u*u)-intensity*.1)+.005);\n}\n\nvoid mainImage(out vec4 O, vec2 F) {\n    // iResolution is the resolution of the screen, and u is the normalized pixel coordinates\n    vec2 r = iResolution.xy, u = (F+F-r)/r.y;\n    \n    // Initialize the output color to black\n    O.rgb *= 0.;\n    \n    // Loop over 20 iterations to create multiple circles\n    for (float i=0.; i<20.; i++) {\n        // Calculate the distance from the center with a custom function for the circle shape\n        float shapeDistance = circleShape(u,i);\n        \n        // Determine the color based on the iteration number and sin function\n        vec3 color = vec3(1.,0.,0.)*step(.5,sin(.1*i+2.));\n        \n        // Create a smooth animation effect\n        float animation = smoothstep(.9,.95,abs(mod(iTime,10.)-i*.1));\n        \n        // Add the calculated color to the output color\n        O.rgb += shapeDistance * color * animation;\n        \n        // Apply a dynamic rotation to the pixel coordinates\n        u *= mat2(cos((iTime+.1*i)*.1 + vec4(0,1,0,0)));\n    }\n}","name":"Image","description":"","type":"image"}]}