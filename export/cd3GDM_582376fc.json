{"ver":"0.1","info":{"id":"cd3GDM","date":"1677346635","viewed":67,"name":"Tears of Joy Emoji","username":"ReplyCosine","description":"Inspire by Microsoft Emoji","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["emoji"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Simple Microsoft Fluentui Emoji ^o^\n// https://github.com/microsoft/fluentui-emoji/blob/main/assets/Face%20with%20tears%20of%20joy/Color/face_with_tears_of_joy_color.svg\n\n#define PI 3.141593\n\nfloat Remap01(float a, float b, float x) {\n    return clamp((x - a) / (b - a), 0., 1.);\n}\nfloat Remap(float a, float b, float c, float d, float x) {\n    return Remap01(a, b, x) * (d - c) + c;\n}\nvec3 MixBrighten(vec3 a, vec3 b) {\n    return vec3(max(a.r, b.r), max(a.g, b.g), max(a.b, b.b));\n}\nvec3 RGB(int r, int g, int b) {\n    return vec3(float(r) / 255., float(g) / 255., float(b) / 255.);\n}\nvec4 RGBA(int r, int g, int b, int a) {\n    return vec4(float(r) / 255., float(g) / 255., float(b) / 255., float(a) / 255.);\n}\nfloat cross2d(vec2 a, vec2 b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nfloat RectSDF(vec2 p, vec2 edgeMin, vec2 edgeMax, float blur) {\n    float d = 1.;\n    d *= smoothstep(edgeMin.x - blur, edgeMin.x, p.x);\n    d *= smoothstep(edgeMax.x, edgeMax.x - blur, p.x);\n    d *= smoothstep(edgeMin.y - blur, edgeMin.y, p.y);\n    d *= smoothstep(edgeMax.y, edgeMax.y - blur, p.y);\n    return d;\n}\n\nfloat CircleSDF(vec2 p, vec2 center, float radius, float blur) {\n    float d = 1.;\n    d = smoothstep(radius + blur, radius, length(p - center));\n    return d;\n}\n\nfloat FanSDF(vec2 p, vec2 center, float radius, float start, float end, float blur) {\n    float d = 1.;\n\n    d *= CircleSDF(p, center, radius, blur);\n\n    vec2 UP = vec2(0., 1.);\n    vec2 cp = normalize(center - p);\n    float signed = sign(cross2d(UP, cp)); // just sign of -cp.x\n    cp.y = -cp.y; // make angle start from UP\n\n    float angleP = signed *  acos(dot(UP, cp));\n\n    if (angleP < 0.) {\n        angleP += PI * 2.;\n    }\n\n    d *= smoothstep(start - blur, start, angleP);\n    d *= smoothstep(end + blur, end, angleP);\n\n    return d;\n}\n\n// Inspire from https://www.shadertoy.com/view/Xl33W2\nfloat RoundRectSDF(vec2 uv, vec2 position, vec2 size, float radius, float blur) {\n    float t = length(max(abs(uv - position) - (size / 2. - radius), 0.)) - radius;\n    return smoothstep(blur, 0., t);\n}\n\n// Copy From https://www.shadertoy.com/view/Xl33W2\nmat2 Rotate(float angle)\n{\n\tfloat ca = cos(angle);\n    float sa = sin(angle);\n\treturn mat2(ca, sa, -sa, ca);\n}\n\n\nvec4 FaceBg(vec2 uv) {\n    float d = length(uv);\n\n    vec3 colorTR = RGB(250, 222, 101); // gradient top right\n    vec3 colorBL = RGB(242, 125,  65); // gradient bottom left\n    vec3 colorHL = RGB(235, 110, 182); // highlight color\n\n    vec4 col = vec4(0.);\n\n    col.rgb = colorTR;\n\n    // gradent bg\n    float gradient1 = cos((uv.x + uv.y + 1.) * PI / 2.) * .5 + .5;\n    col.rgb = mix(col.rgb, colorBL, gradient1);\n\n    // gradent bg\n    float d2 = length(uv - vec2(.2, .65));\n    col.rgb = mix(col.rgb, colorHL, smoothstep(1.3, 1.75, d2));\n\n    // clip circle shape\n    col.a = smoothstep(1., .98, d);\n\n    return col;\n}\n\nvec4 Eye(vec2 uv, vec2 position) {\n    vec4 col = RGBA(69, 42, 61, 255);\n    float blur = .02;\n    float r1 = .26;\n    float r2 = .11;\n\n    uv = Rotate(-PI / 2.) *  uv;\n    position = Rotate(-PI / 2.) *  position;\n\n    col.a = FanSDF(uv, position, r1, 0., PI, blur);\n    col.a -= FanSDF(uv, position, r2, 0., PI, blur);\n\n    col.a = max(col.a, CircleSDF(uv, position + vec2(0., (r1 + r2) / 2.) + .01, (r1 - r2) / 2. - .01, blur));\n    col.a = max(col.a, CircleSDF(uv, position - vec2(0., (r1 + r2) / 2.) - .01, (r1 - r2) / 2. - .01, blur));\n\n    return col;\n}\n\nvec4 Tear(vec2 uv, vec2 position, float rotate) {\n    uv = Rotate(rotate) * uv;\n    position = Rotate(rotate) * position;\n\n    vec4 col = vec4(0.);\n    vec2 size = vec2(.6, .3);\n    float halfSizeY = size.y / 2.;\n    vec3 colorBg = RGB(61, 91, 241);\n    vec3 colorHL = RGB(80, 143, 255);\n\n    col.rgb = colorBg;\n\n    vec2 p = uv - position;\n    float magic = .03; // scale origin range smaller, to get smaller gradient\n    float y = sin(PI * Remap01(-halfSizeY + magic, halfSizeY - magic, p.y)) * .5;\n    col.rgb = mix(col.rgb, colorHL, y);\n\n    vec2 transformedUV = vec2(uv.x, uv.y);\n    col.a = RoundRectSDF(transformedUV, position, size, halfSizeY, .02);\n\n    return col;\n}\n\nvec4 Mouth(vec2 uv, vec2 position, float size) {\n    vec3 colorTop = RGB(154, 3, 154);\n    vec3 colorBottom = RGB(225, 9, 145);\n    vec3 colorTeeth = RGB(255, 255, 255);\n    float mouthHeight = position.y + size * .2;\n    float teethHeight = .2;\n    float blur = .02;\n    float dy = uv.y - position.y;\n\n    vec4 col = vec4(0.);\n\n    // mouth\n    col.rgb = mix(colorTop, colorBottom, smoothstep(position.y, position.y - size, dy));\n\n    col.a = smoothstep(size, size - blur, length(uv - position));\n    col.a *= smoothstep(mouthHeight, mouthHeight - blur, dy);\n\n    // teeth\n    float teethAlpha = 1.;\n    teethAlpha *= smoothstep(mouthHeight + blur, mouthHeight, dy);\n    teethAlpha *= smoothstep(mouthHeight - teethHeight, mouthHeight - teethHeight + blur, dy);\n\n    col.rgb = mix(col.rgb, colorTeeth, teethAlpha);\n\n    return col;\n}\n\nvec4 Face(vec2 uv) {\n    float d = length(uv);\n\n    vec4 col = vec4(0.);\n\n    vec4 faceBg = FaceBg(uv);\n    col = mix(col, faceBg, faceBg.a);\n\n    vec4 eyeLeft = Eye(uv, vec2(-.4, .3));\n    col = mix(col, eyeLeft, eyeLeft.a);\n\n    vec4 eyeRight = Eye(uv, vec2(.4, .3));\n    col = mix(col, eyeRight, eyeRight.a);\n\n    vec4 mouse = Mouth(uv, vec2(0., -.05), .7);\n    col = mix(col, mouse, mouse.a);\n\n    vec4 tearLeft = Tear(uv, vec2(-.8, -.1), -PI / 4.);\n    col = mix(col, tearLeft, tearLeft.a);\n\n    vec4 tearRight = Tear(uv, vec2(.8, -.1), PI / 4.);\n    col = mix(col, tearRight, tearRight.a);\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float minSize = min(iResolution.x, iResolution.y);\n    vec2 uv = fragCoord / vec2(minSize);\n    uv.x -= (iResolution.x - minSize) / minSize / 2.;\n    uv.y -= (iResolution.y - minSize) / minSize / 2.;\n    uv = 3. * uv - 1.5;  // scale canvas bigger then (1., 1.), insure (1., 1.) is not at the edge\n\n\n    vec4 col = Face(uv);\n    // Output to screen\n    fragColor = vec4(col);\n}","name":"Image","description":"","type":"image"}]}