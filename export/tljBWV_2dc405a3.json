{"ver":"0.1","info":{"id":"tljBWV","date":"1599924597","viewed":889,"name":"Volumetric light approximation","username":"boris159","description":"This is realtime version of my previous shader, but not so accurate and realistic.","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","volumetric","fog"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPSILON 0.001\n#define PI 3.141592\n#define MAX_DIST 256.0\n#define MAX_STEPS 256\n#define samples 50\n\nfloat seed;\n\nfloat rand()\n{\n    seed += 0.15342;\n    return fract(sin(seed) * 35423.7652344);\n}\n\nmat2 rot(float ang)\n{\n    float s = sin(ang);\n    float c = cos(ang);\n    return mat2(c, -s, s, c);\n}\n\nvec3 rotVec(vec3 p, vec3 r)\n{\n    p.yz *= rot(r.x);\n    p.xz *= rot(r.y);\n    p.xy *= rot(r.z);\n    return p;\n}\n\nvec3 makeRay(vec2 origin)\n{\n    vec2 res;\n    res.x = origin.x - iResolution.x * 0.5;\n    res.y = origin.y - iResolution.y * 0.5;\n    return normalize(vec3(res / iResolution.yy, 1.0));\n}\n\nfloat box(vec3 b, vec3 pos, vec3 p)\n{\n    vec3 q = abs(p - pos) - b;\n  \treturn length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat emptyBox(vec3 b, vec3 pos, vec3 p, float inner)\n{\n    return max(box(b, pos, p), -box(b * inner, pos, p));\n}\n\nfloat getDist(vec3 origin)\n{\n    //origin.xz *= mat2(cos(iTime), sin(iTime), -sin(iTime), cos(iTime));\n    float box1 = emptyBox(vec3(1.5, 1, 2), vec3(0), origin, 0.9);\n    float box2 = box(vec3(1, 0.5, 1), vec3(1, 0, 0), origin);\n    return max(box1, -box2);\n}\n\nvec3 getNormal(vec3 p)\n{\n    float d = getDist(p);\n    vec2 e = vec2(EPSILON, 0);\n    \n    vec3 n = d - vec3(\n        getDist(p-e.xyy),\n        getDist(p-e.yxy),\n        getDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec2 rayMarch(vec3 origin, vec3 direct)\n{\n    float res = 0.0;\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 tmp = origin + direct * res;\n        float d = getDist(tmp);\n        res += d;\n        \n        if (res >= MAX_DIST || d < EPSILON)\n        \treturn vec2(res, float(i));\n    }\n\n    return vec2(res, float(MAX_STEPS));\n}\n\nvec3 trace(vec3 origin, vec3 dir)\n{\n\tvec3 col = vec3(1);\n   \tvec2 res = rayMarch(origin, dir);\n    vec3 light = vec3(1, cos(iTime) * 0.5 + 0.5, 0);\n    \n    if (res.x < MAX_DIST)\n    {\n        vec3 p = origin + dir * res.x;\n        vec3 normal = getNormal(p);\n        \n        col *= pow(1.0 - res.y / float(MAX_STEPS), 5.0);\n        float shadow = rayMarch(p + normal * EPSILON * 5.0, light).x;\n        \n        if (shadow < MAX_DIST)\n            col *= 0.25;\n    }\n    \n    float toAdd = 1.0 / float(samples);\n    \n    for (int i = 0; i < samples; i++)\n    {\n        float f = (float(i) + rand()) / float(samples);\n        vec3 p = mix(origin, origin + dir * res.x, f);\n        float shadow = rayMarch(p, light).x;\n\n        if (shadow >= MAX_DIST)\n            col += toAdd;\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    seed = iTime + iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;\n    vec3 pos = vec3(-0.75, 0, -1.75);\n    vec3 dir = makeRay(fragCoord);\n    dir = rotVec(dir, vec3(0, -PI / 6.0, 0));\n    \n    vec3 traced = trace(pos, dir);\n    fragColor = vec4(traced, 1);\n}","name":"Image","description":"","type":"image"}]}