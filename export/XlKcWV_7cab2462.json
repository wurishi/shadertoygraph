{"ver":"0.1","info":{"id":"XlKcWV","date":"1537893645","viewed":391,"name":"Stereographic Repoint 360 ","username":"DANewman","description":"Demo of stereographic 360 re-pointing with code to control the camera orientation, source orientation, defish and FOV/zoom.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["viewport","360","gopro","overcapture"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n//Viewport Controls\n#define PAN_ANGLE\t\t0.0\t\t// camera orientation in degrees (unlimited)\n#define TILT_ANGLE\t\t0.0\t\t// camera orientation in degrees (unlimited)\n#define DUTCH_ANGLE\t\t0.0\t\t// camera orientation in degrees (unlimited)\n#define ZOOM_PERCENT\t100.0\t// 100 - GoPro Wide, 200 GoPro Narrow, 20 - little planet, good range 20 - 300 \n#define DEFISH_ANGLE\t0.0\t\t// 0 - GoPro-like Lens, 33 - Rectilinear, range -89 to 89\n#define YAW_ANGLE\t\t0.0\t\t// ERP orientation in degrees (unlimited)\n#define PITCH_ANGLE\t\t0.0\t\t// ERP orientation in degrees (unlimited)\n#define ROLL_ANGLE\t\t0.0\t\t// ERP orientation in degrees (unlimited)\n\n#define CHECKERS  \t\t0 \t\t//1 for a checkerboard instead of a texture.\n#define USE_CUBEMAP  \t1 \t\t//1 for a cubemap, 0  for equirectanglar (no samples in shadertoy)\n#define USE_BICUBIC  \t1\t\t//1 for a bicubic sampling (when not using a cubemap), 0 bi-linear\n\n#define MOUSE_GAIN \t\t0.4\n\n\n#define PI 3.14159265359\n#define HPI 1.5707963268\n#define QPI 0.7853981634\n#define TWOPI 6.28318530718\n#define INV_PI 0.3183098862\n#define INV_TWOPI 0.1591549431\n#define I80_DIVPI 57.2957795131\n#define PI_DIV180 0.01745329\n\n#define DEG2RAD(d)    (PI_DIV180*(d))\n#define RAD2DEG(r)    (I80_DIVPI*(r))\n\n\nvec4 cubic(float v) \n{\n\tvec4 n = vec4(1.0, 2.0, 3.0, 4.0) - v;\n\tvec4 s = n * n * n;\n\tfloat x = s.x;\n\tfloat y = s.y - 4.0 * s.x;\n\tfloat z = s.z - 4.0 * s.y + 6.0 * s.x;\n\tfloat w = 6.0 - x - y - z;\n\treturn vec4(x, y, z, w) * (1.0 / 6.0);\n}\n\nvec4 textureBicubic(sampler2D sampler, vec2 texCoords) \n{\n   vec2 myCoords;\n   vec2 invTexSize = 1.0 / vec2(iChannelResolution[1].xy);\n   myCoords = texCoords * vec2(iChannelResolution[1].xy) - 0.5;\n   vec2 fxy = fract(myCoords);\n   myCoords -= fxy;\n   vec4 xcubic = cubic(fxy.x);\n   vec4 ycubic = cubic(fxy.y);\n\tvec4 c = myCoords.xxyy + vec2(-0.5,1.5).xyxy;\n\tvec4 s = vec4(xcubic.xz + xcubic.yw, ycubic.xz + ycubic.yw);\n\tvec4 offset = c + vec4(xcubic.yw, ycubic.yw) / s;\n\toffset *= invTexSize.xxyy;\n\tvec4 sample0 = texture(sampler, offset.xz);\n\tvec4 sample1 = texture(sampler, offset.yz);\n\tvec4 sample2 = texture(sampler, offset.xw);\n\tvec4 sample3 = texture(sampler, offset.yw);\n\tfloat sx = s.x / (s.x + s.y);\n\tfloat sy = s.z / (s.z + s.w);\n\treturn mix(mix(sample3, sample2, sx), mix(sample1, sample0, sx), sy);\n}\n\n\nvec4 Repoint(vec2 coord, float pan, float tilt)\n{\n    vec4 color;\n    vec2 p = coord;\n    \n    float destwidth_active = iResolution.x;\n    float destheight_active = iResolution.y;\n    \n    float fov = DEFISH_ANGLE;\n    float fov_abs = abs(fov) + 0.1;\n\tfloat fov_abs_inv = 1.0 / fov_abs;\n\tfloat fov_rad = 0.785398 * fov_abs / 45.0;\n\tfloat tan_fov_rad = tan(fov_rad);\n\tfloat tan_fov_rad_inv = 1.0 / tan_fov_rad;\n    \n\tfloat changepan = DEG2RAD(PAN_ANGLE + pan);\n\tfloat changetilt = DEG2RAD(TILT_ANGLE + tilt);\n\tfloat changeinvzoom = 100.0 / ZOOM_PERCENT;\n\n\tfloat dutch_radians = DEG2RAD(DUTCH_ANGLE);\n\tfloat sin_theta = sin(dutch_radians);\n\tfloat cos_theta = cos(dutch_radians);\n    \n        \n    float maxradius = sqrt((destwidth_active *destwidth_active + destheight_active*destheight_active) / 4.0); // Corner Anchor\n\tfloat maxradius_v = 0.5 * destheight_active * fov_abs / (57.2958 * atan(tan(0.785398 * fov_abs / 45.0))); // Center vertical Anchor\n\tfloat maxradius_inv = 1.0 / maxradius;\n\tfloat maxradius_v_inv = 1.0 / maxradius_v;\n        \n    float sensorcrop = 1.0;\n    \n    float changerho = DEG2RAD(YAW_ANGLE);\n\tfloat changetheta = DEG2RAD(PITCH_ANGLE);\n\tfloat changephi = DEG2RAD(ROLL_ANGLE);\n    \n    float a, phid, alpha;\n    float xy_plane_angle;\n    float z_axis_angle;\n\n    float yz_plane_angle;\n    float x_axis_angle;\n\n    float xz_plane_angle;\n    float y_axis_angle;\n\n    float phi, theta, radius, r;\n    float x = coord.x * destwidth_active, y = coord.y * destheight_active, z;\n\tfloat newx, newy, tmp, val;           \n    float u, v;\n    \n\tnewx = x - destwidth_active * 0.5;\n\tnewy = y - destheight_active * 0.5;\n    \n\t//rotate around the projected center.\n\ttmp = newx * cos_theta - newy * sin_theta;\n\tnewy = newx * sin_theta + newy * cos_theta;\n\tnewx = tmp;\n\n    // zoom image\n    newx = newx * changeinvzoom;\n    newy = newy * changeinvzoom;\n\n    radius = sqrt(newx * newx + newy * newy);\n    theta = atan(newy, newx);\n    \n    // Fisheye corrections\n\ta = clamp(fov*10000.0, 0.0, 1.0);\t\n\tval = clamp((radius * maxradius_inv * fov_rad), 0.0, 1.57);\n\tradius = a * (maxradius_v * 57.2958 * atan(radius * maxradius_v_inv * tan_fov_rad) * fov_abs_inv) + (1.0 - a) * (maxradius * tan(val) * tan_fov_rad_inv);\n    \n    \n    // GoPro Lens module\n    r = radius / maxradius;  // normalized_radius\n    phi = atan(90.0*r/131.0)*2.0; // Stereographic projection that approximates a GoPro lens.\n\n    \n    //Repoint pan,tilt\n    xy_plane_angle = phi;\n    z_axis_angle = theta;\n\n    x = sin(xy_plane_angle)*sin(z_axis_angle);\n    y = sin(xy_plane_angle)*cos(z_axis_angle);\n    z = cos(xy_plane_angle);\n\n    yz_plane_angle = acos(y);\n    x_axis_angle = atan(z, x);\n    x_axis_angle += changetilt;\n    \n    x = sin(yz_plane_angle)*sin(x_axis_angle);\n    y = sin(yz_plane_angle)*cos(x_axis_angle);\n    z = cos(yz_plane_angle);\n\n    xz_plane_angle = acos(y);\n    y_axis_angle = atan(z, x);\n    y_axis_angle += changepan;\n\n    x = sin(xz_plane_angle)*sin(y_axis_angle);\n    y = sin(xz_plane_angle)*cos(y_axis_angle);\n    z = cos(xz_plane_angle);\n\n    xy_plane_angle = acos(y);\n    z_axis_angle = atan(z, x);\n\n    x = sin(xy_plane_angle)*sin(z_axis_angle);\n    y = sin(xy_plane_angle)*cos(z_axis_angle);\n    z = cos(xy_plane_angle);\n\n    yz_plane_angle = acos(y);\n    x_axis_angle = atan(z, x);\n    x_axis_angle += changetheta + HPI;\n    \n    x = sin(yz_plane_angle)*sin(x_axis_angle);\n    y = sin(yz_plane_angle)*cos(x_axis_angle);\n    z = cos(yz_plane_angle);\n\n    xz_plane_angle = acos(y);\n    y_axis_angle = atan(z, x);\n    y_axis_angle += PI;\n\n    x = sin(xz_plane_angle)*sin(y_axis_angle);\n    y = sin(xz_plane_angle)*cos(y_axis_angle);\n    z = cos(xz_plane_angle);\n\n    xy_plane_angle = acos(y);\n    z_axis_angle = atan(z, x);\n    z_axis_angle += changerho;\n       \n    x = sin(xy_plane_angle)*sin(z_axis_angle);\n    y = sin(xy_plane_angle)*cos(z_axis_angle);\n    z = cos(xy_plane_angle);\n\n    yz_plane_angle = acos(y);\n    x_axis_angle = atan(z, x);\n    \n    x = sin(yz_plane_angle)*sin(x_axis_angle);\n    y = sin(yz_plane_angle)*cos(x_axis_angle);\n    z = cos(yz_plane_angle);\n\n    xz_plane_angle = acos(y);\n    y_axis_angle = atan(z, x);\n    y_axis_angle += changephi;\n    \n    x = sin(xz_plane_angle)*sin(y_axis_angle);\n    y = sin(xz_plane_angle)*cos(y_axis_angle);\n    z = cos(xz_plane_angle);\n\n    xy_plane_angle = acos(y);\n    z_axis_angle = atan(z, x);\n\n    phi = xy_plane_angle;\n    theta = z_axis_angle;\n\n\n    u = (1.25 - theta * INV_TWOPI);\n    u -= floor(u);\n    v = phi * INV_PI;\n\n\n#if CHECKERS\n    newx = u * srcwidth; \n    newy = v * srcheight;\n    p.x = floor(newx*0.01);\n    p.y = floor(newy*0.01);\n\n    float f = 0.5 + 0.5*mod( p.x+p.y, 2.0 );\n\n    color = vec4( f, f, f, 1.0 );\n#else\n         \n    vec2 pixpos;\n    pixpos.x = u*2.0 - 1.0;\n    pixpos.y = v - 0.5;\n    \n    #if USE_CUBEMAP\n        vec2 thetaphi;\n    \tthetaphi.x = pixpos.x * 3.1415926535897932384626433832795;\n    \tthetaphi.y = pixpos.y * 3.1415926535897932384626433832795;\n    \n    \tvec3 rayDirection = vec3(cos(thetaphi.y) * cos(thetaphi.x), sin(thetaphi.y), cos(thetaphi.y) * sin(thetaphi.x));\n\t\n    \tcolor = texture(iChannel0, rayDirection); \n    #else\n   \t   #if USE_BICUBIC\n    \tcolor = textureBicubic(iChannel1, pixpos);\n       #else\n\t    color = texture(iChannel1, pixpos); \n       #endif\n    #endif\n#endif\n    \n    return color;\n}\n   \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 coord = fragCoord.xy / iResolution.xy;\n    vec2 m = iMouse.xy / iResolution.xy;\n    \n    m -= 0.5;\n    m *= MOUSE_GAIN; // guess for gopro FOV and curvature\n    \n\tfloat pan = -m.x * 360.0;\n    float tilt = m.y * 180.0;  \n    \n    fragColor = Repoint(coord, pan, tilt);    \n}","name":"Image","description":"","type":"image"}]}