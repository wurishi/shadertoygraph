{"ver":"0.1","info":{"id":"tlSXRh","date":"1564994550","viewed":107,"name":"Raycasting Test v0.1","username":"Xaymar","description":"Just some raycasting/marching tests, nothing special to see here.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["raycast"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Camera Options\n#define CAMERA_Z_NEAR 16.\n#define CAMERA_Z_FAR 32767.0\n#define CAMERA_FOV 90.0\n\n#define STEPS 24\n\n// Math\n#define S_PI 3.1415926535897932384626433832795        // PI = pi\n#define S_PI2 6.283185307179586476925286766559        // 2PI = 2 * pi\n#define S_PI2_SQROOT 2.506628274631000502415765284811 // sqrt(2 * pi)\n\n#define S_RAD 57.295779513082320876798154814105  // 180/pi\n#define S_DEG 0.01745329251994329576923690768489 // pi/180\n#define D_DEG_TO_RAD(x) (x * S_DEG)\n#define D_RAD_TO_DEG(x) (x * S_RAD)\n\n//----------------------------------------//\n// Returns a Rotation Matrix for the given Axis and Angle.\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvec3 rotate(vec3 v, vec3 rot) {\n    mat4 rot_z = rotationMatrix(vec3(0., 0., 1.), rot.z);\n    mat4 rot_y = rotationMatrix(vec3(0., 1., 0.), rot.y);\n    mat4 rot_x = rotationMatrix(vec3(1., 0., 0.), rot.x);\n    \n    vec4 pos = vec4(v.x, v.y, v.z, 1.);    \n    vec4 rtd = pos * rot_z * rot_x * rot_y;\n    \n    return rtd.xyz;\n}\n\nbool solveQuadratic(float a, float b, float c, out float x0, out float x1) \n{ \n    float discr = b * b - 4. * a * c; \n    if (discr < 0.) return false; \n    else if (discr == 0.) x0 = x1 = - 0.5 * b / a; \n    else { \n        float q = (b > 0.) ? \n            -0.5 * (b + sqrt(discr)) : \n            -0.5 * (b - sqrt(discr)); \n        x0 = q / a; \n        x1 = c / q; \n    } \n    if (x0 > x1) {\n        float tmp = x1;\n        x1 = x0;\n        x0 = tmp;\n    }\n \n    return true; \n}\n\nbool intersect_sphere(vec3 center, float radius,\n                      vec3 orig, vec3 dir,\n                      out float t) { \n    float t0, t1; // solutions for t if the ray intersects \n    float radius2 = radius * radius;\n#if 0 \n    // geometric solution\n    vec3 L = center - orig; \n    float tca = dot(L, dir); \n    // if (tca < 0) return false;\n    float d2 = dot(L, L) - tca * tca; \n    if (d2 > radius2) return false; \n    float thc = sqrt(radius2 - d2); \n    t0 = tca - thc; \n    t1 = tca + thc; \n#else \n    // analytic solution\n    vec3 L = orig - center; \n    float a = dot(dir, dir); \n    float b = 2. * dot(dir, L); \n    float c = dot(L, L) - radius2; \n    if (!solveQuadratic(a, b, c, t0, t1)) return false; \n#endif \n    if (t0 > t1) {\n        float tmp = t0;\n        t0 = t1;\n        t1 = tmp;\n    }\n\n    if (t0 < 0.) { \n        t0 = t1; // if t0 is negative, let's use t1 instead \n        if (t0 < 0.) return false; // both t0 and t1 are negative \n    } \n\n    t = t0; \n\n    return true; \n}\n\nvoid blend_mix(out vec4 color, vec4 other) {\n    color.rgb = mix(color.rgb, other.rgb, clamp(other.a, 0., 1.));\n    color.a = mix(color.a, other.a+color.a, clamp(other.a, 0., 1.));\n}\n\nvec4 blend_additive(vec4 a, vec4 b) {\n    return a + (b * b.a);\n}\n//----------------------------------------//\n\nfloat sprite(vec3 pos, float radius,\n             vec3 ray_pos, vec3 ray_normal,\n             out vec4 color, out vec3 normal, out vec4 masks) {\n    float t;\n    if (!intersect_sphere(pos, radius, ray_pos, ray_normal, t))\n    \treturn CAMERA_Z_FAR;\n    \n    vec3 hit_pos = ray_pos + ray_normal * t;\n    normal = normalize(hit_pos - pos);\n    \n    color.rgb = vec3(1., 1., 1.);\n    color.a = dot(ray_normal, -normal) * 0.3;\n    return t;\n}\n\n// masks = Specular, Metallic, Roughness, Ambient Occlusion\nvoid ray(vec3 pos, vec3 ray_normal,\n         out vec4 color, out vec3 normal, out vec4 masks) {\n    vec3 ray_start = pos;\n    vec3 ray_length = ray_normal * CAMERA_Z_FAR;\n    vec3 ray_end = pos + ray_length;\n    \n    // Clear values\n    normal = ray_normal;\n    color = vec4(0.0, 0.0, 0.0, 0.0);\n    masks = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    float depth = CAMERA_Z_FAR;\n    float depth_test = CAMERA_Z_FAR;\n    \n    float unit = 10.;\n    float unit_size = 3.333;\n    vec3 ray_step = normalize(ray_length) * unit;\n    for (int n = STEPS; n > 0; n--) {\n        vec3 here = (ray_start + ray_step * float(n)) / unit;\n        vec3 spos = round(here) * unit;\n        \n        vec4 res_color, res_masks;\n        vec3 res_normal;\n        depth_test = sprite(spos, unit_size,\n                            ray_start, ray_normal,\n                            res_color, res_normal, res_masks);\n        if (depth_test < depth) {\n            color = blend_additive(color, res_color);\n            depth = depth_test;\n        }\n    }\n}\n\nvoid camera(in vec3 pos, in vec3 rot, in float fov,\n            in vec2 uv, in float aspect, \n            out vec4 fragColor) {\n    vec3 normal;\n    vec4 masks;\n    \n    vec3 ray_normal = rotate(vec3(fov * (uv.x - 0.5) * aspect, fov * (uv.y - 0.5), 1.), rot);\n    vec3 ray_pos = pos + ray_normal * CAMERA_Z_NEAR;\n    \n    ray(ray_pos, ray_normal, fragColor, normal, masks);\n    vec4 bg = texture(iChannel1, normalize(ray_normal));\n    vec4 fg = texture(iChannel0, normalize(ray_normal));\n    fragColor = blend_additive(bg, vec4(fg.r, fg.g, fg.b, fragColor.a));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 pos = vec3(cos(iTime) * 20., sin(iTime) * 20., cos(iTime / 3.) * sin(iTime + 0.2) * 40.);\n    vec3 rot = vec3(D_DEG_TO_RAD(((1. - (iMouse.y / iResolution.y)) * 180.0)) - S_PI/2.,\n                    D_DEG_TO_RAD((iMouse.x / iResolution.x) * 360.0) - S_PI,\n                    0.);\n    \n    camera(pos, rot, 1.0 / tan(D_DEG_TO_RAD(90. - CAMERA_FOV / 2.0) / 2.0), fragCoord/iResolution.xy, iResolution.x / iResolution.y, fragColor);\n}","name":"Buffer A","description":"","type":"buffer"}]}