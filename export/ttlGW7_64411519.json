{"ver":"0.1","info":{"id":"ttlGW7","date":"1556568140","viewed":111,"name":"Handgun","username":"codebro","description":"Learning how raymarching works in GLSL lead me to create this handgun model.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","handgun"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float SIZE = 1.0;\nconst float MINIMUM_HIT_DISTANCE = 0.001;\nconst float MAXIMUM_TRACE_DISTANCE = 1000.0;\nconst int NUMBER_OF_STEPS = 100;\nconst float PI = 3.14159265359;\n\nmat3 rotateY(float rad) {\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat3(\n        c, 0.0, -s,\n        0.0, 1.0, 0.0,\n        s, 0.0, c\n    );\n}\n\nmat3 rotateX(float rad) {\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, c, s,\n        0.0, -s, c\n    );\n}\n\nmat3 rotateZ(float rad) {\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat3(\n        c, s, 0.0,\n        -s, c, 0.0,\n        0.0, 0.0, 1.0\n    );\n}\n\nmat2 rotationMatrix2d(float time) { // matrix representation of a complex number can be used to rotate 2d vectors\n  return mat2(cos(time), sin(time), -sin(time), cos(time));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r ) {\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) - r\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf\n}\n\nfloat sdTriPrism( vec3 p, vec2 h, float narrow ) {\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*narrow,-p.y)-h.x*0.5);\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h ) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat smoothMin(float dstA, float dstB, float k) {\n    float h = max(k - abs(dstA - dstB), 0.0) / k;\n    return min(dstA, dstB) - h * h * h * k * 1.0 / 6.0;\n}\n\nfloat opOnion( in float sdf, in float thickness ) {\n    return abs(sdf)-thickness;\n}\n\nfloat mapTheWorld(in vec3 p) {\n    float displacement = sin(5.0 * p.x) * cos(5.0 * p.y) * sin(5.0 * p.z) * 0.25;\n\n    float barrel = sdRoundBox(p + vec3(0.0, -0.5, 0.0), vec3(0.1, 0.1, 1.0), 0.06);\n\n    vec3 barrelTipPos = rotateX(PI * 0.5) * p + vec3(0.0, -1.15, -0.55);\n    float barrelTipInner = sdCappedCylinder(barrelTipPos, vec2(0.0675, 2.0));\n    float tri = sdTriPrism(rotateZ(PI * 0.25) * rotateY(PI * 0.5) * p + vec3(-0.28, -1.1, 0.0), vec2(0.28, 0.28), 0.5);\n\n    float x = sdRoundBox(p + vec3(0.0,-0.2,-0.24), vec3(0.01,0.1,0.1), 0.01);\n\n    barrel = max(barrel, -tri);\n    barrel = max(barrel, -barrelTipInner);\n    barrel = min(barrel, x);\n\n    vec3 handlePos = rotateX(PI * 0.04) * p + vec3(0.0, 0.0, -0.6);\n    float handle = sdRoundBox(handlePos, vec3(0.1, 0.5, 0.25), 0.05);\n\n    float trigger = sdRoundBox(p + vec3(0.0, -0.3, -0.1), vec3(0.05, 0.2, 0.2), 0.025);\n    float triggerHole = sdRoundBox(p + vec3(0.0, -0.3, -0.1), vec3(0.1, 0.14, 0.14), 0.025);\n\n    trigger = max(trigger, -triggerHole);\n\n    float sight = sdTriPrism(p + vec3(0.0, -0.65, 0.65), vec2(0.01, 0.4), 0.1);\n\n    return min(sight, smoothMin(barrel, min(handle, trigger), 0.2));\n}\n\nvec3 calculateNormal(in vec3 currentPosition) {\n    const vec3 small_step = vec3(0.001, 0.0, 0.0);\n\n    float gradient_x = mapTheWorld(currentPosition + small_step.xyy) - mapTheWorld(currentPosition - small_step.xyy);\n    float gradient_y = mapTheWorld(currentPosition + small_step.yxy) - mapTheWorld(currentPosition - small_step.yxy);\n    float gradient_z = mapTheWorld(currentPosition + small_step.yyx) - mapTheWorld(currentPosition - small_step.yyx);\n\n    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\n\n    return normalize(normal);\n}\n\nvec3 remap(vec3 col) { // map range -1 to 1, to, range 0 to 1\n  return col * 0.5 + 0.5;\n}\n\nmat2 rotation() {\n    return rotationMatrix2d(iTime * 0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec3 coord = vec3((fragCoord - 0.5 * iResolution.xy) / iResolution.y, 0.0); // adjusting for the viewport size\n\n  vec3 ro = vec3(0, 1, -2), // where the camera is sitting\n        look_at = vec3(0); // where the camera is pointing\n\n  ro.xz *= rotation();\n\n  float zoom = 0.8; // camera zoom\n  vec3 f = normalize(look_at - ro), // forward vector\n    r = normalize(cross(vec3(0, 1, 0), f)); // right vector\n  vec3 u = cross(f, r), // up vector\n    c = ro + f * zoom, // center point of the virtual screen (virtual screen is a screen that the objects are painted onto and sits between the camera and the objects)\n    i = c + coord.x * r + coord.y * u, // ray intersection point with our virtual screen\n    rd = normalize(i - ro); // ray direction\n  float dS, dO = 0.0; // distance to surface and distance to origin;\n  vec3 currentPosition; // point along the ray (from which we emit our spheres);\n  vec3 col = vec3(0); // empty canvas\n\n  for(int i = 0; i < 100; i++) { // ray marcher\n    currentPosition = ro + rd * dO; // the point coord is the ray origin plus the distance from the origin times ray direction\n    dS = mapTheWorld(currentPosition);\n    if (dS < MINIMUM_HIT_DISTANCE) {\n      vec3 normal = calculateNormal(currentPosition);\n      // For now, hard-code the light's position in our scene\n      vec3 lightPosition = vec3(2.0, -5.0, 3.0);\n      lightPosition.xz *= rotation();\n      // Calculate the unit direction vector that points from\n      // the point of intersection to the light source\n      vec3 direction_to_light = normalize(currentPosition - lightPosition);\n  \n      float diffuse_intensity = max(0.0, dot(normal, direction_to_light));\n  \n      col = vec3(0.5, 0.5, 0.5) * diffuse_intensity;\n      break;\n    }; // register a hit - one of our spheres can register a hit on our object because distance of surface is tiny\n    if (dO > MAXIMUM_TRACE_DISTANCE) break; // maximum distance that our camera will pick up\n    dO += dS; // This is stepping to the next point coord to emit another sphere\n  }\n    \t\t\n  fragColor = vec4(col, 1.0); // our final color\n}\n","name":"Image","description":"","type":"image"}]}