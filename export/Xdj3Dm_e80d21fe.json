{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"\t/*\n\tThis shader uses spheres and cilynders deformations to create more complex shapes, itÂ´s\n\tloosely based on the domain warping commented in https://iquilezles.org/articles/warp\n\t\n\tThe idea is to use a local coordinate system vector and give it different scales depending on\n\tthe shapeÂ´s needs. for example if you define a sphere as:\n\t\n\tsphere = length(u) - ratio\n\n\tBeing \"u\" a local vector, you can scale the \"X\" and \"Y\" values of \"U\" like:\n\tu.x = 0.02 * pow(u.x, 2.0)\n\tu.y = 0.02 * pow(u.y, 2.0)\n\tu.z = 0.02 * pow(u.z, 2.0)\n\tand this gives you a much less rounded sphere.\n\n\tFor the cilynders you can change the circle profile around the extruded axis using the\n\tlocal or global coordinates to adapt ratios or scales.\n\n\tFinally you can adapt how the circle profiles change around the axis using pow functions to\n\tmake it curved as you desire (I used differents exponents in the main body to make the lower front\n\tpart very pronounced, and the lower back part very \"linear\".\n\n\tTo create the interpolations for the changes in exponentes for the pow functions I use sometimes\n\tthe clamp function to limint the values around the axis of deformation. this is one example of that\n\n\tinterpoler = 0.9 * pow(clamp(0.5 * u.y / largo, 0.0, 1.0), 1.2);\n\n\tHere the clamp function limits the main value from 0.0 to 0.5, after that, I defined how curved\n\tthe intepolation would be using the pow function with a 1.2 exponent (if I use a 7.0 exponent the curve would\n\tbe very pronounced. After that I scale the interpolation to 90% using the 0.9 value.\n\n\tNote that the previous interpolation uses the local \"Y\" coordenate system to define it.\n\t*/\n\n\n\n\t//#define SHADOWS\n\n\t//const for ray marching\n\tconst int max_iterations = 150;\n\tconst float stop_threshold = 0.1;\n\tconst float grad_step = 0.1;\n\tconst float clip_far = 3000.0;\n\n\n\n\tconst float PI = 3.14159265359;\t\n\tfloat uAngle;\n\n\t//rotations around angles...\n\tmat3 rotX(float angle) {\n\t\tangle = radians(angle);\n\t\treturn mat3(1.0, 0.0, 0.0,\n\t\t\t\t\t0.0, cos(angle), -sin(angle),\n\t\t\t\t\t0.0, sin(angle), cos(angle));\n\t}\n\t\n\tmat3 rotY(float angle) {\n\t\tangle = radians(angle);\n\t\treturn mat3(cos(angle), 0.0, sin(angle),\n\t\t\t\t\t0.0, 1.0, 0.0,\n\t\t\t\t\t-sin(angle), 0.0, cos(angle));\n\t}\n\n\tmat3 rotZ(float angle) {\n\t\tangle = radians(angle);\n\t\treturn mat3(cos(angle), -sin(angle), 0.0,\n\t\t\t\t\tsin(angle), cos(angle), 0.0,\n\t\t\t\t\t0.0, 0.0, 1.0);\n\t}\n\t\n\t//Distance for the propeller \n\tfloat alabe(vec3 u, float desface) {\n\t\tfloat ratio = 20.0;\n\t\tfloat val = 12.0 * ratio;\n\t\tu.y += val * cos(radians(desface));\n\t\tu.x += val * sin(radians(desface));\n\t\tu *=rotZ(desface);\n\t\tu.y *= 0.08 + step(u.y, 0.0) * 0.42;\n\t\tu.z *= 3.0;\n\t\t\n\t\treturn length(u) - ratio;\n\t}\n\n\t//Distance for the tires\n\tfloat sdTorus( vec3 p, vec2 t ) {\n \t\tvec2 q = vec2(length(p.yz)-t.x,p.x);\n \t\treturn length(q)-t.y;\n\t}\n\t\n\n\t//Distance field of the plane\n\tvec3 dist_field(vec3 p) {\n\t\n\t\tp *= rotY(uAngle * 0.1);\n\t\tp *= rotX(7.0);\n\t\n\t\t//Vector that defines the distance (x), color (y), and (z) is used for the eyes color\n\t\tvec3 outData = vec3(0.0, 0.0, 0.0);\t\t\n\t\t\n\t\t//The original point always remains the same, the U vector is used as a local coordinate system\n\t\tvec3 u = p.xyz;\n\t\t\n\t\t//Main body (fuselaje), itÂ´s modeled using a deformed cilynder.\n\t\tfloat ratio = 100.0;\n\t\tfloat largo = 600.0;\n\t\tfloat scalarY = 0.7;\n\t\tfloat scalarX = 0.015;\n\t\tfloat interpoler = 0.0;\n\t\tif(u.z > 0.0) {\n\t\t\tfloat sep = 80.0;\n\t\t\tfloat expo = 7.0 - 5.9 * clamp(0.5 * (p.y + sep) / sep, 0.0, 1.0);\n\t\t\tinterpoler = step(-u.z, 0.0) * pow(u.z / largo, expo);\n\t\t\tscalarX += 0.005 * interpoler;\n\t\t\tscalarY -= 0.5 * interpoler;\n\t\t\tratio -= 60.0 * interpoler;\n\t\t} else { \n\t\t\tfloat limite = step(u.z, 0.0) * abs(u.z) / largo;\n\t\t\tinterpoler =  pow(limite, 2.0);\n\t\t\tscalarX += 0.2 * pow(limite, 5.0);\n\t\t\tratio -= 70.0 * interpoler;\n\t\t\tu.y -= 40.0 * interpoler;\n\t\t}\n\t\tu.x = scalarX * pow(p.x, 2.0);\n\t\tu.y += step(u.y, 0.0) *scalarY * (ratio - abs(u.x));\n\t\t\n        float fuselaje = 0.2 * max(length(u.xy) - ratio, abs(u.z) - largo);\n        \n        float cilinder = length(p.xy) - 30.;\n        fuselaje = max(fuselaje, -cilinder);\n\t\t\n\t\t\n\t\t//antenna, this is also modeled as a deformed cilynder and then added to the main body\n\t\tu.xyz = p.xyz;\n\t\tlargo = 115.0;\n\t\tratio = 12.0;\n\t\tu.z += 150.0;\n\t\tu.y -= largo;\n\t\tfloat sep = 20.0;\n\t\tratio -= 6.0 * clamp(0.5 * (p.y - sep - 100.0) / sep, 0.0, 1.0);\n\t\tratio -= 0.3 * ratio * clamp(pow(u.y / largo, 3.0), 1.0, 0.0);\t\t\n\t\tfloat antena = max(length(u.xz) - ratio, abs(u.y) - largo);\n\t\t\n\t\tfuselaje = min(fuselaje, antena);\n\t\t\n\t\t//tail, another deformed cilynder added to the main body\n\t\tu.xyz = p.xyz;\n\t\tu.z += 450.0;\n\t\tu.z *= 0.15 + 0.25 * step(-u.z, 0.0);\n\t\tratio = 30.0;\n\t\tfloat colaHeight = 300.0;\n\t\t\n\t\tinterpoler = u.y / colaHeight;\n\t\tratio -= 20.0 * interpoler;\n\t\tu.z += 11.0 * interpoler;\n\t\t\t\n\t\tfloat cola = max(length(u.xz) - ratio, abs(u.y) - colaHeight);\n\t\tcola = max(cola, -p.y);\n\t\t\n\t\t//This is a deformed sphere for the upper border of the tail\n\t\tu.y = p.y - colaHeight;\n\t\tu.y *= 0.3;\n\t\tcola = min(cola, length(u) - ratio);\n\t\t\n\t\tfuselaje = min(fuselaje, cola);\n\t\toutData.x = fuselaje;\n\t\t\n\t\t/*\n\t\tThe propeller is modeled deforming a spheres, there is the main sphere that holds\n\t\tthe blades defined in the \"alabe\" function. the blades are added to the main sphere\n\t\tthis part of the plain is treated as a different piece to have its own paiting.\n\t\t*/\n\t\t\n\t\tu.xyz = p.xyz;\n\t\tu.z = p.z - 600.0;\n\t\tu.y += 5.0;\n\t\tu.z *= 0.55;\n\t\tfloat helix =  length(u.xyz) - 42.0;\n\t\t\n\t\tfloat desface = -uAngle * 0.5;\n\t\tu.z = p.z - 615.0;\n\t\t\n\t\tfor(int i = 0; i < 3; i ++) helix = min(helix, alabe(u, desface + 120.0*float(i)));\n\t\thelix *= 0.3;\n\t\t\n\t\toutData.x = min( helix, outData.x );\n\t\t\t\n\t\t/*\n\t\tWings distance function, the wings are also modeled as a deformed\n\t\tcilynder and treated as a different piece to have its own paiting.\n\t\t*/\n\t\tu.xyz = p.xyz;\n\t\tu.z -= 300.0;\n\t\tu.z *= u.z > 0.0 ? 0.35 : 0.1;\n\t\tu.y += 130.0;\n\t\tratio = 30.0;\n\t\tvec2 sections = vec2(180.0, 1000.0);\n\t\tinterpoler = step(-abs(u.x), -sections.x) * pow((abs(u.x) - sections.x) / sections.y, 1.0);\n\t\tu.y -= 120.0 * interpoler;\n\t\tratio -= 20.0 * interpoler;\n\t\t\n\t\tfloat wings = max(length(u.yz) - ratio, abs(u.x) - sections.y);\n\t\t\n\t\t//these are deformed spheres that defines the borders of the wings.\n\t\tu.x = abs(p.x) - sections.y;\n\t\tu.x *= 0.3;\n\t\twings = min(wings, length(u) - ratio);\n\t\toutData.x = min( wings, outData.x );\n\n\t\t/*\n\t\tModeling of the back wings. ItÂ´s the same method used for the wings,\n\t\tbut there is no change of shape in the profile.\n\t\t*/\n\t\tu.xyz = p.xyz;\n\t\tu.z += 450.0;\n\t\tu.z *= 0.1 + 0.25 * step(-u.z, 0.0);\n\t\tratio = 20.0;\n\t\tfloat backWidth = 400.0;\n\t\tinterpoler = abs(u.x) / backWidth;\n\t\tratio -= 12.0 * interpoler;\n\t\tu.z += 12.0 * interpoler;\n\t\t\n\t\t//Deformed spheres for the borders of the back wings\t\n\t\tfloat backWings = max(length(u.yz) - ratio, abs(u.x) - backWidth);\n\t\tu.x = abs(p.x) - backWidth;\n\t\tu.x *= 0.3;\n\t\tbackWings = min(backWings, length(u) - ratio);\t\t\n\t\toutData.x = min( backWings, outData.x );\n\t\t\n\t\t/*\n\t\tModeling of the head (cockpit), since this part was modeled using \n\t\ta different file it had to be scaled to put in the plane. The model uses\n\t\ttwo deformed spheres \n\n\t\tSince there is a need to scale and adapt the head, another local coordinate\n\t\tsystem vector \"v\" is used to preserve the main \"P\" vector.\n\t\t*/\n\t\t\n\t\tvec3 v = p.xyz;\n\t\tv.y -= 120.0;\n\t\tv.z -= 110.0;\n\t\tv *= 2.7;\n\t\tv *= rotX (-4.8);\n\t\tu.xyz= v.xyz;\n\t\t\n\t\tu.x /= (0.65 + 0.15 * (200.0 - v.y) / 200.0);\n\t\tu.y = exp(v.y / 55.0);\n\t\tu.z /= (1.0 + 0.0025 * (200.0 - v.y));\n\t\t\n\t\t//this is the plane hood... \n\t\tvec3 w = u.xyz;\n\t\tw.y = exp((v.y - 185.0)/ 55.0);\n\t\tw.y *= 8200.0;\n\t\tw.x = 0.005 * pow(w.x, 2.0);\n\t\tw.x *= (1.0 + 0.001 * v.z);\n\t\tw.z *= 0.2 * step(-w.z, 0.0);\n\t\tfloat base = max(length(w) - 200.0, -v.y - 130.0);\n\t\tbase = max(base, v.z - 1300.0);\n\t\tbase = max(base, -v.z + 50.0);\n\t\t\n\t\t//Here we start with the cockpit... \n\t\tu.y = exp(v.y / 55.0);\n\t\tif(u.z > 0.0) {\n\t\t\tu.z *= 0.8;\n\t\t\tu.z *= (1.2 + pow(clamp((240.0 - v.y) / 200.0, 0.0, 1.0), 0.6));\n\t\t\tu.z /= (1.0 + 0.002 * (200.0 - v.y));\n\t\t} \n\t\t\n\t\tfloat head = max(length(u) - 200.0, -v.y - 130.0);\n\t\thead = min(head, base);\n\t\thead *= 0.5;\t\t\n\t\toutData.x = min( head, outData.x );\n\t\t\n\t\t\n\t\t//This is the landing train under the wings.\n\t\tu.xyz = p.xyz;\n\t\tratio = 10.0;\n\t\tlargo = 120.0;\n\t\t\t\n\t\tu.y += largo + 140.0;\n\t\tu.x = -abs(p.x) + 220.0;\n\t\tu.z -= 250.0;\n\t\tu *= rotZ(20.0);\n\t\t\t\n\t\tu.x = 0.02 * pow(u.x, 2.0);\n\t\tu.z = 0.02 * pow(u.z, 2.0);\n\t\tinterpoler = 0.0;\n\t\tinterpoler = step(-u.y, 0.0) * 0.9 * pow(clamp(0.5 * u.y / largo, 0.0, 1.0), 1.2);\n\t\tratio -= step(u.y , 0.0) * 5.0;\n\t\tscalarY = 0.5;\n\t\tu.z *= scalarY - interpoler;\n\t\t\t\n\t\tvec2 train = vec2(max(length(u.xz) - ratio, abs(u.y) - largo), 0.0);\n\t\t\t\n\t\tu.xyz = p.xyz;\n\t\tu.y += 2.0 * largo + 110.0;\n\t\tu.x = -abs(p.x) + 270.0;\n\t\tu.z -= 250.0;\n\t\tbase = train.x;\n\t\ttrain = min(train, max(length(u.yz) - 10.0, abs(u.x) - 40.0));\n\t\tu.x += 30.0;\n\t\ttrain = min(train, max(length(u.yz) - 15.0, abs(u.x) - 10.0));\n\t\tu.x += 20.0;\n\t\ttrain = min(train,  max(length(u.yz) - 40.0, abs(u.x) - 10.0));\n\t\ttrain = min(train, sdTorus(u, vec2(50.0, 15.0)));\n\t\t\t\n\t\ttrain.x = 0.5 * train.x;\n\n\n\t\tif(train.x < outData.x) outData.xy = train;\n\t\t\n\t\t//Back wheel, its another deformed cilynder.\n\t\tu.xyz = p.xyz;\t\t\t\n\t\tratio = 6.0;\n\t\tlargo = 60.0;\n\t\t\t\n\t\tu.y += largo + 40.0;\n\t\tu.z += 500.0;\n\t\tu *= rotX(-15.0);\n\t\t\t\n\t\tu.x = 0.02 * pow(u.x, 2.0);\n\t\tu.z = 0.02 * pow(u.z, 2.0);\n\t\tinterpoler = step(u.y, 0.0) * 0.9 * pow(clamp(0.5 * abs(u.y) / largo, 0.0, 1.0), 1.2);\n\t\tu.z += 10.0 * interpoler;\n\t\t\n\t\tscalarY = 0.5;\n\t\tu.z *= scalarY + interpoler;\n\t\t\t\n\t\tfloat backWheel = 0.5 * max(length(u.xz) - ratio, abs(u.y) - largo);\n\t\t\t\n\t\tu.xyz = p.xyz;\t\t\t\n\t\tratio = 5.0;\n\t\tlargo = 60.0;\n\t\t\t\n\t\tu.y += largo * 2.0 + 30.0;\n\t\tu.z += 515.0;\n\t\t\t\n\t\tbackWheel = min(backWheel, 0.5 * max(length(u.yz) - 32.0, abs(u.x) - 6.0));\t\t\n\t\toutData.x = min( backWheel, outData.x );\n\t\t\n\t\treturn outData;\t\n\t}\n\n\t//same function of the distance field to obtain colors...\n\tvec3 coloring(vec3 p) {\n\t\n\t\tp *= rotY(uAngle * 0.1);\n\t\tp *= rotX(7.0);\n\t\n\t\tvec3 outData = vec3(0.0, 0.0, 0.0);\t\t\t\t\n\t\tvec3 u = p.xyz;\n\t\t\n\t\tfloat ratio = 100.0;\n\t\tfloat largo = 600.0;\n\t\tfloat scalarY = 0.7;\n\t\tfloat scalarX = 0.015;\n\t\tfloat interpoler = 0.0;\n\t\tif(u.z > 0.0) {\n\t\t\tfloat sep = 80.0;\n\t\t\tfloat expo = 7.0 - 5.9 * clamp(0.5 * (p.y + sep) / sep, 0.0, 1.0);\n\t\t\tinterpoler = step(-u.z, 0.0) * pow(u.z / largo, expo);\n\t\t\tscalarX += 0.005 * interpoler;\n\t\t\tscalarY -= 0.5 * interpoler;\n\t\t\tratio -= 60.0 * interpoler;\n\t\t} else { \n\t\t\tfloat limite = step(u.z, 0.0) * abs(u.z) / largo;\n\t\t\tinterpoler =  pow(limite, 2.0);\n\t\t\tscalarX += 0.2 * pow(limite, 5.0);\n\t\t\tratio -= 70.0 * interpoler;\n\t\t\tu.y -= 40.0 * interpoler;\n\t\t}\n\t\tu.x = scalarX * pow(p.x, 2.0);\n\t\tu.y += step(u.y, 0.0) *scalarY * (ratio - abs(u.x));\n\t\tfloat fuselaje = 0.2 * max(length(u.xy) - ratio, abs(u.z) - largo);\n\t\t\t\t\n\t\tu.xyz = p.xyz;\n\t\tlargo = 115.0;\n\t\tratio = 12.0;\n\t\tu.z += 150.0;\n\t\tu.y -= largo;\n\t\tfloat sep = 20.0;\n\t\tratio -= 6.0 * clamp(0.5 * (p.y - sep - 100.0) / sep, 0.0, 1.0);\n\t\tratio -= 0.3 * ratio * clamp(pow(u.y / largo, 3.0), 1.0, 0.0);\t\t\n\t\tfloat antena = max(length(u.xz) - ratio, abs(u.y) - largo);\n\t\t\n\t\tfuselaje = min(fuselaje, antena);\n\t\t\n\t\tu.xyz = p.xyz;\n\t\tu.z += 450.0;\n\t\tu.z *= 0.15 + 0.25 * step(-u.z, 0.0);\n\t\tratio = 30.0;\n\t\tfloat colaHeight = 300.0;\n\t\t\n\t\tinterpoler = u.y / colaHeight;\n\t\tratio -= 20.0 * interpoler;\n\t\tu.z += 11.0 * interpoler;\n\t\t\t\n\t\tfloat cola = max(length(u.xz) - ratio, abs(u.y) - colaHeight);\n\t\tcola = max(cola, -p.y);\n\t\t\n\t\tu.y = p.y - colaHeight;\n\t\tu.y *= 0.3;\n\t\tcola = min(cola, length(u) - ratio);\n\t\t\n\t\tfuselaje = min(fuselaje, cola);\n\n\t\t/*\n\t\tPainting the main body, differents colors are used (defined in the main function),\n\t\tthe colors are defined in the \"y\" variable of the outData vector.\n\t\t*/\n\t\toutData.x = fuselaje;\n\t\toutData.y = step(-p.y, 11.0);\n\t\tu.z = p.z - 500.0;\n\t\tu.y = p.y + 11.0;\n\t\toutData.y += step(-u.y / 0.045, u.z) * step(u.y / 0.09, -u.z);\n\t\toutData.y += step(-u.y / 0.09, u.z) * step((u.y - 20.0)/ 0.09, -u.z) * step(u.z, -550.0);\n\t\t\n\t\tu.xyz = p.xyz;\n\t\tu.z += 300.0;\n\t\tfloat circle = length(u.yz);\n\t\toutData.y -= (outData.y - 3.0) * step(-circle, -60.0) * step(circle, 65.0);\n\t\toutData -= outData * step(circle, 60.0);\n\t\t\t\t\n\n\t\t/*\n\t\tThe propeller is modeled deforming a spheres, there is the main sphere that holds\n\t\tthe blades defined in the \"alabe\" function. the blades are added to the main sphere\n\t\tthis part of the plain is treated as a different piece to have its own paiting.\n\t\t*/\n\t\t\n\t\tu.xyz = p.xyz;\n\t\tu.z = p.z - 600.0;\n\t\tu.y += 5.0;\n\t\tu.z *= 0.55;\n\t\tfloat helix =  length(u.xyz) - 42.0;\n\t\t\n\t\tfloat desface = -uAngle * 0.5;\n\t\tu.z = p.z - 615.0;\n\t\t\n\t\tfor(int i = 0; i < 3; i++) helix = min(helix, alabe(u, desface + 120.0*float(i)));\n\t\thelix *= 0.3;\n\t\t\n\t\t//painting of the propeller\n\t\tif(helix < fuselaje) {\n\t\t\toutData.x = helix;\n\t\t\tu.xyz = p.xyz;\n\t\t\tu.y += 5.0;\n\t\t\tcircle = length(u.yx);\n\t\t\toutData.y = 4.0 * step(circle, 42.0) + 3.0 * step(-circle, -42.0) * step(circle, 200.0) + 5.0 * step(-circle, -200.0);\n\t\t}\n\t\t\n\t\t\n\t\t/*\n\t\tWings distance function, the wings are also modeled as a deformed\n\t\tcilynder and treated as a different piece to have its own paiting.\n\t\t*/\n\t\tu.xyz = p.xyz;\n\t\tu.z -= 300.0;\n\t\tu.z *= u.z > 0.0 ? 0.35 : 0.1;\n\t\tu.y += 130.0;\n\t\tratio = 30.0;\n\t\tvec2 sections = vec2(180.0, 1000.0);\n\t\tinterpoler = step(-abs(u.x), -sections.x) * pow((abs(u.x) - sections.x) / sections.y, 1.0);\n\t\tu.y -= 120.0 * interpoler;\n\t\tratio -= 20.0 * interpoler;\n\t\t\n\t\tfloat wings = max(length(u.yz) - ratio, abs(u.x) - sections.y);\n\t\t\n\t\t//these are deformed spheres that defines the borders of the wings.\n\t\tu.x = abs(p.x) - sections.y;\n\t\tu.x *= 0.3;\n\t\twings = min(wings, length(u) - ratio);\n\t\t\n\t\t\n\t\t//paiting of the wings.\n\t\tif(wings < outData.x) {\n\t\t\toutData.xy = vec2(wings, 0.0);\n\t\t\toutData.y += 2.0 * step(abs(p.x), sections.x);\n\t\t\toutData.y -= (outData.y - 1.0) * step(-abs(p.x) - 20.0, -sections.y);\n\t\t\toutData.y -= (outData.y - 1.0) * step(-p.z, -300.0);\n\t\t\t\n\t\t\tu.x = p.x - 900.0;\n\t\t\tu.z = p.z - 230.0;\n\t\t\tcircle = length(u.xz);\n\t\t\toutData.y -= (outData.y - 3.0) * step(-circle, -50.0) * step(circle, 55.0);\n\t\t}\n\t\t\n\t\t/*\n\t\tModeling of the back wings. ItÂ´s the same method used for the wings,\n\t\tbut there is no change of chape in the profile.\n\t\t*/\n\t\tu.xyz = p.xyz;\n\t\tu.z += 450.0;\n\t\tu.z *= 0.1 + 0.25 * step(-u.z, 0.0);\n\t\tratio = 20.0;\n\t\tfloat backWidth = 400.0;\n\t\tinterpoler = abs(u.x) / backWidth;\n\t\tratio -= 12.0 * interpoler;\n\t\tu.z += 12.0 * interpoler;\n\t\t\n\t\t//Deformed spheres for the borders of the back wings\t\n\t\tfloat backWings = max(length(u.yz) - ratio, abs(u.x) - backWidth);\n\t\tu.x = abs(p.x) - backWidth;\n\t\tu.x *= 0.3;\n\t\tbackWings = min(backWings, length(u) - ratio);\n\t\t\n\t\t\n\t\t//Painting of the back wings\t\t\n\t\tif(backWings < wings && backWings < fuselaje && backWings < helix) {\n\t\t\toutData.xy = vec2(backWings, 2.0);\n\t\t\toutData.y -= (outData.y - 1.0) * step(-abs(p.x), -380.0);\n\t\t\toutData.y -= (outData.y - 1.0) * step(-0.3 * u.z, -1.0);\n\t\t}\n\t\t\n\t\t/*\n\t\tModeling of the head (cockpit), since this part was modeled using \n\t\ta different file it had to be scaled to put in the plane. The model uses\n\t\tto deformed spheres \n\n\t\tSince there is a need to scale and adapt the head, another local coordinate\n\t\tsystem vector \"v\" is used to preserve the main \"P\" vector.\n\t\t*/\n\t\t\n\t\tvec3 v = p.xyz;\n\t\tv.y -= 120.0;\n\t\tv.z -= 110.0;\n\t\tv *= 2.7;\n\t\tv *= rotX (-4.8);\n\t\tu.xyz= v.xyz;\n\t\t\n\t\tu.x /= (0.65 + 0.15 * (200.0 - v.y) / 200.0);\n\t\tu.y = exp(v.y / 55.0);\n\t\tu.z /= (1.0 + 0.0025 * (200.0 - v.y));\n\t\t\n\t\t//this is the plane hood... the float base\n\t\tvec3 w = u.xyz;\n\t\tw.y = exp((v.y - 185.0)/ 55.0);\n\t\tw.y *= 8200.0;\n\t\tw.x = 0.005 * pow(w.x, 2.0);\n\t\tw.x *= (1.0 + 0.001 * v.z);\n\t\tw.z *= 0.2 * step(-w.z, 0.0);\n\t\tfloat base = max(length(w) - 200.0, -v.y - 130.0);\n\t\tbase = max(base, v.z - 1300.0);\n\t\tbase = max(base, -v.z + 50.0);\n\t\t\n\t\t//Here we start with the cockpit... the head float\n\t\tu.y = exp(v.y / 55.0);\n\t\tif(u.z > 0.0) {\n\t\t\tu.z *= 0.8;\n\t\t\tu.z *= (1.2 + pow(clamp((240.0 - v.y) / 200.0, 0.0, 1.0), 0.6));\n\t\t\tu.z /= (1.0 + 0.002 * (200.0 - v.y));\n\t\t} \n\t\t\n\t\tfloat head = max(length(u) - 200.0, -v.y - 130.0);\n\t\thead = min(head, base);\n\t\thead *= 0.5;\n\t\t\n\t\t\n\t\t/*\n\t\tThis is the painting of the head, it is divided in the white background, the eyes, the\n\t\t\"eyelashes\" and the black borders, the \"Z\" value of the outData vector is used to define a\n\t\tgradient to paint the eyes since these gradients have to be the same for differents\n\t\tlocal coordinates systems.\n\n\t\tThe gradient is defined using the local atan angle of each eye and the color is in the\n\t\tmain function of the shader.\n\t\t*/\n\t\t\n\t\tif(head < outData.x) {\n\n\t\t\toutData.xy = vec2(head, 1.0);\n\t\t\tfloat angle = atan(v.z, v.x);\n\t\t\tfloat eyesAngle = 35.0;\n\t\t\tfloat alturaOjos = 238.0;\n\n\t\t\toutData.y -= step(-angle, -radians(eyesAngle)) * step(angle, radians(180.0 - eyesAngle));\n\t\t\t\n\t\t\t//Painting the eyes...\n\t\t\tfloat eyesDistance = 50.0;\n\t\t\t\n\t\t\t//This vector defines the ratios or the different parts of the eye\n\t\t\tvec4 ratios = vec4(40.0, 35.0, 25.0, 4.0);\n\t\t\tu.xyz = v.xyz;\t\n\t\t\tu.x = -abs(v.x) + eyesDistance;\n\t\t\tu.y -=90.0;\n\t\t\tfloat eval = length(u.xy);\n\t\t\toutData.z = atan(u.y, u.x);\n\t\t\toutData.y -= (outData.y - 3.0) * step(-eval, -ratios.y) * step(eval, ratios.x) * step(-u.z, 0.0);\n\t\t\toutData.y -= (outData.y - 6.0) * step(-eval, -ratios.z) * step(eval, ratios.y) * step(-u.z, 0.0);\n\t\t\toutData.y -= (outData.y - 3.0) * step(eval, ratios.z) * step(-u.z, 0.0);\n\t\t\t\n\t\t\tu.x = v.x - eyesDistance;\n\t\t\tu.xy += vec2(10.0, -10.0);\n\t\t\toutData.y -= outData.y * step(length(u.xy), ratios.w) * step(-u.z, 0.0);\n\t\t\tu.x += eyesDistance * 2.0;;\n\t\t\toutData.y -= outData.y * step(length(u.xy), ratios.w) * step(-u.z, 0.0);\n\t\t\t\n\t\t\t\n\t\t\t//These are the \"eyelashes\"\n\t\t\tfloat sinAngle = 20.0 * sin(3.5 * angle);\n\t\t\tfloat cosAngle = 15.0 * cos(4.0 * angle);\n\t\t\toutData.y -= (outData.y - 1.0) * step(-v.y, - 135.0 - sinAngle);\n\t\t\toutData.y -= (outData.y - 1.0) * step(v.y, 40.0 - cosAngle);\n\n\t\t\t//these are the black borders lines.\n\t\t\tfloat thinkness = 2.0;\n\t\t\tfloat linearT = 5.0;\n\t\t\tfloat amm = radians(eyesAngle - thinkness);\n\t\t\tfloat amM = radians(eyesAngle + thinkness);\n\t\t\tfloat aMn = radians(180.0 - eyesAngle - thinkness);\n\t\t\tfloat aMM = radians(180.0 - eyesAngle + thinkness);\n\t\t\t\n\t\t\toutData.y -= (outData.y - 3.0) * step(-angle, -amm) * step(angle, aMM) * (step(-v.y, - alturaOjos + linearT) * step(v.y, alturaOjos + linearT) + step(angle, aMM)* step(-v.y, 0.0) * step(v.y, 2.0 * linearT));\n\t\t\toutData.y -= (outData.y - 3.0) * step(-v.y, 0.0) * step(v.y, alturaOjos + linearT) * (step(-angle, -amm) * step(angle, amM) + step(-angle, -aMn) * step(angle, aMM));\n\t\t\toutData.y -= (outData.y - 3.0) * step(-angle, -amm) * step(angle, aMM) * (step(-v.y, -sinAngle - 132.0) * step(v.y, sinAngle + 136.0) + step(-v.y, - 39.0 + cosAngle) * step(v.y, 43.0 - cosAngle));\n\t\t\n\t\t}\n\t\t\n\t\t/*\n\t\tThis is the landing train under the wings, it uses the landing train function\n\t\tdefined above and applies symmetry to draw the both needed. Since there are \n\t\tconcentrical cilynders in this case, the landingTrain function also specifies\n\t\tthe painting.\n\n\t\thence the landingTrain function returns a vec2, the \"x\" value gives the distance and the \"y\"\n\t\tvalue returns the color.\n\t\t*/\n\t\t\n\t\tu.xyz = p.xyz;\n\t\tratio = 10.0;\n\t\tlargo = 120.0;\n\t\t\t\n\t\tu.y += largo + 140.0;\n\t\tu.x = -abs(p.x) + 220.0;\n\t\tu.z -= 250.0;\n\t\tu *= rotZ(20.0);\n\t\t\t\n\t\tu.x = 0.02 * pow(u.x, 2.0);\n\t\tu.z = 0.02 * pow(u.z, 2.0);\n\t\tinterpoler = 0.0;\n\t\tinterpoler = step(-u.y, 0.0) * 0.9 * pow(clamp(0.5 * u.y / largo, 0.0, 1.0), 1.2);\n\t\tratio -= step(u.y , 0.0) * 5.0;\n\t\tscalarY = 0.5;\n\t\tu.z *= scalarY - interpoler;\n\t\t\t\n\t\tfloat train = max(length(u.xz) - ratio, abs(u.y) - largo);\n\t\t\t\n\t\tu.xyz = p.xyz;\n\t\tu.y += 2.0 * largo + 110.0;\n\t\tu.x = -abs(p.x) + 270.0;\n\t\tu.z -= 250.0;\n\t\tfloat eval = length(u.yz);\n\t\ttrain = min(train, max(eval - 10.0, abs(u.x) - 40.0));\n\t\tu.x += 30.0;\n\t\ttrain = min(train, max(eval - 15.0, abs(u.x) - 10.0));\n\t\tu.x += 20.0;\n\t\ttrain = min(train, max(eval - 40.0, abs(u.x) - 10.0));\n\t\ttrain = min(train, sdTorus(u, vec2(50.0, 15.0)));\n\t\t\t\n\t\ttrain = 0.5 * train;\n\t\t\t\t\n\t\tif(train < outData.x) {\n\t\t\toutData.x = train;\n\t\t\toutData.y = 0.0;\n\t\t\toutData.y += 4.0 * step(eval, 11.0);\n\t\t\toutData.y += 3.0 * step(-eval, -11.0) * step(eval, 16.0) * step(u.x, 50.0);\n\t\t\toutData.y += 7.0 * step(-eval, -16.0) * step(eval, 40.0) * step(u.x, 40.0);\n\t\t\toutData.y += 3.0 * step(-eval, -40.0) * step(u.x, 40.0);\n\t\t}\n\t\t\n\t\t//Back wheel, its another deformed cilynder.\n\t\tu.xyz = p.xyz;\t\t\t\n\t\tratio = 6.0;\n\t\tlargo = 60.0;\n\t\t\t\n\t\tu.y += largo + 40.0;\n\t\tu.z += 500.0;\n\t\tu *= rotX(-15.0);\n\t\t\t\n\t\tu.x = 0.02 * pow(u.x, 2.0);\n\t\tu.z = 0.02 * pow(u.z, 2.0);\n\t\tinterpoler = step(u.y, 0.0) * 0.9 * pow(clamp(0.5 * abs(u.y) / largo, 0.0, 1.0), 1.2);\n\t\tu.z += 10.0 * interpoler;\n\t\t\n\t\tscalarY = 0.5;\n\t\tu.z *= scalarY + interpoler;\n\t\t\t\n\t\tfloat backWheel = 0.5 * max(length(u.xz) - ratio, abs(u.y) - largo);\n\t\t\t\n\t\tu.xyz = p.xyz;\t\t\t\n\t\tratio = 5.0;\n\t\tlargo = 60.0;\n\t\t\t\n\t\tu.y += largo * 2.0 + 30.0;\n\t\tu.z += 515.0;\n\t\t\t\n\t\tfloat c1 = max(length(u.yz) - 32.0, abs(u.x) - 6.0);\n\t\tbackWheel = min(backWheel, c1);\n\t\t\t\n\t\tif(backWheel < outData.x)  outData.xy = vec2(backWheel, 3.0);\n\t\tif(outData.x == backWheel && c1 > backWheel) outData.y = 0.0;\n\t\t\n\t\treturn outData;\t\n\t}\n\t\n\t//Finite differences\n\tvec3 gradient( vec3 v ) {\n\t\tconst vec3 delta = vec3( grad_step, 0.0, 0.0 );\n\t\tfloat va = dist_field( v ).x;\n\t\treturn normalize (\n\t\t\tvec3(\n\t\t\t\tdist_field( v + delta.xyy).x - va,\n\t\t\t\tdist_field( v + delta.yxy).x - va,\n\t\t\t\tdist_field( v + delta.yyx).x - va\t\t\t\n\t\t\t)\n\t\t);\n\t}\n\n\t/*\n\tSince I have deformed many shapes (almost everything) I had to reduce the steps\n\tdistances used to aproximate the plane, hence thereÂ´s a depth_reduction value used to\n\tadapt the steps to obtain the correct shape.\n\n\tthe depth_reduction value is defined at the beginning of the shader, it can has values between\n\t0.2 and 0.5, above and under those values the shapes start to be badly rendered.\n\n\tSince this depth_reduction float requires more steps, it makes also the shader go very\n\tslow, try to lower the total iterations to gain some speed if its needed.\n\n\t*/\n\tvec3 ray_marching( vec3 origin, vec3 dir, float start, float end ) {\n\t\tfloat depth = start;\n\t\tvec3 salida = vec3(end);\n\t\tvec3 dist = vec3(100.0);\n\t\tfor ( int i = 0; i < max_iterations; i++ ) \t\t{\n\t\t\tif ( dist.x < stop_threshold || depth > end ) break;\n\t\t\t\n                dist = dist_field( origin + dir * depth );\n                depth += dist.x;\n\t\t}\n\t\t\n\t\tif( dist.x<stop_threshold ) {\n            dist = coloring( origin + dir * depth );\n            salida = vec3(depth, dist.y, dist.z);\n\t\t}\n\n\t\treturn salida;\n\t}\n\n\t/*\n\tThese are simple shadows, since there no need for quality here I could change the \n\tdepth_reduction value to 0.7 to speed up things.\n\t*/\n\tfloat shadow( vec3 v, vec3 light ) {\n\t\tvec3 lv = v - light;\n\t\tfloat end = length( lv );\n\t\tlv /= end;\n\t\t\n\t\tfloat depth = ray_marching( light, lv, 0.0, end ).x;\n\t\n\t\treturn step( end - depth, 0.5);\n\t}\n\n\t//the shading uses a simple phong method, no AO used, just a ambient light\n\tvec3 shading( vec3 v, vec3 n, vec3 eye ) {\n\t\n\t\tvec3 final = vec3( 0.0 );\n\t\n\t\tvec3 ev = normalize( v - eye );\n\t\tvec3 ref_ev = reflect( ev, n );\n\t\n\t\t{\n\t\t\tvec3 light_pos   = vec3(0.0, 2000.0, -2000.0);\n\t\t\tvec3 vl = normalize( light_pos - v );\n\t\t\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\t\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\t\tspecular = pow( specular, 128.0 );\n\t\t\tfinal += vec3( 0.9 ) * ( diffuse * 0.4 + specular * 0.9 );\n\t\t\t\n\t\t\t#ifdef SHADOWS\n\t\t\tfinal *= shadow( v, light_pos );\n\t\t\t#endif\n\t\n\t\t\tfinal += vec3(0.15);\n\t\t}\n\t\t\n\t\n\t\treturn final;\n\t}\n\n\t//Ray direction \n\tvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\t\tvec2 xy = pos - size * 0.5;\n\n\t\tfloat cot_half_fov = tan(radians( 90.0 - fov * 0.5 ));\t\n\t\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\t\treturn normalize( vec3( xy, z ) );\n\t}\n\n\tvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n\t{\n\t\tuAngle =  iTime * 200.0;;\n\t\t\t\n\t\tvec3 rd = ray_dir(50.0, iResolution.xy, fragCoord.xy );\n\t\t\n\t\tvec3 eye = vec3( 0.0, 00.0, -1800.0 );\n\t\n\t\tvec3 color = vec3(0.1);\n\n\t\tvec3 data = ray_marching( eye, rd, 0.0, clip_far );\n\t\tif ( data.x < clip_far ) {\n\t\t\t\n\t\t\tvec3 pos = eye + rd * data.x;\n\t\t\tvec3 n = gradient( pos );\n\t\t\tvec3 lightColor =  shading( pos, n, eye ) * 2.0;\n\n\t\t\t\n\t\t\tif(data.y == 0.0) color = vec3(1.0);\n\t\t\tif(data.y == 1.0) color =  vec3(0.8, 0.4, 0.0) ; //Naranja\n\t\t\tif(data.y == 2.0) color =  vec3(128.0, 181.0, 206.0)  / 255.0; //azul\n\t\t\tif(data.y == 3.0) color = vec3(0.1) ; // negro\n\t\t\tif(data.y == 4.0) color = vec3(0.5) ; // gris\n\t\t\tif(data.y == 5.0) color = vec3(1.0, 1.0, 0.0); // amarillo\n\t\t\tif(data.y == 6.0) color = vec3(0.5, 0.7, 0.9) * (0.01 + 0.99 * abs(cos(data.z + 1.3))); //gradiente o\n\t\t\tif(data.y == 7.0) color = vec3(0.4, 0.0, 0.0) ; //rojo\n\t\t\tcolor *= lightColor;\n\t\t}\n\t\t\t\n\t\tfragColor = vec4(color, 1.0 );\n\t} ","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Xdj3Dm","date":"1389893840","viewed":1824,"name":"Dusty","username":"hat","description":"Uncomment the line #37 for shadows. It requires a little tweaking to render it properly.","likes":24,"published":1,"flags":0,"usePreview":0,"tags":["raymarchingdistancefields"],"hasliked":0,"parentid":"","parentname":""}}