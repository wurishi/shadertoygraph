{"ver":"0.1","info":{"id":"WlKcRc","date":"1611478465","viewed":176,"name":"Flooded LowPolyLand","username":"ming","description":"Flooding water to the LowPolyLand shader (https://www.shadertoy.com/view/lsySRc).\nPerformance is improved by caching the poly noise in Buffer A; so the coastal flow map can by computed with JFA.\nMore details in the shader comments.","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["procedural","noise","water","flow","lowpoly","jfa","polynoise","cache"],"hasliked":0,"parentid":"lsySRc","parentname":"LowPolyLand"},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n Disclaimer:\n \"PolyNoise\" : https://www.shadertoy.com/view/ldGSzc\n \"LowPolyLand\" : https://www.shadertoy.com/view/lsySRc\n \"Jump Flooding DT\" : https://www.shadertoy.com/view/WlGyR3\n \n Attempt to flood water to the LowPolyLand shader.\n \n Here are the key modifications:\n - Buffer A stores the cached poly noise, for much faster ray-marching performance.\n - Buffer B conduct JFA on Buffer A, to compute the coastline distance.\n - Buffer C compute the flow map by calculating the gradient from Buffer B.\n - water foam is rendered with standard flow map method\n - the landscape is dynamically morphing :-)\n*/\n\n\nvec3 lightDir = normalize(vec3(1.0, .2, .0));\n\nmat3 lookat(vec3 from, vec3 to)\n{\n    vec3 f = normalize(to - from);\n    vec3 r = normalize(cross(vec3(0.0, 1.0, 0.0), f));\n    vec3 u = normalize(cross(-r, f));\n    return mat3(r, u, f);\n}\n\nfloat peakH(in vec3 rp)\n{\n    return smoothstep(0.21, 0.2, rp.y);\n}\n\nvec2 cache_uv(in vec3 rp)\n{\n    vec2 uv = ((rp - map_center()) / map_extends()).xz;\n    uv = uv * 0.5 + 0.5;\n    return uv;\n}\n\n\nfloat map(in vec3 rp)\n{\n    // fetch noise from cache\n    float noise = texture(iChannel0, cache_uv(rp)).r;\n    \n    float l = rp.y - noise * noise_scale();\n    \n    float bounds = sdBox(rp - map_center(), map_extends());\n    l = max(l, bounds);\n    \n    return l;\n}\n\nvec3 grad(in vec3 rp)\n{\n    vec2 off = vec2(0.005, 0.0);\n    vec3 g = vec3(map(rp + off.xyy) - map(rp - off.xyy),\n                  map(rp + off.yxy) - map(rp - off.yxy),\n                  map(rp + off.yyx) - map(rp - off.yyx));\n    return normalize(g);\n}\n\n\n//////////////////////\n//////////////////////\n\nvoid render_water(in vec3 rp, inout vec4 color)\n{\n    vec4 flow_data = texture(iChannel1, cache_uv(rp));\n    \n    float water = smoothstep(0.0, 0.1, flow_data.z);\n\n    if (water > 0. && rp.y > 0.01) {\n        vec4 water_color = vec4(0.0, 0.4180, 0.6758, 0.0);\n        vec4 foam_color = vec4(0.8125, 0.9609, 0.9648, 0.0);\n\n        vec2 foam_uv = rp.xz * 6.0;\n\n        vec2 flow = (flow_data.xy * 2.0 - 1.0);\n\n        // apply flow map rendering\n        float scaletime = (iTime) * 1.5;\n        float flow_t0 = fract(scaletime);\n        float flow_t1 = fract(scaletime + .5);\n        float alternate = abs((flow_t0 -.5) * 2.);\n        vec2 distort = flow * 0.125;\n\n        vec4 samp0 = texture(iChannel2, foam_uv + distort * flow_t0); \n        vec4 samp1 = texture(iChannel2, foam_uv + distort * flow_t1);\n\n        float foam_opacity = mix(samp0, samp1, alternate).r;\n        foam_opacity *= (1.0 - smoothstep(0.25, 0.5, flow_data.z));\n\n        // foam compose of the distance to coastline and the foam noise\n        float foam = 1.0 - smoothstep(0.0, 0.3, flow_data.z);\n        foam = min(1.0, foam + foam_opacity);\n\n        // make the water color varies accord to water depth\n        float depth = min(1.0, (water_threshold() - rp.y) / 0.02);\n        water_color = mix(water_color, water_color * water_color, flow_data.w * depth);\n        \n        // apply foam\n        water_color = mix(water_color, foam_color, foam);\n\n        color = mix(color, water_color, water);\n    }\n}\n\nvec4 render(in vec3 rp, in vec3 rd)\n{\n    vec3 g = grad(rp);\n    vec4 color1 = vec4(.8, .8, .1, .0) * clamp( (rp.y + 0.1) * 3.0, 0.05, 1.0);\n    vec4 color2 = vec4(.8, .6, .1, .0) * 1.4;\n    \n    float peak = peakH(rp);\n    vec4 color = mix(color1, color2, smoothstep(0.1, 0.12, rp.y));\n    color += mix(vec4(1.0), vec4(.0), peak);\n    \n    float d = dot(g, lightDir);\n    d = clamp(d, 0.0, 1.0);\n    d = mix(d, 1.0, 0.2);\n    color *= d;\n    \n    render_water(rp, color);\n    \n\treturn color;\n}\n\nvoid trace(in vec3 rp, in vec3 rd, inout vec4 color)\n{\n    bool hit = false;\n    vec3 ro = rp;\n    \n    float closest = 999.0;\n    vec3 closestPoint = vec3(0.0);\n    float dist = 0.0;\n    for (int i = 0; i < 256; ++i)\n    {\n        \n        dist = map(rp);\n        \n        if(dist < 0.0)\n        {\n            hit = true;\n            break;\n        }\n        rp += rd * max(dist, 0.015) * 0.2;\n       \n        vec3 dist = ro - rp;\n        if(dot(dist, dist) > 25.) break;\n    }\n    \n    // some more steps for better accuracy\n    if(hit)\n    {\n        for (int i = 0; i < 8; ++i)\n        {\n            rp += dist * rd * 0.15;\n\t        dist = map(rp);\n        }\n    }\n    \n    float ap = 1.0;\n    if(hit)\n    {\n        color = render(rp, rd);\n        vec3 dist = ro - rp;\n        \n        // some kind of fake aerial perspective effect\n        ap = min(1.0, smoothstep(0.2, 0.3, rp.y));\n        ap *= smoothstep(2.5, 3.0, length(dist));\n        ap *= 0.7;\n    }\n    \n    vec4 bgcolor = mix(\n        vec4(0.8, 0.9, 1.0, 1.0), \n        vec4(0.3, 0.65, 1.0, 1.0),\n        smoothstep(-0.625, -0.5, rd.y));\n\n    color = mix(color, bgcolor, ap);\n    \n    // Gamma 2.2\n    color.rgb = pow(color.rgb, vec3(0.454545));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= vec2(0.5);\n    uv.y /= iResolution.x / iResolution.y;\n    \n    r1 = rotate(2.4);\n    r2 = rotate(0.4);\n    r3 = rotate(-2.0);\n    \n    float T = iTime * 0.125;\n    vec2 m = vec2(sin(T * 0.1) * 0.5,  -0.1 - 0.2 * (cos(T * 0.2) * 0.5 + 0.5));\n    if(iMouse.z > 0.0)\n    {\n\t\tm = ((iMouse.xy / iResolution.xy) - vec2(0.5));\n    }\n    \n    vec2 im = vec2(12.0, 2.0) * m;\n    vec3 rd = normalize(vec3(uv, 1.0));\n    vec3 rp = vec3(0.0, 1.0, -2.5);\n    vec3 lookTo = vec3(0.0, 0.0, 0.0);\n    rp = roty(im.x) * rp;\n    rp.y = -im.y * 4.0;\n    rd = lookat(rp, lookTo) * rd;\n    \n    fragColor = vec4(0.0);\n    trace(rp, rd, fragColor);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//////// Ray Marching Related\n\nvec3 map_center()\n{\n    return vec3(0.0, 0.4, 0.0);\n}\n\nvec3 map_extends()\n{\n    return vec3(1.0, .5, 1.0);\n}\n\nfloat noise_scale()\n{\n    return 0.8;\n}\n\nfloat water_threshold()\n{\n    return 0.05;\n}\n\nbool is_abovewater(vec4 noise)\n{\n    return noise.r * noise_scale() > water_threshold();\n}\n\nfloat coast_width()\n{\n    return 32.0;\n}\n\nconst float PI = 3.14159265;\nmat2 r1; mat2 r2; mat2 r3;\n\n\nmat3 rotx(float a) { mat3 rot; rot[0] = vec3(1.0, 0.0, 0.0); rot[1] = vec3(0.0, cos(a), -sin(a)); rot[2] = vec3(0.0, sin(a), cos(a)); return rot; }\nmat3 roty(float a) { mat3 rot; rot[0] = vec3(cos(a), 0.0, sin(a)); rot[1] = vec3(0.0, 1.0, 0.0); rot[2] = vec3(-sin(a), 0.0, cos(a)); return rot; }\nmat3 rotz(float a) { mat3 rot; rot[0] = vec3(cos(a), -sin(a), 0.0); rot[1] = vec3(sin(a), cos(a), 0.0); rot[2] = vec3(0.0, 0.0, 1.0); return rot; }\nmat2 rotate(float a) { return mat2(cos(a), sin(a), -sin(a), cos(a)); }\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rnd(vec2 p)\n{\n    return abs(rand(p)) * 0.8 + 0.1;\n}\n\nfloat value (float x, float randx)\n{\n    float a = min(x/randx, 1.0);\n    float b = min(1.0, (1.0 - x) / (1.0 - randx));\n    return a + (b - 1.0);\n}\n\nfloat polynoise(vec2 p)\n{\n    vec2 seed = floor(p);\n    vec2 rndv = vec2( rnd(seed.xy), rnd(seed.yx));\n    vec2 pt = fract(p);\n    float bx = value(pt.x, rndv.x);\n    float by = value(pt.y, rndv.y);\n    return min(bx, by) * abs(rnd(seed.xy * 0.1));\n}\n\n\nfloat polyfbm(vec2 p)\n{\n    vec2 seed = floor(p);\n    float m1 = polynoise(p * r2);\n    m1 += polynoise ( r1 * (vec2(0.5, 0.5) + p));\n    m1 += polynoise ( r3 * (vec2(0.35, 0.415) + p));\n    m1 *= 0.33;\n    \n    float m2 = polynoise (r3 * (p * 2.4));\n    m1 += m2 * 0.05;\n    return m1;\n}\n\nfloat stonepolyfbm(vec2 p)\n{\n    vec2 seed = floor(p);\n    float m1 = polynoise(p * r2);\n    m1 += polynoise ( r1 * (vec2(0.5, 0.5) + p));\n    m1 *= 0.5;\n\treturn m1;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\n//////// JFA Related\n// 4096 = 2^12; and 1 init step\n#define pass_id() mod(float(iFrame),13.0);\n#define last_pass_id 12.0\n\n\nvoid store(out vec4 t, vec4 v) {\n    t = v;\n}\n\nvec4 load(sampler2D channel, vec2 res, ivec2 p) {\n    vec2 uv = (vec2(p)-0.5) / res;\n    return texture(channel, uv);\n}\n\n#define load0(p) load(iChannel0, iChannelResolution[0].xy, p)\n#define load1(p) load(iChannel1, iChannelResolution[1].xy, p)","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Buffer A: PolyNoise cache \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 pos = uv * 2.0 - 1.0;\n    pos = pos * map_extends().xz + map_center().xz;\n    \n    r1 = rotate(2.4);\n    r2 = rotate(0.4);\n    r3 = rotate(-2.0);\n    \n    float n1 = polyfbm(pos * 1.4);\n    float n2 = polyfbm(pos * 1.4 + vec2(11., 3.));\n    \n    float w = (sin(iTime * 0.3));\n    w = w * w;\n    w = smoothstep(0.4, 0.6, w);\n    float n = mix(n1, n2, w);\n    fragColor = vec4(n);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Buffer B: Jump Flooding iterations\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float pass = pass_id();\n    \n    ivec2 tc = ivec2(fragCoord + 0.5);\n    \n    if (pass < 0.5) {\n        // init\n        vec4 noise = load1(tc);\n        \n        // store the coordinate for non-empty pixels, otherwise zero\n        if (is_abovewater(noise)) {\n            store(fragColor, vec4(fragCoord,0.0,0.0));\n        } else {\n            store(fragColor, vec4(0.0));\n        }\n    } else {\n        // JFA passes (for up to 4096x4096, 0 - 11)\n        float level = clamp(pass - 1.0, 0.0, 11.0);\n        int stepwidth = int(exp2(11.0 - level)+0.5);\n        \n        \n        float best_dist = 999999.0;\n        vec2 best_coord = vec2(0.0);\n        vec2 center = vec2(tc);\n        \n        // search the 3x3 neighbours\n        for (int y = -1; y <= 1; ++y) {\n            for (int x = -1; x <= 1; ++x) {\n                ivec2 fc = tc + ivec2(x,y)*stepwidth;\n\t\t        vec2 ntc = load0(fc).xy;\n                \n                if ((ntc.x != 0.0) && (ntc.y != 0.0)) {\n                    // compare the squared distance\n                    vec2 diff = ntc - center;\n                    float d = dot(diff, diff);\n                    if (d < best_dist) {\n                        best_dist = d;\n                        best_coord = ntc;\n                    }\n                }\n            }\n        }        \n        store(fragColor,vec4(best_coord,0.0,0.0));\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Buffer C: Compute flow map from each JFA iteration\n\nfloat getD(vec2 center)\n{\n    ivec2 tc = ivec2(center + 0.5);\n    \n    vec2 nearest = load0(tc).xy;\n        \n    vec2 diff = nearest - center;\n    return length(diff);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float pass = pass_id();\n    \n    if (pass == last_pass_id) {\n        // update from Buffer A in every last pass in each iteration\n        vec2 center = fragCoord;\n        \n        float inv_width = 1.0 / coast_width();\n        float s = 1.0;\n        vec4 dxdy;\n        dxdy.x = getD(center + vec2(-s, 0.0)); //-x\n        dxdy.y = getD(center + vec2( s, 0.0)); //+x\n        dxdy.z = getD(center + vec2( 0.0,-s)); //-y\n        dxdy.w = getD(center + vec2( 0.0, s)); //+y\n        \n        vec4 dxdy1 = min(vec4(1.0), dxdy * inv_width);\n        vec4 dxdy2 = min(vec4(1.0), dxdy * inv_width * 0.5);\n        \n        //float d = min(1.0, getD(center) * inv_width); \n        float d1 = dot(dxdy1, vec4(0.25));\n        float d2 = dot(dxdy2, vec4(0.25));\n        \n        // flow = gradient\n        vec2 flow = vec2(dxdy1.x - dxdy1.y, dxdy1.z - dxdy1.w);\n        \n        // safe normalize\n        float len = length(flow);\n        \n        if (len > 1e-7)\n            flow = flow / len;\n        else\n            flow = vec2(0.0, 0.0);\n            \n        // fade out the flow\n        \n        store(fragColor, vec4(flow * 0.5 + 0.5, d1, d2));\n    }\n    else {\n        // otherwise keeps Buffer B's cached results\n        store(fragColor, load1(ivec2(fragCoord + 0.5)));\n    }\n}\n","name":"Buffer C","description":"","type":"buffer"}]}