{"ver":"0.1","info":{"id":"MtdyDX","date":"1534840979","viewed":218,"name":"Faster Iterative 2D Histogram","username":"nalivai","description":"XY coordinates are encoded in RG channels. Pixels distributed randomly \nUsing a little bit more information about surrounding pixels, sorting and merging in the same frame lets produce histogram much faster than here:\nhttps://www.shadertoy.com/view/lt3czl","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["sotring","computation","historgram"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Fedor Petrov\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    // rotate UV around 0.5 0.5\n    vec2 uv2 = uv - vec2(0.5);\n    float f = float(iFrame);\n    uv2.x += uv2.y*sin(f*0.01)*0.05*f/(420.0+f);\n    uv2.y -= uv2.x*sin(f*0.01)*0.05*f/(420.0+f);\n    uv2 += vec2(0.5);\n\tvec4 frag = texture(iChannel0,uv2);\n    float bb = sqrt(sqrt(frag.b));\n\tfrag.rgb = iMouse.z>0.0 ? vec3(bb,bb,bb) : frag.rgb;\n    fragColor = frag;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by Fedor Petrov\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n/*-------------------------------------------------------------------------------\nV.0.2 this is a much more optimal and fast iterative historgram \ncompared to the one I made before. It takes information from 4 nearby\ncells and sorts them according to their distance to the \"encoded\" position.\nThis happens in one frame. Merging of \"bins/particles\" happens in the same frame.\nIn the next frame new four cells are taken overlapping with the previous ones.\n\nPress LMB to see in black and white changes in blue channel.\n\n--------------------------------------------------------------------------------*/\n\n#define PI 3.1415926\n#define ESIZE 0.25\n#define EDIST 0.25\n#define YDIST 0.25\n#define FSIZE 0.95\n#define MSIZE 0.25\n\n//pseudo random\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 4378.5453);\n}\n// CREATING AND \"ENCODING\" SOME ALIEN CHARACTERS\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ratio = iResolution.y/iResolution.x;\n    float tSeed = 0.5+0.5*sin(iDate[3])/10.0;\n    vec2 uv = fragCoord/iResolution.xy;\n    float rnd = rand(sin(33.333*uv)+tSeed);\n    float phi = 8.0*PI*rand(sin(40.0*uv)+tSeed);\n    float phase = PI*rand(vec2(0.0)+tSeed);\n    float ri = sqrt(0.1+0.8*phi/8.0/PI+0.1*rand(0.5*uv+tSeed));\n    float X = 0.0;\n    float Y = 0.0;\n    float j = floor(8.0*rnd)-3.5;\n    float k = floor(4.0*rand(sin(23.333*uv)))-1.5;\n    X = 0.5+0.5*sin(phase+phi*(k)*0.5)*ri*ESIZE*ratio-EDIST*j*ratio;\n    Y = 0.5+0.5*cos(phase+phi*(j+k-0.25)*0.5)*ri*ESIZE+YDIST*k;\n\tX += (0.5-X)*0.2;\n    Y += (0.5-Y)*0.2;\n    if(iFrame<30)\n    {\n    fragColor = vec4(X,Y,0.01,1.0);\n    }\n    else\n    {\n    fragColor = texture(iChannel0,uv);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Created by Fedor Petrov\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n/*-------------------------------------------------------------------------------\nV.0.2 this is a much more optimal and fast iterative historgram \ncompared to the one I made before. It takes information from 4 nearby\ncells and sorts them according to their distance to the \"encoded\" position.\nThis happens in one frame. Merging of \"bins/particles\" happens in the same frame.\nIn the next frame new four cells are taken overlapping with the previous ones.\n\nV 0.3 24.08.2018 removing boundary constrains \ni.e. setting periodic boundary conditions and calculating distance through\nthe boundary when it is shorter increased the convergence by factor 2\nfrom ~12 seconds to ~6 seconds.\n--------------------------------------------------------------------------------*/\n\n#define T(U) texture(iChannel0,uv+(U))\n\n// the function merges the pixels/particles/... \n// if their RG channels multiplied by the screen size are identical\n// blue channel is used for counting\n// hence if there ф ьфеср one particle's blue channel \n// is increased by the value of another\n// \n//vec4[4] \nvoid merge(out vec4 p[4], vec2 W)\n{\nfor(int i=0;i<4;i++)\n{\n    for(int j=0;j<4;j++)\n\t{\n\tif(floor(p[j].rg*W) == floor(p[i].rg*W) && i!=j && p[j].b!=0.0 && p[i].b!=0.0)\n    \t{\n        p[j] += vec4(0.0,0.0,p[i].b,0.0);\n        p[i] *= 0.0;\n        }\n    }\n}\n//return p;\n}\n\n// the function performs swapping in the chosen direction for two given array elements\nvoid swap(out vec4 p[4],out vec2 d[4], vec2 dir, int axis, int i1, int i2)\n{\n\tif((d[i1][axis]*dir[axis]>d[i2][axis]*dir[axis] && p[i1].b!=0.0 && p[i2].b!=0.0)\n      ||(d[i1]==vec2(0.0) && d[i2][axis]*dir[axis]<0.0 && p[i1].b!=0.0 && p[i2].b!=0.0)\n      ||(d[i1][axis]*dir[axis]>0.0 && d[i2]==vec2(0.0) && p[i1].b!=0.0 && p[i2].b!=0.0)\n      ||(p[i1].b==0.0 && d[i2][axis]*dir[axis]<0.0)\n      ||(p[i2].b==0.0 && d[i1][axis]*dir[axis]>0.0)\n      )\n    {\n    vec4 p0=p[i1];    p[i1] = p[i2];\n    p[i2] = p0;    p0.rg = d[i1];\n    d[i1] = d[i2];    d[i2] = p0.rg;\n    }\n}\n\n// the function performs swapping in all the directions\n// first the horizonal swaps (if necessary)\n// then the vertical swaps (if necessary)\nvec4 moveTo(vec4 p[4], vec2 d[4], vec2 dir)\n{\n    swap(p,d,dir,0,0,1);\n    swap(p,d,dir,0,2,3);\n    swap(p,d,dir,1,0,2);\n\tswap(p,d,dir,1,1,3);\n    return p[0];\n}\n\n// the function finds out whether the distance via the boundary is shorter\n// and assigns it to diff\nvoid findShorter(out vec2 diff[4], vec2 W)\n{\nfor(int j=0;j<4;j++)\n{\n\tfor(int k=0;k<2;k++)\n\t{\n\tif(diff[j][k]>0.0 && -diff[j][k]+W[k]<diff[j][k])\n\t\t{\n\t\tdiff[j][k] = diff[j][k]-W[k];\n\t\t}\n\telse if(diff[j][k]<0.0 && diff[j][k]+W[k]<-diff[j][k])\n\t\t{\n\t\tdiff[j][k] = diff[j][k]+W[k];\n\t\t}\n\t}\n}\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 FC = floor(fragCoord);\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 W = iResolution.xy;\n    float WX = iResolution.x;\n    float WY = iResolution.y;\n    float X = FC.x;\n    float Y = FC.y;\n    vec2 texel = 1.0/iResolution.xy;\n    vec2 dx = vec2(texel.x,0.0);\n    vec2 dy = vec2(0.0,texel.y);\n\n    //square\n    float xs = float((int(X)+iFrame)%2)*2.0-1.0;\n    float ys = float((int(Y)+iFrame)%2)*2.0-1.0;\ndx = vec2(xs,0.0)*texel.x;\ndy = vec2(0.0,ys)*texel.y;\nvec2 dxs = vec2(xs,0.0);\nvec2 dys = vec2(0.0,ys);\nif ((xs>0.0 && X==WX-1.0) || (xs<0.0 && X==0.0))\n{\n\tdx = vec2(-xs,0.0)*texel.x*(WX-1.0);\n\tdxs = -xs*vec2(WX-1.0,0.0);\n}\nif ((ys>0.0 && Y==WY-1.0) || (ys<0.0 && Y==0.0))\n{\n\tdy = vec2(0.0,-ys)*texel.y*(WY-1.0);\n\tdys = -ys*vec2(0.0,WY-1.0);\n}\n\t\nvec4 c = T(vec2(0.0,0.0));\nvec4 x = T(dx);\nvec4 y = T(dy);\nvec4 xy = T(dx + dy);\nvec4 p[4];p[0]=c;p[1]=x;p[2]=y;p[3]=xy;\nvec2 diff[4]; \nmerge(p,W);\ndiff[0]=-(FC - floor(p[0].rg*W));\ndiff[1]=-(FC + dxs - floor(p[1].rg*W));\ndiff[2]=-(FC + dys - floor(p[2].rg*W));\ndiff[3]=-(FC + dxs+dys - floor(p[3].rg*W));\nvec2 dir = vec2(xs,ys);\nfindShorter(diff,W);\nc = moveTo(p,diff,dir);\nfragColor = c;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Created by Fedor Petrov\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec4 frag = texture(iChannel0,uv);\n    vec4 frag2 = texture(iChannel1,uv);\n    fragColor = frag*0.1 + frag2*0.9;\n}","name":"Buffer C","description":"","type":"buffer"}]}