{"ver":"0.1","info":{"id":"ds3SR4","date":"1679434884","viewed":357,"name":"cloudy i think","username":"kaleidoscope","description":"an experiment","likes":30,"published":1,"flags":32,"usePreview":0,"tags":["noise","clouds"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define itr 16\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv   = fragCoord/iResolution.xy;\n         \n    vec3 col  = vec3(0);\n    vec2 uvR  = uv, uvG = uv, uvB = uv;\n    \n    for(int i=0; i<itr; i++)\n    {\n       vec3 tex  = texture(iChannel0, uvR).xyz;\n            uvR += tex.xy*.0065;\n          col.r += tex.z;\n      \n            tex  = texture(iChannel0, uvG).xyz;\n            uvG += tex.xy*.01;\n          col.g += tex.z;\n            \n            tex  = texture(iChannel0, uvB).xyz;\n            uvB += tex.xy*.0135;\n          col.b += tex.z;\n    }\n    \n         col   = col/float(itr)/sqrt(2.);\n         col   = exp(-col*7.);\n         col   = pow(col,vec3(.45));\n   float v     = pow(clamp(1.1-length(uv-.6),0.,1.),3.5);\n    vec3 vin   = pow(vec3(0.047,0.208,0.733)*v,vec3(.45));\n         col   = mix(vin,col,pow(v,.45));\n     fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv =    (2.*fragCoord-iResolution.xy)/iResolution.y;\n          \n    float noise  = smoothNoise(uv*1.25 -iTime*vec2(.025,.024) -60., 8., .5);\n    float noise1 = smoothNoise(uv*1.25 -.5 -iTime*.1 -60., 8., .5);\n    vec2  noises = vec2(noise,noise1);\n          noises = pow(noises,vec2(1.7));\n          noises = noises*2.-1.;\n    fragColor    = vec4(noises,length(noises),1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"float hash12(vec2 p) //Dave_Hoskins\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n         p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// a modified version of smooth noise by the art of code. adds a roughness parameter.\nfloat noiseOctave(vec2 uv, float frq)\n{\n     \n    vec2  ID      =  floor(uv*frq);\n    vec2  smoothM =  fract(uv*frq);\n          smoothM =  smoothM*smoothM*(3.-2.*smoothM);\n    float mix1    =  mix( hash12(ID), hash12(ID + vec2(1.,0.) ) , smoothM.x);\n    float mix2    =  mix( hash12(ID + vec2(0.,1.)), hash12(ID + vec2(1.,1.) ) , smoothM.x);\n    return mix(mix1, mix2 , smoothM.y);\n}\n\nfloat smoothNoise(vec2 uv, float amt, float roughness)\n{\n    float octave = 0.;\n    float frq    = 1.5;\n    float norm   = 1.;\n    float bias   = 1.;\n   \n    for(float i = 0.; i < amt;i++)\n    {\n        octave += noiseOctave(uv,frq)*bias;\n        bias   *= roughness;\n        norm   += bias;\n        frq    *= 2.05;\n    }\n\n     return octave /= norm;   \n}","name":"Common","description":"","type":"common"}]}