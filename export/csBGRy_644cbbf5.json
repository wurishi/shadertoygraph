{"ver":"0.1","info":{"id":"csBGRy","date":"1667762268","viewed":120,"name":"3 body 1/sqrt(r) force law","username":"neurofuzzy","description":"3 body fractal. Thanks to @b_artdek for the initial conditions and the idea to use the 1/sqrt(r) force law! Each pixel corresponds to a different initial condition. The smallest distance over the course of the simulation is plotted.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["simulation","physics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nThe 3 body problem with F(r)=-1/sqrt(r)\nG=m1=m2=m3=1\npos1=(x,y), pos2=(0,1), pos3=(0,-1).\nvel1=(0.0,0.0), vel2=(0.0,0), vel3=(0.0,0).\n\n*/\n\n\nconst int ntimesteps=400; //timesteps, higher = smaller dt. Computational time \\propto ntimesteps\n//if you're on a workstation change this to ntimesteps=4000, for renders ntimesteps=12000 or higher is even better.\nconst int ss=1; // supersampling. Computational time \\propto ss^2\nconst float scale=6.0; //scale, higher = more zoomed out\nconst float exponent=0.5; //F(r) \\propto -1/r^exponent.\n\n\nfloat metric(float a1,float b1,float c1,float d1,float a2,float b2,float c2,float d2){\n    return 4.0-2.0*cos(a1-a2)-2.0*cos(b1-b2)+(c1-c2)*(c1-c2)+(d1-d2)*(d1-d2);\n}\n\nvec4 getFrag(float x1, float y1, float dt, int ntimesteps) {\n\n    float x3=0.0,y3=-1.0,x2=0.0,y2=1.0;\n    //float p3x=0.707,p3y=0.0,p2x=-0.707,p2y=0.0,p1x=0.0,p1y=0.0;\n    float p3x=0.0,p3y=0.0,p2x=0.0,p2y=0.0,p1x=0.0,p1y=0.0;\n    float d12=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n    float d23=(x2-x3)*(x2-x3)+(y2-y3)*(y2-y3);\n    float d31=(x3-x1)*(x3-x1)+(y3-y1)*(y3-y1);\n    float m=min(d12,d31);\n    \n    for(int i=0;i<ntimesteps;i++){\n        d12=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n        d23=(x2-x3)*(x2-x3)+(y2-y3)*(y2-y3);\n        d31=(x3-x1)*(x3-x1)+(y3-y1)*(y3-y1);\n        //m=min(m,min(d12,min(d23,d31)));\n        //m=min(m,min(d31,d12));\n        m=min(m,d23);\n        d12=pow(d12,-0.5*(1.0+exponent));\n        d23=pow(d23,-0.5*(1.0+exponent));\n        d31=pow(d31,-0.5*(1.0+exponent));\n        p1x += dt* ((x2-x1)*d12+(x3-x1)*d31);\n        p1y += dt* ((y2-y1)*d12+(y3-y1)*d31);\n        p2x += dt* ((x3-x2)*d23+(x1-x2)*d12);\n        p2y += dt* ((y3-y2)*d23+(y1-y2)*d12);\n        p3x += dt* ((x2-x3)*d23+(x1-x3)*d31);\n        p3y += dt* ((y2-y3)*d23+(y1-y3)*d31);\n        x1 += dt*p1x;\n        y1 += dt*p1y;\n        x2 += dt*p2x;\n        y2 += dt*p2y;\n        x3 += dt*p3x;\n        y3 += dt*p3y;\n    }\n    \n    float h=-log(m/2.0)/16.0;\n    return vec4(h,h,h,1.0);;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float totaltime=iTime/3.0;\n    float dt=totaltime/float(ntimesteps);\n    \n   \tvec2 xpos = (fragCoord.xy-iResolution.xy*0.5)*2.0/iResolution.xx;\n    \n    float x1=xpos.x*scale,y1=xpos.y*scale;\n    \n    float dx=2.0*scale/(iResolution.x*float(ss));\n    \n    vec4 fragAverage=vec4(0.0,0.0,0.0,1.0);\n    \n    for(int i=0;i<ss;i++){\n        for(int j=0;j<ss;j++){\n            fragAverage+=getFrag(x1+float(i)*dx,y1+float(j)*dx,dt,ntimesteps);\n        }\n    }\n\n    fragColor = fragAverage/float(ss*ss);\n    \n}\n","name":"Image","description":"","type":"image"}]}