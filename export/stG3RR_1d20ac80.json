{"ver":"0.1","info":{"id":"stG3RR","date":"1637051904","viewed":99,"name":"Line distance","username":"Sasquatch5","description":"Line distance","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["distance"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265\n#define TWO_PI 2.*PI\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\nfloat dLine( vec2 p, vec2 a, vec2 b ) {\n    vec2 v = a, w = b;\n    \n    float l2 = pow(distance(w, v), 2.);\n    if(l2 == 0.0) return distance(p, v);\n    \n    float t = clamp(dot(p - v, w - v) / l2, 0., 1.);\n    vec2 j = v + t * (w - v);\n    \n    return distance(p, j);   \n}\nfloat dAlongLine(vec2 p, vec2 a, vec2 b){\n    return dot(normalize((b-a)),p-a);\n}\n\nvec2 midPoint(vec2 a, vec2 b){\n    return (a+b)/2.0;\n}\n\nmat2 r2D(float a) {\n\tfloat c = cos(a), s = sin(a);\n\t// https://en.wikipedia.org/wiki/Rotation_matrix\n    // https://www.khronos.org/opengl/wiki/Data_Type_(GLSL)#Matrix_constructors\n    return mat2(\n        c, s, // column 1\n        -s, c // column 2\n    );\n}\n\nvec3 HUEtoRGB(in float hue)\n{\n    // Hue [0..1] to RGB [0..1]\n    // See http://www.chilliant.com/rgb2hsv.html\n    vec3 rgb = abs(hue * 6. - vec3(3, 2, 4)) * vec3(1, -1, -1) + vec3(-1, 2, 2);\n    return clamp(rgb, 0., 1.);\n}\nvec3 HSVtoRGB(in vec3 hsv)\n{\n    // Hue-Saturation-Value [0..1] to RGB [0..1]\n    vec3 rgb = HUEtoRGB(hsv.x);\n    return ((rgb - 1.) * hsv.y + 1.) * hsv.z;\n}\n\nfloat solidAngle(vec2 uv, vec2 a, vec2 b){\n    float angleA = abs(atan((uv-a).y,(uv-a).x))/2.0;\n    float angleB = abs(atan((uv-b).y,(uv-b).x))/2.0;\n    return abs((angleA+angleB)/0.5)/PI;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float top = 0.9;\n    float bottom = 0.1;\n    float left = 0.1;\n    float right = iResolution.x/iResolution.y + 0.2;\n    \n    \n    vec2 pointA = vec2(0.7,0.5);//vec2(left,bottom);\n    vec2 pointB = vec2(right,0.5);//vec2(right,top)/1.5;\n    \n    float lineDist = dLine(uv,pointA,pointB);\n    float currentAngle = solidAngle(uv,pointA,pointB);\n    for(int i = 0; i < 30; i++){\n      float currentSign = (mod(float(i), 2.0)*2.0)-1.0;\n      \n      float rotationAmount = currentAngle * 5.0 + lineDist * -5.0 + iTime;\n      float stepMultiplier = currentAngle * lineDist * -6.0;\n      //stepMultiplier = 0.3;\n      \n      vec2 newPointA = midPoint(pointA,pointB);\n      vec2 newPointB = newPointA + (pointB-pointA) * stepMultiplier * r2D(rotationAmount);\n      pointA = newPointA;\n      pointB = newPointB;\n      \n      currentAngle = smin(currentAngle, solidAngle(uv,pointA,pointB),0.3);\n      lineDist = smin(dLine(uv,pointA,pointB), lineDist,0.9);\n       \n    }\n\n    vec3 col = HSVtoRGB(vec3((abs(currentAngle)),1.0-abs(lineDist)*3.0,1.0-(abs(lineDist)*2.0)));\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}