{"ver":"0.1","info":{"id":"ml33R8","date":"1681915098","viewed":76,"name":"MORE BALLS","username":"testaccountplsignore","description":"no doubt the bestest highest effort shader you have ever seen","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sphere","diffuselighting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define smod(x) .5*sin(x)+.5\n\nmat2 rot(float a){\n    float s=sin(a),c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\n//https://iquilezles.org/articles/smin/\nfloat smin( float a, float b, float k )\n{\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\n//https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\nfloat sd(vec3 p, out vec3 ocol){\n    vec3 px = p;\n    px.x -= 2.*iTime;\n    \n    vec3 col1 = vec3(smod(iTime+px.x),smod(2.1+iTime+px.y),smod(4.2+iTime+px.z))*(.5*sin(rand(iTime*.0005))+1.5);\n    vec3 col2 = vec3(1);\n    \n    px.x *= .1*sin(9.*iTime+px.y*px.z)+1.;\n    px.y *= .1*cos(9.*iTime+px.x*px.z)+1.;\n    px.x += 2.*iTime;\n    float d1 = distance(px,vec3(2.+iTime*2.,2.,5.7))-1.2;\n    \n    px = mod(abs(p),vec3(4.));\n    vec4 s = vec4(2.,2.,2.,1.5+sin(iTime*15.)*.025);\n    float d2 = 1.-(distance(px,s.xyz)-s.w);\n    \n    ocol=col1;\n    if(d1>d2){\n        float mx = 1./(d1*d1);\n        ocol= (1.-mx)*col2 + col1*mx;\n    }\n    \n    \n    return smin(d1,d2,2.5);\n}\n\nfloat diffuse(vec3 p){\n    vec3 ocol,l1 = vec3(iTime*2.-2.,10.,6.);\n    vec2 e = vec2(.0,.01);\n    vec3 nv = normalize(sd(p,ocol)-vec3(sd(p-e.yxx,ocol),sd(p-e.xyx,ocol),sd(p-e.xxy,ocol)));\n    vec3 lv = normalize(l1-p);\n    return clamp(dot(lv,nv),0.,1.);\n}\n\nfloat raymarch(vec3 ro, vec3 rd, out vec3 cp, out vec3 ocol){\n    vec3 oc;\n    float s,td = 0.;\n    vec3 c = ro;\n    for(int i=0;i<128;i++){\n        s=sd(c,oc);\n        if(abs(s)<.002 || td>64.)break;\n        td+=s;\n        c+=rd*s;\n    }\n    ocol = oc*clamp((5./td),.1,1.);\n    cp = c;\n    return td;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.*fragCoord/iResolution.x - vec2(1.,iResolution.y/iResolution.x);\n    vec3 ro = vec3(2.,2.,1.5);\n    ro.x += iTime*2.;\n    vec3 rd = normalize(vec3(uv,.5));\n    \n    rd.xy*=rot(iTime*.25);\n    \n    vec3 cp,ocol;\n    float td = raymarch(ro,rd,cp,ocol);\n\n    vec3 col = vec3(0);\n    if(td<63.)col=ocol*clamp(diffuse(cp)+.3,0.,1.);\n  \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}