{"ver":"0.1","info":{"id":"4ccyW4","date":"1730616783","viewed":80,"name":"10. Torus with irridescence","username":"scozz","description":"iridescence","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["tunnel","torus","cubemap","iridescence"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_STEPS = 100;\nconst float MAX_DIST = 20.0;\nconst float SURF_DIST = 0.001;\nvec3 light_dir = normalize(vec3(1.0, -1.0, -1.0));\nvec3 light2_dir =  normalize(vec3(-0.5, -1.0, 1.0));\nvec3 light_color = vec3(1.2, 0.4, 0.7);  // Warm light (slight orange)\nvec3 light2_color = vec3(1.0, 0.8, 0.7);  // Cool light (slight blue)\nconst float IRIDESCENCE_STRENGTH = 0.80;\nconst float IRIDESCENCE_FREQ = 1.50;\n//const vec3 IRIDESCENCE_BASE = vec3(0.8, 0.5, 0.9); // Base color tint for iridescence\nconst vec3 IRIDESCENCE_BASE = vec3(0.9, 0.9, 1.0);\nconst float REFLECTION_STRENGTH = 1.0;\n\n\n//draw a torus\nfloat torus_radius = 1.90;\n\n\nconst float GRAIN_INTENSITY = 0.0041;\n\nconst float DISPERSION_STRENGTH = 0.95;\nconst float RAINBOW_FREQ = 0.5;\n\nvec3 getIridescence(float cosAngle, vec3 normal, vec3 pos) {\n    // Create shifting colors based on angle, position and time\n    float phase = cosAngle * IRIDESCENCE_FREQ + \n                  dot(normal, pos) * 0.5 +\n                  iTime * 0.5;\n    \n    // Create interference pattern\n    vec3 interference;\n    interference.r = cos(phase + 0.0) * 0.5 + 0.5;\n    interference.g = cos(phase + 2.0) * 0.5 + 0.5;\n    interference.b = cos(phase + 4.0) * 0.5 + 0.5;\n    \n    // Add some variation based on position\n    float pattern = sin(pos.x * 2.0 + pos.y * 2.0 + pos.z * 2.0 + iTime) * 0.5 + 0.5;\n    \n    return interference * IRIDESCENCE_BASE * pattern;\n}\n\n// Glow effect based on SDF\nfloat glow(float d, float intensity, float falloff) {\n    return intensity / pow(max(d, 0.001), falloff);\n}\n\n// Domain repetition\nvec3 opRep(vec3 p, vec3 c) {\n    return mod(p + 0.5 * c, c) - 0.5 * c;\n}\n\n\nfloat sdCyl(vec3 p, float radius, float ringFrequency, float ringAmplitude) {\n    float d = -(length(p.xy) - radius);\n    float rings = sin(p.z * ringFrequency) * ringAmplitude;\n    return d - rings;\n    //return d;\n}\nfloat random(vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\nvec3 wavelengthToRGB(float w) {\n    // Approximate visible spectrum (380-750nm)\n    vec3 col = vec3(0.0);\n    \n    // Red component\n    col.r = smoothstep(0.0, 0.2, w) - smoothstep(0.8, 1.0, w);\n    // Green component\n    col.g = smoothstep(0.2, 0.4, w) - smoothstep(0.6, 0.8, w);\n    // Blue component\n    col.b = smoothstep(0.4, 0.6, w) - smoothstep(0.8, 1.0, w);\n    \n    return col;\n}\n\n\n//p is the position of the inverted torus.\n//t.x: This is the major radius of the torus. It's the distance from the center of the torus to the center of the tube.\n//t.y: This is the minor radius of the torus. It's the radius of the tube itself.\nfloat sdTorus( vec3 p, vec2 t )\n{\n      //float speed = sin(iTime*0.051) * 1.0 + 1.0;\n      float speed = 8.0;\n      float ringFrequency = sin(iTime) * 10.4 + 10.4;\n\n     // float ringAmplitude = 0.0 + sin(p.z + (iTime * 1.0)) * 0.03 + 0.0;\n      float ringAmplitude = smoothstep(0.0, 1.0,sin(p.x + iTime)) * 0.03 + 0.01;\n      \n      vec2 q = vec2(length(p.zy)-t.x,p.x);\n      // return -(length(q)-t.y);\n      //apply ring change\n      float rings = sin(iTime * speed + (p.z * ringFrequency)) * ringAmplitude;\n      float torus = -(length(q)-t.y) - rings;\n      float roughness = smoothstep(0.0, 1.0, sin(iTime* 0.50)) * random(p.xy) * 0.00051;\n      return torus - roughness;\n      \n}\n\n\n//only works for 2d\nmat2 rotate2d(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\nfloat scene_sdf(vec3 p)\n{\n    // Calculate rotation angle based on time\n    float angle = iTime * 0.5; // Adjust rotation speed here\n    // Translate the point to the torus center and rotate\n    vec3 translated = vec3( vec2(rotate2d(angle) * p.xy) , p.z); \n\n    // Translate back\n    translated += vec3(0.0, -torus_radius, 0.0);\n    float tubeRadius =  0.2;\n    // Calculate the SDF for the rotated torus\n    return sdTorus(translated, vec2(torus_radius, tubeRadius));\n}\n\n\nvec3 sampleCubemap(vec3 dir) {\n    float rotX = iTime * 0.2; // or (iMouse.x / iResolution.x) * 2.0 * 3.14;\n    float rotY = iTime * 0.1; // or (iMouse.y / iResolution.y) * 3.14;\n    \n    //camera orientation\n    vec3 camO = vec3(cos(rotX), cos(rotY), sin(rotX));\n    vec3 camD = normalize(-camO);\n    vec3 camR = normalize(cross(camD, vec3(0, 1, 0)));\n    vec3 camU = cross(camR, camD);\n    \n    // Transform reflection direction\n    vec3 transformed = normalize(\n        dir.x * camR +\n        dir.y * camU +\n        dir.z * camD\n    );\n    \n    return texture(iChannel0, transformed).xyz;\n}\n\n\n\nfloat ray_march(vec3 ro, vec3 rd)\n{\n    float d0 = 0.0;\n    \n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + rd * d0;\n        float ds = scene_sdf(p);\n        d0 += ds;\n        if(abs(ds) < SURF_DIST || d0 > MAX_DIST) {\n            break;\n        }\n    }\n    \n    return d0;\n}\n\nvec3 get_normal(vec3 p)\n{\n    vec2 e = vec2(0.001, 0);\n    return normalize(vec3(\n        scene_sdf(p + e.xyy) - scene_sdf(p - e.xyy),\n        scene_sdf(p + e.yxy) - scene_sdf(p - e.yxy),\n        scene_sdf(p + e.yyx) - scene_sdf(p - e.yyx)\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //torus_radius += sin(iTime)*0.50 + 1.0;\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    \n    vec3 ro = vec3(0.0, 0.0, 0.0); //ray origin\n    vec3 rd = normalize(vec3(uv, 1.0)); //ray direction.\n    //Note that the middle ray is straight, all the others are at a slight angle. this is the rays originating from the 2d projection.\n    \n    //the distance the ray travelled before hitting an object\n    float d = ray_march(ro, rd);\n    \n\n      vec3 col = vec3(0.1);\n    \n    if(d < MAX_DIST)\n    {\n        vec3 p = ro + rd * d;\n        vec3 n = get_normal(p);\n        \n        float ringr = smoothstep(0.40, 0.0, (sin(iTime) * 0.2 +0.5) * p.z);\n        float ringg = smoothstep(0.5, 1.0, (sin(iTime * 0.2) * 0.4 + 5.1) * p.z);\n        float ringb = smoothstep(0.5, 1.0, 2.0*p.z) * 0.4 + 0.6;\n        vec3 base_color = vec3(ringr, ringg, ringb);\n\n        float diff = max(dot(n, light_dir), 0.1);\n        float diff2 = max(dot(n, light2_dir), 0.1);\n\n        vec3 light_contribution = light_color * diff;\n        vec3 light2_contribution = light2_color * diff2;\n        \n        // prismatic dispersion\n        float view_angle = acos(dot(rd, n));\n        float dispersion = sin(view_angle * RAINBOW_FREQ + iTime*1.5) * DISPERSION_STRENGTH;\n        \n        // iridescence\n        float cosAngle = abs(dot(rd, n));\n        vec3 iridescence = getIridescence(cosAngle, n, p);\n\n        \n        // Create rainbow effect based on viewing angle and distance\n        vec3 rainbow = wavelengthToRGB(fract(view_angle * 0.3 + dispersion));\n        \n        vec3 reflected = reflect(rd, n);\n        vec3 env = sampleCubemap(reflected);\n        \n        // Add fresnel-like effect\n        float fresnel = pow(1.0 - cosAngle, 5.0);\n        \n        // Combine colors with rainbow reflection\n        col = base_color * (light_contribution + light2_contribution);\n        vec3 reflection_color = mix(env,  iridescence, IRIDESCENCE_STRENGTH);\n        col = mix(col, reflection_color, 0.2 + (0.5 * fresnel) * REFLECTION_STRENGTH);\n    \n\n        \n        //specular highlights\n        //float spec = pow(max(dot(reflect(-light_dir, n), rd), 0.0), 32.0);\n        //col += spec * light_color * 0.5;\n\n        vec3 ambient = vec3(0.01);\n        col += ambient;\n        \n        // Glow effect based on SDF\n        //float glow(float d, float intensity, float falloff)\n\n        // Domain repetition\n        //vec3 opRep(vec3 p, vec3 c)\n        \n        \n        \n    } else {\n        col = vec3(0.0,0.0,1.0);\n    }\n        \n         // Add purple fog\n        vec3 fog_color = vec3(0.6, 0.0, 0.9); // Purple color\n        float fog_density = 0.15; // Adjust this to control fog thickness\n        float fog_factor = 1.0 - exp(-d * fog_density);\n\n        // Add some movement to the fog\n        //fog_factor += sin(iTime * 0.5 + length(uv)) * 0.1;\n\n        // Ensure fog_factor stays between 0 and 1\n        fog_factor = clamp(fog_factor, 0.0, 1.0);\n\n        // Mix between scene color and fog color\n        col = mix(col, fog_color, fog_factor);\n        \n        // Add film grain\n       //float grain = random(uv + iTime) * GRAIN_INTENSITY;\n\n        // Add subtle grain variation based on luminance\n        //float luma = dot(col, vec3(0.299, 0.587, 0.114));\n        //grain *= (1.0 - luma) * 2.0;\n\n        // Add temporal variation to grain\n        //grain *= (sin(iTime * 1.0) * 0.5 + 1.5);\n\n        // Apply grain\n        //col += vec3(grain);\n\n\n        fragColor = vec4(col, 1.0);\n\n}","name":"Image","description":"","type":"image"}]}