{"ver":"0.1","info":{"id":"ddGfzh","date":"1697910298","viewed":49,"name":"YCC vs OKLab color key","username":"MV10","description":"A comparison of green screen identification with the widely used YCC method (left) vs OKLab perceptual similarity (right). OKLab is highly sensitive to the tolerance setting and doesn't fare nearly as well as I expected.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["chromakey","ycbcr","ycc","oklab","colorkey"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// See comments here for credits and info:\n// https://www.shadertoy.com/view/DddBRj\n\n/////////////////////////////////////////////////////////////////////\n\n// Chroma-key begins\n\nvec3 YCbCr (vec3 rgb) {\n\treturn vec3(\n        dot(rgb, vec3(.299, .587, .114)), // y\n        .5 + dot(rgb, vec3(-.169, -.331, .5)), // Cb\n\t\t.5 + dot(rgb, vec3(.5, -.419, -.081)) // Cr\n    );\n}\n\nvec4 CK (vec3 f, vec3 b, vec3 k) {\n    vec3 v = YCbCr(f);\n    float l = length((v - YCbCr(k)).gb);\n    float m = 1. - smoothstep(.075, .225, l);\n    vec3 s = (1. - m) * vec3(v.r);\n    return vec4(mix(s, f - m * k, smoothstep(.125, .275, l)) + m * b, 1.);\n}\n\n// Chroma-key ends\n\n/////////////////////////////////////////////////////////////////////\n\n// OKLab begins\n\nfloat halley_cube_root(float x)\n{\n    float y = sign(x) * uintBitsToFloat(floatBitsToUint(abs(x)) / 3u + 0x2a514067u);\n    for( int i = 0; i < 4; ++i )\n    {\n        float y3 = y * y * y;\n        y *= ( y3 + 2. * x ) / ( 2. * y3 + x );\n    }\n    return y;\n}\n\nvec3 rgb2oklab(vec3 c)\n{\n    float l = 0.4122214708 * c.r + 0.5363325363 * c.g + 0.0514459929 * c.b;\n\tfloat a = 0.2119034982 * c.r + 0.6806995451 * c.g + 0.1073969566 * c.b;\n\tfloat b = 0.0883024619 * c.r + 0.2817188376 * c.g + 0.6299787005 * c.b;\n\n    float lr = halley_cube_root(l);  // pow(l, 1.0 / 3.0)\n    float ar = halley_cube_root(a);  // pow(a, 1.0 / 3.0)\n    float br = halley_cube_root(b);  // pow(b, 1.0 / 3.0)\n\n    return vec3 (\n        0.2104542553 * lr + 0.7936177850 * ar - 0.0040720468 * br,\n        1.9779984951 * lr - 2.4285922050 * ar + 0.4505937099 * br,\n        0.0259040371 * lr + 0.7827717662 * ar - 0.8086757660 * br);\n}\n\nfloat color_difference(vec3 rgb1, vec3 rgb2)\n{\n    vec3 oklab1 = rgb2oklab(rgb1);\n    vec3 oklab2 = rgb2oklab(rgb2);\n    return distance(oklab1, oklab2);\n}\n\n// OKLab ends\n\n/////////////////////////////////////////////////////////////////////\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = vec4(0);\n\n    // Britney ain't fat, y'all...\n    vec2 vres = iChannelResolution[0].xy;\n    float aspect = vres.y / vres.x;\n    float scale = (iResolution.x / 2.0) / vres.x;\n    float ymax = scale * vres.y;\n    \n    vec3 key = vec3(.176, .627, .176);\n    vec3 white = vec3(1.0);\n    float oklab_tolerance = 0.105;\n    \n    if(fragCoord.y <= ymax)\n    {\n        float y = fragCoord.y / ymax;\n        \n        // YCC on the left\n        if(uv.x < 0.5)\n        {\n            float x = uv.x * 2.0;\n            vec3 pixel = texture(iChannel0, vec2(x, y)).rgb;\n            fragColor = CK(pixel, white, key);\n        }\n        // OKLab on the right\n        else\n        {\n            float x = (uv.x - 0.5) * 2.0;\n            vec3 pixel = texture(iChannel0, vec2(x, y)).rgb;\n            float diff = color_difference(key, pixel);\n            vec3 result = (diff - oklab_tolerance <= 0.0) ? vec3(1.0) : pixel;\n            fragColor = vec4(result, 1.0);\n        }\n    }\n}","name":"Image","description":"","type":"image"}]}