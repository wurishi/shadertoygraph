{"ver":"0.1","info":{"id":"3tVfWW","date":"1614338467","viewed":101,"name":"Playstation tunnel","username":"GreenChicken","description":"in fact, i'm team Nintendo","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","ati"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// thanks iq, flopine, gaziya for functions, help\n\n#define Rep(p,c) mod(p+0.5*c,c)-0.5*c;\n#define t iTime\n#define tc fract(t*.5)\n#define td fract(t)\n#define rot(a) mat2(cos(a), sin(a), -sin(a), cos(a) )\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdSphere(vec3 p, float s)\n{\n  return length(p)-s;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r)\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n\nfloat sdInCyl(vec3 p, float h, float r, float ih)\n{\n  p.yz *= rot(radians(90.));\n  float c1 = sdCappedCylinder(p,h,r);\n  float c2 = sdCappedCylinder(p,ih,r+0.1);\n  return max(-c2, c1);\n}\n\nfloat map(vec3 p)\n{\n  vec3 pc = Rep(p, vec3(0.0, 0.0, 2.0)); \n  pc.x -= sin((p.y)*10.+t*10.)*.1;\n  pc.y -= sin((p.x)*10.+t*10.)*.1;\n  p = Rep(p, vec3(5.0, 5.0, 5.0)); \n  \n  float m = -1.;\n  m = max(-sdBox(p, vec3(1.0, 1.0, 5.0)), m);\n  vec2 e = vec2(1.0, 0.0);\n  float s = 2.;\n  m = max(-sdSphere(p+e.xyy, s), m);\n  m = max(-sdSphere(p+e.yxy, s), m);\n  m = max(-sdSphere(p-e.xyy, s), m);\n  m = max(-sdSphere(p-e.yxy, s), m);\n  \n  m = min(m, sdInCyl(pc, 1., .1, .9));\n  \n  return m;\n}\n\nfloat tri(vec2 uv, float s, float h)\n{\n  vec2 st = abs(uv);\n  st.x *= 1.5;\n  return step(st.x+uv.y, s)*step(1.0-uv.y, h+0.5);\n}\n\nfloat sCross(vec2 uv, float r, float d)\n{\n  vec2 st = abs(uv);\n  return clamp(max(step(abs(uv.x), r), step(abs(uv.y), r)) - step(1.0-st.x, d) - step(1.0-st.y, d), 0.0, 1.0);\n}\n\nfloat mCross(vec2 uv, float r, float d)\n{\n  vec2 st = uv;\n  st *= rot(radians(45.));\n  return sCross(st,r,d);\n}\n\nfloat squareDuCul(vec2 uv, float s, float s2)\n{\n    return step(abs(uv.x), s)*step(abs(uv.y), s) - \n            step(abs(uv.x), s2)*step(abs(uv.y), s2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = 2.0 * fragCoord/iResolution.xy - 1.0;\n  uv.x *= iResolution.x/iResolution.y;\n  \n  float mask = squareDuCul(uv, .8, .6);\n  float mask2 = 1.0 - step(0.1, abs(length(uv)-.8));\n  float mask3 = clamp(tri(uv, .8, 1.1) - tri(uv, .5, .9), 0.0, 1.0);\n  float mask4 = mCross(uv, .3, .1);\n  \n  vec3 rd = normalize(vec3(uv+(texture(iChannel0, uv).rg*0.25*length(uv)), 1.0));\n  rd.xy *= rot(sin(t));\n  \n  vec3 p = vec3(0.0, 0.0, t*5.);\n  \n  p.y += sin(t*5.)*.5;\n  \n  // thanks gaziya\n  float d=1.,i;\n  for(;++i<99.&&d>.001;) p += rd * (d=map(p));\n  \n  float f;\n  if(d<.001) f += 10./i;\n  \n   \n  vec3 col = mix(vec3(td, 0., 0.), vec3(0.0, td, td), f);\n  vec3 blue = mix(vec3(0.0, 0., 1.0), vec3(0.0, 0., 0.), f);\n  vec3 black = mix(vec3(0.0), vec3(.1), f);\n  vec3 green = mix(vec3(0.0, 1., 0.), vec3(.0, 0., 0.), f);\n  vec3 red = mix(vec3(1.0, 0., 0.), vec3(.0, 0., 0.), f);\n  \n  if(tc < .25)\n  {\n    col = mix(col, blue, mask);\n  }\n  else if(tc < .5)\n  {\n    col = mix(col, black, mask2);\n  }\n  else if(tc < .75)\n  {\n    col = mix(col, red, mask4);\n  }\n  else if(tc < 1.0)\n  {\n    col = mix(col, green, mask3);\n  }\n  \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}