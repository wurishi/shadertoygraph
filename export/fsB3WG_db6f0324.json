{"ver":"0.1","info":{"id":"fsB3WG","date":"1617851119","viewed":88,"name":"fractal sky stuff","username":"okelly4408","description":"I took this sky shader: https://www.shadertoy.com/view/tdSXzD\nand added some fractals (based on ones created by Kali, not sure though) \nIt's not done but I wanted to get something down. Use mouse to move sun. Watch for a little while for full effect. ","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["fractal","sky"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//original scattering code comes from https://www.shadertoy.com/view/tdSXzD\n\n#define ORIG_CLOUD 0\n#define ENABLE_RAIN 0 //enable rain drops on screen\n#define SIMPLE_SUN 0\n#define NICE_HACK_SUN 1\n#define SOFT_SUN 1\n#define cloudy  0.5 //0.0 clear sky\n#define haze  0.01 * (cloudy*20.)\n#define rainmulti 5.0 // makes clouds thicker\n#define rainy (10.0 -rainmulti)\n#define t iTime\n#define fov tan(radians(60.0))\n#define S(x, y, z) smoothstep(x, y, z)\n#define cameraheight 5e1 //50.\n#define mincloudheight 5e3 //5e3\n#define maxcloudheight 8e3 //8e3\n#define xaxiscloud t*5e2 //t*5e2 +t left -t right *speed\n#define yaxiscloud 0. //0.\n#define zaxiscloud t*6e2 //t*6e2 +t away from horizon -t towards horizon *speed\n#define cloudnoise 2e-4 //2e-4\n\n//#define cloud2\n\n\n//Performance\nconst int steps = 16; //16 is fast, 128 or 256 is extreme high\nconst int stepss = 16; //16 is fast, 16 or 32 is high \n\n//Environment\nconst float R0 = 6360e3; //planet radius //6360e3 actual 6371km\nconst float Ra = 6380e3; //atmosphere radius //6380e3 troposphere 8 to 14.5km\nconst float I = 10.; //sun light power, 10.0 is normal\nconst float SI = 5.; //sun intensity for sun\nconst float g = 0.45; //light concentration .76 //.45 //.6  .45 is normaL\nconst float g2 = g * g;\n\nconst float ts= (cameraheight / 2.5e5);\n\nconst float s = 0.999; //light concentration for sun\n#if SOFT_SUN\nconst float s2 = s;\n#else\nconst float s2 = s * s;\n#endif\nconst float Hr = 8e3; //Rayleigh scattering top //8e3\nconst float Hm = 1.2e3; //Mie scattering top //1.3e3\n\nvec3 bM = vec3(21e-6); //normal mie // vec3(21e-6)\n//vec3 bM = vec3(50e-6); //high mie\n\n//Rayleigh scattering (sky color, atmospheric up to 8km)\nvec3 bR = vec3(5.8e-6, 13.5e-6, 33.1e-6); //normal earth\n//vec3 bR = vec3(5.8e-6, 33.1e-6, 13.5e-6); //purple\n//vec3 bR = vec3( 63.5e-6, 13.1e-6, 50.8e-6 ); //green\n//vec3 bR = vec3( 13.5e-6, 23.1e-6, 115.8e-6 ); //yellow\n//vec3 bR = vec3( 5.5e-6, 15.1e-6, 355.8e-6 ); //yeellow\n//vec3 bR = vec3(3.5e-6, 333.1e-6, 235.8e-6 ); //red-purple\n\nvec3 C = vec3(0., -R0, 0.); //planet center\nvec3 Ds = normalize(vec3(0., 0., -1.)); //sun direction?\n\nfloat cloudyhigh = 0.05; //if cloud2 defined\n\n#if ORIG_CLOUD\nfloat cloudnear = 1.0; //9e3 12e3  //do not render too close clouds on the zenith\nfloat cloudfar = 1e3; //15e3 17e3\n#else\nfloat cloudnear = 1.0; //15e3 17e3\nfloat cloudfar = 70e3; //160e3  //do not render too close clouds on the horizon 160km should be max for cumulus\n#endif\n\n\n\n\n//AURORA STUFF\nmat2 mm2(in float a){\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\nmat2 m2 = mat2(0.95534, 0.29552, -0.29552, 0.95534);\n\nfloat tri(in float x){\n    return clamp(abs(fract(x)-.5),0.01,0.49);\n}\n\nvec2 tri2(in vec2 p){\n    return vec2(tri(p.x)+tri(p.y),tri(p.y+tri(p.x)));\n}\n\nfloat triNoise2d(in vec2 p, float spd)\n{\n    float z=1.8;\n    float z2=2.5;\n\tfloat rz = 0.;\n    p *= mm2(p.x*0.06);\n    vec2 bp = p;\n\tfor (float i=0.; i<5.; i++ )\n\t{\n        vec2 dg = tri2(bp*1.85)*.75;\n        dg *= mm2(t*spd);\n        p -= dg/z2;\n\n        bp *= 1.3;\n        z2 *= 1.45;\n        z *= .42;\n\t\tp *= 1.21 + (rz-1.0)*.02;\n        \n        rz += tri(p.x+tri(p.y))*z;\n        p*= -m2;\n\t}\n    return clamp(1./pow(rz*29., 1.3),0.,.55);\n}\n\n\nfloat hash21(in vec2 n){ return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453); }\nvec4 aurora(vec3 ro, vec3 rd)\n{\n    vec4 col = vec4(0);\n    vec4 avgCol = vec4(0);\n    ro *= 1e-5;\n    float mt = 10.;\n    for(float i=0.;i<5.;i++)\n    {\n        float of = 0.006*hash21(gl_FragCoord.xy)*smoothstep(0.,15., i*mt);\n        float pt = ((.8+pow((i*mt),1.2)*.001)-rd.y)/(rd.y*2.+0.4);\n        pt -= of;\n    \tvec3 bpos = (ro) + pt*rd;\n        vec2 p = bpos.zx;\n        //vec2 p = rd.zx;\n        float rzt = triNoise2d(p, 0.1);\n        vec4 col2 = vec4(0,0,0, rzt);\n        col2.rgb = (sin(1.-vec3(2.15,-.5, 1.2)+(i*mt)*0.053)*(0.5*mt))*rzt;\n        avgCol =  mix(avgCol, col2, .5);\n        col += avgCol*exp2((-i*mt)*0.04 - 2.5)*smoothstep(0.,5., i*mt);\n\n    }\n\n    col *= (clamp(rd.y*15.+.4,0.,1.2));\n    return col*2.8;\n}\n\n//END AURORA STUFF\n\nfloat noise(in vec2 v) { \n    return textureLod(iChannel0, (v+.5)/256., 0.).r; \n}\n\n// by iq\nfloat Noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel0, (uv+ 0.5)/256.0, -100.0).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n\nfloat fnoise( vec3 p, in float t )\n{\n\tp *= .25;\n    float f;\n\n\tf = 0.5000 * Noise(p); p = p * 3.02; p.y -= t*.1; //t*.05 speed cloud changes\n\tf += 0.2500 * Noise(p); p = p * 3.03; p.y += t*.06;\n\tf += 0.1250 * Noise(p); p = p * 3.01;\n\tf += 0.0625   * Noise(p); p =  p * 3.03;\n\tf += 0.03125  * Noise(p); p =  p * 3.02;\n\tf += 0.015625 * Noise(p);\n    return f;\n}\n\nfloat cloud(vec3 p, in float t ) {\n\tfloat cld = fnoise(p*cloudnoise,t) + cloudy*0.1 ;\n\tcld = smoothstep(.4+.04, .6+.04, cld);\n\tcld *= cld * (5.0*rainmulti);\n\treturn cld+haze;\n}\n\nvoid densities(in vec3 pos, out float rayleigh, out float mie) {\n\tfloat h = length(pos - C) - R0;\n\trayleigh =  exp(-h/Hr);\n\tvec3 d = pos;\n    d.y = 0.0;\n    float dist = length(d);\n    \n\tfloat cld = 0.;\n\tif (mincloudheight < h && h < maxcloudheight) {\n\t\t//cld = cloud(pos+vec3(t*1e3,0., t*1e3),t)*cloudy;\n        cld = cloud(pos+vec3(xaxiscloud,yaxiscloud, zaxiscloud),t)*cloudy; //direction and speed the cloud movers\n\t\tcld *= sin(3.1415*(h-mincloudheight)/mincloudheight) * cloudy;\n\t}\n\t#ifdef cloud2\n        float cld2 = 0.;\n        if (12e3 < h && h < 15.5e3) {\n            cld2 = fnoise(pos*3e-4,t)*cloud(pos*32.0+vec3(27612.3, 0.,-t*15e3), t);\n            cld2 *= sin(3.1413*(h-12e3)/12e3) * cloudyhigh;\n            cld2 = clamp(cld2,0.0,1.0);\n        }\n    \n    #endif\n\n    #if ORIG_CLOUD\n    if (dist<cloudfar) {\n        float factor = clamp(1.0-((cloudfar - dist)/(cloudfar-cloudnear)),0.0,1.0);\n        cld *= factor;\n    }\n    #else\n\n    if (dist>cloudfar) {\n\n        float factor = clamp(1.0-((dist - cloudfar)/(cloudfar-cloudnear)),0.0,1.0);\n        cld *= factor;\n    }\n    #endif\n\n\tmie = exp(-h/Hm) + cld + haze;\n\t#ifdef cloud2\n\t\tmie += cld2;\n\t#endif\n    \n}\n\n\n\nfloat escape(in vec3 p, in vec3 d, in float R) {\n\tvec3 v = p - C;\n\tfloat b = dot(v, d);\n\tfloat c = dot(v, v) - R*R;\n\tfloat det2 = b * b - c;\n\tif (det2 < 0.) return -1.;\n\tfloat det = sqrt(det2);\n\tfloat t1 = -b - det, t2 = -b + det;\n\treturn (t1 >= 0.) ? t1 : t2;\n}\n\nfloat field(in vec3 p,float s) {\n\tfloat strength = 7. + .03 * log(1.e-6 + fract(sin(16.3141) * 4373.11));\n\tfloat accum = s/4.;\n\tfloat prev = 0.;\n\tfloat tw = 0.;\n\tfor (int i = 0; i < 26; ++i) {\n\t\tfloat mag = dot(p, p);\n\t\tp = abs(p) / mag + vec3(-.5, -.4, -1.5);\n\t\tfloat w = exp(-float(i) / 7.);\n\t\taccum += w * exp(-strength * pow(abs(mag - prev), 2.2));\n\t\ttw += w;\n\t\tprev = mag;\n\t}\n\treturn max(0., 5. * accum / tw - .7);\n}\n\n// fewer iterations for second layer\nfloat field2(in vec3 p, float s) {\n\tfloat strength = 7. + .03 * log(1.e-6 + fract(sin(16.3141) * 4373.11));\n\tfloat accum = s/4.;\n\tfloat prev = 0.;\n\tfloat tw = 0.;\n\tfor (int i = 0; i < 18; ++i) {\n\t\tfloat mag = dot(p, p);\n\t\tp = abs(p) / mag + vec3(-.5, -.4, -1.5);\n\t\tfloat w = exp(-float(i) / 7.);\n\t\taccum += w * exp(-strength * pow(abs(mag - prev), 2.2));\n\t\ttw += w;\n\t\tprev = mag;\n\t}\n\treturn max(0., 5. * accum / tw - .7);\n}\n\nvec3 nrand3( vec2 co )\n{\n\tvec3 a = fract( cos( co.x*8.3e-3 + co.y )*vec3(1.3e5, 4.7e5, 2.9e5) );\n\tvec3 b = fract( sin( co.x*0.3e-3 + co.y )*vec3(8.1e5, 1.0e5, 0.1e5) );\n\tvec3 c = mix(a, b, 0.5);\n\treturn c;\n}\n\nvec3 HDR(vec3 L) {\n    L = L * 0.4;\n    L.r = L.r < 1.413 ? pow(L.r * 0.38317, 1.0 / 2.2) : 1.0 - exp(-L.r);\n    L.g = L.g < 1.413 ? pow(L.g * 0.38317, 1.0 / 2.2) : 1.0 - exp(-L.g);\n    L.b = L.b < 1.413 ? pow(L.b * 0.38317, 1.0 / 2.2) : 1.0 - exp(-L.b);\n    return L;\n}\n\n// this can be explained: http://www.scratchapixel.com/lessons/3d-advanced-lessons/simulating-the-colors-of-the-sky/atmospheric-scattering/\nvoid scatter(vec3 o, vec3 d, out vec3 col, out vec3 scat, in float t) {\n    \n\tfloat L = escape(o, d, Ra);\t\n\tfloat mu = dot(d, Ds);\n\tfloat opmu2 = 1. + mu*mu;\n\tfloat phaseR = .0596831 * opmu2;\n\tfloat phaseM = .1193662 * (1. - g2) * opmu2 / ((2. + g2) * pow(1. + g2 - 2.*g*mu, 1.5));\n    float phaseS = .1193662 * (1. - s2) * opmu2 / ((2. + s2) * pow(1. + s2 - 2.*s*mu, 1.5));\n\t\n\tfloat depthR = 0., depthM = 0.;\n\tvec3 R = vec3(0.), M = vec3(0.);\n\t\n\tfloat dl = L / float(steps);\n\tfor (int i = 0; i < steps; ++i) {\n\t\tfloat l = float(i) * dl;\n\t\tvec3 p = (o + d * l);\n\n\t\tfloat dR, dM;\n\t\tdensities(p, dR, dM);\n\t\tdR *= dl; dM *= dl;\n\t\tdepthR += dR;\n\t\tdepthM += dM;\n\n\t\tfloat Ls = escape(p, Ds, Ra);\n\t\tif (Ls > 0.) {\n\t\t\tfloat dls = Ls / float(stepss);\n\t\t\tfloat depthRs = 0., depthMs = 0.;\n\t\t\tfor (int j = 0; j < stepss; ++j) {\n\t\t\t\tfloat ls = float(j) * dls;\n\t\t\t\tvec3 ps = ( p + Ds * ls );\n\t\t\t\tfloat dRs, dMs;\n\t\t\t\tdensities(ps, dRs, dMs);\n\t\t\t\tdepthRs += dRs * dls;\n\t\t\t\tdepthMs += dMs * dls;\n\t\t\t}\n\n\t\t\tvec3 A = exp(-(bR * (depthRs + depthR) + bM * (depthMs + depthM)));\n\t\t\tR += (A * dR);\n\t\t\tM += A * dM ;\n\t\t} else {\n\t\t}\n\t}\n\n\t//col = (I) * (R * bR * phaseR + M * bM * (phaseM ));\n    col = (I) *(M * bM * (phaseM )); // Mie scattering\n    #if NICE_HACK_SUN\n    col += (SI) *(M * bM *phaseS); //Sun\n    #endif\n    col += (I) *(R * bR * phaseR); //Rayleigh scattering\n    \n    //new stuff\n    float tm = t + 4500.0;\n    vec3 v = normalize(d);\n    vec3 fv1 = 1.0 * v;\n\tvec3 fv2 = (fv1 * 1024.0) / 768.0;\n\tvec3 p = vec3(fv2 / 4.) + vec3(1.0, -1.3, -1.0);\n\tp += 0.2 * vec3(sin(tm / 16.0), sin(tm / 12.0), sin(tm / 128.0));\n\tfloat freqs[4];\n\tfreqs[0] = 0.25;\n\tfreqs[1] = 0.167;\n\tfreqs[2] = 0.56563;\n\tfreqs[3] = 0.7156;\n\tfloat fractalt1 = 1.75 * field(p, freqs[2]);\n\tfloat fractalv1 = (1.0 - exp((abs(fv2.x) - 1.0) * 6.0)) * (1.0 - exp((abs(fv2.y) - 1.0) * 6.0)) * (1.0 - exp((abs(fv2.z) - 1.0) * 6.0));\n\tvec3 p2 = vec3(fv2 / (4.+sin(t*0.11)*0.2+0.2+sin(t*0.15)*0.3+0.4)) + vec3(2.0, -1.3, -1.0);\n\tp2 += 0.25 * vec3(sin(tm / 16.), sin(tm / 12.),  sin(tm / 128.));\n\tfloat fractalt2 = field2(p2, freqs[3]);\n\tvec4 c2 = mix(.4, 1., fractalv1) * vec4(1.3 * fractalt2 * fractalt2 * fractalt2 ,1.8  * fractalt2 * fractalt2 , fractalt2* freqs[0], fractalt2);\n\tvec4 fractal_final = mix(freqs[3]-.3, 1., fractalv1) * vec4(1.5*freqs[2] * fractalt1 * fractalt1* fractalt1 , 1.2*freqs[1] * fractalt1 * fractalt1, freqs[3]*fractalt1, 1.0)+c2;\n\t\n\tcol = col + (fractal_final.rgb + 0.2);\n    \n    \n    //end\n    \n    scat = 0.1 *(bM*depthM);\n    //scat = 0.0 + clamp(depthM*5e-7,0.,1.); \n   \n}\n\n\nvec3 hash33(vec3 p)\n{\n    p = fract(p * vec3(443.8975,397.2973, 491.1871));\n    p += dot(p.zxy, p.yxz+19.27);\n    return fract(vec3(p.x * p.y, p.z*p.x, p.y*p.z));\n}\n\nvec3 stars(in vec3 p)\n{\n    vec3 c = vec3(0.);\n    float res = iResolution.x*2.5;\n\n\tfor (float i=0.;i<4.;i++)\n    {\n        vec3 q = fract(p*(.15*res))-0.5;\n        vec3 id = floor(p*(.15*res));\n        vec2 rn = hash33(id).xy;\n        float c2 = 1.-smoothstep(0.,.6,length(q));\n        c2 *= step(rn.x,.0005+i*i*0.001);\n        c += c2*(mix(vec3(1.0,0.49,0.1),vec3(0.75,0.9,1.),rn.y)*0.1+0.9);\n        p *= 1.3;\n    }\n    return c*c*.8;\n}\n\n//SIMPLE SUN STUFF\nconst float PI = 3.14159265358979323846;\nconst float density = 0.5;\nconst float zenithOffset = 0.48;\nconst vec3 skyColor = vec3(0.37, 0.55, 1.0) * (1.0 + 0.0);\n\n#define zenithDensity(x) density / pow(max(x - zenithOffset, 0.0035), 0.75)\n\nfloat getSunPoint(vec2 p, vec2 lp){\nreturn smoothstep(0.04*(fov/2.0), 0.026*(fov/2.0), distance(p, lp)) * 50.0;\n}\n\nfloat getMie(vec2 p, vec2 lp){\n    float mytest = lp.y < 0.5 ? (lp.y+0.5)*pow(0.05,20.0):0.05;\n    float disk = clamp(1.0 - pow(distance(p, lp), mytest), 0.0, 1.0);\n    return disk*disk*(3.0 - 2.0 * disk) * 0.25 * PI;\n}\n\nvec3 getSkyAbsorption(vec3 x, float y){\n    vec3 absorption = x * y;\n    absorption = pow(absorption, 1.0 - (y + absorption) * 0.5) / x / y;\n    return absorption;\n}\n\nvec3 jodieReinhardTonemap(vec3 c){\n    float l = dot(c, vec3(0.2126, 0.7152, 0.0722));\n    vec3 tc = c / (c + 1.0);\n    return mix(c / (l + 1.0), tc, tc);\n}\n\nvec3 getAtmosphericScattering(vec2 p, vec2 lp){\n    float zenithnew = zenithDensity(p.y);\n    float sunPointDistMult =  clamp(length(max(lp.y + 0.1 - zenithOffset, 0.0)), 0.0, 1.0);\n    vec3 absorption = getSkyAbsorption(skyColor, zenithnew);\n    vec3 sunAbsorption = getSkyAbsorption(skyColor, zenithDensity(lp.y + 0.1));\n    vec3 sun3 = getSunPoint(p, lp) * absorption;\n    vec3 mie2 = getMie(p, lp) * sunAbsorption;\n    vec3 totalSky = sun3; //+ mie2;\n    totalSky *= sunAbsorption * 0.5 + 0.5 * length(sunAbsorption);\n    vec3 newSky = jodieReinhardTonemap(totalSky);\n    return newSky;\n}\n//END SIMPLE SUN STUFF\n\n//RAIN STUFF\nvec3 N31(float p) {\n    //  3 out, 1 in... DAVE HOSKINS\n   vec3 p3 = fract(vec3(p) * vec3(.1031,.11369,.13787));\n   p3 += dot(p3, p3.yzx + 19.19);\n   return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nfloat SawTooth(float t) {\n    return cos(t+cos(t))+sin(2.*t)*.2+sin(4.*t)*.02;\n}\n\nfloat DeltaSawTooth(float t) {\n    return 0.4*cos(2.*t)+0.08*cos(4.*t) - (1.-sin(t))*sin(t+cos(t));\n}  \n\nvec2 GetDrops(vec2 uv, float seed, float m) {\n    \n    float t2 = t+m;\n    vec2 o = vec2(0.);\n\n    #ifndef DROP_DEBUG\n    uv.y += t2*.05;\n    #endif\n    \n    uv *= vec2(10., 2.5)*2.;\n    vec2 id = floor(uv);\n    vec3 n = N31(id.x + (id.y+seed)*546.3524);\n    vec2 bd = fract(uv);\n    \n    vec2 uv2 = bd;\n    \n    bd -= 0.5;\n    \n    bd.y*=4.;\n\n    bd.x += (n.x-.5)*rainy;\n    \n    t2 += n.z * 6.28;\n    float slide = SawTooth(t2);\n    \n    float ts = 1.5;\n    vec2 trailPos = vec2(bd.x*ts, (fract(bd.y*ts*2.-t2*2.)-.5)*.5);\n    \n    bd.y += slide*2.;\t\t\t\t\t\t\t\t// make drops slide down\n    \n    #ifdef HIGH_QUALITY\n    float dropShape = bd.x*bd.x;\n    dropShape *= DeltaSawTooth(t);\n    bd.y += dropShape;\t\t\t\t\t\t\t\t// change shape of drop when it is falling\n    #endif\n    \n    float d = length(bd);\t\t\t\t\t\t\t// distance to main drop\n    \n    float trailMask = S(-.2, .2, bd.y);\t\t\t\t// mask out drops that are below the main\n    trailMask *= bd.y;\t\t\t\t\t\t\t\t// fade dropsize\n    float td = length(trailPos*max(.5, trailMask));\t// distance to trail drops\n    \n    float mainDrop = S(.2, .1, d);\n    float dropTrail = S(.1, .02, td);\n    \n    dropTrail *= trailMask;\n    o = mix(bd*mainDrop, trailPos, dropTrail);\t\t// mix main drop and drop trail\n    \n    #ifdef DROP_DEBUG\n    if(uv2.x<.02 || uv2.y<.01) o = vec2(1.);\n    #endif\n    \n    return o;\n}\n//END RAIN STUFF\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tfloat AR = iResolution.x/iResolution.y;\n    float M = 1.0; //canvas.innerWidth/M //canvas.innerHeight/M --res\n    \n    vec2 uvMouse = (iMouse.xy / iResolution.xy);\n    uvMouse.x *= AR;\n    \n   \tvec2 uv0 = (fragCoord.xy / iResolution.xy);\n    uv0 *= M;\n\t//uv0.x *= AR;\n    \n    vec2 uv = uv0 * (2.0*M) - (1.0*M);\n    uv.x *=AR;\n    \n  \n    if (uvMouse.y == 0.) uvMouse.y=(0.7-(0.05*fov)); //initial view \n    if (uvMouse.x == 0.) uvMouse.x=(1.0-(0.05*fov)); //initial view\n    \n\n\tDs = normalize(vec3(uvMouse.x-((0.5*AR)), uvMouse.y-0.5, (fov/-2.0)));\n    \n    \n\tvec3 O = vec3(0., cameraheight, 0.);\n\tvec3 D = normalize(vec3(uv, -(fov*M)));\n\n\tvec3 color = vec3(0.);\n    vec3 scat = vec3(0.);\n\n    //float scat = 0.;\n\tfloat att = 1.;\n    float staratt = 1.;\n    float scatatt = 1.;\n\tvec3 star = vec3(0.);\n    vec4 aur = vec4(0.);\n\n    float fade = smoothstep(0.,0.01,abs(D.y))*0.5+0.9;\n\n\n    \n    staratt = 1. -min(1.0,(uvMouse.y*2.0));\n    scatatt = 1. -min(1.0,(uvMouse.y*2.2));\n\n\tif (D.y < -ts) {\n\t\tfloat L = - O.y / D.y;\n\t\tO = O + D * L;\n        D.y = -D.y;\n\t\tD = normalize(D+vec3(0,.003*sin(t+6.2831*noise(O.xz+vec2(0.,-t*1e3))),0.));\n\t\tatt = .6;\n        star = stars(D);\n        uvMouse.y < 0.5 ? aur = smoothstep(0.0,2.5,aurora(O,D)):aur = aur;\n\t}\n    else{\n     \tfloat L1 =  O.y / D.y;\n\t\tvec3 O1 = O + D * L1;\n\n    \tvec3 D1 = vec3(1.);\n    \tD1 = normalize(D+vec3(1.,0.0009*sin(t+6.2831*noise(O1.xz+vec2(0.,t*0.8))),0.));\n    \tstar = stars(D1);\n        uvMouse.y < 0.5 ? aur = smoothstep(0.,1.5,aurora(O,D))*fade:aur = aur;\n    }\n\n    star *= att;\n    star *= staratt;\n\n    scatter(O, D, color, scat, t);\n    color *= att;\n    scat *=  att;\n    scat *= scatatt;\n\t//draw the badly implemented sun\n    #if SIMPLE_SUN\n    \n    vec2 uv1 = (fragCoord.xy / iResolution.xy);\n    uv1 *=M;\n    uv1.x *=AR;\n    \n    vec3 sun2 = getAtmosphericScattering(uv1, vec2(uvMouse.x,uvMouse.y)) ;\n    color += sun2;\n    #endif\n    \n    color += scat;\n    color += star;\n    //color=color*(1.-(aur.a)*scatatt) + (aur.rgb*scatatt);\n    color += aur.rgb*scatatt;\n\n    \n    \n    #if ENABLE_RAIN\n    vec2 drops = vec2(0.);\n    if (rainmulti > 1.0){\n    drops = GetDrops(uv/2.0, 1., 1.);\n\n    color +=drops.x+drops.y;\n    }\n    #endif\n\n\t//float env = pow( smoothstep(.5, iResolution.x / iResolution.y, length(uv*0.8)), 0.0);\n\tfragColor = vec4(pow(color, vec3(1.0/2.2)), 1.); //gamma correct\n}","name":"Image","description":"","type":"image"}]}