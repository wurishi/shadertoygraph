{"ver":"0.1","info":{"id":"llKfD1","date":"1542489743","viewed":567,"name":"Fast marching","username":"dust","description":"Ray-marching can be optimized with cautious over-stepping and adaptive epsilon values; I've seen both techniques in different places, but never in the same shader. So I wrote this to use them together :).","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","raymarching","text","optimization"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Switch between standard and optimized marching\n//#define BASELINE_MARCHING\n// Note the generally darker shading (indicating fewer steps)\n// when standard marching is disabled\n// See [Common] to change the testing surface\n\n// Project primary ray direction from the camera plane\nvec3 rDir(vec2 pixPos,\n          vec2 viewSizes)\n{\n    vec3 dir = vec3(pixPos - (viewSizes / 2.0),\n                \tviewSizes.y / tan(1.62 / 2.0));\n    return normalize(dir);\n}\n\n// Small mapping function to bundle transforms with SDF evaluations\n#define SDF_SCALE 2.0f\nfloat map(vec3 p)\n{ return sdf(rotate(p, iTime) / SDF_SCALE) * SDF_SCALE; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Generate ray-direction, also cache ray origin\n    vec3 rd = rDir(fragCoord,\n                   iResolution.xy);\n    vec3 ro = vec3(0.0f, 0.0f, -5.0f);\n  \n    // March sphere isosurface\n    float eps = 0.0001f;\n    const float maxDist = 16.0f;\n    float t = map(ro);\n    float dt = 0.0f;\n    vec3 rgb = vec3(0.25f);\n    float stepCtr = 0.0f; // Iteration counter for benchmarking\n    #ifdef BASELINE_MARCHING\n    \twhile (t > eps && t < maxDist)\n    \t{\n        \tvec3 p = ro + rd * t;\n        \tdt = map(p);\n    \t\tif (dt < eps)\n       \t\t{\n            \trgb = vec3(stepCtr * dRGB);\n            \tbreak; \n        \t}\n        \telse\n        \t{ t += dt; }\n        \tstepCtr += 1.0f;\n    \t}\n    #else\n    \t// Techniques used:\n    \t// Over-relaxation sphere tracing (Keinert et al.), \n    \t// http://erleuchtet.org/~cupe/permanent/enhanced_sphere_tracing.pdf\n    \t// Dynamic epsilon (linear eps),\n    \t// https://www.shadertoy.com/view/4tXyDH\n    \t// (thanks ollj!)\n    \tfloat w = 1.2f;\n    \tfloat dw = 1.8f; // Keinert et al. suggest adaptive step scaling in their\n    \t\t\t\t\t // possibilities for future research; the simple version\n    \t\t\t\t\t // here allows rays to accelerate towards intersections\n    \t\t\t\t\t // and sometimes provides slightly better performance \n    \t\t\t\t\t // than leaving [w] fixed at ~1.2 \n    \tfloat prevF = 0.0f; // Previous sphere-tracing radius at each step\n    \tfloat prevDt = 0.0f; // Most recent offset at each step\n    \tbool relaxed = true;\n        while (t > eps && t < maxDist)\n    \t{\n        \tvec3 p = ro + rd * t;\n            float f = map(p);\n        \tdt = f * w;\n            if (prevF + f < prevDt && relaxed) // Reset to fallback position on excessive relaxation\n            {\n            \trelaxed = false;\n                t += prevDt * (1.0f - w);\n                p = ro + rd * t;\n                f = map(p);\n                dt = f * w;\n            }\n    \t\tif (f < eps)\n       \t\t{\n            \trgb = vec3(stepCtr * dRGB);\n            \tbreak; \n        \t}\n        \telse\n        \t{ \n                t += dt;\n                prevF = f;\n                prevDt = dt;\n                if (relaxed) \n\t\t\t\t{ w = mod(fract(w) * dw, 1.0f) + 1.0f; } // Escalate step scaling after each relaxation\n                else\n                { w = 1.2f; } // Otherwise re-set [w]\n                eps *= 1.125f; // Potential for further research here...\n        \t}\n        \tstepCtr += 1.0f;\n    \t}\n    #endif\n    \n    // Output to screen\n    fragColor = vec4(rgb,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Possible test surfaces\n// Surface + gradient functions assume shapes lying at the origin\n//#define SPHER_SDF\n#define JULIA_SDF\n//#define TORUS_SDF\n\n// Conditional undefines (only one surface available at a time)\n#ifdef SPHER_SDF\n\t#ifdef JULIA_SDF\n\t\t#undef JULIA_SDF\n\t#endif\n\t#ifdef TORUS_SDF\n\t\t#undef TORUS_SDF\n\t#endif\n#endif\n#ifdef JULIA_SDF\n\t#ifdef SPHER_SDF\n\t\t#undef SPHER_SDF\n\t#endif\n\t#ifdef TORUS_SDF\n\t\t#undef TORUS_SDF\n\t#endif\n#endif\n#ifdef TORUS_SDF\n\t#ifdef JULIA_SDF\n\t\t#undef JULIA_SDF\n\t#endif\n\t#ifdef SPHER_SDF\n\t\t#undef SPHER_SDF\n\t#endif\n#endif\n\n// Actual surface to test\n#ifdef SPHER_SDF\n\t#define sdf SPHER\n#else\n\t#ifdef JULIA_SDF\n\t\t#define sdf JULIA\n\t#else\n\t\t#ifdef TORUS_SDF\n\t\t\t#define sdf TORUS\n\t\t#endif\n\t#endif\n#endif\n\n// Expected baseline steps for different surfaces\n// (un-optimized raymarching)\n#ifdef SPHER_SDF\n\t#define BASE_STEPS 12\n#else\n\t#ifdef JULIA_SDF\n\t\t#define BASE_STEPS 256\n\t#else\n\t\t#ifdef TORUS_SDF\n\t\t\t#define BASE_STEPS 92\n\t\t#endif\n\t#endif\n#endif\n\n// Rotations for different types of geometry\n// Designed to show hidden surface as effectively as possible\n#ifdef SPHER_SDF\n\t#define rotate SPHERE_ROTATE\n#else\n\t#ifdef JULIA_SDF\n\t\t#define rotate JULIA_ROTATE\n\t#else\n\t\t#ifdef TORUS_SDF\n\t\t\t#define rotate TORUS_ROTATE\n\t\t#endif\n\t#endif\n#endif\n\n// Shading deltas for different surfaces\n#define dRGB 0.1f\n#ifdef JULIA_SDF\n\t#undef dRGB\n\t#define dRGB 0.01f\n#endif\n\n// Computes the inverse of a given quaternion\nvec4 QtnInverse(vec4 qtn)\n{\n    return vec4(qtn.xyz, qtn.w * -1.0);\n}\n\n// Compute the product of two unit quaternions\n// (for three-dimensional rotation)\nvec4 QtnUnitProduct(vec4 qtnA, vec4 qtnB)\n{\n    vec3 vecA = qtnA.w * qtnB.xyz;\n    vec3 vecB = qtnB.w * qtnA.xyz;\n    vec3 orthoVec = cross(qtnA.xyz, qtnB.xyz);\n\n    return vec4(vecA + vecB + orthoVec,\n                 (qtnA.w * qtnB.w) - dot(qtnA.xyz, qtnB.xyz));\n}\n\n// Perform rotation by applying the given quaternion to\n// the given vector\nvec3 QtnRotate(vec3 vec, vec4 qtn)\n{\n    vec4 qv = QtnUnitProduct(qtn, vec4(vec, 0.0));\n    return QtnUnitProduct(qv, QtnInverse(qtn)).xyz;\n}\n\n// Compute rotation for spheres\nvec3 SPHERE_ROTATE(vec3 ro, float t)\n{\n    // Spheres are uniform in every direction + contain no hidden\n    // surfaces\n    return ro;\n}\n\n// Compute rotation for Julia fractals\nvec3 JULIA_ROTATE(vec3 ro, float t)\n{\n\treturn QtnRotate(ro,\n                  \t  vec4(vec3(0.0f, 1.0f, 0.0f) * sin(t), cos(t)));\n}\n\n// Compute rotation for tori\nvec3 TORUS_ROTATE(vec3 ro, float t)\n{\n\treturn QtnRotate(ro,\n                  \t vec4(vec3(1.0f, 0.0f, 0.0f) * sin(t), cos(t)));\n}\n\n// Spherical SDF\nfloat SPHER(vec3 p)\n{ return length(p) - 1.0f; }\n\n// Small quaternion multiplier for Julia fractals\n// Adapted from MacSlow's \"qMult\" function, viewable\n// over here:\n// https://www.shadertoy.com/view/lttSzX\nvec4 QtnProduct(vec4 qtnA, vec4 qtnB)\n{\n    float x = qtnA.x * qtnB.x - dot(qtnA.yzw, qtnB.yzw);\n    vec3 yzw = (qtnA.x * qtnB.yzw) +\n               (qtnB.x * qtnA.yzw) +\n               cross(qtnA.yzw, qtnB.yzw);\n    return vec4(x, yzw);\n}\n\n// Julia SDF\n#define JULIA_C vec4(vec3(-0.46f, 0.5f, 0.4f), 0.0f)\n#define JULIA_BAILOUT 256.0f\n#define JULIA_ITER 8\nfloat JULIA(vec3 p)\n{\n    // Initialise iteration point (z), escape-time derivative (dz),\n    // and Julia constant (c)\n    // Also apply uniform scaling\n    vec4 c = JULIA_C;\n    vec4 z = vec4(p, c.w);\n    vec4 dz = vec4(1.0f, 0.0f, 0.0f, 0.0f);\n\n    // Iterate the fractal\n    int i = 0;\n    float sqrBailout = JULIA_BAILOUT;\n    while (i < JULIA_ITER &&\n           dot(z, z) < sqrBailout)\n    {\n        // Update the Julia differential [dz]\n        dz = 2.0f * QtnProduct(z, dz);\n\n        // Displace the Julia coordinate [z]\n        z = QtnProduct(z, z) + c;\n\n        // Update the iteration count\n        i += 1;\n    }\n\n    // Compute, return distance\n    float r = length(z);\n    return (0.5 * log(r) * r / length(dz));\n}\n\n// Torus SDF\n// SDF from iq,\n// https://iquilezles.org/articles/distfunctions\nfloat TORUS(vec3 p)\n{\n    vec2 t = vec2(1.0, 0.4);\n\tvec2 q = vec2(length(p.xz) - t.x, p.y);\n\treturn length(q) - t.y;\n}\n","name":"Common","description":"","type":"common"}]}