{"ver":"0.1","info":{"id":"7ldSRB","date":"1639501014","viewed":566,"name":"[Volumetric raymarching]","username":"Langwedocjusz","description":"Based entirely on this amazing article: https://wallisc.github.io/rendering/2020/05/02/Volumetric-Rendering-Part-1.html","likes":31,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define VOLUME_MARCH_STEPS 20\n#define VOLUME_SHADOWING_STEPS 10\n\n#define MAX_MARCH_STEPS 32\n#define MAX_MARCH_DIST 1e3\n#define MIN_MARCH_DIST 1e-3\n\n#define NUM_LIGHTS 3\n\n#define PI 3.1415926535\n\nstruct PointLight{\n    vec3 pos, col;\n};\n\nmat3 CameraRotation(float pitch, float yaw) {\n    mat3 rot_x = mat3(1.0, 0.0,        0.0,\n                      0.0, cos(pitch),-sin(pitch),\n                      0.0, sin(pitch), cos(pitch));\n    mat3 rot_y = mat3(cos(yaw), 0.0, sin(yaw),\n                      0.0,      1.0, 0.0,\n                     -sin(yaw), 0.0, cos(yaw));\n    return rot_y*rot_x;\n}\n\nbool intersectXZPlane(vec3 org, vec3 dir, inout float dist) {\n    const float epsilon = 0.000001;\n    vec3 normal = vec3(0.0, 1.0, 0.0);\n\n    float denom = dot(-normal, dir); \n    if (denom > epsilon) { \n        dist = dot(-org, -normal) / denom; \n        return (dist >= 0.0); \n    } \n \n    return false; \n}\n\n//https://gamedev.stackexchange.com/questions/96459/fast-ray-sphere-collision-code\nbool intersectSphere(vec3 org, vec3 dir, vec3 sph_pos, float radius, inout float dist) {\n    vec3 displacement = org - sph_pos;\n    \n    float b = dot(displacement, dir);\n    float c = dot(displacement, displacement) - radius*radius;\n    \n    if (c>0.0 && b>0.0) return false;\n    \n    float discriminant = b*b - c;\n    if (discriminant < 0.0) return false;\n    \n    dist = -b - sqrt(discriminant);\n    if (dist < 0.0) dist = 0.0;\n    \n    return true;\n}\n\nPointLight getPointLight(int i){\n    const float delta = 2.0*PI/3.0;\n    float phi = 2.0*iTime;\n    \n    switch(i) {\n        case 0:\n            return PointLight(vec3(cos(phi), 0.25, sin(phi)), 0.9*vec3(0.0, 1.0, 1.0));\n        case 1:\n            phi += delta;\n            return PointLight(vec3(cos(phi), 0.25, sin(phi)), 0.9*vec3(1.0, 0.0, 1.0));\n        case 2:\n            phi += 2.0*delta;\n            return PointLight(vec3(cos(phi), 0.25, sin(phi)), 0.9*vec3(1.0, 1.0, 0.0));\n        default:\n            return PointLight(vec3(0.0), vec3(0.0));\n    }\n}\n\n\nvec3 PhongLighting(vec3 pos, vec3 norm, vec3 view_dir, PointLight light, vec3 base_col) {\n    vec3 displacement = light.pos - pos;\n    \n    float dist = length(displacement);\n    float attenuation = 1.0/dist*dist;\n    \n    displacement = normalize(displacement);\n    vec3 dif = clamp(dot(norm, displacement), 0.0, 1.0) * attenuation * light.col;\n    \n    vec3 reflect_dir = reflect(displacement, norm);\n    float shininess = 32.0;\n    float spec = pow(max(dot(view_dir, reflect_dir), 0.0), shininess);\n    \n    return base_col*(dif + spec);\n}\n\nfloat sdfSphere(vec3 point, float radius) {\n    return length(point) - radius;\n}\n\n//From method 1 in https://www.shadertoy.com/view/XslGRr\nfloat noise(vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n    \n    vec2 uv = (p.xy+vec2(37.0,239.0)*p.z) + f.xy;\n    vec2 rg = textureLod(iChannel0,(uv+0.5)/256.0,0.0).yx;\n\treturn mix( rg.x, rg.y, f.z )*2.0-1.0;\n}\n\n//https://iquilezles.org/articles/fbm\nfloat fbm(in vec3 x) {\n    const float H = 1.0;\n    const int num_octaves = 7;\n    \n    float G = exp2(-H);\n    \n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    \n    vec3 flow = 0.2*iTime*vec3(-1.0, 0.4, 1.0);\n    \n    for(int i=0; i<num_octaves; i++) {\n        t += (i>2) ? a*noise(f*(x-flow)): a*noise(f*x);\n        f *= 2.0;\n        a *= G;\n    }\n    \n    return t;\n}\n\nfloat DensityMap(vec3 point) {\n    vec3 translation = vec3(0.0, 0.4, 0.0);\n    return sdfSphere(point-translation, 0.8) + 0.6*fbm(1.2*point);\n}\n\nfloat NormalizedDensity(vec3 point) {   \n    float sd = DensityMap(point);\n    bool inside = sd < 0.0;\n    return inside ? min(-sd, 1.0) : 0.0;\n}\n\nfloat March(vec3 org, vec3 dir) {\n    float total_dist = 0.0;\n    for (int i=0; i<MAX_MARCH_STEPS; i++) {\n        float sd = DensityMap(org + total_dist*dir);\n        if (sd < MIN_MARCH_DIST || sd > MAX_MARCH_DIST)\n            return total_dist;\n        total_dist += sd;\n    }\n}\n\nfloat BeerLambert(float dist, float absorbance){\n    return exp(-absorbance*dist);\n}\n\nvec3 VolumetricMarch(vec3 org, vec3 dir, float opaque_depth, inout float visibility) {\n    const float albedo = 0.7, absorbance = 30.0;\n    const vec3 ambient = vec3(0.2);\n    \n    vec3 color = vec3(0.0);\n    visibility = 1.0;\n    \n    float volume_depth = March(org, dir); //Start near the volume\n    if (volume_depth >= MAX_MARCH_DIST) return color; //Early exit\n    volume_depth -= 0.2;\n    float max_depth = 3.0; //Empirical value atm\n    float step_size = (max_depth - volume_depth)/float(VOLUME_MARCH_STEPS); //Uniform sampling\n    \n    for(int i = 0; i < VOLUME_MARCH_STEPS; i++) {\n        volume_depth += step_size;\n        \n        if(volume_depth > opaque_depth) break;\n\t\n        vec3 pos = org + volume_depth*dir;\n        bool inVolume = DensityMap(pos) < 0.0f;\n        \n        if(inVolume) \t{\n            float prev_visiblity = visibility;\n            visibility *= BeerLambert(step_size, NormalizedDensity(pos)*absorbance);\n            \n            float absorption = prev_visiblity - visibility;\n            \n            //Lighting:\n            for (int j=0; j<NUM_LIGHTS; j++) {\n                PointLight light = getPointLight(j);\n                float light_dist = length(light.pos - pos);\n                vec3 light_col = light.col/(light_dist*light_dist);\n                \n                vec3 light_dir = normalize(light.pos - pos);\n                float light_vis = 1.0;\n                float ldist = 0.0;\n                float lstep_size = light_dist/float(VOLUME_SHADOWING_STEPS);\n                \n                //Self shadowing:\n                for (int k=0; k<VOLUME_SHADOWING_STEPS; k++) {\n                    ldist += lstep_size;\n                    if (ldist > MAX_MARCH_DIST) break;\n                    \n                    vec3 lpos = pos + ldist * light_dir;\n                    if (DensityMap(lpos) < 0.0 )\n                        light_vis *= BeerLambert(step_size, NormalizedDensity(lpos)*absorbance);\n                }\n                \n                color += absorption * albedo * light_vis * light_col;\n            }\n            \n            color += absorption * albedo * ambient;\n        }\n    }\n    \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    //Coordinates with zero in the middle:\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = 2.0*uv - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    //Generate rays:\n    vec3 org = 1.6*vec3(-1.0, 1.0, -1.0);\n    vec3 dir = normalize(vec3(uv, 1.6));\n    dir = CameraRotation(-PI/4.0 + 0.3, -PI/4.0) * dir;\n    \n    //Opaque rendering:\n    vec3 opaque_color = vec3(0.0);\n    float opaque_dist = 1e9;\n    //Floor:\n    if (intersectXZPlane(org, dir, opaque_dist)) {\n        vec3 pos = org + opaque_dist * dir;\n        \n        int x = int(abs(pos.x))+int(pos.x<0.0), z = int(abs(pos.z))+int(pos.z<0.0);\n        vec3 baseColor = vec3(0.05 + 0.95*float(x%2==z%2));\n        \n        for(int i=0; i<NUM_LIGHTS; i++) {\n            PointLight light = getPointLight(i);\n            opaque_color += PhongLighting(pos, vec3(0.0, 1.0, 0.0), dir, light, baseColor);\n        }\n    }\n    //Light sources:\n    float dist = 1e9;\n    for (int i=0; i<NUM_LIGHTS; i++) {\n        PointLight light = getPointLight(i);\n        if (intersectSphere(org, dir, light.pos, 0.1, dist))\n            if (dist < opaque_dist) {\n                opaque_color = light.col;\n                opaque_dist = dist;\n            }\n    }\n    \n    //Volume rendering\n    float visibility;\n    vec3 volume_color = VolumetricMarch(org, dir, opaque_dist, visibility);\n    \n    vec3 color = min(volume_color, 1.0f) + visibility * opaque_color;\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}