{"ver":"0.1","info":{"id":"4dcBRB","date":"1530552735","viewed":1437,"name":"Leopard Fur","username":"BigWIngs","description":"Noise flow lines seem to be in vogue these days. Had this doodle lying around unreleased. I guess now is as good a time as any to release it. Zoom with mouse.\nPut full screen to see more. Read comments for details.","likes":60,"published":1,"flags":0,"usePreview":0,"tags":["fur","leopard","cheetah","jaguar"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Leopard Fur - by Martijn Steinrucken aka BigWings - 2018\n// Email:countfrolic@gmail.com Twitter:@The_ArtOfCode\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Its not the most efficient but I'm happy with how it turned out.\n// If your computer runs this too slow then lower the number of strands.\n// Put full screen to see more of the pattern.\n\n// Zoom with mouse.\n\n// Use these values to change the effect\n\n\n#define NUM_STRANDS 150.\n#define STRAND_THICKNESS 1.\n#define FUR_SIZE 15.\n#define FUR_CURL 1.\n#define FUR_ROUGHNESS .13\n#define BASE_COL vec3(1., .7, .3)\n#define SPOT_COL vec3(.7, .3, .1)\n#define RING_COL vec3(.2, .15, .1)\n#define MOTTLE .9\n\nvec4 FurLayer(vec2 uv, vec2 offs, vec2 grid, out float alpha) {\n    vec2 gv = (uv-offs)*grid;\n    vec2 id = floor(gv);\n    gv = fract(gv)-.5;\n    \n    vec4 col = vec4(0);\n    col.rgb = N23(id);\n    \n    vec2 a = vec2(0);\n    \n    float n = SmoothNoise((floor((uv-offs)*grid)/grid+offs), 4.)*FUR_CURL;\n   \tfloat r = (n + N21(id)*FUR_ROUGHNESS)*2.*PI;\n    vec2 b = Rot2d(vec2(0,.4), r);\n    \n    float t = sat( GetT(gv, -b, b));\n    float d = length(gv-(2.*b*t-b));\n    \n    float w = mix(.004, .06, t)*STRAND_THICKNESS;\n    float c = S(w, w*.8, d);\n    \n    alpha = S(w, 0., d)*c*S(.0, .5, t);\n    col.a = (1.-t);\n    col.rgb *= c*col.a;\n    col.a *= col.a;\n    \n    return col;\n}\n\nvec3 LeopardTex(vec2 uv) {\n\tfloat n = SmoothNoise(uv, 16.);\n    n += SmoothNoise(uv, 32.)*.5;\n    n/=1.5;\n    \n    vec4 h = HexCoords(uv*5.);\n    vec2 o = N22(h.zw+76354.);\n    \n    float r = (.3+sin(h.x*3.+o.x)*.08*o.y);\n    r *= mix(.5, 1., fract(o.y*10.));\n    float w = .4;\n    float c = S(w, .0, abs(h.y-r));\n    \n    n = n*n + c;\n    n = S(1., 1.2, n);\n    \n    vec3 col = BASE_COL;\n   \n    col = mix(col, SPOT_COL, S(r*1.5, .0, h.y));\n    col = mix(col, RING_COL, n);\n    col *= 1.-SmoothNoise(uv, 50.)*MOTTLE;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = vec2(300, 300)*2.;//iResolution.xy;\n    vec2 uv = (fragCoord-.5*res.xy)/res.y;\n\tvec2 m = (iMouse.xy/iResolution.xy);\n    \n    uv *= .3+m.y;\n    \n    float t = iTime*0.3;\n    \n    uv = Rot2d(uv, t*.1);\n    uv += t*.2;\n    vec2 grid = vec2(FUR_SIZE);\n    \n    vec4 col = vec4(0);\n    for(float i=0.; i<NUM_STRANDS; i++) {\n    \tvec2 offs = (N12(i)-.5);\n        float alpha;\n        vec4 fur = FurLayer(uv, offs, grid, alpha);\n        \n        if(fur.a>col.a) col = mix(col, fur, alpha);\n    }\n    \n    col.rgb = vec3(max(col.r, max(col.g, col.b)));\n    col.rgb *= LeopardTex(uv*.5);\n    \n    fragColor = col*2.5;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define S(a, b, t) smoothstep(a, b, t)\n#define sat(x) clamp(x, 0., 1.)\n#define PI 3.14159265\n#define R3 1.732051\n\n// Returns hexagonal coordinates. \n// XY = polar uv coords,  ZW = hex id \nvec4 HexCoords(vec2 uv) {\n    vec2 s = vec2(1, R3);\n    vec2 h = .5*s;\n\n    vec2 gv = s*uv;\n    \n    vec2 a = mod(gv, s)-h;\n    vec2 b = mod(gv+h, s)-h;\n    \n    vec2 ab = dot(a,a)<dot(b,b) ? a : b;\n    vec2 st = vec2(atan(ab.x, ab.y), length(ab));\n    vec2 id = gv-ab;\n    \n    return vec4(st, id);\n}\n\nfloat GetT(vec2 p, vec2 a, vec2 b) {\n\tvec2 ba = b-a;\n    vec2 pa = p-a;\n    \n    float t = dot(ba, pa)/dot(ba, ba);\n    \n    return t;\n}\n\nvec2 ClosestPointSeg2D(vec2 p, vec2 a, vec2 b) {\n\tvec2 ba = b-a;\n    vec2 pa = p-a;\n    \n    float t = dot(ba, pa)/dot(ba, ba);\n    t = sat(t);\n    \n    return a + ba*t;\n}\n\nfloat DistSeg2d(vec2 uv, vec2 a, vec2 b) {\n\treturn length(uv-ClosestPointSeg2D(uv, a, b));\n}\n\nfloat N(float p) {\n\treturn fract(sin(p*6453.2)*3425.2);\n}\n\n\n\nvec3 N23(vec2 p) {\n    return fract(sin(vec3(p.x*6454., p.y*746., (p.x+p.y)*64.2))*vec3(876.4, 997.4, 654.2));\n}\n\nfloat N21(vec2 p) {\n    p = fract(p*vec2(123.45,234.56));\n    p += dot(p, p+56.57);\n    return fract(p.x*p.y);\n    \n    //p = p*1342.3+vec2(345.45,2345.3);\n\t//return fract(sin(p.x+p.y*1534.2)*7363.2);\n}\n\nvec2 N22(vec2 p) {\n    float n = N21(p);\n    return vec2(n, N21(p+n));\n}\n\nvec2 N12(float p) {\n    float x = N(p);\n\treturn vec2(x, N(p*100.*x));\n}\n\n\n\nfloat N2(vec2 p)\n{\t// Dave Hoskins - https://www.shadertoy.com/view/4djSRW\n\tvec3 p3  = fract(vec3(p.xyx) * vec3(443.897, 441.423, 437.195));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat N2(float x, float y) { return N2(vec2(x, y)); }\n\nfloat SmoothNoise2(vec2 uv) {\n    // noise function I came up with\n    // ... doesn't look exactly the same as what i've seen elswhere\n    // .. seems to work though :)\n    vec2 id = floor(uv);\n    vec2 m = fract(uv);\n    m = 3.*m*m - 2.*m*m*m;\n    \n    float top = mix(N2(id.x, id.y), N2(id.x+1., id.y), m.x);\n    float bot = mix(N2(id.x, id.y+1.), N2(id.x+1., id.y+1.), m.x);\n    \n    return mix(top, bot, m.y);\n}\n\nfloat Hash(in vec2 p, in float scale) {\n\t// This is tiling part, adjusts with the scale...\n\tp = mod(p, scale);\n\treturn fract(sin(dot(p, vec2(27.16898, 38.90563))) * 5151.5473453);\n}\n\n//----------------------------------------------------------------------------------------\nfloat SmoothNoise(in vec2 p, in float scale ){\n\tvec2 f;\n\t\n\tp *= scale;\n\n\t\n\tf = fract(p);\t\t// Separate integer from fractional\n    p = floor(p);\n\t\n    f = f*f*(3.0-2.0*f);\t// Cosine interpolation approximation\n\t\n    float res = mix(mix(Hash(p, \t\t\t\t scale),\n\t\t\t\t\t\tHash(p + vec2(1.0, 0.0), scale), f.x),\n\t\t\t\t\tmix(Hash(p + vec2(0.0, 1.0), scale),\n\t\t\t\t\t\tHash(p + vec2(1.0, 1.0), scale), f.x), f.y);\n    return res;\n}\n\nvec2 Rot2d(vec2 p, float a) {\n\tfloat s = sin(a);\n    float c = cos(a);\n    return vec2(p.x*s-p.y*c, p.x*c+p.y*s);\n}","name":"Common","description":"","type":"common"}]}