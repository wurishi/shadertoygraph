{"ver":"0.1","info":{"id":"sd2yRw","date":"1643275309","viewed":85,"name":"Shader-Studies: Cellular Noise","username":"LeyMB","description":"A shader I made as part of my studies to improve my shader knowledge. Created as part of an exercise on https://thebookofshaders.com/12/\nIt is still a bit flawed, it is sometimes possible to see the cells, but all in all, I am pretty happy with it.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["noise","cellularnoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Many thanks to Patricio Gonzalez Vivo & Jen Lowe for their tutorials on thebookofshaders.com\n// Their website is an invaluable resource when starting out with learning shaders and has helped me greatly\n\n#define SCALE 3.0;\n\n// random function by Patricio Gonzalez Vivo\n// https://thebookofshaders.com/12/\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// random function by Patricio Gonzalez Vivo\n// https://thebookofshaders.com/11/\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                * 43758.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // creating distance field\n\tvec2 t_CurrentCoord = fragCoord.xy/iResolution.xy;\n\tt_CurrentCoord *= iResolution.x/iResolution.y;\n\t\n\tt_CurrentCoord *= SCALE;\n\n\t// tiling\n\tvec2 t_IntComp = floor(t_CurrentCoord);\n\tvec2 t_FractComp = fract(t_CurrentCoord); \n    \n\n\t// smallest distance that can be found to any of the points per pixel\n\tfloat t_Distance = 10000.0;\n\n\tfor(int y = -1; y <= 1; y++)\n\t{\n\t\tfor(int x = -1; x <= 1; x++)\n\t\t{\n\t\t\tvec2 t_AdjacentTile = vec2(x,y);\n\n\t\t\tvec2 t_RandPoint = random2(t_IntComp + t_AdjacentTile); \n\n\t\t\t// space to animate the point\n            t_RandPoint.x += 0.4 * sin(iTime * random(t_RandPoint));\n            \n\t\t\t// distance to t_RandPoint\n\t\t\tfloat t_Dist = length(t_AdjacentTile + t_RandPoint - t_FractComp);\n\t\t\t\n\t\t\tif(t_Dist < t_Distance)\n\t\t\t{\n\t\t\t\tt_Distance = t_Dist;\n\t\t\t}\n\t\t}\n\t}\n\n\t// color based on distance\n\tvec3 t_Color = vec3(0.0);\n\tt_Color += t_Distance;\n\n\tfragColor = vec4(t_Color, 1.0);\n}","name":"Image","description":"","type":"image"}]}