{"ver":"0.1","info":{"id":"Mt3XWj","date":"1482245119","viewed":2065,"name":"GGX Test","username":"Pheema","description":"You can change light direction and surface roughness with mouse dragging.\nx: light direction, y: roughness [0~1]\n\nD: GGX distribution\nG: Smith Joint Masking-Shadowing Function\nF: Schlick approx","likes":21,"published":1,"flags":0,"usePreview":0,"tags":["brdf","ggx"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define M_PI (3.14159265358979)\n#define EPS (1e-3)\n#define USE_ROUGHNESS_TEXTURE\n\nconst float kSensorWidth = 2.0 * 35e-3;\nconst float kSensorDist = 35e-3;\n\nstruct Ray\n{\n\tvec3 o;\n    vec3 dir;\n};\n\nstruct HitInfo\n{\n\tvec3 pos;\n    vec3 normal;\n    float dist;\n    Ray ray;\n};\n\nfloat Sphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat DistFunc(vec3 p) {\n\treturn Sphere(p, 2.0);\n}\n\nvec3 NormalizedGrad(vec3 p) {\n    vec2 d = vec2(0.0, EPS);\n\tfloat dFx = DistFunc(p + d.yxx) - DistFunc(p - d.yxx);\n\tfloat dFy = DistFunc(p + d.xyx) - DistFunc(p - d.xyx);\n\tfloat dFz = DistFunc(p + d.xxy) - DistFunc(p - d.xxy);\n\treturn normalize(vec3(dFx, dFy, dFz));\n}\n\nvec3 BGColor(vec3 dir) {\n\treturn vec3(0.2);\n}\n\nbool RayMarch(Ray ray, out HitInfo hit) {\n    vec3 ray_pos = ray.o;\n    for(int i = 0; i < 64; i++) {\n\t\tfloat dl = DistFunc(ray_pos);\n        if (DistFunc(ray_pos) < EPS) {\n            hit.pos = ray_pos;\n            hit.normal = NormalizedGrad(ray_pos);\n            hit.dist = length(ray_pos - ray.o);\n            hit.ray = ray;\n\t\t\treturn true;\n\t\t}\n\t\tray_pos += ray.dir * dl;\n\t}\n    return false;\n}\n\nfloat Pow5(float x)\n{\n    return (x * x) * (x * x) * x;\n}\n\n\n// GGX Distribution\n// Ref: https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf\nfloat DTerm(vec3 l, float HDotN, float alpha2)\n{\n    float HDotN2 = HDotN * HDotN;\n    float x = (1.0 - (1.0 - alpha2) * HDotN2);\n    float D = alpha2 / (M_PI * x * x);\n    return D;\n}\n\n// Smith Joint Masking-Shadowing Function\n// Ref: https://hal.inria.fr/hal-00942452v1/document\nfloat GTerm(float LDotN, float VDotN, float alpha2)\n{\n    float tanThetaLN2 = 1.0 / (LDotN * LDotN) - 1.0;\n    float tanThetaVN2 = 1.0 / (VDotN * VDotN) - 1.0;\n    \n    float lambdaL = 0.5 * sqrt(1.0 + alpha2 * tanThetaLN2) - 0.5;\n    float lambdaV = 0.5 * sqrt(1.0 + alpha2 * tanThetaVN2) - 0.5;\n       \n    return 1.0 / (1.0 + lambdaL + lambdaV);\n}\n\n// Schlick approx\n// Ref: https://en.wikipedia.org/wiki/Schlick's_approximation\nfloat FTerm(float LDotH, float f0)\n{\n    return f0 + (1.0 - f0) * Pow5(1.0 - LDotH);\n}\n\nfloat TorranceSparrowBRDF(vec3 v, vec3 l, HitInfo hit, float roughness)\n{\n    vec3 h = normalize(l + v);\n    \n    float VDotN = dot(v, hit.normal);\n    float LDotN = dot(l, hit.normal);\n    float HDotN = dot(h, hit.normal);\n    float LDotH = dot(l, h);\n    \n    float alpha = roughness * roughness;\n    float alpha2 = alpha * alpha;\n    \n    float D = DTerm(l, HDotN, alpha2);\n    float G = GTerm(LDotN, VDotN, alpha2);\n    float F = FTerm(LDotH, 0.95);\n    return (D * G * F) / (4.0 * abs(VDotN) * abs(LDotN));\n}\n\nvec3 ShadeSurface(HitInfo hit) {\n    // Light\n    \n    vec2 mouseUV = iMouse.xy / iResolution.xy;\n    if (iMouse.x <= 0.0) mouseUV = vec2(0.2, 0.8);\n    float phi = M_PI * mouseUV.x;\n\tvec3 lightDir = vec3(-cos(phi), 0.0, sin(phi));\n    vec3 viewDir   = -hit.ray.dir;\n    \n#ifdef USE_ROUGHNESS_TEXTURE\n    float u = atan(hit.pos.z, hit.pos.x) / (2.0 * M_PI);\n    float v = atan(hit.pos.y, length(hit.pos.xz)) / M_PI - 0.5;\n    vec2 tile = vec2(10.0, 10.0);\n    float roughness = length(texture(iChannel0, tile * vec2(u, v)).rgb) * mouseUV.y;\n#else\n    float roughness = mouseUV.y;\n#endif\n    \n    float radiance = TorranceSparrowBRDF(viewDir, lightDir, hit, roughness) * dot(lightDir, hit.normal);\n    return vec3(radiance);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = ( fragCoord.xy / iResolution.xy ) * 2.0 - 1.0;\n\tfloat aspect = iResolution.y / iResolution.x;\n    \n    // Camera settings\n\tvec3 camPos = vec3(0, 0, 5);\n\tvec3 camTarget = vec3(0);\n    \n    \n\tvec3 camForward = normalize(camTarget - camPos);\n\tvec3 camRight = cross(camForward, vec3(0.0, 1.0, 0.0));\n\tvec3 camUp = cross(camRight, camForward);\n\t\n    Ray ray;\n    ray.o = camPos;\n    ray.dir = normalize(\n        kSensorDist * camForward + \n        kSensorWidth * 0.5 * uv.x * camRight + \n        kSensorWidth * 0.5 * aspect * uv.y * camUp\n    );\n\t\n    vec3 color = vec3(0);\n    HitInfo hit;\n    if (RayMarch(ray, hit)) {\n        color = ShadeSurface(hit);\n    } else {\n    \tcolor = BGColor(ray.dir);\n    }\n    \n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}