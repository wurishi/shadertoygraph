{"ver":"0.1","info":{"id":"MXsyDN","date":"1726217195","viewed":64,"name":"Nebula Drift ","username":"madrune","description":"A procedural shader simulating drifting clouds in a cosmic nebula. Fractal noise and dynamic color gradients create a smooth, hypnotic effect. Perfect for wallpapers and ambient visuals.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["procedural","clouds","animation","nebula","fractalnoise","cosmic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// \"Nebula Drift - Dynamic Cosmic Flow\"\n// Author: Master Of CP (assisted by Guardian Of Debug)\n// Date: September 2024\n// Special thanks to: Matteo Basei (Fractal Noise) and Inigo Quilez (Procedural Techniques)\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define octaves 7\n\nfloat random(in vec2 point) {\n    return fract(100.0 * sin(point.x + fract(100.0 * sin(point.y))));\n}\n\nfloat noise(in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    float a = random(i);\n    float b = random(i + vec2(1., 0.));\n    float c = random(i + vec2(0., 1.));\n    float d = random(i + vec2(1., 1.));\n\n    vec2 u = f * f * (3. - 2. * f);\n\n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat fbm(in vec2 p) {\n    float value = 0.;\n    float freq = 1.;\n    float amp = .5;\n\n    for (int i = 0; i < octaves; i++) {\n        value += amp * (noise((p - vec2(1.)) * freq));\n        freq *= 1.9;\n        amp *= .6;\n    }\n\n    return value;\n}\n\nfloat pattern(in vec2 p) {\n    vec2 offset = vec2(-.5);\n\n    // Using TIME (iTime) for dynamic changes\n    vec2 aPos = vec2(sin(TIME * .05), sin(TIME * .1)) * 6.;\n    vec2 aScale = vec2(3.);\n    float a = fbm(p * aScale + aPos);\n\n    vec2 bPos = vec2(sin(TIME * .1), sin(TIME * .1)) * 1.;\n    vec2 bScale = vec2(.5);\n    float b = fbm((p + a) * bScale + bPos);\n\n    vec2 cPos = vec2(-.6, -.5) + vec2(sin(-TIME * .01), sin(TIME * .1)) * 2.;\n    vec2 cScale = vec2(2.);\n    float c = fbm((p + b) * cScale + cPos);\n\n    return c;\n}\n\nvec3 palette(in float t) {\n    vec3 a = vec3(.5, .5, .5);\n    vec3 b = vec3(.45, .25, .14);\n    vec3 c = vec3(1., 1., 1.);\n    vec3 d = vec3(0., .1, .2);\n\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Calculate the UV coordinates for the scene\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Oscillate the zoom factor using a sine wave\n    float zoomSpeed = 0.5; // Adjust this for faster or slower zoom\n    float zoomAmount = 0.5; // Controls the amount of zoom in and out\n    float zoomOffset = 1.0; // Base zoom level\n    \n    // Calculate zoom factor\n    float zoomFactor = zoomOffset + sin(iTime * zoomSpeed) * zoomAmount;\n    \n    // Clamp the zoom factor to limit zoom out\n    zoomFactor = clamp(zoomFactor, 0.5, 2.5); // Limits zoom from 0.5x to 2.5x\n\n    // Apply zoom effect\n    uv /= zoomFactor;\n\n    // Apply a moving effect by adding a small time-based offset\n    uv += vec2(sin(iTime * 0.1), cos(iTime * 0.1)) * 0.02; // Reduced offset for subtle movement\n\n    // Random screen shake effect every 10-30 seconds\n    float shakeInterval = 10.0 + random(vec2(floor(iTime * 0.01))) * 20.0; // Random interval between 10 and 30 seconds\n    float shakeStart = mod(iTime, shakeInterval) < 0.2 ? 1.0 : 0.0; // Trigger shake for a short duration\n    float shakeIntensity = 0.02 * shakeStart * sin(iTime * 125.0); // Intensity of the shake\n\n    // Apply the shake effect to the UV coordinates (simulate camera shake)\n    uv += vec2(random(uv + iTime) - 0.5, random(uv + iTime * 2.0) - 0.5) * shakeIntensity;\n\n    // Apply u_time-based changes to make the image dynamic\n    float value = pow(pattern(uv), 2.);\n    vec3 color = palette(value);\n\n    // Apply gamma correction\n    float gamma = 0.5;\n    color = pow(color, vec3(1.0 / gamma));\n\n    // Reduce brightness by scaling color\n    float brightnessFactor = 2.0;\n    color *= brightnessFactor;\n\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}