{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"\n#define iterations 14\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.000 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\nfloat gw3d_hash(float p){\n    return fract(4768.1232345456 * sin(p));\n}\n\nvec2 gw3d_wavedx(vec3 position, vec3 direction, float speed2, float frequency, float timeshift) {\n    float x = dot(direction, position) * frequency + timeshift * speed2;\n    float wave = exp(sin(x) - 1.0);\n    float dx = wave * cos(x);\n    return vec2(wave, -dx);\n}\n\nfloat gw3d_seedWaves = 0.0;\nvec3 gw3d_randWaves(){\n    float x = gw3d_hash(gw3d_seedWaves);\n    gw3d_seedWaves += 1.0;\n    float y = gw3d_hash(gw3d_seedWaves);\n    gw3d_seedWaves += 1.0;\n    float z = gw3d_hash(gw3d_seedWaves);\n    gw3d_seedWaves += 1.0;\n    return vec3(x,y,z) * 2.0 - 1.0;\n}\n\nfloat getwaves3d(vec3 position, float dragmult, float timeshift){\n    float iter = 0.0;\n    float phase = 6.0;\n    float speed2 = 2.0;\n    float weight = 1.0;\n    float w = 0.0;\n    float ws = 0.0;\n    \n    for(int i=0;i<20;i++){\n        vec3 p = gw3d_randWaves() * 1.21;\n    \n        vec2 res = gw3d_wavedx(position, p, speed2, phase, 0.0 + timeshift);\n        position -= normalize(position - p) * res.y * weight * dragmult * 0.01;\n        w += res.x * weight;\n        iter += 12.0;\n        ws += weight;\n        weight = mix(weight, 0.0, 0.2);\n        phase *= 1.2;\n        speed2 *= 1.02;\n    }\n    return w / ws;\n}\n\n// helper function\n\nvec3 polarToXyz(vec2 xy){\n    xy *= vec2(2.0 *3.1415,  3.1415);\n    float z = cos(xy.y);\n    float x = cos(xy.x)*sin(xy.y);\n    float y= sin(xy.x)*sin(xy.y);\n    return normalize(vec3(x,y,z));\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n\t//get coords and direction\n\tvec3 dir=rd;\n\tvec3 from=ro;\n\t\n\t//volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam; // the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.2-dm; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\tfragColor = vec4(v*.02,1.);\t\n}\nvec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n    ,\n    a1 = a+a2;\n    return abs(fract((a1)*(a2.x+a2.y))-.5);\n}\n\nvec3 fractal(vec2 uv){\n    vec3 col = vec3(0.);\n    float scale = 1.5;\n    vec2 t2 = vec2(0.);\n    vec3 col1 = col;\n    float c1=0.;\n    for(int k = 0; k < 12; k++){\n        //uv += 1./2.;\n        if(uv.x>uv.y)\n        uv.x += 1./4.;\n        else uv.y -= 1./4.;\n        //uv.y += sign(uv.x+.5)/2.+1./2.;\n        \n        uv =\n            //-sign(uv.y-uv.x)*(uv+t2)/scale\n            -(uv+t2)/scale\n        ;\n        \n        uv = -(fract(vec2(uv-vec2(.5,1.5))*scale)-.5)/scale;\n        \n        //uv.y -= sign(uv.y+.5)/2.;\n        t2 =\n            -triangle_wave(uv-.5)\n            //-triangle_wave(uv-.5)*sign(t2.y+.25)\n\n            \n            //purple\n            //triangle_wave(uv+.5) - 1.\n        ;\n        float t = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(uv.xy) + .07)) * 2.2;\n\t\n        uv =\n            //t2-triangle_wave(uv.yx)+fract(t2/2.)\n            \n            //looks better with more iterations\n            t2-triangle_wave(uv.yx+floor(iTime*0.+uv.x))-fract(t2)-vec2(floor(-uv.x),0.)\n        ;        uv.y -= sign(uv.x-.5)/2.;\n\n        \n        c1 =\n            //max(abs(uv.y-uv.x*sign(uv.x-uv.y))/2.,c1)\n            max(abs(uv.y-uv.x)/2.,c1)\n        ;\n        \n        c1 =\n            1.-abs(2.*c1-1.)\n            \n            //more colorful\n            //abs(2.*c1-1.)\n            \n            //Spooky!\n            //max(abs(2.*c1-2.),c1/4.)/2.\n        ;\n        uv.y += 1./4.;\n        \n        col.x =\n             //col.x\n            \n            //blue and white\n            //c1\n            \n            //red and blue and white\n            //max(1.-abs(2.*c1-1.),c1/4.)\n\n            \n            //more colorful\n            //max(length(uv-t2-c1)/3.,1.-col.x)\n            \n            //blue and green\n            //max(length(uv-c1)/3.,col.x)\n            length(uv-c1)/3.\n           \n            //purple\n            //2. - max((abs(uv.y-uv.x))/3.,col.x)\n           \n            //black and white\n            //col.x\n        ;\n        \n        col =\n            abs(col-(1.-(c1*col.x)));\n        col1 =\n            abs(col1*c1-col-1.).yzx\n            //abs(col1*c1-col*sign(t2.y-t2.x)-1.).yzx\n        ;\n        //uv.x += sign(uv.y-.5)/2.;\n    }\n    return col1;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//get coords and direction\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 dir=vec3(uv*zoom,1.);\nvec4 o =fragColor;\nvec2 F =fragCoord;\nvec2 R = iResolution.xy; \n  vec3 col1 = fractal(uv);\n    o-=o;\n    for(float d,t = -iTime*.01, i = 0. ; i > -1.; i -= .06 )          \t\n    {   d = fract( i -3.*t );                                          \t\n        vec4 c = vec4( ( F - R *.5 ) / R.y *d ,i,0 ) * 28.;            \t\n        for (int j=0 ; j++ <27; )                                      \t\n            c.xzyw = abs( c / dot(c,c)                                 \t\n                    -vec4( 7.-.2*sin(t) , 6.3 , .7 , 1.-cos(t/.8))/7.);\t\n       o -= c * c.yzww  * d--*d  / vec4(2,3,10,1);                     \n    }\n    \n    float v1, v2, v3;\n\tv1 = v2 = v3 = 0.0;\n\t\n\tfloat s = 0.0;\n\tfor (int i = 0; i < 90; i++)\n\t{\n\t\tvec3 p = s * vec3(uv, 0.0);\n\t\t\n\t\tp += vec3(.22, .3, s - 1.5 - sin(iTime * .13) * .1)*col1;\n\t\tfor (int i = 0; i < 8; i++)\tp = abs(p) / dot(p,p) - 0.659;\n\t\tv1 += dot(p,p) * .0015 * (1.8 + sin(length(uv.xy * 13.0) + .5  - iTime * .2));\n\t\tv2 += dot(p,p) * .0013 * (1.5 + sin(length(uv.xy * 14.5) + 1.2 - iTime * .3));\n\t\tv3 += length(p.xy*10.) * .0003;\n\t\ts  += .035;\n\t}\n\t\n\tfloat len = length(uv);\n\tv1 *= smoothstep(.7, .0, len);\n\tv2 *= smoothstep(.5, .0, len);\n\tv3 *= smoothstep(.9, .0, len);\n\t\n\tvec3 col2 = vec3( v3 * (1.5 + sin(iTime * .2) * .4),\n\t\t\t\t\t(v1 + v3) * .3,\n\t\t\t\t\t v2) + smoothstep(0.2, .0, len) * .85 + smoothstep(.0, .6, v3) * .3;\n\tfloat t = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(uv.xy) + .07)) * 2.2;\n\tfloat si = sin(t);\n\tfloat co = cos(t);\n\tmat2 ma = mat2(co, si, -si, co);\n  \n\tvec3 from=vec3(1.,.5,0.5) +getwaves3d(polarToXyz(uv.xy), 10.4, iTime)*col2;\n\n\t   vec3 col = vec3(0.5,0.1,1.) * getwaves3d(polarToXyz(uv), 1.4, iTime*2.);\n\n\tmainVR(fragColor, fragCoord, from, dir);\t\n    fragColor*=vec4(col*2.+o.xyz*vec3(0.1,0.2,1.)*col2*10.,1.);\n \n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":true,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lcVfRm","date":"1733898479","viewed":168,"name":"fbm ornament","username":"nayk","description":"source https://www.shadertoy.com/view/MfKBRm https://www.shadertoy.com/view/lslyRn# https://www.shadertoy.com/view/MdXSzS","likes":3,"published":3,"flags":1,"usePreview":0,"tags":["noise","fmb","ornament"],"hasliked":0,"parentid":"","parentname":""}}