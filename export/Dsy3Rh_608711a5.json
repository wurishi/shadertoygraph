{"ver":"0.1","info":{"id":"Dsy3Rh","date":"1678155743","viewed":83,"name":"long pause","username":"jorge2017a2","description":"long pause","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["longpause"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//por jorge2017a2---mar-06-2023\n//long pause.....\n//long pause...well I was making my own shadertoy version compiler...\n//efficiency...30%, it has many calculation errors...\n//it's hard to do something well done...well it was worth \n//the try I learned things that we didn't know :)....I'm still doing other things.. :)\n\n\n\n//referencia\n//https://iquilezles.org/articles/distfunctions2d\n///\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(0.8),b,d)\n#define S2(d,b) smoothstep(6.0*antialiasing(0.5),b,d)\n#define PI     3.14159265\n#define TWO_PI 6.28318530\n\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\n\nvec3 DrawFigBordeR(vec3 pColObj, vec3 colOut, float distObj, float r )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-r,0.0));\n  return colOut;\n}\n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  return colOut;\n}\n\nvec3 DrawFigBordeCol(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.01,0.0));\n  return colOut;\n}\n\nvec3 DrawFig(vec3 pColObj, vec3 colOut, float distObj )\n{  colOut = mix(colOut,pColObj ,S2( distObj-0.05,0.0)); return colOut;}\n\nvec3 DrawFigSolo(vec3 pColObj, vec3 colOut, float distObj ) \n{  colOut = mix(colOut,pColObj ,S( distObj,0.0)); return colOut; }\n\nvec3 DrawFigRB(vec3 pColObj, vec3 colOut, float distObj, float r )\n{  colOut = mix(colOut,pColObj ,S2( distObj-r,0.0)); return colOut; }\n\nvec3 DrawFigDelgado(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj-0.001,0.0)); return colOut; }\n\n///oneshade    \nvec2 Rotate(in vec2 p, in vec2 o, in float r) \n{   float c = cos(r), s = sin(r);\n    return (p - o) * mat2(c, -s, s, c) + o;\n}\n\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);  }\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r;}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{  vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n\n///IQ\n// signed distance to a n-star polygon with external angle en\nfloat sdStar(in vec2 p, in float r, in int n, in float m) // m=[2,n]\n{\n    // these 4 lines can be precomputed for a given shape\n    float an = 3.141593/float(n);\n    float en = 3.141593/m;\n    vec2  acs = vec2(cos(an),sin(an));\n    vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) and simplify, for regular polygon,\n\n    // reduce to first sector\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n\n    // line sdf\n    p -= r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\n\n\nfloat sdParallelogram( in vec2 p, float wi, float he, float sk )\n{\n    vec2 e = vec2(sk,he);\n    p = (p.y<0.0)?-p:p;\n    vec2  w = p - e; w.x -= clamp(w.x,-wi,wi);\n    vec2  d = vec2(dot(w,w), -w.y);\n    float s = p.x*e.y - p.y*e.x;\n    p = (s<0.0)?-p:p;\n    vec2  v = p - vec2(wi,0); v -= e*clamp(dot(v,e)/dot(e,e),-1.0,1.0);\n    d = min( d, vec2(dot(v,v), wi*he-abs(s)));\n    return sqrt(d.x)*sign(-d.y);\n}\n\n\nvec4 pisotria(vec2 p,vec3 colOut)\n{\n   vec2 pr= Rotate( p, vec2(0.0),0.79);\n   \n   float d1a= sdBox(pr,vec2(2.5) );\n   float d1b= sdBox(pr,vec2(2.0) );\n   float dif1= differenceSDF(d1a, d1b);\n   \n   float d2a= sdBox(p-vec2(0.0,3.0),vec2(4.,3.0) );\n   dif1= differenceSDF(dif1, d2a);\n   \n   colOut= DrawFigBorde(vec3(0.0), colOut,abs(dif1) );\n   return vec4(colOut, abs(dif1)-0.1); \n   \n}\n\n\n\n\nvec4 dobletriaB(vec2 uv, vec3 colOut)\n{   vec2 uv0=uv;\n    uv.x=opRep1D( uv.x, 16.0);\n\n    \n    vec4 col1=pisotria(uv,colOut);\n    uv.x+=4.;\n    uv.y+=4.0;\n    vec4 col2=pisotria(vec2(uv.x,-uv.y),colOut);\n    \n    float d1a=col1.w;\n    float d1c=col2.w;\n    \n    float unitd=unionSDF(d1a, d1c);\n    colOut= DrawFigBorde(vec3(0.0), colOut,unitd);\n    return vec4( colOut,unitd);\n}\n\n\nvec3 dobletriaC(vec2 uv, vec3 colOut)\n{   vec2 uv0=uv;\n    vec4 col1=dobletriaB(uv, colOut);\n    vec4 col2=dobletriaB(uv-vec2(8.0,0.0), colOut);\n    \n    float d1=col1.w;\n    float d2=col2.w;\n    float unitd=unionSDF(d1, d2);\n    \n    colOut= DrawFigBorde(vec3(0.0), colOut,unitd);\n    return colOut;\n}\n\nvec3 pisof2(vec2 uv, vec3 colOut, vec3 colIn)\n{   vec2 uv0=uv;\n    uv.y+=18.;\n    vec3 col=colOut;\n    vec2 pr=uv-vec2(0.0,6.0);\n    pr.x=opRep1D(pr.x, 16.0);\n    pr.y=abs(pr.y)-5.0;\n    float d1a= sdBox(pr,vec2(8.0,0.5) );\n    d1a=abs(d1a)-0.2;\n    col= dobletriaC(uv-vec2(0.0,10.0),col);\n    col= dobletriaC(vec2(uv.x,-uv.y)-vec2(0.0,-2.0),col);\n    col= DrawFigBorde(colIn,col,d1a);\n    \n    return col;\n}   \n\n\nvec3 AnilloAncho(vec2 p, float r, float ancho,  vec3 colOut)\n{   float d2a= sdCircle(p, r );\n    float d2b= sdCircle(p, r-ancho);\n    float dif2= differenceSDF(d2a, d2b);\n    vec3 col=colOut;\n    col= DrawFigBorde(vec3(0.0,0.0,0.0), col, dif2 );\n    return col;\n}\n\nvec3 AnilloBloque(vec2 p, vec2 med, vec3 colOut)\n{\n    float d1a= sdBox(p,med);\n    float d1b= sdBox(p,med-vec2(0.5));\n    float dif1= differenceSDF(d1a, d1b);\n    dif1=abs(dif1)-0.15;\n    colOut= DrawFigBorde(vec3(0.0),colOut,dif1);\n    return colOut;\n}\n\nvec3 estrellaCirculo(vec2 p, vec3 colOut)\n{\n    float r; int n; float m;\n    r=8.0;n=8; m=5.0;\n    float d1a= sdStar(p, r, n, m); // m=[2,n]\n    \n    \n    r=5.0;n=8; m=5.0;\n    float d1b= sdStar(p, r, n, m); // m=[2,n]\n    \n    float dif1= differenceSDF(d1a, d1b);\n    \n    colOut= DrawFigBorde(vec3(0.0),colOut,dif1);\n    colOut=AnilloAncho(p, 2.0, 0.5, colOut);\n    colOut=AnilloAncho(p, 1.0, 0.5, colOut);\n    colOut=AnilloAncho(p, 8.0, 0.5, colOut);\n    colOut=AnilloAncho(p, 9.0, 0.5, colOut);\n    colOut= AnilloBloque(p-vec2(0.0,-19.0), vec2(7.0,10.0), colOut);\n    \n    return colOut;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    uv-=vec2(0.0,-0.25);\n    float esc=25.0;\n    uv*=esc;\n    \n    float t=iTime;\n    vec2 uv0=uv;\n    vec2 uv2=uv*(mod(sin(t),PI));\n    \n    vec2 uv3=uv*(mod(sin(2.0*t),PI))*Rot(t);\n    vec2 uv4=uv*(mod(sin(2.0*t),PI))*Rot(-t);\n    vec2 uv5=Rot(t)*vec2(uv.x,-uv.y);\n    vec2 uv6=Rot(-t)*vec2(uv.x,-uv.y);\n    \n    //vec3 col=vec3(0.0,0.1,0.8);\n    vec3 col=vec3(1.0);\n    col= pisof2(uv,col, vec3(0.0,1.0,1.0));\n     \n    col= estrellaCirculo(uv-vec2(0.0,23.0), col);\n    col= estrellaCirculo(uv2-vec2(0.0,23.0), col);\n    \n    col= estrellaCirculo(uv3-vec2(0.0,23.0), col);\n    col= estrellaCirculo(uv4-vec2(0.0,23.0), col);\n    col= estrellaCirculo(uv5-vec2(0.0,23.0), col);\n    col= estrellaCirculo(uv6-vec2(0.0,23.0), col);\n    \n    float x=sin(iTime);\n    float y=sin(2.0*iTime);\n    \n        col=1.0-col;\n    \n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}