{"ver":"0.1","info":{"id":"X3fyR7","date":"1725957850","viewed":34,"name":"Bubble Up","username":"lukejsmithluo","description":"infinite bubble up,\nYou can click and drag to move the camera","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarch","bubble","3dsdfs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_DIST 100.0 // Maximum distance for ray marching\n#define MAX_STEPS 100 // Maximum steps for ray marching\n#define SURF_DIST 1e-03 // Surface distance threshold\n#define PI 3.14159265359 // Pi constant\n#define TAU (2.0*PI) // Tau constant (2 * Pi)\n\nstruct meshAttribute\n{\n    vec3 pos; // Position of the mesh\n    vec3 rotation; // Rotation of the mesh\n    vec3 scale; // Scale of the mesh\n};\n\n// Rotation matrix for 2D rotation\nmat2 Rot(in float angle)\n{\n    float a = sin(angle);\n    float b = cos(angle);\n    return mat2(b, -a, a, b);\n}\n\n// Rotation matrix for 3D rotation\nmat3 rot3D(in vec3 Rotation)\n{\n    float a = Rotation.x;\n    float b = Rotation.y;\n    float c = Rotation.z;\n    // Rotation around x-axis\n    float cx = cos(a);\n    float sx = sin(a);\n    mat3 rotx = mat3(1.0, 0.0, 0.0, \n                     0.0, +cx, +sx,\n                     0.0, -sx, +cx);\n    // Rotation around y-axis\n    float cy = cos(b);\n    float sy = sin(b);\n    mat3 roty = mat3(+cy, 0.0, +sy, \n                     0.0, 1.0, 0.0,\n                    -sy, 0.0, +cy);\n    // Rotation around z-axis\n    float cz = cos(c);\n    float sz = sin(c);\n    mat3 rotz = mat3(+cz, +sz, 0.0, \n                     -sz, +cz, 0.0,\n                     0.0, 0.0, 1.0);\n    mat3 result;\n    return result = rotx * roty * rotz;\n}\n\n// Scale matrix for 3D scaling\nmat3 scale3D(in vec3 scale)\n{\n    return mat3(scale.x, 0.0, 0.0,\n                0.0, scale.y, 0.0,\n                0.0, 0.0, scale.z);\n}\n\n// Boolean union operation for distance fields\nfloat BoolenUnion(const in float a, const in float b, const in float c)\n{\n    float h = clamp(0.5 + 0.5 * (b - a)/c, 0.0, 1.0);\n    return mix(b, a, h) - c*h*(1.0 - h);\n}\n\n//hash&noise refï¼šhttps://www.shadertoy.com/view/Xdt3RN\n// Hash function for generating random values\nfloat hash(in float a)\n{\n    return fract(sin(a) * 753.5453123);\n}\n\n// Noise function for generating 3D noise\nfloat noise(in vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f * f * (3.0 - 2.0*f);\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n// Distance function for a transformed sphere\nfloat transSphere(in vec3 p)\n{\n    return length(p)-1.125+ noise((p+vec3(0, 0, iTime/3.0)) * 2.0) * 0.153;\n}\n\n// Distance function for an ellipsoid\nfloat sdEllipsoid(in vec3 p, in vec3 s)\n{\n    float k0 = length(p/s);\n    float k1 = length(p/(s*s));\n    return k0*(k0 - 1.0) / k1;\n}\n\n// Transform function for applying position, rotation, and scale to a point\nvec3 transform(const in vec3 p, meshAttribute mAttribute)\n{\n    vec3 newP = p - mAttribute.pos;\n    newP *= rot3D(mAttribute.rotation);\n    newP *= scale3D(mAttribute.scale);\n    return newP;\n}\n\nmeshAttribute m1Attribute = meshAttribute(vec3(0.0), vec3(0.0), vec3(1.0));\nmeshAttribute m2Attribute = meshAttribute(vec3(0.0), vec3(0.0), vec3(1.0));\n\n// Distance function for the scene\nfloat GetDist(in vec3 p)\n{\n    float dist;\n\n    m1Attribute.pos = vec3(0.0, -1.2, 0.0);\n    vec3 point1 = transform(p, m1Attribute);\n    float tS = transSphere(point1);\n\n    m2Attribute.pos = vec3(0.0, \n                            mix(-2.1, 3.0, mod(iTime/3.0, 3.0)),\n                            0.0);\n    vec3 point2 = transform(p, m2Attribute);\n    float sE = sdEllipsoid(point2, vec3(mix(0.5, 1.0, mod(iTime/3.0, 3.0)),\n                                        mix(1.5, 1.0, mod(iTime/3.0, 3.0)),\n                                        mix(0.5, 1.0, mod(iTime/3.0, 3.0)) ));\n\n    dist = BoolenUnion(tS, sE, sin(iTime)*0.5+0.6);\n\n    return dist;\n}\n\n// Normal calculation function\nvec3 GetNormal(in vec3 p)\n{\n    float d = GetDist(p);\n    vec2 e = vec2(1e-03, 0.0);\n\n    vec3 n = d - vec3(GetDist(p - e.xyy),\n                      GetDist(p - e.yxy), \n                      GetDist(p - e.yyx));\n\n    return normalize(n);\n}\n\n// Ray marching function\nfloat RayMarch(in vec3 ro, in vec3 rd)\n{\n    float t = 0.0;\n\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + rd * t;\n        float d = GetDist(p);\n        t += d;\n\n        if(d == MAX_DIST || d < SURF_DIST) break;\n    }\n\n    return t;\n}\n\n// Dispersion effect function\nvec3 dispersion3(in samplerCube cubeMap, in vec3 p, in float value)\n{\n    // Define dispersion coefficient\n    float dispersion = value;\n\n    // Calculate direction for different color components\n    vec3 dirR = normalize(p + vec3(dispersion, 0.0, 0.0));\n    vec3 dirG = normalize(p + vec3(0.0, dispersion, 0.0));\n    vec3 dirB = normalize(p + vec3(0.0, 0.0, dispersion));\n\n    // Sample texture for each color component\n    vec3 colorR = texture(cubeMap, dirR).rgb;\n    vec3 colorG = texture(cubeMap, dirG).rgb;\n    vec3 colorB = texture(cubeMap, dirB).rgb;\n\n    // Combine color components into final color\n    return vec3(colorR.r, colorG.g, colorB.b);\n}\n\n// Dispersion color function\nvec3 dispersionColor(in vec3 color, in vec3 p, in float value)\n{\n    // Calculate refraction direction for different wavelengths\n    vec3 dirR = normalize(p + vec3(value, 0.0, 0.0));\n    vec3 dirG = normalize(p + vec3(0.0, value, 0.0));\n    vec3 dirB = normalize(p + vec3(0.0, 0.0, value));\n\n    // Simulate color components for different wavelengths\n    vec3 colorR = color * dirR;\n    vec3 colorG = color * dirG;\n    vec3 colorB = color * dirB;\n\n    // Combine color components into final color\n    return colorR + colorG + colorB;\n}\n\n// Camera creation function\nvec3 createAcamera(in vec3 ro, in vec2 uvCoord)\n{\n    // Position of the look-at point\n    const vec3 la = vec3(0.0);\n    const vec3 up = normalize(vec3(0.0, 1.0, 0.0));\n    // Calculate normalized direction vector from look-at point to camera origin\n    vec3 ww = normalize(la - ro);\n    // Calculate and normalize right direction\n    vec3 uu = normalize(cross(up, ww));\n    vec3 vv = (cross(ww,uu));\n    const float fov = tan(TAU / 6.0); // Field of view\n\n    return normalize(-uvCoord.x*uu + uvCoord.y*vv + fov*ww); // Calculate camera direction\n}\n\n// Fresnel effect function\nfloat fresnel(const in vec3 normal, const in vec3 viewDir)\n{\n    return pow(dot(normalize(normal), viewDir), 2.0); // Calculate Fresnel effect\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uvCoord = (fragCoord*2.0 - iResolution.xy)/min(iResolution.x, iResolution.y); // Normalize screen coordinates\n    vec2 m = (iMouse.xy*2.0 - iResolution.xy)/min(iResolution.x, iResolution.y); // Normalize mouse coordinates\n\n    // Initialize camera position and direction\n    vec3 ro = vec3(0.0, 0.0, -3.5); // Camera origin\n    ro = vec3(-sin(ro.x) * ro.z, ro.y + 1.0, cos(ro.x) * ro.z); // Adjust camera position\n    vec3 rd = createAcamera(ro, uvCoord); // Camera direction\n\n    vec3 color = vec3(0.0); // Initialize color\n    float sunIntensity = 0.8; // Sunlight intensity\n    float reflIntensity = 0.42; // Reflection intensity\n    float refrIntenstiy = 0.8; // Refraction intensity\n    vec3 ray, cubeRay; // Initialize ray variables\n\n    // Rotate camera vertically\n    ro.yz *= Rot(-m.y);\n    rd.yz *= Rot(-m.y);\n    // Rotate camera horizontally\n    ro.xz *= Rot(-m.x);\n    rd.xz *= Rot(-m.x);\n\n    // Perform ray marching\n    float d = RayMarch(ro, rd);\n\n    if(d < MAX_DIST)\n    {\n        vec3 p = ro + rd * d; // Calculate intersection point\n        vec3 n = GetNormal(p); // Calculate normal at intersection\n\n        float fValue = fresnel(n, rd); // Calculate Fresnel effect\n\n        ray = reflect(rd, n); // Calculate reflection direction\n        cubeRay = mix(dispersion3(iChannel0, ray, 0.04) * reflIntensity,\n                    texture(iChannel0, ray).xyz * reflIntensity,\n                    fValue); // Calculate reflection color\n\n        ray = refract(rd, n, 0.97); // Calculate refraction direction\n        cubeRay += mix(dispersion3(iChannel0, ray, 0.05) * refrIntenstiy,\n                      texture(iChannel0, ray).xyz * refrIntenstiy,\n                      fValue); // Calculate refraction color\n\n        vec3 sunLight = normalize(vec3(3.0, 5.0, -4.0)); // Sunlight direction\n        float sunDiff = (dot(n, sunLight) * 0.5 + 0.5) * sunIntensity; // Calculate diffuse sunlight\n\n        vec3 diffuse = mix(vec3(0.4549, 0.7176, 0.8392) * sunDiff, \n                          (vec3(1.0) * sunDiff * rd) * 0.6, \n                          sunDiff); // Calculate diffuse color\n        color = dispersionColor(diffuse, p, d); // Apply dispersion effect to color\n\n        color = mix(color + cubeRay, cubeRay, pow(fValue, 0.24)); // Combine color with reflection and refraction\n\n        color *= 1.24; // Adjust color intensity\n    }\n    else\n    {\n        color = texture(iChannel0, rd).xyz; // Use cube map texture color\n    }\n\n    fragColor = vec4(color, 1.0); // Set fragment color\n}","name":"Image","description":"","type":"image"}]}