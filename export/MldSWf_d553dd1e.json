{"ver":"0.1","info":{"id":"MldSWf","date":"1481970449","viewed":263,"name":"PBR Reference","username":"acdimalev","description":"Reverse-engineering 2v_S's PBR_Test to learn how all the pieces fit together.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["pbr","cooktorrance"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n* 2v_S's Physically Based Rendering Test\n* https://www.shadertoy.com/view/MlB3DV\n*\n* Modified to experiment with physically-based rendering implementations.\n* https://en.wikipedia.org/wiki/Specular_highlight#Cook.E2.80.93Torrance_model\n* http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n*\n* Starting with:\n* - Geometric Attenuation (G): Cook-Torrance\n* - Distribution (D): Beckmann\n* - Fresnel (F): Schlick\n*\n* Left: a single, constant reflection coefficient for all materials\n*\n* Right: per-material, per-color-channel reflection coefficients\n*/\n\n\n#define NB_LIGHTS 3\n\n// Metals values in linear space\n#define GOLD vec3(1.0, 0.71, 0.29)\n#define COPPER vec3(0.95, 0.64, 0.54)\n#define IRON vec3(0.56, 0.57, 0.58)\n#define ALUMINIUM vec3(0.91, 0.92, 0.92)\n#define SILVER vec3(0.95, 0.93, 0.88)\n\nfloat splitFromFragCoord(vec2 fragCoord) {\n    return floor(2.0 * fragCoord.x / iResolution.x);\n}\n\nfloat fPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat fSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n// ---- Scene definition\nvec2 fScene(vec3 p) {\n    \n    vec3 pSphere = p/*opRep(p, vec3( 2.0, 0.0, 2.0))*/;\n    \n \tvec2 sphere0 = vec2(fSphere(p, 1.0), 0.5); \t\n    vec2 sphere1 = vec2(fSphere(p+vec3(2.1, 0.0, 2.0), 1.0), 2.5);\n\tvec2 sphere2 = vec2(fSphere(p+vec3(-2.1, 0.0, 2.0), 1.0), 3.5);\n    vec2 sphere3 = vec2(fSphere(p+vec3(2.1, 0.0, -2.0), 1.0), 4.5);\n    vec2 sphere4 = vec2(fSphere(p+vec3(-2.1, 0.0, -2.0), 1.0), 5.5);\n\t\n\n\n    vec2 plane = vec2(fPlane(p, vec4(0, 1, 0, 1.0)), 1.5);\n    \n    return opU(opU(opU(opU(opU(plane, sphere0), sphere1), sphere2), sphere3), sphere4);\n}\n// -----\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 100.0;\n    \n    \n\tfloat precis = 0.00001;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<50; i++ )\n    {\n\t    vec2 res = fScene( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = fScene( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    fScene(pos+eps.xyy).x - fScene(pos-eps.xyy).x,\n\t    fScene(pos+eps.yxy).x - fScene(pos-eps.yxy).x,\n\t    fScene(pos+eps.yyx).x - fScene(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\nstruct Light {\n \tvec3 pos;\n    vec3 color;\n};\nLight lights[NB_LIGHTS];\n\n\n#define PI 3.1415\n\nvec3 half_vector(vec3 v1, vec3 v2) {\n    return normalize(v1 + v2);\n}\n\n\n// https://en.wikipedia.org/wiki/Specular_highlight#Cook.E2.80.93Torrance_model\nfloat geometric_attenuation(vec3 n, vec3 v, vec3 l) {\n    vec3 h = half_vector(v, l);\n\n    float c = 2.0 * dot(h, n) / dot(v, h);\n    float g1 = c * dot(v, n);\n    float g2 = c * dot(l, n);\n\n    return min(1.0, min(g1, g2));\n}\n\n\n// https://en.wikipedia.org/wiki/Specular_highlight#Beckmann_distribution\nfloat beckmann_distribution(vec3 n, vec3 v, vec3 l, float roughness) {\n    vec3 h = half_vector(v, l);\n    float m = roughness;\n\n    float n_dot_h = dot(n, h);\n    float n_dot_h_sq = n_dot_h * n_dot_h;\n    float n_dot_h_qu = n_dot_h_sq * n_dot_h_sq;\n    float m_sq = m * m;\n\n    float expr1 = (n_dot_h_sq - 1.0) / (n_dot_h_sq * m_sq);\n    float expr2 = PI * m_sq * n_dot_h_qu;\n\n    return exp(expr1) / expr2;\n}\n\n\n// https://en.wikipedia.org/wiki/Schlick's_approximation\nfloat shlick_fresnel(vec3 n, vec3 v, vec3 l, float reflection_coefficient) {\n    vec3 h = half_vector(v, l);\n    float c = reflection_coefficient;\n\n    float hv = dot(h, v);\n    return c + (1.0 - c) * pow(1.0 - hv, 5.0);\n}\n\n// with a separate reflection coefficient for each color channel\nvec3 shlick_fresnel(vec3 n, vec3 v, vec3 l, vec3 reflection_coefficients) {\n    vec3 h = half_vector(v, l);\n    vec3 c = reflection_coefficients;\n\n    float hv = dot(h, v);\n    return c + (1.0 - c) * pow(1.0 - hv, 5.0);\n}\n\n\n// https://en.wikipedia.org/wiki/Specular_highlight#Cook.E2.80.93Torrance_model\nvec3 computePBRLighting ( in Light light, in vec3 position, in vec3 N, in vec3 V, in vec3 albedo, in float roughness, in vec3 F0, float split ) {\n    vec3 n = N;\n    vec3 v = V;\n    vec3 l = normalize(light.pos.xyz - position);\n    \n    float d = beckmann_distribution(n, v, l, roughness);\n    float g = geometric_attenuation(n, v, l);\n    \n    vec3 specular;\n    if (split == 0.0) {\n        // https://en.wikipedia.org/wiki/Schlick%27s_approximation\n        float n1 = 1.0;\n        float n2 = 3.0/8.0;\n        float reflection_coefficient = pow((n1 - n2) / (n1 + n2), 2.0);\n        float f = shlick_fresnel(n, v, l, reflection_coefficient);\n        float k = d * f * g / (4.0 * dot(v, n) * dot(n, l));\n        specular = vec3(k);\n    }\n    if (split == 1.0) {\n        vec3 reflection_coefficients = F0;\n        vec3 f = shlick_fresnel(n, v, l, reflection_coefficients);\n        vec3 k = d * f * g / (4.0 * dot(v, n) * dot(n, l));\n        specular = k;\n    }\n    \n\tvec3 ambient = vec3(0.01);\n\tvec3 diffuse = albedo / PI;\n\n\n\treturn ambient + (diffuse + specular) * light.color.xyz * dot(n, l);\n}\n\nvec3 addPBR( in vec3 position, in vec3 N, in vec3 V, in vec3 baseColor, in float metalMask, in float smoothness, in float reflectance, float split) {\n\tvec3 color = vec3(0.0);\n\n    float roughness = 1.0 - smoothness*smoothness;\n    vec3 F0 = 0.16*reflectance*reflectance * (1.0-metalMask) + baseColor*metalMask;\n    vec3 albedo = baseColor;\n    \n    float s = 0.0;\n    \n    \n\tfor ( int i = 0; i < NB_LIGHTS; ++i ) {\n\t\tvec3 col = computePBRLighting ( lights[i], position, N, V, albedo, roughness, F0, split);\n\t\tcolor += col;\t\n        s += softshadow( position, normalize(lights[i].pos.xyz - position), 0.02, 2.5 );\n\t}\n\n\treturn color*s;\n}\n\nvec3 render( in vec3 ro, in vec3 rd, float split )\n{ \n    vec3 col = vec3(0.8, 0.9, 1.0)*8.0; // Sky color\n    \n    vec2 res = castRay( ro, rd );\n    float t = res.x;\n    float m = res.y;\n    vec3 p = ro + t*rd;\n    \n    if(m>-0.5) { // Intersection found\n        if( m < 1.0 ) {\n           // float f = mod( floor( 5.0*p.z ) + floor( 5.0*p.x ), 2.0 );\n            vec3 sur = vec3(1.0,1.0,1.0)*smoothstep(-1.0,-0.6,sin(16.0*p.x));\n            col = addPBR( p, calcNormal( p ), -rd, GOLD*sur, sur.x, 0.3+0.6*sur.x, 0.5, split );\n        } \n        else if( m < 2.0 ) {\n            float f = mod( floor( 5.0*p.z ) + floor( 5.0*p.x ), 2.0 );\n            col = addPBR(p, calcNormal( p ), -rd, vec3(0.5), 0.0, 0.3+0.6*f, 0.5, split );\n        }\n        else if( m < 3.0 ) {\n            vec3 sur = vec3(1.0,1.0,1.0)*smoothstep(-1.0,-0.4,sin(18.0*p.x));\n            col = addPBR( p, calcNormal( p ), -rd, COPPER*sur, sur.x, 0.3+0.6*sur.x, 0.5, split );\n        }\n        else if( m < 4.0 ) {\n            vec3 sur = vec3(1.0,1.0,1.0)*smoothstep(-1.0,-0.0995,sin(106.0*p.x))*smoothstep(-1.0,-0.9,sin(47.0*p.z));\n            col = addPBR( p, calcNormal( p ), -rd, vec3(0.2), 1.0-sur.x, 0.9*sur.x, 0.5, split );\n        }\n        else if( m < 5.0 ) {\n            vec3 sur = vec3(1.0)*smoothstep(-1.0,-0.765,sin(24.0*p.x))*smoothstep(-1.0,-0.4,sin(70.9*p.z));\n            col = addPBR( p, calcNormal( p ), -rd, GOLD*(1.0-sur), sur.x, 0.3+0.6*sur.x, 0.5, split );\n        }\n        else if( m < 6.0 ) {\n            vec3 sur = vec3(1.0,1.0,1.0)*smoothstep(-1.0,-0.4,sin(18.0*p.x));\n            col = addPBR( p, calcNormal( p ), -rd, ALUMINIUM*sur, sur.x, 0.3+0.6*sur.x, 0.5, split );\n        }\n    }\n    \n\treturn col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec4 hejlToneMapping (in vec4 color) {\n \tvec4 x = max(vec4(0.0), color-vec4(0.004)); \n\treturn (x * ((6.2*x)+vec4(0.5))) / max(x * ((6.2*x)+vec4(1.7))+vec4(0.06), vec4(1e-8));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = 0.25*iTime;\n    \n    lights[0] = Light(vec3(0.0, 5.0, .0), vec3(1.0));   \n\tlights[1] = Light(vec3(12.0*sin(iTime), 8.0, 12.0*cos(iTime)), vec3(1.0));   \t\n    lights[2] = Light(vec3(-12.0*cos(-iTime), 8.0, 12.0*sin(-iTime)), vec3(.05));   \n\n   \n\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\t\n\n\t// camera\t\n\tvec3 ro = vec3( 7.0*sin(time), 3.6 , -7.0*cos(time) );\n\tvec3 ta = vec3( 0.0 );\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.5) );\n    \n    float split = splitFromFragCoord(fragCoord);\n    \n    // render\t\n    vec3 col = render( ro, rd, split );\n\n    #if 0\n        col = pow( col, vec3(0.4545) );\n        fragColor=vec4( col, 1.0 );\n    #else \n    \tfloat exposure = 1.0/8.0 + 0.023*sin(time-3.14);\n   \t\tfragColor = hejlToneMapping(vec4(col, 1.0) * exposure) ;\n    #endif\n}","name":"Image","description":"","type":"image"}]}