{"ver":"0.1","info":{"id":"mdfcz8","date":"1686568614","viewed":54,"name":"Square root Newton iterations","username":"chronos","description":"A way to visualize the error and number of iterations before convergence when using Newtons method / the Babylonian method / Herons method of computing square roots.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["square","iterations","error","newton","root","babylonian"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\nVisualizing the number of iterations and error when using\nNewtons method / Herons method / The Babylonian method of computing square roots.\n\nhttps://en.wikipedia.org/wiki/Newton%27s_method#Square_root\n\n\nHorizontal and vertical axes represent the input value (argument)\nand the initial guess for the algorithm, respectively.\n\nThe axes both go from 0 to 'scale' (default = 10), where 'scale' is a constant set in the code.\n\nThe visualization shows the number of iterations taken to converge to within a small error threshold\n\nGreener colors indicate fewer iterations taken to get below the error threshold value,\nwhile more orange colors indicate more iterations taken.\n\nRed indicates that the algorithm did not manage to converge to a value below the error threshold within the\ngiven number of iterations.\n\nThis can be used and experimented with to get a feel for how many iterations are required.\nIt should also be suitable for studying other functions than sqrt().\n\nOf course, if you want to take the square root, then just use the sqrt() function,\nbut if you want an approximation that you perhaps can interleave with other iterations,\nor something of that nature, then using Newtons method could be useful.\n\nExperimentation suggestions:\n\nTry experimenting with the error threshold value and the range of input/guess values.\n\nTry finding a good method of making a fast initial guess.\n    Slightly overestimating the actual square root is a good way according to wikipedia :)\n    For a input value S, an initial guess of \n\n        (S + 1) / 2\n\n    is the same as performing a step of this method from either the value 1 OR S .\n    Check for yourself that this is the case!\n\n*/\n\nconst float error_threshold = 0.001;\nconst float scale = 10.;       // This contols the upper end of the range on the initial_guess and input_value axes\n\nfloat triangle_steps(float t, float max_N, float frequency)\n{\n    // https://www.wolframalpha.com/input?i=plot+floor%282.+*+min%28t+*+0.1%2C+1-t*0.1%29+*+9%29%2C+t+%3D+0+to+10\n    t = fract(t * frequency);\n    float triangle_wave = 2. * min(t, 1.-t);\n    return floor(triangle_wave * (max_N+1.));\n}\n\nfloat babylonian_newton_sqrt_step(float current_guess, float input_value)\n{\n    return .5 * (current_guess + input_value/current_guess);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y; // centered -1 to 1\n\n    float mask = step(-1., uv.x) * step(-1., uv.y) * (1.-step(1., uv.x)) * (1.-step(1., uv.y));\n    \n    uv = (uv + 1.)*.5; // square aspect 0 to 1\n\n    vec3 color = vec3(0);\n\n    float input_value   = uv.x * scale;\n    float current_guess = uv.y * scale;\n    \n    float target = sqrt(input_value);\n    \n    float iterations = 0.;\n    \n    float N = triangle_steps(iTime, 9., 0.05); // Vary the maximum number of iterations (N)\n    float error = 100.;\n    for(float i = 0.; i < N; ++i)\n    {\n        error = abs(current_guess - target);\n        if(error > error_threshold) ++iterations;\n        current_guess = babylonian_newton_sqrt_step(current_guess, input_value);\n    }\n    \n    // Visualize error and iterations taken\n    vec3 background_color = vec3(.95, 0, 0);\n    color = background_color;\n    if(iterations < N)\n    {\n        float normlized_iter = iterations / N;\n        color = mix(background_color, vec3(normlized_iter, (1.-normlized_iter), 0.), (1.-error/error_threshold));\n    }\n    \n    color *= mask;\n    \n    // Max iteration number rendering\n    vec2 text_uv = 3. * (uv - vec2(1., 2./3.));\n    if(text_uv.x > 0. && text_uv.x < 1. && text_uv.y > 0. && text_uv.y < 1.)\n    {\n        color = vec3(texture(iChannel0, text_uv/16. + vec2(0. + N, 12.)/16.).r);\n    }\n    \n    fragColor = vec4(sqrt(color),1.0);\n}","name":"Image","description":"","type":"image"}]}