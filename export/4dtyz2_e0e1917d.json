{"ver":"0.1","info":{"id":"4dtyz2","date":"1519579736","viewed":264,"name":"Fear of the dark","username":"krax","description":"Was going to attempt to put more stuff in this, but legit, my computer is basically running 10fps as it is, so I guess I'll just leave it like this.\nInspired by this: https://www.youtube.com/watch?v=ElbGteGfEfs\nThe movie and song go together well.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["3d","police","bed","sleeping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This is some of the messiest code I've ever written.\n\n// If like me you're computer is a bit of a potato, uncomment the line below.\n// #define POTATO_QUALITY\n\n\n\n#define AO_STEPS 2.0\n#define AO_INTENSITY 5.0\n#define AO_AOI 0.1\n\n#define DOOR_CLOSE_LEN 6.1\n\n// Originally it was going to wait a bit\n// before lighting up, but as it turns out\n// it looks waaaay better if you basically do it\n// as the doors are closing\n#define SLOW_LIGHT_UP_PAUSE -6.1\n#define SLOW_LIGHT_UP_LEN 10.1\n\n#define SLOW_LU_START DOOR_CLOSE_LEN + SLOW_LIGHT_UP_PAUSE\n#define SLOW_LU_END SLOW_LU_START + SLOW_LIGHT_UP_LEN\n\n#define RAY_MARCH_C 64\n#define POLICE_LIGHTS_FREQ 7.\n\n#define HALF_PI 1.57079632679\n\n\n\nfloat random(vec2 co) {\n  return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat opU(float d1, float d2) { return min(d1, d2); }\n\nfloat opS(float d1, float d2) {\n  // For whatever reason max(-d1, d2)\n  // does some weird stuff for me, which\n  // is probably a symptom that I'm doing something\n  // a bit weird\n  return max(0.1 - d1, d2);\n}\n\nfloat opI(float d1, float d2) { return max(d1, d2); }\n\nvec3 opRep(vec3 p, vec3 c) { return mod(p, c) - 0.5 * c; }\n\nfloat sphere(vec3 p, float r) { return length(p) - r; }\n\nfloat plane(vec3 p, vec4 n) { return dot(p, n.xyz) + n.w; }\n\nfloat box(vec3 p, vec3 b) { return length(max(abs(p) - b, 0.0)); }\n\nfloat round_box(vec3 p, vec3 b, float r) {\n  return length(max(abs(p) - b, 0.0)) - r;\n}\n\nvec3 rotateX(vec3 p, float radian) {\n  mat3 m = mat3(1.0, 0.0, 0.0, 0.0, cos(radian), -sin(radian), 0.0, sin(radian),\n                cos(radian));\n  return m * p;\n}\n\nvec3 rotateY(vec3 p, float radian) {\n  mat3 m = mat3(cos(radian), 0.0, sin(radian), 0.0, 1.0, 0.0, -sin(radian), 0.0,\n                cos(radian));\n  return m * p;\n}\n\nvec3 rotateZ(vec3 p, float radian) {\n  mat3 m = mat3(cos(radian), -sin(radian), 0.0, sin(radian), cos(radian), 0.0,\n                0.0, 0.0, 1.0);\n  return m * p;\n}\n\nstruct Camera {\n  vec3 position;\n  vec3 look_at;\n  vec3 up;\n  float focus;\n};\n\nvec3 get_ray_direction(Camera cam, vec2 uv) {\n  // Get the direction the camera is facing, based on what\n  // it's supposed to be looking at\n  vec3 cam_direction = normalize(-(cam.position + cam.look_at));\n  vec3 cam_side = cross(cam_direction, cam.up);\n\n  // Get the normalized ray direction\n  return normalize(\n      vec3(cam_side * uv.x + cam.up * uv.y + cam_direction * cam.focus));\n}\n\nvoid cabinet(const in vec3 p, inout float dist) {\n\n  dist = opU(dist, box(p + vec3(9.3, -1.9, 1.), vec3(1.1, 1.8, 1.75)));\n  dist = opU(dist, sphere(p + vec3(8.2, -1.9, 1.4), 0.1));\n  dist = opU(dist, sphere(p + vec3(8.2, -1.9, 0.8), 0.1));\n  dist = opU(dist, box(p + vec3(8.17, -3.5, 1.), vec3(0.1, 0.05, 1.3)));\n  dist = opU(dist, box(p + vec3(8.17, -3.1, 1.), vec3(0.1, 0.05, 1.3)));\n}\n\nvoid backwall(const in vec3 p, inout float dist) {\n\n  float door_open_amount = pow(smoothstep(DOOR_CLOSE_LEN, 0., iTime), 1.5);\n  float wall = plane(p + vec3(0., 0., -13.), vec4(0., 0.2, -1.0, 0.));\n  wall = opS(plane(p + vec3(0., 0., -14.), vec4(0., 0.2, -1.0, 0.)), wall);\n  wall =\n      opS(box(p + vec3(0., 0., -13.), vec3(door_open_amount, 13., 23.)), wall);\n  dist = opU(dist, wall);\n}\n\nvoid toys(const in vec3 p, inout float dist) {\n\n  dist = opU(dist, sphere(p + vec3(8.3, -.4, -1.), 0.5));\n    \n  dist = opU(dist, sphere(p + vec3(5.3, -.2, -2.), 0.3));\n    \n  vec3 rpA = rotateY(p+vec3(-6, 0.1, -3), 0.6);  \n  dist = opU(dist, box(rpA, vec3(.3,.3,.3)));\n    \n  vec3 rpB = rotateY(p+vec3(-6, -.55, -3), 0.1);  \n  dist = opU(dist, box(rpB, vec3(.3,.3,.3)));\n    \n  vec3 rpC = rotateY(p+vec3(-5, -.1, -2), 0.1);  \n  dist = opU(dist, box(rpC, vec3(.4,.4,.4)));\n  \n}\n\nvoid environment(const in vec3 p, inout float dist) {\n\n  // Create the floor\n  dist = opU(dist, plane(p, vec4(0.01, 1.0, 0.1, 0.0)));\n\n  // Walls\n  dist = opU(dist, plane(p + vec3(11., 0., 0.), vec4(1., 0.15, 0.2, 0.0)));\n  dist = opU(dist, plane(p + vec3(-12.3, 0., 0.), vec4(-1., 0.15, 0.2, 0.0)));\n  dist = opU(dist, plane(p + vec3(0., 0., 9.), vec4(0., 0.2, 1.0, 0.)));\n\n  // Ceiling\n    \n  dist = opU(dist, plane(p + vec3(0., -32, .0), vec4(0.01, -1.0, 0.1, 0.0)));\n  dist = opS(plane(p + vec3(0., -36, .0), vec4(0.01, -1.0, 0.1, 0.0)), dist);\n\n  // Cut out side hollow\n  dist = opS(box(p + vec3(-11., -7, 2.9), vec3(3., 2.0, 2.3)), dist);\n\n  // Cut out window on the left\n  //dist = opS(box(p + vec3(11., -10, 2.9), vec3(3., 5.0, 2.3)), dist);\n  dist = opS(box(p + vec3(11., -13.5, 2.075), vec3(3., 2.525, 0.975)), dist);\n  dist = opS(box(p + vec3(11., -13.5, 4.25), vec3(3., 2.525, 0.975)), dist);\n  dist = opS(box(p + vec3(11., -7.5, 2.075), vec3(3., 2.525, 0.975)), dist);\n  dist = opS(box(p + vec3(11., -7.5, 4.25), vec3(3., 2.525, 0.975)), dist);\n\n  dist = opS(plane(p + vec3(11.5, 0., 1.), vec4(1., 0.15, 0.2, 0.)), dist);\n\n  // Add cabinet\n  cabinet(p, dist);\n\n  // Add toys\n  toys(p, dist);\n\n  // Only bother doing the backwall\n  // if the door hasn't been closed\n  if (iTime < DOOR_CLOSE_LEN) {\n    backwall(p, dist);\n  }\n}\n\nvoid bed_child(const in vec3 p, inout float dist) {\n\n  // Bed base\n  vec3 rp = rotateX(p, 0.23);\n  rp -= vec3(0., 0.1, .0);\n  dist = opU(dist, round_box(rp + vec3(0, -1.6, 5), vec3(3.1, 0.5, 9.), 0.4));\n\n  // Pillow\n  dist = opU(dist, round_box(rp + vec3(0, -3, 8), vec3(1.1, 0.9, 1.), 1.0));\n\n  // Sheet\n  dist = opU(dist, round_box(rotateX(rp, 0.05) + vec3(0, -2.7, 2),\n                             vec3(2.5, 0.05, 6.), .01));\n\n  // Head\n  dist = opU(dist, sphere(rp + vec3(0., -3.3, 6.), 0.7));\n\n  // Hands\n  dist = opU(dist, sphere(rp + vec3(1.4, -3.1, 6.), 0.3));\n  dist = opU(dist, sphere(rp + vec3(-1.4, -3.1, 6.), 0.3));\n}\n\nfloat scene_distance(const in vec3 p) {\n  // Start out by saying everying\n  // is infinitly away\n  float dist = 1. / 0.;\n\n  // Get the environment\n  environment(p, dist);\n  bed_child(p, dist);\n\n  return dist;\n}\n\nvec3 ray_march(const in vec3 start_pos, const in vec3 ray_direction) {\n  // Start off at the cameras position\n  vec3 position = start_pos;\n  // Ray march forward\n  float t = 0.0;\n  for (int i = 0; i < RAY_MARCH_C; ++i) {\n    t += scene_distance(position);\n    position = start_pos + t * ray_direction;\n  }\n  return position;\n}\n\nvec3 get_normal(const in vec3 p) {\n  const float d = 0.0001;\n  return normalize(vec3(scene_distance(p + vec3(d, 0.0, 0.0)) -\n                            scene_distance(p - vec3(d, 0.0, 0.0)),\n                        scene_distance(p + vec3(0.0, d, 0.0)) -\n                            scene_distance(p - vec3(0.0, d, 0.0)),\n                        scene_distance(p + vec3(0.0, 0.0, d)) -\n                            scene_distance(p - vec3(0.0, 0.0, d))));\n}\n\nfloat get_shadow(vec3 light_pos, vec3 p, vec3 light_dir, float light_dist,\n                 float shadow_intensity) {\n  vec3 shadow = ray_march(light_pos, -light_dir);\n  float shadow_distance = distance(light_pos, shadow);\n  // return step(light_dist, shadow_distance);\n  // return smoothstep(0.0, light_dist, shadow_distance);\n  return pow(smoothstep(0.0, light_dist, shadow_distance), shadow_intensity);\n}\n\nvec3 direct_light(vec3 direction, vec3 colour, vec3 normal, float spec_roll,\n                  float spec_intensity) {\n  return colour * (dot(normalize(direction), normal) +\n                   pow(dot(normalize(direction), normal), 1.0 / spec_roll) *\n                       spec_intensity);\n}\n\nvec3 point_light(vec3 light_pos, vec3 colour, vec3 pos, vec3 normal,\n                 float spec_roll, float spec_intensity,\n                 float shadow_intensity) {\n\n  // Just called direct light, but have the direction be\n  // the vector between the objects position and the lights position\n  vec3 direction = normalize(light_pos - pos);\n  vec3 light =\n      direct_light(direction, colour, normal, spec_roll, spec_intensity);\n  light *= get_shadow(light_pos, pos, .5 * direction, distance(light_pos, pos),\n                      shadow_intensity);\n  return max(vec3(0.), light);\n}\n\nvoid do_lighting(vec3 p, vec3 normal, inout vec3 colour) {\n\n  float slow_lightup = 1.;\n\n  if (iTime < SLOW_LU_END) {\n    slow_lightup = max(smoothstep(SLOW_LU_START, SLOW_LU_END, iTime), 0.1);\n  }\n  // Overhead light\n  colour +=\n      point_light(vec3(0., 30., 10), vec3(0.15, 0.2, 0.3) * slow_lightup * 0.8,\n                  p, normal, 1.0, 0.0, 0.5);\n\n  // Moon light\n  colour += point_light(vec3(-100., 80., -50), vec3(0.25, 0.3, 0.35), p, normal,\n                        100.0, 1.0, 100.0);\n\n  // door closing\n  if (iTime <= DOOR_CLOSE_LEN) {\n\n    float moveaway = smoothstep(1., DOOR_CLOSE_LEN, iTime) * 11.;\n    colour +=\n        point_light(vec3(0., 6., 15. + moveaway), vec3(0.5, 0.4, 0.01) * .7, p,\n                    normal, 100.0, 1., 100000.0);\n  } else {\n    // Police\n    colour += point_light(\n        vec3(-20., 2. + sin(iTime - SLOW_LU_END) * 4., sin(iTime * 0.3) * 30.),\n        vec3(max(0., sin(iTime * POLICE_LIGHTS_FREQ)), 0,\n             max(cos(POLICE_LIGHTS_FREQ * iTime + HALF_PI), 0.)),\n        p, normal, 100.0, 0.0, 10000.0);\n  }\n}\n\nfloat ao(vec3 p, vec3 normal) {\n  float occlusion = 0.0;\n  for (float i = 1.; i <= AO_STEPS; i++) {\n    // Distance to to look\n    float dist = (i / AO_STEPS) * AO_AOI;\n    // Direction and distance from the original point\n    vec3 bounced = p + normal * dist;\n    // Add up how far the bouncd point is from another object\n    // But each time we get further away make it's influence\n    // less and less\n    float bounced_dist = scene_distance(bounced);\n    occlusion += (AO_INTENSITY / i) * (dist - bounced_dist);\n  }\n  return clamp(1.0 - occlusion, 0.0, 1.0);\n}\n\nfloat fresnel(vec3 ray_direction, vec3 normal) {\n  return 1.0 + (dot(ray_direction, normal));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n  Camera camera = Camera(vec3(0.0, 1.0, 11.0), // Position\n                         vec3(0., -5.5, 0.),   // Look at\n                         vec3(0.0, 1.0, 0.0),  // Up\n                         1.3                   // FL\n                         );\n\n  // Get the 2d position\n  vec2 uv = (fragCoord.xy * 2. - iResolution.xy) / iResolution.y;\n\n  // Get the ray we're going to be using\n  vec3 ray_direction = get_ray_direction(camera, uv);\n\n  // Get the position and normal\n  vec3 p = ray_march(camera.position, ray_direction);\n  vec3 normal = get_normal(p);\n\n  // Default colour to black\n  vec3 colour = vec3(0.0);\n\n  do_lighting(p, normal, colour);\n\n#ifndef POTATO_QUALITY\n  colour *= ao(p, normal);\n  colour += vec3(0.05, 0.0, 0.01) * fresnel(ray_direction, normal);\n  colour += (random(uv + iTime) * 2. - 1.) * .04;\n#endif\n\n  fragColor = vec4(colour, 1.0);\n}","name":"Image","description":"","type":"image"}]}