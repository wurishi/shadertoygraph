{"ver":"0.1","info":{"id":"4cXcD8","date":"1721048757","viewed":42,"name":"[phreax] algorithmic surrealism","username":"phreax","description":"algorithmic surrealism","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","kifs","surrealism"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 col = texture(iChannel0, uv).rgb;\n    \n    //col *= 1.02;\n    col = pow(col, vec3(.7)); // gamma\n\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/* Creative Commons Licence Attribution-NonCommercial-ShareAlike \n   CC BY-NC-SA 4.0\n   \n   phreax/jiagual 2024\n*/\n\n#define THICKNESS .015\n#define BUMP_EPS 0.004\n\n\nfloat tt, g_mat;\n\nfloat rect( vec2 p, vec2 b, float r ) {\n    vec2 d = abs(p) - (b - r);\n    return length(max(d, 0.)) + min(max(d.x, d.y), 0.) - r;\n}\n\n\nvec3 kalei(vec3 p) {\n    float iter = 2.;\n    p.xy = sabs(p.xy)+.5;\n    p.xz *= rot(.2*2.*PI+.5*tt);\n    p.xy *= rot(.2*2.*PI+.5*tt/PHI);\n\n    p.xy = vec2(length(p.xy)*.9, atan(p.y, p.x));\n\n\n    float s= 1.;\n    for(float i=0.; i< iter; i++) {\n        p = sabs(p);  \n       p.xz *= rot(i/iter*PI*2.*PI*.3);\n        p.xz += .5 - .1*i + sin(p.y*.2) + .2*exp(.01+p.z*.2);\n        p.z -= .3*sin(p.z*.3*i/iter*2.*PI);\n   \n        p -= .6;\n         \n    }\n\n    return clamp(p, -1e5, 1e5);\n\n}\n\n\n// fold space for toroid\nvec3 transform(vec3 p) {\n\n    p.xy *= rot(PI*.5);\n\n\n    float r = 2.;\n    vec2 cp = vec2(length(p.xz)-r, p.y);\n    \n\n    float rev = 2.5;\n    float a = atan(p.z, p.x);\n    \n \n    cp *= rot(rev*a-.8*tt);\n    cp= abs(cp) - .04;\n    cp *= rot(0.1);\n\n\n    return vec3(cp, p.z);\n}\n\n\nfloat spiral(vec3 p) {   \n  \n    vec3 bp = p;\n    \n    float s = .6;\n    p.y *= 1.5;\n    p.xy = p.yx;\n    p *= s;\n        //p.yz *= rot(tt);\n    float dir = sign(p.y);\n    p.y = -abs(p.y);\n    \n    \n    p.y += PI/2.;\n    \n    p.yz *= rot(PI*.5);\n    \n    p.xy *= rot(tt);\n    \n    float r = smoothstep(-2., 1.5, p.z*.9);\n    \n    //if(p.z> - PI/2.) p.xy *= .6;\n    float d = max(abs(p.z)-2.,length(p.xy) - mix(0., PHI, r)); // bounding cylinder\n    d = max(d, abs(sin(dir*atan(p.y,p.x)-p.z*4.))  * min(1.,length(p.xy)) - .02);\n    \n    \n    p.xy *= rot(PI*.5+1./PHI*tt);\n    \n    float d2 = max(abs(p.z)-2.,length(p.xy) - mix(0., PHI+.4*SIN(tt), r)); // bounding cylinder\n    d2 = max(d2, abs(sin(dir*atan(p.y,p.x)-p.z*4.))  * min(1.,length(p.xy)) - mix(.02, .4, SIN(tt)));\n    \n    d = min(d, d2);\n    return .5*d/s;\n}\n\nfloat moebius(vec3 p){\n    float edge = 0.01;\n\n    p.x = sabsk(p.x, .1) - .5- 2.5*SIN(.6*tt);\n    p.x = sabsk(p.x, .1) - .4 -2.5*SIN(.6*tt);\n    // p = kalei(p);\n    float s = .9;\n    p *= s;\n    vec2 cp = transform(p).xy;\n\n    float d = rect(cp.xy, vec2(.7, THICKNESS), edge);\n\n    return d/s;\n}\n\nfloat map(vec3 p) {   \n  \n    vec3 bp = p;\n    \n    p = kalei(p);\n   \n    float dr = moebius(p) * .6;\n\n    float d = spiral(p);   \n    g_mat = 0.;\n    \n    if(d <= dr) {\n        g_mat = 1.;  \n    }\n    \n    d = smin(d, dr, .04);\n    \n    return d;\n}\n\n\nvec3 getNormal(vec3 p) {\n\n    vec2 eps = vec2(0.001, 0.0);\n    return normalize(vec3(map(p + eps.xyy) - map(p - eps.xyy),\n                          map(p + eps.yxy) - map(p - eps.yxy),\n                          map(p + eps.yyx) - map(p - eps.yyx)\n                         )\n                     );\n}\n\nfloat bumpSurf3D( in vec3 p){\n\n    p.z += .3*tt;\n    p = abs(mod(p*2., 2.*0.125)-0.0125);\n    \n    float x = min(p.x,min(p.z, p.y))/0.03125;\n\n    return clamp(x, 0., 1.);\n\n\n}\n\n// Standard function-based bump mapping function (from Shane)\nvec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor){\n    \n    const float eps = BUMP_EPS;\n    float ref = bumpSurf3D(p);                 \n    vec3 grad = vec3( bumpSurf3D(vec3(p.x-eps, p.y, p.z))-ref,\n                      bumpSurf3D(vec3(p.x, p.y-eps, p.z))-ref,\n                      bumpSurf3D(vec3(p.x, p.y, p.z-eps))-ref )/eps;                     \n          \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + bumpfactor*grad );\n\t\n}\n\nvec2 raymarch(vec3 ro, vec3 rd, float steps) {\n\n    float mat = 0.,\n          t   = 0.,\n          d   = 0.;\n    vec3 p = ro;\n    for(float i=.0; i<steps; i++) {\n    \n        d = map(p);\n        mat = g_mat;  // save global material\n        \n        if(abs(d) < 0.0001 || t > 100.) break;\n        \n        t += d;\n        p += rd*d;\n    }\n    \n    return vec2(t, mat);\n}\n\nfloat n21(vec2 p) {\n      return fract(sin(dot(p, vec2(524.423,123.34)))*3228324.345);\n}\n\nfloat noise(vec2 n) {\n    const vec2 d = vec2(0., 1.0);\n    vec2 b = floor(n);\n    vec2 f = mix(vec2(0.0), vec2(1.0), fract(n));\n    return mix(mix(n21(b), n21(b + d.yx), f.x), mix(n21(b + d.xy), n21(b + d.yy), f.x), f.y);\n}\n\n\nvec3 doColorize(int pal, vec3 col, float range, float offset) {\n\n    vec3 hsl = rgb2hsl(col);\n    \n    \n    return getColorRamp(pal, hsl.z*range+offset)*hsl.z;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n    vec3 tot = vec3(0);\n\n   \tvec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n\n    uv = uv.yx;\n    tt = iTime + 17.;\n    vec3 ro = vec3(uv*9.,-4.),\n          rd = vec3(0,0,.6),\n          lp = vec3(2., 2., -10),\n          lp2 = vec3(-2., -3., -5);\n\n    vec3 col;\n       \n    float mat = 0.,\n          t   = 0.,\n          d   = 0.;\n \n\n    vec2 e = vec2(0.0035, -0.0035);\n     \n    // background color\n    vec3 c1 = vec3(0.000,1.000,0.835);\n    vec3 c2 = vec3(1.000,0.494,0.078);\n    \n    // light color\n    vec3 lc1 = vec3(0.961,0.816,0.737);\n    vec3 lc2 = vec3(0.588,0.992,0.945);\n    \n    \n    // currently only one pass\n    for(float i = 0.; i < 1.; i++) {\n        float steps = i > 0. ? 50. : 250.;\n        vec2 rm = raymarch(ro, rd, steps);\n        mat = rm.y;\n        \n        vec3 p = ro + rm.x*rd;\n        \n        vec3 n = normalize( e.xyy*map(p+e.xyy) + e.yyx*map(p+e.yyx) +\n                                e.yxy*map(p+e.yxy) + e.xxx*map(p+e.xxx));\n\n        vec3 pt = transform(p);\n        vec3 np = transform(n);\n        n = doBumpMap(p, n, .001);\n\n    \n        if(rm.x < 50.) {\n        \n            vec3 l = normalize(lp-p);\n            vec3 l2 = normalize(lp2-p);\n            float dif = max(dot(n, l), .0);\n            float dif2 = max(dot(n, l), .0);\n            float spe = pow(max(dot(reflect(-rd, n), -l), .0),40.);\n\n            float sss = smoothstep(0., 1., map(p + l * .4)) / .4;\n            vec3 n2 = n;\n            n2.xy += noise(p.xy) * .5 - .025;\n            n2 = normalize(n2);\n            float height = atan(n2.y, n2.x);\n\n\n            col += dif*lc1*.6 + .8*dif2*lc2;\n            col *= .5;\n            \n        \n            int pal = 2;\n            \n            float col_off = .7;\n            if(mat <= 0.) {\n                pal = 1;\n                col_off = -.3;\n            }\n            \n            col = mix(col, getColorRamp(pal, (SIN(n2.y*.7-col_off))), 1.)*dif + spe;\n           \n            if(mat == 0.) {\n                n += .5*texture(iChannel1, n.xy*100.).rgb;\n                rd = reflect(rd, n);\n         \n                vec3 refl = texture(iChannel0, rd).rgb;\n                \n                refl *= mix(vec3(1), getColorRamp(pal, (SIN(rd.x*1.5))), 1.); // reflect rainbows too\n                col = mix(col, refl, .3);\n                \n                float height = atan(n.y, n.x);\n              \n            } \n\n        } else {\n            col =  mix(c1-.5, c2, (.9-pow(dot(uv, uv), .3)))*.2+.7; // background\n            \n        } \n    \n    }\n\n    \n    col *= mix(.2, 1., (1.5-pow(dot(uv, uv), .5))); // vignette\n    \n    tot += col;\n    \n    \n    vec3 previousColor = texture(iChannel1, ((fragCoord - .5 * iResolution.xy) * .98 / iResolution.xy + 0.5)).rgb;\n\n\n    fragColor = vec4(tot, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n#define PI 3.141592\n#define TAU (2.*PI)\n#define SIN(x) (sin(x)*.5+.5)\n#define PHI 1.618033988749895\n\n\n#define sabsk(x, k) sqrt(x * x + k * k)\n#define sabs(x) (sabsk(x, .01))\n#define COPY_COLOR(N, colorsK)  for(int i = 0; i < N; i++) { colors[i] = colorsK[i]; }\n\nvec3 rgb2hsl(vec3 color) {\n    float r = color.r;\n    float g = color.g;\n    float b = color.b;\n    float max = max(max(r, g), b);\n    float min = min(min(r, g), b);\n    float h, s, l;\n    l = (max + min) / 2.0;\n\n    if (max == min) {\n        h = s = 0.0; // achromatic\n    } else {\n        float d = max - min;\n        s = l > 0.5 ? d / (2.0 - max - min) : d / (max + min);\n        if (max == r) {\n            h = (g - b) / d + (g < b ? 6.0 : 0.0);\n        } else if (max == g) {\n            h = (b - r) / d + 2.0;\n        } else if (max == b) {\n            h = (r - g) / d + 4.0;\n        }\n        h /= 6.0;\n    }\n    return vec3(h, s, l);\n}\n\n\nconst vec3 colors1[] = vec3[](\n    vec3(27, 231, 255) / 255.0, // Electric blue\n    vec3(110, 235, 131) / 255.0, // Light green\n    vec3(228, 255, 26) / 255.0, // Lemon Lime\n    vec3(255, 184, 0) / 255.0, // Selective yellow\n    vec3(255, 87, 20) / 255.0 // Giants orange\n);\n\nconst vec3 colors2[] = vec3[](\n    vec3(0, 204, 255) / 255.0, // Vivid sky blue\n    vec3(0, 255, 204) / 255.0, // Aquamarine\n    vec3(255, 255, 0) / 255.0, // Yellow\n    vec3(255, 0, 204) / 255.0, // Hot magenta\n    vec3(204, 0, 255) / 255.0 // Electric purple\n);\n\n\nconst vec3 colors3[] = vec3[](\n    vec3(237, 174, 73) / 255.0, // Hunyadi yellow\n    vec3(209, 73, 91) / 255.0, // Amaranth\n    vec3(0, 121, 140) / 255.0, // Caribbean Current\n    vec3(48, 99, 142) / 255.0, // Lapis Lazuli\n    vec3(0, 61, 91) / 255.0 // Indigo dye\n);\n\n\n\n// Allow up to 10 colors per palette\nvec3 getColorRamp_(vec3 cols[10], int N, float x ) {\n    // Calculate adjusted length to ensure end color is reachable within [0, 1]\n    float len = float(N);\n    \n    // Scale x according to the adjusted length and apply modulo for wrapping\n    float scaledX = mod(x * (len-1.), len);\n    \n    // Calculate indices. Ensure index2 wraps around to the start if necessary\n    int index1 = int(scaledX);\n    int index2 = index1 + 1;\n    if (index2 >= cols.length()) {\n        index2 = 0; // Wrap to the start to close the loop\n    }\n    \n    // Calculate the fraction between the two indices for smooth interpolation\n    float frac = fract(scaledX);\n    \n    // Interpolate between the two selected colors\n    return mix(cols[index1], cols[index2], smoothstep(0.0, .9, frac));\n}\n\nvec3 getColorRamp(int palette, float x) {\n\n    vec3 colors[10];\n    int len;\n    \n    if(palette == 1) {\n        len = colors1.length();\n        COPY_COLOR(len, colors1);    \n    }\n    \n    if(palette == 2) {\n        len = colors2.length();\n        COPY_COLOR(len, colors2);    \n    }\n    \n    if(palette == 3) {\n        len = colors3.length();\n        COPY_COLOR(len, colors3);    \n    }\n  \n  \n    return getColorRamp_(colors, len, x);\n\n}\n\nmat2 rot(float a) { return mat2(cos(a), -sin(a), sin(a), cos(a)); }\n\n\n// zucconis spectral palette https://www.alanzucconi.com/2017/07/15/improving-the-rainbow-2/\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n    vec3 y = 1. - x * x;\n    y = clamp((y-yoffset), vec3(0), vec3(1));\n    return y;\n}\n\n\nvec3 spectral_zucconi6(float x) {\n    x = fract(x);\n    const vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n    const vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n    const vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n    const vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n    const vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n    const vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n    return bump3y(c1 * (x - x1), y1) + bump3y(c2 * (x - x2), y2) ;\n}\n\nfloat smin(float a, float b, float k) {\n  float h = clamp((a-b)/k * .5 + .5, 0.0, 1.0);\n  return mix(a, b, h) - h*(1.-h)*k;\n}\n","name":"Common","description":"","type":"common"}]}