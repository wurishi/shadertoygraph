{"ver":"0.1","info":{"id":"DlcGRH","date":"1681909939","viewed":1794,"name":"LEGO Cyberpunk","username":"Mathis","description":"Max viewport resolution 2048x2048.\nThe wood texture is used for the floor, so it might not load immediately.\n\nMultibounce diffuse ReSTIR GI with subsurface scattering... and LEGO!\nSee Image for controls.","likes":81,"published":1,"flags":48,"usePreview":1,"tags":["gi","global","illumination","scattering","subsurface","lego","restir"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nThe car was first built IRL and then in shadertoy\n    97 bricks total for the real thing\n    Only selected bricks are used in order to fit them inside the chosen voxel resolution\n        For example: the tire rim connector brick is not modeled since it is essentially hidden\n        Some interiors of bricks are ignored cuz they will never be seen\n    \nLighting\n    ReSTIR GI for diffuse lighting\n        Temporal\n            Screen space multibounce sampling to increase performance and reduce compilation time\n                Because of this, sample validation can't be used\n        Spatial\n            No hitnormal for connection shift map -> no jacobian\n            Screen space visibility is used\n    Reflections\n        Only emissive surfaces contribute\n    LOGO\n        Saved enough pixels for it this time (512x512)\n\nSubsurface scattering\n    Definitely boosted too much to be realistic, but that's cool\n    Ray marcher with an exponential stepsize for scattering inside SDF\n    An Ã€trous denoiser is used\n        No information about scattering -> only G-Buffer info is used\n\nRendering\n    Combination of LEGO Creator 5891 and LEGO Denoising\n        Grid acceleration structure for the car\n            Dimensions: 13x5.4x6\n        Volumetric SDF approximation for individual bricks\n            32^3 in a 1x0.8x1 voxel -> higher resolution in Y axis\n            Stored in a 1024x1536 buffer in the cubemap\n    Fullscreen\n        Somehow the content in cubemap changes when this happens and\n        some SDF-volumes are changed slightly, giving weird normals\n\nTAA\n    Added a depth-based min/max geometry test to reduce ghosting on top of color clamping\n\n\n\n\nControls:\n    WASD to move around\n    Mouse to rotate the camera\n    Hold space while moving to increase speed\n*/\n\nvec3 acesFilm(vec3 x) {\n    //Aces film curve\n    return clamp((x*(2.51*x+0.03))/(x*(2.43*x+0.59)+0.14),0.,1.);\n}\n\nvec4 textureCube(vec2 UV) {\n    //Samples the cubemap\n    float Sign = -mod(floor(UV.y*I1024),2.)*2.+1.;\n    vec3 D = vec3(vec2(UV.x,mod(UV.y,1024.))*I512-1.,Sign);\n    if (UV.y>4096.) D = D.xzy;\n    else if (UV.y>2048.) D = D.zxy;\n    return texture(iChannel3,D);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float YOffset = 2048.+floor(fragCoord.x*I1024)*1024.+floor(fragCoord.y*I1024)*2048.;\n    vec3 Color = textureCube(mod(fragCoord,1024.)+vec2(0.,YOffset)).xyz;\n    \n    \n    \n    //\n    //Bloom\n    //\n    vec4 Bloom = vec4(0.);\n    for (float x=-2.; x<2.5; x+=1.) {\n        for (float y=-2.; y<2.5; y+=1.) {\n            vec2 SUV = fragCoord+vec2(x,y);\n            float SYOffset = 2048.+floor(SUV.x*I1024)*1024.+floor(SUV.y*I1024)*2048.;\n            vec3 SC = textureCube(mod(SUV,1024.)+vec2(0.,SYOffset)).xyz;\n            float SW = float(max(SC.x,max(SC.y,SC.z))>1.95)*exp(-(x*x+y*y)*0.5);\n            Bloom += vec4(SC*SW,SW);\n        }\n    }\n    Color += Bloom.xyz/max(1.,Bloom.w);\n    \n    \n    \n    //\n    //Output\n    //\n    fragColor = vec4(pow(acesFilm(max(vec3(0.),Color)),vec3(0.45)),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Storage, primary rays and secondary rays\n\nvec4 textureCube(vec2 UV) {\n    //Samples the cubemap\n    float Sign = -mod(floor(UV.y*I1024),2.)*2.+1.;\n    vec3 D = vec3(vec2(UV.x,mod(UV.y,1024.))*I512-1.,Sign);\n    if (UV.y>4096.) D = D.xzy;\n    else if (UV.y>2048.) D = D.zxy;\n    return texture(iChannel3,D);\n}\n\nfloat VSDF0(vec3 p, vec2 UVOffset, vec2 UVDim) {\n    //Sample a volume SDF, p assumed to be inside the brick AABB\n    vec2 UV = vec2(mod(p.x*31.+0.5+floor(p.y*38.75)*UVDim.x,1024.),p.z*31.+0.5+floor(p.y*38.75*UVDim.x*I1024)*UVDim.y);\n    vec2 TEX = textureCube(UVOffset+UV).xy;\n    return mix(TEX.x,TEX.y,fract(p.y*38.75));\n}\n\nfloat VSDF1(vec3 p, vec2 UVOffset, vec2 UVDim) {\n    //Sample a volume SDF, p assumed to be inside the brick AABB\n    vec2 UV = vec2(mod(p.x*31.+0.5+floor(p.y*38.75)*UVDim.x,1024.),p.z*31.+0.5+floor(p.y*38.75*UVDim.x*I1024)*UVDim.y);\n    vec2 TEX = textureCube(UVOffset+UV).zw;\n    return mix(TEX.x,TEX.y,fract(p.y*38.75));\n}\n\nHIT Trace(vec3 P, vec3 D, float Time) {\n    HIT OUT = HIT(1000000000.,vec3(-1.),vec3(-1.),-1);\n    vec3 ID = 1./D;\n    \n    //Ground\n    if (D.y<0.) {\n        float planet = -(P.y-0.06)/D.y;\n        vec3 planep = P+D*planet;\n        if (length(planep.xz-vec2(6.5,3.))<15.) {\n            OUT.D = planet;\n            OUT.C = vec3(0.7,0.35,0.);\n            OUT.N = vec3(0.,1.,0.);\n            OUT.M = 1;\n        }\n    }\n    \n    \n    //Car volume\n    vec2 Carbb = ABox(P,ID,vec3(0.,0.,0.),vec3(13.,0.4*16.,6.));\n    float CarDF = DFBox(P-vec3(0.,0.,0.),vec3(13.,0.4*16.,6.));\n    if (CarDF<0. || (Carbb.x>0. && Carbb.y>Carbb.x && Carbb.x<OUT.D)) {\n        float CarFAR = min(Carbb.y,OUT.D);\n        float Cart = ((CarDF<0.)?0.:Carbb.x+0.0001);\n        vec3 sp = P+D*Cart; vec3 fp;\n        bool HitFound = false;\n        //Traversal\n        fp = floor(vec3(sp.x,sp.y*2.5,sp.z))*vec3(1.,0.4,1.);\n        for (int b=0; b<32; b++) {\n            if (HitFound || Cart>CarFAR) break;\n            sp = P+D*Cart;\n            vec4 CarVoxel = textureCube(vec2(512.5+fp.x+fp.y*2.5*13.,1536.5+fp.z));\n            float VFar = ABoxfar(P,ID,fp,fp+vec3(1.,0.4,1.));\n            for (int PixelIndex=0; PixelIndex<4; PixelIndex++) {\n                float CarV = CarVoxel[PixelIndex];\n                if (CarV>-0.5) {\n                    //Voxel contains at least one brick\n                    float CBrickIndex = floor(CarV);\n                    vec4 CBrick0 = textureCube(vec2(512.5+CBrickIndex,1542.5));\n                    vec4 CBrick1 = textureCube(vec2(512.5+CBrickIndex,1543.5));\n                    int BrickTypeIndex = int(floor(CBrick0.w));\n                    BRICKTYPE CBrickType = BrickTypes[BrickTypeIndex];\n                    vec2 BrickUVOffset = vec2(0.,CBrickType.UVOffset);\n                    vec2 BrickUVDim = CBrickType.UVDim;\n                    vec3 BrickDim = CBrickType.BrickDim;\n                    //Rotation\n                    vec3 CX = CBrick1.xyz;\n                    vec2 sincos = vec2(sin(CBrick1.w),cos(CBrick1.w));\n                    vec3 RefCZ = normalize(cross(CX,vec3(0.,1.,0.)));\n                    vec3 RefCY = cross(RefCZ,CX);\n                    vec3 CY = sincos.y*RefCY+sincos.x*RefCZ;\n                    vec3 CZ = -sincos.x*RefCY+sincos.y*RefCZ;\n                    vec3 BRPos = P-CBrick0.xyz;\n                    BRPos = BRPos.x*vec3(CX.x,CY.x,CZ.x)+BRPos.y*vec3(CX.y,CY.y,CZ.y)+BRPos.z*vec3(CX.z,CY.z,CZ.z);\n                    vec3 BRDir = D.x*vec3(CX.x,CY.x,CZ.x)+D.y*vec3(CX.y,CY.y,CZ.y)+D.z*vec3(CX.z,CY.z,CZ.z);\n                    vec2 tmpbb = ABox(BRPos,1./BRDir,vec3(0.),BrickDim);\n                    if (DFBox(BRPos,BrickDim)>0. && (tmpbb.x<0. || tmpbb.x>tmpbb.y)) continue;\n                    float tmpCart = ((tmpbb.x<0. || tmpbb.x>tmpbb.y)?Cart:max(Cart,tmpbb.x+0.0001));\n                    float tmpVFar = min(VFar,tmpbb.y);\n                    BRPos = P+D*tmpCart-CBrick0.xyz;\n                    BRPos = BRPos.x*vec3(CX.x,CY.x,CZ.x)+BRPos.y*vec3(CX.y,CY.y,CZ.y)+BRPos.z*vec3(CX.z,CY.z,CZ.z);\n                    \n                    float Sample;\n                    if (BrickTypeIndex<12) {\n                        for (int i=0; i<256; i++) {\n                            Sample = max(DFBox(BRPos,BrickDim),VSDF0(BRPos,BrickUVOffset,BrickUVDim));\n                            tmpCart += Sample;\n                            BRPos += BRDir*Sample;\n                            if (min(Sample-0.002,tmpVFar-tmpCart)<0.) break;\n                        }\n                    } else {\n                        for (int i=0; i<256; i++) {\n                            Sample = max(DFBox(BRPos,BrickDim),VSDF1(BRPos,BrickUVOffset,BrickUVDim));\n                            tmpCart += Sample;\n                            BRPos += BRDir*Sample;\n                            if (min(Sample-0.002,tmpVFar-tmpCart)<0.) break;\n                        }\n                    }\n                    if (Sample<0.002 && tmpCart<min(tmpVFar,OUT.D)) {\n                        //Hit\n                        vec4 CBrick2 = textureCube(vec2(512.5+CBrickIndex,1544.5));\n                        OUT.D = tmpCart;\n                        OUT.C = CBrick2.xyz;\n                        //Stud\n                        vec3 CStudInfo = StudInfo[BrickTypeIndex];\n                        if (DFBox(BRPos-vec3(0.,CStudInfo.y,0.),vec3(CStudInfo.x,100.,CStudInfo.z))<0.) {\n                            //Stud normal\n                            OUT.N = normalize(textureCube(vec2((1.-fract(BRPos.z))*512.,1536.+fract(BRPos.x)*512.)).xyz);\n                            OUT.N = -OUT.N.z*CZ+OUT.N.y*CY+OUT.N.x*CX;\n                        } else {\n                            //SDF normal\n                            if (BrickTypeIndex<12) {\n                                OUT.N = normalize(vec3(VSDF0(vec3(min(BRPos.x+eps.x,BrickDim.x),BRPos.yz),BrickUVOffset,BrickUVDim)-\n                                                       VSDF0(vec3(max(BRPos.x-eps.x,0.),BRPos.yz),BrickUVOffset,BrickUVDim),\n                                                       VSDF0(vec3(BRPos.x,min(BRPos.y+eps.x,BrickDim.y),BRPos.z),BrickUVOffset,BrickUVDim)-\n                                                       VSDF0(vec3(BRPos.x,max(BRPos.y-eps.x,0.),BRPos.z),BrickUVOffset,BrickUVDim),\n                                                       VSDF0(vec3(BRPos.xy,min(BRPos.z+eps.x,BrickDim.z)),BrickUVOffset,BrickUVDim)-\n                                                       VSDF0(vec3(BRPos.xy,max(BRPos.z-eps.x,0.)),BrickUVOffset,BrickUVDim)));\n                            } else {\n                                OUT.N = normalize(vec3(VSDF1(vec3(min(BRPos.x+eps.x,BrickDim.x),BRPos.yz),BrickUVOffset,BrickUVDim)-\n                                                       VSDF1(vec3(max(BRPos.x-eps.x,0.),BRPos.yz),BrickUVOffset,BrickUVDim),\n                                                       VSDF1(vec3(BRPos.x,min(BRPos.y+eps.x,BrickDim.y),BRPos.z),BrickUVOffset,BrickUVDim)-\n                                                       VSDF1(vec3(BRPos.x,max(BRPos.y-eps.x,0.),BRPos.z),BrickUVOffset,BrickUVDim),\n                                                       VSDF1(vec3(BRPos.xy,min(BRPos.z+eps.x,BrickDim.z)),BrickUVOffset,BrickUVDim)-\n                                                       VSDF1(vec3(BRPos.xy,max(BRPos.z-eps.x,0.)),BrickUVOffset,BrickUVDim)));\n                            }\n                            OUT.N = OUT.N.x*CX+OUT.N.y*CY+OUT.N.z*CZ;\n                        }\n                        OUT.M = int(floor(CBrick2.w));\n                        HitFound = true;\n                    }\n                } else break;\n            }\n            Cart = VFar;\n            fp += ABoxfarNormal(P,ID,fp,fp+vec3(1.,0.4,1.))*vec3(1.,0.4,1.);\n        }\n    }\n    \n    //Return\n    return OUT;\n}\n\nbool Inside(vec3 P) {\n    //Is inside geometry\n    \n    //Car volume\n    float CarDF = DFBox(P-vec3(0.,0.,0.),vec3(13.,0.4*16.,6.));\n    if (CarDF<0.) {\n        vec3 fp = floor(vec3(P.x,P.y*2.5,P.z))*vec3(1.,0.4,1.);\n        vec4 CarVoxel = textureCube(vec2(512.5+fp.x+fp.y*2.5*13.,1536.5+fp.z));\n        for (int PixelIndex=0; PixelIndex<4; PixelIndex++) {\n            float CarV = CarVoxel[PixelIndex];\n            if (CarV>-0.5) {\n                //Voxel contains at least one brick\n                float CBrickIndex = floor(CarV);\n                vec4 CBrick0 = textureCube(vec2(512.5+CBrickIndex,1542.5));\n                vec4 CBrick1 = textureCube(vec2(512.5+CBrickIndex,1543.5));\n                int BrickTypeIndex = int(floor(CBrick0.w));\n                BRICKTYPE CBrickType = BrickTypes[BrickTypeIndex];\n                vec2 BrickUVOffset = vec2(0.,CBrickType.UVOffset);\n                vec2 BrickUVDim = CBrickType.UVDim;\n                vec3 BrickDim = CBrickType.BrickDim;\n                //Rotation\n                vec3 CX = CBrick1.xyz;\n                vec2 sincos = vec2(sin(CBrick1.w),cos(CBrick1.w));\n                vec3 RefCZ = normalize(cross(CX,vec3(0.,1.,0.)));\n                vec3 RefCY = cross(RefCZ,CX);\n                vec3 CY = sincos.y*RefCY+sincos.x*RefCZ;\n                vec3 CZ = -sincos.x*RefCY+sincos.y*RefCZ;\n                vec3 BRPos = P-CBrick0.xyz;\n                BRPos = BRPos.x*vec3(CX.x,CY.x,CZ.x)+BRPos.y*vec3(CX.y,CY.y,CZ.y)+BRPos.z*vec3(CX.z,CY.z,CZ.z);\n                if (DFBox(BRPos,BrickDim)>0.) continue;\n                //Sample SDF\n                float Sample = max(DFBox(BRPos,BrickDim),VSDF0(BRPos,BrickUVOffset,BrickUVDim));\n                if (Sample<0.) return true;\n            }\n        }\n    }\n    //Return\n    return false;\n}\n\nvoid UpdateMouse(inout vec4 Output, vec4 Mouse) {\n    //Updates the mouse\n    if (Mouse.z>0.) {\n        if (Output.w==0.) {\n            Output.w = 1.;\n            Output.xy = Mouse.zw;\n        }\n    } else Output.w = 0.;\n}\n\nvoid UpdateEye(inout vec4 Output, vec4 CMouse, vec4 Mouse) {\n    //Updates the eye vector\n    if (CMouse.w==0.)  Output.zw = Output.xy;\n    if (CMouse.w==1.) {\n        //Y led\n        Output.x = Output.z+(Mouse.y-CMouse.y)*IRES.y*5.;\n        Output.x = clamp(Output.x,-2.8*0.5,2.8*0.5);\n        //X led\n        Output.y = Output.w-(Mouse.x-CMouse.x)*IRES.x*10.;\n        Output.y = mod(Output.y,3.1415926*2.);\n    }\n}\n\nvec3 APositions[5] = vec3[5](\n    vec3(16.5,8.5,-5.5),\n    vec3(-4.05,3.35,-7.05),\n    vec3(3.45,4.45,3.05),\n    vec3(8.6,5.5,15.05),\n    vec3(16.5,8.5,-5.5)\n);\n\nvec2 AEyes[5] = vec2[5](\n    vec2(-0.5,-0.78),\n    vec2(0.,0.8),\n    vec2(-0.25,1.57),\n    vec2(-0.3,3.14),\n    vec2(-0.5,6.283-0.78)\n);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 Output = texture(iChannel0,fragCoord.xy*IRES);\n    if (iFrame==0) {\n        //Initialization\n        if (fragCoord.x<10. && fragCoord.y<1.) { //Store vars\n            if (fragCoord.x<1.) Output = vec4(0.,0.,0.,0.); //Mouse\n            else if (fragCoord.x<2.) Output = vec4(-0.5,-0.78,0.,0.); //Player Eye (Angles)\n            else if (fragCoord.x<3.) Output = vec4(0.,0.,0.,1.); //Player Eye (Vector)\n            else if (fragCoord.x<4.) Output = vec4(16.5,8.5,-5.5,1.); //Player Pos\n            else if (fragCoord.x<5.) Output = vec4(0.5,-2.,0.,0.); //Sun angles\n            else if (fragCoord.x<6.) Output = vec4(0.,0.,0.,0.); //Sun direction\n            else if (fragCoord.x<9.) Output = vec4(0.,0.,0.,0.); //Animation time\n        }\n    } else {\n        //Update\n\t\tif (fragCoord.x<16. && fragCoord.y<1.) {\n            //Update vars\n            if (fragCoord.x<1.) { //Mouse\n                UpdateMouse(Output,iMouse);\n            } else if (fragCoord.x<2.) {\n                //Player Eye (Angles)\n                float ATime = texture(iChannel0,vec2(8.5,0.5)*IRES).x+iTimeDelta;\n                if (iFrame>8 && ATime<16.) {\n                    //Animated movement\n                    int LPosIndex = int(floor(ATime*0.25));\n                    vec2 e0 = AEyes[LPosIndex];\n                    vec2 e1 = AEyes[LPosIndex+1];\n                    float x = max(0.,mod(ATime,4.)-2.)*0.5;\n                    Output.xy = mix(e0,e1,x*x*(3.-2.*x));\n                } else if (iFrame>7) {\n                    //Free movement\n                    vec4 CMouse = texture(iChannel0,vec2(0.5,0.5)*IRES);\n                    UpdateMouse(CMouse,iMouse);\n                    UpdateEye(Output,CMouse,iMouse);\n                }\n            } else if (fragCoord.x<3.) {\n                //Player Eye (Vector)\n                float ATime = texture(iChannel0,vec2(8.5,0.5)*IRES).x+iTimeDelta;\n                if (iFrame>8 && ATime<16.) {\n                    //Animated movement\n                    int LPosIndex = int(floor(ATime*0.25));\n                    vec2 e0 = AEyes[LPosIndex];\n                    vec2 e1 = AEyes[LPosIndex+1];\n                    float x = max(0.,mod(ATime,4.)-2.)*0.5;\n                    e0 = mix(e0,e1,x*x*(3.-2.*x));\n                    Output.xyz = normalize(vec3(cos(e0.x)*sin(e0.y),sin(e0.x),cos(e0.x)*cos(e0.y)));\n                } else if (iFrame>7) {\n                    //Free movement\n                    vec4 A4 = texture(iChannel0,vec2(1.5,0.5)*IRES);\n                    vec4 CMouse = texture(iChannel0,vec2(0.5,0.5)*IRES);\n                    UpdateMouse(CMouse,iMouse);\n                    UpdateEye(A4,CMouse,iMouse);\n                    Output.xyz = normalize(vec3(cos(A4.x)*sin(A4.y),sin(A4.x),cos(A4.x)*cos(A4.y)));\n                }\n            } else if (fragCoord.x<4.) {\n                //Player Pos\n                float ATime = texture(iChannel0,vec2(8.5,0.5)*IRES).x+iTimeDelta;\n                if (iFrame>8 && ATime<16.) {\n                    //Animated movement\n                    int LPosIndex = int(floor(ATime*0.25));\n                    vec3 p0 = APositions[LPosIndex];\n                    vec3 p1 = APositions[LPosIndex+1];\n                    float x = max(0.,mod(ATime,4.)-2.)*0.5;\n                    Output.xyz = mix(p0,p1,x*x*(3.-2.*x));\n                } else if (iFrame>8) {\n                    //Free movement\n                    float Speed = iTimeDelta;\n                    if (texelFetch(iChannel1,ivec2(32,0),0).x>0.) Speed = 8.*iTimeDelta;\n                    //Update eye\n                    vec4 CMouse = texture(iChannel0,vec2(0.5,0.5)*IRES);\n                    UpdateMouse(CMouse,iMouse);\n                    vec4 Eye4 = texture(iChannel0,vec2(1.5,0.5)*IRES);\n                    UpdateEye(Eye4,CMouse,iMouse);\n                    vec3 Eye = normalize(vec3(cos(Eye4.x)*sin(Eye4.y),sin(Eye4.x),cos(Eye4.x)*cos(Eye4.y)));\n                    vec3 Tan = normalize(cross(vec3(Eye.x,0.,Eye.z),vec3(0.,1.,0.)));\n                    //Next position\n                    vec3 NPos = Output.xyz;\n                    if (texelFetch(iChannel1,ivec2(87,0),0).x>0.) NPos += Eye*Speed; //W\n                    if (texelFetch(iChannel1,ivec2(83,0),0).x>0.) NPos += -Eye*Speed; //S\n                    if (texelFetch(iChannel1,ivec2(65,0),0).x>0.) NPos += -Tan*Speed; //A\n                    if (texelFetch(iChannel1,ivec2(68,0),0).x>0.) NPos += Tan*Speed; //D\n                    Output.xyz = NPos;\n                }\n            } else if (fragCoord.x<5.) {\n                //Sun angle\n                if (texelFetch(iChannel1,ivec2(77,0),0).x>0.) Output.y += iTimeDelta;\n                if (texelFetch(iChannel1,ivec2(78,0),0).x>0.) Output.y -= iTimeDelta;\n                Output.z = Output.y; //Sunangle last frame\n            } else if (fragCoord.x<6.) {\n                //Sun direction\n                vec2 Angles = texture(iChannel0,vec2(4.5,0.5)*IRES).xy;\n                Output = vec4(normalize(vec3(cos(Angles.y)*cos(Angles.x)\n                \t,sin(Angles.x),sin(Angles.y)*cos(Angles.x))),1.);\n            } else if (fragCoord.x<7.) {\n                //Last frame dir\n                Output = texture(iChannel0,vec2(2.5,0.5)*IRES);\n            } else if (fragCoord.x<8.) {\n                //Last frame position\n                Output = texture(iChannel0,vec2(3.5,0.5)*IRES);\n            } else if (fragCoord.x<9.) {\n                //Animation time\n                if (iFrame>8) Output.x += iTimeDelta;\n            }\n        }\n    }\n    if (DFBox(fragCoord-1.,RES-2.)<0.) {\n        Output = vec4(0.);\n        if (iFrame>8) {\n            //G-Buffer\n            float CurrentFrame = float(iFrame);\n            vec2 SSOffset = SSOffsets[iFrame%16];\n            vec3 SunDir = texture(iChannel0,vec2(5.5,0.5)*IRES).xyz;\n            //Compensate for 1 frame lag\n            float ATime = texture(iChannel0,vec2(8.5,0.5)*IRES).x+iTimeDelta;\n            vec3 Pos,Eye,Tan;\n            if (ATime<16.) {\n                //Animated movement\n                //Pos\n                int LPosIndex = int(floor(ATime*0.25));\n                vec3 p0 = APositions[LPosIndex];\n                vec3 p1 = APositions[LPosIndex+1];\n                float x = max(0.,mod(ATime,4.)-2.)*0.5;\n                Pos = mix(p0,p1,x*x*(3.-2.*x));\n                //Eye\n                vec2 e0 = AEyes[LPosIndex];\n                vec2 e1 = AEyes[LPosIndex+1];\n                e0 = mix(e0,e1,x*x*(3.-2.*x));\n                Eye = normalize(vec3(cos(e0.x)*sin(e0.y),sin(e0.x),cos(e0.x)*cos(e0.y)));\n                //Tan\n                Tan = normalize(cross(vec3(Eye.x,0.,Eye.z),vec3(0.,1.,0.)));\n            } else {\n                //Free movement\n                float Speed = iTimeDelta;\n                if (texelFetch(iChannel1,ivec2(32,0),0).x>0.) Speed = 8.*iTimeDelta;\n                vec4 CMouse = texture(iChannel0,vec2(0.5,0.5)*IRES);\n                UpdateMouse(CMouse,iMouse);\n                vec4 Eye4 = texture(iChannel0,vec2(1.5,0.5)*IRES);\n                vec3 PriorEye = normalize(vec3(cos(Eye4.x)*sin(Eye4.y),sin(Eye4.x),cos(Eye4.x)*cos(Eye4.y)));\n                UpdateEye(Eye4,CMouse,iMouse);\n                Eye = normalize(vec3(cos(Eye4.x)*sin(Eye4.y),sin(Eye4.x),cos(Eye4.x)*cos(Eye4.y)));\n                Tan = normalize(cross(vec3(Eye.x,0.,Eye.z),vec3(0.,1.,0.)));\n                Pos = texture(iChannel0,vec2(3.5,0.5)*IRES).xyz;\n                vec3 PriorPos = Pos;\n                if (texelFetch(iChannel1,ivec2(87,0),0).x>0.) Pos += Eye*Speed; //W\n                if (texelFetch(iChannel1,ivec2(83,0),0).x>0.) Pos += -Eye*Speed; //S\n                if (texelFetch(iChannel1,ivec2(65,0),0).x>0.) Pos += -Tan*Speed; //A\n                if (texelFetch(iChannel1,ivec2(68,0),0).x>0.) Pos += Tan*Speed; //D\n            }\n            mat3 EyeMat = TBN(Eye);\n            vec3 Bit = -cross(Eye,Tan);\n            vec3 Dir = normalize(vec3(((fragCoord+SSOffset)*IRES*2.-1.)*(ASPECT*CFOV),1.)*EyeMat);\n            //Render scene\n            HIT Pixel = Trace(Pos,Dir,iTime);\n            if (Pixel.M==0) {\n                //Emissive\n                Output = vec4(Vec3ToFloat(Pixel.C*ILightCoeff),texture(iChannel0,fragCoord*IRES).w,Pixel.D,-2.);\n            } else if (Pixel.M>0) {\n                //Geometry\n                Output.w = Pixel.D;\n                Output.z = Vec3ToFloat(Pixel.N*0.5+0.5);\n                \n                \n                \n                \n                //\n                //Copy depth\n                //\n                Output.y = texture(iChannel0,fragCoord*IRES).w;\n                \n                \n                \n                \n                //\n                //Subsurface scattering\n                //\n                vec3 SSLight = vec3(0.);\n                vec3 PPos = Pos+Dir*Pixel.D-Pixel.N*eps.x;\n                vec3 Rand3 = ARand23(fragCoord*IRES*(1.+mod(CurrentFrame*5.527,13.67)));\n                vec3 RandDir = normalize(RandSampleCos(clamp(Rand3.xy,vec2(0.001),vec2(0.999)))*TBN(Dir)*2.+Dir);\n                if (dot(RandDir,Pixel.N)>0.) RandDir = reflect(RandDir,Pixel.N);\n                bool RM_HIT = false;\n                float RM_t = 0.05*(1.+Rand3.z);\n                vec3 RM_p;\n                for (int i=0; i<5; i++) {\n                    RM_p = PPos+RandDir*RM_t;\n                    if (!Inside(RM_p)) {\n                        RM_HIT = true;\n                        break;\n                    }\n                    RM_t *= 2.;\n                }\n                if (RM_HIT) {\n                    HIT Hit2 = Trace(RM_p,RandDir,iTime);\n                    if (Hit2.M==0) SSLight += Hit2.C;\n                    else if (Hit2.M<0) SSLight += SampleSky(RandDir,iTime);\n                }\n                //Radial kernel\n                SSLight *= exp(-RM_t)*mix(vec3(1.,0.15,0.1),vec3(1.),exp(-RM_t*3.));\n                //Output\n                Output.x = Vec3ToFloat(SSLight*ILightCoeff);\n            } else {\n                //Sky\n                Output = vec4(0.,texture(iChannel0,fragCoord*IRES).w,0.,-1.);\n            }\n        }\n    }\n    fragColor = Output;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Temporal ReSTIR\n\nvec4 textureCube(vec2 UV) {\n    //Samples the cubemap\n    float Sign = -mod(floor(UV.y*I1024),2.)*2.+1.;\n    vec3 D = vec3(vec2(UV.x,mod(UV.y,1024.))*I512-1.,Sign);\n    if (UV.y>4096.) D = D.xzy;\n    else if (UV.y>2048.) D = D.zxy;\n    return texture(iChannel3,D);\n}\n\nfloat VSDF0(vec3 p, vec2 UVOffset, vec2 UVDim) {\n    //Sample a volume SDF, p assumed to be inside the brick AABB\n    vec2 UV = vec2(mod(p.x*31.+0.5+floor(p.y*38.75)*UVDim.x,1024.),p.z*31.+0.5+floor(p.y*38.75*UVDim.x*I1024)*UVDim.y);\n    vec2 TEX = textureCube(UVOffset+UV).xy;\n    return mix(TEX.x,TEX.y,fract(p.y*38.75));\n}\n\nfloat VSDF1(vec3 p, vec2 UVOffset, vec2 UVDim) {\n    //Sample a volume SDF, p assumed to be inside the brick AABB\n    vec2 UV = vec2(mod(p.x*31.+0.5+floor(p.y*38.75)*UVDim.x,1024.),p.z*31.+0.5+floor(p.y*38.75*UVDim.x*I1024)*UVDim.y);\n    vec2 TEX = textureCube(UVOffset+UV).zw;\n    return mix(TEX.x,TEX.y,fract(p.y*38.75));\n}\n\nHIT Trace(vec3 P, vec3 D, float Time) {\n    HIT OUT = HIT(1000000000.,vec3(-1.),vec3(-1.),-1);\n    vec3 ID = 1./D;\n    \n    //Ground\n    if (D.y<0.) {\n        float planet = -(P.y-0.06)/D.y;\n        vec3 planep = P+D*planet;\n        if (length(planep.xz-vec2(6.5,3.))<15.) {\n            OUT.D = planet;\n            OUT.C = vec3(0.7,0.35,0.);\n            OUT.N = vec3(0.,1.,0.);\n            OUT.M = 1;\n        }\n    }\n    \n    //Car volume\n    vec2 Carbb = ABox(P,ID,vec3(0.,0.,0.),vec3(13.,0.4*16.,6.));\n    float CarDF = DFBox(P-vec3(0.,0.,0.),vec3(13.,0.4*16.,6.));\n    if (CarDF<0. || (Carbb.x>0. && Carbb.y>Carbb.x && Carbb.x<OUT.D)) {\n        float CarFAR = min(Carbb.y,OUT.D);\n        float Cart = ((CarDF<0.)?0.:Carbb.x+0.0001);\n        vec3 sp = P+D*Cart; vec3 fp;\n        bool HitFound = false;\n        //Traversal\n        for (int b=0; b<32; b++) {\n            if (HitFound || Cart>CarFAR) break;\n            sp = P+D*Cart;\n            fp = floor(vec3(sp.x,sp.y*2.5,sp.z))*vec3(1.,0.4,1.);\n            vec4 CarVoxel = textureCube(vec2(512.5+fp.x+fp.y*2.5*13.,1536.5+fp.z));\n            float VFar = ABoxfar(P,ID,fp,fp+vec3(1.,0.4,1.));\n            for (int PixelIndex=0; PixelIndex<4; PixelIndex++) {\n                float CarV = CarVoxel[PixelIndex];\n                if (CarV>-0.5) {\n                    //Voxel contains at least one brick\n                    float CBrickIndex = floor(CarV);\n                    vec4 CBrick0 = textureCube(vec2(512.5+CBrickIndex,1542.5));\n                    vec4 CBrick1 = textureCube(vec2(512.5+CBrickIndex,1543.5));\n                    int BrickTypeIndex = int(floor(CBrick0.w));\n                    BRICKTYPE CBrickType = BrickTypes[BrickTypeIndex];\n                    vec2 BrickUVOffset = vec2(0.,CBrickType.UVOffset);\n                    vec2 BrickUVDim = CBrickType.UVDim;\n                    vec3 BrickDim = CBrickType.BrickDim;\n                    //Rotation\n                    vec3 CX = CBrick1.xyz;\n                    vec2 sincos = vec2(sin(CBrick1.w),cos(CBrick1.w));\n                    vec3 RefCZ = normalize(cross(CX,vec3(0.,1.,0.)));\n                    vec3 RefCY = cross(RefCZ,CX);\n                    vec3 CY = sincos.y*RefCY+sincos.x*RefCZ;\n                    vec3 CZ = -sincos.x*RefCY+sincos.y*RefCZ;\n                    vec3 BRPos = P-CBrick0.xyz;\n                    BRPos = BRPos.x*vec3(CX.x,CY.x,CZ.x)+BRPos.y*vec3(CX.y,CY.y,CZ.y)+BRPos.z*vec3(CX.z,CY.z,CZ.z);\n                    vec3 BRDir = D.x*vec3(CX.x,CY.x,CZ.x)+D.y*vec3(CX.y,CY.y,CZ.y)+D.z*vec3(CX.z,CY.z,CZ.z);\n                    vec2 tmpbb = ABox(BRPos,1./BRDir,vec3(0.),BrickDim);\n                    if (DFBox(BRPos,BrickDim)>0. && (tmpbb.x<0. || tmpbb.x>tmpbb.y)) continue;\n                    float tmpCart = max(Cart,tmpbb.x+0.0001);\n                    float tmpVFar = min(VFar,tmpbb.y);\n                    BRPos = P+D*tmpCart-CBrick0.xyz;\n                    BRPos = BRPos.x*vec3(CX.x,CY.x,CZ.x)+BRPos.y*vec3(CX.y,CY.y,CZ.y)+BRPos.z*vec3(CX.z,CY.z,CZ.z);\n                    \n                    float Sample;\n                    if (BrickTypeIndex<12) {\n                        for (int i=0; i<256; i++) {\n                            Sample = max(DFBox(BRPos,BrickDim),VSDF0(BRPos,BrickUVOffset,BrickUVDim));\n                            tmpCart += Sample;\n                            BRPos += BRDir*Sample;\n                            if (min(Sample-0.002,tmpVFar-tmpCart)<0.) break;\n                        }\n                    } else {\n                        for (int i=0; i<256; i++) {\n                            Sample = max(DFBox(BRPos,BrickDim),VSDF1(BRPos,BrickUVOffset,BrickUVDim));\n                            tmpCart += Sample;\n                            BRPos += BRDir*Sample;\n                            if (min(Sample-0.002,tmpVFar-tmpCart)<0.) break;\n                        }\n                    }\n                    if (Sample<0.002 && tmpCart<min(tmpVFar,OUT.D)) {\n                        //Hit\n                        vec4 CBrick2 = textureCube(vec2(512.5+CBrickIndex,1544.5));\n                        OUT.D = tmpCart;\n                        OUT.C = CBrick2.xyz;\n                        if (BrickTypeIndex<12) {\n                            OUT.N = normalize(vec3(VSDF0(vec3(min(BRPos.x+eps.x,BrickDim.x),BRPos.yz),BrickUVOffset,BrickUVDim)-\n                                                   VSDF0(vec3(max(BRPos.x-eps.x,0.),BRPos.yz),BrickUVOffset,BrickUVDim),\n                                                   VSDF0(vec3(BRPos.x,min(BRPos.y+eps.x,BrickDim.y),BRPos.z),BrickUVOffset,BrickUVDim)-\n                                                   VSDF0(vec3(BRPos.x,max(BRPos.y-eps.x,0.),BRPos.z),BrickUVOffset,BrickUVDim),\n                                                   VSDF0(vec3(BRPos.xy,min(BRPos.z+eps.x,BrickDim.z)),BrickUVOffset,BrickUVDim)-\n                                                   VSDF0(vec3(BRPos.xy,max(BRPos.z-eps.x,0.)),BrickUVOffset,BrickUVDim)));\n                        } else {\n                            OUT.N = normalize(vec3(VSDF1(vec3(min(BRPos.x+eps.x,BrickDim.x),BRPos.yz),BrickUVOffset,BrickUVDim)-\n                                                   VSDF1(vec3(max(BRPos.x-eps.x,0.),BRPos.yz),BrickUVOffset,BrickUVDim),\n                                                   VSDF1(vec3(BRPos.x,min(BRPos.y+eps.x,BrickDim.y),BRPos.z),BrickUVOffset,BrickUVDim)-\n                                                   VSDF1(vec3(BRPos.x,max(BRPos.y-eps.x,0.),BRPos.z),BrickUVOffset,BrickUVDim),\n                                                   VSDF1(vec3(BRPos.xy,min(BRPos.z+eps.x,BrickDim.z)),BrickUVOffset,BrickUVDim)-\n                                                   VSDF1(vec3(BRPos.xy,max(BRPos.z-eps.x,0.)),BrickUVOffset,BrickUVDim)));\n                        }\n                        OUT.N = OUT.N.x*CX+OUT.N.y*CY+OUT.N.z*CZ;\n                        OUT.M = int(floor(CBrick2.w));\n                        HitFound = true;\n                    }\n                } else break;\n            }\n            Cart = VFar+0.0001;\n        }\n    }\n    \n    //Return\n    return OUT;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 Output = vec4(0.);\n    //Diffuse temporal ReSTIR\n    if (DFBox(fragCoord-vec2(1.),RES-2.)<0. && iFrame>7) {\n        float CurrentFrame = float(iFrame);\n        vec2 SSOffset = SSOffsets[iFrame%16];\n        vec2 UV = fragCoord+SSOffset;\n        vec3 Pos = texture(iChannel0,vec2(3.5,0.5)*IRES).xyz;\n        vec3 Eye = texture(iChannel0,vec2(2.5,0.5)*IRES).xyz;\n        vec3 Tan; vec3 Bit = TBN(Eye,Tan);\n        mat3 EyeMat = TBN(Eye);\n        vec3 PriorPos = texture(iChannel0,vec2(7.5,0.5)*IRES).xyz;\n        vec3 PriorEye = texture(iChannel0,vec2(6.5,0.5)*IRES).xyz;\n        vec3 PriorTan; vec3 PriorBit = TBN(PriorEye,PriorTan);\n        mat3 PriorEyeMat = TBN(PriorEye);\n        vec3 Dir = normalize(vec3((UV*IRES*2.-1.)*CFOV*ASPECT,1.)*EyeMat);\n        vec4 CAttr = texture(iChannel0,fragCoord*IRES);\n        if (CAttr.w>-0.5) {\n            //Geometry pixel\n            vec3 Normal = normalize(FloatToVec3(CAttr.z)*2.-1.);\n            vec3 PPos = Pos+Dir*CAttr.w;\n            vec3 L = vec3(0.);\n            //\n            //Reprojection of temporal reservoirs\n            //\n            vec3 CVPos = PPos-PriorPos;\n            CVPos = vec3(dot(CVPos,PriorTan),dot(CVPos,PriorBit),dot(CVPos,PriorEye));\n            vec2 Luv = ((CVPos.xy/CVPos.z)*0.5/(ASPECT*CFOV)+0.5)*RES;\n            vec2 LuvCenter = floor(Luv);\n            float SmallestDistance = 1000.; vec2 LResUV;\n            for (float x = -1.; x<1.5; x++) {\n                for (float y = -1.; y<1.5; y++) {\n                    vec4 LRSample = texture(iChannel0,(LuvCenter+0.5+vec2(x,y))*IRES);\n                    vec2 LRSample2 = texture(iChannel2,(LuvCenter+0.5+vec2(x,y))*IRES).zw;\n                    vec2 LRluv = LuvCenter+vec2(x,y)+FloatToVec2(LRSample2.y);\n                    vec3 LRDir = normalize(vec3((LRluv*IRES*2.-1.)*CFOV*ASPECT,1.)*PriorEyeMat);\n                    vec3 LRPPos = PriorPos+LRDir*LRSample.y;\n                    vec3 LRNormal = normalize(FloatToVec3(LRSample2.x)*2.-1.);\n                    //Reprojection on current screen space\n                    CVPos = LRPPos-Pos;\n                    CVPos = vec3(dot(CVPos,Tan),dot(CVPos,Bit),dot(CVPos,Eye));\n                    vec2 LRUV = ((CVPos.xy/CVPos.z)*0.5/(ASPECT*CFOV)+0.5)*RES;\n                    float LRUVDist = length(fragCoord-LRUV);\n                    if (LRSample.y>-0.5 && DFBox(LRUV-1.,RES-2.)<0. && abs(dot(Normal,LRPPos-PPos))<0.05\n                        && dot(Normal,LRNormal)>0.9 && LRUVDist<SmallestDistance) {\n                        SmallestDistance = LRUVDist;\n                        LResUV = LRluv;\n                    }\n                }\n            }\n            //Generate ray\n            vec4 LR = texture(iChannel1,LResUV*IRES);\n            vec2 LRWM = FloatToVec2(LR.w);\n            float M = LRWM.y*M_CLAMP_T;\n            vec2 Rand2 = FloatToVec2(LR.y);\n            vec3 RLight = FloatToVec3(LR.x)*LightCoeff;\n            float RDist = LR.z;\n            float w = max(0.,dot(RLight,vec3(0.3333)))*M*LRWM.x;\n            float W = w/max(0.0001,M*dot(RLight,vec3(0.3333))); //Update W\n            vec3 Rand3;\n            if (SmallestDistance>900.) {// || DFBox(UVResidual,vec2(1.))>0.) {\n                //No valid reprojection on the last frame -> new pixel\n                Rand3 = ARand23(fragCoord*IRES*(1.+mod(CurrentFrame*7.253,9.234)));\n            } else {\n                //Old pixel\n                if (iFrame%3==-1) {\n                    //Sample validation\n                    Rand3 = vec3(Rand2,0.);\n                } else {\n                    //New sample\n                    Rand3 = ARand23(fragCoord*IRES*(1.+mod(CurrentFrame*7.253,9.234)));\n                }\n            }\n            Rand3.xy = (floor(Rand3.xy*8192.)+0.5)*I8192;\n            //Trace ray\n            float DiffLength;\n            vec3 DiffLight = vec3(0.);\n            PPos += Normal*eps.x;\n            vec3 RandDir = RandSample(Rand3.xy)*TBN(Normal);\n            HIT Hit1 = Trace(PPos,RandDir,iTime);\n            if (Hit1.M==0) {\n                DiffLength = Hit1.D;\n                DiffLight = Hit1.C;\n            } else if (Hit1.M>0) {\n                DiffLength = Hit1.D;\n                /*\n                //World space second bounce\n                vec3 PPos1 = PPos+RandDir*Hit1.D+Hit1.N*eps.x;\n                vec2 Rand2 = ARand23(Rand3.xy*7.172).xy;\n                vec3 RandDir2 = RandSampleCos(clamp(Rand2,vec2(0.001),vec2(0.999)))*TBN(Hit1.N);\n                HIT Hit2 = Trace(PPos1,RandDir2,iTime);\n                if (Hit2.M==0) DiffLight += Hit2.C*Hit1.C;\n                else if (Hit2.M>0) {}\n                else DiffLight += SampleSky(RandDir2,iTime)*Hit1.C;\n                //*/\n                \n                //*\n                //Screen space projection\n                vec3 CVPos = PPos+RandDir*Hit1.D-PriorPos;\n                CVPos = vec3(dot(CVPos,PriorTan),dot(CVPos,PriorBit),dot(CVPos,PriorEye));\n                vec2 SUV = ((CVPos.xy/CVPos.z)*0.5/(ASPECT*CFOV)+0.5)*RES;\n                if (DFBox(SUV-1.,RES-2.)<0.) {\n                    //Inside screen\n                    vec4 SAttr = texture(iChannel0,SUV*IRES);\n                    vec3 SDir = normalize(vec3((SUV*IRES*2.-1.)*CFOV*ASPECT,1.)*PriorEyeMat);\n                    vec3 SPPos = PriorPos+SDir*SAttr.y;\n                    if (length(SPPos-PPos-RandDir*Hit1.D)<0.05) {\n                        vec4 SRes = texture(iChannel1,SUV*IRES);\n                        DiffLight += FloatToVec3(SRes.x)*(LightCoeff*FloatToVec2(SRes.w).x\n                                     *RandSample(FloatToVec2(SRes.y)).z)*Hit1.C*2.5;\n                    }\n                }\n                //*/\n            } else {\n                //Sky\n                DiffLength = 10000000.;\n                DiffLight += SampleSky(RandDir,iTime);\n            }\n            //Update reservoirs\n            if (SmallestDistance>900.) {// || DFBox(UVResidual,vec2(1.))>0.) {\n                //No valid reprojection on the last frame -> new pixel\n                Output = vec4(Vec3ToFloat(DiffLight*ILightCoeff),Vec2ToFloat(Rand3.xy),\n                              DiffLength,Vec2ToFloat(vec2(1.,1./M_CLAMP_T)));\n            } else {\n                //Old pixel\n                if (iFrame%3==-1) {\n                    //Sample validation\n                    if (length(RLight-DiffLight)>0.1) {\n                        //Invalid sample\n                        Output = vec4(Vec3ToFloat(DiffLight*ILightCoeff),LR.y,\n                                      DiffLength,Vec2ToFloat(vec2(W,max(1.,M*0.5)/M_CLAMP_T)));\n                    } else {\n                        //Valid sample\n                        Output = LR;\n                    }\n                } else {\n                    //Temporal ReSTIR\n                    float wnew = max(0.,dot(DiffLight,vec3(0.3333)))*dot(RandDir,Normal); //Target pdf\n                    M = min(M,M_CLAMP_T-1.); //Clamping\n                    w = max(0.,dot(RLight,vec3(0.3333)))*RandSample(Rand2.xy).z*M*W+wnew; //R.w += w\n                    if (Rand3.z<wnew/max(0.0001,w)) {\n                        //New sample\n                        RLight = DiffLight;\n                        Rand2 = Rand3.xy;\n                        RDist = DiffLength;\n                    }\n                    M += 1.; //R.M += 1\n                    float p_hat = max(0.,dot(RLight,vec3(0.3333)))*RandSample(Rand2.xy).z; //p hat\n                    W = w/max(0.0001,M*p_hat); //Update W\n                    //Output\n                    Output = vec4(Vec3ToFloat(RLight*ILightCoeff),Vec2ToFloat(Rand2),RDist,\n                                  Vec2ToFloat(vec2(W,M/M_CLAMP_T)));\n                }\n            }\n        } else {\n            //Sky pixel\n            Output = vec4(0.,0.,0.,-1.);\n        }\n    }\n    fragColor = Output;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//Reprojection, denoising and spatial ReSTIR\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 Output = vec4(0.);\n    //Diffuse temporal ReSTIR\n    if (DFBox(fragCoord-vec2(1.),RES-2.)<0.) {\n        float CurrentFrame = float(iFrame);\n        vec2 SSOffset = SSOffsets[iFrame%16];\n        vec2 UV = fragCoord+SSOffset;\n        vec3 Pos = texture(iChannel0,vec2(3.5,0.5)*IRES).xyz;\n        vec3 Eye = texture(iChannel0,vec2(2.5,0.5)*IRES).xyz;\n        vec3 Tan; vec3 Bit = TBN(Eye,Tan);\n        mat3 EyeMat = TBN(Eye);\n        vec3 PriorPos = texture(iChannel0,vec2(7.5,0.5)*IRES).xyz;\n        vec3 PriorEye = texture(iChannel0,vec2(6.5,0.5)*IRES).xyz;\n        vec3 PriorTan; vec3 PriorBit = TBN(PriorEye,PriorTan);\n        mat3 PriorEyeMat = TBN(PriorEye);\n        vec3 Dir = normalize(vec3((UV*IRES*2.-1.)*CFOV*ASPECT,1.)*EyeMat);\n        vec4 CAttr = texture(iChannel0,fragCoord*IRES);\n        if (CAttr.w>-0.5) {\n            //Geometry pixel\n            vec3 Normal = normalize(FloatToVec3(CAttr.z)*2.-1.);\n            vec3 PPos = Pos+Dir*CAttr.w;\n            \n            \n            \n            //\n            //Reprojection of temporal reservoirs\n            //\n            vec3 CVPos = PPos-PriorPos;\n            CVPos = vec3(dot(CVPos,PriorTan),dot(CVPos,PriorBit),dot(CVPos,PriorEye));\n            vec2 Luv = ((CVPos.xy/CVPos.z)*0.5/(ASPECT*CFOV)+0.5)*RES;\n            vec2 LuvCenter = floor(Luv);\n            float SmallestDistance = 1000.; vec2 ResUV;\n            for (float x = -1.; x<1.5; x++) {\n                for (float y = -1.; y<1.5; y++) {\n                    vec4 LRSample = texture(iChannel0,(LuvCenter+0.5+vec2(x,y))*IRES);\n                    vec2 LRSample2 = texture(iChannel2,(LuvCenter+0.5+vec2(x,y))*IRES).zw;\n                    vec2 LRluv = LuvCenter+vec2(x,y)+FloatToVec2(LRSample2.y);\n                    vec3 LRDir = normalize(vec3((LRluv*IRES*2.-1.)*CFOV*ASPECT,1.)*PriorEyeMat);\n                    vec3 LRPPos = PriorPos+LRDir*LRSample.y;\n                    vec3 LRNormal = normalize(FloatToVec3(LRSample2.x)*2.-1.);\n                    //Reprojection on current screen space\n                    CVPos = LRPPos-Pos;\n                    CVPos = vec3(dot(CVPos,Tan),dot(CVPos,Bit),dot(CVPos,Eye));\n                    vec2 LRUV = ((CVPos.xy/CVPos.z)*0.5/(ASPECT*CFOV)+0.5)*RES;\n                    float LRUVDist = length(fragCoord-LRUV);\n                    if (LRSample.y>-0.5 && DFBox(LRUV-1.,RES-2.)<0. && abs(dot(Normal,LRPPos-PPos))<0.05\n                        && dot(Normal,LRNormal)>0.9 && LRUVDist<SmallestDistance) {\n                        SmallestDistance = LRUVDist;\n                        ResUV = LRUV;\n                    }\n                }\n            }\n            vec2 UVResidual = ResUV-floor(fragCoord);\n            if (DFBox(UVResidual,vec2(1.))<=0.) { //Can replace with SmallestDistance\n                //Inside current pixel -> keep position\n                Output.w = Vec2ToFloat(UVResidual);\n            } else {\n                //Outside current pixel -> new positions\n                Output.w = Vec2ToFloat(SSOffset+0.5);\n            }\n            \n            \n            \n            \n            //\n            //Copy last frame normal\n            //\n            Output.z = texture(iChannel0,fragCoord*IRES).z;\n            \n            \n            \n            \n            //\n            //Denoise subsurface scattering\n            //\n                //Could be improved if we knew the out-scattering point\n                //The denoiser is built on the fact that the distribution of rays is known\n            vec4 SSLight = vec4(FloatToVec3(texture(iChannel0,fragCoord*IRES).x)*2.,2.);\n            for (float x=-2.; x<2.5; x++) {\n                for (float y=-2.; y<2.5; y++) {\n                    vec2 SUV = fragCoord+vec2(x,y)*16.;\n                    vec4 SAttr = texture(iChannel0,SUV*IRES);\n                    vec3 SDir = normalize(vec3((SUV*IRES*2.-1.)*CFOV*ASPECT,1.)*EyeMat);\n                    vec3 SPPos = Pos+SDir*SAttr.w;\n                    vec3 SNormal = FloatToVec3(SAttr.z)*2.-1.;\n                    if (DFBox(SUV-1.,RES-2.)>0. || SAttr.w<-0.5 ||\n                        abs(dot(SPPos-PPos,Normal))>0.05 || dot(Normal,SNormal)<0.9) continue;\n                    SSLight += vec4(FloatToVec3(SAttr.x),1.);\n                }\n            }\n            SSLight.xyz /= SSLight.w;\n            Output.x = Vec3ToFloat(SSLight.xyz);\n            \n            \n            \n            \n            //\n            //Spatial ReSTIR\n            //\n            vec4 CR = texture(iChannel1,fragCoord*IRES);\n            vec2 CRWM = FloatToVec2(CR.w)*vec2(1.,M_CLAMP_T);\n            float W = CRWM.x;\n            float M = CRWM.y;\n            vec3 CRLight = FloatToVec3(CR.x)*LightCoeff;\n            float CRRandFloat = CR.y;\n            float w = max(0.,dot(CRLight,vec3(0.3333)))*M*W*RandSample(FloatToVec2(CRRandFloat)).z;\n            vec3 Rand3 = ARand23(fragCoord*(1.+mod(iTime*18.327,13.9347)));\n            int NSamples = 9;\n            float SpatialRadius = 1.+Rand3.x*clamp((2./CAttr.w)*RES.x*0.1,1.,RES.x*0.1);\n            float AngleDelta = 6.28318530718/float(NSamples);\n            float CAngle = Rand3.y*AngleDelta;\n            float Jacobian,wnew,np_hat; vec2 SUV; vec3 SDir,SPos,SNormal,SRayHit; vec4 SDiffShad,SR,SSDF;\n            for (int s=0; s<NSamples; s++) {\n                //For all spatial reservoirs\n                CAngle += AngleDelta;\n                SUV = floor(fragCoord+vec2(sin(CAngle),cos(CAngle))*SpatialRadius)+0.5;\n                if (DFBox(SUV-1.,RES-2.)>=0.) continue;\n                SDiffShad = texture(iChannel0,SUV*IRES);\n                if (SDiffShad.w<-0.5) continue; //Sky pixel test\n                SDir = normalize(vec3(((SUV)*IRES*2.-1.)*CFOV*ASPECT,1.)*TBN(Eye));\n                SPos = Pos+SDir*SDiffShad.w;\n                SNormal = FloatToVec3(SDiffShad.z)*2.-1.;\n                if (!(dot(SNormal,Normal)>0.9 && abs(dot(SPos-PPos,Normal))<0.05)) continue; //Geometric similarity test\n                SR = texture(iChannel1,SUV*IRES);\n                vec3 SRandDir = (RandSample(FloatToVec2(SR.y))*TBN(SNormal));\n                SRayHit = SPos+SR.z*SRandDir;\n                //HitNormal = Gradient(SRayHit,iTime,SSDF); //Can't do, is not stored in reservoirs either\n                if (dot(SRayHit-PPos,Normal)<=0.) continue; //Hemisphere test\n                \n                //Screen space ray tracing to approximate visibility\n                bool Visible = true;\n                float SSNSamples = 5.;\n                vec3 SSRayDir = normalize(SRayHit-PPos);\n                for (float di=ARand21(SUV)*0.8+0.1; di<SSNSamples; di++) {\n                    //For each sample\n                    vec3 SSP = PPos+SSRayDir*(di*0.1);\n                    vec3 SSVPos = SSP-Pos;\n                    SSVPos = vec3(dot(SSVPos,Tan),dot(SSVPos,Bit),dot(SSVPos,Eye));\n                    vec2 SSUV = ((SSVPos.xy/SSVPos.z)*0.5/(ASPECT*CFOV)+0.5)*RES;\n                    if (DFBox(SSUV-1.,RES-2.)>0.) break;\n                    float SSDepth = texture(iChannel0,SSUV*IRES).w;\n                    if (SSDepth+0.02<length(SSVPos)) { Visible = false; break; }\n                }\n                if (!Visible) continue;\n                \n                //Read reservoir\n                vec2 SWM = FloatToVec2(SR.w)*vec2(1.,M_CLAMP_T);\n                vec3 SRLight = FloatToVec3(SR.x)*LightCoeff;\n                //Jacobian\n                Jacobian = 1.; //abs(dot(PPos-SRayHit,HitNormal)*pow(SR.z,3.))/\n                           //max(0.0001,abs(dot(SPos-SRayHit,HitNormal)*pow(length(PPos-SRayHit),3.))); //Big sad, can't use\n                np_hat = max(0.,dot(SRLight,vec3(0.3333)));\n                wnew = np_hat*SWM.y*SWM.x*RandSample(FloatToVec2(SR.y)).z*max(0.0001,Jacobian);\n                w += wnew;\n                M += SWM.y;\n                float RandV = ARand21(SUV+mod(float(iFrame+s),2048.)*vec2(3.683,4.887));\n                if (RandV<wnew/max(0.0001,w)) {\n                    CRLight = SRLight;\n                    CRRandFloat = SR.y;\n                }\n            }\n            //Bias correction\n            float bias_p_hat = max(0.,dot(CRLight,vec3(0.3333)))*RandSample(FloatToVec2(CRRandFloat)).z;\n            W = w/max(0.0001,M*bias_p_hat);\n            vec3 IndirectDiffuse = CRLight*W*RandSample(FloatToVec2(CRRandFloat)).z;\n            //Wood color mult\n            if (PPos.y<0.061) {\n                IndirectDiffuse *= texture(iChannel3,PPos.xz*0.1).xyz;\n            }\n            //Output\n            Output.y = Vec3ToFloat(IndirectDiffuse*ILightCoeff);\n        } else {\n            //Sky pixel\n            Output = vec4(0.,0.,0.,-1.);\n        }\n    }\n    fragColor = Output;\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"//Composition\n\nvec4 textureCube(vec2 UV) {\n    //Samples the cubemap\n    float Sign = -mod(floor(UV.y*I1024),2.)*2.+1.;\n    vec3 D = vec3(vec2(UV.x,mod(UV.y,1024.))*I512-1.,Sign);\n    if (UV.y>4096.) D = D.xzy;\n    else if (UV.y>2048.) D = D.zxy;\n    return texture(iChannel3,D);\n}\n\nfloat VSDF0(vec3 p, vec2 UVOffset, vec2 UVDim) {\n    //Sample a volume SDF, p assumed to be inside the brick AABB\n    vec2 UV = vec2(mod(p.x*31.+0.5+floor(p.y*38.75)*UVDim.x,1024.),p.z*31.+0.5+floor(p.y*38.75*UVDim.x*I1024)*UVDim.y);\n    vec2 TEX = textureCube(UVOffset+UV).xy;\n    return mix(TEX.x,TEX.y,fract(p.y*38.75));\n}\n\nfloat VSDF1(vec3 p, vec2 UVOffset, vec2 UVDim) {\n    //Sample a volume SDF, p assumed to be inside the brick AABB\n    vec2 UV = vec2(mod(p.x*31.+0.5+floor(p.y*38.75)*UVDim.x,1024.),p.z*31.+0.5+floor(p.y*38.75*UVDim.x*I1024)*UVDim.y);\n    vec2 TEX = textureCube(UVOffset+UV).zw;\n    return mix(TEX.x,TEX.y,fract(p.y*38.75));\n}\n\nHIT Trace(vec3 P, vec3 D, float Time) {\n    HIT OUT = HIT(1000000000.,vec3(-1.),vec3(-1.),-1);\n    vec3 ID = 1./D;\n    \n    //Ground\n    if (D.y<0.) {\n        float planet = -(P.y-0.06)/D.y;\n        vec3 planep = P+D*planet;\n        if (length(planep.xz-vec2(6.5,3.))<15.) {\n            OUT.D = planet;\n            OUT.C = vec3(0.7,0.35,0.);\n            OUT.N = vec3(0.,1.,0.);\n            OUT.M = 1;\n        }\n    }\n    \n    //Car volume\n    vec2 Carbb = ABox(P,ID,vec3(0.,0.,0.),vec3(13.,0.4*16.,6.));\n    float CarDF = DFBox(P-vec3(0.,0.,0.),vec3(13.,0.4*16.,6.));\n    if (CarDF<0. || (Carbb.x>0. && Carbb.y>Carbb.x && Carbb.x<OUT.D)) {\n        float CarFAR = min(Carbb.y,OUT.D);\n        float Cart = ((CarDF<0.)?0.:Carbb.x+0.0001);\n        vec3 sp = P+D*Cart; vec3 fp;\n        bool HitFound = false;\n        //Traversal\n        for (int b=0; b<32; b++) {\n            if (HitFound || Cart>CarFAR) break;\n            sp = P+D*Cart;\n            fp = floor(vec3(sp.x,sp.y*2.5,sp.z))*vec3(1.,0.4,1.);\n            vec4 CarVoxel = textureCube(vec2(512.5+fp.x+fp.y*2.5*13.,1536.5+fp.z));\n            float VFar = ABoxfar(P,ID,fp,fp+vec3(1.,0.4,1.));\n            for (int PixelIndex=0; PixelIndex<4; PixelIndex++) {\n                float CarV = CarVoxel[PixelIndex];\n                if (CarV>-0.5) {\n                    //Voxel contains at least one brick\n                    float CBrickIndex = floor(CarV);\n                    vec4 CBrick0 = textureCube(vec2(512.5+CBrickIndex,1542.5));\n                    vec4 CBrick1 = textureCube(vec2(512.5+CBrickIndex,1543.5));\n                    int BrickTypeIndex = int(floor(CBrick0.w));\n                    BRICKTYPE CBrickType = BrickTypes[BrickTypeIndex];\n                    vec2 BrickUVOffset = vec2(0.,CBrickType.UVOffset);\n                    vec2 BrickUVDim = CBrickType.UVDim;\n                    vec3 BrickDim = CBrickType.BrickDim;\n                    //Rotation\n                    vec3 CX = CBrick1.xyz;\n                    vec2 sincos = vec2(sin(CBrick1.w),cos(CBrick1.w));\n                    vec3 RefCZ = normalize(cross(CX,vec3(0.,1.,0.)));\n                    vec3 RefCY = cross(RefCZ,CX);\n                    vec3 CY = sincos.y*RefCY+sincos.x*RefCZ;\n                    vec3 CZ = -sincos.x*RefCY+sincos.y*RefCZ;\n                    vec3 BRPos = P-CBrick0.xyz;\n                    BRPos = BRPos.x*vec3(CX.x,CY.x,CZ.x)+BRPos.y*vec3(CX.y,CY.y,CZ.y)+BRPos.z*vec3(CX.z,CY.z,CZ.z);\n                    vec3 BRDir = D.x*vec3(CX.x,CY.x,CZ.x)+D.y*vec3(CX.y,CY.y,CZ.y)+D.z*vec3(CX.z,CY.z,CZ.z);\n                    vec2 tmpbb = ABox(BRPos,1./BRDir,vec3(0.),BrickDim);\n                    if (DFBox(BRPos,BrickDim)>0. && (tmpbb.x<0. || tmpbb.x>tmpbb.y)) continue;\n                    float tmpCart = max(Cart,tmpbb.x+0.0001);\n                    float tmpVFar = min(VFar,tmpbb.y);\n                    BRPos = P+D*tmpCart-CBrick0.xyz;\n                    BRPos = BRPos.x*vec3(CX.x,CY.x,CZ.x)+BRPos.y*vec3(CX.y,CY.y,CZ.y)+BRPos.z*vec3(CX.z,CY.z,CZ.z);\n                    \n                    float Sample;\n                    if (BrickTypeIndex<12) {\n                        for (int i=0; i<256; i++) {\n                            Sample = max(DFBox(BRPos,BrickDim),VSDF0(BRPos,BrickUVOffset,BrickUVDim));\n                            tmpCart += Sample;\n                            BRPos += BRDir*Sample;\n                            if (min(Sample-0.002,tmpVFar-tmpCart)<0.) break;\n                        }\n                    } else {\n                        for (int i=0; i<256; i++) {\n                            Sample = max(DFBox(BRPos,BrickDim),VSDF1(BRPos,BrickUVOffset,BrickUVDim));\n                            tmpCart += Sample;\n                            BRPos += BRDir*Sample;\n                            if (min(Sample-0.002,tmpVFar-tmpCart)<0.) break;\n                        }\n                    }\n                    if (Sample<0.002 && tmpCart<min(tmpVFar,OUT.D)) {\n                        //Hit\n                        vec4 CBrick2 = textureCube(vec2(512.5+CBrickIndex,1544.5));\n                        OUT.D = tmpCart;\n                        OUT.C = CBrick2.xyz;\n                        if (BrickTypeIndex<12) {\n                            OUT.N = normalize(vec3(VSDF0(vec3(min(BRPos.x+eps.x,BrickDim.x),BRPos.yz),BrickUVOffset,BrickUVDim)-\n                                                   VSDF0(vec3(max(BRPos.x-eps.x,0.),BRPos.yz),BrickUVOffset,BrickUVDim),\n                                                   VSDF0(vec3(BRPos.x,min(BRPos.y+eps.x,BrickDim.y),BRPos.z),BrickUVOffset,BrickUVDim)-\n                                                   VSDF0(vec3(BRPos.x,max(BRPos.y-eps.x,0.),BRPos.z),BrickUVOffset,BrickUVDim),\n                                                   VSDF0(vec3(BRPos.xy,min(BRPos.z+eps.x,BrickDim.z)),BrickUVOffset,BrickUVDim)-\n                                                   VSDF0(vec3(BRPos.xy,max(BRPos.z-eps.x,0.)),BrickUVOffset,BrickUVDim)));\n                        } else {\n                            OUT.N = normalize(vec3(VSDF1(vec3(min(BRPos.x+eps.x,BrickDim.x),BRPos.yz),BrickUVOffset,BrickUVDim)-\n                                                   VSDF1(vec3(max(BRPos.x-eps.x,0.),BRPos.yz),BrickUVOffset,BrickUVDim),\n                                                   VSDF1(vec3(BRPos.x,min(BRPos.y+eps.x,BrickDim.y),BRPos.z),BrickUVOffset,BrickUVDim)-\n                                                   VSDF1(vec3(BRPos.x,max(BRPos.y-eps.x,0.),BRPos.z),BrickUVOffset,BrickUVDim),\n                                                   VSDF1(vec3(BRPos.xy,min(BRPos.z+eps.x,BrickDim.z)),BrickUVOffset,BrickUVDim)-\n                                                   VSDF1(vec3(BRPos.xy,max(BRPos.z-eps.x,0.)),BrickUVOffset,BrickUVDim)));\n                        }\n                        OUT.N = OUT.N.x*CX+OUT.N.y*CY+OUT.N.z*CZ;\n                        OUT.M = int(floor(CBrick2.w));\n                        HitFound = true;\n                    }\n                } else break;\n            }\n            Cart = VFar+0.0001;\n        }\n    }\n    \n    //Return\n    return OUT;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 Output = vec4(0.);\n    //Diffuse temporal ReSTIR\n    if (DFBox(fragCoord-vec2(1.),RES-2.)<0.) {\n        float CurrentFrame = float(iFrame);\n        vec2 SSOffset = SSOffsets[iFrame%16];\n        vec2 UV = fragCoord+SSOffset;\n        vec3 Pos = texture(iChannel0,vec2(3.5,0.5)*IRES).xyz;\n        vec3 Eye = texture(iChannel0,vec2(2.5,0.5)*IRES).xyz;\n        vec3 Tan; vec3 Bit = TBN(Eye,Tan);\n        mat3 EyeMat = TBN(Eye);\n        vec3 PriorPos = texture(iChannel0,vec2(7.5,0.5)*IRES).xyz;\n        vec3 PriorEye = texture(iChannel0,vec2(6.5,0.5)*IRES).xyz;\n        vec3 PriorTan; vec3 PriorBit = TBN(PriorEye,PriorTan);\n        mat3 PriorEyeMat = TBN(PriorEye);\n        vec3 Dir = normalize(vec3((UV*IRES*2.-1.)*CFOV*ASPECT,1.)*EyeMat);\n        vec4 CAttr = texture(iChannel0,fragCoord*IRES);\n        if (CAttr.w<-1.5) {\n            //Emissive\n            Output = vec4(FloatToVec3(CAttr.x)*LightCoeff,0.);\n        } else if (CAttr.w>-0.5) {\n            //Geometry pixel\n            vec3 Normal = normalize(FloatToVec3(CAttr.z)*2.-1.);\n            vec3 PPos = Pos+Dir*CAttr.w;\n            \n            HIT SmallRay = Trace(Pos+Dir*CAttr.w,Dir,iTime);\n            \n            \n            \n            //\n            //Denoise subsurface scattering\n            //\n                //Could be improved if we knew the out-scattering point\n                //We know the distribution of the rays\n            vec4 SSLight = vec4(FloatToVec3(texture(iChannel2,fragCoord*IRES).x)*2.,2.);\n            for (float x=-2.; x<2.5; x++) {\n                for (float y=-2.; y<2.5; y++) {\n                    vec2 SUV = fragCoord+vec2(x,y)*4.;\n                    vec4 SAttr = texture(iChannel0,SUV*IRES);\n                    vec3 SDir = normalize(vec3((SUV*IRES*2.-1.)*CFOV*ASPECT,1.)*EyeMat);\n                    vec3 SPPos = Pos+SDir*SAttr.w;\n                    vec3 SNormal = FloatToVec3(SAttr.z)*2.-1.;\n                    if (DFBox(SUV-1.,RES-2.)>0. || SAttr.w<-0.5 ||\n                        abs(dot(SPPos-PPos,Normal))>0.05 || dot(Normal,SNormal)<0.9) continue;\n                    SSLight += vec4(FloatToVec3(texture(iChannel2,SUV*IRES).x),1.);\n                }\n            }\n            SSLight.xyz = SSLight.xyz*(LightCoeff/SSLight.w);\n            \n            \n            \n            //\n            //Diffuse\n            //\n            vec4 PixelC = texture(iChannel2,fragCoord*IRES);\n            vec3 DiffLight = FloatToVec3(PixelC.y)*LightCoeff;\n            if (PPos.y>=0.061) {\n                //Not floor\n                DiffLight *= SmallRay.C;\n            }\n            \n            \n            \n            //\n            //Reflections\n            //\n            vec3 RefLight = vec3(0.);\n            if (SmallRay.M<2) {\n                vec3 RefDir = reflect(Dir,Normal);\n                if (dot(RefDir,SmallRay.N)<0.) RefDir = reflect(RefDir,SmallRay.N);\n                HIT RefHit = Trace(Pos+Dir*CAttr.w+SmallRay.N*eps.x,RefDir,iTime);\n                if (RefHit.M<0) RefLight = SampleSky(RefDir,iTime);\n            }\n            \n            \n            \n            //\n            //Composition\n            //\n            vec3 Composition = mix(DiffLight,RefLight,SchlickFresnel(vec3(0.1),max(0.,dot(-Dir,Normal))));\n            Composition = mix(SSLight.xyz,Composition,SchlickFresnel(vec3(0.5),max(0.,dot(-Dir,Normal))));\n            \n            \n            \n            //\n            //Output\n            //\n            Output = vec4(Composition,1.);\n        } else {\n            //Sky pixel\n            Output = vec4(SampleSky(Dir,iTime),-1.);\n        }\n    }\n    fragColor = Output;\n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"//LEGO Models + TAA\n\nvec4 textureCube(vec2 UV) {\n    //Samples the cubemap\n    float Sign = -mod(floor(UV.y*I1024),2.)*2.+1.;\n    vec3 D = vec3(vec2(UV.x,mod(UV.y,1024.))*I512-1.,Sign);\n    if (UV.y>4096.) D = D.xzy;\n    else if (UV.y>2048.) D = D.zxy;\n    return texture(iChannel3,D);\n}\n\nvec4 UpdateOutput(vec4 Output, int bi, vec3 VPos, inout int WriteIndex) {\n    //Updates Output\n    BRICK CBrick = Bricks[bi];\n    vec4 CBrick0 = vec4(CBrick.P,0.);\n    vec4 CBrick1 = CBrick.Q;\n    BRICKTYPE CBrickType = BrickTypes[CBrick.I];\n    vec3 CBrickSize = CBrickType.BrickDim;\n    //Quaternion coordinate system\n    vec3 CX = CBrick1.xyz;\n    vec2 sincos = vec2(sin(CBrick1.w),cos(CBrick1.w));\n    vec3 RefCZ = normalize(cross(CX,vec3(0.,1.,0.)));\n    vec3 RefCY = cross(RefCZ,CX);\n    vec3 CY = sincos.y*RefCY+sincos.x*RefCZ;\n    vec3 CZ = -sincos.x*RefCY+sincos.y*RefCZ;\n    vec3 CXT = vec3(CX.x,CY.x,CZ.x);\n    vec3 CYT = vec3(CX.y,CY.y,CZ.y);\n    vec3 CZT = vec3(CX.z,CY.z,CZ.z);\n    //Rotate brick\n    bool Intersects = true;\n    vec3 BVP = VPos-vec3(0.5,0.2,0.5)-CBrick0.xyz;\n    BVP = BVP.x*CXT+BVP.y*CYT+BVP.z*CZT;\n    //Plane separation test\n    float CBrickDFSample = DFBox(BVP+(CXT*0.5+CYT*0.2+CZT*0.5),CBrickSize);\n    if (CBrickDFSample>1.22474487139) {\n        Intersects = false;\n    } else if (CBrickDFSample>0.) {\n        for (int axis=0; axis<3; axis++) {\n            //For each axis\n            float BVPA = BVP[axis];\n            float CXA = CXT[axis];\n            float CYA = CYT[axis]*0.4;\n            float CZA = CZT[axis];\n            float VMin = BVPA+min(min(min(0.,CXA),min(CYA,CXA+CYA)),\n                             min(min(CZA,CXA+CZA),min(CYA+CZA,CXA+CYA+CZA)));\n            float VMax = BVPA+max(max(max(0.,CXA),max(CYA,CXA+CYA)),\n                             max(max(CZA,CXA+CZA),max(CYA+CZA,CXA+CYA+CZA)));\n            float BMin = 0.;\n            float BMax = CBrickSize[axis];\n            if (VMin>=BMax || BMin>=VMax) {\n                //No intersection\n                Intersects = false;\n                break;\n            }\n            //Plane in world coordinate system\n            BVPA = (CBrick0.xyz-(VPos-vec3(0.5,0.2,0.5)))[axis];\n            BMin = 0.;\n            BMax = vec3(1.,0.4,1.)[axis];\n            CXA = (CX*CBrickSize.x)[axis];\n            CYA = (CY*CBrickSize.y)[axis];\n            CZA = (CZ*CBrickSize.z)[axis];\n            VMin = BVPA+min(min(min(0.,CXA),min(CYA,CXA+CYA)),\n                             min(min(CZA,CXA+CZA),min(CYA+CZA,CXA+CYA+CZA)));\n            VMax = BVPA+max(max(max(0.,CXA),max(CYA,CXA+CYA)),\n                             max(max(CZA,CXA+CZA),max(CYA+CZA,CXA+CYA+CZA)));\n            if (VMin>=BMax || BMin>=VMax) {\n                //No intersection\n                Intersects = false;\n                break;\n            }\n        }\n    }\n    if (Intersects) {\n        //Brick intersects the current voxel\n        bool UniqueIndex = true;\n        float OUTf = float(bi)+0.5;\n        for (int OutIndex=0; OutIndex<WriteIndex; OutIndex++) {\n            if (abs(Output[OutIndex]-OUTf)<0.1) UniqueIndex = false;\n        }\n        if (UniqueIndex) {\n            Output[WriteIndex] = OUTf;\n            WriteIndex += 1;\n        }\n    }\n    return Output;\n}\n\nvec4 sampleLevel0(vec2 PriorUV) {\n    float YOffset = 2048.+floor(PriorUV.x*I1024)*1024.+floor(PriorUV.y*I1024)*2048.;\n    return textureCube(mod(PriorUV,1024.)+vec2(0.,YOffset));\n}\n\nvoid MIN(inout vec2 Out, vec2 In) {\n    Out = ((Out.x<In.x)?Out:In);\n}\n\nvec4 SampleTextureCatmullRom(vec2 uv) {\n    vec2 samplePos = uv;\n    vec2 texPos1 = floor(samplePos - 0.5) + 0.5;\n    vec2 f = samplePos - texPos1;\n    vec2 w0 = f * ( -0.5 + f * (1.0 - 0.5*f));\n    vec2 w1 = 1.0 + f * f * (-2.5 + 1.5*f);\n    vec2 w2 = f * ( 0.5 + f * (2.0 - 1.5*f) );\n    vec2 w3 = f * f * (-0.5 + 0.5 * f);\n    vec2 w12 = w1 + w2;\n    vec2 offset12 = w2 / w12;\n    vec2 texPos0 = texPos1 - vec2(1.0);\n    vec2 texPos3 = texPos1 + vec2(2.0);\n    vec2 texPos12 = texPos1 + offset12;\n    vec4 result = vec4(0.);\n    result += sampleLevel0( vec2(texPos0.x,  texPos0.y)) * w0.x * w0.y;\n    result += sampleLevel0( vec2(texPos12.x, texPos0.y)) * w12.x * w0.y;\n    result += sampleLevel0( vec2(texPos3.x,  texPos0.y)) * w3.x * w0.y;\n    result += sampleLevel0( vec2(texPos0.x,  texPos12.y)) * w0.x * w12.y;\n    result += sampleLevel0( vec2(texPos12.x, texPos12.y)) * w12.x * w12.y;\n    result += sampleLevel0( vec2(texPos3.x,  texPos12.y)) * w3.x * w12.y;\n    result += sampleLevel0( vec2(texPos0.x,  texPos3.y)) * w0.x * w3.y;\n    result += sampleLevel0( vec2(texPos12.x, texPos3.y)) * w12.x * w3.y;\n    result += sampleLevel0( vec2(texPos3.x,  texPos3.y)) * w3.x * w3.y;\n    return max(vec4(0.,0.,0.,1.),result);\n}\n\nvoid mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir) {\n    vec4 Output = texture(iChannel3,rayDir);\n    vec2 UV; vec3 aDir = abs(rayDir);\n    if (aDir.z>max(aDir.x,aDir.y)) {\n        //Z-side\n        UV = floor(((rayDir.xy/aDir.z)*0.5+0.5)*1024.)+0.5;\n        if (rayDir.z<0.) UV.y += 1024.;\n    } else if (aDir.x>aDir.y) {\n        //X-side\n        UV = floor(((rayDir.yz/aDir.x)*0.5+0.5)*1024.)+0.5;\n        if (rayDir.x>0.) UV.y += 2048.;\n        else UV.y += 3072.;\n    } else {\n        //Y-side\n        UV = floor(((rayDir.xz/aDir.y)*0.5+0.5)*1024.)+0.5;\n        if (rayDir.y>0.) UV.y += 4096.;\n        else UV.y += 5120.;\n    }\n    if (UV.y<1536.) {\n        if (iFrame>=2) {\n            //Stop early\n            fragColor = Output;\n            return;\n        } else {\n            //SDF volumes\n            if (UV.y<32.) {\n                //OnlySlope\n                vec3 VPos = vec3(floor(mod(UV.x,32.))*I31,floor(UV.x*I32)*I31*0.8,floor(UV.y)*I31);\n                Output.xy = vec2(DFOnlySlope(VPos),textureCube(vec2(UV.x+32.,UV.y)).x);\n            } else if (UV.y<64.) {\n                //Round111\n                vec3 VPos = vec3(floor(mod(UV.x,32.))*I31,floor(UV.x*I32)*I31*0.8,floor(UV.y-32.)*I31);\n                Output.xy = vec2(DFRound111(VPos),textureCube(vec2(UV.x+32.,UV.y)).x);\n            } else if (UV.y<128.) {\n                //Round131\n                vec3 VPos = vec3(floor(mod(UV.x,32.))*I31,\n                                (floor(UV.x*I32)+floor((UV.y-64.)*I32)*32.)*I31*0.8,floor(mod(UV.y,32.))*I31);\n                Output.xy = vec2(DFRound131(VPos),\n                                 textureCube(vec2(mod(UV.x+32.,1024.),UV.y+floor((UV.x+32.)*I1024)*32.)).x);\n            } else if (UV.y<160.) {\n                //Brick111\n                vec3 VPos = vec3(floor(mod(UV.x,32.))*I31,floor(UV.x*I32)*I31*0.8,floor(UV.y-128.)*I31);\n                Output.xy = vec2(DFBrick(VPos,vec3(1.,0.8,1.)),textureCube(vec2(UV.x+32.,UV.y)).x);\n            } else if (UV.y<224.) {\n                //Grate\n                vec3 VPos = vec3(floor(mod(UV.x,64.))*I31,\n                                (floor(UV.x*I64)+floor((UV.y-160.)*I32)*16.)*I31*0.8,floor(mod(UV.y,32.))*I31);\n                Output.xy = vec2(DFGrate(VPos),\n                                 textureCube(vec2(mod(UV.x+64.,1024.),UV.y+floor((UV.x+64.)*I1024)*32.)).x);\n            } else if (UV.y<352.) {\n                //Brick411\n                vec3 VPos = vec3(floor(mod(UV.x,128.))*I31,\n                                (floor(UV.x*I128)+floor((UV.y-224.)*I32)*8.)*I31*0.8,floor(mod(UV.y-224.,32.))*I31);\n                Output.xy = vec2(DFBrick(VPos,vec3(4.,0.8,1.)),\n                                 textureCube(vec2(mod(UV.x+128.,1024.),UV.y+floor((UV.x+128.)*I1024)*32.)).x);\n            } else if (UV.y<608.) {\n                //Brick412\n                vec3 VPos = vec3(floor(mod(UV.x,128.))*I31,\n                                (floor(UV.x*I128)+floor((UV.y-352.)*I64)*8.)*I31*0.8,floor(mod(UV.y-352.,64.))*I31);\n                Output.xy = vec2(DFBrick(VPos,vec3(4.,0.8,2.)),\n                                 textureCube(vec2(mod(UV.x+128.,1024.),UV.y+floor((UV.x+128.)*I1024)*64.)).x);\n            } else if (UV.y<672.) {\n                //HeadLight\n                vec3 VPos = vec3(floor(mod(UV.x,32.))*I31,\n                                (floor(UV.x*I32)+floor((UV.y-608.)*I32)*32.)*I31*0.8,floor(mod(UV.y-608.,32.))*I31);\n                Output.xy = vec2(DFHeadLight(VPos),\n                                 textureCube(vec2(mod(UV.x+32.,1024.),UV.y+floor((UV.x+32.)*I1024)*32.)).x);\n            } else if (UV.y<800.) {\n                //Inverse Slope\n                vec3 VPos = vec3(floor(mod(UV.x,64.))*I31,\n                                (floor(UV.x*I64)+floor((UV.y-672.)*I32)*16.)*I31*0.8,floor(mod(UV.y-672.,32.))*I31);\n                Output.xy = vec2(DFISlope(VPos,1.),\n                                 textureCube(vec2(mod(UV.x+64.,1024.),UV.y+floor((UV.x+64.)*I1024)*32.)).x);\n            } else if (UV.y<928.) {\n                //Grip\n                vec3 VPos = vec3(floor(mod(UV.x,64.))*I31,\n                                (floor(UV.x*I64)+floor((UV.y-800.)*I32)*16.)*I31*0.8,floor(mod(UV.y-800.,32.))*I31);\n                Output.xy = vec2(DFGrip(VPos),\n                                 textureCube(vec2(mod(UV.x+64.,1024.),UV.y+floor((UV.x+64.)*I1024)*32.)).x);\n            } else if (UV.y<1056.) {\n                //Handle\n                vec3 VPos = vec3(floor(mod(UV.x,64.))*I31,\n                                (floor(UV.x*I64)+floor((UV.y-928.)*I64)*16.)*I31*0.8,floor(mod(UV.y-928.,64.))*I31);\n                Output.xy = vec2(DFHandle(VPos,0.),\n                                 textureCube(vec2(mod(UV.x+64.,1024.),UV.y+min(64.,floor((UV.x+64.)*I1024)*64.))).x);\n            } else if (UV.y<1120.) {\n                //Brick211\n                vec3 VPos = vec3(floor(mod(UV.x,64.))*I31,\n                                (floor(UV.x*I64)+floor((UV.y-1056.)*I32)*16.)*I31*0.8,floor(mod(UV.y-1056.,32.))*I31);\n                Output.xy = vec2(DFBrick(VPos,vec3(2.,0.8,1.)),\n                                 textureCube(vec2(mod(UV.x+64.,1024.),UV.y+floor((UV.x+64.)*I1024)*32.)).x);\n            }\n            //.zw objects\n            if (UV.y<192.) {\n                //Tire\n                vec3 VPos = vec3(floor(mod(UV.x,64.))*I31,\n                                (floor(UV.x*I64)+floor(UV.y*I32)*16.)*I31*0.8,floor(mod(UV.y,32.))*I31);\n                    //DF\n                    float tmpCylDF = length(VPos.xy-vec2(1.));\n                    float DF = max(VPos.z-0.88461538461,max(0.11538461539-VPos.z,tmpCylDF-0.96153846153*0.-0.9));\n                    vec3 rp = VPos-vec3(1.,1.,0.); rp.xy = Repeat(rp.xy,16.);\n                    DF = -smin(-DF,DFBox(rp-vec3(-0.1282,0.771795,-2.),vec3(0.1282,2.,2.46))-0.02,0.05);\n                    rp = VPos-vec3(1.,1.,0.); rp.xy = Rotate(rp.xy,0.19634954); rp.xy = Repeat(rp.xy,16.);\n                    DF = -smin(-DF,DFBox(rp-vec3(-0.1282,0.771795,0.54),vec3(0.1282,2.,5.))-0.02,0.05);\n                    DF = -smin(-DF,tmpCylDF-0.51282,0.1);\n                //Output\n                Output.zw = vec2(DF,textureCube(vec2(mod(UV.x+64.,1024.),UV.y+floor((UV.x+64.)*I1024)*32.)).z);\n            } else if (UV.y<448.) {\n                //Tire Center\n                vec3 VPos = vec3(floor(mod(UV.x,64.))*I31,\n                                (floor(UV.x*I64)+floor((UV.y-192.)*I32)*16.)*I31*0.8,floor(mod((UV.y-192.),32.))*I31);\n                    //DF\n                    float tmpCylDF = length(VPos.xy-vec2(1.));\n                    float DF = max(VPos.z-0.88461538461,max(0.11538461539-VPos.z,tmpCylDF-0.51282));\n                        DF = -smin(-DF,length(VPos-vec3(1.,1.,-0.1))-0.45,0.05);\n                        DF = -smin(-DF,tmpCylDF-0.26,0.05);\n                    DF = smin(DF,max(VPos.z-0.3,max(0.11538461539-VPos.z,tmpCylDF-0.192)),0.05);\n                        DF = smin(DF,DFBox(VPos-vec3(0.9359,0.5,0.13),vec3(0.1282,0.87,0.1282)),0.05);\n                        DF = smin(DF,DFBox(VPos-vec3(0.5,0.9359,0.13),vec3(0.87,0.1282,0.1282)),0.05);\n                //Output\n                Output.zw = vec2(DF,textureCube(vec2(mod(UV.x+64.,1024.),UV.y+floor((UV.x+64.)*I1024)*32.)).z);\n            } else if (UV.y<704.) {\n                //Steering Wheel\n                vec3 VPos = vec3(floor(mod(UV.x,64.))*I31,\n                                (floor(UV.x*I64)+floor((UV.y-448.)*I64)*16.)*I31*0.8,floor(mod(UV.y-448.,64.))*I31);\n                    //DF\n                    float tmpCylDF = length(VPos.xz-vec2(1.));\n                    float DF = max(VPos.y-0.6,max(0.001-VPos.z,tmpCylDF-0.38461538461));\n                    DF = min(DF,length(vec2(length(VPos.xz-vec2(1.))-0.87179,VPos.y-0.6))-0.141);\n                    vec3 rp = VPos-vec3(1.,0.6,1.); rp.xz = Repeat(rp.xz,3.);\n                    DF = min(DF,DFBox(rp-vec3(-0.16,-0.1,0.),vec3(0.32,0.1,0.87179)));\n                    rp = VPos-vec3(1.,0.6,1.); rp.xz = Rotate(rp.xz,1.0471975512); rp.xz = Repeat(rp.xz,3.);\n                    DF = max(DF,-DFBox(rp-vec3(-0.2,-0.3,0.3),vec3(0.4,1.,0.3)));\n                    DF = max(DF,-tmpCylDF+0.1923);\n                //Output\n                Output.zw = vec2(DF,textureCube(vec2(mod(UV.x+64.,1024.),UV.y+floor((UV.x+64.)*I1024)*64.)).z);\n            } else if (UV.y<736.) {\n                //Lever Base (no interior)\n                vec3 VPos = vec3(floor(mod(UV.x,32.))*I31,\n                                (floor(UV.x*I32)+floor((UV.y-704.)*I32)*32.)*I31*0.8,floor(mod(UV.y-704.,32.))*I31);\n                    //DF\n                    float tmpCylDF = length(VPos.xz-vec2(0.5));\n                    float DF = min(max(tmpCylDF-0.397,VPos.y-0.25),length(VPos-vec3(0.5,0.25,0.5))-0.397);\n                    DF = max(DF,-DFBox(VPos-vec3(-1.,0.3,0.4),vec3(4.,4.,0.2)));\n                //Output\n                Output.zw = vec2(DF,textureCube(vec2(mod(UV.x+32.,1024.),UV.y+floor((UV.x+32.)*I1024)*32.)).z);\n            } else if (UV.y<864.) {\n                //Lever\n                vec3 VPos = vec3(floor(mod(UV.x,128.))*I31,\n                                (floor(UV.x*I128)+floor((UV.y-736.)*I32)*8.)*I31*0.8,floor(mod(UV.y-736.,32.))*I31);\n                    //DF\n                    float DF = DFLine(VPos,vec3(0.5,0.5,0.5),vec3(2.423,0.5,0.5))-0.096;\n                    DF = min(DF,max(max(length(VPos.xy-0.5)-0.2564,0.4-VPos.z),VPos.z-0.6));\n                    DF = min(DF,length(VPos-vec3(2.423,0.5,0.5))-0.16);\n                //Output\n                Output.zw = vec2(DF,textureCube(vec2(mod(UV.x+128.,1024.),UV.y+floor((UV.x+128.)*I1024)*32.)).z);\n            } else if (UV.y<992.) {\n                //Rotating Brick Base\n                vec3 VPos = vec3(floor(mod(UV.x,64.))*I31,\n                                (floor(UV.x*I64)+floor((UV.y-864.)*I32)*16.)*I31*0.8,floor(mod(UV.y-864.,32.))*I31);\n                    //DF\n                    float DF = DFBox(VPos-vec3(0.04),vec3(1.92,1.12,0.92))-0.04;\n                    DF = -smin(-DF,DFBox(VPos-vec3(0.1,0.2,0.1),vec3(1.8,2.,2.)),0.05);\n                        DF = -smin(-DF,DFBox(VPos-vec3(-1.,0.6,0.2),vec3(5.,2.,2.)),0.05);\n                    DF = smin(DF,DFBox(VPos-vec3(0.1,0.2,0.1),vec3(1.8,0.2,0.8)),0.05);\n                    DF = smin(DF,DFBox(VPos-vec3(0.9,0.4,0.1),vec3(0.2,0.3,0.8)),0.05);\n                Output.zw = vec2(DF,textureCube(vec2(mod(UV.x+64.,1024.),UV.y+floor((UV.x+64.)*I1024)*32.)).z);\n            } else if (UV.y<1120.) {\n                //Rotating Brick Piece\n                vec3 VPos = vec3(floor(mod(UV.x,64.))*I31,\n                                (floor(UV.x*I64)+floor((UV.y-992.)*I32)*16.)*I31*0.8,floor(mod(UV.y-992.,32.))*I31);\n                    //DF\n                    float DF = DFBox(VPos-vec3(0.04,1.04,0.04),vec3(1.92,0.12,0.92))-0.04;\n                    DF = min(DF,DFBox(VPos-vec3(0.1,0.4,0.55),vec3(1.8,0.7,0.1)));\n                    DF = min(DF,DFBox(VPos-vec3(0.1,0.4,0.1),vec3(0.1,0.7,0.75)));\n                        DF = min(DF,DFBox(VPos-vec3(1.8,0.4,0.1),vec3(0.1,0.7,0.75)));\n                Output.zw = vec2(DF,textureCube(vec2(mod(UV.x+64.,1024.),UV.y+floor((UV.x+64.)*I1024)*32.)).z);\n            } else if (UV.y<1248.) {\n                //Long Handle\n                vec3 VPos = vec3(floor(mod(UV.x,128.))*I31,\n                                (floor(UV.x*I128)+floor((UV.y-1120.)*I32)*8.)*I31*0.8,floor(mod(UV.y-1120.,32.))*I31);\n                    //DF\n                    float DF = DFBrick(VPos,vec3(2.,0.8,1.));\n                    vec3 syp = vec3(VPos.xy,abs(VPos.z-0.5));\n                    float tmpCyl = length(VPos.xy-vec2(2.5,0.3));\n                    DF = min(DF,DFBox(syp-vec3(0.04,0.04,0.24),vec3(2.46,0.32,0.22))-0.04);\n                    DF = min(DF,-smin(smin(-tmpCyl+0.3,0.5-syp.z,0.04),syp.z-0.2,0.04));\n                    DF = min(DF,max(max(tmpCyl-0.2,0.05-VPos.z),VPos.z-0.95));\n                //Output\n                Output.zw = vec2(DF,textureCube(vec2(mod(UV.x+128.,1024.),UV.y+floor((UV.x+128.)*I1024)*32.)).z);\n            } else if (UV.y<1376.) {\n                //Studgrip\n                vec3 VPos = vec3(floor(mod(UV.x,64.))*I31,\n                                (floor(UV.x*I64)+floor((UV.y-1248.)*I32)*16.)*I31*0.8-0.8,floor(mod(UV.y-1248.,32.))*I31);\n                    //DF\n                    float DF = DFBrick(VPos,vec3(1.,0.8,1.));\n                    DF = smin(DF,DFBox(VPos-vec3(1.,0.,0.244),vec3(0.5,0.4,0.512)),0.05);\n                    float tmpCyl = length(VPos.xy-vec2(1.5,0.35));\n                    DF = min(DF,max(max(tmpCyl-0.4,0.244-VPos.z),VPos.z-0.756));\n                    DF = min(DF,max(max(tmpCyl-0.3,0.01-VPos.z),VPos.z-0.99));\n                    DF = -smin(-DF,tmpCyl-0.2,0.05);\n                Output.zw = vec2(DF,textureCube(vec2(mod(UV.x+64.,1024.),UV.y+floor((UV.x+64.)*I1024)*32.)).z);\n            } else if (UV.y<1440.) {\n                //Vertical Grip\n                 vec3 VPos = vec3(floor(mod(UV.x,32.))*I31,\n                                (floor(UV.x*I32)+floor((UV.y-1376.)*I32)*32.)*I31*0.8,floor(mod(UV.y-1376.,32.))*I31);\n                 //DF\n                 float DF = DFBox(VPos-vec3(0.04),vec3(0.92,0.32,0.92))-0.04;\n                     DF = min(DF,max(max(DFLine(VPos,vec3(0.5,-1.,0.5),vec3(0.5,0.6,0.5))-0.5,0.307-VPos.z),VPos.z-0.692));\n                     DF = max(DF,-length(VPos.xy-vec2(0.5,0.6923))+0.1923);\n                     DF = -smin(-DF,-VPos.y+0.9,0.2);\n                     DF = max(DF,-DFBox(VPos-vec3(0.35,0.6,-1.),vec3(0.3,5.,4.)));\n                Output.zw = vec2(DF,textureCube(vec2(mod(UV.x+32.,1024.),UV.y+floor((UV.x+32.)*I1024)*32.)).z);\n            }\n        }\n    } else if (UV.y<2048.) {\n        //LOGO and acceleration structure\n        if (UV.x<512.) {\n            //LOGO\n            vec2 LUV = vec2(UV.x,UV.y-1536.);\n            if (iFrame>2) {\n                //Stop early\n                fragColor = Output;\n                return;\n            } if (iFrame<2) {\n                //LEGO logo SVG\n                vec2 fragUV = LUV;\n                fragUV.x = 512.-fragUV.x;\n                float normalizer = float(samples * samples);  \n                float fstep = 1.0 / float(samples);\n                for (int sx = 0; sx < samples; sx++) {\n                    for (int sy = 0; sy < samples; sy++) {  \n                        vec2 uv = (fragUV + vec2(float(sx), float(sy)) * fstep)*I512;\n                        uv *= 2.0;\n                        uv -= vec2(1.0);\n                        uv *= 2.24;\n                        if (inPath(uv)) {\n                            Output += vec4(1.0);\n                        }\n                    }\n                }\n                Output = vec4(Output.xyz/normalizer,1.);\n            } else if (iFrame==2) {\n                //LEGO logo gradient\n                vec2 Grad = vec2(0.);\n                for (float i=-2.; i<2.5; i++) {\n                    for (float j=-2.; j<2.5; j++) {\n                        if (i==0. && j==0.) continue;\n                        Grad += normalize(vec2(i,j))*textureCube(UV+vec2(i,j)*3.).x;\n                    }\n                }\n                Output = vec4(normalize(vec3(-Grad.y/16.,0.5,-Grad.x/16.)),1.);\n            }\n        } else if (DFBox(UV-vec2(512.,1536.),vec2(208.,6.))<0.) {\n            //Acceleration structure\n            if (iFrame<=1) {\n                //Initial frame\n                Output = vec4(-1.);\n            } else if (iFrame<=8) {\n                //Building frames\n                vec3 VPos = vec3(mod(UV.x-512.,13.),(floor((UV.x-512.)/13.)+0.5)*0.4,mod(UV.y-1536.,6.));\n                int WriteIndex = 0;\n                for (int lbi=0; lbi<4; lbi++) {\n                    //For each stored index\n                    if (Output[lbi]<-0.5) break;\n                    WriteIndex += 1;\n                }\n                for (int lbi=(iFrame-2)*16; lbi<min((iFrame-1)*16,99); lbi++) {\n                    //For each new index\n                    if (WriteIndex>3) break;\n                    Output = UpdateOutput(Output,lbi,VPos,WriteIndex);\n                }\n            }\n        } else if (DFBox(UV-vec2(512.,1542.),vec2(99.,3.))<0. && iFrame<7) {\n            //Store bricks\n            BRICK CBrick = Bricks[int(floor(UV.x-512.))];\n            if (UV.y<1542.+1.) Output = vec4(CBrick.P,float(CBrick.I)+0.5);\n            else if (UV.y<1542.+2.) Output = CBrick.Q;\n            else if (UV.y<1542.+3.) Output = vec4(CBrick.C,float(CBrick.M)+0.5);\n        }\n    } else if (UV.y>2048.) {\n        //TAA\n        //*\n        vec2 RESOffset = vec2(floor(mod(floor((UV.y-2048.)*I1024)+0.5,2.))*1024.,floor((UV.y-2048.)*I1024*0.5)*1024.);\n        vec2 CUV = mod(UV,1024.)+RESOffset;\n        if (UV.y>2048. && DFBox(CUV-1.,min(vec2(2048.),RES)-2.)<0.) {\n            //Inside the screen\n            vec3 BCRef = texture(iChannel2,CUV*IRES).xyz;\n            vec3 FinalColor = vec3(BCRef.xyz);\n            //Reprojection\n            float CurrentFrame = float(iFrame);\n            vec2 SSOffset = SSOffsets[iFrame%16];\n            vec3 Pos = texture(iChannel0,vec2(3.5,0.5)*IRES).xyz;\n            vec3 Eye = texture(iChannel0,vec2(2.5,0.5)*IRES).xyz;\n            vec3 Tan; vec3 Bit = TBN(Eye,Tan);\n            mat3 EyeMat = TBN(Eye);\n            vec3 PriorPos = texture(iChannel0,vec2(7.5,0.5)*IRES).xyz;\n            vec3 PriorEye = texture(iChannel0,vec2(6.5,0.5)*IRES).xyz;\n            vec3 PriorTan; vec3 PriorBit = TBN(PriorEye,PriorTan);\n            mat3 PriorEyeMat = TBN(PriorEye);\n            vec3 Dir = normalize(vec3(((CUV+SSOffset)*IRES*2.-1.)*CFOV*ASPECT,1.)*EyeMat);\n            vec4 CAttr = texture(iChannel0,CUV*IRES);\n            float Distance = CAttr.w;\n            if (Distance<-1.5) Distance = CAttr.z;\n            else if (Distance<-0.5) Distance = 100000.; //Sky pixel\n            vec3 PPos = Pos+Dir*Distance;\n            //Prior position\n            vec3 PriorVPos = vec3(dot(PPos-PriorPos,PriorTan),dot(PPos-PriorPos,PriorBit),dot(PPos-PriorPos,PriorEye));\n            vec2 PriorUV = ((PriorVPos.xy/PriorVPos.z)*0.5/(ASPECT*CFOV)+0.5)*RES;\n            if (DFBox(PriorUV-1.,RES-2.)<0.) {\n                //Geometric validation\n                float PDepthMin = 10000.;\n                float PDepthMax = 0.;\n                for (float x=-1.; x<1.5; x+=1.) {\n                    for (float y=-1.; y<1.5; y+=1.) {\n                        vec2 SUV = PriorUV+vec2(x,y);\n                        if (DFBox(SUV-1.,RES-2.)>0.) continue;\n                        vec4 SAttr = texture(iChannel0,SUV*IRES);\n                        if (SAttr.y<-1.5) SAttr.y = SAttr.z;\n                        else if (SAttr.y<-0.5) SAttr.y = 100000.;\n                        vec3 SDir = normalize(vec3(((SUV+SSOffset)*IRES*2.-1.)*CFOV*ASPECT,1.)*PriorEyeMat);\n                        float SDepth = length(PriorPos+SDir*SAttr.y-Pos);\n                        PDepthMin = min(PDepthMin,SDepth);\n                        PDepthMax = max(PDepthMax,SDepth);\n                    }\n                }\n                if (CAttr.w<-0.5 || (Distance>PDepthMin-0.05 && Distance<PDepthMax+0.05)) {\n                    //Valid reprojection\n                    vec4 LFinalColor;\n                    if (length(PriorUV-CUV-SSOffset)>0.02) {\n                        //Catmull-rom sampling\n                        PriorUV -= SSOffsets[(iFrame-1)%16];\n                        LFinalColor = SampleTextureCatmullRom(PriorUV);\n                    } else {\n                        //Nearest neighbour sampling\n                        PriorUV = floor(PriorUV)+0.5;\n                        float YOffset = 2048.+floor(PriorUV.x*I1024)*1024.+floor(PriorUV.y*I1024)*2048.;\n                        LFinalColor = textureCube(mod(PriorUV,1024.)+vec2(0.,YOffset));\n                    }\n                    //Clamping\n                    vec3 FMIN = vec3(1000.);\n                    vec3 FMAX = vec3(0.);\n                    for (float x=-1.; x<1.5; x+=1.) {\n                        for (float y=-1.; y<1.5; y+=1.) {\n                            vec3 Sample = texture(iChannel2,(CUV+vec2(x,y))*IRES).xyz;\n                            //Clamp\n                            FMIN = min(FMIN,Sample);\n                            FMAX = max(FMAX,Sample);\n                        }\n                    }\n                    LFinalColor.xyz = clamp(LFinalColor.xyz,FMIN,FMAX);\n                    //Output\n                    Output = vec4((FinalColor+LFinalColor.xyz*LFinalColor.w)/(LFinalColor.w+1.),min(31.,LFinalColor.w+1.));\n                } else {\n                    //Invalid reprojection\n                    Output = vec4(FinalColor,1.);\n                }\n            } else {\n                //Invalid geometry\n                Output = vec4(FinalColor,1.);\n            }\n        }\n    }\n    //Output\n    fragColor = Output;\n}","name":"Cube A","description":"","type":"cubemap"},{"inputs":[],"outputs":[],"code":"//Constants\nconst float FOV = radians((47.5)/2.);\nconst float LightCoeff = 8.;\nconst float ILightCoeff = 1./LightCoeff;\nconst float M_CLAMP_T = 24.;\nconst vec3 SkyLight = vec3(0.5)*vec3(0.4,0.7,0.99);\nconst vec3 SunLight = vec3(1.,0.8,0.5)*3.;\nconst float SunCR = 0.1;\nconst float PI = 3.14159265;\nconst float PI2 = PI*2.;\nconst float HPI = PI*0.5;\nconst float IPI = 1./PI;\nconst float ToRadians = PI/180.;\nconst float I3 = 1./3.;\nconst float I16 = 1./16.;\nconst float I26 = 1./26.;\nconst float I31 = 1./31.;\nconst float I32 = 1./32.;\nconst float I63 = 1./63.;\nconst float I64 = 1./64.;\nconst float I128 = 1./128.;\nconst float I255 = 1./255.;\nconst float I256 = 1./256.;\nconst float I300 = 1./300.;\nconst float I512 = 1./512.;\nconst float I1024 = 1./1024.;\nconst float I8192 = 1./8192.;\nconst float Sqrt2 = sqrt(2.);\nconst float ISqrt2 = sqrt(0.5);\nconst float Sqrt3 = sqrt(3.);\nconst float ISqrt3 = 1./sqrt(3.);\nconst vec2 eps = vec2(I31*0.51,0.);\nconst float CFOV = tan(FOV);\nconst vec3 LEGOOSlope = normalize(vec3(3.5/6.,1.,0.));\nconst vec3 LEGOISlope = normalize(vec3(1.,-1.,0.));\nconst vec2 SSOffsets8[8] = vec2[8](vec2(0.,0.2),vec2(0.,-0.2),vec2(0.2,0.),vec2(-0.2,0.),\n                                  vec2(0.4),vec2(-0.4),vec2(-0.4,0.4),vec2(0.4,-0.4));\nconst vec2 SSOffsets[16] = vec2[16](vec2(0.),vec2(-0.4,-0.4),vec2(0.,0.2),vec2(0.15,-0.4),vec2(-0.4,-0.15),\n                                    vec2(0.15,0.4),vec2(-0.2,-0.2),vec2(-0.4,0.4),vec2(0.4,0.15),vec2(0.2,-0.2),\n                                    vec2(0.4,0.4),vec2(-0.4,0.15),vec2(0.4,-0.15),\n                                    vec2(-0.15,0.4),vec2(0.4,-0.4),vec2(-0.15,-0.4));\n//Defines\n#define RES iChannelResolution[0].xy\n#define IRES 1./iChannelResolution[0].xy\n#define ASPECT vec2(iChannelResolution[0].x/iChannelResolution[0].y,1.)\n\nstruct HIT { float D; vec3 C; vec3 N; int M; };\nstruct DF { float D; vec3 C; int M; };\nstruct BRICKTYPE { float UVOffset; vec2 UVDim; vec3 BrickDim; };\nstruct BRICK { vec3 P; vec4 Q; vec3 C; int I; int M; };\n\nvec3 SampleSky(vec3 d, float t) {\n    vec3 L = vec3(0.2)*(d.y*0.5+0.5);\n    vec3 InitialDir = vec3(sin(-0.78),0.3,cos(-0.78));\n    if (dot(d,InitialDir)>0.75) L += vec3(2.5);\n    else if (dot(d,vec3(-InitialDir.x,InitialDir.yz))>0.85) L += vec3(2.7,0.4,0.075);\n    //Return\n    return L;\n}\n\n//SDF\nfloat DFBox(vec3 p, vec3 b) {\n    vec3 d = abs(p-b*0.5)-b*0.5;\n    return min(max(d.x,max(d.y,d.z)),0.)+length(max(d,0.));\n}\n\nfloat DFBox(vec2 p, vec2 b) {\n    vec2 d = abs(p-b*0.5)-b*0.5;\n    return min(max(d.x,d.y),0.)+length(max(d,0.));\n}\n\nfloat DFBoxC2(vec2 p, vec2 b) {\n    vec2 d = abs(p)-b;\n    return min(max(d.x,d.y),0.)+length(max(d,0.));\n}\n\nfloat DFExtrude(vec3 p, float sdf, float h) {\n    //By IQ: https://www.shadertoy.com/view/4lyfzw\n    vec2 w = vec2(sdf,abs(p.z)-h);\n  \treturn min(max(w.x,w.y),0.)+length(max(w,0.));\n}\n\nfloat DFDisk(vec3 p) {\n    float d = length(p.xz-0.5)-0.35;\n    vec2 w = vec2(d,abs(p.y));\n    return min(max(w.x,w.y),0.)+length(max(w,0.));\n}\n\nfloat DFLine(vec3 p, vec3 a, vec3 b) {\n    vec3 ba = b-a;\n    float k = dot(p-a,ba)/dot(ba,ba);\n    return length((a+clamp(k,0.,1.)*(b-a))-p);\n}\n\nvec2 Rotate(vec2 p, float ang) {\n    float c = cos(ang), s = sin(ang);\n    return vec2(p.x*c-p.y*s,p.x*s+p.y*c);\n}\n\nvec2 Repeat(vec2 p, float n) {\n    float ang = 2.*3.14159/n;\n    float sector = floor(atan(p.x,p.y)/ang+0.5);\n    p = Rotate(p,sector*ang);\n    return p;\n}\n\nfloat smin(float a, float b, float k) {\n    //https://iquilezles.org/articles/smin\n    float h = max(k-abs(a-b),0.)/k;\n    return min(a,b)-h*h*h*k*(1.0/6.0);\n}\n\nvec3 ARand23(vec2 uv) {\n    //Analytic random\n    return fract(sin(uv.x*uv.y)*vec3(403.125,486.125,513.432)+cos(dot(uv,vec2(13.18273,51.2134)))*vec3(173.137,261.23,203.127));\n}\n\nfloat ARand21(vec2 uv) {\n    //Analytic random\n    return fract(sin(uv.x*uv.y)*403.125+cos(dot(uv,vec2(13.18273,51.2134)))*173.137);\n}\n\nmat3 TBN(vec3 N) {\n    vec3 Nb,Nt;\n    if (abs(N.y)>0.999) {\n        Nb = vec3(1.,0.,0.);\n        Nt = vec3(0.,0.,1.);\n    } else {\n    \tNb = normalize(cross(N,vec3(0.,1.,0.)));\n    \tNt = normalize(cross(Nb,N));\n    }\n    return mat3(Nb.x,Nt.x,N.x,Nb.y,Nt.y,N.y,Nb.z,Nt.z,N.z);\n}\n\nvec3 TBN(vec3 N, out vec3 O) {\n    O = ((abs(N.y)>0.999)?vec3(1.,0.,0.):normalize(cross(N,vec3(0.,1.,0.))));\n    return normalize(cross(O,N));\n}\n\nvec2 ABox(vec2 origin, vec2 dir, vec2 bmin, vec2 bmax) {\n    vec2 tMin = (bmin-origin)*dir;\n    vec2 tMax = (bmax-origin)*dir;\n    vec2 t1 = min(tMin,tMax);\n    vec2 t2 = max(tMin,tMax);\n    return vec2(max(t1.x,t1.y),min(t2.x,t2.y));\n}\n\nvec2 ABox(vec3 origin, vec3 dir, vec3 bmin, vec3 bmax) {\n    vec3 tMin = (bmin-origin)*dir;\n    vec3 tMax = (bmax-origin)*dir;\n    vec3 t1 = min(tMin,tMax);\n    vec3 t2 = max(tMin,tMax);\n    return vec2(max(max(t1.x,t1.y),t1.z),min(min(t2.x,t2.y),t2.z));\n}\n\nfloat ABoxfar(vec3 origin, vec3 dir, vec3 bmin, vec3 bmax) {\n    vec3 tMin = (bmin-origin)*dir;\n    vec3 tMax = (bmax-origin)*dir;\n    vec3 t2 = max(tMin,tMax);\n    return min(t2.z,min(t2.x,t2.y));\n}\n\nfloat ABoxfar(vec2 origin, vec2 dir, vec2 bmin, vec2 bmax) {\n    vec2 tMin = (bmin-origin)*dir;\n    vec2 tMax = (bmax-origin)*dir;\n    vec2 t2 = max(tMin,tMax);\n    return min(t2.x,t2.y);\n}\n\nvec2 ABoxfarNormal(vec2 origin, vec2 dir, vec2 bmin, vec2 bmax, out float dist) {\n    vec2 tMin = (bmin-origin)*dir;\n    vec2 tMax = (bmax-origin)*dir;\n    vec2 t2 = max(tMin,tMax);\n    dist = min(t2.x,t2.y);\n    vec2 signdir = (max(vec2(0.),sign(dir))*2.-1.);\n    if (t2.x<t2.y) return vec2(signdir.x,0.);\n    else return vec2(0.,signdir.y);\n}\n\nvec3 ABoxfarNormal(vec3 origin, vec3 dir, vec3 bmin, vec3 bmax) {\n    vec3 tMin = (bmin-origin)*dir;\n    vec3 tMax = (bmax-origin)*dir;\n    vec3 t1 = min(tMin,tMax);\n    vec3 t2 = max(tMin,tMax);\n    vec3 signdir = (max(vec3(0.),sign(dir))*2.-1.);\n    if (t2.x<min(t2.y,t2.z)) return vec3(signdir.x,0.,0.);\n    else if (t2.y<t2.z) return vec3(0.,signdir.y,0.);\n    else return vec3(0.,0.,signdir.z);\n}\n\nvec2 ABoxNormal(vec3 origin, vec3 dir, vec3 bmin, vec3 bmax, out vec3 N) {\n    vec3 tMin = (bmin-origin)*dir;\n    vec3 tMax = (bmax-origin)*dir;\n    vec3 t1 = min(tMin,tMax);\n    vec3 t2 = max(tMin,tMax);\n    vec3 signdir = -(max(vec3(0.),sign(dir))*2.-1.);\n    if (t1.x>max(t1.y,t1.z)) N = vec3(signdir.x,0.,0.);\n    else if (t1.y>t1.z) N = vec3(0.,signdir.y,0.);\n    else N = vec3(0.,0.,signdir.z);\n    return vec2(max(max(t1.x,t1.y),t1.z),min(min(t2.x,t2.y),t2.z));\n}\n\nvec3 ABoxNormal(vec3 origin, vec3 dir, vec3 bmin, vec3 bmax) {\n    vec3 tMin = (bmin-origin)*dir;\n    vec3 tMax = (bmax-origin)*dir;\n    vec3 t1 = min(tMin,tMax);\n    vec3 t2 = max(tMin,tMax);\n    vec3 signdir = -(max(vec3(0.),sign(dir))*2.-1.);\n    if (t1.x>max(t1.y,t1.z)) return vec3(signdir.x,0.,0.);\n    else if (t1.y>t1.z) return vec3(0.,signdir.y,0.);\n    else return vec3(0.,0.,signdir.z);\n}\n\nvec3 RandSample(vec2 v) {\n    float r=sqrt(1.-v.x*v.x);\n    float phi=2.*3.14159*v.y;\n    return vec3(cos(phi)*r,sin(phi)*r,v.x);\n}\n\nvec3 RandSampleCos(vec2 v) {\n    float theta = sqrt(v.x);\n    float phi = 2.*3.14159*v.y;\n    float x = theta*cos(phi);\n    float z = theta*sin(phi);\n    return vec3(x,z,sqrt(max(0.,1.-v.x)));\n}\n\nvec3 RandSampleCosXYer(vec2 v) {\n    float theta = sqrt(v.x);\n    float phi = 2.*3.14159*v.y;\n    float x = theta*cos(phi);\n    float z = theta*sin(phi);\n    return vec3(x,z,0.);\n}\n\n//Float-Vec conversion\nvec3 FloatToVec3(float v) {\n    int VPInt = floatBitsToInt(v);\n    int VPInt1024 = VPInt%1024;\n    int VPInt10241024 = ((VPInt-VPInt1024)/1024)%1024;\n    return vec3(VPInt1024,VPInt10241024,((VPInt-VPInt1024-VPInt10241024)/1048576))*I1024;\n}\n\nfloat Vec3ToFloat(vec3 v) {\n    ivec3 intv = min(ivec3(floor(v*1024.)),ivec3(1023));\n    return intBitsToFloat(intv.x+intv.y*1024+intv.z*1048576);\n}\n\nvec2 FloatToVec2(float v) {\n    int VPInt = floatBitsToInt(v);\n    int VPInt1 = VPInt%32768;\n    return vec2(VPInt1,((VPInt-VPInt1)/32768))/32768.;\n}\n\nfloat Vec2ToFloat(vec2 v) {\n    ivec2 intv = min(ivec2(floor(v*32768.)),ivec2(32767));\n    return intBitsToFloat(intv.x+intv.y*32768);\n}\n//GGX\nvec3 SchlickFresnel(vec3 r0, float angle) {\n    //Schlick Fresnel approximation\n    return r0+(1.-r0)*pow(1.-angle,5.);\n}\n\nfloat SmithGGXMasking(vec3 wi, vec3 wo, float a2) {\n    //Smith masking function\n    float dotNL = wi.z;\n    float dotNV = wo.z;\n    float denomC = sqrt(a2+(1.-a2)*dotNV*dotNV)+dotNV;\n    return 2.*dotNV/denomC;\n}\n\nfloat SmithGGXMaskingShadowing(vec3 wi, vec3 wo, float alpha) {\n    //Smith masking shadowing function\n    float dotNL = wi.z;\n    float dotNV = wo.z;\n    float denomA = dotNV*sqrt(alpha+(1.-alpha)*dotNL*dotNL);\n    float denomB = dotNL*sqrt(alpha+(1.-alpha)*dotNV*dotNV);\n    return 2.*dotNL*dotNV/(denomA+denomB);\n}\n\nvec3 GgxVndf(vec3 wo, float roughness, float u1, float u2) {\n    //Returns the mini normal\n    vec3 v = normalize(vec3(wo.x*roughness,wo.y*roughness,wo.z));\n    vec3 t1 = (v.z<0.999)?normalize(cross(v,vec3(0.,0.,1.))):vec3(1.,0.,0.);\n    vec3 t2 = cross(t1, v);\n    float a = 1./(1.+v.z);\n    float r = sqrt(u1);\n    float phi = (u2<a)?(u2/a)*PI:PI+(u2-a)/(1.-a)*PI;\n    float p1 = r*cos(phi);\n    float p2 = r*sin(phi)*((u2<a)?1.:v.z);\n    vec3 n = p1*t1+p2*t2+sqrt(max(0.,1.-p1*p1-p2*p2))*v;\n    return normalize(vec3(roughness*n.x,roughness*n.y,max(0.,n.z)));\n}\n\nvoid ImportanceSampleGGX(vec2 uRand, vec3 wo, float Roughness, vec3 SpecularColor, out vec3 wi, out vec3 reflectance) {\n    //Importance sampling\n    float a2 = Roughness*Roughness;\n    vec3 wm = GgxVndf(wo,Roughness,uRand.x,uRand.y);\n    wi = reflect(-wo,wm);\n    if (wi.z>0.) {\n        vec3 F = SchlickFresnel(SpecularColor,dot(wi, wm));\n        float G1 = SmithGGXMasking(wi,wo,a2);\n        float G2 = SmithGGXMaskingShadowing(wi,wo,a2);\n        reflectance = F*(G2/G1);\n    } else {\n        reflectance = vec3(0.);\n    }\n}\n\n\n//SDF\nfloat DFStud(vec3 p) {\n    float d = -smin(-DFLine(p,vec3(0.5,-1.,0.5),vec3(0.5,1.,0.5))+0.3,-p.y+0.2,0.075);\n    d = max(-p.y,smin(d,DFDisk(p),0.05));\n    return d;\n}\n\nfloat DFBrick(vec3 p, vec3 BSize) {\n    float d = DFBox(p-vec3(0.04),BSize-vec3(0.08,0.48,0.08))-0.04;\n    d = -smin(-d,DFBox(p-vec3(0.25,-0.95,0.25),BSize-vec3(0.5,-0.3,0.5))-0.05,0.05);\n    if (min(BSize.x,BSize.z)>1.5) {\n        float LineDF = DFLine(vec3(fract(clamp(p.x,0.5,BSize.x-0.5)-0.5),p.yz),vec3(0.5,-1.,1.),vec3(0.5,1.,1.));\n        d = smin(d,-smin(-max(max(LineDF-0.407,-LineDF+0.3),p.y-(BSize.y-0.45)),p.y,0.05),0.05);\n    } else {\n        float tmpLine = DFLine(vec3(fract(clamp(p.x,0.5,BSize.x-0.5)-0.5),p.yz),vec3(0.5,-1.,0.5),vec3(0.5,2.,0.5));\n        d = min(d,max(max(max(tmpLine-0.2,-tmpLine+0.1),p.y-(BSize.y-0.45)),-p.y));\n    }\n    vec3 StudPos = vec3(clamp(floor(p.x),0.,BSize.x-1.),BSize.y-0.4,clamp(floor(p.z),0.,BSize.z-1.));\n    d = -smin(-d,-smin(-DFLine(p-StudPos,vec3(0.5,-1.,0.5),vec3(0.5,-0.05,0.5))+0.15,-p.y+BSize.y-0.45,0.05),0.05); //Hole under stud\n    d = min(d,DFStud(p-StudPos)); //Studs\n    return d;\n}\n\nfloat DFRound131(vec3 p) {\n    float LineDF = DFLine(p,vec3(0.5,-1.,0.5),vec3(0.5,2.,0.5));\n    float d = max(max(LineDF-0.397,p.y-0.35),-p.y);\n    d = min(d,max(-smin(-LineDF+0.48,-p.y+1.2,0.05),-p.y+0.2));\n    //Stud\n    d = smin(d,max(-smin(-LineDF+0.3,-p.y+1.4,0.07),-p.y+1.2),0.07);\n    d = -smin(-d,LineDF-0.2,0.07);\n    return d;\n}\n\nfloat DFISlope(vec3 p, float Z) {\n    float d = -smin(-DFBox(p-vec3(0.02),vec3(1.96,1.16,Z-0.04))+0.017,-dot(LEGOISlope,p-vec3(1.,0.,0.)),0.03);\n    d = -smin(-d,max(DFBox(p-vec3(1.15,0.2,0.15),vec3(0.75,2.,Z-0.3)),dot(LEGOISlope,p-vec3(1.,0.2,0.))),0.05);\n    //Stud\n    float StudZ = clamp(floor(p.z),0.,Z-1.)+0.5;\n    d = smin(d,-smin(-max(-smin(-DFLine(p,vec3(1.5,-1.,StudZ),vec3(1.5,2.,StudZ))+0.3,-p.y+1.4,0.07),-p.y+0.85),\n    DFLine(p,vec3(1.5,-1.,StudZ),vec3(1.5,2.,StudZ))-0.2,0.07),0.07);\n    d = min(d,DFStud(p-vec3(0.,1.2,StudZ-0.5))); //Studs\n    return d;\n}\n\nfloat DFOnlySlope(vec3 p) {\n    float d = -smin(-DFBox(p-vec3(0.1,0.1,0.1),vec3(0.8,0.8,0.8))+0.1,-dot(LEGOOSlope,p-vec3(0.,0.8,0.)),0.06);\n    return d;\n}\n\nfloat DFHose(vec3 p) {\n    vec3 rp = p-vec3(0.5,0.,0.5);\n    float lrp = length(rp);\n    float d = -smin(rp.y,-max(lrp-0.45,-lrp+0.35),0.02);\n    d = smin(d,DFLine(p,vec3(0.5,0.45,0.5),vec3(0.5,1.15,0.5))-0.2,0.07);\n    //Stud\n    d = smin(d,-smin(smin(-DFLine(p,vec3(0.5,-1.,0.5),vec3(0.5,2.,0.5))+0.3,-p.y+1.4,0.07),p.y-1.2,0.07),0.07);\n    //Arm\n    d = smin(d,DFLine(p,vec3(0.7,0.95,0.5),vec3(1.2,0.95,0.5))-0.2+(p.x-0.7)*0.1,0.1);\n    d = smin(d,max(max(DFLine(p,vec3(0.,0.95,0.5),vec3(3.,0.95,0.5))-0.2,-p.x+1.2),p.x-1.4),0.04);\n    return d;\n}\n\nfloat DFPanel(vec3 p) {\n    float d = DFBox(p-vec3(0.04),vec3(1.92,0.32,0.92))-0.04;\n    d = max(d,-DFBox(p-vec3(0.2,-1.,0.2),vec3(1.6,1.2,0.6)));\n    d = min(d,DFBox(p-vec3(0.05,0.05,0.05),vec3(1.9,1.1,0.))-0.05);\n    return d;\n}\n\nfloat DFHandle(vec3 p, float type) {\n    //Symmetric through the x-axis\n    vec3 syp = vec3(p.xy,abs(p.z-1.));\n    float d = DFBrick(p.zyx,vec3(2.,0.8,1.));\n    //Handle\n    float Z = type*0.4;\n    float tmpCyl = length(p.xy-vec2(1.5,0.3));\n    d = min(d,DFBox(syp-vec3(0.04,0.04,0.74-Z),vec3(1.46,0.32,0.22))-0.04);\n    d = min(d,-smin(smin(-tmpCyl+0.3,1.-Z-syp.z,0.04),syp.z-0.7+Z,0.04));\n    d = min(d,max(max(tmpCyl-0.2,0.05-p.z),p.z-1.95));\n    return d;\n}\n\nfloat DFGrip(vec3 p) {\n    float d = DFBox(p-vec3(0.04,0.44,0.04),vec3(0.92,0.32,0.92))-0.04;\n    //Grip\n    d = min(d,DFBox(p-vec3(0.04,0.44,0.39),vec3(1.36,0.32,0.22))-0.04);\n    d = min(d,-smin(smin(-length(p.xy-vec2(1.45,0.68))+0.37,-p.z+0.65,0.04),-0.35+p.z,0.04));\n    d = max(d,-length(p.xy-vec2(1.5,0.7))+0.2);\n    d = -smin(-d,1.62-p.x,0.08);\n    //Stud\n    d = max(d,-DFBox(p-vec3(0.2,-1.,0.2),vec3(0.6,1.6,0.6)));\n    vec3 StudPos = vec3(0.,0.8,0.);\n    d = max(d,-max(DFLine(p-StudPos,vec3(0.5,-1.,0.5),vec3(0.5,2.,0.5))-0.15,p.y-0.75)); //Hole under stud\n    d = min(d,DFStud(p-StudPos)); //Studs\n    return d;\n}\n\nfloat DFGrate(vec3 p) {\n    float d = DFBox(p-vec3(0.02),vec3(1.96,0.36,0.96))-0.02;\n    d = max(d,-DFBox(p-vec3(0.2,-1.,0.2),vec3(1.6,1.25,0.6)));\n    d = max(d,-DFBox(vec3(p.x+2.,p.y-0.2,fract(p.z*2.5)*0.4-0.2),vec3(8.,1.,0.2)));\n    return d;\n}\n\nfloat DFRound111(vec3 p) {\n    float LineDF = DFLine(p,vec3(0.5,-1.,0.5),vec3(0.5,1.,0.5));\n    float d = -smin(smin(-LineDF+0.499,-p.y+0.4,0.04),p.y-0.3,0.05);\n    d = smin(d,-smin(smin(-max(LineDF-0.397,-LineDF+0.305),-p.y+0.35,0.05),p.y-0.01,0.05),0.05);\n    d = -smin(-d,-smin(-LineDF+0.15,-p.y+0.38,0.05),0.05);\n    d = min(d,DFStud(vec3(p.x,p.y-0.4,p.z))); //Stud\n    return d;\n}\n\nfloat DFHeadLight(vec3 p) {\n    float d = -smin(-DFBox(p-vec3(0.04),vec3(0.92,1.12,0.92))+0.04,DFBox(p-vec3(-1.,0.25,-1.),vec3(1.2,2.,3.)),0.05);\n    //Stud\n    d = smin(d,-smin(-DFLine(p,vec3(0.5,0.7,0.5),vec3(-2.,0.7,0.5))+0.3,p.x,0.07),0.05);\n    d = -smin(-d,min(DFBox(p-vec3(0.35,0.25,0.25),vec3(2.9,0.7,0.5)),DFBox(p-vec3(0.35,-1.,0.25),vec3(0.4,1.95,0.5)))-0.05,0.05);\n    d = -smin(-d,DFLine(p,vec3(0.5,0.7,0.5),vec3(-2.,0.7,0.5))-0.2,0.05);\n    d = smin(d,max(-smin(-DFLine(p-vec3(0.,1.2,0.),vec3(0.5,-1.,0.5),vec3(0.5,1.,0.5))+0.3,-p.y+1.2+0.2,0.075),-p.y+1.2),0.03); //Stud\n    return d;\n}\n\nDF MIN(DF OUT, DF IN) {\n    if (OUT.D>IN.D) return IN;\n    return OUT;\n}\n\nDF SDF(vec3 p) {\n    DF OUT = DF(100000.,vec3(1.),1);\n    \n    //Return\n    return OUT;\n}\n\n//Bricks\nBRICKTYPE BrickTypes[22] = BRICKTYPE[22](\n    BRICKTYPE(0.,vec2(32.),vec3(1.,0.8,1.)), //0, OnlySlope\n    BRICKTYPE(32.,vec2(32.),vec3(1.,0.8,1.)), //1, Round111\n    BRICKTYPE(64.,vec2(32.),vec3(1.,1.6,1.)), //2, Round131\n    BRICKTYPE(128.,vec2(32.),vec3(1.,0.8,1.)), //3, Brick111\n    BRICKTYPE(160.,vec2(64.,32.),vec3(2.,0.8,1.)), //4, Grate\n    BRICKTYPE(224.,vec2(128.,32.),vec3(4.,0.8,1.)), //5, Brick411\n    BRICKTYPE(352.,vec2(128.,64.),vec3(4.,0.8,2.)), //6, Brick412\n    BRICKTYPE(608.,vec2(32.),vec3(1.,1.6,1.)), //7, HeadLight\n    BRICKTYPE(672.,vec2(64.,32.),vec3(2.,1.6,1.)), //8, Inverse Slope\n    BRICKTYPE(800.,vec2(64.,32.),vec3(2.,1.6,1.)), //9, Grip\n    BRICKTYPE(928.,vec2(64.,64.),vec3(2.,0.8,2.)), //10, Handle\n    BRICKTYPE(1056.,vec2(64.,32.),vec3(2.,0.8,1.)), //11, Brick211\n    BRICKTYPE(0.,vec2(64.,32.),vec3(2.,2.,1.)), //12, Tire\n    BRICKTYPE(192.,vec2(64.,32.),vec3(2.,1.6,1.)), //13, Tire Rim\n    BRICKTYPE(448.,vec2(64.,64.),vec3(2.,1.6,2.)), //14, Steering Wheel\n    BRICKTYPE(704.,vec2(32.),vec3(1.,0.8,1.)), //15, Lever Base\n    BRICKTYPE(736.,vec2(128.,32.),vec3(3.,0.8,1.)), //16, Lever\n    BRICKTYPE(864.,vec2(64.,32.),vec3(2.,1.6,1.)), //17, Rotating Brick Base\n    BRICKTYPE(992.,vec2(64.,32.),vec3(2.,1.6,1.)), //18, Rotating Brick Piece\n    BRICKTYPE(1120.,vec2(128.,32.),vec3(3.,0.8,1.)), //19, Long handle\n    BRICKTYPE(1248.,vec2(64.,32.),vec3(2.,1.6,1.)), //20, Studgrip\n    BRICKTYPE(1376.,vec2(32.,32.),vec3(1.,1.6,1.)) //21, Vertical Grip\n);\n\nvec3 StudInfo[22] = vec3[22](\n    vec3(0.,10.,0.), //0\n    vec3(1.,0.599,1.), //1\n    vec3(1.,10.,1.), //2\n    vec3(1.,0.599,1.), //3, Brick111\n    vec3(1.,10.,1.), //4\n    vec3(4.,0.599,1.), //5\n    vec3(4.,0.599,2.), //6\n    vec3(1.,1.399,1.), //7\n    vec3(1.,1.399,1.), //8\n    vec3(1.,0.999,1.), //9, Grip\n    vec3(1.,0.599,2.), //10\n    vec3(2.,0.599,1.), //11\n    vec3(1.,10.,1.), //12\n    vec3(1.,10.,1.), //13\n    vec3(1.,10.,1.), //14\n    vec3(1.,10.,1.), //15\n    vec3(1.,10.,1.), //16, Lever\n    vec3(1.,10.,1.), //17\n    vec3(1.,10.,1.), //18\n    vec3(2.,0.599,1.), //19\n    vec3(1.,10.999,1.), //20\n    vec3(1.,10.,1.) //21\n);\n\nconst vec3 L_SteeringY = normalize(vec3(-sin(radians(40.)),cos(radians(40.)),0.));\nconst vec3 L_SteeringX = normalize(cross(L_SteeringY,vec3(0.,0.,1.)));\nconst vec3 L_SteeringP = vec3(9.15,1.7,2.);\nconst float L_RoofAngle = radians(10.);\nconst vec3 L_RoofY = normalize(vec3(sin(L_RoofAngle),cos(L_RoofAngle),0.));\nconst vec3 L_RoofX = normalize(cross(L_RoofY,vec3(0.,0.,1.)));\nconst vec3 L_RoofP = vec3(5.85,4.55,4.);\nconst float L_ScreenAngle = radians(32.5);\nconst vec3 L_ScreenY = normalize(vec3(-sin(L_ScreenAngle),cos(L_ScreenAngle),0.));\nconst vec3 L_ScreenX = normalize(cross(L_ScreenY,vec3(0.,0.,1.)));\nconst vec3 L_ScreenP = vec3(8.5,3.1,1.); //Rotation point\nconst vec3 L_RedEmissive = vec3(1.,0.1,0.025)*3.;\nconst vec3 L_CarColor = vec3(0.2,0.4,0.8);\nBRICK Bricks[99] = BRICK[99](\n    //Tires\n    BRICK(vec3(3.,-0.05,1.),vec4(1.,0.,0.,0.),vec3(0.2),12,2),\n        BRICK(vec3(3.,-0.05,4.),vec4(1.,0.,0.,0.),vec3(0.2),12,2),\n    BRICK(vec3(9.,-0.05,1.),vec4(1.,0.,0.,0.),vec3(0.2),12,2),\n        BRICK(vec3(9.,-0.05,4.),vec4(1.,0.,0.,0.),vec3(0.2),12,2),\n        //Tire rim\n        BRICK(vec3(3.,-0.05,1.),vec4(1.,0.,0.,0.),vec3(0.9),13,1),\n            BRICK(vec3(5.,-0.05,5.),vec4(-1.,0.,0.,0.),vec3(0.9),13,1),\n        BRICK(vec3(9.,-0.05,1.),vec4(1.,0.,0.,0.),vec3(0.9),13,1),\n            BRICK(vec3(11.,-0.05,5.),vec4(-1.,0.,0.,0.),vec3(0.9),13,1),\n        //Tire rim connector (but actually not)\n        BRICK(vec3(3.,0.8,2.),vec4(1.,0.,0.,0.),vec3(0.6),11,1),\n            BRICK(vec3(3.,0.8,3.),vec4(1.,0.,0.,0.),vec3(0.6),11,1),\n        BRICK(vec3(9.,0.8,2.),vec4(1.,0.,0.,0.),vec3(0.6),11,1),\n            BRICK(vec3(9.,0.8,3.),vec4(1.,0.,0.,0.),vec3(0.6),11,1),\n    \n    //Base 412\n    BRICK(vec3(2.,0.4,2.),vec4(1.,0.,0.,0.),vec3(0.3),6,1),\n    BRICK(vec3(8.,0.4,2.),vec4(1.,0.,0.,0.),vec3(0.3),6,1),\n    BRICK(vec3(8.,0.4,1.),vec4(0.,0.,1.,0.),vec3(0.3),6,1),\n        BRICK(vec3(5.,0.8,1.),vec4(1.,0.,0.,0.),vec3(0.6),6,1),\n        BRICK(vec3(5.,0.8,3.),vec4(1.,0.,0.,0.),vec3(0.6),6,1),\n    \n    //Back headlights low\n    BRICK(vec3(2.,0.8,1.),vec4(1.,0.,0.,0.),L_CarColor,7,1),\n        BRICK(vec3(2.,0.8,2.),vec4(1.,0.,0.,0.),L_CarColor,7,1),\n        BRICK(vec3(2.,0.8,3.),vec4(1.,0.,0.,0.),L_CarColor,7,1),\n        BRICK(vec3(2.,0.8,4.),vec4(1.,0.,0.,0.),L_CarColor,7,1),\n    BRICK(vec3(2.2,2.,1.),vec4(0.,0.,1.,HPI),L_CarColor*0.5,5,1), //411\n        BRICK(vec3(1.8,2.,2.),vec4(-0.04471,-0.999,0.,0.),L_CarColor,0,1),\n        BRICK(vec3(1.8,2.,3.),vec4(-0.04471,-0.999,0.,0.),L_CarColor,0,1),\n        BRICK(vec3(1.8,2.,4.),vec4(-0.04471,-0.999,0.,0.),L_CarColor,0,1),\n        BRICK(vec3(1.8,2.,5.),vec4(-0.04471,-0.999,0.,0.),L_CarColor,0,1),\n    \n    //Back headlights above\n    BRICK(vec3(2.,2.,2.),vec4(1.,0.,0.,0.),vec3(0.3),7,1),\n        BRICK(vec3(2.,2.,3.),vec4(1.,0.,0.,0.),vec3(0.3),7,1),\n    BRICK(vec3(2.2,3.2,2.),vec4(0.,0.,1.,HPI),vec3(0.3),11,1), //211\n        BRICK(vec3(1.8,3.2,1.),vec4(0.,0.,1.,HPI),vec3(0.1),5,1), //411\n    BRICK(vec3(1.4,3.2,1.),vec4(0.,0.,1.,HPI),L_RedEmissive,4,0), //Grate\n        BRICK(vec3(1.4,3.2,3.),vec4(0.,0.,1.,HPI),L_RedEmissive,4,0),\n    \n    //Back headlights side\n    BRICK(vec3(4.,2.,2.),vec4(0.,0.,1.,0.),vec3(0.3),7,1), //To origin\n        BRICK(vec3(4.,3.2,2.2),vec4(-1.,0.,0.,HPI),vec3(1.,1.,0.3),1,0),\n        BRICK(vec3(4.,3.2,1.8),vec4(-1.,0.,0.,HPI),vec3(0.1),11,1),\n        BRICK(vec3(4.,3.2,1.4),vec4(-1.,0.,0.,HPI),L_RedEmissive,4,0),\n    BRICK(vec3(3.,2.,4.),vec4(0.,0.,-1.,0.),vec3(0.3),7,1), //From origin\n        BRICK(vec3(3.,3.2,3.8),vec4(1.,0.,0.,HPI),vec3(1.,1.,0.3),1,0),\n        BRICK(vec3(2.,3.2,4.2),vec4(1.,0.,0.,HPI),vec3(0.3),11,1),\n        BRICK(vec3(2.,3.2,4.6),vec4(1.,0.,0.,HPI),L_RedEmissive,4,0),\n    \n    //Under headlights side\n    BRICK(vec3(4.,1.2,2.),vec4(0.,0.,1.,0.),vec3(0.6),11,1),\n        BRICK(vec3(4.,1.6,2.),vec4(0.,0.,1.,0.),vec3(0.6),11,1),\n    \n    //Seat\n    BRICK(vec3(4.,1.2,2.),vec4(1.,0.,0.,0.),vec3(0.7,0.3,0.2),4,1),\n        BRICK(vec3(4.,1.2,3.),vec4(1.,0.,0.,0.),vec3(0.7,0.3,0.2),4,1),\n    BRICK(vec3(7.,1.2,2.),vec4(0.,0.,1.,0.),vec3(0.7,0.3,0.2),4,1),\n    \n    //Over tires (inverse slope and onlyslope)\n    BRICK(vec3(6.,1.2,2.),vec4(-1.,0.,0.,0.),L_CarColor,8,1),\n        BRICK(vec3(6.,1.2,5.),vec4(-1.,0.,0.,0.),L_CarColor,8,1),\n    BRICK(vec3(4.,2.4,1.),vec4(1.,0.,0.,0.),L_CarColor,0,1),\n        BRICK(vec3(4.,2.4,4.),vec4(1.,0.,0.,0.),L_CarColor,0,1),\n    \n    //On top of back + pipe\n    BRICK(vec3(3.,3.2,1.),vec4(0.,0.,1.,0.),L_CarColor,6,1), //412\n        BRICK(vec3(4.,3.2,1.),vec4(0.,0.,1.,0.),L_CarColor,5,1), //411\n    BRICK(vec3(2.,3.6,3.),vec4(1.,0.,0.,0.),vec3(0.3),7,1),\n        BRICK(vec3(2.2,4.8,3.),vec4(0.,0.,1.,HPI),vec3(0.9),2,1), //Pipe\n    BRICK(vec3(2.,3.6,3.),vec4(0.,0.,-1.,0.),L_CarColor,0,1),\n        BRICK(vec3(3.,4.8,4.),vec4(-1.,0.,0.,0.),L_CarColor,0,1),\n    \n    //Base of roof\n    BRICK(vec3(3.,3.6,4.),vec4(1.,0.,0.,0.),vec3(0.9),2,1),\n        BRICK(vec3(3.,3.6,1.),vec4(1.,0.,0.,0.),vec3(0.9),2,1),\n    BRICK(vec3(4.,4.8,1.),vec4(0.,0.,1.,0.),vec3(0.6),5,1), //411\n        BRICK(vec3(3.,5.2,2.),vec4(1.,0.,0.,0.),vec3(0.6),10,1),\n    \n    //Front\n    BRICK(vec3(12.,0.8,1.),vec4(0.,0.,1.,0.),vec3(0.6),5,1), //411\n        BRICK(vec3(12.,1.2,2.),vec4(-1.,0.,0.,0.),L_CarColor,7,1), //Headlight\n        BRICK(vec3(12.,1.2,5.),vec4(-1.,0.,0.,0.),L_CarColor,7,1),\n    BRICK(vec3(11.8,2.4,2.),vec4(0.,0.,-1.,HPI),vec3(2.),1,0),\n        BRICK(vec3(11.8,2.4,5.),vec4(0.,0.,-1.,HPI),vec3(2.),1,0),\n    \n    //Doors with base and mirrors\n    BRICK(vec3(9.,1.2,1.),vec4(0.,0.,1.,0.),L_CarColor,7,1),\n        BRICK(vec3(9.,2.4,1.2),vec4(-1.,0.,0.,HPI),L_CarColor,21,1), //Vertical Grip\n        BRICK(vec3(6.,1.4,0.8),vec4(1.,0.,0.,-HPI),L_CarColor,19,1), //Door (Long Handle)\n            BRICK(vec3(8.,1.35,2.),vec4(0.,0.999,0.04471,0.),vec3(0.6),20,1), //Studgrip\n            BRICK(vec3(7.22,3.5,0.41),vec4(0.,0.,1.,HPI),vec3(0.9),0,1), //Mirror\n    BRICK(vec3(8.,1.2,5.),vec4(0.,0.,-1.,0.),L_CarColor,7,1),\n        BRICK(vec3(9.,1.4,4.8),vec4(-1.,0.,0.,-HPI),L_CarColor,21,1), //Vertical Grip\n        BRICK(vec3(6.,2.4,5.2),vec4(1.,0.,0.,HPI),L_CarColor,19,1), //Door (Long Handle)\n            BRICK(vec3(7.,1.35,4.),vec4(0.,0.999,-0.04471,0.),vec3(0.6),20,1), //Studgrip\n            BRICK(vec3(7.22,2.5,5.6),vec4(0.,0.,-1.,-HPI),vec3(0.9),0,1), //Mirror\n    \n    //Over wheels forward (211+411)\n    BRICK(vec3(8.,2.4,1.),vec4(1.,0.,0.,0.),L_CarColor,5,1),\n        BRICK(vec3(9.,2.,1.),vec4(1.,0.,0.,0.),L_CarColor,11,1),\n    BRICK(vec3(8.,2.4,4.),vec4(1.,0.,0.,0.),L_CarColor,5,1),\n        BRICK(vec3(9.,2.,4.),vec4(1.,0.,0.,0.),L_CarColor,11,1),\n    \n    //Steering wheel and base\n    BRICK(vec3(9.,1.2,2.),vec4(0.,0.,1.,0.),vec3(0.3),17,1),\n    BRICK(L_SteeringP,vec4(0.,0.,1.,0.69813170079),vec3(0.6),18,1),\n        BRICK(L_SteeringP+L_SteeringY*1.2,vec4(0.,0.,1.,0.69813170079),L_CarColor,1,1),\n        BRICK(L_SteeringP+L_SteeringY*1.2+vec3(0.,0.,1.),vec4(0.,0.,1.,0.69813170079),vec3(3.),1,0),\n        BRICK(L_SteeringP+L_SteeringY*1.6+L_SteeringX*0.5+vec3(0.,0.,-0.5),vec4(0.,0.,1.,0.69813170079),vec3(0.8),14,1),\n    \n    //Hatch and under the hatch\n    BRICK(vec3(11.,1.2,4.),vec4(0.,0.,-1.,0.),vec3(0.3),17,1), //Rotating brick\n        BRICK(vec3(11.,1.2,4.),vec4(0.,0.,-1.,0.),vec3(0.6),18,1),\n        BRICK(vec3(12.,2.4,4.),vec4(-1.,0.,0.,0.),vec3(0.6),10,1),\n    BRICK(vec3(9.,1.2,2.),vec4(1.,0.,0.,0.),vec3(0.3),2,1), //Under\n        BRICK(vec3(9.,1.2,3.),vec4(1.,0.,0.,0.),vec3(0.3),2,1),\n        BRICK(vec3(11.,1.2,2.),vec4(0.,0.,1.,0.),vec3(0.3),0,1),\n        BRICK(vec3(10.,1.2,4.),vec4(0.,0.,-1.,0.),vec3(1.,0.5,0.3)*2.5,0,0),\n    \n    //Roof\n    BRICK(L_RoofP,vec4(-L_RoofX,0.),vec3(0.6),9,1),\n        BRICK(L_RoofP-vec3(0.,0.,1.),vec4(-L_RoofX,0.),vec3(0.6),9,1),\n    BRICK(L_RoofP+L_RoofY*0.8+L_RoofX-vec3(0.,0.,3.),vec4(0.,0.,1.,-L_RoofAngle),L_CarColor,6,1),\n        BRICK(L_RoofP+L_RoofY*0.4+L_RoofX*2.-vec3(0.,0.,3.),vec4(0.,0.,1.,-L_RoofAngle),L_CarColor,6,1),\n        BRICK(L_RoofP+L_RoofY*0.8+L_RoofX*1.-vec3(0.,0.,2.),vec4(L_RoofX,0.),vec3(0.6),10,1),\n    \n    //Levers\n    BRICK(vec3(8.,2.8,1.),vec4(1.,0.,0.,0.),vec3(0.8),15,1), //Lever base\n        BRICK(vec3(8.,2.8,4.),vec4(1.,0.,0.,0.),vec3(0.8),15,1),\n    BRICK(L_ScreenP-L_ScreenY*0.5-L_ScreenX*0.5+vec3(0.,0.,1.),vec4(L_ScreenY,0.),vec3(0.1),16,1), //Lever\n        BRICK(L_ScreenP-L_ScreenY*0.5-L_ScreenX*0.5+vec3(0.,0.,4.),vec4(L_ScreenY,0.),vec3(0.1),16,1)\n);\n\n//Lego logo\nconst int samples = 2;\nconst vec3 positions[225] =\n    vec3[225](vec3(0.9408613367791228, 0.43095909706765456, 0),\n              vec3(0.9264762435267317, 0.44352663509707624, 0),\n              vec3(0.8947861254762883, 0.4638692865687953, 0),\n              vec3(0.8777536433400679, 0.4715814511436973, 0),\n              vec3(0.841995189500208, 0.48193008580309815, 0),\n              vec3(0.8048872251098951, 0.48530129825064333, 0),\n              vec3(0.7861678547856077, 0.4842916850607259, 0),\n              vec3(0.7490796945333518, 0.47672464768502254, 0),\n              vec3(0.7309834472672143, 0.47010427463184123, 0),\n              vec3(0.6967507470536414, 0.45128546857518964, 0),\n              vec3(0.6815966127536668, 0.4397110894047105, 0),\n              vec3(0.6551836294986841, 0.41262743744267205, 0),\n              vec3(0.634461035245403, 0.3809322504759403, 0),\n              vec3(0.626419887197555, 0.3635934525495947, 0),\n              vec3(0.6174678863278233, 0.3359891364381042, 0),\n              vec3(0.47899216991926896, -0.24549629059456585, 0),\n              vec3(0.4741737266143069, -0.2751084016236367, 0),\n              vec3(0.473508033500468, -0.29441126217125624, 0),\n              vec3(0.4778079185647557, -0.33209980412273227, 0),\n              vec3(0.4891422806195873, -0.36776620212046324, 0),\n              vec3(0.5069424579864692, -0.40045137004997605, 0),\n              vec3(0.5306397889869092, -0.42919622179679773, 0),\n              vec3(0.5445221803251843, -0.44179131469092675, 0),\n              vec3(0.575999001128787, -0.4628274056990749, 0),\n              vec3(0.5934512651744912, -0.471028632284476, 0),\n              vec3(0.6313136680076146, -0.48217771366078943, 0),\n              vec3(0.6700652677983625, -0.48548096726553785, 0),\n              vec3(0.7077538097498388, -0.48118108220125, 0),\n              vec3(0.7434202077475696, -0.46984672014641854, 0),\n              vec3(0.7761053756770824, -0.45204654277953654, 0),\n              vec3(0.8048502274239044, -0.4283492117790967, 0),\n              vec3(0.8286956768735618, -0.3993233888235917, 0),\n              vec3(0.8466826379115826, -0.36553773559151465, 0),\n              vec3(0.8557512754292231, -0.33741694258942456, 0),\n              vec3(0.996423388384482, 0.25472647096242323, 0),\n              vec3(1, 0.29294405649279703, 0),\n              vec3(0.9960265197448488, 0.3307089760104401, 0),\n              vec3(0.9846915584576656, 0.3670555420215273, 0),\n              vec3(0.7570787710671805, -0.3279246723576778, 0),\n              vec3(0.7481456607517563, -0.34489128805259295, 0),\n              vec3(0.7363053501222789, -0.3595089915158228, 0),\n              vec3(0.7220133343540593, -0.37147883456812697, 0),\n              vec3(0.705725108622407, -0.38050186903026445, 0),\n              vec3(0.6878961681026325, -0.3862791467229943, 0),\n              vec3(0.6689820079700466, -0.3885117194670758, 0),\n              vec3(0.649438123399958, -0.38690063908326805, 0),\n              vec3(0.6304205367457778, -0.3813442914822551, 0),\n              vec3(0.6058327710290847, -0.3668259574428918, 0),\n              vec3(0.5925016292489125, -0.3537028573471296, 0),\n              vec3(0.5819678219692868, -0.33835579970027974, 0),\n              vec3(0.5720660623804614, -0.31216168851770726, 0),\n              vec3(0.5701398889260951, -0.28352583320630764, 0),\n              vec3(0.7155770729851352, 0.3272211318267263, 0),\n              vec3(0.7245101833005594, 0.3441877475216413, 0),\n              vec3(0.7363504939300369, 0.35880545098487127, 0),\n              vec3(0.7506425096982563, 0.3707752940371754, 0),\n              vec3(0.7669307354299086, 0.37979832849931283, 0),\n              vec3(0.7847596759496831, 0.38557560619204273, 0),\n              vec3(0.803673836082269, 0.38780817893612424, 0),\n              vec3(0.8330139122006925, 0.38387499214489884, 0),\n              vec3(0.8511765563761193, 0.3765710374186516, 0),\n              vec3(0.8670548875320945, 0.36613614277101764, 0),\n              vec3(0.8803725907900135, 0.35302297421472734, 0),\n              vec3(0.8908533512712726, 0.3376841977625116, 0),\n              vec3(0.8982208540972669, 0.3205724794271009, 0),\n              vec3(0.9021987843893928, 0.3021404852212259, 0),\n              vec3(0.49404521200236484, 0.32051485979824523, 0),\n              vec3(0.48453276188440575, 0.3577040643779089, 0),\n              vec3(0.4771903875232675, 0.3751107130887582, 0),\n              vec3(0.4578154766529401, 0.40706596689622404, 0),\n              vec3(0.432829864860236, 0.4345676472763559, 0),\n              vec3(0.4030049704751837, 0.4568443358991251, 0),\n              vec3(0.3691122118278114, 0.47312461443450343, 0),\n              vec3(0.3508814516338892, 0.4787750316912871, 0),\n              vec3(0.3319230072481476, 0.4826370645524623, 0),\n              vec3(0.29392752080375106, 0.4846864612988684, 0),\n              vec3(0.2612007307844826, 0.48048830820567073, 0),\n              vec3(0.2302822471806536, 0.47103805054705644, 0),\n              vec3(0.20168320536497242, 0.4567572335473808, 0),\n              vec3(0.17591474071014757, 0.43806740243099923, 0),\n              vec3(0.15348798858888713, 0.41539010242226715, 0),\n              vec3(0.13491408437389962, 0.3891468787455399, 0),\n              vec3(0.12070416343789314, 0.35975927662517293, 0),\n              vec3(0.1132180666353646, 0.33590866248028545, 0),\n              vec3(-0.025338065404089227, -0.24549634892148534, 0),\n              vec3(-0.030138663741522187, -0.27510780484715514, 0),\n              vec3(-0.03077473905960626, -0.29440849931717467, 0),\n              vec3(-0.026382729388821247, -0.33208369115772834, 0),\n              vec3(-0.021501053563444672, -0.35021629512770946, 0),\n              vec3(-0.0067323828414551645, -0.3844667856656981, 0),\n              vec3(0.01422201609720819, -0.4152246749992118, 0),\n              vec3(0.026835852193426657, -0.4289915274635997, 0),\n              vec3(0.05597077473090595, -0.45269631448625475, 0),\n              vec3(0.07234545200867437, -0.46239235564396874, 0),\n              vec3(0.10834321567353711, -0.47686699975078806, 0),\n              vec3(0.12770761787487328, -0.4814513703741509, 0),\n              vec3(0.16645647691437215, -0.4847091805549651, 0),\n              vec3(0.20413166875492594, -0.4803171708841801, 0),\n              vec3(0.23976561979432254, -0.46886097801576615, 0),\n              vec3(0.27239075643035005, -0.45092623860369346, 0),\n              vec3(0.30103950506079724, -0.4270985893019323, 0),\n              vec3(0.31357036712323705, -0.41315793489678415, 0),\n              vec3(0.3344403332411665, -0.38158898948668446, 0),\n              vec3(0.3489149773479858, -0.3455912258218219, 0),\n              vec3(0.42894164996584827, -0.011973834455500498, 0),\n              vec3(0.42972497189919556, 0.005285807701407088, 0),\n              vec3(0.4243979338193449, 0.022557766661810377, 0),\n              vec3(0.410058067874302, 0.03884635586226634, 0),\n              vec3(0.3951169066462894, 0.04640446369357787, 0),\n              vec3(0.381196346171893, 0.04853615910943173, 0),\n              vec3(0.29306584924039014, 0.048288253738397215, 0),\n              vec3(0.274830481833795, 0.04272753468825939, 0),\n              vec3(0.2605446253882744, 0.030976607914030365, 0),\n              vec3(0.25170207774583986, 0.014529271257721282, 0),\n              vec3(0.24954095118037345, 0.000010362544709030003, 0),\n              vec3(0.25170207774583986, -0.014508546168303221, 0),\n              vec3(0.2605446253882744, -0.030955882824612358, 0),\n              vec3(0.274830481833795, -0.042706809598841385, 0),\n              vec3(0.283547839032084, -0.04635430745454747, 0),\n              vec3(0.31863004442757803, -0.048515434020013674, 0),\n              vec3(0.25202421179653345, -0.32792467235767736, 0),\n              vec3(0.2430911014811088, -0.3448912880525925, 0),\n              vec3(0.22438277766140802, -0.36584357985454286, 0),\n              vec3(0.20067054935175999, -0.380501869030264, 0),\n              vec3(0.18284160883198575, -0.38627914672299396, 0),\n              vec3(0.15420575352058608, -0.3882053201773602, 0),\n              vec3(0.13463670610345768, -0.3845783042799128, 0),\n              vec3(0.11660773985991546, -0.37726960481225597, 0),\n              vec3(0.09378165831698615, -0.3605708705373532, 0),\n              vec3(0.07691326269863996, -0.3383557997002793, 0),\n              vec3(0.06947573809880092, -0.3212402796776524, 0),\n              vec3(0.0647789303657329, -0.29324752838512047, 0),\n              vec3(0.06639001074954098, -0.2737036438150323, 0),\n              vec3(0.20590410104503487, 0.3127127704626628, 0),\n              vec3(0.21430798481922464, 0.33602689053214585, 0),\n              vec3(0.2307763633722193, 0.3590033597484454, 0),\n              vec3(0.24497227602406446, 0.37110352110207073, 0),\n              vec3(0.2612004704622315, 0.3802611176093988, 0),\n              vec3(0.288338328393416, 0.3877891213826372, 0),\n              vec3(0.31743891786417455, 0.3869192865064165, 0),\n              vec3(0.34946754816430725, 0.37512846657511933, 0),\n              vec3(0.3628577585368089, 0.365782121700417, 0),\n              vec3(0.37946114119164776, 0.34811165849076364, 0),\n              vec3(0.3938616180155652, 0.3191469867055984, 0),\n              vec3(0.3981023608114145, 0.2852790298923329, 0),\n              vec3(0.40366307986155214, 0.26704366248573774, 0),\n              vec3(0.40885812964828094, 0.2593136830277175, 0),\n              vec3(0.42314398609380155, 0.24756275625348856, 0),\n              vec3(0.4463802520051028, 0.24175413183231625, 0),\n              vec3(0.470219090251927, 0.2480492150414748, 0),\n              vec3(0.4849219338265358, 0.2599629758397277, 0),\n              vec3(0.4902778529410525, 0.2677196751665549, 0),\n              vec3(-0.4238290609360067, -0.3879545880996168, 0),\n              vec3(-0.42399143141451245, -0.3857869964555996, 0),\n              vec3(-0.3435303791941341, -0.04876145696646751, 0),\n              vec3(-0.1881453922760149, -0.04826752864897948, 0),\n              vec3(-0.17862738206770856, -0.04635430745454769, 0),\n              vec3(-0.16218004541139952, -0.037511759812112966, 0),\n              vec3(-0.15042911863717046, -0.023225903366592502, 0),\n              vec3(-0.14678162078146462, -0.014508546168303545, 0),\n              vec3(-0.1448683995870328, 0.005011261049414758, 0),\n              vec3(-0.15042911863717046, 0.02324662845600997, 0),\n              vec3(-0.16218004541139952, 0.037532484901530376, 0),\n              vec3(-0.17862738206770856, 0.04637503254396521, 0),\n              vec3(-0.19314629078072088, 0.04853615910943141, 0),\n              vec3(-0.3201711275962441, 0.04853615910943141, 0),\n              vec3(-0.2395580256922737, 0.3877292902425807, 0),\n              vec3(-0.013614947063175453, 0.3879753131890342, 0),\n              vec3(0.001553809488533675, 0.3901364397545005, 0),\n              vec3(0.010271166686822708, 0.3937839376102065, 0),\n              vec3(0.024557023132343314, 0.4055348643844355, 0),\n              vec3(0.03339957077477784, 0.42198220104074474, 0),\n              vec3(0.035560697340244474, 0.436501109753757, 0),\n              vec3(0.03339957077477784, 0.45102001846676926, 0),\n              vec3(0.024557023132343314, 0.46746735512307847, 0),\n              vec3(0.010271166686822708, 0.4792182818973075, 0),\n              vec3(0.001553809488533675, 0.4828657797530134, 0),\n              vec3(-0.012965099224478305, 0.4850269063184797, 0),\n              vec3(-0.28168609287903024, 0.48485067306612756, 0),\n              vec3(-0.3043423804615203, 0.47698065006041873, 0),\n              vec3(-0.32039964632717177, 0.4593075787165124, 0),\n              vec3(-0.5323543124694348, -0.42474224806260563, 0),\n              vec3(-0.5337338883980041, -0.43998512769155146, 0),\n              vec3(-0.5289140955923151, -0.45796681352017904, 0),\n              vec3(-0.5177230286574426, -0.4726176319384635, 0),\n              vec3(-0.5012621748910309, -0.48217218549675583, 0),\n              vec3(-0.48805568326353965, -0.4848137981736519, 0),\n              vec3(-0.18106368398796246, -0.4846778019002089, 0),\n              vec3(-0.16282831658136732, -0.47911708285007126, 0),\n              vec3(-0.1485424601358467, -0.46736615607584225, 0),\n              vec3(-0.13969991249341207, -0.4509188194195329, 0),\n              vec3(-0.13780384309711902, -0.4313999159620832, 0),\n              vec3(-0.14369958214938683, -0.41318230940945977, 0),\n              vec3(-0.1559911147398615, -0.3989255304682293, 0),\n              vec3(-0.17289041011825634, -0.3901082881133118, 0),\n              vec3(-0.8900128517657221, -0.3879545880996168, 0),\n              vec3(-0.6958469474912434, 0.43024439706208367, 0),\n              vec3(-0.6970680454957241, 0.44937401560737006, 0),\n              vec3(-0.7052111612782105, 0.46615542921161646, 0),\n              vec3(-0.711534261055692, 0.4730785079255896, 0),\n              vec3(-0.7279951148221036, 0.4828153067067156, 0),\n              vec3(-0.7474699697899465, 0.48548096726553785, 0),\n              vec3(-0.756841335071212, 0.48394209929187737, 0),\n              vec3(-0.7735159477880796, 0.4757893172039107, 0),\n              vec3(-0.7858110168317786, 0.461806574093651, 0),\n              vec3(-0.789707952521583, 0.45298025484212406, 0),\n              vec3(-0.9986204823983503, -0.42409851472697496, 0),\n              vec3(-1, -0.4393413360290013, 0),\n              vec3(-0.9951802071943109, -0.4573230218576287, 0),\n              vec3(-0.9839891402594383, -0.4719738402759131, 0),\n              vec3(-0.9675282864930268, -0.48152839383420565, 0),\n              vec3(-0.9543217948655356, -0.48417000651110154, 0),\n              vec3(-0.6473297955899583, -0.48403401023765885, 0),\n              vec3(-0.629094428183363, -0.4784732911875213, 0),\n              vec3(-0.6148085717378426, -0.4667223644132922, 0),\n              vec3(-0.6059660240954079, -0.4502750277569829, 0),\n              vec3(-0.6040688937631473, -0.43076335438168084, 0),\n              vec3(-0.6099273821747845, -0.41268783466083125, 0),\n              vec3(-0.6220949031388547, -0.3986636757539205, 0),\n              vec3(-0.6387381593037988, -0.3900488756991408, 0),\n              vec3(-0.6530549597150334, -0.3879545880996168, 0),\n              vec3(-0.1875131137334065, -0.3879545880996168, 0),\n              vec3(0.4962741058527447, 0.2909237200595889, 0),\n              vec3(0.9001729001451884, 0.2680691160390561, 0),\n              vec3(0.9714728267726251, 0.392803750658161, 0));\nconst ivec3 triangles[219] = ivec3[219](\n    ivec3(0, 61, 1), ivec3(0, 62, 61), ivec3(0, 224, 62), ivec3(1, 60, 2),\n    ivec3(1, 61, 60), ivec3(2, 60, 3), ivec3(3, 59, 4), ivec3(3, 60, 59),\n    ivec3(4, 58, 5), ivec3(4, 59, 58), ivec3(5, 58, 6), ivec3(6, 57, 7),\n    ivec3(6, 58, 57), ivec3(7, 56, 8), ivec3(7, 57, 56), ivec3(8, 56, 9),\n    ivec3(9, 55, 10), ivec3(9, 56, 55), ivec3(10, 54, 11), ivec3(10, 55, 54),\n    ivec3(11, 53, 12), ivec3(11, 54, 53), ivec3(12, 52, 13), ivec3(12, 53, 52),\n    ivec3(13, 52, 14), ivec3(14, 52, 15), ivec3(15, 51, 16), ivec3(15, 52, 51),\n    ivec3(16, 51, 17), ivec3(17, 50, 18), ivec3(17, 51, 50), ivec3(18, 50, 19),\n    ivec3(19, 49, 20), ivec3(19, 50, 49), ivec3(20, 48, 21), ivec3(20, 49, 48),\n    ivec3(21, 47, 22), ivec3(21, 48, 47), ivec3(22, 47, 23), ivec3(23, 46, 24),\n    ivec3(23, 47, 46), ivec3(24, 46, 25), ivec3(25, 45, 26), ivec3(25, 46, 45),\n    ivec3(26, 44, 27), ivec3(26, 45, 44), ivec3(27, 43, 28), ivec3(27, 44, 43),\n    ivec3(28, 42, 29), ivec3(28, 43, 42), ivec3(29, 41, 30), ivec3(29, 42, 41),\n    ivec3(30, 40, 31), ivec3(30, 41, 40), ivec3(31, 39, 32), ivec3(31, 40, 39),\n    ivec3(32, 38, 33), ivec3(32, 39, 38), ivec3(33, 38, 223),\n    ivec3(33, 223, 34), ivec3(34, 223, 35), ivec3(35, 65, 36),\n    ivec3(35, 223, 65), ivec3(36, 64, 37), ivec3(36, 65, 64),\n    ivec3(37, 63, 224), ivec3(37, 64, 63), ivec3(62, 224, 63),\n    ivec3(66, 143, 67), ivec3(66, 144, 143), ivec3(66, 222, 144),\n    ivec3(67, 143, 68), ivec3(68, 142, 69), ivec3(68, 143, 142),\n    ivec3(69, 142, 70), ivec3(70, 141, 71), ivec3(70, 142, 141),\n    ivec3(71, 140, 72), ivec3(71, 141, 140), ivec3(72, 139, 73),\n    ivec3(72, 140, 139), ivec3(73, 139, 74), ivec3(74, 139, 75),\n    ivec3(75, 138, 76), ivec3(75, 139, 138), ivec3(76, 137, 77),\n    ivec3(76, 138, 137), ivec3(77, 137, 78), ivec3(78, 136, 79),\n    ivec3(78, 137, 136), ivec3(79, 135, 80), ivec3(79, 136, 135),\n    ivec3(80, 134, 81), ivec3(80, 135, 134), ivec3(81, 134, 82),\n    ivec3(82, 133, 83), ivec3(82, 134, 133), ivec3(83, 133, 84),\n    ivec3(84, 132, 85), ivec3(84, 133, 132), ivec3(85, 131, 86),\n    ivec3(85, 132, 131), ivec3(86, 131, 87), ivec3(87, 130, 88),\n    ivec3(87, 131, 130), ivec3(88, 130, 89), ivec3(89, 129, 90),\n    ivec3(89, 130, 129), ivec3(90, 128, 91), ivec3(90, 129, 128),\n    ivec3(91, 128, 92), ivec3(92, 127, 93), ivec3(92, 128, 127),\n    ivec3(93, 126, 94), ivec3(93, 127, 126), ivec3(94, 126, 95),\n    ivec3(95, 125, 96), ivec3(95, 126, 125), ivec3(96, 124, 97),\n    ivec3(96, 125, 124), ivec3(97, 123, 98), ivec3(97, 124, 123),\n    ivec3(98, 123, 99), ivec3(99, 122, 100), ivec3(99, 123, 122),\n    ivec3(100, 121, 101), ivec3(100, 122, 121), ivec3(101, 121, 102),\n    ivec3(102, 120, 103), ivec3(102, 121, 120), ivec3(103, 119, 104),\n    ivec3(103, 120, 119), ivec3(104, 109, 105), ivec3(104, 119, 109),\n    ivec3(105, 107, 106), ivec3(105, 109, 107), ivec3(107, 109, 108),\n    ivec3(109, 119, 110), ivec3(110, 113, 111), ivec3(110, 114, 113),\n    ivec3(110, 118, 114), ivec3(110, 119, 118), ivec3(111, 113, 112),\n    ivec3(114, 118, 115), ivec3(115, 117, 116), ivec3(115, 118, 117),\n    ivec3(144, 147, 145), ivec3(144, 148, 147), ivec3(144, 149, 148),\n    ivec3(144, 222, 149), ivec3(145, 147, 146), ivec3(149, 222, 150),\n    ivec3(150, 222, 151), ivec3(152, 181, 153), ivec3(152, 186, 181),\n    ivec3(152, 187, 186), ivec3(152, 221, 187), ivec3(153, 181, 154),\n    ivec3(154, 165, 155), ivec3(154, 180, 165), ivec3(154, 181, 180),\n    ivec3(155, 159, 156), ivec3(155, 160, 159), ivec3(155, 164, 160),\n    ivec3(155, 165, 164), ivec3(156, 158, 157), ivec3(156, 159, 158),\n    ivec3(160, 163, 161), ivec3(160, 164, 163), ivec3(161, 163, 162),\n    ivec3(165, 180, 166), ivec3(166, 177, 167), ivec3(166, 178, 177),\n    ivec3(166, 180, 178), ivec3(167, 172, 168), ivec3(167, 177, 172),\n    ivec3(168, 171, 169), ivec3(168, 172, 171), ivec3(169, 171, 170),\n    ivec3(172, 177, 173), ivec3(173, 175, 174), ivec3(173, 176, 175),\n    ivec3(173, 177, 176), ivec3(178, 180, 179), ivec3(181, 185, 182),\n    ivec3(181, 186, 185), ivec3(182, 184, 183), ivec3(182, 185, 184),\n    ivec3(187, 193, 188), ivec3(187, 194, 193), ivec3(187, 221, 194),\n    ivec3(188, 190, 189), ivec3(188, 193, 190), ivec3(190, 192, 191),\n    ivec3(190, 193, 192), ivec3(195, 205, 196), ivec3(195, 206, 205),\n    ivec3(195, 211, 206), ivec3(195, 212, 211), ivec3(195, 220, 212),\n    ivec3(196, 205, 197), ivec3(197, 205, 198), ivec3(198, 200, 199),\n    ivec3(198, 205, 200), ivec3(200, 205, 201), ivec3(201, 205, 202),\n    ivec3(202, 205, 203), ivec3(203, 205, 204), ivec3(206, 210, 207),\n    ivec3(206, 211, 210), ivec3(207, 209, 208), ivec3(207, 210, 209),\n    ivec3(212, 218, 213), ivec3(212, 219, 218), ivec3(212, 220, 219),\n    ivec3(213, 218, 214), ivec3(214, 218, 215), ivec3(215, 218, 216),\n    ivec3(216, 218, 217));\nconst int len = 219;\n\nbool sameSide(vec3 p1, vec3 p2, vec3 a, vec3 b) {\n  vec3 cp1 = cross(b - a, p1 - a);\n  vec3 cp2 = cross(b - a, p2 - a);\n\n  return dot(cp1, cp2) >= 0.0;\n}\n\nbool pointInTriangle(vec3 p, vec3 a, vec3 b, vec3 c) {\n  return sameSide(p, a, b, c) && sameSide(p, b, a, c) && sameSide(p, c, a, b);\n}\n\nbool inPath(vec2 p) {\n  for (int i = 0; i < len; i++) {\n    ivec3 triangle = triangles[i];\n    vec3 a = positions[triangle[0]];\n    vec3 b = positions[triangle[1]];\n    vec3 c = positions[triangle[2]];\n\n    if (pointInTriangle(vec3(p, 0.0), a, b, c)) {\n      return true;\n    }\n  }\n\n  return false;\n}","name":"Common","description":"","type":"common"}]}