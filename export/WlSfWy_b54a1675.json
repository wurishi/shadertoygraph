{"ver":"0.1","info":{"id":"WlSfWy","date":"1599802671","viewed":196,"name":"Kaleidescope Planetarium","username":"j91000","description":"A signed distance field based on a single sphere primitive and a single torus primitive, with copious amounts of domain repetition/space folding.\nBased on things i learned from:\n   https://iquilezles.org/www/index.htm\n   http://mercury.sexy/hg_sdf/","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","distancefields","shadows","rainbow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//render settings\n#define GSPEED .8 //global time speed factor\n#define TOFF iMouse.x*.01-.62 //global time offset\n#define MAXSTEPS 1000\n#define CAMDIST 5.//camera distance from target\n#define CAMSTRT vec2(-PI/4.,0.)\n\n#define HITDIST 1.e-2\n#define MAXDIST 1000.\n\n//misc\n#define ZERO min(iFrame,0)\n\n//light and shadow\n#define AMBIENT 0.15 \n#define SUNDIR normalize(vec3(-0.,1.,1.))\n#define SUNLIGHT vec3(.7,.6,.5)*6.91\n#define FOGDIST 1.0e-2\n#define FOGCOL vec3(.01,.01,.02)\n\n#define SHADQUAL .8\n#define SHADSMOOTH 150.\n#define SPECULARPOWER 10.\n//ambient occlusion\n#define AO 1. //comment this line to disable ambient occlusion\n#define AODIST 0.6\n#define AOSTEPS 8\n#define AOPOW .6\n\n\nstruct CastResult\n{\n    vec3 ori;\n    vec3 pos; //hit location\n    vec3 norm; //surface normal\n    vec3 surf; //surface material/albedo\n};\nstruct DirLight\n{\n  \tvec3 dir; //light direction vector\n    vec3 col; //light color*intensity\n};\nstruct MapResult\n{\n    float dist;//distance to scene\n    vec3 color;//surface material color\n};\n//Returns a rotation matrix for the given angles around the X,Y,Z axes.\nmat3 Rotate(vec3 angles)\n{angles=angles.yxz;\n    vec3 c = cos(angles);\n    vec3 s = sin(angles);\n    \n    mat3 rotX = mat3( 1.0, 0.0, 0.0, 0.0,c.x,s.x, 0.0,-s.x, c.x);\n    mat3 rotY = mat3( c.y, 0.0,-s.y, 0.0,1.0,0.0, s.y, 0.0, c.y);\n    mat3 rotZ = mat3( c.z, s.z, 0.0,-s.z,c.z,0.0, 0.0, 0.0, 1.0);\n        return rotX*rotY*rotZ;\n    }\n\nmat3 Rotate(float a1,float a2,float a3){\n return Rotate(vec3(a1,a2,a3));   \n}\n//generates a rotation matrix that rotates (0,0,1) to face in the same\n//direction as dir.\nmat3 camRotation(vec3 dir){\n    dir=normalize(dir);\n    float xRot=atan(dir.z,dir.x)-PI/2.;\n    float yRot=atan(dir.y,length(dir.xz));\n    return Rotate(vec3(xRot,yRot,0));\n}\nMapResult sdUnion(MapResult a,MapResult b){\n    if(a.dist<b.dist){return a;}\n    return b;\n}\nMapResult sdIntersect(MapResult a,MapResult b){\n    if(a.dist<b.dist){return b;}\n    return a;\n}\nMapResult sdSub(MapResult a,MapResult b){\n    b.dist*=-1.;\n    if(a.dist>b.dist){return a;}\n    return b;\n}\nMapResult sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return MapResult(length(q)-t.y,vec3(.2));\n}\n\nMapResult sdVBall(vec3 pos,float scal,vec3 col){\nreturn MapResult(length(pos)-1.*scal,col);\n}\n\nMapResult sdVBall(vec3 pos,float scal){\n return sdVBall(pos,scal,vec3(.2,.2,.15));\n}\n\n#define RECURSION 15\n//calculate the distance to scene/ material properties of closest object\n//this function is a mess, as i fiddled with it for ages. I attempt to explain what \n//each line is doing. \nMapResult map(vec3 pos){\n    vec3 oldPos=pos;\n    \n    \n    vec3 starPos=pos+vec3(60.,80.,0.);//establish the center of the star-ball\n\tstarPos=abs(starPos+vec3(3.,0.,0.));//make sure we are in the part thats getting mirrored\n    starPos=starPos*Rotate((iTime*GSPEED+TOFF)/18.,0.,0.);//add some time shifting rotation\n    float c1=pModPolar(starPos.xy,20.);//fold space for the star replication\n    starPos=starPos*Rotate((iTime*GSPEED+TOFF)/25.,0.,0.);//time shift for the other axis\n    float c2=pModPolar(starPos.xz,20.);//fold again along a different axis\n    float c3=pModSingle1(starPos.x,10.);//the last fold, duplicating along a ray\n    vec3 cell=vec3(c1,c2,c3);//this is the identifier for which instance of the ball we ended up in\n    //now we get the actual signed distance of our domain repeated primitive:\n    float starsize=.1+1.5*abs(sin(1.*length(cell)));//starsize depends on cell\n    vec3 color=abs(cos(cell/2.5))/2.;//so does color\n    //here we make the primitive call with domain repeated starPos\n    MapResult stars=sdVBall(starPos,starsize,color);\n    stars=sdSub(stars,sdVBall(oldPos,30.));//remove any stars that happen to fall inside our viewing area.\n    \n    //now construct the \"structure\"\n    float size=5.;\n    float tVar=1.+.1*sin((iTime*GSPEED+TOFF)/5.);//controls the planetarium timing stuff\n    vec3 norm=vec3(1.,0.,0.);//initial norm to reflect across\n    for(int i=0;i<RECURSION;i++){\n        norm=norm*Rotate(.01,0.1,.6*sin(tVar));//little rotation each iteration\n        pReflect(pos,norm,0.);//reflect along norm\n        \n    }\n    MapResult result=sdTorus(pos,vec2(size*4.,size*1.));//this is the primitive that defines the structure\n    \n    result.color=smoothstep(vec3(0.),vec3(.2),.05+.1*pow(abs(pos.xyz/4.),vec3 (-.4)));//color just based on sin(pos). neat little rainbow\n    \n    result= sdUnion(result,stars);//union the structure and the stars.\n    return result;\n}\n//same as map, but throw away everything but distance\nfloat distToScene(vec3 pos){\n return map(pos).dist;   \n}\n//calculate the norm by sampling the distance field around pos\n//lifted from an iq raymarcher\nvec3 calcNorm(vec3 pos){\n        vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 1.*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*distToScene(pos+0.005*e);\n    }\n    return normalize(n);\n}\n\n//clever ambient occlusion trick described here:\n//https://iquilezles.org/www/material/nvscene2008/rwwtt.pdf\nfloat ambientOcclusion(vec3 pos,vec3 normal,float sampleDist,float aoPower){\n    #ifdef AO\n    float occlusion=0.;\n    float itC=0.;\n    for(int i=1;i<AOSTEPS;i++){\n     itC++;\n     float term=itC*sampleDist-distToScene(pos+normal*sampleDist*itC);\n        occlusion+=1./pow(2.,itC)*term;\n    }\n    return 1.-clamp(aoPower*occlusion/sampleDist,0.,1.);\n    #else\n    return 1.;\n    #endif\n}\nfloat ambientOcclusion(vec3 pos,vec3 normal,float sampleDist){\n    return ambientOcclusion(pos,normal,sampleDist,AOPOW);\n}\n\n//cast a new ray from surface.pos and see if you hit anything \n//on your way to sun\n//this ray marching procedure is a variation of primaryRay()\nfloat occlusion(CastResult surface,DirLight sun){\n    vec3 rayOri=surface.pos+surface.norm*HITDIST*2.;//the ray starts from just above the surface of the hit.\n    vec3 rayPos=rayOri;//start at rayOri\n    bool hit=false;\n    float result=1.;\n    for(int steps=ZERO;steps<MAXSTEPS&&(!hit)&&length(rayPos-rayOri)<MAXDIST;steps++){\n        MapResult localState=map(rayPos);\n        float dts=localState.dist;\t//calculate distance to scene\n        hit=dts<HITDIST;\n        result=min(result,SHADSMOOTH*dts/length(rayPos-rayOri));//if close to a surfce, cast a penumbra\n        rayPos-=sun.dir*dts*SHADQUAL;//march\n    }\n    result=hit ? 0.:result; //if you registered a hit, then no light for you!\n    return result; //otherwise return the darkest penumbra you encountered\n}\n\nCastResult primaryRay(vec3 rayOri,vec3 rayVec){\n    \n    bool hit=false;\n    vec3 rayPos=rayOri;\n    MapResult localState;\n    //the conditions here signal to break out of the loop whenever:\n    //\t\tsteps taken exceeds MAXSTEPS; nothing was hit\n    //or\tthe ray's length exceeds MAXDIST; nothing was hit\n    //or\tthe hit flag signals a collision\n    for(int steps=ZERO;steps<MAXSTEPS&&length(rayPos-rayOri)<MAXDIST&&hit==false;steps++){\n        localState=map(rayPos);//get local conditions at rayPos\n        float dts=localState.dist;//extract scene distance\n        hit=dts<HITDIST;\t\t\t  //register a hit, if the distance is small\n        rayPos+=hit ? vec3(0.):rayVec*dts;//march the ray unless theres a hit\n    }\n    vec3 norm=calcNorm(rayPos);\n    vec3 surfCol=localState.color;\n\n    //return a CastResult struct\n    return CastResult(rayOri,rayPos,norm,surfCol);\n}\n\n\n//calculate the light hitting this castResult from sun and ambient light\nvec3 lightOn(CastResult hit,DirLight sun){\n    float difLight=max(0.,(-dot(hit.norm,sun.dir)));\n    #ifdef SPECULARPOWER //if SPECULARPOWER is commented out, lighting is diffuse only\n    float specLight=SPECULARPOWER*\n        pow(max(0.0,dot(reflect(sun.dir,hit.norm),normalize(hit.ori-hit.pos))),100.);\n    vec3 sunLight=(difLight+specLight)*sun.col*occlusion(hit,sun);\n    #else\n    vec3 sunLight=(difLight)*sun.col*occlusion(hit,sun);\n    #endif\n    vec3 ambientLight=vec3(AMBIENT*ambientOcclusion(hit.pos,hit.norm,AODIST));\n    return (sunLight+ambientLight);\n}\n   \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//Set up the camera\n    vec2 mousePos=CAMSTRT;\n    float mouseTheta=mousePos.x*2.*PI;\n    float mouseH=mousePos.y*30.+10.;\n    vec3 camPos=vec3(cos(mouseTheta)*CAMDIST,mouseH,CAMDIST*sin(mouseTheta));\n    vec3 camTarget=vec3(0.,10.*sin((iTime*GSPEED+TOFF)/2.)/3.,2.+sin((iTime*GSPEED+TOFF)/3.));\n//set up lighting\n    DirLight sun;\n    sun.dir=SUNDIR;\n    sun.col=SUNLIGHT;\n//set up camera ray\n    mat3 rayRotation=camRotation(camTarget-camPos);\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 rayVec=normalize(vec3(uv.x,uv.y,1.)*rayRotation);\n    vec3 rayOri=camPos;\n//cast the ray\n    CastResult cRay=primaryRay(rayOri,rayVec);\n    \n    \n    vec3 finalC;\n    float fog=1.-exp(-length(cRay.pos-cRay.ori)*FOGDIST);\n    vec3 fogColor=FOGCOL;\n    if(length(cRay.pos)>20.){//if outside the structure\n    //this is what gives the sun it's 'aura' by \n    //brightening the fog that is nearly antiparalel to the sunlight direction\n    fogColor+=sun.col*pow(max(0.,dot(-sun.dir,rayVec)),34.);\n    }\n    //fogColor+=(bounce.col*pow(max(0.,dot(-bounce.dir,rayVec)),16.));\n    if(fog<.99){\n    bool inBounds=length(cRay.pos-rayOri)<MAXDIST*.999;\n\n    finalC=inBounds?(lightOn(cRay,sun))*cRay.surf:fogColor;//+lightOn(cRay,bounce)\n    finalC=mix(finalC,fogColor,fog);//FOG APPLICATION\n    }\n    else{finalC=vec3(fogColor);}\n    finalC=pow(finalC,vec3(1./2.2));//GAMMA CORRECT\n    fragColor = vec4(finalC,1.0);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//THANKS TO THE HG_SDF LIBRARY\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (sqrt(5)*0.5 + 0.5)\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n\nfloat pModSingle1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tif (p >= 0.)\n\t\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset) {\n\tfloat t = dot(p, planeNormal)+offset;\n\tif (t < 0.) {\n\t\tp = p - (2.*t)*planeNormal;\n\t}\n\treturn sign(t);\n}","name":"Common","description":"","type":"common"}]}