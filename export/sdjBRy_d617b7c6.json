{"ver":"0.1","info":{"id":"sdjBRy","date":"1647041137","viewed":968,"name":"CUBIC BEZIER + FILL","username":"alro","description":"A series of cubic Bezier curves describe an outline of a shape which is filled using the even-odd rule.","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["2d","bezier","logo","intersection","curve","normal","cubic","polygon","twitter","fill","path","tangent","cardano","reproduction","evenodd"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Cubic Bezier curve outline, fill, tangent and normal\n\n    Based on:\n\n    OTF Lobster Shadertoy render\n    https://www.shadertoy.com/view/Wtt3Wl <-- Long compilation times\n    \n    Cubic Bezier - 2D BBox \n    https://www.shadertoy.com/view/XdVBWd\n\n    Cubic Bezier vs. Line Intersect\n    https://www.shadertoy.com/view/NdjGWz\n\n    https://pomax.github.io/bezierinfo/\n    https://www.particleincell.com/2013/cubic-line-intersection/\n    https://www.math.ucdavis.edu/~kkreith/tutorials/sample.lesson/cardano.html\n    https://en.wikipedia.org/wiki/Even-odd_rule\n\n    Logo\n    https://upload.wikimedia.org/wikipedia/commons/4/4f/Twitter-logo.svg\n\n    SVG path to cubic Bezier Converter\n    https://itchylabs.com/tools/path-to-bezier/\n\n*/\n\n// Draw a smooth outline using linear segments\n#define OUTLINE\n\n// Fill shape using the even-odd rule and Cardano's method\n#define FILL\n\n// Uncomment to draw tangent and normal\n//#define ANALYSIS\n\n// Switch fill and background colours\n//#define INVERT\n\nconst vec3 blue = vec3(0.114, 0.608, 0.941);\n\n#ifdef INVERT\nconst vec3 fillColour = blue;\nconst vec3 backgroundColour = vec3(1);\n#else\nconst vec3 fillColour = vec3(1);\nconst vec3 backgroundColour = blue;\n#endif\n\nconst float outlineSegments = 32.0;\nconst float outlineThickness = 1.0;\n\n#define ZERO min(0, iFrame)\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n#define FOUR_PI 12.5663706144\n#define O3 (1.0 / 3.0)\n\n// Return real cuberoot\nfloat cuberoot(float v) {\n    /*\n    if(v < 0.0){\n        return -pow(-v, O3);\n    }\n    return pow(v, O3);\n    */\n    return sign(v) * pow(abs(v), O3);\n}\n\n// Cardano's method\n// https://pomax.github.io/bezierinfo/#extremities\n// Slightly simplified\n// Given cubic y-coordinates pa, pb, pc, pd, find all roots\nvoid cubicRoots(float pa, float pb, float pc, float pd, inout vec3 roots){\n\n    // Precompute 3.0 * p for a, b, c\n    vec3 pabc3 = 3.0 * vec3(pa, pb, pc);\n\n    float a = (pabc3.x - 6.0 * pb + pabc3.z);  // (3.0 * pa - 6.0 * pb + 3.0 * pc)\n    float b = pabc3.y - pabc3.x;               // (-3.0 * pa + 3.0 * pb)\n    float d = pabc3.y - pabc3.z + pd - pa;     // (-pa + 3.0 * pb - 3.0 * pc + pd)\n\n    a /= d;\n    b /= d;\n    pa /= d;\n    \n    // Precompute a / 3.0\n    float a3 = a * O3;\n\n    // Precompute a^2\n    float a2 = a * a;\n\n    float p = (3.0 * b - a2) * O3 * O3;\n    float p3 = p * p * p;\n\n    // Divide q by 27.0 manually\n    float q = (0.07407407407 * a2 * a - O3 * a * b + pa);\n    float q2 = 0.5 * q;\n    float discriminant = q2 * q2 + p3;\n\n    // Three possible real roots\n    if(discriminant < 0.0){\n\n        float r = sqrt(-p3);\n        float phi = acos(clamp(-q / (2.0 * r), -1.0, 1.0));\n\n        roots.x = phi;\n        roots.y = phi + TWO_PI;\n        roots.z = phi + FOUR_PI;\n\n        roots = 2.0 * cuberoot(r) * cos(roots * O3) - a3;\n\n    }else if(discriminant < 1e-8){\n        // Three real roots, but two of them are equal\n        float u1 = q2 < 0.0 ? cuberoot(-q2) : -cuberoot(q2);\n        roots.x = 2.0 * u1;\n        roots.y = -u1;\n\n        roots.xy -= a3;\n\n    }else{\n        // One real root, two complex roots\n        float sd = sqrt(discriminant);\n        roots.x = cuberoot(sd - q2) - cuberoot(sd + q2) - a3;\n    }\n}\n\n// First derivative of a cubic Bezier. The tangent of the curve.\nvec2 cubicDerivative(vec2 a, vec2 b, vec2 c, vec2 d, float t){\n    float omt = 1.0 - t;\n    vec2 aD = 3.0 * (b - a);\n    vec2 bD = 3.0 * (c - b);\n    vec2 cD = 3.0 * (d - c);\n    return  aD * omt * omt + \n            bD * 2.0 * omt * t + \n            cD * t * t;\n}\n\n// Four control point and distance t between a and d in [0, 1]\nvec2 cubicBezier(vec2 a, vec2 b, vec2 c, vec2 d, float t){\n    float omt = 1.0 - t;\n    return  a * omt * omt * omt + \n            b * 3.0 * omt * omt * t + \n            c * 3.0 * omt * t * t + \n            d * t * t * t;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdSegment(vec2 p, vec2 a, vec2 b){\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\n// https://www.shadertoy.com/view/XdVBWd\n// Cubic distance calculation is complex\n// Discretize the curve with linear segments\n// Performance can be pretty poor but works for single frame render\n// TODO: cull AABB / OOBB\nfloat distanceToCurve(vec2 a, vec2 b, vec2 c, vec2 d, vec2 p){\n    \n    float dist = 1e10;\n    \n    vec2 minimum = min(min(a, b), min(c, d));\n    vec2 maximum = max(max(a, b), max(c, d));\n\n    // Only draw outline for pixels in the curve bounding box\n    if(p.x > (minimum.x - outlineThickness) && p.x < (maximum.x + outlineThickness) &&\n       p.y > (minimum.y - outlineThickness) && p.y < (maximum.y + outlineThickness)){\n\n        const float deltaS = 1.0 / (outlineSegments - 1.0);\n\n        vec2 p0 = a;\n\n        for(float i = 1.0; i < outlineSegments; i += 1.0){\n\n            vec2 p1 = cubicBezier(a, b, c, d, i * deltaS);\n            dist = min(dist, sdSegment(p, p0, p1));\n\n            p0 = p1;\n\n        }\n    }\n    return dist;\n}\n\nint intersectionCount(vec2 a, vec2 b, vec2 c, vec2 d, vec2 uv){\n\n    // Intersections are the roots when the curve is translated so the pixel row is the x-axis\n    vec3 roots = vec3(-1);\n    vec2 shift = vec2(0.0, uv.y);\n\n    vec2 sA = a - shift;\n    vec2 sB = b - shift;\n    vec2 sC = c - shift;\n    vec2 sD = d - shift;\n\n    vec2 minimum = min(min(sA, sB), min(sC, sD));\n    vec2 maximum = max(max(sA, sB), max(sC, sD));\n\n    // Epsilon to avoid near miss artefacts at segment ends\n    float eps = 1e-5;\n\n    // Only check for roots when the curve bounding box intersects the pixel row\n    // If the whole curve is above or below the x-axis, there are no roots for t in [0, 1]\n    if(minimum.y > -eps || maximum.y < eps){\n        return 0;\n    }\n    \n    // Pass the y values of the shifted curve\n    cubicRoots(sA.y, sB.y, sC.y, sD.y, roots);\n    \n    int count = 0;\n\n    vec2 p = vec2(0);\n    \n    for(int i = ZERO; i < 3; i++){\n\n        // If the roots exist on the curve between t = 0 and t = 1\n        if(roots[i] >= -eps && roots[i] <= 1.0 + eps){\n\n            // Find the coordinates of the root \n            p = cubicBezier(sA, sB, sC, sD, roots[i]);\n            \n            // If the intersection is to the right of the pixel\n            if(p.x > uv.x){\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.y /= iResolution.x/iResolution.y;\n    \n    // Flip y-axis\n    uv.y *= -1.0;\n\n    // Zoom out\n    uv *= 500.0;\n    \n    // Logo dimensions are [248, 204]\n    vec2 dim = vec2(248.0, 204.0);\n    \n    uv += 0.5 * dim;\n\n    vec3 col = backgroundColour;\n    float dist = 1e10;\n\n    // Only draw outline for pixels in the logo bounding box\n    bool drawOutline =  uv.x > -outlineThickness && \n                        uv.x < dim.x + outlineThickness && \n                        uv.y > -outlineThickness && \n                        uv.y < dim.y + outlineThickness;\n    int count = 0;\n    \n    for(int i = 0; i < POINT_COUNT; i += 3){\n    \n#ifdef FILL\n        count += intersectionCount(points[i], points[i+1], points[i+2], points[i+3], uv);\n#endif\n\n#ifdef OUTLINE\n        if(drawOutline){\n            dist= min(dist,distanceToCurve(points[i],points[i+1],points[i+2],points[i+3],uv));\n        }\n#endif\n\n    }\n\n    // Fill interior using the even-odd rule\n    // https://en.wikipedia.org/wiki/Even-odd_rule\n    // Find the number of intersections to the right of the pixel.\n    // Odd: inside\n    // Even: outside\n    if(count % 2 > 0){\n       col = fillColour;\n    }\n\n    dist = smoothstep(outlineThickness, max(0.0, outlineThickness-1.0), dist);\n    col = mix(col, fillColour, dist);\n\n#ifdef ANALYSIS\n    // Draw point travelling along the curve\n    float time = iTime * 0.1;\n    float curve = floor(fract(time) * PATH_COUNT);\n    float t = fract(fract(time) * PATH_COUNT);\n    int i = 3 * int(curve);\n\n    vec2 a = points[i];\n    vec2 b = points[i + 1];\n    vec2 c = points[i + 2];\n    vec2 d = points[i + 3];\n\n    vec2 pos = cubicBezier(a, b, c, d, t);\n    dist = length(pos - uv);\n    dist = smoothstep(4.0, 3.0, dist);\n    col = mix(col, vec3(0), dist);\n    \n    float lineLength = 25.0;\n    float minSize = 1.0;\n    float maxSize = 1.5;\n\n    // Draw tangent at the point\n    vec2 tangent = normalize(cubicDerivative(a, b, c, d, t));    \n    dist = sdSegment(uv, pos, pos + lineLength * tangent);\n    dist = smoothstep(maxSize, minSize, dist);\n    col = mix(col, vec3(1, 0, 0), dist);\n\n    // Draw normal at the point\n    vec2 normal = normalize(cross(vec3(tangent, 0.0), vec3(0, 0, 1))).xy;\n    dist = sdSegment(uv, pos, pos + lineLength * normal);\n    dist = smoothstep(maxSize, minSize, dist);\n    col = mix(col, vec3(0.5 + 0.5 * normal, 1.0), dist);\n#endif\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Logo: https://upload.wikimedia.org/wikipedia/commons/4/4f/Twitter-logo.svg\n// Converter: https://itchylabs.com/tools/path-to-bezier/\n// Some very short curves removed\n\n#define POINT_COUNT 51\n#define PATH_COUNT 17.0\n\n// First path is [0, 1, 2, 3] second is [3, 4, 5, 6] etc.\nvec2[] points = vec2[](\n    vec2(221.95, 51.29), \n    vec2(222.10, 53.46), \n    vec2(222.10, 55.63), \n    vec2(222.10, 57.82), \n    vec2(222.10, 124.55), \n    vec2(171.30, 201.51), \n    vec2(78.41, 201.51), \n    vec2(50.97, 201.51), \n    vec2(24.10, 193.65), \n    vec2(1.00, 178.83), \n    vec2(4.99, 179.31), \n    vec2(9.00, 179.55), \n    vec2(13.02, 179.56), \n    vec2(35.76, 179.58), \n    vec2(57.85, 171.95), \n    vec2(75.74, 157.90), \n    vec2(54.13, 157.49), \n    vec2(35.18, 143.40), \n    vec2(28.56, 122.83), \n    vec2(36.13, 124.29), \n    vec2(43.93, 123.99), \n    vec2(51.36, 121.96), \n    vec2(27.80, 117.20), \n    vec2(10.85, 96.50), \n    vec2(10.85, 71.82), \n    vec2(17.87, 75.73), \n    vec2(25.73, 77.90), \n    vec2(33.77, 78.14), \n    vec2(11.58, 63.31), \n    vec2(4.74, 33.79), \n    vec2(18.14, 10.71), \n    vec2(43.78, 42.26), \n    vec2(81.61, 61.44), \n    vec2(122.22, 63.47), \n    vec2(118.15, 45.93), \n    vec2(123.71, 27.55), \n    vec2(136.83, 15.22), \n    vec2(157.17, -3.90), \n    vec2(189.16, -2.92), \n    vec2(208.28, 17.41), \n    vec2(219.59, 15.18), \n    vec2(230.43, 11.03), \n    vec2(240.35, 5.15), \n    vec2(236.58, 16.84), \n    vec2(228.69, 26.77), \n    vec2(218.15, 33.08), \n    vec2(228.16, 31.90), \n    vec2(237.94, 29.22), \n    vec2(247.15, 25.12), \n    vec2(240.37, 35.29), \n    vec2(231.83, 44.14), \n    vec2(221.95, 51.29)\n);","name":"Common","description":"","type":"common"}]}