{"ver":"0.1","info":{"id":"4dtGW8","date":"1449316121","viewed":180,"name":"Flagpole","username":"jackdavenport","description":"A waving flag made out of pixels!","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","displacement","flag","pole"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"#define MAX_ITERATIONS 256\n#define MIN_DISTANCE  .001\n\n#define BIAS .01\n#define SUN_DIR normalize(vec3(45.,30.,-45.))\n#define AMB .3\n\nstruct Ray {\n  vec3 ori;\n  vec3 dir;\n};\nstruct Dist {\n  float dst;\n  int id;\n};\nstruct Hit {\n  vec3 p;\n  int id;\n};\n  \nfloat noise(vec2 p) {\n\n   return 0.;\n    \n}\n    \nfloat distFlag(vec3 p, vec3 pos, vec3 b) {\n\n    const float waveIntensity = .1;\n    const float waveSpeed     = 6.;\n    \n    p.y += waveIntensity * cos(waveSpeed * iTime + p.x) * sin(waveSpeed * iTime + p.z);\n    p.z += waveIntensity * cos(waveSpeed * iTime + p.x) * sin(waveSpeed * iTime + p.z);\n    \n    return length(max(abs(pos - p) - b, 0.));\n    \n}\n\nfloat distPole(vec3 p, vec3 pos, vec2 h) {\n \n    vec3 q = pos - p;\n    vec2 d = abs(vec2(length(q.xz),q.y)) - h;\n    return min(max(d.x,d.y),0.) + length(max(d,0.));\n    \n}\n\nfloat distFloor(vec3 p, float y) {\n \n    return p.y - y;\n    \n}\n\nDist distScene(vec3 p) {\n \n    float dFlag = distFlag (p, vec3(0.,1.3,1.), vec3(2.,1.5,.1));\n    float dPole = distPole (p, vec3(-2.,-3.12,1.), vec2(.3,6.));\n    float dFlor = distFloor(p, -6.);\n    \n    float d = min(min(dFlag,dPole), dFlor);\n\treturn Dist(d, d == dFlag ? 0 : d == dPole ? 1 : 2);\n    \n}\n\nHit raymarch(Ray ray) {\n \n    vec3 p = ray.ori;\n    int id = -1;\n    \n    for(int i = 0; i < MAX_ITERATIONS; i++) {\n     \n        Dist dst = distScene(p);\n        p += ray.dir * dst.dst;\n        \n        if(dst.dst <= MIN_DISTANCE) {\n         \n            id = dst.id;\n            break;\n            \n        }\n        \n    }\n    \n    return Hit(p,id);\n    \n}\n\nmat2 rot2D(float angle) {\n \n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return mat2(c,s,-s,c);\n    \n}\n\nvec3 calcNormal(vec3 p) {\n \n    const vec2 eps = vec2(.1,0.);\n    vec3 n = vec3(distScene(p + eps.xyy).dst - distScene(p - eps.xyy).dst,\n                  distScene(p + eps.yxy).dst - distScene(p - eps.yxy).dst,\n                  distScene(p + eps.yyx).dst - distScene(p - eps.yyx).dst);\n    return normalize(n);\n    \n}\n\nfloat getLighting(Hit hit, Ray ray, vec3 n, bool shadows) {\n  \n    float d = AMB + max(dot(SUN_DIR,n), 0.);\n    \n    if(shadows) {\n     \n        Ray sr = Ray(hit.p + (SUN_DIR * BIAS), SUN_DIR);\n    \tHit sh = raymarch(sr);\n    \n    \tif(sh.id != -1) {\n     \n        \td = AMB;\n        \n    \t}\n        \n    }\n    \n    return d;\n    \n}\n\nvec3 clearColor(vec3 dir) {\n \n    return texture(iChannel0, dir).xyz;\n    \n}\n\nvec3 shadeFlag(Ray ray, Hit hit) {\n \n    vec3  n = calcNormal(hit.p);\n    float d = getLighting(hit, ray, n, false);\n        \n    vec3  c = texture(iChannel1, mod(hit.p.xy / .02, 1.)).xyz;\n    return c*d;\n    \n}\n\nvec3 shadeFloor(Ray ray, Hit hit) {\n \n    vec3 n = calcNormal(hit.p);\n    float d = getLighting(hit, ray, n, true);\n        \n    if(d > AMB) d = 1.;\n    \n    return clearColor(ray.dir) * d;\n    \n}\n\nvec3 shade(Ray ray) {\n \n    Hit scene = raymarch(ray);\n    \n    if(scene.id == 0) {\n     \n        return shadeFlag(ray, scene);\n        \n    } else if(scene.id == 1) {\n     \n        vec3 n  = calcNormal(scene.p);\n        vec3 r  = reflect(ray.dir, n);\n        vec3 rc = vec3(0.);\n        \n        Ray rr = Ray(scene.p + (r * BIAS), r);\n        Hit rh = raymarch(rr);\n        \n        if(rh.id == 0) {\n         \n            rc = shadeFlag(rr,rh);\n            \n        } else if(rh.id == 2) {\n          \n            rc = shadeFloor(rr,rh);\n            \n        } else {\n         \n            rc = clearColor(rr.dir);\n            \n        }\n        \n        float diff = getLighting(scene, ray, n, true) - AMB;\n        float spec = max(pow(dot(r,SUN_DIR), 30.), 0.) * diff;\n        return (diff * rc) + vec3(spec);\n        \n    } else if(scene.id == 2) {\n     \n        return shadeFloor(ray, scene);\n        \n    }\n    \n    return clearColor(ray.dir);\n    \n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - iResolution.xy / 2.) / iResolution.y;\n    vec2  m = (iMouse.xy - iResolution.xy / 2.) / iResolution.y;\n    \n    vec3 ori = vec3(0.,0.,-6.);\n    vec3 dir = vec3(uv, 1.);\n    \n    vec3 col = shade(Ray(ori,dir));\n\tfragColor = vec4(col,1.0);\n}","name":"","description":"","type":"image"}]}