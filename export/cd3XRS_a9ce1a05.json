{"ver":"0.1","info":{"id":"cd3XRS","date":"1679991040","viewed":82,"name":"hw2 complex clock","username":"lukawa","description":"Euler Identity","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["complex"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R              iResolution\n#define Aspect         (R.x / R.y)\n#define UNIT           (1.0 / R.y)\n#define PI             3.1415926535\n#define coohomColor vec3(26.0/255.0,122.0/255.0,248.0/255.0) //背景颜色\n#define N              60.0\n#define theta       3.14 * 0.005 // 指针角度\n\n// 旋转矩阵\nmat2 rot(float angle){\n    return mat2(\n        cos(angle),-sin(angle),\n        sin(angle),cos(angle)\n    );\n}\n\nfloat sdCircle(vec2 uv, vec2 o, float r)\n{\n    return length(o - uv)-r;\n}\nfloat sdLine(vec2 p, in vec2 a, in vec2 b ){\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// 共轭复数\nvec2 conjugate(vec2 z) {\n    return vec2(z.x, -z.y);\n}\n// 模长\nfloat length_z1(vec2 z){\n    return sqrt(z.x * z.x + z.y * z.y);\n}\n// 乘积\nvec2 product(vec2 z1, vec2 z2) {\n    return vec2(z1.x*z2.x-z1.y*z2.y, z1.x*z2.y+z1.y*z2.x);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-R.xy+fragCoord )/R.y/0.9;\n\n    float freq = 2.*PI/N;\n    vec2 offset = vec2(cos(freq), sin(freq));\n    vec2 nth_point = vec2(1., 0.);\n    vec3 color = coohomColor;\n\n    for (float n = 0.; n < N; n += 1.){\n        // Complex multiplication.\n        nth_point = product(nth_point,offset);\n        \n        // draw the circle nodes\n        float circle = sdCircle(uv,nth_point,10.0*UNIT);\n        float t = smoothstep(UNIT,0.0,circle);\n        \n        color = mix(color, vec3(1, 1, 1), t);\n    } \n    \n    // ----- draw the change node -----\n    float index = floor(iTime);\n    vec2 anticlock = vec2(cos(index*freq), sin(index*freq));\n    vec2 clockwise = conjugate(vec2(cos(index*freq), sin(index*freq)));\n    // anticlock:逆时针 \n    // clockwise:顺时针\n    float index_node = sdCircle(uv,clockwise,20.0*UNIT);\n    \n    vec2 v1 =  vec2(0.0,0.00);\n\t//vec2 v2 =  vec2(cos(index*freq), sin(index*freq));\n    vec2 v2 =  conjugate(vec2(cos(index*freq), sin(index*freq)));\n    float pointer = sdLine(uv,v1,v2);\n    \n    float scene = min(index_node,pointer);\n\tfloat _scene = smoothstep(5.0*UNIT,0.0,scene);\n    \n    color = mix(color, vec3(1.0,0,0), _scene);\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}