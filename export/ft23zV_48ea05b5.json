{"ver":"0.1","info":{"id":"ft23zV","date":"1624294226","viewed":268,"name":"IDW Interpolation 2","username":"JoeShader","description":"Inverse Distance Weighting - IDW\nUsed to create an interpolated 'surface' from data points. \nBig thanks to user/iapafoto for the colour palette, isolines and optimising the for loop code. \n\nOriginal: [url]https://www.shadertoy.com/view/7t23Wz[/url]","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["interpolation","idw"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NUM_POINTS 9\n\nfloat distancePower = 2.;\nfloat neighbourDistanceThreshold = 1.5;\nfloat exactThreshold = 0.001; // if we are very close to a point then avoid a divide by zero and set to exact weight of the point\n\nvec3 heatmapGradient(float t) {\n\treturn clamp((pow(t, 1.5) * .8 + .2) * vec3(smoothstep(0., .35, t) + t * .5, smoothstep(.5, 1., t), max(1. - t * 1.7, t * 7. - 6.)), 0., 1.);\n}\n\nvec3 palette(float v) {\n    return heatmapGradient(mod((v-11.)*.1,1.));\n}\n\nfloat isoline(float val, float lg, float ref, float pas, float thickness) {\n    float v = abs(mod(val - ref + pas * .5, pas) - pas * .5) / lg - .1 * thickness;\n    return smoothstep(.2, .8, v);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 points[NUM_POINTS];\n    \n    points[0] = vec3(0.25, 0.25, 0.9);\n    points[1] = vec3(0.5, 0.2, 0.5);\n    points[2] = vec3(0.75, 0.25, 0.9); \n    \n    points[3] = vec3(0.25, 0.5, 0.1);\n    points[4] = vec3(0.15, 0.65, .3);\n    points[5] = vec3(0.75, 0.5, 0.9);\n    \n    points[6] = vec3(iMouse.xy/iResolution.xy, 0.9);\n    points[7] = vec3(0.5, 0.75, 0.5);\n    points[8] = vec3(0.95, 0.85, 0.2);\n            \n    float sumOfAllInverseDistances = 0.;\n    float inverseDistances[NUM_POINTS];\n    float interpolatedValue = 0.;  \n    \n    for (int i = 0; i < NUM_POINTS; ++i) \n    {\n        float dist = max(exactThreshold, length(uv - points[i].xy));  \n        if (dist < neighbourDistanceThreshold) \n        {                            \n            inverseDistances[i] = 1. / pow(dist, distancePower);\n            sumOfAllInverseDistances += inverseDistances[i];\n        }\n        interpolatedValue += points[i].z * inverseDistances[i];\n    }\n    interpolatedValue /= sumOfAllInverseDistances;\n    \n    float lg = 2.*length(vec2(dFdx(interpolatedValue), dFdy(interpolatedValue)));\n\tfloat k1 = isoline(interpolatedValue, lg, .05, .2, 1.),\n       \t  k2 = isoline(interpolatedValue, lg, .025, .05, .01);\n    \n    // paletize value\n    vec3 col = palette(2.5 * interpolatedValue - 1.5); \n    \n    // apply isoline to color\n\tcol *= (.3+(k1*.7));\n    col *= (.7+(k2*.3));\n    \n    //vignette\n    //col *= pow(30.0 * uv.x * uv.y * (1. - uv.x) * (1. - uv.y), .2);\n    \n\tfragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}