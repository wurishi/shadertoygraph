{"ver":"0.1","info":{"id":"ltdXDf","date":"1481990482","viewed":726,"name":"Displacement-map Sphere","username":"twitchingace","description":"A dead simple ray-marched displacement-mapped sphere. It looks a bit dumb because I'm pretty bad at things.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["ray","displacement","sphere","map","marcher","marched"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 eye = vec3(0,0,10);\nvec3 sphere1Pos = vec3(0., 0., 0.);\nfloat sphere1Rad = .75;\nvec3 sphere2Pos = vec3(1., 0., 0.);\nvec3 lightPos = vec3(10., -2., 2.);\n\nconst float maxIterations = 32.;\n\nstruct mat{\n\tfloat spec;\n    float diff;\n    float amb;\n    float shiny;\n};\n\nstruct ray{\n \tvec3 position;\n    vec3 direction;\n};\n    \nmat test = mat(.3,1.,.1,1.);\n\nvec3 getNormal(vec3 point, vec3 sphere, float s){\n    float epsilon = 0.00004; // How far in the plane to grab height from to recalc normals\n    // Convert the point into model coordinates.\n    vec3 p = point - sphere;\n    // Standard mapping of a point on a sphere to a UV\n    float u = (.5 + atan(p.z, p.x)\n               / (2. * 3.14159)) / s / .5 \n        \t+ iTime * .1;\n    float v = (.5 - asin(p.y) / 3.14159) / s / .5;\n    \n    // Get the height af (u,v), (u, v + epsilon), and (u + epsilon, v)\n    // So that we can construct two vectors to cross product\n    float d1 = texture( iChannel0,\n                           vec2(u,v)).r;\n    float d2 = texture( iChannel0,\n                           vec2(u,v + epsilon)).r;\n    float d3 = texture( iChannel0,\n                           vec2(u + epsilon,v)).r;\n    \n    // Construct points we can generate the normal from.\n    vec3 p1 = vec3(u, v, d1 * 0.1);\n    vec3 p2 = vec3(u, v + epsilon, d2 * 0.1);\n    vec3 p3 = vec3(u + epsilon, v, d3 * 0.1);\n    \n    // The normal for a un-displaced sphere\n    vec3 sphereNorm = p;\n    // A vector between a standard \"up\" vector and the normal for the displacement map\n    vec3 planeNorm = vec3(0., 0., 1.) - normalize(cross((p3-p1), (p2 - p1)));\n    \n    return normalize(planeNorm + sphereNorm); // Return a corrected normal\n}\n\nfloat distSphere( vec3 p, float s )\n{\n    // Standard UV wrapping for a sphere\n    float u = (.5 + atan(p.z, p.x)\n               / (2. * 3.14159)) / s / .5;\n    float v = (.5 - asin(p.y) / 3.14159) / s / .5;\n    float disp = texture( iChannel0,\n                           vec2(u + iTime * .1,v)).r;\n    \n    vec3 normal = p;\n    // The exponential smooths out the displacement so we don't have crazy looking poles\n\treturn length(p)-s - (disp * 0.1 * exp(1. - abs(normal.y))/exp(1.));\n}\n\nfloat distFunc(vec3 p)\n{\n    float d1 = distSphere(p - sphere1Pos, sphere1Rad);\n    return d1;\n}\n\nray lookAt(in vec2 uv, in vec3 targetPoint){\n\tvec3 forward = normalize(targetPoint - eye);\n    vec3 up = vec3(0.,1.0,0.0);\n    vec3 right = cross(forward, up);\n    up = cross(forward, right);\n    vec3 ro = eye + forward * .1 + right * uv.x + up * uv.y;\n    vec3 rd = forward;\n    return ray(ro,rd);\n}\n\nvec3 rayMarch(ray marcher){\n    float epsilon = 0.001;\n    float t = 0.;\n    for (float i = 0.; i < maxIterations; i++){\n        vec3 point = marcher.position + marcher.direction * t;\n        float d = distFunc(point);\n        if (d < epsilon){\n            // UV wrapping so we can texture the sphere\n            float u = (.5 + atan(point.z, point.x)\n               / (2. * 3.14159)) / sphere1Rad / .5;\n   \t \t\tfloat v = (.5 - asin(point.y) / 3.14159) / sphere1Rad / .5;\n      \n            // Calc phong illumination\n            vec3 normal = getNormal(point, sphere1Pos, sphere1Rad);\n            vec3 lightDir = normalize(lightPos - point);\n            vec3 viewDir = normalize(eye - point);\n            vec3 reflection = reflect(lightDir, normal);\n            // Add the ambient component\n            float Ip = test.amb;\n            // Add the diffuse component\n            Ip += test.diff * dot(lightDir, normal);\n            // Add the specular component\n            Ip += pow(test.spec * dot(reflection, viewDir), test.shiny);\n            return Ip * texture(iChannel1, vec2(u + iTime * 0.1, v)).xyz;\n        }\n        t+=d;\n    }\n    return vec3(0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    //eye = vec3(0, 1. * sin(iTime), 10.);\n    lightPos = vec3(5. * sin(iTime), 5. * cos(iTime), 3.);\n    vec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n\tuv.x *= iResolution.x / iResolution.y;\n    ray eyeRay = lookAt(uv, vec3(0)); \n\tfragColor = vec4(rayMarch(eyeRay),1.0);\n}","name":"Image","description":"","type":"image"}]}