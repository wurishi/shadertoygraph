{"ver":"0.1","info":{"id":"dltGW7","date":"1682674549","viewed":67,"name":"cubeTexture normal test","username":"aruthlessmachine","description":"cubeTexture normal test","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sdf","raymarcher","cubetexture"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nThis is an experiment of saving a SDF into a Cubemap.\n\nIn blue the SDF defined by a function is raymarched.\nIn gray a an SDF cached into cubemap is raymarched.\n\nHow it works:\nFirst the SDF is projected into the Cunemap and cached.\nLater instead of raymarching the scene SDF function, we raymarch the Cubemap.\n\nThe cubemap store the distance and normals that each projected ray goes towards.\nWe use that information to \"raymarch\" inside the cubemap, updating the distance every step.\n\nThis could be used to store SDF into Cubemaps as an optimization,\nbut there are major drawbacks, as this can't store holes or surfaces behind another,\na 3D texture would be needed for that.\n*/\n\n#define COMPARE\n\nfloat sd_cubemap(vec3 p) {\n    float d = textureLod(iChannel0, p, 0.0).w;\n    d -= (0.9 - length(p));\n    d *= 0.3;\n    return d;\n}\n\nfloat map2(vec3 p) {\n      float  d = sd_cubemap(p);\n    return d;\n}\n\nvec3 getnormal2(vec3 p) {\n    return textureLod(iChannel0, p, 0.0).rgb;\n}\n\nfloat raymarch2(vec3 ro, vec3 rd) {\n    float t = SURF_DIST;\n    vec3 p;\n    for(int i=0;i<IMAGE_MAX_STEPS;++i) {\n        p = ro + rd * t;\n        float d = map2(p);\n        if(abs(d) < SURF_DIST)\n            break;\n        t += d;\n        if(t > MAX_DIST)\n            break;\n    }\n    return t;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2. * fragCoord - iResolution.xy)/iResolution.y;\n    \n    vec3 ro = vec3(0.,0.0,1.);\n        vec3 rd = normalize(vec3(uv,-1.0));\n    \n    \n    float t = raymarch2(ro, rd);\n    vec3 col = vec3(0.0);\n    if(t < 3.0) {\n        vec3 p = ro + rd*t;\n    \tvec3 n = getnormal2(p);\n        col = vec3(0.9,0.1,0.5);\n\n        vec3 ld = normalize(vec3(0.0, 1.0, 1.5));\n        float dif = clamp(dot(n, ld), 0.0, 1.0);\n        col *= dif;\n    }\n    col = pow(col, vec3(0.4545));\n    \n    \n    float ft = mod(iTime,7.0);\n    \n    switch(int(ft)){\n        default:\n        case 0:   \n        col=getnormal2(vec3(uv.x,uv.y,1.0));\n        break;\n        case 1:   \n        col=getnormal2(vec3(uv.x,uv.y,-1.0));\n        break;\n        case 2:   \n        col=getnormal2(vec3(1.0,uv.y,uv.x));\n        break;\n        case 3:   \n        col=getnormal2(vec3(-1.0,uv.y,uv.x));\n        break;\n        case 4:   \n        col=getnormal2(vec3(uv.x,1.0, uv.y));\n        break;\n        case 5:   \n        col=getnormal2(vec3(uv.x,-1.0, uv.y));\n        break;\n        case 6:   \n        col = vec3(1.0);\n        break;\n }\n\n   \n\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define CUBE_MAX_STEPS 128\n#define IMAGE_MAX_STEPS 128\n#define SURF_DIST 0.0001\n#define BOX_DIST 0.01\n#define MAX_DIST 10.0\n#define NORMAL_EPS 0.003\n#define PI  3.141592653589793\n#define TAU 6.283185307179586\n#define CUBEMAP_CACHE\n\nfloat sd_sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sd_box(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) ;\n}\n\nfloat sdCylinder(vec3 p, vec2 h) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nvec2 rotate2d(vec2 p, float x) {\n    float s = sin(x), c = cos(x);\n    return mat2(c,-s,s,c) * p;\n}\n\nfloat map(vec3 p) {\n    float d = sdCylinder(p, vec2(.25));\n\n    float s  = sd_sphere(p+vec3(.0,.5,.0),.3);\n    // return min(d,s);\n    return sd_box(p,vec3(.2));\n}\n\nvec3 getnormal(vec3 p) {\n    const float eps = NORMAL_EPS;\n    vec2 e = vec2(1.,-1.);\n    return normalize(e.xyy*map(p + e.xyy*eps) + \n                     e.yyx*map(p + e.yyx*eps) + \n                     e.yxy*map(p + e.yxy*eps) + \n                     e.xxx*map(p + e.xxx*eps));\n}\n\nfloat raymarch(vec3 ro, vec3 rd) {\n    float t = SURF_DIST;\n    vec3 p;\n    for(int i=0;i<CUBE_MAX_STEPS;++i) {\n        p = ro + rd * t;\n        float d = map(p);\n        if(abs(d) < SURF_DIST)\n            break;\n        t += d;\n        if(t > MAX_DIST)\n            break;\n    }\n    return t;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"void mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir) {\n    vec3 ro = normalize(rayDir);\n    vec3 rd = -normalize(rayDir);\n    float t = raymarch(ro, rd);\n    vec3 n = getnormal(ro + rd*t);\n    fragColor.w = t;\n    fragColor.rgb = n;\n}","name":"Cube A","description":"","type":"cubemap"}]}