{"ver":"0.1","info":{"id":"clGczm","date":"1700029154","viewed":69,"name":"glowy spirals","username":"consindine","description":"logarithmic spirals","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["math"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI acos(-1.0)\n\n/*\nhttps://en.wikipedia.org/wiki/Logarithmic_spiral\n\nalright quick note on how this works\n\nin polar coordinates a logarithmic spiral is defined by\n    r = a * exp(k * theta)\n\nnotice that for\n    r = length(pos)\n    log(length(pos)/a)/k = theta\n\nbut for our pos (x, y)\n    theta = arctan(y, x) + 2.0*PI*n (for some n)\n    \nI basically take the difference between the expected angle for the current radius and the current angle\n*/\n\nfloat spiral_dist(vec2 uv, float wraps, float spirals){\n    float th = wraps*log(length(uv)) - atan(uv.y,uv.x);\n    return length(uv)*min(mod(th, 2.0*PI/spirals), mod(-th, 2.0*PI/spirals));\n}\n\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{\n\n    vec2 uv = (2.0*pos - iResolution.xy)/min(iResolution.x, iResolution.y);\n\n    float dist = spiral_dist(tan(0.2*iTime)*uv, 2.0*cos(0.1*iTime), 1.0 + 1.0*floor(mod(iTime, 10.0)));\n\n    col = 0.01/(dist*dist)*vec4(0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)), 1.0);\n\n}","name":"Image","description":"","type":"image"}]}