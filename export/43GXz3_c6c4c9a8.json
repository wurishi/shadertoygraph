{"ver":"0.1","info":{"id":"43GXz3","date":"1720231163","viewed":59,"name":"Hexagonal Celtic Pattern","username":"Zanthous","description":"Fork of https://www.shadertoy.com/view/WsyXW1 and hex function from https://www.shadertoy.com/view/wtdSzX","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["hexagon","pattern","tile","repeat","celtic"],"hasliked":0,"parentid":"WsyXW1","parentname":"Celtic Pattern - Fixed"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fixed the math in 'Repeating Celtic Pattern' found here: https://www.shadertoy.com/view/3syXDz\nfloat scale = 5.;\n#ifdef FLAT_TOP_HEXAGON\nconst vec2 s = vec2(1.7320508, 1);\n#else\nconst vec2 s = vec2(1, 1.7320508);\n#endif\nfloat lineThickness = 0.02;\n\nfloat hex(in vec2 pp)\n{    \n    pp = abs(pp);\n    \n    #ifdef FLAT_TOP_HEXAGON\n    return max(dot(pp, s*.5), pp.y); // Hexagon.\n    #else\n    return max(dot(pp, s*.5), pp.x); // Hexagon.\n    #endif    \n}\n\nfloat circ(vec2 uv, float r){\n    float d = hex(uv);\n    float c = smoothstep(d, (d+2.*scale/iResolution.y), r);\n    return c;\n}\n\nfloat celt(vec2 uv, float r){\n    \n    // Hexagon Math\n    float hexA = 1./sqrt(3.);\t// Sides:       .57735\n    float hexLD = 2.*hexA;\t\t// Long Diag:  1.154701\n    float hexSD = 1.;\t\t\t// Short Diag: 1\n        \n    float c2 = circ(uv, r - lineThickness);\t// Line Thickness\n    \n    vec2 uv1 = vec2(hexA, -(hexA * hexLD)/2.);\t// Translate: (.57735, -.3334)\n    float c3 = circ(uv + uv1, r);\n    \n    vec2 uv2 = vec2(-hexA, -(hexA * hexLD)/2.);\t// Translate: (-.57735, -.3334)\n    float c4 = circ(uv + uv2, r);\n    \n    vec2 uv3 = vec2(0, (hexLD * hexLD)/2.);\t\t// Translate: (0, .6667)\n    float c5 = circ(uv + uv3, r);\n\n    return c2 - (c3 + c4 + c5);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Hexagon Math\n    float hexA = 1./sqrt(3.);\t// .57735\n    float hexLD = 2.*hexA;\t\t// 1.154701\n    float hexSD = 1.;\t\t\t// 1\n    \n    // Main UV \n    vec2 uv = fragCoord / iResolution.y;\t// uv.x(0 to 1.78), uv.y(0 to 1)\n\tuv.y *= hexLD;\t\t\t\t\t\t\t// uv.x(0 to 1.78), uv.y(0 to 1.16)\n    uv *= scale;\t\t\t\t\t\t\t// uv.x(0 to 8.89), uv.y(0 to 5.78)\n    \n    // Insert Translations here\n    \n    // Offset every other Row\n    float n = mod(uv.y,2.);\t\t// divides uv\n    uv.x += step(1., n)*.5;\t\t// offsets every other row by .5\n    \n    // uv = fract(uv) - Split for testing purposes.\n    vec2 fuv = floor(uv);\t\t// uv.x(0 to 8), uv.y(0 to 5)\n    uv.x -= fuv.x;\t\t\t\t\n    uv.y -= fuv.y;\t\t\t\t\n    \n    // ind. uv's (0 - 1)\n    uv.x *= hexLD;\t\t\t\t// scale uv.x (0 - 1.155)\n    uv.x -= hexLD/2.;\t\t\t// translate uv.x to center.x\n    uv.y -= .5;\t\t\t\t\t// translate uv.y to center.y\n    \n    \n    \n    // Offset UV - 1\n    vec2 uv1 = fragCoord / iResolution.y;\n\tuv1.y *= hexLD;\t\t\t\t\t\n    uv1 *= scale;\t\t\t\t\t\n\tuv1.x -= .5;\t\t\t\t\t// Translates uv.x by .5\n    uv1.y -= (hexA*hexLD)/2.;\t\t// Translates uv.y by .3334\n    float m = mod(uv1.y,2.);\t\t\n    uv1.x += step(1., m)*.5;\t\t\n    uv1 = fract(uv1);\t\t\t\t\n    uv1.x *= hexLD;\t\t\t\t\t\n    uv1.x -= hexLD/2.;\t\t\t\t\n    uv1.y -= .5;\t\t\t\t\t\n    \n    // Offset UV - 2\n    vec2 uv2 = fragCoord / iResolution.y;\n\tuv2.y *= hexLD;\t\t\t\t\t\n    uv2 *= scale;\t\t\t\t\t\n\tuv2.x -= 1.;\t\t\t\t\t// Translates uv.x by 1\n    uv2.y -= (hexA*hexLD);\t\t\t// Translates uv.y by .3334\n    float o = mod(uv2.y,2.);\t\t\n    uv2.x += step(1., o)*.5;\t\t\n    uv2 = fract(uv2);\t\t\t\t\n    uv2.x *= hexLD;\t\t\t\t\t\n    uv2.x -= hexLD/2.;\t\t\t\t\n    uv2.y -= .5;\t\t\t\t\t\n    \n\t// Apply Celt to all UV Layers\n    float c1 = celt(uv, .45); \n    float c2 = celt(uv1, .45);\n    float c3 = celt(uv2, .45);\n\n    // Output to screen\n    float test = clamp(c1,0.0,1.0)+clamp(c2,0.0,1.0)+clamp(c3,0.0,1.0);\n    fragColor = vec4(test,test,test,1.0);\n    //fragColor = vec4(c1,c2,c3,1.0);\n}","name":"Image","description":"","type":"image"}]}