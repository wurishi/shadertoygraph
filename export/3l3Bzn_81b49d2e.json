{"ver":"0.1","info":{"id":"3l3Bzn","date":"1612036053","viewed":574,"name":"Rotation 360 sdf","username":"iuryBorgesRodrigues","description":"Based: https://www.shadertoy.com/view/3ddcW8","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["sdf","rotation","360"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst float PI= 3.14159265359;\n#define TYPE 4\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\n\nmat3 rotate_x(float a){float sa = sin(a); float ca = cos(a); return mat3(vec3(1.,.0,.0),    vec3(.0,ca,sa),   vec3(.0,-sa,ca));}\nmat3 rotate_y(float a){float sa = sin(a); float ca = cos(a); return mat3(vec3(ca,.0,sa),    vec3(.0,1.,.0),   vec3(-sa,.0,ca));}\nmat3 rotate_z(float a){float sa = sin(a); float ca = cos(a); return mat3(vec3(ca,sa,.0),    vec3(-sa,ca,.0),  vec3(.0,.0,1.));}\n\n\nconst float TAU = 2.0 * PI;\n\nfloat glow = 0.0;\n\n\n\nfloat sdPlane(in vec3 p) {\n    return p.y;\n}\n\nfloat sdSphere(in vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nvec2 opUnion(vec2 d1, vec2 d2) {\n    return d1.x < d2.x ? d1 : d2;\n}\nfloat sdApple(vec3 p, float r) {\n\tp.y *= 0.95;\n\n\tp.xz *= 1.2;\n\n\tfloat k = 0.84 + 0.16 * smoothstep(-r, r, p.y);\n\tp.xz /= k;\n\treturn sdTorus(p, vec2((0.9 / 1.25) * r, r))*0.3;\n}\n\n\n\nfloat localTime = 0.0;\n\n\n\n\n\n\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 matMin(vec2 a, vec2 b)\n{\n\tif (a.x < b.x) return a;\n\telse return b;\n}\n\n\nfloat sdBox(vec3 p, vec3 radius)\n{\n  vec3 dist = abs(p) - radius;\n  return min(max(dist.x, max(dist.y, dist.z)), 0.0) + length(max(dist, 0.0));\n}\n\n\n\n\n\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\n\nvec3 fold(in vec3 p)\n{\n    const vec3 nc = vec3(-0.5,-0.809017,0.309017);\n    for(int i=0;i<5;i++)\n    {\n\t\tp.xy = abs(p.xy);\n\t\tfloat t = 2.*min(0.,dot(p,nc));\n\t\tp -= t*nc;\n\t}\n    return p;\n}\n\nfloat smax(float a, float b)\n{\n    const float k = 2.;\n    float h = 1.-clamp(.5 + .5*(b-a)/k, 0., 1.);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat tri(in float x){return abs(fract(x)-0.5)*2.;}\n\n\nvec2 toroidal (vec2 p, float r) { return vec2(length(p.xy)-r, atan(p.y,p.x)); }\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\nfloat amod (inout vec2 p, float count) { float an = TAU/count; float a = atan(p.y,p.x)+an/2.; float c = floor(a/an); c = mix(c,abs(c),step(count*.5,abs(c))); a = mod(a,an)-an/2.; p.xy = vec2(cos(a),sin(a))*length(p); return c; }\nfloat sdCylinder (vec2 p, float r) { return length(p)-r; }\n\nfloat sdIso(vec3 p, float r) { return max(0.,dot(p,normalize(sign(p))))-r; }\nfloat sdStar (vec3 pos) {\n    float dist;\n    \n    float radius = 3.;\n    float size = .2;\n    vec3 p = pos;\n    p.y -= radius;\n    p.xy *= rot(-iTime*.5);\n    float index = amod(p.xy, 16.);\n    p.x -= radius-1.5;\n    p.xy *= rot(iTime+index);\n    amod(p.xy, 5.);\n    dist = sdIso(p, size);\n   \n    return dist;\n}\n\nfloat sdShere (vec3 pos) {\n    float dist;\n    \n    float radius = 3.;\n    float size = .2;\n    vec3 p = pos;\n    p.y -= radius;\n    p.xy *= rot(-iTime*.5);\n    float index = amod(p.xy, 16.);\n    p.x -= radius-1.5;\n    p.xy *= rot(iTime+index);\n    \n    dist = length(p)-0.2;\n   \n    return dist;\n}\n\nfloat box (vec3 pos) {\n    float dist;\n    \n    float radius = 4.;\n    float size = .2;\n    vec3 p = pos;\n    p.y -= radius;\n    p.xy *= rot(-iTime*.5);\n    float index = amod(p.xy, 16.);\n    p.x -= radius-1.5;\n    p.xy *= rot(iTime+index);\n    \n    dist =sdBox(p,vec3(0.2));\n   \n    return dist;\n}\n\nvec2 scene(in vec3 position) {\n\n\n    vec3 p=position;\n    p-=vec3(0.0,-0.5,0.0);\n    p/=vec3(0.5);\n    float star=sdStar(p)*0.3;\n    p-=vec3(0.0,0.0,1.0);\n    float sphere=sdShere(p)*0.3;\n    p-=vec3(0.0,3.0,-4.3);\n    p*=rotate_x(1.5);\n    float torus=box (p)*0.3;\n  \n    star=min(star,sphere);\n    star=min(star,torus);\n  \n    \n   \n   \n    vec2 scene = opUnion(\n          vec2(sdPlane(position), 1.0),\n          vec2(star, 12.0)\n    );\n    return scene;\n}\n\nvec4 boxmap( sampler2D sam, in vec3 p, in vec3 n, in float k )\n{\n    vec3 m = pow( abs(n), vec3(k) );\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n\treturn (x*m.x + y*m.y + z*m.z)/(m.x+m.y+m.z);\n}\n//------------------------------------------------------------------------------\n// Ray casting\n//------------------------------------------------------------------------------\n\nfloat shadow(in vec3 origin, in vec3 direction) {\n    float hit = 1.0;\n    float t = 0.02;\n    \n    for (int i = 0; i < 1000; i++) {\n        float h = scene(origin + direction * t).x;\n        if (h < 0.001) return 0.0;\n        t += h;\n        hit = min(hit, 10.0 * h / t);\n        if (t >= 2.5) break;\n    }\n\n    return clamp(hit, 0.0, 1.0);\n}\n\nvec2 traceRay(in vec3 origin, in vec3 direction) {\n    float material = -1.0;\n\n    float t = 0.02;\n    \n    for (int i = 0; i < 1000; i++) {\n        vec2 hit = scene(origin + direction * t);\n        if (hit.x < 0.002 || t > 20.0) break;\n        t += hit.x;\n        material = hit.y;\n    }\n\n    if (t > 20.0) {\n        material = -1.0;\n    }\n\n    return vec2(t, material);\n}\n\nvec3 normal(in vec3 position) {\n    vec3 epsilon = vec3(0.001, 0.0, 0.0);\n    vec3 n = vec3(\n          scene(position + epsilon.xyy).x - scene(position - epsilon.xyy).x,\n          scene(position + epsilon.yxy).x - scene(position - epsilon.yxy).x,\n          scene(position + epsilon.yyx).x - scene(position - epsilon.yyx).x);\n    return normalize(n);\n}\n\n//------------------------------------------------------------------------------\n// BRDF\n//------------------------------------------------------------------------------\n\nfloat pow5(float x) {\n    float x2 = x * x;\n    return x2 * x2 * x;\n}\n\nfloat D_GGX(float linearRoughness, float NoH, const vec3 h) {\n    // Walter et al. 2007, \"Microfacet Models for Refraction through Rough Surfaces\"\n    float oneMinusNoHSquared = 1.0 - NoH * NoH;\n    float a = NoH * linearRoughness;\n    float k = linearRoughness / (oneMinusNoHSquared + a * a);\n    float d = k * k * (1.0 / PI);\n    return d;\n}\n\nfloat V_SmithGGXCorrelated(float linearRoughness, float NoV, float NoL) {\n    // Heitz 2014, \"Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs\"\n    float a2 = linearRoughness * linearRoughness;\n    float GGXV = NoL * sqrt((NoV - a2 * NoV) * NoV + a2);\n    float GGXL = NoV * sqrt((NoL - a2 * NoL) * NoL + a2);\n    return 0.5 / (GGXV + GGXL);\n}\n\nvec3 F_Schlick(const vec3 f0, float VoH) {\n    // Schlick 1994, \"An Inexpensive BRDF Model for Physically-Based Rendering\"\n    return f0 + (vec3(1.0) - f0) * pow5(1.0 - VoH);\n}\n\nfloat F_Schlick(float f0, float f90, float VoH) {\n    return f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\n\nfloat Fd_Burley(float linearRoughness, float NoV, float NoL, float LoH) {\n    // Burley 2012, \"Physically-Based Shading at Disney\"\n    float f90 = 0.5 + 2.0 * linearRoughness * LoH * LoH;\n    float lightScatter = F_Schlick(1.0, f90, NoL);\n    float viewScatter  = F_Schlick(1.0, f90, NoV);\n    return lightScatter * viewScatter * (1.0 / PI);\n}\n\nfloat Fd_Lambert() {\n    return 1.0 / PI;\n}\n\n//------------------------------------------------------------------------------\n// Indirect lighting\n//------------------------------------------------------------------------------\n\nvec3 Irradiance_SphericalHarmonics(const vec3 n) {\n    // Irradiance from \"Ditch River\" IBL (http://www.hdrlabs.com/sibl/archive.html)\n    return max(\n          vec3( 0.754554516862612,  0.748542953903366,  0.790921515418539)\n        + vec3(-0.083856548007422,  0.092533500963210,  0.322764661032516) * (n.y)\n        + vec3( 0.308152705331738,  0.366796330467391,  0.466698181299906) * (n.z)\n        + vec3(-0.188884931542396, -0.277402551592231, -0.377844212327557) * (n.x)\n        , 0.0);\n}\n\nvec2 PrefilteredDFG_Karis(float roughness, float NoV) {\n    // Karis 2014, \"Physically Based Material on Mobile\"\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);\n    const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);\n\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n\n    return vec2(-1.04, 1.04) * a004 + r.zw;\n}\n\n//------------------------------------------------------------------------------\n// Tone mapping and transfer functions\n//------------------------------------------------------------------------------\n\nvec3 Tonemap_ACES(const vec3 x) {\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvec3 OECF_sRGBFast(const vec3 linear) {\n    return pow(linear, vec3(1.0 / 2.2));\n}\n\n//------------------------------------------------------------------------------\n// Rendering\n//------------------------------------------------------------------------------\n\nvec3 hash3(vec2 p)\n{\n    vec3 q = vec3(\n\t\tdot(p,vec2(127.1,311.7)), \n\t\tdot(p,vec2(269.5,183.3)), \n\t\tdot(p,vec2(419.2,371.9))\n\t);\n\treturn fract(sin(q) * 43758.5453);\n}\n\nfloat noise(vec2 x)\n{\n\tvec2 p = floor(x);\n\tvec2 f = fract(x);\n\treturn mix(\n\t\tmix(\n\t\t\thash3(p + vec2(0.0, 0.0)).x,\n\t\t\thash3(p + vec2(1.0, 0.0)).x,\n\t\t\tsmoothstep(0.0, 1.0, f.x)\n\t\t),\n\t\tmix(\n\t\t\thash3(p + vec2(0.0, 1.0)).x,\n\t\t\thash3(p + vec2(1.0, 1.0)).x,\n\t\t\tsmoothstep(0.0, 1.0, f.x)\n\t\t),\n\t\tsmoothstep(0.0, 1.0, f.y)\n\t);\n}\n\n\nvec2 getUV(vec3 pos)\n{\n    vec3 nor = normal(pos);\n    float lon = atan(nor.x,nor.z)/3.14;\n    float lat = acos(nor.y)/3.14;\n    vec2 r = vec2(lat, lon);\n    \n    return r;\n}\nvec3 render(in vec3 origin, in vec3 direction, out float distance,vec2 uv) {\n    // Sky gradient\n    vec3 color = vec3(0.65, 0.85, 1.0) + direction.y * 0.72;\n\n    // (distance, material)\n    vec2 hit = traceRay(origin, direction);\n    distance = hit.x;\n    float material = hit.y;\n\n    // We've hit something in the scene\n    if (material > 0.0) {\n        vec3 position = origin + distance * direction;\n\n        vec3 v = normalize(-direction);\n        vec3 n = normal(position);\n        vec3 l = normalize(vec3(0.6, 0.7, -0.7));\n        vec3 h = normalize(v + l);\n        vec3 r = normalize(reflect(direction, n));\n\n        float NoV = abs(dot(n, v)) + 1e-5;\n        float NoL = saturate(dot(n, l));\n        float NoH = saturate(dot(n, h));\n        float LoH = saturate(dot(l, h));\n\n        vec3 baseColor = vec3(0.0);\n        float roughness = 0.0;\n        float metallic = 0.0;\n\n        float intensity = 2.0;\n        float indirectIntensity = 0.64;\n\n        if (material < 4.0)  {\n            // Checkerboard floor\n            float f = mod(floor(6.0 * position.z) + floor(6.0 * position.x), 2.0);\n            baseColor = 0.4 + f * vec3(0.6);\n            roughness = 0.1;\n        } else if (material < 16.0) {\n            // Metallic objects\n            baseColor = vec3(255.0,255.0,0.0)/255.0218,165,32;\n            roughness = 0.5;\n            metallic=0.5;\n        }\n\n        float linearRoughness = roughness * roughness;\n        vec3 diffuseColor = (1.0 - metallic) * baseColor.rgb;\n        vec3 f0 = 0.04 * (1.0 - metallic) + baseColor.rgb * metallic;\n\n        float attenuation = shadow(position, l);\n\n        // specular BRDF\n        float D = D_GGX(linearRoughness, NoH, h);\n        float V = V_SmithGGXCorrelated(linearRoughness, NoV, NoL);\n        vec3  F = F_Schlick(f0, LoH);\n        vec3 Fr = (D * V) * F;\n\n        // diffuse BRDF\n        vec3 Fd = diffuseColor * Fd_Burley(linearRoughness, NoV, NoL, LoH);\n\n        color = Fd + Fr;\n        color *= (intensity * attenuation * NoL) * vec3(0.98, 0.92, 0.89);\n\n        // diffuse indirect\n        vec3 indirectDiffuse = Irradiance_SphericalHarmonics(n) * Fd_Lambert();\n\n        vec2 indirectHit = traceRay(position, r);\n        vec3 indirectSpecular = vec3(0.65, 0.85, 1.0) + r.y * 0.72;\n        if (indirectHit.y > 0.0) {\n            if (indirectHit.y < 4.0)  {\n                vec3 indirectPosition = position + indirectHit.x * r;\n                // Checkerboard floor\n                float f = mod(floor(6.0 * indirectPosition.z) + floor(6.0 * indirectPosition.x), 2.0);\n                indirectSpecular = 0.4 + f * vec3(0.6);\n            } else if (indirectHit.y < 16.0) {\n                // Metallic objects\n                indirectSpecular = vec3(0.3, 0.0, 0.0);\n            }\n        }\n\n        // indirect contribution\n        vec2 dfg = PrefilteredDFG_Karis(roughness, NoV);\n        vec3 specularColor = f0 * dfg.x + dfg.y;\n        vec3 ibl = diffuseColor * indirectDiffuse + indirectSpecular * specularColor;\n\n        color += ibl * indirectIntensity;\n    }\n\n    return color;\n}\n\n//------------------------------------------------------------------------------\n// Setup and execution\n//------------------------------------------------------------------------------\n\nmat3 setCamera(in vec3 origin, in vec3 target, float rotation) {\n    vec3 forward = normalize(target - origin);\n    vec3 orientation = vec3(sin(rotation), cos(rotation), 0.0);\n    vec3 left = normalize(cross(forward, orientation));\n    vec3 up = normalize(cross(left, forward));\n    return mat3(left, up, forward);\n}\n// Camera\nvec2 glFragCoord;\nvec3 Ray( float zoom )\n{\n\treturn vec3( glFragCoord.xy-iResolution.xy*.5, iResolution.x*zoom );\n}\n\nvec3 Rotate( inout vec3 v, vec2 a )\n{\n\tvec4 cs = vec4( cos(a.x), sin(a.x), cos(a.y), sin(a.y) );\n\t\n\tv.yz = v.yz*cs.x+v.zy*cs.y*vec2(-1,1);\n\tv.xz = v.xz*cs.z+v.zx*cs.w*vec2(1,-1);\n\t\n\tvec3 p;\n\tp.xz = vec2( -cs.w, -cs.z )*cs.x;\n\tp.y = cs.y;\n\t\n\treturn p;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized coordinates\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    vec2 uv= fragCoord.xy / iResolution.xy;\n    // Aspect ratio\n    p.x *= iResolution.x / iResolution.y;\n    \n    vec3 ray = Ray(1.8);\n\t\n\t\n\t\n\tray = normalize(ray);\n    vec3 localRay = ray;\n\n\tvec2 mouse = vec2(-.1,iTime*.01);\n\t\n\tmouse = vec2(.5)-iMouse.yx/iResolution.yx;\n\t\t\n\tfloat T = iTime*.0;\n\tvec3 pos = 3.0*Rotate( ray, vec2(.2,1.5-T)+vec2(-1.0,-7.0)*mouse );\n\t//pos += vec3(0,.3,0) + T*vec3(0,0,-1);\n    pos.y += .06-pos.z*.02; // tail is higher\n    pos.z += pos.z*.2; // centre on the end of the car we're looking at\n    pos.x += .3;//sign(pos.x)*.2*smoothstep(.0,.5,abs(pos.x)); // off-centre framingvec3 ray = Ray(1.8);\n\n\t\n\t\n\t\n\n    // Camera position and \"look at\"\n    vec3 origin = vec3(0.0, 2.0, 0.0);\n    vec3 target = vec3(0.0);\n\n    origin+=pos;\n\n    mat3 toWorld = setCamera(origin, target, 0.0);\n    vec3 direction = toWorld * normalize(vec3(p.xy, 2.0));\n\n    // Render scene\n    float distance;\n    vec3 color = render(origin, direction, distance,getUV(origin + direction*traceRay(origin, direction).x));\n\n    // Tone mapping\n    color = Tonemap_ACES(color);\n\n    // Exponential distance fog\n    color = mix(color, 0.8 * vec3(0.7, 0.8, 1.0), 1.0 - exp2(-0.011 * distance * distance));\n\n    // Gamma compression\n    color = OECF_sRGBFast(color);\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}