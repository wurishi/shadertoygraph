{"ver":"0.1","info":{"id":"MllfWN","date":"1512405058","viewed":579,"name":"Relative Sky Luminance","username":"reinsteam","description":"Logarithmic plot of relative sky luminance distributions (Blue), relative luminance gradations (Green) and scattering indicatrices (Red) according to a paper \"CIE General Sky Standard Defining Luminance Distributions\" by Darula and Kittler. ","likes":6,"published":3,"flags":0,"usePreview":0,"tags":["ciesky"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by reinsteam / Dec 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// This sample demonstrate various relative sky luminance distributions from the paper\n// \"CIE General Sky Standard Defining Luminance Distributions\" by Darula and Kittler \n// Referenced below as [Darula02]\n\n\n#define USE_SOFT_TYPE_TRANSITION 1\n\nconst float kPiOverTwo = 1.5707963;\n\n// Table (1) from [Darula02]\nconst vec2 kGradation_1 = vec2( 4.0, -0.70);\nconst vec2 kGradation_2 = vec2( 1.1, -0.80);\nconst vec2 kGradation_3 = vec2( 0.0, -1.00);\nconst vec2 kGradation_4 = vec2(-1.0, -0.55);\nconst vec2 kGradation_5 = vec2(-1.0, -0.32);\nconst vec2 kGradation_6 = vec2(-1.0, -0.15);\n\nconst vec3 kIndicatrix_1 = vec3( 0.0, -1.0, 0.00);\nconst vec3 kIndicatrix_2 = vec3( 2.0, -1.5, 0.15);\nconst vec3 kIndicatrix_3 = vec3( 5.0, -2.5, 0.30);\nconst vec3 kIndicatrix_4 = vec3(10.0, -3.0, 0.45);\nconst vec3 kIndicatrix_5 = vec3(16.0, -3.0, 0.30);\nconst vec3 kIndicatrix_6 = vec3(24.0, -2.8, 0.15);\n\nvec2 TypeToAB[15] = vec2[]\n(\n    kGradation_1,\n    kGradation_1,\n    kGradation_2,\n    kGradation_2,\n    kGradation_3,\n    kGradation_3,\n    kGradation_3,\n    kGradation_3,\n    kGradation_4,\n    kGradation_4,\n    kGradation_4,\n    kGradation_5,\n    kGradation_5,\n    kGradation_6,\n    kGradation_6\n);\n\nvec3 TypeToCDE[15] = vec3[]\n(\n    kIndicatrix_1,\n    kIndicatrix_2,\n    kIndicatrix_1,\n    kIndicatrix_2,\n    kIndicatrix_1,\n    kIndicatrix_2,\n    kIndicatrix_3,\n    kIndicatrix_4,\n    kIndicatrix_2,\n    kIndicatrix_3,\n    kIndicatrix_4,\n    kIndicatrix_4,\n    kIndicatrix_5,\n    kIndicatrix_5,\n    kIndicatrix_6\n);\n\n// Formula (5) from [Darula02]\nfloat LuminanceGradation(float Mu, vec2 AB)\n{\n    float A = AB.x;\n    float B = AB.y;\n    return (Mu < 0.0000001) ? 1.0 : 1.0 + A * exp(B / Mu);\n}\n\n\n// Figure (2) from [Darula02]\nfloat LuminanceGradation_Relative(float Angle, vec2 AB)\n{\n    float CosAngle = cos(Angle);\n\treturn LuminanceGradation(CosAngle, AB) / LuminanceGradation(1.0, AB);\n}\n\n// Formula (7) (8) and Figure (3) from [Darula02]\nfloat ScatteringIndicatrix(float Angle, vec3 CDE)\n{\n    float C = CDE.x;\n    float D = CDE.y;\n    float E = CDE.z;\n    float CosAngle = cos(Angle);\n    return 1.0 + C * (exp(D * Angle) - exp(D * kPiOverTwo)) + E * CosAngle * CosAngle;\n}\n\nfloat ScatteringIndicatrix_Relative(float EyeToSun, float SunZenith, vec3 CDE)\n{\n    return ScatteringIndicatrix(EyeToSun, CDE) / ScatteringIndicatrix(SunZenith, CDE);\n}\n\nfloat Luminance_Relative(float EyeZenith, float SunZenith, float EyeToSun, vec2 AB, vec3 CDE)\n{\n    \n    return ScatteringIndicatrix_Relative(EyeToSun, SunZenith, CDE) *\n           LuminanceGradation_Relative(EyeZenith, AB);\n}\n\nfloat Luminance_Relative(float EyeZenith, float SunZenith, float EyeToSun, int Type)\n{\n    return Luminance_Relative(EyeZenith, SunZenith, EyeToSun, TypeToAB[Type], TypeToCDE[Type]);\n}\n\nfloat Plot(float F, float Y)\n{\n    float Y_Scale = 6.0;\n    float Y_Shift = 2.0;\n    F = log2(F);\n    Y = (Y * 2.0 - 1.0);\n    float Y_Delta = F - Y * Y_Scale;\n    //return 1.0 - clamp(abs(F - Y * y_stretch - y_offset)  / fwidth(F - Y * y_stretch), 0.0, 1.0);\n    //return 1.0 - smoothstep(0.0, 1.0, abs(Y_Delta - Y_Shift) * 0.5 / fwidth(Y_Delta));\n    return 1.0 - clamp(abs(Y_Delta - Y_Shift) * 0.5 / fwidth(Y_Delta), 0.0, 1.0);\n}\n\nfloat Max6(float X0, float X1, float X2, float X3, float X4, float X5)\n{\n    return max(max(max(X0, X1), max(X2, X3)), max(X4, X5));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat U = fragCoord.x / iResolution.x;\n    float V = fragCoord.y / iResolution.y;\n    \n    float X = iMouse.x / iResolution.x;\n    float Y = iMouse.y / iResolution.y;\n    \n    float ZeroToPi = kPiOverTwo * X * 2.0;\n    float ZeroToPi_U = kPiOverTwo * U * 2.0;\n    float ZeroToHalfPi_U = kPiOverTwo * U;\n    \n    // ZeroToHalfPi_U defines angular difference between EyeDir and Zenith\n    // Corresponds to Figure (2) from [Darula02]\n    float LG1 = LuminanceGradation_Relative(ZeroToHalfPi_U, kGradation_1);\n    float LG2 = LuminanceGradation_Relative(ZeroToHalfPi_U, kGradation_2);\n    float LG3 = LuminanceGradation_Relative(ZeroToHalfPi_U, kGradation_3);\n    float LG4 = LuminanceGradation_Relative(ZeroToHalfPi_U, kGradation_4);\n    float LG5 = LuminanceGradation_Relative(ZeroToHalfPi_U, kGradation_5);\n    float LG6 = LuminanceGradation_Relative(ZeroToHalfPi_U, kGradation_6);\n\n#if 0\n    // ZeroToHalfPi_U defines difference between SunDir and Zenith\n    // ZeroToPi defines difference between SunDir and EyeDir\n    float SI1 = ScatteringIndicatrix_Relative(ZeroToPi, ZeroToHalfPi_U, kIndicatrix_1);\n    float SI2 = ScatteringIndicatrix_Relative(ZeroToPi, ZeroToHalfPi_U, kIndicatrix_2);\n    float SI3 = ScatteringIndicatrix_Relative(ZeroToPi, ZeroToHalfPi_U, kIndicatrix_3);\n    float SI4 = ScatteringIndicatrix_Relative(ZeroToPi, ZeroToHalfPi_U, kIndicatrix_4);\n    float SI5 = ScatteringIndicatrix_Relative(ZeroToPi, ZeroToHalfPi_U, kIndicatrix_5);\n    float SI6 = ScatteringIndicatrix_Relative(ZeroToPi, ZeroToHalfPi_U, kIndicatrix_6);\n#else\n    // ZeroToPI_U defines angular difference between SunDir and EyeDir\n    // Corresponds to Figure (3) from [Darula02]\n    float SI1 = ScatteringIndicatrix(ZeroToPi_U, kIndicatrix_1);\n    float SI2 = ScatteringIndicatrix(ZeroToPi_U, kIndicatrix_2);\n    float SI3 = ScatteringIndicatrix(ZeroToPi_U, kIndicatrix_3);\n    float SI4 = ScatteringIndicatrix(ZeroToPi_U, kIndicatrix_4);\n    float SI5 = ScatteringIndicatrix(ZeroToPi_U, kIndicatrix_5);\n    float SI6 = ScatteringIndicatrix(ZeroToPi_U, kIndicatrix_6);\n#endif\n    \n    \n    float PlotR = Max6(Plot(LG1, V), Plot(LG2, V), Plot(LG3, V),\n                       Plot(LG4, V), Plot(LG5, V), Plot(LG6, V));\n\n    float PlotG = Max6(Plot(SI1, V), Plot(SI2, V), Plot(SI3, V),\n                       Plot(SI4, V), Plot(SI5, V), Plot(SI6, V));\n    \n    float PlotB = 0.0;\n    \n    float EyeZenith = U * kPiOverTwo * 2.0;\n    float EyeToSun  = X * kPiOverTwo * 2.0;    \n    \n    float NumTypes = 15.0;\n    \n    {\n        Y = fract(iTime * 1.0 / NumTypes);\n        \n        float Type = floor(Y * NumTypes);\n        float TypeLerp = fract(Y * NumTypes);\n        for (int SunZenithIdx = 0; SunZenithIdx < 16; ++SunZenithIdx)\n        {\n            float SunZenith = (float(SunZenithIdx) / 16.0) * kPiOverTwo ;\n#if USE_SOFT_TYPE_TRANSITION\n            float Lum0 = Luminance_Relative(EyeZenith, SunZenith, EyeToSun, int(Type));\n            float Lum1 = Luminance_Relative(EyeZenith, SunZenith, EyeToSun, (int(Type) + 1) % int(NumTypes));\n            float Lum = mix(Lum0, Lum1, TypeLerp);\n#else\n            float Lum = Luminance_Relative(EyeZenith, SunZenith, EyeToSun, int(Type));\n#endif\n            PlotB = max(PlotB, Plot(Lum, V));\n        }\n    }\n    fragColor = vec4(PlotR, PlotG, PlotB, 0.0);\n}","name":"Image","description":"","type":"image"}]}