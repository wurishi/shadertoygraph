{"ver":"0.1","info":{"id":"3llXW2","date":"1564351593","viewed":145,"name":"bonzomatic test run #2","username":"Exca","description":"Testing bonzomatic for asm19 shader showdown.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["bonzomatic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 rep( vec2 p, vec2 c)\n{\n  vec2 h = 0.5*c;\n  return mod(p, c)-h;\n}\n\nfloat sphere( vec2 p, float d)\n{\n  return length(p)-d;\n}\n\nfloat square(vec2 p, float d)\n{\n  return min(p.x -d, p.y-d);\n}\n\nfloat dist(vec2 p)\n{\n  float mp = sin(iTime+p.x)*0.2;\n  p = rep(p, vec2(0.5,0.5)*mp);\n  return mix(sphere(p, 0.13), square(p, 0.15), abs(sin(iTime*.05)));\n}\n\nfloat txtr(vec2 p, float t)\n{\n  vec2 off1 = vec2( iTime, iTime);\n  vec2 off2 = vec2( iTime*.5, iTime*0.3);\n  vec2 off3 = vec2( iTime*.354, iTime*-.235);\n  vec2 off4 = vec2( iTime*.2541, iTime*-.151);\n  \n  off1*=0.2;\n  off2*=0.2;\n  off3*=0.2;\n  off4*=0.2;\n  \n  float c1 = texture(iChannel0, t*p+off1).r;\n  float c2 = texture(iChannel0, t*p+off2).r;\n  float c3 = texture(iChannel0, t*p+off3).r;\n  float c4 = texture(iChannel0, t*p+off4).r;\n  \n  float n = c1+ c2*0.75 + c3* 0.44 + c4*0.2;\n  \n  n = smoothstep( 0., 1., n/2.);\n  \n  return n;\n}\n\nvec3 colc(float off)\n{\n  float r1 = texture(iChannel1, vec2(0.)).r;\n  float r2 = texture(iChannel1, vec2(0.1)).r;\n  float r3 = texture(iChannel1, vec2(0.2)).r;\n  float r4 = texture(iChannel1, vec2(0.3)).r;\n  \n  r1 = abs(sin(iTime*0.3+off))*.9;\n  r2 = abs(sin(iTime*0.3+off))*.9;\n  r3 = abs(sin(iTime*0.3+off))*.9;\n  r4 = abs(sin(iTime*0.3+off))*.9;\n  \n  \n  return mix( vec3(1., 0.6, 0.), vec3(0.4,0.6, 1.), smoothstep(0., 4.,r1+r2+r3+r4));\n}\n\nconst float eps = 0.001;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = fragCoord/iResolution.xy;\n\n  uv *=2.;\n  uv-=1.;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec3 col = vec3(0.);\n  float t = 0.;\n  \n  if(mod(iTime, 5.) < 2.5)\n  {\n    if(uv.x < 0.0)\n      uv.x*=-1.;\n    if(uv.y < 0.0)\n      uv.y*=-1.;\n  }\n  \n  for(int i = 0; i < 500; i++)\n  {\n     float d = dist(uv*(1.5-step(1., mod(iTime, 2.))));\n     t+=d;\n     if(d < eps)\n     {\n       col = txtr(uv,t*7.25) * colc(uv.x + uv.y);\n       vec3 bloom = vec3(0.);\n       vec2 nuv = uv + vec2(0.05, 0.05);\n       bloom += txtr(nuv,t*7.25) * colc(nuv.x + nuv.y);\n       nuv = uv + vec2(-0.05, 0.05);\n       bloom += txtr(nuv,t*7.25) * colc(nuv.x + nuv.y);\n       nuv = uv + vec2(0.05, -0.05);\n       bloom += txtr(nuv,t*7.25) * colc(nuv.x + nuv.y);\n       nuv = uv + vec2(-0.05, -0.05);\n       bloom += txtr(nuv,t*7.25) * colc(nuv.x + nuv.y);\n       bloom/=3.0;\n       col += bloom;\n       \n       break;\n     }\n     if(t > 1000.)\n     {\n       break;\n     }\n  }\n  \n  fragColor = vec4(col,1.);\n}\n","name":"Image","description":"","type":"image"}]}