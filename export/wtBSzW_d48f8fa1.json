{"ver":"0.1","info":{"id":"wtBSzW","date":"1567197079","viewed":559,"name":"üê∏ Frogger üïπÔ∏è","username":"coyote","description":"My reconstruction of the popular arcade game. (check also [url=https://www.shadertoy.com/view/wllSRs]Space Invaders reconstruction[/url])\nKeys:\n Left/Right/Up/Down - move\n 1 - new game (at any moment)\n C - toggle CRT filter, nice for fullscreen (def OFF)","likes":32,"published":1,"flags":48,"usePreview":1,"tags":["2d","game","retro","pixel","arcade","frogger"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n//    Frogger reconstruction by coyote\n//\n// (work in progress, only two levels, no snakes, no otters,\n//  various other things to correct, but mainly playable...)\n//\n// my other reconstruction:\n//    Space Invaders : https://www.shadertoy.com/view/wllSRs\n//\n// CRT filter by Timothy Lottes  (press C to toggle CRT)\n// hash11 taken from Dave Hoskins: https://www.shadertoy.com/view/4djSRW\n//\n// Engine updates are exactly one per frame so the game:\n//  - slows down if 60fps is not met\n//  - probably would be too fast if both monitor and browser support working\n//    in higher refresh rate, and of course if gfx card is fast enough\n//    (haven't had a chance to try it on such a system, though)\n//\n// Anyway, for too fast game there is a preprocessor variable defined at the\n// top of the Common source.\n// The variable is called FD. (as in frame divisor)\n//\n//  - for monitor/browser with support for 120Hz set FD to 2 (updates every other frame)\n//  - for 144Hz with FD 2 the game will be faster, and with FD 3 slower, sorry\n//\n// ********* Keys **********\n//\n// Left arrow   - jump left\n// Right arrow  - jump right\n// Up arrow     - jump up\n// Down arrow   - jump down\n//\n// 1 - start a new game at any moment\n// C - toggle CRT simulation, nice for fullscreen (default OFF   )\n// I - toggle max integer multiplier / max height (default height)\n// L - toggle linear interpolation during zoom    (default ON    )\n// F - toggle FPS counter\n// P - pause, but shader runs, so use wisely !!\n//\n\n//============================================================\n\n//\n// PUBLIC DOMAIN CRT STYLED SCAN-LINE SHADER\n//\n//   by Timothy Lottes\n//\n// This is more along the style of a really good CGA arcade monitor.\n// With RGB inputs instead of NTSC.\n// The shadow mask example has the mask rotated 90 degrees for less chromatic aberration.\n//\n// Left it unoptimized to show the theory behind the algorithm.\n//\n// It is an example what I personally would want as a display option for pixel art games.\n// Please take and use, change, or whatever.\n//\n\n// Emulated input resolution.\n\n//#define res (640.0*vec2(1.0,iResolution.y/iResolution.x))\n//#define res (iResolution.xy/floor(1.0+iResolution.xy/512.0))\n\n#define res (iResolution.xy/2.)\n\n// Hardness of scanline.\n//  -8.0 = soft\n// -16.0 = medium\nconst float hardScan=-8.0;\n\n// Hardness of pixels in scanline.\n// -2.0 = soft\n// -4.0 = hard\nconst float hardPix=-3.0;\n\n// Display warp.\n// 0.0 = none\n// 1.0/8.0 = extreme\nconst vec2 warp=vec2(1./32.0,1./24.0); \n\n// Amount of shadow mask.\nconst float maskDark=.6;\nconst float maskLight=2.0;\n\n//------------------------------------------------------------------------\n\n// sRGB to Linear.\n// Assuing using sRGB typed textures this should not be needed.\nfloat ToLinear1(float c){return(c<=0.04045)?c/12.92:pow((c+0.055)/1.055,2.4);}\nvec3 ToLinear(vec3 c){return vec3(ToLinear1(c.r),ToLinear1(c.g),ToLinear1(c.b));}\n\n// Linear to sRGB.\n// Assuing using sRGB typed textures this should not be needed.\nfloat ToSrgb1(float c){return(c<0.0031308?c*12.92:1.055*pow(c,0.41666)-0.055);}\nvec3 ToSrgb(vec3 c){return vec3(ToSrgb1(c.r),ToSrgb1(c.g),ToSrgb1(c.b));}\n\n// Nearest emulated sample given floating point position and texel offset.\n// Also zero's off screen.\nvec3 Fetch(vec2 pos,vec2 off){\n  pos=floor(pos*res+off)/res;\n  if(max(abs(pos.x-0.5),abs(pos.y-0.5))>0.5)return vec3(0.0,0.0,0.0);\n//    return ToLinear(texelFetch(iChannel1,ivec2(pos.xy*iResolution.xy),0).rgb);\n  return ToLinear(texture(iChannel1,pos.xy,-16.0).rgb);}\n\n// Distance in emulated pixels to nearest texel.\nvec2 Dist(vec2 pos){pos=pos*res;return -((pos-floor(pos))-vec2(0.5));}\n    \n// 1D Gaussian.\nfloat Gaus(float pos,float scale){return exp2(scale*pos*pos);}\n\n// 3-tap Gaussian filter along horz line.\nvec3 Horz3(vec2 pos,float off){\n  vec3 b=Fetch(pos,vec2(-1.0,off));\n  vec3 c=Fetch(pos,vec2( 0.0,off));\n  vec3 d=Fetch(pos,vec2( 1.0,off));\n  float dst=Dist(pos).x;\n  // Convert distance to weight.\n  float scale=hardPix;\n  float wb=Gaus(dst-1.0,scale);\n  float wc=Gaus(dst+0.0,scale);\n  float wd=Gaus(dst+1.0,scale);\n  // Return filtered sample.\n  return (b*wb+c*wc+d*wd)/(wb+wc+wd);}\n\n// 5-tap Gaussian filter along horz line.\nvec3 Horz5(vec2 pos,float off){\n  vec3 a=Fetch(pos,vec2(-2.0,off));\n  vec3 b=Fetch(pos,vec2(-1.0,off));\n  vec3 c=Fetch(pos,vec2( 0.0,off));\n  vec3 d=Fetch(pos,vec2( 1.0,off));\n  vec3 e=Fetch(pos,vec2( 2.0,off));\n  float dst=Dist(pos).x;\n  // Convert distance to weight.\n  float scale=hardPix;\n  float wa=Gaus(dst-2.0,scale);\n  float wb=Gaus(dst-1.0,scale);\n  float wc=Gaus(dst+0.0,scale);\n  float wd=Gaus(dst+1.0,scale);\n  float we=Gaus(dst+2.0,scale);\n  // Return filtered sample.\n  return (a*wa+b*wb+c*wc+d*wd+e*we)/(wa+wb+wc+wd+we);}\n\n// Return scanline weight.\nfloat Scan(vec2 pos,float off){\n  float dst=Dist(pos).y;\n  return Gaus(dst+off,hardScan);}\n\n// Allow nearest three lines to effect pixel.\nvec3 Tri(vec2 pos){\n  vec3 a=Horz3(pos,-1.0);\n  vec3 b=Horz5(pos, 0.0);\n  vec3 c=Horz3(pos, 1.0);\n  float wa=Scan(pos,-1.0);\n  float wb=Scan(pos, 0.0);\n  float wc=Scan(pos, 1.0);\n  return a*wa+b*wb+c*wc;}\n\n\n// Shadow mask.\nvec3 Mask(vec2 pos)\n{\n  pos.x+=pos.y*3.0;\n  vec3 mask=vec3(maskDark,maskDark,maskDark);\n  pos.x=fract(pos.x/6.0);\n  if(pos.x<0.333)mask.r=maskLight;\n  else if(pos.x<0.666)mask.g=maskLight;\n  else mask.b=maskLight;\n  return mask;}\n\nvoid mainImage( out vec4 o, vec2 u )\n{\n    \n#if FD > 1\n    //skip frames\n    if( iFrame % FD != 0 ) {\n        discard ;\n    } else\n#endif\n    {\n        ivec2 iu = ivec2( u ) ;\n\n        vec2 fscr_dim = vec2( scr_dim ) ;\n\n        float k = iResolution.y / fscr_dim.y ;\n\n        if( texelFetch( iChannel3, ivec2( KEY_INT_SIZE, 2 ), 0 ).x > .5 ) {\n            k = floor( k ) ;\n        }\n\n        ivec2 new_dim = ivec2( fscr_dim * k ) ;\n        ivec2 diff = ivec2( iResolution.xy ) - new_dim ;\n\n        vec4 col ;\n\n        if( ! iINSIDE( iu, diff / 2, diff / 2 + new_dim ) ) {\n            col = vec4( .4, .0, 0, 1 ) ; //border\n        } else {\n            if( texelFetch( iChannel3, ivec2( KEY_CRT, 2 ), 0 ).x > .5 ) {\n                col.rgb = ToSrgb( Tri(u.xy/iResolution.xy)*Mask(u.xy) ) ; //read Buffer C and apply crt filter\n                col.a = 1. ;\n            } else {\n                col = texelFetch( iChannel1, ivec2( u ), 0 ) ; //plain Buffer C copy\n            }\n        }\n\n        o = col ;\n    }\n}\n\n//END Image","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n#define FD  1  //update every n-th frame (1 for 60Hz, 2 for 120Hz monitor/browser combo)\n\n//ARROWS\n#define KEY_LEFT     37\n#define KEY_UP       38\n#define KEY_RIGHT    39\n#define KEY_DOWN     40\n\n#define KEY_RESTART  49  //1 - start a new game at any moment\n#define KEY_CRT      67  //C - toggle CRT simulation, nice for fullscreen (default OFF   )\n#define KEY_INT_SIZE 73  //I - toggle max integer multiplier / max height (default height)\n#define KEY_LINEAR   76  //L - toggle linear interpolation during zoom    (default ON    )\n#define KEY_FPS      70  //F - toggle fps counter\n#define KEY_PAUSE    80  //P - pause, but shader runs at full power, so use wisely !!\n\n#define BONUS_SHOW_T        128\n#define TIME_BONUS_SHOW_T   256 //after saving frog\n\n#define FROG_WINK_WAIT_T   64 //after level complete\n#define FROG_WINK_T        48 //first frog wink time\n#define FROG_WINK_T2       32 //rest of frogs wink time\n#define FROG_WINK_TOTAL_T (FROG_WINK_WAIT_T+FROG_WINK_T+4*FROG_WINK_T2)\n\n#define PLAYER_WAIT_T       FROG_WINK_TOTAL_T //after level complete\n#define TIME_BONUS_SHOW_T2  (PLAYER_WAIT_T+16) //after level complete\n#define START_SHOW_T        128 //after time bonus is removed after level complete\n#define NEW_LEV_WAIT_T       16 //after start is shown\n\n#define FLY_T           128\n#define CROC_T          128\n#define HALF_CROC_T     128\n\n#define PTS_TRACK             10\n#define PTS_FROG_SAVED        50\n#define PTS_TIME_BONUS        10\n#define PTS_LADYFROG_BONUS   200\n#define PTS_FLY_BONUS        200\n#define PTS_LEV_COMPLETE    1000\n#define PTS_EXTRA_LIFE     20000\n\n#define JUMP_SPEED    2                            //pixel/frame, must divide jump length of 16 pixels\n#define END_JUMP_T    2                            //frames to wait before new jump\n#define JUMP_T        (16/JUMP_SPEED + END_JUMP_T) //total jump time in frames\n\n#define LADYFROG_JUMP_T  (16/JUMP_SPEED)\n#define LADYFROG_SHORT_T 32\n#define LADYFROG_LONG_T  64\n\n#define DEBUG_MODE 0\n\n#if( DEBUG_MODE == 1 )\n    #define DBG(a) a\n#else\n    #define DBG(a)\n#endif\n\n#define LOADI( ivec2_adr ) ivec4( texelFetch( iChannel0, (ivec2_adr), 0 ) )\n#define STOREI( ivec2_adr, value ) (o = iu == (ivec2_adr) ? vec4(value) : o)\n\n#define STATE_PLAYING        0\n#define STATE_LEV_COMPLETE   1\n#define STATE_FROGS_WINKING  2\n\n#define STATE_GAME_OVER      99\n\nconst ivec2\n    DBG( adr_debug_var = ivec2( 0, 0 ) ),\n    adr_state =          ivec2( 1, 0 ),\n    adr_player =         ivec2( 2, 0 ),\n    adr_score =          ivec2( 3, 0 ),\n    adr_turtle_anims =   ivec2( 4, 0 ),\n    adr_ladyfrog =       ivec2( 5, 0 ),\n    adr_timers =         ivec2( 6, 0 ),\n    adr_fly_n_croc =     ivec2( 7, 0 ),\n\n    madr_track[]  = ivec2[10](\n        ivec2( 0, 1 ), ivec2( 1, 1 ), ivec2( 2, 1 ), ivec2( 3, 1 ), ivec2( 4, 1 ),\n        ivec2( 5, 1 ), ivec2( 6, 1 ), ivec2( 7, 1 ), ivec2( 8, 1 ), ivec2( 9, 1 ) ) ;\n\n//state_flag bits 0-4 keep record of reached grass homes\n#define STATE_FLAGS_ALL_HOMES   (0x1f)\n\n#define STATE_FLAG_PAUSED       (1<<5)\n#define STATE_FLAG_LADY_ACTIVE  (1<<6)\n#define STATE_FLAG_BONUS_FLY    (1<<7)\n#define STATE_FLAG_BONUS_LADY   (1<<8)\n\n#define STATE_FLAG_KEY_LEFT     (1<<12)\n#define STATE_FLAG_KEY_UP       (1<<13)\n#define STATE_FLAG_KEY_RIGHT    (1<<14)\n#define STATE_FLAG_KEY_DOWN     (1<<15)\n#define STATE_FLAG_KEY_RESTART  (1<<16)\n#define STATE_FLAG_KEY_PAUSE    (1<<17)\n\n#define PLAYER_FLAG_DROWN   (1<<8)\n\n#define set_flag( flags, b )    ( flags |= (b) )\n#define clear_flag( flags, b )  ( flags &= ~(b) )\n#define toggle_flag( flags, b ) ( flags ^= (b) )\n#define flag( flags, b )        bool( (flags) & (b) )\n\n//input: int flags, int bit (or multiple bits), float condition\n#define put_flag( flags, b, c ) { if( (c) > .5 ) set_flag( flags, b ) ; else clear_flag( flags, b ) ; }\n\n\n//integer collisions, top and right (trs) borders are excluded\n//input ivec2 point, ivec2 (left,bottom), ivec2 (right,top)\n#define iINSIDE( a, bl, tr ) ( (a) == clamp( (a), (bl), (tr)-1 ) )\n#define iCOLLIDE( bl, tr, bl2, tr2 ) iINSIDE( (bl), (bl2)-((tr)-1)+(bl), (tr2) )\n\n//rects are ivec4 as (x,y,w,h)\n#define iRECTS_COLLIDE( a, b ) iCOLLIDE( (a).xy, (a).xy+(a).zw, (b).xy, (b).xy+(b).zw )\n\n\n//16 uvec4 array, p=[0,15] is index of uvec4, y=[0,3] is index of uvec4 component\n#define GENERATE_GET_BR_32(fn,arr) \\\nuint fn( int p, int y, int x ) { \\\n    uvec4 v ; \\\n    v =  p<16?p<8?p<4?p<2?p<1?   arr[ 0] : arr[ 1] \\\n        :p<3?                    arr[ 2] : arr[ 3] \\\n        :p<6?p<5?                arr[ 4] : arr[ 5] \\\n        :p<7?                    arr[ 6] : arr[ 7] \\\n        :p<12?p<10?p<9?          arr[ 8] : arr[ 9] \\\n        :p<11?                   arr[10] : arr[11] \\\n        :p<14?p<13?              arr[12] : arr[13] \\\n        :p<15?                   arr[14] : arr[15] \\\n        :p<24?p<20?p<18?p<17?    arr[16] : arr[17] \\\n        :p<19?                   arr[18] : arr[19] \\\n        :p<22?p<21?              arr[20] : arr[21] \\\n        :p<23?                   arr[22] : arr[23] \\\n        :p<28?p<26?p<25?         arr[24] : arr[25] \\\n        :p<27?                   arr[26] : arr[27] \\\n        :p<30?p<29?              arr[28] : arr[29] \\\n        :p<31?                   arr[30] : arr[31]; \\\n    x <<= 3 ; \\\n    return( \\\n        ( ( y<2?y<1? v[0] : v[1] \\\n           :y<3?     v[2] : v[3] ) >> x ) & 0xffU \\\n    ) ; }\n\n\n//16 uvec4 array, p=[0,15] is index of uvec4, y=[0,3] is index of uvec4 component\n#define GENERATE_GET_BR_16(fn,arr) \\\nuint fn( int p, int y ) { \\\n    uvec4 v ; \\\n    v =  p<8?p<4?p<2?p<1?   arr[ 0] : arr[ 1] \\\n        :p<3?               arr[ 2] : arr[ 3] \\\n        :p<6?p<5?           arr[ 4] : arr[ 5] \\\n        :p<7?               arr[ 6] : arr[ 7] \\\n        :p<12?p<10?p<9?     arr[ 8] : arr[ 9] \\\n        :p<11?              arr[10] : arr[11] \\\n        :p<14?p<13?         arr[12] : arr[13] \\\n        :p<15?              arr[14] : arr[15] ; \\\n    return( \\\n        y<2?y<1? v[0] : v[1] \\\n       :y<3?     v[2] : v[3] \\\n    ) ; }\n\n//8 uvec4 arr, p=[0,7] is index of uvec4, y=[0,3] is index of uvec4 component\n#define GENERATE_GET_BR_8(fn,arr) \\\nuint fn( int p, int y ) { \\\n    uvec4 v ; \\\n    v =  p<4?p<2?p<1?       arr[ 0] : arr[ 1] \\\n        :p<3?               arr[ 2] : arr[ 3] \\\n        :p<6?p<5?           arr[ 4] : arr[ 5] \\\n        :p<7?               arr[ 6] : arr[ 7] ; \\\n    return( \\\n        y<2?y<1? v[0] : v[1] \\\n       :y<3?     v[2] : v[3] \\\n    ) ; }\n\n//4 uvec4 arr, p=[0,4] is index of uvec4, y=[0,3] is index of uvec4 component\n#define GENERATE_GET_BR_4(fn,arr) \\\nuint fn( int p, int y ) { \\\n    uvec4 v ; \\\n    v =  p<2?p<1?       arr[ 0] : arr[ 1] \\\n        :p<3?           arr[ 2] : arr[ 3] ; \\\n    return( \\\n        y<2?y<1? v[0] : v[1] \\\n       :y<3?     v[2] : v[3] \\\n    ) ; }\n\n//4t = 4 types or 4 animation frames of 16x16x2 gfx (4 colors per pixel -> 4 uvec4 per type/frame, total 16 uvec4 array)\n#define GENERATE_DRAW_4T_BODY( fn, dim, fn_get_br ) \\\nvec4 fn( int type, ivec2 pos, inout vec4 o, ivec2 iu ) { \\\n    vec4 v = vec4( -1 ) ; \\\n    iu -= pos ; \\\n    if( iINSIDE( iu, ivec2(0), (dim) ) ) { \\\n        type &= 0x3 ; \\\n        int row_group = type * 4 + 3 - ( iu.y >> 2 ), \\\n            component = 3 - ( iu.y & 0x3 ), \\\n            sh = 2 * iu.x ; \\\n        uint bits = 0x3U << sh, \\\n             col_ind = ( fn_get_br( row_group, component ) & bits ) >> sh ; \\\n\n#define GENERATE_DRAW_4T_END_COL_FN( fn_get_col ) \\\n        v = fn_get_col( type, col_ind ) ; \\\n    } \\\n    o = v.a > 0. ? v : o ; \\\n    return( v ) ; }\n\n#define GENERATE_DRAW_4T_END_PALETTE( palette ) \\\n        v = get_col( palette, col_ind ) ; \\\n    } \\\n    o = v.a > 0. ? v : o ; \\\n    return( v ) ; }\n\n\n#define GENERATE_DRAW_4T_COL_FN( fn, dim, fn_get_br, fn_get_col ) \\\n    GENERATE_DRAW_4T_BODY( fn, dim, fn_get_br ) \\\n    GENERATE_DRAW_4T_END_COL_FN( fn_get_col )\n\n#define GENERATE_DRAW_4T_PALETTE( fn, dim, fn_get_br, palette ) \\\n    GENERATE_DRAW_4T_BODY( fn, dim, fn_get_br ) \\\n    GENERATE_DRAW_4T_END_PALETTE( palette )\n\n\n#define _ 0U\n#define r 1U\n#define g 2U\n#define y 3U\n        \n//row of 16 2-bit pixels (-> 32-bit unsigned int for uvec4 component)\n#define BR16(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P) uint(A+(B<<2)+(C<<4)+(D<<6)+(E<<8)+(F<<10)+(G<<12)+(H<<14)+(I<<16)+(J<<18)+(K<<20)+(L<<22)+(M<<24)+(N<<26)+(O<<28)+(P<<30))\n \n//row of 32 1-bit pixels (-> 32-bit unsigned int for uvec4 component)\n#define BR32(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P) uint(a+(b<<1)+(c<<2)+(d<<3)+(e<<4)+(f<<5)+(g<<6)+(h<<7)+(i<<8)+(j<<9)+(k<<10)+(l<<11)+(m<<12)+(n<<13)+(o<<14)+(p<<15)+(A<<16)+(B<<17)+(C<<18)+(D<<19)+(E<<20)+(F<<21)+(G<<22)+(H<<23)+(I<<24)+(J<<25)+(K<<26)+(L<<27)+(M<<28)+(N<<29)+(O<<30)+(P<<31))\n\nconst uvec4 gfx_player[] = uvec4[4*4](\n    uvec4( 0, //frame sit still\n           0,\n           0,\n           0 ),\n    uvec4( BR16( _,_,_,g,_,_,y,g,y,y,_,_,g,_,_,_ ),\n           BR16( _,_,g,g,_,r,g,y,y,g,r,_,g,g,_,_ ),\n           BR16( _,_,_,g,_,g,g,y,y,g,g,_,g,_,_,_ ),\n           BR16( _,_,_,g,g,y,y,y,y,y,y,g,g,_,_,_ ) ),\n    uvec4( BR16( _,_,_,_,_,y,g,y,y,y,y,_,_,_,_,_ ),\n           BR16( _,_,_,g,g,y,g,y,y,y,y,g,g,_,_,_ ),\n           BR16( _,_,_,g,_,g,y,g,y,y,g,_,g,_,_,_ ),\n           BR16( _,_,g,g,_,_,g,y,y,g,_,_,g,g,_,_ ) ),\n    uvec4( BR16( _,_,_,g,_,_,_,_,_,_,_,_,g,_,_,_ ),\n           0,\n           0,\n           0 ),\n    uvec4( 0, //frame jump\n           BR16( _,_,_,g,_,_,_,_,_,_,_,_,g,_,_,_ ),\n           BR16( _,_,g,g,_,_,y,g,y,y,_,_,g,g,_,_ ),\n           BR16( _,_,_,g,_,r,g,y,y,g,r,_,g,_,_,_ ) ),\n    uvec4( BR16( _,_,_,g,_,g,g,y,y,g,g,_,g,_,_,_ ),\n           BR16( _,_,_,_,g,y,y,y,y,y,y,g,_,_,_,_ ),\n           BR16( _,_,_,_,_,y,g,y,y,y,y,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,y,g,y,y,y,y,_,_,_,_,_ ) ),\n    uvec4( BR16( _,_,_,_,_,g,y,g,y,y,g,_,_,_,_,_ ),\n           BR16( _,_,_,_,g,g,g,y,y,g,g,g,_,_,_,_ ),\n           BR16( _,_,_,g,g,_,_,_,_,_,_,g,g,_,_,_ ),\n           BR16( _,_,_,g,_,_,_,_,_,_,_,_,g,_,_,_ ) ),\n    uvec4( BR16( _,_,g,g,_,_,_,_,_,_,_,_,g,g,_,_ ),\n           BR16( _,_,_,g,_,_,_,_,_,_,_,_,g,_,_,_ ),\n           0,\n           0 ),\n\n           //life\n    uvec4( BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,g,_,r,y,r,_,g,_,_,_,_,_,_,_,_ ),\n           BR16( _,g,y,y,y,y,y,g,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,y,y,y,y,y,_,_,_,_,_,_,_,_,_ ) ),\n    uvec4( BR16( _,_,y,y,y,y,y,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,g,g,y,y,y,g,g,_,_,_,_,_,_,_,_ ),\n           BR16( _,g,_,_,_,_,_,g,_,_,_,_,_,_,_,_ ),\n           BR16( _,g,_,_,_,_,_,g,_,_,_,_,_,_,_,_ ) ),\n    uvec4( 0 ),\n    uvec4( 0 ),\n\n           //level\n    uvec4( BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,r,r,r,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,g,r,g,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,g,g,g,g,g,_,_,_,_,_,_,_,_,_ ) ),\n    uvec4( BR16( _,_,g,y,g,g,g,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,g,y,g,g,g,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,g,y,g,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ) ),\n    uvec4( 0 ),\n    uvec4( 0 )\n) ;\n\n/*\n    uvec4( BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ) ),\n    uvec4( BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ) ),\n    uvec4( BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ) ),\n    uvec4( BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ) )\n*/\n\n\n#undef _\n#undef r\n#undef g\n#undef y\n\n\nconst vec4\n    col_transp      = vec4( .0, .0, .0, 0 ),\n    col_road        = vec4( .0, .0, .0, 1 ),\n    col_water       = vec4( .0, .0, .3, 1 ),\n    col_water_hack  = vec4( .0, .0, .3, .99 ), //hack for simpler collision with diving turtles\n    col_white       = vec4( .9, .9, .9, 1 ),\n    col_red         = vec4( 1., .0, .1, 1 ),\n    col_green       = vec4( .0, .9, .2, 1 ),\n    col_dark_brown  = vec4( .6, .4, .3, 1 ),\n    col_brown       = vec4( .9, .4, .3, 1 ),\n    col_light_brown = vec4( 1., .3, .1, 1 ),\n    col_cyan        = vec4( .0, .9, 1., 1 ),\n    col_blue        = vec4( .0, .0, 1., 1 ),\n    col_purple      = vec4( .6, .0, 1., 1 ),\n    col_yellow      = vec4( 1., 1., .2, 1 ),\n    col_magenta_2   = vec4( 1., .3, .9, 1 ),\n    col_magenta     = vec4( 1., .0, .9, 1 ),\n    \n    pal_player[]   = vec4[4]( col_transp, col_magenta, col_green,  col_yellow    ),\n    pal_ladyfrog[] = vec4[4]( col_transp, col_green,   col_cyan,   col_magenta_2 ),\n    pal_death_1[]  = vec4[4]( col_transp, col_red,     col_yellow, col_purple    ),\n    pal_death_2[]  = vec4[4]( col_transp, col_red,     col_yellow, col_purple    ) ;\n\n#define get_col(arr,i) \\\n   ((i)<2U?(i)<1U? arr[0] : arr[1] \\\n   :(i)<3U?        arr[2] : arr[3])\n\nconst ivec2\n    dim_player  = ivec2( 16, 16 ),\n    dim_death_1 = ivec2( 16, 16 ),\n    dim_death_2 = ivec2( 16, 16 ) ;\n\n\n//get bit row fns   fn name              gfx arr\nGENERATE_GET_BR_16( get_player_br,       gfx_player      )\n\nvec4 draw_player( int frame, int dir, ivec2 pos, inout vec4 o, ivec2 iu ) {\n    vec4 v = vec4( -1 ) ;\n    iu -= pos ;\n    if( iINSIDE( iu, ivec2(0), dim_player ) ) {\n        frame &= 0x3 ;\n        dir   &= 0x3 ;\n             if( dir == 1 )  iu = iu.yx ;                    //right\n        else if( dir == 2 )  iu = 15 - iu ;                  //down\n        else if( dir == 3 )  iu = ivec2( iu.y, 15 - iu.x ) ; //left\n        int row_group = frame * 4 + 3 - ( iu.y >> 2 ),\n            component = 3 - ( iu.y & 0x3 ),\n            sh = 2 * iu.x ;\n        uint bits = 0x3U << sh,\n             col_ind = ( get_player_br( row_group, component ) & bits ) >> sh ;\n        v = get_col( pal_player, col_ind ) ;\n    }\n    o = v.a > 0. ? v : o ;\n    return( v ) ;\n}\n\nvec4 draw_ladyfrog( int frame, int dir, ivec2 pos, inout vec4 o, ivec2 iu ) {\n    vec4 v = vec4( -1 ) ;\n    iu -= pos ;\n    if( iINSIDE( iu, ivec2(0), dim_player ) ) {\n        frame &= 0x3 ;\n        dir   &= 0x3 ;\n             if( dir == 1 )  iu = iu.yx ;                    //right\n        else if( dir == 2 )  iu = 15 - iu ;                  //down\n        else if( dir == 3 )  iu = ivec2( iu.y, 15 - iu.x ) ; //left\n        int row_group = frame * 4 + 3 - ( iu.y >> 2 ),\n            component = 3 - ( iu.y & 0x3 ),\n            sh = 2 * iu.x ;\n        uint bits = 0x3U << sh,\n             col_ind = ( get_player_br( row_group, component ) & bits ) >> sh ;\n        v = get_col( pal_ladyfrog, col_ind ) ;\n    }\n    o = v.a > 0. ? v : o ;\n    return( v ) ;\n}\n    \n#ifndef FD\n    #define FD 1\n#else\n    #if FD < 1 || FD > 5\n      #undef FD\n      #define FD 1\n    #endif\n#endif\n\nconst ivec2 scr_dim = ivec2( 224, 256 ) ;\n\n//END Common","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define GET_KEY(key)         texelFetch(iChannel3, ivec2((key),0), 0).x\n#define UPDATE_KEY(key,bit)  put_flag(state.z,(bit),GET_KEY(key))\n//#define KEY_PRESSED(key)    ( texelFetch(iChannel3, ivec2((key),1), 0).x > .5 )\n#define KEY_PRESSED(key,bit) (GET_KEY(key)>.5 && ! flag(state.z,(bit)))\n\n//hash11 taken from Dave Hoskins: https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 19.19;\n    p *= p + p;\n    return fract(p);\n}\n\n//only two levels have correct speeds\n\n#define NUM_LEVELS 2\n\nivec4 get_level_track_init( int level, int track_ind ) {\n    level %= NUM_LEVELS ;\n    if( level == 0 ) {\n        //                            num | len | space, speed | fdiv, res1, res2\n        if( track_ind == 9 ) return( ivec4(    0x030803,       0x0103,   0, 0 ) ) ;\n        if( track_ind == 8 ) return( ivec4(    0x040403,       0xff02,   0, 0 ) ) ;\n        if( track_ind == 7 ) return( ivec4(    0x020c04,       0x0101,   0, 0 ) ) ;\n        if( track_ind == 6 ) return( ivec4(    0x030604,       0x0106,   0, 0 ) ) ;\n        if( track_ind == 5 ) return( ivec4(    0x040602,       0xff02,   0, 0 ) ) ;\n\n        if( track_ind == 4 ) return( ivec4(    0x020407,       0xff02,   0, 0 ) ) ;\n        if( track_ind == 3 ) return( ivec4(    0x010200,       0x0103,   0, 0 ) ) ;\n        if( track_ind == 2 ) return( ivec4(    0x030206,       0xff04,   0, 0 ) ) ;\n        if( track_ind == 1 ) return( ivec4(    0x030206,       0x0105,   0, 0 ) ) ;\n        if( track_ind == 0 ) return( ivec4(    0x030207,       0xff06,   0, 0 ) ) ;\n    \n    } else if( level == 1 ) {\n    \n        if( track_ind == 9 ) return( ivec4(    0x030803,       0x0102,   0, 0 ) ) ;\n        if( track_ind == 8 ) return( ivec4(    0x050402,       0xff03,   0, 0 ) ) ;\n        if( track_ind == 7 ) return( ivec4(    0x010c00,       0x0102,   0, 0 ) ) ;\n        if( track_ind == 6 ) return( ivec4(    0x030603,       0x0105,   0, 0 ) ) ;\n        if( track_ind == 5 ) return( ivec4(    0x030606,       0xff01,   0, 0 ) ) ;\n    \n        if( track_ind == 4 ) return( ivec4(    0x030407,       0xff03,   0, 0 ) ) ;\n        if( track_ind == 3 ) return( ivec4(    0x020203,       0x0201,   0, 0 ) ) ;\n        if( track_ind == 2 ) return( ivec4(    0x040207,       0xff02,   0, 0 ) ) ;\n        if( track_ind == 1 ) return( ivec4(    0x040206,       0x0103,   0, 0 ) ) ;\n        if( track_ind == 0 ) return( ivec4(    0x040207,       0xff02,   0, 0 ) ) ;\n\n    } else if( level == 2 ) {\n\n        if( track_ind == 9 ) return( ivec4(    0x020803,       0x0103,   0, 0 ) ) ;\n        if( track_ind == 8 ) return( ivec4(    0x040404,       0xff02,   0, 0 ) ) ;\n        if( track_ind == 7 ) return( ivec4(    0x010c00,       0x0101,   0, 0 ) ) ;\n        if( track_ind == 6 ) return( ivec4(    0x030606,       0x0106,   0, 0 ) ) ;\n        if( track_ind == 5 ) return( ivec4(    0x030603,       0xff02,   0, 0 ) ) ;\n\n        if( track_ind == 4 ) return( ivec4(    0x030405,       0xff02,   0, 0 ) ) ;\n        if( track_ind == 3 ) return( ivec4(    0x020207,       0x0103,   0, 0 ) ) ;\n        if( track_ind == 2 ) return( ivec4(    0x050205,       0xff04,   0, 0 ) ) ;\n        if( track_ind == 1 ) return( ivec4(    0x040207,       0x0105,   0, 0 ) ) ;\n        if( track_ind == 0 ) return( ivec4(    0x040206,       0xff06,   0, 0 ) ) ;\n\n    } else if( level == 3 ) {\n\n        if( track_ind == 9 ) return( ivec4(    0x020803,       0x0103,   0, 0 ) ) ;\n        if( track_ind == 8 ) return( ivec4(    0x030405,       0xff02,   0, 0 ) ) ;\n        if( track_ind == 7 ) return( ivec4(    0x010c00,       0x0101,   0, 0 ) ) ;\n        if( track_ind == 6 ) return( ivec4(    0x020607,       0x0106,   0, 0 ) ) ;\n        if( track_ind == 5 ) return( ivec4(    0x030604,       0xff02,   0, 0 ) ) ;\n\n        if( track_ind == 4 ) return( ivec4(    0x040404,       0xff02,   0, 0 ) ) ;\n        if( track_ind == 3 ) return( ivec4(    0x030206,       0x0103,   0, 0 ) ) ;\n        if( track_ind == 2 ) return( ivec4(    0x040207,       0xff04,   0, 0 ) ) ;\n        if( track_ind == 1 ) return( ivec4(    0x040205,       0x0105,   0, 0 ) ) ;\n        if( track_ind == 0 ) return( ivec4(    0x040207,       0xff06,   0, 0 ) ) ;\n\n    } else if( level == 4 ) {\n    \n        if( track_ind == 9 ) return( ivec4(    0x010800,       0x0103,   0, 0 ) ) ;\n        if( track_ind == 8 ) return( ivec4(    0x030407,       0xff02,   0, 0 ) ) ;\n        if( track_ind == 7 ) return( ivec4(    0x010c00,       0x0101,   0, 0 ) ) ;\n        if( track_ind == 6 ) return( ivec4(    0x020605,       0x0106,   0, 0 ) ) ;\n        if( track_ind == 5 ) return( ivec4(    0x020607,       0xff02,   0, 0 ) ) ;\n\n        if( track_ind == 4 ) return( ivec4(    0x030403,       0xff02,   0, 0 ) ) ;\n        if( track_ind == 3 ) return( ivec4(    0x040205,       0x0103,   0, 0 ) ) ;\n        if( track_ind == 2 ) return( ivec4(    0x050204,       0xff04,   0, 0 ) ) ;\n        if( track_ind == 1 ) return( ivec4(    0x040206,       0x0105,   0, 0 ) ) ;\n        if( track_ind == 0 ) return( ivec4(    0x050205,       0xff06,   0, 0 ) ) ;\n    \n    }\n}\n\nfloat hpix_rand_seed = 0. ;\nfloat frame_rand_seed = 0. ;\n\n//integer rand [low,high>  (high is excluded!)\nint hpix_rand( int low, int high ) { //same pseudo rand sequence per frame per hor pixel\n    hpix_rand_seed = float( high - low ) * hash11( hpix_rand_seed ) ;\n    return( low + int( floor( hpix_rand_seed ) ) ) ;\n}\n\nint frame_rand( int low, int high ) { //same pseudo rand sequence per frame\n    frame_rand_seed = float( high - low ) * hash11( frame_rand_seed ) ;\n    return( low + int( floor( frame_rand_seed ) ) ) ;\n}\n\nvec4 draw_vehicle( int type, ivec2 pos, inout vec4 o, ivec2 iu ) ;\nvec4 draw_truck( int type, ivec2 pos, inout vec4 o, ivec2 iu ) ;\nvec4 draw_frog_wink( ivec2 pos, inout vec4 o, ivec2 iu ) ;\nvec4 draw_tile( int type, ivec2 pos, inout vec4 o, ivec2 iu ) ;\nvec4 draw_tile2( int type, ivec2 pos, inout vec4 o, ivec2 iu ) ;\nvec4 draw_half_tile( int type, ivec2 pos, inout vec4 o, ivec2 iu ) ;\nvec4 draw_croc( int type, ivec2 pos, inout vec4 o, ivec2 iu ) ;\nvec4 draw_wood( int type, ivec2 pos, inout vec4 o, ivec2 iu ) ;\nvec4 draw_turtle( int frame, ivec2 pos, inout vec4 o, ivec2 iu ) ;\nvec4 draw_turtle_dive( int frame, ivec2 pos, inout vec4 o, ivec2 iu ) ;\n\nbool pix_coll_player_car_track( ivec4 player, ivec2 track_off ) {\n    //test of player and cars track, single pixel collision within car track kills player\n    const ivec2 track_dim = ivec2( 256, 16 ) ;\n    ivec2 d, pos = player.xy, off = track_off ;\n    if( ! iRECTS_COLLIDE( ivec4( pos, dim_player ), ivec4( 0, off.y, track_dim ) ) ) {\n        return( false ) ;\n    }\n    int frame = int( player.w >= END_JUMP_T ) ;\n    int dir = player.z & 0x3 ;\n    for( d.y = 0 ; d.y < dim_player.y ; ++ d.y ) {\n        if( iINSIDE( pos.y + d.y, off.y, off.y + track_dim.y ) ) {\n            for( d.x = 0 ; d.x < dim_player.x ; ++ d.x ) {\n                vec4 dummy ;\n                if( draw_player( frame, dir, ivec2( 0 ), dummy, d ).a > 0. ) {\n                    vec4 b = texelFetch( iChannel0, ivec2( pos.x+off.x+d.x, pos.y+d.y ) & 0xff, 0 ) ;\n                    if( b != col_road ) {\n                        return( true ) ;\n                    }\n                }\n            }\n        }\n    }\n    return( false ) ;\n}        \n\nbool pix_coll_player_water_track( ivec4 player, ivec2 player_dim, ivec2 track_off, ivec2 track_dim ) {\n    //test 8x8 middle pixels of player for water, and if a single pixel is not on water than player lives\n    ivec2 d, pos = player.xy, off = track_off ;\n    if( ! iRECTS_COLLIDE( ivec4( pos, player_dim ), ivec4( 0, off.y, track_dim ) ) ) {\n        return( false ) ;\n    }\n    int num_pix_coll = 0 ;\n    for( d.y = 4 ; d.y < 12 ; ++ d.y ) {\n        if( iINSIDE( pos.y + d.y, off.y, off.y + track_dim.y ) ) {\n            for( d.x = 4 ; d.x < 12 ; ++ d.x ) {\n                vec4 dummy ;\n                if( draw_player( int( player.w >= END_JUMP_T ), player.z & 0x3, ivec2( 0 ), dummy, d ).a > 0. ) {\n                    vec4 b = texelFetch( iChannel0, ivec2( pos.x+off.x+d.x, pos.y+d.y ) & 0xff, 0 ) ;\n                    if( b != col_water ) {\n                        return( false ) ;\n                    }\n                }\n            }\n        }\n    }\n    return( true ) ;\n}\n\nbool coll_player_grass( ivec4 player, ivec4 state ) {\n    if( player.y > 12 * 16 + 4 ) {\n        int pos_x = player.x - 16 ; //hack -16\n        int home_ind = pos_x / 48 ;\n        int home_center = home_ind * 48 + 8 + 8 ;\n        if( abs( pos_x + 8 - home_center ) < 4 ) {\n            if( flag( state.z, 1 << home_ind ) ) {\n                return( true ) ;\n            }\n        } else {\n            return( true ) ;\n        }\n    }\n    return( false ) ;\n}\n\nvoid draw_turtle_anim_diving( ivec2 frames, ivec2 pos, inout vec4 o, ivec2 iu ) {\n    if( frames.y == 0 ) {\n        draw_turtle( frames.x, pos, o, iu ) ;\n    } else if( frames.y == 1 || frames.y == 5 ) {\n        draw_turtle_dive( 0, pos, o, iu ) ;\n    } else if( frames.y == 2 || frames.y == 4 ) {\n        draw_turtle_dive( 1, pos, o, iu ) ;\n    } else { //frames.y == 3\n        draw_turtle_dive( 2, pos, o, iu ) ;\n    }\n}\n\nvoid init_tracks_gfx( int level, inout vec4 o, ivec2 iu ) {\n\n    int row = iu.y >> 4 ;\n\n    if( row >= 2 && row <= 6 ) {\n        //prepare road tracks (each road track is 256x16 static image of cars)\n        int track_ind = row - 2 ;\n        ivec4 track_init = get_level_track_init( level, track_ind ) ;\n        int num_obj = track_init.x >> 16,\n            len =     ( track_init.x & 0xff00 ) >> 9,\n            space =   track_init.x & 0xff,\n            tot_len = len * 16 + space * 8,\n            nx = 256 - iu.x ;\n        if( nx < num_obj * tot_len - space * 8 ) {\n            int x = nx % tot_len,\n                p = nx / tot_len ;\n            if( x < len * 16 ) {\n                DBG( o = vec4( 1, float(x)/56., 0, 1 ) ) ;\n                if( track_ind < 4 ) {\n                    draw_vehicle( track_ind, ivec2( 256-15 - ( p * tot_len + (x & ~0xf) ), iu.y & ~0xf ), o, iu ) ;\n                } else {\n                    draw_truck( 0 + int( x < 16 ), ivec2( 256-15 - ( p * tot_len + (x & ~0xf) ), iu.y & ~0xf ), o, iu ) ;\n                }\n            }\n        }\n    }\n\n    else if( row >= 8 && row <= 12 ) {\n        //prepare water tracks (logs are static 256x16, turtles are dynamic 256x16 images)\n        int track_ind = row - 8 + 5 ;\n        ivec4 track_init = get_level_track_init( level, track_ind ) ;\n        int num_obj = track_init.x >> 16,\n            len =     ( track_init.x & 0xff00 ) >> 9,\n            space =   track_init.x & 0xff,\n            tot_len = len * 16 + space * 8,\n            nx = 256 - iu.x ;\n        if( nx < num_obj * tot_len - space * 8 ) {\n            int x = nx % tot_len,\n                p = nx / tot_len ;\n            if( x < len * 16 ) {\n                DBG( o = vec4( 1, float(x)/56., 0, 1 ) ) ;\n                if( track_ind == 5 || track_ind == 8 ) {\n                    draw_turtle( 0, ivec2( 256-15 - ( p * tot_len + (x & ~0xf) ), iu.y & ~0xf ), o, iu ) ;\n                } else {\n                    draw_wood( 0 + int( x < (len-1)*16 ) + int( x < 16 ), ivec2( 256-15 - ( p * tot_len + (x & ~0xf) ), iu.y & ~0xf ), o, iu ) ;\n                }\n            }\n        }\n    }\n}\n\nconst ivec2 player_start_pos = ivec2( 8*16, 16 ) ;\nconst ivec4 ladyfrog_init = ivec4( 256 - 18, 9 * 16, 0x0203, LADYFROG_LONG_T ) ;\n\nvoid mainImage( out vec4 o, vec2 u )\n{\n    ivec2 iu = ivec2( u ) ;\n\n    if( iu.x >= 256 || iu.y >= 256 ) {\n        discard ;\n    } else\n        //HACK\n        //without the else block after discard, fullscreen fps is 9 (with else almost 60!)\n        //(MacOS Sierra 10.12.6, Intel Iris)\n    {\n        hpix_rand_seed = fract( sin( 1. + u.x + iTime + iTimeDelta + iDate.w ) ) ;\n        frame_rand_seed = fract( sin( iTime + iTimeDelta + iDate.w ) ) ;\n\n        int game_frame = iFrame ;\n\n#if FD > 1\n        //skip frames\n        game_frame /= FD ;\n        if( iFrame % FD != 0 ) {\n            o = texelFetch( iChannel0, iu, 0 ) ; //copy data from front buffer of Buffer A\n            return ;\n        } else\n#endif\n        {\n\n            ivec4\n                 DBG( debug_var )\n                ,state         //x=state, y=player level timer, z=flags, w=time(/state)\n                ,player        //x,y, z=state, w=time(/state)\n                ,score         //x=score, y=hiscore\n                ,turtle_anims  //x=swimming frame, y=sequence offset, zw=turtle 3,2 dive frame\n                ,ladyfrog      //xy, z=orientation, w=timing\n                ,timers\n                ,fly_n_croc\n                ,m_track[10] //x source off, y pos\n            ;\n\n            int level ;\n            \n            state = LOADI( adr_state ) ;\n\n            if( iFrame < 2 || KEY_PRESSED( KEY_RESTART, STATE_FLAG_KEY_RESTART ) ) {\n\n                DBG( debug_var = ivec4( 0 ) ) ;\n\n                if( iFrame < 2 ) {\n                    score = ivec4( 0 ) ; //score,hiscore,current level,last home ind and time \n                    state = ivec4( STATE_PLAYING, 60*32, 0, 0 ) ; //state, player timer, flags, time\n                } else {\n                    //restart key was pressed, keep hiscore (score.y)\n                    score = LOADI( adr_score ) ;\n                    score = ivec4( 0, score.y, 0, 0 ) ;\n                }\n\n                state =        ivec4( STATE_PLAYING, 60*32, 0, 0 ) ; //state, player timer, flags, time\n                player =       ivec4( player_start_pos, (4<<16) | (1<<4), 0 ) ; //xy, z=lives<<16 | flags<<8 | track<<4 | dir, w=time(/state)\n                turtle_anims = ivec4( 0, 0, 1, 0 ) ; //x=swim frame,y=offset for dive sequence,z=turtle3 dive frame,w=turtle2 dive frame\n                ladyfrog =     ladyfrog_init ; //xy, z=state<<8 | orientation, w=time\n                timers =       ivec4( 0 ) ; //x=timer for showing bonus pts\n                fly_n_croc =   ivec4( 0, 0, CROC_T, FLY_T ) ; //x=fly home ind, y=croc home ind, z=croc time, w=fly time\n\n                level = score.z ;\n\n                if( iINSIDE( iu, madr_track[0], madr_track[9] + 1 ) ) {\n                \n                    //init track data\n                    //track ivec4: x = x_src_off,\n                    //             y = y_dst_pos,\n                    //             z = num_obj | len_obj | space  (3 bytes, len,space are in 8px)\n                    //             w = speed | frame_divisor      (2 bytes)\n                    int track_ind = iu.x - madr_track[0].x ;\n                    ivec4 track_init = get_level_track_init( level, track_ind ) ;\n                    o = vec4( 0, 32 + ( track_ind + int( track_ind >= 5 ) ) * 16, track_init.xy ) ;\n                    return ;\n\n                } else {\n\n                    o = iu.y < scr_dim.y / 2 ? col_road : col_water ;\n\n                    int row = iu.y >> 4 ;\n                    ivec2 pos = iu & ~0xf ;\n\n                    if( row == 1 || row == 7 ) {\n                        draw_tile( 0, pos, o, iu ) ; //sidewalks\n                    } else if( row == 13 ) {\n                        int type = ( iu.x % 48 ) / 16 + 1 ;\n                        draw_tile( type, pos, o, iu ) ; //grass homes\n                    } else if( row == 14 && ( iu.y & 0xf ) < 8 ) {\n                        int type = ( iu.x % 48 ) / 16 + 1 ;\n                        draw_half_tile( type, pos, o, iu ) ; //top 8 pixels of grass homes\n                    } else {\n                        init_tracks_gfx( level, o, iu ) ;\n                    }\n                }\n\n            } else {\n\n                o = texelFetch( iChannel0, iu, 0 ) ;\n\n                score =         LOADI( adr_score ) ;\n                level =         score.z ;\n                player =        LOADI( adr_player ) ;\n                turtle_anims =  LOADI( adr_turtle_anims ) ;\n                ladyfrog =      LOADI( adr_ladyfrog ) ;\n                timers =        LOADI( adr_timers ) ;\n                fly_n_croc =    LOADI( adr_fly_n_croc ) ;\n\n                if( ( state.x == STATE_PLAYING ) && KEY_PRESSED( KEY_PAUSE, STATE_FLAG_KEY_PAUSE ) ) {\n                    toggle_flag( state.z, STATE_FLAG_PAUSED ) ;\n                }\n\n                if( state.x == STATE_GAME_OVER || flag( state.z, STATE_FLAG_PAUSED ) ) {\n\n                    UPDATE_KEY( KEY_PAUSE, STATE_FLAG_KEY_PAUSE ) ;\n                    STOREI( adr_state, state ) ;\n                    return ;\n                    \n                } else if( state.x == STATE_LEV_COMPLETE ) {\n                    \n                    level ++ ;\n\n                    int row = iu.y >> 4 ;\n\n                    if( row >= 2 && row <= 12 && row != 7 ) {\n                        o = iu.y < scr_dim.y / 2 ? col_road : col_water ;\n                        init_tracks_gfx( level, o, iu ) ;\n                        return ;\n                    } else if( iINSIDE( iu, madr_track[0], madr_track[9] + 1 ) ) {\n\t\t\t\t\t\tint track_ind = iu.x - madr_track[0].x ;                        \n                        ivec4 track_init = get_level_track_init( level, track_ind ) ;\n                        o = vec4( 0, 32 + ( track_ind + int( track_ind >= 5 ) ) * 16, track_init.xy ) ;\n                        return ;\n                    }\n\n                    state.x = STATE_FROGS_WINKING ;\n                    state.w = FROG_WINK_TOTAL_T ;\n\n                    //player = ivec4( player_start_pos, (4<<16) | (1<<4), 0 ) ; //xy, z=lives<<16 | flags<<8 | track<<4 | dir, w=time(/state)\n                    player.xy = player_start_pos ;\n                    player.z = ( player.z & ~ 0xffff ) | (1<<4) ; //keep lives, reset flags, reached track and orientation\n\n                    turtle_anims = ivec4( 0, 0, 1, 0 ) ; //x=swim frame,y=offset for dive sequence,z=turtle3 dive frame,w=turtle2 dive frame\n                    ladyfrog =     ladyfrog_init ; //xy, z=state<<8 | orientation, w=time\n                    //timers =       ivec4( 0 ) ; //x=timer for showing bonus pts\n                    fly_n_croc =   ivec4( 0, 0, CROC_T, FLY_T ) ; //x=fly home ind, y=croc home ind, z=croc time, w=fly time\n\n                } else if( state.x == STATE_PLAYING || state.x == STATE_FROGS_WINKING ) {\n                    \n                    int row = iu.y >> 4 ;\n                    int col_off_8 = ( iu.x - 8 ) >> 4 ; //for homes\n\n                    DBG( debug_var = state ) ;\n                    if( state.x == STATE_FROGS_WINKING ) {\n                        \n                        if( state.w > 0 ) {\n                            if( flag( state.z, STATE_FLAGS_ALL_HOMES ) && row == 13 && col_off_8 % 3 == 0 ) {\n                                int home_ind = col_off_8 / 3 ;\n                                o = col_water ; //clear by default\n                                ivec2 pos = ivec2( 8 + 48 * home_ind, 13 * 16 ) ;\n                                int t = FROG_WINK_TOTAL_T - state.w ;\n                                int up_to_home_ind = - 1 ;\n                                t -= FROG_WINK_WAIT_T ;\n                                if( t >= 0 && t < FROG_WINK_T ) {\n                                    up_to_home_ind = 0 ;\n                                } else {\n                                    t -= FROG_WINK_T ;\n                                    if( t >= 0 ) {\n                                        up_to_home_ind = 1 + t / FROG_WINK_T2 ;\n                                    }\n                                }\n                                if( home_ind <= up_to_home_ind ) {\n                                    draw_frog_wink( pos, o, iu ) ;\n                                } else {\n                                    draw_tile2( 0, pos, o, iu ) ; //saved frog\n                                }\n                            }\n                            state.w -- ;\n                            if( state.w <= 0 ) {\n                                clear_flag( state.z, STATE_FLAGS_ALL_HOMES ) ;\n                            }\n                        }\n                    }\n\n                    //auto tracks and sidewalks never change\n                    //bottom two log tracks also never change\n                    if( ! ( ( row >= 1 && row <= 7 ) || row == 9 || row == 10 ) ) {\n\n                        int croc_head_frame = ( game_frame >> 7 ) & 1 ;\n\n                        if( iu == adr_turtle_anims ) {\n                            const uvec2 turtle_sequences = uvec2( 0x04e904e9U, 0x04510401 ) ;\n                            //x=swimming frame, y=diving sequences bit pos\n                            //z=3 turtles dive frame, w=2 turtles dive frame\n                            if( ( game_frame & 0x7 ) == 0 ) {\n                                //diving animation\n                                turtle_anims.y ++ ; //every 8 frames change which bit to check for frame change\n                                turtle_anims.y &= 0x1f ;\n                                turtle_anims.zw += ivec2( bvec2( turtle_sequences.xy & ( 1U << turtle_anims.y ) ) ) ;\n                                turtle_anims.zw %= 6 ;\n\n                                if( ( game_frame & 0xf ) == 0 ) {\n                                    //swimming animation (every 16 frames)\n                                    turtle_anims.x ++ ;\n                                    turtle_anims.x %= 3 ;\n                                }\n                            }\n                        }\n\n                        //croc in the last water track\n                        //TODO everything\n                        else if( iINSIDE( iu, ivec2( 256 - 64, 12 * 16 ), ivec2( 256, 12 * 16 + 16 ) ) ) {\n                            ivec2 pos = ivec2( 256 - 32, 12 * 16 ) ;\n                            o = col_water ;\n                            draw_croc( 2 + croc_head_frame, pos, o, iu ) ;\n                            pos.x -= 16 ;\n                            draw_croc( 1, pos, o, iu ) ;\n                            pos.x -= 16 ;\n                            draw_croc( 0, pos, o, iu ) ;\n                        }\n\n                        //turtles in groups of 3 (track 5, pos y=8*16)\n                        //TODO draw only when anim frame changes\n                        else if( row == 8 ) {\n                            o = col_water ;\n                            ivec4 track = LOADI( madr_track[5] ) ;\n                            int num_obj = track.z >> 16,\n                                len =     ( track.z & 0xff00 ) >> 9,\n                                space =   track.z & 0xff,\n                                tot_len = len * 16 + space * 8,\n                                nx = 256 - iu.x ;\n                            if( nx < (num_obj-1) * tot_len - space * 8 ) {\n                                int x = nx % tot_len,\n                                    p = nx / tot_len ;\n                                if( x < len * 16 ) {\n                                    DBG( o = vec4( 1, float(x)/56., 0, 1 ) ) ;\n                                    draw_turtle( turtle_anims.x, ivec2( 256-15 - ( p * tot_len + (x & ~0xf) ), iu.y & ~0xf ), o, iu ) ;\n                                }\n                            } else if( nx < num_obj * tot_len - space * 8 ) {\n                                int x = nx % tot_len,\n                                    p = nx / tot_len ;\n                                if( x < len * 16 ) {\n                                    DBG( o = vec4( 1, float(x)/56., 0, 1 ) ) ;\n                                    draw_turtle_anim_diving( turtle_anims.xz, ivec2( 256-15 - ( p * tot_len + (x & ~0xf) ), iu.y & ~0xf ), o, iu ) ;\n                                }\n                            }\n\n                        }\n\n                        //turtles in groups of 2 (track 8, pos y=11*16)\n                        //TODO draw only when anim frame changes\n                        else if( row == 11 ) {\n                            o = col_water ;\n                            ivec4 track = LOADI( madr_track[8] ) ;\n                            int num_obj = track.z >> 16,\n                                len =     ( track.z & 0xff00 ) >> 9,\n                                space =   track.z & 0xff,\n                                tot_len = len * 16 + space * 8,\n                                nx = 256 - iu.x ;\n                            if( nx < (num_obj-1) * tot_len - space * 8 ) {\n                                int x = nx % tot_len,\n                                    p = nx / tot_len ;\n                                if( x < len * 16 ) {\n                                    DBG( o = vec4( 1, float(x)/56., 0, 1 ) ) ;\n                                    draw_turtle( turtle_anims.x, ivec2( 256-15 - ( p * tot_len + (x & ~0xf) ), iu.y & ~0xf ), o, iu ) ;\n                                }\n                            } else if( nx < num_obj * tot_len - space * 8 ) {\n                                int x = nx % tot_len,\n                                    p = nx / tot_len ;\n                                if( x < len * 16 ) {\n                                    DBG( o = vec4( 1, float(x)/56., 0, 1 ) ) ;\n                                    draw_turtle_anim_diving( turtle_anims.xw, ivec2( 256-15 - ( p * tot_len + (x & ~0xf) ), iu.y & ~0xf ), o, iu ) ;\n                                }\n                            }\n                        }\n\n                        //homes with saved frogs, flies, croc\n                        //TODO don't draw every frame\n                        else if( state.x != STATE_FROGS_WINKING && row == 13 && col_off_8 % 3 == 0 ) {\n                            int home_ind = col_off_8 / 3 ;\n                            o = col_water ; //clear by default\n                            ivec2 pos = ivec2( 8 + 48 * home_ind, 13 * 16 ) ;\n                            if( flag( state.z, 1 << home_ind ) ) {\n                                draw_tile2( 0, pos, o, iu ) ; //saved frog\n                            } else if( fly_n_croc.x == home_ind && fly_n_croc.w < 0 ) {\n                                draw_tile2( 1, pos, o, iu ) ; //fly\n                            } else if( fly_n_croc.y == home_ind && fly_n_croc.z < 0 ) {\n                                if( fly_n_croc.z < - HALF_CROC_T ) {\n                                    draw_tile2( 2, pos, o, iu ) ; //half croc\n                                } else {\n                                    draw_tile2( 3, pos, o, iu ) ; //croc\n                                }\n                            }\n                        }\n\n                        //load tracks data\n                        for( int i = 0 ; i < 10 ; ++ i ) {\n                            m_track[i] = LOADI( madr_track[i] ) ;\n                        }\n\n                        int old_lady_track_x = m_track[6].x ;\n\n                        //cycle src_off_x for tracks\n                        for( int i = 0 ; i < 10 ; ++ i ) {\n                            if( game_frame % ( m_track[i].w & 0xff ) == 0 ) { //frame division\n                                m_track[i].x -= m_track[i].w >> 8 ; //speed\n                                m_track[i].x &= 0xff ; //wrap\n                            }\n                            STOREI( madr_track[i], m_track[i] ) ;\n                        }\n\n                        if( ( m_track[6].x >= 0 && m_track[6].x < 4 ) && m_track[6].x != old_lady_track_x ) {\n                            if( ! flag( state.z, STATE_FLAG_LADY_ACTIVE ) ) {\n                                set_flag( state.z, STATE_FLAG_LADY_ACTIVE ) ;\n                                ladyfrog = ladyfrog_init ;\n                            }\n                        }\n\n                        if( ( ladyfrog.z & 0xff00 ) == 0x1000 ) {\n                            ladyfrog.xy = player.xy - ivec2( 0, 2 ) ;\n                            ladyfrog.z = 0x1000 | ( player.z & 0x3 ) ;\n                        } else if( ( ladyfrog.z & 0xff00 ) == 0x0000 ) {\n                            if( -- ladyfrog.w <= 0 ) ladyfrog.zw = ivec2( 0x0101, LADYFROG_JUMP_T ) ;\n                        } else if( ( ladyfrog.z & 0xff00 ) == 0x0100 ) {\n                            ladyfrog.x += JUMP_SPEED ;\n                            if( -- ladyfrog.w <= 0 ) ladyfrog.zw = ivec2( 0x0200, LADYFROG_SHORT_T ) ;\n                        } else if( ( ladyfrog.z & 0xff00 ) == 0x0200 ) {\n                            if( -- ladyfrog.w <= 0 ) ladyfrog.zw = ivec2( 0x0303, LADYFROG_SHORT_T ) ;\n                        } else if( ( ladyfrog.z & 0xff00 ) == 0x0300 ) {\n                            if( -- ladyfrog.w <= 0 ) ladyfrog.zw = ivec2( 0x0403, LADYFROG_JUMP_T ) ;\n                        } else if( ( ladyfrog.z & 0xff00 ) == 0x0400 ) {\n                            ladyfrog.x -= JUMP_SPEED ;\n                            if( -- ladyfrog.w <= 0 ) ladyfrog.zw = ivec2( 0x0503, LADYFROG_LONG_T ) ;\n                        } else if( ( ladyfrog.z & 0xff00 ) == 0x0500 ) {\n                            if( -- ladyfrog.w <= 0 ) ladyfrog.zw = ivec2( 0x0603, LADYFROG_JUMP_T ) ;\n                        } else if( ( ladyfrog.z & 0xff00 ) == 0x0600 ) {\n                            ladyfrog.x -= JUMP_SPEED ;\n                            if( -- ladyfrog.w <= 0 ) ladyfrog.zw = ivec2( 0x0700, LADYFROG_SHORT_T ) ;\n                        } else if( ( ladyfrog.z & 0xff00 ) == 0x0700 ) {\n                            if( -- ladyfrog.w <= 0 ) ladyfrog.zw = ivec2( 0x0801, LADYFROG_SHORT_T ) ;\n                        } else if( ( ladyfrog.z & 0xff00 ) == 0x0800 ) {\n                            if( -- ladyfrog.w <= 0 ) ladyfrog.zw = ivec2( 0x0901, LADYFROG_JUMP_T ) ;\n                        } else if( ( ladyfrog.z & 0xff00 ) == 0x0900 ) {\n                            ladyfrog.x += JUMP_SPEED ;\n                            if( -- ladyfrog.w <= 0 ) ladyfrog.zw = ivec2( 0x0001, LADYFROG_LONG_T ) ;\n                        }\n                        if( ( ladyfrog.z & 0xff00 ) != 0x1000 ) {\n                            if( game_frame % ( m_track[6].w & 0xff ) == 0 ) {\n                                int track_speed = m_track[6].w >> 8 ;\n                                if( track_speed >= 128 ) track_speed -= 256 ;\n                                ladyfrog.x += track_speed ;\n                                ladyfrog.x &= 0xff ;\n                            }\n                            if( flag( state.z, STATE_FLAG_LADY_ACTIVE ) ) {\n                                ivec2 d = abs( ladyfrog.xy - player.xy ) ;\n                                if( d.x < 4 && d.y < 4 ) {\n                                    ladyfrog.z = 0x1000 ;\n                                }\n                            }\n                        }\n\n                        if( DBG( iu == adr_debug_var || )\n                              iu == adr_timers || iu == adr_ladyfrog || iu == adr_fly_n_croc\n                           || iu == adr_player || iu == adr_state || iu == adr_score ) {\n\n                            if( fly_n_croc.z >= 0 ) {\n                                fly_n_croc.z -- ;\n                                if( fly_n_croc.z <= 0 ) {\n                                    fly_n_croc.z = - ( CROC_T + HALF_CROC_T ) ;\n                                    fly_n_croc.y = frame_rand( 0, 5 ) ;\n                                    if( fly_n_croc.y == fly_n_croc.x ) {\n                                        fly_n_croc.y = - 1 ;\n                                    }\n                                }\n                            } else {\n                                fly_n_croc.z ++ ;\n                                if( fly_n_croc.z >= 0 ) {\n                                    fly_n_croc.z = CROC_T ;\n                                }\n                            }\n                            if( fly_n_croc.w >= 0 ) {\n                                fly_n_croc.w -- ;\n                                if( fly_n_croc.w <= 0 ) {\n                                    fly_n_croc.w = - FLY_T ;\n                                    fly_n_croc.x = frame_rand( 0, 5 ) ;\n                                    if( fly_n_croc.x == fly_n_croc.y ) {\n                                        fly_n_croc.x = - 1 ;\n                                    }\n                                }\n                            } else {\n                                fly_n_croc.w ++ ;\n                                if( fly_n_croc.w >= 0 ) {\n                                    fly_n_croc.w = FLY_T ;\n                                }\n                            }\n\n                            //bonus points for flies and/or ladyfrog (200+200)\n                            if( timers.x > 0 ) {\n                                timers.x -- ;\n                                if( timers.x <= 0 ) {\n                                    timers.x = 0 ;\n                                    clear_flag( state.z, STATE_FLAG_BONUS_FLY | STATE_FLAG_BONUS_LADY ) ;\n                                }\n                            }\n                            //\"time bonus\", or at lev complete \"time bonus\" and then \"start\"\n                            if( timers.y > 0 ) {\n                                timers.y -- ;\n                            } else if( timers.y < 0 ) {\n                                timers.y ++ ;\n                            }\n                            //wait to show player after lev complete\n                            if( timers.z > 0 ) {\n                                timers.z -- ;                                    \n                            }\n                            //wait to allow playing after lev complete\n                            if( timers.w > 0 ) {\n                                timers.w -- ;\n                                if( timers.w <= 0 ) {\n                                    state.x = STATE_PLAYING ;\n                                }\n                            }\n\n                            //player.xy -> xy pos\n\n                            //player.z & 0x3 -> orientation (0-up,1-right,2-down,3-left)\n                            //player.z & 0xf0 -> reached track (0-9) so we can give points\n                            //player.z & 0xff00 -> flags\n                            //player.z & 0xff0000 -> number of lives\n\n                            //player.w < 0 -> death\n                            //player.w == 0 -> sitting still (able to jump)\n                            //player.w in [1,END_JUMP_T> -> sitting in last jump phase (not able to jump)\n                            //player.w >= END_JUMP_T -> jump in move phase\n\n                            int player_dir = player.z & 0x3 ;\n                            int old_track = ( player.z & 0xf0 ) >> 4 ;\n\n                            //CHECK! is it ok for this to not be in the following if block?\n                            {\n                                if( player.w >= 0 && player.w < END_JUMP_T  //sitting or jump in sitting phase in any orientation\n                                   || ( player.w >= 0 && ( player.z & 1 ) == 1 ) //or oriented horizontally (jump in move phase or not)\n                                   || ( player.w < 0 && ! flag( player.z, PLAYER_FLAG_DROWN ) ) ) { //or dying on logs or turtles\n                                    //move with water tracks if in them\n                                    for( int i = 5 ; i < 10 ; ++ i ) {\n                                        if( player.y == ( i + 3 ) * 16 ) {\n                                            if( game_frame % ( m_track[i].w & 0xff ) == 0 ) {\n                                                int track_speed = m_track[i].w >> 8 ;\n                                                if( track_speed >= 128 ) track_speed -= 256 ;\n                                                player.x += track_speed ;\n                                                if( player.w >= 0 && ( player.x >= 224 + 16 || player.x < 0 ) ) {\n                                                    player.w = - 80 ; //kill if went out of the screen\n                                                }\n                                            }\n                                            break ;\n                                        }\n                                    }\n                                }\n                                player.x &= 0xff ; //so dying player cycles the screen if on logs\n                            }\n\n                            if( state.x == STATE_PLAYING ) {\n                                if( player.w >= 0 ) { //not dying\n                                    if( player.w >= END_JUMP_T ) { //jump in move phase\n                                        if( player_dir == 0 ) {\n                                            player.y += JUMP_SPEED ;\n                                        } else if( player_dir == 1 ) {\n                                            player.x += JUMP_SPEED ;\n                                        } else if( player_dir == 2 ) {\n                                            player.y -= JUMP_SPEED ;\n                                        } else {\n                                            player.x -= JUMP_SPEED ;\n                                        }\n                                    }\n\n                                    if( player.w == 0 ) { //sitting (and jump fully ended)\n                                        if( KEY_PRESSED( KEY_LEFT, STATE_FLAG_KEY_LEFT ) && player.x > 16 ) {\n                                            player.z = ( player.z & ~0x3 ) | 3 ;\n                                            player.w = JUMP_T ;\n                                        } else if( KEY_PRESSED( KEY_RIGHT, STATE_FLAG_KEY_RIGHT ) && player.x < 224 ) {\n                                            player.z = ( player.z & ~0x3 ) | 1 ;\n                                            player.w = JUMP_T ;\n                                        } else if( KEY_PRESSED( KEY_UP, STATE_FLAG_KEY_UP ) && player.y <= 12*16 ) {\n                                            player.z = ( player.z & ~0x3 ) | 0 ;\n                                            player.w = JUMP_T ;\n                                        } else if( KEY_PRESSED( KEY_DOWN, STATE_FLAG_KEY_DOWN ) && player.y > 0 ) {\n                                            player.z = ( player.z & ~0x3 ) | 2 ;\n                                            player.w = JUMP_T ;\n                                        }\n                                    }\n\n                                    if( player.w > 0 ) { //player in jump\n                                        player.w -- ;\n                                        if( player.w <= 0 ) {\n                                            player.w = 0 ;\n                                        }\n                                    }\n\n                                    //collision with cars                    \n                                    for( int i = 0 ; i < 5 ; ++ i ) {\n                                        if( pix_coll_player_car_track( player, m_track[i].xy ) ) {\n                                            player.w = - 80 ; //kill player\n                                            break ;\n                                        }\n                                    }\n\n                                    //collision with water\n                                    if( player.w >= 0 && ( player.w > JUMP_T || player.w < END_JUMP_T ) ) {\n                                        for( int i = 5 ; i < 10 ; ++ i ) {\n                                            if( pix_coll_player_water_track( player, dim_player, m_track[i].xy, ivec2( 256, 16 ) ) ) {\n                                                set_flag( player.z, PLAYER_FLAG_DROWN ) ;\n                                                player.w = - 80 ; //kill player\n                                                break ;\n                                            }\n                                        }\n                                    }\n\n                                    //collision with croc's open mouth on water\n                                    if( player.w >= 0 && player.y > 11*16 + 4 ) {\n                                        if( croc_head_frame == 1 ) {\n                                            ivec2 croc_head_pos = ivec2( (256-32 + 8 - m_track[9].x ) & 0xff, m_track[9].y ) ;\n                                            DBG( debug_var.xy = croc_head_pos ) ;\n                                            if( iRECTS_COLLIDE( ivec4(croc_head_pos,8,16), ivec4( player.xy, dim_player ) ) ) {\n                                                player.w = - 80 ; //kill player\n                                            }\n                                        }\n                                    }\n\n                                    //collision with grass\n                                    if( player.w >= 0 && coll_player_grass( player, state ) ) {\n                                        player.w = - 80 ;\n                                    }\n\n                                    //collision with whole croc in home\n                                    if( player.w >= 0 && player.y > 12*16 + 4 ) {\n                                        int home_ind = player.x / 48 ; \n                                        if( home_ind == fly_n_croc.y\n                                           && fly_n_croc.z < 0\n                                           && fly_n_croc.z >= - HALF_CROC_T ) {\n                                            player.w = - 80 ; //kill player\n                                        }\n                                    }\n\n                                    //player timer\n                                    if( state.y > 0 ) {\n                                        state.y -- ;\n                                        if( state.y <= 0 ) {\n                                            player.w = - 80 ; //kill player\n                                        }\n                                    }\n\n                                    if( player.w >= 0 ) { //alive\n                                        int old_score = score.x ;\n                                        int curr_track = player.y >> 4 ;\n                                        if( curr_track >= 7 ) curr_track -- ;\n                                        if( curr_track > old_track ) {\n                                            if( curr_track == 12 ) {\n                                                //nothing\n                                            } else {\n                                                score.x += PTS_TRACK ;\n                                            }\n                                            //keep new current track\n                                            player.z = ( player.z & ~0xf0 ) | ( curr_track << 4 ) ;\n                                        }\n\n                                        if( player.y >= 12*16 + 10 ) {\n                                            score.x += PTS_FROG_SAVED ;\n                                            if( ( ladyfrog.z & 0xff00 ) == 0x1000 ) {\n                                                score.x += PTS_LADYFROG_BONUS ;\n                                                set_flag( state.z, STATE_FLAG_BONUS_LADY ) ;\n                                                timers.x = BONUS_SHOW_T ;\n                                                clear_flag( state.z, STATE_FLAG_LADY_ACTIVE ) ;\n                                                ladyfrog = ladyfrog_init ;\n                                            }\n                                            int home_ind = player.x / 48 ;\n                                            if( fly_n_croc.w < 0 && home_ind == fly_n_croc.x ) {\n                                                score.x += PTS_FLY_BONUS ;\n                                                set_flag( state.z, STATE_FLAG_BONUS_FLY ) ;\n                                                timers.x = BONUS_SHOW_T ;\n                                            }\n                                            score.x += ( state.y >> 5 ) * PTS_TIME_BONUS ;\n\n                                            //keep last time and home ind for renderer\n                                            score.w = ( state.y & ~0x1f ) | ( home_ind & 0x7 ) ;\n                                            timers.y = - TIME_BONUS_SHOW_T ; //one frog saved\n                                            set_flag( state.z, 1 << home_ind ) ; //mark used home\n                                            if( ( state.z & STATE_FLAGS_ALL_HOMES ) == STATE_FLAGS_ALL_HOMES ) {\n                                                score.x += PTS_LEV_COMPLETE ;\n                                                state.x = STATE_LEV_COMPLETE ;\n                                                timers.y = TIME_BONUS_SHOW_T2 + START_SHOW_T ;\n                                                timers.z = PLAYER_WAIT_T ;\n                                                timers.w = TIME_BONUS_SHOW_T2 + NEW_LEV_WAIT_T ;\n                                            }\n                                            player.xy = player_start_pos ;\n                                            player.z = ( player.z & ~0xf0 ) | ( 1 << 4 ) ; //reset reached track\n                                            player.w = 0 ; //reset jump\n                                            state.y = 60*32 ;\n                                        }\n\n                                        score.y = max( score.x, score.y ) ;\n\n                                        if( score.x != old_score && score.x % PTS_EXTRA_LIFE == 0 ) {\n                                            player.z += 1 << 16 ;\n                                        }\n                                    }\n\n                                } else {\n                                    if( ( ladyfrog.z & 0xff00 ) == 0x1000 && flag( state.z, STATE_FLAG_LADY_ACTIVE ) ) {\n                                        clear_flag( state.z, STATE_FLAG_LADY_ACTIVE ) ;\n                                        ladyfrog = ladyfrog_init ;\n                                    }\n\n                                    player.w ++ ;\n                                    if( player.w >= 0 ) {\n                                        player.w = 0 ;\n                                        int lives = player.z >> 16 ;\n                                        if( lives == 0 ) {\n                                            state.x = STATE_GAME_OVER ;\n                                        } else {\n                                            lives -- ;\n                                            player.xy = player_start_pos ;\n                                            state.y = 60*32 ;\n                                        }\n                                        player.z = ( lives << 16 ) | ( 1 << 4 ) ; //reset reached track, and flags\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }        \n            }\n\n            if( iu == adr_state ) {\n                UPDATE_KEY( KEY_LEFT,    STATE_FLAG_KEY_LEFT    ) ;\n                UPDATE_KEY( KEY_UP,      STATE_FLAG_KEY_UP      ) ;\n                UPDATE_KEY( KEY_RIGHT,   STATE_FLAG_KEY_RIGHT   ) ;\n                UPDATE_KEY( KEY_DOWN,    STATE_FLAG_KEY_DOWN    ) ;\n                UPDATE_KEY( KEY_RESTART, STATE_FLAG_KEY_RESTART ) ;\n                UPDATE_KEY( KEY_PAUSE,   STATE_FLAG_KEY_PAUSE   ) ;\n            }\n\n            DBG( STOREI( adr_debug_var,    debug_var ) ) ;\n\n            STOREI( adr_state,        state        ) ;\n            STOREI( adr_player,       player       ) ;\n            score.z = level ;\n            STOREI( adr_score,        score        ) ;\n            STOREI( adr_turtle_anims, turtle_anims ) ;\n            STOREI( adr_ladyfrog,     ladyfrog     ) ;\n            STOREI( adr_timers,       timers       ) ;\n            STOREI( adr_fly_n_croc,   fly_n_croc   ) ;\n        }\n    }\n}\n\n#define _ 0U\n#define r 1U\n#define g 2U\n#define y 3U\n\nconst uvec4 gfx_tile[] = uvec4[4*4](\n    uvec4( BR16( _,y,_,_,y,y,_,_,y,_,_,y,y,_,_,_ ),\n           BR16( y,y,y,y,y,y,y,y,y,_,y,y,y,y,y,y ),\n           BR16( y,y,g,y,y,y,y,g,y,y,y,y,y,g,y,y ),\n           BR16( y,g,r,g,y,y,g,r,g,y,y,y,g,r,g,y ) ),\n    uvec4( BR16( y,y,g,y,y,y,y,g,y,y,y,y,y,g,y,y ),\n           BR16( y,y,y,y,y,y,y,y,r,y,g,y,y,y,y,y ),\n           BR16( y,y,y,g,y,y,y,y,r,g,r,g,y,y,y,y ),\n           BR16( y,y,g,r,g,y,y,g,r,y,g,y,y,y,y,y ) ),\n    uvec4( BR16( y,y,y,g,y,y,g,r,g,y,y,y,y,y,y,y ),\n           BR16( y,y,y,y,y,y,y,g,y,y,y,y,y,y,y,y ),\n           BR16( y,g,y,y,y,y,y,y,r,y,y,y,g,y,y,y ),\n           BR16( g,r,g,y,y,y,y,y,_,y,y,g,r,g,y,y ) ),\n    uvec4( BR16( y,g,y,y,g,y,y,g,r,g,y,y,g,y,y,y ),\n           BR16( y,y,y,g,r,g,y,y,g,y,y,y,y,y,y,y ),\n           BR16( y,y,y,y,g,y,y,y,y,y,y,y,y,y,y,y ),\n           BR16( y,y,g,y,y,_,_,y,_,_,y,_,_,_,_,_ ) ),\n    \n    uvec4( BR16( y,y,y,y,y,_,r,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,r,r,y,y,y,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( y,_,y,y,y,r,r,_,_,_,_,_,_,_,_,_ ),\n           BR16( y,y,y,y,y,r,_,_,_,_,_,_,_,_,_,_ ) ),\n    uvec4( BR16( y,_,r,r,y,r,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( y,y,_,y,y,_,r,_,_,_,_,_,_,_,_,_ ),\n           BR16( y,y,y,y,y,y,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,y,y,y,y,r,r,_,_,_,_,_,_,_,_,_ ) ),\n    uvec4( BR16( y,y,y,y,y,r,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( y,_,r,r,y,r,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( y,y,_,y,y,_,r,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,y,y,y,y,y,_,_,_,_,_,_,_,_,_,_ ) ),\n    uvec4( BR16( y,y,y,y,y,r,r,_,_,_,_,_,_,_,_,_ ),\n           BR16( r,r,r,y,_,r,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( r,r,r,y,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           0 ),\n    \n    uvec4( BR16( _,_,_,_,_,_,_,_,_,r,r,y,y,y,y,y ),\n           BR16( _,_,_,_,_,_,_,_,_,_,y,y,_,r,y,y ),\n           BR16( _,_,_,_,_,_,_,_,_,r,_,y,y,_,r,y ),\n           BR16( _,_,_,_,_,_,_,_,_,_,r,y,y,y,y,y ) ),\n    uvec4( BR16( _,_,_,_,_,_,_,_,_,_,r,y,y,y,y,y ),\n           BR16( _,_,_,_,_,_,_,_,_,r,r,y,y,r,r,r ),\n           BR16( _,_,_,_,_,_,_,_,_,_,y,y,y,y,_,y ),\n           BR16( _,_,_,_,_,_,_,_,_,r,_,y,y,y,y,y ) ),\n    uvec4( BR16( _,_,_,_,_,_,_,_,_,_,r,y,y,y,y,y ),\n           BR16( _,_,_,_,_,_,_,_,_,r,r,y,_,r,r,y ),\n           BR16( _,_,_,_,_,_,_,_,_,_,r,y,y,_,y,y ),\n           BR16( _,_,_,_,_,_,_,_,_,_,y,y,y,y,y,_ ) ),\n    uvec4( BR16( _,_,_,_,_,_,_,_,_,r,_,y,y,y,y,y ),\n           BR16( _,_,_,_,_,_,_,_,_,_,r,r,y,_,r,r ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,r,_,r,_,_ ),\n           0 ),\n    \n    uvec4( BR16( _,y,y,y,y,y,y,_,_,y,y,y,y,y,y,_ ),\n           BR16( y,y,y,y,y,_,y,y,y,y,y,y,y,_,y,y ),\n           BR16( y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y ),\n           BR16( y,_,r,r,y,y,y,y,y,_,r,r,y,y,y,y ) ),\n    uvec4( BR16( y,y,_,y,y,y,y,_,y,y,_,y,y,y,y,_ ),\n           BR16( y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y ),\n           BR16( y,_,y,y,_,r,r,y,y,_,y,y,_,r,r,y ),\n           BR16( y,y,y,y,y,_,y,y,y,y,y,y,y,_,y,y ) ),\n    uvec4( BR16( y,y,y,_,y,y,y,y,y,y,y,_,y,y,y,y ),\n           BR16( y,y,y,y,y,_,r,r,y,y,y,y,y,_,r,r ),\n           BR16( y,_,r,r,y,y,_,y,y,_,r,r,y,y,_,y ),\n           BR16( y,y,_,y,y,y,y,y,y,y,_,y,y,y,y,y ) ),\n    uvec4( BR16( y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y ),\n           BR16( r,y,_,r,r,r,y,_,r,y,_,r,r,r,y,_ ),\n           BR16( r,_,r,r,_,r,_,r,r,_,r,r,_,r,_,r ),\n           0 )\n) ;\n\nconst uvec4 gfx_frog_wink[] = uvec4[4](\n    uvec4( BR16( _,_,_,y,y,_,_,_,_,_,_,y,y,_,_,_ ),\n           BR16( _,_,y,_,_,y,_,_,_,_,y,r,r,y,_,_ ),\n           BR16( _,_,y,r,r,y,y,y,y,y,y,r,r,y,_,_ ),\n           BR16( _,_,_,y,y,y,y,y,y,y,y,y,y,_,_,_ ) ),\n    uvec4( BR16( _,_,_,_,_,y,y,y,y,y,y,_,_,_,_,_ ),\n           BR16( _,_,_,_,y,y,r,r,r,r,y,y,_,_,_,_ ),\n           BR16( _,y,_,_,y,y,r,r,r,r,y,y,_,_,y,_ ),\n           BR16( y,y,y,_,g,y,y,r,r,y,y,g,_,y,y,y ) ),\n    uvec4( BR16( y,y,y,y,g,y,y,y,y,y,y,g,y,y,y,y ),\n           BR16( y,y,y,y,g,g,y,y,y,y,y,g,y,y,y,y ),\n           BR16( y,y,y,y,y,g,g,g,g,g,g,g,y,y,y,y ),\n           BR16( _,y,y,y,y,g,r,r,r,g,g,y,y,y,y,_ ) ),\n    uvec4( BR16( _,y,y,y,y,g,r,r,r,g,g,y,y,y,y,_ ),\n           BR16( _,_,_,y,y,y,g,g,g,g,y,y,y,_,_,_ ),\n           BR16( _,_,y,y,y,y,_,_,_,_,y,y,y,y,_,_ ),\n           BR16( _,y,y,y,_,y,_,_,_,_,y,_,y,y,y,_ ) )\n) ;\n\nconst uvec4 gfx_tile2[] = uvec4[4*4](\n    uvec4( BR16( _,_,_,y,y,_,_,_,_,_,_,y,y,_,_,_ ),\n           BR16( _,_,y,_,_,y,_,_,_,_,y,_,_,y,_,_ ),\n           BR16( _,_,y,r,r,y,y,y,y,y,y,r,r,y,_,_ ),\n           BR16( _,_,_,y,y,y,y,y,y,y,y,y,y,_,_,_ ) ),\n    uvec4( BR16( _,_,_,_,_,y,y,y,y,y,y,_,_,_,_,_ ),\n           BR16( _,_,_,_,y,y,r,y,y,r,y,y,_,_,_,_ ),\n           BR16( _,y,_,_,y,y,y,r,r,y,y,y,_,_,y,_ ),\n           BR16( y,y,y,_,g,y,y,y,y,y,y,g,_,y,y,y ) ),\n    uvec4( BR16( y,y,y,y,g,y,y,y,y,y,y,g,y,y,y,y ),\n           BR16( y,y,y,y,g,g,y,y,y,y,y,g,y,y,y,y ),\n           BR16( y,y,y,y,y,g,g,g,g,g,g,g,y,y,y,y ),\n           BR16( _,y,y,y,y,g,r,r,r,g,g,y,y,y,y,_ ) ),\n    uvec4( BR16( _,y,y,y,y,g,r,r,r,g,g,y,y,y,y,_ ),\n           BR16( _,_,_,y,y,y,g,g,g,g,y,y,y,_,_,_ ),\n           BR16( _,_,y,y,y,y,_,_,_,_,y,y,y,y,_,_ ),\n           BR16( _,y,y,y,_,y,_,_,_,_,y,_,y,y,y,_ ) ),\n    \n    uvec4( BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ) ),\n    uvec4( BR16( _,_,_,_,_,_,_,g,g,g,g,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,g,g,g,g,_,_,_,_,_,_ ),\n           BR16( _,_,_,r,r,_,g,g,g,r,r,_,_,_,_,_ ),\n           BR16( _,_,_,r,y,y,g,g,r,r,r,r,_,_,_,_ ) ),\n    uvec4( BR16( _,_,y,y,y,r,r,r,r,r,r,r,g,_,_,_ ),\n           BR16( _,_,_,r,y,y,g,g,r,r,r,r,_,_,_,_ ),\n           BR16( _,_,_,r,r,_,g,g,g,r,r,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,g,g,g,g,_,_,_,_,_,_ ) ),\n    uvec4( BR16( _,_,_,_,_,_,_,g,g,g,g,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ) ),\n\n    uvec4( BR16( _,r,r,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( r,_,r,r,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( r,r,r,r,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( r,r,r,y,_,_,_,_,_,_,_,_,_,_,_,_ ) ),\n    uvec4( BR16( r,y,_,y,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,y,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ) ),\n    uvec4( BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,y,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( r,r,_,y,_,y,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( r,r,r,r,r,r,r,_,_,_,_,_,_,_,_,_ ) ),\n    uvec4( BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,y,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,y,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( y,y,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ) ),\n    \n    uvec4( BR16( _,_,_,_,_,_,_,_,_,r,r,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,r,_,r,r,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,r,r,r,r,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,r,r,r,r,y,_,_,_,_ ) ),\n    uvec4( BR16( _,_,_,_,_,_,r,r,r,y,_,y,_,_,_,_ ),\n           BR16( _,_,y,y,r,r,r,r,_,y,_,_,_,_,_,_ ),\n           BR16( _,_,y,y,r,r,r,y,_,_,_,_,_,_,_,_ ),\n           BR16( r,r,r,r,r,r,_,y,_,_,_,_,_,_,_,_ ) ),\n    uvec4( BR16( r,y,y,r,r,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( r,r,y,r,r,_,_,y,_,y,_,_,_,_,_,_ ),\n           BR16( g,r,r,r,r,r,r,y,r,r,_,y,_,y,_,_ ),\n           BR16( r,r,r,r,r,r,r,r,r,r,r,r,r,r,r,_ ) ),\n    uvec4( BR16( r,r,r,r,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( r,r,r,r,_,y,_,_,_,y,_,_,_,_,_,_ ),\n           BR16( r,r,r,_,_,_,y,_,_,_,y,_,_,_,_,_ ),\n           BR16( _,y,y,y,y,y,_,_,y,y,_,_,_,_,_,_ ) )\n) ;\n\nconst uvec4 gfx_half_tile[] = uvec4[4*2](\n    uvec4( 0,0,0,0 ),\n    uvec4( 0,0,0,0 ),\n\n    uvec4( BR16( _,y,y,y,y,y,y,_,y,y,y,_,y,y,y,y ),\n           BR16( y,y,y,_,r,y,y,y,y,y,y,y,y,_,r,r ),\n           BR16( y,_,y,y,_,r,y,y,y,_,r,r,y,y,_,y ),\n           BR16( y,y,y,y,y,y,y,y,y,y,_,y,y,y,y,y ) ),\n    uvec4( BR16( _,y,_,r,r,y,y,y,y,y,y,y,y,y,y,y ),\n           BR16( y,y,y,_,y,y,r,r,r,y,_,r,r,r,y,_ ),\n           BR16( _,y,y,y,y,r,r,_,r,_,r,r,_,r,_,r ),\n           BR16( y,y,y,y,y,r,_,_,_,_,_,_,_,_,_,_ ) ),\n    \n    uvec4( BR16( y,y,y,_,y,y,y,y,y,y,y,_,y,y,y,_ ),\n           BR16( y,y,y,y,y,_,r,r,y,y,y,y,y,_,y,y ),\n           BR16( y,_,r,r,y,y,_,y,y,_,r,r,y,y,_,y ),\n           BR16( y,y,_,y,y,y,y,y,y,y,_,y,y,y,y,y ) ),\n    uvec4( BR16( y,y,y,y,y,y,y,y,y,y,y,y,_,r,r,y ),\n           BR16( r,y,_,r,r,r,y,_,r,r,y,y,y,_,y,y ),\n           BR16( r,_,r,r,_,r,_,r,_,r,r,y,y,y,y,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,r,y,y,y,y,y ) ),\n    \n    uvec4( BR16( _,y,y,y,y,y,y,_,_,y,y,y,y,y,y,_ ),\n           BR16( y,y,y,y,y,_,y,y,y,y,y,y,y,_,y,y ),\n           BR16( y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y ),\n           BR16( y,_,r,r,y,y,y,y,y,_,r,r,y,y,y,y ) ),\n    uvec4( BR16( y,y,_,y,y,y,y,_,y,y,_,y,y,y,y,_ ),\n           BR16( y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y ),\n           BR16( y,_,y,y,_,r,r,y,y,_,y,y,_,r,r,y ),\n           BR16( y,y,y,y,y,_,y,y,y,y,y,y,y,_,y,y ) )\n) ;\n\nconst uvec4 gfx_croc[] = uvec4[4*4](\n    uvec4( BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ) ),\n    uvec4( BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,y,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,y,_,_,_,_,_,_,_,_,y,_,_,_,y,_ ) ),\n    uvec4( BR16( _,y,y,_,_,_,y,_,_,y,y,y,y,y,y,y ),\n           BR16( _,_,y,y,g,y,y,y,y,y,g,y,y,r,y,y ),\n           BR16( _,_,_,_,y,y,y,g,y,y,y,y,y,g,y,y ),\n           BR16( g,g,_,_,_,_,_,_,y,r,y,y,y,y,y,y ) ),\n    uvec4( BR16( _,_,g,g,g,g,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,g,g,g,g,_,_ ),\n           BR16( _,_,_,g,g,g,g,g,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,g,g,g,g ) ),\n\n    uvec4( BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ) ),\n    uvec4( BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,y,_,_,_,_,y,_,_ ),\n           BR16( _,_,y,_,_,_,_,y,y,y,_,_,y,g,y,_ ),\n           BR16( _,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y ) ),\n    uvec4( BR16( y,y,y,y,y,y,y,g,y,y,y,y,y,r,y,y ),\n           BR16( y,y,g,r,y,y,y,y,y,r,y,y,y,y,y,y ),\n           BR16( y,y,y,y,y,y,y,y,y,y,g,y,y,y,y,y ),\n           BR16( g,r,y,y,y,y,y,y,y,y,y,y,y,_,y,y ) ),\n    uvec4( BR16( _,_,_,_,r,g,y,y,_,_,_,_,_,_,_,_ ),\n           BR16( g,g,g,_,y,y,y,r,_,g,_,_,g,g,_,y ),\n           BR16( _,_,_,y,y,y,y,_,_,_,g,_,_,_,y,y ),\n           BR16( _,_,_,_,g,g,g,g,g,g,_,_,_,_,g,g ) ),\n\n    uvec4( BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ) ),\n    uvec4( BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,g,g,y,y,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( y,y,g,g,y,y,y,y,_,_,_,_,_,y,y,_ ) ),\n    uvec4( BR16( y,y,y,y,y,y,y,y,y,y,y,y,y,_,y,_ ),\n           BR16( y,r,y,y,y,y,g,g,y,y,y,y,y,y,y,_ ),\n           BR16( r,y,y,y,y,y,y,y,g,g,g,g,g,g,g,_ ),\n           BR16( y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,_ ) ),\n    uvec4( BR16( y,y,y,y,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( y,y,y,y,_,g,_,_,_,g,_,_,_,_,_,_ ),\n           BR16( y,y,y,_,_,_,g,_,_,_,g,_,_,_,_,_ ),\n           BR16( _,g,g,g,g,g,_,_,g,g,_,_,_,_,_,_ ) ),\n\n    uvec4( BR16( _,_,_,_,_,_,_,_,_,y,y,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,y,_,y,y,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,y,y,y,y,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,y,y,y,y,g,_,_,_,_ ) ),\n    uvec4( BR16( _,_,_,_,_,_,y,y,y,g,_,g,_,_,_,_ ),\n           BR16( _,_,g,g,y,y,y,y,_,g,_,_,_,_,_,_ ),\n           BR16( _,_,g,g,y,y,y,g,_,_,_,_,_,_,_,_ ),\n           BR16( y,y,y,y,y,y,_,g,_,_,_,_,_,_,_,_ ) ),\n    uvec4( BR16( y,g,g,y,y,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( y,y,g,y,y,_,_,g,_,g,_,_,_,_,_,_ ),\n           BR16( r,y,y,y,y,y,y,g,y,y,_,g,_,g,_,_ ),\n           BR16( y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,_ ) ),\n    uvec4( BR16( y,y,y,y,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( y,y,y,y,_,g,_,_,_,g,_,_,_,_,_,_ ),\n           BR16( y,y,y,_,_,_,g,_,_,_,g,_,_,_,_,_ ),\n           BR16( _,g,g,g,g,g,_,_,g,g,_,_,_,_,_,_ ) )\n) ;\n\nconst uvec4 gfx_wood[] = uvec4[4*4](\n    uvec4( BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,y,y,y,y,y,y,y,_,y,y ) ),\n    uvec4( BR16( _,_,_,_,y,y,y,y,y,y,y,g,y,y,y,y ),\n           BR16( _,_,_,_,y,y,g,g,y,y,y,y,y,y,y,y ),\n           BR16( _,_,_,y,y,y,y,y,y,y,y,y,y,y,y,y ),\n           BR16( _,_,_,y,y,y,y,y,y,y,y,y,y,y,g,g ) ),\n    uvec4( BR16( _,_,_,y,y,g,g,y,y,y,y,g,y,y,y,y ),\n           BR16( _,_,_,y,y,y,y,y,y,y,y,g,y,y,y,y ),\n           BR16( _,_,_,_,y,y,y,y,y,y,y,_,r,g,r,r ),\n           BR16( _,_,_,_,_,_,r,_,r,r,r,r,r,r,r,r ) ),\n    uvec4( BR16( _,_,_,_,_,y,y,y,r,r,r,_,r,r,r,r ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ) ),\n    \n    uvec4( BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( y,y,_,y,y,y,y,y,y,y,y,y,_,y,y,y ) ),\n    uvec4( BR16( g,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y ),\n           BR16( y,y,y,y,y,y,y,y,y,g,g,y,y,y,y,y ),\n           BR16( y,y,y,y,y,g,y,y,y,y,y,y,y,y,g,y ),\n           BR16( y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y ) ),\n    uvec4( BR16( y,y,g,y,y,y,y,y,y,y,y,y,y,y,y,y ),\n           BR16( y,y,y,y,y,y,y,y,y,y,g,g,g,y,y,y ),\n           BR16( r,r,r,r,r,r,r,r,r,y,y,y,y,y,y,r ),\n           BR16( r,r,r,r,g,g,g,r,r,r,r,r,r,r,r,r ) ),\n    uvec4( BR16( r,r,r,_,r,r,r,r,r,r,r,_,r,r,r,r ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ) ),\n    \n    uvec4( BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( y,y,_,y,y,y,y,y,g,g,g,_,_,_,_,_ ) ),\n    uvec4( BR16( y,y,y,y,g,y,y,g,g,g,g,g,_,_,_,_ ),\n           BR16( y,y,y,y,y,y,y,g,y,y,y,g,_,_,_,_ ),\n           BR16( y,y,y,y,y,y,y,g,y,y,y,g,g,_,_,_ ),\n           BR16( y,y,y,y,y,y,g,y,y,y,y,y,g,_,_,_ ) ),\n    uvec4( BR16( y,y,y,y,y,y,g,y,y,g,y,y,g,_,_,_ ),\n           BR16( y,y,g,g,y,g,g,g,y,g,y,g,g,_,_,_ ),\n           BR16( r,r,r,r,r,r,r,g,y,y,y,g,_,_,_,_ ),\n           BR16( r,r,r,r,r,r,r,g,y,y,g,g,_,_,_,_ ) ),\n    uvec4( BR16( r,r,r,r,_,r,r,r,y,g,g,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ) ),\n    \n    uvec4( 0 ),\n    uvec4( 0 ),\n    uvec4( 0 ),\n    uvec4( 0 )\n) ;\n\nconst uvec4 gfx_turtle[] = uvec4[4*4](\n    uvec4( BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ) ),\n    uvec4( BR16( _,_,_,_,g,_,_,_,_,_,g,_,_,_,_,_ ),\n           BR16( _,_,_,g,g,r,r,r,r,r,g,g,_,_,_,_ ),\n           BR16( _,_,_,_,r,r,r,r,r,r,r,_,_,_,_,_ ),\n           BR16( _,_,y,r,r,r,r,r,r,r,r,r,_,_,_,_ ) ),\n    uvec4( BR16( _,g,g,r,r,r,r,r,r,r,r,r,r,g,_,_ ),\n           BR16( _,_,y,r,r,r,r,r,r,r,y,r,_,_,_,_ ),\n           BR16( _,_,_,_,r,y,r,r,r,y,r,_,_,_,_,_ ),\n           BR16( _,_,_,g,g,r,y,y,y,r,g,g,_,_,_,_ ) ),\n    uvec4( BR16( _,_,_,_,g,_,_,_,_,_,g,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ) ),\n\n    uvec4( BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,g,_,_,_,_,_,_,_,g,_,_,_,_ ) ),\n    uvec4( BR16( _,_,g,g,g,_,_,_,_,_,g,g,g,_,_,_ ),\n           BR16( _,_,_,_,g,r,r,r,r,r,g,_,_,_,_,_ ),\n           BR16( _,_,_,_,r,r,r,r,r,r,r,_,_,_,_,_ ),\n           BR16( _,y,g,r,r,r,r,r,r,r,r,r,_,_,g,_ ) ),\n    uvec4( BR16( g,g,g,r,r,r,r,r,r,r,r,r,r,g,_,_ ),\n           BR16( _,y,g,r,r,r,r,r,r,r,y,r,_,_,_,_ ),\n           BR16( _,_,_,_,r,y,r,r,r,y,r,_,_,_,_,_ ),\n           BR16( _,_,_,_,g,r,y,y,y,r,g,_,_,_,_,_ ) ),\n    uvec4( BR16( _,_,g,g,g,_,_,_,_,_,g,g,g,_,_,_ ),\n           BR16( _,_,_,g,_,_,_,_,_,_,_,g,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ) ),\n\n    uvec4( BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,y,_,_,_,_,_,y,_,_,_,_ ) ),\n    uvec4( BR16( _,_,_,_,g,g,y,_,_,_,g,y,y,_,_,_ ),\n           BR16( _,_,_,_,g,r,r,r,r,r,g,_,_,_,_,_ ),\n           BR16( _,_,_,_,r,r,r,r,r,r,r,_,_,_,_,_ ),\n           BR16( _,y,g,r,r,r,r,r,r,r,r,r,_,_,_,_ ) ),\n    uvec4( BR16( g,g,g,r,r,r,r,r,r,r,r,r,r,g,_,_ ),\n           BR16( _,y,g,r,r,r,r,r,r,r,y,r,_,_,g,_ ),\n           BR16( _,_,_,_,r,y,r,r,r,y,r,_,_,_,_,_ ),\n           BR16( _,_,_,_,g,r,y,y,y,r,g,_,_,_,_,_ ) ),\n    uvec4( BR16( _,_,_,_,g,g,y,_,_,_,g,y,y,_,_,_ ),\n           BR16( _,_,_,_,_,y,_,_,_,_,_,y,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ) ),\n    \n    uvec4( 0 ),\n    uvec4( 0 ),\n    uvec4( 0 ),\n    uvec4( 0 )\n\n) ;\n\nconst uvec4 gfx_turtle_dive[] = uvec4[4*4](\n    uvec4( BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,y,_,_,_,_,_,_,_,_,_,_,_ ) ),\n    uvec4( BR16( _,_,_,y,_,_,_,_,_,_,_,y,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,g,g,g,g,_,_,y,_,_,_ ),\n           BR16( _,_,_,_,_,g,g,g,g,g,g,_,_,_,_,_ ),\n           BR16( _,_,_,_,g,g,g,g,g,g,g,g,_,_,_,_ ) ),\n    uvec4( BR16( _,_,_,_,g,g,g,g,g,g,y,g,_,_,_,_ ),\n           BR16( _,_,_,_,_,g,g,y,y,y,g,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,g,g,g,g,_,_,_,_,_,_ ),\n           BR16( _,_,_,y,_,_,_,_,_,_,_,_,y,_,_,_ ) ),\n    uvec4( BR16( _,_,_,_,y,_,_,_,_,_,_,y,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ) ),\n\n    uvec4( BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,y,y,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ) ),\n    uvec4( BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,y,_,_,_,y,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,y,_,_,_,_,_,y,_,_,_,_,_ ),\n           BR16( _,y,_,_,_,_,g,g,g,_,_,_,_,_,y,_ ) ),\n    uvec4( BR16( _,y,_,_,_,g,g,g,g,g,_,_,_,_,y,_ ),\n           BR16( _,_,_,_,_,_,g,g,y,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,y,_,_,_,_,_,y,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,y,_,_,_,y,_,_,_,_,_,_ ) ),\n    uvec4( BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,y,y,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ) ),\n\n    uvec4( 0 ),\n    uvec4( 0 ),\n    uvec4( 0 ),\n    uvec4( 0 ),\n    \n    uvec4( BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,y,y,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ) ),\n    uvec4( BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,y,_,_,_,y,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,y,_,_,_,_,_,y,_,_,_,_,_ ),\n           BR16( _,y,_,_,_,_,g,g,g,_,_,_,_,_,y,_ ) ),\n    uvec4( BR16( _,y,_,_,_,g,g,g,g,g,_,_,_,_,y,_ ),\n           BR16( _,_,_,_,_,_,g,g,y,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,y,_,_,_,_,_,y,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,y,_,_,_,y,_,_,_,_,_,_ ) ),\n    uvec4( BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,y,y,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ) )\n\n) ;\n\nconst uvec4 gfx_truck[] = uvec4[2*4](\n    uvec4( 0,\n           0,\n           0,\n           BR16( _,_,_,_,_,_,g,g,g,_,_,g,g,g,g,_ ) ),\n    uvec4( BR16( _,_,_,_,r,y,y,y,y,_,y,y,y,y,y,y ),\n           BR16( _,_,_,r,y,y,y,y,y,_,y,y,y,y,y,y ),\n           BR16( _,_,_,r,y,y,y,y,y,r,y,y,y,y,y,y ),\n           BR16( _,_,_,r,y,y,y,y,y,r,y,y,y,y,y,y ) ),\n    uvec4( BR16( _,_,_,r,y,y,y,y,y,r,y,y,y,y,y,y ),\n           BR16( _,_,_,r,y,y,y,y,y,r,y,y,y,y,y,y ),\n           BR16( _,_,_,r,y,y,y,y,y,_,y,y,y,y,y,y ),\n           BR16( _,_,_,_,r,y,y,y,y,_,y,y,y,y,y,y ) ),\n    uvec4( BR16( _,_,_,_,_,_,g,g,g,_,_,g,g,g,_,_ ),\n           0,\n           0,\n           0 ),\n\n    uvec4( BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,g,g,g,_,_,_ ) ),\n    uvec4( BR16( y,y,y,y,y,y,y,y,y,y,y,y,y,y,_,_ ),\n           BR16( y,y,y,y,y,y,y,y,y,y,y,y,y,y,_,_ ),\n           BR16( y,y,y,y,y,y,y,y,y,y,y,y,y,y,_,_ ),\n           BR16( y,y,y,y,y,y,y,y,y,y,y,y,y,y,_,_ ) ),\n    uvec4( BR16( y,y,y,y,y,y,y,y,y,y,y,y,y,y,_,_ ),\n           BR16( y,y,y,y,y,y,y,y,y,y,y,y,y,y,_,_ ),\n           BR16( y,y,y,y,y,y,y,y,y,y,y,y,y,y,_,_ ),\n           BR16( y,y,y,y,y,y,y,y,y,y,y,y,y,y,_,_ ) ),\n    uvec4( BR16( _,_,_,_,_,_,_,_,_,_,g,g,g,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ) )\n) ;\n\nconst uvec4 gfx_vehicle[] = uvec4[4*4](\n    uvec4( 0,\n           BR16( _,_,_,_,_,_,_,_,_,_,r,r,r,r,r,_ ),\n           BR16( _,_,r,r,r,r,r,_,_,_,r,r,r,r,r,_ ),\n           BR16( _,_,r,r,r,r,r,_,_,_,r,r,r,r,r,_ ) ),\n    uvec4( BR16( _,_,_,_,g,_,_,_,_,_,_,_,g,_,_,_ ),\n           BR16( _,_,y,y,y,y,y,y,y,y,y,y,y,y,_,_ ),\n           BR16( _,y,y,y,y,g,g,g,y,y,g,g,g,g,g,g ),\n           BR16( y,y,y,y,g,g,g,y,y,r,y,r,y,r,y,_ ) ),\n    uvec4( BR16( y,y,y,y,g,g,g,y,y,r,y,r,y,r,y,_ ),\n           BR16( _,y,y,y,y,g,g,g,y,y,g,g,g,g,g,g ),\n           BR16( _,_,y,y,y,y,y,y,y,y,y,y,y,y,_,_ ),\n           BR16( _,_,_,_,g,_,_,_,_,_,_,_,g,_,_,_ ) ),\n    uvec4( BR16( _,_,r,r,r,r,r,_,_,_,r,r,r,r,r,_ ),\n           BR16( _,_,r,r,r,r,r,_,_,_,r,r,r,r,r,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,r,r,r,r,r,_ ),\n           0 ),\n    \n    uvec4( 0,\n           0,\n           BR16( _,r,y,r,y,r,y,r,_,_,_,_,y,y,y,_ ),\n           BR16( _,r,y,r,y,r,y,r,_,_,_,_,y,r,_,_ ) ),\n    uvec4( BR16( _,_,g,_,_,_,g,_,_,g,g,g,y,y,y,_ ),\n           BR16( _,_,y,y,y,y,y,y,y,y,_,_,y,r,_,_ ),\n           BR16( _,y,y,y,y,y,g,g,y,g,_,_,y,y,y,_ ),\n           BR16( _,y,y,g,g,g,y,g,y,y,_,_,y,r,_,_ ) ),\n    uvec4( BR16( _,y,y,g,g,g,y,g,y,y,_,_,y,r,_,_ ),\n           BR16( _,y,y,y,y,y,g,g,y,g,_,_,y,y,y,_ ),\n           BR16( _,_,y,y,y,y,y,y,y,y,_,_,y,r,_,_ ),\n           BR16( _,_,g,_,_,_,g,_,_,g,g,g,y,y,y,_ ) ),\n    uvec4( BR16( _,r,y,r,y,r,y,r,_,_,_,_,y,r,_,_ ),\n           BR16( _,r,y,r,y,r,y,r,_,_,_,_,y,y,y,_ ),\n           0,\n           0 ),\n    \n    uvec4( 0,\n           0,\n           0,\n           BR16( _,_,_,r,r,_,_,_,_,_,r,r,r,_,_,_ ) ),\n    uvec4( BR16( _,y,y,y,y,y,y,_,_,y,y,y,y,y,_,_ ),\n           BR16( g,y,y,y,y,g,g,y,g,y,y,y,y,y,y,_ ),\n           BR16( g,r,y,y,g,g,y,y,y,y,g,g,g,y,_,_ ),\n           BR16( g,y,y,y,g,g,y,y,y,y,g,g,g,y,_,_ ) ),\n    uvec4( BR16( g,y,y,y,g,g,y,y,y,y,g,g,g,y,_,_ ),\n           BR16( g,r,y,y,g,g,y,y,y,y,g,g,g,y,_,_ ),\n           BR16( g,y,y,y,y,g,g,y,g,y,y,y,y,y,y,_ ),\n           BR16( _,y,y,y,y,y,y,_,_,y,y,y,y,y,_,_ ) ),\n    uvec4( BR16( _,_,_,r,r,_,_,_,_,_,r,r,r,_,_,_ ),\n           0,\n           0,\n           0 ),\n\n    uvec4( 0,\n           BR16( _,r,r,r,r,r,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,r,r,r,r,r,_,_,_,r,r,r,r,r,_,_ ),\n           BR16( _,r,r,r,r,r,_,_,_,r,r,r,r,r,_,_ ) ),\n    uvec4( BR16( _,_,_,g,_,_,_,_,_,_,_,g,_,_,_,_ ),\n           BR16( _,_,y,y,y,y,y,y,y,y,y,y,y,y,_,_ ),\n           BR16( g,g,g,g,g,g,g,y,g,g,g,y,y,y,y,_ ),\n           BR16( _,_,r,y,r,_,r,y,y,g,g,g,y,y,y,y ) ),\n    uvec4( BR16( _,y,r,y,r,y,r,y,y,g,g,g,y,y,y,y ),\n           BR16( g,g,g,g,g,g,g,y,g,g,g,y,y,y,y,_ ),\n           BR16( _,_,y,y,y,y,y,y,y,y,y,y,y,y,_,_ ),\n           BR16( _,_,_,g,_,_,_,_,_,_,_,g,_,_,_,_ ) ),\n    uvec4( BR16( _,r,r,r,r,r,_,_,_,r,r,r,r,r,_,_ ),\n           BR16( _,r,r,r,r,r,_,_,_,r,r,r,r,r,_,_ ),\n           BR16( _,r,r,r,r,r,_,_,_,_,_,_,_,_,_,_ ),\n           0 )\n) ;\n\n#undef _\n#undef r\n#undef g\n#undef y\n\nconst vec4 pal_sidewalk[]  = vec4[4]( col_transp, col_red,         col_blue,   col_purple    ) ;\nconst vec4 pal_grass[]     = vec4[4]( col_transp, col_light_brown, col_cyan,   col_green     ) ;\n\nconst vec4 pal_wood[]      = vec4[4]( col_transp, col_dark_brown,  col_white,  col_brown     ) ;\nconst vec4 pal_turtle[]    = vec4[4]( col_transp, col_red,         col_green,  col_white     ) ;\n\nconst vec4 pal_vehicle_0[] = vec4[4]( col_transp, col_red,         col_purple, col_yellow    ) ;\nconst vec4 pal_vehicle_1[] = vec4[4]( col_transp, col_red,         col_green,  col_white     ) ;\nconst vec4 pal_vehicle_2[] = vec4[4]( col_transp, col_green,       col_cyan,   col_magenta_2 ) ;\nconst vec4 pal_vehicle_3[] = vec4[4]( col_transp, col_red,         col_green,  col_white     ) ;\n\nconst vec4 pal_truck[]     = vec4[4]( col_transp, col_red,         col_green,  col_white     ) ;\n\n#define get_col(arr,i) \\\n   ((i)<2U?(i)<1U? arr[0] : arr[1] \\\n   :(i)<3U?        arr[2] : arr[3])\n\nvec4 get_tile_col( int t, uint i ) {\n    return( t<1? get_col( pal_sidewalk, i ) : get_col( pal_grass, i ) ) ;\n}\n\nvec4 get_vehicle_col( int t, uint i ) {\n    return( t<2?t<1? get_col( pal_vehicle_0, i ) : get_col( pal_vehicle_1, i )\n           :t<3?     get_col( pal_vehicle_2, i ) : get_col( pal_vehicle_3, i ) ) ;\n}\n\n//get bit row fns   fn name              gfx arr\nGENERATE_GET_BR_16( get_vehicle_br,      gfx_vehicle     )\nGENERATE_GET_BR_8 ( get_truck_br,        gfx_truck       )\nGENERATE_GET_BR_4 ( get_frog_wink_br,    gfx_frog_wink   )\nGENERATE_GET_BR_16( get_tile_br,         gfx_tile        )\nGENERATE_GET_BR_16( get_tile2_br,        gfx_tile2       )\nGENERATE_GET_BR_8 ( get_half_tile_br,    gfx_half_tile   )\nGENERATE_GET_BR_16( get_croc_br,         gfx_croc        )\nGENERATE_GET_BR_16( get_wood_br,         gfx_wood        )\nGENERATE_GET_BR_16( get_turtle_br,       gfx_turtle      )\nGENERATE_GET_BR_16( get_turtle_dive_br,  gfx_turtle_dive )\n\n//generating draw fns     fn_name            frames dim    bit row fn           fn or 4 col palette arr\nGENERATE_DRAW_4T_COL_FN ( draw_vehicle,      ivec2( 16 ),  get_vehicle_br,      get_vehicle_col ) //4 4col vehicle palettes\nGENERATE_DRAW_4T_PALETTE( draw_truck,        ivec2( 16 ),  get_truck_br,        pal_truck       )\nGENERATE_DRAW_4T_COL_FN ( draw_tile,         ivec2( 16 ),  get_tile_br,         get_tile_col    ) //pal_sidewalk, pal_grass\nGENERATE_DRAW_4T_PALETTE( draw_tile2,        ivec2( 16 ),  get_tile2_br,        pal_grass       )\nGENERATE_DRAW_4T_PALETTE( draw_croc,         ivec2( 16 ),  get_croc_br,         pal_wood        )\nGENERATE_DRAW_4T_PALETTE( draw_wood,         ivec2( 16 ),  get_wood_br,         pal_wood        )\nGENERATE_DRAW_4T_PALETTE( draw_turtle,       ivec2( 16 ),  get_turtle_br,       pal_turtle      )\n\n//GENERATE_DRAW_4T_PALETTE( draw_turtle_dive,  ivec2( 16 ),  get_turtle_dive_br,  pal_turtle      )\nvec4 draw_turtle_dive( int frame, ivec2 pos, inout vec4 o, ivec2 iu ) {\n    vec4 v = vec4( -1 ) ;\n    iu -= pos ;\n    if( frame < 2 && iINSIDE( iu, ivec2(0), ivec2( 16 ) ) ) { //hack, frame 2 is empty\n        \n        //hack for simpler collision with diving turtles (same color, different alpha!)\n        o = iINSIDE( iu, ivec2( 3 ), ivec2( 3 ) + ivec2( 10 ) ) ? col_water_hack : o ;\n        \n        int row_group = frame * 4 + 3 - ( iu.y >> 2 ),\n            component = 3 - ( iu.y & 0x3 ),\n            sh = 2 * iu.x ;\n        uint bits = 0x3U << sh,\n             col_ind = ( get_turtle_dive_br( row_group, component ) & bits ) >> sh ;\n        v = get_col( pal_turtle, col_ind ) ;\n    }\n    o = v.a > 0. ? v : o ;\n    return( v ) ;\n}\n\nvec4 draw_half_tile( int type, ivec2 pos, inout vec4 o, ivec2 iu ) {\n    vec4 v = vec4( -1 ) ;\n    iu -= pos ;\n    if( iINSIDE( iu, ivec2(0), ivec2( 16, 8 ) ) ) {\n        type &= 0x3 ;\n        int row_group = type * 2 + 1 - ( iu.y >> 2 ),\n            component = 3 - ( iu.y & 0x3 ),\n            sh = 2 * iu.x ;\n        uint bits = 0x3U << sh,\n             col_ind = ( get_half_tile_br( row_group, component ) & bits ) >> sh ;\n        v = get_col( pal_grass, col_ind ) ;\n    }\n    o = v.a > 0. ? v : o ;\n    return( v ) ;\n}\n\nvec4 draw_frog_wink( ivec2 pos, inout vec4 o, ivec2 iu ) {\n    vec4 v = vec4( -1 ) ;\n    iu -= pos ;\n    if( iINSIDE( iu, ivec2(0), ivec2( 16 ) ) ) {\n        int row_group = 0 * 4 + 3 - ( iu.y >> 2 ),\n            component = 3 - ( iu.y & 0x3 ),\n            sh = 2 * iu.x ;\n        uint bits = 0x3U << sh,\n             col_ind = ( get_frog_wink_br( row_group, component ) & bits ) >> sh ;\n        v = get_col( pal_grass, col_ind ) ;\n    }\n    o = v.a > 0. ? v : o ;\n    return( v ) ;\n}\n\n\n//END Buffer A\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"const int\n    _0=1,_1=2,_2=3,_3=4,_4=5,_5=6,_6=7,_7=8,\n    _8=9,_9=10,_BONUS_1=11,_BONUS_2=12,_A=13,_B=14,_C=15,_D=16,\n    _E=17,_F=18,_G=19,_H=20,_I=21,_J=22,_K=23,_L=24,\n    _M=25,_N=26,_O=27,_P=28,_Q=29,_R=30,_S=31,_T=32,\n    _U=33,_V=34,_W=35,_X=36,_Y=37,_Z=38,_QM=39,_DASH=40,\n    _SLASH=41,_=63 ;\n\n#define c(x) +(x\n#define _end *64))*64)*64)*64)\n#define STR20(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T)\\\n    ivec4( c(A)c(B)c(C)c(D)c(E) _end,  c(F)c(G)c(H)c(I)c(J) _end,\\\n           c(K)c(L)c(M)c(N)c(O) _end,  c(P)c(Q)c(R)c(S)c(T) _end )\n\nconst ivec4\n     txt_fps       = STR20( _F,_P,_S, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 )\n    ,txt_1_up      = STR20( _1,_DASH,_U,_P, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 )\n    ,txt_hiscore   = STR20( _H,_I,_DASH,_S,_C,_O,_R,_E, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 )\n    ,txt_game_over = STR20( _G,_A,_M,_E,_ ,_O,_V,_E,_R, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 )\n    ,txt_press_1   = STR20( _P,_R,_E,_S,_S,_ ,_1,_ , 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 )\n    ,txt_for_a_new = STR20( _F,_O,_R,_ ,_A,_ ,_N,_E,_W,_ ,_G,_A,_M,_E, 0, 0, 0, 0, 0, 0 )\n    ,txt_paused    = STR20( _P,_A,_U,_S,_E,_D, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 )\n    ,txt_time_left = STR20( _T,_I,_M,_E,_ ,_ ,_ , 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 )\n    ,txt_start     = STR20( _ ,_S,_T,_A,_R,_T,_ , 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 )\n    ,txt_time      = STR20( _T,_I,_M,_E, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 )\n;\n\n#undef c\n#undef _end\n#undef STR20\n\nconst ivec2\n     pos_txt_fps       = ivec2( scr_dim.x - 5*8, scr_dim.y - 8 )\n    ,pos_fps           = ivec2( scr_dim.x - 5*8, scr_dim.y - 16 )\n    ,pos_txt_1_up      = ivec2( 32, scr_dim.y -  8 )\n    ,pos_score         = ivec2( 24, scr_dim.y - 16 )\n    ,pos_txt_hiscore   = ivec2( 80, scr_dim.y -  8 )\n    ,pos_hiscore       = ivec2( 88, scr_dim.y - 16 )\n    ,pos_txt_game_over = ivec2( 80, 120 )\n    ,pos_txt_press_1   = ivec2( 144-15*8, 20 )\n    ,pos_txt_for_a_new = ivec2( 24+8*8, 20 )\n    ,pos_txt_paused    = ivec2( 88, scr_dim.y -  8 - 20 )\n    ,pos_txt_time_left = ivec2( 88, 112 )\n    ,pos_time_left     = pos_txt_time_left + ivec2( 5*8, 0 )\n    ,pos_txt_start     = ivec2( 88, 112 )\n    ,pos_txt_time      = ivec2( scr_dim.x - 4*8, 0 )\n    ,pos_bonus_lady    = ivec2( 8, scr_dim.y - 28 )\n    ,pos_bonus_fly     = pos_bonus_lady - ivec2( 0, 16 )\n;\n\nvec4 draw_font8x8_char( int ch, vec4 col, ivec2 pos, inout vec4 o, ivec2 iu ) ;\nvec4 draw_font8x8_string20_ivec4( int num_ch, ivec4 str, vec4 col, ivec2 pos, inout vec4 o, ivec2 iu ) ;\nvec4 draw_font8x8_number_0k( int k_digits, int n, vec4 col, ivec2 pos, inout vec4 o, ivec2 iu ) ;\nvec4 draw_font8x8_number_k( int k_digits, int n, vec4 col, ivec2 pos, inout vec4 o, ivec2 iu ) ;\nvec4 draw_font8x8_number_05( int n, vec4 col, ivec2 pos, inout vec4 o, ivec2 iu ) ;\n\nvec4 draw_death_1( int frame, ivec2 pos, inout vec4 o, ivec2 iu ) ;\nvec4 draw_death_2( int frame, ivec2 pos, inout vec4 o, ivec2 iu ) ;\n\nvoid mainImage( out vec4 o, vec2 u )\n{\n    int game_frame = iFrame ;\n\n#if FD > 1\n    //skip frames\n    game_frame /= FD ;\n    if( iFrame % FD != 0 ) {\n        discard ;\n    } else\n#endif\n\n    {\n        ivec2 iu = ivec2( u ) ;\n\n        ivec4\n             DBG( debug_var )\n            ,state\n            ,score\n            ,player\n            ,ladyfrog\n            ,timers\n            ,fly_n_croc\n            ,m_track[10] //x=src_x_off, y=dst_y_pos\n        ;    \n\n        if( ! iINSIDE( iu, ivec2( 0 ), ivec2( 224, 256 ) )\n           || iINSIDE( iu, ivec2( 0 ), ivec2( 32, 2 ) ) ) {\n            discard ;\n        } else\n        {\n\n            ivec2 src_pos = iu ;\n            int track_ind = ( iu.y - 32 ) >> 4 ;\n            if( track_ind != 5 && track_ind >= 0 && track_ind < 11 ) {\n                if( track_ind >= 5 ) track_ind -- ;\n                ivec4 track = LOADI( madr_track[track_ind] ) ;\n                src_pos = track.xy ;\n                src_pos.x = ( iu.x + src_pos.x + 16 ) & 0xff ;\n                src_pos.y = iu.y ;\n            }\n            o = texelFetch( iChannel0, src_pos, 0 ) ;\n\n            DBG( debug_var = LOADI( adr_debug_var ) ) ;\n            state = LOADI( adr_state ) ;\n            score = LOADI( adr_score ) ;\n            timers = LOADI( adr_timers ) ;\n\n            player = LOADI( adr_player ) ;\n\n            int lives = player.z >> 16 ;\n            int level = score.z ;\n            if( iINSIDE( iu, ivec2( 0 ), ivec2( lives * 8, 16 ) ) ) {\n                draw_player( 2, 0, ivec2( iu.x & ~0x7, iu.y & ~0xf ), o, iu ) ; //lives\n            }\n            else if( iINSIDE( iu, ivec2( 224-8 - (level+1)*8, 0 ), ivec2( 224-8, 16 ) ) ) {\n                draw_player( 3, 0, ivec2( iu.x & ~0x7, iu.y & ~0xf ), o, iu ) ; //levels\n            }\n            /*\n            for( int i = 0 ; i < level + 1 ; ++ i ) {\n                draw_player( 3, 0, ivec2( 224-16 - i*8, 0 ), o, iu ) ;\n            }*/  \n\n            const vec4\n                 col_red_tr =    vec4( col_red.xyz,    0 )\n                ,col_white_tr =  vec4( col_white.xyz,  0 )\n                ,col_yellow_tr = vec4( col_yellow.xyz, 0 )\n            ;\n\n            draw_font8x8_string20_ivec4( 4, txt_1_up, col_white_tr, pos_txt_1_up, o, iu ) ;\n            draw_font8x8_number_05( score.x, col_red_tr, pos_score, o, iu ) ;\n            draw_font8x8_string20_ivec4( 8, txt_hiscore, col_white_tr, pos_txt_hiscore, o, iu ) ;\n            draw_font8x8_number_05( score.y, col_red_tr, pos_hiscore, o, iu ) ;\n\n            if( flag( state.z, STATE_FLAG_PAUSED ) ) {\n                draw_font8x8_string20_ivec4( - ((game_frame>>4)&0x1), txt_paused, col_white, pos_txt_paused, o, iu ) ;\n            }\n\n            if( texelFetch( iChannel3, ivec2( KEY_FPS, 2 ), 0 ).x > .5 ) {\n                draw_font8x8_string20_ivec4( 3, txt_fps, col_white_tr, pos_txt_fps, o, iu ) ;\n                int fr = int( iFrameRate ),\n                    t = int( fr > 99 ) ;\n                draw_font8x8_number_0k( 2 + t, fr, col_red_tr, pos_fps, o, iu ) ;\n                #if( FD > 1 )\n                draw_font8x8_char( _SLASH, col_red_tr, pos_fps + ivec2( 16 + 8*t, 0 ), o, iu ) ;\n                draw_font8x8_number_0k( 1, FD, col_red_tr, pos_fps + ivec2( 24 + 8*t, 0 ), o, iu ) ;\n                #endif\n            }\n\n            ivec2 pos_home = ivec2( ( score.w & 0x7 ) * 48, 0 ) ;\n            if( flag( state.z, STATE_FLAG_BONUS_LADY ) ) {\n                ivec2 pos = pos_bonus_lady + pos_home ;\n                draw_font8x8_char( _BONUS_1, col_yellow_tr, pos, o, iu ) ;\n                draw_font8x8_char( _BONUS_2, col_yellow_tr, pos + ivec2( 8, 0 ), o, iu ) ;\n            }\n            if( flag( state.z, STATE_FLAG_BONUS_FLY ) ) {\n                ivec2 pos = pos_bonus_fly + pos_home ;\n                draw_font8x8_char( _BONUS_1, col_yellow_tr, pos, o, iu ) ;\n                draw_font8x8_char( _BONUS_2, col_yellow_tr, pos + ivec2( 8, 0 ), o, iu ) ;\n            }\n\n            if( state.x == STATE_GAME_OVER ) {\n                draw_font8x8_string20_ivec4( 0, txt_game_over, col_red, pos_txt_game_over, o, iu ) ;\n                if( bool( game_frame & 0x10 ) ) {\n                    draw_font8x8_string20_ivec4( 0, txt_press_1,   col_yellow, pos_txt_press_1,   o, iu ) ;\n                    draw_font8x8_string20_ivec4( 0, txt_for_a_new, col_yellow, pos_txt_for_a_new, o, iu ) ;\n                }\n            } else if( state.x != STATE_GAME_OVER ) {\n                if( timers.y < 0 || timers.y > START_SHOW_T ) {\n                    draw_font8x8_string20_ivec4( 0, txt_time_left, col_red, pos_txt_time_left, o, iu ) ;\n                    draw_font8x8_number_0k( 2, ( score.w >> 5 ), col_red, pos_time_left, o, iu ) ;\n                } else if( timers.y > 0 ) {\n                    draw_font8x8_string20_ivec4( 0, txt_start, col_red, pos_txt_start, o, iu ) ;\n                }\n            }\n\n            DBG( draw_font8x8_number_0k( 5, debug_var.x, vec4(1), ivec2(0,7*16), o, iu ) ) ;\n            DBG( draw_font8x8_number_0k( 5, debug_var.y, vec4(1), ivec2(6*8,7*16), o, iu ) ) ;\n            DBG( draw_font8x8_number_0k( 5, debug_var.z, vec4(1), ivec2(12*8,7*16), o, iu ) ) ;\n            DBG( draw_font8x8_number_0k( 5, debug_var.w, vec4(1), ivec2(18*8,7*16), o, iu ) ) ;\n\n            draw_font8x8_string20_ivec4( 0, txt_time, col_yellow, pos_txt_time, o, iu ) ;\n\n            ivec2 timer_rect_dim = ivec2( ( (state.y + 31) >> 5 ) * 2, 8 ) ;\n            ivec2 timer_rect_pos = ivec2( scr_dim.x - 4 * 8 - timer_rect_dim.x, 0 ) ;\n            if( iu.y < 8 && iu.x < scr_dim.x - 4*8 && iu.x >= timer_rect_pos.x ) {\n                o = timer_rect_dim.x > 20 ? col_green : col_red ; //last 10 ticks (20 pixels)\n            }\n\n            //DBG( draw_font8x8_number_05_(timer_rect_dim.x>>1, vec4(1),ivec2(0),o,iu) ) ;\n            DBG(\n                timers = LOADI( adr_timers ) ;\n                //draw_font8x8_number_0k( 5, timers.x, vec4(1),ivec2(0),o,iu ) ;\n                draw_font8x8_number_0k( 5, state.z & 0x1f, vec4(1), ivec2(0),o,iu ) ;\n            ) ;\n\n            if( state.x == STATE_PLAYING || ( state.x == STATE_FROGS_WINKING && timers.z == 0 ) ) {\n                ivec2 player_pos = player.xy - ivec2( 16, 0 ) ; //hack\n                if( player.w >= END_JUMP_T ) { //jump in move phase\n                    draw_player( 1, player.z & 0x3, player_pos, o, iu ) ;\n                } else if( player.w >= 0 ) { //sitting still, or jump in end phase\n                    draw_player( 0, player.z & 0x3, player_pos, o, iu ) ;\n                } else {\n                    int frame = 3 - ( - player.w ) / 16 ;\n                    if( flag( player.z, PLAYER_FLAG_DROWN ) ) {\n                        //dying in water\n                        if( frame < 0 ) {\n                            draw_player( 1, player.z & 0x3, player_pos, o, iu ) ;\n                        } else {\n                            draw_death_2( frame, player_pos, o, iu ) ;\n                        }\n                    } else {\n                        draw_death_1( clamp( frame, 0, 3 ), player_pos, o, iu ) ;\n                    }\n                }\n            }\n\n            if( flag( state.z, STATE_FLAG_LADY_ACTIVE ) ) {\n                ladyfrog = LOADI( adr_ladyfrog ) ;\n                ivec2 ladyfrog_pos = ladyfrog.xy - ivec2( 16, 0 ) ; //hack\n                draw_ladyfrog( 0, ladyfrog.z & 0x3, ladyfrog_pos, o, iu ) ;\n            }\n        }\n    }\n}\n\n\n\n#undef _\n#define _ 0U\n#define x 1U\n\nconst uvec4 gfx_font8x8[] = uvec4[32](\n    //0,1,2,3\n    uvec4( BR32( _,_,_,x,x,x,_,_, _,_,_,_,x,x,_,_, _,_,x,x,x,x,x,_, _,_,x,x,x,x,x,x ),\n           BR32( _,_,x,_,_,x,x,_, _,_,_,x,x,x,_,_, _,x,x,_,_,_,x,x, _,_,_,_,_,x,x,_ ),\n           BR32( _,x,x,_,_,_,x,x, _,_,_,_,x,x,_,_, _,_,_,_,_,x,x,x, _,_,_,_,x,x,_,_ ),\n           BR32( _,x,x,_,_,_,x,x, _,_,_,_,x,x,_,_, _,_,_,x,x,x,x,_, _,_,_,x,x,x,x,_ ) ),\n    uvec4( BR32( _,x,x,_,_,_,x,x, _,_,_,_,x,x,_,_, _,_,x,x,x,x,_,_, _,_,_,_,_,_,x,x ),\n           BR32( _,_,x,x,_,_,x,_, _,_,_,_,x,x,_,_, _,x,x,x,_,_,_,_, _,x,x,_,_,_,x,x ),\n           BR32( _,_,_,x,x,x,_,_, _,_,x,x,x,x,x,x, _,x,x,x,x,x,x,x, _,_,x,x,x,x,x,_ ),\n           0 ),\n    //4,5,6,7\n    uvec4( BR32( _,_,_,_,x,x,x,_, _,x,x,x,x,x,x,_, _,_,_,x,x,x,x,_, _,x,x,x,x,x,x,x ),\n           BR32( _,_,_,x,x,x,x,_, _,x,x,_,_,_,_,_, _,_,x,x,_,_,_,_, _,x,x,_,_,_,x,x ),\n           BR32( _,_,x,x,_,x,x,_, _,x,x,x,x,x,x,_, _,x,x,_,_,_,_,_, _,_,_,_,_,x,x,_ ),\n           BR32( _,x,x,_,_,x,x,_, _,_,_,_,_,_,x,x, _,x,x,x,x,x,x,_, _,_,_,_,x,x,_,_ ) ),\n    uvec4( BR32( _,x,x,x,x,x,x,x, _,_,_,_,_,_,x,x, _,x,x,_,_,_,x,x, _,_,_,x,x,_,_,_ ),\n           BR32( _,_,_,_,_,x,x,_, _,x,x,_,_,_,x,x, _,x,x,_,_,_,x,x, _,_,_,x,x,_,_,_ ),\n           BR32( _,_,_,_,_,x,x,_, _,_,x,x,x,x,x,_, _,_,x,x,x,x,x,_, _,_,_,x,x,_,_,_ ),\n           0 ),\n    //8,9, bonus 200 through 2 chars\n    uvec4( BR32( _,_,x,x,x,x,_,_, _,_,x,x,x,x,x,_, _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR32( _,x,x,_,_,_,x,_, _,x,x,_,_,_,x,x, _,x,x,x,_,_,_,x,x,_,_,_,x,x,_,_ ),\n           BR32( _,x,x,x,_,_,x,_, _,x,x,_,_,_,x,x, x,_,_,_,x,_,x,_,_,x,_,x,_,_,x,_ ),\n           BR32( _,_,x,x,x,x,_,_, _,_,x,x,x,x,x,x, _,_,_,_,x,_,x,_,_,x,_,x,_,_,x,_ ) ),\n    uvec4( BR32( _,x,_,_,x,x,x,x, _,_,_,_,_,_,x,x, _,_,_,x,_,_,x,_,_,x,_,x,_,_,x,_ ),\n           BR32( _,x,_,_,_,_,x,x, _,_,_,_,_,x,x,_, _,_,x,_,_,_,x,_,_,x,_,x,_,_,x,_ ),\n           BR32( _,_,x,x,x,x,x,_, _,_,x,x,x,x,_,_, _,x,_,_,_,_,x,_,_,x,_,x,_,_,x,_ ),\n           BR32( _,_,_,_,_,_,_,_, _,_,_,_,_,_,_,_, x,x,x,x,x,_,_,x,x,_,_,_,x,x,_,_ ) ),\n    //A,B,C,D\n    uvec4( BR32( _,_,_,x,x,x,_,_, _,x,x,x,x,x,x,_, _,_,_,x,x,x,x,_, _,x,x,x,x,x,_,_ ),\n           BR32( _,_,x,x,_,x,x,_, _,x,x,_,_,_,x,x, _,_,x,x,_,_,x,x, _,x,x,_,_,x,x,_ ),\n           BR32( _,x,x,_,_,_,x,x, _,x,x,_,_,_,x,x, _,x,x,_,_,_,_,_, _,x,x,_,_,_,x,x ),\n           BR32( _,x,x,_,_,_,x,x, _,x,x,x,x,x,x,_, _,x,x,_,_,_,_,_, _,x,x,_,_,_,x,x ) ),\n    uvec4( BR32( _,x,x,x,x,x,x,x, _,x,x,_,_,_,x,x, _,x,x,_,_,_,_,_, _,x,x,_,_,_,x,x ),\n           BR32( _,x,x,_,_,_,x,x, _,x,x,_,_,_,x,x, _,_,x,x,_,_,x,x, _,x,x,_,_,x,x,_ ),\n           BR32( _,x,x,_,_,_,x,x, _,x,x,x,x,x,x,_, _,_,_,x,x,x,x,_, _,x,x,x,x,x,_,_ ),\n           0 ),\n    //E,F,G,H\n    uvec4( BR32( _,_,x,x,x,x,x,x, _,x,x,x,x,x,x,x, _,_,_,x,x,x,x,x, _,x,x,_,_,_,x,x ),\n           BR32( _,_,x,x,_,_,_,_, _,x,x,_,_,_,_,_, _,_,x,x,_,_,_,_, _,x,x,_,_,_,x,x ),\n           BR32( _,_,x,x,_,_,_,_, _,x,x,_,_,_,_,_, _,x,x,_,_,_,_,_, _,x,x,_,_,_,x,x ),\n           BR32( _,_,x,x,x,x,x,_, _,x,x,x,x,x,x,_, _,x,x,_,_,x,x,x, _,x,x,x,x,x,x,x ) ),\n    uvec4( BR32( _,_,x,x,_,_,_,_, _,x,x,_,_,_,_,_, _,x,x,_,_,_,x,x, _,x,x,_,_,_,x,x ),\n           BR32( _,_,x,x,_,_,_,_, _,x,x,_,_,_,_,_, _,_,x,x,_,_,x,x, _,x,x,_,_,_,x,x ),\n           BR32( _,_,x,x,x,x,x,x, _,x,x,_,_,_,_,_, _,_,_,x,x,x,x,x, _,x,x,_,_,_,x,x ),\n           0 ),\n    //I,J,K,L\n    uvec4( BR32( _,_,x,x,x,x,x,x, _,_,_,_,_,_,x,x, _,x,x,_,_,_,x,x, _,_,x,x,_,_,_,_ ),\n           BR32( _,_,_,_,x,x,_,_, _,_,_,_,_,_,x,x, _,x,x,_,_,x,x,_, _,_,x,x,_,_,_,_ ),\n           BR32( _,_,_,_,x,x,_,_, _,_,_,_,_,_,x,x, _,x,x,_,x,x,_,_, _,_,x,x,_,_,_,_ ),\n           BR32( _,_,_,_,x,x,_,_, _,_,_,_,_,_,x,x, _,x,x,x,x,_,_,_, _,_,x,x,_,_,_,_ ) ),\n    uvec4( BR32( _,_,_,_,x,x,_,_, _,_,_,_,_,_,x,x, _,x,x,x,x,x,_,_, _,_,x,x,_,_,_,_ ),\n           BR32( _,_,_,_,x,x,_,_, _,x,x,_,_,_,x,x, _,x,x,_,x,x,x,_, _,_,x,x,_,_,_,_ ),\n           BR32( _,_,x,x,x,x,x,x, _,_,x,x,x,x,x,_, _,x,x,_,_,x,x,x, _,_,x,x,x,x,x,x ),\n           0 ),\n    //M,N,O,P\n    uvec4( BR32( _,x,x,_,_,_,x,x, _,x,x,_,_,_,x,x, _,_,x,x,x,x,x,_, _,x,x,x,x,x,x,_ ),\n           BR32( _,x,x,x,_,x,x,x, _,x,x,x,_,_,x,x, _,x,x,_,_,_,x,x, _,x,x,_,_,_,x,x ),\n           BR32( _,x,x,x,x,x,x,x, _,x,x,x,x,_,x,x, _,x,x,_,_,_,x,x, _,x,x,_,_,_,x,x ),\n           BR32( _,x,x,x,x,x,x,x, _,x,x,x,x,x,x,x, _,x,x,_,_,_,x,x, _,x,x,_,_,_,x,x ) ),\n    uvec4( BR32( _,x,x,_,x,_,x,x, _,x,x,_,x,x,x,x, _,x,x,_,_,_,x,x, _,x,x,x,x,x,x,_ ),\n           BR32( _,x,x,_,_,_,x,x, _,x,x,_,_,x,x,x, _,x,x,_,_,_,x,x, _,x,x,_,_,_,_,_ ),\n           BR32( _,x,x,_,_,_,x,x, _,x,x,_,_,_,x,x, _,_,x,x,x,x,x,_, _,x,x,_,_,_,_,_ ),\n           0 ),\n    //R,Q,S,T\n    uvec4( BR32( _,_,x,x,x,x,x,_, _,x,x,x,x,x,x,_, _,_,x,x,x,x,_,_, _,_,x,x,x,x,x,x ),\n           BR32( _,x,x,_,_,_,x,x, _,x,x,_,_,_,x,x, _,x,x,_,_,x,x,_, _,_,_,_,x,x,_,_ ),\n           BR32( _,x,x,_,_,_,x,x, _,x,x,_,_,_,x,x, _,x,x,_,_,_,_,_, _,_,_,_,x,x,_,_ ),\n           BR32( _,x,x,_,_,_,x,x, _,x,x,_,_,x,x,x, _,_,x,x,x,x,x,_, _,_,_,_,x,x,_,_ ) ),\n    uvec4( BR32( _,x,x,_,x,x,x,x, _,x,x,x,x,x,_,_, _,_,_,_,_,_,x,x, _,_,_,_,x,x,_,_ ),\n           BR32( _,x,x,_,_,x,x,_, _,x,x,_,x,x,x,_, _,x,x,_,_,_,x,x, _,_,_,_,x,x,_,_ ),\n           BR32( _,_,x,x,x,x,_,x, _,x,x,_,_,x,x,x, _,_,x,x,x,x,x,_, _,_,_,_,x,x,_,_ ),\n           0 ),\n    //U,V,W,X\n    uvec4( BR32( _,x,x,_,_,_,x,x, _,x,x,_,_,_,x,x, _,x,x,_,_,_,x,x, _,x,x,_,_,_,x,x ),\n           BR32( _,x,x,_,_,_,x,x, _,x,x,_,_,_,x,x, _,x,x,_,_,_,x,x, _,x,x,x,_,x,x,x ),\n           BR32( _,x,x,_,_,_,x,x, _,x,x,_,_,_,x,x, _,x,x,_,x,_,x,x, _,_,x,x,x,x,x,_ ),\n           BR32( _,x,x,_,_,_,x,x, _,x,x,x,_,x,x,x, _,x,x,x,x,x,x,x, _,_,_,x,x,x,_,_ ) ),\n    uvec4( BR32( _,x,x,_,_,_,x,x, _,_,x,x,x,x,x,_, _,x,x,x,x,x,x,x, _,_,x,x,x,x,x,_ ),\n           BR32( _,x,x,_,_,_,x,x, _,_,_,x,x,x,_,_, _,_,x,x,_,x,x,_, _,x,x,x,_,x,x,x ),\n           BR32( _,_,x,x,x,x,x,_, _,_,_,_,x,_,_,_, _,_,x,_,_,_,x,_, _,x,x,_,_,_,x,x ),\n           0 ),\n    //Y,Z,?,-\n    uvec4( BR32( _,_,x,x,_,_,x,x, _,x,x,x,x,x,x,x, _,_,_,_,_,_,_,_, _,_,_,_,_,_,_,_ ),\n           BR32( _,_,x,x,_,_,x,x, _,_,_,_,_,x,x,x, _,_,_,_,_,_,_,_, _,_,_,_,_,_,_,_ ),\n           BR32( _,_,_,x,_,_,x,_, _,_,_,_,x,x,x,_, _,_,_,_,_,_,_,_, _,_,_,_,_,_,_,_ ),\n           BR32( _,_,_,x,x,x,x,_, _,_,_,x,x,x,_,_, _,_,_,_,_,_,_,_, _,x,x,x,x,x,x,x ) ),\n    uvec4( BR32( _,_,_,_,x,x,_,_, _,_,x,x,x,_,_,_, _,_,_,_,_,_,_,_, _,_,_,_,_,_,_,_ ),\n           BR32( _,_,_,_,x,x,_,_, _,x,x,x,_,_,_,_, _,_,_,_,_,_,_,_, _,_,_,_,_,_,_,_ ),\n           BR32( _,_,_,_,x,x,_,_, _,x,x,x,x,x,x,x, _,_,_,_,_,_,_,_, _,_,_,_,_,_,_,_ ),\n           0 ),\n    // /\n    uvec4( BR32( _,_,_,_,_,_,x,_, _,_,_,_,_,_,_,_, _,_,_,_,_,_,_,_, _,_,_,_,_,_,_,_ ),\n           BR32( _,_,_,_,_,x,x,_, _,_,_,_,_,_,_,_, _,_,_,_,_,_,_,_, _,_,_,_,_,_,_,_ ),\n           BR32( _,_,_,_,x,x,_,_, _,_,_,_,_,_,_,_, _,_,_,_,_,_,_,_, _,_,_,_,_,_,_,_ ),\n           BR32( _,_,_,_,x,_,_,_, _,_,_,_,_,_,_,_, _,_,_,_,_,_,_,_, _,_,_,_,_,_,_,_ ) ),\n    uvec4( BR32( _,_,_,x,x,_,_,_, _,_,_,_,_,_,_,_, _,_,_,_,_,_,_,_, _,_,_,_,_,_,_,_ ),\n           BR32( _,_,x,x,_,_,_,_, _,_,_,_,_,_,_,_, _,_,_,_,_,_,_,_, _,_,_,_,_,_,_,_ ),\n           BR32( _,_,x,_,_,_,_,_, _,_,_,_,_,_,_,_, _,_,_,_,_,_,_,_, _,_,_,_,_,_,_,_ ),\n           0 ),\n\n    uvec4(0),uvec4(0),\n    uvec4(0),uvec4(0),uvec4(0),uvec4(0),\n    uvec4(0),uvec4(0),uvec4(0),uvec4(0)\n) ;\n\n//BR32( _,_,_,_,_,_,_,_, _,_,_,_,_,_,_,_, _,_,_,_,_,_,_,_, _,_,_,_,_,_,_,_ )\n\n#undef x\n\n#define r 1U\n#define g 2U\n#define y 3U\n\n/**/\n\nconst uvec4 gfx_death_1[] = uvec4[4*4](\n    uvec4( BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,g,_,_,_,_,_,g,_,_,_,_ ),\n           BR16( _,_,_,_,g,g,g,_,_,_,g,g,g,_,_,_ ),\n           BR16( _,_,_,g,g,g,y,y,y,y,y,g,g,g,_,_ ) ),\n    uvec4( BR16( _,_,_,_,g,y,r,r,y,r,r,y,g,_,_,_ ),\n           BR16( _,_,_,_,_,r,r,r,y,r,r,r,_,_,_,_ ),\n           BR16( _,_,_,_,_,g,g,g,y,g,g,g,_,_,_,_ ),\n           BR16( _,_,_,_,_,g,g,y,y,y,g,g,_,_,_,_ ) ),\n    uvec4( BR16( _,_,_,_,_,y,y,y,y,y,y,y,_,_,_,_ ),\n           BR16( _,_,_,_,_,y,g,y,y,y,y,y,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,g,y,y,y,y,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,y,g,y,y,y,g,_,_,_,_ ) ),\n    uvec4( BR16( _,_,_,_,g,g,y,y,y,y,y,g,g,_,_,_ ),\n           BR16( _,_,_,_,_,g,g,g,_,g,g,g,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,g,_,_,_,g,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ) ),\n\n    uvec4( BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,g,_,_,y,y,y,_,_,g,_,_,_ ),\n           BR16( _,_,_,g,g,_,g,y,y,y,g,_,g,g,_,_ ) ),\n    uvec4( BR16( _,_,_,g,_,g,g,g,y,g,g,g,_,g,_,_ ),\n           BR16( _,_,_,_,r,r,r,g,y,g,r,r,r,_,_,_ ),\n           BR16( _,_,_,_,g,r,g,g,y,g,g,r,g,_,_,_ ),\n           BR16( _,_,_,_,g,g,g,y,y,y,g,g,g,_,_,_ ) ),\n    uvec4( BR16( _,_,_,_,g,g,y,y,y,y,y,g,g,_,_,_ ),\n           BR16( _,_,_,_,y,y,y,y,y,y,y,y,y,_,_,_ ),\n           BR16( _,_,_,_,y,y,y,y,y,y,y,y,y,_,_,_ ),\n           BR16( _,_,_,_,_,g,y,y,y,y,y,y,_,_,_,_ ) ),\n    uvec4( BR16( _,_,_,g,g,y,g,y,y,y,y,y,g,g,_,_ ),\n           BR16( _,_,_,g,g,g,y,y,y,y,y,g,g,g,_,_ ),\n           BR16( _,_,_,_,_,g,_,_,_,_,_,g,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ) ),\n\n    uvec4( BR16( _,_,_,_,g,g,_,_,_,_,_,g,g,_,_,_ ),\n           BR16( _,_,_,g,g,y,y,y,y,y,y,y,g,g,_,_ ),\n           BR16( _,_,g,g,y,y,y,y,y,y,y,y,y,g,g,_ ),\n           BR16( _,_,g,_,y,g,g,g,y,g,g,g,y,_,g,_ ) ),\n    uvec4( BR16( _,_,_,_,g,g,g,g,y,g,g,g,g,_,_,_ ),\n           BR16( _,_,_,_,r,g,g,g,y,g,g,g,r,_,_,_ ),\n           BR16( _,_,_,y,r,r,g,g,y,g,g,r,r,y,_,_ ),\n           BR16( _,_,_,y,y,r,g,y,y,y,g,r,y,y,_,_ ) ),\n    uvec4( BR16( _,_,_,y,y,y,y,y,y,y,y,y,y,y,_,_ ),\n           BR16( _,_,_,y,y,y,y,y,y,y,y,y,y,y,_,_ ),\n           BR16( _,_,_,_,g,y,y,y,y,y,y,y,y,_,_,_ ),\n           BR16( _,_,_,_,g,y,y,y,y,y,y,y,y,_,_,_ ) ),\n    uvec4( BR16( _,_,g,g,y,g,y,y,y,y,y,y,y,g,g,_ ),\n           BR16( _,_,g,g,y,y,y,y,y,y,y,y,y,g,g,_ ),\n           BR16( _,_,_,g,g,y,y,y,y,y,y,y,g,g,_,_ ),\n           BR16( _,_,_,g,g,g,_,_,_,_,_,g,g,g,_,_ ) ),\n\n    uvec4( BR16( _,_,_,_,_,_,g,g,g,g,g,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,g,g,g,g,g,g,g,_,_,_,_ ),\n           BR16( _,_,_,_,g,g,_,g,g,g,_,g,g,_,_,_ ),\n           BR16( _,_,_,_,g,_,g,g,g,g,g,_,g,_,_,_ ) ),\n    uvec4( BR16( _,g,g,_,g,g,g,g,g,g,g,g,g,_,g,g ),\n           BR16( _,g,g,_,_,_,g,g,g,g,g,_,_,_,g,g ),\n           BR16( _,_,_,g,_,_,_,g,g,g,_,_,_,g,_,_ ),\n           BR16( _,_,_,_,g,_,_,_,_,_,_,_,g,_,_,_ ) ),\n    uvec4( BR16( _,_,_,_,_,g,_,_,_,_,_,g,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,g,_,_,_,g,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,g,_,g,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,g,_,_,_,_,_,_,_ ) ),\n    uvec4( BR16( _,_,_,_,_,_,_,g,_,g,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,g,_,_,_,g,_,_,_,_,_ ),\n           BR16( _,_,_,_,g,g,_,_,_,_,_,g,g,_,_,_ ),\n           BR16( _,_,_,_,g,g,_,_,_,_,_,g,g,_,_,_ ) )\n\n) ;\n\nconst uvec4 gfx_death_2[] = uvec4[4*4](\n    uvec4( BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,g,_,_,g,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,g,_,_,_,_,_,_,g,_,_,_,_ ) ),\n    uvec4( BR16( _,_,_,g,_,_,_,y,y,_,_,_,g,_,_,_ ),\n           BR16( _,_,_,_,_,y,y,y,y,y,y,_,_,_,_,_ ),\n           BR16( _,_,g,_,_,y,y,y,y,y,y,_,_,g,_,_ ),\n           BR16( _,_,_,_,y,y,y,y,y,y,y,y,_,_,_,_ ) ),\n    uvec4( BR16( _,_,_,_,y,y,y,y,y,y,y,y,_,_,_,_ ),\n           BR16( _,_,g,_,_,y,y,y,y,y,y,_,_,g,_,_ ),\n           BR16( _,_,_,_,_,y,y,y,y,y,y,_,_,_,_,_ ),\n           BR16( _,_,_,g,_,_,_,y,y,_,_,_,g,_,_,_ ) ),\n    uvec4( BR16( _,_,_,_,g,_,_,_,_,_,_,g,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,g,_,_,g,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ) ),\n\n    uvec4( BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,g,_,g,g,_,g,_,_,_,_,_ ),\n           BR16( _,_,_,g,_,_,_,_,_,_,_,_,g,_,_,_ ),\n           BR16( _,_,g,_,_,_,_,_,_,_,_,_,_,g,_,_ ) ),\n    uvec4( BR16( _,_,_,_,_,_,_,g,g,_,_,_,_,_,_,_ ),\n           BR16( _,_,g,_,_,g,_,y,y,_,g,_,_,g,_,_ ),\n           BR16( _,_,_,_,_,_,y,y,y,y,_,_,_,_,_,_ ),\n           BR16( _,g,_,_,g,y,y,y,y,y,y,g,_,_,g,_ ) ),\n    uvec4( BR16( _,g,_,_,g,y,y,y,y,y,y,g,_,_,g,_ ),\n           BR16( _,_,_,_,_,_,y,y,y,y,_,_,_,_,_,_ ),\n           BR16( _,_,g,_,_,g,_,y,y,_,g,_,_,g,_,_ ),\n           BR16( _,_,_,_,_,_,_,g,g,_,_,_,_,_,_,_ ) ),\n    uvec4( BR16( _,_,g,_,_,_,_,_,_,_,_,_,_,g,_,_ ),\n           BR16( _,_,_,g,_,_,_,_,_,_,_,_,g,_,_,_ ),\n           BR16( _,_,_,_,_,g,_,g,g,_,g,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ) ),\n\n    uvec4( BR16( _,_,_,_,_,_,g,_,_,g,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,g,_,_,_,_,_,_,_,_,_,_,g,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ) ),\n    uvec4( BR16( _,_,_,_,_,_,g,_,_,g,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( g,_,_,_,g,_,_,_,_,_,_,g,_,_,_,g ),\n           BR16( _,_,_,_,_,_,_,y,y,_,_,_,_,_,_,_ ) ),\n    uvec4( BR16( _,_,_,_,_,_,_,y,y,_,_,_,_,_,_,_ ),\n           BR16( g,_,_,_,g,_,_,_,_,_,_,g,_,_,_,g ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,g,_,_,g,_,_,_,_,_,_ ) ),\n    uvec4( BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,g,_,_,_,_,_,_,_,_,_,_,g,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,g,_,_,g,_,_,_,_,_,_ ) ),\n\n    uvec4( BR16( _,_,_,_,_,_,g,g,g,g,g,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,g,g,g,g,g,g,g,_,_,_,_ ),\n           BR16( _,_,_,_,g,g,_,g,g,g,_,g,g,_,_,_ ),\n           BR16( _,_,_,_,g,_,g,g,g,g,g,_,g,_,_,_ ) ),\n    uvec4( BR16( _,g,g,_,g,g,g,g,g,g,g,g,g,_,g,g ),\n           BR16( _,g,g,_,_,_,g,g,g,g,g,_,_,_,g,g ),\n           BR16( _,_,_,g,_,_,_,g,g,g,_,_,_,g,_,_ ),\n           BR16( _,_,_,_,g,_,_,_,_,_,_,_,g,_,_,_ ) ),\n    uvec4( BR16( _,_,_,_,_,g,_,_,_,_,_,g,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,g,_,_,_,g,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,g,_,g,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,_,_,g,_,_,_,_,_,_,_ ) ),\n    uvec4( BR16( _,_,_,_,_,_,_,g,_,g,_,_,_,_,_,_ ),\n           BR16( _,_,_,_,_,_,g,_,_,_,g,_,_,_,_,_ ),\n           BR16( _,_,_,_,g,g,_,_,_,_,_,g,g,_,_,_ ),\n           BR16( _,_,_,_,g,g,_,_,_,_,_,g,g,_,_,_ ) )\n) ;\n\n#undef _\n#undef r\n#undef g\n#undef y\n\nGENERATE_GET_BR_16( get_death_1_br,      gfx_death_1     )\nGENERATE_GET_BR_16( get_death_2_br,      gfx_death_2     )\n\nGENERATE_DRAW_4T_PALETTE( draw_death_1, dim_death_1, get_death_1_br, pal_death_1 )\nGENERATE_DRAW_4T_PALETTE( draw_death_2, dim_death_2, get_death_2_br, pal_death_2 )\n\n\nGENERATE_GET_BR_32( get_font8x8_br, gfx_font8x8 )\n    \nvec4 draw_font8x8_char( int ch, vec4 col, ivec2 pos, inout vec4 o, ivec2 iu ) {\n    vec4 v = vec4( -1 ) ;\n    iu -= pos ;\n    if( ch > 0 && iINSIDE( iu, ivec2(0), ivec2(8) ) ) {\n        if( col.a == 0. ) {\n            col.a = 1. ;\n        } else {\n            v = vec4( 0,0,0,1 ) ;\n        }\n            \n        ch -- ;\n        int row_group = ( ch >> 2 ) * 2 + 1 - ( iu.y >> 2 ),\n            component = 3 - ( iu.y & 0x3 ),\n            sh = iu.x ;\n        uint bit = 0x1U << sh,\n             col_ind = ( get_font8x8_br( row_group, component, ch & 0x3 ) & bit ) >> sh ;\n        v = col_ind == 1U ? col : v ;\n    }\n    o = v.a > 0. ? v : o ;\n    return( v ) ;\n}\n\n//5 letters (6 bit) packed per component, max 20 letters\nvec4 draw_font8x8_string20_ivec4( int num_ch, ivec4 s, vec4 col, ivec2 pos, inout vec4 o, ivec2 iu ) {\n    vec4 v = vec4( 0 ) ;\n    if( num_ch < 0 ) {\n        return( v ) ;\n    }\n    num_ch = num_ch == 0 ? 20 : min( num_ch, 20 ) ;\n\n    ivec2 iu2 = iu - pos ;\n    if( iINSIDE( iu2, ivec2(0), ivec2(num_ch*8,8) ) ) {\n        int i = iu2.x >> 3,\n            j = i / 5,\n            sh = 6*(i % 5),\n            s5 =  j<2?j<1?  s[0] : s[1]\n                 :j<3?      s[2] : s[3],\n            m = 0x3f << sh,\n            c = (s5 & m) >> sh ;\n        pos.x += i * 8 ;\n        v += draw_font8x8_char( c, col, pos, o, iu ) ;\n    }\n    return( v ) ;\n}\n\n//prints  -99..9 to 99..9\n//digits:   k-1       k\n//for numbers outside the range more significant digits will get cut off\nvec4 draw_font8x8_number_0k( int k, int n, vec4 col, ivec2 pos, inout vec4 o, ivec2 iu ) {\n    vec4 v = vec4( 0 ) ;\n    int off = 0 ;\n    if( n < 0 ) {\n        v += draw_font8x8_char( _DASH, col, pos, o, iu ) ;\n        n = 0 - n ; //freaking workaround for mac os bug!!!\n        off = 8 ;\n    }\n    ivec2 iu2 = iu - pos ;\n    if( iINSIDE( iu2, ivec2(off,0), ivec2(k*8,8) ) ) {\n        int p = ( ( k*8 - 1 ) - iu2.x ) / 8, c ;\n        //for( int i = 0 ; i < p ; ++ i ) n /= 10 ;\n        //c = n % 10 ;\n        int d = int( floor( pow( 10., float(p) ) ) ) ;\n        c = ( n / d ) % 10 ;\n        v += draw_font8x8_char( c + 1, col, pos + ivec2( (k-1-p) * 8, 0 ), o, iu ) ;\n    }\n    return( v ) ;\n}\n\n//prints numbers in range 00000 - 99999\n//\nvec4 draw_font8x8_number_05( int n, vec4 col, ivec2 pos, inout vec4 o, ivec2 iu ) {\n    vec4 v = vec4( 0 ) ;\n    ivec2 iu2 = iu - pos ;\n    if( iINSIDE( iu2, ivec2(0), ivec2(5*8,8) ) ) {\n        int p = ( ( 5*8 - 1 ) - iu2.x ) / 8,\n            d = int( round( pow( 10., float(p) ) ) ),\n            c = ( n / d ) % 10 ;\n        v += draw_font8x8_char( c + 1, col, pos + ivec2( (4-p) * 8, 0 ), o, iu ) ;\n    }\n    return( v ) ;\n}\n\n\n//END Buffer B","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 o, vec2 u )\n{\n#if FD > 1\n    //skip frames\n    if( iFrame % FD != 0 ) {\n        discard ;\n    } else\n#endif\n    {\n\n        ivec2 iu = ivec2( u ) ;\n\n        vec2 fscr_dim = vec2( scr_dim ) ;\n\n        float k = iResolution.y / fscr_dim.y ;\n\n        //read toggle status of the key by fetching (key, 2) from keyboard\n        if( texelFetch( iChannel3, ivec2( KEY_INT_SIZE, 2 ), 0 ).x > .5 ) {\n            k = floor( k ) ;\n        }\n\n        ivec2 new_dim = ivec2( fscr_dim * k ) ;\n        ivec2 diff = ivec2( iResolution.xy ) - new_dim ;\n        u -= vec2( diff / 2 ) ;\n\n        o = vec4( 0 ) ;\n\n        if( texelFetch( iChannel3, ivec2( KEY_LINEAR, 2 ), 0 ).x < .5 ) { //default linear\n            o += texture( iChannel1, u / ( k * iResolution.xy ) ) ;\n        } else {\n            o += texelFetch( iChannel1, ivec2( u / k ), 0 ) ;\n        }\n\n        //border (but it is redrawn in filter stage to avoid filtering...)\n        /*if( ! iINSIDE( ivec2( u ), ivec2( 0 ), new_dim ) ) {\n            o = vec4( .4, 0, 0, 1 ) ;\n        }*/\n    }\n}\n\n\n//END Buffer C","name":"Buffer C","description":"","type":"buffer"}]}