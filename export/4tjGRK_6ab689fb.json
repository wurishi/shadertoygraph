{"ver":"0.1","info":{"id":"4tjGRK","date":"1430358403","viewed":173,"name":"Untitled #3","username":"kindofsleepy","description":"Blobs and lighting","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"#ifdef GL_ES\nprecision highp float;\n#endif\n\n#define POINTS 25.0\n#define RADIUS 500.0\n#define BRIGHTNESS 0.45\n#define COLOR vec3(1.0, 1.0, 0.0)\n#define SMOOTHNESS 40.0\n#define PI 3.14149\n#define LAG_A 0.325\n#define LAG_B 0.825\n#define LAG_C 0.825\nvec2 uv = gl_FragCoord.xy;\nvec4 fragCoord = gl_FragCoord;\nvec2 rand22(in vec2 p)\n{\n\treturn fract(vec2(sin(p.x * 591.32 + p.y * 154.077), cos(p.x * 391.32 + p.y * 49.077)));\n}\n\n// i just faked the vec3 version frin the one above by adding random numbers, no idea if it's \"correct\"\nvec3 rand33(in vec3 p)\n{\n\treturn fract(vec3(sin(p.x * 591.32 + p.y * 154.077 + p.z * 712.223 ), cos(p.x * 391.32 + p.y * 49.077 + p.z * 401.326), cos (p.x * 1010.22 + p.y * 27.311 + p.z* 131.44)));\n}\n\tvec2 vUv = ( fragCoord.xy / iResolution.xy );\nfloat nrand( vec2 n ) {\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\nvec2 rot2d( vec2 p, float a ) {\n\tvec2 sc = vec2(sin(a),cos(a));\n\treturn vec2( dot( p, vec2(sc.y, -sc.x) ), dot( p, sc.xy ) );\n}\nvec4 circularBlur(){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv.x *= 0.1 *iTime;\n\n\tfloat maxofs = 12.0 * (0.5+0.5*sin( iTime ));\n\tconst int NUM_SAMPLES = 16;\n\tconst int NUM_SAMPLES2 = NUM_SAMPLES/2;\n\tconst float NUM_SAMPLES_F = float(NUM_SAMPLES);\n\tconst float anglestep = 30.28 / NUM_SAMPLES_F;\n\tconst float MIPBIAS = -8.0; //note: make sure we always pick mip0\n\n\t//note: rand\n\tfloat rnd = nrand( 0.01*fragCoord.xy );//+ fract(iTime) );\n\t\n\t//note: ordered dither\n\t//float rnd = texture( iChannel1, fragCoord.xy / 8.0 ).r;\n\n\t//note: create halfcircle of offsets\n\tvec2 ofs[NUM_SAMPLES];\n\t{\n\t\tfloat angle = 3.1416*rnd;\n\t\tfor( int i=0;i<NUM_SAMPLES2;++i )\n\t\t{\n\t\t\tofs[i] = rot2d( vec2(maxofs,0.0), angle ) / iResolution.xy;\n\t\t\tangle += anglestep;\n\t\t}\n\t}\n\t\n\tvec4 sum = vec4(0.0);\n\t//note: sample positive half-circle\n\tfor( int i=0;i<NUM_SAMPLES2;++i )\n\t\tsum += texture( iChannel0, vec2(uv.x, uv.y)+ofs[i], MIPBIAS );\n\n\t//note: sample negative half-circle\n\tfor( int i=0;i<NUM_SAMPLES2;++i )\n\t\tsum += texture(iChannel0, vec2(uv.x, uv.y)-ofs[i], MIPBIAS );\n\t\n\treturn vec4((sum.rgb / NUM_SAMPLES_F),texture( iChannel1, vUv ));\n}\n\nfloat dst(vec3 r) {\n\t//return max(abs(r.x), abs(r.y));\n\treturn length(r);\n}\n\n\nvec3 getPoint(float n) {\n    vec4 texture1 = texture(iChannel1, vUv, -0.8);\n\tvec2 p = ( fragCoord.xy / iResolution.xy );\n\t\n    float theta = (3.14149) /sin(4.0);\n\t#define time time + atan(p.x, p.y)*2.0\n    \n\tmat2 m = mat2(sin(theta), sin(theta)/ iTime, sin(theta)/ iTime, tan(theta));\n\t \n    p = p * 2.0 - 1.0;\n\tp.x *= iResolution.x / iResolution.y;\n\tp = m * p;\n\t\n    vec2 f = fract(p * 5.0);\n\tf = 2.0 * f - 1.0;\n\t\n\tfloat df = distance(f, vec2(0.0, 0.0));\n\tdf = 3.0*df*df - 2.0*df*df*df;\n\t\n    //df /= texture1.r;\n    float dp = max(1.5 - distance(p, vec2(0.0, 0.0)), 0.0);\n\t\n    dp = 3.0*dp*dp - 2.0*dp*df*df;\n\t\n    float from = 0.3 + sin(dp * PI * 0.5 + iTime * 0.5) * 0.75;\n\tfloat to = from + 0.05;\n    \n    vec3 d = texture(iChannel0,uv+iTime*0.05).xyz;\n     float t = iTime * 0.1;\n     vec2 center = iResolution.xy / 2.0;\n   \n     p += vec2(d.x + texture1.x,d.x * texture1.x) * dp * sin(t *  3.5 + n * LAG_A);\n     p += vec2(d.y + texture1.y,d.y * texture1.y) * dp * sin(t *  4.5 + n * LAG_B);\n     p += vec2(d.z + texture1.z,d.z * texture1.z) * 50.0 * sin(t *  4.0 + n * LAG_C);\n       \n     p += vec2(d.x + texture1.x,d.x * texture1.x) * dp * sin(t *  3.5 + n * LAG_A);\n     p += vec2(d.y + texture1.y,d.y * texture1.y) * dp * sin(t *  4.5 + n * LAG_B);\n     p += vec2(d.z + texture1.z,d.z * texture1.z) * 50.0 * sin(t *  4.0 + n * LAG_C);\n       \n     p += vec2(d.x + texture1.x,d.x * texture1.x) * dp * sin(t *  3.5 + n * LAG_A);\n     p += vec2(d.y + texture1.y,d.y * texture1.y) * dp * sin(t *  4.5 + n * LAG_B);\n     p += vec2(d.z + texture1.z,d.z * texture1.z) * 50.0 * sin(t *  4.0 + n * LAG_C);\n    \n    \n     p += vec2(100.0, 0.0) * sin(t *  2.5 + n * LAG_A)\n          - vec2(110.0, 100.0) * sin(t * -1.5 + n * LAG_B)\n          + vec2(150.0, 100.0) * cos(t * 0.05 + n * LAG_C)\n          - vec2(150.0, 0.0) * sin(t * 0.15 + n);\n     p += vec2(150.0, 0.0) * sin(t * 0.15 + n);\n        p += vec2(100.0, 0.0) * sin(t *  2.5 + n * LAG_A)\n          + vec2(110.0, 100.0) * sin(t * -1.5 + n * LAG_B)\n          + vec2(150.0, 100.0) * cos(t * 0.05 + n * LAG_C)\n          + vec2(150.0, 0.0) * sin(t * 0.15 + n);\n     p += vec2(150.0, 0.0) * sin(t * 0.15 + n);\n\n     p += vec2(150.0, 0.0) * sin(t * 0.15 + n);\n   \t\n   \n  \n     return vec3(center + p.xy,0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n     vec2 position = fragCoord.xy;\n    \t\n     float b = 0.3;\n    \n     for (float i = 0.0; i < POINTS; i += 0.8) {\n          vec3 p = getPoint(i);\n          float d = 1.0 - clamp(distance(p.xy, position) / RADIUS, 0.0, 0.5);\n          b -= pow(d, SMOOTHNESS);\n     }\n    \n     vec3 c = 0.9 - b+(\n            (sin(b * 0.0) - 0.25) * vec3(0.3, 0.1, 1.0)\n         \n          + clamp(1.0 - b, 1.0, 1.0) * (cos(b * 10.0) + 1.25) \n     );\n    \n\n     fragColor = vec4(c * BRIGHTNESS, 1.0);\n}\n","name":"","description":"","type":"image"}]}