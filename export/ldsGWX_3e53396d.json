{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","sampler":{"filter":"nearest","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"/*\nComparison of distance from point to ellipsoid solvers,\nincluding a new one which is more robust than the other two.\nAnton Kirczenow 2013\n\nEach view shows a colorized planar slice of the distance field to an ellipsoid\nwhich is changing shape over time.\nThe ellipsoid is drawn with a checker board pattern to show the \ndifferent parameterizations used in the solvers.\n\nTop row: \t\tinitial guesses\t\nBottom row: \tsolved result\nLeft to right:\tEberly, Nurnberg, ours\n\nNote Eberly version takes a lot of iterations to still be rather inaccurate in many situations,\nespecially in the interior.\n\nNote Nurnberg version blows up in interior and around the poles of the \nspherical coordinate parameterization.\n\n\nMIT LICENSE\nCopyright 2013 Anton Kirczenow\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n*/\n#define pi 3.1415927\n\nfloat DistanceToEllipsoidEberly(vec3 p, vec3 abc);\nfloat DistanceToEllipsoidNurnberg(vec3 p, vec3 abc);\nvec3 InitialGuessClosestPointToEllipsoid(vec3 p, vec3 abc);\nfloat DistanceToEllipsoidStereo(vec3 p, vec3 abc);\nvec2 ToStereoParameters(vec3 cart, vec3 abc);\nvec2 CartToSpherical(vec3 p, vec3 abc);\nvec2 RayEllipsoid(vec3 P, vec3 V, vec3 abc);\nvec3 hsv2rgb(vec3 c);\nvec3 rgb2hsv(vec3 c);\n\n//#define CONFOCAL\n\nvec3 ConfocalGuess(vec3 p, vec3 abc);\n\nvoid MakeViewRay(out vec3 eye, out vec3 ray, in vec2 fragCoord);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewP, viewD;\n\tMakeViewRay(viewP, viewD, fragCoord);\n\t\t\n\t//sweep a plane up and down through the distance field to show distances\n\tfloat t = iTime * 0.5;\n\tfloat floor_height = (sin(t*pi+pi*1.5)+1.)*2.;\n\tfloat floor_intersect_t = (-viewP.y + floor_height) / (viewD.y);\n\n\t//query point is on this plane\t\n\tvec3 p = viewP+viewD*floor_intersect_t;\n\t\n\t//shape of the ellipsoid, the more eccentric, the more numerical problems\t\n#ifdef CONFOCAL\t\n\t//needs coordinates sorted this way\n\tvec3 abc = vec3(3.,2.,1.)*(1.+3.*(sin(iTime)*0.5+0.5));\n//\tvec3 abc=vec3(sin(t)*0.5+0.51,4,1).yzx*(1.+3.*(sin(iTime)*0.5+0.5));\n#else\n \tvec3 abc=vec3(sin(t)*0.5+0.51,4,1)*(1.+3.*(sin(iTime)*0.5+0.5));\t\t\t\n#endif\n\t\n\tfloat d;\n\n\tif (fragCoord.y > 0.5*iResolution.y)\n\t{\n\t\t//top row: show initial guesses for distances\n\t\tif (fragCoord.x < 0.333*iResolution.x)\n\t\t{\n\t\t\tvec3 p_over_abc = p/abc;\n\t\t\tfloat inouttest = dot(p_over_abc,p_over_abc);\n\t\t\tfloat t = inouttest < 1. ? 0. : max(abc.x,max(abc.y,abc.z))*length(p);\n\t\t\tvec3 g = (abc*abc)*p/(t+abc*abc);\n\t\t\td = length(g-p);\n\t\t}\n\t\telse if (fragCoord.x < 0.666*iResolution.x)\n\t\t{\n\t\t\t//simple projection\n\t\t\tvec3 np = normalize(p/abc)*abc;\t\n\t\t\td = length(np-p);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//fancy one (tm) best of simple projection and straight line ray casts\n\t\t\tvec3 gp = InitialGuessClosestPointToEllipsoid(p, abc);\t\n\t\t\td = length(gp-p);\n\t#ifdef CONFOCAL\t\t\t\n\t\t\td = length(ConfocalGuess(p, abc)-p);\n\t#endif\t\t\n\t\t}\n\t}\n\telse\n\t{\n\t\t//bottom row: compare these three solvers\t\t\t\t\n\t\tif \t\t(fragCoord.x < 0.333*iResolution.x) d = DistanceToEllipsoidEberly(p,abc);\n\t\telse if (fragCoord.x < 0.666*iResolution.x) d = DistanceToEllipsoidNurnberg(p,abc);\n\t\telse \t\t\t\t\t\t\t\t\t\t   d = DistanceToEllipsoidStereo(p,abc); //ours (tm)!\n\t}\n\t\n\t//colorize distance \n\tvec3 floor_c = hsv2rgb(vec3(abs(d),1.0,0.8));\n\t\n\tvec3 L = normalize(vec3(-1,2,-1));\n\t\n\t//find and shade intersections of eye ray with ellipsoid\n\tvec2 tE = RayEllipsoid(viewP, viewD, abc);\n\n\tvec3 pE[2], nE[2], cE[2];\n\tfor (int i=0; i<2; i++)\n\t{\n\t\tpE[i] = viewP + viewD * tE[i];\n\t\tnE[i] = normalize(pE[i]/(abc*abc));\n\t\t\n\t\tvec2 uv = vec2(0.0,0.99);\n\t\tif (fragCoord.x > 0.666*iResolution.x)\n\t\t\tuv = ToStereoParameters(abs(pE[i]), abc);\n\t\telse if (fragCoord.x > 0.333*iResolution.x)\n\t\t\tuv = CartToSpherical(abs(pE[i]), abc);\n\t\t\n\t\tcE[i] = vec3(1.) * max(dot(nE[i],L),0.)+.3;\n\t\tcE[i] *= (texture(iChannel0,uv).x > 0.5 ? 1. : 0.);\n\t}\n\t\n\tvec3 c=floor_c;\n#if 0 //bottom half of ellipsoid, kind of confusing to look at\n\tfor (int i=1; i>=0; i--)\n\t{\n\t\tif (tE[i] > 0. && tE[i] > floor_intersect_t)\n\t\t\tc = mix(c, cE[i], 0.95);\t\t\n\t}\n\tc = mix(c,floor_c,0.65);\n#endif\t\t\n\tfor (int i=1; i>=0; i--)\n\t{\n\t\tif (pE[i].z > 0.) //cut away front half to see inside\n\t\tif (tE[i]>0.)\n\t\t{\n\t\t\tif (tE[i]< floor_intersect_t)\n\t\t\t\tc = mix(c, cE[i], 0.75);\n\t\t}\t\n\t}\n\t\n\tc=pow(c,vec3(1./2.2));\n\tfragColor = vec4(c,1.0);\n}\n\nfloat DistanceToEllipsoidEberly(vec3 p, vec3 abc)\n{\n\t//This just seems really busted, not sure what I'm missing here: \n\t//http://www.geometrictools.com/Documentation/DistancePointEllipseEllipsoid.pdf\n\t//I guess this is why it's always good to publish source to recreate methods like this!!!\n\t\n\t//doesn't like negative scales & result is the same by symmetry!\n\tabc = abs(abc);\n\tp = abs(p);\n\t\n\tfloat a = abc.x;\n\tfloat b = abc.y;\n\tfloat c = abc.z;\n\n\t//inside or outside ?\n\tvec3 p_over_abc = p/abc;\n\tfloat inouttest = dot(p_over_abc,p_over_abc);\n\tfloat t = inouttest < 1. ? 0. : max(a,max(b,c))*length(p);\n\n\tfloat aa = a*a;\n\tfloat bb = b*b;\n\tfloat cc = c*c;\n\n\tfloat uu = p.x*p.x;\n\tfloat vv = p.y*p.y;\n\tfloat wW = p.z*p.z;\n\n\tfor (int i=0; i<30; i++)\t//loads of iterations required!\n\t{\n\t\tfloat tasq = (t+aa);\n\t\ttasq *= tasq;\n\n\t\tfloat tbsq = (t+bb);\n\t\ttbsq *= tbsq;\n\n\t\tfloat tcsq = (t+cc);\n\t\ttcsq *= tcsq;\n\t\t\n\t\tfloat Ft = tasq*tbsq*tcsq - aa*uu*tbsq*tcsq - bb*vv*tasq*tcsq - cc*wW*tasq*tbsq;\n\n\t\tfloat aat = aa+t;\n\t\tfloat aatsq = aat * aat;\n\n\t\tfloat bbt = bb+t;\n\t\tfloat bbtsq = bbt * bbt;\n\n\t\tfloat cct = cc+t;\n\t\tfloat cctsq = cct * cct;\n\n\t\tfloat dFt =\n\t\t\t//2 (a^2 + t)^2 (b^2 + t)^2 (c^2 + t) + \n\t\t\t2.0 * aatsq * bbtsq * cctsq + \n\t\t\t//2 (a^2 + t)^2 (b^2 + t)   (c^2 + t)^2 + \n\t\t\t2.0 * aatsq * bbt * cctsq + \n\t\t\t//2 (a^2 + t)   (b^2 + t)^2   (c^2 + t)^2 - \n\t\t\t2.0 * aat * bbtsq * cctsq - \n\t\t\t//2 a^2 (b^2 + t)^2\t(c^2 + t) u^2 - 2 a^2 (b^2 + t) (c^2 + t)^2 u^2 - \n\t\t\t2.0 * aa * bbtsq * cct * uu - 2.0 * aa * bbt * cctsq * uu - \n\t\t\t//2 b^2 (a^2 + t)\t(c^2 + t) v^2 -   b^2 (c^2 + t)^2 v^2 - \n\t\t\t2.0 * bb * aat * cct * vv - bb * cctsq * vv - \n\t\t\t//2 c^2 (a^2 + t)^2\t(b^2 + t) w^2 - 2 c^2 (a^2 + t) (b^2 + t)^2 w^2\n\t\t\t2.0 * cc * aatsq * bbt * wW - 2.0 * cc * aat * bbtsq * wW;\n\t\t\n\t\tt = t - Ft/dFt;\n\t}\n\n\tvec3 abcsq = abc * abc;\n\tvec3 closest = abcsq * p / (abcsq + t);\n\tfloat dist = length(closest-p);\n\treturn inouttest < 1. ? dist : -dist;\n}\n\nvec2 CartToSpherical(vec3 p, vec3 abc)\n{\n\treturn vec2( atan( abc.x*p.y, abc.y*p.x ), atan( p.z, abc.z*length(p.xy/abc.xy)) );\n}\n\nvec2 IterateNurnberg(vec2 x, vec3 p, vec3 abc);\n\nfloat DistanceToEllipsoidNurnberg(vec3 p, vec3 abc)\n{\t\n\t//A 2D Newton's method, on spherical coordinates!\n\t//Unfortunately the initial guess often gives a divide by zero in the first step \n\t//and kaboom goes the solution.\n\t//Also, the parameterization has a strong pinch point at the poles\n\t//which gives additional weird effects.\t\n\t//http://www2.imperial.ac.uk/~rn/distance2ellipse.pdf\n\t//\"the iteration always converges in practice, usually taking only a couple of iterations to converge\"\n\t//Fraid not, my friend!!!\n\t//Still, the 2D Newton's method is interesting.\n\t\n\t//doesn't like negative scales & result is the same by symmetry!\n\tabc = abs(abc);\n\tp = abs(p);\n\n\t//inside or outside ?\n\tvec3 inouttest = p/abc;\n\n\tvec3 guess_p = p;\n\n\tfloat a = abc.x;\n\tfloat b = abc.y;\n\tfloat c = abc.z;\n\t\n\t//just the same as normalize(p/abc)*abc but in spherical coordinates ! weird vag shaped distortions \n\tvec2 initial_guess = vec2( atan( a*guess_p.y, b*guess_p.x ), atan( guess_p.z, c*length(guess_p.xy/abc.xy)) );\n\tvec2 x = initial_guess;\n\n\t//amazingly, Firefox seems to think it is OK to optimize away this code if written as a looop! :(\n\tx = IterateNurnberg(x, p, abc);\n\tx = IterateNurnberg(x, p, abc);\n\tx = IterateNurnberg(x, p, abc);\n\tx = IterateNurnberg(x, p, abc);\n\tx = IterateNurnberg(x, p, abc);\n\t\n\n\tfloat cx = cos(x.x);\n\tfloat cy = cos(x.y);\n\tfloat sx = sin(x.x);\n\tfloat sy = sin(x.y);\n\n\t//back to cartesian\n\tvec3 closest = vec3( a*cy*cx,  b*cy*sx, c*sy );\n\n\tfloat dist = length(closest - p);\n\n\treturn  dot(inouttest,inouttest) < 1.0 ? dist : -dist;\n}\n\t\nvec2 IterateNurnberg(vec2 x, vec3 p, vec3 abc)\n{\n\tfloat a = abc.x;\n\tfloat b = abc.y;\n\tfloat c = abc.z;\n\t\n\tfloat aa_bb = (a*a-b*b);\n\t\n\t//for (int i=0; i<5; i++)\n\t{\t\n\t\t//crank newton's method in spherical coordinates\n\t\tfloat u = x.x;\n\t\tfloat v = x.y;\n\n\t\tfloat cu = cos(u);\n\t\tfloat cv = cos(v);\n\t\tfloat su = sin(u);\n\t\tfloat sv = sin(v);\n\t\n\t\tfloat F=aa_bb*cu*su*cv - p.x*a*su + p.y*b*cu;\n\t\tfloat G=(a*a*cu*cu + b*b*su*su - c*c)*sv*cv - p.x*a*sv*cu - p.y*b*sv*su + p.z*c*cv;\n\t\n\t\tfloat A = aa_bb*(cu*cu-su*su)*cv - p.x*a*cu - p.y*b*su;\n\t\tfloat B = -aa_bb*cu*su*sv;\n\t\tfloat C = -2.0 * aa_bb*cu*su*sv*cv + p.x*a*sv*su - p.y*b*sv*cu;\n\t\tfloat D = (a*a*cu*cu + b*b*su*su - c*c) * (cv*cv - sv*sv) - p.x*a*cv*cu - p.y*b*cv*su - p.z*c*sv;\n\t\t\n\t\tfloat denom = (A*D-B*C);\n\t\tfloat det = 1./denom;\n\n\t//\tD  -B  mul F\n\t//\t-C  A      G\n\t\t\n\t\tx -=  det * vec2( D*F-B*G, A*G-C*F );\n\t}\t\n\t\n\treturn x;\n}\n\n\n//A different parameterization of the ellipsoid is the so-called stereographic ellipsoid\n//http://mathworld.wolfram.com/Ellipsoid.html\nvec2 ToStereoParameters(vec3 cart, vec3 abc)\n{\n\treturn (abc.x * cart.yz) / (abc.yz * (cart.x+abc.x));\n}\n\nvec3 StereoParametersToCart(vec2 uv, vec3 abc)\n{\n\tfloat d = dot(uv,uv);\n\tfloat ood = 1./(1.+d);\n\treturn vec3(1.-d,2.*uv)*ood*abc;\n}\n\nfloat FixSign(float x, float t)\n{\n\treturn x > 0. ? t : -t;\n}\n\nfloat QuadraticPositive(float Q_a, float Q_b, float Q_c)\n{\n\tfloat disc = Q_b*Q_b-(4.*Q_a*Q_c);\n\tif (disc > 0. && abs(Q_a) > 0.0001)\n\t{\n\t\tfloat sqrt_disc = sqrt(disc);\n\t\tfloat t=(-Q_b+sqrt_disc)/(2.*Q_a);\n\t\tfloat s=(-Q_b-sqrt_disc)/(2.*Q_a);\n\n\t\t//smaller of these will be nearer the query point for the same ray.\n\t\treturn abs(t) < abs(s) ? t : s;\n\t}\n\n\t//somebody else will have a nearer point and this will be rejected!\n\treturn 1e10;\n}\n\nvec3 GuessXY(vec3 p, vec3 abc)\n{\n\t//find the nearest of the intersections in the XY XZ and YZ directions\n\tfloat a = abc.x;\n\tfloat b = abc.y;\n\tfloat c = abc.z;\n\n\tfloat x = p.x;\n\tfloat y = p.y;\n\tfloat z = p.z;\n\t\n\tfloat aa = a*a;\n\tfloat bb = b*b;\n\tfloat cc = c*c;\n\n\tfloat x_sq = x*x;\n\tfloat y_sq = y*y;\n\tfloat z_sq = z*z;\n\n//XY\tt^2*(aa+bb) + t*2*(x*bb+y*aa) + aa*y_sq+bb*x_sq-(aa*bb*1)+aa*bb*z_sq/cc\n\tfloat t_xy = QuadraticPositive(aa+bb, 2.*(x*bb+y*aa), aa*y_sq+bb*x_sq-(aa*bb)+aa*bb*z_sq/cc);\n//XZ\tt^2*(aa+cc) + t*2*(z*aa+x*cc) + aa*cc*(y_sq/bb)+aa*z_sq+cc*x_sq-(aa*cc)\n\tfloat t_xz = QuadraticPositive(aa+cc,2.*(z*aa+x*cc),aa*cc*(y_sq/bb)+aa*z_sq+cc*x_sq-(aa*cc));\n//YZ    t^2*(cc+bb) + t*2*(y*cc+z*bb) + (cc*y_sq+bb*z_sq+bb*cc*x_sq/aa-(bb*cc))\n\tfloat t_yz = QuadraticPositive(cc+bb,2.*(y*cc+z*bb),(cc*y_sq+bb*z_sq+bb*cc*x_sq/aa-(bb*cc)));\n\n\tif (abs(t_xy) < abs(t_xz) && abs(t_xy) < abs(t_yz))\n\t{\n\t\treturn vec3(x+t_xy,y+t_xy,z);\n\t}\n\telse if (abs(t_xz) < abs(t_xy) && abs(t_xz) < abs(t_yz))\n\t{\n\t\treturn vec3(x+t_xz,y,z+t_xz);\n\t}\n\n\treturn vec3(x,y+t_yz,z+t_yz);\n}\n\nvec3 NearerOfTo(vec3 M, vec3 S, vec3 p)\n{\n\t//return which of M and S is nearest to P\n\tvec3 Sp = S-p;\n\tvec3 Mp = M-p;\n\t\n\tif (dot(Sp,Sp) < dot(Mp,Mp))\n\t\treturn S;\n\t\t\n\treturn M;\n}\n\t\nvec3 InitialGuessClosestPointToEllipsoid(vec3 p, vec3 abc)\n{\n\tfloat a = abc.x;\n\tfloat b = abc.y;\n\tfloat c = abc.z;\n\n\tfloat x = p.x;\n\tfloat y = p.y;\n\tfloat z = p.z;\n\n\tvec3 n = p/abc;\n\tvec3 nsq = n*n;\n\tfloat x_over_a_sq = nsq.x;\n\tfloat y_over_b_sq = nsq.y;\n\tfloat z_over_c_sq = nsq.z;\n\n\tconst float inf = 1e10;\n\n\t//find intercepts with the ellipse in 3 principle directions from query point\n\tfloat x_term = y_over_b_sq+z_over_c_sq;\n\tfloat y_term = x_over_a_sq+z_over_c_sq;\n\tfloat z_term = x_over_a_sq+y_over_b_sq;\n\n\tfloat N_x=x_term < 1. ? FixSign(x,a*sqrt(1.-x_term)) : inf;\n\tfloat N_y=y_term < 1. ? FixSign(y,b*sqrt(1.-y_term)) : inf;\n\tfloat N_z=z_term < 1. ? FixSign(z,c*sqrt(1.-z_term)) : inf;\n\t\n\tfloat abs_N_x = abs(N_x-x);\n\tfloat abs_N_y = abs(N_y-y);\n\tfloat abs_N_z = abs(N_z-z);\n\n\t//take the nearest of those\n\tvec3 M = vec3(x,y,N_z);\n\tif(abs_N_x<abs_N_y && abs_N_x<abs_N_z)\n\t\tM = vec3(N_x,y,z);\n\telse if(abs_N_y<abs_N_x && abs_N_y<abs_N_z)\n\t\tM = vec3(x,N_y,z);\n\n\t//projection onto a sphere guess:\n\tvec3 S = normalize(p/abc)*abc;\n\n#if 0\n\t//nearest of the two kinds of guess:  ... discontinous, still leaves some problems\n\tvec3 Sp = S-p;\n\tvec3 Mp = M-p;\n\t\n\tif (dot(Sp,Sp) < dot(Mp,Mp))\n\t\treturn S;\n\t\t\n\treturn M;\n#else\n\t\n\t//If we're inside there seems to be an extra bit kind of torus shape and aligned to the principle planes \n\t//where the initial guess still gives a divide by 0 in Newton's method\n\t//Add some more directions to try to get rid of it!\n\t//But still not perfect, so do not use for air traffic control software, please thanks!\n\t//improvements welcomed.\n\tvec3 inouttest = p/abc;\n\tif (dot(inouttest,inouttest) < 1.)\n\t{\n\t\tM = NearerOfTo(M,S,p);\n\t\t\n\t\tvec3 gXY = GuessXY(p, abc);\n\t\tM = NearerOfTo(M, gXY, p);\n\n//\t\tt^2*(bb*cc+aa*cc+aa*bb)+t*(2*x*bb*cc+2*y*aa*cc+2*z*aa*bb)+bb*cc*x_sq+aa*cc*y_sq+aa*bb*z_sq-(aa*bb*cc)\n\t\tfloat aa = a*a;\n\t\tfloat bb = b*b;\n\t\tfloat cc = c*c;\n\n\t\tfloat x_sq = x*x;\n\t\tfloat y_sq = y*y;\n\t\tfloat z_sq = z*z;\n\n\t\tfloat t_xyz = QuadraticPositive(bb*cc+aa*cc+aa*bb, 2.*x*bb*cc+2.*y*aa*cc+2.*z*aa*bb, bb*cc*x_sq+aa*cc*y_sq+aa*bb*z_sq-(aa*bb*cc));\n\t\tM = NearerOfTo(M, vec3(p)+vec3(t_xyz,t_xyz,t_xyz), p);\n\t}\n\telse\n\t{\n\t\tM = S;\t\n\t}\n\treturn M;\n#endif\n}\n\nvec2 IterateStereo(vec2 uv, vec3 p, vec3 abc);\n\nfloat DistanceToEllipsoidStereo(vec3 p, vec3 abc)\n{\t\n\t//2D Newton's method again, this time with different parameterization and better initial guess\n\t\n\t//doesn't like negative scales & result is the same by symmetry!\n\tabc = abs(abc);\n\n\tp = abs(p);\n\n\t//inside or outside ?\n\tvec3 inouttest = p/abc;\n\n\t\n#ifdef CONFOCAL\t\t\t\n\tvec3 guess_p = ConfocalGuess(p, abc);\n#else\n\tvec3 guess_p = InitialGuessClosestPointToEllipsoid(p, abc);\t\n#endif\n\t\n\tvec2 initial_guess = ToStereoParameters(guess_p, abc);\n\n\tvec2 uv = initial_guess;\n\n\t//amazingly, Firefox seems to think it is OK to optimize away this code if written as a looop! :(\t\n\tuv = IterateStereo(uv,p,abc);\n\tuv = IterateStereo(uv,p,abc);\n\tuv = IterateStereo(uv,p,abc);\n\tuv = IterateStereo(uv,p,abc);\n\tuv = IterateStereo(uv,p,abc);\n\t\n\tvec3 closest = StereoParametersToCart(uv, abc);\n\n\tfloat dist = length(closest - p);\n\n\treturn  dot(inouttest,inouttest) < 1. ? dist : -dist;\n}\n\n\nvec2 IterateStereo(vec2 uv, vec3 p, vec3 abc)\n{\n\tfloat a = abc.x;\n\tfloat b = abc.y;\n\tfloat c = abc.z;\n\t\n\tfloat x = p.x;\n\tfloat y = p.y;\n\tfloat z = p.z;\n\tfloat a_2 = a*a;\n//\tfor (int i=0; i<5; i++)\n\t{\n\t\tfloat u = uv.x;\n\t\tfloat u_2 = u*u;\n\t\tfloat v = uv.y;\n\t\tfloat v_2 = v*v;\n\n\t\tfloat U=1.+u_2+v_2;\n\t\tfloat ooU = 1. / U;\n\t\tfloat U_2 = U*U;\n\t\tfloat ooU_2 = 1. / U_2;\n\n\t\t//partial derivatives via computer algebra system, not very simplified...\n\t\t\n\t\tfloat t0 = (-16.)*u*v*a_2*ooU_2; \n\t\tfloat t1 = -x-a+2.*a*ooU;\n\t\tfloat t2 = y-2.*b*u*ooU;\n\t\tfloat t3 = 4.*c*u*v;\n\t\tfloat t4 = 4.*b*u*v;\n\t\tfloat t5 = z-2.*c*v*ooU;\n\t\tfloat t6 = -x-a+2.*a*ooU;\n\t\tfloat t7 = 2.*U*c-(4.*c*v_2);\n\t\tfloat t8 = (v_2-u_2+1.)*ooU_2;\t\t\t\n\t\tfloat t9 = (u_2-v_2+1.)*ooU_2;\n\t\t\n\t\tfloat F= 4.*a*u*t1+t2*b*(2.*U-(4.*u_2))-(t3*t5);\n\t\tfloat G= 4.*a*v*t1-t4*t2+t5*2.*c*(U-(2.*v_2));\n\n\t\tfloat A=4.*a*(-4.*a*u_2*ooU_2+t6)+2.*b*(-(2.*u*t2)-(2.*U*b-(4.*b*u_2))*t8)-(4.*c*(4.*c*u_2*v_2*ooU_2+v*t5));\n\t\tfloat B=t0+2.*b*(2.*v*t2+t4*t8)-(4.*c*u*((-v)*t7*ooU_2+t5));\n\t\tfloat C=t0-(4.*b*((-u)*v*(2.*U*b-(4.*b*u_2))*ooU_2+v*t2))+2.*c*(2.*u*t5+t3*t9);\n\t\tfloat D=-(4.*a*(4.*a*v_2*ooU_2-t6))-(4.*b*u*(4.*b*u*v_2*ooU_2+y-2.*b*u*ooU))+2.*c*(-(2.*v*t5)-t7*t9);\n\t\t\n\t\tfloat denom = (A*D-B*C); \n\t\tfloat det = 1./denom;\t \n\n\t//\tD  -B  mul F\n\t//\t-C  A      G\n\t\t\n\t\tuv -=  det * vec2( D*F-B*G, A*G-C*F );\n\t}\t\n\t\n\treturn uv;\n}\n\n\nvec3 RotY(vec3 p, float t) {\n\tfloat c = cos(t); float s = sin(t);\n\treturn vec3(p.x*c+p.z*s,\n\t\t\t\tp.y,\n\t\t\t\t-p.x*s+p.z*c);\n}\n\nvoid MakeViewRay(out vec3 eye, out vec3 ray, in vec2 fragCoord)\n{\n\tvec2 ooR = 1./iResolution.xy;\n    vec2 q = fragCoord.xy * ooR;\n\tq.x = mod(q.x*3.,1.);\t//tile it for split views!\n\tq.y = mod(q.y*2.,1.);\t//tile it for split views!\n    vec2 p =  2.*q -1.;\n    p.x *= iResolution.x * ooR.y;\n\t\n    vec3 lookAt = vec3(0.,0.,0.);\n\tfloat t = sin(iTime*.5)*.5;\n\teye = vec3(-2.5,5.,-2.5) * (t+2.);\n\teye = RotY(eye,smoothstep(0.,1.,t)*-0.5*pi);\t\n\t\n    // camera frame\n    vec3 fo = normalize(lookAt-eye);\n    vec3 ri = normalize(vec3(fo.z, 0., -fo.x ));\n    vec3 up = normalize(cross(fo,ri));\n     \n    float fov = .25;\n\t\n    ray = normalize(fo + fov*p.x*ri + fov*p.y*up);\n}\n\nvec2 Q(float a, float b, float c)\n{\n\tfloat d = b*b-4.0*a*c;\n\tif (d < 0.0) return vec2(-1.,-1.);\n\td=sqrt(d);\t\n\tfloat oo2a = 0.5/a;\n\tvec2 i = vec2(-b-d,-b+d)*oo2a;\n\treturn vec2( min(i.x,i.y), max(i.x,i.y) );\n}\n\nvec2 RayEllipsoid(vec3 P, vec3 V, vec3 A)\n{\n\tA*=A;\n\tvec3 VP = V*P;\n\tP *= P;\n\tV *= V;\n\t\n\tvec3 S=A.yzx*A.zxy;\n\t\t\n\tfloat a = dot(V,S);\n\tfloat b = 2. * dot(VP,S);\n\tfloat c = dot(P,S) - A.x*A.y*A.z;\n\t\t\t\t\n\treturn Q(a,b,c);\n}\n\n//http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat Bisect(vec3 cubic, float a, float b )\n{\n\tfloat fa = -a*a*a + a*a*cubic.x + a*cubic.y + cubic.z;\n\n\tfloat p = a+(b-a)*0.5;\n\n\tfor (int n=0; n<8; n++)\n\t{\n\t\tfloat fp = -p*p*p + p*p*cubic.x + p*cubic.y + cubic.z;\n\t\tif (fa*fp > 0.)\n\t\t{\n\t\t\ta=p;\n\t\t\tfa = fp;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tb = p;\n\t\t}\n\n\t\tp = a+(b-a)*0.5;\n\t}\n\n\treturn p;\n}\n\n//b^2*c^2*x^2+a^2*c^2*y^2+a^2*b^2*z^2-(a^2*b^2*c^2)\n//+T*(c^2*x^2+b^2*x^2+a^2*y^2+a^2*z^2+b^2*z^2-(a^2*b^2)-(b^2*c^2)-(a^2*c^2)+c^2*y^2)\n//+T^2*(y^2+x^2+z^2-a^2-b^2-c^2)\n//-T^3=0\n\nvec3 ConfocalGuess(vec3 p, vec3 abc)\n{\n\tfloat x=p.x; \tfloat y=p.y; \tfloat z=p.y;\n\tfloat x_2=x*x;\tfloat y_2=y*y;\tfloat z_2=z*z;\n\tfloat a=abc.x;\tfloat b=abc.y; \tfloat c=abc.z;\n\tfloat a_2=a*a;\tfloat b_2=b*b; \tfloat c_2=c*c;\t\n\t\n\tfloat cubic_a0 = b_2*c_2*x_2+a_2*c_2*y_2+a_2*b_2*z_2-(a_2*b_2*c_2);\n\tfloat cubic_a1 = c_2*x_2+b_2*x_2+a_2*y_2+a_2*z_2+b_2*z_2-(a_2*b_2)-(b_2*c_2)-(a_2*c_2)+c_2*y_2;\n\tfloat cubic_a2 = y_2+x_2+z_2-a_2-b_2-c_2;\n\n\tvec3 cubic = vec3(cubic_a2,cubic_a1,cubic_a0);\t\n\tfloat t0 = Bisect(cubic, -a_2, -b_2 );\n\tfloat t1 = Bisect(cubic, -b_2, -c_2 );\n\tfloat t2 = 0.;\n\t\n\tvec3 abc2=abc*abc;\n\tvec3 baa2=abc2.yxx;\n\tvec3 ccb2=abc2.zzy;\n\tvec3 q2=((abc2+t2)*(abc2+t1)*(abc2+t0))/((baa2-abc2)*(ccb2-abc2));\n\n\treturn sqrt(abs(q2))*sign(p);\n}\n\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldsGWX","date":"1381618538","viewed":1872,"name":"Ellipsoid solver","username":"Antonalog","description":"A while back I discovered the hard way just how annoying it is to get a true Euclidean distance to an ellipsoid. Various published solvers fail in a lot of places.  Here is more robust method based on the stereo parameterization of an ellipsoid. ","likes":25,"published":1,"flags":0,"usePreview":0,"tags":["distance","ellipsoid","numerical"],"hasliked":0,"parentid":"","parentname":""}}