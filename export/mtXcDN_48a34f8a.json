{"ver":"0.1","info":{"id":"mtXcDN","date":"1690747818","viewed":506,"name":"Stochastic anti aliasing","username":"normaalewoon","description":"This is a rasterizer that samples geometry in a random location inside the pixel, rather than the pixel centers only. This counters all aliasing artefacts in the whole picture without supersampling, blur or reprojection. The more fps, the smoother it is","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["noise","antialiasing","random","rasterization"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Copyright 2023 normaalewoon\n\n//Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n//THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.*/\n\n/*\nStochastic anti aliasing is a way of handling aliasing, besides supersampling,\nreprojection, adding blur or doing nothing. Instead of the pixel centers, a random\nlocation inside the pixel is sampled. This turns jagged edges, moire and\nundersampled subpixel detail into noise, which makes it really good at resolving\ndetail that is smaller than pixels. No anti aliasing simply can't do this. \nShimmering, another effect that results from aliasing, is not reduced in any way. \nIt's rather maxed out in a reasonable way, so you need to be comfortable with it. \nWhat you get back is a razor sharp picture during movement (at least on a slow \nmotion video, more on that later), free from any motion artefacts that result from \nTAA and more advanced methods like DLSS, FSR and TSR. Those are either blurry or \nsmeary during movement, even at 100% render resolution. Temporal stability does \nnot come without compromises\n\nTAA without accumulation isn't perfect either. Uniform jitter is visible as screen \nshaking without any further action, because everything moves as a whole. These\nactions give some blur and even ghosting sometimes and even then, cannot completely\nremove the shaking everywhere. It's not nearly as bad as accumulation artefacts, \nbut still a bit annoying. The jitter pattern can also line up differently during \ncertain camera movements and form jagged edges when the offset is not random enough, \nwhich happens with TAA as well. Random jitter per pixel solves all of these issues\n\nThe perfect place for stochastic anti aliasing is, of course, inside the \nrasterization. This is not really an option though, since the rasterization is \nhardcoded inside API's. Even if possible, it may be too expensive to generate or \nload a random number for every pixel on every polygon, inside the whole\ncircumferencing rectangle of pixels. This does not put SAA off the table. It still\nworks fine in pixel shaders, which cover nearly the whole screen area even in \nmodern games. Even if it does not work on mesh edges, it works on opacity masks,\nspecular highlights, normals and albedo. That makes it complementary to MSAA, which\nonly works on mesh edges\n\nMost game engines support derivatives DDX and DDY, which you can use to lookup the\nvalue of something in the pixel above or to the right. You can do this with the \nworld position, texture coordinates, vertex normals and colors (require a vertex \ninterpolator to calculate the pixel value) and anything else for which the pixel \nvalue is known. If you blend between this value and the value of the current pixel \n(randomly with an alpha between -0.5 and 0.5), you can get random sample \ncoordinates for textures or something else\n\nShimmering with SAA can be reduced with higher render resolutions, lower detail/\ncontrast and more frames per second. I personally don't like TAA, but if you want \nto combine it with SAA, make sure that the uniform jitter from the TAA is disabled\n\nAccumulation is not the only cause of motion blur. Your monitor is probably causing\nmuch more of it. That's because you see at least as much motion blur as your eye \nmovement during the time that the frame is visible, because your eye moves while \nthe picture doesn't. This makes eye tracking blurry, even without anti aliasing. \nDid you ever notice that movement looks different than stills? It's not only due to \nresponse times, because it even happens on oled (phone) screens. It's rather due to \nthe frametime itself! The only thing you can do to counter this is reducing the \nframe visibility time with a crt, backlight strobing or black frame insertion. \nSample and hold motion blur is probably the biggest reason why accumulation has \ngotten so popular. It is so relaxing on stills after the blurry crap during motion, \nwhile the accumulation artefacts are perfectly hidden by the sample and hold motion \nblur. Don't fool yourself please\n*/\n\n#define movespeed 1. //change the speed of the moving vertex. Use a number with a . directly behind it, then compile\n\nfloat pixelsize = 1.;\n\nfloat pixelsize2 = 8.;\n\nfloat randomstrength = 1.; //0. = off, 1. = physically correct, 0.5 = balanced (more sharpness, less noise with only a little bit of aliasing on dense detail), > 1. = blur\n\n//random number generator, not using dot product for more flexibility\nfloat randomize(float cf) { \n\n    float t = (fract(sin(cf+1.320854)*857.748583));\n    \n    return t;\n\n}\n\nfloat random(vec2 cx, float time) {\n\n    float t = randomize(cx.x+randomize(cx.x)+randomize(cx.y+randomize(cx.y)+randomize(time)));\n\n    return t;\n\n}\n\nvec3 vertex1 = vec3(.65,.8,0.);\n\nvec3 vertex2 = vec3(.1,.8,0.);\n\nvec3 vertex3 = vec3(.4,.1,0.);\n\n\n//rasterizer functions, one per edge\n\nfloat edgeside1(vec2 uvs, vec3 aspect) {\n  \n    vec3 determine = cross(vec3(uvs,0)-vertex1*aspect, vertex2*aspect-vertex1*aspect);\n\n    return determine.z;\n\n}\n\nfloat edgeside2(vec2 uvs, vec3 aspect) {\n\n    vec3 determine = cross(vec3(uvs,0)-vertex2*aspect, vertex3*aspect-vertex2*aspect);\n\n    return determine.z;\n\n}\n\nfloat edgeside3(vec2 uvs, vec3 aspect) {\n\n    vec3 determine = cross(vec3(uvs,0)-vertex3*aspect, vertex1*aspect-vertex3*aspect);\n\n    return determine.z;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n\n{\n\n    vec2 uv = fragCoord/iResolution.y;\n  \n    //correction for different aspect ratios\n    vec3 aspect = vec3(iResolution.x/iResolution.y/16.*9.,1.,1.);\n    \n    //left and right picture\n    if(uv.x > .9*aspect.x){pixelsize = pixelsize2; uv.x -= .9*aspect.x;}\n\n    float pixels = iResolution.y/pixelsize;\n\n    vec2 uvgrid = uv*pixels;\n\n    uvgrid = floor(uvgrid);\n\n    vec2 offset = vec2(random(uvgrid/pixels, iTime+.682), random(uvgrid/pixels, iTime));\n\n    offset -= .5;\n    \n    //disable in order to remove jagged edge comparison\n    randomstrength *= sign(1.-fract(iTime/45.)-.3)/2.+.5;\n\n    offset *= randomstrength;\n\n    uvgrid += offset;\n    \n\n    uvgrid /= pixels;\n    \n    \n    //make vertex move\n    vertex1 += vec3(sin(iTime*movespeed)/10.*(sin(iTime/3.1+3.)+1.),cos(iTime*movespeed)/12.*(sin(iTime/3.1+3.)+1.),0);\n\n    float isinside = max(edgeside1(uvgrid, aspect),max(edgeside2(uvgrid, aspect),edgeside3(uvgrid, aspect)));\n\n    isinside = sign(-isinside);\n\n    vec3 col = vec3(isinside);\n\n    fragColor = vec4(col,1.0);\n\n}","name":"Image","description":"","type":"image"}]}