{"ver":"0.1","info":{"id":"DddXzf","date":"1680194507","viewed":128,"name":"Stereolux Workshop - 3D","username":"Flopine","description":"Shadercoding workshop for Stereolux","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["3d","raymarching","teaching","workshop"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv =  fragCoord/iResolution.xy;\n    vec2 centered_uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    // chromatic aberation\n    float red = texture(iChannel0, uv*0.95 + length(centered_uv)*0.013).r;\n    float green = texture(iChannel0, uv*0.95 + length(centered_uv)*0.018).g;\n    float blue = texture(iChannel0, uv*0.95 + length(centered_uv)*0.015).b;\n    \n    fragColor = vec4(red, green, blue, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","previewfilepath":"/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// REFS\n// For object distance functions\n// https://iquilezles.org/articles/distfunctions/\n\n// For union and space manipulations\n// https://mercury.sexy/hg_sdf/\n\n// For tight domain repetition without discontinuity\n// https://www.youtube.com/watch?v=I8fmkLK1OKg\n\n\n// sample FFT of sound (thanks to the 0.25 in the vec2)\n#define boumboum texture(iChannel0, vec2(0.15, 0.25)).x\n\n// rotation matrice\nmat2 rotation (float angle)\n{\n    return mat2( cos(angle), sin(angle), -sin(angle), cos(angle) );\n}\n\nfloat sphere (vec3 position)\n{ return length(position) - (.5+boumboum); }\n\nfloat cube (vec3 position, vec3 corner)\n{\n    vec3 q = abs(position)-corner;\n    return min( 0.0, max( q.x, max(q.y,q.z) ) ) + length(max(q, 0.)) ;\n}\n\n// Signed Distance Field\nfloat SDF (vec3 position)\n{\n    // translate space\n    position.z += iTime;\n    // rotate space\n    position.xy *= rotation( sin(position.z*0.2 + iTime) );\n    \n    float period = 3.0;\n    // domain repetition\n    position = mod(position, period)-period*0.5;\n    \n    // union operation\n    return min(sphere(position), cube(position, vec3(0.25+boumboum))) ;\n    \n    // intersection operation\n    //return max(sphere(position), cube(position, vec3(0.25+boumboum))) ;\n    // subtraction operation\n    //return max(-sphere(position), cube(position, vec3(0.25+boumboum))) ;\n}\n\nvec3 get_normals (vec3 position)\n{\n    vec2 eps = vec2(0.01, 0.0);\n    return normalize( SDF(position) -  vec3(SDF(position-eps.xyy),\n                                            SDF(position-eps.yxy),\n                                            SDF(position-eps.yyx)) \n                    );\n}\n\nfloat specular (vec3 rd, vec3 L, vec3 n)\n{\n    // half vector\n    vec3 h = normalize(L - rd);\n    float dotNH = dot(n, h);\n    // spreading of specular \n    float rough = 20.;\n    float spec = pow(max(dotNH, 0.), rough);\n    \n    return spec;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    vec3 ray_origin = vec3(0.0, 0.0, -3.0);\n    vec3 ray_direction = normalize(vec3(uv, 1.0));\n    // position that will be incremented with the raymarching\n    vec3 p = ray_origin;\n    vec3 color = vec3(0.);\n    vec3 dir_light = vec3(1.0, 1.0, -1.0);\n\n    bool hit = false;\n    float iteration_shade;\n    float t=0.;\n    \n    for(float i=0.0; i<60.0; i++)\n    {\n        p = ray_origin + t*ray_direction;\n        // distance to the scene\n        float d = SDF(p);\n        // if we hit something\n        if(d < 0.001)\n        {\n            hit = true;\n            // calculate normalized iteration for quick shading\n            iteration_shade = i/60.0;\n            break;\n        }\n        // march slower\n        t += d*.7;\n    }\n\n    if(hit)\n    {\n        vec3 n = get_normals(p);\n        \n        float lighting = max(dot( n, normalize(dir_light) ), 0.);\n        // add a fake second lighting bounce\n        //float lighting = dot( n, normalize(dir_light)) * 0.5 + 0.5;\n        \n        // toon shading\n        float color_mix_cursor = floor(lighting * 4.0) / 4.0;\n        color = mix(vec3(0.03), vec3(1.0), color_mix_cursor);\n        color += step(0.7, specular(ray_direction, normalize(dir_light), n));\n    }\n\n    // Output to screen\n    fragColor = vec4( sqrt(color), 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}