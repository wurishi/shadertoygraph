{"ver":"0.1","info":{"id":"3sGGDR","date":"1569960064","viewed":102,"name":"2_beadando","username":"Akszipukszis","description":"ok","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["ok"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float pdist=texelFetch(iChannel0,ivec2(fragCoord),0).w;\n        \n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0)*2.0;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// This file contains the \n// --- MEK ---\n\nstruct Ray\n{\n\tvec3 P;\n\tfloat Tmin;\n\tvec3 V;\n\tfloat Tmax;\n};\n\nstruct TraceResult\n{\n    float T;\t\t// Distance taken on ray\n    int flags;\t\t// bit 0:   distance condition:     true if travelled to far t > t_max\n                    // bit 1:   surface condition:      true if distance to surface is small < error threshold\n};                  // bit 2:   iteration condition:    true if took too many iterations\n\nstruct mResult\n{\n    float T;\t\t// Distance taken on ray\n    float m;\n    int flags;\t\t// bit 0:   distance condition:     true if travelled to far t > t_max\n                    // bit 1:   surface condition:      true if distance to surface is small < error threshold\n};                  // bit 2:   iteration condition:    true if took too many iterations\n    \n    \nstruct SphereTraceDesc\n{\n    float epsilon;  //Stopping distance to surface\n    int maxiters;   //Maximum iteration count\n};\n\nTraceResult sphere_trace(in Ray ray, in SphereTraceDesc params)\n{\n    TraceResult ret = TraceResult(ray.Tmin, 0);\n    float d;\n    \n    int i = 0; do\n    {\n        d = sdf(ray.P+ret.T*ray.V);\n        ret.T+=d;\n        ++i;\n    } while (\n\t\tret.T < ray.Tmax &&       \t\t\t// Stay within bound box\n\t\td\t  > params.epsilon * ret.T &&\t// Stop if cone is close to surface\n\t\ti     < params.maxiters\t        \t// Stop if too many iterations\n\t);\n    \n    ret.flags =  int(ret.T >= ray.Tmax)\n              | (int(d <= params.epsilon* ret.T)  << 1)\n              | (int(i >= params.maxiters) << 2);\n    return ret;\n}\n\nfloat distance_function_approximation(in float df, in float t, in float r0, in float tanAlpha)\n{\n    return (df - r0 - t*tanAlpha)/(1.0 + abs(tanAlpha));\n}\n\nTraceResult cone_trace_good(in Ray ray, in SphereTraceDesc params, float r0, float tanAlpha)\n{\n    TraceResult ret = TraceResult(ray.Tmin,0);\n    float d;\n    float dd;\n    \n    int i = 0; \n    do\n    {\n        d = sdf(ray.P+ret.T*ray.V);\n        dd = distance_function_approximation(d, ret.T, r0, tanAlpha);\n        ret.T += dd;\n        ++i;\n    } while (\n        ret.T < ray.Tmax && \n\t\tdd     >  params.epsilon* ret.T &&\n\t\ti     < params.maxiters\t        \t// Stop if too many iterations\n\t);\n    \n    ret.flags =  int(ret.T >= ray.Tmax)\n        \t  | (int(dd <= params.epsilon* ret.T) << 1)\n              | (int(i >= params.maxiters) << 2);\n    return ret;\n}\n\nvec3 quadratic_equation_solver(const in vec3 p0, const in vec3 v0, const in vec3 c0, const in float r)\n{\n    //return value:   1) number of solutions\n    //\t\t\t\t  2) first solution\n    //                3) second solution\n\tfloat a = 1.0;\n    float b = 2.0*dot(v0, p0 - c0);\n    float c = dot(p0 - c0, p0 - c0) - r*r;\n    float D = b*b - 4.0*a*c;\n    if (D < 0.0)\n    {\n        return vec3(0., 0., 0.);\n    }\n    else if (D == 0.0)\n    {\n        float sol = -b/(2.*a);\n        return vec3(1.0,sol,0.);\n    }\n    else\n    {\n        float sol1 = (-b+pow(D, 1./2.))/(2.*a);\n        float sol2 = (-b-pow(D, 1./2.))/(2.*a);\n        return vec3(2.,sol1,sol2);\n    }\n}\n\nfloat min_positive_solution(const in vec3 p0, const in vec3 v0, const in vec3 c0, const in float r)\n{\n\tvec3 solution = quadratic_equation_solver(p0, v0, c0, r);\n    if (solution.x == 0.0)\n    {\n    \treturn -1.0;\n    }\n    if (solution.x == 1.0)\n    {\n    \treturn solution.y;\n    }\n    if (solution.x == 2.0)\n    {\n    \tif (solution.y > 0.0)\n        {\n        \tif (solution.z > 0.0)\n            {\n            \treturn (min(solution.y, solution.z));\n            }\n            else\n            {\n            \treturn solution.y;\n            }\n        }\n        else\n        {\n\n            return solution.z;\n        }\n            \n    }\n}\n\nmResult mek(in Ray ray, in SphereTraceDesc params, const in float R, const in vec3 c, float r0)\n{\n    mResult mresult = mResult(0.0, 0.0, 0);\n    if (length(c-ray.P) > R)\n    {\n        float m = 1.0; \n        int i = 0;\n        float T = length(ray.P-c);\n        float r = r0;\n        float tanAlpha = tan(asin(R/(T)));\n        float tanAlpha0 = tan(asin(R/(T)));\n        float epsilon = params.epsilon;\n        \n        TraceResult ret = TraceResult(ray.Tmin,0);\n        \n    \tfloat d;\n        float dd;\n        float dist;\n        \n        do\n        {            \n            d = sdf(ray.P+ret.T*ray.V);\n        \tdd = distance_function_approximation(d, ret.T, r0, tanAlpha);\n            dist = d - (r0 + ret.T*tanAlpha);\n            if (dist < epsilon*ret.T*tanAlpha0)\n            {\n            \tm = (dist + r + ret.T*tanAlpha)/(r0 + ret.T*tanAlpha0);\n                r = (m - epsilon)*r0;\n                tanAlpha = (m - epsilon)*tanAlpha0;\n            }\n            ret.T += dd;\n            i = i + 1;\n\n        }while (\n            ret.T < ray.Tmax && \n            m     >  -1.0 &&\n            i     < params.maxiters\n        );\n        mresult.flags =  int(ret.T >= ray.Tmax)\n        \t\t   \t| (int(m     <=  -1.0) << 1)\n             \t  \t| (int(i >= params.maxiters) << 2);\n        \n        mresult.T = ret.T;\n        mresult.m = m;\n    }\n\treturn mresult;\n}\n\n// ---- SHADING ---- (todo!)\n\nvec3 normal(const in vec3 p)\n{\n    const float eps=0.001;\n    vec3 plus = vec3(sdf(p+vec3(eps,0,0)),sdf(p+vec3(0,eps,0)),sdf(p+vec3(0,0,eps)));\n    vec3 minu = vec3(sdf(p-vec3(eps,0,0)),sdf(p-vec3(0,eps,0)),sdf(p-vec3(0,0,eps)));\n    return normalize(plus-minu);\n}\n\nvec4 missColor(Ray ray)\n{\n    return vec4(texture(iChannel2, ray.V).xyz,1.);\n}\nvec4 errorColor(Ray ray, float t)\n{\n    return vec4(1.,0.,0.,1.);\n}\nvec4 hitColor(Ray ray,TraceResult result, const in float R, float r0)\n{\n    float t = result.T;\n    vec3 n = normal(ray.P+ray.V*t);\n    \n\n    vec3 lightPos=vec3(10.,10.,10.);\n    \n    vec3 p = ray.P + ray.V*t;\n    vec3 v = -ray.V;\n    vec3 l = normalize(lightPos-p);\n    \n    SphereTraceDesc params = SphereTraceDesc(0.05, 1000);\n    \n    //diffuse\n    float costheta = max(dot(n,l),0.);\n    vec3 k_d = vec3(1./pi);\n    \n    //specular\n    vec3 toLight = normalize(lightPos - p);\n    vec3 toEye = -ray.V;\n    vec3 k_s = vec3(0.4);\n    \n    vec3 h = normalize(toLight+toEye);\n    float si = pow(clamp(dot(h,n),0.,1.),160.);\n    \n    vec3 col;\n    if (k_d == vec3(0.0, 0.0, 0.0))\n    {\n        col = vec3(0., 0., 0.);\n    }\n    else\n    {\n    \tcol = (k_d + si*k_s)*costheta;\n    }\n    \n    Ray Ray = Ray(p,0.05,normalize(lightPos-p),distance(p,lightPos));\n    mResult mresult = mek(Ray, params, R, lightPos, r0);\n    \n    if(bool(mresult.flags & 1))    \n    {\n        if (mresult.m > 1.0)\n        {\n            mresult.m = 1.0;\n            return vec4(col*mresult.m, 1.);\n        }\n        else if (mresult.m <= 1.0 && mresult.m >= -1.0)\n        {\n            mresult.m = 1./2.*mresult.m + 1./2.;\n            return vec4(col*mresult.m, 1.);\n        } \n    }\n    else if(bool(mresult.flags & 2)) \n    {\n        mresult.m = 0.0;\n        return vec4(col*mresult.m,1.);\n    }\n    else \t        \t\t\t  \n    {\n        return vec4(vec3(1., 0., 0.), 1.);\n    }\n}\n\n// ---- CAMERA and EVENTs ----\n// Common key codes (WASD instead of arrows)\n\nconst int KeyLeft  = 65;\nconst int KeyRight = 68;\nconst int KeyUp    = 87;\nconst int KeyDown  = 83;\n\n#define isKeyHeld(k)  (texelFetch(iChannel1, ivec2(k,0), 0).x > 0.)\n\nRay Camera(vec2 fragCoord, out vec3 eye, out vec2 data2)\n{    \n    // Ray generation\n    eye = texelFetch(iChannel0, ivec2(0,0), 0).yzw;\t\t// camera position\n    data2 = texelFetch(iChannel0, ivec2(1,0), 0).zw;\t// spherical coordinates\n    vec2 uv\t= abs(data2);\n    \n   \tif(iMouse.z>0. || data2.x >= 0.)\t//mouse held or was held last frame\n        uv += (abs(iMouse.zw)-abs(iMouse.xy))*0.01;\n    \n    vec3 w = vec3(cos(uv.x)*cos(-uv.y),\n                  \t\t\tsin(-uv.y),\n                  sin(uv.x)*cos(-uv.y));\n    vec3 u = normalize(cross(vec3(0,1,0),w));\n\tvec3 v = cross(w,u);\n    \n    vec2 px = (fragCoord/iResolution.xy*2.-1.)*1.*normalize(iResolution.xy);\n    \n    // Keyboard and mouse handling:\n\tfloat speed = 0.2;\n    if (isKeyHeld(KeyLeft )) eye -= u*speed;\n    if (isKeyHeld(KeyRight)) eye += u*speed;\n    if (isKeyHeld(KeyUp   )) eye += w*speed;\n    if (isKeyHeld(KeyDown )) eye -= w*speed;\n    \n    if(iMouse.z>=0.)\t\t//mouse held\n        data2 = abs(data2.xy);\n\telse if(data2.x >= 0.)\t//mouse released\n        data2 = -mod(uv,2.*pi);\n    \n    // Ray generation\n    return Ray(eye,\t\t\t\t\t\t\t//V\n               0.5,\t\t\t\t\t\t\t//minT\n               normalize(w+px.x*u+px.y*v),\t//P\n               500.);\t\t\t\t\t\t//maxT\n}\n\n// ---- MAIN ----\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 eye; vec2 data;\n    Ray ray = Camera(fragCoord, eye, data);\n        \n    SphereTraceDesc params = SphereTraceDesc(0.006, 64);\n    \n    vec3 p0 = ray.P;\n    vec3 v0 = ray.V;\n    vec3 c0 = vec3(10,10,10);\n    float r = 1.0;\n    TraceResult result = sphere_trace(ray, params);\n    float sol = min_positive_solution(p0, v0, c0, r);\n    \n    if(bool(result.flags & 1))    fragColor = missColor(ray);    \n    else if(bool(result.flags&2)) fragColor = hitColor(ray, result, r, 0.0);\n    else \t        \t\t\t  fragColor = errorColor(ray, result.T);\n\n    if (sol >= 0.0 && result.T > sol)\n    {\n        fragColor = vec4(vec3(1.,1., 0.), 1.);\n    }       \n    //fragColor.xyz = pow(fragColor.xyz / 6.0, vec3(1.0/2.2));\n    \n    // First two pixels are reserved\n    if(fragCoord.x == 0.5 && fragCoord.y == 0.5) // pixel (0,0)\n        fragColor.yzw = eye;\n    if(fragCoord.x == 1.5 && fragCoord.y == 0.5) //pixel (1,0)\n        fragColor.zw = data;\n        \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float pi = 3.1415926535897932384626433832795;\n\nfloat sdSphere( vec3 p, float s )\n{\n\treturn length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n\tvec3 d = abs(p) - b;\n\treturn length(max(d,0.0))+min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n///SDF\n\nfloat sdf(in vec3 p)\n{\n    p-=vec3(0,0,2);\n    float f = sdSphere(p, 1.);\n    float g = sdBox(p-vec3(2,0,0),vec3(1,1,1));\n    float h = sdBox(p-vec3(2,2,0),vec3(1,1,1));\n    float i = sdSphere(p-vec3(0,2,0), 1.);\n    \n    float j = sdSphere(p-vec3(4,0,0), 1.);\n    float k = sdSphere(p-vec3(4,2,0), 1.);\n    \n    float l = sdSphere(p-vec3(2,0,2), 1.);\n    float m = sdSphere(p-vec3(2,2,2), 1.);\n    \n    float n = sdRoundedCylinder(p-vec3(2,4,0),1.0, 0.5,0.5);\n    \n    float s = sdSphere(p-vec3(-30, 1, -30), 1.);\n    \n    return min(min(min(min(min(min(min(min(min(min(f,g),h),i),j),k),l),m),n), s),p.y+1.);\n}","name":"Common","description":"","type":"common"}]}