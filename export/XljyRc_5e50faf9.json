{"ver":"0.1","info":{"id":"XljyRc","date":"1509565052","viewed":179,"name":"integration: golden ratio sanity","username":"hornet","description":"sanity check on analysis of https://blog.demofox.org/2017/10/31/animating-noise-for-integration-over-time/ (see also https://www.shadertoy.com/view/MlByz3 )\n\nLMB to vary samplecount\n\n\n","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["sanity"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//red: noise\n//green: avg of N samples of noise\n//blue: avg of noise + N random numbers\n//black: avg of noise + i/N (uniform)\n//gold: avg of noise + N golden ratios\n\n\n// https://blog.demofox.org/2017/10/31/animating-noise-for-integration-over-time/\nconst float gr = (1.0 + sqrt(5.0)) / 2.0;\nfloat GoldenRatioMultiple( int multiple )\n{\n    return float(multiple) * gr;\n}\n\n/*\n//note: uniform pdf rand [0;1[\nfloat hash12n(vec2 p)\n{\n\tp  = fract(p * vec2(5.3987, 5.4421));\n    p += dot(p.yx, p.xy + vec2(21.5351, 14.3137));\n\treturn fract(p.x * p.y * 95.4307);\n}\n/*/\n//note: src https://www.shadertoy.com/view/4dlcR4\nuint hash12_xor_int(uint x, uint y)\n{\n\t//note: improved constants by MBR, https://twitter.com/marc_b_reynolds/status/924771187070308352\n    #define W0 0x3504f335u    // 15 | 101 | 41*79*274627\n\t#define W1 0x8fc1ecd5u  // 18 | 101 | 5*482370193\n\t#define M  741103597u    // 13*83*686843\n\n    x *= W0;   // x' = Fx(x)\n    y *= W1;   // y' = Fy(y)\n\n    //note: hash2-improvement from MBR\n    //x += W1;   // some odd constant\n    //y += W0;   // some odd constant\n\n    x ^= y;    // combine\n    x *= M;    // MLCG constant\n\n    //note: murmur-like finalizer, suggestion: https://twitter.com/funny_falcon/status/923270464394481664\n\tx ^= x >> 16;\n\tx *= M;\n\tx ^= x >> 16;\n    \n  \treturn x;\n}\nfloat hash12n( vec2 seed )\n{\n    seed *= iResolution.xy;\n    uint hi = hash12_xor_int( uint(seed.x), uint(seed.y) );\n    return float(hi) * (1.0/4294967296.0);\n}\n/**/\nfloat myfract(float v )\n{\n    return mod( v, 1.0000001 ); //wat...\n}\n\n\n\nconst vec4 RED   = vec4(1.0,0.2,0.1,1.0);\nconst vec4 GREEN = vec4(0.5,1.0,0.3,1.0);\nconst vec4 BLUE  = vec4(0.1,0.3,1.0,1.0);\nconst vec4 BLACK = vec4(0.0,0.0,0.0,1.0);\nconst vec4 GOLD  = vec4(1.0,0.7,0.1,1.0);\n\nvoid mainImage( out vec4 oc, in vec2 fc )\n{\n\tvec2 uv = fc.xy / iResolution.xy;\n    int idx = int( floor( 5.0 * uv.x ) + 4.0*floor( 1.0 * uv.y ) );\n    \n    const int NUM_SAMPLES = 16;\n\tconst float RCP_NUM_SAMPLES_F = 1.0  / float(NUM_SAMPLES);\n\n    int sample_limit = 16;\n    if ( iMouse.z > 0.5 )\n    {\n        sample_limit = int(16.0*iMouse.x/iResolution.x)+1;\n        if ( uv.y > 0.9875)\n        {\n            oc = vec4(vec3(step(uv.x-float(sample_limit)/float(NUM_SAMPLES), 0.0)), 1.0 ); return;\n        }\n    }\n    float rcp_sample_limit = 1.0 / float(sample_limit);\n    \n    vec2 seed = 101.0 * uv;\n    \n    float sum = 0.0;\n    for ( int i=0; i<NUM_SAMPLES; ++i )\n    {\n        if ( i >= sample_limit )\n            break;\n        \n        if ( idx == 0 )\n        {\n            //note: base noise\n            sum = hash12n( seed );\n            if ( uv.y < 0.0125 ) { oc=RED; return; }\n        }\n        if ( idx == 1 )\n        {\n            //note: averaged over N different seeds\n            if ( uv.y < 0.0125 ) { oc=GREEN; return; }\n            float rnd = hash12n( seed + float(i) );\n            sum += rcp_sample_limit * rnd;\n        }\n        else if ( idx == 2 )\n        {\n            //note: random [0;1]-offset per sample\n            if ( uv.y < 0.0125 ) { oc=BLUE; return; }\n            float rnd = hash12n( seed );\n            float ofs = hash12n( vec2(i) );\n            rnd = myfract( rnd + ofs );\n            sum += rcp_sample_limit * rnd;\n        }\n        else if ( idx == 3 )\n        {\n            //note: uniform offset per sample\n            if ( uv.y < 0.0125 ) { oc=BLACK; return; }\n            float rnd = hash12n( seed );\n\n            //uniform\n            float ofs = float(i) / float(sample_limit);\n            \n            //note: as good as uniform for exactly 8 or 16\n            //const float van_der_corput16[16] = float[] (0.0, 1.0/2.0, 1.0/4.0, 3.0/4.0, 1.0/8.0, 5.0/8.0, 3.0/8.0, 7.0/8.0, 1.0/16.0, 9.0/16.0, 5.0/16.0, 13.0/16.0, 3.0/16.0, 11.0/16.0, 7.0/16.0, 15.0/16.0 );\n\t\t\t//float ofs = van_der_corput16[ i%16 ];\n            \n            //ofs += hash12n( vec2(i) ) / float(sample_limit); //note: uniform-step sized random offset\n\n            rnd = myfract( rnd + ofs );\n            sum += rcp_sample_limit * rnd;\n        }\n        else if ( idx == 4 )\n        {\n            //note: average using golden ratio offset per sample\n            if ( uv.y < 0.0125 ) { oc=GOLD; return; }\n            float rnd = hash12n( seed );\n            float grm = GoldenRatioMultiple( i ); \n            rnd = myfract( rnd + grm );\n            sum += rcp_sample_limit * rnd;\n        }\n    }\n    \n    oc  = vec4( vec3(sum), 1.0 );\n    \n    //lines\n    oc *= step( 6.0/iResolution.x, 1.0-abs(2.0*fract(5.0*uv.x)-1.0));\n}\n\n/*\nfloat getchar( int idx )\n{\n    int i = idx / 4;\n    int f = idx % 4;\n    uint c = chars_uint[ i ];\n    return float( (c>>(8*f)) & 0xffU );\n}\n\n\nfloat textcol()\n{\n    const int COLROW = 16;\n    const float COLROW_F = float(COLROW);\n    uvtxt /= 16.0;\n    uvtxt.x += mod( charidx, 16.0 ) / 16.0;\n    uvtxt.y += floor( COLROW_F-(charidx+1.0)/16.0) / 16.0;\n    \n    return texture( iChannel0, uvtxt ).a;\n}\n*/","name":"Image","description":"","type":"image"}]}