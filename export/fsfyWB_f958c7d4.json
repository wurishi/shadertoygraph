{"ver":"0.1","info":{"id":"fsfyWB","date":"1642693391","viewed":207,"name":"Tripliodics","username":"lz","description":"Playing with triply periodic functions and glass like shading.","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["glass","gyroid","triplyperiodic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 col = texture(iChannel0, uv);\n    /*ivec2 e = ivec2(1,0);\n    \n    vec4 l = texelFetch(iChannel0, ivec2(fragCoord) - e.xy, 0);\n    vec4 r = texelFetch(iChannel0, ivec2(fragCoord) + e.xy, 0);\n    vec4 u = texelFetch(iChannel0, ivec2(fragCoord) + e.yx, 0);\n    vec4 d = texelFetch(iChannel0, ivec2(fragCoord) - e.yx, 0);\n    \n    vec4 na = vec4(l.a, r.a, u.a, d.a);\n    vec4 ca = vec4(col.a);\n    vec4 da = abs(ca - na);\n    float maxDa = max(da.x, max(da.y, max(da.z, da.w)));\n    \n    //col = mix(col, 0.25 * (l + r + u + d), step(10., maxDa) * step(25., col.a));\n    */\n    col.rgb = pow(col.rgb, vec3(2.2));\n    \n    fragColor = vec4(col);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvec3 lidinoid(in vec3 p, in float t, in float th)\n{\n    vec3 r;\n    float s_len = PI2 * .3;\n    vec3 q = p * PI2 / s_len;\n    \n    float fn = 0.5 * (sin(2.*q.x)*cos(q.y)*sin(q.z) + \n                      sin(2.*q.y)*cos(q.z)*sin(q.x) +\n                      sin(2.*q.z)*cos(q.x)*sin(q.y)) -\n               0.5 * dot(cos(2.*q),cos(2.*q.yzx)) + 0.15;\n    \n    r.z = sign(fn - t);\n    r.x = .05 * abs(fn - t);\n    \n    return r - th;\n}\n\nvec3 shwartzW(in vec3 p, in float t, in float th)\n{\n    vec3 r;\n    float s_len = PI2 * .3;\n    vec3 q = p * PI2 / s_len;\n    \n    float fn = dot(cos(q), cos(q.yzx)) - cos(q.x)*cos(q.y)*cos(q.z);\n    \n    r.z = sign(fn - t);\n    r.x = .01 * abs(fn - t);\n    \n    return r - th;\n}\n\nvec3 shwartzD(in vec3 p, in float t, in float th)\n{\n    vec3 r;\n    float s_len = PI2 * .3;\n    vec3 q = p * PI2 / s_len;\n    \n    float fn = sin(q.x)*sin(q.y)*sin(q.z) +\n                sin(q.x)*cos(q.y)*cos(q.z) +\n                cos(q.x)*sin(q.y)*cos(q.z) +\n                cos(q.x)*cos(q.y)*sin(q.z);\n    \n    r.z = sign(fn - t);\n    r.x = .05 * abs(fn - t);\n    \n    \n    return r - th;\n}\n\nvec3 shwartzP(in vec3 p, in float t, in float th)\n{\n    vec3 r;\n    float s_len = PI2 * 0.3;\n    \n    float fn = dot(cos(p*PI2 / s_len), vec3(1.)) - t;\n    \n    r.z = sign(fn - t);\n    r.x = .03 * abs(fn - t);\n    \n    return r - th;\n}\n\nvec3 gyroid(in vec3 p, in float t, in float th)\n{\n    vec3 r;\n    float s_len = PI2 * .3;\n    \n    float fn = dot(cos(p*PI2 / s_len), sin(p.yzx * PI2 / s_len)) - t;\n    \n    \n    r.z = sign(fn);\n    r.x = .05 * abs(fn);\n    \n    return r - th;\n}\n\nvec3 double_gyroid(in vec3 p, in float t, in bool high)\n{\n    vec3 r;\n    float s_len = PI2 * 3.;\n    \n    float fn = dot(cos(p*PI2 / s_len), sin(p.yzx * PI2 / s_len));\n    \n    r.x = fn*fn - t*t;\n    \n    // differentiate gyroid\n    r.z = sign( (abs(fn - t) - abs(fn + t)) );\n    \n    // differentiate side of the gyroid\n    r.y = sign( r.x );\n    \n    r.x = .5 * abs(r.x);\n    \n    return r;\n}\n\nvec2 geom(in vec3 p)\n{\n    vec3 op = p + vec3(0.);\n    float rotAngle = 0.5 * op.y * _ANIMATION(0);\n    op.xz = ROT2D(op.xz, rotAngle);\n    rotAngle = 0.5 * op.y * _ANIMATION(1);\n    op.yz = ROT2D(op.yz, rotAngle);\n    float th = 0.01 * _ANIMATION(12);\n    \n    vec3 cp = p;\n    cp.y -= abs(0.5 * length(cp.x));\n    cp.z *= 1.5;\n    float f = length(p - vec3(0., 0., 0.)) - 2.0;\n    float tf = 0.5 * (_ANIMATION(2) + _ANIMATION(3));\n    vec3 g0 = lidinoid(op, tf, th);\n    vec3 g1 = shwartzD(op, tf, th);\n    vec3 g2 = shwartzP(op, tf, th);\n    vec3 g3 = gyroid(op, tf, th);\n    \n    float boxf = sdRoundBox(op, vec3(2.5), .1);\n    \n\n    vec2 gfz = mix(g0.xz, \n    mix(g1.xz, \n    mix(g3.xz, g2.xz,\n    _ANIMATION(4)), _ANIMATION(5)), _ANIMATION(6));\n    \n    //return vec2(boxf, 1.);\n    return vec2(max(gfz.x, f), gfz.y);\n}\n\nvec4 geomI(in vec3 p, in bool high)\n{\n    //p.x += 2.5*sin(p.x*0.01) + 0.1*sin(p.y*2. + iTime*0.5);\n    //p.y += 4.3*cos(p.z*0.1) + 0.1*cos(p.z*2. + iTime*0.75) + 0.2*cos(p.x*2. + iTime*0.37);\n    vec3 gf = double_gyroid(p, .7, high);\n    float rf = (high) ? 0.05*fbm(p) : 0.0;\n    gf.x += rf;\n    return vec4(gf, rf);\n}\n\nvec2 planeIsect(in vec3 p, float d)\n{\n  float f = -100.;\n  float pi = -1.;\n  for (int i = 0; i < DODECPLANES; i++)\n  {\n    float df = (dplane(p, d*pPoints[i], normalize(pPoints[i])));\n    pi = (df > f) ? float(i) : pi;\n    \n    f = spmax(f, df, 0.1);\n  }\n  return vec2(f, pi);\n}\n\nvec2 geomSolid(in vec3 p)\n{\n   vec3 op = p + vec3(0.);\n   float rad = 0.15 + 0.1 * _ANIMATION(7);\n   float shapePulse = _ANIMATION(8);\n   float boxf = sdRoundBox(op, vec3(2.5), rad);\n   vec2 dodecf = planeIsect(op, 3.);\n   float fshape = mix(boxf, dodecf.x, shapePulse);\n   return vec2(fshape, 1.);\n}\n\nvec4 trace(in vec3 o, in vec3 d, in float start, in float end) {\n  float t = 0.0;\n  float mint = 10.0;\n\n  vec2 res = vec2(mint, 0.);\n  float g = 0.;\n  float efar = min(FAR, end);\n    \n  for (int i=0 ; i < M_ITER ; i++)\n  {\n    vec3 p = o + t*d;\n\n    res = geom(p);\n    mint = abs(res.x);\n    g += 0.1/(0.1 + mint * mint* mint * mint);\n    t += mint;\n\n    if (mint < T_EPS*t || t > efar) break;\n  }\n  \n   \n  return vec4(t, mint, res.y, g);\n}\n\nvec4 traceI(in vec3 o, in vec3 d) {\n  float t = 0.0;\n  float mint = 10.0;\n\n  vec2 res = vec2(mint, 0.);\n  float glow = 0.;\n    \n  for (int i=0 ; i < M_ITER ; i++)\n  {\n    vec3 p = o + t*d;\n    \n    res = geomI(p, false).xz;\n    mint = abs(res.x);\n    //glow += 0.1/(0.1 + glow * glow * 5.);\n    t += mint;\n\n    if (mint < T_EPS*10.*t || t > FAR) break;\n  }\n  \n   \n  return vec4(t, mint, res.y, glow);\n}\n\nvec4 traceFrontBack(in vec3 o, in vec3 d, float jump, int gval)\n{\n    float t = 0.0;\n    float mint = 10.0;\n    \n    vec2 res = vec2(mint, 0.);\n    vec4 ret = vec4(0.);\n    \n    // first pass\n    for (int i = 0; i < M_ITER && mint > T_EPS; i++)\n    {\n      vec3 p = o + t*d;\n      \n      res = geomSolid(p);\n      mint = res.x;\n      \n      if (mint < T_EPS*t || t > FAR) break;\n      \n      t += mint;\n    }\n    \n    if (t > FAR)\n    {\n        return ret;\n    }\n    \n    ret.x = t;\n    ret.z += 1.;\n    \n    // second pass\n    t += jump;\n    mint = -10.0;\n    for (int i = 0; i < M_ITER && mint < -T_EPS; i++)\n    {\n        vec3 p = o + t * d;\n        \n        res = geomSolid(p);\n        mint = res.x;\n        t += 1.;\n        ret.w += 1.;\n    }\n    \n    // third pass // backwards\n    mint = 10.0;\n    for (int i = 0; i < M_ITER && mint > T_EPS; i++)\n    {\n        vec3 p = o + t * d;\n        \n        res = geomSolid(p);\n        mint = res.x;\n        \n        if (mint < T_EPS*t) break;\n        \n        t -= mint;\n    }\n    \n    ret.y = t;\n    ret.z += 1.;\n    \n    return ret;\n}\n\nvec3 norm(in vec3 p, in float i_geom)\n{\n    vec3 n;\n    vec2 e = vec2(N_EPS, 0.0);\n    \n    n.x = geom(p + e.xyy).x - geom(p - e.xyy).x;\n    n.y = geom(p + e.yxy).x - geom(p - e.yxy).x;\n    n.z = geom(p + e.yyx).x - geom(p - e.yyx).x;\n\n    return normalize(n);\n}\n\nvec3 normI(in vec3 p, in bool hres)\n{\n    vec3 n;\n    vec2 e = vec2(N_EPS*10., 0.0);\n    \n    n.x = geomI(p + e.xyy, hres).x - geomI(p - e.xyy, hres).x;\n    n.y = geomI(p + e.yxy, hres).x - geomI(p - e.yxy, hres).x;\n    n.z = geomI(p + e.yyx, hres).x - geomI(p - e.yyx, hres).x;\n    \n    return normalize(n);\n}\n\nvec3 normfI(in vec3 p, in float _f, in bool hres)\n{\n    vec3 n;\n    vec2 e = vec2(N_EPS*10., 0.0);\n    \n    n.x = geomI(p + e.xyy, hres).x - _f;\n    n.y = geomI(p + e.yxy, hres).x - _f;\n    n.z = geomI(p + e.yyx, hres).x - _f;\n    \n    return normalize(n);\n}\n\nvec3 normSolid(in vec3 p, in float i_geom)\n{\n    vec3 n;\n    vec2 e = vec2(N_EPS, 0.0);\n    \n    n.x = geomSolid(p + e.xyy).x - geomSolid(p - e.xyy).x;\n    n.y = geomSolid(p + e.yxy).x - geomSolid(p - e.yxy).x;\n    n.z = geomSolid(p + e.yyx).x - geomSolid(p - e.yyx).x;\n    \n    return normalize(n);\n}\n\nvec4 renderCube(in vec4 solidRes, in vec4 res, in vec3 o, in vec3 d)\n{\n    vec3 col;\n    vec3 nsolid;\n    float dbound = solidRes.y - solidRes.x;\n    float glassFactor = clamp(2.5/(dbound + T_EPS), 0.01, 1.5);\n    float depthFactor = 100./(pow(solidRes.y, 1.8));\n    \n    nsolid = normSolid(o + solidRes.x * d, 0.);\n    \n    float bColPulse = _ANIMATION(9);\n    float bColPulse2 = _ANIMATION(10);\n    \n    vec3 cBaseCol = mix(mix(vec3(.89, 0.44, 0.09), vec3(.69, 0.21, 0.37), bColPulse), vec3(.49, 0.81, 0.37), bColPulse2);\n    vec3 cubecol = cBaseCol*dot(nsolid, -d)*glassFactor*depthFactor;\n    \n    float alpha = pow(grayscale(cubecol), 0.05);\n    \n    col = cubecol;\n    \n    if (res.y < T_EPS * res.x)\n    {\n        vec3 n = norm(o + res.x * d, 0.);\n        vec3 gcol = mix(vec3(.8, .83, .79), vec3(0.1, 0.15, .27), step(res.z, 0.1));    \n        \n        gcol *= dot(n, -d);\n\n        if (solidRes.x < res.x && solidRes.z >= 2.)\n        {\n            float df = res.x - solidRes.x;\n            vec3 glow = (cBaseCol) * length(cross(n, -d)) * res.w*0.03;\n            col = mix(cubecol, gcol + glow, dot(nsolid, -d) * 2.5/(df*df));\n        }\n        \n        alpha = 1.;\n    }\n    \n    return vec4(col, alpha);\n}\n\nvec4 traceCubeCol(in vec3 o, in vec3 d, int gval)\n{\n    \n    vec4 solidRes;\n    if ((gval & 1) != 0)\n        solidRes = traceFrontBack(o, d, 1.5, 0);\n        \n    vec4 res = vec4(0., 100000., 1., 0.);\n    vec4 ccol = vec4(0.);\n    if (solidRes.z >= 2.)\n    {\n        if ((gval & 2) != 0)\n        {\n            res = trace(o + solidRes.x*d, d, 0., solidRes.y - solidRes.x);\n            res.x += solidRes.x;\n        }\n        ccol = renderCube(solidRes, res, o, d);\n    }\n    \n    return ccol;\n}\n\nvec4 environment(in float t, in vec3 o, in vec3 d) {\n    float b = .03 + .01*sin(iTime * .1);\n    float alpha = exp(-(t + 5.)*b);\n    vec3  light  = vec3(0.1,0.2,0.3);\n    light = mix(light, vec3(0.5), clamp(pow(dot(d, vec3(1., 1., 0.0)), 9.), 0., 1.) );\n    \n    return vec4(light, alpha);\n}\n\nvec4 triplanar(in vec3 p, in vec3 n, in float scale, in sampler2D s)\n{\n  vec4 dx = texture(s, p.yz*scale);\n  vec4 dy = texture(s, p.zx*scale);\n  vec4 dz = texture(s, p.xy*scale);\n  //n += 0.7*n + vec3(0.2);\n  float sw = n.x + n.y + n.z;\n  float wx = n.x/sw;\n  float wy = n.y/sw;\n  float wz = n.z/sw;\n  \n  return dx * wx + dy *wy + dz * wz;\n}\n\n// Fresnel-Shlick\nfloat F(in float _f0, in vec3 _h, in vec3 _v)\n{\n    float hv = max(dot(_h, _v), 0.);\n    float hv1 = pow(1. - hv, 5.);\n    return _f0 + (1. - _f0) * hv1;\n}\n\n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/(iResolution.y);\n    \n    float fov = .5;\n    \n    ANIM_FRAME_SET(iTime)\n    \n    vec3 o = getOrigin(iTime, iChannel1);\n    vec3 target = getOrigin(iTime - 1., iChannel1);\n    \n    vec3 od = normalize(vec3(fov*(2.*(uv-vec2(0.0, -0.5))),-1.));\n    vec3 light = normalize(vec3(1., -1., -1.));\n    \n    vec3 d = camera(o, od, 0.5*target);\n\n    vec3 col;\n    vec3 bckcol = vec3(0.);\n    vec4 ccol = vec4(0.);\n    \n    float depth = 0.0;\n    \n    if (abs(uv.y) > 1.0)\n    {\n        fragColor = vec4(0.);\n        return;\n    }\n    \n    for (int rw = 0; rw < AA; rw++)\n    for (int cl = 0; cl < AA; cl++)\n    {\n        vec2 off = -0.5 + vec2( float(rw), float(cl) ) / float(AA);\n        vec2 tuv = (2.0*(fragCoord + off)-iResolution.xy)/(iResolution.y);\n        \n        d = normalize(vec3(fov*(2.*(tuv-vec2(0.0, -0.0))),-1.0));\n        //rcd.xy += (1./vec2(float(AA*AA)) + vec2(float(row)/float(AA), float(col)/float(AA))) / (iResolution.y);\n        d = camera(o, d, 0.55*target);\n        ccol += traceCubeCol(o, d, 3);\n\n\n        float rad = 15.;\n        vec2 rsph = sphIntersect(o, d, vec3(0.), rad);\n        if (rsph.x * rsph.y < 0.)\n        {\n          vec3 pshp = o + rsph.y * d;\n          vec3 nsph = -normalize(pshp);\n          vec4 g3res = traceI(pshp, d);\n\n          // color sphere\n          float rsscl = rsph.y/(rad * 2.);\n          vec3 sphCol = vec3(1., rsscl, 0.0);\n          vec4 mtl = geomI(pshp + g3res.x * d, true);\n\n          float inside = step(0.1, mtl.y);\n          float gid = step(0.5, mtl.z);\n\n          vec3 gcol = mix(vec3(1.), vec3(1., 1., 0.821), step(0.1, mtl.z));\n\n          // differentiate inside/outside\n          gcol *= (1. - 0.5*inside);\n\n          /*\n          float hue = mix(mix(0.5, 0.6, inside), mix(0.64, 0.68, 1. - inside), gid) * (5./6.);\n          vec3 hsv = vec3(hue, 0.7, 1.0);\n          gcol.bgr = hsv2rgb(hsv);\n          */\n\n          // hit position to gyroid.\n          vec3 totp = pshp + g3res.x * d;\n          depth = max(depth, g3res.x + rsph.y);\n          vec3 n3gyr = normI(totp, true);\n\n          // fake normals for triplanar texturing\n          vec3 tn3gyr = normI(totp*0.1, false);\n          vec3 tcol2 = triplanar(totp, abs(tn3gyr), 0.1, iChannel3).rgb;\n          vec3 tcol = triplanar(totp, abs(tn3gyr), 0.01, iChannel0).rgb;\n\n          // texture brigthness attenuation.\n          gcol *= length(tcol);\n          gcol += tcol2 * rsph.y * 0.25;\n\n          // bright one of the two gyroids.\n          gcol *= (1. + 1.*step(0.1, mtl.z));\n\n          // light direction towards the cube.\n          vec3 ldir = normalize(totp);\n\n          vec3 rfl;\n          rfl = reflect(d, n3gyr);\n          //vec3 dn3gyr = fwidth(n3gyr);\n          vec3 h = normalize(ldir - d);\n          float spec = clamp(dot(rfl, -ldir), 0., 1.) * 1.25*F(0.6, h, -d);\n\n          // spherical distance attenuation\n          vec3 ocol = mix(sphCol, gcol, 0.75);\n          ocol = mix(ocol, 1. - ocol*ocol, vec3(ccol.a));\n\n          // gyroid distance attenuation\n          ocol += vec3(.96, 0.41, 2.1) * smoothstep(0., g3res.x, 0.25);\n\n          // lighting\n          ocol *= (dot(n3gyr, -ldir) + pow(spec*exp(-0.001), 4.));\n          \n          // inverted fog\n          vec4 fg = environment(g3res.x * (smoothstep(0., 20., g3res.x) - smoothstep(30., 40., g3res.x)), o, d);\n          ocol = mix(ocol, fg.rgb, fg.a);\n\n          // cube color reflection\n          rfl = reflect(d, nsph);\n          vec4 rocol = traceCubeCol(pshp + (g3res.x - 0.001) * d, rfl, 1);\n          ocol = mix(ocol, rocol.rgb * dot(n3gyr, -ldir), 0.7 * clamp(rocol.a, 0., 1.));\n          bckcol += ocol;\n        }\n    }\n    \n    ccol /= float(AA * AA);\n    bckcol /= float(AA * AA);\n    col = mix(bckcol, ccol.rgb, pow(clamp(1.02*ccol.a, 0., 1.), 2.));\n\n    col = mix(col, col.bgr, _ANIMATION(11));\n    \n    //col = mix(col, tcol.rgb, (step(0.1, ccol.a) - step(0.75, ccol.a)) * 0.5 * smoothstep(1.2, 1.8, length(col - tcol.rgb)) );\n    // Output to screen\n    fragColor = vec4(col, depth * step(ccol.a, 0.1));\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_H 1.57079632679\n\n#define PHI 1.6180339887\n#define INV_PHI 0.6180339887\n\n#define INT(f) int(f + 0.00001)\n\n#define SEL_ZONE_Y 0.01\n\n#define ROT2D(p2d, ang) (cos(ang) * p2d.xy + sin(ang) * vec2(p2d.y, -p2d.x))\n\n#define FAR 60.\n#define M_ITER 256\n#define T_EPS 0.0001\n#define N_EPS 0.0001\n\n#define PI 3.14159265359\n#define PI2 6.28318530718\n\n#define PULSE_T(_t, _e, _pa, _pb) (smoothstep(_pa - _e, _pa, _t) - smoothstep(_pb, _pb + _e, _t))\n\n#define DODECPLANES 12\nconst vec3 pvx = normalize(vec3(0., 1., PHI));\nconst vec3 nvx = normalize(vec3(0., 1., -PHI));\n\nconst vec3 pPoints[DODECPLANES] = \n    vec3[DODECPLANES](pvx, nvx,\n                  -pvx, -nvx,\n                  pvx.yzx, nvx.yzx,\n                  -nvx.yzx, -pvx.yzx,\n                  pvx.zxy, nvx.zxy,\n                  -nvx.zxy, -pvx.zxy);\n\nfloat dplane(in vec3 p, in vec3 pp, in vec3 n)\n{\n  return dot(p - pp, n);\n}\n\n\n\n//https://www.shadertoy.com/view/ldSSzV\nvec3 hash31(float p) {\n\tvec3 h = vec3(127.231,491.7,718.423) * p;\t\n    return fract(sin(h)*435.543);\n}\n\n// signed distance functions:\n// https://iquilezles.org/articles/distfunctions\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n// polynomial\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec3 hsv2rgb( const in vec3 c )\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n////\n\nfloat spmax(in float f1, in float f2, in float k)\n{\n  float df = f1 - f2;\n  return 0.5 * (f1 + f2 + sqrt(df * df + k));\n}\n\n\nfloat grayscale(in vec3 col)\n{\n    float gray = dot(col.rgb, vec3(0.299, 0.587, 0.114));\n    return gray;\n}\n\nfloat hash(in float s) {\n  return fract(sin(s*4138.5453123));\n}\n\nfloat hash(in vec3 p)\n{\nreturn fract(sin(dot(p,\nvec3(12.6547, 765.3648, 78.653)))*43749.535);\n}\n\nfloat noise3(in vec3 p)\n{\nvec3 pi = floor(p);\nvec3 pf = fract(p);\n\npf = pf*pf*(3.-2.*pf);\n\nfloat a = hash(pi + vec3(0., 0., 0.));\nfloat b = hash(pi + vec3(1., 0., 0.));\nfloat c = hash(pi + vec3(0., 1., 0.));\nfloat d = hash(pi + vec3(1., 1., 0.));\n\nfloat e = hash(pi + vec3(0., 0., 1.));\nfloat f = hash(pi + vec3(1., 0., 1.));\nfloat g = hash(pi + vec3(0., 1., 1.));\nfloat h = hash(pi + vec3(1., 1., 1.));\n\nreturn mix(mix(mix(a,b,pf.x),mix(c,d,pf.x),pf.y),\nmix(mix(e,f,pf.x),mix(g,h,pf.x),pf.y), pf.z);\n}\n\nfloat fbm(vec3 p) {\n\n  float f = 0.;\n  float ampl = 0.5;\n  float freq = 1.;\n  float off = 0.;\n\n  int i = 0;\n  for (i = 0; i < 4; i++) {\n    f += ampl*noise3(p*freq + off);\n    ampl*= 0.5;\n    freq *= 2.;\n    off += 12.274739;\n  }\n\n  return f;\n}\n\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\nvec3 camera(in vec3 o, in vec3 d, in vec3 tar) {\n  vec3 dir = normalize(o - tar);\n  vec3 right = cross(vec3(0.,1.,0.),dir);\n  vec3 up = cross(dir,right);\n\n  mat3 view = mat3(right,up,dir);\n  return view*d;\n}\n\nvec3 camera(in vec3 o, in vec3 d, in vec3 tar, in vec3 up) {\n  vec3 dir = normalize(o - tar);\n  vec3 right = normalize(cross(dir, up));\n  up = normalize(cross(right,dir));\n\n  mat3 view = mat3(right,up,dir);\n  return (view*d);\n}\n\n#define NPO 6\nvec3 origs[NPO] = vec3[NPO](vec3(-7., 4.2, 6.4), vec3(4., 5.8, 6.4), \n    vec3(3., -6., 7.), vec3(4.4, -4., -8.23), vec3(-4., -6.3, -7.3), vec3(-4.7, 4.1, -6.6));\n\nvec3 getOrigin(in float time, in sampler2D s)\n{\n    float oTime = texelFetch(s, ivec2(mod(time*0.05, 256.), 0), 0).r;\n    float oNTime = texelFetch(s, ivec2(mod(time*0.05 + 1., 256.), 0), 0).r;\n\n    int iOrig = int(mod(oTime * float(4), float(4)));\n    int iNOrig = int(mod(oNTime * float(4), float(4)));\n\n    float fOrig = fract(time*0.05);\n\n    vec3 o = mix(origs[iOrig], origs[iNOrig], smoothstep(0., 1., fOrig));\n    o = normalize(o) * 8.;\n    o += vec3(sin(time*.5),cos(time*.5),0.);\n    \n    return o;\n}\n\n// animation states\n\n#define ANIM_PULSE(t, s, e) (smoothstep(s - 0.75, s, t) - smoothstep(e, e + 0.75, t))\n#define ANIM_PULSE2(t, s, e) (smoothstep(s - 2., s, t) - smoothstep(e, e + 2., t))\n\nfloat animStates[20] = float[20](0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n                                 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.);\n                                 \n#define ANIM_FRAME_SET(time) \\\n    float t20 = mod(time, 20.); \\\n    float t40 = mod(time, 40.); \\\n    float t45 = mod(time, 45.); \\\n    float t10 = mod(time, 10.); \\\n    float t17 = mod(time, 17.); \\\n    float t15 = mod(time, 15.); \\\n    float t73 = mod(time, 73.); \\\n    animStates[0] = ANIM_PULSE(t20, 5., 13.);  \\\n    animStates[1] = ANIM_PULSE(t20, 9., 17.);  \\\n    animStates[2] = ANIM_PULSE(t40, 10., 20.); \\\n    animStates[3] = ANIM_PULSE(t40, 10., 30.); \\\n    animStates[4] = ANIM_PULSE2(t45, 30., 40.); \\\n    animStates[5] = ANIM_PULSE2(t45, 20., 38.); \\\n    animStates[6] = ANIM_PULSE2(t45, 10., 42.); \\\n    animStates[7] = ANIM_PULSE(t10, 3., 3.4); \\\n    animStates[8] = ANIM_PULSE(t17, 8., 14.); \\\n    animStates[9] = ANIM_PULSE(t10, 3., 7.); \\\n    animStates[10] = ANIM_PULSE(t15, 6., 10.); \\\n    animStates[11] = ANIM_PULSE(t73, 27., 53.); \\\n    animStates[12] = ANIM_PULSE(t45, 5., 5.45) + ANIM_PULSE(t45, 24., 24.45);\n    \n#define _ANIMATION(id) animStates[id]\n\nfloat getAnimation(in int id)\n{\n  return animStates[id];\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.xy;\n    \n    //uv.y += 2.*sin(uv.x);\n    vec2 grid = uv;\n    //uv = vec2(atan(uv.y, abs(uv.x)), length(uv));\n    uv.y += iTime * 0.1;\n    float ht = iTime*0.01;\n    float gridFactor = 2. + 2.*mix(hash(floor(ht)), hash(floor(ht) + 1.), fract(ht));\n    uv.x += sin(fbm(vec3(uv*1.2, iTime * 0.05))) + iTime*0.01;\n    vec2 fgridy = fract(vec2(uv.x * gridFactor, uv.y));\n    vec2 igridy = floor(vec2(uv.x * gridFactor, uv.y));\n    \n    float f0 = fbm(vec3(grid, iTime * 0.15));\n    float fl = smoothstep(0.5*f0, 0.5, fgridy.x) - smoothstep(0.5, 1.0 - 0.5*f0, fgridy.x);\n    float f2 = 1.5*fbm(vec3(uv, iTime*0.01));\n    \n    fragColor = vec4(vec3(1.0, 0.55, 0.5)*fl*f2,1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}