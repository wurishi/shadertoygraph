{"ver":"0.1","info":{"id":"WlGcDR","date":"1610905419","viewed":76,"name":"Proof Of Fixed Points Theorem","username":"m1ke","description":"Each box in the smaller grid is lit up white if it is still in its original box, it is lit up white\nYou cannot rotate or transform the smaller box so that none of the boxes are white, at least one must be still in its original position.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["fixedpoints"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Square\n{\n    vec2 pos;\n    float size;\n    vec2 maxR;\n    vec2 minR;\n    vec3 colour;\n};\nSquare newSquare(vec2 p, float s, vec3 c)\n{\n    Square sq;\n    sq.pos = p;\n    sq.size = s;\n    sq.maxR = vec2(p.x+s, p.y+s);\n    sq.minR = vec2(p.x-s, p.y-s);\n    sq.colour = c;\n    return sq;\n}\nbool InSquare(vec2 p, Square s)\n{\n    return (p.x > s.minR.x && p.y > s.minR.y && p.x < s.maxR.x && p.y < s.maxR.y);\n}\nvoid DrawSquare(inout vec3 col, vec2 p, Square s)\n{\n    if (InSquare(p, s))\n    {\n        col = s.colour;\n    }\n}\nvoid DrawHollowSquare(inout vec3 col, vec2 p, Square inner, float t)\n{\n    vec3 prevCol = col;\n    DrawSquare(col, p,newSquare(inner.pos, inner.size, inner.colour));\n    DrawSquare(col, p,newSquare(inner.pos, inner.size-t, prevCol));\n}\nvoid DrawBoxArray(inout vec3 col, vec2 p, Square s, bool top)\n{\n    float sideLength = s.size/ 2.5f;\n    float size = s.size/5.0f;\n    vec2 bottomleft = s.minR+vec2(size,size);\n    \n    for (int x = 0; x < 5; x++)\n    {\n        for (int y = 0; y < 5; y++)\n        {\n            float thisX = bottomleft.x+(float(x)*sideLength);\n            float thisY = bottomleft.y+(float(y)*sideLength);\n        \n            vec2 thisP = vec2(thisX, thisY);\n            vec3 co = vec3(float(x)/5.0f, float(y)/5.0f, 0.0f);\n            if (top&&col == co)\n            {\n                DrawSquare(col, p, newSquare(thisP, size, vec3(1)));\n            }\n            else\n            {\n                DrawSquare(col, p, newSquare(thisP, size, co));\n            }\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = vec3(0);\n    vec2 middle = iResolution.xy/2.0f;\n    \n    //VARIABLES\n    vec2 innerBoxPos = middle+vec2(sin(iTime)*50.0f, cos(iTime)*50.0f);\n    //END\n    \n    Square b = newSquare(middle, 100.0f, vec3(1,1,1));\n    DrawBoxArray(col, fragCoord, b, false);\n    DrawHollowSquare(col, fragCoord,b, 2.0f);\n    \n    Square f = newSquare(innerBoxPos, 50.0f, vec3(0));\n    DrawBoxArray(col, fragCoord, f, true);\n    DrawHollowSquare(col, fragCoord, f, 2.0f);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}