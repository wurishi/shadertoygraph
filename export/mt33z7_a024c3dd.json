{"ver":"0.1","info":{"id":"mt33z7","date":"1682444101","viewed":621,"name":"SWAMP STALKER","username":"alro","description":"After years of studying these bizarre creatures, professor Foster became convinced that they were in fact the larval stage of something he'd rather not think about.","likes":70,"published":1,"flags":32,"usePreview":0,"tags":["sss","transparent","scattering","organic","translucent","skin","gyroid","pbr","transmission","flesh"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n    Exploring rough transmission and subsurface scattering. Use mouse to move camera.\n    \n    Buffer B generates a pre-integrated subsurface scattering texture.\n    Buffer C renders the interior geometry.\n    \n    The Image tab renders the exterior geometry and blends with the interior by blurring \n    based on depth.\n    \n    See Common tab to reduce the interior render resolution and improve performance.\n    \n    Bicubic blur for rough transmission based on:\n    \n    https://developer.download.nvidia.com/SDK/9.5/Samples/DEMOS/OpenGL/src/fast_third_order/docs/Gems2_ch20_SDK.pdf\n    https://0xef.wordpress.com/2013/01/12/third-order-texture-filtering-using-linear-interpolation/\n    https://www.shadertoy.com/view/Dl2SDW\n    https://www.shadertoy.com/view/4df3Dn\n    https://stackoverflow.com/questions/13501081/efficient-bicubic-filtering-code-in-glsl\n\n*/\n\n//#define DISPLAY_INTERIOR\n\n//#define DISPLAY_SSS_TEXTURE\n\n// Only for one light\n//#define DISPLAY_SSS\n\nconst float topTransmission = 0.75;\nconst float bottomTransmission = 0.0;\n\nvec3 baseColour = 0.15 * vec3(0.9, 0.9, 0.95);\nvec3 detailColour = 0.1 * vec3(0.8, 0.3, 0.3);\n\nconst float SHADOW_SHARPNESS = 8.0;\n\nconst float EPSILON = 1e-4;\nconst float MIN_DIST = 0.01;\nconst int MAX_STEPS = 60;\nconst float MAX_DIST = 8.0;\nconst vec3 DETAIL_SCALE = vec3(0.15);\nconst vec3 BLENDING_SHARPNESS = vec3(2.0);\nconst float DETAIL_HEIGHT = 0.02;\n\n//----------------------------- Rotations -----------------------------\n\nvec3 rotate(vec3 p, vec4 q){\n  return 2.0 * cross(q.xyz, p * q.w + cross(q.xyz, p)) + p;\n}\nvec3 rotateX(vec3 p, float angle){\n    return rotate(p, vec4(sin(angle/2.0), 0.0, 0.0, cos(angle/2.0)));\n}\nvec3 rotateY(vec3 p, float angle){\n\treturn rotate(p, vec4(0.0, sin(angle/2.0), 0.0, cos(angle/2.0)));\n}\nvec3 rotateZ(vec3 p, float angle){\n\treturn rotate(p, vec4(0.0, 0.0, sin(angle), cos(angle)));\n}\n\n//---------------------------- Operations -----------------------------\n\nfloat displacement(vec3 p){\n    return sin(p.x);\n}\n\nvec2 radialRepetition(vec2 p, float cells){\n    float an = TWO_PI/cells;\n    float fa = (atan(p.y,p.x)+an*0.5)/an;\n    float sym = an*floor(fa);\n    p.xy = mat2(cos(sym),-sin(sym), sin(sym), cos(sym))*p.xy;\n    return p;\n}\n\n//---------------------- Distance functions ----------------------\n//https://iquilezles.org/articles/distfunctions/\n\nfloat sdBox( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdRoundCone( vec3 p, float r1, float r2, float h ){\n    vec2 q = vec2( length(p.xz), p.y );\n\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n\n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n\n    return dot(q, vec2(a,b) ) - r1;\n}\n\n\n//------------------------- Geometry -------------------------\n\nfloat legSDF(vec3 p){\n\n    float dist = 1e5;\n    vec3 q = p;\n    \n    q.y += 1.35;\n    q.x -= 0.8;\n    q = rotateY(q, PI/6.0);\n\n    q.xz = radialRepetition(q.xz, 6.0);\n    \n    q.y += 0.05*(0.5+0.5*displacement(12.0*q));\n    \n    q.x -= 0.45;\n    q = rotateZ(q, -0.4);\n    dist = sdRoundCone(q, 0.09, 0.2, 1.0);\n    \n    q = rotateZ(q, 0.9);\n    dist = smoothMin(dist, sdRoundCone(q, 0.089, 0.07, 0.85), 0.0);\n    \n    q.y -= 0.85;\n    q = rotateZ(q, 0.85);\n    dist = smoothMin(dist, sdRoundCone(q, 0.07, 0.03, 0.5), 0.0);\n    \n    q.y -= 0.5;\n    q = rotateZ(q, 0.45);\n    dist = smoothMin(dist, sdRoundCone(q, 0.03, 0.005, 0.65), 0.0);\n    \n    dist = smoothSub(-sdBox(q, vec3(2.0, 2.0, 0.05)), dist, 0.05);\n    \n    return 0.8*dist;\n}\n\nfloat eyeSDF(vec3 p){\n\n    float dist = 1e5;\n    vec3 q = p;\n   \n    q.x -= 1.1;\n    q.y += 0.8;\n    q.z = abs(q.z);\n    q.z -= 0.15;\n    dist = sphereSDF(q, 0.115);\n\n    q.z -= 0.15;\n    q.x += 0.05;\n    dist = min(dist, sphereSDF(q, 0.075));\n\n    q.y -= 0.125;\n    q.z += 0.05;\n    q.x -= 0.075;\n    dist = min(dist, sphereSDF(q, 0.075));\n    \n    return dist;\n}\n\nfloat bodySDF(vec3 p){\n    float dist = 1e5;\n    vec3 q = p;\n    \n    q.y -= 0.1;\n    dist = sphereSDF(q, 1.1);\n    q.y -= 0.8;\n    q.x += 0.8;\n    dist = smoothMin(dist, sphereSDF(q, 0.2), 1.2);\n    \n    return dist;\n}\n\nfloat getSDF(vec3 p, vec3 dir, out float transmission){\n\n    p -= modelOffset;\n\n    transmission = bottomTransmission;\n\n    float dist = 1e5;\n    vec3 q = p;\n    \n    float previousDist = dist;\n\n    // Legs\n    if(testAABB(p, dir, vec3(-0.45, -2.0, -1.4), \n                        vec3(2.1, -0.8, 1.4))){\n        q = p;\n        q.x -= 0.75;\n        q.y += 1.05;\n        dist = sphereSDF(q, 0.3);\n        dist = smoothMin(dist, legSDF(p), 0.04);\n\n        if(previousDist > dist){\n                previousDist = dist;\n                transmission = bottomTransmission;\n        }\n    }\n    \n    // Body\n    if(testAABB(p, dir, vec3(-1.3, -2.0, -1.1), \n                        vec3(1.2, 1.8, 1.1))){\n        q = p;\n        dist = min(bodySDF(q), dist);\n\n        if(previousDist > dist){\n                previousDist = dist;\n                q = p;\n                q = rotateZ(q, -0.25);\n                transmission = mix(bottomTransmission, topTransmission, \n                                            smoothstep(-1.0, 0.0, q.y));\n        }\n    }\n    \n    // Head\n    if(testAABB(p, dir, vec3(0.0, -1.25, -0.75), \n                        vec3(1.3, 0.1, 0.75))){\n        q = p;\n        q.x -= 0.75;\n        q.y += 0.6;\n\n        // Mix transmission using smoothMin\n        transmission = mix( bottomTransmission, \n                            transmission, \n                            saturate(0.5+0.5*(sphereSDF(q, 0.5)-dist)/0.2));\n                            \n        dist = smoothMin(dist, sphereSDF(q, 0.5), 0.2);\n\n        if(previousDist > dist){\n                previousDist = dist;\n        }\n    }\n\n    // Eyes\n    if(testAABB(p, dir, vec3(1.0, -1.0, -0.4), \n                        vec3(1.3, -0.6, 0.4))){\n        q = p;\n        dist = min(dist, eyeSDF(q));\n\n        if(previousDist > dist){\n                transmission = bottomTransmission;\n                previousDist = dist;\n        }\n    }\n    return dist;\n}\n\nfloat distanceToScene(vec3 cameraPos, vec3 rayDir, float start, float end, \n                      out float transmission) {\n\t\n    float depth = start;\n    \n    float dist;\n    \n    for (int i = ZERO; i < MAX_STEPS; i++){\n\n        dist = getSDF(cameraPos + depth * rayDir, rayDir, transmission);\n\n        if (dist < EPSILON){ return depth; }\n\n        depth += dist;\n\n        if (depth >= end){ return end; }\n    }\n    \n    return depth;\n}\n\n// Tetrahedral normal technique with a loop to avoid inlining getSDF()\n// This should improve compilation times\n// https://iquilezles.org/articles/normalsSDF\nvec3 getNormal(vec3 p, vec3 dir){\n    vec3 n = vec3(0.0);\n    float t;\n    for(int i = ZERO; i < 4; i++){\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*getSDF(p+e*EPSILON, dir, t);\n    }\n    return normalize(n);\n}\n\nfloat getTriplanar(vec3 position, vec3 normal){\n    float xaxis = texture(iChannel1, DETAIL_SCALE.x*(position.zy)).a;\n    float yaxis = texture(iChannel1, DETAIL_SCALE.y*(position.zx)).a;\n    float zaxis = texture(iChannel1, DETAIL_SCALE.z*(position.xy)).a;\n\n    vec3 blending = abs(normal);\n\tblending = normalize(max(blending, 0.00001));\n    blending = pow(blending, BLENDING_SHARPNESS);\n\tfloat b = (blending.x + blending.y + blending.z);\n\tblending /= b;\n\n    return\txaxis * blending.x + \n       \t\tyaxis * blending.y + \n        \tzaxis * blending.z;\n}\n\n\n// Return the position of p extruded in the normal direction by normal map\nvec3 getDetailExtrusion(vec3 p, vec3 normal){\n    float detail = DETAIL_HEIGHT*length(getTriplanar(p, normal));\n    return p + detail * normal;\n}\n\n// Get orthonormal basis from surface normal\n// https://graphics.pixar.com/library/OrthonormalB/paper.pdf\nvoid pixarONB(vec3 n, out vec3 b1, out vec3 b2){\n\tfloat sign_ = n.z >= 0.0 ? 1.0 : -1.0;\n\tfloat a = -1.0 / (sign_ + n.z);\n\tfloat b = n.x * n.y * a;\n\tb1 = vec3(1.0 + sign_ * n.x * n.x * a, sign_ * b, -sign_ * n.x);\n\tb2 = vec3(b, sign_ + n.y * n.y * a, -n.y);\n}\n\n// Return the normal direction after applying a normal map\nvec3 getDetailNormal(vec3 p, vec3 normal){\n    vec3 tangent;\n    vec3 bitangent;\n    // Construct orthogonal directions tangent and bitangent to sample detail gradient in\n    pixarONB(normal, tangent, bitangent);\n    \n    tangent = normalize(tangent);\n    bitangent = normalize(bitangent);\n    \n    float EPS = 1e-3;\n    vec3 delTangent = \tgetDetailExtrusion(p + tangent * EPS, normal) - \n        \t\t\t\tgetDetailExtrusion(p - tangent * EPS, normal);\n    \n    vec3 delBitangent = getDetailExtrusion(p + bitangent * EPS, normal) - \n        \t\t\t\tgetDetailExtrusion(p - bitangent * EPS, normal);\n    \n    return normalize(cross(delTangent, delBitangent));\n}\n\n\n//---------------------------- Transmission ----------------------------\n\n// Cubic B-spline weighting\nvec2 w0(vec2 a){\n    return (1.0/6.0)*(a*(a*(-a + 3.0) - 3.0) + 1.0);\n}\n\nvec2 w1(vec2 a){\n    return (1.0/6.0)*(a*a*(3.0*a - 6.0) + 4.0);\n}\n\nvec2 w2(vec2 a){\n    return (1.0/6.0)*(a*(a*(-3.0*a + 3.0) + 3.0) + 1.0);\n}\n\nvec2 w3(vec2 a){\n    return (1.0/6.0)*(a*a*a);\n}\n\n// g0 is the amplitude function\nvec2 g0(vec2 a){\n    return w0(a) + w1(a);\n}\n\n// h0 and h1 are the two offset functions\nvec2 h0(vec2 a){\n    return -1.0 + w1(a) / (w0(a) + w1(a));\n}\n\nvec2 h1(vec2 a){\n    return 1.0 + w3(a) / (w2(a) + w3(a));\n}\n\nvec4 bicubic(sampler2D tex, vec2 uv, vec2 textureLodSize, float lod){\n\t\n    uv = uv * textureLodSize + 0.5;\n    \n\tvec2 iuv = floor(uv);\n\tvec2 f = fract(uv);\n\n    // Find offset in texel\n    vec2 h0 = h0(f);\n    vec2 h1 = h1(f);\n\n    // Four sample points\n\tvec2 p0 = (iuv + h0 - 0.5) / textureLodSize;\n\tvec2 p1 = (iuv + vec2(h1.x, h0.y) - 0.5) / textureLodSize;\n\tvec2 p2 = (iuv + vec2(h0.x, h1.y) - 0.5) / textureLodSize;\n\tvec2 p3 = (iuv + h1 - 0.5) / textureLodSize;\n\t\n    // Weighted linear interpolation\n    // g0 + g1 = 1 so only one is needed for a mix\n    vec2 g0 = g0(f);\n    return mix( mix(textureLod(tex, p3, lod), textureLod(tex, p2, lod), g0.x),\n                mix(textureLod(tex, p1, lod), textureLod(tex, p0, lod), g0.x), g0.y);\n}\n\nvec4 textureBicubic(sampler2D s, vec2 uv, float lod) {\n\n    vec2 lodSizeFloor = vec2(textureSize(s, int(lod)));\n    vec2 lodSizeCeil = vec2(textureSize(s, int(lod + 1.0)));\n\n    vec4 floorSample = bicubic(s, uv, lodSizeFloor.xy, floor(lod));\n    vec4 ceilSample = bicubic(s, uv, lodSizeCeil.xy, ceil(lod));\n\n    return mix(floorSample, ceilSample, fract(lod));\n}\n\nvec4 getRoughTransmission(sampler2D s, vec2 uv, float roughness){\n    float maxLod = floor(log2(iChannelResolution[3].x));\n    float lod = mix(0.0, maxLod-1.0, roughness * roughness);\n    \n    return textureBicubic(s, uv, lod);\n}\n\n//---------------------------- Material ----------------------------\n\nvec3 getAlbedo(vec3 p){\n    p -= modelOffset;\n    \n    p*= 32.0;\n    float g = dot(sin(p), cos(p.zxy));\n    p *= 0.5;\n    g += dot(sin(p), cos(p.zxy));\n\n    return mix(baseColour, detailColour, smoothstep(0.0, 5.8, g));\n}\n\n//---------------------------- PBR ----------------------------\n\n// Trowbridge-Reitz\nfloat distribution(vec3 n, vec3 h, float roughness){\n    float a_2 = roughness * roughness;\n\treturn a_2/(PI * pow(pow(dot_c(n, h), 2.0) * (a_2 - 1.0) + 1.0, 2.0));\n}\n\n// GGX and Schlick-Beckmann\nfloat geometry(float cosTheta, float k){\n\treturn (cosTheta) / (cosTheta * (1.0 - k) + k);\n}\n\nfloat smiths(float NdotV, float NdotL, float roughness){\n    float k = pow(roughness + 1.0, 2.0) / 8.0; \n\treturn geometry(NdotV, k) * geometry(NdotL, k);\n}\n\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness){\n    return F0 + (max(vec3(1.0-roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n// Cook-Torrance BRDF\nfloat specularBRDF(vec3 n, vec3 viewDir, vec3 lightDir, vec3 h, float roughness){\n    \n    // Normal distribution\n    // What fraction of microfacets are aligned in the correct direction\n    float D;\n\n    // Geometry term\n    // What fraction of the microfacets are lit and visible\n    float G;\n    \n    // Visibility term. \n    // In Filament it combines the geometry term and the denominator\n    float V;\n    \n    float NdotL = dot_c(lightDir, n);\n    float NdotV = dot_c(viewDir, n);\n    \n    D = distribution(n, h, roughness);\n    G = smiths(NdotV, NdotL, roughness);\n    V = G / max(0.0001, (4.0 * NdotV * NdotL));\n        \n    // Specular reflectance\n    return D * V;\n}\n\n//---------------------------- Shadows ----------------------------\n\n// https://iquilezles.org/articles/rmshadows\nfloat softShadow(vec3 pos, vec3 rayDir, float start, float end, float k ){\n    float res = 1.0;\n    float depth = start;\n    float t;\n    for(int counter = ZERO; counter < 16; counter++){\n        float dist = getSDF(pos + rayDir * depth, rayDir, t);\n        if( abs(dist) < EPSILON){ return 0.0; }       \n        if( depth > end){ break; }\n        res = min(res, k*dist/depth);\n        depth += dist;\n    }\n    return saturate(res);\n}\n\n//---------------------------- Lighting ----------------------------\n\nvec3 getAmbientLight(vec3 normal){\n    vec3 gradient = mix(vec3(0.15), vec3(2), 0.5+0.5*normal.y);\n    return mix(gradient, 4.0*getEnvironment(normal), 0.15);\n}\n\nvec3 getTransmitted(vec2 uv, float t){\n\n    vec4 background = texture(iChannel3, uv * RENDER_SCALE);\n\n    float dist = background.a - t;\n    float roughness = mix(0.4, 0.7, smoothstep(0.0, 0.65, dist));\n    if(background.a < 0.0){\n        roughness = 0.7;\n    }\n\n    vec4 roughBackground = getRoughTransmission(iChannel3, uv * RENDER_SCALE, roughness);\n    vec3 col = vec3(0);\n    col = roughBackground.rgb;\n    return col;\n}\n\nvec3 getIrradiance(vec3 p, vec3 rayDir, vec3 geoNormal, vec2 uv, float t, float transmission){\n    \n    vec3 I = vec3(0);\n    vec3 radiance = vec3(0);\n    vec3 lightDir = vec3(0);\n    vec3 vectorToLight = vec3(0);\n    \n    vec3 albedo = getAlbedo(p);\n    \n    // Tint legs\n    albedo = mix(0.5*vec3(1.0,0.1,0.1) * albedo, albedo, smoothstep(-1.4, -0.5, p.y));\n    \n    vec3 n = getDetailNormal(p, geoNormal);\n  \n    float metalness = 0.0;\n    float roughness = 0.175;\n    roughness = mix(roughness, 0.1, metalness);\n\n    float IOR = 1.44;\n\n    float eyeWeight = smoothstep(5e-3, 0.0, eyeSDF(p - modelOffset));\n\n    albedo = mix(albedo, vec3(0), eyeWeight);\n    n = mix(n, geoNormal, eyeWeight);\n    IOR = mix(IOR, 2.0, eyeWeight);\n    roughness = mix(roughness, 0.05, eyeWeight);\n    \n    // Reflectance of the surface when looking straight at it along the negative normal\n    vec3 F0 = vec3(pow(IOR - 1.0, 2.0) / pow(IOR + 1.0, 2.0));\n    \n    // Metal uses gold reflectance\n    F0 = mix(F0, vec3(1.022, 0.782, 0.344), metalness);\n    \n    vec3 directDiffuse = vec3(0);\n    vec3 directSpecular = vec3(0);\n    \n    // Find direct lighting for all sources\n    for(int i = ZERO; i < 2; i++){\n        \n        vec3 position = getLightPosition(i);\n        vectorToLight = position - p;\n        lightDir = normalize(vectorToLight);\n        radiance = i == 0 ? 1.0 * vec3(1.0) : 1.0 * vec3(0.45, 0.75, 1.0);\n        \n        float shadow = softShadow(p + n * EPSILON * 2.0, lightDir, MIN_DIST, \n                                                        MAX_DIST, SHADOW_SHARPNESS);\n                                                        \n        vec3 h = normalize(-rayDir + lightDir);\n        // Fresnel term\n        // How reflective are the microfacets viewed from the current angle\n        vec3 F = fresnelSchlickRoughness(dot_c(h, -rayDir), F0, roughness);\n        vec3 specular = F * specularBRDF(n, -rayDir, lightDir, h, roughness);\n        \n        float d = 0.5 + 0.5 * dot(geoNormal, lightDir);\n        vec3 sss = 0.5 * texture(iChannel1, vec2(max(d, 0.001), 0.75)).rgb;\n\n#ifdef DISPLAY_SSS\n        return sss;\n#endif\n        directDiffuse += sss * albedo * radiance;\n        directSpecular += shadow * specular * radiance * dot_c(n, lightDir);\n    }\n    \n    // Use simple gradient for diffuse ambient light\n    vec3 F = fresnelSchlickRoughness(dot_c(n, -rayDir), F0, roughness);\n\tvec3 kD = (1.0 - F) * (1.0 - metalness);\n\tvec3 irradiance = getAmbientLight(n);\n\tvec3 ambientDiffuse = kD * irradiance * albedo / PI;\n\n    // Use low LOD of cubemap for specular ambient\n    vec3 env = 0.225 * textureLod(iChannel2, normalize(reflect(rayDir, n)), 4.0).rgb;\n    vec3 ambientSpecular = env * F;\n    \n    vec3 diffuse = directDiffuse + ambientDiffuse;\n    \n    diffuse = mix(diffuse + directDiffuse, getTransmitted(uv, t), transmission);\n    \n    // Combine direct and ambient lighting\n    return  diffuse + directSpecular + ambientSpecular;\n}\n\n//-------------------------- Tonemap and render -------------------------\n\n// https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x){\n    return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n\t//----------------- Define a camera -----------------\n    \n    vec3 rayDir = rayDirection(60.0, fragCoord, iResolution.xy);\n\n    vec3 cameraPos = texelFetch(iChannel0, ivec2(0.5, 1.5), 0).xyz;\n    vec3 targetDir = -cameraPos;\n    vec3 up = vec3(0.0, 1.0, 0.0);\n\n    // Get the view matrix from the camera orientation.\n    mat3 viewMatrix = lookAt(cameraPos, targetDir, up);\n\n    // Transform the ray to point in the correct direction.\n    rayDir = normalize(viewMatrix * rayDir);\n\n    //---------------------------------------------------\n\n    vec3 p = vec3(0);\n    vec3 col = vec3(0);\n    \n    float t = MAX_DIST;\n    float transmission = 0.0;\n\n    if(testAABB(cameraPos, rayDir, vec3(-1.3, -2.0, -1.4) + modelOffset, \n                                   vec3(2.1, 1.4, 1.4) + modelOffset)){\n        t = distanceToScene(cameraPos, rayDir, MIN_DIST, MAX_DIST, transmission);\n    }\n    \n    if(t < MAX_DIST){\n        p = cameraPos + rayDir * t;\n        vec3 normal = getNormal(p, rayDir);\n        col = getIrradiance(p, rayDir, normal, uv, t, transmission);\n    } else {\n        col = 0.1 * getEnvironment(rayDir);\n    }\n    \n#ifdef DISPLAY_INTERIOR\n    col = getRoughTransmission(iChannel3, uv*RENDER_SCALE, 0.0).rgb;\n#endif\n#ifdef DISPLAY_SSS_TEXTURE\n    col = texture(iChannel1, uv).rgb;\n#endif\n    \n    col = ACESFilm(col);\n    col = gamma(col);\n        \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Track mouse movement and resolution change between frames and set camera position.\n\n#define CAMERA_DIST 4.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // Work with just the first four pixels.\n    if((fragCoord.x == 0.5) && (fragCoord.y < 4.0)){\n        \n        vec4 oldData = texelFetch(iChannel0, ivec2(0.5), 0).xyzw;\n\n        vec2 oldPolarAngles = oldData.xy;\n        vec2 oldMouse = oldData.zw;\n\n        vec2 polarAngles = vec2(0);\n        vec2 mouse = iMouse.xy / iResolution.xy; \n        \n        // Stop camera going directly above and below\n        float angleEps = 0.01;\n\n        float mouseDownLastFrame = texelFetch(iChannel0, ivec2(0.5, 3.5), 0).x;\n        \n        // If mouse button is down and was down last frame.\n        if(iMouse.z > 0.0 && mouseDownLastFrame > 0.0){\n            \n            // Difference between mouse position last frame and now.\n            vec2 mouseMove = mouse - oldMouse;\n            polarAngles = oldPolarAngles + vec2(5.0, 3.0) * mouseMove;\n            \n        }else{\n            polarAngles = oldPolarAngles;\n        }\n        \n        polarAngles.x = mod(polarAngles.x, 2.0 * PI - angleEps);\n        polarAngles.y = min(PI - angleEps, max(angleEps, polarAngles.y));\n\n        // Store mouse data in the first pixel of Buffer A.\n        if(fragCoord == vec2(0.5, 0.5)){\n            // Set value at first frames.\n            if(iFrame < 10){\n                polarAngles = vec2(2.9, 1.7);\n                mouse = vec2(0);\n            }\n            \n            fragColor = vec4(polarAngles, mouse);\n        }\n\n        // Store camera position in the second pixel of Buffer A.\n        if(fragCoord == vec2(0.5, 1.5)){\n            // Cartesian direction from polar coordinates.\n            vec3 cameraPos = normalize(vec3(-cos(polarAngles.x) * sin(polarAngles.y), \n                                             cos(polarAngles.y), \n                                            -sin(polarAngles.x) * sin(polarAngles.y)));\n\n            fragColor = vec4(CAMERA_DIST * cameraPos, 1.0);\n        }\n        \n        // Store resolution change data in the third pixel of Buffer A.\n        if(fragCoord == vec2(0.5, 2.5)){\n            float resolutionChangeFlag = 0.0;\n            // The resolution last frame.\n            vec2 oldResolution = texelFetch(iChannel0, ivec2(0.5, 2.5), 0).yz;\n            \n            if(iResolution.xy != oldResolution){\n            \tresolutionChangeFlag = 1.0;\n            }\n            \n        \tfragColor = vec4(resolutionChangeFlag, iResolution.xy, 1.0);\n        }\n           \n        // Store whether the mouse button is down in the fourth pixel of Buffer A\n        if(fragCoord == vec2(0.5, 3.5)){\n            if(iMouse.z > 0.0){\n            \tfragColor = vec4(vec3(1.0), 1.0);\n            }else{\n            \tfragColor = vec4(vec3(0.0), 1.0);\n            }\n        }\n        \n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/*\n    Copyright (c) 2023 al-ro\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the \"Software\"), to deal\n    in the Software without restriction, including without limitation the rights\n    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all\n    copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n    SOFTWARE.\n*/\n\nconst vec3 modelOffset = vec3(-0.5, 0.5, 0);\n\n// Size of canvas that renders interior and is then stretched across the whole view.\n// Reduce at full screen\n// Between 0 and 1\n#define RENDER_SCALE (iResolution.x < 2048.0 ? 1.0 : 0.5)\n\n#define PI 3.14159\n#define TWO_PI (2.0 * PI)\n#define HALF_PI (0.5 * PI)\n\n#define GAMMA 2.2\n#define INV_GAMMA (1.0/GAMMA)\n\n//  Variable iterator initializer to stop loop unrolling\n#define ZERO (min(iFrame,0))\n\n// Minimum dot product value\nconst float minDot = 1e-3;\n\n// Clamped dot product\nfloat dot_c(vec3 a, vec3 b){\n\treturn max(dot(a, b), minDot);\n}\n\nvec3 gamma(vec3 col){\n\treturn pow(col, vec3(INV_GAMMA));\n}\n\nfloat saturate(float x){\n    return max(0.0, min(x, 1.0));\n}\n\n//-------------------------- AABB -------------------------\n\n// Only evaluate the distance function when near a feature or when looking at it.\n// This improves performance as we skip complex distance calculations for many pixels.\n\n// https://gist.github.com/DomNomNom/46bb1ce47f68d255fd5d\n// Compute the near and far intersections using the slab method.\n// No intersection if tNear > tFar.\nvec2 intersectAABB(vec3 rayOrigin, vec3 rayDir, vec3 boxMin, vec3 boxMax) {\n    vec3 tMin = (boxMin - rayOrigin) / rayDir;\n    vec3 tMax = (boxMax - rayOrigin) / rayDir;\n    vec3 t1 = min(tMin, tMax);\n    vec3 t2 = max(tMin, tMax);\n    float tNear = max(max(t1.x, t1.y), t1.z);\n    float tFar = min(min(t2.x, t2.y), t2.z);\n    return vec2(tNear, tFar);\n}\n\nbool insideAABB(vec3 p, vec3 boxMin, vec3 boxMax){\n    float eps = 1e-4;\n\treturn  (p.x > boxMin.x-eps) && (p.y > boxMin.y-eps) && (p.z > boxMin.z-eps) && \n\t\t\t(p.x < boxMax.x+eps) && (p.y < boxMax.y+eps) && (p.z < boxMax.z+eps);\n}\n\nbool testAABB(vec3 org, vec3 dir, vec3 boxMin, vec3 boxMax){\n\tvec2 intersections = intersectAABB(org, dir, boxMin, boxMax);\n\t\n    if(insideAABB(org, boxMin, boxMax)){\n        intersections.x = 1e-4;\n    }\n    \n    return intersections.x > 0.0 && (intersections.x < intersections.y);\n}\n\nvec3 getEnvironment(vec3 dir){\n    return mix(0.5*vec3(0.5, 0.3, 0.1), 0.5*vec3(0.09, 0.81, 0.35), 0.5+0.5*dir.y);\n}\n\n\n//-------------------------- Lights -------------------------\n\nvec3 getLightPosition(int i){\n\n    float offset = -1.0;\n\n    if(i == 0){\n        return vec3(30.0*cos(offset+0.2), 8.0, -30.0*sin(offset+0.2)); \n    }\n    return vec3(20.0*cos(3.2+offset), 1.0,  -20.0*sin(3.2+offset));\n}\n\n//---------------------------- Camera -----------------------------\n\nvec3 rayDirection(float fieldOfView, vec2 fragCoord, vec2 resolution) {\n    vec2 xy = fragCoord - resolution / 2.0;\n    float z = (0.5 * resolution.y) / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n// https://www.geertarien.com/blog/2017/07/30/breakdown-of-the-lookAt-function-in-OpenGL/\nmat3 lookAt(vec3 camera, vec3 at, vec3 up){\n  vec3 zaxis = normalize(at-camera);    \n  vec3 xaxis = normalize(cross(zaxis, up));\n  vec3 yaxis = cross(xaxis, zaxis);\n\n  return mat3(xaxis, yaxis, -zaxis);\n}\n\n//---------------------------- Operations -----------------------------\n\nfloat smoothSub( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\n// https://iquilezles.org/articles/smin\nfloat smoothMin(float a, float b, float k){\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n//---------------------- Distance functions ----------------------\n//https://iquilezles.org/articles/distfunctions/\n\nfloat sphereSDF(vec3 p, float radius) {\n    return length(p) - radius;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*\n\n    Pre-integrated screen-space subsurface scattering based on:\n\n    https://therealmjp.github.io/posts/sss-intro/\n    https://dokumen.tips/documents/advances-in-real-time-rendering-in-games-pre-integrated-skin-shading-eric-penner.html\n    https://developer.nvidia.com/gpugems/gpugems3/part-iii-rendering/chapter-14-advanced-techniques-realistic-real-time-skin\n    https://www.shadertoy.com/view/4tXBWr\n    https://www.shadertoy.com/view/dt2SWh\n*/\n\n\n// Gaussian definition from Nvidia article although different from standard form\n// v: variance\n// x: evaluation position\nfloat gaussian(float v, float x){\n\treturn 1.0/sqrt(TWO_PI*v)*exp(-(x*x)/(2.0*v));\n}\n\n// Scattering profile for human skin from Nvidia article\nvec3 getProfile(float x){\n    return gaussian(0.0064, x) * vec3(0.233, 0.455, 0.649) +\n    \t   gaussian(0.0484, x) * vec3(0.100, 0.336, 0.344) +\n    \t   gaussian(0.1870, x) * vec3(0.118, 0.198, 0.000) +\n    \t   gaussian(0.5670, x) * vec3(0.113, 0.007, 0.007) +\n    \t   gaussian(1.9900, x) * vec3(0.358, 0.004, 0.000) +\n    \t   gaussian(7.4100, x) * vec3(0.078, 0.000, 0.000);\n}\n\n/*\n  We want to find the amount of light that travels to the evaluated point through a \n  sphere of a given radius. For this we sample points around a circle, integrating \n  the light contribution from each sample point. We find the amount of light arriving \n  at the sample point using the diffuse Lambertian term, calculate the path length \n  through the sphere and find the amount of light that remains after scattering along \n  this path using the scattering profile. Due to symmetry, this can be done in 2D.\n*/\nvec3 integrateProfile(float angle, float r){\n\n    vec3 totalLight = vec3(0);\n    vec3 weight = vec3(0);\n\n    // Higher count gives more accurate results\n    const float STEPS = 128.0;\n    float delta = TWO_PI / STEPS;\n\n    // Sample points in a circle\n    for(float theta = 0.0; theta < TWO_PI; theta += delta){\n\n        /*\n          The distance that light travels from the sample point to the evaluated point\n          is the length of the chord between these two points. This assumes light travels \n          straight and does not scatter multiple times. This is the formula for a chord\n          length of a circle given an angle and a radius.\n          https://en.wikipedia.org/wiki/Chord_(geometry)\n        */\n        float dist = 2.0 * r * sin(0.5 * theta);\n        \n        // The amount of light that remains while travelling from the sample point\n        // to the evaluated point is determined by the scattering profile.\n        vec3 scattering = getProfile(dist);\n\n        // The amount of light at the sample point is determined by its normal in relation\n        // to the incoming light direction - the diffuse Lambertian term.\n        totalLight += max(0.0, cos(angle + theta)) * scattering;\n        \n        // Accumulate the light contribution to normalize the integral\n        weight += scattering;\n    }\n    \n    // Return normalized integral of all incoming light at the evaluation point.\n    return totalLight / weight;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    bool resolutionChanged = texelFetch(iChannel1, ivec2(0.5, 2.5), 0).r > 0.0;\n    \n    if(iFrame == 0 || resolutionChanged){\n        // Normalized pixel coordinates (from 0 to 1)\n        vec2 uv = fragCoord/iResolution.xy;\n        vec3 col = integrateProfile(PI - uv.x * PI, 1.0 / uv.y);\n        fragColor = vec4(col, 1.0);\n    }else{\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        \n        vec3 normalMap = texture(iChannel2, fragCoord/iResolution.xy).rgb;\n        fragColor.a = saturate(length(normalMap));\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"/*\n\n    Gyroid surface based on:\n    \n    https://en.wikipedia.org/wiki/Gyroid\n    https://www.shadertoy.com/view/wddfDM\n    \n    Use simple diffuse shading for performance reasons\n*/\n\nconst float SHADOW_SHARPNESS = 8.0;\n\nconst float EPSILON = 1e-4;\nconst float MIN_DIST = 0.01;\nconst int MAX_STEPS = 60;\nconst float MAX_DIST = 8.0;\n\n// https://www.shadertoy.com/view/wddfDM\nfloat gyroid(vec3 p, float scale, float thickness, float bias) {\n    p *= scale;\n    return abs(dot(sin(1.1*p), cos(0.9*p.zxy)) - bias) / scale - thickness;\n}\n\n//---------------------------- Operations -----------------------------\n\nfloat displacement(vec3 p){\n    return dot(sin(p), cos(p.zxy));\n}\n\n\n//------------------------- Geometry -------------------------\n\nfloat getSDF(vec3 p, vec3 dir){\n    \n    p -= modelOffset;\n    \n    float dist = 1e5;\n    \n    if(testAABB(p, dir, vec3(-1.0, -0.95, -1.0), \n                            vec3(1.0, 1.05, 1.0))){\n        p.y -= 0.05;\n\n        p += 0.01 * displacement(-iTime + 3.0 * p);\n\n        float scale = 6.0;\n\n        dist = sphereSDF(p, 1.0);\n        dist = smoothSub(-gyroid(p, scale, 0.1, 0.0), dist, 0.1);\n        dist = smoothSub(-gyroid(p, scale + 32.0, 0.02, 0.0), dist, 0.03);\n\n        float dist2 = sphereSDF(p, 0.9);\n        dist2 = smoothSub(gyroid(p, scale, 0.1, 0.0), dist2, 0.1);\n        dist2 = smoothSub(-gyroid(p, scale + 16.0, 0.02, 0.0), dist2, 0.03);\n\n        dist = smoothMin(dist, dist2, 0.0);\n\n        return 0.5 * dist;\n    }else{\n        return dist;\n    }\n}\n\nfloat distanceToScene(vec3 cameraPos, vec3 rayDir, float start, float end) {\n\t\n    float depth = start;\n    \n    float dist;\n    \n    for (int i = ZERO; i < MAX_STEPS; i++){\n\n        dist = getSDF(cameraPos + depth * rayDir, rayDir);\n\n        if (dist < EPSILON){ return depth; }\n\n        depth += dist;\n\n        if (depth >= end){ return end; }\n    }\n    \n    return depth;\n}\n\n// Tetrahedral normal technique with a loop to avoid inlining getSDF()\n// This should improve compilation times\n// https://iquilezles.org/articles/normalsSDF\nvec3 getNormal(vec3 p, vec3 dir){\n    vec3 n = vec3(0.0);\n    for(int i = ZERO; i < 4; i++){\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*getSDF(p+e*EPSILON, dir);\n    }\n    return normalize(n);\n}\n\n//---------------------------- Shadows ----------------------------\n\n// https://iquilezles.org/articles/rmshadows\nfloat softShadow(vec3 pos, vec3 rayDir, float start, float end, float k){\n    float res = 1.0;\n    float depth = start;\n    for(int counter = ZERO; counter < 32; counter++){\n        float dist = getSDF(pos + rayDir * depth, rayDir);\n        if( abs(dist) < EPSILON){ return 0.0; }       \n        if( depth > end){ break; }\n        res = min(res, k*dist/depth);\n        depth += dist;\n    }\n    return res;\n}\n\n//---------------------------- Lighting ----------------------------\n\nvec3 getAmbientLight(vec3 normal){\n    vec3 gradient = mix(vec3(0.5), vec3(1), 0.5+0.5*normal.y);\n    return mix(gradient, getEnvironment(normal), 0.15);\n}\n\nvec3 getIrradiance(vec3 position, vec3 normal, vec3 rayDir){\n    \n    vec3 ambientColour = vec3(1, 0.3, 0.1) * getAmbientLight(normal);\n    vec3 diffuseColour = vec3(1);\n    \n    vec3 albedo = mix(vec3(1.0, 0.2, 0.01), 0.5 * vec3(0.6, 0.5, 0.2),  \n                  smoothstep(0.7, 1.0, length(position + vec3(0.0, -0.05, 0) - modelOffset)));\n    \n    vec3 direct = vec3(0);\n\n    // Find direct lighting for all sources\n    for(int i = ZERO; i < 2; i++){\n        \n        vec3 lightPos = getLightPosition(i);\n        vec3 lightDir = normalize(lightPos - position);\n    \n        // How much a fragment faces the light\n        float diff = max(dot(normal, lightDir), 0.0);\n    \n        vec3 diffuse = diff * diffuseColour;\n\n        float shadow = softShadow(position + normal * EPSILON * 2.0, lightDir, MIN_DIST,\n                              length(lightPos - position), SHADOW_SHARPNESS);\n                              \n        direct += shadow * 0.7 * diffuse;\n    }\n\n    return albedo * (0.3 * ambientColour + direct);\n}\n\n//-------------------------- Render -------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    if(fragCoord.x > iResolution.x * RENDER_SCALE || \n       fragCoord.y > iResolution.y * RENDER_SCALE){\n    \n        fragColor = vec4(0);\n        \n    }else{\n    \n        //----------------- Define a camera -----------------\n\n        vec3 rayDir = rayDirection(60.0, fragCoord, iResolution.xy * RENDER_SCALE);\n\n        vec3 cameraPos = texelFetch(iChannel0, ivec2(0.5, 1.5), 0).xyz;\n        vec3 targetDir = -cameraPos;\n        vec3 up = vec3(0.0, 1.0, 0.0);\n\n        // Get the view matrix from the camera orientation.\n        mat3 viewMatrix = lookAt(cameraPos, targetDir, up);\n\n        // Transform the ray to point in the correct direction.\n        rayDir = normalize(viewMatrix * rayDir);\n\n        //---------------------------------------------------\n\n        vec3 p = vec3(0);\n        vec3 col = vec3(0);\n\n        float t = MAX_DIST;\n        bool background = true;\n        if(testAABB(p, rayDir, vec3(-1.3, -2.0, -1.1) + modelOffset, \n                               vec3(1.2, 1.8, 1.1) + modelOffset)){\n\n            t = distanceToScene(cameraPos, rayDir, MIN_DIST, MAX_DIST);\n            if(t < MAX_DIST){\n                p = cameraPos + rayDir * t;\n                vec3 normal = getNormal(p, rayDir);\n                col = getIrradiance(p, normal, rayDir);\n                background = false;\n            } \n        }\n\n        if(background){\n            col = 0.1 * getEnvironment(rayDir);\n            t = -1.0;\n        }\n\n        fragColor = vec4(col, t);\n    }\n}","name":"Buffer C","description":"","type":"buffer"}]}