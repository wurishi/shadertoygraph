{"ver":"0.1","info":{"id":"3tc3WH","date":"1576156012","viewed":408,"name":"Simple 3D_shadow mapping","username":"lypion","description":"shadow mapping, shadow acne problem","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["shadowmapping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n---Main Content---\n\t1. Use shadow maping technique to implement the shadow. The basic idea of shadow mapping\n\t   is as follows:\n\t   a). render the scene from the light point of view and store the depth information\n\t       in the buffer.\n\t   b). transform the point you normally render now to the light space, then to the NDC space\n\t   c). use the transformed point's x and y as uv coordinate to sample the buffer, and we\n\t   \t   get the closest depth to the light.\n\t   d). compare the transformed point's z value to the closest depth. If it is smaller, \n\t\t   then the point we're render now is lit by the light, otherwise it's in the shadow.\n*/\n\n     \nmat4 perWorld2ViewMat;\nmat4 orthoViewMat;\n\nRay GeneratePerspectiveRay(PerspectiveCamera camera, vec2 uv)\n{\n    //map the center of the screen as the origin point\n\tuv -= vec2(0.5);\n    float halfHeight = tan(camera.fov / 2.0) * camera.frustum.nearestPlane;\n    float halfWidth = halfHeight / camera.aspectRatio;\n    vec3 pixelInViewSpace = vec3(0.0, 0.0, -camera.frustum.nearestPlane) + \n                 \t\t\tvec3(2.0 * uv.x * halfWidth * camera.aspectRatio * camera.aspectRatio, 0.0, 0.0) + \n                 \t\t\tvec3(0.0, 2.0 * uv.y * halfHeight, 0.0);\n    return Ray(vec3(0.0), normalize(pixelInViewSpace), RAY_MIN, RAY_MAX);\n}\n\nvec3 CalDirectLight(DirectLight light, Intersection intersection, vec3 viewPos)\n{   \n    //diffuse\n    float diff = max(0.0, dot(-light.direction, intersection.normal));\n    vec3 diffuse = diff * light.color * intersection.color.diffuse;\n    \n    //specular\n    vec3 viewDirect = normalize(viewPos - (intersection.ray.origin + intersection.t * intersection.ray.direction));\n    vec3 h = normalize(-light.direction + viewDirect);\n    vec3 specular = light.color * intersection.color.specular * pow(max(0.0, dot(intersection.normal, h)), intersection.color.shininess);\n\t\n    return diffuse + specular;\n}\n\nIntersection ViewSpaceRayTracing(PerspectiveCamera camera, vec2 uv)\n{\n    mat4 world2view = LookAt(camera.position, camera.target, vec3(0.0, 1.0, 0.0)); \n    sphere.position = vec3(world2view * vec4(sphere.position, 1.0));  \n    \n    plane.point = (world2view * vec4(plane.point, 1.0)).xyz;\n    plane.normal = normalize((world2view * vec4(plane.normal, 0.0)).xyz);\n    \n    Ray ray = GeneratePerspectiveRay(camera, uv);   \n    \n    Material defultMat = Material(vec3(1.0), vec3(1.0), vec3(1.0), 0.0);    \n\tIntersection intersection = Intersection(ray, defultMat, vec3(1.0, 0.0, 0.0), RAY_MAX, false);\n    intersection = IntersectWithSphereFirst(intersection, sphere);    \n    intersection = IntersectWithPlaneFirst(intersection, plane);\n    return intersection;\n}\n\nvec3 ShadowTest(Intersection intersection)\n{\n    //it is in view space\n\tvec3 point = intersection.ray.origin + intersection.ray.direction * intersection.t;\n    mat4 perView2world = inverse(perWorld2ViewMat);\n    //transform it to world space\n    vec3 worldPoint = vec3(perView2world * vec4(point, 1.));\n    //transform it t light NDC space\n    vec3 lightSpacePoint = vec3(orthoViewMat * vec4(worldPoint, 1.));\n    //map [-1, 1] to [0, 1]\n    lightSpacePoint = lightSpacePoint * 0.5 + 0.5;\n    //the sample point exceeded the range of orthographic camera cube, \n    //which will never be in the shadow.\n    if(lightSpacePoint.x > 1. || lightSpacePoint.y > 1.)\n        return vec3(1.);\n    float realDepth = lightSpacePoint.z;\n    //use this point coordinate in light space to sample the depth texture\n    float nearestDepth = texture(iChannel0, lightSpacePoint.xy).r;\n    //Add a bias to solve the \"shadow acne\" problem\n    //you can try to delete the bias and see what happens\n    return realDepth - 0.002 > nearestDepth ? vec3(0.) : vec3(1.);\n    //return vec3(1.);\n}\n\nvec3 CalLightAndShadow(PerspectiveCamera camera, vec2 uv)\n{\n    //Find the closest intersection\n    Intersection intersection = ViewSpaceRayTracing(camera, uv);\n    \n    DirectLight tempLight = DirectLight(directLight.direction, directLight.color); \n    tempLight.direction = vec3(perWorld2ViewMat * vec4(directLight.direction, 0.0)).xyz;\n\n    //The ambient color is added whether or not the ray hits something\n    vec3 ambient = LIGHT_AMBIENT * intersection.color.ambient;\n    if(intersection.hasIntersect == true)\n    {\n    \tvec3 lightColor = CalDirectLight(tempLight, intersection, vec3(0.0)); \n        vec3 shadow = ShadowTest(intersection);\n        lightColor = lightColor * shadow;\n        return ambient + lightColor;\n    }\n    return vec3(1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    Frustum frustum = Frustum(2.0, 100.0);\n\tvec3 cameraPos = vec3(0.0, 4.0, 0.0);\n\tvec3 cameraTar = vec3(0.0, 4.0, -1.);\n\tPerspectiveCamera camera = PerspectiveCamera(cameraPos, cameraTar, vec3(0.0, 1.0, 0.0), frustum, \n                           80.0 / 180.0 * PI, iResolution.x / iResolution.y);\n    \n    perWorld2ViewMat = LookAt(camera.position, camera.target, vec3(0.0, 1.0, 0.0)); \n    \n    mat4 world2View = LookAt(orthoCamera.position, orthoCamera.target, vec3(0.0, 1.0, 0.0));\n    mat4 orthoMat = CalOrthographicMat(orthoCamera.window.x, orthoCamera.window.y, \n                                       orthoCamera.window.z, orthoCamera.window.w, \n                                       orthoCamera.nearFar.x, orthoCamera.nearFar.y);\n    orthoViewMat = orthoMat * world2View;\n    \n    vec3 color = CalLightAndShadow(camera, uv);\n\n    fragColor = vec4(color,1.0);\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//The nearest intersect distance\n#define RAY_MIN 0.0001f\n//The farest intersect distance\n#define RAY_MAX 1.0e20f\n\n#define PI 3.1415\n#define LIGHT_AMBIENT vec3(0.5)\n\nstruct Ray\n{\n\tvec3 origin;\n    vec3 direction;\n    float tMIN;\n    float tMAX;       \n};\n    \nstruct DirectLight\n{\n\tvec3 direction;\n\tvec3 color;\n};\n    \nstruct Material\n{\n    vec3 ambient;\n\tvec3 diffuse;\n    vec3 specular;\n    float shininess;\n};\n    \nstruct Intersection\n{\n    Ray ray;\n    Material color;\n    vec3 normal;\n\tfloat t;\n    bool hasIntersect;\n};\n    \nstruct Plane\n{\n\tvec3 point;\n    vec3 normal;\n    Material material;\n};\n    \nstruct Sphere\n{\n\tvec3 position;\n    Material material;\n    float radius;\n};\n    \nstruct Frustum\n{\n    //the distance between near plane and camera\n    float nearestPlane;\n    //the distance between far plane and camera\n    float farestPlane;\n};\n    \nstruct PerspectiveCamera\n{\n\tvec3 position;\n    vec3 target;\n    vec3 upGuide;   //the vector used to calculate the coordinate of camera, not the real up vector of camera\n    Frustum frustum;\n    float fov;\n    float aspectRatio;\n};\n    \nstruct OrthographicCamera\n{\n\tvec3 position;\n    vec3 target;\n    vec3 upGuide;\n    vec4 window;\n    vec2 nearFar;\n};\n\nmat4 Scale(vec3 param)\n{\n\treturn mat4(vec4(param.x, 0.0, 0.0, 0.0),\n                vec4(0.0, param.y, 0.0, 0.0),\n                vec4(0.0, 0.0, param.z, 0.0),\n                vec4(0.0, 0.0, 0.0, 1.0));\n}\n\nmat4 Translate(vec3 param)\n{\n\treturn mat4(vec4(1.0, 0.0, 0.0, 0.0),\n                vec4(0.0, 1.0, 0.0, 0.0),\n                vec4(0.0, 0.0, 1.0, 0.0),\n                vec4(param, 1.0));\n}\n\nmat4 Rotate(vec3 param)\n{\n\tmat4 xMat = mat4(vec4(1.0, 0.0, 0.0, 0.0),\n                     vec4(0.0, cos(param.x), sin(param.x), 0.0),\n                     vec4(0.0, -sin(param.x), cos(param.x), 0.0),\n                     vec4(0.0, 0.0, 0.0, 1.0));\n    mat4 yMat = mat4(vec4(cos(param.y), 0.0, -sin(param.y), 0.0),\n                     vec4(0.0, 1.0, 0.0, 0.0),\n                     vec4(sin(param.y), 0.0, cos(param.y), 0.0),\n                     vec4(0.0, 0.0, 0.0, 1.0));\n    mat4 zMat = mat4(vec4(cos(param.z), sin(param.z), 0.0, 0.0),\n                     vec4(-sin(param.z), cos(param.z), 0.0, 0.0),\n                    vec4(0.0, 0.0, 1.0, 0.0),\n                    vec4(0.0, 0.0, 0.0, 1.0));\n    return zMat * yMat * xMat;\n}\n\nmat4 CalOrthographicMat(float left, float right, float bottom, float top, float near, float far)\n{\n    mat4 translate = Translate(vec3(-(left + right) / 2., -(bottom + top) / 2.,\n                               -(near + far) / 2.));\n    mat4 scale = Scale(vec3(2. / (right - left), 2. / (top - bottom), -2. / (near - far)));\n    return scale * translate;\n}\n\nmat4 LookAt(vec3 position, vec3 center, vec3 up)\n{\n\tvec3 zDirec = normalize(position - center);\n    vec3 xDirec = normalize(cross(up, zDirec));\n    vec3 yDirec = cross(zDirec, xDirec);\n    mat4 c2p = mat4(vec4(xDirec, 0.0), \n                           vec4(yDirec, 0.0), \n                           vec4(zDirec, 0.0), \n                           vec4(0.0, 0.0, 0.0, 1.0));\n\t\n    mat4 translateMat = mat4(vec4(1.0, 0.0, 0.0, 0.0), \n                             vec4(0.0, 1.0, 0.0, 0.0), \n                             vec4(0.0, 0.0, 1.0, 0.0), \n                             vec4(-position, 1.0));\n    return transpose(c2p) * translateMat;\n}\n\nvec3 CalSphereNormal(Sphere sphere, vec3 point)\n{\n\treturn normalize(point - sphere.position);\n}\n\n//All the objects is defined in its self space\nSphere sphere = Sphere(vec3(0.0, 4.1, -9.0), Material(vec3(0.2), vec3(1.0, 1.0, 0.0), vec3(1.0, 1.0, 0.0), 256.0), 4.0);  \nPlane plane = Plane(vec3(0.0), normalize(vec3(0.0, 1.0, 0.0)), Material(vec3(0.2), vec3(0.9), vec3(0.2), 4.0));\nDirectLight directLight = DirectLight(normalize(vec3(-10., -8., -4.)), vec3(0.8));     \n//the light we are using is a direction light which doesn't have position but direction,\n//so we need to use a orthographic camera.\nOrthographicCamera orthoCamera = OrthographicCamera(vec3(8., 10., -9.), vec3(8., 10., -9.) + normalize(vec3(-10., -8., -4.)),\n                                                   vec3(0., 1., 0.), vec4(-7., 7., -7., 7.),\n                                                   vec2(-0.5, -20.));\n\nbool IsIntersectWithSphere(Ray ray, Sphere sphere)\n{\n\tvec3 temp = ray.origin - sphere.position;\n    float a = dot(ray.direction, ray.direction);\n    float b = dot(ray.direction, temp);\n    float c = dot(temp, temp) - sphere.radius * sphere.radius;\n    float delta = b * b - a * c;\n    \n    if(delta > 0.0)\n    {\n        float sqrtDelta = sqrt(delta);\n    \tfloat t1 = (-b + sqrtDelta) / a;\n        float t2 = (-b - sqrtDelta) / a;\n        \n        Intersection inter;\n        inter.ray = ray;\n        \n        if(t2 > ray.tMIN && t2 < ray.tMAX)\n       \t{\n            return true;\n        }\n        else if(t1 > ray.tMIN && t1 < ray.tMAX)\n        {\n        \treturn true;      \n        }\n    }        \n    return false;\n}\n\nbool IsIntersectWithPlane(Ray ray, Plane plane)\n{\n    float denominator = dot(ray.direction, plane.normal);\n\tif(abs(denominator) < 0.00001)\n        return false;\n    \n    float t = dot((plane.point - ray.origin), plane.normal) / denominator;\n\tif(t > ray.tMIN && t < ray.tMAX)\n    {\n        return true;\n    }\n    return false;\n}\n\nIntersection IntersectWithSphereFirst(Intersection intersection, Sphere sphere)\n{\n\tvec3 temp = intersection.ray.origin - sphere.position;\n    float a = dot(intersection.ray.direction, intersection.ray.direction);\n    float b = dot(intersection.ray.direction, temp);\n    float c = dot(temp, temp) - sphere.radius * sphere.radius;\n    float delta = b * b - a * c;\n    \n    if(delta > 0.00001)\n    {\n    \tfloat sqrtDelta = sqrt(delta);\n    \tfloat t1 = (-b + sqrtDelta) / a;\n        float t2 = (-b - sqrtDelta) / a;\n        \n        if(t2 > intersection.ray.tMIN && t2 < intersection.t)\n        {\n            vec3 point = intersection.ray.origin + intersection.ray.direction * t2;\n            vec3 normal = CalSphereNormal(sphere, point);\n        \tintersection.t = t2;\n            intersection.color = sphere.material;\n            intersection.normal = normal;\n            intersection.hasIntersect = true;\n        }        \t\n        else if(t1 > intersection.ray.tMIN && t1 < intersection.t)\n        {\n            vec3 point = intersection.ray.origin + intersection.ray.direction * t1;\n            vec3 normal = CalSphereNormal(sphere, point);\n        \tintersection.t = t1;\n            intersection.color = sphere.material;\n            intersection.normal = normal;\n            intersection.hasIntersect = true;\n        }        \t\n    }\n    return intersection;\n}\n\nIntersection IntersectWithPlaneFirst(Intersection intersection, Plane plane)\n{\n\tfloat denominator = dot(intersection.ray.direction, plane.normal);\n\tif(abs(denominator) < 0.00001)\n        return intersection; \n    \n    float t = dot((plane.point - intersection.ray.origin), plane.normal) / denominator;\n    if(t > intersection.ray.tMIN && t < intersection.ray.tMAX && t < intersection.t)\n    {\n    \tintersection.t = t;\n        intersection.color = plane.material;\n        intersection.normal = plane.normal;\n        intersection.hasIntersect = true;\n    } \n    return intersection;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n---Main Content---\n\t1. Render the scene from direction light view\n\t2. Store the depth value in the buffer\n*/\n\n//Generate the ray from the orthographic camera to simulate the direction light\nRay GenerateOrthographicRay(OrthographicCamera camera, vec2 uv)\n{\n    //map the center of the screen as the origin point\n\tuv -= vec2(0.5);\n    float height = camera.window.w - camera.window.z;\n    float width = camera.window.y - camera.window.x;\n    vec3 pixelInViewSpace = vec3(0.0, 0.0, -camera.nearFar.x) + \n                 \t\t\tvec3(uv.x * width, 0.0, 0.0) + \n                 \t\t\tvec3(0.0, uv.y * height, 0.0);\n    //all the rays are in the same direction as (0., 0., -1) in camera space\n    return Ray(pixelInViewSpace, vec3(0., 0., -1.), RAY_MIN, RAY_MAX);\n}\n\nIntersection LightSpaceRayTracing(OrthographicCamera camera, vec2 uv)\n{\n    //transform all the objects to the camera(direction light) space\n\tSphere tempSphere = Sphere(sphere.position, sphere.material, sphere.radius);\n    Plane tempPlane = Plane(plane.point, plane.normal, plane.material);\n\n\n    mat4 world2View = LookAt(camera.position, camera.target, vec3(0.0, 1.0, 0.0)); \n    tempSphere.position = vec3(world2View * vec4(tempSphere.position, 1.0));  \n    \n    tempPlane.point = (world2View * vec4(tempPlane.point, 1.0)).xyz;\n    tempPlane.normal = normalize((world2View * vec4(tempPlane.normal, 0.0)).xyz);\n    \n    Ray ray = GenerateOrthographicRay(camera, uv);\n    Material defultMat = Material(vec3(1.0), vec3(1.0), vec3(1.0), 0.0);  \n\tIntersection intersection = Intersection(ray, defultMat, vec3(1.0, 0.0, 0.0), RAY_MAX, false);\n    intersection = IntersectWithSphereFirst(intersection, tempSphere);    \n    intersection = IntersectWithPlaneFirst(intersection, tempPlane);\n    return intersection;\n}\n\n\nfloat CalDepthInLightSpace(OrthographicCamera camera, vec2 uv)\n{\n\tIntersection intersection = LightSpaceRayTracing(camera, uv);\n    if(intersection.hasIntersect)\n    {\n        //the point is in the camera space\n    \tvec3 point = intersection.ray.origin + intersection.ray.direction * intersection.t;\n        //transform the intersect point to NDC space\n        mat4 orthoMat = CalOrthographicMat(camera.window.x, camera.window.y, \n                                           camera.window.z, camera.window.w, \n                                           camera.nearFar.x, camera.nearFar.y);\n        vec3 NDCPoint = vec3(orthoMat * vec4(point, 1.));\n        //map [-1, 1] to [0, 1]\n        return NDCPoint.z * 0.5 + 0.5;\n    }\n    return 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n    float depth = CalDepthInLightSpace(orthoCamera, uv);\n    fragColor = vec4(vec3(depth),1.0);\n}","name":"Buf A","description":"","type":"buffer"}]}