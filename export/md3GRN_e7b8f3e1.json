{"ver":"0.1","info":{"id":"md3GRN","date":"1677040802","viewed":86,"name":"Contouring example","username":"rreusser","description":"An illustration of how to draw contours of a function using standard derivatives.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["standardderivatives"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float linearstep(float a, float b, float x) {\n  return clamp((x - a) / (b - a), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Could scale this meaningfully with respect to x/y, but the whole point\n    // is *it doesn't matter* since it's done in screen space anyway, which will\n    // cancel that out.\n    float f = sin(fragCoord.x * 0.01) * sin(fragCoord.y * 0.01);\n    \n    // We want contours of integer values, so we multiply by 10 to get 10 contours\n    // between 0 and 1\n    float g = 10.0 * f;\n    \n    // Compute the slope of g (fwidth(g) has some anisotropy, though it's commonly used for this)\n    float slope = length(vec2(dFdx(g), dFdy(g)));\n    \n    // Now use abs and fract to turn this into a function that basically measures\n    // how far away from zeros we are, in pixels\n    float h = abs(fract(g) - 0.5) / slope;\n    \n    // Given that this function measures how far from zero we are, in pixels, threshold\n    // this at 1 to get a line of with 2px with antialiasing\n    float contour = linearstep(0.5, 1.5, h);\n    \n    fragColor = vec4(pow(vec3(contour), vec3(0.454)), 1.0);\n}","name":"Image","description":"","type":"image"}]}