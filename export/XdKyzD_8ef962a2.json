{"ver":"0.1","info":{"id":"XdKyzD","date":"1521239939","viewed":217,"name":"StereoRayMarch 3D ","username":"Ouid","description":"Stereographic projection of anything ?","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","stereographic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Mathieu Simon aka Ouid (2018)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// ref : https://www.shadertoy.com/view/4sfGzS (noise)\n// ref : https://iquilezles.org/articles/palettes (color)\n\n//#define DEBUG\n\nconst float PI = 3.14159265359;\n\nconst float GOLDEN_RATIO = 1.6180339887498;\n\nconst float DEG_TO_RAD = 0.0174533;\n\nconst float MAX = 10000.0;\n\n#define FOV 25.0\n\n#define WITH_SHADOW 1\n#define WITH_STEREO_NORMAL 0\n\n#define PLANE(_Vec3Point,_Vec3Normal) pointAndNormToPlane ( ( vec4(_Vec3Point,1.0) ).xyz, ( vec4(normalize(_Vec3Normal),0.0) ).xyz )\n#define CENTRIC_PLANE(_dist,_Vec3Normal) pointAndNormToPlane ( ( vec4(_dist*_Vec3Normal,1.0) ).xyz, ( vec4(normalize(_Vec3Normal),0.0) ).xyz )\n\n\n//All planes (I'm using /* */ tricks to make new-line)\n//Object(10+x) are used to detect plane and select color\n\n#define COLOR_COUNT 12\n\n#if 0\n// tetrahedron\n\n#define CENTER(_x,_y,_z) (((_x)+(_y)+(_z))/3.0)\n#define P1 vec3(1.0,1.0,1.0)\n#define P2 vec3(1.0,-1.0,-1.0)\n#define P3 vec3(-1.0,1.0,-1.0)\n#define P4 vec3(-1.0,-1.0,1.0)\n\n#define FOREACH_PLANES(_Call) /*\n*/\t_Call(CENTRIC_PLANE(1.0,CENTER(P1,P2,P3)), Object(10))/*\n*/\t_Call(CENTRIC_PLANE(1.0,CENTER(P1,P3,P4)), Object(11))/*\n*/\t_Call(CENTRIC_PLANE(1.0,CENTER(P1,P2,P4)), Object(12))/*\n*/\t_Call(CENTRIC_PLANE(1.0,CENTER(P2,P3,P4)), Object(13))\n\n#undef COLOR_COUNT\n#define COLOR_COUNT 4\n    \n#elif 0\n//cube\n\n#define FOREACH_PLANES(_Call) /*\n*/\t_Call(CENTRIC_PLANE(1.0,vec3(1.0,0.0,0.0)), Object(10))/*\n*/\t_Call(CENTRIC_PLANE(1.0,vec3(-1.0,0.0,0.0)), Object(11))/*\n*/\t_Call(CENTRIC_PLANE(1.0,vec3(0.0,1.0,0.0)), Object(12))/*\n*/\t_Call(CENTRIC_PLANE(1.0,vec3(0.0,-1.0,0.0)), Object(13))/*\n*/\t_Call(CENTRIC_PLANE(1.0,vec3(0.0,0.0,1.0)), Object(14))/*\n*/\t_Call(CENTRIC_PLANE(1.0,vec3(0.0,0.0,-1.0)), Object(15))\n\n#undef COLOR_COUNT\n#define COLOR_COUNT 6\n\n#elif 1 \n//dodecahedron\n    \nconst float GOLDEN_DIST = (GOLDEN_RATIO*GOLDEN_RATIO) / (GOLDEN_RATIO*GOLDEN_RATIO+2.0);\n    \n#define FOREACH_PLANES(_Call) /*\n*/\t_Call(CENTRIC_PLANE(GOLDEN_DIST,vec3(GOLDEN_RATIO,1.0,0.0)), Object(10))/*\n*/\t_Call(CENTRIC_PLANE(GOLDEN_DIST,vec3(-GOLDEN_RATIO,1.0,0.0)), Object(11))/*\n*/\t_Call(CENTRIC_PLANE(GOLDEN_DIST,vec3(GOLDEN_RATIO,-1.0,0.0)), Object(12))/*\n*/\t_Call(CENTRIC_PLANE(GOLDEN_DIST,vec3(-GOLDEN_RATIO,-1.0,0.0)), Object(13))/*\n*/\t_Call(CENTRIC_PLANE(GOLDEN_DIST,vec3(0.0,GOLDEN_RATIO,1.0)), Object(14))/*\n*/\t_Call(CENTRIC_PLANE(GOLDEN_DIST,vec3(0.0,-GOLDEN_RATIO,1.0)), Object(15))/*\n*/\t_Call(CENTRIC_PLANE(GOLDEN_DIST,vec3(0.0,GOLDEN_RATIO,-1.0)), Object(16))/*\n*/\t_Call(CENTRIC_PLANE(GOLDEN_DIST,vec3(0.0,-GOLDEN_RATIO,-1.0)), Object(17))/*\n*/\t_Call(CENTRIC_PLANE(GOLDEN_DIST,vec3(1.0,0.0,GOLDEN_RATIO)), Object(18))/*\n*/\t_Call(CENTRIC_PLANE(GOLDEN_DIST,vec3(1.0,0.0,-GOLDEN_RATIO)), Object(19))/*\n*/\t_Call(CENTRIC_PLANE(GOLDEN_DIST,vec3(-1.0,0.0,GOLDEN_RATIO)), Object(20))/*\n*/\t_Call(CENTRIC_PLANE(GOLDEN_DIST,vec3(-1.0,0.0,-GOLDEN_RATIO)), Object(21))\n    \n#undef COLOR_COUNT\n#define COLOR_COUNT 12\n    \n#endif\n    \n#define SPHERE_SIZE 1.0\n#define SPHERE_OBJECT_RATIO 1.0\n\n// structures (I love structures, sorry, C/C++ habits)\n\nstruct Ray\n{\n    vec3 p;\t\t\t// start of the ray\n    vec3 d;    \t\t// direction of the ray, intersect functions need \"normalized\" dir\n};\n\nstruct Camera\n{ \n    mat4\tmatrix;\t// this matrix can be \"Left\" or \"Right\" handed...just used to compute viewRay\n};\n    \nstruct Object\n{\n    int\t\tid;\t\t// just an id, to find material after all raycasts\n};\n    \nstruct RayResult\n{\n    float\tt;\t\t// distance from origin of the ray that cause the result\n    Object\to;\t// object intersected\n};\n    \nstruct Lighting\n{\n    vec3\tambient; \t// xyz = color\n    vec2\tshading;\n};\n    \nstruct Light\n{\n    vec3\tp;\t\t// pition of the light    \n    vec4\tspec;\t\t// xyz = color, w = intensity\n};\n    \nstruct World\n{\n    float \tobject_scale;\n    mat4\tobject_trf;   \t// matrix of the object\n    mat4\tobject_trf_inv;\n};\n    \nWorld world;\n\n// util funcs\n\nfloat maxPerElem ( in vec2 _v )\n{\n    return max(_v.x,_v.y);\n}\n\nfloat maxPerElem ( in vec3 _v )\n{\n    return max(_v.z,maxPerElem(_v.xy));\n}\n\nfloat maxPerElem ( in vec4 _v )\n{\n    return max(_v.w,maxPerElem(_v.xyz));\n}\n\nmat4 rotationX ( float _angle )\n{\n    mat4 mat;\n    mat[0] = vec4(1.0,0.0,0.0,0.0);\n    mat[1] = vec4(0.0,cos(_angle),sin(_angle),0.0);\n    mat[2] = vec4(0.0,-sin(_angle),cos(_angle),0.0);\n    mat[3] = vec4(0.0,0.0,0.0,1.0);    \n    return mat;\n}\nmat4 rotationY ( float _angle )\n{\n    mat4 mat;\n    mat[0] = vec4(cos(_angle),0.0,-sin(_angle),0.0);\n    mat[1] = vec4(0.0,1.0,0.0,0.0);\n    mat[2] = vec4(sin(_angle),0.0,cos(_angle),0.0);\n    mat[3] = vec4(0.0,0.0,0.0,1.0);\n    return mat;\n}\nmat4 rotationZ ( float _angle )\n{\n    mat4 mat;\n    mat[0] = vec4(cos(_angle),sin(_angle),0.0,0.0);\n    mat[1] = vec4(-sin(_angle),cos(_angle),0.0,0.0);\n    mat[2] = vec4(0.0,0.0,1.0,0.0);\n    mat[3] = vec4(0.0,0.0,0.0,1.0);\n    return mat;\n}\n\nmat4 scale (vec3 _scale)\n{\n    mat4 mat;\n    mat[0] = vec4(_scale.x,0.0,0.0,0.0);\n    mat[1] = vec4(0.0,_scale.y,0.0,0.0);\n    mat[2] = vec4(0.0,0.0,_scale.z,0.0);\n    mat[3] = vec4(0.0,0.0,0.0,1.0);\n    return mat;\n}\n\nmat4 translate (vec3 _translation)\n{\n    mat4 mat;\n    mat[0] = vec4(1.0,0.0,0.0,0.0);\n    mat[1] = vec4(0.0,1.0,0.0,0.0);\n    mat[2] = vec4(0.0,0.0,1.0,0.0);\n    mat[3] = vec4(_translation,1.0);\n    return mat;\n}\n\nvec4 pointAndNormToPlane ( in vec3 _p, in vec3 _n )\n{\n    return vec4 ( _n, -dot(_p,_n) );\n}\n\nRayResult sdSphere(vec3 p, float r, Object o)\n{\n    return RayResult ( length(p) - r, o);\n}\n\nRayResult sdPlane(vec3 p, vec4 n, Object o)\n{\n    return RayResult ( dot(p,n.xyz) + n.w, o);\n}\n\n\nRayResult sdBox( vec3 p, vec3 b, Object o )\n{\n    vec3 d = abs(p) - b;\n    return RayResult(min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)), o);\n}\n\nRayResult inv ( RayResult r )\n{\n    return RayResult(-r.t, r.o);\n}\n\nRayResult mul(RayResult r, float s)\n{\n    return RayResult(r.t * s, r.o);\n}\n\nRayResult add(RayResult r, float v)\n{\n    return RayResult(r.t + v, r.o);\n}\n\nRayResult opU( RayResult r1, RayResult r2 )\n{\n    if ( r1.t < r2.t )\n        return RayResult(r1.t, r1.o);    \n    else\n        return RayResult(r2.t, r2.o);\n}\n\n\nRayResult opI( RayResult r1, RayResult r2 )\n{\n    if ( r1.t > r2.t )\n        return RayResult(r1.t, r1.o);    \n    else\n        return RayResult(r2.t, r2.o);\n}\n\n\nRayResult opS( RayResult r1, RayResult r2 )\n{\n    return opI(r1, inv(r2));\n}\n\n\nRayResult opRepBox( vec3 p, vec3 bs, vec3 c, in Object o )\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return sdBox( q, bs, o );\n}\n\n/*RayResult main_object(vec3 p, float scale)\n{\n    vec3 p2 = p / scale;\n    RayResult r = RayResult(-1.0, Object(-1));\n    \n\t#define INTERSECT_PLANE_RANGE(_Plane,_PlaneId) r=opI(r, sdPlane ( p2, _Plane, _PlaneId ));\n\tFOREACH_PLANES(INTERSECT_PLANE_RANGE) \n        \n    r = opS ( r, sdSphere(p2,1.15, Object(2)) );\n        \n    return mul(r, scale);\n}*/\n\nRayResult main_object(vec3 p, float scale)\n{\n    vec3 p2 = p / scale;\n        \n    //RayResult r =  sdSphere(p2, 1.0, Object(10));\n    RayResult r =  sdBox(p2, vec3(0.7), Object(10));\n    \n    float box_size = 1.0 / 3.0; //0.05;\n    \n    RayResult box = opRepBox(p2, vec3(box_size*0.15), vec3(box_size), Object(10));\n    \n    r = opI ( r, box);\n    \n    //r = opS ( r,  sdSphere(p2, 1.0-box_size*0.25*sqrt(2.0), Object(10)));\n    //r = opS ( r,  sdSphere(p2, 0.9, Object(10)));\n    r = opS ( r,  sdBox(p2, vec3(0.5), Object(10)));    \n        \n    return mul(r, scale);\n}\n\n\n\nRayResult map(vec3 p, in Object _except)\n{\n    vec3 p2 = (world.object_trf_inv * vec4(p,1.0f)).xyz;\n    \n    RayResult r = main_object(p2, world.object_scale);\n\n\tif ( _except.id != 2 )\n    \tr = opU ( r, sdPlane(p, vec4(0.0,1.0,0.0,0.0), Object(2)));\n\t\n\treturn r;\n}\n\nRayResult map(vec3 p)\n{\n    return map(p, Object(-1));\n}\n\n// normal : copy from https://www.shadertoy.com/view/Xds3zN\nvec3 normal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.00001;\n    return normalize( e.xyy*map( pos + e.xyy ).t + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).t + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).t + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).t );\n}\n\nRayResult intersect(in Ray ray, in Object _except, float _precis, float _max)\n{\n    RayResult r;\n    float t=0.0;\n    float tmax = _max;\n    for ( int i=0; i<128; ++i )\n    {\n        float precis = _precis;\n        \n        RayResult curr = map(ray.p + t * ray.d, _except);\n        \n        if( curr.t<precis || t>tmax ) break;\n                \n        t += curr.t;\n        r = curr;\n    }\n    \n    if (t>tmax)\n        return RayResult(-1.0,Object(-1));\n    \n    return RayResult(t, r.o);\n}\n\n// Stereographic projection\n\nRay stereographicRay ( in World _world, in vec3 _p )\n{\n    // x;y;z;0 on hyperplane w=0\n    // on sphere of radius 1 => (2x/(R+1);2y/(R+1);2x/(R+1);R-1/R+1) where R = x²+y²+z²\n    \n    float R = dot(_p.xz,_p.xz);\n    \n    vec3 onSphere = vec3(2.0*_p.x,R-1.0,2.0*_p.z) / vec3(R+1.0);\n    \n    // STC : SphereToCube\n    Ray raySTC;\n    raySTC.p = _world.object_trf[3].xyz;\n    raySTC.d =  normalize( onSphere - _world.object_trf[3].xyz );\n    \n    return raySTC;\n}\n\n\n// standard [image -> screen -> view -> world] funcs\n\nvec2 imageToScreen ( in vec2 _uv )\n{\n    vec2 ratioUV = _uv.xy / iResolution.xy;\n    vec2 ratio = 2.0*iResolution.xy/vec2(min(iResolution.x,iResolution.y));\n    vec2 xy = (ratioUV*2.0-1.0)*ratio;\n    return xy;\n}\n\nvoid screenToWorld ( in Camera _camera, in vec2 _screenp, float _z, out vec3 _p )\n{\n    _p = (_camera.matrix * vec4(_screenp,_z,1.0)).xyz;    \n}\n\nvoid screenToRay ( in Camera _camera, in vec2 _screenp, out Ray _ray )\n{\n    vec3 rayPoint;\n    \n    //fov is hardcoded here (distance of Z plane)\n    screenToWorld ( _camera, _screenp, 1.0 / tan ( DEG_TO_RAD * FOV / 2.0), rayPoint );        \n    \n    _ray.p = _camera.matrix[3].xyz;\n    _ray.d = normalize(rayPoint-_ray.p);\n}\n\nCamera cameraLookAt ( in vec3 _eye, in vec3 _lookAtp, in vec3 _up )\n{\n    Camera _camera;\n    \n    vec3 front = normalize(_lookAtp-_eye);    \n    vec3 left = normalize(cross(front, _up));\n    vec3 up = normalize(cross(left,front));\n    _camera.matrix[0] = vec4(left,0.0);\n    _camera.matrix[1] = vec4(up,0.0);\n    _camera.matrix[2] = vec4(front,0.0);\n    _camera.matrix[3] = vec4(_eye,1.0);\n    \n    return _camera;\n}\n\n// color funcs\n\nvec3 computeMaterial ( in World _world, in Ray _ray, in RayResult _rayResult )\n{\n    vec3 _material;\n    \n    if ( _rayResult.o.id == 1 )\n    {\n        _material = vec3(1.0);\n    }\n    else if ( _rayResult.o.id == 2 )\n    {\n        _material = vec3(0.5);\n    }\n    else if ( _rayResult.o.id >= 10  )\n    {\n        float ratio = mod(float(_rayResult.o.id-9)+5.0,float(COLOR_COUNT)) / float(COLOR_COUNT);\n        vec3 a = vec3(0.28,0.5,0.5)*1.3;\n        vec3 b = vec3(0.5,0.2,0.5);\n        vec3 c = vec3(1.0,1.0,0.0);        \n        vec3 d = vec3(0.5,0.3, 0.25);\n        \n        //https://iquilezles.org/articles/palettes\n        _material = a+b*cos(2.0*3.141592*(c*ratio+d));\n        \n        vec3 pos = _ray.p + _rayResult.t * _ray.d;\n        _material = (world.object_trf_inv * vec4(normal(pos), 0.0)).xyz * 0.5 + vec3(0.5);\n\n    }\n    else   \n    {\n        _material = vec3(0.0);\n    }\n    \n    return _material;\n}\n\n// softShadow : copy from https://www.shadertoy.com/view/Xds3zN\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).t;\n        res = min( res, 2.0*h/t );\n        t += clamp( h, 0.001, 0.05 );\n        if( h<0.0001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// AO : copy from https://www.shadertoy.com/view/Xds3zN\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).t;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// setup world, cam & light\n\n    mat4 rot = rotationZ ( iTime*1.278914) * rotationY(iTime) * rotationX(iTime*0.332567);\n    mat4 inverseRot = rotationX(-iTime*0.332567) * rotationY(-iTime) * rotationZ ( -iTime*1.278914) ;\n    \n    world.object_scale = 0.5;\n    world.object_trf = translate (vec3(0.0,0.5,0.0)) * rot;\n    world.object_trf_inv = inverse(world.object_trf);\n    \n    vec2 eye = vec2(0.0);\n    \n#ifndef DEBUG\n    eye = iMouse.xy/iResolution.xy;\n#endif\n    \n    Camera cam = cameraLookAt ( vec3(2.5-5.0*(eye.x),2.0+5.0*(eye.y),2.5), vec3(0.0,0.5,0.0), vec3(0.0,1.0,0.0) );\n    \n    // compute raytrace\n    vec2 xy = imageToScreen ( fragCoord );    \n        \n    Ray ray;\n    \n    screenToRay ( cam, xy, ray );\n    \n    RayResult res = intersect ( ray, Object(-1), 0.0001, 100.0 );\n    \n    vec3 pos = ray.p + ray.d * res.t;\n\tvec3 nor = normal( pos );\n\tvec3 ref = reflect( ray.d, nor );\n     \n    vec3 col = computeMaterial ( world, ray, res );   \n    \n    // if plane => stereographicProj to obtain color\n    if ( res.o.id == 2 )\n    {\n        Ray stRay = stereographicRay ( world, pos );\n        RayResult stInter = intersect(stRay, Object(2), 0.0001, 1.0);\n            \n        vec3 stereoCol = computeMaterial ( world, stRay, stInter );\n        \n        col = stereoCol * stInter.t;\n    }\n        \n    // lighting : copy from https://www.shadertoy.com/view/Xds3zN\n    float occ = 1.0f; //calcAO( pos, nor );\n    vec3  lig = normalize( vec3(-0.4, 0.7, -0.6) );\n    vec3  hal = normalize( lig-ray.d );\n    float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n    float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n    float dom = smoothstep( -0.1, 0.1, ref.y );\n    float fre = pow( clamp(1.0+dot(nor,ray.d),0.0,1.0), 2.0 );\n\n    dif *= calcSoftshadow( pos, lig, 0.02, 10.0 );\n    dom *= calcSoftshadow( pos, ref, 0.02, 10.0 );\n\n    float spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n        dif *\n        (0.04 + 0.96*pow( clamp(1.0+dot(hal,ray.d),0.0,1.0), 5.0 ));\n\n    vec3 lin = vec3(0.0);\n    lin += 1.30*dif*vec3(1.00,0.80,0.65);\n    lin += 0.40*amb*vec3(0.60,0.80,1.00)*occ;\n    lin += 0.50*dom*vec3(0.60,0.80,1.00)*occ;\n    lin += 0.50*bac*vec3(0.35,0.35,0.35)*occ;\n    lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n    col = col*lin;\n    col += 10.00*spe*vec3(1.00,0.90,0.70);\n\n    col = col; //mix( col, vec3(0.,0.0,.0), 1.0-exp( -0.0002*res.t*res.t*res.t ) );\n\n    fragColor = vec4(col, 0.0);\n}\n","name":"Image","description":"","type":"image"}]}