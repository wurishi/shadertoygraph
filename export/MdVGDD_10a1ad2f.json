{"ver":"0.1","info":{"id":"MdVGDD","date":"1454872179","viewed":176,"name":"Freakend 2016 demo3","username":"jcant0n","description":"Demos about #shadertoy written during the #freakend conference","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["simpleraymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_ES\n    precision highp float;\n#endif\n\nvec3 cameraPosition = vec3(0, 2, 5.0);\nvec3 lightPosition = vec3(3);\n\nvec3 spherePosition = vec3(1, 0, 0);\nfloat sphereRadio = 1.0;\n\nvec3 cubePosition = vec3(0,0,0);\nvec3 cubeSize = vec3(1.0, 2.0, 2.0);\n\nvec3 torusPosition = vec3(0);\nvec2 torusSize = vec2(1.0, 0.4);\n\nfloat torusDistance(vec3 rayPosition, vec3 torusPosition, vec2 torusSize) {\n    vec2 d = vec2( length(rayPosition.xz - torusPosition.xz) - torusSize.x, rayPosition.y - torusPosition.y);\n    return length(d) - torusSize.y;\n}\n\nfloat sphereDistance(vec3 rayPosition, vec3 spherePosition, float sphereRadius)\n{\n    float d = length(rayPosition - spherePosition) - sphereRadius;\n    return d;\n}\n\nfloat cubeDistance(vec3 rayPosition, vec3 cubePosition, vec3 cubeSize) {\n    vec3 d = abs(rayPosition - cubePosition) - cubeSize;\n    return min(max(d.x, max(d.y,d.z)), 0.0) + length(max(d,0.0));\n}\n\n\nvec2 rotate( vec2 vector, float angle )\n{\n\tvec2 sincos = vec2( sin(angle), cos(angle) );\n\treturn vec2( vector.x * sincos.y - vector.y * sincos.x, \n\t\t\t\tvector.x * sincos.x + vector.y * sincos.y );\n}\n\nfloat scene(vec3 rayPosition)\n{\n    float entity = sphereDistance(rayPosition, spherePosition, sphereRadio);\n    entity = max(-entity, cubeDistance(rayPosition, cubePosition, cubeSize));\n    //float entity = torusDistance(rayPosition, torusPosition, torusSize);\n\n    return entity;\n}\n\nvec3 getNormal(vec3 pos)\n{\n    float epsilon = 0.001;\n    \n\tvec2 t = vec2(0.0, epsilon);\n    vec3 n = vec3(scene(pos + t.yxx) - scene(pos - t.yxx),\n           \t      scene(pos + t.xyx) - scene(pos - t.xyx),\n                  scene(pos + t.xxy) - scene(pos - t.xxy));\n    \n    return normalize(n);\n}\n\nvec3 getColor(vec3 rayPosition)\n{\n\tvec3 N = getNormal(rayPosition);\n    vec3 L = normalize(lightPosition - rayPosition);\n    float diffuse = max(dot(L, N), 0.0);\n    \n    vec3 color = texture(iChannel0, rayPosition).xyz;\n    return color * diffuse;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= vec2(0.5);\n    float aspect = iResolution.x / iResolution.y;\n    uv.x *= aspect;\n    \n    cameraPosition.xz = rotate(cameraPosition.xz, cos(iTime) - 0.5);\n\n    vec3 cameraTarget = vec3(0);\n    vec3 cameraForward = normalize(cameraTarget - cameraPosition);\n    vec3 cameraUp = vec3(0,1,0);\n    vec3 cameraRight = normalize(cross(cameraForward, cameraUp));\n    \n    vec3 rayPosition = cameraPosition;\n    vec3 rayDirection = normalize(cameraForward + uv.x * cameraRight + uv.y * cameraUp);\n    \n    vec3 color = vec3(0);\n    \n    // Raymarching algorithm\n    for(int i = 0; i < 32; i++)\n    {\n        float d = scene(rayPosition);\n        rayPosition += d * rayDirection;\n        \n        if(d < 0.001)\n        {\n            color = getColor(rayPosition);\n            break;\n        }\n    }\n    \n\tfragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}