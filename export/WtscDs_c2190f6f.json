{"ver":"0.1","info":{"id":"WtscDs","date":"1667524456","viewed":174,"name":"Mountains and Valleys","username":"spalmer","description":"fork of stb's [url=http://shadertoy.com/view/XsKGWG]poor hydraulic erosion[/url] mashup using my Walk Camera and the terrain renderer from Biquadratic Heightfield. WASD+Arrows+Mouse, space jumps, G toggles gravity, R resets terrain","likes":8,"published":1,"flags":48,"usePreview":0,"tags":["terrain","heightfield","heightmap","river","walk","erosion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// fork of poor hydraulic erosion by stb at http://shadertoy.com/view/XsKGWG\n// Based on paniq's biquadratic filter http://shadertoy.com/view/wtXXDl\n\n#define BluNoiz   iChannel1\n#define BNzRes iChannelResolution[1].xy\n// blue noise\n// camera state\n// see HillHeight for the terrain channel\n// also in iChannel0\n// most configurable options here\n\n#define SHADOWS 1\n\nconst float\n  fogdensity = .002\n, maxdepth = 6e3 //1e2 //3.4e38 //8.5e4 //\n, shfalloff = 2. //.5 // exponent of curve\n, shd = 8. // soft shadow trace distance\n, sc = 3.2  // soft shadow crispness\n, sfuzz = .0 //.05 // HACK fade contribution with scan range - HACK for penumbra (not mixed correctly though, so doesn't really work well)\n, aod = .3 // ao distance\n, ambient = .25 // balance between ambient and direct light\n, nitebrite = .06 // how dark the lighting gets at night, essentially night time ambient light level\n, lfloor = .02 // lighting floor, limits how deep shadows can get, fake global ambient\n;\n\nconst vec3\n, csun = vec3( 1., .95, .79) // light color\n, csky = vec3(.11, .33, .99) // fake, gets dimmed by sun angle though\n;\n\n// attempting to scale by resolution,\n// automatically reducing samples as needed.\n// only smaller windows will get the full count.\nconst int\n  marchsteps = 192 //128 //96 //64 //\n, shadowsteps = 16 //8 //24 //32 //\n;\n\n// material ids\nconst int\n  mSky   = 0\n, mGray  = 1\n, mRed   = 2\n, mGreen = 3\n, mBlue  = 4\n;\n\n// \"constants\" based on uniforms, set in mainImage\n\nvec3 sunDir = normalize(vec3(.1, .5, .8));\n\n\nstruct Hit\n{\n    float d; // signed distance to surface\n    int m; // material id\n};\n/* TODO other convenient quantities\ninclude local texture coordinate\n*/\n\nHit Scene(vec3 p) // FIXME crappy wrapper supplies material only, hard-coded\n{\n\treturn Hit(sceneDistance(BufA, p), mGray);\n}\n\n// bounding clip plane height for entire scene - nothing is taller than this\nconst float hmax = 0.; //-.4*displ; //displ; // it's displaced downward\n\nstruct Marched \n{\n\tfloat t;   // distance to intersection\n\tint m;     // material id\n\tfloat nmd; // nearest miss distance\n};\n\nMarched March(vec3 ro, vec3 rd, float thresh, float dmax, int iters)\n{\n\tMarched c = Marched(dmax, mSky, dmax);\n\tint i = iters;\n\tfloat t = 0.;\n\twhile (i-- > 0) {\n\t\tvec3 mp = ro + rd * t;\n\t\tHit h = Scene(mp);\n\t\tfloat d = h.d, ad = abs(d);\n\t\tt += d;\n\t\tc.m = h.m, c.nmd = h.d;\n\t\tif (rd.y >= 0. && (mp.y > hmax || ad > dmax))\n\t\t\tbreak; //t = dmax;\n\t\tif (ad < thresh * t || t >= dmax)\n\t\t\tbreak;\n\t}\n\tc.t = t = clamp(t, 0., dmax);\n\tif (abs(c.nmd) > thresh * 2. * t) \n\t\tc.m = mSky;\n    else {\n        vec3 hp = ro + rd * t;\n        vec3 hw = hillwaveheight(BufA, hp.xz);\n        if (hw.y > 2e-6)\n        \tc.m = mBlue;\n        else if (hw.x <= hw.z + 1e-4)\n            c.m = mRed; // indicate exposed bedrock\n    }\n\t//if (c.m == mSky)\n\t//\tc.t = dmax; // caller won't be able to tell how far it got though\n\treturn c;\n}\n\n// HACK rescue failed marches for planar scenes\nvoid Rescue(inout Marched c, vec3 ro, vec3 rd, float dmax)\n{\n    if (c.m == mSky)\n        if (rd.y >= 0. && ro.y > 0.-displ)\n            c.t = dmax;\n        else {\n            //c.t = (ro.y+displ) / -rd.y;\n            c.m = mGray;\n            c.nmd = 0.;\n        }\n}\n\n// compute material (albedo for now) from id\nvec3 Material(int i, vec3 p, vec3 n, float d)\n{\n    float tsc = 32.;\n    vec3 a, t = sin(tsc*p + .25*tau) * .5 + .5;\n    float f = dot(1.-n*n, t) // triplanar texture\n         * exp2(-4.*tsc/iResolution.y*d) * .25 // distance fade\n        + .5\n      , e = .1*f; // don't want any black components, desaturate a bit\n    float fy = 1. - .3*(1.-abs(sin(p.y * .7))); // * (1.-abs(n.y));\n    switch (i) {\n      default:\n      case mSky:   a = vec3(  e  ); break;\n      case mGray:  a = vec3(  f * fy  ); break;\n      case mRed:   a = vec3(f * fy * fy,e,e); break;\n      case mGreen: a = vec3(e,f,e); break;\n      case mBlue: {\n        vec3 wh = hillwaveheight(BufA, p.xz);\n        //a = vec3(e,e,f);\n        a = mix(vec3(e,e,f), vec3(f * fy), exp2(-4096.*max(0., wh.y))); \n        break;\n      }\n    }\n    return a;\n}\n\nfloat Shadow(vec3 p, vec3 n, vec3 l, float hd, float d, float rnd, int ssteps)\n{\n    float nl = max(0., dot(n, l))\n    , ao = clamp((Scene(p + n * aod).d - hd) / aod, 0., 1.);\n  #if SHADOWS         \n    if (nl > 1e-4) {\n    \tvec3 sht = sunDir * shd\n    \t, hp = p + n * .002; // self-shadow bias hit position\n        int iters = max(1, int(rnd + float(ssteps) / (1.+.002*d)));\n        float sh = 1.; // min shadow factor found so far\n        for (int i = iters; i-- > 0; ) {\n    \t\tfloat f = (float(i) + 1.) / float(iters)\n    \t\t// must distribute the samples nonlinearly\n\t\t\t// to support long shadow trace distances.\n\t\t\t// need more samples close to the receiver.\n\t\t\t, ff = f * f\n\t\t\t, v = max((Scene(p + sht * ff).d - hd + sfuzz * f) * sc / shd / nl / ff, 0.);\n\t\t\tsh = min(sh, v); //sh = min(sh, v * (2.-f)); //sh *= mix(v, 1., f); //sh *= v; //\n        }\n        // hoisted sqrt and part of clamp out of loop\n        sh = min(sh, 1.);\n        sh = pow(sh, shfalloff);\n\t    nl *= sh; // fake soft shadow attenuates direct lighting\n    }\n  #endif\n    //nl = max(nl, ao);\n    //nl *= max(0., mix(ao, 1., .2));  // fake AO\n    //nl = mix(nl, 1., ambient);  // HACK ambient floor\n    //float af = min(mix(ao, 1., ambient), 1.);\n    //nl = mix(nl, 1., af);\n    // FIXME I still don't like how I've mixed the factors, really.\n    // FIXME ambient light should have a color from the surrounding environment bounces,\n    // so should be based on albedo of nearby surfaces\n    // as a major HACK can use our *own* albedo since it does contribute somewhat due to interreflections\n    float ah = mix(n.y, 1., .5) * ambient; // hemisphere ambient\n    nl *= (1.-ambient); // leave room for ambient factor\n    nl += ah * ao; // hemi ambient only where not occluded\n    //nl /= (1. + ambient); // I like this mixing better\n    nl = clamp(nl, 0., 1.);\n    // must have some minimum lighting floor to prevent harsh black ao in shadows\n    nl = mix(nl, 1., lfloor); // after clamping\n//    nl = 1.; // HACK disable lighting\n    return nl;\n}\n\nvec3 Light(int m, vec3 p, vec3 v, float d, float rnd)\n{\n    float h = 3e-4 * (d + 1.) //2e-3 * clamp(d, .01, 100.) //\n    , hd;\n    vec3 n = sceneNormal(BufA, p, h, IZERO, hd)\n    , H = normalize(v + sunDir) // for blinn-phong specular\n    , albedo = Material(m, p, n, d)\n    , c = albedo;\n    float nl = max(0., dot(n, sunDir))\n    , fogscale = fogdensity // / dmax * 8.5e4; // TODO scale by dmax somehow?\n    , fexp = exp2(-fogscale * d);\n    nl = Shadow(p, n, sunDir, hd, d, rnd, shadowsteps + IZERO);\n    c *= nl * mix(sunDir.y, 1., .5+.5*nitebrite);\n    if (true && m == mBlue)  {\n    \tfloat fres = 1.-pow(max(0., dot(n, v)), 5.)\n        , nh = max(0., dot(n, H))\n        , rspec = pow(nh, 16.) + .5 * pow(nh, 2.);\n    \tc += (rspec * .5 + // TODO sun specular\n        n.y * .5 * csky // fake sky specular\n        ) * fres // fake fresnel\n        ;\n        //c = mix(c, vec3(nl), exp2(-4096.*max(0., wh.y)));  // FIXME alpha \n    }\n    vec3 cfog = (csky // fake optical depth for atmo, fake sky coloration, inscatter color\n        + (1.-fexp) * .7 * pow(clamp(1.-abs(v.y), 0., 1.), 8.) // fake all the things!  distant horizon fog\n        ) * mix(sunDir.y, 1., .5 + .25 * nitebrite)\n        + .87*pow(max(0., dot(-v, sunDir) * .5 + .5), 16.); // fake mie, sun halo\n    c = mix(cfog, c, fexp)*csun; // simple fog Beer's law (not spectral, extinction&inscatter fused)\n    c = clamp(c, 0., 1.);\n    return c;\n}\n\nvec3 Render(vec3 ro, vec3 rd, float rnd, out float depth)\n{\n    int msteps = marchsteps + IZERO;\n    //msteps = max(1, msteps * 8 / (1+int(log2(iResolution.y))));\n    msteps = max(128, int(float(msteps) * exp2(min(0., iResolution.y/-2560.))));\n    Marched mr = March(ro, rd, 2e-3, maxdepth, msteps);\n    Rescue(mr, ro, rd, maxdepth); // HACK\n    float t = mr.t // trace depth to first hit\n        , hd; // distance at hit point\n    int m = mr.m;\n    vec3 hp = ro + rd * t\n    , c = Light(m, hp, -rd, t, rnd);\n    //c *= n * .5 + .5; // DEBUG hit normal\n    depth = mr.t;\n    return c;\n}\n\nvoid SetupTime(float t)\n{\n//    time = t;\n    // rapidly rotating sun is just too seizure-inducing and flashy\n\tfloat sunangle = .9; //12.*t; //24.*t; //.1*t; //\n\tsunDir = normalize(vec3(.2,1,1)*sin(vec3(sunangle)+vec3(0,0,.25*tau))); //vec3(.1, .9,.2)); //\n}\n\nvec3 Draw(vec2 p, float rnd)\n{\n    State state;\n    vec2 r = iResolution.xy;\n    LoadState(state, iChannel0, ivec2(r));\n    SetupTime(iTime);\n    vec3 vd = normalize(vec3(2.*p-r, r.y*2.))\n    , ro = state.eyepos, rd = Camera(state.eyeaim) * vd;\n    float depth;\n    vec3 c = Render(ro, rd, rnd, depth);\n    return c;\n}\n    //Marched mr = March(ro, rd, .001, 128., 96 + IZERO);\n    //float t = mr.t;\n    //vec3 h = ro + rd * t\n    //, albedo = vec3(.5) // sceneAlbedo(h)\n    //, n = sceneNormal(h, .01);\n//\treturn sceneLight(h, -rd, n, t, dot(rd, sunDir), albedo, t);\n//\treturn LightingBlinnPhong(n, -rd, sunDir, albedo, t, 1.).rgb;\n//    return Light(ro + rd * t, t);\n\nfloat rnoise(vec2 p)\n{\n\treturn fetch(BluNoiz, ivec2(p) & ivec2(BNzRes-1.)).x; // blue noise is great\n}\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n//    ch1res = BufARes.y; //iChannelResolution[0].y; // iChannelResolution[1].y is uniform though, not constant; hard-coded blue noise texture resolution; must be done in mainImage\n    float rnd = rnoise(p);\n\tvec3 c = Draw(p, rnd);\n\tc = pow(c, vec3(.4545)); // to approx sRGB gamut\n\tc += .6 / 256. * rnd; // dither\n\to = vec4(c, 1);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// fork of poor hydraulic erosion by stb at http://shadertoy.com/view/XsKGWG\n\n// TODO do I need pressure, to propagate waves and water motion properly?\n\n#define BufA     iChannel0\n#define Pebbles  iChannel1\n#define Kbd      iChannel3\n\nconst int // http://keycode.info\n  KEY_SPACE = 32\n, KEY_SHIFT = 16\n, KEY_C     = 67\n, KEY_W     = 87\n, KEY_A     = 65\n, KEY_S     = 83\n, KEY_D     = 68\n, KEY_Z     = 90\n, KEY_Q     = 81\n, KEY_O     = 79\n, KEY_E     = 69\n, KEY_G     = 71\n, KEY_COMMA = 188\n, KEY_LEFT  = 37 // arrow keys\n, KEY_RIGHT = 39\n, KEY_UP    = 38\n, KEY_DOWN  = 40\n, KEY_PGUP  = 33\n, KEY_PGDN  = 34\n// key bindings to local directions\n// can be customized as necessary\n#if 0\n  // AZERTY ZQSD\n, KEY_FW    = KEY_Z\n, KEY_LF    = KEY_Q\n, KEY_BW    = KEY_S\n, KEY_RT    = KEY_D\n#elif 0\n  // DVORAK ,AOE\n, KEY_FW    = KEY_COMMA\n, KEY_LF    = KEY_A\n, KEY_BW    = KEY_O\n, KEY_RT    = KEY_E\n#else\n  // QWERTY WASD\n, KEY_FW    = KEY_W\n, KEY_LF    = KEY_A\n, KEY_BW    = KEY_S\n, KEY_RT    = KEY_D\n#endif\n// FIXME up/down controls probably not great for\n// non-QWERTY layouts, but can swap to PGUP/DN\n, KEY_UW    = KEY_SPACE // up\n, KEY_DW    = KEY_C     // down\n// FIXME turn keys will only really work for QWERTY\n, KEY_TURNL = KEY_Q // KEY_DEL\n, KEY_TURNR = KEY_E // KEY_END\n//, KEY_F     = 70\n, KEY_R     = 82\n//, KEY_V     = 86\n//, KEY_X     = 88\n//, KEY_TAB   = 9\n;\n// http://wikipedia.org/wiki/Arrow_keys#WASD_keys\n\nfloat key(int vk)\n{\n    return step(.5, fetch(Kbd, ivec2(vk, 0)).x);\n}\n\nbool option(int vk)\n{\n    return fetch(Kbd, ivec2(vk, 2)).x > .5;\n}\n\n// hash without sine from https://shadertoy.com/view/4djSRW for adding rain\nfloat hash12(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(443.8975,397.2973, 491.1871));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// multiscale noise from image\nfloat getLand(vec2 p) \n{\n    float f = 0., anim = .1; //0.; //\n    for (int i = 0; i < 16; ++i) {\n        float pwv = pow(1.1, float(i));\n        f += .25 / pwv * texture(iChannel1, p*pwv+anim*iTime+.2+.2*float(i)).r;\n    }\n    return f;\n}\n// sample from old height data\n#define t2D(x, y) texture(iChannel0, fract(uv-vec2(x, y)/res))\n// was stb's mainImage, adapted into my data buffer update\nvoid InitData(inout vec4 fragColor, vec2 fragCoord, vec2 res, inout bool init) \n{\n    if (IsStatePixel(ivec2(fragCoord), ivec2(res))) return;\n    vec2 uv = fragCoord.xy / res;\n    \n    // land height & water volume (outputs)\n    float lh = fragColor.r, wv = fragColor.g, bed = fragColor.b;\n    init = init || \n        iFrame < 10 // delay because texture loading\n     || key(KEY_R) > .5 //texture(iChannel3, vec2(82.5/256., .2)).r > 0.) { // 'R' on keyboard?\n       ; // first frame operations\n    if (init) {\n        // texture scale\n        float ts = res.y*4.;\n        vec2 o = vec2(-.5, .5);\n        vec2 suv = smoothstep(0., 1., uv);\n        float h1 = hash12(uv), h2 = hash12(uv*2.), h3 = hash12(uv*3.);\n        // tiled landscape\n        lh = mix(mix(\n                getLand((fragCoord-o.xx*res)/ts),\n                getLand((fragCoord-o.yx*res)/ts),\n                suv.x\n              ), mix(\n                getLand((fragCoord-o.xy*res)/ts),\n                getLand((fragCoord-o.yy*res)/ts),\n                suv.x\n              ), suv.y);\n        lh += .001*h2 + .002*h1;\n        // bedrock - store at first frame and put into z channel\n    \t//bed = lh * .85;\n        //bed = mix(.8, .98, hash12(uv * 16.)) * lh;\n        bed = lh * (sin(uv.x*tau*9.)*sin(uv.y*tau*9.)*.04 + .95)\n                    - (.01*h1 + .005*h2);\n        //    lh = sin(suv.x*tau*2.)*sin(suv.y*tau*2.)*.125 + .5; // HACK sinewaves\n        wv = 8e-3 * lh;// * (h3+h2); //0.; // start with some water, not too much though, mostly high altitude\n        \n    } else { // simulation\n\t    vec4 buf[9];\n\t    buf[0] = t2D(0.,  0.);\n\t    buf[1] = t2D(1.,  0.);\n\t    buf[2] = t2D(-1., 0.);\n\t    buf[3] = t2D(0.,  1.);\n\t    buf[4] = t2D(0., -1.);\n\t    buf[5] = t2D(1.,  1.);\n\t    buf[6] = t2D(-1., 1.);\n\t    buf[7] = t2D(1., -1.);\n\t    buf[8] = t2D(-1.,-1.);\n\t\tfloat clipr = 1.+float(slotCount);\n        if (all(lessThan(mod(fragCoord + clipr, res), vec2(clipr*2.+1.)))) {\n            for (int k = 0; k < 9; ++k)\n\t            buf[k] = vec4(.7,.1,0,0);\n            // can turn it back into a huge deep pit if you want; I'm trying to hide it!\n            // also making it fill with water, making a big lake in a dormant volcano \n        }\n\t    float lhc = buf[0].r;  // land  height (this cell)\n\t    float wvc = buf[0].g;  // water volume (this cell)\n\t    float brc = buf[0].b;  // bedrock height (this cell)\n        float whc = wvc + lhc; // water height (this cell)\n    \n\t\tlh = lhc;\n        wv = wvc;\n        bed = brc;\n        for (int i=1; i<9; ++i) {\n            float lhi = buf[i].r  // land height (neighboring cell)\n            , wvi = buf[i].g  // water volume (neighboring cell)\n            , whi = wvi + lhi // water height (neighboring cell)\n            , wslope = whi - whc // water slope\n            , lslope = lhi - lhc; // land slope\n            \n            // normalize corner weights for slopes\n            if (i>4) {\n                wslope /= sqrt(2.);\n                lslope /= sqrt(2.);\n            }\n            \n            const float wscale = 1./9., escale = .04, cscale = 6000.;\n            if (true && wvc>0. && wslope<0.) {                \n                // give water\n                float g = wslope * min(wvc * cscale, 1.);\n                wv += wscale * g;\n                \n                //if (lslope<0.) // basic erosion\n            \t\tlh += escale * g * 1.01; // give land too\n            }\n            \n            if (true && wvi>0. && wslope>0.) {                \n                // take water (currently less than it should, to help keep water from sticking to slopes)\n                float g = wslope * min(wvi * cscale, 1.);\n                wv += wscale * g * .99;\n                \n                //if (lslope>0.) // basic silt deposition\n            \t\tlh += escale * g;\n                // giving more than we take makes overall\n                // land total stay more consistent but\n                // seems to cause formation of small lakes\n                // instead of flowing rivers\n            }\n            \n            // give & take land base on water slope (help smooth things out)\n            if (false && wvc>0.) //&& wvi>0.) // only if there's actually water present!\n            \tlh += .0005 * wslope * wvc; // * wvi;\n            \n            // collapse steep land slopes (loss only)(helps widen gullies)\n            if (true \n              //  && iTime < 18.\n                && lslope < -.002-.004*hash12(uv)) //-.004) //\n                lh += lslope / 9.;\n            // is good and really helps esp at the start, to make the terrain much more naturally shaped\n        }\n        \n        // add land based on water volume - makes flood plains\n        //lh += .0001 * max(0., wv);\n        // without, water tends to stick to the slopes\n        if (lh < bed) lh = bed; // max - prevent erosion past bedrock height, preserves some features\n        \n        if (true) { // 'evaporation'\n        \t//wv -= 1. / 65535.;\n    \t\t//wv *= .98; // drain water!! HACK\n        \twv *= exp2(-5e-2*iTimeDelta); // more draining/evaporation HACK\n        }\n        // 'rain'\n        if (true && hash12(uv*.5+fract(iTime)/100.) > .99991)\n            wv += .5 / 65535.;\n        // 'springs'\n        if (false && brc > .66 && hash12(uv*3.) > .99987)\n            wv += 1280. / 65535.; //, lh = brc + .02; //lh += 128. / 65535.; //mix(lh, lhc, .999);\n        //if (all(lessThan(mod(fragCoord + 2., res), vec2(5)))) {\n        //    lh = lhc; wv = wvc;\n        //}\n    }\n    wv = clamp(wv, 0., 1.); // idk if I should clamp water to zero or not\n    lh = clamp(lh, 0., 1.); // just in case - prevent NaN propagation hopefully\n    // good thing, too, otherwise the \"crater\" or \"lake\" or \"volcano\" that\n    // happen in the corners of the heightmap would spread all over the \n    // whole world after a few seconds!  FIXME find what went wrong there,\n    // but the crater thing is cool, I want to keep it :)\n    // honestly I believe it's the state data pixels!!\n    fragColor = vec4(lh, wv, bed, 0);\n}\n\n// Walk Camera's BufferA from https://shadertoy.com/view/wlfcz2\n\nconst float \n  eyeradius = .25 // collision size\n, eyespeed = 8. // eye max velocity; shift doubles it\n, eyespin = 2.    // spin rate per mouse uv\n, eyesmooth = .05 // just a little is plenty\n, eyeh = 1.5 //0. //.75 - eyeradius //\n, eyeacc = 3. // eye acceleration\n, eyeldamp = 4. // friction\n, eyevdamp = .1 // air resistance\n;\nconst vec3 grav = vec3(0,-9.8,0); // gravity force\n\nstruct Inputs\n{\n    vec3 move;\n    vec2 mouse;\n    vec2 turn; // keyboard turning\n    float dt; // delta time seconds\n    bool button;\n    bool attract;\n    // debug features TODO\n};\n\nvoid LoadInputs(out Inputs inp)\n{\n    inp.button = iMouse.z >= 0.;\n    inp.mouse = iMouse.xy;\n    inp.attract = !inp.button && dot(inp.mouse, inp.mouse) < 4.;\n    if (inp.attract) { // icon?\n        inp.mouse.x = .02*iTime; // slow spin\n        inp.mouse.y = iResolution.y*.5; // don't look at ground\n    }\n    inp.move =\n      vec3(key(KEY_RT) - key(KEY_LF)\n         , key(KEY_UW) - key(KEY_DW)\n         , key(KEY_FW) - key(KEY_BW))\n    + vec3(key(KEY_RIGHT) - key(KEY_LEFT)\n         , key(KEY_PGUP ) - key(KEY_PGDN)\n         , key(KEY_UP   ) - key(KEY_DOWN)) // arrows alternate controls\n      ;\n    inp.turn = vec2(key(KEY_TURNR) - key(KEY_TURNL), 0);\n    inp.dt = iTimeDelta;\n}\n\n#if COLLISION\n// vertically-oriented capsule as collision shape\n// ofs = half-seg-offset from center to one end of the core segment,\n// radius of capsule segment poof\n// HACK just tests closest of a string of spheres along the capsule\nvoid CollideCapsule(inout vec3 pos, vec3 ofs, float radius)\n{\n    vec3 p = pos, no; float d = 3.4e38;\n\tint ncapsph = IZERO + 5; //7; //9; //3; //\n\tfor (float d2, st = 2./float(ncapsph), j = -1.; j <= 1.; j += st) {\n\t\tvec3 ns = sceneNormal(BufA, p + j * ofs, .1*radius, IZERO, d2);\n\t\tif (d2 < d) { d = d2; no = ns; }\n\t}\n\tpos -= no * min(0., d  - radius);\n}\n\nbool CollideEye(inout vec3 p)\n{\n\tfloat eh = .5 * eyeh - eyeradius;\n\tvec3 po = p; // HACK not best way to detect collision; too late anyway\n\t// FIXME should actually distribute the movement throughout all these iterations - see fixes in Plumbing Maze\n\t// multiple collision iterations to prevent tunnelling at low fps\n\tfor (int i = 3; --i >= 0; ) { // repeating helps with getting stuck in crevices\n\t\tp.y -= eh; // capsule center is below the eyes\n\t\tCollideCapsule(p, vec3(0,eh,0), eyeradius);\n\t\tp.y += eh;\n//\t\tpos.y = max(pos.y, radius + abs(ofs.y)); // HACK prevent going beneath ground plane just in case\n\t} // FIXME the response when stepping up onto steps can be extremely bouncy\n\treturn dot(po-p,po-p) > 1e-8; // must be very sensitive; probably breaks at high fps\n}\n#endif\n\nvoid MoveCamera(inout State state, Inputs inp) \n{\n    if (FLY==0 && WALK==0) return;\n    vec2 oa = state.eyeaim;\n    mat3 view = Camera(oa);\n    float d, spd = eyespeed, dt = inp.dt;\n    spd *= 1. + key(KEY_SHIFT);\n    vec3 op = state.eyepos\n    , move = inp.move * dt * spd \n    , p = op\n    ;\n    bool usegravity = /*!*/option(KEY_G) // 'G' = 71\n    , walking = WALK!=0 && (FLY==0 || usegravity)\n    , flying = FLY!=0 && !walking; //FLY!=0 && (WALK==0 || !usegravity)    \n    if (walking) {\n        move = view * move; // to world space\n\t\t// should not be able to fly simply by looking down or up,\n        // so remove portion of input directed along gravity vector\n        move -= grav * dot(move, grav) / dot(grav, grav);\n        // TODO reduce air control - need grounded state\n        // gravity requires velocity state\n    \tstate.eyevel += dt * grav; // gravity force - wrong for Euler integration\n        state.eyevel += 2. * dt * dt * grav; // correction for above issue - unsure if right\n        state.eyevel += move * eyeacc; // control force\n        state.eyevel *= exp2(-dt*vec3(eyeldamp,eyevdamp,eyeldamp)); // damping\n    \tp += dt * state.eyevel; // momentum\n    } else if (flying) {\n     \tp += view * move;\n    }\n    bool collided = false;\n  #if COLLISION    \n    collided = CollideEye(p);\n    // TODO save collided to grounded state?\n  #endif\n    state.eyepos = p;\n    state.eyevel = (p - op) / max(1e-7, dt);\n    float evl2 = dot(state.eyevel, state.eyevel);\n    state.eyevel *= isnan(evl2) ? 0. : evl2 > 5e3 ? .5 : 1.;\n    if (walking && collided && inp.move.y > 0. && dot(state.eyevel, grav) >= 0.)\n        state.eyevel -= .5*grav; // up is jump // TODO sqrt (.5*h)\n}\n\nvoid TurnCamera(inout State state, Inputs inp) \n{\n    vec2 R = vec2(state.resolution)\n    , oa = state.eyeaim\n    , a = oa;\n    if (state.mbdown && inp.button)\n        a = (inp.mouse - abs(iMouse.zw)) / R * vec2(2) + state.aimbase;\n    a += inp.turn * mix(.5, 1., key(KEY_SHIFT)) * inp.dt;\n    a.x = fract(a.x);\n    a.y = clamp(a.y, 0., 1.);\n    if (abs(a.x - oa.x) > .5)\n        oa.x += sign(a.x - oa.x); // put on side of nearest wrapped angle\n    if (dot(inp.turn,inp.turn) < 1e-3) // only if not key turning, because that doesn't work well\n    \ta = mix(a, oa, exp2(-inp.dt / eyesmooth)); // smooth interpolate mouse aim\n    else\n    // key turning should update the aimbase,\n    // to prevent it snapping back when the mouse is next clicked.\n        state.aimbase = state.eyeaim;\n    state.eyeaim = a;\n}\n\nvoid Update(inout State state, ivec2 R, inout bool init)\n{\n    Inputs inp;\n    LoadInputs(inp);\n    if (state.resolution != R) { // resized?\n        init = true; state.resolution = R; \n    }\n    if (init) { // if zeroes aren't good enough\n        state.eyepos = vec3(.5*tscale\n                          , 0 //eyeh+.5*eyeradius\n                          , .5*tscale\n                           );\n        state.aimbase = \n        state.eyeaim = vec2(0.,.5);\n        state.mbdown = false;\n    } else { // update state\n        MoveCamera(state, inp);\n\t    TurnCamera(state, inp);\n        if (state.mbdown && !inp.button) // on mouse up\n    \t    state.aimbase = state.eyeaim; // record aim base\n        state.mbdown = inp.button;\n    }\n}\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    ivec2 R = ivec2(iResolution)\n    , i = ivec2(p);\n    State state;\n    LoadState(state, BufA, R);\n    bool init = iFrame == 0;\n    Update(state, R, init);\n\t// Usually prior data is loaded and passed through unchanged.\n    vec4 c = fetch(BufA, i);\n    InitData(c, p, iResolution.xy, init);\n    if (init) { state.eyepos.y = -.1*displ; } //0.; }\n    SaveState(c, state, i);\n    o = c;\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// shared from Walk Camera\n\n#define IZERO min(0, iFrame)\n\n// enable gravity feature\n#define WALK 1\n// enable antigravity feature\n#define FLY  1\n// camera fixed if neither is enabled\n#define COLLISION 1\n\n#define BufA iChannel0\n#define ResA iChannelResolution[0].xy\n\nconst float\n  tau = 2. * acos(-1.) //6.28318531 //\n, tscale = 4.*512. // terrain extent in world units\n, displ = 8.*128. // terrain vertical displacement\n;\n// cos,sin of full turns angle; e^(i*r*tau) = Euler's identity but in turns not radians\nvec2 spin(float r)\n{\n    return sin((r + vec2(.25, 0)) * tau);\n}\n\nmat2 mrot(vec2 cs)\n{\n\treturn mat2(cs.x,-cs.y\n              , cs.y, cs.x);\n}\n\nvoid rot(inout float a, inout float b, mat2 m)\n{\n    vec2 r = m * vec2(a, b); a = r.x; b = r.y;\n}\n\n// Rodrigues' formula rotation by \n// arbitrary unit axis and radian angle\nvec3 prot(vec3 p, vec3 axis, float angle) \n{\n    float c = cos(angle), s = sin(angle);\n    return c * p\n        + (1.-c) * dot(p, axis) * axis\n        + s * cross(p, axis);\n}\n\nvoid rot(inout vec2 a, inout vec2 b, mat2 m)\n{\n    rot(a.x, b.x, m);\n\trot(a.y, b.y, m);\n}\n\nvoid rot(inout vec3 a, inout vec3 b, mat2 m)\n{\n    rot(a.x, b.x, m);\n\trot(a.y, b.y, m);\n    rot(a.z, b.z, m);\n}\n\n// given two fractions azimuth and elevation,\n// return orthonormal camera to world matrix\nmat3 Camera(vec2 uv)\n{\n    mat3 m = mat3(1);\n    rot(m[0], m[2], mrot(spin(-1.*uv.x)));\n    rot(m[1], m[2], mrot(spin(.25 - .5*uv.y)));\n    return m; \n}\n\nvec4 fetch(sampler2D ch, ivec2 p)\n{\n\treturn texelFetch(ch, p, 0);\n}\n\nstruct State\n{\n    ivec2 resolution; // window resolution\n    vec3 eyepos;\n    vec3 eyevel;\n    vec2 eyeaim;\n    vec2 aimbase; // involved in mouse lookaround\n    bool mbdown; // mouse button was down?\n};\n\nconst int\n  slotResMBD     = 0 // w unused\n, slotEyePos     = 1 // w unused\n, slotEyeVel     = 2 // w unused\n, slotAzElBase   = 3 // azimuth and elevation of aim, also recorded on mouse up\n, slotCount      = 4\n;\n\nbool IsStatePixel(ivec2 i, ivec2 R)\n{\n   \treturn i.y == R.y-1 && i.x >= R.x-1-slotCount;\n}\n\n// TODO I could coexist with the heightmap data more peacefully\n// if I only used the unused fields to store data (currently z and w are unused)\n// otherwise I must patch around the artifacts caused by the data pixels\n// which include a massive crater pit!\n\n// cache to and from state structure\nvoid LoadState(out State state, sampler2D A, ivec2 R)\n{\n\tvec4[slotCount] data; // at least temporarily\n\tfor (int i = slotCount; i-- > 0; )\n        data[i] = fetch(A, R-1-ivec2(i,0));\n    state.resolution = ivec2(data[slotResMBD].xy);\n    state.mbdown = data[slotResMBD].z > .5;\n    state.eyepos = data[slotEyePos].xyz;\n    state.eyevel = data[slotEyeVel].xyz;\n    state.eyeaim = data[slotAzElBase].xy;\n    state.aimbase = data[slotAzElBase].zw;\n}\n\n// only needed in Buffer A\n// but it mirrors LoadState\nvoid SaveState(inout vec4 c, State state, ivec2 p)\n{\n    ivec2 R = state.resolution;\n    if (p.y == R.y - 1) switch (R.x - 1 - p.x) { // IsStatePixel(p)\n      case slotResMBD:\n        c = vec4(R, state.mbdown ? 1. : 0., 0);\n        break;\n      case slotEyePos:\n        c = vec4(state.eyepos, 0.);\n        break;\n      case slotEyeVel:\n        c = vec4(state.eyevel, 0.);\n        break;\n      case slotAzElBase:\n        c = vec4(state.eyeaim, state.aimbase);\n        break;\n      default:\n        break;\n    }\n}\n\nvec4 tfetch(sampler2D ch, ivec2 t, ivec2 r)\n{\n    ivec2 c = t % r; //ivec2(uvec2(t) % uvec2(r)); //\n    if (c.x < 0) c.x += int(r.x); // % handles negative values differently on some platforms\n    if (c.y < 0) c.y += int(r.y);\n    return texelFetch(ch, c, 0); // software uv wrap on fetch\n}\n\nvec4 quadratic(vec4 a, vec4 b, vec4 c, float f)\n{\n    float g = (f + 1.) * .5, h = f * .5;\n    return mix(mix(a, b, g), mix(b, c, h), f);\n}\n\n// software biquadratic filter of texture, 9 taps\nvec4 biquadratic(sampler2D ch, vec2 q, vec2 r)\n{\n    vec2 s = q * r - .0; ivec2 t = ivec2(floor(s)), u = ivec2(r); s -= vec2(t);\n    vec4 a = tfetch(ch, t + ivec2(-1,-1), u)\n       , b = tfetch(ch, t + ivec2( 0,-1), u)\n       , c = tfetch(ch, t + ivec2( 1,-1), u)\n       , d = tfetch(ch, t + ivec2(-1, 0), u)\n       , e = tfetch(ch, t + ivec2( 0, 0), u)\n       , f = tfetch(ch, t + ivec2( 1, 0), u)\n       , g = tfetch(ch, t + ivec2(-1, 1), u)\n       , h = tfetch(ch, t + ivec2( 0, 1), u)\n       , i = tfetch(ch, t + ivec2( 1, 1), u)\n       ;\n   \tvec4 q0 = quadratic(a, b, c, s.x)\n       , q1 = quadratic(d, e, f, s.x)\n       , q2 = quadratic(g, h, i, s.x);\n    return quadratic(q0, q1, q2, s.y);\n}\n\nvec3 hillwaveheight(sampler2D ch, vec2 q)\n{\n    ivec2 chres = textureSize(ch, 0);\n    vec2 r = vec2(chres);\n    q = q / tscale; // texture scaling hack\n    q.x *= r.y / r.x; // aspect ratio hack\n  #if 1\n    // HACK hide the data pixels somehow; mask them off!\n    // otherwise causes a hole and strange shadow\n    // in the corner of the heightmap\n    // and can watch some pixels change value as you fly around\n    // FIXME still not ideal\n    if (all(greaterThanEqual(fract(q - 1./r.y) * r, r - vec2(slotCount+3, 3)))) //IsStatePixel(ivec2(mod(q + 0.*.5*r, r)), ivec2(r))) //\n        q.y = 1.-2./r.y; //3./r.y;  // just shift down a row; neighbor cell works better but is still a major discontinuity.    \n    \t//return .5; // replace with medium height isn't much better than unfixed!\n  #endif\n  #if 1\n    // biquadratic software filter heightmap\n    vec4 h4 = biquadratic(ch, q, r);\n  #elif 1\n    // bilinear software filter heightmap\n    vec4 h4 = bilinear(ch, q, ResA);\n  #else\n    // bilinear hardware filter heightmap - has severe subpixel precision issues\n    vec4 h4 = texture(ch, q);\n  #endif\n    float h = h4.x;\n    float w = h4.y;\n    return h4.rgb; //clamp(h, 0., 1.); // just in case\n}\n\nfloat sceneDistance(sampler2D ch, vec3 q)\n{\n    vec3 wh = hillwaveheight(ch, q.xz);\n    float th = wh.x + wh.y\n        , hd = q.y + (1. - th) * displ\n        , ld = q.y + 0.*displ; // clip plane?\n    hd *= .7; // HACK prevent nasty overstepping on steep slopes\n    return hd; //max(ld, hd); //min(ld, hd); //\n}\n\n// iq's looped simplex gradient, excellent!\n// http://iquilezles.org/articles/normalsSDF\nvec3 sceneNormal(sampler2D ch, vec3 q, float h, int zero, out float hd)\n{\n    vec3 n = vec3(0); float d = 0.;\n    for (int i = zero+4; i-- > 0; ) {\n        vec3 e = vec3((ivec3(i+3, i, i+i)&2) - 1);\n        float sd = sceneDistance(ch, q + e * h);\n        d += sd; \n        n += sd * e;\n    }\n    hd = .25 * d; // average distance ~= distance at center point q\n    return normalize(n);\n}\n","name":"Common","description":"","type":"common"}]}