{"ver":"0.1","info":{"id":"3tsXRN","date":"1562272000","viewed":268,"name":"Cave water","username":"ParaBellum","description":"I saw this shader:\nhttps://www.shadertoy.com/view/MdcXR8\nand I liked very much so I decided to do the same in my own version :D\n\nSorry for use microsoft edge :(\n","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["2d","noise","water","light"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* MUST READ!!!!!! :D\nThis shader had a problem and I didnÂ´t notice because I use Microsoft Edge,\nthe problem was the next:\n\"IF YOU USE A TEXTURE WITH ONLY 1 CHANNEL LIKE THE PEBBLES TEXTURE, THE \nMOMENT YOU READ IT YOU MUST USE THE RED CHANENL LIKE THIS:\ntexture(sampler2D, vec2).r / .x\nORIGINALLY I HAD THIS SHADER AS:\ntexture(sampler2D, vec2).b SO IT COULDN'T BE APPRECIATED CORRECTLY,\nBECAUSE I WAS USING EDGE AND IN MICROSOFT EDGE IT WORKS.\nSo if you change the line 47 as the comment says you will see the problem.\"\n*/\n\nvec3 cw = vec3(.0509, .2431, .3745);\nvec3 w = vec3(1.);\n\nfloat sdCircle(vec2 p, float r)\n{\n    return length(p) - r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 frag = fragCoord.xy;\n    vec2 uv = frag/iResolution.xy;\n    vec2 st = uv;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec2 ms = vec2(.5);\n    \n    vec2 e = vec2(1., 0.);\n    vec2 r_uv = (frag-e.xy)/iResolution.xy;\n    vec2 r_st = r_uv;\n    r_uv.x *= iResolution.x / iResolution.y;\n    vec2 a_uv = (frag-e.yx)/iResolution.xy;\n    vec2 a_st = a_uv;\n    a_uv.x *= iResolution.x / iResolution.y;\n    \n    float noise = texture(iChannel3, st).r;\n    float r_noise = texture(iChannel3, r_st).r;\n    float a_noise = texture(iChannel3, a_st).r;\n    \n    vec3 col = vec3(0.);\n    float m = 1.-sdCircle(uv-ms, .6);\n    \n    // Use .b instead of .r to see the problem in Chrome or Firefox (in Edge remains the same)\n    float z = texture(iChannel0, uv+(noise*.025)).r;\n    if (z*noise < .3)\n    {\n        \n        float r_z = texture(iChannel0, r_uv+(noise*.025)).r;\n        float a_z = texture(iChannel0, a_uv+(noise*.025)).r;\n\t\t\n        vec3 noisePos = vec3(st, noise);\n        vec3 r_noisePos = vec3(r_st, r_noise);\n        vec3 a_noisePos = vec3(a_st, a_noise);\n        \n        vec3 fragPos = vec3(uv, z);\n        vec3 r_fragPos = vec3(r_uv, r_z);\n        vec3 a_fragPos = vec3(a_uv, a_z);\n\n        vec3 a_n = r_noisePos - noisePos;\n        vec3 b_n = a_noisePos - noisePos;\n        vec3 c_n = cross(a_n, b_n);\n        \n        vec3 a = r_fragPos - fragPos;\n        vec3 b = a_fragPos - fragPos;\n        vec3 c = cross(a, b);\n\n        vec3 nor_n = normalize(c_n);\n        vec3 lightPos_n = vec3(ms, 1.);\n        vec3 lightDir_n = normalize(lightPos_n - noisePos);\n        vec3 eyeDir_n = normalize(vec3(uv, 3.));\n        vec3 halfWay_n = normalize(lightDir_n + eyeDir_n);\n\n        float al_n = z;\n        float dl_n = max(dot(nor_n, lightDir_n), 0.);\n        float sl_n = pow(max(dot(halfWay_n, nor_n), 0.), 2.);\n        float l_n = al_n + dl_n + sl_n;\n        \n        vec3 nor = normalize(c);\n        vec3 lightPos = vec3(ms, 3.);\n        vec3 lightDir = normalize(lightPos - fragPos);\n        vec3 eyeDir = normalize(vec3(uv, 3.));\n        vec3 halfWay = normalize(lightDir + eyeDir);\n\n        float al = z*.25;\n        float dl = max(dot(nor, lightDir), 0.)*.75;\n        float sl = pow(max(dot(halfWay, nor), 0.), 2.);\n        float l = al + dl + sl;\n\n        vec3 ground = mix(texture(iChannel1, uv+(noise*.009)).rgb, texture(iChannel2, uv+(noise*.009)).rgb, .25);\n        col += ground * l;\n        col += ground*mix(w*l_n, cw, noise);\n\t}\n    else\n    {\n        z = texture(iChannel0, uv).r;\n        float r_z = texture(iChannel0, r_uv).r;\n        float a_z = texture(iChannel0, a_uv).r;\n\n        vec3 fragPos = vec3(uv, z);\n        vec3 r_fragPos = vec3(r_uv, r_z);\n        vec3 a_fragPos = vec3(a_uv, a_z);\n\n        vec3 a = r_fragPos - fragPos;\n        vec3 b = a_fragPos - fragPos;\n        vec3 c = cross(a, b);\n\n        vec3 nor = normalize(c);\n        vec3 lightPos = vec3(ms, 3.);\n        vec3 lightDir = normalize(lightPos - fragPos);\n        vec3 eyeDir = normalize(vec3(uv, 3.));\n        vec3 halfWay = normalize(lightDir + eyeDir);\n\n        float al = z*.15;\n        float dl = max(dot(nor, lightDir), 0.)*.5;\n        float sl = pow(max(dot(halfWay, nor), 0.), 2.);\n        float l = al + dl + sl;\n\n        vec3 ground = mix(texture(iChannel1, uv).rgb, texture(iChannel2, uv).rgb, .5);\n        col += ground * l;\n    }\n    col *= m;\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// 2D Random\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n    vec2 u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 frag = fragCoord.xy;\n    vec2 uv = frag/iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float size = 8.;\n    uv *= size;\n    \n    vec2 e = vec2(1., 0.);\n    vec2 r_uv = (frag-e.xy)/iResolution.xy;\n    r_uv *= size;\n    vec2 a_uv = (frag-e.yx)/iResolution.xy;\n    a_uv *= size;\n    \n    float z = noise(uv);\n    z += noise(uv+iTime)*.5;\n    float r_z = noise(r_uv);\n    r_z += noise(r_uv+iTime)*.4;\n    float a_z = noise(a_uv);\n    a_z += noise(a_uv+iTime)*.4;\n    \n    vec3 fragPos = vec3(uv, z);\n    vec3 r_fragPos = vec3(r_uv, r_z);\n    vec3 a_fragPos = vec3(a_uv, a_z);\n    \n    vec3 a = r_fragPos - fragPos;\n    vec3 b = a_fragPos - fragPos;\n    \n    vec3 nor = normalize(cross(a, b));\n    \n    vec3 col = vec3(0.);\n    col += z;\n\n    fragColor = vec4(col, 1.);\n}","name":"Buffer A","description":"","type":"buffer"}]}