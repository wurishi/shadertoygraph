{"ver":"0.1","info":{"id":"MttSzM","date":"1478867567","viewed":491,"name":"TheDream","username":"dila","description":"Had a go at producing some more interesting textures instead of using the raw stock images.","likes":28,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 col1 = vec3(0.659, 0.435, 0.18);\nvec3 col2 = vec3(0.455, 0.349, 0.059);\nvec3 col3 = vec3(0.667, 0.569, 0.514);\n\nfloat hash( float n ) { return fract(sin(n)*13.5453123); }\nvec2 hash2(vec2 p) { return vec2(hash(p.x), hash(p.y)); }\n\nmat2 rot(float x)\n{\n    return mat2(cos(x), sin(x), -sin(x), cos(x));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdBoxZ( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,d.y),0.0) + length(max(d.xy,0.0));\n}\n\nfloat cylinder(vec3 p, vec2 b)\n{\n    float d = length(p.yz) - b.x;\n    float k = b.y - abs(p.x);\n    return max(d, -k);\n}\n\nfloat mid = 0.0;\nvec3 mpos = vec3(0.0);\n\nfloat rs = 11.0;\nfloat hs = 6.0;\n\nfloat picpos(vec3 p)\n{\n    return floor(p.z / hs + 0.5) + floor(p.x / rs * 7.0 + 0.5);\n}\n\nfloat cam = 0.25;\n\nfloat map(vec3 p)\n{\n    p.y += sin(p.z * cam);\n    \n    mid = 0.0;\n    mpos = p;\n    \n    float rw = 4.2;\n    float rh = 4.0;\n    float fx = (fract(p.x / rs - 0.5) - 0.5) * rs;\n    vec3 rp = vec3(p.x, p.y, p.z);\n\tfloat rd = -sdBoxZ(rp, vec3(rw, rh, 1.0));\n\n    vec3 kp = vec3(abs(p.x) - rw * 1.75 - 1.0, p.y, p.z);\n    float kd = -sdBoxZ(kp, vec3(rw * 0.75, rh, 1.0));\n    if (kd > rd) {\n        rd = kd;\n        mid = 3.0;\n    }\n    \n    float ct = 0.1;\n    float ax = abs(p.x) - rw + ct;\n    float cx = (fract(ax / rs - 0.5) - 0.5) * rs;\n    vec3 hp = vec3(ax, p.y, (fract(p.z / hs) - 0.5) * hs);\n    float hd = -sdBox(hp, vec3(2.0, 2.0, 1.5));\n    \n    float d = rd;\n    if (hd > rd) {\n        d = hd;\n        mid = 1.0;\n    }\n\n    vec3 cp = vec3(ax, p.y, (fract(p.z / hs + 0.5) - 0.5) * hs);\n    cp.yz *= rot(iTime * 1.25 + picpos(p));\n    float cd = cylinder(cp, vec2(2.0, ct));\n    \n    if (cd < d) {\n        d = cd;\n        mid = 2.0;\n        mpos = cp;\n    }\n    \n    return d;\n}\n\nvec3 normal(vec3 p)\n{\n\tvec3 o = vec3(0.01, 0.0, 0.0);\n    return normalize(vec3(map(p+o.xyy) - map(p-o.xyy),\n                          map(p+o.yxy) - map(p-o.yxy),\n                          map(p+o.yyx) - map(p-o.yyx)));\n}\n\nfloat trace(vec3 o, vec3 r)\n{\n    float t = 0.0;\n    for (int i = 0; i < 40; ++i) {\n        t += map(o + r * t);\n    }\n    return t;\n}\n\nvec3 strips(vec2 p)\n{\n    float gap = 0.25;\n    float fy = fract(p.y);\n    float kx = max(fy - gap, 0.0) / (1.0 - gap);\n    float ky = min(fy, gap) / gap;\n    float ku = 4.0 * kx * (1.0 - kx);\n    ku = 1.0 - pow(1.0 - ku, 5.0);\n    vec3 tex = texture(iChannel0, p * 0.1).xyz;\n    tex *= tex;\n    float dark = 1.0 - ky;\n    dark = dark * dark;\n    vec3 gs = mix(col3 * 0.125, col3, dark);\n    return tex * (col3 * ku + gs);\n}\n\nvec3 tiles(vec2 p)\n{\n    p *= 0.5;\n    vec2 f = fract(p);\n    float gap = 0.01;\n    vec2 kx = max(f - gap, 0.0) / (1.0 - gap);\n    vec2 ky = min(f, gap) / gap;\n    vec2 ku = 4.0 * kx * (1.0 - kx);\n    ku = pow(1.0 - ku, vec2(5.0));\n    vec2 fp = floor(p);\n    vec2 tu = hash2(fp) * 1000.0 + fract(p);\n    vec3 tex = texture(iChannel1, tu * 0.1).xyz;\n    tex *= tex;\n    float bwt = dot(tex, vec3(0.299, 0.587, 0.114));\n    float alt = mod(fp.x + fp.y, 2.0);\n    float gc = max(ku.x, ku.y);\n    vec3 gl = mix(col3 * bwt * 0.5, col3 * (1.0 - bwt), alt);\n    vec3 gs = mix(col1, col1 * 0.125, max(ku.x, ku.y));\n    return mix(gl, gs, gc);\n}\n\nvec3 picture(vec3 p, vec3 w)\n{\n    vec2 q = p.yz;\n    q *= 0.5;\n    float d = 1000.0;\n    vec2 tuv = vec2(0.0);\n    float fid = 0.0;\n    float pp = picpos(w) * 3.14159 * 0.125;\n    const int n = 5;\n    for (int i = 0; i < n; ++i) {\n        float fi = float(i) / float(n);\n        q = abs(q) - 0.25;\n        q *= rot(3.14159 * 0.25 + pp * 3.345);\n        q.y = abs(q.y) - 0.25;\n        q *= rot(pp);\n        float b = sdBoxZ(vec3(q, 0.0), vec3(0.5, 0.125, 1.0));\n        if (b < d) {\n            d = b;\n            tuv = q;\n            fid = fi;\n        }\n    }\n    vec3 tex = texture(iChannel1, tuv * 0.1).xyz;\n    tex *= tex;\n    tex = mix(col3, tex * col3, 1.0-fid);\n    return tex;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 o = vec3(0.0, 0.0, iTime * 2.0);\n    vec3 r = normalize(vec3(uv, 0.7 - dot(uv, uv) * 0.5));\n    \n    o.y -= sin(o.z * cam);\n    r.xy *= rot(sin(iTime * 0.125) * 3.14159 * 0.125);\n    \n    float t = trace(o, r);\n    vec3 w = o + r * t;\n    vec3 sn = normal(w);\n    \n    vec3 tex = vec3(1.0);\n\n    if (mid == 1.0) {\n        if (abs(sn.y) < 0.1) {\n            tex = strips(mpos.xy);\n        } else {\n            tex = strips(mpos.xy);\n        }\n    } else if (mid == 2.0) {\n        if (abs(sn.x) < 0.1) {\n            tex = col1 * 0.25;\n        } else {\n            tex = picture(mpos, w);\n        }\n    } else if (mid == 3.0) {\n        vec2 st = mpos.yz - 2.0 * vec2(0.0, o.z);\n        tex = tiles(st);\n    } else if (abs(sn.y) < 0.1) {\n        tex = strips(mpos.zy);\n    } else {\n        vec2 st = mpos.xz + vec2(0.0, o.z);\n        tex = tiles(st);\n    }\n    \n    vec3 lit = vec3(0.3);\n    \n    vec3 lpos = o + vec3(0.0, 0.0, 0.0);\n    lpos += vec3(0.0, 0.0, 0.0);\n    vec3 ldel = w - lpos;\n    float ldist = length(ldel);\n    ldel /= ldist;\n    float lm = max(dot(ldel, -sn), 0.0);\n    lm /= 1.0 + ldist * ldist * 0.1;\n    lit += vec3(lm) * col3 * 2.0;\n    \n\tfloat aoc = map(w + sn * 1.2);\n    float fog = 1.0 / (1.0 + t * t * 0.001);\n    vec3 fc = lit * tex * aoc * fog;\n\tfragColor = vec4(sqrt(fc), 1.0);\n}","name":"Image","description":"","type":"image"}]}