{"ver":"0.1","info":{"id":"llBSD3","date":"1446827843","viewed":554,"name":"Pixelated Hourglass","username":"phi16","description":"30sec animation","likes":26,"published":1,"flags":0,"usePreview":0,"tags":["pixel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"float noise( in vec3 x )//https://www.shadertoy.com/view/4sfGzS\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel0, (uv+0.5)/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\nfloat erf(float x) {\n  float s = sign(x), a = abs(x);\n  x = 1.0 + (0.278393 + (0.230389 + 0.078108 * (a * a)) * a) * a;\n  x *= x;\n  return s - s / (x * x);\n}\nvec3 pixelImage(int x,int y,vec3 lg){\n    int dx = x-24;\n    int dy = y-18;\n    if(dx<0)dx=-dx;\n    if(dy<0)dy=-dy;\n    if(dx<10 && dy<15){\n        float xu = float(x-24)/10.0;\n        lg=normalize(lg);\n        if(dy>12){\n            vec3 b = vec3(1.0,0.4,0.0);\n            vec3 n = vec3(xu,sqrt(1.0-xu*xu),0);\n            if(y==5 || y==32)n.z=0.2;\n            n=normalize(n);\n            vec3 diff = b*(dot(n,lg)+0.8)/2.3;\n            vec3 lig = vec3(1,1,1)*pow(max(0.0,dot(reflect(vec3(0,-1,0),n),lg)),2.0)/3.0;\n            return diff+lig;\n        }else{\n            float yi = float(y-18)/12.0;\n            float dist = 1.0-exp(-yi*yi*7.5*16.0/25.0)*0.85;\n            if(dist>abs(xu)){\n                float fra = xu/dist;\n                vec3 n = vec3(fra,0,0);\n                n.y=sqrt(1.0-n.x*n.x);\n                n.z=-sin(yi*3.1415926535);\n                n=normalize(n);\n                float spec = 0.0;\n                spec += max(0.0,dot(n,lg)*0.9+0.1)/1.6;\n                if(dist<=abs(xu)+0.1)spec+=0.3;\n                spec += pow(max(0.0,dot(reflect(vec3(0,-1,0),n),lg)),3.0)/5.0;\n                spec += abs(yi)*pow(max(0.0,dot(reflect(vec3(0,-1,0),n),vec3(sqrt(2.0)/2.0*lg.x*5.0,sqrt(2.0)/2.0,lg.z))),2.0)/8.0;\n                \n                vec3 sand = mix(vec3(0.3,0.2,0.0),vec3(0.9,0.8,0.5),noise(vec3(float(x-24)*sign(yi),abs(yi*400.0),7))*0.5+0.5);\n                \n                float time = mod(iDate.w/30.0,1.0);\n                float wMax=dist;\n                if(x!=24 || yi > 0.0 || abs(mod(time*120.0,1.0)+yi) > 0.08){\n                    float A = 0.0714648/2.0;\n                    float C = -4.12596*erf(0.365148*yi)+1.23993*erf(0.516398*yi)+yi+0.0357324;\n                    if(yi<0.0)wMax = min(wMax,max(0.0,pow((C-time*A+0.005)*32.0,1.0/1.4)));\n                    C+=pow(abs(xu),1.4)/32.0-0.005;\n                    if(yi<0.0 && time<C/A)sand=vec3(1,1,1);\n                    C = 4.12596*erf(0.365148*yi)-1.23993*erf(0.516398*yi)-yi+0.0357324;\n                    if(yi>0.0 && time>C/A)sand=vec3(1,1,1);\n                }\n                if(sand.z<0.9){\n                    float is = xu/wMax;\n                    vec3 n2 = vec3(is,sqrt(1.0-is*is),0.0);\n                    sand *= (max(0.0,dot(reflect(vec3(0,-1,0),n2),lg))/1.5+1.5)*0.8;\n                }\n                if(dist<=abs(xu)+0.1)sand=(vec3(1,1,1)+sand)/2.0;\n                return vec3(spec)*sand;\n            }else return vec3(0.2,0.2,0.2);\n        }\n    }\n    return vec3(0.2,0.2,0.2);\n}\nvec3 imageFilter(vec2 pos, float rot){\n    vec3 lg = vec3(0.2,0.4,0.15);\n    lg.xz*=cos(rot);\n    vec3 color = pixelImage(int(pos.x*16.0+24.5),int(pos.y*16.0+18.5),lg);\n    vec2 di = mod(pos+1.0/32.0,1.0/16.0)*16.0-0.5;\n    color *= pow(0.5-abs(di.x),0.2)+pow(0.5-abs(di.y),0.2);\n    /*\n\tvec2 du = vec2(0,0);\n    du.x = di.x * cos(rot) - di.y * sin(rot);\n    du.y = di.x * sin(rot) + di.y * cos(rot);\n\t*/\n    float C = cos(rot), S = sin(rot);\n    vec2 du = di*mat2(C,-S,S,C);\n    \n    if(du.y>0.0)color*=0.8;\n    float le = length(pos)/2.0;\n    color *= pow(1.0/sqrt(le*le+1.0),4.0);\n    return color;\n}\nfloat ease(float t){\n    float s=1.0;\n    t+=1.0;\n    if(t<1.0){\n        return (t*t*((s+1.0)*t-s))-1.0;\n    }else{\n        t-=2.0;\n        return (t*t*((s+1.0)*t+s)+2.0)-1.0;\n    }\n}\nvec3 getColor(vec2 pos){\n\t/*\n\tvec2 uv = pos.xy / iResolution.xy;\n    uv*=2.0;\n    uv-=1.0;\n    uv.x*=iResolution.x/iResolution.y;\n\t*/\n\tvec2 R = iResolution.xy, \n\tuv = (2.*pos.xy - R)/R.y;\n    \n    float rotAngle = 0.0;\n    float tM = mod(iDate.w/30.0,1.0);\n    if(tM<0.05)rotAngle=-1.0+ease(tM*20.0);\n    if(tM>0.95)rotAngle=+1.0+ease((tM-1.0)*20.0);\n    rotAngle*=3.141592/2.0;\n    uv+=1.0/32.0;\n    /*\n\tvec2 q = uv;\n    q.x = uv.x * cos(rotAngle) - uv.y * sin(rotAngle);\n    q.y = uv.x * sin(rotAngle) + uv.y * cos(rotAngle);\n\t*/\n    float C = cos(rotAngle), S = sin(rotAngle);\n    vec2 q = uv*mat2(C,-S,S,C);\n    \n    return imageFilter(q,-rotAngle);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec3 c = vec3(0,0,0);\n    vec2 s = vec2(0.2,0);\n    c += getColor(fragCoord);\n    fragColor = vec4(c,1.0);\n}","name":"","description":"","type":"image"}]}