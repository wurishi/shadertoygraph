{"ver":"0.1","info":{"id":"XXj3Rz","date":"1708125734","viewed":131,"name":"Fast noise Fog","username":"Zentient","description":"Modified version of this shader:https://www.shadertoy.com/view/XXXGDs to use this noise algorithm (fractal bilinear value noise) https://www.shadertoy.com/view/X32GRz\n\nPerforms roughly 4x faster with equivalent steps. Roughly 125 fps on gtx 970","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["whitenoise","hashing"],"hasliked":0,"parentid":"XXXGDs","parentname":"noise fog raycaster"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define hashi(x)   lowbias32(x)\n#define hash(x)  ( float( hashi(x) ) / float( 0xffffffffU ) )\n\nconst float stepSize = 5.0; //larger values appear to have more detail but are less stable\nconst float octaves = 3.0; \nconst float occlusion = 10.0; //How dark the dark spots are\nconst float steps = 15.0;\nconst float innit = 10.0; //largest noise octave\n\n//bias: 0.17353355999581582\nuint lowbias32(uint x)\n{\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\n//Random function from: www.shadertoy.com/view/WttXWX\n\nfloat rand(vec3 position)\n{\n    uvec3 V = uvec3(abs(position)); //abs to prevent issues with negative values\n    float h = hash( V.x + (V.y<<16) + (V.z<<8) );  // 2D hash (should be ok too )\n    return h;\n\n}\n\n\n//Interpolation algorithm from https://www.shadertoy.com/view/X32GRz\nfloat interpolate(vec3 position)\n{\n    vec3 quantPos = round((position + 0.5));\n    vec3 divPos = fract(0.0 + (1.0 * position));\n    \n\n    //Finds noise values for the corners, treats Z axis as a separate rectnagle\n    vec4 lerpXY = vec4(\n        rand(quantPos + vec3(0.0, 0.0, 0.0)),\n        rand(quantPos + vec3(1.0, 0.0, 0.0)),\n        rand(quantPos + vec3(1.0, 1.0, 0.0)),\n        rand(quantPos + vec3(0.0, 1.0, 0.0)));\n    \n    vec4 lerpXYZ = vec4(\n        rand(quantPos + vec3(0.0, 0.0, 1.0)),\n        rand(quantPos + vec3(1.0, 0.0, 1.0)),\n        rand(quantPos + vec3(1.0, 1.0, 1.0)),\n        rand(quantPos + vec3(0.0, 1.0, 1.0)));\n    \n    //Calculates the area of rectangles\n    vec4 weights = vec4(\n    abs((1.0 - divPos.x) * (1.0 - divPos.y)),\n    abs((0.0 - divPos.x) * (1.0 - divPos.y)),\n    abs((0.0 - divPos.x) * (0.0 - divPos.y)),\n    abs((1.0 - divPos.x) * (0.0 - divPos.y)));\n    \n    //linear interpolation between values\n    vec4 lerpFinal = mix(lerpXY, lerpXYZ, divPos.z);\n   \n    float fin =  weights.r * lerpFinal.r +\n                 weights.g * lerpFinal.g +\n                 weights.b * lerpFinal.b +\n                 weights.a * lerpFinal.a;\n    return fin;\n    \n}\n\nfloat octave(vec3 coord, float octs, float div)\n{\n    \n    float col = 0.0;\n    float it = 1.0;\n    float cnt = 1.0;\n    for(float i = 1.0; i <= octs; i++)\n    {\n        col = col + interpolate((it * coord / (div)));// / it;\n        it = it * 1.8;\n        cnt = cnt + 1.0;// / it;\n       \n    }\n    return col / cnt;\n}\n\nvec3 rayCast(vec3 position, vec3 vector, float stp, float offset)\n{\n    float i = 0.0;\n    float vol = 0.0;\n    vec3 rayPos = position;\n    rayPos = rayPos + vector * offset;\n    float occ = 1.0;\n    \n    for(i = 0.0; i <= stp; i++)\n    {\n        \n        //vol = vol + octave(abs(rayPos), 1.0, 1000.0);\n        float val = pow(octave(abs(rayPos), octaves, 10.0), 2.0);\n        if (val <= 0.5) {occ = occ + occlusion / stp;} //light occlusion\n        vol = vol + val / occ;\n        rayPos = rayPos + stepSize * vector;\n        //if (val <= 0.01) {return vec3(vol);}\n        \n    }\n    return vec3(vol);\n\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n   vec2 uv = fragCoord/iResolution.xy;\n   float offset = texture(iChannel1, fragCoord / 1024.0).b; //Blue noise to distort ray Position\n   vec3 vector = texture(iChannel0, uv).rgb; //Grabs camera vectors from buffer\n   vec3 pos = vec3(300.0 * sin(0.1 * iTime)); //Change position over time\n   \n   vec3 col = rayCast(pos, vector, steps, 2.0 * offset);\n   fragColor = vec4(col, 1.0);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Camera vectors\nconst float FOV = 90.0 * 0.0174533;\n\nvoid mainImage( out vec4 viewVector, in vec2 fragCoord )\n{\n    vec2 rayD = FOV * ((fragCoord) / iResolution.x - 0.5);\n    vec3 rayV = vec3(cos(rayD.x), sin(rayD.x), sin(rayD.y));\n    viewVector = vec4(rayV.x, rayV.y , rayV.z, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}