{"ver":"0.1","info":{"id":"DsSBRy","date":"1689818272","viewed":49,"name":"Lava lakes","username":"jKubitschek","description":"fbm terrain with lava lakes. the lava is based on the lava texture in minecraft. This runs pretty slowly on my machine, any tips for optimization would be appreciated. ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["terrain","fbm","lava"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926583\n\nfloat rand(vec2 st) { // bookofshaders\n    return fract(sin(dot(st, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nfloat rand(float f) {\n    return fract(sin(f * 21.9173291)) * 2871.2618327;\n}\n\nvec2 rand2(vec2 st){ // bookofshaders\n    st = vec2( dot(st,vec2(617.1,311.7)),\n               dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\nvec3 rand3( ivec3 p )     // this hash is not production ready, please\n{                        // replace this by something better\n\t\t\t // stole from iq\n\tivec3 n = ivec3( p.x*127 + p.y*311 + p.z*74,\n                     p.x*269 + p.y*183 + p.z*246,\n                     p.x*113 + p.y*271 + p.z*124);\n\n\t// 1D hash by Hugo Elias\n\tn = (n << 13) ^ n;\n    n = n * (n * n * 15731 + 789221) + 1376312589;\n    return -1.0+2.0*vec3( n & ivec3(0x0fffffff))/float(0x0fffffff);\n}\n\nfloat gnoise(vec2 st) { // perlin, taken from bookofshaders\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 spl = f*f*f*(f*(f*6.0 - 15.0) + 10.0); // quintic interp\n\n    return mix( mix( dot( rand2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                 dot( rand2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), spl.x),\n            mix( dot( rand2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                 dot( rand2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), spl.x), spl.y);\n}\n\nfloat gnoise3(vec3 st) { // perlin, iq, https://iquilezles.org/articles/gradientnoise/\n    ivec3 i = ivec3(floor(st));\n    vec3 f = fract(st);\n\n    //quintic\n    #if 1\n    vec3 spl = f*f*f*(f*(f*6.0 - 15.0) + 10.0);\n    #else\n    vec3 spl = f*f*(3.0 - 2.0*f);\n    #endif\n\n    vec3 ga = rand3( i + ivec3(0.0,0.0,0.0) );\n    vec3 gb = rand3( i + ivec3(1.0,0.0,0.0) );\n    vec3 gc = rand3( i + ivec3(0.0,1.0,0.0) );\n    vec3 gd = rand3( i + ivec3(1.0,1.0,0.0) );\n    vec3 ge = rand3( i + ivec3(0.0,0.0,1.0) );\n    vec3 gf = rand3( i + ivec3(1.0,0.0,1.0) );\n    vec3 gg = rand3( i + ivec3(0.0,1.0,1.0) );\n    vec3 gh = rand3( i + ivec3(1.0,1.0,1.0) );\n\n    float va = dot( ga, f - vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, f - vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, f - vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, f - vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, f - vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, f - vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, f - vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, f - vec3(1.0,1.0,1.0) );\n\n    return va +\n\t   spl.x*(vb - va) +\n\t   spl.y*(vc - va) +\n\t   spl.z*(ve - va) +\n\t   spl.x*spl.y*(va - vb - vc + vd) +\n\t   spl.y*spl.z*(va - vc - ve + vg) +\n\t   spl.z*spl.x*(va - vb - ve + vf) +\n\t   spl.x*spl.y*spl.z*(-va + vb + vc - vd + ve - vf - vg + vh);\n}\n\n// Grounds:\n// -0.2 : 1.5\n// the fbm : 2.5\n\nvec2 opU( vec2 a, vec2 b ) {\n    return ( a.x < b.x ) ? a : b; // x is dist\n}\n\n#define NUM_OCTAVES_2 9\n#define NUM_OCTAVES_LQ_2 3\n\nfloat fbmq(vec2 st) {\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n\n    for (int i = 0; i < NUM_OCTAVES_LQ_2; ++i) {\n\tfloat ang = rand(float(i) + 32.21896);\n\tfloat co = cos(ang);\n\tfloat si = sin(ang);\n\tmat2 rot = mat2( co, -si,\n\t\t\t si, co );\n\tt += a*gnoise(f*st*rot);\n\tf *= 2.0;\n\ta *= 0.5;\n    }\n    return t;\n}\n\nfloat fbm(vec2 st) { // taken from iq\n    //float G = exp2(-H);\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n\n    for (int i = 0; i < NUM_OCTAVES_2; ++i) {\n\tfloat ang = rand(float(i) + 32.21896);\n\tfloat co = cos(ang);\n\tfloat si = sin(ang);\n\tmat2 rot = mat2( co, -si,\n\t\t\t si, co);\n\tt += a*gnoise(f*st*rot);\n\tf *= 2.0;\n\t//a *= G;\n\ta *= 0.5;\n    }\n    return t;\n}\n\n#define NUM_OCTAVES_3 2\nfloat fbm3(vec3 st, float H) {\n    float G = exp2(-H);\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n\n    for (int i = 0; i < NUM_OCTAVES_3; ++i) {\n\tt += a*gnoise3(f*st);\n\tf *= 2.0;\n\ta *= 0.5;\n    }\n    return t;\n}\n\nvec2 fbmd(vec3 p) {\n    return vec2( p.y - 1.4*fbm(p.xz*0.4 + vec2(0.1*iTime)), 2.5);\n}\n\nvec2 fbmd_q(vec3 p) {\n    return vec2( p.y - 1.4*fbmq(p.xz*0.4 + vec2(0.1*iTime)), 2.5);\n}\n\nvec2 map(vec3 p) {\n    vec2 res = vec2( 1e10, 0.0 ); // second component is the object ID, 0 means no object\n    vec2 gr =  vec2( p.y + 0.2, 1.5 );\n    vec2 tr = fbmd(p);\n\n    //res = opU(res, gr);\n    res = opU(gr, tr);\n    return res;\n}\n\nfloat findIsect(vec3 ro, vec3 look, float _near, float _far) {\n    float near = _near;\n    float far = _far;\n    float mid = (_near + _far)*0.5;\n\n    for (int i = 0; i < 4; ++i) {\n\tfloat f = fbmd(ro + look*mid).x;\n\tif (mid < f) {\n\t    far = mid;\n\t    mid = (near + far)*0.5;\n\t} else {\n\t    near = mid;\n\t    mid = (near + far)*0.5;\n\t}\n    }\n    return mid;\n}\n\nfloat shMarchFbm(vec3 ro, vec3 sDir) { // don't calculate the intersect with the lava when shmarching, as it is irrelevant\n    float k = 10.0; // soft shadow coefficient\n\n    float r = 1.0;\n    float t = 0.01;\n    for (int throw = 0; throw < 50; ++throw) {\n\n        if (t > 2.0) break;\n\n\tvec3 pos = ro + sDir*t;\n\n\tfloat h = fbmd_q(pos).x;\n    if (h < 0.3) h = fbmd(pos).x;\n\n\tif (h < 0.001) return 0.0;\n\tr = min(r, k * h/t);\n\n\tt += max( 0.05, h );\n    }\n    return r;\n}\n\nfloat shMarch(vec3 ro, vec3 sDir) {\n    float k = 10.0; // soft shadow coefficient\n\n    float r = 1.0;\n    float t = 0.01;\n    for (int throw = 0; throw < 20; ++throw) {\n\n        if (t > 2.0) break;\n\n\tvec3 pos = ro + sDir*t;\n\n\tfloat h = map(pos).x;\n\n\tif (h < 0.001) return 0.0;\n\tr = min(r, k * h/t);\n\n\tt += max( 0.05, h*0.7 );\n    }\n    return r;\n}\n\nvec3 normal(vec3 p) {\n    vec2 e = vec2(0.01, 0.0);\n    return normalize(vec3(map(p + e.xyy).x - map(p - e.xyy).x,\n                          map(p + e.yxy).x - map(p - e.yxy).x,\n                          map(p + e.yyx).x - map(p - e.yyx).x ));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 coord = 2.0*(fragCoord)/iResolution.x - vec2(1.0);\n    vec3 ro = vec3(0.0);\n    ro.y = 1.4*gnoise(ro.xz*0.4 + vec2(0.1*iTime)) + 2.5;\n    //ro.y += -map(ro).x + 1.5;\n    vec3 look = normalize(vec3(coord, -1.0));\n\n    vec3 skyblue = vec3(0.01, 0.48, 0.89);\n    vec3 brown = 0.85*vec3( 0.65, 0.47, 0.29 );\n    vec3 col = mix( vec3(1.0), skyblue, coord.y + 0.45 );\n\n    // Raymarch\n    vec2 t = vec2(0.0); // dist traveled\n    //if (look.y != 0.0) t = vec2( 2.0*1.4/look.y, 0.0 ); \n    for (int throw = 0; throw < 100; ++throw) { // number of marches\n\n        if (t.x > 30.0) { // gone too far, don't bother, give up search\n            break;\n        }\n\n        vec3 pos = ro + t.x*look;\n\n        vec2 h = fbmd(pos);\n\n        if (h.x < 0.001) {\n            t = vec2( findIsect(ro, look, t.x, t.x + h.x), h.y );\n            break;\n        }\n\n        t = vec2( t.x + 0.4 * h.x, h.y );\n\n        if (ro.y + t.x*look.y < -0.2) {\n            t.y = 1.5;\n            t.x = (-0.2 - ro.y)/look.y;\n            break;\n        }\n    }\n\n\n    vec3 sunDir = normalize(vec3( 1.25 , 0.65, -0.25 ));\n    vec3 pt = ro + t.x*look;\n    float sh = shMarchFbm(pt, sunDir);\n    vec3 blood = vec3( 0.8, 0.4, 0.1 ); // actually lava\n    if (t.x < 30.0) { // if we didn't give up\n        if ( t.y == 2.5 ) {\n            vec3 n = normal( pt );\n            col = brown; // fbm of ground\n\n            // Lighting\n            float amb = clamp( 0.5 + 0.5*n.y, 0.0, 1.0 );\n            float dif = clamp( dot( n, sunDir ), 0.0, 1.0 );\n            float b = clamp( dot( vec3(-sunDir.x, 0.0, -sunDir.z), n), 0.0, 1.0 ); // back face of cliffs\n\n            // mat\n            float flatC = smoothstep( 0.7, 0.8, n.y );\n            col = (1.0 - abs(n.y))*vec3(0.9) + abs(n.y)*vec3(0.1);\n            col = flatC*vec3(0.6, 0.2, 0.1) + (1.0 - flatC)*col;\n\n            // lighting\n            col *= min(1.0, 0.15 + sh) * dif;\n            col += b*vec3(0.5)*0.2;\n            float bmix = -min(0.0, -1.0 + 0.2 + pt.y);\n            col += 0.15*mix( vec3(0.0), vec3( 0.8, 0.3, 0.1), bmix*bmix )*min(1.0, 0.3 + sh);\n        } else if ( t.y == 1.5 ) {\n            col = mix( blood, vec3(1.0), fbm3(vec3(pt.xz*5.0 + vec2(iTime*1.3), iTime*0.2), 0.01) );\n            col *= min(1.0, 0.5 + sh);\n        }\n    }\n    float fogWt = exp( -0.12 * t.x ); // tint for distant parts of image\n    col = fogWt*col + (1.0 - fogWt)*vec3(0.45);\n\n    fragColor = vec4( col, 1.0 );\n}\n","name":"Image","description":"","type":"image"}]}