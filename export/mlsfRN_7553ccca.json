{"ver":"0.1","info":{"id":"mlsfRN","date":"1692712890","viewed":24,"name":"CARRO ANDANDO","username":"Yuri_Benassi","description":"CARRO ANDANDO EM UMA PONTE DURANTE UM DIA COMPLETO E COM A CIDADE DE FUNDO","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["andandopeloambiente"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.98,78.23))) * 43758.53);\n}\n\nvec4 PalletToRGB(vec3 col01, vec3 col02, vec3 col03, vec3 col04, vec3 colorToConvert)\n{ \t\n    vec3 toReturn = col04;\n    toReturn = mix(toReturn, col01, colorToConvert.x);\n    toReturn = mix(toReturn, col02, colorToConvert.y);\n    toReturn = mix(toReturn, col03, colorToConvert.z);\n    \n    return vec4(toReturn, 1.0);\n}\n\nfloat impulse( in float k, in float x )\n{\n    float h = k*x;\n    return h*exp(1.0-abs(h));\n}\n\nvoid DrawACircle(inout vec3 color, in vec3 circleColor, in vec2 pos, in vec2 coord, in float radius)\n{\n    float distanceToCenter = distance(coord, pos);\n    \n    color = mix(circleColor, color, step(radius, distanceToCenter));    \n}\n\nvoid DrawRectangle(inout vec3 color, in vec3 recantgleColor, in vec2 pos, in vec2 coord, in vec2 dimensions)\n{\n    vec2 distanceVector = abs(coord - pos);\n    float shilloute = step(0.5, (step(dimensions.x, distanceVector.x) +step(dimensions.y, distanceVector.y))/2.0);\n    color = mix(recantgleColor, color, shilloute);\n}\n\nvoid DrawClouds( inout vec3 color, in vec3 cloudcolor, in vec2 pos, in vec2 coord,  in vec2 dimensions, in float cloudsHeight)\n{    \n    float randomSeed= rand(vec2 (pos.y));\n    \n    float waveyHeight = (sin((coord.x - dimensions.x) * 20.0 ) * pow(coord.x, randomSeed*2.0)/cloudsHeight) + pos.y;\n    vec2 distanceVector = abs(coord - pos);\n    float drawingBox = step(0.5, (step(dimensions.x, distance( coord, vec2(pos.x, pos.y - dimensions.x*0.7))) +\n                                  step(dimensions.y, distanceVector.y))/2.0);\n    \n    float finalLerpFactor =  (1.0 - drawingBox) *  ( 1.0 - step(waveyHeight , coord.y));\n    \n    color = mix(cloudcolor, color, 1.0- finalLerpFactor);  \n}\n\nvoid DrawAPole( inout vec3 color, in vec3 poleColor, in vec2 pos, in vec2 coord)\n{  \n    DrawRectangle(color, poleColor, vec2(0.0, 0.18), coord ,vec2(6.5, 0.012));\n    \n    for(int i = 0; i<20; i++)\n    {\n      DrawRectangle(color, poleColor, vec2(pos.x - 2.0 + float(i)*0.3, pos.y), coord ,vec2(0.026, 0.14));\n    }    \n}\n\nvoid DrawTwoSidedTriangle(inout vec3 Color, in vec3 toDrawColor, in vec2 pos, in vec2 coord, in float height, in float width)\n{\n \tfloat functionIn = coord.x - pos.x;\n    float heightValue = height * (1.0 - abs(width * functionIn));\n    \n    float shilloute = 1.0 - step((heightValue + pos.y), coord.y);\n    shilloute *=  step(pos.y, coord.y);\n    \n    Color = mix(toDrawColor, Color, 1.0 - shilloute);    \n}\n\nvoid DrawACar( inout vec3 color, in vec2 coord)\n{\n    vec3 backColorIn = color;\n    float yOffset = abs( 2.0 * fract(iTime) - 1.0) * 0.010;\n    DrawRectangle(color, vec3(0.14, 0.03, 0.0), vec2(0.6, 0.2+ yOffset), coord ,vec2(0.3, 0.15));\n    DrawRectangle(color, backColorIn, vec2(0.80, 0.28 + yOffset), coord, vec2(0.11, 0.07));\n     DrawRectangle(color, backColorIn, vec2(0.35, 0.31 + yOffset), coord, vec2(0.1, 0.07));\n    \n    \n    DrawTwoSidedTriangle(color, vec3(0.14, 0.03, 0.0), vec2(0.68, 0.21 + yOffset), coord, 0.142, 10.00001);\n    \n    \n    DrawACircle(color, vec3(0.14, 0.03, 0.0), vec2(0.42, 0.06 + yOffset * 1.4), coord, 0.08);\n     DrawACircle(color, vec3(0.14, 0.03, 0.0), vec2(0.78, 0.05 + yOffset * 1.4), coord, 0.08);\n}\n\nvoid DrawMountain(in vec2 coord, inout vec3 color, float buttonHeight, vec3 mountainColor, float manualOffset)\n{\t\n    float randomSeed= rand(vec2 (buttonHeight));\n    float offset =  sin(coord.x *2.0 +manualOffset + (pow(randomSeed, randomSeed)) )/\n        (14.0 - pow(randomSeed, randomSeed)/10.0) + abs(cos(sin( (fract(cos(coord.x  + pow(randomSeed, randomSeed) ) *2.0 -1.0 )* \n                  (fract(cos(coord.x * randomSeed+ 0.5) * randomSeed * 20.0))*2.0 -1.0))))/ 4.0;\n    \n    float randomTreeHeight = rand(vec2( floor(coord.x *25.0)));\n    float trees = (pow(abs((2.0* fract(coord.x*0.9 * randomTreeHeight * randomSeed))-1.0),2.0))/\n        (20.0- 10.0 * randomTreeHeight  *pow(randomSeed,2.0)) ;\n    \n    float sillhoute = clamp(step(buttonHeight + offset+ trees, coord.y) + step(buttonHeight-0.1, coord.y) -1.0 , 0.0, 1.0);\n    \n    \n    color = mix(mountainColor, color, sillhoute);    \n}\n\nvoid DrawMountainGradient(in vec2 coord, inout vec3 color, float buttonHeight, vec3 mountainColor, vec3 color02, float manualOffset)\n{ \t\n    float randomSeed= rand(vec2 (buttonHeight));\n    float offset =  sin(coord.x *2.0 +manualOffset + (pow(randomSeed, randomSeed * 4.0)) )/\n        (14.0 - pow(randomSeed, randomSeed)/10.0) + abs(cos(sin( (fract(cos(coord.x  + pow(randomSeed, randomSeed) ) *2.0 -1.0 )* \n                  (fract(cos(coord.x * randomSeed+ 0.5) * randomSeed * 20.0))*2.0 -1.0))))/ 4.0;\n    \n    float randomTreeHeight = rand(vec2( floor(coord.x *25.0)));\n    float trees = (pow(abs((2.0* fract(coord.x*0.9 * randomTreeHeight * randomSeed))-1.0),2.0))/\n        (20.0- 10.0 * randomTreeHeight  *pow(randomSeed,2.0)) ;\n    \n    float sillhoute = clamp(step(buttonHeight + offset+ trees, coord.y) + step(buttonHeight-0.1, coord.y) -1.0 , 0.0, 1.0);\n    \n    float gradientFactor =  clamp( coord.y - buttonHeight/ 120.0, 0.0, 1.0);\n    vec3 colorToUse = mix(mountainColor, color02, 1.0 - gradientFactor);\n    \n    color = mix(colorToUse, color, sillhoute);    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;    \n    vec3 backGround = vec3( abs (2.0 * fract(iTime*0.05) - 2.0), 0.101, 0.270);\n    vec3 color01 = vec3(0.360, 0.2, abs (2.0 * fract(iTime*0.05) - 1.0));\n    vec3 color02 = vec3(abs(cos(iTime/10.0) + cos(iTime*0.8 +2.215)), 0.827, abs( cos(iTime)+ cos(iTime*0.76 +52.21)));\n    vec3 color03 = vec3(0.8, 0.9, 0.8);\n    vec3 colorToReturn = vec3(1.0, 1.0, 0.0);\n    \n    float backGroundGradientBlend = impulse( 2.5, uv.y );\n    \n    colorToReturn = backGround + 1.0 - backGroundGradientBlend; \n    \n    DrawACircle(colorToReturn, vec3(2.8, 2.5, 0.9), vec2(0.3, 0.75), uv, 0.2);\n    \n    float cloudMovementSpeed = 0.05;\n    \n    DrawClouds( colorToReturn, vec3(0.3, 0.6, 0.7), vec2(0.5, 0.94),\n               vec2(uv.x - 1.5 + 2.4* fract((iTime + 40.0) *cloudMovementSpeed), uv.y),\n               vec2(0.4,0.13), 10.0);\n    \n    DrawClouds( colorToReturn, vec3(0.2, 0.4, 0.6), vec2(1.0, 0.7),\n               vec2(uv.x - 1.0 + 2.4* fract((iTime +18.0 )*cloudMovementSpeed* 0.5), uv.y),\n                vec2(0.7,0.13), 30.0);\n    \n    float mountainMovementSpeed = 0.3;\n    \n    DrawMountainGradient(vec2(uv.x + iTime * mountainMovementSpeed * 0.5, uv.y),\n                         colorToReturn, 0.2, vec3(0.9, 0.5, 0.5), vec3(0.9, 0.5, 0.4), 0.2);\n                         \n    float poleMovementSpeed= 1.6;\n    \n    DrawAPole(colorToReturn, vec3(0.03, 0.3, 0.0), vec2(0.2, 0.07),\n              vec2(uv.x + 2.0 *fract(iTime) -1.0, uv.y) );\n    \n    DrawACar(colorToReturn, uv);\n    \n\tfragColor = PalletToRGB(color01, color02, color03, backGround, colorToReturn);\n}","name":"Image","description":"","type":"image"}]}