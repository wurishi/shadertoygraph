{"ver":"0.1","info":{"id":"lt3Gz8","date":"1467864712","viewed":469,"name":"Flower Hive","username":"zackpudil","description":"A kaliset fractal with no mirroring offsets.","likes":26,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fractal","distancefields"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// basic 2d rotation.\nvoid rotate(inout vec2 p, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\n\tp = mat2(c, s, -s, c)*p;\n}\n\nvec4 orb;\nfloat de(vec3 p) {\n\tvec4 q = vec4(p, 1);\n\tvec4 c = vec4(p, 0);\n\n\trotate(q.xy, iTime*step(-0.5, -length(p)));\n\trotate(q.xz, 2.*iTime*step(-0.5, -length(p)));\n\torb = vec4(10000.0);\n\n\tfor(int i = 0; i < 10; i++) { //kaliset fractal with no mirroring offset\n\t\tq.xyz = abs(q.xyz);\n\t\tfloat r = dot(q.xyz, q.xyz);\n\t\tq /= clamp(r, 0.0, 1.7);\n\t\t\n\t\tq = 2.0*q - vec4(2, 1, 2, 0); // julia offset.\n\t\t\n\t\torb = min(orb, vec4(abs(q.xyz), sqrt(r)));\n\t}\n\t\n\treturn (length(q.xy)/q.w - 0.003); // cylinder primative instead of a sphere primative.\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // pixel coords\n\tvec2 p = -1.0 + 2.0*fragCoord.xy/iResolution.xy;\n\tp.x *= iResolution.x/iResolution.y;\n\t\n\tvec3 col = vec3(0);\n\t\n    // ray origin and ray direction.\n\tvec3 ro = 1.3*vec3(cos(iTime), (1.0/1.3)*sin(iTime*0.3), -sin(iTime));\n\tvec3 ww = normalize(vec3(0, 0.5*sin(iTime*0.3), 0) - ro);\n\tvec3 uu = normalize(cross(vec3(0, 1, 0), ww));\n\tvec3 vv = normalize(cross(ww, uu));\n\tvec3 rd = normalize(p.x*uu + p.y*vv + 1.97*ww);\n\t\n    // ray marching.\n\tfloat t = 0.0;\n\tfor(int i = 0; i < 200; i++) {\n\t\tfloat d = de(ro + rd*t);\n\t\tif(abs(d) < 0.001*t || t >= 1000.0) break;\n\t\tt += d*0.75; // fudge factor = 1/4.\n\t}\n\t\n\tif(t < 1000.0) {\n        // position and normal.\n\t\tvec3 pos = ro + rd*t;\n\t\tvec2 eps = vec2(0.001, 0.0);\n\t\tvec3 nor = normalize(vec3(\n\t\t\tde(pos + eps.xyy) - de(pos - eps.xyy),\n\t\t\tde(pos + eps.yxy) - de(pos - eps.yxy),\n\t\t\tde(pos + eps.yyx) - de(pos - eps.yyx)\n\t\t));\n\t\t\n        // ambient occlusion.\n\t\tfloat o = 0.0, w = 1.0, s = 0.003;\n\t\tfor(int i = 0; i < 15; i++) {\n\t\t\tfloat d = de(pos + nor*s);\n\t\t\to += (s - d)*w;\n\t\t\ts += s/(float(i) + 1.0);\n\t\t}\n\t\t\n        // color by orbit trap.\n\t\tvec3 oc = vec3(0.3, 0.3, 1.0)*orb.x\n\t\t\t+ vec3(0.1, 0.5, 0.6)*orb.y\n\t\t\t+ vec3(0.3, 0.3, 1.0)*orb.z\n\t\t\t+ vec3(0.9, 0.3, 0.5)*orb.w;\n\t\t\n        // mix color with base color.\n\t\tcol = mix(vec3(1), 3.0*oc, 0.4);\n\t\t\n        // apply ambient occlusion.\n\t\tcol *= vec3(1.0 - clamp(o, 0.0, 1.0));\n\t}\n\t\n    // mix with black fog...good fake for attenuation.\n\tcol = mix(col, vec3(0), 1.0 - exp(-0.5*t));\n\t\n\tfragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}