{"ver":"0.1","info":{"id":"tlSSDh","date":"1565724722","viewed":88,"name":"Julia 2D zoom","username":"envy","description":"Mouse left click to zoom.\nUse #defines to control look","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["2d","fractal","julia","zoom","iteration"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Zoom into a 2-D fractal indefinitely to see self-similarity\n// Rabbit ears <-> Cracks\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tfloat col = texture(iChannel0, uv).r;\n    \n    // Output to screen\n    vec2 v = vec2(sin(col*iTime), cos(col*iTime));\n    \n    fragColor = vec4(v.xyxy);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Check out the paper for more details:\n// http://www.cs.cmu.edu/~kmcrane/Projects/QuaternionJulia/paper.pdf\n\n// Whether the fractal moves and blends its shape\n#define BLEND true\n// Highest zoom level (make this number larger to avoid precision artifacts at highest zoom)\n#define EPS 1e-12\n// Max iterations (must be float)\n#define MAX_ITER 128.0\n// How fast to zoom in (0, 1): decrease this to zoom in faster\n#define ZOOM_IN_SPEED 0.99\n// How fast to zoom out (> 1): increase this to zoom out faster\n#define ZOOM_OUT_SPEED 1.2\n#define PI 3.14159\n#define TAU (2.0*PI)\n\n\n// Complex number lib\nstruct Complex\n{\n    // a + ib\n \tfloat a; // real part\n    float b; // img part\n};\n\nComplex comp_sq(Complex z)\n{\n    Complex ret;\n    ret.a = (z.a * z.a) - (z.b * z.b);\n    ret.b = 2.0 * z.a * z.b;\n    return ret;\n}\n\nComplex comp_add(Complex z1, Complex z2)\n{\n    Complex ret;\n    ret.a = z1.a + z2.a;\n    ret.b = z1.b + z2.b;\n    return ret;\n}\n\nfloat comp_mag(Complex z)\n{\n \treturn sqrt((z.a * z.a) + (z.b * z.b));\n}\n\n///////////////////\n\nfloat iterate(Complex z, Complex c, float iter)\n{\n    Complex z_n = z;\n    float i = 0.0;\n    // Iterate by z_n+1 = z_n^2 + c\n    for (; i < iter; ++i)\n    {\n        if(comp_mag(z_n) > 2.0)\n        {\n            return i;\n        }\n        z_n = comp_add(comp_sq(z_n), c);\n    }\n \treturn 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Scale UV for zoom\n    float uv_scale = texture(iChannel0, uv).g;\n    if(uv_scale == 0.0) uv_scale = 1.0;\n    if(iMouse.z > 0.0)\n    {\n        if(uv_scale > EPS) uv_scale *= ZOOM_IN_SPEED;\n        else uv_scale = EPS;\n    }\n    else\n    {\n        uv_scale *= ZOOM_OUT_SPEED;\n        if(uv_scale > 1.0) uv_scale = 1.0;\n\t}\n\n    vec2 new_uv = uv * uv_scale;\n    vec2 rect_min, rect_max;\n    vec2 curr_mouse, last_mouse;\n    if(iMouse.z > 0.0)\n    {\n        curr_mouse = iMouse.xy;\n    }\n    else\n    {\n        vec2 last_mouse = texture(iChannel0, uv).ba;\n        if(last_mouse.x == 0.0 && last_mouse.y == 0.0) last_mouse = iResolution.xy * 0.5;\n        curr_mouse=last_mouse;\n    }\n    rect_min = curr_mouse - (iResolution.xy * uv_scale)*0.5;\n    rect_max = curr_mouse + (iResolution.xy * uv_scale)*0.5;\n    new_uv = mix(rect_min/iResolution.xy, rect_max/iResolution.xy, uv);\n\n    // Complex coord [-2, 2]\n    vec2 z = (new_uv * 4.0) - 2.0;\n    Complex z0;\n    z0.a = z.x; z0.b = z.y;\n    \n    // Julia set constant, lerping between:\n    // 1: Rabbit ears (c = -0.12 + i0.75)\n    // 2: Cracks (c = c = 0 + i0.8)\n    // Other shapes modulated by c: http://paulbourke.net/fractals/juliaset/\n    Complex c, c1, c2;\n    c1.a = -0.12; c1.b = 0.75;\n    c2.a = 0.0; c2.b = 0.8;\n    c.a = BLEND ? mix(c1.a, c2.a, sin(mod(iTime, TAU))) : c1.a;\n    c.b = BLEND ? mix(c1.b, c2.b, sin(mod(iTime, TAU))) : c1.b;\n    \n    float num_iters = iterate(z0, c, MAX_ITER);\n\n    // Time varying pixel color\n    float col = num_iters/MAX_ITER;\n    \n    // Gamma correct to add shine\n    col = pow(col, 0.75);\n\t    \n    // Output to screen\n    fragColor = vec4(col, uv_scale, curr_mouse);\n}","name":"Buffer A","description":"","type":"buffer"}]}