{"ver":"0.1","info":{"id":"3l23Wh","date":"1559339558","viewed":172,"name":"[0002] glass sphere","username":"Meow8p","description":"Perfectly transparent glass sphere","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","refraction","sphere","glass","refract"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS (128)\n#define SURFACE_DIST (0.001)\n   \nint mat=0;\n   \nvec2 rotate(vec2 p, float a)\n{\n   float s=sin(a);\n   float c=cos(a);\n   mat2 r=mat2(c, -s, s, c);\n   return p*r;\n}\n\nfloat sphereDist(vec3 p, vec3 origin, float radius)\n{\n   return length(p-origin)-radius;\n}\n\nfloat planeDist(vec3 p, float position)\n{\n   return p.y-position;\n}\n   \nfloat sceneDistance(vec3 p)\n{\n   float s1=sphereDist(p, vec3(0.0, 0.5, 0.0), 0.2);\n   if(s1<SURFACE_DIST)\n   {\n      mat=1;\n   }\n   float p1=planeDist(p, 0.0);\n   if(p1<SURFACE_DIST)\n   {\n      mat=2;\n   }\n   p.xz=rotate(p.xz, iTime);\n   float s2=sphereDist(p, vec3(1.0, 0.5, 0.0), 0.2);\n   if(s2<SURFACE_DIST)\n   {\n      mat=3;\n   }\n   return min(p1, min(s1, s2));\n}\n\nvec3 normalAt(vec3 p)\n{\n   float dist=sceneDistance(p);\n   vec2 epsilon=vec2(0.001,0.0);\n   return normalize(vec3(dist-sceneDistance(p-epsilon.xyy), \n                         dist-sceneDistance(p-epsilon.yxy),\n                         dist-sceneDistance(p-epsilon.yyx)));\n}\n   \nfloat lightAt(vec3 p)\n{\n   vec3 lightPosition=vec3(0.0,2.0,0.0);\n   vec3 n=normalAt(p);\n   vec3 lightDirection=normalize(lightPosition-p);\n   \n   float diffuse=clamp(dot(n, lightDirection), 0.0, 1.0);\n   return diffuse;\n}\n\nvec3 pixelColor(vec2 uv)\n{\n   vec3 direction=normalize(vec3(uv,1.0));\n   vec3 color=vec3(0.0,0.0,0.0);\n   float distance=0.0;\n   vec3 camera=vec3(0.0,0.5,-1.5);\n   float sceneDist=0.0;\n   vec3 p;\n   int refractCount=0;\n   vec3 n;\n   \n   for(int i=0;i<MAX_STEPS;i++)\n   {\n      p=camera+distance*direction;\n      sceneDist=sceneDistance(p);\n      \n      if(sceneDist<=SURFACE_DIST)\n      {\n         if(mat==1)\n         {\n            n=normalAt(p);\n            camera=p+SURFACE_DIST*direction*10.0;\n            direction=normalize(refract(direction,n,1.0/1.5));\n            \n            distance=0.0;\n            for(int j=0;j<MAX_STEPS;j++)\n            {\n               p=camera+distance*direction;\n               sceneDist=sceneDistance(p);\n               distance+=max(abs(sceneDist),SURFACE_DIST); \n               if(sceneDist>SURFACE_DIST)\n               {\n                  break;\n               }\n            }\n            \n            camera=p+SURFACE_DIST*direction*10.0;\n            distance=0.0;\n         }\n         else\n         {\n            break;\n         }\n      }\n      \n      distance+=sceneDist;\n   }\n   \n   if(sceneDist<=SURFACE_DIST\n      && mat!=1)\n   {\n      color=vec3(lightAt(p));\n   }\n   \n   if(mat==2)\n   {\n      color*=vec3(0.0,1.0,0.0);\n   }\n   else if(mat==3)\n   {\n      color*=vec3(0.0,0.0,1.0);\n   }\n   \n   return color;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.x;\n\n    // Output to screen\n    fragColor = vec4(pixelColor(uv),1.0);\n    \n    \n    \n}","name":"Image","description":"","type":"image"}]}