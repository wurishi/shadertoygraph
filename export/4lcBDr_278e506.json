{"ver":"0.1","info":{"id":"4lcBDr","date":"1541363267","viewed":104,"name":"Pieuvre Surface Implicite","username":"fpochol","description":"Surface Implicite","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["surfaceimplicite"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Blobs\n// Eric Galin\n\nconst int Steps = 1000;\nconst float Epsilon = 0.01; // Marching epsilon\nconst float T = 0.5;\nconst float pi = 3.14159265359;\n\nconst float rA = 16.0; // Maximum ray marching or sphere tracing distance from origin\nconst float rB = 23.0; // Minimum\n\n// Transforms\nvec3 rotateX(vec3 p, float a)\n{\n\tfloat sa = sin(a);\n\tfloat ca = cos(a);\n\treturn vec3(p.x, ca * p.y - sa * p.z, sa * p.y + ca * p.z);\n}\n\nvec3 rotateY(vec3 p, float a)\n{\n\tfloat sa = sin(a);\n\tfloat ca = cos(a);\n\treturn vec3(ca * p.x + sa * p.z, p.y, -sa * p.x + ca * p.z);\n}\n\nvec3 rotateZ(vec3 p, float a)\n{\n\tfloat sa = sin(a);\n\tfloat ca = cos(a);\n\treturn vec3(ca * p.x + sa * p.y, -sa * p.x + ca * p.y, p.z);\n}\n\n// Smooth falloff function\n// r : small radius\n// R : Large radius\nfloat falloff(float r, float R)\n{\n\tfloat x = clamp(r / R, 0.0, 1.0);\n\tfloat y = (1.0 - x * x);\n\treturn y * y * y;\n}\n\n// Primitive functions\n\n// Point skeleton\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// R : large radius\nfloat point(vec3 p, vec3 c, float e, float R)\n{\n\treturn e * falloff(length(p - c), R);\n}\n\n// Line skeleton\n// p : point\n// a et b : points in the line\n// e : energy associated to skeleton\n// R : large radius\nfloat droite(vec3 p, vec3 a, vec3 b, float e, float R)\n{\n\tvec3 ba = b - a;\n\tvec3 c = ba * (dot(a - p, ba) / dot(ba, ba));\n\tvec3 d = a - p - c;\n\treturn e * falloff(sqrt(dot(d, d)), R);\n}\n\n// Segment skeleton\n// p : point\n// a et b : bornes of segment\n// e : energy associated to skeleton\n// R : large radius\nfloat segment(vec3 p, vec3 a, vec3 b, float e, float R)\n{\n\tvec3 ba = b - a;\n\tvec3 pa = a - p;\n\tvec3 k;\n\n\tfloat c = dot(ba, pa);\n\n\tif (c > 0.0) // Closest point is a\n\t\tk = pa;\n\telse\n\t{\n\t\tvec3 bp = p - b;\n\n\t\t// Closest point is b\n\t\tif (dot(ba, bp) > 0.0)\n\t\t\tk = bp;\n\t\telse // Closest point is between a and b\n\t\t\tk = pa - ba * (c / dot(ba, ba));\n\t}\n\n\treturn e * falloff(dot(k, k), R);\n}\n\n// Cercle skeleton\n// p : point\n// c : center of cercle\n// n : normal of cercle\n// r : radius of cercle\n// e : energy associated to skeleton\n// R : large radius\nfloat cercle(vec3 p, vec3 c, vec3 n, float r, float e, float R)\n{\n\tfloat l = dot(p - c, n);\n\tfloat pc = sqrt(dot(p - c, p - c));\n\tfloat hc = sqrt(pc * pc - l * l) - r;\n\tfloat d = sqrt(hc * hc + l * l);\n\treturn e * falloff(d, R);\n}\n\n// Disque skeleton\n// p : point\n// c : center of disque\n// n : normal of disque\n// r : radius of disque\n// e : energy associated to skeleton\n// R : large radius\nfloat disque(vec3 p, vec3 c, vec3 n, float r, float e, float R)\n{\n\tfloat l = dot(p - c, n);\n\tfloat pc = length(p - c);\n\tfloat hc = sqrt(pc * pc - l * l) - r;\n\tif (hc < 0.0)\n\t\thc = 0.0;\n\tfloat d = sqrt(hc * hc + l * l);\n\treturn e * falloff(d, R);\n}\n\n// half-sphere skeleton\n// p : point\n// c : center of skeleton\n// n : normal\n// r : rayon\n// e : energy associated to skeleton\n// R : large radius\nfloat halfSphere(vec3 p, vec3 c, vec3 n, float r, float e, float R)\n{\n\tif (dot(n, p - c) <= 0.)\n\t\treturn disque(p, c, n, r, e, R);\n\treturn e * falloff(max(0., length(p - c) - r), R);\n}\n\nfloat courbe(vec3 pos, vec3 A, vec3 B, vec3 C, float e, float min, float max)\n{    \n    vec3 a = B - A;\n    vec3 b = A - 2.0*B + C;\n    vec3 c = A - pos;\n\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(c,b)) / 3.0;\n    float kz = kk * dot(c,a);      \n\n    float p = ky - kx*kx;\n    float p3 = pow(p,3.);\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    float t;\n\n    if(h >= 0.0) \n    {\n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        t = uv.x + uv.y - kx;\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        t = -abs(cos(v)) - abs(sin(v))*1.732050808;\n    }\n    t = clamp( t, 0.0, 1.0 );\n\n    vec3 qos = c + (a * 2.0 + b*t)*t;\n\n    float res = sqrt( dot(qos,qos) );\n    \n    t = max - t*(max-min);\n    \n\treturn e * falloff(res, t);\n}\n\nfloat cube(vec3 p, vec3 pmin, vec3 pmax, float e, float R)\n{\n\tvec3 d3;\n\td3.x = min(min(0., p.x - pmin.x), min(0., pmax.x - p.x));\n\td3.y = min(min(0., p.y - pmin.y), min(0., pmax.y - p.y));\n\td3.z = min(min(0., p.z - pmin.z), min(0., pmax.z - p.z));\n\n\tfloat d = dot(d3, d3);\n\treturn e * falloff(d, R);\n}\n\nfloat cone(vec3 p, vec3 c, vec3 n, float r, float l, float e, float R)\n{\n\n\tvec3 a = c + n * l;\n\tvec3 t = normalize(cross(cross(p - c, n), n));\n\tvec3 b = c + t * r;\n\t/*\n    if(dot(p-c,n) < 0.)\n    {\n        float hc = dot(p-c,b-c)-r;\n        if(hc<0.0) hc = 0.0;\n        float d = sqrt(hc*hc + l*l);\n        return e*falloff(d,R);\n    }*/\n\treturn point(p, b, e, R);\n\n\tvec3 ba = b - a;\n\tvec3 pa = a - p;\n\n\tfloat BPb = dot(pa, ba);\n\tvec3 Pb = b + ba * BPb;\n\n\tfloat d = length(p - BPb);\n\tif (d < 0.)\n\t\td = 0.;\n\treturn e * falloff(d, R);\n\n\tvec3 k;\n\t/*\n    float d = dot(ba,pa );\n    \n    if ( d > 0.0 ) // Closest point is a\n        k = pa;\n    else {\n        vec3 bp = p - b;\n    \n        // Closest point is b\n        if ( dot(ba, bp) > 0.0 )\n            k = bp;\n        else // Closest point is between a and b\n            k = pa - ba *(d / dot(ba, ba));\n    }\n \n    return e*falloff(dot(k,k),R);*/\n}\n\n// Blending\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Blend(float a, float b)\n{\n\treturn a + b;\n}\n\nfloat erode(float a, float b)\n{\n    return a - b;\n}\n\n// Union\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Union(float a, float b)\n{\n\treturn max(a, b);\n}\n\nfloat Intersection(float a, float b)\n{\n    return min(a,b);\n}\n\n// Potential field of the object\n// p : point\nfloat object(vec3 p)\n{\n    float sinTime = sin(iTime)/4.;\n    float cosTime = cos(iTime*3.)/4.;\n    float sinTimeb = sin(iTime*1.5)/4.;\n\tp.z = -p.z; \n    // TÃªte\n    \t//Globe\n    vec3 t = rotateZ(p,-1.9- sinTime/2.);\n    t.y /= 1.8;\n    float globe = point(t, vec3(-1.5, 0.6, 0.), 1.0, 3.2);\n    \t// yeux\n    float yeux = Blend(point(p,vec3(-.3+ sinTime/2.,2.4,.75),1.,.4),point(p,vec3(-.3+ sinTime/2.,2.4,-0.75),1.,.4));\n    t = p;\n    t.z /= 1.8;\n    yeux = Blend(yeux,halfSphere(t,vec3(-.3+ sinTime/2.,2.4,0.3),vec3(0.,0.,-1.),0.4,1.,0.2));\n    yeux = Blend(yeux,halfSphere(t,vec3(-.3+ sinTime/2.,2.4,-0.3),vec3(0.,0.,1.),0.4,1.,0.2));\n\tfloat tete = Blend(globe,yeux);\n    \n    // Tentacules\n    t=p;\n    t.x /=1.2;\n    vec3 finBArriere = vec3(.3,-1.-sinTime,2.0);  \n    vec3 finBMilieu = vec3(-.8-sinTime,-1.,1.5);    \n    //base arriere et milieu\n    float tentacules = Blend(courbe(t,vec3(-0.1,0.7,0.8),vec3(-.2,-.6,1.0),finBArriere,1.,.6,1.),\n                      \t\t courbe(t,vec3(-.3,1.2,0.3),vec3(-.8,-.2,0.5),finBMilieu,1.,.6,1.));\n    finBArriere.z = -finBArriere.z;\n    finBMilieu.z = -finBMilieu.z;\n    tentacules = Blend(tentacules,\n                       courbe(t,vec3(-0.1,0.7,-.8),vec3(-.2,-.6,-1.),finBArriere,1.,.6,1.));\n    tentacules = Blend(tentacules,\n                       courbe(t,vec3(-.3,1.2,-.3),vec3(-.8,-.2,-.5),finBMilieu,1.,.6,1.));\n    t=p;\n    t.z/=1.2;\n    // avant\n    vec3 finBAvant = vec3(-1.8-sinTime,-.9+sinTime,.45);\n    tentacules = Blend(tentacules,\n                       courbe(t,vec3(-1.,1.,.2),vec3(-1.1,.2,.1),finBAvant,1.,.6,1.));\n    tentacules = Blend(tentacules,\n                       courbe(t,vec3(finBAvant.x-.3,finBAvant.y-.4,finBAvant.z+.15),vec3(-2.5,-2.,1.1),vec3(-2.3+sinTimeb,-1.6+sinTimeb,1.7+sinTimeb),1.,.2,.6));\n    finBAvant.z = -finBAvant.z;\n    tentacules = Blend(tentacules,\n                       courbe(t,vec3(-1.,1.,-.2),vec3(-1.1,.2,-.1),finBAvant,1.,.6,1.));\n    tentacules = Blend(tentacules,\n                       courbe(t,vec3(finBAvant.x-.3,finBAvant.y-.4,finBAvant.z-.15),vec3(-2.5,-2.,-1.1),vec3(-2.3+sinTimeb,-1.6+sinTimeb,-1.7-sinTimeb),1.,.2,.6));\n    t=p;\n    t.y /=.8;\n    // 2e part arriere \n    //.8,-1.3,2.\n    tentacules = Blend(tentacules,\n                       courbe(t,vec3(finBArriere.x+.5,finBArriere.y-.3,-finBArriere.z),vec3(1.2,-1.5-cosTime,2.9),vec3(1.8,-.8,2.5+cosTime*2.),1.,.2,.6));\n    tentacules = Blend(tentacules,\n                       courbe(t,vec3(finBArriere.x+.5,finBArriere.y-.3,finBArriere.z),vec3(1.2,-1.5-cosTime,-2.9),vec3(1.8,-.8,-2.5-cosTime*2.),1.,.2,.6));\n    \n    // 2e part milieu  \n    //-.9,-1.6,1.8\n    tentacules = Blend(tentacules,\n                       courbe(t,vec3(finBMilieu.x-.1,finBMilieu.y-.6,-finBMilieu.z+.3),vec3(-.7,-2.3,2.7),vec3(-.1+cosTime*2.,-1.3-cosTime,2.5),1.,.2,.6));\n    tentacules = Blend(tentacules,\n                       courbe(t,vec3(finBMilieu.x-.1,finBMilieu.y-.6,finBMilieu.z-.3),vec3(-.7,-2.3,-2.7),vec3(-.1+cosTime*2.,-1.3-cosTime,-2.5),1.,.2,.6));\n    float v = Blend(tete,tentacules);\n    \n\treturn v - T;\n}\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p)\n{\n\tfloat eps = 0.0001;\n\tvec3 n;\n\tfloat v = object(p);\n\tn.x = object(vec3(p.x + eps, p.y, p.z)) - v;\n\tn.y = object(vec3(p.x, p.y + eps, p.z)) - v;\n\tn.z = object(vec3(p.x, p.y, p.z + eps)) - v;\n\treturn normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat Trace(vec3 o, vec3 u, out bool h, out int s)\n{\n\th = false;\n\n\t// Don't start at the origin, instead move a little bit forward\n\tfloat t = rA;\n\n\tfor (int i = 0; i < Steps; i++)\n\t{\n\t\ts = i;\n\t\tvec3 p = o + t * u;\n\t\tfloat v = object(p);\n\t\t// Hit object\n\t\tif (v > 0.0)\n\t\t{\n\t\t\ts = i;\n\t\t\th = true;\n\t\t\tbreak;\n\t\t}\n\t\t// Move along ray\n\t\tt += Epsilon;\n\t\t// Escape marched far away\n\t\tif (t > rB)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o, vec3 u, out bool h, out int s)\n{\n\th = false;\n\n\t// Don't start at the origin, instead move a little bit forward\n\tfloat t = rA;\n\tfloat overhard;\n\n\tfor (int i = 0; i < Steps; i++)\n\t{\n\t\ts = i;\n\t\tvec3 p = o + t * u;\n\t\tfloat v = object(p);\n\t\t// Hit object\n\t\tif (v > 0.0)\n\t\t{\n\t\t\th = true;\n\t\t\tbreak;\n\t\t}\n\n        float f = abs(v) / 3.;\n\t\t// Test overhard i-1\n\t\tif(overhard > f) {\n\t\t\t//back\n\t\t\tt-=overhard;\n\t\t} else {\n\t\t\t// Move along ray\n\t\t\toverhard = f*0.2;\n\t\t\tt += max(Epsilon, f+overhard);\n\t\t}\n\n\t\t// Escape marched far away\n\t\tif (t > rB)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn t;\n}\n\n// Background color\nvec3 background(vec3 rd)\n{\n\treturn mix(vec3(0.4, 0.3, 0.0), vec3(0.7, 0.8, 1.0), rd.y * 0.5 + 0.5);\n}\n\n// Shading and lighting\n// p : point,\n// n : normal at point\nvec3 Shade(vec3 p, vec3 n)\n{\n\t// point light\n\tconst vec3 lightPos = vec3(5.0, 5.0, 5.0);\n\tconst vec3 lightColor = vec3(0.5, 0.5, 0.5);\n\n\tvec3 c = 0.25 * background(n);\n\tvec3 l = normalize(lightPos - p);\n\n\t// Not even Phong shading, use weighted cosine instead for smooth transitions\n\tfloat diff = 0.5 * (1.0 + dot(n, l));\n\n\tc += diff * lightColor;\n\n\treturn c;\n}\n\n// Shading with number of steps\nvec3 ShadeSteps(int n)\n{\n\tfloat t = float(n) / (float(Steps - 1));\n\treturn vec3(t, 0.25 + 0.75 * t, 0.5 - 0.5 * t);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 pixel = (gl_FragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\n\t// compute ray origin and direction\n\tfloat asp = iResolution.x / iResolution.y;\n\tvec3 rd = normalize(vec3(asp * pixel.x, pixel.y, -4.0));\n\tvec3 ro = vec3(0.0, 0.0, 20.0);\n\n    vec2 mouse = vec2(.5,.5);\n    if(iMouse.z>0.)\n\t\tmouse = iMouse.xy / iResolution.xy;\n\t//float a = iTime * 0.25;\n\tro = rotateY(ro, -2.+mouse.x);\n\trd = rotateY(rd, -2.+mouse.x);\n\tro = rotateZ(ro, -.5+mouse.y);\n\trd = rotateZ(rd, -.5+mouse.y);\n\n\t// Trace ray\n\tbool hit;\n\n\t// Number of steps\n\tint s;\n\n\tfloat t = SphereTrace(ro, rd, hit, s);\n\tvec3 pos = ro + t * rd;\n\t// Shade background\n\tvec3 rgb = background(rd);\n\n\tif (hit)\n\t{\n\t\t// Compute normal\n\t\tvec3 n = ObjectNormal(pos);\n\n\t\t// Shade object with light\n\t\trgb = Shade(pos, n);\n\t}\n\n\t// Uncomment this line to shade image with false colors representing the number of steps\n\t//rgb = ShadeSteps(s);\n\n\tfragColor = vec4(rgb, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}