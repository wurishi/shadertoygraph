{"ver":"0.1","info":{"id":"4XK3DD","date":"1717676135","viewed":34,"name":"Raymarching, 3 Spheres","username":"saxha","description":"a spheres\nuse mouse to rotate camera\n\nmy first raymarching shader","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","mouse","interactive","sphere","camera","rotation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 lightColor = vec3(1.0, 0.7, 0.4);\n\nfloat sphere(vec3 p, vec3 c, float r) {\n    return length(p - c) - r;\n}\n\nstruct Camera {\n    vec3 position;\n    vec3 rotation;\n    float fov; // Field of view\n};\n\nfloat rands(float seed) {\n    return fract(sin(seed) * 43758.5453123);\n}\n\nfloat randSeed() {\n    float a = iDate.w / 1000.0;\n    float rsx = rands(gl_FragCoord.x + a);\n    float rsy = rands(gl_FragCoord.y + rsx);\n    return a + rsy;\n}\n\nfloat rand(float seed) {\n    return fract(sin(seed + randSeed()) * 43758.5453123);\n}\n\nvec3 calculateLighting(vec3 normal, vec3 lightDir, vec3 viewDir, vec3 lightColor, float specularStrength, float roughness) {\n    // Lambertian diffuse term\n    float diffuse = max(dot(normal, lightDir), 0.0);\n    \n    // Specular reflection term with roughness\n    vec3 halfwayDir = normalize(lightDir + viewDir);\n    float roughnessFactor = 1.0 - roughness;\n    float specular = pow(max(dot(normal, halfwayDir), 0.0), 32.0 * roughnessFactor); // Shininess modified by roughness\n    \n    return lightColor * (diffuse + specularStrength * specular);\n}\n\nfloat calculateShadow(vec3 origin, vec3 dir, float maxDist) {\n    float shadow = 1.0;\n    float dist = 0.01;\n    for (int i = 0; i < 50; i++) {\n        float d = length(origin + dir * dist);\n        if (d < 0.001 || dist > maxDist) break;\n        shadow = min(shadow, 0.3 + 0.7 * d / maxDist); // Soft shadow\n        dist += 0.05;\n    }\n    return shadow;\n}\n\nvec3 postProcess(vec2 uv, vec3 c) {\n    c *= smoothstep(2., 0.1, length(uv - 0.5));\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized coordinates\n    vec2 uv = (fragCoord - vec2(0.25, 0.0) * iResolution.xy) / iResolution.y;\n    \n    // Ray direction\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec3 rayDir = normalize(vec3((uv.x * 2.0 - 1.0), uv.y * 2.0 - 1.0, 1.0));\n    \n    vec2 mouse = iMouse.xy / iResolution.xy;\n    if (mouse.x < 0.001 && mouse.y < 0.001) {\n        mouse = vec2(0.5, 0.5);\n    }\n    mouse -= 0.5;\n    mouse *= 3.;\n    \n    // Camera setup\n    Camera camera;\n    camera.position = vec3(0., 0., -3.);\n    camera.rotation = vec3(mouse.y, mouse.x * -1., 0.); // Pitch, yaw, roll (not used in this simple example)\n    camera.fov = 90.; // Field of view\n    \n    // Apply camera rotation (Y -> X -> Z order)\n    mat3 rotX = mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(camera.rotation.x), -sin(camera.rotation.x),\n        0.0, sin(camera.rotation.x), cos(camera.rotation.x)\n    );\n    mat3 rotY = mat3(\n        cos(camera.rotation.y), 0.0, sin(camera.rotation.y),\n        0.0, 1.0, 0.0,\n        -sin(camera.rotation.y), 0.0, cos(camera.rotation.y)\n    );\n    mat3 rotZ = mat3(\n        cos(camera.rotation.z), -sin(camera.rotation.z), 0.0,\n        sin(camera.rotation.z), cos(camera.rotation.z), 0.0,\n        0.0, 0.0, 1.0\n    );\n    rayDir = rotY * rotX * rotZ * rayDir;\n    \n    // Adjust ray direction based on FOV\n    float tanFOV = tan(radians(camera.fov * 0.5));\n    rayDir.x *= tanFOV;// * aspectRatio;\n    rayDir.y *= tanFOV;\n    \n    // Ray origin (transformed by camera position)\n    vec3 rayOrigin = camera.position;\n    \n    // Sphere positions\n    vec3 sphereCenter1 = vec3(0.0, sin(iTime) * 2., .5);\n    vec3 sphereCenter2 = vec3(2.0, 0.0, cos(iTime) * 2.);\n    vec3 sphereCenter3 = vec3(0., 0.0, 0.0);\n    \n    // Sphere radius\n    float sphereRadius = 1.0;\n    \n    vec3 lightPos = vec3(mouse.x, mouse.y, -3.0);\n    \n    // View direction\n    vec3 viewDir = normalize(-rayDir);\n    \n    // Raymarching\n    float t = 0.0;\n    float shadow = 1.0;\n    vec3 color = mix(vec3(0.0, 0.4, 1.0), vec3(0.7), (1.0 - uv.y - 0.2) - camera.rotation.x * 0.5);\n    bool hit = false;\n    for (int i = 0; i < 60; i++) {\n        vec3 p = rayOrigin + rayDir * t;\n        float dist1 = sphere(p, sphereCenter1, sphereRadius);\n        float dist2 = sphere(p, sphereCenter2, sphereRadius);\n        float dist3 = sphere(p, sphereCenter3, sphereRadius);\n        float dist = min(min(dist1, dist2), dist3);\n        if (dist < 0.001) {\n            // Hit a sphere, calculate lighting\n            hit = true;\n            vec3 normal;\n            if (dist == dist1) {\n                normal = normalize(p - sphereCenter1);\n            } else if (dist == dist2) {\n                normal = normalize(p - sphereCenter2);\n            } else {\n                normal = normalize(p - sphereCenter3);\n            }\n            vec3 lightDir = normalize(lightPos - p);\n            shadow = calculateShadow(p + normal * 0.001, lightDir, length(lightPos - p));\n            color += calculateLighting(normal, lightDir, viewDir, lightColor, 0.5, .8);\n            \n            // Add roughness to reflections\n            vec3 reflectDir = normalize(reflect(rayDir, normal));\n            reflectDir += 0.1 * normalize(vec3(rand(p.x), rand(p.y), rand(p.z))) * .8; // Adjust 0.1 for roughness effect\n            \n            // Sample texture and blend it with the calculated color\n            vec2 texCoord = vec2(0.5) + normal.xy * 0.5; // Use normal to generate texture coordinates\n            vec3 texColor = texture(iChannel0, texCoord).rgb;\n            color = mix(color, texColor, .5); // Blend 50% of texture color with calculated color\n            \n            rayOrigin = p + normal * 0.001;\n            rayDir = reflectDir;\n            t = 0.0;\n        }\n        t += dist;\n    }\n    \n    // If no hit, sample cubemap for sky color\n    if (!hit) {\n        vec3 cubemapColor = texture(iChannel1, rayDir).rgb;\n        color = mix(color, cubemapColor, 0.8); // Blend cubemap color with the base color\n    }\n    \n    // Final color\n    color *= shadow;\n    color = postProcess(uv, color); // some post process\n    fragColor = vec4(color, 1.);\n}\n","name":"Image","description":"","type":"image"}]}