{"ver":"0.1","info":{"id":"4XK3DG","date":"1718165046","viewed":79,"name":"Ziggy zags","username":"xld3","description":"kept iterating and stumbled onto something cool","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["mouse","transform","golf","ziggy"],"hasliked":0,"parentid":"lXG3zd","parentname":"Rainbow folding"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// mouse x affects rotation\n// mouse y affects zoom\n// mouse dist from 0,0 affects wave offset, edge offset, & fract transform\n\nvoid mainImage(out vec4 o, in vec2 f)\n{\n    vec2 r = 2./iResolution.xy,\n        M = (iMouse.z == 1. || iMouse.x != 0.) ? \n            iMouse.xy*r - 1. \n        : vec2(0);\n    \n    f = f*r - 1.; // NDC\n    \n    float T = iTime * .1,\n        G = length(f),\n        X = sin(T),\n        N = length(M), // length(mouse.xy) used for wave offset\n        A = radians((X - M.x) * G * 90. ) - M.x, // rotation angle\n        B = sin(A),\n        C = cos(A),\n        D = .5+.5*X;\n        \n    // this transform is pretty cool\n    f = mix(f, f*cos(f)/(.5+.5*G), D + N);\n    \n    // rotate, zoom +- mouse.y\n    f *= mat2(C, B, -B, C) * (2.5+ D + M.y);\n    \n    // wave\n    float W = T + abs(f.x * f.y) + sin(cos(T) * dot(f, f)),\n        // edge\n        e = sin(3.*W + 3.*N),\n        d = 1./fwidth(e),\n        // vignette\n        v = smoothstep(.5, 2., G);\n        \n    /* \n    the vignette is applied to color and white edges separately...\n    white edge isn't true vignette, it subtracts thickness.\n    looking for a better way to do this.\n    */\n        \n    o = vec4(\n    // rgb waves - vignette\n    (.5 + .5*cos(W + N + vec3(0, 2, 4)) - v)\n    // black edges\n    * (smoothstep(1., -1., (abs(e) - .5) * d)\n        // edge glow\n        + smoothstep(3., -3., abs(e)))\n    // white edges - vignette\n    + smoothstep(1., -1., (e +.95) * d + v), \n    1.); // alpha\n}","name":"Image","description":"","type":"image"}]}