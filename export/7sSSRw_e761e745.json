{"ver":"0.1","info":{"id":"7sSSRw","date":"1619887176","viewed":295,"name":"Bouncy balls II","username":"Leasel","description":"Uses a similar way of thinking in my sketch of pressure fluids. \n(Second version with less glitches, but still disappearing balls. Thus something is not right with the collission)","likes":5,"published":3,"flags":32,"usePreview":0,"tags":["buffer"],"hasliked":0,"parentid":"fdBSzW","parentname":"Bouncy balls 1"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = T(ivec2(fragCoord)).wwww;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvoid ConfigureOwnBall(inout vec4 myBall)\n{\n    //Get all variables\n    ivec2 dir = GetTexelDirection(myBall);\n    \n    //Look if it will lose its ball\n    myBall *= WillLandInThisCell(dir);\n}\n\nvoid ConfigureNeighbourBall(inout vec4 myBall, in ivec2 RelativePositionToNeighbour, in ivec2 p)\n{\n    //Get all variables of neighbourball\n    vec4 NeighbourBall = T(p - RelativePositionToNeighbour);\n    ivec2 dirN = GetTexelDirection(NeighbourBall);\n    \n    //Look if will get neighbour ball\n    NeighbourBall *= WillLandInThisCell(dirN - RelativePositionToNeighbour);\n    \n    //Apply physics to the neighbour ball(this is not accurate)\n    //NeighbourBall.xy -= min(GetSpeed(NeighbourBall), 1.) * GetDirection(NeighbourBall) * iTimeDelta * GetWeight(NeighbourBall);\n    \n    //Get neighbour ball if landing on own cell\n    myBall += NeighbourBall;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Get start variables\n    ivec2 p = ivec2(fragCoord);\n    vec4 myBall = T(p);\n   \n    //Look if myBall will lose its ball\n    ConfigureOwnBall(myBall);\n    \n    //Look around at neightbours balls if you can inherit one\n    ConfigureNeighbourBall(myBall, ivec2(-1., -1.), p);\n    ConfigureNeighbourBall(myBall, ivec2(-0., -1.), p);\n    ConfigureNeighbourBall(myBall, ivec2( 1., -1.), p);\n    ConfigureNeighbourBall(myBall, ivec2(-1., -0.), p);\n    //Center\n    ConfigureNeighbourBall(myBall, ivec2( 1., -0.), p);\n    ConfigureNeighbourBall(myBall, ivec2(-1.,  1.), p);\n    ConfigureNeighbourBall(myBall, ivec2(-0.,  1.), p);\n    ConfigureNeighbourBall(myBall, ivec2( 1.,  1.), p);\n    \n    //Return the ball to this cell\n    fragColor = myBall;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec4 GetStarterBalls(in vec2 fragCoord)\n{\n    vec4 ball = texture(iChannel1, fragCoord/iResolution.xy);\n    \n    ball.x = 0.;\n    ball.y = 2.;\n    \n    ball.w = ceil(ball.z-0.5);\n    \n    ball.w = clamp(round(ball.w), 0., 1.);\n    ball.xy *= ball.w;\n\n    return ball;\n}\n\nbool AtBorder(in ivec2 p)\n{\n    return p.x < 2 || p.y < 2 || p.x > int(iResolution.x) - 3 || p.y > int(iResolution.y) - 3;\n}\n\nvec4 GetBorderBalls(in ivec2 p)\n{\n    return vec4(0.);\n}\n\nvoid ApplyGravity(inout vec4 myBall)\n{\n    myBall.y += GetWeight(myBall) * -9.81 * iTimeDelta;\n}\n\nvec2 reflectionDir(in ivec2 p, in ivec2 dir)\n{\n    return GetBall(T(p + dir)) * -vec2(dir);\n}\n\nvoid ApplyCollission(inout vec4 myBall, in ivec2 p)\n{\n    //The best option is to look around and compute how much speed it gets from its neighbours and loses from its neighbours\n\n    //Get variables\n    ivec2 dir = GetTexelDirection(myBall);\n    vec4 colBall = T(p + dir);\n    vec2 reflectDir = vec2(0);\n    \n    //Make reflection dir\n    for(int i = 0; i < 8; i++)\n    {\n        reflectDir += reflectionDir(p, neighbourPosses[i]);\n    }\n    \n    ////Look if direction to move will not be occupied\n    //bool canMove = true;\n    //vec2 moveToDir = reflect(normalize(vec2(dir)), normalize(reflectDir))*length(myBall.xy);\n    //ivec2 moveToTexelDir = GetTexelDirection(moveToDir);\n    //for(int i = 0; i < 8 && canMove; i++)\n    //{\n    //    if(neighbourPosses[i] != -moveToTexelDir)\n    //    {\n    //        vec4 ball = T(neighbourPosses[i] + p + moveToTexelDir);\n    //        ivec2 oDir = GetTexelDirection(ball);\n    //        \n    //        canMove = (neighbourPosses[i] + oDir) != ivec2(0) && !isBall(ball);\n    //    }\n    //}\n    //\n    ////Stand still for now if occupied(crued fix)\n    //myBall.xy = canMove || moveToTexelDir == ivec2(0) ? myBall.xy : vec2(0.);\n    \n    myBall.xy = isBall(myBall) && dir != ivec2(0) && reflectDir != vec2(0.) && isBall(colBall) ? \n        reflect(normalize(vec2(dir)), normalize(reflectDir))*length(myBall.xy) : \n        myBall.xy;\n}\n\nvoid ApplyDamping(inout vec4 myBall)\n{\n    myBall.xy *= 0.99;//Sort of air resistance\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    //Get start variables\n    ivec2 p = ivec2(fragCoord);\n    vec4 myBall = T(p);\n    \n    //Add in some balls\n    myBall += iFrame < 10 && !isBall(myBall) ? GetStarterBalls(fragCoord) : vec4(0.); \n    \n    //Apply physics to ball\n    ApplyGravity(myBall);\n    \n    //Apply some damping\n    ApplyDamping(myBall);\n    \n    //Apply collission to ball\n    ApplyCollission(myBall, p);\n    \n    //Add the border balls\n    myBall = AtBorder(p) ? vec4(0.,0.,0.,1.) : myBall;\n    \n    //Return the ball to this cell\n    fragColor = myBall;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define T(fragCoord) texelFetch(iChannel0, fragCoord, 0)\n\nconst ivec2 neighbourPosses[] = ivec2[]\n(\n    ivec2(-1., -1.),\n    ivec2( 0., -1.),\n    ivec2( 1., -1.),\n    ivec2( 1.,  0.),\n    ivec2( 1.,  1.),\n    ivec2( 0.,  1.),\n    ivec2(-1.,  1.),\n    ivec2(-1.,  0.)\n);\n\nivec2 GetTexelDirection(in vec2 dir)\n{\n    return ivec2(clamp(dir, -1., 1.));\n}\nivec2 GetTexelDirection(in vec4 ball)\n{\n    return GetTexelDirection(ball.xy);\n}\n\nvec2 GetDirection(in vec4 ball)\n{\n    return ball.x + ball.y == 0. ? vec2(0.) : normalize(ball.xy);\n}\n\nvec2 GetImpulse(in vec4 ball)\n{\n    return ball.xy;\n}\n\nfloat GetSpeed(in vec4 ball)\n{\n    return length(ball.xy);\n}\n\nfloat GetWeight(in vec4 ball)\n{\n    return ball.z;\n}\n\nbool isBall(in vec4 ball)\n{\n    return ball.w > 0.;\n}\n\nfloat GetBall(in vec4 ball)\n{\n    return ball.w;//Get this value and multiply this with the force, but this can also be checked with mass\n}\n\nfloat WillLandInThisCell(in ivec2 pos)\n{\n    return pos == ivec2(0) ? 1. : 0.;\n}\n\nfloat WillLandInThisCell(in vec2 pos)\n{\n    return pos == vec2(0.) ? 1. : 0.;\n}","name":"Common","description":"","type":"common"}]}