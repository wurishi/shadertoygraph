{"ver":"0.1","info":{"id":"mlsBRX","date":"1693290523","viewed":60,"name":"3D Fractal Render by Anton","username":"Anto_Crasher555","description":"made using https://www.shadertoy.com/view/MtfGWM","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","fractal","render"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_MARCH_STEPS 78\n#define MAX_DISTANCE 10.0\n#define SURFACE_DISTANCE_THRESHOLD 0.00001\n#define EPSILON 0.0001\n#define TAU 6.283185\n#define PI 3.141592\n#define SIZE iResolution\n#define TIME iTime\n\n// GLOBAL VARIABLES\nvec3 lightDirection = normalize(vec3(0.4, 0.8, -0.6));\nvec3 fractCenter;\nvec3 mainColor;\nvec2 fragCoord;\n\n// GET SKYBOX COLOR\nvec3 Sky(vec3 rayDirection) {\n    return vec3(0.5 + 0.5 * rayDirection.y);\n}\n\n// RANDOM\nfloat random(vec2 coords) {\n    return fract(sin(dot(vec2(1.317, 19.753), coords)) * 413.7972);\n}\n\n// RANDOM START\nfloat randomStart() {\n    return 0.5 + 0.5 * random(fragCoord.xy + vec2(TIME * 217.0));\n}\n\n// RANDOM FRACTAL DE\n\nfloat randFractalDE(vec3 point) {\n    float distanceMultiplier = 1.0;\n    float dist = length(point);\n    \n    for (int i = 0; i < 10; i++) {\n        if (dist > 20.0)\n            break;\n        \n        distanceMultiplier = distanceMultiplier * 2.0 * dist;\n        float psi = abs(mod(atan(point.z, point.y) + PI / 8.0, PI / 4.0) - PI / 8.0);\n        point.yz = vec2(cos(psi), sin(psi)) * length(point.yz);\n        vec3 posSquared = point * point;\n        point = vec3(vec2(posSquared.x - posSquared.y, 2.0 * point.x * point.y) * (1.0 - posSquared.z / (posSquared.x + posSquared.y + posSquared.z)),\n                 2.0 * point.z * sqrt(posSquared.x + posSquared.y)) + fractCenter;\n        \n        dist = length(point);\n        \n        if (i == 3)\n            mainColor = point;\n    }\n    \n    return min(log(dist) * dist / max(distanceMultiplier, 1.0), 1.0);\n}\n\n// MANDELBULB DE\nfloat mandelbulbDE(vec3 point) {\n    vec3 z = point;\n    float dr = 1.0;\n    float r = 0.0;\n    float max_pow = 11.640;\n    float power = sin(iTime) + 5.0;\n    int iters = 0;\n    for (int i = 0; i < 100; i++) {\n        iters = i;\n        r = length(z);\n        if (r > 2.0)\n            break;\n        float theta = atan(z.y, z.x);\n        float phi = acos(z.z / r);\n        dr = pow(r, power - 1.0) * power * dr + 1.0;\n        float zr = pow(r, power);\n        theta = theta * power;\n        phi = phi * power;\n        z = vec3(sin(phi) * cos(theta), sin(phi) * sin(theta), cos(phi)) * zr + point;\n        if (i == 2)\n            mainColor = z;\n    }\n    return 0.5 * log(r) * r / dr;\n}\n\n// SCENE DISTANCE ESTIMATE\nfloat getSceneDist(vec3 point) {\n    return randFractalDE(point);\n}\n\n// GET SOFT SHADOW\nfloat softShadow(vec3 rayOrigin, vec3 rayDir, float pixelSize) {\n    float result = 1.0, distance, t = 2.0 * pixelSize * randomStart();\n    for (int i = 0; i < 4; i++) {\n        distance = max(pixelSize, getSceneDist(rayOrigin + rayDir * t) * 1.5);\n        t += distance;\n        result = min(result, distance / t + t * 0.1);\n    }\n    \n    return result;\n}\n\n// COLOR SCENE\nvec3 Color(vec3 rayOrigin, vec3 rayDir, float t, float pixelSize, vec3 color, bool shouldFill) {\n    rayOrigin += rayDir * t;\n    float dist = getSceneDist(rayOrigin);\n    \n    vec2 epsilon = vec2(pixelSize * t, 0.0);\n    vec3 dn = vec3(getSceneDist(rayOrigin - epsilon.xyy), getSceneDist(rayOrigin - epsilon.yxy), getSceneDist(rayOrigin - epsilon.yyx));\n    vec3 dp = vec3(getSceneDist(rayOrigin + epsilon.xyy), getSceneDist(rayOrigin + epsilon.yxy), getSceneDist(rayOrigin + epsilon.yyx));\n    vec3 normal = (dp - dn) / (length(dp - vec3(dist)) + length(vec3(dist) - dn));\n    vec3 reflection = reflect(rayDir, normal);\n    vec3 lightColor = vec3(1.0, 0.9, 0.8), surfaceColor = sqrt(abs(sin(mainColor))), reflectionColor = Sky(reflection);\n    float shadow = clamp(softShadow(rayOrigin, lightDirection, pixelSize * t) + 0.2, 0.0, 1.0);\n    shadow = shadow * (0.5 + 0.5 * dot(normal, lightDirection)) * exp(-t * 0.125);\n    vec3 finalColor = shadow * lightColor * (surfaceColor + reflectionColor * pow(max(0.0, dot(reflection, lightDirection)), 4.0));\n    \n    if (shouldFill)\n        dist *= 0.05;\n    \n    color = mix(finalColor, color, clamp(dist / (pixelSize * t), 0.0, 1.0));\n    return color;\n}\n\n// MARCH RAY TO SCENE\nvec3 rayMarch(vec3 rayOrigin, vec3 rayDir) {\n    float pixelSize = 0.5 / SIZE.y;\n\n    float dist = getSceneDist(rayOrigin), previousDistance = 0.0, oldDistance = MAX_DISTANCE;\n    vec3 edge = vec3(-1.0);\n    bool shouldGrab = false;\n    vec3 finalColor = Sky(rayDir);\n\n    for (int i = 0; i < MAX_MARCH_STEPS; i++) {\n        dist += previousDistance * 0.5;\n        previousDistance = getSceneDist(rayOrigin + rayDir * dist);\n\n        if (previousDistance > oldDistance) {\n            if (shouldGrab && oldDistance < pixelSize * dist && edge.x < 0.0) {\n                edge = vec3(edge.yz, dist - oldDistance);\n                shouldGrab = false;\n            }\n        } else {\n            shouldGrab = true;\n        }\n\n        oldDistance = previousDistance;\n\n        if (dist > MAX_DISTANCE || previousDistance < SURFACE_DISTANCE_THRESHOLD)\n            break;\n    }\n\n    bool shouldFill = false;\n    previousDistance *= 0.05;\n\n    if (previousDistance < pixelSize * dist && dist < MAX_DISTANCE) {\n        if (edge.x > 0.0)\n            edge = edge.zxy;\n        \n        edge = vec3(edge.yz, dist);\n        shouldFill = true;\n    }\n\n    for (int i = 0; i < 3; i++) {\n        if (edge.z > 0.0)\n            finalColor = Color(rayOrigin, rayDir, edge.z, pixelSize, finalColor, shouldFill);\n        \n        edge = edge.zxy;\n        shouldFill = false;\n    }\n    \n    return finalColor;\n}\n\n// GET SCREEN RAY DIRECTION\nvec3 getRayDir(vec2 screenUV, vec3 cameraPosition, vec3 lookAt, float focalLength) {\n    vec3 forward = normalize(lookAt - cameraPosition);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    vec3 cameraCenter = cameraPosition + forward * focalLength;\n    vec3 intersectionPoint = cameraCenter + screenUV.x * right + screenUV.y * up;\n    return normalize(intersectionPoint - cameraPosition);\n}\n\n// ROTATE VECTOR\nmat2 rotVector(float angleRadians) {\n    float sineValue = sin(angleRadians);\n    float cosineValue = cos(angleRadians);\n    mat2 rotationMatrix = mat2(cosineValue, -sineValue, sineValue, cosineValue);\n    return rotationMatrix;\n}\n\n// MAIN IMAGE FUNCTION\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord = fragCoord;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n \n    // FRACTAL SETTINGS\n    fractCenter = vec3(0.0, sin(TIME)+1.0, cos(TIME)-1.0);\n \n    // CAMERA SETTINGS \n    vec3 cameraPos = vec3(0, 0.0, 2.0);\n    \n    cameraPos.yz *= rotVector(mouse.y*PI-1.);\n    cameraPos.xz *= rotVector(-mouse.x*TAU);\n    \n    const vec3 cameraTarget = vec3(0.0, 0.0, 0.0);\n    const float fov = 70.0;\n\n    // UV COORDS\n    vec2 uv = fragCoord/iResolution.xy;\n    uv *= 2.0;\n    uv -= 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // GET FOV PIXEL COORDS\n    float fovRad = fov * (3.141 / 180.0);\n    float tanHalfFov = tan(fovRad * 0.5);\n    float ny = tanHalfFov * uv.y;\n    float nx = tanHalfFov * uv.x;\n\n    // GET DIRECTION\n    vec3 cameraDirection = getRayDir(vec2\n    (nx, ny), cameraPos, cameraTarget, 1.);\n    \n    vec3 retColor = rayMarch(cameraPos, cameraDirection);\n    \n    fragColor = vec4(2.0 * retColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}