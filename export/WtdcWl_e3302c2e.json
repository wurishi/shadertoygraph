{"ver":"0.1","info":{"id":"WtdcWl","date":"1610369444","viewed":276,"name":"Manhattan Voronoi Distance","username":"nr4","description":"This shader contains technology for taxicab/manhattan metric voronoi.","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["intersection","distance","manhattan","taxicab","metrics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * Manhattan Voronoi Distance\n * \n * Copyright (C) 2021  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nconst vec3 c = vec3(1.,0.,-1.);\nconst float pi = acos(-1.);\n\nvoid rand(in vec2 x, out float n)\n{\n    x -= 400.;\n    n = fract(sin(dot(sign(x)*abs(x) ,vec2(12.9898,78.233)))*43758.5453);\n}\n\nvoid lfnoise(in vec2 t, out float n)\n{\n    vec2 i = floor(t);\n    t = fract(t);\n    t = smoothstep(c.yy, c.xx, t);\n    vec2 v1, v2;\n    rand(i, v1.x);\n    rand(i+c.xy, v1.y);\n    rand(i+c.yx, v2.x);\n    rand(i+c.xx, v2.y);\n    v1 = c.zz+2.*mix(v1, v2, t.y);\n    n = mix(v1.x, v1.y, t.x);\n}\n\nfloat mn(in vec2 a)\n{\n    a = abs(a);\n    return a.x+a.y;\n}\n\nfloat ml(in vec2 x, in vec2 p1, in vec2 p2)\n{\n    return (mn(x-p1)-mn(x-p2))/pow(mn(p2-p1),.5);\n}\n\nvoid dmanhattanvoronoi(in vec2 x, out float d, out vec2 z)\n{\n    vec2 y = floor(x);\n       float ret = 1.;\n    vec2 pf=c.yy, p;\n    float df=10.;\n    \n    for(int i=-1; i<=1; i+=1)\n        for(int j=-1; j<=1; j+=1)\n        {\n            p = y + vec2(float(i), float(j));\n            vec2 pa;\n            lfnoise(p-.5*iTime, pa.x);\n            lfnoise(p+13.-.5*iTime-2.*pa.x, pa.y);\n            pa = .5+.25*pa;\n            //rand(p, pa);\n            p += pa;\n            \n            d = mn(x-p);\n            \n            if(d < df)\n            {\n                df = d;\n                pf = p;\n            }\n        }\n    for(int i=-1; i<=1; i+=1)\n        for(int j=-1; j<=1; j+=1)\n        {\n            p = y + vec2(float(i), float(j));\n            vec2 pa;\n            lfnoise(p-.5*iTime, pa.x);\n            lfnoise(p+13.-.5*iTime-2.*pa.x, pa.y);\n            pa = .5+.25*pa;\n            //rand(p, pa);\n            p += pa;\n            \n            d = abs(ml(x, pf, p));\n            ret = min(ret, d);\n        }\n    \n    d = ret;\n    z = pf;\n}\n\nfloat sm(in float d)\n{\n    return smoothstep(1.5/iResolution.y, -1.5/iResolution.y, d);\n}\n\nvoid rgb2hsv(in vec3 c, out vec3 b)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    b = vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvoid hsv2rgb(in vec3 c, out vec3 o)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    o = c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Please ignore the drawing code :) I invested no effort here.\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y,\n        vc;\n    \n    float d,\n        r;\n    dmanhattanvoronoi(5.*uv, d, vc);\n    d /= 5.;\n    vc /= 5.;\n    lfnoise(40.*vc-.2*iTime, r);\n    r = .5+.5*r;\n\n    d = abs(d)-.01;\n    \n    float interval = clamp(.01 * (d-mod(d,.00125))/.00125, 0., 1.);\n    vec3 col = mix(vec3(1.00,0.90,0.68), vec3(0.98,0.64,0.67), 2.*interval);\n    if(interval > .5) col = mix(col, vec3(0.54,0.80,0.80), 2.*(interval-.5));\n    col = mix(col, c.yyy, sm(d));\n    col = mix(mix(col, r*col*col, (.5+.5*r)), r*.4*c.xxx, sm(abs(mod(d+.0125,.025)-.0125)-.001));\n    col = mix(col, c.xyy, sm(length(uv-vc)-.01));\n    \n    rgb2hsv(col,col);\n    col.g = r;\n    hsv2rgb(col,col);\n    \n    fragColor = vec4(clamp(col,0.,1.),1.0);\n}","name":"Image","description":"","type":"image"}]}