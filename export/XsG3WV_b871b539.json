{"ver":"0.1","info":{"id":"XsG3WV","date":"1456578893","viewed":620,"name":"Distance shapes morphing","username":"Andre","description":"A collection of 2D shape formulas and morphing between them","likes":29,"published":1,"flags":0,"usePreview":0,"tags":["2d","distancefield","numbers","shapes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float heart(vec2 i) {\n    // From: https://www.shadertoy.com/view/ldVGzt by coyote & Fabrice\n    i.y += .034;\n    i *= 1.1;\n    return sqrt(dot(i, i) - abs(i.x)*i.y);\n}\n\nfloat diamond(vec2 i) {\n    i = abs(i);\n    return (i.x+i.y);\n}\n\nfloat square(vec2 i) {\n    i = abs(i);\n    return max(i.x,i.y);\n}\n\nfloat circle(vec2 i) {\n    return length(i);\n}\n\nfloat circle2(vec2 i) {\n    \n    return length(vec2(abs(length(i)-.5),max(0.,abs(atan(i.x,i.y))/2.-sin(iTime)-.7)))+.35;\n   //return length(vec2(abs(length(i)-.5),1.3-2.*atan(i.x,i.y)))+.35;\n}\n\nfloat honeycomb(vec2 i) {\n    i.x*=.866;\n    i = abs(i);\n    return max(i.x+i.y*.5,i.y);\n}\n\nfloat segment(vec2 uv)\n{\n    uv = abs(uv);\n\tfloat f = max(0.45+uv.x,0.225+uv.y+uv.x);\n    return f;\n}\n\nfloat m(float a, float b)\n{\n    return min(a,b);\n    //return 1./(1./a+1./b);\n    //return length(vec2(a,b));\n}\n\nfloat sevenSegment(vec2 uv,int num)\n{\n\tfloat seg= 5.0;\n\tseg = (num!=-1 && num!=1 && num!=4                    ?m(segment(uv.yx+vec2(-0.450, 0.000)),seg):seg);\n\tseg = (num!=-1 && num!=1 && num!=2 && num!=3 && num!=7?m(segment(uv.xy+vec2( 0.225,-0.225)),seg):seg);\n\tseg = (num!=-1 && num!=5 && num!=6                    ?m(segment(uv.xy+vec2(-0.225,-0.225)),seg):seg);\n\tseg = (num!=-1 && num!=0 && num!=1 && num!=7          ?m(segment(uv.yx+vec2( 0.000, 0.000)),seg):seg);\n\tseg = (num==0 || num==2 || num==6 || num==8           ?m(segment(uv.xy+vec2( 0.225, 0.225)),seg):seg);\n\tseg = (num!=-1 && num!=2                              ?m(segment(uv.xy+vec2(-0.225, 0.225)),seg):seg);\n\tseg = (num!=-1 && num!=1 && num!=4 && num!=7          ?m(segment(uv.yx+vec2( 0.450, 0.000)),seg):seg);\n\t\n\treturn seg;\n}\n\nvec2 rotate(vec2 i,float a) {\n   return i *mat2(cos(a), -sin(a),\n                  sin(a), cos(a));\n}\n\nfloat getShape(int nr, vec2 uv) {\n    \n    //return circle2(uv);\n        \n    bool outline = false;\n    if (nr<10)\n        return sevenSegment(uv,nr);\n    else {\n        outline = (nr>=15);\n        nr = int(mod(float(nr),5.));\n    }\n\n    float x = 0.0;\n    if (nr==0) x = heart    (uv); else\n    if (nr==1) x = diamond  (uv); else\n    if (nr==2) x = square   (uv); else\n    if (nr==3) x = circle   (uv); else\n               x = honeycomb(uv);\n        \n    return outline ? 0.45+abs(x-.5) : x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord-0.5*iResolution.xy) / iResolution.y *1.1;\n    \n    //uv = rotate(uv,iTime);\n    \n    float gt = iTime;\n    int shapeNr1 = int(mod(gt    ,20.0));\n    int shapeNr2 = int(mod(gt+1.0,20.0));\n    float mixPerc = mod(gt, 1.0);\n    \n    // Start morph in the middle\n    mixPerc = smoothstep(0.2,0.8,mixPerc);\n    \n    // Add bounce to morph\n    mixPerc = sin(pow(mixPerc,2.5)*2.2)/sin(2.2);\n    \n    // Linear mix\n    //float x = mix(getShape(shapeNr1,uv),\n    //              getShape(shapeNr2,uv),\n    //              mixPerc);\n    \n    // Alternate mix\n    float x = 1.0/mix(1.0/getShape(shapeNr1,uv),\n                      1.0/getShape(shapeNr2,uv),\n                      mixPerc);\n                      \n\tvec3 clr = vec3(0.0);\n    \n    float px2 = 2.0/iResolution.y;\n    // distance lines\n    clr.g = 0.6-0.6*smoothstep( 0.0,\n                                px2,\n                                abs(mod(x-.001,.05)-0.025));\n    // shape\n    clr.b = 1.0-smoothstep(0.5,\n                           0.5+px2,\n                           x);\n    if (iMouse.w>0.) {\n    \tclr.r = 0.7-0.7*smoothstep(0.49,0.49+px2, x); // The numbers\n    \tclr.g = 0.7-0.7*smoothstep(0.00,px2, abs(x-0.49)); // Yellow outline\n    \tclr.b = 0.4-0.4*smoothstep(0.43,0.53,1.0-x); // Background with shadow\n    \tclr.rg += 0.12-0.12*smoothstep(0.00,0.04, abs(x-0.49)); // Yellow glow\n    \tclr += 0.12-0.12*smoothstep(0.40,0.50, x); // Stretchmarks\n    \tclr -= clr.b*(1.0- smoothstep( 0.0,\n                                   px2,\n                                   abs(mod(x-.001,.05)-0.025)));\n    }\n    \n    fragColor = vec4(clamp(clr,0.0,1.0),1.0);\n}","name":"Image","description":"","type":"image"}]}