{"ver":"0.1","info":{"id":"7stfzs","date":"1657057167","viewed":90,"name":"Inside The Nebulae","username":"mattdeeds","description":"Simple ray casting into noise.  Intended for a sky sphere.  Use mouse to rotate camera.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raycasting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define kDistanceToScreen 1.0\n#define kRaySteps 5\n#define kRayLength 15.0\n#define kOrbitRadius 3.0\n\nmat3 rotation3dX(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n\n  return mat3(\n    1.0, 0.0, 0.0,\n    0.0, c, s,\n    0.0, -s, c\n  );\n}\n\nmat3 rotation3dY(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n\n  return mat3(\n    c, 0.0, -s,\n    0.0, 1.0, 0.0,\n    s, 0.0, c\n  );\n}\n\n\nmat3 rotation3dZ(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n\n  return mat3(\n    c, s, 0.0,\n    -s, c, 0.0,\n    0.0, 0.0, 1.0\n  );\n}\n\n\nfloat noise3to1(in vec3 p) {\n  const mat3 m = mat3(\n    1.0, 0.0, 0.0,\n    0.5, 1.2, 0.0,\n    0.0, 0.0, 1.0);\n\n  vec3 s = m * p;\n\n  return sin(s.x) * sin(s.y) * sin(s.z);\n}\n\nvec3 noise3to3(in vec3 p) {\n  return vec3(\n    noise3to1(p.xyz + vec3(1, 2, 3) * vec3(0.9, 0.7, 1.3)),\n    noise3to1(p.zyx + vec3(7, 9, 8) * vec3(0.5, 1.2, 1.1)),\n    noise3to1(p.yxz + vec3(3, 2, 5) * vec3(0.8, 0.3, 1.5)));\n}\n\nvec3 brown(in vec3 p) {\n  return 0.5 * noise3to3(p) + 0.2 * noise3to3(p * 3.0) + 0.1 * noise3to3(p * 5.0);\n\n}\n\nvec3 grey(in vec3 p) {\n  return brown(brown(p * 0.1) * 5.0);\n}\n\n\n\nvec3 noise(in vec3 x) {\n  float thickness2 = 25.0;\n  float p = smoothstep(0.0, thickness2, thickness2 - (x.y * x.y));\n  float radius = length(x);\n  float q = smoothstep(8.0, 7.0, radius);\n  return grey(x) * p * q;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.0 * (fragCoord - (iResolution.xy * 0.5)) / iResolution.yy;\n\n    vec2 mouseUV = 8.0 * (iMouse.xy - (iResolution.xy * 0.5)) / iResolution.yy;\n\n    mat3 tx = rotation3dY(mouseUV.x) * rotation3dX(-mouseUV.y);\n\n    vec3 view = vec3(uv.x, uv.y, -kDistanceToScreen);\n    view = view / length(view);\n    view = tx * view;\n    \n    vec3 pos = kOrbitRadius * vec3(cos(iTime * 0.3), 0.0, sin(iTime * 0.3));\n    \n    vec3 step = view * kRayLength / float(kRaySteps);\n    vec3 col = vec3(0.0,0.0,0.0);\n    for (int i = 0; i < kRaySteps; ++i) {\n      col += noise(step * float(i + 1) + pos);\n    }\n    col = smoothstep(0.0, 1.0, 5.0 * col / float(kRaySteps));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}