{"ver":"0.1","info":{"id":"DtKyzG","date":"1701920429","viewed":38,"name":"Eyelash on your screen","username":"Pyromican","description":"Did you wipe your screen?\n\nNoise ripped from https://www.shadertoy.com/view/ldjczd","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","lol","eyelash"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_RAYMARCH_STEPS = 500;\nconst float nearPlane = 0.0001;\nconst float farPlane = 100.0;\nconst float PI = 3.1415926535;\nconst float GAMMA = 2.2;\nconst int aaON = 4;\nconst int aaOFF = 1;\n\nvec3 camera = vec3(0.0, 0.0, 1.0);\nvec3 col = vec3(0.0);\n\nfloat attConst = 1.0;\nfloat attLinear = 0.0035f;\nfloat attQuad = 0.0005f;\n\n\nstruct Material\n{\n    vec3 ambientCol;\n    vec3 diffCol;\n    vec3 specCol;\n    float alpha;\n    float gloss;\n    // The gloss number is based on how far it is from the number 1. ex) 0.2 = 1.8, 0.5 = 1.5, 0.0 = 2.0\n    float ior;\n    // IF 0 < ior < 1 THEN equivalent to 1/ior\n    // IF 1 < ior THEN just use the ior\n};\n\nstruct Surface\n{\n    float sd;\n    vec3 color;\n    Material mat;\n};\n\n//----------Materials----------//\n\nMaterial Black()\n{\n    vec3 a = vec3(0.0);\n    vec3 d = vec3(0.0);\n    vec3 s = vec3(1.0);\n    float alpha = 135.0;\n    float gloss = 1.0;\n    float ior = 1.5;\n    return Material(a, d, s, alpha, gloss, ior);\n}\n\nMaterial BurntCopper()\n{\n    vec3 a = vec3(0.05267, 0.007788, 0.00075625);\n    vec3 d = vec3(0.30338, 0.044859, 0.004356);\n    vec3 s = vec3(0.33709, 0.049844, 0.004831);\n    float alpha = 51.1;\n    float gloss = 1.5;\n    float ior = 1.22;\n    return Material(a, d, s, alpha, gloss, ior);\n}\n\n//----------Noise----------//\n//I got this from       \"https://www.shadertoy.com/view/ldjczd\"\nfloat whangHashNoise(uint u, uint v)\n{    \n    uint seed = (u*1664525u + v);\n    \n    seed  = (seed ^ 61u) ^(seed >> 16u);\n    seed *= 9u;\n    seed  = seed ^(seed >> 4u);\n    seed *= uint(0x27d4eb2d);\n    seed  = seed ^(seed >> 15u);\n    \n    float value = float(seed);\n    return value;\n}\n\n\nMaterial Grass(vec3 p)\n{\n    float noise = whangHashNoise(uint(p.x), uint(p.z));\n    vec3 a = vec3(0.0);\n    vec3 d;\n    \n    if (noise > 0.0)\n        d = vec3(0.0, 1.0, 0.0);\n        \n    else\n        d = vec3(0.0, 0.0, 0.0);\n        \n    vec3 s = vec3(0.0);\n    float alpha = 16.0;\n    float gloss = 0.0;\n    float ior = 1.0;\n    return Material (a, d, s, alpha, gloss, ior);\n}\n\nMaterial Checkerboard(vec3 p)\n{\n    vec3 a = vec3(mod(floor(p.x * 2.0) + floor(p.z * 2.0), 2.0)) * 0.5; //mod 2.0 with a floor will force it to either be 0.0(black) or 1.0(white)\n    vec3 d = vec3(a * 0.2);\n    vec3 s = vec3(0.2);\n    if (p.x >= 0.0)\n        a = vec3(1.0, 0.0, 0.0);\n    \n    float alpha = 100.0;\n    float gloss = 1.0;\n    float ior = 1.0;\n    return Material(a, d, s, alpha, gloss, ior);\n}\n\n//----------Signed Distance Fields----------//\n\nSurface SDFplane(vec3 p, vec3 color, Material mat) // Flat\n{\n    float noise = whangHashNoise(uint(p.x), uint(p.z));\n    float d = noise + p.y + 1.0;\n    return Surface(d, color, mat);\n}\n\nSurface SDFsphere(vec3 p, float radius, vec3 move, vec3 color, Material mat)\n{\n    float d = length(p - move) - radius;    \n    return Surface(d, color, mat);\n}\n\nSurface minObjectDistance(Surface obj1, Surface obj2)\n{\n    if (obj1.sd < obj2.sd)\n        return obj1;        \n    return obj2;\n}\n\nSurface map(vec3 p)\n{\n    Material Colorb;\n    Surface d;\n    Surface sphere = SDFsphere(p, 1.5, vec3(0.0, 0.0, -5.0), vec3(0.0), Black());\n    \n    return minObjectDistance(sphere, SDFplane(p, vec3(0.0), Grass(p)));\n}\n\n//----------Normals----------//\nvec3 calcNormal(vec3 p)\n{\n    vec2 e = vec2(1.0, -1.0) * 0.0001;    \n    return normalize (e.xyy * map(p + e.xyy).sd +\n                      e.yyx * map(p + e.yyx).sd +\n                      e.yxy * map(p + e.yxy).sd +\n                      e.xxx * map(p + e.xxx).sd);\n}\n\n//----------Ray Marching Methods----------//\nSurface rayMarch(inout vec3 ro, inout vec3 rd)\n{\n    float depth = nearPlane; //Starting depth\n    Surface d;\n\n    for(int i = 0; i < MAX_RAYMARCH_STEPS; i++)\n    {\n        d = map(ro + rd * depth); // Calculates the SDF\n        depth += d.sd;// adds the SDF to the length of the ray\n        \n        if (d.sd < nearPlane || depth > farPlane)\n            break;\n    }   \n    d.sd = depth;\n    return d;\n}\n\nfloat softShadow(vec3 fragPos, vec3 lightPos)\n{\n    float res = 1.0;\n    float depth = 0.01; //Artifacts appear if you start lower\n    vec3 lightDir = normalize(lightPos - fragPos);\n    \n    for (int i = 0; i < MAX_RAYMARCH_STEPS; i++)\n    {\n        float d = map(fragPos + lightDir * depth).sd;\n        res = min(res, (d * 3.0) / depth);\n        depth += d;\n        \n        if (d < nearPlane || depth > 25.0) //the lower limit of \"d\" needs to be lower than the one in the rayMarch function to avoid having a streak of light on overlapping shadows.\n            break;\n    }\n    return clamp(res, 0.02, 1.0 ); //clamps the res value between nonzero numbers so it doesn't black out everything\n}\n\nfloat AmbientOcclusion(vec3 fragPos, vec3 normal)\n{\n    float occ = 0.0;\n    float weight = 1.0;\n    for(int i = 0; i < 8; i++)\n    {\n        float len = 0.01 + 0.02 * float(i * i);\n        vec3 p = fragPos + normal * len;\n        float dist = map(p).sd;\n        occ += (len - dist) * weight;\n        weight *= 0.85;\n    }\n    return 1.0 - clamp(0.6 * occ, 0.0, 1.0);\n}\n\n//----------BRDF (Blinn Phong)----------//\nvec3 BlinnPhong(vec3 normal, vec3 lightPos, vec3 fragPos, Material mat)\n{ \n    //ambient\n    float occ = AmbientOcclusion(fragPos, normal);\n    vec3 ambient = mat.ambientCol;\n    //return vec3(0.9) * occ; //Occlusion test\n    \n    //diffuse\n    vec3 lightDir = normalize(lightPos - fragPos);\n    float diff = max(dot(normal, lightDir), 0.0);\n    vec3 diffuse = diff * mat.diffCol;\n    \n    //specular with normalization\n    vec3 reflectDir = reflect(-lightDir, normal);\n    vec3 viewDir = normalize(camera - fragPos);\n    vec3 halfwayDir = normalize(lightDir + viewDir);\n    float spec = max(dot(normal, halfwayDir), 0.0);\n    spec = pow(spec, mat.alpha) * ((mat.alpha + 2.0) / (4.0 * PI * (2.0 - exp(-mat.alpha/2.0))));\n    vec3 specular = spec * mat.specCol;\n    \n    //phong\n    return (ambient*occ + diffuse + specular*occ);\n}\n\nvec3 reflectBP(vec3 normal, vec3 lightPos, vec3 fragPos, Material mat, vec3 reflectDir)\n{\n    //ambient\n    vec3 ambient = mat.ambientCol;\n    \n    //diffuse\n    vec3 lightDir = normalize(lightPos - fragPos);\n    float diff = max(dot(normal, lightDir), 0.0);\n    vec3 diffuse = diff * mat.diffCol;\n    \n    //specular with normalization\n    vec3 viewDir = normalize(camera - fragPos);\n    vec3 halfwayDir = normalize(lightDir + viewDir);\n    float spec = max(dot(reflectDir, halfwayDir), 0.0);\n    spec = pow(spec, mat.alpha) * ((mat.alpha + 2.0) / (4.0 * PI * (2.0 - exp(-mat.alpha/2.0))));\n    vec3 specular = spec * mat.specCol;\n    \n    return ambient + diffuse + specular;\n}\n\n//----------Anti-Aliasing----------//\n// Takes four evenly spaced rotated supersamples in each pixel\nvec2 RGSS(int num)\n{\n    if (num == 0) return vec2(0.125, 0.375);\n    if (num == 1) return vec2(-0.125, -0.375);\n    if (num == 2) return vec2(0.375, -0.125);\n    else return vec2(-0.375, 0.125);  \n}\n\nfloat dielectricFresnel(vec3 normal, vec3 rd, Material object)\n{\n    float NdotV = dot(normal, -rd);\n    float fresnel = clamp(pow(1.0 - NdotV, 5.0), 0.005, 1.0);\n    float k = pow(1.0 - object.ior, 2.0) / pow(1.0 + object.ior, 2.0);\n    fresnel += (1.0 - fresnel) * k;\n    fresnel = fresnel + (1.0 - fresnel) * pow(NdotV, 5.0) * pow(1.0 - object.gloss, 2.0);\n    return fresnel;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 background;\n    Surface d;\n    int i;\n    for (i = 0; i < aaON; i++) //You can turn Anti-aliasing on/off by changing the condition to \"aaON/aaOFF\"\n    {\n        vec2 uv = ((fragCoord + RGSS(i)) - 0.5 * iResolution.xy)/iResolution.y; //aspect ratio       \n        vec3 rd = normalize(vec3(uv, -1.0)); //Turns the uv into a 3D vector by making it point outwards\n        background = vec3(0.65, 0.85, 1.0) + uv.y * 0.75;\n        background = mix(vec3(0.9, 0.65, 0.55), vec3(0.65, 0.85, 1.0), uv.y + 0.55);\n        //background = vec3(0.0);\n\n        d = rayMarch(camera, rd);\n        Material shine = d.mat;\n        float attenuation = 1.0 / (attConst + attLinear * d.sd + attQuad * d.sd * d.sd); //inverse square law\n        vec3 fragPos = camera + rd * d.sd;\n        vec3 normal = vec3(calcNormal(fragPos));\n        vec3 reflectDir = reflect(rd, normal);\n        vec3 lightPos = vec3(-10.0, 20.0, 10.0);\n\n        if (d.sd <= farPlane)\n        {\n            float fresnel = dielectricFresnel(normal, rd, d.mat);\n            vec3 ref = fragPos + normal * 0.005;   \n            \n            //Reflections - Adds the reflections to the colors before running through the BRDF\n            for (int i = 0; i < 1; i++)\n            {\n                Surface bounce = rayMarch(ref, reflectDir);\n                if (bounce.sd <= farPlane)\n                    shine = Material(shine.ambientCol + bounce.mat.ambientCol * fresnel, shine.diffCol + bounce.mat.diffCol * fresnel, shine.specCol + bounce.mat.specCol * fresnel, shine.alpha, shine.gloss, shine.ior);\n\n                else\n                    shine = Material(shine.ambientCol + background * fresnel, shine.diffCol + background * fresnel, shine.specCol + background * fresnel, shine.alpha, shine.gloss, shine.ior);                   \n            \n            }\n            \n            //Blinn-Phong + softshadows\n            vec3 b_phong = BlinnPhong(normal, lightPos, fragPos, shine);\n            float softShadow = softShadow(fragPos + normal * 0.003, lightPos);\n            col += b_phong * softShadow * attenuation ;            \n        }\n        else col += background; //Rays go into the v o i d ~\n    }\n    \n    col /= float(i);\n    col = mix(col, background, 1.0 - exp(-0.00001 * d.sd * d.sd * d.sd)); //fog\n    fragColor.rgb = pow(col.rgb, vec3(1.0/GAMMA));\n    }","name":"Image","description":"","type":"image"}]}