{"ver":"0.1","info":{"id":"flXyDs","date":"1648883848","viewed":63,"name":"Bilibili","username":"Lumos320","description":"Different shape combination based on SDF","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265\n//最大迭代次数\n#define Traymarch 128\n//阈值精度\n#define Precision .001\n#define R 1.;\n//全局光照系数\n#define Ka 0.6\n//diffuse光照系数\n#define Kd 0.7\n//抗锯齿\n#define AA 4\n//软阴影系数\n#define K 10.\n\nvec2 fixUV(in vec2 uv)\n{\n    return (2.*uv - iResolution.xy)/ min(iResolution.x,iResolution.y);\n}\n\nfloat sdfSphere(in vec3 p)\n{\n    return length(p) - R;\n}\n\nfloat sdfRect(in vec3 p, vec3 wh, float r)\n{\n    vec3 d = abs(p) - wh;\n    return length(max(d, 0.)) + min(max(d.x, max(d.y, d.z)),0.) - r;\n}\n\n//圆环 t:(半径，粗细)\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n//条状胶囊\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n//缺口圆环 sc:起始sin,cos\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nvec2 operate(vec2 a, vec2 b)\n{\n    return a.x<b.x ? a : b;\n}\n\n//拉伸\nvec4 opElongate( in vec3 p, in vec3 h )\n{\n    vec3 q = abs(p)-h;\n    return vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );\n}\n\n//返回最短距离和具体物体\nvec2 map(in vec3 p)\n{   \n    p.xz *= mat2(0.,1.,1.,0.);\n    vec2 d = vec2(sdfRect(p-vec3(0.,1.3,0.), vec3(1.3,.9,1.), .3),2.);\n    //对称图案坐标\n    vec3 q = vec3(abs(p.x),p.yz);\n    //拉伸圆环\n    // elongated torus\n    {\n        vec4 w = opElongate(p.xzy - vec3(0.,1.3,1.4), vec3(.9,.0,0.5) );\n        float t = w.w+sdTorus( w.xyz, vec2(.3,.05) );\n        d = operate(d, vec2(t, 3.) );\n    }\n    //eye\n    {\n        float e = sdCapsule(q,vec3(.8, 1.5, 1.3), vec3(.3, 1.7, 1.3), .1);\n        d = operate(d, vec2(e,3.));\n    }\n\n    //hair\n    {\n        float h = sdCapsule(q,vec3(.8, 3, .5), vec3(.6, 2.5, .5), .1);\n        d = operate(d, vec2(h,3.));\n    }\n    \n    //mouth\n    {\n        float angle = 90./180. * PI;\n        float m = sdCappedTorus(q * vec3(1.,-1.,1.) - vec3(.3,-1.2,1.3), vec2(sin(angle),cos(angle)), .3, .05);\n        d = operate(d, vec2(m,3.));\n    }\n\n    //leg\n    {\n        float l = sdCapsule(vec3(q.xy,abs(q.z)),vec3(1., .5, 1.0), vec3(1.5, .1, 1.3), .1);\n        d = operate(d, vec2(l,3.));\n    }\n\n    return d;\n}\n\nvec2 rayMarching(in vec3 ro, in vec3 rd)\n{\n    //射线走的距离\n    float t = 0.1;\n    float tmax = 40.;\n    vec2 res = vec2(-1.);\n    //和平面相交,射线向下走\n    if(rd.y < 0.){\n        float ty = -ro.y/rd.y;\n        tmax = min(tmax,ty);\n        res = vec2(ty,1.);\n    }\n    for(int i=0; i<Traymarch && t<tmax; ++i){\n        //当前位置\n        vec3 pos = ro + t*rd;\n        vec2 d = map(pos);\n        if(d.x < Precision) {\n            res = vec2(t, d.y);\n            break;\n        }\n        t += d.x;\n    }\n    return res;\n}\n\n//SDF的法向量\nvec3 calcNormal( in vec3  p ) \n{\n    const float h = 0.0001; // 步长\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ).x + \n                      k.yyx*map( p + k.yyx*h ).x + \n                      k.yxy*map( p + k.yxy*h ).x + \n                      k.xxx*map( p + k.xxx*h ).x);\n}\n\n//摄像机变换矩阵\nmat3 setCamera(vec3 target, vec3 cpos, float theta)\n{\n    vec3 z = normalize(target - cpos);\n    //theta是y轴绕z旋转的角度，cp能确定相机上方向\n    vec3 cp = vec3(sin(theta),cos(theta),0.);\n    vec3 x = normalize(cross(z,cp));\n    vec3 y = cross(x,z);\n\n    return mat3(x,y,z);\n}\n\n//优化的软阴影\nfloat softshadow( in vec3 ro, in vec3 rd)\n{\n    float res = 1.0;\n    float ph = 1e20;\n    float tmin = .1;\n    float tmax = 10.;\n    for( float t=tmin; t<tmax; )\n    {\n        float h = map(ro + rd*t).x;\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, K*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\n// triangular signal\nvec2 tri( in vec2 x )\n{\n    vec2 h = fract(x*.5)-.5;\n    return 1.-2.*abs(h);\n}\n\n//反走样\nfloat checkersGrad( in vec2 uv, in vec2 ddx, in vec2 ddy )\n{\n    vec2 w = max(abs(ddx), abs(ddy)) + 0.01;    // filter kernel\n    vec2 i = (tri(uv+0.5*w)-tri(uv-0.5*w))/w;   // analytical integral (box filter)\n    return 0.5 - 0.5*i.x*i.y;                   // xor pattern\n}\n\nvec3 render(vec2 uv, in vec2 px, in vec2 py)\n{\n    vec3 color = vec3(0.);\n    \n    //摄像机位置\n    //vec3 ro = vec3(0.,0.,-2.);\n    vec3 ro = vec3(6.*cos(0.2*iTime), 2. , 6.*sin(0.2*iTime));\n\n    //鼠标控制时\n    if(iMouse.z > 0.1){\n        //鼠标(0,1) 旋转角度(0,2pi)\n        float theta = iMouse.x/iResolution.x * 2. * PI;\n        ro = vec3(6.*cos(0.2*theta), 2. , 6.*sin(0.2*theta));\n    }\n    \n    vec3 target = vec3(0.);\n    //摄像机变换矩阵\n    mat3 camera = setCamera(target, ro, 0.);\n    //焦距\n    float fl = 1.;\n    //方向要归一化\n    //ro是view坐标系原点，不用减\n    vec3 rd = normalize(camera * vec3(uv,fl));\n    vec2 t = rayMarching(ro,rd);\n    \n    //背景颜色\n    vec3 bgcolor = vec3(0.36, 0.51, 0.8);\n    color = bgcolor -rd.y * vec3(.1);\n\n    if(t.y > 0.){\n        //光线打到的位置\n        vec3 pos = ro + t.x*rd;\n        //球和平面分开计算法向量\n        vec3 normal = t.y<1.1 ? vec3(0.,1.,0.) : calcNormal(pos);\n        //设置一个光源\n        vec3 light = vec3(6., 4., 5.);\n        //漫反射\n        float diffuse = dot(normalize(light-pos), normal);\n        diffuse = clamp(diffuse,0.,1.);\n        //软阴影(能否看到光源)\n        float sd = softshadow(pos,normalize(light - pos));\n        diffuse *= sd;\n        //环境光\n        float ambi = Ka + Ka * dot(normal, vec3(0., 1., 0.));\n        vec3 ctmp = vec3(0.0);\n        //rect\n        if(t.y > 1.9 && t.y < 2.1){\n            ctmp = vec3(1.,1.,1.);\n        }\n        //圆环\n        else if(t.y > 2.9 && t.y < 3.1){\n            ctmp = vec3(0.,0.,0.);\n        }\n        //plane\n        else if(t.y > 0.9 && t.y < 1.1){\n            //ctmp = vec3(5.,1.,6.);\n            //格子棋盘\n            //vec2 grid = floor(pos.xz);\n            //ctmp = vec3(0.43) + 2. * mod(grid.x + grid.y,2.);\n            vec3 rdx = normalize(camera * vec3(px,fl));\n            vec3 rdy = normalize(camera * vec3(py,fl));\n            // 缩放的差距：rd/rd.y - rdx/rdx.y\n            vec3 ddx = ro.y * (rd/rd.y - rdx/rdx.y);\n            vec3 ddy = ro.y * (rd/rd.y - rdy/rdy.y);\n            //贴图坐标\n            ctmp = vec3(.1) + vec3(.1) * checkersGrad(pos.xz,ddx.xz,ddy.xz);\n        }\n        color = ambi * ctmp + diffuse * Kd;\n    }\n    //伽马校正<1\n    return sqrt(color);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    //vec2 uv = fixUV(fragCoord);\n    vec3 color = vec3(0.);\n    //抗锯齿\n    for(int i=0; i<AA; ++i){\n        for(int j=0; j<AA; ++j){\n            //偏移量在(0,1)\n            vec2 offset = 2. * (vec2(float(i),float(j))/float(AA) - 0.5);\n            vec2 uv = fixUV(fragCoord+offset);\n            vec2 dx = fixUV(fragCoord + vec2(1.,0.) + offset);\n            vec2 dy = fixUV(fragCoord + vec2(0.,1.) + offset);\n            color += render(uv, dx, dy);\n        }\n    }\n    //color归一化\n    fragColor = vec4(color/float(AA*AA),1.);\n}","name":"Image","description":"","type":"image"}]}