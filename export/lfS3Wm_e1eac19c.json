{"ver":"0.1","info":{"id":"lfS3Wm","date":"1706987255","viewed":85,"name":"RayTracing___","username":"guhler","description":"Simple ray tracer","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision mediump float;\nprecision mediump int;\n\nfloat positive_infinity = uintBitsToFloat(0x7F800000u);\n\nconst int MAX_RAY_DEPTH = 10;\nconst int RAY_ARRAY_SIDE_LEN = 6;\nconst int RAY_ARRAY_SIZE = RAY_ARRAY_SIDE_LEN * RAY_ARRAY_SIDE_LEN;\n\nconst uint LAMBERTIAN = 0u;\nconst uint METAL = 1u;\nconst uint DIELECTRIC = 2u;\n\nstruct viewport {\n    vec3 upper_left;\n    vec3 horizontal;\n    vec3 vertical;\n    vec3 dh;\n    vec3 dv;\n    uint width;\n    uint height;\n};\n\nstruct ray {\n    vec3 pos;\n    vec3 dir;\n};\n\nstruct material {\n    uint type;\n    vec3 col;\n    float refract_index;\n};\n\nstruct sphere {\n    vec3 pos;\n    float r;\n    material mat;\n};\n\nsphere[4] sphere_list = sphere[] (\n    sphere(vec3(0., 0., -10.), 1., material(LAMBERTIAN, vec3(.5, .0, .0), 1.)), \n    sphere(vec3(-2., 0., -4.), 1., material(METAL, vec3(.4, .4, 1.), 1.)), \n    sphere(vec3(1., 0., -4.), 1., material(DIELECTRIC, vec3(1., 1., 1.), 1.5)), \n    sphere(vec3(0., -200.5, -4.), 199.5, material(LAMBERTIAN, vec3(.08, .43, .08), 1.))\n);\n\n//function declarations\nviewport setup_viewport(vec3 cam, vec3 dir, vec3 up);\nray[RAY_ARRAY_SIZE] make_rays(vec3 cam, viewport vp, int x, int y);\nvec3 ray_color(ray r);\nfloat hit_sphere(ray r, sphere s);\nray scatter(material mat, vec3 pos, vec3 in_dir, vec3 normal);\nfloat reflectance(float cosine, float eta);\nvec3 random_vec3_unit(vec2 st);\nvec3 random_vec3(vec2 st);\nfloat random(vec2 st);\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    fragCoord.y = iResolution.y - fragCoord.y;\n    \n    vec3 cam = vec3(sin(iTime * .5), 0., 0.);\n    viewport vp = setup_viewport(cam, vec3(0., 0., -1.), vec3(0., 1., 0.));\n    \n    ray[RAY_ARRAY_SIZE] rays = make_rays(cam, vp, int(fragCoord.x), int(fragCoord.y));\n    vec3 avg_col = vec3(0.);\n    for (int i = 0; i < RAY_ARRAY_SIZE; i++) {\n        avg_col += ray_color(rays[i]);\n    }\n    avg_col /= float(RAY_ARRAY_SIZE);\n    fragColor = vec4(sqrt(avg_col), 1.);\n}\n\n//viewport setup_viewport(vec3 cam, vec3 dir, float angle) {\n//    \n//}\n\nviewport setup_viewport(vec3 cam, vec3 dir, vec3 up) {\n    float focal_length = 1.0;\n    dir = normalize(dir);\n    up = normalize(up);\n    \n    vec3 vertical = -1. * up;\n    vec3 horizontal = cross(dir, up) * \n        iResolution.x / iResolution.y;\n    \n    vec3 upper_left = cam + dir * focal_length \n        - horizontal / 2. - vertical / 2.;\n    \n    viewport vp = viewport(\n        upper_left, \n        horizontal, \n        vertical, \n        horizontal / iResolution.x, \n        vertical / iResolution.y, \n        uint(iResolution.x), \n        uint(iResolution.y)\n    );\n    return vp;\n}\n\nray[RAY_ARRAY_SIZE] make_rays(vec3 cam, viewport vp, int x, int y) {\n    vec3 pixel_upper_left = vp.upper_left + \n        float(x) * vp.dh + float(y) * vp.dv;\n    viewport v = viewport(\n        pixel_upper_left, \n        vp.dh, \n        vp.dv, \n        vp.dh / float(RAY_ARRAY_SIDE_LEN), \n        vp.dv / float(RAY_ARRAY_SIDE_LEN), \n        uint(RAY_ARRAY_SIDE_LEN), \n        uint(RAY_ARRAY_SIDE_LEN)\n    );\n    ray[RAY_ARRAY_SIZE] rays;\n    for (int i = 0; i < RAY_ARRAY_SIDE_LEN; i++) {\n        for (int j = 0; j < RAY_ARRAY_SIDE_LEN; j++) {\n            vec3 pos = v.upper_left + \n                (float(i) + 0.5) * v.dh + \n                (float(j) + 0.5) * v.dv;\n            rays[i + j * RAY_ARRAY_SIDE_LEN] = ray(cam, pos - cam);\n        }\n    }\n    return rays;\n}\n\n\nvec3 ray_color(ray r_in) {\n    vec3 col = vec3(1.);\n    ray r = r_in;\n    for (int i = 0; i < MAX_RAY_DEPTH; i++) {\n        float min_t = positive_infinity;\n        int min_index = 0;\n        for (int j = 0; j < sphere_list.length(); j++) {\n            float t = hit_sphere(r, sphere_list[j]);\n            min_t = min(min_t, t);\n            min_index = min_index * int(min_t != t) + j * int(min_t == t);\n        }\n        sphere sp = sphere_list[min_index];\n        float got_hit = float(!isinf(min_t));\n        min_t = isinf(min_t) ? 0. : min_t;\n\n        vec3 hit_point = r.pos + min_t * r.dir;\n        vec3 normal = (hit_point - sp.pos) / sp.r;\n\n        vec3 ray_col = sp.mat.col * got_hit;\n\n        float a = (normalize(r.dir).y + 1.) * 0.5;\n        vec3 sky = mix(vec3(1.), vec3(.5, .7, 1.), a) * (1. - got_hit);\n\n        col *= ray_col + sky;\n\n        r = scatter(sp.mat, hit_point, r.dir, normal);\n\n        if (!bool(got_hit)) {\n            break;\n        }\n    }\n    return col;\n}\n\nfloat hit_sphere(ray r, sphere s) {\n    vec3 oc = r.pos - s.pos;\n    float a = dot(r.dir, r.dir);\n    float half_b = dot(oc, r.dir);\n    float c = dot(oc, oc) - s.r * s.r;\n    float discriminant = half_b * half_b - a * c;\n    \n    if (discriminant < 0.)\n        return positive_infinity;\n    float sq = sqrt(discriminant);\n    float t = (-half_b - sq) / a;\n    t = float(t > .0001) * t + float(t <= .0001) * (-half_b + sq) / a;\n    return t > .0001 ? t : positive_infinity;\n}\n\nray scatter(material mat, vec3 pos, vec3 in_dir, vec3 outward_normal) {\n    vec3 in_dir_unit = normalize(in_dir);\n    bool front_face = dot(in_dir, outward_normal) > 0.;\n    vec3 normal = outward_normal * (float(!front_face) * 2. - 1.);\n\n    vec2 st = vec2(pos.x * pos.z, pos.y * pos.z);\n    \n    vec3 lambertian_dir = normal + random_vec3_unit(st);\n    \n    vec3 metal_dir = reflect(in_dir, normal);\n    \n    float cos_theta = min(dot(-1. * in_dir_unit, normal), 1.);\n    float eta = (mat.refract_index) * float(front_face) + \n        (1. / mat.refract_index) * float(!front_face);\n    vec3 dielect_dir = refract(in_dir_unit, normal, eta);\n    bool must_reflect = dot(dielect_dir, dielect_dir) == 0. || \n        reflectance(cos_theta, eta) > random(st);\n    dielect_dir = dielect_dir * float(!must_reflect) + metal_dir * float(must_reflect);\n    \n    \n    vec3 dir = float(mat.type == LAMBERTIAN) * lambertian_dir + \n        float(mat.type == METAL) * metal_dir + \n        float(mat.type == DIELECTRIC) * dielect_dir;\n    return ray(pos, dir);\n}\n\nfloat reflectance(float cosine, float eta) {\n    float r0 = (1. - eta) / (1. + eta);\n    r0 *= r0;\n    return r0 + (1. - r0) * pow((1. - cosine),5.);\n}\n\nvec3 random_vec3_unit(vec2 st) {\n    return normalize(random_vec3(st));\n}\n\nvec3 random_vec3(vec2 st) {\n    return vec3(2. * random(st) - 1., \n        2. * random(st * 24.2313) - 1., \n        2. * random(st * 64.2937) - 1.\n    );\n}\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n        vec2(12.9898,78.233)))*\n        43758.5453123);\n}","name":"Image","description":"","type":"image"}]}