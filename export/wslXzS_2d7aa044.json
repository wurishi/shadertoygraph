{"ver":"0.1","info":{"id":"wslXzS","date":"1551605564","viewed":79,"name":"reflection & heightmap test","username":"takahiroando","description":"test","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["reflection","raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"int MAX_TRACE = 270;\nfloat EPS = 0.00001;\nfloat GAMMA = 2.2;\nfloat FAR = 1400.0;\n\nfloat dsphere(vec3 p, vec3 c, float r) {\n  return length(p - c) - r;\n}\n\nvec2 opmin(vec2 d1, vec2 d2) {\n  return d1.x < d2.x ? d1 : d2;\n}\n\n// 2D Random\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat hground(vec2 xz) {\n  return -3.0 + 10.0 * (noise(xz * 0.125) - 0.25);\n}\n\nfloat dground(vec3 p) {\n  return p.y - hground(p.xz);\n}\n\nfloat hwater() {\n  float h = -3.0 + 2.0;\n  return h;\n}\n\nfloat dwater(vec3 p) {\n  return p.y - hwater();\n}\n\nvec3 oprep(vec3 p, float w) {\n  return mod(p, w) - 0.5 * w;\n}\n\nvec2 dscene(vec3 p) {\n  vec2 d = vec2(dground(p), 2);\n  d = opmin(d, vec2(dwater(p), 3));\n  float orgy = p.y;\n  p = oprep(p, 10.0);\n  p.y = min(p.y, orgy);\n  d = opmin(d, vec2(dsphere(p, vec3(1.0, 2.0, 1.0), 1.0), 0));\n  d = opmin(d, vec2(dsphere(p, vec3(-1.0, 1.0, -1.0), 1.0), 1));\n  return d;\n}\n\nvec2 trace(vec3 org, vec3 ray) {\n  vec3 p = org;\n  vec2 d = vec2(0.0);\n  for (int i = 0; i < MAX_TRACE; ++i) {\n    d = dscene(p);\n    if (abs(d.x) < EPS) {\n      break;\n    }\n    p += d.x * ray;\n  }\n  return vec2(length(p - org), d.y);\n}\n\nvec3 normal(vec2 d, vec3 org, vec3 ray) {\n  vec3 p = org + ray * d.x;\n  float d2 = dscene(p).x;\n  vec2 eps = vec2(EPS, 0.0);\n  return normalize(\n    vec3(dscene(p + eps.xyy).x, dscene(p + eps.yxy).x, dscene(p + eps.yyx).x) - d2\n  );\n}\n\nfloat diffuse(vec2 d, vec3 org, vec3 ray) {\n  vec3 light = vec3(-0.9, 0.1, 0.4) * 0.1;\n  vec3 light2 = vec3(0.3, 1.0, 0.1) * 0.1;\n  vec3 light3 = vec3(-0.3, 1.0, -0.1) * 0.1;\n  vec3 n = normal(d, org, ray);\n  return max(dot(n, light) + dot(n, light2), 0.03);\n}\n\nvec3 rshade(vec3 org, vec3 ray);\n\nvec3 shade(vec3 org, vec3 ray) {\n  vec2 d = trace(org, ray);\n  if (d.x > FAR) {\n    return vec3(0.0, 0.0, 1.0) * ray.y * 0.5;\n  } else if (d.y >= 3.0) {\n    return mix(vec3(0.1, 0.2, 1.0), rshade(org + ray * d.x, ray), 0.9);\n  } else if (d.y >= 2.0) {\n    return vec3(1.0, 0.5, 0.0) * diffuse(d, org, ray);\n  } else if (d.y >= 1.0) {\n    return vec3(1.0, 0.0, 0.0) * diffuse(d, org, ray);\n  } else if (d.y >= 0.0) {\n    return vec3(0.0, 1.0, 0.0) * diffuse(d, org, ray);\n  } else {\n    return vec3(0.0, 0.0, 0.0);\n  }\n}\n\nvec3 rshade(vec3 org, vec3 ray) {\n  ray.y *= -1.0;\n  vec2 d = trace(org, ray);\n  if (d.x > FAR || d.y >= 2.0) {\n    return vec3(0.0, 0.0, 0.0);\n  } else if (d.y >= 1.0) {\n    return vec3(1.0, 0.0, 0.0) * diffuse(d, org, ray);\n  } else if (d.y >= 0.0) {\n    return vec3(0.0, 1.0, 0.0) * diffuse(d, org, ray);\n  } else {\n    return vec3(0.0, 0.0, 0.0);\n  }\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 p2 = (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n  vec3 org = vec3(0.0, 1.0, 10.0 - 50.0 * iTime);\n  org.y = max(hwater(), hground(org.xz)) + 4.0;\n  vec3 lookat = org;\n  lookat.x = 0.0;\n  lookat.z -= 10.0;\n  vec3 camdir = normalize(lookat - org);\n  vec3 camr = cross(camdir, vec3(0.0, 1.0, 0.0));\n  vec3 camup = normalize(cross(camr, camdir));\n  vec3 ray = normalize(camdir + p2.x * camr + p2.y * camup);\n\n  fragColor = vec4(shade(org, ray), 1.0);\n  fragColor.rgb = pow(fragColor.rgb, vec3(1.0 / GAMMA));\n}\n","name":"Image","description":"","type":"image"}]}