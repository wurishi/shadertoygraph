{"ver":"0.1","info":{"id":"XtsBRs","date":"1513314052","viewed":567,"name":"Video Pixel Fractal","username":"KilledByAPixel","description":"Recursively zooming into pixels of a video (or image).","likes":12,"published":3,"flags":0,"usePreview":0,"tags":["2d","fractal","zoom","pixel","recursion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//////////////////////////////////////////////////////////////////////////////////\n// Video Pixel Fractal - Copyright 2017 Frank Force\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//////////////////////////////////////////////////////////////////////////////////\n\nconst float zoomSpeed\t\t\t= 0.3;\t// how fast to zoom (negative to zoom out)\nconst float zoomScale\t\t\t= 0.001;\t// how much to multiply overall zoom (closer to zero zooms in)\nconst int recursionCount\t\t= 2;\t// how deep to recurse\nconst float recursionFadeDepth\t= 0.0;\t// how deep to fade out\nconst int glyphSize\t\t\t\t= 64;\t// width & height of glyph in pixels\nconst float glyphMargin\t\t\t= 0.0;\t// how much to center the glyph in each pixel\nconst float brightness\t\t\t= 0.6;\n\n//////////////////////////////////////////////////////////////////////////////////\n// Precached values and math\n\nconst float glyphSizeF = float(glyphSize) + 2.0*glyphMargin;\nconst float glyphSizeLog = log(glyphSizeF);\nconst int powTableCount = 10;\nconst float gsfi = 1.0 / glyphSizeF;\nconst float powTable[powTableCount] = float[]( 1.0, gsfi, pow(gsfi,2.0), pow(gsfi,3.0), pow(gsfi,4.0), pow(gsfi,5.0), pow(gsfi,6.0), pow(gsfi,7.0), pow(gsfi,8.0), pow(gsfi,9.0));\nconst float e = 2.718281828459;\nconst float pi = 3.14159265359;\n\nfloat RandFloat(int i) { return (fract(sin(float(i)) * 43758.5453)); }\nint RandInt(int i) { return int(100000.0*RandFloat(i)); }\n\nvec3 HsvToRgb(vec3 c) \n{\n    float s = c.y * c.z;\n    float s_n = c.z - s * .5;\n    return vec3(s_n) + vec3(s) * cos(2.0 * pi * (c.x + vec3(1.0, 0.6666, .3333)));\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n// Color and image manipulation\n\nfloat GetRecursionFade(int r, float timePercent)\n{\n    if (r > recursionCount)\n        return timePercent;\n    \n    // fade in and out recusion\n    float rt = max(float(r) - timePercent - recursionFadeDepth, 0.0);\n    float rc = float(recursionCount) - recursionFadeDepth;\n    return rt / rc;\n}\n\nvec3 InitPixelColor() { return vec3(0); }\nvec3 CombinePixelColor(vec3 color, float timePercent, int i, int r, vec2 pos, ivec2 glyphPos, ivec2 glyphPosLast)\n{\n    /*vec3 myColor = vec3\n    (\n    \tmix(-0.2, 0.2, RandFloat(i + r + 419*(glyphPosLast.x + glyphPosLast.y))),\n    \tmix(0.0, 1.0, RandFloat(i + r + 929*(glyphPosLast.x + glyphPosLast.y))),\n        mix(0.0, 1.0, RandFloat(i + r + 316*(glyphPosLast.x + glyphPosLast.y)))\n    );\n\n    // combine with my color\n    float f = GetRecursionFade(r, timePercent);\n    color.x += myColor.x*f;;\n        color.y = max(color.y, myColor.y*f);\n    color.z = max(color.z, myColor.z*pow(f,1.5));\n    return color;*/\n    vec3 myColor = vec3(1.0, 1.0, 1.0);\n    //float f = GetRecursionFade(r, timePercent);\n    //color = mix(color, myColor, f);\n    return myColor;\n}\n\nvec3 FinishPixel(vec3 color, vec2 uv)\n{\n    // color wander\n    //color.x += (0.05*uv.y + 0.05*uv.x + 0.05*iTime);\n    \n    // convert to rgb\n    //color = HsvToRgb(color);\n    return color;\n}\n\nvec2 InitUV(vec2 uv)\n{\n\t// wave\n\t//uv.x += 0.01*sin(10.0*uv.y + 0.17*iTime);\n\t//uv.y += 0.01*sin(10.0*uv.x + 0.13*iTime);\n\t//uv.x += 0.1*sin(2.0*uv.y + 1.0*iTime);\n\t//uv.y += 0.1*sin(2.0*uv.x + 0.8*iTime);\n    return uv;\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n// Fractal functions\n\nvec3 GetGlyphPixel(ivec2 pos)\n{\n    vec2 uv = vec2(pos) + 0.5f;\n    uv /= float(glyphSize);\n    \n    vec4 c = texture(iChannel0,uv);\n    //return (c.x + c.y + c.z) / 3.0f;\n    return vec3(c);\n    \n}\n\nivec2 focusList[max(powTableCount, recursionCount) + 2];\nivec2 GetFocusPos(int i) { return focusList[i+2]; }\n\nivec2 CalculateFocusPos(int iterations)\n{\n    //return ivec2(RandInt(iterations) % glyphSize, RandInt(iterations) % glyphSize);\n    //return ivec2(glyphSize / 2);\n    return ivec2(glyphSize/4 + RandInt(iterations) % (glyphSize/2), glyphSize/4 +RandInt(iterations) % (glyphSize/2));\n}\n      \n// get color of pos, where pos is 0-1 point in the glyph\nvec3 GetPixelFractal(vec2 pos, int iterations, float timePercent)\n{\n\tivec2 glyphPosLast = GetFocusPos(-2);\n\tivec2 glyphPos =     GetFocusPos(-1);\n    \n\tbool isFocus = true;\n    ivec2 focusPos = glyphPos;\n    \n\tvec3 color = InitPixelColor();\n\tfor (int r = 0; r <= recursionCount + 1; ++r)\n\t{\n        //color = CombinePixelColor(color, timePercent, iterations, r, pos, glyphPos, glyphPosLast);\n        \n        //if (r == 1 && glyphPos == GetFocusPos(r-1))\n\t    //    color.z = 1.0; // debug - show focus\n           \n        // update pos\n        pos -= vec2(glyphMargin*gsfi);\n        pos *= glyphSizeF;\n\n        // get glyph and pos within that glyph\n        glyphPosLast = glyphPos;\n        glyphPos = ivec2(pos);\n\n        // check pixel\n        vec3 glyphValue = GetGlyphPixel(glyphPos);\n        //color.z *= glyphValue;\n        //glyphValue = pow(glyphValue, 2.0) + 0.2;\n        //glyphValue = pow(glyphValue, vec3(2.0)) + vec3(0.2);\n        glyphValue *= brightness;\n       \n        vec3 myColor = vec3(0.0, 0.0, glyphValue);\n        float f = GetRecursionFade(r, timePercent);\n        //color = mix(color, myColor, f);\n        color += glyphValue*f;//\n        \n        if (r > recursionCount)\n\t\t\treturn color;\n        \n\t\tif (pos.x < 0.0 || pos.y < 0.0)\n\t\t\treturn color;\n        \n        // next glyph\n\t\tpos -= vec2(floor(pos));\n        if (isFocus)\n        {\n        \tisFocus = isFocus && (glyphPosLast == focusPos);\n            focusPos = isFocus? GetFocusPos(r) : ivec2(-100);\n        }\n\t}\n}\n \n//////////////////////////////////////////////////////////////////////////////////\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// use square aspect ratio\n\tvec2 uv = fragCoord;\n\tuv = fragCoord / iResolution.y;\n\tuv -= vec2(0.5*iResolution.x / iResolution.y, 0.5);\n    uv = InitUV(uv);\n\t\n\t// get time \n\tfloat timePercent = iTime*zoomSpeed;\n\tint iterations = int(floor(timePercent));\n\ttimePercent -= float(iterations);\n\t\n\t// update zoom, apply pow to make rate constant\n\tfloat zoom = pow(e, -glyphSizeLog*timePercent);\n\tzoom *= zoomScale;\n    \n    // cache focus positions\n    for(int i = 0; i  < powTableCount + 2; ++i)\n      focusList[i] = CalculateFocusPos(iterations+i-2);\n    \n\t// get offset\n\tvec2 offset = vec2(0);\n\tfor (int i = 0; i < powTableCount; ++i)\n\t\toffset += ((vec2(GetFocusPos(i)) + vec2(glyphMargin)) * gsfi) * powTable[i];\n    \n\t// apply zoom & offset\n    vec2 uvFractal = uv * zoom + offset;\n\t\n\t// check pixel recursion depth\n\tvec3 pixelFractalColor = GetPixelFractal(uvFractal, iterations, timePercent);\n    pixelFractalColor = FinishPixel(pixelFractalColor, uv);\n    \n\t// apply final color\n\tfragColor = vec4(pixelFractalColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}