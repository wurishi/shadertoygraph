{"ver":"0.1","info":{"id":"mdf3WN","date":"1666146685","viewed":171,"name":"Stars Aligning","username":"ChunderFPV","description":"I'm still getting some mileage out of these number spirals.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["spiral","stars","fractions"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SCALE 40.0\n#define PI radians(180.0)\n#define TAU (PI*2.0)\n#define CS(a) vec2(cos(a), sin(a))\n#define PT(xy,r) max(0.0, 1.0-length(xy/r))\nvoid mainImage(out vec4 RGBA, in vec2 XY)\n{\n    float sec = 600.0; // num seconds between integers\n    vec2 R = iResolution.xy;\n    float my = (iMouse.y/R.y*2.0)-1.0; // mouse y\n    float z = (iMouse.z > 0.0) ? pow(1.0-abs(my), 2.0*sign(my)): 1.0; // zoom\n    vec2 sc = (XY-0.5*R)/R.y; // screen coords\n    vec3 c = vec3(0.04, 0.06, 0.12)/exp(length(sc)); // background color\n    sc *= SCALE*z; // apply scale & zoom\n    float t = (iTime*TAU)/sec; // time\n    t += TAU*sqrt(45.0); // starting value\n    float as = t*24.0; // angular speed\n    float zs = t*8.0; // zoom speed\n    float zt = abs(sin(zs)); // zoom time\n    float zt2 = zt*zt;\n    c *= zt2; // fade to black\n    vec3 stars = vec3(0);\n    float sm = pow(zt*1.5, 2.0)+0.72; // scale multiplier\n    float lim = 10.0; // loop limit\n    for(float i = 0.0; i < 1.0; i += 1.0/lim)\n    {\n        sc *= sm; // scale screen coords for next spiral\n        float r = round(length(sc)); // screen radius in integers\n        vec2 xy = sc-CS(as-t*sqrt(r*2.0))*r; // point coords\n        float w = max(0.5, length(fwidth(sc))); // point size\n        float p = PT(xy, w)*(1.0-i); // form points\n        stars += p*p*2.0; // add points & curve brightness\n    }\n    c += stars*max(vec3(1.0-zt2), texture(iChannel0, XY/R).rgb)*2.0; // blue noise\n    c *= c; // contrast\n    RGBA = vec4(exp(log(c)/2.2), 1.0);\n}","name":"Image","description":"","type":"image"}]}