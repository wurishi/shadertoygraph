{"ver":"0.1","info":{"id":"NlySWD","date":"1640662660","viewed":88,"name":"Hammer and sickle sketch","username":"Ciubix8513","description":"Just a quick sketch of a hammer and sickle using raymarching\nupdate: added camera movement\n\ntodo: better materials","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int maxSteps = 100;\nconst float minDist = 0.0;\nconst float maxDist = 100.0;\nconst float E = 0.0001;\n\nvec3 rayDir(float FOV, vec2 size,vec2 fragCoord)\n{\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(FOV)/2.0);\n    return normalize(vec3(xy,-z));\n}\nmat4 viewMat(vec3 eye,vec3 center,vec3 up)\n{\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f,up));\n    vec3 u = cross(s,f);\n    return mat4(vec4(s,0.0),vec4(u,0.0),vec4(-f,0.0),vec4(0.0,0.0,0.0,1.0));\n}\nmat4 rotMat(vec3 r)\n{\n    mat4 roll = mat4(\n    vec4(1,0,0,0),\n    vec4(0,cos(r.x),-sin(r.x),0),\n    vec4(0,sin(r.x),cos(r.x),0),\n    vec4(0,0,0,1));\n    mat4 pitch = mat4(\n    vec4(cos(r.y),0,sin(r.y) ,0),\n    vec4(0,1,0,0),\n    vec4(-sin(r.y),0,cos(r.y),0),\n    vec4(0,0,0,1));\n    mat4 yaw = mat4(\n    vec4(cos(r.z),-sin(r.z),0,0),\n    vec4(sin(r.z),cos(r.z),0,0),\n    vec4(0,0,1,0),\n    vec4(0,0,0,1));   \n    \n    return roll * pitch * yaw;    \n}\nvec3 rotDeg(vec3 v,vec3 r){return (vec4(v,0) * rotMat(radians(r))).xyz;}\n\nfloat Union(float a, float b){return min(a,b);}\nfloat Diff(float a, float b){return max(a,-b);}\n\nfloat Box(vec3 p, vec3 b, float r)\n{    \n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\nfloat Cylinder(vec3 p, float h, float r)\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat Handles(vec3 p)\n{\n \n  float Handle = Cylinder(rotDeg(p,vec3(0,0,30)) + vec3(0,2.5,0),.1,.5);\n   \n  vec3 p1 = rotDeg(p,vec3(0,0,-60)) - vec3(0,-1,1);   \n  float Handle1 = Cylinder(p1 + vec3(0,1,0),.1,1.5);\n  \n  return Union(Handle,Handle1);\n}\n\nfloat MetallicParts(vec3 p)\n{\n  float c1 = Cylinder(rotDeg(p,vec3(90,0,0)), 2.,.1);\n  float c2 = Cylinder(rotDeg(p,vec3(90,0,0)) - vec3(-.4,0,.1), 1.8,1.);\n  float Blade =  Diff(c1,c2);\n   \n  vec3 p1 = rotDeg(p,vec3(0,0,-60)) - vec3(0,-1,1);      \n  float box = Box(p1 - vec3(0,1,0),vec3(1,.5,.5),0.);\n  return Union(box,Blade);\n}\n\n\nfloat SceneSDF(vec3 p) \n{    \n   return Union(MetallicParts(p),Handles(p));\n}\n\nvec2 March(vec3 eye, vec3 dir,float minDist, float maxDist)\n{\n    float depth = minDist;\n    float mat = -1.;\n    for(int i = 0; i < maxSteps;i++)\n    {\n       vec3 p = eye + depth *dir;\n       float dst1 = Handles(p);\n       float dst2 = MetallicParts(p);\n       float dst;\n       if(dst1 < dst2)\n       {\n           dst = dst1;\n           mat = 1.;\n       }\n       else\n       {\n           dst = dst2;\n           mat =2.;\n       }\n       \n       if(dst < E)return vec2(depth,mat);\n       depth+= dst;\n       if(depth >= maxDist)return vec2(maxDist,-1);\n    }\n    return vec2(maxDist,-1);\n}\n\nvec3 estNorm(vec3 p)\n{   \n    return normalize(vec3(\n    SceneSDF(vec3(p.x + E,p.y,p.z)) - SceneSDF(vec3(p.x - E,p.y,p.z)),\n    SceneSDF(vec3(p.x ,p.y + E,p.z)) - SceneSDF(vec3(p.x ,p.y- E,p.z)),\n    SceneSDF(vec3(p.x ,p.y,p.z+E)) - SceneSDF(vec3(p.x,p.y,p.z - E))\n    ));\n}\n\n//Blinn - Phong lighting\nvec4 Light(vec3 eye, vec3 point, vec3 light)\n{\n    vec3 n = estNorm(point);\n    vec3 LightDifuse = vec3(1,0,0);\n    vec3 LightSpec = vec3(.5,0,0);\n    \n     float DifuseCnst = .5;\n    float SpecCnst = 1.0;\n    float Shininess = 15.0;\n    \n    vec3 lightDir = normalize(light - point);\n    \n       \n    float lightDot = dot(lightDir,n);\n    vec3 H = normalize( lightDir + normalize(eye - point)); \n    float ReflViewDot = dot(H,n) ;  \n    \n    vec3 Difuse = vec3(0);        \n    if(lightDot > 0.0)\n \n    Difuse = DifuseCnst * lightDot * LightDifuse;\n    \n    vec3 Spec = vec3(0);    \n    \n    if(ReflViewDot > 0.0)   \n    Spec = SpecCnst *pow(ReflViewDot,Shininess) * LightSpec;   \n    \n    return vec4(Difuse + Spec,0);\n    \n}\n\nvec4 Lighting(vec3 eye,vec3 point, vec4 baseColor)\n{\n    float ambient = 0.2;\n    float ambientInt = 1.0;      \n    return (baseColor * ambient * ambientInt) + \n    Light(eye,point,vec3(4.0*sin(iTime),2.0,4.0 * cos(iTime)));\n \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 eyeDir = rayDir(60.0,iResolution.xy,fragCoord);\n    float t = sin( iTime /2.) * .75;\n    \n    vec3 eye = vec3(10.0 * sin(t),0.0,10.0 * cos(t)); \n    vec3 dir = (viewMat(eye,vec3(0),vec3(0,1,0)) * vec4(eyeDir,0)).xyz;\n    vec2  dst = March(eye,dir,minDist,maxDist);\n    if(dst.x > maxDist - E){fragColor = vec4(0); return;}       \n    if(dst.y == 1.)\n    fragColor = Lighting(eye, eye+dir*dst.x,vec4(.44,.33,.23,1));    \n    else if(dst.y == 2.)\n    fragColor = Lighting(eye, eye+dir*dst.x,vec4(1,1,1,1));\n}","name":"Image","description":"","type":"image"}]}