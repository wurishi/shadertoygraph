{"ver":"0.1","info":{"id":"DsKfWw","date":"1698278727","viewed":61,"name":"Hex grid infinte-state CA","username":"laserbat","description":"Looks better in full screen. The main computation is done in \"Buffer A\" tab. Click to randomize all cells.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["feedback","cellularautomata"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SQRT_3 1.73205080757\n#define ZOOM 2.0\n\n// Colorization and output stuff here.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    // Transform coordinates to correctly display hexagonal geometry\n    vec2 coord = vec2((fragCoord.x*SQRT_3 + fragCoord.y) / 2.0, fragCoord.y) / ZOOM;    \n    int val = GET(coord, ivec2(0, 0));\n    \n    fragColor.r = float(val % D) / float(D);\n    val /= D;\n    fragColor.g = float(val % D) / float(D);\n    val /= D;\n    fragColor.b = float(val % D) / float(D);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Simple time-dependant noise function, for seeding CA\nfloat noise(in vec2 co){\n    int x = int(co.x * float(M));\n    int y = int(co.y * float(M));\n    int z = int(iDate.a);\n    int w = int(fract(iDate.a) * float(M));\n    int res = hash(x + hash(y + hash(z + hash(w))));\n    \n    return float(res % M);\n}\n\n\n// Main CA computation\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Randomize initial state on 0th frame or if mouse button is pressed\n    if (iFrame <= 0 || iMouse.z > 0.0) {\n        fragColor.x = noise(fragCoord/iResolution.xy);\n    } else {\n    \tivec2 d;\n        \n        int vals[7];\n        int hash = 0;\n\n        int i = 0, idx = 0, best = M;\n\n    \tfor(d.y = -1; d.y <= +1; d.y++)\n        \tfor(d.x = -1; d.x <= +1; d.x++){\n                // To turn Moore neighborhood into hexagonal one we simply ignore a pair of opposite corners\n                if((d.x == -1 && d.y == 1) || (d.x == 1 && d.y == -1)) continue;\n            \t\n                vals[i] = GET(fragCoord, d);\n                \n                // Not including central cell in `hash` seems to produce slightly more interesting results\n                if (d.x != 0 || d.y != 0)\n                    hash |= vals[i];\n                    \n                i += 1;\n             }\n        \n        // Different transformations on `hash` and `value` produce different results.\n        hash ^= (hash << 1) ^ (hash >> 1);\n\n        for(int i = 0; i < 7; i ++){\n            int value = vals[i];\n            \n            value ^= (value << 2) ^ (value >> 2) ^ hash;\n            value %= M;\n            \n            if(value <= best){\n                best = value;\n                idx = i;\n            }\n        }\n\n        fragColor.x = float(vals[idx]);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define swap(x, y) if (vals[x] > vals[y]) {int t = vals[y]; vals[y] = vals[x]; vals[x] = t;};\n#define GET(coord, offset) int(texelFetch(iChannel0, ivec2(mod(coord + vec2(offset) + iResolution.xy, iResolution.xy)), 0).x)\n\n#define D 256\n#define M (D * D * D)\n\nint hash(int x) {\n    x++;\n    x ^= x >> 17;\n    x *= 0xed5ad4bb;\n    x ^= x >> 11;\n    x *= 0xac4c1b51;\n    x ^= x >> 15;\n    x *= 0x31848bab;\n    x ^= x >> 14;\n    return x;\n}","name":"Common","description":"","type":"common"}]}