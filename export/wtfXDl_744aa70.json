{"ver":"0.1","info":{"id":"wtfXDl","date":"1682963524","viewed":74,"name":"universe shader version 2","username":"poipoi34","description":"universe shader version 2","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["universeshaderversion2"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define pi 3.1415\n\n\n\nvec2 N22(vec2 p)\n{\n \treturn vec2(fract( sin(p.x*1525.+p.y*5462.) * 2123.),fract( sin(p.x*4756.+p.y*7953.) * 3522.)  );  \n}\n\nvec3 N43(vec4 p)\n{\n    return vec3(fract( sin(p.x*1525.+p.y*5462.+p.x*2547.+p.z*4392.) * 2123.),\n                fract( sin(p.x*4237.+p.y*3750.+p.x*4683.+p.z*1358.) * 2882.),\n                fract( sin(p.x*1525.+p.y*1057.+p.x*3257.+p.z*4589.) * 4683.));\n}\n\nfloat N41(vec4 p)\n{\n    return fract(sin(p.x*1525.+p.y*5462.+p.z*2547.+p.w*4392.) * 2123.) + 0.5;\n}\n\nfloat N21(vec2 p)\n{\n \treturn fract(sin(p.x*1235.0+p.y*7651.0)*1681.0) + 0.5;   \n}\n\nfloat smoothf(float edge1,float edge2,float t)  //return f(t) where f(edge1)=0,f(edge2)=1\n{\n    \n    \n    t -= edge1,\n    t /= (edge2-edge1);\n    \n    \n    if (t>1.0)\n        return 1.0;\n    if (t<0.)\n        return 0.0;\n    \n    return t*t*(3.0-2.0*t);\n}\n\n\n\nfloat distPointSeg(vec2 p,vec2 p1,vec2 p2)\n{\n    if (p1.x != p2.x)\n    {\n        float m = (p1.y-p2.y)/(p1.x-p2.x);\n        float c = -m*p1.x + p1.y;\n        float projection = dot( p-p1, p2-p1)/length(p2-p1);\n        \n        if (projection > length(p2-p1) ) \n            return length(p-p2);\n        if (projection < 0.0)\n            return length(p-p1);\n        else\n        return (abs(p.y-m*p.x - c)/(sqrt(1.0+m*m)));\n    }\n    else\n    {\n        if (p.y> min(p1.y,p2.y) && p.y < max(p1.y,p2.y))\n        \treturn abs(p.x-p1.x);\n        else\n            return(min(length(p-p1),length(p-p2)));\n    }\n}\n\nfloat distPointLine(vec2 p,vec2 p1,vec2 p2)\n{\n    if (p1.x != p2.x)\n    {\n        float m = (p1.y-p2.y)/(p1.x-p2.x);\n        float c = -m*p1.x + p1.y;\n        return (abs(p.y-m*p.x - c)/(sqrt(1.0+m*m)));\n    }\n    else\n        return abs(p.x-p1.x);\n}\n\nbool isIn(vec2 p,vec2 borderx,vec2 bordery)\n{\n \tif (p.x<borderx.x ||p.x>borderx.y ||p.y<bordery.x ||p.y>bordery.y )\n        return false;\n    return true;\n}\n\nvec2 coordPij(vec2 ID,float time)\n{\n    return sin(time * N22(ID ))*0.5+0.5 + ID;\n}\n\n\n\nvec4 shaderUniverse( vec2 uv, float deltaTime,vec3 univC)\n{\n    vec4 fragColor;\n    // Normalized pixel coordinates (from 0 to gridSize)\n    \n\n    \n    vec3 col = vec3 (0.,0.,0.0);\n    float lT = 0.01; //lineThickness\n    float lG = 0.04; //lineGradient\n    float pT = 0.03; //pointThickness\n    float pG = 0.08; //pointGradient\n    \n    float brightnessMax = 0.0;\n    \n    float time = iTime +deltaTime;\n    \n    \n    vec2 cellID = floor(uv);\n \n    \n    vec2 p = coordPij(cellID,time);//coord of point in the cell of uv\n    \n    \n    //go throught every pair of adjacent cell\n    for (int c1 = 0; c1 <= 9; c1++)\n    {\n        int i = c1/3-1;\n        int j = c1%3-1;\n        for (int c2 = c1+1; c2 <= 9 ; c2++)\n        {\n            \n            int i1 = c2/3-1;\n            int j1 = c2%3-1;\n            \n            //drawing lines between points of adjacent cells\n            if (abs(i-i1) < 2 && abs(j-j1) < 2)\n            {\n                float d = distPointSeg(uv,coordPij(cellID + vec2(i1,j1),time),coordPij(cellID + vec2(i,j),time));\n                //float coeff = sin(iTime*N41(vec4(cellID + vec2(i1,j1),cellID + vec2(i,j))));\n                //coeff = coeff*coeff*coeff;\n                float coeff = smoothstep(1.0,0.5,length(coordPij(cellID + vec2(i1,j1),time)-coordPij(cellID + vec2(i,j),time)));\n                if ( d < lT+lG )\n                        brightnessMax = max(brightnessMax,smoothstep(lT+lG,lT,d) * coeff);\n                    }\n               \n            \n        }\n        //drawing point\n        float d = length(uv-coordPij(cellID + vec2(i,j),time));\n        if (d < pT+pG)\n            brightnessMax = max(brightnessMax, smoothstep(pT+pG,pT,d)*sin(N21(cellID + vec2(i,j))*iTime) );\n    }\n        \n    col = brightnessMax * univC;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n    return fragColor;\n}\n\nfloat intersectPlane(vec3 normal,vec3 A,vec3 ro,vec3 rd)\n{\n    //dot(ro + k*rd - A,normal) = 0\n    return  (-dot(ro,normal)+dot(A,normal)) /dot(rd,normal);\n}\n\nvec2 rotate(vec2 p,float t)\n{\n \treturn vec2(cos(t)*p.x + sin(t)*p.y, -sin(t)*p.x + cos(t)*p.y);   \n}\n\nvec3 rotateX(vec3 p, float t)\n{\n \treturn vec3(p.x,rotate(p.yz,t));   \n}\nvec3 rotateY(vec3 p, float t)\n{\n \tp.xz = rotate(p.xz,t);\n    return p;\n}\nvec3 rotateZ(vec3 p, float t)\n{\n \treturn vec3(rotate(p.xy,t),p.z);   \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = fragCoord/iResolution.xy*2.-1.;\n    \n    vec3 planeGaps = vec3 (0.0,0.0,5.0);\n    float timeGap = 100.;\n    \n    \n    \n    vec3 ro = vec3(0.,10.,iTime);\n    vec3 rd = normalize(vec3(uv,1.0));\n    rd = rotateY(rd,iTime*0.1);\n    \n    vec3 normal = vec3(0.,0.,-1.);\n    vec3 xPlane = vec3(1.,0.,0.);\n    vec3 yPlane = vec3(0.,1.,0.);\n    \n    vec3 centerPlane = vec3(0.,0.,0.);\n    \n    //centerPlane. y += iTime;\n    \n    float k=0.;\n    vec3 I = ro;\n    \n    float fogEffect = 0.95;\n    \n    vec4 color = vec4(0.,0.,0.,1.);\n    int it = 0;\n    while (length(color.xyz) < 0.3 && it <100)\n    {\n        centerPlane += planeGaps;\n        vec3 univC = vec3(float(it)*0.1,0.,1.);\n        k = intersectPlane(normal,centerPlane,ro,rd );\n        I = ro+rd*k;\n        if (k>0. && k<50.)\n    \t\tcolor = shaderUniverse(vec2(dot(I-centerPlane,xPlane), dot(I-centerPlane,yPlane)),timeGap*float(it),univC) * pow(fogEffect,k);\n        it++;\n    }\n    \n    fragColor = color;\n    \n}\n\n\n\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}