{"ver":"0.1","info":{"id":"clKGzt","date":"1684467016","viewed":107,"name":"Fork Glass Rod ","username":"mehow_one","description":"Basic emulation of optics through glass rods.","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["refraction","glass","optics"],"hasliked":0,"parentid":"DtSXzz","parentname":"Glass Rod Refraction"},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define R iResolution.x/iResolution.y\n#define PI 3.141528\n\n\nvec3 hsv(float h,float s,float v){return ((clamp(abs(fract(h+vec3(0.,.666,.333))*6.-3.)-1.,0.,1.)-1.)*s+1.)*v;}\n\nfloat map(float val, float inA, float inB, float outA, float outB) {\n  return (val - inA) / (inB - inA) * (outB - outA) + outA;\n}\n\nfloat fresnel(vec3 direction, vec3 normal, float power, bool invert) {\n    vec3 halfDirection = normalize( normal + direction );\n    float cosine = dot( halfDirection, direction );\n    float product = max( cosine, 0.0 );\n    float factor = invert ? 1.0 - pow( product, power ) : pow( product, power );\n    return factor;\n}\nvec4 remapShadows(vec4 color) {\n  float factor = 10.;\n  return vec4(\n    pow(color.x, factor),\n    pow(color.y, factor),\n    pow(color.z, factor),\n    color.w\n  );\n}\nfloat specular(vec3 eyeVector, vec3 worldNormal, vec3 light, float shininess, float diffuseness) {\n  vec3 normal = worldNormal;\n  vec3 lightVector = normalize(-light);\n  vec3 halfVector = normalize(eyeVector + lightVector);\n  float NdotL = dot(normal, lightVector);\n  float NdotH =  dot(normal, halfVector);\n  float kDiffuse = max(0.0, NdotL);\n  float NdotH2 = NdotH * NdotH;\n  float kSpecular = pow(NdotH2, shininess);\n  return kSpecular + kDiffuse * diffuseness;\n}\n\n\nvec3 dispersion(vec2 pos,vec3 rd,vec3 normal,vec2 uv){\n    \n    \n    float uIor = 1./1.488;\n    vec3 color = vec3(0.0);\n    vec3 eye = rd;\n    float uChromaticAberration = .8155;\n    float uRefractPower = .025;\n    int LOOP = 8;\n    for (int i = 0; i < LOOP; i++) {\n    float slide = (float(i) / float(LOOP)) * 0.425;\n      vec3 refractVec = mix(normal, rd, uIor);\n      float r = texture(iChannel1, uv + refractVec.xy * (uRefractPower + slide * 1.0) * uChromaticAberration).x * 0.5;\n      float y = (texture(iChannel1, uv + refractVec.xy * (uRefractPower + slide * 1.0) * uChromaticAberration).x * 2.0 +\n                 texture(iChannel1, uv + refractVec.xy * (uRefractPower + slide * 1.0) * uChromaticAberration).y * 2.0 -\n                 texture(iChannel1, uv + refractVec.xy * (uRefractPower + slide * 1.0) * uChromaticAberration).z) / 6.0;\n      float g = texture(iChannel1, uv + refractVec.xy * (uRefractPower + slide * 2.0) * uChromaticAberration).y * 0.5;\n      float c = (texture(iChannel1, uv + refractVec.xy * (uRefractPower + slide * 2.5) * uChromaticAberration).y * 2.0 +\n             texture(iChannel1, uv + refractVec.xy * (uRefractPower + slide * 2.5) * uChromaticAberration).z * 2.0 -\n             texture(iChannel1, uv + refractVec.xy * (uRefractPower + slide * 2.5) * uChromaticAberration).x) / 6.0;\n      float b = texture(iChannel1, uv + refractVec.xy * (uRefractPower + slide * 3.0) * uChromaticAberration).z * 0.5;\n      float p = (texture(iChannel1, uv + refractVec.xy * (uRefractPower + slide * 1.0) * uChromaticAberration).z * 2.0 +\n             texture(iChannel1, uv + refractVec.xy * (uRefractPower + slide * 1.0) * uChromaticAberration).x * 2.0 -\n             texture(iChannel1, uv + refractVec.xy * (uRefractPower + slide * 1.0) * uChromaticAberration).y) / 6.0;\n\n      float re = r + (2.0*p + 2.0*y - c)/3.0;\n      float gr = g + (2.0*y + 2.0*c - p)/3.0;\n      float bl = b + (2.0*c + 2.0*p - y)/3.0;\n\n      color.r += re;\n      color.g += gr;\n      color.b += bl;\n      //color += remapShadows(vec4(color,1.)).rgb*.000125;\n  \n}\n    color /= float(LOOP);\n    \n    return color;\n    \n}\n\nvec4 sampleBackground(vec3 normal, sampler2D bg) {\n  // x = rho sin(phi) cos(theta)\n  // y = rho cos(phi)\n  // z = rho sin(phi) sin(theta)\n  // rho = 1 after normalization\n  float phi = acos(normal.y);\n  float sinPhi = sin(phi);\n  float theta =\n    abs(sinPhi) > 0.0001\n      ? acos(normal.x / sinPhi)\n      : 0.;\n  vec2 coord = vec2(\n    map(theta, 0., PI, 0., 1.),\n    map(phi, 0., PI, 1., 0.)\n  );\n    \n  return texture(bg, coord);\n}\n\n\n\nfloat lambert(vec3 normal, vec3 lightPos)\n{\n\treturn max(dot(normal, lightPos), 0.05);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (1.0*fragCoord - iResolution.xy)/iResolution.y;\n    vec3 rd = vec3(0., 0.0, -1.0);\n    vec2 uv = fragCoord/iResolution.xy;\n    // define  \"glass rods\" and normals\n    float rod_x = fract(p.x * 12.0)*2.-1.;\n    float rod_z = sqrt(1.0 - rod_x*rod_x);\n    vec3 n = normalize(vec3(rod_x, 0.0, -rod_z));   \n    \n    vec3 lpos = normalize(vec3(0.5, -0.5, 1.0));\n    vec3 lcol = vec3(1.);\n    \n    float lambert = pow(lambert(n,lpos),1.);\n    float specularLight = specular(rd, n, lpos, 80., 10.);\n    vec3 reflectedDir = normalize(reflect(rd, n));\n    vec4 diffuseColor = sampleBackground(n, iChannel1);\n    vec4 reflectionColor = remapShadows(sampleBackground(reflectedDir, iChannel0));\n    float fresnel = fresnel(rd, n, 8.,true);\n    float fresnelStrength = 0.995;\n    float reflectionStrength = 0.525;\n    float reflectionAmount = reflectionStrength + fresnelStrength * fresnel;\n        \n    vec3 color = dispersion(p/R,rd,n,uv);\n    color += specularLight*diffuseColor.rgb*.0125;\n    color += reflectionAmount * reflectionColor.rgb;\n    color += lambert;\n    color = pow(color,vec3(1./1.222));\n    fragColor = vec4(color,1.);\n}\n\n\n\n\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define C(c) U.x-=.5; O+= char(U,64+c)\n\nmat2 rotate(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvec4 char(vec2 p, int c) \n{\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1);\n\treturn textureGrad( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/32.),dFdy(p/32.) );\n}\n\nvoid mainImage( out vec4 O, vec2 frag )\n{\n    O = vec4(0.0);\n    \n    vec2 uv = frag/iResolution.y;\n    uv -= .5;\n    uv.x -= .4;\n    uv.x += sin(iTime*.25*6.2830)*.5;\n    //uv *= rotate(iTime*.25*6.2830);\n    //uv += .5;\n    float FontSize = 84.;\n    vec2 position = vec2(-.8,-0.15);\n    \n    vec2 U = ( uv - position +.5)*64.0/FontSize;\n    C(1);//C(5);C(12);C(12);C(15);C(-32);C(23);C(15);C(18);C(12);C(4);C(-31);\n    O.x = smoothstep(0.4,0.9,O.x);\n    O = O.xxxx+texture(iChannel1,frag/iResolution.y);\n}","name":"Buffer A","description":"","type":"buffer"}]}