{"ver":"0.1","info":{"id":"NlcGz2","date":"1636348142","viewed":402,"name":"TimelordQ's Matrix Rain v1.0","username":"TimelordQ","description":"Based on Rainbox matrix, this integrates comments from the original and a return to the green to create a more authentic Matrix like experience. ","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["color","glsl","bitmap","font","rainbow","matrix"],"hasliked":0,"parentid":"3lBBWG","parentname":"rainbow matrix"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nprecision mediump float;\n\nfloat random(vec2 v) {\n    return fract(sin(v.x * 32.1231 - v.y * 2.334 + 13399.2312) * 2412.32312);\n}\nfloat random(float x, float y) {\n    return fract(sin(x * 32.1231 - y * 2.334 + 13399.2312) * 2412.32312);\n}\nfloat random(float x) {\n    return fract(sin(x * 32.1231 + 13399.2312) * 2412.32312);\n}\n\nfloat hue2rgb(float f1, float f2, float hue) {\n    if (hue < 0.0)\n        hue += 1.0;\n    else if (hue > 1.0)\n        hue -= 1.0;\n    float res;\n    if ((6.0 * hue) < 1.0)\n        res = f1 + (f2 - f1) * 6.0 * hue;\n    else if ((2.0 * hue) < 1.0)\n        res = f2;\n    else if ((3.0 * hue) < 2.0)\n        res = f1 + (f2 - f1) * ((2.0 / 3.0) - hue) * 6.0;\n    else\n        res = f1;\n    return res;\n}\nvec3 hsl2rgb(vec3 hsl) {\n    vec3 rgb;\n    \n    if (hsl.y == 0.0) {\n        rgb = vec3(hsl.z); // Luminance\n    } else {\n        float f2;\n        \n        if (hsl.z < 0.5)\n            f2 = hsl.z * (1.0 + hsl.y);\n        else\n            f2 = hsl.z + hsl.y - hsl.y * hsl.z;\n            \n        float f1 = 2.0 * hsl.z - f2;\n        \n        rgb.r = 0.0; // hue2rgb(f1, f2, hsl.x + (1.0/3.0));\n        rgb.g = cos( hue2rgb(f1, f2, hsl.x ));\n        rgb.b = 0.0; // hue2rgb(f1, f2, hsl.x - (1.0/3.0));\n    }   \n    return rgb;\n}\n\nfloat character(float i) {    \n     return i<15.01? floor(random(i)*32768.) : 0.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 S = 15. * vec2(3., 2.);\n    vec2 coord = vec2(\n        fragCoord.x / iResolution.y,\n        fragCoord.y / iResolution.y + (iResolution.y - iResolution.x) / (9. * iResolution.y)\n    );\n    vec2 c = floor(coord * S);\n\n    float offset = random(c.x) * S.x;\n    float speed = random(c.x * 3.) * 1. + 0.2;\n    float len = random(c.x) * 15. + 10.;\n    float u = 1. - fract(c.y / len + iTime * speed + offset) * 2.;\n\n    float padding = 2.;\n    vec2 smS = vec2(3., 5.);\n    vec2 sm = floor(fract(coord * S) * (smS + vec2(padding))) - vec2(padding);\n    float symbol = character(floor(random(c + floor(iTime * speed)) * 15.));\n    bool s = sm.x < 0. || sm.x > smS.x || sm.y < 0. || sm.y > smS.y ? false\n             : mod(floor(symbol / pow(2., sm.x + sm.y * smS.x)), 2.) == 1.;\n\n    vec3 curRGB = hsl2rgb(vec3(c.x / S.x, 1., 0.5));\n    if( s )\n    {\n        if( u > 0.9 )\n            {\n            curRGB.r = 1.0;\n            curRGB.g = 1.0;\n            curRGB.b = 1.0;\n            }\n        else\n            curRGB = curRGB * u;\n    }\n    else\n        curRGB = vec3( 0.0, 0.0, 0.0 );\n\n    fragColor = vec4(curRGB.x, curRGB.y, curRGB.z, 1.0);\n}","name":"Image","description":"","type":"image"}]}