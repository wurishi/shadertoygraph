{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"\nfloat cell_size=5.0;\nfloat cull_dist=30.0;\nfloat zoom=1.8;\n\nvec2 rotate(float angle, vec2 v)\n{\n    return vec2(cos(angle) * v.x + sin(angle) * v.y, cos(angle) * v.y - sin(angle) * v.x);\n}\n\nfloat hash(float n)\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise(vec2 p)\n{\n    return hash(p.x + p.y*57.0);\n}\n\nfloat smoothNoise1(float p)\n{\n    float p0 = floor(p + 0.0);\n    float p1 = floor(p + 1.0);\n    return mix(hash(p0), hash(p1), fract(p));\n}\n\nfloat sceneDist(vec3 p, out vec2 tc)\n{\n    p.xy=rotate(cos(p.z*0.2)*0.8+sin(p.z*0.07),p.xy);\n    if(-p.x>p.y)\n        p.xy=vec2(p.y,-p.x);\n    if(p.x<p.y)\n        p.xy=vec2(p.y,p.x);\n    p.x-=1.6+cos(p.z*0.06)*0.5+cos(p.z*0.25)*0.5;\n    tc.x=p.z;\n    tc.y=atan(p.y,p.x);\n    return length(p.xy)-0.5+cos(tc.y*30.0)*0.004+cos(tc.x*2.0)*0.002;\n}\n\n// Simplified scene, for when detail isn't necessary.\nfloat sceneDist2(vec3 p)\n{\n    p.xy=rotate(cos(p.z*0.2)*0.8+sin(p.z*0.07),p.xy);\n    if(-p.x>p.y)\n        p.xy=vec2(p.y,-p.x);\n    if(p.x<p.y)\n        p.xy=vec2(p.y,p.x);\n    p.x-=1.6+cos(p.z*0.06)*0.5+cos(p.z*0.25)*0.5;\n    return length(p.xy)-0.5;\n}\n\nvec3 sceneNorm(vec3 p)\n{\n    vec2 eps=vec2(1e-3,0.0);\n    vec2 tc;\n    float c=sceneDist(p,tc);\n    return normalize(vec3(sceneDist(p+eps.xyy,tc)-c,sceneDist(p+eps.yxy,tc)-c,sceneDist(p+eps.yyx,tc)-c));\n}\n\n// Extract normal using the simplified version of the scene.\nvec3 sceneNorm2(vec3 p)\n{\n    vec2 eps=vec2(1e-3,0.0);\n    float c=sceneDist2(p);\n    return normalize(vec3(sceneDist2(p+eps.xyy)-c,sceneDist2(p+eps.yxy)-c,sceneDist2(p+eps.yyx)-c));\n}\n\n// Return a light position, which has been snapped to the scene surface.\nvec3 lightPositionForCell(float cell)\n{\n    vec3 p=vec3(cos(cell)*2.0,sin(cell*10.0)*-2.0,(cell+0.5)*cell_size);\n    vec3 n=sceneNorm2(p);\n    float d=sceneDist2(p);\n    p-=n*d;\n    return p+n*0.3;\n}\n\nvec3 tonemap(vec3 c)\n{\n    return c/(c+vec3(0.25));\n}\n\nfloat codeTex(vec2 p)\n{\n    p.x=mod(p.x,256.0);\n    float f=pow(clamp(smoothNoise1(p.x*16.0)+0.3,0.0,1.0),16.0)*0.75;\n    return 1.0-(1.0-smoothstep(0.04,0.05,abs(p.y-0.4)))*f*step(0.6,fract(p.x*0.1));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time=iTime;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv=uv*2.0-vec2(1.0);\n    uv.y*=iResolution.y/iResolution.x;\n    uv*=1.2;\n    vec2 coord=uv;\n    vec3 ro=vec3(0.0,7.0,-time*1.0);\n    vec3 rd=normalize(vec3(coord,-1.0*zoom));\n    rd.yz=rotate(0.7,rd.yz);\n\n    // Create the background dots.\n    {\n        vec2 bc=floor(coord.xy*9.0);\n        vec2 bp=fract(coord.xy*9.0);\n        fragColor.rgb = 10.3*vec3(0.01,0.01,0.02)*\n            (1.0-smoothstep(0.0,0.2,distance(bp,vec2(0.5))))*pow(0.5+0.5*cos(time*0.2+bc.y*9.5+bc.x*17.0),128.0);\n    }\n\n    // Raymarch the scene.\n    vec2 tc=vec2(0.0);\n    float t=2.0;\n    for(int i=0;i<80;i+=1)\n    {\n        vec3 rp=ro+rd*t;\n        vec3 lp = lightPositionForCell(floor(rp.z/cell_size));\n        float d=min(sceneDist(rp,tc), distance(lp,rp)-0.4)*0.75;\n        if (abs(d)<1e-4)\n            break;\n        t+=d;\n        if(t>cull_dist)\n            break;\n    }\n\n    // Accumulate glow from the orbs.\n    vec3 rp=ro+rd*t;\n    vec3 glow=vec3(0.0);\n    float cell=floor(ro.z/cell_size);\n    for(int i=0;i<6;i+=1)\n    {\n        vec3 lp=lightPositionForCell(cell-float(i));\n        vec3 lpn=sceneNorm(lp);\n        vec3 p=lp-ro;\n        p.yz=rotate(-0.7,p.yz);\n        vec2 pp=p.xy/-p.z*zoom;\n        if(p.z<0.0)\n            glow+=(1.0-smoothstep(0.0,40.0,-p.z))*\n            0.05*vec3(0.6,0.8,1.0)*vec3(pow(1.0-smoothstep(0.0,0.3,distance(coord,pp)),2.0))*pow(max(0.0,0.5+0.5*dot(lpn,-rd)),2.0);\n    }\n\n    vec3 dc=vec3(1.0)*0.04*codeTex(tc);\n\n    float lightscale=mix(0.85,1.0,0.5+0.5*cos(time*32.0));\n\n    if(t<cull_dist)\n    {\n        // Shade the scene surface.\n        vec3 rn=sceneNorm(rp);\n        fragColor.rgb=dc*mix(vec3(0.04),vec3(0.2,0.2,0.22),max(0.0,dot(rn,normalize(vec3(3.0,1.0,1.0)))));\n\n        for(int j=-1;j<=1;j+=1)\n        {\n            vec3 lp=lightPositionForCell(floor(rp.z/cell_size)+float(j));\n            if(distance(lp,rp)<0.41)\n            {\n                fragColor.rgb+=lightscale*2.0*vec3(0.3,0.7,1.0)*mix(0.1,1.0,pow(1.0-dot(normalize(rp-lp),-rd),1.0));\n            }\n            else\n            {\n                vec3 ld=normalize(lp-rp);\n                fragColor.rgb+=lightscale*60.0*dc*vec3(0.3,0.7,1.0)*vec3(max(0.0,dot(ld,rn)))*pow(max(0.0,1.0-distance(rp,lp)*0.2),4.0);\n            }\n        }\n    }\n\n    // Create the wires.\n    {\n        float mask=1.0;\n        float tt=(3.0-ro.y)/rd.y;\n        vec2 cc=(ro+rd*tt).xz;\n        vec3 dust=vec3(0.0);\n        for (int i=0;i<12;i+=1)\n        {\n            float s=(0.5+0.5*sin(float(i)*7.0))*0.007;\n            float sp=mix(1.0,4.0,0.5+0.5*cos(float(i)))*0.5;\n            float d=abs(cc.x+cos(float(i+1)+cc.y*0.1*sp+time*0.03*(sp+cos(float(i))))*1.3);\n            float cable=smoothstep(s+0.00,s+0.011,d);\n\n            dust+=mask*0.05*sqrt(glow)*((1.0-smoothstep(s+0.00,s+0.005,d))-pow(1.0-smoothstep(0.0,s*0.5+0.005,d),1.0));\n\n            mask=min(mask,cable);\n            mask=min(mask,0.75+0.25*smoothstep(0.0,0.3,abs(cc.x+cos(float(i+1)+cc.y*0.1*sp+time*0.03*(sp+cos(float(i))))*1.3)));\n        }\n        // Mask out the wire shapes.\n        fragColor.rgb*=mix(0.0,1.0,mask);\n        // Add some fake lighting.\n        fragColor.rgb+=dust;\n    }\n\n    fragColor.rgb+=glow+0.6*vec3(0.3,0.7,1.0)*mix(vec3(0.01),vec3(0.0),min(1.0,abs(coord.x)));\n    fragColor.rgb=tonemap(fragColor.rgb*10.0)+noise(fragCoord.xy)/255.0;\n}\n\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MdSXRh","date":"1408734280","viewed":1001,"name":"Midnight Comms","username":"fizzer","description":"Just a sketch with wires, cables and glowing orbs.","likes":27,"published":1,"flags":0,"usePreview":0,"tags":["procedural","distancefield","blue","wires","cables"],"hasliked":0,"parentid":"","parentname":""}}