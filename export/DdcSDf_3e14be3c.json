{"ver":"0.1","info":{"id":"DdcSDf","date":"1680487550","viewed":103,"name":"edge aligned blur","username":"lalaoopybee","description":"a very nice smoothing effect. \ninput textures should have similar size to resolution to help with artifacting","likes":2,"published":1,"flags":34,"usePreview":0,"tags":["lic","etf","edgeblur"],"hasliked":0,"parentid":"dsd3zs","parentname":"edge tangent flow(etf+lic)"},"renderpass":[{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//line integral convolution\n#define K 8\n\n#define SIGMA 2.3\n\n#define GETDIR(a) normalize(texture(iChannel1, a).xy)\n#define GETCOL(a) texture(iChannel0, a)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv=fragCoord/iResolution.xy;\n\n    vec2 pt0=fragCoord+.5, pt=pt0;\n    vec2 dir0=GETDIR(uv), dir=dir0;\n    vec4 sum=vec4(0);\n    for(int i=-K;i<=K;i++){\n        //which way are we going?\n        if(i<0) pt-=dir;\n        else if(i==0) pt=pt0, dir=dir0;\n        else pt+=dir;\n        \n        //sampling\n        float weight=gaussian(pt-pt0, SIGMA);\n        vec2 ptUV=pt/iResolution.xy;\n        vec4 col=GETCOL(ptUV);\n        sum+=vec4(col.rgb, 1.)*weight;\n        dir=GETDIR(ptUV);\n    }\n    fragColor=sum/sum.a;\n    \n    float line=iMouse.x/iResolution.x;\n    if(uv.x<line) fragColor=texture(iChannel0, uv);\n    \n    fragColor*=smoothstep(0., .005, abs(line-uv.x));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//make structure tensor from partial derivative using sobel\nmat3 sobel=mat3(\n    -1, 0, 1,\n    -2, 0, 2,\n    -1, 0, 1\n);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv=fragCoord/iResolution.xy;\n\n    vec3 gradX=vec3(0);\n    vec3 gradY=vec3(0);\n    for(int i=0;i<3;i++){\n        for(int j=0;j<3;j++){\n            vec2 offsetUV=vec2(i-1, j-1)/iResolution.xy;\n            vec3 col=texture(iChannel0, uv+offsetUV).rgb;\n            gradX+=sobel[i][j]*col;\n            gradY+=sobel[j][2-i]*col;\n        }\n    }\n    gradX*=.25;\n    gradY*=.25;\n    \n    fragColor=vec4(\n        dot(gradX, gradX),\n        dot(gradX, gradY),\n        dot(gradY, gradY),\n        1  \n    );\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//blur structure tensor, calc eigenvectors. this is the etf.\n#define K 7\n\n#define SIGMA 2.5\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv=fragCoord/iResolution.xy;\n    \n    vec4 sum=vec4(0);\n    for(int i=-K;i<=K;i++){\n        for(int j=-K;j<=K;j++){\n            vec2 offset=vec2(i, j);\n            float weight=gaussian(offset, SIGMA);\n            \n            vec2 offsetUV=offset/iResolution.xy;\n            vec3 efg=texture(iChannel0, uv+offsetUV).rgb;\n            sum+=vec4(efg, 1)*weight;\n        }\n    }\n    vec3 efg=sum.rgb/sum.a;\n    \n    //calc eigenvalues\n    float e=efg.x, f=efg.y, g=efg.z;\n    float sqeg24f2=sqrt(pow(e-g, 2.)+4.*f*f);\n    float l1=(e+g+sqeg24f2)*.5;\n    float l2=(e+g-sqeg24f2)*.5;\n    \n    //calc eigenvectors\n    vec2 v1=vec2(f, l1-e);//maximal, gradient\n    vec2 v2=vec2(l2-g, f);//minimal, tangent\n    fragColor=vec4(v1, v2);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float Pi=3.1415927;\nfloat gaussian(vec2 pos, float sigma){\n    float left=1./(2.*Pi*sigma*sigma);\n    float right=exp(-dot(pos, pos)/(2.*sigma*sigma));\n    return left*right;\n}","name":"Common","description":"","type":"common"}]}