{"ver":"0.1","info":{"id":"XddGW2","date":"1452240659","viewed":509,"name":"GPU Gems Texture Bomb","username":"xfw","description":"Someone help and fixed the crazy cell line. Thx first.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","texturebomb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// GPU Gems Texture Bomb\n// http://http.developer.nvidia.com/GPUGems/gpugems_ch20.html\n\n#define SCALE_FACTOR vec2(0.037, 0.119)\n#define RADIUS 0.5\n#define RADIUS2 0.25\n#define CELL_CENTER vec2(RADIUS, RADIUS)\n\n// The cells created by this algorithm aren't guaranteed to be Voronoi regions. \n// The point in a neighboring cell, Pn , can be in the opposite corner from our sample, \n// but the point in the cell past that, Pn +1, may be on the close edge, \n// such that Pn +1 is actually closer. However, we don't include the cell belonging \n// to Pn +1 in our computations. Practically speaking, this doesn't happen very often, \n// and the regions are still useful. Increasing the number of samples per cell reduces the probability of this problem occurring.\n#define USE_3x3_SAMPLE\n\n#define SAMPLE_F -1\n\n#ifdef USE_3x3_SAMPLE\n\t#define SAMPLE_T 1 \n#else \n\t#define SAMPLE_T 0\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = uv;\n    p.x *= iResolution.x / iResolution.y;\n    \n    vec3 col = vec3(0.2, 0.3, 0.6);\n    \n    float time = iTime*0.1;\n    //p += vec2(sin(time), cos(time));\n\n    p *= 4.;   \n    vec2 cell = floor(p);\n    vec2 positionInCellSpace = fract(p);\n    \n    //float priority = -1.;\n    float priority = 999.;\n    for (int i = SAMPLE_F; i <= SAMPLE_T; i++)\n    {\n       for (int j = SAMPLE_F; j <= SAMPLE_T; j++)\n       {\n           vec2 adjacentCell = cell + vec2(i,j);\n           vec2 positionToAdjacentCell = positionInCellSpace - vec2(i,j);\n           \n           // hash cell's origin position, make it looks random.\n           vec4 sample = texture(iChannel0, adjacentCell*SCALE_FACTOR);\n           \n           // anim must keep in cell. more detail seen GPU Gems\n           vec2 animSamplePoint = RADIUS2 * (1.0 + sin(time*8.0*sample.xy)); \n           vec2 positionToSampleCell = positionToAdjacentCell - CELL_CENTER - animSamplePoint;\n\t\t   \n           float radius2 = dot(positionToSampleCell, positionToSampleCell);\n           \n           //if (sample.w > priority && radius2 < RADIUS2)\n           if (radius2 < priority )\n           {\n               col = texture(iChannel0, sample.xy+vec2(0.13,0.4)).xyz;\n               //priority = sample.w;\n               priority = radius2;\n           }\n           \n           if (radius2 < 0.001)\n           {\n              col = vec3(0.);// voronoi site\n           }\n        }\n    }\n    \n\tfragColor = vec4(col, 1.0);\n}","name":"","description":"","type":"image"}]}