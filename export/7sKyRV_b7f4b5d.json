{"ver":"0.1","info":{"id":"7sKyRV","date":"1715620061","viewed":64,"name":"Huh","username":"vladeeer","description":"1","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["1"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define N_OBJECTS 2\n\nconst float FOV = 100.0;\nconst int MAX_STEPS = 1000;\nconst float EPSILON = 0.001;\nconst float MAX_DISTANCE = 1000.0;\n\nstruct Hit\n{\n    float l;\n    int id;\n};\n\nHit sphere(vec3 p, vec3 o, float r)\n{\n    p = mod(p, 8.0) - 4.0;\n    Hit object;\n    object.id = 1;\n    object.l = length(o - p) - r;\n    return object;\n}\n\nHit plane(vec3 p, vec3 n, float distanceFromOrigin) {\n    Hit object;\n    object.id = 2;\n    object.l = dot(p, n) + distanceFromOrigin; \n\treturn object;\n}\n\nHit getDistance(vec3 p)\n{\n    Hit objects[N_OBJECTS]; \n    \n    objects[0] = sphere(p, vec3(0.0), 1.0);\n    objects[1] = plane(p, vec3(0.0, 1.0, 0.0), 1.0);\n    \n    int minI;\n    for (int i = 1; i < N_OBJECTS; i++)\n        if (objects[i].l < objects[minI].l)\n            minI = i;\n    \n    return objects[minI];\n}\n\nHit rayMarch(vec3 ro, vec3 rd)\n{\n    Hit hit, object;\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + rd * object.l;\n        hit = getDistance(p);\n        object.id = hit.id;\n        object.l += hit.l;\n        if (abs(hit.l) < EPSILON || object.l > MAX_DISTANCE) break;\n    }\n    return object;\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec2 e = vec2(EPSILON, 0.0);\n    vec3 n = getDistance(p).l-vec3(getDistance(p-e.xyy).l, getDistance(p-e.yxy).l, getDistance(p-e.yyx).l);\n    return normalize(n);\n}\n\nvec3 getLight(vec3 p, vec3 rd, vec3 color)\n{\n    vec3 lightPos = vec3(20.0, 40.0, -30.0);\n    vec3 L = normalize(lightPos-p);\n    vec3 N = getNormal(p);\n    \n    vec3 diffuse = color * clamp(dot(L, N), 0.0, 1.0);\n    vec3 ambient = color * 0.05;\n    \n    float d = rayMarch(p + N*EPSILON*2.0, L).l;\n    if (d < length(lightPos - p)) return ambient;\n    return diffuse + ambient;\n}\n\nvec3 getMaterial(vec3 p, int id)\n{\n    vec3 m;\n    \n    switch(id)\n    {\n        case 1: \n        m = vec3(0.9, 0.0, 0.0); break; \n        case 2: \n        m = vec3(0.2 + 0.4*mod(floor(p.x) + floor(p.z), 2.0)); break;\n        \n        default: m = vec3(1.0);\n    }\n    return m;\n}\n\nvec3 render(vec2 uv)\n{\n    vec3 col;\n    vec3 ro = vec3(0.0, 0.0, -3.0);\n    vec3 rd = normalize(vec3(uv.xy, iResolution.x/(iResolution.y*tan(FOV * 3.141592 / 360.0))));\n    \n    Hit object = rayMarch(ro, rd);\n    \n    vec3 background = vec3(0.5, 0.8, 0.9);\n    if (object.l < MAX_DISTANCE)\n    {\n        vec3 p = ro + rd * object.l;\n        vec3 material = getMaterial(p, object.id);\n        col += getLight(p, rd, vec3(material));\n        col = mix(col, background, 1.0 - exp(-0.00000008 * object.l * object.l));\n    } else {\n        col += background - max(0.95 * rd.y, 0.0);\n    }\n    return  col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n\n    vec3 col;\n    col += render(uv);\n    \n    col = pow(col, vec3(0.4545));\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}