{"ver":"0.1","info":{"id":"NttXWH","date":"1639128938","viewed":104,"name":"Rebounds","username":"kastorp","description":"testing the simplest elastic collision\nBLUE: approximate rule (x=0 and v=-v0) with configurable subframing\nGREEN: exact calculation of impact time and rebound parabola\nAfter 10 rebounds, the approximate maximum height diverges from initial height","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["collision","elastic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Rebounds\n\n#define R iResolution.xy\n#define T(i) texelFetch(iChannel0,ivec2(i,0),0)\n#define S M/float(N) \n\nvoid mainImage( out vec4 O, in vec2 U )\n{   \n\nO=vec4(0);\n    vec2 uv = U/R*float(N)*S*1.1;  \n    for(int i = 0;i<N;i++){\n        vec4 b =T(i);\n        if(uv.x<float(i)*S + S*.5 && uv.x>float(i)*S ){\n            if(uv.y< b.y+S) O= ((i%2)>0?vec4(0,0,.2,0):vec4(0,.2,0,0))* (uv.y< b.w?2.:1.); \n            if(uv.y< b.x+S  &&uv.y>b.x)  O=vec4(1);\n        \n        \n        }\n    }\n \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define FR 60.  //framerate\n#define SF 1. //collision sub framing\n#define G  9.8 //gravity\n#define T(u) texelFetch(iChannel0,ivec2(u),0)\n#define S M/float(N) \n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n   O=vec4(0);\n   int i= int(U.x);\n   \n   if(iFrame==0) {      \n      ivec2 c=ivec2(U);\n      if(c.y>0) discard;\n      if(c.x<N) O=vec4(floor(U.x/2.)*2.*S+1.,floor(U.x/2.)*2.*S+S*.3+1.,0,0);\n        \n   }else{\n       vec4 a0= T(U);\n       float x,x0=a0.x,v,v0=a0.z;\n        \n        if((i%2)>0){ //APPROXIMATE\n      \n                //SUBFRAMING\n                for(float j =0.;j<SF;j++){\n                   if(x0<0.) {           \n                       //reposition\n                       x= 0.;\n                       //restitution\n                       v= -v0 ;//- G/FR;\n                   }\n                   else{\n                       //move\n                       x= x0+ v0/FR/SF - G/2./FR /FR/SF/SF;\n                       //apply forces      \n                       v= v0 - G/FR/SF;\n                   }\n                   x0=x;v0=v;\n                }\n\n        }else{ //EXACT, with Wolfram Alpha and Geogebra :-)\n               //collision (multiple rebounds per frame not handled)\n               if(x0 + (v0 - G/2./FR) /FR<0.) {\n                   float k= sqrt(2. * x0 * G +v0*v0);\n                     x =  -(k + v0 - G/FR)*(3.* k + v0 - G/FR)/(2.* G); \n                     v = 2.*k + v0 - G/FR;\n               }\n               else{\n                   //move\n                   x= x0  + (v0 - G/2./FR) /FR;\n                   //apply forces      \n                   v= v0 - G/FR;\n               }\n        }        \n       \n       float h0 = floor(U.x/2.)*2.*S+1.,\n             p = 2.*sqrt(2. * h0 / G ),\n             t=  2.* fract(float(iFrame)/FR/p +.5)-1.,\n             h = h0 *(1.-  t*t),\n             hm =max(x,a0.y);\n       O =vec4(x,hm,v,h);;\n   }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define N 50  //number of samples\n#define M 20.  //max height in meters\n\n","name":"Common","description":"","type":"common"}]}