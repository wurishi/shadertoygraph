{"ver":"0.1","info":{"id":"3dBSDW","date":"1553708798","viewed":4945,"name":"Faster atmospheric scattering","username":"16807","description":"I modified Valentine Galea's demo to calculate optical depth by solving an integral. Should be faster and more precise than standard ray marching. See http://davidson16807.github.io/tectonics.js//2019/03/24/fast-atmospheric-scattering.html for details.","likes":73,"published":1,"flags":0,"usePreview":0,"tags":["sky","volumetric","scattering","atmosphere","rayleigh","mie"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ----------------------------------------------------------------------------\n// Rayleigh and Mie scattering atmosphere system\n//\n// implementation of the techniques described here:\n// http://www.scratchapixel.com/old/lessons/3d-advanced-lessons/simulating-the-colors-of-the-sky/atmospheric-scattering/\n// ----------------------------------------------------------------------------\n\n#ifdef GL_ES\n#define _in(T) const in T\n#define _inout(T) inout T\n#define _out(T) out T\n#define _begin(type) type (\n#define _end )\n#define mul(a, b) (a) * (b)\n#endif\n\n#define PI 3.14159265359\n\n// Shadertoy specific uniforms\n#define u_res iResolution\n#define u_time iTime\n#define u_mouse iMouse\n\nstruct ray_t {\n\tvec3 origin;\n\tvec3 direction;\n};\n#define BIAS 1e-4 // small offset to avoid self-intersections\n\nstruct sphere_t {\n\tvec3 origin;\n\tfloat radius;\n\tint material;\n};\n\nstruct plane_t {\n\tvec3 direction;\n\tfloat distance;\n\tint material;\n};\n\nmat3 rotate_around_x(_in(float) angle_degrees)\n{\n\tfloat angle = radians(angle_degrees);\n\tfloat _sin = sin(angle);\n\tfloat _cos = cos(angle);\n\treturn mat3(1, 0, 0, 0, _cos, -_sin, 0, _sin, _cos);\n}\n\n\nray_t get_primary_ray(\n\t_in(vec3) cam_local_point,\n\t_inout(vec3) cam_origin,\n\t_inout(vec3) cam_look_at\n){\n\tvec3 fwd = normalize(cam_look_at - cam_origin);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 right = cross(up, fwd);\n\tup = cross(fwd, right);\n\n\tray_t r = _begin(ray_t)\n\t\tcam_origin,\n\t\tnormalize(fwd + up * cam_local_point.y + right * cam_local_point.x)\n\t\t_end;\n\treturn r;\n}\n\nbool isect_sphere(_in(ray_t) ray, _in(sphere_t) sphere, _inout(float) t0, _inout(float) t1)\n{\n\tvec3 rc = sphere.origin - ray.origin;\n\tfloat radius2 = sphere.radius * sphere.radius;\n\tfloat tca = dot(rc, ray.direction);\n\tfloat d2 = dot(rc, rc) - tca * tca;\n\tif (d2 > radius2) return false;\n\tfloat thc = sqrt(radius2 - d2);\n\tt0 = tca - thc;\n\tt1 = tca + thc;\n\n\treturn true;\n}\n\n// scattering coefficients at sea level (m)\nconst vec3 betaR = vec3(5.5e-6, 13.0e-6, 22.4e-6); // Rayleigh \nconst vec3 betaM = vec3(21e-6); // Mie\n\n// scale height (m)\n// thickness of the atmosphere if its density were uniform\nconst float hR = 7994.0; // Rayleigh\nconst float hM = 1200.0; // Mie\n\nfloat rayleigh_phase_func(float mu)\n{\n\treturn\n\t\t\t3. * (1. + mu*mu)\n\t/ //------------------------\n\t\t\t\t(16. * PI);\n}\n\n// Henyey-Greenstein phase function factor [-1, 1]\n// represents the average cosine of the scattered directions\n// 0 is isotropic scattering\n// > 1 is forward scattering, < 1 is backwards\nconst float g = 0.76;\nfloat henyey_greenstein_phase_func(float mu)\n{\n\treturn\n\t\t\t\t\t\t(1. - g*g)\n\t/ //---------------------------------------------\n\t\t((4. + PI) * pow(1. + g*g - 2.*g*mu, 1.5));\n}\n\n// Schlick Phase Function factor\n// Pharr and  Humphreys [2004] equivalence to g above\nconst float k = 1.55*g - 0.55 * (g*g*g);\nfloat schlick_phase_func(float mu)\n{\n\treturn\n\t\t\t\t\t(1. - k*k)\n\t/ //-------------------------------------------\n\t\t(4. * PI * (1. + k*mu) * (1. + k*mu));\n}\n\nconst float earth_radius = 6360e3; // (m)\nconst float atmosphere_radius = 6420e3; // (m)\n\nvec3 sun_dir = vec3(0, 1, 0);\nconst float sun_power = 20.0;\n\nconst sphere_t atmosphere = _begin(sphere_t)\n\tvec3(0, 0, 0), atmosphere_radius, 0\n_end;\n\nconst int num_samples = 16;\nconst int num_samples_light = 8;\n\n\nconst float BIG = 1e20;\nconst float SMALL = 1e-20;\n\nfloat approx_air_column_density_ratio_through_atmosphere(\n    in float a,\n    in float b,\n    in float z2,\n    in float r0\n){\n    // GUIDE TO VARIABLE NAMES:\n    //  \"x*\" distance along the ray from closest approach\n    //  \"z*\" distance from the center of the world at closest approach\n    //  \"r*\" distance (\"radius\") from the center of the world\n    //  \"*0\" variable at reference point\n    //  \"*2\" the square of a variable\n    //  \"ch\" a nudge we give to prevent division by zero, analogous to the Chapman function\n    const float SQRT_HALF_PI = sqrt(PI/2.);\n    const float k = 0.6; // \"k\" is an empirically derived constant\n    float x0 = sqrt(max(r0*r0 - z2, SMALL));\n    // if obstructed by the world, approximate answer by using a ludicrously large number\n    if (a < x0 && -x0 < b && z2 < r0*r0) { return BIG; }\n    float abs_a  = abs(a);\n    float abs_b  = abs(b);\n    float z      = sqrt(z2);\n    float sqrt_z = sqrt(z);\n    float ra     = sqrt(a*a+z2);\n    float rb     = sqrt(b*b+z2);\n    float ch0    = (1. - 1./(2.*r0)) * SQRT_HALF_PI * sqrt_z + k*x0;\n    float cha    = (1. - 1./(2.*ra)) * SQRT_HALF_PI * sqrt_z + k*abs_a;\n    float chb    = (1. - 1./(2.*rb)) * SQRT_HALF_PI * sqrt_z + k*abs_b;\n    float s0     = min(exp(r0- z),1.) / (x0/r0 + 1./ch0);\n    float sa     = exp(r0-ra) / max(abs_a/ra + 1./cha, 0.01);\n    float sb     = exp(r0-rb) / max(abs_b/rb + 1./chb, 0.01);\n    return max( sign(b)*(s0-sb) - sign(a)*(s0-sa), 0.0 );\n}\n\n// \"approx_air_column_density_ratio_along_3d_ray_for_curved_world\" is just a convenience wrapper \n//   for the above function that works with 3d vectors.\nfloat approx_air_column_density_ratio_along_3d_ray_for_curved_world (\n    vec3  P, // position of viewer\n    vec3  V, // direction of viewer (unit vector)\n    float x, // distance from the viewer at which we stop the \"raymarch\"\n    float r, // radius of the planet\n    float H  // scale height of the planet's atmosphere\n){\n    float xz = dot(-P,V);           // distance (\"radius\") from the ray to the center of the world at closest approach, squared\n    float z2 = dot( P,P) - xz * xz; // distance from the origin at which closest approach occurs\n    return approx_air_column_density_ratio_through_atmosphere( 0.-xz, x-xz, z2, r/H );\n}\n\nbool get_sun_light(\n\t_in(ray_t) ray,\n\t_inout(float) optical_depthR,\n\t_inout(float) optical_depthM\n){\n\tfloat t0, t1;\n\tisect_sphere(ray, atmosphere, t0, t1);\n\n    // // this is the implementation using classical raymarching \n\t// float march_pos = 0.;\n\t// float march_step = t1 / float(num_samples_light);\n    // \n\t// for (int i = 0; i < num_samples_light; i++) {\n\t// \tvec3 s =\n\t// \t\tray.origin +\n\t// \t\tray.direction * (march_pos + 0.5 * march_step);\n\t// \tfloat height = length(s) - earth_radius;\n\t// \tif (height < 0.)\n\t// \t\treturn false;\n    // \n\t// \toptical_depthR += exp(-height / hR) * march_step;\n\t// \toptical_depthM += exp(-height / hM) * march_step;\n    // \n\t// \tmarch_pos += march_step;\n\t// }\n    \n    // this is the implementation using a fast closed form approximation\n    optical_depthR = \n        approx_air_column_density_ratio_along_3d_ray_for_curved_world (\n            ray.origin,    // position of viewer\n            ray.direction, // direction of viewer (unit vector)\n            t1, // distance from the viewer at which we stop the \"raymarch\"\n            earth_radius, // radius of the planet\n            hR  // scale height of the planet's atmosphere\n        );\n    optical_depthM = \n        approx_air_column_density_ratio_along_3d_ray_for_curved_world (\n            ray.origin,    // position of viewer\n            ray.direction, // direction of viewer (unit vector)\n            t1, // distance from the viewer at which we stop the \"raymarch\"\n            earth_radius, // radius of the planet\n            hM  // scale height of the planet's atmosphere\n        );\n\n\treturn true;\n}\nvec3 get_incident_light(_in(ray_t) ray)\n{\n\t// \"pierce\" the atmosphere with the viewing ray\n\tfloat t0, t1;\n\tif (!isect_sphere(\n\t\tray, atmosphere, t0, t1)) {\n\t\treturn vec3(0);\n\t}\n\n\tfloat march_step = t1 / float(num_samples);\n\n\t// cosine of angle between view and light directions\n\tfloat mu = dot(ray.direction, sun_dir);\n\n\t// Rayleigh and Mie phase functions\n\t// A black box indicating how light is interacting with the material\n\t// Similar to BRDF except\n\t// * it usually considers a single angle\n\t//   (the phase angle between 2 directions)\n\t// * integrates to 1 over the entire sphere of directions\n\tfloat phaseR = rayleigh_phase_func(mu);\n\tfloat phaseM =\n#if 1\n\t\thenyey_greenstein_phase_func(mu);\n#else\n\t\tschlick_phase_func(mu);\n#endif\n\n\t// optical depth (or \"average density\")\n\t// represents the accumulated extinction coefficients\n\t// along the path, multiplied by the length of that path\n\tfloat optical_depthR = 0.;\n\tfloat optical_depthM = 0.;\n\n\tvec3 sumR = vec3(0);\n\tvec3 sumM = vec3(0);\n\tfloat march_pos = 0.;\n\n\tfor (int i = 0; i < num_samples; i++) {\n\t\tvec3 s =\n\t\t\tray.origin +\n\t\t\tray.direction * (march_pos + 0.5 * march_step);\n\t\tfloat height = length(s) - earth_radius;\n\n\t\t// integrate the height scale\n\t\tfloat hr = exp(-height / hR) * march_step;\n\t\tfloat hm = exp(-height / hM) * march_step;\n\t\toptical_depthR += hr;\n\t\toptical_depthM += hm;\n\n\t\t// gather the sunlight\n\t\tray_t light_ray = _begin(ray_t)\n\t\t\ts,\n\t\t\tsun_dir\n\t\t_end;\n\t\tfloat optical_depth_lightR = 0.;\n\t\tfloat optical_depth_lightM = 0.;\n\t\tbool overground = get_sun_light(\n\t\t\tlight_ray,\n\t\t\toptical_depth_lightR,\n\t\t\toptical_depth_lightM);\n\n\t\tif (overground) {\n\t\t\tvec3 tau =\n\t\t\t\tbetaR * (optical_depthR + optical_depth_lightR) +\n\t\t\t\tbetaM * 1.1 * (optical_depthM + optical_depth_lightM);\n\t\t\tvec3 attenuation = exp(-tau);\n\n\t\t\tsumR += hr * attenuation;\n\t\t\tsumM += hm * attenuation;\n\t\t}\n\n\t\tmarch_pos += march_step;\n\t}\n\n\treturn\n\t\tsun_power *\n\t\t(sumR * phaseR * betaR +\n\t\tsumM * phaseM * betaM);\n}\n\nvoid mainImage(_out(vec4) fragColor, vec2 fragCoord)\n{\n\tvec2 aspect_ratio = vec2(u_res.x / u_res.y, 1);\n\tfloat fov = tan(radians(45.0));\n\tvec2 point_ndc = fragCoord.xy / u_res.xy;\n\tvec3 point_cam = vec3((2.0 * point_ndc - 1.0) * aspect_ratio * fov, -1.0);\n\n\tvec3 col = vec3(0);\n\n\t// sun\n\tmat3 rot = rotate_around_x(-abs(sin(u_time / 2.)) * 90.);\n\tsun_dir *= rot;\n\n    if (u_mouse.z < 0.1) {\n        // sky dome angles\n        vec3 p = point_cam;\n        float z2 = p.x * p.x + p.y * p.y;\n        float phi = atan(p.y, p.x);\n        float theta = acos(1.0 - z2);\n        vec3 dir = vec3(\n            sin(theta) * cos(phi),\n            cos(theta),\n            sin(theta) * sin(phi));\n\n        ray_t ray = _begin(ray_t)\n            vec3(0, earth_radius + 1., 0),\n            dir\n        _end;\n\n        col = get_incident_light(ray);\n    } else {\n        vec3 eye = vec3 (0, earth_radius + 1., 0);\n        vec3 look_at = vec3 (0, earth_radius + 1.5, -1);\n\n        ray_t ray = get_primary_ray(point_cam, eye, look_at);\n\n        if (dot(ray.direction, vec3(0, 1, 0)) > .0) {\n            col = get_incident_light(ray);\n        } else {\n            col = vec3 (0.333);\n        }\n    }\n\n\tfragColor = vec4(col, 1);\n}\n","name":"Image","description":"","type":"image"}]}