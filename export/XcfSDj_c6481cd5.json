{"ver":"0.1","info":{"id":"XcfSDj","date":"1705705678","viewed":96,"name":"[phreax] melting with you","username":"phreax","description":"quick sketch for another project","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["rayarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592\n#define TAU PI*2.\n\n\n#define SIN(x) (.5+.5*sin(x))\n\nfloat tt;\n\nconst highp float NOISE_GRANULARITY = 0.5/255.0;\n\nhighp float random(highp vec2 coords) {\n   return fract(sin(dot(coords.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat curve(float t, float d) {\n  float off = .25;\n  t = ((t-off)/d);\n  return mix(floor(t), floor(t)+1., pow(smoothstep(0.,1.,fract(t)), 20.));\n}\n\nfloat box(vec3 p, vec3 r) {\n\tvec3 q = abs(p) - r;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nmat2 rot(float a) { return mat2(cos(a), sin(a), -sin(a), cos(a));}\n\n\nfloat cyl( vec3 p, float r, float h )\n{\n\n  vec2 d = abs(vec2(length(p.yz),p.x)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n    \nfloat rep(inout float x, float s) {\n    float id = floor(x/s);\n    x = mod(x, s) - s/2.;\n    return id;\n}\n\nfloat matID;\nfloat instIDn;\nfloat instID;\n\n\nfloat hash11(float x) {\n\treturn fract(sin(5137765.44*x)*345.63);\n}\n\n\nfloat rectSin(float x) {\n    return smoothstep(0., 1., sin(x));\n}\n\n\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat hand(vec3 p, float off, float dir) {\n\n\n    p.x -= off * (SIN(.5*tt)*7.-2.3);\n    \n    if(dir < 0.) p.x = -p.x;\n\n    p.xy*= rot(0.05*sin(2.*p.z+tt));\n    p.xz *= rot(.5*sin(.25*tt));\n\n    \n\n    float bend = 1.3*SIN(tt);\n    \n    p.x += 0.5*SIN(p.y*2.)*bend;\n    \n    p.xy = mix(p.xy, p.xy * rot(bend), smoothstep(-0.5, 0.5, p.y));\n    \n    float gap = .8;\n    /*p.x = abs(p.x) - gap;\n    p.x = abs(p.x) - gap;\n    p.x = abs(p.x) - gap;\n    */\n     \n    return box(p, vec3(.3, 3.3, 1.5))-.1;\n}\n\n\nfloat map(vec3 p) {\n    \n    \n    vec3 bp =p;\n   // p.xz *= rot(.2*tt);\n    float instIDo = instIDn; \n   \n    instID = 1.;\n    matID = 0.;\n    \n    float h1 = hand(p, 1., 1.);\n    float h2 = hand(p, -1., -1.);\n    \n    p = bp;\n    p.y += 5.;\n    p.yz = mix(p.yz, p.yz* rot(-.6), smoothstep(10.,50., p.z));\n    float fl = box(p, vec3(100, 0.1, 200));\n    \n    matID = h1 < h2 ? 0. : 1.;\n\n    float d = opSmoothUnion(h1, h2, mix(1., 3., SIN(tt*.75)));\n    \n    matID = fl < d ? 2. : matID;\n    \n    d = min(d*.5, fl);\n    //return min(d*.4, o);\n    return d;\n \n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float w )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<100 && t<maxt; i++ )\n    {\n        float h = map(ro + t*rd);\n        res = min( res, h/(w*t) );\n        t += clamp(h, 0.001, 0.1);\n        if( res<-1.0 || t>maxt ) break;\n    }\n    res = max(res,-1.0);\n    return 0.25*(1.0+res)*(1.0+res)*(2.0-res);\n}\n\n\nfloat calcAO(vec3 p, vec3 n)\n{\n\tfloat sca = 2.0, occ = 0.0;\n    for( int i=0; i<5; i++ ){\n    \n        float hr = 0.01 + float(i)*0.5/4.0;        \n        float dd = map(n * hr + p);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n\nvec3 invGamma(vec3 col) {\n    return pow(col, vec3(2.2));\n}\n\nvec3 gamma(vec3 col) {\n    return pow(col, vec3(1./2.2));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.x;\n    \n    //uv = uv.yx;\n    tt = (iTime*2.*PI)/5. + 1.4*PI;\n    \n  //  tt = tt*1.2+ 6.*curve(tt+BEATS*1.-.4, 3.*BEATS/8.);\n    vec3 ro = vec3(0, 0., -13),\n         rd = normalize(vec3(uv, .6)),\n         lp = vec3(2., 0.6, -5.),\n         lp2 = vec3(-2., 1.0, -5.);\n    \n    vec3 col;\n    float i, t, d = 0.1;\n    float matIDt = 0.;\n    float instIDt = 0.;\n\n    vec3 p = ro;\n    \n    for(i=0.; i<200.; i++) {\n    \n          \n        d = map(p);\n        matIDt = matID;\n        instIDt = instID;\n        if(d < 0.001 || t > 100.) break;\n        \t\n        p += rd*d;\n        t += d;\n    }\n    \n    vec2 e = vec2(0.0035, -0.0035);\n    \n    vec3 objColor = vec3(0.918,0.969,0.984);\n    vec3 al1 = vec3(0.078,0.902,0.804);\n    vec3 al2 = vec3(1.000,0.533,0.000);\n       \n    vec3 al1_ = vec3(0.894,0.220,0.941);\n    vec3 al2_ = vec3(0.976,0.949,0.102);\n    \n    float ringMod =  float(mod(instIDt, 4.)<1.);\n   \n    vec3 al = mix(mix(al1, al1_, ringMod), mix(al2, al2_, ringMod), matIDt);\n    \n \n    float isRing = matIDt <= 1.? 1. : 0.;\n    if(isRing < 1.) {\n        al = objColor;\n        al = mix(al, al1, rectSin(iTime+instIDt)*float(mod(instIDt, 3.)<1.));\n        al = mix(al, al2, rectSin(.5*iTime+instIDt)*float(mod(instIDt+.5, 4.)>=3.));\n    }\n\n    \n    vec3 bg = vec3(0.722,0.820,0.859);\n    \n    if(d < 0.001) {\n        vec3 n = normalize( e.xyy*map(p+e.xyy) + e.yyx*map(p+e.yyx) +\n                            e.yxy*map(p+e.yxy) + e.xxx*map(p+e.xxx));\n        \n        vec3 l = normalize(lp-p);\n        vec3 l2 = normalize(lp-p);\n        \n        float dif = max(dot(n, l), .0);\n        float spe = pow(max(dot(reflect(-rd, n), -l), .0), 40.);\n        float sss = smoothstep(0., 1., map(p+l*.4))/.4;     \n \n        float shd = softshadow(vec3(-abs(p.x), p.yz), lp, 2., 10., 0.6);\n        \n        float dif2 = max(dot(n, l2), .0);\n        float spe2 = pow(max(dot(reflect(-rd, n), -l2), .0), 40.);\n       // float sss2 = smoothstep(0., 1., map(p+l2*.4))/.4; \n\n\n        //al = mix(al, al-vec3(0.106,0.090,0.208) , ringMod*isRing);\n        \n        \n        \n        col =  al*mix(1., 0.5*(spe+spe2)+.9*(0.5*(dif+dif2)+1.5*(sss)), .4);\n                  \n        float ao = calcAO(p, n);\n\n        col = mix(col, col*(1.-ao), .4);\n\n        if(matID < 2.) {\n        \n            rd = reflect(rd, n);\n\n            vec3 refl = texture(iChannel0, rd).rgb;\n\n            refl = invGamma(refl);\n            \n            col = mix(col, col*refl, .5);\n            col *= 1.6+.2;\n\n        } else {\n            col *= 1.1;\n            col += .2;\n        \n        }\n        \n        col = mix(col, col*shd, .5);\n        \n  \n\n    } else {\n        col += bg*mix(.1, 1., (1.-pow(dot(uv, uv), .8)));\n    }\n    \n    col += mix(-NOISE_GRANULARITY, NOISE_GRANULARITY, random(uv)); // dithering\n\n    // Output to screen\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}