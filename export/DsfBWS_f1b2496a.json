{"ver":"0.1","info":{"id":"DsfBWS","date":"1689095800","viewed":54,"name":"raymarched spheres","username":"texl","description":"some rarymarched spheres","likes":0,"published":3,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"Surface sdScene(vec3 p, vec2 mouse, bool mouseActive, float time)\n{\n    Surface ret = EmptySurface;\n\n    vec3 c = vec3(1);\n    vec3 q = mod((p - vec3(0.5, 0.5, 0.0)) + 0.5 * c,c) - 0.5 * c;\n    float radius = 0.2;\n    vec3 color = vec3(1);\n    ret = minWithColor(ret, sdSphere(q, radius, color));\n    ret = minWithColor(ret, sdBasis(p, 1.0f));\n    return ret;\n}\n\nSurface rayMarch(vec3 ro, vec3 rd, float start, float end, vec2 mouse, bool mouseActive, float time)\n{\n    float depth = start;\n    Surface co; // closest object\n\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++)\n    {\n        vec3 p = ro + depth * rd;\n        co = sdScene(p, mouse, mouseActive, time);\n        depth += co.sd;\n        if (co.sd < PRECISION || depth > end) break;\n    }\n  \n    co.sd = depth;\n  \n    return co;\n}\n\nvec3 calcNormal(in vec3 p, vec2 mouse, bool mouseActive, in float time)\n{\n    vec2 e = vec2(1.0, -1.0) * 0.0005; // epsilon\n    return normalize(\n        e.xyy * sdScene(p + e.xyy, mouse, mouseActive, time).sd +\n        e.yyx * sdScene(p + e.yyx, mouse, mouseActive, time).sd +\n        e.yxy * sdScene(p + e.yxy, mouse, mouseActive, time).sd +\n        e.xxx * sdScene(p + e.xxx, mouse, mouseActive, time).sd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 backgroundColor = vec3(0.5);\n    float time = iTime;\n  \n    float cameraDistance = 4.25;\n  \n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 mouse = cameraDistance * 0.5 * viewport_to_world(iMouse.xy, iResolution);\n    bool mouseActive = iMouse.z > 0.0;\n  \n    vec3 col = vec3(0);\n    vec3 ro = vec3(-0.25, 0, -cameraDistance); // ray origin that represents camera position\n    \n    float bob = sin(iTime * 0.1) * 0.05f;\n    ro += vec3(0, bob, 0);\n\n    vec3 target = vec3(0) + vec3(0.5, -0.5, 0.0);\n    if (mouseActive)\n    {\n        target = target + vec3(mouse, 0);\n    }\n    vec3 toTarget = target - ro;\n    mat3 lookAtInv = lookAtInv(toTarget);\n  \n//    vec3 rd = normalize(vec3(uv, 1) + vec3(0.15, -0.15, 0.0));\n//    if (mouseActive)\n//    {\n        vec3 rd = lookAtInv * normalize(vec3(uv, 1)); // ray direction\n//    }\n    \n\n    Surface co = rayMarch(ro, rd, MIN_DIST, MAX_DIST, mouse, mouseActive, time); // closest object\n\n    if (co.sd > MAX_DIST)\n    {\n        col = backgroundColor; // ray didn't hit anything\n    }\n    else\n    {\n        vec3 p = ro + rd * co.sd; // point on surface\n        vec3 normal = calcNormal(p, mouse, mouseActive, time);\n        vec3 lightPosition = vec3(4, -2, 0);\n        vec3 lightDirection = normalize(lightPosition - p);\n\n        float ambientContrib = 0.01;\n        float diffuseContrib = 1.0 - ambientContrib;\n        vec3 ambient = ambientContrib * co.col;\n        vec3 diffuse = diffuseContrib * saturate(dot(normal, lightDirection)) * co.col;\n\n        col = ambient + diffuse;\n    }\n    \n    col = pow(col, vec3(1.0 / 2.2));\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = 3.1415926535897932384626433832795;\nconst float TWO_PI = 6.283185307179586476925286766559;\nconst float DEGREES_TO_RADIANS = PI / 180.0;\n\nvec3 lerp (in vec3 a, in vec3 b, in float t)\n{\n    return (1.0 - t) * a + t * b;\n}\n\nfloat saturate(in float value)\n{\n    return clamp(value, 0.0, 1.0);\n}\n\n// origin at viewport center, y in range [-1, 1], corrected for aspect ratio\nvec2 viewport_to_world( in vec2 fragCoord, in vec3 resolution )\n{\n    return (2.0 * fragCoord - resolution.xy) / resolution.y;\n}\n\n// ray marching\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 200.0;\nconst float PRECISION = 0.001;\n\nstruct Surface\n{\n    float sd; // signed distance value\n    vec3 col; // color\n};\n\nconst Surface EmptySurface = Surface(MAX_DIST, vec3(0));\n\n// operations\n\nSurface minWithColor(Surface obj1, Surface obj2)\n{\n    if (obj2.sd < obj1.sd)\n    {\n        return obj2;\n    }\n    else\n    {\n        return obj1;\n    }\n}\n\n// SDFs\n\n// torus\n// p = center\n// r1 = major radius (distance from center to circular cross-section center\n// r2 = radius of circular cross-section\nSurface sdTorus(vec3 p, float r1, float r2, vec3 col)\n{\n    vec2 q = vec2(length(p.xy) - r1, p.z);\n    return Surface(length(q) - r2, col);\n}\n\n// cone\n// p = center of base\n// c = sin/cos of angle\n// h = height\nSurface sdCone(vec3 p, vec2 c, float h, vec3 col)\n{\n  vec2 q = h * vec2(c.x / c.y, -1.0);\n  vec2 w = vec2(length(p.xy), p.z);\n  vec2 a = w - q * saturate(dot(w,q) / dot(q,q));\n  vec2 b = w - q * vec2(saturate(w.x / q.x), 1.0);\n  float k = sign(q.y);\n  float d = min(dot(a, a), dot(b, b));\n  float s = max(k * (w.x * q.y - w.y * q.x), k * (w.y - q.y));\n  return Surface(sqrt(d) * sign(s), col);\n}\n\nSurface sdCone(vec3 p, float angle, float h, vec3 col)\n{\n    return sdCone(p, vec2(sin(angle), cos(angle)), h, col);\n}\n\n// infinite cylinder\n// p = point on center axis\n// r = radius\nSurface sdCylinder(vec3 p, float r, vec3 col)\n{\n    return Surface(length(p.xy) - r, col);\n}\n\n// finite cylinder\n// p = point on center axis\n// r = radius\n// h = height\nSurface sdCylinder(vec3 p, float r, float h, vec3 col)\n{\n  vec2 d = abs(vec2(length(p.xy), p.z - 0.5 * h)) - vec2(r, 0.5 * h);\n  return Surface(min(max(d.x, d.y), 0.0) + length(max(d, 0.0)), col);\n}\n\n// arrow\nSurface sdArrow(vec3 p, float shaftRadius, float totalLength, vec3 col)\n{\n    float capAngle = 20.0 * DEGREES_TO_RADIANS;\n    float capLength = 2.0 * shaftRadius / tan(capAngle);\n    Surface ret = EmptySurface;\n    ret = minWithColor(ret, sdCylinder(p, shaftRadius, totalLength - capLength, col));\n    ret = minWithColor(ret, sdCone((p - vec3(0, 0, totalLength)), capAngle, capLength, col));\n    return ret;\n}\n\n// sphere\n// p = center\n// r = radius\nSurface sdSphere(vec3 p, float r, vec3 col)\n{\n    return Surface(length(p) - r, col);\n}\n\n// box\n// p = center\n// b = size\nSurface sdBox(vec3 p, vec3 b, vec3 col)\n{\n    vec3 q = abs(p) - b;\n    float d = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n    return Surface(d, col);\n}\n\n// xz-plane\n// p = point on plane\nSurface sdFloor(vec3 p, vec3 col)\n{\n    float d = p.z + 1.0;\n    return Surface(d, col);\n}\n\nmat3 lookAtInv(vec3 lookAtDirection)\n{\n    vec3 forward = normalize(lookAtDirection);\n\n    const vec3 upHint = vec3(0, 1, 0);\n    vec3 rightTest = cross(upHint, forward);\n    vec3 right =\n        length(rightTest) < 0.0001\n            ? normalize(cross(forward, vec3(0, 0, 1)))\n            : normalize(rightTest);\n\n    vec3 up = normalize(cross(forward, right));\n\n    return mat3(right, up, forward);\n}\n\nSurface sdBasis( vec3 p, float scale )\n{\n    float arrowRadius = max(0.015, scale * 0.04);\n\n    vec3 colRed = vec3(1, 0, 0);\n    vec3 colGreen = vec3(0, 1, 0);\n    vec3 colBlue = vec3(0, 0, 1);\n\n    Surface col = EmptySurface;\n    col = minWithColor(col, sdBox(p, vec3(arrowRadius), vec3(1)));\n    col = minWithColor(col, sdArrow(p * lookAtInv(vec3(1, 0, 0)), arrowRadius, scale, colRed));\n    col = minWithColor(col, sdArrow(p * lookAtInv(vec3(0, 1, 0)), arrowRadius, scale, colGreen));\n    col = minWithColor(col, sdArrow(p * lookAtInv(vec3(0, 0, 1)), arrowRadius, scale, colBlue));\n    return col;\n}\n\n","name":"Common","description":"","type":"common"}]}