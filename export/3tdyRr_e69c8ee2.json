{"ver":"0.1","info":{"id":"3tdyRr","date":"1616807642","viewed":102,"name":"Julia Sets Sandbox","username":"jllusty","description":"Playthings for julia sets.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["juliasets"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float pi = 4.*atan(1.);\n\nmat2 rotate(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\nvec2 cmult(in vec2 a, in vec2 b) {\n\treturn vec2(a.x * b.x - a.y * b.y, a.y * b.x + a.x * b.y);\n}\n\nfloat wrap(float x, float a) {\n    return x - a*floor(x/a);\n}\n\nvec2 f(vec2 z) {\n    float a = pi/4.0 + iTime/15.0;\n    vec2 c = 0.7885*vec2(cos(a), sin(a));\n    return (cmult(z,z) + c);\n}\n\n// Smooth HSV to RGB conversion \nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nfloat R = 1.6;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (1.35)*(2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec2 z = uv;\n\n    float max_iter = 1000.;\n    float iter = 0.;\n    while((iter < max_iter) && (length(z) < R)) {\n        z = f(z);\n        iter = iter + 1.;\n    }\n    if (iter < max_iter) {\n        // renormalization\n        iter = iter + 1. - log(log2(length(z)));\n    }\n    \n    // HSV coloring\n    float h = iter/max_iter; //atan(z.y, z.x);\n    float r = log(1.+length(z));\n    float s = (1.+sin(2.0*pi*r))/2.;\n    float v = 1.;\n    if(iter > max_iter) {\n         v = 0.;\n    }\n    vec3 hsv = hsv2rgb_smooth(vec3(h,s,v));\n    \n    vec3 black = vec3(0);\n    vec3 icol = vec3(wrap(float(iter),100.)/10.*hsv);\n    vec3 col = (iter == max_iter)?black:icol;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}