{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"#define R 1.0\n\n#define speed 2.0\n#define max_distance 300.0\n#define epsilon 0.001\n#define max_steps 500\n#define K 0.37\n#define shininess 1.0\n#define ambient 0.4\n#define bump_factor 0.0\n#define specular_koef 40.5\n#define diffuse_koef 2.0\n#define FOV 60.0\n\nfloat ball_vertical = 0.0;\n\n// returns height of water at time t\nfloat water(vec3 point, float t) {\n\tfloat k = 0.6;\n\tfloat h1 = sin(point.x)*1.0;\n\tfloat h2 = sin(point.y)*2.0;\n\tfloat h3 = sin(point.z)*2.0;\n\tfloat h4 = cos(t+point.z+point.x+point.y);\n\t\n\tfloat combined = h1 + h2 + h3 + h4;\n\tcombined = combined / 4.0;\n\treturn combined *k;\n}\n\nvec4 texture3d (sampler2D t, vec3 p, vec3 n, float scale) {\n\treturn \n\t\ttexture(t, p.yz * scale) * abs (n.x) +\n\t\ttexture(t, p.xz * scale) * abs (n.y) +\n\t\ttexture(t, p.xy * scale) * abs (n.z);\n}\n\nfloat smin( float a, float b, float k) {\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat get_distance(vec3 point) {\n\tfloat bump = 0.0;\n\tfloat elevation = -1.0;\n\t\n\tif ( length(point) < R + bump_factor) {\n\t\tbump = bump_factor * texture3d(iChannel1, point, normalize(-point), 0.5).r;\n\t}\n\t\n\tfloat water_h = water(point, iTime*speed);\n\t\n\tvec3 ball_point = point;\n\tball_point.y += ball_vertical;\n\tball_point.y += 0.4;\n\t\n\treturn min(\n\t\tdot(point + water_h, vec3(0.0, 1.0, 0.0)) - elevation,\n\t\tlength(ball_point) - R + bump\n\t\t);\n}\n\nfloat raymarch(vec3 ray_origin, vec3 ray_direction) {\n\tfloat d = 0.0;\n\t\n\tfor (int i = 0; i < max_steps; i++) {\n\t\tvec3 new_point = ray_origin + ray_direction*d;\n\t\tfloat s = get_distance(new_point);\n\t\tif (s < epsilon) return d;\n\t\td += s;\n\t\tif (d > max_distance) return max_distance;\n\t}\n\treturn max_distance;\n}\n\nvec3 get_normal(vec3 point) {\n\tfloat d0 = get_distance(point);\n\tfloat dX = get_distance(point-vec3(epsilon, 0.0, 0.0));\n\tfloat dY = get_distance(point-vec3(0.0, epsilon, 0.0));\n\tfloat dZ = get_distance(point-vec3(0.0, 0.0, epsilon));\n\t\t\n\treturn normalize(vec3(dX-d0, dY-d0, dZ-d0));\n}\n\nmat3 rotateY(float fi) {\n\treturn mat3(\n\t    cos(fi), 0.0, sin(fi),\n\t  \t0.0, 1.0, 0.0,\n\t\t-sin(fi), 0.0, cos(fi)\n\t);\n}\n\nmat3 rotateX(float fi) {\n\treturn mat3(\n\t\t1.0, 0.0, 0.0,\n\t\t0.0, cos(fi), -sin(fi),\n\t\t0.0, sin(fi), cos(fi)\n\t);\t\n}\n\nfloat shadow_sample (vec3 org, vec3 dir) {\n    float res = 1.0;\n    float t = epsilon*200.0;\n    for (int i =0; i < 100; ++i){\n        float h = get_distance (org + dir*t);\n\t\tif (h <= epsilon) {\n            return 0.0;\n\t\t}\n        res = min (res, 32.0*h/t);\n        t += h;\n\t\tif (t >= max_distance) {\n      \t\treturn res;\n\t\t}\n\t\t\n    }\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tball_vertical = 0.3*sin(iTime*speed);\n\tvec2 uv = ((2.0 * fragCoord.xy) - iResolution.xy) / min(iResolution.x, iResolution.y);\n\tuv *= tan (radians (FOV)/2.0);\n\t\n\tvec4 color = vec4(0.0);\n\t\n\tvec3 light = vec3(-1.0, 4.0, 8.0) * rotateY(iTime);\n\t\n\tmat3 rotated = mat3(1.0); //rotateY(sin(iTime/4.0));\n\t\n\tvec3 eye_pos = rotated*vec3(0.0, 0.0, -4.0);\n\tvec3 up = vec3(0.0, 1.0, 0.0);\n\tvec3 forward = rotated*vec3(0.0, 0.0, 1.0);\n\tvec3 right = cross(up, forward);\t\n\t\n\tvec3 ray_dir = normalize(up * uv.y + right *uv.x + forward);\n\n\tfloat d = raymarch(eye_pos, ray_dir);\n\tvec3 point = (eye_pos+ray_dir*d);\t\t\t\n\t\n\tif (d < max_distance) {\t\t\n\t\tvec3 point_normal = get_normal(point);\n\t\t\n\t\tvec3 light_dir = -normalize(light-point);\n\t\tvec3 reflected_light_dir = reflect(-light_dir, point_normal);\n\t\tfloat attenuation = 1.0 / (1.0 + K*pow( length(light - point), 2.0));\n\t\t\t\n\t\tfloat dotp_diffuse = max(0.0, dot(light_dir, point_normal));\n\t\tfloat dotp_specular = pow(max(0.0, dot(ray_dir, reflected_light_dir)), shininess);\n\t\t\n\t\t// no diffuse -> no specular\n\t\tif (dotp_diffuse <= 0.0) dotp_specular = 0.0;\n\t\t\n\t\tfragColor = vec4(0.2, 0.2, 0.6, 1.0) * (ambient + (dotp_diffuse*diffuse_koef + dotp_specular*specular_koef) * shadow_sample(point, -light_dir) * attenuation);// * texture3d(iChannel0, point, point_normal, 0.5);\n\t} else {\t\t\t\n\t    fragColor = vec4(0.1, 0.1, 0.4, 1.0);\t\n\t}\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldsSWH","date":"1400441521","viewed":272,"name":"Raymarched water plane","username":"LukasPukenis","description":"water","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["water"],"hasliked":0,"parentid":"","parentname":""}}