{"ver":"0.1","info":{"id":"7dtXzf","date":"1633673853","viewed":150,"name":"Volume Rendering + Isosurface ","username":"OSevenC","description":"Combine Iso Surface with Volume Rendering","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["isosurface","volumerendering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define LARGE_NUMBER 1e20\n#define MAX_VOLUME_MARCH_STEPS 240//在Volume中光线步进的最大次数\n#define MAX_SDF_DETECT_STEPS 15//最大探测次数，用于确定物体边界\n#define MARCH_STRIDE 0.15//固定的光线步长（在Volume中）\n#define ABSORPTION_COEFFICIENT 0.5\n#define ABSORPTION_CUTOFF 0.25\n\n#define GAMMA_CORRECT\n#define ANIMATION\n#define BOUNDARY 0.5\n#define VOLUME_RENDERING\n\nvec3[] colors = vec3[](\n    vec3(1., 206. / 255., 1. / 255.),\n    vec3(1., 205. / 255., 51. / 255.),\n    vec3(1., 204. / 255., 102. / 255.),\n    vec3(1., 203. / 255., 153. / 255.),\n    vec3(1., 1., 1.),\n    vec3(204. / 255., 237. / 255., 1.),\n    vec3(153. / 255., 205. / 255., 1.),\n    vec3(101. / 255., 173. / 255., 1.),\n    vec3(50. / 255., 141. / 255., 1.)\n    );\nvec3 GetColor(float v)\n{\n    int iv = int(v  * 9.);\n    return colors[iv];\n}\n\nstruct Box {\n    vec3 Position;\n    vec3 Vertex;\n};\n\nBox mBox = Box(\n    vec3(0, 0, 0),\n    vec3(16.0)\n);\n\nstruct Camera\n{\n    vec3 Position;//\n    vec3 LookAt;\n\n    float ImageHeight;//成像高度//根据屏幕长宽比可求宽度\n    float FocalDistance;//焦距\n};\nCamera mCamera = Camera(\n    vec3(120, 20, -165),\n    vec3(0, 0, 0),\n    2.0,\n    7.0\n);\n\n//https://www.shadertoy.com/view/MlsGW8\nbool IntersectBox(vec3 rayOrigin, vec3 rayDirection, vec3 boxEdgeLength, \n    out float tN, out float tF, out vec3 normal)\n{\n    vec3 m = 1. / rayDirection,\n        k = abs(m) * boxEdgeLength,\n        a = -m * rayOrigin - k * .5,\n        b = a + k;\n    normal = -sign(rayDirection) * step(a.yzx, a.xyz) * step(a.zxy, a.xyz);\n    tN = max(max(a.x, a.y), a.z);\n    tF = min(min(b.x, b.y), b.z);\n    return tN < tF;\n}\n\nvec3 CameraOrbit(float speedRatio)//相机在轨道上旋转\n{\n    float theta = iTime * speedRatio;\n    float radius = 165.0;\n\n    return vec3(radius * cos(theta), mCamera.Position.y + 50.0 /** sin(theta*4.0)*/, radius * sin(theta));\n}\n\nvoid SetCamera(in vec2 _uv, in float _aspectRatio, out vec3 _rayOrigin, out vec3 _rayDirection)\n{\n    float ImageWidth = mCamera.ImageHeight * _aspectRatio;\n\n    //vec3 ImagePosition = mCamera.Position;\n    vec3 ImagePosition = CameraOrbit(0.3);\n    vec3 CameraView = mCamera.LookAt - ImagePosition;\n    float ViewLength = length(CameraView);\n    vec3 CameraViewDir = CameraView / ViewLength;\n\n    vec3 CameraRight = cross(CameraViewDir, vec3(0, 1, 0));\n    vec3 CameraUp = cross(CameraRight, CameraViewDir);\n\n    vec3 focalPoint = ImagePosition - mCamera.FocalDistance * CameraViewDir;//焦点位置\n\n    vec3 ImagePoint = ImagePosition;//用Image的中心点初始化成像点\n    //根据uv坐标偏移成像点\n    ImagePoint += CameraRight * (_uv.x * 2.0 - 1.0) * ImageWidth * .5;\n    ImagePoint += CameraUp * (_uv.y * 2.0 - 1.0) * mCamera.ImageHeight * .5;\n\n    _rayOrigin = focalPoint;\n    _rayDirection = normalize(ImagePoint - focalPoint);\n}\n\nvec3 GetAmbientLight()\n{\n    return vec3(0.4);\n}\n\n//https://www.shadertoy.com/view/wssBR8\nfloat BeerLambert(float absorption, float dist)\n{\n    return exp(-absorption * dist);\n}\n\nfloat GetVolumeValue(vec3 pos)\n{\n    float scale = 96.;//32.0*(2.0+sin(iTime));\n    vec3 conner = mBox.Position - mBox.Vertex;\n    float value = texture(iChannel0, (pos - conner) / scale).x;//选取3D纹理的一部分进行采样\n    return value;\n}\n\n//https://www.shadertoy.com/view/MlsGW8\nvec3 GetBoundaryNormal(vec3 ro, vec3 rd, vec3 sz) {\n    vec3 m = 1. / rd,\n        k = abs(m) * sz,\n        a = -m * ro - k * .5, b = a + k;\n    return -sign(rd) * step(a.yzx, a.xyz) * step(a.zxy, a.xyz);\n}\n\n//https://www.shadertoy.com/view/MlsGW8\nvec3 GetNormal(in vec3 p) {\n    vec2 e = vec2(0.5, -0.5);\n    return normalize(\n        e.xyy * GetVolumeValue(p + e.xyy)\n        + e.yyx * GetVolumeValue(p + e.yyx)\n        + e.yxy * GetVolumeValue(p + e.yxy)\n        + e.xxx * GetVolumeValue(p + e.xxx)\n    );\n}\n\n//https://www.shadertoy.com/view/wssBR8\nvec3 Diffuse(in vec3 normal, in vec3 lightVec, in vec3 diffuse)\n{\n    float nDotL = dot(normal, lightVec);\n    return clamp(nDotL * diffuse, 0.0, 1.0);\n}\n\nvoid CalculateLighting(vec3 position, vec3 normal, vec3 reflectionDirection, inout vec3 color)\n{\n    vec3 lightDirection = vec3(-1.0, 1.0, -1.0);//方向光\n    float lightDistance = length(lightDirection);\n    lightDirection /= lightDistance;//normalize\n\n    vec3 lightColor = vec3(1.0, 1.0, 1.0)*0.5 ;\n    vec3 albedo = color;\n    color *= GetAmbientLight();\n    color += lightColor * pow(max(dot(reflectionDirection, lightDirection), 0.0), 4.0);\n    color += lightColor * Diffuse(normal, lightDirection, albedo);\n    //color += GetAmbientLight() * albedo;\n}\n\nvec3 Render(in vec3 rayOrigin, in vec3 rayDirection)\n{\n    vec3 opaquePosition, opaqueNormal;\n    float opaqueDepth = -1.0;\n    float dMin = -1.0;\n    float dMax = LARGE_NUMBER;\n\n    vec3 volumetricColor = vec3(0.0f);\n    vec3 opaqueColor = vec3(0.0f);\n    float opaqueVisiblity = 1.0f;\n    \n    float boundary = BOUNDARY;\n#ifdef ANIMATION\n    boundary +=0.1*sin(iTime);\n#endif\n\n    if (IntersectBox(rayOrigin, rayDirection, mBox.Vertex * 2., dMin, dMax, opaqueNormal) && dMin > 0.0)\n    {\n        vec3 position = rayOrigin + dMin * rayDirection;\n        float value = GetVolumeValue(position);\n        if (value > boundary)//大于这个值的部分变成isosurface\n        {\n            opaqueDepth = dMin;\n            opaquePosition = position;\n            opaqueColor = GetColor(value);\n        }\n        else\n        {\n            float volumeDepth = dMin;\n            for (int i = 0; i < MAX_VOLUME_MARCH_STEPS; i++)\n            {\n                volumeDepth += MARCH_STRIDE;\n                if (volumeDepth > dMax)\n                    break;\n                vec3 position = rayOrigin + volumeDepth * rayDirection;\n\n                float value = GetVolumeValue(position);\n\n                if (value > boundary)//大于这个值的部分变成isosurface\n                {\n                    opaqueDepth = volumeDepth;\n                    opaquePosition = position;\n                    opaqueNormal = GetNormal(position);\n                    opaqueColor = GetColor(value);\n                    break;\n                }\n                float lastVisibility = opaqueVisiblity;\n\n                opaqueVisiblity *= BeerLambert(ABSORPTION_COEFFICIENT * value, MARCH_STRIDE);\n\n                float absorbtion = lastVisibility - opaqueVisiblity;\n\n                volumetricColor += value * GetColor(value) * GetAmbientLight() * absorbtion * 5.0;\n\n            }\n        }\n    }\n    if (opaqueDepth > .0 )//&& opaqueVisiblity > ABSORPTION_CUTOFF)\n    {\n        vec3 reflectionDirection = reflect(rayDirection, opaqueNormal);\n\n        CalculateLighting(opaquePosition, opaqueNormal, reflectionDirection, opaqueColor);\n    }\n#ifdef VOLUME_RENDERING\n    return min(volumetricColor, 1.0f) + opaqueVisiblity * opaqueColor;\n#else\n    return opaqueColor;\n#endif\n}\n\n//https://www.shadertoy.com/view/wssBR8\nvec3 GammaCorrect(vec3 color)\n{\n    return pow(color, vec3(1.0 / 2.2));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    float aspectRatio = iResolution.x / iResolution.y;\n\n    vec3 rayOrigin, rayDirection;\n\n    SetCamera(\n        uv, aspectRatio, //输入\n        rayOrigin, rayDirection//输出\n    );\n\n    vec3 color = Render(rayOrigin, rayDirection);\n    \n#ifdef GAMMA_CORRECT\n    fragColor = vec4(GammaCorrect(clamp(color, 0.0, 1.0)), 1.0);\n#else\n    fragColor=vec4( color, 1.0 );\n    \n#endif\n}","name":"Image","description":"","type":"image"}]}