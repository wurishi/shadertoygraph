{"ver":"0.1","info":{"id":"lclBDM","date":"1724112553","viewed":18,"name":"Monte Carlo Winding number","username":"alpers_shadertoy","description":"Yellow=Inside\nBlue=Outsite\nMonte Carlo method for generalized continuous winding numbers for 2D polygons. The point containment test works even if the polygon is not continuous.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["2dpointcontainmentwindingnumber"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec3 col=texture(iChannel0, fragCoord.xy / iResolution.xy).xyz;\n  \n     \n  \n\tfragColor = vec4(tanh(2.0*col), 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":" const float PI = 3.14159265359;\n\nfloat rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\nfloat rand(vec3 co){ return rand(co.xy+rand(co.z)); }\n\n\nvec3 plasma(float t) {\n    t = clamp(t, 0.0, 1.0);\n\n    const vec3 c[10] = vec3[10](\n        vec3(0.050383, 0.029803, 0.527975),\n        vec3(0.274191, 0.012109, 0.622722),\n        vec3(0.447714, 0.002080, 0.660240),\n        vec3(0.610667, 0.090204, 0.619951),\n        vec3(0.740143, 0.213864, 0.524216),\n        vec3(0.846788, 0.342551, 0.420579),\n        vec3(0.928329, 0.472975, 0.326067),\n        vec3(0.983041, 0.624131, 0.227937),\n        vec3(0.991209, 0.790537, 0.149377),\n        vec3(0.940015, 0.975158, 0.131326)\n    );\n\n    // Scale t to the range [0, 9]\n    float scaledT = t * 9.0;\n    \n    // Find the indices of the two colors to interpolate between\n    int idx = int(floor(scaledT));\n    float frac = fract(scaledT);\n    \n    // Interpolate between the two colors\n    return mix(c[idx], c[idx + 1], frac);\n}\n\nvec2 sampleUniformCircle(vec2 uv) {\n    // sample a point on a unit circle\n    float theta = 2.0 * PI * rand(vec3(uv.xy, iTime));\n    return vec2(cos(theta), sin(theta));\n}\n\n\nfloat rayIntersectsSegment(vec2 o, vec2 d, vec2 a, vec2 b) {\n    vec2 ao = o - a;// v1\n    vec2 ab = b - a;// v2 and d is v3\n    float denom = dot(ab, d);\n    if (abs(denom) < 1e-6) return -1.0;\n    float t = (ab.x * ao.y - ab.y * ao.x) / denom;// v2 X v1\n    float u = dot(ao, d) / denom;// v1 . v3\n    if(t >= 0.0 && u >= 0.0 && u <= 1.0) return t;\n    else return -1.0;\n}\n\nconst int NUM_VERT = 8;\nconst int NUM_IND = 12;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Define the vertices of the non-convex polygon\n    vec2 vertices[NUM_VERT];\n    vertices[0] = vec2(0.1, 0.1);\n    vertices[1] = vec2(0.9, 0.1);\n    vertices[2] = vec2(0.46, 0.5);\n    vertices[3] = vec2(0.54, 0.5);\n    vertices[4] = vec2(0.9, 0.9);\n    vertices[5] = vec2(0.1, 0.9);\n    vertices[6] = vec2(0.28, 0.32);\n    vertices[7] = vec2(0.3, 0.24);\n\n\n    // Normalize fragCoord to the range [0, 1]\n    vec2 uv = fragCoord / iResolution.xy;\n    bool hit = false;\n    \n    //sample a random direction\n    vec2 rayDir = sampleUniformCircle(uv);\n    float curRayT=1e20;\n    float minRayT=1e20;\n    \n    for (int i = 0; i < NUM_VERT; i++) {\n        if(i==2 || i==6) //break the polygon\n            continue;\n        vec2 v0 = vertices[i];\n        vec2 v1 = vertices[(i+1)%NUM_VERT];\n        \n        float curRayT = rayIntersectsSegment(uv, rayDir, v1, v0);\n        \n        if (curRayT > 0.0 && curRayT < minRayT) {\n            minRayT = curRayT;\n            if(dot(v1-v0, rayDir) > 0.0)\n                hit = true;\n            else\n                hit = false;\n        }\n\n    }\n    \n    // Color the pixel based on whether it's inside the polygon\n    vec3 col = plasma(0.0);\n    if(hit)\n        col = plasma(0.9);\n        \n    vec4 prev=texture(iChannel0, uv);\n    prev.w*=0.98;\n    \n    vec4 col1 = vec4(prev.xyz*prev.w, prev.w) + vec4(col,0.9);\n    fragColor = vec4(col1.xyz/col1.w, col1.w);\n}","name":"Buffer A","description":"","type":"buffer"}]}