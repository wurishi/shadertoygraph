{"ver":"0.1","info":{"id":"lsK3WV","date":"1456735503","viewed":1924,"name":"Yet Another Simple Raymarcher","username":"tomkel","description":"Another simple ray marcher with a few primitives and techniques. Nothing clever - rotate with mouse as usual.  ","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["procedural"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 sphere( vec3 spherepos, float r, vec3 raypos )\n{\n //   float disp = texture( iChannel1, raypos.xy * 0.05 ).r;\n   // ec4 clip =vec4( -1.0,-1.0,0,0);\n    \n   // return max( distance( spherepos, raypos ) - r, dot(raypos, normalize(clip.xyz)) - clip.w);\n    return vec4( distance( spherepos, raypos ) - r,1.0,0,0.5); \n}\n\n\nvec4 box( vec3 position, vec3 lengths, vec3 raypos )\n{\n    vec3 p = raypos - position;\n    \n    float d0 = max( p.x - lengths.x, -p.x - lengths.x );\n    float d1 = max( p.y - lengths.y, -p.y - lengths.y );\n    float d2 = max( p.z - lengths.z, -p.z - lengths.z );\n    return vec4( max( d0, max(d1,d2 )), 1.0,0, 0.8);\n}\n\nvec4 cylinder( vec3 position, vec2 dim, vec3 raypos )\n{\n    vec3 p = raypos - position;\n    return vec4( max( length( p.xz ) - dim.x,\n                 max( p.y - dim.y, -p.y - dim.y)), 1.0,0,0.1);\n}\n\nvec4 stage( vec3 raypos, float w, float r )\n{\n\n //   float scale = max( 0.0, 1.0 -  length( raypos.xz) / 40.0 );\n    \n  //  float d = cos( iTime * 10.0 - distance( vec2( 0,0) , raypos.xz) * 0.5 ) * 2.0 + \n    //    \t  cos( iTime * 10.0 - distance( vec2( 10.0,5.0) , raypos.xz) * 1.0 )  * 0.8 + \n    //     \t  cos( iTime * 10.0 - distance( vec2( -10.0,-5.0) , raypos.xz) * 2.0 ) * 0.8;\n    \n    float disp = texture( iChannel0, raypos.xz * 0.01 ).r;\n//    \n    float dome = r - length( raypos );\n    return vec4( min( raypos.y - w - disp * 4.0, dome),0,0,0);\n}\n\n\n\nvec4 getlight( vec3 eye, vec3 normal, vec3 position, vec3 lightpos, vec4 lightcolour  )\n{\n    float d = distance( lightpos, position );\n    vec3 n = normalize( lightpos - position  );\n    \n    vec4 spec = pow( max( dot( normalize( n - eye ), normal ), 0.0 ), 16.0 ) * vec4(1.0,1.0,1.0,1.0);\n   \n    \n    return max( dot( normal, n ), 0.0 ) * lightcolour + spec * 0.25;   \n    \n}\n\nvec4 matmin( vec4 o0, vec4 o1 )\n{\n    if ( o0.x < o1.x )\n    { \n        return o0;\n    }\n    \n    return o1;\n}\n\n\nvec4 smin( vec4 a, vec4 b, float k )\n{\n    float res = exp( -k*a.x ) + exp( -k*b.x );\n    float blend = -log( res )/k;\n    float aw = exp( -k*a.x ) / res;\n    float bw = exp(-k*b.x) / res;\n    \n  \t//vec3 material = a.x/(a.x+b.x) * a.yzw + b.x/(a.x+b.x) * b.yzw;\n    //return vec4( blend, material ); */\n    vec4 colour = aw * a + bw * b;\n    colour.x = blend;\n    return colour;\n}\n\nvec4 softmin( vec4 a, vec4 b, float d )\n{\n    if (abs( a.x-b.x ) > d )\n    {\n        return matmin( a, b );\n    }\n   \telse\n    {\n        float lerp = abs( a.x - b.x ) / d;\n        return matmin(a,b) * lerp +  (a+b)/2.0 * ( 1.0 - lerp );\n        \n    }\n}\n\n\n\nvec4 sdf( vec3 raypos )\n{\n //   float e = abs( cos( iTime ) ) * 10.0;\n    return smin( cylinder( vec3( 20.0, 10.0, 0.0), vec2( 5.0, 20.0), raypos ),\n                smin( box( vec3( -20, 0.0, 20), vec3( 10.0,10.0,10.0), raypos ),\n                    smin( sphere( vec3( 0, 0.0, -20 ), 10.0, raypos ),\n                \t stage( raypos, -10.0, 100.0 ), 1.0\n                   ),1.0\n               ),0.25\n    );\n    \n    //return  stage( raypos, -10.0, 200.0 );\n}\n\nvec3 grad( vec3 raypos, float delta )\n{\n    float dx =  sdf( raypos + vec3( delta, 0,0 ) ).x - sdf( raypos - vec3( delta,0,0 ) ).x;\n    float dy =  sdf( raypos + vec3( 0, delta,0 ) ).x - sdf( raypos - vec3( 0,delta,0 ) ).x;\n    float dz =  sdf( raypos + vec3( 0,0, delta ) ).x - sdf( raypos - vec3( 0,0,delta ) ).x;\n    return vec3( dx,dy,dz );\n}\n\n\nvec4 contact( vec3 position, vec3 normal, float scale )\n{\n    float s = sdf( position + normal * scale ).x;\n    return  (s/scale) * vec4( 1.0,1.0,1.0,1.0);\n    \n}\n\nvec4 shadowlight( vec3 eye, vec3 normal, vec3 origin,  vec3 lightpos, vec4 colour, float ep )\n{\n   vec3 ray = normalize( lightpos - origin);\n    \n    vec4 amb = contact( origin, normal, 4.0 ) * 0.25 ;\n    vec3 p = origin + ray * 2.0;\n    for ( int i = 0; i < 512; i++ )\n    {\n        vec4 sd = sdf(p);\n        float ld = distance( p, lightpos );\n        float step = min( sd.x, ld );\n        if ( sd.x  <  ep )\n        {\n           return amb;\n        }\n        else if ( ld < ep )\n        {\n           return getlight( eye, normal, origin, lightpos, colour ) + amb;\n        }\n        \n        p += ray * step;\n    } \n    \n    \n    return getlight( eye, normal, origin, lightpos, colour ) + amb;\n}\n\nvec4 getDiffuse( float d )\n{\n   // return vec4( 1.0-d,1.0-d,1.0-d,1.0);\n   return (1.0-d) * vec4( 1.0,0.7,0.7,1.0) + d * vec4( 0.9,0.9,1.0,1.0) *d;\n}\n\nvec4 reflectRay( vec3 eye, \n                 vec3 normal, \n                 vec3 origin,\n                 vec4 colour,\n                 vec3 lightpos, \n                 float ep )\n{\n   vec3 ray = reflect( eye, normal );\n    \n    vec3 p = origin + ray * 2.0;\n    for ( int i = 0; i < 512; i++ )\n    {\n        vec4 sd = sdf(p);\n        float step =sd.x;\n        if ( step  <  ep )\n        {\n           vec3 normal = normalize( grad( p, 0.1 ) );\n           return getlight( p, normal, p, lightpos, colour ) * getDiffuse( sd.y );\n        }\n        \n        p += ray * step;\n    } \n    return vec4(0,0,0,1.0);\n   \n}\n\n\n\nvec4 march( vec3 ray, vec3 origin, float ep )\n{\n    vec3 p = origin;\n    vec3 eye = normalize( ray );\n    for ( int i = 0; i < 512; i++ )\n    {\n        vec4 step = sdf(p);\n        if ( step.x  <  ep )\n        {\n            vec4 ref = vec4(0,0,0,0);\n            vec3 normal = normalize( grad( p, 0.1 ) );\n            vec4 lightcol = vec4(1.0,1.0,1.0,1.0) * 0.8;\n            if ( step.w > 0.0 )\n            {\n            \tref = reflectRay( eye, normal, p, lightcol,  vec3( -10,20,-10 ), 0.1 ); \n            }\n            \n //           vec4 cube =  texture( iChannel0, reflect( eye, normal ) ); //reflect( eye, normal ) );\n //           return //shadowlight( eye, normal, p,  vec3( 100,100,100 ), vec4(0.5,0.5,0,1.0 ), ep) + \n   return    shadowlight( eye, normal, p,  vec3( -10,50,-10 ), lightcol, ep) \n            * getDiffuse( step.y ) + ref * step.w;\n           // return cube *  contact( p, normal, 4. );\n        }\n        \n        p += ray * step.x;\n    }\n    \n    return vec4(0.0,0,0,1);\n}\n\nvec3 rotatevecY( vec3 vec, float angle )\n{\n    vec3 m0 = vec3( -cos( angle ), 0, sin( angle ));\n    vec3 m1 = vec3( 0            , 1.0,   0      );\n    vec3 m2 = vec3( sin( angle ), 0, cos( angle ) );\n    \n    return vec3(  dot( m0, vec ), dot( m1, vec ), dot( m2, vec )) ;\n} \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float aspect = iResolution.y / iResolution.x;\n    \n    vec3 origin = vec3(0.0, 2, -50.0 + iMouse.y / iResolution.y * 100.0);\n    vec3 ray = vec3( uv.x - 0.5, (uv.y - 0.5) * aspect, 0.5 );\n    \n\n    \n    ray = rotatevecY( ray, iMouse.x / iResolution.x * 8.0 );\n    origin = rotatevecY( origin,  iMouse.x / iResolution.x * 8.0  );\n\n    \n\tfragColor = march( ray, origin, 0.25);\n}","name":"Image","description":"","type":"image"}]}