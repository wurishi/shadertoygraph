{"ver":"0.1","info":{"id":"3lBSDz","date":"1565536253","viewed":257,"name":"Nested Cubes","username":"omeometo","description":"Inspired by \"Cube in cube in cube in cube\" by TambakoJaguar: https://www.shadertoy.com/view/tlSXzw, but here the structure nested through the faces is not the surface texture but rather cubes in another space.","likes":7,"published":1,"flags":1,"usePreview":0,"tags":["cube","vr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 hash4(int n){\n    return fract(sin(vec4(532.894,392.843,402.942,837.098)*float(n+1))*4444.5);\n}\n\nvoid qrot(inout vec3 v, in vec4 q){ \n\tv += 2.0*cross(cross(v, q.xyz)+q.w*v, q.xyz);\n}\n\nvec3 cube_ray_hit(in float r, in vec4 q, in vec3 c, in vec3 ori, in vec3 rd){\n    ori-=c;\n    qrot(ori, q);\n    qrot(rd, q);\n    vec3 h0=-(ori+sign(rd)*r)/rd;\n    vec3 h1=-(ori-sign(rd)*r)/rd;\n    float t0=max(h0.x, max(h0.y, h0.z));\n    float t1=min(h1.x, min(h1.y, h1.z));\n    if(t1<t0)return vec3(-1);\n    if(t0<1e-9)return vec3(-1);\n    \n    float u=1.0;\n    if(h0.y>h0.x)u=2.0;\n    if(h0.z>max(h0.x, h0.y))u=3.0;\n    \n    vec3 hp=abs(ori+rd*t0);\n    \n    float d=r-min(max(hp.x, hp.y), min(max(hp.y, hp.z), max(hp.z, hp.x)));\n    return vec3(t0, u, d);\n}\n\nvec3 osc(in vec3 u){\n\tu=mod(u, 1.0)*4.0;\n    return abs(u-2.0)-1.0;\n}\n\nvoid getColor(out vec4 fragColor, in vec3 pos, in vec3 ray){\n    int depth=10;\n    int idx=0;\n    int ri=0;\n    for(int d=0;d<depth;d++){\n        float col=0.2;\n        mat4 back=mat4(0,0,0,1,col,0,0,1,0,col,0,1,0,0,col,1);\n        mat4 edge=mat4(1,1,1,1,1,0,0,1,0,1,0,1,0,0,1,1);\n\n        \n        float t=iTime*0.2;\n        vec4 u=normalize(hash4(ri));\n        vec4 v=vec4(hash4(ri+1));\n        v=normalize(v-dot(v,u)*u);\n        vec4 q=cos(t)*u+sin(t)*v;\n        float r=pow(0.5, float(d))*0.5;\n\t\tvec3 c=(0.5-r)*osc(t+hash4(ri+2).xyz)*0.3;\n        \n        vec3 hit=cube_ray_hit(r, q, c, pos, ray);\n        if(hit.y<-0.5){fragColor=back[idx];break;}\n        if(hit.z<0.02*r){\n            fragColor=edge[idx^int(hit.y)];\n            break;\n        }else if(d==depth-1){\n\t\t\tfragColor=back[idx^int(hit.y)];        \t\n        }else{\n            idx^=int(hit.y);\n            ri=ri*3+int(hit.y);\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy)/iResolution.y;\n\t\n    vec3 pos = vec3(0, 0, 3);\n    vec3 eye = -normalize(pos);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    up-=dot(up, eye)*eye;\n    up=normalize(up);\n    vec3 right = cross(eye, up);\n    float angle=0.3;\n    vec3 ray = eye + (uv.x*right+uv.y*up) * angle;\n    ray = normalize(ray);\n\n    getColor(fragColor, pos, ray);\n}\n\nvoid mainVR(out vec4 fragColor, in vec2 fragCoord, in vec3 pos, in vec3 ray){\n\tgetColor(fragColor, pos+vec3(0,0,1), ray);\n}","name":"Image","description":"","type":"image"}]}