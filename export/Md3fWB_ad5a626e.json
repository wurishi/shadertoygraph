{"ver":"0.1","info":{"id":"Md3fWB","date":"1526819857","viewed":307,"name":"Boiling geometry","username":"Moumou38","description":"hexagon party in raymarching with some point lights, trying to get a better understanding of raymarching. Not most optimised I guess. ","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","hexagon","geometry"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MARCHING_STEPS = 30;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10.0;\nconst float EPSILON = 0.0001;\n\nstruct light\n{\n\tvec3 Position;\n\tvec3 Color;\n\tfloat Intensity;\n} PointLight;\n\n\nfloat rand_1_05(in vec2 uv)\n{\n    float noise = (fract(sin(dot(uv ,vec2(12.9898,78.233)*2.0)) * 43758.5453));\n    return noise;\n}\n\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n\t\n}\n\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nmat4 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(c, 0, s, 0),\n        vec4(0, 1, 0, 0),\n        vec4(-s, 0, c, 0),\n        vec4(0, 0, 0, 1)\n    );\n}\n\nmat4 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(1, 0, 0, 0),\n        vec4(0, c, -s, 0),\n        vec4(0, s, c, 0),\n        vec4(0, 0, 0, 1)\n    );\n}\n\nfloat map(vec3 originPos)\n{\n    vec3 q = originPos + vec3(-2.5,-1.3,0.4);\n    float d = 1.0; //sdHexPrism(q,vec2(0.2,0.5));\n    for(int j=0; j< 12; ++j)\n    {\n        for(int i = 0; i < 7; ++i)\n        {\n            //float rand = rand_1_05(vec2(float(i)/iTime*cos(iTime),float(j)/sin(iTime)));\n            vec3 q = q + vec3(float(j)*0.45,float(i)*0.45,(0.05*cos(float(i)*iTime/1.5)*sin(float(j)*iTime)));\n            d = opU(d, sdHexPrism(q,vec2(0.2,0.2)));\n        }\n    }\n    \n    \n    return d;\n}\n\nfloat opRep( vec3 p, vec3 c )\n{\n    //p += vec3(0.0,0.0,sin(iTime));\n    vec3 q = mod(p,c)-0.5*c;\n    return map(q);\n}\n\n\nfloat trace(vec3 o, vec3 r)\n{\n float t= 0.0;\n    for(int i=0; i< MAX_MARCHING_STEPS; ++i) // for number of iteration\n    {\n    \tvec3 p = o + r*t; // until we find intersection\n        //p += vec3(0.0,1.0,0.0);\n        \n        vec3 q = ((rotateX(-90.0)) * vec4(p, 1.0)).xyz;\n        \n        float d =  map(p); //opRep(q, vec3(5.4,1,0));;\n\n        t += d * 0.5; // advancing on ray\n    }\n    return t;\n        \n}\n\nfloat applyFog( float b ) \n{\n    return pow(1.0 / (1.0 + b), 1.0);;\n}\n\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        map(vec3(p.x + EPSILON, p.y, p.z)) - map(vec3(p.x - EPSILON, p.y, p.z)),\n        map(vec3(p.x, p.y + EPSILON, p.z)) - map(vec3(p.x, p.y - EPSILON, p.z)),\n        map(vec3(p.x, p.y, p.z  + EPSILON)) - map(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n\nvec3 pointLight( in vec3 p, in vec3 n, in vec3 v, in vec3 diffuseColor, in vec3 specularColor, in float specularPower, light Light)\n{\n\tvec3 l = normalize(Light.Position - p);\n\tfloat ndotl = max(dot(n, l), 0.0);\n\tvec3 h = normalize(l+v);\n\tfloat ndoth = max(dot(n, h), 0.0);\n\tfloat d = distance(Light.Position, p);\n\tfloat att = 1.f / (d*d);\n\treturn att * Light.Color * Light.Intensity * (diffuseColor * ndotl + specularColor * pow(ndoth, specularPower));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - 1.0; // change coordinates\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 ro = vec3(0.0,0.0,-2.0);\n    vec3 rd = normalize(vec3(uv,1.0)); // normalized so it does not poke geometry close to camera\n\n\n    float t = trace(ro, rd); // distance\n    \n    if (t > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n \n\tvec3 intersection = ro + rd * t;    \n    \n    // scene \n    //vec3 col = vec3(0.5,0.5,1.0); // background\n    \n    //col += vec3(applyFog(t)); // geometry\n    \n   \n    PointLight.Position = vec3(sin(iTime), cos(iTime), ro.z); \n    PointLight.Color = vec3(1.0,0.5,0.8); \n    PointLight.Intensity = 2.0;\n      \n    light point = PointLight;\n    \n    point.Position = vec3(cos(iTime*2.0), sin(iTime/3.14), ro.z); \n    point.Color = vec3(0.0,0.5,0.8); \n    point.Intensity = 2.0;\n    \n    vec3 color = pointLight( intersection, estimateNormal(intersection),-rd, vec3(abs(sin(iTime)),abs(cos(iTime)),abs(cos(iTime))), vec3(1.0,1.0,1.0), 0.0, PointLight)\n        + pointLight( intersection, estimateNormal(intersection),-rd, vec3(abs(sin(iTime)),abs(cos(iTime)),abs(cos(iTime))), vec3(0.0,1.0,1.0), 5.0, point) ;\n    \n\tfragColor = vec4(color , 1.0) ; /* applying the fog last */\n}","name":"Image","description":"","type":"image"}]}