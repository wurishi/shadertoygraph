{"ver":"0.1","info":{"id":"4dlfWN","date":"1496244776","viewed":108,"name":"AleixParellada-PracticaFinal","username":"AleixParelladaENTI","description":"University Project.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["enti"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"////-----------GAMMA CORRECTION-----------\n#define GAMMA\n\n\n////-----------POSTPROCESS-----------\n\n//Changing the postprocess value will change the post process algorithm\n\t//0 - DEFAULT\n\t//1 - PIXELLATION \n\t//2 - VIGNETTING\n\t//3 - TONEMAPPING\n\t//4 - TOON/CONTOUR -> Extracted and modified from (https://www.shadertoy.com/view/XdB3zV)\n\t//5 - COMBINATION OF VIGNETTING+TONEMAPPING+TOON\n\n#define POSTPROCESS 0\n\n\n//-----------GLOBAL VARIABLES-----------\n\n#define PI 3.1415927\n\nstruct Light{\n\tvec3 pos;\n    vec4 color;\n};\n\nLight lights[7];\n\nfloat gamma = 2.2;\n\n\n//-----------PIXELLATION----------- \n#define PixelationSize 1024.0;\n\nfloat pixelWide = 15.0;\nfloat pixelHeight = 15.0;\n\n//Pixellation\nvec2 pixellation(in vec2 q){\n    float Pixels = PixelationSize;\n    float wide  = pixelWide * (1.0 / Pixels);\n\tfloat height = pixelHeight * (1.0 / Pixels);\n\tvec2 newUV = vec2(wide * floor(q.x / wide), height * floor(q.y / height)); \n    q = newUV;\n    return q;\n}\n\n\n//-----------VIGNETTING-----------\nfloat light = 0.8;\nfloat outRadius = 0.5;\nfloat inRadius = 0.4;\n\n//Vignetting\nvec3 vignetting(in vec2 vp, in vec3 col){\n    float posLength = length(vp);\n    float vignetteColor = smoothstep(outRadius,inRadius,posLength);\n    vec3 finalColor = mix(col, col*vignetteColor, light);\n\treturn finalColor;\t\n}\n\n\n//-----------TONEMAPPING-----------\nfloat A = 0.22;\nfloat B = 0.30;\nfloat C = 0.10;\nfloat D = 0.20;\nfloat E = 0.01;\nfloat F = 0.30;\nfloat LinearWhitePointValue = 11.2;\nfloat exposure = 2.0;\n\nvec3 toneMappping(vec3 x){\n\treturn ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\n}\n\nfloat getWhite(){\n\treturn ((LinearWhitePointValue*(A*LinearWhitePointValue+C*B)+D*E)/(LinearWhitePointValue*(A*LinearWhitePointValue+B)+D*F))-E/F;\n}\n\nvec3 toneMapping(in vec2 q, in vec3 col){\n\n    col *= 16.0;\n    \n    col = toneMappping(exposure*col);\n    \n    float whiteScale = 1.0/getWhite();\n\n    col  = col * whiteScale;\n    col = col/ (1.0+col);\n    \n    vec3 finalColor = pow(col, vec3(1.0/2.2));\n\n    return finalColor;\n}\n\n//-----------TOON/CONTOUR-----------\n#define REGIONS 0.99\n#define LINES 11.99\n#define BASE 30.01\n#define GREEN_BIAS 20.01\n\nvec3 posterize(in vec3 col){\n\tcol = pow(col, vec3(gamma, gamma, gamma));\n\tcol = floor(col * REGIONS)/REGIONS;\n\tcol = pow(col, vec3(1.0/gamma));\n\treturn col;\n}\n\nvec3 contour(in vec2 q, vec3 col){\n  \tvec4 lines= vec4(0.30, 0.59, 0.11, 1.0);\n\n\tlines.xyz = lines.xyz * LINES;\n\n \n  \tfloat s11 = dot(texture(iChannel2, q + vec2(-1.0 / iResolution.x, -1.0 / iResolution.y)), lines);   \n  \tfloat s12 = dot(texture(iChannel2, q + vec2(0, -1.0 / iResolution.y)), lines);\n  \tfloat s13 = dot(texture(iChannel2, q + vec2(1.0 / iResolution.x, -1.0 / iResolution.y)), lines);    \n \n\n  \tfloat s21 = dot(texture(iChannel2, q + vec2(-1.0 / iResolution.x, 0.0)), lines);                \n  \tfloat s23 = dot(texture(iChannel2, q + vec2(-1.0 / iResolution.x, 0.0)), lines);                \n \n  \tfloat s31 = dot(texture(iChannel2, q + vec2(-1.0 / iResolution.x, 1.0 / iResolution.y)), lines); \n  \tfloat s32 = dot(texture(iChannel2, q + vec2(0, 1.0 / iResolution.y)), lines);              \n  \tfloat s33 = dot(texture(iChannel2, q + vec2(1.0 / iResolution.x, 1.0 / iResolution.y)), lines); \n \n  \tfloat t1 = s13 + s33 + (2.0 * s23) - s11 - (2.0 * s21) - s31;\n  \tfloat t2 = s31 + (2.0 * s32) + s33 - s11 - (2.0 * s12) - s13;\n \n \n\tif (((t1 * t1) + (t2* t2)) > 0.4){\n  \t\tcol += vec3(-1.,-1.,-1.);\n  \t}\n\telse{\n    \tcol += vec3(0.,0.,0.);\n  \t}\n \n  \treturn col;\n}\n\nvec3 toonShading(in vec3 col, in vec2 q){\n\tvec3 prevCol;\n    prevCol = col;\n  \tprevCol = normalize(texture(iChannel2,q)).rgb*1.1;\t\n\tprevCol.xyz = posterize(col.xyz);\n\tcol += contour(q, prevCol);\n    return col;\n}\n\n\n//-----------BRDF-----------\n\n\n//Fresnel Schlick\nfloat fresnel(float hL, float q)\n{\n    float fresnel = q + (1.0 - q) * (pow(1.0 - hL,5.0));\n    return fresnel;\n}\n\n//Geometry Schlick-Beckmann\nfloat geometry(float nV, float a2)\n{\n    float a = sqrt(a2);\n    float k = a * sqrt(2.0/PI);\n    \n    float geometry = nV / (nV * (1.0 - k) + 1.0);\n\n    return geometry;\n}\n\n// Distribution GGX\nfloat distribution(float nM, float a2)\n{\n    float nM2 = nM * nM;\n    float dividend = (1.0 - (1.0 - a2) * nM2);\n    float distribution = a2 / (PI * dividend * dividend);\n    return distribution;\n}\n\n//BRDF Computation\nvec3 BRDF(vec3 lightPos, vec3 pos, vec3 nor)\n{\n    vec3 halfVector = normalize(lightPos + pos);\n    float roughness = 0.1;\n    \n    float vN = dot(nor, pos);\n    float lN = dot(nor, lightPos);\n    float hN = dot(nor, halfVector);\n    float lH = dot(pos, halfVector);\n    \n    float a = roughness * roughness;\n    float a2 = a * a;\n    \n\tfloat F = fresnel(lH, 0.95);\n\tfloat G = geometry(vN, a2);\n\tfloat D = distribution(hN, a2);\n    \n    vec3 finalColor = vec3((F*G*D)/(4.0* lN * vN));\n    return finalColor;\n}\n\n\n\n////-----------MAIN PROGRAM-----------\n\n#define SC 15.0\n\nfloat fbm( vec3 p, vec3 n )\n{\n\tp *= 0.15;\n\tfloat x = texture( iChannel0, p.yz ).x;\n\tfloat y = texture( iChannel0, p.zx ).x;\n\tfloat z = texture( iChannel0, p.xy ).x;\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n\nfloat distToBox( in vec3 p, in vec3 abc )\n{\n\tvec3 di = max(abs(p)-abc,0.0);\n\treturn dot(di,di);\n}\n\nvec2 column( in float x, in float y, in float z )\n{\n\tvec3 p = vec3( x, y, z );\n\n\tfloat y2=y-0.40;\n    float y3=y-0.35;\n    float y4=y-1.00;\n\n    float di1=distToBox( p, vec3(0.10*0.85,1.00,0.10*0.85) );\n    float di2=distToBox( p, vec3(0.12,0.40,0.12) );\n    float di3=distToBox( vec3(x,y4,z), vec3(0.14,0.02,0.14) );\n    x = max( abs(p.x), abs(p.z) );\n    z = min( abs(p.x), abs(p.z) );\t\n    float di4=distToBox( vec3(x, y, z), vec3(0.14,0.35,0.05) );\n    float di5=distToBox( vec3(x, (y2+z)*0.7071, (z-y2)*0.7071), vec3(0.12, 0.10*0.7071, 0.10*0.7071) );\n    float di6=distToBox( vec3(x, (y3+z)*0.7071, (z-y3)*0.7071), vec3(0.14, 0.10*0.7071, 0.10*0.7071) );\n\n    float dm = min(min(min(di5,di6),min(di3,di4)),di2);\n\t\n\tvec2 res = vec2( dm, 3.0 );\n\tif( di1<res.x ) res = vec2( di1, 2.0 );\n\n\treturn vec2( sqrt(res.x), res.y );\n}\n\nvec3 map( vec3 pos )\n{\npos /= SC;\n    float sid = 0.0;\n    float dis;\n\n    // floor\n\tfloat mindist = pos.y;\n\n    // ceilin\n\tfloat x = fract( pos.x+128.0 ) - 0.5;\n\tfloat z = fract( pos.z+128.0 ) - 0.5;\n    float y = 1.0 - pos.y;\n\tdis = -sqrt( y*y + min(x*x,z*z)) + 0.4;\n\tdis = max( dis, y );\n    if( dis<mindist )\n    {\n        mindist = dis;\n        sid = 1.0;\n    }\n\n    // columns\n\tvec2 fc = fract( pos.xz+128.5 ) - 0.5;\n\tvec2 dis2 = column( fc.x, pos.y, fc.y );\n\t\t\n    if( dis2.x<mindist )\n    {\n        mindist = dis2.x;\n        sid = dis2.y;\n    }\n\t\n\t//float dsp = 1.0*clamp(pos.y,0.0,1.0)*abs(sin(6.0*pos.y)*sin(50.0*pos.x)*sin(4.0*6.2831*pos.z));\n    float dsp = 1.0*clamp(pos.y,0.0,1.0)*abs(sin(12.0*pos.y)*sin(100.0*pos.x)*sin(8.0*6.2831*pos.z));\n\tmindist -= dsp*0.03*0.25;\n\n    return vec3(mindist*SC,sid,dsp);\n}\n\nvec3 calcColor( in vec3 pos, in vec3 nor, in float sid )\n{\n\tvec3 col = vec3( 1.0 );\n\n    float kk = fbm( 32.0*pos, nor );\n\n    if( sid<0.5 )\n\t{\n\t\tvec2 peldxz = fract( 3.0*12.0*pos.xz );\n\t\tpeldxz = 4.0*peldxz*(1.0-peldxz);\n\t\tfloat de = 20.0*length(fwidth(pos.xz));\n\t\tfloat peld = smoothstep( 0.15-de, 0.15+de, min( peldxz.x, peldxz.y ) );\n\t\tcol = 0.05 + 0.95*vec3(peld);\n        col = pow( texture( iChannel1, 6.0*pos.xz ).xyz, vec3(2.20) );\n\t}\n    else if( sid>0.5 && sid<1.5 )\n\t{\n\t\tfloat fx = fract( pos.x+128.0 ); \n\t    float fz = fract( pos.z+128.0 ); \n\t\tcol = vec3(0.7,0.7,0.7);\n\t\tfloat p = 1.0;\n\t\tp *= smoothstep( 0.02, 0.03, abs(fx-0.1) );\n\t\tp *= smoothstep( 0.02, 0.03, abs(fx-0.9) );\n\t\tp *= smoothstep( 0.02, 0.03, abs(fz-0.1) );\n\t\tp *= smoothstep( 0.02, 0.03, abs(fz-0.9) );\n\t\tcol = mix( 0.75*vec3(0.3,0.15,0.15), col, p );\n\t}\n    else if( sid>1.5 && sid<2.5 )\n\t{\n\t\tfloat l = fract( 12.0*pos.y );\n\t\tfloat peld = smoothstep( 0.1, 0.2, l );\n\t\tcol = 0.05 + 0.95*vec3(peld);\n\t}\n\t\n    return col * 2.0 * kk;\t\n}\n\nvec3 castRay( in vec3 ro, in vec3 rd, in float precis, in float startf, in float maxd )\n{\n    float h = precis*10.0;\n    vec3 c;\n    float t = h*4.0;\n    float dsp = 0.0;\n    float sid = -1.0;\n    for( int i=0; i<50; i++ )\n    {\n        if( abs(h)<precis||t>maxd ) break;\n        t += h;\n\t    vec3 res = map( ro+rd*t );\n        h = res.x;\n\t    sid = res.y;\n\t\tdsp = res.z;\n    }\n\n    if( t>maxd ) sid=-1.0;\n    return vec3( t, sid, dsp );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<32; i++ )\n    {\n        float h = map( ro + rd*t ).x;\n        res = min( res, k*h/t );\n        t += h;\n\t\tif( t>maxt ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nvec3 doBumpMap( in vec3 pos, in vec3 nor )\n{\n    float e = 0.0015;\n    float b = 0.005;\n    \n\tfloat ref = fbm( 48.0*pos, nor );\n    vec3 gra = -b*vec3( fbm(48.0*vec3(pos.x+e, pos.y, pos.z),nor)-ref,\n                        fbm(48.0*vec3(pos.x, pos.y+e, pos.z),nor)-ref,\n                        fbm(48.0*vec3(pos.x, pos.y, pos.z+e),nor)-ref )/e;\n\t\n\tvec3 tgrad = gra - nor * dot ( nor , gra );\n    return normalize ( nor - tgrad );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float ao = 0.0;\n    float sca = 15.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = SC*(0.01 + 0.015*float(i*i));\n        float dd = map( pos + hr*nor ).x;\n        ao += (hr-dd)*sca/SC;\n        sca *= 0.5;\n    }\n    return 1.0 - clamp( ao, 0.0, 1.0 );\n}\n\n//Function for suming the colors based on the BRDF and the light color\nvec3 sumColor(in Light lights, in vec3 lig, in vec3 pos, in vec3 nor, in float ao, in vec3 lin, in vec3 ro, in vec3 rd, in vec3 spe, in int returnValue){\n    lights.color.xyz += BRDF(lig, pos, nor);\n\n    float llig = dot( lig, lig);\n    float im = inversesqrt( llig );\n    lig = lig * im;\n    \n\n    float dif = dot( nor, lig );\n    dif = clamp( dif, 0.0, 1.0 );\n\tfloat at = 2.0*exp2( -2.3*llig )*lights.color.w;\n    dif *= at;\n    float at2 = exp2( -0.35*llig );\n\n\tfloat sh = 0.0;\n\tif( dif>0.02 ) { \n    \tsh = softshadow( pos*SC, lig, 0.02*SC, sqrt(llig)*SC, 32.0 ); \n        dif *= sh; \n    }\n    \t    \n    float dif2 = clamp( dot(nor,normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 );\n    lin += 0.20*ao*sh*vec3(0.35,0.20,0.10)*at2;\n    lin += 2.50*ao*dif*lights.color.xyz;\n\t\t\t\n\tfloat pp = clamp( dot( reflect(rd,nor), lig ), 0.0, 1.0 );\n\tspe += ao*lights.color.xyz*at*sh*(pow(pp,16.0) + 0.5*pow(pp,4.0)); \n\n\n    if(returnValue == 1){    \n    return lin;\n        }\n    \n    if(returnValue == 2){\n    \treturn vec3(ao);\n    }\n    \n    if(returnValue == 3){\n    \treturn spe;\n    }\n}\n\n//Function for computing the final color that the scene will have\nvec3 computeFinalColor(in vec3 col, in float ao, in vec3 nor, in vec3 pos, in vec3 lin, in vec3 spe){\n    col += mix( col, vec3(0.1,0.3,0.0), sqrt(max(1.0-ao*1.4,0.0))*smoothstep(-0.5,-0.1,nor.y) );\n    col = mix( col, vec3(0.1,0.3,0.0), (1.0-smoothstep( 0.0, 0.12, abs(nor.y) - 0.1*(1.0-smoothstep(-0.1,0.3,pos.y)) ))*(1.0-smoothstep(0.5,1.0,pos.y)) );\n    \n    col = col*lin;\n\n    col += 3.0*spe*vec3(1.0,0.6,0.2);\n    \n    return col;\n}\n\n//Render function for rendering the scene and the lights\nvec3 render( in vec3 ro, in vec3 rd, in vec3 pos, in vec3 nor, float m)\n{ \n\n    for( int i=0; i<7; i++ ){\n\t    float la = 1.0;\n        lights[i].pos.x = 0.5 + 2.2*cos(0.22+0.1*iTime + 17.0*float(i) );\n\t    lights[i].pos.y = 0.25;\n\t    lights[i].pos.z = 1.5 + 2.2*cos(2.24+0.1*iTime + 13.0*float(i) );\n\n\t\t// make the lights avoid the columns\n        vec2 ilpos = floor( lights[i].pos.xz );\n        vec2 flpos = lights[i].pos.xz - ilpos;\n        flpos = flpos - 0.5;\n        if( length(flpos)<0.2 ) flpos = 0.2*normalize(flpos);\n\t    lights[i].pos.xz = ilpos + flpos;\n\t\t\n        lights[i].pos *= SC;\n        \n        float li = sqrt(0.5 + 0.5*sin(2.0*iTime+ 23.1*float(i)));\n\n        float h = float(i)/8.0;\n\t\tvec3 c = mix( vec3(1.0,0.8,0.6), vec3(1.0,0.3,0.05), 0.5+0.5*sin(40.0*h) );\n\t    lights[i].color = vec4( c, li );\n\t}\n\n   \tvec3 col = vec3(0.0);\n    vec3 res = castRay(ro,rd,0.001*SC,0.025*SC,20.0*SC);\n    float t = res.x;\n    \n    if( m >-0.5 ){\n\t\tpos /= SC;\n\t\tt /= SC;\n        col = calcColor( pos, nor, m );\n \t\tnor = doBumpMap( pos, nor );\n        float ao = calcAO(pos,nor);\n        ao *= 0.7 + 0.6 * res.z;\n\t\tvec3 spe = vec3(0.0);\n\t\tvec3 lin = 0.03*ao*vec3(0.25,0.20,0.20)*(0.5+0.5*nor.y);\n\n\n\tfor(int i = 0; i < 7; i++){\n        //Getting the sumatory of colors\n        vec3 lig = lights[i].pos / SC - pos;\n\n        lin += sumColor(lights[i], lig, pos, nor, ao, lin, ro, rd, spe, 1);\n\t\tao =sumColor(lights[i], lig, pos, nor, ao, lin, ro, rd, spe, 2).x;\n        spe += sumColor(lights[i], lig, pos, nor, ao, lin, ro, rd, spe, 3);\n        \n        }\n        \n        //Computing the final color\n\t\tcol = computeFinalColor(col, ao, nor, pos, lin, spe);\n    }\n        \nelse\n    \n\tt /= SC;\n\tcol *= exp( -0.055*t*t );\n\n    // lights\n\tfor( int i=0; i<7; i++ )\n\t{\n        vec3 lv = lights[i].pos /SC - ro/SC;\n        float ll = length( lv );\n        if( ll<t )\n        {\n            float dle = clamp( dot( rd, lv/ll ), 0.0, 1.0 );\n\t\t\tdle = (1.0-smoothstep( 0.0, 0.2*(0.7+0.3*lights[i].color.w), acos(dle)*ll ));\n            col += dle*6.0*lights[i].color.w*lights[i].color.xyz*dle*exp( -0.07*ll*ll );;\n        }\n    }\n\t\n\treturn col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n \tvec2 vp = fragCoord.xy/iResolution.xy - 0.5;\n    \n    //Pixellation post process\n    if(POSTPROCESS == 1){\n\t\tq = pixellation(q);\n    }\n    \n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tvec4 gBuffer = texture(iChannel2,q).xyzw;\n\tfloat time = iTime;\n\n\t//Camera\t\n\tvec3 ce = vec3( 0.5, 0.25, 1.5 );\n\tvec3 ro = ce + vec3( 1.3*cos(0.11*time + 6.0*mo.x), 0.65*(1.0-mo.y)- 0.2, 1.3*sin(0.11*time + 6.0*mo.x) );\n\tvec3 ta = ce + vec3( 0.95*cos(1.2+.08*time), 0.4*0.25+0.75*ro.y- 0.2, 0.95*sin(2.0+0.07*time) );\n\tro *= SC;\n\tta *= SC;\n\tfloat roll = -0.15*sin(0.1*time);\n\t\n\t//Camera tx\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( sin(roll), cos(roll),0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 1.5*cw );\n\tmat3 ca = mat3(cu,cv,cw);\n\n    \n     //Unpacking\n    //Normals - Using Spheremap Transform\n    vec2 normalsPacked;\n    normalsPacked = gBuffer.xy;\n    vec4 normals = vec4(normalsPacked,0,0) * vec4(2.0,2.0,0.0,0.0) + vec4(-1.0,-1.0,1.0,-1.0);\n    float l = dot(normals.xyz, -normals.xyw);\n    normals.z = l;\n    normals.xy *= sqrt(l);\n    vec3 normalsUnpacked = normals.xyz * vec3(2.0) + vec3(0.0,0.0,-1.0);\n    \n    //Reconverting the normals from view space to world space \n    normalsUnpacked *= ca;\n\n    //Position\n    float depth = gBuffer.z;\n    const float a = (20.0 + 1.0) / (20.0-1.0);\n    const float b = 2.0 * 20.0 * 1.0 / (20.0-1.0);\n    vec3 position = ro + rd * (b/(a-depth));\n    \n    //Material ID\n    float matID = gBuffer.w;\n    \n    \n    vec3 col = render( ro, rd, position, normalsUnpacked, matID);\n\n    //Default postprocess\n    if(POSTPROCESS == 0){\n    \tcol = sqrt( col );\n     }\n\t\n\n    //Default Vignetting implemented\n    if(POSTPROCESS != 2 || POSTPROCESS != 5 || POSTPROCESS != 4){\n    col *= 0.25+0.75*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.15 );\n\t}\n    \n    //Tonemapping\n    if(POSTPROCESS == 3 || POSTPROCESS == 5){\n    \tcol = toneMapping(p,col);\n    }\n \n    //Combination of post process\n    if(POSTPROCESS == 4 || POSTPROCESS == 5){\n\t\tcol = toonShading(col, q);       \n        \n\t}\n    \n    //Vignetting PostProcess\n    if(POSTPROCESS == 2 || POSTPROCESS == 5){\n\t\tcol = vignetting(vp, col);\n    }\n    \n    //Gamma Correction\n    #ifdef GAMMA\n    col = (pow(col,vec3(gamma)));\n    #else\n        col = (pow(col,vec3(1.0/gamma)));\n    #endif\n    \n \n    fragColor=vec4( col, 1.0 );\n}\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define SC 15.0\n\nfloat fbm( vec3 p, vec3 n )\n{\n\tp *= 0.15;\n\tfloat x = texture( iChannel0, p.yz ).x;\n\tfloat y = texture( iChannel0, p.zx ).x;\n\tfloat z = texture( iChannel0, p.xy ).x;\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n\nfloat distToBox( in vec3 p, in vec3 abc )\n{\n\tvec3 di = max(abs(p)-abc,0.0);\n\treturn dot(di,di);\n}\n\nvec2 column( in float x, in float y, in float z )\n{\n\tvec3 p = vec3( x, y, z );\n\n\tfloat y2=y-0.40;\n    float y3=y-0.35;\n    float y4=y-1.00;\n\n    float di1=distToBox( p, vec3(0.10*0.85,1.00,0.10*0.85) );\n    float di2=distToBox( p, vec3(0.12,0.40,0.12) );\n    float di3=distToBox( vec3(x,y4,z), vec3(0.14,0.02,0.14) );\n    x = max( abs(p.x), abs(p.z) );\n    z = min( abs(p.x), abs(p.z) );\t\n    float di4=distToBox( vec3(x, y, z), vec3(0.14,0.35,0.05) );\n    float di5=distToBox( vec3(x, (y2+z)*0.7071, (z-y2)*0.7071), vec3(0.12, 0.10*0.7071, 0.10*0.7071) );\n    float di6=distToBox( vec3(x, (y3+z)*0.7071, (z-y3)*0.7071), vec3(0.14, 0.10*0.7071, 0.10*0.7071) );\n\n    float dm = min(min(min(di5,di6),min(di3,di4)),di2);\n\t\n\tvec2 res = vec2( dm, 3.0 );\n\tif( di1<res.x ) res = vec2( di1, 2.0 );\n\n\treturn vec2( sqrt(res.x), res.y );\n}\n\nvec3 map( vec3 pos )\n{\npos /= SC;\n    float sid = 0.0;\n    float dis;\n\n    // floor\n\tfloat mindist = pos.y;\n\n    // ceilin\n\tfloat x = fract( pos.x+128.0 ) - 0.5;\n\tfloat z = fract( pos.z+128.0 ) - 0.5;\n    float y = 1.0 - pos.y;\n\tdis = -sqrt( y*y + min(x*x,z*z)) + 0.4;\n\tdis = max( dis, y );\n    if( dis<mindist )\n    {\n        mindist = dis;\n        sid = 1.0;\n    }\n\n    // columns\n\tvec2 fc = fract( pos.xz+128.5 ) - 0.5;\n\tvec2 dis2 = column( fc.x, pos.y, fc.y );\n\t\t\n    if( dis2.x<mindist )\n    {\n        mindist = dis2.x;\n        sid = dis2.y;\n    }\n\t\n\t//float dsp = 1.0*clamp(pos.y,0.0,1.0)*abs(sin(6.0*pos.y)*sin(50.0*pos.x)*sin(4.0*6.2831*pos.z));\n    float dsp = 1.0*clamp(pos.y,0.0,1.0)*abs(sin(12.0*pos.y)*sin(100.0*pos.x)*sin(8.0*6.2831*pos.z));\n\tmindist -= dsp*0.03*0.25;\n\n    return vec3(mindist*SC,sid,dsp);\n}\n\nvec3 calcColor( in vec3 pos, in vec3 nor, in float sid )\n{\n\tvec3 col = vec3( 1.0 );\n\n    float kk = fbm( 32.0*pos, nor );\n\n    if( sid<0.5 )\n\t{\n\t\tvec2 peldxz = fract( 3.0*12.0*pos.xz );\n\t\tpeldxz = 4.0*peldxz*(1.0-peldxz);\n\t\tfloat de = 20.0*length(fwidth(pos.xz));\n\t\tfloat peld = smoothstep( 0.15-de, 0.15+de, min( peldxz.x, peldxz.y ) );\n\t\tcol = 0.05 + 0.95*vec3(peld);\n        col = pow( texture( iChannel1, 6.0*pos.xz ).xyz, vec3(2.20) );\n\t}\n    else if( sid>0.5 && sid<1.5 )\n\t{\n\t\tfloat fx = fract( pos.x+128.0 ); \n\t    float fz = fract( pos.z+128.0 ); \n\t\tcol = vec3(0.7,0.7,0.7);\n\t\tfloat p = 1.0;\n\t\tp *= smoothstep( 0.02, 0.03, abs(fx-0.1) );\n\t\tp *= smoothstep( 0.02, 0.03, abs(fx-0.9) );\n\t\tp *= smoothstep( 0.02, 0.03, abs(fz-0.1) );\n\t\tp *= smoothstep( 0.02, 0.03, abs(fz-0.9) );\n\t\tcol = mix( 0.75*vec3(0.3,0.15,0.15), col, p );\n\t}\n    else if( sid>1.5 && sid<2.5 )\n\t{\n\t\tfloat l = fract( 12.0*pos.y );\n\t\tfloat peld = smoothstep( 0.1, 0.2, l );\n\t\tcol = 0.05 + 0.95*vec3(peld);\n\t}\n\t\n    return col * 2.0 * kk;\t\n}\n\nvec3 castRay( in vec3 ro, in vec3 rd, in float precis, in float startf, in float maxd )\n{\n    float h = precis*10.0;\n    vec3 c;\n    float t = h*4.0;\n    float dsp = 0.0;\n    float sid = -1.0;\n    for( int i=0; i<50; i++ )\n    {\n        if( abs(h)<precis||t>maxd ) break;\n        t += h;\n\t    vec3 res = map( ro+rd*t );\n        h = res.x;\n\t    sid = res.y;\n\t\tdsp = res.z;\n    }\n\n    if( t>maxd ) sid=-1.0;\n    return vec3( t, sid, dsp );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<32; i++ )\n    {\n        float h = map( ro + rd*t ).x;\n        res = min( res, k*h/t );\n        t += h;\n\t\tif( t>maxt ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nvec3 doBumpMap( in vec3 pos, in vec3 nor )\n{\n    float e = 0.0015;\n    float b = 0.005;\n    \n\tfloat ref = fbm( 48.0*pos, nor );\n    vec3 gra = -b*vec3( fbm(48.0*vec3(pos.x+e, pos.y, pos.z),nor)-ref,\n                        fbm(48.0*vec3(pos.x, pos.y+e, pos.z),nor)-ref,\n                        fbm(48.0*vec3(pos.x, pos.y, pos.z+e),nor)-ref )/e;\n\t\n\tvec3 tgrad = gra - nor * dot ( nor , gra );\n    return normalize ( nor - tgrad );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float ao = 0.0;\n    float sca = 15.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = SC*(0.01 + 0.015*float(i*i));\n        float dd = map( pos + hr*nor ).x;\n        ao += (hr-dd)*sca/SC;\n        sca *= 0.5;\n    }\n    return 1.0 - clamp( ao, 0.0, 1.0 );\n}\n\nvec3 render( in vec3 ro, in vec3 rd, int get)\n{ \n    vec3 col = vec3(0.0);\n    vec3 res = castRay(ro,rd,0.001*SC,0.025*SC,20.0*SC);\n    float t = res.x;\n\n\tvec3 pos = ro + t*rd;\n    vec3 nor = calcNormal( pos );\n\n     nor = doBumpMap( pos, nor );\n\n    if(get == 1){\n       \tcol = pos;\n       }\n        \n    if(get == 2){\n       \tcol = nor;\n       }\n        \n    if(get == 3){\n       \tcol = res;\n       }\n    \n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = iTime;\n\n\t// camera\t\n\tvec3 ce = vec3( 0.5, 0.25, 1.5 );\n\tvec3 ro = ce + vec3( 1.3*cos(0.11*time + 6.0*mo.x), 0.65*(1.0-mo.y)- 0.2, 1.3*sin(0.11*time + 6.0*mo.x) );\n\tvec3 ta = ce + vec3( 0.95*cos(1.2+.08*time), 0.4*0.25+0.75*ro.y- 0.2, 0.95*sin(2.0+0.07*time) );\nro *= SC;\nta *= SC;\n\tfloat roll = -0.15*sin(0.1*time);\n\t\n\t// camera tx\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( sin(roll), cos(roll),0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 1.5*cw );\n\t\n    \n    mat3 ca = mat3(cu,cv,cw);\n    \n\tvec3 normals = render(ro,rd,2);\n\tnormals = inverse(ca) * normals;\n    \n    //Packing\n     \n   //Packing variables\n   //Normals - Using Spheremap Transform\n\n    vec4 gBuffer = vec4(normals.xyz,1.0);\n    vec2 normalsPacked;\n    \n    normalsPacked = normalize(normals.xy)*(sqrt(-normals.z*0.5+0.5));\n    normalsPacked = normalsPacked*0.5+0.5;\n    gBuffer.x = normalsPacked.x;\n    gBuffer.y = normalsPacked.y;\n    \n    float far = 20.0;\n\tfloat near = 1.0;\n    \n    //Getting the depth using the formula:\n    \n    \t/*const float a = (far + near) / (far - near);\n\t\tconst float b = 2.0 * far * near / (far - near);\n\t\t...\n\t\tfloat depth = a + b / -length(camEye - worldPos);\n\t\t*/\n    \n    vec3 position = render(ro,rd,1);\n    float a = (far + near) / (far - near);\n    float b = 2.0 * far * near / (far - near);\n    float depth = a + b / -length(ro - position);\n    gBuffer.z = depth;\n    \n    //MaterialID\n    gBuffer.w = render(ro,rd,3).y;\n    \n    fragColor = vec4(gBuffer);\n}","name":"Buf A","description":"","type":"buffer"}]}