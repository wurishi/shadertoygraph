{"ver":"0.1","info":{"id":"XfsBWf","date":"1724722929","viewed":10,"name":"Big Mommy Neon Tubers","username":"gllama","description":"I kinda want to make the beams closer to IRL neon-light tubes. Eg kinda toon shaded where brighter on the edges\n\nIn due time...","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","grid","sdf","distortion","projection","spherical","equirectangular","3dgrid"],"hasliked":0,"parentid":"4csBzf","parentname":"Ahhh yes of course."},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 🫃 Big Mommy Neon Tubers (Equirectangular)\n// License CC0-1.0\n// - gllama\n// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// Shoutout @DamnXYZ see distort_space() func\n// Learned a ton about Neon from @alro - MIT License - https://www.shadertoy.com/view/WdK3Dz\n// Feat: SDF Techniques from @shadertoyjiang given in comments on previous attempt https://www.shadertoy.com/view/4csBzf\n// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n// Modified version of @DamnXYZ's effect - License Unkown - https://www.shadertoy.com/view/wdBcW3\nvec3 distort_space(vec3 p){\n    float osc = .5 + .5*sin(iTime);\n    p.x += osc * sin(p.z)*.5;\n    p.y += osc * cos(p.z)*.5+.5;\n    return p;\n}\n\n\n// This function let's us jump from 2D-UV to spherical 3D-XYZ position\nvec3 uvTo3D(vec2 uv) {\n    // The 2-Sphere point via UV => Lat/Long angles\n    float theta = uv.x * 2.0 * 3.14159265359; // Longitude\n    float phi = uv.y * 3.14159265359; // Latitude\n    // Trigonometry from 2-Sphere angles to an XYZ normalized [-1,1].\n    float x = sin(phi) * cos(theta);\n    float y = sin(phi) * sin(theta);\n    float z = cos(phi);\n    // { Dev Note }\n    // If you're porting this shader to a material, I strongly recommend you skip this function and just use the XYZ of your 'varying vNormal' in place of the result you would get here. Should be suitable for all spheres and most round geometries\n    return vec3(x, y, z);\n}\n\nfloat sdfLine(vec3 p) {\n    float radius = .002;\n    //p*=1.2+sin(iTime/10.)/2.;\n    // 3 Techniques below from @shadertoyjiang 🙏 - License Unkown - https://www.shadertoy.com/user/shadertoyjiang \n    // From comment on previous attempt > https://www.shadertoy.com/view/4csBzf\n    p*=.5;\n    \n    p = p-round(p);\n    p = abs(p);\n    vec3 m = step(p.yzx,p)*step(p.zxy,p); // The largest component becomes \"1\", and the other two components become \"0\".\n    p -= p * m;\n    return length(p)-.002;\n    \n    \n    \n    p = p-round(p);\n    p = abs(p);\n    float maxxyz = max(p.x,max(p.y,p.z)),\n          lengthpp = dot(p,p);    \n    return sqrt(lengthpp-maxxyz*maxxyz)-.002;   \n    \n    \n    \n    p = p-round(p);\n    p = abs(p);\n    if(p.x<p.y)p.xy=p.yx;\n    if(p.x<p.z)p.xz=p.zx;\n    return length(p.yz)-.002;\n    \n    \n    float closestXLine = length(vec2(round(p.yz))-p.yz)-radius;\n    float closestYLine = length(vec2(round(p.xz))-p.xz)-radius;\n    float closestZLine = length(vec2(round(p.xy))-p.xy)-radius;\n    return min(closestXLine,min(closestYLine,closestZLine));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor= vec4(0.);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 pos = uvTo3D(uv); // UV => 3D for equirectangular/spherical mapping\n    \n    \n    // Simple raymarching blog reference: https://michaelwalczyk.com/blog-ray-marching.html\n    const float MINIMUM_HIT_DISTANCE = 0.02;//0.001;\n    //int NUMBER_OF_STEPS = 26+int(25.*sin(iTime));\n    const int NUMBER_OF_STEPS = 25;\n    float total_distance_traveled = 0.;\n    // Fix RO overshoot\n    pos*=.85;\n    float distance_to_closest;\n    //fragColor=(vec4(sdfLine(pos)));\n    for (int i = 0; i < NUMBER_OF_STEPS; ++i){\n        vec3 current_position = pos/1.2+iTime + total_distance_traveled * pos;\n        distance_to_closest = sdfLine(distort_space(current_position));\n        //fragColor.z+=sqrt(length(current_position));\n        if (distance_to_closest < MINIMUM_HIT_DISTANCE) // hit\n        {\n            //fragColor.x=(1./total_distance_traveled);\n            //fragColor.y=(1./total_distance_traveled);\n            //fragColor.w=1.;\n            \n            //fragColor.z=1.;//fragColor.z/(fragColor.z);\n            //fragColor*=pow(.02/total_distance_traveled, .2);\n            //fragColor.z=fragColor.z;\n            break;\n        }\n        \n        //fragColor.x = normalize(fragColor.x);//\n        //fragColor.y = normalize(fragColor.y);//\n        //fragColor.z = normalize(fragColor.z);//\n        //fragColor.w = \n        //fragColor. = normalize(fragColor.)\n         \n        total_distance_traveled += distance_to_closest;\n        //if(total_distance_traveled>2.){break;}\n    }\n    //fragColor=normalize(fragColor);\n    //fragColor = normalize(fragColor);\n    \n    // Technique from @alro - MIT License - https://www.shadertoy.com/view/WdK3Dz\n    fragColor.rgb += 10.0*vec3(smoothstep(0.02, 0.01,distance_to_closest));\n\n    //fragColor.rgb += 10.0*vec3(smoothstep(0.02+(sin(iTime)+1.)/10., 0.01+(sin(iTime)+1.)/10.,distance_to_closest));\n    fragColor.rgb += pow(.2/distance_to_closest, 1.3)*vec3(.2,.01,.4);\n    //fragColor *= pow(.02/total_distance_traveled, .2);\n}\n\n/* \n// 🪦 \n// This doesn't work I don't even know what this would \n// be an SDF for. (if anything?)\nfloat sdfLine(vec3 p) {\n    float radius = .001;\n    //p*=10.;\n    float closestXLine = length(vec3(round(p.x),p.yz)-p)-radius;\n    float closestYLine = length(vec3(p.x,round(p.y),p.z)-p)-radius;\n    float closestZLine = length(vec3(p.xy,round(p.z))-p)-radius;\n    return min(closestXLine,min(closestYLine,closestZLine));\n}\n*/","name":"Image","description":"","type":"image"}]}