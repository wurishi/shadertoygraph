{"ver":"0.1","info":{"id":"wsXfDN","date":"1588262208","viewed":372,"name":"Grid Floor Antialiased","username":"bloxard","description":"Fiddling around with the derivative operators to avoid flicking in the horizon.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["grid","derivative","floor"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Copyright Per Bloksgaard, 2020 - https://perbloksgaard.dk\n\n#define PI 3.14159265358979\n\nfloat derivative(vec2 p)\n{\n    vec2 dx = dFdx(p);\n    vec2 dy = dFdy(p);\n \tvec2 d = p - floor(p);\n    return exp2(-0.31 * min((1.-d.x) * d.x, (1.-d.y) * d.y) / (dot(dx,dy) + dot(dy,dy) + 2e-3));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  vec3 tot = vec3(0.);\n  float u = iTime*0.2;\n  float v = -PI*0.6-cos(iTime*0.01)*PI*0.1;\n  float f = clamp(cos(iTime*0.5),0.,1.)*5.5;\n  vec3 vCamTarget = vec3(0.,0.2,0.);\n  vec3 vCamPos = vec3(cos(u)*sin(v)*2.,0.4+f,sin(u)*sin(v));\n  vec3 vCamForward = normalize(vCamTarget-vCamPos);\n  vec3 vCamRight = normalize(cross(vCamForward,vec3(0.,1.,0.)));\n  vec3 vCamUp = normalize(cross(vCamRight,vCamForward));    \n  for(int m=-1; m<2; m++)\n  {\n    for(int n=-1; n<2; n++)\n    {\n      vec2 o = vec2(float(m),float(n)) * 0.5;\n      vec2 s = (-iResolution.xy + 2.0*(fragCoord.xy+o))/iResolution.xy*iResolution.xy/iResolution.yy;\n\t  vec3 vRayDir = normalize(s.x*vCamRight+s.y*vCamUp+vCamForward*1.5);\n      float d = -vCamPos.y / min(vRayDir.y,-1e-6);\n      vec3 vHitPos = vCamPos + vRayDir * d;\n      float sV = 0.5*derivative(vHitPos.xz*2.);\n      float bV = derivative(vHitPos.xz);\n      tot += mix(vec3(.79,.88,1.), vec3(1.-max(bV,sV)), exp2(-.12*length(vCamPos.xz - vHitPos.xz)));\n    }\n  }\n  tot *= float(1./9.);\n  fragColor = vec4(vec3(tot),1.);\n}","name":"Image","description":"","type":"image"}]}