{"ver":"0.1","info":{"id":"4fBcz3","date":"1723470462","viewed":257,"name":"Peaceful Stream","username":"Timbrhoggvandi","description":"Compile and run time is pretty bad :P\nDistant grass is also pretty aliasy, among other issues. Might revisit this at some point in the future.","likes":28,"published":1,"flags":0,"usePreview":1,"tags":["procedural","raymarching","water","grass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926535897932384626433832795\n#define E 2.718281828459045235360287471352\n\n/* RAYMARCH SETTINGS */\n#define VERTICAL_FOV 1.0\n#define MAX_ITERATIONS 512\n#define MAX_DISTANCE 256.0\n#define HIT_DISTANCE 0.001\n#define BOUNDING_BOX_BUFFER 0.03\n\n#define SHADOW_STEPS 164\n\n#define TERRAIN_DIST_SCALE 0.9\n#define GRASS_DIST_SCALE 0.9\n#define WATER_DIST_SCALE 1.0\n\n/* GRASS */\n#define REPETITION_PERIOD 0.065\n#define LENGTH_MIN 0.11\n#define LENGTH_RANGE 0.09\n#define WIDTH 0.09\n\n/* WATER */\n#define STREAM_RADIUS 24.0\n#define STREAM_CENTER vec3(65,2.8,265.0)\n#define WATER_HEIGHT 1.2\n\n/* STONES */\n#define STONE_REPETITIONS_RADIAL 175.0\n#define STONE_REPETITION_PERIOD 2.25\n#define DIST_CENTER_RANGE 0.2\n#define RADIAL_RANGE 0.2\n#define RADIUS_MIN 0.1\n#define RADIUS_RANGE 0.3\n#define STONE_PROBABILITY 0.4\n\n/* TREES */\n#define TREE_POS0 vec2(147.5/2.0, 490.0/2.0)\n#define TREE_POS1 vec2(143.5/2.0, 480.0/2.0)\n#define TREE_POS2 vec2(149.5/2.0, 478.0/2.0)\n#define TRUNK_LENGTH 2.0\n#define BRANCH_REPETITIONS_RADIAL 6.0\n#define BRANCH_REPETITIONS 2.0\n#define BRANCH_REPETITION_PERIOD 0.5\n#define BRANCH_POS_RANGE 0.2\n#define BRANCH_LENGTH_MIN 0.7\n#define BRANCH_LENGTH_RANGE 0.2\n\n/* LIGHTING AND COLOR */\n#define SUN_DIRECTION normalize(vec3(0.35,0.25,-1))\n\n#define ID_ATMOSPHERE 0\n#define ID_GRASS 1\n#define ID_GROUND 2\n#define ID_WATER 3\n#define ID_STONE 4\n#define ID_TREE 5\n#define ID_LEAVES 6\n\n#define COL_SUNLIGHT vec3(1.000,0.388,0.059)\n#define COL_ATMOSPHERE vec3(0.345,0.671,0.835)\n#define COL_GROUND vec3(0.055,0.043,0.027)\n#define COL_GRASS vec3(0.17,0.9,0.17)\n#define COL_WATER vec3(0.141,0.627,0.839)\n#define COL_STONE vec3(0.478,0.451,0.424)\n#define COL_TREE vec3(0.263,0.216,0.157)\n#define COL_LEAVES vec3(0.902,0.345,0.157)\n#define COL_FOG vec3(1.0)\n\n#define WATER_REFLECTANCE vec3(0.08)\n\n#define ZERO (min(iFrame,0))\n\nstruct RaymarchInfo {\n    vec3 point;\n    float rayDistance;\n    bool hit;\n};\n\nstruct MapInfo {\n    vec3 coord;\n    float dist;\n    int matId;\n};\n\n// hash functions are pretty bad, will probably rewrite when I have time\nfloat hash12(vec2 p) {\n    p = fract(23.745783*p + 7.5491549) / vec2(PI, E);\n    return fract((p.x*p.y)*513.324765);\n}\n\nvec2 hash22(vec2 p) {\n    p = fract(23.745783*p + 7.5491549) / vec2(PI, E);\n    return fract((p.x*p.y)*vec2(319.6731201, 193.83039));\n}\n\nvec3 hash32(vec2 p) {\n    p = fract(23.745783*p + 7.5491549) / vec2(PI, E);\n    return fract((p.x*p.y)*vec3(319.6731201, 193.83039, 271.83018));\n}\n\nfloat hash13(vec3 p) {\n    p = fract(23.745783*p + 7.5491549) / vec3(PI, E, PI+E);\n    return fract((p.x*p.y*p.z)*513.324765);\n}\n\nvec2 rotate2D(vec2 p, float angle) {\n    return vec2(p.x*cos(angle) - p.y*sin(angle), p.x*sin(angle) + p.y*cos(angle));\n}\n\nfloat getTilt(vec2 point) {\n    float tilt = cos(0.5*point.x+0.25*sin(point.y - iTime) - iTime);\n    return 2.5*tilt*tilt - 0.1;\n}\n\nfloat getRotation(vec2 point) {\n    return 2.3*cos(0.15 * point.x + 0.1*iTime) + 2.0*sin(0.18 * point.y + 0.11*iTime) + 0.1 * cos(2.2*iTime);\n}\n\n// These combination functions and a lot of the sdfs used from https://iquilezles.org/articles/distfunctions/\nfloat opSubtraction( float d1, float d2 ) {\n    return max(-d1,d2);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\nMapInfo minDist(MapInfo a, MapInfo b) {\n    if(a.dist < b.dist) {\n        return a;\n    }\n    return b;\n}\n\nvec2 closestPoint(vec2 a, vec2 b, vec2 c) {\n    return length(c-a) < length(c-b) ? a : b;\n}\n\n\nMapInfo opSmoothMinDist(MapInfo a, MapInfo b, float k) {\n    MapInfo mapInfo;\n    mapInfo = b;\n    if(a.dist < b.dist) {\n        mapInfo = a;\n    }\n    mapInfo.dist = opSmoothUnion(a.dist, b.dist, k);\n    return mapInfo;\n}\n\nfloat valueNoise(vec2 coord) {\n    vec2 f = fract(coord);\n    vec2 i = floor(coord);\n    \n    vec2 a = f * f * (3.0 - 2.0 * f);\n    \n    float v00 = hash12(i);\n    float v10 = hash12(i + vec2(1, 0));\n    float v01 = hash12(i + vec2(0, 1));\n    float v11 = hash12(i + vec2(1, 1));\n    \n    return mix(\n        mix(v00, v10, a.x),\n        mix(v01, v11, a.x),\n        a.y);\n}\n\nfloat valueNoise(vec3 coord) {\n    vec3 f = fract(coord);\n    vec3 i = floor(coord);\n    \n    vec3 a = f * f * (3.0 - 2.0 * f);\n    \n    float v000 = hash13(i);\n    float v100 = hash13(i + vec3(1, 0, 0));\n    float v010 = hash13(i + vec3(0, 1, 0));\n    float v110 = hash13(i + vec3(1, 1, 0));\n    float v001 = hash13(i + vec3(0, 0, 1));\n    float v101 = hash13(i + vec3(1, 0, 1));\n    float v011 = hash13(i + vec3(0, 1, 1));\n    float v111 = hash13(i + vec3(1, 1, 1));\n    \n    return mix(\n        mix(\n            mix(v000, v100, a.x),\n            mix(v010, v110, a.x),\n            a.y),\n        mix(\n            mix(v001, v101, a.x),\n            mix(v011, v111, a.x),\n            a.y),\n            a.z);\n    \n}\n\nfloat fbm(vec2 coord, int octaves) {\n    float scale = 0.5;\n    float sum = 0.0;\n    for(int i = ZERO; i < octaves; i++) {\n        sum += scale * valueNoise(coord);\n        scale *= 0.45;\n        coord *= 2.38095;\n    }\n    return sum;\n}\n\nfloat fbm(vec3 coord, int octaves) {\n    float scale = 0.5;\n    float sum = 0.0;\n    for(int i = ZERO; i < octaves; i++) {\n        sum += scale * valueNoise(coord);\n        scale *= 0.45;\n        coord *= 2.38095;\n    }\n    return sum;\n}\n\nfloat sdTorus( vec3 p, vec2 t ) {\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nfloat sdPlane(vec3 p) {\n    return p.y;\n}\n\nfloat sdSphere( vec3 p, float s ) {\n    return length(p)-s;\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r ) {\n    p.y -= clamp( p.y, 0.0, h );\n    return length( p ) - r;\n}\n\nfloat sdGrassBlade( vec3 p, float h, float r, float crossSectionRotation ) {\n    r*= 1.0 - (p.y*p.y/(h*h));\n    p.y = p.y - clamp( p.y, 0.0, h );\n    float tilt = getTilt(p.xz);\n    p.xz = rotate2D(p.xz, crossSectionRotation);\n    return sdSphere(p, r) - 0.006;\n}\n\nMapInfo evalDomain(vec3 point, vec2 id, vec2 treePoint) {\n    float tilt = getTilt(point.xz);\n    float rotation = getRotation(point.xz);\n    vec2 translation = 0.004 + (REPETITION_PERIOD - 0.008) * hash22(id);\n    float streamCenterDist = abs(length(STREAM_CENTER - point) - STREAM_RADIUS);\n    float grassProbability = (streamCenterDist - 1.18)*2.0;\n    grassProbability *= abs(grassProbability);\n    if(grassProbability < hash12(id*9.4316)) {\n        return MapInfo(point, 999.0, ID_GRASS);\n    }\n    vec2 globalCellCoord = REPETITION_PERIOD * id + translation;\n    if(length(globalCellCoord - treePoint) < 0.33) {\n        return MapInfo(point, 999.0, ID_GRASS);\n    }\n    point.xz -= globalCellCoord;\n    point.xz = rotate2D(point.xz, rotation);\n    point.xy = rotate2D(point.xy, point.y*tilt);\n    float len = LENGTH_MIN + LENGTH_RANGE*hash12(13.1894*id);\n    float crossSectionRotation = 2.0*PI*hash12(41.6921*id) - rotation;\n    float dist = sdGrassBlade(point, len, len*WIDTH, crossSectionRotation);\n    return MapInfo(point, dist, ID_GRASS);\n}\n\nMapInfo sdGrassField(vec3 point, vec2 treePoint) {\n    float tilt = getTilt(point.xz);\n    float rotation = getRotation(point.xz);\n    float py = clamp(point.y, 0.0, 1.0);\n    \n    vec2 id = point.xz;\n    id -= vec2(cos(rotation), -sin(rotation))*py*py*tilt;\n    id = floor(id / REPETITION_PERIOD - 0.5);\n    \n    MapInfo mapInfo = MapInfo(point, REPETITION_PERIOD * 0.5, ID_GRASS);\n    for(int i = 0; i <= 1; i++) {\n        for(int j = 0; j <= 1; j++) {\n            MapInfo domainDist = evalDomain(point, id + vec2(i,j), treePoint);\n            mapInfo = minDist(mapInfo, domainDist);\n        }\n    }\n    return mapInfo;\n}\n\nfloat sdTerrain(vec3 point) {\n    float dist = sdPlane(point);\n    float terrainHeight = 7.0*fbm(0.025*point.xz, 6);\n    dist -= terrainHeight;\n    float riverShape = sdTorus(point - STREAM_CENTER, vec2(STREAM_RADIUS, 2.0));\n    return opSmoothSubtraction(riverShape, dist, 1.0);\n}\n\n// Rock generated by subtracting spheres, similar to https://www.shadertoy.com/view/ldSSzV\nfloat sdStone(vec3 p, float r, vec2 id) {\n    float stone = sdSphere(p, r);\n    for(float i = 0.0; i < 4.0; i++) {\n        vec3 offset = 1.8*r*normalize((2.0*hash32(id + i) - 1.0));\n        stone = opSmoothSubtraction(sdSphere(p - offset, r), stone, 0.2);\n    }\n    return stone;\n}\n\nMapInfo sdStones(vec3 point) {\n    vec2 id;\n    float repetitionAngle = 2.0*PI/STONE_REPETITIONS_RADIAL;\n    point = point - vec3(STREAM_CENTER.x, 0.0, STREAM_CENTER.z);\n    float theta = atan(point.z, point.x);\n    float r = sqrt(point.x*point.x + point.z*point.z);\n    id.x = floor((theta)/repetitionAngle)*repetitionAngle + 0.5*repetitionAngle;\n    theta -= id.x;\n    \n    point = vec3(r*cos(theta), point.y, r*sin(theta));\n    point.x -= STREAM_RADIUS - 0.5*STONE_REPETITION_PERIOD;\n    id.y = STONE_REPETITION_PERIOD*clamp(round(point.x/STONE_REPETITION_PERIOD), 0.0, 1.0);\n    \n    float translation = id.y - 0.4 + 0.8*hash12(1561.91683*id);\n    float width = RADIUS_MIN + RADIUS_RANGE*hash12(121.91412*id);\n    \n    vec3 stoneCoord = vec3(translation, 0, 0);\n    float stone = 999.0;\n    if(STONE_PROBABILITY > hash12(774.7601*id)) {\n        vec3 q = point - stoneCoord;\n        stone = sdStone(q, width, vec2(id));\n    }\n    return MapInfo(point, stone, ID_STONE);\n}\n\nfloat sdLeaves(vec3 point, vec2 id, float seed) {\n    float leaves = sdSphere(point, 0.3 + 0.1*hash12(id + 0.54813 + seed));\n    if(leaves < 0.1) {\n        leaves += 0.05*fbm(15.0*point, 2);\n    }\n    return leaves;\n}\n\nMapInfo sdBranch(vec3 point, vec2 id, float seed) {\n    float repetitionAngle = 2.0*PI/BRANCH_REPETITIONS_RADIAL;\n    float branchAngle = -repetitionAngle*id.x;\n    point.xz = rotate2D(point.xz, branchAngle);\n\n    id.y = clamp(id.y, 0.0, 1.0);\n    point.y -= BRANCH_REPETITION_PERIOD * id.y + BRANCH_POS_RANGE*(hash12(id + 9.39519) - 0.5);\n    point.xy = rotate2D(point.xy, 1.0 - 0.5*id.y/BRANCH_REPETITIONS);\n    float branchLength = BRANCH_LENGTH_MIN + BRANCH_LENGTH_RANGE*hash12(id + seed + 1.1659327);\n    branchLength *= 1.0 - 0.5*id.y/BRANCH_REPETITIONS;\n    MapInfo branch = MapInfo(point, sdVerticalCapsule(point, branchLength, 0.055), ID_TREE);\n    if(branch.dist < 0.05) {\n        branch.dist += 0.015*fbm(30.0*vec3(point.x, 0.2*point.y, point.z) + 58.41497, 2);\n    }\n    \n    MapInfo leaves = MapInfo(point, sdLeaves(point - vec3(0,branchLength,0), id, seed), ID_LEAVES);\n    \n    return minDist(leaves, branch);\n}\n\nMapInfo sdTree(vec3 point, float seed) {\n    vec2 id;\n    float width = 0.12 * (1.0 - 0.1*point.y);\n    float trunk = sdVerticalCapsule(point, TRUNK_LENGTH, width);\n    trunk -= exp2(-6.0*clamp(point.y, 0.0, 2.0))*0.3*fbm(12.0*point.xz, 2);\n    if(trunk < 0.05) {\n        trunk += 0.02*fbm(25.0*vec3(point.x, 0.2*point.y, point.z) + seed, 2);\n    }\n    \n    MapInfo tree = MapInfo(point, trunk, ID_TREE);\n    \n        \n    if(point.y < 0.5*TRUNK_LENGTH) {\n        return tree;\n    }\n    \n    float repetitionAngle = 2.0*PI/BRANCH_REPETITIONS_RADIAL;\n    float theta = atan(point.z, point.x);\n    id.x = floor(theta/repetitionAngle);\n    \n    vec3 branchPoint = point;\n    branchPoint -= vec3(0,0.65*TRUNK_LENGTH,0);\n    id.y = round(branchPoint.y/BRANCH_REPETITION_PERIOD);\n    \n    for(int i = 0; i <= 1; i++) {\n        for(int j = 0; j <= 1; j++) {\n            tree = opSmoothMinDist(sdBranch(branchPoint, id - vec2(-i, j), seed), tree, 0.05);\n        }\n    }\n    \n    tree.dist *= 0.8;\n    return tree;\n}\n\n/* Map returns distance, material ID and some local coordinates used for coloring\n(grass is darker the lower the coord is along its arc length).\nCould make a separate function that just returns dist for raymarching,\nbut the performance impact seems low so should be fine for now */\nMapInfo map(vec3 point) {\n    /* GROUND */\n    MapInfo mapInfo = MapInfo(point, sdTerrain(point), ID_GROUND);\n    \n    float terrainHeight = point.y - mapInfo.dist;\n    \n    mapInfo.dist *= TERRAIN_DIST_SCALE;\n    \n    vec2 treePos = closestPoint(TREE_POS0, TREE_POS1, point.xz);\n    treePos = closestPoint(treePos, TREE_POS2, point.xz);\n    \n    float treeBound = sdSphere(point - vec3(treePos.x, point.y, treePos.y), 1.6);\n    if(treeBound < BOUNDING_BOX_BUFFER) {\n        float terrainHeightTree = point.y - sdTerrain(vec3(treePos.x, point.y, treePos.y));\n        \n        /* TREES */\n        MapInfo tree = sdTree(point - vec3(treePos.x, terrainHeightTree, treePos.y), 0.1*(treePos.x + treePos.y));\n\n        mapInfo = minDist(mapInfo, tree);\n    }\n    else {\n        mapInfo.dist = min(treeBound, mapInfo.dist);\n    }\n    \n    float grassBound = sdPlane(point - vec3(0,LENGTH_MIN + LENGTH_RANGE,0)) - terrainHeight;\n    if(grassBound < BOUNDING_BOX_BUFFER) {\n        float streamBoundOut = -sdTorus(point - vec3(STREAM_CENTER.x, point.y, STREAM_CENTER.z), vec2(STREAM_RADIUS, 0.8));\n        if(streamBoundOut < BOUNDING_BOX_BUFFER) {\n            /* GRASS */\n            MapInfo grass = sdGrassField(point - vec3(0, terrainHeight, 0), treePos);\n            grass.dist *= GRASS_DIST_SCALE;\n            mapInfo = minDist(mapInfo, grass);\n        }\n        float streamBoundIn = sdTorus(point - vec3(STREAM_CENTER.x, point.y, STREAM_CENTER.z), vec2(STREAM_RADIUS, 1.5));\n        if(streamBoundIn < BOUNDING_BOX_BUFFER) {\n            /* STONES */\n            MapInfo stones = sdStones(point - vec3(0, terrainHeight, 0));\n            mapInfo = minDist(mapInfo, stones);\n        }\n        \n    }\n    else {\n        mapInfo.dist = min(grassBound, mapInfo.dist);\n    }\n    \n    /* WATER */\n    float water = sdPlane(point - vec3(0,WATER_HEIGHT,0));\n    if(point.y < WATER_HEIGHT + 0.04) {\n        vec2 waterCoord = rotate2D(point.xz - STREAM_CENTER.xz, -0.005*iTime);\n        water += mix(0.01*fbm(9.49*waterCoord, 1), 0.01*fbm(9.29*waterCoord + 8.34, 1), cos(iTime*0.3)*cos(iTime*0.3));\n    }\n    water *= WATER_DIST_SCALE;\n    mapInfo = minDist(mapInfo, MapInfo(point, water, ID_WATER));\n    \n    return mapInfo;\n}\n\n/* Version of map function that doesn't include water\nImproves performance a bit to use this for shadows and reflections,\nsince it takes less steps to raymarch away from the water surface.\nCan also use this to raymarch to riverbed if adding water transparency,\nnot using it this way at the moment though */\nMapInfo mapNoWater(vec3 point) {\n    /* GROUND */\n    MapInfo mapInfo = MapInfo(point, sdTerrain(point), ID_GROUND);\n    \n    float terrainHeight = point.y - mapInfo.dist;\n    \n    mapInfo.dist *= TERRAIN_DIST_SCALE;\n    \n    vec2 treePos = closestPoint(TREE_POS1, TREE_POS2, point.xz);\n    \n    float treeBound = sdSphere(point - vec3(treePos.x, point.y, treePos.y), 1.6);\n    if(treeBound < BOUNDING_BOX_BUFFER) {\n        float terrainHeightTree = point.y - sdTerrain(vec3(treePos.x, point.y, treePos.y));\n        \n        /* TREES */\n        MapInfo tree = sdTree(point - vec3(treePos.x, terrainHeightTree, treePos.y), 0.1*(treePos.x + treePos.y));\n\n        mapInfo = minDist(mapInfo, tree);\n    }\n    else {\n        mapInfo.dist = min(treeBound, mapInfo.dist);\n    }\n    \n    float grassBound = sdPlane(point - vec3(0,LENGTH_MIN + LENGTH_RANGE,0)) - terrainHeight;\n    if(grassBound < BOUNDING_BOX_BUFFER) {\n        float streamBoundOut = -sdTorus(point - vec3(STREAM_CENTER.x, point.y, STREAM_CENTER.z), vec2(STREAM_RADIUS, 0.9));\n        if(streamBoundOut < BOUNDING_BOX_BUFFER) {\n            /* GRASS */\n            MapInfo grass = sdGrassField(point - vec3(0, terrainHeight, 0), treePos);\n            grass.dist *= GRASS_DIST_SCALE;\n            mapInfo = minDist(mapInfo, grass);\n        }\n        float streamBoundIn = sdTorus(point - vec3(STREAM_CENTER.x, point.y, STREAM_CENTER.z), vec2(STREAM_RADIUS, 1.5));\n        if(streamBoundIn < BOUNDING_BOX_BUFFER) {\n            /* STONES */\n            MapInfo stones = sdStones(point - vec3(0, terrainHeight, 0));\n            mapInfo = minDist(mapInfo, stones);\n        }\n        \n    }\n    else {\n        mapInfo.dist = min(grassBound, mapInfo.dist);\n    }\n    \n    return mapInfo;\n}\n\nRaymarchInfo raymarch(vec3 ro, vec3 rd, int maxIterations, float maxDistance) {\n    RaymarchInfo info = RaymarchInfo(ro, 0.0, false);\n    \n    for(int i = 0; i < maxIterations; i++) {\n        float dist = map(info.point).dist;\n        \n        if(dist < HIT_DISTANCE) {\n            info.hit = true;\n            break;\n        }\n        \n        info.rayDistance += dist;\n        info.point = ro + info.rayDistance*rd;\n        \n        if(info.rayDistance > MAX_DISTANCE) {\n            break;\n        }\n    }\n    \n    return info;\n}\n\nRaymarchInfo raymarchNoWater(vec3 ro, vec3 rd, int maxIterations, float maxDistance) {\n    RaymarchInfo info = RaymarchInfo(ro, 0.0, false);\n    \n    for(int i = 0; i < maxIterations; i++) {\n        float dist = mapNoWater(info.point).dist;\n        \n        if(dist < HIT_DISTANCE) {\n            info.hit = true;\n            break;\n        }\n        \n        info.rayDistance += dist;\n        info.point = ro + info.rayDistance*rd;\n        \n        if(info.rayDistance > MAX_DISTANCE) {\n            break;\n        }\n    }\n    \n    return info;\n}\n\n// This implementation of calcNormal from https://iquilezles.org/articles/normalsSDF/,\n// based on function written by Klems\nvec3 calcNormal( in vec3 p )\n{\n    const float h = 0.0001;\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*h).dist;\n        if( n.x>10000.0 ) break; // reduces compile time a lot, ty iq :)\n    }\n    return normalize(n);\n}\n\nvec3 calcNormalNoWater( in vec3 p )\n{\n    const float h = 0.0001;\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*mapNoWater(p+e*h).dist;\n        if( n.x>10000.0 ) break;\n    }\n    return normalize(n);\n}\n\nvec3 calcNormalTerrain( in vec3 p )\n{\n    const float h = 0.0001;\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sdTerrain(p+e*h);\n        if( n.x>10000.0 ) break;\n    }\n    return normalize(n);\n}\n\nfloat shadow(vec3 point, vec3 lightDirection, float lightDistance, float penumbraCoefficient) {\n    float light = 1.0;\n    float rayDist = 0.0;\n    point += 0.01*lightDirection;\n    for(int i = 0; i < SHADOW_STEPS; i++) {\n        float dist = mapNoWater(point + lightDirection*rayDist).dist;\n        if(dist < 0.05*HIT_DISTANCE) {\n            light = 0.0;\n            break;\n        }\n        light = min(light, penumbraCoefficient*dist/rayDist);\n        rayDist += max(dist, 0.01);\n        if(rayDist > lightDistance) {\n            return light;\n        }\n    }\n    return light;\n}\n\nvec3 calcCol(RaymarchInfo info, vec3 rd, MapInfo mapInfo, vec3 normal) {\n    \n    if(!info.hit) {\n        return mix(COL_SUNLIGHT, COL_ATMOSPHERE, 2.5*rd.y - 0.35*dot(rd, SUN_DIRECTION));\n    }\n    \n    vec3 col;\n    switch(mapInfo.matId) {\n        case ID_GROUND:\n            col = COL_GROUND;\n            break;\n        case ID_GRASS:\n            col = COL_GRASS;\n            col *= 0.2 + 0.8*mapInfo.coord.y/(LENGTH_MIN + LENGTH_RANGE);\n            break;\n        case ID_WATER:\n            col = COL_WATER;\n            break;\n        case ID_STONE:\n            col = COL_STONE;\n            break;\n        case ID_TREE:\n            col = COL_TREE;\n            break;\n        case ID_LEAVES:\n            col = COL_LEAVES;\n            break;\n    }\n    \n    vec3 colUnlit = 0.04*col;\n    \n    float light = dot(normal, SUN_DIRECTION);\n    light *= shadow(info.point, SUN_DIRECTION, 128.0, 12.0);\n    \n    // cel shading\n    light = light > 0.001 ? 1.0 : 0.0;\n    \n    if(mapInfo.matId == ID_GRASS) {\n        float distanceScale = exp2(-0.1*info.rayDistance);\n        vec3 normApprox = calcNormalTerrain(info.point);\n        float lightApprox = max(0.0, 0.55*dot(normApprox, SUN_DIRECTION));\n        light = mix(lightApprox, light, distanceScale);\n    }\n    \n    col = mix(colUnlit, col, COL_SUNLIGHT*light);\n    \n    vec3 fogScale = exp(-0.0008*info.rayDistance*vec3(1,2,4));\n    \n    col = mix(COL_FOG, col, fogScale);\n    \n    return col;\n}\n\nvec3 lighting(RaymarchInfo info, vec3 rd) {\n\n    MapInfo mapInfo = map(info.point);\n    vec3 col;\n    \n    if(!info.hit) {\n        float rdDotSun = dot(rd, SUN_DIRECTION);\n        col = mix(COL_SUNLIGHT, COL_ATMOSPHERE, 3.0*rd.y - 0.3*pow(rdDotSun, 2.0));\n        float sunStep = clamp(700.0*(rdDotSun - 0.997), 0.0, 1.0);\n        col = mix(col, vec3(1.0, 0.87, 0.67), sunStep);\n        return col;\n    }\n    \n    vec3 normal = calcNormal(info.point);\n    \n    col = calcCol(info, rd, mapInfo, normal);\n    \n    if(mapInfo.matId == ID_WATER) {\n        float distToShore = mapNoWater(info.point).dist - 0.0155*fbm(26.81*info.point.xz, 3);\n        if(distToShore < 0.016 && distToShore > 0.00) {\n            col = mix(col, vec3(1), 0.3);\n        }\n        \n        else {\n            vec3 reflectance = WATER_REFLECTANCE + (1.0 - WATER_REFLECTANCE)*pow(1.0 - max(0.0, dot(normal, -rd)), 5.0);\n            vec3 reflectionDir = 2.0*dot(normal, -rd)*normal + rd; \n            RaymarchInfo reflection = raymarchNoWater(info.point + 0.01*reflectionDir, reflectionDir, 128, 128.0);\n            MapInfo reflectionMap = mapNoWater(reflection.point);\n            vec3 reflectionNormal = calcNormalNoWater(reflection.point);\n            vec3 reflectedCol = calcCol(reflection, reflectionDir, reflectionMap, reflectionNormal);\n            \n            vec3 transmittance = 1.0 - reflectance;\n            col = reflectance * reflectedCol + transmittance * col;\n        }\n    }\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord.xy - iResolution.xy)/iResolution.y;\n    \n    vec3 ro = vec3(76, 2.7, 247.0);\n    \n    vec3 rd = normalize(vec3(uv, 1.0 / tan(0.5 * VERTICAL_FOV)));\n    \n    rd.yz = rotate2D(rd.yz, 0.135);\n    rd.xz = rotate2D(rd.xz, 2.95);\n    \n    RaymarchInfo info = raymarch(ro, rd, MAX_ITERATIONS, MAX_DISTANCE);\n\n    vec3 col = lighting(info, rd);\n    col = mix(col, COL_SUNLIGHT, 0.2*pow(max(dot(SUN_DIRECTION, rd), 0.0), 5.0));\n    \n    col = pow(col, vec3(1.0/2.2));\n    \n    uv = (2.0*fragCoord.xy - iResolution.xy)/iResolution.xy;\n    col = col * (0.5 + 0.5*pow((1.0 - uv.x*uv.x)*(1.0 - uv.y*uv.y), 0.05));\n   \n    fragColor = vec4(col, 1.0);  \n}\n","name":"Image","description":"","type":"image"}]}