{"ver":"0.1","info":{"id":"ltdSz8","date":"1478188688","viewed":141,"name":"matrix dance","username":"komietty","description":"raymarching","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 cPos = vec3(0.,  0.,  3.0);\nconst vec3 cDir = vec3(0., 0., -1.);\nconst vec3 cUp  = vec3(0., 1., 0.);\n\nconst vec3 lightDir = vec3(-0.577, 0.577, 0.577);\n\n// smoothing min\nfloat smoothMin(float d1, float d2, float k){\n    float h = exp(-k * d1) + exp(-k * d2);\n    return -log(h) / k;\n}\n\n// box distance function\nfloat distFuncBox(vec3 p){\n    return length(max(abs(p) - vec3(2.0, 0.1, 0.5), 0.0)) - 0.1;\n}\n\n// torus distance function\nfloat distFuncTorus(vec3 p){\n    vec2 t = vec2(1.5, 0.25);\n    vec2 r = vec2(length(p.xy) - t.x, p.z);\n    return length(r) - t.y;\n}\n\n// twist x axis\nvec3 twistX(vec3 p, float power){\n    float s = sin(power * p.x);\n    float c = cos(power * p.x);\n    mat3 m = mat3(\n        1.0, 0.0, 0.0,\n        0.0,   c,   s,\n        0.0,  -s,   c\n    );\n    return m * p;\n}\n\n// twist y axis\nvec3 twistY(vec3 p, float power){\n    float s = sin(power * p.y);\n    float c = cos(power * p.y);\n    mat3 m = mat3(\n          c, 0.0,  -s,\n        0.0, 1.0, 0.0,\n          s, 0.0,   c\n    );\n    return m * p;\n}\n\n// twist z axis\nvec3 twistZ(vec3 p, float power){\n    float s = sin(power * p.z);\n    float c = cos(power * p.z);\n    mat3 m = mat3(\n          c,  s,  0.0,\n         -s,  c,  0.0,\n        0.0, 0.0, 1.0\n    );\n    return m * p;\n}\n\n\n\n\n// distance function\nfloat distFunc(vec3 p){\n    vec3 x = twistX(p, 0.0);\n    vec3 y = twistY(x, cos(iTime));\n    vec3 z = twistZ(y, sin(iTime));\n    float d1 = distFuncTorus(z);\n    float d2 = distFuncBox(z);\n    return smoothMin(d1, d2, 8.0);\n}\n\nvec3 genNormal(vec3 p){\n    float d = 0.001;\n    return normalize(vec3(\n        distFunc(p + vec3(  d, 0.0, 0.0)) - distFunc(p + vec3( -d, 0.0, 0.0)),\n        distFunc(p + vec3(0.0,   d, 0.0)) - distFunc(p + vec3(0.0,  -d, 0.0)),\n        distFunc(p + vec3(0.0, 0.0,   d)) - distFunc(p + vec3(0.0, 0.0,  -d))\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// fragment position\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n    \n    // camera and ray\n    vec3 cSide = cross(cDir, cUp);\n    float targetDepth = 1.0;\n    vec3 ray = normalize(cSide * p.x + cUp * p.y + cDir * targetDepth);\n    \n    // marching loop\n    float tmp, dist;\n    tmp = 0.0;\n    vec3 dPos = cPos;\n    for(int i = 0; i < 256; i++){\n        dist = distFunc(dPos);\n        tmp += dist;\n        dPos = cPos + tmp * ray*0.1;\n    }\n    \n    // hit check\n    vec3 color;\n    if(abs(dist) < 0.001){\n        vec3 normal = genNormal(dPos);\n        float diff = clamp(dot(lightDir, normal), 0.1, 1.0);\n        color = vec3(1.0, 1.0, 1.0) * diff;\n    }else{\n        color = vec3(0.0);\n    }\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}