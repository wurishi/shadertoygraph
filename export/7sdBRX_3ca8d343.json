{"ver":"0.1","info":{"id":"7sdBRX","date":"1656949706","viewed":189,"name":"Ray Tracing - Jan Bulling","username":"JanBulling","description":"A simple ray tracing renderer for spheres and planes. You can customize the color, position and material of the objects and the lighting.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","lighting","spheres","rendering","planes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Material {\n    float diffuse;\n    float specular;\n    float shininess;\n    float ambience;\n};\n\n// number of objects\n#define SPHERE_COUNT 2\n#define PLANE_COUNT 6\n\n#define SPHERE 0\nstruct Sphere {\n    vec3 position;\n    float radius;\n    Material material;\n    vec3 color;\n} spheres[SPHERE_COUNT];  \n\n#define PLANE 1\nstruct Plane {\n    vec3 position;\n    vec3 normal;\n    Material material;\n    vec3 color;\n} planes[PLANE_COUNT];\n\nstruct Camera {\n    vec3 position;\n    float zoom;\n};\n\nstruct PointLight {\n    vec3 position;\n    float intensity;\n};\n\n\n// define camera, light and materials\nCamera camera = Camera(vec3(0.0, 0.1, -3), 0.6);\nPointLight light = PointLight(vec3(0.0, 0.1, -0.25), 25.0);\nMaterial reflectiveMaterial = Material(0.4, 0.8, 50.0, 0.5);\nMaterial roughMaterial = Material(0.5, 0.1, 10.0, 0.1);\n\n// setup method. Here are the scene objects instanciated\nvoid setup() {\n    float pos = sin(iTime) * 0.15;\n\n    spheres[0] = Sphere(vec3(0.25, pos + 0.15, 0), 0.2, reflectiveMaterial, vec3(0.2, 0.2, 0.2));\n    spheres[1] = Sphere(vec3(-0.25, 0, 0), 0.2, reflectiveMaterial, vec3(0.3, 0.05, 0.05));\n\n    planes[0] = Plane(vec3(0,-0.2,0), vec3(0,1,0), roughMaterial, vec3(0.36, 0.22, 0.07)); // floor\n    planes[1] = Plane(vec3(-0.5,0,0), vec3(1,0,0), roughMaterial, vec3(0.7, 0.7, 0.7)); // left wall\n    planes[2] = Plane(vec3(0.5,0,0), vec3(-1,0,0), roughMaterial, vec3(0.7, 0.7, 0.7)); // right wall\n    planes[3] = Plane(vec3(0,0.5,0), vec3(0,-1,0), roughMaterial, vec3(0.2, 0.5, 0.6)); // ceiling\n    planes[4] = Plane(vec3(0,0,0.3), vec3(0,0,-1), roughMaterial, vec3(0.7, 0.7, 0.7)); // front wall\n    planes[5] = Plane(vec3(0,0,-0.8), vec3(0,0,1), roughMaterial, vec3(0.6, 0.6, 0.2)); // back wall\n}\n\n// =====================================================================================\n// ========= Ray Tracing ===============================================================\n// =====================================================================================\n\n// method for solving the quadratic formula. Returns true, if a solution exists. The\n// solutions are stored in \"x0\" and \"x1\"\nbool solveQuadratic(in float a, in float b, in float c, out float x0, out float x1) {\n    float discriminant = b * b - 4.0 * a * c;\n    \n    if (discriminant < 0.0) {\n        return false;\n    } else if (discriminant == 0.0) {\n        x0 = x1 = -b / (2.0 * a);\n        return true;\n    } \n    \n    x0 = (-b + sqrt(discriminant)) / (2.0 * a);\n    x1 = (-b - sqrt(discriminant)) / (2.0 * a);\n    return true;\n}\n\n// method for determining, whether a ray (with rayDirection and rayOrigin) intersetcs with a \n// sphere. Returns true if there is an intersection. The distance to the intersection point\n// is stored in \"dist\"\nbool intersectSphere(in vec3 rayOrigin, in vec3 rayDirection, Sphere sphere, out float dist) {\n    vec3 L = rayOrigin - sphere.position;\n    float a = dot(rayDirection, rayDirection);\n    float b = 2.0 * dot(L, rayDirection);\n    float c = dot(L, L) - sphere.radius * sphere.radius;\n    \n    float x0, x1;\n    \n    if (solveQuadratic(a, b, c, x0, x1)) {\n        if (x0 > x1) {\n            float tmp = x0; x0 = x1; x1 = tmp;\n        }\n        \n        if (x0 < 0.0) {\n            x0 = x1;\n            if (x0 < 0.0) {\n                dist = -1.0;\n                return false;\n            }\n        }\n        \n        dist = x0;\n        return true;\n    }\n}\n\n// method for determining, whether a ray (with rayDirection and rayOrigin) intersetcs with a \n// plane. Returns true if there is an intersection. The distance to the intersection point\n// is stored in \"dist\"\nbool intersectPlane(in vec3 rayOrigin, in vec3 rayDirection, Plane plane, out float dist) {\n    float tmp = dot(plane.normal, rayDirection);\n    \n    if (tmp < 1e-6) {\n        vec3 tmp2 = plane.position - rayOrigin;\n        dist = dot(tmp2, plane.normal) / tmp;\n        return dist > 0.0;\n    }\n    \n    dist = -1.0;\n    return false;\n}\n\n// method for color and material calculations\nvec3 getColor(in Material mat, in vec3 color, in vec3 hitPos, in vec3 normalVec, in vec3 rayDirection) {\n    vec3 lightVec = hitPos - light.position;\n    vec3 lightDir = normalize(lightVec);\n    \n    float lightIntensity = (0.01 * light.intensity) / abs(dot(lightVec, lightVec));\n    \n    float reflCoeff = max(0.0, -dot(lightDir, normalVec));\n    \n    vec3 ambient = color * mat.ambience;\n    vec3 diffuse = mat.diffuse * reflCoeff * lightIntensity * color;\n        \n    float shininess = pow(max(-dot(reflect(lightDir, normalVec), rayDirection), 0.0), mat.shininess);\n    vec3 specular = mat.specular * shininess * lightIntensity * color;\n    \n    return ambient + diffuse + specular;\n}\n\n// ray tracing algorithm. A ray gets send out and if it colides with an object,\n// the color of the pixel is calculated. Also responsible for bouncing\nvec3 castRay(in vec3 rayDirection, in vec3 rayOrigin) {\n    int BOUNCES = 2; // number of bounces\n    \n    int prevIndex = -1;\n    int prevType = -1;\n    \n    vec3 finalColor = vec3(0.0);\n    \n    for (int bounce = 0; bounce < BOUNCES; bounce++) {\n        float minDistance = 100000000.0;\n        int minDistanceIndex = -1;\n        int minDistanceType = -1;\n        \n        // interection with spheres\n        for (int i = 0; i < SPHERE_COUNT; i++) {\n            if (i == prevIndex && prevType == SPHERE) {\n                continue;\n            }\n            \n            float dist;\n            if (intersectSphere(rayOrigin, rayDirection, spheres[i], dist)) {\n                \n                if (dist < minDistance) {\n                    minDistance = dist;\n                    minDistanceIndex = i;\n                    minDistanceType = SPHERE;\n                }\n            }\n        }\n        \n        // intersection with planes\n        for (int i = 0; i < PLANE_COUNT; i++) {\n            if (i == prevIndex && prevType == PLANE) {\n                continue;\n            }\n            \n            float dist;\n            if (intersectPlane(rayOrigin, rayDirection, planes[i], dist)) {\n                if (dist < minDistance) {\n                    minDistance = dist;\n                    minDistanceIndex = i;\n                    minDistanceType = PLANE;\n                }\n            }\n        }\n        \n        vec3 hitPosition = rayOrigin + rayDirection * minDistance;\n        \n        vec3 passColor = vec3(0);\n        vec3 normalVec = vec3(0);\n        \n        // color calculation\n        if (minDistanceType == SPHERE) {\n            Sphere s = spheres[minDistanceIndex];\n            normalVec = normalize(hitPosition - s.position);\n            passColor = getColor(s.material, s.color, hitPosition, normalVec, rayDirection);\n            \n        } else if (minDistanceType == PLANE) {\n            Plane p = planes[minDistanceIndex];\n            normalVec = p.normal;\n            passColor = getColor(p.material, p.color, hitPosition, normalVec, rayDirection); \n            \n        } else {\n            return vec3(0.5, 0.2, 0.2); // background color\n        }\n        \n        // coulor mixing\n        if (bounce == 0) {\n            finalColor += passColor;\n        } else {\n            Material m;\n            \n            if (prevType == SPHERE) {\n                m = spheres[prevIndex].material;\n            } else if (prevType == PLANE) {\n                m = planes[prevIndex].material;\n            }\n            \n            finalColor += m.specular / (float(bounce) * 1.5) * passColor;\n        }\n        \n        // reflection and light-bouncing\n        rayOrigin = hitPosition;\n        rayDirection = normalize(reflect(rayDirection, normalVec));\n        prevIndex = minDistanceIndex;\n        prevType = minDistanceType;\n    }\n    \n    return finalColor;\n}\n\n\n// Main method. Runs on every pixel (with the fragCoord) every frame. Supposed\n// to return the color of the pixel in \"fragColor\"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    setup();\n    \n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv.x *= (iResolution.x / iResolution.y); \n    \n    vec3 rayDirection = normalize(vec3(uv.x, uv.y, camera.zoom) - camera.position);\n    \n    vec3 col = castRay(rayDirection, camera.position);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}