{"ver":"0.1","info":{"id":"dds3Rr","date":"1665598136","viewed":131,"name":"Antialiased square noise","username":"jaszunio15","description":"Antialiased square noise, does 2 hash operations per pixel. I just wanted to add this function to my library, maybe someone of you will make a good use of it :)","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["noise","antialiasing","square","hash"],"hasliked":0,"parentid":"NlGfRt","parentname":"Futuristic circuit"},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat hash12(vec2 uv)\n{\n    return fract(sin(dot(uv, vec2(18.38927984, 26.4896235))) * 1334.89479835);\n}\n\nfloat antialiasedSquareNoise(vec2 uv)\n{\n    vec2 root = floor(uv);\n    vec2 f = uv - root;\n    \n    vec2 travelDir = f - 0.5;\n    float m = max(abs(travelDir.x), abs(travelDir.y));\n    float pixelSize = 0.0;\n\n    if (abs(travelDir.x) > abs(travelDir.y))\n    {\n        pixelSize = fwidth(uv.x);\n        travelDir = vec2(sign(travelDir.x), 0.0f);\n    }\n    else\n    {\n        pixelSize = fwidth(uv.y);\n        travelDir = vec2(0.0, sign(travelDir.y));\n    }\n\n        \n    float v0 = hash12(root);    \n    float v1 = hash12(root + travelDir);\n    \n    // This lerp t component is just simplified linearstep(0.5-pixelSize, 0.5+pixelSize, m)\n    float value = mix(v0, v1, clamp((m - 0.5 + pixelSize * 0.5) / pixelSize, 0.0, 1.0));\n    return value;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    vec3 rayOrigin = vec3(0, -0.3, 0) + (-cos(iTime * 0.126) + 1.0);\n    vec3 rayDirection = uvToRayDirection(uv);\n    mat3 cameraRotation = rotationMatrix(vec3(1.0 + -cos(iTime * 0.232) * 0.3, iTime * 0.1, 0.0));\n    rayDirection = cameraRotation * rayDirection;\n    vec3 cameraForward = cameraRotation * uvToRayDirection(vec2(0.0, 0.0));\n    rayOrigin -= normalize(cameraForward) * 2.0;\n    \n    vec4 color = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    vec3 hitPoint = raycastYPlane(rayOrigin, rayDirection, 0.0);\n    \n    color += drawGrid(hitPoint.xz) * 0.1;\n    color += antialiasedSquareNoise(hitPoint.xz) * 1.0;\n\n    fragColor = color;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec3 uvToRayDirection(vec2 uv)\n{\n    return vec3(uv, 1.3);\n}\n\nvec3 raycastYPlane(vec3 rayOrigin, vec3 rayDirection, float planeY)\n{\n    float distanceToPlane = planeY - rayOrigin.y;\n    rayDirection /= rayDirection.y;\n    return rayOrigin + rayDirection * distanceToPlane;\n}\n\nmat3 rotationMatrix(vec3 eulerAngles)\n{\n    // x - pitch, y - yaw, z - roll\n    vec3 c = cos(eulerAngles);\n    vec3 s = sin(eulerAngles);\n    return mat3(c.y, 0.0, s.y, \n                0.0, 1.0, 0.0, \n                -s.y, 0.0, c.y) *\n           mat3(1.0, 0.0, 0.0, \n               0.0, c.x, s.x, \n               0.0, -s.x, c.x) * \n           mat3(c.z, s.z, 0.0, \n               -s.z, c.z, 0.0, \n               0.0, 0.0, 1.0);\n}\n\nfloat drawGrid(vec2 uv)\n{\n    float pixelSize = (fwidth(uv.x) + fwidth(uv.y)) * 0.5;\n    return smoothstep(pixelSize, 0.0, min(abs(fract(uv.x) - 0.5), abs(fract(uv.y) - 0.5)));\n}\n\n\n\n\n","name":"Common","description":"","type":"common"}]}