{"ver":"0.1","info":{"id":"llXSD7","date":"1439530443","viewed":1279,"name":"Adaptive Sampling Diagram","username":"huwb","description":"Diagram used in our talk \"A Novel Sampling Algorithm for Fast and Stable Real-Time Volume Rendering\" at SIGGRAPH. Course page: http://advances.realtimerendering.com/s2015/index.html","likes":32,"published":1,"flags":0,"usePreview":0,"tags":["1d","sampling","adaptive"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nThe MIT License (MIT)\n\nCopyright (c) 2015 Huw Bowles & Daniel Zimmermann\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\n// Example to illustrate volume sampling research undertaken right here on\n// shadertoy and published at siggraph 2015:\n//\n// Talk: \"A Novel Sampling Algorithm for Fast and Stable Real-Time Volume Rendering\"\n// Ppt: http://advances.realtimerendering.com/s2015/siggraph15_volsampling.pptx\n// Course page: http://advances.realtimerendering.com/s2015/index.html\n//\n\n\n// for graph\n#define RANGEY 6.0\n#define RANGEX (RANGEY*iResolution.x/iResolution.y)\n#define THICK  0.05\n\n// simple macros to pull mouse position in [0,1]\n#define MOUSEX\tiMouse.x/iResolution.x\n#define MOUSEY\tiMouse.y/iResolution.y\n\n#define CAMX (RANGEX*(MOUSEX-.5)*2.5)\n\n#define SAMPLE_COUNT 32\n#define PARAMETRIC_STEPS 32\n\n#define EPS 0.001\n\n//#define VIS_SAMPLE_LEVELS\n\nfloat pdf_max( float xstart, float xend )\n{\n    xstart = max( xstart, 0. );\n    return 5./(1.+xstart*1.5);\n}\n\n// the density line plot\nbool fn1( float x, out float y, out vec4 col )\n{\n\tcol = vec4(1.,0.,0.,1.);\n\ty = pdf_max( x, x );\n\treturn true;\n}\n\n// visualise two tree levels\nfloat inten = .4;\nfloat visy0 = .5;\nbool fn2( float x, out float y, out vec4 col )\n{\n    return false;\n    //y = pow( 2., 1.+floor(log2(MOUSEY*RANGEY)) );\n    y = MOUSEY*RANGEY;\n\tcol = vec4(inten);\n\treturn true;\n}\n\n\nvec4 drawSample( vec2 px, vec2 pt, vec4 col )\n{\n    float pw = .2;\n    float r = length(pt-px);\n    \n    float border = smoothstep( pw*.65, pw*.7, r );\n    col.rgb = mix(col.rgb, vec3(99.,37.,35.)/255., border);\n    \n    float alpha = smoothstep( pw, pw*.85, r );\n    //alpha *= border;\n    alpha *= col.a;\n    return vec4( col.rgb, alpha );\n}\n\nfloat dens_max( float x, float dx )\n{\n    return pdf_max(x,x+dx);\n}\n\nfloat mov_mod( float x, float y)\n{\n    return mod( x - iTime/4., y );\n}\n\nbool onBoundary( float x, float dx )\n{\n    // the +0.25 solves numerical issues without changing the result\n\treturn mov_mod( x + dx*0.25, dx ) < dx*0.5;\n}\n\n// this parametric function places a white dot at each sample\nbool pfn1( float t, out float x, out float y, out vec4 col, out float mint, out float maxt )\n{\n\tcol = vec4(192.,80.,77.,255.)/255.;\n\tmint = 0.;\n\tmaxt = 1.;\n\tint thisPt = int(floor(t*float(SAMPLE_COUNT)));\n    \n    // new variables from adaptive sampling\n    \n    // setup sampling\n\tx = 0.;\n    float dx = exp2(floor(log2(1./dens_max(x,0.))));\n    x -= mov_mod(x,2.*dx);\n    float wt = 1.;\n    bool even = true;\n    \n\tfor( int i = 0; i < SAMPLE_COUNT; i++ )\n\t{\n\t\tif( i == thisPt && x >= 0.)\n\t\t{\n\t\t\tbreak;\n\t\t}\n        \n        // sample at x, give weight wt\n        if( even )\n        {\n\t\t\tfloat densx = dens_max( x, dx * 2.0 );\n\t\t\tif( densx > 1.0 / dx )\n            {\n                // higher sampling rate\n                dx /= 2.0;\n                densx = dens_max( x, dx * 2.0 );\n                \n                // need enough of these to get to desired density, if not can get\n                // pops\n                if( densx > 1.0 / dx ) { dx /= 2.0; densx = dens_max( x, dx * 2.0 ); }\n                if( densx > 1.0 / dx ) { dx /= 2.0; densx = dens_max( x, dx * 2.0 ); }\n                if( densx > 1.0 / dx ) { dx /= 2.0; densx = dens_max( x, dx * 2.0 ); }\n            }\n            else\n            {\n                float nextDx, nextDens; bool nextEven;\n                \n                nextDx = 2.*dx;\n                nextDens = dens_max( x, nextDx*2. );\n                nextEven = onBoundary( x, nextDx*2. );\n                if( nextDens < 0.5 / dx && nextEven )\n                {\n                    // lower sampling rate\n\t\t\t\t\tdx = nextDx;\n\t\t\t\t\t// commit to this density\n\t\t\t\t\tdensx = nextDens;\n                }\n                \n                // can repeat the above block to step down sampling rates faster\n            }\n            \n\t\t\t//wt = saturate( 2.0 * (densx / (1.0 / dx) - 0.5) );\n\t\t\twt = clamp( 1.0*(2.0 * densx * dx - 1.0), 0., 1. );\n        }\n        \n        x += dx;\n\t    even = !even;\n\t}\n    \n    wt = even ? (2.-wt) : wt;\n    \n    col.a *= clamp(wt,0.,1.);\n    \n    y = pdf_max(x,x);// even ? pdf_max(x,x) : max( pdf_max(x,x), 1./(2.*dx));\n    \n\treturn true;\n}\n\n\nvec4 graph( vec2 p, float xmin, float xmax, float ymin, float ymax, float width );\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // uv minx maxx miny maxy thickness\n\tfragColor = graph( uv, 0., RANGEX, 0., RANGEY, THICK );\n\n\treturn;\n}\n\n\nfloat drawNumber( float num, vec2 pos, vec2 pixel_coords );\n\nfloat boundary(float coord, float spacing)\n{\n    float r = abs(mov_mod(coord+spacing/2.,spacing)-spacing/2.);\n    return smoothstep(7.5/iResolution.y,0.,r);\n    //return  < 10./iResolution.x ? 1. : 0.;\n}\n\nvec3 graph_bg(vec2 thisPt)\n{\n    float lowcoord = exp2(floor(log2(1./thisPt.y)));\n    float i = 1.-boundary(thisPt.x,lowcoord);\n    i = mix( 0.2,1.,i);\n    return vec3(i);\n}\n\n// p is in [0,1]. \nvec4 graph( vec2 p, float xmin, float xmax, float ymin, float ymax, float width )\n{\n\tvec4 result = vec4(1.);\n\t\n\tfloat thisx = xmin + (xmax-xmin)*p.x;\n\tfloat thisy = ymin + (ymax-ymin)*p.y;\n\t\n    result.rgb = graph_bg(vec2(thisx,thisy));\n    \n\t// compute gradient between this pixel and next (seems reasonable)\n\tfloat eps = dFdx(thisx);\n\n\tfloat alpha;\n\t\n\t//vec4 axisCol = vec4(vec3(.3),1.);\n\t\n\t// axes\n\t// x\n\t//alpha = abs( thisy - 0. ); alpha = smoothstep( width, width/4., alpha );\n\t//result = (1.-alpha)*result + alpha*axisCol;\n\t// y\n\t//alpha = abs( thisx - 0. ); alpha = smoothstep( width, width/4., alpha );\n\t//result = (1.-alpha)*result + alpha*axisCol;\n\t\n\t// uses iq's awesome distance to implicit https://iquilezles.org/articles/distance\n\tfloat f;\n\tvec4 fcol;\n\tif( fn1( thisx, f, fcol ) )\n\t{\n\t\tfloat f_1; fn1( thisx + eps, f_1, fcol ); float f_prime = (f_1 - f) / eps;\n\t\talpha = abs(thisy - f)/sqrt(1.+f_prime*f_prime); alpha = smoothstep( width, width/4., alpha ); alpha *= fcol.a;\n\t\tresult = (1.-alpha)*result + alpha*fcol;\n\t}\n\tif( fn2( thisx, f, fcol ) )\n\t{\n\t\tfloat f_1; fn2( thisx + eps, f_1, fcol ); float f_prime = (f_1 - f) / eps;\n\t\talpha = abs(thisy - f)/sqrt(1.+f_prime*f_prime); alpha = smoothstep( width, width/4., alpha ); alpha *= fcol.a;\n\t\tresult = (1.-alpha)*result + alpha*fcol;\n\t}\n\t// parametric curves. todo - join the dots!\n\tfloat x, mint, maxt;\n\tif( pfn1( 0., x, f, fcol, mint, maxt ) )\n\t{\n\t\tfloat dt = (maxt-mint)/float(PARAMETRIC_STEPS);\n\t\tfloat t = mint;\n\t\tfor( int i = 0; i <= PARAMETRIC_STEPS; i++ )\n\t\t{\n\t\t\tpfn1( t, x, f, fcol, mint, maxt );\n\t\t\tvec4 samp = drawSample( vec2(thisx,thisy), vec2(x,f), fcol );\n\t\t\tresult = (1.-samp.a)*result + samp.a*samp;\n\t\t\tt += dt;\n\t\t}\n\t}\n\t\n\t//result += vec4(drawNumber(xmin, vec2(0.,0.)+vec2(1.)/iResolution.xy, p ));\n\t//result += vec4(drawNumber(xmax, vec2(1.,0.)+vec2(-26.,1.)/iResolution.xy, p ));\n\t//result += vec4(drawNumber(ymax, vec2(0.,1.)+vec2(1.,-7.)/iResolution.xy, p ));\n\t//result += vec4(drawNumber(ymin, vec2(0.,0.)+vec2(1.,10.)/iResolution.xy, p ));\n\t\n\treturn result;\n}\n\n// digits based on the nice ascii shader by movAX13h\n\nfloat drawDig( vec2 pos, vec2 pixel_coords, float bitfield )\n{\n\t// offset relative to \n\tvec2 ic = pixel_coords - pos ;\n\tic = floor(ic*iResolution.xy);\n\t// test if overlap letter\n\tif( clamp(ic.x, 0., 2.) == ic.x && clamp(ic.y, 0., 4.) == ic.y )\n\t{\n\t\t// compute 1d bitindex from 2d pos\n\t\tfloat bitIndex = ic.y*3.+ic.x;\n\t\t// isolate the bit\n\t\treturn floor( mod( bitfield / exp2( floor(bitIndex) ), 2. ) );\n\t}\n\treturn 0.;\n}\n// decimal point\nfloat drawDecPt( vec2 center, vec2 pixel_coords )\n{\n\treturn drawDig( center, pixel_coords, 1. );\n}\n// minus sign\nfloat drawMinus( vec2 center, vec2 pixel_coords )\n{\n\treturn drawDig( center, pixel_coords, 448. );\n}\n// digits 0 to 9\nfloat drawDigit( float dig, vec2 pos, vec2 pixel_coords )\n{\n\tif( dig == 1. )\n\t\treturn drawDig( pos, pixel_coords, 18724. );\n\tif( dig == 2. )\n\t\treturn drawDig( pos, pixel_coords, 31183. );\n\tif( dig == 3. )\n\t\treturn drawDig( pos, pixel_coords, 31207. );\n\tif( dig == 4. )\n\t\treturn drawDig( pos, pixel_coords, 23524. );\n\tif( dig == 5. )\n\t\treturn drawDig( pos, pixel_coords, 29671. );\n\tif( dig == 6. )\n\t\treturn drawDig( pos, pixel_coords, 29679. );\n\tif( dig == 7. )\n\t\treturn drawDig( pos, pixel_coords, 31012. );\n\tif( dig == 8. )\n\t\treturn drawDig( pos, pixel_coords, 31727. );\n\tif( dig == 9. )\n\t\treturn drawDig( pos, pixel_coords, 31719. );\n\t// 0\n\treturn drawDig( pos, pixel_coords, 31599. );\n}\n\n// max num width is 26px (minus, 3 nums, dec pt, 2 nums)\n// max height is 6px\nfloat drawNumber( float num, vec2 pos, vec2 pixel_coords )\n{\n\tfloat result = 0.;\n\tbool on = false;\n\tfloat d;\n\t\n\t// minus sign\n\tif( num < 0. )\n\t{\n\t\tresult += drawMinus( pos, pixel_coords );\n\t\tpos.x += 4. / iResolution.x;\n\t\tnum = -num;\n\t}\n\t// hundreds\n\td = floor(mod(num/100.,10.));\n\tif( on || d > 0. )\n\t{\n\t\tresult += drawDigit( d, pos, pixel_coords );\n\t\tpos.x += 4. / iResolution.x;\n\t\ton = true;\n\t}\n\t// tens\n\td = floor(mod(num/10.,10.));\n\tif( on || d > 0. )\n\t{\n\t\tresult += drawDigit( d, pos, pixel_coords );\n\t\tpos.x += 4. / iResolution.x;\n\t\ton = true;\n\t}\n\t// ones\n\td = floor(mod(num,10.));\n\tresult += drawDigit( d, pos, pixel_coords );\n\tpos.x += 4. / iResolution.x;\n\t// dec pt\n\tresult += drawDecPt( pos, pixel_coords );\n\tpos.x += 2. / iResolution.x;\n\t// tenths\n\td = floor(mod(num/.1,10.));\n\tif( true )\n\t{\n\t\tresult += drawDigit( d, pos, pixel_coords );\n\t\tpos.x += 4. / iResolution.x;\n\t}\n\t// hundredths\n\td = floor(.5+mod(num/.01,10.));\n\tif( d > 0. )\n\t{\n\t\tresult += drawDigit( d, pos, pixel_coords );\n\t\tpos.x += 4. / iResolution.x;\n\t}\n\t\n\treturn clamp(result,0.,1.);\n}\n\nvec3 hsv2rgb(vec3 c);\nvec3 rgb2hsv(vec3 c);\n\nvec3 errorColour( float err, float maxerror )\n{\n\terr = 1. - err / maxerror;\n\terr *= 2. / 3.;\n\treturn hsv2rgb( vec3(err, 1., 1.) );\n}\n\n//http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n","name":"Image","description":"","type":"image"}]}