{"ver":"0.1","info":{"id":"MtsfDS","date":"1513316062","viewed":126,"name":"Ray Tracing Basic Shading","username":"jacwilso","description":"Ray tracing fragment shader, see list at bottom for what is included. Added sound for fun.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rn","filepath":"/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","previewfilepath":"/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","type":"music","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//=======================================================================================\nstruct Light {\n\tvec3 position;\n    int type; // 0 - point, 1 - directional, 2 - spotlight\n    vec3 direction;\n    float intensity;\n    vec3 color;\n    float angle;\n    float cutoff;\n};\n\n//=======================================================================================\nstruct Material {\n    vec3 albedo;\n    vec3 emissiveColor;\n    bool isReflective;\n    float smoothness;\n};\n    \n//=======================================================================================\nstruct Sphere {\n\tvec4 center;\n    Material mat; \n};\n    \n//=======================================================================================\nstruct Rectangle {\n\tvec3 minCorner, maxCorner;\n    Material mat;\n};\n\n//=======================================================================================\n\n// Constants\nconst float bias = 0.00003;\nconst float PI = 3.141519;\n// 0 - Phong, 1 - Blinn-Phong\n#define SPECULAR 1\n\n// Objects in Environment\nconst Sphere spheres[2] = Sphere[](\n\t// red sphere\n\tSphere(vec4(-0.4, 0.4, 0.5, 0.5), Material(vec3(0.9, 0.6, 0.6), vec3(0.0), true, 120.0)),\n\t// blue sphere\n\tSphere(vec4(-0.8, 0.4, -0.75, 0.25), Material(vec3(0.1, 0.1, 0.9), vec3(0.1, 0.1, 0.9), false, 120.0))\n);\nconst Rectangle rectangles[1] = Rectangle[](\n\t// green box\n\tRectangle(vec3(0.4,-0.3,-0.5), vec3(1.4,0.3,0.5), Material(vec3(0.1, 0.9, 0.1), vec3(0.0), false, 120.0))\n);\n\n// Lighting\nLight lights[3] = Light[](\n    Light (vec3(0.0, 0.0, 0.0), 0, vec3(0.0, 0.0, 0.0), 0.15, vec3(1.0), 0.0, 2.0),\n    Light (vec3(0.0, 0.0, 0.0), 1, vec3(1.0, 0.0, 0.0), 0.5, vec3(1.0), 0.0, 2.0),\n    Light (vec3(1.5, 0.5, -0.6), 2, vec3(-1.0, -1.0, 1.0), 0.5, vec3(1.0), PI / 4.0, 2.0)\n);\n    \n//=======================================================================================\nbool RayIntersectAABox  (in Rectangle box, in vec3 rayPos, in vec3 rayDir, out vec3 hitPos, out vec3 normal, inout float maxTime)\n{\n    vec3 boxCenter = (box.minCorner+box.maxCorner)*0.5;\n\tvec3 roo = rayPos - boxCenter;\n    vec3 rad = (box.maxCorner - box.minCorner)*0.5;\n\n    vec3 m = 1.0/rayDir;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    vec2 time = vec2( max( max( t1.x, t1.y ), t1.z ),\n                 min( min( t2.x, t2.y ), t2.z ) );\n    \n    // if the time is beyond the maximum allowed bail out (we hit somethign else first!)\n    if (time.x > maxTime)\n        return false;\n    \n    // if time invalid or we hit from inside, bail out\n    if (time.y < time.x || time.x < 0.0)\n        return false;\n\t\n    // calculate surface normal\n    hitPos = rayPos + rayDir * time.x;   \n    vec3 hitPosRelative = hitPos - boxCenter;\n    vec3 hitPosRelativeAbs = abs(hitPosRelative);\n    vec3 distToEdge = abs(hitPosRelativeAbs - rad);\n\n    float closestDist = 1000.0;\n    for(int axis = 0; axis < 3; ++axis)\n    {\n        if (distToEdge[axis] < closestDist)\n        {\n            closestDist = distToEdge[axis];\n            normal = vec3(0.0);\n            if (hitPosRelative[axis] < 0.0)\n                normal[axis] = -1.0;\n            else\n                normal[axis] = 1.0;\n        }\n    }        \n\n    // store the collision time as the new max time\n    maxTime = time.x;\n    return true;\n}\n\n//=======================================================================================\nbool RayIntersectSphere (in Sphere sphere, in vec3 rayPos, in vec3 rayDir, out vec3 hitPos, out vec3 normal, inout float maxTime)\n{\n    if (sphere.center.w <= 0.0)\n        return false;\n    \n\t//get the vector from the center of this circle to where the ray begins.\n\tvec3 m = rayPos - sphere.center.xyz;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.center.w * sphere.center.w;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn false;\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn false;\n\n\t//ray now found to intersect sphere, compute smallest t value of intersection\n\tfloat collisionTime = -b - sqrt(discr);\n\n\t//if t is negative, ray started inside sphere so clamp t to zero and remember that we hit from the inside\n\tif(collisionTime < 0.0)\n        return false;\n    \n    // if the time is beyond the maximum allowed bail out (we hit somethign else first!)\n    if (collisionTime > maxTime)\n        return false;\n    \n    // store the collision time as the new max time\n    maxTime = collisionTime;\n    \n\t//compute the point of intersection\n\thitPos = rayPos + rayDir * collisionTime;    \n    \n   \t// calculate the normal\n\tnormal = hitPos - sphere.center.xyz;\n\tnormal = normalize(normal); \n\n\treturn true;\n}\n\n//=======================================================================================\n// Is object hit, pass back normal and albedo\nbool TraceRay (in vec3 rayPos, in vec3 rayDir, in float maxDistance, inout vec3 hitPos, inout vec3 normal, inout Material mat)\n{   \n    float maxRayHitTime = 1000.0;\n\tbool hit = false;\n\t\n    // Rectangle Objects\n    for (int i = 0; i < rectangles.length(); i++)\n    {\n    \tif (RayIntersectAABox(rectangles[i], rayPos, rayDir, hitPos, normal, maxRayHitTime))\n    \t{\n        \thit = true;\n            mat = rectangles[i].mat;\n    \t}\n    }\n    \n    // Sphere Objects\n    for (int i = 0; i < spheres.length(); i++)\n    {\n        if (RayIntersectSphere(spheres[i], rayPos, rayDir, hitPos, normal, maxRayHitTime))\n    \t{\n            hit = true;\n            mat = spheres[i].mat;\n        }\n    }\n    \n    // Check if the object's distance is within the ray range (maxDistance)\n    if (hit && maxDistance > 0.0 && distance(hitPos, rayPos) > maxDistance)\n        return false;\n    \n    return hit;\n}\n \n//=======================================================================================\n// Is object occluded\nbool Shadow (in Light light, in vec3 rayPos, in vec3 normal)\n{    \n    float maxDistance = -1.0;\n    vec3 lightDir = -light.direction;\n    // If not directional light, max distance is distance to the light position\n    if (light.type != 1)\n    {\n        vec3 toLight = light.position - rayPos;\n        lightDir = normalize(toLight);\n        maxDistance = length(toLight);\n    }\n    \n    vec3 hitPos, hitNormal;\n    Material mat;\n    return TraceRay(rayPos + normal * bias, lightDir, maxDistance, hitPos, hitNormal, mat);\n}\n    \n//=======================================================================================\n// Return specified light's contribution - Diffuse, Specular (Phong, Blinn-Phong)\nvec3 LightCalculation (in Light light , in vec3 normal, in vec3 rayDir, in vec3 hitPos, in float smoothness)\n{\n    const float kd = 1.0;\n    const float ks = 1.0;\n    \n    vec3 v = -1.0 * rayDir;\n\tvec3 lightDir = -light.direction;\n    float lightIntensity = light.intensity;\n    // Point Light\n    if (light.type == 0)\n    {\n        vec3 toLight = light.position - hitPos;\n\t    lightDir = normalize(toLight);\n        lightIntensity /= pow(length(toLight), light.cutoff);\n    }\n    // Spotlight\n    else if (light.type == 2)\n    {\n        vec3 toLight = hitPos - light.position;\n        float halfAngle = light.angle / 2.0;\n        float dist = dot(normalize(toLight), normalize(light.direction));\n        if (dist >= cos(halfAngle))\n        {\n            lightIntensity /= pow(length(toLight), light.cutoff);\n        }\n        else\n        {\n\t\t\tlightIntensity = 0.0;\n        }\n    }    \n    \n    \n    float diffuseFactor = max(0.0, dot(normal, lightDir));\n    \n    //Specular\n    vec3 reflection = 2.0 * dot(normal, lightDir) * normal - lightDir;\n    float specularFactor;\n    #if SPECULAR == 0\n        // Phong\n        specularFactor = pow(max(0.0, dot(v, reflection)), smoothness);\n    #elif SPECULAR == 1\n        // Blinn-Phong\n        vec3 h = (v + lightDir) / length(v + lightDir);\n\t\tspecularFactor = pow(max(0.0, dot(normal, h)), smoothness);\n    #endif\n    \n\tvec3 diffuse = kd * lightIntensity * light.color * diffuseFactor;\n    vec3 specular = ks *  lightIntensity * light.color * specularFactor;\n    \n    vec3 lightAlbedo = diffuse + specular;\n    \n    return lightAlbedo;\n}\n\n//=======================================================================================\n// Return the shade of the pixel from all lights\nvec3 ShadePixel (in Material mat, in vec3 normal, in vec3 rayDir, in vec3 hitPos)\n{\n    const float ka = 1.0;\n\tconst float ambientIntensity = 0.2;\n\tconst vec3 ambientColor = vec3 (1.0);\n\tvec3 ambient = ka * ambientIntensity * ambientColor;\n    \n    // Apply ambient + emissive if not shadowed\n    vec3 light = ambient + mat.emissiveColor;\n    for (int i = 0; i < lights.length(); i++)\n    {\n        // Check if object is shadowed\n        if (!Shadow(lights[i], hitPos, normal))\n        {\n\t        light += LightCalculation (lights[i], normal, rayDir, hitPos, mat.smoothness);\n        }\n    }\n    \n\treturn light;\n}\n\n//=======================================================================================\n// Return the albedo of reflected object\nvec3 Reflection (in vec3 rayPos, in vec3 rayDir, in vec3 normal)\n{\n   \tvec3 v = -1.0 * rayDir;\n\tvec3 reflection = 2.0 * dot(normal, v) * normal - v;\n    \n\tMaterial hitMat;\n    vec3 hitPos, hitNormal;\n    float maxDistance = -1.0;\n    // Check if ray hits object or environment\n    if (TraceRay(rayPos + normal * bias, reflection, maxDistance, hitPos, hitNormal, hitMat))\n    {\n        vec3 hitLight = ShadePixel (hitMat, hitNormal, rayDir, hitPos);\n        return hitLight * hitMat.albedo;\n    }\n    else\n    {\n\t\treturn texture(iChannel0, reflection).rgb;\n    }\n}\n\n//=======================================================================================\n// Modify the absolute color of the pixel w/ reflection + lighting\nvoid ColorPixel (in vec3 rayPos, in vec3 rayDir, inout vec3 pixelColor)\n{\n    float maxRayHitTime = 1000.0;\n\tbool hit = false;\n    vec3 hitPos;    \n    vec3 normal;            \n    vec3 albedo;\n    Material mat;\n\n    for (int i = 0; i < rectangles.length(); i++)\n    {\n    \tif (RayIntersectAABox(rectangles[i], rayPos, rayDir, hitPos, normal, maxRayHitTime))\n    \t{\n        \thit = true;\n        \tmat = rectangles[i].mat;\n            albedo = mat.albedo;\n            if (rectangles[i].mat.isReflective)\n            {\n                albedo *=  Reflection (hitPos, rayDir, normal);\n          \t}\n    \t}\n    }\n    \n    for (int i = 0; i < spheres.length(); i++)\n    {\n        if (RayIntersectSphere(spheres[i], rayPos, rayDir, hitPos, normal, maxRayHitTime))\n    \t{\n            hit = true;\n            mat = spheres[i].mat;\n            albedo = mat.albedo;\n            if (spheres[i].mat.isReflective)\n            {\n                albedo *= Reflection (hitPos, rayDir, normal);\n          \t}\n        }\n    }\n    \n    \n    if (!hit)\n\t\treturn;\n    \n    pixelColor = albedo * ShadePixel (mat, normal, rayDir, hitPos);\n}\n\n//=======================================================================================\n// Modify the pixel color to bloom\nvoid Bloom (inout vec3 pixelColor)\n{\n    float strength = 3.5;\n    vec3 bloom = pixelColor;\n    pixelColor = pow(bloom, vec3(strength)) * bloom + bloom;\n}\n\n//=======================================================================================\n// Modify the pixel color to create a dynamic vignette\nvoid Vignette (inout vec3 pixelColor, in vec3 rayDir, in vec3 cameraLeft, in vec3 cameraUp)\n{\n    vec2 uv = vec2(dot(cameraLeft, rayDir), dot(cameraUp, rayDir)) + 0.5;\n   \tpixelColor -= vec3(1.0) *  pow(distance(uv, vec2(0.5, 0.5)), 3.0)  * 7.0;\n}\n             \n//=======================================================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    //----- camera setup\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\n    vec3 cameraAt \t= vec3(0.0,0.0,0.0);\n\n    float angleX = iMouse.z > 0.0 ? 6.28 * mouse.x : 0.0;\n    float angleY = iMouse.z > 0.0 ? (mouse.y * 6.28) : 0.0;\n\n    vec3 cameraPos\t= (vec3(sin(angleX)*cos(angleY), sin(angleY), cos(angleX)*cos(angleY))) * 4.0;\n\n    vec3 cameraFwd;\n    vec3 cameraLeft;\n    vec3 cameraUp;\n\n    float cameraViewWidth\t= 6.0;\n    float cameraViewHeight\t= cameraViewWidth * iResolution.y / iResolution.x;\n    float cameraDistance\t= 6.0;  // intuitively backwards!    \n    \n\tvec2 rawPercent = (fragCoord.xy / iResolution.xy);\n\tvec2 percent = rawPercent - vec2(0.5,0.5);\n\t\n\tvec3 rayPos;\n\tvec3 rayTarget;\n\t   \n\t// if the mouse button is down do orbit camera\n\tif( iMouse.z > 0.0 ) {\n\t\tcameraFwd = normalize(cameraAt - cameraPos);\n        cameraLeft  = normalize(cross(normalize(cameraAt - cameraPos), vec3(0.0,sign(cos(angleY)),0.0)));\n        cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n        \n\t\trayPos = cameraPos;\n\t}\n\t// else handle the case of the mouse button not being down\n\telse {\n\t\t// Rotate the ray (ie camera) w/ specified radius and frequency\n        const float camRadius = 4.0;\n        const float camFrequency = 0.5;\n\t\trayPos = vec3(camRadius * cos(camFrequency * iTime), 1.0, camRadius * sin(camFrequency * iTime));\n        //rayPos = vec3(0.0,3.0,-3.0);\n        \n\t\tcameraFwd = normalize(cameraAt - rayPos);\n\t\tcameraLeft = normalize(cross(cameraFwd, vec3(0.0,1.0,0.0)));\n\t\tcameraUp = normalize(cross(cameraLeft, cameraFwd));\n\t}\n    rayTarget = (cameraFwd * cameraDistance)\n\t\t\t\t  + (cameraLeft * percent.x * cameraViewWidth)\n\t\t          + (cameraUp * percent.y * cameraViewHeight);\n\t\t\n    \n\t//----- ray trace\n\tvec3 rayDir = normalize(rayTarget);\n    \n    // initialze ray color to the cube map\n    vec3 pixelColor = texture(iChannel0, rayDir).rgb;\n    \n    // ray trace - color\n\tColorPixel(rayPos, rayDir, pixelColor);\n    \n    // output sRGB corrected pixel\n    pixelColor = pow(pixelColor, vec3(1.0/2.2));   \n   \t\n    // Vignetting\n    Vignette(pixelColor, rayDir, cameraLeft, cameraUp);\n   \n    // Bloom\n    Bloom(pixelColor);\n    \n    fragColor = vec4(pixelColor, 1.0);\n}\n\n/*\n*- point light and directional light (diffuse + specular. Doesn't need to be PBR. Lambert / phong is ok!)\n*- ambient lighting\n*- emissive lighting\n*- environment mapped reflections\n*- shadows\n*- ray based reflections\n*- post processing effects (bloom, vignetting)\n*- animating the camera\n*- spotlight\n*/","name":"Image","description":"","type":"image"}]}