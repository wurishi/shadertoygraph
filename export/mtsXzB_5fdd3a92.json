{"ver":"0.1","info":{"id":"mtsXzB","date":"1675026314","viewed":132,"name":"Refraction - azavier","username":"azavier","description":"ref","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","refraction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Material {\n  vec3 alb;\n  float iref;// LARGER THAN 1\n};\nMaterial[] materials = Material[](\n  Material(vec3(0.3,0.1,0.4), 0.),\n  Material(vec3(0.33), 1.5),\n  Material(vec3(0.6, 0.2, 0.25), 0.)\n);\n\nstruct Ray {\n  vec3 ro;\n  vec3 rd;\n  \n  float bounces;\n  float[3] hit;\n  vec3 hitp;\n  vec3 hitn;\n  Material mat;\n};\n\nvoid rectify(inout float d, inout float mat, in float od, in float om) {\n  float c = step(od, d);\n  \n  d = mix(d, od, c);\n  mat = mix(mat, om, c);\n}\nfloat[2] sdf(in vec3 p) {\n  float dist = FAR;\n  float matID = -1.;\n  \n  float ground = p.y;\n  rectify(dist, matID, ground, 1.0);\n  \n  vec3 rp = p-vec3(0, 1.05, 0);\n  rp.xz *= rot(-iTime);\n  \n  float rho = sdfRhombicIcos(rp, 1.);\n  rectify(dist, matID, rho, 2.0);\n  \n  vec3 sp = p-vec3(0,1,0);\n  sp -= vec3(0,0,2);\n  float sphere = length(sp) - 0.2;\n  rectify(dist, matID, sphere, 3.0);\n  \n  sp = p-vec3(0,1,0);\n  sp = abs(sp);\n  sp -= vec3(2,0,0);\n  sphere = length(sp) - 0.2;\n  rectify(dist, matID, sphere, 3.0);\n  \n  return float[](dist, matID);\n}\n\nvec3 normal(in vec3 p) {\n  vec2 delta = vec2(0.0001, 0);\n  vec3 v1 = vec3(\n    sdf(p-delta.xyy)[0],\n    sdf(p-delta.yxy)[0],\n    sdf(p-delta.yyx)[0]\n  );\n  vec3 v2 = vec3(\n    sdf(p+delta.xyy)[0],\n    sdf(p+delta.yxy)[0],\n    sdf(p+delta.yyx)[0]\n  );\n  return normalize(v2 - v1);\n}\n\nfloat[3] trace(in vec3 ro, in vec3 rd, in int steps, in float side) {\n  float dist;\n  float[2] sd;\n  \n  for(int i; i < steps; i++) {\n    sd = sdf(ro + rd*dist);\n    sd[0] *= side;\n    if(step(HIT, sd[0]) + step(dist, FAR) == 0.0)\n      break;\n    \n    dist += sd[0];\n  }\n  \n  return float[](dist, sd[1], sd[0]);\n}\n\nvec3 texel(in Ray ray) {\n  switch(int(ray.hit[1])) {\n    case 1:\n      float s = 0.1414;\n      float g = mod(floor(s*ray.hitp.x)+floor(s*ray.hitp.z), 2.);\n      vec3 acc = vec3(0.6);\n      return mix(ray.mat.alb, acc, g);\n    default:\n      return ray.mat.alb;\n      //return 0.5+normal(ray.hitp)*0.5;\n  }\n}\n\nvec3 bgcol(in vec3 rd) {\n  rd.xz *= rot(iTime*0.5);\n  return 0.5+rd*0.5;\n}\n\nvoid refractt(inout Ray ray) {\n  ray.hitn = normal(ray.hitp);\n  \n  ray.ro = ray.hitp - ray.hitn*HIT*4.;\n  vec3 rdent = refract(ray.rd, ray.hitn, 1./ray.mat.iref);\n  \n  float dI = trace(ray.ro, rdent, STEPS, -1.)[0];\n  \n  ray.ro += rdent*dI;\n  ray.hitn = -normal(ray.ro);\n  \n  ray.rd = refract(rdent, ray.hitn, ray.mat.iref);\n  \n  float rayc = abs(ray.rd.x) + abs(ray.rd.y) + abs(ray.rd.z);\n  float checkray = step(0.0, rayc) + step(rayc, 0.0) - 1.0;\n  \n  ray.rd = mix(ray.rd, reflect(rdent, ray.hitn), checkray);\n  dI = mix(dI, trace(ray.ro+ray.hitn*HIT*4., ray.rd, STEPS, -1.)[0], checkray);\n  ray.ro += mix(vec3(0), ray.rd*dI, checkray);\n  ray.hitn = mix(ray.hitn, -normal(ray.ro), checkray);\n  \n  ray.ro -= ray.hitn*HIT*4.;\n}\n\nvec3 bounce(inout Ray ray) {\n  ray.hit = trace(ray.ro, ray.rd, STEPS, 1.);\n  \n  vec3 bg = bgcol(ray.rd);\n    \n  ray.mat = material(int(ray.hit[1]));\n  ray.hitp = ray.ro + ray.rd*ray.hit[0];\n  \n  vec3 surf = texel(ray);\n  \n   //REFLECTIONS\n  //ray.hitn = normal(ray.hitp);\n  //ray.ro = ray.hitp + ray.hitn*HIT;\n  //ray.rd = reflect(ray.rd, ray.hitn);\n  \n   //REFRACTIONS\n  if(step(ray.mat.iref, 1.0) == 0.0)\n    refractt(ray);\n  \n  return mix(surf, bg, S(0., FAR*FAR, ray.hit[0]*ray.hit[0]));\n}\n\nvec3 pixcol(in vec2 uv) {\n  vec3 col;\n  \n  Ray ray;\n  ray.ro = vec3(0, 1, -3);\n  ray.ro.x += 0.5*cos(2.*iTime);\n  ray.ro.y += 0.5*sin(2.*iTime);\n  ray.rd = normalize(vec3(uv*1.25, 1)); \n  \n  for(ray.bounces; step(BOUNCES, ray.bounces) + step(FAR, ray.hit[0]) == 0.0; ray.bounces++)\n    col += bounce(ray);\n  \n  float check = step(1.0, ray.bounces);\n  col *= mix(1.0, 1.0/ray.bounces, check);\n  \n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n  vec3 col;\n  \n  col += pixcol(uv);\n\n  fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define FAR 17.5\n#define HIT 0.0075\n\n#define STEPS 80\n\n#define BOUNCES 2.0\n\n#define sat(a) clamp(a,0.,1.)\n#define S smoothstep\n#define material(ind) materials[ind-1]\n\n#define PI 3.141592653\n#define TAU 6.283185306\n\nmat2x2 rot(in float a) {\n  float s = sin(a), c = cos(a);\n  \n  return mat2x2(c, -s, s, c);\n}\n\nfloat sdfBox(vec3 p, vec3 s) {\n  p = abs(p)-s;\n  return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdfRhombicIcos(in vec3 p, in float r) {\n  float c = cos(PI/5.), s = sqrt(0.75-c*c);\n  vec3 n = vec3(-0.5, -c, s);\n\n  p = abs(p);\n  p -= 2.*min(0., dot(p, n))*n;\n\n  p.xy = abs(p.xy);\n  p -= 2.*min(0., dot(p, n))*n;\n\n  p.xy = abs(p.xy);\n  p -= 2.*min(0., dot(p, n))*n;\n\n  return p.z-1.;\n}","name":"Common","description":"","type":"common"}]}