{"ver":"0.1","info":{"id":"MtlXD8","date":"1436541492","viewed":1785,"name":"HURA generator","username":"nimitz","description":"Hexagonal uniformly redundant arrays.  Inspired by the Sixty Symbols video on Coded Masks: https://www.youtube.com/watch?v=_ezhdhHNku0\n\nTry different v and r values and let me know if you find interesting ones!","likes":59,"published":1,"flags":0,"usePreview":0,"tags":["math","ura","hura","codedmask"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"//HURA generator by nimitz (twitter: @stormoid)\n\n/*\n  \tAfter watching syxty simbols video on Coded Masks:\n\t\thttps://www.youtube.com/watch?v=_ezhdhHNku0\n\t\n\tI was wondering what was the math behind those nice looking\n\thexagonal patterns, I found this paper online:\n\t\thttp://articles.adsabs.harvard.edu//full/1985ICRC....3..295F/C000295.000.html\n\t(note that the paper seems to have a mistake on page 296, Figure 2. is indeed order 23\n\tbut of r=15 and not r=5)\n\n\tI am using iq's hexagon grid function: https://www.shadertoy.com/view/Xd2GR3\n\n\tThe nice thing is that the main generation loop seems to get optimized\n\tout, so the limit on the order of these patterns seems very high, I tried with\n\tv=9907 an no problems at all!\n*/\n\nconst float v = 151.0;  //v should be a prime of the form 4n-1\nconst float r = 32.0;\n\n/*\n\tSome nice examples (from the paper doesn't give the r values!):\n\tv = 67 , r = 29\n\tv = 139, r = 42\n\tv = 151, r = 32\n\tv = 331, r = 31\n\n\tI tried with prime order up to 9907 and no compile problems!\n\n\tLet me know if you find interesting looking ones, \n\tI'll add them to the list.\n*/\n\n//If you want to increment r with time uncomment next line\n//#define INCREMENT_R\n#define BORDERS\n\n#define time iTime\n\n//From iq: https://www.shadertoy.com/view/Xd2GR3\nvec4 hexagon(in vec2 p) \n{\n\tvec2 q = vec2( p.x*2.0*0.5773503, p.y + p.x*0.5773503 );\n\tvec2 pi = floor(q), pf = fract(q);\n\tfloat v = mod(pi.x + pi.y, 3.0);\n\tfloat ca = step(1.0,v), cb = step(2.0,v);\n\tvec2  ma = step(pf.xy,pf.yx);\n\tfloat e = dot( ma, 1.0-pf.yx + ca*(pf.x+pf.y-1.0) + cb*(pf.yx-2.0*pf.xy) );\n\tp = vec2( q.x + floor(0.5+p.y/1.5), 4.0*p.y/3.0 )*0.5 + 0.5;\n\tfloat f = length( (fract(p) - 0.5)*vec2(1.0,0.85) );\t\t\t\n\treturn vec4( pi + ca - cb*ma, e, f );\n}\n\nfloat URA(in vec2 p)\n{\n#ifdef INCREMENT_R\n    float l = mod(p.y + floor(time*1.5)*p.x, v);\n#else\n    float l = mod(p.y + r*p.x, v);\n#endif\n\tfloat rz = 1.;\n    \n    //Looks like this loop gets optimized, allowing for high order patterns.\n    for(float i = 1.;i<(v/2.);i++)\n        if (mod(i*i,v) == l)rz= .0;\n    \n    return rz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    vec2 p = fragCoord.xy/iResolution.xy*2.-1.;\n    vec2 q = p;\n    p.x *= iResolution.x/iResolution.y;\n    \n\tvec4 h = hexagon(p*21.);\n\t\n    vec3 col = vec3(URA(h.xy));\n    #ifdef BORDERS\n    if (dot(col,vec3(1)) > 1.)\n    \tcol *= smoothstep(-0.2,.13,h.z);\n    else\n    \tcol = 1.-(1.-col)*smoothstep(-0.2,.13,h.z);\n    #endif\n    \n    col *= smoothstep(1.01,.95,max(abs(q.x),abs(q.y)));\n        \n\tfragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}