{"ver":"0.1","info":{"id":"NlBSWK","date":"1631671451","viewed":134,"name":"Water Stuff","username":"mkorenchan","description":"water stuff. currently contains no water","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["water"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Michael Korenchan\n// University of Illinois at Urbana-Champaign\n// In-progress shader for playing with water effects. currently contains no water\n\n#define RAYMARCH_STEPS 600.\n#define RAYMARCH_MAX_DIST 10000.\n#define RAYMARCH_MIN_DIST 0.0001\n#define FLT_MAX 3.40282e+038\n#define sdot(a,b) clamp(dot(a,b),0.,1.)\n#define PI 3.14159265358979\n#define saturate(f) clamp(f,0.,1.)\n\nconst vec2 epsln = vec2(0.00001,0.);\n\nstruct SDFData {\n    float dist;\n    bool water;\n};\n\nstruct MarchResult {\n    bool hit;\n    float totalD;\n    vec3 hitP;\n    vec3 nrml;\n    SDFData sdfData;\n};\n\nmat2 rot(float angle) {\n    float s = sin(angle), c = cos(angle);\n    return mat2(c,-s,s,c);\n}\n\nfloat noise(vec2 uv) {\n    uv += .1;\n\tuv = fract(uv*vec2(322.24, 64.23));\n    uv += dot(uv, uv+23.45);\n    return fract(uv.x*uv.y);\n}\n\nSDFData sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return SDFData(length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0), false);\n}\n\nSDFData sdPlane(vec3 p, float height, bool water) {\n    return SDFData(p.y-height, water);\n}\n\nfloat waterMap(vec2 uv, float t) {\n    float d = 0.;\n    d += .6*texture(iChannel0, vec2(.5)*(uv+vec2(.05,.1)*t)).r;\n    d += .4*texture(iChannel0, vec2(.6)*(uv+vec2(.03,-.02)*t)).r;\n    d += .2*texture(iChannel0, vec2(.9)*(uv+vec2(-.01,.1)*t)).r;\n    return saturate(d);\n}\n\nSDFData sdHeightMap(vec3 p, float base) {\n    vec2 uv = p.xz;\n    float t = .1*iTime;\n    float height = waterMap(.04*uv, t);\n    height *= .2;\n    \n    return SDFData(p.y - height - base, false);\n}\n\n\nSDFData sdf(vec3 p) {\n    SDFData best = SDFData(FLT_MAX, false);\n    SDFData box = sdBox(p-vec3(0,0,0), vec3(.2,.2,.2));\n    SDFData ground = sdPlane(p, -0.6, false);\n    SDFData water = sdHeightMap(p, -.6);\n    \n    if (box.dist < best.dist) best = box;\n    //if (ground.dist < best.dist) best = ground;\n    if (water.dist < best.dist) best = water;\n    //if (water.dist < best.dist) best = water;\n    \n    return best;\n}\n\nvec3 getNormal(vec3 p) {\n    const vec2 epsln = vec2(0.0001,0.);\n    vec3 d = sdf(p).dist-vec3(sdf(p-epsln.xyy).dist,sdf(p-epsln.yxy).dist,sdf(p-epsln.yyx).dist);\n    return normalize(d);\n}\n\nMarchResult rayMarch(vec3 start, vec3 dir, float maxDist) {\n    MarchResult res = MarchResult(false,0.,start,vec3(0), SDFData(0.,false));\n    for (float i = 0.; i < RAYMARCH_STEPS; i+=1.) {\n        res.sdfData = sdf(res.hitP);\n        res.totalD += res.sdfData.dist;\n        res.hitP = start + res.totalD*dir;\n        if (res.sdfData.dist < RAYMARCH_MIN_DIST) {\n            res.hit = true;\n            break;\n        }\n        if (res.totalD >= maxDist) {\n            break;\n        }\n    }\n    if (res.hit) {\n        res.nrml = getNormal(res.hitP);\n    }\n    return res;\n}\n\nfloat shadow(vec3 p, vec3 dir, float dist) {\n    MarchResult res = rayMarch(p, dir, dist);\n    return res.hit ? 0.1 : 1.;\n}\n\nfloat shade(vec3 camDir, MarchResult data) {\n    vec3 lightPos = vec3(0,2,2);\n    vec3 lightDir = normalize(lightPos-data.hitP);\n    float l = sdot(data.nrml, lightDir);\n    float ambient = 0.1;\n    l += ambient;\n    \n    data.hitP += 0.1*data.nrml;\n    l *= shadow(data.hitP, lightDir, distance(data.hitP, lightPos));\n\n    return saturate(l);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 camPos = 2.*vec3(0,.5,1);\n    vec3 camDir = normalize(vec3(uv,-1));\n    mat2 camRot = rot(iMouse.x/100.+PI);\n    camPos.xz *= camRot;\n    camDir.yz *= rot(-.5);\n    camDir.xz *= camRot;\n    \n\n    MarchResult res = rayMarch(camPos, camDir, RAYMARCH_MAX_DIST);\n    \n    float d = shade(camDir, res);\n\n    //d = waterMap(1.*uv, iTime);\n    \n    vec3 col = vec3(d);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}