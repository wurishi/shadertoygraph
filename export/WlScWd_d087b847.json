{"ver":"0.1","info":{"id":"WlScWd","date":"1595751856","viewed":1040,"name":"Space Racer","username":"sdfgeoff","description":"A mini racing game. Race against three AI spaceships. You are the blue one. The AI's are pretty average, you should be able to beat them fairly easily.","likes":19,"published":1,"flags":48,"usePreview":0,"tags":["sprite","race","spaceship","ai"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define CHANNEL_STATE iChannel0\n#define CHANNEL_SPRITES iChannel1\n#define CHANNEL_SPRITES_RESOLUTION iChannelResolution[1].xy\n\n#define CHANNEL_TRAILS iChannel2\n#define CHANNEL_TRAILS_RESOLUTION iChannelResolution[2].xy\n\n//#define SHOW_SPRITE_BUFFER\n//#define SHOW_STATE_BUFFER\n//#define SHOW_TRAILS_BUFFER\n\n\nvec4 neon(float sdf, vec4 color, float glow_width) {\n    float ramp = clamp(1.0 - sdf / glow_width, 0.0, 1.0);\n    vec4 outp = vec4(0.0);\n    ramp = ramp * ramp;\n    outp += pow(color, vec4(4.0)) * ramp;\n    ramp = ramp * ramp;\n    outp += color * ramp;\n    ramp = ramp * ramp;\n    outp += vec4(1.0) * ramp;\n    return outp;\n}\n\n\nmat3 get_trans_mat(float angle, vec2 position, vec2 scale) {\n    // Constructs a transformation matrix\n    float c = cos(angle);\n    float s = sin(angle);\n    \n    mat3 offset = mat3(\n        c, s, 0.0,\n        -s, c, 0.0,\n        position.x, position.y, 1.0\n    ) * mat3(\n        scale.x, 0.0, 0.0,\n        0.0, scale.y, 0.0,\n        0.0, 0.0, 1.0\n    );\n    \n    return offset;\n}\n\n\n\nvec4 fetch_sprite(ivec2 tile_id, vec2 uv) {\n    if (any(lessThan(uv, vec2(-1.0))) || any( greaterThan(uv, vec2(1.0)))) {\n        return vec4(1.0);\n    }\n    uv = uv * 0.5 + 0.5 + vec2(tile_id);\n    uv = uv * SPRITE_SIZE; // Convert to pixels;\n    uv.y += MAP_SIZE.y;\n    uv /= CHANNEL_SPRITES_RESOLUTION; // Convert back to UV;\n    return texture(CHANNEL_SPRITES, uv);\n}\n\n\nvec4 draw_sprite(vec2 frag_coord, ivec2 tile_id, mat3 trans_mat) {\n    vec2 uv = (inverse(trans_mat) * vec3(frag_coord, 1.0)).xy;\n    return fetch_sprite(tile_id, uv);\n}\n\n\nfloat draw_background(vec2 world_coordinates) {\n    vec2 sections = mod(world_coordinates, 1.0);\n    vec2 lines = abs(0.5 - sections) + 0.04;\n    \n    return min(lines.x, lines.y);\n}\n\n\nvec4 draw_start_box(vec2 world_coords) {\n    mat3 offset = get_trans_mat(\n        MAP_START_LINE.z, // angle\n        MAP_START_LINE.xy, // position\n        vec2(0.5) // scale\n    );\n    \n    float sdf = draw_sprite(\n        world_coords,\n        SPRITE_START_BOX,\n        offset\n    ).b;\n    return neon(sdf, vec4(1.0, 1.0, 1.0, 1.0), 0.05) * 0.2;\n}\n\n\nfloat draw_map(vec2 world_coords, float line_width) {\n    vec4 raw = sample_map(CHANNEL_SPRITES, CHANNEL_SPRITES_RESOLUTION, world_coords);\n    \n    float edge_sdf = abs(raw.z) / line_width;\n    \n    if (raw.z > 0.0) {\n        edge_sdf = min(edge_sdf, draw_background(world_coords));\n    }\n    \n    return edge_sdf;\n}\n\n\nvec4 draw_ship(vec2 world_coords, ship_t ship, vec4 color) {\n    mat3 ship_trans = get_trans_mat(\n        ship.position.z, // angle\n        ship.position.xy, // position\n        vec2(SHIP_SCALE) // scale\n    );\n    \n    mat3 flame_trans = ship_trans * mat3(\n        1.0, 0.0, 0.0,\n        0.0, 1.0, 0.0,\n        0.0, -1.45, 1.0\n    );\n    \n    vec4 final_sdf = draw_sprite(\n        world_coords,\n        SPRITE_SHIP,\n        ship_trans\n    );\n    \n    \n    if (ship.flame) {\n        final_sdf = min(\n            final_sdf,\n            draw_sprite(\n            \tworld_coords,\n        \t\tSPRITE_FLAME,\n            \tflame_trans\n        \t)\n    \t);\n    }\n    \n    \n    return neon(final_sdf.z, color, 0.1);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 centered = (uv - 0.5) * 2.0;\n    centered.x*= iResolution.x / iResolution.y; // (0,0) in center of screen\n    vec2 world_coords = centered;\n    world_coords /= ZOOM;\n    \n    fragColor = vec4(0.0);\n    \n    ship_t ship_1 = unpack_ship(read_data(CHANNEL_STATE, A_SHIP_1));\n    ship_t ship_2 = unpack_ship(read_data(CHANNEL_STATE, A_SHIP_2));\n    ship_t ship_3 = unpack_ship(read_data(CHANNEL_STATE, A_SHIP_3));\n    ship_t ship_4 = unpack_ship(read_data(CHANNEL_STATE, A_SHIP_4));\n    \n    \n    world_coords += ship_1.position.xy;\n    \n    float predict_amount = dot(ship_1.velocity.xy, ship_1.velocity.xy);\n    world_coords += ship_1.velocity.xy * predict_amount * 0.008;\n    \n    vec4 ship_1_sprite = draw_ship(world_coords, ship_1, COLOR_SHIP_1);\n    vec4 ship_2_sprite = draw_ship(world_coords, ship_2, COLOR_SHIP_2);\n    vec4 ship_3_sprite = draw_ship(world_coords, ship_3, COLOR_SHIP_3);\n    vec4 ship_4_sprite = draw_ship(world_coords, ship_4, COLOR_SHIP_4);\n        \n    vec4 map = neon(\n        draw_map(world_coords, 0.03),\n        vec4(0.9, 0.9, 0.9, 1.0), 0.1\n    );\n    \n    vec4 trail_data = sample_trails(CHANNEL_TRAILS, CHANNEL_TRAILS_RESOLUTION, world_coords);\n    vec4 trails = neon(\n        -0.005 + trail_data.a,\n        vec4(trail_data.rgb, 1.0), 0.05\n    ) * 0.1;\n    \n    vec4 start_box = draw_start_box(world_coords);\n    \n    \n    //vec4 map_data = sample_map(CHANNEL_MAP, CHANNEL_MAP_RESOLUTION, world_coords);\n    //fragColor += vec4(map_data.rgb, 0.0);\n    \n    //vec4 trail_data = sample_trails(CHANNEL_TRAILS, CHANNEL_TRAILS_RESOLUTION, world_coords);\n    \n    fragColor += map;\n    fragColor += trails;\n    fragColor += start_box;\n    \n    fragColor += ship_1_sprite;\n    fragColor += ship_2_sprite;\n    fragColor += ship_3_sprite;\n    fragColor += ship_4_sprite;\n    \n    \n    \n    if (iTime < STARTING_DELAY) {\n    \tfloat dot1 = length(centered + vec2(0.5, -0.5)) - 0.1;\n        float dot2 = length(centered + vec2(0.0, -0.5)) - 0.1;\n    \tfloat dot3 = length(centered + vec2(-0.5, -0.5)) - 0.1;\n        \n        vec4 red = vec4(1.0, 0.0, 0.0, 1.0);\n        vec4 green = vec4(0.0, 1.0, 0.0, 1.0);\n        vec4 col1 = green;\n        vec4 col2 = mix(red, green, float(iTime > (STARTING_DELAY / 3.0)));\n        vec4 col3 = mix(red, green, float(iTime > (STARTING_DELAY / 3.0 * 2.0)));\n    \t\n    \tfragColor += neon(dot1, col1, 0.1);\n    \tfragColor += neon(dot2, col2, 0.1);\n    \tfragColor += neon(dot3, col3, 0.1);\n    }\n    \n\n#ifdef SHOW_SPRITE_BUFFER\n    fragColor = texture(CHANNEL_SPRITES, uv);\n#endif\n#ifdef SHOW_STATE_BUFFER\n    fragColor = texture(CHANNEL_STATE, uv);\n#endif\n#ifdef SHOW_TRAILS_BUFFER\n    fragColor = texture(CHANNEL_TRAILS, uv);\n#endif\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/////////////// GAMEPLAY SETTINGS //////////////////\n\nconst float STARTING_DELAY = 3.0; // Time at start before race begins\nconst float ZOOM = 0.7; // Zooms the viewport\n\nconst vec3 SHIP_THRUST = vec3(10.0, 10.0, 40.0); // Note: global ref frame for x/y\nconst vec3 SHIP_DAMPING = vec3(2.0, 2.0, 8.0);   // Note: global ref frame for x/y\n\nconst float GROUND_FRICTION = 5.0;  // Deceleration from colliding with world\n\nconst float MAP_SCALE = 10.0; // Size of the map in world coordinates\nconst float SHIP_SCALE = 0.1; // Radius/size of the ship in world coordinates\n\n\nconst vec3 MAP_START_LINE = vec3(vec2(0.5, 0.707) * MAP_SCALE, -1.45); // Where to place the ships\n\n\nconst int KEY_LEFT = 37;\nconst int KEY_UP   = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\n\n\n/////////////// PERFORMANCE SETTINGS //////////////////\nconst float SPRITE_SIZE = 64.0;            // Size of a sprite in the sprite sheet\nconst vec2 MAP_SIZE = vec2(256, 128);       // Size of the sprite sheet to use for the map\nconst vec2 TRAIL_MAP_SIZE = vec2(512, 256); // Size of the trail buffer\n\n\n/////////////// ADRESSES_IN_BUFFERS //////////////////\nconst ivec2 SPRITE_SHIP = ivec2(0,0);\nconst ivec2 SPRITE_FLAME = ivec2(1,0);\nconst ivec2 SPRITE_START_BOX = ivec2(2,0);\n\nconst ivec2 A_SHIP_1 = ivec2(0,0);\nconst ivec2 A_SHIP_2 = ivec2(0,1);\nconst ivec2 A_SHIP_3 = ivec2(1,0);\nconst ivec2 A_SHIP_4 = ivec2(1,1);\n\n\n\n////////////// Visual Settings /////////////////\n\n// Colors for the different ships\nconst vec4 COLOR_SHIP_1 = vec4(0.0, 0.6, 1.0, 1.0);\nconst vec4 COLOR_SHIP_2 = vec4(1.0, 0.6, 0.0, 1.0);\nconst vec4 COLOR_SHIP_3 = vec4(0.0, 1.0, 0.6, 1.0);\nconst vec4 COLOR_SHIP_4 = vec4(1.0, 0.0, 0.6, 1.0);\n\n// Seconds for the image to fade to white. Due to other visual effects\n// it visually fades a long time before this\nconst float TRAIL_FADE_TIME = 120.0; \n\nvec4 read_data(sampler2D buffer, ivec2 address){\n    return texelFetch(buffer, address, 0);\n}\n\n\n\n////////////////// FUNCTIONS FOR SHIP STATE /////////////////\n/* Each ship has a bunch of attributes. These all need to be\npreserved each frame. The struct ship_t contains the attributes\nand the pack_ship and unpack_ship functions are used to\nstuff the ship into a vec4 color for storage */\n\n\nstruct ship_t {\n    vec3 position;\n    vec3 velocity;\n    bool flame;\n};\n\n    \nvec4 pack_ship(ship_t ship) {\n\tuint pos = packHalf2x16(ship.position.xy);\n    uint velocity = packHalf2x16(ship.velocity.xy);\n    uint angular = packHalf2x16(vec2(ship.position.z, ship.velocity.z));\n    \n    uint flags = uint(ship.flame);\n    // Can possibly add other things such as engine being on into the flags\n    \n    return vec4(\n        uintBitsToFloat(pos),\n        uintBitsToFloat(velocity),\n        uintBitsToFloat(angular),\n        uintBitsToFloat(flags)\n       );\n}\n\nship_t unpack_ship(vec4 data) {\n    uint pos = floatBitsToUint(data.x);\n    uint velocity = floatBitsToUint(data.y);\n    uint angular = floatBitsToUint(data.z);\n    uint flags = floatBitsToUint(data.w);\n    \n    bool flame = bool(flags);\n    \n    vec2 ang = unpackHalf2x16(angular);\n    \n    return ship_t(\n    \tvec3(unpackHalf2x16(pos), ang.x),\n        vec3(unpackHalf2x16(velocity), ang.y),\n        flame\n    );\n}\n\n\n////////////// SAMPLING FUNCTIONS ////////////////\n/* Data stored in the buffers often has transforms\napplied to it, both in where it's stored and the\ndata itself. These functions provide ergonomic access to\ndata in other buffers. */\n\nvec4 sample_map(sampler2D map_channel, vec2 map_channel_resolution, vec2 world_coords) {\n    vec2 uv = world_coords;\n    uv.x *= MAP_SIZE.y / MAP_SIZE.x;\n    \n    uv /= MAP_SCALE;\n    uv = uv * 0.5 + 0.5;\n    \n    if (any(lessThan(uv, vec2(0.0))) || any( greaterThan(uv, vec2(1.0)))) {\n        return vec4(1.0);\n    }\n    \n    uv = uv * MAP_SIZE / map_channel_resolution;\n    \n    vec4 raw = texture(map_channel, uv);\n    raw.xyzw -= 0.5;\n    \n    raw.w *= 3.14 * 4.0;\n    \n    return raw;\n}\n\nvec4 sample_trails(sampler2D trail_channel, vec2 trail_channel_resolution, vec2 world_coords) {\n    vec2 uv = world_coords;\n    uv.x *= TRAIL_MAP_SIZE.y / TRAIL_MAP_SIZE.x;\n    uv /= MAP_SCALE;\n    uv = uv * 0.5 + 0.5;\n    \n    if (any(lessThan(uv, vec2(0.0))) || any( greaterThan(uv, vec2(1.0)))) {\n        return vec4(1.0);\n    }\n    uv = uv * TRAIL_MAP_SIZE / trail_channel_resolution;\n    \n    vec4 raw = texture(trail_channel, uv);\n\n    return raw;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Contains gameplay state\n#define CHANNEL_STATE iChannel0\n#define CHANNEL_SPRITES iChannel1\n#define CHANNEL_KEYS iChannel2\n\nconst float PI = 3.14159;\n\n#define CHANNEL_SPRITES_RESOLUTION iChannelResolution[1].xy\n\n\nfloat get_key(int key_code) {\n    return texelFetch(CHANNEL_KEYS, ivec2(key_code,0), 0).x;\n}\n\nfloat wrap_angle(float angle) {\n    // Ensure a number is between pi and -pi\n    // Not sure if this is the optimal way, but it\n    // avoids issues with fract/mod indeterminism on\n    // negative numbers\n    angle = angle + PI; // Work between 0 and 2PI;\n \tfloat sig = sign(angle);\n    float mag = mod(abs(angle), 2.0 * PI);\n    \n    return sig * (mag - PI);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 address = ivec2(fragCoord);\n    \n    if (address == A_SHIP_1 || address == A_SHIP_2 || address == A_SHIP_3 || address == A_SHIP_4) {\n        // Data about the ship: Texture sample 1\n        ship_t ship = unpack_ship(read_data(iChannel0, address));\n        \n        // Data about what is underneath the ship: Texture sample 2\n        vec4 map_data = sample_map(CHANNEL_SPRITES, CHANNEL_SPRITES_RESOLUTION, ship.position.xy);\n        \n        \n        if (iTime < STARTING_DELAY) {\n            ship.velocity = vec3(0.0);\n            \n            vec3 start_offset = vec3(0.15, 0.15, 0.0) - vec3(address, 0.0) * 0.3;\n            float c = cos(MAP_START_LINE.z);\n            float s = sin(MAP_START_LINE.z);\n            mat3 ori = mat3(\n                c, s, 0.0,\n                -s, c, 0.0,\n                0.0, 0.0, 1.0\n            );\n            \n            ship.position = MAP_START_LINE + ori * start_offset;\n            ship.flame = false;\n            \n            fragColor = pack_ship(ship);\n            return;\n        }\n        \n        \n        \n        float c = cos(ship.position.z);\n        float s = sin(ship.position.z);\n        mat2 ori = mat2(\n            c, s,\n            -s, c\n        );\n        vec2 forwards = ori * vec2(0.0, 1.0);\n        \n        float thrust = 0.0;\n        float steer = 0.0;\n        \n        \n        // Compute control for this ship. For the player (ship 1) it is keyboard\n        // anything else is AI\n        if (address == A_SHIP_1) {\n            float thrust_keys = get_key(KEY_UP) - get_key(KEY_DOWN);\n            ship.flame = thrust_keys > 0.0; // Indicate that thrust is being applied to the ship\n\t\t\tthrust = thrust_keys;\n            steer = (get_key(KEY_LEFT) - get_key(KEY_RIGHT));\n\n        } else {\n            // AI using map SDF/metadata\n            \n            // This is used to make the different ships behave differently.\n            float diff = float(address.x) + float(address.y) * 2.0;\n            \n            thrust = 1.0;\n            \n            vec2 corrective_direction = map_data.xy * vec2(1.0, -1.0); // Points towards track center\n            float course_angle = atan(-ship.position.y, -ship.position.x); // Go around track clockwise\n            vec2 course_direction = vec2(sin(course_angle), cos(course_angle));\n            \n            float off_course_amount = 0.5;\n            \n            vec2 target_direction = mix(course_direction, corrective_direction, off_course_amount);\n            float target_angle = atan(target_direction.x, target_direction.y);\n            \n            steer = target_angle - ship.position.z;\n\n            steer = wrap_angle(steer);\n            steer *= (0.12 - map_data.z) * pow(3.0, diff);\n\n            //steering -= ship.velocity.z * diff * 0.2; // Some damping - doesn't help.\n            \n            //ship.velocity.z += steering;\n            \n            ship.flame = thrust > 0.0;\n        }\n        \n        vec3 acceleration = vec3(0.0);\n        \n        acceleration.xy += forwards * clamp(thrust, -1.0, 1.0);\n        acceleration.z += steer;\n        acceleration *= SHIP_THRUST;\n        \n        // Damping/friction\n        acceleration -= ship.velocity * SHIP_DAMPING;\n        \n        // Collision with map\n        float ship_size = SHIP_SCALE / MAP_SCALE;\n        if (map_data.b > -ship_size) {\n            // Compute vector to back on the course\n            vec2 overlap = (map_data.xy) * (map_data.z + ship_size) * MAP_SCALE;\n            ship.position.xy -= overlap * 0.5;\n            acceleration.xy -= ship.velocity.xy * GROUND_FRICTION;\n        }\n        \n        \n        // Integration\n        ship.velocity += acceleration * iTimeDelta;\n        ship.position += ship.velocity * iTimeDelta;\n        ship.position.z = wrap_angle(ship.position.z);\n        \n        fragColor = pack_ship(ship);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Sprites and the map. The map is in coords (0,0) to MAP_SIZE\n// and the sprites sit on top of it from (0, MAP_SIZE)\n\n\nvec2 line_segment(vec2 point, vec2 segment_start, vec2 segment_end) {\n    // Returns a vector pointing to the line segment.\n    vec2 line_direction = segment_start - segment_end;\n    vec2 point_on_line = segment_end;\n    float segment_length = length(line_direction);\n\n\n    float projected_distance = dot(normalize(line_direction), point - point_on_line);\n    vec2 closest_point = point_on_line + projected_distance * line_direction / segment_length;\n\n    float distance_from_end = -projected_distance;\n    float distance_from_start = projected_distance - segment_length;\n\n    // Rounded caps on segment\n    if (distance_from_start > 0.0) {\n        closest_point = segment_start;\n    }\n    if (distance_from_end > 0.0) {\n        closest_point = segment_end;\n    }\n\n    return point - closest_point;\n}\n\n\nvec4 n_union(vec4 existing, vec2 new) {\n    // Converts a normal towards a surface into:\n    // X - normal X\n    // Y - normal Y\n    // Z - sdf squared\n    // W - vacant\n    float sdf_squared_new = dot(new, new);\n    if (sdf_squared_new < existing.z){\n        return vec4(new, sdf_squared_new, 0.0);\n    }\n    return existing;\n}\n\n\nvec4 draw_sprite_start_box(vec2 uv) {\n    // Start line and places for ships. Normaldata invalid\n    uv.x -= 0.5;\n\n    \n    vec4 outp = vec4(0.0, 0.0, 9999.0, 0.0);\n    \n    // Start/finish line\n    outp = n_union(outp, line_segment(uv, vec2(-0.4, 0.9), vec2(0.4, 0.9)));\n    outp = n_union(outp, line_segment(uv, vec2(-0.4, 0.95), vec2(0.4, 0.95)));\n    \n    // Duplicate start boxes early\n    uv.x = abs(uv.x);\n    uv.y = mod(uv.y, 0.3);\n    \n    outp = n_union(outp, line_segment(uv, vec2(0.1, 0.18), vec2(0.2, 0.18)));\n    outp = n_union(outp, line_segment(uv, vec2(0.2, 0.15), vec2(0.2, 0.18)));\n    outp = n_union(outp, line_segment(uv, vec2(0.1, 0.15), vec2(0.1, 0.18)));\n    \n    outp.b = sqrt(outp.b);\n\n    return outp;\n}\n\n\nvec4 draw_sprite_ship(vec2 uv){\n    // Ship\n    const float SCALE = 1.5;\n    uv = (uv - 0.5);\n    \n    uv.y += 0.175;\n    uv *= SCALE;\n    \n    vec2 unmirror = uv;\n    uv.x = abs(uv.x); // Mirror\n    \n    vec4 outp = vec4(0.0, 0.0, 9999.0, 0.0);\n    \n    // Wings\n    outp = n_union(outp, line_segment(uv, vec2(0.0, 0.75), vec2(0.5, 0.0)));\n    outp = n_union(outp, line_segment(uv, vec2(0.15, -0.35), vec2(0.5, 0.0)));\n    outp = n_union(outp, line_segment(uv, vec2(0.15, -0.35), vec2(0.15, 0.25)));\n    outp = n_union(outp, line_segment(uv, vec2(0.0, 0.5), vec2(0.15, 0.25)));\n    \n    // Engine\n    outp = n_union(outp, line_segment(uv, vec2(0.15, -0.2), vec2(0.0, -0.25)));\n    outp = n_union(outp, line_segment(uv, vec2(0.11, -0.22), vec2(0.06, -0.35)));\n    outp = n_union(outp, line_segment(uv, vec2(0.0, -0.35), vec2(0.06, -0.35)));\n    \n    // Cockpit\n    outp = n_union(outp, line_segment(uv, vec2(0.1, 0.2), vec2(0.0, 0.35)));\n    outp = n_union(outp, line_segment(uv, vec2(0.1, 0.2), vec2(0.1, 0.1)));\n    outp = n_union(outp, line_segment(uv, vec2(0.0, 0.15), vec2(0.1, 0.1)));\n    \n    outp.b = sqrt(outp.b) / SCALE;\n    if (unmirror.x < 0.0) {\n        outp.x *= -1.0;\n    }\n    return outp;\n}\n\nvec4 draw_sprite_flame(vec2 uv){\n    // Engine flame. Note, normaldata invalid and SDF does not have unit gradient.\n    uv = (uv - 0.5);\n\n    uv.y -= 0.25;\n    \n    if (uv.y < 0.0) {\n        // Stretch and taper the coordinate system\n    \tuv.y /= (1.0 - uv.y) * 4.0;\n        uv.x /= (1.0 + 10.0 * uv.y);\n    }\n    \n    vec4 outp = vec4(0.0, 0.0, 9999.0, 0.0);\n    outp = n_union(outp, line_segment(uv, vec2(-0.025, 0.0), vec2(0.025, 0.0)));\n    \n    outp.b = sqrt(outp.b);\n\n    return outp;\n}\n\n\n\nvoid draw_map(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 map_uv = mod(fragCoord, MAP_SIZE) / MAP_SIZE;\n    \n    vec2 coords = (map_uv - 0.5) * 2.0;\n    coords.x *= MAP_SIZE.x / MAP_SIZE.y;\n    \n    \n    vec2 line = line_segment(coords, vec2(-0.5, 0.0), vec2(0.5, 0.0));\n    \n    \n    \n    float angle = atan(coords.x, coords.y);\n    \n    float track_radius = 0.7;\n    \n    // Distort\n    track_radius += cos(angle * 3.0 - 1.0) * 0.10;\n    track_radius += cos(angle * 5.0 + 1.0) * 0.10;\n    \n    float track_width = 0.05;\n    \n    float center_sdf = abs(track_radius - length(line));\n    float border_sdf = center_sdf - track_width;\n    float boundary_sdf = abs(track_width - center_sdf);\n    \n    vec2 border_norm = normalize(vec2(\n        dFdx(border_sdf),\n        dFdy(border_sdf)\n    ));\n    \n    fragColor = vec4(border_norm + 0.5, border_sdf + 0.5, 0.0);\n}\n\n\nvoid draw_sprites(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 tile_uv = mod(fragCoord, SPRITE_SIZE) / SPRITE_SIZE;\n    ivec2 tile_id = ivec2(fragCoord / SPRITE_SIZE);\n    \n    vec4 outp = vec4(0.0);\n    \n    if (tile_id == SPRITE_SHIP) {\n        outp = draw_sprite_ship(tile_uv);\n    } else if (tile_id == SPRITE_FLAME) {\n        outp = draw_sprite_flame(tile_uv);\n    } else if (tile_id == SPRITE_START_BOX) {\n        outp = draw_sprite_start_box(tile_uv);\n    }\n    \n    fragColor = outp;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 map_id = ivec2(fragCoord / MAP_SIZE);\n    if (map_id == ivec2(0,0)) {\n        draw_map(fragColor, fragCoord);\n        return;\n    } else {\n        vec2 start_position = fragCoord;\n        start_position.y -= MAP_SIZE.y;\n        draw_sprites(fragColor, start_position);\n    \treturn;\n\t}\n    \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Trails\n\n#define CHANNEL_STATE iChannel0\n#define CHANNEL_TRAILS iChannel1\n\n\nvec4 min_preserve(vec4 existing, vec4 new) {\n    // combines sdf preserving other channels:\n    // X - data\n    // Y - data\n    // Z - data\n    // W - sdf\n    if (existing.w < new.w) {\n        return existing;\n    } else {\n        return new;\n    }\n}\n\n\nfloat draw_trail(vec2 world_coords, ship_t ship) {\n    if (!ship.flame) {\n        return 1.0;\n    }\n    vec2 ship_world_coords = ship.position.xy;\n    \n    float point_direction = ship.position.z;\n    float c = cos(point_direction);\n    float s = sin(point_direction);\n    \n    vec2 flame_position = ship_world_coords + vec2(s*0.1, -c*0.1);\n    \n    float dist = length(world_coords - flame_position);\n    return dist * 0.1;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    if (iTime < STARTING_DELAY || fragCoord.x > TRAIL_MAP_SIZE.x || fragCoord.y > TRAIL_MAP_SIZE.y) {\n        fragColor = vec4(1.0);\n        return;\n    }\n    vec2 raw_uv = fragCoord / iResolution.xy;\n    vec2 uv = mod(fragCoord, TRAIL_MAP_SIZE) / TRAIL_MAP_SIZE;\n    vec2 centered = (uv - 0.5) * 2.0;\n    centered.x *= TRAIL_MAP_SIZE.x / TRAIL_MAP_SIZE.y;\n    vec2 world_coords = centered * MAP_SCALE;\n    \n    \n    vec4 sdf = texture(CHANNEL_TRAILS, raw_uv);\n    \n    sdf = clamp(sdf + iTimeDelta / TRAIL_FADE_TIME, 0.0, 1.0); // Fade to white\n\n    ship_t ship_1 = unpack_ship(read_data(CHANNEL_STATE, A_SHIP_1));\n    ship_t ship_2 = unpack_ship(read_data(CHANNEL_STATE, A_SHIP_2));\n    ship_t ship_3 = unpack_ship(read_data(CHANNEL_STATE, A_SHIP_3));\n    ship_t ship_4 = unpack_ship(read_data(CHANNEL_STATE, A_SHIP_4));\n    \n    sdf = min_preserve(sdf, vec4(COLOR_SHIP_1.rgb, draw_trail(world_coords, ship_1)));\n    sdf = min_preserve(sdf, vec4(COLOR_SHIP_2.rgb, draw_trail(world_coords, ship_2)));\n    sdf = min_preserve(sdf, vec4(COLOR_SHIP_3.rgb, draw_trail(world_coords, ship_3)));\n    sdf = min_preserve(sdf, vec4(COLOR_SHIP_4.rgb, draw_trail(world_coords, ship_4)));\n    \n    fragColor = sdf;\n    //fragColor = sample_map(iChannel2, iChannelResolution[2].xy, world_coords);\n    //fragColor = vec4(uv, 0.0, 1.0);\n}","name":"Buffer C","description":"","type":"buffer"}]}