{"ver":"0.1","info":{"id":"4tlyRN","date":"1503769254","viewed":191,"name":"Filter Kernel Comp. Template","username":"TinyTexel","description":"template for comparing filter kernels\nccw starting from bottom left: box, tri, gauss (matched to tri), cubic","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["antialiasing","filtering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Filter Kernel Comp. Template\n// Created by TinyTexel\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n\n/*\ntemplate for comparing filter kernels\nccw starting from bottom left: box, tri, cubic, gauss\n*/\n\n#define Time iTime\n#define Frame iGlobalFrame\n#define PixelCount iResolution.xy\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\n\nfloat sRGB_NonlinearEncode(float c)\n{\n    return c > 0.0031308 ? pow(c, 1.0/2.4) * 1.055 - 0.055 : c * 12.92;\n}\n\nfloat sRGB_NonlinearDecode(float c)\n{\n    return c > 0.04045 ? pow(c / 1.055 + 0.055/1.055, 2.4) : c / 12.92;\n}\n\nvec3 sRGB_NonlinearEncode(vec3 rgb)\n{\n    return If(greaterThan(rgb, vec3(0.0031308)), pow(rgb, vec3(1.0/2.4)) * 1.055 - 0.055, rgb * 12.92);\n}\n\nvec3 sRGB_NonlinearDecode(vec3 rgb)\n{\n    return If(greaterThan(rgb, vec3(0.04045)), pow(rgb / 1.055 + 0.055/1.055, vec3(2.4)), rgb / 12.92);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy - 0.5;\n\tvec2 tex = fragCoord.xy / PixelCount;\n    \n    vec3 col = textureLod(iChannel0, tex, 0.0).rgb;\n    \n    #if 1\n    vec3 v0 = textureLodOffset(iChannel0, tex, 0.0, ivec2( 0, 0)).rgb;\n    \n    vec3 v1 = textureLodOffset(iChannel0, tex, 0.0, ivec2( 0, 1)).rgb;\n    vec3 v2 = textureLodOffset(iChannel0, tex, 0.0, ivec2( 1, 0)).rgb;\n    vec3 v3 = textureLodOffset(iChannel0, tex, 0.0, ivec2( 1, 1)).rgb;\n    \n    vec3 v4 = textureLodOffset(iChannel0, tex, 0.0, ivec2( 0,-1)).rgb;\n    vec3 v5 = textureLodOffset(iChannel0, tex, 0.0, ivec2(-1, 0)).rgb;\n    vec3 v6 = textureLodOffset(iChannel0, tex, 0.0, ivec2(-1,-1)).rgb;\n\n    vec3 v7 = textureLodOffset(iChannel0, tex, 0.0, ivec2(-1, 1)).rgb;\n    vec3 v8 = textureLodOffset(iChannel0, tex, 0.0, ivec2( 1,-1)).rgb;\n    \n    vec3 laplace;\n    laplace  = -12.0 *  v0;\n    laplace +=   2.0 * (v1 + v2 + v4 + v5);\n    laplace +=          v3 + v6 + v7 + v8;\n    laplace /=  12.0;\n    #endif\n    \n    \n    #if 0\n    // show high frequencies only (i.e. high-pass filter image)\n    \t#if 1\n        col = abs(laplace);\n    \t#else\n    \tcol = vec3(laplace.x, abs(laplace.x)*0., -laplace.x);\n    \t#endif\n    #else \n    // boost frequencies close to Nyquist-freq to compensate for attenuation from low-pass filtering\n    // i.e. sharpen image to counter blurring\n        float s = 0.0;\n        #if 0\n    \t{\n            float box = 0.0;\n            float tri = 0.5;\n            float cub = 1.0;\n            float gau = 1.5;\n\n            s  = tex.x < 0.5 ? (tex.y < 0.5 ? box : tri) : (tex.y < 0.5 ? gau : cub);\n        }\n    \t#endif\n\n        col = v0 - laplace * s;\n\n        #if 0\n        // reduce contrast; helps visualizing ringing artifacts\n        col = mix(col, vec3(0.5), 0.2);    \n        #endif\n    #endif\n    \n    \n    col = clamp(col, 0.0, 1.0);\n    fragColor = vec4(sRGB_NonlinearEncode(col), 0.0);\n    //fragColor = vec4(col, 0.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Filter Kernel Comp. Template\n// Created by TinyTexel\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n\n/*\ntemplate for comparing filter kernels\nccw starting from bottom left: box, tri, quadratic, gauss\n*/\n\n///////////////////////////////////////////////////////////////////////////\n//=======================================================================//\n\n#define Frame float(iFrame)\n#define Time iTime\n#define PixelCount iResolution.xy\n#define OUT\n\n/*\n#define float2 vec2\n#define float3 vec3\n#define float4 vec4\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define frac fract\n/**/\n\n#define lerp mix\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\nconst float Pi = 3.14159265359;\nconst float RcpPi = 1.0 / Pi;\nconst float Pi05 = Pi * 0.5;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\n\nvec3 AngToVec(vec2 ang)\n{\n    float sinPhi   = sin(ang.x);\n    float cosPhi   = cos(ang.x);\n    float sinTheta = sin(ang.y);\n    float cosTheta = cos(ang.y);    \n\n    return vec3(cosPhi * cosTheta, \n                         sinTheta, \n                sinPhi * cosTheta); \n}\n\n\nfloat SqrLen(float v) {return v * v;}\nfloat SqrLen(vec2  v) {return dot(v, v);}\nfloat SqrLen(vec3  v) {return dot(v, v);}\nfloat SqrLen(vec4  v) {return dot(v, v);}\n\nfloat GammaDecode(float x) {return pow(x,      2.2) ;}\nvec2  GammaDecode(vec2  x) {return pow(x, vec2(2.2));}\nvec3  GammaDecode(vec3  x) {return pow(x, vec3(2.2));}\nvec4  GammaDecode(vec4  x) {return pow(x, vec4(2.2));}\n\nfloat GammaEncode(float x) {return pow(x,      1.0 / 2.2) ;}\nvec2  GammaEncode(vec2  x) {return pow(x, vec2(1.0 / 2.2));}\nvec3  GammaEncode(vec3  x) {return pow(x, vec3(1.0 / 2.2));}\nvec4  GammaEncode(vec4  x) {return pow(x, vec4(1.0 / 2.2));}\n\n\n\n// single iteration of Bob Jenkins' One-At-A-Time hashing algorithm:\n//  http://www.burtleburtle.net/bob/hash/doobs.html\n// suggested by Spatial on stackoverflow:\n//  http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\nuint BJXorShift(uint x) \n{\n    x += x << 10u;\n    x ^= x >>  6u;\n    x += x <<  3u;\n    x ^= x >> 11u;\n    x += x << 15u;\n\t\n    return x;\n}\n\n\n// xor-shift algorithm by George Marsaglia\n//  https://www.thecodingforums.com/threads/re-rngs-a-super-kiss.704080/\n// suggested by Nathan Reed:\n//  http://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/\nuint GMXorShift(uint x)\n{\n    x ^= x << 13u;\n    x ^= x >> 17u;\n    x ^= x <<  5u;\n    \n    return x;\n}\n\n// hashing algorithm by Thomas Wang \n//  http://www.burtleburtle.net/bob/hash/integer.html\n// suggested by Nathan Reed:\n//  http://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/\nuint WangHash(uint x)\n{\n    x  = (x ^ 61u) ^ (x >> 16u);\n    x *= 9u;\n    x ^= x >> 4u;\n    x *= 0x27d4eb2du;\n    x ^= x >> 15u;\n    \n    return x;\n}\n\n//#define Hash BJXorShift\n#define Hash WangHash\n//#define Hash GMXorShift\n\n// \"floatConstruct\"          | renamed to \"ConstructFloat\" here \n// By so-user Spatial        | http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n// used under CC BY-SA 3.0   | https://creativecommons.org/licenses/by-sa/3.0/             \n// reformatted and changed from original to extend interval from [0..1) to [-1..1) \n//-----------------------------------------------------------------------------------------\n// Constructs a float within interval [-1..1) using the low 23 bits + msb of an uint.\n// All zeroes yields -1.0, all ones yields the next smallest representable value below 1.0. \nfloat ConstructFloat(uint m) \n{\n\tfloat flt = uintBitsToFloat(m & 0x007FFFFFu | 0x3F800000u);// [1..2)\n    float sub = (m >> 31u) == 0u ? 2.0 : 1.0;\n    \n    return flt - sub;// [-1..1)             \n}\n\nvec2 ConstructFloat(uvec2 m) { return vec2(ConstructFloat(m.x), ConstructFloat(m.y)); }\nvec3 ConstructFloat(uvec3 m) { return vec3(ConstructFloat(m.xy), ConstructFloat(m.z)); }\nvec4 ConstructFloat(uvec4 m) { return vec4(ConstructFloat(m.xyz), ConstructFloat(m.w)); }\n\n\nuint Hash(uint  v, uint  r) { return Hash(v ^ r); }\nuint Hash(uvec2 v, uvec2 r) { return Hash(Hash(v.x , r.x ) ^ (v.y ^ r.y)); }\nuint Hash(uvec3 v, uvec3 r) { return Hash(Hash(v.xy, r.xy) ^ (v.z ^ r.z)); }\nuint Hash(uvec4 v, uvec4 r) { return Hash(Hash(v.xy, r.xy) ^ Hash(v.zw, r.zw)); }\n\n// Pseudo-random float value in interval [-1:1).\nfloat Hash(float v, uint  r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\nfloat Hash(vec2  v, uvec2 r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\nfloat Hash(vec3  v, uvec3 r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\nfloat Hash(vec4  v, uvec4 r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\n\n\nfloat HashFlt(uint   v, uint  r) { return ConstructFloat(Hash(v, r)); }\nfloat HashFlt(uvec2  v, uvec2 r) { return ConstructFloat(Hash(v, r)); }\nfloat HashFlt(uvec3  v, uvec3 r) { return ConstructFloat(Hash(v, r)); }\nfloat HashFlt(uvec4  v, uvec4 r) { return ConstructFloat(Hash(v, r)); }\n\nuint HashUInt(float v, uint  r) { return Hash(floatBitsToUint(v), r); }\nuint HashUInt(vec2  v, uvec2 r) { return Hash(floatBitsToUint(v), r); }\nuint HashUInt(vec3  v, uvec3 r) { return Hash(floatBitsToUint(v), r); }\nuint HashUInt(vec4  v, uvec4 r) { return Hash(floatBitsToUint(v), r); }\n\n\n// s [-1..1]\nfloat Sample_Triangle(float s) \n{ \n    //float v = 1.0 - sqrt(abs(s));\n    float v = 1.0 - sqrt(1.0 - abs(s));\n    \n    return s < 0.0 ? -v : v; \n}\n\n// s [-1..1]\nfloat Sample_CosKernel(float s) \n{ \n    return asin(s) * RcpPi * 2.0; \n}\n\n\nfloat Tanh(float x)\n{\n    return 1.0 - 2.0 / (1.0 + exp(2.0 * x));\n}\n\n// s [-1..1]\nfloat Sample_ExpKernel(float s) \n{ \n    float n = 3.6;\n    //-(Log[-1 + 2/(1 + x Tanh[(3 n)/4])]/n)\n    return -(log(-1.0 + 2.0/(1.0 + s * Tanh((3.0 * n)/4.0))) / n) * 1.5;\n}\n\n// Box-Muller Transform: \n// https://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform\n// u (0..1] | v [-1..1]\nvec2 Sample_Gauss2D(float u, float v)\n{\n    float l = sqrt(-2.0 * log(u));\n    \n    return vec2(cos(v * Pi), sin(v * Pi)) * l;\n}\n\n// https://www.shadertoy.com/view/ltByWW\nfloat ssteppow(float x, float p)\n{\n\tx = clamp(x, 0.0, 1.0);\n\tfloat ix = 1.0 - x;\n    x = pow(x, p);\n    ix = pow(ix, p);\n    return x / (x + ix);\n}\n\nfloat nuttalFiApprox(float x)\n{\n    return mix(ssteppow(x, 1.0/3.53), x, 0.11);\n}\n\n#define KEY_LEFT  37\n#define KEY_UP    38\n#define KEY_RIGHT 39\n#define KEY_DOWN  40\n\n#define KEY_SHIFT 0x10\n#define KEY_A 0x41\n#define KEY_D 0x44\n#define KEY_S 0x53\n#define KEY_W 0x57\n\n#define KeyBoard iChannel1\n\nfloat ReadKey(int keyCode) {return texelFetch(KeyBoard, ivec2(keyCode, 0), 0).x;}\n\n\n#define VarTex iChannel0\n#define OutCol outCol\n#define OutChannel w\n\n#define WriteVar(v, cx, cy) {if(uv.x == float(cx) && uv.y == float(cy)) OutCol.OutChannel = v;}\n#define WriteVar4(v, cx, cy) {WriteVar(v.x, cx, cy) WriteVar(v.y, cx, cy + 1) WriteVar(v.z, cx, cy + 2) WriteVar(v.w, cx, cy + 3)}\n\nfloat ReadVar(int cx, int cy) {return texelFetch(VarTex, ivec2(cx, cy), 0).OutChannel;}\nvec4 ReadVar4(int cx, int cy) {return vec4(ReadVar(cx, cy), ReadVar(cx, cy + 1), ReadVar(cx, cy + 2), ReadVar(cx, cy + 3));}\n\n//=======================================================================//\n///////////////////////////////////////////////////////////////////////////\n\n// checkerboard tunnel\nfloat Pattern(vec2 uv)\n{\n    vec3 rdir = normalize(vec3((uv - PixelCount * 0.5) / PixelCount.x, 1.0));\n    \n    //vec3 n = normalize(rdir - cam.Front * dot(rdir, cam.Front));\n    vec3 n = normalize(vec3(rdir.xy, 0.0));\n    float z = 1.0 / dot(rdir, n);\n    \n    float s = 8.0;\n    bool sz = fract(z*s*0.5) < 0.5;   \n    //bool sc = fract(atan(dot(n, cam.Right), dot(n, cam.Up)) * RcpPi * 2.0 * s) < 0.5;\n    bool sc = fract(atan(n.x, n.y) * RcpPi * 2.0 * s) < 0.5;\n    float p = sz == sc ? 1.0 : 0.0;   \n \n    return p;\n}\n\nfloat Sinc(float x)\n{\n    float v = abs(x) <= 0.0 ? 1.0 : (abs(x) > 10240.0 ? 0.0 : sin(x * Pi) / (x * Pi));\n    return v != v ? 1.0 : v;\n    //return x == 0.0 ? 1.0 : sin(x * Pi) / (x * Pi);\n}\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{     \n    vec2 uv = uv0.xy - 0.5;    \n\tvec2 tex = uv0.xy / PixelCount;\n    \n    \n    vec2 uv1 = uv0;\n    \n    #if 0\n    uv1.x += sin(iTime) * 8.0;\n    uv1.y += cos(iTime * 0.8) * 7.0;\n    #endif\n    \n\n    vec4 mouseAccu  = ReadVar4(1, 0);\n    vec4 wasdAccu   = ReadVar4(2, 0);\n    float frameAccu = ReadVar (3, 0);\n\n\tfloat W = 1.0;\n    vec2 off;\n    //{\n        vec3 pxId  = vec3(frameAccu, uv); \n         \t pxId *= vec3( 0.76032, 1.47035, 0.92526); \n         \t pxId += vec3(-0.69060, 0.02293, 0.68109);\n    \n    \tuint hh = HashUInt(pxId, uvec3(0xB8D3E97Cu, 0x736D370Fu, 0xA7D00135u));\n    \n        float h0 = HashFlt(hh, 0xAF609A13u);\n        float h1 = HashFlt(hh, 0xE0ABC868u);\n        float h2 = HashFlt(hh, 0xBDD11B06u);\n        float h3 = HashFlt(hh, 0x167B56B0u);\n        float h4 = HashFlt(hh, 0x585573EFu);\n        float h5 = HashFlt(hh, 0xDCF25247u);\n\n        if(tex.x < 0.5)\n        {\n            if(tex.y < 0.5)// box\n            {\n                off = vec2(h0, h1) * 0.5;\n                //off = sqrt(clamp01(h0 * 0.5 + 0.5)* 0.5)  * vec2(cos(h1 * Pi), sin(h1 * Pi));\n            }\n            else// tri\n            {\n                off = vec2(Sample_Triangle(h0), Sample_Triangle(h1));\n            }\n        }\n        else\n        {\n            if(tex.y > 0.5)// gauss\n            {\n                //off  = vec2(Sample_Triangle(h0), Sample_Triangle(h1));\n                //off += vec2(Sample_Triangle(h2), Sample_Triangle(h3));\n                //off += vec2(Sample_Triangle(h4), Sample_Triangle(h5));\n\n                float o = rsqrt(2.0 * Pi);\n                o = 0.45;\n                //o = 0.5;\n                //o = 1.4;\n                \n                float u = mix(0.00001, 1.0, h0 * 0.5 + 0.5);\n                \n                off = Sample_Gauss2D(u, h1) * o;\n                \n                if(false)\n                {\n                    float x = tan(Pi * h0 * 0.5) / Pi;\n                    float y = tan(Pi * h1 * 0.5) / Pi;\n\n                    off = vec2(x, y);\n                    \n                    float sinc = Sinc(x) * Sinc(y);\n                    //sinc = Pow2(Sinc(x*0.5) * Sinc(y*0.5))*0.25;\n                    float rcpF = (1.0 + Pi*Pi * x*x) * (1.0 + Pi*Pi * y*y);\n                    \n                    W = sinc * rcpF;\n                }\n               // off = (vec2(nuttalFiApprox(h0 * 0.5 + 0.5), nuttalFiApprox(h1 * 0.5 + 0.5)) * 2.0 - 1.0) * 2.0;\n            }\n            else// cubic\n            {\n                //off = vec2(Sample_CosKernel(h0), Sample_CosKernel(h1));\n                off  = vec2(Sample_Triangle(h0), Sample_Triangle(h1));\n                off += vec2(Sample_Triangle(h2), Sample_Triangle(h3));\n                //off += vec2(h2, h3) * 0.5;\n            }\n        }\n\n    //}\n\n    uv1 += off;\n\n\n\tfloat p = Pattern(uv1);\n\n    vec3 col = vec3(p) * W;\n    col = isnan(col.r) || isnan(col.g) || isnan(col.b) ? vec3(p) : col;\n    \n    vec3 colLast = textureLod(iChannel0, tex, 0.0).rgb;\n    \n   \tcol = mix(colLast, col, 1.0 / (frameAccu + 1.0));    \n     \n    \n    outCol = vec4(col, 0.0);\n    \n    \n    // persistent user input:\n    {\n        vec4 iMouseLast     = ReadVar4(0, 0);\n        vec4 iMouseAccuLast = ReadVar4(1, 0);\n        vec4 wasdAccuLast   = ReadVar4(2, 0);\n        float frameAccuLast = ReadVar (3, 0);\n\n\n        bool shift = ReadKey(KEY_SHIFT) != 0.0;\n\n        float kW = ReadKey(KEY_W);\n        float kA = ReadKey(KEY_A);\n        float kS = ReadKey(KEY_S);\n        float kD = ReadKey(KEY_D);\n\n        float left  = ReadKey(KEY_LEFT);\n        float right = ReadKey(KEY_RIGHT);\n        float up    = ReadKey(KEY_UP);\n        float down  = ReadKey(KEY_DOWN);\n        \n        \n        bool anyK = false;\n        \n        anyK = anyK || iMouse.z > 0.0;\n        anyK = anyK || shift;\n        anyK = anyK || kW != 0.0;\n        anyK = anyK || kA != 0.0;\n        anyK = anyK || kS != 0.0;\n        anyK = anyK || kD != 0.0;\n        anyK = anyK || left  != 0.0;\n        anyK = anyK || right != 0.0;\n        anyK = anyK || up    != 0.0;\n        anyK = anyK || down  != 0.0;\n        \n        \n        frameAccuLast += 1.0;\n        if(anyK) frameAccuLast = 0.0;\n        \n\n        vec4 wasdAccu = wasdAccuLast;\n        wasdAccu += vec4(kW, kA, kS, kD);\n        wasdAccu += vec4(up, left, down, right);        \n\n        \n        vec2 mouseDelta = iMouse.xy - iMouseLast.xy;\n\n        bool cond0 = iMouse.z > 0.0 && iMouseLast.z > 0.0;\n        vec2 mouseDelta2 = cond0 && !shift ? mouseDelta.xy : vec2(0.0);\n        vec2 mouseDelta3 = cond0 &&  shift ? mouseDelta.xy : vec2(0.0);\n\n        vec4 iMouseAccu = iMouseAccuLast + vec4(mouseDelta2, mouseDelta3);\n\n        \n        WriteVar4(iMouse,        0, 0);\n        WriteVar4(iMouseAccu,    1, 0);\n        WriteVar4(wasdAccu,      2, 0);\n        WriteVar (frameAccuLast, 3, 0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}