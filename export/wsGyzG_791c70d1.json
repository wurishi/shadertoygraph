{"ver":"0.1","info":{"id":"wsGyzG","date":"1603109035","viewed":65,"name":"Example 48 - implicitsurface CSG","username":"jt","description":"Simple & inefficient visualization of CSG.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["example","csg","implicit","surface"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// some usefull info related to implicit surfaces:\n// http://paulbourke.net/geometry/implicitsurf/\n// http://paulbourke.net/geometry/polygonise/\n// https://developer.nvidia.com/gpugems/gpugems3/part-i-geometry/chapter-1-generating-complex-procedural-terrains-using-gpu\n// https://iquilezles.org/articles/distfunctions\n\nfloat sphere(vec3 c, float r, vec3 v)\n{\n    return length(v - c) - r;\n}\n\nfloat cyl_x(vec3 c, float r, vec3 v)\n{\n    return length(v.yz - c.yz) - r;\n}\n\nfloat cyl_y(vec3 c, float r, vec3 v)\n{\n    return length(v.xz - c.xz) - r;\n}\n\nmat3 rotate_x(float phi)\n{\n    return mat3(\n        vec3(1.0, 0.0, 0.0),\n        vec3(0.0, cos(phi), sin(phi)),\n        vec3(0.0,-sin(phi), cos(phi)));\n}\n\nmat3 rotate_y(float phi)\n{\n    return mat3(\n        vec3(cos(phi), 0.0, sin(phi)),\n        vec3(0.0, 1.0, 0.0),\n        vec3(-sin(phi), 0.0, cos(phi)));\n}\n\nmat3 rotate_z(float phi)\n{\n    return mat3(\n        vec3(cos(phi), sin(phi), 0.0),\n        vec3(-sin(phi), cos(phi), 0.0),\n        vec3(0.0, 0.0, 1.0));\n}\n\nvec3 transform(vec3 v)\n{\n    v += vec3(0.0, 0.0,-2.0); // camera-offset\n    return rotate_x(iTime) * rotate_y(iTime) * rotate_z(iTime) * v;\n}\n\nvec3 tex(vec3 v)\n{\n    v = transform(v);\n    //return fract(v);\n    return vec3(step(0.75, length(2.0 * fract(2.0 * v) - 1.0)));\n}\n\n// primitives can be combined via min, max, negation\n// (https://en.wikipedia.org/wiki/Constructive_solid_geometry)\nfloat scene(vec3 v)\n{\n    v = transform(v);\n\n    //return sphere(vec3(0.5, 0.0, 2.0), 1.0, v);\n    //return min(sphere(vec3(0.5, 0.0, 2.0), 1.0, v), sphere(vec3(-0.5, 0.0, 2.0), 1.0, v));\n    //return max(sphere(vec3(0.5, 0.0, 2.0), 1.0, v), sphere(vec3(-0.5, 0.0, 2.0), 1.0, v));\n    //return max(sphere(vec3(0.75, 0.0, 2.0), 1.0, v), -sphere(vec3(-0.25, 0.0, 2.0), 1.0, v));\n    return max(max(\n        min(cyl_x(vec3(0.0, 0.0, 0.0), 0.5, v), cyl_y(vec3(0.0, 0.0, 0.0), 0.5, v)),\n        sphere(vec3(0.0, 0.0, 0.0), 1.0, v)), -sphere(vec3(0.0, 0.0, 0.0), 0.75, v));\n}\n\n#define EPS 0.001\n\nvec3 gradient(vec3 p)\n{\n    return vec3(\n        scene(p + vec3(+1.0, 0.0, 0.0) * EPS) - scene(p + vec3(-1.0, 0.0, 0.0) * EPS),\n        scene(p + vec3(0.0, +1.0, 0.0) * EPS) - scene(p + vec3(0.0, -1.0, 0.0) * EPS),\n        scene(p + vec3(0.0, 0.0, +1.0) * EPS) - scene(p + vec3(0.0, 0.0, -1.0) * EPS));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 delta = vec3(2.0 * fragCoord/iResolution.xy - 1.0, 1.0);\n    delta.x *= iResolution.x / iResolution.y; // fix aspect\n\n    fragColor = vec4(0.0);\n    float s = 0.01;\n    int iter = 0;\n    int itermax = 280;\n    //for(vec3 p = vec3(0.0); iter < itermax; p += delta * scene(p), iter++) // buggy\n    for(vec3 p = vec3(0.0); iter < itermax; p += delta * s, iter++)\n    {\n        float dist = scene(p);\n        if(dist <= 0.0)\n        {\n            //fragColor = vec4(1.0);\n            //fragColor = vec4(fract(p.z));\n            vec3 n = normalize(gradient(p));\n            fragColor = vec4(0.5 + 0.5 * n, 1.0);\n            //fragColor = vec4(tex(p), 1.0); // apply 3d texture\n            float brightness = dot(n, normalize(vec3(1.0, 0.0, 0.0)));\n            //fragColor *= brightness;\n            //fragColor = vec4(brightness);\n            break;\n        }\n    }\n}\n","name":"Image","description":"","type":"image"}]}