{"ver":"0.1","info":{"id":"wlScWG","date":"1595342589","viewed":1139,"name":"Customizable NTSC Filter w/ AM","username":"Hatchling","description":"Change the look of the encoding and decoding by opening the \"Common\" tab and modifying the wavelength constants and window size. Also simulates an AM carrier signal with SSB demodulation.\nCompatability fix by dom1817.","likes":14,"published":1,"flags":32,"usePreview":0,"tags":["ntsc"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\tfragColor = texture(iChannel0, uv);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // initialize a random number state based on frag coord and frame\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);    \n    uint rngStateRow = uint(uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);    \n    \n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 pixelSize = 1.0 / iResolution.xy;\n    \n    float encoded = Encode(iChannel0, uv, pixelSize.x * NTSC_SCALE, (iFrame + int(fragCoord.y)) % 2 == 0);\n    \n    float snowNoise = RandomFloat01(rngState) - 0.5;\n    float sineNoise = sin(uv.x * 200.0 + uv.y * -50.0 + fract(iTime * iTime) * 3.1415927 * 2.0) * 0.065;\n    float saltPepperNoise = RandomFloat01(rngState) * 2.0 - 1.0;\n    saltPepperNoise = sign(saltPepperNoise) * pow(abs(saltPepperNoise), 200.0) * 10.0;\n    float rowNoise = RandomFloat01(rngStateRow) * 2.0 - 1.0;\n    rowNoise *= 0.1;   \n    float rowSaltPepper = RandomFloat01(rngStateRow) * 2.0 - 1.0;\n    rowSaltPepper = sign(rowSaltPepper) * pow(abs(rowSaltPepper), 200.0) * 1.0;\n    \n    encoded += (snowNoise + saltPepperNoise + sineNoise + rowNoise + rowSaltPepper) * NOISE_STRENGTH; \n    \n    fragColor.rgb = vec3(encoded);\n    fragColor.a = 1.0;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"#define PI 3.14159265359\n\n// Adjust these values to control the look of the encoding.\n\n// Increasing this value increases ringing artifacts. Careful, higher values are expensive.\nconst int WINDOW_RADIUS = 20;\n\n// Simulated AM signal transmission.\nconst float AM_CARRIERSIGNAL_WAVELENGTH = 2.0;\nconst float AM_DECODE_HIGHPASS_WAVELENGTH = 2.0;\nconst float AM_DEMODULATE_WAVELENGTH = 2.0;\n\n// Wavelength of the color signal. \nconst float COLORBURST_WAVELENGTH_ENCODER = 3.0;\nconst float COLORBURST_WAVELENGTH_DECODER = 3.0;\n\n// Lowpassing of luminance before encoding.\n// If this value is less than the colorburst wavelength,\n// luminance values will be interpreted as chrominance,\n// resulting in color fringes near edges.\nconst float YLOWPASS_WAVELENGTH = 1.0;\n\n// The higher these values are, the more smeary colors will be.\nconst float ILOWPASS_WAVELENGTH = 8.0;\nconst float QLOWPASS_WAVELENGTH = 11.0;\n\n// The higher this value, the blurrier the image.\n// If this value is less than or equal to the colorburst wavelength,\n// you'll have striping artifacts.\nconst float DECODE_LOWPASS_WAVELENGTH = 4.5;\n\n// Change the overall scale of the NTSC-style encoding and decoding artifacts.\nconst float NTSC_SCALE = 1.0;\n\nconst float PHASE_ALTERNATION = 0.0;//3.1415927;\n\n// Amount of TV static.\nconst float NOISE_STRENGTH = 0.1;\n\n// Saturation control.\nconst float SATURATION = 2.0;\n\n// Offsets shape of window. This can make artifacts smear to one side or the other.\nconst float WINDOW_BIAS = 0.0;\n\nmat3 MatrixRGBToYIQ = mat3(0.299, 0.587, 0.114,\n                           0.595,-0.274,-0.3213,\n                           0.2115,-0.5227, 0.3112);\n\nmat3 MatrixYIQToRGB = mat3(1.0,  0.956,  0.619,\n                           1.0, -0.272, -0.647,\n                           1.0, -1.106, 1.703);\n\n// RNG algorithm credit: https://www.shadertoy.com/view/wtSyWm\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat RandomFloat01(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n\n// NOTE: Window functions expect a range from -1 to 1.\nfloat Sinc(float x)\n{\n    x *= PI;\n\treturn (x == 0.0) ? 1.0 : sin(x)/x;   \n}\n\nfloat WindowCosine(float x)\n{\n    x = atanh(x);\n    x += WINDOW_BIAS;\n    x = tanh(x);\n    \n\treturn cos(PI * x) * 0.5 + 0.5;    \n}\n\nfloat Encode(sampler2D sampler, in vec2 uv, in float pixelWidth, bool alternatePhase)\n{\n    vec3 yiq = vec3(0);\n    float windowWeight = 0.0;\n\tfor(int i = -WINDOW_RADIUS; i <= WINDOW_RADIUS; i++)\n    {\n\t\t// Extend padding by one since we don't want to include a sample at the very edge, which will be 0.\n        float window = WindowCosine(float(i) / float(WINDOW_RADIUS+1)); \n        float sincY = Sinc(float(i)/YLOWPASS_WAVELENGTH)/YLOWPASS_WAVELENGTH;\n        float sincI = Sinc(float(i)/ILOWPASS_WAVELENGTH)/ILOWPASS_WAVELENGTH;\n        float sincQ = Sinc(float(i)/QLOWPASS_WAVELENGTH)/QLOWPASS_WAVELENGTH;\n        \n        vec2 uvWithOffset = vec2(uv.x + float(i) * pixelWidth, uv.y);\n\n        vec3 yiqSample = MatrixRGBToYIQ * clamp(texture(sampler, uvWithOffset).xyz, vec3(0.0), vec3(1.0));\n\n    \tyiq.x += yiqSample.x * sincY * window;\n        yiq.y += yiqSample.y * sincI * window;\n        yiq.z += yiqSample.z * sincQ * window;\n        windowWeight += window;\n    }\n    //yiq /= windowWeight;\n    \n    float phase = uv.x * PI / (COLORBURST_WAVELENGTH_ENCODER * pixelWidth);\n    \n    if(alternatePhase)\n    {\n        phase += PHASE_ALTERNATION;\n    }\n    \n    float phaseAM = uv.x * PI / (AM_CARRIERSIGNAL_WAVELENGTH * pixelWidth);\n    \n    return (yiq.x \n         + sin(phase) * yiq.y\n         + cos(phase) * yiq.z) * sin(phaseAM);\n}\n\nfloat DecodeAM(sampler2D sampler, in vec2 uv, in float pixelWidth)\n{\n    //float originalSignal = texture(sampler, uv).x;\n    \n    float phaseAM = uv.x * PI / (AM_DEMODULATE_WAVELENGTH * pixelWidth);\n    \n    float decoded = 0.0;\n    float windowWeight = 0.0;\n\tfor(int i = -WINDOW_RADIUS; i <= WINDOW_RADIUS; i++)\n    {\n\t\t// Extend padding by one since we don't want to include a sample at the very edge, which will be 0.\n        float window = WindowCosine(float(i) / float(WINDOW_RADIUS+1)); \n        \n        vec2 uvWithOffset = vec2(uv.x + float(i) * pixelWidth, uv.y);\n        float sinc = Sinc(float(i)/AM_DECODE_HIGHPASS_WAVELENGTH)/AM_DECODE_HIGHPASS_WAVELENGTH;\n        float encodedSample = texture(sampler, uvWithOffset).x;\n        \n    \tdecoded += encodedSample * sinc * window;\n        windowWeight += window;\n    }\n    \n    return (decoded) * sin(phaseAM) * 4.0;\n}\n\nvec3 DecodeNTSC(sampler2D sampler, in vec2 uv, in float pixelWidth, ivec2 rng, bool alternatePhase)\n{\n    uint seed = uint(rng.y);\n    vec2 originalUV = uv;\n    \n    vec3 rowNoiseIntensity = vec3(RandomFloat01(seed), RandomFloat01(seed), RandomFloat01(seed));\n    rowNoiseIntensity = pow(rowNoiseIntensity, vec3(500.0)) * 1.0;\n    \n    float horizOffsetNoise = RandomFloat01(seed) * 2.0 - 1.0;\n    horizOffsetNoise *= rowNoiseIntensity.x * 0.5 * NOISE_STRENGTH;\n    uv.x += horizOffsetNoise;\n    \n    float phaseNoise = RandomFloat01(seed) * 2.0 - 1.0;\n    phaseNoise *= rowNoiseIntensity.y * 0.5 * 3.1415927 * NOISE_STRENGTH;\n\n    float frequencyNoise = RandomFloat01(seed) * 2.0 - 1.0;\n    frequencyNoise *= rowNoiseIntensity.z * 0.5 * 3.1415927 * NOISE_STRENGTH;\n    \n    float alt = 0.0;  \n    if(alternatePhase)\n        alt = PHASE_ALTERNATION;\n    \n    \n    vec3 yiq = vec3(0);\n    float windowWeight = 0.0;\n\tfor(int i = -WINDOW_RADIUS; i <= WINDOW_RADIUS; i++)\n    {\n\t\t// Extend padding by one since we don't want to include a sample at the very edge, which will be 0.\n        float window = WindowCosine(float(i) / float(WINDOW_RADIUS+1)); \n        \n        vec2 uvWithOffset = vec2(uv.x + float(i) * pixelWidth, uv.y);\n        vec2 originalUVWithOffset = vec2(originalUV.x + float(i) * pixelWidth, originalUV.y);\n    \tfloat phase = originalUVWithOffset.x * PI / ((COLORBURST_WAVELENGTH_DECODER + frequencyNoise) * pixelWidth) + phaseNoise + alt;\n    \t//float phaseAM = uv.x * PI / (AM_SIGNAL_WAVELENGTH * pixelWidth);\n        \n        \n        float sincY = Sinc(float(i)/DECODE_LOWPASS_WAVELENGTH)/DECODE_LOWPASS_WAVELENGTH;\n        float sinI = sin(phase);\n        float sinQ = cos(phase);\n        //float sincI = Sinc(float(i)/ILOWPASS_WAVELENGTH)/ILOWPASS_WAVELENGTH;\n        //float sincQ = Sinc(float(i)/QLOWPASS_WAVELENGTH)/QLOWPASS_WAVELENGTH;\n        \n        float encodedSample = texture(sampler, uvWithOffset).x;\n        \n    \tyiq.x += encodedSample * sincY * window;\n        yiq.y += encodedSample * sinI * window;\n        yiq.z += encodedSample * sinQ * window;\n        //yiq.y += yiqSample.y * sincI * window;\n        //yiq.z += yiqSample.z * sincQ * window;\n        windowWeight += window;\n    }\n    \n    yiq.yz *= SATURATION / windowWeight;\n    \n    return max(vec3(0.0), MatrixYIQToRGB * yiq);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 pixelSize = 1.0 / iResolution.xy;\n    \n    float value = DecodeAM(iChannel0, uv, pixelSize.x); // texture(iChannel0, uv).r; //\n    //value = texture(iChannel0, uv).r; //\n    \n    fragColor.rgb = vec3(value);\n    fragColor.a = 1.0;\n    \n    //uint rngStateRow = uint(uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);    \n    //uint rngStateCol = uint(uint(fragCoord.x) * uint(1973) + uint(iFrame) * uint(26699)) | uint(1);    \n    \n    //fragColor.rgb = Decode(iChannel0, uv, pixelSize.x * NTSC_SCALE, ivec2(rngStateCol, rngStateRow), ((iFrame) + int(fragCoord.y)) % 2 == 0);\n    //fragColor.a = 1.0;\n}\n\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 pixelSize = 1.0 / iResolution.xy;\n   \n    \n    uint rngStateRow = uint(uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);    \n    uint rngStateCol = uint(uint(fragCoord.x) * uint(1973) + uint(iFrame) * uint(26699)) | uint(1);    \n    \n    fragColor.rgb = DecodeNTSC(iChannel0, uv, pixelSize.x * NTSC_SCALE, ivec2(rngStateCol, rngStateRow), ((iFrame) + int(fragCoord.y)) % 2 == 0);\n    fragColor.a = 1.0;\n}\n\n","name":"Buffer C","description":"","type":"buffer"}]}