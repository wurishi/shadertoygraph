{"ver":"0.1","info":{"id":"ssXSzn","date":"1618174589","viewed":183,"name":"RayCast Octree Emulate Recursion","username":"jt","description":"A basic ray-traced (or rather just ray-cast) subdivided cube by emulating recursion via array of stack-frames.\nAdjust STACKSIZE to change recursion depth.\nTo show subdivision (in a simple way) first and last sub-cube are omitted.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raycast","raytraced","recursive","recursion","octree","emulated"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/ssXSzn RayCast Octree Emulate Recursion, written 2021 by Jakob Thomsen, license CC0 (public domain)\n\n// A basic ray-traced (or rather just ray-cast) subdivided cube by emulating recursion via array of stack-frames.\n// Adjust STACKSIZE to change recursion depth.\n// To show subdivision (in a simple way) first and last sub-cube are omitted.\n// (https://www.shadertoy.com/view/ssXSzn)\n\n// tags: raycast, raytraced, recursive, recursion, octree, emulated\n\n#define MAXDIST 1000.0\n//#define MAXDIST 1.0 / 0.0\n\nvec3 cubenormal(vec3 v) // position relative to cube center\n{\n    vec3 s = sign(v);\n    vec3 a = abs(v);\n\n    //vec3 n = (a.z > a.y)\n    // ?\n    // (a.z > a.x) ? vec3(0.0, 0.0, s.z) : vec3(s.x, 0.0, 0.0)\n    // :\n    // (a.y > a.x) ? vec3(0.0, s.y, 0.0) : vec3(s.x, 0.0, 0.0);\n\n    vec3 n = mix(\n        mix(vec3(0.0, 0.0, s.z), vec3(s.x, 0.0, 0.0), step(a.z, a.x)),\n        mix(vec3(0.0, s.y, 0.0), vec3(s.x, 0.0, 0.0), step(a.y, a.x)),\n        step(a.z, a.y));\n\n    return n;\n}\n\nstruct intersection\n{\n    float distance;\n    vec3 normal;\n};\n\nintersection skysphere(vec3 raydir)\n{\n    intersection result;\n    result.distance = MAXDIST;\n    result.normal = -raydir; // sky-sphere\n\n    return result;\n}\n\nintersection nearest(intersection a, intersection b)\n{\n    if(a.distance < b.distance) return a; else return b;\n}\n\nstruct ray\n{\n    vec3 pos;\n    vec3 dir;\n};\n\nstruct aabb\n{\n    vec3 min;\n    vec3 max;\n};\n\n// based on https://gamedev.stackexchange.com/questions/18436/most-efficient-aabb-vs-ray-collision-algorithms\nfloat rayboxintersect(ray r, aabb box)\n{\n    // min/max of box relative to ray origin\n    vec3 t = (box.min - r.pos) / r.dir;\n    vec3 u = (box.max - r.pos) / r.dir;\n\n    float tmin = max(max(min(t.x, u.x), min(t.y, u.y)), min(t.z, u.z));\n    float tmax = min(min(max(t.x, u.x), max(t.y, u.y)), max(t.z, u.z));\n\n    if (tmax < 0.0) return MAXDIST; // box on ray but behind ray origin\n    if (tmin > tmax) return MAXDIST; // ray doesn't intersect box\n\n    return tmin;\n}\n/*\n// source: https://gamedev.stackexchange.com/questions/18436/most-efficient-aabb-vs-ray-collision-algorithms\nfloat rayboxintersect(ray r, aabb box)\n{\n    float t1 = (box.min.x - r.pos.x) / r.dir.x;\n    float t2 = (box.max.x - r.pos.x) / r.dir.x;\n    float t3 = (box.min.y - r.pos.y) / r.dir.y;\n    float t4 = (box.max.y - r.pos.y) / r.dir.y;\n    float t5 = (box.min.z - r.pos.z) / r.dir.z;\n    float t6 = (box.max.z - r.pos.z) / r.dir.z;\n\n    float tmin = max(max(min(t1, t2), min(t3, t4)), min(t5, t6));\n    float tmax = min(min(max(t1, t2), max(t3, t4)), max(t5, t6));\n\n    if (tmax < 0.0) // box on ray but behind ray origin\n    {\n        return MAXDIST;\n    }\n\n    if (tmin > tmax) // ray doesn't intersect box\n    {\n        return MAXDIST;\n    }\n\n    return tmin;\n}\n*/\n/*\n// source: https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-box-intersection\nfloat rayboxintersect(ray r, aabb box)\n{\n    float tmin = (box.min.x - r.pos.x) / r.dir.x;\n    float tmax = (box.max.x - r.pos.x) / r.dir.x;\n\n    if (tmin > tmax)\n    {\n        // swap(tmin, tmax);\n        float tmp = tmin;\n        tmin = tmax;\n        tmax = tmp;\n    }\n\n    float tymin = (box.min.y - r.pos.y) / r.dir.y;\n    float tymax = (box.max.y - r.pos.y) / r.dir.y;\n\n    if (tymin > tymax)\n    {\n        // swap(tymin, tymax);\n        float tmp = tymin;\n        tymin = tymax;\n        tymax = tmp;\n    }\n\n    if ((tmin > tymax) || (tymin > tmax))\n        return MAXDIST; // no intersection\n\n    if (tymin > tmin)\n        tmin = tymin;\n\n    if (tymax < tmax)\n        tmax = tymax;\n\n    float tzmin = (box.min.z - r.pos.z) / r.dir.z;\n    float tzmax = (box.max.z - r.pos.z) / r.dir.z;\n\n    if (tzmin > tzmax)\n    {\n        // swap(tzmin, tzmax);\n        float tmp = tzmin;\n        tzmin = tzmax;\n        tzmax = tmp;\n    }\n\n    if ((tmin > tzmax) || (tzmin > tmax))\n        return MAXDIST; // no intersection\n\n    if (tzmin > tmin)\n        tmin = tzmin;\n\n    if (tzmax < tmax)\n        tmax = tzmax;\n\n    return tmin;\n}\n*/\n\nintersection RAYBOXINTERSECT(ray r, aabb box)\n{\n    intersection result;\n    result.distance = rayboxintersect(r, box);\n    //result.normal = -r.dir; // sky-sphere\n    //if(result.distance < MAXDIST) result.normal = cubenormal(r.pos + r.dir * result.distance - (box.min + box.max) / 2.0);\n\n    result.normal = mix(-r.dir, cubenormal(r.pos + r.dir * result.distance - (box.min + box.max) / 2.0), step(result.distance, MAXDIST));\n\n    return result;\n}\n\naabb[8] subdivide(aabb box)\n{\n    aabb[8] subdiv;\n    vec3 boxhalf = (box.min + box.max) / 2.0;\n    subdiv[0] = aabb(vec3(box.min.x, box.min.y, box.min.z), vec3(boxhalf.x, boxhalf.y, boxhalf.z));\n    subdiv[1] = aabb(vec3(boxhalf.x, box.min.y, box.min.z), vec3(box.max.x, boxhalf.y, boxhalf.z));\n    subdiv[2] = aabb(vec3(box.min.x, boxhalf.y, box.min.z), vec3(boxhalf.x, box.max.y, boxhalf.z));\n    subdiv[3] = aabb(vec3(boxhalf.x, boxhalf.y, box.min.z), vec3(box.max.x, box.max.y, boxhalf.z));\n    subdiv[4] = aabb(vec3(box.min.x, box.min.y, boxhalf.z), vec3(boxhalf.x, boxhalf.y, box.max.z));\n    subdiv[5] = aabb(vec3(boxhalf.x, box.min.y, boxhalf.z), vec3(box.max.x, boxhalf.y, box.max.z));\n    subdiv[6] = aabb(vec3(box.min.x, boxhalf.y, boxhalf.z), vec3(boxhalf.x, box.max.y, box.max.z));\n    subdiv[7] = aabb(vec3(boxhalf.x, boxhalf.y, boxhalf.z), vec3(box.max.x, box.max.y, box.max.z));\n    return subdiv;\n}\n\nstruct stackframe\n{\n    aabb subdiv[8];\n    int branch;\n};\n\nstackframe call(ray r, aabb box)\n{\n    stackframe frame;\n    frame.subdiv = subdivide(box);\n    //frame.branch = 8;\n    frame.branch = 7; // TEST: remove first sub-cube\n    return frame;\n}\n\n#define STACKSIZE 3\nstackframe stack[STACKSIZE];\n\n#define PI 3.1415926\n#define TAU (2.0 * PI)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 NDC = 2.0 * fragCoord / iResolution.xy - 1.0;\n    NDC.x *= iResolution.x / iResolution.y; // aspect\n\n    float latitude = iTime / 10.0;\n    float longitude = iTime;\n    //mat2 R = mat2(cos(longitude), sin(longitude),-sin(longitude), cos(longitude));\n    mat3 R = mat3(cos(longitude), 0.0, sin(longitude), 0.0, 1.0, 0.0,-sin(longitude), 0.0, cos(longitude));\n    mat3 S = mat3(1.0, 0.0, 0.0, 0.0, cos(latitude), sin(latitude), 0.0,-sin(latitude), cos(latitude));\n\n    vec3 raydir = R * S * vec3(NDC, 1.0);\n    vec3 raypos = R * S * vec3(0.0, 0.0,-3.5);\n    ray r = ray(raypos, raydir);\n\n    intersection result = skysphere(r.dir);\n    int stackptr = 0;\n    stack[stackptr] = call(r, aabb(vec3(-1.0), vec3(+1.0)));\n\n    //intersection result = RAYBOXINTERSECT(r, vec3(-1.0), vec3(+1.0));\n    while(stackptr >= 0)\n    {\n        //if(stack[stackptr].branch > 0)\n        if(stack[stackptr].branch > 1) // TEST: remove last sub-cube\n        {\n            --stack[stackptr].branch;\n            if(stackptr < STACKSIZE - 1)\n            {\n                if(rayboxintersect(r, stack[stackptr].subdiv[stack[stackptr].branch]) < MAXDIST)\n                {\n                    // ray intersects bounding box - descend further\n                    int newstackptr = stackptr + 1;\n                    stack[newstackptr] = call(r, stack[stackptr].subdiv[stack[stackptr].branch]);\n                    stackptr = newstackptr;\n                }\n                else\n                {\n                    // ray misses bounding box - stop recursion\n                }\n            }\n            else\n            {\n                // max recursion depth - reached leaf - stop recursion\n                intersection local = RAYBOXINTERSECT(r, stack[stackptr].subdiv[stack[stackptr].branch]);\n                result = nearest(result, local);\n            }\n        }\n        else\n        {\n            --stackptr; // ascend from recursive call (return)\n        }\n    };\n\n    fragColor = vec4(vec3(0.5 + 0.5 * result.normal), 1.0);\n    //fragColor *= 0.5 + 0.5 * sin(5.0 * result.distance * TAU);\n    if(result.distance >= MAXDIST)\n        fragColor = vec4(0.0, 0.0, 0.5, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}