{"ver":"0.1","info":{"id":"dtsyWn","date":"1690625424","viewed":70,"name":"Halton sequence (2, 3)","username":"Envy24","description":"Remake of original shader: https://www.shadertoy.com/view/wdXSW8\nJust to make picture more smooth.\nhttps://en.wikipedia.org/wiki/Halton_sequence","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["halton","sequence"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 O, in vec2 SC )\n{\n    O = texelFetch(iChannel0, ivec2(SC), 0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define SCENE_SCALE               ( 0.51 )\n#define UNIT                      ( (SCENE_SCALE*4.0) / iResolution.y  )\n#define SMAA(d)                   ( smoothstep(UNIT, 0., d) )\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale + origin;\n}\n\nfloat diskSDF_L2(in vec2 NDC, in vec2 C, in float r) { return length(C - NDC)-r; }\n\n// halton low discrepancy sequence, from https://www.shadertoy.com/view/wdXSW8\nvec2 Halton(int index)\n{\n    const vec2 coprimes = vec2(2.0, 3.0);   // Halton(2, 3)\n    //const vec2 coprimes = vec2(3.0, 5.0); // Halton(3, 5)\n    //const vec2 coprimes = vec2(2.0, 5.0); // Halton(2, 5), e.t.c.\n    vec2 s = vec2(index, index);\n\tvec4 a = vec4(1,1,0,0);\n    while (s.x > 0. && s.y > 0.)\n    {\n        a.xy = a.xy/coprimes;\n        a.zw += a.xy*mod(s, coprimes);\n        s = floor(s/coprimes);\n    }\n    return a.zw; // output ranges [0.; 1.][0.; 1.]\n}\n\nfloat y_axisSDF(vec2 NDC) { return abs(NDC.x); }\nfloat x_axisSDF(vec2 NDC) { return abs(NDC.y); }\nfloat vertical_lineSDF(vec2 NDC, float x0) { return abs(NDC.x-x0); }\nfloat horizontal_lineSDF(vec2 NDC, float y0) { return abs(NDC.y-y0); }\nfloat cellsSDF(vec2 NDC)\n{\n    NDC = fract(NDC);\n    NDC = fract(min(NDC, 1. - NDC));\n    return\n        min(vertical_lineSDF(NDC, 0.), horizontal_lineSDF(NDC, 0.));\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, vec2(0.5), false);\n    \n    if (iFrame == 0)\n    {\n        vec3 color = vec3(1);\n             color = mix( color, vec3(0.5), SMAA(cellsSDF(NDC)) );\n             color = mix( color, vec3(0), SMAA(x_axisSDF(NDC)) );\n             color = mix( color, vec3(0), SMAA(y_axisSDF(NDC)) );\n\n        vec2 p = Halton(int(iTime));\n        color =  mix( color, vec3(0), SMAA(diskSDF_L2(NDC, p, 0.01)) );\n\n        O = vec4(color, 1.);\n        return;\n    }\n    \n    vec3 color = vec3(1);\n    vec3 pcolor = texelFetch(iChannel0, ivec2(SC), 0).xyz;\n\n    vec2 p = Halton(iFrame);\n    color =  mix( color, vec3(1,0,0), SMAA(diskSDF_L2(NDC, p, 0.0005)) );\n\n    O = vec4(min(color, pcolor), 1.);\n}","name":"Buffer A","description":"","type":"buffer"}]}