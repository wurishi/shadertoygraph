{"ver":"0.1","info":{"id":"Wdj3DV","date":"1550802827","viewed":274,"name":"Simple Campfire","username":"xjp","description":"Fire by xbe : https://www.shadertoy.com/view/XsXSWS\nFog by iq : https://www.shadertoy.com/view/XslGRr","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fire","volumetric","fog"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// \"Simple Campfire\"\n\nfloat noise(in vec3 x)\n{\n// Fix Problem of Sampler 3d On Some Machines\n#if 1\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n    vec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0. ).yx;\n\treturn mix(rg.x, rg.y, f.z);\n#else\n    // return texture(iChannel1, x / 32.0).x;\n#endif    \n}\n\nfloat fbm5(in vec3 p)\n{\n\tfloat f;\n    f  = 0.50000 * noise(p); p *= 2.02;\n    f += 0.25000 * noise(p); p *= 2.03;\n    f += 0.12500 * noise(p); p *= 2.01;\n    f += 0.06250 * noise(p); p *= 2.02;\n    f += 0.03125 * noise(p);\n\treturn f;\n}\n\nfloat fbm4(in vec3 p)\n{\n\tfloat f;\n    f  = 0.50000 * noise(p); p *= 2.02;\n    f += 0.25000 * noise(p); p *= 2.03;\n    f += 0.12500 * noise(p); p *= 2.01;\n    f += 0.06250 * noise(p);\n\treturn f;\n}\n\nfloat fbm3(in vec3 p)\n{\n\tfloat f;\n    f  = 0.50000 * noise(p); p *= 2.02;\n    f += 0.25000 * noise(p); p *= 2.03;\n    f += 0.12500 * noise(p);\n\treturn f;\n}\n\nfloat fbm2(in vec3 p)\n{\n\tfloat f;\n    f  = 0.50000 * noise(p); p *= 2.02;\n    f += 0.25000 * noise(p);\n\treturn f;\n}\n\nvec4 integrate(in vec4 sum, in float den, in float dis)\n{\n    den = 1.0 - exp(-0.04 * sqrt(den));\n    vec4 col = vec4(den * vec3(1.0, 0.95, 0.9) * 0.2 + 0.8 * dis * vec3(1.0, 0.85, 0.6), den);\n    col.xyz = clamp(col.xyz, 0.0, 1.0);\n    return vec4(sum.xyz + col.xyz * (1.0 - sum.a), sum.a + col.a - sum.a * col.a);\n}\n\nfloat sdCappedCylinder(in vec3 p, in vec2 h)\n{\n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat firewood(in vec3 p) {\n    vec2 h = vec2(0.15, 0.8);\n    vec3 q1 = vec3(p.y - 0.15, p.z * 0.5 - p.x * 0.866, p.x * 0.866 + p.z * 0.5);\n    vec3 q2 = vec3(q1.x, -q1.z, q1.y);\n\treturn min(sdCappedCylinder(q1, h), sdCappedCylinder(q2, h)) - 0.1 * noise((q1 + q2) * 10.0) + 0.05;\n}\n\nvec3 calcNormal(in vec3 x, in float eps)\n{\n    vec2 e = vec2(eps, 0.0);\n    return normalize(vec3(firewood(x + e.xyy) - firewood(x - e.xyy),\n                            firewood(x + e.yxy) - firewood(x - e.yxy),\n                            firewood(x + e.yyx) - firewood(x - e.yyx)));\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k)\n{\n    float res = 1.0;\n    float t = mint;\n    for(int i = 0; i < 32; i++)\n    {\n        float h = firewood(ro + rd * t);\n        res = min(res, k * h / t);\n        t += h;\n        if(t > maxt) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nvec4 raymarch(in vec3 ro, in vec3 rd)\n{\n    vec4 sum = vec4(0.0);\n    float t = 0.0;\n    \n    // ground\n    float tm = max(-ro.y / rd.y, 0.0);\n    vec3 gc = vec3(0.35, 0.32, 0.3);\n    int caseid = tm > 0.0? 1 : 0;\n    vec3 gp = ro + tm * rd;\n    \n    // fire\n    vec3 fc, wc;\n    float glt = smoothstep(0.0, 0.6, fbm3(vec3(0., 10.0 * iTime, 0.))) * 0.5 + 0.5;\n    float a = dot(rd.xz, rd.xz);\n    float b = 2.0 * dot(ro.xz, rd.xz);\n    float c = dot(ro.xz, ro.xz) - 0.64;\n    float dt = b * b - 4.0 * a * c;\n    if(dt > 0.0) {\n        float tf1 = (-b - sqrt(dt)) / 2.0 / a;\n        if(tf1 > 0.0) {\n            if(caseid == 0) {\n            \tcaseid = 2;\n        \t} else {\n        \t\tcaseid = 3;\n        \t}\n            float tf2 = (-b + sqrt(dt)) / 2.0 / a;\n            float tf = tf1;\n            float tf3 = 100.0;\n            float denf = 0.0;\n            for(int i = 0; i < 30; i++){ \n                vec3  pos = ro + tf * rd;\n                if(pos.y < 0.0 || pos.y > 2.0 || sum.a > 0.99) \n                    break;\n                float dp = fbm5(9.1 * pos - vec3(0., iTime * 13.0, 0.));\n                float c = 1. - 16. * pow(max( 0., length(vec2(pos.x, pos.z - 0.2 * pos.y) * vec2(0.11 + 0.46 * pos.y)) - 0.9 * pos.y * dp * dp), 1.2);\n                if(c * dp > 0.15) {\n                    if(tf3 == 100.0)\n                        tf3 = tf;\n                }\n                denf += c * dp;\n                tf += 0.05;\n                if(tf >= tf2) break;\n            }\n            float c1 = 0.05 * denf * (2.0 - pow(1.0 * (ro.y + tf1 * rd.y), 4.));\n            c1 = clamp(c1,0.,1.);\n            if(c1 < 0.1 || denf < 0.1) {\n            \tcaseid -= 2;\n                tf3 = 100.0;\n            } else {\n                fc = 1.6 * vec3(1.5*c1, 1.3*c1*c1, c1*c1*c1);\n                tm = (tf1 + tf2) * 0.5;\n        \t}\n            \n            // firewood\n            float tw = tf1;\n            float dw;\n            for(int i = 0; i < 30; ++i) {\n                vec3 pos = ro + tw * rd;\n            \tdw = firewood(pos);\n                if(dw < 0.0001) {\n                    if(tw < tf3 || caseid < 2) {\n                        tm = tw;\n                        caseid = 4;\n                        vec3 nor = calcNormal(pos, 0.01);\n                        float dif1 = dot(normalize(vec3(0.0, 1.0, 0.5) - pos), nor);\n                        wc = vec3(2.0) * (dif1 + 0.2) * glt * vec3(0.8, 0.45, 0.3);\n                        break;\n                    }\n                }\n                tw += dw;\n                if(tw >= tf2 || tw >= tf3) break;\n            }\n        }\n    }\n    \n    // fog\n    float wtf = 1.638;\n    if(caseid != 0) {\n        for(int i = 0; i < 100; i++){\n            if(t >= tm) break;\n            vec3 pos = ro + t * rd; \n            if(pos.y < 0.0 || pos.y > 8.0 || sum.a > 0.99) \n                break;\n            vec3 pos_ = pos - vec3(0.0, 0.0, iTime);\n            float den = fbm3(pos_); \n            if(den > 0.01){\n                float dis = abs(den - fbm3(0.9 * pos_));\n                dis = clamp(dis, 0.0, 1.0);\n                dis *= exp(-length(pos.xyz * vec3(1.0, 0.6, 1.0)) * wtf);\n                sum = integrate(sum, den, dis); \n            } \n            t += max(0.06, 0.02 * t);\n        }\n        if(caseid == 2 || caseid == 3)\n        {\n            sum.xyz += (1.0 - sum.a) * fc;\n        } else if(caseid == 1){\n            float ang = fbm2(2.1 * gp);\n            vec3 nor = normalize(vec3(0.5 * cos(16.28 * ang), 1.0, 0.5 * sin(16.28 * ang)));\n            float dif1 = dot(normalize(vec3(-gp.x, 2.0, -gp.z)), nor);\n            float dif2 = pow(normalize(vec3(-gp.x, 2.0, -gp.z)).y, 13.0);\n            float res = softshadow(gp, normalize(vec3(-gp.x, 12.0 - 10.0 * glt, -gp.z + 1.3)), 0.01, 1.0, 2.0);\n            res += softshadow(gp, normalize(vec3(-gp.x, 12.0 - 10.0 * glt, -gp.z + 0.3)), 0.01, 1.0, 2.0);\n            res *= glt / 2.0;\n            sum.xyz += (1.0 - sum.a) * (gc * (dif1 + 0.2) + 3.0 * dif2 * vec3(1.0, 0.85, 0.6)) * res;\n        } else {\n            sum.xyz += (1.0 - sum.a) * wc;\n        }\n        sum.w = 1.0;\n    }\n    else {\n        for(int i = 0; i < 100; i++){ \n            vec3 pos = ro + t * rd; \n            if(pos.y < 0.0 || pos.y > 8.0 || sum.a > 0.99) \n                break; \n            vec3 pos_ = pos - vec3(0.0, 0.0, iTime);\n            float den = fbm3(pos_); \n            if(den > 0.01){\n                float dis = abs(den - fbm3(0.9 * pos_));\n                dis = clamp(dis, 0.0, 1.0);\n                dis *= exp(-length(pos.xyz * vec3(1.0, 0.6, 1.0)) * wtf);\n                sum = integrate(sum, den, dis); \n            } \n            t += max(0.06, 0.02 * t);\n        }\n    }\n    return clamp(sum, 0.0, 1.0);\n}\n\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr)\n{\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvec4 render(in vec3 ro, in vec3 rd, in vec2 q)\n{\n    // sky\n    vec3 col = mix(vec3(0.27, 0.40, 0.51), vec3(0.112, 0.141, 0.38), q.y + 0.2);\n    \n    vec4 res = raymarch(ro, rd);\n    col = col*(1.0 - res.w) + res.xyz;\n    \n    return vec4(col, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x / iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n    \n    vec3 ro = 3.0 * vec3(sin(6.283 * m.x + 1.57), 0.0, cos(6.283 * m.x + 1.57)) + vec3(0.0, 1.0, 0.0);\n    vec3 ta = vec3(0.0, m.y + 1.0, 0.0);\n    mat3 ca = setCamera(ro, ta, 0.0);\n\n    vec3 rd = ca * normalize(vec3(p.xy, 1.5));\n    vec4 col = render(ro, rd, q);\n    \n    // vigneting\n    col *= 0.25 + 0.75 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.5);\n    fragColor = col;\n}","name":"Image","description":"","type":"image"}]}