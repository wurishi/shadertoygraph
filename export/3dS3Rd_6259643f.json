{"ver":"0.1","info":{"id":"3dS3Rd","date":"1549643873","viewed":157,"name":"Gyroid Tunnelling","username":"Polytrope","description":"Panning through a raymarched gyroid with simple fresnel shading. Very much WIP.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","gyroid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ZERO (min(iFrame,0))\n\n// Volumes\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat gyroid ( vec3 p, float s )\n{\n    return sin(p.x*s)*cos(p.y*s) + sin(p.y*s)*cos(p.z*s) + sin(p.z*s)*cos(p.x*s);\n}\n\n// Ops\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\nvec2 map( in vec3 pos )\n{\n    float d = sdBox( pos-vec3(0, 0, 0), vec3(1, 1, 1) );\n    \n    d = opS(d, sdBox(pos-vec3(0, 0, 0), vec3(0.5, 0.5, 2)));\n    \n    d = gyroid(pos, 1.0);\n    \n    return vec2(d, 1);\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 1000.0;\n    \n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<256; i++ )\n    {\n\t    float precis = 0.0004*t;\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    // Sky color\n    vec3 col = vec3(0);\n    //vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    \n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    \n    \n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        \n        float a = abs(dot( rd, nor ));\n        \n\t\tvec3 lig = normalize( vec3(-0.5, 0.5, -0.5) );\n        \n        vec3 hal = normalize( lig-rd );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        \n\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n                    dif *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n        \n\t\tvec3 lin = vec3(0.0);\n        //lin += 1.0*dif*vec3(1.0,1.0,1.0);\n        lin += 1.0*fre*vec3(1.00,1.00,1.00);\n        //lin += 0.50*bac*vec3(0.25,0.25,0.25);\n        \n\t\t//col += 9.00*spe*vec3(1.00,0.90,0.70);\n        \n        \n        col = lin;\n    }\n    \n    return col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Time\n\tfloat time = iTime;\n    \n    float spin = time * 0.5;\n    float bob = time * 0.5;\n    float pan = time * 0.5;\n\n    // pixel coordinates\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    \n    // Camera\n    float ox = cos(spin)*5.0;\n    float oy = sin(bob)*2.0;\n    float oz = sin(spin)*5.0;\n    vec3 ro = vec3(ox, oy, oz);\n    vec3 ta = vec3(0, 0, 0);\n    \n    ro = vec3(pan, pan, -pan) + vec3(1, 0, 1);\n    ta = ro + vec3(1, 1, -1);\n    \n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    // ray direction\n    vec3 rd = ca * normalize( vec3(p.xy,1.0) );\n    \n    // Render from origin, along direction\n    vec3 col = render(ro, rd);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}