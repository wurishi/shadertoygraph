{"ver":"0.1","info":{"id":"cdlSW4","date":"1668894626","viewed":176,"name":"Acid Cairo","username":"Mojomajor","description":"post effect for underwater scenes","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["wobble","net","cairo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define tex iChannel0\n#define time iTime\n#define factor 1.5\n\n#define JELLY 0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 vUv = fragCoord/iResolution.xy;\n    vUv *=1.;\n    #if JELLY\n    float sin0to1 = sin(time*30.)*0.5+0.5;\n    #else\n    float sin0to1 = 1.;\n    #endif\n\n    vec2 uv1 = vUv;\n    float frequency = 6.0;\n    float amplitude = 0.015 * factor*sin0to1;\n    float x = uv1.y * frequency + time * .7; \n    float y = uv1.x * frequency + time * .3;\n    uv1.x += cos(x+y) * amplitude * cos(y);\n    uv1.y += sin(x-y) * amplitude * cos(y);\n    vec4 rgba = texture(tex, uv1);\n    fragColor = rgba;\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define time iTime/3.\n\nfloat noise(vec2 st){\n    return fract(sin(dot(vec2(12.23,74.343),st))*43254.);  \n}\n\n#define pi acos(-1.)\nfloat noise2D(vec2 st){\n  \n  //id,fract\n  vec2 id =floor(st);\n  vec2 f = fract(st);\n  \n  //nachbarn\n  float a = noise(id);\n  float b = noise(id + vec2(1.,0.));\n  float c = noise(id + vec2(0.,1.));\n  float d = noise(id + vec2(1.));\n  \n  \n  //f\n  f = smoothstep(0.,1.,f);\n  \n  //mix\n  float ab = mix(a,b,f.x);\n  float cd = mix(c,d,f.x);\n  return mix(ab,cd,f.y);\n}\n\nmat2 rot45 = mat2(0.707,-0.707,0.707,0.707);\n\nmat2 rot(float a){\n  float s = sin(a); float c = cos(a);\n  return mat2(c,-s,s,c);\n}\nfloat fbm(vec2 st, float N, float rt){\n    st*=3.;\n \n  float s = .5;\n  float ret = 0.;\n  for(float i = 0.; i < N; i++){\n     \n      ret += noise2D(st)*s; st *= 2.9; s/=2.; st *= rot((pi*(i+1.)/N)+rt*8.);\n      st.x += iTime/10.;\n  }\n  return ret;\n  \n}\n\nfloat Hash21(vec2 p) {\n\tp = fract(p*vec2(234.34, 435.345));\n    p += dot(p, p+34.23);\n    return fract(p.x*p.y);\n}\n\nvec3 Cairo(vec2 uv, float k) {\n    vec2 id = floor(uv);\n    //id*=fbm(id,1.,1.);\n    float check = mod(id.x+id.y, 2.); // 0 or 1\n\n    uv = fract(uv)-.5;\n    //vec2 p = abs(uv*fbm(uv,1.,1.));\n    vec2 p = abs(uv);\n    \n    if (check==1.) p = p.yx;\n\n    float a = (k*.5+.5)*3.1415;\n    vec2 n = vec2(sin(a), cos(a));\n    float d = dot(p-.5, n); // slanted line\n    if (d* (check-.5)<0. )\n        id.x += sign(uv.x)*.5;\n    else\n        id.y += sign(uv.y)*.5;\n\n    d = min(d, p.x); // straight line\n    d = max(d, -p.y);// straight line\n    d = abs(d);\n    d = min(d, dot(p-.5, vec2(n.y, -n.x)));\n    //d*=fbm(uv,1.,1.);\n    d/=fbm(id,1.,1.);\n    return vec3(id, d); \n}\nvec3 hash3( vec3 p ) // replace this by something better\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n            dot(p,vec3(269.5,183.3,246.1)),\n            dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\nfloat perlin(vec2 n) {\n    const vec2 d = vec2(0.0, 1.0);\n    vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n    return mix(mix(rand(dot(b, d)), rand(dot(b + vec2(1.0, 0.0), d)), f.x),\n               mix(rand(dot(b + vec2(0.0, 1.0), d)), rand(dot(b + vec2(1.0, 1.0), d)), f.x), f.y);\n}\nvec3 saturate(vec3 x) {\n  return clamp(x, vec3(0.0), vec3(1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord- .5*iResolution.xy)/iResolution.y;\n    vec2 mouse = iMouse.xy/iResolution. xy;\n    vec3 col = vec3(0);\n    uv *= 5.;\n    vec3 c = Cairo(uv, 0.25*(sin(time)*0.5+0.55));\n    //vec3 rnd = vec3(10.,0.,0.);\n    //vec2 p = fract(uv)-.5;\n    vec2 p = abs(uv*fbm(uv,1.,1.));\n    // symmetry\n    //p = abs(p);\n    \n    vec3 randColor = vec3(sin(p.x * 10.0), cos(p.y * 20.0), fbm(p, 3.0,2.));\n\n    vec3 rnd = fract(vec3(p, 1.0) );\n    col += c.z*+randColor*10.;\n    //col += c.z;\n    float r = Hash21(c.xy);\n    col *= 1. * sin(r*6.283185*time);\n    col += smoothstep(.01, 0., c.z-.005/fbm(p, 3.0,2.));\n    \n    fragColor = vec4(col,1.0); \n\n}","name":"Buffer A","description":"","type":"buffer"}]}