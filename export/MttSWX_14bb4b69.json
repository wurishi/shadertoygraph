{"ver":"0.1","info":{"id":"MttSWX","date":"1481920586","viewed":227,"name":"Simple steriogram","username":"Seledorn","description":"A steriogram shader, ie old fashioned 3d. Focus behind the screen and until the black lines line up and you can see it. \nIt might be easier if you turn off the motion, and crank down the z_mult. Smaller resolution is easier, don't go fullscreen!\n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["steriogram"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// try to focus behind the scene to see the hidden image :) \n// the black lines should line up.\n// if you have trouble seeing anything \n// turn off the speed, pull down the z_mult \nconst float move_speed = 20.0;\nconst float z_mult = 5.0; // range around 1 to 20\nconst float square_size = 0.60;\nconst float num_divisions = 4.0; // higher easier but more artifacts when animating\n//#define TWO_WAY\n\n\nconst float stop_threshold = 0.001;\nconst float clip_far = 10.0;\n\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\nfloat sphere( vec3 pos, float r ) {\n\treturn length( pos ) - r;\n}\n\nfloat cube( vec3 p, vec3 b ) {\n  vec3 d = abs(p) - b;\n  return max(d.x,max(d.y,d.z));\n}\n\nfloat opI(float a,float b)\n{\n    return max(a,b);\n}\nfloat opU(float a, float b)\n{\n    return min(a,b);\n}\n\nfloat cone( vec3 p, vec2 c )\n{\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n#define ssin(x) sin(iTime*0.5)*x\n\nfloat dist_field( vec3 pos ) {\n    \n    float b = cube(pos,vec3(0.5));\n    float s = sphere(pos,0.60);\n    float s2 = sphere(pos+vec3(ssin(1.0),0.0,0.0),0.2);\n\n    return opU(opI(b,-s),s2);\n    \n    float box = (cube(pos, vec3(0.5))+sphere(pos,0.7))/2.0;\n    float b2 = cube(pos, vec3(0.5)+ssin(0.058));\n    return  opI(box,-b2) ;\n}\n\nfloat shading( vec3 v, vec3 n, vec3 eye ) {\n    float f = 1.0;\n    return mix(0.0,1.0,smoothstep(4.0,1.0,length(v-eye)));\n}\n\nfloat ray_marching( vec3 origin, vec3 dir, float start, float end ) {\n\tfloat depth = start;\n\tfor ( int i = 0; i < 64; i++ ) {\n        vec3 p = origin + dir * depth;\n\t\tfloat dist = dist_field(p) ;\n\t\tif ( abs( dist ) < stop_threshold ) {\n\t\t\treturn depth;\n\t\t}\n\t\tdepth += dist * 0.9;\n\t\tif ( depth >= end) {\n\t\t\treturn end;\n\t\t}\n\t}\n\treturn end;\n}\n\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\n\nfloat random(vec2 p){return fract(cos(dot(p,vec2(23.14069263277926,2.665144142690225)))*123456.);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //#define NO_STERIO\n    vec2 res = iResolution.xy;\n    \n    #ifdef NO_STERIO\n    const float num_divs =2.0;\n    #else\n    const float num_divs = num_divisions;\n    #endif\n    res.x/=num_divs;\n    vec2 uv = fragCoord.xy;\n    uv.x = mod(uv.x,res.x); \t//equal on left and right side.\n\tuv /=  iResolution.x;\n    int i = int(fragCoord.x/res.x);\n    \n    \n    float d=0.0;\n    {\n        for(int j=0;j<int(num_divs);j++)\n        {\n\t\t\tvec2 p = vec2(fragCoord.x-res.x*float(j),fragCoord.y);\n            p.x -= (res.x*(num_divs))/2.0;\n\n\n            mat3 rot = rotationXY( ( iMouse.xy +vec2(iTime,0.0)*move_speed - res * 0.5 ).yx * vec2( 0.01, -0.01 ) );\n            vec3 dir = ray_dir( 60.0, res, p);\n\n            vec3 eye = vec3( 0.0, 0.0, 2.5 );\n            dir *= rot;\n            eye *= rot;\n\t\t\t\n            if(j>i)break;\n            d += smoothstep(4.0,1.0,ray_marching( eye, dir, 0.0, clip_far ));\n        }\n    }\n    uv/=square_size;\n    \n    #ifdef NO_STERIO\n    fragColor = vec4(vec3(d),1.0);\n    return;\n    #else\n    //if(fragCoord.x<res.x) d = 0.0; \n    uv*=200.0;\n    vec2 r = floor(vec2(uv.x+d*z_mult,uv.y));\n    float noise_x = random(r);\n    float noise_y = random(r*31.0);\n    float noise_z = random(r*101.0);\n    vec4 background = vec4(noise_x,noise_y,noise_z,1);\n    fragColor = mod(fragCoord.x,res.x) < 1.0 ?  vec4(0,0,0,0):background;\n    //fragColor = background;\n   \t#endif\n}","name":"Image","description":"","type":"image"}]}