{"ver":"0.1","info":{"id":"sslyDM","date":"1644062275","viewed":60,"name":"Projet Graphisme Lilian Battani","username":"lbattani","description":"Projet module graphisme par ordinateur Télécom Nancy 2021-2022","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["projetgraphisme"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float FARAWAY=1e30;\nconst float EPSILON=1e-3;\nconst vec4 GROUND=vec4(0.,.7,0.,1.);\nconst vec4 SKY=vec4(0.5, 0.5, 1.0, 1.0);\n\nstruct Camera {\n    vec3 Obs;\n    vec3 View;\n    vec3 Up;\n    vec3 Horiz;\n    float H;\n    float W;\n    float z;\n};\n\nstruct Ray {\n    vec3 Origin;\n    vec3 Dir;\n};\n\nvec2 to2D(in vec3 V){\n    return vec2(V.x, V.y);\n}\n\nCamera camera(in vec3 Obs, in vec3 LookAt, in float aperture) {\n   Camera C;\n   C.Obs = Obs;\n   C.View = normalize(LookAt - Obs);\n   C.Horiz = normalize(cross(vec3(0.0, 0.0, 1.0), C.View));\n   C.Up = cross(C.View, C.Horiz);\n   C.W = float(iResolution.x);\n   C.H = float(iResolution.y);\n   C.z = (C.H/2.0) / tan((aperture * 3.1415 / 180.0) / 2.0);\n   return C;\n}\n\nCamera rotatingCamera(in vec3 Obs, in vec3 LookAt, in float aperture) {\n   float speed = -120.0;\n\n   float beta = float(iFrame)/speed;\n   float c = cos(beta);\n   float s = sin(beta);\n   \n   vec3 Obs2 = vec3(Obs.x*c, Obs.y*s, Obs.z);\n    \n   Camera C;\n   C.Obs = Obs2;\n   C.View = normalize(LookAt - Obs2);\n   C.Horiz = normalize(cross(vec3(0.0, 0.0, 1.0), C.View));\n   C.Up = cross(C.View, C.Horiz);\n   C.W = float(iResolution.x);\n   C.H = float(iResolution.y);\n   C.z = (C.H/2.0) / tan((aperture * 3.1415 / 180.0) / 2.0);\n   return C;\n}\n\nRay launch(in Camera C, in vec2 XY) {\n   return Ray(\n      C.Obs,\n      C.z*C.View+(XY.x-C.W/2.0)*C.Horiz+(XY.y-C.H/2.0)*C.Up \n   );\n}\n\nstruct Sphere {\n   vec3 Center;\n   float R;\n};\n\nconst Sphere NULL_SPHERE = Sphere(vec3(0., 0., 0.), 0.);\n\nstruct Cylinder {\n   vec3 Origin;\n   float Height;\n   float R;\n};\n\nconst Cylinder NULL_CYLINDER = Cylinder(vec3(0., 0., 0.), 0., 0.);\n\nstruct Plan {\n    vec3 norm;\n    vec3 point;\n    float planeHeight;\n};\n\nfloat getD(Plan P) {\n    return dot(P.norm, P.point);\n}\n\nfloat getIntersectT(Plan P, Ray Droite) {\n    float d = getD(P);\n    \n    vec3 orig = Droite.Origin;\n    vec3 dir = Droite.Dir;\n    vec3 norm = -P.norm;\n    \n    return -((dot(orig, norm)+d)/dot(orig, dir));\n}\n\nstruct Material {\n    vec4 Kd; // diffuse color\n    vec4 Ke; // emissive color\n    vec4 Kr; // couleur réflechie\n};\n\nMaterial diffuse(in vec4 Kd) {\n   return Material(Kd, vec4(0.0, 0.0, 0.0, 1.0), vec4(0.0, 0.0, 0.0, 1.0));\n}\n\nMaterial light(in vec4 Ke) {\n   return Material(vec4(0.0, 0.0, 0.0, 1.0), Ke, vec4(0.0, 0.0, 0.0, 1.0));\n}\n\nMaterial reflector(in vec4 Kd, in vec4 Kr){\n   return Material(Kd ,vec4(0., 0., 0., 1.), Kr);\n}\n\nstruct Object {\n   Sphere sphere;\n   Cylinder cylinder;\n   Material material;\n};\n\nObject sphereObject(in Sphere S, in Material M){\n    return Object(S, NULL_CYLINDER, M);\n}\n\nObject cylinderObject(in Cylinder C, in Material M){\n    return Object(NULL_SPHERE, C, M);\n}\n\nvec3 getCenter(in Object o){\n    if(o.sphere != NULL_SPHERE)\n        return o.sphere.Center;\n    else if(o.cylinder != NULL_CYLINDER)\n        return o.cylinder.Origin+vec3(0., 0., o.cylinder.Height/2.);\n        \n    return vec3(0., 0., 0.);\n}\n\nstruct PlanObject {\n    Plan plan;\n    Material material;\n};\n\nObject scene[7];\nPlanObject scenePlan;\n\nvoid init_scene(vec2 fragCoordxy, vec2 iResolutionxy) {\n   float beta = float(iFrame)/30.0;\n   float s = sin(beta);\n   float c = cos(beta);\n   \n   float beta2 = float(iFrame)/120.0;\n   float s2 = sin(beta2);\n   float c2 = cos(beta2); \n\n   scene[0] = cylinderObject(\n      Cylinder(\n          vec3(2., 2., -1.),\n          1.75,\n          .2\n      ), \n      diffuse(texture(iChannel0, fragCoordxy / iResolutionxy))\n   );\n   \n   scene[6] = sphereObject(\n      Sphere(vec3(2., 2., 1.35),0.7), \n      diffuse(vec4(0.0, 1.0, 0.0, 1.0))\n   );\n\n   scene[1] = sphereObject(\n      Sphere(vec3(0.7*s, 0.7*c, 0.0),0.1), \n      diffuse(vec4(1.0, 0.0, 0.0, 1.0))\n   );\n   \n   scene[2] = sphereObject(\n      Sphere(vec3(1.4*c2, 1.4*s2, 0.0),0.2), \n      diffuse(vec4(1.0, 1.0, 0.0, 1.0))\n   );\n\n   scene[3] = sphereObject(\n      Sphere(vec3(12.0, 0.0, 6.0),0.02),\n      light(vec4(1.0, 1.0, 1.0, 1.0)) \n   );\n   \n   scene[4] = sphereObject(\n      Sphere(vec3(0.0, 0.0, 6.0),0.02),\n      light(vec4(0.5, 0.5, 0.5, 1.0)) \n   );\n   \n   scene[5] = sphereObject(\n      Sphere(vec3(0.0, 0.0, 0.0),0.5), \n      reflector(vec4(0.2, 0.2, 0.2, 1.), vec4(0.8, 0.8, 0.8, 1.))\n   );\n   \n   scenePlan = PlanObject(\n       Plan(\n           vec3(0., 0., 1.),\n           vec3(0., 0., 19.),\n           -2.0\n       ),\n       diffuse(texture(iChannel1, fragCoordxy / iResolutionxy))\n   );\n   \n\n//   scene[3] = Object(\n//      Sphere(vec3(1.5, 0.0, 1.5),0.02),\n//      light(vec3(1.0, 1.0, 1.0)) \n//   );\n\n\n}\n\nbool intersect_sphere(in Ray R, in Sphere S, out float t) {\n   vec3 CO = R.Origin - S.Center;\n   float a = dot(R.Dir, R.Dir);\n   float b = 2.0*dot(R.Dir, CO);\n   float c = dot(CO, CO) - S.R*S.R;\n   float delta = b*b - 4.0*a*c;\n   if(delta < 0.0) {\n      return false;\n   }\n   t = (-b-sqrt(delta)) / (2.0*a);\n   return true;\n}\n\nbool intersect_cylinder(in Ray R, in Cylinder C, out float t){\n    float t2d;\n\n    vec2 CO = to2D(R.Origin) - to2D(C.Origin);\n    vec2 Dir = to2D(R.Dir);\n    \n    float a = dot(Dir, Dir);\n    float b = 2.0*dot(Dir, CO);\n    float c = dot(CO, CO) - pow(C.R, 2.);\n    \n    float delta = b*b - 4.0*a*c;\n    \n    if(delta < 0.0) {\n       return false;\n    }\n    \n    t2d = (-b-sqrt(delta)) / (2.0*a);\n    \n    float x2d = to2D(R.Origin).x + t2d * CO.x;\n    \n    t = t2d;\n    \n    vec3 P = R.Origin + R.Dir*t;\n    float zDist = P.z - C.Origin.z;\n    \n    if(zDist < EPSILON || zDist > C.Height)\n        return false;\n    \n    //Calcul du point sur la droite en 3d\n    \n    return true;\n}\n\nbool intersect_plane(in Ray R, in PlanObject P, out float t) {\n   vec3 norm = normalize(P.plan.point - P.plan.norm);\n   vec3 dir = R.Dir;\n   float planeHeight = P.plan.planeHeight;\n   \n   float dotProduct = dot(norm, dir);\n   bool intersect = dotProduct < EPSILON;\n   \n   if(intersect)\n       //t = planeHeight*dotProduct;\n       t = getIntersectT(P.plan, R);\n   \n   return intersect;\n}\n\nbool shadow(in Ray r){\n    for(int i=0; i<scene.length(); ++i){\n        float t;\n        \n        if(scene[i].material.Ke == vec4(0. ,0. ,0. , 1.)){\n            if(scene[i].sphere != NULL_SPHERE && intersect_sphere(r, scene[i].sphere, t)\n            && t > EPSILON\n            && t < 1.0){\n            \n                return true;\n            }else if(scene[i].cylinder != NULL_CYLINDER && intersect_cylinder(r, scene[i].cylinder, t)\n            && t > EPSILON\n            && t < 1.0){\n            \n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n \nvec4 lighting(in vec3 P, in vec3 N, in Material material) {\n   if(material.Ke != vec4(0.0, 0.0, 0.0, 1.0)) {\n      return material.Ke;\n   }  \n\n   vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n\n   for(int i=0; i<scene.length(); ++i) {\n      if(scene[i].material.Ke != vec4(0.0, 0.0, 0.0, 0.0)) {\n         vec3 center = getCenter(scene[i]);\n         Ray R2 = Ray(P, center);\n         \n         if( !shadow(R2) ){\n             vec3 E = center - P;\n             float lamb = max(0.0, dot(E,N) / length(E));\n             result += lamb * material.Kd * scene[i].material.Ke;\n         }\n      }\n   }\n\n   return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n   init_scene(fragCoord.xy, iResolution.xy);\n\n   Camera C = rotatingCamera(\n       vec3(3.0, 3.0, 1.5),\n       vec3(0.5, 0.5, 0.5),\n       100.0       \n   );\n   Ray R = launch(C, fragCoord);\n   \n   \n   fragColor = SKY;\n\n   const float FARAWAY=1e30; \n   float t = FARAWAY;\n\n   vec3 P;  // Point courant\n   vec3 N;  // Normale\n   Material material; // Couleur\n\n   for(int i=0; i<scene.length(); ++i) {\n       float cur_t;\n       vec3 center = getCenter(scene[i]);\n       \n       if(\n          (\n              scene[i].sphere != NULL_SPHERE\n              && intersect_sphere(R, scene[i].sphere, cur_t) \n              && cur_t < t\n          )\n       ) {\n           t = cur_t;\n           P = R.Origin + t*R.Dir;\n           N = normalize(P - center);\n           material = scene[i].material;\n       }\n       \n       if(\n           (\n              scene[i].cylinder != NULL_CYLINDER\n              && intersect_cylinder(R, scene[i].cylinder, cur_t) \n              && cur_t < t\n              && t == FARAWAY\n          )\n       ){\n           t = cur_t;\n           P = R.Origin + t*R.Dir;\n           N = normalize(P - center);\n           material = scene[i].material;\n       }\n   }\n   \n   float t2;\n   bool intersectSomething = false;\n\n   if(t != FARAWAY) {\n      fragColor = lighting(P,N,material);\n      intersectSomething = true;\n   }else if(intersect_plane(R, scenePlan, t2) && t2 < t){\n       P = R.Origin + t2*R.Dir;\n       N = scenePlan.plan.norm;\n       material = scenePlan.material;\n       \n       fragColor = lighting(P,N,material);\n       intersectSomething = true;\n   }\n   \n   if(intersectSomething && material.Kr != vec4(0.0, 0.0, 0.0, 1.0)){\n       \n       //réflexion\n       vec4 Kr = material.Kr;\n       \n       //vecteur réflexion\n       R = Ray(P, -2.*dot(N, R.Dir)*N + R.Dir);\n       intersectSomething = false;\n       \n       //\n       //\n       //\n       \n       for(int i=0; i<scene.length(); ++i) {\n           float cur_t;\n           vec3 center = getCenter(scene[i]);\n           \n           if(\n              (\n                  scene[i].sphere != NULL_SPHERE\n                  && intersect_sphere(R, scene[i].sphere, cur_t) \n                  && cur_t < t\n              )\n           ) {\n               t = cur_t;\n               P = R.Origin + t*R.Dir;\n               N = normalize(P - center);\n               material = scene[i].material;\n           }\n       \n           if(\n               (\n                  scene[i].cylinder != NULL_CYLINDER\n                  && intersect_cylinder(R, scene[i].cylinder, cur_t) \n                  && cur_t < t\n                  && t == FARAWAY\n              )\n           ){\n               t = cur_t;\n               P = R.Origin + t*R.Dir;\n               N = normalize(P - center);\n               material = scene[i].material;\n           }\n       }\n\n       if(t != FARAWAY) {\n          fragColor = lighting(P,N,material);\n          intersectSomething = true;\n       }else if(intersect_plane(R, scenePlan, t2) && t2 < t){\n           P = R.Origin + t2*R.Dir;\n           N = scenePlan.plan.norm;\n           material = scenePlan.material;\n       \n           fragColor = lighting(P,N,material);\n           intersectSomething = true;\n       }\n       \n       if(intersectSomething){\n           fragColor = Kr*lighting(P,N,material);\n       }else{\n           fragColor = SKY;\n       }\n   }\n}\n","name":"Image","description":"","type":"image"}]}