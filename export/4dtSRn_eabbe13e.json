{"ver":"0.1","info":{"id":"4dtSRn","date":"1457481918","viewed":671,"name":"Reusable drag and drop","username":"mhnewman","description":"Reusable drag and drop framework. Drag objects around by clicking on them. Add new objects by clicking in space. Delete objects by dragging them to the red square.","likes":21,"published":1,"flags":32,"usePreview":0,"tags":["mouse","template","drop","drag","util","reusable"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Inspired by https://www.shadertoy.com/view/MdKGRw\n// This is a reusable drag and drop framework.\n//\n//  * Drag objects around by clicking on them.\n//  * Add new objects by clicking in space.\n//  * Delete objects by dragging them to the red square.\n//\n// Buf A has all the drag and drop logic. Check it out for the instructions!\n\nconst int maxCount = 16;\nconst float radius = 20.0;\nconst float border = 3.0;\n\nconst vec4 deleteRect = vec4(0.0, 0.0, 40.0, 40.0);\n\nconst float statePos = float(maxCount);\n\n#define BufA(x) texture(iChannel0, (vec2(x, 0.0) + 0.5) / iResolution.xy)\n\nbool inRect(vec2 pos, vec4 rect) {\n    return pos.x >= rect.x && pos.y >= rect.y && pos.x < rect.z && pos.y < rect.w;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 state = BufA(statePos);\n    \n\tvec3 color = vec3(1.0);\n    \n    float curr = 0.0;\n    float dist = radius + 1.0;\n    for (int i = 0; i < maxCount; ++i) {\n        float f = float(i);\n        if (f >= state.y)\n            break;\n        vec2 center = BufA(f).xy;\n        float d = distance(fragCoord, center);\n        if (d < dist) {\n            dist = d;\n            curr = f;\n        }\n    }\n    \n    if (dist < radius) {\n        if (dist > radius - border) {\n            color = vec3(0.0, 0.0, 0.0);\n        } else {\n            if (curr == state.x)\n                if (state.z > 0.0)\n                    color = vec3(0.0, 1.0, 0.0);\n                else\n                    color = vec3(0.5, 1.0, 1.0);\n            else\n                color = vec3(0.5, 0.5, 1.0);\n        }\n    }\n    \n    if (inRect(fragCoord, deleteRect))\n        color = mix(color, vec3(1.0, 0.0, 0.0), 0.3);\n    \n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Drag and drop framework\n// https://www.shadertoy.com/view/4dtSRn\n// by mhnewman\n//\n// maxCount := the maximum number of objects that can be represented.\n//\n// Buffer pixels (0, 0) to (maxCount - 1, 0) := the coordinates of each object.\n//  * .x := the object's x coordinate.\n//  * .y := the object's y coordinate.\n//\n// Buffer pixel (maxCount, 0) := the current state.\n//  * .x := the index of the currently selected object.\n//  * .y := the number of active objects.\n//  * .z := the mouse state.\n//\n// Buffer pixel (maxCount + 1, 0) := the mouse offset from the center of the current object.\n\nconst int maxCount = 16;\nconst float radius = 20.0;\n\nconst vec4 deleteRect = vec4(0.0, 0.0, 40.0, 40.0);\n\nconst float statePos = float(maxCount);\nconst float offsetPos = float(maxCount + 1);\n\n#define addObject(xPos, yPos) { if (p.x == count) fragColor = vec4((xPos), (yPos), 0.0, 0.0); count += 1.0; }\n\nbool inRect(vec2 pos, vec4 rect) {\n    return pos.x >= rect.x && pos.y >= rect.y && pos.x < rect.z && pos.y < rect.w;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = fragCoord - 0.5;\n    \n    if (p.y > 0.0 || p.x > offsetPos) {\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    if (iFrame == 0) {\n        float count = 0.0;\n\n        //\n        // Initial conditions\n        //\n        addObject(0.2 * iResolution.x, 0.2 * iResolution.y);\n        addObject(0.2 * iResolution.x, 0.8 * iResolution.y);\n        addObject(0.8 * iResolution.x, 0.8 * iResolution.y);\n        \n        if (p.x == statePos)\n            fragColor = vec4(2.0 * statePos, count, 0.0, 0.0);\n        return;\n    }\n    \n    vec4 state = texture(iChannel0, vec2(0.5 + statePos, 0.5) / iResolution.xy);\n    vec4 offset = texture(iChannel0, vec2(0.5 + offsetPos, 0.5) / iResolution.xy);\n\n    if (state.z <= 0.0 && iMouse.z > 0.0) {\n        float r = radius + 1.0;\n        for (int i = 0; i < maxCount; ++i) {\n            float f = float(i);\n            if (f >= state.y)\n                break;\n            vec4 center = texture(iChannel0, vec2(0.5 + f, 0.5) / iResolution.xy);\n            float d = distance(iMouse.xy, center.xy);\n            if (d < r) {\n                r = d;\n                state.x = f;\n                offset = center - iMouse;\n            }\n        }\n        if (r > radius) {\n            if (state.y >= statePos) {\n            \tstate.x = 2.0 * statePos;\n            } else {\n    \t        state.x = state.y;\n        \t    state.y += 1.0;\n        \t}\n        }\n    } else if (state.z > 0.0 && iMouse.z <= 0.0 && inRect(iMouse.xy, deleteRect)) {\n        if (p.x == statePos) {\n            state.x = 2.0 * statePos;\n            state.y -= 1.0;\n            state.z = iMouse.z;\n\t        fragColor = state;\n    \t    return;\n        }\n        if (p.x < state.x) {\n            fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n            return;\n        }\n        fragColor = texture(iChannel0, (fragCoord + vec2(1.0, 0.0)) / iResolution.xy);\n        return;\n    }\n    state.z = iMouse.z;\n    \n    if (p.x == statePos) {\n        fragColor = state;\n        return;\n    }\n    \n    if (p.x == offsetPos) {\n        fragColor = offset;\n        return;\n    }\n\n    if (p.x == state.x && state.z > 0.0) {\n        fragColor = iMouse + offset;\n        return;\n    }\n    \n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}","name":"Buf A","description":"","type":"buffer"}]}