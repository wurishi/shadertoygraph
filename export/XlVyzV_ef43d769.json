{"ver":"0.1","info":{"id":"XlVyzV","date":"1536993427","viewed":68,"name":"Slice of a 3d mandelbrot","username":"vegardno","description":"Just trying out a generalisation of the Mandelbrot set to 3D.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["mandelbrot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 mul(vec3 p, vec3 q) {\n    return vec3(p.x * q.x + p.y * q.z - p.z * q.y,\n                p.x * q.y + p.y * q.x + p.z * q.z,\n                -p.x * q.z + p.y * q.y + p.z * q.x);\n}\n\n// http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n// https://github.com/kbinani/colormap-shaders/blob/master/shaders/glsl/IDL_Rainbow%2BBlack.frag\nvec4 colormap_hsv2rgb(float h, float s, float v) {\n\tfloat r = v;\n\tfloat g = v;\n\tfloat b = v;\n\tif (s > 0.0) {\n\t\th *= 6.0;\n\t\tint i = int(h);\n\t\tfloat f = h - float(i);\n\t\tif (i == 1) {\n\t\t\tr *= 1.0 - s * f;\n\t\t\tb *= 1.0 - s;\n\t\t} else if (i == 2) {\n\t\t\tr *= 1.0 - s;\n\t\t\tb *= 1.0 - s * (1.0 - f);\n\t\t} else if (i == 3) {\n\t\t\tr *= 1.0 - s;\n\t\t\tg *= 1.0 - s * f;\n\t\t} else if (i == 4) {\n\t\t\tr *= 1.0 - s * (1.0 - f);\n\t\t\tg *= 1.0 - s;\n\t\t} else if (i == 5) {\n\t\t\tg *= 1.0 - s;\n\t\t\tb *= 1.0 - s * f;\n\t\t} else {\n\t\t\tg *= 1.0 - s * (1.0 - f);\n\t\t\tb *= 1.0 - s;\n\t\t}\n\t}\n\treturn vec4(r, g, b, 1.0);\n}\n\nvec4 colormap(float x) {\n\tif (x < 0.0) {\n\t\treturn vec4(0.0, 0.0, 0.0, 1.0);\n\t} else if (1.0 < x) {\n\t\treturn vec4(0.0, 0.0, 0.0, 1.0);\n\t} else {\n\t\tfloat h = clamp(-9.42274071356572E-01 * x + 8.74326827903982E-01, 0.0, 1.0);\n\t\tfloat s = 1.0;\n\t\tfloat v = clamp(4.90125513855204E+00 * x + 9.18879034690780E-03, 0.0, 1.0);\n\t\treturn colormap_hsv2rgb(h, s, v);\n\t}\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -2 to 2)\n    vec3 c = 2. * vec3(2. * fragCoord / iResolution.xy - vec2(1., 1.), 0);\n\n    c = (rotationMatrix(vec3(1., 0., 0.), 1.0 * iTime) * vec4(c, 0)).xyz;\n    //c = (rotationMatrix(vec3(0., 1., 0.), 0.3 * iTime) * vec4(c, 0)).xyz;\n    //c = (rotationMatrix(vec3(0., 0., 1.), 0.7 * iTime) * vec4(c, 0)).xyz;\n    \n    const int n = 100;\n    \n    vec3 z = vec3(0., 0., 0.);\n    \n    int i;\n    for (i = 0; i < n; ++i) {\n        z = mul(z, z) + c;\n        if (length(z) > 4.)\n            break;\n    }\n\n    // Output to screen\n    fragColor = colormap(log(float(i)) / log(float(n)));\n}","name":"Image","description":"","type":"image"}]}