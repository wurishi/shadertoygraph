{"ver":"0.1","info":{"id":"wlXXDS","date":"1564098194","viewed":689,"name":"Smooth outlines WIP","username":"cdyk","description":"Experiment with anti-aliased toon outlines using the screen space equations of the triangle outlines. Left side is hard edges, right side is smooth edges.","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["outlines"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Post-process toon outline using screen space line equations, work-in-progress.\n//\n// BufferA implements a very basic rasterization pipeline, to emulate\n// geometry drawing. In rasterizerTriangle, the screen-space line\n// equations of the triangle are evaluated and the neareast are passed\n// along via the render target.\n//\n// There is a per-triangle calc of three line equations, which would\n// fit into a geometry or mesh shader.\n//\n// The post-process pass (this file) reads a 3x3 stencil of object ids\n// and determines if there should be an edge, and if so, tries to find\n// the distance to the closest edge.\n//\n// At interior edges, this could be calculated directly in the fragment\n// shader, however, at silhouette edges only one triangle has a nearby\n// edge, and thus silhouette lines gets half thickness.\n// \n// This post-process pass tries to remedy this by searching for a nearby\n// edge if the distance to neareast edge is too large.\n//\n// To figure out:\n// - Pixel coverage calc is propably too simple.\n// - Removing triangle outlines not corresponding to change of object id\n//   has some leakage.\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = 0.5*iTime;\n    float ti = floor(t);\n    float tf = fract(t);\n    bool drawAllEdges = false; //int(ti) % 2 == 0;\n    float lineWidth = 0.9; //0.6 + 0.3*(mod(ti, 3.0) + smoothstep(0.9,1.0, tf));\n\n    // fetch 3x3 stencil of object ids and \n    uint id[9];\n    vec3 eq[9];\n    for(int j=0; j<3; j++) {\n        for(int i=0; i<3; i++) {\n            vec4 t = texture(iChannel0, (fragCoord+vec2(-1+j,-1+i))/iResolution.xy);\n            id[3*j+i] = uint(t.a);\n            eq[3*j+i] = t.xyz;\n        }\n    }\n\n    // Check if there is a boundary in the 3x3 neighbourhood.\n    bool nearBoundary = drawAllEdges;\n    for(int i=0; i<9; i++) {\n        nearBoundary = nearBoundary || id[4] != id[i];\n    }\n\n    float weight = 1.0;\n    if(nearBoundary) {\n        \n        // find distance to closest edge in triangle\n        vec2 p = 2.0*fragCoord.xy - iResolution.xy;\n        float dist = abs(dot(vec3(p,-1), eq[4]));\n\n        if(1.0 < dist) { \n            // closest edge was far away, so we're probably on a\n            // silhouette. Search through stencil and find closest edge.\n            for(int i=0; i<9; i++) {\n                dist = min(dist, abs(dot(vec3(p,-1), eq[i])));\n            }\n        }\n        \n        // calculate pixel coverage, ignoring rotation for now.\n        float n = max(-0.5, dist - lineWidth);\n        float f = min( 0.5, dist + lineWidth);\n        float cover = max(0.0, f-n);\n\n        weight = 1.0 - cover;\n    }\n\n    vec3 baseColor = 0.5*(vec3((id[4]>>2u)&1u,(id[4]>>1u)&1u,id[4] & 1u)+vec3(1));\n    \n    if(int(fragCoord.x) == int(0.5*iResolution.x)) {\n        // Black line in the middle\n        weight = 0.0;\n    }\n    else if(int(fragCoord.x) < int(0.5*iResolution.x)) {\n        // Left side is binary edge detection for comparison.\n\t\tweight =\n            id[4] != id[5] ||\n            id[4] != id[7] ||\n            id[4] != id[8]\n            ? 0.0 : 1.0;\n    }\n\n    fragColor = vec4(weight*baseColor, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Simple rasterization pipeline, interesting stuff is in rasterizeTriangle\n\nfloat cross2(vec2 a, vec2 b)\n{\n\treturn cross(vec3(a, 0), vec3(b, 0)).z;   \n}\n\nvoid rasterizeTriangle(inout float depth,\n                       inout int id,\n                       inout vec3 equation,\n                       in vec4 a, in vec4 b, in vec4 c,\n                       in vec2 p,\n                       in int _id)\n{\n    vec2 ab = b.xy - a.xy;\n    vec2 bc = c.xy - b.xy;\n    vec2 ca = a.xy - c.xy;\n    \n    vec2 ap = p - a.xy;\n    vec2 bp = p - b.xy;\n    vec2 cp = p - c.xy;\n    \n    // Back-face culling\n    float area_abc = cross2(ab, bc);\n    if(area_abc <= 0.0) return;\n\n    // Point-in-triangle test\n    float area_abp = cross2(ab, bp);\n    float area_bcp = cross2(bc, cp);\n    float area_cap = cross2(ca, ap);\n    if(area_abc <= 0.0 || area_abp < 0.0 || area_bcp < 0.0 || area_cap < 0.0) return;\n    \n    // barycentric coords\n    float bary_a = area_bcp/area_abc;\n    float bary_b = area_cap/area_abc;\n    float bary_c = 1.0 - bary_a - bary_b;\n    \n    // perspective corrected z-interpolation\n    // probably not necessary here.\n    float z = bary_a * a.w*a.z + bary_b * b.w*b.z + bary_c * c.w*c.z;\n    float w = bary_a * a.w + bary_b * b.w + bary_c * c.w;\n    z = z/w;\n    \n    // frustum z is in [-1, 1], do near-far plane clipping\n    if(z < -1.0 || 1.0 < z) return;\n    \n    if(z < depth) {\n        depth = z;\n        id = _id;\n\n\t\t// Per-triangle calc that probably should be done in a\n        // geometry, mesh or compute shader.\n        \n        ab *= iResolution.xy;\n        bc *= iResolution.xy;\n        ca *= iResolution.xy;\n        p  *= iResolution.xy;\n        vec2 l_ab = normalize(vec2(-ab.y, ab.x));\n        float d_ab = dot(iResolution.xy*a.xy, l_ab);\n        \n        vec2 l_bc = normalize(vec2(-bc.y, bc.x));\n        float d_bc = dot(iResolution.xy*b.xy, l_bc);\n\n        vec2 l_ca = normalize(vec2(-ca.y, ca.x));\n        float d_ca = dot(iResolution.xy*c.xy, l_ca);\n\n        // Per-pixel calc, corresponding to fragment shader.\n        // Find closest edge of the triangle outline and pass\n        // that forward.\n        float eq_ab = dot(p.xy, l_ab) - d_ab;\n        float eq_bc = dot(p.xy, l_bc) - d_bc;\n        float eq_ca = dot(p.xy, l_ca) - d_ca;\n        \n        if(eq_ab < eq_bc) {\n            if(eq_ab < eq_ca) {\n                equation = vec3(l_ab, d_ab);\n            }\n            else {\n                equation = vec3(l_ca, d_ca);\n            }\n        }\n        else if(eq_bc < eq_ca) {\n            equation = vec3(l_bc, d_bc);\n        }\n        else {\n         \tequation = vec3(l_ca, d_ca);   \n        }\n    }\n   \n}\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    float x = axis.x;\n    float y = axis.y;\n    float z = axis.z;\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat4(\n        x*x*(1.0-c) +   c, y*x*(1.0-c) + z*s, x*z*(1.0-c) - y*s, 0,\n        x*y*(1.0-c) - z*s, y*y*(1.0-c) +   c, y*z*(1.0-c) + x*s, 0,\n        y*z*(1.0-c) + y*s, y*z*(1.0-c) - x*s, z*z*(1.0-c) +   c, 0,\n        0,                                 0,                 0, 1\n\t);\n}\n\nmat4 translationMatrix(vec3 o)\n{\n    return mat4(\n        1, 0, 0, 0,\n        0, 1, 0, 0, \n        0, 0, 1, 0,\n        o.x, o.y, o.z, 1\n    );\n}\n    \n\nmat4 frustumMatrix(float l, float r, float b, float t, float n, float f)\n{\n    return mat4(\n        2.0*n/(r-l), 0, 0, 0,\n        0, 2.0*n/(t-b), 0, 0,\n        (r+l)/(r-l), (t+b)/(t-b), -(f+n)/(f-n), -1,\n        0, 0, -2.0*f*n/(f-n), 0\n    );\n}\n\nvec4 perspectiveDivide(vec4 h)\n{\n    return (1.0/h.w)*vec4(h.xyz, 1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = 0.1*iTime;\n    \n    mat4 M =\n        rotationMatrix(vec3(0,0,1), 0.3*t) *\n        rotationMatrix(vec3(0,1,0), 0.7*t) *\n        rotationMatrix(vec3(0,0,1), 1.1*t);\n\n    float h = 1.0;\n    float aspect = iResolution.x/iResolution.y;\n    mat4 P =\n        frustumMatrix(-h*aspect, h*aspect,\n                      -h,  h,\n                       1.0, 11.0) *\n        translationMatrix(vec3(0,0,-6.5));\n        \n    \n    mat4 PM = P * M;\n    \n    vec3 equation = vec3(0,0,-100);\n    int id = 0;\n    float depth = 200.0;\n\n    int _id = 1;\n    vec2 uv = 2.0*fragCoord/iResolution.xy - vec2(1);\n    for(int j=-1; j<=1; j++) {\n\t    for(int i=-1; i<=1; i++) {\n    \t    vec3 o = 2.5*vec3(i,j,0);\n    \n            vec4 c000 = perspectiveDivide(PM*vec4(o + vec3(-1,-1, -1), 1));\n            vec4 c100 = perspectiveDivide(PM*vec4(o + vec3(1,-1, -1), 1));\n            vec4 c010 = perspectiveDivide(PM*vec4(o + vec3(-1, 1, -1), 1));\n            vec4 c110 = perspectiveDivide(PM*vec4(o + vec3( 1, 1, -1), 1));\n            vec4 c001 = perspectiveDivide(PM*vec4(o + vec3(-1,-1,  1), 1));\n            vec4 c101 = perspectiveDivide(PM*vec4(o + vec3( 1,-1,  1), 1));\n            vec4 c011 = perspectiveDivide(PM*vec4(o + vec3(-1, 1,  1), 1));\n            vec4 c111 = perspectiveDivide(PM*vec4(o + vec3( 1, 1,  1), 1));\n\n            vec3 n_x = mat3(M)*vec3(1,0,0);\n            vec3 n_y = mat3(M)*vec3(0,1,0);\n            vec3 n_z = mat3(M)*vec3(0,0,1);\n\n            rasterizeTriangle(depth, id, equation, c100, c000, c110, uv, _id);\n            rasterizeTriangle(depth, id, equation, c110, c000, c010, uv, _id);\n            rasterizeTriangle(depth, id, equation, c001, c101, c111, uv, _id);\n            rasterizeTriangle(depth, id, equation, c001, c111, c011, uv, _id);\n\t\t\t_id++;\n\n            rasterizeTriangle(depth, id, equation, c000, c100, c001, uv, _id);\n            rasterizeTriangle(depth, id, equation, c100, c101, c001, uv, _id);\n            rasterizeTriangle(depth, id, equation, c110, c010, c011, uv, _id);\n            rasterizeTriangle(depth, id, equation, c111, c110, c011, uv, _id);\n\t\t\t_id++;\n\n            rasterizeTriangle(depth, id, equation, c010, c000, c011, uv, _id);\n            rasterizeTriangle(depth, id, equation, c011, c000, c001, uv, _id);\n            rasterizeTriangle(depth, id, equation, c100, c110, c111, uv, _id);\n            rasterizeTriangle(depth, id, equation, c100, c111, c101, uv, _id);\n\t\t\t_id++;\n        }\n    }        \n    \n    fragColor = vec4(equation, id);\n}","name":"Buffer A","description":"","type":"buffer"}]}