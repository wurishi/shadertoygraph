{"ver":"0.1","info":{"id":"4l2SDK","date":"1446676288","viewed":374,"name":"raytracing reflections 1","username":"Equations","description":"just an attempt of raytracing objects, with reflection","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["reflections","rayrtacing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"//cc by-nc-sharealike\nconst float minGlobalDist = 0.001;\nconst float maxGlobalDist = 5000.0;\nconst int reflectionIter = 10;\n\n//basic calculation functions\nfloat traceSphere(vec3 rayOrg, vec3 rayDir, vec4 sphere)\n{\n\t// ( k*rayDir + rayOrg - sphere.xyz )Â² = sphere.wÂ²\n    // kÂ² * rayDirÂ² + 2.0 * k * rayDir * (rayOrg - sphere.xyz) + (rayOrg - sphere.xyz)Â² - sphere.wÂ²\n    float a = dot(rayDir, rayDir);\n    float b = 2.0 * dot(rayDir, rayOrg - sphere.xyz); \n    float c = dot(rayOrg - sphere.xyz, rayOrg - sphere.xyz) - sphere.w * sphere.w;\n    \n    // x = -b-sqrt(bÂ²-4ac)/2a\n    float root = b * b - 4.0 * a * c;\n   \t\n    float dist;\n    if(root >= 0.0){ \n       \tdist = ( - b - sqrt(root)) / 2.0 / a;\n    \tif(dist == clamp(dist, minGlobalDist, maxGlobalDist))\n        \treturn dist;\n    }\n    return maxGlobalDist;   \n}\nfloat tracePlane(vec3 rayOrg, vec3 rayDir, vec4 plane)\n{\n\t//(rayOrg+ k*rayDir - plane.xyz * plane.w) * plane.xyz = 0\n    \n    float dist;\n    if(dot(rayDir, plane.xyz) != 0.0){\n       dist = dot(plane.xyz * plane.w - rayOrg, plane.xyz) / dot(rayDir, plane.xyz);\n       if(dist == clamp(dist, minGlobalDist, maxGlobalDist))\n           return dist;\n    }\n    return maxGlobalDist;\n}\nvec3 getReflection(vec3 rayDir, vec3 normal)\n{\n    //normal is normalized!\n    return rayDir - 2.0 * normal * dot(rayDir, normal);\n}\nfloat _min(float arg1, float arg2, float arg3, float arg4, float arg5, float arg6, float arg7, float arg8, float arg9)\n{ \n    return min(min(min(min(min(min(min(min(arg1, arg2), arg3), arg4), arg5), arg6), arg7), arg8), arg9);\n}\n\n\n//    --- OBJECTS ---\t\t//null \"0\": no obj.\n//light sorces\nvec4 light1 = vec4(0.2, 1.7, 1.0, 0.03);\n//planes\nvec4 plane101 = vec4(0.0, 1.0, 0.0, -1.8);\nvec4 plane102 = vec4(0.0, 1.0, 0.0, 3.8);\nvec4 plane103 = vec4(0.0, 0.0, 1.0, -1.8);\nvec4 plane104 = vec4(0.0, 0.0, 1.0, 3.8);\nvec4 plane105 = vec4(1.0, 0.0, 0.0, -2.8);\nvec4 plane106 = vec4(1.0, 0.0, 0.0, 2.8);\n//spheres\nvec4 sphere201(){\n    return vec4(1.7 * sin(iTime), 0.0, 1.5 + 1.2 * cos(iTime), 0.9); \n}\nvec4 sphere202(){\n    return vec4(-1.7 * sin(iTime), 0.0, 1.5 - 1.2 * cos(iTime), 0.9);\n}\n\n//object tracing\nint getTracedObj(vec3 rayOrg, vec3 rayDir, out float dist)\n{\n\tfloat \n        distLight1 = traceSphere(rayOrg, rayDir, light1), \n        \n        distPlane101 = tracePlane(rayOrg, rayDir, plane101),\n        distPlane102 = tracePlane(rayOrg, rayDir, plane102),\n    \tdistPlane103 = tracePlane(rayOrg, rayDir, plane103),\n    \tdistPlane104 = tracePlane(rayOrg, rayDir, plane104),\n    \tdistPlane105 = tracePlane(rayOrg, rayDir, plane105),\n    \tdistPlane106 = tracePlane(rayOrg, rayDir, plane106),\n    \t\n        distSphere201 = traceSphere(rayOrg, rayDir, sphere201()),\n    \tdistSphere202 = traceSphere(rayOrg, rayDir, sphere202());\n    \n    dist = _min(distLight1, distPlane101, distPlane102, distPlane103, distPlane104, distPlane105, distPlane106, distSphere201, distSphere202);\n    \n    if(dist == maxGlobalDist) return 0;\n    if(dist == distLight1) return 1;\n    \n    if(dist == distPlane101) return 101;\n    if(dist == distPlane102) return 102;\n    if(dist == distPlane103) return 103;\n    if(dist == distPlane104) return 104;\n    if(dist == distPlane105) return 105;\n    if(dist == distPlane106) return 106;\n    \n    if(dist == distSphere201) return 201;\n    if(dist == distSphere202) return 202;\n    return 0;\n    \n}//reflection\nfloat getReflAmount(int obj)\n{\n\tif(obj == 102) return 0.70;\n    else if(obj == 202) return 0.95;\n    else if(obj == 201) return 0.95;\n    else return 0.0;\n}\nvec3 getReflDir(vec3 rayDir, vec3 rayLoc, int obj)\n{\n\tif(obj == 102) return getReflection(rayDir, normalize(plane102.xyz));\n    else if(obj == 201) return getReflection(rayDir, normalize(rayLoc - sphere201().xyz));\n    else if(obj == 202) return getReflection(rayDir, normalize(rayLoc - sphere202().xyz));\n    else return vec3(0.0);\n}\n//colors \nvec4 getColor(vec3 rayDir, vec3 rayPos, int obj)\n{\n\tvec4 _return = vec4(0.0);\n    \n    (obj == 1) && vec4(0.0) == (_return = vec4(1.0));\n    \n    (obj == 101) && vec4(0.0) == (_return = vec4(0.3, 0.3, 1.0, 1.0));\n    (obj == 103) && vec4(0.0) == (_return = vec4(0.3, 1.0, 0.3, 1.0));\n    (obj == 104) && vec4(0.0) == (_return = vec4(1.0, 0.3, 0.3, 1.0));\n    (obj == 105) && vec4(0.0) == (_return = vec4(1.0, 1.0, 0.3, 1.0));\n    (obj == 106) && vec4(0.0) == (_return = vec4(1.0, 0.3, 1.0, 1.0));\n    \n    (obj > 100 && obj < 110) && vec4(0.0) == (_return = _return * smoothstep (0.0, 0.15, 1.0 / dot(light1.xyz - rayPos, light1.xyz - rayPos)));\n    return _return;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv =  - 1.0 + 2.0 * fragCoord.xy / iResolution.xy; uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 rayOrg = vec3(0.0, 0.3, -1.0);\n    vec3 rayDir = vec3(uv, 1.0);\n    \n    //setting up game objects\n    float dist; int obj = getTracedObj(rayOrg, rayDir, dist);\n    \n    float thisReflection = getReflAmount(obj); \n    float totalReflection = thisReflection;\n    vec4 reflColor = vec4(0.0);\n    \n    fragColor = (1.0 - thisReflection) * getColor(rayDir, rayOrg + dist * rayDir, obj);\n    \n    \n    \n    for(int reflCtr = 0; reflCtr < reflectionIter; reflCtr++)\n    {\n        vec3 newDir;\n        (thisReflection != 0.0) && ((((((rayOrg += dist * rayDir) == (rayDir = getReflDir(rayDir, rayOrg, obj))))\n        \t== (0 == (obj =getTracedObj(rayOrg, rayDir, dist))))\n            == (0.0 == (thisReflection = getReflAmount(obj))))\n            == (vec4(0.0) == (fragColor += totalReflection * (1.0 - thisReflection) * getColor(rayDir, rayOrg + dist * rayDir, obj))))\n            == (0.0 == (totalReflection -= totalReflection * (1.0 - thisReflection)));\n        \n        \n        \n        /* --- original loop code --- \n        if(thisReflection == 0.0) break;\n        vec3 newDir = getReflDir(rayDir, rayOrg + dist * rayDir, obj);\n        rayOrg += dist * rayDir; rayDir = newDir;\n        obj = getTracedObj(rayOrg, rayDir, dist);\n        thisReflection = getReflAmount(obj);\n        fragColor += totalReflection * (1.0 - thisReflection) * \n            getColor(rayDir, rayOrg + dist * rayDir, obj);\n        totalReflection -= totalReflection * (1.0 - thisReflection); */\n    } \n}","name":"Image","description":"","type":"image"}]}