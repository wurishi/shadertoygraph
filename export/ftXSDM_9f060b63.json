{"ver":"0.1","info":{"id":"ftXSDM","date":"1625750194","viewed":134,"name":"The Tetration Fractal","username":"incription","description":"Fractal on whether the function x^^infinity converges or not\n\nStarts at z^2 at t = 0 and mixes to z^^2 at t = 4pi","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define _Center vec2(-0.5, 0.0)\n#define _Range 9.0\n#define _Iter 250.0\n#define PI 3.14159\n\nfloat iter(vec2 w)\n{\n    vec2 z = w;\n    \n    float i;\n    float t = cos(min(max(iTime-1., 0.) / 4., 1.*PI)) / 2. + .5;\n    for(i = 0.; i < _Iter; i++) {\n        if(z.x * z.x + z.y * z.y > 1e12) break;\n        //z = cmul(cpow(z, w), z);\n        z = cmul(cpow(mix(w, z, t), mix(z, vec2(2., 0.), t)), w); //Mix between z^2 and z^^2\n    }\n    return i;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x / iResolution.y; //Preserve aspect\n    \n    float t = 0.; //smoothstep(0., 1., min(1., max(iTime/5. - 0.2, 0.)));\n    float Range = mix(_Range, 0.02, t);\n    vec2 Center = mix(_Center, vec2(-0.188,0.235), t);\n    \n    vec4 dx = Range * vec4((1./iResolution.xy)/4., -1. * (1./iResolution.xy)/4.);\n    vec2 z = (uv * Range + Center); //Calculate initial value\n    \n    //Iterate (bad msaa?)\n    float i = iter(z + dx.xy) + \n              iter(z + dx.xw) +\n              iter(z + dx.zy) +\n              iter(z + dx.zw);\n    i *= 1. / 4.;\n          \n    vec3 col = vec3( i / _Iter );\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\nfrom\nhttps://stackoverflow.com/questions/56725883/how-to-express-tetration-function-for-complex-numbers\n*/\n\nvec2 cmul(in vec2 a, in vec2 b) {\n    return vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x);\n}\n\n// complex exponent e^a\nvec2 cexp(in vec2 a) {\n    float ea = exp(a.x);\n    float vl = a.y;\n    return ea * vec2( cos(vl), sin(vl) );\n}\n\n// complex natural logarithm ln(a)\nvec2 cln(in vec2 a) {\n    float ql = length(a);\n    return vec2( log(ql), atan(a.y, a.x));\n}\n\n// complex power function a^b\nvec2 cpow(in vec2 a, in vec2 b) {\n    return cexp(cmul(cln(a), b));   \n}","name":"Common","description":"","type":"common"}]}