{"ver":"0.1","info":{"id":"lXySDm","date":"1720026186","viewed":60,"name":"Pond after oil spill","username":"Capo","description":"I added oil spill and ripple effects to the pond, simulating the color of the water in the pond after the oil spill。","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["colorrippleichannel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Shadertoy GLSL code\n//reference：https://www.shadertoy.com/view/Mt33DH\nfloat rotSpeed = 0.05;\nfloat nsize = 5.0;\nfloat nstrenght = 1.0;\nfloat rippleSpeed = 10.0;\nfloat rippleFreq = 20.0;\nfloat size = 0.8;\nfloat dropSpeed = 1.0;\nfloat dropSize = 0.7;\nfloat pi = 3.14159265359;\n\nfloat hash(float n)\n{\n    return fract(sin(dot(vec2(n, n), vec2(12.9898, 78.233))) * 43758.5453);  \n} \n\nfloat brush(vec2 uv, float tile)\n{            \n    uv *= tile;\n    float mouseRipple = 0.0;\n\n    if (iMouse.z > 0.5)\n    {     \n        vec2 mPos = iMouse.xy / iResolution.xy;\n        mPos.x *= iResolution.x / iResolution.y; \n        mPos *= tile;\n        \n        float l = 1.0 - length(uv - mPos);\n        \n        mouseRipple = smoothstep(size, 1.0, l);\n    }\n     \n    float dropRipple = 0.0;\n    \n    const int iter = 10;\n    for (int i = 0; i < iter; i++)\n    {\n        float ifloat = float(i) + 1.0;\n        float phase = (ifloat / float(iter)) * dropSpeed;\n        float t = iTime * dropSpeed + phase;\n        float rX = hash(floor(t) + ifloat);\n        float rY = hash(floor(t) * 0.5 + ifloat);\n        \n        vec2 rPos = vec2(rX, rY) * tile; \n        rPos.x *= iResolution.x / iResolution.y; \n        float rl = 1.0 - length(uv - rPos);\n        float fTime = fract(t);\n        float rRipple = sin(rl * rippleFreq + fTime * rippleSpeed) * 0.5 + 0.5;\n        float rB = smoothstep((1.0 - fTime) * dropSize, 1.0, rl);\n        dropRipple += rB * rRipple * (1.0 - fTime);\n    }\n    \n    return dropRipple + mouseRipple;\n}\n\nvec3 calculateNormals(vec2 uv, float tile)\n{\n    float offsetX = nsize / iResolution.x;\n    float offsetY = nsize / iResolution.y;\n    vec2 ovX = vec2(offsetX, 0.0);\n    vec2 ovY = vec2(0.0, offsetY);\n    \n    float X = (brush(uv - ovX, tile) - brush(uv + ovX, tile)) * nstrenght;\n    float Y = (brush(uv - ovY, tile) - brush(uv + ovY, tile)) * nstrenght;\n    float Z = 1.0; \n    \n    return normalize(vec3(X, Y, Z));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // 添加两秒后背景扭动效果\n    if (iTime > 2.0) {\n        float distortionStrength = smoothstep(2.0, 10.0, iTime) * 0.05;\n        float distortionTime = (iTime - 2.0) * 2.0;\n        uv += vec2(\n            sin(uv.y * 10.0 + distortionTime) * distortionStrength,\n            cos(uv.x * 10.0 + distortionTime) * distortionStrength\n        );\n    }\n\n    // 生成水波和法线\n    vec3 n = calculateNormals(uv, 2.0);\n    \n    // 计算光照\n    vec3 lightDir = normalize(vec3(sin(iTime * rotSpeed), cos(iTime * rotSpeed), 1.0));\n    float l = max(0.0, dot(n, lightDir));\n    float fresnel = 1.0 - dot(vec3(0.0, 0.0, 1.0), n);\n\n    // 计算反射坐标\n    vec3 reflDir = reflect(-lightDir, n);\n    vec2 reflUV = reflDir.xy * 0.5 + 0.5;\n    reflUV = clamp(reflUV, 0.0, 1.0);\n\n    // 采样反射纹理\n    vec4 refl = texture(iChannel2, reflUV);\n\n    // 采样iChannel0的纹理并增加初始亮度\n    vec2 distortedUv = uv + n.xy * 0.05;\n    vec4 tex = texture(iChannel0, distortedUv) * 5.0;\n\n    // 直接处理iChannel0本身的变化\n    float wave = sin(uv.y * 10.0 + iTime) * 0.1;\n    vec2 additionalDistortedUv = uv + vec2(wave, 0.0);\n    vec4 texColor0 = texture(iChannel0, additionalDistortedUv) * 3.0;\n\n    float wave2 = cos(uv.x * 10.0 + iTime * 1.5) * 0.1;\n    vec2 additionalDistortedUv2 = uv + vec2(wave2, wave2);\n    vec4 texColor1 = texture(iChannel0, additionalDistortedUv2) * 3.0;\n\n    vec4 mixedColor = mix(texColor0, texColor1, 0.5);\n\n    vec3 colorEffect = vec3(\n        0.5 + 0.5 * sin(iTime + uv.x * 10.0),\n        0.5 + 0.5 * cos(iTime + uv.y * 10.0),\n        0.5 + 0.5 * sin(iTime + uv.x * 5.0 + uv.y * 5.0)\n    );\n    \n    float colorEffectStrength = smoothstep(2.0, 10.0, iTime); \n    mixedColor.rgb *= colorEffect * colorEffectStrength;\n\n    float brightness = 3.0; \n    mixedColor.rgb *= brightness;\n\n    mixedColor = clamp(mixedColor, 0.0, 1.0);\n\n    // 增加油腻效果\n    float oilyEffect = sin(iTime * 2.0) * 0.5 + 0.5;\n    refl *= 1.0 + oilyEffect;\n\n    // 结合光照和反射效果\n    mixedColor = mix(mixedColor, tex, 0.5);\n    mixedColor = mixedColor * 0.5 + vec4((fresnel + l) * 2.5) * refl + refl * 0.5;\n\n    // 输出最终颜色\n    fragColor = mixedColor;\n}\n","name":"Image","description":"","type":"image"}]}