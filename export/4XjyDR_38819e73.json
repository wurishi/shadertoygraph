{"ver":"0.1","info":{"id":"4XjyDR","date":"1727145862","viewed":40,"name":"defenderII","username":"jorge2017a2","description":"defenderII","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["2d","bitmap","defender"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//otra version de defenderII, con nueva tecnica o nueva idea!!!\n//por Jorge2017a2\n//--lun-23-2024\n\n\n\n#define PI 3.14159265\n#define TWO_PI 6.28318530\n\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d, b) smoothstep(antialiasing(1.5), 0., d - (b))\n///#define S3(d, b) smoothstep(1.0 / antialiasing(0.5), 0., d - (b))  //orignal\n#define S3(d, b) smoothstep(0.25 / antialiasing(0.5), 0., d - (b))\n\n\nconst int NAVE_BITMAP[256] = int[](\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,\n0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,\n0,2,1,1,1,1,0,0,0,0,0,0,0,0,0,0,\n0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,\n0,2,1,2,2,1,1,1,1,0,0,0,5,0,0,0,\n0,0,0,2,2,2,1,1,1,1,1,1,1,3,4,0,\n0,0,0,2,2,1,3,4,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);\n\n\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \n    \nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r;}\n\nvec3 DFB(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S3( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0),S3(abs( distObj)-0.005,0.0));\n  return colOut;\n}\n\n\n\nvec3 DFS(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S( distObj,0.0)); return colOut;\n  return colOut;\n}\n\n\nfloat sdSegment(in vec2 p, in vec2 a, in vec2 b, in float th) {\n    vec2 ba = b - a;\n    vec2 pa = p - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    vec2 q = pa - h * ba;\n    return length(q) - th;\n}\n\n// Function to generate a random number based on tile position\nfloat random(float seed) {\n    return fract(sin(seed) * 43758.5453);\n}\n\n\nvec3 RGB3(float r ,float g, float b)\n{ return vec3(r/255.,g/255.,b/255.);}\n\n\nvec3 GetColorNave(int opc)\n{   switch(opc)\n    {\n        \n    case 0:return RGB3(0.,0.,0.);\n    case 1:return RGB3(140.,140.,140.);\n    case 2:return RGB3(255.,0.,255.);\n    case 3:return RGB3(255.,255.,255.);\n    case 4:return RGB3(0.,159.,98.);\n    case 5:return RGB3(255.,255.,0.);\n\n    }\n    return vec3(1.0);\n}\n\n\n\n\nvec3 PonerNave(vec2 uv, ivec2 pos, vec3 col)\n{   int opc;\n    ivec2 pix = ivec2(uv*256.)+ivec2(-pos.x*16,-16*pos.y);\n    \n     pix.y=-pix.y+15;\n    if (min(pix.x, pix.y) >= 0 && max(pix.x, pix.y) < 16) \n    {   opc=int( NAVE_BITMAP[pix.x+pix.y*16] );\n        if(opc!=0) col=GetColorNave(opc);\n    }\n    return col;\n}\n\n\n\nvec3 Linea01(vec2 p, vec3 colout, vec3 colin, float timeOffset) {\n    vec2 pt18_1[17] = vec2[](\n        vec2(0.0000, 0.2568), vec2(0.0608, 0.3142), vec2(0.1250, 0.2500),\n        vec2(0.1824, 0.3108), vec2(0.2500, 0.2601), vec2(0.3108, 0.3108), \n        vec2(0.3750, 0.2534), vec2(0.4324, 0.3142), vec2(0.4932, 0.2534), \n        vec2(0.5608, 0.3176), vec2(0.6216, 0.2534), vec2(0.6858, 0.3142), \n        vec2(0.7466, 0.2601), vec2(0.8041, 0.3142), vec2(0.8716, 0.2568), \n        vec2(0.9392, 0.3108), vec2(0.9966, 0.2568)\n    );\n\n  \n    float dfin = 999.9;\n    for (int i = 0; i < 16; i++) {\n        float d1 = sdSegment(p, pt18_1[i], pt18_1[i + 1], 0.01);        \n        dfin = min(dfin, d1);\n    }\n\n    colout = DFB(colin, colout, dfin);\n    return colout;\n}\n\nvec3 Linea02(vec2 p, vec3 colout, vec3 colin, float timeOffset) {\n    vec2 pt18_1[17] = vec2[](\n        vec2(0.0034, 0.2568), vec2(0.0608, 0.3176), vec2(0.1216, 0.2568),\n        vec2(0.1824, 0.3108), vec2(0.2534, 0.2568), vec2(0.3142, 0.3142), \n        vec2(0.3750, 0.2568), vec2(0.4358, 0.3108), vec2(0.4966, 0.2500), \n        vec2(0.5608, 0.3209), vec2(0.6216, 0.2534), vec2(0.6824, 0.3480), \n        vec2(0.7196, 0.3176), vec2(0.7500, 0.3480), vec2(0.8378, 0.2162), \n        vec2(0.9324, 0.3142), vec2(0.9966, 0.2601)\n    );\n\n\n    float dfin = 999.9;\n    for (int i = 0; i < 16; i++) {\n        float d1 = sdSegment(p, pt18_1[i], pt18_1[i + 1], 0.01);        \n        dfin = min(dfin, d1);\n    }\n\n    colout = DFB(colin, colout, dfin);\n    return colout;\n}\n\nvec3 Linea03(vec2 p, vec3 colout, vec3 colin, float timeOffset) {\n    vec2 pt[3] = vec2[](\n        vec2(0.0068, 0.2500), vec2(0.4966, 0.7432), vec2(0.9966, 0.2534) );\n\n\n    float dfin = 999.9;\n    for (int i = 0; i < 2; i++) {\n        float d1 = sdSegment(p, pt[i], pt[i + 1], 0.01);        \n        dfin = min(dfin, d1);\n    }\n    \n    \n\n    colout = DFB(colin, colout, dfin);\n    return colout;\n}\n\nvec3 Linea04(vec2 p, vec3 colout, vec3 colin, float timeOffset) {\n    vec2 pt[13] = vec2[](\n        vec2(0.0034, 0.2534), vec2(0.0541, 0.3142), vec2(0.1284, 0.2500),\n        vec2(0.1926, 0.3074), vec2(0.2568, 0.2500), vec2(0.3108, 0.3074), \n        vec2(0.3682, 0.2568), vec2(0.4358, 0.3142), vec2(0.4932, 0.2601), \n        vec2(0.6182, 0.3750), vec2(0.7466, 0.2568), vec2(0.8716, 0.3716), \n        vec2(0.9966, 0.2534)\n    );\n\n\n    float dfin = 999.9;\n    for (int i = 0; i < 12; i++) {\n        float d1 = sdSegment(p, pt[i], pt[i + 1], 0.01);        \n        dfin = min(dfin, d1);\n    }\n    \n\n    colout = DFB(colin, colout, dfin);\n    return colout;\n}\n\n\n\n\nvec3 lineasTdo(vec2 p, vec3 colout, float timeOffset) {\n    colout = Linea01(p - vec2(-1.5-timeOffset,0.0), colout, vec3(1.0), timeOffset);\n    colout = Linea02(p - vec2(-0.5-timeOffset,0.0), colout, vec3(1.0), timeOffset);\n    colout = Linea03(p - vec2(0.5-timeOffset, 0.0), colout, vec3(1.0), timeOffset);\n    colout = Linea04(p - vec2(1.5-timeOffset, 0.0), colout, vec3(1.0), timeOffset);\n    \n    // Agrega más líneas aquí si lo deseas...\n    return colout;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 col = vec3(0.0);\n\n   float timeOffset =0.0;\n    float t=iTime;\n  \n    float tt=mod(t*0.5,4.0);\n    \n    vec2 uv2=uv;\n    float escala=1.0;\n     \n     uv.x =opRep1D(uv.x+tt, 4.0 )+0.5;\n     \n     uv2*=0.25;\n     uv2.x =opRep1D(uv2.x+tt, 8.0 )+0.5;\n    \n      ivec2 pos3=ivec2(10+int(5.0*sin(t)),8);\n      ivec2 posi=ivec2(2,2);\n    ivec2 pos2=ivec2(3  ,2);\n\n    col = lineasTdo(uv-vec2(0.0,-0.75), col, timeOffset);\n    \n     vec2 posn=vec2(0.0-tt, 0.125*sin(t)+0.1);\n    col=PonerNave(uv2+posn, pos2, col);\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}