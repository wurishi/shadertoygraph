{"ver":"0.1","info":{"id":"lstfRj","date":"1525984197","viewed":259,"name":"One Wolf Logo I","username":"oalpha","description":"First version of my logo in webgl. Uses implicitized bezier curves.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["logo","wolf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.14159265358\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\nmat2 invert(mat2 m) {\n    return (1.0 / determinant(m)) * mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]);\n}\nstruct line2 {\n    vec2 start;\n    vec2 end;\n};\nvec2 intersect(line2 a, line2 b, out vec2 s) {\n    mat2 Ai = invert(mat2(a.end - a.start, b.start - b.end));\n    s = Ai * (b.start - a.start);\n    return a.start + s.x * (a.end - a.start);\n}\nfloat triarea(vec2 a, vec2 b, vec2 c) {\n    vec3 ab = vec3(b - a, 0.0);\n    vec3 bc = vec3(c - b, 0.0);\n    vec3 ca = vec3(a - c, 0.0);\n    vec3 n = cross(ab, bc);\n    float A = length(bc);\n    float B = length(ca);\n    float C = length(ab);\n    float S = (A + B + C) * 0.5;\n    return sign(n.z) * S * (S - A) * (S - B) * (S - C);\n}\nstruct bezier2{\n    vec2 start;\n    vec2 control1;\n    vec2 control2;\n    vec2 end;\n};\nfloat prod_e(vec3 v) {\n    return v.x * v.y * v.z;\n}\nfloat plotBezier(\n    bezier2 bezier,\n    vec2 p,\n    float tolerance,\n    float fade,\n    bool smoothedge,\n    bool cap,\n    bool smoothcap\n) {\n    vec2 n;\n    vec2 p0 = bezier.start;\n    vec2 p1 = intersect(\n        line2(bezier.start, bezier.control1),\n        line2(bezier.end, bezier.control2),\n        n);\n    vec2 p2 = bezier.end;\n    float t3 = triarea(p0, p1, p2);\n    vec3 t = vec3(\n        triarea(p, p1, p2),\n        triarea(p0, p, p2),\n        triarea(p0, p1, p)\n    ) / t3;\n    float l1 = 1.0 / n.x;\n    float l2 = 1.0 / n.y;\n    float a1 = 3.0 * (1.0 - l1);\n    float a2 = 3.0 * (1.0 - l2);\n    float b1 = 3.0 * l1;\n    float b2 = 3.0 * l2;\n    float A = -b1 * b1 * (b1 - b2 * a2);\n    float B = -b2 * b2 * (b2 - b1 * a1);\n    float C = -3.0 * b1 * b2 +\n        2.0 * b1 * b1 * a1 +\n        2.0 * b2 * b2 * a2 -\n        b1 * b2 * a1 * a2;\n    float D = a2 * (b1 - b2 * a2);\n    float E = a1 * (b2 - b1 * a1);\n    float F = 1.0 - a1 * a2;\n    float d = \n        A * t[0] * t[0] * t[2] +\n        B * t[0] * t[2] * t[2] +\n        C * t[0] * t[1] * t[2] +\n        D * t[0] * t[1] * t[1] +\n        E * t[1] * t[1] * t[2] +\n        F * t[1] * t[1] * t[1];\n    d = d / tolerance + 0.5;\n    float b = smoothedge ? smoothstep(0.0, 0.5, d) - smoothstep(0.5, 1.0, d) : step(0.0, d) - step(1.0, d);\n    return cap ? (smoothcap ? mix(0.0, b, prod_e(smoothstep(-fade, fade, t))) : b * prod_e(0.5 * (sign(t) + 1.0))) : b;\n}\nvec3 pixel(vec2 st) {\n    vec3 st3 = vec3(st, 0.0);\n    float rt = 1.0 * iTime * PI / 15.0;\n    st = mat2(cos(rt), sin(rt), -sin(rt), cos(rt)) * (st - 0.5) + 0.5;\n    float polar = length(st - 0.5);\n    vec3 color = vec3(st.x, st.y, 0.0);\n    \n    vec3 b = vec3(0.0);\n    mat3 t = mat3(\n        0.002,  0.00000, 0.000,\n        0.00000, -0.002, .000,\n        0.51,  0.555, 1.000\n    );\n    float ut;\n    vec2 str;\n    const int N = 7;\n    const float fN = float(N);\n    for(int i = 0; i < N; i++) {\n        ut = 1.0 + 2.0 * float(i) * PI / fN;\n        str = mat2(cos(ut), sin(ut), -sin(ut), cos(ut)) * (st - 0.5) + 0.5;\n    \tb += plotBezier(bezier2((t * vec3(-252.4,   27.4, 1.0)).xy, (t * vec3(-252.4, -107.7, 1.0)).xy, (t * vec3(-142.4, -217.2, 1.0)).xy, (t * vec3(  -6.6, -217.2, 1.0)).xy), str,  0.0005, 0.0001, true, false, true) * pow(polar * 2.0, 4.0);\n    }\n    \n    t = mat3(\n        0.00195,  0.00000, 0.000,\n        0.00000, -0.00195, .000,\n        0.05500,  0.87500, 1.000\n    );\n    bool smoothedge = true, cap = false, smoothcap = true;\n    b += color * plotBezier(bezier2((t * vec3(169.2, 421.3, 1.0)).xy, (t * vec3( 119.9, 406.4, 1.0)).xy, (t * vec3( 49.6, 375.8, 1.0)).xy, (t * vec3( 10.7, 284.5, 1.0)).xy), st,  0.005, 0.001, smoothedge, cap, smoothcap);// * pow(polar * 2.0, 4.0);\n    b += color * plotBezier(bezier2((t * vec3( 10.7, 284.5, 1.0)).xy, (t * vec3( -28.3, 193.1, 1.0)).xy, (t * vec3(  1.1,  96.1, 1.0)).xy, (t * vec3( 42.0,  48.8, 1.0)).xy), st,  0.002, 0.001, smoothedge, cap, smoothcap);// * pow(polar * 2.0, 4.0);\n    b += color * plotBezier(bezier2((t * vec3( 42.0,  48.8, 1.0)).xy, (t * vec3(  82.8,   1.6, 1.0)).xy, (t * vec3(127.5, -34.8, 1.0)).xy, (t * vec3(208.6, -41.2, 1.0)).xy), st,  0.005, 0.001, smoothedge, cap, smoothcap);// * pow(polar * 2.0, 4.0);\n    b += color * plotBezier(bezier2((t * vec3(208.6, -41.2, 1.0)).xy, (t * vec3( 289.7, -47.6, 1.0)).xy, (t * vec3(319.9,  -5.6, 1.0)).xy, (t * vec3(327.5,  63.4, 1.0)).xy), st,  0.002, 0.001, smoothedge, cap, smoothcap);\n    b += color * plotBezier(bezier2((t * vec3(327.5,  63.4, 1.0)).xy, (t * vec3( 337.9, 210.7, 1.0)).xy, (t * vec3(310.2, 349.2, 1.0)).xy, (t * vec3(212.2, 380.3, 1.0)).xy), st, 0.0005, 0.001, smoothedge, cap, smoothcap);\n    b += color * plotBezier(bezier2((t * vec3(212.2, 380.3, 1.0)).xy, (t * vec3( 244.0, 388.4, 1.0)).xy, (t * vec3(273.8, 388.1, 1.0)).xy, (t * vec3(295.4, 383.8, 1.0)).xy), st,  0.005, 0.001, smoothedge, cap, smoothcap);\n    b += color * plotBezier(bezier2((t * vec3(295.4, 383.8, 1.0)).xy, (t * vec3( 278.9, 401.8, 1.0)).xy, (t * vec3(252.0, 414.7, 1.0)).xy, (t * vec3(210.0, 428.1, 1.0)).xy), st,  0.005, 0.001, smoothedge, cap, smoothcap);\n    b += color * plotBezier(bezier2((t * vec3(210.0, 428.1, 1.0)).xy, (t * vec3( 293.6, 432.6, 1.0)).xy, (t * vec3(355.0, 398.8, 1.0)).xy, (t * vec3(390.0, 364.9, 1.0)).xy), st,  0.001, 0.001, smoothedge, cap, smoothcap);\n    b += color * plotBezier(bezier2((t * vec3(390.0, 364.9, 1.0)).xy, (t * vec3( 425.1, 331.1, 1.0)).xy, (t * vec3(484.3, 254.2, 1.0)).xy, (t * vec3(458.2, 137.8, 1.0)).xy), st,  0.001, 0.001, smoothedge, cap, smoothcap);\n    float r = 0.15, f = 0.005;\n    b += 1.0 - smoothstep(r - f, r + f, polar);\n\treturn b;// * (1.0 - smoothstep(0.5, 0.51, polar));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 rem = iResolution.xy - min(iResolution.x, iResolution.y);\n\t//vec2 st = (gl_FragCoord.xy * 2.0 - u_resolution) / min(u_resolution.x, u_resolution.y);\n    const int SAMPLES = 3;\n    const float fSAMPLES = float(SAMPLES);\n    float shifta = 1.0 / fSAMPLES, shiftb = 0.5 - 0.5 / fSAMPLES;\n\tvec2 st = gl_FragCoord.xy;\n    vec3 p = vec3(0.0);\n    for(int i = 0; i < SAMPLES; i++)\n        for(int j = 0; j < SAMPLES; j++)\n            p += pixel((st - rem * 0.5 + vec2(i, j) * shifta - shiftb) / min(iResolution.x, iResolution.y)) / (fSAMPLES * fSAMPLES);\n\tfragColor = vec4(vec3(p), 1.0);\n}","name":"Image","description":"","type":"image"}]}