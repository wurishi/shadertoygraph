{"ver":"0.1","info":{"id":"csGyzw","date":"1695925684","viewed":58,"name":"4x6 Shader Font","username":"cnlohr","description":"Another one of my tiny printf fonts.  See this for a much nicer (but heavier) font. https://www.shadertoy.com/view/stK3Rm\nOr, an even lighter one, here https://www.shadertoy.com/view/msVcRw","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["font","printf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Tiny Print Font, Public Domain 2023 Charles Lohr\n\n//  xx    xx   xxx   xxx     x   xxxx   xx   xxxx   xx    xx\n// x  x  x x      x     x   xx   x     x       x   x  x  x  x\n// x  x    x    xx    xx   x x   xxx   xxx    x     xx    xx        xxxx\n// x  x    x   x        x  xxxx     x  x  x   x    x  x     x        \n//  xx   xxxx  xxxx  xxx     x   xxx    xx    x     xx    xx    x   \n\nconst uint tppfont[] = uint[13]( \n    6595878u,   // 0 0b0011001001010010100100110\n    15863974u,  // 1 0b0111100100001000010100110\n    15767815u,  // 2 0b0111100001001100100000111\n    7608583u,   // 3 0b0011101000001100100000111\n    4691140u,   // 4 0b0010001111001010011000100\n    7609391u,   // 5 0b0011101000001110000101111\n    6593574u,   // 6 0b0011001001001110000100110\n    2164879u,   // 7 0b0001000010000100010001111\n    6592806u,   // 8 0b0011001001001100100100110\n    6560038u,   // 9 0b0011001000001100100100110\n    2097152u,   // . 0b0001000000000000000000000\n    15360u,     // - 0b0000000000011110000000000\n    0u          //   0b0000000000000000000000000\n);\n\n\nconst int ipow10[12] = int[12]( 1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000, 2147483647, 2147483647 );\n#define calc_ipow10(x) ipow10[x]\n\nfloat char4x5( int ch, vec2 uv )\n{\n    uvec2 pos = uvec2( fract(uv) * vec2( 5, 6 ) );\n    uint offset = pos.x + pos.y * 5u;\n    return float( ( tppfont[ch] >>  offset ) & 1u );\n}\n\n\n\nfloat print4x5int( int num, vec2 uv, int places )\n{\n    vec2 cuv = uv*vec2( places, 1. );\n    vec2 luv = cuv*vec2( 1, 1. );\n    ivec2 iuv = ivec2( luv );\n    int posi = int(iuv.x);\n    int marknegat = -1;\n    if( num < 0 )\n    {\n        marknegat = places-int(log(-float(num))/log(10.0))-2;\n    }\n    num = abs(num);\n    int nn = (num/calc_ipow10(places-posi-1));\n    if( posi == marknegat )\n        nn = 11;\n    else if( nn <= 0 && posi != places-1)\n        nn = 12;\n    else\n        nn %= 10;\n    int ch = nn;\n    return char4x5( ch, fract(cuv)*vec2(1.,1.) );\n}\n\n\n// Zero Leading Integer Print\nfloat print4x5intzl( int num, vec2 uv, int places )\n{\n    vec2 cuv = uv*vec2( places, 1. );\n    vec2 luv = cuv*vec2( 1, 1. );\n    ivec2 iuv = ivec2( luv );\n    int posi = int(iuv.x);\n    int nn = (num/calc_ipow10(places-posi-1));\n    nn %= 10;\n    int ch = nn;\n    return char4x5( ch, fract(cuv)*vec2(1.,1.) );\n}\n\nfloat print4x5float( float num, vec2 uv, int wholecount, int decimalcount )\n{\n    vec2 cuv = uv*vec2( wholecount+decimalcount+1, 1. );\n    vec2 luv = cuv*vec2( 1, 1 );\n    ivec2 iuv = ivec2( luv );\n    int posi = int(iuv.x);\n    int nn = 10;\n    \n    int marknegat = -1;\n    if( num < 0.0 )\n    {\n        marknegat = wholecount-2-int(log(-num)/log(10.0));\n    }\n    \n    num = abs(num);\n    num +=  pow(.1f,float(decimalcount))*.499;\n    int nv = int( num );\n    \n    if( posi < wholecount )\n    {\n        int wholediff = posi - wholecount+1;\n        float v = (pow( 10.0 , float(wholediff)));\n        int ni = int( float(nv) * v);\n        if( posi == marknegat ) nn = 11;\n        else if( ni <= 0 && wholediff != 0 ) nn = 12; //Blank out.\n        else         nn = ni%10;\n    }\n    else if( posi > wholecount )\n    {\n        num -= float(nv);\n        nn = int( num * pow( 10.0 , float(posi-wholecount)));\n        nn %= 10;\n    }\n    int ch = nn;\n\n    return char4x5( ch, fract(cuv)*vec2( 1, 1. ));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\t// Normalized pixel coordinates (from 0 to 1)\n\tvec2 uv = fragCoord/iResolution.xy;\n    uv.y = 1.0 - uv.y;\n    \n    uv.y*=12.0;\n\n    vec3 col = vec3( print4x5float( sin(iTime + max(0.9,uv.y)), fract( uv*vec2( 3.0, 1.0) ), 4, 5 ) );\n    if( uv.y > 8.0 )\n        col = vec3( print4x5int( -34, fract( uv*vec2( 3.0, 1.0 ) ), 10 ) );\n    else if( uv.y > 4.0 )\n        col = vec3( print4x5float( -3.14159, fract( uv*vec2( 3.0, 1.0) ), 4, 5 ) );\n\n\t// Output to screen\n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}