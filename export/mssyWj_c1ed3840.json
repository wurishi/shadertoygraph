{"ver":"0.1","info":{"id":"mssyWj","date":"1687218108","viewed":124,"name":"Argon Tinnitus Tetragrammaton","username":"Oneleven","description":"Use mouse. \nHold keys 1,2,3 for debug views\n\n\n","likes":16,"published":1,"flags":16,"usePreview":0,"tags":["raymarch","ruins"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//===============================================================================================================\n// \"Look, mum! I'm painting with maths!\"\n//  First somewhat serious, crude and goofy attempt at raymarching\n//  Wouldn't be possible without amazing tutorials by IQ, BitWings and without help from shadertoy discord community. \n//  Thank you everyone\n//===============================================================================================================\n\n//rayMarch\nconst int STEPS = 200;\nconst float MAX_DIST = 360.0;\nconst float EPSILON = 1e-4;\nconst float SHADOW = 2e-3;\n\nconst vec3 sunDir = normalize(vec3(0.3, 0.2, 0.6));\nconst vec3 SIZE = vec3(3.0, MAX_DIST * 2.0, 3.0); //cell size\nconst vec3 hSIZE = SIZE * 0.5;                    //half cell size\n\n//https://iquilezles.org/articles/distfunctions/\nfloat sdfBox(vec3 p, vec3 size, float sm)\n{\n    vec3 d = abs(p)-size + vec3(sm);\n    return length(max(d,vec3(0))) + min(max(max(d.x,d.y),d.z),0.0) - sm;\n}\n\n//https://iquilezles.org/articles/intersectors/\nvec2 boxIntersect(vec3 ro, vec3 rd, vec3 boxSize, vec3 m) \n{\n    vec3 outNormal;\n    vec3 n = m*ro;   // can't precompute due to domain repetition\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(MAX_DIST); // no intersection\n    outNormal = (tN>0.0) ? step(vec3(tN),t1): // ro ouside the box\n                           step(t2,vec3(tF));  // ro inside the box\n    outNormal *= -sign(rd);\n    return vec2( tN, tF );\n}\n\nvec3 domRep(vec3 p, vec3 c)\n{\n    return mod(p,c) - c / 2.0;\n}\n\nvec3 domRepCell(vec3 p)\n{\n    return domRep(p, SIZE);\n}\n\nvec3 domRepCell2D(vec3 p)\n{\n    p.xz=domRepCell(p).xz;\n    return p;\n}\n\nvec2 getRay(vec3 p) //get distance and material id\n{\n    float id = noise(floor(p.xz/SIZE.xz), 0.4); // get cell id\n    float edge = 0.45; //cutoff between different objects\n\n    //material 1\n    float plane1 = p.y;\n    float m1 = plane1;\n    \n    float m2 = MAX_DIST, m3 = MAX_DIST;\n    if (id > edge) \n    {\n    //material 2 \n        \n        float id1 = smoothstep(edge, 1.0, id); //normalize id\n        float id_rot = hash11(id1);\n        mat2 rot = rot2D(id_rot*0.2 - 0.1);\n        \n        vec3 s1; s1.y = id1*3.0 + 1.0; s1.xz = vec2(0.6);                \n        vec3 p1 = domRepCell2D(p);\n        p1.xy*=rot; p1.x-=id_rot; //there is definetely better way to do these rotations, but i'm to lazy\n        p1.y -=s1.y;\n        p1.yz*=-rot; p1.y+=id_rot;\n\n        float box1 = sdfBox(p1, s1, 0.05);\n        \n        float id2 = floor(id1 * 10.0) + 3.0;\n\n        vec3 c2 = SIZE; c2.y = id2*0.04; c2.x/=id2;\n        vec3 p2 = domRep(p, c2);\n        p2.xy*=rot;\n        p2.yz*=-rot;\n        float box2 = sdfBox(p2, c2*0.3, 0.0);\n        \n        vec3 c3 = SIZE; c3.y = id2*0.04; c3.z/=id2;\n        vec3 p3 = domRep(p, c3);\n        p3.xy*=rot;\n        p3.yz*=-rot;\n        float box3 = sdfBox(p3, c3*0.3, 0.0);\n        \n        m2 = min(box2, box3);\n        m2 = max(box1,-m2);\n    }\n    else\n    {\n    //material 3\n        float id1 = smoothstep(0., edge, id); //normalize id\n        float id_rot = hash11(id1);\n        mat2 rot = rot2D(id_rot*0.4 - 0.2);\n        \n        vec3 s1; s1.y = 1.0; s1.xz = vec2(0.1);\n        vec3 p1 = domRepCell2D(p);\n        p1.xy*=rot; p1.x-=id_rot;\n        p1.y -=s1.y-id_rot;\n        p1.yz*=-rot; p1.y+=id_rot;\n        float box1 = sdfBox(p1, s1, 0.05);\n        \n        vec3 s2; s2.x = 0.5; s2.yz = vec2(0.1);\n        vec3 p2 = domRepCell2D(p);\n        p2.xy*=rot; p2.x-=id_rot;\n        p2.y -=1.5-id_rot;\n        p2.yz*=-rot; p2.y+=id_rot;\n        float box2 = sdfBox(p2, s2, 0.05);\n        \n        m3 = min(box1,box2);\n    } \n    \n    /* unused. debug objects for world origin and grid borders\n    vec3 dSize = vec3(0.1, 8.0, 0.1);\n    float debugBox0 = sdfBox(p, dSize, 0.05);\n    float debugBox1 = sdfBox(p + vec3(SIZE.x,0,0), dSize, 0.05);\n    float debugBox2 = sdfBox(p + vec3(0,0,SIZE.z), dSize, 0.05);\n    float debugBox3 = sdfBox(p + vec3(SIZE.x,0,SIZE.z), dSize, 0.05);\n    float m4 = min(debugBox0,debugBox1); m4 = min(m4, debugBox2); m4 = min(m4, debugBox3);\n    */\n    \n    //final dist and mat\n    float dist = min(min(m1, m2),m3);\n    //dist = m3;\n    \n    float m = 0.;\n    if (dist == m1) m = 1.;\n    if (dist == m2) m = 2.;\n    if (dist == m3) m = 3.;\n\n    return vec2(dist, m);\n}\n\n\nvec4 rayMarch(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    float m = 0.0;\n    int i = 0;\n    float minDelta = 100.0;\n    \n    vec3 mBox = 1.0/rd; //precompute constant for box intersect\n    \n    for (i; i < STEPS; i++)\n    {\n        vec3 p = ro + rd * t;\n        vec2 d = getRay(p);\n        m = d.y;\n        float b = boxIntersect(domRepCell(p), rd, vec3(hSIZE), mBox).y; \n        d = min(d, b + EPSILON);\n        minDelta = min(minDelta, d.x);\n        t += d.x;\n        if ((d.x < EPSILON) || (abs(t) > MAX_DIST)) break;\n    }\n    \n    return vec4(t, m, i, minDelta); //distance, material index, steps count, closest distance\n}\n\n//https://iquilezles.org/articles/rmshadows/\nfloat softShadow(vec3 ro, vec3 rd, float w)\n{\n    float res = 1.0;\n    float t = EPSILON;\n    for(int i=0; i<STEPS && t<MAX_DIST; i++ )\n    {\n        vec2 h = getRay(ro + t*rd);\n        res = min( res, h.x/(w*t) );\n        t += clamp(h.x, 0.005, 0.50);\n        if( res<-1.0 || abs(t)>MAX_DIST ) break;\n    }\n    res = max(res,-1.0);\n    return 0.25*(1.0+res)*(1.0+res)*(2.0-res);\n}\n\n//https://iquilezles.org/articles/normalsSDF/\nvec3 getNormal(vec3 p) \n{\n    const float h = 1e-2;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*getRay( p + k.xyy*h ).x + \n                      k.yyx*getRay( p + k.yyx*h ).x + \n                      k.yxy*getRay( p + k.yxy*h ).x + \n                      k.xxx*getRay( p + k.xxx*h ).x );\n}\n\nfloat directionalLight(vec3 p, vec3 lightDir, vec3 n)\n{\n    return clamp(dot(lightDir, n), 0.0, 1.0);\n}\n\nfloat directionalLightShad(vec3 p, vec3 lightDir, vec3 n)\n{\n    return directionalLight(p, lightDir, n) * softShadow(p, lightDir, SHADOW);\n}\n\nvec3 heatMap(float x)\n{\n    vec3 col = vec3(x);\n    col.r = smoothstep(0.6, 1.0, x);\n    col.g = pow(x,2.0)-smoothstep(0.87,0.97,x);\n    col.b = pow(1.0 - x, 2.0) - max(col.r,col.g);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5)/iResolution.y;\n    \n    //camera tutorial by BigWIngs (ArtOfCode)\n    //https://www.youtube.com/watch?v=PBxuVlp7nuM&t=130s  \n    vec3 ro = vec3(sin(iTime*0.05)*10.,8.0,cos(iTime*0.05)*10.);\n    vec3 lp = vec3(0,0,-1);\n    \n    //also camera controls taken from Gelami's\n    //Hybrid SDF-Voxel Traversal\n    //https://www.shadertoy.com/view/dtVSzw\n    vec2 cam;\n    if (iMouse.xy==vec2(0)) cam = vec2(-0.05,-0.4);\n    else                    cam = iMouse.xy/iResolution.xy;\n    \n    float ax = cam.x * TAU + PI;\n    float ay = -cam.y * PI + PI * 0.5;\n    lp.yz *= rot2D(ay);\n    lp.xz *= rot2D(ax);\n    lp += ro;\n    \n    vec3 f = normalize(lp - ro);\n    vec3 r = normalize(cross(vec3(0., 1., 0.), f));\n    vec3 u = cross(f, r);\n    vec3 rd = normalize(f + r * uv.x + u * uv.y);\n    \n    vec4 ray = rayMarch(ro, rd); \n    \n    vec3 col = vec3(0.0);\n    float sun = dot(rd, sunDir)*0.5 + 0.5;\n    vec3 refl = vec3(0);\n    float shad = 0.;\n    vec3 n;\n    vec3 bg = mix(vec3(-0.3,0.55,2.0), vec3(2.0,2.0,2.0), sun);\n    \n    float sun2 = smoothstep(0.994, 0.995, sun);\n    bg = mix(bg, vec3(1.0,0.0,0.0), sun2);\n    vec3 p = ro + rd * ray.x;\n    \n    if (ray.x>=MAX_DIST) col = bg;\n    else\n    {\n        n = getNormal(p);\n        \n        col = directionalLight(p, sunDir, n) * vec3(1.0);\n        \n        shad = softShadow(p, sunDir, SHADOW);\n        refl = texture(iChannel2,reflect(rd, n)).rgb * max(1.0-dot(-rd,n),0.);\n    }\n    \n    if (ray.y == 1.) //ground\n    {\n        float grC = smoothstep(0.0,1.0,noise(p.xz, 0.1)); \n        col = mix(vec3(0.2,0.0,0.0),vec3(1,0,0),grC);\n    }\n    if (ray.y == 2.) //buildings\n    {\n        col*=vec3(1.0,0.0,0.00);\n        col += refl*vec3(0.9,0,0);\n        \n    }\n    if (ray.y == 3.) col*=vec3(1.0); //\"not buildings\"\n    \n    col*=mix(vec3(0.3,0.15,1.2),vec3(1),shad); //shadow color\n    \n    //fog\n    float fogAmount = smoothstep(10., MAX_DIST, ray.x);\n    vec3  fogColor  = bg;\n    col = mix(col, fogColor, fogAmount );\n    \n    //debug\n    if (keyDown(KEY_1)) col = heatMap(ray.z / float(STEPS)); //raymarch steps\n    if (keyDown(KEY_2)) col = vec3(1.0 - ray.x/MAX_DIST);    //depth\n    if (keyDown(KEY_3)) col = vec3(ray.a*MAX_DIST);          //min distance\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//https://www.shadertoy.com/view/llySRh\n//iResolution, iMouse, iDate, etc by FabriceNeyret2\n\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\nconst int KEY_1 = 49;\nconst int KEY_2 = 50;\nconst int KEY_3 = 51;\nconst int KEY_4 = 52;\n\nconst float PI = 3.141592;\nconst float TAU = 6.283185;\n\nmat2 rot2D(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\n//Hash without Sine by Dave_Hoskins \n//https://www.shadertoy.com/view/4djSRW\nfloat hash21(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat noise(vec2 uv, float scale)\n{\n    uv*=scale;\n    vec2 index = floor(uv);\n    uv = fract(uv);\n    \n    float x1=mix(hash21(index), hash21(index+vec2(1,0)), uv.x);\n    float x2=mix(hash21(index + vec2(0,1)), hash21(index+vec2(1,1)), uv.x);\n    return mix(x1,x2,uv.y);\n}","name":"Common","description":"","type":"common"}]}