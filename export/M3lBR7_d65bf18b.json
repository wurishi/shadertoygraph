{"ver":"0.1","info":{"id":"M3lBR7","date":"1728216988","viewed":46,"name":"breathing planet","username":"davidullmann271","description":"paint like texture, warping, recursive randomness","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["fractal","noise","warp","recursion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float hash(float n) { return fract(sin(n) * 43758.5453123); }\n\nfloat noise(vec2 x){\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    float a = hash(p.x + p.y * 57.0);\n    float b = hash(p.x + 1.0 + p.y * 57.0);\n    float c = hash(p.x + (p.y + 1.0) * 57.0);\n    float d = hash(p.x + 1.0 + (p.y + 1.0) * 57.0);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(a, b, u.x) +\n           (c - a) * u.y * (1.0 - u.x) +\n           (d - b) * u.x * u.y;\n}\n\nfloat highAmpNoise(vec2 x) {\n    return noise(x) * 2.0; \n}\n\nfloat fbm(vec2 x) {\n    float v = 0.0;\n    float a = 0.5;\n    float angle = 0.5 + iTime * 0.001; \n    mat2 rot = mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\n    for (int i = 0; i < 8; ++i) {\n        v += a * highAmpNoise(x);\n        x = rot * x * 2.0;\n        a *= 0.5;\n    }\n    return v;\n}\n\nfloat domainWarping(vec2 p) {\n    float t = iTime * 0.0001;  \n    float timeStep = noise(vec2(iTime*0.0001, 0.0));\n    float myNoiseValue = noise(vec2(timeStep, 0.0));\n    float mxNoiseValue = noise(vec2(timeStep, 100.0));\n    float my = mix(0.5, 2.0, myNoiseValue);\n    float mx = mix(1.0, 100.0, mxNoiseValue);\n\n    vec2 highAmpWarp = vec2(\n        highAmpNoise(p * 0.1 * my + t),\n        highAmpNoise(p * 0.1 * my + t + 10.0 * mx)\n    );\n\n    vec2 q = vec2(fbm(p + highAmpWarp + vec2(0.0, 0.0)),\n                  fbm(p + highAmpWarp + vec2(5.2, 1.3)));\n    vec2 r = vec2(fbm(p + 3.0 * q + vec2(1.7, 9.2 + t)),\n                  fbm(p + 3.0 * q + vec2(8.3 + t, 2.8)));\n    vec2 s = vec2(fbm(p + 3.0 * r + vec2(3.4, 7.1 + t)),\n                  fbm(p + 3.0 * r + vec2(5.6 + t, 1.2)));\n    return fbm(0.4 * p + 0.4 * s);\n}\n\nvec3 hexToRgb(int hexValue) {\n    return vec3(\n        float((hexValue >> 16) & 0xFF) / 255.0,\n        float((hexValue >> 8) & 0xFF) / 255.0,\n        float(hexValue & 0xFF) / 255.0\n    );\n}\n\nvec3 palette(float t) {\n    t = fract(t + sin(t * 123.456) * 0.05);\n    t = clamp(t, 0.0, 1.0);\n\n    int hexColors[5] = int[5](\n        0x2C3531, // #2C3531\n        0x116466, // #116466\n        0xD9B08C, // #D9B08C\n        0xFFCB9A, // #FFCB9A\n        0xD1E8E2  // #D1E8E2\n    );\n\n    vec3 colors[5];\n    for (int i = 0; i < 5; i++) {\n        colors[i] = hexToRgb(hexColors[i]);\n        colors[i] = mix(vec3(0.5), colors[i] * 0.9, 1.2);\n    }\n    float thresholds[15] = float[15](\n        0.07, 0.15, 0.22, 0.28, 0.35, 0.42, 0.48, 0.55, 0.62, 0.68, 0.75, 0.82, 0.88, 0.95, 1.0\n    );\n\n    if (t < thresholds[0]) {\n        return mix(colors[0], colors[1], t / thresholds[0]);\n    } else if (t < thresholds[1]) {\n        return mix(colors[1], colors[2], (t - thresholds[0]) / (thresholds[1] - thresholds[0]));\n    } else if (t < thresholds[2]) {\n        return mix(colors[2], colors[3], (t - thresholds[1]) / (thresholds[2] - thresholds[1]));\n    } else if (t < thresholds[3]) {\n        return mix(colors[3], colors[4], (t - thresholds[2]) / (thresholds[3] - thresholds[2]));\n    } else if (t < thresholds[4]) {\n        return mix(colors[4], colors[0], (t - thresholds[3]) / (thresholds[4] - thresholds[3]));\n    } else if (t < thresholds[5]) {\n        return mix(colors[0], colors[1], (t - thresholds[4]) / (thresholds[5] - thresholds[4]));\n    } else if (t < thresholds[6]) {\n        return mix(colors[1], colors[2], (t - thresholds[5]) / (thresholds[6] - thresholds[5]));\n    } else if (t < thresholds[7]) {\n        return mix(colors[2], colors[3], (t - thresholds[6]) / (thresholds[7] - thresholds[6]));\n    } else if (t < thresholds[8]) {\n        return mix(colors[3], colors[4], (t - thresholds[7]) / (thresholds[8] - thresholds[7]));\n    } else if (t < thresholds[9]) {\n        return mix(colors[4], colors[0], (t - thresholds[8]) / (thresholds[9] - thresholds[8]));\n    } else if (t < thresholds[10]) {\n        return mix(colors[0], colors[1], (t - thresholds[9]) / (thresholds[10] - thresholds[9]));\n    } else if (t < thresholds[11]) {\n        return mix(colors[1], colors[2], (t - thresholds[10]) / (thresholds[11] - thresholds[10]));\n    } else if (t < thresholds[12]) {\n        return mix(colors[2], colors[3], (t - thresholds[11]) / (thresholds[12] - thresholds[11]));\n    } else if (t < thresholds[13]) {\n        return mix(colors[3], colors[4], (t - thresholds[12]) / (thresholds[13] - thresholds[12]));\n    } else {\n        return mix(colors[4], colors[0], (t - thresholds[13]) / (thresholds[14] - thresholds[13]));\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    float n = domainWarping(uv * 2.0);\n    vec3 color = palette(n);\n    fragColor = vec4(color, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}