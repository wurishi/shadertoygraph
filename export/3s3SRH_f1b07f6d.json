{"ver":"0.1","info":{"id":"3s3SRH","date":"1571390152","viewed":289,"name":"noise_experiment_2","username":"skaplun","description":"It's quite heavy now, can't figure out how to improve performance. Any suggestions?","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","voronoi","noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_FLOAT 1e5\n#define MIN_FLOAT 1e-5\n#define ANIMATE\n\nconst vec3 ORANGE = vec3(158., 64., 1.)/255.;\nconst vec3 GRAY = vec3(47., 76., 108.)/750.;\n\nvec2 hash2( vec2 p ){\n\treturn textureLod( iChannel0, (p+0.5)/256.0, 0.0 ).xy;\n}\n\nfloat smin( float a, float b, float k ){\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat voronoi( in vec2 x, float seed )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mg, mr;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g + seed);\n\t\t#ifdef ANIMATE\n        o = 0.5 + 0.5*sin( iTime + 6.2831*o );\n        #endif\t\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g + seed);\n\t\t#ifdef ANIMATE\n        o = 0.5 + 0.5*sin( iTime + 6.2831*o );\n        #endif\t\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>0.00001 )\n        md = smin( md, dot( 0.5*(mr+r), normalize(r-mr) ), .25 );\n    }\n\n    return md;\n}\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\nvec2 map(vec3 p){\n    if (p.y > .1){\n    \tfloat noiseVal = voronoi(p.xz * 1.5 + vec2(0., sin(p.x) * 1.2), .17);\n        return vec2(opSubtraction(.15 - p.y, noiseVal - .02), 2.);\n    }\n    \n    if (p.y > .05){\n        float noiseVal = voronoi(p.xz * .5 + vec2(0., fbm1x(p.x, 1.) * .25), .71);\n        return vec2(opSubtraction(.1 - p.y, noiseVal - .015), 1.);\n    }\n    \n    return vec2(0., 0.);\n}\n\nconst float epsilon = 0.01;\nvec3 calculateNormals(vec3 pos){\n    vec2 eps = vec2(0.0, epsilon);\n    vec3 n = normalize(vec3(\n    map(pos + eps.yxx).x - map(pos - eps.yxx).x,\n    map(pos + eps.xyx).x - map(pos - eps.xyx).x,\n    map(pos + eps.xxy).x - map(pos - eps.xxy).x));\n    return n;\n}\n\n//by @iq\nconst float maxHei = .2;\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (maxHei-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for(int i=0; i<12; i++){\n        float h = map( ro + rd*t ).x;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n//by @iq\nfloat calcAO( in vec3 pos, in vec3 nor ){\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<6; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\nvec3 calcColor(Ray r, vec3 nor, vec3 p, vec3 albedo, float t){\n\tvec3 ref = reflect( r.dir, nor );\n    // lighting\n    float occ = calcAO( p, nor );\n    vec3  lig = normalize( vec3(3., 2.4, -1.6) );\n    vec3  hal = normalize( lig-r.dir );\n    float amb = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n    float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-p.y,0.0,1.0);\n    float dom = smoothstep( -.1, 0.4, ref.y );\n    float fre = pow( clamp(1.0+dot(nor,r.dir),0.0,1.0), 2.0 );\n\n    dif *= calcSoftshadow( p, lig, 0.02, 2.5 );\n    dom *= calcSoftshadow( p, ref, 0.02, 2.5 );\n\n    float spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ), 8.0)*\n        dif * (.001 + .96*pow( clamp(1.0+dot(hal,r.dir),0.0,1.0), 5.0 ));\n\n    vec3 lin = vec3(0.0);\n    lin += 3.80*dif*vec3(1.30,1.00,0.70);\n    lin += 0.55*amb*vec3(0.40,0.60,1.15)*occ;\n    lin += 0.85*dom*vec3(0.40,0.60,1.30)*occ;\n    lin += 0.55*bac*vec3(0.25,0.25,0.25)*occ;\n    lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n    vec3 col = albedo * lin;\n    col += 7.00*spe*vec3(1.10,0.90,0.70);\n\n    col = mix( col, vec3(0.7,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );\n    return clamp(col, 0., 1.);\n}\n\nconst int stepsCnt = 50;\nvec3 clrInside(in float minD, in float maxD, in Ray r){\n    float stepSize = (maxD - minD)/float(stepsCnt);\n    float t = minD + MIN_FLOAT;\n    for(int i = 0; i <= stepsCnt; i++){\n        vec3 p = r.origin + r.dir * t;\n        vec2 dst = map(p);\n        \n        if(dst.x < stepSize){\n            vec3 nor = calculateNormals(p);\n            vec3 albedo = vec3(0.);\n            switch(int(dst.y)){\n            \tcase 0:\n                \talbedo = mix(GRAY * .85, GRAY, pattern(p.xz * 250.));\n                \tbreak;\n                case 1:\n                \talbedo = mix(ORANGE * 10., GRAY, step(epsilon, dot(nor, vec3(0., 1., 0.))));\n                \tbreak;\n                case 2:\n                \talbedo = mix(ORANGE, GRAY, step(epsilon, dot(nor, vec3(0., -1., 0.))));\n                \tbreak;\n                default:\n                    break;\n            }\n            return calcColor(r, nor, p, albedo, t);\n        }\n        \n        t += stepSize;\n        if(t > maxD)\n            break;\n    }\n    return vec3(0.);\n}\n\nvec3 makeClr(vec2 fragCoord){\n    vec3 viewDir = rayDirection(60., iResolution.xy, fragCoord);\n    float ang = (iResolution.y - iMouse.y) * .01 / 3.1415;\n    vec3 origin = vec3(0., 3. * cos(ang), 3. * sin(ang));\n    mat4 viewToWorld = viewMatrix(origin, vec3(0.), vec3(0., 1., 0.));\n    vec3 dir = (viewToWorld * vec4(viewDir, 1.0)).xyz;\n    \n    Ray camRay = Ray(origin, dir);\n    \n    float minDst, maxDst;\n    plane_hit(camRay, Plane(vec3(0., .151, 0.), vec3(0., -1., 0.)), minDst);\n    plane_hit(camRay, Plane(vec3(0., -.001, 0.), vec3(0., -1., 0.)), maxDst);\n    return clrInside(minDst, maxDst, camRay);\n}\n\n#define AA 1\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    fragColor = vec4(0.);\n    for(int y = 0; y < AA; ++y)\n        for(int x = 0; x < AA; ++x){\n            fragColor.rgb += clamp(makeClr(fragCoord + vec2(x, y) / float(AA)), 0., 1.);\n        }\n    \n    fragColor.rgb /= float(AA * AA);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"struct Box{ vec3 origin; vec3 bounds;};\nstruct Ray{ vec3 origin, dir;};\nstruct HitRecord{vec2 dist;vec3 ptnt[2];};\nstruct Plane{ vec3 origin; vec3 normal;};\n\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.;\n    float z = size.y / tan(radians(fieldOfView) / 2.);\n    return normalize(vec3(xy, -z));\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye),\n         s = normalize(cross(f, up)),\n         u = cross(s, f);\n    return mat4(vec4(s, 0.), vec4(u, 0.), vec4(-f, 0.), vec4(vec3(0.), 1.));\n}\n\nmat3 calcLookAtMatrix(in vec3 camPosition, in vec3 camTarget, in float roll) {\n  vec3 ww = normalize(camTarget - camPosition);\n  vec3 uu = normalize(cross(ww, vec3(sin(roll), cos(roll), 0.0)));\n  vec3 vv = normalize(cross(uu, ww));\n\n  return mat3(uu, vv, ww);\n}\n\nbool plane_hit(in Ray inray, in Plane plane, out float dst) {\n    float denom = dot(plane.normal, inray.dir);\n    if (denom > 1e-6) {\n        vec3 p0l0 = plane.origin - inray.origin;\n        dst = dot(p0l0, plane.normal) / denom;\n        return true;\n    }\n    return false;\n}\n\nfloat fbm1x(float x, float time){\n\tfloat amplitude = 1.;\n    float frequency = 1.;\n    float y = sin(x * frequency);\n    float t = 0.01*(-time * 130.0);\n    y += sin(x*frequency*2.1 + t)*4.5;\n    y += sin(x*frequency*1.72 + t*1.121)*4.0;\n    y += sin(x*frequency*2.221 + t*0.437)*5.0;\n    y += sin(x*frequency*3.1122+ t*4.269)*2.5;\n    y *= amplitude*0.06;\n    return y;\n}\n\nfloat pattern(vec2 p){\n\tp.x *= sign(cos(length(ceil(p /= 50.))*99.));\n    return cos(min(length(p = fract(p)), length(--p))*44.);\n}","name":"Common","description":"","type":"common"}]}