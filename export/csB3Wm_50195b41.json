{"ver":"0.1","info":{"id":"csB3Wm","date":"1667673503","viewed":86,"name":"Dashed parabola segment","username":"Envy24","description":"Red dashes moves forward, not backward.\nTry to change speed with mouse.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["arclength","dashes","reparametrization","stroboscopiceffect"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                         ( iResolution )\n#define AR                        ( R.x / R.y )                      // Aspect ratio.\n#define UNIT                      ( 8.0 / R.y )                      // Affects AA and thickness\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n#define SMAA_(x, unit)            ( smoothstep(unit, 0., x) )\n#define SCENE_SCALE               ( 1.2 )\n\nfloat vertical_line(vec2 NDC, float x0) { return SMAA(abs(NDC.x-x0)); }\nfloat horizontal_line(vec2 NDC, float y0) { return SMAA(abs(NDC.y-y0)); }\nfloat y_axis(vec2 NDC) { return SMAA(abs(NDC.x)); }\nfloat x_axis(vec2 NDC) { return SMAA(abs(NDC.y)); }\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - R.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse)\n{\n    vec2 M = MOUSE_OFFSET * (mouse == true ? 1. : 0.);\n    return ((2. * (SC - M) - R.xy) / R.y) * scale - origin;\n}\n\nvec2 parametric(float t) { return vec2(t, t*t-1.); }\nfloat arclength(float t) { return asinh(2.*t)*0.25 + t*sqrt(4.*t*t+1.)*0.5; }\nfloat arclength(float t0, float t1) { return arclength(t1) - arclength(t0); }\n\n// Bisection method for finding t relative to s (inverse arclength)\nfloat invArclength(float s, float t_min, float t_max)\n{\n    const float tolerance = 1e-7; /* Desired precision */\n    float T[2] = float[2](t_min-.001, t_max);\n    float F[2] = float[2](\n        arclength(T[0]),\n        arclength(T[1]));\n    \n    float l = 0.5;\n    \n    for (int i = 0; (i < 64) && (abs(l-s) > tolerance); ++i)\n    {\n        // Make step of bisection method.\n        float t = (T[0] + T[1]) * 0.5;\n              l = arclength(t);\n\n        int w_idx = int(l>s);\n        \n        F[w_idx] = l; T[w_idx] = t;\n    }\n\n    return (T[0] + T[1])*0.5;\n}\n\n// https://www.shadertoy.com/view/NtVfWG\nfloat parametric_sdf(\n    in vec2 NDC,\n    in vec2 from, // NDC.x range\n    in vec2 to,   // t range\n    in float count)\n{\n    float dt = (from.y - from.x) / (count - 1.);\n    \n    float minimal_distance = 99.;\n    vec2 B = parametric(linear_remap(from.x, from.x, from.y, to.x, to.y));\n      \n    for (float i = 1.; i < count; i += 1.)\n    {\n        float t = linear_remap(from.x + dt * i, from.x, from.y, to.x, to.y);\n    \n        vec2 E = parametric(t);\n        minimal_distance = \n            min(minimal_distance, segmentSDF_L2(NDC, B, E, 0.));\n        B = E;\n    }\n    \n    return minimal_distance;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, vec2(0, 0.5), false);\n\n    vec3 color = vec3(1.);\n         color -= x_axis(NDC); color -= y_axis(NDC);\n//                                                  Stroboscopic effect\n#define SPEED ( iMouse.z > 0. ? iMouse.y/R.y*4. : 3.10 )\n    /* Point path (should restart every 10 seconds if SPEED is 0.1). */\n    float len = arclength(1.);\n    float s = fract(iTime*SPEED)*2.*len-len;\n    float t = invArclength(s, -1., 1.);\n    color = mix(color, vec3(1,0,1), SMAA(diskSDF_L2(NDC, parametric(t), UNIT)) );\n\n    /* Dashes. */     \n    float count = 20. * 2., ds = (2.*len) / (count-2.);\n    for (float i = 1.; i < count; i += 2.)\n    {\n        //s = -len + i*ds; // static\n        s = -len + mod(iTime*len*SPEED*2.+i*ds, 2.*len);\n        t = invArclength(s, -1., 1.);\n\n        float sp = s - ds;\n        float tp = invArclength(sp, -1., 1.);\n        color = mix(color, vec3(1,0,0), SMAA(segmentSDF_L2(NDC, parametric(tp), parametric(t), 0.)) );\n    }\n    /**/\n\n    /* Cells */\n#define CELL_SIZE 1\n         NDC = mod(NDC, vec2(CELL_SIZE)); \n         color -= vertical_line(NDC, 0.)*.2;  color -= horizontal_line(NDC, 0.)*.2; // comment this line if you not use mod\n         color -= vertical_line(NDC, -1.)*.2; color -= horizontal_line(NDC, -1.)*.2;         \n         color -= vertical_line(NDC, 1.)*.2;  color -= horizontal_line(NDC, 1.)*.2; \n    /* */ \n        \n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nfloat linear_remap(\n    float val,\n    float fl,\n    float fr,\n    float tl,\n    float tr)\n{\n    val = (val - fl) / (fr - fl); // inverse linear map from [fl; fr] to [0; 1].\n    return val * (tr - tl) + tl;  // linear map from [0; 1] to [tl; tr].\n}\n\nfloat diskSDF_L2(vec2 NDC, vec2 C, float R) { return length(C - NDC)-R; }\n\nfloat segmentSDF_L2(in vec2 NDC, in vec2 B, in vec2 E, in float R)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - R;\n}","name":"Common","description":"","type":"common"}]}