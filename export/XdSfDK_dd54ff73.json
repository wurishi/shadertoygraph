{"ver":"0.1","info":{"id":"XdSfDK","date":"1502131997","viewed":84,"name":"MB","username":"mickname","description":"A pretty naive mandelbrot implementation","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["fraccal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MB_ITERS 120\n\n#define PSIZE 5\nvec3[] palette = vec3[] (\n    vec3(1.0, 1.0, 1.0),\n\tvec3(0.9, 0.2, 0.2),\n    vec3(0.5, 0.6, 0.1),\n    vec3(0.1, 0.4, 0.5),\n    vec3(0.0, 0.0, 0.0)\n);\n\n/* Single mandelbrot iteration */\nvec2 mb_iter(vec2 z, vec2 c) {\n    return vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;\n}\n\n/* Check if complex number c is in the mandelbrot se. ret.z = 0.0 If maybe,\n   otherwise the number of iterations for certain escaping. ret.xy = the\n   value of z at escape */\nvec3 mb_test_escape(vec2 c) {\n    vec2 z = vec2(0.0);\n    for (int i = 0; i < MB_ITERS; i++) {\n    \tz = mb_iter(z, c);\n        \n        if (length(z) > 2.0) {\n        \treturn vec3(z, i + 1);\n        }\n    }\n    return vec3(0.0);\n}\n\nfloat mb_normalized_iters(float count, vec2 z) {\n\treturn count - log(log(length(z))) / log(2.0);\n}\n\nmat3 make_trans(float x, float y) {\n\treturn mat3(\n    \tvec3(1.0, 0.0, 0.0),\n        vec3(0.0, 1.0, 0.0),\n        vec3(x,   y,   1.0)\n    );\n}\n\nmat3 make_rot(float a) {\n\treturn mat3(\n    \tvec3(cos(a),  sin(a), 0.0),\n        vec3(-sin(a), cos(a), 0.0),\n        vec3(0.0,     0.0,    1.0)\n    );   \n}\n\nmat3 make_viewport_tform(vec2 poi) {\n    float scale_init = 0.02;\n\n    float scale = scale_init * pow(0.5, 0.5 * iTime);\n    \n    float a = (2.0 * 3.14159) * 0.05 * iTime;\n    \n    mat3 R = make_rot(a);\n    \n    mat3 S = mat3(\n    \tvec3(scale, 0.0,   0.0),\n        vec3(0.0,   scale, 0.0),\n        vec3(0.0,   0.0,   1.0)\n    );\n    \n    mat3 T_cent = make_trans(-0.5 * iResolution.x, -0.5 * iResolution.y);\n    \n    mat3 T_poi = make_trans(poi.x, poi.y);\n    \n    \n    //mat3 T2 = make_trans(0.5 * viewport_w, 0.5 * viewport_h);\n    \n\n    \n    return T_poi * R * S * T_cent;\n}\n\nvec3 shade(float count) {\n    count = min(float(MB_ITERS), count);\n    float p = clamp(count / float(MB_ITERS), 0.0, 1.0);\n    \n    int idx = int(p * float((PSIZE - 1)));\n    \n    float a = p * float(PSIZE - 1) - float(idx);\n    \n    vec3 color = mix(palette[idx], palette[idx + 1], a);\n        \n    return color;\n}\n\nvec3 sample_xy(vec2 pos) {\n    // Point of interest\n    vec2 poi = vec2(-0.746335, 0.1102);\n    \n    mat3 vp_tform = make_viewport_tform(poi);\n    \n    // Fragment position on complex plane\n    vec2 c = (vp_tform * vec3(pos, 1.0)).xy;\n    \n    vec3 escape = mb_test_escape(c);\n\n   \treturn shade(mb_normalized_iters(escape.z, escape.xy));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec3 c = 0.25 * (\n        sample_xy(fragCoord.xy + vec2(-0.25, -0.25)) +\n        sample_xy(fragCoord.xy + vec2( 0.25, -0.25)) +\n        sample_xy(fragCoord.xy + vec2(-0.25,  0.25)) +\n        sample_xy(fragCoord.xy + vec2( 0.25, -0.25 ))\n    );\n    \n    fragColor = vec4(c, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}