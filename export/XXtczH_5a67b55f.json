{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// conf\n#define COLOR_MODE 2\n#define MOVE_MODE 1\n#define PULSE_MODE 1\n\n#define INVERT_RATE (3.5)\n#define COLORSHIFT_INTENSITY (0.5/15.)\n\n// const\n#define PI (3.14159)\n\n// code\nvec4 mainImage2(in vec2 uv, float dotCount, float dotSize, float nGroups, float gID) {\n    // Scale uv by dotCount to get a denser or sparser grid:\n    vec2 scaledUV = uv * dotCount;\n\n    // Find the nearest integer lattice point:\n    vec2 cell = floor(scaledUV + 0.5); \n    // Convert cell back to world coordinates for the dot position:\n    vec2 dotPos = (cell / dotCount);\n\n    // If desired, use grouping logic to show/hide certain dots.\n    // For example, only draw a dot if (cell.x + cell.y) mod nGroups == gID.\n    float cellIndex = mod((cell.x + cell.y), nGroups);\n    if (cellIndex != gID) return vec4(0.0);\n\n    // Compute the distance from the current pixel to the dot center:\n    float dist = length(uv - dotPos);\n\n    vec2 unuv = vec2(uv.x/(iResolution.x/iResolution.y), uv.y);\n    unuv = (unuv+1.)/2.; // undo resolution scaling\n    vec3 texC = texture(iChannel0, unuv).rgb;\n    texC += texture(iChannel1, unuv).rgb;\n    texC /= 2.;\n\n    // Use smoothstep to create a soft-edged dot:\n#if COLOR_MODE==2\n    dotSize *= dot(texC.rgb, vec3(1./3.));\n    float intensity = smoothstep(dotSize, dotSize * 0.8, dist);\n\n    if (gID==0.) return vec4(1.*intensity,0.,0.,1.);\n    if (gID==1.) return vec4(0.,1.*intensity,0.,1.);\n    if (gID==2.) return vec4(0.,0.,1.*intensity,1.);\n    if (gID==3.) return vec4(1.*intensity,0.,0.,1.);\n\n#endif\n#if COLOR_MODE==1\n    float intensity = smoothstep(dotSize, dotSize * 0.8, dist);\n    return vec4(vec3(intensity)*texC, 1.0);\n#endif\n#if COLOR_MODE==0\n    dotSize *= dot(texC.rgb, vec3(1./3.));\n    float intensity = smoothstep(dotSize, dotSize * 0.8, dist);\n    return vec4(vec3(intensity), 1.0);\n#endif\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;  // Adjust for aspect ratio\n\n    vec3 col_ = vec3(0.0);\n\n    if (distance(uv,vec2(0.)) < 0.025) col_.r = 1.;\n\n// RGB delay\nfor (float i=0.; i<3.; i++) {\n    float time = iTime+(i*COLORSHIFT_INTENSITY);\n    float moveSpeed = .5;\n    float moveDist = 0.2;\n\n    vec2 off;\n#if MOVE_MODE\n    off = vec2(sin(time*moveSpeed), cos(time*moveSpeed))*moveDist;\n    //if (fract(time/INVERT_RATE*2.)<0.1) off = vec2(0.);\n#endif\n    vec2 m = (iMouse.z>0.) ? (iMouse.xy / iResolution.xy) * 2.0 - 1.0 : off;\n\n    // The parameters can be tweaked:\n    // dotCount, radius, dotSize define the look of the grid.\n    // nGroups, gID allow for patterned distribution of the dots.\n\n    float dotCount = 30.;\n    float dotRadius = 0.055;\n#if PULSE_MODE\n    dotRadius = mix(0.02,.055, (sin(time/2.)+1.)/2.);\n#endif\n    float nGroups = 4.;\n    vec3 col = vec3(0.0);\n    col += mainImage2(uv + m,                   dotCount, dotRadius, nGroups, 0.0).rgb;\n    col += mainImage2(uv + m * vec2(1.0,-1.0),  dotCount, dotRadius, nGroups, 1.0).rgb;\n    col += mainImage2(uv + m * vec2(-1.0,1.0),  dotCount, dotRadius, nGroups, 2.0).rgb;\n    col += mainImage2(uv + m * vec2(-1.0,-1.0), dotCount, dotRadius, nGroups, 3.0).rgb;\n\n    if (mod(time, INVERT_RATE*2.) > INVERT_RATE) col = 1.-col;\n    if (i==0.) col_.r += col.r;\n    if (i==1.) col_.g += col.g;\n    if (i==2.) col_.b += col.b;\n    //col_ += col/3.;\n}\n\n    fragColor = vec4(col_,1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XXtczH","date":"1734735333","viewed":43,"name":"psychedelic streetview","username":"bombblob","description":"shifting sections make image come together and fragment rapidly\n\nclicking the red dot in the center re-aligns the image","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["hiddenimage"],"hasliked":0,"parentid":"","parentname":""}}