{"ver":"0.1","info":{"id":"llcGWB","date":"1471257987","viewed":167,"name":"circlerender","username":"visy","description":"circ","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["circ"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// based on gltracy's marching examples\n\n// ray marching\nconst int max_iterations = 1;\nfloat stop_threshold = 0.001;\n float grad_step = 0.02;\nconst float clip_far = 1000.0;\n\nfloat speed = 1.0;\nfloat time = 0.0;\n\n// Optimized port and generalization of \n// http://learningwebgl.com/blog/?p=2858\nfloat stride = 8.0; // Must be a multiple of 4\nbool wiggle = true;\n\n\n// math\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\n// distance function\nfloat dist_sphere( vec3 pos, float r ) {\n\treturn length( pos ) - r;\n}\n\nfloat dist_box( vec3 pos, vec3 size ) {\n\treturn length( max( abs( pos ) - size, 0.0 ) );\n}\n\nint mode = 0;\n\nfloat repeat(vec3 pos) {\n    pos.x = mod(pos.x, 1.) - 0.5;\n    pos.y = mod(pos.y, 1.) - 0.5;\n    pos.z = mod(pos.z, 1.) - 0.5;\n\tif (mode == 0) \n    return -dist_sphere(pos,0.5);\n    else \n    return dist_sphere(pos,0.5);\n}\n\n// get distance in the world\nfloat dist_field( vec3 pos ) {\n\t// ...add objects here...\n\t\n\t// object 0 : sphere\n\tfloat d0 = 0.0;\n\t\n\t// object 1 : cube\n\tfloat d1 = dist_box( pos, vec3( iTime ) );\n\n    float d2 = repeat(pos);\n    \n\t// union     : min( d0,  d1 )\n\t// intersect : max( d0,  d1 )\n\t// subtract  : max( d1, -d0 )\n\treturn max(d2, min( d1, -d0 ));\n}\n\n// phong shading\nvec3 shading( vec3 v, vec3 n, vec3 eye ) {\n\t// ...add lights here...\n\t\n\tfloat shininess = 2.8;\n\t\n\tvec3 final = vec3(0.0);\n\t    \n\tvec3 ev = normalize( v - eye );\n\tvec3 ref_ev = reflect( ev, n );\n\t\n\t// light 0\n\t{\n\t\tvec3 light_pos   = vec3( cos(time*0.1)*100., 0.0, -1.0+v.z*0.0001);\n\t\tvec3 light_color = vec3( n.z*0.4,n.z*0.49, n.z*0.5 );\n\t\n\t\tvec3 vl = normalize( light_pos - v );\n\t\n\t\tfloat diffuse  = max( -1.0+n.z*0.8, dot( vl, n ) )*0.6;\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) )*0.8;\n\t\tspecular = pow( specular, shininess );\n\t\t\n\t\tfinal += light_color * ( diffuse + specular ); \n\t}\n\t\n\t// light 1\n\t{\n\t\tvec3 light_pos   = vec3( 100.-abs(cos(time*0.1)*200.), 50.+abs(cos(time*1.)*180.), 10.0 );\n\t\tvec3 light_color = vec3( 0.0, 0.0, 0.0 );\n\t\n\t\tvec3 vl = normalize( light_pos - v );\n\t\n\t\tfloat diffuse  = max( -1., dot( vl, n ) );\n\t\tfloat specular = max( -10.5+sin(n.z*0.1*(time*time*1.))*25., dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, shininess );\n\t\t\n\t\tfinal += light_color * ( diffuse + specular ); \n\t}\n\n\treturn final;\n}\n\n// get gradient in the world\nvec3 gradient( vec3 pos ) {\n\t vec3 dx = vec3( grad_step, 0.0, 0.0 );\n\t vec3 dy = vec3( 0.0, grad_step, 0.0 );\n\t vec3 dz = vec3( 0.0, 0.0, grad_step );\n\treturn normalize (\n\t\tvec3(\n\t\t\tdist_field( pos + dx ) + dist_field( pos - dx )*pos.x*0.1,\n\t\t\tdist_field( pos + dy ) + dist_field( pos - dy )*pos.y*0.01,\n\t\t\tdist_field( pos + dz ) + dist_field( pos - dz )*pos.z*0.5\t\t\t\n\t\t)\n\t);\n}\n\n// ray marching\nfloat ray_marching( vec3 origin, vec3 dir, float start, float end ) {\n\tfloat depth = start;\n\tfor ( int i = 0; i < max_iterations; i++ ) {\n\t\tfloat dist = dist_field( origin + dir * depth )*time*0.00035;\n\t\tif ( dist < stop_threshold ) {\n\t\t\treturn depth;\n\t\t}\n\t\tdepth += dist;\n\t\tif ( depth >= end) {\n\t\t\treturn end;\n\t\t}\n\t}\n\treturn end;\n}\n\n// get ray direction\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( (150.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\n// camera rotation : pitch, yaw\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nvec3 hash3( float n ) { return fract(sin(vec3(n,n+1.0,n+2.0))*43758.5453123); }\n\n\nfloat cf = 0.0;\nvoid mainImage(out vec4 fa, in vec2 aa)\n{\n\ttime = iTime*0.1;\n\tvec2 uv = gl_FragCoord.xy/iResolution.xy;\n\n    if (time > 3.14 && time < 4.79) { if (uv.x < 0.5) uv.x = 1.0-uv.x; if (uv.y < 0.5) uv.y = 1.0-uv.y;}\n    if (time > 4.79) { if (uv.x < 0.5) uv.x = 1.0-uv.x;}\n    if (time > 4.79) time-=4.79;\n    \n    \n    // default ray dir\n\tvec3 dir = ray_dir(iTime*0.0001, iResolution.xy, uv*iResolution.xy );\n    \n\t// default ray origin\n\tvec3 eye = vec3( 0., 0.0,0.0 );\n\n\t// rotate camera\n\tmat3 rot = rotationXY( vec2( time,time) );\n\tdir = rot * dir;\n\teye = rot * eye;\n\t\n\t// ray marching\n\tfloat depth = ray_marching( eye, dir, time, clip_far );\n\tif ( depth >= clip_far ) {\n\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n        return;\n\t}\n\t\n\t// shading\n\tvec3 pos = eye + dir * depth;\n\tmode = 0;\n\tvec3 n = vec3(0.0);\n    vec4 oc1 = vec4(0.0);\n    vec4 oc2 = vec4(0.0);\n\tmode = 1;\n\tvec3 n2 = vec3(0.0);\n    vec4 oc3 = vec4(0.0);\n    vec4 oc4 = vec4(0.0);\n    \n\tmode = 1;\n\tn = gradient( pos );\n    oc1 = vec4( shading( pos*time*0.001, n*0.61, eye ), 1.0 );\n    oc1 *= 0.2 + 0.8*pow(26.0*uv.x*uv.y*(3.0-uv.x)*(1.05-uv.y),0.55);\n    oc2 = vec4( shading( pos+vec3(0.,0.,0.), n*time*0.4, eye ), 1.0 )*1.2;\n    oc1 = oc1+((oc1+oc2*0.01)*-abs(cos(time*0.3+n.z*90.1)*n.z*0.1));\n\toc1 = clamp(oc1,vec4(0.0),vec4(1.0))*3.4+pos.z*0.00005;\n\n   \tmode = 0;\n\tn2 = gradient( pos );\n    oc3 = vec4( shading( pos, n2*0.8, eye ), 1.0 );\n    oc3 *= 0.2 + 0.8*pow(26.0*uv.x*uv.y*(3.0-uv.x)*(1.05-uv.y),0.55);\n    oc4 = vec4( shading( pos+vec3(0.,0.,0.), n2*time*0.01, eye ), 1.0 )*1.2;\n\n    oc3 = oc3+((oc3+oc4*0.01)*-abs(cos(time*0.3+n2.z*500.1)*n2.z*.1));\n\toc3 = clamp(oc3,vec4(0.0),vec4(1.0))*2.0;\n\n    float v = dot(oc1.rgb+oc3.rgb, oc1.rgb+oc3.rgb)*n2.z*0.1;\n    vec2 p = gl_FragCoord.xy+vec2(oc3.b*0.00001,0.0);\n\tif (wiggle) p.x += floor(sin(p.x * 0.08) * 2.0 + sin(p.y * 0.01 + p.x * 0.07));\n\tp = mod(p.xx + vec2(p.y, -p.y), vec2(stride));\n    cf = iTime*0.04;\n    if (cf > 1.0) cf = 1.0; \n  fa = gl_FragColor = (oc1*(cf+oc1.r-p.x*0.01+p.y*0.02+cos(iTime*1.1+p.x*0.0001+p.y*0.002*oc1.b)*0.1)+oc3*cf)+0.1*oc3.b*vec4(vec3(\n          float((v > 1.00) || (p.x != 0.0)) *\n\t\t  float((v > 0.70) || (p.y != 0.0)) *\n  \t\t  float((v > 0.35) || (p.x != stride / 2.0)) *\n    \t  float((v > 0.18) || (p.y != stride / 2.0)) *\n          float((v > 0.10) || (p.x != stride / 4.0)) *\n          float((v > 0.02) || (p.y != stride / 4.0))*(3.-pos.z*1.)), 1.0);\n\n}","name":"Image","description":"","type":"image"}]}