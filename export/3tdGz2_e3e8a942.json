{"ver":"0.1","info":{"id":"3tdGz2","date":"1577032812","viewed":152,"name":"4D sphere boys","username":"BernieBud","description":"omg look at my sweet little boys","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["4d","hypersphere","glome"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// IMPORTANT TO NOTE each \"slice\" is not of its own 3D space but rather to be treated as another \"row\" of pixels on a 3D image\n// This is why the checkboard pattern acts the way it does when you move away from the center W slice.\n// Click and drag to see different 2D slices of the 3D image created by this 4D world\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define R_STEP 8. // How many samples along the uv.z coordinate don't set this much higher than like 32 or else you'll die\n// set above to .5 so we only get a single image\n#define W_CROP 128. // How far along the W axis do we render our samples? (Bigger number = Narrower slice)\n#define PI 3.14159265\n\nfloat GetDist(vec4 p)\n{\n vec4 glome[4];\n    glome[0]  = vec4(.5,1.,6,0);\n    glome[1]  = vec4(-1,-1.5,12,1);\n    glome[2]  = vec4(2.,-1.5,8,.0);\n    glome[3]  = vec4(-1,-1.5,4,0);\n    float radius = 1.0;\n    float sDIST = 100.;\n    \n    for(int i = 0;i < 4;i++)\n    {sDIST = min(length(p-glome[i])-radius,sDIST);}\n    sDIST = min(sDIST,p.y+2.5);\n    return sDIST;\n}\n\n\nfloat RayMarch(vec4 ro, vec4 rd)\n{\n float dO = 0.0;\n    \n    for(int i = 0;i < MAX_STEPS;i++)\n    {\n        vec4 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO > MAX_DIST || dS < SURF_DIST) break;\n        \n    }\n    \n    return dO;\n}\n\nvec4 GetNormal(vec4 p)\n{\n    float D = GetDist(p);\n    vec2 e = vec2(.01,0);\n    vec4 n = D - vec4(\n        GetDist(p-e.xyyy),\n        GetDist(p-e.yxyy),\n        GetDist(p-e.yyxy),\n        GetDist(p-e.yyyx)\n        );\n    return normalize(n);\n}\n\nfloat GetLight(vec4 p)   \n{\n    vec4 LightPos = vec4(4,8,4,4);\n   \n    vec4 l = normalize(LightPos-p);\n    vec4 n = GetNormal(p);\n    float s = RayMarch(p+n*SURF_DIST*2.,l);\n    if(s<length(LightPos-p)) l *= .0;\n    \n    float GAY = dot(n,l);\n\treturn GAY;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec4 col = vec4(0);\n\n    // Time varying pixel color\n    vec4 space = vec4(uv,iMouse.x/iResolution.x - 0.5,iMouse.y/iResolution.y - 0.5);\n    //space = vec4(uv,0,0); // Locks W value to 0.\n    float T = (iTime/20. - float(int(iTime/20.)))*2.-1.;\n    T = clamp(iMouse.x/iResolution.x - 0.5,-1.,1.);\n    \n    //space = vec4(uv,0,round(T*64.)/64.);\n    space = vec4(uv,0,T); // set T to 0.0 so we lock on the center slice of pixels\n    \n    vec4 rO = vec4(cos(iTime/2.)*9.,0,6.+sin(iTime/2.)*9.,0);\n    vec4 rD = normalize(vec4(space.xy,1.0,space.w));\n    float D = 0.;\n    vec3 lightcol = vec3(1.0,1.0,1.0);\n    \n    for(float i = -R_STEP;i < R_STEP;i++)\n    {\n        float YAW = iTime/2.+PI/2.;\n        \n    space = vec4(uv,0,i/R_STEP/W_CROP + T);\n    rD = normalize(vec4(\n        cos(YAW)*space.x - sin(YAW),\n        space.y,\n        sin(YAW)*space.x + cos(YAW),\n        space.w));\n    D = RayMarch(rO,rD);\n    \n        vec4 p = rO + rD * D;\n    //vec4 col = vec4(1.-1./D);\n    float CHK = 0.0;\n    if(int(p.x+64.) % 2 >= 1) // p.x+64. is so the checkerboard pattern repeats properly with negative numbers\n        CHK = 1.;\n    if(int(p.z+64.) % 2 >= 1)\n        CHK = 1.-CHK;\n    if(int(p.w+64.) % 2 >= 1)\n        CHK = 1.-CHK;\n    CHK = 1.-CHK/3.;\n        if(p.y >= -2.49) // makes the checkerboard only affect the grid and shit agh\n            CHK = 1.;\n        \n    //lightcol = vec3(clamp(1.-i*2. ,.0,1.), clamp(1.+i*2. ,.0,1.) , 0.);\n        lightcol = vec3(CHK,1.0-CHK/2.,1.0);\n    \n    col += vec4(  (clamp(GetLight(p),0.,1.) + 0.1)  ) * vec4(lightcol,1.) / R_STEP/2.;\n    }\n    \n    // Tonemapping\n    //col = (col/(col+1.))*1.9-0.1;\n    \n    // Output to screen\n    fragColor = vec4(col);\n}","name":"Image","description":"","type":"image"}]}