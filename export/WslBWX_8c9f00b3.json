{"ver":"0.1","info":{"id":"WslBWX","date":"1589183140","viewed":131,"name":"julia sets on riemann sphere","username":"matthen","description":"julia sets on riemann sphere","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["fractal","julia","mandelbrot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 256\n#define HIT_THRESHOLD 0.00001\n\nstruct Surface {\n\tvec3 color;\n};\n\n    \nstruct SceneDistance {\n    float d;\n    Surface surface;\n};\n    \n    \n\nSceneDistance planeDist(Surface surface, vec3 p, vec3 n, float d) {\n    return SceneDistance(\n        dot(p, n.xyz) + d,\n        surface\n    );\n}\n\nSceneDistance sphereDist(Surface surface, vec3 p, float s) {\n    return SceneDistance(\n        length(p) - s,\n        surface\n    );\n}\n\nSceneDistance distanceUnion(SceneDistance d1, SceneDistance d2) {\n    if (d1.d < d2.d) {\n        return d1;\n    }\n    return d2;\n}\n\nSceneDistance distanceSubtract(SceneDistance d1, SceneDistance d2) {\n    if (d2.d > -d1.d) {\n    \treturn d2;   \n    }\n    return SceneDistance(\n    \t-d1.d, d2.surface    \n    );\n}\n\nvec3 translate(vec3 v, vec3 t) {\n\treturn v - t;\n}\n\nvec3 rotate(vec3 point, vec3 axis, float angle){\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    mat4 rot= mat4(\n        oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s,  0.0,\n        oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,oc * axis.y * axis.z - axis.x * s,  0.0,\n        oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n        0.0, 0.0, 0.0, 1.0);\n    return (rot * vec4(point, 1.)).xyz;\n}\n\n\nSceneDistance scene(in vec3 pos) {\n    Surface surf = Surface(vec3(0., 0., 1.));\n    return  sphereDist(\n        surf, translate( pos, vec3(0., 0., 0.)), 1. ); \n}\n\nvec3 sceneNormal(vec3 pos, float d) {\n    float eps = 0.001;\n    vec3 n;\n\t\n    n.x = scene(vec3( pos.x + eps, pos.y, pos.z )).d - d;\n    n.y = scene(vec3( pos.x, pos.y + eps, pos.z )).d - d;\n    n.z = scene(vec3( pos.x, pos.y, pos.z + eps )).d - d;\n\t\n    return normalize(n);\n}\n\nstruct Ray {\n\tvec3 org;\n\tvec3 dir;\n};\n\nstruct MarchResult {\n\tbool hit;\n    vec3 pos;\n    vec3 norm;\n    int steps;\n    Surface surface;\n};\n\nMarchResult rayMarch(Ray ray) {\n\tMarchResult result = MarchResult(\n    \tfalse,\n        ray.org,\n        vec3(0., 0., 0.),\n        0,\n        Surface(vec3(0., 0., 0.))\n    );\n\n    for (; result.steps < MAX_STEPS; result.steps++) {\n\t\tSceneDistance sd = scene(result.pos);\n\t\tif (sd.d < HIT_THRESHOLD) {\n\t\t\tresult.hit = true;\n\t\t\tresult.norm = sceneNormal(result.pos, sd.d);\n            result.surface = sd.surface;\n\t\t\tbreak;\n\t\t}\n\t\tresult.pos += sd.d * ray.dir;\n\t}\n\treturn result;\n}\n\n\nfloat shadow(vec3 ro, vec3 rd, float mint, float maxt) {\n\tfloat t = mint;\n    for ( int i = 0; i < 64; ++i )\n    {\n        float h = scene(ro + rd * t).d;\n        if ( h < 0.001 && i > 0) {\n            return 0.2;\n        }\n        t += h;\n\t\t\n\t\tif ( t > maxt )\n\t\t\tbreak;\n    }\n    return 1.0;\n}\n\n\nvec3 gradient(in float r) {\t\n    r /= 20.;\n    r = clamp(r, 0.01, 1.);\n    float mask = smoothstep(0., 0.2, r);\n    r = pow(r, 0.4);\n    vec3 rainbow = 0.5 + 0.5 * cos((5.5 * r + vec3(0.2, 0.45, 0.8)*6.));\n    \n    return rainbow * mask;\n}\n\n\nvec4 fractal(vec2 z, vec2 c) {    \n    for (float i = 0.; i < 256.; ++i) {\n  \t\t      \n        z = vec2(\n            z.x*z.x - z.y*z.y + c.x,\n            2.0 * z.x*z.y + c.y\n        );\n        \n\n        float distSqr = dot(z, z);\n        \n        if (distSqr > 16.0)\n            return vec4(gradient(float(i) + 1.0 - log2(log(distSqr) / 2.0)), 1.);\n    }\n    \n    return vec4(0.0, 0.0, 0.0, 1.0);\n}\n\nvec3 colorSphere(in vec3 p) {\n    vec2 pp = p.xz / (1. - p.y);\n    pp.x -= 0.25;\n    \n    float scale = 20.;\n    pp *= scale;\n    vec2 c = round(pp);\n    vec2 z = pp - c;\n    c /= scale;\n    c *= 3.;\n    z /= scale;\n    z *= 60. - 50. * (\n        smoothstep(0., 10., mod(iTime, 20.))\n        -smoothstep(10., 20., mod(iTime, 20.))\n     );\n    \n\treturn fractal(z, c).rgb;\n}\n\nvec3 shade(MarchResult marchResult, vec4 light) {\n\tvec3 toLight = light.xyz - marchResult.pos;\n\t\n\tfloat toLightLen = length(toLight);\n\ttoLight = normalize(toLight);\n\t\n\tfloat comb = 0.4;\n   \tfloat vis = shadow(marchResult.pos, toLight, 0.01, toLightLen);\n\tif (vis > 0.0) {\n\t\tfloat diff = 1.2 * max(0.0, dot(marchResult.norm, toLight));\n\t\tfloat attn = 1.0 - pow(min(1.0, toLightLen / light.w), 2.0);\n        comb += diff * attn * vis;\n\t}\n\treturn comb * colorSphere(normalize(marchResult.pos));\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 ndcXY = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\tfloat aspectRatio = iResolution.x / iResolution.y;\n\tvec2 scaledXY = 0.7 * ndcXY * vec2( aspectRatio, 1.0 );\n\t\n\t// camera XYZ in world space\n\tvec3 camWsXYZ = vec3(0.0, 0.0, 2.0);\n   \t\n    Ray ray;\n\tray.org = camWsXYZ;\n\tray.dir =  normalize(vec3( scaledXY, -1 ));\n    float t = iTime / 20.;\n    float ph = 0. + 6.28 * t;\n    float th = -1.57 - 0.3 * sin(6.28 * t);\n    ray.org = rotate(ray.org, vec3(1., 0., 0.), th);\n    ray.dir = rotate(ray.dir, vec3(1., 0., 0.), th);\n    ray.org = rotate(ray.org, vec3(0., 1., 0.), ph);\n    ray.dir = rotate(ray.dir, vec3(0., 1., 0.), ph);\n    \n\t\n\t// define point lights (XYZ, range)\n\tvec4 light = vec4(0.0, -2., 0.5, 8.0);\n\t\n    MarchResult marchResult = rayMarch(ray);\n\t\n\tif (marchResult.hit) {\n\t\tvec3 shade = shade(marchResult, light);\n\t\t\n\t\tfragColor = vec4(shade, 1.0);\n\t}\n\telse {\n\t\tfragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\t}\n    \n    \n    \n}\n","name":"Image","description":"","type":"image"}]}