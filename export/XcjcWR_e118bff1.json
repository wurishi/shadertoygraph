{"ver":"0.1","info":{"id":"XcjcWR","date":"1722163747","viewed":62,"name":"Note visializer 3D raytrace","username":"ODtian","description":"sound: Fighting My Way (piano ver.)  https://www.youtube.com/watch?v=5Wx0FON8KAE\nraytrace: https://www.shadertoy.com/view/tl23Rm https://www.shadertoy.com/view/3lB3DR\ndenoise: https://www.shadertoy.com/view/ldKBzG","likes":4,"published":1,"flags":40,"usePreview":0,"tags":["3d","sound","raytrace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// #define VSCODE\n\n#ifdef VSCODE\n#iChannel0 \"file://vis3d.glsl\"\n// #include \"3d_common.glsl\"\n#endif\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec3 col = data.rgb;\n\n    // gamma correction\n    col = max(vec3(0), col - 0.004);\n    col = (col * (6.2 * col + .5)) / (col * (6.2 * col + 1.7) + 0.06);\n\n    // Output to screen\n    fragColor = vec4(col, data.w);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define DEBUG\n\n#ifdef DEBUG\n#define TIME_SCALE 1.0\n#define iTime (iTime * TIME_SCALE)\n#define iTimeDelta (iTimeDelta * TIME_SCALE)\n#endif\n\n#define SOUND_LENGTH 705\n#define INSTRUMENT pianoWithPedal\n#define SCALE (1100.0)\n#define VOL -3.5\n#define LEN 74702.0\n#define KEY_MARGIN 0.01\n\nconst vec3[SOUND_LENGTH] sound = vec3[SOUND_LENGTH](vec3(1670.0, 2294.0, 65.0), vec3(1670.0, 2515.0, 41.0), vec3(2323.0, 2515.0, 63.0), vec3(2544.0, 2755.0, 65.0), vec3(2765.0, 2976.0, 68.0), vec3(2544.0, 3158.0, 39.0), vec3(3187.0, 3398.0, 63.0), vec3(3418.0, 3619.0, 65.0), vec3(3638.0, 3830.0, 63.0), vec3(3859.0, 4070.0, 65.0), vec3(4070.0, 4963.0, 68.0), vec3(3187.0, 5117.0, 37.0), vec3(4934.0, 5146.0, 65.0), vec3(5146.0, 5366.0, 70.0), vec3(5366.0, 5578.0, 70.0), vec3(5578.0, 5818.0, 70.0), vec3(5146.0, 6019.0, 46.0), vec3(5818.0, 6019.0, 70.0), vec3(6019.0, 6240.0, 70.0), vec3(6240.0, 6451.0, 68.0), vec3(6019.0, 6662.0, 44.0), vec3(6451.0, 6662.0, 68.0), vec3(6662.0, 7094.0, 67.0), vec3(7094.0, 7526.0, 65.0), vec3(7555.0, 7738.0, 63.0), vec3(6662.0, 8160.0, 39.0), vec3(8218.0, 8621.0, 40.0), vec3(7776.0, 8621.0, 60.0), vec3(8650.0, 9293.0, 65.0), vec3(8650.0, 9504.0, 41.0), vec3(9293.0, 9504.0, 63.0), vec3(9504.0, 9725.0, 65.0), vec3(9504.0, 10138.0, 39.0), vec3(9725.0, 10138.0, 68.0), vec3(10166.0, 10378.0, 63.0), vec3(10378.0, 10598.0, 65.0), vec3(10598.0, 10810.0, 63.0), vec3(10810.0, 11030.0, 65.0), vec3(10166.0, 11453.0, 37.0), vec3(11030.0, 11453.0, 72.0), vec3(11491.0, 11674.0, 41.0), vec3(11702.0, 11894.0, 44.0), vec3(11702.0, 11923.0, 72.0), vec3(11923.0, 12106.0, 48.0), vec3(11923.0, 12134.0, 72.0), vec3(12134.0, 12355.0, 72.0), vec3(12355.0, 12566.0, 70.0), vec3(12134.0, 12998.0, 46.0), vec3(12566.0, 13430.0, 68.0), vec3(12998.0, 13642.0, 44.0), vec3(13459.0, 13642.0, 70.0), vec3(13670.0, 13872.0, 68.0), vec3(13670.0, 14851.0, 39.0), vec3(13872.0, 14851.0, 67.0), vec3(14851.0, 15072.0, 72.0), vec3(15072.0, 15283.0, 70.0), vec3(15283.0, 15504.0, 73.0), vec3(15533.0, 15619.0, 78.0), vec3(15619.0, 15965.0, 65.0), vec3(15619.0, 16051.0, 41.0), vec3(15840.0, 16272.0, 53.0), vec3(16051.0, 16483.0, 41.0), vec3(15965.0, 16483.0, 65.0), vec3(16272.0, 16733.0, 53.0), vec3(16483.0, 16819.0, 65.0), vec3(16483.0, 16944.0, 41.0), vec3(16733.0, 17155.0, 53.0), vec3(16944.0, 17376.0, 41.0), vec3(16819.0, 17376.0, 65.0), vec3(17155.0, 17587.0, 53.0), vec3(17376.0, 17587.0, 65.0), vec3(17155.0, 17694.0, 60.0), vec3(17376.0, 17808.0, 41.0), vec3(17587.0, 17808.0, 53.0), vec3(17587.0, 17808.0, 65.0), vec3(17808.0, 18019.0, 53.0), vec3(17808.0, 18019.0, 65.0), vec3(17808.0, 18240.0, 41.0), vec3(18019.0, 18240.0, 53.0), vec3(18019.0, 18240.0, 65.0), vec3(18240.0, 18451.0, 53.0), vec3(18240.0, 18701.0, 41.0), vec3(18451.0, 18883.0, 53.0), vec3(18240.0, 18883.0, 65.0), vec3(18883.0, 19008.0, 65.0), vec3(18701.0, 19094.0, 41.0), vec3(18883.0, 19094.0, 53.0), vec3(19008.0, 19094.0, 65.0), vec3(18019.0, 19094.0, 68.0), vec3(19094.0, 19315.0, 53.0), vec3(19094.0, 19315.0, 68.0), vec3(19315.0, 19440.0, 68.0), vec3(19094.0, 19526.0, 41.0), vec3(19315.0, 19526.0, 53.0), vec3(19440.0, 19526.0, 68.0), vec3(19526.0, 19776.0, 41.0), vec3(19526.0, 19776.0, 53.0), vec3(19526.0, 19776.0, 67.0), vec3(19776.0, 19872.0, 67.0), vec3(19776.0, 19987.0, 41.0), vec3(19776.0, 19987.0, 53.0), vec3(19872.0, 19987.0, 67.0), vec3(19987.0, 20112.0, 65.0), vec3(19987.0, 20208.0, 41.0), vec3(19987.0, 20208.0, 53.0), vec3(20112.0, 20208.0, 65.0), vec3(20208.0, 20323.0, 65.0), vec3(20208.0, 20419.0, 41.0), vec3(20208.0, 20419.0, 53.0), vec3(20323.0, 20419.0, 65.0), vec3(20419.0, 20630.0, 53.0), vec3(20419.0, 20851.0, 41.0), vec3(20630.0, 20851.0, 53.0), vec3(20419.0, 20880.0, 65.0), vec3(20851.0, 21062.0, 53.0), vec3(20851.0, 21187.0, 72.0), vec3(20851.0, 21283.0, 41.0), vec3(21062.0, 21523.0, 53.0), vec3(20630.0, 21626.0, 63.0), vec3(21283.0, 21734.0, 41.0), vec3(21187.0, 21734.0, 72.0), vec3(21523.0, 21946.0, 53.0), vec3(21734.0, 22166.0, 41.0), vec3(21946.0, 22378.0, 53.0), vec3(22166.0, 22598.0, 41.0), vec3(21523.0, 22598.0, 65.0), vec3(22378.0, 22838.0, 53.0), vec3(22598.0, 23050.0, 41.0), vec3(22838.0, 23270.0, 53.0), vec3(23050.0, 23482.0, 41.0), vec3(21734.0, 23482.0, 72.0), vec3(23270.0, 23592.0, 53.0), vec3(22598.0, 23592.0, 65.0), vec3(23482.0, 23914.0, 41.0), vec3(23702.0, 24134.0, 53.0), vec3(23827.0, 24134.0, 65.0), vec3(23914.0, 24346.0, 41.0), vec3(23482.0, 24346.0, 72.0), vec3(24134.0, 24566.0, 53.0), vec3(24134.0, 24566.0, 65.0), vec3(24346.0, 24566.0, 72.0), vec3(24346.0, 24778.0, 41.0), vec3(24566.0, 24778.0, 72.0), vec3(24566.0, 24989.0, 53.0), vec3(24566.0, 24989.0, 65.0), vec3(24778.0, 25210.0, 41.0), vec3(24778.0, 25210.0, 72.0), vec3(24989.0, 25450.0, 53.0), vec3(24989.0, 25450.0, 65.0), vec3(25450.0, 25558.0, 65.0), vec3(24989.0, 25558.0, 75.0), vec3(25210.0, 25651.0, 41.0), vec3(25450.0, 25862.0, 53.0), vec3(25862.0, 25987.0, 70.0), vec3(25651.0, 26083.0, 41.0), vec3(25862.0, 26294.0, 53.0), vec3(26083.0, 26323.0, 68.0), vec3(25987.0, 26323.0, 70.0), vec3(25210.0, 26323.0, 72.0), vec3(26294.0, 26506.0, 67.0), vec3(26083.0, 26544.0, 41.0), vec3(26294.0, 26544.0, 53.0), vec3(26544.0, 26755.0, 53.0), vec3(26544.0, 26755.0, 65.0), vec3(26544.0, 26966.0, 41.0), vec3(26323.0, 26966.0, 72.0), vec3(26755.0, 27187.0, 53.0), vec3(26966.0, 27398.0, 41.0), vec3(26755.0, 27524.0, 68.0), vec3(26323.0, 27524.0, 70.0), vec3(26966.0, 27524.0, 72.0), vec3(27187.0, 27629.0, 53.0), vec3(27398.0, 27840.0, 41.0), vec3(27629.0, 28061.0, 53.0), vec3(27629.0, 28061.0, 65.0), vec3(27840.0, 28272.0, 41.0), vec3(28061.0, 28272.0, 65.0), vec3(28061.0, 28493.0, 53.0), vec3(28272.0, 28704.0, 41.0), vec3(28272.0, 28704.0, 65.0), vec3(28493.0, 28925.0, 53.0), vec3(28704.0, 29136.0, 41.0), vec3(28925.0, 29376.0, 53.0), vec3(28493.0, 29490.0, 63.0), vec3(28061.0, 29490.0, 67.0), vec3(27840.0, 29490.0, 68.0), vec3(27629.0, 29490.0, 70.0), vec3(29136.0, 29587.0, 41.0), vec3(29376.0, 29587.0, 53.0), vec3(28704.0, 29587.0, 65.0), vec3(29587.0, 30019.0, 53.0), vec3(29587.0, 30019.0, 65.0), vec3(29587.0, 30019.0, 68.0), vec3(29808.0, 30019.0, 72.0), vec3(29587.0, 30240.0, 41.0), vec3(30019.0, 30240.0, 53.0), vec3(30019.0, 30240.0, 65.0), vec3(30240.0, 30662.0, 41.0), vec3(30240.0, 30883.0, 53.0), vec3(30240.0, 30883.0, 60.0), vec3(30240.0, 30883.0, 65.0), vec3(30662.0, 31123.0, 41.0), vec3(30883.0, 31123.0, 53.0), vec3(30883.0, 31123.0, 60.0), vec3(30883.0, 31123.0, 65.0), vec3(31123.0, 31219.0, 60.0), vec3(31123.0, 31219.0, 65.0), vec3(31123.0, 31344.0, 41.0), vec3(31123.0, 31344.0, 53.0), vec3(31219.0, 31344.0, 60.0), vec3(31219.0, 31344.0, 65.0), vec3(30019.0, 31456.0, 68.0), vec3(30019.0, 31456.0, 72.0), vec3(29808.0, 31456.0, 77.0), vec3(31344.0, 31555.0, 53.0), vec3(31344.0, 31555.0, 60.0), vec3(31344.0, 31555.0, 65.0), vec3(31555.0, 31776.0, 53.0), vec3(31555.0, 31776.0, 60.0), vec3(31555.0, 31776.0, 65.0), vec3(31344.0, 31987.0, 41.0), vec3(31776.0, 31987.0, 53.0), vec3(31776.0, 31987.0, 60.0), vec3(31776.0, 31987.0, 65.0), vec3(31987.0, 32419.0, 41.0), vec3(31987.0, 32630.0, 53.0), vec3(31987.0, 32630.0, 65.0), vec3(31987.0, 32630.0, 68.0), vec3(31987.0, 32630.0, 72.0), vec3(32419.0, 32851.0, 41.0), vec3(32630.0, 32851.0, 68.0), vec3(32630.0, 32851.0, 72.0), vec3(32851.0, 33062.0, 41.0), vec3(32851.0, 33062.0, 68.0), vec3(32851.0, 33062.0, 72.0), vec3(33062.0, 33283.0, 68.0), vec3(33062.0, 33283.0, 72.0), vec3(32630.0, 33422.0, 53.0), vec3(32630.0, 33422.0, 65.0), vec3(33062.0, 33514.0, 41.0), vec3(33283.0, 33514.0, 68.0), vec3(33283.0, 33514.0, 72.0), vec3(33514.0, 33725.0, 53.0), vec3(33514.0, 33725.0, 68.0), vec3(33514.0, 33725.0, 71.0), vec3(33725.0, 33946.0, 68.0), vec3(33725.0, 33946.0, 71.0), vec3(33725.0, 34157.0, 41.0), vec3(33946.0, 34157.0, 68.0), vec3(33946.0, 34157.0, 70.0), vec3(34157.0, 34378.0, 41.0), vec3(34157.0, 34378.0, 68.0), vec3(34157.0, 34378.0, 70.0), vec3(34378.0, 34589.0, 53.0), vec3(34378.0, 34589.0, 68.0), vec3(34378.0, 34589.0, 69.0), vec3(34589.0, 34810.0, 41.0), vec3(34589.0, 34810.0, 68.0), vec3(34589.0, 34810.0, 69.0), vec3(34810.0, 35146.0, 41.0), vec3(34810.0, 35146.0, 65.0), vec3(34810.0, 35146.0, 68.0), vec3(35146.0, 35482.0, 41.0), vec3(35146.0, 35482.0, 65.0), vec3(35146.0, 35482.0, 68.0), vec3(35482.0, 36528.0, 41.0), vec3(35482.0, 36528.0, 53.0), vec3(35482.0, 36528.0, 65.0), vec3(35482.0, 36528.0, 68.0), vec3(36557.0, 36989.0, 41.0), vec3(36778.0, 36989.0, 53.0), vec3(36778.0, 36989.0, 68.0), vec3(36557.0, 36989.0, 72.0), vec3(36989.0, 37114.0, 65.0), vec3(37114.0, 37238.0, 65.0), vec3(37238.0, 37325.0, 65.0), vec3(36989.0, 37440.0, 41.0), vec3(37210.0, 37440.0, 53.0), vec3(37325.0, 37440.0, 65.0), vec3(37440.0, 37872.0, 41.0), vec3(37651.0, 37872.0, 53.0), vec3(37651.0, 37872.0, 65.0), vec3(37440.0, 37872.0, 68.0), vec3(37872.0, 38304.0, 41.0), vec3(38083.0, 38304.0, 53.0), vec3(38083.0, 38304.0, 65.0), vec3(37872.0, 38304.0, 72.0), vec3(38304.0, 38765.0, 41.0), vec3(38515.0, 38765.0, 53.0), vec3(38640.0, 38851.0, 65.0), vec3(38851.0, 39072.0, 65.0), vec3(38765.0, 39187.0, 41.0), vec3(38976.0, 39187.0, 53.0), vec3(39072.0, 39187.0, 65.0), vec3(38515.0, 39283.0, 68.0), vec3(38304.0, 39320.0, 72.0), vec3(39187.0, 39408.0, 65.0), vec3(39187.0, 39619.0, 41.0), vec3(39408.0, 39840.0, 53.0), vec3(39408.0, 39840.0, 65.0), vec3(39283.0, 39840.0, 68.0), vec3(39840.0, 39955.0, 65.0), vec3(39619.0, 40051.0, 41.0), vec3(39619.0, 40051.0, 72.0), vec3(39840.0, 40262.0, 53.0), vec3(39840.0, 40262.0, 68.0), vec3(39955.0, 40387.0, 65.0), vec3(40051.0, 40483.0, 41.0), vec3(40387.0, 40608.0, 65.0), vec3(40262.0, 40723.0, 53.0), vec3(40608.0, 40819.0, 65.0), vec3(40483.0, 40944.0, 41.0), vec3(40819.0, 40944.0, 65.0), vec3(40723.0, 41155.0, 53.0), vec3(40262.0, 41155.0, 68.0), vec3(40944.0, 41376.0, 41.0), vec3(41155.0, 41376.0, 53.0), vec3(40944.0, 41376.0, 65.0), vec3(41376.0, 41587.0, 53.0), vec3(41376.0, 41587.0, 65.0), vec3(41155.0, 41587.0, 68.0), vec3(41376.0, 41808.0, 41.0), vec3(41587.0, 41808.0, 53.0), vec3(41587.0, 41808.0, 65.0), vec3(41587.0, 41808.0, 68.0), vec3(40051.0, 41808.0, 72.0), vec3(41808.0, 42662.0, 41.0), vec3(41808.0, 42662.0, 53.0), vec3(41808.0, 42662.0, 65.0), vec3(41808.0, 42662.0, 68.0), vec3(41808.0, 42662.0, 72.0), vec3(42662.0, 42883.0, 72.0), vec3(42662.0, 42883.0, 84.0), vec3(42883.0, 43094.0, 70.0), vec3(42883.0, 43094.0, 82.0), vec3(43123.0, 43325.0, 68.0), vec3(43123.0, 43325.0, 80.0), vec3(43325.0, 43536.0, 63.0), vec3(43325.0, 43536.0, 75.0), vec3(43536.0, 43968.0, 37.0), vec3(43757.0, 44218.0, 49.0), vec3(43968.0, 44429.0, 37.0), vec3(43872.0, 44429.0, 72.0), vec3(43872.0, 44429.0, 84.0), vec3(44218.0, 44640.0, 49.0), vec3(44429.0, 44861.0, 37.0), vec3(44640.0, 44861.0, 49.0), vec3(44861.0, 45072.0, 49.0), vec3(43536.0, 45218.0, 65.0), vec3(44861.0, 45218.0, 68.0), vec3(44640.0, 45218.0, 70.0), vec3(44429.0, 45218.0, 72.0), vec3(43536.0, 45218.0, 77.0), vec3(44861.0, 45218.0, 80.0), vec3(44640.0, 45218.0, 82.0), vec3(44429.0, 45218.0, 84.0), vec3(44861.0, 45274.0, 37.0), vec3(45072.0, 45274.0, 49.0), vec3(45072.0, 45274.0, 63.0), vec3(45072.0, 45274.0, 75.0), vec3(45302.0, 45610.0, 65.0), vec3(45302.0, 45610.0, 77.0), vec3(45302.0, 45734.0, 39.0), vec3(45514.0, 45946.0, 51.0), vec3(45734.0, 46166.0, 39.0), vec3(45638.0, 46166.0, 75.0), vec3(45638.0, 46166.0, 87.0), vec3(45946.0, 46378.0, 51.0), vec3(46166.0, 46406.0, 75.0), vec3(46166.0, 46406.0, 87.0), vec3(46166.0, 46589.0, 39.0), vec3(46378.0, 46589.0, 73.0), vec3(46378.0, 46589.0, 85.0), vec3(46378.0, 46810.0, 51.0), vec3(46589.0, 46810.0, 72.0), vec3(46589.0, 46810.0, 84.0), vec3(46589.0, 47021.0, 39.0), vec3(46810.0, 47021.0, 51.0), vec3(46810.0, 47021.0, 73.0), vec3(46810.0, 47021.0, 85.0), vec3(47021.0, 47261.0, 41.0), vec3(47021.0, 47261.0, 72.0), vec3(47021.0, 47261.0, 84.0), vec3(47261.0, 47472.0, 41.0), vec3(47261.0, 47472.0, 53.0), vec3(47261.0, 47472.0, 72.0), vec3(47261.0, 47472.0, 84.0), vec3(47472.0, 47693.0, 41.0), vec3(47472.0, 47693.0, 72.0), vec3(47472.0, 47693.0, 84.0), vec3(47693.0, 47904.0, 41.0), vec3(47693.0, 47904.0, 53.0), vec3(47693.0, 47904.0, 70.0), vec3(47693.0, 47904.0, 82.0), vec3(47904.0, 48125.0, 41.0), vec3(47904.0, 48125.0, 68.0), vec3(47904.0, 48125.0, 80.0), vec3(48125.0, 48336.0, 41.0), vec3(48125.0, 48336.0, 53.0), vec3(48125.0, 48336.0, 70.0), vec3(48125.0, 48336.0, 82.0), vec3(48336.0, 48557.0, 41.0), vec3(48336.0, 48557.0, 72.0), vec3(48336.0, 48557.0, 84.0), vec3(48557.0, 48768.0, 41.0), vec3(48557.0, 48768.0, 53.0), vec3(48557.0, 48768.0, 68.0), vec3(48557.0, 48768.0, 80.0), vec3(48797.0, 49104.0, 36.0), vec3(49008.0, 49104.0, 48.0), vec3(48797.0, 49104.0, 67.0), vec3(48797.0, 49104.0, 79.0), vec3(49104.0, 49150.0, 48.0), vec3(49104.0, 49238.0, 36.0), vec3(49104.0, 49421.0, 67.0), vec3(49104.0, 49421.0, 79.0), vec3(49238.0, 49450.0, 36.0), vec3(49450.0, 49661.0, 36.0), vec3(49450.0, 49661.0, 48.0), vec3(49450.0, 49661.0, 77.0), vec3(49450.0, 49661.0, 89.0), vec3(49661.0, 49882.0, 36.0), vec3(49661.0, 49882.0, 48.0), vec3(49661.0, 49882.0, 72.0), vec3(49661.0, 49882.0, 84.0), vec3(49882.0, 50093.0, 36.0), vec3(49882.0, 50093.0, 48.0), vec3(49882.0, 50093.0, 70.0), vec3(49882.0, 50093.0, 82.0), vec3(50093.0, 50314.0, 36.0), vec3(50093.0, 50314.0, 48.0), vec3(50093.0, 50314.0, 68.0), vec3(50093.0, 50314.0, 80.0), vec3(50314.0, 50525.0, 36.0), vec3(50314.0, 50525.0, 48.0), vec3(50314.0, 50525.0, 63.0), vec3(50314.0, 50525.0, 75.0), vec3(50525.0, 50861.0, 37.0), vec3(50746.0, 50861.0, 49.0), vec3(50525.0, 50861.0, 65.0), vec3(50525.0, 50861.0, 77.0), vec3(50861.0, 50986.0, 37.0), vec3(50861.0, 50986.0, 49.0), vec3(50986.0, 51117.0, 49.0), vec3(50986.0, 51197.0, 37.0), vec3(51197.0, 51408.0, 49.0), vec3(50861.0, 51408.0, 72.0), vec3(50861.0, 51408.0, 84.0), vec3(51408.0, 51629.0, 37.0), vec3(51408.0, 51629.0, 72.0), vec3(51408.0, 51629.0, 84.0), vec3(51629.0, 51840.0, 49.0), vec3(51629.0, 51840.0, 70.0), vec3(51629.0, 51840.0, 82.0), vec3(51840.0, 52061.0, 37.0), vec3(51840.0, 52061.0, 68.0), vec3(51840.0, 52061.0, 80.0), vec3(52061.0, 52272.0, 49.0), vec3(52061.0, 52272.0, 63.0), vec3(52061.0, 52272.0, 75.0), vec3(52272.0, 52483.0, 39.0), vec3(52272.0, 52608.0, 65.0), vec3(52272.0, 52608.0, 77.0), vec3(52483.0, 52704.0, 51.0), vec3(52704.0, 52915.0, 39.0), vec3(52608.0, 52944.0, 75.0), vec3(52608.0, 52944.0, 87.0), vec3(52944.0, 53136.0, 51.0), vec3(53136.0, 53357.0, 51.0), vec3(53136.0, 53568.0, 39.0), vec3(53357.0, 53568.0, 51.0), vec3(52944.0, 53568.0, 75.0), vec3(52944.0, 53568.0, 87.0), vec3(53568.0, 53789.0, 51.0), vec3(53568.0, 53818.0, 75.0), vec3(53568.0, 53818.0, 87.0), vec3(53568.0, 54000.0, 39.0), vec3(53789.0, 54000.0, 51.0), vec3(53789.0, 54000.0, 73.0), vec3(53789.0, 54000.0, 85.0), vec3(54000.0, 54221.0, 72.0), vec3(54000.0, 54221.0, 84.0), vec3(54000.0, 54461.0, 41.0), vec3(54221.0, 54461.0, 53.0), vec3(54221.0, 54461.0, 73.0), vec3(54221.0, 54461.0, 85.0), vec3(54461.0, 54643.0, 80.0), vec3(54461.0, 54643.0, 92.0), vec3(54461.0, 54682.0, 41.0), vec3(54682.0, 54893.0, 41.0), vec3(54682.0, 54893.0, 53.0), vec3(54682.0, 54893.0, 73.0), vec3(54682.0, 54893.0, 85.0), vec3(54893.0, 55114.0, 41.0), vec3(54893.0, 55114.0, 72.0), vec3(54893.0, 55114.0, 84.0), vec3(55114.0, 55325.0, 41.0), vec3(55114.0, 55325.0, 53.0), vec3(55114.0, 55325.0, 73.0), vec3(55114.0, 55325.0, 85.0), vec3(55325.0, 55546.0, 41.0), vec3(55325.0, 55546.0, 72.0), vec3(55325.0, 55546.0, 84.0), vec3(55546.0, 55757.0, 41.0), vec3(55546.0, 55757.0, 53.0), vec3(55546.0, 55757.0, 65.0), vec3(55546.0, 55757.0, 77.0), vec3(55757.0, 56064.0, 65.0), vec3(55757.0, 56064.0, 77.0), vec3(55757.0, 56218.0, 36.0), vec3(55978.0, 56218.0, 48.0), vec3(56093.0, 56400.0, 73.0), vec3(56093.0, 56400.0, 85.0), vec3(56218.0, 56429.0, 36.0), vec3(56218.0, 56429.0, 48.0), vec3(56429.0, 56621.0, 36.0), vec3(56429.0, 56621.0, 48.0), vec3(56429.0, 56621.0, 72.0), vec3(56429.0, 56621.0, 84.0), vec3(56650.0, 56832.0, 36.0), vec3(56650.0, 56832.0, 48.0), vec3(56650.0, 56832.0, 65.0), vec3(56650.0, 56832.0, 77.0), vec3(56861.0, 57072.0, 36.0), vec3(56861.0, 57072.0, 48.0), vec3(56861.0, 57072.0, 73.0), vec3(56861.0, 57072.0, 85.0), vec3(57072.0, 57101.0, 48.0), vec3(57072.0, 57533.0, 36.0), vec3(57312.0, 57533.0, 48.0), vec3(57072.0, 57533.0, 72.0), vec3(57072.0, 57533.0, 84.0), vec3(57533.0, 57965.0, 37.0), vec3(57744.0, 57965.0, 49.0), vec3(57965.0, 58176.0, 37.0), vec3(57965.0, 58176.0, 49.0), vec3(57533.0, 58176.0, 65.0), vec3(57533.0, 58176.0, 77.0), vec3(58176.0, 58387.0, 37.0), vec3(58176.0, 58387.0, 49.0), vec3(58176.0, 58387.0, 67.0), vec3(58176.0, 58387.0, 79.0), vec3(58387.0, 58608.0, 49.0), vec3(58387.0, 58608.0, 68.0), vec3(58387.0, 58608.0, 80.0), vec3(58387.0, 58819.0, 37.0), vec3(58608.0, 58819.0, 49.0), vec3(58608.0, 58819.0, 65.0), vec3(58608.0, 58819.0, 77.0), vec3(58819.0, 58981.0, 49.0), vec3(58819.0, 59040.0, 37.0), vec3(59040.0, 59251.0, 49.0), vec3(59251.0, 59472.0, 39.0), vec3(58819.0, 59472.0, 72.0), vec3(58819.0, 59472.0, 84.0), vec3(59472.0, 59683.0, 51.0), vec3(59472.0, 59683.0, 65.0), vec3(59472.0, 59683.0, 77.0), vec3(59683.0, 59894.0, 39.0), vec3(59683.0, 59894.0, 65.0), vec3(59683.0, 59894.0, 77.0), vec3(59894.0, 60115.0, 51.0), vec3(59894.0, 60115.0, 67.0), vec3(59894.0, 60115.0, 79.0), vec3(60115.0, 60326.0, 39.0), vec3(60115.0, 60326.0, 68.0), vec3(60115.0, 60326.0, 80.0), vec3(60326.0, 60547.0, 51.0), vec3(60326.0, 60547.0, 65.0), vec3(60326.0, 60547.0, 77.0), vec3(60576.0, 60979.0, 39.0), vec3(60787.0, 60979.0, 51.0), vec3(60576.0, 61190.0, 84.0), vec3(60576.0, 61219.0, 72.0), vec3(61008.0, 61440.0, 41.0), vec3(61219.0, 61440.0, 53.0), vec3(61219.0, 61440.0, 72.0), vec3(61219.0, 61440.0, 84.0), vec3(61440.0, 61651.0, 41.0), vec3(61440.0, 61651.0, 72.0), vec3(61440.0, 61651.0, 84.0), vec3(61651.0, 61776.0, 70.0), vec3(61651.0, 61776.0, 82.0), vec3(61651.0, 61872.0, 41.0), vec3(61651.0, 61872.0, 53.0), vec3(61776.0, 61872.0, 70.0), vec3(61776.0, 61872.0, 82.0), vec3(61872.0, 62083.0, 41.0), vec3(61872.0, 62083.0, 70.0), vec3(61872.0, 62083.0, 82.0), vec3(62112.0, 62208.0, 68.0), vec3(62112.0, 62208.0, 80.0), vec3(62112.0, 62294.0, 53.0), vec3(62208.0, 62294.0, 68.0), vec3(62208.0, 62294.0, 80.0), vec3(62333.0, 62515.0, 41.0), vec3(62333.0, 62515.0, 68.0), vec3(62333.0, 62515.0, 80.0), vec3(62544.0, 62726.0, 53.0), vec3(62544.0, 62726.0, 67.0), vec3(62544.0, 62726.0, 79.0), vec3(62755.0, 62966.0, 36.0), vec3(62755.0, 63062.0, 65.0), vec3(62755.0, 63062.0, 77.0), vec3(62966.0, 63187.0, 36.0), vec3(62966.0, 63187.0, 48.0), vec3(63062.0, 63370.0, 65.0), vec3(63062.0, 63370.0, 77.0), vec3(63187.0, 63398.0, 36.0), vec3(63187.0, 63398.0, 48.0), vec3(63398.0, 63619.0, 36.0), vec3(63398.0, 63619.0, 48.0), vec3(63398.0, 63619.0, 60.0), vec3(63398.0, 63619.0, 72.0), vec3(63619.0, 63830.0, 48.0), vec3(63619.0, 63955.0, 60.0), vec3(63619.0, 63955.0, 72.0), vec3(63619.0, 64042.0, 36.0), vec3(63830.0, 64042.0, 48.0), vec3(64042.0, 64262.0, 36.0), vec3(64042.0, 64262.0, 48.0), vec3(63955.0, 64262.0, 72.0), vec3(64262.0, 64474.0, 36.0), vec3(64262.0, 64474.0, 48.0), vec3(63955.0, 64474.0, 60.0), vec3(64262.0, 64474.0, 72.0), vec3(64262.0, 64474.0, 84.0), vec3(64474.0, 64934.0, 37.0), vec3(64694.0, 64934.0, 49.0), vec3(64934.0, 65146.0, 37.0), vec3(64934.0, 65146.0, 49.0), vec3(64502.0, 65146.0, 65.0), vec3(64502.0, 65146.0, 77.0), vec3(65146.0, 65366.0, 37.0), vec3(65146.0, 65366.0, 49.0), vec3(65146.0, 65366.0, 67.0), vec3(65146.0, 65366.0, 79.0), vec3(65366.0, 65578.0, 37.0), vec3(65366.0, 65578.0, 49.0), vec3(65366.0, 65578.0, 68.0), vec3(65366.0, 65578.0, 80.0), vec3(65578.0, 65798.0, 37.0), vec3(65578.0, 65798.0, 49.0), vec3(65578.0, 65798.0, 65.0), vec3(65578.0, 65798.0, 77.0), vec3(65798.0, 66010.0, 49.0), vec3(65798.0, 66221.0, 37.0), vec3(66010.0, 66221.0, 49.0), vec3(66221.0, 66442.0, 39.0), vec3(66221.0, 66442.0, 51.0), vec3(65798.0, 66442.0, 72.0), vec3(65798.0, 66442.0, 84.0), vec3(66442.0, 66653.0, 39.0), vec3(66442.0, 66653.0, 51.0), vec3(66442.0, 66682.0, 65.0), vec3(66470.0, 66682.0, 77.0), vec3(66653.0, 66845.0, 51.0), vec3(66653.0, 66883.0, 39.0), vec3(66682.0, 66883.0, 65.0), vec3(66682.0, 66883.0, 77.0), vec3(66883.0, 67094.0, 51.0), vec3(66883.0, 67094.0, 67.0), vec3(66883.0, 67094.0, 79.0), vec3(67094.0, 67315.0, 39.0), vec3(67094.0, 67315.0, 68.0), vec3(67094.0, 67315.0, 80.0), vec3(67315.0, 67526.0, 51.0), vec3(67315.0, 67526.0, 65.0), vec3(67344.0, 67526.0, 77.0), vec3(67555.0, 67958.0, 39.0), vec3(67776.0, 67958.0, 51.0), vec3(67555.0, 67958.0, 72.0), vec3(67555.0, 67958.0, 84.0), vec3(67987.0, 68419.0, 41.0), vec3(68208.0, 68419.0, 53.0), vec3(68419.0, 68630.0, 41.0), vec3(67987.0, 68811.0, 84.0), vec3(67987.0, 68870.0, 72.0), vec3(68630.0, 69082.0, 53.0), vec3(68870.0, 69082.0, 68.0), vec3(68870.0, 69302.0, 41.0), vec3(68630.0, 69302.0, 60.0), vec3(69082.0, 69302.0, 65.0), vec3(69082.0, 69514.0, 53.0), vec3(69302.0, 69734.0, 41.0), vec3(69514.0, 69734.0, 53.0), vec3(69302.0, 69734.0, 60.0), vec3(69302.0, 69734.0, 65.0), vec3(69082.0, 69734.0, 68.0), vec3(68870.0, 69734.0, 72.0), vec3(69734.0, 70070.0, 68.0), vec3(69734.0, 70166.0, 36.0), vec3(70166.0, 70598.0, 36.0), vec3(70070.0, 70598.0, 68.0), vec3(70378.0, 70777.0, 65.0), vec3(70598.0, 70838.0, 68.0), vec3(70598.0, 71050.0, 36.0), vec3(70838.0, 71050.0, 68.0), vec3(71059.0, 71318.0, 66.0), vec3(71050.0, 71491.0, 36.0), vec3(71270.0, 71491.0, 68.0), vec3(71491.0, 71702.0, 41.0), vec3(71491.0, 71702.0, 48.0), vec3(71491.0, 71702.0, 65.0), vec3(71491.0, 71702.0, 72.0));\n\n// Sound\n//------------------------------------------------------------------\nfloat pitch(float p) {\n    return pow(1.059460646483, p) * 440.0;\n}\n\n// https://www.shadertoy.com/view/4ffyDf\nvec2 soundNote(float noteFreq, float noteTime) {\n    vec2 eco = vec2(0.0);\n\n    float y = 0.5 * sin(6.2831 * 1.00 * noteFreq * noteTime) * exp(-0.0015 * 1.0 * noteFreq * noteTime);\n    y += 0.3 * sin(6.2831 * 2.01 * noteFreq * noteTime) * exp(-0.0015 * 2.0 * noteFreq * noteTime);\n    y += 0.2 * sin(6.2831 * 4.01 * noteFreq * noteTime) * exp(-0.0015 * 4.0 * noteFreq * noteTime);\n    y += 0.1 * y * y * y;\n    y *= 0.9 + 0.1 * sin(40.0 * noteTime);\n    y *= smoothstep(0.0, 0.1, noteTime);\n    for (int i = 0; i < 2; i++) {\n        float h = float(i) / 2.0;\n        eco += y * vec2(0.5 + 0.2 * h, 0.5 - 0.2 * h) * (1.0 - sqrt(h) * 0.85);\n    }\n    eco /= 3.0;\n    return eco;\n}\n\nvec2 bassTromboneSound(float noteFreq, float noteTime) {\n    noteFreq *= 0.25;\n    float y = 0.6 * sin(6.2831 * 0.5 * noteFreq * noteTime) * exp(-0.002 * noteFreq * noteTime);\n    y += 0.3 * sin(6.2831 * 1.0 * noteFreq * noteTime) * exp(-0.002 * noteFreq * noteTime);\n    y += 0.2 * sin(6.2831 * 1.5 * noteFreq * noteTime) * exp(-0.002 * noteFreq * noteTime);\n    y *= smoothstep(0.0, 0.1, noteTime) * (1.0 - smoothstep(0.8, 1.5, noteTime));\n    return vec2(y);\n}\n\nvec2 clarinetSound(float noteFreq, float noteTime) {\n    float y = 1.0 * sin(6.2831 * 1.00 * noteFreq * noteTime) * exp(-0.0008 * noteFreq * noteTime);\n    y += 0.7 * sin(6.2831 * 0.50 * noteFreq * noteTime) * exp(-0.0008 * noteFreq * noteTime);\n    y += 0.5 * sin(6.2831 * 0.25 * noteFreq * noteTime) * exp(-0.0008 * noteFreq * noteTime);\n    y *= smoothstep(0.0, 0.2, noteTime) * (1.0 - smoothstep(1.0, 2.0, noteTime));\n    return vec2(y);\n}\n\nvec2 pianoSound(float freq, float time) {\n    freq /= pow(2.0, 1.0 / 1.0);\n    float ph = 1.0;\n    ph *= sin(6.283185 * freq * time * 2.0);\n    ph *= 0.5 + 0.5 * max(0.0, 5.0 - 0.01 * freq);\n    ph *= exp(-time * freq * 0.2);\n\n    float y = 0.0;\n    y += 0.70 * sin(1.00 * 6.283185 * freq * time + ph) * exp2(-0.7 * 0.007 * freq * time);\n    y += 0.20 * sin(2.01 * 6.283185 * freq * time + ph) * exp2(-0.7 * 0.011 * freq * time);\n    y += 0.20 * sin(3.01 * 6.283185 * freq * time + ph) * exp2(-0.7 * 0.015 * freq * time);\n    y += 0.16 * sin(4.01 * 6.283185 * freq * time + ph) * exp2(-0.7 * 0.018 * freq * time);\n    y += 0.13 * sin(5.01 * 6.283185 * freq * time + ph) * exp2(-0.7 * 0.021 * freq * time);\n    y += 0.10 * sin(6.01 * 6.283185 * freq * time + ph) * exp2(-0.7 * 0.027 * freq * time);\n    y += 0.09 * sin(8.01 * 6.283185 * freq * time + ph) * exp2(-0.7 * 0.030 * freq * time);\n    y += 0.07 * sin(9.01 * 6.283185 * freq * time + ph) * exp2(-0.7 * 0.033 * freq * time);\n\n    y += 0.35 * y * y * y;\n    y += 0.10 * y * y * y;\n\n    y *= 1.0 + 1.5 * exp(-8.0 * time);\n    y *= clamp(time / 0.004, 0.0, 1.0);\n\n    y *= 2.5 - 1.5 * clamp(log2(freq) / 10.0, 0.0, 1.0);\n\n    float modulation = sin(6.283185 * 0.5 * freq * time);\n    y += 0.1 * sin(6.283185 * 1.5 * freq * time + modulation) * exp2(-0.7 * 0.007 * freq * time);\n    y += 0.08 * sin(6.283185 * 2.5 * freq * time + modulation) * exp2(-0.7 * 0.009 * freq * time);\n    y += 0.06 * sin(6.283185 * 3.5 * freq * time + modulation) * exp2(-0.7 * 0.011 * freq * time);\n\n    return vec2(y);\n}\n\nvec2 pianoWithPedal(float freq, float time) {\n    vec2 y = pianoSound(freq, time);\n    float pedalEffect = smoothstep(0.0, 0.5, mod(time, 3.0));\n    y *= 1.0 + 0.8 * pedalEffect;\n\n    return y;\n}\n\nvec2 fluteSound(float noteFreq, float noteTime) {\n    float y = 0.6 * sin(6.2831 * noteFreq * noteTime) * exp(-0.0015 * noteFreq * noteTime);\n    y += 0.4 * sin(6.2831 * noteFreq * noteTime * 2.0) * exp(-0.0015 * noteFreq * noteTime);\n    y += 0.2 * sin(6.2831 * noteFreq * noteTime * 3.0) * exp(-0.0015 * noteFreq * noteTime);\n    y *= smoothstep(0.0, 0.2, noteTime) * (1.0 - smoothstep(1.0, 2.0, noteTime));\n    return vec2(y);\n}\n\nvec2 yangqinSound(float noteFreq, float noteTime) {\n    noteFreq *= pow(1.5, 1.2);\n    float y = 0.8 * sin(6.2831 * noteFreq * noteTime) * exp(-0.005 * noteTime);\n    y += 0.5 * sin(6.2831 * 2.0 * noteFreq * noteTime) * exp(-0.005 * noteTime);\n    y += 0.3 * sin(6.2831 * 4.0 * noteFreq * noteTime) * exp(-0.005 * noteTime);\n    y *= smoothstep(0.0, 0.02, noteTime) * (1.0 - smoothstep(0.05, 0.1, noteTime));\n    return vec2(y);\n}\n//------------------------------------------------------------------\n\n// constant\n//------------------------------------------------------------------\n#define PI 3.1415926\n#define PI2 6.2831852\n\n#define M_PI radians(180.)\n//------------------------------------------------------------------\n\n// rendering & modeling\n//------------------------------------------------------------------\n#define PATH_LENGTH 19\n#define MAX_DIST 1e10\n\n#define ROT3X(x) mat4(1, 0, 0, 0, 0, cos(x), sin(x), 0, 0, -sin(x), cos(x), 0, 0, 0, 0, 1)\n#define ROT3Y(x) mat4(cos(x), 0, -sin(x), 0, 0, 1, 0, 0, sin(x), 0, cos(x), 0, 0, 0, 0, 1)\n#define ROT3Z(x) mat4(cos(x), sin(x), 0, 0,  -sin(x), cos(x), 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)\n#define TRANSLATE3(x, y, z) mat4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x, y ,z, 1)\n#define ROT2(x) mat2(cos(x), -sin(x), sin(x), cos(x))\n\n#define LAMBERTIAN 0.0\n#define METAL 1.0\n#define DIELECTRIC 2.0\n\nstruct Material {\n    float type;\n    vec3 albedo;\n    float roughness;\n    float metallic;\n};\n\nstruct Surface {\n    float dist_min;\n    float dist_max;\n    // Material mat;\n    int material_id;\n};\n\nSurface op_union(Surface s1, Surface s2) {\n    if (s2.dist_max < s1.dist_max) {\n        return s2;\n    } else {\n        return s1;\n    }\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(6.28318530718 * (c * t + d));\n}\n\nfloat checker_board(vec2 p) {\n    return mod(floor(p.x) + floor(p.y), 2.);\n}\n\nvec3 get_sky_color(vec3 rd) {\n    vec3 col = mix(vec3(1), vec3(.5, .7, 1), .5 + .5 * rd.y);\n    float sun = clamp(dot(normalize(vec3(-.4, .7, -.1)), rd), 0., 1.);\n    // col += vec3(1, .6, .1) * (pow(sun, 4.) + 10. * pow(sun, 32.));\n    return col;\n}\n\nmat3 set_camera(in vec3 origin, in vec3 target, float cam_roll) {\n    vec3 cw = normalize(target - origin);\n    vec3 cp = vec3(sin(cam_roll), cos(cam_roll), 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = (cross(cu, cw));\n    return mat3(-cu, cv, cw);\n}\n\nfloat hash1(inout float seed) {\n    seed = clamp(fract(sin(seed + 0.1) * 43758.5453123), 0.0, 1.0);\n    return seed;\n}\n\nvec2 hash2(inout float seed) {\n    vec2 x = clamp(fract(sin(vec2(seed + 0.1, seed + 0.2)) * vec2(43758.5453123, 22578.1459123)), vec2(0.0), vec2(1.0));\n    seed = x.x;\n    return x;\n}\n\nvec3 hash3(inout float seed) {\n    vec3 x = clamp(fract(sin(vec3(seed + 0.1, seed + 0.2, seed + 0.3)) * vec3(43758.5453123, 22578.1459123, 19642.3490423)), vec3(0.0), vec3(1.0));\n    seed = x.x;\n    return x;\n}\n\nuint base_hash(uvec2 p) {\n    p = 1103515245U * ((p >> 1U) ^ (p.yx));\n    uint h32 = 1103515245U * ((p.x) ^ (p.y >> 3U));\n    return h32 ^ (h32 >> 16);\n}\n\n// float hash1(inout float seed) {\n//     uint n = base_hash(floatBitsToUint(vec2(seed += .1, seed += .1)));\n//     return float(n) / float(0xffffffffU);\n// }\n\n// vec2 hash2(inout float seed) {\n//     uint n = base_hash(floatBitsToUint(vec2(seed += .1, seed += .1)));\n//     uvec2 rz = uvec2(n, n * 48271U);\n//     return vec2(rz.xy & uvec2(0x7fffffffU)) / float(0x7fffffff);\n// }\n\nfloat fresnel_schlick_roughness(float cosTheta, float F0, float roughness) {\n    return F0 + (max((1. - roughness), F0) - F0) * pow(abs(1. - cosTheta), 5.0);\n}\n\nvec3 cos_weighted_random_hemisphere_direction(const vec3 n, inout float seed) {\n    vec2 r = hash2(seed);\n    vec3 uu = normalize(cross(n, abs(n.y) > .5 ? vec3(1., 0., 0.) : vec3(0., 1., 0.)));\n    vec3 vv = cross(uu, n);\n    float ra = sqrt(r.y);\n    float rx = ra * cos(6.28318530718 * r.x);\n    float ry = ra * sin(6.28318530718 * r.x);\n    float rz = sqrt(1. - r.y);\n    vec3 rr = vec3(rx * uu + ry * vv + rz * n);\n    return normalize(rr);\n}\n\nvec3 modify_direction_with_roughness(const vec3 normal, const vec3 n, const float roughness, inout float seed) {\n    vec2 r = hash2(seed);\n\n    vec3 uu = normalize(cross(n, abs(n.y) > .5 ? vec3(1., 0., 0.) : vec3(0., 1., 0.)));\n    vec3 vv = cross(uu, n);\n\n    float a = roughness * roughness;\n\n    float rz = sqrt(abs((1.0 - r.y) / clamp(1. + (a - 1.) * r.y, .00001, 1.)));\n    float ra = sqrt(abs(1. - rz * rz));\n    float rx = ra * cos(6.28318530718 * r.x);\n    float ry = ra * sin(6.28318530718 * r.x);\n    vec3 rr = vec3(rx * uu + ry * vv + rz * n);\n\n    vec3 ret = normalize(rr);\n    return dot(ret, normal) > 0. ? ret : n;\n}\n\nvec2 random_in_unit_disk(inout float seed) {\n    vec2 h = hash2(seed) * vec2(1, 6.28318530718);\n    float phi = h.y;\n    float r = sqrt(h.x);\n    return r * vec2(sin(phi), cos(phi));\n}\n// Surface surf_op_union(Surface s1, Surface s2) {\n//     if (s1.d < s2.d) {\n//         return s1;\n//     } else {\n//         return s2;\n//     }\n// }\n\n// Surface surf_op_sub(Surface s1, Surface s2) {\n//     s2.d *= -1.0;\n//     if (s1.d > s2.d) {\n//         return s1;\n//     } else {\n//         return s2;\n//     }\n// }\n\n// Surface surf_op_smooth_union(Surface s1, Surface s2, float k) {\n//     float h = clamp(0.5 + 0.5 * (s2.d - s1.d) / k, 0.0, 1.0);\n\n//     vec3 p1 = vec3(s1.d, s1.mat.roughness, s1.mat.metallic), p2 = vec3(s2.d, s2.mat.roughness, s2.mat.metallic);\n//     p1 = mix(p2, p1, h) - k * h * (1.0 - h);\n\n//     s1.mat.albedo = mix(s2.mat.albedo, s1.mat.albedo, h) - k * h * (1.0 - h);\n//     s1.d = p1.x;\n//     s1.mat.roughness = p1.y;\n//     s1.mat.metallic = p1.z;\n//     return s1;\n// }\n\n// Surface surf_op_smooth_sub(Surface s1, Surface s2, float k) {\n//     float h = clamp(0.5 - 0.5 * (s2.d + s1.d) / k, 0.0, 1.0);\n//     vec3 p1 = vec3(s1.d, s1.mat.roughness, s1.mat.metallic), p2 = vec3(s2.d, s2.mat.roughness, s2.mat.metallic);\n//     p1 = mix(p2, -p1, h) + k * h * (1.0 - h);\n\n//     s1.mat.albedo = mix(s2.mat.albedo, s1.mat.albedo, h) - k * h * (1.0 - h);\n//     s1.d = p1.x;\n//     s1.mat.roughness = p1.y;\n//     s1.mat.metallic = p1.z;\n//     return s1;\n// }\n\n// Surface surf_op_smooth_intersection(Surface s1, Surface s2, float k) {\n//     float h = clamp(0.5 - 0.5 * (s2.d - s1.d) / k, 0.0, 1.0);\n//     vec3 p1 = vec3(s1.d, s1.mat.roughness, s1.mat.metallic), p2 = vec3(s2.d, s2.mat.roughness, s2.mat.metallic);\n//     p1 = mix(p2, p1, h) + k * h * (1.0 - h);\n\n//     s1.mat.albedo = mix(s2.mat.albedo, s1.mat.albedo, h) - k * h * (1.0 - h);\n//     s1.d = p1.x;\n//     s1.mat.roughness = p1.y;\n//     s1.mat.metallic = p1.z;\n//     return s1;\n// }\n\n// float op_union(float d1, float d2) {\n//     return min(d1, d2);\n// }\n\n// float op_inter(float d1, float d2) {\n//     return max(d1, d2);\n// }\n\n// float op_sub(float d1, float d2) {\n//     return max(d1, -d2);\n// }\n\n// float op_smooth_union(float d1, float d2, float k) {\n//     float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n//     return mix(d2, d1, h) - k * h * (1.0 - h);\n// }\n\n// float op_smooth_subtraction(float d1, float d2, float k) {\n//     float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n//     return mix(d2, -d1, h) + k * h * (1.0 - h);\n// }\n\n// float op_smooth_intersection(float d1, float d2, float k) {\n//     float h = clamp(0.5 - 0.5 * (d2 - d1) / k, 0.0, 1.0);\n//     return mix(d2, d1, h) + k * h * (1.0 - h);\n// }\n//------------------------------------------------------------------\n\n// Ray query\n//------------------------------------------------------------------\nfloat iPlane(\n    in vec3 ro,\n    in vec3 rd,\n    in vec2 distBound,\n    inout vec3 normal,\n    in vec3 planeNormal,\n    in float planeDist\n) {\n    float a = dot(rd, planeNormal);\n    float d = -(dot(ro, planeNormal) + planeDist) / a;\n    if (a > 0. || d < distBound.x || d > distBound.y) {\n        return MAX_DIST;\n    } else {\n        normal = planeNormal;\n        return d;\n    }\n}\n// Box:             https://www.shadertoy.com/view/ld23DV\nfloat iBox(\n    in vec3 ro,\n    in vec3 rd,\n    in vec2 distBound,\n    inout vec3 normal,\n    in vec3 boxSize\n) {\n    vec3 m = sign(rd) / max(abs(rd), 1e-8);\n    vec3 n = m * ro;\n    vec3 k = abs(m) * boxSize;\n\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n\n    if (tN > tF || tF <= 0.) {\n        return MAX_DIST;\n    } else {\n        if (tN >= distBound.x && tN <= distBound.y) {\n            normal = -sign(rd) * step(t1.yzx, t1.xyz) * step(t1.zxy, t1.xyz);\n            return tN;\n        } else if (tF >= distBound.x && tF <= distBound.y) {\n            normal = -sign(rd) * step(t1.yzx, t1.xyz) * step(t1.zxy, t1.xyz);\n            return tF;\n        } else {\n            return MAX_DIST;\n        }\n    }\n}\n\nfloat iCylinder(\n    in vec3 ro,\n    in vec3 rd,\n    in vec2 distBound,\n    inout vec3 normal,\n    in vec3 pa,\n    in vec3 pb,\n    float ra\n) {\n    vec3 ca = pb - pa;\n    vec3 oc = ro - pa;\n\n    float caca = dot(ca, ca);\n    float card = dot(ca, rd);\n    float caoc = dot(ca, oc);\n\n    float a = caca - card * card;\n    float b = caca * dot(oc, rd) - caoc * card;\n    float c = caca * dot(oc, oc) - caoc * caoc - ra * ra * caca;\n    float h = b * b - a * c;\n\n    if (h < 0.)\n        return MAX_DIST;\n\n    h = sqrt(h);\n    float d = (-b - h) / a;\n\n    float y = caoc + d * card;\n    if (y > 0. && y < caca && d >= distBound.x && d <= distBound.y) {\n        normal = (oc + d * rd - ca * y / caca) / ra;\n        return d;\n    }\n\n    d = ((y < 0. ? 0. : caca) - caoc) / card;\n\n    if (abs(b + a * d) < h && d >= distBound.x && d <= distBound.y) {\n        normal = normalize(ca * sign(y) / caca);\n        return d;\n    } else {\n        return MAX_DIST;\n    }\n}\n//------------------------------------------------------------------\n\n// 3d sdf\n//------------------------------------------------------------------\n// float dot2(in vec2 v) {\n//     return dot(v, v);\n// }\n// float dot2(in vec3 v) {\n//     return dot(v, v);\n// }\n// float sdRoundBox(vec3 p, vec3 b, float r) {\n//     vec3 q = abs(p) - b + r;\n//     return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - r;\n// }\n\n// float sdCappedCylinder(vec3 p, vec3 a, vec3 b, float r) {\n//     vec3 ba = b - a;\n//     vec3 pa = p - a;\n//     float baba = dot(ba, ba);\n//     float paba = dot(pa, ba);\n//     float x = length(pa * baba - ba * paba) - r * baba;\n//     float y = abs(paba - baba * 0.5) - baba * 0.5;\n//     float x2 = x * x;\n//     float y2 = y * y * baba;\n//     float d = (max(x, y) < 0.0) ? -min(x2, y2) : (((x > 0.0) ? x2 : 0.0) + ((y > 0.0) ? y2 : 0.0));\n//     return sign(d) * sqrt(abs(d)) / baba;\n// }\n\n// float sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2) {\n//     // sampling independent computations (only depend on shape)\n//     vec3 ba = b - a;\n//     float l2 = dot(ba, ba);\n//     float rr = r1 - r2;\n//     float a2 = l2 - rr * rr;\n//     float il2 = 1.0 / l2;\n\n//     // sampling dependant computations\n//     vec3 pa = p - a;\n//     float y = dot(pa, ba);\n//     float z = y - l2;\n//     float x2 = dot2(pa * l2 - ba * y);\n//     float y2 = y * y * l2;\n//     float z2 = z * z * l2;\n\n//     // single square root!\n//     float k = sign(rr) * rr * rr * x2;\n//     if (sign(z) * a2 * z2 > k)\n//         return sqrt(x2 + z2) * il2 - r2;\n//     if (sign(y) * a2 * y2 < k)\n//         return sqrt(x2 + y2) * il2 - r1;\n//     return (sqrt(x2 * a2 * il2) + y * rr) * il2 - r1;\n// }\n\n// float sdCappedCone(vec3 p, float h, float r1, float r2) {\n//     vec2 q = vec2(length(p.xz), p.y);\n//     vec2 k1 = vec2(r2, h);\n//     vec2 k2 = vec2(r2 - r1, 2.0 * h);\n//     vec2 ca = vec2(q.x - min(q.x, (q.y < 0.0) ? r1 : r2), abs(q.y) - h);\n//     vec2 cb = q - k1 + k2 * clamp(dot(k1 - q, k2) / dot2(k2), 0.0, 1.0);\n//     float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n//     return s * sqrt(min(dot2(ca), dot2(cb)));\n// }\n\n// float sdSphere(vec3 p, float s) {\n//     return length(p) - s;\n// }\n\n// float sdBox(vec3 p, vec3 b) {\n//     vec3 d = abs(p) - b;\n//     return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n// }\n\n// float sdCappedCylinder(vec3 p, float h, float r) {\n//     vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n//     return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n// }\n//------------------------------------------------------------------\n\n// 2d sdf\n//------------------------------------------------------------------\nfloat sdCircle(vec2 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdBox(in vec2 p, in vec2 b) {\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n//------------------------------------------------------------------\n\n// pbr stuff\n//------------------------------------------------------------------\n// float pow5(float x) {\n//     float pow2 = x * x;\n//     return pow2 * pow2 * x;\n// }\n\n// // https://blog.csdn.net/qq_28299311/article/details/123312767\n// vec3 DisneyDiffuse(float NdotV, float NdotL, float LdotH, float roughness, vec3 base_color) {\n//     float fd90 = 0.5 + 2.0 * LdotH * LdotH * roughness;\n//     // Two schlick fresnel term\n//     float light_scatter = (1.0 + (fd90 - 1.0) * pow5(1.0 - NdotL));\n//     float view_scatter = (1.0 + (fd90 - 1.0) * pow5(1.0 - NdotV));\n//     return (base_color / PI) * light_scatter * view_scatter;\n// }\n\n// // D\n// float D_GGX_TR(float NdotH, float roughness) {\n//     float a2 = roughness * roughness;\n//     float NdotH2 = NdotH * NdotH;\n//     float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n//     denom = PI * denom * denom;\n//     denom = max(denom, 0.001); //防止分母为0\n//     return a2 / denom;\n// }\n\n// // G\n// float GeometrySchlickGGX(float NdotV, float k) {\n//     float nom = NdotV;\n//     float denom = NdotV * (1.0 - k) + k;\n\n//     return nom / denom;\n// }\n\n// float GeometrySmith(float NdotV, float NdotL, float k) {\n//     float ggx1 = GeometrySchlickGGX(NdotV, k);\n//     float ggx2 = GeometrySchlickGGX(NdotL, k);\n\n//     return ggx1 * ggx2;\n// }\n\n// // F\n// vec3 F_Schlick(float HdotV, vec3 F0) {\n//     return F0 + (1.0 - F0) * pow(1.0 - HdotV, 5.0);\n// }\n\n// vec2 PrefilteredDFG_Karis(float roughness, float NoV) {\n//     // Karis 2014, \"Physically Based Material on Mobile\"\n//     const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n//     const vec4 c1 = vec4(1.0, 0.0425, 1.040, -0.040);\n\n//     vec4 r = roughness * c0 + c1;\n//     float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n\n//     return vec2(-1.04, 1.04) * a004 + r.zw;\n// }\n\n// vec3 Irradiance_SphericalHarmonics(const vec3 n) {\n//     // Irradiance from \"Ditch River\" IBL (http://www.hdrlabs.com/sibl/archive.html)\n//     return max(vec3(0.754554516862612, 0.748542953903366, 0.790921515418539) + vec3(-0.083856548007422, 0.092533500963210, 0.322764661032516) * (n.y) + vec3(0.308152705331738, 0.366796330467391, 0.466698181299906) * (n.z) + vec3(-0.188884931542396, -0.277402551592231, -0.377844212327557) * (n.x), 0.0);\n// }\n\nvec3 Tonemap_ACES(const vec3 x) {\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n//------------------------------------------------------------------","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// #define VSCODE\n\n#ifdef VSCODE\n#iChannel0 \"self\"\n#include \"3d_common.glsl\"\n#endif\n\n#define DIST(x) (vec2(x.dist_min, x.dist_max))\n\nint start;\nint end;\n\nSurface map(vec3 ro, vec3 rd, float dist_min, float dist_max, out vec3 normal) {\n\n    float time = iTime;\n    time *= SCALE;\n    time = mod(time, LEN);\n    // time = 1670.0;\n\n    Surface co = Surface(dist_min, dist_max, 0);\n\n    co = op_union(co, Surface(0.001, iPlane(ro, rd, DIST(co), normal, vec3(0, 1, 0), 0.0), 1));\n\n    for (int i = start; i <= end; ++i) {\n        vec3 s = sound[i];\n        float y_size = (s.y - s.x) / SCALE;\n        float y_size_h = y_size * 0.5;\n\n        float d = iBox(ro - vec3((s.z - 60.0) * 0.022, 0.04, (s.x - time) / SCALE + y_size_h), rd, DIST(co), normal, vec3(0.02, 0.01, y_size_h - KEY_MARGIN));\n        // float d = sdBox(pos - vec2((s.z - 64.0) * 0.022, (s.x - time) / SCALE + y_size_h), vec2(0.01, y_size_h - KEY_MARGIN));\n        Surface surf = Surface(0.001, d, 1);\n\n        if (s.x > time || time > s.y) {\n            surf.material_id = 3;\n        } else {\n            surf.material_id = 2;\n        }\n        co = op_union(co, surf);\n    }\n    // iBox(ro - vec3((s.z - 64.0) * 0.022, 0.04, (s.x - time) / SCALE + y_size_h), rd, DIST(co), normal, vec3(0.02, 0.01, y_size_h - KEY_MARGIN)\n    co = op_union(co, Surface(0.001, iBox(ro, rd, DIST(co), normal, vec3(1.0, 0.1, 0.02)), 4));\n\n    return co;\n}\n\nconst Material mats[3] = Material[3](Material(LAMBERTIAN, vec3(0.525, 0.521, 0.827), 0.3, 0.0), Material(DIELECTRIC, vec3(0.0, 0.0, 0.0), 0.8, 0.0), Material(DIELECTRIC, vec3(0.0, 0.0, 0.0), 0.02, 0.0));\nMaterial get_material_properties(vec3 pos, int mat_id) {\n    if (mat_id == 1) {\n        vec3 albedo = vec3(0.25 + 0.25 * checker_board(pos.xz * 5.0));\n        return Material(METAL, albedo, 0.75 * albedo.x - 0.15, 0.0);\n    } else if (mat_id > 1) {\n\n        return mats[mat_id - 2];\n    }\n}\n\nvec3 render(in vec3 ro, in vec3 rd, inout float seed) {\n    vec3 normal, col = vec3(1.);\n\n    for (int i = 0; i < PATH_LENGTH; ++i) {\n        // vec3 res = worldhit(ro, rd, vec2(.0001, 100), normal);\n        Surface co = map(ro, rd, 0.0001, 100.0, normal);\n\n        if (co.material_id > 0) {\n            ro += rd * co.dist_max;\n\n            Material mat = get_material_properties(ro, co.material_id);\n\n            if (mat.type < LAMBERTIAN + 0.5) { // Added/hacked a reflection term\n                float F = fresnel_schlick_roughness(max(0., -dot(normal, rd)), .04, mat.roughness);\n                if (F > hash1(seed)) {\n                    rd = modify_direction_with_roughness(normal, reflect(rd, normal), mat.roughness, seed);\n                } else {\n                    col *= mat.albedo;\n                    rd = cos_weighted_random_hemisphere_direction(normal, seed);\n                }\n            } else if (mat.type < METAL + 0.5) {\n                col *= mat.albedo;\n                rd = modify_direction_with_roughness(normal, reflect(rd, normal), mat.roughness, seed);\n            } else { // DIELECTRIC\n                vec3 normalOut, refracted;\n                float ni_over_nt, cosine, reflectProb = 1.;\n                if (dot(rd, normal) > 0.) {\n                    normalOut = -normal;\n                    ni_over_nt = 1.4;\n                    cosine = dot(rd, normal);\n                    cosine = sqrt(1. - (1.4 * 1.4) - (1.4 * 1.4) * cosine * cosine);\n                } else {\n                    normalOut = normal;\n                    ni_over_nt = 1. / 1.4;\n                    cosine = -dot(rd, normal);\n                }\n\n\t            // Refract the ray.\n                refracted = refract(normalize(rd), normalOut, ni_over_nt);\n\n        \t    // Handle total internal reflection.\n                if (refracted != vec3(0)) {\n                    float r0 = (1. - ni_over_nt) / (1. + ni_over_nt);\n                    reflectProb = fresnel_schlick_roughness(cosine, r0 * r0, mat.roughness);\n                }\n\n                rd = hash1(seed) <= reflectProb ? reflect(rd, normal) : refracted;\n                rd = modify_direction_with_roughness(-normalOut, rd, mat.roughness, seed);\n            }\n        } else {\n            col *= get_sky_color(rd);\n            return col;\n        }\n    }\n    return vec3(0);\n}\n\nvoid read_data(out vec4 data0) {\n    data0 = texelFetch(iChannel0, ivec2(0, 0), 0);\n    vec2 data1 = texelFetch(iChannel0, ivec2(1, 0), 0).xy;\n    start = floatBitsToInt(data1.x);\n    end = floatBitsToInt(data1.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    bool reset = iFrame == 0;\n    vec2 mo = iMouse.xy == vec2(0) ? vec2(.125) : abs(iMouse.xy) / iResolution.xy - .5;\n\n    vec4 data;\n    read_data(data);\n\n    if (round(mo * iResolution.xy) != round(data.yz) || round(data.w) != round(iResolution.x)) {\n        reset = true;\n    }\n\n    // vec3 ro = vec3(.5 + 2.5 * cos(1.5 + 6. * mo.x), 1. + 2. * mo.y, -.5 + 2.5 * sin(1.5 + 6. * mo.x));\n    vec3 ro = vec3(1.0 * cos(6.0 * mo.x), 1.0, -1.0 * sin(6.0 * mo.x)) * (mo.y + 0.5);\n    vec3 ta = vec3(0.0, 0.03, 0.0);\n    mat3 ca = set_camera(ro, ta, 0.);\n    ivec2 coord = ivec2(fragCoord);\n    if (coord.x == 0 && coord.y == 0) {\n        vec3 normal;\n        // Calculate focus plane.\n        float nfpd = map(ro, normalize(vec3(.5, 0, .5) - ro), 0.0, 100.0, normal).dist_max;\n        fragColor = vec4(nfpd, mo * iResolution.xy, iResolution.x);\n    } else if (coord.x == 1 && coord.y == 0) {\n        float time = iTime;\n        time *= SCALE;\n        time = mod(time, LEN);\n\n        int i_start = -1;\n        int i_end = -1;\n        for (int i = 0; i < SOUND_LENGTH; ++i) {\n            vec3 s = sound[i];\n            if (((time + 6000.0) > s.x && (time - 1000.0) < s.y)) {\n                i_end = i;\n            } else if (i_end == -1) {\n                i_start = i;\n            }\n\n        }\n        fragColor.r = intBitsToFloat(i_start);\n        fragColor.g = intBitsToFloat(i_end);\n\n    } else {\n        vec2 pos = (2.0 * fragCoord - vec2(iResolution.x, iResolution.y)) / iResolution.y;\n\n        float seed = float(base_hash(floatBitsToUint(pos - fract(1.12345314312 * iTime)))) / float(0xffffffffU);\n        // AA\n        // pos += 2. * hash2(seed) / iResolution.y;\n        // vec2 pos = (2.0 * fragCoord - vec2(iResolution.x, iResolution.y)) / iResolution.y;\n        // vec3 rd = ca * normalize(vec3(pos.xy, 1.6));  \n        vec3 col = vec3(0.0);\n\n        #define SSAA\n\n        #define NUM_SAMPLES 4\n        for (int i = 0; i < NUM_SAMPLES; ++i) {\n\n#ifdef SSAA\n            vec2 ssaa = hash2(seed);\n#else\n            vec2 ssaa = vec2(.5);\n#endif\n\n            pos = (2.0 * (fragCoord + ssaa) - vec2(iResolution.x, iResolution.y)) / iResolution.y;\n            vec3 rd = ca * normalize(vec3(pos.xy, 1.6));  \n\n            // DOF\n            // float fpd = data.x;\n            // vec3 fp = ro + rd * fpd;\n            // ro = ro + ca * vec3(random_in_unit_disk(seed), 0.) * .01;\n            // rd = normalize(fp - ro);\n            // vec2 screenCoord = vec2(2. / iResolution.x) * (fragCoord + ssaa) -\n            //     vec2(1., iResolution.y / iResolution.x);\n\n            // vec3 projCoord = vec3(vec2(.5 * FRAME_WIDTH) * screenCoord, FOCAL_LENGTH);\n\n            // vec3 rayDirection = cameraTransform * normalize(projCoord);\n\n            col += render(ro, rd, seed);\n        }\n        col /= vec3(NUM_SAMPLES);\n\n        fragColor = vec4(col, 1);\n        // if (reset) {\n        // } else {\n        //     fragColor = vec4(col, 1);\n        //     // fragColor = vec4(col, 1) * 1.0 + texelFetch(iChannel0, ivec2(fragCoord), 0) * 0.5;\n        // }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"vec2 mainSound(int samp, float time) {\n    time *= SCALE;\n    time = mod(time, LEN);\n\n    vec2 res = vec2(0.0);\n\n    for (int i = 0; i < SOUND_LENGTH; ++i) {\n        vec3 s = sound[i];\n        if (time > s.x && time < s.y) {\n            res += INSTRUMENT(pitch(s.z - 69.0), (time - s.x) / SCALE);\n        }\n    }\n    return res * exp(VOL);\n}","name":"Sound","description":"","type":"sound"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// #define VSCODE\n\n#ifdef VSCODE\n#iChannel0 \"file://3d_buffer_a.glsl\"\n#include \"3d_common.glsl\"\n#endif\n\n#define DIST(x) (vec2(x.dist_min, x.dist_max))\n\nint start;\nint end;\n\nSurface map(vec3 ro, vec3 rd, float dist_min, float dist_max, out vec3 normal) {\n    float time = iTime;\n    time *= SCALE;\n    time = mod(time, LEN);\n\n    Surface co = Surface(dist_min, dist_max, 0);\n\n    co = op_union(co, Surface(0.001, iPlane(ro, rd, DIST(co), normal, vec3(0, 1, 0), 0.0), 1));\n\n    for (int i = start; i <= end; ++i) {\n        vec3 s = sound[i];\n        float y_size = (s.y - s.x) / SCALE;\n        float y_size_h = y_size * 0.5;\n\n        float d = iBox(ro - vec3((s.z - 60.0) * 0.022, 0.04, (s.x - time) / SCALE + y_size_h), rd, DIST(co), normal, vec3(0.02, 0.01, y_size_h - KEY_MARGIN));\n        // float d = sdBox(pos - vec2((s.z - 64.0) * 0.022, (s.x - time) / SCALE + y_size_h), vec2(0.01, y_size_h - KEY_MARGIN));\n        Surface surf = Surface(0.001, d, 1);\n\n        if (s.x > time || time > s.y) {\n            surf.material_id = 3;\n        } else {\n            surf.material_id = 2;\n        }\n        co = op_union(co, surf);\n    }\n\n    co = op_union(co, Surface(0.001, iBox(ro, rd, DIST(co), normal, vec3(1.0, 0.1, 0.02)), 4));\n\n    return co;\n}\n\nvec3 render(in vec3 ro, in vec3 rd, inout float seed) {\n    vec3 normal;\n\n    Surface co = map(ro, rd, 0.0001, 100.0, normal);\n    if (co.material_id > 0) {\n        return normal;\n    } else {\n        return vec3(0.0);\n    }\n}\n\nvoid read_data(out vec4 data0) {\n    data0 = texelFetch(iChannel0, ivec2(0, 0), 0);\n    vec2 data1 = texelFetch(iChannel0, ivec2(1, 0), 0).xy;\n    start = floatBitsToInt(data1.x);\n    end = floatBitsToInt(data1.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 mo = iMouse.xy == vec2(0) ? vec2(.125) : abs(iMouse.xy) / iResolution.xy - .5;\n\n    vec4 data;\n    read_data(data);\n\n    // vec3 ro = vec3(.5 + 2.5 * cos(1.5 + 6. * mo.x), 1. + 2. * mo.y, -.5 + 2.5 * sin(1.5 + 6. * mo.x));\n    vec3 ro = vec3(1.0 * cos(6.0 * mo.x), 1.0, -1.0 * sin(6.0 * mo.x)) * (mo.y + 0.5);\n    vec3 ta = vec3(0.0, 0.03, 0.0);\n    mat3 ca = set_camera(ro, ta, 0.);\n\n    vec2 pos = (2.0 * fragCoord - vec2(iResolution.x, iResolution.y)) / iResolution.y;\n\n    float seed;\n    // AA\n    // pos += 2. * hash2(seed) / iResolution.y;\n    vec3 rd = ca * normalize(vec3(pos.xy, 1.6));  \n\n    // DOF\n    // float fpd = data.x;\n    // vec3 fp = ro + rd * fpd;\n    // ro = ro + ca * vec3(random_in_unit_disk(seed), 0.) * .02;\n    // rd = normalize(fp - ro);\n\n    vec3 col = render(ro, rd, seed);\n\n    fragColor = vec4(col, 1);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// #define VSCODE\n\n#ifdef VSCODE\n#iChannel0 \"file://3d_buffer_a.glsl\"\n#iChannel1 \"file://3d_buffer_b.glsl\"\n#endif\n\nconst float denoiseStrength = 1.0;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 offset[25];\n    offset[0] = vec2(-2, -2);\n    offset[1] = vec2(-1, -2);\n    offset[2] = vec2(0, -2);\n    offset[3] = vec2(1, -2);\n    offset[4] = vec2(2, -2);\n\n    offset[5] = vec2(-2, -1);\n    offset[6] = vec2(-1, -1);\n    offset[7] = vec2(0, -1);\n    offset[8] = vec2(1, -1);\n    offset[9] = vec2(2, -1);\n\n    offset[10] = vec2(-2, 0);\n    offset[11] = vec2(-1, 0);\n    offset[12] = vec2(0, 0);\n    offset[13] = vec2(1, 0);\n    offset[14] = vec2(2, 0);\n\n    offset[15] = vec2(-2, 1);\n    offset[16] = vec2(-1, 1);\n    offset[17] = vec2(0, 1);\n    offset[18] = vec2(1, 1);\n    offset[19] = vec2(2, 1);\n\n    offset[20] = vec2(-2, 2);\n    offset[21] = vec2(-1, 2);\n    offset[22] = vec2(0, 2);\n    offset[23] = vec2(1, 2);\n    offset[24] = vec2(2, 2);\n\n    float kernel[25];\n    kernel[0] = 1.0 / 256.0;\n    kernel[1] = 1.0 / 64.0;\n    kernel[2] = 3.0 / 128.0;\n    kernel[3] = 1.0 / 64.0;\n    kernel[4] = 1.0 / 256.0;\n\n    kernel[5] = 1.0 / 64.0;\n    kernel[6] = 1.0 / 16.0;\n    kernel[7] = 3.0 / 32.0;\n    kernel[8] = 1.0 / 16.0;\n    kernel[9] = 1.0 / 64.0;\n\n    kernel[10] = 3.0 / 128.0;\n    kernel[11] = 3.0 / 32.0;\n    kernel[12] = 9.0 / 64.0;\n    kernel[13] = 3.0 / 32.0;\n    kernel[14] = 3.0 / 128.0;\n\n    kernel[15] = 1.0 / 64.0;\n    kernel[16] = 1.0 / 16.0;\n    kernel[17] = 3.0 / 32.0;\n    kernel[18] = 1.0 / 16.0;\n    kernel[19] = 1.0 / 64.0;\n\n    kernel[20] = 1.0 / 256.0;\n    kernel[21] = 1.0 / 64.0;\n    kernel[22] = 3.0 / 128.0;\n    kernel[23] = 1.0 / 64.0;\n    kernel[24] = 1.0 / 256.0;\n\n    vec4 sum = vec4(0.0);\n    float c_phi = 1.0;\n    float n_phi = 0.5;\n    //float p_phi = 0.3;\n    vec4 cval = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec4 nval = texelFetch(iChannel1, ivec2(fragCoord), 0);\n\t//vec4 pval = texelFetch(iChannel2, ivec2(fragCoord), 0);\n\n    float cum_w = 0.0;\n    for (int i = 0; i < 25; i++) {\n        vec2 uv = fragCoord + offset[i] * denoiseStrength;\n\n        vec4 ctmp = texelFetch(iChannel0, ivec2(uv), 0);\n        vec4 t = cval - ctmp;\n        float dist2 = dot(t, t);\n        float c_w = min(exp(-(dist2) / c_phi), 1.0);\n\n        vec4 ntmp = texelFetch(iChannel1, ivec2(uv), 0);\n        t = nval - ntmp;\n        dist2 = max(dot(t, t), 0.0);\n        float n_w = min(exp(-(dist2) / n_phi), 1.0);\n\n        //vec4 ptmp = texelFetch(iChannel2, ivec2(uv), 0);\n        //t = pval - ptmp;\n        //dist2 = dot(t,t);\n        //float p_w = min(exp(-(dist2)/p_phi), 1.0);\n\n        //float weight = c_w*n_w*p_w;\n        float weight = c_w * n_w;\n        sum += ctmp * weight * kernel[i];\n        cum_w += weight * kernel[i];\n    }\n    fragColor = sum / cum_w;\n\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// #define VSCODE\n\n#ifdef VSCODE\n#iChannel0 \"file://3d_buffer_c.glsl\"\n#iChannel1 \"self\"\n#endif\n\n// Temporal AA based on Epic Games' implementation:\n// https://de45xmedrsdbp.cloudfront.net/Resources/files/TemporalAA_small-59732822.pdf\n// \n// Originally written by yvt for https://www.shadertoy.com/view/4tcXD2\n// Feel free to use this in your shader!\n\n// YUV-RGB conversion routine from Hyper3D\nvec3 encodePalYuv(vec3 rgb) {\n    rgb = pow(rgb, vec3(2.0)); // gamma correction\n    return vec3(dot(rgb, vec3(0.299, 0.587, 0.114)), dot(rgb, vec3(-0.14713, -0.28886, 0.436)), dot(rgb, vec3(0.615, -0.51499, -0.10001)));\n}\n\nvec3 decodePalYuv(vec3 yuv) {\n    vec3 rgb = vec3(dot(yuv, vec3(1., 0., 1.13983)), dot(yuv, vec3(1., -0.39465, -0.58060)), dot(yuv, vec3(1., 2.03211, 0.)));\n    return pow(rgb, vec3(1.0 / 2.0)); // gamma correction\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // split screen\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 lastColor = texture(iChannel1, uv);\n\n    vec3 antialiased = lastColor.xyz;\n    float mixRate = min(lastColor.w, 0.5);\n\n    vec2 off = 1.0 / iResolution.xy;\n    vec3 in0 = texture(iChannel0, uv).xyz;\n\n    antialiased = mix(antialiased * antialiased, in0 * in0, mixRate);\n    antialiased = sqrt(antialiased);\n\n    vec3 in1 = texture(iChannel0, uv + vec2(+off.x, 0.0)).xyz;\n    vec3 in2 = texture(iChannel0, uv + vec2(-off.x, 0.0)).xyz;\n    vec3 in3 = texture(iChannel0, uv + vec2(0.0, +off.y)).xyz;\n    vec3 in4 = texture(iChannel0, uv + vec2(0.0, -off.y)).xyz;\n    vec3 in5 = texture(iChannel0, uv + vec2(+off.x, +off.y)).xyz;\n    vec3 in6 = texture(iChannel0, uv + vec2(-off.x, +off.y)).xyz;\n    vec3 in7 = texture(iChannel0, uv + vec2(+off.x, -off.y)).xyz;\n    vec3 in8 = texture(iChannel0, uv + vec2(-off.x, -off.y)).xyz;\n\n    antialiased = encodePalYuv(antialiased);\n    in0 = encodePalYuv(in0);\n    in1 = encodePalYuv(in1);\n    in2 = encodePalYuv(in2);\n    in3 = encodePalYuv(in3);\n    in4 = encodePalYuv(in4);\n    in5 = encodePalYuv(in5);\n    in6 = encodePalYuv(in6);\n    in7 = encodePalYuv(in7);\n    in8 = encodePalYuv(in8);\n\n    vec3 minColor = min(min(min(in0, in1), min(in2, in3)), in4);\n    vec3 maxColor = max(max(max(in0, in1), max(in2, in3)), in4);\n    minColor = mix(minColor, min(min(min(in5, in6), min(in7, in8)), minColor), 0.5);\n    maxColor = mix(maxColor, max(max(max(in5, in6), max(in7, in8)), maxColor), 0.5);\n\n    vec3 preclamping = antialiased;\n    antialiased = clamp(antialiased, minColor, maxColor);\n\n    mixRate = 1.0 / (1.0 / mixRate + 1.0);\n\n    vec3 diff = antialiased - preclamping;\n    float clampAmount = dot(diff, diff);\n\n    mixRate += clampAmount * 4.0;\n    mixRate = clamp(mixRate, 0.05, 0.5);\n\n    antialiased = decodePalYuv(antialiased);\n\n    fragColor = vec4(antialiased, mixRate);\n}","name":"Buffer D","description":"","type":"buffer"}]}