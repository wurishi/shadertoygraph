{"ver":"0.1","info":{"id":"3lXcDH","date":"1591916493","viewed":132,"name":"Light study / RayMarching","username":"photonic","description":"Raymarching and light study","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","light","ambient"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Takes a point in the space\n\n#define FAR 20.\n\n\nfloat map( in vec3 pos )\n{\n    \n \tfloat d1 = length(pos)-0.25;\n    \n    float d2 = pos.y - ( - 0.25);\n\n    float t = iTime*10.0;\n    vec3 rotation = vec3(sin(t), 0.0, cos(t));\n    pos += rotation / 3.0;\n    float d3 = length(pos)- 0.05;\n    \n    return min(min(d1, d3), d2);\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(0.0001, 0.0);\n \treturn normalize ( vec3(map(pos+e.xyy)-map(pos-e.xyy),\n                           \tmap(pos+e.yxy)-map(pos-e.yxy),\n                           \tmap(pos+e.yyx)-map(pos-e.yyx) ) );   \n}\n\nfloat castRay( in vec3 ro, vec3 rd ) {\n  float t = 0.0;\n    for (int i=0; i<100; i++)\n    {\n    \tvec3 pos = ro + t*rd;\n        float h = map( pos );\n        // h < 0.001 means that we are inside the sphere\n        if(h<0.001 || t>FAR ) break;\n        t += h;\n        if ( t>FAR ) break;\n    }   \n    if (t>FAR) t = -1.0;\n    \n    return t;\n}\n\n//Code provided by @Shane , thanks man!\nfloat soft(vec3 ro, vec3 ld, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable...\n    const int maxIterationsShad = 32; \n    \n    float shade = 1.0;\n    float t = 0.; \n    float end = FAR;//max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n  \n    vec3 rd = ld;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        //shade = min(shade, k*d/t);\n        // Subtle difference. Thanks to IQ for this tidbit. I've tweaked this just a little to \n        // help with shadow overlap... Well, I think it helps, but who knows? \n        shade = min(shade, smoothstep(.25, .75, k*d/t));\n        // So many options here, and none are perfect: dist += min(h, .2), \n        // dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .025, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. \n    return max(shade, 0.); \n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    //CAMERA\n    float an = -iMouse.x/iResolution.x * 10.;\n\tvec3 ro = vec3(1.0*sin(an), 0.0, 1.0*cos(an));\n\tvec3 ta = vec3(0.0, 0.0, 0.0);\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize( cross(ww, vec3(0,1,0)) );\n    vec3 vv = normalize( cross(uu,ww) );\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );    \n    \n    vec3 col = vec3(0.4,0.7,0.9) - .8*rd.y;\n    //col = mix( col, vec3(0.7, 0.75, 0.85), exp(-10.0*rd.y) );\n\t\n   \n    float t = castRay( ro, rd );\n    if ( t > 0.0 )\n    {\n\t\tvec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\t\t\n        vec3 mate = vec3(0.18);\n        \n        vec3 sunpos = vec3(0.8, 0.4, 0.2);\n        vec3 sun_dir = normalize(vec3(0.8, 0.4,0.2 ) );\n        float sun_dif = clamp( dot(nor, sun_dir), 0.0, 1.0);\n        //float sun_shadow = soft(pos + nor*0.0011, sun_dir, nor, 12.);\n       \tfloat sun_shadow = softshadow(pos, sun_dir, 0.1, 1.0, 2.0); \n        float sky_dif = clamp( 0.5 + 0.5*dot(nor, vec3(0.0, 1.0, 0.0)), 0.0, 1.0); \n        float bou_dif = clamp( 0.5 + 0.5*dot(nor, vec3(0.0, -1.0, 0.0)), 0.0, 1.0); \n        \n        col = mate*vec3(7.0, 4.5, 3.0)*sun_dif*sun_shadow;   \n        col += mate*vec3(0.5, 0.8, 0.9)*sky_dif;\n        col += mate*vec3(0.7, 0.3, 0.2)*bou_dif* 5.0;\n\n    }\n    \n    col = pow( col, vec3(0.4545));\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}