{"ver":"0.1","info":{"id":"WtyyRR","date":"1610288082","viewed":200,"name":"cubes on background (illusion)","username":"sukupaper","description":"I've seen a lot's of optical illusion like this on twitter, so I wanted to do my own one.","likes":21,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","cubes","checkerboard","opticalillusion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Author: paperu\n// Title: cubes on background\n\nfloat anim2(in float x, in float y, in float s) { return  smoothstep(-s,s,abs(mod(x,y) - y*.5) - y*.25); }\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st = fragCoord.xy/iResolution.xy;\n    float aa = 1./max(iResolution.x,iResolution.y);\n    \n    float t = iTime*.25;\n    float a = 1. - pow(1.-anim2(t,1.,.25),20.);\n    \n    vec4 tex = texture(iChannel0, st).rgba;\n    float d = tex.a;\n    vec3 color = vec3(\n        texture(iChannel0,st + vec2(aa,0.)).r,\n        texture(iChannel0,st - vec2(0.,aa)).g,\n        texture(iChannel0,st - vec2(aa)).b\n    );\n    \n    const float maxB = 8.;\n    vec3 blurColor = vec3(0.);\n    for(float i = -maxB*.5; i < maxB*.5; i++)\n        for(float j = -maxB*.5; j < maxB*.5; j++)\n            blurColor += texture(iChannel0,st + vec2(i,j)*aa*2.).rgb;\n    blurColor /= maxB*maxB;\n    \n    \n    color = mix(color, blurColor, a*clamp(abs(d - .8)*3.,0.,1.));\n    \n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Author: paperu\n// Title: cubes on background\n\n#define PRC .0005\n#define MAX_IT 70\n\n#define P 3.14159265359\n#define US 1./6.\n#define UT 1./3.\n\nfloat t, fmode;\nbool mode;\nvec3 colorA, colorB;\n\nmat2 rot(in float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat rcub(in vec3 p, in float s, in float r) { return length(max(abs(p) - s, 0.)) - r; }\nfloat cub(in vec3 p, in float s) { float sm = 0.05 - .049999*fmode; return rcub(p,s - sm,sm); }\nfloat anim1(in float x, in float s) { x += .5; return smoothstep(-s,s,mod(x, 1.) - .5) + floor(x); }\nfloat anim2(in float x, in float y, in float s) { return  smoothstep(-s,s,abs(mod(x,y) - y*.5) - y*.25); }\n\nfloat df(in vec3 p) {\n    float a = anim1(t,.45)*P;\n    p.xy *= rot(mode ? 0. : P*.5);\n    p.yz *= rot(a*.5);\n    p.xz *= rot(a*1.);\n    return mode\n        ? min(min(cub(vec3(abs(p.x) - UT,p.yz - UT), US), cub(vec3(abs(p.x) - UT,p.yz + UT), US)),cub(p, US))\n        : min(cub(vec3(abs(p.x) - UT,p.yz), US), min(cub(vec3(p.y - UT,p.x,p.z + UT), US), cub(vec3(p.y + UT,p.x,p.z - UT), US)));\n}\n\nvec3 normal(in vec3 p) { vec2 u = vec2(0., PRC); float d = df(p); return normalize(vec3(df(p + u.yxx), df(p + u.xyx), df(p + u.xxy)) - d); }\n\nstruct rmres { vec3 p; bool h; int i; };\nrmres rm(in vec3 c, in vec3 r, in float maxD) {\n    rmres res;\n    vec3 p = c;\n    bool h = false;\n    for(int i = 0; i < MAX_IT; i++) {\n        float d = df(p);\n        if(d < PRC) { h = true; break; }\n        if(distance(c, p) > maxD) { res.i = i; break; }\n        p += r*d;\n    }\n    res.p = p;\n    res.h = h;\n    return res;\n}\n\nvec3 material(in vec3 r, in vec3 n, in vec3 l) {\n    float diff = clamp(dot(n,l),.0,1.);\n    float spec = min(pow(max(dot(reflect(r,n),l),0.),50.),1.);\n\n    vec3 color = mix(colorA, colorB, .5*(diff + spec));\n    color += vec3(pow(1.-dot(-r,n),3.));\n    \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st = (fragCoord.xy - .5*iResolution.xy)/iResolution.x;\n    \n    t = iTime*.25;\n    \n    mode = cos(t*P) > 0.;\n    fmode = pow(anim2(t+.5,1.,.25),2.);\n    \n    float foc = 40. - 39.*(1.-pow(1.-anim2(t,1.,.25),30.));\n    vec3 c = vec3(0.,0.,-foc), r = normalize(vec3(st,foc));\n    \n    rmres res = rm(c, r, 50.);\n\t\n    colorA = vec3(0.); colorB = vec3(1.);\n    vec3 color = mode ? colorB : colorA;\n    \n    if(res.h) {\n        vec3 n = normal(res.p);\n        vec3 l = normalize(vec3(0.,0.,mode ? 1. : -1.));\n        vec3 ref = reflect(r,n);\n        \n        if(foc > 10.) {\n            color = material(r, n, l);\n        } else {\n            rmres res2 = rm(res.p - r*PRC*2., ref, 5.);\n            if(res2.h) {\n                vec3 n = normal(res2.p);\n                color = material(r, n, l)*material(ref, n, l);\n            } else\n                color = material(r, n, l);\n        }\n    }\n                \n    float ao = float(res.i)/float(MAX_IT);\n    color += ao*ao*(1.-fmode);\n    \n    float l = length(st);\n    float d = distance(c, res.p);\n    fragColor = vec4(min(color, 1.) - l*l*.8,d);\n}","name":"Buffer A","description":"","type":"buffer"}]}