{"ver":"0.1","info":{"id":"3djSDt","date":"1555342289","viewed":250,"name":"Bartlett filter example","username":"vchizhov","description":"Illustration of Bartlett filter convolution for the tutorial in IPCV at Saarland university. W/S for increasing/decreasing the radius.","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["filter","imageprocessing","bartlett","tent","trianglefunction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Output to screen\n    fragColor = vec4(texture(iChannel0,fragCoord/iResolution.xy).xyz,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n/*\n\t@author: Vassillen Chizhov, 15.04.2019\n\n\tThe barttlet function in 2D is: \n\tf(r) = 1 - min(1, r/R), where r = sqrt(x^2+y^2)\n\tWe want to find a constant such that it integrates to 1:\n\tI_[0,2pi]x[0,R](f(r)r dr dphi) = 2pi(R^2/2 - R^2/3) = R^2 * pi / 3\n\tC = 3 / (pi * R^2)\n\n*/\n#define PI 3.141592653589793238\n\n// radius is given in pixels\nvec3 convolveBartlett(in sampler2D channel, vec2 coord, float radius, vec2 scale)\n{\n    vec2 delta = 1.0/scale;\n    vec2 uv = coord * delta;\n    ivec2 pos = ivec2(round(coord));\n    int uR = int(ceil(radius));\n    float R = float(uR);\n    vec3 acc = vec3(0);\n    float normalizationConstant = 3.0 / (PI * R*R);\n    for(int y = pos.y - uR; y <= pos.y + uR;++y)\n        for(int x = pos.x - uR; x <= pos.x + uR;++x)\n        {\n            vec2 xy = vec2(x,y);\n            float mag = length(xy-coord);\n            float weight = 1.0 - clamp(mag/R, 0.0, 1.0);\n            vec3 smp = texture(channel, xy * delta).xyz;\n            acc += weight * smp;\n        }\n    return normalizationConstant*acc;\n}\n\nfloat keyDown(int ascii) {\n\treturn float(texture(iChannel1,vec2((.5+float(ascii))/256.,0.25)).x > 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{;\n    float radius = clamp(texelFetch(iChannel3, ivec2(0), 0).a, 1.0, 20.0);\n    vec4 col = vec4(convolveBartlett(iChannel0, fragCoord, radius, iResolution.xy),1.0);\n \tif(all(equal(uvec2(fragCoord),uvec2(0))))\n    {\n        float sensitivity = 1.0;\n        radius += keyDown(87) - keyDown(83);\n        col.a = radius;\n    }\n    fragColor = vec4(col);\n}","name":"Buffer A","description":"","type":"buffer"}]}