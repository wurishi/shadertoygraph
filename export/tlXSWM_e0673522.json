{"ver":"0.1","info":{"id":"tlXSWM","date":"1563142604","viewed":366,"name":"Signed Distance Helix","username":"willalexander","description":"Helix intersection using ray marching","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float a = 0.2;\nfloat r = 1.0;\nfloat helixThickRad = 0.3;\nfloat threshold = 0.001;\nfloat zeroThreshold = 0.001;\n\nfloat TWOPI = 6.283;\nfloat PI = 3.14159;\n\nvec3 sphereP = vec3(0.0, 0.0, 0.0);\nfloat sphereRad = 1.0;\n\n\nfloat f(float t, vec3 P)\n{\n   \tfloat a = 0.8 + 0.7 * sin(2.0 * iTime);\n    return r*r + length(P)*length(P) + 2.0*P.x*r*sin(t) - 2.0*P.z*r*cos(t) + a*a*t*t - 2.0*a*t*P.y;\n}\n\nfloat f1(float t, vec3 P)\n{\n    float a = 0.8 + 0.7 * sin(2.0 * iTime);\n    return 2.0*P.x*r*cos(t) + 2.0*P.z*r*sin(t) + 2.0*a*a*t - 2.0*a*P.y;\n}\n\nbool sameSign(float a, float b)\n{\n    if((a >= 0.0)&&(b >= 0.0)) return true;\n    if((a < 0.0)&&(b < 0.0)) return true;\n    return false;\n}\n\n\nfloat findSolution(float t1, float t2, vec3 P)\n{\n   \tif((f1(t1, P) > 0.0)&&(f1(t2, P) < 0.0)) return 1000000.0;\n    \n\tfloat thalf;\n\tfor(int i = 0; i < 10; i++)\n\t{\n\t\tthalf = 0.5 * (t1 + t2);\n\t\tfloat gradHalf = f1(thalf, P);\n\t\tif(abs(gradHalf) < 0.01) break;\n\n\t\tfloat d2_1 = f1(t1, P);\n\t\tfloat d2_half = gradHalf;\n\t\tfloat d2_2 = f1(t2, P);\n        \n\t\tif(sameSign(d2_1, d2_half) == false)\n\t\t{\n\t\t\tt2 = thalf;\n\t\t\tcontinue;\n\t\t}\n\n\t\tt1 = thalf;\n\t}\n\n\treturn thalf;\n}\n\nfloat helixDist(vec3 P, out float tout)\n{\n   \tfloat a = 0.8 + 0.7 * sin(2.0 * iTime);\n    \n\tfloat t0 = P.y / a;\n\t\n\tfloat closest = f(t0, P);\n\tfloat closestT = t0;\n\n    \n    for(float i = 0.0; i < 4.0; i+=1.0)\n    {\n        float tTest = findSolution(t0 + (i - 2.0)*PI, t0 + (i - 1.0)*PI, P);\n        float dTest = f(tTest, P);\n        \n        if(dTest < closest)\n        {\n            closest = dTest;\n\t\t\tclosestT = tTest;\n        }\n    }\n  \n\ttout = closestT;\n\treturn sqrt(closest);\n}\n\nvec3 helixPos(float t)\n{\n    float a = 0.8 + 0.7 * sin(2.0 * iTime);\n    \n    return vec3(-1.0 * r * sin(t), a * t, r * cos(t));\n}\n\nbool rayMarchHelix(vec3 rayPos, vec3 rayDir, out vec3 Pout, out vec3 Nout, out int countout)\n{   \n    vec3 P = rayPos;\n    float t;\n    float dist = helixDist(P, t) - helixThickRad;\n    \n    int count = 0;\n    \n    while(dist > threshold)\n    {\n        P += dist * rayDir;\n        if(P.z > 2.2) return false;\n            \n        dist = helixDist(P, t) - helixThickRad;\n       \n        if(count == 128) return false;\n        \n        count++;\n    }\n    \n    Pout = P + dist * rayDir;\n    Nout = normalize(Pout - helixPos(t));\n    countout = count;\n    \n    return true;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 imgPlane = 5.0 * (2.0 / iResolution.x) * vec2(fragCoord.x - 0.5*iResolution.x, fragCoord.y - 0.5 * iResolution.y);\n   \n    vec3 rayPos = vec3(0.0, 0.0, -5.0);\n    vec3 rayDir = normalize(vec3(imgPlane.x, imgPlane.y, 5.0));\n    \n    vec3 P, N;\n    int count;\n    \n    if(rayMarchHelix(rayPos, rayDir, P, N, count))\n    {\n        float radiance = 0.0;\n        vec3 L;\n        float ldiff, lspec;\n    \t    \n        for(int i = 0; i < 2; i++)\n        {\n            if(i == 0)\n            {\n               L = vec3(3.0, 2.0, -3.0);\n               ldiff = 200.0;\n               lspec = 0.4;\n            }\n            \n            if(i == 1)\n            {\n                L = vec3(-10.0, 2.0, 10.0);\n              \tldiff = 200.0;\n               \tlspec = 0.4;\n            }\n        \n       \t\tvec3 PL = L - P;\n        \n       \t\tfloat diff = (ldiff  / (4.0 * PI * pow(length(PL), 2.0))) * (1.0 / PI) * dot(normalize(PL), N);\n       \t\tif(diff < 0.0) diff = 0.0;\n            \n       \t\tvec3 EP = normalize(P - rayPos);\n       \t\tvec3 specVec = EP - 2.0 * (dot(N, EP) * N);\n       \t\tfloat spec = lspec * pow(dot(specVec, normalize(PL)), 5.0);\n       \t\tif(spec < 0.0) spec = 0.0;\n       \n           \tradiance += (diff + spec);\n       \t}\t\n            \n    \tfragColor = vec4(vec3(radiance), 1.0);\n    }\n    \n    else fragColor = vec4(0.0);\n}","name":"Image","description":"","type":"image"}]}