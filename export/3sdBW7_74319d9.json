{"ver":"0.1","info":{"id":"3sdBW7","date":"1605279421","viewed":217,"name":"Imagyx 2D-Letters","username":"Imagyx","description":"I wanted to have all characters and digits as a combination of smooth rounded lines. It's done.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","letters"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/************************************\\\n| A shader for letters and numbers   |\n\\************************************/\n\n// Most of the code is not in vector notation for me to be able to transfer it more easily to my offline application. \n\n#define SMOOTHING 0.05\n#define THICKNESS 0.105\n#define PI 3.14159265\n#define SPEED 2.0\n#define TEST 0\n#define BASE_SIZE 0.8\n\n// Uses code and ideas from (Thank you very much for all the good tutorials):\n//  + https://iquilezles.org/articles/distfunctions2d\n//  + https://iquilezles.org/articles/smin\n//  + https://iquilezles.org/articles/distfunctions\n\nfloat smin(float a, float b, float k){\n    if (SMOOTHING < 0.0){\n        return min(a, b);\n    }\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0 - h);\n}\n\n// Line\nfloat dLine(float px, float py, float ax, float ay, float bx, float by){\n    float bax = bx-ax;\n    float bay = by-ay;\n    float pax = px-ax;\n    float pay = py-ay;\n    float h = clamp((pax*bax + pay*bay)/(bax*bax + bay*bay), 0.0, 1.0);\n    pax = pax - h*bax;\n    pay = pay - h*bay;\n    return sqrt(pax*pax + pay*pay);\n}\n\n// Horizontal Line\nfloat dXLine(float px, float py, float l){\n    px -= min(l, max(-l, px));\n    return sqrt(px*px + py*py);\n}\n// Arc (most) from https://www.shadertoy.com/view/wl23RK\nfloat dArc(float px, float py,float sca, float scb, in float ra){\n    float scax = sin(sca);\n    float scay = cos(sca);\n    float scbx = sin(scb);\n    float scby = cos(scb);\n    float tmp = px*scax + py*scay;\n    py = py*scax - px*scay;\n    px = abs(tmp);\n    float k = (scby*px > scbx*py) ? px*scbx + py*scby : sqrt(px*px+py*py);\n    return sqrt(px*px+py*py + ra*ra - 2.0*ra*k) - THICKNESS;\n}\n// Oval\nfloat dOval(float px, float py, float l, float ir, float or){\n  \treturn abs(dXLine(py, px, l) - ir) - or;\n}\n\n// Letters...\nfloat char_A(float px, float py, float size, float size2){\n \tfloat d = dLine(px-size2,py, -size2,size,0.0,-size) - THICKNESS;\n\td = smin(d, dLine(px+size2,py, size2,size,0.0,-size) - THICKNESS, SMOOTHING);\n    // use size*0.4 for perfect fit of the horizontal line, but I want it to overlap a bit\n\td = smin(d, dXLine(px,py + size2*0.4, size*0.6) - THICKNESS, SMOOTHING);\n    return d;\n}\nfloat char_B(float px, float py, float size, float size2){\n \tfloat d = dXLine(py,px + size2, size) - THICKNESS;\n    float opy = py;\n    py = py-size*clamp(round(py/size),-1.0,1.0);\n \td = smin(d, dXLine(px+size2*0.5,py, size2*0.45) - THICKNESS, SMOOTHING);\n    py = opy;\n \tpy -= size*0.5;\n \td = smin(d, dArc(px,py, 1.0*PI, 0.5*PI, size*0.5), SMOOTHING*0.5);\n    py += size;\n    return d = smin(d, dArc(px,py, 1.0*PI, 0.5*PI, size*0.5), SMOOTHING);\n}\nfloat char_C(float px, float py, float size, float size2, float roundness){\n \tfloat c = cos(roundness); float s = sin(roundness);\n    float tmp = py;\n    py = -px;\n    px = abs(tmp);\n    float k = (c * px > s * py) ? px * s + py * c : sqrt(px*px + py*py);\n    float d = sqrt(px*px + py*py + size*size - 2.0*size*k);\n    return d - THICKNESS;\n}\nfloat char_D(float px, float py, float size, float size2, float roundness){\n \tfloat d = dXLine(py,px + size2, size) - THICKNESS;\n    float c = cos(roundness); float s = sin(roundness);\n    float tmp = py;\n    py = px + size/2.0;\n    px = abs(tmp);\n    float k = (c * px > s * py) ? px * s + py * c : sqrt(px*px + py*py);\n    return smin(d, sqrt(px*px + py*py + size*size - 2.0*size*k) - THICKNESS, SMOOTHING);\n}\nfloat char_E(float px, float py, float size, float size2){\n \tfloat d = dXLine(py,px + size2, size) - THICKNESS;\n    py = py-size*clamp(round(py/size),-1.0,1.0);\n \td = smin(d, dXLine(px,py, size2) - THICKNESS, SMOOTHING);\n    return d;\n}\nfloat char_F(float px, float py, float size, float size2){\n \tfloat d = dXLine(py,px + size2, size) - THICKNESS;\n    float c = size2;\n    py = py-size*clamp(round(py/size),0.0,1.0);\n \td = smin(d, dXLine(px,py, size2) - THICKNESS, SMOOTHING);\n    return d;\n}\nfloat char_G(float px, float py, float size, float size2, float roundness){\n \tfloat d = dXLine(py + size*0.55,px - size2*0.5, size*0.45) - THICKNESS;\n    d = smin(d, dXLine(px - 0.1,py + size*0.2, size*0.35) - THICKNESS, SMOOTHING);\n    float c = cos(roundness); float s = sin(roundness);\n    float tmp = py;\n    py = -px;\n    px = abs(tmp);\n    float k = (c * px > s * py) ? px * s + py * c : sqrt(px*px + py*py);\n    return smin(d, sqrt(px*px + py*py + size*size - 2.0*size*k) - THICKNESS, SMOOTHING);\n}\nfloat char_H(float px, float py, float size, float size2){\n \tfloat d = dXLine(py,px + size2, size) - THICKNESS;\n \td = min(d, dXLine(py,px - size2, size) - THICKNESS);\n \td = smin(d, dXLine(px,py, size2) - THICKNESS, SMOOTHING);\n    return d;\n}\nfloat char_I(float px, float py, float size, float size2){\n\tfloat d = dXLine(py,px, size) - THICKNESS;\n    py = py+size;\n \td = smin(d, dXLine(px,py, size2*0.5) - THICKNESS, SMOOTHING);\n    py = py-size*2.0;\n    return d = smin(d, dXLine(px,py, size2*0.5) - THICKNESS, SMOOTHING);\n}\nfloat char_J(float px, float py, float size, float size2){\n\tfloat d = dXLine(py-size*0.25,px-size*0.5, size*0.75) - THICKNESS;\n    d = smin(d, dArc(px,py+size*0.5, 1.5*PI, 0.5*PI, size*0.5), SMOOTHING);\n \td = smin(d, dXLine(px,py-size, size*0.5) - THICKNESS, SMOOTHING);\n    return d;\n}\nfloat char_K(float px, float py, float size, float size2){\n \tfloat d = dXLine(py,px + size2, size) - THICKNESS;\n    py = abs(py);\n\td = smin(d, dLine(px+size2,py, size,size,0.0,0.0) - THICKNESS, SMOOTHING);\n    return d;\n}\nfloat char_L(float px, float py, float size, float size2){\n \tfloat d = dXLine(py,px + size2, size) - THICKNESS;\n    d = smin(d, dXLine(px,py+size, size2) - THICKNESS, SMOOTHING);\n    return d;\n}\nfloat char_M(float px, float py, float size, float size2){\n \tfloat d = dXLine(py,px + size2, size) - THICKNESS;\n \td = smin(d, dXLine(py,px - size2, size) - THICKNESS, SMOOTHING);\n\td = smin(d, dLine(px+size2,py, size2,0.0,0.0,size) - THICKNESS, SMOOTHING);\n\td = smin(d, dLine(px+size2,py, size2,0.0,size2*2.0,size) - THICKNESS, SMOOTHING);\n    return d;\n}\nfloat char_N(float px, float py, float size, float size2){\n \tfloat d = dXLine(py,px + size2, size) - THICKNESS;\n \td = smin(d, dXLine(py,px - size2, size) - THICKNESS, SMOOTHING);\n\td = smin(d, dLine(px+size2,py, 0.0, size, size2*2.0, -size) - THICKNESS, SMOOTHING);\n    return d;\n}\nfloat char_O(float px, float py, float size, float size2){\n \tfloat d = dOval(px, py, size2*0.6, size*0.6, 0.1);\n    return d;\n}\nfloat char_P(float px, float py, float size, float size2){\n \tfloat d = dXLine(py,px + size2, size) - THICKNESS;\n    float opy = py;\n    py = py-size*clamp(round(py/size),0.0,1.0);\n \td = smin(d, dXLine(px+size2*0.5,py, size2*0.45) - THICKNESS, SMOOTHING);\n    py = opy;\n \tpy -= size*0.5;\n    return d = smin(d, dArc(px,py, 1.0*PI, 0.5*PI, size*0.5), SMOOTHING);\n}\nfloat char_Q(float px, float py, float size, float size2){\n \tfloat d = dOval(px, py, size2*0.6, size*0.6, 0.1);\n\td = smin(d, dLine(px+size2,py, size2,-size*0.5,size*1.3,-size) - THICKNESS, SMOOTHING);\n    return d;\n}\nfloat char_R(float px, float py, float size, float size2){\n \tfloat d = dXLine(py,px + size2, size) - THICKNESS;\n\td = smin(d, dLine(px+size2,py, size*1.15,-size,0.0,0.0) - THICKNESS, SMOOTHING);\n    float opy = py;\n    py = py-size*clamp(round(py/size),0.0,1.0);\n \td = smin(d, dXLine(px+size2*0.5,py, size2*0.45) - THICKNESS, SMOOTHING);\n    py = opy;\n \tpy -= size*0.5;\n    px += 0.1*size;\n    return d = smin(d, dArc(px,py, 1.0*PI, 0.5*PI, size*0.5), SMOOTHING);\n}\nfloat char_S(float px, float py, float size, float size2){\n \tfloat d = dXLine(px,py-size, size2*0.4) - THICKNESS;\n \td = min(d, dXLine(px+size*0.3,py+size, size2*0.4) - THICKNESS);\n \tpy -= size*0.5;\n    px += size*0.2;\n    d = smin(d, dArc(px,py, 2.0*PI, 0.5*PI, size*0.5), SMOOTHING);\n \tpy += size;\n    px -= size*0.05;\n    d = smin(d, dArc(px,py, 1.0*PI, 0.5*PI, size*0.5), SMOOTHING);    \n    return d;\n}\nfloat char_T(float px, float py, float size, float size2){\n\tfloat d = dXLine(py,px, size) - THICKNESS;    \n    py = py - size;\n    return d = smin(d, dXLine(px,py, size2) - THICKNESS, SMOOTHING);\n}\nfloat char_U(float px, float py, float size, float size2){\n \tfloat d = dXLine(py-size2*0.55,px + size2, size2);\n \td = min(d, dXLine(py-size2*0.55,px - size2, size2));\n\n    px = abs(px);\n    py = -py-size2*0.5;\n    float k = (0.0 > py) ? px : sqrt(px*px + py*py);\n    d = min(d, sqrt(px*px + py*py + size2*size2 - 2.0*size2*k));\n    return d - THICKNESS;\n}\nfloat char_V(float px, float py, float size, float size2){\n \tfloat d = dLine(px-size2,py, -size2,-size,0.0,size) - THICKNESS;\n\td = smin(d, dLine(px+size2,py, size2,-size,0.0,size) - THICKNESS, SMOOTHING);\n    return d;\n}\nfloat char_W(float px, float py, float size, float size2){\n \tfloat d = dLine(px-size2*0.5,py, -size2, -size, -size, size) - THICKNESS;\n\td = smin(d, dLine(px-size2,py, -size, -size, -size2, size2*0.4) - THICKNESS, SMOOTHING);\n\td = smin(d, dLine(px-size2,py, -size2*0.5, -size, -size2, size2*0.4) - THICKNESS, SMOOTHING);\n\td = smin(d, dLine(px-size2,py, -size2*0.5, -size, 0.0, size) - THICKNESS, SMOOTHING);\n    return d;\n}\nfloat char_X(float px, float py, float size, float size2){\n\tfloat d = dLine(px+size2,py, size2*2.0,size,0.0,-size) - THICKNESS;\n    d = smin(d, dLine(px+size2,py, size2*2.0,-size,0.0,size) - THICKNESS, SMOOTHING);\n    return d;\n}\nfloat char_Y(float px, float py, float size, float size2){\n\tfloat d = dLine(abs(px)+size2,py, size2*2.0,size,0.0,-size) - THICKNESS;\n\td = smin(d, dXLine(py+size2*0.7,px, size*0.5) - THICKNESS, SMOOTHING);\n    return d;\n}\nfloat char_Z(float px, float py, float size, float size2){\n\tfloat d = dLine(px+size2,py, size2*2.0,size,0.0,-size) - THICKNESS;\n    py = py-size*clamp(round(py/size),-1.0,1.0);\n \td = smin(d, dXLine(px,py, size2) - THICKNESS, SMOOTHING);\n    return d;\n}\nfloat char_0(float px, float py, float size, float size2){\n \tfloat d = dOval(px, py, size2, size*0.4, 0.1);\n    return d;\n}\nfloat char_1(float px, float py, float size, float size2){\n\tfloat d = dXLine(py,px-size2*0.6, size) - THICKNESS;\n\td = smin(d, dLine(px+size,py, size2,0.0,size2*2.0,size) - THICKNESS, SMOOTHING);\n    return d;\n}\nfloat char_2(float px, float py, float size, float size2){\n\tfloat d = dLine(px+size*0.7,py, size*1.1,size*0.05,0.0,-size) - THICKNESS;\n    d = smin(d, dArc(px,py-size*0.5, 0.62*PI, 0.62*PI, size*0.6), SMOOTHING);\n    d = smin(d, dXLine(px+size*0.1,py+size, size*0.6) - THICKNESS, SMOOTHING);\n    return d;\n}\nfloat char_3(float px, float py, float size, float size2){\n \tpy -= size*0.5;\n \tfloat d = dArc(px,py, 0.9*PI, 0.65*PI, size*0.5); \n    py += size;\n    return d = smin(d, dArc(px,py, 1.1*PI, 0.65*PI, size*0.5), SMOOTHING);\n}\nfloat char_4(float px, float py, float size, float size2){\n \tfloat d = dXLine(py,px - size2*0.35, size) - THICKNESS;\n \td = smin(d, dXLine(px,py + size*0.25, size2) - THICKNESS, SMOOTHING);\n\td = smin(d, dLine(px,py, -size2, -size*0.25, size2*0.35, size) - THICKNESS, SMOOTHING);\n    return d;\n}\nfloat char_5(float px, float py, float size, float size2){\n \tfloat d = dXLine(px+size*0.1,py-size, size*0.5) - THICKNESS;\n \td = smin(d, dXLine(px+size*0.3,py+size, size2*0.4) - THICKNESS, SMOOTHING);\n \td = smin(d, dXLine(px+size*0.3,py, size2*0.4) - THICKNESS, SMOOTHING);\n \td = smin(d, dXLine(py - size*0.5,px + size2*0.9, size*0.5) - THICKNESS, SMOOTHING);\n \tpy -= size*0.5;\n \tpy += size;\n    d = smin(d, dArc(px,py, 1.0*PI, 0.5*PI, size*0.5), SMOOTHING);    \n    return d;\n}\nfloat char_6(float px, float py, float size, float size2){\n \tfloat d = dArc(px,py, PI*0.2, 0.4*PI, size); \n    px += size*0.2;\n    py += size*0.4;\n    d = smin(d, abs(sqrt(px*px + py*py) - size*0.6) - THICKNESS, SMOOTHING);\n    return d;\n}\nfloat char_7(float px, float py, float size, float size2){\n\tfloat d = dLine(px+size2,py, size2*2.0,size,size2,-size) - THICKNESS;\n \td = smin(d, dXLine(px-size2*0.25,py, size*0.5) - THICKNESS, SMOOTHING);\n \td = smin(d, dXLine(px,py-size, size2) - THICKNESS, SMOOTHING);\n    return d;\n}\nfloat char_8(float px, float py, float size, float size2){\n    py -= size*0.6;\n    float d = abs(sqrt(px*px + py*py) - size*0.45) - THICKNESS;\n    py += size*1.05;\n    return smin(d, abs(sqrt(px*px + py*py) - size*0.6) - THICKNESS, SMOOTHING);\n}\nfloat char_9(float px, float py, float size, float size2){\n \tfloat d = dArc(px+size*0.2,py, PI*1.2, 0.4*PI, size); \n    py -= size*0.4;\n    d = smin(d, abs(sqrt(px*px + py*py) - size*0.6) - THICKNESS, SMOOTHING);\n    return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\tfloat px = p.x;\n\tfloat py = p.y;\n    \n    // Distance calculations\n    float size = BASE_SIZE + cos(iTime*5.0)*0.025;\n    float size2 = size*0.666;\n\tfloat d = 1.0; \n    float time = iTime*SPEED;\n    float mm = mod(time, 36.0*PI);\n    if(mm < PI){\n\t    d = mix(char_A(px,py, size, size2), char_Z(px,py, size, size2), pow(cos(time), 4.0));        \n    }else if(mm < 2.0*PI){\n\t    d = mix(char_B(px,py, size, size2), char_Z(px,py, size, size2), pow(cos(time), 4.0));                \n    }else if(mm < 3.0*PI){\n\t    d = mix(char_C(px,py, size, size2, 0.7*PI), char_Z(px,py, size, size2), pow(cos(time), 4.0));                \n    }else if(mm < 4.0*PI){\n\t    d = mix(char_D(px,py, size, size2, 0.6*PI), char_Z(px,py, size, size2), pow(cos(time), 4.0));                \n    }else if(mm < 5.0*PI){\n\t    d = mix(char_E(px,py, size, size2), char_Z(px,py, size, size2), pow(cos(time), 4.0));                \n    }else if(mm < 6.0*PI){\n\t    d = mix(char_F(px,py, size, size2), char_Z(px,py, size, size2), pow(cos(time), 4.0));                \n    }else if(mm < 7.0*PI){\n\t    d = mix(char_G(px,py, size, size2, 0.6*PI), char_Z(px,py, size, size2), pow(cos(time), 4.0));                \n    }else if(mm < 8.0*PI){\n\t    d = mix(char_H(px,py, size, size2), char_Z(px,py, size, size2), pow(cos(time), 4.0));                \n    }else if(mm < 9.0*PI){\n\t    d = mix(char_I(px,py, size, size2), char_Z(px,py, size, size2), pow(cos(time), 4.0));                \n    }else if(mm < 10.0*PI){\n\t    d = mix(char_J(px,py, size, size2), char_Z(px,py, size, size2), pow(cos(time), 4.0));                \n    }else if(mm < 11.0*PI){\n\t    d = mix(char_K(px,py, size, size2), char_Z(px,py, size, size2), pow(cos(time), 4.0));                \n    }else if(mm < 12.0*PI){\n\t    d = mix(char_L(px,py, size, size2), char_Z(px,py, size, size2), pow(cos(time), 4.0));                \n    }else if(mm < 13.0*PI){\n\t    d = mix(char_M(px,py, size, size2), char_Z(px,py, size, size2), pow(cos(time), 4.0));                \n    }else if(mm < 14.0*PI){\n\t    d = mix(char_N(px,py, size, size2), char_Z(px,py, size, size2), pow(cos(time), 4.0));                \n    }else if(mm < 15.0*PI){\n\t    d = mix(char_O(px,py, size, size2), char_Z(px,py, size, size2), pow(cos(time), 4.0));                \n    }else if(mm < 16.0*PI){\n\t    d = mix(char_P(px,py, size, size2), char_Z(px,py, size, size2), pow(cos(time), 4.0));                \n    }else if(mm < 17.0*PI){\n\t    d = mix(char_Q(px,py, size, size2), char_Z(px,py, size, size2), pow(cos(time), 4.0));                \n    }else if(mm < 18.0*PI){\n\t    d = mix(char_R(px,py, size, size2), char_Z(px,py, size, size2), pow(cos(time), 4.0));                \n    }else if(mm < 19.0*PI){\n\t    d = mix(char_S(px,py, size, size2), char_Z(px,py, size, size2), pow(cos(time), 4.0));                \n    }else if(mm < 20.0*PI){\n\t    d = mix(char_T(px,py, size, size2), char_Z(px,py, size, size2), pow(cos(time), 4.0));                \n    }else if(mm < 21.0*PI){\n\t    d = mix(char_U(px,py, size, size2), char_Z(px,py, size, size2), pow(cos(time), 4.0));                \n    }else if(mm < 22.0*PI){\n\t    d = mix(char_V(px,py, size, size2), char_Z(px,py, size, size2), pow(cos(time), 4.0));                \n    }else if(mm < 23.0*PI){\n\t    d = mix(char_W(px,py, size, size2), char_Z(px,py, size, size2), pow(cos(time), 4.0));                \n    }else if(mm < 24.0*PI){\n\t    d = mix(char_X(px,py, size, size2), char_Z(px,py, size, size2), pow(cos(time), 4.0));                \n    }else if(mm < 25.0*PI){\n\t    d = mix(char_Y(px,py, size, size2), char_Z(px,py, size, size2), pow(cos(time), 4.0));                \n    }else if(mm < 26.0*PI){\n\t    d = char_Z(px,py, size, size2);      \n    }else if(mm < 27.0*PI){\n\t    d = mix(char_0(px,py, size, size2), char_Z(px,py, size, size2), pow(cos(time), 4.0));                \n    }else if(mm < 28.0*PI){\n\t    d = mix(char_1(px,py, size, size2), char_Z(px,py, size, size2), pow(cos(time), 4.0));                \n    }else if(mm < 29.0*PI){\n\t    d = mix(char_2(px,py, size, size2), char_Z(px,py, size, size2), pow(cos(time), 4.0));                \n    }else if(mm < 30.0*PI){\n\t    d = mix(char_3(px,py, size, size2), char_Z(px,py, size, size2), pow(cos(time), 4.0));                \n    }else if(mm < 31.0*PI){\n\t    d = mix(char_4(px,py, size, size2), char_Z(px,py, size, size2), pow(cos(time), 4.0));                \n    }else if(mm < 32.0*PI){\n\t    d = mix(char_5(px,py, size, size2), char_Z(px,py, size, size2), pow(cos(time), 4.0));                \n    }else if(mm < 33.0*PI){\n\t    d = mix(char_6(px,py, size, size2), char_Z(px,py, size, size2), pow(cos(time), 4.0));                \n    }else if(mm < 34.0*PI){\n\t    d = mix(char_7(px,py, size, size2), char_Z(px,py, size, size2), pow(cos(time), 4.0));                \n    }else if(mm < 35.0*PI){\n\t    d = mix(char_8(px,py, size, size2), char_Z(px,py, size, size2), pow(cos(time), 4.0));                \n    }else if(mm < 36.0*PI){\n\t    d = mix(char_9(px,py, size, size2), char_Z(px,py, size, size2), pow(cos(time), 4.0));                \n    }else{\n        d = char_Z(px,py, size, size2);                \n    }\n\n    // Coloring\n    vec3 col = vec3(0.75,0.5,0);\n\tcol *= 5.0*pow(-d, 0.7);\n    col += mix(col, vec3(cos(iTime*4.0))*vec3(0.0,0.2,0.4), length(p));\n\n#if TEST\n\t// Alternative to check sizes of letters\n\tpx -= 1.0;\n    d = char_9(px,py, size, size2);\n    px += 1.8;\n    d = min(d, char_A(px,py, size, size2));\n    col = vec3(0.75,0.5,0);\n\tcol *= 5.0*pow(-d, 0.7);\n#endif\n    \n    // Return\n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}