{"ver":"0.1","info":{"id":"XX2yzz","date":"1726872438","viewed":24,"name":"RomainSoares- AngelMunoz M1if02","username":"Kyutsune","description":"Projet pour la matière M1if02 en Master à l'université Lyon1 Claude Bernard","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["projet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Rayon{\n    vec3 or; //Origine\n    vec3 dir; // Direction\n};\n\nstruct Val{\n    float v;\n    int c;\n};\n\n\n\n// Compute point on ray\n// ray : The ray\n//   t : Distance\nvec3 Point(Rayon ray,float t)\n{\n    return ray.or+t*ray.dir;\n}\n\n\n// Union\n// a,b : field function of left and right sub-trees\nVal Union(Val a,Val b)\n{\n  return Val(min(a.v,b.v),a.c+b.c+1);\n}\n\n// Intersection\n// a, b : field function of left and right sub-trees\nVal Intersection(Val a, Val b)\n{\n    return Val(max(a.v, b.v), a.c + b.c + 1);\n}\n\n\n// Plan \n// p : Point duquel on veut calculer la distance\n// n : Normale du plan\n// o : Origine du plan\nVal Plan(vec3 p, vec3 n, vec3 o)\n{\n    // Calcul de la distance signée\n    float dist = dot((p - o), n);\n    return Val(dist, 1);\n}\n\n\n// Sphere\n// p : Point duquel on veut calculer la distance\n// c : centre de la sphere\n// r : rayon\nVal Sphere(vec3 p,vec3 c,float r)\n{\n  float dist=length(p-c)-r;\n  return Val(dist,1);\n}\n\n\n// Cylindre infini\n// p : Point duquel on veut calculer la distance\n// b : Position ou centre de l'objet\n// u : Direction de l'axe du cylindre\n// r : Rayon de la surface du cylindre\nVal Cylindre_infini(vec3 p, vec3 b, vec3 u, float r) {\n    vec3 toPoint = p - b;\n    float l = dot(toPoint, u);\n    vec3 h = toPoint - l * u;\n\n    float signedDistance = length(h) - r;\n\n    return Val(signedDistance, 1);\n}\n\n\n// Cylindre\n// p : Point duquel on veut calculer la distance\n// b : Position ou centre de l'objet\n// u : Direction de l'axe du cylindre\n// r : Rayon de la surface du cylindre\n// h : Hauteur du cylindre\nVal Cylindre(vec3 p, vec3 b, vec3 u, float r, float h) {\n    // Calcul de la distance au cylindre infini\n    Val distCylindreInfini = Cylindre_infini(p, b, u, r);\n\n    // Plans de limitation (slabs) : définis à une distance de +/- h/2 du centre b\n    vec3 topPlanePosition = b + (h / 2.0) * u;  // Position du plan supérieur\n    vec3 bottomPlanePosition = b - (h / 2.0) * u;  // Position du plan inférieur\n\n    // Calcul de la distance aux plans supérieur et inférieur\n    Val distTopPlane = Plan(p, u, topPlanePosition);  // Plan supérieur\n    Val distBottomPlane = Plan(p, -u, bottomPlanePosition);  // Plan inférieur\n \n\n    // Intersection entre le cylindre infini et les plans de limitation\n    Val cylindreFini = Intersection(Intersection(distCylindreInfini, distTopPlane), distBottomPlane);\n\n    return cylindreFini;\n}\n\n\n\n// Tore\n// p : Point pour lequel on veut calculer la distance\n// c : Centre du tore\n// r : Rayon du tube\n// R : Rayon du tore\nVal Tore(vec3 p, vec3 c, float r, float R) {\n    vec2 tp = vec2(length(p.xz - c.xz) - R, p.y - c.y); // Position relative au tore\n    float dist = length(tp) - r; // Calcul de la distance\n    return Val(dist, 1);\n}\n\n\n\n\n///Partie comprenant les Transformations affines\n\n//Translation inverse\n// p : point à translater\n// t : vecteur de translation\nvec3 Translate(vec3 p, vec3 t) {\n    return p - t;\n}\n\n\n//Rotations inverses:\nmat3 RotX(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, c, -s,\n        0.0, s, c\n    );\n}\nmat3 RotY(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat3(\n        c, 0.0, s,\n        0.0, 1.0, 0.0,\n        -s, 0.0, c\n    );\n}\nmat3 RotZ(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat3(\n        c, -s, 0.0,\n        s, c, 0.0,\n        0.0, 0.0, 1.0\n    );\n}\n\nvec3 RotatePoint(vec3 p, vec3 angles) {\n    mat3 rot = RotX(angles.x) * RotY(angles.y) * RotZ(angles.z);\n    return rot * p; \n}\n\n// Homothétie inverse \n// p : point \n// s : facteur d'échelle\nvec3 Scale(vec3 p, float s) {\n    return p/s;\n}\n\n\n\n/// Bruit et déformation des objets\n\nvec2 g(ivec2 q) {\n    int n = q.x + q.y * 11111;\n    n = (n << 13) ^ n;\n    n = (n * (n * n * 15731 + 789221) + 1376312589) >> 16;\n    return vec2(cos(float(n)), sin(float(n)));\n}\n\nfloat noise3D(vec3 p) {\n    vec2 p2 = vec2(p.x, p.y); \n    ivec2 q = ivec2(floor(p2));\n    vec2 f = fract(p2);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(\n        mix(dot(g(q + ivec2(0, 0)), f - vec2(0, 0)),\n            dot(g(q + ivec2(1, 0)), f - vec2(1, 0)), u.x),\n        mix(dot(g(q + ivec2(0, 1)), f - vec2(0, 1)),\n            dot(g(q + ivec2(1, 1)), f - vec2(1, 1)), u.x), u.y);\n}\n\n\n/// Partie des objets composés d'autres objets\n\n//Capsule\n//p : Point pour lequel on veut calculer la distance\n//o : Point du centre de la capsule\nVal Capsule(vec3 p, vec3 o, vec3 cylinderDirection , float epaisseur, float taille, vec3 deformation)\n{     \n    p += deformation;\n    Val cylindre = Cylindre(p, o, cylinderDirection, epaisseur, taille);\n    Val sphere1 = Sphere(p, o + cylinderDirection * (taille / 2.0), epaisseur);\n    Val sphere2 = Sphere(p, o - cylinderDirection * (taille / 2.0), epaisseur);\n    \n    Val capsule_retour = Union(Union(cylindre,sphere1),sphere2);\n    \n    return capsule_retour;\n}\n\n\n// Boîte\n// p : Point pour lequel on veut calculer la distance\n// min : Coin inférieur de la boîte \n// max : Coin supérieur de la boîte \nVal Boite(vec3 p, vec3 boxMin, vec3 boxMax) {\n    vec3 q = max(boxMin - p, p - boxMax);  // Distance à chaque plan de la boîte\n    float dist = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);  // Calcul de la distance minimale à la boîte\n    return Val(dist, 1);\n}\n\n\n// Ajouter du bruit à la surface d'un plan\nVal PlanAvecBruit(vec3 p, vec3 normal, vec3 origin) {\n    float bruit = noise3D(p * 0.2); \n    vec3 p_deforme = p + normal * bruit * 0.5; \n    return Plan(p_deforme,normal,origin);\n}\n\n\n\n\n\nVal object(vec3 p)\n{\n    // PLAN //\n    float noiseFactor_plan = noise3D(p * 0.2); \n    vec3 deformation_plan = vec3(noiseFactor_plan) * 1.5;  // Amplitude de la déformation\n    vec3 plan_direction = vec3(0., 0. , 1.); // Direction normale du plan\n\n    // Utiliser la fonction avec bruit pour créer le plan\n    Val plan = PlanAvecBruit(p, plan_direction, vec3(0., 0., 0.));\n\n    // CYLINDRE //\n\n    // Appliquer la rotation uniquement au cylindre pour le test\n    vec3 cylinderDirection = vec3(1.0, 0.0, 0.0); // Direction de l'axe du cylindre\n    vec3 rotationAngles = vec3(radians(45.0), radians(45.0), radians(0.0)); \n    vec3 rotatedDirection = RotatePoint(cylinderDirection, rotationAngles);\n    \n    Val cylindre = Cylindre(p, vec3(-15.0, -10.0, 5.0), rotatedDirection, 1.0, 2.0);\n    Val cylindre_infini = Cylindre_infini(p, vec3(-10.0, 0.0, 3.0), vec3(0.0, 1.0, 0.0), 0.5); \n\n    // SPHERE //\n\n    vec3 point_sphere = vec3(0., 2., 2.);\n    vec3 point_sphere_translationne = Translate(point_sphere, vec3(-10, 0, 0));\n    \n    Val sphere = Sphere(p, point_sphere, 2.25);\n    Val sphere_translate = Sphere(p, point_sphere_translationne, 2.25);\n\n    vec3 point_sphere_homothetiee = Scale(p , 1.5);\n    Val sphere_homothetiee = Sphere(vec3(0., 8., 2.), point_sphere_homothetiee, 2.25);\n    \n    // TORE //\n\n    Val tore = Tore(p, vec3(-4., -12., 4.), 1., 2.);\n    \n    // CAPSULE //\n\n    vec3 centre_capsule = vec3(-13.0, -3.0, 5.0);\n    vec3 cylinderCapsuleDirection = vec3(1.0, 0.0, 0.0);\n    float epaisseur_capsule = 1.5;\n    float taille_capsule = 6.;\n    \n    float noiseFactor_capsule = noise3D(p * 2.); \n    vec3 deformation_capsule = vec3(noiseFactor_capsule) * 0.1;  // Amplitude de la déformation\n    \n    //vec3 deformation_capsule_test= vec3(0.,0.,0.);\n\n    Val capsule = Capsule(p, centre_capsule, cylinderCapsuleDirection, epaisseur_capsule, taille_capsule, deformation_capsule);\n\n    // BOITE //\n\n    vec3 d = normalize(p); // Direction du rayon\n    vec3 minCorner = vec3(2.0, -4.0, 2.0); // Coin inférieur de la boîte\n    vec3 maxCorner = vec3(8.0, -1.0, 4.0); // Coin supérieur de la boîte\n\n    Val boite = Boite(p, minCorner, maxCorner);\n\n    Val v = Union(plan, cylindre);\n    v = Union(v, cylindre_infini);\n    v = Union(Union(Union(v, sphere), sphere_translate), sphere_homothetiee);\n    v = Union(v, tore);\n    v = Union(v, capsule);\n    if (boite != Val(-1., 0))\n        v = Union(v, boite);\n\n    return v;\n}\n\n\n\n\n\n// La partie caméra \n\n// Rotation matrix around z axis\n// a : Angle\nmat3 Rz(float a)\n{\n  float sa=sin(a);float ca=cos(a);\n  return mat3(ca,sa,0.,-sa,ca,0.,0.,0.,1.);\n}\n\n// Calcul du rayon\n//      m : Mouse position\n//      p : Pixel\nRayon CreateRay(vec2 m,vec2 p)\n{\n  float a=3.*3.14*m.x;\n  float le=3.5;\n  \n  // Origin\n  vec3 ro=vec3(37.,0.,18.);\n  ro*=Rz(a);\n  \n  // Target point\n  vec3 ta=vec3(0.,0.,1.);\n  \n  // Orthonormal frame\n  vec3 w=normalize(ta-ro);\n  vec3 u=normalize(cross(w,vec3(0.,0.,1.)));\n  vec3 v=normalize(cross(u,w));\n  vec3 rd=normalize(p.x*u+p.y*v+le*w);\n  return Rayon(ro,rd);\n}\n\n\n\n\n///La partie ray tracing\nconst int Steps=200;// Nombre d'étape à faire pour trouver l'objet\nconst float Epsilon=.01;// La distance qu'on va parcourir à chaque instant sur le rayon\n\n\n// Object normal\n// p : point\nvec3 ObjectNormal(vec3 p)\n{\n  const float eps=.001;\n  vec3 n;\n  Val val=object(p);\n  float v=val.v;\n  n.x=object(vec3(p.x+eps,p.y,p.z)).v-v;\n  n.y=object(vec3(p.x,p.y+eps,p.z)).v-v;\n  n.z=object(vec3(p.x,p.y,p.z+eps)).v-v;\n  return normalize(n);\n}\n\n// ray : The ray\n//   e : Maximum distance\n//   h : hit\n//   s : Number of steps\n//   c : cost\nbool SphereTrace(Rayon ray,float e,out float t,out int s,out int c)\n{\n  bool h=false;\n  \n  // Start at the origin\n  t=0.0;\n  c=0;\n  \n  for(int i=0;i<Steps;i++)\n  {\n    s=i;\n    vec3 p=Point(ray,t);\n    Val val=object(p);\n    float v=val.v;\n    c+=val.c;\n    // Hit object\n    if(v<0.)\n    {\n      h=true;\n      break;\n    }\n    // Move along ray\n    t+=max(Epsilon,v);\n    // Escape marched too far away\n    if(t>e)\n    {\n      break;\n    }\n  }\n  return h;\n}\n\n\n// Eclairage \n\n// Background color\n// ray : Ray \nvec3 background(Rayon ray)\n{\n  return mix(vec3(.45,.55,.99),vec3(.65,.69,.99),ray.dir.z*.5+.5);\n}\n\n// Shadowing\n// p : Point\n// n : Normal\n// l : Light direction\nfloat Shadow(vec3 p,vec3 n,vec3 l)\n{\n  float t;\n  int s;\n  int c;\n  bool hit=SphereTrace(Rayon(p+Epsilon*n,l),100.,t,s,c);\n  if(!hit)\n  {\n    return 1.;\n  }\n  return 0.;\n}\n\n\n\n\n// Fonction pour calculer l'occlusion ambiante\n// p : position du point pour lequel on calcule l'occlusion\n// n : normale au point p\n// numRays : nombre de rayons à lancer pour estimer l'occlusion\n// radius : distance maximale à laquelle on considère les intersections\nfloat AmbientOcclusion(vec3 p, vec3 n, int numRays, float R) {\n    int hits = 0; \n\n    for (int i = 0; i < numRays; i++) {\n        // Générer une direction aléatoire basée sur la normale et le bruit\n        vec3 randomDir = normalize(n + vec3(noise3D(p + float(i) * .1))); \n        \n        \n        Rayon randomRay = Rayon(p + randomDir * R, p); \n        float t; \n        int s, c; \n\n        // Vérifier si le rayon intersecte un objet\n        bool hit = SphereTrace(randomRay, R, t, s, c);\n\n        // Compter les intersections\n        if (hit && t < R) {\n            hits++; \n        }\n    }\n    return 1.0 - float(hits) / float(numRays); \n}\n\n\n\n\n\n\n\n\n// Shading and lighting\n//   p : Point\n//   n : Normal at point\n// eye : Eye direction\nvec3 Shade(vec3 p,vec3 n,Rayon eye)\n{\n  // Point light\n  const vec3 lp=vec3(5.,10.,25.);\n  \n  // Light direction to point light\n  vec3 l=normalize(lp-p);\n  \n  // Ambient color\n  vec3 ambient=.25+.25*background(Rayon(p,n));\n  \n  // Shadow computation\n  float shadow=Shadow(p,n,l);\n  \n  // Calcul de l'occlusion ambiante\n  float oa = 1.;//AmbientOcclusion(p, n, 16, 1.); \n  \n  // Phong diffuse\n  vec3 diffuse=.35*clamp(dot(n,l),0.,1.)*vec3(1.,1.,1.);\n  \n  // Specular\n  vec3 r=reflect(eye.dir,n);\n  vec3 specular=.15*pow(clamp(dot(r,l),0.,1.),35.)*vec3(1.,1.,1.);\n  \n  \n  \n  vec3 c=ambient+shadow*(diffuse+specular)*oa;\n  return c;\n}\n\n// Shading according to the number of steps in sphere tracing\n// n : Number of steps\nvec3 ShadeSteps(int n,int m)\n{\n  float t=float(n)/(float(m));\n  return.5+mix(vec3(.05,.05,.5),vec3(.65,.39,.65),t);\n}\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv=(-iResolution.xy+2.*fragCoord)/iResolution.y;\n\n    // Souris\n    vec2 m = iMouse.xy / iResolution.xy;\n    Rayon rayon_cam = CreateRay(m, uv);\n\n    int cost;\n    float t = 0.0;\n    int steps = Steps;\n    bool hit = SphereTrace(rayon_cam, 100.0, t, steps, cost);\n\n    vec3 rgb = background(rayon_cam);\n\n    if (hit) {\n            vec3 p = Point(rayon_cam, t);\n\n            vec3 n = ObjectNormal(p);\n\n            // Shade object with light\n            rgb = Shade(p, n, rayon_cam);\n    }\n    //Correction gamma?\n    //vec3 correctedColor = pow(rgb, vec3(1.0 / 2.2));\n\n\n    fragColor = vec4(rgb, 1.0);\n\n}","name":"Image","description":"","type":"image"}]}