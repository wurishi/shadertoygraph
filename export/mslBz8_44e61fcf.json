{"ver":"0.1","info":{"id":"mslBz8","date":"1688469333","viewed":74,"name":"Gundi tundi tuhanda kachan","username":"nayk","description":"remake","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["3d","voronoi","illusion","bump","blocks"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//*remake https://www.shadertoy.com/view/lt3SzH//\n\nvec2 sport(vec2 p) { \n\n   \n    float n = tan(dot(p, vec2(410, 289)));\n    \n   \n    p = fract(vec2(2624, 32768)*n); \n  \n    return cos(sin( p*1.2831853 + iTime )*1.05); \n    \n}\n\n\n\nfloat Voronoi(in vec2 p){\n    \n\tvec2 g = floor(p), o; p -= g; // Cell ID, offset variable, and relative cell postion.\n\t\n\tvec3 d = vec3(1.0); \n    \n\tfor(int y=-1; y<=1; y++){\n\t\tfor(int x=-1; x<=1; x++){\n            \n\t\t\to = vec2(x, y); // Grid cell ID offset.\n            o += sport(g + o) - p; // Random offset.\n\t\t\t\n          \n            d.y = dot(o, o); \n           \n            \n            d.x *= (1. -  fract(atan(o.y, o.x)*3./6.283 + .25)*.5); // More linear looking.\n            \n            d.y = max(d.x, min(d.y, d.z*1.0)); // Second order distance.\n            d.x = min(d.x, d.z); // First order distance.\n                      \n\t\t}\n\t}\n\n    // A bit of science and experimentation.\n    return d.y*.2 + (d.y-d.x)*.2; // Range: [0, 1]... Although, I'd check. :)\n    \n    //return d.y; // d.x, d.y - d.x, etc.\n    \n    \n}\n\n\n// Bump mapping function. Put whatever you want here. If you wish to do some\n// fake shadowing, it's usually helpful to keep the range between zero and one.\nfloat bumpFunc(vec2 p){ \n    \n    return Voronoi(p*4.); // Range: [0, 1] \n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    \n   \n    vec2 a = sin(vec2(10.57, 0) + sin(iTime*0.1)*sin(iTime*0.12)*2.);\n    uv *= mat2(a, -a.y, a.x);\n  \n   \n    vec3 offs = vec3(-iTime/8., iTime/8., 0);\n\n  \n    vec3 sp = vec3(uv, 0) + offs; // Surface posion. Hit point, if you prefer. Essentially, a screen at the origin.\n    vec3 rd = normalize(vec3(uv, 1.)); // Unit direction vector. From the origin to the screen plane.\n    vec3 lp = vec3(cos(iTime)*0.5, sin(iTime)*0.2, -2.) + offs; // Light position - Back from the screen.\n\tvec3 sn = vec3(0., 0., -1); // Plane normal. Z pointing toward the viewer.\n \n     \n\n    \n  \n    vec2 eps = vec2(1./iResolution.x, 1.);\n    \n    float f = bumpFunc(sp.xy); // Function value.\n    float fx = bumpFunc(sp.xy+eps.xy); // Nearby sample in the X-direction.\n    float fy = bumpFunc(sp.xy+eps.yx); // Nearby sample in the Y-direction.\n  \n    float fx2 = bumpFunc(sp.xy-eps.xy); // Sample on the other side in the X-direction.\n    float fy2 = bumpFunc(sp.xy-eps.yx); // Same on the other side in the Y-direction.\n    \n    // Using the samples to provide an edge measurement. How you do it depends on the\n    // look you're going for.\n    //float edge = abs(fx + fy + fx2 + fy2 - 4.*f); //abs(fx - f) + abs(fy - f);\n   \n    float edge = abs(fx + fx2) + abs(fy + fy2) - 4.*f; //abs(fx - f) + abs(fy - f);\n\n    edge = smoothstep(0., 8., edge/eps.x*4.);\n   \n \t// Controls how much the bump is accentuated.\n\tconst float bumpFactor = 0.35;\n    \n    // Using the above to determine the dx and dy function gradients.\n    fx = (fx-fx2)/eps.x/20.; // Change in X\n    fy = (fy-fy2)/eps.x/2.; // Change in Y.\n   \n    vec3 grad = vec3(fx, fy, 0);\n    grad -= sn*dot(sn, grad);\n    sn = normalize( sn + grad*bumpFactor ); \n           \n     \n    \n \n\tvec3 ld = lp - sp;\n\tfloat lDist = max(length(ld), 1.001);\n\tld /= lDist;\n\n    // Light attenuation.    \n    float atten = 15./(0.0 + lDist*lDist*0.05);\n    \n    \n    atten *= smoothstep(0.1, 1., f)*.9 + .1; // Or... f*f*.7 + .3; //  pow(f, .75); // etc.\n   \n    \n\n\t\n     \n    const float ts = 2.;\n    vec3 nsn = max(abs(sn)-.2, .001);\n    nsn /= dot(nsn, vec3(1));\n    vec3 texCol = vec3(0);\n    sp.z += -f*10.; // Pretending that the Z-value is not sitting flat on the plane.\n    // Tri-planar.\n   \n    // sRGB to linar with processing. Basically, minipulating the color a bit.\n    texCol = smoothstep(0.175, 1.5, texCol*texCol)*0.5;\n    \n    \n    // Diffuse value.\n\tfloat diff = max(dot(sn, ld), 0.);  \n    // Enhancing the diffuse value a bit. Made up.\n    diff = pow(diff, 4.)*1.66 + pow(diff, 8.)*1.34; \n    // Specular highlighting.\n    float spec = pow(max(dot( reflect(-ld, sn), -rd), 0.), 8.); \n    // Fresnel reflection. It's one line, so why not.\n    float fres = pow(clamp(dot(rd, sn) + 10., 0., 1.), 16.);\n    \n    \n   \n    texCol *= 1.-edge*.5; \n    \n    // I did this by accident, but found it added to the depth, so I kept it.\n    texCol *= smoothstep(2.1, 2.6, atten);\n\t\n    \n    \n    vec3 col = (texCol*(diff*20. + 8.2 + vec3(10, 1.4, 2)*fres) + vec3(1., .7, .3)*spec*2.)*atten;\n\n    \n    \n\n    uv = fragCoord/iResolution.xy;\n    col *= pow(1.*uv.x*uv.y*(1.-uv.x)*(1.-uv.y), .025); // Vignette.\n  \n    col = vec3(0.5, 0.5, 0.3)*pow(max(col, 0.), vec3(0.5, 0.5, 0.5))*1.5; // Contrast, coloring.\n    \n\n    // Perform some statistically unlikely (but close enough) 2.0 gamma correction. :) \n\tfragColor = vec4(sqrt(clamp(col, 0., 1.)), 1.);\n}\n","name":"Image","description":"","type":"image"}]}