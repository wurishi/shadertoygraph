{"ver":"0.1","info":{"id":"NdK3Dt","date":"1632412350","viewed":59,"name":"matrice rotation","username":"mguilbault","description":"matrice","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["math"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int NB_VERTICES = 10;\nstruct Shape { vec3[NB_VERTICES] vertices; float thickness; };\n\n///////////////////////////////////////////////////////////////\n// Section DOJO \n// Ex2. Construire une transformation\n//\n// 1- Faites pivoter la forme (Shape s) autour du centre de l'écran de -90° \n// 2- Translater la forme +0.25 en y\n// 3- Faites pivoter la forme autour du centre de l'écran (angle)\n//\n// Note 1 : combinez ces transformations en une seule.\n// Note 2 : quand iTime=0, vous devez obtenir la maison en position \"12h00\" à l'écran, la pointe vers le haut.\n//\n///////////////////////////////////////////////////////////////\n\nShape dojoTransformShape(Shape s) {\n\n    float angle = iTime;\n\n    mat3 pivot = mat3(vec3(0.,1.,0.),vec3(-1.,0.,0.),vec3(0.,0.,1.));;\n\n    mat3 translation = mat3(vec3(1.,0.,0.),vec3(0.,1.,0.),vec3(0.,0.25,1));;\n    \n    mat3 rotation = mat3(vec3(cos(angle),sin(angle),0.),vec3(-sin(angle),cos(angle),0.),vec3(0.,0.,1.));\n\n \n    mat3 transfo =rotation * translation * pivot  ;\n   \n    for(int i=0; i<NB_VERTICES; i++) {\n        s.vertices[i]= transfo * s.vertices[i];\n    }\n    \n    return s;\n}\n\n\n///////////////////////////////////////////////////////////////\n// Private Section\n///////////////////////////////////////////////////////////////\nstruct Circle { vec2 o; float r; };\n\nfloat sdCircle(vec2 p, Circle c) { \n    return length(p-c.o) - c.r;\n}\n\nfloat sdSegment(vec2 p, vec2 p1, vec2 p2, float thickness) { \n    vec2 v = p-p1;\n    vec2 dir = p2 - p1;    \n    float param = clamp(dot(v, dir) / dot(dir, dir), 0., 1.); \n\n    return length(p- mix(p1, p2, param)) - thickness;\n}\n\nfloat sdShape(vec2 p, Shape s) {\n    float sd = 10E9;    \n    \n    for(int i=0; i<NB_VERTICES+1; i++) {\n        sd = min(sd, sdSegment(p, s.vertices[i%NB_VERTICES].xy, s.vertices[(i+1)%NB_VERTICES].xy, s.thickness));\n    }\n    \n    return sd;\n}\n\n\nShape scaleShape(Shape s, float scale) {\n    for(int i=0; i<NB_VERTICES; i++) {\n        s.vertices[i].xy *= scale;\n    }\n    \n    s.thickness *= scale;\n    \n    return s;\n}\n\nShape buildShape() {\n    Shape s;\n    s.vertices[0] = vec3(0, 15, 1);\n    s.vertices[1] = vec3(0, -15, 1);\n    s.vertices[2] = vec3(30, -15, 1);\n    s.vertices[3] = vec3(40, 0, 1);\n    s.vertices[4] = vec3(30, 15, 1);\n    s.vertices[5] = vec3(0, 15, 1);\n    s.vertices[6] = vec3(0, 0, 1);\n    s.vertices[7] = vec3(15, 0, 1);\n    s.vertices[8] = vec3(15, -8, 1);\n    s.vertices[9] = vec3(0, -8, 1);\n    \n    s.thickness = 0.75;\n    \n    return s;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n\n    Shape house = scaleShape(buildShape(), 0.0035);\n    \n    Shape transformedHouse = dojoTransformShape(house);\n\n    float dist = min(\n                    sdCircle(uv, Circle(vec2(0), 0.01)),\n                    sdShape(uv, transformedHouse)\n                 );\n\n    if(dist < 0.) {\n        fragColor = vec4(1.,.5,0.,1.);    \n    }\n    else {\n        fragColor = vec4(0);\n    }\n}\n\n\n","name":"Image","description":"","type":"image"}]}