{"ver":"0.1","info":{"id":"4XsyzM","date":"1725983829","viewed":18,"name":"Static Bulbs","username":"thedarkbunny","description":"A math experiment got away from me, so I tweaked it until it looked cool.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["experimental"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//Cycles of convergence per pixel.  Decrease if performance suffers.\n#define LOOPS 100\n\n//Higher = more brightness, but sharper divide in the center.\n#define LIM 6.\n\n//Constant 2*pi\n#define TAU 6.28318531\n\n\n//Convergence routine\nfloat findN(in vec2 p, in float r){\n    float n = 1.;\n    p = abs(p);\n    float ndiff,nv;\n    for(int i=0;i<LOOPS;i++){\n        nv = pow(p.x,n)+pow(p.y,n)-pow(r,n);\n        ndiff = pow(p.x,n)*log(p.x) + pow(p.y,n)*log(p.y);\n        n -= nv / ndiff / 2.;\n    }\n    return n;\n}\n\n//Actual output of findN is (theoretically) -INF .. +INF\n//This scales it to something more useful.\nfloat scaleN(in float n){\n    return ( log(n) + log(LIM) ) / log(LIM) / 2.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/min(iResolution.x,iResolution.y)*4.;\n    \n    //120-second cycle.\n    float ct = iTime/120.*TAU;\n    \n    //Rotate and flip so we're dealing with positive values.\n    uv = abs(uv*cos(ct) + uv.yx*vec2(-1.,1.)*sin(ct));\n    \n    //Target radius, with a set of coprime cycles\n    //(Cycles should also be coprime to 4, for best results)\n    vec3 r = cos(vec3(7.,3.,17.)*ct) * 2. + 4.;\n    \n    //Use our fancy findN function\n    vec3 nrad = vec3( scaleN(findN(uv,r.x)),scaleN(findN(uv,r.y)),scaleN(findN(uv,r.z)) );\n\n    vec3 col = nrad;\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}