{"ver":"0.1","info":{"id":"fdsGDl","date":"1617037441","viewed":183,"name":"Voronoi 3d test 1","username":"treize","description":"Voronoi is still deep.\nparameter is insufficient.\nMy next goal is to be able to get it out cleanly.\nI used it as a reference.\nhttps://www.shadertoy.com/view/ldl3Dl","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["3d","voronoi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p =(fragCoord.xy *2.0 -iResolution.xy) /min(iResolution.x,iResolution.y);\n\tvec3 ro = vec3( 3.5*cos(0.5*iTime), 4.0, 3.5*sin(0.5*iTime));\n    mat3 camera = SetCamera(ro, vec3( 0.0, 1.0, 0.0 ), 0.0);\n\tvec3 rd =camera * normalize(vec3(p, 1.5));\n\n    vec3 sc = vec3(0.0,1.0,0.0);\n    // raytrace\n\tfloat tmin = 10000.0;\n\tvec3  nor = vec3(0.0);\n\tfloat occ = 1.0;\n\tvec3  pos = vec3(0.0);\n    float f;\n\t// raytrace-plane\n\tfloat h = (0.0-ro.y)/rd.y;\n\tif( h>0.0 ) \n\t{ \n\t\ttmin = h; \n\t\tnor = vec3(0.0,1.0,0.0); \n\t\tpos = ro + h*rd;\n\t\tvec3 di = sc - pos;\n\t\tfloat l = length(di);\n\t\tocc = 1.0 - dot(nor,di/l)*1.0*1.0/(l*l); \n\t}\n\n\t// raytrace-sphere\n\tvec3  ce = ro - sc;\n\tfloat b = dot( rd, ce );\n\tfloat c = dot( ce, ce ) - 1.0;\n\th = b*b - c;\n\tif( h>0.0 )\n\t{\n\t\th = -b - sqrt(h);\n\t\tif( h<tmin ) \n\t\t{\n\t\t\ttmin=h; \n\t\t\tnor = normalize(ro+h*rd-sc); \n\t\t\tocc = 0.5 + 0.5*nor.y;\n\t\t}\n\t}\n\n    // shading/lighting\t\n\tvec3 col = vec3(0.9);\n\tif( tmin<100.0 )\n\t{\n\t    pos = ro + tmin*rd;\n       // f=voronoi(pos,vec3(6.0,4.0,9.0),vec3(2.0)).x;\n        f=voronoi(pos,vec3(7.0,4.0,5.0),vec3(3.0)).y;\n       // f=voronoi(pos,vec3(2.0),vec3(3.0)).z;\n      //  f=voronoi(pos,vec3(2.0),vec3(3.0)).w;\n\t\tf *= occ;\n\t\tcol = vec3(f*1.2);\n\t\tcol = mix( col, vec3(0.9), 1.0-exp( -0.003*tmin*tmin ) );\n\t}\n\tfragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec3 vhash(vec3 UV, vec3 offset)\n{\n\tmat3 m = mat3(127.1,311.7, 74.7,269.5,183.3,246.1,113.5,271.9,124.6);\n\tUV = fract(sin(UV* m) * 46839.32);\n\treturn vec3(sin(UV.z * +offset.x) * 0.5 + 0.5, cos(UV.x* offset.y) * 0.5 + 0.5,tan(UV.y * offset.z) * 0.5 + 0.5);\n}\nvec4 voronoi(vec3 p,vec3 AngleOffset, vec3 CellDensity)\n{\n\tvec3 g = floor(p * CellDensity);\n\tvec3 f = fract(p * CellDensity);\t\n    float res = 8.0;\n    float md=8.0;\n    vec3 mr;\n    vec4 Out;\n    for( int z=-1; z<=1; z++ )\n    for( int y=-1; y<=1; y++ )\n    for( int x=-1; x<=1; x++ )\n    {\n        vec3 lattice = vec3(x,y,z);\n        vec3 offset=vhash(lattice + g ,AngleOffset);\n        vec3 r = lattice +offset -f;\n        float d = dot( r, r );\n        if (d < res)\n\t\t{\n\t\t    res=d;\t\n            mr=r;\n\t\t}\n    }\n    res = 8.0;\n    for( int z=-1; z<=1; z++ )\n    for( int y=-1; y<=1; y++ )\n    for( int x=-1; x<=1; x++ )\n    {\n        vec3 lattice = vec3(x,y,z);\n        vec3 offset=vhash(lattice + g ,AngleOffset);\n        vec3 r = lattice +offset -f;\n        float d = dot( r, r );\n        if( d < res )\n        {\n\t\t    res = d;\n\t\t    Out.x =  d;\n\t\t    Out.y= offset.x;\n        }\n       \tif( dot(mr-r,mr-r)>0.00001)\n\t\t{\n            md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n\t\t}\n    }\n    Out.z = mix(1.0, 0.0, smoothstep( 0.0, 0.1, md ));\n    Out.w=1.0-smoothstep( 0.0, 0.1, res);\n    return Out;\n}\n\nmat3 SetCamera(in vec3 origin, in vec3 target, float rotation)\n{\n    vec3 forward = normalize(target - origin);\n    vec3 orientation = vec3(sin(rotation), cos(rotation), 0.0);\n    vec3 left = normalize(cross(forward, orientation));\n    vec3 up = normalize(cross(left, forward));\n    return mat3(left, up, forward);\n}","name":"Common","description":"","type":"common"}]}