{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":2,"type":"texture","id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // extract data\n    vec2 circlePos = texelFetch(iChannel1, Data1Address,0).xy;\n    vec2 rectPos = texelFetch(iChannel1, Data2Address,0).xy;\n    int score = int(texelFetch(iChannel1, Data2Address,0).w);\n    \n    vec2 uv = fragCoord/iResolution.xy; // normalized pixel coordinates \n    vec2 FirstUV = uv;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // render\n    CircleColor = vec3(0.0, 1.0, 0.0);\n    BgColor = texture(iChannel0,FirstUV).rgb;\n    vec3 kamen = texture(iChannel2,FirstUV).rgb;\n    vec3 col = vec3(BgColor);\n    \n    float circle = Circle(uv, circlePos, CircleRadius);\n    float rect = sdBox(uv, rectPos, RectSize);\n    float point;\n\n    col = mix(kamen,col,step(0.,FirstUV.y-(0.5 + Bottom)));\n    col = mix(CircleColor,col,smoothstep(0.,0.003 ,circle));\n    col = mix(RectColor,col,smoothstep(0.,0.004,rect));\n    fragColor = vec4(col,1.); // Output to screen\n}","name":"Image","description":"","type":"image"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"keyboard","id":"4dXGRr","filepath":"/presets/tex00.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// ВОЗДУХ\nbool isInAir(vec2 circlePos, vec2 velocity) {\n    return circlePos.y > Bottom + CircleRadius && velocity.y > 0.0;\n}\n\n// ЗЕМЛЯ\nbool isOnGround(vec2 circlePos, vec2 velocity) {\n    return abs(circlePos.y - (Bottom + CircleRadius)) < 0.01 && abs(velocity.y) < 0.01;\n}\n\nvec2 control() {\n    vec2 left = texelFetch(iChannel0, ivec2(KEY_LEFT, 0), 0).x * vec2(-1., 0.);\n    vec2 right = texelFetch(iChannel0, ivec2(KEY_RIGHT, 0), 0).x * vec2(1., 0.);\n    vec2 space = texelFetch(iChannel0, ivec2(KEY_UP, 0), 0).x * vec2(0., 1.);\n    return (left + right + space);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 velocity = vec2(0., 0.);  \n    float g = 1.0;      \n    float jumpStrength = 5.0;\n\n    if (iFrame == 0) {  \n        if (ivec2(fragCoord) == Data1Address)\n            fragColor = vec4(CircleStartPos, 0, 0);\n        else if (ivec2(fragCoord) == Data2Address)\n            fragColor = vec4(RectStartPos, Velocity, Score);\n    } else {\n        vec2 circlePos = texelFetch(iChannel1, Data1Address, 0).xy;\n        vec2 rectPos = texelFetch(iChannel1, Data2Address, 0).xy;\n        velocity = texelFetch(iChannel1, Data1Address, 0).zw;\n\n        if (ivec2(fragCoord) == Data1Address) {\n            // Проверка, если мяч на земле\n            if (isOnGround(circlePos, velocity)) {\n                // Если пробел (клавиша \"вверх\") нажата и мяч на земле\n                if (control().y > 0.) {\n                    velocity.y = jumpStrength;  \n                }\n            } else if (isInAir(circlePos, velocity)) {\n                // Если мяч в воздухе, применяем гравитацию\n                velocity.y -= g * iTimeDelta;\n            }\n\n            // Применяем боковое движение\n            velocity.x += StrafeAcceleration * control().x;\n\n            // Обновляем позицию мяча\n            circlePos += velocity * iTimeDelta; \n\n            // Отскоки от границ\n            if (circlePos.y < Bottom + CircleRadius || circlePos.y > 0.5 - CircleRadius) {\n                velocity.y *= -Rebounce;\n            } else if (circlePos.x < -Border || circlePos.x > Border) {\n                velocity.x *= -Rebounce;\n            } else if (sdBox(circlePos, rectPos, RectSize) < CircleRadius) {\n                velocity *= -Rebounce;\n                circlePos -= velocity * (sdBox(circlePos, rectPos, RectSize) - CircleRadius) * 10.;\n            }\n            \n            if (circlePos.y <= -0.2) circlePos.y = -0.2;\n          \n            // Ограничение позиции мяча в пределах экрана\n            circlePos = clamp(circlePos, vec2(-Border, Bottom + CircleRadius), \n                              vec2(Border, 0.5 - CircleRadius)); \n            fragColor = vec4(circlePos, velocity); \n        } else if (ivec2(fragCoord) == Data2Address) {\n            // Двигаем платформу\n            rectPos.x = 0.5 * sin(iTime * PlatformSpeed); \n            rectPos.y = RectStartPos.y; \n            fragColor = vec4(rectPos, 0, 0); \n        }\n    }\n}\n\n    \n","name":"Buffer A","description":"","type":"buffer"},{"outputs":[],"inputs":[],"code":"const int KEY_LEFT = 65;\nconst int KEY_RIGHT = 68;\n/*const int KEY_UP = 87;*/\nconst int KEY_UP = 32;\nconst vec2 CircleStartPos = vec2(0,-0.2); //нач позиция мяча\nconst float CircleRadius = 0.05; \nconst vec3 RectColor = vec3(99.,10.,19.)/256.;\nconst vec2 RectStartPos = vec2(0, 0.1);\nconst float RectSpawnBorder = 0.7;\nconst vec2 RectSize = vec2(0.2,0.02);\nconst float Border = 0.75;\nconst float Bottom = -0.2;\nconst float StrafeAcceleration = 0.01; //ускорение для бокового движения (лево, право)\nconst float JumpAcceleration = 0.05; //ускорение для прыжков\nconst float PlatformSpeed = 3.0;\nconst float Rebounce = 0.5;\nconst float g = 0.005;\n\n\n\nconst ivec2 Data1Address = ivec2(0, 0); // in texel (0,0) - circlePos\nconst ivec2 Data2Address = ivec2(0, 1); // in texel (0,1) - rectPos, Velocity,Score\n\nvec3 CircleColor = vec3(1);\nvec3 BgColor = vec3(0.);\nint Score = 0;\nfloat Velocity = .75;\n\nfloat Circle(vec2 uv, vec2 pos, float r)\n{\n    return length(uv - pos) - r;\n}\nfloat sdBox(vec2 uv, in vec2 p, in vec2 b )\n{\n    vec2 d = abs(uv - p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}","name":"Common","description":"","type":"common"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":true,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"McVBzh","date":"1733763956","viewed":49,"name":"lab1_1","username":"AnastasiaPerevyshina","description":"AAAAAAAAAAAAAA","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["lab1"],"hasliked":0,"parentid":"","parentname":""}}