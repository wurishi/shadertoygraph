{"ver":"0.1","info":{"id":"MlBXWV","date":"1446490497","viewed":770,"name":"inverse trochoids dispersion","username":"jt","description":"Trying to use approximated inverse trochoids for water-ripples,\nbased on FabriceNeyret2 waves-dispersion [url]https://www.shadertoy.com/view/MtBSDG[/url]\nand inverse trochoids [url]https://www.shadertoy.com/view/MtSSDG[/url].\n","likes":14,"published":1,"flags":8,"usePreview":0,"tags":["inversetrochoids","wavesdispersion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// \"Trochoid dispersion\" by Jakob Thomsen, based on FabriceNeyret2 waves-dispersion and inverse trochoids\n// (https://www.shadertoy.com/view/MtBSDG resp. https://www.shadertoy.com/view/MtSSDG)\n// (Trochoid approximation-function: https://www.shadertoy.com/view/ltjXDG)\n// Assumption: to use trochoids for water-ripples in waves-dispersion we replace sin by trochoid(?)\n// Question: Which value should A have? For low values the result looks like using sines -> use hight values, e.g. A = 0.8 or A = 1.0\n// Question: Or could A be a function of the distance?\n// Question: Why/how should bessel-functions be used?\n\n// Original code:\n// different wavelengths travels at different speed: this is dispersion\n// there are 2 main cases: gravity waves + capillary waves\n// (+ mix case + shallow water + mix case + soliton + ... ok, forget theses :-p )\n// Physics of dispersion here: https://en.wikipedia.org/wiki/Capillary_wave\n\n// in 2D, add 1/r modulation. Or better: use Bessels instead of sines.\n\nfloat A,X, t; \nvec2 R;\n\nfloat trochoids_approx(float v) // jt's approximation to FabriceNeyret2's inverse trochoid function (source: https://www.shadertoy.com/view/MtSSDG)\n{ // (Trochoid approximation-function: https://www.shadertoy.com/view/ltjXDG)\n    return -A + 2.0 * A * pow(1.0 - pow(0.5 + 0.5 * sin(v), A + 1.0), 1.0 / (A + 1.0));\n}\n\nfloat single_trochoid_approx(float v) // experimenting with inverse trochoid \"singleton\"\n{\n    //return -(2.0 * exp(-sqrt(pow(v, 2.0) + 1.0 / A - 1.0)) - A); // apparently some systems can't handle v^2 for negative v?!\n    return -(2.0 * exp(-sqrt(v * v + 1.0 / A - 1.0)) - A);\n}\n\nfloat sech(float v) // experimenting with inverse trochoid \"singleton\"\n{\n    return 2.0 / (exp(v) + exp(-v));\n}\n\n#define W(x,k,c) A*trochoids_approx(k*(X=x-c*t))*exp(-X*X)\n#define W_new(x,k,c) A*single_trochoid_approx(k*(X=x-c*t))*exp(-X*X)\n\n#define plot(Y) o += smoothstep(40./R.y, 0., abs(Y-U.y))\n#define plot_r(Y) o.r += smoothstep(40./R.y, 0., abs(Y-U.y))\n#define plot_g(Y) o.g += smoothstep(40./R.y, 0., abs(Y-U.y))\n\nvoid mainImage( out vec4 o, in vec2 U )\n//void mainImage( inout vec4 o, vec2 U ) // ERROR: overloaded functions must have the same parameter qualifiers\n{\n    A=1.0,t=mod(iTime,10.); \n    R = iResolution.xy;\n\n    U = 10.* (2.*U-R)/R.y;\n    o -= o;\n    float Y0 = 0.0, y0;\n    float Y0_new = 0.0, y0_new;\n    float Y1 = 0.0, y1;\n    float Y1_new = 0.0, y1_new;\n    for (float k=1.; k<10.; k++) { // waves dispersion from: https://www.shadertoy.com/view/MtBSDG\n        // Y0 += y0 = W(abs(U.x), k, sqrt(k))/k;   // dispertion for capillary waves\n        Y0 += y0 = W(U.x, k, sqrt(k))/k + W(-U.x, k, sqrt(k))/k;   // dispertion for capillary waves (no abs-\"kink\")\n        Y0_new += y0_new = W_new(U.x, k, sqrt(k))/k + W_new(-U.x, k, sqrt(k))/k;   // dispertion for capillary waves (no abs-\"kink\")\n        // Y1 += y = W(abs(uv.x), k, 1./sqrt(k))/k;// dispertion for gravity waves\n        Y1 += y1 = W(U.x, k, 1./sqrt(k))/k + W(-U.x, k, 1./sqrt(k))/k;// dispertion for gravity waves (no abs-\"kink\")\n        Y1_new += y1_new = W_new(U.x, k, 1./sqrt(k))/k + W_new(-U.x, k, 1./sqrt(k))/k;// dispertion for gravity waves (no abs-\"kink\")\n\t    plot( y0 - 3.  ); \n        plot_r( y0_new - 3.  ); \n        plot( y1 - 6.  ); \n        plot_r( y1_new - 6.  ); \n    }\n\n    plot( Y0 + 6. );\n    plot_r( Y0_new + 6. );\n    plot( Y1 + 3. );\n    plot_r( Y1_new + 3. );\n    \n    //plot( exp(-pow(uv.x, 2.0)) );\n    plot( trochoids_approx(U.x + 0.5 * 3.1415926) );\n    plot_r( single_trochoid_approx(U.x) );\n    plot_g( -2.0 * A * (sech(U.x) - 0.5) );\n    \n    o.b += .2;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"XsfGRr","channel":0}],"code":"float A = 1.0, X;\nfloat trochoids_approx(float v) // jt's approximation to FabriceNeyret2's inverse trochoid function (source: https://www.shadertoy.com/view/MtSSDG)\n{ // (Trochoid approximation-function: https://www.shadertoy.com/view/ltjXDG)\n    return -A + 2.0 * A * pow(1.0 - pow(0.5 + 0.5 * sin(v), A + 1.0), 1.0 / (A + 1.0));\n}\n\nfloat single_trochoid_approx(float v) // experimenting with inverse trochoid \"singleton\"\n{\n    //return -(2.0 * exp(-sqrt(pow(v, 2.0) + 1.0 / A - 1.0)) - A); // apparently some systems can't handle v^2 for negative v?!\n    return -(2.0 * exp(-sqrt(v * v + 1.0 / A - 1.0)) - A);\n}\n\n#define W(x,k,c) A*trochoids_approx(k*(X=x-c*t))*exp(-X*X)\n#define W_new(x,k,c) A*single_trochoid_approx(k*(X=x-c*t))*exp(-X*X)\n\nvec2 mainSound( in int samp,float time)\n{\n    float pos = mod(time * 111.0, 200.0); // varying the sample-psition yields different sounds\n    float t=440.0*mod(time,2.);\n    vec2 Y = vec2(0.0); // stereo sound\n    for (float k=1.; k<100.; k++) {\n        Y.x += W(2.5 * pos, k, sqrt(k))/k; // dispertion for capillary waves\n        Y.y += W(pos, k, 1./sqrt(k))/k;// dispertion for gravity waves\n    }\n    return 5.0 * Y;\n}\n","name":"Sound","description":"","type":"sound"}]}