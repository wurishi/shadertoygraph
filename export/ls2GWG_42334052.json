{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// 2D vector field visualization by Matthias Reitinger, @mreitinger\n// Based on \"2D vector field visualization by Morgan McGuire, http://casual-effects.com\", https://www.shadertoy.com/view/4s23DG\n\nconst float ARROW_TILE_SIZE = 32.0;\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos) {\n\treturn (floor(pos / ARROW_TILE_SIZE) + 0.5) * ARROW_TILE_SIZE;\n}\n\n// Computes the signed distance from a line segment\nfloat line(vec2 p, vec2 p1, vec2 p2) {\n\tvec2 center = (p1 + p2) * 0.5;\n\tfloat len = length(p2 - p1);\n\tvec2 dir = (p2 - p1) / len;\n\tvec2 rel_p = p - center;\n\tfloat dist1 = abs(dot(rel_p, vec2(dir.y, -dir.x)));\n\tfloat dist2 = abs(dot(rel_p, dir)) - 0.5*len;\n\treturn max(dist1, dist2);\n}\n\n// v = field sampled at arrowTileCenterCoord(p), scaled by the length\n// desired in pixels for arrows\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p, vec2 v) {\n\t// Make everything relative to the center, which may be fractional\n\tp -= arrowTileCenterCoord(p);\n\t\t\n\tfloat mag_v = length(v), mag_p = length(p);\n\t\n\tif (mag_v > 0.0) {\n\t\t// Non-zero velocity case\n\t\tvec2 dir_v = v / mag_v;\n\t\t\n\t\t// We can't draw arrows larger than the tile radius, so clamp magnitude.\n\t\t// Enforce a minimum length to help see direction\n\t\tmag_v = clamp(mag_v, 5.0, ARROW_TILE_SIZE * 0.5);\n\n\t\t// Arrow tip location\n\t\tv = dir_v * mag_v;\n\n\t\t// Signed distance from shaft\n\t\tfloat shaft = line(p, v, -v);\n\t\t// Signed distance from head\n\t\tfloat head = min(line(p, v, 0.4*v + 0.2*vec2(-v.y, v.x)),\n\t\t                 line(p, v, 0.4*v + 0.2*vec2(v.y, -v.x)));\n\n\t\treturn min(shaft, head);\n\t} else {\n\t\t// Signed distance from the center point\n\t\treturn mag_p;\n\t}\n}\n\n/////////////////////////////////////////////////////////////////////\n\n// The vector field; use your own function or texture\nvec2 field(vec2 pos) {\n//\treturn 2.0 * texture(iChannel1, mod(pos, 2.0 * iChannelResolution[1].xy) * 0.5 / iChannelResolution[1].xy).xy - 1.0;\n//\treturn 2.0 * texture(iChannel0, (pos + vec2(iTime * 100.0, 0.0)) / iChannelResolution[0].xy).xy - 1.0;\n//\treturn vec2(0.0, 0.0);\n\treturn vec2(cos(pos.x * 0.01 + pos.y * 0.01) + cos(pos.y * 0.005 + iTime), 2.0 * cos(pos.y * 0.01  + iTime * 0.3)) * 0.5;\n//\treturn vec2(cos(pos.x * 0.017 + cos(pos.y * 0.004 + iTime * 0.1) * 6.28 * 4.0) * 3.0, cos(6.28 * cos(pos.y * 0.01 + pos.x * 0.007)));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat arrow_dist = arrow(fragCoord.xy,\n\t                         field(arrowTileCenterCoord(fragCoord.xy)) * ARROW_TILE_SIZE * 0.4);\n\tvec4 arrow_col = vec4(0, 0, 0, clamp(arrow_dist, 0.0, 1.0));\n\tvec4 field_col = vec4(field(fragCoord.xy) * 0.5 + 0.5, 0.5, 1.0);\n\t\n\tfragColor = mix(arrow_col, field_col, arrow_col.a);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ls2GWG","date":"1393028751","viewed":1902,"name":"2D Vector Field Quiver Plot","username":"reima","description":"Based on Morgan McGuire's https://www.shadertoy.com/view/4s23DG, but with Matlab style quiver plot visualization.","likes":38,"published":1,"flags":0,"usePreview":1,"tags":["flow","vector","antialiased","arrow"],"hasliked":0,"parentid":"","parentname":""}}