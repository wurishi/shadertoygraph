{"ver":"0.1","info":{"id":"dtS3DV","date":"1677213496","viewed":133,"name":"Mandelbulb raymarcher0","username":"Mik0","description":"Mandelbulb but the shadows are weird","likes":0,"published":3,"flags":0,"usePreview":0,"tags":["mandelbulb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float mandelbulb(vec3 pos,  float Power) {\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < 4 ; i++) {\n\t\tr = length(z);\n\t\tif (r>50.0) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\n\nconst float pi = asin(1.0);\nconst float constant = 90.0/pi;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=0.5;\n    uv.x*=iResolution.x/iResolution.y;\n    vec2 turn = vec2(((iTime/10.0)*constant)+180.0, -45);\n    vec3 cam_pos = vec3(sin((iTime/10.0))*2.0, cos((iTime/10.0))*2.0, 2);\n    vec3 cam_dir = vec3(sin((turn.x)/constant)*cos((turn.y)/constant), cos((turn.x)/constant)*cos((turn.y)/constant), sin((turn.y)/constant));\n    vec3 cam_right = vec3(sin((turn.x+90.0)/constant), cos((turn.x+90.0)/constant), 0.0);\n    vec3 cam_up = vec3(sin((turn.x)/constant)*cos((turn.y+90.0)/constant), cos((turn.x)/constant)*cos((turn.y+90.0)/constant), sin((turn.y+90.0)/constant));\n    vec3 cam_scrn = (cam_dir*1.0)+(cam_right*uv.x)+(cam_up*uv.y);\n    vec3 ray_origin = cam_pos;\n    vec3 ray_vec = normalize(cam_scrn);\n    \n    float power = 8.0;\n    \n    float dist = 1.0;\n    while(dist>0.001)\n    {\n        dist = mandelbulb(ray_origin, power);\n        if (dist > 10.0)\n        {break;}\n        ray_origin+=ray_vec*dist;\n    }\n\n\n    // Time varying pixel color\n    vec3 col = abs(ray_vec)*((ray_vec.z+1.0)/2.0);\n    if(dist<0.001)\n    {\n        vec2 eps = vec2(0.00001, 0.0);\n        vec3 pos = ray_origin;\n\n        vec3 normal = normalize(vec3(\n\n            mandelbulb(pos + eps.xyy,  power) - mandelbulb(pos - eps.xyy,  power),\n\n            mandelbulb(pos + eps.yxy,  power) - mandelbulb(pos - eps.yxy,  power),\n\n            mandelbulb(pos + eps.yyx,  power) - mandelbulb(pos - eps.yyx,  power)\n\n    ));\n        vec3 light = vec3(sin(0.0)*cos(pi/2.0), cos(0.0)*cos(pi/2.0), sin(pi/2.0));\n        float brightness = dot(-normal,  normalize(light));\n        ray_vec=light;\n        dist = 1.0;\n        ray_origin+=ray_vec*0.035;\n        int maxShadowIters = 100;\n        int shadowI = 0;\n        while (dist<0.01)\n        {\n            shadowI+=1;\n            if(shadowI>maxShadowIters){break;}\n            dist = mandelbulb(ray_origin, power);\n            ray_origin+=ray_vec*dist;\n        }\n        dist = 1.0;\n        while(dist>0.001)\n\n        {\n\n        dist = mandelbulb(ray_origin, power);\n\n        if (dist > 100.0)\n\n        {break;}\n\n        ray_origin+=ray_vec*dist;\n\n        }\n        if(dist<0.001){brightness*=0.2;}\n        \n        //brightness=1.0;\n        col=abs(vec3(1))*brightness;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}