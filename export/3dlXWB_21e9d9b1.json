{"ver":"0.1","info":{"id":"3dlXWB","date":"1552054084","viewed":78,"name":"Mashgraph - Task1","username":"apospelova","description":"Map with the differnet figures","likes":2,"published":1,"flags":16,"usePreview":0,"tags":["figures"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Управление камерой происходит с помощью мыши.\n * Действия при нажатии клавиш:\n * \"0\" - on/off - блокировка всех эффектов - возвращение в \"дефолтный\" вид1\n * \"1\" - on/off - фигуры двигаются.\n*/\n\n#define KEY_0 48\n#define KEY_1 49\n#define KEY_2 50\n#define KEY_3 51\n#define KEY_4 52\n#define KEY_5 53\n#define KEY_6 54\n#define KEY_7 55\n#define KEY_8 56\n#define KEY_9 57\n\n#define Keyboard iChannel0\n#define DEFAULT_KEY KEY_0\n#define KEY_FIGURES_MOVE KEY_1\n\nmat3 Create_Transformation_Matrix(in vec3 Eye_Position, in vec3 Gaze_Position) {\n\tvec3 z = normalize(Gaze_Position - Eye_Position);\n\tvec3 x = cross(z, vec3(0.0, 1.0, 0.0));\n\tvec3 y = cross(x, z);\n\treturn mat3(x, y, z);\n}\n\nbool Toggled_Key(int Key) {return texelFetch(Keyboard, ivec2(Key, 2), 0).x > 0.0;}\n\nfloat Sphere(vec3 Distance, float Radius) {return length(Distance) - Radius;}\n\nfloat Box(vec3 Distance, vec3 Box_Size) {\n\tvec3 Surface_Distance = abs(Distance) - Box_Size;\n\treturn min(max(Surface_Distance.x, max(Surface_Distance.y, Surface_Distance.z)), 0.0) + length(max(Surface_Distance, 0.0));\n}\n\nfloat Cylinder(vec3 Distance, vec2 Height) {\n\tvec2 Surface_Distance = abs(vec2(length(Distance.xz), Distance.y)) - Height;\n\treturn length(max(Surface_Distance, 0.0)) + min(max(Surface_Distance.x, Surface_Distance.y), 0.0);\n}\n\n\nfloat Cone(in vec3 Distance, in vec3 Cone_Size) {\n\tvec2 Axis = vec2(length(Distance.xz), Distance.y);\n\tfloat Axis_Distance = -(Axis.y + Cone_Size.z);\n\tfloat Weidth_Distance = max(dot(Axis, Cone_Size.xy), Axis.y);\n\treturn length(max(vec2(Axis_Distance, Weidth_Distance), 0.0)) + min(max(Axis_Distance, Weidth_Distance), 0.0);\n}\n\nfloat Torus(vec3 Distance, vec2 Radiusis) {\n    return length(vec2(length(Distance.xz) - Radiusis.x, Distance.y)) - Radiusis.y;\n}\n\nfloat Substraction(float Figure1, float Figure2) {return max(Figure1, -Figure2);}\n\nfloat Union(float Figure1, float Figure2) {return min(Figure1, Figure2);}\n\nvec2 Get_The_Closest_Pixel(vec2 pixel1, vec2 pixel2) {\n\tif (pixel1.x < pixel2.x) return pixel1;\n\telse return pixel2;\n}\n\nvec2 Get_Figures_Pixel(in vec3 Pixel_Position) {\n\tvec2 Figures[7];\n    float Move = 1.0;\n    if (Toggled_Key(KEY_FIGURES_MOVE)) Move = abs(sin(iTime * 0.4));\n    if (Toggled_Key(DEFAULT_KEY)) Move = 1.0;\n\tFigures[0] = vec2(Sphere(Pixel_Position - vec3(0.0, 0.5, 0.0), 0.25 * Move), 1.0);\n\tFigures[1] = vec2(Box(Pixel_Position - vec3(1.0, 0.5, 1.0), vec3(0.2)), 2.0);\n\tFigures[2] = vec2(Cylinder(Pixel_Position - vec3(0.8, Move * 0.3, -1.3), vec2(0.1, 0.2)), 3.0);\n\tFigures[3] = vec2(Cone(Pixel_Position - vec3(-1.0, 0.7, Move * 1.0), vec3(0.2, 0.2, 0.5)), 4.0);\n\tFigures[4] = vec2(Torus(Pixel_Position - vec3(0.0, 0.9 * Move, 0.0), vec2(0.3, 0.05)), 5.0);\n\tFigures[5] = vec2(Substraction(Box(Pixel_Position - vec3(-0.6, 0.3, -1.2), vec3(0.3)),\n\t\t\t\t\t\t\t\t\tSphere(Pixel_Position - vec3(-0.6, 0.3, -1.2), 0.35)), Move * 6.0);\n\tFigures[6] = vec2(Union(Cylinder(Pixel_Position - vec3(1.0, 0.3, Move * 0.5), vec2(0.06, 0.25)),\n\t\t\t\t\t\t\tCone(Pixel_Position - vec3(1.0, 0.5,Move * 0.5), vec3(0.2, 0.15, 0.3))), 7.0);\n\tvec2 Figure_Pixel = vec2(1e10, 0.0);\n    for (int i = 0 ; i < 7; i++)\n        Figure_Pixel = Get_The_Closest_Pixel(Figure_Pixel, Figures[i]);\n\treturn Figure_Pixel;\n}\n\nvec2 Get_Ray_Intersection(in vec3 Eye_Position, in vec3 Gaze_Position) {\n\tvec2 Intersection_Pixel = vec2(-1.0, -1.0); // Out of picture.\n\tfloat Out_Pixel = - Eye_Position.y / Gaze_Position.y;\n\tfloat Max_Pixel = 50.0;\n\tif (Out_Pixel > -1.0) {\n\t\tMax_Pixel = min(Out_Pixel, Max_Pixel);\n\t\tIntersection_Pixel = vec2(Out_Pixel, 0.0); // Screen.\n\t}\n\tfloat Current_Pixel = 0.0;\n    while (Current_Pixel < Max_Pixel) {\n\t\tvec2 Figure_Pixel = Get_Figures_Pixel(Eye_Position + Current_Pixel * Gaze_Position);\n\t\tif (0.00001 * Current_Pixel > Figure_Pixel.x) { \n\t\t\tIntersection_Pixel = vec2(Current_Pixel, Figure_Pixel.y); \n\t\t\treturn Intersection_Pixel;\n\t\t}\n\t\tCurrent_Pixel = Current_Pixel + Figure_Pixel.x;\n\t}\n\treturn Intersection_Pixel;\n}\n\nvec3 Get_Normal(in vec3 Pixel_Position) {\n\tfloat eps = 0.001;\n\tvec3 epsX = vec3(eps, 0.0, 0.0);\n\tvec3 epsY = vec3(0.0, eps, 0.0);\n\tvec3 epsZ = vec3(0.0, 0.0, eps);\n\tfloat dx = Get_Figures_Pixel(Pixel_Position + epsX).x - Get_Figures_Pixel(Pixel_Position - epsX).x;\n\tfloat dy = Get_Figures_Pixel(Pixel_Position + epsY).x - Get_Figures_Pixel(Pixel_Position - epsY).x;\n\tfloat dz = Get_Figures_Pixel(Pixel_Position + epsZ).x - Get_Figures_Pixel(Pixel_Position - epsZ).x;\n\treturn normalize(vec3(dx, dy, dz));\n}\n\nstruct Light {\n    vec3 Light_Position;\n    vec3 Light_Color;\n};\n\nstruct Material {\n\tvec3 Ambient_Light;\n\tvec3 Diffuse_Light;\n\tvec3 Specular_Light;\n\tfloat Material_Shininess;\n}; \n\nfloat Fractal_Floor(in vec2 Pixel_Position) {\n\tvec2 width = fwidth(Pixel_Position);\n\tvec2 Integral = abs(fract((Pixel_Position + width / 2.0) / 2.0) - 0.5);\n    Integral -= abs(fract((Pixel_Position - width / 2.0) / 2.0) - 0.5);\n    Integral /= width;\n \treturn (1.0 - Integral.x * Integral.y) / 2.0;\n}\n\nvec3 Fractal_Cone(in vec2 Pixel_Position) {\n\tvec2 z  = vec2(0.0);\n\tvec2 dz = vec2(0.0);\n\tfor (int i=0; i < 500; i++) {\n\t\tif (dot(z,z) > 4.0) break;\n \t\tdz = 2.0 * vec2(0.5 + z.x * dz.x - z.y * dz.y, 0.5 + z.x * dz.y + z.y * dz.x);\t\t\n \t\tz = Pixel_Position * 0.01 + vec2(z.x * z.x - z.y * z.y - 0.53, 2.0 * z.x * z.y + 0.52);\n    }\n\tfloat Distance = log(dot(z, z)) * sqrt(dot(z, z) / dot(dz, dz));\n    return vec3(2.0 * sqrt(pow(clamp(Distance * 100.0, 0.0, 1.0), 0.3)));\n}\n\nMaterial Get_Material(in float Figure_Index, in vec3 Pixel_Position) {\n    Material material;\n    if (Figure_Index == 0.0) { // The screen\n\t\tmaterial.Ambient_Light = 0.06 + vec3(2.0 * Fractal_Floor(10.0 * Pixel_Position.xz), 0.0, 0.0);\n\t\tmaterial.Diffuse_Light = material.Ambient_Light + 0.8;\n\t\tmaterial.Material_Shininess = 1000.0;\n    }\n    else { // Different materials for different Figures.\n        if (Figure_Index == 4.0) {\n            material.Ambient_Light = Fractal_Cone(Pixel_Position.xz);\n            material.Diffuse_Light = material.Ambient_Light + 0.8;\n        } else {\n            material.Ambient_Light = sin(Figure_Index * vec3(1.0, 0.2, 0.7));\n        \tmaterial.Diffuse_Light = sin(material.Ambient_Light + vec3(0.5));\n        }\n        material.Material_Shininess = (8.0 - Figure_Index) * 20.0;\n    }\n    material.Specular_Light = vec3(1.0, 1.0, 1.0);\n    return material;\n}\n\nfloat Get_Shadow(in vec3 Pixel_Position, in vec3 Light_Position) {\n\tfloat Light_Length = 0.9;\n\twhile (Light_Length < 5.0) {\n        float Closer_Pixel = Get_Figures_Pixel(Pixel_Position + Light_Position * Light_Length).x;\n        if (Closer_Pixel < 0.001) return 0.0;\n        Light_Length += Closer_Pixel;\n    }\n\treturn 1.0;\n}\n\nfloat Get_Soft_Shadow(in vec3 Pixel_Position, in vec3 Light_Position) {\n\tfloat Pixel_Offset = (0.8 - Pixel_Position.y) / Light_Position.y;\n\tif (Pixel_Offset > 0.0) Pixel_Offset = min(5.0, Pixel_Offset);\n \tfloat Shadow_Flag = 1.0;\n \tfloat Light_Length = 0.9;\n \tfor (int i = 0; i < 5; i++) {\n\t\tfloat Closer_Pixel = Get_Figures_Pixel(Pixel_Position + Light_Position * Light_Length).x;\n\t\tShadow_Flag = min(Shadow_Flag, 8.0 * Closer_Pixel / Light_Length);\n\t\tLight_Length += Closer_Pixel;\n\t\tif ((Shadow_Flag < 0.001) || (Light_Length > Pixel_Offset)) return Shadow_Flag;\n\t}\n\treturn Shadow_Flag;\n}\n\nfloat Get_Ambient_Occlusion(in vec3 Pixel_Position, in vec3 Normal) {\n\tfloat Ambient_Occlusion = 0.0;\n\tfloat Light_Length = 0.0;\n\tfor (int i = 0; i < 5; i++) {\n\t\tLight_Length = float(i) / 6.0 + 0.1;\n\t\tAmbient_Occlusion += (Light_Length - Get_Figures_Pixel(Pixel_Position + Normal * Light_Length).x) / exp(Light_Length);\n\t}\n\tAmbient_Occlusion /= 6.0;\n\treturn clamp(pow(1.0 - Ambient_Occlusion, 1.0), 0.0, 1.0);\n}\n\nvec3 Get_Color(in vec3 Eye_Position, in vec3 Gaze_Position) {\n\tvec2 Ray_Intersection = Get_Ray_Intersection(Eye_Position, Gaze_Position); // (pixel, figure index)\n    if (Ray_Intersection.y == -1.0) return vec3(0.6, 0.9, 1.0); // Out of picture.\n\tvec3 Pixel_Position = Eye_Position + Ray_Intersection.x * Gaze_Position;\n    Light Lights[2];\n\tLights[0].Light_Position = normalize(vec3(10.0, 5.0, 5.0));\n\tLights[1].Light_Position = normalize(vec3(-10.0, 5.0, 5.0));\n\tLights[0].Light_Color = normalize(vec3(1.0, 1.0, 1.0));\n\tLights[1].Light_Color = normalize(vec3(1.0, 1.0, 0.5));\n    Material material = Get_Material(Ray_Intersection.y, Pixel_Position);\n\tvec3 Normal = vec3(0.0, 1.0, 0.0);\n\tif (Ray_Intersection.y > 0.0) Normal = Get_Normal(Pixel_Position); // For figures.\n\tvec3 Reflection = reflect(Gaze_Position, Normal);\n    vec3 Color = vec3(0.0);\n    for (int i = 0; i < 2; i++) {\n\t\tvec3 i_Color = vec3(0.1) * material.Ambient_Light; // Ambient light.\n        vec3 Light_Direction = normalize(Lights[i].Light_Position - Gaze_Position);\n\t\ti_Color += vec3(0.5) * vec3(max(0.0, dot(Lights[i].Light_Position, Reflection))) * material.Diffuse_Light; // Diffuse light.\n        i_Color += pow(max(dot(Light_Direction, Normal), 0.0), material.Material_Shininess) * material.Specular_Light; // Specular light.\n\t\tColor += i_Color * Lights[i].Light_Color;\n    \tColor *= Get_Shadow(Pixel_Position, Lights[i].Light_Position);\n\t\tColor *= Get_Soft_Shadow(Pixel_Position, Lights[i].Light_Position);\n        Color *= Get_Ambient_Occlusion(Pixel_Position, Normal);\n    }\n    Color = mix(Color, vec3(0.6, 0.9, 1.0), clamp((1.0 - exp(-0.001 * Ray_Intersection.x * Ray_Intersection.x)), 0.0, 1.0));\n\treturn Color;\n}\n    \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n \tvec2 Mouse_Position = iMouse.xy / iResolution.xy;\n\tvec3 Eye_Position = vec3(5.0 * cos(Mouse_Position.x * 6.0), Mouse_Position.y * 1.0 + 1.0,\n\t\t\t\t\t\t\t5.0 * sin(Mouse_Position.x * 6.0)); \n\tmat3 Transformation_Matrix = Create_Transformation_Matrix(Eye_Position, vec3(0.0));\n\tvec3 Color = vec3(0.0, 0.0, 0.0);\n\tfor (int i = 0; i < 2; i++)\n\t\tfor (int j = 0; j < 2; j++) {\n \t\t\tvec2 Pixel_Offset = vec2(float(i), float(j)) / 2.0; // Antialiasing.\n\t\t\tvec2 Pixel_Position = ((fragCoord.xy + Pixel_Offset) * 2.0 - iResolution.xy) / iResolution.y;\n\t\t\tvec3 Ray_Direction = Transformation_Matrix * normalize(vec3(Pixel_Position.xy, 4.0));\n\t\t\tColor += Get_Color(Eye_Position, Ray_Direction);\n\t}\n    Color = pow(Color / 4.0, vec3(0.7));\n\tfragColor = vec4(Color, 1.0);\n}","name":"Image","description":"","type":"image"}]}