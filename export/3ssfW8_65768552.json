{"ver":"0.1","info":{"id":"3ssfW8","date":"1588408926","viewed":324,"name":"Infinite Pinballs","username":"BradyInstead","description":"Messed around with raymarched reflections and made this","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","reflections"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Brady's Reflections\" by BradyInstead. https://shadertoy.com/view/tsXfD8\n// 2020-04-29 09:06:59\n\n\n#define MAX_MARCH 12.\n#define MAX_MARCH_REFLECT 2.\n\n#define REFLECT_POWER .8\n\n#define NUM_REFLECTIONS 4\n\nfloat opSmoothUnion( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat sphere(vec3 p)\n{\n    float div = 1.05;\n    vec3 grid = floor(p/div);\n    p.xz = mod(p.xz, div) - div/2.;\n\n    p.y -= abs(sin(iTime + grid.x*2.)*.1);\n    p.y -= abs(cos(iTime + grid.z*2.)*.1);\n    \n    float sphere = length(p) - .5;\n    float amp = .05;\n    \n    grid = abs(grid);\n    return sphere - amp*sin(iTime*5. + grid.z)*sin(iTime + grid.x)*sin(iTime + grid.z*7.) + amp;\n}\n  \nfloat plane( vec3 p)\n{\n\treturn abs(p.y);\n}\n\nfloat model(vec3 p)\n{\n    float amount = .05;\n    \n    // movement\n    p.xz -= iTime*.5;\n    \n    float sp = sphere(p);\n    float pl = plane(p + vec3(0, .5, 0.));\n    \n    return min(sp, pl);\n}\n\nfloat raymarch(in vec3 ro, in vec3 rd, float maxdist, float modifier)\n{\n    float dist = 0.;\n    for(int i = 0; i < 90; i++)\n    {\n\t\tfloat m = model(ro+rd*dist)*modifier;\n        dist += m;\n        \n        if(m < .001) return dist;\n        else if(dist > maxdist) break;\n    }\n    return -1.;\n}\n\nvec3 normal(vec3 pos)\n{\n    vec3 eps = vec3(.01, -.01, 0.);\n    \n    return normalize(vec3(\n        model(pos + eps.xzz) - model(pos + eps.yzz),\n        model(pos + eps.zxz) - model(pos + eps.zyz),\n        model(pos + eps.zzx) - model(pos + eps.zzy)));\n}\n\nfloat shadow(in vec3 pos, in vec3 ld)\n{\n    float spread = 3.;\n    float res = 1.0;\n\tfor(float t = .2; t < .4;)\n    {\n        float dist = model(pos+ld*t);\n        if(dist<.001) return 0.;\n        res = min(res, spread*dist/t);\n        t += dist;\n    }\n    return res;\n}\n\n\nvec3 background()\n{\n    return vec3(0.);\n    //return vec3(.2, .3, .1);\n}\n\nvec3 shade(vec3 pos, vec3 nor, vec3 rd, float dist)\n{\n    if(dist < 0.) return background();\n    \n    vec3 lp = vec3(2., 2., 0.);\n    vec3 ld = normalize(lp-pos);\n    \n    float dif = max(dot(nor,ld),0.);\n    float sha = 0.;\n    if(dif > .01) sha = shadow(pos, ld);\n    vec3 lin = vec3(dif) * vec3(sha) * vec3(1.0);\n    \n    float sharp = 10.0;\n    float inten = .5;\n    vec3 ref = 2.0 * dot(ld, nor)*nor-ld;\n    lin += pow(max(0., dot(-rd, ref)), sharp) * vec3(inten) * sha;\n    \n    vec3 col = lin;\n    col *= exp(-.01*dist*dist);\n    col *= 0.3+0.7*clamp((pos.y+0.5)*2.0,0.0,1.0);\n    \n    return col;\n}\n\n//\t1. raymarch until you hit something\n//\t2. calculate the surface normal at that spot\n//\t3. reflect your marching vector: dir -= 2. * dot(dir, normal) * normal\n//\t4. march in the new direction until you hit something else\n//\t5. figure out the colour for the second hit location (use lighting, etc.)\n//\t6. figure out the colour for the first hit, using the second hit's color as part of the calculation\n\nvec3 reflection(vec3 pos, vec3 rd, vec3 nor, float dist)\n{\n    if(dist < -.1) return background();\n    \n    vec3 rrd = reflect(rd, nor);\n    vec3 rro = pos + rrd*.02;\n    \n    vec3 col = vec3(0.);\n    vec3 fade = vec3(1.);\n    \n    for(int i = 0; i < NUM_REFLECTIONS; i++)\n    {\n    \tfloat rdist = raymarch(rro, rrd, MAX_MARCH_REFLECT, 1.);\n    \n    \tvec3 rpos = rro + rrd*rdist;\n    \tvec3 rnor = normal(rpos);\n    \n    \tfade -= pow(1. - rdist/MAX_MARCH_REFLECT, .5) * .3; //* vec3(.5, .9, .1);\n        \n        rrd = reflect(rrd, rnor);\n    \trro = rpos + rrd*.02;\n       \n        col += shade(rpos, rnor, rrd, rdist) * fade;\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    \n    //vec2 s = sign(p);\n    p.x = abs(p.x);\n    //p.y = pow(p.y, .8);\n    \n    \n    vec3 ro = vec3(3., 3., 3.); \n    vec3 ta = vec3(0.0, 0., 0.0);\t\t\t\t\n    \n    vec3 w = normalize (ta-ro);\n    vec3 u = normalize (cross (w, vec3(0., 1., 0.)));\n    vec3 v = normalize (cross (u, w));\n    mat3 mat = mat3(u, v, w);\n    vec3 rd = normalize (mat*vec3(p.xy,1.5));\n    \n    float dist = raymarch(ro, rd, MAX_MARCH, 1.);\n    vec3 pos = ro+rd*dist;\n    vec3 nor = normal(pos);\n    \n    vec3 col = shade(pos, nor, rd, dist);\n    vec3 ref = reflection(pos, rd, nor, dist);\n    \n    //col = mix(col, ref, REFLECT_POWER);\n    col += ref*REFLECT_POWER;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}