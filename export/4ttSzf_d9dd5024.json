{"ver":"0.1","info":{"id":"4ttSzf","date":"1480965785","viewed":127,"name":"#Devember 2016 -  day 04","username":"theGiallo","description":"Studying primitives ray-marching and clean and modular way to structure code.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","primitives","learning","devember"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SQRT2 1.4142135623730950488016887242096980785696\n#define PI    3.1415926535897932384626433832795\n#define HPI   1.57079632679489661923132169\n#define QPI   0.785398163397448309615660845819875721\n#define TAU   6.283185307179586476925286766559\n\nfloat\nmanhattan( vec2 p )\n{\n    p = abs ( p );\n    float ret = p.x + p.y;\n    return ret;\n}\nfloat\nmanhattan( vec2 p0, vec2 p1 )\n{\n    float ret;\n    \n    vec2 d = abs ( p1 - p0 );\n    ret = d.x + d.y;\n    \n    return ret;\n}\nvec4\ncircle( vec4 color, vec2 pos, float radius, float border_width, vec2 point )\n{\n    vec4 ret = vec4(0);\n    color.rgb *= color.a;\n    \n    float dist = length( point - pos );\n    ret = color * (1.0 - smoothstep( radius, radius + border_width, dist ) );\n    \n    return ret;\n}\nvec4\nsquare( vec4 color, vec2 pos, float side, float border_width, float rot_rad, vec2 point )\n{\n    vec4 ret = vec4(0);\n    color.rgb *= color.a;\n    \n    float max_d = SQRT2 * side;\n    vec2 rd = point - pos;\n    float tot_rad = QPI + rot_rad;\n    vec2 rd_rot;\n    rd_rot.x = rd.x * cos( tot_rad ) + rd.y * sin( tot_rad );\n    rd_rot.y = rd.x * sin( tot_rad ) - rd.y * cos( tot_rad );\n    float dist = manhattan( rd_rot );\n    ret = color * (1.0 - smoothstep( max_d, max_d + border_width, dist ) );\n    \n    return ret;\n}\nvec4\nsquare_tex( vec4 color, vec2 pos, float side, float border_width, float rot_rad, vec2 point, sampler2D tex )\n{\n    vec4 ret = vec4(0);\n    color.rgb *= color.a;\n    \n    float max_d = SQRT2 * side;\n    vec2 rd = point - pos;\n    float tot_rad = QPI + rot_rad;\n    vec2 rd_rot;\n    rd_rot.x = rd.x * cos( tot_rad ) + rd.y * sin( tot_rad );\n    rd_rot.y = rd.x * sin( tot_rad ) - rd.y * cos( tot_rad );\n    float dist = manhattan( rd_rot );\n    ret = color * (1.0 - smoothstep( max_d, max_d + border_width, dist ) );\n    ret *= texture( tex, rd_rot * (0.5 / side ) + 0.5 );\n    \n    return ret;\n}\n\n// NOTE(theGiallo): pre-multiplied alpha\nvoid\nblend_pma( inout vec4 dst, in vec4 src )\n{\n    dst.rgb = src.rgb + dst.rgb * ( 1.0 - src.a );\n    dst.a = min( 1.0, dst.a + src.a );\n}\n\nfloat\nmirror( float x )\n{\n    x *= 0.5;\n    return 1.0 - abs( 2.0 * ( x - floor(x) ) - 1.0 );\n}\n\nfloat\ndecimal( float x )\n{\n    return x - floor(x);\n}\n\n// NOTE(theGiallo): h in [0,1)\nvec4\nrgb_from_hsv( vec4 hsv )\n{\n\tvec4 ret;\n\tret.a = hsv.a;\n\tfloat c = hsv.g * hsv.b;\n\tfloat hh = hsv.r * 6.0;\n\n\tfloat x = c * ( 1.0 - abs( hh - 2.0 * floor( hh / 2.0 ) - 1.0 ) );\n\n\tif ( hh < 1.0 || hh >= 6.0 )\n\t{\n\t\tret.r = c;\n\t\tret.g = x;\n\t\tret.b = 0.0;\n\t} else\n\tif ( hh < 2.0 )\n\t{\n\t\tret.r = x;\n\t\tret.g = c;\n\t\tret.b = 0.0;\n\t} else\n\tif ( hh < 3.0 )\n\t{\n\t\tret.r = 0.0;\n\t\tret.g = c;\n\t\tret.b = x;\n\t} else\n\tif ( hh < 4.0 )\n\t{\n\t\tret.r = 0.0;\n\t\tret.g = x;\n\t\tret.b = c;\n\t} else\n\tif ( hh < 5.0 )\n\t{\n\t\tret.r = x;\n\t\tret.g = 0.0;\n\t\tret.b = c;\n\t} else\n\tif ( hh < 6.0 )\n\t{\n\t\tret.r = c;\n\t\tret.g = 0.0;\n\t\tret.b = x;\n\t}\n\n\tfloat m = hsv.b - c;\n\tret.r += m;\n\tret.g += m;\n\tret.b += m;\n\n\treturn ret;\n}\n\n#define ORANGE_RGB vec3(1.0,0.4,0.0)\n#define T_EPS 0.001\n\nfloat\nmin( in vec3 v )\n{\n    return min( v.x, min( v.y, v.z ) );\n}\n\nfloat\nmax( in vec3 v )\n{\n    return max( v.x, max( v.y, v.z ) );\n}\n\nfloat\nsphere_sd( in float sph_r, in vec3 p )\n{\n    return length( p ) - sph_r;\n}\n\nfloat\naab_sd( in vec3 sides, in vec3 p )\n{\n    sides *= 0.5;\n    p = abs( p );\n    vec3 d = p - sides;\n    return min( max( d ), 0.0 ) + length( max(d,0.0) );\n}\n\nfloat\nplane_sd( in vec3 p )\n{\n    return abs( p.z );\n}\n\nvec3\nat_pos( in vec3 pos, in vec3 p )\n{\n    return p-pos;\n}\n\nmat4\ntr( mat4 m )\n{\n    return mat4(\n       vec4(m[0][0],m[1][0],m[2][0],m[3][0]),\n       vec4(m[0][1],m[1][1],m[2][1],m[3][1]),\n       vec4(m[0][2],m[1][2],m[2][2],m[3][2]),\n       vec4(m[0][3],m[1][3],m[2][3],m[3][3])\n    );\n}\n\nvec3\nrotate( in vec3 r, in vec3 p )\n{\n\tmat4 Rx = mat4(\n\t   vec4( 1.0, 0.0,      0.0,       0.0 ),\n\t   vec4( 0.0, cos(r.x), -sin(r.x), 0.0 ),\n\t   vec4( 0.0, sin(r.x),  cos(r.x), 0.0 ),\n\t   vec4( 0.0, 0.0,      0.0,       0.0 ) );\n\tmat4 Ry = mat4(\n\t   vec4(  cos(r.y), 0.0, sin(r.y), 0.0 ),\n\t   vec4(  0.0,      1.0, 0.0,      0.0 ),\n\t   vec4( -sin(r.y), 0.0, cos(r.y), 0.0 ),\n\t   vec4(  0.0,      0.0, 0.0,      1.0 ) );\n\tmat4 Rz = mat4(\n\t   vec4( cos(r.z), -sin(r.z), 0.0, 0.0 ),\n\t   vec4( sin(r.z),  cos(r.z), 0.0, 0.0 ),\n\t   vec4( 0.0,      0.0,       1.0, 0.0 ),\n\t   vec4( 0.0,      0.0,       0.0, 1.0 ) );\n    #if 0\n\tmat4 m = Rz * Ry * Rx;\n\treturn (vec4(p,1.0)*m).xyz;\n    #else\n\tmat4 m = Rx * Ry * Rz;\n\tvec4 pp = vec4(p,1.0) * m;\n    return pp.xyz;\n    #endif\n}\n\nvec3\nat_angle( in vec3 a, in vec3 p )\n{\n    return rotate( -a, p );\n}\n\nvec4\nunion_op( vec4 v0, vec4 v1 )\n{\n    if ( v0.x < v1.x )\n    {\n        return v0;\n    }\n    return v1;\n}\n\nvec3 sky_color;\nvec4\nmap( in vec3 pos )\n{\n    #if 0\n    float r = 1.1;\n    float h = decimal( ( floor( pos.x / r + 0.5 ) + 50.0 ) / 10.0 );\n    float s = mirror( ( floor( pos.s / r + 0.5 ) + 50.0 ) / 30.0 );\n    vec3 color = rgb_from_hsv( vec4( h, s, 1.0, 1.0 ) ).rgb;\n    pos.x = mirror( pos.x / r ) * r;\n    pos.y = mirror( pos.y / r ) * r;\n    #else\n    vec3 color = ORANGE_RGB;\n    #endif\n\n    float sr = 0.5;\n    float sd = 0.5;\n    vec4 res = vec4(1e38, sky_color);\n    #if 0\n    res = union_op( vec4( sphere_sd( sr, at_pos( sd * vec3(0.0, cos( HPI             ), sin( HPI             ) ), pos ) ), color ),\n                    vec4( sphere_sd( sr, at_pos( sd * vec3(0.0, cos( HPI + TAU / 3.0 ), sin( HPI + TAU / 3.0 ) ), pos ) ), color ) );\n    res = union_op( vec4( sphere_sd( sr, at_pos( sd * vec3(0.0, cos( HPI - TAU / 3.0 ), sin( HPI - TAU / 3.0 ) ), pos ) ), color ), res );\n    #endif\n    \n    res = union_op( vec4( sphere_sd( 0.1, at_pos( vec3(0.0        ), pos ) ), vec3(1.0) ), res );\n    res = union_op( vec4( sphere_sd( 0.1, at_pos( vec3(1.0,0.0,0.0), pos ) ), vec3(1.0,0.0,0.0) ), res );\n    res = union_op( vec4( sphere_sd( 0.1, at_pos( vec3(0.0,1.0,0.0), pos ) ), vec3(0.0,1.0,0.0) ), res );\n    res = union_op( vec4( sphere_sd( 0.1, at_pos( vec3(0.0,0.0,1.0), pos ) ), vec3(0.0,0.0,1.0) ), res );\n    res = union_op( vec4( aab_sd( vec3(1.0), at_angle( vec3(0.0,0.0,pos.z * HPI * sin(iTime)), at_pos(vec3(2.0,0.0,0.5),pos) ) ), color ), res );\n    res = union_op( vec4( aab_sd( vec3(1.0), at_angle( vec3(0.0,0.0,iTime*0.05), at_pos(vec3(2.0,2.0,0.5),pos) ) ), color ), res );\n    res = union_op( vec4( aab_sd( vec3(1.0), at_angle( vec3(0.0,pos.y * HPI,0.0), at_pos(vec3(-2.0,pos.y,0.5),pos) ) ), color ), res );\n    res = union_op( vec4( plane_sd( pos ), vec3(0.7 + 0.3 * mod(floor(pos.x)+floor(pos.y),2.0)) ), res);\n\treturn res;\n}\n\nvec3\ncalc_normal( in vec3 pos, in float t )\n{\n    vec3 eps = vec3( max(0.02,T_EPS*t),0.0,0.0);\n\treturn normalize( vec3(\n           map( pos + eps.xyy ).x - map( pos - eps.xyy ).x,\n           map( pos + eps.yxy ).x - map( pos - eps.yxy ).x,\n           map( pos + eps.yyx ).x - map( pos - eps.yyx ).x ) );\n}\n\nfloat\nimg_scale_given_h_fov( float near, float fov )\n{\n    float hw = iResolution.x / min( iResolution.y, iResolution.x );\n    return tan( fov * 0.5 ) * near / hw;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 qc = 2.0 * q - 1.0;\n\tvec2 p = ( 2.0 * fragCoord.xy - iResolution.xy ) / min( iResolution.y, iResolution.x );\n    vec4 col = rgb_from_hsv(vec4(0.57,0.5,0.7,1.0));\n    sky_color = col.rgb;\n        \n    vec3 sun_light_dir = normalize( vec3( 0.0, 1.0, -1.0 ) );\n    \n    float img_plane_dist = 0.05;\n    float img_scale = img_scale_given_h_fov( img_plane_dist, TAU / 3.0 );\n    float time = iTime * PI * 0.125;\n    float d0 = 4.2;\n    vec3 camera_pos = vec3(cos(time) * d0, sin(time) * d0,0.5);\n    camera_pos = rotate( vec3(0.0,0.0,time), vec3(1.5,0.0,1.0) * 2.0 );\n    vec3 look = normalize( -camera_pos );\n    camera_pos.z += 1.5;\n    vec3 up = vec3(0.0,0.0,1.0);\n    vec3 right = cross( look, up );\n    vec3 img_up = cross( right, look );\n    vec3 dir = look * img_plane_dist + right * p.x * img_scale + img_up * p.y * img_scale;\n    vec3 start = camera_pos + dir;\n    dir = normalize( dir );\n    vec4 distance_color;\n    float t = 0.0, t_max = 1e2;\n    for ( int it=0; it!=120; ++it )\n    {\n        vec3 here = start + dir * t;\n        distance_color = map( here );\n        if ( distance_color.x < ( T_EPS * t ) || t > t_max )\n        {\n        \tbreak;\n        }\n        #if 1\n        // NOTE(theGiallo): this is to sample nicely the twisted cubes\n        t += distance_color.x * 0.7;\n        #else\n        t += distance_color.x;\n        #endif\n    }\n    if ( t > t_max )\n    {\n        t = -1.0;\n    }\n    if ( t > 0.0 )\n    {\n        vec3 point = start + dir * t;\n        vec3 normal = calc_normal( point, t );\n        col.rgb = 0.5 + normal * 0.5;\n        float diffuse = max( 0.0, dot( normal, -sun_light_dir ) );\n        float spec = pow( max( 0.0, dot( reflect( dir, normal ) , -sun_light_dir ) ), 15.0 );\n        float ambient = 0.3;\n        col.rgb = ( diffuse + ambient ) * distance_color.yzw + spec * vec3(0.8,1.0,1.0);\n    } else\n    if ( t == 0.0 )\n    {\n        col.rgb = distance_color.yzw / ( 1.0 - 20.0 * distance_color.x );\n    }\n\n    fragColor = vec4(col.rgb,1);\n}","name":"Image","description":"","type":"image"}]}