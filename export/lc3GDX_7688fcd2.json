{"ver":"0.1","info":{"id":"lc3GDX","date":"1712190516","viewed":41,"name":"[phreax] custom color palettes","username":"phreax","description":"Upgrading the color game with some custom palettes.\nSchemas from:\n\n- https://coolors.co/palettes/trending\n- https://blog.depositphotos.com/neon-color-palettes.html","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["gradient"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Creative Commons Licence Attribution-NonCommercial-ShareAlike \n   phreax 2024\n   \n   Implementing discrete and continous color palattes from some popular color schemes.\n\n   Schemas from: \n\n   - https://coolors.co/palettes/trending\n   - https://blog.depositphotos.com/neon-color-palettes.html\n   \n*/\n\n#define COPY_COLOR(N, colorsK)  for(int i = 0; i < N; i++) { colors[i] = colorsK[i]; }\n#define IS_BAR(i) (uv.y>(i/N))\n\n\n\nconst vec3 colors2[] = vec3[](\n    vec3(27, 231, 255) / 255.0, // Electric blue\n    vec3(110, 235, 131) / 255.0, // Light green\n    vec3(228, 255, 26) / 255.0, // Lemon Lime\n    vec3(255, 184, 0) / 255.0, // Selective yellow\n    vec3(255, 87, 20) / 255.0 // Giants orange\n);\n\nconst vec3 colors1[] = vec3[](\n    vec3(84, 13, 110) / 255.0, // Indigo\n    vec3(238, 66, 102) / 255.0, // Red (Crayola)\n    vec3(255, 210, 63) / 255.0, // Sunglow\n    vec3(59, 206, 172) / 255.0, // Turquoise\n    vec3(14, 173, 105) / 255.0 // Jade\n);\n  \n\nconst vec3 colors3[] = vec3[](\n    vec3(155, 93, 229) / 255.0, // Amethyst\n    vec3(241, 91, 181) / 255.0, // Brilliant rose\n    vec3(254, 228, 64) / 255.0, // Maize\n    vec3(0, 187, 249) / 255.0, // Deep Sky Blue\n    vec3(0, 245, 212) / 255.0 // Aquamarine\n);\n\n\nconst vec3 colors4[] = vec3[](\n    vec3(0.169, 0.761, 0.718),\n    vec3(0.357, 0.518, 0.008),\n    vec3(0.604, 0.851, 0.259),\n    vec3(0.820, 0.235, 0.196),\n    vec3(0.522, 0.075, 0.020)\n);\n\nconst vec3 colors5[] = vec3[](\n    vec3(237, 174, 73) / 255.0, // Hunyadi yellow\n    vec3(209, 73, 91) / 255.0, // Amaranth\n    vec3(0, 121, 140) / 255.0, // Caribbean Current\n    vec3(48, 99, 142) / 255.0, // Lapis Lazuli\n    vec3(0, 61, 91) / 255.0 // Indigo dye\n);\n\n\nconst vec3 colors6[] = vec3[](\n    vec3(0, 204, 255) / 255.0, // Vivid sky blue\n    vec3(0, 255, 204) / 255.0, // Aquamarine\n    vec3(255, 255, 0) / 255.0, // Yellow\n    vec3(255, 0, 204) / 255.0, // Hot magenta\n    vec3(204, 0, 255) / 255.0 // Electric purple\n);\n\n/*const vec3 colors4[] = vec3[](\n    vec3(249, 65, 68) / 255.0, // Imperial red\n    vec3(243, 114, 44) / 255.0, // Orange (Crayola)\n    vec3(248, 150, 30) / 255.0, // Carrot orange\n    vec3(249, 132, 74) / 255.0, // Coral\n    vec3(249, 199, 79) / 255.0, // Saffron\n    vec3(144, 190, 109) / 255.0, // Pistachio\n    vec3(67, 170, 139) / 255.0, // Zomp\n    vec3(77, 144, 142) / 255.0, // Dark cyan\n    vec3(87, 117, 144) / 255.0, // Payne's gray\n    vec3(39, 125, 161) / 255.0 // Cerulean\n);*/\n\n/*const vec3 colors1[] = vec3[](\nvec3(176.,29.,30.) / 255.,\nvec3(241.,104.,38.) / 255.,\nvec3(234.,211.,95.) / 255.,\nvec3(0.,187.,173.) / 255.,\nvec3(0.,107.,228.) / 255.,\nvec3(126.,99.,180.) / 255.);\n*/\n\n/*const vec3 colors1[] = vec3[](\n    vec3(60, 22, 66) / 255.0, // Russian violet\n    vec3(8, 99, 117) / 255.0, // Caribbean Current\n    vec3(29, 211, 176) / 255.0, // Turquoise\n    vec3(175, 252, 65) / 255.0, // Green Yellow\n    vec3(178, 255, 158) / 255.0 // Light green\n);*/\n/*const vec3 colors2[] = vec3[](\n    vec3(112, 214, 255) / 255.0, // Pale azure\n    vec3(255, 112, 166) / 255.0, // Cyclamen\n    vec3(255, 151, 112) / 255.0, // Atomic tangerine\n    vec3(255, 214, 112) / 255.0, // Naples yellow\n    vec3(233, 255, 112) / 255.0  // Mindaro\n);*/\n\n\n\n// Allow up to 10 colors per palette\nvec3 getColorRamp_(vec3 cols[10], int N, float x ) {\n    // Calculate adjusted length to ensure end color is reachable within [0, 1]\n    float len = float(N);\n    \n    // Scale x according to the adjusted length and apply modulo for wrapping\n    float scaledX = mod(x * (len-1.), len);\n    \n    // Calculate indices. Ensure index2 wraps around to the start if necessary\n    int index1 = int(scaledX);\n    int index2 = index1 + 1;\n    if (index2 >= cols.length()) {\n        index2 = 0; // Wrap to the start to close the loop\n    }\n    \n    // Calculate the fraction between the two indices for smooth interpolation\n    float frac = fract(scaledX);\n    \n    // Interpolate between the two selected colors\n    return mix(cols[index1], cols[index2], smoothstep(0.0, .9, frac));\n}\n\nvec3 getColorRamp(int palette, float x) {\n\n    vec3 colors[10];\n    int len;\n    \n    \n    if(palette == 0) {\n        len = colors1.length();\n        COPY_COLOR(len, colors1);       \n    }\n    \n    if(palette == 1) {\n        len = colors2.length();\n        COPY_COLOR(len, colors2);\n    }\n    if(palette == 2) {\n        len = colors3.length();\n        COPY_COLOR(len, colors3);\n        \n    }\n    if(palette == 3) {\n        len = colors4.length();\n        COPY_COLOR(len, colors4);    \n    }\n    \n    if(palette == 4) {\n        len = colors5.length();\n        COPY_COLOR(len, colors5);    \n    }\n    if(palette == 5) {\n        len = colors6.length();\n        COPY_COLOR(len, colors6);    \n    }\n    return getColorRamp_(colors, len, x);\n\n}\n\nvec3 getColorDiscrete_(vec3 cols[10], int N, float x) {\n    // Ensure x wraps at intervals beyond [0, 1] for repeating the pattern\n    float wrappedX = fract(x);\n\n    // Calculate the adjusted index based on x to directly map to the discrete color steps\n    // The added small value before casting to int ensures the last segment is reachable\n    int index = int(wrappedX * (float(N)));\n\n    // Select the color based on the calculated index\n    return cols[index];\n}\n\nvec3 getColorDiscrete(int palette, float x) {\n\n    vec3 colors[10];\n    int len;\n    \n    \n    if(palette == 0) {\n        len = colors1.length();\n        COPY_COLOR(len, colors1);       \n    }\n    \n    if(palette == 1) {\n        len = colors2.length();\n        COPY_COLOR(len, colors2);\n    }\n    if(palette == 2) {\n        len = colors3.length();\n        COPY_COLOR(len, colors3);\n        \n    }\n    if(palette == 3) {\n        len = colors4.length();\n        COPY_COLOR(len, colors4);    \n    }\n    \n    if(palette == 4) {\n        len = colors5.length();\n        COPY_COLOR(len, colors5);    \n    }\n    \n    if(palette == 5) {\n        len = colors6.length();\n        COPY_COLOR(len, colors6);    \n    }\n    return getColorDiscrete_(colors, len, x);\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.y = 1.-uv.y;\n    float N = 6.;\n    vec3 col = vec3(0);\n    vec2 UV = uv;\n    \n    uv.x = fract(uv.x*2.);\n    \n    // compute colors\n  \n    if(UV.x < .5) {\n        if(IS_BAR(0.)) col = getColorDiscrete(0, uv.x);\n        if(IS_BAR(1.)) col = getColorDiscrete(1, uv.x);\n        if(IS_BAR(2.)) col = getColorDiscrete(2, uv.x);\n        if(IS_BAR(3.)) col = getColorDiscrete(3, uv.x);\n        if(IS_BAR(4.)) col = getColorDiscrete(4, uv.x);\n        if(IS_BAR(5.)) col = getColorDiscrete(5, uv.x);\n    } else {\n    \n        if(IS_BAR(0.)) col = getColorRamp(0, uv.x);\n        if(IS_BAR(1.)) col = getColorRamp(1, uv.x);\n        if(IS_BAR(2.)) col = getColorRamp(2, uv.x);\n        if(IS_BAR(3.)) col = getColorRamp(3, uv.x);\n        if(IS_BAR(4.)) col = getColorRamp(4, uv.x);\n        if(IS_BAR(5.)) col = getColorRamp(5, uv.x);\n    }\n    \n    // band\n    float fx = fract(UV.x*2.);\n    float fy = fract(UV.y*N);\n    // borders\n    col *= smoothstep( 0.499, 0.489, abs(fx-0.5) );\n    col *= smoothstep( 0.49, 0.47, abs(fy-0.5) );\n    // shadowing\n    col *= 0.6 + 0.4*sqrt(4.0*fx*(1.0-fx));\n    col *= 0.6 + 0.4*sqrt(4.0*fy*(1.0-fy));\n    // dithering\n    col += (1.0/255.0)*texture( iChannel0, fragCoord.xy/iChannelResolution[0].xy ).xyz;\n\n\tfragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}