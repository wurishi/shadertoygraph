{"ver":"0.1","info":{"id":"XdcBWf","date":"1527906634","viewed":297,"name":"Chaos game","username":"saidwho12","description":"Chaos Game\nClick on the screen!\nChange in Common tab \"#define ruleType 0\" to any value from 0 to 4 inclusive to see different fractal rules.\nOther parameters are also in Common tab.\nPress R to reset particles.","likes":5,"published":1,"flags":48,"usePreview":0,"tags":["2d","fractal","game","chaos","iterative"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (2.*fragCoord - iResolution.xy)/iResolution.y;\n\tfragColor = texture(iChannel0, uv);\n\t//fragColor = vec4( simplex13(vec3(p, 0)) );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define ruleType 4\n//#define timeBased\n\n#define numPoints 5.\n\n// for time based looping if enabled\n#define maxPoints 6.\n\n#define particleCount 100.0\n\n#define duration 5.\n#define pi 3.14159\n#define tau 6.28318\n\n#define K(i) (texelFetch(iChannel3, ivec2(i, 1), 0).x > 0.)\n\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(.1031, .1030, .0973, .1099)\n\n// For smaller input rangers like audio tick or 0-1 UVs use these...\n//#define HASHSCALE1 443.8975\n//#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n//#define HASHSCALE4 vec3(443.897, 441.423, 437.195, 444.129)\n\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    #ifdef timeBased\n    \tfloat n = floor(mod(iTime,(maxPoints-2.)*duration)/duration+3.);\n    #else\n    \tfloat n = numPoints;\n    #endif\n    \n    vec4 p = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    if(fragCoord.y<1. && fragCoord.x < particleCount) {\n        float d1 = hash12(fragCoord*iTime*iTimeDelta);\n        float d2 = hash12(fragCoord*iTime*d1);\n\n        switch(ruleType) {\n        \tcase 0:\n            p.z = mod(floor(d1*n), n)/n; // Sierpenski sequence\n       \t\tbreak;\n            case 1:\n            p.z = mod(floor(d1*(n-1.)+n*p.z+1.), n)/n;\n        \tbreak;\n            case 2:\n            p.z = mod(floor(d1*(n-1.))+floor(n*p.z-1.), n)/n;\n        \tbreak;\n            case 3:\n            p.z = mod(floor(d1*(n-1.))+floor(n*p.z), n)/n;\n        \tcase 4:\n            p.z = mod(floor(max(d1+n*p.z, d1*(n-3.)+n*p.z+2.)), n)/n; // koch star, found this rule by myself :-)\n        \tbreak;\n        }\n        /*\n        float d3 = d1*(n-2.);\n        p.z = mod(floor( d3<1. ? d3+n*p.z : d3+n*p.z+2. ), n)/n;\n        */\n        float a = p.z*tau+radians(90.);\n\n        vec2 v = vec2(cos(a), sin(a));\n        p.xy = mix(p.xy, v, .5)*((1.-iMouse.x/iResolution.x)*2.);\n        //p.xy = mix(p.xy, v, .5)*1.25; // koch star\n        //p.xy = mix(p.xy,v, (iMouse.x/iResolution.x*2.));\n        //p.xy = mix(p.xy,v, .5);\n\n    }\n    fragColor = K(82) ? vec4(0) : p;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define T(x) texelFetch(iChannel0, ivec2(x), 0)\n#define P(x) texelFetch(iChannel1, ivec2(x, 0), 0)\n\n// Smooth HSV to RGB conversion\nvec3 hsv2rgb( in vec3 c ) {\n    vec3 rgb = clamp( abs(mod(c.x*6.+vec3(0.,4.,2.),6.)-3.)-1., 0., 1.);\n\trgb = rgb*rgb*(3.-2.*rgb); // cubic smoothing\n\treturn c.z * mix(vec3(1.), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 R = iResolution.xy,\n    \t U = (2.*fragCoord-R.xy)/R.y;\n    fragColor = vec4(0, 0, 0, 0);\n    for(float i=0.; i<particleCount; i++)\n        fragColor.rgb += 1.-smoothstep(.0,3./R.y, length(U-P(i).xy)-1e-5);\n    fragColor = K(82) ? vec4(0) : clamp(.996*T(fragCoord)+.2*fragColor, 0.,1.);\n}\n/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 R = iResolution.xy,\n    \t p = (2.*fragCoord-R.xy)/R.y;\n    for(float i=0.; i<R.x; i++) {\n        vec4 pt = P(i);\n        fragColor.rgb += hsv2rgb(vec3(iTime+pt.z,.5, 1.-smoothstep(.0,3./R.y, length(p-pt.xy)-1e-5)));\n    }\n    fragColor = K(82) ? vec4(0) : clamp(.97*T(fragCoord)+.3*fragColor, 0.,1.);\n}*/","name":"Buffer A","description":"","type":"buffer"}]}