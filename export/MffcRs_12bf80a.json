{"ver":"0.1","info":{"id":"MffcRs","date":"1721457880","viewed":224,"name":"Travel through a time tunnel","username":"Capo","description":"haha\nï¼šhttps://www.shadertoy.com/view/MsX3RH","likes":23,"published":1,"flags":0,"usePreview":0,"tags":["3dcolor"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#pragma optimize(off)\n#define getNormal getNormalHex\n#define FAR 1e3\n#define INFINITY 1e32\n#define T iTime\n#define mt (iChannelTime[0] > 0. ? iChannelTime[0] : iTime)\n#define FOV 70.0\n#define FOG .06\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (1.618033988749895)\n\nfloat hash12(vec2 p) {\n    float h = dot(p,vec2(127.1,311.7));    \n    return fract(sin(h)*43758.5453123);\n}\n\nfloat hash33(vec3 p) {\n    p = fract(p * 0.3183099 + 0.1);\n    p *= 17.0;\n    return fract(p.x * p.y * p.z * (p.x + p.y + p.z));\n}\n\n// 3d noise\nfloat noise_3(in vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);    \n    vec3 u = 1.-(--f)*f*1.1*f*f*-f;\n    \n    vec2 ii = i.xy + i.z * vec2(5.0);\n    float a = hash12(ii + vec2(0.0,0.0));\n    float b = hash12(ii + vec2(1.0,0.0));    \n    float c = hash12(ii + vec2(0.0,1.0));\n    float d = hash12(ii + vec2(1.0,1.0));\n    float v1 = mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n    \n    ii += vec2(5.0);\n    a = hash12(ii + vec2(0.0,0.0));\n    b = hash12(ii + vec2(1.0,0.0));    \n    c = hash12(ii + vec2(0.0,1.0));\n    d = hash12(ii + vec2(1.0,1.0));\n    float v2 = mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n        \n    return max(mix(v1, v2, u.z), 0.);\n}\n\nfloat noise_3_new(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);    \n    vec3 u = f * f * (3.0 - 2.0 * f);\n    \n    return mix(mix(mix(hash33(i + vec3(0, 0, 0)), hash33(i + vec3(1, 0, 0)), u.x),\n                   mix(hash33(i + vec3(0, 1, 0)), hash33(i + vec3(1, 1, 0)), u.x), u.y),\n               mix(mix(hash33(i + vec3(0, 0, 1)), hash33(i + vec3(1, 0, 1)), u.x),\n                   mix(hash33(i + vec3(0, 1, 1)), hash33(i + vec3(1, 1, 1)), u.x), u.y), u.z);\n}\n\nfloat fbm(vec3 x) {\n    float r = 0.0;\n    float w = 1.0, s = 1.0;\n    for (int i = 0; i < 6; i++) {\n        w *= 0.26;\n        s *= 3.0;\n        vec3 p = x * s;\n        mat3 rotMat = mat3(\n            cos(PI/4.0), -sin(PI/4.0), 0.0,\n            sin(PI/4.0), cos(PI/4.0), 0.0,\n            0.0, 0.0, 1.0\n        );\n        p *= rotMat;\n        r += w * noise_3(p);\n    }\n    return r*1.2;\n}\n\nfloat fbm_new(vec3 x) {\n    float r = 0.0;\n    float w = 1.05, s = 1.;\n    for (int i = 0; i < 5; i++) {\n        w *= 0.26;\n        s *= 3.;\n        r += w * noise_3_new(s * x);\n    }\n    return r;\n}\n\nfloat yC(float x) {\n    return cos(x * -.134) * 1. * cos(x * .13) * 15. + fbm(vec3(x * .1, 0., 0.) * 55.4);\n}\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a) * p + sin(a) * vec2(p.y, -p.x);\n}\n\nstruct geometry {\n    float dist;\n    vec3 hit;\n    int iterations;\n};\n\nfloat fCylinderInf(vec3 p, float r) {\n    return length(p.xz) - r + 1.0;\n}\n\ngeometry map(vec3 p) {\n    p.x -= yC(p.y * .1) * 3.;\n    p.z += yC(p.y * .01) * 4.;\n    \n    float n = pow(abs(fbm(p * .07)) * 12., 1.3);\n    float s = fbm(p * 0.01 + vec3(0., T * 0.14, 0.)) * 128.;\n    \n    geometry obj;\n    obj.dist = max(0., -fCylinderInf(p, s + 18. - n));\n    \n    p.x -= sin(p.y * .02) * 34. + sin(p.z * 0.01) * 62.;\n    obj.dist = max(obj.dist, -fCylinderInf(p, s + 28. + n * 2.));\n    \n    return obj;\n}\n\nfloat t_min = 10.0;\nfloat t_max = FAR;\nconst int MAX_ITERATIONS = 100;\n\ngeometry trace(vec3 o, vec3 d) {\n    float omega = 1.3;\n    float t = t_min;\n    float candidate_error = INFINITY;\n    float candidate_t = t_min;\n    float previousRadius = 0.;\n    float stepLength = 0.;\n    float pixelRadius = 1. / 1000.;\n    \n    geometry mp = map(o);\n    float functionSign = mp.dist < 0. ? -1. : +1.;\n    float minDist = FAR;\n    \n    for (int i = 0; i < MAX_ITERATIONS; ++i) {\n        mp = map(d * t + o);\n        mp.iterations = i;\n    \n        float signedRadius = functionSign * mp.dist;\n        float radius = abs(signedRadius);\n        bool sorFail = omega > 1. && (radius + previousRadius) < stepLength;\n        \n        if (sorFail) {\n            stepLength -= omega * stepLength;\n            omega = 1.;\n        } else {\n            stepLength = signedRadius * omega;\n        }\n        previousRadius = radius;\n        float error = radius / t;\n        \n        if (!sorFail && error < candidate_error) {\n            candidate_t = t;\n            candidate_error = error;\n        }\n        \n        if (!sorFail && error < pixelRadius || t > t_max) break;\n        \n        t += stepLength * .5;\n    }\n    \n    mp.dist = candidate_t;\n    if ((t > t_max || candidate_error > pixelRadius)) mp.dist = INFINITY;\n    \n    return mp;\n}\n\nfloat rotatingSmoke(vec3 p, float time) {\n    float theta = time * 0.2;\n    mat2 rotMat = mat2(cos(theta), -sin(theta), sin(theta), cos(theta));\n    p.xy *= rotMat;\n    return fbm(p * 0.5);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 ouv = fragCoord.xy / iResolution.xy;\n    vec2 uv = ouv - .5;\n    uv *= tan(radians(FOV) / 2.0) * 4.;\n    \n    vec3 vuv = normalize(vec3(cos(T), sin(T * .11), sin(T * .41)));\n    vec3 ro = vec3(0., 30. + iTime * 100., -.1);\n    ro.x += yC(ro.y * .1) * 3.;\n    ro.z -= yC(ro.y * .01) * 4.;\n    \n    vec3 vrp = vec3(0., 50. + iTime * 102., 2.);\n    vrp.x += yC(vrp.y * .1) * 3.;\n    vrp.z -= yC(vrp.y * .01) * 4.;\n    \n    vec3 vpn = normalize(vrp - ro);\n    vec3 u = normalize(cross(vuv, vpn));\n    vec3 v = cross(vpn, u);\n    vec3 vcv = ro + vpn;\n    vec3 scrCoord = vcv + uv.x * u * iResolution.x / iResolution.y + uv.y * v;\n    vec3 rd = normalize(scrCoord - ro);\n    vec3 oro = ro;\n    \n    vec3 sceneColor = vec3(0.);\n    geometry tr = trace(ro, rd);\n    tr.hit = ro + rd * tr.dist;\n    \n    vec3 col = vec3(1., 0.5, .4) * fbm(tr.hit.xzy * .01) * 20.;\n    col.b *= fbm(tr.hit * .01) * 10.;  \n    \n    sceneColor += min(.8, float(tr.iterations) / 90.) * col + col * .03;\n    sceneColor *= 1. + .9 * (abs(fbm(tr.hit * .002 + 3.) * 10.) * (fbm(vec3(0., 0., iTime * .05) * 2.)) * 1.);\n    sceneColor = pow(sceneColor, vec3(1.)) * 0.6;\n    \n    vec3 steamColor1 = vec3(.0, .4, .5);\n    vec3 rro = oro;\n    ro = tr.hit;\n    float distC = tr.dist, f = 0., st = .9;\n    \n    for (float i = 0.; i < 24.; i++) {\n        rro = ro - rd * distC;\n        f += fbm(rro * vec3(.1, .1, .1) * .3) * .1;\n        distC -= 3.;\n        if (distC < 3.) break;\n    }\n \n    sceneColor += steamColor1 * pow(abs(f * 1.5), 3.) * 4.;\n   \n    // smoke\n    vec3 smokeP = ro + rd * (tr.dist * 0.5);\n    float smoke = rotatingSmoke(smokeP, T);\n    vec3 smokeColor = vec3(0.5, 0.5, 0.5) * smoke;\n    sceneColor = mix(sceneColor, smokeColor, 0.5);\n    \n    fragColor = vec4(clamp(sceneColor * (1. - length(uv) / 2.), 0.0, 1.0), 1.0);\n    fragColor = pow(abs(fragColor / tr.dist * 130.), vec4(.8));\n}\n","name":"Image","description":"","type":"image"}]}