{"ver":"0.1","info":{"id":"MctXzr","date":"1713530790","viewed":84,"name":"Synthèse d'Images - Joud Cazeaux","username":"Joucaz","description":"Cours Synthèse d'Images, CY Tech Visual 2023-2024 - Joud Cazeaux","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["3d","shader"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float FLT_MAX = 999999999.0;    \n\n// We can define a structure that will contain the parameters needed\n// by an object to specify its shading according to Phong shading.\nstruct Material\n{\n    float Ka; // ambiant coefficient\n    float Kd; // diffuse coefficient\n    float Ks; // specular coefficient\n    float Kn; // specular power coefficient\n};\n\nstruct ShadeInfo\n{\n    vec3 shadeCol;\n    float Ks;\n};\n\nstruct LightInfo\n{\n    vec3 pos;\n    vec3 col;\n    float power;\n};\n\n// Camera parameters\nvec3 cameraPos = vec3(6.0,4.0,-5.0);\nconst vec3 cameraTarget = vec3(3.0,1.0,-8.0);\nconst float cameraFovY = 80.0; // NOTE: angle in degree\n\n// Sky parameters\nconst vec3 skyCol = vec3(0,0,0);\t\t\t\nconst int skyId = 0;\n\n// Sphere parameters\nvec3 spherePos = cameraTarget + vec3(0.0,1.0,2.0);\nconst float sphereRadius = 1.0;\nconst vec3 sphereCol = vec3(1.0,0.0,0.0);\nconst Material sphereMat = Material(0.2/*Ka*/,0.7/*Kd*/,1.0/*Ks*/,50.0/*Kn*/);\nconst int sphereId = 1;\n\n// Plane parameters\nconst vec3 planePos = vec3(0.0,0.1,0.0);\nconst vec3 planeNormal = vec3(0.0,1.0,0.0);\nconst vec3 planeCol1 = vec3(1.0);\nconst vec3 planeCol2 = vec3(0.4); \nconst Material planeMat = Material(0.2/*Ka*/,1.0/*Kd*/,0.2/*Ks*/,5.0/*Kn*/);\nconst int planeId = 3;\n\n// Lights parameters\nconst vec3 ambiantCol = vec3(0.0,0.0,0.0);\n\nconst vec3 light1Col = vec3(0.890, 0.706, 0.020);\nvec3 light1Pos = vec3(8.0,10.0,-12.0);\nconst float light1Pow = 0.8;\n\nconst vec3 light2Col = vec3(0.878, 0.404, 0.851);\nvec3 light2Pos = vec3(3.0,10.0,1.0);\nconst float light2Pow = 0.5;\n\nconst int NB_LIGHTS = 2;\n\nLightInfo lights[NB_LIGHTS];\n\n// Antialiasing parameters\nconst int PIXEL_SAMPLING_SIZE = 20;\n\n// Raytracer parameter\nconst int MAX_NB_BOUNCES = 5;\n\n// Blur parameter\nconst int TIME_SAMPLING_SIZE = 4;\nconst float TIME_SAMPLING_OFFSET_MAX = 0.017;\n\n// Render parameter\nconst bool ANTIALIASING = true;\nconst bool BLUR = false;\n\n\nvec2 noise2(vec2 location, vec2 delta)\n{\n    const vec2 c = vec2(12.9898,78.233);\n    const float m = 43758.5453;\n    return vec2(fract(sin(dot(location + delta, c)) * m), fract(sin(dot(location + vec2(delta.y, delta.x), c)) * m));\n}\n\nvec2 transform_to_apply(vec2 xy){\n    xy = (2.0 * xy.xy - iResolution.xy) / iResolution.y;\n    return vec2(xy.x, xy.y);\n}\n\nfloat raySphere(vec3 rayPos, vec3 rayDir, vec3 spherePos, float sphereRadius, out vec3 intersecPt, out vec3 normal)\n{\n    vec3 diff = rayPos - spherePos;\n    float a = dot(rayDir, rayDir);\n    float b = 2.0 * dot(diff, rayDir);\n    float c = dot(diff, diff) - sphereRadius * sphereRadius;\n    float di = b * b - 4.0 * a * c;\n    if (di >= 0.0)\n    {\n        float sdi = sqrt(di);\n        float den = 1.0 / (2.0 * a);\n        float t1  = (-b - sdi) * den;\n        float t2  = (-b + sdi) * den;\n        float t = -1.0;\n        float dir = 1.0;\n        if (t1 > 0.0)\n        \tt = t1;\n        else if (t2 > 0.0)\n        {\n            t = t2;\n            dir = -1.0;\n        }\n        else\n            return t;\n        intersecPt = rayPos + t * rayDir;\n        normal     = normalize(intersecPt - spherePos) * dir;\n        return t;\n    }\n    return -1.0;\n}\n\n\n// NOTE: planeNormal must be a unit-vector!\nfloat rayPlane(vec3 rayPos, vec3 rayDir, vec3 planePos, vec3 planeNormal, out vec3 intersecPt, out vec3 normal)\n{\n    float den = dot(planeNormal, rayDir);\n    if (abs(den) <= 0.000001) // To avoid numerical instabilities we consider the ray to be parallel\n        return -1.0; // if the angle between the normal and the ray is ALMOST zero.\n    float t = dot(planeNormal, planePos - rayPos) / den;\n    // As we found the value of t, we can insert it into equation (1) to find the position of the first\n    // intersection point encountered along the ray.\n    intersecPt = rayPos + t * rayDir;\n    normal = -sign(den) * planeNormal;\n    return t;\n}\n\n\nvoid computeCameraRayFromPixel(in vec2 pixCoord, out vec3 rayPos, out vec3 rayDir)\n{\n    float focal = 1.0 / tan(radians(cameraFovY) / 2.0); \n    vec3 cz = normalize(cameraTarget - cameraPos);\n    vec3 up = vec3(0,1,0); // perfect up vector\n    vec3 cx = normalize(cross(-up, cz));\n    // Finally, we can find the true cy by applying: cy = cross-product(cz, cx)\n    vec3 cy = normalize(cross(cz, cx));\n    rayPos = cameraPos;\n    rayDir = normalize(pixCoord.x * cx - pixCoord.y * cy + focal * cz);\n}\n\n\n// The aim of this routine is to find the nearest intersection the ray has with ALL the objects\nfloat computeNearestIntersection(vec3 rayPos, vec3 rayDir, out int objectId, out vec3 intersecI, out vec3 normalI)\n{\n    // Set the default value when no intersection is found: we hit the 'sky'\n    float minDist  = FLT_MAX;\n    objectId = skyId;\n    // Test the sphere\n    vec3 intersecS, normalS;\n    float distS = raySphere(rayPos, rayDir, spherePos, sphereRadius, intersecS, normalS);\n    if ((distS > 0.0) && (distS < minDist))\n    {\n        objectId = sphereId;\n        minDist = distS;\n        intersecI = intersecS;\n        normalI = normalS;\n    }\n    // Test the plane\n    vec3 intersecP, normalP;\n    float distP =  rayPlane(rayPos, rayDir,  planePos,  planeNormal, intersecP, normalP);\n    if ((distP > 0.0) && (distP < minDist))\n    {\n        objectId = planeId;\n        minDist = distP;\n\t    intersecI = intersecP;\n    \tnormalI = normalP;\n    }\n    // To remain coherent with the raySphere & rayPlane function that returns -1 when no\n    // intersetion is found, we add the following two lines:\n    if (objectId == skyId)\n        minDist = -1.0;\n    return minDist;\n}\n\n\nvec3 getSphereColorAtPoint(vec3 pt)\n{\n    return sphereCol;\n}\n\n\n// Pt is assumed to be on the plane surface\nvec3 getPlaneColorAtPoint(vec3 pt)\n{\n    vec3 worldX = vec3(1,0,0);\n    vec3 axisX  = normalize(worldX - dot(worldX, planeNormal) * planeNormal);\n    // We then find the plane Y-axis thanks to the cross-product properties with orthonormal basis\n    vec3 axisY  = normalize(cross(planeNormal, axisX));\n    // Now, find the coordinate of the input point according to this texture coordinate frame\n    vec3 diff = pt - planePos; \n    float u = dot(diff, axisX);\n    float v = dot(diff, axisY);\n    // Finally, apply the checkboard pattern by using this very concise formula:\n    return mod(floor(u * 0.5) + floor(v * 0.5), 2.0) < 1.0  ? planeCol1 : planeCol2;\n}\n\n\nvec3 getObjectColorAtPoint(int objectId, vec3 pt, out Material objectMat)\n{\n    if (objectId == sphereId)\n    {\n        objectMat = sphereMat;\n        return getSphereColorAtPoint(pt);\n    }\n    else if (objectId == planeId)\n    {\n        objectMat = planeMat;\n        return getPlaneColorAtPoint(pt);\n    }\n    return skyCol;\n}\n\n\nfloat getShadowFactorAtPoint(vec3 I, vec3 N, Material objectMat, vec3 L, float Ldist)\n{\n    vec3  shadowRayStart = I + 0.0001 * N;\t// Move the surface point a little outward (along its \n    // normal) to ensure it is a bit above the surface.\n\t// The direction of the ray is just the unit-vector going from the surface point towards the \n    // light source\n    vec3  shadowRayDir = L;\n    int unusedInt;\n    vec3 unusedVec1, unusedVec2;\n    float shadowRes = computeNearestIntersection(shadowRayStart, shadowRayDir, unusedInt, unusedVec1, unusedVec2);\n    float shadowFactor = (shadowRes < 0.0 || shadowRes >= Ldist) ? 1.0 : objectMat.Ka;\n    return shadowFactor;\n}\n\n\nvec3 computePhongShading(vec3 objectCol, Material objectMat, LightInfo light, float shadowFactor, vec3 N, vec3 L, vec3 R, vec3 V)\n{\n    vec3 ambiant = objectMat.Ka * ambiantCol;\n    vec3 diffuse = objectMat.Kd * objectCol * light.col * light.power * max(dot(N, L), 0.0);\n    vec3 specular = objectMat.Ks * light.col * light.power * pow(max(dot(R, V), 0.0), objectMat.Kn);\n    float shadowFactorSpec = shadowFactor < 1.0 ? 0.0 : 1.0;\n    vec3 phongCol = ambiant + (diffuse * shadowFactor) + (specular * shadowFactorSpec);\n    return phongCol;\n}\n\n\nvoid AnimateScene(float time)\n{\n    // Animate the sphere position\n    const float pi = 3.1415926535;\n    const float rs = 2.0;\n    const float spr = 5.0;\n    float as = 2.0 * pi * time / spr;\n\t// NOTE: at time=0, the sphere position is the same than the default one defined at the top of \n    // this source code.\n    spherePos = cameraTarget + rs * vec3(-sin(as), 0.0, cos(as)) + vec3(0.0,1.0,0.0);\n    // Animate the light position\n    // NOTES: - light will move up and down from height of 1 to 20.\n    //        - again we made our formula so that the position is the default one at time = 0.\n    // Loop in the lights list\n    for(int l = 0 ; l < NB_LIGHTS; l++)\n    {\n        lights[l].pos += vec3(0, 10.5 + 9.5 * cos(time) - 10.0, 0);\n    }\n    // Animate the camera\n    // NOTE: again we made our formula so that the position is the default one at time = 0.\n    float targetDist = length(cameraTarget - cameraPos);\n    cameraPos -= vec3(0.0, 0.0, targetDist);\n    cameraPos += targetDist*vec3(sin(time), max(sin(time*0.5),0.0), cos(time));\n}\n\n\nvec3 raycastAtPixelCoord(vec2 pixCoord,LightInfo light)\n{\n    vec3 rayPos, rayDir;\n    computeCameraRayFromPixel(pixCoord, rayPos, rayDir);\n    int objectId;\n    vec3 intersecI, normalI;\n    float distI = computeNearestIntersection(rayPos, rayDir, objectId, intersecI, normalI);\n    if(distI <= 0.0)\n        return skyCol;\n    vec3 L = light.pos - intersecI;\n    float Ldist = length(L);\n    L = L / Ldist;\n    vec3 R = 2.0 * dot(normalI, L) * normalI - L;\n    vec3 V = -rayDir;\n    Material objectMat;\n    vec3 objectCol = getObjectColorAtPoint(objectId, intersecI, objectMat);\n    float shadowFactor = getShadowFactorAtPoint(intersecI, normalI, objectMat, L, Ldist);\n    vec3 resCol = computePhongShading(objectCol, objectMat, light ,shadowFactor, normalI, L, R, V);\n    return resCol;\n}\n\n\n\nvec3 RaytraceAtPixelCoord(vec2 pixCoord)\n{\n    vec3 rayPos, rayDir;\n    computeCameraRayFromPixel(pixCoord, rayPos, rayDir);\n    \n    ShadeInfo infos[MAX_NB_BOUNCES];\n    int nbBounces = 0;\n    do\n    {\n        int objectId, objectId2;\n        vec3 intersecI, normalI, intersecI2, normalI2;\n        float distI = computeNearestIntersection(rayPos, rayDir, objectId, intersecI, normalI);\n        if(distI <= 0.0)\n        {\n            infos[nbBounces].shadeCol = skyCol;\n            infos[nbBounces].Ks = 0.0;\n            break;\n        }\n        vec3 resCol;\n        Material objectMat;\n        vec3 V = -rayDir;\n        for(int l = 0 ; l < NB_LIGHTS; l++)\n        {\n            vec3 L = lights[l].pos - intersecI;\n            float Ldist = length(L);\n            L = L / Ldist;\n            vec3 R = 2.0 * dot(normalI, L) * normalI - L;\n            vec3 objectCol = getObjectColorAtPoint(objectId, intersecI, objectMat);\n            float shadowFactor = getShadowFactorAtPoint(intersecI, normalI, objectMat, L, Ldist);\n            resCol += computePhongShading(objectCol, objectMat, lights[l] ,shadowFactor, normalI, L, R, V);\n        }\n        infos[nbBounces].shadeCol = resCol;\n        infos[nbBounces].Ks = objectMat.Ks;\n        rayPos = intersecI + 0.001 * normalI;\n        rayDir = normalize(2.0 * dot(normalI, V) * normalI - V);\n        nbBounces++;\n    } while(nbBounces < MAX_NB_BOUNCES);\n    \n    vec3 resCol = vec3(0.0);\n   \tdo\n    {\n        resCol = infos[nbBounces].shadeCol + infos[nbBounces].Ks * resCol;\n        nbBounces--;\n    } while(nbBounces >= 0);\n    return resCol;\n}\n\nvec3 Render(vec3 resCol,vec2 fragCoord)\n{\n    if(ANTIALIASING == true){\n        if(BLUR == true){\n            for (int k = 0; k < TIME_SAMPLING_SIZE; k++) {\n                // Animate scene with offset for motion blur\n                AnimateScene(TIME_SAMPLING_OFFSET_MAX);\n\n                // Stochastic Antialiasing\n                for (int i = 0; i<PIXEL_SAMPLING_SIZE; i++)\n                {\n                    vec2 val = noise2(fragCoord, vec2(float(i), float(i)));\n                    vec2 off = vec2(val.x/640.0, val.y/360.0);\n                    resCol += RaytraceAtPixelCoord(fragCoord + off);\n                }\n            }\n            resCol /= float(PIXEL_SAMPLING_SIZE * TIME_SAMPLING_SIZE);\n        }\n        else\n        {\n            for (int i = 0; i<PIXEL_SAMPLING_SIZE; i++)\n            {\n                vec2 val = noise2(fragCoord, vec2(float(i), float(i)));\n                vec2 off = vec2(val.x/640.0, val.y/360.0);\n                resCol += RaytraceAtPixelCoord(fragCoord + off);\n            }\n            resCol /= float(PIXEL_SAMPLING_SIZE);\n        }\n    }\n    else\n    {\n        if(BLUR == true)\n        {\n            for (int k = 0; k < TIME_SAMPLING_SIZE; k++)\n            {\n                AnimateScene(TIME_SAMPLING_OFFSET_MAX);\n                resCol += RaytraceAtPixelCoord(fragCoord);\n            }\n            resCol /= float(TIME_SAMPLING_SIZE);\n        }\n        else\n        {\n            resCol += RaytraceAtPixelCoord(fragCoord);\n        }\n    }\n    return resCol;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //add lights values in the list\n    lights[0].pos = light1Pos;\n    lights[0].col = light1Col;\n    lights[0].power = light1Pow;\n    lights[1].pos = light2Pos;\n    lights[1].col = light2Col;\n    lights[1].power = light2Pow;\n\n    // Set the time used for the animation\n    float time = iTime;\n    AnimateScene(time * 1.0);\n    fragCoord = transform_to_apply(fragCoord.xy);\n    vec3 resCol = vec3(0);\n    resCol = Render(resCol,fragCoord);\n    fragColor = vec4(resCol,1);\n}\n\n\n","name":"Image","description":"","type":"image"}]}