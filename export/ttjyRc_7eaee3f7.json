{"ver":"0.1","info":{"id":"ttjyRc","date":"1594997047","viewed":886,"name":"2D Fur and hair textures","username":"pronce","description":"A few experiments with my 2d fur and hair implementation. Different growth and shading options and even a multi-layer approach (rainbow colors) simple but fun! Best viewed in fullscreen","likes":43,"published":1,"flags":0,"usePreview":1,"tags":["2d","texture","hair","fur","growth"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n\they! i've implemented a few different 2D hair textures generated\n\tcompletely in real-time in the shader.\n\n\tfree to use, please give credit and link back to this page. thanks!\n\n\thow it works:\n\t1. generate some fbm noise and stretch it in one direction (hair)\n\t2. rotate the stretch direction. since it's texture we cannot rotate\n\t   around a fixed pivot point. that's why we ...\n\t3. generate patches that are rotated\n\t4. each patch gets a soft border \n\t5. patches are merged in the final render process\n\t6. specular effect is generated by interpreting the\n\t   luminance of the stretched hair texture\n\t7. coloring and mixing is done in the final evaluation\n\t8. tada, hair! :)\n\n*/\n\n\n// pseudorandom canonical function from 'On generating random numbers, \n// with help of y= [(a+x)sin(bx)] mod 1\", W.J.J. Rey, 22nd European\n// Meeting of Statisticians and the 7th Vilnius Conference on Probability\n// Theory and Mathematical Statistics, August 1998'\n#define R(x) fract(sin(dot(x,vec2(12.9898, 78.233))) * 43758.5453)\n\n// global parameters\nfloat HAIR_LENGTH = 20.0;\nfloat TOUSLE = 0.15;\nfloat BORDER = 1.5;\n\n#define PI 3.14159265\n\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (vec2 st)\n{\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = R(i);\n    float b = R((i + vec2(1.0, 0.0)));\n    float c = R((i + vec2(0.0, 1.0)));\n    float d = R((i + vec2(1.0, 1.0)));\n\n    // Smooth Interpolation\n    vec2 u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return (mix(a, b, u.x) +\n            (c - a) * u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y) * 2.0 - 1.0;\n}\n\n//https://thebookofshaders.com/13/\nfloat fbm(vec2 x)\n{\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100);\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n\tfor (int i = 0; i < 5; ++i) {\n\t\tv += a * noise(x);\n\t\tx = rot * x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n// generate a hair patch, which is essentially just some fbm noise \n// stretched along one axis based on the rotation value a.\n// to mimic tousling of the hair a random offset is added to the \n// rotation. the hair length is derived from the actual stretch\nfloat hairpatch(vec2 u, vec2 o, float a)\n{\n    a += sin(R(o) * 5.0) * TOUSLE;\n    vec2 d = vec2(1.0 / HAIR_LENGTH, .5);\n\tfloat s = sin(a); float c = cos(a);\n    mat2 m = mat2(c, -s, s, c);\n    u=m*u;\n  \n    float h = (fbm((u + o) * d * 70.0) + 1.0) / 2.0;\n     \n    h = smoothstep(0.0, 2.2, h);\n\n    return max(0.0, 1.0 - min(1.0, 1.0 - h));\n}\n\n// as the hair is organized in patches, each patch has some\n// smooth falloff since patches are blended together dynamically\nfloat hair(vec2 u, vec2 d, float w, float a)\n{\n    float hr = 0.0;\n    u *= w * 4.0;\n    u += d;\n    vec2 hp = fract(u) - vec2(0.5);\n   \tfloat h = hairpatch(hp, floor(u), a);\n    return pow(h * max(1.-length(hp) * BORDER, 0.0),1.0 / 3.0);\n}\n\n// mix 9 hair patches together in order to simulate an overlapping effect\nfloat hairtexture(vec2 uv, float scale, float angle)\n{\n    vec2 offsets[9] = vec2[9](vec2(0.), vec2(.5), vec2(-.5),\n                              vec2(.5,0.), vec2(-.5,0.),\n                              vec2(0.,.5), vec2(0.,-.5),\n                              vec2(.5,-.5), vec2(-.5,.5));\n\n    float f = 0.0;\n\n    for(int i = 0; i < 9; i++)\n    {\n        f = max(f, hair(uv, offsets[i], scale, angle));\n    } \n    \n    return smoothstep(0.0, 1.0, f);\n}\n\n\nvec3 hyena(vec2 uv)\n{\n    HAIR_LENGTH = 20.0;\n\tTOUSLE = 0.15;\n\tBORDER = 1.5;\n    \n    float angle = (fbm(uv) + 2.0) * PI;\n    float f = hairtexture(uv, 1.0f, angle);\n    \n    // apply color look and use fbm to create darker patches\n    vec3 col = mix(vec3(0.4, 0.3, 0.25) * f * mix(2.0, 4.0, fbm(uv * 8.0)), vec3(1.0), pow(f, 4.0));\n    \n    return col;\n}\n\nvec3 leopard(vec2 uv)\n{\n    HAIR_LENGTH = 15.0;\n\tTOUSLE = 0.15;\n\tBORDER = 1.5;\n    \n    float angle = (fbm(uv)-2.0) * PI * 0.25;\n    float f = hairtexture(uv, 1.0f, angle);\n    \n    //generate a map that mixes between the black and yellow patches\n    float patches = min(1.0, sin(fbm(uv * 2.0) * 3.0 * PI));\n    \n    // apply both colors to the patches\n    vec3 col = mix(max(vec3(0.0), vec3(0.55, 0.37, 0.05) * f * mix(1.0, 4.0, patches)), \n                   vec3(1.0), \n                   pow(f, 4.0));\n    \n    return col;\n}\n\nvec3 woman(vec2 uv)\n{\n    HAIR_LENGTH = 2000.0;\n\tTOUSLE = 0.1;\n\tBORDER = 1.25;\n    \n    float angle = (fbm(uv * 0.25)) * PI;\n    float f = hairtexture(uv * 0.5, 1.0, angle);\n    \n    // just mix in some blond strains\n    vec3 col = mix(vec3(0.8, 0.5, 0.0) * f * mix(2.0, 1.0, fbm(uv)), vec3(1.05, 0.92, 0.9), pow(f, 4.0) * 2.0);\n    \n    return col;\n}\n\nvec3 rainbow(vec2 uv)\n{\n    HAIR_LENGTH = 15.0 + 5.0 * fbm(uv * 2.0);\n\tTOUSLE = 0.2;\n\tBORDER = 1.5;\n    \n    vec3 rainbowColors[7] = vec3[](vec3(148.0/255.0, 0.0, 211.0/255.0), \n                             vec3(75.0/255.0, 0.0, 130.0/255.0), \n                             vec3(0.0, 0.0, 1.0), \n                             vec3(0.0, 1.0, 0.0), \n\t\t\t\t\t\t\t vec3(1.0, 1.0, 0.0), \n\t\t\t\t\t\t\t vec3(1.0, 0.5, 0.0), \n\t\t\t\t\t\t\t vec3(1.0, 0.0, 0.0));\n    vec3 col = vec3(0.0);\n    \n    // overlap different colors to form the rainbow fur\n    for(int i = 0; i < 7; i++)\n    {\n        float angle = sin(uv.x * PI) * PI / 1.5 - float(i);\n        TOUSLE = 0.2 + float(i)/30.0;\n    \tfloat f = hairtexture(uv, 1.0, angle);\n       \n    \tf = smoothstep(0.0, 1.0, f);\n        \n        // generate a mask that maps for each color with some overlapping\n    \tfloat layerMask = max(0.0, pow(sin(clamp(uv.x * PI + (float(i) / 7.0) * PI - PI / 2.61, 0.0, PI)), 2.0) * 4.0);\n    \tlayerMask = clamp(pow(f * layerMask, 3.0) * 3.0, 0.0, 1.0);\n        \n        // mix in the hairs and use the hair luminance to control the blending between different colors\n        vec3 patchColor = mix(rainbowColors[i] * f * 2.0f * (0.5 + (1.0-uv.x) * 0.5), vec3(1.5), pow(f, 3.0));\n    \n        // blend things together\n    \tcol = mix(col, patchColor, layerMask);\n    }\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = vec3(1.0);\n\t\n    if(uv.x < .499 && uv.y < .498)\n    \tcol = rainbow(uv * 2.0);\n    else if(uv.x > .501 && uv.y < .498)\n    \tcol = woman(uv * 2.0);\n   \telse if(uv.x < .499 && uv.y > .502)\n    \tcol = leopard(uv * 2.0);\n    else if(uv.x > .501 && uv.y > .502)\n    \tcol = hyena(uv * 2.0);\n   \n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}