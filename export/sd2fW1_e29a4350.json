{"ver":"0.1","info":{"id":"sd2fW1","date":"1646172138","viewed":167,"name":"Fresh Lime","username":"Flopine","description":"I made this shader months ago as an idea for an album cover that wasn't chosen. But I like it! So here it is :)","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","voronoi","modeling","green"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan, slerpy, wwrighter \n// BigWings, FabriceNeyret and Blackle for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  \n// https://twitter.com/CookieDemoparty\n\n\n#define time iTime\n#define PI acos(-1.)\n#define TAU (2.*PI)\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define hash22(x) fract(sin(vec2(dot(x,vec2(34.1,27.14)),dot(x,vec2(17.4,32.4))))*147.4)\n#define AAstep(thre, val) smoothstep(-.7,.7,(val-thre)/min(0.07,fwidth(val-thre)))\n\nvec3 voronoise (vec2 uv, bool anim)\n{\n    vec2 uvid = floor(uv),\n        uvrep = fract(uv),\n        m_point;\n    float m_dist = 10.;\n\n    for (int j = -1; j<=1; j++)\n    {\n        for (int i = -1; i<=1; i++)\n        {\n            vec2 neighbor = vec2(float(i), float(j));\n            vec2 point = hash22(uvid + neighbor);\n            if(anim) point = 0.5+0.5*sin(2.*PI*point+time);\n            vec2 diff = neighbor + point - uvrep;\n\n            float dist = length(diff);\n            if (dist < m_dist)\n            {\n                m_dist = dist;\n                m_point = uvid + neighbor;\n            }\n        }\n    }\n    return vec3(m_point,m_dist);\n}\n\n\nfloat lines (vec2 uv)\n{\n    float a = mod(atan(uv.y,uv.x),TAU/10.)-(TAU/10.)*.5;\n    vec2 uu = vec2(cos(a),sin(a))*length(uv);\n    return smoothstep(0.04,0.001,abs(uu.y)-sin(uu.x*15.)*.015+.003);\n}\n\nstruct obj\n{\n    float d;\n    int mat;\n};\n\nobj minobj (obj a, obj b)\n{if(a.d<b.d) return a; else return b;}\n\nfloat quarter (vec3 p)\n{\n    float pz = p.z-(p.y*p.y)*0.15;\n    float q = max(abs(p.x)+pz*0.5,length(vec3(p.x,p.y,pz))-1.2);   \n    return q;\n}\n\nfloat ring (vec3 p)\n{\n    float r = quarter(p);\n    r = max(-length(p)+1.1,r);\n    return r;\n}\n\nobj ringout (vec3 p)\n{return obj(ring(p)+voronoise(vec2(atan(p.z,p.y),p.x)*8.,false).z*0.016, 1);}\n\nobj ringin (vec3 p)\n{\n    p *= 1.03;\n    return obj(ring(p)/1.03, 2);\n}\n\nobj quart (vec3 p)\n{\n    p *= 1.065;\n    return obj((quarter(p)-lines(abs(p.yz))*0.02)/1.065,3);\n}\n\nvec3 pp;\nobj SDF (vec3 p)\n{\n    p.xz *= rot(-PI/2.);\n    p.yz *= rot(-PI/3.);\n   \n    obj lime = minobj(ringout(p), ringin(p)); \n    lime = minobj(lime,quart(p));\n    pp = p;\n    return lime;\n}\n\nvec3 get_normals (vec3 p)\n{\n    vec2 eps = vec2(0.01,0.);\n    return normalize(SDF(p).d-vec3(SDF(p-eps.xyy).d, SDF(p-eps.yxy).d, SDF(p-eps.yyx).d));\n}\n\nfloat AO (float eps, vec3 p, vec3 n)\n{return SDF(p+eps*n).d/eps;}\n\nvec3 background (vec2 uv)\n{\n    float mask = AAstep(0.11, fract(abs(abs(uv.x-uv.y)-0.2)-0.1));\n    return (mask < 0.99) ? vec3(0.1,0.9,0.4) : vec3(0.9);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    vec3 ro = vec3(-0.1,-0.3,-1.5), rd=normalize(vec3(uv,1.)),p=ro, \n    col= background(uv), lp=vec3(0.,1.,-3.);\n    bool hit = false; float shad,t=0.;obj O;  \n    \n    for (float i=0.; i<100.; i++)\n    {\n        p = ro+rd*t;\n        O = SDF(p);\n        \n        if (O.d<0.001)\n        {\n            hit=true;shad=i/100.;break;\n        }\n        t += O.d*.8; \n    }\n\n    if (hit)\n    {\n        vec3 n = get_normals(p);\n        if (O.mat == 1) col = vec3(0.,.6,.0);\n        if (O.mat == 2) col = vec3(.95);       \n        vec2 limeuv = pp.yz;\n        vec3 voro = voronoise(limeuv*2.5,true);\n        if (O.mat == 3) col = pow(clamp(vec3(0., 0.99, voro.z*0.2+voro.x*0.05),0.,1.),vec3(0.7))\n        +vec3(0.95,0.97,0.6)*lines(limeuv); \n        \n        n *= vec3(1.-voro.z*0.8);\n        float ao = AO(0.1,p,n)+AO(0.4,p,n)+AO(0.7,p,n);\n        \n        float spec = pow(max(dot(normalize(lp-rd),n),0.),1.);\n        col += spec*vec3(0.5,0.99,0.8)*0.2;\n        col *= ao/3.;\n    }\n    \n    // Output to screen\n    fragColor = vec4(sqrt(clamp(col,0.,1.)),1.0);\n}","name":"Image","description":"","type":"image"}]}