{"ver":"0.1","info":{"id":"tlX3z7","date":"1555896779","viewed":532,"name":"ring visualizer","username":"fenwick67","description":"ring-style visualizers are super popular on Youtube, this is a slightly more interesting version of that.\n\n(you may have to click buffer A and then on iChannel0 and pick some audio)","likes":2,"published":3,"flags":32,"usePreview":0,"tags":["2d","ring","visualizer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord / iResolution.xy;   \n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGRr","filepath":"/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3","previewfilepath":"/media/ap/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define SPD 0.008\n#define FEEDBACK 0.0\n\n\n// convert sample data into map for vis\n// low frequencies => bigger chonks\nfloat transferFunction(float x){\n    return x*x;\n}\n\nvec4 transferFunction (vec4 x){\n    return vec4(transferFunction(x.r),transferFunction(x.g),transferFunction(x.b),transferFunction(x.a));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixelSize = 1. / iResolution.xy;\n    vec2 uv = fragCoord.xy * pixelSize;\n    \n    float speed = SPD;\n    \n    vec2 sampleCoords = vec2(uv.x,transferFunction(uv.y));\n    \n    if(uv.x > 1.0 - speed){\n        float magnitude = texture(iChannel0, sampleCoords.yx * vec2(1.,-1.) + vec2(0.,1.)).r;\n    \tfragColor = \n            (1.0 - FEEDBACK) * magnitude+\n            FEEDBACK * texture(iChannel1, sampleCoords);\n    }else{\n        fragColor = texture(iChannel1, uv + vec2(speed, 0.0));\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define PI 3.14159f\n#define ROTSPD 0.02\n#define SYMMETRICAL 1\n\n// square pulse that is width wide centered on 0\nfloat stamp(float x, float width){\n    float d = abs(x);\n    return step(d, width/2.0);\n}\n\n// given an inner radius and a width return if on a ring or not\nfloat ring(vec2 center, vec2 pos, float r, float width){\n    float dist = length(center - pos);    \n    return stamp(dist-r,width);\n}\n\n// freq is 0...1, delay is 0...1\nfloat sampleAudio(float freq, float delay){\n    #ifdef SYMMETRICAL\n    return 0.5 * (\n        texture(iChannel0, vec2(max(0.0f,0.999f - delay), freq) ).r\n         + texture(iChannel0, vec2(max(0.0f,0.999f - delay), 1.0 - freq) ).r\n    );\n    #else\n    return texture(iChannel0, vec2(max(0.0f,0.999f - delay), freq) ).r;\n    #endif\n}\n\nvec3 colorScale(float x){\n   \n   return vec3(\n      smoothstep(-0.5f,0.5f,x),\n      smoothstep(0.333f,0.666f,x),\n      smoothstep(0.0f,0.8,x)\n   );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord / iResolution.xy;\n    // UV coordinates but where a square would max out in the viewport    \n    vec2 uvsq = vec2(uv.x* iResolution.x/iResolution.y - 0.5*(iResolution.x/iResolution.y - 1.0),uv.y);\n    \n    float theta01 =  atan(uvsq.y - 0.5f,uvsq.x - 0.5f) / (PI*2.0f) + 0.5f;\n    theta01 += iTime*ROTSPD;\n    theta01 = mod(theta01, 1.0f);\n    \n    vec4 ringContrib = vec4(0.0f,0.0f,0.0f,0.0f);\n    \n    float deviation = sampleAudio(theta01,0.0f)*0.8f + sampleAudio(1.0f - theta01,0.0f)*0.2f;    \n    \n    float onCircle = ring(vec2(0.5f,0.5f), uvsq, 0.1f+deviation*0.35f, 0.02f*(1.0f + deviation));\n\tringContrib += vec4(colorScale(deviation)*onCircle,onCircle);   \n\n    float scrollSpeed = 0.9999f - (sampleAudio(0.0f,0.0f)*0.015 + sampleAudio(0.1f,0.0f)*0.015);\n    float feedbackAmount = 0.95f + sampleAudio(0.0f,0.0f)*0.05;\n    \n    fragColor = ringContrib * ringContrib.a \n        + feedbackAmount *(1.0f - ringContrib.a) * texture(iChannel1,(uv-vec2(0.5,0.5))*scrollSpeed+vec2(0.5,0.5));\n    \n}","name":"Buffer B","description":"","type":"buffer"}]}