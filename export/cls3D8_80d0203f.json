{"ver":"0.1","info":{"id":"cls3D8","date":"1671691866","viewed":108,"name":"3d arrow","username":"andrerm2k","description":"3d arrow with raymarch and rotation tricks","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarch","arrown"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// inspired on on https://www.shadertoy.com/view/NttcW8\n\nfloat arrow(vec3 position, vec3 start, vec3 end, float baseRadius, float tipRadius, float tipHeight)\n{\n    vec3 t = start - end;\n    float l = length(t);\n    t /= l;\n    l = max(l, tipHeight);\n\n    position -= end;\n    if (t.y + 1.0 < 0.0001)\n    {\n        position.y = -position.y;\n    }\n    else\n    {\n        float k = 1.0 / (1.0 + t.y);\n        vec3 column1 = vec3(t.z * t.z * k + t.y, t.x, t.z * -t.x * k);\n        vec3 column2 = vec3(-t.x, t.y, -t.z);\n        vec3 column3 = vec3(-t.x * t.z * k, t.z, t.x * t.x * k + t.y);\n        position = mat3(column1, column2, column3) * position;\n    }\n\n    vec2 q = vec2(length(position.xz), position.y);\n    q.x = abs(q.x);\n\n    // tip\n    vec2 e = vec2(tipRadius, tipHeight);\n    float h = clamp(dot(q, e) / dot(e, e), 0.0, 1.0);\n    vec2 d1 = q - e * h;\n    vec2 d2 = q - vec2(tipRadius, tipHeight);\n    d2.x -= clamp(d2.x, baseRadius - tipRadius, 0.0);\n\n    // base\n    vec2 d3 = q - vec2(baseRadius, tipHeight);\n    d3.y -= clamp(d3.y, 0.0, l - tipHeight);\n    vec2 d4 = vec2(q.y - l, max(q.x - baseRadius, 0.0));\n\n    float s = max(max(max(d1.x, -d1.y), d4.x), min(d2.y, d3.x));\n    return sqrt(min(min(min(dot(d1, d1), dot(d2, d2)), dot(d3, d3)), dot(d4, d4))) * sign(s);\n}\n\nmat3 lookAtMatrix(vec3 from, vec3 to)\n{\n    vec3 forward = normalize(to - from);\n    vec3 right = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up = cross(right, forward);\n    return mat3(right, up, forward);\n}\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    return mat4(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s, 0.0,\n                oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s, 0.0,\n                oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c, 0.0,\n                0.0, 0.0, 0.0, 1.0);\n}\n\nvec3 rotate(vec3 v, vec3 axis, float angle)\n{\n    mat4 m = rotationMatrix(axis, angle);\n    return (m * vec4(v, 1.0)).xyz;\n}\n\nfloat sdf(in vec3 position)\n{\n    //vec3 dir = normalize(vec3(1.0, 0.0, 0.0));\n    vec3 dir = normalize(vec3(1.0 * cos(iTime), 1.0 * sin(iTime), 0.0));\n    \n    float angle = atan(dir.y, dir.x);\n    position = rotate(position, vec3(0.0, 0.0, -1.0), angle);\n    float angleZ = -asin(dir.z);\n    position = rotate(position, vec3(0.0, 1.0, 0.0), angleZ);\n\n    float baseRadius = 0.1;\n    float tipRadius = 0.3;\n    float tipHeight = 0.6;\n    float cornerRadius = 0.05;\n    vec3 start = vec3(-1.0, 0.0, 0.0);\n    vec3 end = vec3(1.0, 0.0, 0.0);\n    float d = arrow(position, start, end, baseRadius, tipRadius, tipHeight);\n    d -= cornerRadius;\n    return d;\n}\n\nvec3 normal(vec3 position)\n{\n    float epsilon = 0.001;\n    vec3 gradient = vec3(\n        sdf(position + vec3(epsilon, 0, 0)) - sdf(position + vec3(-epsilon, 0, 0)),\n        sdf(position + vec3(0, epsilon, 0)) - sdf(position + vec3(0, -epsilon, 0)),\n        sdf(position + vec3(0, 0, epsilon)) - sdf(position + vec3(0, 0, -epsilon)));\n    return normalize(gradient);\n}\n\nfloat raycast(vec3 rayOrigin, vec3 rayDirection)\n{\n    int stepCount = 128 * 3;\n    float maximumDistance = 10.0;\n    float t = 0.0;\n    for (int i = 0; i < stepCount; i++)\n    {\n        if (t > maximumDistance)\n        {\n            break;\n        }\n        vec3 currentPosition = rayOrigin + rayDirection * t;\n        float d = sdf(currentPosition);\n        if (d < 0.0001)\n        {\n            return t;\n        }\n        t += d;\n    }\n    return 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 targetPosition = vec3(0.0);\n    vec3 rayOrigin = vec3(0.0, 0.0, 4.0);\n    float timeDelta = 0.25;\n    vec3 cameraPosition = vec3(sin(timeDelta * iTime), 0.0, cos(timeDelta * iTime));\n    \n    mat3 eyeTransform = lookAtMatrix(cameraPosition, targetPosition);\n    rayOrigin = eyeTransform * rayOrigin;\n    \n    mat3 cameraTransform = lookAtMatrix(rayOrigin, targetPosition);\n    vec3 result = vec3(0.0);\n    const float quality = 3.0;\n    ivec2 sampleCount = ivec2(quality, quality);\n    for (int y = 0; y < sampleCount.y; y++)\n    {\n        for (int x = 0; x < sampleCount.x; x++)\n        {\n            vec2 uv = fragCoord + (vec2(float(x), float(y)) / vec2(sampleCount) - 0.5);\n            \n            uv = uv / iResolution.xy;\n            uv = (uv * 2.0) - 1.0;\n            uv.x *= iResolution.x / iResolution.y;\n            \n            vec3 rayDirection = normalize(vec3(uv, 1.5));\n            rayDirection = cameraTransform * rayDirection;\n            float t = raycast(rayOrigin, rayDirection);\n            vec3 color = vec3(0.0);\n            if (t > 0.0)\n            {\n                vec3 position = rayOrigin + rayDirection * t;\n                vec3 n = normal(position);\n                vec3 lightPosition = 1.0 * normalize(vec3(1.0, 1.0, 1.0));\n                \n                // diffuse\n                vec3 diffuseColor = 1.0 * normalize(vec3(1.0, 0.0, 0.0));\n                float diffuseAngle = max(dot(n, lightPosition), 0.0);\n                color = diffuseColor * diffuseAngle; // arrow\n                \n                // ambient\n                vec3 ambientColor = 0.1 * normalize(vec3(1, 1, 2));\n                color += ambientColor * ((n.y + 1.0) * 0.5);\n                \n                // specular\n                float specularStrength = 30.0;\n                vec3 specularColor = ambientColor;//normalize(vec3(1.0, 1.0, 1.0));\n                vec3 reflectDir = reflect(lightPosition, n);\n                float spec = pow(max(dot(rayDirection, reflectDir), 0.0), 32.0);\n                vec3 specular = specularStrength * spec * specularColor;\n                color += specular;\n            }\n            // gamma\n            color = sqrt(color);\n            result += color;\n        }\n    }\n    result /= float(sampleCount.x * sampleCount.y);\n    fragColor = vec4(result, 1.0);\n}","name":"Image","description":"","type":"image"}]}