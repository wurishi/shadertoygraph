{"ver":"0.1","info":{"id":"WdK3Wz","date":"1570019967","viewed":204,"name":"Noise cube","username":"Anskiere","description":"drag to change isosurface offset","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define fr float(iFrame)\n\nconst float maxDist = 200.;\nconst float planeDist = 2.;\n\nfloat rand31(vec3 co)\n{\n\treturn fract(sin(dot(co,vec3(65.9898,\n\t \t78.233, 29.3471))) * 1537.5497);\n}\n\nfloat n(vec3 uv)\n{\n\tvec3 i = floor(uv);\n\tvec3 luv = fract(uv);\n\tluv.xyz = smoothstep(0., 1., luv.xyz);\n\tvec3 d = vec3(1,-1,0);\n\tvec3 p[8];\n\tfloat r[8];\n\n\tp[0] = i;\n\tp[1] = i + d.zzx;\n\tp[2] = i + d.zxz;\n\tp[3] = i + d.zxx;\n\tp[4] = i + d.xzz;\n\tp[5] = i + d.xzx;\n\tp[6] = i + d.xxz;\n\tp[7] = i + d.xxx;\n\n\tfor(int k = 0; k < 8; k++)\n\t\tr[k] = rand31(p[k]);\n\n\tfloat rx[4];\n\n\tfor(int k = 0; k < 4; k++)\n\t    rx[k] = mix(r[k], r[k+4], luv.x);\n\n\tfloat rxy[2];\n\n\tfor(int k = 0; k < 2; k++)\n\t    rxy[k] = mix(rx[k], rx[k+2], luv.y);\n\n\tfloat rxyz = mix(rxy[0], rxy[1], luv.z);\n\n\treturn rxyz;\n}\n\nfloat noise(vec3 uv)\n{\n\tfloat r = 0.;\n\tfloat p = 1.;\n\n\tfor(int i = 0; i < 2; i++)\n\t{\n\t    float cr = n(uv * p) / p;\n        r += cr;\n\t    p *= 2.;\n\t}\n\n\tr -= .5;\n\n\treturn r;\n}\n\nfloat sin01(float x)\n{\n\treturn sin(x) * 0.5 + 0.5;\n}\n\nfloat cos01(float x)\n{\n\treturn cos(x) * 0.5 + 0.5;\n}\n\nvec3 lightPos()\n{\n\treturn vec3(1,1,1);\n}\n\nfloat smin(float a, float b, float k)\n{\n\tfloat h = clamp((a - b)/k + 0.5, 0., 1.);\n\tfloat m = h * (1. - h) * 0.5 * k;\n\tfloat r = mix(a, b, h) - m;\n\treturn r;\n}\n\nvec3 cameraPos()\n{\n\treturn vec3(6,8,-6);\n\tfloat t = (fr/30.) * 0.05;\n\n\tvec3 res = vec3(\n\t\tsin(t) * 9.,\n\t\t9.,\n\t\t-cos(t) * 9.);\n\n\treturn res;\n}\n\nvec3 getRay(vec2 uv)\n{\n\tvec3 cam = cameraPos();\n\tvec3 origin = vec3(0, 0, 0);\n\tvec3 look = normalize(origin - cam);\n\tvec3 upGlob = vec3(0,1,0);\n\tvec3 right = normalize(cross(upGlob, look));\n\tvec3 camUp = normalize(-cross(right, look));\n\n\tvec3 p = cam + camUp * uv.y + right * uv.x;\n\tp += look * planeDist;\n\n\tvec3 res = p - cam;\n\treturn normalize(res);\n}\n\nfloat getSphere(vec3 p, float size, vec3 origin)\n{\n\treturn length(p - origin) - size;\n}\n\nfloat getSphere(vec3 p, float size)\n{\n\treturn getSphere(p, size, vec3(0,0,0));\n}\n\nfloat getCube(vec3 p, float size)\n{\n\tp = abs(p);\n\treturn max(max(p.x, p.y), p.z) - size;\n}\n\nfloat getInfCylinder(vec3 p, float size)\n{\n\tfloat l = length(vec3(p.x, p.y, 0)) - size;\n\treturn l;\n}\n\nfloat getPlane(vec3 p)\n{\n\treturn p.y;\n}\n\nfloat inter(float a, float b)\n{\n\treturn max(a, b);\n}\n\nfloat un(float a, float b)\n{\n\treturn min(a, b);\n}\n\nfloat diff(float a, float b)\n{\n\treturn max(a, -b);\n}\n\nfloat getCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nvec2 skew(vec2 p, float a)\n{\n\tfloat ca = cos(a);\n\tfloat sa = sin(a);\n\n\tmat2 m = mat2(ca, sa, -sa, ca);\n\n\tp = p * m;\n\n\treturn p;\n}\n\nfloat getSd(vec3 p)\n{\n\tvec3 po = p;\n\n    float time = fr / 30.;\n    float n = noise(p - vec3(0,time*.5,0));\n\n\tfloat res = n;\n\n\tres = inter(res, getCube(po, 1.7));\n    \n    if (iMouse.z > 0.)\n    {\n        float x = smoothstep(0., 1., iMouse.y / iResolution.y)*2.-1.;\n        x *= 0.5;\n        res -= x;\n    }\n\n    return res;\n}\n\nvec3 calcNormal(vec3 p )\n{\n\tconst float h = 0.03; // or some other value const\n\tvec2 k = vec2(1,-1);\n\n\treturn\n\tnormalize(\n\t\tk.xyy*getSd( p + k.xyy*h ) +\n\t\t k.yyx*getSd( p + k.yyx*h ) +\n\t\t \tk.yxy*getSd( p + k.yxy*h ) +\n\t\t \t\tk.xxx*getSd( p + k.xxx*h ) );\n}\n\nfloat raymarch(vec3 sp, vec3 ray)\n{\n\tfloat depth = 0.;\n\n\tfor(int i = 0; i < 150; i++)\n\t{\n\t\tvec3 p = sp + ray * depth;\n\t\tfloat dist = getSd(p);\n\n\t\tif (dist <= 0.001)\n\t\t  return depth;\n\n\t\tdepth += dist;\n\n\t\tif (depth >= maxDist)\n\t\t  return maxDist;\n\t}\n\n\treturn maxDist;\n}\n\nfloat getShadow(vec3 p)\n{\n\tvec3 lp = lightPos();\n\tfloat ld = length(lp - p);\n\tvec3 ray = normalize(lp - p);\n\tfloat d = raymarch(p + ray*0.2, ray);\n\tfloat res = smoothstep(0.1,1., d);\n\tres = res * 0.3 + 0.7;\n\treturn res;\n}\n\nfloat getSpec(vec3 refRay, vec3 l)\n{\n\tfloat x = dot(refRay, l);\n\n\tx = clamp(x,0.,1.);\n\tx = pow(x, 7.);\n\n\treturn x;\n}\n\nfloat getHatch(vec3 l, vec3 p)\n{\n\tfloat time = fr / 30.;\n\tp -= vec3(0,time*.5,0);\n\tvec3 right = normalize(cross(l, vec3(0,1,0)));\n\tvec3 up = (cross(l, right));\n\n\tfloat u = dot(p, right);\n\tfloat v = dot(p, up);\n\tvec2 uv = vec2(u,v)*0.3;\n\n\tfloat h = texture(iChannel0, uv).r;\n\n\treturn 1.-h;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tvec2 uv = gl_FragCoord.xy / iResolution.xy;\n\tuv -= 0.5;\n\tuv.y /= iResolution.x / iResolution.y;\n    uv *= 2.;\n    \n    vec3 ray = getRay(uv);\n    vec3 camPos = cameraPos();\n\tfloat d = raymarch(camPos, ray);\n\tfloat inf = step(1., maxDist - d);\n\n\tvec3 col = vec3(1.);\n\n\tif (d > 30.)\n\t{\n\t    fragColor = vec4(0);\n\t\treturn;\n\t}\n\n\tvec3 intP = cameraPos() + d*ray;\n\tvec3 n = calcNormal(intP);\n\tvec3 lightDir = normalize(vec3(1));\n\n    float dd = dot(n, lightDir);\n    dd = dd *.5 + .5;\n    \n    vec3 cuv = (intP - vec3(-1.7))/3.4;\n\n\tvec3 res = col * dd * inf * cuv;\n\n\tvec3 refRay = reflect(ray, n);\n\n\tfloat spec = getSpec(refRay, lightDir);\n\tfloat h = getHatch(lightDir, intP);\n    \n\tspec *= h;\n\tres += spec;\n\n    fragColor = vec4(res, 1.0);\n}","name":"Image","description":"","type":"image"}]}