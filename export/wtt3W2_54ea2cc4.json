{"ver":"0.1","info":{"id":"wtt3W2","date":"1577660291","viewed":635,"name":"Spherical Harmonics L1-L4 Lib","username":"lhog","description":"// https://github.com/kayru/Probulator\n\nThe results are different from Probulator. Probably because shadertoy cubemaps are not HDR","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["sphericalharmonics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://github.com/kayru/Probulator\n\n#define myT vec3\n#define myL 4\n\n#define SphericalHarmonicsTL(T, L) T[(L + 1)*(L + 1)]\n#define SphericalHarmonics SphericalHarmonicsTL(myT, myL)\n#define shSize(L) ((L + 1)*(L + 1))\n\n\nconst float PI  = 3.1415926535897932384626433832795;\nconst float PIH = 1.5707963267948966192313216916398;\nconst float sqrtPI = 1.7724538509055160272981674833411; //sqrt(PI)\n\nSphericalHarmonics shZero() {\n\tSphericalHarmonics result;\n\tfor (int i = 0; i < shSize(myL); ++i)\n\t{\n\t\tresult[i] = myT(0.0);\n\t}\n    return result;\n}\n\n\nvoid shScale(inout SphericalHarmonics sh, myT scale) {\n\tfor (int i = 0; i < shSize(myL); ++i)\n\t{\n\t\tsh[i] *= scale;\n\t}\n}\n\nvoid shAddWeighted(inout SphericalHarmonics accumulatorSh, in SphericalHarmonics sh, myT weight)\n{\n\tfor (int i = 0; i < shSize(myL); ++i)\n\t{\n\t\taccumulatorSh[i] += sh[i] * weight;\n\t}\n}\n\nmyT shDot(in SphericalHarmonics shA, in SphericalHarmonics shB)\n{\n\tmyT result = myT(0.0);\n\tfor (int i = 0; i < shSize(myL); ++i)\n\t{\n\t\tresult += shA[i] * shB[i];\n\t}\n\treturn result;\n}\n\nSphericalHarmonics shEvaluate(vec3 p)\n{\n\t// From Peter-Pike Sloan's Stupid SH Tricks\n\t// http://www.ppsloan.org/publications/StupidSH36.pdf\n\t// https://github.com/dariomanesku/cmft/blob/master/src/cmft/cubemapfilter.cpp#L130\n\n\tSphericalHarmonics result;\n\n\tfloat x = -p.x;\n\tfloat y = -p.y;\n\tfloat z = p.z;\n\n\tfloat x2 = x*x;\n\tfloat y2 = y*y;\n\tfloat z2 = z*z;\n\n\tfloat z3 = z2*z;\n\n\tfloat x4 = x2*x2;\n\tfloat y4 = y2*y2;\n\tfloat z4 = z2*z2;\n\n\tint i = 0;\n\n\tresult[i++] =  myT( 1.0f/(2.0f*sqrtPI) );\n\n\t#if (myL >= 1)\n\t\tresult[i++] = myT(-sqrt(3.0f/(4.0f*PI))*y );\n\t\tresult[i++] = myT( sqrt(3.0f/(4.0f*PI))*z );\n\t\tresult[i++] = myT(-sqrt(3.0f/(4.0f*PI))*x );        \t\n    #endif\n\n\t#if (myL >= 2)\n\t\tresult[i++] = myT( sqrt(15.0f/(4.0f*PI))*y*x );\n\t\tresult[i++] = myT(-sqrt(15.0f/(4.0f*PI))*y*z );\n\t\tresult[i++] = myT( sqrt(5.0f/(16.0f*PI))*(3.0f*z2-1.0f) );\n\t\tresult[i++] = myT(-sqrt(15.0f/(4.0f*PI))*x*z );\n\t\tresult[i++] = myT( sqrt(15.0f/(16.0f*PI))*(x2-y2) );\t\t\t\n    #endif\n\n\t#if (myL >= 3)\n\t\tresult[i++] = myT(-sqrt( 70.0f/(64.0f*PI))*y*(3.0f*x2-y2) );\n\t\tresult[i++] = myT( sqrt(105.0f/ (4.0f*PI))*y*x*z );\n\t\tresult[i++] = myT(-sqrt( 21.0f/(16.0f*PI))*y*(-1.0f+5.0f*z2) );\n\t\tresult[i++] = myT( sqrt(  7.0f/(16.0f*PI))*(5.0f*z3-3.0f*z) );\n\t\tresult[i++] = myT(-sqrt( 42.0f/(64.0f*PI))*x*(-1.0f+5.0f*z2) );\n\t\tresult[i++] = myT( sqrt(105.0f/(16.0f*PI))*(x2-y2)*z );\n\t\tresult[i++] = myT(-sqrt( 70.0f/(64.0f*PI))*x*(x2-3.0f*y2) );\t\t\t\n    #endif\n\n\t#if (myL >= 4)\n\t\tresult[i++] = myT( 3.0f*sqrt(35.0f/(16.0f*PI))*x*y*(x2-y2) );\n\t\tresult[i++] = myT(-3.0f*sqrt(70.0f/(64.0f*PI))*y*z*(3.0f*x2-y2) );\n\t\tresult[i++] = myT( 3.0f*sqrt( 5.0f/(16.0f*PI))*y*x*(-1.0f+7.0f*z2) );\n\t\tresult[i++] = myT(-3.0f*sqrt(10.0f/(64.0f*PI))*y*z*(-3.0f+7.0f*z2) );\n\t\tresult[i++] = myT( (105.0f*z4-90.0f*z2+9.0f)/(16.0f*sqrtPI) );\n\t\tresult[i++] = myT(-3.0f*sqrt(10.0f/(64.0f*PI))*x*z*(-3.0f+7.0f*z2) );\n\t\tresult[i++] = myT( 3.0f*sqrt( 5.0f/(64.0f*PI))*(x2-y2)*(-1.0f+7.0f*z2) );\n\t\tresult[i++] = myT(-3.0f*sqrt(70.0f/(64.0f*PI))*x*z*(x2-3.0f*y2) );\n\t\tresult[i++] = myT( 3.0f*sqrt(35.0f/(4.0f*(64.0f*PI)))*(x4-6.0f*y2*x2+y4) );\n    #endif\n\n\treturn result;\n}\n\nmyT shEvaluateDiffuse(SphericalHarmonics sh, vec3 direction) {\n\n\tSphericalHarmonics directionSh = shEvaluate(direction);\n\t// https://cseweb.ucsd.edu/~ravir/papers/envmap/envmap.pdf equation 8\n\n\tconst float A[5] = float[5](\n\t\t 1.0,\n\t\t 2.0 / 3.0,\n\t\t 1.0 / 4.0,\n\t\t 0.0,\n\t\t-1.0f / 24.0\n\t);\n\n\tint i = 0;\n\n\tmyT result = sh[i] * directionSh[i] * A[0]; ++i;\n\n\t#if (myL >= 1)\n\t\tresult += sh[i] * directionSh[i] * A[1]; ++i;\n\t\tresult += sh[i] * directionSh[i] * A[1]; ++i;\n\t\tresult += sh[i] * directionSh[i] * A[1]; ++i;\n\t#endif\n\n\t#if (myL >= 2)\n\t\tresult += sh[i] * directionSh[i] * A[2]; ++i;\n\t\tresult += sh[i] * directionSh[i] * A[2]; ++i;\n\t\tresult += sh[i] * directionSh[i] * A[2]; ++i;\n\t\tresult += sh[i] * directionSh[i] * A[2]; ++i;\n\t\tresult += sh[i] * directionSh[i] * A[2]; ++i;\n\t#endif\n\n\t// L3 and other odd bands > 1 have 0 factor\n\n\t#if (myL >= 4)\n\t\ti = 16;\n\n\t\tresult += sh[i] * directionSh[i] * A[4]; ++i;\n\t\tresult += sh[i] * directionSh[i] * A[4]; ++i;\n\t\tresult += sh[i] * directionSh[i] * A[4]; ++i;\n\t\tresult += sh[i] * directionSh[i] * A[4]; ++i;\n\t\tresult += sh[i] * directionSh[i] * A[4]; ++i;\n\t\tresult += sh[i] * directionSh[i] * A[4]; ++i;\n\t\tresult += sh[i] * directionSh[i] * A[4]; ++i;\n\t\tresult += sh[i] * directionSh[i] * A[4]; ++i;\n\t\tresult += sh[i] * directionSh[i] * A[4]; ++i;\n\t#endif\n\n\treturn result;   \n}\n\n\n///////////////////////////////////////////////////////////////////////////////////////\n\n#define reflectTex iChannel0\n///////////////////////////////////////////////////////////////////////////////////////\n\nconst float goldenAngle = 2.3999632297286533222315555066336; // PI * (3.0 - sqrt(5.0));\nconst vec3 LUMA = vec3(0.2126, 0.7152, 0.0722);\n\nvec3 SpherePoints_GoldenAngle(float i, float numSamples) {\n    float theta = i * goldenAngle;\n    float z = (1.0 - 1.0 / numSamples) * (1.0 - 2.0 * i / (numSamples - 1.0));\n    float radius = sqrt(1.0 - z * z);\n    return vec3(radius * vec2(cos(theta), sin(theta)), z);\n}\n\nvec3 sampleReflectionMap(vec3 p, float b) {\n    vec3 col = textureLod(reflectTex, p, b).rgb;\n    \n    // fake HDR\n    //col *= 1.0 + 1.0 * smoothstep(0.5, 1.0, dot(LUMA, col));\n    \n    return col;\n}\n\n#define ENV_SMPL_NUM 256\nSphericalHarmonics CubeMapToRadianceSH() {\n    // Initialise sh to 0\n    SphericalHarmonics shRadiance = shZero();\n\n    vec2 ts = vec2(textureSize(reflectTex, 0));\n    float maxMipMap = log2(max(ts.x, ts.y));\n\n    float lodBias = maxMipMap - 5.0;\n    \n\n    for (int i=0; i < ENV_SMPL_NUM; ++i) {\n        vec3 direction = SpherePoints_GoldenAngle(float(i), float(ENV_SMPL_NUM));\n        vec3 radiance = sampleReflectionMap(direction, lodBias);\n        shAddWeighted(shRadiance, shEvaluate(direction), radiance);\n    }\n\n    // integrating over a sphere so each sample has a weight of 4*PI/samplecount (uniform solid angle, for each sample)\n    float shFactor = 4.0 * PI / float(ENV_SMPL_NUM);\n    shScale(shRadiance, vec3(shFactor));\n\n    return shRadiance;\n}\n\nvec3 GetRadianceFromSH(SphericalHarmonics shRadiance, vec3 direction) {\n    SphericalHarmonics shDirection = shEvaluate(direction);\n\n    vec3 sampleSh = max(vec3(0.0), shDot(shRadiance, shDirection));    \n    return sampleSh;\n}\n\nvec3 GetIrradianceFromSH(SphericalHarmonics shRadiance, vec3 direction) {\n    SphericalHarmonics shDirection = shEvaluate(direction);\n\n    vec3 sampleIrradianceSh = max(vec3(0.0), shEvaluateDiffuse(shRadiance, direction));\n    return sampleIrradianceSh;\n}\n\n//////////////////////////////////////////////////////////////\n#define NORM2SNORM(value) (value * 2.0 - 1.0)\n#define SNORM2NORM(value) (value * 0.5 + 0.5)\n\nvec3 EquirectToDirection(vec2 uv) {\n    uv = NORM2SNORM(uv);\n    uv.x *= PI;  // phi\n    uv.y *= PIH; // theta\n        \n    /* Calculate a direction from spherical coords:\n\t** R = 1\n    ** x = R sin(phi) cos(theta)\n\t** y = R sin(phi) sin(theta)\n\t** z = R cos(phi)\n\t*/\n    return vec3(cos(uv.x)*cos(uv.y)\n              , sin(uv.y)\n              , sin(uv.x)*cos(uv.y));\n}\n\n#define ENV_SMPL_NUM2 1024\nvec3 DiffuseImportanceSampling(in vec3 N, float power, bool lumaAsWeight) {\n    vec3 iblDiffuse = vec3(0.0);\n\n    float sum = 0.0;\n\n    vec2 ts = vec2(textureSize(reflectTex, 0));\n    float maxMipMap = log2(max(ts.x, ts.y));\n\n    float lodBias = maxMipMap - 5.0;\n\n    for (int i=0; i < ENV_SMPL_NUM2; ++i) {\n        vec3 sp = SpherePoints_GoldenAngle(float(i), float(ENV_SMPL_NUM2));\n\n        vec3 iblD = sampleReflectionMap(sp, lodBias); \n\n        float w = SNORM2NORM(dot(sp, N ));\n\n        w = pow(w, power); //pow exponent is responsible for sharpness of the resulting convolution\n        \n        if (lumaAsWeight)\n        \tw *= dot(LUMA, iblD);\n\n        iblDiffuse  += iblD * w;\n\n        sum += w;\n    }\n\n    iblDiffuse  /= sum;\n    return iblDiffuse;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 direction = EquirectToDirection(uv);\n    \n    SphericalHarmonics shRadiance = CubeMapToRadianceSH();\n    \n    vec3 col;\n    \n    int m = int(iTime) % 7;\n    if (m == 0)\n    \tcol = sampleReflectionMap(direction, 0.0);\n    else if (m == 1)\n    \tcol = GetRadianceFromSH(shRadiance, direction);\n    else if (m == 2)\n        col = GetIrradianceFromSH(shRadiance, direction);\n\telse if (m == 3)         \n        col = DiffuseImportanceSampling(direction, 2.0, false);\n\telse if (m == 4)\n        col = DiffuseImportanceSampling(direction, 2.0, true);\n\telse if (m == 5)\n        col = DiffuseImportanceSampling(direction, 64.0, false);        \n    else if (m == 6)\n        col = textureLod(iChannel1, direction, 0.0).rgb;\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}