{"ver":"0.1","info":{"id":"wlcyWl","date":"1612925642","viewed":168,"name":"Frigid Mountain Flyover","username":"4gateftw","description":"My first foray into raymarching and non-trivial shader programming. I'm proud of it, though I wish I'd had time to add clouds. Mountains are generated and then textured with fractal Brownian motion. Inspired by the work of Inigo Quilez.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fbm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Nicholas Smoker, nsmoker@trinity.edu, and published on 02/10/2021\n// Stuff that helped me: \n// https://iquilezles.org/articles/morenoise\n// https://iquilezles.org/articles/fbm\n// https://iquilezles.org/articles/terrainmarching\n// https://www.shadertoy.com/view/4ttSWf\n// https://www.shadertoy.com/view/MdBGzG\n// https://www.shadertoy.com/view/4sdfz8\n\nconst int NUM_OCTAVES = 10;\n\nstruct DirectionalLight\n{\n    vec3 specular;\n    vec3 diffuse;\n    vec3 direction;\n};\n\nconst DirectionalLight sun = DirectionalLight(vec3(1.25, 0.7, 0.2), vec3(1.25, 0.7, 0.2), vec3(1.0, -1.0, -1.0));\nconst DirectionalLight skyLight = DirectionalLight(vec3(0.075, 0.075, 0.3), vec3(0.05, 0.05, 0.2), vec3(0.0, -1.0, 0.0));\nconst DirectionalLight ind = DirectionalLight(vec3(0.0, 0.0, 0.0), vec3(0.3, 0.17, 0.05), vec3(-1.0, 0.0, 1.0));\n\nfloat noise( in vec2 x )\n{\n    vec2 f = fract(x);\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 p = floor(x);\n\tfloat a = textureLod( iChannel0, (p+vec2(0.5,0.5))/256.0, 0.0 ).x;\n\tfloat b = textureLod( iChannel0, (p+vec2(1.5,0.5))/256.0, 0.0 ).x;\n\tfloat c = textureLod( iChannel0, (p+vec2(0.5,1.5))/256.0, 0.0 ).x;\n\tfloat d = textureLod( iChannel0, (p+vec2(1.5,1.5))/256.0, 0.0 ).x;\n    return a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y;\n}\n\nfloat noiseT( in vec2 x, sampler2D tex)\n{\n    vec2 f = fract(x);\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 p = floor(x);\n\tfloat a = textureLod( tex, (p+vec2(0.5,0.5))/1024.0, 0.0 ).x;\n\tfloat b = textureLod( tex, (p+vec2(1.5,0.5))/1024.0, 0.0 ).x;\n\tfloat c = textureLod( tex, (p+vec2(0.5,1.5))/1024.0, 0.0 ).x;\n\tfloat d = textureLod( tex, (p+vec2(1.5,1.5))/1024.0, 0.0 ).x;\n    return a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y;\n}\n\nfloat fbm(in vec2 x)\n{\n    float g = 0.5;\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for(int i = 0; i < NUM_OCTAVES; ++i)\n    {\n        t += a * noise(f * x);\n        f *= 2.0;\n        a *= g;\n    }\n    return t;\n}\n\nfloat fbmT(in vec2 x, sampler2D tex)\n{\n    float g = 0.5;\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for(int i = 0; i < NUM_OCTAVES; ++i)\n    {\n        t += a * noiseT(f * x, tex);\n        f *= 2.0;\n        a *= g;\n    }\n    return t;\n}\n\nfloat terrainH(vec2 xz)\n{\n    float ret = fbm(xz);\n    return ret;\n}\n\nvec3 terrainCol(vec3 position, vec3 normal)\n{\n   vec3 rocCol = vec3(0.075) * mix(fbmT(position.yx * 1000.0, iChannel1), fbmT(position.yz * 1000.0, iChannel1), (normal.x - normal.z) / 5.0);\n   if(position.y <= 1.0 || normal.y <= 0.5) {\n       return rocCol;\n   } else {\n       return rocCol + smoothstep(1.0, 1.3, position.y) * vec3(0.3, 0.3, 0.3);\n   }\n}\n\nfloat cloudDensity(vec3 position)\n{\n    return noiseT(position.xz, iChannel2);\n}\n\nbool castRay(vec3 ro, vec3 rd, out float d)\n{\n    float end = 100.0;\n    float inc = 0.01;\n    float lastH = 0.0;\n    float lastY = 0.0;\n    for(float depth = 0.001; depth < end; depth += inc)\n    {\n        vec3 p = ro + rd * depth;\n        float h = terrainH(p.xz);\n        float dist = p.y - h;\n        if(dist < 0.001 * depth)\n        {\n            d = depth - inc + inc * (lastH - lastY) / (h - lastH - p.y + lastY);\n            return true;\n        }\n        inc = pow(depth, 0.2) * ((0.3 * dist) / 2.0);\n        lastH = h;\n        lastY = p.y;\n    }\n    return false; \n}\n\nfloat shadow(vec3 ro, vec3 rd)\n{\n    float depth = 0.001;\n    float res = 1.0;\n    float oldH = 1e20;\n    for(int i = 0; i < 32; ++i)\n    {\n        vec3 p = ro + rd * depth;\n        float ter = terrainH(p.xz);\n        float h = p.y - ter;\n        if(h < 0.001) return 0.0;\n        float y = h * h / (2.0 * oldH);\n        float d = sqrt(h * h / y * y);\n        res = min(res, 2.0 * d / max(0.0, depth - y));\n        depth += h;\n        oldH = h;\n    }\n    return res;\n}\n\nvec3 getNormal(vec3 p, float depth)\n{\n    vec2 eps = vec2(0.001 * depth, 0.0);\n    return normalize(vec3(terrainH(p.xz - eps.xy) - terrainH(p.xz + eps.xy),\n                     2.0 * eps.x,\n                     terrainH(p.xz - eps.yx) - terrainH(p.xz + eps.yx)));\n}\n\nvec3 phongShade(vec3 ro, float depth, vec3 ray, vec3 p, DirectionalLight light)\n{\n    vec3 norm = getNormal(p, depth);\n    vec3 lightDir = normalize(-light.direction);\n    vec3 reflectDir = normalize(reflect(-lightDir, norm));\n    vec3 viewDir = normalize(ro - p);\n    vec3 tCol = terrainCol(p, norm);\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    \n    if(dot(lightDir, norm) < 0.0)\n    {\n        return col;\n    }\n    \n    vec3 diffuseComponent = tCol * dot(lightDir, norm) * light.diffuse;\n    \n    if(dot(reflectDir, viewDir) < 0.0)\n    {\n        return col + diffuseComponent;\n    }\n    \n    vec3 specularComponent = tCol * pow(dot(reflectDir, viewDir), 1.1) * light.specular;\n    \n    return col + diffuseComponent + specularComponent;\n}\n\nvec3 illumination(vec3 ro, vec3 ray, float depth)\n{\n    vec3 p = ro + depth * ray;\n    float skyShad = shadow(p, normalize(-skyLight.direction));\n    vec3 col = phongShade(ro, depth, ray, p, sun) * shadow(p, normalize(-sun.direction));\n    col += phongShade(ro, depth, ray, p, skyLight) * skyShad;\n    return col + phongShade(ro, depth, ray, p, ind) * skyShad;\n}\n\nvec3 sky(vec3 ray)\n{\n    float sunMult = dot(ray, -sun.direction) * 0.75;\n    return mix(vec3(0.0, 0.0, 0.2), vec3(1.0, 0.7, 0.2), sunMult);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 eyePos = vec3(1.5, 1.5, 12.5 + iTime * 0.05);\n    vec3 ray = normalize(vec3((-iResolution.xy + 2.0*fragCoord)/iResolution.y, 3.0));\n    float res;\n    if(castRay(eyePos, ray, res)) {\n        fragColor = vec4(pow(illumination(eyePos, ray, res), vec3(1.0 / 2.2)), 1.0);\n    } else {\n        fragColor = vec4(sky(ray), 1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}