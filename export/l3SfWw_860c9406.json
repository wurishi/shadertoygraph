{"ver":"0.1","info":{"id":"l3SfWw","date":"1729520124","viewed":23,"name":"wave simulator 0.6","username":"Psyph","description":"so much easier... this is more like simulating a ripple on water. each pixel can have a \"height\" value, red is the top of the wave and blue the bottom.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["wave"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col2=texture(iChannel0,uv).xyz;\n    float b=texture(iChannel1,uv).x;\n    col2.yz=vec2(0.);\n    col2.z=-col2.x;\n\n    fragColor = vec4(4.*col2*(1./b),1.0);\n\n    //vec3 col=texture(iChannel1,uv).xyz;\n    //fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//red stores position and blue stores velocity.\n#define fr fragCoord\n\nvec3 calcn(ivec2 p)\n{\n    vec3 p1=texelFetch(iChannel0,p,0).xyz;\n    float f=0.;\n    int ney=6;\n    int i=-ney;\n    while(i<=ney)\n    {\n        int j=-ney;\n        while(j<=ney)\n        {\n            if(i==0&&j==0) j++;\n            vec2 p2=texelFetch(iChannel0,p+ivec2(i,j),0).xz;\n            f+=(p1.x-p2.x)/length(vec2(i,j));\n            j++;\n        }\n        i++;\n    }\n    p1.z-=.05*f;\n    p1.x+=p1.z;\n    return p1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col=texelFetch(iChannel0,ivec2(fr),0).xyz;\n    if(iFrame<10)\n    {\n        col=vec3(0.);\n    }\n    else\n    {\n        vec2 b=texelFetch(iChannel1,ivec2(fr),0).yz;\n        col=calcn(ivec2(fr));\n        float g=iResolution.x/4.;\n        float h=iResolution.y/2.;\n        if(length(fr-vec2(g,h))<8.)\n        {\n            col=vec3(0.);\n            float hfreq=25.;\n            float bfreq=1.8;\n            col.x=sin(iTime*bfreq*hfreq)/2.;\n        }\n        col*=b.y;\n    }\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//blue; amount gets multiplied by the wave in calculation, causing damping. \n//1 means wave uninhibited, 0 means pixel does not react to wave.\n//red; only effects the visual output on the screen. multiplies by the inverse of amount.\n//.2 = wave appears 5 times as bright\n\n#define fr fragCoord\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //init whole screen no damping no brightening\n    vec3 col=vec3(1.,0.,.99);\n    \n    //top and bottom dampers, min and max damping\n    float mi = .75;\n    float ma = 1.;\n    if(fr.y<20.)\n    {\n        col.z=mix(mi,ma,fr.y/20.);\n    }\n    if(fr.y>iResolution.y-20.)\n    {\n        col.z=mix(mi,ma,(iResolution.y-fr.y)/20.);\n    }\n    \n    //slit wall\n    float g=3.*iResolution.x/5.;\n    if(fr.x>g&&fr.x<g+10.)\n    {\n        col.z=.38;\n    }\n    \n    //create multiple slits, prob doesnt work for now...\n    //float ph=100.;\n    //float ph=iResolution.y/4.;\n    //float n=2.;\n    //float m=mod(fr.y-ph,iResolution.y/n);\n    //float s=20./2.;\n    \n    //if(m<s&&m>-s)\n    //{\n    //    col.z=1.;\n    //}\n    \n    //slits\n    float m=iResolution.y/2.;\n    float s=60.;\n    float w=20.;\n    if(fr.y>m-s-w/2.&&fr.y<m-s+w/2.)\n    {\n        col.z=1.;\n    }\n    if(fr.y>m+s-w/2.&&fr.y<m+s+w/2.)\n    {\n        col.z=1.;\n    }\n    \n    //side dampers\n    if(fr.x<20.)\n    {\n        col.z=mix(mi,ma,fr.x/20.);\n    }\n    if(fr.x>iResolution.x-20.)\n    {\n        col.z=mix(mi,ma,(iResolution.x-fr.x)/20.);\n    }\n    if(fr.x>g+10.)\n    {\n         col.x=.1;\n    }\n    \n    fragColor = vec4(col,1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}