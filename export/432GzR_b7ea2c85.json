{"ver":"0.1","info":{"id":"432GzR","date":"1708121785","viewed":52,"name":"Fast 2d fractal noise","username":"Zentient","description":"Simple layered 2d value noise using billinear interpolation. Doesn't look great at low octaves but I'm going for speed since I want to raymarch 3d noise.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["whitenoise","hashing"],"hasliked":0,"parentid":"4XXGWX","parentname":"3d hash noise"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define hashi(x)   lowbias32(x)\n#define hash(x)  ( float( hashi(x) ) / float( 0xffffffffU ) )\n\nconst float kernelDia = 3.0; //odd numbers only\n\n//bias: 0.17353355999581582 ( very probably the best of its kind )\nuint lowbias32(uint x)\n{\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\n//Random function\nfloat rand(vec2 position)\n{\n    uvec2 V = uvec2(position);\n    float h = hash( V.x + (V.y<<16) );  // 2D hash (should be ok too )\n    return h;\n\n}\n\n\n\n//linear interpolation function from https://www.shadertoy.com/view/WttXWX\nfloat interpolate(vec2 position)\n{\n    vec2 quantPos = round((position + 0.5));\n    vec2 divPos = fract(0.0 + (1.0 * position));\n    \n\n    //Finds noise values for the corners\n    vec4 lerpXY = vec4(\n        rand(quantPos + vec2(0.0, 0.0)),\n        rand(quantPos + vec2(1.0, 0.0)),\n        rand(quantPos + vec2(1.0, 1.0)),\n        rand(quantPos + vec2(0.0, 1.0)));\n    //Calculates the area of rectangles\n    vec4 weights = vec4(\n    abs((1.0 - divPos.x) * (1.0 - divPos.y)),\n    abs((0.0 - divPos.x) * (1.0 - divPos.y)),\n    abs((0.0 - divPos.x) * (0.0 - divPos.y)),\n    abs((1.0 - divPos.x) * (0.0 - divPos.y)));\n   \n    return weights.r * lerpXY.r +\n           weights.g * lerpXY.g +\n           weights.b * lerpXY.b +\n           weights.a * lerpXY.a;\n    \n}\n//Octaves of noise, sligtly less than a perfect octave to hide linear interpolation artifatcs\nfloat octave(vec2 coord, float octaves, float div)\n{\n    \n    float col = 0.0;\n    float it = 1.0;\n    float cnt = 1.0;\n    for(float i = 1.0; i <= octaves; i++)\n    {\n        col = col + interpolate((it * coord / (div))) / it;\n        it = it * 1.9;\n        cnt = cnt + 1.0 / it;\n       \n    }\n    return col / cnt;\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n   float oct = 4.0;\n   vec2 uv = fragCoord/iResolution.x;\n   vec2 motCoord = fragCoord + floor(64.0 * iTime);\n   vec3 col = vec3( pow(octave(motCoord, oct, 30.0), 1.0 ) );\n   fragColor = vec4(col, 1.0);\n    \n}","name":"Image","description":"","type":"image"}]}