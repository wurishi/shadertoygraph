{"ver":"0.1","info":{"id":"fljGD3","date":"1624863998","viewed":90,"name":"Parametric line and ray equation","username":"Envy24","description":"Explicit parametric line and ray equations","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["ray","line","equation","parametric","explicit"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R iResolution\n#define FUNC rayXY\n\nvec2 rotateAroundZ(vec2 p, float a)\n{\n    float s = sin(-a);\n    float c = cos(-a);\n\n    return vec2(\n        p.x * c + p.y * s,\n        p.y * c - p.x * s);\n}\n\nfloat scene(vec2 p, vec2 o)\n{\n    float xOff = 180.0;\n    float yOff = 180.0;\n    float angularSpeed = 60.0;\n\n    float gray = FUNC(p, o, iTime * TO_RAD * angularSpeed);\n    gray = min(gray, FUNC(p, o + vec2(xOff, yOff), iTime * TO_RAD * angularSpeed * 1.1));\n    gray = min(gray, FUNC(p, o + vec2(-xOff, yOff), iTime * TO_RAD * angularSpeed * 1.2));\n    gray = min(gray, FUNC(p, o + vec2(xOff, -yOff), iTime * TO_RAD * angularSpeed * 1.3));\n    gray = min(gray, FUNC(p, o + vec2(-xOff, -yOff), iTime * TO_RAD * angularSpeed * 1.4));\n    \n    return gray;\n}\n\nfloat scene2(vec2 p, vec2 o)\n{\n    float t = iTime * 20.0;\n\n    vec2 c0 = vec2(0.0, -60.0);\n    vec2 c1 = vec2(-60.0, 0.0);\n    vec2 c2 = vec2(60.0, 0.0);\n      \n    float gray = FUNC(p, o + c0, (t + 0.0) * TO_RAD);\n    gray = min(gray, FUNC(p, o + c1, (t + 45.0) * TO_RAD));\n    gray = min(gray, FUNC(p, o + c2, (t + 135.0) * TO_RAD));\n    \n    return gray;\n}\n\nfloat scene3(vec2 p, vec2 o)\n{\n    float t = iTime * 10.0;\n    //float t = 0.0;\n\n    vec2 c0 = vec2(0.0, -60.0);\n    vec2 c1 = vec2(-60.0, 0.0);\n    vec2 c2 = vec2(60.0, 0.0);\n    \n    vec2 d0 = direction(0.0 * TO_RAD);\n    vec2 d1 = direction(45.0 * TO_RAD);\n    vec2 d2 = direction(135.0 * TO_RAD);\n    \n    c0 = rotateAroundZ(c0, t * TO_RAD);\n    c1 = rotateAroundZ(c1, t * TO_RAD);\n    c2 = rotateAroundZ(c2, t * TO_RAD);\n    \n    d0 = rotateAroundZ(d0, t * TO_RAD);\n    d1 = rotateAroundZ(d1, t * TO_RAD);\n    d2 = rotateAroundZ(d2, t * TO_RAD);\n    \n    #define FUNC2 lineXY2\n    float gray = FUNC2(p, o + c0, d0);\n    gray = min(gray, FUNC2(p, o + c1, d1));\n    gray = min(gray, FUNC2(p, o + c2, d2));\n    \n    return gray;\n}\n\nfloat scene4(vec2 p, vec2 o)\n{\n    float t = iTime * 10.0;\n    //float t = 0.0;\n\n    vec2 c0 = vec2(0.0, -60.0);\n    vec2 c1 = vec2(-60.0, 0.0);\n    vec2 c2 = vec2(60.0, 0.0);\n\n    c0 = rotateAroundZ(c0, t * TO_RAD);\n    c1 = rotateAroundZ(c1, t * TO_RAD);\n    c2 = rotateAroundZ(c2, t * TO_RAD);\n\n    float gray = FUNC(p, o + c0, (t + 0.0) * TO_RAD);\n    gray = min(gray, FUNC(p, o + c1, (t + 45.0) * TO_RAD));\n    gray = min(gray, FUNC(p, o + c2, (t + 135.0) * TO_RAD));\n    \n    return gray;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 FC )\n{\n    vec2 o = R.xy * 0.5;\n\n    float deg = (iMouse.x / R.x) * 360.0;\n\n    //float gray = FUNC(FC, o, deg * TO_RAD); // interactive\n    //float gray = rayXY3(FC, o, vec2(-1.0, 0.1));\n    float gray = scene(FC, o);\n    //float gray = scene4(FC, o);\n\n\n    // Output to screen\n    fragColor = vec4(vec3(gray),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define TO_RAD 0.017453292519943295\n#define PI 3.141592\n\nvec2 direction(float a)\n{\n    return vec2(sin(-a + PI / 2.0), cos(-a + PI / 2.0));\n}\n\n/*\n    p - test point;\n    o - line origin;\n    a - angle between x axis and line direction.\n*/\nfloat lineXY(vec2 p, vec2 o, float a)\n{\n    vec2 d = vec2(sin(-a), cos(-a));\n    \n    float t = dot(p - o, d) / dot(d, d); // signed distance\n    \n    return t < 0.0 ? -t : t;\n}\n\n/*\n    p   - test point;\n    o   - line origin;\n    dir - normalized line direction vector.\n*/\nfloat lineXY2(vec2 p, vec2 o, vec2 dir)\n{\n    vec2 d = cross(\n        vec3(dir.xy, 0.0),\n        vec3(0.0, 0.0, 1.0) ).xy;\n    \n    float t = dot(p - o, d) / dot(d, d); // signed distance\n    \n    return t < 0.0 ? -t : t;\n}\n\n/*\n    p - test point;\n    o - line origin;\n    a - angle between x axis and line direction.\n*/\nfloat rayXY(vec2 p, vec2 o, float a)\n{\n    vec2 d = vec2(sin(-a), cos(-a));\n    \n    float t = dot(p - o, d) / dot(d, d); // signed distance\n    \n    vec2 d2 = vec2(\n        sin(-a + 90.0 * TO_RAD),\n        cos(-a + 90.0 * TO_RAD));\n        \n    float t2 = dot(p - o, d2) / dot(d2, d2);\n    \n    return t2 >= 0.0 ? (t < 0.0 ? -t : t) : 1.0;\n}\n\n/*\n    p - test point;\n    o - line origin;\n    a - angle between x axis and line direction.\n*/\nfloat rayXY2(vec2 p, vec2 o, float a)\n{\n    vec2 d = vec2(sin(-a), cos(-a));\n    \n    float t = dot(p - o, d) / dot(d, d); // signed distance\n    \n    vec2 d2 = cross(vec3(d.xy, 0.0), vec3(0.0, 0.0, 1.0)).xy;\n        \n    float t2 = dot(p - o, d2) / dot(d2, d2);\n    \n    return t2 >= 0.0 ? (t < 0.0 ? -t : t) : 1.0;\n}\n\n/*\n    p   - test point;\n    o   - line origin;\n    dir - normalized line direction vector.\n*/\nfloat rayXY3(vec2 p, vec2 o, vec2 dir)\n{\n    vec2 d = cross(vec3(dir.xy, 0.0), vec3(0.0, 0.0, 1.0)).xy;\n    \n    float t = dot(p - o, d) / dot(d, d); // signed distance\n    \n    vec2 d2 = cross(vec3(d.xy, 0.0), vec3(0.0, 0.0, -1.0)).xy;\n        \n    float t2 = dot(p - o, d2) / dot(d2, d2);\n    \n    return t2 >= 0.0 ? (t < 0.0 ? -t : t) : 1.0;\n}","name":"Common","description":"","type":"common"}]}