{"ver":"0.1","info":{"id":"WlByzc","date":"1595009041","viewed":154,"name":"Line Integral Sinusoid 3D","username":"spalmer","description":"extending back to 3D but visualizing every ray as a trace through fog as density; equivalent to blackle's original toy but with my math.  I'm still not happy with how it gets scaled and visualized, but it's working well enough I'll show it.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["fog","analytic","integral","calculus","lineintegral"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// I simply stole blackle's work from https://shadertoy.com/view/3lByRK\n// and changed to use my method instead.  Most of credit to blackle.\n\n// see 1D toy at https://shadertoy.com/view/3lScz3 where the math was derived\n// see 2D toy at https://shadertoy.com/view/WtScRc\n\n// CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n// To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n// and so has Sean L. Palmer.\n\nconst float pi = acos(-1.);\n\n#if 1\n// my way\n/**/\n// the sinusoidal function we're working with, F(x) := sin(x)^2; in Maxima notation.\nfloat F(float x)\n{\n    float s = sin(x);\n\treturn s*s; // s^2\n}\n// in 3D we don't show or evaluate the F function directly\nfloat F(vec3 p)\n{\n    //return F(p.y) * F(p.z);\n    return F(p.x) * F(p.y) * F(p.z);\n    //return F(p.x) + F(p.y) + F(p.z);\n    //return F(p.x) + F(p.y);\n    //return F(p.x);\n\t//return dot(vec3(F(p.x),F(p.y),F(p.z)), vec3(1,0,1));\n    //return F(p.x) * F(p.y) * F(p.z); // ?\n}\n// ok maybe we do\n/**/\n/*\n(%i0) F(p) := sin(p)^2;\n(%o0)\tF(p):=sin(p)^2\n(%i1) integrate(F(p_x), p_x, a_x, b_x)\n\t+ integrate(F(p_y), p_y, a_y, b_y)\n\t+ integrate(F(p_z), p_z, a_z, b_z);\n(%o1)\t-(sin(2*b_z)-2*b_z)/4-(sin(2*b_y)-2*b_y)/4-(sin(2*b_x)-2*b_x)/4\n\t\t+(sin(2*a_z)-2*a_z)/4+(sin(2*a_y)-2*a_y)/4+(sin(2*a_x)-2*a_x)/4\n(%i2) trigsimp(%o1);\n(%o2)\t-(sin(2*b_z)-2*b_z+sin(2*b_y)-2*b_y+sin(2*b_x)-2*b_x\n\t\t -sin(2*a_z)+2*a_z-sin(2*a_y)+2*a_y-sin(2*a_x)+2*a_x)/4\n*/\n// Maxima does integrate(F(x), x, a, b); producing (+2*b-2*a-sin(2*b)+sin(2*a))/4\n// compute line integral of F(x) with x ranging between a and b\nfloat A(float a, float b)\n{\n    return abs(.5*(b - a) + .25*(sin(2.*a) - sin(2.*b)));\n}\n/*\n// no idea why I split it out this way originally;\n// I almost want to rewrite all of this anyway now.\nfloat B(float a, float b)\n{\n    return .0125 * abs(b - a); // constant fog on this axis\n}\n*/\nfloat A(vec3 a, vec3 b, vec3 dir)\n{\n    return dot(abs(dir), vec3(A(a.x, b.x), A(a.y, b.y), A(a.z, b.z))) // bingo!\n        //A(a.x, b.x)// just one plane is interesting\n        //dot(abs(dir), vec3(F(a), A(a.y, b.y), A(a.z, b.z))) //A(a.y, b.y) * A(a.z, b.z) // \"beams\"?\n        //(A(a.x, b.x) * A(a.y, b.y) * A(a.z, b.z)) / 127. // product shows up much more strongly\n        //(A(a.x, b.x) + A(a.y, b.y) + A(a.z, b.z)) / 3.\n    \t//(A(a.x, b.x) + A(a.y, b.y) + B(a.z, b.z)) / 3. // seems we must include some constant fog on the remaining axes or it doesn't seem right\n    \t//(A(a.x, b.x) + A(a.y, b.y)) / 2.\n    \t//(A(a.x, b.x) + B(a.y, b.y) + B(a.z, b.z)) / 3.\n    \t//A(a.x, b.x) // Can see mine easier when using just 2 axes or even just one\n        ;     // HACK\n}\n// if you give the individual planes/puffs any sort of density, \n// it quickly obscures view entirely, which wasn't really desired.\n\nfloat lineintegral(vec3 a, vec3 b) \n{\n    // find a scale where I can perceive it\n    const float s = 4.8; //1.; //2.; //.5; //200.; //1./200.; //\n    a *= s; b *= s; //\n    vec3 dir = (b - a);\n    if (dot(dir, dir) > 0.) dir = normalize(dir);\n    return A(a, b, dir) / s;\n}\n\n// I don't think it's quite right though,\n// because each axis is considered too independently.\n// I believe I probably must integrate the full vector equation\n// but I won't know until I see it.\n// yeah, I mean, it does work, but it does also\n// seem to combine in a way that isn't quite realistic.\n// It seems I can see one axis, and maybe even two, but\n// when I combine all three, I can't perceive the noise anymore.\n// I added wind so I can notice flow, which helps, \n// and I can definitely see it when there's just one planar axis\n// of fog flowing, but when I combine all 3, very hard to see, again.  :(\n// I tried some exponent-bending hacks, nothing works well so far.\n// I get the feeling I'm missing something crucial here\n// regarding self-obscurance of the fog.\n// idk how I'd incorporate that into the integral,\n// if it would even be possible.\n// anyway this was only intended to mimic\n// the flow of noise through otherwise solid fog, anyway!!!\n// So, if I can wrangle the values to a usable range\n// and distribution, I can utilize it to modulate\n// some other shape of fog, which is still very useful.\n// proper scattering can be factored by angle easily,\n// at least for single-scattering model.\n// for fog-shadows, would likely need to march through somehow.\n// I can't see how this technique would handle god-rays,\n// unless the fog-sheets themselves were arranged into beams\n// directed along a certain axis, which is easy for parallel beams\n// with fairly uniform distribution, but not so easy for\n// beams emanating from a point or ball or something.\n// Oh well I think it's still great for certain purposes!\n\n#else\n\n// blackle's way\n// shitty way to prevent division by zero. if b is zero, add a little bit to it.\nvec3 div(vec3 a, vec3 b) \n{\n    b += vec3(equal(b, vec3(0))) * .01;\n    return a/b;\n}\n\nvec3 antiderivatives(float x, vec3 origin, vec3 dir) \n{\n    // antiderivative for pow(dot(sin(origin + x*dir), vec3(1), 2.);\n    mat3 A = mat3( 1, 1, 0, -1, 0, 1,  0,-1,-1);\n    mat3 B = mat3( 1, 1, 0,  1, 0, 1,  0, 1, 1);\n    vec3 Q = origin + dir * x;\n    vec3 integral = div(sin(A*Q),(A*dir)) \n                  - div(sin(B*Q),(B*dir))\n         + div((2.*Q-sin(2.*Q)),(4.*dir));\n    return integral;\n}\n\nfloat lineintegral(vec3 a, vec3 b) \n{\n    float len = distance(a, b);\n    vec3 dir = (b-a)/len;\n    vec3 r = antiderivatives(len,a,dir) - antiderivatives(0.,a,dir);\n    return dot(r, vec3(1));\n}\n\n#endif\n\n// blackle implemented Rodrigues' rotation formula\nvec3 erot(vec3 p, vec3 ax, float ro) \n{\n    return mix(dot(ax,p)*ax, p, cos(ro)) + sin(ro)*cross(ax,p);\n}\n// blackle bit munging\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\n\nfloat hash(float a, float b) \n{\n    int x = FK(a), y = FK(b);\n    return float((x*x-y)*(y*y+x)-x)/2.14e9;\n}\n\nvec3 hash3(float a, float b) \n{\n    float s1 = hash(a, b);\n    float s2 = hash(s1, b);\n    float s3 = hash(s2, b);\n    return vec3(s1,s2,s3);\n}\n\n// niter must be 50, or it won't be scaled correctly FIXME - am working on it\nfloat lifogmultiscale(vec3 a, vec3 b, int niter)\n{\n    float fog = 0.\n    , prescale = 6. //1. //9. //1./9. //9. //\n \t, scale = 1.\n    , scalefactor = 1.06;\n    a *= prescale; b *= prescale; // massive HACK\n    vec3 oa = a, ob = b; // keep so each layer can be independent\n    // sum up multiple different versions of the fog\n    for (int i = 0; i < niter; ++i) {\n        // I tried some other stuff here, \n        // but blackle's works better so far.\n        // See Pyramid Field where I was working on it also.\n        // https://shadertoy.com/view/3ld3Dl\n        // N.B. tan is blackle's distribution-uniformizing trick,\n        // helps fixup the cubic distribution hash3 gives,\n        // back into something more spherically-distributed.\n        // random rotation\n        vec3 ax = normalize(tan(hash3(float(i), 14353.))); // axis\n        float ro = hash(float(i), 66123.)*10.; // angle, yet another hash\n        // TODO can't we just get a random length vector\n        // and use its direction and length?  Would be cheaper than another hash,\n        // and since we normalize anyway...\n        \n        // rotate both points into this layer's basis\n        // if not chained, each loop iteration can be\n        // done more independently and the compiler has\n        // more flexibility, less flow dependency issues.\n        // Just rotate each layer from the original coordinates!\n        a = erot(oa,ax,ro);\n        b = erot(ob,ax,ro);\n        // TODO I'm not 100% sure how it's scaling the fbm layers\n        // but in general it contributes less for finer scales.\n        fog += lineintegral(a*scale,b*scale) / sqrt(scale);\n       \tscale *= scalefactor;\n    }\n    fog /= prescale; // HACK HACK HACK\n    fog /= prescale;\n    fog /= float(niter);\n    fog /= float(niter);\n    //fog /= pow(scalefactor, float(niter)); // HACK try to fix it? TODO\n\t//fog /= 2500.; // mega HACK only works for niter == 50 apparently\n\treturn fog;\n}\n// if you wanted fog beams all parallel but with different scales,\n// would require a different method of randomly rotating each scale layer.\n// this seems only good for radially symmetric tiled fog.\n// but you could do a 2d field and skew the 3rd axis\n// to project the shafts into the scene how you like.\n\nfloat lifoguniscale(vec3 a, vec3 b)\n{\n    return lineintegral(a,b);\n}\n\nfloat scene(vec3 p) \n{\n    // tile space mirrored, the transcendental-heavy way isn't as slow as it seems\n    p = asin(sin(p+0.));\n\t// field of spheres\n    return length(p)-1.;\n}\n\nfloat march(inout vec3 p, vec3 cam, float tol, float maxd, int niter, out bool hit)\n{\n    //vec3 p = init;\n    hit = false;\n    float t = 0.;\n    for (int i = 0; i < niter && !hit; ++i) {\n        float dist = scene(p);\n        hit = dist*dist < tol*tol;\n        p += dist * cam;\n        t += dist;\n        if (t > maxd) break; //t = distance(p,init)\n    }\n    return t;\n}\n\nvoid mainImage(out vec4 o, vec2 q)\n{\n    vec2 R = iResolution.xy\n    , uv = (q-.5*R)/R.y\n    , mr = (iMouse.xy-.5*R)/R.y * vec2(2,-1) * pi;\n    if (iMouse.xy == vec2(0)) mr = vec2(0, .2);\n    // I changed blackle's camera to a coordinate system \n    // I'm more familiar with, having +Y up, w/ mouselook\n    float ct = iTime/5., st = iTime/15., wt = iTime/3.;\n    vec3 cam = normalize(vec3(uv,1))\n\t, init = vec3(.5,.5,.5)*pi;\n    init += .25*pi * vec3(-cos(ct), 0, sin(ct)); \n    //init.x += iTime/15.; // sin,cos spin? TODO\n     cam = erot(cam, vec3(1,0,0), .0 + mr.y);\n     cam = erot(cam, vec3(0,1,0), st + mr.x);\n\t// draw a field of black spheres in thick noisy white fog\n    vec3 p = init;\n    bool hit;\n    float maxd = 28.;\n    float t = march(p, cam, 1e-4, maxd, 256, hit);\n    vec3 wind = mod(wt, 1024.) * vec3(1,0,0) * 8. // wind can only discard so much precision at expense of an occasional pop\n    , a = init + wind\n    , b = p + wind;  // init + cam * t\n    float fog = lifoguniscale(a,b);\n    // I managed to botch the tuning on it so you can't see it rn anyway :(\n    // hopefully I'll get something worth looking at soon\n    //if (uv.x > 0.) //p.x > R.x/2.) \n    //    fog = lifogmultiscale(a*.02,b*.02,8) * 1024.; //lifoguniscale(a,b); //50); //lifoguniscaleB(a,b); //\n    // blackle just obtained the density\n    // and was using that directly as intensity, after scaling\n    // but I want proper fogging; doesn't seem to make much difference :(\n    // at this point I have so many HACK's in so many parts of the process\n    // that I don't feel I have any control over the results.\n    \n    // meh, I have no control over the contrast of the puffs,\n    // and about fed up messing w it for the day.\n    fog *= .08; // master density HACK\n    float g = 1.-exp2(-fog); // Beer's law\n    vec3 c = vec3(g);\n    c = sqrt(c); // cheap gamma output\n    // dither for 8 bits/ch using blue noise texture in iChannel0\n    c += .5/256. * (texelFetch(iChannel0, ivec2(q) % ivec2(iChannelResolution[0].xy), 0).x * 2. - 1.);\n    o = vec4(c, 1);\n}\n\n","name":"Image","description":"","type":"image"}]}