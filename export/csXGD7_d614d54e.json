{"ver":"0.1","info":{"id":"csXGD7","date":"1666200526","viewed":94,"name":"Erosion Lab CIS 566","username":"nmoon","description":"Cellular automata erosion demo for CIS 5660","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["automata","erosion"],"hasliked":0,"parentid":"cdl3W4","parentname":"Erosion Lab"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\nvec2 uv = fragCoord / iResolution.x;\n    if(iTime == 0.) {\n        float f_r = fbm(uv, 0.5, 8.0, 0.5, 8);\n        vec2 warp_r = NoiseVectorFBM(uv, 0.5, 8.0, 0.5, 8) * 0.6;\n        float w_r = WorleyNoise(uv * vec2(1., 6.) + warp_r);\n        \n        float f_g = fbm(uv + vec2(8,2), 0.5, 4.0, 0.5, 8);\n        vec2 warp_g = NoiseVectorFBM(uv + vec2(8,2), 0.5, 4.0, 0.5, 8) * 0.6;\n        float w_g = WorleyNoise(uv * vec2(8., 12.) + warp_g);\n        \n        \n        float f_b = fbm(uv + vec2(2,5), 0.5, 2.0, 0.5, 8);\n        vec2 warp_b = NoiseVectorFBM(uv + vec2(2,5), 0.5, 2.0, 0.5, 8) * 0.6;\n        float w_b = WorleyNoise(uv * vec2(2., 3.) + warp_b);\n        \n        \n        float h_r = gain(mix(w_r, f_r, 0.66), 0.4);\n        float h_g = gain(mix(w_g, f_g, 0.66), 0.4);\n        float h_b = gain(mix(w_b, f_b, 0.66), 0.4);\n        fragColor = vec4(h_r,h_g,h_b,1.);\n    }\n    else {\n        // Here's how to read a pixel from the input buffer. This gets us the cell stored in a single pixel\n        vec3 curr = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n        \n        // 1. Get the values from the neighboring cells\n        vec3 neighbors[9];\n        for (int yi = 0; yi < 3; ++yi) {\n            for (int xi = 0; xi < 3; ++xi) {\n                vec2 uv_neighbor = vec2(fragCoord.x + float(xi - 1), fragCoord.y + float(yi - 1)) / iResolution.xy;\n                neighbors[xi + yi * 3] = texture(iChannel0, uv_neighbor).rgb;\n            }\n        }\n        \n        // 2. Get change in slope b/t each of 8 neighbors\n        vec3 diffs[9];\n        for (int yi = 0; yi < 3; ++yi) {\n            for (int xi = 0; xi < 3; ++xi) {\n                diffs[xi + yi * 3] = neighbors[xi + yi * 3] - curr;\n            }\n        }\n        \n        // 3. For each negative slope, subtract height from\n        // curr proportional to diff. For each positive slope,\n        // add height to curr (represents neighbor losing\n        // height to us)\n        // To mimic erosion due to gravity, only do this when between\n        // certain thresholds. Here are some recommendations!\n        \n        #define THR_LOWER 0.0035\n        #define THR_UPPER 0.0085     \n        \n        for (int i = 0; i < 9; ++i) {\n            if (i != 4) {\n                vec3 diff_value = diffs[i];\n                if (abs(diff_value.r) > THR_LOWER && abs(diff_value.r) < THR_UPPER) {\n                    curr.r += diff_value.r * curr.r * EROSION_SCALAR;\n                }\n                if (abs(diff_value.g) > THR_LOWER && abs(diff_value.g) < THR_UPPER) {\n                    curr.g += diff_value.g * curr.g * EROSION_SCALAR;\n                }\n                if (abs(diff_value.b) > THR_LOWER && abs(diff_value.b) < THR_UPPER) {\n                    curr.b += diff_value.b * curr.b * EROSION_SCALAR;\n                }\n            }\n        }\n       \n        fragColor = vec4(curr, 1.);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define EROSION_SCALAR 0.05\n#define FBM_OCTAVES 8\n\nfloat bias(float t, float b) {\n    return (t / ((((1.0/b) - 2.0)*(1.0 - t))+1.0));\n}\n\nfloat gain(float time, float gain)\n{\n  if(time < 0.5)\n    return bias(time * 2.0,gain)/2.0;\n  else\n    return bias(time * 2.0 - 1.0,1.0 - gain)/2.0 + 0.5;\n}\n\nvec2 rotate(vec2 p, float deg) {\n    float rad = deg * 3.14159 / 180.0;\n    return vec2(cos(rad) * p.x - sin(rad) * p.y,\n                sin(rad) * p.x + cos(rad) * p.y);\n}\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat random1( vec2 p ) {\n    return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);\n}\n\nfloat mySmootherStep(float a, float b, float t) {\n    t = t*t*t*(t*(t*6.0 - 15.0) + 10.0);\n    return mix(a, b, t);\n}\n\n\nfloat bilerpNoise(vec2 uv) {\n    ivec2 uvFloor = ivec2(floor(uv));\n    vec2 uvFract = fract(uv);\n    float ll = random1(vec2(uvFloor));\n    float lr = random1(vec2(uvFloor + ivec2(1, 0)));\n    float ul = random1(vec2(uvFloor + ivec2(0, 1)));\n    float ur = random1(vec2(uvFloor + ivec2(1, 1)));\n\n    float lerpXL = mySmootherStep(ll, lr, uvFract.x);\n    float lerpXU = mySmootherStep(ul, ur, uvFract.x);\n\n    return mySmootherStep(lerpXL, lerpXU, uvFract.y);\n}\n\nfloat fbm(vec2 uv, float amp, float freq, float persistence, int octaves) {\n    float sum = 0.0;\n    for(int i = 0; i < octaves; i++) {\n        sum += bilerpNoise(uv * freq) * amp;\n        amp *= persistence;\n        freq *= 2.0;\n    }\n    return sum;\n}\n\nfloat WorleyNoise(vec2 uv) {\n    // Tile the space\n    vec2 uvInt = floor(uv);\n    vec2 uvFract = fract(uv);\n    float minDist = 1.0; // Minimum distance initialized to max.\n\n    // Search all neighboring cells and this cell for their point\n    for(int y = -1; y <= 1; y++) {\n        for(int x = -1; x <= 1; x++) {\n            vec2 neighbor = vec2(float(x), float(y));\n\n            // Random point inside current neighboring cell\n            vec2 point = random2(uvInt + neighbor);\n\n            // Compute the distance b/t the point and the fragment\n            // Store the min dist thus far\n            vec2 diff = neighbor + point - uvFract;\n            float dist = length(diff);\n            minDist = min(minDist, dist);\n        }\n    }\n    return minDist;\n}\n\nvec2 NoiseVectorFBM(vec2 uv, float amp, float freq, float persistence, int octaves) {\n    float x = fbm(uv, amp, freq, persistence, octaves) * 2.0 - 1.0;\n    float y = fbm(rotate(uv, 60.0), amp, freq, persistence, octaves) * 2.0 - 1.0;\n    return vec2(x, y);\n}","name":"Common","description":"","type":"common"}]}