{"ver":"0.1","info":{"id":"Ns23zt","date":"1617825043","viewed":77,"name":"Many Reflective Spheres","username":"Symmetries","description":"Simple iterative ray tracer","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define num 4\n#define epsilon 0.0000005\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float theta = cos(iTime / 4.);\n    mat3 rot = mat3(\n        cos(theta), -sin(theta), 0.,\n        sin(theta), cos(theta),  0.,\n        0.,          0.,           1.\n    );\n    \n    vec3 col = vec3(0.);\n    for (int i = -2; i <= 2; i++) {\n        for (int j = -2; j <= 2; j++) {\n            vec2 st = 2. * (fragCoord.xy + vec2(i, j)/5.)/iResolution.xy - 1.;\n            st.y *= iResolution.y / iResolution.x;\n            st *= 1.6;\n\n            vec3 ps[num] = vec3[](\n                vec3(0., 7., 2.),\n                vec3(-2., 3., 0.),\n                vec3(0., 4., -0.5),\n                vec3(2., 3., .5)\n            );\n            float rs[num] = float[](3., 1., 0.5, 1.5);\n            \n            vec3 w = rot * normalize(vec3(st.xy, 1.).xzy);\n            vec3 o = vec3(0.);\n\n            for (int iteration = 0; iteration < 8; iteration++) {\n                \n                float minT = -1.;\n                vec3 minP = ps[0];\n                float minR = -1.;\n                for (int i = 0; i < num; i++) {\n                    float b = -2. * dot(w, ps[i] - o);\n                    float dis = b * b - 4. * (dot(ps[i] - o, ps[i] - o) - rs[i] * rs[i]);\n                    \n                    float t = (-b - sqrt(abs(dis))) / 2.;\n                    float cond = float((t < minT || minT == -1.) && dis > 0. && t > 0.);\n                    \n                    minT += cond * (t - minT);\n                    minP += cond * (ps[i] - minP);\n                    minR += cond * (rs[i] - minR);\n                }\n                \n                o += float(minT > 0.) * (minP + normalize(o + minT * w - minP) * (minR + epsilon) - o);\n                w += float(minT > 0.) * (normalize(reflect(w, normalize(minP - o))) - w);\n            }\n            \n            float cond = float(w.z < 0.);\n            vec2 v = o.xy - (1. + o.z) * w.xy / w.z;\n            col += cond * mod(floor(v.x) + floor(v.y), 2.) * vec3(fract(v.xy), .5).xzy\n                + (1. - cond) * w.zzz;\n        }\n    }\n    \n    fragColor = vec4(col/25., 1.);\n}","name":"Image","description":"","type":"image"}]}