{"ver":"0.1","info":{"id":"fsffRf","date":"1645109766","viewed":122,"name":"FireworksNZ","username":"Wingrime","description":"testing fireworks","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["fireworks"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nfloat sdStar5(in vec2 p, in float r, in float rf)\n{\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0*max(dot(k1,p),0.0)*k1;\n    p -= 2.0*max(dot(k2,p),0.0)*k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n    float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n    return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n\nfloat sdCircle( in vec2 p, in float r ) \n{\n    return length(p)-r;\n}\nfloat rand(vec2 co){\n    // https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nvec3 lastExplosion(float time)\n{\n    // vec3(time since last explosion,\n    //      index of last explosion,\n    //      time until next explosion)\n    float t = mod(time, 10.);\n    float interval = floor(time/10.);\n    float t0max = 0., imax=-1.;\n    float t0next = 10.;\n    for(float i=0.; i<10.; i++)\n    {\n        float t0 = rand(vec2(interval, i)) * 10.;\n        if(t > t0 && t0 > t0max)\n        {\n            t0max = t0;\n            imax = i;\n        }\n        if(t < t0 && t0 < t0next)\n        {\n            t0next = t0;\n        }\n    }\n    return vec3(t-t0max, 10.*interval+imax, t0next-t);\n}\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\n\tfloat d = 0.0;\n        vec3 lastExpl = lastExplosion(iTime);\n    float t = lastExpl.x, explNum = lastExpl.y, tFadeout = lastExpl.z;\n    \n     // Number of particles\n    float N_LIGHTS = 40.;\n    for(float i=0.; i<N_LIGHTS; i++)\n    {\n            // (see Total Compendium eq. (34))\n        float f = i/N_LIGHTS;\n        float r = sqrt(1. - f*f);\n        float th = 2.*0.618033*3.14159*i; // Use Golden Ratio for a quasirandom sequence\n        float hash = sin(i*85412.243);\n        float weight = (1.-0.2*hash);\n        th += hash *3.* 6.28/N_LIGHTS;\n        // Only take x and y coordinates\n        vec2 lpos = vec2(cos(th), sin(th)) * r;\n        // Add some physics\n        lpos.xy *= (1.-exp(-3.*t/weight)) * weight; // explosion, easing out\n        lpos.y += t*0.3*weight - t*(1.-exp(-t*weight)) * 0.6 * weight; // vertical free-fall motion\n        float scale = 10.0-t*2.0;\n         d = min(d,sdStar5(rotate(scale*p-scale*lpos,sin(0.2*t)),0.5 ,0.5));\n        }\n    \n    vec3 col = (d<0.0) ? vec3(255/208,0.0,0.0) : vec3(0.65,0.85,1.0);\n    \n\t// coloring\n   // vec3 col = vec3(d);\n\n\n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}