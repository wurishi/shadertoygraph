{"ver":"0.1","info":{"id":"4dcSz2","date":"1460311477","viewed":222,"name":"Trinoisemarble-mainsequence","username":"Orihaus","description":"t","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["t"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Created by S. Guillitte 2015\n\nfloat zoom=1.;\n\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 csqr( vec2 a )  { return vec2( a.x*a.x - a.y*a.y, 2.0*a.x*a.y  ); }\n\nfloat smin( float a, float b )\n{\n    float k = 0.7;\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\n//\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\nfloat tri(in float x){return abs(fract(x)-.5);}\nvec2 tri2(in vec2 p){return vec2(tri(p.x+tri(p.y*2.)),tri(p.y+tri(p.x*2.)));}\nmat2 m2 = mat2( 0.970,  0.242, -0.242,  0.970 );\n\n//Animated triangle noise, cheap and pretty decent looking.\nfloat triangleNoise(in vec2 p)\n{\n    float z=1.5;\n    float z2=1.5;\n\tfloat rz = 0.;\n    vec2 bp = p;\n\tfor (float i=0.; i<=4.; i++ )\n\t{\n        vec2 dg = tri2(bp*2.)*.8;\n        dg *= mm2(iTime*.1);\n        p += dg/z2;\n\n        bp *= 1.6;\n        z2 *= .6;\n\t\tz *= 1.8;\n\t\tp *= 1.2;\n        p*= m2;\n        \n        rz+= (tri(p.x+tri(p.y)))/z;\n\t}\n\treturn rz;\n}\n\n//\n\nmat2 rot(float a) \n{\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sph )//from iq\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\t//if( h<0.0 ) return vec2(-1.0);\n\th = sqrt(h);\n\treturn vec2(-b-h, -b+h );\n}\n\nfloat map(in vec3 p) \n{\n\tfloat res = 0.;\n    float timeinput = sin( iTime * 0.1 )*0.01;\n    vec3 c = p;\n\t\n    \n\tfor (int i = 0; i <6 ; ++i) \n    {\n        float indexover = 1.0 + ( float( i ) / 8.0 );\n        p =(.41+timeinput)*abs(p)/dot(p,p) -(0.41 + timeinput);\n        p.yz= csqr(p.yz);\n        \n        //p = abs( 1.0 + dot(p,c) * 0.7 )/abs(p*0.7);\n        \n        //p += tri2( timeinput + abs( p.xz ) ).x;\n        \n        //p.xy = csqr(p.xy);\n        //p.yz = csqr(p.yz);\n        //p.zx /= csqr(p.zx);\n        //p=p.zxy;\n       \n        //p *= triangleNoise( timeinput + p.yx * 0.5 );\n        //p -= triangleNoise( p.zy * 0.5 ) * 1.0;\n\n        res = ( .9 * res) + exp(-20.0 * abs(dot(p,c))) * 0.15 * indexover;\n\t}\n\n\treturn res;\n}\n\n\n\nvec4 raymarch( in vec3 ro, vec3 rd, vec2 tminmax )\n{\n    float timeinput = sin( iTime * 1.1 );\n    \n    float t = 1.0 + tminmax.x * 0.875;\n    //float dt = .1;\n    float dt = .018;//animated\n    vec3 col= vec3(0.);\n    float c = 0.5; float c2 = 0.0;\n    /*for( int i=0; i<16; i++ )\n\t{\n        float indexover = float( i ) / 16.0;\n        indexover *= indexover;\n        t+=dt*exp(-12.0*c);\n        if(t>tminmax.y)break;\n        vec3 pos = ro+t*rd;\n        \n        c += map(pos);               \n        \n        //col = .99*col+ .08*vec3(c*c, c, c*c*c);//green\t\n        col = .75*col+ .75*vec3( c*c*c*c, c*c*c, c*c )*vec3(1.3, 2.0 * c, 1.25);//blue\n    }    */\n    for( int i=0; i<64; i++ )\n\t{\n        float indexover = float( i ) / 64.0;\n        indexover = pow( indexover, 0.875 );\n        t+=dt*exp((-4.0*indexover)*c) * 1.5;\n        if(t>tminmax.y)break;\n        vec3 pos = ro+t*rd;\n        \n        float imap = map(pos);\n        c = clamp( ( 0.93 * c ) + ( indexover * imap ) * 0.07, 0.0, 1.0 );\n        c2 =.99*c2+ .4*imap;\n       \n        col = .96*col+ .1*(2.5+0.15*pos*t)*vec3( c*c*c, c*c*c, c*c )*vec3(8. + indexover * 7.0, 7.0 - 4.0 * c, 1.75 + c * 4.0);//blue\n    }    \n    return vec4( col, c2 );\n}\n\n//\n\nvec3 srgb2lin( vec3 cs )\n{\n\tvec3 c_lo = cs / 12.92;\n\tvec3 c_hi = pow( (cs + 0.055) / 1.055, vec3(2.4) );\n\tvec3 s = step(vec3(0.04045), cs);\n\treturn mix( c_lo, c_hi, s );\n}\n\nvec3 lin2srgb( vec3 cl )\n{\n\t//cl = clamp( cl, 0.0, 1.0 );\n\tvec3 c_lo = 12.92 * cl;\n\tvec3 c_hi = 1.055 * pow(cl,vec3(0.41666)) - 0.055;\n\tvec3 s = step( vec3(0.0031308), cl);\n\treturn mix( c_lo, c_hi, s );\n}\n\n//\n\nfloat EnvBRDFApproxNonmetal( float Roughness, float NoV )\n{\n    const vec2 c0 = vec2( -1.0, -0.0275 );\n    const vec2 c1 = vec2(  1.0,  0.0425 );\n    vec2 r = Roughness * c0 + c1;\n    return min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n}\n\n//\n\nvec3 fisheye_lookup(float fov, vec2 position)\n{\n\tvec2 d = position;\n\t\n\tfloat yaw = sqrt(d.x*d.x+d.y*d.y) * fov;\n\n\tfloat roll = -atan(d.y, d.x);\n\tfloat sx = sin(yaw) * cos(roll);\n\tfloat sy = sin(yaw) * sin(roll);\n\tfloat sz = sin(yaw);\t\n\n\treturn vec3(sx, sy, sz);\n}\n\n//\n\nfloat MAT_triplanarScratches(vec3 p, vec3 n)\n{\n    //Idea from http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\n    //Figure 1-23 Triplanar Texturing\n    float fTotal = abs(n.x)+abs(n.y)+abs(n.z);\n    return ( abs(n.x)*triangleNoise(p.zy*0.3)\n            +abs(n.y)*triangleNoise(p.xz*0.3)\n            +abs(n.z)*triangleNoise(p.xy*0.3))/fTotal;\n}\n\n//\n\nvec3 ACESFilm( vec3 x ) {\n\tfloat a = 2.51;\n\tfloat b = 0.03;\n\tfloat c = 2.43;\n\tfloat d = 0.59;\n\tfloat e = 0.14;\n\treturn clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.0, 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = iTime;\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 m = vec2(0.);\n\tif( iMouse.z>0.0 )m = iMouse.xy/iResolution.xy*3.14;\n    m-=.5;\n    vec3 fp = fisheye_lookup( 4.2 + sin( time ) * 0.025, p );\n   //p = fp.xy;\n\n    // camera\n    vec3 ro = zoom*vec3(4.0);\n    ro.yz*=rot(m.y);\n    ro.xz*=rot(m.x+ 0.1*time);\n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 4.0*ww );\n    vec3 rdfp = normalize( fp.x*uu + fp.y*vv + 4.0*ww );\n    \n    vec2 tmm = iSphere( ro, rd, vec4(0.,0.,0.,2.1) );\n    vec2 tmmfp = iSphere( ro, rdfp, vec4(0.,0.,0.,2.1) );\n    vec2 tmmp = iSphere( ro, rd, vec4(0.,0.,0.,1.245) );\n    \n\n\t// raymarch\n    vec4 icol = raymarch(ro,rd,tmmfp);\n    vec4 icolfp = raymarch(ro,rdfp,tmmfp);\n    vec3 col = icol.xyz * 4.0; float acol = icol.w;\n  float noise = 0.0;\n    \n    if (tmm.x<-0.)\n        col = vec3( 0.0 );\n    else \n    {\n        vec3 cnor = (ro+tmm.x*rd);\n        vec3 cnorp = (ro+tmmp.x*rd);\n        vec3 nor=cnor/2.5;\n        nor = reflect(rd, nor);     \n        \n        vec3 nor2=cnor/3.0;\n        nor2 = reflect(rd, nor2);     \n        \n        vec3 norp=cnorp/2.8;\n        norp = reflect(rd, norp); \n        \n        float frep = clamp( dot( norp, rd ), 0.0, 1.0 ); \n\t\tnoise = clamp( 0.3 + pow( MAT_triplanarScratches( cnorp - iTime * 0.03, cnorp ), 1.3 ) * 10.0, 0.0, 1.0 );\n        \n        col *= mix( 1.0, noise, frep * frep* frep);\n        //icolfp *= 0.5 + noise * 1.5;\n        \n        //\n        \n        float fre = abs( dot( nor, rd ) );\n        float fre2 = clamp( dot( nor2, rd ), 0.0, 1.0 );   \n        \n        float eclipse = pow( clamp( dot( nor2, rd ) + 2.0, 0.0, 1.0 ), 1.5 );\n        \n        //\n        \n        vec3 diffuse = vec3( clamp( dot( norp, normalize( vec3( -1.0, 1.3, 1.0 ) ) ), 0.0, 1.0 ) )  * 0.2 * (0.9 + rd * 0.3 );\n        diffuse       += vec3( clamp( dot( norp, normalize( vec3(  1.0, -0.3, -0.7 ) ) ), 0.0, 1.0 ) ) * 0.15 * ( 1.3 - rd * 0.3 );\n        diffuse       += vec3( clamp( dot( norp, normalize( vec3(  0.0, -0.0, -1.0 ) ) ), 0.0, 1.0 ) ) * 0.1 * ( 0.9 + rd * 0.3 );\n        \n        \n        float fade = pow( 1.0 - fre2, 1.7 );\n        vec3 storedcol = fade * vec3( clamp( smin( smin( smin( acol, col.z ), col.y ), col.x ), 0.0, 8.0 ) );// * vec3(2.8 - tmm.x * 0.125, 4.0, 2.5 + tmm.x * 1.5);\n        col += clamp( diffuse * (1.0-0.7*tmm.x*noise), 0.0, 1.0 );// * vec3(1.1 - tmm.x * 0.125, 0.5, 0.5 + tmm.x * 0.5);\n        col *= vec3( pow( ( 1.0 - fre * fre ) + pow( fre, 4.0 ), 5.0 ) );\n        \n        col += clamp( icolfp.xyz * pow( fre2, 3.0 ), 0.0, 4.0 ) * 256.0 * clamp( pow( 1.0 + fp.z, 4.0 ), 0.0, 1.2 );\n        col *= fade * eclipse;\n        \n        col = .3 *(log(1.0+col));\n        col += 1.3 *(log(1.0+(storedcol * eclipse * 0.04)));\n        col *= clamp( pow( 1.0 + fp.z, 0.5 ), 0.0, 1.0 );\n    }\n\t\n\t// shade\n    //col = clamp(col,0.,1.);\n    fragColor = vec4( lin2srgb( pow( ACESFilm( vec3( col ) ), vec3( 1.5 ) ) * 1.3 ), 1.0 );\n\n}\n","name":"Image","description":"","type":"image"}]}