{"ver":"0.1","info":{"id":"XXtSz8","date":"1718877668","viewed":48,"name":"TAU LOGO RAVE","username":"_TAU_","description":"Experimenting with basic ray marching. \nI am trying to give it a \"cartooney\" feel by clipping the colors, but the look of it it's not that great... any ideas ?\n\n","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["enginedemo"],"hasliked":0,"parentid":"XX3XzH","parentname":"TAU LOGO Basic"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float FOV =  6.0;\nconst int MAX_STEPS = 256;\nconst float MAX_DIST = 250.0;\nconst float EPSILON = 0.008;\n\nconst float DIST = 11.0;\nconst float SPIRAL_TILT = 0.015; // very sensitive ! \nconst float SINE_MOV_SPEED = 5.;\nconst float SINE_MOV_AMP = .8;\nconst float LOGO_THICKNESS = 0.5;\n\nvec2 fOpUnion(vec2 res1, vec2 res2){\n    return (res1.x < res2.x) ? res1 : res2;\n}\n\nvec2 fOpDifferenceID(vec2 res1, vec2 res2) {\n    return (res1.x > -res2.x) ? res1 : vec2(-res2.x, res2.y);\n}\n\nvec2 fTauLogo(vec3 p, float thickness){\n    \n    float tauID = 1.0;\n    \n    // BoxA\n    float size = 1.;\n    // rotate box\n    vec3 boxA_center = p - vec3(0., 0.5, 0.);\n    pR(boxA_center.xy, deg2rad(45.));\n    // usual box SDF\n    float boxADist = fBox(boxA_center, vec3(size, size, thickness));\n    float boxAID = tauID;\n    vec2 boxA = vec2(boxADist, boxAID);\n    \n    // Tetra\n    // rotate box\n    vec3 tetra_Center = p - vec3(0., 1.7, 0.);\n    pR(tetra_Center.xy, deg2rad(180.));\n    // usual box SDF\n    float tetraDist = fTriPrism(tetra_Center, vec2(1.,1.));\n    float tetraID = tauID;\n    vec2 tetra = vec2(tetraDist, tetraID);\n    \n    // InletA\n    // rotate box\n    vec3 InletA_center = p - vec3(0.8, 0.7, 0.);\n    pR(InletA_center.xy, deg2rad(-45.));\n    // usual box SDF\n    float InletADist = fBox(InletA_center, vec3(0.03, 1.2, thickness + 0.01));\n    float InletAID = tauID;\n    vec2 InletA = vec2(InletADist, InletAID);\n    \n    // InletB\n    // rotate box\n    vec3 InletB_center = p - vec3(-0.75, 0.25, 0.);\n    pR(InletB_center.xy, deg2rad(-45.));\n    // usual box SDF\n    float InletBDist = fBox(InletB_center, vec3(0.03, 0.3, thickness + 0.01));\n    float InletBID = tauID;\n    vec2 InletB = vec2(InletBDist, InletBID);\n    \n    // InletC\n    // rotate box\n    vec3 InletC_center = p - vec3(-0.18, 0.02, 0.);\n    pR(InletC_center.xy, deg2rad(45.));\n    // usual box SDF\n    float InletCDist = fBox(InletC_center, vec3(0.03, 0.22, thickness + 0.01));\n    float InletCID = tauID;\n    vec2 InletC = vec2(InletCDist, InletCID);\n    \n    // Result\n    vec2 res;\n    res = fOpDifferenceID(boxA, InletA);\n    res = fOpDifferenceID(res, InletB);\n    res = fOpDifferenceID(res, InletC);\n    res= fOpDifferenceID(res, tetra);\n    return res;\n}\n\nvec2 map(vec3 p){\n\nvec3 p_TAU = p;\n    \np_TAU.x += DIST/2.;  \n\n// spiral movements\npR(p_TAU.xy, SPIRAL_TILT * p_TAU.z * sin(iTime / 8.));\n\n// wiggle ray   \np_TAU.z += iTime * 20.; // Forward movement\np.y += sin(iTime* 2.5)*.55;\n\n// translation\np_TAU += vec3(0., SINE_MOV_AMP* cos(SINE_MOV_SPEED* iTime + 0.1 * p_TAU.z), 0.);\n\n// repeat logo\nvec3 c = floor((p_TAU + DIST*0.5)/DIST);\np_TAU = mod(p_TAU + DIST*0.5, DIST) - DIST*0.5;\n\n// rotate logo\npR(p_TAU.xz, deg2rad(70. * iTime));\n\n// draw logo\nvec2 tauLogo = fTauLogo(p_TAU, LOGO_THICKNESS);\n\n// result\nreturn tauLogo;\n    \n}\n\nvec2 rayMarch(vec3 ro, vec3 rd){\n// the rayMarch function returns a 2-dimensiona vector object in order to store\n// the distance to the object in the X component, and get the object ID ( it's color) \n// in the Y component\n    vec2 hit, object;\n    for(int i = 0; i < MAX_STEPS; i++){\n        // march the ray p ...\n        vec3 p = ro + object.x * rd;\n        // and compute distance from the objects\n        hit = map(p);\n        // update distance from the objects and ID\n        object.x += hit.x;\n        object.y = hit.y;\n        // stop is object is hit ( really small distance ) or ray has travelled to far away\n        if(abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }\n    return object;\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(EPSILON, 0.0);\n    vec3 n = vec3(map(p).x) - vec3(map(p - e.xyy).x, map(p - e.yxy).x, map(p - e.yyx).x);\n    return normalize(n);\n}\n\nvec3 getLight(vec3 p, vec3 rd, vec3 color){\n// Lighting model based on the Lambert Law: \n// amount of reflected light is proportional to the scalar product of the vector\n// directed to the light source and the normal to the surface\n    vec3 lightPos = vec3(20., 40., -15.);\n    vec3 L = normalize(lightPos - p); // vector from surface element directed to the light source\n    vec3 N = getNormal(p);  \n    \n    // return N; //check normals\n    // compute the Lambert Law\n    vec3 diffuse = color * clamp(dot(L, N), 0.0, 1.0);\n    \n    // shadows\n    float d = rayMarch(p + N * 0.02, normalize(lightPos)).x; // cast ray from surface point p towards the light and get distance\n    // if the distance travelled from p to the ligth is lower that the distance from the point to the light, it means we've hit an object\n    // which is obstructing the light, so we cast a shadow for point p\n    if (d < length(lightPos - p)) return vec3(0.);\n    \n    //3 components of the Phong lighitng model\n    return diffuse ; \n}\n\n\nvec3 getMaterial(vec3 p, float id) {\n// Gives the color based on the ID of the hit object\n    vec3 m;\n    switch (int(id)) {\n        case 1:\n        m = vec3(1.0, 1.0, 1.0); break;\n    }\n    return m;\n}\n\nvoid render(inout vec3 col, in vec2 uv){\n    // sets ray origin\n    vec3 ro = vec3(0.0, 0.2, -2.3);\n    // sets ray directionS -> points towards xy plane \n    vec3 rd = normalize(vec3(uv, (1. + 0.75 * sin(iTime / 2.))*FOV));\n    \n    vec2 object = rayMarch(ro, rd);\n    \n    vec3 background = vec3(1.);//vec3(0.5, 0.8, 0.9);\n    \n    if(object.x < MAX_DIST){\n    \n        if(object.x > MAX_DIST * 0.5 && FOV > 5.){\n            col= vec3(1.);\n        }else{\n            vec3 p = ro + object.x * rd;\n\n            vec3 material = getMaterial(p, object.y);\n            col += getLight(p, rd, material);\n            float blur = .00001;\n            float base = .002;\n            col = smoothstep(base-blur,base+blur,col);    \n        }\n            \n    }else{\n        col += vec3(0., 0., 0.);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (x,y in (-1,1))\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) /iResolution.y;\n\n    vec3 col;\n    \n    //AA setting\n    int aa_factor = 3;\n    \n    // Supersampling - nxn grid within each pixel\n    for(int x = 0; x < aa_factor; x++) {\n        for(int y = 0; y < aa_factor; y++) {\n            // Offset for each sample - shifts within the pixel grid\n            vec2 offset = vec2(x, y) * (1. / float(aa_factor)) / iResolution.y;\n            // Adjusted UV for current sample\n            vec2 sampleUV = uv + offset;\n            // Render scene for this sample\n            vec3 sampleColor;\n            render(sampleColor, sampleUV);\n            col += sampleColor;\n        }\n    }\n\n    // Average the color from the samples\n    col /= float(aa_factor * aa_factor);\n    \n    // gamma correction -- needed to adjust the lighting (make all brighter)\n    col = pow(col, vec3(0.4545));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265\n\n\nfloat deg2rad(float degrees) {\n    return degrees * (PI / 180.0f);\n}\n\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\n\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n\treturn dot(p, n) + distanceFromOrigin;\n}\n\nfloat fTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.5+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n","name":"Common","description":"","type":"common"}]}