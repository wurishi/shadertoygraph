{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n\n\n\n//------------------ ------------------------------------------\n// Triplex operations\n\n\n//http://www.bugman123.com/Hypercomplex/index.html#Mandelbulb2\n\n\n\nvec3 tsqr(vec3 p) \n{\n\tif(p.x==0. && p.y==0.)return vec3(-p.z*p.z,0.,0.);\n\tfloat a=1.-p.z*p.z/dot(p.xy,p.xy);\n\treturn vec3((p.x*p.x-p.y*p.y)*a ,2.*p.x*p.y*a,2.*p.z*length(p.xy));\n}\n\nvec3 tinv(vec3 p) \n{\n\treturn vec3(p.x,-p.yz)/dot(p,p);\n}\n\nvec3 tconj(vec3 p) \n{\n\treturn vec3(p.x,-p.yz);\n}\n\n\nvec3 tmul(vec3 a, vec3 b) \n{\n\tfloat r1 = length(a.xy);\n\tfloat r2 =length(b.xy);\n\tif(r1==0. || r2==0.)return vec3(-a.z*b.z,0.,0.);\n\tfloat k=1.-a.z*b.z/(r1*r2);\n\treturn vec3((a.x*b.x-a.y*b.y)*k ,(a.x*b.y+b.x*a.y)*k,a.z*r2+b.z*r1);\n}\n\nvec3 tdiv(vec3 a, vec3 b) \n{\n\tfloat r1 = length(a.xy);\n\tfloat r2 =length(b.xy);\n\tif(r1==0. || r2==0.)return vec3(a.z*b.z,0.,0.)/dot(b,b);\n\tfloat k=1.+a.z*b.z/(r1*r2);\n\treturn vec3((a.x*b.x+a.y*b.y)*k ,(-a.x*b.y+b.x*a.y)*k,a.z*r2-b.z*r1)/dot(b,b);\n}\n\n\n\nvec3 tpow(vec3 a, float power) \n{\n\tfloat r = length(a)+1e-10;\n\tfloat phi = atan(a.y,a.x)  ;// azimuth\n\tfloat theta = asin(a.z/r);//asin(-a.z/r);\n\tr=pow(r,power);\n\tphi = power*phi;\n\ttheta = power*theta;\n\treturn vec3(\n    \tr*cos(theta)*cos(phi),\n    \tr*cos(theta)*sin(phi),\n    \tr*sin(theta)\n    );\n\n}\n\nvec3 tcube(vec3 p){\n        float x = p.x; float x2 = x*x; \n        float y = p.y; float y2 = y*y; \n        float z = p.z; float z2 = z*z; \n\n        float r = x2 + y2;\n        float a = 1.-3.*z2/r;\n        \nreturn vec3(\n        x*(x2-3.*y2)*a,\n        y*(3.*x2-y2)*a,\n        (3.*r-z2)*z\n);\n}\n\nvec3 tpow8(vec3 p){\n        float x = p.x; float x2 = x*x; float x4 = x2*x2;\n        float y = p.y; float y2 = y*y; float y4 = y2*y2;\n        float z = p.z; float z2 = z*z; float z4 = z2*z2;\n\n        float k3 = x2 + z2;\n        float k2 = 1./sqrt( k3*k3*k3*k3*k3*k3*k3 );\n        float k1 = x4 + y4 + z4 - 6.0*y2*z2 - 6.0*x2*y2 + 2.0*z2*x2;\n        float k4 = x2 - y2 + z2;\n\t\treturn vec3(\n        64.0*x*y*z*(x2-z2)*k4*(x4-6.0*x2*z2+z4)*k1*k2,\n        -16.0*y2*k3*k4*k4 + k1*k1,\n        -8.0*y*k4*(x4*x4 - 28.0*x4*x2*z2 + 70.0*x4*z4 - 28.0*x2*z2*z4 + z4*z4)*k1*k2\n);\n\n}\n\nvec3 talt(vec3 z){return vec3(z.xy,-z.z);}\n//----------------------------------------------------------------------\n\n\n\nmat2 rot(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\nfloat zoom;\nvec3 dz = vec3(0.);\nvec3 c = vec3(-0.9,1.1,0.95);//+sin(0.1*iTime);\n\nvec3 f(vec3 z,vec3 c){\n\n\n//return sin(tinv(z))+c;\n//return tinv(sin(z))+c;\n//return tinv(sin(z))+0.22;\n//return tinv(z-z*z*z/6.)+c;\n//return tinv(z-tpow(z,3.)/6.+tpow(z,5.)/120.)+c;\n//return tinv(z-tcube(z)/6.)+c;\n//return tinv(tsqr(z)+c)+ z-c;//with g=0.1\n//return tinv(tsqr(z))+(c);\n//return tsqr(tinv(z+c))+ z-c;\n//return tinv(z)+(z)-0.5*talt(c);\n//return tinv(tmul(z,c))+c;\n//return tdiv(talt(z),tsqr(talt(z))+c);\n\treturn tdiv(z,tsqr(z)+c);       \n\n}\n\nvec3 map( vec3 p, vec3 rd )\n{\n    float eps=1e-4;\n    float bailout = 1e5;\n    float invbail=1./bailout;\n    c=p;\n    vec3 z = p;\n    vec3 z1 = p+eps*rd;\n    vec3 c1 = z1;\n    vec3 pz = vec3( 0.0 );\n    float dz2 = 0.0;\n    vec2  t = vec2( 1e10 );   \n    \t\t\n    float d;\n    \n\tfor( int i=0; i<10; i++ ) \n\t{\n            pz=z;\n\t\t\n            // formula\n\t\t\t\n            z=f(z,c);\n            z1=f(z1,c1); \n    \n            // stop under divergence or convergence\t\n            dz= (z-pz);\n            dz2 = dot(dz, dz);\n            d = dot(z,z);\t\n            if( dz2<invbail||dz2>bailout) break;\t\t\t\t \n\n            // orbit trapping ( |dz|Â² and z_x*z_y  )\n            t = min( t, vec2( d, abs(z.x*z.y) ));\n\t}\n\n        z1-=z;  //delta z\n        z1/=eps; //derivative along rd\n        d=0.25*(sqrt(d/dot(z1,z1))*log(d));\n\n\treturn vec3( d, t );\n}\n\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n    float maxd = 10.0;\n    float eps = 0.0000001;\n    float g = .3;\n    float t = 0.1;\n    vec3 z;\n    vec3 pz;\n    float dt = 0.5;\n\n    float d = 0.0;\n    float m = 1.0;\n    for( int i=0; i<150; i++ )\n\t{\n        if( dt<eps||t>maxd ) break;\n\n        t += g*dt;\n\n\tvec3 res = map(z=ro+rd*t, rd );\n        dt=abs(res.x);      \n\td = res.y;\n\tm = res.z;\n    }\n\n\n    if( t>maxd ||dt>0.1) return sin(vec3(3.0,1.5,2.0)+1.2*rd+0.);\n\tvec3  ref = reflect( rd, normalize(dz) );\n\treturn sin(vec3(3.0,1.5,2.0)+1.2*ref+m)*(1.-d);\n    \n}\n\n\n\n\nvec3 calcPixel( in vec2 pi, in float time )\n{\n\tvec2 q = pi / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q; \n    p.x *= iResolution.x/iResolution.y;\n    vec2 m = vec2(0.5);\n\tm = iMouse.xy/iResolution.xy*3.14;\n\n    // camera\n\n\t\n\n    vec3 ro = zoom*tconj(vec3(-3.));\n    ro.yz*=rot(m.y);\n    ro.xz*=rot(m.x+ 0.1*time);\n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 4.0*ww );\n\n\t// raymarch\n    return intersect(ro,rd);\n\t\n\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tzoom=.7+.5*sin(.2*iTime);\n    fragColor = vec4( calcPixel( fragCoord.xy, iTime ), 1.0 );\n\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4sB3DW","date":"1388184880","viewed":242,"name":"Triplex","username":"guil","description":"Test with triplex \"numbers\" used in mandelbulb. You may try alternate formulas by uncommenting lines from 117 to 128. The algorithm doesn't work with diverging formulas like standard mandelbulb with glsl es for unknown reasons (it works with glsl). ","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","fractal","triplex"],"hasliked":0,"parentid":"","parentname":""}}