{"ver":"0.1","info":{"id":"4c3yWN","date":"1730624109","viewed":40,"name":"Dynamic Geometric Trio I","username":"Secretstar","description":"A dynamic 3D shader featuring rotating geometric shapes—torus, cone, and cylinder—with smooth transitions and vibrant colors, creating a harmonious, animated visual effect.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["proceduralgraphics","smoothblending","3dgeometry","rotatingshapes","torusconecylinder","dynamicanimation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Funzioni di distanza per le nuove forme 3D\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat sdCone(vec3 p, vec3 c) {\n    // c.x = cos(angle), c.y = sin(angle), c.z = height\n    float q = length(p.xy);\n    return max(dot(c.xy, vec2(q, p.z)), -p.z) - c.z;\n}\n\nfloat sdCylinder(vec3 p, vec2 h) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// Funzione per ruotare un punto nello spazio 3D\nvec3 rotate(vec3 p, vec3 angles) {\n    float cx = cos(angles.x); float sx = sin(angles.x);\n    float cy = cos(angles.y); float sy = sin(angles.y);\n    float cz = cos(angles.z); float sz = sin(angles.z);\n\n    mat3 rx = mat3(1.0, 0.0, 0.0,\n                   0.0, cx, -sx,\n                   0.0, sx, cx);\n\n    mat3 ry = mat3(cy, 0.0, sy,\n                   0.0, 1.0, 0.0,\n                   -sy, 0.0, cy);\n\n    mat3 rz = mat3(cz, -sz, 0.0,\n                   sz, cz, 0.0,\n                   0.0, 0.0, 1.0);\n\n    return rz * ry * rx * p;\n}\n\n// Funzione per unire le forme con smooth union\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(b - a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n// Funzione principale di distanza che combina tutte le forme\nfloat map(vec3 p) {\n    float t = iTime;\n\n    // Toro rotante\n    vec3 torusPos = p - vec3(2.0 * sin(t), 0.0, 0.0);\n    torusPos = rotate(torusPos, vec3(t * 0.5, t * 0.3, 0.0));\n    float torus = sdTorus(torusPos, vec2(1.0, 0.3));\n\n    // Cono rotante\n    vec3 conePos = p - vec3(-2.0 * sin(t), 0.0, 0.0);\n    conePos = rotate(conePos, vec3(t * 0.4, t * 0.6, t * 0.2));\n    float cone = sdCone(conePos, vec3(cos(radians(30.0)), sin(radians(30.0)), 1.0));\n\n    // Cilindro al centro\n    vec3 cylPos = p - vec3(0.0, 2.0 * sin(t * 0.5), 0.0);\n    cylPos = rotate(cylPos, vec3(t * 0.3, t * 0.4, t * 0.5));\n    float cylinder = sdCylinder(cylPos, vec2(0.5, 1.0));\n\n    // Combina le forme con smooth union\n    float d = smin(torus, cone, 0.5);\n    d = smin(d, cylinder, 0.5);\n\n    return d;\n}\n\n// Calcola la normale alla superficie\nvec3 calcNormal(vec3 p) {\n    const float eps = 0.001;\n    vec2 h = vec2(eps, 0.0);\n    return normalize(vec3(\n        map(p + h.xyy) - map(p - h.xyy),\n        map(p + h.yxy) - map(p - h.yxy),\n        map(p + h.yyx) - map(p - h.yyx)\n    ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    // Setup della camera\n    vec3 ro = vec3(0.0, 0.0, -6.0); // Posizione camera\n    vec3 rd = normalize(vec3(uv, 1.5)); // Direzione ray\n\n    // Ray marching\n    float t = 0.0;\n    float d = 0.0;\n    vec3 p;\n\n    for(int i = 0; i < 100; i++) {\n        p = ro + rd * t;\n        d = map(p);\n        if(d < 0.001 || t > 20.0) break;\n        t += d;\n    }\n\n    // Coloring\n    vec3 color = vec3(0.0, 0.0, 0.0); // Colore di sfondo\n\n    if(d < 0.001) {\n        // Calcola normale e lighting\n        vec3 normal = calcNormal(p);\n\n        // Lighting base\n        vec3 lightPos = vec3(2.0 * sin(iTime), 4.0, -3.0);\n        vec3 lightDir = normalize(lightPos - p);\n\n        // Diffuse lighting\n        float diff = max(dot(normal, lightDir), 0.0);\n\n        // Specular lighting\n        vec3 viewDir = normalize(ro - p);\n        vec3 reflectDir = reflect(-lightDir, normal);\n        float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);\n\n        // Colori differenti per le forme\n        vec3 torusColor = vec3(1.0, 0.5, 0.0); // Arancione\n        vec3 coneColor = vec3(0.0, 0.5, 1.0); // Azzurro\n        vec3 cylinderColor = vec3(0.5, 1.0, 0.0); // Verde\n\n        // Determina quale forma è più vicina\n        float torusD = sdTorus(p - vec3(2.0 * sin(t), 0.0, 0.0), vec2(1.0, 0.3));\n        float coneD = sdCone(p - vec3(-2.0 * sin(t), 0.0, 0.0), vec3(cos(radians(30.0)), sin(radians(30.0)), 1.0));\n        float cylinderD = sdCylinder(p - vec3(0.0, 2.0 * sin(t * 0.5), 0.0), vec2(0.5, 1.0));\n\n        vec3 baseColor;\n        if(torusD < coneD && torusD < cylinderD) {\n            baseColor = torusColor;\n        } else if(coneD < cylinderD) {\n            baseColor = coneColor;\n        } else {\n            baseColor = cylinderColor;\n        }\n\n        // Combine all lighting\n        color = baseColor * (diff * vec3(0.8) + spec * vec3(0.5));\n\n        // Aggiunge ambient occlusion\n        float ao = 1.0 - float(t) / 20.0;\n        color *= ao;\n    }\n\n    // Gamma correction\n    color = pow(color, vec3(0.4545));\n\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}