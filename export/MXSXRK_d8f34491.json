{"ver":"0.1","info":{"id":"MXSXRK","date":"1710788046","viewed":105,"name":"Raymarching rotating cubes","username":"koboko34","description":"Raymarching cubes","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat2 rot2D(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\nvec3 palette(in float t)\n{\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 0.0);\n    vec3 d = vec3(0.50, 0.20, 0.25);\n    \n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min(a,b) - h*h*h*k*(1.0/6.0);\n}\n\nfloat map(vec3 p)\n{\n    // vec3 spherePos = vec3(sin(iTime) * 3., 0., 0.); // sphere position\n    // float sphere = sdSphere(p - spherePos, 0.); // sphere SDF, translated (translated by negative spherePos because we are essentially moving the ray origin to the left)\n    \n    vec3 q = p; // position to be used by each instance of the shape\n    \n    q.y -= iTime * 0.6;\n    \n    q = fract(q) - .5;\n    q.xy *= rot2D(iTime); // uses 2x2 matrix but can stack concat multiple rotations\n    q.xz *= rot2D(iTime); // swizzle vec3 to exclude the axis of rotation\n    \n    float negativeSphere = sdSphere(q, 0.16);  // sphere to be subtracted from the cube\n    float box = sdBox(q * 4., vec3(0.5)) / 4.; // just as before, scaling is applied inversely.\n                                               // the resulting float is scaled by inverse to\n                                               // maintain correct SDF\n    \n    float ground = p.y + .75; // ground plane\n    \n    return smin(ground, max(-negativeSphere, box), 0.9); // objects are combined using min(d1, d2), subtracted using max(-d1, d2)\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n    vec2 m = (iMouse.xy * 2. - iResolution.xy) / iResolution.y;\n    \n    // initialisation\n    vec3 ro = vec3(0., 0., -3.); // ray origin\n    vec3 rd = normalize(vec3(uv, 1.)); // ray direction (normalised)\n    vec3 col = vec3(0.);\n    \n    float t = 0.; // total distance travelled\n    \n    /*\n    // mouse control (vertical)\n    ro.yz *= rot2D(-m.y);\n    rd.yz *= rot2D(-m.y);\n    \n    // mouse control (horizontal)\n    ro.xz *= rot2D(-m.x);\n    rd.xz *= rot2D(-m.x);\n    */\n    \n    // raymarching\n    int i;\n    for (i = 0; i < 80; i++)\n    {\n        vec3 p = ro + rd * t;\n        \n        float d = map(p);\n        t += d;\n        \n        if (d < .001 || t > 100.)\n            break;\n    }\n    \n    col = palette(t * 0.05 + float(i) * .003);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}