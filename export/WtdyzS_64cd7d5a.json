{"ver":"0.1","info":{"id":"WtdyzS","date":"1609790128","viewed":300,"name":"Smooth contours","username":"Vectornaut","description":"Draw an antialiased contour plot using automatic differentiation. This method works well when the contour stripes are many pixels wide.","likes":28,"published":1,"flags":0,"usePreview":0,"tags":["antialiasing","analytical","autodiff","automaticdifferentiation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// draw an antialiased contour plot using automatic differentiation. this method\n// works well when the contour stripes are many pixels wide. at each pixel, we\n// use the linearized pattern function to estimate the distance to the nearest\n// stripe edge. then we mix the colors on the near and far sides of the edge by\n// area samping with a gaussian weight. for more on area sampling, see\n//\n//   Andries van Dam. \"Image Processing & Antialiasing, Part II\"\n//   https://www.slideserve.com/shannon-dominguez/image-processing-antialiasing\n\n// --- automatic differentiation ---\n\n// a 1-jet of a map R^2 --> R^2, with image point `pt` and derivative `push`\nstruct jet2 {\n    vec2 pt;\n    mat2 push;\n};\n\njet2 add(jet2 f, jet2 g) {\n    return jet2(f.pt + g.pt, f.push + g.push);\n}\n\njet2 apply(mat2 a, jet2 f) {\n    return jet2(a*f.pt, a*f.push);\n}\n\njet2 wave(jet2 f) {\n    return jet2(sin(f.pt), mat2(cos(f.pt.x), 0., 0., cos(f.pt.y)) * f.push);\n}\n\n// a 1-jet of a map R^2 --> R, with image point `pt` and derivative `push`\nstruct jet21 {\n    float pt;\n    vec2 push;\n};\n\njet21 proj_y(jet2 f) {\n    return jet21(f.pt.y, vec2(f.push[0].y, f.push[1].y));\n}\n\njet21 dmod(jet21 t, float period) {\n    return jet21(mod(t.pt, period), t.push);\n}\n\n// --- approximate error function ---\n\nconst float A1 = 0.278393;\nconst float A2 = 0.230389;\nconst float A3 = 0.000972;\nconst float A4 = 0.078108;\n\n// Abramowitz and Stegun, equation 7.1.27\nfloat erfc_appx(float t) {\n  float p = 1. + A1*(t + A2*(t + A3*(t + A4*t)));\n  float p_sq = p*p;\n  return 1. / (p_sq*p_sq);\n}\n\n// --- antialiased stripe pattern ---\n\nconst int N = 4;\n\nvec3 stripe(jet2 f, float r_px) {\n    // set up stripe colors\n    vec3 colors [N];\n    colors[0] = vec3(0.82, 0.77, 0.71);\n    colors[1] = vec3(0.18, 0.09, 0.00);\n    colors[2] = vec3(0.02, 0.36, 0.51);\n    colors[3] = vec3(0.24, 0.62, 0.67);\n    \n    // find the displacement to the nearest stripe edge in the pattern space\n    jet21 t = dmod(proj_y(f), float(N)); // the pattern coordinate\n    int n = int(t.pt); // the index of the nearest stripe edge\n    float pattern_disp = t.pt - (float(n) + 0.5);\n    \n    // the edges of the stripes on the screen are level sets of the pattern\n    // coordinate `t`. linearizing, we get stripes on the screen tangent space,\n    // whose edges are level sets of `t.push`. find the distance to the nearest\n    // stripe edge in the screen tangent space\n    float screen_dist = abs(pattern_disp) / length(t.push);\n    \n    // now we can integrate our pixel's sampling distribution on the screen\n    // tangent space to find out how much of the pixel falls on the other side\n    // of the nearest edge\n    float overflow = 0.5*erfc_appx(screen_dist / r_px);\n    return mix(colors[n], colors[(n+1)%N], pattern_disp < 0. ? overflow : 1.-overflow);\n}\n\n// --- test image ---\n\nconst float VIEW = 2.;\n\nmat2 rot(float t) {\n    float a = cos(t);\n    float b = sin(t);\n    return mat2(a, b, -b, a);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // find screen point\n    float small_dim = min(iResolution.x, iResolution.y);\n    float r_px = VIEW / small_dim; // the inner radius of a pixel in the Euclidean metric of the screen\n    jet2 p = jet2(r_px * (2.*fragCoord - iResolution.xy), mat2(1.));\n    \n    // choose time-varying linear maps\n    float t = 0.125*iTime;\n    mat2 pre = (2.+cos(0.5*t)) * mat2(1., 1., 1., -1.);\n    mat2 post = 2.*rot(t);\n    \n    // get pixel color\n    vec3 color = stripe(apply(post, add(p, wave(apply(pre, p)))), r_px);\n    fragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"}]}