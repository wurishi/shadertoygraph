{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"vec3 ambientLight;\nvec3 dirLightColor = vec3(0.5, 0.5, 0.5);\nvec3 dirLightDir;\nfloat c = 2.0;\n\nfloat dBox(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0)) - 0.07;\n}\n\nfloat map(vec3 p)\n{\n    vec3 b = vec3(0.5);\n    vec3 q = vec3(\n        mod(p.x, c) - 0.5 * c,\n        mod(p.y, c) - 0.5 * c,\n        mod(p.z, c) - 0.5 * c);\n    return dBox(q, b);\n}\n\nvec3 getNormal(vec3 pos)\n{\n    float threshold = 0.001;\n\tvec2 t = vec2(0.0, threshold);\n    vec3 n = vec3(map(pos + t.yxx) - map(pos - t.yxx),\n           \t  map(pos + t.xyx) - map(pos - t.xyx),\n              map(pos + t.xxy) - map(pos - t.xxy));\n    return normalize(n);\n}\n\nbool getDepth(vec3 rayPos, vec3 rayDir, inout float depth)\n{\n    const int max_iters = 1000;\n    float phase = (.5 + .5 * sin(iTime));\n    float eps = mix(0.001, 0.5, phase);\n    vec3 p = rayPos;\n    float d;\n    float d_total = 0.0;\n    for (int i = 0; i < max_iters; ++i)\n    {\n        d = map(p);\n        d_total += d;\n        p += d * rayDir;\n        if (d < eps)\n            break;\n    }\n    depth = d_total;\n    return d < eps;\n}\n\nbool intersect(vec3 rayPos, vec3 rayDir, inout vec3 color, inout vec3 normal)\n{\n    vec3 bg = vec3(0.1, 0.1, 0.1);\n    \n    float depth;\n    bool hit = getDepth(rayPos, rayDir, depth);\n    \n    normal = vec3(0.0);\n    \n    if (hit)\n    {\n        normal = getNormal(rayPos + depth * rayDir);\n        vec3 kd = vec3(0.1, 0.1, 0.1);\n        vec3 ka = ambientLight;\n        color = ka + kd * max(dot(normal, -dirLightDir), 0.0);\n        return true;\n    }\n    else\n    {\n\t    color = bg;\n        normal = vec3(0.0);\n        return false;\n    }\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ambientLight = vec3(.2 + .2 * sin(iTime), .2 + .2 * cos(iTime), 0.2) * .2;\n\tdirLightDir = normalize(vec3(sin(iTime), -0.3, 1.0));\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float aspect = iResolution.x / iResolution.y;\n    \n    uv -= .5;\n    uv.x = aspect * uv.x;\n    \n    vec3 camPos = vec3(2.0, 1.5, -2.) * iTime;\n    vec3 camTarget = vec3(0.);\n    vec3 camUp = vec3(0., 1., 0.);\n    vec3 camDir = normalize(camTarget - camPos);\n    vec3 camRight = normalize(cross(camUp, camDir));\n    camUp = normalize(cross(camDir, camRight));\n    vec3 rayPos = camPos;\n    vec3 rayDir = normalize(camDir + uv.x * camRight + uv.y * camUp);\n    \n    float zNear = 10.0;\n    rayPos += zNear * rayDir;\n    \n    vec3 c;\n    vec3 n;\n    bool hit = intersect(rayPos, rayDir, c, n);\n    \n\tfragColor = vec4(c, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldSXRt","date":"1414802654","viewed":156,"name":"boksit","username":"janneasdf","description":"lots of boxes","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"","parentname":""}}