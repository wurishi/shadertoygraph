{"ver":"0.1","info":{"id":"fsK3DK","date":"1632878746","viewed":61,"name":"SuperSimpleRayMarching-00","username":"liaozixin","description":"SDF \nyou can rotate camera by click the screen","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST .01\n#define PI 3.1415926\n\n\nmat3 RotX(float a)\n{\n    a = a * PI / 180.;\n    return mat3(\n        1., 0., 0.,\n        0., cos(a), sin(a),\n        0., -sin(a), cos(a)\n    );\n}\n\nmat3 RotY(float a)\n{\n    a = a * PI / 180.;\n    return mat3(\n        cos(a), 0., -sin(a),\n        0., 1., 0.,\n        sin(a), 0., cos(a)\n    );\n}\n\n\nmat3 RotZ(float a)\n{\n    a = a * PI / 180.;\n    return mat3(\n        cos(a), sin(a), 0.,\n        -sin(a), cos(a), 0.,\n        0., 0., 1.\n    );\n}\n\nfloat sdSphere(vec3 sampling, vec3 ori, float r)\n{\n    return length(sampling - ori.xyz) - r;\n}\n\nfloat sdPlaneXOZ(vec3 sampling)\n{\n    return sampling.y;\n}\n\nfloat sdCapsule(vec3 sampling, vec3 a, vec3 b, float r)\n{\n    vec3 ab = b - a;\n    vec3 ap = sampling - a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    vec3 c = a + t * ab;\n    \n    return length(sampling - c) - r;\n\n}\n\n\nfloat sdTorus(vec3 sampling, vec2 r)\n{\n    float x = length(sampling.xz) - r.x;\n    return length(vec2(x, sampling.y)) - r.y;\n\n}\n\n\nfloat sdBox(vec3 sampling, vec3 size)\n{\n    return length(max(abs(sampling) - size, 0.));\n\n}\n\nfloat sdCylinder(vec3 sampling, vec3 a, vec3 b, float r)\n{\n    vec3 ab = b - a;\n    vec3 ap = sampling - a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    \n    vec3 c = a + t * ab;\n    \n    float x = length(sampling - c) - r;\n    float y = (abs(t - .5) - .5) * length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    return e;\n}\n\n\nfloat sdPillar(vec3 sampling)\n{\n    float d = .0;\n    \n    float box1 = sdBox(sampling, vec3(1, 7, 1));\n    \n    vec3 boxPos = sampling;\n    boxPos -= vec3(0, 6, 0);\n    float box2 = sdBox(boxPos, vec3(1.6, 0.1, 1.6));\n    \n   \n    float box3 = sdBox(sampling, vec3(1.2, 3., 1.2));\n    \n    boxPos = sampling;\n    boxPos -= vec3(0, 3, 0);\n    boxPos *= RotZ(45.); \n    float box4 = sdBox(boxPos, vec3(0.8, 0.8, 1.2));\n    \n    \n    d = min(box1, box2);\n    d = min(d, box3);\n    d = min(d, box4);\n    \n   \n    return d;\n}\n\n\nfloat GetDist(vec3 sampling)\n{\n    float plane = sdPlaneXOZ(sampling);\n    \n    vec3 pillarPos = sampling - vec3(0, 1, 4);\n    pillarPos *= RotY(0.);\n    float pillar = sdPillar(pillarPos);\n    \n    \n    \n    \n    return min(pillar, plane);\n}\n\nfloat RayMarching(vec3 ro, vec3 rd)\n{\n    float d = 0.;\n    vec3 p = ro;\n    \n    \n    for(int i = 0; i < MAX_STEPS; ++i)\n    {\n        float dS = GetDist(p);\n        d += dS;\n        p = ro + d * rd;\n        \n        if (d > MAX_DIST || d < MIN_DIST)\n            break;\n    }\n    \n    return d;\n}\n\n\nvec3 GetNormal(vec3 p)\n{\n    vec2 dS = vec2(.01, 0);\n    \n    float d = GetDist(p);\n    \n    vec3 n = vec3(\n        (d - GetDist(p - dS.xyy)) / dS.x,\n        (d - GetDist(p - dS.yxy)) / dS.x,\n        (d - GetDist(p - dS.yyx)) / dS.x\n    );\n    \n    return normalize(n);\n}\n\n\nfloat GetLight(vec3 p)\n{\n    \n    vec3 lightPos = vec3(-6, 10, 0);\n    lightPos.xz += vec2(sin(iTime), cos(iTime) * 2.);\n     \n    vec3 lightDir = normalize(lightPos - p);\n    vec3 n = GetNormal(p);\n    \n    float dif = dot(lightDir, n);\n    \n    float d = RayMarching(p + n, lightDir);\n    if (d < length(lightPos - p))\n        dif *= .4;\n        \n    return dif;\n}\n\n\nvec3 InitCam(in vec2 fragCoord)\n{\n    float time = iTime;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n  \n  \tvec2 p = fragCoord.xy/iResolution.xy-0.5;\n    vec2 q = fragCoord.xy/iResolution.xy;\n\tp.x*=iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy / iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(-0,-0.03):mo;\n\tmo.x *= iResolution.x/iResolution.y * 3.14159;\n\t\n\n    mo.x += smoothstep(0.6,1.,0.5+0.5)-1.5;\n    vec3 eyedir = normalize(vec3(cos(mo.x),mo.y*2.-0.2+sin(1.57)*0.1,sin(mo.x)));\n    vec3 rightdir = normalize(vec3(cos(mo.x+1.5708),0.,sin(mo.x+1.5708)));\n    vec3 updir = normalize(cross(rightdir,eyedir));\n\tvec3 rd=normalize((p.x*rightdir+p.y*updir)*1.+eyedir);\n\treturn rd;\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    \n    \n    vec3 col = vec3(0);\n    \n    //ray\n    vec3 ro = vec3(0, 5, -4); //ray origin\n    vec3 rd = InitCam(fragCoord);//ray direction\n   \n    float d = RayMarching(ro, rd);\n    \n    vec3 p = ro + d * rd;\n    float dif = GetLight(p);\n    col = vec3(dif);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}