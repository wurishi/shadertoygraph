{"ver":"0.1","info":{"id":"dtf3zn","date":"1671167367","viewed":101,"name":"Mirror Mirror on the ball","username":"maftkd","description":"Click and drag to rotate!\n\nTesting approaches for\n1. Rotating a camera to sample a cubemap\n2. rendering a sphere using sphere-tracing + sdf\n3. generating reflections on the sphere by getting normals from the sdf evaluation","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sdf","sphere","cubemap","mirror","reflect"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.1416;\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nfloat sphereSdf(vec3 sphere, vec3 p, float r){\n    float dist = length(sphere-p);\n    return dist-r;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //camera field of view\n    float aspect = iResolution.x/iResolution.y;\n    float fovy = 60.*PI/180.;\n    float fovx = 2. * atan(tan(fovy * 0.5) * aspect);\n\n\n    //map mouse coords to camera rotation\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    float theta = mix(-PI, PI, mouse.x);\n    float phi = mix(-PI/2., PI/2., mouse.y);\n\n    float nearClip = 0.1;\n    float nearWidthHalf = tan(fovx/2.)*nearClip;\n    float nearHeightHalf = tan(fovy/2.)*nearClip;\n\n    vec3 ray = vec3(\n            mix(-nearWidthHalf,nearWidthHalf,uv.x),\n            mix(-nearHeightHalf,nearHeightHalf,uv.y),\n            nearClip);\n\n\n    //rotate cam\n    mat3 rotateYMatrix = rotateY(theta);\n    mat3 rotateXMatrix = rotateX(-phi);\n    ray = normalize(ray * rotateXMatrix * rotateYMatrix);\n   \n    //get bg color\n    vec3 samplePos = normalize(ray);\n    vec4 bg = texture(iChannel0, samplePos);\n    \n    //sphere\n    vec3 spherePos = vec3(0,0,3) * rotateXMatrix * rotateYMatrix;\n    float sphereRadius = 1.;\n\n    //sphere-trace\n    vec3 cam = vec3(0);\n    vec3 cur = cam;\n    float minDst = 1000.;\n    float thresh = 1e-5;\n    vec3 hitPoint = vec3(0);\n    for(float i = 0.; i< 40. && minDst>0.; i++) {\n        float d = sphereSdf(spherePos, cur, sphereRadius);\n\n        minDst = min(d,minDst);\n\n        //mark hitpoint if cur point is within thresh\n        hitPoint = step(minDst,thresh)*cur;\n        \n        cur+=ray*d;\n    }\n\n    float sphere = step(minDst,thresh);\n\n    vec3 diff = reflect(ray,normalize(hitPoint-spherePos));\n\n    vec4 sphereCol = texture(iChannel0,diff);\n\n\n    // Output to screen\n    fragColor = mix(bg,sphereCol,sphere);\n}","name":"Image","description":"","type":"image"}]}