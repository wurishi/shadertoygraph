{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"\nprecision highp float;\n\n#define LACU 2.0\n#define MAXGRASSSTEEP 0.5\n#define MAXGRASSALTITUDE .8\n#define MAXSNOWSTEEP   0.35\n#define MAXSNOWALTITUDE 0.8\n#define NORMALEPSILON 0.002\n#define SEALEVEL 0.3 //std 0.3\n#define CAMERAALTITUDE 1.3 //std 1.0\n#define CAMERASCREENDISTANCE 0.5 //std 0.4\n#define LOWITER 5\n#define HIGHITER 9\n#define COLORITER 7\n\n\n\n\n/* ****************************************************************** */\nfloat conv(float f) {\n\t//f*=f*f*f;  //sealevel 0.01 - flat landscape with few hills\n\t//f = f *(f *(f *(16.5333 - 6.4 * f )-13.6)+4.46667);\n\t//f = f* (f* (f* (f* (33.4169-13.3668 *f)-29.2398)+10.4428)-0.253133); // plains with holes\n\t//f = f* (f* (f* (f* (f* (119.616-40.3125 *f)-131.004)+63.0956)-11.5608)+1.16577);\n    if (f < SEALEVEL){f = SEALEVEL;}\n    return f;\n}\n\n\n// ***** noise code ***************************************************\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//iq hash\nfloat hash( float n )\n{\n    return fract(sin(n)*54321.98761234);  // value has no meaning that I could find\n}\n\n//iq derivative noise function\n// returns vec3(noise, dnoise/dx, dnoise/dy)\nvec3 noised(vec2 pos )\n{\n    vec2 p = floor(pos);\n    vec2 f = fract(pos);\n    \n    vec2 u = (10.0+(-15.0+6.0*f)*f)*f*f*f;  // f=6*x^5-15*x^4+10*x^3  df/dx=30*x^4-60*x^3+30*x^2; horner of df is 30.0*f*f*(f*(f-2.0)+1.0)\n    \n    float n = p.x + p.y*57.0;\n    \n    float a = hash(n+  0.0);\n    float b = hash(n+  1.0);\n    float c = hash(n+ 57.0); // do not know why 57 & 58\n    float d = hash(n+ 58.0);\n    \n    return vec3( a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n    30.0*f*f*(f*(f-2.0)+1.0) * (vec2(b-a,c-a)+(a-b-c+d)*u.yx) );\n    \n}\n\n//iq  noise function\nfloat noise(vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    \n    f= (10.0+(-15.0+6.0*f)*f)*f*f*f; // smooth\n    \n    float n = p.x + p.y*57.0;\n    \n    float res = mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n    \n    return res;\n}\n\n\n/* ****************************************************************** */\n\n\n/* ****************************************************************** */\n\n\n// fractional brownian motion\n// iter is number of octaves\n\nvec3 fbmDerivative(vec2 p, int iter) {\n    \n    float f = 0.0;\n\tfloat dfx = 0.0;\n\tfloat dfy = 0.0;\n    float fLacunarity = LACU;\n    \n\tfloat amplitude = 0.5;\n\tfloat sumAmplitude = 0.0;\n\t\t\n\tfor (int i=0;i<20;i++) {\n\t\tvec3 value = noised( p ); \n\t\t\n\t\tf += amplitude * value.x;\n\t\tdfx +=  value.y;\n\t\tdfy +=  value.z;\n\t\tp = p * fLacunarity; \n\t\tsumAmplitude+=amplitude;\n\t\tamplitude/=2.0;\n\t\tif (i>iter) {break;}\n\t}\n\tf/=sumAmplitude;\n\t\n    return vec3( conv(f), dfx, dfy);\n}\n\n// same as above, without derivatives\nfloat fbm(vec2 p, int iter){\n\tint idx=0;\n    float f = 0.0;\n\tfloat amplitude = 0.5;\n\tfloat sumAmplitude = 0.0;\n\tfor (int i=0;i<20;i++) {\n\t\tfloat value = noise( p ); \n\t\tf += amplitude * value;\n\t\tp = p * LACU; \n\t\tsumAmplitude+=amplitude;\n\t\tamplitude/=2.0;\n\t\tif ( i>iter ) {break;}\n\t}\n\tf/=sumAmplitude;\n    return conv(f);\n}\n\nvec3 getNormal( vec3 p, int iter ) {\n\t//using noise derivative\n\t//not sure this code is correct\n    vec3 value;\n\tvalue = fbmDerivative( p.xz, iter);\n\tif (value.x <= SEALEVEL) { return vec3(.0,1.0,.0); } //sea is flat\n\tfloat dfx=value.y;\n\tfloat dfz=value.z;\n\t\n\treturn normalize(vec3( -value.y, 1.0, -value.z));\n}\n\n// #####################################################################\nvec3 GenerateTerrainColor(vec3 position, vec3 normal) {\n    float x = position.x;\n    float y = position.z;\n    float z = position.y;\n\tfloat n = getNormal(position,COLORITER).y;\n    float l = 1.0;\n    vec3 terrainColor;\n    vec3 cmin,cmax;\n    \n    //palette\n    vec3 ocean      = vec3( 0.2, .300, .8);\n    vec3 shore      = vec3( 0.3, .400,1.0);\n    vec3 beach      = vec3( 1.0, .894, .710);\n    vec3 earth      = vec3(.824, .706, .549);\n    vec3 calcaire   = vec3(.624, .412, .118);\n    vec3 rocks      = vec3(.412, .388, .422);\n    \n    vec3 grass1 = vec3 (.19, .335, .14);\n    vec3 grass2 = vec3 (.478, .451, .14);\n    \n    vec3 snow1 = vec3 ( .78,.78,.78);\n    vec3 snow2 = vec3 ( .9,.9,.9);\n    \n    if ( z <= SEALEVEL) {\n        //water\n        //terrainColor = mix (ocean, shore , smoothstep( 0.0, 1.0,  noise( position.xz * position.xz)) );    \n\t\tterrainColor=shore;\n        return terrainColor;\n    }\n    \n    \n\t// add some noise\n\t// input noise divisor define size of stains in transition areas\n    // multiplicator define the size of the range of altitude with mixed color\n    z += noise( position.xz * 47.0 )* 0.2;\n    \n    \n    // base color\n    terrainColor = mix (        beach,    earth, smoothstep(0.0 , 0.08 , z) );\n    terrainColor = mix ( terrainColor, calcaire, smoothstep(0.08, 0.3 , z) );\n    terrainColor = mix ( terrainColor,    rocks, smoothstep(0.3, 1.0  , z) );\n    \n    //add grass\n    if (( n > MAXGRASSSTEEP ) && ( z <  MAXGRASSALTITUDE )) {\n        terrainColor = mix( grass1, grass2, smoothstep(0.0 , 1.0, noise( position.xz * 5.0 )));\n    }\n    // add snow\n    if (( n > MAXSNOWSTEEP) && ( z > MAXSNOWALTITUDE )) {\n        return mix( snow1, snow2, smoothstep(0.0 , 1.0, noise( position.xz * 131.0 )));\n\t}\n    return vec3(terrainColor);;\n}\n\n\n\n// ###################################################################\n\n\n\n// ###################################################################\nvec4 castRay( vec3 startPosition, vec3 lookatDirection )  {\n    // return vec4 = last worldPosition, 1 if terrain / 0 if sky\n    float step = 0.03;\n    float lastStep;\n    float altitude = 0.0;\n    float lastAltitude;\n    float lastY;\n    float walkStep = 0.0;\n    vec3 p;\n\tfloat delta;\n    lastStep=step;\n    for( int i = 0; i < 180; i++ ) { // GLSL limitation: loop on int only\n        p = startPosition + lookatDirection * walkStep;\n        altitude = fbm( vec2(p.x, p.z),LOWITER);\n\t\tdelta = p.y -  altitude;\n        if(delta<0.0 ){\n            // we are under floor: linear interpolate the intersect\n            walkStep = walkStep - lastStep + lastStep*(lastAltitude-lastY)/(p.y-lastY-altitude+lastAltitude);\n            p = startPosition + lookatDirection * walkStep;\n            altitude = fbm( vec2(p.x, p.z),HIGHITER ); //high definition altitude\n            return vec4(p.x,altitude,p.z,walkStep);\n        }\n        if( p.y <  0.001){\n\t\t\t// under the flow, exit\n            walkStep = walkStep - lastStep + lastStep*(lastAltitude-lastY)/(p.y-lastY-altitude+lastAltitude);\n            p = startPosition + lookatDirection * walkStep;\n            return vec4(p.x,0,p.z,walkStep);\n        }\n        if (p.y > 5.0) {break;} // far in the sky\n        lastAltitude = altitude;\n        lastStep=step;\n        lastY = p.y;\n        step = max(max(0.05,.5*delta) , float(i)/2000.0); // step is big when far from floor and far from camera\n\t\t//step+=0.0005;\n        walkStep += step;\n        \n    }\n    return  vec4(p.x,p.y,p.z,-walkStep);  \n}\n\n// ###################################################################\n\nvec3 calcLookAtDirection( vec3 cP, vec3 cD, float screenDistance, vec2 z ){\n    // cameraPosition\n    // cameraDirection\n    // camera-screen distance\n    // position of pixel on screen\n    \n    // normalize camera direction\n    vec3 cDnorm = normalize (cD);\n    \n    // we are looking for u & v, the unity vectors on screen, in world coordinates\n    // we know that u is // to surface (since we locked horizon at horizontal ):its Y is 0\n    // we know that cDnorm is perpendicular to u\n    // we project to surface to find u.x and u.y\n    vec3 u = vec3(cDnorm.z, 0.0,cDnorm.x);\n    \n    vec3 v = cross( cDnorm, u);\n    \n    //screen point 0,0 in world coordiante\n    vec3 screenPointOO = cP + cDnorm * screenDistance;\n    \n    //z in world coordiantes\n    vec3 screenPointInWorld= screenPointOO + u*z.x + v*z.y;\n    \n    return  (screenPointInWorld-cP);\n    \n}\n\n// #################################################################\n\nvec3 calcStartPosition( vec3 cP, vec3 cD, float screenDistance, vec2 z ){\n    // cameraPosition\n    // cameraDirection\n    // camera-screen distance\n    // position of pixel on screen\n    \n    // normalize camera direction\n    vec3 cDnorm = normalize (cD);\n    \n    // we are looking for u & v, the unity vectors on screen, in world coordinates\n    // we know that u is // to surface =&gt; its Y is 0\n    // we know that cDnorm is perpendicular to u\n    // we project to surface to find u.x and u.y\n    vec3 u = vec3(cDnorm.z, 0.0,cDnorm.x);\n    \n    vec3 v = cross( cDnorm, u);\n    \n    //screen point 0,0 in world coordiante\n    vec3 screenPointOO = cP + cDnorm * screenDistance;\n    \n    //z in world coordiantes\n    vec3 screenPointInWorld= screenPointOO + u*z.x + v*z.y;\n    \n    return  screenPointInWorld;\n    \n}\n\n// #################################################################\nvec3 getNormal( vec3 p ) {\n\t//noise derivative\n    vec3 value;\n\tvalue = fbmDerivative( p.xz, HIGHITER);\n\tif (value.x <= SEALEVEL) { return vec3(.0,1.0,.0); }\n\tfloat dfx=value.y;\n\tfloat dfz=value.z;\n\t//float vy = 1.0 ;\tvy -= dfx*dfx + dfz*dfz;vy=sqrt(vy);\n\t\n\treturn normalize(vec3( -value.y, 1.0, -value.z));\n}\n\n\n vec3 getNormalC( vec3 p ) {\n\t//central differences\n    float eps=NORMALEPSILON;\n    vec3  n = vec3( fbm( vec2(p.x-eps,p.z), HIGHITER ) - fbm( vec2(p.x+eps,p.z), HIGHITER ), \n\t\t\t\t  \t2.0*eps,\n    \t\t\t\tfbm(vec2(p.x,p.z-eps), HIGHITER ) - fbm(vec2(p.x,p.z+eps), HIGHITER ) );\n    return normalize( n );\n}\n\n\n// #################################################################\nfloat castRay2Sun( vec3 startPosition, vec3 lookatDirection )  {\n    float step = 0.03;\n    float lastStep;\n    float altitude = 0.0;\n    float lastAltitude;\n    float lastY;\n    float walkStep = 0.0;\n\tfloat delta;\n    vec3 p;\n    lastStep=step;\n    for( int i = 0; i < 20; i++ ) { // GLSL limitation: loop on int only\n        p = startPosition + lookatDirection * walkStep;\n        altitude = fbm( vec2(p.x, p.z) , HIGHITER);\n\t\tdelta = p.y -  altitude;\n\t\tif( delta < .0){\n\t\t\treturn float(i)/20.0; //penumbra is lighter when we are far from hill\n        }\n        walkStep += step;\n        \n    }\n    return  1.0;   //no penumnra\n}\nvec3 getShading( vec3 position , vec3 normal ) {\n    vec3 uAmbientColor = vec3 (0.25, 0.25, 0.3);         // ambiant light color\n    vec3 uLightingDirection = vec3(-0.9, 0.2, 0.1); // sunlight direction\n    vec3 uDirectionalColor = vec3( 250.0/255.0, 230.0/255.0, 200.0/255.0);  // sunlight color\n    \n    vec3 penombre = vec3 (1.0, 1.0, 1.0);\n    \n    // march to sun. if we intersect a moutain, we are in its shadow\n    penombre = mix( vec3(.6, .6, .8), \n\t\t\t\t   vec3(1.0,1.0,1.0),\n\t\t\t\t   castRay2Sun(  position ,uLightingDirection) \n\t\t\t\t  );\n    \n    \n    //directional lightning (sun)\n    float directionalLightWeighting = max(dot(normal, uLightingDirection), 0.0);\n    \n    //final lightning: ambiant, sun, penumbra\n    return (uAmbientColor + uDirectionalColor * directionalLightWeighting) * penombre;\n\t//return vec3(1.0, 1.0, 1.0) * penombre; // usefull to debug penumbra\n    \n}\n\n// #################################################################\n\nvec4 applyFog ( vec3 color, float far) {\n\t//just to hide clipping\n    return vec4( mix( color ,vec3(0.5,0.5,0.6), smoothstep(0.0,1.0,far/25.0) ) ,1.0);\n}\n\n// #################################################################\n\nvec4 colorize(vec3 startPosition, vec3 lookatDirection, vec4 position) {\n    \n    vec3 p = position.xyz; //startPosition + lookatDirection * position.w;\n    vec3 n = getNormal( p );\n    vec3 s = getShading( p, n );\n    vec3 m = GenerateTerrainColor( position.xyz, n ); //getMaterial( p, n );\n    return applyFog( m * s, position.w );\n    \n    //return vec4(  m *s ,1.0);\n    \n}\n\n// ###################################################################\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec3 uCameraXYZ = vec3( 0.0, CAMERAALTITUDE, 0.0); // camera postion\n    vec3 uCameraDirXYZ = vec3(0, -0.2, .707160) ; // camera direction\n    \n    uCameraXYZ.z = iTime/1.1;\n\t\n    \n    float uScreenDistance = CAMERASCREENDISTANCE;  // distance camera/screen\n    \n    \n    float sx=float(iResolution.x);\n    float sy=float(iResolution.y);\n    vec2 z,zn;\n    \n    z.x = fragCoord.x / sx - 0.5;\n    z.y = fragCoord.y / sy - 0.5;\n    \n    vec3 lookatDirection = calcLookAtDirection( uCameraXYZ,uCameraDirXYZ, uScreenDistance, z );\n    vec3 startPosition  = calcStartPosition( uCameraXYZ, uCameraDirXYZ, uScreenDistance, z );\n    \n    vec4 gotcha = castRay( startPosition, lookatDirection );\n    \n    if (gotcha.w > 0.0 ) {\n        fragColor = colorize( startPosition, lookatDirection, gotcha);\n        } else {\n        // sky color;\n        fragColor = vec4( mix ( vec3(0.7,0.9,1.0), vec3(0.5,0.5,0.6), smoothstep(0.0,1.0,-gotcha.w/30.0)), 1.0);\n        \n    }\n}   // main","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldj3zd","date":"1392590276","viewed":1509,"name":"terrain marching 5","username":"rmotfage","description":"having fun trying to understand iq's code & articles ","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["terrainmarching"],"hasliked":0,"parentid":"","parentname":""}}