{"ver":"0.1","info":{"id":"7lBfRt","date":"1665303253","viewed":183,"name":"ShadertoyPresentation","username":"sdfgeoff","description":"Presentation about shadertoy - done in shadertoy. Space or click or forward arrow to go forwards.","likes":20,"published":1,"flags":48,"usePreview":0,"tags":["sdf","text","shadertoy","presentation","slides"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Combine Everything\n\n#define BUFFER_STATE iChannel0\n#define WORLD_BUFFER iChannel1\n#define TEXT_BUFFER iChannel2\n#define FLAT_BUFFER iChannel3\n\n\n\nvec4 alpha_over(vec4 img2, vec4 img1) {\n    float a2s = img2.a * (1.0 - img1.a);\n    float a0 = img1.a + a2s;\n    \n    return vec4(\n        (img1.rgb * img1.a + img2.rgb * a2s) / a0,\n        a0\n    );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 presentation_state = read_data(BUFFER_STATE, ADDRESS_PRESENTATION_STATE);\n    int slide_number = int(presentation_state.r);\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    \n    vec4 outcol = vec4(col, 1.0);\n\n    outcol = texture(WORLD_BUFFER, uv);\n    \n    // Text Buffer\n    outcol = alpha_over(outcol, texture(FLAT_BUFFER, uv));\n    outcol = alpha_over(outcol, texture(TEXT_BUFFER, uv));\n    \n    // Output to screen\n    fragColor = outcol;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const int SLIDE_COUNT = 26;\n\n\n\nconst int KEY_PREV = 37;\nconst int KEY_SPACE = 32;\nconst int KEY_NEXT = 39;\n\n// Red = slide number\n// Green = slide change time\n// Blue = iTime\n// Alpha = transition_state (betwen 0.0 and 1.0)\nivec2 ADDRESS_PRESENTATION_STATE = ivec2(0,0);\n\n\nconst int START_FRAME_3D = 7;\nconst int START_FRAME_INTERACTION = START_FRAME_3D + 11;\nconst int START_FRAME_STATE = START_FRAME_INTERACTION + 4;\n\n\n\n\nvec4 read_data(sampler2D buffer, ivec2 address){\n    return texelFetch(buffer, address, 0);\n}\n\nfloat get_key(sampler2D buffer, int key_code) {\n    return texelFetch(buffer, ivec2(key_code,0), 0).x;\n}\nfloat get_key_edge(sampler2D buffer, int key_code) {\n    return texelFetch(buffer, ivec2(key_code,1), 0).x;\n}\n\n\n// 1 out, 3 in...\n// Taken from https://www.shadertoy.com/view/4djSRW\n// Used under MIT\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n\nvec3 neon(float val, vec3 color) {\n\tfloat r = clamp(val, 0.0, 1.0);\n    float r2 = r * r;\n    float r4 = r2 * r2;\n    float r16 = r4 * r4;\n    vec3 c = color;\n    vec3 c2 = pow(color, vec3(4.0)); // A darker, more saturated version of color\n    \n\tvec3 outp = vec3(0.0);\n\toutp += c2 * r2; // Darker color falloff\n\toutp += c * r4; // Specified Color main part\n\toutp += vec3(1.0) * r16; // White core\n\treturn outp;\n}\n\n\nfloat easeOutQuad(float x) {\n    return 1.0 - (1.0 - x) * (1.0 - x);\n}\n\nfloat easeInOutQuad(float x) {\n    float a = -2.0 * x + 2.0;\n    return x < 0.5 ? 2.0 * x * x : 1.0 - (a*a) / 2.0;\n}\n\n\n\n\nfloat map(vec4 presentation_state, vec3 position) {\n    int slide = int(presentation_state.r);\n    \n    if (slide == START_FRAME_3D + 2) {\n        return length(position) - easeOutQuad(presentation_state.a) * 0.1;\n    } \n    else if (slide == START_FRAME_3D + 3) {\n        return length(position + vec3(easeInOutQuad(presentation_state.a), 0.0, 0.0)) - 0.1;\n    }\n    else if (slide == START_FRAME_3D + 4) {\n        return length(position + vec3(1.0 -easeInOutQuad(presentation_state.a) * 2.0, 0.0, 0.0)) - 0.1;\n    }\n    else if (slide == START_FRAME_3D + 5) {\n        float bounce_scale = 1.0 - easeOutQuad(presentation_state.a);\n        float bounce_speed = mix(15.0, 5.0, bounce_scale);\n        float bounce = -abs(cos(presentation_state.a * bounce_speed)) * bounce_scale * 0.8 + 0.8;\n        return length(position + vec3(-bounce_scale, bounce, 0.0)) - 0.1;\n    }\n    else if (slide == START_FRAME_3D + 6) {\n        return length(position + vec3(0.0, 0.8 * (1.0 - easeInOutQuad(presentation_state.a)), 0.0)) - 0.1;\n    }\n    else if (slide == START_FRAME_3D + 7) {\n        vec3 size = mix(vec3(0.5, 0.5, 0.001), vec3(2.0, 2.0, 0.001), vec3(easeOutQuad(presentation_state.a)));\n        vec3 co = position.xyz;\n        vec3 cell = round(co * size) / size;\n        vec3 delta = co - cell;\n        \n        return length(delta) - 0.1;\n    }\n    else if (slide == START_FRAME_3D + 8) {\n        vec3 size = vec3(2.0, 2.0, 0.001);\n        vec3 co = position.xyz;\n        vec3 cellid = round(co * size);\n\n        vec3 cell = round(co * size) / size;\n        vec3 delta = co - cell;\n        \n        float radius = 1.0;\n        float cellnoise = hash13(cellid);\n        radius += (cellnoise - 0.5) * easeInOutQuad(presentation_state.a) * 1.5;\n        \n        return length(delta) - radius * 0.1;\n    }\n    else if (slide == START_FRAME_3D + 9) {\n        vec3 size = vec3(2.0, 2.0, 0.001);\n        vec3 co = position.xyz;\n        vec3 cellid = round(co * size);\n\n        vec3 cell = round(co * size) / size;\n        vec3 delta = co - cell;\n        \n        float radius = 1.0;\n        float cellnoise = hash13(cellid);\n        radius += (cellnoise - 0.5) * 1.5;\n        \n        return length(delta) - radius * 0.1;\n    }\n    else if (slide == START_FRAME_3D + 10) {\n        vec3 size = vec3(2.0, 2.0, mix(0.001, 2.0, easeOutQuad(presentation_state.a)));\n        vec3 co = position.xyz;\n        vec3 cellid = round(co * size);\n        vec3 cell = round(co * size) / size;\n        vec3 delta = co - cell;\n        \n        float radius = 1.0;\n        float cellnoise = hash13(cellid);\n        radius += (cellnoise - 0.5) * 1.5;\n        \n        return length(delta) - radius * 0.1;\n    }\n    else if (slide == START_FRAME_3D + 11) {\n        float scale = mix(2.0, 0.002, easeOutQuad(presentation_state.a));\n        vec3 size = vec3(scale);\n        vec3 co = position.xyz;\n        vec3 cellid = round(co * size);\n        vec3 cell = round(co * size) / size;\n        vec3 delta = co - cell;\n        \n        float radius = 1.0;\n        float cellnoise = hash13(cellid);\n        radius += (cellnoise - 0.5) * 1.5;\n        \n        return length(delta) - radius * 0.1;\n    }\n    \n    return 10.0;\n}\n\n\n\n/// Raymarch by the distance field each step until the step count or\n/// the maximum distance is reached.\nvec4 raymarch(vec3 start_point, vec3 direction, int steps, float max_dist, vec4 presentation_state) {\n    vec3 position = start_point;\n    \n    float dist = 0.0;\n    \n    int i = 0;\n    for (i=0; i<steps; i++) {\n        float df = map(presentation_state, position);\n        \n        float threshold = 0.001 * dist;\n        float step_size = df;\n        \n        if ((abs(df) < threshold)) {\n            return vec4(position, dist / max_dist);\n        }\n        if  (dist > max_dist) {\n            return vec4(position, 1.0);\n        }\n        dist += step_size;\n        position += direction * step_size;\n    }\n    return vec4(position, dist/max_dist);\n}\n\nconst float NORMAL_SAMPLE_SIZE = 0.0001;\n\nvec3 calc_normal(vec3 sample_point, vec4 presentation_state) {\n    const float h = NORMAL_SAMPLE_SIZE; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    \n    vec3 normal = normalize(\n\t\tk.xyy * map( presentation_state, sample_point + k.xyy*h ) + \n\t\tk.yyx * map( presentation_state, sample_point + k.yyx*h ) + \n\t\tk.yxy * map( presentation_state, sample_point + k.yxy*h ) + \n\t\tk.xxx * map( presentation_state, sample_point + k.xxx*h ) );\n    normal = normal.xyz;\n    return normal;\n}\n\nmat4 get_camera_transform(vec4 presentation_state) {\n    int slide = int(presentation_state.r);\n\n    if (slide <= START_FRAME_3D + 8) {\n        return mat4(\n            vec4(1.0, 0.0, 0.0, 0.0),\n            vec4(0.0, 1.0, 0.0, 0.0),\n            vec4(0.0, 0.0, 1.0, 0.0),\n            vec4(0.0, 0.0, -2.0, 1.0)\n        );\n    }\n    if (slide == START_FRAME_3D + 9) {\n        float ratio = easeInOutQuad(presentation_state.a);\n        float angle = ratio * 3.14159 / 2.0;\n        float s = sin(angle);\n        float c = cos(angle);\n        return mat4(\n            vec4(1.0, 0.0, 0.0, 0.0),\n            vec4(0.0, c, -s, 0.0),\n            vec4(0.0, s, c, 0.0),\n            vec4(0.0, 0.0, -2.0 + ratio * 1.8, 1.0)\n        );\n    }\n    if (slide >= START_FRAME_3D + 10) {\n        return mat4(\n            vec4(1.0, 0.0, 0.0, 0.0),\n            vec4(0.0, 0.0, -1.0, 0.0),\n            vec4(0.0, 1.0, 0.0, 0.0),\n            vec4(0.0, 0.0, -0.2, 1.0)\n        );\n    }\n}\n\n\n\nconst ivec2 char_space = ivec2(0, 0);\nconst ivec2 char_exclam = ivec2(-2147352576, 135274560);\nconst ivec2 char_quotedbl = ivec2(0, 338186240);\nconst ivec2 char_numbersign = ivec2(-494600192, 338229411);\nconst ivec2 char_dollar = ivec2(-2058944512, 475277538);\nconst ivec2 char_percent = ivec2(1179385856, 105660480);\nconst ivec2 char_ampersand = ivec2(-1572143104, 68429858);\nconst ivec2 char_quoteright = ivec2(0, 135270400);\nconst ivec2 char_parenleft = ivec2(1090781184, 269488160);\nconst ivec2 char_parenright = ivec2(16842752, 68173953);\nconst ivec2 char_asterisk = ivec2(-985530368, 139751489);\nconst ivec2 char_plus = ivec2(-2130706432, 1057264);\nconst ivec2 char_comma = ivec2(16908800, 0);\nconst ivec2 char_hyphen = ivec2(0, 224);\nconst ivec2 char_period = ivec2(131072, 0);\nconst ivec2 char_slash = ivec2(1077936128, 4210752);\nconst ivec2 char_zero = ivec2(578945024, 136874258);\nconst ivec2 char_one = ivec2(-2130247680, 135798848);\nconst ivec2 char_two = ivec2(1078951936, 474251456);\nconst ivec2 char_three = ivec2(71761920, 1044398274);\nconst ivec2 char_four = ivec2(-503054336, 271601811);\nconst ivec2 char_five = ivec2(71761920, 1040480514);\nconst ivec2 char_six = ivec2(608632832, 403179762);\nconst ivec2 char_seven = ivec2(1082195968, 1044398144);\nconst ivec2 char_eight = ivec2(608632832, 474253538);\nconst ivec2 char_nine = ivec2(33751040, 474253794);\nconst ivec2 char_colon = ivec2(131072, 8192);\nconst ivec2 char_semicolon = ivec2(16908800, 8192);\nconst ivec2 char_less = ivec2(1090781184, 269488144);\nconst ivec2 char_equal = ivec2(-536870912, 63491);\nconst ivec2 char_greater = ivec2(16842752, 68174081);\nconst ivec2 char_question = ivec2(-2147352576, 474234944);\nconst ivec2 char_at = ivec2(-1605959680, 474278227);\nconst ivec2 char_A = ivec2(-465010688, 136874259);\nconst ivec2 char_B = ivec2(608665600, 507807986);\nconst ivec2 char_C = ivec2(608632832, 474220560);\nconst ivec2 char_D = ivec2(608665600, 507808018);\nconst ivec2 char_E = ivec2(542081024, 1040451824);\nconst ivec2 char_F = ivec2(541097984, 1040451824);\nconst ivec2 char_G = ivec2(609157120, 474220563);\nconst ivec2 char_H = ivec2(608731136, 574917106);\nconst ivec2 char_I = ivec2(-2130247680, 470818880);\nconst ivec2 char_J = ivec2(71761920, 541098242);\nconst ivec2 char_K = ivec2(-1572306944, 572794928);\nconst ivec2 char_L = ivec2(542081024, 33818640);\nconst ivec2 char_M = ivec2(608731136, 577546578);\nconst ivec2 char_N = ivec2(608731136, 574921043);\nconst ivec2 char_O = ivec2(608632832, 474253586);\nconst ivec2 char_P = ivec2(541097984, 507807984);\nconst ivec2 char_Q = ivec2(-1572143104, 474253586);\nconst ivec2 char_R = ivec2(-1572306944, 507807984);\nconst ivec2 char_S = ivec2(71761920, 474220770);\nconst ivec2 char_T = ivec2(-2130575360, 1041244224);\nconst ivec2 char_U = ivec2(608632832, 574916882);\nconst ivec2 char_V = ivec2(1090650112, 574916769);\nconst ivec2 char_W = ivec2(-1522204672, 574916946);\nconst ivec2 char_X = ivec2(1145602048, 574902337);\nconst ivec2 char_Y = ivec2(-2130575360, 574902336);\nconst ivec2 char_Z = ivec2(1078951936, 1044398144);\nconst ivec2 char_bracketleft = ivec2(1083113472, 1007161376);\nconst ivec2 char_backslash = ivec2(67108864, 266305);\nconst ivec2 char_bracketright = ivec2(34045952, 505430145);\nconst ivec2 char_asciicircum = ivec2(0, 136873984);\nconst ivec2 char_underscore = ivec2(1015808, 0);\nconst ivec2 char_quotereversed = ivec2(0, 135282688);\nconst ivec2 char_a = ivec2(-1001455616, 28931);\nconst ivec2 char_b = ivec2(608665600, 33847570);\nconst ivec2 char_c = ivec2(542048256, 61456);\nconst ivec2 char_d = ivec2(609157120, 541126930);\nconst ivec2 char_e = ivec2(-532217856, 28947);\nconst ivec2 char_f = ivec2(-2130575360, 269492448);\nconst ivec2 char_g = ivec2(609161244, 61714);\nconst ivec2 char_h = ivec2(608731136, 33847570);\nconst ivec2 char_i = ivec2(-2130247680, 134230080);\nconst ivec2 char_j = ivec2(-2130574332, 134225984);\nconst ivec2 char_k = ivec2(-1031208960, 67670176);\nconst ivec2 char_l = ivec2(-2130247680, 202383424);\nconst ivec2 char_m = ivec2(-1521844224, 22866);\nconst ivec2 char_n = ivec2(608731136, 30994);\nconst ivec2 char_o = ivec2(608632832, 28946);\nconst ivec2 char_p = ivec2(608665858, 30994);\nconst ivec2 char_q = ivec2(609161248, 61714);\nconst ivec2 char_r = ivec2(1082195968, 53344);\nconst ivec2 char_s = ivec2(-1006141440, 61457);\nconst ivec2 char_t = ivec2(-2130444288, 135295040);\nconst ivec2 char_u = ivec2(609157120, 35090);\nconst ivec2 char_v = ivec2(1115815936, 35089);\nconst ivec2 char_w = ivec2(-1522204672, 35090);\nconst ivec2 char_x = ivec2(-2104983552, 34976);\nconst ivec2 char_y = ivec2(609161244, 35090);\nconst ivec2 char_z = ivec2(-2138079232, 63616);\nconst ivec2 char_braceleft = ivec2(-2129920000, 806363168);\nconst ivec2 char_brokenbar = ivec2(-2130575360, 135274496);\nconst ivec2 char_braceright = ivec2(-2130608128, 101720192);\nconst ivec2 char_asciitilde = ivec2(0, 72630272);\nconst ivec2 char_filledbox = ivec2(-405831680, 1048377843);\nconst ivec2 char_sterling = ivec2(1083146240, 407375984);\nconst ivec2 char_quotesingle = ivec2(0, 135274496);\nconst ivec2 char_arrowleft = ivec2(1090519040, 1053168);\nconst ivec2 char_onehalf = ivec2(-1543240648, 33818641);\nconst ivec2 char_arrowright = ivec2(16777216, 1065457);\nconst ivec2 char_arrowup = ivec2(-2130706432, 1077584);\nconst ivec2 char_emdash = ivec2(0, 496);\nconst ivec2 char_onequarter = ivec2(1175067680, 67637282);\nconst ivec2 char_dblverticalbar = ivec2(1116012544, 338186401);\nconst ivec2 char_threequarters = ivec2(1711938592, 101718082);\nconst ivec2 char_divide = ivec2(16777216, 1049072);\nconst ivec2 char_comma_saa5051 = ivec2(8454400, 0);\nconst ivec2 char_period_saa5051 = ivec2(25362432, 0);\nconst ivec2 char_colon_saa5051 = ivec2(65536, 32);\nconst ivec2 char_semicolon_saa5051 = ivec2(8454400, 4096);\nconst ivec2 char_section = ivec2(596119836, 474220770);\nconst ivec2 char_Adieresis = ivec2(-465010688, 335573267);\nconst ivec2 char_Odieresis = ivec2(608632832, 335573266);\nconst ivec2 char_Udieresis = ivec2(608632832, 335579410);\nconst ivec2 char_degree = ivec2(0, 407396352);\nconst ivec2 char_adieresis = ivec2(-1001455616, 335573251);\nconst ivec2 char_odieresis = ivec2(608632832, 2621666);\nconst ivec2 char_udieresis = ivec2(609157120, 2621714);\nconst ivec2 char_germandbls = ivec2(608600322, 203704530);\nconst ivec2 char_currency = ivec2(1133019136, 35041);\nconst ivec2 char_Eacute = ivec2(-531660800, 269547537);\nconst ivec2 char_D_saa5052 = ivec2(1149698048, 474517794);\nconst ivec2 char_L_saa5052 = ivec2(1083113472, 67637280);\nconst ivec2 char_Aring = ivec2(-465010688, 134246675);\nconst ivec2 char_eacute = ivec2(-532217856, 269512979);\nconst ivec2 char_aring = ivec2(-1001455616, 134246659);\nconst ivec2 char_ccedilla = ivec2(542050312, 61456);\nconst ivec2 char_ugrave = ivec2(609157120, 68192530);\nconst ivec2 char_agrave = ivec2(-1001455616, 68186371);\nconst ivec2 char_ograve = ivec2(608632832, 68157666);\nconst ivec2 char_egrave = ivec2(-532217856, 68186387);\nconst ivec2 char_igrave = ivec2(-2130247680, 68157536);\nconst ivec2 char_idieresis = ivec2(-2130247680, 335556672);\nconst ivec2 char_edieresis = ivec2(-532217856, 335573267);\nconst ivec2 char_ecircumflex = ivec2(-532217856, 136868115);\nconst ivec2 char_ugrave_saa5054 = ivec2(609157120, 136349970);\nconst ivec2 char_icircumflex = ivec2(-2130247680, 136839264);\nconst ivec2 char_acircumflex = ivec2(-1001455616, 136868099);\nconst ivec2 char_ocircumflex_saa5054 = ivec2(608632832, 136868114);\nconst ivec2 char_ucircumflex = ivec2(609157120, 136839442);\nconst ivec2 char_ccedilla_saa5054 = ivec2(542050328, 61456);\n\nconst ivec2[10] NUM_2_CHAR = ivec2[](\n    char_zero,\n    char_one,\n    char_two,\n    char_three,\n    char_four,\n    char_five,\n    char_six,\n    char_seven,\n    char_eight,\n    char_nine\n);\n\n\n\nconst ivec2[11] SHADERTOY = ivec2[](\n    char_space,\n    char_S,\n    char_h,\n    char_a,\n    char_d,\n    char_e,\n    char_r,\n    char_t,\n    char_o,\n    char_y,\n    char_space\n);\n\nconst ivec2[33] PUSHING_PIXEL_SHADERS_TO_THE_MAX = ivec2[](\n    char_P,\n    char_u,\n    char_s,\n    char_h,\n    char_i,\n    char_n,\n    char_g,\n    char_space,\n    char_p,\n    char_i,\n    char_x,\n    char_e,\n    char_l,\n    char_space,\n    char_s,\n    char_h,\n    char_a,\n    char_d,\n    char_e,\n    char_r,\n    char_s,\n    char_space,\n    char_t,\n    char_o,\n    char_space,\n    char_t,\n    char_h,\n    char_e,\n    char_space,\n    char_m,\n    char_a,\n    char_x,\n    char_space\n);\n\n\nconst ivec2[11] INTERACTION = ivec2[](\n    char_I,\n    char_n,\n    char_t,\n    char_e,\n    char_r,\n    char_a,\n    char_c,\n    char_t,\n    char_i,\n    char_o,\n    char_n\n);\n\nconst ivec2[33] BETTER_THAN_JUST_VISUALS = ivec2[](\n    char_space,\n    char_space,\n    char_space,\n    char_space,\n    char_B,\n    char_e,\n    char_t,\n    char_t,\n    char_e,\n    char_r,\n    char_space,\n    char_t,\n    char_h,\n    char_a,\n    char_n,\n    char_space,\n    char_j,\n    char_u,\n    char_s,\n    char_t,\n    char_space,\n    char_v,\n    char_i,\n    char_s,\n    char_u,\n    char_a,\n    char_l,\n    char_s,\n    char_space,\n    char_space,\n    char_space,\n    char_space,\n    char_space\n);\n\n\nconst ivec2[11] STATE = ivec2[](\n    char_space,\n    char_space,\n    char_space,\n    char_s,\n    char_t,\n    char_a,\n    char_t,\n    char_e,\n    char_space,\n    char_space,\n    char_space\n);\n\nbool sample_underlying_5x9(vec2 coord, ivec2 char) {\n    int pos_id = int(coord.x * 7.0) + int(coord.y * 9.0) * 7;\n    int num = pos_id < 32 ? char.x : char.y;\n    int val = (1 << pos_id) & num;\n    return val != 0;\n}\n\n\nbool sample_virtual_10x18(vec2 coord, ivec2 char) {\n    vec2 coordscaled = clamp(coord * vec2(7, 9), vec2(0.0), vec2(6.4, 8.4));\n    ivec4 pos_id = ivec4(\n        int(coordscaled.x + 0.5) + int(coordscaled.y - 0.5) * 7,\n        int(coordscaled.x + 0.5) + int(coordscaled.y + 0.5) * 7,\n        int(coordscaled.x - 0.5) + int(coordscaled.y + 0.5) * 7,\n        int(coordscaled.x - 0.5) + int(coordscaled.y - 0.5) * 7\n    );\n    ivec4 selector = ivec4(lessThan(pos_id, ivec4(32))); // Select if X or Y bit\n    ivec4 nums = selector * ivec4(char.x) + (1 - selector) * ivec4(char.y);\n    ivec4 bits = ivec4(1) << pos_id;\n    bvec4 vals = equal(bits & nums, ivec4(0));\n           \n    \n    bool diagonals =  (vals.x == vals.z) && (vals.y == vals.a) && (vals.x != vals.y);\n    return (diagonals || sample_underlying_5x9(coord, char));\n}\n\n\n\nfloat draw_char(vec2 coord, ivec2 char) {\n    /*int pos_id = int(coord.x * 7.0) + int(coord.y * 9.0) * 7;\n    int num = pos_id < 32 ? char.x : char.y;\n    \n    int val = (1 << pos_id) & num;\n    float col = val == 0 ? 0.0 : 1.0;\n    \n    return col;*/\n    float col = sample_virtual_10x18(coord, char) ? 1.0 : 0.0;\n    return col;\n\n}\n\n\n\nfloat draw_text_5(vec2 coord, ivec2[5] text_string, ivec2 text_box) {\n    int i = 0;\n    float out_col = 0.0;\n    \n    coord.x *= float(text_box.x);\n    coord.y *= float(text_box.y);\n    int char = int(coord.x) + (text_box.y - int(coord.y) - 1) * text_box.x;\n    coord.x -= float(int(coord.x));\n    coord.y -= float(int(coord.y));\n\treturn draw_char(coord, text_string[char]);\n}\n\nfloat draw_text_11(vec2 coord, ivec2[11] text_string, ivec2 text_box) {\n    int i = 0;\n    float out_col = 0.0;\n    \n    coord.x *= float(text_box.x);\n    coord.y *= float(text_box.y);\n    int char = int(coord.x) + (text_box.y - int(coord.y) - 1) * text_box.x;\n    coord.x -= float(int(coord.x));\n    coord.y -= float(int(coord.y));\n\treturn draw_char(coord, text_string[char]);\n}\nfloat draw_text_33(vec2 coord, ivec2[33] text_string, ivec2 text_box) {\n    int i = 0;\n    float out_col = 0.0;\n    \n    coord.x *= float(text_box.x);\n    coord.y *= float(text_box.y);\n    int char = int(coord.x) + (text_box.y - int(coord.y) - 1) * text_box.x;\n    coord.x -= float(int(coord.x));\n    coord.y -= float(int(coord.y));\n\treturn draw_char(coord, text_string[char]);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// State Management\n\n#define BUFFER_STATE iChannel0\n#define BUFFER_KEYS iChannel1\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 address = ivec2(fragCoord);\n    \n    if (address == ADDRESS_PRESENTATION_STATE) {\n        // Red = slide number\n        // Green = target_slide\n        // Blue = unused\n        // Alpha = transition_state (betwen 0.0 and 1.0)\n\n\n        vec4 current_state = read_data(BUFFER_STATE, ADDRESS_PRESENTATION_STATE);\n        if (iFrame == 1) {\n            current_state = vec4(0);\n        }\n        \n        current_state.g += get_key_edge(BUFFER_KEYS, KEY_SPACE);\n        current_state.g += get_key_edge(BUFFER_KEYS, KEY_NEXT);\n        current_state.g -= get_key_edge(BUFFER_KEYS, KEY_PREV);\n        current_state.g = clamp(current_state.g, 0.0, float(SLIDE_COUNT));\n        \n        // Fade Transition\n        int change = int(current_state.g - current_state.r);\n        if (change >= 0) {\n            current_state.a += float(change + 1) * iTimeDelta;\n        } else {\n            current_state.a += float(change) * iTimeDelta;\n        }\n        \n        // Switch between slides\n        if (change < 0) {\n            if (current_state.a < 0.0) {\n                current_state.r -= 1.0; // Decrement Slide\n                current_state.a = 1.0; // Set to end of transition\n            }\n        } if (change > 0) {\n            if (current_state.a > 1.0) {\n                current_state.r += 1.0;  // Increment Slide\n                current_state.a = 0.0; // Set to beginning of transition\n            }\n        }\n        current_state.a = clamp(current_state.a, 0.0, 1.0);\n        \n        current_state.b = iTime;\n        \n        \n        fragColor = current_state;\n        return;\n    }\n    \n    fragColor = vec4(0.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// 3D stuff\n\n#define BUFFER_STATE iChannel0\n\n\n// The signed distance field\n\nconst float LENS = 0.5;\n\n// Trace Parameters\nconst int MAX_STEPS = 120;\nconst float DRAW_DISTANCE = 8.0; // Note that this can be shorter than FOG_DISTANCE because of the FOG_OVERBLOOM\n\n\nconst float PI = 3.14159;\nconst float MAJOR_LINES = 6.0;\nconst float MAJOR_LINE_WIDTH = MAJOR_LINES * 0.002;\nconst float MINOR_LINES = MAJOR_LINES * 5.0;\nconst float MINOR_LINE_WIDTH = MINOR_LINES * 0.001;\n\nconst float MAJOR_LINE_INTENSITY = 0.03;\nconst float MINOR_LINE_INTENSITY = 0.05;\n\n\nvec3 world_background(vec3 rayDirection) {\n\n    float r2 = dot(rayDirection.xy, rayDirection.xy);\n    float elevation = acos(rayDirection.z / sqrt(r2 + rayDirection.z * rayDirection.z));\n    float angle = atan(rayDirection.y, rayDirection.x);\n    \n\n    float elevationPercent = (0.5 - elevation / PI) * 2.0;\n    vec3 baseColor = mix(vec3(0,0,0.8), vec3(0,0,0.2), elevationPercent);\n    vec3 horizonColor1 = mix(vec3(0,0.9, 0.2), vec3(0,0,0), pow(clamp(elevationPercent, 0.0, 1.0), 0.7));\n    vec3 horizonColor2 = mix(vec3(0.8, 0.0, 0.0), vec3(0,0,0), pow(clamp(elevationPercent * 2.0, 0.0, 1.0), 0.7));\n\n\n    float lines = 0.0;\n    lines += clamp((abs(fract(elevation / PI * MAJOR_LINES) - 0.5) * 2.0 - 1.0 + MAJOR_LINE_WIDTH) /  MAJOR_LINE_WIDTH, 0.0, 1.0) * MAJOR_LINE_INTENSITY;\n    lines += clamp((abs(fract(angle / PI * MAJOR_LINES) - 0.5) * 2.0 - 1.0 + MAJOR_LINE_WIDTH) / MAJOR_LINE_WIDTH, 0.0, 1.0) * MAJOR_LINE_INTENSITY;\n    lines += clamp((abs(fract(elevation / PI * MINOR_LINES) - 0.5) * 2.0 - 1.0 + MINOR_LINE_WIDTH) /  MINOR_LINE_WIDTH, 0.0, 1.0) * MINOR_LINE_INTENSITY;\n    lines += clamp((abs(fract(angle / PI * MINOR_LINES) - 0.5) * 2.0 - 1.0 + MINOR_LINE_WIDTH) / MINOR_LINE_WIDTH, 0.0, 1.0) * MINOR_LINE_INTENSITY;\n\n\n    vec3 col = baseColor;\n    col += horizonColor1;\n    col += horizonColor2;\n\n    col += lines;\n\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 presentation_state = read_data(BUFFER_STATE, ADDRESS_PRESENTATION_STATE);\n\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 raw_uv = fragCoord/iResolution.xy;\n    vec2 uv = raw_uv;\n    uv = (uv - 0.5) * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Render our geometry\n    mat4 camera_transform = get_camera_transform(presentation_state);\n    \n    vec3 start_point = camera_transform[3].xyz;\n    vec3 direction = normalize(vec3(uv * LENS, 1.0));\n    direction = (camera_transform * vec4(direction, 0.0)).xyz;\n    \n    vec4 data = raymarch(start_point, direction, MAX_STEPS, DRAW_DISTANCE, presentation_state);\n    vec3 surface_normal = calc_normal(data.xyz, presentation_state);\n    \n    if (data.a >= 1.0) {\n        fragColor = vec4(world_background(direction), 1.0); \n    } else {\n        int slide = int(presentation_state.r);\n        \n        if (slide <= START_FRAME_3D + 8) {\n            fragColor = vec4(vec3(1.0), data.a);\n            return;\n        }\n        else if (slide == START_FRAME_3D + 9) {\n            float angle = 3.14 / (presentation_state.a + 0.2);\n            float lighting = dot(surface_normal, vec3(sin(angle), cos(angle), -0.5));\n            lighting = lighting * 0.5 + 0.5;\n            lighting = mix(1.0, lighting, presentation_state.a);\n            vec3 color = vec3(lighting);\n            color = mix(color, world_background(direction), data.a * presentation_state.a);\n            \n            fragColor = vec4(color, data.a);\n            return;\n        }\n        else if (slide == START_FRAME_3D + 10) {\n            float angle = 3.14 / (1.0 + 0.2);\n            float lighting = dot(surface_normal, vec3(sin(angle), cos(angle), -0.5));\n            lighting = lighting * 0.5 + 0.5;\n            vec3 color = vec3(lighting);\n            color = mix(color, world_background(direction), data.a);\n            \n            fragColor = vec4(color, data.a);\n            return;\n        }\n        else if (slide == START_FRAME_3D + 11) {\n            float angle = 3.14 / (1.0 + 0.2);\n            float lighting = dot(surface_normal, vec3(sin(angle), cos(angle), -0.5));\n            lighting = lighting * 0.5 + 0.5;\n            vec3 color = vec3(lighting);\n            color = mix(color, world_background(direction), data.a);\n            \n            fragColor = vec4(color, data.a);\n            return;\n        }\n        \n        \n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Text/HUD\n\n#define BUFFER_STATE iChannel0\n\n\nfloat draw_title_screen(vec2 uv, ivec2[11] main_title, ivec2[33] subtitle, float transition){\n    \n    vec2 centered = (uv - 0.5) * 2.0 + vec2(0.0, 0.1);\n    \n    // Horizontal Line\n    if (all(lessThan(abs(centered), vec2(0.8, 0.01)))) {\n        return 1.0 - transition;\n    }\n    // Title\n    vec2 title_size = vec2(0.65, 0.15);\n    vec2 title_coord = (centered + vec2(transition * 5.0, -0.22)) / title_size;\n    if (all(lessThan(abs(title_coord), vec2(1.0)))) {\n        return draw_text_11((title_coord + 1.0) * 0.5, main_title, ivec2(11, 1));\n    }\n    \n    vec2 subtitle_size = vec2(0.75, 0.05);\n    vec2 subtitle_coord = (centered + vec2(transition * -5.0, 0.1)) / subtitle_size;\n    if (all(lessThan(abs(subtitle_coord), vec2(1.0)))) {\n        return draw_text_33((subtitle_coord + 1.0) * 0.5, subtitle, ivec2(33, 1));\n    }\n    \n    return 0.0;\n}\n\n\n\nfloat draw_slide_number(vec2 uv, int slide_number, int slide_count) {\n    ivec2[5] text = ivec2[](\n        NUM_2_CHAR[(slide_number / 10) % 10],\n        NUM_2_CHAR[(slide_number) % 10],\n        char_slash,\n        NUM_2_CHAR[(slide_count / 10) % 10],\n        NUM_2_CHAR[(slide_count) % 10]\n    );\n    \n    vec2 slide_number_size = vec2(0.1, 0.05);\n    vec2 slide_number_coord = (uv) / slide_number_size;\n    \n    if (all(lessThan(abs(slide_number_coord), vec2(1.0)))) {\n        return draw_text_5((slide_number_coord), text, ivec2(5, 1));\n    }\n    return 0.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 presentation_state = read_data(BUFFER_STATE, ADDRESS_PRESENTATION_STATE);\n    int slide_number = int(presentation_state.r);\n    \n    \n    float text = 0.0;\n    \n    if (slide_number == 0){\n        text = draw_title_screen(\n            uv, \n            SHADERTOY,\n            PUSHING_PIXEL_SHADERS_TO_THE_MAX,\n            1.0 - presentation_state.a\n        );\n    }\n    else if (slide_number == 1){\n        text = draw_title_screen(\n            uv, \n            SHADERTOY,\n            PUSHING_PIXEL_SHADERS_TO_THE_MAX,\n            presentation_state.a\n        );\n    } else if (slide_number == START_FRAME_INTERACTION) {\n        text = draw_title_screen(\n            uv, \n            INTERACTION,\n            BETTER_THAN_JUST_VISUALS,\n            1.0 - presentation_state.a\n        );\n    } else if (slide_number == START_FRAME_INTERACTION + 1) {\n        text = draw_title_screen(\n            uv, \n            INTERACTION,\n            BETTER_THAN_JUST_VISUALS,\n            presentation_state.a\n        );\n    }else if (slide_number == START_FRAME_STATE) {\n        text = draw_title_screen(\n            uv, \n            STATE,\n            BETTER_THAN_JUST_VISUALS,\n            1.0 - presentation_state.a\n        );\n    } else if (slide_number == START_FRAME_STATE + 1) {\n        text = draw_title_screen(\n            uv, \n            STATE,\n            BETTER_THAN_JUST_VISUALS,\n            presentation_state.a\n        );\n    }\n    \n    text += draw_slide_number(\n        uv,\n        slide_number,\n        SLIDE_COUNT\n    );\n        \n    \n    // if (uv.x < 0.1 && uv.y < presentation_state.a) {\n    //     text += 0.5;\n    // }\n\n    // Output to screen\n    fragColor = vec4(vec3(1.0), text);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// 2D stuff\n\n\n#define BUFFER_STATE iChannel0\n#define BUFFER_KEYS iChannel1\n#define BUFFER_LOOP iChannel2\n\n\n\nvec3 distance_from_segment(vec2 point, vec2 segment_start, vec2 segment_end) {\n    // the first component is the distance, second and third component are\n    // direction to the line segment\n    vec2 line_direction = segment_start - segment_end;\n    vec2 point_on_line = segment_end;\n    float segment_length = length(line_direction);\n\n\n    float projected_distance = dot(normalize(line_direction), point - point_on_line);\n    vec2 closest_point = point_on_line + projected_distance * line_direction / segment_length;\n\n    float distance_from_end = -projected_distance;\n    float distance_from_start = projected_distance - segment_length;\n\n    // Rounded caps on segment\n    if (distance_from_start > 0.0) {\n        closest_point = segment_start;\n    }\n    if (distance_from_end > 0.0) {\n        closest_point = segment_end;\n    }\n\n    return vec3(\n        length(point - closest_point),\n        normalize(point - closest_point).xy\n    );\n}\n\nvec3 start_col(vec2 uv) {\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    return col;\n}\n\nvec3 basegraph(vec2 uv, vec2 arm_length) {\n    vec3 col = vec3(0.0);\n    col.rgb += vec3( \n        step(\n            distance_from_segment(\n                uv, \n                vec2(0.0), \n                vec2(arm_length.x, 0.0)\n            ).x, \n            0.005\n        )\n    );\n    col.rgb += vec3(\n        step(\n            distance_from_segment(\n                uv, \n                vec2(0.0), \n                vec2(0.0, arm_length.y)\n            ).x, \n            0.005\n        )\n    );\n    return col;\n\n}\n\nfloat red_equal_x(vec2 uv) {\n    vec2 text_size = vec2(0.2, 0.05);\n    vec2 text_coord = (uv) / text_size + vec2(-2.0, 1.5);\n\n    if (all(lessThan(abs(text_coord), vec2(1.0)))) {\n        return draw_text_5((text_coord + 1.0) * 0.5, ivec2[](char_r, char_space, char_equal, char_space, char_x), ivec2(5, 1));\n    }\n    return 0.0;\n}\nfloat green_equal_y(vec2 uv) {\n    vec2 text_size = vec2(0.2, 0.05);\n    vec2 text_coord = (uv) / text_size + vec2(1.5, -7.0);\n\n    if (all(lessThan(abs(text_coord), vec2(1.0)))) {\n        return draw_text_5((text_coord + 1.0) * 0.5, ivec2[](char_g, char_space, char_equal, char_space, char_y), ivec2(5, 1));\n    }\n    return 0.0;\n}\n\nfloat threshold(vec2 uv) {\n    vec2 text_size = vec2(0.4, 0.10);\n    vec2 text_coord = (uv) / text_size;\n\n    if (all(lessThan(abs(text_coord), vec2(1.0)))) {\n        return draw_text_5((text_coord + 1.0) * 0.5, ivec2[](char_greater, char_space, char_zero, char_period, char_five), ivec2(5, 1));\n    }\n    return 0.0;\n}\n\nfloat mirror(vec2 uv) {\n    vec2 text_size = vec2(0.4, 0.10);\n    vec2 text_coord = (uv) / text_size;\n\n    if (all(lessThan(abs(text_coord), vec2(1.0)))) {\n        return draw_text_5((text_coord + 1.0) * 0.5, ivec2[](char_a, char_b, char_s, char_parenleft, char_parenright), ivec2(5, 1));\n    }\n    return 0.0;\n}\n\nfloat draw_box(vec2 uv) {\n    float s = sin(-3.14159265359 / 4.0);\n    float c = cos(-3.14159265359 / 4.0);\n    mat2 r = mat2(c, s, -s, c);\n    uv = r * uv;\n        \n    vec2 text_size = vec2(0.5, 0.15);\n    vec2 text_coord = (uv) / text_size;\n\n    if (all(lessThan(abs(text_coord), vec2(1.0)))) {\n        return draw_text_5((text_coord + 1.0) * 0.5, ivec2[](char_space, char_B, char_o, char_x, char_space), ivec2(5, 1));\n    }\n    return 0.0;\n}\n\n// 2D\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 raw_uv = fragCoord/iResolution.xy;\n    vec2 uv = raw_uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec4 presentation_state = read_data(BUFFER_STATE, ADDRESS_PRESENTATION_STATE);\n    int slide = int(presentation_state.r);\n    \n    vec4 col = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    float forw = presentation_state.a;\n    float inv = (1.0 - presentation_state.a);\n    float ease = easeInOutQuad(forw);\n    \n    \n    if (slide == 0) {\n        col = vec4(start_col(uv), 1.0);\n    }\n    else if (slide == 1) {\n        col = vec4(start_col(uv) * inv, 1.0);\n        \n    } else if (slide == 2) {\n        col = vec4(\n            mix(vec3(0.0), vec3(uv.x, 0.0, 0.0), ease),\n            1.0\n        );\n        col.rgb += basegraph(uv, vec2(ease, 0.0));\n        col.rgb += vec3(red_equal_x(uv) * ease);\n    } else if (slide == 3) {\n        col = vec4(\n            mix(vec3(uv.x, 0.0, 0.0), vec3(uv.x, uv.y, 0.0), ease),\n            1.0\n        );\n        col.rgb += basegraph(uv, vec2(1.0, ease));\n        col.rgb += vec3(red_equal_x(uv));\n        col.rgb += vec3(green_equal_y(uv) * ease);\n        \n    } else if (slide == 4) {\n        col = mix(\n            vec4(uv, 0.0, 1.0) + vec4(basegraph(uv, vec2(1.0)), 0.0),\n            vec4(vec3(abs(uv), 0.0), 1.0),\n            ease\n        );\n        col.rgb += vec3(red_equal_x(uv) * (1.0 - ease));\n        col.rgb += vec3(green_equal_y(uv) * (1.0 - ease));\n        col.rgb += vec3(mirror(uv) * ease);\n    } else if (slide == 5) {\n        col = mix(\n            vec4(vec3(abs(uv), 0.0), 1.0),\n            vec4(step(vec2(0.5), abs(uv)), 0.0, 1.0),\n            ease\n        );\n        col.rgb += vec3(mirror(uv) * (1.0 - ease));\n        col.rgb += vec3(threshold(uv) * ease);\n    } else if (slide == 6) {\n        float easeout = easeOutQuad(clamp(inv * 3.0 - 2.0, 0.0, 1.0));\n    \n        vec4 old = vec4(step(vec2(0.5), abs(uv)), 0.0, 1.0);\n        old.rgb += vec3(threshold(uv));\n\n        uv += vec2(\n            (sin(forw * 14.0) + cos(forw * 18.345) + cos(forw * 34.345)) * 0.05,\n            (sin(forw * 20.0) + cos(forw * 17.345) + cos(forw * 43.345)) * 0.2\n        ) * easeout;\n    \n        float box = all(greaterThan(vec2(0.5), abs(uv))) ? 0.0 : 1.0;\n        vec4 new = vec4(vec3(box), 1.0);\n        new.rgb += vec3(draw_box(uv));\n\n        col = mix(new, old, easeout);\n\n    } else if (slide == 7) {\n        float s = sin(ease * 3.14159265359 / 2.0);\n        float c = cos(ease * 3.14159265359 / 2.0);\n        mat2 r = mat2(c, s, -s, c);\n        uv = r * uv;\n        \n        float box = all(greaterThan(vec2(0.5), abs(uv))) ? 0.0 : 1.0;\n        col = mix(\n            vec4(vec3(box), 1.0),\n            vec4(vec3(1.0 - box), 1.0 - box),\n            ease\n        );\n        col.rgb += vec3(draw_box(uv)) * (0.5 - ease) * 2.0;\n\n    } else if (slide == 8) {        \n        uv = vec2(-uv.y, uv.x);\n        uv /= clamp(1.0 - forw * 2.0, 0.0, 1.0);\n    \n        float box = all(greaterThan(vec2(0.5), abs(uv))) ? 0.0 : 1.0;\n        col = vec4(vec3(1.0 - box), 1.0 - box);\n        col.rgb -= vec3(draw_box(uv));\n    }\n    \n    else if (slide <= START_FRAME_3D) {\n        col = vec4(uv.x, uv.y, 1.0, 1.0);\n    }\n    else if (slide == START_FRAME_INTERACTION + 1) {\n        // Keyboard Tex\n        vec4 keys = vec4(vec3(texture(BUFFER_KEYS, fragCoord/iResolution.xy).r), 1.0);\n        col += keys * ease;\n    } else if (slide == START_FRAME_INTERACTION + 2) {\n        // Mouse Simple\n        vec3 keys = vec3(texture(BUFFER_KEYS, raw_uv).r);\n        vec2 mouse = (iMouse.xy / iResolution.xy);\n        col = vec4(mix(keys, vec3(mouse, 0.0), ease), 1.0);\n    }\n    else if (slide == START_FRAME_INTERACTION + 3) {\n        // Mouse Dot\n        vec2 mouse_simple = (iMouse.xy / iResolution.xy);\n        vec3 mouse_dot = neon(1.0 - length(((fragCoord - iMouse.xy) / iResolution.x)), vec3(0.2, 0.6, 0.7));\n        col = vec4(mix(vec3(mouse_simple, 0.0), mouse_dot, ease), 1.0);\n    }\n    else if (slide == START_FRAME_INTERACTION + 4) {\n        vec3 mouse_dot = neon(1.0 - length(((fragCoord - iMouse.xy) / iResolution.x)), vec3(0.2, 0.6, 0.7));\n        col = vec4(mouse_dot, 1.0);\n    }\n    \n    else if (slide == START_FRAME_STATE + 1) {\n        // Static Screen Non Looped\n        vec3 mouse_dot = neon(1.0 - length(((fragCoord - iMouse.xy) / iResolution.x)), vec3(0.2, 0.6, 0.7));\n        float screen = clamp(dot(pow(abs(raw_uv - 0.5) * 1.5, vec2(4.0)), vec2(1)), 0.2, 0.6) - 0.15;\n        col = mix(vec4(mouse_dot, 1.0), vec4(vec3(screen), 1.0), ease);\n    }\n    else if (slide == START_FRAME_STATE + 2) {\n        // Screen Loop Tex\n        float screen = clamp(dot(pow(abs(raw_uv - 0.5) * 1.5, vec2(4.0)), vec2(1)), 0.2, 0.6) - 0.15;\n        \n\n        vec3 old_screen = texture(BUFFER_LOOP, raw_uv).rgb;\n\n        vec2 screen_uv = (raw_uv - 0.5);\n\n        float angle = sin(iTime * 5.0) * 0.05;\n        float s = sin(angle * 3.14159265359 / 2.0);\n        float c = cos(angle * 3.14159265359 / 2.0);\n        mat2 r = mat2(c, s, -s, c);\n        screen_uv = r * screen_uv;\n        screen_uv *= 1.1;\n        screen_uv += 0.5;\n        vec3 zoomed_screen = vec3(0.0);\n\n\n        if (screen_uv == clamp(screen_uv, vec2(0), vec2(1))){\n            zoomed_screen = texture(BUFFER_LOOP, screen_uv).rgb;\n            zoomed_screen.b += 0.02;\n            zoomed_screen.g += 0.01;\n        }\n\n        col = vec4(zoomed_screen * ease + screen, 1.0);\n    }\n    else if (slide == START_FRAME_STATE + 3) {\n        //Flame\n        vec2 uv = fragCoord/iResolution.xy;\n        vec2 delta = vec2(0.001, 0.01);\n        float heat_below = texture(BUFFER_LOOP, uv + vec2(0.0, -0.01), 2.0).a;\n        float airflow_velocity = heat_below;\n        delta *= airflow_velocity;\n\n        float heat_below_left = texture(BUFFER_LOOP, uv + vec2(delta.x, -delta.y)).a;\n        float heat_below_right = texture(BUFFER_LOOP, uv + vec2(-delta.x, -delta.y)).a;\n\n        vec3 rand = hash33(vec3(fragCoord, iTime)) - 0.5;\n        vec3 rand1 = hash33(vec3(iTime));\n\n        float diff = (heat_below_right - heat_below_left);\n        float ratio = clamp(-diff * 1.0 + rand1.x * 0.5, -0.5, 0.5);\n        float heat = mix(heat_below_left, heat_below_right, ratio + 0.5);\n        heat *= 0.97;\n\n\n        if (iFrame == 0) {\n            heat = 0.0;\n        }\n        vec2 offset = vec2(0.35 + rand.y * 0.1 + rand1.y * 0.2, 0.0);\n        float heat_source = clamp(1.0 - length((uv - offset) * vec2(2.0, 1.0)) * 10.0, 0.0, 1.0);\n\n\n        heat += heat_source;\n        float extra_heat = iMouse.z > 0.0 ? length(uv - iMouse.xy / iResolution.xy - rand.z * 0.02) : 1.0;\n        \n        heat += clamp(1.0 - extra_heat * 15.0, 0.0, 1.0);\n\n        col = vec4(neon(heat * 0.3, vec3(1.0, 0.5, 0.1)),heat);\n        \n    } else if (slide == START_FRAME_STATE + 4) {\n        vec2 pos = texture(BUFFER_LOOP, vec2(0, 0)).rg;\n        pos += vec2(\n            get_key(BUFFER_KEYS, 68) - get_key(BUFFER_KEYS, 65),\n            get_key(BUFFER_KEYS, 87) - get_key(BUFFER_KEYS, 83)\n        ) * 0.02;\n        \n        vec2 sprite_coords = (uv - pos) * vec2(5.0, 10.0);\n        float sprite = draw_char(sprite_coords, char_greater);\n        sprite = all(lessThan(abs(sprite_coords - 0.5), vec2(0.5))) ? sprite : 0.0;\n        \n        col = vec4(pos, sprite, 1.0);\n    }\n\n    fragColor = col;\n}","name":"Buffer D","description":"","type":"buffer"}]}