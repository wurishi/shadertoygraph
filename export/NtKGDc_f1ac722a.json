{"ver":"0.1","info":{"id":"NtKGDc","date":"1640552947","viewed":198,"name":"Indra's net 3d","username":"bunyk","description":"Trying to render Indra's net, see comment at the top of the code for description.\n\nThis often crashes when trying to render it with lot's of reflections and subpixels. If you have any ideas on how to optimize this - please share. Any tips are welcome.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["3d","raytracing","fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nFar away in the heavenly abode of the great god Indra,\nthere is a wonderful net which has been hung by some cunning artificer\nin such a manner that it stretches out infinitely in all directions.\nIn accordance with the extravagant tastes of deities,\nthe artificer has hung a single glittering jewel in each \"eye\" of the net,\nand since the net itself is infinite in dimension, the jewels are infinite in number.\nThere hang the jewels, glittering \"like\" stars in the first magnitude, a wonderful sight to behold.\nIf we now arbitrarily select one of these jewels for inspection and look closely at it,\nwe will discover that in its polished surface there are reflected all the other jewels in the net,\ninfinite in number. Not only that, but each of the jewels reflected in this one jewel is also reflecting\nall the other jewels, so that there is an infinite reflecting process occurring.\n\nhttps://en.wikipedia.org/wiki/Indra%27s_net\n\nMade with the help of https://raytracing.github.io/books/RayTracingInOneWeekend.html\n*/\n\nconst int MAX_REFLECTIONS = 15;\nconst float SUBPIXELS = 4.0; // multiplier of resolution for antialiasing. Increase for quality, decrease for performance\nconst float LINE_WIDTH = 0.05;\nconst float REFLECTIVITY = 0.90;\nconst vec3 SPHERE_ATTENNUATION = vec3(0.9, 0.8, 0.3);\nconst float SPHERE_RADIUS_SQR = 0.7 * 0.7;\n\nconst vec3 CAM_START_POS = vec3(0, 0, -1.0);\nconst vec3 CAM_DIR = vec3(0, 0, 1.0);\nconst float focal_length = 1.0;\n\nconst vec3 red = vec3(1, 0, 0);\nconst vec3 green = vec3(0, 1, 0);\nconst vec3 black = vec3(0);\nconst vec3 white = vec3(1);\n\n\nconst vec3 spheres[8] = vec3[](\n    vec3(-1,-1, -1),\n    vec3(1,-1, -1),\n    vec3(-1,1, -1),\n    vec3(1,1, -1),\n    vec3(-1,-1, 1),\n    vec3(1,-1, 1),\n    vec3(-1,1, 1),\n    vec3(1,1, 1)\n);\n\nstruct Plane {\n    vec3 Location;\n    vec3 Normal;\n};\n\nconst Plane planes[6] = Plane[](\n    Plane(vec3(1, -1, 1), vec3(0, 1, 0)),\n    Plane(vec3(1, 1, 1), vec3(0, -1, 0)),\n    Plane(vec3(-1, 1, 1), vec3(1, 0, 0)),\n    Plane(vec3(1, 1, 1), vec3(-1, 0, 0)),\n    Plane(vec3(1, 1, 1), vec3(0, 0, -1)),\n    Plane(vec3(1, 1, -1), vec3(0, 0, 1))\n);\n\n\nstruct Ray {\n    vec3 Origin;\n    vec3 Direction;\n};\n\n// https://en.wikipedia.org/wiki/Line%E2%80%93plane_intersection#Algebraic_form\nfloat hit_plane(in Plane p, in Ray r) {\n    float d = dot(r.Direction, p.Normal);\n    if(d == 0.0) {\n        return -1.0;\n    }\n    return dot(p.Location - r.Origin, p.Normal) / d;\n}\n\nvec2 planeUV(in Plane p, in vec3 hp) {\n    vec3 d = abs(hp - p.Location);\n    if (d.x <= d.y && d.x <= d.z) {\n        return d.yz;\n    }\n    if (d.y <= d.x && d.y <= d.z) {\n        return d.xz;\n    }\n    return d.xy;\n}\n\nRay getCamRay(in vec3 origin, in vec2 uv, in float aspect_ratio) {\n    float viewport_height = 2.0;\n    float viewport_width = aspect_ratio * viewport_height;\n\n    vec3 horizontal = vec3(viewport_width, 0, 0);\n    vec3 vertical = vec3(0, viewport_height, 0);\n    vec3 lower_left_corner = origin - horizontal/2.0 - vertical/2.0 + vec3(0, 0, focal_length);\n\n    return Ray(origin, normalize(lower_left_corner + uv.x * horizontal + uv.y*vertical - origin));\n}\n\n\nfloat hit_sphere(in vec3 center, in Ray r) {\n    vec3 oc = r.Origin - center;\n    float b = 2.0 * dot(oc, r.Direction);\n    float c = dot(oc, oc) - SPHERE_RADIUS_SQR;\n    float discriminant = b*b - 4.0*c;\n    if (discriminant < 0.0) {\n        return -1.0;\n    } else {\n        return (-b - sqrt(discriminant) ) * 0.5;\n    }\n}\n\n\nvec3 at(in Ray r, float t) {\n    return r.Origin + r.Direction * t;\n}\n\nvec3 rayColor(in Ray r) {\n    float t;\n    float min_t;\n    Ray newRay;\n    vec3 color;\n    bool returnColor = false;\n    int reflections = 0;\n    \n    for(int ref = 0; ref < MAX_REFLECTIONS; ref++) {\n        min_t = 100.0;\n        for(int i = 0; i < spheres.length(); i++) {\n            t = hit_sphere(spheres[i], r);\n            if ((t > 0.0) && (t < min_t)) { \n                min_t = t;\n                vec3 hp = at(r, t);\n                vec3 N = normalize(hp - spheres[i]);\n\n                newRay = Ray(\n                    hp, reflect(r.Direction, N)\n                );\n                returnColor = false;\n                reflections++;\n            }\n        }\n        for(int i = 0; i < planes.length(); i++) {\n            t = hit_plane(planes[i], r);\n            if ((t > 0.0) && (t < min_t)) {\n                min_t = t;\n                vec3 hp = at(r, t);\n                vec2 uv = planeUV(planes[i], hp);\n                float x = mod(uv.x, 2.0);\n                float y = mod(uv.y, 2.0);\n                if((x < LINE_WIDTH) || (y < LINE_WIDTH)) {\n                    color = white;\n                    returnColor = true;\n                } else {\n                    newRay = Ray(\n                        hp, reflect(r.Direction, planes[i].Normal)\n                    );\n                    returnColor = false;\n                }\n            }\n        }\n        if(returnColor) {\n            return color * pow(SPHERE_ATTENNUATION, vec3(float(reflections)));\n        }\n        if(min_t < 100.0) {\n            r = newRay;\n        } else {\n            break;\n        }\n   }\n   return black;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 camPos = CAM_START_POS + mod(iTime / 3.0, 2.0) * CAM_DIR;\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 subpixelUV = vec2(1, 1) / iResolution.xy / SUBPIXELS;\n    \n    vec3 col;\n    \n    for(float i = 0.0; i < SUBPIXELS; i++) {\n        for(float j = 0.0; j < SUBPIXELS; j++) {\n            Ray ray = getCamRay(camPos, uv + vec2(i, j) * subpixelUV, aspectRatio);\n            col += rayColor(ray);\n        }\n    }\n    col /= SUBPIXELS*SUBPIXELS;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}