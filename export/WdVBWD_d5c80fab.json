{"ver":"0.1","info":{"id":"WdVBWD","date":"1607167959","viewed":656,"name":"Shader Royale #2 - NuSan","username":"NuSan","description":"Shader coded live on stream for Shader Royale #2 (about 1h20) - 4 december 2020","likes":33,"published":1,"flags":0,"usePreview":0,"tags":["mosaic","live"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Shader coded live on stream for Shader Royale #2 (about 1h20) - 4 december 2020\n// Placed 3rd among 13 awesome shaders made simultaneously\n//\n// I added a bit of progression on time to this shadertoy version\n// so effects activate one after the other in the first 60s\n// I also added all the comments\n//\n// this shader may be a bit too fast if you don't have any music\n// you can lower the SPEED bellow to adjust to your taste\n\n#define SPEED 0.5\n#define COLOR_SHIFT 1\n#define CENTER_COLOR 1\n#define RAINBOW 1\n\nfloat time = 0.0;\nfloat progression = 0.0;\n\n// rotation matrix\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);  \n}\n\n// simple box distance field\nfloat box(vec3 p, vec3 s) {\n  p=abs(p)-s;\n  return max(p.x, max(p.y,p.z));\n}\n\n// random value\nfloat rnd(float t) {\n  return fract(sin(t*425.551)*974.512);  \n}\n\n// noise on uv \nfloat rnd(vec2 uv) {\n  return fract(dot(sin(uv*352.742+uv.yx*254.741),vec2(642.541)));\n  \n}\n\n// very useful function to get random beats and motion, d is the frequency of the pulses\nfloat curve(float t, float d) {\n  t/=d;\n  return mix(rnd(floor(t)), rnd(floor(t)+1.0), pow(smoothstep(0.0,1.0,fract(t)), 10.0));\n}\n\n\n// tick function that shape the t value to had pulses every second\nfloat tick(float t) {\n  float g=fract(t);\n  g=smoothstep(0.,1.,g);\n  g=pow(g,10.);\n  return floor(t)+g;\n}\n\n// KIFS like space folding\n// used on the central piece\nvec3 fractal(vec3 p, float t) {\n  \n  float s= 2.0 + (curve(time, .3)-0.5)*.1;\n  for(float i=0.; i<3.; ++i) {\n    p.xz *= rot(t);\n    p.yz *= rot(t*1.3);\n    p.xz=abs(p.xz)-s*(1.+vec2(rnd(i),rnd(i+.1)));\n    s*=0.7;\n  }\n  \n  return p;\n}\n\n// smooth minimum between two distance fields\nfloat smin(float a, float b, float h) {\n  float k=clamp((a-b)/h*0.5+0.5,0.,1.);\n  return mix(a,b,k) - k*(1.-k)*h;\n}\n\n// repeat a shape at each s intervals\nvec3 repeat(vec3 p, vec3 s) {\n  return (fract(p/s+0.5)-0.5)*s;\n}\n\nfloat center = 10000.; // keep distance value of the center piece for latter use in shading\n\n// Main distance field function\nfloat map(vec3 p) {  \n  \n  // add a ripple effect from the center\n  p.y += curve(time*3. - length(p.xz)*0.02, 1.)*8.;\n  \n  float t=tick(time)*2.;\n  \n  // center piece made by intersecting two boxes on kifs\n  float d=box(fractal(p, t*.3), vec3(0.3,1.3,0.4));\n  float d2=box(fractal(p+vec3(1), t*.4), vec3(0.3,1.3,0.4)*2.);\n  d = abs(max(d,d2))-0.2;\n  \n  // tried adding something interesting to the center piece, mostly useless\n  float d5 = box(fractal(p-vec3(0,10,0), t*.1), vec3(-5,-5,1000.0));  \n  d = min(d, d5);\n  center = d;  \n  \n  // ground floor, blended with the center piece\n  d = smin(d, -p.y+5., 1. + curve(time, 0.3)*15.);\n  \n  \n  // the little swirly pointy towers thingies, with 32 copies\n  vec3 p2=p;  \n  p2.xz = abs(p2.xz)-40.;\n  p2.xz = abs(p2.xz)-20.;\n  p2.xz = abs(p2.xz)-10.*curve(time, .3);\n  \n  // make it swirly\n  p2.xz *= rot(p2.y*curve(time, 0.4)*0.5-time);\n  \n  // make it pointy\n  float sd = -abs(p.y)*0.3+3.;\n  d = min(d, box(p2, vec3(sd,10,sd)));\n  \n  // the flying spheres\n  vec3 p3=p;\n  p3=repeat(p3, vec3(13));\n  // randomise sphere sizes a bit\n  float d3 = length(p3)-.1-sin(p.x*.3)*.3-sin(p.y*.2)*.3-sin(p.z*.1)*.3 - sin(length(p)*0.03-time)*.1;\n  // ne sphere near the ground\n  d3 = max(d3, p.y+1.);\n  d = min(d, d3);\n  \n  // makes it hollow, so that latter we can x-ray everything\n  d=abs(d)-0.1;\n  return d;\n}\n\n// camera rotations\nvoid cam(inout vec3 p) {  \n  float t=time*0.3;\n  p.yz *= rot(.4 + sin(t*.2)*.4);\n  p.xz *= rot(t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  // we loop every now and then so precision is not too much of an issue\n  time = mod(iTime*SPEED, 300.);\n  progression = mod(iTime, 300./SPEED);\n  \n  // bonzomatic centered uv's\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  ///////\n  // first step: uv effects\n  ///////\n    \n  // centered ripples in the uvs\n  uv *= 1.+max(0.,curve(time - length(uv),.2)-.7)*.6;\n  // vertical pulses\n  uv.y -= curve(time, .2)*.1;\n  \n  // distance to the center circle\n  float di2 = pow(curve(time, .8),4.)*3.-length(uv)-.1;\n  bool circ = di2<0.;\n  bool truc = curve(time, 6.)<.7;\n  vec2 nu = vec2(0);\n  vec2 nuv = uv;\n  // every now and then, horizontal symmetry on mosaic\n  if(!truc) nuv.x = abs(nuv.x)*fract(time);\n    \n  if(progression<7.) {\n      circ=false;\n      truc=false;\n  }\n  \n  // mosaic computation\n  float di = 1000.; // distance to nearest mosaic piece\n  // kaleidoscopic effect, 4 random successive symmetries and rotations\n  for(float i=0.; i<4.; ++i) {\n    // random rotation\n    nuv *= rot(curve(time+i*0.32,1.2)*2.);\n    // random vertical offset evolving with time\n    nuv.y += curve(time+.7+i*.1,.5)-.5;\n    // at each step we add a slight uv distortion different for each piece\n    nu += sign(nuv)*(1.+i*0.2);\n    // symmetry\n    nuv=abs(nuv);\n    // retreive distance to nearest symmetry axe\n    di = min(di, min(nuv.x,nuv.y));\n    // random offset on the symmetry\n    nuv-=0.4*rnd(nu);\n  }\n  \n  // value used for camera cuts\n  float pulse = floor(time*0.7);  \n  // apply uv distorting from mosaic pieces\n  if(circ && truc) uv += nu*(0.03+0.03*curve(time+.7,.3))*.5;\n  \n  ///////\n  // second step: 3D raymarching\n  ///////\n    \n  // camera orbit starting position, with random x offset and random distance\n  vec3 s=vec3((curve(time+2.3,.8)-.5)*20. ,-10.,-30. - curve(time, 1.3)*40.);\n  // camera perspective, random fov\n  vec3 r=normalize(vec3(-uv, .5 + curve(pulse, .7)*2.));\n  \n  // apply camera rotation\n  cam(s);\n  cam(r);\n  \n  vec3 p=s;\n  vec3 col = vec3(0);\n    \n  // noise value that will elimitate banding that comes from iteration glow\n  float mu=mix(0.9,1.0,rnd(uv));\n  \n  // decide for each mosaic piece, if raymarching will be reflexive or xray\n  bool band = rnd(nu)>0.7 && circ;\n  if(rnd(pulse+.23)<.4) band=true;\n    \n  // color or the colored mosaic piece\n  vec3 diff=vec3(1,0.4,0.5);\n  float t2 = tick(time*.5)*.7;\n  #if COLOR_SHIFT\n    // rotate the color with time\n  \tdiff.xz *= rot(t2);\n    diff.yz *= rot(t2*.7);\n    diff=abs(diff);\n  #endif\n  \n  // change smoothness of the glow with time\n  float de = 0.01*(1.+sin(abs(uv.x*3.)-time*4.)*0.8);\n  \n  // RAYMARCHING LOOP\n  vec3 diff2 = vec3(1);\n  bool maa=false;\n  int zero = min(0,iFrame); // disable possible loop unrolling\n  for(int i=zero; i<100; ++i) {\n    float d=map(p);\n    if(d<0.001) {\n      // We found a collision\n      if(band) {\n        // inside a xray mosaic piece\n        // just advance the ray a bit and continue marching through everything  \n      \td=0.1;\n        #if CENTER_COLOR\n        if(center<10. && progression>24.) {\n          // this handle the color shift of the center 3D piece\n          diff.xz *= rot(.1);\n          diff=abs(diff);\n          maa=abs(center-10.)<1.;\n        }\n        #endif\n      } else {\n        // inside a reflexive mosaic piece\n        vec2 off=vec2(0.01,0);\n        #if CENTER_COLOR\n        if(center<10. && progression>24.) {\n          // this handle the color shift of the center 3D piece\n          diff2 = vec3(.3,8,10)*curve(time, .75);\n          maa=abs(center-10.)<1.;\n        }\n        #endif\n        // compute surface normal\n        vec3 n=normalize(d-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));\n        // reflect the ray\n        r=reflect(r,n);        \n        // avance a little bit so we are out of the surface  \n      \td=0.1;\n      }\n      //break;\n    }\n    // if we are too far, break out the loop to save performance\n    if(d>100.0) break;\n    // raymarching step\n    p+=r*d*mu;\n    // accumulate diffrent color if we are reflexive or xray\n    if(band) {\n      col += diff*0.3*de/(de+.1+abs(d));\n    } else {\n      col += diff2*vec3(0.7,0.7,0.7)*0.1*de/(de+abs(d));\n    }\n  }\n  \n  ///////\n  // third step: color postprocessing\n  ///////\n    \n  // mosaic black edges (outside circle)\n  if(circ) col *= smoothstep(0.0,0.01,di);\n  // circle edge\n  if(circ) col *= smoothstep(0.0,0.02,abs(di2));\n  // 3D center piece dark edges\n  if(maa) {\n    col *= .2;\n  }\n  \n  #if RAINBOW\n  // rainbox band I added at the end, probably missing some black edges but I didn't have the time ...\n  if(rnd(pulse)<0.6 && abs(uv.y)<.1 && progression>60.) {\n    float t4 = time + uv.x;\n    col.yz *= rot(t4);\n    col.xz *= rot(t4*1.3);\n    col=abs(col);\n  }\n  #endif\n  \n  // vignette\n  col *= 1.2-length(uv);\n  \n  // \"tonemapping\"\n  col=smoothstep(0.,1.,col);\n  col=pow(col, vec3(0.4545));\n  \n  fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}