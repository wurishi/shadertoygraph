{"ver":"0.1","info":{"id":"4fKyRV","date":"1733074050","viewed":64,"name":"Infinite Azure","username":"enka","description":"Entry for Sperasoft Shader contest.\nTerrain rendered with raymarching. \nMeant to resemble \"Infinite Azure\" level from Tekken 7.\nA weird mish-mash of several ray marching tutorials: specifically by Inigo Quilez and Art of Code","likes":0,"published":3,"flags":0,"usePreview":0,"tags":["ray","terrain","marching","contest"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Num of maximum marching steps for a ray\n#define MAX_STEPS 100\n\n// Max distance to surface, tells the ray that it completely missed\n#define MAX_DISTANCE 800.0\n\n// If ray is closer than this distance - then we have an intersection\n#define SURFACE_DISTANCE 0.01\n\n// Generate terrain heightfield with sinewaves. 0=2DNoise, 1=SineWaves\n#define SINEWAVE_TERRAIN 1\n\n// How many 2D sine waves should be added to terrain displacement\n#define MAX_TERRAIN_WAVES 10\n\n// Cut-off height for water. Used to override specular and base color of the waterplane\n#define WATER_LINE_HEIGHT 1.0\n\n// Display Capsules. 0=OFF, 1=ON\n#define ENABLE_CAPSULES 1\n\n// Display more SDF shapes. 0=OFF, 1=ON\n#define ENABLE_SHAPES 0\n\n// Cloud Toggle. 0=OFF, 1=ON\n#define ENABLE_CLOUDS 1\n\n\n\n// Global colors\nconst vec3 FOG_COLOR = 1.66 * vec3(0.1882, 0.2627, 0.3176);\nconst vec3 HORIZON_COLOR = 1.33 * vec3(0.43, 0.537, 0.592);\nconst vec3 ZENITH_COLOR = 1.15 *  vec3(0.33, 0.519, 0.63);\nconst vec3 SUN_COLOR = vec3(1.150, 1.00, 0.895);\nconst vec3 CLOUD_COLOR = vec3(1.0, 0.95, 1.0);\n\n// ---------------------------------- NOISE FUNCTIONS ----------------------------------\n\n// Calculate Fraction Brownian Motion noise from a White Noise Texture\n// Used for cloud layer generation\n// https://iquilezles.org/articles/morenoise/\nfloat FractionBrownianMotion(in vec2 p)\n{\n    float f = 0.0;\n    const mat2 m2 = mat2(0.8, -0.6, 0.6, 0.8);\n    \n    f += 0.5000 * texture( iChannel0, p / 256.0 ).x; \n    p = m2 * p * 2.03;\n    \n    f += 0.2500 * texture( iChannel0, p / 256.0 ).x; \n    p = m2 * p * 2.03;\n    \n    f += 0.1250 * texture( iChannel0, p / 256.0 ).x; \n    p = m2 * p * 2.01;\n    \n    f += 0.0625 * texture( iChannel0, p / 256.0 ).x;\n    \n    return f / 0.9275;\n}\n\n// 2D Noise. Used to generate the terrain heightfield.\n// https://www.shadertoy.com/view/tldSRj\nvec2 g( vec2 n ) { return sin(n.x*n.y*vec2(12, 17)+vec2(1, 2)); }\nfloat noise(vec2 p)\n{\n    const float kF = 2.0;\n    vec2 i = floor(p);\n\tvec2 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f);\n    return mix(mix(sin(kF*dot(p,g(i+vec2(0,0)))),\n               \t   sin(kF*dot(p,g(i+vec2(1,0)))),f.x),\n               mix(sin(kF*dot(p,g(i+vec2(0,1)))),\n               \t   sin(kF*dot(p,g(i+vec2(1,1)))),f.x),f.y);\n}\n\n\n// ---------------------------------- SIGNED DISTANCE FIELD FUNCTIONS ---------------------------------- \nfloat GetBoxDistance(vec3 pos, vec3 box)\n{\n  vec3 q = abs(pos) - box;\n  return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n// SDF, Box with rounded edges\nfloat GetRoundedBoxDistance(vec3 pos, vec3 box, float roundness)\n{\n  vec3 q = abs(pos) - box + roundness;\n  return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - roundness;\n}\n\n// SDF, Torus\nfloat GetTorusDistance(vec3 position, vec2 radii)\n{\n  vec2 q = vec2(length(position.xz) - radii.x, position.y);\n  return length(q) - radii.y;\n}\n\n// SDF, Vertical Capsule\nfloat GetCapsuleDistance(vec3 position, float height, float radius)\n{\n  position.y -= clamp(position.y, 0.0, height);\n  return length(position) - radius;\n}\n\n// Returns distance to terrain. \n// Heightfield is constructed in with two algorithms:\n// - Adding multiple sine waves together\n// - Generating a 2D noise with 4 octaves\nfloat GetTerrainDistance(vec3 position)\n{\n#if SINEWAVE_TERRAIN == 1\n    // These are sine wave params. Limit the amount of waves to defined MAX.\n    int steps = clamp(min(10, MAX_TERRAIN_WAVES), 0, 10);\n    float frequencies[10] = float[10](0.03, 0.01, 0.05, 0.1, 0.25, 0.5, 1.0, 1.5, 2.0, 3.0);\n    float amplitudes[10] = float[10](111.0, 99.0, 88.973, 24.317, 8.797, 1.315, 1.0, 0.786, 0.531, 0.235);\n    float offsets[10] = float[10](1.0, 0.973, 0.739, 0.573, 0.383, 0.179, 0.0, 0.354, 0.876, 0.222);\n    \n    // Iterate over arrays, add multiple sine waves\n    float noise = 0.0;\n    float noise_amplitude = 0.1;\n    float noise_offset = 0.0;\n    for(int i = 0; i <= steps - 1; i++)\n    {\n        noise += amplitudes[i] * sin(position.x * frequencies[i] + offsets[i]) * sin(position.z * frequencies[i] - offsets[i]); \n    }\n    \n    float terrain = noise * noise_amplitude - noise_offset;\n#else\n    // Calculate terrain Heightfield with 2D fractal noise, overlaying 4 octaves\n    vec2 uv = position.xz * 0.01 + 0.0; \n    float terrain = 0.0;\n    const mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    terrain  = 0.5000 * noise( uv ); \n    uv = m*uv;\n    terrain += 0.2500 * noise( uv ); \n    uv = m*uv;\n    terrain += 0.1250 * noise( uv ); \n    uv = m*uv;\n    terrain += 0.0625 * noise( uv ); \n    uv = m*uv;\n    terrain = -30.0 * terrain + 0.0;\n\n#endif\n\n    // Calculate radius around 0-coords. And convert it to [0-1] smooth mask\n    float dist = length(position.xz);\n    float dist_min = 175.0;\n    float dist_max = 300.0;\n    float alpha = clamp(dist - dist_min, 0.0, dist_max - dist_min) / 50.0;\n    alpha = clamp(alpha, 0.0, 1.0);\n    \n    // Scale down the heightfield around the 0-coords, so terrain would be flat around the camera\n    float mask = smoothstep(0.0, 1.0, alpha);\n    float terrain_scale = mix(0.00, 1.0, mask);\n    float out_distance = position.y + 1.0 + terrain * terrain_scale;\n \n    return out_distance;\n}\n\n// Returs distance to the water plane at position\nfloat GetWaterDistance(in vec3 position)\n{\n    float out_distance = position.y;\n    \n    // Calculate two sine waves\n    float distance_a = 0.0055 * sin(iTime * 1.657 + position.x) * sin(iTime * 1.753 + position.z);\n    float distance_b = 0.0495 * sin(iTime * 1.01357 + position.x * 0.51) * sin(iTime * 1.0353 + position.z * 0.51);\n    \n    // Blend waves based on distance to camera\n    float depth = length(position.xz);\n    float alpha = clamp(depth / 200.0, 0.0, 1.0);\n    float water_distance = mix(distance_a, distance_b, alpha);\n    \n    out_distance += water_distance;\n    \n    return out_distance;\n}\n\n// Returns distance to closest surface at a position\nfloat GetDistance(vec3 position)\n{\n    // Compare terrain and waterplane\n    float terrain_distance = GetTerrainDistance(position);\n    float water_distance = GetWaterDistance(position);\n    float closest_distance =  min(terrain_distance, water_distance);\n    \n#if ENABLE_SHAPES >= 1\n    // Sphere: position XYZ + radius W\n    vec4 sphere_a = vec4(0.0, 2.0, 0.0, 1.0);\n    float sphere_a_distance = length(position - sphere_a.xyz) - sphere_a.w;\n    closest_distance = min(closest_distance, sphere_a_distance);\n    \n    // Box with rounded edges\n    vec3 box_pos = vec3(-3.0, -2.0, 0.0) + position;\n    vec3 box_size = vec3(0.8, 0.8, 0.8);\n    float box_distance = GetRoundedBoxDistance(box_pos, box_size, 0.1);\n    closest_distance = min(closest_distance, box_distance);\n    \n    // Torus\n    vec3 torus_pos = vec3(3.0, -2.0, 0.0) + position;\n    vec2 torus_radii = vec2(1.0, 0.333);\n    float torus_distance = GetTorusDistance(torus_pos, torus_radii);\n    closest_distance = min(closest_distance, torus_distance);\n\n#endif\n    \n    \n#if ENABLE_CAPSULES >= 1\n    // Capsule Left\n    vec3 capsule_left_pos = vec3(7.0, -1.25, 0.0) + position;\n    float capsule_left_distance = GetCapsuleDistance(capsule_left_pos, 3.5, 1.0);\n    closest_distance = min(closest_distance, capsule_left_distance);\n    \n    \n    // Capsule Right\n    vec3 capsule_right_pos = vec3(-7.0, -1.25, 0.0) + position;\n    float capsule_right_distance = GetCapsuleDistance(capsule_right_pos, 3.5, 1.0);\n    closest_distance = min(closest_distance, capsule_right_distance);\n#endif\n    \n    return closest_distance;\n}\n\n// ---------------------------------- RENDERING FUNCTIONS ---------------------------------- \n// Returns a normal at the position\nvec3 GetNormal(vec3 position)\n{\n    float dist = GetDistance(position);\n    vec2 error = vec2(0.01, 0.0);\n    \n    vec3 normal = dist - vec3(\n        GetDistance(position - error.xyy),\n        GetDistance(position - error.yxy),\n        GetDistance(position - error.yyx));\n        \n    return normalize(normal);\n}\n\n// Marches the ray until it hits a surface or goes way too far\nfloat RayMarch(vec3 origin, vec3 direction)\n{\n    float distance_to_origin = 0.0;\n    \n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 position = origin + direction * distance_to_origin;\n        float distance_to_surface = GetDistance(position);\n        distance_to_origin += distance_to_surface;\n        float error_threshold = SURFACE_DISTANCE * float(i);\n        \n        if(distance_to_origin > MAX_DISTANCE || distance_to_surface < error_threshold)\n        {\n            break; // stop marching\n        }\n    }\n    \n    return distance_to_origin;\n}\n\n// Returns direction to the sun light\nvec3 GetLightDirection()\n{\n    vec3 position = vec3(0.0, 1.03, 5.0);\n    position.y += sin(iTime) * 0.05;\n    \n    return normalize(position);\n}\n\n// Returns direction to the light source (point)\nfloat GetLight(vec3 position)\n{\n    vec3 light_direction = GetLightDirection();\n    vec3 normal = GetNormal(position);\n    \n    // Diffuse lighting for a pixel\n    float diffuse = clamp(dot(normal, light_direction), 0.0, 1.0); \n    \n    // Cast ray from position in direction of the light\n    vec3 shadow_sample_position = position + normal * SURFACE_DISTANCE * 2.0;\n    float shadow = RayMarch(shadow_sample_position, light_direction);\n    \n    // Check if point is occluded from the light source\n    if (shadow < length(light_direction * 10.0 - position))\n    {\n        diffuse *= 0.1;\n    }\n    \n    return diffuse;\n}\n\n// Returns a shadow mask\nfloat GetShadow(in vec3 position, in vec3 direction)\n{\n    vec3 normal = GetNormal(position);\n    vec3 shadow_position = position + normal * SURFACE_DISTANCE * 2.0;\n    \n     // Check if point is occluded in the ray direction\n    float shadow = RayMarch(shadow_position, direction);\n    \n    float shadow_mask = 1.0;\n    if (shadow < length(direction * 10.0 - position))\n    {\n        shadow_mask *= 0.1;\n    }\n    \n    return clamp(shadow_mask, 0.0, 1.0 );\n}\n\n// Applies exponential fog to the pixel\nvec3 ApplyFog(in vec3 color, in float depth)\n{\n    float strength = 0.005;\n    float amount = 1.0 - exp(-depth * strength);\n    vec3 fog_color = FOG_COLOR;\n    \n    return mix(color, fog_color, amount);\n}\n\n\n\n// Returns alpha of the clouds\nfloat GetCloudAlpha(in vec3 origin, in vec3 direction)\n{\n    // Scale for the noise\n    vec2 scale = origin.xz + direction.xz * (35000.0 - origin.y) / direction.y; \n    \n    // Animate offsets with time, so the clouds scroll across the sky\n    vec2 offset_a = iTime * 0.87 * vec2(1.0, 0.55);\n    vec2 offset_b = iTime * 0.63 * vec2(1.0, 0.33);\n    \n    // Calculate alphas for 2 cloud layers\n    float cloud_a = 0.83 * smoothstep(0.45, 0.8, FractionBrownianMotion(scale / 4400.0 + offset_a)); \n    float cloud_b = 0.63 * smoothstep(0.17, 0.8, FractionBrownianMotion(scale / 1973.0 + offset_b));\n    \n    // Return the biggest alpha, so colors won't be blown out\n    return max(cloud_a, cloud_b);\n}\n\n// Return sky color with clouds and sunglare\nvec3 GetSkyColor(in vec3 origin, in vec3 direction)\n{\n    // Sky\n    vec3 color = ZENITH_COLOR - direction.y * direction.y * 0.5;\n    color = mix(color, HORIZON_COLOR, pow(1.0 - max(direction.y, 0.0), 3.0));\n\n    // Sun: boost red channel of global sun color to get a yellow-ish color\n    float sun_glare = clamp(dot(direction, GetLightDirection()), 0.0, 1.0);\n    color += 0.225 * vec3(1.250, 1.0, 1.0) * SUN_COLOR * pow(sun_glare, 5.0);\n    color += 0.175 * vec3(1.250, 1.0, 1.0) * SUN_COLOR * pow(sun_glare, 64.0);\n    color += 0.190 * vec3(1.250, 1.0, 1.0) * SUN_COLOR * pow(sun_glare, 512.0);\n\n    // Clouds: calculate alpha from the noise\n#if ENABLE_CLOUDS == 1\n    float alpha = GetCloudAlpha(origin, direction);\n    color = mix(color, CLOUD_COLOR, alpha);\n#endif\n\n    // Horizon: blend fog color\n    color = mix(color, FOG_COLOR, pow(1.0 - max(direction.y, 0.0), 16.0));\n    \n    return color;\n}\n\n\n// ---------------------------------- MAIN LOOP ---------------------------------- \n// Scene, consists of 4 elements represented by Signed Distance Fields: \n//    water plane, mountain terrain, skyscape and optional SDF shapes\n// We raymarch through it, pixel by pixel.\n// For each sky pixel we calculate cloud noise, sky color and sun glare\n// For each non-sky pixel we calculate diffuse and specular lighting\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // UVs starting from the screen center\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Camera position and direction\n    vec3 ray_origin = vec3(0.0, 7.0, -22.0);\n    vec3 ray_direction = normalize(vec3(uv.x, uv.y, 1.0));\n\n    // Raymarch the SDFs to get pixel depths\n    // Get the attrbiutes that we'll need later for lighting\n    float depth = RayMarch(ray_origin, ray_direction);\n    vec3 position = ray_origin + ray_direction * depth;\n    vec3 normal = GetNormal(position);\n    vec3 reflection = reflect(ray_direction, normal);\n    \n    // Time to calculate the pixel color\n    vec3 color = vec3(0.0);\n    if( depth > MAX_DISTANCE)\n    {\n        // If ray didn't hit anything - it must be sky\n        color = GetSkyColor(ray_origin, ray_direction);\n        depth = -1.0;\n\t}\n    else\n    {\n        // Material attributes\n        vec3 base_color = vec3(0.4, 0.4, 0.4);\n        float specular_strength = 0.5;\n        \n        // Override the color of capsules\n        vec3 capsule_left_color = vec3(0.95, 0.4, 0.4);\n        vec3 capsule_right_color = vec3(0.4, 0.4, 0.95);\n        vec3 capsule_color = mix(capsule_left_color, capsule_right_color, step(position.x, 0.0));\n        if(GetBoxDistance(position - vec3(0.0, 0.0, 0.0), vec3(10.0, 10.0, 4.0) ) < position.y - 1.0 )\n        {\n            // Make the capsules and other object SDFs red or blue\n            base_color = 1.50 * mix(base_color, capsule_color, step(position.y, 5.0));\n            specular_strength = 0.5;\n        }\n\n        // Override BaseColor and Specular strength for water plane\n        if( position.y < WATER_LINE_HEIGHT )\n        {\n            base_color = vec3(0.13);\n            specular_strength = 1.0;\n        }\n        \n        // Lighting : Sun\n        vec3 lit_color = vec3(0.0);\n        {\n            // Get diffuse light from the Sun\n            float diffuse = GetLight(position); \n                  //diffuse *= GetShadow(position, GetLightDirection());\n\n            // Get Specular from the Sun\n            vec3 ligth_dir = GetLightDirection();\n            vec3 hal = normalize(ligth_dir - ray_direction);\n            float specular = pow( clamp( dot( normal, hal ), 0.0, 1.0 ),16.0);\n                  specular *= diffuse;\n                  specular *= 0.04 + 0.96 * pow( clamp( 1.0-dot(hal, ligth_dir), 0.0, 1.0), 5.0);\n\n            // Accumulate lighting color (base color influenced by diffuse + specular)\n            lit_color += base_color * 2.20 * diffuse * SUN_COLOR;\n            lit_color += 5.00 * specular * SUN_COLOR * specular_strength;\n        }\n\n        // Lighting : Sky, diffuse + specular\n        {\n            vec3 sky_color = GetSkyColor(ray_origin, reflection);\n           \n            float diffuse = sqrt(clamp(0.5 + 0.5 * normal.y, 0.0, 1.0));\n            float specular = smoothstep( -0.2, 0.2, reflection.y );\n                  specular *= diffuse;\n                  specular *= 0.04 + 0.96 * pow(clamp(1.0 + dot(normal, ray_direction), 0.0, 1.0), 5.0);\n                  specular *= GetShadow(position, reflection);\n                  \n            // Add everything up together\n            lit_color += 0.60 * base_color * diffuse * sky_color;\n            lit_color += specular * sky_color * specular_strength;\n        }\n        \n        color = lit_color;\n    }\n    \n    \n    // Add exponential fog on top of the image\n    vec3 out_color = ApplyFog(color, depth);\n    \n    fragColor = vec4(out_color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}