{"ver":"0.1","info":{"id":"4XSBWD","date":"1729441920","viewed":112,"name":"fractalic armor","username":"nayk","description":"originals fractal 62 remake","likes":1,"published":3,"flags":0,"usePreview":0,"tags":["fractal","armor"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(10,13,21))*0.5+.5)\n#define n1Q(p) p *= ri(round(atan(p.x, p.y) * 10.) / 2.)\n#define ri(a) mat2(cos(a + asin(vec4(0,1.,-1.,0))))\nfloat pi=acos(-1.);\n\nfloat sat(float t) { return clamp(t, 0.,1.); }\n\n//DAVE HOSKINS' HASH FUNCTIONS\n// we use them mainly because they don't contain any sin/cos and so should be more consistent accross hardware\n//https://www.shadertoy.com/view/4djSRW\nfloat rnd(float p)\n{\n    p = fract(p * 044.1031);\n    p *= p + 33.33;\n    return fract(0.4*p*p);\n}\n\nvec3 rnd23(vec2 p)\n{\n\tvec3 p3 = fract(p.xyx * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat rnd31(vec3 p3)\n{\n\tp3  = fract(p3 * 33.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat rnd21(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 rnd33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(1.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nmat2 rot(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\n}\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec2 uv = (C.xy / iResolution.xy) - .5;\n    \tfloat t = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(uv.xy) + 0.2)) * 1.2;\n\tfloat si = sin(t);\n\tfloat co = cos(t);\n\tmat2 ma = mat2(co, si, -si, co);\n    vec3 p,q,r=iResolution,\n    \n    d=normalize(vec3((C*2.-r.xy)/r.y,1));  \n     vec3 target = vec3(0.0, 0.0, 0.0);      // カメラが注目するターゲット位置\n    vec3 cp = vec3(0.0, -7.0, -1.0);       // カメラの位置\n    vec3 cd= normalize(target - cp);       // カメラの視線方向\n    vec3 cs = normalize(cross(cd, vec3(0.0, 1.0, 0.0))); // 右方向\n    vec3 cu = normalize(cross(cd, cs));     // 上方向\n    \n    float fov = 2.5; // 視野角\n    vec3 rd = normalize(cs * p.x + cu * p.y + cd * fov); // レイの方\n    for(float i=0.,a,s,e,g=0.;\n        ++i<70.;\n        O.xyz+=mix(vec3(0.3,0.55,2.0),H(g*0.5),.8)*1./e/8e3\n    )\n    {\n    \n        p=g*d;\n       \n           n1Q(p.zy);\n           n1Q(p.xy);\n            n1Q(p.xz);\n  \n    \n        a=30.;\n        p=mod(p-a,a*2.)-a;\n        ;\n        s=1.0;\n    ;\n p.xy*=dot(p.x, p.y);\n        for(int i=0;i++<8;){\n          \n            p=.3-abs(p);\n            p.x<p.z?p=p.zyx:p;\n            p.z<p.y?p=p.xzy:p;\n             p.y<p.x?p=p.yzx:p;\n                    p.z<p.x?p=p.xyz:p;  \n            s*=e=2.0+sin(iTime*.0021)*.1;\n            p=abs(p)*e-\n                vec3(\n                    40.*rnd(20.)+cos(iTime*0.21),\n                    20.*rnd(rd.y),\n                    20.*rnd(rd.z)\n                 );\n                 \n         }\n         \n         g+=e=length(p.zxx)/s;\n    }\n}","name":"Image","description":"","type":"image"}]}