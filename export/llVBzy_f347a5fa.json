{"ver":"0.1","info":{"id":"llVBzy","date":"1546313543","viewed":335,"name":"Crimson Nebula","username":"WB","description":"Another nebula made with raymarching and a rough radiative transfer approximation.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","volumetric","nebula"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 256\n#define STEP_SIZE 0.05\n#define _FoV 45.0\n\n#define JITTER\n\nconst vec3 _Absorption = vec3(0.9,0.7,0.4);\nconst vec3 _Light = vec3(1.0,0.7,0.5);\nconst vec3 _LightPos = vec3(0.0, -0.2, 0.0);\nconst float _Density = 0.4;\n\n//Ray-sphere intersection\nbool raycastSphere(vec3 ro, vec3 rd, out vec3 p0, out vec3 p1, vec3 center, float r)\n{\n    float A = 1.0; //dot(rd, rd);\n    float B = 2.0 * (rd.x * (ro.x - center.x) + rd.y * (ro.y - center.y) + rd.z * (ro.z - center.z));\n    float C = dot(ro - center, ro - center) - (r * r);\n\n    float D = B * B - 4.0 * A * C;\n    if (D < 0.0)\n    {\n        return false;\n    }\n    else\n    {\n        float t0 = (-B - D)/(2.0 * A);\n        float t1 = (-B + D)/(2.0 * A);\n        p0 = ro + rd * t0;\n        p1 = ro + rd * t1;\n        return true;\n    }\n}\n\n//Y-axis rotation matrix\nvec3 rotateY(vec3 p, float t)\n{\n    float cosTheta = cos(t);\n    float sinTheta = sin(t);\n    mat3 rot = mat3(cosTheta, 0.0, sinTheta,\n        \t\t\t0.0, 1.0, 0.0,\n    \t\t\t    -sinTheta, 0.0, cosTheta);\n    \n    return rot * p;\n}\n\n//iq's gradient noise\nvec3 hash( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\nfloat fbm(vec3 seed, int octaves, float freq, float lac)\n{\n    float val;\n    for (int i = 0; i < octaves; i++)\n    {\n        val += noise(seed * freq * float(i+1)) / (pow(float(i+1), lac));\n    }\n\n    return val;\n}\n\nfloat sampleVolume(vec3 pos)\n{\n    pos = rotateY(pos, pos.y + noise(16.0+pos*8.0));\n    float rr = dot(pos,pos);\n    rr = sqrt(rr);\n    float p = exp(-rr);\n    p *= _Density;\n    \n    if (p < 0.1)\n        return p;\n    \n    p = max(0.0, p - abs(fbm(pos, 4, 0.5, 0.5)) - abs(noise(pos*0.1)));\n            \n    return p;\n}\n\nvec4 raymarch(vec3 pos, vec3 dir, float ds, int s)\n{\n    vec4 result = vec4(0.0,0.0,0.0,1.0);\n    int steps = min(s, MAX_STEPS);\n    for (int i = 0; i < steps; i++)\n    {\n        float p = sampleVolume(pos);\n        if (p > 0.0)\n        {\n            vec3 r = _LightPos - pos;\n            float atten = 1.0/dot(r, r) * 2.0;\n            vec3 scatter = _Light * atten * p * ds;\n            vec3 amb = vec3(0.03,0.0,0.02);\n            float ext = 1.0 - exp(-p * ds);\n            result.rgb += (amb + scatter) * result.a * _Absorption;\n            result.a *= exp(-p);\n\n            if (result.a <= 0.0)\n                return result;\n        }\n            \n        pos += dir * ds;\n    }\n    \n    result = clamp(result, 0.0, 1.0);\n    \n    return result;\n}\n\n//4x4 Bayer matrix for ordered dithering\nconst mat4 _Bayer4x4 = mat4(vec4(0,0.5,0.125,0.625),\n                        vec4(0.75,0.25,0.875,.375), \n                        vec4(0.1875,0.6875,0.0625,0.5625), \n                        vec4(0.9375,0.4375,0.8125,0.3125));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = iMouse.y/iResolution.y;\n    vec3 rayOrigin = vec3(0.0, 0.0, -5.0 + (5.0 * zoom));\n    //Compute eye vector from field of view\n    vec2 uv = fragCoord/iResolution.xy;\n    float ar = iResolution.x/iResolution.y;\n    float d = ar/tan(radians(_FoV/2.0));    \n    vec3 rayDir = normalize(vec3((-1.0 + 2.0 * uv) * vec2(ar, 1.0), d));\n    rayOrigin = rotateY(rayOrigin, iTime * 0.1 + iMouse.x * 0.01);\n    rayDir = rotateY(rayDir, iTime * 0.1 + iMouse.x * 0.01);\n    \n    vec4 col = vec4(0.0,0.0,0.0,1.0);\n    col.rgb += smoothstep(0.5, 0.8, abs(noise(rayDir * 256.0)));\n    \n    vec3 p0, p1;\n    if (raycastSphere(rayOrigin, rayDir, p0, p1, vec3(0.0), 1.0))\n    {        \n        #ifdef JITTER\n        //Bayer matrix ordered depth jittering\n        float width = (uv.x * iResolution.x);\n        float height = (uv.y * iResolution.y);\n        width = mod(width, 4.0);\n        height = mod(height, 4.0);\n        float offset = _Bayer4x4[int(width)][int(height)];\n        p0 -= rayDir * offset * STEP_SIZE*2.0;\n        #endif\n        \n        float dist = length(p1 - p0);\n        int s = int(dist/STEP_SIZE) + 1;\n        \n        vec4 integral = raymarch(p0, rayDir, STEP_SIZE, s);\n                \n        col.rgb = col.rgb * integral.a + integral.rgb * (1.0-integral.a);        \n    }\t\n       \n    fragColor = col;\n}","name":"Image","description":"","type":"image"}]}