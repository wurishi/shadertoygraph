{"ver":"0.1","info":{"id":"fdsXWr","date":"1618524167","viewed":159,"name":"How to save state (Commented)","username":"spaceWumpus","description":"Forked from https://www.shadertoy.com/view/XdtSWn\nExample of saving state from frame to frame to run a simulation or game.\nI have heavily commented the code, and made some structure and name changes compared to the original for clarity.\n","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["example","simulation","educational","commented","state","texelfetch"],"hasliked":0,"parentid":"XdtSWn","parentname":"Shader Lesson #10, saving state"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Forked from https://www.shadertoy.com/view/XdtSWn\n// Example of saving state from frame to frame to run a simulation or game.\n// I have heavily commented the code, and made some structure and name changes compared to the original for clarity.//\n\n// This Image shader simply renders the current state of the simulation, as encoded in Buffer A (iChannel0).\n//\n// ********************************************************************************\n// * Most of the interesting stuff is in the code for Buffer A - go look at that! *\n// ********************************************************************************\n\n\n// Convenience wrapper for getting ball state directly from its index\nvoid GetStateForBallIndex(int ballIdx, out vec2 pos, out vec2 vel, int iChanRes0)\n{\n    vec4 posAndVel = texelFetch(iChannel0, BufferPixelPosFromBallIndex(ballIdx, iChanRes0), 0);\n    pos = posAndVel.xy;\n    vel = posAndVel.zw;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int iChanRes0 = int(iChannelResolution[0].x);\n\n    vec2 uv = fragCoord.xy / iResolution.x;\n    \n    fragColor = vec4(0,0,0,1);\n\n    // Iterate through all the balls, if this pixel is inside one of them,\n    // then assign the output pixel to that color.\n    // If this fragment covers multiple balls then the one with the highest index will overwrite the earlier ones.\n    for (int i = 0; i < NUM_BALLS; i++) \n    {\n        vec2 pos, vel;\n        GetStateForBallIndex(i, pos, vel, iChanRes0);\n      \n        float dist = length(uv - pos);\n        if (dist < R) \n        { // We are within the ball\n          // Ball colour is derived from its index. \n          // Note that it doesn't need to be stored like the pos/vel state in Buffer A,\n          // because it is always the same for each ball, and not something that could change that we need to keep track of.\n          // If we wanted e.g. to change the colour based on how many collisions the ball had had, then that information\n          // WOULD then need to be stored as state somewhere, as we cannot just calculate it here.\n            vec3 rgb = vec3(mod(float(i) / 3.0, 1.0),\n                            mod(float(i) / 5.0, 1.0),\n                            mod(float(i) / 7.0, 1.0));\n\n            // Calculate normal vector for the ball (for use in lighting).\n            vec3 norm = normalize(vec3((uv-pos).xy, - sqrt(R * R - dist * dist)));\n            // Incoming light.\n            vec3 sunray = normalize(vec3(-1.0,1.0,-1.0));\n            // Color\n            fragColor.xyz = rgb * (1.0 + dot(norm, sunray));\n        }\n    }\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Forked from https://www.shadertoy.com/view/XdtSWn\n// Example of saving state from frame to frame to run a simulation or game.\n// I have heavily commented the code, and made some structure and name changes compared to the original for clarity.\n\n// This code simulates a set of balls/particles which bounce off each other and the boundaries.\n//\n// This buffer stores and updates the position and velocity information for the simulated objects.\n// The simulation state is stored in the buffer, and this shader code runs the simulation to update the state for the next frame.\n//\n// To work, iChannel0 must be set to Buffer A, so that iChannel0 gives us (running in Buffer A) access to \n// our own output from the previous frame.\n//\n// Each ball corresponds to exactly one texel in this buffer, which is where its data is stored.\n// The four channels of that texel (XYZW) are used to store position (in X and Y) and velocity (in Z and W).\n// Each frame, this shader runs for every texel, but because there are (in general) far more texels than\n// balls in the simulation, we first check whether the current texel (fragCoord) corresponds to an actual ball.\n// If it doesn't then the fragment is discarded (and no more processing is done for it).\n// If it does then we update the simulation for the ball corresponding to this texel,\n// by applying gravity, momentum, and checking for and responding to collisions.\n// Once we've calculated the new position and velocity for this ball, we return the new texel state as the\n// fragment 'colour' for this texel, where we will see it again as iChannel0 input in the next frame.\n// In this way rendering a single fragment in this buffer is actually running the simulation for a single ball.\n// Via iChannel0 we have access to the previous frame state of ALL of the balls, from which we calculate and\n// return the new state of the current ball.\n\n\n\n// Whether to enable collisions between balls.\n// Set to false when first trying to understand the code, you can then ignore all the code in handleInterBallCollisions(...)\nbool enableInterBallCollisions = true;\n\n\n// Return a \"random\" number based on co.\nhighp float rand(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\n\n// Update the position and velocity of ball with index ballIdx in response\n// to collisions with any other balls.\n// (We only need ballIdx so we know which ball we are, so we don't wrongly detect \n// a collision with ourself.)\nvoid handleInterBallCollisions(int ballIdx, inout vec2 pos, inout vec2 vel)\n{\n    // Iterate through all the other balls to see if we are colliding with any.\n    // If we are, then update our position and velocity accordingly\n\n    int iChanRes0 = int(iChannelResolution[0].x);\n\n    for (int i = 0; i < NUM_BALLS; i++) \n    {\n\t\t// If it's the same ball, ignore it (can't collide with self)\n        if (i == ballIdx) continue;\n\n        // Get the position and speed of ball i.\n        vec4 otherPosAndVel = texelFetch(iChannel0, BufferPixelPosFromBallIndex(i, iChanRes0), 0);\n        vec2 otherPos = otherPosAndVel.xy;\n        vec2 otherVel = otherPosAndVel.zw;\n\n        // Calculate the distance between the centers of the two balls.\n        vec2 delta = pos - otherPos;\n        float dist = length(delta);\n\n        // If it's smaller than the diameter, we have a collision.\n        if (dist < (R+R)) \n        {\n            vec2 collision_normal = normalize(delta);\n            vec2 collision_tangent = vec2(collision_normal.y, -collision_normal.x);\n            // How fast *the other ball* is going in the \"collision_normal\" direction.\n            float a1 = dot(otherVel, collision_normal);\n            // How fast *this* ball is going in the \"collision_normal\" direction.\n            float a2 = dot(vel, collision_normal);\n            // How fast *this* ball is going in the \"collision tangent\" direction.\n            float b = dot(vel, collision_tangent);\n            // Our new speed.\n            vel = collision_normal * (a2 + (a1 - a2) * 0.9) + collision_tangent * b;\n            \n            // Also, move the ball away to make sure we're not colliding anymore.\n            pos = otherPos + delta * R * 2.01 / dist;\n        }\n    }   \n}\n\n\n// Update the position and velocity of ball in response to collisions with the bottom or left/right edges.\n// Note that here we don't need ballIdx, as it doesn't matter which ball we are, only the state is needed.\nvoid handleWallCollisions(inout vec2 pos, inout vec2 vel)\n{\n    // If we are within distance R of the bottom, then we have hit the bottom (and likely gone past it)\n    if (pos.y < R) \n    { \n        pos.y = (R+R)-pos.y; // Bounce off the bottom, so that we are ALWAYS at least R away\n        vel.y = abs(vel.y * 0.9); // Make sure we are moving up, and lose some energy\n    }\n\n    // Similarly for left and right walls\n    // If we reach left/right wall, invert the speed in the x direction. \n    if (pos.x < R) { pos.x = (R+R)-pos.x; vel.x = abs(vel.x * 0.9); }\n    if (pos.x > 1.0-R) { pos.x = (2.0-(R+R)) - pos.x; vel.x = -abs(vel.x * 0.9); }\n}\n\n\n\n// fragColor is the output state (position, velocity) for the ball whose data is stored in texel containing fragCoord\n// fragCoord is the current pixel coords in range 0.5 to resolution-0.5, in steps of 1.0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Convert to integer pixel coords, range 0 to resolution - 1\n    ivec2 xyPix = ivec2(floor(fragCoord.x), floor(fragCoord.y));\n\n    // Figure out which ball we're currently processing (which ball index corresponds to this texel)\n    int iChanRes0 = int(iChannelResolution[0].x);\n    int ballIdx = BallIndexFromBufferPixelPos(xyPix, iChanRes0);\n\n    // Check that the index is in the range that we are actually using.\n    // In general, most texels in this buffer will correspond to indices that we are not using,\n    // and we shouldn't attempt to simulate for those, so we check here and discard if this texel is not used.\n    if (ballIdx < 0 || ballIdx >= NUM_BALLS) \n        discard;\n\n    // If here then this texel corresponds to an actual ball.\n    // ballIdx is the index of the ball, where 0 <= ballIdx < NUM_BALLS\n\n    // Get the current data for this ball from iChannel0 (which contains our output from the previous frame).\n    // The four channels of this buffer are used to store position and velocity of each ball.\n    // (There's nothing special about this - the buffer just holds a vec4 for this texel,\n    //  the only reason they mean position and velocity is because that's what we've decided they mean).\n    // xy = Position\n    // zw = Velocity\n\n    // We access texels directly by integer coordinates (xyPix) without any interpolation \n    // by using 'texelFetch', NOT by using 'texture'.\n    // This is important! \n    // The information contained in each texel corresponds to a specific ball.\n    // As long as we know which texel is associated with which ball, it doesn't matter\n    // how they are arranged in texture space, i.e. what the actual texel coordinates are.\n    // Interpolating between texels is something that we NEVER want to do in this case,\n    // since a blend between the states of two unrelated balls is not useful information!\n    // Since we only ever want to access raw texel values, without interpolation, then\n    // using integer texel coordinates together with texelFetch is simpler and faster than using texture with floats.\n    vec4 posAndVel = texelFetch(iChannel0, xyPix, 0);\n\n    // Extract current ball state:\n    vec2 pos = posAndVel.xy;\n    vec2 vel = posAndVel.zw;\n\n    // Handle inter-ball collisions, if enabled.\n    // This updates this ball's position and velocity in response to any collisions with other balls.\n    if (enableInterBallCollisions)\n        handleInterBallCollisions(ballIdx, pos, vel);\n\n    // Move the ball\n    pos += vel;\n\n    // Air resistance slows balls over time.\n    vel *= 0.9999;\n\n    // Gravity constantly accelerates us down.\n    vel.y -= 0.0001;\n\n    // Handle wall collisions. Do this last to ensure we remain in bounds.\n    handleWallCollisions(pos, vel);\n\n\n    // If this is the first frame, initialize position and speed to something random.\n    // (Overwriting whatever was calculated above)\n    if (iFrame == 0) \n    {\n        vec2 uv = fragCoord.xy / iResolution.xy;\n        pos = vec2(rand(uv), rand(uv.yx));\n        vel = vec2((rand(uv + vec2(0.1))-0.5) / 30.0, (rand(uv + vec2(0.2))-0.5) / 30.0);\n    }\n\n    // Store position and speed for ball associated with this fragCoord in the output (which we will see as input iChannel0 on the next frame).\n    fragColor = vec4(pos, vel);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Number of balls to be simulated (Buffer A code) and rendered (Image code).\n// Can be any number up to the number of texels in this buffer (which is defined by the resolution)\n// For most practical purposes, this will always be enough.\n#define NUM_BALLS 300\n\n// Radius of balls - used for collision calculations and display.\n#define R 0.01\n\n\n\n// Given the index of a ball (0 to NUM_BALLS-1), returns the pixel UV coordinates in this buffer where the data for this ball is stored.\n// (This is the opposite mapping to BallIndexFromBufferPixelPos)\n// iChanRes0 has to be passed in, as it is not defined in Common.\nivec2 BufferPixelPosFromBallIndex(int ballIdx, int iChanRes0) \n{\n  int x = ballIdx % iChanRes0;\n  int y = ballIdx / iChanRes0;\n  return ivec2(x,y);\n}\n\n\n// Given a pixel XY position in iChannel0, return the index (0 to NUM_BALLS-1) of the ball this corresponds to,\n// i.e. the index of the ball whose data is stored at this XY coord.\n// (This is the opposite mapping to BufferPixelPosFromBallIndex)\n// iChanRes0 has to be passed in, as it is not defined in Common.\nint BallIndexFromBufferPixelPos(ivec2 xyPix, int iChanRes0) \n{\n  return int(xyPix.x + xyPix.y * iChanRes0);\n}\n\n\n\n\n","name":"Common","description":"","type":"common"}]}