{"ver":"0.1","info":{"id":"dd3GWB","date":"1677943814","viewed":127,"name":"That's no sponge","username":"rucksack","description":"Thanks again to Inigo Quilez: https://iquilezles.org/articles/menger/\nMenger sponge with sphere + cylinder crosses instead of cubes.\nTried a bunch of rendering techniques I haven't used (properly) before.\n","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fractal","menger","ambientocclusion","mengersponge"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Raymarching parameters\nconst int MAX_STEPS = 300;\nconst float TOO_FAR = 100.0;\nconst float NEAR_ENOUGH = 0.001;\nconst float NORMAL_DELTA = 0.0005;\n\n// Lighting parameters\nconst float DIFFUSE_RATIO = .5;\nconst float BECKMANN_ALPHA = .2; // = roughness^2\nconst float INDEX_OF_REFRACTION = .001;\nconst float LIGHT_INTENSITY = 1.3;\nconst float SHADOW_RATIO = .9;\n\n// Colors\nconst vec3 BACKGROUND_COLOR = .1*vec3(0.97255,0.95686,0.94118);\nconst vec3 SHADOW_COLOR     = .1*vec3(0.35686,0.14902,0.20392);\nconst vec3 TINT_COLOR       = .4*vec3(0.95686,0.14902,0.40392);\nconst vec3 SPECULAR_COLOR   = vec3(1);\n\n// TODO do a different animation?\n// TODO animate skewing of the sponge (with rotations)\n\n//#define ANIMATE_LIGHT\n//#define ANIMATE\n\n\nconst float PI = 3.14159265359;\nconst int SPONGE_ITERATIONS = 5;\n\nmat3 rotateY(float a) {\n    return mat3(\n        -sin(a),      0, cos(a),\n              0,      1, 0,\n         cos(a),      0, sin(a)\n    );\n}\n\nmat3 rotateX(float a) {\n    return mat3(\n              1,      0, 0,\n              0,      -sin(a), cos(a),\n              0,      cos(a), sin(a)\n    );\n}\n\nfloat rand(vec2 uv) {\n    return fract(sin(dot(uv, vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat dither(vec2 uv) {\n  return (rand(uv)*2. - 1.) / 156.;\n}\n\nfloat sphere(vec3 point, vec3 center, float radius) {\n    return length(point - center) - radius;\n}\n\n// Intersection of 2D cylinders in all directions\nfloat cylinders(vec3 point, float radius) {\n    float dx = length(point.yz) - radius;\n    float dy = length(point.xz) - radius;\n    float dz = length(point.xy) - radius;\n    return min(dx, min(dy, dz));\n}\n\nfloat cube(vec3 point, vec3 center, float size) {\n    vec3 q = abs(point) - center - size;\n    return max(q.x, max(q.y, q.z));\n}\n\nfloat distance_from_everything(vec3 point) {\n    float d = sphere(point, vec3(0), 2.);\n    float scale = 1.;\n    float increase = 3.;\n    float radius = .4;\n    for (int i = 0; i < SPONGE_ITERATIONS; i++) {\n        // Weird rotation (not used atm)\n        mat3 rotation = rotateY(sin(.5*iTime) * .1 * scale * PI / 4. + .5) * rotateX(sin(.5*iTime) * .1 * scale * 5. * PI / 3. + .3);\n        // Repeat\n        vec3 q = mod(point * scale, 2.) - 1.;\n        // Upscale\n        scale *= increase;\n        // Uhhh whatever this is (shifts position of crosses)\n        vec3 r = 1. - abs(q);\n\n        d = max(d, -cylinders(r, radius)/scale);\n    }\n    return d;\n}\n\nvec3 sun_position() {\n    float orbit_radius = 5.;\n#ifdef ANIMATE_LIGHT\n    return vec3(orbit_radius*cos(1.2*iTime), 2., orbit_radius*sin(1.2*iTime));\n#else\n    return vec3(-.5*orbit_radius, 1., -orbit_radius);\n#endif\n}\n\nfloat ray_march(vec3 ray_origin, vec3 ray_direction, out int steps, out float mindist) {\n    // How far we've traveled\n    float d = 0.0;\n    steps = 0;\n    mindist = TOO_FAR;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        // Where we stand\n        vec3 point = ray_origin + ray_direction*d;\n        // How far anything is from us\n        float current_distance = distance_from_everything(point);\n        mindist = min(mindist, current_distance);\n        // March on\n        d += current_distance;\n        steps++;\n        // Check status - have we reached a surface?\n        if (current_distance < NEAR_ENOUGH || d > TOO_FAR)\n            break;\n    }\n    return d;\n}\n\n// Approach taken from https://iquilezles.org/articles/rmshadows\nfloat ray_shadow(vec3 ray_origin, vec3 ray_direction, vec3 light_position) {\n    // Start some distance along the rain to avoid counting shadow because we're close to the surface\n    float d = NEAR_ENOUGH;\n    float shade = 1.0;\n    float shadow_factor = 32.;\n    // Sign of the direction we're travelling,\n    // if this changes we know that we passed the light source.\n    vec3 side = sign(light_position - ray_origin);\n    for (int i = 0; i < MAX_STEPS; i++) {\n        // Where we stand\n        vec3 point = ray_origin + ray_direction*d;\n        // How far anything is from us\n        float current_distance = distance_from_everything(point);\n        // March on\n        d += current_distance;\n        // Update to more significant shadow value\n        shade = min(shade, shadow_factor * current_distance / d);\n        // Only check if we've gone too far or gone beyond the light source\n        if (d > TOO_FAR || sign(light_position - point) != side)\n            break;\n    }\n    return max(shade, 0.);\n}\n\n// Estimate ambient occlusion using n steps along the normal\nfloat ray_occlusion(vec3 ray_origin, vec3 ray_direction) {\n    float k = 70.;\n    float delta = 7.*NEAR_ENOUGH;\n    float dist = delta;\n    float occlusion = 0.;\n    float decay = 0.5;\n    for (int i = 0; i < 5; i++) {\n        vec3 point = ray_origin + ray_direction * dist;\n        float current_distance = distance_from_everything(point);\n        occlusion += k * decay * (dist - current_distance);\n        decay *= 0.5;\n        dist += delta;\n    }\n    return 1. - occlusion;\n}\n\n// See https://iquilezles.org/articles/normalsSDF\nvec3 estimate_normal(vec3 point) {\n    vec2 e = vec2(NORMAL_DELTA, 0); // x smol, y none\n    // Find normal as tangent of distance function\n    return normalize(vec3(\n        distance_from_everything(point + e.xyy) - distance_from_everything(point - e.xyy),\n        distance_from_everything(point + e.yxy) - distance_from_everything(point - e.yxy),\n        distance_from_everything(point + e.yyx) - distance_from_everything(point - e.yyx)\n    ));\n}\n\nfloat beckmann_distribution(vec3 n, vec3 c, vec3 l, float m) {\n    vec3 h = (c + l) / 2.;\n    float a = acos(dot(n, h));\n    // Used abs(cos(a)) here, what's the proper way of doing this?\n    return exp(-pow(tan(a), 2.)/(m*m))/(PI*m*m*pow(abs(cos(a)), 4.));\n}\n\nfloat cook_torrance_specular(vec3 n, vec3 v, vec3 l) {\n    vec3 h = (v + l) / 2.;\n    float D = beckmann_distribution(n, v, l, BECKMANN_ALPHA);\n    float n2 = INDEX_OF_REFRACTION;\n    float reflectance = (1. - n2)/(1. + n2) * (1. - n2)/(1. + n2);\n    float theta = acos(dot(n, v));\n    float F = reflectance + (1. - reflectance)*pow(1. - cos(theta), 5.);\n    float G = min(1., min(2.*dot(h, n)*dot(v, n)/dot(v, h), 2.*dot(h, n)*dot(l, n)/dot(v, h)));\n    // Note that dot(n, l) is typically in the divisor here, but it serves only to cancel the diffuse dot(n, l)\n    return D*F*G/(4.*dot(v, n));\n}\n\nvec3 light_contribution(vec3 light_position, float light_intensity, vec3 light_color, vec3 surface_color, vec3 point, vec3 n, vec3 c) {\n    vec3 l = normalize(light_position-point);\n    // Cook-Torrance lighting\n    vec3 specular = cook_torrance_specular(n, c, l) * light_color;\n    vec3 light = light_intensity * (max(dot(n, l), 0.) * DIFFUSE_RATIO * surface_color + (1. - DIFFUSE_RATIO) * specular);\n\n    // Find soft shadow factor by marching from where you stand\n    float shade = ray_shadow(point, l, light_position);\n    return mix(SHADOW_COLOR, light, shade * SHADOW_RATIO + (1. - SHADOW_RATIO));\n}\n\nvec3 lighting(vec3 point, vec3 camera, vec3 ray_direction, float dist, int steps, float mindist) {\n    if (length(point - camera) > TOO_FAR*0.99) {\n        return BACKGROUND_COLOR + .07*log(1./mindist);\n    }\n\n    vec3 n = estimate_normal(point);\n    vec3 c = normalize(camera-point);\n\n    vec3 surface_color = (.5*abs(n)+.5).xzy ; // color values in the range [0.6, 1.0]\n    // Base color is affected by ambient occlusion\n    float ambient_occlusion = ray_occlusion(point, n);\n    vec3 color = mix(SHADOW_COLOR, .3*surface_color, ambient_occlusion);\n    color += light_contribution(sun_position(), 1.2, SPECULAR_COLOR, surface_color, point, n, c);\n    color += light_contribution(vec3(3., 4., 5.), .2, vec3(0, 0, 0.4), surface_color, point, n, c);\n\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 xy = (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n#ifdef ANIMATE\n    // Animate camera zooming in, zooming out, rotating to next hole, etc.\n    // TODO make period work\n    float period = 2.;\n    float a = round(iTime/period)*PI/2.;\n    float zoom = 0.;\n    float modt = mod(iTime, period);\n    if (modt > period/2.) {\n        zoom = 1.-abs(2.*(modt-period*0.75));\n    } else{\n        a += modt*PI/2.;\n    }\n#else\n    float a = PI/2. + m.x*PI*2.;\n    float zoom = m.y;\n#endif\n    if (iMouse.x == 0. && iMouse.y == 0.) {\n        a = PI/2.;\n        zoom = 0.;\n    }\n    \n    mat3 rotY = mat3(\n        -sin(a),      0, cos(a),\n              0,      1, 0,\n         cos(a),      0, sin(a)\n    );\n    mat3 rot = rotY;\n\n    // Ray origin\n    vec3 camera = vec3(0., 0., (1.-zoom) * -4.5) * rot;\n    // Ray direction\n    vec3 ray_direction = vec3(xy, 1.) * rot;\n\n    int steps;\n    float mindist;\n    float dist = ray_march(camera, ray_direction, steps, mindist);\n    \n    vec3 point = camera + ray_direction * dist;\n    \n    vec3 base_color = lighting(point, camera, ray_direction, dist, steps, mindist);\n\n\n    fragColor = vec4(base_color + dither(fragCoord), 1.);\n}","name":"Image","description":"","type":"image"}]}