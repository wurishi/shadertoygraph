{"ver":"0.1","info":{"id":"4XtSRl","date":"1719744827","viewed":73,"name":"UV 2D Matrix Transform","username":"luckebjucke","description":"An example of how to create a 3X3 Transform Matrix that allows for Scale, Rotation, Translation and Scew on 2D UV-coordinates.\n\nA Key and Mouse = Scale\nS Key and Mouse = Translation\nD Key and Mouse = Rotation\nF Key and Mouse = Scew","likes":3,"published":1,"flags":16,"usePreview":1,"tags":["2d","uv","matrix","rotation","translation","coordinates","scale","transform","screw","3x3matrix"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define pi 3.14159265359\n\n// transfrom Matrix to control a UV:s Pivot, Scale, Scew, Position and Rotation.\nvec2 transformUV (vec2 uv, vec2 pivot, vec2 scale, vec2 scew, vec2 position, float rotationAngle)\n{\n    // UV (U) Matrix Components\n    float uX =  scale.x * cos(rotationAngle) + scew.x * scale.y * sin(rotationAngle); // Scale, Rotation and Scew.\n    float uY = -scale.x * sin(rotationAngle) + scew.x * scale.y * cos(rotationAngle); // Scale, Rotation and Scew.\n    float uZ = -(pivot.x + position.x) * uX - (pivot.y + position.y) * uY + pivot.x;  // Pivot and Translation.\n    \n    // UV (V) Matrix Components\n    float vX =  scale.y * sin(rotationAngle) + scew.y * scale.x * cos(rotationAngle); // Scale, Rotation and Scew.\n    float vY =  scale.y * cos(rotationAngle) + scew.y * scale.x * sin(rotationAngle); // Scale, Rotation and Scew.\n    float vZ = -(pivot.x + position.x) * vX - (pivot.y + position.y) * vY + pivot.y;  // Pivot and Translation.\n    \n    \n    // Add in a third component to the UV:s so Translation and Pivot is possible\n    vec3 uvMat3 = vec3(uv,1.0);\n    \n    // Scale, Scew, Rotation, Translation Matrix\n    mat3 Transform;\n         Transform[0] = vec3(uX, uY, uZ);\n         Transform[1] = vec3(vX, vY, vZ);\n    \n    // Multiply the Transfrom Matrix with the UV:s\n    uvMat3 *= Transform;\n    \n    // Make the UV:s a vec2 again.\n    return uvMat3.xy;\n}\n\n// Find the all Key codes here: http://gcctech.org/csc/javascript/javascript_keycodes.htm\nconst int A_KEY = 65;\nconst int S_KEY = 83;\nconst int D_KEY = 68;\nconst int F_KEY = 70;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Toggle for when a specific key is pressed. From Inigo Quilez: https://www.shadertoy.com/view/lsXGzf\n    float aKey = texelFetch( iChannel1, ivec2(A_KEY,0),0 ).x;\n    float sKey = texelFetch( iChannel1, ivec2(S_KEY,0),0 ).x;\n    float dKey = texelFetch( iChannel1, ivec2(D_KEY,0),0 ).x;\n    float fKey = texelFetch( iChannel1, ivec2(F_KEY,0),0 ).x;\n    \n    // find largest of X and Y iResolution\n    float iRes = min(iResolution.x,iResolution.y);\n    \n    // Create occilation for iTime that goes from 0 to 1 to 0\n    float time = (sin(iTime*0.5*pi)+1.0)*0.5; //Make the sin curve 0-1 range in both Amplitude and Frequency.\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // UV Pivot\n    vec2 pivot = vec2(0.5);\n    \n    // Find how much to scale to make X and Y 1:1\n    vec2 ratio = iResolution.xy / iRes;\n    \n    // correct UV:s so they are 1:1.\n    uv -= .5;    // Subtract the UV by 0.5 to shift 0.0 to the center.\n    uv *= ratio; // Scale the UV:s with ratio.\n    uv += .5;    // add back 0.5 to reset 0.0.\n    \n    // Get Mouse Position. From Inigo Quilez: https://www.shadertoy.com/view/Mss3zH\n    vec4  m      = iMouse / iRes;\n    float mDown  = step(0.0,m.z);                                  // Check if Left Mouse Button is down.\n    vec2  mRot   = vec2(m.x-pivot.x*ratio.x, m.y-pivot.y*ratio.y); // Mouse Control Rotation.\n    vec2  mPos   = (m.xy - 0.5*ratio);                             // Mouse Control Position.\n    vec2  mScale = vec2(1.0/distance(m.xy,pivot*ratio));           // Mouse Control Scale.\n    vec2  mScew  = vec2(m.x-pivot.x*ratio.x, m.y-pivot.y*ratio.y); // Mouse Control Scew.\n    \n    // Variables to control Scale, Rotation, Translation and pivot\n    vec2  scale = mScale * aKey * mDown + (1.0 - aKey * mDown);\n    vec2  localPos = mPos * sKey * mDown;\n    float angle = atan(mRot.x,mRot.y) * dKey * mDown;\n    vec2  scew = mScew * fKey * mDown;\n\n\n    // Use the transfromUV function to control: pivot, scale, scew, translation and rotation. \n    uv = transformUV(uv, pivot, scale, scew, localPos, angle);\n    \n    \n    // Remove tiling by clamping the UV coordinates from 0 to 1.\n    uv = clamp(uv,0.0,1.0);\n    \n    // Creates a mask to remove the streched UV:s when clamping \n    float mask  = min(uv.x,1.0-uv.x)*2.0;\n          mask *= min(uv.y,1.0-uv.y)*2.0;\n          mask  = step(mask, 0.0);\n          mask  = 1.0 - mask;\n    \n    // Samples the texture\n    vec4 tex = texture(iChannel0,uv);\n    tex *= mask; // Multiply in the mask to hide streching artifacts.\n    \n\n    // Output to screen\n    fragColor = tex;\n}","name":"Image","description":"","type":"image"}]}