{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"video","id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"#define M_PI 3.1415926535897932384626433832795\n\n\n#define CENTER_X 0.5         // Center of the polar source (horizontal)\n#define CENTER_Y 0.5         // Center of the polar source (vertical)\n#define RADIUS_SCALE 1.0     // Scaling for the radius\n#define ANGLE_SCALE 1.0      // Scaling for the angular resolution\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized UV coordinates\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // Map rectangular UVs to polar space\n    float radius = (1.0 - uv.y) * RADIUS_SCALE;  // Invert radius mapping (1.0 - uv.y)\n    float angle = uv.x * 2.0 * M_PI * ANGLE_SCALE; // Angle corresponds to horizontal position\n\n    // Convert polar coordinates back to Cartesian\n    float x = radius * cos(angle);\n    float y = radius * sin(angle);\n\n    // Map Cartesian coordinates back to UV space\n    vec2 cartesianUV = vec2(x, y) + vec2(CENTER_X, CENTER_Y);\n\n    // Sample the texture\n    fragColor = texture(iChannel0, cartesianUV);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4cyBRR","date":"1733660908","viewed":84,"name":"Polar to Rectangular","username":"Sleng","description":"simple function for polar to rectangular conversion","likes":1,"published":3,"flags":0,"usePreview":0,"tags":["uv","polar"],"hasliked":0,"parentid":"","parentname":""}}