{"ver":"0.1","info":{"id":"Md3cDN","date":"1518875444","viewed":311,"name":"filtering: smoothstep texcoords","username":"hornet","description":"Shows the non-linearity of smoothstepping texturecoordinates to improve texture-filtering\nred: linear\ngreen: texcoord-smoothstep\nblue: catmull rom\nclone of https://www.shadertoy.com/view/XsfGDn","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["2d","texture","filtering","smoothstep"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//note: variant of https://www.shadertoy.com/view/XsfGDn\n//\n// original license / description:\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-ShareAlike 3.0 Unported\n// https://creativecommons.org/licenses/by-sa/3.0/\n//\n// This is the implementation for my article \"improved texture interpolation\"\n// https://iquilezles.org/articles/texture\n\n\nvec4 textureCatmullRom( sampler2D smplr, vec2 uv  );\nvec4 textureBicubic(sampler2D smplr, vec2 uv);\nvec4 textureBilinear( sampler2D smplr, vec2 uv );\n\nvec4 textureBilinear( sampler2D smplr, vec2 uv )\n{\n    return texture( smplr, uv, -10.0 );\n    //return vec3( uv.x );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy / iResolution.xy;\n    vec2 uv = p*0.1;\n\t\n    //---------------------------------------------\t\n\t// regular texture map filtering\n    //---------------------------------------------\t\n\tvec3 colA = textureBilinear( iChannel0, uv ).rgb;\n    \n    //-------------------------------------------1--\t\n\t// my own filtering \n    //---------------------------------------------\t\n\tfloat textureResolution = 64.0;\n\tuv = uv*textureResolution + 0.5;\n\tvec2 iuv = floor( uv );\n\tvec2 fuv = fract( uv );\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv); // fuv*fuv*fuv*(fuv*(fuv*6.0-15.0)+10.0);;\n\tuv = (uv - 0.5)/textureResolution;\n\tvec3 colB = textureBilinear( iChannel0, uv ).rgb;\n\t\n    vec3 colC = textureCatmullRom( iChannel0, uv ).rgb;\n    //vec3 colC = textureBicubic( iChannel0, uv).rgb;\n    \n   \n    //note: vis\n    vec2 xy = vec2(fragCoord/iResolution.xy);\n    vec3 col = vec3(0.0);\n    if ( xy.y > 0.85 )\n    {\n        col = 10.0 * colA;\n        if ( xy.x < 0.0125 ) col = vec3(1,0,0);\n    }\n    else if ( xy.y > 0.7 )\n    {\n        col = 10.0 * colB;\n        if ( xy.x < 0.0125 ) col = vec3(0,1,0);\n    }\n    else if ( xy.y > 0.55 )\n    {\n        col = 10.0 * colC;\n        if ( xy.x < 0.0125 ) col = vec3(0,0,1);\n    }\n    else if ( xy.y > 0.45 )\n    {\n        col = vec3(0);\n    }\n    else if ( xy.y > 0.3 )\n    {\n        float luv_y = (xy.y-0.3)/0.15;\n        col = vec3(step( 10.0*colA.x, luv_y ));\n        if ( xy.x < 0.0125 ) col = vec3(1,0,0);\n    }\n    else if ( xy.y > 0.15 )\n    {\n        float luv_y = (xy.y-0.15)/0.15;\n        col = vec3(step( 10.0*colB.x, luv_y ));\n        if ( xy.x < 0.0125 ) col = vec3(0,1,0);\n    }\n    else\n    {\n        float luv_y = (xy.y-0.0)/0.15;\n        col = vec3(step( 10.0*colC.x, luv_y ));\n        if ( xy.x < 0.0125 ) col = vec3(0,0,1);\n    }\n    \n    fragColor = vec4( col, 1.0 );\n}\n\n\n\n//note: entirely stolen from https://www.shadertoy.com/view/Ml2yD3\nvec4 cubic(float v)\n{\n    vec4 n = vec4(1.0, 2.0, 3.0, 4.0) - v;\n    vec4 s = n * n * n;\n    vec4 o;\n    o.x = s.x;\n    o.y = s.y - 4.0 * s.x;\n    o.z = s.z - 4.0 * s.y + 6.0 * s.x;\n    o.w = 6.0 - o.x - o.y - o.z;\n    return o;\n}\nvec4 textureBicubic(sampler2D smplr, vec2 uv)\n{\n   \tvec2 texSize = vec2(textureSize(smplr, 0));\n   \tvec2 invTexSize = 1.0 / texSize;\n\n   \tuv = uv * texSize - 0.5;\n\n    vec2 fxy = fract(uv);\n    uv -= fxy;\n\n    vec4 xcubic = cubic(fxy.x);\n    vec4 ycubic = cubic(fxy.y);\n\n    vec4 c = uv.xxyy + vec2 (-0.5, +1.5).xyxy;\n\n    vec4 s = vec4(xcubic.xz + xcubic.yw, ycubic.xz + ycubic.yw);\n    vec4 offset = c + vec4 (xcubic.yw, ycubic.yw) / s;\n\n    offset *= invTexSize.xxyy;\n\n    vec4 sample0 = texture(smplr, offset.xz);\n    vec4 sample1 = texture(smplr, offset.yz);\n    vec4 sample2 = texture(smplr, offset.xw);\n    vec4 sample3 = texture(smplr, offset.yw);\n\n    float sx = s.x / (s.x + s.y);\n    float sy = s.z / (s.z + s.w);\n\n    return mix(\n       mix(sample3, sample2, sx), mix(sample1, sample0, sx)\n    , sy);\n}\n\n\n// Samples a texture with Catmull-Rom filtering, using 9 texture fetches instead of 16.\n// See http://vec3.ca/bicubic-filtering-in-fewer-taps/ for more details\n// note: entirely stolen from https://gist.github.com/TheRealMJP/c83b8c0f46b63f3a88a5986f4fa982b1\nvec4 sampleLevel0( sampler2D smplr, vec2 uv )\n{\n    return texture( smplr, uv, -10.0 );\n}\nvec4 textureCatmullRom( sampler2D smplr, vec2 uv  )\n{\n    vec2 texSize = vec2(textureSize( smplr, 0 ).xy);\n        \n    // We're going to sample a a 4x4 grid of texels surrounding the target UV coordinate. We'll do this by rounding\n    // down the sample location to get the exact center of our \"starting\" texel. The starting texel will be at\n    // location [1, 1] in the grid, where [0, 0] is the top left corner.\n    vec2 samplePos = uv * texSize;\n    vec2 texPos1 = floor(samplePos - 0.5) + 0.5;\n\n    // Compute the fractional offset from our starting texel to our original sample location, which we'll\n    // feed into the Catmull-Rom spline function to get our filter weights.\n    vec2 f = samplePos - texPos1;\n\n    // Compute the Catmull-Rom weights using the fractional offset that we calculated earlier.\n    // These equations are pre-expanded based on our knowledge of where the texels will be located,\n    // which lets us avoid having to evaluate a piece-wise function.\n    vec2 w0 = f * ( -0.5 + f * (1.0 - 0.5*f));\n    vec2 w1 = 1.0 + f * f * (-2.5 + 1.5*f);\n    vec2 w2 = f * ( 0.5 + f * (2.0 - 1.5*f) );\n    vec2 w3 = f * f * (-0.5 + 0.5 * f);\n    \n    // Work out weighting factors and sampling offsets that will let us use bilinear filtering to\n    // simultaneously evaluate the middle 2 samples from the 4x4 grid.\n    vec2 w12 = w1 + w2;\n    vec2 offset12 = w2 / (w1 + w2);\n\n    // Compute the final UV coordinates we'll use for sampling the texture\n    vec2 texPos0 = texPos1 - vec2(1.0);\n    vec2 texPos3 = texPos1 + vec2(2.0);\n    vec2 texPos12 = texPos1 + offset12;\n\n    texPos0 /= texSize;\n    texPos3 /= texSize;\n    texPos12 /= texSize;\n\n    vec4 result = vec4(0.0);\n    result += sampleLevel0( smplr, vec2(texPos0.x,  texPos0.y)) * w0.x * w0.y;\n    result += sampleLevel0( smplr, vec2(texPos12.x, texPos0.y)) * w12.x * w0.y;\n    result += sampleLevel0( smplr, vec2(texPos3.x,  texPos0.y)) * w3.x * w0.y;\n\n    result += sampleLevel0( smplr, vec2(texPos0.x,  texPos12.y)) * w0.x * w12.y;\n    result += sampleLevel0( smplr, vec2(texPos12.x, texPos12.y)) * w12.x * w12.y;\n    result += sampleLevel0( smplr, vec2(texPos3.x,  texPos12.y)) * w3.x * w12.y;\n\n    result += sampleLevel0( smplr, vec2(texPos0.x,  texPos3.y)) * w0.x * w3.y;\n    result += sampleLevel0( smplr, vec2(texPos12.x, texPos3.y)) * w12.x * w3.y;\n    result += sampleLevel0( smplr, vec2(texPos3.x,  texPos3.y)) * w3.x * w3.y;\n\n    return result;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = vec4(uv.xxx, 0);\n}","name":"Buffer A","description":"","type":"buffer"}]}