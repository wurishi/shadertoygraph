{"ver":"0.1","info":{"id":"stBSWc","date":"1628956960","viewed":530,"name":"Watchtower (4k exe gfx)","username":"slerpy","description":"[url]https://www.pouet.net/prod.php?which=89602[/url]","likes":36,"published":1,"flags":32,"usePreview":0,"tags":["4k","demoscene","evoke","watchtower","exegfx","slerpy","nevoke"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sinmix(vec2 p) {\n    float l=length(p),s=sqrt(.5),r=.25+.5*s-l;\n    mat2 m=mat2(s,s,-s,s);p=abs(m*p)*m;\n    return min(max(max(l-1.,r),p.y),-min(r,p.y));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec4 col = texelFetch(iChannel1,ivec2(fragCoord.xy),0);\n\tcol = max(col / col.w, 0.0);\n\n    // add little logo in the bottom right\n\tfloat size = round(iResolution.y / 64.0);\n\tvec2 v = (fragCoord.xy - vec2(iResolution.x - 2.0 * size, 2.0 * size)) / size;\n\tcol += 0.1 * (1.0 - smoothstep(-0.5, 0.5, size * sinmix(v)));\n    \n    // brightness and gamma correction\n\tfragColor = pow(3.7 * col, vec4(1) / 2.2);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// This shader starts off with an empty canvas and\n// sequentially places smaller and smaller boxes\n// of varying aspect ratio onto it.\n//\n// This texture is used as heigh-map, color-map and\n// displacement-map in the render.\n//\n// The executable uses a small square shaped texture\n// here instead of a screen sized one, but since the\n// exact size of the texture doesn't matter for the\n// purpose of this render, this Shadertoy uses a\n// fullscreen one instead.\n\nconst int batch_size = 256;\n\nvec4 rv;\nvoid shuffle() {\n    rv = fract(sin(1e4*rv)+rv.wxyz);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if (iFrame > 8) discard;\n    \n    // fetch color from last frame\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    if (iFrame > 4) return;\n\n    // init random number generator\n    rv = vec2(2 * batch_size, 1).xxyy + float(iFrame) / 50.0;\n    for (int i=0; i<5; i++) shuffle();\n\n    // compute uv coordinates\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // draw boxes one after the other\n    for(int i=0; i<batch_size; i++) {\n        float t = float(iFrame * batch_size + i) / 100.0;\n        \n        // get width and height of the box to draw\n        float r = 1.0 / rv.z - 1.0;\n        vec2 s = vec2(r, 1.0 / r) * exp(-t);\n        \n        // compute signed distance to the box\n        vec2 a = max(abs(fract(uv + rv.xy) - 0.5) - s, 0.0);\n        float d = max(a.x, a.y);\n        shuffle();\n\n        // update color if pixel is inside the box\n        if (d <= 0.0) {\n            fragColor = vec4(rv.w);\n        }\n\n        shuffle();\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"const float pi = acos(-1.0);\n\nvec4 rv;\nvoid shuffle() {\n    rv = fract(sin(1e4 * rv) + rv.wxyz);\n}\n\n// based on this article by fizzer\n// http://amietia.com/lambertnotangent.html\nvec4 bsdf_sample(vec3 n) {\n    float a = 2.0 * pi * rv.x;\n    float b = 2.0 * rv.y - 1.0;\n    float c = sqrt(1.0 - b*b);\n    shuffle();\n\n    vec3 h = vec3(c * cos(a), b, c * sin(a));\n    vec3 v = normalize(n + h);\n    return vec4(v, dot(v, n) / pi);\n}\n\nmat2 rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat h = 0.0;\nfloat height(vec2 p) {\n    const float s = 8.0;\n    float l = 0.7 * texture(iChannel0, 0.1 * p / s).x;\n    h = 0.3 * texture(iChannel0, p / s).x;\n    if (length(max(abs(p)-0.5, 0.0)) == 0.0) return 0.0;\n    vec2 r = step(0.12, abs(fract(p.xy)-0.5));\n    return mix(0.0, l + h, min(r.x, r.y));\n}\n\n// routine for intersecting with the city scape\nfloat ground(vec3 ro, vec3 rd) {\n    const int iter = 250;\n    const float amp = 2.0;\n\n    // intersect ray with the upper and lower bound of the city scape\n    ro.y += 1.0 + amp / 2.0;\n    float t_min = -(ro.y - amp) / rd.y;\n    float t_max = -ro.y / rd.y;\n\n    // search range for first intersection\n    float t = t_min;\n    for (int i=0; i < iter; i++) {\n        t = mix(t_min, t_max, (float(i) + rv.x) / float(iter));\n        vec3 p = ro + rd * t;\n        if (p.y < amp * height(p.xz)) break;\n    }\n\n    shuffle();\n\n    // fail to intesect in case the found intersection is behind the camera\n    if (t < 0.001) {\n        return 1e30;\n    }\n\n    return t;\n}\n\n// SDF formular for the tower in the middle of the scene\nfloat tower(vec3 p) {\n    const float m = pi / 8.0;\n    float fa = atan(p.x, p.z);\n    float a = mod(fa + m, 2.0 * m) - m;\n    p.xz = length(p.xz) * vec2(cos(a), sin(a));\n\n    p.y -= 1.5;\n    vec3 ap = abs(p);\n    return sqrt(0.5) * max(\n        min(\n            max(min(p.x - 0.25, max(p.x - 0.26, abs(mod(p.y, 0.6)-0.3)-0.01)), p.y + 0.4),\n            abs(max(ap.x + ap.y - 0.65, max(ap.x, p.y) - 0.45)) - 0.05\n        ),\n        0.13 - max(ap.y + 0.04, ap.z)\n    ) + 0.008 * texture(iChannel0, 0.1 * vec2(fa, p.y)).x;\n}\n\n// routine for intersecting with the geometry\nfloat trace(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    for (int i=0; i < 100; i++) {\n        t += tower(ro + rd * t);\n    }\n\n    return min(t, ground(ro, rd));\n}\n\n// taken from yx\nvec2 bokeh() {\n    vec2 a = rv.zw;\n    a.x = a.x * 3.0 - 1.0;\n    a -= step(1.0, a.x + a.y);\n\ta.x += a.y * 0.5;\n\ta.y *= sqrt(0.75);\n    return a;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0);\n\n    if (iFrame > 4) {\n        fragColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    }\n    \n    // only render part of the screen in one frame\n    // (not present in the actual entry)\n    if (int(3.0 * fragCoord.x / iResolution.x) != iFrame % 3) {\n        return;\n    }\n\n    rv = vec4(fragCoord.xy, float(iFrame) / 60.0, 1);\n    for (int i=0; i<5; i++) shuffle();\n\n    // setup camera\n    const float focal = 10.0;\n\n    vec2 uv = (2.0 * (fragCoord.xy + rv.xy - 0.5) - iResolution.xy) / iResolution.y;\n    vec2 dof = 2.5 * bokeh() * rot(0.3);\n\n    vec3 ro = vec3(dof / focal, -30);\n    vec3 rd = normalize(vec3(uv - dof / length(ro), focal - 0.35));\n    shuffle();\n\n    ro.yz *= rot(-0.43);\n    rd.yz *= rot(-0.43);\n    ro.xz *= rot(-0.5);\n    rd.xz *= rot(-0.5);\n\n    // intersect primary ray\n    float t = trace(ro, rd);\n    vec3 sp = ro + rd * t;\n\n    // sample bsdf and bounce ray\n    vec4 samp = bsdf_sample(vec3(0, 1, 0));\n\n    vec3 ld = samp.xyz;\n    bool shadow = trace(sp + 0.02 * ld, ld) < 100.0;\n\n    // add lighting if the ray hit the skybox\n    if (!shadow) {\n        float r = 1.1 * texture(iChannel0, 0.02 * (sp.xz + sp.y)).x;\n        r = smoothstep(0.0, 1.0, r);\n        r = smoothstep(0.0, 1.0, r);\n        r *= smoothstep(-0.5, 0.5, -sp.y);\n        vec3 hue = vec3(1.0-r, 1.0-0.75*r, 1);\n        vec3 col = 1.0 - 0.3 * vec3(-ld.x, 0, ld.x);\n        fragColor.xyz += hue * col * h;\n    }\n\n    // add fancy grid lines\n    for(int i = -1; i < 1; i++) {\n        float gt = -(ro.y - float(i)) / rd.y;\n        if (gt > t) continue;\n\n        vec2 gp = (ro + rd * gt).xz;\n        vec2 gu = abs(fract(gp / 3.0) - 0.5);\n        fragColor.xyz += 0.02 * step(min(gu.x, gu.y), .002);\n    }\n\n    fragColor.w += 1.0;\n}\n","name":"Buffer B","description":"","type":"buffer"}]}