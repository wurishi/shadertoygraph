{"ver":"0.1","info":{"id":"ldVfzy","date":"1529425866","viewed":154,"name":"Bad Shadow Box","username":"hypothete","description":"I\"m having a rough time trying to understand shadows. I haven't found sample code for simple hard shadows, so I'm working off of iq's improved soft shadow function. As you can see I'm getting a lot of artifacts. Any advice on where to start?\n\n","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sdf","cornellbox","shadows"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPSILON 0.01\n#define MAXSTEPS 128\n#define NEAR 0.1\n#define FAR 100.0\n#define TWOPI 6.28319\n\nprecision mediump float;\n\nstruct Camera {\n    vec3 pos;\n    vec3 dir;\n};\n\nfloat rand (vec2 st) {\n    return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\n\nfloat udfBox( vec3 p, vec3 b ) {\n    return length(max(abs(p)-b, 0.0));\n}\n\nfloat dot2( in vec3 v ) {\n    return dot(v,v);\n}\n\nfloat udfQuad( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d ) {\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 dc = d - c; vec3 pc = p - c;\n    vec3 ad = a - d; vec3 pd = p - d;\n    vec3 nor = cross( ba, ad );\n\n    return sqrt(\n        (sign(dot(cross(ba,nor),pa)) +\n         sign(dot(cross(cb,nor),pb)) +\n         sign(dot(cross(dc,nor),pc)) +\n         sign(dot(cross(ad,nor),pd))<3.0)\n        ?\n        min( min( min(\n            dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n            dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n                 dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n            dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n        :\n        dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nvec2 sceneSDF(vec3 p) {\n    \n    // x is distance to scene, y is object id\n\n    float id = 0.0;\n    float cr = 5.0;\n\n    vec3 q = p - vec3(0.0, 0.0, 10.0);\n    vec3 ca = vec3(-cr,  cr,  cr);\n    vec3 cb = vec3( cr,  cr,  cr);\n    vec3 cc = vec3(-cr, -cr,  cr);\n    vec3 cd = vec3( cr, -cr,  cr);\n    vec3 ce = vec3(-cr,  cr, -cr);\n    vec3 cf = vec3( cr,  cr, -cr);\n    vec3 cg = vec3(-cr, -cr, -cr);\n    vec3 ch = vec3( cr, -cr, -cr);\n\n    vec3 b1 = vec3(1.0);\n    float box1 = udfBox(p - vec3(-2.0, -cr+b1.y, 10.0), b1);\n\n    vec3 b2 = vec3(1.5, 3.0, 1.5);\n    float box2 = udfBox(p - vec3(2.0, -cr+b2.y, 9.0), b2);\n\n    float tot = FAR;\n\n    float back = udfQuad(q, ca, cb, cd, cc);\n    float right = udfQuad(q, cb, cf, ch, cd);\n    if (right < EPSILON) { id = 1.0; }\n    float left = udfQuad(q, ce, ca, cc, cg);\n    if (left < EPSILON) { id = 2.0; }\n    float top = udfQuad(q, ce, cf, cb, ca);\n    float bottom = udfQuad(q, cc, cd, ch, cg);\n\n    tot = min(tot, back);\n    tot = min(tot, right);\n    tot = min(tot, left);\n    tot = min(tot, top);\n    tot = min(tot, bottom);\n    tot = min(tot, box1);\n    tot = min(tot, box2);\n\n    return vec2(tot, id);\n}\n\nvec3 sceneNormal(vec3 p) {\n    vec3 v1 = vec3(1.0, -1.0, -1.0);\n    vec3 v2 = vec3(-1.0, -1.0, 1.0);\n    vec3 v3 = vec3(-1.0, 1.0, -1.0);\n    vec3 v4 = vec3(1.0, 1.0, 1.0);\n    return normalize(\n        v1 * sceneSDF(p + v1*EPSILON).x +\n        v2 * sceneSDF(p + v2*EPSILON).x +\n        v3 * sceneSDF(p + v3*EPSILON).x +\n        v4 * sceneSDF(p + v4*EPSILON).x\n    );\n}\n\nfloat distToSurface(Camera c, out vec3 ip, out float id) {\n    float depth = NEAR;\n    for (int i=0; i<MAXSTEPS; i++) {\n        ip = c.pos + c.dir * depth;\n        vec2 distToScene = sceneSDF(ip);\n        id = distToScene.y;\n        if (distToScene.x < EPSILON) {\n            return depth;\n        }\n        depth += distToScene.x;\n        if (depth >= FAR) {\n            return FAR;\n        }\n    }\n    return depth;\n}\n\nfloat lambert(vec3 norm, vec3 lpos) {\n    return max(dot(norm, normalize(lpos)), 0.0);\n}\n\nfloat shadow(vec3 ro, vec3 rd) {\n\t// based off of https://iquilezles.org/articles/rmshadows\n    float res = 1.0;\n    float ph = 1e20;\n    float tmin = 0.1;\n    float tmax = 2.0;\n    float k = 8.0;\n\n    for (float t = tmin; t < tmax;) {\n        vec2 h = sceneSDF(ro + rd * t);\n        if (h.x < EPSILON) {\n            return 0.0;\n        }\n        float y = (h.x * h.x) / (2.0 / ph);\n        float d = sqrt((h.x * h.x) - (y * y));\n        res = min(res, k * d / max(0.0, t - y));\n        ph = h.x;\n        t += h.x;\n    }\n    return res;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2. * fragCoord.xy - iResolution.xy) / iResolution.y;\n    vec3 nrmDir = normalize(vec3(uv, 1.0));\n    Camera camera = Camera(vec3(0.0, 0.0, 0.0), nrmDir);\n    vec3 endPt;\n    vec3 col = vec3(0.0);\n    float id = 0.0;\n    float t = distToSurface(camera, endPt, id);\n\n    if (t < FAR) {\n        vec3 nrm = sceneNormal(endPt);\n\n        if (id == 1.0) {\n            col = vec3(0.8, 0.1, 0.1);\n        }\n        else if(id == 2.0) {\n            col = vec3(0.1, 0.8, 0.1);\n        }\n        else {\n            col = vec3(0.9);\n        }\n\n        vec3 lpos = vec3(4.5 * sin(iTime), -4.0, 7.5 + 4.5 * cos(iTime)); // light position top\n\n        float lamb = lambert(nrm, lpos - endPt);\n        float shad = shadow(endPt, normalize(lpos - endPt));\n\n        col *= lamb;\n        col *= max(0.2, shad);\n\n    } \n\n    col = pow(col, vec3(0.4545)); // gamma\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}