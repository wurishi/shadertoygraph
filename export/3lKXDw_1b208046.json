{"ver":"0.1","info":{"id":"3lKXDw","date":"1582855187","viewed":51,"name":"Ray March 4","username":"baksej","description":"ray march 4","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat smin(float a, float b, float k) {\n \tfloat h = clamp(.5 + .5 * (b - a) / k, 0.0, 1.0);   \n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat sphere(vec3 pos, float radius){\n \treturn length(pos) - radius;   \n}\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123);\n}\n\nfloat map(float v, float a, float b, float x, float y){\n \tfloat n = (v - a) / (b - a);\n \treturn x + n * (y - x);\n}\n\nfloat ground(vec3 pos) {\n    return pos.y;\n    \n}\n\n\nfloat scene(vec3 pos){\n    \n    vec3 i = floor(pos / .2);\n    \n    vec3 pos1 = pos;\n    \n \tfloat s1 = sphere(pos1, .2);\n   \n    \n    vec3 pos2 = pos;\n    pos2.y += 30.0 + .1;\n    pos2.z -= 1.0;\n    float s2 = sphere(pos2, 30.0);\n    \n \n    return smin(s1, s2, .15);\n}\n\nvec3 estimateNormal(vec3 pos){\n    \n \treturn normalize(\n    vec3(\n        scene(pos - vec3(.001, .0, .0)) - scene(pos + vec3(.001, .0, .0)),\n        scene(pos - vec3(.0, .001, .0)) - scene(pos + vec3(.0, .001, .0)),\n        scene(pos - vec3(.0, .0, .001)) - scene(pos + vec3(.0, .0, .001))\n        \n    ));   \n}\n\n//https://iquilezles.org/articles/rmshadows\n    // these probably have pretty bad performance\n    // they are modified from iq's, but I made a lot of changes\n    // to explore how they work without worrying about speed\n\n// float jshadow( in vec3 light, in vec3 pos)\n// {\n//     float dist = distance(light, pos);\n//     vec3 dir = normalize(pos - light);\n    \n//     for( float t=.1; t<dist-.01; )\n//     {\n//         float h = scene(light + dir*t);\n//         if( h<0.001 )\n//             return 0.0;\n//         t += clamp(h, 0.01, 0.50);\n//     }\n//     return 1.0;\n// }\n\n float jsoftshadow( in vec3 light, in vec3 pos, float w )\n {\n     float dist = distance(light, pos);\n     vec3 dir = normalize(pos - light);\n    \n     float s = 1.0;\n     for( float t=.1; t<dist-.1; )\n     {\n         float h = scene(light + dir*t);\n         s = min( s, 0.5+0.5*h/(w*t) );\n         if( s<0.0 ) break;\n         t += clamp(h, 0.01, 0.50);\n     }\n     s = max(s,0.0);\n     \n     return s*s*(3.0-2.0*s); // smoothstep\n }\n\n\n\nvec3 lightOrigin = vec3(-.3, .6, -.3);\n\n\n\nvec3 trace(vec3 camOrigin, vec3 dir, out float totalDist) {\n \tconst int maxSteps = 1024;\n    vec3 ray = camOrigin;\n    totalDist = 0.0;\n    \n    // hacky near plane clipping\n    totalDist += .1;\n    ray += totalDist * dir;\n    \n    for(int i = 0; i < maxSteps; i++) {\n     \tfloat dist = scene(ray);\n        if (abs(dist) < .001) {\n            vec3 lightDir = normalize(ray - lightOrigin);\n            // this is not how falloff works!\n            float lightFalloff = 2.0 - pow(length(ray - lightOrigin) * .5, 2.);\n            float diffuse = clamp(dot(lightDir, estimateNormal(ray))* lightFalloff, 0., 1.) ;\n            \n            float s = jsoftshadow(lightOrigin, ray, .02);\n            diffuse *= s;\n            \n            vec3 ambient = vec3(.1, .1, .2);\n            return vec3(1.0, .8, .6)*diffuse + ambient;\n        \t   \n        }\n        totalDist += dist;\n        ray += dist * dir;\n    }\n    \n    return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n    \n{\n    lightOrigin = vec3(sin(iTime), .6, -.3);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n    uv.y /= iResolution.x / iResolution.y;\n    \n    vec3 camOrigin = vec3(0.,.5,-3.);\n    vec3 rayOrigin = vec3(camOrigin.xy + uv, camOrigin.z + 3.0);\n    vec3 dir = normalize(rayOrigin - camOrigin);\n    \n    pR(dir.yz, -.1);\n   \n    \n    float dist;\n    vec3 color = trace(camOrigin, dir, dist);\n\t\n    //float fog = clamp(map(dist, 10., 15., 1., 0.), 0.0, 1.0);\n    //color = mix(vec3(0.0), color, fog);\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}