{"ver":"0.1","info":{"id":"7ljGDc","date":"1624904951","viewed":430,"name":"Mean Value Coordinates","username":"Reynolds","description":"Mean value coordinates  are generalised barycentric coordinates which are valid for any polygon. The functions allow you to interpolate over multisided faces, but they may become negative if non-convex. Shows isolines of the coordinate of one vertex.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["convex","polygon","nonconvex","gbc","generalisedbarycentriccoordinates"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define N 6\n\nfloat cr2(vec2 A, vec2 B) {\n    return A.x*B.y-A.y*B.x;\n}\n\nfloat getAngle(vec2 A, vec2 B) {\n    return atan(cr2(A,B), dot(A,B));\n}\n\nfloat[N] meanvalue(vec2 p, vec2[N] poly) {\n    float[N] weights;\n    vec2 vi, vi_min1, vi_plus1;\n    float sumweights = 0.0;\n    float ang1, ang2;\n    float t1, t2;\n    vec2 vi_p;\n    \n    for(int i = 0; i < N; i++) {\n        vi = poly[i];\n        vi_min1 = poly[(i-1 + N) % N];\n        vi_plus1 = poly[(i+1) % N];\n        vi_p = normalize(vi-p);\n        \n        \n        //ang1 = acos(dot(normalize(vi_min1-p), vi_p));\n        //ang2 = acos(dot(normalize(vi_plus1-p), vi_p));\n        ang1 = getAngle(vi_min1-p, vi_p);\n        ang2 = getAngle(vi_p, vi_plus1-p);\n        \n        \n        t1 = tan(ang1*0.5);\n        t2 = tan(ang2*0.5);\n        weights[i] = (t1 + t2) / distance(vi, p);\n        sumweights += weights[i];\n    }\n    \n    //normalize\n    float recp = 1.0/sumweights;\n    for(int i = 0; i < N; i++) {\n        weights[i] *= recp;\n    }\n    return weights;\n}\n\nfloat sdSegment(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p-a, ba = b-a;\n    float A = dot(pa,ba)/dot(ba,ba);\n    float h = clamp( A, 0.0, 1.0 );\n\n    return length( pa - ba*h);\n}\n\nfloat sdScene(vec2 p,     vec2[N] poly) {\n    float d = sdSegment(p, poly[0], poly[1]);\n    \n    for(int i = 0; i < N; ++i) {\n       d = min(d, sdSegment(p, poly[i], poly[(i+1) % N])); \n    }\n    \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y - vec2(0.25, 0.0);\n\n    vec3 col = vec3(1.0);\n\n    //create a polygon\n    vec2[N] poly;\n    float R = 0.5;\n    float tpi = 2.0*3.14159;\n    \n    float incr = 1.0/float(N);\n    float phi = 0.0;\n    for(int i = 0; i < N; ++i) {\n        poly[i] = vec2(0.5) + R * vec2(cos(tpi * phi), sin(tpi * phi));\n        \n        phi += incr;\n    }\n\n    //perturb right most vertex\n    poly[0] += 0.5*vec2(sin(iTime), 0.0);\n   \n    float[N] weights = meanvalue(uv, poly);\n    float d = sdScene(uv, poly);\n    \n    //change v to [0,..,N-1] to show the other coordinate functions    \n    int v = 0;\n    \n    //render isolines\n    float linewidth = 0.005;\n    float z = 0.001;\n    //simple check to see if we are inside the polygon\n    if(weights[0] > 0.0 && weights[1] > 0.0 && weights[2] > 0.0 && weights[3] > 0.0) {\n        //to change number of isolines    \n        float w = 0.1;\n        for(int i = 0; i < 9; ++i) {\n            float f = weights[v] - (w - linewidth);\n            f /= 2.0 * linewidth;\n            col = mix( vec3(0), col, smoothstep(0., 1.5, abs(f - 0.5)/fwidth(f)));\n            w += 0.1;\n            linewidth += z;\n        }\n    }\n\n    //draw polygon through segments\n    linewidth = 0.005;\n    fragColor.rgb  = mix(vec3(0), col, smoothstep(0.0, 1.0, d / linewidth));\n}","name":"Image","description":"","type":"image"}]}