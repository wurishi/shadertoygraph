{"ver":"0.1","info":{"id":"tldGRj","date":"1576927026","viewed":92,"name":"Postprocessing_Droping Shadow","username":"lypion","description":"PostProcessing, drop a soft shadow of the image, use a Gaussian filter with a certain offset","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["postprocessing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n---Base---\n\tThis one is based on the Gaussian Blur one:https://www.shadertoy.com/view/3ltGz2\n\n---Main Content\n\t1. Postprocessing of image. Using a Gaussian filter with a certain offset to implement\n\t   dropping soft shadow of objects\n*/\n\n\nfloat CalGaussianFilterValue(float sigma, float param)\n{\n    return 0.3989f * exp(-param * param * 0.5f / (sigma * sigma)) / sigma;\n}\n\n//Calculate the luminanca of the color in order to get a gragscale\n//color of the original color\nfloat CalLuminanca(vec3 color)\n{\n    return 0.2125 * color.r + 0.7154 * color.g + 0.0721 * color.b;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //the range we sample the filter\n    const int range = 4;\n    //the total number of sample points\n    const int samplePointCount = 2 * range + 1;\n    const float sigma = 4.0;\n    float gaussianKernel[samplePointCount];\n    for(int i = 0; i <= range; i++)\n    {\n        gaussianKernel[i] = gaussianKernel[samplePointCount - i - 1] = CalGaussianFilterValue(sigma, float(i - range));\n    }\n\n    //store the total value of the kernel array, for keeping the brightness of the image\n    float total = 0.0;\n    for(int i = 0; i < samplePointCount; i++)\n    {\n        total += gaussianKernel[i];\n    }\n\n    //define the offset of the shadow\n    //you can change it to see what happens\n    const int xOffset = 15;\n    const int yOffset = 15;\n\n    vec3 shadowCol = vec3(0.0);\n    //the convolution operation starts at the center of (-xOffset, -yOffset)\n    //based on the current fragCoord point as the origin.\n    //you can compare it with the blur convolution operation which starts\n    //just at the center of the current fragCoord.\n    for(int v = -yOffset - range, i = 0; v <= -yOffset + range; v++, i++)\n    {\n        for(int h = -xOffset - range, j = 0; h <= -xOffset + range; h++, j++)\n        {\n            vec2 uv = (fragCoord + vec2(h, v)) / iResolution.xy;\n            shadowCol += (gaussianKernel[i] * gaussianKernel[j] * texture(iChannel0, uv)).rgb;\n        }\n    }\n\n    //get the grayscale color of it\n    shadowCol /= (total * total);\n    float luminance = CalLuminanca(shadowCol);\n    shadowCol = vec3(luminance);\n\n    //get the original color\n    vec3 originCol = texture(iChannel0, fragCoord / iResolution.xy).xyz;\n\n    fragColor = vec4(shadowCol * originCol, 1.0);\n}","name":"Image","description":"","type":"image"}]}