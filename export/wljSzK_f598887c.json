{"ver":"0.1","info":{"id":"wljSzK","date":"1566671336","viewed":781,"name":"Sinephony","username":"TheRomanOne","description":"playing around with trigo functions and \"scan lines\"","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["sin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_DIST 250.\n#define EPS 0.01\n\n// Uncomment to switch to dark color pallete\n//#define DARK_MODE\n\nvec3 spCenter;\n\nfloat sphere(vec3 p, vec3 center, float radius)\n{\n    return length(center - p) - radius;\n}\n\nmat2x2 rot(float ang)\n{\n    ang *= 3.141592654 / 180.;\n \treturn mat2x2(cos(ang), sin(ang), -sin(ang), cos(ang));   \n}\n\nfloat terrain(vec3 p)\n{\n    float d = 0.;\n    d += 3.*sin(iTime+p.z/10.)*cos(iTime+p.x/10.);\n    d += (sin(iTime+p.z/5642.38453)*cos(iTime+p.x/345.153));\n    d += 2.*sin(p.x*p.z/2500.+iTime);\n    return d;\n}\n\nvec4 map(vec3 p)\n{\n    float h = terrain(p);\n \th *= terrain(p+cos(iTime+p.z*p.x/50.))/2.;\n    float d = p.y + h;\n    vec3 col = vec3(0);\n    float ringSize1 = 20. + iMouse.y/20. + 7.*sin(p.x/7.+iTime);\n    float ringSize2 = 20. + 10.*sin(p.z/25.+1.325*iTime);\n    \n    float ringSize3 = 55. + iMouse.y/20. + 10.*sin(p.x/50.+iTime);\n    float ringSize4 = 20. + 10.*cos(p.x/15.+2.325*iTime);\n    \n    float spRotRad = 20.;\n    spCenter = vec3(spRotRad * cos(iTime), 10., 50. + spRotRad * sin(iTime));\n    \n    float sp = sphere(p, spCenter, 3./* + sin(length(p))*/);\n    \n    if(sp < d)\n    {\n        d = sp;\n        col = vec3(.7, .5, .5);\n    }else\n    {\n        if(length(p) > ringSize1 && length(p) < ringSize1 + ringSize2)\n        {\n            col = normalize(vec3(p.x, p.z, .5));\n\t\t\t\n            col.zy = (rot(iTime*15.) * col.xy);\n            #ifndef DARK_MODE\n            col.zy = abs(col.zy);\n            #endif\n            col.zx = (rot(iTime*30.) * col.yx);\n            #ifndef DARK_MODE\n            col.zx = abs(col.zx);\n            #endif\n            col += .2;\n        }\n        if (length(p) > ringSize3 && length(p) < ringSize3 + ringSize4)\n        {\n            col += normalize(vec3(p.x, .5, p.z));\n\n                col.xy = (rot(iTime*15.) * col.xy);\n                #ifndef DARK_MODE\n                col.zy = abs(col.zx);\n                #endif\n                col.zy = (rot(iTime*30.) * col.yx);\n                #ifndef DARK_MODE\n                col.zx = abs(col.zx);\n                #endif\n            col += .2;\n        }\n    }\n    \n\n    return vec4(col, d);\n}\n\nvec3 deriv(vec3 p)\n{\n    return normalize(vec3(\n        map(p + vec3(EPS, 0, 0)).w - map(p - vec3(EPS, 0, 0)).w,\n        map(p + vec3(0, EPS, 0)).w - map(p - vec3(0, EPS, 0)).w,\n        map(p + vec3(0, 0, EPS)).w - map(p - vec3(0, 0, EPS)).w\n        ));\n}\n\nvec4 march(vec3 ro, vec3 rd)\n{\n    \n    vec4 d=vec4(0.);\n    float dv;\n    for(int i = 0; i < 250; i++)\n    {\n        vec3 newRay = ro + dv * rd;\n        d = map(newRay);\n        if(d.w < EPS || dv > MAX_DIST)\n            break;\n        dv += d.w * .3;\n    }\n    \n    return vec4(d.xyz, dv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - .5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 ro = vec3(0, 30, -1);\n        \n    vec3 lookat = vec3(0, 0, 45);\n\n    vec3 fw = normalize(lookat - ro);\n    vec3 ri = normalize(vec3(fw.z, 0, -fw.x));\n    vec3 up  = cross(fw, ri);\n    \n    vec3 rd = mat3x3(ri, up, fw) * vec3(uv, 1);\n    \n    vec4 d = march(ro, rd);\n    \n    vec3 light = vec3(1);\n    light.xz *= rot(iMouse.x/2. + 200.);\n    vec3 col = vec3(0);\n    if(d.w < MAX_DIST)\n    {\n        vec3 hitPoint = ro + rd * d.w;\n        vec3 n = deriv(hitPoint);\n        vec3 basecolor = d.xyz*vec3(.7, 0.3, .5)*1.2;\n        \n        float ds = march(hitPoint + n *.1, light).w;\n        float l = .3;\n        if(ds>=MAX_DIST)\n            l = max(.3, dot(n, 1.3*normalize(light)));\n        col = basecolor * l;\n    }\n    // Output to screen\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}