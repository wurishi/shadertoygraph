{"ver":"0.1","info":{"id":"ddXcWs","date":"1687306531","viewed":83,"name":"Graphing calculator, SDF... V3","username":"Rogolop","description":"Graphing calculator, 2d SDF plotter (with Mandelbrot set, logistic map attractor, box SDF, implicit curves...)\n\nMove: drag with mouse or WASD or arrow keys\nZoom: Q/E or +/- (Spanish keboard)\nRotate: 1/3\nRestart position/zoom: R or Space or Backspace or 0","likes":4,"published":1,"flags":48,"usePreview":0,"tags":["2d","sdf"],"hasliked":0,"parentid":"dslczs","parentname":"Graphing calculator, SDF... V2"},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Graphing calculator, 2d SDF plotter (with Mandelbrot set, logistic map attractor, box SDF, implicit curves...)\n\n// Move: drag with mouse or WASD or arrow keys\n// Zoom: Q/E or +/- (Spanish keboard)\n// Rotate: 1/3\n// Restart position/zoom: R or Space or Backspace or 0\n\n// Toggle layers\n#define GRID 1\n#define GRAPHING_CALC 0\n#define SDF 1\n#define PRINT_NUMBERS 1\n\n\n\n\n// The MIT License\n// Copyright © 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Distance to an oriented box.\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and iquilezles.org/articles/distfunctions2d\n\n\n\nfloat sdOrientedBox( in vec2 p, in vec2 a, in vec2 b, float th )\n{\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = p-(a+b)*0.5;\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l*0.5,th);\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n}\n\nfloat magnitude(float x) {\n    return pow(10., round(log2(x)/log2(10.)));\n}\n\nfloat orderOfMagnitude(float x) {\n    return log2(x)/log2(10.);\n}\n\nfloat fracabs(float x) {\n    return abs(x - round(x));\n}\n\nfloat cmod(float x, float m) {\n    return mod(x+0.5*m, m)-0.5*m;\n}\n\nvec4 alphaBlend(vec4 back, vec4 front) {\n    //return vec4(mix(back.xyz, front.xyz, front.w), back.w);\n    float alpha = mix(back.w, 1., front.w);\n    return vec4(mix(back.xyz*back.w, front.xyz, front.w)/alpha, alpha);\n}\n\nfloat mandelbrot(float x, float y) {\n    float z1 = 0., z2 = 0.;\n    float oldz1 = z1, oldz2 = z2;\n    int i=0;\n    const int maxiter = 600;\n    \n    for (i; i<maxiter; i++) {\n        z1 = oldz1*oldz1 - oldz2*oldz2 + x;\n        z2 = 2.*oldz1*oldz2 + y;\n        \n        if (z1*z1+z2*z2 > 4.) break; \n        oldz1 = z1;\n        oldz2 = z2;\n    }\n    if (i == maxiter) return -1.;\n    \n    float val = float(i);\n    val += -log2(log2(z1*z1+z2*z2)) + 4.0; // Smooth iteration count https://www.shadertoy.com/view/4df3Rn\n    \n    val = val/float(maxiter);\n    \n    return val;\n}\n\n// https://www.shadertoy.com/view/4dSXWt\nfloat logistic(float x, float y, float scale) {\n\n\tfloat r = 4.0*x;\n    y = 1.0*y;\n\n    float xn = 0.5; // initial condition\n    float f = 0.0; // accumulate output value\n\n    // get rid of the transient state\n    for( int i=0; i<128; i++ ) xn = r*xn*(1.0-xn); // recurrence relation\n    // start plotting\n    for( int i=0; i<512; i++ )\n    {\n        xn = r*xn*(1.0-xn); // recurrence relation\n        \n        // accumulate only values close to y=xn\n        f += 0.1*exp(-200000.0*(y-xn)*(y-xn)*scale*scale);\n    }\n    \n    return f;\n}\n\nfloat tangentCircles(float x, float y, float scale, float n, int iter) {\n    float d = 0.;\n    //d += exp(-1e3*abs(length(vec2(y, x))-1.)*scale);\n    d = max(d, smoothstep(1e-3, 0., abs(length(vec2(y, x))-1.)*scale));\n    float X, Y, a, b, theta, q;\n    X = 0.;\n    Y = 0.;\n    float r, s;\n    r = 1.;\n    for (int i=0; i<iter; i++) {\n        theta = atan(y-Y, x-X);\n        if (theta < 0.) theta += 2.*PI;\n        a = (2.*PI)/float(n)*floor(theta/(2.*PI)*n+0.5);\n        //d = a/(2.*PI);\n        //d += exp(-3e2*abs(length(vec2(y-Y, x-X))-r));\n        float rr = 1. / (1. + 1./(sin(PI/n)));\n        s = r*(rr/sin(PI/n));\n        r = r*rr;\n        X += (s)*cos(a);\n        Y += (s)*sin(a);\n        d = max(d, smoothstep(2e-2, 1e-2, 2e0*length(vec2(y-Y, x-X))/r));\n        d = max(d, smoothstep(1e-3, 0., abs(length(vec2(y-Y, x-X))-r)*scale));\n        /*\n        for (int k=0; k<3; k++) {\n            d += exp(-1e2*abs(x*x+y*y-exp(float(i))));\n        }\n        */\n    }\n    return d;\n}\n\nvec2 RocksSegermanFunction(vec2 z) {\n    float x = z.x, y = z.y;\n    float re, im;\n    re = y*y*(\n            y*y*(\n                x*(3.*x*x+5.) + \n                x*y*y\n            ) +\n            x*(\n                -5. +\n                x*x*(3.*x*x+6.)\n            )\n        ) +\n        x*(\n            - 1. +\n            x*x*(\n                -1. +\n                x*x*(x*x+1.)\n            )\n        );\n    im = y*(\n            y*y*(\n                -1. +\n                y*y*(-1.+3.*x*x+y*y) +\n                (3.*x*x-3.)*x*x\n            ) +\n            1. +\n            (x*x*(x*x-5.)-5.)*x*x\n        );\n    float den = 4.*(x*x + y*y)*(\n                    4.*x*x*y*y +\n                    (x*x - y*y -1.)*(x*x - y*y -1.)\n                );\n    return vec2(re/den, im/den);\n}\n\n\nvec2 complexFunctions(int i, vec2 z) {\n    float x = z.x, y = z.y;\n    //i = 4;\n    switch (i) {\n        case 1: // z\n            return vec2(x, y);\n        case 2: // z^2\n            return vec2(x*x-y*y, 2.*x*y);\n        case 3: // 1/z\n            return vec2(x, -y) / (x*x+y*y);\n        case 4: // e^z\n            return exp(x)*vec2(cos(y),sin(y));\n        case 5: // log(z)\n            return vec2(log2(length(z))/log2(exp(1.)), atan(z.y,z.x));\n        case 6:\n            return vec2(cos(z.x), -1./length(z)*sin(z.x));\n        case 7:\n            return vec2(length(z), atan(z.y,z.x));\n        case 8:\n            return vec2(cos(length(z)), sin(length(z)));\n    }\n    return vec2(0.);\n}\n\n\n\nfloat functions(int i, float x) {\n    //i = 8;\n    switch (i) {\n        case 1:\n            x = clamp(x, 0., 1.);\n            return x*x*(3.-2.*x);\n        case 2:\n            x = clamp(x, 0., 1.);\n            return x*x*(7.+x*(-18.+x*(20.-8.*x)));\n        case 3:\n            x = clamp(x, 0., 1.);\n            return x*x*x*(10.+x*(-15.+6.*x));\n        case 4:\n            x = clamp(x, 0., 1.);\n            return x*x*x*(38.+x*(-155.+x*(+258.+x*(-196.+56.*x))));\n        case 5:\n            x = clamp(x, 0., 1.);\n            return x*x*x*x*(35.+x*(-84.+x*(+70.-20.*x)));\n        case 6:\n            float c = cos(PI*x);\n            return (3.+c*(-2.-c*c))/6.;\n        case 7:\n            return cmod(x, 1.5)-1.;\n        case 8:\n            return mix(0., 1., x);\n    }\n    return 0.;\n}\n\nvec4 drawSmoothFunction(int i, float x, float y, float lineWidth, vec4 lineColor) {\n    float d = abs(functions(i,x)-y);\n    \n    // Approximate constant linewidth\n    // https://www.shadertoy.com/view/mt3SDN\n    float fx = (functions(i,x+EPS)-functions(i,x-EPS))/(2.*EPS); // df/dx\n    fx = min( abs(fx), 40.0 );\n    d /= sqrt( 1.0 + fx*fx );\n    d = ( 1.0-smoothstep(lineWidth*0.8,lineWidth*1.2,abs(d)) );\n    \n    return vec4(lineColor.xyz, lineColor.w*d); //vec4(mix(col.xyz, lineColor.xyz, d*lineColor.w), max(d,col.w));// mix(col, lineColor, d);\n}\n\n\n\nvec3 colorize(float x, float m) {\n    if (x == -1.) return vec3(0.,0.,0.);\n    x = fract(x/m);\n    if (0./6. <= x && x < 1./6.) return mix(vec3(1.,0.,0.), vec3(1.,1.,0.), (x-0./6.)/(1./6.-0./6.));\n    if (1./6. <= x && x < 2./6.) return mix(vec3(1.,1.,0.), vec3(0.,1.,0.), (x-1./6.)/(2./6.-1./6.));\n    if (2./6. <= x && x < 3./6.) return mix(vec3(0.,1.,0.), vec3(0.,1.,1.), (x-2./6.)/(3./6.-2./6.));\n    if (3./6. <= x && x < 4./6.) return mix(vec3(0.,1.,1.), vec3(0.,0.,1.), (x-3./6.)/(4./6.-3./6.));\n    if (4./6. <= x && x < 5./6.) return mix(vec3(0.,0.,1.), vec3(1.,0.,1.), (x-4./6.)/(5./6.-4./6.));\n    if (5./6. <= x && x < 6./6.) return mix(vec3(1.,0.,1.), vec3(1.,0.,0.), (x-5./6.)/(6./6.-5./6.));\n}\n\nvec3 SDFColoring(float d) {\n    vec3 col = vec3(1.) - sign(d)*vec3(0.1,0.4,0.7); // cyan-orange\n    col *= 1.0 - exp(-6.0*abs(d)); // black close to 0\n    col *= 0.8 + 0.2*cos(120.0*d); // lighter-darker bands\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) ); // white line\n    //col = mix( col, vec3(1.0), exp(-120.0*abs(d))); // white line v2\n    //col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.005/scale,abs(d)) ); // white line v3\n    return col;\n}\n\nvec3 colorMix(vec3 c1, vec3 c2, float t) {\n    t = clamp(t, 0., 1.);\n    return sqrt( (1.-t)*c1*c1 + t*c2*c2 );\n}\n\nvec3 colorize2(float x, float m) {\n    if (x == -1.) return vec3(0.,0.,0.);\n    int i = int(floor(mod(x/m*6., 6.)));\n    x = fract(x/m);\n    vec3[] colors = vec3[] (\n            vec3(0.85, 0.00, 0.00),\n            vec3(0.70, 0.60, 0.00),\n            vec3(0.00, 0.75, 0.00),\n            vec3(0.00, 0.60, 0.80),\n            vec3(0.30, 0.30, 1.00),\n            vec3(0.70, 0.00, 0.70),\n            vec3(0.85, 0.00, 0.00)\n        );\n    return colorMix(colors[i], colors[i+1], fract(x*6.));\n}\n\nvec3 complexColoring(vec2 z) {\n    float angle = atan(z.y,z.x);\n    float r = length(z);\n    //r = log(1.+r);\n    ////r = exp(-1./(r*r));\n    //r = smoothstep(0., 1., r);\n    ////r = 1.;\n    //return vec3(colorize2(angle,2.*PI) * r);\n    if (fract(angle/PI/2.*8.+0.01)<0.02) return colorize2(angle,2.*PI)*1.1; // bands of constant argument\n    return mix(vec3(0.),\n        mix(colorize2(angle,2.*PI), vec3(1.), smoothstep(0., 1., log(max(1.,r))/3.)),\n        smoothstep(0., sqrt(0.05), sqrt(r))\n        );\n}\n\n\n//---------\n\n// Printing floats (https://www.shadertoy.com/view/4tl3D2)\n// Created by Eduardo Castineyra - casty/2015\n// Creative Commons Attribution 4.0 International License\n\nvec2 pV[4];\n//   -\n// 0| |1\n//   -\n// 2| |3\n//   -\n\nvec2 pH[3];\n//\t- 2\n//\t- 1\n//\t- 0\n\n//vec2 uv;\nvec2 pixel; // size of a \"pixel\"\nint SIZE; // \"pixels\" per segment\nint WIDTH;\nvec2 SEGMENT; // dimensions of a segment\nfloat DIGIT_SPACING = 0.2; // digit spacing (proportion wrt. SIZE)\nfloat digitSpace; // (as length)\nfloat digitWidth;\nconst ivec2 DIGITS = ivec2(3, 7); // #digits before and after decimal separator\n\nvoid globalInit(){\n    pixel = vec2(1./iResolution.y); //vec2(0.005, 0.001);\n    SIZE = max(3, int(iResolution.y/70.)); // at least 3 pixels\n    WIDTH = int(float(SIZE)/3.);\n    WIDTH = clamp(WIDTH, 1, int(SIZE/2)); // at least 1 pixel, at most half the length\n    SEGMENT = pixel * vec2(SIZE, WIDTH);\n    digitWidth = pixel.x * float(SIZE+WIDTH);\n    digitSpace = pixel.x * max(1., DIGIT_SPACING * float(SIZE+WIDTH)); // at least 1 pixel spacing\n    \n    // starting positon of segments\n    pV[0] = vec2(0, SIZE);  pV[1] = vec2(SIZE - 1, SIZE);\n    pV[2] = vec2(0, 0); \tpV[3] = vec2(SIZE - 1, 0);\n    \n    for (int i = 0; i < 3; i++) {\n    \tpH[i] = vec2(0, SIZE * i);\n    }\n}\n\n// segments encoded in the digits of v.x, v.y (ending in 5 to prevent numerical errors)\nconst vec2[] digitSegments = vec2[] (\n    vec2(.11115, .1015),\n    vec2(.01015, .0005),\n    vec2(.01105, .1115),\n    vec2(.01015, .1115),\n    vec2(.11015, .0105),\n    vec2(.10015, .1115),\n    vec2(.10115, .1115),\n    vec2(.01015, .0015),\n    vec2(.11115, .1115),\n    vec2(.11015, .1115),\n    vec2(.00005, .0105)\n);\n\nvec2 step2(vec2 edge, vec2 v){\n    return vec2(step(edge.x, v.x), step(edge.y, v.y));\n}\n\n// horizontal segment\nfloat segmentH(vec2 pos, vec2 uv){\n    vec2 sv = step2(pos, uv) - step2(pos + SEGMENT.xy, uv); // 0, 1 or 2\n    return step(1.5, sv.x+sv.y); // if == 2\n}\n\n// vertical segment\nfloat segmentV(vec2 pos, vec2 uv){\n    vec2 sv = step2(pos, uv) - step2(pos + SEGMENT.yx, uv); // 0, 1 or 2\n    return step(1.5, sv.x+sv.y); // if == 2\n}\n\n// dot segment\nfloat segmentDot(vec2 pos, vec2 uv){\n    vec2 sv = step2(pos, uv) - step2(pos + SEGMENT.yy, uv); // 0, 1 or 2\n    return step(1.5, sv.x+sv.y); // if == 2\n}\n\n// return units digit and shift f one digit to the left\nfloat nextDigit(inout float f){\n    f = fract(f) * 10.0;\n    return floor(f);\n}\n\nfloat drawDigit(int d, vec2 pos, vec2 uv){\n    //vec4 sv = vec4(1.0, 0.0, 1.0, 0.0);\n    //vec3 sh = vec3(1.0);\n    float c = 0.0;\n    \n    vec2 v = digitSegments[d];\n    \n    for (int i = 0; i < 4; i++)\n        c += segmentV(pos + pixel.x * pV[i], uv) * nextDigit(v.x);\n\n    for (int i = 0; i < 3; i++)\n        c += segmentH(pos + pixel.x * pH[i], uv) * nextDigit(v.y);\n    \n\treturn c;\n}\n\nfloat printNumber(float f, vec2 pos, vec2 uv){\n    float c = 0.0;\n    \n    // Overflow\n    if (f >= pow(10.0, float(DIGITS.x)) || f <= -pow(10.0, float(DIGITS.x-1))) {\n        for (int i = 0; i < DIGITS.x + DIGITS.y; i++) {\n            c += drawDigit(10, pos, uv); // draw digit\n            pos += vec2(digitWidth + digitSpace, 0.0); // move right\n        }\n        return c;\n    }\n    \n    // set first representable digit of f to units digit\n    f /= pow(10.0, float(DIGITS.x));\n    \n    // draw digits before decimal separator\n    for (int i = 0; i < DIGITS.x; i++) {\n        if (i==0 && f < 0.) {\n            // Negative sign\n            c += drawDigit(10, pos, uv); // draw digit\n            pos += vec2(digitWidth + digitSpace, 0.0); // move right\n            f = -f;\n            nextDigit(f);\n        } else {\n            // Digit\n            c += drawDigit(int(nextDigit(f)), pos, uv); // draw digit\n            pos += vec2(digitWidth + digitSpace, 0.0); // move right\n        }\n    }\n    \n    // decimal separator\n    c += segmentDot(pos, uv);\n    pos += vec2(digitWidth + digitSpace, 0.0); // move right\n    // float(WIDTH)*pixel.x + digitSpace\n    \n    // draw digits after decimal separator\n    for (int i = 0; i < DIGITS.y; i++) {\n        c += drawDigit(int(nextDigit(f)), pos, uv); // draw digit\n        pos += vec2(digitWidth + digitSpace, 0.0); // move right\n    }\n   \treturn c;\n}\n\nfloat printFloat(float f, vec2 pos, vec2 uv){\n    float c = 0.0;\n    int ifSign = 1-int(step(0., f));\n    /*\n    // Overflow\n    if (f >= pow(10.0, float(DIGITS.x)) || f <= -pow(10.0, float(DIGITS.x-1))) {\n        for (int i = 0; i < DIGITS.x + DIGITS.y; i++) {\n            c += drawDigit(10, pos, uv); // draw digit\n            pos += vec2(digitSpace, 0.0); // move right\n        }\n        return c;\n    }\n    */\n    \n    // Negative sign\n    if (f < 0.) {\n        c += drawDigit(10, pos, uv); // draw digit\n        pos += vec2(digitWidth + digitSpace, 0.0); // move right\n        f = -f;\n    }\n    \n    int power10 = max(0, 1 + int(floor(log2(f)/log2(10.))));\n    \n    // set first representable digit of f to units digit\n    f /= pow(10.0, float(power10));\n    \n    \n    \n    // draw digits\n    for (int i = 0; i < DIGITS.x+DIGITS.y-ifSign; i++) {\n        // decimal separator\n        if (power10 == 0) {\n            c += segmentDot(pos, uv);\n            pos += vec2(digitWidth + digitSpace, 0.0); // move right\n        }\n        c += drawDigit(int(nextDigit(f)), pos, uv); // draw digit\n        pos += vec2(digitWidth + digitSpace, 0.0); // move right\n        \n        power10--;\n    }\n   \treturn c;\n}\n\n\n\n\n\n//#########################################################\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Position, rotation, scale, mouse\n    vec2 p = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 m = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n    vec2 centerPos = get0(POSITION_ADDR).xy;\n    float scale = get0(POSITION_ADDR).z;\n    float rotationAngle = get0(POSITION_ADDR).w;\n    p /= scale;\n    m /= scale;\n    {\n        float c = cos(rotationAngle);\n        float s = sin(rotationAngle);\n        mat2x2 M = mat2x2(c, -s, s, c);\n        p = M * p;\n        m = M * m;\n    }\n    p += centerPos;\n    float x = p.x;\n    float y = p.y;\n    float h = 1./scale;\n    \n    //-----------------------------------------------------\n    // Background\n    //-----------------------------------------------------\n    \n    fragColor = vec4(vec3(1.0), 1.0); // Output color\n    \n    //-----------------------------------------------------\n    // Grid and x-y axis\n    //-----------------------------------------------------\n    #if GRID\n    {\n        vec4 Col = vec4(1.0); // white layer background\n        float h0 = pow(10., floor(log(h)/log(10.)) ); // greatest power of 10 smaller than h\n        float hp = fract(log(h)/log(10.)); // \"logarithmic position\" of h in [h0,10*h0), values in [0,1)\n        float lineWidth = 0.003/scale;\n\n        // grid\n        if ( 2./3. <= hp && hp < 3./3.) {\n            Col.xyz = mix(Col.xyz, vec3(0.88), smoothstep(lineWidth*1.0,lineWidth*0.5, min(mod(x, h0/1./5.),mod(y, h0/1./5.)) ));\n            Col.xyz = mix(Col.xyz, vec3(0.60), smoothstep(lineWidth*1.0,lineWidth*0.5, min(mod(x, h0/1.),mod(y, h0/1.)) ));\n        }\n        if ( 1./3. <= hp && hp < 2./3.) {\n            Col.xyz = mix(Col.xyz, vec3(0.88), smoothstep(lineWidth*1.0,lineWidth*0.5, min(mod(x, h0/2./5.),mod(y, h0/2./5.)) ));\n            Col.xyz = mix(Col.xyz, vec3(0.60), smoothstep(lineWidth*1.0,lineWidth*0.5, min(mod(x, h0/2.),mod(y, h0/2.)) ));\n        }\n        if ( 0./3. <= hp && hp < 1./3.) {\n            Col.xyz = mix(Col.xyz, vec3(0.88), smoothstep(lineWidth*1.0,lineWidth*0.5, min(mod(x, h0/5./4.),mod(y, h0/5./4.)) ));\n            Col.xyz = mix(Col.xyz, vec3(0.60), smoothstep(lineWidth*1.0,lineWidth*0.5, min(mod(x, h0/5.),mod(y, h0/5.)) ));\n        }\n        // x-y axis\n        Col.xyz = mix(Col.xyz, vec3(0.1), smoothstep(lineWidth*1.0,lineWidth*0.8, min(abs(x),abs(y)) ));\n        Col = clamp(Col, 0., 1.);\n        Col.w *= 1.0; // layer alpha\n        fragColor = alphaBlend(fragColor, Col); // alpha blend layer\n        //fragColor = Col; // draw on top\n    }\n    #endif\n    \n    //-----------------------------------------------------\n    // Graphing calculator\n    //-----------------------------------------------------\n    #if GRAPHING_CALC\n    {\n        vec4 Col = vec4(0.); // transparent layer background\n        Col = alphaBlend(Col, drawSmoothFunction(1, x, y, 0.003/scale, DESMOS_RED));\n        Col = alphaBlend(Col, drawSmoothFunction(2, x, y, 0.003/scale, DESMOS_BLUE));\n        Col = alphaBlend(Col, drawSmoothFunction(3, x, y, 0.003/scale, DESMOS_GREEN));\n        Col = alphaBlend(Col, drawSmoothFunction(4, x, y, 0.003/scale, DESMOS_ORANGE));\n        Col = alphaBlend(Col, drawSmoothFunction(5, x, y, 0.003/scale, DESMOS_PURPLE));\n        Col = alphaBlend(Col, drawSmoothFunction(6, x, y, 0.003/scale, DESMOS_BLACK));\n        Col = alphaBlend(Col, drawSmoothFunction(7, x, y, 0.03/scale, vec4(1., 0., 0., 0.5)));\n        \n        Col = clamp(Col, 0., 1.);\n        Col.w *= 1.; // layer alpha\n        fragColor = alphaBlend(fragColor, Col); // alpha blend layer\n    }\n    #endif\n    \n    \n    //-----------------------------------------------------\n    // 2d SDFs and other 2d functions\n    //-----------------------------------------------------\n    #if SDF\n\t{\n        vec4 Col = vec4(vec3(1.0),1.0);\n        \n        float d = 0.;\n        \n        /*\n        // Box animation\n        {\n            float t = iTime;\n            vec2 v1 = cos( t*0.5 + vec2(0.0,1.00) + 0.0 );\n            vec2 v2 = cos( t*0.5 + vec2(0.0,3.00) + 1.5 );\n            float th = 0.3*(0.5+0.5*cos(t*1.1+1.0));\n            d = sdOrientedBox( p, v1, v2, th );\n        }\n        */\n        \n        //d = x*x*x-y*y;\n        //d = x*x*(x+1.)-y*y;\n        //d = y*y*(x+y-1.)-2.*x*x*x;\n        //d = (x*x+y*y)*(x*x+y*y)-(x*x-y*y);\n        //d = y*y-x*x+x*x*x*x;\n        //d = y*y*(y*y-9.)-x*x*(x*x-10.);\n        //d = (x*x-2.*y+y*y)*(x*x-2.*y+y*y)-x*x-y*y;\n        //d = functions(1, x)-y;\n\n        // Logistic map attractor\n        //d = logistic(x, y, scale); Col = vec4(vec3(1.-d),d);\n        \n        // Mandelbrot set\n        //d = mandelbrot(x, y); Col.xyz = colorize(d, 1./5.); //colorize(d, 1.);\n        \n        // Tangent circles\n        float n = 2.+2.*(0.5-0.5*cos(iTime/5.));\n        int iter = 6;\n        d = tangentCircles(x,y, scale, n, iter);\n        \n        // Complex functions\n        //vec2 z = vec2(x,y);\n        //z = complexFunctions(4, z);\n        //z = RocksSegermanFunction(z); // Rocks, Segerman - Youtube video\n        \n        d = 1.-d; // invert black <-> white\n        Col.xyz = vec3(d); // Black and white coloring\n        //Col.xyz = SDFColoring(d); // SDF coloring\n        //Col.xyz = colorize(d, 1.);\n        //Col.xyz = complexColoring(z); // Complex number coloring\n\n        \n        Col = clamp(Col, 0., 1.);\n        Col.w *= 0.85; // layer alpha\n        fragColor = alphaBlend(fragColor, Col); // alpha blend layer\n        //fragColor = vec4(col, 1.0); // draw on top\n    }\n    #endif\n    \n    //-----------------------------------------------------\n    // Old grid\n    //-----------------------------------------------------\n    /*\n    if (fracabs(x*magnitude(1.8*scale))<0.01 ||\n        fracabs(y*magnitude(1.8*scale))<0.01 ||\n        fracabs(x*magnitude(4.*scale))<0.01 ||\n        fracabs(y*magnitude(4.*scale))<0.01) {\n        //col = 0.9*col + 0.1*(1.-col);\n        //col = 0.7*col + 0.3*(1.+col)*vec3(1.,0.,0.);\n        //col = 0.8*col + 0.2*(1.-col)*vec3(1.,0.,0.);\n        col.xyz = vec3( sign(0.5-(col.x+col.y+col.z)/3.)*0.1+(col.x+col.y+col.z)/3. );\n    }\n    */\n    \n    \n    \n    //-----------------------------------------------------\n    // Print numbers (scale, center x, center y)\n    //-----------------------------------------------------\n    #if PRINT_NUMBERS\n    globalInit();\n    vec2 uv = fragCoord.xy / iResolution.y;\n    if (uv.x < 0.25 && uv.y < 0.15) fragColor *= 0.5; // Dark box\n    //vec2 mouse = iMouse.xy / iResolution.xy;\n    //fillNumbers();\n    \n    fragColor += vec4(//printNumber(mouse.x * 100.0, mouse) + \n                     //printNumber(mouse.y * 100.0, mouse - pixel * vec2(0.0, SIZE * 5)) + \n                     //printNumber(0.0123405, vec2(0.01,0.01+0.05*5.), uv) +\n                     //printFloat(1.+floor(log2(scale)/log2(10.)), vec2(0.01,0.01+0.05*5.), uv) +\n                     printFloat(centerPos.x, vec2(0.01,0.01+0.05*1.), uv) +\n                     printFloat(centerPos.y, vec2(0.01,0.01), uv) +\n                     printFloat(scale, vec2(0.01,0.01+0.1*1.), uv)\n                    );\n    #endif\n    \n    fragColor.a = 1.;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Save and manipulate \"static variables\" stored in Buffer A\n\n// POSITION_ADDR\n//     xy: position\n//     z: scale\n//     w: rotationAngle\n// LAST_MOUSE_ADDR\n//     xy: last mouse position\n//     z: 0\n//     w: whether last mouse position is updated\n\nconst vec4 startPos0 = vec4(0., 0., 0.4, 0.);\nconst vec4 startPosMandelbrot1 = vec4(-0.777120613150274923773, 0.126857111509958518545, 0.4, 0.);\nconst vec4 startPosMandelbrot2 = vec4(-1.7864403, 0., 0.4, 0.);\nconst vec4 startPosLogistic1 = vec4(0.8924840, 0.8924847, 0.8, 0.);\nconst vec4 startPosLogistic2 = vec4(0.5, 0.5, 0.8, 0.);\nconst vec4 startPosGraphingCalc0 = vec4(0., 0., 0.4, 0.);\nconst vec4 startPosGraphingCalc1 = vec4(0.5, 0.5, 0.8, 0.);\nconst vec4 startPosGraphingCalc2 = vec4(0., 0., 0.15, 0.);\nconst vec4 startPosGraphingCalc3 = vec4(0., 0., 0.15, 0.);\n\n// Choose start position\nconst vec4 startPos = startPosGraphingCalc0;\n\nvec2 visitPoint(vec2 startPoint, vec2 destinationPoint, float tStart, float tArrive, float t) {\n    float s = smoothstep(tStart, tArrive, t);\n    return (destinationPoint-startPoint)*s;\n}\n\n#define CAMERA_ANIMATION 0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Initialize\n    if (iFrame == 0) {\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n        if (inAddr(POSITION_ADDR)) {\n            fragColor = startPos;\n        }\n        return;\n    }\n    \n    // Mouse\n    vec2 m = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n    //m = vec2(0., 0.);\n    //m *= 1.4;\n    float scale = get0(POSITION_ADDR).z;\n    float rotationAngle = get0(POSITION_ADDR).w;\n    m /= scale;\n    {\n        float c = cos(rotationAngle);\n        float s = sin(rotationAngle);\n        mat2x2 M = mat2x2(c, -s, s, c);\n        m = M * m;\n    }\n    \n    if (inAddr(POSITION_ADDR)) {\n    \n        // Update position\n        fragColor = get0(POSITION_ADDR); // last position\n        if ( mouseClicked && get0(LAST_MOUSE_ADDR).w == 1.) {\n            fragColor -= (vec4(m.x, m.y, 0., 0.) - vec4(get0(LAST_MOUSE_ADDR).xy, 0., 0.));\n        }\n        if ( checkKey(KEY_W) || checkKey(KEY_UP)    ) fragColor.y += 0.01/scale;\n        if ( checkKey(KEY_A) || checkKey(KEY_LEFT)  ) fragColor.x -= 0.01/scale;\n        if ( checkKey(KEY_S) || checkKey(KEY_DOWN)  ) fragColor.y -= 0.01/scale;\n        if ( checkKey(KEY_D) || checkKey(KEY_RIGHT) ) fragColor.x += 0.01/scale;\n        \n        // Update rotation\n        if ( checkKey(KEY_1) ) fragColor.w += 0.01;\n        if ( checkKey(KEY_3) ) fragColor.w -= 0.01;\n        \n        // Update zoom\n        if ( checkKey(KEY_Q) || checkKey(KEY_MINUS) ) fragColor.z *= 0.97;\n        if ( checkKey(KEY_E) || checkKey(KEY_PLUS)     ) fragColor.z *= 1.03;\n        if ( checkKey(KEY_R) || checkKey(KEY_BACKSPACE) || checkKey(KEY_SPACE) || checkKey(KEY_0) ) {\n            fragColor = startPos;\n        }\n        \n        // Camera animation\n        #if CAMERA_ANIMATION\n        {\n            float T = 60.;\n            float tAnim = mod(iTime, T);\n            float tProgress = tAnim / T;\n            float transitionT = 3.;\n            float tt = 2.*3.14159*(iTime/T*2.+0.25);\n            fragColor.z = startPos.z*pow(600., 1.-2./3.*sin(tt)*(1.+0.5*sin(tt)*sin(tt)) );\n            fragColor.xy = startPosMandelbrot1.xy + \n                visitPoint(startPosMandelbrot1.xy, startPosMandelbrot2.xy,\n                    T/2.-transitionT, T/2., tAnim) +\n                visitPoint(startPosMandelbrot2.xy, startPosMandelbrot1.xy,\n                    T-transitionT, T, tAnim);\n        }\n        #endif\n        \n    } else if (inAddr(LAST_MOUSE_ADDR)) {\n        // Update last mouse position\n        fragColor = vec4(m.x, m.y, 0., 1.);\n        \n        // Indicate mouse may have moved when not pressed\n        if ( !(mouseClicked) ) {\n            fragColor.w = 0.;\n        }\n        \n        \n    } else {\n        fragColor = vec4(0.0,0.0,0.0,0.0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const ivec2 POSITION_ADDR = ivec2(0, 0);\nconst ivec2 LAST_MOUSE_ADDR = ivec2(1, 0);\n\n\n// https://www.shadertoy.com/view/WsdfRS\n// --- most  utils from https://www.shadertoy.com/view/llySRh\n                                                        \n#define mouseUp      ( iMouse.z < 0. )                  // mouse up even:   mouse button released (well, not just that frame). cf https://www.shadertoy.com/view/3dcBRS\n#define mouseDown    ( iMouse.z > 0. && iMouse.w > 0. ) // mouse down even: mouse button just clicked\n#define mouseClicked ( iMouse.z > 0. )                  // mouse clicked:   mouse button currently clicked\n\n//#define hue(v)       ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) ) \n//#define keyClick(a)  ( texelFetch(iChannel3,ivec2(a,0),0).x > 0.)\n//#define hash(p)        fract( sin( (p) * vec2(12.9898, 78.233) ) * 43758.5453 )\n\n//#define in(x,a,b)    ( x > min(a,b) && x < max(a,b) )\n\n\n\n// buf_pos - fragment position (fragCoord)\n// addr - the data address in the form of an ivec2\n// storeData() just evaluates if the data address matches the fragment position\n// in which case the data should be stored in fragColor.\n#define inAddr(addr) ( ivec2(fragCoord) == addr )\n\n#define get0(addr) ( texelFetch(iChannel0, addr, 0) )\n#define get1(addr) ( texelFetch(iChannel1, addr, 0) )\n\n\n// https://www.shadertoy.com/view/XdG3Dh\n// Modified for Spanish keyboard\n\n// Keyboard constants definition\nconst float KEY_BACKSPACE = 8.5/256.0;\nconst float KEY_SPACE = 32.5/256.0;\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\nconst float KEY_A     = 65.5/256.0;\nconst float KEY_B     = 66.5/256.0;\nconst float KEY_C     = 67.5/256.0;\nconst float KEY_D     = 68.5/256.0;\nconst float KEY_E     = 69.5/256.0;\nconst float KEY_F     = 70.5/256.0;\nconst float KEY_G     = 71.5/256.0;\nconst float KEY_H     = 72.5/256.0;\nconst float KEY_I     = 73.5/256.0;\nconst float KEY_J     = 74.5/256.0;\nconst float KEY_K     = 75.5/256.0;\nconst float KEY_L     = 76.5/256.0;\nconst float KEY_M     = 77.5/256.0;\nconst float KEY_N     = 78.5/256.0;\nconst float KEY_O     = 79.5/256.0;\nconst float KEY_P     = 80.5/256.0;\nconst float KEY_Q     = 81.5/256.0;\nconst float KEY_R     = 82.5/256.0;\nconst float KEY_S     = 83.5/256.0;\nconst float KEY_T     = 84.5/256.0;\nconst float KEY_U     = 85.5/256.0;\nconst float KEY_V     = 86.5/256.0;\nconst float KEY_W     = 87.5/256.0;\nconst float KEY_X     = 88.5/256.0;\nconst float KEY_Y     = 89.5/256.0;\nconst float KEY_Z     = 90.5/256.0;\nconst float KEY_COMMA = 188.5/256.0; // ,\nconst float KEY_PERIOD = 190.5/256.0; // .\n//const float KEY_ADD   = 107.5/256.0; // NO FUNCIONA\n//const float KEY_SUBS  = 109.5/256.0; // NO FUNCIONA\n//const float KEY_EQUAL = 187.5/256.0; // NO FUNCIONA\n//const float KEY_MINUS = 189.5/256.0; // NO FUNCIONA\n\n\nconst float KEY_TAB = 9.5/256.0; // TAB\nconst float KEY_CTRL = 17.5/256.0; // CTRL, ALTGR\nconst float KEY_ALT = 18.5/256.0; // ALT, ALTGR\nconst float KEY_0 = 48.5/256.0;\nconst float KEY_1 = 49.5/256.0;\nconst float KEY_2 = 50.5/256.0;\nconst float KEY_3 = 51.5/256.0;\nconst float KEY_4 = 52.5/256.0;\nconst float KEY_5 = 53.5/256.0;\nconst float KEY_6 = 54.5/256.0;\nconst float KEY_7 = 55.5/256.0;\nconst float KEY_8 = 56.5/256.0;\nconst float KEY_9 = 57.5/256.0;\nconst float KEY_SHIFT = 16.5/256.0;\nconst float KEY_LT = 16.5/256.0; // <\nconst float KEY_oth = 220.5/256.0; // º\nconst float KEY_MINUS = 173.5/256.0; // -\nconst float KEY_RIGHTACCENT = 222.5/256.0; // ´ and  '\nconst float KEY_LEFTACCENT = 192.5/256.0; // ` and ñ\nconst float KEY_CTRENCADA = 191.5/256.0; // ç\nconst float KEY_PLUS = 171.5/256.0; // +\nconst float KEY_INVERTEDEXCLAMATION = 221.5/256.0; // ¡\n\n#define checkKey(key) ( texture(iChannel1, vec2(key, 0.25)).x > 0.5 )\n\n\n\n// More constants\n\nconst float PI = acos(-1.);\nconst float EPS = 1e-4;\n\nconst vec4 DESMOS_RED    = vec4(0.78, 0.27, 0.25, 1.00);\nconst vec4 DESMOS_BLUE   = vec4(0.18, 0.44, 0.70, 1.00);\nconst vec4 DESMOS_GREEN  = vec4(0.22, 0.55, 0.27, 1.00);\nconst vec4 DESMOS_ORANGE = vec4(0.98, 0.49, 0.10, 1.00);\nconst vec4 DESMOS_PURPLE = vec4(0.38, 0.26, 0.65, 1.00);\nconst vec4 DESMOS_BLACK  = vec4(0.10, 0.10, 0.10, 1.00);\n\n\n\n\n","name":"Common","description":"","type":"common"}]}