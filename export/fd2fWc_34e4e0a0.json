{"ver":"0.1","info":{"id":"fd2fWc","date":"1647465116","viewed":1394,"name":"Production Sky Rendering v2","username":"jonnyhyman","description":"Modified version of AndrewHelmer's https://www.shadertoy.com/view/slSXRW \n- adds space view by switching to direct ray marching outside atmosphere since sky view LUT fails at high altitudes\n- removes sun flare, open to suggestions to make it work again","likes":15,"published":1,"flags":32,"usePreview":0,"tags":["sun","sky","atmosphere","physical"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * Modified version of Andrew Helmer's https://www.shadertoy.com/view/slSXRW \n * implementation of Sebastian Hillare's Unreal engine sky-atmosphere\n * ... still doesn't implement aerial perspective lut, just makes space views possible\n* TODO: replace sunflare with something new that works\n        allow density profiles, and thicker atmospheres (fails beyond 7.1 right now)\n */\n\n/*\n * Final output basically looks up the value from the skyLUT, and then adds a sun on top,\n * does some tonemapping.\n */\nvec3 getValFromSkyLUT(vec3 rayDir, vec3 sunDir) {\n\n    vec3 viewPos = getViewPos(iTime);\n    float height = length(viewPos);\n    vec3 up = viewPos / height;\n\n    float horizonAngle = safeacos(sqrt(height * height - groundRadiusMM * groundRadiusMM) / height);\n    float altitudeAngle = horizonAngle - acos(dot(rayDir, up)); // Between -PI/2 and PI/2\n    float azimuthAngle; // Between 0 and 2*PI\n\n    vec3 right = cross(sunDir, up);\n    vec3 forward = cross(up, right);\n\n    vec3 projectedDir = normalize(rayDir - up*(dot(rayDir, up)));\n    float sinTheta = dot(projectedDir, right);\n    float cosTheta = dot(projectedDir, forward);\n    azimuthAngle = atan(sinTheta, cosTheta) + PI;\n\n    // Non-linear mapping of altitude angle. See Section 5.3 of the paper.\n    float v = 0.5 + 0.5*sign(altitudeAngle)*sqrt(abs(altitudeAngle)*2.0/PI);\n    vec2 uv = vec2(azimuthAngle / (2.0*PI), v);\n    uv *= skyLUTRes;\n    uv /= iChannelResolution[1].xy;\n\n    return texture(iChannel1, uv).rgb;\n}\n\nvec3 jodieReinhardTonemap(vec3 c){\n    // From: https://www.shadertoy.com/view/tdSXzD\n    float l = dot(c, vec3(0.2126, 0.7152, 0.0722));\n    vec3 tc = c / (c + 1.0);\n    return mix(c / (l + 1.0), tc, tc);\n}\n\nvec3 sunWithBloom(vec3 rayDir, vec3 sunDir) {\n    const float sunSolidAngle = 0.53*PI/180.0;\n    const float minSunCosTheta = cos(sunSolidAngle);\n\n    float cosTheta = dot(rayDir, sunDir);\n    if (cosTheta >= minSunCosTheta) return vec3(1.0);\n\n    float offset = minSunCosTheta - cosTheta;\n    float gaussianBloom = exp(-offset*50000.0)*0.5;\n    float invBloom = 1.0/(0.02 + offset*300.0)*0.01;\n    return vec3(gaussianBloom+invBloom);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 sunDir = getSunDir(iTime);\n    vec3 viewPos = getViewPos(iTime);\n\n    vec3 camDir = normalize(vec3(0.0, -(sin(iTime/10.0 - PI/2.)+1.0), -(.8*cos(iTime/10.0-PI/2.)+1.0)));\n\n    float camFOVWidth = PI/3.0;\n\n    float camWidthScale = 2.0*tan(camFOVWidth/2.0);\n    float camHeightScale = camWidthScale*iResolution.y/iResolution.x;\n\n    vec3 camRight = normalize(cross(camDir, vec3(0.0, 1.0, 0.0)));\n    vec3 camUp = normalize(cross(camRight, camDir));\n\n    vec2 xy = 2.0 * (fragCoord.xy / iResolution.xy) - 1.0;\n    vec3 rayDir = normalize(camDir + camRight*xy.x*camWidthScale + camUp*xy.y*camHeightScale);\n\n    vec3 lum;\n\n    if (length(viewPos) < atmosphereRadiusMM * 1.0){\n        lum = getValFromSkyLUT(rayDir, sunDir);\n    } else {\n    \n        // As mentioned in section 7 of the paper, switch to direct raymarching outside atmosphere\n        lum = raymarchScattering(iChannel0, iChannelResolution[0].xy,\n                                 iChannel2, iChannelResolution[2].xy,\n                                 viewPos, rayDir, sunDir, float(numScatteringSteps));\n        \n        // This little bit of red helps to debug when the rendering switches to pure raymarching\n        //lum += vec3(1e-3,0.0,0.0);\n    }\n\n    // Tonemapping and gamma. Super ad-hoc, probably a better way to do this.\n    lum *= 10.0;\n    lum = jodieReinhardTonemap(lum);\n    lum = pow(lum, vec3(1.0/2.2));\n\n    fragColor = vec4(lum,1.0);\n\n    // Peek at the Transmittance LUT\n    //fragColor = vec4(100.*texture(iChannel0, fragCoord.xy/iResolution.xy).rgb,1.0);\n\n    // Peek at the Sky View LUT\n    //fragColor = vec4(80.*texture(iChannel1, fragCoord.xy/iResolution.xy).rgb,1.0);\n\n    // Peek at the Multiscattering LUT\n    //fragColor = vec4(100.*texture(iChannel2, fragCoord.xy/iResolution.xy).rgb,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = 3.14159265358;\n\n// Units are in megameters.\nconst float groundRadiusMM = 6371.;\nconst float atmosphereRadiusMM = 6471.;\n\nconst vec2 tLUTRes = vec2(256.0, 64.0)*1.;\nconst vec2 msLUTRes = vec2(32.0, 32.0)*1.;\nconst vec2 skyLUTRes = vec2(400.0, 200.0)*2.;\n\nconst vec3 groundAlbedo = vec3(0.1);\n\n// These are per megameter.\nconst vec3 rayleighScatteringBase = vec3(5.802, 13.558, 33.1)*1e-3;\nconst float rayleighAbsorptionBase = 0.0;\n\nconst float mieScatteringBase = 3.996*1e-3;\nconst float mieAbsorptionBase = 4.4*1e-3;\n\nconst vec3 ozoneAbsorptionBase = vec3(0.650, 1.881, .085)*1e-3;\n\n// Quality\nconst float sunTransmittanceSteps = 40.0;\nconst float mulScattSteps = 20.0;\nconst int sqrtSamples = 8;\n\nconst int numScatteringSteps = 16;\n\n/*\n * Animates the sun movement.\n */\nfloat getSunAltitude(float time)\n{\n    const float periodSec = 60.0;\n    return (PI)*time/periodSec - PI/24.;\n}\nvec3 getSunDir(float time)\n{\n    float altitude = getSunAltitude(time);\n    return normalize(vec3(0.0, sin(altitude), -cos(altitude)));\n}\n\n/* Animate camera */\nvec3 getViewPos(float time){\n\n    vec3 viewPos = vec3(0.0, groundRadiusMM + 0.0002*1000., 0.0);\n\n    // anything beyond about 7 falls apart because the skyview lut doesn't have enough resolution\n    float alt_range = 50.0;\n    \n    viewPos.y += (sin(time/10.0 - PI/2.)*.5+.5) * (atmosphereRadiusMM - groundRadiusMM) * alt_range;\n\n    return viewPos;\n}\n\n\nfloat getMiePhase(float cosTheta) {\n    const float g = 0.8;\n    const float scale = 3.0/(8.0*PI);\n\n    float num = (1.0-g*g)*(1.0+cosTheta*cosTheta);\n    float denom = (2.0+g*g)*pow((1.0 + g*g - 2.0*g*cosTheta), 1.5);\n\n    return scale*num/denom;\n}\n\nfloat getRayleighPhase(float cosTheta) {\n    const float k = 3.0/(16.0*PI);\n    return k*(1.0+cosTheta*cosTheta);\n}\n\nvoid getScatteringValues(vec3 pos,\n                         out vec3 rayleighScattering,\n                         out float mieScattering,\n                         out vec3 extinction) {\n    float altitudeKM = (length(pos)-groundRadiusMM);//*1000.0;\n    // Note: Paper gets these switched up.\n    float rayleighDensity = exp(-altitudeKM/8.0);\n    float mieDensity = exp(-altitudeKM/1.2);\n\n    rayleighScattering = rayleighScatteringBase*rayleighDensity;\n    float rayleighAbsorption = rayleighAbsorptionBase*rayleighDensity;\n\n    mieScattering = mieScatteringBase*mieDensity;\n    float mieAbsorption = mieAbsorptionBase*mieDensity;\n\n    vec3 ozoneAbsorption = ozoneAbsorptionBase*max(0.0, 1.0 - abs(altitudeKM-25.0)/15.0);\n\n    extinction = rayleighScattering + rayleighAbsorption + mieScattering + mieAbsorption + ozoneAbsorption;\n}\n\nfloat safeacos(const float x) {\n    return acos(clamp(x, -1.0, 1.0));\n}\n\n// From https://gamedev.stackexchange.com/questions/96459/fast-ray-sphere-collision-code.\nfloat rayIntersectSphere(vec3 ro, vec3 rd, float rad) {\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - rad*rad;\n    if (c > 0.0f && b > 0.0) return -1.0;\n    float discr = b*b - c;\n    if (discr < 0.0) return -1.0;\n    // Special case: inside sphere, use far discriminant\n    if (discr > b*b) return (-b + sqrt(discr));\n    return -b - sqrt(discr);\n}\n\n// From https://www.shadertoy.com/view/wlBXWK\nvec2 rayIntersectSphere2D(\n    vec3 start, // starting position of the ray\n    vec3 dir, // the direction of the ray\n    float radius // and the sphere radius\n) {\n    // ray-sphere intersection that assumes\n    // the sphere is centered at the origin.\n    // No intersection when result.x > result.y\n    float a = dot(dir, dir);\n    float b = 2.0 * dot(dir, start);\n    float c = dot(start, start) - (radius * radius);\n    float d = (b*b) - 4.0*a*c;\n    if (d < 0.0) return vec2(1e5,-1e5);\n    return vec2(\n        (-b - sqrt(d))/(2.0*a),\n        (-b + sqrt(d))/(2.0*a)\n    );\n}\n\n\n/*\n * Same parameterization here.\n */\nvec3 getValFromTLUT(sampler2D tex, vec2 bufferRes, vec3 pos, vec3 sunDir) {\n    float height = length(pos);\n    vec3 up = pos / height;\n\tfloat sunCosZenithAngle = dot(sunDir, up);\n    vec2 uv = vec2(tLUTRes.x*clamp(0.5 + 0.5*sunCosZenithAngle, 0.0, 1.0),\n                   tLUTRes.y*clamp((height - groundRadiusMM)/(atmosphereRadiusMM - groundRadiusMM),0.,1.));\n    uv /= bufferRes;\n    return texture(tex, uv).rgb;\n}\nvec3 getValFromMultiScattLUT(sampler2D tex, vec2 bufferRes, vec3 pos, vec3 sunDir) {\n    float height = length(pos);\n    vec3 up = pos / height;\n\tfloat sunCosZenithAngle = dot(sunDir, up);\n    vec2 uv = vec2(msLUTRes.x*clamp(0.5 + 0.5*sunCosZenithAngle, 0.0, 1.0),\n                   msLUTRes.y*max(0.0, min(1.0, (height - groundRadiusMM)/(atmosphereRadiusMM - groundRadiusMM))));\n    uv /= bufferRes;\n    return texture(tex, uv).rgb;\n}\n\n/* \n * Do raymarching : builds skyview lut inside atmoshpere, raymarches directly outside atmosphere\n*/\n\n\nvec3 raymarchScattering(sampler2D TLUT, vec2 TLUT_size, sampler2D MSLUT, vec2 MSLUT_size,\n                              vec3 viewPos,\n                              vec3 rayDir,\n                              vec3 sunDir,\n                              float numSteps) {\n                              \n                              \n    vec2 atmos_intercept = rayIntersectSphere2D(viewPos, rayDir, atmosphereRadiusMM);\n    float terra_intercept = rayIntersectSphere(viewPos, rayDir, groundRadiusMM);\n\n    float mindist, maxdist;\n\n    if (atmos_intercept.x < atmos_intercept.y){\n        // there is an atmosphere intercept!\n        // start at the closest atmosphere intercept\n        // trace the distance between the closest and farthest intercept\n        mindist = atmos_intercept.x > 0.0 ? atmos_intercept.x : 0.0;\n\t\tmaxdist = atmos_intercept.y > 0.0 ? atmos_intercept.y : 0.0;\n    } else {\n        // no atmosphere intercept means no atmosphere!\n        return vec3(0.0);\n    }\n\n    // if in the atmosphere start at the camera\n    if (length(viewPos) < atmosphereRadiusMM) mindist=0.0;\n\n\n    // if there's a terra intercept that's closer than the atmosphere one,\n    // use that instead!\n    if (terra_intercept > 0.0){ // confirm valid intercepts\t\t\t\n        maxdist = terra_intercept;\n    }\n\n    // start marching at the min dist\n    vec3 pos = viewPos + mindist * rayDir;\n                              \n    float cosTheta = dot(rayDir, sunDir);\n\n\tfloat miePhaseValue = getMiePhase(cosTheta);\n\tfloat rayleighPhaseValue = getRayleighPhase(-cosTheta);\n\n    vec3 lum = vec3(0.0);\n    vec3 transmittance = vec3(1.0);\n    float t = 0.0;\n    for (float i = 0.0; i < numSteps; i += 1.0) {\n        float newT = ((i + 0.3)/numSteps)*(maxdist-mindist);\n        float dt = newT - t;\n        t = newT;\n\n        vec3 newPos = pos + t*rayDir;\n\n        vec3 rayleighScattering, extinction;\n        float mieScattering;\n        \n        getScatteringValues(newPos, rayleighScattering, mieScattering, extinction);\n\n        vec3 sampleTransmittance = exp(-dt*extinction);\n\n        vec3 sunTransmittance = getValFromTLUT(TLUT, TLUT_size, newPos, sunDir);\n        vec3 psiMS = 0.0*getValFromMultiScattLUT(MSLUT, MSLUT_size, newPos, sunDir);\n\n        vec3 rayleighInScattering = rayleighScattering*(rayleighPhaseValue*sunTransmittance + psiMS);\n        vec3 mieInScattering = mieScattering*(miePhaseValue*sunTransmittance + psiMS);\n        vec3 inScattering = (rayleighInScattering + mieInScattering);\n\n        // Integrated scattering within path segment.\n        vec3 scatteringIntegral = (inScattering - inScattering * sampleTransmittance) / extinction;\n\n        lum += scatteringIntegral*transmittance;\n\n        transmittance *= sampleTransmittance;\n    }\n    return lum;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Buffer A generates the Transmittance LUT. Each pixel coordinate corresponds to a height and sun zenith angle, and\n// the value is the transmittance from that point to sun, through the atmosphere.\n\nvec3 getSunTransmittance(vec3 pos, vec3 sunDir) {\n    if (rayIntersectSphere(pos, sunDir, groundRadiusMM) > 0.0) {\n        return vec3(0.0);\n    }\n\n    float atmoDist = rayIntersectSphere(pos, sunDir, atmosphereRadiusMM);\n    float t = 0.0;\n\n    vec3 transmittance = vec3(1.0);\n    for (float i = 0.0; i < sunTransmittanceSteps; i += 1.0) {\n        float newT = ((i + 0.3)/sunTransmittanceSteps)*atmoDist;\n        float dt = newT - t;\n        t = newT;\n\n        vec3 newPos = pos + t*sunDir;\n\n        vec3 rayleighScattering, extinction;\n        float mieScattering;\n        getScatteringValues(newPos, rayleighScattering, mieScattering, extinction);\n\n        transmittance *= exp(-dt*extinction);\n    }\n    return transmittance;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.x >= (tLUTRes.x+1.5) || fragCoord.y >= (tLUTRes.y+1.5)) {\n        return;\n    }\n    float u = clamp(fragCoord.x, 0.0, tLUTRes.x-1.0)/tLUTRes.x;\n    float v = clamp(fragCoord.y, 0.0, tLUTRes.y-1.0)/tLUTRes.y;\n\n    float sunCosTheta = 2.0*u - 1.0;\n    float sunTheta = safeacos(sunCosTheta);\n    float height = mix(groundRadiusMM, atmosphereRadiusMM, v);\n\n    vec3 pos = vec3(0.0, height, 0.0);\n    vec3 sunDir = normalize(vec3(0.0, sunCosTheta, -sin(sunTheta)));\n\n    fragColor = vec4(getSunTransmittance(pos, sunDir), 1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Buffer B is the multiple-scattering LUT. Each pixel coordinate corresponds to a height and sun zenith angle, and\n// the value is the multiple scattering approximation (Psi_ms from the paper, Eq. 10).\n\nvec3 getSphericalDir(float theta, float phi) {\n     float cosPhi = cos(phi);\n     float sinPhi = sin(phi);\n     float cosTheta = cos(theta);\n     float sinTheta = sin(theta);\n     return vec3(sinPhi*sinTheta, cosPhi, sinPhi*cosTheta);\n}\n\n// Calculates Equation (5) and (7) from the paper.\nvoid getMulScattValues(vec3 pos, vec3 sunDir, out vec3 lumTotal, out vec3 fms) {\n    lumTotal = vec3(0.0);\n    fms = vec3(0.0);\n\n    float invSamples = 1.0/float(sqrtSamples*sqrtSamples);\n    for (int i = 0; i < sqrtSamples; i++) {\n        for (int j = 0; j < sqrtSamples; j++) {\n            // This integral is symmetric about theta = 0 (or theta = PI), so we\n            // only need to integrate from zero to PI, not zero to 2*PI.\n            float theta = PI * (float(i) + 0.5) / float(sqrtSamples);\n            float phi = safeacos(1.0 - 2.0*(float(j) + 0.5) / float(sqrtSamples));\n            vec3 rayDir = getSphericalDir(theta, phi);\n\n            float atmoDist = rayIntersectSphere(pos, rayDir, atmosphereRadiusMM);\n            float groundDist = rayIntersectSphere(pos, rayDir, groundRadiusMM);\n            float tMax = atmoDist;\n            if (groundDist > 0.0) {\n                tMax = groundDist;\n            }\n\n            float cosTheta = dot(rayDir, sunDir);\n\n            float miePhaseValue = getMiePhase(cosTheta);\n            float rayleighPhaseValue = getRayleighPhase(-cosTheta);\n\n            vec3 lum = vec3(0.0), lumFactor = vec3(0.0), transmittance = vec3(1.0);\n            float t = 0.0;\n            for (float stepI = 0.0; stepI < mulScattSteps; stepI += 1.0) {\n                float newT = ((stepI + 0.3)/mulScattSteps)*tMax;\n                float dt = newT - t;\n                t = newT;\n\n                vec3 newPos = pos + t*rayDir;\n\n                vec3 rayleighScattering, extinction;\n                float mieScattering;\n                getScatteringValues(newPos, rayleighScattering, mieScattering, extinction);\n\n                vec3 sampleTransmittance = exp(-dt*extinction);\n\n                // Integrate within each segment.\n                vec3 scatteringNoPhase = rayleighScattering + mieScattering;\n                vec3 scatteringF = (scatteringNoPhase - scatteringNoPhase * sampleTransmittance) / extinction;\n                lumFactor += transmittance*scatteringF;\n\n                // This is slightly different from the paper, but I think the paper has a mistake?\n                // In equation (6), I think S(x,w_s) should be S(x-tv,w_s).\n                vec3 sunTransmittance = getValFromTLUT(iChannel0, iChannelResolution[0].xy, newPos, sunDir);\n\n                vec3 rayleighInScattering = rayleighScattering*rayleighPhaseValue;\n                float mieInScattering = mieScattering*miePhaseValue;\n                vec3 inScattering = (rayleighInScattering + mieInScattering)*sunTransmittance;\n\n                // Integrated scattering within path segment.\n                vec3 scatteringIntegral = (inScattering - inScattering * sampleTransmittance) / extinction;\n\n                lum += scatteringIntegral*transmittance;\n                transmittance *= sampleTransmittance;\n            }\n\n            if (groundDist > 0.0) {\n                vec3 hitPos = pos + groundDist*rayDir;\n                if (dot(pos, sunDir) > 0.0) {\n                    hitPos = normalize(hitPos)*groundRadiusMM;\n                    lum += transmittance*groundAlbedo*getValFromTLUT(iChannel0, iChannelResolution[0].xy, hitPos, sunDir);\n                }\n            }\n\n            fms += lumFactor*invSamples;\n            lumTotal += lum*invSamples;\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.x >= (msLUTRes.x+1.5) || fragCoord.y >= (msLUTRes.y+1.5)) {\n        return;\n    }\n    float u = clamp(fragCoord.x, 0.0, msLUTRes.x-1.0)/msLUTRes.x;\n    float v = clamp(fragCoord.y, 0.0, msLUTRes.y-1.0)/msLUTRes.y;\n\n    float sunCosTheta = 2.0*u - 1.0;\n    float sunTheta = safeacos(sunCosTheta);\n    float height = mix(groundRadiusMM, atmosphereRadiusMM, v);\n\n    vec3 pos = vec3(0.0, height, 0.0);\n    vec3 sunDir = normalize(vec3(0.0, sunCosTheta, -sin(sunTheta)));\n\n    vec3 lum, f_ms;\n    getMulScattValues(pos, sunDir, lum, f_ms);\n\n    // Equation 10 from the paper.\n    vec3 psi = lum  / (1.0 - f_ms);\n    fragColor = vec4(psi, 1.0);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Buffer C calculates the actual sky-view! It's a lat-long map (or maybe altitude-azimuth is the better term),\n// but the latitude/altitude is non-linear to get more resolution near the horizon.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.x >= (skyLUTRes.x+1.5) || fragCoord.y >= (skyLUTRes.y+1.5)) {\n        return;\n    }\n    float u = clamp(fragCoord.x, 0.0, skyLUTRes.x-1.0)/skyLUTRes.x;\n    float v = clamp(fragCoord.y, 0.0, skyLUTRes.y-1.0)/skyLUTRes.y;\n\n    float azimuthAngle = (u - 0.5)*2.0*PI;\n\n    // Non-linear mapping of altitude. See Section 5.3 of the paper.\n\n    float adjV;\n    if (v < 0.5) {\n\t\tfloat coord = 1.0 - 2.0*v;\n\t\tadjV = -coord*coord;\n\t} else {\n\t\tfloat coord = v*2.0 - 1.0;\n\t\tadjV = coord*coord;\n\t}\n\n    vec3 viewPos = getViewPos(iTime);\n\n    float height = length(viewPos); vec3 up = viewPos / height;\n    float horizonAngle = safeacos(sqrt(height * height - groundRadiusMM * groundRadiusMM) / height) - 0.5*PI;\n    float altitudeAngle = adjV*0.5*PI - horizonAngle;\n\n    float cosAltitude = cos(altitudeAngle);\n    vec3 rayDir = vec3(cosAltitude*sin(azimuthAngle), sin(altitudeAngle), -cosAltitude*cos(azimuthAngle));\n\n    float sunAltitude = (0.5*PI) - acos(dot(getSunDir(iTime), up));\n    vec3 sunDir = vec3(0.0, sin(sunAltitude), -cos(sunAltitude));\n\n    vec3 lum = raymarchScattering(iChannel0, iChannelResolution[0].xy,\n                                  iChannel1, iChannelResolution[1].xy,\n                                  viewPos, rayDir, sunDir, float(numScatteringSteps));\n    fragColor = vec4(lum, 1.0);\n}\n","name":"Buffer C","description":"","type":"buffer"}]}