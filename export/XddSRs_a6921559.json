{"ver":"0.1","info":{"id":"XddSRs","date":"1460927804","viewed":195,"name":"Sandbox 3 2 1","username":"j3553","description":"My 1st post to Shadertoy. Originally 3 separate shaders from GLSLsandbox's precursor: glsl.heroku. I couldn't retrace all credits apart from Paulo Falcao, Simon Green and Chris Wood. Shaders were ported to and blended in Quartz Composer before rewriting.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["sandbox","heroku"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// plasma functions: makePoint and minDist\nfloat makePoint(vec2 x, vec2 f, vec2 s, float t)\n{\n   vec2 p = vec2(sin(t*f.x), cos(t*f.y)) * s;\n   return sin(length(p - x) * 5.);\n}\n\nvec2 minDist(vec2 mind, float i, float d)\n{\n   return min(mind, d);\n}\n\n// dreamwaves functions: Distort, pattern, hash and noise\nvec2 Distort(vec2 p)\n{\n    float theta  = atan(p.y, p.x);\n    float radius = length(p);\n    radius = pow(radius, 1.3);\n    p.x = radius * cos(theta);\n    p.y = radius * sin(theta);\n    return 0.5 * (p + 1.0);\n}\n\nvec4 pattern(vec2 p)\n{\n\tvec2 m=mod(p.xy+p.x+p.y,2.)-1.;\n\treturn vec4(length(m));\n}\n\nfloat hash(const float n)\n{\n\treturn fract(sin(n)*43758.5453);\n}\n\nfloat noise(const vec3 x)\n{\n\tvec3 p=floor(x);\n\tvec3 f=fract(x);\n\n    \tf=f*f*(3.0-2.0*f);\n\n    \tfloat n=p.x+p.y*57.0+p.z*43.0;\n\n    \tfloat r1=mix(mix(hash(n+0.0),hash(n+1.0),f.x),mix(hash(n+57.0),hash(n+57.0+1.0),f.x),f.y);\n    \tfloat r2=mix(mix(hash(n+43.0),hash(n+43.0+1.0),f.x),mix(hash(n+43.0+57.0),hash(n+43.0+57.0+1.0),f.x),f.y);\n\n\treturn mix(r1,r2,f.z);\n}\n\n// PchasingLightBlobs\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n    \n{\n\tvec2 pos1 = ( fragCoord.xy / iResolution.xy * 7. );\n\n\tvec2 pos2 = ( fragCoord.xy/iResolution.x ) * 2.0 - vec2(1.0,iResolution.y/iResolution.x);\n\n\tvec2 pos3 = ( fragCoord.xy / iResolution.xy ) * 2.0 - 1.0;\n\tpos3.x *= iResolution.x / iResolution.y;\n\tpos3 *= 3.0;\n\n\tfloat t = iTime*0.7;\n\t\n\tfloat off = noise(pos1.xyx + .3*iTime);\n\t\n\tvec4 col1 = pattern(Distort(pos1+off));\n\n\tcol1.xy = Distort(col1.xy);\n\n\tcol1 = vec4(col1.x - off, sin(col1.y) - off, cos(col1.z), 1.0);\n\n\tvec2 a = vec2(1e10, 1e10);\n\ta = minDist(a, 1.0, makePoint(pos2, vec2(3.3,2.9), vec2(0.1,0.1), t));\n\ta += minDist(a, 2.0, makePoint(pos2, vec2(1.9,2.0), vec2(0.4,0.4), t));\n\ta *= minDist(a, 3.0, makePoint(pos2, vec2(0.8,0.7), vec2(0.4,0.5), t));\n\ta += minDist(a, 4.0, makePoint(pos2, vec2(2.3,0.1), vec2(0.6,0.3), t));\n\ta *= minDist(a, 5.0, makePoint(pos2, vec2(0.8,1.7), vec2(0.5,0.4), t));\n\ta += minDist(a, 6.0, makePoint(pos2, vec2(0.3,1.0), vec2(0.4,0.4), t));\n\ta *= minDist(a, 7.0, makePoint(pos2, vec2(1.4,1.7), vec2(0.4,0.5), t));\n\ta += minDist(a, 8.0, makePoint(pos2, vec2(1.3,2.1), vec2(0.6,0.3), t));\n\ta *= minDist(a, 9.0, makePoint(pos2, vec2(1.8,1.7), vec2(0.5,0.4), t));     \n\n\tfloat i = a.x * 50.0;\n\t\n\tvec3 col2 = 1.4 - vec3(0.8 * i, 0.8 * i, 0.4 * i);\n\n\tfloat col3 = 0.7;\n\tfor(float i = 0.0; i < 50.0; i++)\n\t{\n\t\tvec2 randCoord = vec2(rand(vec2(i, i)), rand(vec2(i, i+10.0)));\n\t\trandCoord.x += sin(iTime/2.0 + randCoord.y * randCoord.y);\n\t\trandCoord.y += sin(iTime + randCoord.x * 2.0);\n\t\t\n\t\trandCoord = randCoord * 2.0 - 1.0;\n\t\tcol3 += 1.0 / distance(pos3, randCoord) * 0.6;\n\t}\n\tcol3 *= 0.02;\n\tcol3 = pow(col3, 0.9);\n\n\tvec4 col3B = vec4( vec3(col3 + rand(pos3) * (1.0 / 128.0)), 0.3);\n\tcol3B = pow(col3B, vec4(1.5, iTime*iTime,0.86, 0.3));\n\n\tvec3 col2A = 1.-col2;\n\tfragColor = max(min(col1,vec4(col2,1.0)) , min (col3B,vec4(col2A,1.0)));\n}\n\n","name":"Image","description":"","type":"image"}]}