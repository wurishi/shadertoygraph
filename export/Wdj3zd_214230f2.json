{"ver":"0.1","info":{"id":"Wdj3zd","date":"1606789285","viewed":150,"name":"Deferred raytracing test","username":"KylBlz","description":"This is an experiment where I wanted to store the results of raytraces in the buffers. Buffer A traces the initial ray, buffer B traces the reflection, and buffer C traces the refraction. The buffers are integrated in the Image buffer.","likes":3,"published":1,"flags":48,"usePreview":0,"tags":["deferred"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// integrate bounces\n\n// Each buffer stores vec4(normal*, distance, material, <unused>)\n// *using IQ's Normals Compression: https://www.shadertoy.com/view/llfcRl\n\n\nfloat ambient = 0.01;\n\n// our shading function\nvec3 shade(in vec3 col, in vec3 ro, in vec3 rd, in vec3 n, in float t, in int o, in sph l, in mat lmat) {\n    // get material\n    int m = getMaterial(o);\n    mat mt = matLib[m];\n\n    // get light properties\n    vec3 lv = l.l - ro,\n         nlv = normalize(lv);\n    float ld = length(lv),\n        sa = solidAngle(ld, l.r),\n        ca = abs(sin(sa) / cos(sa));\n\n    // IDS\n    vec3 d, gi;\n    if (o == pln1.d) {\n        float ids1 = float(ids(ro, l.l, sph1, d));\n        vec3 dhl = d - ro,\n             surfDir = normalize(dhl);\n        // treat it like a diffuse light source with the color of the light bouncing off the sphere\n        gi = ids1 * pow(Lambertian(n, surfDir), 4.) * matLib[sph1.m].r * lmat.e / (1. + dot(dhl, dhl)) * 10.;\n        ambient *= clamp(sqrt(sd(ro, sph1).d), 0., 1.);\n    } else if (o == sph1.d) {\n        // repeat for other objects\n        float ids1 = float(ids(ro, l.l, pln1, d));\n        vec3 dhl = d - ro,\n             surfDir = normalize(dhl);\n        // treat it like a diffuse light source with the color of the light bouncing off the plane\n        gi = ids1 * pow(Lambertian(n, surfDir), 4.) * matLib[pln1.m].r * lmat.e / (1. + dot(dhl, dhl)) * 1.;\n        ambient *= clamp(sqrt(sd(ro, pln1).d), 0., 1.);\n    }\n    \n    // \"Ratio of Solid Angles\" shadows\n    float rosa = ROSA(ro, l, sph1);\n    \n    // mul reflection color for 1st bounce, add 1st surface emissive\n    return col * schlick(matLib[_air].f, mt.f, dot(n, rd)) +\n           gi +\n           rosa * lmat.e * mt.r * ggx(n, -rd, nlv, 1., 1.) / (1. + ld*ld) +\n           mt.e +\n           ambient;\n}\n\n#define oneLight(lit, lmat, col) \\\n    if (o2 > 0) col = shade(col, ro3, rd3, n2, t2, o2, lit, lmat); \\\n    if (o1 > 0) col = shade(col, ro2, rd2, n1, t1, o1, lit, lmat); \n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\t// first thing always\n    update(iTime);\n\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //get input\n\tvec3 l = tex(iChannel3, POS / iResolution.xy).xyz,\n\t\t o = tex(iChannel3, ROT / iResolution.xy).xyz,\n\t\t d = rotateXY(normalize(vec3(vec2(1., iResolution.y / iResolution.x) * (uv * 2. - 1.), 1.2)), o.xy);\n    \n    vec3 ro1 = l, rd1 = d, n1,\n         ro2,     rd2,     n2,\n         ro3,     rd3;\n    float t1,     t2;\n    int   o1,     o2;\n    int   m1,     m2;\n    // recover calculations from first trace\n    processChannel(iChannel0, uv, ro1, rd1,  t1, n1, o1, ro2, rd2);\n    \n    // if first trace hit surface get second trace\n    if (o1 > 0)\n\t  \tprocessChannel(iChannel1, uv, ro2, rd2,  t2, n2, o2, ro3, rd3);\n\n\t// final output color\n    vec3 col = vec3(ambient);\n    // one light model\n    oneLight(lit1, matLib[lit1.m], col);\n    //oneLight(lit2, matLib[lit2.m], col);\n\n    col = mix(col, vec3(ambient), vec3(min(1., sqrt(t1) * .1)));\n    \n\t// tone mapping\n    col = pow(ACESFilm(col * EXPOSURE), vec3(GAMMA));\n    \n    fragColor = vec4(col, 1.);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// trace first pass\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\t// first thing always\n    update(iTime);\n        \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    //get input\n\tvec3 l = tex(iChannel0, POS / iResolution.xy).xyz,\n\t\t o = tex(iChannel0, ROT / iResolution.xy).xyz,\n\t\t d = rotateXY(normalize(vec3(vec2(1., iResolution.y / iResolution.x) * (uv * 2. - 1.), 1.2)), o.xy);\n    \n    // trace scene\n    ray r = ray(l, d, v31, nullMat);\n    hit h = traceScene(r);\n    float t = minT(h.s.t);\n    \n    fragColor = vec4(float(octahedral_16(h.n)), t, h.o, 0.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define MULTI\t\t8\n#define BOUNCE_PXL\t8\n#define GAMMA\t\t.45\n#define EXPOSURE\t1.5\n\n//Reflect, Transmit, Emit rgb wavelengths, Surface scatter, sUbsurface scatter, reFractive index, Emission Uniformity, unique iDentifier\nstruct mat { vec3 r, t, e; vec2 s, u; float f, eu; int d; };\n//1D line segment with signed IDs for each end point\nstruct seg { vec2 t; ivec2 d; };\n//Location, Normal, segment, Object id, current Material\nstruct hit { vec3 l, n; seg s; int o, m; };\n//Origin, Direction, Color, current Material\nstruct ray { vec3 o, d, c; mat m; };\n//Location, Normal, Distance, Object id\nstruct sdf { float d; int o, m; };\n//Output structure holding two colors\nstruct mad { vec3 m, a; };\n\n//center Location, Radius, Material, iDentifier\nstruct sph { vec3 l; float r; int m, d; };\n//Location, Normal, size, Material, iDentifier\nstruct pln { vec3 l; mat3 o; int m, d; };\n\n// Some shortcuts\n#define v20 vec2(0.)\n#define v21 vec2(1.)\n#define v30 vec3(0.)\n#define v31 vec3(1.)\n#define v40 vec4(0.)\n#define v41 vec4(1.)\n#define vec3max(a) max(a.x, max(a.y, a.z))\n#define vec3min(a) min(a.x, min(a.y, a.z))\n#define vec4max(a) max(max(a.x, a.y), max(a.z, a.w))\n#define vec4min(a) min(min(a.x, a.y), min(a.z, a.w))\n#define inRange(a,x,b) step(a,x)*step(x,b)\n#define tex(a,b) textureLod(a,b,0.)\n#define texComp(a,b,c) vec4max((tex(a, b) * c))\n\nconst float\teps = .0001, ieps = .9999, sml = .001, isml = .999, zfar = 10000.,\n\t\t\tpi_rcp = .3183098, pi2_rcp = .1591549, pi4_rcp = .0795775,\n    \t\tpi_5 = 1.5707963, pi = 3.1415926, pi2 = 6.2831853, pi4 = 12.56637,\n\t\t\tsc45 = .7071067, s60 = .866025, sqrt2 = 1.4142135, sqrt3 = 1.732050808;\nconst vec2\tVEL = vec2(0.5), POS = vec2(1.5, 0.5), ROT = vec2(2.5, 0.5), MOU = vec2(3.5, 0.5);\n\nconst mat nullMat = mat(v30, v30, v30, vec2(0.), vec2(0.), 0., 0., -1);\nconst seg nullSeg = seg(vec2(zfar), ivec2(0));\nconst hit nullHit = hit(v30, v30, nullSeg, 0, -1);\nconst sdf nullSdf = sdf(zfar, -1, -1);\nconst vec2 nullT = vec2(zfar, 0.);\n\n////////////////////// random number (distribution sucks)\nfloat hash12( in vec2 p ) {\n\tfloat h = dot(p,vec2(101.7, 683.11));\n    return fract(sin(h)*467.709);\n}\nfloat hash13( in vec3 p ) {\n\tfloat h = dot(p,vec3(571.127, 467.311, 881.521));\n    return fract(sin(h)*467.197);\n}\nvec2 hash22( in vec2 p ) {\n\tvec2 h = vec2(dot(p,vec2(467.127, 881.311)),\n                  dot(p,vec2(7.101, 11.683)));\n    return fract(sin(h)*467.281);\n}\nvec3 hash33( in vec3 p ) {\n\tvec3 h = vec3(dot(p,vec3(467.127, 881.311, 571.521)),\n                  dot(p,vec3(7.101, 11.683, 13.331)),\n                  dot(p,vec3(683.331, 761.101, 823.127)));\n    return fract(sin(h)*467.281);\n}\n\n////////////////////// normal(ish) distribution\nfloat bell12( in vec2 n ) {\n\tfloat r0 = hash12(n + 0.07),\n\t r1 = hash12(n + 0.11);\n\treturn (r0+r1) * 0.5;\n}\nfloat bell13( in vec3 n ) {\n\tfloat r0 = hash13(n + 0.07),\n\t r1 = hash13(n + 0.11);\n\treturn (r0+r1) * 0.5;\n}\nvec3 bell33( in vec3 n ) {\n\tvec3 r0 = hash33(n + 17.07),\n\t r1 = hash33(n + 13.11);\n\treturn (r0+r1) * 0.5;\n}\n\n////////////////////// some tools\n// tone mapping https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x) {\n    return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), v30, v31);\n}\nvoid basis(in vec3 n, out vec3 f, out vec3 r) {\n    float a = 1. / (1. + n.z);\n    float b = -n.x*n.y*a;\n    f = vec3(1. - n.x*n.x*a, b, -n.x);\n    r = vec3(b, 1. - n.y*n.y*a, -n.y);\n}\nvec3 rotateXY(in vec3 p, in vec2 angle) {\n    vec2 c=cos(angle), s=sin(angle); vec3 o = p;\n    o.yz *= mat2(c.x,s.x,-s.x,c.x);  o.xz *= mat2(c.y,s.y,-s.y,c.y);\n    return o;\n}\n//solid angle of sphere at distance D with radius R\nfloat solidAngle(float d, float r) {\n    return min(pi_5, abs(asin(r/d)));\n}\nvec3 slerp(in vec3 start, in vec3 end, in float percent) {\n    float dt = dot(start, end), theta = acos(dt)*percent;\n    return start*cos(theta) + normalize(end - start*dt)*sin(theta);\n}\nvec3 rndSphere(in vec3 chaos) {\n    return normalize(bell33(chaos)*2.-1.);\n}\nvec3 rndHemi(in vec3 norm, in vec3 chaos) {\n    vec3 guess = normalize(bell33(chaos + norm)*2.-1.);\n    float negate = step(0., dot(norm, guess))*2.-1.;\n    return guess * negate;\n}\n\n//////////////////////////////////////////// Segment operators ////////////////////////////////////////////\n#define len(a) (a.t.y - a.t.x)\n#define valid(a) (a.t.y < zfar)\n#define overlap(a, b) ((a.t.y > b.t.x) && (a.t.x < b.t.y))\n#define contains(a, b) ((a.t.x > b.t.x) && (a.t.y < b.t.y))\n#define minT(a) ((a.y<a.x)? zfar: (a.x<0.)? (a.y<0.)? zfar: a.y: a.x)\n#define pickXLT(l, r) ((l.t.x < r.t.x)? vec2(l.t.x, float(l.d.x)): vec2(r.t.x, float(r.d.x)))\n#define pickYLT(l, r) ((l.t.y < r.t.y)? vec2(l.t.y, float(l.d.y)): vec2(r.t.y, float(r.d.y)))\n#define pickXGT(l, r) ((l.t.x > r.t.x && l.t.x < zfar)? vec2(l.t.x, float(l.d.x)): (r.t.x < zfar)? vec2(r.t.x, float(r.d.x)): nullT)\n#define pickYGT(l, r) ((l.t.y > r.t.y && l.t.y < zfar)? vec2(l.t.y, float(l.d.y)): (r.t.y < zfar)? vec2(r.t.y, float(r.d.y)): nullT)\nvoid lt(inout seg o, in seg s) {\n    if (minT(s.t) < minT(o.t))\n        o = s;\n}\nvec2 lt(in seg s) {\n    if (s.t.x < s.t.y && s.t.x > 0.) return vec2(s.t.x, float(s.d.x));\n    else if (s.t.y > 0.) return vec2(s.t.y, float(s.d.y));\n    return nullT;\n}\nvoid tIntersect(in seg l, in seg r, out seg o) {\n    if (!overlap(l, r) || !valid(l) || !valid(r)) {\n        o = nullSeg; return;\n    }\n    vec2 t1 = pickXGT(l, r), t2 = pickYLT(l, r);\n    o = seg(vec2(t1.x, t2.x), ivec2(int(t1.y), int(t2.y)));\n}\nvoid tUnion(in seg l, in seg r, out seg o, out seg p) {\n    if (!overlap(l, r)) {\n        o = l; p = r; return; \n    }\n    vec2 t1 = pickXLT(l, r), t2 = pickYGT(l, r);\n    o = seg(vec2(t1.x, t2.x), ivec2(int(t1.y), int(t2.y)));\n    p = nullSeg;\n}\nvoid tDiff(in seg l, in seg r, out seg o, out seg p) {\n    if (!overlap(l, r)) { o = l; p = nullSeg; return; }\n    if (contains(l, r)) { o = nullSeg; p = nullSeg; return; }\n    if (contains(r, l)) {\n\t\tvec2 t1 = pickXLT(l, r), t2 = pickXGT(l, r),\n             t3 = pickYLT(l, r), t4 = pickYGT(l, r);\n\t    o = seg(vec2(t1.x, t2.x), ivec2(int(t1.y), int(t2.y)));\n\t    p = seg(vec2(t3.x, t4.x), ivec2(int(t3.y), int(t4.y)));\n    } else {\n    \tvec2 t1 = nullT, t2 = nullT;\n    \tif (l.t.x < r.t.x) {\n            t1 = pickXLT(l, r); t2 = pickXGT(l, r);\n    \t} else {\n            t1 = pickYLT(l, r); t2 = pickYGT(l, r);\n        } \n    \to = seg(vec2(t1.x, t2.x), ivec2(int(t1.y), int(t2.y)));\n        p = nullSeg;\n    }\n}\n\n//////////////////////////////////////////// Signed distance functions ////////////////////////////////////////////\n// Signed distance operators (thanks IQ)\n#define sdIntersect(l, r) max(d1, d2)\n#define sdUnion(l, r) min(l, r)\n#define sdDiff(l, r) max(-l, r)\nvoid lt(inout sdf l, in sdf r) {\n    if (r.d < l.d && r.d > 0.)\n        l = r;\n}\n//thanks IQ\nsdf sd(in vec3 l, in sph s) {\n    vec3 oc = l - s.l;\n    return sdf(dot(oc, oc) - s.r * s.r, s.d, s.m);\n}\nsdf sd(in vec3 l, in pln p) {\n    return sdf(dot(p.o[1], l - p.l), p.d, p.m);\n}\n\n//////////////////////////////////////////// Normal functions ////////////////////////////////////////////\nvec3 nrm(in vec3 l, in sph s) {\n    return (l - s.l) / s.r;   \n}\nvec3 nrm(in vec3 l, in pln p) {\n    return p.o[1];\n}\n\n//////////////////////////////////////////// UV map functions ////////////////////////////////////////////\nvec2 map(in vec3 l, in vec3 n, in sph s) {\n    return vec2(atan(n.z, n.x) + pi, acos(-n.y)) / vec2(pi2, pi);\n}\nvec2 map(in vec3 l, in sph s) {\n    vec3 n = nrm(l, s);\n    return map(l, n, s);\n}\nvec2 map(in vec3 l, in pln p) {\n    return vec2(dot(l, p.o[0]), dot(l, p.o[2]));\n}\n\n//////////////////////////////////////////// Segment functions ////////////////////////////////////////////\nseg rs(in ray r, in sph s) {\n    vec3 oc = r.o - s.l;\n    float c = dot(oc, oc) - s.r * s.r,\n          b = -dot(oc, r.d), h = b*b - c;\n    if (h < 0.) return nullSeg;\n    h = sqrt(h);\n    return seg(vec2(b-h,b+h), ivec2(s.d, -s.d));\n}\nseg rs(in ray r, in pln p) {\n    float t = dot(p.o[1], p.l - r.o) / dot(p.o[1], r.d);\n\treturn seg(vec2(t, t + eps), ivec2(p.d, -p.d));\n}\n\n////////////////////////////////////////// Hit functions //////////////////////////////////////////\nvoid lt(inout hit o, in hit h) {\n    if (minT(h.s.t) < minT(o.s.t)) o = h;\n}\nvoid tlt(inout hit o, in hit h) {\n    if (len(h.s) > len(o.s)) o = h;\n}\n// raytrace function\n#define _trc \\\n    seg s = rs(r, o); \\\n    vec3 l = r.o + r.d * minT(s.t); \\\n    hit h = hit(l, nrm(l, o), s, o.d, o.m)\n\nhit trace(in ray r, in sph o) { _trc; return h; }\nhit trace(in ray r, in pln o) { _trc; return h; }\n\n//////////////////////////////////////// Scene Definition ////////////////////////////////////////\n\n// IDs\nconst int\n// Materials\n_air = 0, _gls = 1, _chr_g = 2, _wht = 3, _blu = 4, _blk = 5, _wht_e = 6, _wht2_e = 7,\n// Primitivies\n_lit1 = 1, _lit2 = 2, _sph1 = 3, _sph2 = 4, _box1 = 5, _pln1 = 6;\n\nconst mat[] matLib = mat[] (\n//conductors\n    mat(vec3(0.001), vec3(0.99), vec3(0.), vec2(1.), vec2(0.), 1.0003, 0., _air),\n\tmat(vec3(.5),    vec3(.5),   vec3(0.), vec2(1.), vec2(0.), 1.7, 0., _gls),\n//reflective insulator\n \n\n   mat(vec3(0.,1.,0.), vec3(0.), vec3(0.), vec2(1.), vec2(0.), -1., 0., _chr_g),\n//diffuse insulator\n    mat(vec3(.3,.3,.3), vec3(0.), vec3(0.), vec2(1.), vec2(0.), 2., 0., _wht),\n    mat(vec3(0.,0.,.3), vec3(0.), vec3(0.), vec2(1.), vec2(0.), 2., 0., _blu),\n    mat(vec3(.3,0.,0.), vec3(0.), vec3(0.), vec2(1.), vec2(0.), -1., 0., _blk),\n//emissive\n\tmat(vec3(1.), vec3(1.), vec3(10.), vec2(1.), vec2(1.), -1., 0., _wht_e),\n\tmat(vec3(1.), vec3(1.), vec3(10.), vec2(1.), vec2(1.), -1., 0., _wht2_e)\n);\n\n// Primitives\nsph sph1 = sph(vec3(0., -1., 0.), 1., _blu, _sph1),\n//lights\n\tlit1 = sph(vec3(2.,2.,0.), .5, _wht2_e, _lit1),\n    lit2 = sph(vec3(-2.,2.,0.), .5, _wht_e, _lit2);\n//planes\npln pln1 = pln(vec3(0.,-2.,0.), mat3(1.), _wht, _pln1);\n\n///////////////////////////////////////// Scene /////////////////////////////////////////\n\n//calculates where the ray intersects\nhit traceScene(in ray r) {\n    //trace objects and lights\n    hit ret = nullHit;\n    lt(ret, trace(r, pln1));\n    lt(ret, trace(r, lit1));\n    //lt(ret, trace(r, lit2));\n    lt(ret, trace(r, sph1));\n    return ret;\n}\nhit traceSceneThickness(in ray r) {\n    //trace objects only\n    hit ret = nullHit;\n    tlt(ret, trace(r, pln1));\n    tlt(ret, trace(r, sph1));\n\treturn ret;\n}\n\nsdf sdSmp(in vec3 l) {\n\tsdf d = nullSdf;\n    lt(d, sd(l, pln1));\n    lt(d, sd(l, lit1));\n    //lt(d, sd(l, lit2));\n    lt(d, sd(l, sph1));\n\treturn d;\n}\n\nsdf sdSmp(in vec3 l, in int id) {\n\tsdf d = nullSdf;\n    if (id != pln1.d)\n        lt(d, sd(l, pln1));\n    if (id != sph1.d)\n        lt(d, sd(l, sph1));\n\treturn d;\n}\n\nint getMaterial(in int d) {\n    if (d == sph1.d)\n        return sph1.m;\n    else if (d == pln1.d)\n        return pln1.m;\n    else if (d == lit1.d)\n        return lit1.m;\n    else if (d == lit2.d)\n        return lit2.m;\n    else\n        return -1;\n}\n\nvec3 sdNorm(vec3 p) {\n    vec3 e = vec3 (.001, -.001, 0.);\n    vec4 v = vec4(sdSmp(p + e.xxx).d, sdSmp(p + e.xyy).d,\n                  sdSmp(p + e.yxy).d, sdSmp(p + e.yyx).d);\n    return normalize(vec3(v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nhit sdScene(in ray r, in float md) {\n    hit h = nullHit;\n\tsdf d = nullSdf;\n\tvec3 l = r.o;\n\tfloat t = 0.;\n\tfor (int i = 0; i < 128; ++i) {\n\t\td = sdSmp(l);\n\t\tt += d.d;\n\t\tif (t > md) break;\n\t\tl += r.d * d.d;\n\t\tif (d.d < eps * float(i))\n            return hit(l, sdNorm(l), seg(vec2(t, t+eps), ivec2(d.o, -d.o)), d.o, d.m);\n\t}\n\treturn h;\n}\n\nvoid update(in float time) {\n    lit1.r = .26 + sin(time * 2.) * .25;\n    lit1.l = vec3(2. * sin(time), cos(time), 2. * cos(time));\n    lit2.r = .26 + cos(time * 2.) * .25;\n    lit2.l = vec3(-2. * sin(time), cos(time), -2. * cos(time));\n}\n\n///////////////////////////////////////// surface funcs /////////////////////////////////////////\n// returns point d on the object where specular from l is coming from\nbool ids(in vec3 h, in vec3 l, in pln p, out vec3 d) {\n    vec3 pn = p.o[1];\n    // get distance from each point to the plane\n    float a = dot(h - p.l, pn),\n          b = dot(l - p.l, pn);\n    // if they are not both above the plane\n    if (a < 0. || b < 0.) return false;\n    // similar triangles, just use the ratio of side lengths\n    d = mix(h - a*pn, l - b*pn, a / (a + b));\n    return true;\n}\n// quampute the caustics by breaking it again (change lh = normalize(l - h), change hsl = h - s.l) \nbool ids(in vec3 h, in vec3 l, in sph s, out vec3 d) {\n    // if (s.l - h) is projected onto (l - h), the result should be outside the sphere\n    vec3 lh = l - h;\n    vec3 hsl = s.l - h;\n    if (distance(h + normalize(lh) * (dot(hsl, lh) / length(lh)), s.l) < s.r) return false;\n    // distance from each point to surface of sphere (should always be positive)\n    vec3 lsl = l - s.l;\n    float a = length(hsl) - s.r,\n          b = length(lsl) - s.r;\n    // figure the direction with the ratio of distances, then multiply out to sphere surface\n    d = slerp(normalize(hsl), normalize(lsl), a / (a + b)) * s.r + s.l;\n    return true;\n}\n\n// solid angle of light normalized away so it is independent of the size of the light\nfloat ROSA(in vec3 l, in sph lit, in sph occ) {\n    vec3 lv = lit.l - l,\n         ov = occ.l - l;\n    float ld = sqrt(dot(lv, lv)),\n          od = sqrt(dot(ov, ov)),\n          sal = solidAngle(ld, lit.r),\n          sao = solidAngle(od, occ.r),\n          fsa = sal;\n    if (od < ld) {\n        float theta = acos(dot(lv / ld, ov / od));\n\t    fsa *= 1. - clamp((sao - theta) / sal, 0., 1.);\n    }\n    fsa /= sal;\n    return fsa * fsa;\n}\n\nfloat Blinn(in vec3 hn, in vec3 rd, in vec3 lv, in float roughness) {\n    vec3 H = normalize(rd + lv);\n    float dotNH = clamp(dot(hn, H), 0., 1.);\n    return (roughness + 2.) / (8. * pi) * pow(dotNH, roughness);\n}\n\nfloat Lambertian(in vec3 hn, in vec3 lv) {\n    return clamp(dot(hn, lv), 0., 1.) * pi_rcp;\n}\n\n// ggx from goo shader\nfloat G1V(float dnv, float k){\n    return 1.0/(dnv*(1.0-k)+k);\n}\nfloat ggx(vec3 n, vec3 v, vec3 l, float rough, float f0) {\n    vec3 h = normalize(v+l);\n    float alpha = rough*rough;\n    float asqr = alpha*alpha;\n    float dnl = clamp(dot(n, l), 0., 1.);\n    float dnv = clamp(dot(n, v), 0., 1.);\n    float dnh = clamp(dot(n, h), 0., 1.);\n    float den = dnh*dnh * (asqr - 1.) + 1.;\n    float d = asqr / (pi * den * den);\n    float dlh = pow(1. - clamp(dot(l, h), 0., 1.), 5.);\n    float f = f0 + (1. - f0)*dlh;\n    float vis = G1V(dnl, alpha) * G1V(dnv, alpha);\n    return dnl * d * f * vis;\n}\n\nfloat schlick(in float r1, in float r2, in float vn) {\n    float r0 = (r1 - r2) / (r1 + r2);\n\treturn mix(r0*r0, 1., pow(1. - vn, 5.));\n}\n\n\n// from IQ's Normals Compression: https://www.shadertoy.com/view/llfcRl\nvec2 msign(vec2 v) {\n    return vec2((v.x >= 0.0)? 1.0: -1.0, (v.y >= 0.0)? 1.0: -1.0);\n}\n\nuint packSnorm2x8(vec2 v) {\n    uvec2 d = uvec2(round(127.5 + v * 127.5));\n    return d.x | (d.y << 8u);\n}\n\nuint octahedral_16(in vec3 nor) {\n    nor /= ( abs( nor.x ) + abs( nor.y ) + abs( nor.z ) );\n    nor.xy = (nor.z >= 0.0)? nor.xy: (1.0 - abs(nor.yx)) * msign(nor.xy);\n    return packSnorm2x8(nor.xy);\n}\n\nvec2 unpackSnorm2x8(uint d) {\n    return vec2(uvec2(d,d>> 8) & 255u) / 127.5 - 1.0;\n}\n\nvec3 i_octahedral_16(uint data) {\n    vec2 v = unpackSnorm2x8(data);\n    vec3 nor = vec3(v, 1.0 - abs(v.x) - abs(v.y)); // Rune Stubbe's version,\n    float t = max(-nor.z,0.0);                     // much faster than original\n    nor.x += (nor.x>0.0)?-t:t;                     // implementation of this\n    nor.y += (nor.y>0.0)?-t:t;                     // technique\n    return normalize( nor );\n}\n\n// extract/recalc vars from channel\nvoid processChannel(sampler2D channel, in vec2 uv, in vec3 ro, in vec3 rd, out float d, out vec3 n, out int o, out vec3 l, out vec3 f) {\n    vec4 frame = textureLod(channel, uv, 0.);\n\t// distance\n    d = frame.g;\n    // material\n    o = int(frame.b);\n    // too far or hit nothing\n    if (d > zfar || o < 0) {\n        return;\n    }\n    // hit object properties\n    l = ro + rd * d;\n    n = i_octahedral_16(uint(frame.r));\n    // new direction\n    f = reflect(rd, n);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// trace reflect ray\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\t// first thing always\n    update(iTime);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // first trace\n    vec4 frame = textureLod(iChannel0, uv, 0.);\n\n    // first ray failed\n    if (frame.g < 0. || frame.g > zfar) {\n        fragColor = vec4(0.);\n        return;\n    }\n    \n    //get input\n\tvec3 l = tex(iChannel1, POS / iResolution.xy).xyz,\n\t\t o = tex(iChannel1, ROT / iResolution.xy).xyz,\n\t\t d = rotateXY(normalize(vec3(vec2(1., iResolution.y / iResolution.x) * (uv * 2. - 1.), 1.2)), o.xy);\n    \n    // go to bounce\n    l += d * frame.g;\n    // surface normal\n    vec3 hn = i_octahedral_16(uint(frame.r));\n    \n    // sample reflection ray\n    ray r = ray(l + hn * eps, reflect(d, hn), v31, nullMat);\n    hit h = traceScene(r);\n    float t = minT(h.s.t);\n    \n    fragColor = vec4(float(octahedral_16(h.n)), t, h.o, 0.);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// trace refract ray\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\t// first thing always\n    update(iTime);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // first trace\n    vec4 frame = textureLod(iChannel0, uv, 0.);\n    \n    // first ray failed\n    if (frame.g < 0. || frame.g > zfar) {\n        fragColor = vec4(0.);\n        return;\n    }\n    \n    //get input\n\tvec3 l = tex(iChannel1, POS / iResolution.xy).xyz,\n\t\t o = tex(iChannel1, ROT / iResolution.xy).xyz,\n\t\t d = rotateXY(normalize(vec3(vec2(1., iResolution.y / iResolution.x) * (uv * 2. - 1.), 1.2)), o.xy);\n    \n    // go to bounce\n    l += d * frame.g;\n    // surface normal\n    vec3 hn = i_octahedral_16(uint(frame.r));\n    // object hit\n\tint obj = int(frame.b);\n    \n    // trace scene\n    ray r = ray(l - hn * eps, refract(d, hn, matLib[_air].f / matLib[getMaterial(obj)].f), v31, nullMat);\n    hit h = traceScene(r);\n    float t = minT(h.s.t);\n    \n    fragColor = vec4(float(octahedral_16(h.n)), t, h.o, 0.);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// controls\n\n//#define INVERT_ROTATION\n\n#define MAX_ACCELERATION      4.\n#define MAX_VELOCITY          4.\n#define FRICTION              2.\n\n#define VALUE_VELOCITY        0\n#define VALUE_POSITION        1\n#define VALUE_ROTATION        2\n#define VALUE_MOUSE           3\n\n//controls\nconst vec2 KEY_W \t = vec2(87.5 / 256., 0.),\n    \t   KEY_S \t = vec2(83.5 / 256., 0.),\n    \t   KEY_A \t = vec2(65.5 / 256., 0.),\n    \t   KEY_D \t = vec2(68.5 / 256., 0.),\n\t\t   KEY_LEFT  = vec2(37.5 / 256., 0.),\n\t\t   KEY_UP    = vec2(38.5 / 256., 0.),\n\t\t   KEY_RIGHT = vec2(39.5 / 256., 0.),\n\t\t   KEY_DOWN  = vec2(40.5 / 256., 0.),\n    \t   KEY_SHIFT = vec2(16.0 / 256., 0.),\n    \t   KEY_SPACE = vec2(32.0 / 256., 0.);\n\nconst vec4 INIT_POS = vec4(0., .5, -8., 0.),\n    \t   INIT_VEL = vec4(0.),\n    \t   INIT_ROT = vec4(-.2, 0., 0., 0.),\n    \t   INIT_MOU = vec4(0.);\n\nvec3 vRotateY(vec3 p, float angle) {\n    float c = cos(angle), s = sin(angle);\n    return vec3(c*p.x + s*p.z, p.y, -s*p.x + c*p.z);\n}\n\nvec3 getAcceleration() {\n    return vec3(\n        tex(iChannel1, KEY_D).x - tex(iChannel1, KEY_A).x + tex(iChannel1, KEY_RIGHT).x - tex(iChannel1, KEY_LEFT).x,\n        tex(iChannel1, KEY_SPACE).x - tex(iChannel1, KEY_SHIFT).x,\n        tex(iChannel1, KEY_W).x - tex(iChannel1, KEY_S).x + tex(iChannel1, KEY_UP).x - tex(iChannel1, KEY_DOWN).x\n    );\n}\n\nvec4 getValue(int a) {\n    vec2 q = vec2(float(a) + 0.5, 0.0) / iResolution.x;\n    return tex(iChannel0, q);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    if (fragCoord.y > 1.) discard;\n    \n    int a = int(fragCoord.x);\n    float q = fragCoord.x / iResolution.x;\n    vec4 value = tex(iChannel0, vec2(q, 0.));\n    \n    //set initial values\n    if (iFrame == 0) {\n        if (a == VALUE_ROTATION) {\n            value = INIT_ROT;\n        } else if (a == VALUE_MOUSE) {\n            value = INIT_ROT;\n        } else if (a == VALUE_VELOCITY) {\n            value = INIT_VEL;\n        } else if (a == VALUE_POSITION) {\n            value = INIT_POS;\n        }    \n    } else if (a == VALUE_ROTATION && iMouse.z > 0.) {\n        vec4 mouse = 2.0 * abs(iMouse) / iResolution.y;\n        vec4 rot = getValue(VALUE_MOUSE);\n      \tvalue.y = mouse.x - mouse.z + rot.y;\n      \tvalue.x = clamp(mouse.y - mouse.w + rot.x, -pi_5, pi_5);\n        \n    } else if (a == VALUE_MOUSE && iMouse.z < 0.) {\n        value = getValue(VALUE_ROTATION);\n        \n    } else if (a == VALUE_VELOCITY) {\n        float rot = getValue(VALUE_ROTATION).y;\n        vec3 acc = vRotateY(getAcceleration(), rot);\n        value.xyz += acc * MAX_ACCELERATION * iTimeDelta;\n        float speed = length(value.xyz);\n        //limit speed\n        if (speed > MAX_VELOCITY) {\n            value.xyz *= MAX_VELOCITY / speed;\n        } else if (speed > FRICTION * iTimeDelta) {\n            value.xyz *= (speed - FRICTION * iTimeDelta) / speed;\n        } else {\n            value.xyz = vec3(0.0, 0.0, 0.0);\n        }\n    } else if (a == VALUE_POSITION) {\n        vec3 velocity = getValue(VALUE_VELOCITY).xyz;\n        value.xyz += velocity * iTimeDelta;\n        //collision detection?\n        value.y = max(value.y, pln1.l.y + eps);\n    }\n    \n    fragColor = vec4(value);\n    return;\n}","name":"Buffer D","description":"","type":"buffer"}]}