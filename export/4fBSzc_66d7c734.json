{"ver":"0.1","info":{"id":"4fBSzc","date":"1706688859","viewed":242,"name":"2 step Cone Marching ","username":"seven_dc","description":"This is cone marching example. \nPRESS MOUSE 1 to see the Buffer A and Buffer B output.\n\nCone marching is just rendering a depth of the scene on lower resolution in the buffer. and then using that depth to fast travel to your point in the final render.","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["raymarch","conemarching"],"hasliked":0,"parentid":"lcBXzV","parentname":"1 step Cone Marching seven_dc"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS_LAST_STEP 20\n#define SURF_DIST .002\n\nvec2 RayMarch(vec3 rayOrgin, vec3 rayDirection) {\n\tfloat distance=0.;\n    \n    int i, steps = MAX_STEPS_LAST_STEP; \n    \n    for(i=0; i<steps; i++) {\n    \tvec3 point = rayOrgin + rayDirection * distance;\n        float surfaceDistance = GetDistance(point, iTime);\n        distance += surfaceDistance;\n        // Stop marching if we go too far or we are close enough of surface\n        if(surfaceDistance<SURF_DIST) break;\n    }\n    \n    return vec2(distance,i);\n}\n\nfloat GetLight(vec3 point, vec3 normal, vec3 lightPos) {    \n  \n  vec3 direction = normalize(lightPos-point);\n  \n  float dif = clamp(dot(normal, direction), 0., 1.);\n  \n  vec2 d = RayMarch(point+normal*.1, direction);\n  if ( d.x < length(lightPos-point)) {\n      dif *= 0.5;      \n  } else {\n      dif -= d.y*.006;\n  }\n  \n  return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    if (iMouse.z > 1.) {\n        if (iMouse.x > iResolution.x*.5) {\n            vec4 d1 = texture(iChannel1,fragCoord/iResolution.xy);\n            fragColor = d1;\n        } else {\n            vec4 d1 = texture(iChannel0,fragCoord/iResolution.xy);\n            fragColor = d1;\n        }\n        return;\n    }    \n    \n    vec2 cd = vec2((fragCoord.x * .5)+iResolution.x/4.,(fragCoord.y * .5)+iResolution.y/4.);    \n    \n    vec3 col = vec3(0.);\n    vec4 d1 = texture(iChannel0,cd/iResolution.xy);\n    if (d1.x > 1.) {\n        // depth is too far we can ignore this\n        return;\n    }\n    \n    // put 0,0 in the center\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;        \n       \n    // camera   \n    vec3 rayOrgin = vec3(0., 2, 4.);\n    vec3 rayDirection = normalize(vec3(uv.x, uv.y, 1));\n    rayDirection.yz *= Rotate(.3);\n    rayDirection.xz *= Rotate(sin(iTime));\n    \n    vec3 newOrigin = rayOrgin + rayDirection * (d1.x*DEPTMAPDIVIDER);\n    \n\n    vec2 d = RayMarch(newOrigin, rayDirection);\n    \n    vec3 lightPos = vec3(1, 4, 3);\n    \n    \n    vec3 p = newOrigin + rayDirection * d.x;\n    vec3 n = GetNormal(p, iTime);\n    float light = GetLight(p, n, lightPos);\n    // color\n    col = vec3(light);\n    col.r += n.r*.3;\n    col.g += n.r*.1;\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define DEPTMAPDIVIDER 22. // This is used to divide and multiply the depth to store in buffer A\n\nmat2 Rotate(float a) {\n  float s = sin(a);\n  float c = cos(a);\n  return mat2(c, -s, s, c);\n}\n\nfloat smin( float a, float b, float k ) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat ballDist(vec3 point, vec4 sphere, float preBallDist) {\n    float l1 = length(point-sphere.xyz)-sphere.w;\n    return smin(l1, preBallDist, .6);\n}\n\nfloat GetDistance(vec3 point, float iTime) {\n\tvec4 sphere = vec4(0, 1., 5., 1);\n    float planeDist = point.y+ mod(iTime*3., 1.)*.05; // 3 times a second       \n    planeDist += smoothstep(.5, 0.01, abs(mod(point.x, 3.)-1.))*.2;\n    planeDist += smoothstep(.5, 0.01, abs(mod(point.z, 3.)-1.))*.2;\n    \n    \n    float rot1 = sin(iTime);\n    float rot2 = cos(iTime);\n    float rot3 = sin(iTime*2.);\n    float rot4 = cos(iTime*3.);\n    \n    float rot5 = sin(iTime*6.);\n    float rot6 = cos(iTime*6.);\n    \n\n    vec3 spoint = vec3(mod(point.x, 7.)-3., point.y, mod(point.z, 7.)-0.);\n    \n\n    vec4 ball1 = vec4(0, 1., 5.+rot1*.5, 1);\n\n    float spd1 = ballDist(spoint, ball1, 9.);\n    float spd2 = ballDist(spoint, vec4(0. + rot1, 2., 5., .4), spd1);  \n    float spd3 = ballDist(spoint, vec4(0. + rot1 * 1.5, 1., 4.5-rot2* 1.5, .2), spd2);\n    float spd4 = ballDist(spoint, vec4(0. + rot3 * 1.5, .5, 4.5-rot2* 1.5, .2), spd3);\n    \n    vec4 ball2 = vec4(.5 + rot4 * .5, 1.+rot1*.5, 4.5-rot4* 2., .5);\n    \n    float spd5 = ballDist(spoint, ball2, spd4);\n    float spd6 = ballDist(spoint, ball2+vec4(rot5, rot6*.5, rot6, -.2), spd5);\n   \n    float spd7 = ballDist(spoint, ball1+vec4(-rot5*2., rot6*.5, -rot2, -.5), spd6);\n    \n    \n    float d = min(spd7, planeDist);\n    \n    return d;\n}\n\nvec3 GetNormal(vec3 point, float iTime) {\n  float distance = GetDistance(point, iTime);\n  vec2 e = vec2(.01,0);\n  \n  vec3 normal = distance - vec3(\n      GetDistance(point-e.xyy, iTime),\n      GetDistance(point-e.yxy, iTime),\n      GetDistance(point-e.yyx, iTime));\n  \n  return normalize(normal);\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAX_STEPS_A 70\n#define MAX_DIST 20.\n#define SURF_DIST .01\n\n\n// Raymarching here a low resolution base image into buffer iChannel0 for input for Buffer A\n// Press mouse1 to see the output of this buffer.\nvec2 RayMarch(vec3 rayOrgin, vec3 rayDirection) {\n\tfloat distance=0.;\n    \n    int i, steps = MAX_STEPS_A; \n    \n    for(i=0; i<steps; i++) {\n    \tvec3 point = rayOrgin + rayDirection * distance;\n        float surfaceDistance = GetDistance(point, iTime);\n        distance += surfaceDistance;\n        // Stop marching if we go too far or we are close enough of surface\n        if(distance>MAX_DIST || surfaceDistance<SURF_DIST) break;\n    }\n    \n    return vec2(distance,i);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // put 0,0 in the center\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    fragColor = vec4(0.);\n    // render about fourth of the resolution.\n    // this is done just for shadertoy\n    if (abs(uv.x) > .25) return; \n    if (abs(uv.y) > .125) return;\n    uv *= 4.;    \n       \n    // camera   \n    vec3 rayOrgin = vec3(0., 2, 4.);\n    vec3 rayDirection = normalize(vec3(uv.x, uv.y, 1));\n    rayDirection.yz *= Rotate(.3);\n    rayDirection.xz *= Rotate(sin(iTime));\n    \n    vec2 d = RayMarch(rayOrgin, rayDirection);\n    \n    // So much to do here other than just save it as black and white image and then use just the x channel\n    vec3 col = vec3(d.x/DEPTMAPDIVIDER);    \n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define MAX_STEPS_B 10\n#define MAX_DIST 20.\n#define SURF_DIST .005\n\n\n// Raymarching here a low resolution base image into buffer iChannel0 for input for Image step\n// Press mouse1 to see the output of this buffer.\nvec2 RayMarch(vec3 rayOrgin, vec3 rayDirection) {\n\tfloat distance=0.;\n    \n    int i, steps = MAX_STEPS_B; \n    \n    for(i=0; i<steps; i++) {\n    \tvec3 point = rayOrgin + rayDirection * distance;\n        float surfaceDistance = GetDistance(point, iTime);\n        distance += surfaceDistance;\n        // Stop marching if we go too far or we are close enough of surface\n        if(distance>MAX_DIST || surfaceDistance<SURF_DIST) break;\n    }\n    \n    return vec2(distance,i);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // put 0,0 in the center\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    fragColor = vec4(0.);\n    // render about half of the resolution.\n    // this is done just for shadertoy\n    if (abs(uv.x) > .5) return; \n    if (abs(uv.y) > .25) return;\n    uv *= 2.;    \n       \n    // camera   \n    vec3 rayOrgin = vec3(0., 2, 4.);\n    vec3 rayDirection = normalize(vec3(uv.x, uv.y, 1));\n    rayDirection.yz *= Rotate(.3);\n    rayDirection.xz *= Rotate(sin(iTime));\n    \n    vec2 cd = vec2((fragCoord.x * .5)+iResolution.x/4.,(fragCoord.y * .5)+iResolution.y/4.);    \n    \n    vec3 col = vec3(0.);\n    vec4 d1 = texture(iChannel0,cd/iResolution.xy);\n   \n    \n    vec3 newOrigin = rayOrgin + rayDirection * (d1.x*DEPTMAPDIVIDER);\n    \n    vec2 d = RayMarch(newOrigin, rayDirection) + (d1.x*DEPTMAPDIVIDER);\n    \n    // So much to do here other than just save it as black and white image and then use just the x channel\n    col = vec3(d.x/DEPTMAPDIVIDER);    \n    fragColor = vec4(col,1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}