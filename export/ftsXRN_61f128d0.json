{"ver":"0.1","info":{"id":"ftsXRN","date":"1626791400","viewed":145,"name":"Sound Tunnel Trip","username":"gabor","description":"Old school tunnel, synth and tune meet modern GPUs.","likes":8,"published":1,"flags":8,"usePreview":0,"tags":["tunnel","raymarch","soundsynth"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEP 100\n#define MAX_DISTANCE 30.0\n#define MIN_DISTANCE 0.002\n\n#define FX_MOVE .02\n#define FX_SHAPE .01\n#define FX_BOUNCE .01\n#define FX_BLINK 100.\n#define FX_SHAKE .03\n#define FX_FLY .3\n\nvec3 ambientColor = vec3(.15, .17, .21);\nfloat aspect = 0.;\nvec3 lightPos = vec3(.0, .0, .5);\n\nvec3 kd;\nvec3 sn;\nvec3 pt1;\nvec2 pt2;\nvec4 pt3;\n\nmat2 rotate(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\nfloat hash11(float p) {\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= 2.*p;\n    return fract(p);\n}\n\nfloat hash21(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise(vec2 p) {\n    vec2 p2 = vec2(1.-p.x, p.y);\n    float smp =  .57 * texture(iChannel0, .5*p).x;\n          smp += .43 * texture(iChannel0, 2.*p+.1).x;\n    return smp/256.;\n}\n\nfloat sdTunnel(vec3 p, float r) {\n    return r - length(p.xy);\n}\n\nfloat sdSphere(vec3 p, float s) {\n  return length(p)-s;\n}\n\nvec2 getDistance(vec3 p) {\n    vec2 tn = vec2(sdTunnel(p, 0.1), 1.);\n    float angle = atan(p.y, p.x) + PI;\n    float dh = noise(vec2(angle/PI2, p.z));\n    tn += dh*(.5 + FX_BOUNCE*kd.z);\n    tn += FX_SHAPE*sin(floor(hash11(pt2.x)*9.)*angle + 0.*iTime);\n    return tn;\n}\n\nvec2 castRay(vec3 ro, vec3 rd) {\n    vec2 res = vec2(0);\n    for (int i=0; i<MAX_STEP; i++) {\n        vec3 p = ro + res.x*rd;\n        vec2 ds = getDistance(p);\n        res.x += ds.x;\n        res.y = ds.y;\n        if (res.x > MAX_DISTANCE || ds.x < MIN_DISTANCE) break;\n    }\n    return res;\n}\n\nvec3 getNormal(vec3 p, float d) {\n    vec3 v = vec3(MIN_DISTANCE, .0, .0);\n    return normalize(vec3(\n        d - getDistance(p - v.xyy).x,\n        d - getDistance(p - v.yxy).x,\n        d - getDistance(p - v.yyx).x\n    ));\n}\n\nvec3 getLight(vec3 p, vec3 matCol, vec3 lightPos, vec3 lightCol, vec2 lightDamping) {\n    vec3 col = vec3(.0);\n    vec2 dm = getDistance(p);\n    if (dm.x < MAX_DISTANCE) {\n        int mat = int(dm.y);\n        // diffuse\n        vec3 n = getNormal(p, dm.x);\n        vec3 l = normalize(lightPos - p);\n        float diff = clamp(dot(l, n), 0., 1.);\n        vec3 diffColor = clamp(vec3(lightCol) * .2 * diff, .0, 1.);\n        // specular\n        vec3 lightReflect = reflect(-l, n);\n\n        float sf = max(dot(normalize(p), lightReflect), .0);\n        float spec = pow(sf, 24.);\n        vec3 specColor = vec3(lightCol * .8 * spec);\n        float fallOff = lightDamping.x * pow(12.*distance(p, lightPos), lightDamping.y);\n        col = matCol * fallOff * clamp(diffColor + specColor, .0, 1.);\n    }\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    kd = kdBeat(iTime);\n    sn = snBeat(iTime);\n    pt1 = pattern1(iTime);\n    pt2 = pattern2(iTime);\n    pt3 = pattern3(iTime);\n\n    aspect = iResolution.x/iResolution.y;\n    float qm = pow(mask(iTime, .9), 1.8);\n    vec2 uv = floor((fragCoord - .5*iResolution.xy)*qm)/qm/iResolution.y;\n    vec3 ro = vec3(.0, .0, .0);\n    ro.x += aspect*FX_MOVE*cos(T*.3*iTime + FX_SHAKE*texture(iChannel0, ro.xy).x*sn.z);\n    ro.y += FX_MOVE*sin(T*.5*iTime + FX_SHAKE*texture(iChannel0, ro.yz).x*sn.z);\n    ro.z += 1. + FX_FLY*(0.1 + 0.9*pt1.y) * iTime - .4*FX_BOUNCE*kd.z;\n\n    vec3 rt = vec3(uv.x, uv.y, 1.);\n    rt.xy *= rotate(FX_SHAKE*.5*pt3.z/64.);\n    vec3 rd = normalize(rt);\n\n    lightPos.z = -.02 + ro.z + 1.*kd.x*TICK;\n\n    vec2 ds = castRay(ro, rd);\n    float d = ds.x;\n    vec3 p = ro + d*rd;\n\n    vec3 lc = vec3(.3, .8, .2);\n    vec3 mat = vec3(.5 + nsin(T16*p.z*pt1.y, .2, 1.));\n    \n    if (ds.y == 2.) mat = lc;\n    vec3 col = ambientColor;\n         col += getLight(p, mat, vec3(.0, .0, -.1+ro.z), vec3(.72, .65, .5), vec2(5.5, -2.11));\n         col += getLight(p, mat, vec3(.0, .0, 9.+ro.z), vec3(.8, .8, .7)*sn.z, vec2(FX_BLINK, -1.5));\n         col += getLight(p, mat, lightPos, lc, vec2((1.2 + 8.*kd.y), -3.1));\n\n    //col *= pow(clamp(.02*MAX_DISTANCE/d, .0, 1.), .4);\n    \n    fragColor = fadeInOut(iTime)*vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define LOW_C 16.351597831287414\n\n// misc.\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= 2.*p;\n    return fract(p);\n}\n\nfloat hash21(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat p2f(float pitch) {\n    return step(0., pitch) * pow(pow(2., 1./12.), pitch) * LOW_C;\n}\n\n\n// effects\nfloat dist(float smp, float gain) {\n    return clamp(smp, -gain, gain)/gain;\n}\n\nvec2 dist(vec2 smp, float gain) {\n    return clamp(smp, -gain, gain)/gain;\n}\n\nfloat quant(float smp, float aLvl) {\n    return floor(smp*aLvl)/aLvl;\n}\n\nvec2 quant(vec2 smp, float aLvl) {\n\n    return floor(smp*aLvl)/aLvl;\n}\n\n// generators\nfloat kick(float time) {\n    float t = fract(TICK*time);\n    float beat = kdBeat(time).y;\n    float fm = 19.*pow(.06 + t, .247);\n\tfloat am = beat*env(t, vec4(.0, .5, .5, .4));\n    float s = am*sin(fm * PI2);\n    return dist(s, .5 );\n}\n\nfloat snare(float time) {\n    float t = fract(TICK*time);\n    vec3 beat = snBeat(time);\n    float fm = beat.x*pow(2.1 + t, .275);\n\tfloat am = beat.y*env(t, vec4(.1, .2, .6, .6));\n    float s = am*am*(sin(fm * PI2) + sin(1.5 * fm * PI2));\n    float n = am*hash11(31.*fm);\n    return dist(mix(s, n, .3), .3);\n}\n\nfloat hihat(float time) {\n    float t = fract(TICK*time);\n    vec3 beat = hhBeat(time);\n    float fm = pow(851. + 4.*t, 1.6);\n\tfloat am = beat.y*env(t, vec4(.01, .5*beat.z, .4+.5*beat.z, .2 + .2*beat.z));\n    float s = sin(fm * PI2) + sin(1.5 * fm * PI2);\n    return am*am*s;\n}\n\nfloat sampleHihat(float time) {\n    float td2 = .6*iSampleRate;\n    float td1 = .9*td2;\n    float t1 = floor(time*td1)/td1;\n    float t2 = floor(time*td2)/td2;\n    float smp1 = hihat(t1);\n    float smp2 = hihat(t2);\n    return dist(smp2 - smp1, .6);\n}\n\nfloat synth(float time, vec4 en, vec2 n, float m) {\n    float t = fract(TICK*time);\n    float e = n.y*env(t, en);\n    float w = .45 *(1. - .05*e);\n    float fm = fract(p2f(n.x)*time);\n    float pls = 1.-step(w, fm);\n\tfloat saw = pls * fract(fm/w);\n    return e*mix(saw, pls, m);\n}\n\nfloat sampleSynth(float time, vec4 en, vec2 n, float m, float td, float sm) {\n    float t = floor(time*td)/td;\n    return mix(synth(time, en, n, m), synth(t, en, n, m), sm);\n}\n\nfloat mono(float time, float sm) {\n    vec3 n = pattern1(time);\n    float td = nsin(T/64.*PI2*time, 10000., 12000.);\n    float smp = sampleSynth(time, vec4(.01, .4, .4, .5), n.xy, .2, td, sm);\n    return dist(smp, .7);\n}\n\nfloat bass(float time) {\n    vec2 n = pattern2(time);\n    float smp = sampleSynth(time, vec4(.1, .3, .6, .5), n, .6, 8000., .8);\n    return dist(smp, .8);\n}\n\nfloat synth1(float time) {\n    vec4 n = pattern3(time);\n    //n -= vec4(.0, vec3(0,12,12));\n    \n    float t = fract(.5*TICK*time);\n    float e = n.x*env(t, vec4(.001, .1, .4, .6));\n    float w = (1. - .2*e) * nsin(time, .3, .5);\n    // voice 1\n    float fm = fract(p2f(n.y)*time);\n    float pls = 1.-step(w, fm);\n    float smp = pls*fract(fm/w);\n    // voice2\n    fm = fract(p2f(n.z+12.0)*time);\n    pls = 1.-step(w, fm);\n    smp += pls* fract(fm/w);\n    // voice3\n    fm = fract(p2f(n.w+12.0)*time);\n    pls = 1.-step(w, fm);\n    smp += pls* fract(fm/w);\n    return e*smp;\n}\n\nfloat sampleSynth1(float time, float td, float sm) {\n    float t = floor(time*td)/td;\n    float h = nsin(PI2*td/iSampleRate, 1.-sm, sm);\n    return mix(synth1(time), synth1(t), h);\n}\n\nvec2 chords(float time) {\n    float td = nsin(T*time, 8000., 24000.);\n    float s1 = sampleSynth1(time, td, .6);\n    float s2 = sampleSynth1(time - 3./TICK, td, .6);\n    float s3 = sampleSynth1(time - 6./TICK, td, .5);\n    float s4 = sampleSynth1(time - 9./TICK, td, .4);\n    return vec2(\n        s1 + .4*s2 + .05*s3 + .07*s4,\n        s1 + .1*s2 + .2*s3 + .07*s4\n    );\n}\n\nvec2 allSound(float time )\n{\n    // panning\n    vec4 pan1 = vec4(.4, .5, .8, .45);\n    vec4 pan2 = vec4(.4, .0, .4, .0);\n    // master mix\n    vec2 ch1 = .4*vec2(snare(time), snare(time-.01));\n    vec2 ch2 = .3*vec2(kick(time), kick(time-.0001));\n    vec2 ch3 = .2*vec2(mono(time, 0.6), mono(time-.03, .2));\n    vec2 ch4 = .4*vec2(bass(time), bass(time-.01));\n    vec4 ch5 = .2*vec4(chords(time), chords(time-.02));\n    vec2 ch6 = .3*vec2(sampleHihat(time), sampleHihat(time-.02));\n\n    vec4 left1 = vec4(ch1.x, ch2.x, ch3.x, ch4.x);\n    vec4 right1 = vec4(ch1.y, ch2.y, ch3.y, ch4.y);\n    \n    vec4 left2 = vec4(ch5.x, ch5.z, ch6.x, .0);\n    vec4 right2 = vec4(ch5.y, ch5.w, ch6.y, .0);\n    \n    vec2 final = vec2(dot(left1, pan1), dot(right1, 1.-pan1));\n         final += vec2(dot(left2, pan2), dot(right2, 1.-pan2));\n         \n         final = quant(final, 65536.);\n\n    return clamp(2.*final, -.8, .8);\n}\n\nvec2 sampleAll(float td, float time) {\n    float t = floor(time*td)/td;\n    return allSound(t);\n}\n\nvec2 mainSound(int samp, float time) {\n    //return allSound(time);\n    float m = pow(mask(time, .96), 1.2);\n    return fadeInOut(time)*sampleAll(iSampleRate*m, time);\n}","name":"Sound","description":"","type":"sound"},{"inputs":[],"outputs":[],"code":"#define PI 3.1415926535897932384626433832795\n#define PI2 6.283185307179586476925286766559\n#define BPM 127.\n#define T (BPM/60.)\n#define TICK (T*4.)\n#define T16 (T/4.)\n\n#define P1 12.\n#define P2 15.\n#define P3 16.\n#define P4 17.\n#define END 60.\n\n#define pC   36\n#define pCis 37\n#define pD   38\n#define pDis 39\n#define pE   40\n#define pF   41\n#define pFis 42\n#define pG   43\n#define pGis 44\n#define pA   45\n#define pAis 46\n#define pH   47\n\n#define Dmoll  vec3(pD, pF, pA)\n#define Amoll6 vec3(pC, pE, pA)\n#define Gdur6  vec3(pH, pD, pG)\n#define Cdur   vec3(pC, pE, pG)\n\n\n\n#define nsin(th, a, dc) dc + a * sin(th)\n\nfloat env(float t, vec4 adsr) {\n    float x = fract(t*TICK);\n    float y = smoothstep(.0, adsr.x, t);\n    float g1 = adsr.x;\n    float g2 = g1 + adsr.y;\n    y = min(y, (smoothstep(g2, g1, t)  * (1.-adsr.z) + adsr.z));\n    g1 = g2;\n    g2 += adsr.w;\n    y *= smoothstep(g2, g1, t);\n    return y;\n}\n\nvec3 snBeat(float time) {\n    vec3 n = vec3(0);\n    \n    if (time*T16 > 4.)\n    {\n    \n    float steps = 16.;\n    float t = fract(time*TICK/steps);\n    float st = 1./steps;\n    float s = 0.;\n\n    n  = (1.-step(0.5*st, abs(t - (s + .5)*st))) * vec3(117.0, 0.1, .0); s++;\n    n += (1.-step(0.5*st, abs(t - (s + .5)*st))) * vec3(117.0, 0.0, .0); s++;\n    n += (1.-step(0.5*st, abs(t - (s + .7)*st))) * vec3(127.0, 0.1, .0); s++;\n    n += (1.-step(0.5*st, abs(t - (s + .3)*st))) * vec3(117.0, 0.0, .0); s++;\n    \n    n += (1.-step(0.5*st, abs(t - (s + .5)*st))) * vec3( 24.0, 1.2, .0); s++;\n    n += (1.-step(0.5*st, abs(t - (s + .5)*st))) * vec3(117.0, 0.0, .0); s++;\n    n += (1.-step(0.5*st, abs(t - (s + .7)*st))) * vec3( 27.0, 0.1, .0); s++;\n    n += (1.-step(0.5*st, abs(t - (s + .3)*st))) * vec3(117.0, 0.0, .0); s++;\n    \n    n += (1.-step(0.5*st, abs(t - (s + .5)*st))) * vec3(117.0, 0.0, .0); s++;\n    n += (1.-step(0.5*st, abs(t - (s + .5)*st))) * vec3(117.0, 0.2, .0); s++;\n    n += (1.-step(0.5*st, abs(t - (s + .7)*st))) * vec3(127.0, 0.1, .0); s++;\n    n += (1.-step(0.5*st, abs(t - (s + .3)*st))) * vec3( 17.0, 0.1, .0); s++;\n\n    n += (1.-step(0.5*st, abs(t - (s + .5)*st))) * vec3( 24.0, 1.2, .0); s++;\n    n += (1.-step(0.5*st, abs(t - (s + .5)*st))) * vec3(117.0, 0.0, .0); s++;\n    n += (1.-step(0.5*st, abs(t - (s + .7)*st))) * vec3( 27.0, 0.1, .0); s++;\n    n += (1.-step(0.5*st, abs(t - (s + .3)*st))) * vec3(117.0, 0.0, .0); s++;\n    }\n    n.z = n.y*time;\n    return 1.0*n;\n}\n\nvec3 kdBeat(float time) {\n    vec3 n = vec3(0);\n  \n    float pt = time*T16;\n    \n    if (pt < 12. || pt > 16. && pt < 40. || pt > 44.) {\n    \n    float steps = 32.;\n    float t = fract(time*TICK/steps);\n    float st = 1./steps;\n\n    n  = (1.-step(0.5*st, abs(t - ( 0. + .5)*st))) * vec3(1.);\n    n += (1.-step(0.5*st, abs(t - ( 4. + .5)*st))) * vec3(1.);\n    n += (1.-step(0.5*st, abs(t - ( 8. + .5)*st))) * vec3(1.);\n    n += (1.-step(0.5*st, abs(t - (12. + .5)*st))) * vec3(1.);\n    n += (1.-step(0.5*st, abs(t - (15. + .5)*st))) * vec3(1.);\n    n += (1.-step(0.5*st, abs(t - (16. + .5)*st))) * vec3(1.);\n    n += (1.-step(0.5*st, abs(t - (20. + .5)*st))) * vec3(1.);\n    n += (1.-step(0.5*st, abs(t - (24. + .5)*st))) * vec3(1.);\n    n += (1.-step(0.5*st, abs(t - (28. + .5)*st))) * vec3(1.);\n    n += (1.-step(0.5*st, abs(t - (30. + .5)*st))) * vec3(1.);\n\n    n.x = t;\n    n.z = sin(time*TICK*PI2)*n.y;\n    }\n    return 1.0*n;\n}\n\nvec3 hhBeat(float time) {\n    vec3 n = vec3(0);\n\n    float pt = time*T16;\n    \n    if (pt > 12. && pt < 28. || pt > 32.) {\n    float steps = 16.;\n    float t = fract(time*TICK/steps);\n    float st = 1./steps;\n    float s = 0.;\n\n    n  = (1.-step(0.5*st, abs(t - (s + .5)*st))) * vec3(0., .4, .2); s++;\n    n += (1.-step(0.5*st, abs(t - (s + .5)*st))) * vec3(0., .0, .0); s++;\n    n += (1.-step(0.5*st, abs(t - (s + .5)*st))) * vec3(0., .6, .6); s++;\n    n += (1.-step(0.5*st, abs(t - (s + .5)*st))) * vec3(0., .3, .1); s++;\n\n    n += (1.-step(0.5*st, abs(t - (s + .5)*st))) * vec3(0., .4, .2); s++;\n    n += (1.-step(0.5*st, abs(t - (s + .5)*st))) * vec3(0., .0, .0); s++;\n    n += (1.-step(0.5*st, abs(t - (s + .5)*st))) * vec3(0., .6, .6); s++;\n    n += (1.-step(0.5*st, abs(t - (s + .5)*st))) * vec3(0., .0, .0); s++;\n\n    n += (1.-step(0.5*st, abs(t - (s + .5)*st))) * vec3(0., .4, .2); s++;\n    n += (1.-step(0.5*st, abs(t - (s + .5)*st))) * vec3(0., .5, .2); s++;\n    n += (1.-step(0.5*st, abs(t - (s + .5)*st))) * vec3(0., .6, .8); s++;\n    n += (1.-step(0.5*st, abs(t - (s + .5)*st))) * vec3(0., .0, .0); s++;\n\n    n += (1.-step(0.5*st, abs(t - (s + .5)*st))) * vec3(0., .4, .2); s++;\n    n += (1.-step(0.5*st, abs(t - (s + .5)*st))) * vec3(0., .0, .0); s++;\n    n += (1.-step(0.5*st, abs(t - (s + .5)*st))) * vec3(0., .6, .6); s++;\n    n += (1.-step(0.5*st, abs(t - (s + .5)*st))) * vec3(0., .0, .0); s++;\n\n    n.x = t;\n    }\n    return 1.0*n;\n}\n\nvec3 pattern1(float time) {\n    vec3 n = vec3(0);\n    \n    if (time*T16 > 4.) {\n    \n    float steps = 16.;\n    float t = fract(time*TICK/steps);\n    float s = 0.;\n    float st = 1./steps;\n\n    n  = (1.-step(0.5*st, abs(t - (s + .5)*st))) * vec3(26.0, 1., .0); s++;\n    n += (1.-step(0.5*st, abs(t - (s + .5)*st))) * vec3(26.0, 1., .0); s++;\n    n += (1.-step(0.5*st, abs(t - (s + .5)*st))) * vec3(38.0, 1., .0); s++;\n    n += (1.-step(0.5*st, abs(t - (s + .5)*st))) * vec3(26.0, 1., .0); s++;\n    \n    n += (1.-step(0.5*st, abs(t - (s + .5)*st))) * vec3(29.0, 1., .0); s++;\n    n += (1.-step(0.5*st, abs(t - (s + .5)*st))) * vec3(29.0, 1., .0); s++;\n    n += (1.-step(0.5*st, abs(t - (s + .5)*st))) * vec3(41.0, 1., .0); s++;\n    n += (1.-step(0.5*st, abs(t - (s + .5)*st))) * vec3(29.0, 1., .0); s++;\n\n    n += (1.-step(0.5*st, abs(t - (s + .5)*st))) * vec3(24.0, 1., .0); s++;\n    n += (1.-step(0.5*st, abs(t - (s + .5)*st))) * vec3(24.0, 1., .0); s++;\n    n += (1.-step(0.5*st, abs(t - (s + .5)*st))) * vec3(36.0, 1., .0); s++;\n    n += (1.-step(0.5*st, abs(t - (s + .5)*st))) * vec3(24.0, 1., .0); s++;\n    \n    n += (1.-step(0.5*st, abs(t - (s + .5)*st))) * vec3(31.0, 1., .0); s++;\n    n += (1.-step(0.5*st, abs(t - (s + .5)*st))) * vec3(26.0, 1., .0); s++;\n    n += (1.-step(0.5*st, abs(t - (s + .5)*st))) * vec3(38.0, 1., .0); s++;\n    n += (1.-step(0.5*st, abs(t - (s + .5)*st))) * vec3(29.0, 1., .0); s++;\n    \n    n.z = n.y*t;\n\n    }\n\n    return 1.0*n;\n}\n\nvec2 pattern2(float time) {\n    vec2 n = vec2(0);\n    float steps = 16.;\n    float t = fract(time*TICK/steps);\n    float st = 1./steps;\n\n    n  = (1.-step(0.5*st, abs(t - ( 2. + .5)*st))) * vec2(14.0, 1.);\n    n += (1.-step(0.5*st, abs(t - ( 6. + .5)*st))) * vec2(14.0, 1.);\n    n += (1.-step(0.5*st, abs(t - (10. + .5)*st))) * vec2(14.0, 1.);\n    n += (1.-step(0.5*st, abs(t - (14. + .5)*st))) * vec2(26.0, 1.);\n    n += (1.-step(0.5*st, abs(t - (15. + .5)*st))) * vec2(14.0, 1.);\n\n    return 1.0*n;\n}\n\nvec4 pattern3(float time) {\n    vec4 n = vec4(0);\n    float steps = 64.;\n    float t = fract(time*TICK/steps);\n    float st = 1./steps;\n    float pt = time*T16;\n\n    if (pt < 8.) {\n    } else\n    if (pt < 16.) {\n        steps = 16.;\n        t = fract(time*TICK/steps);\n        st = 1./steps;\n        n  = (1.-step(0.5*st, abs(t - ( 0. + .5)*st))) * vec4(1., Dmoll);\n        n += (1.-step(0.5*st, abs(t - ( 6. + .5)*st))) * vec4(1., Dmoll);\n        //n += (1.-step(0.5*st, abs(t - (28. + .5)*st))) * vec4(1., 38., 41., 45.);\n        //n += (1.-step(0.5*st, abs(t - (30. + .5)*st))) * vec4(1., 38., 41., 45.);\n        //n += (1.-step(0.5*st, abs(t - (32. + .5)*st))) * vec4(1., 36., 40., 45.);\n\n    } else\n    if (pt < 24. || pt > 32.) {\n\n        steps = 64.;\n        t = fract(time*TICK/steps);\n        st = 1./steps;\n\n        n  = (1.-step(0.5*st, abs(t - ( 0. + .5)*st))) * vec4(1., Dmoll);\n        n += (1.-step(0.5*st, abs(t - ( 6. + .5)*st))) * vec4(1., Dmoll);\n        n += (1.-step(0.5*st, abs(t - (12. + .5)*st))) * vec4(1., Dmoll);\n        n += (1.-step(0.5*st, abs(t - (14. + .5)*st))) * vec4(1., Amoll6);\n        n += (1.-step(0.5*st, abs(t - (16. + .5)*st))) * vec4(1., Dmoll);\n        n += (1.-step(0.5*st, abs(t - (32. + .5)*st))) * vec4(1., Dmoll);\n        n += (1.-step(0.5*st, abs(t - (38. + .5)*st))) * vec4(1., Dmoll);\n        n += (1.-step(0.5*st, abs(t - (44. + .5)*st))) * vec4(1., Dmoll);\n        n += (1.-step(0.5*st, abs(t - (46. + .5)*st))) * vec4(1., Cdur);\n        n += (1.-step(0.5*st, abs(t - (48. + .5)*st))) * vec4(1., Gdur6);\n\n        n += vec4(0, 12,12,12)*(1.-step(pt, 32.));\n    }\n\n    return 1.0*n;\n}\n\nfloat mask(float time, float f) {\n    float pt = time*T16;\n\n    float m1 = (1. - 0.)/(P2 - P1);\n    float m2 = -(1. - 0.)/(P4 - P3);\n    float v = 1. - f*clamp(min(m1*(pt-P1), m2*(pt-P4)), 0., 1.);\n    return v;\n}\n\nfloat fadeInOut(float time) {\n    float pt = time*T16;\n    return min(smoothstep(0., 1., pt), smoothstep(END+8., END, pt));\n}","name":"Common","description":"","type":"common"}]}