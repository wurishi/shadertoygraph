{"ver":"0.1","info":{"id":"stlXDN","date":"1636157131","viewed":72,"name":"Sampling unit disk","username":"Envy24","description":"Sampling disk (uniform distribution).","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","random","raytrace","sampling","disk","distribution","uniform"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SCENE_SCALE               ( 1.0 )\n#define UNIT                      ( (SCENE_SCALE*3.0) / iResolution.y  )\n#define SMAA(d)                   ( smoothstep(UNIT, 0., d) )\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale + origin;\n}\n\nfloat samplesSDF(vec2 NDC, uint numOfSamples)\n{\n    float min_d = 99999999.0;\n\n    uint t = uint(1.0 + iTime * 1.1);\n\n    for (uint i = 0u; i < numOfSamples; ++i)\n    {\n        uint x = uint((i + 1u) * t * 345u);\n        uint y = uint((i + 1u) * t * 75673u);\n    \n        vec2 rand = \n            //vector2HashUI32(x, y);        // for rejection.\n            //sampleUnitDiskTreshold(x, y); // non-uniform\n            //sampleUnitDiscPolar(x, y);    // non-uniform\n            sampleUnitDiscSqrt(x, y);\n            //sampleUnitSumDist(x, y);\n            //sampleUnitMaxDist(x, y);\n            \n        // Reject?\n        //if (length(rand) > 1.0) { continue; }\n        //if (dot(rand, rand) > 1.0) { continue; }\n        \n        min_d = min(min_d, diskSDF_L2(NDC, rand, 0.005));\n    }\n    \n    return min_d;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, vec2(0), false);\n\n    vec3 color = vec3(1);\n    \n    color = mix(color, vec3(0), SMAA(abs(diskSDF_L2(NDC, vec2(0), 1.))));\n    color = mix(color, vec3(1,0,0), SMAA(samplesSDF(NDC, 512u)));\n\n    O = vec4(color, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define TO_RAD 0.017453292519943295\n#define PI 3.1415926535897932\n\n/* \n    Returns random vec2([-1.0; 1.0], [-1.0; 1.0]).\n*/\nvec2 vector2HashUI32(\n    const uint x,\n    const uint y)\n{\n    // Pick some enthropy source values.\n    // Try different values.\n    const uint enthropy0 = 123u;\n    const uint enthropy1 = 456u;\n    const uint enthropy2 = 789u;\n\n    // Use linear offset method to mix coordinates.\n    uint value0 = y * enthropy2 + x;\n    uint value1 = x * enthropy2 + y;\n\n    // Calculate hash.\n\tvalue0 += enthropy1; value0 *= 445593459u; value0 ^= enthropy0;\n    value1 += enthropy1; value1 *= 445593459u; value1 ^= enthropy0;\n    \n    // 2.0f / 4294967295.0f = 4.6566128730773926e-10\n\n    return \n        vec2(\n            float(value0 * value0 * value0) * 4.6566128730773926e-10f - 1.0f,\n            float(value1 * value1 * value1) * 4.6566128730773926e-10f - 1.0f);\n}\n\n/*\n    Returns random float=[0.0; 1.0].\n*/\nfloat golderRatioHashWithSeed(float x, float seed)\n{\n    float y = (100. + x);\n    float m = mod(1e3 * y, 11.67115450f * seed);\n    float f = fract(m * (m * y));\n    float a = (f - m) * 6.18034029f;\n\n    return fract(a * fract(a * fract(a)));\n}\n\nvec2 sampleUnitDiskTreshold(\n    const uint x,\n    const uint y)\n{\n    // Pick some enthropy source values.\n    // Try different values.\n    const uint enthropy0 = 123u;\n    const uint enthropy1 = 456u;\n    const uint enthropy2 = 789u;\n\n    // Use linear offset method to mix coordinates.\n    uint value0 = y * enthropy2 + x;\n    uint value1 = x * enthropy2 + y;\n\n    // Calculate hash.\n\tvalue0 += enthropy1; value0 *= 445593459u; value0 ^= enthropy0;\n    value1 += enthropy1; value1 *= 445593459u; value1 ^= enthropy0;\n    \n    // (2.0f * PI) / 4294967295.0f = 1.46291812e-09\n    // 1.0f / 4294967295.0f        = 2.32830644e-10 \n\n    float angle = float(value0 * value0 * value0) * 1.46291812e-09 - 3.14159274f;\n    float radius = float(value1 * value1 * value1) * 2.32830644e-10;\n\n    // Redistribute values.\n    radius = radius >= 0.80 ?\n        1.0 - radius * radius * radius * radius:\n        1.0 - radius * radius;\n\n    return \n        vec2(\n            cos(angle) * radius,\n            sin(angle) * radius);\n}\n\n// source: https://www.youtube.com/watch?v=4y_nmpv-9lI\nvec2 sampleUnitDiscPolar(\n    const uint x,\n    const uint y)\n{\n    vec2 rand = vector2HashUI32(x, y);\n    \n    // map from [-1.0; 1.0] to [0.0; 2*PI].\n    rand.y = (rand.y + 1.0) * 180.0 * TO_RAD;\n    \n    return vec2(\n        rand.x * cos(rand.y),\n        rand.x * sin(rand.y));\n}\n\n// source: https://www.youtube.com/watch?v=4y_nmpv-9lI\nvec2 sampleUnitDiscSqrt(\n    const uint x,\n    const uint y)\n{\n    vec2 rand = vector2HashUI32(x, y);\n    \n    // applying inverse of CDF.\n    rand.x = sqrt((rand.x + 1.0f) * 0.5f);\n    \n    // map from [-1.0; 1.0] to [-PI; PI].\n    rand.y *= 3.14159274f;\n    \n    return vec2(\n        rand.x * cos(rand.y),\n        rand.x * sin(rand.y));\n}\n\n// source: https://www.youtube.com/watch?v=4y_nmpv-9lI\nvec2 sampleUnitSumDist(\n    const uint x,\n    const uint y)\n{\n    vec2 rand = vector2HashUI32(x, y);\n    vec2 rand2 = vector2HashUI32(x + 1u, y - 1u);\n\n    rand.x = (2.0 + rand.x + rand2.x) * 0.5;\n    rand.x = rand.x >= 1.0 ? 2.0 - rand.x : rand.x;\n    \n    // map from [-1.0; 1.0] to [-PI; PI].\n    rand.y *= 3.14159274f;\n    \n    return vec2(\n        rand.x * cos(rand.y),\n        rand.x * sin(rand.y));\n}\n\n// source: https://www.youtube.com/watch?v=4y_nmpv-9lI\nvec2 sampleUnitMaxDist(\n    const uint x,\n    const uint y)\n{\n    float theta = golderRatioHashWithSeed(float(x), 123.3);\n    float r = golderRatioHashWithSeed(float(y), 0.42343);\n    float t = golderRatioHashWithSeed(float((x + y * y) * 2944u), 812.0);\n\n    r = t > r ? t : r;\n    \n    // map from [-1.0; 1.0] to [0.0; 2.0*PI].\n    theta *= 2.0 * 3.14159274f;\n    \n    return vec2(\n        r * cos(theta),\n        r * sin(theta));\n}\n\nfloat diskSDF_L2(in vec2 NDC, in vec2 C, in float r) { return length(C - NDC)-r; }","name":"Common","description":"","type":"common"}]}