{"ver":"0.1","info":{"id":"4fVGzy","date":"1723408626","viewed":42,"name":"Clouds#9999","username":"vonnie","description":"clouds test https://blog.maximeheckel.com/posts/real-time-cloudscapes-with-volumetric-raymarching/","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["volumetricraymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float MD = 0.002;\nconst int MC = 100;\nconst float SD = 0.06;\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nmat2 rot2D(float angle)\n{\n\tangle *= 3.15 / 180.0;\n    float sine = sin(angle), cosine = cos(angle);\n    return mat2( cosine, -sine, \n                 sine,    cosine );\n}\n\n\nfloat noise(vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\n\nfloat fbm(vec3 p) {\n  vec3 q = p + iTime * 0.5 * vec3(1.0, -0.2, -1.0);\n  float g = noise(q);\n\n  float f = 0.0;\n  float scale = 0.5;\n  float factor = 2.02;\n\n  for (int i = 0; i < 6; i++) {\n      f += scale * noise(q);\n      q *= factor;\n      factor += 0.21;\n      scale *= 0.5;\n  }\n\n  return f;\n}\n\n\nfloat Sphere(vec3 raypos, vec3 pos, float radius){\n    return length(raypos - pos) - radius;\n}\n\nfloat scene(vec3 pos){\n    float sphere = Sphere(pos, vec3(0., 0., 0.), 1.);\n\n    return -pos.y - 1. + fbm(pos)*1.5;\n}\n\nvec4 volumetricMarch(vec3 ro, vec3 rd, vec3 sunPos){\n    vec4 res = vec4(0.);\n    float depth = 0.;\n    \n    vec3 sunDir = normalize(sunPos);\n    for(int i = 0; i < 100; i++){\n        vec3 pos = ro + rd * depth;\n\n        float density = scene(pos);\n        \n        if(density > 0.){\n            //inside the cloud\n           \n            //res += density;\n            float diffuse = clamp((scene(pos) - scene(pos + 0.3 * sunDir)) / 0.3, 0.0, 1.0 );\n            vec3 lin = vec3(0.60,0.60,0.75) * 1.1 + 0.8 * vec3(1.0,0.6,0.3) * diffuse;\n\n            vec4 color = vec4(mix(vec3(1.0,1.0,1.0), vec3(0.0, 0.0, 0.0), density), density );\n            color.rgb *= color.a * lin;\n            res += color * (1.0 - res.a);\n        }\n        //if(i < 2) depth += abs(density);\n        depth += SD;\n    }\n    \n    return res;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2. - iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy)/iResolution.xy-.5;\n    \n\n    vec3 ro = vec3(mouse.x*2., mouse.y*2., -6);\n    vec3 rd = normalize(vec3(uv.xy, 1));\n    rd.xz *= rot2D(mouse.x*100.);\n    rd.yz *= rot2D(mouse.y*100.);\n\n    vec3 sunPos = vec3(4.,4.,10.);\n    \n    vec3 col = vec3(0.9,0.7,0.30)*0.4;\n    col -= 0.8 * vec3(0.9,0.75,0.30) * rd.y;\n    vec4 res = volumetricMarch(ro, rd, sunPos);\n    col = (1.-col) * (1.-res.a) + res.rgb;\n\n\n    fragColor = vec4(col, 1.);\n}\n","name":"Image","description":"","type":"image"}]}