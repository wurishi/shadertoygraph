{"ver":"0.1","info":{"id":"MclGDs","date":"1703702516","viewed":43,"name":"sphere and softun","username":"nayk","description":"colorful, soft,neon, stars, 3d, noise, swirl, curl, domainwarping","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","noise","swirl","colorful","curl","stars","soft","neon","domainwarping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* originals  https://www.shadertoy.com/view/DtGyWh https://www.shadertoy.com/view/DsKyRh*/\n#define iterations 10\n#define flowintensity 1.0\n#define numOctaves 2\n#define flowoffset 1.0\n\n\n\n\n\nfloat hash( ivec3 p )    // this hash is not production ready, please\n{                        // replace this by something better\n\n    // 3D -> 1D\n    int n = p.x*3 + p.y*113 + p.z*311;\n\n    // 1D hash by Hugo Elias\n\tn = (n << 13) ^ n;\n    n = n * (n * n * 15731 + 789221) + 1376312589;\n    return -1.0+2.0*float( n & 0x0fffffff)/float(0x0fffffff);\n}\n\nvec4 noised( in vec3 x )\n{\n    ivec3 i = ivec3(floor(x));\n    vec3 w = fract(x);\n    \n    // cubic interpolation\n    vec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w); \n    \n    float a = hash(i+ivec3(0,0,0));\n    float b = hash(i+ivec3(1,0,0));\n    float c = hash(i+ivec3(0,1,0));\n    float d = hash(i+ivec3(1,1,0));\n    float e = hash(i+ivec3(0,0,1));\n\tfloat f = hash(i+ivec3(1,0,1));\n    float g = hash(i+ivec3(0,1,1));\n    float h = hash(i+ivec3(1,1,1));\n    \n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, \n                 du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\n                            k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\n                            k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\n}\n\nvec4 fbm( vec3 x )\n{    \n    float G = exp2(-1.);\n    float f = 1.0;\n    float a = 1.0;\n    vec4 t;\n    for( int i=0; i<numOctaves; i++ )\n    {\n        t += a*noised(x * f);\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}\n\n\n//MY LIL FUNCTION TO MAKE SWIRLY NOISE :)))\n//Subtract original position by the cross product of the noise derivative and the surface normal\n//More iterations is smoother\n\nfloat curl(vec3 p, vec3 n)\n{\n    for(int i=0; i<iterations; i++)\n    {\n        vec3 x = p + flowoffset;\n        vec3 g = cross(fbm(x).yzw, n);\n        p -= (flowintensity / float(iterations)) * g;\n    }\n    \n    //Plug warped coordinates back into the fbm (or any other 3d function)\n    //AND BOOM, SWIRLS\n    //Remap from [-1, 1] to [0, 1] range\n    return (fbm(p).x + 1.0) / 2.0;\n}\n#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*0.3+cos(iTime*0.1)+vec3(15,20,32))*.55+.5)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p2 = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n\nvec2 m = (.5 * iResolution.xy - iMouse.xy) / iResolution.x * 6.28;\n\n    vec3 e = vec3(cos(iTime) * cos(iTime), sin(iTime) * cos(iTime), sin(iTime));\n    vec3 u = normalize(vec3(e.y, -e.x, 0));\n    vec3 v = cross(e, u);\n   \n\tvec2 cPos = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    \n  \n\tfloat cLength = length(cPos);\n\n\t\n\n    vec3 d3 = e + p2.x * u + p2.y * v;\n    \n    vec3 a2 = (e + .1) / d3;\n    vec3 b2 = (e - .1) / d3;\n    float mi = max(max(min(a2.x, b2.x), min(a2.y, b2.y)), min(a2.z, b2.z));\n    float ma = min(min(max(a2.x, b2.x), max(a2.y, b2.y)), max(a2.z, b2.z));\n    float t2 = mi < ma ? mi : 10.;\n    vec3 i2 = e - d3 * t2;\n       \n\t\n    vec3 c2 = (step(-.099, i2) + step(.099, i2) - 1.)+d3; \n     // camera movement\t\n\tfloat an = 0.5*iTime;\n\tvec3 ro = vec3( 2.5*cos(an), 1.0, 2.5*sin(an) );\n    vec3 ta = vec3( 0.0, 1.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p2.x*uu + p2.y*vv + 1.5*ww );\n\n    // sphere center\t\n\tvec3 sc = vec3(0.0,1.0,0.0);\n\n    // raytrace\n\tfloat tmin = 10000.0;\n\tvec3  nor = vec3(0.0);\n\tfloat occ = 1.0;\n\tvec3  pos = vec3(0.0);\n\t\n\t// raytrace-plane\n\tfloat h = (0.0-ro.y)/rd.y;\n\tif( h>0.0 ) \n\t{ \n\t\ttmin = h; \n\t\tnor = vec3(0.0,1.0,0.0); \n\t\tpos = ro + h*rd;\n\t\tvec3 di = sc - pos;\n\t\tfloat l = length(di);\n\t\tocc = 1.0 - dot(nor,di/l)*1.0*1.0/(l*l); \n\t}\n\n\t// raytrace-sphere\n\tvec3  ce = ro - sc;\n\tfloat b = dot( rd, ce );\n\tfloat c = dot( ce, ce ) - 1.0;\n\th = b*b - c;\n\tif( h>0.0 )\n\t{\n\t\th = -b - sqrt(h);\n\t\tif( h<tmin ) \n\t\t{ \n\t\t\ttmin=h; \n\t\t\tnor = normalize(ro+h*rd-sc)*c2; \n\t\t\tocc = 0.5 + 0.5*nor.y;\n\t\t}\n\t}\n\n    // shading/lighting\t\n\tvec3 col = vec3(0.9);\n    \n    if( tmin<100.0 )\n\t{\n\t    pos = ro + tmin*rd+t2;\n\t    float f = 0.0;\n\t\t\n        f = curl(pos * 10.f, normalize(nor));\n        \n        f *= occ;\n\t\tcol = vec3(f*1.2);\n\t\tcol = mix( col, vec3(0.9), 1.0-exp( -0.003*tmin*tmin ) );\n\t}\n    vec4 O =fragColor;\nvec2 C = fragCoord ;\n    O=vec4(0);\n    vec3 p,q,r=iResolution,\n    d=normalize(vec3((C*2.-r.xy)/r.y,1));  \n    for(float i=0.,a,s,e,g=0.;\n        ++i<110.;\n        O.xyz+=mix(vec3(1),H(g*.1),sin(.8))*1./e/8e3\n    )\n    {\n        p=g*d;\n        p.z+=iTime*0.05;\n        \n        a=30.;\n        p=mod(p-a,a*2.)-a;\n        s=6.;\n        p.xy*=mat2(cos(iTime*0.37),sin(iTime*0.37),-sin(iTime*0.37),cos(iTime*0.37));\n                \n        for(int i=0;i++<8;){\n            p=.13-abs(p);\n            \n            p.x<p.z?p=p.zyx:p;\n            p.z<p.y?p=p.xzy:p;\n            p.y<p.x?p=p.zyx:p;\n            \n            s*=e=1.4+sin(iTime*.234)*.1;\n            p=abs(p)*e-\n                vec3(\n                    2.+cos(iTime*.3+.5*cos(iTime*.3))*3.,\n                   150.001,\n                    1.+cos(iTime*.5)*1.\n                 )+col;\n         }\n       //  g+=e=length(p.yz)/s;\n         g+=e=length(p.yx)/s;\n    }\n    col = sqrt(col);\n\n\t\n\tfragColor = vec4( O.xyz, 1.0 );\n}","name":"Image","description":"","type":"image"}]}