{"ver":"0.1","info":{"id":"dtfXWf","date":"1675426040","viewed":78,"name":"Fun_Electro_v2","username":"Sephisis","description":"ouè la rue","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["v2"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGzn","filepath":"/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3","previewfilepath":"/media/ap/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//blur glow buffer\n\nconst int samples = 35,\n          LOD = 2,         // gaussian done on MIPmap at scale LOD\n          sLOD = 1 << LOD; // tile size = 2^LOD\nconst float sigma = float(samples) * .25;\n\nfloat gaussian(vec2 i) {\n    return exp( -.5* dot(i/=sigma,i) ) / ( 6.28 * sigma*sigma );\n}\n\nvec4 blur(sampler2D sp, vec2 U, vec2 scale) {\n    vec4 O = vec4(0);  \n    int s = samples/sLOD;\n    \n    for ( int i = 0; i < s*s; i++ ) {\n        vec2 d = vec2(i%s, i/s)*float(sLOD) - float(samples)/2.;\n        O += gaussian(d) * textureLod( sp, U + scale * d , float(LOD) );\n    }\n    \n    return O / O.a;\n}\n\n                 \n\n\n// creation de nos fonctions pour les booleans entre la sphere et la box\n\nvec3 opRep(vec3 p, vec3 c)\n{\n    return mod(p+0.5*c, c) - 0.5 * c;\n}\n\nvec2 rot(vec2 st, float a)\n{\n    return st * mat2(cos(a), -sin(a),\n                    sin(a), cos(a));\n}\n\nfloat SDF(vec3 p)\n{\n    p = opRep(p, vec3(4.));\n    return length(p)-1.0;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n    \nfloat opSmoothUnion1( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(-1.0-h); }\n\n//creation Torus sphere cube\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n//creation cube , sphere et cone SDF 3D - bolean et couleur\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d)\n{\n    return a + b*cos(6.28318 *(c*t+d));\n}\n\nfloat map(vec3 pos) {\n    float v = 0.0;\n    float v1 = 0.0;\n    \n    vec3 blue = vec3(0.15,0.2,0.7);\n    vec3 green = sin(fract((iTime*0.5)-vec3(0.1,0.7,0.3)));\n    vec3 mixC = mix(blue, green, 5.0);\n    \n    vec3 sp1 = pos + vec3(3.0, 0.0, 0.0);\n    vec3 sp2 = pos + vec3(-3.0, 0.0, 0.0);\n    vec3 sp3 = pos + vec3(3.0, 0.2, 0.0);\n    vec3 sp4 = pos + vec3(3.0, 0.3, 0.1);\n    \n    vec3 cubePos = pos * (blue*3.8);\n    cubePos.x += sin(pos.y+iTime);\n    float timeSpeed = v+0.00025*(iTime);\n    \n    vec3 torusPos = pos;\n    torusPos.x += sin(pos.y+iTime);\n   \n    \n    \n    float cube = sdBox(cubePos, vec3(1.0, 5.5, 5.0));\n    float sphere = sdSphere(pos+vec3(0.0, timeSpeed-1.0, 0.0), 1.0);\n    float torus = sdTorus(vec3(1.2,5.8,5.0), vec2(0.2,0.8));\n    float capsule = sdCapsule(pos+vec3(3.0, 0.0, 0.0), vec3 (1.0,1.0,1.0), vec3 (1.0,1.0,1.0), float(1.0));\n    \n    \n    \n    \n    v = sdSphere(sp1, 3.0);\n    v = sdSphere(sp3, 3.0);\n    v = sdSphere(sp4, 3.0);\n    v = sdCapsule(pos+vec3(3.0, 0.0, 0.0), vec3 (1.0,1.0,1.0), vec3 (1.0,1.0,1.0), float(1.0));\n    \n    v = mix(sdCapsule(pos+vec3(3.0, 0.0, 0.0), vec3 (1.0,1.0,1.0), vec3 (1.0,1.0,1.0), float(1.0)), sdBox(pos, vec3(3.0)), sin(iTime) / opSmoothUnion(cube, capsule, 0.2) / opSmoothUnion(sphere, capsule, 25.8)+0.25);\n    //v = sdCapsule(pos+vec3(3.0, 0.0, 0.0), vec3 (1.0,1.0,1.0), vec3 (1.0,1.0,1.0), float(1.0));\n    //v = opSmoothUnion(cube, sphere, 0.5) + 0.25;\n \n    \n    return v;\n    \n}\n\n\n//Le cast ray, détection de profondeur par marche, à partir de rayon si colision = contact = surface\n\nfloat CastRay(vec3 ro, vec3 rd)  \n{\n    float contact = 0.0;\n    \n    for(int i=0; i<64; i++)\n    {\n        float ray = map(ro + rd * contact); // TODO\n        \n        if(ray < (0.0001*contact))\n        {\n            //return contact;\n            return float(i)/32.;\n        }\n        \n        contact += ray;\n    }\n    \n    return -1.0;\n}\n\n\n// creation de nos normal\n\n\nvec3 getnorm(vec3 p)\n{\n    vec2 eps = vec2(0.001,0.);\n    return normalize(map(p)-vec3(\n    map(p-eps.xyy),\n    map(p-eps.yxy),\n    map(p-eps.yyx)));\n}\n\n// le rendu 3d en appelant notre fonction cast ray + mise ne place des lights, de notre materiaux à partir des normal\n\nvec3 render(vec3 ro, vec3 rd) \n{\n    float contact = CastRay(ro, rd);\n    \n    vec3 col = vec3(0.0);\n    col = palette(col.x * sin(0.3), vec3(0.5), vec3(0.5), vec3(1.0), vec3(0.0));\n    \n    if(contact == -1.0)\n    {\n        col = vec3(0.0);\n    }\n    else\n    {\n        \n        vec3 lightPos = vec3(sin(iTime)*5500.0, 8.0, -10.0);\n        vec3 lightTar = vec3(0.0);\n        vec3 lightDir = normalize(lightPos - lightTar);\n        vec3 nor = getnorm(ro + rd * contact);\n        \n        float lambert = dot(nor, lightDir);\n        float toon = step(lambert, 0.5);\n        float stoon = smoothstep(lambert, 0.6, 0.5);\n        \n        float fresnel = dot(nor, rd);\n        \n       // col = vec3(1.0);\n       //col = vec3(1.0-contact);\n       col = vec3(0.5,0.0,0.0) * (lambert) + pow(lambert, 0.64) + fresnel + 0.5;\n       col = palette(col.x, vec3(0.5), vec3(0.8), vec3(0.8, 0.6, 0.4), vec3(0.00, 0.15, 0.20));\n       //col = vec3(0.5,0.0,0.0) + fresnel;\n    }\n    \n    return col;\n}\n\n// set de la camera et affichage du fragment color\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0 * fragCoord/iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // texture\n    \n    vec3 t= texture(iChannel0, uv).xyz;\n    \n    //camera\n    \n    \n    vec3 cameraPos = vec3(0.0, 4.0, -8.0);\n    vec3 cameraTar = vec3(0.0, 0.0, 0.0);\n    \n    cameraPos.xz = rot(cameraPos.xz, iTime);\n    \n    vec3 forward = normalize(cameraTar - cameraPos);\n    vec3 right = normalize(cross(vec3(0.0, -1.0, 0.0), forward));\n    vec3 up = normalize(cross(right, forward));\n    vec3 viewDir = normalize(uv.x * right + uv.y * up + 2.0 * forward);\n\n    \n    //color en fonction du temps dans une range entre le bleu et le vert\n    \n    vec3 blue = vec3(0.15,0.2,0.7);\n    vec3 green = sin(fract((iTime*0.1)-vec3(0.1,0.7,0.3)));\n    vec3 mixC = mix(blue, green, 0.5);\n    \n\n    vec3 col = t + pow(blur(iChannel0, uv, 1.0/iChannelResolution[0].xy).x, 0.001)* 2.8 * (render(cameraPos, viewDir) + mixC*0.2) * 3.2;\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}