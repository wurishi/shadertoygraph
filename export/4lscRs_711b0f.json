{"ver":"0.1","info":{"id":"4lscRs","date":"1506038134","viewed":143,"name":"complex gamma","username":"Justaway","description":"Complex gamma function.\nGoing to use to try to render the Riemann Zeta function.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["complexmath"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define E 2.71828\n#define PI 3.14159\n\nconst float[8] p = float[8](\n    676.5203681218851,\n    -1259.1392167224028,\n    771.32342877765313,\n    -176.61502916214059,\n    12.507343278686905,\n    -0.13857109526572012,\n    9.9843695780195716e-6,\n    1.5056327351493116e-7\n);\n\nvec2 complexPower(vec2 z1, vec2 z2)\n{\n    float a2b2 = z1.x*z1.x+z1.y*z1.y;\n    float t1 = pow(a2b2,z2.x/2.0)*exp(-z2.y*atan(z1.y,z1.x));\n    float t2 = z2.x*atan(z1.y,z1.x)+0.5*z2.y*log(a2b2);\n    return vec2(t1*cos(t2),t1*sin(t2));\n}\n\nvec2 complexExp(vec2 z)\n{\n    return complexPower(vec2(E,0.0),z);\n}\n\nvec2 complexDiv(vec2 z1,vec2 z2)\n{\n    return z1*mat2(z2,-z2.y,z2.x)/dot(z2,z2);\n}\n\nvec2 complexMult(vec2 z1,vec2 z2)\n{\n    return mat2(z1,-z1.y,z1.x)*z2;\n}\n\nvec2 complexSine(vec2 z)\n{\n    return complexMult(vec2(0.0,0.5),complexExp(complexMult(vec2(0.0,-1.0),z))-complexExp(complexMult(vec2(0.0,1.0),z)));\n}\n\nvec2 gammaRightSide(vec2 z)\n{\n    z -= vec2(1.0,0.0);\n    vec2 x = vec2(0.99999999999980993,0.0);\n    vec2 pval;\n    for(int i = 0; i < 8; i++)\n    {\n        pval = vec2(p[i],0.0);\n        x += complexDiv(pval,z+vec2(float(i)+1.0,0.0));\n    }\n    vec2 t = z + vec2(7.5,0.0);\n    vec2 y = complexMult(complexMult(complexMult(vec2(sqrt(2.0*PI),0.0),complexPower(t,z+vec2(0.5,0.0))),complexExp(-t)),x);\n    return y;\n}\n\nvec2 gammaLeftSide(vec2 z)\n{\n    vec2 y = complexDiv(vec2(PI,0.0),complexMult(complexSine(complexMult(vec2(PI,0.0),z)),gammaRightSide(vec2(1.0,0.0)-z)));\n    return y;\n}\n\n//based on https://en.wikipedia.org/wiki/Lanczos_approximation\nvec2 gamma(vec2 z)\n{\n    if(z.x > 0.5)\n    {\n        return gammaRightSide(z);\n    }\n    else\n    {\n        return gammaLeftSide(z);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 z = (fragCoord.xy-iResolution.xy/2.0) / iResolution.xy*10.0;\n    vec2 y = gamma(z);\n\n    vec4 color;\n    color.r = (sin(y.x)+1.0)/2.0;\n    color.g = (sin(y.y)+1.0)/2.0;\n    color.b = (sin(length(y))+1.0)/2.0;\n    \n\tfragColor = color;\n}","name":"Image","description":"","type":"image"}]}