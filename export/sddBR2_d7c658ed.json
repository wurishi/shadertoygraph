{"ver":"0.1","info":{"id":"sddBR2","date":"1656853996","viewed":99,"name":"Camouflage Texture","username":"alezen","description":"CONTROLS\nmove - LEFT, RIGHT, UP, DOWN\nscale - MouseY","likes":3,"published":1,"flags":48,"usePreview":0,"tags":["procedural","2d","texture"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define GRID_OUTLINE 0\n#define DEBUG 0\n\n#define LINE_WIDTH .6\n#define POINT_WIDTH .1\n\n#define SHOW_POINTS 0\n#define SHOW_LINES 1\n\n#define NOISE_THRESHOLD .76\n#define POINT_JOIN_DIST 2.5\n#define SMOOTH_FACTOR .5\n#define SCALE 50.\n\nfloat pixelWidth = 1.;\n\nfloat drawLine(vec2 uv, vec2 a, vec2 b) {\n    float d = sdLine(uv, a, b);\n    return smoothstep(pixelWidth, -pixelWidth, d - LINE_WIDTH);\n}\n\nbool checkPoint(vec2 uv) {\n    float n = hash1(floor(uv));\n    return n > NOISE_THRESHOLD;\n}\n\nvec2 genPoint(vec2 uv) {\n\n    vec2 p = vec2(hash1(floor(uv)) + 100.);\n    p.x = hash1(p.x);\n    p.y = hash1(p.x);\n    \n    p *= 1.-POINT_WIDTH*2.;\n    p += POINT_WIDTH;\n    return p;\n}\n\nfloat caveNoisePointsDist(vec2 uv) {\n    vec2 gv = fract(uv);\n    if(checkPoint(uv)) {\n        return length(gv - genPoint(uv));\n    }\n    return 1.;\n}\n\nvec4 points(vec2 uv) {\n    vec2 gi = floor(uv);\n    vec3 col = vec3(.0);\n    //col.x = hash1(col.x);\n    //col.y = hash1(col.x);\n    //col.z = hash1(col.y);\n    \n    col.x = .8;\n    float alpha = smoothstep(pixelWidth,-pixelWidth, caveNoisePointsDist(uv) - POINT_WIDTH);\n    return vec4(col, alpha);\n}\n\n\n\nvec4 lines(vec2 uv) {\n\n    float d = 1.;\n\n    const int scan_cells = int(ceil(POINT_JOIN_DIST))*2 + 1;\n    const ivec2 offset = ivec2((1 - scan_cells)/2);\n    const int sqr_scan_cells = scan_cells*scan_cells;\n    \n    vec2 gi = floor(uv);\n    vec2 gv = fract(uv);\n        \n    for(int i=0;i<sqr_scan_cells-2;i++){\n        vec2 cell1 = vec2(splitToVec2(i, scan_cells) + offset) + gi;\n        if(checkPoint(cell1))\n        for(int j=i+1;j<sqr_scan_cells;j++){\n            vec2 cell2 = vec2(splitToVec2(j, scan_cells) + offset) + gi;\n            cell1 = floor(cell1) + genPoint(cell1);\n            cell2 = floor(cell2) + genPoint(cell2);\n            if(checkPoint(cell2) && length(cell1-cell2) < POINT_JOIN_DIST)\n                d = smin(d, sdLine(uv, cell1, cell2), SMOOTH_FACTOR);\n        }\n    }\n    \n    float alpha = smoothstep(pixelWidth, -pixelWidth, d - LINE_WIDTH);\n    alpha = clamp(alpha,0.,1.);\n    return vec4(alpha);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float w = 1. - iMouse.y/iResolution.y;\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    float scaleFactor = SCALE*w;\n    pixelWidth = 1.2*scaleFactor/iResolution.y;\n    uv *= scaleFactor;\n    vec2 camPos = texelFetch(iChannel0, CAM_POS_LOCATION, 0).xy;\n    uv += camPos;\n\n#if SHOW_LINES\n    vec4 line = lines(uv);\n    col =mix(col, line.rgb, line.a);\n#endif\n\n#if SHOW_POINTS\n    vec4 point = points(uv);\n    col =mix(col, point.rgb, point.a);\n#endif\n\n#if GRID_OUTLINE\n    vec2 outline = abs(fract(uv) - .5)*2.;\n    outline = smoothstep(1.-0.006*SCALE,1., outline);\n    float grid = max(outline.x, outline.y);\n    col =mix(col, vec3(0.,0.,1.), grid);\n#endif\n\n    fragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"ivec2 splitToVec2(int i, int radix) {\n    ivec2 v;\n    v.x = i%radix;\n    v.y = i/radix;\n    return v;\n}\n\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n  return mix(a, b, h) - k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k) {\n    return -smin(-a,-b, k);\n}\n\nfloat sdLine(vec2 p, vec2 a, vec2 b)\n{\n  vec2 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h );\n}\n\nfloat hash1(float p)\n{\n \tp = fract(p * 8794.45764);\n    p += p*(p + 34.23);\n    return fract(p);\n}\n\nfloat hash1(vec2 p)\n{\n \tp = fract(p * vec2(325.23454, 874.45764));\n    p += dot(p, p + 34.23);\n    return fract(p.x * p.y);\n}\n\nfloat hash1(vec3 p)\n{\n    return hash1(vec2(hash1(p.xy), p.z));\n}\n\nfloat noise(float p)\n{\n    float ip = floor(p);\n    float a = hash1(ip);\n    float b = hash1(ip+vec2(1,0));\n    float o = p-ip;\n    o = smoothstep(0.,1.,o);\n    return a*(1. - o) + b*o;\n}\n\n\nfloat noise(vec2 p)\n{\n    vec2 ip = floor(p);\n    float a = hash1(ip);\n    float b = hash1(ip+vec2(1,0));\n    float c = hash1(ip+vec2(0,1));\n    float d = hash1(ip+vec2(1,1));\n    vec2 o = p-vec2(ip);\n    o = smoothstep(0.,1.,o);\n    return (a*(1. - o.x) + b*o.x)*(1. - o.y) + (c*(1. - o.x) + d*o.x)*o.y;\n}\n\nfloat noise(vec3 p)\n{\n    vec3 ip = floor(p);\n    float a = hash1(ip);\n    float b = hash1(ip+vec3(1,0,0));\n    float c = hash1(ip+vec3(0,1,0));\n    float d = hash1(ip+vec3(1,1,0));\n    \n    float a1 = hash1(ip + vec3(0,0,1));\n    float b1 = hash1(ip + vec3(1,0,1));\n    float c1 = hash1(ip + vec3(0,1,1));\n    float d1 = hash1(ip + vec3(1,1,1));\n    vec3 o = p-vec3(ip);\n    //o = 1.-cos(o*PI);\n    //o*=.5;\n    o = smoothstep(0.,1.,o);\n    return\n    ((a*(1. - o.x) + b*o.x)*(1. - o.y) + (c*(1. - o.x) + d*o.x)*o.y)*(1. - o.z) +\n    ((a1*(1. - o.x) + b1*o.x)*(1. - o.y) + (c1*(1. - o.x) + d1*o.x)*o.y)*o.z;\n}\n\n#define CAM_POS_LOCATION ivec2(1,1)\n\nbool isLocated(vec2 fragCoord, ivec2 location) {\n    return length(fragCoord-vec2(location)) < 1.;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\n#define SPEED 5.\nfloat getKey(int code)\n{\n    return texelFetch(iChannel0, ivec2(code,0),0).x;\n}\n\nvec2 getMotionVec2() {\n    return vec2(getKey(KEY_RIGHT)-getKey(KEY_LEFT),getKey(KEY_UP)-getKey(KEY_DOWN));\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 outColor = vec4(0.);\n\n    vec4 val = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    vec2 motion = getMotionVec2();\n    \n    outColor = val;\n    outColor.xy += motion * SPEED * iTimeDelta;\n        \n    fragColor = outColor;\n}","name":"Buffer A","description":"","type":"buffer"}]}