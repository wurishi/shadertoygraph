{"ver":"0.1","info":{"id":"stVGzD","date":"1637498914","viewed":238,"name":"Riemann sphere projection","username":"TotallyReal","description":"Simulates the projection from the Riemann sphere to the plane.\nIf P is any point on the sphere other than the north pole Q, then there is a line going through P and Q intersects the plane at a unique point T(P), and the projection is P->T(P).","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["projection","riemannsphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// some color constants\nconst vec3 RED = vec3(1.,0.,0.);\nconst vec3 GREEN = vec3(0.,1.,0.);\nconst vec3 BLUE = vec3(0.,0.,1.);\nconst vec3 YELLOW = vec3(1.,1.,0.);\nconst vec3 GRAY = vec3(0.8);\nconst vec3 BLACK = vec3(0.);\nconst vec3 WHITE = vec3(1.);\n\n// --------------------------- drawing on the plane ---------------------------\n\n// To change what is actually drawn on the plane, change the pixelColor function below.\n\n\nstruct Ring {\n    vec2 center;\n    float radius;\n    float width;\n};\n\nbool inRing(vec2 p, Ring ring){\n    return abs(distance(p,ring.center)-ring.radius)<ring.width;\n}\n\nstruct Line {\n    vec2 point;\n    vec2 direction; // should be normalized\n    float width;\n};\n\nbool inLine(vec2 p, Line line){\n    vec2 v = p-line.point;\n    float len = dot(v, line.direction);\n    v -= len*line.direction; // The part perpendicular to the line\n    \n    return length(v)<line.width;\n}\n\n//                      center,      radius, width.\nconst Ring ring1 = Ring(vec2(1.),       1.,  0.05);\nconst Ring ring2 = Ring(vec2(-1.),      0.5, 0.05);\nconst Ring ring3 = Ring(-vec2(-3., 3.), 1.,  0.05);\nconst Ring ring4 = Ring(-vec2(2., -2.), 2.,  0.05);\n\nconst Line xAxis = Line(vec2(0.), vec2(1., 0.), 0.03);\nconst Line yAxis = Line(vec2(0.), vec2(0., 1.), 0.03);\n\nvec3 pixelColor(vec2 p){\n\n    if (inLine(p, xAxis) || inLine(p, yAxis))\n        return RED;\n    if (abs(p.x-round(p.x))<0.03 || abs(p.y-round(p.y))<0.03)  // draw grid\n        return YELLOW;\n    if (inRing(p, ring1) || inRing(p, ring2) || inRing(p, ring3) || inRing(p, ring4))\n        return GREEN;\n        \n    float d = (length(p)-1.+sin(iTime))/0.07;\n    d = 1. - d*d;\n    d = clamp(d, 0., 1.);\n    \n    return mix(texture(iChannel0, p/2.).rgb * 0.7, BLUE, d);\n}\n\n\n// --------------------------- ray computation ---------------------------\n\n\nconst float MAX_DIST = 1000000000.;\n\nvec3 planeHit(vec3 origin, vec3 direction, out float dist){\n    dist = MAX_DIST;\n    \n    if (direction.z == 0.)\n        return GRAY;\n    \n    dist = -origin.z/direction.z;\n    if (dist<0.){\n        dist = MAX_DIST;\n        return GRAY;\n    }\n    vec3 hitPoint = origin + dist*direction;\n    \n    \n    return pixelColor(hitPoint.xy);\n}\n\n\nstruct Light{\n    vec3 position;\n    float strength; //between 0 and 1\n};\n\nconst Light light = Light(vec3(2.), 0.5);\n\nvec3 sphereHit(vec3 origin, vec3 direction, out float dist){\n    dist = MAX_DIST;\n    vec3 center = vec3(0.,0.,0.5);\n    float r = 0.5;\n    // compute the intersection of the ray with the sphere\n    // |origin + t*direction - center|^2 = r^2\n    // |origin-center|^2 +2t<direction,origin-center> + t^2 |direction|^2 = r^2\n    \n    vec3 v = origin-center;                     \n    float a = dot(direction, direction);         \n    float b = 2.*dot(direction,v);               \n    float c = dot(v,v)-r*r;                      \n    // solve a*t^2 + b*t + c = 0\n    float disc = b*b-4.*a*c;\n    if (disc<0.)\n        return GRAY; // no intersection with the sphere\n        \n    dist = (-b - sqrt(disc))/(2.*a);\n    vec3 hitPoint = origin + dist*direction;\n    // Look at the ray starting at the north pole, and going through the hitting point,\n    // and find out its intersection with the plane\n    vec3 newDirection = hitPoint-center-vec3(0.,0.,r);\n    float planeDist;\n    vec3 planeColor = planeHit(\n        hitPoint, \n        newDirection,\n        planeDist);\n        \n    // Just to differentiate a little bit the sphere from the plane, add some lighting to the sphere.    \n    vec3 toLight = normalize(light.position-hitPoint);\n    vec3 normal = normalize(hitPoint-center);\n    vec3 lightReflection = reflect(toLight, normal);\n    float dotProduct = dot(direction, lightReflection)*light.strength;\n    return planeColor + WHITE*dotProduct;\n}\n\n\n// Set the location of the camera.\nvoid camera(out vec3 origin, out vec3 forward, out vec3 right, out vec3 up){\n    \n    float angle = iTime*0.5;\n    float r = 4.+sin(iTime);\n   \n    origin = vec3(r*cos(angle),r*sin(angle),3. + 2.3*cos(angle*0.8));\n    \n    forward = -normalize(origin);\n    right = cross(forward, vec3(0.,0.,1.));\n    up = cross(right,forward);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (height goes from 0 to 1, and keep the ratio with the width)\n    vec2 uv = fragCoord/iResolution.y;\n\n    // camera\n    vec3 origin, forward, right,up;\n    camera(origin,forward, right,up);\n   \n    // ray direction\n    uv -= vec2(0.5*iResolution.x/iResolution.y, 0.5);\n    vec3 direction = normalize(forward + uv.x*right + uv.y*up);\n       \n    // compute intersection with sphere\n    float dist = MAX_DIST;\n    vec3 color = BLACK;\n    \n    float sphereDist;\n    vec3 sphereColor = sphereHit(origin, direction, sphereDist);\n    if (sphereDist<dist){\n        dist = sphereDist;\n        color = sphereColor;\n    }\n\n    // compute intersection with the plane\n    float planeDist;\n    vec3 planeColor = planeHit(origin, direction, planeDist);\n    if (planeDist<dist){\n        dist = planeDist;\n        float fog = 2.-dist/10.;\n        fog = clamp(fog, 0., 1.);\n        color = planeColor*fog;\n    }\n\n    // Output to screen\n    fragColor = vec4(color ,1.0);\n    \n}","name":"Image","description":"","type":"image"}]}