{"ver":"0.1","info":{"id":"wlXBD4","date":"1596716938","viewed":201,"name":"Glitchy Merri","username":"Flopine","description":"I made this shader during a live set with Lucija/Merristasis for A Bit of Chiptune last concert!\nListen to her work here > https://soundcloud.com/e_z_ra","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","glitch","rainbow","isometric","live"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan and slerpy for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n\n#define PI acos(-1.)\n\n#define BPM (170./60.)\n#define time(speed) fract(iTime*speed)\n#define bouncy(speed) sqrt(abs(sin(time(speed)*PI))) \n#define swit(speed) floor(sin(time(speed)*2.*PI)+1.)\n\n\nfloat hash21 (vec2 x)\n{return fract(sin(dot(x,vec2(13.1,45.5)))*1284.4);}\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nvoid mo (inout vec2 p, vec2 d)\n{\n    p = abs(p)-d;\n    if(p.y>p.x) p = p.yx;\n}\n\nvoid moda (inout vec2 p, float rep)\n{\n    float per = (2.*PI)/rep;\n    float a = mod(atan(p.y,p.x),per)-per*0.5;\n    p = vec2(cos(a),sin(a))*length(p);\n}\n\nfloat box (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0.,max(q.x,max(q.y,q.z)))+length(max(q,0.));\n}\n\nfloat od (vec3 p, float d)\n{return dot (p,normalize(sign(p)))-d;}\n\nfloat sphe (vec3 p, float r)\n{return length(p)-r;}\n\nfloat sc (vec3 p, float d)\n{\n    p = abs(p);\n    p = max(p, p.yzx);\n    return min(p.x,min(p.y,p.z))-d;\n}\n\nfloat prim1 (vec3 p)\n{\n    return min(\n        max(-sphe(p, 0.95),od(p, 0.8)),\n        max(-(sc(p, 0.9)-0.1),box(p,vec3(1.+bouncy(1.)*0.4))-0.05)\n    );\n}\n\nfloat g1 = 0.;\nfloat prim2 (vec3 p)\n{\n    float d= 1e10;\n    for (int i =0; i<3; i++)\n    {\n        float ratio = (float(i)/4.);\n        mo(p.xz, vec2(0.5));\n        p.x -= 2.;\n        p.yz *= rot(time(0.2)*2.*PI);\n        d = min(d,od(p, 0.5));    \n    }\n    g1 += 0.01/(0.01+d*d);\n    return d;\n}\n\n\nfloat SDF (vec3 p)\n{\n    p.yz *= rot(-atan(1./sqrt(2.)));\n    p.xz *= rot(PI/4.);\n    vec3 pp  = p;\n    \n    moda(p.yz,3.);\n    p.x -= 5.3;\n    float per = 10.;\n    float size = 5.;\n    p = p-per*clamp(round(p/per),-size,size);\n\n    return min(prim2(p),prim1(p));\n}\n\nfloat mask (vec2 uv)\n{return sign(fract(uv.x+0.5*uv.y)-fract(uv.y));}\n\nvec3 pal (float t, vec3 c)\n{return vec3(0.5)+vec3(0.5)*cos(2.*PI*(c*t+vec3(0.,0.34,0.66)));}\n\nvec3 getnorm (vec3 p)\n{\n    vec2 eps = vec2(0.01,0.);\n    return normalize(SDF(p)-vec3(SDF(p-eps.xyy),SDF(p-eps.yxy),SDF(p-eps.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    vec2 detail = vec2(2.5, 40.);\n    uv += hash21(floor((uv+time(BPM/4.)*0.)*detail)/detail);\n\n    if (swit(BPM/2.)<= 0.) uv += mask(uv*5.);\n\n    vec3 ro = vec3(uv*15.,-50.),\n        rd = vec3(0.,0.,1.),\n        p = ro,\n        l = normalize(vec3(1.,2.,-1.)),\n        col = vec3(0.,0.,0.1);\n\n    bool hit = false; float d = 0.;\n\n    for (float i=0.; i<64.; i++)\n    {\n        d = SDF(p);\n        if (d<0.1)\n        {\n            hit = true;\n            break;\n        }\n        d = max(abs(d)-0.1,0.5);\n        p += d*rd;\n    } \n\n\n    if (hit)\n    {\n        vec3 n = getnorm(p);\n        float light = max(dot(n,l), 0.);\n        col = mix(vec3(0.,0.1,0.2),pal(length(p),vec3(.05)),light);\n    }\n    col += g1*0.1;\n\n    fragColor = vec4(sqrt(col), 1.);\n}","name":"Image","description":"","type":"image"}]}