{"ver":"0.1","info":{"id":"ssKfRD","date":"1657805180","viewed":124,"name":"Quartic solvers","username":"Envy24","description":"Analytical quartic solver in this shader is really bad, even though it look like it works)\nFormulas for factoring terms: https://www.desmos.com/calculator/uh9mtw2wiw\nBetter solvers can be found here: https://www.shadertoy.com/playlist/sfjBz1","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["approximation","solver","quartic","newton","raphson","halley","numeric","secant","regulafalsi"],"hasliked":0,"parentid":"ssKBRD","parentname":"Cubic Solvers"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                           iResolution\n#define AR                        ( R.x / R.y )                      // Aspect ratio (AR > 1.0).\n#define TO_CENTERED_NDC(SC)       ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define UNIT                      (  6.0 / R.y  )\n#define SM(x)                     ( smoothstep(UNIT, 0., x) )\n#define LMB_IS_HOLD               ( iMouse.z > 0.0 )\n\nfloat diskSDF_L2(vec2 NDC, vec2 C, float R)\n{\n    return length(C - NDC)-R;\n}\n\nfloat x_axis(vec2 NDC) { return SM(abs(NDC.x)); }\nfloat y_axis(vec2 NDC) { return SM(abs(NDC.y)); }\nfloat quartic(vec2 NDC, float a, float b, float c, float d, float e)\n{\n    float df   = NDC.y - ((((a * NDC.x + b) * NDC.x + c) * NDC.x + d) * NDC.x + e),\n          dfdx = ((4.0 * a * NDC.x + 3.0 * b) * NDC.x + 2.0 * c) * NDC.x + d;\n    return SM(abs(df) / sqrt(1.0 + dfdx * dfdx));\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = \n        LMB_IS_HOLD ?\n            2.*TO_CENTERED_NDC(SC-(iMouse.xy-R.xy*0.5)) :\n            2.*TO_CENTERED_NDC(SC);\n\n    //float a = -0.8, b = -1.4, c = 0.8, d = 0.0, e = -1.0;\n    /* Quartic */\n    float a = sinOSC(-1.25, 1.25, iTime * 0.15), b = sinOSC( -2.0,  2.0, iTime * 0.6), \n          c = sinOSC( -1.0,  1.0, iTime * 0.45), d = sinOSC( -1.0,  1.0, iTime * 0.25),\n          e = sinOSC( -1.0,  1.0, iTime * 0.17);\n    /* Cubic *\n    float a =                               0.0, b = sinOSC( -2.0,  2.0, iTime * 0.6), \n          c = sinOSC( -1.0,  1.0, iTime * 0.45), d = sinOSC( -1.0,  1.0, iTime * 0.25),\n          e = sinOSC( -1.0,  1.0, iTime * 0.17);\n    /* Quadratic *\n    float a =                               0.0, b =                               0.0, \n          c = sinOSC( -1.0,  1.0, iTime * 0.45), d = sinOSC( -1.0,  1.0, iTime * 0.25),\n          e = sinOSC( -1.0,  1.0, iTime * 0.17);\n    /* Linear *\n    float a =                               0.0, b =                               0.0,\n          c =                               0.0, d = sinOSC( -1.0,  1.0, iTime * 0.25),\n          e = sinOSC( -1.0,  1.0, iTime * 0.17);\n    /* Identity 0 == 0 *\n    float a =                               0.0, b =                              0.0,\n          c =                               0.0, d =                              0.0,\n          e =                               0.0;\n    /**/\n\n    // Cauchy's roots bounds.\n    float upper_bound = max(0.0, 1.0 + max(-a/a, max(-b/a, max(-c/a, max(-d/a, -e/a)))));\n    float lower_bound = max(0.0, 1.0 + max( a/a, max( b/a, max( c/a, max( d/a,  e/a)))));\n\n    vec3 color = (NDC.x <= upper_bound && NDC.x >= -lower_bound) ? vec3(.9,.9,.9) : vec3(1.);\n         color -= quartic(NDC, a, b, c, d, e);\n         color -= x_axis(NDC); color -= y_axis(NDC);\n\n    vec2 roots[4]; float coef[5] = float[5]( a, b, c, d, e );\n      \n    // Non-numeric solvers.\n    int num = solve4(roots, coef);\n    \n    // Numeric solvers.\n    //int num = solve4n(roots, coef);\n\n    for (int r=0; r < num; ++r) \n    {\n        float x = roots[r].x;\n        color = mix(color, vec3(1, 0, 0), SM(diskSDF_L2(NDC, vec2(x, 0.0), 0.03)));\n    }\n\n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\n/*\n    Returns number of real roots.\n*/\nint solveQuadraticForReal(\n    inout vec2[2] roots,\n    in float[3] coefs)\n{\n    float discriminant = coefs[1] * coefs[1] - 4.0 * coefs[0] * coefs[2];\n    float INVa = 1.0 / (2. * coefs[0]);\n    float SQRT = sqrt(discriminant);\n\n    roots[0].x = (SQRT - coefs[1]) * INVa;  roots[0].y = 0.0;\n    roots[1].x = (-coefs[1] - SQRT) * INVa; roots[1].y = 0.0;\n\n    return \n        discriminant < 0.0 ? // No real roots?\n        0 : 2;\n}\n\n/*\n    Return value:\n        0 - no roots when A==0, B==0, C==0;\n        1 - one real, two complex roots;\n        2 - three real roots, but root[1] == root[2];\n        3 - three real roots.\n*/\nint solveCubicVieta(\n    inout vec2[3] roots,\n    in float[4] coef)\n{\n    const float oneThird = 0.33333333333333331;\n    const float TAU = 6.2831853071795862;\n\n    float inv = 1.0 / coef[0];\n    float a = coef[1] * inv;\n    float b = coef[2] * inv;\n    float c = coef[3] * inv;\n\n    float Q = (a * a - 3.0 * b) / 9.0;\n    float R = (2.0 * a * a * a - 9.0 * a * b + 27.0 * c) / 54.0;\n    float S = Q * Q * Q - R * R;\n\n    if (S > 0.0)\n    {\n        float phi = oneThird * acos(R / sqrt(Q * Q * Q));\n        float Re = -2.0 * sqrt(Q);\n\n        roots[0].x = Re * cos(phi) - a * oneThird;\n        roots[0].y = 0.0;\n        roots[1].x = Re * cos(phi + TAU * oneThird) - a * oneThird;\n        roots[1].y = 0.0;\n        roots[2].x = Re * cos(phi - TAU * oneThird) - a * oneThird;\n        roots[2].y = 0.0;\n\n        return 3;\n    }\n\n    if (S < 0.0 && Q > 0.0)\n    {\n        float phi = oneThird * acosh(abs(R) / sqrt(Q * Q * Q));\n        float signR = R < 0.0 ? -1.0 : 1.0;\n\n        float sqrtQ = sqrt(Q);\n        float Re = signR * sqrtQ * cosh(phi);\n        float Im = sqrtQ * sinh(phi);\n        float sqrt3 = 1.7320508075688772;\n\n        roots[0].x = -2.0 * Re - a * oneThird;\n        roots[0].y = 0.0;\n        roots[1].x = Re - a * oneThird;\n        roots[1].y = sqrt3 * Im;\n        roots[2].x = Re - a * oneThird;\n        roots[2].y = -sqrt3 * Im;\n\n        return 1;\n    }\n\n    if (S < 0.0 && Q < 0.0)\n    {\n        float phi = oneThird * asinh(abs(R) / sqrt(abs(Q * Q * Q)));\n        float signR = R < 0.0 ? -1.0 : 1.0;\n\n        float sqrtQ = sqrt(abs(Q));\n        float Re = signR * sqrtQ * sinh(phi);\n        float Im = sqrtQ * cosh(phi);\n        float sqrt3 = 1.7320508075688772;\n\n        roots[0].x = -2.0 * Re - a * oneThird;\n        roots[0].y = 0.0;\n        roots[1].x = Re - a * oneThird;\n        roots[1].y = sqrt3 * Im;\n        roots[2].x = Re - a * oneThird;\n        roots[2].y = -sqrt3 * Im;\n\n        return 1;\n    }\n    \n    if (Q == 0.0)\n    {\n        float Re = -pow(c - a * a * a / 27.0, oneThird) - a * oneThird;\n        float Im = sqrt(abs(a - 3.0 * Re) * (a + Re) - 4.0 * b) * 0.5;\n\n        roots[0].x = Re;\n        roots[0].y = 0.0;\n        roots[1].x = -(a + Re) * 0.5;\n        roots[1].y = Im;\n        roots[2].x = -(a + Re) * 0.5;\n        roots[2].y = Im;\n\n        return 1;\n    }\n\n    float signR = R < 0.0 ? -1.0 : 1.0;\n    float Re = signR * sqrt(Q);\n\n    roots[0].x = -2.0 * Re - a * oneThird;\n    roots[0].y = 0.0;\n    roots[1].x = Re - a * oneThird;\n    roots[1].y = 0.0;\n    roots[2] = roots[1];\n\n    return 2;\n}\nint solveCubicForReal(\n    inout vec2[3] roots,\n    in float[4] coef)\n{\n    const float oneThird = 0.33333333333333331;\n    const float TAU = 6.2831853071795862;\n\n    float inv = 1.0 / coef[0];\n    float a = coef[1] * inv;\n    float b = coef[2] * inv;\n    float c = coef[3] * inv;\n\n    float Q = (a * a - 3.0 * b) / 9.0;\n    float R = (2.0 * a * a * a - 9.0 * a * b + 27.0 * c) / 54.0;\n    float S = Q * Q * Q - R * R;\n\n    if (S > 0.0)\n    {\n        float phi = oneThird * acos(R / sqrt(Q * Q * Q));\n        float Re = -2.0 * sqrt(Q);\n\n        roots[0].x = Re * cos(phi) - a * oneThird;\n        roots[0].y = 0.0;\n        roots[1].x = Re * cos(phi + TAU * oneThird) - a * oneThird;\n        roots[1].y = 0.0;\n        roots[2].x = Re * cos(phi - TAU * oneThird) - a * oneThird;\n        roots[2].y = 0.0;\n\n        return 3;\n    }\n\n    if (S < 0.0 && Q > 0.0)\n    {\n        float phi = oneThird * acosh(abs(R) / sqrt(Q * Q * Q));\n        float signR = R < 0.0 ? -1.0 : 1.0;\n\n        roots[0].x = -2.0 * signR * sqrt(Q) * cosh(phi) - a * oneThird;\n        roots[0].y = 0.0;\n\n        return 1;\n    }\n\n    if (S < 0.0 && Q < 0.0)\n    {\n        float phi = oneThird * asinh(abs(R) / sqrt(abs(Q * Q * Q)));\n        float signR = R < 0.0 ? -1.0 : 1.0;\n\n        roots[0].x = -2.0 * signR * sqrt(abs(Q)) * sinh(phi) - a * oneThird;\n        roots[0].y = 0.0;\n\n        return 1;\n    }\n    \n    if (Q == 0.0)\n    {\n        roots[0].x = -pow(c - a * a * a / 27.0, oneThird) - a * oneThird; roots[0].y = 0.0;\n\n        return 1;\n    }\n\n    float signR = R < 0.0 ? -1.0 : 1.0;\n    float Re = signR * sqrt(Q);\n\n    roots[0].x = -2.0 * Re - a * oneThird;\n    roots[0].y = 0.0;\n    roots[1].x = Re - a * oneThird;\n    roots[1].y = 0.0;\n    roots[2] = roots[1];\n\n    return 2;\n}\n\n/*\n     Returns number of real roots.       \n*/\nint solveQuartic(\n    inout vec2 roots[4],\n    in float coef[5])\n{\n    float invA = 1.0 / coef[0];\n    float B = coef[1] * invA;\n    float C = coef[2] * invA;\n    float D = coef[3] * invA;\n    float E = coef[4] * invA;\n\n    float coef_[4] = float[4](\n        1.,\n        -C,\n        D * B - 4. * E,\n        -(D * D + E * B * B - 4. * E * C)\n    );\n    vec2 roots_[3];\n\n    int num = solveCubicForReal(roots_, coef_);\n\n    float u = 0.0;\n    float D0 = 0.0;\n    float D1 = 0.0;\n\n    if (num == 3)\n    {\n        for (int r = 0; r < 3; ++r)\n        {\n            u = roots_[r].x;\n\n            D0 = B * B * 0.25 + u - C;\n            D1 = u * u * 0.25 - E;\n\n            if (D0 >= 0.0 && D1 >= 0.0)\n            {\n                break;\n            }\n        }\n    }\n    else\n    {\n        u = roots_[0].x;\n        D0 = B * B * 0.25 + u - C;\n        D1 = u * u * 0.25 - E;\n    }   \n\n    D0 = abs(D0) < 1e-14 ? 0.0 : D0; D0 = sqrt(D0);\n    D1 = abs(D1) < 1e-14 ? 0.0 : D1; D1 = sqrt(D1);\n    //D0 = D0 < 0. ? -D0 : D0; D0 = sqrt(D0);\n    //D1 = D1 < 0. ? -D1 : D1; D1 = sqrt(D1);\n\n    float p0 = B * 0.5 + D0, p1 = B * 0.5 - D0,\n          q0 = u * 0.5 + D1, q1 = u * 0.5 - D1;\n    \n    // This line may cause problems.\n    if (abs(p0 * q1 + p1 * q0 - D) > 0.01)\n    {\n        float t = q0; q0 = q1; q1 = t;\n    } \n\n    vec2 r_[2];\n    float c_[3] = float[3]( 1.0, p0, q0 );\n\n    num = solveQuadraticForReal(r_, c_);\n\n    int wIdx = \n        num == 0 ? \n            2 : 0;\n\n    roots[wIdx] = r_[0]; roots[wIdx + 1] = r_[1];\n\n    wIdx = \n        num == 0 ? \n        0 : 2;\n\n    c_[1] = p1; c_[2] = q1;\n\n    int n = solveQuadraticForReal(r_, c_);\n\n    roots[wIdx] = r_[0]; roots[wIdx + 1] = r_[1];\n\n    num = num == 1 ? 2 : num;\n\n    return\n        n == 1 ? \n            num + 2 :\n            num + n;\n}\n\n/* \n    Returns number of real roots.       \n*/\nint solve4(\n    inout vec2[4] roots,\n    in float[5] coef)\n{\n    // Quartic equation?\n    if (coef[0] != 0.0)\n    {\n        return solveQuartic(roots, coef);\n    }\n    \n    // Cubic equation?\n    if (coef[1] != 0.0)\n    {\n        vec2 roots_[3];\n        float coef_[4] = float[4](\n            coef[1], coef[2], coef[3], coef[4]\n        );\n\n        int num = solveCubicForReal(roots_, coef_);\n\n        roots[0] = roots_[0]; roots[1] = roots_[1]; roots[2] = roots_[2];\n        \n        return num;\n    }\n    \n    // Quadratic equation?\n    if (coef[2] != 0.0)\n    {\n        vec2 roots_[2];\n        float coef_[3] = float[3](\n            coef[2], coef[3], coef[4]\n        );\n\n        int num = solveQuadraticForReal(roots_, coef_);\n\n        roots[0] = roots_[0]; roots[1] = roots_[1];\n        \n        return num;\n    }\n\n    // Linear equation?\n    if (coef[3] != 0.0)\n    {\n        // Solve linear equation.\n        roots[0].x = -coef[4]/coef[3]; roots[0].y = 0.0;\n\n        return 1;\n    }\n\n    // Identity 0 == 0? Infinitely many roots?\n    if (coef[4] == 0.0) \n    { \n        // Pick zero root.\n        roots[0].x = 0.0; roots[0].y = 0.0;\n\n        return 1;\n    }\n    \n    return 0;\n}\n\n/* Numeric solvers. */\nfloat findQuarticRootNewtonRaphson(\n    float x, float a, float b, float c, float d, float e)\n{\n    const float tolerance = 1e-7; /* Desired precision. */\n    const float EPSILON = 1e-14;  /* Treshold for infinitly small values. */\n    \n    float dfdx = ((4.0 * a * x + 3.0 * b) * x + 2.0 * c) * x + d;\n    bool quit = abs(dfdx) <= EPSILON;\n    \n    for (int i = 0; (i < 24) && (quit == false); ++i)\n    {\n        float f = (((a * x + b) * x + c) * x + d) * x + e;\n        x -= f / dfdx;          \n        dfdx = ((4.0 * a * x + 3.0 * b) * x + 2.0 * c) * x + d;\n        quit = (abs(f) <= tolerance) || (abs(dfdx) <= EPSILON);\n    }\n\n    return x;\n}\nfloat findQuarticRootSecant(\n    float x, float a, float b, float c, float d, float e)\n{\n    const float tolerance = 1e-7; /* Desired precision. */\n    const float EPSILON = 1e-14;  /* Treshold for infinitly small values. */\n\n    float x_p = x;\n    float f_p = (((a * x + b) * x + c) * x + d) * x + e;\n          x = x_p - (f_p / (((4.0 * a * x + 3.0 * b) * x + 2.0 * c) * x + d));\n\n    bool quit = false;\n\n    for (int i = 0; (i < 16) && (quit == false); ++i)\n    {\n        float f = (((a * x + b) * x + c) * x + d) * x + e;\n        float df = f - f_p; f_p = f;\n        float dx = x - x_p; x_p = x;\n\n        x -= f / (df / dx);\n\n        quit = (abs(f) <= tolerance) || (abs(dx) <= EPSILON || (abs(df) <= EPSILON));         \n    }\n\n    return x;\n}\nfloat findQuarticRootHalley(\n    float x, float a, float b, float c, float d, float e)\n{\n    const float tolerance = 1e-7; /* Desired precision. */\n    const float EPSILON = 1e-14;  /* Treshold for infinitly small values. */\n    \n    float f = (((a * x + b) * x + c) * x + d) * x + e,\n          dfdx = ((4. * a * x + 3. * b) * x + 2. * c) * x + d,\n          ddfddx = (12. * a * x + 6. * b) * x + 2. * c,\n          denom = 2.*dfdx*dfdx - f * ddfddx;\n          \n    bool quit = abs(denom) <= EPSILON;\n    \n    for (int i = 0; (i < 16) && (quit == false); ++i)\n    {       \n        x -= (2.*f*dfdx) / denom;\n        \n        f = (((a * x + b) * x + c) * x + d) * x + e;\n        dfdx = ((4. * a * x + 3. * b) * x + 2. * c) * x + d;\n        ddfddx = (12. * a * x + 6. * b) * x + 2. * c;\n        denom = 2.*dfdx*dfdx - f * ddfddx;\n        \n        quit = (abs(f) <= tolerance) || (abs(denom) <= EPSILON);\n    }\n\n    return x;\n}\nfloat findQuarticRootBisection(\n    float xl, float xr, float a, float b, float c, float d, float e)\n{\n    const float tolerance = 1e-7; /* Desired precision */\n\n    float X[2] = float[2]( xl, xr );\n    float F[2] = float[2](\n        (((a * xl + b) * xl + c) * xl + d) * xl + e,  // f(xl)\n        (((a * xr + b) * xr + c) * xr + d) * xr + e); // f(xr)\n        \n    float f = 0.5;\n        \n    for (int i = 0; (i < 24) && (abs(f) > tolerance); ++i)\n    {\n        // Make step of bisection method.\n        float x = X[0] + (X[1] - X[0]) * 0.5;\n              f = (((a * x + b) * x + c) * x + d) * x + e;\n\n        int w_idx = int(sign(F[0]) != sign(f));\n        \n        F[w_idx] = f; X[w_idx] = x;\n    }\n\n    return X[0] + (X[1] - X[0]) * 0.5;\n}\nfloat findQuarticRootHybrid(\n    float xl, float xr, float a, float b, float c, float d, float e)\n{\n    const float tolerance = 1e-7; /* Desired presicion. */\n    const float EPSILON = 1e-14;  /* Treshold for infinitely small values. */\n\n    float X[2] = float[2]( xl, xr );\n    float F[2] = float[2](\n        (((a * xl + b) * xl + c) * xl + d) * xl + e,  // f(xl)\n        (((a * xr + b) * xr + c) * xr + d) * xr + e); // f(xr)\n        \n    bool quit = abs(F[1] - F[0]) <= EPSILON;\n\n    for (int i = 0; (i < 24) && (quit == false); ++i)\n    {\n        float x = (X[0] * F[1] - X[1] * F[0]) / (F[1] - F[0]);\n        float f = (((a * x + b) * x + c) * x + d) * x + e;\n    \n        int w_idx = int(abs(f - F[0]) < abs(f - F[1]));\n\n        F[w_idx] = f; X[w_idx] = x;\n\n        quit = (abs(f) <= tolerance) || (abs(F[1] - F[0]) <= EPSILON);\n    }\n\n    return X[0] + (X[1] - X[0]) * 0.5;\n}\nfloat findQuarticRootRegulaFalsi(\n    float xl, float xr, float a, float b, float c, float d, float e)\n{\n    const float tolerance = 1e-7; /* Desired presicion. */\n    const float EPSILON = 1e-14;  /* Treshold for infinitely small values. */\n\n    float X[2] = float[2]( xl, xr );\n    float F[2] = float[2](\n        (((a * xl + b) * xl + c) * xl + d) * xl + e,   // f(xl)\n        (((a * xr + b) * xr + c) * xr + d) * xr + e ); // f(xr)\n\n    float x = 0.0, f = 0.0;\n\n    bool quit = abs(F[1] - F[0]) <= EPSILON;\n\n    for (int i = 0; (i < 24) && (quit == false); ++i)\n    {\n        x = X[0] -  F[0] * ((X[1] - X[0]) / (F[1] - F[0]));\n        f = (((a * x + b) * x + c) * x + d) * x + e;\n\n        int w_idx = int(f * F[1] > 0.);\n\n        F[w_idx] = f; X[w_idx] = x;\n\n        quit = (abs(f) <= tolerance) || (abs(F[1] - F[0]) <= EPSILON);\n    }\n\n    return x;\n}\n\n/*  Unstable.\n    Returns number of real roots.       \n*/\nint solve4n(\n    inout vec2[4] roots,\n    in float[5] coef)\n{\n    // Quartic equation?\n    if (coef[0] != 0.0)\n    {           \n        // Find first root.\n        //float x = findQuarticRootNewtonRaphson(0.01, coef[0], coef[1], coef[2], coef[3], coef[4]);\n        //float x = findQuarticRootHalley(0.01, coef[0], coef[1], coef[2], coef[3], coef[4]);\n        //float x = findQuarticRootBisection(-5.0, 5.0, coef[0], coef[1], coef[2], coef[3], coef[4]);\n        //float x = findQuarticRootRegulaFalsi(-1.1, 10.0, coef[0], coef[1], coef[2], coef[3], coef[4]);\n        //float x = findQuarticRootSecant(.1, coef[0], coef[1], coef[2], coef[3], coef[4]);\n        float x = findQuarticRootHybrid(-10.0, 1., coef[0], coef[1], coef[2], coef[3], coef[4]);\n              x = findQuarticRootNewtonRaphson(x, coef[0], coef[1], coef[2], coef[3], coef[4]);\n\n        /* No real roots? */\n        if ( abs((((coef[0] * x + coef[1]) * x + coef[2]) * x + coef[3]) * x + coef[4]) > 1e-4 ) \n        { \n            x = findQuarticRootHybrid(-1., 10., coef[0], coef[1], coef[2], coef[3], coef[4]);\n            x = findQuarticRootNewtonRaphson(-x, coef[0], coef[1], coef[2], coef[3], coef[4]);\n                  \n            // Still no real roots?\n            if ( abs((((coef[0] * x + coef[1]) * x + coef[2]) * x + coef[3]) * x + coef[4]) > 1e-4 ) { return 0; }\n        }\n        /**/\n\n        roots[0].x = x;\n\n        // Convert equation to form: (x-r0)(axxx+bxx+cx+d)=0\n        vec2 roots_[3];\n        float coef_[4] = float[4](\n            coef[0],\n            coef[1] + coef[0] * x,\n            coef[2] + coef[1] * x + coef[0] * x * x,\n            coef[3] + coef[2] * x + coef[1] * x * x + coef[0] * x * x * x\n        );\n\n        int num = solveCubicForReal(roots_, coef_);\n\n        roots[1] = roots_[0]; roots[2] = roots_[1]; roots[3] = roots_[2];\n\n        return num + 1;\n    }\n    \n    // Cubic equation?\n    if (coef[1] != 0.0)\n    {\n        vec2 roots_[3];\n        float coef_[4] = float[4](\n            coef[1], coef[2], coef[3], coef[4]\n        );\n\n        int num = solveCubicForReal(roots_, coef_);\n\n        roots[0] = roots_[0]; roots[1] = roots_[1]; roots[2] = roots_[2];\n        \n        return num;\n    }\n    \n    // Quadratic equation?\n    if (coef[2] != 0.0)\n    {\n        vec2 roots_[2];\n        float coef_[3] = float[3](\n            coef[2], coef[3], coef[4]\n        );\n\n        int num = solveQuadraticForReal(roots_, coef_);\n\n        roots[0] = roots_[0]; roots[1] = roots_[1];\n        \n        return num;\n    }\n\n    // Linear equation?\n    if (coef[3] != 0.0)\n    {\n        // Solve linear equation.\n        roots[0].x = -coef[4]/coef[3]; roots[0].y = 0.0;\n\n        return 1;\n    }\n\n    // Identity 0 == 0? Infinitely many roots?\n    if (coef[4] == 0.0) \n    { \n        // Pick zero root.\n        roots[0].x = 0.0; roots[0].y = 0.0;\n\n        return 1;\n    }\n    \n    return 0;\n}","name":"Common","description":"","type":"common"}]}