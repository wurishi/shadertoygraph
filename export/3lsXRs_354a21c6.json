{"ver":"0.1","info":{"id":"3lsXRs","date":"1563950088","viewed":193,"name":"x0006 - rasterizer - cube","username":"xigh","description":"Duplicated code from my Suzanne experiment, because it crashed on Firefox/Win10 and Chrome/MacOSX.\n\nI guess it crashed because of the size of array. I'll investigate now ...\n\nThis works well on Firefox/Ubuntu, Firefox/Win10 and Chrome/MacOSX","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raytracingcuberaytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int vCount = 8;\nconst vec3 vertices[] = vec3[](\n vec3(0.80000, -0.80000, -0.80000),\n vec3(0.80000, -0.80000, 0.80000),\n vec3(-0.80000, -0.80000, 0.80000),\n vec3(-0.80000, -0.80000, -0.80000),\n vec3(0.80000, 0.80000, -0.80000),\n vec3(0.80000, 0.80000, 0.80000),\n vec3(-0.80000, 0.80000, 0.80000),\n vec3(-0.80000, 0.80000, -0.80000) \n);\n\nconst int iCount = 12;\n\nconst int indices[] = int[](\n 1026,\n 2051,\n 4201478,\n 4200453,\n 4101,\n 5121,\n 1053702,\n 1054722,\n 2103303,\n 2104323,\n 4194307,\n 4197383 \n);\n\nconst float PI = 3.1415;\nconst float epsilon = 1e-5;\nconst vec3 centerColor = vec3(1.0, 0.5, 0.0);\nconst vec3 mouseColor = vec3(1.0, 0.0, 0.0);\nconst float near = 0.2;\n\nconst vec3 eye = vec3(0.0, 5.0, 35.0);\n\n// https://www.shadertoy.com/view/XdlGzn\nmat4 translate(float x, float y, float z) {\n    return mat4(1.0, 0.0, 0.0, x, 0.0, 1.0, 0.0, y, 0.0, 0.0, 1.0, z, 0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 rotate(float x, float y, float z) {\n    float a = sin(x);\n    float b = cos(x);\n    float c = sin(y);\n    float d = cos(y);\n    float e = sin(z);\n    float f = cos(z);\n\n    float ac = a * c;\n    float bc = b * c;\n\n    return mat4(d * f, d * e, -c, 0.0, ac * f - b * e, ac * e + b * f, a * d, 0.0,\n                bc * f + a * e, bc * e - a * f, b * d, 0.0, 0.0, 0.0, 0.0, 1.0);\n}\n\n#define CULLING\n\n// https://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-rendering-a-triangle/moller-trumbore-ray-triangle-intersection\nbool triangleIntersect(in vec3 orig, in vec3 dir, in vec3 v0, in vec3 v1, in vec3 v2,\n                       out vec3 uvt) {\n    vec3 v0v1 = v1 - v0;\n    vec3 v0v2 = v2 - v0;\n    vec3 pvec = cross(dir, v0v2);\n    float det = dot(v0v1, pvec);\n\n#ifdef CULLING\n    if (det <= epsilon) {\n        return false;\n    }\n#else\n    if (abs(det) < epsilon) {\n        return false;\n    }\n#endif\n    float invDet = 1.0 / det;\n\n    vec3 tvec = orig - v0;\n    float u = dot(tvec, pvec) * invDet;\n    if (u < 0.0 || u > 1.0) {\n        return false;\n    }\n\n    vec3 qvec = cross(tvec, v0v1);\n    float v = dot(dir, qvec) * invDet;\n    if (v < 0.0 || u + v > 1.0) {\n        return false;\n    }\n\n    float t = dot(v0v2, qvec) * invDet;\n    uvt = vec3(u, v, t);\n    return true;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 color = vec3(0.1, 0.1, 0.1);\n    // vec3 color = texture(iChannel0, fragCoord / iResolution.xy).xyz;\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 pt = uv * 2.0 - 1.0;\n\n    // z position of near clipping plane\n    pt.x *= iResolution.x / iResolution.y;\n    vec3 p = vec3(pt, near);\n\n    // calc ray direction\n    vec3 dir = normalize(p - eye);\n\n    // prepare model matrix\n    mat4 model = rotate(iTime, iTime, 0.0);\n    \n    float minZ = 1e9;\n\n    // triangle verts\n    int stride = int(iResolution.x);\n    for (int t = 0; t < iCount; t++) {\n        int z = indices[t];\n        ivec3 idx = ivec3(z / 1024 / 1024, z / 1024 % 1024, z % 1024);\n        \n        \n        vec4 v0 = model * vec4(vertices[idx.x], 1.0);\n        vec4 v1 = model * vec4(vertices[idx.y], 1.0);\n        vec4 v2 = model * vec4(vertices[idx.z], 1.0);\n\n        vec3 uvt = vec3(0.0);\n        if (triangleIntersect(eye, dir, v0.xyz, v1.xyz, v2.xyz, uvt)) {\n            vec3 norm = cross((v0-v1).xyz, (v0-v2).xyz);\n            norm = normalize(norm);\n            color = vec3(uvt.x, uvt.y, 1.0-uvt.x-uvt.y);\n            color = vec3(abs(dot(norm, vec3(0.0, 0.0, -1.0))));\n            break;\n        }\n    }\n\n    // draw center\n    float l2 = length(pt);\n    float x2 = smoothstep(0.01, 0.005, l2);\n    color = clamp(mix(color, centerColor, x2), 0.0, 1.0);\n\n    // draw mouse\n    float l0 = length(fragCoord - iMouse.xy);\n    float x0 = smoothstep(3.0, 2.0, l0);\n    color = clamp(mix(color, mouseColor, x0), 0.0, 1.0);\n\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}