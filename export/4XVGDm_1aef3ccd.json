{"ver":"0.1","info":{"id":"4XVGDm","date":"1717827990","viewed":27,"name":"Hall of Looking","username":"kesem","description":"idk","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["idk"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define STEPS 128\n#define MAX_MARCH 100.0\n#define HIT_DISTANCE 0.001\n\nfloat sphere(vec3 p, vec3 o) {\n    return distance(p, o) - 0.25;\n}\n\nvec4 raymarch(vec3 rd, vec3 ro) {\n    float traveled = 0.03;\n    vec3 p = ro;\n    vec3 l = normalize(vec3(-1.0, 1.0, 0.0));\n\n    for (int i = 0; i < STEPS; i++) {\n        p = ro + traveled * rd;\n        \n        float sdf = sphere(sin(p * 3.0) / 3.0, vec3(0.0));\n    \n        float max_travel = sdf;\n        \n        if (max_travel < HIT_DISTANCE) {\n            return vec4(p, 1.0);\n        }\n        \n        if (traveled > MAX_MARCH) {\n            break;\n        }\n        \n        traveled += max_travel;\n    }\n    return vec4(0.0, 0.0, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec3 ro = vec3((uv.x - 0.5) * aspectRatio, (uv.y - 0.5), 0.0);\n    vec3 rd = normalize(vec3(vec2(ro * 100.0), 1.0));\n    \n    vec3 position = vec3(sin(iTime), cos(iTime), 0.1);\n    //ro = position;\n    \n    fragColor = raymarch(rd, ro + position) * 3.0;\n    fragColor *= float(fragColor.z < 0.5);\n    fragColor *= sin((fragColor.z * 500.0) + (iTime * -2.0));\n}","name":"Image","description":"","type":"image"}]}