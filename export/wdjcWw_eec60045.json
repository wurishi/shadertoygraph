{"ver":"0.1","info":{"id":"wdjcWw","date":"1586793681","viewed":344,"name":"Pawn promotion","username":"elefAntti","description":"Pawns moving on an infinite chessboard.\nI got the idea for the movement from The Art of Code tutorial on rainy window: https://www.youtube.com/watch?v=52TMliAWocY\nThen just added various shadows, reflections and depth of field effect.","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["chess"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define GammaValue 1.0/2.2\n#define VignetteStrength 1.1\n#define FocalLength 1.0\n#define GroundHeight 0.0\n#define MaxDistance 170.0\n#define SquareSize 6.3\n//1.0 = No pices, 0.0 max pieces\n#define PieceDensity 0.75\n#define DepthOfFieldMag 0.016\n#define DepthOfFieldStr 0.4\n#define Speed 0.6\n#define LightIntensity 50.0\n//Strength of the ambient light\n#define AmbientStr 0.1\n#define BoardReflectivity 0.01\n\n#define M_PI 3.14159265\n\n//Generate \"random\" number\nfloat noise(float x)\n{\n    return fract((sin(x * 102.1) * 1002.1 + sin(x * 53.0)* 3023.7));\n}                \n\n//For the movement of the pieces\nfloat saw_wave3(float x)\n{\n    x = fract(x);\n    float y = x - smoothstep(0.9, 1.0, x);\n    return y;\n}\n\n//Smoother checkerboard pattern, inspired by\n//https://iquilezles.org/articles/checkerfiltering\nfloat checkers(vec2 pos)\n{\n    pos = (fract(pos * 0.5) - 0.5);\n    vec2 s = smoothstep(-0.005, 0.005, pos) * smoothstep(0.5, 0.49, pos) * 2.0 - 1.0;\n    return 0.5 - 0.5 * s.x * s.y;\n}\n\n//create a rotation matrix for the camera to look at certain direction\nmat3 cameraLookAt( vec3 lookAt )\n{\n    lookAt = normalize(lookAt);\n    lookAt.y *= -1.0;\n    lookAt.x *= -1.0;\n    vec3 x = vec3( lookAt.z, 0, -lookAt.x ); \n    vec3 y = cross( lookAt, x );\n    return mat3( x, y, lookAt );\n}\n\n//Used to identify a piece in a certain position at a certain time\nvec2 pieceID(vec3 pos, float time)\n{\n    float id_x = floor(pos.x / SquareSize + 0.5);\n    time += noise(id_x - 1.0) * 3.0;\n    pos.z -= time * SquareSize;\n    float id_z = floor(pos.z / (SquareSize * 4.0) + 0.5);\n    return vec2(id_x, id_z);\n}\n\n//Repeats the pawn and moves it\nvec3 worldToPawnCoords(vec3 pos, float time)\n{\n    float id_x = floor(pos.x / SquareSize + 0.5);\n    time += noise(id_x - 1.0) * 3.0;\n    pos.z -= time * SquareSize;\n    float id_z = floor(pos.z / (SquareSize * 4.0) + 0.5);\n    //Store this for later, remove saw_wave3(time_offset) so the pieces stay within squares\n    float time_offset = noise(145.0 * id_z + 23.0) * 5.0;\n    time += time_offset;\n    \n    vec3 squareCoord = pos;\n    squareCoord.x = (fract(pos.x / SquareSize + 0.5) - 0.5) * SquareSize;\n    squareCoord.z = (fract(pos.z / (SquareSize * 4.0) + 0.5) - 0.5) * SquareSize * 4.0;\n    squareCoord.z += (saw_wave3(time) - saw_wave3(time_offset) - 1.0) * SquareSize;\n    \n    return squareCoord;\n}\n\n//Joins shapes smoothly together\nfloat soft_max2(float a, float b, float alpha)\n{\n    float ea = exp(alpha * a);\n    float eb = exp(alpha * b);\n    return (a * ea + b * eb)/(ea + eb);\n}\n\n//distance field for a rounded cone that is the base of a pawn\nfloat distCone(vec3 pos, float radiusBase, float height)\n{\n    float slope = radiusBase / height;\n    float r = length(pos.xz);\n    float dist = r - (radiusBase - pos.y * slope);\n    dist = soft_max2(dist, -pos.y, 1.0);\n    return dist;\n}\n\n//Distance field function for a pawn\nfloat pawn(vec3 pos)\n{   \n    //Offset so the piece doesn't float\n    pos.y += 0.8;\n    float dist = distCone(pos - vec3(0.0, 1.0, 0.0), 2.5, 5.0);\n    \n    //Collar\n    dist = soft_max2(dist, \n                     length((pos - vec3(0.0, 5.2, 0.0)) * vec3(1.0, 2.0, 1.0)) / 2.0 - 0.9, -3.0);\n    //Head\n    float head = length(pos - vec3(0.0, 6.5, 0.0)) - 1.2;\n    dist = soft_max2(dist, head, -3.0);  \n    \n    //Hack to fix an artifact on top of the head :P\n    dist = mix(dist, head + 0.02, smoothstep(7.5, 7.6, pos.y));\n    return dist;\n}\n\n//Fake ambient occlusion\nfloat aoPawn(vec3 pos)\n{\n    //Ambient occlusion around the base\n    float shadow = smoothstep(-0.4, 0.4, length(pos * vec3(1.0, 4.0, 1.0)) - 2.6);\n    //Ambient occlusion below the collar\n    shadow *= smoothstep(-0.5, 0.5, length((pos - vec3(0.0, 3.8, 0.0)) * vec3(1.0, 4.0, 1.0)) - 1.1);\n    //Ambient occlusion below the head\n    shadow *= smoothstep(-0.8, 0.8, length((pos - vec3(0.0, 5.0, 0.0)) * vec3(1.0, 4.0, 1.0)) - 1.1);\n    return shadow;\n}\n\n//Used to remove some of the pieces so it is not too crowded\nbool piecePresent(vec3 pos, float time)\n{\n    vec2 id = pieceID(pos, time);\n    return noise(id.x * 1202.0 - id.y * 731.1) > PieceDensity;\n}\n\n//The main distance field function\nfloat distModel(vec3 pos, float time)\n{\n    float dist = SquareSize;\n    //Look at the nearby files of the board to prevent artifacts\n    //For some convenient reason, it works without examining the nearby ranks\n    for(float dx = -1.0; dx < 2.0; dx += 1.0)\n    {\n        vec3 offset = vec3(dx, 0.0, 0.0) * SquareSize;\n        if(piecePresent(pos + offset, time))\n        {\n        \tdist = min(dist, pawn(worldToPawnCoords(pos + offset, time) - offset));\n        }\n    }\n   \n    dist = min(dist, pos.y - GroundHeight);\n    return dist;\n}\n\n//Computes the normal of the distance field \nvec3 normModel(vec3 pos, float time)\n{\n    float delta = 0.001;\n    return normalize(vec3(\n         distModel(pos + vec3(delta, 0.0, 0.0), time) - distModel(pos - vec3(delta, 0.0, 0.0), time),\n         distModel(pos + vec3(0.0, delta, 0.0), time) - distModel(pos - vec3(0.0, delta, 0.0), time),\n         distModel(pos + vec3(0.0, 0.0, delta), time) - distModel(pos - vec3(0.0, 0.0, delta), time)\n    ) / (2.0 * delta));\n}\n\n//Schlick's approximation of Fresnel factor\nfloat reflectionCoef(float cos_theta, float R0)\n{\n    return R0 + (1.0 - R0) * pow(1.0 - cos_theta, 5.0);\n}\n\n//Cast a ray in the distance field. Return the distance it travelled before hitting something.\nfloat castRay(vec3 pos, vec3 dir, float time, float maxDist)\n{\n    float totalDist = 0.0;\n    float distToSurface = distModel(pos + dir * 0.1, time);\n    \n    while(totalDist < maxDist)\n    {\n        totalDist += distToSurface + 0.01;\n        vec3 currentPos = pos + dir * totalDist;\n        distToSurface = distModel(currentPos, time);\n        \n        if(distToSurface < 0.00)\n        {\n            //Return a little bit to better hit the surface pos\n        \ttotalDist += distToSurface;\n            return totalDist;\n        }\n    }\n    \n    return maxDist;\n}\n\n//Cast a ray in the distance field. Return the shadow factor\nfloat castShadowRay(vec3 pos, vec3 dir, float time, float maxDist)\n{\n    float totalDist = 0.0;\n    float distToSurface = distModel(pos + dir * 0.1, time);\n    float maxShadow = 0.0;\n    \n    for(int i = 0; i < 50 ; ++i)\n    {\n        totalDist += distToSurface;\n        vec3 currentPos = pos + dir * totalDist;\n        distToSurface = distModel(currentPos, time);\n        float shadowSmooth = mix(0.1, 0.7, smoothstep(0.1, 10.0, totalDist));\n        float shadow = smoothstep(shadowSmooth, 0.0, distToSurface);\n        shadow *= smoothstep(10.0, 8.0, totalDist);\n        maxShadow = max(maxShadow, shadow);\n        \n        if(distToSurface < 0.00 || totalDist > maxDist)\n        {\n            return 1.0 - maxShadow;\n        }\n    }\n    \n    return  1.0 - maxShadow;\n}\n\n//Determine the color for a ray, without the reflection part\nvec3 basicShade(vec3 cameraRayEnter, vec3 surfaceNormal, float distToSurface, float time, vec3 rayDir)\n{\n    //vec3 lightPos = vec3(-3.784, 5.0, -3.26);\n    vec3 ambientColor = vec3(185.0, 110.0, 55.0) / 255.0;\n    vec3 lightColor = vec3(254.0, 235.0, 197.0) / 255.0;\n    vec3 lightPos = vec3(-3.784, 13.0, 4.26);\n    \n    float shininess = 10.0;\n    vec3 lightDir = normalize(lightPos - cameraRayEnter);\n    float lightDist = length(lightPos - cameraRayEnter);\n    \n    float backgroundMask = smoothstep(MaxDistance, MaxDistance - 20.0, distToSurface);\n\n    float lambertShade = max(0.0, dot(lightDir, surfaceNormal)) * backgroundMask;\n    float specular = 0.0;\n    float dropShadow = 1.0;\n    \n    //Only for the side facing the light\n    if(lambertShade > 0.0)\n    {\n        //Blinn-Phong\n    \tvec3 halfDir = normalize(lightDir - rayDir);\n    \tfloat specAngle = max(dot(halfDir, surfaceNormal), 0.0);\n    \tspecular = pow(specAngle, shininess) * LightIntensity / lightDist;\n        \n        //Slight offset towards light dir to prevent artifacts\n        dropShadow = castShadowRay(cameraRayEnter + lightDir * 0.4, lightDir, time, 12.0);\n        \n\t\tdropShadow *= smoothstep(0.0, 0.2, lambertShade);\n    }\n    \n   \tvec3 baseShade = lightColor * lambertShade * dropShadow + ambientColor * AmbientStr;\n    \n    vec3 color = mix(baseShade, lightColor * specular * dropShadow, 0.5);\n    \n    if(cameraRayEnter.y <= GroundHeight + 0.001)\n    {\n        //The chessboard\n        \n        //This was the old, non-antialiased way\n       \t//vec2 id = floor(cameraRayEnter.xz / SquareSize + vec2(0.5));\n        //float bw = mod((id.x + id.y), 2.0);\n        \n        vec2 squareCoord = fract(cameraRayEnter.xz / SquareSize + vec2(0.5));\n        float bw = checkers(cameraRayEnter.xz / SquareSize + vec2(0.5));\n    \tcolor *= texture(iChannel0, squareCoord).rgb * (bw * 0.9 + 0.1);        \n    }\n\n    float shadow = 1.0;\n    if(piecePresent(cameraRayEnter, time))\n    {\n    \tshadow = aoPawn(worldToPawnCoords(cameraRayEnter, time));\n    }\n    \n    vec3 bgColor = texture(iChannel1, rayDir).xyz;\n    return mix(bgColor, color * shadow, backgroundMask);\n}\n\n//Main image function (frag coords, time) -> color\nvec3 rtMain(in vec2 fragCoord, in float time, float focalLength)\n{\n    vec2 position = fragCoord * 2.0 - 1.0;\n    vec3 rayDir = normalize(vec3( position, focalLength));\n\n    vec3 cameraPos = vec3( 0, 10.0, -30.0 );\n    rayDir *= cameraLookAt(-cameraPos);\n\n  \t//First raycast\n    float distToSurface = castRay(cameraPos, rayDir, time, MaxDistance);\n    vec3 cameraRayEnter = cameraPos + rayDir * (distToSurface);    \n    vec3 surfaceNormal = normModel(cameraRayEnter, time);\n\n    vec3 color = basicShade(cameraRayEnter, surfaceNormal, distToSurface, time, rayDir);\n    \n    //For the board, reflections\n    if(cameraRayEnter.y <= GroundHeight)\n    {\n        float refCoef = reflectionCoef(max(0.0, dot(-rayDir, surfaceNormal)), BoardReflectivity); \n        vec3 reflectionDir = reflect(rayDir, surfaceNormal);\n        float reflectedRayDist = castRay(cameraRayEnter, reflectionDir, time, MaxDistance - distToSurface);\n        vec3 relectedRayHit = cameraRayEnter + reflectionDir * reflectedRayDist; \n        vec3 surfaceNormal2 = normModel(relectedRayHit, time);\n        //Add the distances together to prvrnt reflection of pices that are no longer visible\n        vec3 reflectedColor = basicShade(relectedRayHit, surfaceNormal2,\n                                         reflectedRayDist + distToSurface, time, reflectionDir);\n        color = mix(color, reflectedColor, refCoef);\n    }\n\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.y / iResolution.x;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy - vec2(0.5f)) * vec2(1.0, aspect) + vec2(0.5);\n    \n    float focalNoise = texture(iChannel2, uv * 1.0).g * DepthOfFieldMag;\n    \n    //Mess with the Focal length to fake depth of field\n    vec3 color = mix(rtMain(uv, iTime * Speed, FocalLength),\n                     rtMain(uv, iTime * Speed, FocalLength + focalNoise),\n                     DepthOfFieldStr);\n\n    //Gamma\n    color.rgb = pow(color.rgb, vec3(GammaValue));\n\n    //Saturate channels\n    color.rgb = min(color.rgb, vec3(1.0));\n    \n    //Noise\n    color.rgb += (vec3(texture(iChannel2, uv * 1.0).r) - 0.5 ) * 0.15;\n    \n    //Vignette\n    color.rgb *= pow(1.0 - length(uv - vec2(0.5, 0.5)) * VignetteStrength, 0.5); \n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}