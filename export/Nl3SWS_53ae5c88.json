{"ver":"0.1","info":{"id":"Nl3SWS","date":"1639648341","viewed":129,"name":"Mipmaps only bloom, bad","username":"AwareStubMan","description":"A very bad implementation of https://youtu.be/tI70-HIc5ro\nYou can control the \"transition\" of the bloom by changing LOD_MULT_INCREMENT and SAMPLES.\nLOD_MULT_INCREMENT cannot be set too low or else the bloom will be too bright","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["bloom","mipmap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define LOD_MULT_INCREMENT 1.5\n#define INTENSITY 10.0\n#define SAMPLES 6\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col;\n    \n    float currentLOD = 1.0; // starts with 1, a 2x2 \"blur\"\n    for (int i = 0; i < SAMPLES; i++)\n    {\n        float alpha = texture(iChannel0, uv, currentLOD).a;\n        col += textureSRGB2Linear(iChannel0, uv, currentLOD).rgb * alpha * INTENSITY;\n        currentLOD *= LOD_MULT_INCREMENT;\n    }\n    \n    col += textureSRGB2Linear(iChannel0, uv).rgb; // add it ontop of the original image\n    col = ACES_fitted(col); // tonemap\n    col = pow(col, vec3(1.0 / 2.2)); // srgb to linear\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define THRESHOLD 0.5\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    \n    float mask = smoothstep(0.1, 0.6, dot(col-vec3(0.0, 1.0, 0.0), col-vec3(0.0, 1.0, 0.0)));\n    \n    // Apply green screening, go ahead and comment the line if you want\n    col = mix(vec3(0.0), col, mask);\n    \n    fragColor = vec4(col, pow(luminance(col), log(0.01) / log(THRESHOLD)));\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// ACES Tonemapping\nmat3 ACES_INPUT_MATRIX = mat3(\n    0.59719, 0.35458, 0.04823,\n    0.07600, 0.90834, 0.01566,\n    0.02840, 0.13383, 0.83777\n);\nmat3 ACES_OUTPUT_MATRIX = mat3(\n    1.60475, -0.53108, -0.07367,\n    -0.10208,  1.10813, -0.00605,\n    -0.00327, -0.07276,  1.07602\n);\nvec3 RTT_ODT_FIT(vec3 v)\n{\n    vec3 a = v * (v + 0.0245786) - 0.000090537;\n    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    return a / b;\n}\nvec3 ACES_fitted(vec3 v)\n{\n    v = v * ACES_INPUT_MATRIX;\n    v = RTT_ODT_FIT(v);\n    return v * ACES_OUTPUT_MATRIX;\n}\n\n\n// Color functions\nfloat luminance(vec3 v) { return dot(v, vec3(0.2126, 0.7152, 0.0722)); }\n\n\n// Image sampling functions\nvec3 textureSRGB2Linear(sampler2D img, vec2 uv) { return pow(texture(img, uv).rgb, vec3(2.2)); }\nvec3 textureSRGB2Linear(sampler2D img, vec2 uv, float lod) { return pow(texture(img, uv, lod).rgb, vec3(2.2)); }","name":"Common","description":"","type":"common"}]}