{"ver":"0.1","info":{"id":"4d2Szd","date":"1474232204","viewed":652,"name":"Triangle functions","username":"TDM","description":"triangle tools","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["intersection","distance","triamgle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\t\"Triangle functions\" by Alexander Alekseev aka TDM - 2016\n\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n\tPapers:\n\thttp://www.cs.virginia.edu/~gfx/Courses/2003/ImageSynthesis/papers/Acceleration/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf\n\thttp://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-rendering-a-triangle/moller-trumbore-ray-triangle-intersection\n*/\n\nconst int NUM_STEPS = 32;\nconst int AO_SAMPLES = 4;\nconst vec2 AO_PARAM = vec2(1.2, 3.8);\nconst vec2 CORNER_PARAM = vec2(0.25, 40.0);\nconst float INV_AO_SAMPLES = 1.0 / float(AO_SAMPLES);\nconst float TRESHOLD \t= 0.2;\nconst float EPSILON \t= 1e-4;\nconst float LIGHT_INTENSITY = 0.3;\nconst vec3 WHITE \t= vec3(1.2,1.07,0.98) * LIGHT_INTENSITY;\n\nvec3 tri[3];\n\n// math\nfloat saturate(float x) { return clamp(x,0.,1.); }\nfloat boolUnion(float a,float b) { return min(a,b); }\t\n\n#define RAY_TRIANGLE_INTERSECTION triangleIntersectionCramer\n\n/******************************************************************\n triangle distance\n ******************************************************************/\n\nfloat triangleDistance(vec3 p,vec3 v0,vec3 v1,vec3 v2) {\n    vec3 e0 = v1-v0, e1 = v2-v0, e2 = v2-v1;\n    vec3 pe0 = p-v0, pe1 = p-v1;\n    vec3 normal = cross(e0,e1);\n                      \n    // distance to plane  \n    if(dot(normal,cross(pe0,e0)) < 0.0 &&\n       dot(normal,cross(pe1,e2)) < 0.0 &&\n       dot(normal,cross(pe0,e1)) > 0.0) {\n        \n        return abs(dot(p-v0,normalize(normal)));\n        \n    // distance to edges\n    } else {\n        vec3 dp0 = e0 * saturate(dot(e0,pe0) / dot(e0,e0)) - pe0;\n        vec3 dp1 = e1 * saturate(dot(e1,pe0) / dot(e1,e1)) - pe0;\n        vec3 dp2 = e2 * saturate(dot(e2,pe1) / dot(e2,e2)) - pe1;                                 \n        return sqrt(min(min(dot(dp0,dp0),dot(dp1,dp1)),dot(dp2,dp2)));\n    }\n}\n\n/******************************************************************\n culled triangle intersection - based on Cramer's rule\n \t24 multiplications (6*2+3*4)\n \t1 division\n ******************************************************************/\n\nfloat triangleIntersectionCramerCulled(vec3 o,vec3 d, vec3 v0,vec3 v1,vec3 v2) {\n    vec3 e0 = v1-v0, e1 = v2-v0, r = o - v0;\n    vec3 ce0d = cross(e0,d);\n    float det = dot(e1,ce0d);\n    \n    // check intersection\n   \tfloat v = dot(r,ce0d);    \n    if(v < 0.0 || v > det) return -1.0;\n    \n    vec3 ce1r = cross(e1,r);\n   \tfloat u = dot(d,ce1r);\n    if(u < 0.0 || (u+v) > det) return -1.0;\n    \n    // distance to triangle\n\treturn dot(e0,ce1r) / det;\n}\n\n/******************************************************************\n triangle intersection - based on Cramer's rule\n \t27 multiplications (6*2+3*4+3)\n \t1 division\n ******************************************************************/\n\nfloat triangleIntersectionCramer(vec3 o,vec3 d, vec3 v0,vec3 v1,vec3 v2) {\n    vec3 e0 = v1-v0, e1 = v2-v0, r = o - v0;\n    vec3 ce0d = cross(e0,d);\n    float idet = 1.0 / dot(e1,ce0d);\n    \n    // check intersection\n   \tfloat v = dot(r,ce0d) * idet;    \n    if(v < 0.0 || v > 1.0) return -1.0;\n    \n    vec3 ce1r = cross(e1,r);\n   \tfloat u = dot(d,ce1r) * idet;    \n    if(u < 0.0 || (u+v) > 1.0) return -1.0;\n    \n    // distance to triangle\n\treturn dot(e0,ce1r) * idet;\n}\n\n/******************************************************************\n triangle intersection - simple approach\n \t45 multiplications (6×4+3×6+3)\n \t1 division\n ******************************************************************/\n\nfloat triangleIntersectionSimple(vec3 o,vec3 d, vec3 v0,vec3 v1,vec3 v2) {\n    vec3 e0 = v1-v0, e1 = v2-v0;\n    vec3 normal = cross(e0,e1);\n    \n    // ray vs plane    \n    float t = -(dot(normal,o) - dot(normal,v0)) / dot(normal,d);\n    \n    // point inside triangle\n    vec3 point = o + d * t;\n    if(dot(normal, cross(e0,point-v0)) < 0.0 ||\n       dot(normal, cross(e1,v2-point)) < 0.0 ||\n       dot(normal, cross(v2-v1,point-v1)) < 0.0) return -1.0;   \n    \n\treturn t;\n}\n\n\n\n\n// lighting\nfloat diffuse(vec3 n,vec3 l,float p) { return pow(max(dot(n,l),0.0),p); }\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    float nrm = (s + 8.0) / (3.1415 * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\n\nfloat plane(vec3 gp, vec4 p) {\n\treturn dot(p.xyz,gp+p.xyz*p.w);\n}\n\n// world\nfloat map_tri(vec3 p) {        \n    return triangleDistance(p, tri[0],tri[1],tri[2]);\n}\nfloat map(vec3 p) {\n    float d = map_tri(p);\n    d = boolUnion(d,plane(p,vec4(0.0,1.0,0.0,1.3)));\n    return d;\n}\n\n// tracing\nvec3 getNormal(vec3 p, float dens) {\n    vec3 n;\n    n.x = map(vec3(p.x+EPSILON,p.y,p.z));\n    n.y = map(vec3(p.x,p.y+EPSILON,p.z));\n    n.z = map(vec3(p.x,p.y,p.z+EPSILON));\n    return normalize(n-map(p));\n}\nfloat getOcclusion(vec3 p, vec3 n) {\n    float r = 0.0;\n    for(int i = 0; i < AO_SAMPLES; i++) {\n        float f = float(i)*INV_AO_SAMPLES;\n        float h = 0.01+f*AO_PARAM.x;\n        float d = map(p + n * h) - TRESHOLD;\n        r += clamp(h-d,0.0,1.0) * (1.0-f);\n    }    \n    return pow(clamp(1.0-r*INV_AO_SAMPLES*AO_PARAM.y,0.0,1.0),0.25);\n}\nvec2 spheretracing(vec3 ori, vec3 dir, out vec3 p) {\n    vec2 td = vec2(0.0);\n    for(int i = 0; i < NUM_STEPS; i++) {\n        p = ori + dir * td.x;\n        td.y = map(p);\n        if(td.y < TRESHOLD) break;\n        td.x += td.y-TRESHOLD;\n    }\n    return td;\n}\n\n// object\nvec3 getObjectColor(vec3 p, vec3 l, vec3 n, vec3 e) {\n    vec3 color = vec3(0.0,0.5,0.5);\n    color += vec3(diffuse(n,l,1.0) * WHITE);\n    color += vec3(specular(n,l,e,20.0) * WHITE); \n    color *= (n.y * 0.2 + 0.8);\n    return color;\n}\n\n// main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 iuv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    vec2 uv = iuv;\n    uv.x *= iResolution.x / iResolution.y;    \n        \n    // ray    \n    vec3 ori = vec3(0.0,0.1,4.0);\n    vec3 dir = normalize(vec3(uv.xy,-2.0));\n    vec2 sc = vec2(cos(iTime),sin(iTime));\n    dir.xz = vec2(dir.x * sc.x - dir.z * sc.y, dir.x * sc.y + dir.z * sc.x);\n    ori.xz = vec2(ori.x * sc.x - ori.z * sc.y, ori.x * sc.y + ori.z * sc.x);\n    \n    // triangle    \n    vec2 sc2 = vec2(sin(iTime),cos(iTime)) * 0.3;\n    tri[0] = vec3(-1.0+sc2.x,\t-0.4+sc2.y,\t-sc2.x*2.0);\n    tri[1] = vec3( 0.0+sc2.y,\t 1.2+sc2.x,\tsc2.y);\n    tri[2] = vec3( 1.0-sc2.x,\t-0.4-sc2.y,\tsc2.x*2.0);        \n        \n    // tracing\n    vec3 p;\n    vec2 td = spheretracing(ori,dir,p);\n    vec3 n = getNormal(p,td.y);\n    float occ = getOcclusion(p,n);\n    vec3 light = normalize(-dir); \n         \n    // color\n    vec3 color = vec3(1.0);    \n    if(map_tri(p) - EPSILON <= td.y) color = getObjectColor(p,light,n,dir);\n    \n    float t = RAY_TRIANGLE_INTERSECTION(ori, dir, tri[0],tri[1],tri[2]);\n    if(t > 0.0) color *= 0.75;    \n    \n    color *= occ;    \n    color = pow(color,vec3(1.0/2.2));\n    \n\tfragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}