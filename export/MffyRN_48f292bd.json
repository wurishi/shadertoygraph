{"ver":"0.1","info":{"id":"MffyRN","date":"1720840175","viewed":79,"name":"Fork Volumetric neurofuzzy 698","username":"neurofuzzy","description":"Fork of https://www.shadertoy.com/view/3tXXzX\n// Using iteration code from Dave Mouton's mandelbeast https://community.wolfram.com/groups/-/m/t/3210386\n","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["fractal","mandelbulb","volumetric"],"hasliked":0,"parentid":"3tXXzX","parentname":"Volumetric Mandelbulb"},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of https://www.shadertoy.com/view/3tXXzX\n// Using iteration code from Dave Mouton's mandelbeast https://community.wolfram.com/groups/-/m/t/3210386\n\n#define Pi 3.14159265359\n#define ViewStart 1.6\n#define ViewEnd 4.4\n\n\n//#define HQ\n\n\n#ifdef HQ\nint CameraRaySteps = 255;\nint ShadowRaySteps = 64;\nfloat MaxTransparency = .95;\n#else\nint CameraRaySteps = 128;\nint ShadowRaySteps = 16;\nfloat MaxTransparency = .7;\n#endif\n\n\n\nvec3 DirCam = normalize(vec3(-1, 0, 0));\nvec3 PosCam = vec3(3.0, 0, .0);\nfloat FocalLength = 1.0;\n\nvec3 LightColor = vec3(1.5);\nvec3 LightPos;\n\nfloat Density = 25.0;\nfloat Anisotropy = .25;\nvec3 VolumeColor = vec3(.1, .15, .2);\n\nfloat Power;\n\n\n\nvec3 powV(vec3 v, float p){\n    return vec3(pow(v.x, p), pow(v.y, p), pow(v.z, p));\n}\n\nfloat maxV(vec3 v){\n    return max(max(v.x, v.y), v.z);\n}\nbool insideShape(vec3 pos) {\n    pos=1.3*pos; //Zoom out a bit.\n    vec3 mx = 1.0*pos;\n    float nx, ny, tmp, tmp2;\n    int nIter = 0;\n    const int maxIter = 9; // Adjust max iterations as needed\n\n    for (int n = 0; n < maxIter; n++) {\n        nIter = n;\n        tmp = sqrt((mx.x * mx.x + mx.y * mx.y + mx.z * mx.z) / (mx.x * mx.x + mx.y * mx.y));\n        tmp2 = (mx.x * mx.x + mx.y * mx.y) * tmp;\n\n        // Transform 3D to 2D\n        nx = mx.x * tmp;\n        ny = mx.y * tmp;\n\n        // Mandelbrot (part 1)\n        float nx2 = nx * nx - ny * ny;\n        ny = 2.0 * nx * ny;\n        nx = nx2;\n\n        // Transform 2D back to 3D\n        mx = vec3(\n            (mx.x * mx.x * nx + mx.y * mx.y * tmp * nx - mx.x * mx.y * (-1.0 + tmp) * ny) / tmp2,\n            (-mx.x * mx.y * (-1.0 + tmp) * nx + mx.y * mx.y * ny + mx.x * mx.x * tmp * ny) / tmp2,\n            (mx.z * (mx.x * nx + mx.y * ny)) / tmp2\n        );\n\n        // Check size\n        if (mx.x * mx.x + mx.y * mx.y + mx.z * mx.z > 4.0) {\n            break;\n        }\n\n        // Mandelbrot (part 2)\n        mx += pos;\n    }\n    //Turn the mandelbeast into a thin shell\n    float rr=mx.x * mx.x + mx.y * mx.y + mx.z * mx.z;\n    //Raise this 0.00 to see it as a shell\n    return 0.00<rr && rr<4.0;\n}\n/*\nbool insideShape(vec3 pos) {\n\tvec3 z = pos;\n\tfloat r;\n\tfloat zr;\n    float sinTheta;\n    float phi;\n    float theta;\n\tfor(int i = 0; i < 4; i++) {\n\t\tr = length(z);\n\t\tif(r>1.3) break;\n\t\ttheta = acos(z.z/r)*Power;\n\t\tphi = atan(z.y,z.x)*Power;\n        sinTheta = sin(theta);\n\t\tz = pow(r,Power)*vec3(sinTheta*vec2(cos(phi), sin(phi)), cos(theta)) + pos;\n\t}\n\treturn r < 1.0 && r > .65;\n}*/\n\nfloat henyeyGreenstein(vec3 pos, vec3 dir){\n\tfloat cosTheta = dot(dir, normalize(LightPos-pos));\n \treturn Pi/4.0 * (1.0-Anisotropy*Anisotropy) / pow(1.0 + Anisotropy*Anisotropy - 2.0*Anisotropy*cosTheta, 3.0/2.0);\n}\n\nvec3 lightReceived(vec3 pos, float headStart){\n    \n    float LightDist = length(LightPos-pos);\n    vec3 LightDir = normalize(LightPos-pos);\n    \n    float stepSize = LightDist / float(ShadowRaySteps);\n    vec3 absorption = vec3(1.0);\n    \n    pos += headStart * LightDir * stepSize;\n    \n    for(int i = 0; i < ShadowRaySteps; i++){\n        if(insideShape(pos)){\n            absorption *= powV(vec3(1)-VolumeColor, stepSize*Density);\n        }\n        pos += LightDir * stepSize;\n    }\n    return absorption*LightColor / (LightDist*LightDist);\n}\n\n\nvec3 rotateZ(vec3 p, float angle){\n    return vec3(cos(angle) * p.x + sin(angle) * p.y,\n                -sin(angle) * p.x + cos(angle) * p.y,\n                p.z);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    //quick animation ...\n    DirCam = rotateZ(DirCam, -iTime/3.0);\n    PosCam = rotateZ(PosCam, -iTime/3.0);\n    Power = abs(cos(iTime/5.0)) * 7.0 + 1.0;\n    LightPos = vec3(cos(iTime/2.0), -sin(iTime/2.0), cos(iTime/1.0)) * 1.25;\n    \n    vec2 uv = (fragCoord.xy - iResolution.xy/2.0)/iResolution.y;\n    \n    vec3 camX = vec3(-DirCam.y, DirCam.x, 0);\n\tvec3 camY = cross(camX, DirCam);\n\tvec3 sensorX = camX * (uv.x/length(camX));\n\tvec3 sensorY = camY * (uv.y/length(camY));\n\tvec3 centerSensor = PosCam - DirCam * FocalLength;\n\tvec3 posOnSensor = centerSensor + sensorX + sensorY;\n\tvec3 dir = normalize(PosCam - posOnSensor);\n\t\n    vec3 pos = PosCam + dir*ViewStart;\n    float hg = henyeyGreenstein(pos, dir);\n    vec3 color;\n    \n    float stepSize = (ViewEnd-ViewStart) / float(CameraRaySteps);\n    vec3 absorption = vec3(1.0);\n    \n    float headStart = texture(iChannel0, fragCoord/vec2(1024)).a;\n    \n    pos += headStart * dir * stepSize;\n    \n    for(int i = 0; i < CameraRaySteps; i++){\n        if(length(LightPos-pos) <.05){\n            color += 10.0*absorption*LightColor;\n            break;\n        }\n        if(insideShape(pos)){\n            color += VolumeColor*absorption*lightReceived(pos, headStart)*hg*stepSize*Density;\n            absorption *= powV(vec3(1)-VolumeColor, stepSize*Density);\n        }\n        pos += dir * stepSize;\n        if(maxV(absorption) < 1.0-MaxTransparency) break;\n    }\n    \n\tfragColor = vec4(log(color + vec3(1.0)), 1.0);\t//reduces clipping and desaturates bright colors\n}","name":"Image","description":"","type":"image"}]}