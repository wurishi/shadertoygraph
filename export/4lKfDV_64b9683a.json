{"ver":"0.1","info":{"id":"4lKfDV","date":"1544131044","viewed":95,"name":"Triangle20","username":"Jkulvich","description":"Triangle","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["triangle","lesson"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float getTriangleArea( vec2 p[3] ) {  \n    float area = \n        (p[1].x - p[0].x) * (p[2].y - p[0].y) - \n        (p[2].x - p[0].x) * (p[1].y - p[0].y);   \n    return abs(area) * .5;\n}\n\nfloat getDistanceTriangle( vec2 coords[3], vec2 point ) { \n    // Area of the main triangle\n    float area = getTriangleArea(coords);\n            \n    // Building 3 triangles areas for every point pair + our positon\n    float subAreas[3];\n    subAreas[0] = getTriangleArea(vec2[3](coords[0], coords[1], point));\n    subAreas[1] = getTriangleArea(vec2[3](coords[0], point, coords[2]));\n    subAreas[2] = getTriangleArea(vec2[3](point, coords[1], coords[2]));\n    \n    // Calc total sum for triangles\n    float subArea;\n    for (int i = 0; i < subAreas.length(); i++)\n        subArea += subAreas[i];        \n    \n    // \"Distance\" to the triangle\n\treturn subArea - area;   \n}\n\nbool isPointInTriangle( vec2 coords[3], vec2 point ) {\n    // Allows to remove artifacts (larger value - less artifacts, but more inaccurate)\n    float deviation = 0.0001;\n    \n    // If point in the triangle (distance 0 or lower)\n    if (getDistanceTriangle(coords, point) - deviation <= 0.)\n        return true;\n    \n    return false;\n}\n\nvec2 getRotatedPoint(vec2 point, vec2 pivot, float angle) {\n    // Prepare transformation matrix\n    mat2x2 rotMtx;\n    rotMtx[0] = vec2(cos(angle), -sin(angle));\n    rotMtx[1] = vec2(sin(angle), cos(angle));\n    \n    // Make point relative start of coordinates, rotate and restore it\n    point -= pivot;    \n    point = rotMtx * point;    \n    point += pivot;\n    \n    return point;\n}\n\nvec2 getScaledPoint(vec2 point, vec2 pivot, float ratio) {\n    // Prepare transformation matrix\n    mat2x2 scalMtx;\n    scalMtx[0] = vec2(ratio, 0);\n    scalMtx[1] = vec2(0, ratio);\n    \n    // Make point relative start of coordinates, scale and restore it\n    point -= pivot;    \n    point = scalMtx * point;    \n    point += pivot;\n    \n    return point;\n}\n\nvec2 pointToUV(vec2 point) {\n\treturn point / iResolution.xy;   \n}\nvec2 uvToPoint(vec2 uv) {\n\treturn uv * iResolution.xy;   \n}\n\n\n\n\nvec4 figureRender(vec2 fragCoord, float ratio) {   \n    vec2 uv = pointToUV(fragCoord);\n    vec3 col = vec3(0., 0., 0.);\n    \n    // Coordinates of triangles (in UV)\n    vec2 coords[3];\n    coords[0] = vec2(0.5, 0.3);\n    coords[1] = vec2(0.3, 0.7);\n    coords[2] = vec2(0.7, 0.7);\n    \n    // Rotate & scale points by matrix\n    for (int i = 0; i < coords.length(); i++) {\n    \tcoords[i] = getRotatedPoint(coords[i], vec2(.5, .5), ratio + abs(sin(ratio)));\n        coords[i] = getScaledPoint(coords[i], vec2(.5, .5), abs(sin(ratio)) * .8 + .2);\n    }\n    \n\t// Get distance to the triangle\n    float dist = getDistanceTriangle(coords, uv);\n    dist = max(dist * 300., 1.);\n    col = vec3(1., 1., 1.) / dist;\n    \n    return vec4(col, 1.0);\n}\n\n\n\n// The entry point\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) { \n    float ratio = iTime;\n    \n    float pi = 3.1415;    \n    ratio += abs(sin(ratio));    \n    \n    vec2 shift = vec2(.14 * sin(ratio), .0);\n    \n    vec2 uv = pointToUV(fragCoord);\n    \n    vec4 colR = figureRender(uvToPoint(uv + shift), ratio) * vec4(1., 0., 0., 0.);\n    vec4 colG = figureRender(fragCoord, ratio) * vec4(0., 1., 0., 0.);\n    vec4 colB = figureRender(uvToPoint(uv - shift), ratio) * vec4(0., 0., 1., 0.);\n    \n    fragColor = colR + colG + colB;\n}","name":"Image","description":"","type":"image"}]}