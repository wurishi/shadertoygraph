{"ver":"0.1","info":{"id":"DtsSWS","date":"1675391818","viewed":304,"name":"Simple & Fast DDA-Accelerated RM","username":"myth0genesis","description":"This is my take on a cubic grid DDA-accelerated raymarcher. This was really just borne out of my failure to clearly understand existing implementations being used, so I just made my own from scratch.","likes":28,"published":1,"flags":0,"usePreview":0,"tags":["ray","raymarch","dda","hash","march","accelerated"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 2023 myth0genesis\n// I was trying to learn about a basic DDA algorithm and understood the general concept,\n// but had to admit I was having a difficult time trying to pick apart what was happening\n// in the code in actual implementations, so I made my own from scratch.\n// Hopefully it's easier to read and as fast as other DDA-accelerated raymarchers.\n// One of iq's plane intersection functions was adapted for the purpose (since it was only three operations)\n// and 7 out of the 8 SDFs (https://iquilezles.org/articles/distfunctions/) are his, as well, since they were fast and simple.\n// No fancy AA, DOF, motion blur, or raymarched shadows here for readability's sake, in case anyone wants to use this.\n\nconst int maxstps = 128;\nconst int maxcells = 100;\nconst float mindst = 0.001;\nconst float mapscale = 1.0;\n\nconst float pi = 3.1415927410125732421875;\nconst float tau = 6.283185482025146484375;\nconst uvec4 MB2 = uvec4(0x55555555U, 0xAAAAAAAAU, 0x33333333U, 0xCCCCCCCCU);\nconst float isq3 = 1.0 / sqrt(3.0);\nconst float sq3d3 = 0.57735025882720947265625;\nconst float sqrt2 = sqrt(2.0);\nconst float sqrt2d2 = sqrt2 * 0.5;\n\nconst float imf = 1.0 / float(0x7FFFFFFFU);\n\nuvec4 hsh;\nbvec4 hshtst0;\n\nuvec4 cnvrtFloatToUint(vec4 crds, float scale) {\n    return floatBitsToUint(floor(crds * scale));\n}\n\n// My own collision-free 128-bit hash: https://www.shadertoy.com/view/ctXXRn\nuvec4 hash128(uvec4 p) {\n    p *= uvec4(0xCAF649A9U, 0x735A2D97U, 0xD35A2D97U, 0x450C2D35U);\n    uvec4 m0 = p & MB2.x;\n    uvec4 m1 = p & MB2.y;\n    p = m0 | m1.yzwx;\n    p ^= p >> 16;\n    p *= uvec4(0xEAF649A9U, 0x6AF649A9U, 0x050C2D35U, 0xAAF649A9U);\n    m0 = p & MB2.x;\n    m1 = p & MB2.y;\n    p = m0 | m1.zwxy;\n    p ^= p >> 15;\n    p *= uvec4(0x21F0AAADU, 0x0D0C2D35U, 0xE8F649A9U, 0xD30332D3U);\n    m0 = p & MB2.z;\n    m1 = p & MB2.w;\n    p = m0 | m1.wxyz;\n    p *= uvec4(0xC865C965U, 0x4D0C2D35U, 0x930332D3U, 0x410C2D35U);\n    p ^= p >> 16;\n    return p;\n}\n\nmat2 rot2D(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s,\n                s,  c);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\n// Credit goes to yx: https://www.shadertoy.com/view/Ws23zt\nfloat sdTetra(vec3 p, float bnds) {\n    return (max(abs(p.x + p.y) - p.z, abs(p.x - p.y) + p.z) - bnds) * isq3;\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat sdCaps(vec3 p, float h, float r) {\n    p.y -= clamp(p.y, 0.0, h);\n    return length(p) - r;\n}\n\nfloat sdCyl(vec3 p, float h, float r) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r,h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdOcthd(vec3 p, float s) {\n    p = abs(p);\n    return (p.x + p.y + p.z - s) * sq3d3;\n}\n\nfloat sdCone(vec3 p, vec2 c, float h) {\n    float q = length(p.xz);\n    return max(dot(c.xy, vec2(q, p.y)), -h - p.y);\n}\n\nfloat map(vec3 pos, vec3 offs) {\n    pos -= offs + vec3(0.5, 0.5, 0.5);\n    pos *= mapscale;\n    float box = sdBox(pos, vec3(0.25));\n    float sphere = sdSphere(pos, 0.25);\n    float tetra = sdTetra(pos, 0.25);\n    float torus = sdTorus(pos.yzx, vec2(0.2, 0.05));\n    float capsule = sdCaps(pos + vec3(0.0, 0.15, 0.0), 0.3, 0.1);\n    float cylinder = sdCyl(pos, 0.3, 0.2);\n    float octhd = sdOcthd(pos, 0.25);\n    float cone = sdCone(pos - vec3(0.0, 0.225, 0.0), vec2(0.9, 0.3), 0.45);\n    \n    float d = hshtst0.x ?\n        (hshtst0.y ?\n            (hshtst0.z ? box : sphere) :\n            (hshtst0.z ? tetra : torus)) :\n        (hshtst0.y ?\n            (hshtst0.z ? capsule : cylinder) :\n            (hshtst0.z ? octhd : cone));\n\n    return d / mapscale;\n}\n\nvec4 iPlane(vec3 ro, vec3 rd, vec3 offst) {\n    vec3 pRes = (-ro + offst) / rd;\n    float md = min(min(pRes.x, pRes.y), pRes.z);\n    \n    // .xyz values return a factor to mask out the next potential cell ID's offset\n    // If plane in x direction is closest, .xyz = vec3(1.0, 0.0, 0.0)\n    // If plane in y direction is closest, .xyz = vec3(0.0, 1.0, 0.0)\n    // If plane in z direction is closest, .xyz = vec3(0.0, 0.0, 1.0)\n    // .w returns distance to closest plane\n    return vec4(vec3(equal(pRes, vec3(md))), md);\n}\n\nvec3 rayMarchDDA(inout vec3 ro, vec3 rd, vec3 id, vec3 rdsgn, out bool sdfht, out vec3 pf) {\n    bool plnht = false;\n    vec3 mf = max(rdsgn, 0.0);  // The amount to offset the plane position from the cell by (determined by ray direction)\n    vec3 qo = id + mf;          // The cell's planes' positions (along each of their respective axes)\n    vec4 hRes = iPlane(ro, rd, qo);\n    pf = hRes.xyz;\n\tfloat dO = 0.0;\n    float ns = 0.0;\n    for(int i = 0; i < maxstps; i++) {\n        ns += 1.0;\n    \tvec3 p = ro + rd * dO;\n        float dS = map(p, id);\n        dO += dS;\n        sdfht = abs(dS) < mindst;\n        plnht = dO > hRes.w;\n        if(sdfht || plnht) break;\n    }\n    \n    // If a plane is hit, set ro to the plane's hit position\n    // If a plane isn't hit, set ro to the pixel's starting position to calculate normals\n    ro = plnht ? (ro + rd * hRes.w) : ro;\n    \n    // y returns distance to the closest plane\n    // z returns the number of steps the ray marcher took (both for debugging)\n    return vec3(dO, hRes.w, ns);\n}\n\nvec3 getNormal(vec3 p, vec3 offs) {\n    vec2 e = vec2(.001, 0.0);\n    vec3 n = map(p, offs) -\n        vec3(map(p - e.xyy, offs), map(p - e.yxy, offs), map(p - e.yyx, offs));\n    \n    return normalize(n);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 m = (all(equal(iMouse.xy, vec2(0.0)))) ? (vec2(0.5)) : (-iMouse.xy / iResolution.xy);\n    \n    vec3 ro = vec3(0.0, 0.0, iTime);\n    mat2 rmxz = rot2D(m.x * tau + pi);\n    mat2 rmyz = rot2D(m.y * tau + pi);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.0));\n    rd.yz *= rmyz;\n    rd.xz *= rmxz;\n    vec3 col = vec3(0.0);\n\n    vec3 sgn = sign(rd);\n    bool sdfhit = false;\n    vec3 id = floor(ro);\n    vec3 plnmask;\n    vec3 mRes = vec3(0.0);\n    \n    for (int i = 0; i < maxcells; i++) {\n        hsh = hash128(floatBitsToUint(vec4(id, 1.0)));\n        hshtst0 = bvec4(hsh & 1U);\n        \n        // If a cell boundary is hit, raymarch from that position in the next step\n        mRes = rayMarchDDA(ro, rd, id, sgn, sdfhit, plnmask);\n        if (sdfhit) break;\n        \n        id += sgn * plnmask; // Advance cell ID with a mask determined by plane intersection function\n    }\n    \n    vec3 p = ro + rd * mRes.x;\n    vec3 n = getNormal(p, id);\n    float dif = dot(n, normalize(vec3(1.0, 2.0, 0.0))) * 0.45 + 0.55;\n    \n    col = sdfhit ? (vec3(hsh.xyz >> 1) * imf * dif) : col;\n    \n    // Uncomment below to see the number of steps the raymarcher takes in each cell (blue = 0, red = maxstps)\n//    col = sdfhit ? mix(vec3(0.0, 0.0, 1.0), vec3(1.0, 0.0, 0.0), mRes.z / float(maxstps)) : col;\n    col = pow(col, vec3(0.4545));\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}