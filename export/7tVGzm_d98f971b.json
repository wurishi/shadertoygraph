{"ver":"0.1","info":{"id":"7tVGzm","date":"1637422180","viewed":119,"name":"metaball character test","username":"Ornibulon","description":"Test to assemble a character with metaballs and render a sdf with an attempt at sphere-tracing.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","metaball","head"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float PI = 3.14159265;\n\nmat3 rotMatrix(vec3 rotation){\n    rotation *= PI/180.;\n    float rx = rotation.x;\n    float ry = rotation.y;\n    float rz = rotation.z;\n    \n    mat3 rotationX = mat3( 1      , 0      , 0      ,\n                           0      , cos(rx),-sin(rx),\n                           0      , sin(rx), cos(rx));\n                          \n    mat3 rotationY = mat3( cos(ry), 0      , sin(ry),\n                          0       , 1      , 0      ,\n                          -sin(ry), 0      , cos(ry));\n                          \n    mat3 rotationZ = mat3( cos(rz),-sin(rz), 0      ,\n                           sin(rz), cos(rz), 0      ,\n                           0      , 0      , 1);\n                           \n    return rotationX * rotationY * rotationZ;\n}\n\n\nfloat sphere(vec3 position, vec3 center, float size){\n    return length(position-center)-size;\n}\n\n\nfloat metaball(vec3 position, vec3 center, vec3 rotation, vec3 scale){\n    float size = 2.;\n    float l = length(rotMatrix(rotation)*(position-center)/(scale));\n    return -1./l/l/l/l*size;\n}\n\n/*\nfloat sq(float a){\n    return a*a;\n}\n\nvec3 sq(vec3 a){\n    return a*a;\n}\n\nfloat metaball(vec3 position, vec3 center, vec3 rotation, vec3 scale)\n{\n    float size = 0.81;\n    float l = length(rotMatrix(rotation)*(position-center)/(scale));\n \treturn -sq(size) / sq(l);\n}*/\n\nfloat head(vec3 position){\n    return \n            metaball(position, vec3(0.,0.,0.), vec3(0,0,0), vec3(0.671,1,1))\n          + metaball(position, vec3(0.,-0.5,-0.9), vec3(0,0,0), vec3(0.400,0.472,0.538))\n          // jaw\n          + metaball(position, vec3(0.3,-0.3,0.1), vec3(0,0,0), vec3(0.450,0.472,0.538))\n          + metaball(position, vec3(-0.3,-0.3,0.1), vec3(0,0,0), vec3(0.450,0.472,0.538))\n          // ears\n          + metaball(position, vec3(1.,0.71,0.47), vec3(0,60,-50), vec3(0.2,0.75,0.415))\n          + metaball(position, vec3(-1.,0.71,0.47), vec3(0,-60,50), vec3(0.2,0.75,0.415))\n          // ears interior\n          - metaball(position, vec3(1.2,0.8,0.32), vec3(0,60,-50), vec3(0.07,0.40,0.255))/1.5\n          - metaball(position, vec3(-1.2,0.8,0.32), vec3(0,-60,50), vec3(0.07,0.40,0.255))/1.5\n          // neck\n          + metaball(position, vec3(0,-1.729,0.15), vec3(-1.6,0,0), vec3(0.363,0.683,0.435))\n          + metaball(position, vec3(1.04,-2.64,0.383), vec3(0,0,0), vec3(0.671,0.671,0.671))\n          + metaball(position, vec3(-1.04,-2.64,0.383), vec3(0,0,0), vec3(0.671,0.671,0.671))\n          + metaball(position, vec3(0,-2.729,0.15), vec3(0,0,0), vec3(0.6,0.6,0.6))\n          // left brow\n          + metaball(position, vec3(0.9-0.1,0.45,-0.33), vec3(35.6,-7.,0), vec3(0.213,0.162,0.269))\n          + metaball(position, vec3(0.647-0.1,0.49,-0.55), vec3(20, 0, 0), vec3(0.213,0.184,0.269))\n          + metaball(position, vec3(0.86-0.1,0.02,-0.41), vec3(0, 0, 0), vec3(0.213,0.158,0.269))\n          - metaball(position, vec3(0.66-0.1,0.13,-1.21), vec3(0, 0, 0), vec3(0.15,0.15,0.3))\n          // right brow\n          + metaball(position, vec3(-0.9+0.1,0.45,-0.33), vec3(35.6,7.,0), vec3(0.213,0.162,0.269))\n          + metaball(position, vec3(-0.647+0.1,0.49,-0.55), vec3(-20, 0, 0), vec3(0.213,0.184,0.269))\n          + metaball(position, vec3(-0.86+0.1,0.02,-0.41), vec3(0, 0, 0), vec3(0.213,0.158,0.269))\n          - metaball(position, vec3(-0.66+0.1,0.13,-1.21), vec3(0, 0, 0), vec3(0.15,0.15,0.3))\n          // end\n          + 1.\n            ;\n}\n\n/*\nfloat sdf(vec3 position){\n    return \n            min(sphere(position, vec3(1.5*sin(iTime),0,3.+1.5*cos(iTime)), 0.3),\n               max(sphere(position, vec3(0,0,3), 1.), \n                   -min(sphere(position, vec3(.2,.2+0.04*sin(10.*iTime),2.1), .2),\n                        sphere(position, vec3(.6,.2+0.04*sin(10.*iTime),2.3), .2)\n               \n           )));\n}*/\n\n\nfloat sdf(vec3 position){\n    return \n            min(max(head(position), \n                -min(sphere(position, vec3(0.18, -0.26, -1.468), 0.06), \n                     sphere(position, vec3(-0.18, -0.26, -1.468), 0.06))),\n            min(sphere(position, vec3(0.81-0.12, 0.27, -0.468), 0.4),\n                sphere(position, vec3(-0.81+0.12, 0.27, -0.468), 0.4)\n            ));\n}\n\n\nfloat sdfIntersect(out bool intersect, out vec3 position, out vec3 normal, in vec3 rayOrigin, in vec3 rayDir){\n    float advStep = .1;\n    int dichoSteps = 10;\n    \n    vec3 rayPos = rayOrigin;\n    \n    float sdfValue = 10.;//sdf(rayPos);\n    float newSdfValue = sdf(rayPos);\n    int nbSteps = 0;\n    vec3 a = rayPos;\n    vec3 b = rayPos;\n    while (newSdfValue >= 0.){\n        //rayPos += rayDir*advStep;  //constant step\n        rayPos += (newSdfValue/3.4+0.01)*rayDir;\n        a = b;\n        b = rayPos;\n        /*\n        if (newSdfValue < sdfValue) {\n            rayPos += (newSdfValue/3.+0.01)*rayDir;\n        } else {\n            rayPos += (0.01)*rayDir;\n        }*/\n       \n        sdfValue = newSdfValue;\n        newSdfValue = sdf(rayPos);\n        \n        /*\n        if (newSdfValue > sdfValue){\n            intersect = false;\n            return;\n        }*/\n        \n        if (nbSteps > 100 || sdfValue > .998){\n            intersect = false;\n            return 0.;\n        }\n        \n        nbSteps += 1;\n    }\n    \n    // dichotomy\n    //vec3 a = rayPos - rayDir*advStep;\n    //vec3 b = rayPos;\n    vec3 ab = vec3(0,0,0);\n    float sdfA;\n    float sdfB;\n    float sdfAB;\n    for (int i; i<dichoSteps; i++){\n        sdfA = sdf(a);\n        sdfB = sdf(b);\n        \n        ab = (a+b)*0.5;\n        sdfAB = sdf(ab);\n        \n        if (sdfAB < 0.){\n            b = ab;\n        } else {\n            a = ab;\n        }\n    }\n    sdfValue = sdfAB;\n    \n    intersect = true;\n    position = ab;\n    \n    float epsilon = 0.0001;\n    vec3 preNormal = vec3(sdf(position + epsilon*vec3(1,0,0)) - sdfValue,\n                          sdf(position + epsilon*vec3(0,1,0)) - sdfValue,\n                          sdf(position + epsilon*vec3(0,0,1)) - sdfValue);\n                     \n    normal = normalize(preNormal);\n    \n    return length(preNormal);\n}\n\n\nvec3 light(in vec3 lightsource, in vec3 color, in vec3 position, in vec3 normal){\n    bool intersect = false;\n    vec3 position2 = vec3(0,0,0);\n    vec3 normal2 = vec3(0,0,0);\n    \n    vec3 rayDir = normalize(lightsource - position); \n    vec3 rayOrigin = position + 0.1*rayDir;\n    \n    sdfIntersect(intersect, position2, normal2, rayOrigin, rayDir);\n    \n    if (intersect){\n        return vec3(0,0,0);\n    } else {\n        return color * dot(normal, rayDir);\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - vec2(0.5, 0.5);\n    \n    vec2 sensorDims = vec2(16, 9);\n    float focal = 10.;\n    \n    bool intersect = false;\n    vec3 position = vec3(0,0,0);\n    vec3 normal = vec3(0,0,0);\n    \n    float time = iTime;\n    \n    vec3 rayOrigin = vec3(5.*sin(time),0,-5.*cos(time));\n    vec3 rayDir = normalize(vec3(uv.x*sensorDims.x, uv.y*sensorDims.y, focal));\n    \n    mat3 rotation = mat3( cos(time), 0       , sin(time),\n                          0        , 1       , 0        ,\n                          -sin(time), 0       , cos(time));\n                         \n    rayDir = rotation * rayDir;\n    \n    float pointiness = sdfIntersect(intersect, position, normal, rayOrigin, rayDir);\n    \n    vec3 col = vec3(1,1,1);\n    if (intersect){\n        //col = 0.5*normal + vec3(0.5, 0.5, 0.5);//vec3(1,1,1);   //vec3(0.4, 0.4, 0.8)\n        col = light(vec3(5,5,-4), vec3(1,1,1), position, normal) + light(vec3(-3,1,1), vec3(0.4, 0.4, 0.8), position, normal);\n        if (pointiness*1000. > 0.15){\n            col *= vec3(1,.8,.8)*(1.-min(0.6,max(0., pointiness*1000.)));\n        }\n    } else {\n        col.x = (uv.y+.5)/4.;\n        col.y = (uv.y+.5)/4.;\n        col.z = .1+(uv.y+.5)/4.;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}