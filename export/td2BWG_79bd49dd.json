{"ver":"0.1","info":{"id":"td2BWG","date":"1590840754","viewed":335,"name":"Coffee chat","username":"dean_the_coder","description":"Webcam projected onto a coffee cup.\nPerfect for those virtual 'Covid' coffee chats (with MemixApp, or similar).","likes":13,"published":1,"flags":2,"usePreview":0,"tags":["procedural","3d","raymarching","webcam","covid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Set to zero for a better frame rate.\n#define REFLECTIONS 1\n\nfloat hash(vec2 p) {\n    return fract(sin(dot(p, vec2(123.45, 875.43))) * 5432.3);\n}\n\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n    float a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n    f = f * f * (3.0 - 2.0 * f); // smoothstep with no clamp.\n    \n    return mix(a, b, f.x) +\n            (c - a) * f.y * (1.0 - f.x) +\n            (d - b) * f.x * f.y;\n}\n\nfloat fbm(vec2 p) {\n\tfloat f = 0.0;\n    f += 0.5 * noise(p * 1.1);\n    f += 0.22 * noise(p * 2.3);\n    f += 0.155 * noise(p * 3.9);\n    f += 0.0625 * noise(p * 8.4);\n    f += 0.03125 * noise(p * 15.0);\n    \n    return f;\n}\n\nvec3 vignette(vec3 col, vec2 fragCoord) {\n    vec2 q = fragCoord.xy / iResolution.xy;\n    col *= 0.5 + 0.5 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.4);\n    return col;\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdCylinder(vec3 p, vec2 rh) {\n    return max(length(p.xz) - rh.x, abs(p.y) - rh.y);\n}\n\nvec3 opElongate(vec3 p, vec3 h) {\n    return p - clamp( p, -h, h );\n}\n\nfloat sdCup(vec3 p) {\n    float d = sdTorus(opElongate(p, vec3(0.0, 1.0, 0.0)), vec2(1.0, 0.05));\n    \n    vec3 pp = p;\n    pp.y += 0.4;\n    pp.y -= pp.x * 0.5;\n    pp.xy -= vec2(1.0, 0.0);\n    pp.zy *= rot(3.14159 * 0.5);\n    return smin(d, sdTorus(pp, vec2(0.6, mix(0.08, 0.06, p.y))), 0.15);\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    return normalize(forward + right * uv.x + up * uv.y);\n}\n\nvec2 dmin(vec2 d1, vec2 d2) {\n    return d1.x < d2.x ? d1 : d2;\n}\n\nvec2 map(vec3 p) {\n    vec2 d1 = vec2(sdCup(p), 1.5);\n    \n    vec3 pp = p;\n    pp.xy *= rot(sin(iTime) * 0.05);\n    pp.y -= sin(length(pp.xz) * 10.0 + iTime) * 0.02;\n    vec2 d2 = vec2(sdCylinder(pp, vec2(1.0, 0.85)), 2.5); // Coffee\n    vec2 d3 = vec2(abs(p.y + 1.1), 3.5); // Table\n    \n    return dmin(d1, dmin(d2, d3));\n}\n\nvec3 calcNormal(in vec3 p) {\n    // Thanks iq!\n    vec2 e = vec2(1.0, -1.0) * 0.5773 * 0.0005;\n    return normalize(e.xyy * map(p + e.xyy).x + \n\t\t\t\t\t e.yyx * map(p + e.yyx).x + \n\t\t\t\t\t e.yxy * map(p + e.yxy).x + \n\t\t\t\t\t e.xxx * map(p + e.xxx).x);\n}\n\nfloat calcShadow(vec3 p, vec3 lightPos, float sharpness) {\n    vec3 rd = normalize(lightPos - p);\n    \n    float h;\n    float minH = 1.0 / sharpness;\n    for (float d = 0.1; d < 32.0; d += h) {\n        h = max(0.0, map(p + rd * d).x);\n        minH = min(minH, h / d);\n        if (minH < 0.01)\n            break;\n    }\n    \n    return minH * sharpness;\n}\n\nfloat calcOcc(vec3 p, vec3 n, float strength) {\n    const float dist = 0.3;\n    return 1.0 - (dist - map(p + n * dist).x) * strength;\n}\n\nint march(vec3 ro, vec3 rd, out vec3 p) {\n    float d = 0.01;\n    for (float steps = 0.0; steps < 128.0; steps++) {\n        p = ro + rd * d;\n        vec2 h = map(p);\n        if (h.x < 0.001 * d) {\n            return int(h.y);\n        }\n\n        d += h.x;\n    }\n    \n    return 0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    // Raymarch.\n    float camTime = clamp(iTime - 4.0, 0.0, 4.0) / 4.0;\n    vec2 cyz = mix(vec2(2.0, -2.0), vec2(0.6, -1.2), smoothstep(0.0, 1.0, camTime));\n    vec3 ro = 2.5 * vec3(0.2, cyz);\n    ro.xy += clamp(iTime - 8.0, 0.0, 1.0) * vec2(sin(iTime - 8.0) * 0.05, 0.0);\n    vec3 rd = getRayDir(ro, vec3(0.0), uv);\n\n    vec3 rgb;\n    vec3 p;\n    float ref = 1.0;\n    for (int i = 0; i <= REFLECTIONS; i++) {\n        int hit = march(ro, rd, p);\n\n        if (hit > 0) {\n            vec3 n = calcNormal(p);\n            vec3 lightPos = vec3(20.0, 15.0, -15.0);\n            vec3 lightCol = vec3(1.0, 0.9, 0.8);\n            vec3 lightToPoint = normalize(lightPos - p);\n            vec3 skyCol = vec3(0.15, 0.2, 0.25);\n            float sha = calcShadow(p, lightPos, 5.0);\n            float occ = calcOcc(p, n, 4.0);\n            float spe = pow(max(0.0, dot(rd, reflect(lightToPoint, n))), 15.0);\n            vec3 mainLight = clamp(dot(n, lightToPoint), 0.01, 1.0) * lightCol;\n            vec3 backLight = clamp(dot(n, -rd), 0.01, 1.0) * 0.1 * lightCol;\n            vec3 skyLight = clamp(dot(n, vec3(0.0, 1.0, 0.0)), 0.01, 1.0) * 0.4 * skyCol;\n            float d = length(p - ro);\n            float fog = 1.0 - exp(-max(0.0, d - 8.0) * 0.06);\n            float shiny;\n\n            vec3 mat;\n            if (hit == 1) {\n                // Cup.\n                vec2 wuv = p.xy * 0.7;\n                wuv.x *= iResolution.y / iResolution.x;\n                wuv.xy += vec2(0.45, 0.4);\n                if (abs(wuv.x - 0.5) > 0.35 || abs(wuv.y - 0.5) > 0.5 || p.z > 0.0)\n                    mat = vec3(0.5, 0.51, 0.49);\n                else\n                    mat = texture(iChannel0, wuv).rgb;\n                shiny = 0.3;\n            } else if (hit == 2) {\n                // Coffee.\n                mat = vec3(0.43, 0.3, 0.22);\n                shiny = 0.2;\n            } else if (hit == 3) {\n                // Table.\n                mat = vec3(0.6, 0.3, 0.18);\n                vec3 pp = p;\n                pp.x -= 5.6;\n                pp.xz *= rot(2.2);\n                mat *= 0.4 + 0.6 * abs(sin((3.0 + pp.x) * 0.8 * (5.0 + fbm(pp.xz * 0.8))));\n                shiny = 0.1;\n            }\n\n            vec3 col = mainLight * lightCol * sha;\n            col += backLight * occ;\n            col += skyLight * occ;\n            col += spe * lightCol * occ;\n            col *= mat;\n\t\t\tcol = mix(col, skyCol, fog);\n            \n            rgb += col * ref;\n\n\n            rd = reflect(rd, n);\n            ref *= shiny;\n            ro = p;\n        } else {\n            // Sky.\n            rgb += vec3(0.15, 0.2, 0.25) * ref;\n            break;\n        }\n    }\n\n    // Output to screen\n    rgb = pow(rgb, vec3(0.4545));\n    fragColor = vec4(vignette(rgb, fragCoord), 1.0);\n}","name":"Image","description":"","type":"image"}]}