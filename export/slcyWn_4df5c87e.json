{"ver":"0.1","info":{"id":"slcyWn","date":"1659549764","viewed":96,"name":"Mand3lbulb fixed for cyanux","username":"timeparticle","description":"I debugged cyanux's Mand3lbulb as a way to get my head back into things a bit.\n[This currently works in my versions of Firefox, Chrome, Edge, but NOT Tor.]","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["mandelbulb","fix","timeparticle","cyanux"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by vincent francois - cyanux/2014\n// Creative Commons Attribution-NonCommercial-NoDerivs 3.0 Unported License (CC BY-NC-ND 3.0)\n\n#define D 2.0\n\n//vec2 M = 8.0 * (iMouse.xy / iResolution.xy - 0.5);\n\nvec3 rX(vec3 v, float t) {\n\tfloat COS = cos(t);\n\tfloat SIN = sin(t);\n\treturn vec3(v.x,SIN*v.z+COS*v.y,COS*v.z-SIN*v.y);\n}\nvec3 rY(const vec3 v, const float t) {\n\tfloat COS = cos(t);\n\tfloat SIN = sin(t);\n\treturn vec3(COS*v.x-SIN*v.z, v.y, SIN*v.x+COS*v.z);\n}\n// hsv2rgb - iq / https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( in vec3 c ) {\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\nfloat sdSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\nbool is_dC = false;\nfloat L;\n\nfloat scene(vec3 p) {\n\tfloat dCM = -sdSphere(p, 16.0);\t\n\tvec3 v=p;\n\tvec3 c=v;\n\tfloat r=0.0;\n\tfloat d=1.0;\n\tfloat P = 2.0 + abs(sin(iTime * 0.04)) * 14.0;\n\tfor(float n=0.0;n<=32.0;n++)\n\t{\n\t\tr=length(v);\n\t\tif(r>2.0) break;\n\t\tfloat theta=acos(v.z/r) * P;\n\t\tfloat phi =atan(v.y,v.x) * P;\n\t\td=pow(r,P-1.0)*P*d+1.0;\n\t\tv=pow(r, P) * vec3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta)) + c;\n\t\tL = r;\n\t}\n\tfloat dO = 0.50*log(r)*r/d;\t\n\tbool is_dCM = dCM < dO ? true : false;\n\treturn min(dO, dCM);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 M = 8.0 * (iMouse.xy / iResolution.xy - 0.5);\n    \n\tvec2 ar = vec2(iResolution.x/iResolution.y, 1.0);\n\tvec2 uv = ar * (fragCoord.xy / iResolution.xy - 0.5);\n\tvec3 ro = -rY(rX(vec3(0.0, 0.0, D) , M.y), M.x);\n\tvec3 co = ro;\n\tvec3 rd = normalize(rY(rX(vec3(uv, 1.0), M.y), M.x));\n\tfloat d;\n\tfor(float n = 0.0; n < 200.0; n++) {\n\t\td = scene(ro);\n\t\tif(d < 0.002)\n\t\t\tbreak;\n\t\tro += rd * d * 0.5;\n\t}\n    \n    bool is_dCM = true;\n    \n\tif(is_dCM == true)\n\t{\n\t\tfragColor = texture(iChannel0, ro);\n\t\treturn;\n\t}\n\tvec3 g = vec3(\n\t\tscene(ro + vec3(0.002, 0.000, 0.000)),\n\t\tscene(ro + vec3(0.000, 0.002, 0.000)),\n\t\tscene(ro + vec3(0.000, 0.000, 0.002)));\n\n\tg = normalize(g - d);\n\tvec3 c = hsv2rgb(vec3(dot(ro, ro), 1.0, L * L - 0.7));\n\tfragColor.rgb = mix(texture(iChannel0, reflect(rd, g)).rgb, c, 0.3);\n}\n","name":"Image","description":"","type":"image"}]}