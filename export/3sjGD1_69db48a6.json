{"ver":"0.1","info":{"id":"3sjGD1","date":"1548751699","viewed":126,"name":"cloud_0001","username":"kuma720","description":"cloud","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["cloud"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float noise(vec3 uv) {\n  return fract( sin( dot( uv ,vec3(123.,65.,44.) ) ) * 4811.424 );\n}\n\nfloat pnoise(vec3 uv,float f) {\n\n  vec3 t = uv * f;\n  vec3 v1 = floor(t);\n  vec3 v2 = fract(t);\n\n  float a0 = noise(v1 + vec3(0.,0.,0.));\n  float b0 = noise(v1 + vec3(1.,0.,0.));\n  float c0 = noise(v1 + vec3(0.,1.,0.));\n  float d0 = noise(v1 + vec3(1.,1.,0.));\n\n  float a1 = noise(v1 + vec3(0.,0.,1.));\n  float b1 = noise(v1 + vec3(1.,0.,1.));\n  float c1 = noise(v1 + vec3(0.,1.,1.));\n  float d1 = noise(v1 + vec3(1.,1.,1.));\n\n  float o1 = mix(a0,b0,v2.x);\n  float o2 = mix(c0,d0,v2.x);\n  float o3 = mix(o1,o2,v2.y);\n\n  float o4 = mix(a1,b1,v2.x);\n  float o5 = mix(c1,d1,v2.x);\n  float o6 = mix(o4,o5,v2.y);\n\n  float o7 = mix(o3,o6,v2.z);\n  \n  return o7;\n}\n\nfloat fbm(vec3 uv , float f ) {\n  float o = 0.;\n  float n = 1.;\n  \n  for ( int i = 0 ; i < 5 ; ++ i ) {\n    o += pnoise( uv , f ) * n;\n    f *= 2.; \n    n *= 0.5;\n  }\n\n  return o;\n}\n\n\nmat4 createVTW(vec3 eye,vec3 center,vec3 up) {\n  vec3 f = normalize( center - eye );\n  vec3 s = normalize( cross(f,up) );\n  vec3 u = cross(s,f);\n  return mat4(\n    vec4(s,0.),\n    vec4(u,0.),\n    vec4(-f,0.),\n    vec4(0.,0.,0.,1)\n  );\n}\n\n\nvec3 rayDirection(float fieldofView,vec2 size,vec2 fragCoord) {\n  vec2 xy = fragCoord - size / 2.0;\n  float z = size.y / tan(radians(fieldofView) / 2.0 );\n  return normalize(vec3(xy,-z));\n}\n\n\nfloat sdf(vec3 p) {\n  vec3 p2 = p + vec3( iTime * .15 , iTime * -.08 , iTime * -.12 );\n\n  float l0 = length( p + vec3(-0.9,0.2,-0.4) ) - 0.5;\n  float l1 = length( p + vec3(0.5,0.6,-0.4) ) - 1.0;\n  float l2 = min(l0,l1);\n\n  float l4 = fbm( p2 , 4.0 ) - 1.0;\n  float l5 = mix ( l2 , l4 , .6 );\n\n  return l5;\n}\n\n\nvec3 createnormal(vec3 p) {\n\n  float e = 0.0001;\n\n  return normalize( vec3(\n    sdf( vec3(p.x+e,p.y,p.z) ) - sdf( vec3(p.x-e,p.y,p.z) ) ,\n    sdf( vec3(p.x,p.y+e,p.z) ) - sdf( vec3(p.x,p.y-e,p.z) ) ,\n    sdf( vec3(p.x,p.y,p.z+e) ) - sdf( vec3(p.x,p.y,p.z-e) )\n  ));\n\n}\n\n\nfloat lighting( vec3 p ) {\n\n  vec3 lightvec = normalize( vec3( 1.0 ,1.0, 0.0) );\n\n  vec3 normal = createnormal(p);\n  vec3 s = p + normal * 0.01;\n\n  float result = 1.;\n  float depth = 0.;\n  float minlight = .1;\n\n  for( int I=0; I< 15 ; ++I ) {\n    \n    vec3 p2 = s + lightvec * depth;\n    float len = sdf(p2);\n    result = min( result , len * 3.6 / depth + minlight );\n    depth += len ;\n\n    if( len < 0.001 ) {\n      result = minlight;\n      break;\n    }\n\n  }\n\n  return result;\n\n}\n\n\nvec4 render( vec2 fragCoord , vec3 eye , vec3 worldDir , float start , float end ) {\n\n  vec3 sky = vec3(0.3,0.4,0.65);\n  float result = 0.;\n  float ratio = 0.;\n\n  float depth = start;\n  for(int I=0;I<30;++I) {\n\n    vec3 p = eye + worldDir * depth;\n    float len = sdf(p);\n    depth += max(len,0.01);\n    \n    if( len < 0.01 ) {\n      float l = lighting( p );\n      result = mix( result , l , .1 );\n      ratio += 0.1;\n    }\n\n  }\n\n  vec3 cloud = vec3(result);\n  vec3 o = sky + cloud * 6.;\n  return vec4( o , 1. );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord * (1.0/iResolution.x) - vec2(0.5, 0.5);\n    \n    vec3 eye = vec3(8.,8.,5.);\n    vec3 center = vec3(0.,0.,0.);\n    vec3 up = vec3(0.,1.,0.);\n    mat4 vtw = createVTW(eye,center,up);\n\n    vec3 viewDir = rayDirection(45.,iResolution.xy,fragCoord);\n    vec3 worldDir = (vtw * vec4(viewDir,0.)).xyz;\n\n   fragColor = render( fragCoord , eye , worldDir , 0. , 1000. );\n}","name":"Image","description":"","type":"image"}]}