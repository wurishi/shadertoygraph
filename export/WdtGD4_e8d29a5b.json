{"ver":"0.1","info":{"id":"WdtGD4","date":"1568557377","viewed":156,"name":"3D Dual Vector Distance Estimate","username":"skye_adaire","description":"This uses a vector3 of dual real numbers to compute the distance estimate and normal of an implicit surface. A variety of algebraic surfaces are shown https://en.wikipedia.org/wiki/List_of_complex_and_algebraic_surfaces","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["distance","dual","automatic","algebraic","differentiation","estimate"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//created by Skye Adaire\n\n#define pi32 3.1415926535\n#define tau32 6.2831853072\n#define eps32 10e-15\n\n//begin Hypercomplex\n\n#define Real float\n#define Nat uint\n\nReal H_negate(Real r)\n{\n    return -r;\n}\n\nReal H_conjugate(Real r)\n{\n    return r;\n}\n\nReal H_norm(Real r)\n{\n    return abs(r);\n}\n\nReal H_sqnorm(Real r)\n{\n    return r * r;\n}\n\nReal H_inverse(Real r)\n{\n \treturn 1.0 / r;   \n}\n\nReal H_add(Real lhs, Real rhs)\n{\n    return lhs + rhs;\n}\n\nReal H_subtract(Real lhs, Real rhs)\n{\n    return lhs - rhs;\n}\n\nReal H_multiply(Real lhs, Real rhs)\n{\n    return lhs * rhs;\n}\n\nReal H_divide(Real lhs, Real rhs)\n{\n    return lhs / rhs;\n}\n\nbool H_isZero(Real r)\n{\n    return H_norm(r) < eps32;\n}\n\nReal H_power(Real x, Real e)\n{\n    return pow(x, e);\n}\n\nReal H_power(Real x, Nat e)\n{\n    return pow(abs(x), float(e)) * ((e % 2u) == 0u ? 1.0 : sign(x));\n}\n\nReal H_sq(Real r)\n{\n    return r * r;\n}\n\nReal H_sin(Real r)\n{\n    return sin(r);\n}\n\nReal H_cos(Real r)\n{\n    return cos(r);\n}\n\n#define DualReal vec2\n\nDualReal D_add(DualReal lhs, DualReal rhs)\n{\n    return lhs + rhs;\n}\n\nDualReal D_subtract(DualReal lhs, DualReal rhs)\n{\n    return lhs - rhs;\n}\n\nDualReal D_multiply(DualReal lhs, DualReal rhs)\n{\n    return DualReal(\n        H_multiply(lhs[0], rhs[0]),\n        H_add(H_multiply(lhs[1], rhs[0]), H_multiply(lhs[0], rhs[1])));\n}\n\nDualReal D_divide(DualReal lhs, DualReal rhs)\n{\n    return DualReal(\n        H_divide(rhs[0], lhs[0]),\n        H_divide(\n            H_subtract(H_multiply(lhs[1], rhs[0]), H_multiply(lhs[0], rhs[1])),\n            H_sq(rhs[0])));\n}\n\nDualReal D_power(DualReal d, Real exponent)\n{\n    return DualReal(\n        H_power(d[0], exponent),\n        H_multiply(exponent * H_power(d[0], exponent - 1.0), d[1]));\n}\n\nDualReal D_power(DualReal d, Nat exponent)\n{\n    return DualReal(\n        H_power(d[0], exponent),\n        H_multiply(float(exponent) * H_power(d[0], exponent - 1u), d[1]));\n}\n\nDualReal D_sq(DualReal d)\n{\n \treturn D_multiply(d, d);   \n}\n\nDualReal D_inverse(DualReal d)\n{\n    return DualReal(\n        H_inverse(d[0]),\n        H_multiply(H_negate(H_inverse(H_sq(d[0]))), d[1]));\n}\n\nDualReal D_sin(DualReal d)\n{\n \treturn DualReal(\n        H_sin(d[0]), \n        H_multiply(d[1], H_cos(d[0])));   \n}\n                          \nDualReal D_cos(DualReal d)\n{\n \treturn DualReal(\n        H_cos(d[0]),\n        H_multiply(H_negate(d[1]), H_sin(d[0])));   \n}\n\n#define DualVector2 mat2x2\n#define DualVector3 mat3x2\n\n//end Hypercomplex\n\nDualReal f(int index, DualVector3 d)\n{\n    switch(index)\n    {\n     \tcase 1:\n        //https://en.wikipedia.org/wiki/Fermat_cubic\n    \treturn \n            D_power(d[0], 3u) + \n            D_power(d[1], 3u) + \n            D_power(d[2], 3u) - \n            DualReal(1,0); \n        \n        case 2:\n        //https://en.wikipedia.org/wiki/Roman_surface\n    \treturn\n            D_multiply(D_sq(d[0]), D_sq(d[1])) + \n            D_multiply(D_sq(d[1]), D_sq(d[2])) + \n            D_multiply(D_sq(d[2]), D_sq(d[0])) -\n            D_multiply(d[0], D_multiply(d[1], d[2]));\n        \n        case 3:\n        //https://en.wikipedia.org/wiki/Monkey_saddle\n    \treturn \n            d[2] - \n            D_power(d[0], 3u) + \n            D_multiply(DualReal(3,0), D_multiply(d[0], D_sq(d[1])));\n        \n        case 4:\n        //https://en.wikipedia.org/wiki/Whitney_umbrella\n        return \n            D_sq(d[0]) - \n            D_multiply(d[2], D_sq(d[1]));\n        \n        case 5:\n        //https://en.wikipedia.org/wiki/Cayley%27s_ruled_cubic_surface\n        return \n            D_multiply(DualReal(3,0), d[2]) - \n            D_multiply(DualReal(3,0), D_multiply(d[0], d[1])) + \n            D_power(d[0], 3u);\n       \n        case 6:\n        //hyperbolic paraboloid\n        return D_sq(d[0]) - D_sq(d[1]) - d[2];\n        \n        case 7:\n        //lemniscate of bernoulli\n        DualReal a = DualReal(1.0, 0);\n        return\n            D_sq(D_sq(d[0]) + D_sq(d[1])) - \n            2.0 * D_multiply(D_sq(a), D_sq(d[0]) - D_sq(d[1]));\n        \n        case 8:\n        //double tori\n        return \n            D_sq(D_sq(D_sq(d[0]) + D_sq(d[1])) - D_sq(d[0]) + D_sq(d[1])) + D_sq(d[2]) - DualReal(0.01);\n            \n            /*\n            D_sq(D_multiply(d[0], D_multiply(D_sq(d[0] - DualReal(1,0)), d[0] - DualReal(2,0))) + D_sq(d[1])) + \n            D_sq(d[2]) - \n            DualReal(0.02);*/\n    }\n}\t\n\nfloat getDE(int index, vec3 p, out vec3 gradient)\n{\n \tDualReal dx = f(index, DualVector3(p.x, 1, p.y, 0, p.z, 0)); \n    DualReal dy = f(index, DualVector3(p.x, 0, p.y, 1, p.z, 0)); \n    DualReal dz = f(index, DualVector3(p.x, 0, p.y, 0, p.z, 1)); \n    \n    float fp = dx[0];//level, same for all partials\n    gradient = vec3(dx[1], dy[1], dz[1]);\n    float de = fp / length(gradient);\n    \n    //bounding cylinder\n    float bound = length(p.xz) - 2.2;\n    \n    if(abs(bound) < 0.001)//correct the normal\n    {\n        gradient = normalize(vec3(p.xz, 0));\n    }\n   \n    return max(de, bound) * 0.5;//intersection\n}\n\nmat3 rotationXY(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(c, s, 0, -s, c, 0, 0, 0, 1);\n}\n\nmat3 rotationXZ(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n}\n\nmat3 rotationYZ(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(1, 0, 0, 0, c, s, 0, -s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 clip = uv * 2.0 - 1.0;\n    vec2 unitSpacePosition = 0.5 * clip;\n    vec2 ratioSpacePosition = vec2(aspectRatio, 1) * unitSpacePosition;\n    \n    //model\n    float time = iTime * 0.15;\n    int index = int(time) % 8 + 1;\n    \n    //view basis\n    mat3 viewTransform = rotationXZ(time * tau32 + tau32 / 2.0) * rotationYZ(-0.1);\n    vec3 viewPosition = viewTransform * vec3(0, 0, index == 2 ? 1 : 8);\n    vec3 viewRight = viewTransform * vec3(1, 0, 0);\n    vec3 viewUp = viewTransform * vec3(0, 1, 0);\n    vec3 viewForward = viewTransform * vec3(0, 0, -1);\n    \n    //view ray\n    vec3 frustumPoint = viewPosition - viewForward;\n    vec3 srp =\n       viewPosition +\n       viewRight * ratioSpacePosition.x +\n       viewUp * ratioSpacePosition.y;\n    vec3 srd = normalize(srp - frustumPoint);\n\n    //sphere trace\n    int i;\n    float t = 0.0;\n    vec3 p;\n    bool hit = false;\n    vec3 gradient;\n    \n    for(i = 0; i < 300; i++)\n    {\n        p = srp + t * srd;\n        \n        float de = getDE(index, p, gradient);\n        \n        if(de < 0.0001)\n        {\n            hit = true;\n            p -= 0.001 * srd;\n            break; \n        }\n\n        t += de;\n    }\n    \n    if(hit)\n    {\n        vec3 color = vec3(1.0 - float(i) / 100.0);\n        color = normalize(gradient) * 0.8 + 0.2;\n        fragColor = vec4(color, 1);\n    }\n    else\n    {\n     \tfragColor = vec4(0,0,0,1);   \n    }\n}","name":"Image","description":"","type":"image"}]}