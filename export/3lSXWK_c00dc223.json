{"ver":"0.1","info":{"id":"3lSXWK","date":"1567106849","viewed":216,"name":"Church","username":"icaroleles1","description":"A small Church","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarchingchurch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_DIST 100.\n\n\n\nstruct material{\n    \n    vec3 diffuse;\n };\n\n//transformations\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nstruct mat{\n    \n    \n vec3 diffuseColor;\n vec3 specularColor;\n float spec;\n    \n    \n};\n\nfloat addCapsule(vec3 p,vec3 a, vec3 b,float r){\n    vec3 ab = b-a;\n    vec3 ap = p-a;\n    float t = dot(ab,ap)/(dot(ab,ab));\n                          \n    t = clamp(t,.0,1.);\n                          \n                          \n    vec3 c = a + t*ab;\n    float d = length(p-c) - r;\n                          \n     return d;                    \n    \n}\n\nfloat addTorus(vec3 p,vec2 r){\n    \n float x = length(p.xz)-r.x;\n    return length(vec2(x,p.y))-r.y;\n    \n    \n}\n\nfloat addCube(vec3 p, vec3 s){\n    return length(max(abs(p)-s,0.));\n    \n    \n    \n}\n\nfloat addSphere(vec3 p, float r){\n    \n  vec3 sphere = vec3(0.0,0 ,.0);\n\n  //float sphereDistance = length(p - sphere.xyz)-sphere.w;\n  float sphereDistance = length(p - sphere.xyz)-r;   \n    \n    return sphereDistance;\n}\n\n//camera\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvec2 opUnion(vec2 r1, vec2 r2){\n    return r1.x < r2.x ? r1 : r2;\n}\nvec2 getDistance(vec3 p){\n    \n   vec2 res;\n   vec3 cubeP =p-vec3(1.0,1.4,4);\n   cubeP.xz *=Rot(160.);\n   float cube = addCube(cubeP,vec3(2.1,1.3,.8));\n   \n   vec3 window1P = cubeP - vec3(-3.,.3,0.3);\n   float window1  = addSphere(window1P,.6);\n   res = opUnion(vec2(cube,1.0),vec2(window1,2.0));\n    \n   vec3 window2P = cubeP -  vec3(3.,.3,0.3);\n   float window2  = addSphere(window2P,.6);\n   res = opUnion(res,vec2(window2,2.0));\n\n   vec3 col1P  = cubeP -vec3(-3.,-.0,0.);\n   float col1 = addCube(col1P,vec3(.8,1.3,.8));\n   res = opUnion(res,vec2(col1,3.0));     \n\n   vec3 col2P = cubeP - vec3(3,0.,0.0);\n   float col2 = addCube(col2P,vec3(.8,1.3,.8));\n   res = opUnion(res,vec2(col2,3.0)); \n       \n \tvec3 tri1P = cubeP - vec3(-3,1.8,0.0);\n\tfloat tri1 = sdTriPrism(tri1P,vec2(.9,.9)); \n    res = opUnion(res,vec2(tri1,4.0));\n    \n    vec3 tri2P = cubeP - vec3(3.1,1.8,0.0);\n\tfloat tri2 = sdTriPrism(tri2P,vec2(.9,.9));\n    res = opUnion(res,vec2(tri2,4.0));\n    \n    vec3 tri3P = cubeP - vec3(0.0,2.0,0.0);\n\tfloat tri3 = sdTriPrism(tri3P,vec2(1.4,1.1));  \n    res = opUnion(res,vec2(tri3,4.0));\n    \n    vec3 cross1P = cubeP - vec3(3.1,3.,.0);\n    cross1P.xy *=Rot(55.);\n\tfloat cross1 =addCube(cross1P,vec3(1.2,.09,.09));\n    res = opUnion(res,vec2(cross1,5.0));\n    \n    vec3 cross11P = cubeP -vec3(3.1,3.4,.0);\n    cross11P.xy *=Rot(0.);\n\tfloat cross11 =addCube(cross11P,vec3(1.2,.09,.09));\n    res = opUnion(res,vec2(cross11,6.0));\n\n    \n    vec3 cross2P = cubeP - vec3(-3.1,3.,.0);\n    cross2P.xy *=Rot(55.);\n    float  cross2 =addCube(cross2P,vec3(1.2,.09,.09));\n\tres = opUnion(res,vec2(cross2,6.0));\n\n    vec3 cross22P = cubeP - vec3(-3.1,3.4,.0);\n    cross22P.xy *=Rot(0.);\n    float  cross22 =addCube(cross22P,vec3(1.2,.09,.09));\n   \tres = opUnion(res,vec2(cross22,6.0));\n\n    vec3 doorP = cubeP + vec3(0.0,0.6,-.9);\n    float door = addCube(doorP,vec3(.6,.6,.09));\n\tres = opUnion(res,vec2(door,7.0));\n\n  \tres = opUnion(res,vec2(p.y,-1.0));\n    \n    \n   \n     res = opUnion(res,vec2(p.y+1.,-2.0));\n\n    \n    return res;\n   \n   \n}\n\nfloat getDistToSphere(vec3 p){\n   float sphere = addSphere(p-vec3(.3,.0,2),1.0);\n\n    return sphere;\n}\n\n\n\n\nvec2 rayMarch(vec3 ro,vec3 rd){\n    float dO = 0.;\n    \n    vec2 d;\n\n    for(int i=0;i<100;i++){\n        \n     vec3 p = ro + rd*dO;\n        \n        d = getDistance(p);\n        \n\n        dO+=d.x;\n        if(d.x >100.0|| d.x<.01)\n            break;\n\n    }\n    \n        float id=d.y;\n        float dist = dO;\n    \n    return vec2(dist,id);\n    \n    \n}\n\n\n\nvec3 getNormal(vec3 p){\n    \n    vec2 d = getDistance(p);\n    \n    vec2 e= vec2(.01,.0);\n    \n    vec3 normal = d.x -vec3(getDistance(p-e.xyy).x,\n                          getDistance(p-e.yxy).x,\n                          getDistance(p-e.yyx).x);\n    \n      \n    return normalize(normal);\n}    \n\n\nvec3 getLight(vec3 p,vec3 ro,vec3 uv,float geometry){\n \n    \n \tvec3 lightPos = vec3(4, 5, 1.3);\n    lightPos.xz -= vec2(sin(iTime)*6., cos(iTime)*6.);\n    vec3 lightDir = normalize(lightPos-p);\n    vec3 normal = getNormal(p);\n    \n    \n    float dist = distance(lightPos,p);\n    float diff = clamp(dot(normal, lightDir), 0., 1.);\n    float d = rayMarch(p+normal*0.02*2., lightDir).x;\n    if(d<length(lightPos-p)) diff *= .1;\n    \n    \n    \n    vec3 viewDir = normalize(uv-ro);\n    vec3 reflectDir = reflect(-lightDir,normal);\n    vec3 ambient = vec3(.2,.2,.4);\n\n    mat material;\n    \n    //floor\n    if(geometry==-1.0){\n        \n        \n        material.diffuseColor = vec3(1.,1.3,1.3);\n        material.specularColor = vec3(.7,.7,.7);\n        material.spec = 64.0;\n        \n }\n    //mainWall\n      if(geometry==1.0){\n        \n        \n        material.diffuseColor = vec3(1.0,1.,.1);\n        material.specularColor = vec3(1.0);\n        material.spec = 2.0;\n        \n    }\n    \n    //window\n    else if(geometry == 2.0){\n        \n        material.diffuseColor = vec3(.1,1.,.1);\n        material.specularColor = vec3(.0,1.,.0);\n        material.spec = 256.0;\n\n        \n        \n    }\n    //columns\n      else if(geometry == 3.0){\n       \n        material.diffuseColor = vec3(.0,.0,.6);\n        material.specularColor = vec3(.8);\n        material.spec = 256.;\n        \n        \n    }\n    //roof\n      else if(geometry ==4.0 ){\n        material.diffuseColor = vec3(1.0,.1,.1);\n        material.specularColor = vec3(.6);\n        material.spec = 256.;\n        \n        \n        \n    }\n    //cross\n      else if(geometry ==5.0 ){\n        \n        material.diffuseColor = vec3(.0,.1,.1);\n        material.specularColor = vec3(.6);\n        material.spec = 2.;\n        \n        \n    }\n     else if(geometry ==6.0 ){\n        \n        material.diffuseColor = vec3(.0,.1,.1);\n        material.specularColor = vec3(.6);\n        material.spec = 4.;\n        \n        \n    }\n     else if(geometry ==7.0 ){\n        \n        material.diffuseColor = vec3(.1,.3,.3);\n        material.specularColor = vec3(.6);\n        material.spec = 256.;\n        \n        \n    }\n    else{\n        \n         material.diffuseColor = vec3(.8,.8,.8);\n        material.specularColor = vec3(.6);\n        material.spec = 256.;\n    }\n   float spec = pow(max(dot(viewDir,reflectDir),0.0),material.spec);\n\n\n    material.diffuseColor*=diff * 1./(dist*.063);\n    material.specularColor*=spec*1./(dist*.063);\n    return material.diffuseColor + material.specularColor + ambient ;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv-=.5;\n\tuv.x *=iResolution.x/iResolution.y;\n\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 position =  vec3(1.0,1.4,4);\n    vec3 col = vec3(0);\n    vec3 ro = vec3(0, 3.9, -13);\n    vec3 dir = position-ro;\n \n\tro.xz = vec2(sin(iTime),cos(iTime)-13.);\n   // ro.yz *= Rot(-m.y+.4);\n    //ro.xz *= Rot(.2-m.x*6.2831);\n   // ro.xz = vec2(0. + sin(iTime),-6. + cos(iTime));\n    float geometry  ;\n    vec3 rd = vec3(uv.x,uv.y,1.);\n   \t\n    \n    \n   vec2 x = rayMarch(ro,rd);\n  \n    geometry = x.y;\n   vec3  outPut = ro +rd*x.x; \n   \n   vec3 result = getLight(outPut,ro,vec3(uv,1.0),geometry);\n    \n    \n    const float gamma = 2.2;\n    /*vec3 hdrColor = texture(hdrBuffer, TexCoords).rgb;\n  \n    // Exposure tone mapping\n    vec3 mapped = vec3(1.0) - exp(-hdrColor * exposure);\n    // Gamma correction \n    mapped = pow(mapped, vec3(1.0 / gamma));\n  \n    FragColor = vec4(mapped, 1.0);*/\n    \n    vec3 colx = result;\n    vec3 mapped = vec3(1.0) - exp(-colx * .2);\n    mapped = pow(mapped, vec3(1.0 / gamma));\n\n    fragColor = vec4(mapped,1.);\n}","name":"Image","description":"","type":"image"}]}