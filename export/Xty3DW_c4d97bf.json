{"ver":"0.1","info":{"id":"Xty3DW","date":"1474548018","viewed":138,"name":"Marine sim, wind cover calc","username":"Pekoni","description":"A quick prototype needed for a marine navigation simulation.\nDetermines a rough estimate for wind cover using a land mass heightmap for occlusion.\nWind direction is from the center of the screen towards the mouse cursor.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["procedural"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float height( in vec2 uv )\n{\n    const float baseHeight = 0.4;\n    float h = texture( iChannel0, uv ).r;\n\treturn 1.0 / ( 1.0 - baseHeight ) * ( max( h, baseHeight ) - baseHeight );\n}\n\nfloat windOverLineSegment( in vec2 p1, in vec2 p2 )\n{\n    const float maxCoverDistance = 1.0;\n    const float minEffectiveHeight = 0.1;\n    float windValue = 1.0;\n    vec2 dPix = ( p2 - p1 ) * iResolution.xy;\n    if ( length( dPix ) < 1.0 ) return 0.0;\n    float numSteps = abs( dPix.x ) > abs( dPix.y ) ? abs( dPix.x ) : abs( dPix.y );\n    vec2 inc = ( p2 - p1 ) / numSteps;\n    #define MAXSTEPS 4096\n    vec2 p = p1;\n    for( int i = 0; i < MAXSTEPS; ++i )\n    {\n        if ( float( i ) >= numSteps ) break;\n        if ( p.x < 0.0 || p.x > 1.0 ) break;\n        if ( p.y < 0.0 || p.y > 1.0 ) break;\n        float h = height( p );\n        windValue = h > minEffectiveHeight && distance( p, p1 ) < maxCoverDistance * h ? 0.0 : windValue;\n        p += inc;\n    }\n    return windValue;\n}\n\n#define EPSILON 1e-7\n\nbool pointIsOnPlane2D( in vec2 point, in vec2 AnyPointOnPlane, in vec2 planeNormal )\n{\n    return abs( dot( point - AnyPointOnPlane, planeNormal ) ) < EPSILON;\n}\n\nbool rayIsParallelToPlane2D( in vec2 rd, in vec2 n )\n{\n    return abs( dot( rd, n ) ) < EPSILON;\n}\n\nbool rayIntersectsPlane2D( in vec2 ro, in vec2 rd, in vec2 p, in vec2 n, out vec2 intersectionPoint )\n{\n    if ( pointIsOnPlane2D( ro, p, n ) )\n    {\n        intersectionPoint = ro;\n        return true;\n    }\n    if ( rayIsParallelToPlane2D( rd, n ) ) return false;\n    float t = -dot( ro - p, n ) / dot( rd, n );\n    if ( t < 0.0 ) return false;\n    intersectionPoint = ro + t * rd;\n    return true;\n}\n\nfloat wind( in vec2 uv, in vec2 dir )\n{\n    vec2 uv2 = uv;\n\tbool intersects = rayIntersectsPlane2D( uv, -dir, vec2( 0.0, 0.0 ), vec2( 1.0, 0.0 ) , uv2 );\n    if ( !intersects ) intersects = rayIntersectsPlane2D( uv, -dir, vec2( 0.0, 0.0 ), vec2( 0.0, 1.0 ), uv2 );\n    if ( !intersects ) intersects = rayIntersectsPlane2D( uv, -dir, vec2( 1.0, 1.0 ), vec2( -1.0, 0.0 ) , uv2 );\n    if ( !intersects ) intersects = rayIntersectsPlane2D( uv, -dir, vec2( 1.0, 1.0 ), vec2( 0.0, -1.0 ) , uv2 );\n    return windOverLineSegment( uv, uv2 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 mousePos =  iMouse.xy / iResolution.xy;\n    vec2 dir = normalize( mousePos - vec2( 0.5, 0.5 ) );\n    fragColor = vec4( height( uv ) ) + vec4( wind( uv, dir ), 0.0, 0.0, 1.0 );\n}","name":"Image","description":"","type":"image"}]}