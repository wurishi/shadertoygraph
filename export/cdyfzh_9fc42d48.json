{"ver":"0.1","info":{"id":"cdyfzh","date":"1697876676","viewed":60,"name":"mulit-model and moving light","username":"tomcat7479","description":"单移动光源与多物体之间的光照阴影","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["shadow","2dlight"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define samplerCount 4\n#define shadowColor vec3(0.0)\n#define bgColor vec3(0.2, 0.1, 0.0)\n#define unitX 1.0 / iResolution.x\n#define unitY 1.0 / iResolution.y\n#define zoom 1.0\n#define inf 2.0 * zoom\n#define unit vec2(unitX, unitY)\n\nstruct Light {\n    vec2 pos;\n    vec3 color;\n    float minIntentity;\n    float maxIntentity;\n    float brightness;\n} light;\n\nstruct Segment {\n    vec2 start;\n    vec2 end;\n} segment;\n\nstruct Box {\n    float w;\n    vec2 leftUp;\n    vec2 rightUp;\n    vec2 leftDown;\n    vec2 rightDown;\n    vec3 color;\n} box;\n\n\nfloat lightInterpolate(Light light, vec2 p) {\n    float d = pow(distance(p, light.pos), 0.3);\n    if (d < light.minIntentity) {\n        return 1.0;\n    } \n    if (d > light.maxIntentity) {\n        return 0.0;\n    }\n    float x = (d - light.minIntentity) / (light.maxIntentity - light.minIntentity);\n    return (100.0 / 99.0) / ((9.0 * x + 1.0) * (9.0 * x + 1.0)) - 1.0 / 99.0;\n}\n\nvec2 fix(in vec2 fragCoord) {\n    return zoom * (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n}\n\n\nBox createBox(float w, vec2 boxCenter, vec3 boxColor) {\n    float h = w / 2.0;\n    vec2 k = vec2(1.0, -1.0);\n    vec2 lu = boxCenter + h * k.yx;\n    vec2 ru = boxCenter + h * k.xx;\n    vec2 ld = boxCenter + h * k.yy;\n    vec2 rd = boxCenter + h * k.xy;\n    Box box = Box(w, lu, ru, ld, rd, boxColor);\n    return box; \n}\n\nbool insideBox(vec2 p, Box box) {\n    vec2 minValue = vec2(min(box.leftDown.x, box.rightUp.x), min(box.leftDown.y, box.rightUp.y));\n    vec2 maxValue = vec2(max(box.leftDown.x, box.rightUp.x), max(box.leftDown.y, box.rightUp.y));\n    if (p.x < minValue.x || p.y < minValue.y) return false;\n    if (p.x > maxValue.x || p.y > maxValue.y) return false;\n    return true;\n}\n\nbool insideSegment(vec2 p, Segment segment) {\n    vec2 minValue = vec2(min(segment.start.x, segment.end.x), min(segment.start.y, segment.end.y));\n    vec2 maxValue = vec2(max(segment.start.x, segment.end.x), max(segment.start.y, segment.end.y));\n    if (p.x < minValue.x || p.y < minValue.y) return false;\n    if (p.x > maxValue.x || p.y > maxValue.y) return false;\n    return true;\n}\n\nvec2 intersectPoint(Segment line_0, Segment line_1) {\n    float slope_0, slope_1, x, y;\n    \n    if (line_0.start.x == line_0.end.x) {     \n        //slope_0 is infinite\n        slope_1= (line_1.start.y - line_1.end.y) / (line_1.start.x - line_1.end.x);\n        \n        x= line_0.start.x;\n        y= slope_1 * x + line_1.start.y;\n        \n    } else if (line_1.start.x == line_1.end.x) {\n        //slope_1 is infinite\n        slope_0= (line_0.start.y - line_0.end.y) / (line_0.start.x - line_0.end.x);\n        \n        x= line_1.start.x;\n        y= slope_0 * (x - line_0.start.x) + line_0.start.y;\n        \n    } else {\n        slope_0= (line_0.start.y - line_0.end.y) / (line_0.start.x - line_0.end.x);\n        slope_1= (line_1.start.y - line_1.end.y) / (line_1.start.x - line_1.end.x);\n\n        if (slope_0 != slope_1) {\n\t\t\t\n            //calculate y-intercept of line_1 based on line_0.start\n            float b= slope_1 * (line_0.start.x - line_1.start.x) + line_1.start.y;\n            \n            x= (b - line_0.start.y) / (slope_0 - slope_1);\n            y= slope_0 * x + line_0.start.y;\n            x= x + line_0.start.x;\n            \n\n        } else {\n            return vec2(-1.0);\n        }\n    }\n    \n    return vec2(x, y);\n}\n\nbool isIntersect(Box box, Segment segA, Segment segB) {\n    vec2 point = intersectPoint(segA, segB);\n    if (point.x >= inf - 1e-1 && point.x <= inf + 1e-1) return false; \n    return insideBox(point, box) && insideSegment(point, segA) && insideSegment(point, segB);\n}\n\nvec3 calculateLightings(vec2 p, Box box, Light light) {\n    vec3 color = vec3(0.0);\n    Segment lightSegment = Segment(light.pos, p);\n    Segment leftSegment = Segment(box.leftDown, box.leftUp); \n    Segment rightSegment = Segment(box.rightDown, box.rightUp); \n    Segment downSegment = Segment(box.leftDown, box.rightDown); \n    Segment upSegment = Segment(box.leftUp, box.rightUp);\n    bool isIntersectStatus = isIntersect(box, lightSegment, leftSegment) || \n                             isIntersect(box, lightSegment, rightSegment) ||\n                             isIntersect(box, lightSegment, downSegment) || \n                             isIntersect(box, lightSegment, upSegment);\n    if (isIntersectStatus) {\n        return shadowColor;\n    } \n    return lightInterpolate(light, p) * light.brightness * light.color;\n}\n\nvec3 renderScene(vec2 p, Box box, Light light) {\n    vec3 color = vec3(0.0);\n    vec2 h = vec2(1.0, -1.0);\n    color += calculateLightings(p + unit * h.yx, box, light);\n    color += calculateLightings(p + unit * h.xx, box, light);\n    color += calculateLightings(p + unit * h.yy, box, light);\n    color += calculateLightings(p + unit * h.xy, box, light);\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = fix(fragCoord);\n    Box box1 = createBox(0.2, vec2(0.5), vec3(0.1, 0.63, 0.86));\n    Box box2 = createBox(0.15, vec2(-0.5, 0.5), vec3(0.1, 0.63, 0.36));\n    Box box3 = createBox(0.1, vec2(-0.3, -0.4), vec3(0.43, 0.17, 0.81));\n    Box box4 = createBox(0.22, vec2(0.5, -0.27), vec3(0.9, 0.69, 0.12));\n    Light light = Light(fix(iMouse.xy), vec3(1.0), 0.0, 1.5, 0.71);\n    \n    vec3 color = bgColor;\n    color += renderScene(p, box1, light);\n    color += renderScene(p, box2, light);\n    color += renderScene(p, box3, light);\n    color += renderScene(p, box4, light);\n    if (insideBox(p, box1)) {\n        color = box1.color;\n    }\n\n    if (insideBox(p, box2)) {\n        color = box2.color;\n    }\n\n    if (insideBox(p, box3)) {\n        color = box3.color;\n    }\n\n    if (insideBox(p, box4)) {\n        color = box4.color;\n    }\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}