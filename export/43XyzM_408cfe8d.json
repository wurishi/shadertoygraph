{"ver":"0.1","info":{"id":"43XyzM","date":"1725952128","viewed":76,"name":"Fork Signed Dis but easier","username":"Flamgop","description":"distance functions to all standard capital letters, now with easy declaration instead of manually writing it alltogether\nyou're free to use this in your projects btw, that's why dottedboxguy made it ! just credit dottedboxguy if you can or smth\n","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["sdf","font","alphabet","ascii","character","letter"],"hasliked":0,"parentid":"XfjBWt","parentname":"Signed Distance Font"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//changing the letter is in the top of the scene function, aaaaaaaaall the way down\n\n#define PI 3.14159265359\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b ){\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdTunnel( in vec2 p, in vec2 wh )\n{\n    p.x = abs(p.x); p.y = -p.y;\n    vec2 q = p - wh;\n\n    float d1 = dot2(vec2(max(q.x,0.0),q.y));\n    q.x = (p.y>0.0) ? q.x : length(p)-wh.x;\n    float d2 = dot2(vec2(q.x,max(q.y,0.0)));\n    float d = sqrt( min(d1,d2) );\n    \n    return (max(q.x,q.y)<0.0) ? -d : d;\n}\n\nfloat sdHalfCircle( in vec2 p, in float r, in float rb )\n{\n    p.x = abs(p.x);\n    return ((0.>p.y) ? length(vec2(p.x-r, p.y)) : \n                                  abs(length(p)-r)) - rb;\n}\n\nfloat sdVerticalCapsule( vec2 p, float h, float r ){\n    p.y -= clamp( p.y, 0.0, h );\n    return length( p ) - r; \n}\n\n// TODO : \n//.   - make it so all possible SDFs stop taking thickness as a parameter, to eco some additions for fri\n\n//will revisit later to make it fit with the width of all the other characters\nfloat sdA(vec2 p, float thickness){\n    p.x = abs(p.x);\n    const vec4 long_bar = vec4(0., .4, .175, -.3);\n    const float height_of_middle_bar = .33;\n    const vec2 middle_bar = mix(long_bar.zw, long_bar.xy, height_of_middle_bar);\n    return min(\n        sdSegment(p, long_bar.xy, long_bar.zw)-thickness,\n        sdSegment(p, middle_bar, vec2(0., middle_bar.y))-thickness);\n}\n\nfloat sdB(vec2 p, float thickness){\n    p.y=-abs(p.y-.05);\n    vec2 tunnel_size = vec2(.175);\n    p.y+=tunnel_size.x;\n    p = p.yx;\n    return abs(sdTunnel(p, tunnel_size))-thickness;\n}\n\nfloat sdC(vec2 p, float thickness){\n    p.y=abs(p.y-.05)-.175;\n    return min(\n        sdHalfCircle(p, .175, thickness), \n        sdVerticalCapsule(p+vec2(.175, .175), .175, thickness));\n}\n\nfloat sdD(vec2 p, float thickness){\n    p.y-=clamp(p.y, .0-.13125, .35-.13125);\n    return abs(sdTunnel(p.yx, vec2(.175)))-thickness;\n}\n\nfloat sdE(vec2 p, float thickness){\n    p.y-=.05;\n    p.y=abs(abs(p.y)-.175);\n    return min(\n            sdSegment(p, vec2(.175), vec2(-.175, .175)),\n            sdSegment(p, vec2(-.175, 0.), vec2(-.175, .175)))-thickness;\n}\n\nfloat sdF(vec2 pos, float thickness){\n    pos.y-=.225;\n    vec2 p = pos;\n    p.y=abs(p.y);\n    return min(\n            sdSegment(p, vec2(.175), vec2(-.175, .175)),\n            sdSegment(pos, -vec2(.175, .525), vec2(-.175, .175)))-thickness;\n}\n\n//over 3 square roots because otherwise it looks like shit, might revisit later\nfloat sdG(vec2 pos, float thickness){\n    pos.y-=.05;\n    vec2 p = pos;\n    p.y=abs(p.y)-.175;\n    return min(min(min(\n        sdHalfCircle(p, .175, thickness), \n        sdVerticalCapsule(p+vec2(.175, .175), .175, thickness)),\n        sdVerticalCapsule(pos.yx+vec2(.0875, .0), 0.175, thickness)),\n        sdVerticalCapsule(pos+vec2(-.175, .175), .0875, thickness));\n}\n\nfloat sdH(vec2 p, float thickness){\n    p.y-=.05;\n    p=abs(p);\n    return min(\n        sdVerticalCapsule(p.yx, .175, thickness),\n        sdVerticalCapsule(p-vec2(.175, .0), .35, thickness));\n}\n\nfloat sdI(vec2 p, float thickness){\n    p.y-=.05;\n    p=abs(p);\n    return min(\n        sdVerticalCapsule(p.yx-vec2(.35, .0), .175, thickness),\n        sdVerticalCapsule(p, .35, thickness));\n}\n\nfloat sdJ(vec2 p, float thickness){\n    p.y-=.05;\n    return min(min(\n        sdHalfCircle(vec2(p.x, -.175-p.y), .175, thickness),\n        sdVerticalCapsule(p+vec2(-.175, .175), .525, thickness)),\n        sdVerticalCapsule(p.yx-vec2(.35, .0), .175, thickness));\n}\n\nfloat sdK(vec2 p, float thickness){\n    p.y-=.05;\n    p.y=abs(p.y);\n    return min(min(\n        sdVerticalCapsule(p.yx+vec2(.0, .175), .175, thickness),\n        sdVerticalCapsule(p+vec2(.175, .0), .35, thickness)),\n        sdSegment(p, vec2(.0), vec2(.175, .35))-thickness);\n}\n\nfloat sdL(vec2 p, float thickness){\n    p.y-=.05;\n    return min(\n        sdVerticalCapsule(p.yx+vec2(.35, .175), .350, thickness),\n        sdVerticalCapsule(p+vec2(.175, .35), .7, thickness));\n}\n\nfloat sdM(vec2 p, float thickness){\n    p.y-=.05;\n    p.x=abs(p.x);\n    return min(\n        sdSegment(p, vec2(.0), vec2(.175, .35))-thickness,\n        sdVerticalCapsule(p+vec2(-.175, .35), .7, thickness));\n}\n\nfloat sdN(vec2 pos, float thickness){\n    pos.y-=.05;\n    vec2 p = pos;\n    p.x=abs(p.x);\n    return min(\n        sdSegment(pos, vec2(-.175, .350), vec2(.175, -.35))-thickness,\n        sdVerticalCapsule(p+vec2(-.175, .35), .7, thickness));\n}\n\nfloat sdO(vec2 p, float thickness){\n    p.y+=.125;\n    return abs(sdVerticalCapsule(p, .35, .175))-thickness;\n}\n\nfloat sdP(vec2 p, float thickness){\n    p.y-=.05;\n    return min(\n        abs(sdTunnel(p.yx-vec2(.175, .0), vec2(.175)))-thickness,\n        sdVerticalCapsule(p+vec2(.175, .35), .35, thickness));\n}\n\nfloat sdQ(vec2 p, float thickness){\n    const vec2 tailpos = vec2(cos(-PI/3.-.2), sin(-PI/3.-.2))*.175;\n    return min(\n        sdO(p, thickness), \n        sdSegment(p, vec2(.0, -.125)+tailpos, vec2(.175, -.45))-thickness);\n}\n\nfloat sdR(vec2 p, float thickness){\n    \n    return min(\n        sdP(p, thickness), \n        sdSegment(p, vec2(.0, .05), vec2(.175, -.3))-thickness);\n}\n\nfloat sdS(vec2 pos, float thickness){\n    pos.y-=.05;\n    vec2 p = pos;\n    p.y=abs(p.y);\n    pos.y = sign(pos.x)*pos.y;\n    pos.y+=.175;\n    pos.x = abs(pos.x);\n    return min(\n        sdHalfCircle(pos, .175, thickness),\n        sdHalfCircle(p-vec2(.0, .175), .175, thickness));\n    \n}\n\nfloat sdT(vec2 p, float thickness){\n    return min(\n        sdVerticalCapsule(p+vec2(.0, .3), .7, thickness),\n        sdVerticalCapsule(p.yx+vec2(-.4, .175), .35, thickness));\n}\n\nfloat sdU(vec2 p, float thickness){\n    p.x=abs(p.x);\n    p.y=-p.y+.05;\n    return min(\n        sdHalfCircle(p-vec2(.0, .175), .175, thickness),\n        sdVerticalCapsule(p+vec2(-.175, .35), .525, thickness));\n}\n\nfloat sdV(vec2 p, float thickness){\n    p.x=abs(p.x);\n    return sdSegment(p, vec2(.0, -.3), vec2(.175, .4))-thickness;\n}\n\nfloat sdW(vec2 p, float thickness){\n    p.x=abs(abs(p.x)-0.0875)+0.0875;\n    return sdSegment(p, vec2(.0875, -.3), vec2(.175, .4))-thickness;\n}\n\nfloat sdX(vec2 p, float thickness){\n    p.y-=.05;\n    p=abs(p);\n    return sdSegment(p, vec2(.0), vec2(.175, .35))-thickness;\n}\n\nfloat sdY(vec2 p, float thickness){\n    p.x=abs(p.x);\n    return min(\n        sdSegment(p, vec2(.0), vec2(.175, .4))-thickness,\n        sdVerticalCapsule(p+vec2(.0, .3), .3, thickness));\n}\n\nfloat sdZ(vec2 pos, float thickness){\n    vec2 p = pos;\n    p.y=abs(p.y-.05);\n    return min(\n        sdVerticalCapsule(p.yx-vec2(.35, -.175), .35, thickness),\n        sdSegment(pos, vec2(-.175, -.3), vec2(.175, .4))-thickness);\n}\n\nconst int _a = 0;\nconst int _b = 1;\nconst int _c = 2;\nconst int _d = 3;\nconst int _e = 4;\nconst int _f = 5;\nconst int _g = 6;\nconst int _h = 7;\nconst int _i = 8;\nconst int _j = 9;\nconst int _k = 10;\nconst int _l = 11;\nconst int _m = 12;\nconst int _n = 13;\nconst int _o = 14;\nconst int _p = 15;\nconst int _q = 16;\nconst int _r = 17;\nconst int _s = 18;\nconst int _t = 19;\nconst int _u = 20;\nconst int _v = 21;\nconst int _w = 22;\nconst int _x = 23;\nconst int _y = 24;\nconst int _z = 25;\nconst int _space = 26;\n\nconst int[] data = int[](\n    _t,_h,_e,_space,_q,_u,_i,_c,_k,_space,_b,_r,_o,_w,_n,_space,_f,_o,_x,_space,_j,_u,_m,_p,_s,_space,_o,_v,_e,_r,_space,_t,_h,_e,_space,_l,_a,_z,_y,_space,_d,_o,_g\n);\n\nfloat sdForChar(int c, vec2 pos, float thickness) {\n    if (c == _a)\n        return sdA(pos, thickness);\n    else if (c == _b)\n        return sdB(pos, thickness);\n    else if (c == _c)\n        return sdC(pos, thickness);\n    else if (c == _d)\n        return sdD(pos, thickness);\n    else if (c == _e)\n        return sdE(pos, thickness);\n    else if (c == _f)\n        return sdF(pos, thickness);\n    else if (c == _g)\n        return sdG(pos, thickness);\n    else if (c == _h)\n        return sdH(pos, thickness);\n    else if (c == _i)\n        return sdI(pos, thickness);\n    else if (c == _j)\n        return sdJ(pos, thickness);\n    else if (c == _k)\n        return sdK(pos, thickness);\n    else if (c == _l)\n        return sdL(pos, thickness);\n    else if (c == _m)\n        return sdM(pos, thickness);\n    else if (c == _n)\n        return sdN(pos, thickness);\n    else if (c == _o)\n        return sdO(pos, thickness);\n    else if (c == _p)\n        return sdP(pos, thickness);\n    else if (c == _q)\n        return sdQ(pos, thickness);\n    else if (c == _r)\n        return sdR(pos, thickness);\n    else if (c == _s)\n        return sdS(pos, thickness);\n    else if (c == _t)\n        return sdT(pos, thickness);\n    else if (c == _u)\n        return sdU(pos, thickness);\n    else if (c == _v)\n        return sdV(pos, thickness);\n    else if (c == _w)\n        return sdW(pos, thickness);\n    else if (c == _x)\n        return sdX(pos, thickness);\n    else if (c == _y)\n        return sdY(pos, thickness);\n    else if (c == _z)\n        return sdZ(pos, thickness);\n    \n    return 0.0; // Default return value if the character isn't recognized\n}\n\nvec4 scene(in vec2 p){\n    \n    //DO NOT LOOK, VERY BAD\n    float offset = .6;\n    float thickness = .03 + .02*cos(iTime);\n    \n    //float d = sdT(p, thickness);p.x-=offset;d=min(d, sdH(p, thickness));p.x-=offset;d=min(d, sdE(p, thickness));p.x-=offset;p.x-=offset;d=min(d, sdQ(p, thickness));p.x-=offset;d=min(d, sdU(p, thickness));p.x-=offset;d=min(d, sdI(p, thickness));p.x-=offset;d=min(d, sdC(p, thickness));p.x-=offset;d=min(d, sdK(p, thickness));p.x-=offset;p.x-=offset;d=min(d, sdB(p, thickness));p.x-=offset;d=min(d, sdR(p, thickness));p.x-=offset;d=min(d, sdO(p, thickness));p.x-=offset;d=min(d, sdW(p, thickness));p.x-=offset;d=min(d, sdN(p, thickness));p.x-=offset;p.x-=offset;d=min(d, sdF(p, thickness));p.x-=offset;d=min(d, sdO(p, thickness));p.x-=offset;d=min(d, sdX(p, thickness));p.x-=offset;p.x-=offset;d=min(d, sdJ(p, thickness));p.x-=offset;d=min(d, sdU(p, thickness));p.x-=offset;d=min(d, sdM(p, thickness));p.x-=offset;d=min(d, sdP(p, thickness));p.x-=offset;d=min(d, sdS(p, thickness));p.x-=offset;p.x-=offset;d=min(d, sdO(p, thickness));p.x-=offset;d=min(d, sdV(p, thickness));p.x-=offset;d=min(d, sdE(p, thickness));p.x-=offset;d=min(d, sdR(p, thickness));p.x-=offset;p.x-=offset;d=min(d, sdT(p, thickness));p.x-=offset;d=min(d, sdH(p, thickness));p.x-=offset;d=min(d, sdE(p, thickness));p.x-=offset;p.x-=offset;d=min(d, sdL(p, thickness));p.x-=offset;d=min(d, sdA(p, thickness));p.x-=offset;d=min(d, sdZ(p, thickness));p.x-=offset;d=min(d, sdY(p, thickness));p.x-=offset;p.x-=offset;d=min(d, sdD(p, thickness));p.x-=offset;d=min(d, sdO(p, thickness));p.x-=offset;d=min(d, sdG(p, thickness));\n    \n    float d = sdForChar(data[0], p, thickness);\n    p.x -= offset;\n    \n    for (int i = 1; i < data.length(); i++) {\n        if (data[i] != _space) d = min(d,sdForChar(data[i],p,thickness));\n        p.x -= offset;\n    }\n    \n    \n    //float d = sdO(p, .0);\n    \n    float d_baseline = sdSegment(p, vec2(-.5, -.3), vec2(.5, -.3));\n    float d_decender_height = sdSegment(p, vec2(-.5, -.45), vec2(.5, -.45));\n    float d_x_height = sdSegment(p, vec2(-.5, .2), vec2(.5, .2));\n    float d_caps_height = sdSegment(p, vec2(-.5, .4), vec2(.5, .4));\n    float d_ascender_height = sdSegment(p, vec2(-.5, .5), vec2(.5, .5));\n    \n    //coloring taken from iq\n    vec3 color = vec3(0.);\n    float px = 2./iResolution.y;\n    color = (d>0.0) ? vec3(.9,.6,.3) : vec3(.65,.85,1.);\n    color *= 1. - exp2(-.06/px*abs(d));\n    color *= .8 + .2*cos(iResolution.x*.06*abs(d));\n    color = mix(color, vec3(1.), 1.-smoothstep(-px*12.,px*12.,abs(d)-0.005));\n    \n    //debug lines i used to make the characters the same dimentions\n    //color = mix(color, vec3(1., 0., 0.), 1.-smoothstep(-px,px,abs(d_baseline)-0.005));\n    //color = mix(color, vec3(1., 0., 0.), 1.-smoothstep(-px,px,abs(d_decender_height)-0.005));\n    //color = mix(color, vec3(1., 0., 0.), 1.-smoothstep(-px,px,abs(d_x_height)-0.005));\n    //color = mix(color, vec3(1., 0., 0.), 1.-smoothstep(-px,px,abs(d_caps_height)-0.005));\n    //color = mix(color, vec3(1., 0., 0.), 1.-smoothstep(-px,px,abs(d_ascender_height)-0.005));\n    \n    return vec4(color, d);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 m = iMouse.xy/iResolution.xy;\n    vec2 p = uv-.5;\n    m-=.5;\n    p.x = p.x*iResolution.x/iResolution.y;\n    m.x = m.x*iResolution.x/iResolution.y;\n    p.x+=.81;\n    p*=15.5;\n    m.x+=.81;\n    m*=15.5;\n    vec3 col = scene(p).xyz;\n    \n    float px = 16./iResolution.y;\n    \n    if( iMouse.z>0.001 )\n    {\n    float d = scene(m).w;\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, px, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, px, length(p-m)-0.015));\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    //fragColor = vec4(p, 0., 1.);\n}","name":"Image","description":"","type":"image"}]}