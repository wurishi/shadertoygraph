{"ver":"0.1","info":{"id":"ssG3DK","date":"1632186855","viewed":103,"name":"Punctured Torus Deformation","username":"stevejtrettel","description":"Just a first test of making a hyperbolic tiling in shadertoy","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["hyperbolic"],"hasliked":0,"parentid":"fdG3DV","parentname":"Hyperbolic Octagon Reflections"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//A tiling of the hyperbolic plane by ideal quadrilaterals determines a punctured torus\n//by taking each pair of opposite sides, and gluing them with the hyperbolic isometry\n// which identifies the closest pair of points on each to one another.\n//To draw this tiling, instead of translating by these isometries,\n//I generate it by reflecting in the sides\n\n\n\n\n//------------------------------------------\n//Define hyperbolic half spaces, reflections\n//------------------------------------------\n\n//vertical line to reflect in\n//side=+1 means the half space contains points to the right, -1 to the left\nstruct Line{\nfloat pos;\nfloat side;\n};\n\n\n//semicircle centered on real line to reflect in\n//side =+1 means the halfspace contains points below, -1 means above\nstruct Circle{\nfloat center;\nfloat radius;\nfloat side;\n};\n\n\n\n//reflection in vertical line defining a half space\n//this is done by conjugating reflection in the line x=0\n//by the translation taking this line there\nvoid invert(inout vec2 p, Line line){\n\n    p.x -= line.pos;\n    \n    p.x *= -1.;\n    \n    p.x += line.pos;\n    \n}\n\n\n\n//reflection in a circle defining a half space\n//this is done by conjugating inversion in the unit circle\n//with a similarity transformation taking the given circle to the unit circle\nvoid invert(inout vec2 p, Circle circle){\n\n    p.x -= circle.center;\n    p /= circle.radius;\n    \n    p /= dot(p,p);\n    \n    p *= circle.radius;\n    p.x += circle.center;\n \n}\n\n//check if inside a half space bounded by a line:\nbool inside(vec2 p, Line line){\n    if(line.side>0.){//check if we are on the right side\n        return p.x>line.pos;\n    }\n    else{//check if we are on the left side\n        return p.x<line.pos;\n    }\n}\n\n//check if inside a half space bounded by a circle\nbool inside(vec2 p, Circle circle){\n    if(circle.side>0.){//check if we are inside the semicircle\n        return length(p-vec2(circle.center,0))<circle.radius;\n    }\n    else{//check if we are outside the semicircle\n        return length(p-vec2(circle.center,0))>circle.radius;\n    }\n}\n\n\n\n\n//------------------------------------------\n//set up the fundamental domain\n//------------------------------------------\n\n\n//Give names to the sides of the shape\nLine side0;\nLine side1;\nCircle side2;\nCircle side3;\n\n\n//function that defines these sides in terms of two deformation parameters a,b\n//this generates a quadrilateral with vertices at infinity, -a, 0 and b.\nvoid setUpFD(float a, float b){\n\nside0=Line(-1.*a,1.);\nside1=Line(b,-1.);\nside2=Circle(-a/2.,a/2.,-1.);\nside3=Circle(b/2.,b/2.,-1.);\n\n}\n\n\n\n//------------------------------------------\n//reflect points into fundamental domain\n//------------------------------------------\n\n\n//this function takes in a point p, and looks at each side of the fundamental domain\n//if p is not within the half space defined by that side, we reflect it\n//if p is already in that half space, we leave it alone\nvoid reflectInFD(inout vec2 p,inout float invCount){\n\n   \n        if(!inside(p,side0)){\n            invert(p,side0);\n            invCount+=1.;\n        }\n        \n        if(!inside(p,side1)){\n            invert(p,side1);\n            invCount+=1.;\n        }\n        \n        if(!inside(p,side2)){\n            invert(p,side2);\n            invCount+=1.;\n        }\n        \n        if(!inside(p,side3)){\n            invert(p,side3);\n            invCount+=1.;\n        }\n    \n}\n\n\n\n//this function checks if p is inside our fundamental domain or not\nbool insideFD(vec2 p){\n  return inside(p,side0)&&inside(p,side1)&&inside(p,side2)&&inside(p,side3);\n}\n\n\n\n\n//move into the fundamental domain\n//this combines the two functions above: it iteratively reflects in the sides,\n//then checks if you ended up inside the FD\n//if you do, it stops.\nvoid moveToFD(inout vec2 p,inout float invCount){\n  \n    \n    for(int i=0;i<20;i++){\n    \n        reflectInFD(p,invCount);\n    \n    if(insideFD(p)){\n            break;\n         }\n  \n    }\n}\n\n\n\n\n\n//------------------------------------------\n//prepare the screen pixels for computation\n//------------------------------------------\n\n\n//this takes in the pixel coordinates on the screen (fragCoord) and rescales\n//them to show the appropriate region of the plane\nvec2 normalizedFragCoord(vec2 fragCoord){\n\n // Normalized the pixel coordinates (from -0.5 to 0.5)\n    vec2 uv =(fragCoord/iResolution.xy-vec2(0.5));\n    \n    //rescale this how you like\n    uv = 4.*vec2(1,iResolution.y/iResolution.x)*uv;\n    \n    return uv;\n}\n\n\n\n\n//starting from Poincare Disk:\n//if you want to draw this picture in the half plane (where we did the computation)\n//simply delete the contents of this function and just have it \"return uv\"\nvec2 toUHP(vec2 uv){\n\n//do a rotation slowly\n    float c=cos(iTime/5.);\n    float s=sin(iTime/5.);\n    uv=mat2(c,s,-s,c)*uv;\n    \n\n//move to half plane\n    float Re = 2.*uv.x;\n    float Im = 1.-dot(uv,uv);\n    vec2 temp=vec2(1.-uv.y,uv.x);\n    float Scale = dot(temp,temp);\n    return 1./Scale*vec2(Re,Im);\n   \n\n    //return uv;\n  }\n  \n  \n//just packing the sinusoidal oscillation which oscillates between a and b into its own function\nfloat osc(float a,float b, float t){\nreturn abs(b-a)/2.*(1.+sin(t))+a;\n}\n\n\n\n\n//------------------------------------------\n//making the main image\n//------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    //set up the input\n    vec2 uv = normalizedFragCoord(fragCoord);\n    \n    //if you are outside the poincare disk, make black\n    if(length(uv)>1.){\n        fragColor=vec4(0,0,0,1);\n        return;\n      }\n    \n    //map to upper half plane for computation:\n    vec2 p = toUHP(uv);\n    \n    //setup the fundamental domain we are working with\n    setUpFD(osc(0.01,1.,iTime/3.),osc(0.5,2.5,iTime/1.));\n   \n    //reflect into the fundamental domain\n    float invCount=0.;\n    moveToFD(p,invCount);\n\n    // color the pixel based on this\n    //right now this is a very boring coloring: \n    //we just count if theres an even or odd number of reflections!\n    float evenOdd=mod(invCount,2.);\n    vec3 col=vec3(0.3,0.6-evenOdd,evenOdd);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}