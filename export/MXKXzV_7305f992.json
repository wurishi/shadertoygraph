{"ver":"0.1","info":{"id":"MXKXzV","date":"1720221468","viewed":50,"name":"not my not first raymarcher ","username":"NoahSchrr","description":"floop ploop boop","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarcher"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_ITERATIONS = 50;\nconst float SURFACE_THRESHOLD = 0.0001;\nconst float MAX_DISTANCE = 10.0;\n\nfloat smoothMin(float distA, float distB, float smoothing){\n    float h = max(smoothing - abs(distA-distB), 0.0) / smoothing;\n    return min(distA, distB) - h*h*h*smoothing*(1.0/6.0);\n}\n\n\n\nfloat distanceToBox( vec3 currentPosition,vec3 boxPos, vec3 boxDimensions ){\n  vec3 q = abs(currentPosition - boxPos) - boxDimensions;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat distanceToSphere(vec3 currentPosition, vec3 spherePosition, float radius){\n    return length(currentPosition - spherePosition) - radius;\n}\n\n\n\nfloat sceneDistances(vec3 currentPosition){\n    float sphereA = distanceToSphere(currentPosition, vec3(-0.5 * sin(iTime), 0.0, -1.0), 0.15);\n    float boxA = distanceToBox(currentPosition, vec3(0.5 * sin(iTime), 0.0, -1.0), vec3(0.1 , 0.1, 0.1));\n    \n    float result = smoothMin(sphereA, boxA, 1.0);\n    return result;\n}\n\n\n\n\nfloat performRayMarching(vec3 rayOrigin, vec3 rayDirection) {\n    float totalDistance = 0.0;\n\n    for (int i = 0; i < MAX_ITERATIONS; i++) {\n        vec3 currentPosition = rayOrigin + rayDirection * totalDistance;\n        float distanceToScene = sceneDistances(currentPosition);\n        \n        if (distanceToScene < SURFACE_THRESHOLD) {\n            break;\n        }\n        \n        totalDistance += distanceToScene;\n        \n        if (totalDistance > MAX_DISTANCE) {\n            break;\n        }\n    }\n\n    return totalDistance;\n}\n\n\n\nvec3 computeRayDirection(vec2 uv) {\n    vec3 direction = vec3(uv - vec2(0.5), 1.0); \n    direction.x *= iResolution.x / iResolution.y; \n    return normalize(direction);\n}\n\n\nvec3 estimateNormal(vec3 p) {\n    const float epsilon = 0.0001; \n\n    float centerDistance = sceneDistances(p);\n\n    float xDistance = sceneDistances(p + vec3(epsilon, 0.0, 0.0));\n    float yDistance = sceneDistances(p + vec3(0.0, epsilon, 0.0));\n    float zDistance = sceneDistances(p + vec3(0.0, 0.0, epsilon));\n\n    vec3 normal = normalize(vec3(xDistance, yDistance, zDistance) - centerDistance);\n\n    return normal;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 rayOrigin = vec3(0.0, 0.0, -2.0);\n    vec3 rayDirection = computeRayDirection(uv);\n    \n    float dist = performRayMarching(rayOrigin, rayDirection);\n\n    vec3 col;\n    if (dist < MAX_DISTANCE) {\n        col = 0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0, 2, 4)) + 0.5 + 0.5 * estimateNormal(rayOrigin + rayDirection * dist);\n    } else {\n        col = vec3(0.01, 0.11, 0.17);\n    }\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}