{"ver":"0.1","info":{"id":"stKcDm","date":"1661640016","viewed":111,"name":"Smooth External Ray","username":"PhDFractal","description":"Smooth External Ray Shader, cycles every 1 minute. Angle: rounded sawtooth map θ↦p×(θ-(2/p)×π×round((p/2)×θ/π)): p∈{2,3,4,5}. Uses only single precision. Compare Absolute Julia Set/Julia Set of external rays.\nhttps://en.wikipedia.org/wiki/External_ray.","likes":5,"published":1,"flags":48,"usePreview":1,"tags":["fractal","mandelbrot","rays","gradient","comparison"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"////////////////////////////////////////////////////////////////////////////////\n//\n// Smooth External Ray\n//\n// Also uses continuous escape algorithm.\n// See @iq:https://www.shadertoy.com/view/4df3Rn.\n//\n// Coloring algorithm for smooth external rays of Mandelbrot Set and Multibrots\n// of powers 3,4,5, and Absolute Julias. The map is the rounded sawtooth:\n// θ↦p×(θ-(2/p)×π×round((p/2)×θ/π)). Mandelbrot: z↦z²³⁴⁵+c. Hence the principal\n// external ray is not identifiable, but among the p^i rays in iteration i.\n// Smooth escape algorithm was used, and the width of the external rays smoothly\n// decreases by a factor of p per iteration. For higher p the density is greater\n// and the iterations smaller, and the ray easier to identify. In the Julia Sets\n// of the Mandelsquare z↦z⁵+c even the boundary of the rays can be seen.\n//\n// Press 'p' to cycle through powers 2,3,4,5.\n//\n// Press 'o' for original Mandelbrot, and 'o' again for Julia comparison.\n// The seed is already synchronized.\n//\n// The rays will cycle through 60/(p-1) seconds per cusp in original Mandelbrots\n// and 60p through the whole Julias, where p is the power; by the minute.\n//\n// Only 25,16,12,11 iterations used for z↦z²³⁴⁵+c due to low precision. \n// \n////////////////////////////////////////////////////////////////////////////////\n\n// Created by PhdFractal: https://www.youtube.com/channel/UCY-W4FvxaNRoZ8N5b-KzSZg\n// I share this piece (art and code) here in Shadertoy and through its Public API,\n// only for educational purposes. You cannot use, sell, share or host this piece\n// or modifications of it as part of your own commercial or non-commercial product\n// website or project. You cannot use, sell, share or host this piece or modifications\n// of it as part of your own commercial or non-commercial product, website or project.\n// You can share a link to it or an unmodified screenshot of it provided you attribute\n// \"by PhdFractal (@Fractal MathPro)\".\n\nbool keypress(int code){ return texelFetch(iChannel0,ivec2(code,2),0).x != 0.0; }    //for switching modes\nvec4 store(int i,int j) { return texelFetch(iChannel1,ivec2(i,j),0); }               //for counting presses\nint keycount(int key) { return int(store(0,key).x); }\n//from Wythoffian Tiling Generator: https://www.shadertoy.com/view/wlGSWc (@mla)\nvec4 rainbow(float i,float density){                                                 //rainbow palette\n    vec4 black=vec4(0.,0.,0.,1.); vec4 red=vec4(1.,0.,0.,1.); vec4 yellow=vec4(1.,1.,0.,1.);\n    vec4 green=vec4(0.,1.,0.,1.); vec4 cyan=vec4(0.,0.698,1.,1.); vec4 blue=vec4(0.,0.,1.,1.);\n    float r=(i*density-5.)-100.*floor((i*density-5.)/100.); float R=0.;\n    if(r<16.){ R=r/16.; return R*red+(1.-R)*black; }\n    else if(r>=16. && r<31.){ R=(r-16.)/15.; return R*yellow+(1.-R)*red; }\n    else if(r>=31. && r<45.){ R=(r-31.)/14.; return R*green+(1.-R)*yellow; }\n    else if(r>=45. && r<62.){ R=(r-45.)/17.; return R*cyan+(1.-R)*green; }\n    else if(r>=62. && r<78.){ R=(r-62.)/16.; return R*blue+(1.-R)*cyan; }\n    else{ R=(r-78.)/22.; return R*black+(1.-R)*blue; }\n}\nvec2 sqr(vec2 z){ return vec2(z.x*z.x-z.y*z.y,2.*z.x*z.y); }                         //square, cube, quad, pent\nvec2 cube(vec2 z){ return vec2(z.x*z.x*z.x-3.*z.x*z.y*z.y,3.*z.x*z.x*z.y-z.y*z.y*z.y); }\nvec2 quad(vec2 z){ return vec2(z.x*z.x*z.x*z.x-6.*z.x*z.x*z.y*z.y+z.y*z.y*z.y*z.y\n                               ,4.*z.x*z.x*z.x*z.y-4.*z.x*z.y*z.y*z.y); }\nvec2 pent(vec2 z){ return vec2(z.x*z.x*z.x*z.x*z.x-10.*z.x*z.x*z.x*z.y*z.y+5.*z.x*z.y*z.y*z.y*z.y\n                               ,5.*z.x*z.x*z.x*z.x*z.y-10.*z.x*z.x*z.y*z.y*z.y+z.y*z.y*z.y*z.y*z.y); }\nfloat pi=3.14159265359;                                                              //π\nfloat arg(vec2 z){                                                                   //argument\n    float magn=sqrt(z.x*z.x+z.y*z.y);\n    if(magn==0.) { return 0.; }\n    float arg=acos(z.x/magn);\n    if(z.y>=0.){ return arg; }\n    else{ return -arg; }\n}\nfloat thickness=0.5; float realthick=0.; float index=0.; float density=0.; float offset=0.;\nvec4 extcolor(vec2 z,float angleIter,int iter, int p) //algorithm for continuous escape plus smooth external ray\n{\n  realthick=thickness*log(dot(z,z))/log(1e3)/float(p); density=4.*log(float(p))/log(2.); offset=20./density;\n  index=float(iter)+(log(log(1e3))-log(log(dot(z,z))/float(p)))/log(float(p));\n  if(angleIter>=pi-realthick){                                             //shade ray very close to +π\n    if(abs(arg(-z)+pi-angleIter)<=realthick){ return rainbow(index+offset,density); } }\n  else if(angleIter<=realthick-pi){                                        //shade ray very close to –π\n    if(abs(arg(-z)-pi-angleIter)<=realthick){ return rainbow(index+offset,density); } }\n  else{                                                                    //shade ray regular\n    if(abs(arg(z)-angleIter)<=realthick){ return rainbow(index+offset,density); } }\n  return rainbow(index,density);\n}\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec2 c=4.*vec2(iMouse.x-.5*iResolution.x,iMouse.y-.5*iResolution.y)/iResolution.x;\n    bool isOriginal=keypress(79);      //Press key 'o' for original\n    int mode=keycount(80)%4;           //Press key 'p' to switch powers (cycles through 2,3,4,5)\n    vec4 color=vec4(0.,0.,0.,1.); vec2 z1=vec2(0.,0.);\n    vec2 z0=vec2(0.,0.); vec2 pix=fragCoord/iResolution.x-.5*vec2(1,iResolution.y/iResolution.x);\n    vec2 z=vec2(0.,0.); float ray=2.*pi*(iTime/60.-floor(iTime/60.)); float angleIter=ray;\n    if(!isOriginal){\n    if(mode==0){\n    for(int i=0; i<25; i++){ //Power 2 Original\n        z=sqr(z0)+4.*pix-vec2(0.5,0.);\n        if(dot(z,z)>1e3){ color=extcolor(z,angleIter,i,2); break; }\n        else{ z0=z; } angleIter=2.*(angleIter-pi*round(angleIter/pi)); } }\n    else if(mode==1){\n    for(int i=0; i<16; i++){ //Power 3 Original\n        z=cube(z0)+4.*pix;\n        if(dot(z,z)>1e3){ color=extcolor(z,angleIter,i,3); break; }\n        else{ z0=z; } angleIter=3.*(angleIter-2./3.*pi*round(1.5*angleIter/pi)); } }\n    else if(mode==2){\n    for(int i=0; i<12; i++){ //Power 4 Original\n        z=quad(z0)+4.*pix;\n        if(dot(z,z)>1e3){ color=extcolor(z,angleIter,i,4); break; }\n        else{ z0=z; } angleIter=4.*(angleIter-0.5*pi*round(2.*angleIter/pi)); } }\n    else {\n    for(int i=0; i<11; i++){ //Power 5 Original\n        z=pent(z0)+4.*pix;\n        if(dot(z,z)>1e3){ color=extcolor(z,angleIter,i,5); break; }\n        else{ z0=z; } angleIter=5.*(angleIter-0.4*pi*round(2.5*angleIter/pi)); } } }\n    else{\n    if(mode==0){ c=c-vec2(0.5,0.); //Power 2 Julias\n    if(pix.x<=0.){ z1=4.*pix+vec2(1.,0.);\n    for(int i=0; i<25; i++){\n        z=sqr(z0)+sqr(z1)+c;\n        if(dot(z,z)>1e3){ color=extcolor(z,angleIter,i,2); break; }\n        else{ z0=z; } angleIter=2.*(angleIter-pi*round(angleIter/pi)); } }\n    else{         z0=4.*pix-vec2(1.,0.);\n    for(int i=0; i<25; i++){\n        z=sqr(z0)+c;\n        if(dot(z,z)>1e3){ color=extcolor(z,angleIter,i,2); break; }\n        else{ z0=z; } angleIter=2.*(angleIter-pi*round(angleIter/pi)); } } }\n    else if(mode==1){              //Power 3 Julias\n    if(pix.x<=0.){ z1=4.*pix+vec2(1.,0.);\n    for(int i=0; i<16; i++){\n        z=cube(z0)+cube(z1)+c;\n        if(dot(z,z)>1e3){ color=extcolor(z,angleIter,i,3); break; }\n        else{ z0=z; } angleIter=3.*(angleIter-2./3.*pi*round(1.5*angleIter/pi)); } }\n    else{         z0=4.*pix-vec2(1.,0.);\n    for(int i=0; i<16; i++){\n        z=cube(z0)+c;\n        if(dot(z,z)>1e3){ color=extcolor(z,angleIter,i,3); break; }\n        else{ z0=z; } angleIter=3.*(angleIter-2./3.*pi*round(1.5*angleIter/pi)); } } }\n    else if(mode==2){              //Power 4 Julias\n    if(pix.x<=0.){ z1=4.*pix+vec2(1.,0.);\n    for(int i=0; i<12; i++){\n        z=quad(z0)+quad(z1)+c;\n        if(dot(z,z)>1e3){ color=extcolor(z,angleIter,i,4); break; }\n        else{ z0=z; } angleIter=4.*(angleIter-0.5*pi*round(2.*angleIter/pi)); } }\n    else{         z0=4.*pix-vec2(1.,0.);\n    for(int i=0; i<12; i++){\n        z=quad(z0)+c;\n        if(dot(z,z)>1e3){ color=extcolor(z,angleIter,i,4); break; }\n        else{ z0=z; } angleIter=4.*(angleIter-0.5*pi*round(2.*angleIter/pi)); } } }\n    else{                          //Power 5 Julias\n    if(pix.x<=0.){ z1=4.*pix+vec2(1.,0.);\n    for(int i=0; i<11; i++){\n        z=pent(z0)+pent(z1)+c;\n        if(dot(z,z)>1e3){ color=extcolor(z,angleIter,i,5); break; }\n        else{ z0=z; } angleIter=5.*(angleIter-0.4*pi*round(2.5*angleIter/pi)); } }\n    else{         z0=4.*pix-vec2(1.,0.);\n    for(int i=0; i<11; i++){\n        z=pent(z0)+c;\n        if(dot(z,z)>1e3){ color=extcolor(z,angleIter,i,5); break; }\n        else{ z0=z; } angleIter=5.*(angleIter-0.4*pi*round(2.5*angleIter/pi)); } } } }\n    fragColor=color;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define keystate(k,n) (texelFetch(iChannel0,ivec2(k,n),0))\nvoid mainImage(out vec4 t,vec2 uv){\n#if __VERSION__ < 300\n    t = vec4(0);\n#else    \n    int i=int(uv.x); int j=int(uv.y);\n    if(iFrame==0) { t=vec4(0); }\n    else{ t=texelFetch(iChannel1,ivec2(i,j),0); } //Get current state\n    if(i==0){ float w1 = keystate(j,2).x;\n        if (w1!=t.w) { t.w=w1; t.x++; } }\n#endif           \n} //from Wythoffian Tiling Generator: https://www.shadertoy.com/view/wlGSWc (@mla)","name":"Buffer A","description":"","type":"buffer"}]}