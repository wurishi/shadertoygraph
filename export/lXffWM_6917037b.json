{"ver":"0.1","info":{"id":"lXffWM","date":"1728460481","viewed":35,"name":"Mean shift clustering","username":"Ultraviolet","description":"Yet another clustering algo.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["clustering","meanshift"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec2 rest_pos(int id) {\n    return SCREEN2WORLD(hash21(float(id)) * iResolution.xy);\n}\n\nvec2 pos(int id) {\n    vec2 low  = SCREEN2WORLD(vec2(0.));\n    vec2 high = SCREEN2WORLD(iResolution.xy);\n    \n    vec2 p = rest_pos(id) + iTime*speed(id);\n    BoxReflect(p, vec2(radius)+low, high-vec2(radius));\n    \n    return p;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 X = SCREEN2WORLD(fragCoord);\n    vec3 col = vec3(1.);\n    \n#ifdef DRAW_GRID\n    DRAW_C(Grid(1.), X, vec3(.1), .5, col);\n    DRAW_C(Ray(vec2(0.), vec2(1.,0.)), X, vec3(.0), 1., col);\n    DRAW_C(Ray(vec2(0.), vec2(0.,1.)), X, vec3(.0), 1., col);\n#endif\n    \n#ifdef DRAW_CLUSTER_PARTICLE\n    for(int i=0; i < NB_PARTICLES; ++i) {\n        vec2 p0 = pos(i);\n        vec2 cluster_pos = texelFetch(iChannel0, ivec2(i, 0), 0).xy;\n        vec2 cluster_uv = SCREEN2UV(WORLD2SCREEN(cluster_pos));\n        //vec3 cluster_col = colormap(cluster_uv);\n        vec3 cluster_col = hash32(cluster_uv);\n        cluster_col = mix(vec3(1.), cluster_col, 0.5);\n        \n        DRAW(Circle(cluster_pos, radius*2.), X, cluster_col, col);\n    }\n#endif\n    \n#ifdef DRAW_PARTICLE\n    for(int i=0; i < NB_PARTICLES; ++i) {\n        vec2 p0 = pos(i);\n        vec2 cluster_pos = texelFetch(iChannel0, ivec2(i, 0), 0).xy;\n        vec2 cluster_uv = SCREEN2UV(WORLD2SCREEN(cluster_pos));\n        //vec3 cluster_col = colormap(cluster_uv);\n        vec3 cluster_col = hash32(cluster_uv);\n        \n        DRAW(Circle(p0, radius), X, cluster_col, col);\n    }\n#endif\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n#define PI 3.14\n\n#define EPSILON (1e-8)\n#define SPEED 0.0\n#define NB_PARTICLES 50\n#define WINDOW 0.75\n\n// display options\n//#define DRAW_GRID\n#define DRAW_PARTICLE\n#define DRAW_CLUSTER_PARTICLE\n\n\n\nfloat radius = 0.03;\n\n\n#define SCREEN2WORLD(X)  ((X -iResolution.xy*.5)/iResolution.y*3.)\n#define WORLD2SCREEN(X)  ((X*iResolution.y/3. +iResolution.xy*.5))\n#define SCREEN2UV(X)  (X/iResolution.xy)\n\nvoid BoxReflect(inout float p, in float bbmin, in float bbmax)\n{    \n    p =  bbmax-(abs(bbmax-mod( p - bbmin, (bbmax-bbmin)*2.) - bbmin));    \n}\n\nvoid BoxReflect(inout vec2 p, in vec2 bbmin, in vec2 bbmax)\n{\n    BoxReflect(p.x, bbmin.x, bbmax.x);\n    BoxReflect(p.y, bbmin.y, bbmax.y);\n}\n\nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb);\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n// thx Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec2 speed(int id) {\n    float alpha = hash11(float(id)) * 2. * PI;\n    return vec2(cos(alpha), sin(alpha)) * SPEED;\n}\n\n\n////////////////////////////////////////////////////////////////////////////\n//      ___  ____  __   _  _  ____  ____  ____  _  _      __    __  ____ \n//     / __)(  __)/  \\ ( \\/ )(  __)(_  _)(  _ \\( \\/ )    (  )  (  )(  _ \\\n//    ( (_ \\ ) _)(  O )/ \\/ \\ ) _)   )(   )   / )  /     / (_/\\ )(  ) _ (\n//     \\___/(____)\\__/ \\_)(_/(____) (__) (__\\_)(__/      \\____/(__)(____/\n//\n////////////////////////////////////////////////////////////////////////////\n\n\n//---------------------------------------\n// Point\n\nfloat dist(vec2 p0, vec2 p1)\n{\n    return length(p1-p0);\n}\n\n\n\n\n//---------------------------------------\n// Circle\n\nstruct Circle\n{\n    vec2 ctr;\n    float rad;\n};\n\nvec2 getPt(Circle c, float t)\n{\n    return c.ctr + c.rad*vec2(cos(t*PI*2.), sin(t*PI*2.));\n}\n    \nfloat dist(Circle c, vec2 p)\n{\n    return (length(c.ctr-p)-c.rad);\n}\n\n    \n    \n//---------------------------------------\n// Ray\n\nstruct Ray\n{\n    vec2 org;\n    vec2 dir;\n};\n    \nvec2 getPt(Ray r, float t)\n{\n    return r.org + t*r.dir;\n}\n\nfloat dist(Ray r, vec2 p)\n{\n    return abs(dot(r.dir.yx*vec2(-1., 1.), p-r.org)/dot(r.dir, r.dir));\n    \n    \n    float t = dot(r.dir, p-r.org);\n    t = max(t, 0.);\n    return length(getPt(r, t) - p);\n}\n\n\n\n\n//---------------------------------------\n// Segment\n\nstruct Segment\n{\n    vec2 A;\n    vec2 B;\n};\n\nvec2 getPt(Segment c, float t)\n{\n    return mix(c.A, c.B, t);\n}\n\nfloat dist(Segment s, vec2 p)\n{\n\tvec2 pa = p-s.A, ba = s.B-s.A;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\n\n\n\n\n//---------------------------------------\n// Triangle\n\nstruct Triangle\n{\n    vec2 p0;\n    vec2 p1;\n    vec2 p2;\n};\n\n\nfloat dist(Triangle t, in vec2 p )\n{\n\tvec2 e0 = t.p1 - t.p0;\n\tvec2 e1 = t.p2 - t.p1;\n\tvec2 e2 = t.p0 - t.p2;\n\n\tvec2 v0 = p - t.p0;\n\tvec2 v1 = p - t.p1;\n\tvec2 v2 = p - t.p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n\n//---------------------------------------\n// Grid\n\nstruct Grid\n{\n    float inter;\n}; \n\nfloat dist(Grid g, vec2 p)\n{\n    vec2 d = abs(mod(p+g.inter*.5,g.inter*2.)-g.inter)-g.inter*.5;\n    return max(min(d.x, d.y), min(-d.x, -d.y));\n}\n\n\n\n\n//---------------------------------------\n// Drawing Macros\n\n// draw the inside of the shape\n// O = object, P = point, C = drawing color, CC = original color\n#define DRAW(O,P,C,CC)\tCC=mix(CC,C,mix(1.,0.,clamp(dist(O,P)*iResolution.y/2., -1., 1.)*.5+.5))\n\n// draw the inside of the shape, with alpha\n#define DRAW_A(O,P,C,CC)\tCC=mix(CC,C.rgb,(mix(1.,0.,clamp(dist(O,P)*iResolution.y/2., -1., 1.)*.5+.5))*C.a)\n\n// draw the contour of the shape \n#define DRAW_C(O,P,C,W,CC)\tCC=mix(CC,C,mix(1.,0.,clamp(abs(dist(O,P))*iResolution.y/2.-W, -1., 1.)*.5+.5))\n\n// draw the contour of the shape with alpha\n#define DRAW_CA(O,P,C,W,CC)\tCC=mix(CC,C.rgb,(mix(1.,0.,clamp(abs(dist(O,P))*iResolution.y/2. -  W, -1., 1.)*.5+.5))*C.a)\n\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvec2 rest_pos(int id) {\n    return SCREEN2WORLD(hash21(float(id)) * iResolution.xy);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(fragCoord.y > 1. || fragCoord.x > float(NB_PARTICLES))\n        discard;\n    \n    int id = int(fragCoord.x);\n    \n    if(iFrame == 0) {\n        fragColor = vec4(rest_pos(id),0.0,0.0);\n        return;\n    }\n    \n    vec2 self_pos = texelFetch(iChannel0, ivec2(id, 0), 0).xy;\n\n    float weight_sum = 0.;\n    vec2 mean = vec2(0.);\n    for(int i=0; i < NB_PARTICLES; ++i) {\n        vec2 neib_pos = texelFetch(iChannel0, ivec2(i, 0), 0).xy;\n        //vec2 neib_pos = pos(i);\n        if(distance(self_pos, neib_pos) > WINDOW)\n            continue;\n        mean += neib_pos;\n        weight_sum += 1.;\n    }\n\n    self_pos = mean / weight_sum;\n    \n    fragColor = vec4(self_pos,0.0,0.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}