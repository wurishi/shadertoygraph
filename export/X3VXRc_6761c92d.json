{"ver":"0.1","info":{"id":"X3VXRc","date":"1720334435","viewed":31,"name":"bezierpattern","username":"maxiie","description":"bezier","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["bezier"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 O, in vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord -.5*iResolution.xy ) / iResolution.y;\n\n    float angle = iTime*.1,\n          s = sin(angle),\n          c = cos(angle);\n    \n    mat2 rotationMatrix = mat2( c, s, -s,  c);\n    \n    uv = rotationMatrix * uv + .5;\n\n    O = max( texture(iChannel0, uv),\n             texture(iChannel1, uv) );\n    O.w = 0.;\n    O = normalize(O);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\nInfo on curves:\nhttp://research.microsoft.com/en-us/um/people/hoppe/ravg.pdf\nhttp://research.microsoft.com/en-us/um/people/cloop/LoopBlinn05.pdf\nhttp://www.pouet.net/topic.php?which=9119&page=1\nhttp://blog.gludion.com/2009/08/distance-to-quadratic-bezier-curve.html\n\nThe top link is where the get_distance_vector comes from.\n\nThanks also to other bezier curve shadertoys:\nhttps://www.shadertoy.com/view/XsX3zf\nhttps://www.shadertoy.com/view/lts3Df\n*/\n\n#define EDGE   0.005\n#define SMOOTH 0.0025\n\n// signed distance function for Circle, for control points\n\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\nvec2 get_distance_vector(vec2 b0, vec2 b1, vec2 b2) {\n  float a=det(b0,b2), b=2.0*det(b1,b0), d=2.0*det(b2,b1); // ð›¼,ð›½,ð›¿(ð‘)\n  float f=b*d-a*a; // ð‘“(ð‘)\n  vec2 d21=b2-b1, d10=b1-b0, d20=b2-b0;\n  vec2 gf=2.0*(b*d21+d*d10+a*d20);\n  gf=vec2(gf.y,-gf.x); // âˆ‡ð‘“(ð‘)\n  vec2 pp=-f*gf/dot(gf,gf); // ð‘â€²\n  vec2 d0p=b0-pp; // ð‘â€² to origin\n  float ap=det(d0p,d20), bp=2.0*det(d10,d0p); // ð›¼,ð›½(ð‘â€²)\n  // (note that 2*ap+bp+dp=2*a+b+d=4*area(b0,b1,b2))\n  float t=clamp((ap+bp)/(2.0*a+b+d), 0.0, 1.0); // ð‘¡Ì…\n  return mix(mix(b0,b1,t),mix(b1,b2,t),t); // ð‘£ð‘– = ð‘(ð‘¡Ì…)\n}\n\nfloat approx_distance(vec2 p, vec2 b0, vec2 b1, vec2 b2) {\n  return length(get_distance_vector(b0-p, b1-p, b2-p));\n}\n\n//-----------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 percent = fragCoord / iResolution.y - vec2(.444,.625);\n    percent.x *= aspectRatio;\n    \n\n    vec2 A = vec2(0.0,-0.5);\n    vec2 B = vec2(0.5,0.25);\n    vec2 C = vec2(1.0,-0.5);\n\n    vec3 color = vec3(0);\n    float dist = 0.;\n\t\n    \n    \n    dist = approx_distance(percent, A, B, C);\n    if (dist < EDGE + SMOOTH)\n    {\n        dist = smoothstep(EDGE - SMOOTH,EDGE + SMOOTH,dist);\n        color = vec3(0,dist,0);\n    }\n\n    dist = approx_distance(percent, B, C, A);\n    if (dist < EDGE + SMOOTH)\n    {\n        dist = smoothstep(EDGE - SMOOTH,EDGE + SMOOTH,dist);\n        color = vec3(dist,0,0);\n    }\n    dist = approx_distance(percent, C, A, B);\n    if (dist < EDGE + SMOOTH)\n    {\n        dist = smoothstep(EDGE - SMOOTH,EDGE + SMOOTH,dist);\n        color = vec3(0,0,dist);\n    }\n\tfragColor = vec4(color,1.0);\n}\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float angle = iTime*0.1;\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    mat2 rotationMatrix = mat2( c, s,\n                               \t-s,  c);\n    \n    vec2 pivot = vec2( 0.5, 0.5);\n\n\n    // alternative that doesn't warp, scaled to the aspect ratio if. Thanks FabriceNeyret2!\n    //uv = rotationMatrix * ( fragCoord - .5*iResolution.xy ) / iResolution.y;\n    uv = rotationMatrix * (uv - pivot) + pivot;\n\n    vec3 col = texture(iChannel0, uv).xyz;\n    vec3 col2=texture(iChannel1, uv).xyz;\n    col=(col+12.*col2*length(col2))/(12.*length(col2)+1.);\n\n    fragColor = vec4(col,1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}