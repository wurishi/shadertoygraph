{"ver":"0.1","info":{"id":"4tdGWB","date":"1471476800","viewed":1611,"name":"2D: {s,q,n}lerp","username":"MBR","description":"normal interp with slerp, qlerp and nlerp","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["normal","interpolation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// viz for: http://marc-b-reynolds.github.io/quaternions/2017/04/19/slerp0.html\n\n\n// 2D version\n//  blue = slerp\n//  red  = qlerp\n//  mag  = lerp\n\n// ba^* \nvec2 z_mulc(vec2 a, vec2 b)\n{\n  return vec2(dot(a,b), a.x*b.y-a.y*b.x);\n}\n\n// z^2\nvec2 z_pow2(vec2 z)\n{\n  float x = 2.0*z.x;\n  return vec2(z.x*x-1.0, x*z.y);\n}\n\n// sqrt(z) when |z|=1\nvec2 z_usqrt(vec2 z)\n{\n  float t = 1.0+z.x;\n  float s = inversesqrt(t+t);\n  \n  return vec2(s*t, s*z.y);\n}\n\nvec2 nlerp(vec2 A, vec2 B, float t)\n{\n  return normalize(mix(A, B, t));\n}\n\nvec2 slerp(vec2 A, vec2 B, float t)\n{\n  vec2  z = z_mulc(A,B);\n  float a = acos(z.x);\n  float c = cos(a*t);\n  float s = sqrt(1.0-c*c);\n  s = (z.y >= 0.) ? s : -s;\n    \n  return c*A + s*vec2(-A.y, A.x); \n}\n\nvec2 qlerp(vec2 A, vec2 B, float t)\n{\n  vec2 z = z_mulc(A,B);\n  vec2 h = z_usqrt(z);\n  vec2 m = normalize(vec2(1.0-t+t*h.x, t*h.y));\n  vec2 r = z_pow2(m);  \n    \n  return r.x*A + r.y*vec2(-A.y, A.x);\n}\n\n\n// Viz junk below here\n\n#define W0 0.5545497\n#define W1 0.308517\n#define W3 0.618034\n\n// [-1,1]\nfloat tnoise(in vec2 c)\n{   \n  c = c*fract(c*vec2(W0,W1));\n  float p  = c.x*c.y;\n  float i  = floor(p);\n  float u0 = p-i;\n  float u1 = fract(W3*i);\n  return u0-u1;\n}\n\nfloat circle(vec2 uv, vec3 c)\n{\n  float r = length(c.xy - uv);\n  float d = abs(r - c.z);  \n  return smoothstep(0.015, 0.0, d) + 0.5*smoothstep(0.06, 0.01, r-c.z);\n}\n\nfloat saturate(float x)\n{\n  return clamp(x, 0.0, 1.0);\n}\n\nfloat seg(vec2 p, vec2 a, vec2 b, float r)\n{  \n  b = b-a;\n  a = p-a;\n    \n  float h  = saturate(dot(a,b)/dot(b,b));\n  float d  = length(a - b*h) - r;\n  \n  return smoothstep(0.0095, 0.0, d);\n}\n\n#define RADIUS 0.6\n#define LW     0.004\n#define LL     1.5*RADIUS\n\nconst vec2 x0 = vec2(RADIUS, 0.0);\nconst vec2 y0 = vec2(0.0, RADIUS);\n\nconst vec3 blue  = vec3(0.7, 0.7, 1.9);\nconst vec3 red   = vec3(1.9, 0.7, 0.7);\nconst vec3 green = vec3(0.5, 0.9, 0.5);\nconst vec3 mag   = vec3(0.8, 0.4, 0.8);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  float ar = iResolution.x / iResolution.y;\n  vec2  ir = 1.0/iResolution.xy;\n  vec2 uv = 2.0 * (fragCoord.xy*ir) - 1.0;\n  uv.x *= ar;\n  float t = abs(1.0 -(fract(iTime*.25) * 2.0));\n    \n  vec2 A = vec2(1.0, 0.0);\n  vec2 B = (2.0 * iMouse.xy*ir) - 1.0;\n  B.x *= ar;\n  B = normalize(B);\n \n  if (iMouse.w > 0.0) {\n    A = (2.0 * iMouse.zw*ir) - 1.0;\n    A.x *= ar;\n    A = normalize(A);\n  }\n\n  vec2 rl = nlerp(A,B,t);\n  vec2 rs = slerp(A,B,t);\n  vec2 rq = qlerp(A,B,t);\n  \n  vec3 c = vec3(0.0);\n  vec2 o = vec2(0.0);\n  \n  c  += 0.85     *seg(uv, o, LL*A,  LW); // A\n  c  += 0.85     *seg(uv, o, LL*B,  LW); // B\n  c  += 0.85*mag *seg(uv, o, LL*rl, LW); // nlerp(A,B,t)\n  c  += 0.85*blue*seg(uv, o, LL*rs, LW); // slerp(A,B,t)\n  c  += 0.85*red *seg(uv, o, LL*rq, LW); // qlerp(A,B,t)\n    \n  //c += blue*vec3(0.5, 0.5, 0.5) * circle(uv, RADIUS*vec3(rq.x, rq.y, .04));\n    \n  // reference circle and add some SS noise\n  c += vec3(0.5, 0.5, 0.5) * circle(uv, vec3(0, 0, RADIUS));\n  c  = c+(8.0/256.0)*tnoise(fragCoord);\n    \n  fragColor = vec4(c, 1.0);\n}","name":"Image","description":"","type":"image"}]}