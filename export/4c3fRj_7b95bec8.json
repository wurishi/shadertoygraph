{"ver":"0.1","info":{"id":"4c3fRj","date":"1733247610","viewed":638,"name":"eye of old magic dragon","username":"nayk","description":"originals https://www.shadertoy.com/view/MdXSzS https://www.shadertoy.com/view/lslyRn# https://www.shadertoy.com/view/MfcfWN https://www.shadertoy.com/view/dstcWX","likes":12,"published":3,"flags":1,"usePreview":0,"tags":["star","bubble"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Star Nest by Pablo RomÃ¡n Andrioli\n// copied from https://www.shadertoy.com/view/XlfGRj\n//\n// This content is under the MIT License.\n// (copied for API availability + VR)\n\n#define iterations 12\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.000 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\nfloat happy_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\n \n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n\t//get coords and direction\n\tvec3 dir=rd;\n\tvec3 from=ro;\n\t\n\t//volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam;\n            p.xy*=mat2(cos(iTime*0.01),sin(iTime*0.01),-sin(iTime*0.01), cos(iTime*0.01));// the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.2-dm; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\tfragColor = vec4(v*.01,1.);\t\n}\n\nfloat numOct  = 4. ;  //number of fbm octaves\nfloat focus = 0.;\nfloat focus2 = 0.;\n#define pi  3.14159265\n\nfloat random(vec2 p) {\n    //a random modification of the one and only random() func\n    return fract( sin( dot( p, vec2(12., 90.)))* 5e5 );\n}\n\nmat2 rot2(float an){float cc=cos(an),ss=sin(an); return mat2(cc,-ss,ss,cc);}\n\n//this is the noise func everyone uses...\nfloat noise(vec3 p) {\n    vec2 i = floor(p.yz);\n    vec2 f = fract(p.yz);\n    float a = random(i + vec2(0.,0.));\n    float b = random(i + vec2(1.,0.));\n    float c = random(i + vec2(0.,1.));\n    float d = random(i + vec2(1.,1.));\n    vec2 u = f*f*(3.-2.*f); \n    \n    return mix( mix(a,b,u.x), mix(c,d,u.x), u.y);\n}\n\nfloat fbm3d(vec3 p) {\n    float v = 0.;\n    float a = .35;\n\n    for (float i=0.; i<numOct; i++) {\n        v += a * noise(p);\n        a *= .25*(1.2+focus+focus2);\n    }\n    return v;\n}\n\n#define S (1. + sin(iTime) / 4.)\n#define C (1. + cos(iTime) / 4.)\n#define SMOOTH(r,R) (1.0-smoothstep(R-1.0,R+1.0, r))\n#define SMOOTH2(r,R) (1.0-smoothstep(R-0.01, R+0.01, r))\n#define SS(r,R) (smoothstep(r-0.005, r+0.005, R))\n#define ROT(p, a) (mat2(cos(a),-sin(a),sin(a),cos(a))*p)\n\n\n// fork1: https://www.shadertoy.com/view/fdK3DD\n// fork2: https://www.shadertoy.com/view/4dVXWy\n// fork3: https://www.shadertoy.com/view/MlyGzW\n\nconst float PI = 3.14159;\nconst float TAU = PI * 2.;\nconst float QTR_PI = PI / 4.;\n\n\n\nfloat stroke(float x, float s, float w) { \n    float d = SS(s, x + w / 2.) - SS(s, x - w / 2.);\n    return clamp(d, 0., 1.);\n}\n\nfloat fill(float x, float size) { \n    return 1. - SS(size, x);\n}\n\n\nfloat sdCircle(vec2 st) { \n    return length(st - 0.5) * 2.;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat cro(in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031,.11369,.13787));\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3(p3.x+p3.y, p3.x+p3.z, p3.y+p3.z)*p3.zyx);\n}\nfloat snoise3(vec3 p)\n{\n    const float K1 = 0.333333333;\n    const float K2 = 0.866666667;\n    \n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n    \n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n\tvec3 i1 = e * (1.0 - e.zxy);\n\tvec3 i2 = 1.0 - e.zxy * (1.0 - e);\n    \n    vec3 d1 = d0 - (i1 - K2);\n    vec3 d2 = d0 - (i2 - K1);\n    vec3 d3 = d0 - 0.5;\n    \n    vec4 h = max(0.3 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n    vec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));\n    \n    return dot(vec4(301.316), n);\n}\n\nfloat sdUnevenCapsule( in vec2 p, in vec2 pa, in vec2 pb, in float ra, in float rb )\n{\n    p  -= pa;\n    pb -= pa;\n    float h = dot(pb,pb);\n    vec2  q = vec2( dot(p,vec2(pb.y,-pb.x)), dot(p,pb) )/h;\n    \n    //-----------\n    \n    q.x = abs(q.x);\n    \n    float b = ra-rb;\n    vec2  c = vec2(sqrt(h-b*b),b);\n    \n    float k = cro(c,q);\n    float m = dot(c,q);\n    float n = dot(q,q);\n    \n         if( k < 0.0 ) return sqrt(h*(n            )) - ra;\n    else if( k > c.x ) return sqrt(h*(n+1.0-2.0*q.y)) - rb;\n                       return m                       - ra;\n}\n\nfloat light0(float intensity, float attenuation, float dist) {\n    return intensity / (dist * attenuation);\n}\n\nfloat light1(float intensity, float attenuation, float dist)\n{\n    return intensity / (1.0 + dist * attenuation);\n}\nfloat light2(float intensity, float attenuation, float dist)\n{\n    return intensity / (1.0 + dist * dist * attenuation);\n}\n\nfloat circle2(float d, float radius, float vignette) {\n    return smoothstep(radius * vignette, radius, d);\n}\n\nfloat circle3(float d, float radius) {\n    return .1 - smoothstep(radius, radius + 0.01, d);\n}\n\n\nvec3 draw(vec2 st, vec2 tileXY, vec2 count) {\n\n\n    int cardNumber = int(tileXY.x + (-tileXY.y + count.y - 1.) * count.x);\n    vec3 retCol = vec3(0.);\n    float color = 0.0;\n     float t = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(st.xy) + .507)) * 1.2;\n\tfloat si = sin(t);\n\tfloat co = cos(t);\n\n\tmat2 ma = mat2(co, si, -si, co);\n\n    switch(cardNumber) {\n    \n   \n    case 7: {\n        // https://www.shadertoy.com/view/3tBGRm\n        st = st * 2.0 - 1.0;\n;\n const vec3 color1 = vec3(0.611765, 0.262745, 0.996078)*2.;\n const vec3 color2 = vec3(0.298039, 0.760784, 0.913725)*2.;\n\n\n\nconst vec3 color3 = vec3(0.2, 0.2, 0.2);\nconst float innerRadius = 0.5;\nconst float noiseScale = 0.65;\n\n\n\n        float angle = atan(st.y, st.x);\n        float len = length(st);\n\n        float n0 = snoise3( vec3(st * noiseScale, iTime * 23.5) ) * 0.5 + 0.5;\n        float r = mix(innerRadius-0.25, innerRadius+0.25, n0);\n        float dist = abs(len - r+cos(iTime));\n        float baseLight = light1(1.0, 10.0, dist);\n\n        // high light\n        float a = iTime * -1.0;\n        vec2 pos = vec2(cos(a), sin(a)) * r+cos(iTime); // 边缘点\n            pos*=ma;\n        dist = distance(st, pos);\n        float highLight = light2(5.5, 5.0, dist);\n        highLight *= light1(1.0, 10.0, dist);\n\n        // outer\n        float decay = smoothstep(r * 1.05, r, len);\n        // inner\n        float hole = smoothstep(innerRadius*0.5, innerRadius, len);\n\n        float cl = cos(angle + iTime * 2.0) * 0.5 + 0.5;\n        vec3 col = mix(color1, color2, cl);\n        col = mix(color3, col, baseLight);\n        retCol  = (col  + highLight)  * hole * decay;\n        break;   \n    }\n\n  \n   \n    \n    } // switch end\n    return retCol;\n}\n#define tt iTime \nmat2 rot(float an) { float cc=cos(an),ss=sin(an); return mat2(cc,ss,-ss,cc); }\nvec3 F(vec3 p) {\n  vec4 q = vec4(p,1), jc = q; q.xz *= rot(tt/5.);\n  for (float i=0.;i<11.;i++){   \n#define C3(x) x = x>1. ? x=2.-x : (x<-1. ? -2.-x : x)\n#define D(x) x /= dot(x,x)  \n    C3(q.x); C3(q.y); C3(q.z); C3(q.w);  //4d Mandelbox (but not really)\n    D(q.xyz); D(q.yzw); D(q.zwx);\n    q.xyz*=.8; q.yzw*=.9; q.zwx*=1.3;\n    q.xy *= rot(-p.z*p.z); \n    q += jc;   \n  } return q.xyz;    \n}\n#define SM(x) max( -x*.2, min(0.,x))\nvec3 march( vec3 ro, vec3 rd) {\n  vec3 p = ro, color = vec3(0);\n  for (float i=0.; i<3.; i++) {\n    vec3 cx = F(ro+i*.6*rd*(1.- SM(4.) ));\n    cx = 1. - exp(-cx*cx);\n    color += cx*cx * exp(-i*i/1.8*(1.+SM(2.)));\n  } return color; \n}\n\nvoid mainImage0( out vec4 O, in vec2 U ) {\n  U = (2.*U - iResolution.xy) / iResolution.y * 2.; \n  vec3 rd = normalize( vec3(U, 2) ), ro = vec3(0,0, -4.-SM(.5) );\n  rd.xy  *= rot(tt/5.);     \n  O = vec4( pow(march( ro, rd ),vec3(.45)), 1);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//get coords and direction\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n    \tfloat t = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(uv.xy) + .07)) * 1.2;\n\tfloat si = sin(t);\n\tfloat co = cos(t);\n\tmat2 ma = mat2(co, si, -si, co);\n  \n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 dir=vec3(uv*zoom,0.001);\n\tfloat time=iTime*speed+.25;\n\n\n\n//aa by FabriceNeyret2 - makes a difference\n vec4 O =fragColor;\n vec2 U =fragCoord;\n    mainImage0(O,U);\n    if ( (length(O)) > .01 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { mainImage0(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n                             \n    \n\n}\n\nvec2 uv2 = (2.*fragCoord-iResolution.xy)/iResolution.y * 2.5;\n\tfloat aspectRatio = iResolution.x / iResolution.y;\n\n    vec3 rd = normalize( vec3(uv2, -1.2) );  \n    \n    vec3 ro = vec3(0); \n      vec2 uv3 = fragCoord / iResolution.xy;\n     \n      uv3.y-=0.35;\n    float coordAspectRatio = iResolution.y / iResolution.x;\n    \n    vec2 count = vec2(3, 3);\n    \n    float tileW = iResolution.x / count.x;\n    float tileH = iResolution.y / count.y;\n    float tileAspectRatio = tileH / tileW;\n    vec2 tileXY = floor(uv3 * count);\n   \n    // coordinates for each tile\n    vec2 st = vec2(\n        uv3.x * count.x - tileXY.x, \n        (uv3.y * count.y - tileXY.y - 0.5) * tileAspectRatio + .5\n    );\n       \n    vec2 gridBars = clamp(cos(uv3 * TAU * count) * 10. - 9.9, 0., 1.); // ---^---^---\n    float grid = max(gridBars.x, gridBars.y)*2.0;\n    \n    \n    vec3 color = draw(st, tileXY, count);\n    float delta = iTime / 1.5 ; \n        \n    rd.yz *= rot2(-delta/2. );\n    rd.xz *= rot2(delta*3.);\n    vec3 p = ro + rd;\n\n    float bass = 1.5 +  .5*max(0.,2.*sin(iTime*3.));\n    \n    vec2 nudge = vec2( aspectRatio*cos(iTime*1.5), sin(iTime*1.5));\n\n    focus = length(uv2 + nudge);\n    focus = 2./(1.+focus) * bass;\n\n    focus2 = length(uv2 - nudge);\n    focus2 = 4./(1.+focus2*focus2) / bass;\n\n    vec3 q = vec3( fbm3d(p), fbm3d(p.yzx), fbm3d(p.zxy) ) ;\n\n    float f = fbm3d(p + q);\n    \n    vec3 cc = q;\n    cc *= 20.*f;   \n\n    cc.r += 5.*focus; cc.g+= 3.5*focus; \n    cc.b += 7.*focus2; cc.r-= 3.5*focus2;    \n    cc /= 25.;\n\n\tvec3 from=vec3(1.,.5,0.5)+O.xyz;\n\t\n\t\n    \n\tmainVR(fragColor, fragCoord, from, dir);\t\n      uv *= 2.0 * ( cos(iTime * 2.0) -2.5); // scale\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;  // anim between 0.9 - 1.1 \n    fragColor*= vec4(happy_star(uv, anim) * vec3(0.35,0.2,0.55)*15.*O.xyz, 1.0);\n      fragColor+=vec4(cc*0.51+color,1.);\n}\n","name":"Image","description":"","type":"image"}]}