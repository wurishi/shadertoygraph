{"ver":"0.1","info":{"id":"M3fyzX","date":"1726492826","viewed":31,"name":"Glowing cup of soup in smokes","username":"AstronomicTelescope","description":"Decided to use one of the internet cubemaps rather than a built in one.\n\n","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sdf","channels"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Cup of soup in smokes\n\n// ----\n// Box mapping from https://www.shadertoy.com/view/MtsGWH\n\n// The MIT License\n// Copyright © 2015 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// How to do texture map a 3D object when it doesn't have \n// uv coordinates but can't afford full 3D solid texturing.\n\n// The idea is to perform three planar texture projections \n// and blend the results based on the alignment of the\n// normal vector to each one of the projection directions.\n\n// The technique was invented by Mitch Prater in the early\n// 90s, and has been called \"Box mapping\" or \"Rounded cube\n// mapping\" traditionally, although more recently it has\n// become popular in the realtime rendering community and\n// rebranded as \"triplanar\" mapping.\n\n// For a \"biplanar\" mapping example, visit:\n//\n// https://www.shadertoy.com/view/ws3Bzf\n\n\n\n// \"p\" point apply texture to\n// \"n\" normal at \"p\"\n// \"k\" controls the sharpness of the blending in the\n//     transitions areas.\n// \"s\" texture sampler\nvec4 boxmap( in sampler2D s, in vec3 p, in vec3 n, in float k )\n{\n    // project+fetch\n\tvec4 x = texture( s, p.yz );\n\tvec4 y = texture( s, p.zx );\n\tvec4 z = texture( s, p.xy );\n    \n    // and blend\n    vec3 m = pow( abs(n), vec3(k) );\n\treturn (x*m.x + y*m.y + z*m.z) / (m.x + m.y + m.z);\n}\n\n\n//===============================================================================================\n\nconst vec3  eye      = vec3 ( 0, 0, 5 );\nconst vec3  light    = vec3  ( 0.0, 7.0, 8.0 );\nconst int   maxSteps = 70;\nconst float eps      = 0.00001;\nconst float pi    = 3.1415926;\n\n// const vec3  cupClr  = vec3 ( 1, 0.3, 0 );\nconst vec3 soupClr = vec3(0.6, 0.2, 0);\n\nvec3 cupClr(vec3 p) {\n    return texture(iChannel0, normalize(p.xy)).rgb;\n}\n\nvec4 skyboxClr(vec3 dir) {\n    return texture(iChannel1, dir);\n}\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, s, 0),\n        vec3(-s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n\nfloat smin ( float a, float b, float k )\n{\n\tfloat res = exp ( -k*a ) + exp ( -k*b );\n\treturn -log ( res ) / k;\n}\n\nfloat sdCutSphere( vec3 p, float r, float h )\n{\n  // sampling independent computations (only depend on shape)\n  float w = sqrt(r*r-h*h);\n\n  // sampling dependant computations\n  vec2 q = vec2( length(p.xz), p.y );\n  float s = max( (h-r)*q.x*q.x+w*w*(h+r-2.0*q.y), h*q.x-w*q.y );\n  return (s<0.0) ? length(q)-r :\n         (q.x<w) ? h - q.y     :\n                   length(q-vec2(w,h));\n}\n\n// Функция не работает...\nfloat sdDiff(float srcdist, float subdist) {\n    // Представим себе летящий луч, пересекающий фигуры.\n    // -->->- src ->D>- sub\n    //   Норм, возвращаем src.\n    // -->->- src = sub\n    //   Не понятно :( :( :( Не понятно, беру с лекции.\n    // -->->- sub ->D>- dst\n    //   Возвращаем dst.\n    // Ограничение -- вся фигура sub лежит в src,\n    //   т.к. мы продвигаемся по лучу до окончания фигуры\n  \n   return max(-subdist, srcdist);\n}\n/*\nfloat sdf ( in vec3 p, in mat3 m )\n{\n   vec3 q = m * p;\n   \n   float base = sdDiff(sdCutSphere(q, 1.0, -1.0), sdCutSphere(q, 1.0, 0.3));\n   float inner = sdCutSphere(q, 0.9, -0.9);\n   float result = sdDiff(base, inner);\n   return sdCutSphere(q, 1.0, 0.3);\n}\n*/\n\n\nfloat sdCutHollowSphere( vec3 p, float r, float h, float t )\n{\n  // sampling independent computations (only depend on shape)\n  float w = sqrt(r*r-h*h);\n  \n  // sampling dependant computations\n  vec2 q = vec2( length(p.xz), p.y );\n  return ((h*q.x<w*q.y) ? length(q-vec2(w,h)) : \n                          abs(length(q)-r) ) - t;\n}\n\nfloat sdCappedTorus( vec3 p, vec2 sc, float ra, float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\nfloat sdfCup(in vec3 p, in mat3 m) {\n   //m = mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);\n   vec3 realpnt = m * p;\n   float base = sdCutHollowSphere(realpnt, 1.0, 0.4, 0.1);\n   vec3 cuppnt = realpnt;\n   \n   float result = base;\n\n   // Дополнительно вращаем экран, чтобы получить \n   //   разрвернутую фигуру.\n   mat3 rotViewHandle1 = rotateZ(0.5 * pi);\n   vec3 offsetViewHandle1 = vec3(0.0, -1.0, 0.0);\n   realpnt = rotViewHandle1 * m * p + offsetViewHandle1;\n   float handle1 = sdCappedTorus(realpnt, vec2(1.0, 0.0), 0.3, 0.05);\n   result = min(result, handle1);\n\n   // Дополнительно вращаем экран, чтобы получить \n   //   разрвернутую фигуру.\n   mat3 rotViewHandle2 = rotateZ(-0.5 * pi);\n   vec3 offsetViewHandle2 = vec3(0.0, -1.0, 0.0);\n   realpnt = rotViewHandle2 * m * p + offsetViewHandle2;\n   float handle2 = sdCappedTorus(realpnt, vec2(1.0, 0.0), 0.3, 0.05);\n   result = min(result, handle2);\n   \n   return result;\n}\n\nvec3 generateNormalForCup ( vec3 z, float d, in mat3 m)\n{\n    // mat3 m = mat3(1, 0, 0, 0, 1, 0, 0, 0, 1);\n    float e   = max (d * 0.5, eps );\n    vec3 clr = vec3(0.0, 0.0, 0.0);\n    float dx1 = sdfCup(z + vec3(e, 0, 0), m);\n    float dx2 = sdfCup(z - vec3(e, 0, 0), m);\n    float dy1 = sdfCup(z + vec3(0, e, 0), m);\n    float dy2 = sdfCup(z - vec3(0, e, 0), m);\n    float dz1 = sdfCup(z + vec3(0, 0, e), m);\n    float dz2 = sdfCup(z - vec3(0, 0, e), m);\n    \n    return normalize ( vec3 ( dx1 - dx2, dy1 - dy2, dz1 - dz2 ) );\n}\n\n\nvec4 cupClr(in vec3 p, in mat3 m) {\n   vec3 realpnt = m * p;\n   return boxmap(iChannel0, realpnt, generateNormalForCup(p, eps, m), 0.3 + 0.7 * (1.0 + sin(pi * iTime))); \n}\n\n\nfloat sdf ( in vec3 p, in mat3 m, out vec3 clr )\n{\n   float result = sdfCup(p, m);\n   clr = cupClr(p, m).rgb;\n   \n   mat3 rotViewSoup = rotateX(pi);\n   vec3 realpnt = rotViewSoup * m * p;\n   // Заполняется снова за 5 секунд.\n   float soup = sdCutSphere(realpnt, 1.0, max(0.0, sin(iTime * 2.0 * pi / 5.0)));\n   if (soup < result) {\n       clr = soupClr;\n   }\n   result = min(result, soup);\n   \n   //realpnt = m * p;\n   // (p, n) = d для случая, когда плоскость проходит через ноль,\n   //   оттуда же идет радиус-вектор p к точке.\n   // (p-p0, n) = d. Теперь плоскость проходит через p0, получаем\n   //   радиус-вектор к p после перехода в СО с началом в p0.\n   //   А дальше свели задачу к первой.\n   // С другой стороны (p-p0, n) = d = (p, n) - (p0, n).\n   //   Т.е. h в sdf равна -(p0, n).\n   //float skybox_up = abs(sdPlane(realpnt, vec3(0, 1, 0), -6.0));\n   //if (skybox_up < result + eps) {\n       // Можно считать, что здесь уже точка на плоскости.\n       //   Поскольку цвет применяется только когда итерации\n       //   raymarching завершились.\n       // Плоскость проходит через (0, 6, 0). Координаты\n       //   картинки будут (x, z). Другие плоскости обрубают\n       //   эту, координаты x и z в видимой части меняются от -6\n       //   до 6. Значит, нормированные координаты пикселя в картинке\n       //   будут (x + 6) / 12, (z + 6) / 12.\n   //    clr = skyboxClr((realpnt.x + 6.0) / 16.0, (realpnt.z + 6.0) / 16.0);\n   //}\n   // result = min(result, skybox_up);\n   /*\n   float skybox_down = abs(sdPlane(realpnt, vec3(0, 1, 0), 6.0));\n   if (skybox_down < result + eps) {\n       clr = skyboxClr((realpnt.x + 6.0) / 16.0, (realpnt.z + 6.0) / 16.0);\n   }\n   result = min(result, skybox_down);\n\n   float skybox_left = abs(sdPlane(realpnt, vec3(1, 0, 0), -6.0));\n   if (skybox_left < result + eps) {\n       clr = skyboxClr((realpnt.y + 8.0) / 16.0, (realpnt.z + 6.0) / 16.0);\n   }\n   result = min(result, skybox_left);\n\n   float skybox_right = abs(sdPlane(realpnt, vec3(1, 0, 0), 3.0));\n   if (skybox_right < result + eps) {\n       clr = skyboxClr((realpnt.y + 8.0) / 16.0, (realpnt.z + 6.0) / 16.0);\n   }\n   result = min(result, skybox_left);\n\n   float skybox_front = abs(sdPlane(realpnt, vec3(0, 0, 1), 6.0));\n   if (skybox_front < result + eps) {\n       clr = skyboxClr((realpnt.x + 8.0) / 16.0, (realpnt.y + 6.0) / 16.0);\n   }\n   result = min(result, skybox_front);\n\n   float skybox_back = abs(sdPlane(realpnt, vec3(0, 0, 1), -8.0));\n   if (skybox_back < result + eps) {\n       clr = skyboxClr((realpnt.x + 8.0) / 16.0, (realpnt.y + 8.0) / 16.0);\n   }\n   result = min(result, skybox_back);\n   */\n\n\n   return result;\n}\n\n\nvec3 trace ( in vec3 from, in vec3 dir, out bool hit, in mat3 m, out vec3 clr )\n{\n\tvec3\tp         = from;\n\tfloat\ttotalDist = 0.0;\n\t\n\thit = false;\n\t\n\tfor ( int steps = 0; steps < maxSteps; steps++ )\n\t{\n\t\tfloat\tdist = sdf ( p, m, clr );\n        \n\t\tif ( dist < eps )\n\t\t{\n\t\t\thit = true;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\ttotalDist += dist;\n\t\t\n\t\tif ( totalDist > 100.0 )\n\t\t\tbreak;\n\t\t\t\n\t\tp += dist * dir;\n\t}\n\t\n\treturn p;\n}\n\nvec3 generateNormal ( vec3 z, float d, in mat3 m )\n{\n    float e   = max (d * 0.5, eps );\n    vec3 clr = vec3(0.0, 0.0, 0.0);\n    float dx1 = sdf(z + vec3(e, 0, 0), m, clr);\n    float dx2 = sdf(z - vec3(e, 0, 0), m, clr);\n    float dy1 = sdf(z + vec3(0, e, 0), m, clr);\n    float dy2 = sdf(z - vec3(0, e, 0), m, clr);\n    float dz1 = sdf(z + vec3(0, 0, e), m, clr);\n    float dz2 = sdf(z - vec3(0, 0, e), m, clr);\n    \n    return normalize ( vec3 ( dx1 - dx2, dy1 - dy2, dz1 - dz2 ) );\n}\n\nconst float roughness = 0.2;\nconst vec3  r0   = vec3 ( 1.0, 0.92, 0.23 );\nconst float gamma = 2.2;\nconst float FDiel = 0.04;\t\t// Fresnel for dielectrics\n\nvec3 fresnel ( in vec3 f0, in float product )\n{\n\tproduct = clamp ( product, 0.0, 1.0 );\t\t// saturate\n\t\n\treturn mix ( f0, vec3 (1.0), pow(1.0 - product, 5.0) );\n}\n\nfloat D_blinn(in float roughness, in float NdH)\n{\n    float m = roughness * roughness;\n    float m2 = m * m;\n    float n = 2.0 / m2 - 2.0;\n    return (n + 2.0) / (2.0 * pi) * pow(NdH, n);\n}\n\nfloat D_beckmann ( in float roughness, in float NdH )\n{\n\tfloat m    = roughness * roughness;\n\tfloat m2   = m * m;\n\tfloat NdH2 = NdH * NdH;\n\t\n\treturn exp( (NdH2 - 1.0) / (m2 * NdH2) ) / (pi * m2 * NdH2 * NdH2);\n}\n\nfloat D_GGX ( in float roughness, in float NdH )\n{\n\tfloat m  = roughness * roughness;\n\tfloat m2 = m * m;\n\tfloat NdH2 = NdH * NdH;\n\tfloat d  = (m2 - 1.0) * NdH2 + 1.0;\n\t\n\treturn m2 / (pi * d * d);\n}\n\nfloat G_schlick ( in float roughness, in float nv, in float nl )\n{\n    float k = roughness * roughness * 0.5;\n    float V = nv * (1.0 - k) + k;\n    float L = nl * (1.0 - k) + k;\n\t\n    return 0.25 / (V * L);\n}\n\nfloat G_neumann ( in float nl, in float nv )\n{\n\treturn nl * nv / max ( nl, nv );\n}\n\nfloat G_klemen ( in float nl, in float nv, in float vh )\n{\n\treturn nl * nv / (vh * vh );\n}\n\nfloat G_default ( in float nl, in float nh, in float nv, in float vh )\n{\n\treturn min ( 1.0, min ( 2.0*nh*nv/vh, 2.0*nh*nl/vh ) );\n}\n\nvec4 cookTorrance ( in vec3 p, in vec3 n, in vec3 l, in vec3 v, in vec3 clr )\n{\n    vec3  h    = normalize ( l + v );\n\tfloat nh   = dot (n, h);\n\tfloat nv   = dot (n, v);\n\tfloat nl   = dot (n, l);\n\tfloat vh   = dot (v, h);\n    float metallness = 1.0;\n    vec3  base  = pow ( clr, vec3 ( gamma ) );\n    vec3  F0    = mix ( vec3(FDiel), clr, metallness );\n\t\n\t\t\t// compute Beckman\n   \tfloat d = D_beckmann ( roughness, nh );\n\n            // compute Fresnel\n    vec3 f = fresnel ( F0, nv );\n\t\n            // default G\n    float g = G_default ( nl, nh, nv, vh );\n\t\n\t\t\t// resulting color\n\tvec3  ct   = f*(0.25 * d * g / nv);\n\tvec3  diff = max(nl, 0.0) * ( vec3 ( 1.0 ) - f ) / pi;\n\tfloat ks   = 0.5;\n\n\treturn vec4 ( pow ( diff * base + ks * ct, vec3 ( 1.0 / gamma ) ), 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\n\n    // Повернем кружку дном вниз. Просто добавим к mouse.x так,\n    //   чтобы картинка повернулась по y на pi.\n    //   Поведение прокрутки не изменится, почти все значения\n    //   синуса все так же будут пробегаться (все бы, почти все,\n    //   пробегались, если бы была формула pi * mouse.y).\n    mouse.y += pi / 6.0; // Повернем кружку дном вниз :)\n\n\n    mat3 m     = rotateX ( 6.0*mouse.y ) * rotateY ( 6.0*mouse.x);\n    \n    \n    vec2 scale = 9.0 * iResolution.xy / max ( iResolution.x, iResolution.y ) ;\n    vec2 uv    = scale * ( fragCoord/iResolution.xy - vec2 ( 0.5 ) );\n\tvec3 dir   = normalize ( vec3 ( uv, 0 ) - eye );\n    vec4 color = vec4 ( 0, 0, 0, 1 );\n    \n    vec3 clr = vec3(0, 0, 0);\n    bool hit;\n\tvec3 p     = trace ( eye, dir, hit, m, clr );\n\n\n\tif ( hit )\n\t{\n\t\tvec3  l  = normalize        ( light - p );\n        vec3  v  = normalize        ( eye - p );\n\t\tvec3  n  = generateNormal   ( p, 0.001, m );\n\t\tfloat nl = max ( 0.0, dot ( n, l ) );\n        vec3  h  = normalize ( l + v );\n        float hn = max ( 0.0, dot ( h, n ) );\n        float sp = pow ( hn, 150.0 );\n\t\t\n        color = cookTorrance ( p, n, l, v, clr );\n       \n        // Output to screen\n        fragColor = color * 3.0;\n\t} else {\n        // https://inspirnathan.com/posts/63-shadertoy-tutorial-part-16\n        fragColor = skyboxClr(m * dir);\n    }\n}\n\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"// https://www.shadertoy.com/view/XdlGzX\n\n// by Nikos Papadopoulos, 4rknova / 2013\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define USE_MOUSE\n#define ANIMATE\n\n#define PI   3.14159265359\n#define RADIAN  180. / PI\n#define CAMERA_FOV 60.4 * RADIAN\n\nfloat hash(in vec3 p)\n{\n    return fract(sin(dot(p,vec3(127.1,311.7, 321.4)))*43758.5453123);\n}\n\nfloat noise(in vec3 p)\n{\n#ifdef ANIMATE\n p.z += iTime * .75;\n#endif\n \n    vec3 i = floor(p);\n vec3 f = fract(p); \n f *= f * (3.-2.*f);\n\n    vec2 c = vec2(0,1);\n\n    return mix(\n  mix(mix(hash(i + c.xxx), hash(i + c.yxx),f.x),\n   mix(hash(i + c.xyx), hash(i + c.yyx),f.x),\n   f.y),\n  mix(mix(hash(i + c.xxy), hash(i + c.yxy),f.x),\n   mix(hash(i + c.xyy), hash(i + c.yyy),f.x),\n   f.y),\n  f.z);\n}\n\nfloat fbm(in vec3 p)\n{\n float f = 0.;\n f += .50000 * noise(1. * p);\n f += .25000 * noise(2. * p);\n f += .12500 * noise(4. * p);\n f += .06250 * noise(8. * p);\n return f;\n}\n\nstruct Camera { vec3 p, t, u; };\nstruct Ray  { vec3 o, d; };\n\nvoid generate_ray(Camera c, out Ray r, in vec2 fragCoord)\n{\n float ratio = iResolution.x / iResolution.y;\n\n vec2  uv = (2.0 * fragCoord.xy / iResolution.xy - 1.)\n    * vec2(ratio, 1.0);\n \n r.o = c.p;\n r.d = normalize(vec3(uv.x, uv.y, 1.0 / tan(CAMERA_FOV * .5)));\n \n vec3 cd = c.t - c.p;\n\n vec3 rx,ry,rz;\n rz = normalize(cd);\n rx = normalize(cross(rz, c.u));\n ry = normalize(cross(rx, rz));\n \n mat3 tmat = mat3(rx.x, rx.y, rx.z,\n        ry.x, ry.y, ry.z,\n      rz.x, rz.y, rz.z);\n\n r.d = normalize(tmat * r.d);\n}\n\nvec3 cubemap(vec3 d, vec3 c1, vec3 c2)\n{\n return fbm(d) * mix(c1, c2, d * .5 + .5);\n}\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n Camera c;\n c.p = vec3(0., 0., 75.);\n c.u = vec3(0., 1., 0.);\n\n#ifdef USE_MOUSE\n c.t = vec3(iMouse.x / iResolution.x * 180. -90., \n      iMouse.y / iResolution.y * 180. -90., 0.);\n#else\n c.t = vec3( 26. * sin(mod(iTime * .64, 2. * PI)),\n       28. * cos(mod(iTime * .43, 2. * PI)),\n      -25. * cos(mod(iTime * .20, 2. * PI)));\n#endif  \n \n    Ray r;\n generate_ray(c, r, fragCoord);\n    vec3 col = cubemap(r.d,vec3(.5,.9,.1), vec3(.1,.1,.9));\n fragColor = vec4(col, 1);\n}","name":"Cube A","description":"","type":"cubemap"}]}