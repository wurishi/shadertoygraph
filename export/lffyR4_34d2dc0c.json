{"ver":"0.1","info":{"id":"lffyR4","date":"1720866116","viewed":100,"name":"Spherical Inversion sd","username":"timestamp","description":"Keyboard: z x c\nOptimized signed distance for spherical inversion without fudge factor. Adjusts sd to be optimal, but can't be exact without assumptions about map().","likes":16,"published":1,"flags":16,"usePreview":0,"tags":["sphere","inversion","spherical","sd","signeddistance"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// Optimized signed distance for spherical inversion without fudge factor.\n//\n// Adjusts sd to be optimal, but can't be exact without assumptions about map().\n//\n// (c) timestamp @ shadertoy.com 2024-07\n//\n\n//\n//          VIEWER DISCRETION IS ADVISED\n//\n//        Some spheres where turned inside \n//        out during this coding exercise.\n//\n\n//\n//  Keyboard:\n//\n//    z    Toggle cubes vs spheres\n//    x    Toggle 2D vs 3D\n//    c    Show march step count in 3d\n//\n//  Mouse: sample point in 2D.\n//\n\nvec3 fold(vec3 p, float r, out vec2 v)\n{\n    v = vec2(dot(p, p), r * r);\n    return v.y / v.x * p;    \n}\n\nfloat foldEnd(float sd, vec2 v)\n{   \n    return v.x / (v.y + sqrt(v.x) * abs(sd)) * sd;\n}\n\n//\n//\n// Demo\n//\n//\n\n\n#define R                 iResolution.xy\n#define Key_Z             0x5a\n#define Key_X             0x58\n#define Key_C             0x43\n\n#define keyToggle(ascii)  (texelFetch(iChannel3,ivec2(ascii,2),0).x > 0.)\n#define keyDown(ascii)    (texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\nbool doSpheres;\n\nfloat map0(vec3 p)\n{\n    p.xy = mod(p.xy + .7, 1.4) - .7;\n    vec3 b = abs(p) - .3;\n    return doSpheres\n        ? length(p) - 0.4\n        : length(max(b,0.0)) + min(max(b.x,max(b.y,b.z)),0.0);    \n}\n\nfloat map1(vec3 p)\n{\n    vec2 v;\n    vec3 q = fold(p, 1., v);\n    float sd = map0(q);\n    return foldEnd(sd, v);\n}\n\nfloat map(vec3 p)\n{\n    return max(map1(p * .5) / .5, abs(p.z) - 1.);\n}\n\nvec4 show2D(vec2 I)\n{    \n    vec2 p = (I+I-R)/R.y;    \n    float h = 3.0 / iResolution.y;\n    // derived from iq\n    vec2 m = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n    float d = map(vec3(p, 0));        \n    vec3 col = 0.5 + 0.5 * sign(d) * (vec3(0.9, 0.6, 0.3) * 2. - 1.);    \n    col *= 1.0 - exp(-20.0*abs(d));\n    col *= 0.8 + 0.2*cos(140.0*d);\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,h,abs(d)) );\n    if(iMouse.z < 0.001) m = vec2(cos(iTime * 0.4811), sin(iTime * 0.3211));\n    d = map(vec3(m,0));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, h, abs(length(p-m)-abs(d))));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, h, length(p-m)-h));\n    return vec4(col, 1);\n}\n\nvec3 getMapNormal(vec3 p)\n{\n    // iq\n    vec2 e = vec2(1.0, -1.0) * 0.57735027 * .002;\n    vec4 s = vec4(map(p + e.xyy)\n        , map(p + e.yyx)\n        , map(p + e.yxy)\n        , map(p + e.xxx));\n    return normalize((s.xzy + s.www) - (s.yxx + s.zyz));\n}\n\nvec2 rot(vec2 p, float a) { return vec2(p.x * cos(a) - p.y * sin(a), p.y * cos(a) + p.x * sin(a)); }\n\nvec4 show3D(vec2 I)\n{\n    vec2 sc = (I+I-R)/R.y;    \n    vec3 ro = vec3(-1.8,-0.6,1.7);\n    ro.xy = rot(ro.xy, iTime * 0.4);\n    vec3 rd = -normalize(ro);\n    vec3 right = normalize(cross(rd, vec3(0, 0, 1)));\n    vec3 up = normalize(cross(right, rd));\n    rd = normalize(rd * 3. + right * sc.x + up * sc.y);\n\n    int i, Iters = 100;\n    float t = 0.;\n    vec3 p, col;\n    \n    for(i=min(0, iFrame); i<Iters; i++)\n    {\n        p = ro + rd * t;\n        float d = map(p);        \n        if(d<.00001) break;\n        t += d;\n    }\n\n    bool stp = keyToggle(Key_C);\n    if(i < Iters)\n    {    \n        vec3 n = getMapNormal(p); \n        vec3 dif = vec3(0.945,0.820,0.475);\n        vec3 lcol = vec3(1.);\n        vec3 ld = normalize(vec3(1,0.5,2));    \n        col = dif * lcol * max(0.005, dot(ld, n));\n        if(stp) col.z = float(i) / float(Iters);\n    }\n    else if(stp && p.z > -2.)\n        col.xz = vec2(1,0);\n    \n    return vec4(pow(col, vec3(1./2.2)), 1);\n}\n\nvoid mainImage( out vec4 O, in vec2 I)\n{    \n    doSpheres = keyToggle(Key_Z);\n    O = keyToggle(Key_X) ? show3D(I) : show2D(I);    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n\n\n//\n// Derivation\n//\n// This code is not used by the demo.\n//\n\n\n// Consider the spherical inversion projection\n// which maps march space P to map space Q\n//\n//   * f is valid except for p==0\n//   * f(p) == q   <=>   f(q) == p\n//   * f(n r) == n r  for |n| == 1\n//   * p and q and (0,0,0) are on a line\n//\nvec3 f(vec3 p, float r)\n{\n    vec3 q = r * r / dot(p, p) * p;\n    return q;\n}\n\n// In a ray-marching step, we need to back-project the\n// signed distance we measured in Q space to P space,\n// so we can make an optimal update of t.\n//\n\nvoid _step(vec3 ro, vec3 rd, inout float t)\n{\n    const float r = 2.0;  // inversion sphere radius\n    vec3 p = ro + t * rd;\n    vec3 q = f(p, r);     // fold\n    float sdq, sdp;\n    // sdq = map(q);      // signed distance in Q space\n    // sdp = f_end(sdq);  // project sdq to sdp in P space\n    t += sdp;\n}\n\n//\n// The key is to realize that..\n//\n// ====================================================================\n// In Q-space, the point q and the signed distance sdq\n// outline a sphere, q + n * abs(sdq), and spherical\n// inversion maps a sphere onto a sphere!\n// ====================================================================\n//\n// More precisely, there are 3 cases:\n// * A sphere that does not include the origin maps to a sphere.\n// * A sphere passing through the origin maps to a plane.\n// * A sphere that contains the origin maps to a sphere that's inside-out.\n//\n// So, project the Q-space sphere (q + n sdq) to\n// its P-space sphere and then find the closest distance\n// of that sphere to the original P-space point p:\n//\nfloat f_End_01(vec3 p, vec3 q, float sdq, float r)\n{\n\n    float iq = length(q);            // distance of q from origin. Safe to assume != 0.\n    float ip = length(p);            // distance of p from origin. Safe to assume != 0.\n    float qlo = iq - abs(sdq);       // Q-space sphere inner edge. Can be 0 or negative.\n    float qhi = iq + abs(sdq);       // Q-space sphere outer edge. Always positive.\n    float plo = r * r / qhi;         // P-space sphere inner edge.\n    float phi = r * r / qlo;         // P-space sphere outer edge. Possibly flipped or inf.\n    float pc = (phi + plo) * 0.5;    // P-space sphere centre.\n    float pr = (phi - plo) * 0.5;    // P-space sphere radius.\n    \n    // For all 3 cases (origin outside, origin inside, origin on edge), \n    // plo is the closest point to p of the P-space sphere \n    // and 0 < plo <= p. So..\n    \n    float sdp = ip - plo;\n    \n    // Finally, fix up the sign, which will always be the same as in Q-space,\n    // including when sdq == 0.\n    \n    sdp *= sign(sdq);\n    \n    return sdp;\n}\n\n//\n// This simplifies beautifully, so it must be true..\n//\nfloat f_End_02(float pdotp, float sdq, float r)\n{  \n    return pdotp / (r * r + sqrt(pdotp) * abs(sdq)) * sdq;\n}\n\n// \n// Alternatively, if instead of dot(p,p) you have dot(q,q) handy, you can use\n//\nfloat f_End_03(float qdotq, float sdq, float r)\n{  \n    return r * r / (qdotq + sqrt(qdotq) * abs(sdq)) * sdq;\n}\n\n","name":"Common","description":"","type":"common"}]}