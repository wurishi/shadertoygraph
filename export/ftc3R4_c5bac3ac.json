{"ver":"0.1","info":{"id":"ftc3R4","date":"1635873499","viewed":163,"name":"moon walk","username":"rockhard","description":"a walk through scene.some important detail.such as hill/rock etc.. is still missing. Shadow of a walking human.. \nplay the scene at fullscreen with some piano music.very peaceful.:)","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["moonland"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat3 rotXY(float rX, float rY){\n float cx = cos(rX),sx = sin(rX),cy = cos(rY),sy=sin(rY);\n return mat3(-sy, 0, -cy, -sx * cy, cx, sx * sy,cx * cy, sx, -cx * sy);\n}\nvec3 getdir(vec2 p,mat3 m){\n  return normalize(vec3(p.x * m[0].x + p.y * m[1].x - m[2].x, \n       p.x * m[0].y + p.y * m[1].y - m[2].y, \n       p.x * m[0].z + p.y * m[1].z - m[2].z));\n}\n#define DELTA 0.025\n\nfloat sam(vec2 uv){ return texture(iChannel0,uv).x; }\nfloat fbm(vec2 p){\n    return 0.5*sam(p)+ 0.35*sam(p*0.125)+ 0.125*sam(p*0.35);}\n\nfloat hash(float n) { return fract(sin(n)*43758.5453123); }\nfloat noise2(vec2 x){ vec2 p = floor(x),f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*17.0;\n    return mix(mix( hash(n), hash(n+1.0),f.x),\n               mix( hash(n+ 17.0), hash(n+ 18.0),f.x),f.y);\n}\n//inversed noise and texture together for heightmap\nfloat map(vec3 p){ \n   float ns=fbm(p.xz*0.25)*0.15; \n   float n=noise2(p.xz*0.3)*2.0-1.0;    \n   ns+=smoothstep(-0.65,0.6,n-0.28*ns); \n   p.y+=ns*0.3;\n   return p.y;\n}\n//large delta to avoid pixel flicking\nvec3 normal(vec3 p){\n    vec2 e=vec2(DELTA,-DELTA);\n\treturn normalize(vec3(e.xyy*map(p+e.xyy) \n         +e.yyx*map(p+e.yyx) +e.yxy*map(p+e.yxy) +e.x*map(p+e.x)));\n}\n#define NUM_STEPS 45\n#define FAR 50.0\nfloat trace(vec3 ori,vec3 dir, inout vec3 p) {  \n    float t = 0.0;    \n    float tot= 0.0;\n    for(int i = 0; i < NUM_STEPS; i++) {                        \n    \tt = map(p);\n\t\tif(t < 0.02||t>FAR) break;\n        tot+=t;\n        p = ori + dir * tot;   \n    }\n    return tot;\n}\n\nfloat n11(float p) { return fract(sin(p*154.101)*313.019);}\nfloat n21(vec2 p) { return sin(dot(p, vec2(7., 157.)));}\n\nfloat star(vec3 p) {\n\tvec2 gv = fract(p.xy) - 0.5;\n\tvec2 id = floor(p.xy);\n\tgv.x += sin(n21(id)*354.23) * 0.3;\n\tgv.y += sin(n11(n21(id))*914.19) * 0.3;\n\tfloat r = n11(n21(id));\n\treturn 0.1*n11(r)*abs(sin(p.z+r*133.12))*0.2/length(gv)*0.1;\n}\n\nfloat stars(vec2 p) {\n\tfloat z = 1.0, m = 0.0,t=iTime*0.25; \n\tfor(int i=0; i<5 ;i++){ z *= 2.0;m += star(vec3(p*z,1.0+t*2.0));}\n\treturn m; }\n\nfloat saturate(float x){ return clamp(x,0.0,1.0);}\n//simplifyed sphere raytest \nfloat raysphere(vec3 dir){  \n     float b = -10.0*dir.z;  \n     float discr = b * b - 99.0;\n     if (discr < 0.0) return -1.0;\n     return -b - sqrt(discr);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = fragCoord/iResolution.xy-0.5;\n    uv.x*=iResolution.x/iResolution.y;\n    float time= iTime*0.2;\n    \n    mat3 camrot=rotXY(-0.15,0.12);\n    vec3 ro=camrot[2]*5.0;\n    \n    ro.y+=1.25;\n    vec3 rd=getdir(uv,camrot);\n    ro.x-=iTime*0.25;      \n   \n    vec3 light=normalize(vec3(0.15,0.125,0.15));\n    vec3 sky=vec3(0.05,0.09,0.1)*\n          clamp(-(rd.y+0.85)/(ro.y-3.0),0.25,1.0);\n    \n    sky+=stars(uv);\n        \n    float d = length(uv-vec2(0.0,0.125));\n   \n    float land=smoothstep(0.25,0.75,fbm(2.2*uv+0.125));\n    sky += exp(-5.0*d*d)*vec3(0.25,0.28,0.26);\n    vec3 moon =vec3(0.2,0.4,0.6)+ vec3(0.9,0.6,0.3)*land;\n    sky = mix(moon,sky, smoothstep(0.245,0.25,d) );\n               \n    vec3 raydir=normalize(vec3(uv.x,uv.y-0.125,2.465));\n    float dist=raysphere(raydir);\n   //earth \n    if(dist>0.0){\n      vec3 hit=(raydir*dist); \n      hit.z-=10.0;\n      \n      float d2n=dot(hit,light)+0.65;\n      float edge= 1.0-dot(hit,reflect(light,hit));\n      edge=pow(edge,5.5);\n      sky*=d2n;\n      sky= mix(sky+land*(0.5-d2n)*vec3(1.5,1.2,0.65),vec3(0.72,0.825,0.9),edge*0.1);\n    }\n    \n    vec3 col =vec3(0.0);\n    vec3 pos=ro;  \n    //raystep matching is the slowest part...\n    float t= trace(ro,rd,pos);      \n    \n    if(t<FAR){      \n       vec3 n =normal(pos);\n       light.xz=-light.xz;\n       float d2l=max(dot(n,light),0.0);\n       float fre = clamp(1.0+dot(light,n),0.0,1.0); // Fresnel reflection.\n       float Schlick = pow(1.0- max(dot(rd, normalize(rd + light)),0.0),5.0);\n       fre *= mix(0.2, 1.0, Schlick);//Hard clay.\n       col+=d2l*vec3(1.25,1.22,1.2)+fre*vec3(0.65,0.725,0.8);       \n     }\n     else col=sky;\n  //blur the landscape edge to sky\n   col=mix(col,sky,smoothstep(0.8,1.0,t/FAR));\n   float uy=fragCoord.y/iResolution.y-0.5;\n   float vig = (1.1-0.8*uy*uy)*(1.0-0.6*uv.x*uv.x);\n   col*=col;\n   fragColor = vec4(col*vig,1.0);\n}","name":"Image","description":"","type":"image"}]}