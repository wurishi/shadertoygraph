{"ver":"0.1","info":{"id":"X3fXD7","date":"1709658246","viewed":93,"name":"Raytracing with soft shadows","username":"Voakie","description":"Three spheres drawn with a simple whitted-style raytracer. No transmission or reflection. For ease of implementation, the phong illumination model ist used with 2 lights and 81 shadow rays are shot per intersection.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","phong","shadows"],"hasliked":0,"parentid":"l3sXzH","parentname":"Kugeln ;)"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SHADOW_RAYS 81.0\n// Shadow rays are laid out on a grid defined by the normal of the intersection point with bounds being floor(sqrt(SHADOW_RAYS)/2)\n// Use 1.0 for no smooth shadows\n\n\nstruct Material {\n    vec3 k_a;\n    vec3 k_d;\n    vec3 k_s;\n    int texture; // 0 = none; 1 = checkerboard\n    float n;\n};\n\n\nstruct Sphere {\n    int id;\n    vec3 center;\n    float radius;\n    Material mat;\n};\n\nstruct Light {\n    vec3 center;\n    float intensity;\n    vec3 color;\n};\n\nstruct Isect {\n    float t;\n    vec3 pos;\n    vec3 normal;\n    Material mat;\n};\n\nconst Material m0 = Material(vec3(-0.1), vec3(0.1), vec3(0.2), 0, 10.0);\nconst Material m1 = Material(vec3(0.5, 0.5, 0.0), vec3(0.2, 0.2, 0.0), vec3(0.2, 0.2, 0.0), 0, 1.0);\nconst Material m2 = Material(vec3(0.05, 0.05, 0.9)/2.0, vec3(0.0, 0.0, 0.2), vec3(0.1), 0, 2.0);\nconst Material mLight = Material(vec3(1.0), vec3(0.0), vec3(0.0), 0, 1.0);\nconst Material mFloor = Material(vec3(0.25), vec3(1.2), vec3(0.0), 1, 1.0);\n\nconst Sphere s1 = Sphere(0, vec3(0.0, 0.0, 10.0), 5.0, m0);\nconst Sphere s2 = Sphere(1, vec3(15.0, -3.0, 25.0), 10.0, m1);\nconst Sphere s3 = Sphere(2, vec3(-10.0, -2.0, 6.0), 4.0, m2);\nconst Sphere s4 = Sphere(3, vec3(0.0, 27.0, 50.0), 1.0, mLight);\nconst Sphere[] spheres = Sphere[](s1, s2, s3, s4);\n\nconst Isect empty_isect = Isect(0.0, vec3(0.0), vec3(0.0), m0);\n\nconst mat4 V = mat4(vec4(1.0, 0.0, 0.0, 0.0),\n                    vec4(0.0, cos(radians(-20.0)), -sin(radians(-20.0)), 0.0),\n                    vec4(0.0, sin(radians(-20.0)), cos(radians(-20.0)), 0.0),\n                    vec4(0.0, 0.0, 0.0, 1.0));\n                    \nconst vec3 ambientBackground = vec3(217.0, 247.0, 250.0) / 255.0; // Lazy google color picker\n\nbool intersectSphere(in vec3 origin, in vec3 direction, in Sphere sphere, out Isect isect) {\n    isect = empty_isect;\n    \n    vec3 sphereCenter = sphere.center + (sphere.id == 0 ? vec3(1.0) *  sin(iTime) + vec3(0.0, 2.0, 0.0) * cos(iTime) : vec3(0.0));\n    sphereCenter = sphere.id == 3 ? sphereCenter + vec3(0.0, 20.0, 0.0) *  sin(iTime*1.5) : sphereCenter;\n    \n    float a = dot(direction, direction);\n    float b = dot(2.0 * direction, (origin - sphereCenter));\n    float c = dot(origin - sphereCenter, origin - sphereCenter) - pow(sphere.radius, 2.0);\n    float disc = pow(b, 2.0) - 4.0 * a * c;\n\n    if (disc < 0.0) return false;\n    else {\n        float t1 = (-b + sqrt(disc)) / 2.0 * a;\n        float t2 = (-b - sqrt(disc)) / 2.0 * a;\n        float _t = min(t1, t2);\n\n        if (_t < 0.0 && max(t1, t2) >= 0.0) _t = max(t1, t2);\n        else if (_t < 0.0) return false;\n\n        isect.t = _t;\n        isect.pos = origin + _t * direction;\n        isect.normal = normalize(isect.pos - sphereCenter);\n        isect.mat = sphere.mat;\n\n        return true;\n    }\n}\n\nbool intersectFloor(in vec3 origin, in vec3 direction, out Isect isect) {\n    if (direction.y == 0.0) return false;\n    float isectFloor = (-5.0 - origin.y) / direction.y;\n    if (isectFloor > 0.0 && isectFloor < 999.0) {\n        isect = Isect(isectFloor, origin + isectFloor * direction, vec3(0.0, 1.0, 0.0), mFloor);\n        return true;\n    } else return false;\n}\n\nvec3 checkerboard(vec2 pos) {\n    pos /= 5.0;\n    float base = mod(floor(pos.x), 2.0) == 0.0 ? 0.0 : 1.0;\n    base -= mod(floor(pos.y), 2.0) == 0.0 ? 0.0 : 1.0;\n    return vec3(abs(base));\n}\n\nvec4 phong(vec3 origin, vec3 direction, Isect isect) {\n    Light l1 = Light(vec3(5.0 * sin(iTime+3.0), 10.0, 0.5), 150.0, vec3(1.0, 1.0, 1.0));\n    Light l2 = Light(vec3(0.0, 25.0 + sin(iTime*1.5) * 20.0, 50.0), 1000.0, vec3(1.0, 1.0, 1.0));\n    Light[] lights = Light[](l1, l2);\n    \n\n    vec3 color = vec3(0.0);\n    for (int i = 0; i < lights.length(); i++) {\n        float shadowCoeff = 1.0;\n        vec3 L = normalize(lights[i].center - isect.pos);\n        float distance = length(lights[i].center - isect.pos);\n        vec3 RL = normalize(reflect(L, isect.normal));\n        \n        vec3 e = normalize(vec3(0.0, -isect.normal.z, isect.normal.y));\n        vec3 f = cross(isect.normal, e);\n        \n        // Ambient base light is at index 1, dont want hard shadows for it\n        if (i != 2) {\n            int shadows = int(SHADOW_RAYS);\n            int bounds = int(floor(sqrt(SHADOW_RAYS) / 2.0));\n            float offsetFactor = 1.0 + exp(-(distance/SHADOW_RAYS) + 2.0); // Use exponential falloff for offset, making shadows of distant lights softer\n            for (int xOff = -bounds; xOff <= bounds; xOff++) {\n                for (int yOff = -bounds; yOff <= bounds; yOff++) {\n                        for (int s = 0; s < spheres.length(); s++) {\n                        vec3 offset = e * float(xOff)/offsetFactor + f * float(yOff)/offsetFactor;\n                        vec3 shadowOrigin = isect.pos + offset + 0.01 * L;\n                        Isect _isect;\n                        if (intersectSphere(shadowOrigin, L, spheres[s], _isect)) {\n                            shadows--;\n                        }\n                    }\n                }\n            }\n            shadowCoeff = float(shadows) / SHADOW_RAYS;\n        }\n        \n        vec3 tex = isect.mat.texture == 1 ? vec3(checkerboard(isect.pos.xz)) : vec3(1.0);\n        vec3 ambient = isect.mat.k_a * tex;\n        vec3 diffuse = isect.mat.k_d * dot(L, isect.normal) * tex;\n        vec3 specular = isect.mat.k_s * pow(max(0.0, dot(direction, RL)), isect.mat.n) * tex;\n        color += ambient/float(lights.length()) + (shadowCoeff * lights[i].intensity/pow(distance, 2.0) * lights[i].color * (diffuse + specular));\n    }\n    return vec4(color, 1.0);\n}\n\nvec4 raytrace(in vec3 origin, in vec3 direction, in vec2 fragCoords) {\n    bool foundIsect = false;\n    float nearest = 999.0;\n    Isect isect;\n    vec4 color = vec4(0.0, 0.0, 0.0, 1.0);\n\n    for (int i = 0; i < spheres.length(); i++) {\n        Isect _isect;\n        if (intersectSphere(origin, direction, spheres[i], _isect)) {\n            if (_isect.t >= 0.0) {\n                foundIsect = true;\n                if (_isect.t < nearest) {\n                    nearest = _isect.t;\n                    isect = _isect;\n                }\n            }\n        }\n    }\n    \n    Isect _isect;\n    if (intersectFloor(origin, direction, _isect)) {\n        if (_isect.t < nearest) {\n            foundIsect = true;\n            nearest = _isect.t;\n            isect = _isect;\n        }\n    }\n   \n    \n    \n    if (foundIsect) {\n        vec4 p = phong(origin, direction, isect);\n        color += mix(p, vec4(217.0, 247.0, 250.0, 255.0) / 255.0, vec4(min(isect.t / 200.0, 1.0)));\n    } else {\n        color = vec4(vec3(217.0, 247.0, 250.0) / 255.0, 1.0);\n    }\n    \n    \n    return vec4(vec3(pow(color.rgb, vec3(0.67))), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\n\n    vec3 v = vec3(V * vec4(1.0, 0.0, 0.0, 0.0));\n    vec3 u = vec3(V * vec4(0.0, 1.0, 0.0, 0.0));\n    vec3 w = vec3(V * vec4(0.0, 0.0, -1.0, 0.0));\n\n    float lr = (fragCoord.x - iResolution.x / 2.0) / (iResolution.x / 2.0);\n    float tb = (fragCoord.y - iResolution.y / 2.0) / (iResolution.x / 2.0);\n\n    vec3 direction = normalize(lr * v + tb * u - w);\n    // vec3 origin = vec3(cos(iTime)*2.0, sin(iTime)*2.0, -10.0);\n    vec3 origin = vec3(0.0, 5.0, -10.0);\n\n    vec3 pos = vec3(0.0);\n    vec3 normal = vec3(0.0);\n    vec3 color = vec3(0.0);\n\n    fragColor = raytrace(origin, direction, fragCoord);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}","name":"Common","description":"","type":"common"}]}