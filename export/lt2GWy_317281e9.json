{"ver":"0.1","info":{"id":"lt2GWy","date":"1432168305","viewed":147,"name":"Template Shader","username":"resonance","description":"Basic template I will be using as base to my new shaders. Very basic, tho.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3dshadertemplate"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"/* Victor Franco (resonance) */\n\n#define FAR 50.0\n#define EPS 0.01\n#define STEPS 128\n\n#define REFLECTIONS 4\n#define REFLECTIVENESS 0.3\n\n#define MULTISAMPLING4\n\n#define PI    3.14159265359\n#define TWOPI 6.28318530718\n\nconst vec3 backgroundColor = vec3(1.0);\n\nstruct Inter {\n\tint id;\n\tfloat dist;\n};\n\nInter iCilindroZ(int id, vec3 p, float s) {\n \treturn Inter (id, length(p.xy) - s);   \n}\n\nInter iSphere(int id, vec3 p, float s) {\n \treturn Inter (id, length(p) - s);\n}\n\nInter iCube(int id, vec3 p, float s) {\n \treturn Inter(id, length(max(abs(p) - s, 0.0)));   \n}\n\nInter iCubeZ(int id, vec3 p, float s) {\n \treturn Inter(id, length(max(abs(p.xy) - s, 0.0)));   \n}\n\nInter opU(in Inter a, in Inter b) {\n \treturn a.dist > b.dist ? b : a;   \n}\n\nInter opS(in Inter a, in Inter b) {\n\tb.dist = -b.dist;\n\treturn a.dist > b.dist ? a : b;\n}\n\nInter map(in vec3 p) {\n\tfloat angle = iTime * 0.075 + 0.5 * TWOPI * p.z/FAR;\n    \n\tvec3 pCubos = p;\n\tpCubos.xy += 4.0 * vec2(cos(angle), sin(angle));\t\n\tpCubos.xy  = mod(pCubos.xy, 10.0) - 5.0;\n\t\n\tvec3 pEsfera = p;\n\tpEsfera.z += -5.2;\n\t\n \treturn opU(\n\t\tiSphere(1, pEsfera, 1.0),\n\t\topS(iCubeZ(2, pCubos,  1.0),\n\t\t\tiSphere(3, pEsfera, 1.8)\n\t\t\t));\n}\n\n\n// FunÃ§Ã£o responsÃ¡vel por colorizar os objetos a partir de sua interseÃ§Ã£o\nvec3 colorize(Inter inter) {\n\tif (inter.id == 1) return vec3(0.1, 0.2, 0.3);\n\tif (inter.id == 2) return vec3(0.1);\n\tif (inter.id == 3) return vec3(0.0);\n\treturn backgroundColor;\n}\n\n// Calcula a normal para determinado ponto no espaÃ§o\nvec3 normals(in vec3 p) {\n \tvec2 e = vec2(0.001, 0.0);\n\treturn normalize(vec3(\n\t\tmap(p + e.xyy).dist - map(p - e.xyy).dist,\n\t\tmap(p + e.yxy).dist - map(p - e.yxy).dist,\n\t\tmap(p + e.yyx).dist - map(p - e.yyx).dist));\n}\n\nbool raymarch(out Inter inter, in vec3 ro, in vec3 rd) \n{   \n\t// DistÃ¢ncia real do 'ro' atÃ© o objeto\n\tfloat dist = 0.0;\n\t\n\t// Intersecta\n\tfor (int i = 0; i < STEPS; i++)\n\t{\n\t\tInter deltaInter = map(ro + dist * rd);\n\n\t\t// Caso passemos da distÃ¢ncia mÃ¡xima, para o loop\n\t\tif (dist > FAR)\n\t\t\tbreak;\n        \n\t\t// Caso ocorra colisÃ£o, isto Ã©, a variaÃ§Ã£o da distÃ¢ncia for menor\n\t\t// que EPSILON, move as informaÃ§Ãµes da interseÃ§Ã£o temporÃ¡ria para a\n\t\t// interseÃ§Ã£o real e retorna verdadeiro\n\t\tif (deltaInter.dist < EPS)\n\t\t{\n            inter.id   = deltaInter.id;\n            inter.dist = dist;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\t// AvanÃ§a a distÃ¢ncia real\n\t\tdist += deltaInter.dist;\n\t}\n\t\n\t// Retorna que nÃ£o foi possÃ­vel encontrar uma interseÃ§Ã£o\n\treturn false;\n}\n\nvec3 renderPixel(in vec2 coord)\n{   \n    // Cor final do pixel\n\tvec3 col = vec3(0.0);\n\t\n\t// Coordenadas do relativas viewport\n\tvec2 uv = 1.0 - 2.0 * (coord.xy / iResolution.xy);\n\t\t uv.x *= iResolution.x/iResolution.y;\n\t\n\t// DireÃ§Ã£o e origem do raio\n\tvec3 rd = normalize(vec3(uv, 1.0));\n\tvec3 ro = vec3(0.0);\n\t\n\t// Realiza a primeira iteraÃ§Ã£o do raymarching\n\tInter realInter;\n\tbool hit = raymarch(realInter, ro, rd);\n    \n   \t// Colore a imagem\n    col = colorize(realInter);\n\n    // Realiza reflexÃµes caso exista colisÃ£o\n    if (hit) \n    {\n        Inter inter = realInter;\n\t\tfor (int i = 0; i < REFLECTIONS; i++)\n\t\t{\n            // Normal para a interseÃ§Ã£o\n\t\t\tvec3 normal = normals(ro + inter.dist * rd);\n\t\t\t\n            // Novas posiÃ§Ãµes 'ro' e 'rd'\n\t\t\tro = ro + (inter.dist - EPS) * rd;\n\t\t\trd = reflect(rd, normal);\n\t\t\t\n            bool reflectHit = raymarch(inter, ro, rd);\n                \n\t\t\tcol += REFLECTIVENESS * colorize(inter);\n            \n            if (!reflectHit)\n            \tbreak;\n\t\t}\n    }\n\t\n\treturn mix(col, backgroundColor, realInter.dist/FAR);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n#ifdef MULTISAMPLING4\n\tvec2 e = vec2(0.0, 0.5);\n  \tvec3 col = renderPixel(fragCoord + e.ss)\n\t\t\t + renderPixel(fragCoord + e.st)\n\t\t\t + renderPixel(fragCoord + e.ts)\n\t\t\t + renderPixel(fragCoord + e.tt);\n\tcol /= 4.0;\n#else\n\tvec3 col = renderPixel(fragCoord);\n#endif\n    \n    fragColor = vec4(col, 1.0);\n}\n\n\t\n\t","name":"","description":"","type":"image"}]}