{"ver":"0.1","info":{"id":"clKfDG","date":"1702441858","viewed":24,"name":"UCSD CSE 167 HW5 kringpis","username":"kringpis","description":"This is a homework template for a homework for UCSD CSE 167.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["boids"],"hasliked":0,"parentid":"ddtyDs","parentname":"UCSD CSE 167 Boids template"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Smooth HSV2RGB from https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb(in vec3 c)\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 color = vec4(0.5, 0.5, 0.5, 1.0);\n    // Loop over all boids\n    vec4 bcolor = vec4(0.0, 0.0, 0.0, 1.0);\n    bool hit = false;\n    for (int i = 0; i < NUM_BOIDS; i++) {\n        ivec2 tex_pos = ivec2(i % int(iChannelResolution[0].x),\n                                                i / int(iChannelResolution[0].x));\n        vec4 pos_vel = texelFetch(iChannel0, tex_pos, 0);\n        if (distance(fragCoord, pos_vel.xy) < BOIDS_SIZE) {\n            vec3 rgb = hsv2rgb(vec3((float(i)+0.5) / float(NUM_BOIDS), 1.0, 0.9));\n            bcolor += vec4(rgb, 1.0);\n            hit = true;\n        }\n    }\n    if (hit) {\n        color = bcolor;\n    }\n\n    // Output to screen\n    fragColor = color;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    if (iFrame == 0) {\n        // initialize the buffer\n        vec4 pos_vel = texture(iChannel1, fragCoord/iChannelResolution[1].xy);\n        pos_vel.xy = iResolution.xy / 2.0 + (pos_vel.xy - 0.5) * iResolution.xy * 0.2;\n        pos_vel.zw = (pos_vel.zw - 0.5) * iResolution.xy * 1.0;\n        fragColor = pos_vel;\n        return;\n    }\n    ivec2 iFragCoord = ivec2(fragCoord);\n    // \n    vec4 pos_vel = texelFetch(iChannel0, iFragCoord, 0);\n    vec2 pos = pos_vel.xy;\n    vec2 vel = pos_vel.zw;\n    // ID of the current Boid\n    int my_id = int(iFragCoord.y) * int(iResolution.x) + int(iFragCoord.x);\n\n    // Implement Boids here\n    // Setting parameters given from HW5 pdf\n    float s_max = 10.0; // max speed\n    float s_min = 5.0;  // min speed\n    \n    float d_s = 30.0; // separation distance or \"safety\" distance\n    float d_v = 150.0; // visible distance or \"perceptual\" distance\n\n    float alpha_s = 0.02; // scalar parameter for controlling magnitude of separation force\n    float alpha_c = 0.001; // cohesion force parameter\n    float alpha_a = 0.03; // alignment force parameter\n    float alpha_b = 0.5; // boundary force parameter\n    \n    float d_left = 200.0; // domain boundaries\n    float d_right = float(iResolution.x) - 200.0;\n    float d_top = 160.0;\n    float d_bottom = float(iResolution.y) - 160.0;\n    \n    vec2 F_s = vec2(0.0,0.0); // separation force\n    vec2 F_c = vec2(0.0,0.0); // cohesion force\n    vec2 F_a = vec2(0.0,0.0); // alignment force\n    vec2 F_b = vec2(0.0,0.0); // boundary force\n    vec2 F = vec2(0.0,0.0); // total force (sum of all above)\n    \n    float N_s = 0.0; // number of nearby boids within distance d_s\n    float N_v = 0.0; // number of nearby visible boids within other dist threshold\n    \n    vec2 p_j = pos; // position of the current boid   \n    vec2 v_j = vel; // velocity of the current boid\n    vec2 p_i = vec2(0.0,0.0); // position of the nearby boid \n    vec2 v_i = vec2(0.0,0.0); // velocity of the nearby boid\n    vec2 pbar = vec2(0.0,0.0); // average position\n    vec2 vbar = vec2(0.0,0.0); // average velocity\n    \n    // Calculating forces\n    for(int i = 0; i < NUM_BOIDS; i++) {\n        if(i != my_id){\n            ivec2 texCoord = ivec2(i % int(iResolution.x), i / int(iResolution.x));\n            vec4 ipos_Vel = texelFetch(iChannel0, texCoord, 0);\n            p_i = ipos_Vel.xy;\n            v_i = ipos_Vel.zw; \n            \n            // For calculating separation force F_s\n            float dist = distance(p_j,p_i);\n            if (dist < d_s) {\n                N_s++;\n                F_s += p_j - p_i;\n            }\n          \n            // For calculating cohesion force F_c and alignment force F_a\n            if (dist < d_v) {\n                N_v++;\n                pbar += p_i;\n                vbar += v_i;\n            }\n        }\n    }\n    \n    if (N_s > 0.0){\n        F_s = F_s / N_s;\n    }\n    \n    if (N_v > 0.0){\n        pbar = pbar / N_v;\n        vbar = vbar / N_v;\n    }\n\n    F_c = pbar - p_j;\n    F_a = vbar - v_j;\n    \n    // Calculating boundary force F_b\n    F_b = vec2(float(p_j.x < d_left) - float(p_j.x > d_right), float(p_j.y < d_top) - float(p_j.y > d_bottom));\n    \n    // Calculating total force F\n    F = alpha_s*F_s + alpha_c*F_c + alpha_a*F_a + alpha_b*F_b;\n    \n    // Update current boid velocity (vel = v_j; pos = p_j)\n    vel += F;\n    \n    // Impose maximum and minimum speed to the boids\n    if (length(vel) > 0.0) {\n        if (length(vel) > s_max)\n            vel = vel * (s_max/length(vel));\n        if (length(vel) < s_min)\n            vel = vel * (s_min/length(vel));\n    }\n    \n    // Update current boid position\n    pos += vel;\n    \n    fragColor = vec4(pos, vel);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define NUM_BOIDS 200\n#define BOIDS_SIZE 10.0\n","name":"Common","description":"","type":"common"}]}