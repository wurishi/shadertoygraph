{"ver":"0.1","info":{"id":"sdVcDG","date":"1655555600","viewed":158,"name":"Dark Cloud and Dark River","username":"meowyih","description":"This shader shows some tricks of using ray marching. ","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This shader shows some tricks of using ray marching.\n// The code will be explained in my post in the bbs ptt.cc. #1YhVlLZd (GameDesign)\n//\n// In order to make it easy to read, it wasn't optimized and \n// has lot of duplicate part. For example, the ray march function\n// for sky and the river are exactly the same, except one line. (redundant)\n// Also, we should ignore the ray marching for rd.y < 0 in sky rendering \n// and rd.y > 0 in river rendering to increase fps. (bad performance)\n\n////////////////////////////////////////////////////////////////////////////////////////\n// iq's 3d noise functions from the elevated shader (incl. modifications where needed)\n////////////////////////////////////////////////////////////////////////////////////////\n\n// rotation matrix for fbm octaves\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n              \n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\n// 3d noise function\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\n// iq's fbm noise for 2-4 octaves including rotation per octave\nfloat fbm( vec3 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p );\n\tp = m*p*2.02;\n    f += 0.2500*noise( p ); \n\tp = m*p*2.03;\n    f += 0.1250*noise( p );\n\treturn f/0.875;\n}\n\n////////////////////////////////////////////////////////////////////////////////////////\n// end of iq's 3d noise functions from the elevated shader\n////////////////////////////////////////////////////////////////////////////////////////\n\n// given a pos in the world, return:\n// distance: \"shortest length\" between pos and sky, since sky is a xz-plane, \n//           it indicates the vertical distance between pos and sky\n// density: if pos is in the sky, returns the density of that point, otherwise returns 0.\nvoid sky( vec3 pos, out float distance, out float density )\n{\n    // sky is xz plane, with 1 unit height\n    // and we use noise to mess up the plane to create cloud look\n    // \n    // Before mess up (1.0 - pos.y) means:\n    //            distance density\n    //  +3       -2.0      2.05\n    //  +2       -1.0      1.05\n    //  +1  ----- sky -----\n    //  +0.07     0.03     0.02\n    //  +0.05     0.05     0\n    //  +0        0.0      0\n    //  -1        1.0      0\n    //  -2        2.0      0\n    distance = 1. - pos.y + fbm(pos*4.-iTime*0.2) * 0.3;\n    \n    // this line does the same thing as the if-statement block below. \n    // It means we only care the points from 0.05 lower than sky and \n    // above. 0.05 - distance is equal to the fbm in value sky() function.\n    density = step(distance, 0.05) * (0.05 - distance);\n    // if ( distance < 0.05 )\n    // {\n    //     density = 0.05 - distance;\n    // }\n}\n\nfloat sky_raymarch( in vec3 ro, in vec3 rd )\n{\n    float density_sum = 0.0;\n    vec3 pos = ro;\n    \n    for ( int i = 0; i < 20; i ++ )\n    {\n        // why not 1.0? we want some texture even the total density\n        // reaches the maximum.\n        if ( density_sum > 0.95 )\n            break;\n        \n        float distance; // shortest length between sky and pos\n        float density;  // density of pos\n        \n        // get distance and density\n        sky(pos, distance, density );\n        \n        // we add density in the reminder part. It will make sure\n        // the sum won't go over 1.0\n        density_sum += (1. - density_sum)*density;\n        \n        // why we can move such long distance in one step?\n        // It's SDF trick. The distance returned from sky() is the\n        // shortest distance between pos and sky. We can 'almost' \n        // garentee there is nothing between them.\n        // why 'almost'? because the plane was messed up by fbm.\n        distance = max(distance, 0.01 );\n        \n        pos = pos + rd*distance;\n    }\n    \n    // gamma correction (change the brightness)\n    density_sum = pow( density_sum, 0.6 );\n    \n    return density_sum;\n}\n\n// same as sky() function, \n// but this time the ocean is at xz plane with -1 unit height and upside down\nvoid river( vec3 pos, out float distance, out float density )\n{\n    distance = pos.y + 1. + fbm(pos*12.-vec3(pos.z,iTime,iTime*10.)) * 0.1;\n    // this line does the same thing as if-statement block below\n    // the different between this one and the one in sky_raymarch() is that\n    // we not only ignore the point that 0.05 higher than river plane, but also\n    // ignore the point that below the river plane. In other words, we only get the\n    // density with in 0.05 unit.\n    density = step(distance, 0.05) *  step(0.0, distance) * (0.05 - distance);\n    // if ( distance < 0.05 && distance > 0. )\n    // {\n    //     density = 0.05 - distance;\n    // }\n}\n\n// almost same as sky_raymarch, except the if-block in for loop.\nfloat river_raymarch( in vec3 ro, in vec3 rd )\n{\n    float density_sum = 0.0;\n    vec3 pos = ro;\n    \n    for ( int i = 0; i < 40; i ++ )\n    {\n        if ( density_sum > 0.95 )\n            break;\n            \n        float distance = 0.0; // shortest length between river and pos\n        float density = 0.0;\n        river(pos, distance, density );\n        \n        density_sum += (1. - density_sum)*density;\n\n        distance = max(distance, 0.01 );\n        \n        pos = pos + rd*distance;\n    }\n    \n    // gamma correction (change the brightness)\n    density_sum = pow( density_sum, 1.1 );\n    \n    return density_sum;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // (0,0) is at the center of screen, and y-axis range is from [1, -1]\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n#if 1\n    // adjust fish eye by changing the uv value\n    // I am pretty sure there is something wrong in my code,\n    // but it works in the wrong way. Gonna fix it one day. :(\n    // b - distance between eye and screen\n    // theta - angle of ray direction\n    // a - max ray distance\n    // c - adjust size\n    float b = 0.1;\n    float theta = tanh( uv.y / b );\n    float a = uv.y / sin(theta);\n    float c = (a-b) / sin(theta);\n    uv.y += c*1.;\n#endif\n\n    // we stand in position 0,0,0\n    vec3 ro = - vec3(0.,0.,0.);\n\n    // we got ray direction from uv\n    vec3 rd = normalize(vec3(uv,1.) );  \n    \n    // get the sky and ocean density\n    float sky_density = sky_raymarch( ro, rd );\n    float river_density = river_raymarch( ro, rd );\n    \n    // combines sky and ocean density and form a mono color\n    fragColor = vec4(vec3(sky_density + river_density),1.);\n}","name":"Image","description":"","type":"image"}]}