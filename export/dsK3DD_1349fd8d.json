{"ver":"0.1","info":{"id":"dsK3DD","date":"1678613897","viewed":290,"name":"Fly Through Spiral Grid","username":"HaleyHalcyon","description":".","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["spiral"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// set to 0 to make colors buttery-smooth\n// set to 1 to dither colors (for GIF export)\n#define DITHER 1\n\n// generate an ordered dithered pattern based on pixel coordinates\n#if DITHER == 1\nfloat crosshatch(vec2 xyf) {\n    ivec2 xy = ivec2(xyf) & 3;\n    return (float(\n        + ((xy.y >> 1) & 1)\n        + ((xy.x & 2) ^ (xy.y & 2))\n        + ((xy.y & 1) << 2)\n        + ((((xy.x) & 1) ^ (xy.y & 1)) << 3)\n    ) + 0.5) / 16.;\n}\n#endif\n\nconst float TURN = acos(-1.) * 2.;\n// rotation matrix\n#define ROT(x) mat2x2(cos(x + TURN * vec4(0, 0.25, -0.25, 0)))\n// converts colors from hex code to vec3\n#define HEX(x) vec3((ivec3(x) >> ivec3(16, 8, 0)) & 255) / 255.\n// “zigzag” value between 0 and 1\n#define ZIG(x) (1. - abs(1. - fract(x) * 2.))\n\n// convert float in range [0, 1) to a color based on a colormap\nvec3 colormap(float x){\n    const int colorCount = 16;\n    vec3[] c = vec3[](\n        HEX(0xfaf875),\n        HEX(0xfcfc26),\n        HEX(0xbcde26),\n        HEX(0x5CC863),\n        \n        HEX(0x1FA088),\n        HEX(0x33638D),\n        HEX(0x3D4285),\n        HEX(0x1F0269),\n        \n        HEX(0x25024D),\n        HEX(0x430787),\n        HEX(0x6F00A8),\n        HEX(0x9814A0),\n        \n        HEX(0xC23C81),\n        HEX(0xF07F4F),\n        HEX(0xFDB22F),\n        HEX(0xFAEB20)\n    );\n    x *= float(colorCount);\n    int lo = int(floor(x));\n    \n    return mix(\n        c[lo],\n        c[(lo + 1) % colorCount],\n        fract(x)\n        //smoothstep(0.0, 1., fract(x))\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = fract(iTime / 8.);\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    uv *= 2.;\n    \n    // For ease of calculation, X and Y are flipped here\n    vec2 disp = vec2(2, 1);\n    float dispAngle = atan(disp.x, disp.y);\n    float swingAngle = TURN / 2. - 2. * dispAngle;\n    vec2 swingRoot = disp.x / vec2(-1, tan(swingAngle));\n\n    float swingProg = cos((t + 1./16.) * TURN);\n    vec2 swingArm = vec2(0,-(swingRoot.y + disp.y)) * ROT(\n        swingAngle * swingProg\n    );\n    \n    uv *= ROT(cos(t * TURN) * 0.5 * swingAngle);\n    \n    vec2 swingDisp = vec2(0, swingRoot.y + disp.y) + swingArm;\n\n    float v = 0.;\n    const float LAYERS = 16.;\n    const float LAYERSPERLOOP = 4.;\n    const float ZSCALE = 0.25;\n    float LAYEROFFSET = floor(t * LAYERSPERLOOP);\n    for (float i = LAYERS; i > 0.; i--) {\n        float z = ZSCALE * (i - fract(t * LAYERSPERLOOP));\n        vec2 uvLayer = uv * z + swingDisp;\n        uvLayer = fract(uvLayer - 0.25);\n        float alpha = 1. - step(0.5, uvLayer.x) * step(0.5, uvLayer.y);\n        alpha *= step(0.06, z);\n        float altColor = 1. - step(uvLayer.x, 0.5) * step(uvLayer.y, 0.5);\n        \n        vec2 uvGrid = fract(uvLayer * 2.) - 0.5;\n        float r = length(uvGrid) + .05;\n        float theta = atan(uvGrid.y, uvGrid.x) / TURN;\n        \n        v = mix(\n            v, t + uv.y / 16. + ( \n                0.5 * altColor + 0.5 * step(\n                fract(\n                    mix(-1.2, 1.0, altColor) * log(r) +\n                    mix(0., 3., altColor) * theta +\n                    11. * t +\n                    1.3 * z +\n                    mix(0.5, 0., altColor)\n                ), 0.75) +\n                (i + LAYEROFFSET) / LAYERSPERLOOP\n            ),\n            alpha\n        );\n    }\n    \n#if DITHER == 1\n    float thres = crosshatch(fragCoord);\n    const float STEPS = 16.;\n    v = fract((\n        floor(v * STEPS) +\n        step(thres, fract(v * STEPS))\n    ) / STEPS);\n#endif\n\n    vec3 col = colormap(v);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}