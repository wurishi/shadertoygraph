{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"\n// change this to get different explosions :)\n#define EXPLOSION_SEED 0.\n\n// uncomment this to get a cross section view\n//#define CROSS_SECTION\n\n// the bounding sphere of the explosion. this is less general but means that\n// ray cast is only performed for nearby pixels, and raycast can begin from the sphere\n// (instead of walking out from the camera)\nfloat expRadius;\nvec3 expCenter;\n\n//iq's LUT 3D noise\nfloat noise( in vec3 x )\n{\n    vec3 f = fract(x);\n    vec3 p = x - f; // this avoids the floor() but doesnt affect performance for me.\n    f = f*f*(3.0-2.0*f);\n     \n    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n    vec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n    return mix( rg.x, rg.y, f.z );\n}\n\n// assign colour to the media\nvec3 computeColour( float density, float radius )\n{\n\t// these are almost identical to the values used by iq\n\t\n\t// colour based on density alone. gives impression of occlusion within\n\t// the media\n\tvec3 result = mix( 1.1*vec3(1.0,0.9,0.8), vec3(0.4,0.15,0.1), density );\n\t\n\t// colour added for explosion\n\tvec3 colBottom = 3.1*vec3(1.0,0.5,0.05);\n\tvec3 colTop = 2.*vec3(0.48,0.53,0.5);\n\tresult *= mix( colBottom, colTop, min( (radius+.5)/1.7, 1.0 ) );\n\t\n\treturn result;\n}\n\n// maps 3d position to colour and density\nfloat densityFn( in vec3 p, in float r, out float rawDens, in float rayAlpha )\n{\n\t// density has dependency on mouse y coordinate (linear radial ramp)\n\tfloat mouseIn = 0.85;\n\tif( iMouse.z > 0.0 )\n\t\tmouseIn = iMouse.y/iResolution.y;\n\tfloat mouseY = 1.0 - mouseIn;\n    float den = -0.1 - 1.5*r*(4.*mouseY+.5);\n    \n\t// offset noise based on seed\n    float t = EXPLOSION_SEED;\n    vec3 dir = vec3(0.,1.,0.);\n    \n    // participating media    \n    float f;\n    vec3 q = p - dir* t; f  = 0.50000*noise( q );\n\tq = q*2.02 - dir* t; f += 0.25000*noise( q );\n\tq = q*2.03 - dir* t; f += 0.12500*noise( q );\n\tq = q*2.01 - dir* t; f += 0.06250*noise( q );\n\tq = q*2.02 - dir* t; f += 0.03125*noise( q );\n\t\n\t// add in noise with scale factor\n\trawDens = den + 4.0*f;\n\t\n    den = clamp( rawDens, 0.0, 1.0 );\n    \n\t// thin out the volume at the far extends of the bounding sphere to avoid\n\t// clipping with the bounding sphere\n\tden *= 1.-smoothstep(0.8,1.,r/expRadius);\n\t\n\t#ifdef CROSS_SECTION\n\tden *= smoothstep(.0,.1,-p.x);\n\t#endif\n\t\n\treturn den;\n}\n\nvec4 raymarch( in vec3 rayo, in vec3 rayd, in float expInter, in vec2 fragCoord )\n{\n    vec4 sum = vec4( 0.0 );\n     \n    float step = 0.075;\n     \n    // dither start pos to break up aliasing\n\tvec3 pos = rayo + rayd * (expInter + step*texture( iChannel0, fragCoord.xy/iChannelResolution[0].x ).x);\n\t\n    for( int i=0; i<25; i++ )\n    {\n        if( sum.a > 0.99 ) continue;\n\t\t\n\t\tfloat radiusFromExpCenter = length(pos - expCenter);\n\t\t\n\t\tif( radiusFromExpCenter > expRadius+0.01 ) continue;\n\t\t\n\t\tfloat dens, rawDens;\n\t\t\n        dens = densityFn( pos, radiusFromExpCenter, rawDens, sum.a );\n\t\t\n\t\tvec4 col = vec4( computeColour(dens,radiusFromExpCenter), dens );\n\t\t\n\t\t// uniform scale density\n\t\tcol.a *= 0.6;\n\t\t\n\t\t// colour by alpha\n\t\tcol.rgb *= col.a;\n\t\t\n\t\t// alpha blend in contribution\n\t\tsum = sum + col*(1.0 - sum.a);  \n\t\t\n\t\t// take larger steps through negative densities.\n\t\t// something like using the density function as a SDF.\n\t\tfloat stepMult = 1. + 2.5*(1.-clamp(rawDens+1.,0.,1.));\n\t\t\n\t\t// step along ray\n\t\tpos += rayd * step * stepMult;\n    }\n\t\n    return clamp( sum, 0.0, 1.0 );\n}\n\n// iq's sphere intersection\nfloat iSphere(in vec3 ro, in vec3 rd, in vec4 sph)\n{\n\t//sphere at origin has equation |xyz| = r\n\t//sp |xyz|^2 = r^2.\n\t//Since |xyz| = ro + t*rd (where t is the parameter to move along the ray),\n\t//we have ro^2 + 2*ro*rd*t + t^2 - r2. This is a quadratic equation, so:\n\tvec3 oc = ro - sph.xyz; //distance ray origin - sphere center\n\t\n\tfloat b = dot(oc, rd);\n\tfloat c = dot(oc, oc) - sph.w * sph.w; //sph.w is radius\n\tfloat h = b*b - c; // delta\n\tif(h < 0.0) \n\t\treturn -1.0;\n\tfloat t = (-b - sqrt(h)); //Again a = 1.\n\n\treturn t;\n}\n\nvec3 computePixelRay( in vec2 p, out vec3 cameraPos )\n{\n    // camera orbits around explosion\n\t\n    float camRadius = 3.8;\n\t// use mouse x coord\n\tfloat a = iTime*20.;\n\tif( iMouse.z > 0. )\n\t\ta = iMouse.x;\n\tfloat theta = -(a-iResolution.x)/80.;\n    float xoff = camRadius * cos(theta);\n    float zoff = camRadius * sin(theta);\n    cameraPos = vec3(xoff,expCenter.y,zoff);\n     \n    // camera target\n    vec3 target = vec3(0.,expCenter.y,0.);\n     \n    // camera frame\n    vec3 fo = normalize(target-cameraPos);\n    vec3 ri = normalize(vec3(fo.z, 0., -fo.x ));\n    vec3 up = normalize(cross(fo,ri));\n     \n    // multiplier to emulate a fov control\n    float fov = .5;\n\t\n    // ray direction\n    vec3 rayDir = normalize(fo + fov*p.x*ri + fov*p.y*up);\n\t\n\treturn rayDir;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// get aspect corrected normalized pixel coordinate\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x / iResolution.y;\n    \n    expRadius = 1.75;\n\texpCenter = vec3(0.,expRadius,0.);\n\t\n\tvec3 rayDir, cameraPos;\n    rayDir = computePixelRay( p, cameraPos );\n\t\n\tvec4 col = vec4(0.);\n\t\n    // does pixel ray intersect with exp bounding sphere?\n\tfloat boundingSphereInter = iSphere( cameraPos, rayDir, vec4(expCenter,expRadius) );\n\tif( boundingSphereInter > 0. )\n\t{\n\t\t// yes, cast ray\n\t    col = raymarch( cameraPos, rayDir, boundingSphereInter,fragCoord );\n\t}\n\t\n    // smoothstep final color to add contrast\n    fragColor.xyz = col.xyz*col.xyz*(3.0-2.0*col.xyz);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Xss3DS","date":"1378501611","viewed":5545,"name":"Anatomy of an explosion","username":"huwb","description":"Instructions: Click and drag!\n\nMy first steps in volume rendering, hope it's instructive for others. This started life as, and borrows much from, iq's Hell shader.\n\nIt takes bigger steps in empty space similar to marching through a distance field.","likes":126,"published":1,"flags":0,"usePreview":1,"tags":["3d","noise","raycast","explosion","volumetric"],"hasliked":0,"parentid":"","parentname":""}}