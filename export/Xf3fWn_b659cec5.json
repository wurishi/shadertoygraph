{"ver":"0.1","info":{"id":"Xf3fWn","date":"1732899257","viewed":95,"name":"Apple Posterized Perlin Noise","username":"dennizor","description":"(Apple inspired)","likes":3,"published":3,"flags":0,"usePreview":0,"tags":["noise","perlin","apple","poster"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Customizable parameters\n#define NOISE_SCALE 4.0      // How zoomed in/out the noise appears\n#define ANIMATION_SPEED 0.1  // How fast the noise morphs\n#define NUM_COLORS 11        // Number of colors in palette - MUST MATCH arrays below\n#define NOISE_OCTAVES 1      // Number of noise layers\n\nconst vec3 COLORS[11] = vec3[11](\n    vec3(0.0, 0.0, 0.0),       // #000000 Black\n    vec3(0.447, 0.133, 0.906), // #7222E7 Electric Purple\n    vec3(0.0, 0.0, 0.0),       // #000000 Black\n    vec3(0.992, 0.952, 0.349), // #FDF359 Canary Yellow\n    vec3(0.968, 0.839, 0.431), // #F7D66E Golden Yellow\n    vec3(0.745, 0.157, 0.965), // #BE28F6 Bright Purple\n    vec3(0.129, 0.306, 0.933), // #214EEE Royal Blue\n    vec3(0.486, 0.965, 0.976), // #7CF6F9 Bright Cyan\n    vec3(0.0, 0.0, 0.0),       // #000000 Black\n    vec3(0.902, 0.204, 0.482), // #E6347B Hot Pink\n    vec3(0.0, 0.0, 0.0)        // #000000 Black\n);\n\n// Updated thresholds to include new color while maintaining similar spacing\nconst float COLOR_THRESHOLDS[11] = float[11](\n    0.43,\n    0.455,\n    0.48,\n    0.486,\n    0.5,\n    0.505,\n    0.53,\n    0.54,    // Added new threshold for cyan\n    0.55,\n    0.6,\n    0.601\n);\n\nfloat rand(vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 getGradient(vec2 intPos, float t) {\n    float randVal = rand(intPos);\n    float angle = 6.283185 * randVal + ANIMATION_SPEED * t * randVal;\n    return vec2(cos(angle), sin(angle));\n}\n\nfloat perlin(vec3 pos) {\n    vec2 i = floor(pos.xy);\n    vec2 f = pos.xy - i;\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    \n    float a = dot(getGradient(i + vec2(0, 0), pos.z), f - vec2(0, 0));\n    float b = dot(getGradient(i + vec2(1, 0), pos.z), f - vec2(1, 0));\n    float c = dot(getGradient(i + vec2(0, 1), pos.z), f - vec2(0, 1));\n    float d = dot(getGradient(i + vec2(1, 1), pos.z), f - vec2(1, 1));\n    \n    float noise = mix(\n        mix(a, b, u.x),\n        mix(c, d, u.x),\n        u.y\n    );\n    \n    return noise * 0.5 + 0.5;\n}\n\nfloat fbm(vec3 pos) {\n    float value = 0.0;\n    float amplitude = 1.0;\n    float frequency = 1.0;\n    float sum = 0.0;\n    \n    for(int i = 0; i < NOISE_OCTAVES; i++) {\n        value += amplitude * perlin(pos * frequency);\n        sum += amplitude;\n        amplitude *= 0.5;\n        frequency *= 2.0;\n    }\n    \n    return value / sum;\n}\n\nvec3 getColor(float t) {\n    // Find which interval we're in\n    for(int i = 0; i < NUM_COLORS - 1; i++) {\n        if(t >= COLOR_THRESHOLDS[i] && t < COLOR_THRESHOLDS[i + 1]) {\n            // Get the two colors to interpolate between\n            vec3 color1 = COLORS[i];\n            vec3 color2 = COLORS[i + 1];\n            \n            // Calculate how far we are between thresholds\n            float interval = COLOR_THRESHOLDS[i + 1] - COLOR_THRESHOLDS[i];\n            float localT = (t - COLOR_THRESHOLDS[i]) / interval;\n            \n            // Sharp transition in middle of interval\n            return mix(color1, color2, step(0.5, localT));\n        }\n    }\n    return COLORS[NUM_COLORS - 1]; // Return last color if we're at 1.0\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 scaled_uv = uv * NOISE_SCALE;\n    float noise = fbm(vec3(scaled_uv, iTime));\n    vec3 col = getColor(noise);\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}