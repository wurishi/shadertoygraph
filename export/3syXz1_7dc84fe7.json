{"ver":"0.1","info":{"id":"3syXz1","date":"1573355854","viewed":165,"name":"mini path tracer","username":"gabrielpiveta","description":"my basic path tracer :)","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracer","sphere","pathtracer","graphics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"int sd = 2401;\n\nvoid srand(int s)\n{\n   \tsd = s;\n}\n\nint rand()\n{\n    return ((sd = sd * 214013 + 2531011) >> 16) & 0x7fff;\n}\n\nfloat frand()\n{\n    return float(rand()) / float(0x7fff);\n}\n\nstruct Camera\n{\n    vec3 origin;\n    vec3 downleft;\n    vec3 horizontal;\n    vec3 vertical;\n};\n\nstruct Ray\n{\n    vec3 pos;\n    vec3 dir;\n};\n\nstruct Intersection\n{\n    vec3 point;\n    vec3 normal;\n    float t;\n};\n    \nstruct Sphere\n{\n    vec3 pos;\n    float radius;\n    vec3 color;\n};\n    \nstruct World\n{\n    Sphere spheres[100];\n    int size;\n};\n    \nWorld world;\n\nvoid initWorld()\n{\n    world.size = 0;\n}\n\nvoid addSphere(Sphere sphere)\n{\n   \tworld.spheres[world.size] = sphere;\n    world.size++;\n}\n\nCamera makeCamera(float fov, float aspect)\n{\n    float hheight = tan(fov * 0.5);\n    float hwidth = aspect * hheight;\n    \n    Camera tmp;\n    tmp.downleft = vec3(-hwidth, -hheight, -1.0f);\n    tmp.horizontal = vec3(2.0 * hwidth, 0.0, 0.0);\n    tmp.vertical = vec3(0.0, 2.0 * hheight, 0.0);\n    tmp.origin = vec3(0.0, 0.0, 0.0);\n    \n    return tmp;\n}\n\nRay cameraSampleRay(out Camera cam, vec2 uv)\n{\n    Ray tmp;\n    tmp.pos = cam.origin;\n    tmp.dir = cam.downleft + uv.x * cam.vertical + uv.y * cam.horizontal; \n    return tmp;\n}\n    \nbool intersectRaySphere(vec3 pos, float radius, Ray ray, out Intersection isect)\n{\n    /* t*t(b.b) + 2*t*(b.(a-c)) + (a-c).(a-c) - R*R = 0 */\n   \tvec3 d = ray.pos - pos;\n    float b = 2.0 * dot(ray.dir, d);\n    \n    if(b > 0.0) return false;\n    \n    float c = dot(d, d) - radius*radius;\n    float det = b * b - 4.0 * c;\n    \n    if(det >= 0.0f){\n       \tfloat tmp = (-b - sqrt(det)) / 2.0f;\n        if(tmp < 0.001 || tmp > 1000000.0) return false;\n       \t\n        isect.t = tmp;\n        isect.point = ray.pos + ray.dir * tmp;\n        isect.normal = (isect.point - pos) / radius;\n        \n        return true;\n    }\n    return false;\n}\n\n\nbool intersectAnything(Ray ray, out Intersection isect, out Sphere sphere)\n{\n    Intersection tmp;\n    bool anything;\n    float closest = 1000000.0;\n    for(int i = 0; i < world.size; ++i)\n    {\n        if(intersectRaySphere(world.spheres[i].pos, world.spheres[i].radius, \n                              ray, tmp))\n        {\n            if(tmp.t < closest){\n                closest = tmp.t;\n                anything = true;\n                isect = tmp;\n                sphere = world.spheres[i];\n            }\n        }\n    }\n    return anything;\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 rand2(vec2 co){\n    return vec2(rand(co), rand(co + 20423.42));\n}\n\nvec3 sampleCosineHemisphere(float u1, float u2)\n{\n \tfloat sin_theta = sqrt(max(0.0, 1.0 - u1 * u1));\n\tfloat phi = 2.0 * 3.1415926535 * u2;\n\tvec3 result = vec3( \n\t\tcos(phi) * sin_theta, \n\t\tsin(phi) * sin_theta, \n\t\tu1 \n\t);\n\treturn result;\n}\n\nvec3 rayColor(Ray ray)\n{\n    vec3 col = vec3(1.0);\n    while(true)\n    {\n    \tray.dir = normalize(ray.dir);\n    \t\n    \tIntersection isect;\n        Sphere sphere;\n    \n    \tif(intersectAnything(ray, isect, sphere))\n    \t{\n      \t  vec3 ch = sampleCosineHemisphere(frand(), frand());\n          ch += isect.normal;\n      \t  ray.pos = isect.point;\n       \t  ray.dir = ch;\n      \t  col *= sphere.color;\n          continue;\n   \t\t}\n    \n    \tfloat t = 0.5 * (ray.dir.x + 1.0);\n    \tcol *= mix(vec3(1.0), vec3(0.5, 0.7, 1.0), t); \n        break;\n    }\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int samples = 100;\n    float isamples = 1.0/float(samples);\n    \n    srand(int(fragCoord.x) * int(fragCoord.y));\n    srand(rand());\n    srand(rand());\n  \n\tCamera cam = makeCamera(3.1415926 * 0.3333, iResolution.y / iResolution.x);\n \tinitWorld();\n    \n    Sphere s1;\n    s1.pos = vec3(0.0, 0.0, -2.0);\n \ts1.radius = 0.5;\n    s1.color = vec3(1.0, 0.2, 1.0);\n    addSphere(s1);\n    Sphere s2;\n    s2.pos = vec3(-1000.0, 0.0, -2.0);\n \ts2.radius = 999.5;\n    s2.color = vec3(0.1, 0.1, 0.1);\n    addSphere(s2);\n    \n    vec3 color;\n    \n    for(int i = 0; i < samples; ++i)\n    {\n          \n   \t \tvec2 uv = (fragCoord + rand2(vec2(float(i))))/\n            iResolution.xy;\n        color += rayColor(cameraSampleRay(cam, uv));\n    }\n    \n    color *= isamples;\n    color = pow(color, vec3(1.0 / 2.4));\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}