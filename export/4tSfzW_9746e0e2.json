{"ver":"0.1","info":{"id":"4tSfzW","date":"1514773283","viewed":168,"name":"Raymarching + CSG","username":"PGrad","description":"CSG means \"Constructive Solid Geometry\": https://en.wikipedia.org/wiki/Constructive_solid_geometry\nSigned Distance Functions from here: https://iquilezles.org/articles/distfunctions/distfunctions.htm\nRaymarching algorithm from here: http://jamie-wo","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","csg","dreidel","paul"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\nconst float SPHERE_RADIUS = 1.;\n\n//For each of the CSG logic functions, it is helpful to\n//think about a Venn Diagram and calculating the sdf of points\n//inside each circle.\n\n//Also known as \"nearest\". Chooses the closest shape,\n//i.e. the most negative/interior of two intersecting shapes.\nvec2 csg_union(vec2 shape1, vec2 shape2) {\n\tvec2 res;\n    if(shape1.x < shape2.x)\n        res = shape1;\n    else\n        res = shape2;\n    return res;\n}\n\n//Chooses the shape with the farthest sdf. This gives the \n//intersection because given 2 intersecting objects and a ray,\n//we always choose the furthest away (least negative).\nvec2 intersect(vec2 shape1, vec2 shape2) {\n\tvec2 res;\n    if(shape1.x > shape2.x)\n        res = shape1;\n    else\n        res = shape2;\n    return res;\n}\n\n//A - B is A intersect (negate B)\nvec2 diff(vec2 shape1, vec2 shape2) {\n    return intersect(shape1, vec2(-shape2.x, 0.));\n    \n}\n\nfloat yCylinderSDF( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat xCylinderSDF( vec3 p, vec3 c )\n{\n  return length(p.yz-c.xy)-c.z;\n}\n\nfloat zCylinderSDF( vec3 p, vec3 c )\n{\n  return length(p.xy-c.xy)-c.z;\n}\n\n//Signed distance function for a box centered at origin.\nfloat boxSDF(vec3 samplePoint, vec3 rt_corner, vec3 c) {\n\tvec3 dist = abs(samplePoint - c) - rt_corner;\n    return min(\n        \t   max(dist.x, max(dist.y, dist.z)),\n               0.\n       \t   ) \n           + length(max(dist, 0.));\n}\n\n/**\n * Signed distance function for a sphere centered at the origin with radius 1.0;\n */\nfloat sphereSDF(vec3 samplePoint, float s, vec3 c) {\n    return length(samplePoint - c) - s;\n}\n\nfloat coneSDF( vec3 p, vec3 c ) {\n    // c must be normalized\n    float q = length(p.xz);\n    return dot(c.xy,vec2(q,p.y - c.z));\n}\n\nfloat ellipsoidSDF( in vec3 p, in vec3 r, vec3 c)\n{\n    return (length( (p - c)/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nvec2 idShape(float dist, float id) {\n\treturn vec2(dist, id); \n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nvec2 sceneSDF(vec3 samplePoint) {\n    float id = 1.;\n    vec2 ground = idShape(boxSDF(samplePoint, vec3(50., 0., 50.), vec3(0., -1.1, 0.)), id++);\n    vec2 sd_box = idShape(boxSDF(samplePoint, vec3(.5, .3, .5), vec3(0., 0., 0.)), id++);\n    vec2 sd_cyl = idShape(yCylinderSDF(samplePoint, vec3(0., .0, .1)), id++);\n    vec2 sd_cyl_z = idShape(zCylinderSDF(samplePoint, vec3(0., .2, .718)), id++);\n    vec2 sd_cyl_x = idShape(xCylinderSDF(samplePoint, vec3(.2, 0, .718)), id++);\n    vec2 cyl_bounded = intersect(sd_cyl,\n                       \t\tidShape(sphereSDF(samplePoint, .6, vec3(0., .7, 0.)), id++));\n    vec2 cyl_bounded_z = intersect(sd_cyl_z, \n                        \tidShape(boxSDF(samplePoint, vec3(.5, 1., .5), vec3(0., -.8, 0.)), id++));\n    vec2 cyl_bounded_x = intersect(sd_cyl_x, \n                        \tidShape(boxSDF(samplePoint, vec3(.5, 1., .5), vec3(0., -.8, 0.)), id++));\n    vec2 ellip = idShape(ellipsoidSDF(samplePoint, vec3(.87, 1.5, .87), vec3(0., 0.4, 0.)), id++);\n    vec2 bottom_bound = idShape(boxSDF(samplePoint, vec3(.5, .6,.5), vec3(0., -.95, 0.)), id++);\n    vec2 bottom = intersect(ellip, bottom_bound);\n    return csg_union(ground,\n               csg_union(cyl_bounded,\n                         csg_union(\n                                   csg_union(cyl_bounded_x,\n                                             csg_union(sd_box, cyl_bounded_z)),\n                         bottom)\n               )\n           );\n}\n\nvec3 estimateNormal(vec3 p) {\n\treturn normalize(\n        \t\tvec3(\n                    sceneSDF(vec3(p.x + EPSILON, p.y, p.z)).x - \n                    sceneSDF(vec3(p.x - EPSILON, p.y, p.z)).x,\n                    sceneSDF(vec3(p.x, p.y + EPSILON, p.z)).x - \n                    sceneSDF(vec3(p.x, p.y - EPSILON, p.z)).x,\n                    sceneSDF(vec3(p.x, p.y, p.z + EPSILON)).x - \n                    sceneSDF(vec3(p.x, p.y, p.z - EPSILON)).x\n               \t)\n           );\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nvec2 shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec2 sd = sceneSDF(eye + depth * marchingDirection);\n        if (sd.x < EPSILON) {\n\t\t\treturn vec2(depth, sd.y);\n        }\n        depth += sd.x;\n        if (depth >= end) {\n            return vec2(end, 0.);\n        }\n    }\n    return vec2(end, 0.);\n}\n            \nfloat lambert(vec3 n, vec3 l) {\n\treturn clamp(dot(n, l), 0., 1.);\n}\n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec3 rotate(vec3 p, float angle) {\n\treturn vec3(\n        \t\tdot(p.xz, vec2(cos(angle), -sin(angle))),\n        \t\tp.y,\n        \t\tdot(p.xz, vec2(sin(angle), cos(angle)))\n           );\n}\n\nmat4 lookAt(vec3 p, vec3 center, vec3 up) {\n    vec3 fwd = normalize(center - p);\n    \n    vec3 strafe = normalize(cross(fwd, up));\n    \n    vec3 new_up = cross(strafe, fwd);\n    \n    return mat4(vec4(strafe, 0.),\n               \tvec4(new_up, 0.),\n                vec4(-fwd, 0.),\n                vec4(vec3(0.), 1.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 dir = rayDirection(90.0, iResolution.xy, fragCoord);\n    float freq = 5.;\n    vec3 eye = vec3(0., 1., 0.) + 3. * vec3(cos(iTime * freq), 0., sin(iTime * freq));\n    dir = (lookAt(eye, vec3(0.), vec3(0., 1., 0.)) * vec4(dir, 1.)).xyz; \n    vec2 sd = shortestDistanceToSurface(eye, dir, MIN_DIST, MAX_DIST);\n    \n    float dist = sd.x;\n    float type = sd.y;\n    vec3 iXPos = eye + dist * dir;\n    \n    vec3 light = eye;\n    vec3 lightDir = normalize(light - iXPos);\n    vec3 normal = estimateNormal(iXPos);\n    float lambert = lambert(normal, lightDir);\n    float ambient = 0.1;\n    vec3 color;\n    \n    // Didn't hit anything\n    color = ((dist > MAX_DIST - EPSILON) ? vec3(0.) :\n               (type > .5 && type < 1.5) ? vec3(.8, .4, 0.) :\n \t\t\t\t\t\t\t\t\t\t   vec3(0., 0., .9)) * (lambert + ambient);\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}