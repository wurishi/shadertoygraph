{"ver":"0.1","info":{"id":"tsB3Rc","date":"1549509963","viewed":137,"name":"Mount Castle","username":"cbrpnk","description":"everyday","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 rotate(vec2 p, float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c) * p;\n}\n\nfloat box(vec3 p, vec3 r)\n{\n    vec3 d = abs(p) - r;\n \treturn length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat cylinder(vec3 p, float r, float l)\n{\n    return max(length(p.xz) - r, abs(p).y-l);\n}\n\nfloat caps(vec3 p, float r, float l)\n{   \n    return length(p-vec3(0., clamp(p.y, -l, l), 0.)) - r;\n}\n\nfloat sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat voronoi(vec2 p)\n{    \n    p = mod(p+vec2(.5), 1.)-vec2(.5);\n    p *= 5.;\n    p = abs(p);\n    \n    float d = 1000000.;\n    float alpha = .25;\n    \n    for(int i=0; i<2; ++i) {\n        for(int j=0; j<2; ++j) {\n        \td = min(d, length(p-vec2(float(i)*alpha, (float(j)+.5*mod(float(i), 2.))*alpha)));\n        \td = min(d, length(p-vec2(i, j)));\n            d = min(d, length(p-vec2(i, j)*2.));\n            d = min(d, length(p-vec2(i, j)*3.));\n        }\n    }\n    \n    return d;\n}\n\nfloat tower(vec3 p)\n{\n    p.xz = abs(p.xz);\n    p.xz -= vec2(.5);\n    p.y -= .1;\n    float d = 1000.;\n    d = min(d, cylinder(p, .2, .6));\n    d = min(d, cylinder(p-vec3(0., .5, 0.), .23, .1));\n    d = max(d, -cylinder(p+vec3(0., -.6, 0.), .15, .1));\n    float h = min(1000., box(p-vec3(.01, .6, .1), vec3(.025, .055, .4)));\n    h = min(h, box(p-vec3(.01, .6, .01), vec3(.4, .055, .025)));\n    p.xz = rotate(p.xz, .7);\n    h = min(h, box(p-vec3(.01, .6, .01), vec3(.4, .055, .025)));\n    h = min(h, box(p.zyx-vec3(.01, .6, .01), vec3(.4, .055, .025)));\n    return max(d, -h);\n}\n\nfloat outterWalls(vec3 p)\n{\n\tfloat d = 1000000.;\n    d = min(d, box(p, vec3(.5)));\n    d = max(d, -box(p-vec3(0., .2, 0.), vec3(.4, 1., .4)));\n    \n    d = max(d, -box(p-vec3(0.12, .5, 0.), vec3(.05, .1, 1.)));\n    d = max(d, -box(p-vec3(-.12, .5, 0.), vec3(.05, .1, 1.)));\n    p.xz = rotate(p.xz, 1.55);\n    d = max(d, -box(p-vec3(0.12, .5, 0.), vec3(.05, .1, 1.)));\n    d = max(d, -box(p-vec3(-.12, .5, 0.), vec3(.05, .1, 1.)));\n    \n    return d;\n}\n\nfloat inner(vec3 p)\n{\n    float main = box(p-vec3(0., .25, 0.), vec3(.25, .7, .25));\n    float top = box(p-vec3(0., 1., 0.), vec3(.3, .2, .3));\n    float cap = caps(vec3(abs(p.x), p.y, abs(p.z)) - vec3(.25, 1., .25), .1, .25);\n    \n    \n   \tfloat roof = box(p-vec3(0.1, 1.2, 0.), vec3(.025, .1, 1.));\n    float roof2 = box(p-vec3(-0.1, 1.2, 0.), vec3(.025, .1, 1.));\n    p.xz = rotate(p.xz, 1.55);\n    float roof3 = box(p-vec3(0.1, 1.2, 0.), vec3(.025, .1, 1.));\n    float roof4 = box(p-vec3(-0.1, 1.2, 0.), vec3(.025, .1, 1.));\n    float roof5 = box(p-vec3(-0., 1.2, 0.), vec3(.25, .2, .25));\n    float roof6 = box(p-vec3(-0., 1.2, 0.), vec3(.05, .8, .05));\n    \n    \n    \n    float d = min(main, top);\n    d = min(d, cap);\n    d = max(d, -roof);\n    d = max(d, -roof2);\n    d = max(d, -roof3);\n    d = max(d, -roof4);\n    d = max(d, -roof5);\n    d = min(d, roof6);\n    return d;\n}\n\nfloat land(vec3 p)\n{\n    p.y += 2.2;\n    //p.xz *= .8;\n    float mount = sphere(p, 2.) - voronoi(p.xz)*.1 - voronoi(p.xz*1.5)*.05;\n    float d = mount;\n    \n    return d;\n}\n\nfloat map(vec3 p)\n{\n    p.yz = rotate(p.yz, .3);\n    p.xz = rotate(p.xz, iTime*.25);\n    \n    float d = 1000000.;\n    d = min(d, outterWalls(p));\n    d = min(d, tower(p));\n    d = min(d, inner(p));\n    d = min(d, land(p));\n    \n    return d;\n}\n\nvec2 march(vec3 ro, vec3 rd)\n{\n    float t = 0.;\n    float ao = 0.;\n    for(int i=0; i<128; ++i) {\n        ao = float(i);\n    \tfloat d = map(ro+rd*t);\n        if(d < .001) break;\n        t += d*.6;\n    }\n    return vec2(t, ao);\n}\n\nvec3 getNormal(vec3 p)\n{\n    return normalize(vec3(\n    \tmap(p+vec3(0.001, 0., 0.)) - map(p-vec3(0.001, 0., 0.)),\n        map(p+vec3(0., 0.001, 0.)) - map(p-vec3(0., 0.001, 0.)),\n        map(p+vec3(0., 0., 0.001)) - map(p-vec3(0., 0., 0.001))\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - vec2(.5);\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 eye = vec3(0., 0., 4.);\n    vec3 lookat = normalize(vec3(uv.x, uv.y, -1.));\n    vec2 res = march(eye, lookat);\n    vec3 normal = getNormal(eye+lookat*res.x);\n    \n    vec3 col = vec3(.1, .1, .9);\n    if(res.x<100.) {\n        col = vec3(.4) * (uv.x+.5);\n        col += .3 * vec3(.8, .8, .55) * max(0., dot(normal, vec3(1., 0., 1.)));\n        col += .3 * vec3(.55, .8, .8) * max(0., dot(normal, vec3(-1., 1., 1.)));\n        col *= pow(res.x*.2, 1.1);\n        col *= 1.4;\n    }\n\n    col *= pow(max(dot(lookat, vec3(0., 0., -1.)), 0.), 5.);\n    col = sqrt(col);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}