{"ver":"0.1","info":{"id":"MlcSDX","date":"1481970760","viewed":949,"name":"Pretty Ground, Breaking.","username":"Hadyn","description":"A little update of my previous shader, adding in perspective projection and a second layer to help convey a sense of depth. Apologies for messy/un-commented source; I'll try to come back to tidy it up a bit later on.","likes":58,"published":1,"flags":0,"usePreview":1,"tags":["voronoi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Made by hadyn lander\n\n// Based on original code by by inigo quilez - iq/2013\n// https://www.shadertoy.com/view/ldl3W8\n// https://iquilezles.org/articles/voronoilines\n\n#define MAXDEPTH 60.\n#define FOGSTART 8.\n#define FOGCOLOR vec3(1,1,1)\n#define FOV 120.\n#define NEARPLANE 0.0001\n#define UP vec3(0.0, 1.0, 0.0)\n\n\nvec2 hash2( vec2 p )\n{\n\t// texture based white noise\n\treturn texture( iChannel0, (p+0.5)/256.0, -100.0 ).xy;\n\t\n    // procedural white noise\t\n\t//return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvec4 voronoi( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\tvec2 o;\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mg, mr;\n\tfloat oldDist;\n    \n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\to = hash2( n + g );\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n\t\n    oldDist = md;\n    \n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\to = hash2( n + g );\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>0.00001 )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\n    return vec4( md, mr, oldDist );\n}\n\n// I borrowed this useful function from: http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvec3 getPlaneIntersectPhase(vec3 ro, vec3 rd, float planeY)\n{\n    \n    float intersect = (planeY-(ro+rd).y)/normalize(rd).y;\n    if( intersect > 0.0)\n    {        \n        float twistSpeed = 2.0;\n        float twistScale = 1.25;\n        \n        vec3 p = ro+rd+normalize(rd)*intersect;\n        vec4 c = voronoi( p.xz );\n         \n        float camDist = max(-0.35+max(p.z-ro.z, 0.0)*0.6, 0.0);\n        float edgePhase = abs(p.x+(sin(twistSpeed*p.z*0.35)*1.0+sin(twistSpeed*p.z*0.5156)*0.35+sin(twistSpeed*p.z*1.241)*0.15)*twistScale);\n\n        edgePhase *= 0.05;        \n\t\tedgePhase -= -0.925 + pow(0.065*camDist, 1.4);        \n        edgePhase = mix(edgePhase, 1.0, ( 1.0-clamp(0.25*camDist, 0.0, 1.0)));        \n        edgePhase = clamp(edgePhase, 0.0, 1.0);             \n\t\tedgePhase = 1.0- pow(edgePhase,2.0);\n        \n  //    p.xz += c.yz;\n  //    camDist = max(p.z-camPosition.z +1.0, 0.0)*1.4;\n  //    float cellPhase = abs(p.x+(sin(twistSpeed*p.z*0.35)*1.0+sin(twistSpeed*p.z*0.5156)*0.35+sin(twistSpeed*p.z*1.241)*0.15)*twistScale);\n  //    cellPhase -= 0.5;\n  //    cellPhase /= max(pow(camDist, 1.6), 1.0);        \n  //    cellPhase = pow(clamp(1.0-cellPhase, 0.0, 1.0), 16.0);\n  //    cellPhase *= min(0.05*camDist, 1.0);\n  //    cellPhase = pow(cellPhase, 2.0);\n        \n        return vec3(edgePhase, c.x, intersect);      \n     }\n    return vec3(0.0, 0.0, 1.0/0.0);  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec2 uv = fragCoord.xy / iResolution.y;\n    uv -= 0.5*vec2(iResolution.x/iResolution.y, 1); \n    \n    float camDist = 1.0/tan(radians(FOV*0.5));\n    \n    vec2 mouse = vec2(0.0);    \n\tif( iMouse.z>0.0 )\n        mouse = 2.0*iMouse.xy/iResolution.y-vec2(iResolution.x/iResolution.y,1);\n    vec3 camForward = vec3(0, 0, 1);\n    camForward = mat3(rotationMatrix(UP, mouse.x*-radians(90.0))) * camForward;\n\tvec3 camRight = cross(UP, camForward);\n    camRight = mat3(rotationMatrix(camForward, radians(8.0))) * camRight;\n    camForward = mat3(rotationMatrix(camRight, mouse.y*radians(90.0) + radians(-40.0))) * camForward;\n\tvec3 camUp = cross(camForward, camRight);\n    vec3 vectorToPixel = vec3(uv.xy,camDist)*NEARPLANE;\n   \tvectorToPixel = (uv.x*camRight + uv.y*camUp + camDist*camForward)*NEARPLANE;\n    vec3 camPosition = vec3(2.0,3.0,0) + vec3(0,0,-3.5*iTime);// + vec3((iMouse.xy/iResolution.xy-vec2(0.5,0.5))*1.0,0.0);\n    \n //   float rumbleSpeed = 100.0;\n //   float rumbleAmount = 0.025*(sin(rumbleSpeed*iTime*0.35)*1.0+sin(rumbleSpeed*iTime*0.37)*0.35+sin(rumbleSpeed*iTime*1.241)*0.15);\n //   camPosition += vec3(0,rumbleAmount,0);\n    \n    vec4 pixel = vec4(0,0,0,1.0/0.0);\n    \n    vec3 phase = getPlaneIntersectPhase(camPosition, vectorToPixel, -1.0);\n    pixel.rgb = vec3(phase.y);\n    pixel.rgb = mix( vec3(1.0,0.1,0.0), vec3(0.6,0.05,0.0), smoothstep( phase.x-0.025, phase.x, phase.y ) );  \n    \n    phase = getPlaneIntersectPhase(camPosition, vectorToPixel, -0.9);\n    pixel.rgb = mix( pixel.rgb, vec3(1.0), smoothstep(phase.x-0.025, phase.x, phase.y) );\n    \n    //pixel.rgb = vec3(phase.x);\n    \n    pixel.w = phase.z; \n    \n    \n    float fogStrength = clamp(pow(max(pixel.w-FOGSTART,0.0)/(MAXDEPTH-FOGSTART), 0.85), 0.0, 1.0);\n    fragColor = vec4(pixel.rgb*(1.0-fogStrength) + FOGCOLOR*fogStrength, 1.0);\n}","name":"Image","description":"","type":"image"}]}