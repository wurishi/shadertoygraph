{"ver":"0.1","info":{"id":"7ltBD7","date":"1663244146","viewed":245,"name":"particle beams","username":"pb","description":"learned a trick from three.js","likes":12,"published":1,"flags":32,"usePreview":0,"tags":["rays","icosahedron"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//philip.bertani@gmail.com\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\n    fragColor = .1*texture(iChannel0, uv) + .9*vec4 ( vec3(1.) - texture( iChannel1, uv ).rgb, 1.);\n    \n    fragColor = pow( fragColor, vec4( 6. ));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.14159265;\n#define sc  .7\n\n//hard coded icosahedron vertices for fractal generation\nconst float sqr5 = sqrt(5.);\nconst float p1 = 1./sqr5;\nconst float p2 = 2./sqr5;\nconst float p3 = sqrt( (5.+sqr5)/10. );\nconst float p4 = sqrt( (5.-sqr5)/10. );\nconst float p5 = (5.-sqr5)/10.;\nconst float p6 = (-5.-sqr5)/10.;\nconst float p7 = (5.+sqr5)/10.;\nconst float p8 = (-5.+sqr5)/10.;\n\nvec3[] d20 = vec3[] (\nvec3(1.,0.,0.),\nvec3(p1, p2, 0.),\nvec3(p1, p5, p3),\nvec3(p1, p6, p4),\nvec3(p1, p6, -p4),\nvec3(p1, p5, -p3),\nvec3(-1.,0.,0.),\nvec3(-p1, -p2, 0.),\nvec3(-p1, p8, -p3),\nvec3(-p1, p7, -p4),\nvec3(-p1, p7, p4),\nvec3(-p1, p8, p3)\n);\n\nvec3  ifs_color, center_of_hollow_sphere, center_of_earth;\nfloat ifs_scale; \nint   max_iter;\nfloat angle_time, thetaL, phiL, max_dist, sun_rnd, global_lum;\nvec3  global_light, lightpos;\n\nmat3 rot_xz( float an ) {\n    float can = cos(an);\n    float san = sin(an);\n\n    return mat3( can, 0., -san,\n                 0. , 1.,   0.,\n                 san, 0.,  can );\n\n}   \n\nvec2 de_d20(vec3 z) {\n    \n    vec3 min_vtx;\n    vec3 orig_z = z;\n    int n=0;\n    float min_dist,dist_to_vtx;\n\n    z += .5;\n    z = mod( z - .8, 1.6 ) - .8;\n\n    z = rot_xz(iTime)*z;\n\n    ifs_color = vec3(0.);\n\n    for (int i=0; i<100; i++) {\n       \n        if ( i > max_iter ) break;\n\n        min_vtx = sc*d20[0];\n        min_dist=length(z-sc*d20[0]);\n        for (int j=1; j<12; j++) {\n        \n            dist_to_vtx=length(z-sc*d20[j]); \n            if (dist_to_vtx<min_dist) {min_vtx=sc*d20[j]; min_dist=dist_to_vtx;}\n            \n        }\n        \n        z = min_vtx + ifs_scale*(z-min_vtx);  //exact same formula as for Sierpinski Triangle\n        \n        n++;\n\n    }\n\n    float dz = pow(ifs_scale, float(n) );\n    //dz is simply the constant Scale factor to the power of number of times used\n\n    float scene_dist = length(z) / dz;  \n    float objid = 0.;\n\n    return vec2( scene_dist, objid );\n}\n\n\n\nvec3 sky_color( vec3 dir, vec3 lightpos, vec3 p ) {\n  \n    vec3 skypos  = dir*max_dist - center_of_earth;\n    vec3 sky;\n\n    float ldiff = length( -lightpos - skypos ); \n\n    ldiff *= ldiff;\n\n    float sun_lum  = exp( -ldiff/1e12);\n    float sun_lum2 = exp( -ldiff/4e8);\n    float sun_lum3 = exp( -ldiff/1e10);\n    \n    global_light = vec3( sun_lum/3., sun_lum/3., 1.6*sun_lum );\n\n    float global_sun_lum = sun_lum2;\n\n    sky = vec3(sun_lum2,sun_lum2,0.);\n    sky += (1.-sun_lum)*sky + .7*global_light;\n    sky += (1.-sun_lum)*sky + vec3( sun_lum3/2., sun_lum3/3., 0.);\n\n    return  .7*sky;\n\n}\n\n\nvec3 raymarch(in vec3 from, in vec3 dir) \n{\n\n    float totdist=0.;\n    float dist;\n    vec3  p, col=vec3(0.);\n    float glow = 0.;\n    float glow_threshold = .05;\n\n    for (int i=0; i<20; i++) {\n\n        {\n            p = from + totdist*dir;\n            dist = de_d20(p).x;\n            totdist+=dist; \n\n            if (dist<glow_threshold) \n                glow += max(0.,glow_threshold-dist)* exp(-totdist*totdist/6.);\n         }\n \n    }\n\n    vec3 backg = sky_color( dir, lightpos, p );\n\n    col = backg;\n    col +=  glow * backg ;\n    col.r += glow * .4;\n    col.g += glow * .3;\n\n\n    return col; \n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ifs_scale = 1.666 + 2.5;\n    max_iter = 4;\n    max_dist = 100000.;\n    center_of_earth = vec3(0.,-1000.,0.);    \n    \n    mat3 rot;\n    vec3 movement;\n\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3( 0. );\n        \n    float  focal_point = -1.2;\n\n    rot = rot_xz(.3);\n    vec3   rd =  rot * normalize(vec3(uv,focal_point));\n\n    ro  += vec3(-.2,.5,-1.)* iTime/2.;\n\n    angle_time = 0.;\n\n    thetaL    = -angle_time;\n\n    phiL      = 0.;\n    lightpos  = max_dist * vec3(0.,0.,1.)  + center_of_earth;        \n\n    vec3 color = raymarch(ro,rd);\n \n    color = .5 + 1.7*(color - .5);\n    color = clamp(color,0.,1.);\n    \n    fragColor = vec4(color, 1.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 uv )\n{\n\n    fragColor = vec4(1.) - texture(iChannel0,uv/iResolution.xy);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// thanks three.js\n\n#define TAPS_PER_PASS 200.\n\n#define fStepSize .015 // filter step size\n\nvoid mainImage( out vec4 fragColor, in vec2 uv ) {\n\n    uv /=  iResolution.xy;\t\n    \n    vec2 delta = (vec2(.6,.5) - uv);   //hard coded light position for now\n    \n    float dist = length( delta );      //distance to light source\n\n    vec2 stepv = fStepSize * delta / dist;\n\n    float iters = dist/fStepSize;\n            \n    float col = 0.0;\n\n\n    for ( float i = 0.0; i < TAPS_PER_PASS; i += 1.0 ) {\n\n\n        col += ( i <= iters ? dot(texture( iChannel0, uv ).rgb,vec3(1.2)) : 0.0 );\n\n        uv += stepv;\n\n    }\n\t\t\n\t\n    fragColor = vec4( col/TAPS_PER_PASS );\n    \n    fragColor.a = 1.0;\n\n}","name":"Buffer C","description":"","type":"buffer"}]}