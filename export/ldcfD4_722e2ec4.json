{"ver":"0.1","info":{"id":"ldcfD4","date":"1525122380","viewed":308,"name":"VoronoiTunnel","username":"dila","description":"Classic Voronoi tunnel. Thanks to iq for his tutorials!","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat2 rot(float x) {\n    return mat2(cos(x), sin(x), -sin(x), cos(x));\n}\n\nvec2 random2( vec2 p ) {\n    /* https://thebookofshaders.com/12/ */\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvec4 voronoi(vec3 p) {\n    p.x += sin(p.z);\n    p.y += cos(p.z);\n    p = vec3(atan(p.y, abs(p.x)) / 3.141592 * 3.0, 1.0 - length(p.xy), p.z);\n    \n    float k = 6.0;\n    vec3 ip = floor(p * k);\n    vec3 fp = fract(p * k);\n    ip.y = 0.0;\n    fp.y = p.y;\n    \n    vec4 da = vec4(vec3(0.0), 1000.0);\n    vec4 db = da;\n    vec3 dc = vec3(0.0);\n    \n    for (int i = 0; i < 9; ++i) {\n        float fi = float(i);\n        vec3 o = vec3(mod(fi, 3.0), 1.0, floor(fi / 3.0)) - 1.0;\n        vec3 lp = o;\n        lp.xz = o.xz + random2(ip.xz + o.xz);\n        vec3 diff = lp - fp;\n        float dist = dot(diff,diff);\n        if (dist < da.w) {\n            db = da;\n            da = vec4(diff, dist);\n            dc = ip + diff;\n        } else if (dist < db.w) {\n            db = vec4(diff, dist);\n        }\n    }\n    \n    /* from iq */\n    float d = dot( 0.5*(da.xyz+db.xyz), normalize(db.xyz-da.xyz) );\n    \n    return vec4(dc, max(p.y, 0.25 - sqrt(d)));\n}\n\nfloat map(vec3 p) {\n    return voronoi(p).w;\n}\n\nvec3 normal(vec3 p)\n{\n\tvec3 o = vec3(0.01, 0.0, 0.0);\n    return normalize(vec3(map(p+o.xyy) - map(p-o.xyy),\n                          map(p+o.yxy) - map(p-o.yxy),\n                          map(p+o.yyx) - map(p-o.yyx)));\n}\n\nfloat trace(vec3 o, vec3 r) {\n    float t = 0.0;\n    for (int i = 0; i < 32; ++i) {\n        t += map(o + r * t) * 0.5;\n    }\n    return t;\n}\n\nvec3 tex3d(vec3 p) {\n    vec3 ta = texture(iChannel0, p.yz).xyz;\n    vec3 tb = texture(iChannel0, p.xz).xyz;\n    vec3 tc = texture(iChannel0, p.xy).xyz;\n    return (ta * ta + tb * tb + tc * tc) / 3.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 o = vec3(0.0, 0.0, iTime);\n    o.x += -sin(o.z);\n    o.y += -cos(o.z);\n    vec3 r = normalize(vec3(uv, 0.7));\n    r.xy *= rot(iTime);\n    \n    float t = trace(o, r);\n    vec3 w = o + r * t;\n    vec3 sn = normal(w);\n    float aoc = map(w + sn * 0.5);\n    vec4 vm = voronoi(w);\n\n    float f = max(dot(-r, sn), 0.0) * aoc;\n    f /= (1.0 + t * t * 0.1);\n    vec3 fc = tex3d(vm.xyz * 0.2) * f;\n    \n    fragColor = vec4(sqrt(fc), 1.0);\n}","name":"Image","description":"","type":"image"}]}