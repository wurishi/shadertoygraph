{"ver":"0.1","info":{"id":"lc3cDf","date":"1731263428","viewed":19,"name":"TpInformatiquegraphique","username":"Karima","description":"Modélisation avancée de primitives géométriques","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Ray {\n    vec3 o; // Origin\n    vec3 d; // Direction\n};\n\nstruct Val {\n    float v; // Signed distance\n    int c;   // Cost\n    vec3 color; // Couleur de l'objet\n};\n\n// Compute point on ray\nvec3 Point(Ray ray, float t) {\n    return ray.o + t * ray.d;\n}\n\n// Primitives -------------------------------------------------------------------------------\n\nVal Sphere(vec3 p, vec3 c, float r) {\n    return Val(length(p - c) - r, 1, vec3(1.0, 0.0, 0.0)); // Rouge\n}\n\nVal Ellipsoid(vec3 p, vec3 c, vec3 r) {\n    return Val(length((p - c) / r) - 1.0, 1, vec3(1.0, 1.0, 0.0)); // Vert\n}\n\nVal Box(vec3 p, vec3 c, vec3 b) {\n    vec3 d = abs(p - c) - b;\n    return Val(length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0), 1, vec3(0.0, 0.0, 1.0));\n}\n\nVal Cylinder(vec3 p, vec3 c, float r, float h) {\n    vec2 d = vec2(length(p.xz - c.xz) - r, abs(p.y - c.y) - h);\n    return Val(min(max(d.x, d.y), 0.0) + length(max(d, 0.0)), 1, vec3(0.0, 1.0, 1.0));\n}\n\nVal Capsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return Val(length(pa - ba * h) - r, 1, vec3(1.0, 0.0, 1.0));\n}\n\nVal Torus(vec3 p, vec3 c, vec2 t) {\n    vec3 q = p - c;\n    return Val(length(vec2(length(q.xz) - t.x, q.y)) - t.y, 1, vec3(1.0, 0.0, 0.0));\n}\n\nVal Plane(vec3 p, vec3 n, vec3 o) {\n    return Val(dot((p - o), n), 1, vec3(1.0, 1.0, 1.0));\n}\n\n// Fonction de bruit simple\nfloat Noise(vec2 p) {\n    return sin(p.x * 10.0) * cos(p.y * 10.0);\n}\n\n// Fonction de turbulence\nfloat Turbulence(vec2 p) {\n    float total = 0.0;\n    float frequency = 1.0;\n    float amplitude = 0.5;\n    int octaves = 5;\n\n    for (int i = 0; i < octaves; i++) {\n        total += Noise(p * frequency) * amplitude;\n        frequency *= 2.0;\n        amplitude *= 0.5;\n    }\n\n    return total;\n}\n\n// Fonction de déformation pour ajouter des bosses ou des creux\nvec3 AddBumps(vec3 p) {\n    float scale = 0.2;\n    float frequency = 5.0;\n    float noiseValue = Noise(p.xz * frequency);\n    return p + vec3(0.0, noiseValue * scale, 0.0);\n}\n\nVal Union(Val a, Val b) {\n    float d = min(a.v, b.v);\n    vec3 combinedColor = mix(a.color, b.color, smoothstep(a.v, b.v, d));\n    return Val(d, a.c + b.c + 1, combinedColor);\n}\n\n// Matrices de rotation\nmat3 Rx(float a) {\n    float sa = sin(a); float ca = cos(a);\n    return mat3(1., 0., 0., 0., ca, -sa, 0., sa, ca);\n}\n\nmat3 Ry(float a) {\n    float sa = sin(a); float ca = cos(a);\n    return mat3(ca, 0., -sa, 0., 1., 0., sa, 0., ca);\n}\n\nmat3 Rz(float a) {\n    float sa = sin(a); float ca = cos(a);\n    return mat3(ca, sa, 0., -sa, ca, 0., 0., 0., 1.);\n}\n\nmat3 Scale(vec3 s) {\n    return mat3(s.x, 0., 0., 0., s.y, 0., 0., 0., s.z);\n}\n\nvec3 Rotate(vec3 p, mat3 rotationMatrix) {\n    return rotationMatrix * p;\n}\n\nvec3 applyTranslation(vec3 pos, vec3 translation) {\n    return pos + translation;\n}\n\nRay CreateRay(vec2 m, vec2 p) {\n    float a = 3.0 * 3.14 * m.x;\n    float le = 3.5;\n    vec3 ro = vec3(37., 0., 15.);\n    ro *= Rz(a);\n    vec3 ta = vec3(0., 0., 1.);\n    vec3 w = normalize(ta - ro);\n    vec3 u = normalize(cross(w, vec3(0., 0., 1.)));\n    vec3 v = normalize(cross(u, w));\n    vec3 rd = normalize(p.x * u + p.y * v + le * w);\n    return Ray(ro, rd);\n}\n\nvec3 Deform(vec3 p) {\n    float turbulenceValue = Turbulence(p.xz * 0.1);\n    return p + normalize(p) * turbulenceValue * 0.5;\n}\n\n\nVal sdTeapot(vec3 p) {\n    // Facteur d'échelle pour augmenter la taille de la théière\n    float scaleFactor = 2.0; // Augmenter la taille de la théière\n\n    // Corps principal (sphère aplatie)\n    Val body = Ellipsoid(p, vec3(0.0), vec3(0.8, 0.6, 0.8) * scaleFactor);\n\n    // Base (cylindre)\n    Val base = Cylinder(p - vec3(0.0, -0.6, 0.0), vec3(0.0), 0.3 * scaleFactor, 0.1 * scaleFactor);\n\n    // Bec (cône)\n    vec3 spoutPos = vec3(0.9, 0.0, 0.0);\n    Val spout = Capsule(p - spoutPos, vec3(0.0), vec3(0.3, 0.0, 0.0) * scaleFactor, 0.1 * scaleFactor);\n\n    // Anse (tore)\n    vec3 handlePos = vec3(-0.7, 0.2, 0.0);\n    Val handle = Torus(p - handlePos, vec3(0.0), vec2(0.3, 0.05) * scaleFactor);\n\n    // Couvercle (sphère aplatie + cylindre)\n    vec3 lidPos = vec3(0.0, 0.6, 0.0);\n    Val lid = Union(\n        Ellipsoid(p - lidPos, vec3(0.0), vec3(0.4, 0.1, 0.4) * scaleFactor),\n        Cylinder(p - (lidPos + vec3(0.0, 0.1, 0.0)), vec3(0.0), 0.05 * scaleFactor, 0.05 * scaleFactor)\n    );\n\n    // Combiner toutes les parties\n    Val teapot = Union(Union(Union(Union(body, base), spout), handle), lid);\n    teapot.color = vec3(0.8, 0.4, 0.1); // Couleur de la théière\n    return teapot;\n}\n\nVal BoundingSphere(vec3 p, vec3 center, float radius) {\n    return Val(length(p - center) - radius, 1, vec3(1.0, 1.0, 1.0)); // Blanc pour le volume englobant\n}\n\n// Modification de la fonction object pour inclure la théière\nVal object(vec3 p) {\n    Val v;\n    Val u;\n\n    vec3 globalTranslation = vec3(2.0, 1.0, -3.0);\n    vec3 ellipsoidPos = applyTranslation(vec3(5.0, 2.0, 4.0), globalTranslation);\n    vec3 boxPos = applyTranslation(vec3(-1.0, 2.0, 4.0), globalTranslation);\n    vec3 cylinderPos = applyTranslation(vec3(-10.0, 2.0, 4.0), globalTranslation);\n    vec3 capsulePosA = vec3(-4.0, 0.0, 0.0);\n    vec3 capsulePosB = vec3(-2.0, 0.0, 0.0);\n    vec3 torusPos = applyTranslation(vec3(5.0, 2.0, 4.0), globalTranslation);\n    vec3 torus2Pos = applyTranslation(vec3(5.0, 5.0, 4.0), globalTranslation);\n    //vec3 teapotPos = applyTranslation(vec3(0.0, 2.0, 0.0), globalTranslation);\n    vec3 teapotPos = applyTranslation(vec3(0.0, 1.0, -2.0), globalTranslation);\n\n    vec3 ellipsoidRot = Rotate((p - ellipsoidPos), Ry(iTime)) + ellipsoidPos;\n    vec3 boxRot = AddBumps(Rotate((p - boxPos), Ry(iTime)) + boxPos);\n    vec3 cylinderRot = AddBumps(Rotate((p - cylinderPos), Rx(iTime)) + cylinderPos);\n    vec3 capsuleARot = Rotate((p - capsulePosA), Ry(iTime)) + capsulePosA;\n    vec3 capsuleBRot = Rotate((p - capsulePosB), Ry(iTime)) + capsulePosB;\n    vec3 torusRot = Deform(Rotate((p - torusPos), Rx(iTime)) + torusPos);\n    vec3 teapotRot = p + teapotPos; \n\n    v = Union(Ellipsoid(ellipsoidRot, ellipsoidPos, vec3(1.0, 1.5, 2.0)), \n              Box(boxRot, boxPos, vec3(1.0, 1.0, 1.0)));\n    v = Union(v, Cylinder(cylinderRot, cylinderPos, 1.0, 1.0));\n    v = Union(v, Capsule(capsuleARot, capsulePosA, capsulePosB, 1.0));\n    v = Union(v, Torus(torusRot, torusPos, vec2(3.0, 1.0)));\n    v = Union(v, Plane(p, vec3(0., 0., 1.), vec3(0.0, 0.0, -4.0)));\n    torusRot = Deform(torusRot);\n    v = Union(v, Torus(torusRot, torus2Pos, vec2(3.0, 1.0)));\n    \n    // Ajout de la théière\n    v = Union(v, sdTeapot(teapotRot));\n\n    return v;\n}\n\nconst int Steps = 100; // Réduction des étapes de ray marching\nconst float Epsilon = .01;\n\nvec3 ObjectNormal(vec3 p, out vec3 color) {\n    float h = 0.01;\n    vec3 n = vec3(\n        object(p + vec3(h, 0., 0.)).v - object(p - vec3(h, 0., 0.)).v,\n        object(p + vec3(0., h, 0.)).v - object(p - vec3(0., h, 0.)).v,\n        object(p + vec3(0., 0., h)).v - object(p - vec3(0., 0., h)).v\n    );\n    Val val = object(p);\n    color = val.color;\n    return normalize(n);\n}\n\nbool SphereTrace(Ray ray, float e, out float t, out int s, out int c) {\n    bool hit = false;\n    t = 0.0;\n    c = 0;\n    for (int i = 0; i < Steps; i++) {\n        s = i;\n        vec3 p = Point(ray, t);\n        Val val = object(p);\n        float v = val.v;\n        c += val.c;\n        if (v < 0.0) {\n            hit = true;\n            break;\n        }\n        t += max(Epsilon, v);\n        if (t > e) {\n            break;\n        }\n    }\n    return hit;\n}\n\nbool SphereTraceDirect(Ray ray, float e, out float t, out int s, out int c) {\n    bool hit = false;\n    t = 0.0;\n    c = 0;\n    for (int i = 0; i < Steps; i++) {\n        s = i;\n        vec3 p = Point(ray, t);\n        Val val = object(p);\n        float v = val.v;\n        c += val.c;\n        if (v < 0.0) {\n            hit = true;\n            break;\n        }\n        t += max(Epsilon, v);\n        if (t > e) {\n            break;\n        }\n    }\n    return hit;\n}\n\nbool SphereTraceWithBounding(Ray ray, float e, out float t, out int s, out int c) {\n    // Première étape : test d'intersection avec la sphère englobante\n    bool hit = false;\n    t = 0.0;\n    c = 0;\n    \n    // Définir les paramètres de la sphère englobante autour de l'objet complexe\n    vec3 boundingCenter = vec3(0.0, 2.0, -3.0); // Centre de la sphère englobante\n    float boundingRadius = 10.0; // Rayon de la sphère englobante\n\n    // Tester l'intersection avec la sphère englobante\n    for (int i = 0; i < Steps; i++) {\n        s = i;\n        vec3 p = Point(ray, t);\n        Val val = BoundingSphere(p, boundingCenter, boundingRadius);\n        float v = val.v;\n        c += val.c;\n        \n        // Si le rayon touche la sphère englobante, effectuer le lancer de rayon sur l'objet complexe\n        if (v < 0.0) {\n            // Deuxième étape : lancer de rayon sur l'objet complexe seulement après avoir intersecté la sphère\n            hit = SphereTraceDirect(ray, e, t, s, c);\n            break;\n        }\n        \n        t += max(Epsilon, v);\n        if (t > e) {\n            break;\n        }\n    }\n    \n    return hit;\n}\n\n\nfloat Shadow(vec3 ro, vec3 n, vec3 rd) {\n    float res = 1.0;\n    float t = 0.02;\n    float h;\n    int c;\n    for (int i = 0; i < 16; i++) {\n        Val val = object(ro + rd * t);\n        h = val.v;\n        c = val.c;\n        if (h < 0.0001) return 0.0;\n        res = min(res, 10.0 * h / t);\n        t += clamp(h, 0.01, 0.5);\n    }\n    return res;\n}\n\nfloat AmbientOcclusion(vec3 p, vec3 n) {\n    float ao = 1.0;\n    const int samples = 8; // Réduction du nombre d'échantillons\n\n    for (int i = 0; i < samples; i++) {\n        float angle = float(i) / float(samples) * 3.14;\n        vec3 mySample = normalize(n + vec3(cos(angle), sin(angle), 0.0) * 0.5);\n        ao -= Shadow(p + n * 0.1, mySample, normalize(vec3(5., 10., 25.)));\n    }\n\n    return max(ao, 0.0);\n}\n\nvec3 Shade(vec3 p, vec3 n, Ray eye) {\n    const vec3 lp = vec3(5.0, 10.0, 25.0);\n    vec3 l = normalize(lp - p);\n    vec3 v = normalize(eye.o - p);\n\n    float diff = max(dot(n, l), 0.0);\n    float s = Shadow(p, n, l);\n    float ao = AmbientOcclusion(p, n);\n\n    Val val = object(p);\n\n    return (s * (diff * val.color) + ao * vec3(0.2, 0.2, 0.2));\n}\n\nvec3 background(Ray ray) {\n    float g = dot(ray.d, vec3(0., 0., 1.));\n    return mix(vec3(1., 1., 1.), vec3(0., 0., 0.5), g * g);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    Ray ray = CreateRay(iMouse.xy / iResolution.xy, uv);\n    float t;\n    int s, c;\n    vec3 color;\n\n    bool directHit = SphereTraceDirect(ray, 100.0, t, s, c); // Lancer de rayon direct\n    bool boundingHit = SphereTraceWithBounding(ray, 100.0, t, s, c); // Lancer de rayon avec volume englobant\n\n    if (boundingHit) {\n        vec3 p = Point(ray, t);\n        vec3 n = ObjectNormal(p, color);\n        vec3 finalColor = Shade(p, n, ray);\n        fragColor = vec4(finalColor, 1.0);\n    } else {\n        fragColor = vec4(background(ray), 1.0);\n    }\n\n    // Affichage de statistiques (en option, pour comparaison des coûts entre les deux approches)\n    fragColor.rgb *= directHit ? vec3(0.0, 1.0, 1.0) : vec3(1.0, 1.0, 1.0); // Affiche en rouge pour direct et vert pour bounding\n}","name":"Image","description":"","type":"image"}]}