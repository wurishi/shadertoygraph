{"ver":"0.1","info":{"id":"XscyRs","date":"1519758848","viewed":5524,"name":"bouncy boi on the run","username":"stellabialek","description":"subsurface stuff and lots of sillyness","likes":76,"published":1,"flags":0,"usePreview":1,"tags":["subsurfacescattering","sss","spheretracing","reflections","weird"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.1415926535897932384626433832795;\nconst float TWOPI = 2.0 * PI;\nconst float EPSILON = 0.0001;\n\nconst float MAXDIST = 20.0;\n\nconst int m_boi = 0;\nconst int m_eyes = 1;\nconst int m_world = 2;\nconst int m_ghost = 3;\n\nvec3 bg = vec3(0.3, 0.3, 0.2);\n\nstruct ray\n{\n\tvec3 o; //origin\n\tvec3 d;\t//direction\n};\n\nstruct result\n{\n\tfloat t;\n\tvec2 uv;\n\tvec3 p;\n\tvec3 n;\n\tint mID;\n};\n\nstruct material \n{\n\tvec3 diffuse;\n\tvec3 shadow;\n\tfloat sss;\n\tfloat refl;\n};\n\nresult compare(result a, result b)\n{\n    if(a.t < b.t)\n        return a;\n    return b;\n}\n\nfloat rand(float seed)\n{\n\treturn fract(sin(seed) * 1231534.9);\n}\n\nfloat rand(vec2 seed) \n{ \n    return rand(dot(seed, vec2(12.9898, 783.233)));\n}\n\nfloat distSphere(vec3 p, float r)\n{\n\treturn length(p) - r;\n}\n\nfloat opU(float a, float b)\n{\n\treturn min(a, b);\n}\n\nfloat opU2(float a, float b, float k)\n{\n\tfloat h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat opD(float a, float b)\n{\n\treturn max(a, -b);\n}\n\nvec3 opR(vec3 p, vec3 r)\n{\n\treturn mod(p, r)-0.5*r;\n}\n\nvec3 rotateX(vec3 p, float angle)\n{\n\tmat3 r = mat3(1, 0, 0,\n\t\t\t\t\t0, cos(angle), -sin(angle),\n\t\t\t\t\t0, sin(angle), cos(angle));\n\treturn r * p;\n}\n\nvec3 rotateY(vec3 p, float angle)\n{\n\tmat3 r = mat3(cos(angle), 0, sin(angle),\n\t\t\t\t0, 1, 0,\n\t\t\t\t-sin(angle),0 , cos(angle));\n\treturn r * p;\n}\n\nvec3 rotateZ(vec3 p, float angle)\n{\n\tmat3 r = mat3(cos(angle), -sin(angle), 0,\n\t\t\t\tsin(angle), cos(angle), 0,\n\t\t\t\t0, 0, 1);\n\treturn r * p;\n}\n\nvec2 getUVSphere(vec3 p)\n{\n\tp = normalize(p);\n\tfloat x = atan(p.z, p.x) / TWOPI;\n\tfloat y = asin(p.y) / PI;\n\t\n\treturn vec2(0.5) + vec2(x,y);\n}\n\nvec3 getLightPos(float t)\n{\n\treturn vec3(-2.0*sin(t), 0.3+sin(t*4.0)*0.2, 5.0 + 2.0 * cos(t));\n}\n \nresult bouncyBoi(vec3 p, float t)\n{\n\tresult res;\t\n\tres.mID = m_boi;\n\n\tp.y -= abs(sin(t * 4.0)) * 0.4;\t\n\tp.x -= sin(t * 2.0) * 0.2;\n\tp.z -= 5.0;\n\tp = rotateY(p, sin(t * 4.0) * PI * 0.2);\t\t\n\tp = rotateZ(p, smoothstep(-.6, 0.4, p.y) * PI * 0.1 * sin(t * 4.0));\n\t\t\t\n\tvec3 op = p;\n\t\n\t//body\n\tp = op;\n\tp.y += smoothstep(0.15, 2.5, abs(op.x));\n\tp.y *= 0.8;\n\tp.z += (1.0 - smoothstep(0.0, 1.2, abs(op.y - 0.1))) * 0.4 * max(0.0, op.z);\n\tp.xz *= (1.0 + opU2(0.0, p.y, 0.2) * 0.2 * pow((1.0 - abs(sin(t * 4.0))), 2.0));\n\tres.t = distSphere(p, 1.0);\n\t\t\n\t//arms\n\tp = op;\n\tp.x *= 0.13;\n\tp.y += sin((p.x) * 2.0 + t * 8.0) * 0.2 * smoothstep(0.8, 2.0, abs(op.x));\n\tres.t = opU2(res.t, distSphere(p, 0.2), 0.2);\n\t\t\n\t//mouth\n\tp = op;\n\tp -= vec3(0.0, 0.45, -1.0);\n\tp *= vec3(1.0, ((sin(t  * 8.0) + 1.0) * 0.5) * 0.5 + 0.5, 0.8);\n\tres.t = opD(res.t, distSphere(p, 0.1));\n\t\t\n\t//right eye\n\tp = op;\n\tp -= vec3(0.25, 0.6, -0.7);\n\tp = rotateY(p, -PI/16.0 + sin(t*6.0)*PI/16.0);\n\tp = rotateX(p, PI/2.0 + sin(t*6.0)*PI/16.0);\n\tresult resEyeR;\n\tresEyeR.t = distSphere(p, 0.2);\n\tresEyeR.mID = m_eyes;\n\tresEyeR.uv = getUVSphere(p);\n\t\n\t//left eye\n\tp = op;\n\tp -= vec3(-0.25, 0.6, -0.7);\n\tp = rotateY(p, PI/16.0 - sin(t*6.0)*PI/16.0);\n\tp = rotateX(p, PI/2.0 - sin(t*6.0)*PI/16.0);\t\t\n\tresult resEyeL;\n\tresEyeL.t = distSphere(p, 0.2);\n\tresEyeL.mID = m_eyes;\n\tresEyeL.uv = getUVSphere(p);\n\t\n\tres = compare(res, resEyeR);\n\tres = compare(res, resEyeL);\n\treturn res;\n}\n\nfloat angle(vec2 a, vec2 b)\n{\n\ta = normalize(a);\n\tb = normalize(b);\n\tfloat c = dot(a,b);\n\tfloat s = a.x*b.y - b.x*a.y;\n\treturn atan(s,c);\n}\n  \nresult ghost(vec3 p, float t)\n{\n\tresult res;\n\tres.mID = m_ghost;\n\t\n\tvec3 lPos = getLightPos(t);\n\tp -= lPos;\n\tfloat rY = angle(lPos.xz - vec2(0.0,5.0), vec2(-1.0, 0.0));\n\tfloat rX = sin(t * 4.0) * PI / 16.0;\n\tp = rotateY(p, rY);\n\tp = rotateX(p, rX);\n\t\n\tvec3 op = p;\n\t\n\t//body\n\tp = rotateX(p, p.y*10.0*(1.0 + 0.2*sin(t*8.0)));\n\tp.y += mix(0.0, 0.2, 1.0 - smoothstep(-0.6, 0.0, p.y));\t\t\n\tres.t = distSphere(p, 0.16);\n\n\t//arms\n\tp = op;\n\tp = rotateZ(p, p.x*sin(t*4.0)*2.0);\n\tp.y += 0.04;\n\tp.x *= 0.6;\n\tp.zy *= 8.0;\t\t\n\tres.t = opU2(res.t, distSphere(p,0.1), 0.2);\n\t\n\t//eyes\n\tp = op;\n\tp += vec3(0.07,-0.06,0.1);\n\tres.t = opD(res.t, distSphere(p, 0.06));\t\n\tp.x -= 0.14;\n\tres.t = opD(res.t, distSphere(p, 0.06));\n\n\treturn res;\n}\n\nresult world(vec3 p, float t)\n{\n\tresult res;\n\tres.mID = m_world;\n\t\n\t//floor deformations\n\tp.z -= t * 1.4;\n\tp = rotateZ(p, p.x*0.1);\n\tp.y += sin(p.x/2.0)*sin(p.z/2.0)*0.4;\n\tp.y += sin(p.x)*sin(p.z)*0.2;\n\tp.y += sin(p.x*2.0)*sin(p.z*2.0)*0.1;\n\tp.y += sin(p.x*6.0)*sin(p.z*6.0)*0.01;\n\tres.t = p.y + 1.0;\n\t\n\t//lumps\n\tvec3 rep = vec3(3.0, 0.0, 2.0);\n\tvec2 id = floor(p/rep).xz;\n\tp = mod(p,rep)-rep*0.5;\n\tp.y += mix(0.6, 1.0,rand(id));\n\tp.x += rand(id.y)-0.5;\n\tp.z += rand(id.x)-0.5;\n\tres.t = opU2(res.t, distSphere(p, mix(0.2, 0.3, rand(id))), 0.6);\n\t\n\treturn res;\n}\n\nresult distanceField(vec3 p, float t)\n{\n\tresult res;\n\tres = bouncyBoi(p,t);\n\tres = compare(res, ghost(p,t));\n\tres = compare(res, world(p,t));\n\treturn res;\n}\n\n//shadow casters only\nresult distanceFieldShadow(vec3 p, float t)\n{\n\tresult res;\n\tres = bouncyBoi(p,t);\n\tres = compare(res, world(p,t));\n\treturn res;\n}\n  \nvec3 getNormal(vec3 p, float t)\n{\n\tvec2 d = vec2(0.01, 0.0);\n\tfloat dx = distanceField(p + d.xyy,t).t\n\t\t\t\t- distanceField(p - d.xyy,t).t;\n\tfloat dy = distanceField(p + d.yxy,t).t\n\t\t\t\t- distanceField(p - d.yxy,t).t;\n\tfloat dz = distanceField(p + d.yyx,t).t\n\t\t\t\t- distanceField(p - d.yyx,t).t;\n\treturn normalize(vec3(dx, dy, dz));\n}\n\nfloat SSS(vec3 p, vec3 l, vec3 n, float t, float delta)\n{\n\tconst int samples = 6;\n\tfloat sss = 0.0;\n\tfloat lDist = length(l);\n\tl = normalize(l);\n\tfor(int i = 1; i <= samples; i++)\n\t{\n\t\tfloat i_f = float(i);\n\t\tfloat dist = rand(i_f) * delta;\n\t\tvec3 offset = vec3(rand(i_f),rand(i_f+1.0),rand(i_f+2.0));\n\t\toffset = normalize(offset - vec3(0.5));\n\t\tvec3 dir = normalize(l + offset*0.3);\n\t\tfloat d = distanceField(p + dir * dist, t).t;\n\t\tfloat s = max(dist+d, 1.0 - (lDist - dist)/lDist);\n\t\ts /=  pow(1.0 + (delta/dist)*0.4, 2.0);\n\t\tsss += s;\n\t}\n\tsss /= float(samples);\n\tsss = smoothstep(0.0, 0.4, sss);\n\treturn sss;\n}\n\nresult trace(ray r, float time)\n{\t\t\n\tresult res;\n\tfloat t = 0.0;\n\tvec3 p;\n\twhile(t <= MAXDIST)\n\t{\n\t\tp = r.o + r.d * t;\n\t\tres = distanceField(p, time);\t\t\n\t\tif(res.t <= EPSILON) break;\t\n\t\t//don't use full distance because artifacts\n\t\tt += max(res.t*0.6, t * 0.0001);\n\t}\t\n\tres.t = t;\n\tres.p = p;\n\tres.n = getNormal(p, time);\n\treturn res;\n}\n\nfloat shadow(result res, float time, float k)\n{\n\tray r;\n\tr.o = res.p + res.n * 0.01;\n\tvec3 l = getLightPos(time) - r.o;\n\tr.d = normalize(l);\n\tfloat maxDist = length(l);\n\n\tfloat s = 1.0;\n\tfloat t = 0.0;\n\twhile(t <= maxDist)\n\t{\n\t\tvec3 p = r.o + r.d * t;\n\t\tfloat d = distanceFieldShadow(p, time).t;\t\t\n\t\tif(d <= EPSILON) break;\n\t\ts = min(s, d*k / t);\n\t\tt += max(d, t * 0.0001);\n\t}\t\n\treturn min(s, t < maxDist ? 0.0 : 1.0);\n}\n\nmaterial getMaterial(result res)\n{\n\tmaterial m;\n\tswitch(res.mID)\n\t{\n\t\tcase(m_boi):\n\t\t\tm.diffuse = vec3(1.0, 0.6, 0.4);\n\t\t\tm.shadow = vec3(0.4, 0.1, 0.0);\n\t\t\tm.sss = 1.0;\n\t\t\tm.refl = 0.4;\n\t\tbreak;\n\t\tcase(m_eyes):\n\t\t\tm.diffuse = vec3(1.0, 1.0, 0.8);\n\t\t\tm.diffuse *= smoothstep(0.02,0.05, res.uv.y);\n\t\t\tm.shadow = vec3(0.4, 0.1, 0.1);\n\t\t\tm.sss = 1.0;\n\t\t\tm.refl = 0.6;\n\t\tbreak;\n\t\tcase(m_world):\n\t\t\tm.diffuse = vec3(1.0, 0.6, 0.4);\n\t\t\tm.shadow = vec3(0.4, 0.1, 0.0);\n\t\t\tm.sss = 1.0;\n\t\t\tm.refl = 0.2;\n\t\tbreak;\n\t\tcase(m_ghost):\n\t\t\tm.diffuse = vec3(1.4, 1.3, 1.0);\n\t\t\tm.shadow = vec3(0.6, 0.5, 0.4);\n\t\t\tm.sss = 0.2;\n\t\t\tm.refl = 0.5;\n\t\tbreak;\n\t}\n\treturn m;\n}\n\nvec3 getColor(result res, float time)\n{\n\tvec3 color = bg;\n\tif(res.t <= MAXDIST)\n\t{\n\t\tmaterial m = getMaterial(res);\n\t\tcolor = m.diffuse;\n\t\t\n\t\tvec3 l = getLightPos(time) - res.p;\t\t\t\n\t\tfloat ndl = max(0.0, dot(normalize(l),res.n));\n\t\tfloat i = max(0.0, ndl);\n\t\ti *= shadow(res, time, 16.0);\n\t\tfloat sss = SSS(res.p, l, res.n, time, m.sss);\n\t\ti = mix(i, sss, (-ndl+1.0)/2.0);\n\t\ti *= 1.0 - smoothstep(4.0, 8.0, length(l));\n\t\tcolor = mix(color * m.shadow, color, i);\t\n\t}\n\treturn color;\n} \n\nvec3 reflection(ray r, result res, float time)\n{\n\tr.o = res.p + res.n * 0.01;\n\tr.d = reflect(r.d, res.n);\n\tres = trace(r, time);\n\treturn getColor(res,time);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tfloat time = iTime;\t\t\n\tvec4 color = vec4(0.0);    \n\t\t\n\tfloat camRotY = PI * 0.1 * sin(time * 0.5);\n\tfloat camRotX = -PI *(0.01 + 0.03 *(sin(time * 0.2)+1.0));\n\t\n\tray r;\n\tr.o = vec3(0.0,0.0,-5.0);\n\tr.o = rotateX(r.o, camRotX);\n\tr.o = rotateY(r.o, camRotY);\n\tr.o.z += 5.0;\n\tr.o.y += 0.2;\n\tfloat fx = tan(radians(70.0) / 2.0) / iResolution.x;\n\tvec2 d = fx * (fragCoord.xy * 2.0 - iResolution.xy);\n\tr.d = normalize(vec3(d, 1.0));\n\tr.d = rotateX(r.d, camRotX);\n\tr.d = rotateY(r.d, camRotY);\n\t\t\n\tresult res = trace(r, time);\n\tcolor.rgb = getColor(res,time);\t\n\tif(res.t <= MAXDIST)\n\t{\t\n\t\tfloat fresnel = pow(1.0 + dot(r.d,res.n),2.0);\n\t\tfresnel = clamp(fresnel, 0.0, 1.0);\n\t\n\t\tmaterial mat = getMaterial(res);\n\t\tcolor.rgb *= (1.0 - mat.refl * fresnel);\n\t\n\t\tvec3 reflectedColor = reflection(r, res,time);\n\t\tcolor.rgb += reflectedColor * mat.refl * fresnel;\t\n\t}\n\tfloat fog = smoothstep(MAXDIST * 0.5, MAXDIST,res.t);\n\tcolor.rgb = mix(color.rgb, bg, fog);\n\t\n\tvec3 l = getLightPos(time)-r.o;\n\tfloat halo = dot(normalize(l),r.d);\n\thalo *= max(0.0, sign(res.t - length(l)));\n\thalo = smoothstep(0.99, 0.999, halo);\n\tcolor.rgb += halo * vec3(0.2, 0.2, 0.1);\n\tfragColor = color;\n}","name":"Image","description":"","type":"image"}]}