{"ver":"0.1","info":{"id":"NljyRz","date":"1649069145","viewed":156,"name":"Random Cylinders Generator","username":"Kamoshika","description":"Click mouse to clear the screen.","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["cylinder","cylinders"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Click mouse to clear the screen.\n\n//#define AA 5\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    /*\n    for(int m = 0; m < AA; m++) {\n        for(int n = 0; n < AA; n++) {\n            vec2 of = vec2(m, n) / float(AA) - 0.5;\n            col += texture(iChannel0, (fragCoord + of) / iResolution.xy).rgb;\n        }\n    }\n    col /= float(AA * AA);\n    */\n    \n    col += texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    \n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define hash(x) fract(sin(x) * 43758.5453)\n\nconst float PI = acos(-1.);\nconst float PI2 = acos(-1.) * 2.;\n\nconst float z_coeff = 50.; // Coefficient for storing data in z-buffer.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float frame = float(iFrame);\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    vec3 ro = vec3(0, 0, 0.6); // Ray origin.\n    vec3 rd = normalize(vec3(uv, -2)); // Ray direction.\n    \n    // Cylinder parameters.\n    vec3 cb = hash(frame * vec3(1, 1.1, 1.2)) - 0.5; // Base point.\n    float theta = hash(frame * 1.3) * PI;\n    float phi = hash(frame * 1.4) * PI2;\n    vec3 ca = vec3(sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta)); // Axis.\n    float cr = (0.1 + hash(frame * 1.5)) / 200.; // Radius.\n    \n    // https://iquilezles.org/articles/intersectors\n    vec3 oc = ro - cb;\n    float card = dot(ca, rd);\n    float caoc = dot(ca, oc);\n    float a = 1. - card * card;\n    float b = dot(oc, rd) - caoc * card;\n    float c = dot(oc, oc) - caoc * caoc - cr * cr;\n    float h = b * b - a * c;\n    float d = (-b - sqrt(h)) / a; // Ray length.\n    \n    vec4 buffer = texture(iChannel0, fragCoord/iResolution.xy);\n    float d_min = sqrt(-log(buffer.a) / z_coeff);\n    \n    if(h > 0. && d > 0. && d < d_min) { // Update color and z-buffer.\n        vec3 tmp = ro + d * rd - cb;\n        vec3 normal = normalize(tmp - dot(tmp, ca) * ca);\n        vec3 ld = normalize(vec3(-1, 2, 5)); // Light Direction.\n        float diff = max(dot(normal, ld), 0.);\n        float spec = pow(max(dot(reflect(ld, normal), rd), 0.), 20.);\n        vec3 rim = pow(1. + min(dot(normal, rd), 0.), 2.) * vec3(1, 0.2, 1.5);\n        \n        float m = 0.9;\n        float lp = 10.;\n        buffer.rgb = exp(-d * d * 5.) * (diff * (1. - m) * lp + spec * m * lp + rim); // Lighting.\n        buffer.rgb = pow(buffer.rgb, vec3(1. / 2.2)); // Gamma correction.\n        \n        buffer.a = exp(-d * d * z_coeff);\n    }\n    \n    if(iMouse.z > 0.0) {\n        buffer = vec4(0); // Clear the screen.\n    }\n    \n    fragColor = buffer;\n}","name":"Buffer A","description":"","type":"buffer"}]}