{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"#define PI 3.14159265\n#define TWO_PI 6.2831853\n\nvec2 rotate( const in vec2 vPos, const in float fAngle )\n{\n    float s = sin(fAngle);\n    float c = cos(fAngle);\n\n    vec2 vResult = vec2( c * vPos.x + s * vPos.y, -s * vPos.x + c * vPos.y);\n\n    return vResult;\n}\n\nvec3 orangegrad(float d)\n{\n    return mix(mix(vec3(0.3, 0.0, 0.1), vec3(2.0, 0.7, 0.1), d), vec3(5.0, 5.0, 0.0), d * 0.1);\n}\n\nvec2 RadialDistort(vec2 uv ,vec2 centre, float radius, float amount, float r)\n{\n    vec2 lpos = uv - centre;\n    float dist = length(lpos);\n    float dx = dist / radius;\n    vec2 ret = rotate(lpos, r + (dx * amount));\n    return ret + centre;\n}\n\nfloat CircularGradient(vec2 pos, vec2 centre, float radius)\n{\n    float dist = length(pos - centre);\n    float dx = dist / radius;\n  \n    return dx;\n}\n\nfloat easeInOutCubic(float t) \n{\n\tif ((t/=0.5) < 1.0) return 0.5*t*t*t;\n\treturn 0.5*((t-=2.0)*t*t + 2.0);\n}\n\n\nfloat CircularGradientSineSeg(vec2 pos, vec2 centre, float radius, float segments)\n{\n    vec2 vec = (pos - centre);\n    float dist = length(vec);\n    vec2 norm = vec / dist;\n    float segment = max(0.0, sin(atan(-norm.y, norm.x) * segments));\n    float dx = 1.0 - (dist / radius);\n  \n    return dx * segment;\n}\n\n\nfloat SelectSegment(const in vec2 vPos, const in float segcount)\n{\n\t\n\tvec2 vNorm = normalize(vPos);\n\tfloat atn = (atan(vNorm.y, vNorm.x) + PI)/  TWO_PI;\n\tfloat segment = floor(atn * segcount);\n\tfloat half_segment = 0.5 / segcount;\n\tfloat seg_norm = mod((segment / segcount) + 0.25 + half_segment, 1.0);\n\t\n\treturn seg_norm * TWO_PI;//turn it back in to rotation\n}\n\nfloat fade2(float t)\n{\n\treturn t*t*(3.0-2.0*t);\n}\n \n\n\nfloat StarShape(vec2 pos, vec2 centre, float centrerad, float radius, float segments)\n{\n    vec2 vec = (pos - centre);\n    float dist = length(vec);\n    float angle = atan(-vec.y, vec.x);\n    float seg_angle_size = TWO_PI / segments;\n    float half_seg_seg_angle_size = seg_angle_size * 0.5;\n    float seg_arc_length = seg_angle_size * centrerad;\n    \n    float r =  SelectSegment(vec, segments);\t\t\n\tvec2 dpos = rotate(vec, r );        \n    float ld = 1.0 - (dist - centrerad) / (radius - centrerad);\n    float w = mod(angle, seg_angle_size);\n    float d = abs(dpos.x * 1.1);\n   \n    float width_at = (seg_arc_length * ld);\n    return cos((width_at-d) / seg_arc_length) * ld ;\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float ar = iResolution.x / iResolution.y;\n    uv.x = (uv.x * ar) - 0.5;\n    vec2 centre  = vec2(0.4, 0.5);\n    float radius = 0.5;\n    float amount = sin(iTime)*5.0;\n    float r = iTime * 0.5;\n    uv = RadialDistort(uv, centre, radius, amount, r);\n    \n    \n    float p = StarShape(uv, centre, 0.325, 0.9, 4.0);\n  \n    fragColor = vec4(orangegrad(p), 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4sjXzW","date":"1409664269","viewed":1478,"name":"HypnoWorm","username":"Luther","description":"On the way to making something else, I ended up with this thing.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["spinninghappyaccident"],"hasliked":0,"parentid":"","parentname":""}}