{"ver":"0.1","info":{"id":"ms3fWB","date":"1697580766","viewed":58,"name":"2.5D SDF","username":"slime_horse","description":"faking 3D SDFs from 2D SDFs using circular interpolated normals (or whatever maths people would call it)\n\n\n\nwho needs raymarching anyways :D","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sdf","25d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nfloat cirp (float d) {\n    return sqrt(1. - pow(d, 2.));\n}\n\nfloat lerp(float v0, float v1, float t) {\n    return v0 * (1. - t) + v1 * t;\n}\n\nfloat inverse_lerp(float min, float max, float value) {\n    return (value - min) / (max - min);\n}\n\nfloat remap(float a_min, float a_max, float b_min, float b_max, float a_value) {\n    return lerp(\n        b_min, b_max,\n        inverse_lerp(a_min, a_max, a_value)\n    );\n}\n\nfloat cirp (float d, float r) {\n    return sqrt(pow(r, 2.) - pow(d, 2.));\n}\n\nfloat cirp_curve(float d, float r) {\n    return  d /2. + (r/2.);\n} \n\nvec2 sdfDistanceCircleInterpolationRemap(float d, float r) {\n    float md = remap(0., 0. - r, -1., 0., d);\n    float depth = cirp(md, 1.0);\n    float curvature = cirp_curve(depth, r);\n    return vec2(depth, curvature);\n}\n\nvec2 sdfGradientCircleInterpolationRemap(float d, float r) {\n    float md = remap(0., 1., -1., 0., d);\n    float depth = cirp(md, 1.0);\n    float curvature = cirp_curve(depth, r);\n    return vec2(depth, curvature);\n}\n\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdHexagram( in vec2 p, in float r )\n{\n    const vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= 2.0*min(dot(k.yx,p),0.0)*k.yx;\n    p -= vec2(clamp(p.x,r*k.z,r*k.w),r);\n    return length(p)*sign(p.y);\n}\n\nfloat sdRoundedX( in vec2 p, in float w, in float r )\n{\n    p = abs(p);\n    return length(p-min(p.x+p.y,w)*0.5) - r;\n}\n\nvec3 calcNorms(vec3 pos){\n    float x = mix(pos.x, 0., pos.z);\n    float y = mix(pos.y, 0., pos.z);\n    float voidz = mix(1., 0., mix(pos.x, pos.y, 0.5));\n    float z = mix(1., 0., voidz);\n    return pos;\n    return vec3(x, y, z);\n}\n\nvec3 render (vec2 p) {\n    vec3 col = vec3(0.0);\n    float ra = 0.75;\n\n    \n\tfloat x_wi = 0.5 + 0.30 * sin(iTime * 0.5);\n    float x_ra = 0.5;//0.1 + 0.70 * cos(iTime * 1.1);\n\n    float sdf_circle = sdCircle(p, ra);\n    float sdf_hex = sdHexagram(p, 0.15);\n\tfloat sdf_x = sdRoundedX(p, x_wi, x_ra) ;\n    \n    float sdf = opSmoothUnion(sdf_circle, sdf_x, 0.1);\n    \n    \n    float dgt = sdfDistanceCircleInterpolationRemap(sdf, ra).x;\n    \n    vec3 ro = vec3(p ,0.);\n\n    vec3 pos = ro + dgt;\n    vec3 norm = calcNorms(vec3(pos.xy, dgt));\n         norm = calcNorms(vec3(pos.xy, dgt));\n    \n\t// coloring\n    //col = norm;\n    \n    // Rendering\n    vec3 incident = vec3(0.5, 0.0, 0.0);\n    vec3 normal = norm / 6.;\n    //normal = simpleRotation(normal, iTime * 1.0);\n    incident = simpleRotation(incident, iTime * 1.0);\n    vec3 reflectedIncident = reflect(incident, normal);\n    \n    vec3 diffuse = vec3(0.9, 0.9, 0.5);\n    vec3 sun = vec3(1.0, .7, .65) * 1.5;\n    vec3 ambient = vec3(.2, .3, .6) * 0.35;\n    vec3 floorColor = vec3(0.1);\n    \n    float lighting = max(0.0, dot(normal, sunDirection));\n    float lightingHalfLambert = dot(normal, sunDirection) * .5 + .5;\n    float ambientLighting = dot(normal, up) * .5 + .5;\n    float floorAmbientLighting = dot(normal, -up) * .5 + .5;\n    \n    float fres = fresnelSchlicks(incident, normal, ior);\n    \n    float highlight = specularHighlight(reflectedIncident, sunDirection, 32.0, 32.0);\n    \n    col = (diffuse * (\n            (floorColor * sun * floorAmbientLighting * sunStrength * floorAmbientStrength) + // fake bounce lighting from an imaginary floor\n            (ambient * ambientLighting * ambientStrength) +  // ambientlight coming from the top\n            (sun * lighting * sunStrength) +// sun\n            (sun * lightingHalfLambert * halfLambertStrength * sunStrength) // some fake GI approx used by Valve\n           )) + \n            // reflections for dielectrics should not be tinted by the diffuse color\n            (ambient * fres) +  // reflection\n            // same goes for highlights because they are techically reflections\n            (sun * highlight * fres * sunStrength); // specular highlights\n            \n        \n        \n\n    \n    \n    if (p.x <= -1. || p.x >= 1. || p.y <= -1. || p.y >= 1.) {\n        col = vec3(0.2);\n    }\n    \n    //return normal;\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    int AA = 2;\n    float AADiv = float(AA*AA);\n    \n    \n    vec2 aa_coord = fragCoord * float(AA);\n    vec2 aa_resolution = iResolution.xy * float(AA);\n    vec3 color = vec3(0.);\n    \n    \n    for( int iaax=0; iaax<AA; iaax++ ){ \n        for( int iaay=0; iaay<AA; iaay++ ){\n             vec2 aa_offset = vec2(float(iaax), float(iaay));\n             vec2 p = (2.0 * (aa_coord + aa_offset) - aa_resolution) / aa_resolution.y;\n             color += render(p);\n         }\n    }\n\n    color /= AADiv;\n    \n    //color = agx(color);\n    //color = agxLook(color);\n    //color = agxEotf(color);\n\t\n\t\n    fragColor = vec4(color,1.0);\n    //fragColor = fromLinear(fragColor);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float opUnion( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat opSubtraction( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat opIntersection( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = max(k-abs(d1-d2),0.0);\n    return min(d1, d2) - h*h*0.25/k;\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k )\n{\n    return -opSmoothUnion(d1,-d2,k);\n    \n    //float h = max(k-abs(-d1-d2),0.0);\n    //return max(-d1, d2) + h*h*0.25/k;\n}\n\nfloat opSmoothIntersection( float d1, float d2, float k )\n{\n    return -opSmoothUnion(-d1,-d2,k);\n\n    //float h = max(k-abs(d1-d2),0.0);\n    //return max(d1, d2) + h*h*0.25/k;\n}\n\nvec3 simpleRotation(vec3 v, float rot)\n{\n    vec3 rotated = vec3(\n        v.x * cos(rot) - v.y * sin(rot),\n        v.x * sin(rot) + v.y * cos(rot),\n        v.z\n    );\n    return rotated;\n}\n\nfloat dot2(vec2 v)\n{\n    return dot(v, v);\n}\n\n\nfloat fresnelSchlicks(vec3 incident, vec3 normal, float ior)\n{\n    float f0 = (ior - 1.0) / (ior + 1.0);\n    f0 *= f0;\n    return f0 + (1.0 - f0) * pow(1.0 - dot(normalize(incident), normalize(normal)), 2.0);\n}\n\n// stylized specular highlights\nfloat specularHighlight(vec3 reflected, vec3 sunDirection, float size, float strength)\n{\n    float bigOne = pow(max(0.0, dot(reflected, -sunDirection)), size * 0.5) * strength * 0.2;\n    float smallOne = pow(max(0.0, dot(reflected, -sunDirection)), size * 4.0) * strength;\n    return bigOne + smallOne;\n}\n\nconst float ambientStrength = 1.0;\nconst float sunStrength = 1.0;\n\nconst float floorAmbientStrength = 0.5;\nconst float halfLambertStrength = 0.2;\n\nconst float ior = 1.5;\n\nconst float exposure = 5.0;\nconst vec3 up = vec3(0.0, 0.0, 1.0);\nconst vec3 sunDirection = normalize(vec3(1.0));\n\n\n\n\nvec3 agxDefaultContrastApprox(vec3 x) {\n  vec3 x2 = x * x;\n  vec3 x4 = x2 * x2;\n  \n  return + 15.5     * x4 * x2\n         - 40.14    * x4 * x\n         + 31.96    * x4\n         - 6.868    * x2 * x\n         + 0.4298   * x2\n         + 0.1191   * x\n         - 0.00232;\n}\n\nvec3 agx(vec3 val) {\n  const mat3 agx_mat = mat3(\n    0.842479062253094, 0.0423282422610123, 0.0423756549057051,\n    0.0784335999999992,  0.878468636469772,  0.0784336,\n    0.0792237451477643, 0.0791661274605434, 0.879142973793104);\n    \n  const float min_ev = -12.47393f;\n  const float max_ev = 4.026069f;\n\n  // Input transform\n  val = agx_mat * val;\n  \n  // Log2 space encoding\n  val = clamp(log2(val), min_ev, max_ev);\n  val = (val - min_ev) / (max_ev - min_ev);\n  \n  // Apply sigmoid function approximation\n  val = agxDefaultContrastApprox(val);\n\n  return val;\n}\n\nvec3 agxEotf(vec3 val) {\n  const mat3 agx_mat_inv = mat3(\n    1.19687900512017, -0.0528968517574562, -0.0529716355144438,\n    -0.0980208811401368, 1.15190312990417, -0.0980434501171241,\n    -0.0990297440797205, -0.0989611768448433, 1.15107367264116);\n    \n  // Undo input transform\n  val = agx_mat_inv * val;\n  \n  // sRGB IEC 61966-2-1 2.2 Exponent Reference EOTF Display\n  //val = pow(val, vec3(2.2));\n\n  return val;\n}\n\nvec3 agxLook(vec3 val) {\n  const vec3 lw = vec3(0.2126, 0.7152, 0.0722);\n  float luma = dot(val, lw);\n  \n  // Default\n  vec3 offset = vec3(0.0);\n  vec3 slope = vec3(1.0);\n  vec3 power = vec3(1.0);\n  float sat = 1.0;\n \n  // Punchy\n  slope = vec3(1.0);\n  power = vec3(1.35, 1.35, 1.35);\n  sat = 1.4;\n  \n  // ASC CDL\n  val = pow(val * slope + offset, power);\n  return luma + sat * (val - luma);\n}\n\nvec4 fromLinear(vec4 linearRGB) {\n  bvec4 cutoff = lessThan(linearRGB, vec4(0.0031308));\n  vec4 higher = vec4(1.055)*pow(linearRGB, vec4(1.0/2.4)) - vec4(0.055);\n  vec4 lower = linearRGB * vec4(12.92);\n\n  return mix(higher, lower, cutoff);\n}","name":"Common","description":"","type":"common"}]}