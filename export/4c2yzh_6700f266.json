{"ver":"0.1","info":{"id":"4c2yzh","date":"1721956250","viewed":39,"name":"Occluded Point Lights","username":"dansh0","description":"Demo of occluding point lights with a series of lines\nLights and wall segments are stored in buffers\n\nDrag mouse to move one of the bigger lights","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["lighting","occlusion","radiance"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Demo of lights and walls\n// Buffer A has light data (x, y, radius, color)\n// Buffer B has wall data (x1, y1, x2, y2)\n// Lights are tested against walls for intersections\n// Non-occluded lights are drawn over background texture\n// Walls are drawn on top\n\n// CONTROL:\n// Mouse moves one of the lights\n\nvec3 hueToRGB(float hue) {\n    float r = abs(hue * 6.0 - 3.0) - 1.0;\n    float g = 2.0 - abs(hue * 6.0 - 2.0);\n    float b = 2.0 - abs(hue * 6.0 - 4.0);\n    return clamp(vec3(r, g, b), 0.0, 1.0);\n}\n\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    // From IQ - https://www.shadertoy.com/view/3tdSDj\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h =clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length(pa-h*ba);\n}\n\nbool lineIntersect(vec2 p0, vec2 p1, vec2 p2, vec2 p3) {\n    vec2 s1 = p1 - p0;\n    vec2 s2 = p3 - p2;\n    float s = (-s1.y * (p0.x - p2.x) + s1.x * (p0.y - p2.y)) / (-s2.x * s1.y + s1.x * s2.y);\n    float t = ( s2.x * (p0.y - p2.y) - s2.y * (p0.x - p2.x)) / (-s2.x * s1.y + s1.x * s2.y);\n    return (s >= 0. && s <= 1. && t >= 0. && t <= 1.);\n}\n\nfloat isOccludedSoft(vec2 lightPos, vec2 fragPos, vec4 line, float softness) {\n    const int samples = 1;\n    float occlusion = 0.0;\n    vec2 offset[samples];\n    \n    for (int i = 0; i < samples; i++) {\n        float angle = float(i) * 6.283185 / float(samples);\n        offset[i] = vec2(cos(angle), sin(angle)) * softness;\n    }\n    \n    for (int i = 0; i < samples; i++) {\n        vec2 samplePos = fragPos + offset[i];\n        if (lineIntersect(lightPos, samplePos, line.xy, line.zw)) {\n            occlusion += 1.0;\n        }\n    }\n    \n    return occlusion / float(samples);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Paras\n    float lineWidth = 0.005;\n    vec3 lineColor = vec3(0.5, 0.3, 0.3);\n    float softness = 0.01;\n    vec3 bgndColor = vec3(0.2);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.yy;\n    float aspect = iResolution.x/iResolution.y;\n    vec2 uvAdjust = vec2((iResolution.x-iResolution.y)/iResolution.x, 0.);\n    uv -= uvAdjust;\n    \n    // Sample light count and light data from Buffer A\n    int lightCount = int(texelFetch(iChannel0, ivec2(0, 0), 0).x);\n    \n    // Sample line segment count and line segment data from Buffer B\n    int lineCount = int(texelFetch(iChannel1, ivec2(0, 0), 0).x);\n    \n    // Sample line segment data\n    vec4 lineSegments[40];\n    for (int i = 0; i < lineCount; i++) {\n        vec4 lineSegment = texelFetch(iChannel1, ivec2(i + 1, 0), 0);\n        lineSegment.xz = lineSegment.xz*aspect - vec2(uvAdjust.x);\n        lineSegments[i] = lineSegment;\n    }\n    \n    // Background\n    vec3 col = bgndColor;\n    vec3 background = texture(iChannel2, uv).rgb;\n\n    // Iterate over each light\n    for (int i = 0; i < lightCount; i++) {\n        vec4 light = texelFetch(iChannel0, ivec2(i + 1, 0), 0);\n        \n        // update over time\n        light.xy += 0.05*sin(light.zw*iTime/1.);\n        \n        // Update mouse light position\n        if (i == 2) {\n            light.xy = iMouse.xy/iResolution.xy;\n        }\n        \n        light.x = light.x*aspect - uvAdjust.x;\n        \n        // SDF\n        float dist = distance(uv, light.xy);\n        float sdf = dist - light.z;\n        \n        if (sdf < 0.) {\n            // find occlusion with walls\n            float occlusion = 0.0;\n            for (int j = 0; j < lineCount; j++) {\n                if (udSegment(light.xy, lineSegments[j].xy, lineSegments[j].zw) < light.z) {\n                    occlusion += isOccludedSoft(light.xy, uv, lineSegments[j], softness);\n                }\n            }\n            occlusion = min(1., occlusion);\n\n            // Solve color\n            vec3 colLight = vec3(0.7) + 0.2*hueToRGB(light.w);\n            col = mix(col, 2.0*colLight * (1.0 - occlusion), smoothstep(0.0, 1.0, -sdf / light.z));\n        }\n    }\n    \n    // Lights + Albedo\n    col *= background;\n     \n    // Wall rendering\n    for (int i = 0; i < lineCount; i++) {\n        float sdfWall = udSegment(uv, lineSegments[i].xy, lineSegments[i].zw) - lineWidth;\n        col = mix(col, lineColor, smoothstep(0.0, 1.0, 1.0 - (sdfWall / lineWidth)));\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Buffer A: Light data storage with light count\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    int lightCount = 25; // Number of lights\n\n    vec4 lightData[26]; // Array to store light count and light data\n    lightData[0] = vec4(float(lightCount), 0.0, 0.0, 0.0); // Store the count in the first texel\n\n    // Generate random lights data\n    vec4[25] randomLights;\n    for (int i = 0; i < lightCount; ++i) {\n        float x = fract(sin(float(i) * 12.9898) * 43758.5453); // Pseudo-random x position\n        float y = fract(sin(float(i + 50) * 78.233) * 43758.5453); // Pseudo-random y position\n        float radius = 0.1 + fract(sin(float(i + 100) * 93.9898) * 43758.5453) * 0.25; // Pseudo-random radius\n        float hue = fract(sin(float(i + 150) * 45.233) * 43758.5453); // Pseudo-random hue\n\n        randomLights[i] = vec4(x, y, radius, hue);\n    }\n\n    // Store light data in the array\n    for (int i = 0; i < lightCount; ++i) {\n        lightData[i + 1] = randomLights[i];\n    }\n\n    // Get the current index based on the fragment coordinate\n    int index = int(fragCoord.x) + int(fragCoord.y) * int(iResolution.x);\n\n    if (index < lightCount + 1) {\n        fragColor = lightData[index];\n    } else {\n        fragColor = vec4(0.0); // Default value for unused texels\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Buffer B: Line segment data storage with line segment count\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    int lineCount = 40; // Total number of line segments\n\n    vec4 lineData[41]; // Array to store line count and line segment data\n    lineData[0] = vec4(float(lineCount), 0.0, 0.0, 0.0); // Store the count in the first texel\n\n    // Generate random line segments data\n    int lineNum = 0;\n    for (int group = 0; group < 1; group++) {\n        float startX = 0.;\n        float startY = 0.;\n        \n        for (int i = 0; i < lineCount; i++) {\n            int groupNum = int(float(lineNum)/10.);\n            // Start point of the first line in the group\n            if (mod(float(lineNum), 10.) == 0.) {\n                startX = float(groupNum)*0.1 + 0.1*fract(sin(float(lineNum) * 12.9898) * 43758.5453); // Pseudo-random start x position\n                startY = 0.1*fract(sin(float(lineNum + 10) * 78.233) * 43768.5453); // Pseudo-random start y position\n            }\n            // find end of line values\n            float endX = startX + 0.2*fract(sin(float(lineNum + 20) * 12.9998) * 43758.5453); // Pseudo-random end x position\n            float endY = startY + 0.2*fract(sin(float(lineNum + 30) * 78.233) * 43758.5453); // Pseudo-random end y position\n            \n            if (groupNum == 0 || groupNum == 2) {\n                // normal\n                lineData[lineNum + 1] = vec4(startX, startY, endX, endY);\n            } else {\n                // flip these directions\n                lineData[lineNum + 1] = vec4(startX, 1.0 - startY, endX, 1.0 - endY);\n            }\n            lineNum++;\n            \n            // Update the start point for the next line to create contiguous lines\n            startX = endX;\n            startY = endY;\n        }\n    }\n\n    // Get the current index based on the fragment coordinate\n    int index = int(fragCoord.x) + int(fragCoord.y) * int(iResolution.x);\n\n    if (index < lineCount + 1) {\n        fragColor = lineData[index];\n    } else {\n        fragColor = vec4(0.0); // Default value for unused texels\n    }\n}","name":"Buffer B","description":"","type":"buffer"}]}