{"ver":"0.1","info":{"id":"43ScRz","date":"1726824436","viewed":25,"name":"falling bricks","username":"tommyangl","description":"bricks","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["falling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // extract data\n    vec2 circlePos = texelFetch(iChannel1, Data1Address,0).xy;\n    vec2 rectPos = texelFetch(iChannel1, Data2Address,0).xy;\n    int score = int(texelFetch(iChannel1, Data2Address,0).w);\n    \n    vec2 uv = fragCoord/iResolution.xy; // normalized pixel coordinates \n    vec2 FirstUV = uv;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // render\n    CircleColor = 0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0,2,4));\n    BgColor = texture(iChannel0,FirstUV).rgb;\n    vec3 wood = texture(iChannel2,FirstUV).rgb;\n    vec3 col = vec3(BgColor);\n    \n    float circle = Circle(uv, circlePos, CircleRadius);\n    float rect = sdBox(uv, rectPos, RectSize);\n    float point;\n    \n    for (int i = 0;i<int(score);++i)\n    {\n        point = sdBox(uv, vec2(-0.82 + 0.08*float(i%22),0.42 - 0.06*float(i/22)), vec2(0.02,0.02));\n        col = mix(vec3(0.2,0.7,1),col,smoothstep(0.,0.004,point));\n    }\n    col = mix(wood,col,smoothstep(0.,0.01,FirstUV.y-0.2));\n    col = mix(CircleColor,col,smoothstep(0.,0.003 ,circle));\n    col = mix(RectColor,col,smoothstep(0.,0.004,rect));\n    fragColor = vec4(col,1.); // Output to screen\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec2 control()\n{\n    vec2 left = texelFetch(iChannel0, ivec2(KEY_LEFT, 0), 0).x * vec2(-1., 0.);\n    vec2 right = texelFetch(iChannel0, ivec2(KEY_RIGHT, 0), 0).x * vec2(1., 0.);\n    return (left + right);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame == 0) // initialization\n    {  \n        if (ivec2(fragCoord) == Data1Address)\n            fragColor = vec4(CircleStartPos,0,0);\n        else if (ivec2(fragCoord) == Data2Address)\n            fragColor = vec4(RectStartPos,Velocity,Score);\n    }\n    else\n    {\n        // data extraction\n        vec2 circlePos = texelFetch(iChannel1, Data1Address,0).xy;\n        vec2 rectPos = texelFetch(iChannel1, Data2Address,0).xy;\n        Velocity = texelFetch(iChannel1,Data2Address,0).z;\n        Score = int(texelFetch(iChannel1,Data2Address,0).w);\n        \n        if (ivec2(fragCoord) == Data1Address)\n        {\n            circlePos += vec2(Speed*iTimeDelta,0)*control().x;\n            if (circlePos.x < -Border) circlePos.x = -Border;\n            else if (circlePos.x> Border) circlePos.x = Border;\n            \n            fragColor = vec4(circlePos,0,0); // save data\n        }\n        else if (ivec2(fragCoord) == Data2Address)\n        {\n            // rectangle movement\n            rectPos += vec2(0,-Velocity*iTimeDelta);\n            \n            // collision with bottom/sphere\n            vec2 platformMin = rectPos - RectSize;\n            vec2 platformMax = rectPos + RectSize;\n            vec2 nearestPoint = clamp(circlePos, platformMin, platformMax);\n            if (rectPos.y <= Bottom || distance(circlePos, nearestPoint) <= CircleRadius) \n            {\n                if (distance(circlePos, nearestPoint) > CircleRadius) \n                {\n                    Score++;\n                    Velocity *= 1.1;\n                }\n                else // reset\n                {\n                    Score = 0;\n                    Velocity = 1.;\n                }\n                // random rect respawn\n                rectPos = vec2(-RectSpawnBorder + fract(sin(iTime))*2.*RectSpawnBorder,RectStartPos.y);\n            }\n            \n            fragColor = vec4(rectPos,Velocity,Score); // save data\n        }\n    }\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define KEY_LEFT 37\n#define KEY_RIGHT 39\nconst vec2 CircleStartPos = vec2(0,-0.3);\nconst float CircleRadius = 0.1;\nconst vec3 RectColor = vec3(102.,19.,19.)/256.;\nconst vec2 RectStartPos = vec2(0, 0.5);\nconst float RectSpawnBorder = 0.7;\nconst vec2 RectSize = vec2(0.2,0.05);\nconst float Border = 0.75;\nconst float Bottom = -0.5;\nconst float Speed = 1.3;\nconst ivec2 Data1Address = ivec2(0, 0); // in texel (0,0) - circlePos\nconst ivec2 Data2Address = ivec2(0, 1); // in texel (0,1) - rectPos, Velocity,Score\n\nvec3 CircleColor = vec3(1);\nvec3 BgColor = vec3(0.);\nint Score = 0;\nfloat Velocity = .75;\n\nfloat Circle(vec2 uv, vec2 pos, float r)\n{\n    return length(uv - pos) - r;\n}\nfloat sdBox(vec2 uv, in vec2 p, in vec2 b )\n{\n    vec2 d = abs(uv - p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}","name":"Common","description":"","type":"common"}]}