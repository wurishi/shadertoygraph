{"ver":"0.1","info":{"id":"Nlc3R4","date":"1668832089","viewed":225,"name":"Bubble Test 2D","username":"spalmer","description":"merging of bubbles in preparation for 3d soap film.\n","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["bubble"],"hasliked":0,"parentid":"sdGXzK","parentname":"Angular Distance"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// equal radii is fairly easy,\n// but to handle different sizes,\n// must find where 2 spheres \n// intersect each other.\n// Trickier!\n\n// see my comment at http://shadertoy.com/view/DdsXW4\nvoid bubbleIntersector(float d, float r0, float rd, out float p, out float r)\n{\n    // handle equal radii planar case, treat as kinda big sphere (but not too big)\n    if (abs(r0 - rd) < 1e-9) { r = 1e3*r0; p = .5*d+r; return; }\n    p = d * r0 / (r0 - rd);\n    r = sqrt((p - d + (rd*rd - r0*r0) / d)*p + r0*r0);\n}\n// saved the original r0 > rd version\n// TODO handle r0 <= rd\n/*\n    float rm = max(r0, rd); rd = min(r0, rd); r0 = rm;\n    p = d * r0 / (r0 - rd);\n    r = sqrt((((p) - d + -abs(rd*rd - r0*r0) / d)*(p) + rm*rm));\n*/\n// I have most of the nastiness isolated to this one function now.\nvoid bubbleIntersectorRobust(float bd, vec2 p0, vec2 p1, float r0, float r1, out vec2 p2, out float r2)\n{\n    //float bd = distance(p0, p1);\n    // handle equal radii planar case, treat as kinda big sphere (but not too big)\n    if (abs(r0 - r1) < 1e-9) { r2 = 1e3*r0; p2 = 1e3 * (p1 - p0) + p0; return; } //d2 = .5*bd+r2; \n    float s = 1.; \n    if (r1 > r0) { s = -1.; float tr = r0; r0 = r1; r1 = tr; vec2 tp = p0; p0 = p1; p1 = tp; } // HACK ensures r0 >= r1\n    float d2 = bd * r0 / (r0 - r1);\n    r2 = sqrt((d2 - bd + (r1*r1 - r0*r0) / bd)*d2 + r0*r0);\n    //r2 = abs(r2); // but it's always positive anyway\n    // but the outer loop in mainImage already verified they touch, so the intersection\n    // will exist, so r2 will exist (but might be infinite)\n    //r2 = min(r2, 1e7); // finite so we don't have to also handle linear case - but already did handle that!\n    r2 *= s;\n    p2 = d2 / bd * (p1 - p0) + p0;\n}\n// so now I split off a new one for experimentation\nvoid bubbleIntersectorAttempt(float bd, vec2 p0, vec2 p1, float r0, float r1, out vec2 p2, out float r2)\n{\n    if (abs(r0 - r1) < 1e-9) { r2 = 1e3*r0; p2 = 1e3 * (p1 - p0) + p0; return; }\n    float d2 = bd * r0 / (r0 - r1);\n    r2 = sqrt((d2 - bd + (r1*r1 - r0*r0) / bd)*d2 + r0*r0);\n    if (r1 > r0) r2 = -r2; // oh wow, that's all I had to do?!\n    p2 = d2 / bd * (p1 - p0) + p0;\n}\n// so those output position and signed radius of dividing bubble, handling the inside-out sphere for negative radius is important\n// but FIXME I still dislike having to pull the sign back out, but damn the interface is complicated enough already!\n// FIXME it gets really confusing trying to keep track of the various ways I refer to the bubbles.  By array index, by P0,P1,P2, R0,Rd,r ...\n// and is different for various parts of the code.  I wrote it, and I get really confused by it.\n// So once I straighten that out, I hope to go back and redo the identifiers and such.\n\n// simply return signed distance to the divider\nfloat dbubblesplit(vec2 q, float bd, vec2 p0, vec2 p1, float r0, float r1)\n{\n    float r2; vec2 p2;\n    bubbleIntersectorAttempt/*Robust*/(bd, p0, p1, r0, r1, p2, r2);\n    float s = sign(r2);\n    return (distance(q, p2) - r2 * s) * s; // just return third bubble signed distance\n} // so negative result means not actually inside this bubble b0, but in other b1\n\n#define IZERO min(0, iFrame)\n\n// Brute force is not the way.\n// In a real situation, would likely set\n// N to be the maximum neighbor count.\n// That at least prevents N from being large,\n// which makes such unclever algorithm usable.\nconst int N = 5;\n\nvec2  bp[N]; // center of bubble\nfloat br[N]; // radius of bubble\nfloat bd[N]; // signed distance to bubble\n\nfloat dbubbles(vec2 q, out int bid)\n{\n    float h = 3e38;\n    bid = -1;\n    // compute all the distances to query once to save some sqrts; can compute outside distance as we go, if negative, is inside at least one bubble\n    for (int i = N + IZERO; i-- > 0; ) {\n        vec2 a = bp[i]; \n        float r = br[i],\n            ad = bd[i] = distance(q, a) - r;\n        h = min(h, ad); // TODO smoothmin would make a meniscus\n    }\n    bool inside = h < 0.;\n    if (inside)\n    // for all bubbles\n    for (int i = N + IZERO; i-- > 0; ) {\n        float da = bd[i];\n        // query is actually inside?\n        if (da <= 0.)\n        {\n            // FIXME O(N^2), should at least go for O(log(N))\n            // so far no luck with that, so doing it slowly\n            for (int j = N; j-- > 0; ) {\n                if (j == i) continue;\n                float db = bd[j];\n                // TODO optimization exclude query points on far side away from other bubble\n                float bd = distance(bp[i], bp[j]); // FIXME still computed wastefully 2x each due to O(N^2) loop\n                // bubbles touch?\n                if (bd < br[i]+br[j]) {\n                    // handle bubble completely inside another\n                    if (bd < abs(br[i] - br[j])) continue;\n                    float dq = dbubblesplit(q, bd, bp[i], bp[j], br[i], br[j]);\n                    // if q in another bubble, give up on this one\n                    if (dq < 0.) { da = 0.; break; }\n                    da = max(da, -abs(dq));\n                }\n            }\n            if (da < 0.) {\n                bid = i;\n                h = da;\n                break;\n            }\n        }\n    }\n    return h;\n}\n// now separated out from the mainImage setup and drawing, ungolfed for clarity\n\nvoid initBubbles()\n{\n    const float rn = 1./float(N);\n    for (int i = N + IZERO; i-- > 0; ) {\n        float z = float(i) * rn;\n        bp[i] = vec2(0,0) + vec2(2.*sin(vec2(0,11) + .3*iTime + vec2(3,4) * .1*iTime + 6.*z));\n        br[i] = 1.5 - z; //1.; //\n    }\n}\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    vec2 r = iResolution.xy;\n    float S = 8./r.y;\n    vec2 q = (p - .5*r) * S;\n    initBubbles();\n    if (iMouse.z > 0.) bp[2] = (iMouse.xy - .5*r) * S;            \n    // inside any bubble?\n    int bid = -1;\n    float h = dbubbles(q, bid);\n    bool inside = h < 0.;\n    h = abs(h);\n    float T = 1.5*S; // half thickness\n    h -= T;\n    h /= S;\n    float g = 1. - clamp(h, 0., 1.);\n    vec3 c = inside ? vec3(1) : vec3(.1);\n    const float phi = (sqrt(5.) + 1.) * .5;\n    if (inside) // don't want to show outside voronoi regions here, didn't compute bid for those\n        c = mix(c, cos(vec3(0,2,4) + phi * float(bid)) * .5 + .5, .5);\n    c = mix(vec3(.2), c, mix(-cos(1.2*h), 1., .8)); // dim isocontours\n    c = mix(c, vec3(1), g); // white outline\n    o = vec4(pow(c, vec3(.45)), 1);\n}\n\n// uiop posted bubbles at http://shadertoy.com/view/DdlXWn before I could finish,\n// which prompted me to public this way before it was even working properly.\n// It's better now, but still needs much optimization and cleaning.\n\n/*\n    //r = r0*rd / (rd-r0); // TESTING\n    //r = abs(r0*rd / (rd-r0)); // TESTING\n    //r = 1./(1./r0 - 1./rd); // TESTING\n    //r = 1./(1./rd - 1./r0); // TESTING\n// so far seems doesn't work out the same,\n// was hoping it would let me avoid the sqrt!\n// TODO apparently 1/r2 = 1/r0-1/r1 or something like that,\n// see question at mla's link where it's a given\n// http://math.stackexchange.com/questions/680651/geometric-construction-of-2-soap-bubbles-meeting\n// which seems to imply r2 = r0*r1 / (r1-r0)\n// I think that may let me work backward to\n// find the position of the smaller bubble that\n// will produce 120 degree intersections.\n// but doesn't appear to be a true relationship here.\n// perhaps if actually moved the smaller bubble...\n// it can't work *here* if it doesn't take the distance d\n// between bubbles b0 and b1 into account!\n*/","name":"Image","description":"","type":"image"}]}