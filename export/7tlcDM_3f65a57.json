{"ver":"0.1","info":{"id":"7tlcDM","date":"1648153064","viewed":96,"name":"Torus Man","username":"Tiposan","description":"torus man","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["torus"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\nvec2 opU2(vec2 d1, vec2 d2)\n{\n    return (d1.x < d2.x) ? d1 : d2;\n}\nvec2 Union(vec2 d1, vec2 d2){\n    return min(d1,d2);\n}\nvec3 opRep(vec3 p, vec3 c)\n{\n    return mod(p+0.5*c, c)-0.5*c;\n}\n///////////////FORME////////////////////////////////////////////////\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nvec2 map(vec3 pos)\n{\n    pos.y+=1.;\n    pos = opRep(pos, vec3(10.0, 10.0, 10.0));\n    vec3 newPos = pos+vec3(0.,clamp(5.*-sin(iTime*3.),-1.,-0.7),0.0);\n    newPos.xy *= rot(3.14);\n    vec2 c = vec2(sin(2.),cos(2.));\n    vec2 head = vec2(sdCappedTorus(newPos, c, 1., .7));\n    \n    newPos = pos+vec3(0.,clamp(5.*-sin(iTime*3.), 2.3,2.6 ),0.0);\n    vec2 body = vec2(  sdVerticalCapsule(newPos, 2.4, .3));\n    \n    newPos = pos+vec3(-0.2, clamp(5.*-sin(iTime*3.),0.9,1.2),0.0);\n    newPos.xy *= rot(2.7);\n    newPos.xy *= rot(clamp(2.*sin(iTime*3.),-0.8,0.0));\n    vec2 left_arm = vec2(  sdVerticalCapsule(newPos, .7, .2));\n   \n    newPos = pos+vec3(clamp(5.*sin(iTime*3.),-0.8,-0.6),2.1,0.0);\n    newPos.xy *= rot(0.);\n    newPos.xy *= rot(clamp(2.*-sin(iTime*3.),0.,0.6));\n    vec2 left_foreArm = vec2(sdVerticalCapsule(newPos, .4, .2));\n    \n    newPos = pos+vec3(0.2,clamp(5.*-sin(iTime*3.),0.9,1.2),0.0);\n    newPos.xy *= rot(-2.7);\n    newPos.xy *= rot(clamp(2.*-sin(iTime*3.),-0.0,0.8));\n    vec2 right_arm = vec2(  sdVerticalCapsule(newPos, .7, .2));\n    \n    newPos = pos+vec3(clamp(5.*-sin(iTime*3.),0.6,0.8),2.1,0.0);\n    newPos.xy *= rot(0.);\n    newPos.xy *= rot(clamp(2.*sin(iTime*3.),-0.6,0.));\n    vec2 right_foreArm = vec2(sdVerticalCapsule(newPos, .4, .2));\n    \n    newPos = pos+vec3(-0.2,clamp(5.*-sin(iTime*3.),2.5,2.8),0.0);\n    newPos.xy *= rot(3.14);\n    newPos.xy *= rot(clamp(2.*sin(iTime*3.),-0.8,0.0));\n    vec2 left_leg = vec2(sdVerticalCapsule(newPos, .4, .2));\n    \n    newPos = pos+vec3(-0.2,3.6,0.0);\n    newPos.xy *= rot(0.);\n    newPos.xy *= rot(clamp(2.*-sin(iTime*3.),-0.,0.6));\n    vec2 left_lowerLeg = vec2(sdVerticalCapsule(newPos, .4, .2));\n    \n    newPos = pos+vec3(0.2,clamp(5.*-sin(iTime*3.),2.5,2.8),0.0);\n    newPos.xy *= rot(3.14);\n    newPos.xy *= rot(clamp(2.*-sin(iTime*3.),-0.0,0.8));\n    vec2 right_leg = vec2(sdVerticalCapsule(newPos, .4, .2));\n    \n    newPos = pos+vec3(0.2,3.6,0.0);\n    newPos.xy *= rot(0.);\n    newPos.xy *= rot(clamp(2.*sin(iTime*3.),-0.6,0.));\n    vec2 right_lowerLeg = vec2(sdVerticalCapsule(newPos, .4, .2));\n    \n    //vec2 sdf_with_materials = opU2(v ,v2);\n    vec2 sdf_with_materials = Union(body, head);\n    sdf_with_materials = Union( sdf_with_materials, left_arm);\n    sdf_with_materials = Union( sdf_with_materials, left_foreArm);\n    sdf_with_materials = Union( sdf_with_materials, right_arm);\n    sdf_with_materials = Union( sdf_with_materials, right_foreArm);\n    sdf_with_materials = Union( sdf_with_materials, left_leg);\n    sdf_with_materials = Union( sdf_with_materials, left_lowerLeg);\n    sdf_with_materials = Union( sdf_with_materials, right_leg);\n    sdf_with_materials = Union( sdf_with_materials, right_lowerLeg);\n    \n    \n    return sdf_with_materials;\n}\nvec3 GetNormal (vec3 pos)\n{\n    float v = map(pos).x;\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(\n        map(pos+e.xyy).x,\n        map(pos+e.yxy).x,\n        map(pos+e.yyx).x) - v);\n}\n\nvec2 castRay(vec3 ro, vec3 rd)\n{\n    float c = 0.0;\n    for(int i=0; i<64; i++)\n    {\n        vec2 ray = map(ro + rd * c);\n        if(ray.x <(0.0001*c))\n        {\n            return vec2(c, ray.y);\n        }\n        c += ray.x;\n    }\n    return vec2(-1., 0.0);\n}\nvec3 render(vec3 ro, vec3 rd)\n{\n    vec2 contact = castRay(ro, rd);\n    vec3 nor = GetNormal(ro+ rd *contact.x);\n   \n    vec3 lightDir = vec3(1., 1., 2.);\n    float lambert = dot(nor, lightDir);\n    vec3 col=vec3(1.);\n    if (contact.x ==-1.0)\n    {\n        col = vec3(0.0) + (abs(rd.y)*0.5);\n    }\n    else\n    {\n        float depth = vec3(1.-contact.x).r;\n        col = palette(depth+fract(iTime*2.), vec3(0.5), vec3(0.5),vec3(1.), vec3(0.0,0.33,0.67));\n        col*=lambert;\n    }\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.*fragCoord/iResolution.xy-1.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 cameraPos = vec3(0.,0.,1.*iTime);\n    vec3 cameraTar = vec3(0.0);\n    \n    vec3 forward = normalize(cameraTar - cameraPos);\n    vec3 right = normalize(cross(vec3(0,-1.,0), forward));\n    vec3 up = normalize(cross(right, forward));\n    vec3 viewDir = normalize(uv.x * right + uv.y* up +2. * forward);\n    // Time varying pixel color\n    vec3 col = render(cameraPos, viewDir);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}