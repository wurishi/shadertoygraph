{"ver":"0.1","info":{"id":"wsK3RR","date":"1569616152","viewed":463,"name":"Quantum Harmonic Oscillator - 2D","username":"Kerdek","description":"Complex plot of the wave function of a Gaussian particle in a quantum harmonic oscillator in two dimensions, calculated directly from an elementary solution.\n\nHue represents phase, and brightness represents probability.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["physics","quantum"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 c, in vec2 ij)\n{\n    vec2 x = 2.0 * ij / iResolution.x - vec2(1.0, iResolution.y / iResolution.x);\n    float t = iTime;\n\n    c.xyz = complex2rgb(psi(x, t));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec3 hsl2rgb( in vec3 c )\n{\n    return c.z + c.y * clamp(abs(mod(c.x * 0.95493 - vec3(0.0, 2.0, 4.0), 6.0) - 3.0) - 1.5, -0.5, 0.5) * (1.0 - abs(2.0 * c.z - 1.0));\n}\n\nfloat compress(in float x)\n{\n    return pow(x / (x + 1.0), 2.0);\n}\n\nvec3 complex2rgb(in vec2 z)\n{\n    return hsl2rgb(vec3(atan(z.y, z.x), 1.0, compress(length(z))));\n}\n\nvec2 complex_cosh(in vec2 z)\n{\n    return vec2(cosh(z.x) * cos(z.y), sinh(z.x) * sin(z.y));\n}\n\nvec2 complex_tanh(in vec2 z)\n{\n    return vec2(sinh(2.0 * z.x) / (cos(2.0 * z.y) + cosh(2.0 * z.x)), sin(2.0 * z.y) / (cos(2.0 * z.y) + cosh(2.0 * z.x)));\n}\n\nvec2 complex_atanh(in vec2 z)\n{\n    float one_minus_zx = 1.0 - z.x;\n    float one_plus_zx = 1.0 + z.x;\n    return vec2(0.25 * (log(one_plus_zx * one_plus_zx + z.y * z.y) - log(one_minus_zx * one_minus_zx + z.y * z.y)), 0.5 * (atan(z.y, one_plus_zx) - atan(-z.y, one_minus_zx)));\n}\n\nfloat complex_arg(in vec2 z)\n{\n    return atan(z.y, z.x);\n}\n\nvec2 complex_exp(in vec2 z)\n{\n    return exp(z.x) * vec2(cos(z.y), sin(z.y));\n}\n\nvec2 i_times(in vec2 z)\n{\n    return vec2(-z.y, z.x);\n}\n\nfloat vec2_square(in vec2 r)\n{\n    return dot(r, r);\n}\n\nconst float pi = 3.14159265358979;\n\n// Enter the parameters and initial conditions here.\n\nconst float m = 1.0;\nconst float hbar = 0.01;\nconst float omega = 1.0;\nconst vec2 a0 = vec2(200.0, 0.0);\nconst vec2 r0 = vec2(0.5, 0.0);\nconst vec2 v0 = vec2(0.0, 0.2);\nconst float theta0 = 0.0;\n\n// Some physical quantites calculated from the above.\n\nconst vec2 neg_r0_omega = -r0 * omega;\nconst vec2 v0_over_omega = v0 / omega;\n\nconst float m_omega_over_hbar = m * omega / hbar;\nconst vec2 a0_hbar_over_m_omega = a0 / m_omega_over_hbar;\n\nvec2 a(in vec2 i_omega_t_plus_atanh_a0_hbar_over_m_omega)\n{\n    return m_omega_over_hbar * complex_tanh(i_omega_t_plus_atanh_a0_hbar_over_m_omega);\n}\n\nvec2 rvec(in float omega_t)\n{\n    return r0 * cos(omega_t) + v0_over_omega * sin(omega_t);\n}\n\nvec2 vvec(in float omega_t)\n{\n    return neg_r0_omega * sin(omega_t) + v0 * cos(omega_t);\n}\n\nfloat theta(in vec2 i_omega_t_plus_atanh_a0_hbar_over_m_omega)\n{\n    return theta0 - complex_arg(complex_cosh(i_omega_t_plus_atanh_a0_hbar_over_m_omega));\n}\n\nvec2 psi(in vec2 x, in float t)\n{\n    float omega_t = omega * t;\n    vec2 i_omega_t_plus_atanh_a0_hbar_over_m_omega = vec2(0.0, omega_t) + complex_atanh(a0_hbar_over_m_omega);\n    vec2 a_val = a(i_omega_t_plus_atanh_a0_hbar_over_m_omega);\n    vec2 rvec_val = rvec(omega_t);\n    return sqrt(a_val.x / pi) * complex_exp(-0.5 * a_val * vec2_square(x - rvec_val) + vec2(0.0, m / hbar * dot(vvec(omega_t), x - 0.5 * rvec_val) + theta(i_omega_t_plus_atanh_a0_hbar_over_m_omega)));\n}","name":"Common","description":"","type":"common"}]}