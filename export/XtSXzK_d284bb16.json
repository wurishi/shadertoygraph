{"ver":"0.1","info":{"id":"XtSXzK","date":"1451457385","viewed":254,"name":"Noise Functions: 1","username":"AxleMike","description":"A collection of noise functions. \nNeed to fix the text so that it is properly supported for any resolution, right now it just kinda works.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// By Alexander Lemke, 2015\n\n// Text\n#define LETTER_A(position) BitCheck(0x3F, 0x48, 0x48, 0x48, 0x3F, position); position.x -= 7.0 \n#define LETTER_B(position) BitCheck(0x7F, 0x49, 0x49, 0x49, 0x36, position); position.x -= 7.0 \n#define LETTER_C(position) BitCheck(0x3E, 0x41, 0x41, 0x41, 0x41, position); position.x -= 7.0 \n#define LETTER_D(position) BitCheck(0x7F, 0x41, 0x41, 0x41, 0x3E, position); position.x -= 7.0 \n#define LETTER_E(position) BitCheck(0x7F, 0x49, 0x49, 0x49, 0x49, position); position.x -= 7.0 \n#define LETTER_F(position) BitCheck(0x7F, 0x48, 0x48, 0x48, 0x48, position); position.x -= 7.0 \n#define LETTER_G(position) BitCheck(0x3E, 0x41, 0x41, 0x49, 0x49, 0x2E, position); position.x -= 8.0 \n#define LETTER_H(position) BitCheck(0x7F, 0x8, 0x8, 0x8, 0x7F, position); position.x -= 7.0 \n#define LETTER_I(position) BitCheck(0x41, 0x41, 0x7F, 0x41, 0x41, position); position.x -= 7.0 \n#define LETTER_J(position) BitCheck(0x42, 0x41, 0x41, 0x7E, 0x40, 0x40, position); position.x -= 8.0 \n#define LETTER_K(position) BitCheck(0x7F, 0x8, 0x8, 0x14, 0x22, 0x41, position); position.x -= 8.0 \n#define LETTER_L(position) BitCheck(0x7F, 0x1, 0x1, 0x1, 0x1, position); position.x -= 7.0 \n#define LETTER_M(position) BitCheck(0x7F, 0x40, 0x20, 0x1F, 0x20, 0x40, 0x7F, position); position.x -= 9.0 \n#define LETTER_N(position) BitCheck(0x7F, 0x20, 0x18, 0x6, 0x1, 0x7F, position); position.x -= 8.0 \n#define LETTER_O(position) BitCheck(0x3E, 0x41, 0x41, 0x41, 0x41, 0x3E, position); position.x -= 8.0 \n#define LETTER_P(position) BitCheck(0x7F, 0x48, 0x48, 0x48, 0x30, position); position.x -= 7.0 \n#define LETTER_Q(position) BitCheck(0x3E, 0x41, 0x41, 0x45, 0x42, 0x3D, position); position.x -= 8.0 \n#define LETTER_R(position) BitCheck(0x7F, 0x48, 0x4C, 0x4A, 0x31, position); position.x -= 7.0 \n#define LETTER_S(position) BitCheck(0x31, 0x49, 0x49, 0x49, 0x46, position); position.x -= 7.0 \n#define LETTER_T(position) BitCheck(0x40, 0x40, 0x7F, 0x40, 0x40, position); position.x -= 7.0 \n#define LETTER_U(position) BitCheck(0x7E, 0x1, 0x1, 0x1, 0x7E, position); position.x -= 7.0 \n#define LETTER_V(position) BitCheck(0x70, 0xE, 0x1, 0xE, 0x70, position); position.x -= 7.0 \n#define LETTER_W(position) BitCheck(0x7C, 0x2, 0x1, 0x7E, 0x1, 0x2, 0x7C, position); position.x -= 9.0 \n#define LETTER_X(position) BitCheck(0x63, 0x14, 0x8, 0x14, 0x63, position); position.x -= 7.0 \n#define LETTER_Y(position) BitCheck(0x60, 0x10, 0xF, 0x10, 0x60, position); position.x -= 7.0 \n#define LETTER_Z(position) BitCheck(0x41, 0x43, 0x45, 0x49, 0x51, 0x61, position); position.x -= 8.0 \n#define SPACE(position) position.x -= 8.0 \n#define DASH(position) BitCheck(0x8, 0x8, 0x8, position); position.x -= 5.0 \n#define NUMBER_1(position) BitCheck(0x21, 0x21, 0x7F, 0x1, 0x1, position); position.x -= 7.0 \n#define NUMBER_2(position) BitCheck(0x23, 0x45, 0x49, 0x49, 0x31, position); position.x -= 7.0 \n#define NUMBER_3(position) BitCheck(0x49, 0x49, 0x49, 0x49, 0x36, position); position.x -= 7.0 \n#define NUMBER_4(position) BitCheck(0x78, 0x8, 0x8, 0x7F, 0x8, position); position.x -= 7.0 \n#define NUMBER_5(position) BitCheck(0x72, 0x49, 0x49, 0x49, 0x46, position); position.x -= 7.0 \n#define NUMBER_6(position) BitCheck(0x3E, 0x49, 0x49, 0x49, 0x26, position); position.x -= 7.0  \n#define NUMBER_7(position) BitCheck(0x41, 0x42, 0x44, 0x48, 0x50, 0x60, position); position.x -= 8.0  \n#define NUMBER_8(position) BitCheck(0x36, 0x49, 0x49, 0x49, 0x36, position); position.x -= 7.0 \n#define NUMBER_9(position) BitCheck(0x32, 0x49, 0x49, 0x49, 0x3E, position); position.x -= 7.0 \n#define NUMBER_0(position) BitCheck(0x3E, 0x41, 0x41, 0x41, 0x3E, position); position.x -= 7.0 \n\n#define START_TEXT     fragCoord = (fragCoord.xy*iResolution.xy)/scale; vec2 textPos=floor(fragCoord.xy-(textCursor.xy /scale)+1.0); if(textPos.y<0.0 || textPos.y>8.0) return -1.0; if (fragCoord.x + (scale * 2.0) < textCursor.x) return -1.0;\n#define END_TEXT\t   if (fragCoord.x < (textPos.x * iResolution.x)) return -1.0;\n\nfloat BitCheck(in int c1, in int c2, in int c3, in int c4, in int c5, in int c6, in int c7, in vec2 textPos) \n{\n    float columnBits = 0.0;\n    \n    int textColumn = int(textPos.x);\n    \n    if (textColumn == 1) { columnBits = float(c1); }\n    else if (textColumn == 2) { columnBits = float(c2); }\n    else if (textColumn == 3) { columnBits = float(c3); }\n    else if (textColumn == 4) { columnBits = float(c4); }\n    else if (textColumn == 5) { columnBits = float(c5); }\n    else if (textColumn == 6) { columnBits = float(c6); }\n    else if (textColumn == 7) { columnBits = float(c7); }\n       \n    return floor(fract(columnBits / pow(2.0, floor(textPos.y))) * 2.0);\n}\n\nfloat BitCheck(in int c1, in int c2, in int c3, in int c4, in int c5, in int c6, in vec2 textPos) \n{\n    return BitCheck(c1, c2, c3, c4, c5, c6, 0, textPos);\n}\n\nfloat BitCheck(in int c1, in int c2, in int c3, in int c4, in int c5, in vec2 textPos) \n{\n    return BitCheck(c1, c2, c3, c4, c5, 0, textPos);\n}\n\nfloat BitCheck(in int c1, in int c2, in int c3, in int c4, in vec2 textPos) \n{\n    return BitCheck(c1, c2, c3, c4, 0, textPos);\n}\n\nfloat BitCheck(in int c1, in int c2, in int c3, in vec2 textPos) \n{\n    return BitCheck(c1, c2, c3, 0, textPos);\n}\n\n// Shared Strings\n#define NOISE_STRING(bitVal, textPos) bitVal += LETTER_N(textPos); bitVal += LETTER_O(textPos); bitVal += LETTER_I(textPos); bitVal += LETTER_S(textPos); bitVal += LETTER_E(textPos);\n#define GENERIC_STRING(bitVal, textPos) bitVal += LETTER_G(textPos); bitVal += LETTER_E(textPos); bitVal += LETTER_N(textPos); bitVal += LETTER_E(textPos); bitVal += LETTER_R(textPos); bitVal += LETTER_I(textPos); bitVal += LETTER_C(textPos)\n#define TEXTURE_STRING(bitVal, textPos) bitVal = LETTER_T(textPos); bitVal += LETTER_E(textPos); bitVal += LETTER_X(textPos); bitVal += LETTER_T(textPos); bitVal += LETTER_U(textPos); bitVal += LETTER_R(textPos);  bitVal += LETTER_E(textPos)\n\n#define FRACTAL_STRING(bitVal, textPos) bitVal = LETTER_F(textPos); bitVal += LETTER_R(textPos); bitVal += LETTER_A(textPos); bitVal += LETTER_C(textPos); bitVal += LETTER_T(textPos); bitVal += LETTER_A(textPos); bitVal += LETTER_L(textPos)\n#define BROWNIAN_STRING(bitVal, textPos) bitVal += LETTER_B(textPos); bitVal += LETTER_R(textPos); bitVal += LETTER_O(textPos); bitVal += LETTER_W(textPos); bitVal += LETTER_N(textPos); bitVal += LETTER_I(textPos); bitVal += LETTER_A(textPos); bitVal += LETTER_N(textPos) \n#define MOTION_STRING(bitVal, textPos) bitVal += LETTER_M(textPos); bitVal += LETTER_O(textPos); bitVal += LETTER_T(textPos); bitVal += LETTER_I(textPos); bitVal += LETTER_O(textPos); bitVal += LETTER_N(textPos)\n#define PERLIN_STRING(bitVal, textPos) bitVal += LETTER_P(textPos); bitVal += LETTER_E(textPos); bitVal += LETTER_R(textPos); bitVal += LETTER_L(textPos); bitVal += LETTER_I(textPos); bitVal += LETTER_N(textPos)\n#define LAYERS_STRING(bitVal, textPos) bitVal += LETTER_L(textPos); bitVal += LETTER_A(textPos); bitVal += LETTER_Y(textPos); bitVal += LETTER_E(textPos); bitVal += LETTER_R(textPos); bitVal += LETTER_S(textPos)\n\nfloat WriteRandomNoiseString(in vec2 textCursor, in vec2 fragCoord, in float scale)\n{\n    START_TEXT     \n    float bitVal = LETTER_R(textPos);\n    bitVal += LETTER_A(textPos);\n    bitVal += LETTER_N(textPos);\n    bitVal += LETTER_D(textPos);\n    bitVal += LETTER_O(textPos);\n    bitVal += LETTER_M(textPos);\n    SPACE(textPos);\n\tNOISE_STRING(bitVal, textPos);\n    END_TEXT\n    \n    return bitVal;\n}\n\nfloat WriteTextureNoiseString(in vec2 textCursor, in vec2 fragCoord, in float scale)\n{\n    START_TEXT      \n    float bitVal = 0.0;\n    TEXTURE_STRING(bitVal, textPos);\n    SPACE(textPos);\n    NOISE_STRING(bitVal, textPos)\n    END_TEXT\n    \n    return bitVal;\n}\n\nfloat WriteGenericNoiseString(in vec2 textCursor, in vec2 fragCoord, in float scale)\n{\n    START_TEXT\n    float bitVal = 0.0;\n    GENERIC_STRING(bitVal, textPos);\n    SPACE(textPos);\n    NOISE_STRING(bitVal, textPos);\n    END_TEXT\n    \n    return bitVal;\n}\n\nfloat WriteFractalBrownianMotionString(in vec2 textCursor, in vec2 fragCoord, in float scale)\n{\n    START_TEXT \n    float bitVal = 0.0;\n    FRACTAL_STRING(bitVal, textPos);\n    SPACE(textPos);\n    BROWNIAN_STRING(bitVal, textPos);\n    SPACE(textPos);\n    MOTION_STRING(bitVal, textPos);\n    SPACE(textPos);\n    bitVal += DASH(textPos);\n    SPACE(textPos);\n    GENERIC_STRING(bitVal, textPos);\n    SPACE(textPos);\n    NOISE_STRING(bitVal, textPos);\n    SPACE(textPos);\n    bitVal += DASH(textPos);\n    SPACE(textPos);\n    bitVal += NUMBER_7(textPos);\n    SPACE(textPos);\n\tLAYERS_STRING(bitVal, textPos);\n    END_TEXT\n    \n    return bitVal;\n}\n\nfloat WritePerlinNoiseString(in vec2 textCursor, in vec2 fragCoord, in float scale)\n{\n    START_TEXT   \n    float bitVal = 0.0;\n    PERLIN_STRING(bitVal, textPos);\n    SPACE(textPos);\n    NOISE_STRING(bitVal, textPos)\n    SPACE(textPos);\n    bitVal += DASH(textPos);\n    SPACE(textPos);\n    bitVal += NUMBER_7(textPos);\n    SPACE(textPos);\n    LAYERS_STRING(bitVal, textPos);\n    END_TEXT\n    \n    return bitVal;\n}\n\n//////////////////////////////////////////////////\n// Helpers\n//////////////////////////////////////////////////  \nfloat TextureNoise(in vec2 p)\n{\n \treturn texture(iChannel0, p).r; \n}\n\n// http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\nfloat RandomNoise(in vec2 p)\n{\n    return fract(sin(dot(p.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// I believe the following noise function is based on an implementation done by iq in one of his examples, not sure though.  My bad\nfloat Hash(in vec2 p)\n{\n\tfloat h = dot(p, vec2(12.9898, 78.233));\n    return fract(sin(h) * 43758.5453);\n}\n\nfloat Noise(in vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\t\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(mix(Hash(i), Hash(i + vec2(1.0, 0.0)), u.x), mix(Hash(i + vec2(0.0, 1.0)), Hash(i + vec2(1.0)), u.x), u.y);   \n}\n\nfloat FractalBrownianMotion(in vec2 p)\n{\n   float f \n     = Noise(p) * 64.0\n     + Noise(p * 2.0) * 32.0\n   \t + Noise(p * 4.0) * 16.0\n     + Noise(p * 8.0) * 8.0\n     + Noise(p * 16.0) * 4.0\n     + Noise(p * 32.0) * 2.0\n     + Noise(p * 64.0);\n    \n    return f / (1.0 + 2.0 + 4.0 + 8.0 + 16.0 + 32.0 + 64.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 clampValues = vec2(0.5);\n    if(iMouse.z > 0.001)\n    {\n    \tclampValues = vec2(iMouse.x / iResolution.x, iMouse.y / iResolution.y);\n    }\n    vec2 textPoint = vec2(clampValues.x * iResolution.x, clampValues.y * iResolution.y);\n\n    vec3 finalColor;\n    if(uv.y > clampValues.y)\n    {\n        if(uv.x < clampValues.x)\n        {\n            finalColor = vec3(RandomNoise(uv));\n            float textBit = WriteRandomNoiseString(vec2(textPoint.x - 100.0, textPoint.y + 8.0), uv, 1.0);\n            if(textBit != -1.0)\n            {\n                finalColor = textBit * vec3(0.2, 0.8, 0.2);   \n            }\n        }\n        else\n        {\n            finalColor = vec3(Noise(uv * 400.0));\n            float textBit = WriteGenericNoiseString(vec2(textPoint.x + 10.0, textPoint.y + 8.0), uv, 1.0);\n            if(textBit != -1.0)\n            {\n                finalColor = textBit * vec3(1.0, 0.2, 0.2);   \n            }\n        }\n    }\n    else\n    {\n        if(uv.x < clampValues.x)\n        {\n            finalColor = vec3(FractalBrownianMotion(uv * 400.0));\n            float textBit = WriteFractalBrownianMotionString(vec2(textPoint.x - 378.0, textPoint.y - 15.0), uv, 1.0);\n            if(textBit != -1.0)\n            {\n                finalColor = textBit * vec3(0.8, 0.8, 0.2);   \n            }\n        }\n        else\n        {\n            finalColor = vec3(TextureNoise(uv * 2.0));\n            float textBit = WriteTextureNoiseString(vec2(textPoint.x + 10.0, textPoint.y - 15.0), uv, 1.0);\n            if(textBit != -1.0)\n            {\n                finalColor = textBit * vec3(0.5, 0.5, 1.0);   \n            }\n        }\n    }\n\n    // Dividers\n    vec3 dividerColor = vec3(0.7, 1.0, 0.7);\n    float divider = min(smoothstep(0.003, 0.005, abs(uv.x - clampValues.x)), smoothstep(0.003, 0.008, abs(uv.y - clampValues.y)));\n    finalColor = finalColor * divider + dividerColor * (1.0 - divider);\n    \n    fragColor = vec4(finalColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}