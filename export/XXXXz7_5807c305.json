{"ver":"0.1","info":{"id":"XXXXz7","date":"1709247204","viewed":124,"name":"plane through matrix determinant","username":"Cewein","description":"a plane define by a matrix determiant, funny but unpratical due to numerical error","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","matrix","plain","determinant"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Shader made by Maximilien \"Cewein\", february 2024\n//\n// This shader showcase how a determinant can define a \n// plane, we are looking when the determiantn is null\n// i.e when the volume is null. this mean for the ray\n// marcher that we are in the define plane and that the\n// world point is coplanar\n//\n//\n// Possible improvement :\n// \t\t- Anti-Aliasing\n//\n// main help came from here : \n// http://repo.darmajaya.ac.id/5422/1/Fundamentals%20of%20Computer%20Graphics%2C%20Fourth%20Edition%20%28%20PDFDrive%20%29.pdf\n//\n//\n\n\n///// CONSTANT /////\n\n#define MAX_STEP 256\n#define MAX_DIST 200.0\n\n\n\n///// RAY MARCHING FUNCTION /////\n\nvec2 map(vec3 pos)\n{\n    vec2 dm = vec2(0.0,0.5);\n    \n    float total = MAX_DIST;\n\n    //floor\n    float ground = pos.y;\n    if( total > ground) dm.y = 2.5;\n    total = min(total,ground);\n    \n    //define the 3x3 matrix define by 3 vector\n    mat3 plainMat = mat3(\n        vec3(0.0,0.5,0.0),\n        vec3(1.0,1.0,1.0),\n        vec3(0.0,1.0,1.0)\n    );\n    \n    for(int i = 0; i < 3; i++)\n    {\n        float sphere = length(pos - plainMat[i]) - 0.25;\n        plainMat[i] = plainMat[i] - pos;\n\n        if( total > sphere) dm.y = 3.5;\n        total = min(total,sphere);\n    }\n    \n    //we fine when the position is coplanar to the points define in the matrix\n    //the esp at the right is just for numerical precision\n    float plain = abs(determinant(plainMat))-0.001;\n    if( total > plain) dm.y = 4.5;\n    total = min(total,plain);\n    \n    \n    dm.x = total;\n    \n    return dm;\n}\n\n//raymarching loop\nhitPayload trace(hitPayload p)\n{\n    p.dist = 0.0;\n    for(int i = 0; i < MAX_STEP; i++)\n    {\n        p.hitPos = p.orig + p.dist * p.dir;\n        vec2 tmp = map(p.hitPos);\n        \n        if(tmp.x < 0.0001) return p;\n        \n        //update payload\n        p.nbStep = i;\n        p.dist += tmp.x;\n        p.mat = tmp.y;\n\n        if(p.dist > MAX_DIST) \n        {\n            p.mat = -1.0;\n            break;\n        }\n        \n    }\n    \n    return p;\n}\n\n///// SHADING FUNCTION /////\n\nvec3 calcNormal(vec3 pos)\n{\n    vec2 e = vec2(0.0001,0.);\n    return normalize(vec3(map(pos + e.xyy).x-map(pos-e.xyy).x,\n                          map(pos + e.yxy).x-map(pos-e.yxy).x,\n                          map(pos + e.yyx).x-map(pos-e.yyx).x)\n                    );\n}\n\n//this is the function that translate a material to the correct color\nvec3 getColor(hitPayload p)\n{\n    vec3 color = vec3(0.5, 0.7, 1.) - max(p.dir.y,0.0)*0.75;\n    \n    float zoom=.5;  \n    p.hitPos.xz=fract( p.hitPos.xz*zoom)*2.;\n    \n    if(p.mat > 2.0 ) //floor\n    {\n        //floor tilling \n        if(floor(p.hitPos.x)>.5==floor(p.hitPos.z)>.5)\n            color = vec3(0.6);\n        else\n            color = vec3(0.3);\n\n    }\n    if(p.mat > 3.0 ) //spheres\n    {\n        //red ball\n        color = vec3(1.0,0.0,0.0);\n\n    }\n    if(p.mat > 4.0 ) //determinante plane\n    {\n        //floor tilling \n        if(floor(p.hitPos.x)>.5==floor(p.hitPos.z)>.5)\n            color = vec3(0.6,0.6,0.0);\n        else\n            color = vec3(0.3,0.3,0.0);\n\n    }\n    \n    \n    return color;\n}\n\n\n///// RENDERING FUNCTION /////\n\n//this is the quick way to obtain a invervse view matrix\n//go to common to see alternative way with a long process\nmat4 getInvViewMatrix(vec3 ro, vec3 at)\n{\n    vec3 ww = normalize(at-ro); //front\n    vec3 uu = normalize(cross(ww, vec3(0.0,1.0,0.0))); // rigth;\n    vec3 vv = normalize(cross(uu,ww)); // up;\n    \n    return mat4(uu,0.,\n                vv,0.,\n                -ww,0.,\n                0.,0.,0.,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy - 1.0)/iResolution.y;\n    \n    //init camera para\n    float angle = 5.0*iMouse.x/iResolution.x;\n    float height = 5.0*iMouse.y/iResolution.y;\n    \n    //if screen has not been clicked yet\n    if(iMouse.x == 0.0 )\n    {\n        angle = 09.95;\n        height = 2.5;\n\n    }\n    \n    //ray origin and look at point\n    vec3 ro = vec3(10.0 * cos(angle), 4.0*height, 10.0 * sin(angle));\n    vec3 at = vec3(0.0,4.0,0.0);\n    \n    //ray direction\n    vec3 rd = normalize(getInvViewMatrix(ro,at) * vec4(uv,-1.5,1.0)).xyz;\n    \n    //init scope variable\n    vec3 color = vec3(0.5, 0.7, 1.) - max(rd.y,0.0)*0.5;\n    \n    //Using a struct make the code cleaner and\n    //will also shorten many function \n    hitPayload p = hitPayload(\n        ro, //postion aka origin at first\n        ro,\n        rd, //ray direction\n        vec3(0.0), //normal\n        -1.0, //material\n        0, //number of step\n        0.0 //total distance\n    );\n        \n    \n    //preform ray-marching\n    p = trace(p);\n    \n    //compute normal and get color\n    p.normal = calcNormal(p.orig + p.dist * p.dir);\n    color = getColor(p);\n    \n    //perform color grading before shadow (prefere this way)\n    color = pow(color,vec3(0.4545));\n    \n    //TODO : ADD LIGTHING\n\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"///// STRUCTURE /////\n\nstruct hitPayload\n{\n    vec3 orig;\n    vec3 hitPos;\n    vec3 dir;\n    vec3 normal;\n    float mat;\n    int nbStep;\n    float dist;\n};\n\n///// CONSTANTE /////\n\nconst float PI = atan(1.0)*4.0;\n\n///// SDF FUNCION /////\n//https://iquilezles.org/articles/distfunctions/\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n///// SDF OPERATION /////\n// https://iquilezles.org/articles/distfunctions/\n\nfloat opUnionRound( float a, float b, float k )\n{\n    float h = clamp( 0.5 + 0.5 * ( b - a ) / k, 0.0, 1.0 );\n    return mix( b, a, h ) - k * h * ( 1.0 - h );\n}\n\nfloat opSubstractRound( float a, float b, float r ) \n{\n\tvec2 u = max( vec2( r + a, r - b ), vec2( 0.0, 0.0 ) );\n\treturn min( -r, max( a, -b ) ) + length( u );\n}\n\nmat2 rot(in float a)\n{\n    a *= 0.0174533;\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, -s, s, c);\n}","name":"Common","description":"","type":"common"}]}