{"ver":"0.1","info":{"id":"stGBWm","date":"1664605620","viewed":94,"name":"Try Black Hole","username":"didibr","description":"Try create black hole, but not work with this textures","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["blackhole"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define STEP 0.05\n#define NSTEPS 200\n#define PI 3.141592653589793238462643383279\n#define DEG_TO_RAD (PI/180.0)\n#define ROT_Y(a) mat3(1, 0, 0, 0, cos(a), sin(a), 0, -sin(a), cos(a))\n#define ROT_Z(a) mat3(cos(a), -sin(a), 0, sin(a), cos(a), 0, 0, 0, 1)\n#define TAU 6.28318530718\n\n\n//uniform float time;\n//uniform vec2 resolution;\n\nvec3 cam_pos =vec3(0,0,-1);\nvec3 cam_dir=vec3(0,0,-1);\nvec3 cam_up=vec3(0,1,0);\nfloat fov=90.0;\nvec3 cam_vel=vec3(0,0,0);\n\nconst float MIN_TEMPERATURE = 1000.0;\nconst float TEMPERATURE_RANGE = 39000.0;\n\nbool accretion_disk=true;\nbool use_disk_texture=true;\nconst float DISK_IN = 1.0;\nconst float DISK_WIDTH = 6.0;\n\nbool doppler_shift=true;\nbool lorentz_transform=true;\nbool beaming=true;\n\n//uniform sampler2D iChannel0;//bg_texture;\n//uniform sampler2D iChannel1;//star_texture;\n//uniform sampler2D iChannel2;//disk_texture;\n\n\n\n\n\nvec2 square_frame(vec2 screen_size){\n  vec2 position = 6.0 * (gl_FragCoord.xy / screen_size.xy) - 3.0; \n  // first make pixels arranged in 0..1\n  // then by multiplying by 2 and subtracting 1, put them in -1..1\n  \n  return position;\n}\n\nvec2 to_spherical(vec3 cartesian_coord){\n  // spherical projection\n  // polar angles are directly used as horizontal and vertical coordinates\n  // here angle to y-axis mapped to latitude (looking vertically 180 degrees)\n  // xz plane to longitude (looking horizontally 360 degrees)\n  vec2 uv = vec2(atan(cartesian_coord.z,cartesian_coord.x), asin(cartesian_coord.y)); \n  uv *= vec2(1.0/(2.0*PI), 1.0/PI); //long, lat\n  uv += iTime*0.05;\n  return uv;\n}\n\nvec3 lorentz_transform_velocity(vec3 u, vec3 v){ \n  // u = ray\n  // v = observer\n  float speed = length(v);\n  if (speed > 0.0){\n    float gamma = 1.0/sqrt(1.0-dot(v,v));\n    \n    float denominator = 1.0 - dot(v,u);\n    \n    vec3 new_u = (u/gamma - v + (gamma/(gamma+1.0)) * dot(u,v)*v)/denominator;\n    return new_u;\n  }\n  return u;\n}\n\nvec3 temp_to_color(float temp_kelvin){\n  vec3 color;\n  // 1k ~ 40k rescale by dividing 100\n  temp_kelvin = clamp(temp_kelvin, 1000.0, 40000.0) / 100.0;\n  if (temp_kelvin <= 66.0){\n    color.r = 255.0;\n    color.g = temp_kelvin;\n    color.g = 99.4708025861 * log(color.g) - 161.1195681661;\n    if (color.g < 0.0) color.g = 0.0;\n    if (color.g > 255.0)  color.g = 255.0;\n  } else {\n    color.r = temp_kelvin - 60.0;\n    if (color.r < 0.0) color.r = 0.0;\n    color.r = 329.698727446 * pow(color.r, -0.1332047592);\n    if (color.r < 0.0) color.r = 0.0;\n    if (color.g > 255.0) color.r = 255.0;\n    color.g = temp_kelvin - 60.0;\n    if (color.g < 0.0) color.g = 0.0;\n    color.g = 288.1221695283 * pow(color.g, -0.0755148492);\n    if (color.g > 255.0)  color.g = 255.0;  \n  }\n  if (temp_kelvin >= 66.0){\n    color.b = 255.0;\n  } else if (temp_kelvin <= 19.0){\n    color.b = 0.0;\n  } else {\n    color.b = temp_kelvin - 10.0;\n    color.b = 138.5177312231 * log(color.b) - 305.0447927307;\n    if (color.b < 0.0) color.b = 0.0;\n    if (color.b > 255.0) color.b = 255.0;\n  }\n  color /= 255.0; // make it 0..1\n  return color;\n}\n\n//MarioX Addon\nfloat exponentialInOut(float t) {\n  return  \n       1.8 * pow(11.652, 1.0 - (t * 0.2)) + 2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    // Output to screen\n    //fragColor = vec4(col,1.0);  \n    float uvfov = tan(fov / 2.0 * DEG_TO_RAD);\n    vec2 uv = square_frame(iResolution.xy); \n    \n    uv *= vec2(iResolution.x/iResolution.y, 1.0);\n  vec3 forward = normalize(cam_dir); // \n  vec3 up = normalize(cam_up);\n  vec3 nright = normalize(cross(forward, up));\n  up = cross(nright, forward);\n  // generate ray\n  vec3 pixel_pos =cam_pos + forward +\n                 nright*uv.x*uvfov+ up*uv.y*uvfov;\n  \n  vec3 ray_dir = normalize(pixel_pos - cam_pos); // \n  \n   // light aberration alters ray path \n  if (lorentz_transform)\n    ray_dir = lorentz_transform_velocity(ray_dir, cam_vel);\n\n  \n  // initial color\n  vec4 color = vec4(0.0,0.0,0.0,1.0);\n\n  // geodesic by leapfrog integration\n\n  vec3 point = cam_pos;\n  vec3 velocity = ray_dir;\n  vec3 c = cross(point,velocity);\n  float h2 = dot(c,c);\n\n  \n  // for doppler effect\n  float ray_gamma = 1.0/sqrt(1.0-dot(cam_vel,cam_vel));\n  float ray_doppler_factor = ray_gamma * (1.0 + dot(ray_dir, -cam_vel));\n    \n    \n  float ray_intensity = 2.0;\n  if (beaming)\n    ray_intensity /= pow(ray_doppler_factor , 3.0);\n  \n  \n  vec3 oldpoint; \n  float pointsqr;\n  \n  float distance = length(point);\n  \n  // Leapfrog geodesic\n  for (int i=0; i<NSTEPS;i++){ \n    oldpoint = point; // remember previous point for finding intersection\n    point += velocity * STEP;\n    vec3 accel = -1.5 * h2 * point / pow(dot(point,point),2.5);\n    velocity += accel * STEP;    \n    \n    // distance from origin\n    distance = length(point);\n    if ( distance < 0.0) break;\n    \n    bool horizon_mask = distance < 1.0 && length(oldpoint) > 1.0;// intersecting eventhorizon\n    // does it enter event horizon?\n    if (horizon_mask) {\n      vec4 black = vec4(0.0,0.0,0.0,1.0);\n      color += black;\n      break;\n    }\n    \n    // intersect accretion disk\n    if (accretion_disk){\n      if (oldpoint.y * point.y < 0.0){\n        // move along y axis\n        float lambda = - oldpoint.y/velocity.y;\n        vec3 intersection = oldpoint + lambda*velocity;\n        float r = length(intersection);//dot(intersection,intersection);\n        if (DISK_IN <= r&&r <= DISK_IN+DISK_WIDTH ){\n          float phi = atan(intersection.x, intersection.z);\n          \n          vec3 disk_velocity = vec3(-intersection.x, 0.0, intersection.z)/sqrt(2.0*(r-1.0))/(r*r); \n          phi -= iTime;//length(r);\n          phi = mod(phi , PI*2.0);\n          float disk_gamma = 1.0/sqrt(1.0-dot(disk_velocity, disk_velocity));\n          float disk_doppler_factor = disk_gamma*(1.0+dot(ray_dir/distance, disk_velocity)); // from source \n          \n          if (use_disk_texture){\n          // texture\n            vec2 tex_coord = vec2(mod(phi,2.0*PI)/(2.0*PI),1.0-(r-DISK_IN)/(DISK_WIDTH));\n            vec4 disk_color = texture(iChannel2, tex_coord) / (ray_doppler_factor * disk_doppler_factor);\n            float disk_alpha = clamp(dot(disk_color,disk_color)/4.5,0.0,1.0);\n\n            if (beaming)\n              disk_alpha /= pow(disk_doppler_factor,3.0);\n            \n            color += vec4(disk_color)*disk_alpha;\n          } else {\n          \n          // use blackbody \n          float disk_temperature = 10000.0*(pow(r/DISK_IN, -3.0/4.0));\n          \n            //doppler effect\n          if (doppler_shift)\n            disk_temperature /= ray_doppler_factor*disk_doppler_factor;\n\n          vec3 disk_color = temp_to_color(disk_temperature);\n          float disk_alpha = clamp(dot(disk_color,disk_color)/3.0,0.0,1.0);\n          \n          if (beaming)\n            disk_alpha /= pow(disk_doppler_factor,3.0);\n            \n          \n          color += vec4(disk_color, 1.0)*disk_alpha;\n          \n          }\n        }\n      }\n    }\n    \n  }\n  //Last part\n  \n  if (distance > 1.0){\n    ray_dir = normalize(point - oldpoint);\n    vec2 tex_coord = to_spherical(ray_dir * ROT_Z(45.0 * DEG_TO_RAD));\n    // taken from source\n    // red = temp\n    // green = lum\n    // blue = vel \n    //vec4 star_color = texture2D(star_texture, tex_coord);\n\n// MarioXRotTaion\n    vec2 textureOffset = vec2(-0.5);\n    float easedProgress = exponentialInOut(mod(iTime * 0.03, 0.1));\n    float rotation = easedProgress * TAU;\n    float aspect = 5.32/3.;\n    float zoom = 1.7;\n    //zoom += 0.6 * sin(rotation / 2.);\n\n    // rotate\n    vec2 uv2 = gl_FragCoord.xy / iResolution.xy;\n    uv2 = vec2((uv2.x - 0.5) * (iResolution.x / iResolution.y), uv2.y - 0.5);\n\tuv2 *= (2. - zoom) / 2.;\n    uv2 *= mat2(cos(rotation), sin(rotation), -sin(rotation), cos(rotation));\n    uv2.y *= aspect;\n    //vec4 color = texture(iChannel0, uv2 - textureOffset);\n    //fragColor = color;\n    \n    vec4 star_color= texture(iChannel1, uv2 - textureOffset);\n    \n    if (star_color.g > 0.0){\n      float star_temperature = (MIN_TEMPERATURE + TEMPERATURE_RANGE*star_color.r);\n      // arbitrarily sets background stars' velocity for random shifts\n      float star_velocity = star_color.b - 0.5;\n      float star_doppler_factor = sqrt((1.0+star_velocity)/(1.0-star_velocity));\n      if (doppler_shift)\n        star_temperature /= ray_doppler_factor*star_doppler_factor;\n      \n      color += (vec4(temp_to_color(star_temperature),1.0)* star_color.g)*0.02;\n      \n    }\n\n    color += texture(iChannel0, tex_coord) * 0.30;\n// gl_FragColor = color;\n\n\n\n  }\n\n  \n\n  \n  //gl_FragColor = color*ray_intensity;\n   fragColor = color*ray_intensity;\n\n}","name":"Image","description":"","type":"image"}]}