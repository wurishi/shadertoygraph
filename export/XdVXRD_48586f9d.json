{"ver":"0.1","info":{"id":"XdVXRD","date":"1463240167","viewed":504,"name":"Isosurface raycasting","username":"mpj500","description":"Started with ray/AABB code from J-E-L-L-O by @demofox ([url]https://www.shadertoy.com/view/4lXSDf[/url]). Added some within-cell isosurface ray tracing.","likes":5,"published":1,"flags":0,"usePreview":1,"tags":["isosurface"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define FLT_MAX 3.402823466e+38\n#define PI 3.1415926536\n\nconst float c_scale = 1.0;\n\n//=======================================================================================\n\nfloat snoise(vec3 p) {\n\t\n    float igt = iTime * 0.01;\n    vec2 uv = p.xy + vec2(17.0,7.0)*(p.z+igt);\n\tvec2 rg = texture( iChannel0, (uv+0.5)/256.0, -100.0 ).yx;\n\treturn (rg.x - 0.5)*55.5;\n}\n\n//=======================================================================================\n\nfloat RayIntersectAABoxMax (in ivec3 cellPos, in vec3 rayPos, in vec3 rayDir)\n{\n    vec3 boxMid = vec3(cellPos)+vec3(0.5);\n    \n\tvec3 roo = rayPos - boxMid;\n    vec3 rad = vec3(0.5);\n\n    vec3 m = 1.0/rayDir;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t2 = -n + k;\n\n    return min( min( t2.x, t2.y ), t2.z );\n}\n\nfloat RayIntersectAABoxMin (in ivec3 cellPos, in vec3 rayPos, in vec3 rayDir)\n{\n    vec3 boxMid = vec3(cellPos)+vec3(0.5);\n    \n\tvec3 roo = rayPos - boxMid;\n    vec3 rad = vec3(0.5);\n\n    vec3 m = 1.0/rayDir;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n\n    return max( max( t1.x, t1.y ), t1.z );\n}\n\nfloat CubicLERP(vec4 A, vec4 B, vec3 p)\n{\n    return mix( mix( mix(A.x, A.y, p.x),\n                     mix(A.z, A.w, p.x), p.y),\n                mix( mix(B.x, B.y, p.x),\n                     mix(B.z, B.w, p.x), p.y), p.z);\n}\n\nfloat DistanceFunc_ (in vec3 p)\n{\n    ivec3 cellPos = ivec3(floor(p));\n    \n    vec4 A = vec4(snoise(vec3(cellPos+ivec3(0,0,0))),\n              snoise(vec3(cellPos+ivec3(1,0,0))),\n\t \t\t  snoise(vec3(cellPos+ivec3(0,1,0))),\n\t \t\t  snoise(vec3(cellPos+ivec3(1,1,0))));\n\n    vec4 B = vec4(snoise(vec3(cellPos+ivec3(0,0,1))),\n              snoise(vec3(cellPos+ivec3(1,0,1))),\n\t \t\t  snoise(vec3(cellPos+ivec3(0,1,1))),\n\t \t\t  snoise(vec3(cellPos+ivec3(1,1,1))));\n\n    return CubicLERP(A,B, p - vec3(cellPos));\n}\n\n\nfloat DistanceFunc (in vec3 p)\n{\n    p *= c_scale;\n    \n    vec3 fp = floor(p);\n    ivec3 cellPos = ivec3(fp);\n   \n    vec4 A = vec4(DistanceFunc_(vec3(cellPos+ivec3(0,0,0))),\n              DistanceFunc_(vec3(cellPos+ivec3(1,0,0))),\n\t \t\t  DistanceFunc_(vec3(cellPos+ivec3(0,1,0))),\n\t \t\t  DistanceFunc_(vec3(cellPos+ivec3(1,1,0))));\n\n    vec4 B = vec4(DistanceFunc_(vec3(cellPos+ivec3(0,0,1))),\n              DistanceFunc_(vec3(cellPos+ivec3(1,0,1))),\n\t \t\t  DistanceFunc_(vec3(cellPos+ivec3(0,1,1))),\n\t \t\t  DistanceFunc_(vec3(cellPos+ivec3(1,1,1))));\n    \n    return CubicLERP(A,B,p-fp);\n}\n\n///////////////////////////////////////////////////////////////////////////////////////////\n// Adaptation of SolveCubic from \"Roots3And4.c\" by Jochen Schwarze found in Graphics Gems\n///////////////////////////////////////////////////////////////////////////////////////////\n\nfloat cbrt( float x )\n{\n    return pow(abs(x), 1.0/3.0) * sign(x);\n}\n\nvec2 SolveQuadric(vec3 coeff)\n{\n    float c0 = coeff.x;\n    float c1 = coeff.y;\n    float c2 = coeff.z;\n\n    // normal form: x^2 + px + q = 0\n\n    float p = c1 / (2.0 * c2);\n    float q = c0 / c2;\n\n    float D = p * p - q;\n\n    if (D < 0.0)\n    {\n\t\treturn vec2(FLT_MAX);\n    }\n    float sqrt_D = sqrt(D);\n    return vec2( sqrt_D - p, -sqrt_D - p );\n}\n\nvec3 SolveCubic(vec4 coeff)\n{\n    vec3 s;\n    \n    if( abs(coeff.x) < 0.01 )\n    {\n        return SolveQuadric(coeff.wzy).xyy;\n    }\n    \n    // normal form: x^3 + Ax^2 + Bx + C = 0\n\n    vec3 ABC = coeff.yzw / coeff.x;\n    float A = ABC.x;\n    float B = ABC.y;\n    float C = ABC.z;\n\n    // substitute x = y - A/3 to eliminate quadric term:\n\t// x^3 +px + q = 0\n\n    float sq_A = A * A;\n    float p = (-1.0/3.0  * sq_A + B) / 3.0;\n    float q = ( 2.0/27.0 * A * sq_A - 1.0/3.0 * A * B + C) / 2.0;\n\n    // use Cardano's formula\n\n    float cb_p = p * p * p;\n    float D = q * q + cb_p;\n\n    if (D < 0.0) // Casus irreducibilis: three real solutions\n    {\n        float phi = 1.0/3.0 * acos(-q * inversesqrt(-cb_p));\n        float t = 2.0 * sqrt(-p);\n\n        s = t * vec3(cos(phi), -cos(phi + PI / 3.0), -cos(phi - PI / 3.0));\n    }\n    else // one real solution\n    {\n        float sqrt_D = sqrt(D);\n        float u =  cbrt(sqrt_D - q);\n        float v = -cbrt(sqrt_D + q);\n\n        s = vec3(u + v);\n    }\n\n    // resubstitute\n    return s - vec3(A/3.0);\n}\n\nconst mat4 isoCubicCoeff = mat4(\n    vec4( -9.0/2.0, 27.0/2.0, -27.0/2.0, 9.0/2.0),\n    vec4(  9.0,    -45.0/2.0,  18.0,    -9.0/2.0),\n    vec4(-11.0/2.0,  9.0,      -9.0/2.0, 1.0),\n    vec4(  1.0,      0.0,       0.0,     0.0));\n\n///////////////////////////////////////////////////////////////////////////////////////////\n// Cubic polynomial equation from:\n// \"Analytic Isosurface Rendering and Maximum Intensity Projection on the GPU\"\n///////////////////////////////////////////////////////////////////////////////////////////\n\nfloat DoRootFinding( vec3 o, vec3 disp)\n{\n    vec4 samples = vec4(DistanceFunc(o),\n                        DistanceFunc(o + disp*(1.0/3.0)),\n                        DistanceFunc(o + disp*(2.0/3.0)),\n                        DistanceFunc(o + disp));\n    \n    if( samples.x < 0.0 )\n    {\n        return -1.0;\n    }\n\n    vec3 s = SolveCubic(samples * isoCubicCoeff);\n    \n    float tmin = 1.0;\n    if( s.x >=0.0 && s.x < tmin ) tmin = s.x;\n    if( s.y >=0.0 && s.y < tmin ) tmin = s.y;\n    if( s.z >=0.0 && s.z < tmin ) tmin = s.z;\n    \n    return tmin;\n}\n\n\n//=======================================================================================\nvec3 HandleRay (in ivec3 cellPos, in vec3 rayPos, in vec3 rayDir, inout float hitTime)\n{\n    // calculate surface normal\n    float tMin = RayIntersectAABoxMin(cellPos, rayPos, rayDir);\n    float tMax = RayIntersectAABoxMax(cellPos, rayPos, rayDir);\n    \n    if( tMin>tMax && tMin > 0.0 )\n    {\n        hitTime = FLT_MAX;\n        return vec3(1.0);\n    }\n   \tif( tMin > hitTime )\n    {\n        hitTime = FLT_MAX;\n        return vec3(0.0);        \n    }\n    \n    vec3 frontCollisionPos = rayPos + rayDir*tMin;\n    vec3 backCollisionPos = rayPos + rayDir*tMax;\n    \n    float tt = DoRootFinding(frontCollisionPos, backCollisionPos - frontCollisionPos);\n    if( tt < 1.0 )\n    {\n        if( tt < 0.0 )\n        {\n            hitTime = tMin;\n        \treturn vec3(1.0,0.0,0.0);\n        }\n        \n        hitTime = mix(tMin,tMax, tt);\n        return vec3(0.0,1.0,0.0);\n    }\n    hitTime = FLT_MAX;\n    return vec3(1.0);\n}\n\n//=======================================================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{       \n    //----- camera\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\n    vec3 cameraAt = vec3(0.5);\n\n    float angleX = iMouse.z > 0.0 ? 6.28 * mouse.x : 3.14 + iTime * 0.25;\n    float angleY = iMouse.z > 0.0 ? (mouse.y * 6.28) - 0.4 : 0.5;\n    vec3 cameraPos\t= (vec3(sin(angleX)*cos(angleY), sin(angleY), cos(angleX)*cos(angleY))) * (9.0 + 2.0 * (sin(iTime)*0.5+0.5));\n    cameraPos += vec3(0.5);\n\n    vec3 cameraFwd  = normalize(cameraAt - cameraPos);\n    vec3 cameraLeft  = normalize(cross(normalize(cameraAt - cameraPos), vec3(0.0,sign(cos(angleY)),0.0)));\n    vec3 cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n\n    float cameraViewWidth\t= 6.0;\n    float cameraViewHeight\t= cameraViewWidth * iResolution.y / iResolution.x;\n    float cameraDistance\t= 6.0;  // intuitively backwards!\n\t\n\t\t\n\t// Objects\n\tvec2 rawPercent = (fragCoord.xy / iResolution.xy);\n\tvec2 percent = rawPercent - vec2(0.5,0.5);\n\t\n\tvec3 rayTarget = (cameraFwd * vec3(cameraDistance,cameraDistance,cameraDistance))\n\t\t\t\t   - (cameraLeft * percent.x * cameraViewWidth)\n\t\t           + (cameraUp * percent.y * cameraViewHeight);\n\tvec3 rayDir = normalize(rayTarget);\n\t\n\t\n    float skyY = 0.8+rayDir.y;\n    vec3 minPixCol = vec3(0.3,0.6,1.0)*skyY;\n    float minHitTime = FLT_MAX;\n    \n    const int xs = 2;\n    const int ys = 2;\n    const int zs = 2;\n    \n    for( int z=-zs;z<=zs; z++)\n    {\n        for( int y=-ys;y<=ys; y++)\n        {\n            for( int x=-xs;x<=xs; x++)\n            {\n                float hitTime = minHitTime;\n\t\t\t\tvec3 pixelColor = HandleRay(ivec3(x,y,z), cameraPos, rayDir, hitTime);\n                \n                if( hitTime < minHitTime )\n                {\n                    vec3 pos = cameraPos + rayDir * hitTime;\n                    pos *= 2.0;\n                    vec3 cellPos = pos - floor(pos);\n                    float gridMin = min(min(cellPos.x,cellPos.y),cellPos.z);\n                    float gridMax = max(max(cellPos.x,cellPos.y),cellPos.z);\n                    gridMin = min(gridMin, 1.0-gridMax);\n                    \n                    float gridScale = gridMin < 0.05 ? 0.5 : 1.0;\n                                        \n                    \n                    minHitTime = hitTime;\n                    minPixCol = pixelColor * gridScale;\n                }\n            }\n        }\n    }\n    \n    if( minHitTime < FLT_MAX )\n    {\n        // calculate and apply absorption\n    \tvec3 c_absorb = vec3(1.8,1.8,1.8)*0.2;\n    \tvec3 absorb = vec3(exp(-c_absorb * (minHitTime-7.0)));\n    \tminPixCol *= absorb;\n    }\n    \n    fragColor = vec4(clamp(minPixCol,0.0,1.0), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}