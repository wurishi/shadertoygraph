{"ver":"0.1","info":{"id":"csdcWj","date":"1695562949","viewed":73,"name":"Hilbert Curve _|-|_","username":"VL","description":".","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["pattern"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define int2 ivec2\n#define float2 vec2\n#define int3 ivec3\n#define float3 vec3\n#define int4 ivec4\n#define float4 vec4\n#define frac fract\n#define float2x2 mat2\n#define float3x3 mat3\n#define float4x4 mat4\n#define saturate(x) clamp(x,0.,1.)\n#define lerp mix\n#define sincos(x,s,c) s = sin(x),c = cos(x)\n#define mul(x,y) (x*y)\n#define atan2 atan\n#define fmod mod\n\n//https://en.wikipedia.org/wiki/Hilbert_curve\nint gridToHilbert(int2 gridIdx, int p2Level, out bool bounded)\n{\n    bounded = 0 <= gridIdx.x && gridIdx.x < p2Level && 0 <= gridIdx.y && gridIdx.y < p2Level;\n    \n    int d = 0;\n    int2 r;\n    for (int s = p2Level >> 1; s > 0; s >>= 1)\n    {\n        r.x = int((gridIdx.x & s) > 0);\n        r.y = int((gridIdx.y & s) > 0);\n        d += s * s * ((3 * r.x) ^ r.y);\n        \n        if (r.y == 0)\n        {\n            if (r.x == 1)\n                gridIdx = p2Level - 1 - gridIdx;            \n            gridIdx = gridIdx.yx;\n        }\n    }\n    \n    return bounded ? d : -10;\n}\n\nfloat minkowskiLength(float2 v, float p)\n{\n    v = abs(v);\n    return pow(pow(v.x,p)+pow(v.y,p), 1.f / p);\n}\n\nfloat hilbertCurve(float2 p, int level, float tickness, float roundness) \n{\n    //int p4Level = 1 << (level << 1);\n    \n    int p2Level = 1 << level;\n    p *= float(p2Level);\n        \n    int2 gridIdx = int2(floor(p));\n    p -= float2(gridIdx) + 0.5;    \n    \n    bool bounded;\n    int hilbertIdx = gridToHilbert(gridIdx + int2(0,0), p2Level, bounded);\n    float dist = bounded ?  minkowskiLength(p, roundness): 100.0;    \n    \n    int hilbertIdxLeft = gridToHilbert(gridIdx + int2(-1,0), p2Level, bounded);\n    int hilbertIdxRight = gridToHilbert(gridIdx + int2(1,0), p2Level, bounded);\n    int hilbertIdxDown = gridToHilbert(gridIdx + int2(0,-1), p2Level, bounded);\n    int hilbertIdxUp = gridToHilbert(gridIdx + int2(0,1), p2Level, bounded);    \n\n    if(abs(hilbertIdx - hilbertIdxLeft) == 1)\n        dist = p.x < 0.0 ? min(dist, abs(p.y)) : dist;\n        \n    if(abs(hilbertIdx - hilbertIdxRight) == 1)\n        dist = p.x > 0.0 ? min(dist, abs(p.y)) : dist;  \n        \n    if(abs(hilbertIdx - hilbertIdxDown) == 1)\n        dist = p.y < 0.0 ? min(dist, abs(p.x)) : dist; \n        \n    if(abs(hilbertIdx - hilbertIdxUp) == 1)\n        dist = p.y > 0.0 ? min(dist, abs(p.x)) : dist;          \n\n    return smoothstep(0.002 * float(p2Level), 0.0, dist - tickness);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    vec2 uv = fragCoord / iResolution.y;\n    uv.x -= iResolution.x / iResolution.y * 0.5 - 0.5;    \n    \n    \n    int level = int(fmod(iTime*0.5, 8.0));\n    float tickness = sin(iTime*0.8)* sin(iTime*0.8)*0.2;\n    float roundness = sin(iTime*0.9)* sin(iTime*0.9)*15.0+1.0;\n    \n    fragColor = vec4(vec3(1.0 - hilbertCurve(uv, level, tickness, roundness)), 1.0);\n}","name":"Image","description":"","type":"image"}]}