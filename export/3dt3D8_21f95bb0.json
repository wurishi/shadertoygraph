{"ver":"0.1","info":{"id":"3dt3D8","date":"1569152420","viewed":1159,"name":"Music synthesizer","username":"TambakoJaguar","description":"I used my knowledge in electronic music and synthesizers to create this music track made 100% with GPU sound (and some math), but I had to restrain a lot of stuff to keep decent compile times. Anyway, I could add this simple visualization of the tracks!","likes":31,"published":1,"flags":40,"usePreview":0,"tags":["sound","music","beat","fm","bpm","synthesis","synth","sequencer","synthesizer","bass","pad","electronic","gpusound","chords","instruments","edm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t#ifdef VIZUALISATION\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0,uv);\n    #else\n    fragColor = vec4(0.);\n    #endif\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n\nvec2 mainSound( in int samp,float time)\n{\n   float time2 = time + startTime;\n    \n   if (time2<0.)\n       return vec2(0.);    \n    \n   onlyEnvelope = false;\n   init(time2);\n   vec2 sound = vec2(0.);\n    \n   #ifdef SOLO_TRACK\n      sound = playTrack(SOLO_TRACK, time2);\n   #else\n   for (int t = 1; t <= tracks.length(); t++)\n      sound+= playTrack(t, time2);\n   #endif\n    \n   return gvolume*sound*exp(-0.24*max(time2 - 165., 0.))*smoothstep(180., 175., time2);\n}","name":"Sound","description":"","type":"sound"},{"inputs":[],"outputs":[],"code":"/*\n\"Music synthesizer\" by Emmanuel Keller aka Tambako - September 2019\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n*/\n\n#define tpi 6.2831\n\n//#define ZERO 0\n#define ZERO int(min(time,0.))\n\n// note frequencies\n#define FC  261.626\n#define FCH 277.183\n#define FD  293.665\n#define FDH 311.127\n#define FE  329.628\n#define FF  349.228\n#define FFH 369.994\n#define FG  391.995\n#define FGH 415.305\n#define FA  440.000\n#define FAH 466.164\n#define FB  493.883\n\nstruct Note\n{\n   float freq;\n   float octave;\n   float velocity;\n   float length;\n   float gateOpening;\n};\n\nstruct Track\n{\n   float playtime;\n   float loopBars;\n   float tVolume;\n   float tTune;\n   float tBalance;\n   int instrumentNr;\n   vec3 color;\n};\n    \nstruct Instrument\n{\n   float iVolume;\n   int waveform;\n   vec3 wfParams;\n   vec4 envelope;\n   vec4 fmParams;\n   vec3 detuneParams;\n   vec3 echoParams;\n};\n    \nTrack tracks[6];\nInstrument instruments[5];\n\nint chordNr;\nvec2[4] bassNotes;\nfloat bassNote;\nfloat bassOctave;\nvec3[5] rChord;\nvec3[5] padChord;\nfloat arpOctave = 6.;\nfloat arpNote1;\nfloat arpNote2;\nfloat arpNote3;\n\nfloat bartime;\nfloat barnr0;\nfloat barnr;\n\nbool onlyEnvelope;\n\n// General options\n//#define SOLO_TRACK 6\n#define VIZUALISATION\n#define NEW_CHORDS\n//#define ECHO\n\nconst float bpm = 132.;\nconst float startTime = -0.5;\nconst float gvolume = 0.15;\nconst float gtune = 1.;\nconst float stereoPhase = 0.25;\n\nvoid init(float time)\n{\n   bartime = 240./bpm;\n   barnr0 = time/bartime;\n   barnr = floor(barnr0);\n   chordNr = int(mod(barnr/2., 4.));\n    \n   // Song progression\n   // Melody\n   float track1On = mod(barnr, 64.)>=16.?1.:0.;\n   // Bass\n   float track2On = barnr>=4.?(mod(barnr, 64.)<56.?1.:0.):0.;\n   // Chords\n   float track3On = barnr>=8.?(barnr<48.?smoothstep(40., 32., barnr0):1.):0.;\n   // Pad\n   float track4On = mod(barnr, 64.)<48.?(barnr>=64.?smoothstep(64., 72., barnr0):1.):0.;\n   // Arp\n   float track5On = mod(barnr, 64.)>=24.?1.:0.;\n   // Beat\n   float track6On = barnr>=8.?1.:0.;\n    \n   // Melody\n   tracks[0] = Track(0., 2., track1On*1.15, 1., -0.1, 1, vec3(1., 0.7, 0.5));\n   // Bass\n   tracks[1] = Track(0., 0.5, track2On*0.9, 1., 0., 3, vec3(0.3, 1., 0.9));\n   // Chords\n   tracks[2] = Track(0., 0.5, track3On*0.4, 1., 0.25, 2, vec3(1., 0.9, 0.6));\n   // Pad\n   tracks[3] = Track(-0.5, 2., track4On*0.27, 1., -0.25, 4, vec3(0.3, 0.9, 1.3));\n   // Arp\n   tracks[4] = Track(0., 0.125, track5On*0.28, 1., 0.5*sin(1.2*time), 5, vec3(2.2, 0.3, 1.3));\n   // Beat\n   tracks[5] = Track(0., 1., track6On*1.5, 1., 0., 1, vec3(1., 1., 1.));\n    \n   // Melody\n   instruments[0] = Instrument(1., 1, vec3(0.18 + 0.12*sin(30.*time), 0., 0.), vec4(0.02, 0.2, 0.5, 0.5), vec4(0.3, 5., 0., 3.), vec3(0., 0, 0.1), vec3(7, 0.65, 5.));\n   // Chords\n   instruments[1] = Instrument(1., 2, vec3(0.3, 2., 0.), vec4(0.001, 0.2, 0.55, 1.1), vec4(0.9, 1.5, 0., 5.), vec3(0.13, 9, 0.15), vec3(0, 1., 8.));\n   // Bass\n   instruments[2] = Instrument(1., 1, vec3(.7, 1., 0.), vec4(0.04, 0.02, 0.8, 0.05), vec4(1.1, 2., 0., 8.), vec3(0., 0, 0.1), vec3(0, 1., 8.));\n   // Pad\n   instruments[3] = Instrument(1., 4, vec3(0.85, 1.1, 0.), vec4(1.8, 0.15, 1., 1.8), vec4(0.22, 3., 0., 0.4), vec3(0.25, 5, 0.5), vec3(0, 1., 8.));  \n   // Arp\n   instruments[4] = Instrument(1., 3, vec3(1. - 0.25*sin(0.9*time), 10., 0.), vec4(0.003, 0.01, 1., 0.05), vec4(1.1 - 0.5*sin(1.7*time), 2.5, 0., 15.), vec3(0., 0, 0.1), vec3(0, 1., 8.));\n    \n   // Main notes and chords\n   #ifdef NEW_CHORDS\n   if (chordNr==0) {bassNote=FD; bassOctave=1.;}\n   if (chordNr==1) {bassNote=FF; bassOctave=1.;}\n   if (chordNr==2) {bassNote=FG; bassOctave=0.;}\n   if (chordNr==3) {bassNote=FE; bassOctave=1.;}  \n    \n   if (chordNr==0) rChord = vec3[](vec3(FD, 4., .5), vec3(FFH, 4., .5), vec3(FA, 4., .5), vec3(FD, 5., .3), vec3(FD, 6., .15));\n   if (chordNr==1) rChord = vec3[](vec3(FF, 4., .5), vec3(FA, 4., .5), vec3(FC, 4., .5), vec3(FF, 5., .3), vec3(FF, 6., .15));\n   if (chordNr==2) rChord = vec3[](vec3(FG, 4., .5), vec3(FB, 4., .5), vec3(FD, 4., .5), vec3(FD, 5., .3), vec3(FD, 6., .15));\n   if (chordNr==3) rChord = vec3[](vec3(FE, 4., .5), vec3(FG, 4., .5), vec3(FC, 4., .5), vec3(FC, 5., .3), vec3(FC, 6., .15));\n    \n   if (chordNr==0) padChord = vec3[](vec3(FD, 3., .5), vec3(FFH, 3., .5), vec3(FA, 3., .5), vec3(FD, 2., .2), vec3(FD, 1., .1));\n   if (chordNr==1) padChord = vec3[](vec3(FF, 3., .5), vec3(FA, 3., .5), vec3(FC, 3., .5), vec3(FF, 2., .2), vec3(FF, 1., .1));\n   if (chordNr==2) padChord = vec3[](vec3(FG, 3., .5), vec3(FB, 3., .5), vec3(FD, 3., .5), vec3(FD, 2., .2), vec3(FD, 1., .1));\n   if (chordNr==3) padChord = vec3[](vec3(FE, 3., .5), vec3(FG, 3., .5), vec3(FC, 3., .5), vec3(FC, 2., .2), vec3(FC, 1., .1));\n\n   if (chordNr==0) {arpNote1=FD; arpNote2=FFH; arpNote3=FA;}\n   if (chordNr==1) {arpNote1=FF; arpNote2=FA; arpNote3=FC;}\n   if (chordNr==2) {arpNote1=FG; arpNote2=FB; arpNote3=FD;}    \n   if (chordNr==3) {arpNote1=FE; arpNote2=FG; arpNote3=FC;}      \n   #else\n   if (chordNr==0) {bassNote=FD; bassOctave=1.;}\n   if (chordNr==1) {bassNote=FF; bassOctave=1.;}\n   if (chordNr==2) {bassNote=FA; bassOctave=0.;}\n   if (chordNr==3) {bassNote=FE; bassOctave=1.;}  \n    \n   if (chordNr==0) rChord = vec3[](vec3(FD, 4., .5), vec3(FF, 4., .5), vec3(FA, 4., .5), vec3(FD, 5., .3), vec3(FD, 6., .15));\n   if (chordNr==1) rChord = vec3[](vec3(FF, 4., .5), vec3(FA, 4., .5), vec3(FC, 4., .5), vec3(FF, 5., .3), vec3(FF, 6., .15));\n   if (chordNr==2) rChord = vec3[](vec3(FA, 4., .5), vec3(FC, 4., .5), vec3(FE, 4., .5), vec3(FA, 5., .3), vec3(FA, 6., .15));\n   if (chordNr==3) rChord = vec3[](vec3(FE, 4., .5), vec3(FGH, 4., .5), vec3(FB, 4., .5), vec3(FE, 5., .3), vec3(FE, 6., .15));\n    \n   if (chordNr==0) padChord = vec3[](vec3(FD, 3., .5), vec3(FF, 3., .5), vec3(FA, 3., .5), vec3(FD, 2., .2), vec3(FD, 1., .1));\n   if (chordNr==1) padChord = vec3[](vec3(FF, 3., .5), vec3(FA, 3., .5), vec3(FC, 3., .5), vec3(FF, 2., .2), vec3(FF, 1., .1));\n   if (chordNr==2) padChord = vec3[](vec3(FA, 3., .5), vec3(FC, 3., .5), vec3(FE, 3., .5), vec3(FA, 2., .2), vec3(FA, 1., .1));\n   if (chordNr==3) padChord = vec3[](vec3(FE, 3., .5), vec3(FGH, 3., .5), vec3(FB, 3., .5), vec3(FE, 2., .2), vec3(FE, 1., .1));\n\n   if (chordNr==0) {arpNote1=FD; arpNote2=FF; arpNote3=FA;}\n   if (chordNr==1) {arpNote1=FF; arpNote2=FA; arpNote3=FC;}\n   if (chordNr==2) {arpNote1=FA; arpNote2=FC; arpNote3=FE;}\n   if (chordNr==3) {arpNote1=FE; arpNote2=FGH; arpNote3=FB;}  \n   #endif\n}\n\nfloat hash(float p)\n{\n    p = fract(p*(258.6 + 0.00007*(fract(p*0.55))));\n    p *= p + 353.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat getFM(float time, float freq, vec4 FMParams)\n{\n   if (FMParams.x>0.)\n      return FMParams.x*sin(time*tpi*(freq*FMParams.y + FMParams.z))*exp(-FMParams.w*time);\n   else\n      return 0.;\n}\n\nvec2 balance(float b)\n{\n    return vec2(clamp(1. - b, 0., 1.), clamp(b + 1., 0., 1.));\n}\n\nfloat osc(int instrument, float time, int waveform, float ampl, float freq, float phase, float p1, float p2, float p3)\n{    \n   freq+= getFM(time, freq, instruments[instrument].fmParams);    \n    \n   // Sin to Square, param1 = squareness\n   if (waveform==1)\n      return ampl*(2.*smoothstep(-p1*(1. - exp(-p2*time)), p1*(1. - exp(-p2*time)), sin(tpi*freq*time + phase*tpi)) - 1.);\n   // Triangle to sawtooth, param1 = type\n   if (waveform==2)\n   {\n      float tt = fract(freq*time + phase);\n      return ampl*(2.*smoothstep(0., p1*(1. - exp(-p2*time)), tt)*smoothstep(1., p1*(1. - exp(-p2*time)), tt) - 1.);\n   }\n   // Straigtened sine, param1 = offset\n   if (waveform==3)\n      return ampl*(2.*abs(sin(tpi*freq*time + phase*tpi) + p1*(1. - exp(-p2*time)))*2. - 1.);\n   // PWM Square, param1 = opening\n   if (waveform==4)\n   {\n      float tt = fract(freq*time + phase);\n      return ampl*(tt>p1*(1. - exp(-p2*time))?1.:-1.);\n   }    \n}\n\nvec2 stereoOsc(int instrument, float time, int waveform, float ampl, float freq, float p1, float p2, float p3)\n{\n   return vec2(osc(instrument, time, waveform, ampl, freq, 0., p1, p2, p3), osc(instrument, time, waveform, ampl, freq, stereoPhase, p1, p2, p3));\n}\n\nvec2 stereoOscDetune(int instrument, float time, int waveform, float ampl, float freq, float p1, float p2, float p3)\n{\n    vec2 s = vec2(0.);\n    int ns = int(instruments[instrument].detuneParams.y);\n    if (ns<2)\n       return stereoOsc(instrument, time, waveform, ampl, freq, p1, p2, p3);\n    else\n    {\n       for (int n = ZERO; n < ns; n++)\n       {\n          float fo = freq*0.01*instruments[instrument].detuneParams.x*float(n - ns/2);\n          float b = instruments[instrument].detuneParams.z*float(n - ns/2);\n           \n          s+= balance(b)*stereoOsc(instrument, time, waveform, ampl, freq + fo, p1, p2, p3); \n       }\n    }\n    return s;\n}\n\nfloat envelope(float time, float a, float d, float s, float r, float noteDuration)\n{\n    float e = smoothstep(0., a, time);\n    e*= s + (1. - s)*smoothstep(a + d, a, time);\n    e*= smoothstep(noteDuration + r, noteDuration, time);\n    \n    return e;\n}\n\nvec2 note0(int track, float time, float freq, float octave, float velocity, float duration, float gateOpening)\n{\n   vec2 notev;\n   float ltime = time - tracks[track].playtime;\n   Instrument cInstrument = instruments[tracks[track].instrumentNr - 1];\n    \n   freq*= gtune*tracks[track].tTune; \n    \n   if (velocity>0.)\n   {\n      freq*= pow(2., octave - 3.);\n       \n      float env = envelope(ltime, cInstrument.envelope.x, cInstrument.envelope.y, cInstrument.envelope.z, cInstrument.envelope.w, bartime/duration*gateOpening);\n       \n      if (ltime>0.)\n         if (onlyEnvelope)\n            notev = vec2(cInstrument.iVolume*env*velocity);\n         else\n            notev = balance(tracks[track].tBalance)*stereoOscDetune(tracks[track].instrumentNr - 1, ltime, cInstrument.waveform, cInstrument.iVolume*env*velocity, freq, cInstrument.wfParams.x, cInstrument.wfParams.y, cInstrument.wfParams.z);    \n      else\n         notev = vec2(0.);\n   }\n   \n   return notev;\n}\n\nvec2 note(int track, float time, float freq, float octave, float velocity, float duration, float gateOpening)\n{\n   vec2 note;\n   #ifdef ECHO\n   vec3 ep = instruments[tracks[track].instrumentNr - 1].echoParams;\n   if (ep.x<2.)\n      note = note0(track, time, freq, octave, velocity, duration, gateOpening);   \n   else\n   {\n      float a = 1.;\n      for (int n = ZERO; n < int(ep.x); n++)\n      {\n         note+= a*note0(track, time - float(n)*bartime/ep.z, freq, octave, velocity, duration, gateOpening);\n         a*= ep.y;\n      }\n   }\n   #else\n      note = note0(track, time, freq, octave, velocity, duration, gateOpening); \n   #endif\n   \n   tracks[track].playtime+= bartime/duration;    \n   return note;\n}\n\nvec2 chord(int track, float time, vec3[5] notes, float duration, float gateOpening)\n{\n   vec2 notev = vec2(0.);\n    \n   for (int n = ZERO; n < 5; n++)\n   {\n      notev+= note(track, time, notes[n].x, notes[n].y, notes[n].z, duration, gateOpening);\n      if (n<4)\n         tracks[track].playtime-= bartime/duration;\n   }\n    \n   return notev;\n}\n\nvoid pause(int track, float duration)\n{\n    tracks[track].playtime+= bartime/duration;   \n}\n\nvec2 drum(int track, float time, float duration, float freq, float ba, float fd, float d1, float d2, float a1, float a2, float nl, float nd, float nf, float drb)\n{\n    float v;\n    \n    float t = time - tracks[track].playtime;    \n    if (t>0.)\n    {\n       float f = freq*exp(-fd*t);\n       float a = onlyEnvelope?0.05:sin(tpi*f*t*0.5);\n       v = 0.3*ba*clamp(a*a1,-1.0,1.0)*(exp(-d1*t) + exp(-d2*t));\n       v+= a*a2*ba*exp(-1.0*t);\n        \n       float tnf2 = t*nf*(1. - 0.00012*exp(-nd*t*2.));\n       v+= clamp(nl*(onlyEnvelope?0.2:(hash(tnf2) - hash(tnf2 + 0.025)))*exp(-nd*t), -1., 1.);\n    }\n    tracks[track].playtime+= bartime/duration; \n    \n    return (onlyEnvelope?vec2(1.):balance(drb)*balance(tracks[track].tBalance))*vec2(v);\n}\n\nvec2 playTrack0(int track, float time)\n{\n   vec2 sound = vec2(0.);\n   //float btime = mod(time, bartime*tracks[track - 1].loopBars);\n   float btime = time;\n   \n   // Melody\n   if (track==1)\n   {\n      #ifdef NEW_CHORDS\n      sound+= note(track - 1, btime, (chordNr==3)?FE:FD, 3., 1., 2., .5);\n      sound+= note(track - 1, btime, (chordNr==3)?FG:FA, 3., 1., 4., .4);\n      sound+= note(track - 1, btime, FC, 4., 1., 4., .7);\n      pause(track - 1, 8.);\n      sound+= note(track - 1, btime, FA, 4., .8, 8., .5);\n      sound+= note(track - 1, btime, (chordNr==3)?FE:FD, 5., .7, 8., .4);\n      sound+= note(track - 1, btime, FC, 5., .6, 4., .7);\n      #else\n      sound+= note(track - 1, btime, FD, 3., 1., 2., .5);\n      sound+= note(track - 1, btime, FA, 3., 1., 4., .4);\n      sound+= note(track - 1, btime, FEH, 3., 1., 4., .7);\n      pause(track - 1, 8.);\n      sound+= note(track - 1, btime, FA, 4., .8, 8., .5);\n      sound+= note(track - 1, btime, FD, 5., .7, 8., .4);\n      sound+= note(track - 1, btime, FA, 4., .6, 4., .7);       \n      #endif\n   }\n   // Bass\n   if (track==2)\n   {    \n      pause(track - 1, 8.);\n      sound+= note(track - 1, btime, bassNote, bassOctave, 1., 4., .45);\n      sound+= note(track - 1, btime, bassNote, bassOctave, 1., 4., .45);\n   }\n   // Chords\n   if (track==3)\n   {       \n      sound+= chord(track - 1, btime, rChord, 4., .5);\n      sound+= chord(track - 1, btime, rChord, fract(barnr0)<0.5?8.:16., .5);\n      sound+= chord(track - 1, btime, rChord, 8., .5); \n   }\n   // Pad\n   if (track==4)\n   {       \n      sound+= chord(track - 1, btime, padChord, 0.5, 0.82);\n   }\n   // Arp\n   if (track==5)\n   {       \n      sound+= note(track - 1, btime, arpNote1, arpOctave, 1., 24., .45);\n      sound+= note(track - 1, btime, arpNote2, arpOctave, 1., 24., .45);\n      sound+= note(track - 1, btime, arpNote3, arpOctave - 1., 1., 24., .45); \n   }\n   // Beat\n   if (track==6)\n   {\n      bool sdf = mod(barnr, 16.)==15.;\n      float bdl = mod(barnr, 16.)<15.?1.17:0.;\n      float bdb = 0.;\n      float sndb = 0.;\n      float sdd = 55.;\n      float snl = mod(barnr, 64.)>=16.?25.:0.;\n      float hhd = 12.;\n      float hhl = mod(barnr, 64.)>=24.?1.8:0.;\n      float hhb = 0.28;\n      float chhd = 78.;\n      float chhl = mod(barnr, 64.)>=32.?1.3:0.;\n      float chhb = -0.45;\n       \n      if (mod(barnr, 8.)==0.)\n      {\n         sound+= drum(track - 1, btime, 16., 340., 0.0, 7.5, 12., 8., 12., 1.4, 1.9, 2.3, 130., 0.);\n         tracks[track - 1].playtime-= bartime/16.;\n      }\n      sound+= drum(track - 1, btime, 16., 340., bdl, 7.5, 12., 8., 12., 1.5, 0.2, 80., 100., bdb);\n      sound+= drum(track - 1, btime, 16., 340., 0.0, 7.5, 12., 8., 12., 1.4, chhl, chhd, 300., chhb);\n      sound+= drum(track - 1, btime, 16., 340., 0.0, 7.5, 12., 8., 12., 1.4, hhl, hhd, 301., hhb);\n      sound+= drum(track - 1, btime, 16., 340., 0.0, 7.5, 12., 8., 12., 1.4, chhl, chhd, 300., chhb);\n      sound+= drum(track - 1, btime, 16., 340., bdl, 7.5, 12., 8., 12., 1.9, snl, sdd, 150., sndb);\n      sound+= drum(track - 1, btime, 16., 340., 0.0, 7.5, 12., 8., 12., 1.4, chhl, chhd, 300., chhb);\n      sound+= drum(track - 1, btime, 16., 340., 0.0, 7.5, 12., 8., 12., 1.4, hhl, hhd, 301., hhb);\n      sound+= drum(track - 1, btime, 16., 340., 0.0, 7.5, 12., 8., 12., 1.4, chhl, chhd, 300., chhb);\n      sound+= drum(track - 1, btime, 16., 340., bdl, 7.5, 12., 8., 12., 1.5, 0.2, 80., 100., bdb);\n      sound+= drum(track - 1, btime, 16., 340., 0.0, 7.5, 12., 8., 12., 1.4, chhl, chhd, 300., chhb);\n      sound+= drum(track - 1, btime, 16., 340., 0.0, 7.5, 12., 8., 12., 1.4, hhl, hhd, 301., hhb);\n      sound+= drum(track - 1, btime, 16., 340., 0.0, 7.5, 12., 8., 12., 1.4, chhl, chhd, 300., chhb);         \n      sound+= drum(track - 1, btime, 16., 340., bdl, 7.5, 12., 8., 12., 1.9, snl, sdd, 150., sndb);\n      sound+= drum(track - 1, btime, 16., 340., 0.0, 7.5, 12., 8., 12., 1.4, sdf?snl:chhl, sdf?sdd:chhd, 300., sdf?sndb:chhb);\n      sound+= drum(track - 1, btime, 16., 340., mod(barnr, 2.)==0.?0.0:bdl, 7.5, 12., 8., 12., 1.4, sdf?snl:hhl, sdf?sdd:hhd, 301., sdf?sndb:hhb);\n      sound+= drum(track - 1, btime, 16., 340., 0.0, 7.5, 12., 8., 12., 1.4, sdf?snl:chhl, sdf?sdd:chhd, 300., sdf?sndb:chhb);  \n   }\n\n   return tracks[track - 1].tVolume*sound;\n}\n\nvec2 playTrack(int track, float time)\n{\n   vec2 sound = playTrack0(track, mod(time, bartime*tracks[track - 1].loopBars));\n   // Nice idea, but takes too much time to compile...\n   /*if (track==4 && time>bartime*tracks[track - 1].loopBars)\n   {\n       tracks[track - 1].playtime = -0.5;\n       init(time - bartime*tracks[track - 1].loopBars);\n       sound+= playTrack0(track, mod(time, bartime*tracks[track - 1].loopBars) + bartime*tracks[track - 1].loopBars);\n   }*/\n    \n   // Removes the stereo of of the bass\n   if (track==2)\n      sound = vec2(sound.x + sound.y);\n       \n   return sound;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   #ifdef VIZUALISATION\n   vec2 uv = fragCoord.xy / iResolution.xy;\n    \n   if (fragCoord.x>=iResolution.x - 1.0)\n   {\n      float time2 = iTime + startTime - 0.2;  // 0.2: buffer time compensation\n      if (time2<0.)\n          fragColor = vec4(0.);      \n      else\n      {\n         int track = int(float(tracks.length())*fragCoord.y/iResolution.y);\n    \n         onlyEnvelope = true;\n         init(time2);\n         vec2 ts = abs(playTrack(track + 1, time2));\n         fragColor = vec4(tracks[track].color*vec3(ts.x), 0.)*exp(-0.24*max(time2 - 165., 0.))*smoothstep(180., 175., time2);\n      }       \n   }\n   else\n      fragColor = vec4(texture(iChannel0,vec2(uv.x + 1./iResolution.x, uv.y)));\n   #endif\n}","name":"Buffer A","description":"","type":"buffer"}]}