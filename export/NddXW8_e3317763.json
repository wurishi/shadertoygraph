{"ver":"0.1","info":{"id":"NddXW8","date":"1633047369","viewed":225,"name":"Lever Drawings Index Seed","username":"Yusef28","description":"Exploring rotation in coordinate systems. Lever animations.\nspacebar to reset\n","likes":8,"published":3,"flags":48,"usePreview":0,"tags":["color","rotation","coordinate","lever","coordinatesystems","aniumation"],"hasliked":0,"parentid":"-1","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define gelb vec3(194,110,40)/255.\n#define rot vec3(157,25,47)/255.\n#define dunkleRot vec3(22,5,30)/355.\n#define black vec3(0.)\n#define white vec3(1.)\n#define rotWhite(d) mix(rot,white,d)\n#define blue vec3(0.,0.,1.)\n\nfloat rnd2(vec2 st){\n    return fract(sin(dot(st,vec2(12.34,76.99)))*42355.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)\n                /iResolution.y;\n                \n    vec2 uvBuff = (fragCoord/iResolution.xy);\n                            \n    vec2 asp = vec2(1., iResolution.y/iResolution.x);\n    \n    // Time varying pixel color\n    vec3 col = texture(iChannel0,uvBuff).rgb;// dunkleRot;\n    \n    for(int j = 1; j < 2; j++){\n    \n        vec2 st = uv;// + vec2( rnd2( vec2(j*8) ), rnd2( vec2(j*35) ) ) - 0.5;\n        \n        vec2 A = vec2( 0.0 );\n        int iMax = leverMax;//int( floor( rnd2( vec2( j*91 ) )*15. ) );\n\n        //ok, my understanding is when you want to rotate\n        // a point around an origin other than 0,0\n        //you need to have that point and the origin you want//\n        //to rotate it around first\n        ///then shift both based on what would make this origin\n        /// 0,0\n        //then rotate\n        //then shift back to initial positions\n        for(int i = 0; i < iMax; i ++){\n\n            float t = iTime*timeFactor;\n            //so if origin A is not 0,0\n            //and I find point be from A\n            vec2 B = A + vec2(0.5) * asp * leverSize;\n\n            //before rotating I need to shift B by A\n            //if a is 0,1, we need 0,-1 to make it 0,0\n            //so we need B -(0,1) to get the \"B if A is 0,0)\n            B -= A;\n            B*= rotate( t / float( i+1 ) );\n\n            //then shift back after\n            B += A;\n\n            float lineRadius = 0.006;\n            float lineSharpness = 0.001;\n            float brightness = 1.;\n\n            float d = distToLine(A, B, st);\n            d = sharpenLine(d, lineRadius, lineSharpness, brightness );\n            col = mix(col, blue, d);\n\n            //float circle1 = 1.-smoothstep(0.0,0.01,length(st-A)-eps);\n            //col = mix(col, white, circle1);\n            //float circle2 = 1.-smoothstep(0.0,0.01,length(st-B)-eps);\n            //col = mix(col, white, circle2);\n\n            A = B;\n\n        }\n    }\n    col = pow(col,vec3(.9,1.,1.3));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define pi acos(-1.)\n#define eps 1./iResolution.y\n\n\n#define leverSize 0.3\n#define leverMax 3\n#define animationSeed 3\n#define timeFactor 2.\nfloat distToLine(vec2 A, vec2 B, vec2 p){\n    \n    vec2 PA = p - A;\n    vec2 BA = B - A;\n    float d = dot(PA,BA);\n    float t = clamp(d/(length(BA)*length(BA)),0., 1.);\n    vec2 normal = PA - BA*t;\n    return length(normal);\n}\n\nfloat sharpenLine(float d, float radius, float sharpAmount, float brightness){\n\n    return (1.-smoothstep(radius - sharpAmount, \n                         radius + sharpAmount,\n                         d)) * brightness;\n                         \n}\n\nmat2 rotate(float a){\n    float si = sin(a);\n    float cs = cos(a);\n    return mat2(cs,-si,si,cs); \n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define gelb vec3(194,110,40)/255.\n#define rot vec3(157,25,47)/255.\n#define dunkleRot vec3(22,5,30)/355.\n#define black vec3(0.)\n#define white vec3(1.)\n#define rotWhite(d) mix(rot,white,d)\n\n\nfloat rnd2(vec2 st){\n    return fract(sin(dot(st,vec2(12.34,76.99)))*42355.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)\n                /iResolution.y;\n    vec2 asp = vec2(1.,iResolution.y/iResolution.x);\n    vec3 col;\n    //set up / spacebar reset\n    if(iFrame == 0 || texture(iChannel1,  vec2(0.126953125, .25)).x > 0.){\n    \n    // Time varying pixel color\n    col = vec3(0.);\n        \n    }\n    \n    else\n    {\n    \n    col = texture(iChannel0, fragCoord/iResolution.xy).rgb;\n    \n    for(int j = 1; j < 2; j++){\n    \n        vec2 st = uv;// + vec2( rnd2( vec2(j*8) ), rnd2( vec2(j*35) ) ) - 0.5;\n        \n        vec2 A = vec2( 0.0 );\n        int iMax = leverMax;//int( floor( rnd2( vec2( j*91 ) )*15. ) );\n\n        //ok, my understanding is when you want to rotate\n        // a point around an origin other than 0,0\n        //you need to have that point and the origin you want//\n        //to rotate it around first\n        ///then shift both based on what would make this origin\n        /// 0,0\n        //then rotate\n        //then shift back to initial positions\n        for(int i = 0; i < iMax; i ++){\n\n            float t = iTime*timeFactor;\n            //so if origin A is not 0,0\n            //and I find point be from A\n            vec2 B = A + vec2(0.5) * asp * leverSize;\n\n            //before rotating I need to shift B by A\n            //if a is 0,1, we need 0,-1 to make it 0,0\n            //so we need B -(0,1) to get the \"B if A is 0,0)\n            B -= A;\n            B*= rotate( t / float( i+1 ) );\n\n            //then shift back after\n            B += A;\n\n            float lineRadius = 0.006;\n            float lineSharpness = 0.001;\n            float brightness = 1.;\n\n            float d = distToLine(A, B, st);\n            d = sharpenLine(d, lineRadius, lineSharpness, brightness );\n            //col = mix(col, white, d);\n\n            float circle1 = 1.-smoothstep(0.0,0.01,length(st-A)-eps);\n            col = mix(col, white, circle1);\n            float circle2 = 1.-smoothstep(0.0,0.01,length(st-B)-eps);\n            col = mix(col, white, circle2);\n\n            A = B;\n\n        }\n    }\n    \n    }\n    //endelse\n    col = pow(col,vec3(.9,1.,1.3));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}