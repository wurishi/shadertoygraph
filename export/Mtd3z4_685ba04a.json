{"ver":"0.1","info":{"id":"Mtd3z4","date":"1468772988","viewed":605,"name":"Desert sunset","username":"zguerrero","description":"I was messing around with noise function and ended up with a landscape and a day/night cycle, was fun to make ! :)","likes":21,"published":1,"flags":0,"usePreview":0,"tags":["noise","ray","lighting","light","cycle","marching","landscape","distance","night","field","day"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float eps = 0.001;\nconst float daySpeed = 0.3;\nconst float season = -1.0;\nconst float followSun = 0.25;\n\nvec3 rotationX(vec3 pos, float angle) {\n\tfloat c = cos(angle);\n    float s = sin(angle);\n    vec3 rotPos;\n\trotPos.x = pos.x;\n    rotPos.y = c * pos.y - s * pos.z;\n\trotPos.z = s * pos.y + c * pos.z;\n    \n    return rotPos;\n}\n\n/*\nvec3 rotationY(vec3 pos, float angle) {\n\tfloat c = cos(angle);\n    float s = sin(angle);\n    vec3 rotPos;\n\trotPos.x = c * pos.x + s * pos.z;\n    rotPos.y = pos.y;\n\trotPos.z = -s * pos.x + c * pos.z;\n    \n    return rotPos;\n}\n\nvec3 rotationZ(vec3 pos, float angle) {\n\tfloat c = cos(angle);\n    float s = sin(angle);\n    vec3 rotPos;\n\trotPos.x = c * pos.x - s * pos.y;\n    rotPos.y = c * pos.x + s * pos.y;\n\trotPos.z = pos.z;\n    \n    return rotPos;\n}\n*/\n\nvec2 rotuv(vec2 uv, float angle, vec2 center)\n{    \n   \treturn mat2(cos(angle), -sin(angle), sin(angle), cos(angle)) * (uv - center) + center;\n}\n\nfloat hash(float n)\n{\n   return fract(sin(dot(vec2(n,n) ,vec2(12.9898,78.233))) * 43758.5453);  \n} \n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat cell0(vec2 uv)\n{    \n    vec2 uv2 = sin(uv);\n    return uv2.x * uv2.y;\n}\n\nfloat cellCombine0(vec2 uv, float randSeed, float v, float s)\n{\n    float r1 = hash(randSeed);\n    float angle1 = r1*360.0 + (r1*2.0-1.0)*iTime*s;\n    float c = cell0(rotuv(uv*(1.0 + r1*v), angle1, vec2(r1, hash(r1))));\n    \n    const int itterations = 3;\n    \n    for(int i = 0; i < itterations; i++)\n    {\n        float r = hash(float(i)*randSeed);\n        float angle = r*360.0 + (r*2.0-1.0)*iTime*s;\n        float nc = cell0(rotuv(uv*(1.0 + r*v) + c, angle, vec2(r, hash(r))*10.0));\n        c = mix(c, nc, 0.5);\n    }\n    \n    return c;\n}\n\nfloat cell1(vec2 uv)\n{    \n    vec2 uv2 = abs(sin(uv));\n    return uv2.x * uv2.y;\n}\n\nfloat cellCombine1(vec2 uv, float randSeed, float v, float s)\n{\n    float r1 = hash(randSeed);\n    float angle1 = r1*360.0 + (r1*2.0-1.0)*iTime*s;\n    float c = cell1(rotuv(uv*(1.0 + r1*v), angle1, vec2(r1, hash(r1))));\n    \n    const int itterations = 5;\n    \n    for(int i = 0; i < itterations; i++)\n    {\n        float r = hash(float(i)*randSeed);\n        float angle = r*360.0 + (r*2.0-1.0)*iTime*s;\n        float nc = cell1(rotuv(uv*(1.0 + r*v) + c, angle, vec2(r, hash(r))*10.0));\n        c = max(c, nc);\n    }\n    \n    return c;\n}\n\nfloat cell2(vec2 uv)\n{   \n    vec2 uv2 = abs(fract(uv) - vec2(0.5));\n    return smoothstep(0.98, 1.0, (uv2.x+uv2.y));\n}\n\nfloat cellCombine2(vec2 uv, float randSeed, float v, float s)\n{\n    float r1 = hash(randSeed);\n    float angle1 = r1*360.0 + (r1*2.0-1.0)*iTime*s;\n    float c = cell2(rotuv(uv*(1.0 + r1*v), angle1, vec2(r1, hash(r1))));\n    \n    const int itterations = 7;\n    \n    for(int i = 0; i < itterations; i++)\n    {\n        float r = hash(float(i)*randSeed);\n        float angle = r*360.0 + (r*2.0-1.0)*iTime*s;\n        float nc = cell2(rotuv(uv*(1.0 + r*v), angle, vec2(r, hash(r))*10.0));\n        c += nc*(0.5 + r);\n    }\n    \n    return c;\n}\n\nfloat infinitePlane(vec3 pos, float height)\n{\n    return pos.y - height;\n}\n\nfloat distfunc(vec3 pos)\n{  \n    float n0 = cellCombine0(pos.xz*0.3, 10.98765, 0.5, 0.0);\n    float n1 = 1.0 - cellCombine1(pos.xz*0.2, 5.5678, 0.5, 0.0);\n\tfloat n2 = 1.0 - cellCombine1(pos.xz*vec2(1.5,3.0), 8.5548, 0.5, 0.0);\n    return pos.y - n0*2.0 - n1*2.0 - n2*0.1;\n}\n\nvec2 rayMarch(vec3 rayDir, vec3 cameraOrigin)\n{\n    const int MAX_ITER = 100;\n\tconst float MAX_DIST = 40.0;\n    \n    float totalDist = 0.0;\n\tvec3 pos = cameraOrigin;\n\tfloat dist = eps;\n    \n    for(int i = 0; i < MAX_ITER; i++)\n\t{\n\t\tdist = distfunc(pos);\n\t\ttotalDist += dist;\n\t\tpos += dist*rayDir;\n        \n        if(dist < eps || totalDist > MAX_DIST)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n    return vec2(dist, totalDist);\n}\n\nvec3 skyBox(vec3 rayDir, vec3 sunDir, vec3 sunColor, float dayCycle1, float dayCycle2, float blur)\n{\n    vec3 rotDir = rotationX(rayDir, -iTime*daySpeed);\n    vec2 starUvs = vec2(atan(rotDir.x, rotDir.z), rotDir.y*4.0)*2.0;\n    float stars = clamp(clamp(cellCombine2(starUvs, 3259.5741, 0.5, 0.0),0.0,1.0) + (1.0 - blur),0.0,1.0); \n    vec3 skyColor1 = mix(vec3(0.05,0.05,0.2)+stars, mix(vec3(0.5,0.2,0.5),vec3(0.25,0.25,1.0), dayCycle1), dayCycle2);\n    vec3 skyColor2 = mix(vec3(0.25,0.25,0.35), mix(vec3(0.8,0.4,0.2), vec3(1.0,1.0,1.0), dayCycle1), dayCycle2);\n    vec3 groundColor1 = mix(vec3(0.25,0.22,0.3), mix(vec3(0.5,0.3,0.2), vec3(1.0,0.9,0.75), dayCycle1), dayCycle2);\n       \n    float sunPos = length(rayDir - sunDir);\n    float sunBall = 1.0 - smoothstep(0.04, 0.05*blur, sunPos);\n    float sunGlow = 1.0 - smoothstep(0.03, 0.5*blur, sunPos);\n    float sunInnerGlow = 1.0 - smoothstep(0.0, 0.05*blur, sunPos);\n    vec3 sun = ((sunBall + sunGlow)/blur)*sunColor + vec3(sunInnerGlow);\n    \n    vec3 skyColor = mix(skyColor2, skyColor1, clamp(rayDir.y*1.5,0.0,1.0));\n    float m = smoothstep(0.0, 0.05, (rayDir.y+0.1)*blur);\n    return mix(groundColor1, skyColor+sun, m);\n}\n\nvec3 lensFlare(vec3 rayDir, vec3 sunDir, vec3 sunColor, float dayCycle1)\n{    \n    vec3 l = vec3(0.0);\n    for(int i = 0; i < 4; i++)\n    {  \n        float d = 0.22;\n        float lensDistance = d + float(i)*d;\n        vec3 rvec = vec3(0.0,0.0,1.0);\n        vec3 sunvec = vec3(sunDir.x,-sunDir.y,sunDir.z);\n    \tfloat lPos = length(rayDir - normalize(mix(sunDir, reflect(sunvec, rvec), lensDistance)));\n        float growFactor = (1.0 + float(i)*float(i));\n        float lGlow = 1.0 - smoothstep(0.01*growFactor, 0.05*growFactor, lPos);\n        \n        l += mix(vec3(1.0), vec3(0.5,0.5,2.0), lensDistance)*lensDistance*lGlow;\n    }\n\n    float lPosv = 1.0 - clamp(length(rayDir.xz - sunDir.xz),0.0,1.0);\n    float lGlowv = pow(lPosv, 50.0);\n\n    vec3 lens = (l + lGlowv)*sunColor*dayCycle1;\n    \n    return lens;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 calculateNormals(vec3 pos)\n{\n\tvec2 eps = vec2(0.0, 0.02);\n    float X = distfunc(pos + eps.yxx) - distfunc(pos - eps.yxx);\n    float Y = distfunc(pos + eps.xyx) - distfunc(pos - eps.xyx);\n    float Z = distfunc(pos + eps.xxy) - distfunc(pos - eps.xxy);\n\tvec3 n = normalize(vec3(X,Y,Z));\n\treturn n;\n}\n\nvec3 lighting(vec3 pos, vec3 rayDir, vec3 light, vec3 sunColor, float dayCycle1, float dayCycle2, vec3 n)\n{   \n    vec3 ambSkyBox = skyBox(n, light, sunColor, dayCycle1, dayCycle2, 5.0);\n    vec3 ambientColor = mix(ambSkyBox, clamp(ambSkyBox + 0.5, 0.0, 1.0), dayCycle1);\n    vec3 diffuseColor = mix(vec3(1.0,0.7,0.5), vec3(1.0,0.9,0.6), pos.y*0.65);\n    vec3 specColor = vec3(1.0,1.0,1.0);\n   \n\tfloat diff = dot(normalize(light), n);\n\tfloat fresnel = (1.0 - 0.0, dot(n, -rayDir));\n\tvec3 r = reflect(normalize(rayDir), n);\n\tfloat spec = pow(max (0.0, dot (r, light)), 50.0);\n\tfloat specMap = cellCombine1(pos.xz*3.0, 12458.5125, 1.0, 0.0);\n    \n\tvec3 res = diffuseColor*ambientColor;\n\n\tres += diffuseColor*max(0.0, diff)*sunColor;\n    res += specColor*spec*sunColor*fresnel*smoothstep(0.95,1.0,specMap)*5.0;\n    res += sunColor * max(0.0, -diff) * 0.35;\n\n\treturn res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 light = normalize(vec3(season,cos(daySpeed*iTime),sin(daySpeed*iTime)));\n    \n    vec2 screenPos = (fragCoord.xy/iResolution.xy)*2.0-1.0;\n\tscreenPos.x *= iResolution.x/iResolution.y;\n    \n    vec3 cameraOrigin = vec3(iTime, 4.0, iTime);\n\tvec3 cameraTarget = cameraOrigin + mix(vec3(-1.0,0.0,0.0), light, followSun);\n       \n\tmat3 cam = setCamera(cameraOrigin, cameraTarget, 0.0 );\n    \n    vec3 rayDir = cam* normalize( vec3(screenPos, 0.75) );\n    vec2 dist = rayMarch(rayDir, cameraOrigin);\n    \n    float dayCycle = dot(light, vec3(0.0, 1.0, 0.0));\n    float dayCycle1 = smoothstep(0.0, 0.5, max(0.0, dayCycle));\n    float dayCycle2 = smoothstep(0.5, 1.0, min(dayCycle + 1.0, 1.0));\n    vec3 sunColor = mix(vec3(0.5,0.2,0.0), vec3(0.4,0.4,0.2), dayCycle1);\n    vec3 dayLight = mix(vec3(0.2, 0.2, 0.4), sunColor, dayCycle2);\n    \n    vec3 sky = skyBox(rayDir, light, dayLight, dayCycle1, dayCycle2, 1.0);\n    vec3 lens = lensFlare(rayDir, light, dayLight, dayCycle1);\n    vec3 res;\n     \n\tif(dist.x < eps)\n    {\n        vec3 pos = cameraOrigin + dist.y*rayDir;\n        vec3 n = calculateNormals(pos);\n        float fog = clamp((dist.y - 18.0)*0.05, 0.0, 1.0);\n        float fogY = (1.0 - clamp((pos.y+0.5)*0.5, 0.0, 1.0))*0.8;\n        res = mix(lighting(pos, rayDir, light, dayLight, dayCycle1, dayCycle2, n), sky, clamp(fog+fogY, 0.0, 1.0));\n    }\n    else\n    {\n        res = sky;       \n    }\n\n    float vign = 1.0 - smoothstep(0.5, 1.0, length(screenPos - vec2(0.0))*0.5);\n    \n\tfragColor = vec4(res + vec3(lens), 1.0) * (0.75+vign*0.25);\n}","name":"Image","description":"","type":"image"}]}