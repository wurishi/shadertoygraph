{"ver":"0.1","info":{"id":"7ssfWN","date":"1644905455","viewed":295,"name":"Hammersley Sampling Test","username":"JuanDeager","description":"A quick sample showing importance sampling using a Hammersley sequence for pseudorandom numbers.\n\nTime-based rotation isn't actually used in practice, it just makes this shader a little less boring to visualize :D","likes":5,"published":3,"flags":0,"usePreview":0,"tags":["test","sample","distribution"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SAMPLES 200u\n#define MODE 1\n// mode 0: display points as cartesian\n// mode 1: display points as polar\n// mode 2: display points as uniform polar\n// mode 3: secret :)\n\n#define PI (3.141592653)\n#define TWO_PI (2.0 * PI)\n\n// reverses the bits of the input\nuint MyBitfieldReverse(uint i)\n{\n\tuint b =  ( uint(i) << 16u) | (uint(i) >> 16u );\n\tb = (b & 0x55555555u) << 1u | (b & 0xAAAAAAAAu) >> 1u;\n\tb = (b & 0x33333333u) << 2u | (b & 0xCCCCCCCCu) >> 2u;\n\tb = (b & 0x0F0F0F0Fu) << 4u | (b & 0xF0F0F0F0u) >> 4u;\n\tb = (b & 0x00FF00FFu) << 8u | (b & 0xFF00FF00u) >> 8u;\n    return b;\n}\n\nvec2 Hammersley(uint i, uint N)\n{\n  return vec2(\n    float(i) / float(N),\n    float(MyBitfieldReverse(i)) * 2.3283064365386963e-10\n  );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // rotate the UV\n    float t = iTime * .25;\n    mat2 rot = mat2(\n        cos(t), sin(t),\n        -sin(t), cos(t)\n    );\n    uv = (rot * (uv - 0.5)) + 0.5;\n\n    // accumulate color based on proximity to samples\n    vec3 color = vec3(0, 0, 0);\n    uint s = uint(ceil(float(SAMPLES) * (.5 + .5 * sin(iTime))));\n    for (uint i = 0u; i < s; i++)\n    {\n        float weight = 1.0;\n        vec2 point = vec2(0.0);\n#if MODE == 0\n        point = Hammersley(i, SAMPLES);\n#elif MODE == 1 || MODE == 2 || MODE == 3\n        vec2 xi = Hammersley(i, SAMPLES);\n    #if MODE == 1\n        weight = max(.10, 3.0 * xi.x);\n    #elif MODE == 2\n        xi.x = sqrt(xi.x);\n    #elif MODE == 3\n        xi.x = float(i) / float(SAMPLES);\n        xi.y = float(i) / float(SAMPLES) * PI;\n        xi.y = log(xi.y);\n        weight = .25;\n    #endif\n        float r = xi.x * 0.5;\n        float theta = xi.y * TWO_PI;\n        point = vec2(0.5) + vec2(r * cos(theta), r * sin(theta));\n#endif\n        float str = 1.0 - smoothstep(0.0, .02 * weight, distance(uv, point));\n        color.rb += str;\n        color.g += str * float(i) / float(SAMPLES);\n    }\n    \n\n    fragColor = vec4(pow(color, vec3(1.0/2.2)),1.0);\n}","name":"Image","description":"","type":"image"}]}