{"ver":"0.1","info":{"id":"lsGSzR","date":"1462399982","viewed":372,"name":"Spherical Harmonics Ray Tracer","username":"maldicion069","description":"Ray tracer scene with Spherical Harmonics","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracer","sphericalharmonics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAXSAMPLES 64\n#define INFINITY 1000.0\n\n#define SA  // Comment this to disable Spherical Harmonics Irradiance\n#define MB // Comment this to disable Motion Blur\n\nfloat random(float seed) { \n    return fract(sin(seed++)*74532.563045); \n}\n\nhighp float rand(vec2 co) {\n  highp float a = 12.9898;\n  highp float b = 78.233;\n  highp float c = 43758.5453;\n  highp float dt= dot(co.xy ,vec2(a,b));\n  highp float sn= mod(dt,3.1415926);\n  return fract(sin(sn) * c);\n}\n\nfloat pseudorandom(float u) {\n  float a = fract(sin(gl_FragCoord.x*12.9898*3758.5453));\n  float b = fract(sin(gl_FragCoord.x*63.7264*3758.5453));\n  return rand(gl_FragCoord.xy * mod(u * 4.5453,3.1415926));\n}\n\nstruct Ray {\n    vec3 o;\n    vec3 d;\n};\n    \nstruct Sphere {\n    vec3 center;\n    vec3 color;\n    float radius;\n    vec3 pos;\n    vec3 normal;\n};\n    \nstruct SHCoefficients {\n    vec3 l00, l1m1, l10, l11, l2m2, l2m1, l20, l21, l22;\n};\n\nconst SHCoefficients sph_arm = SHCoefficients(\n  vec3( 1.630401,  1.197034,  1.113651),\n  vec3( 0.699675,  0.540300,  0.536132),\n  vec3(-0.354008, -0.287976, -0.268514),\n  vec3( 1.120136,  0.854082,  0.880019),\n  vec3( 1.012764,  0.783031,  0.812029),\n  vec3(-0.181137, -0.147510, -0.132195),\n  vec3(-0.589437, -0.434048, -0.452781),\n  vec3(-0.266943, -0.211540, -0.210316),\n  vec3( 0.868657,  0.665028,  0.655598)\n);\n\nconst SHCoefficients sph_arm2 = SHCoefficients(\n    vec3( 0.7953949,  0.4405923,  0.5459412 ),\n    vec3( 0.3981450,  0.3526911,  0.6097158 ),\n    vec3(-0.3424573, -0.1838151, -0.2715583 ),\n    vec3(-0.2944621, -0.0560606,  0.0095193 ),\n    vec3(-0.1123051, -0.0513088, -0.1232869 ),\n    vec3(-0.2645007, -0.2257996, -0.4785847 ),\n    vec3(-0.1569444, -0.0954703, -0.1485053 ),\n    vec3( 0.5646247,  0.2161586,  0.1402643 ),\n    vec3( 0.2137442, -0.0547578, -0.3061700 )\n);\n\nconst SHCoefficients sph_arm3 = SHCoefficients(\n  vec3( 2.479083,  2.954692,  3.087378),\n  vec3( 1.378513,  1.757425,  2.212955),\n  vec3(-0.321538, -0.574806, -0.866179),\n  vec3( 1.431262,  1.181306,  0.620145),\n  vec3( 0.580104,  0.439953,  0.154851),\n  vec3(-0.446477, -0.688690, -0.986783),\n  vec3(-1.225432, -1.270607, -1.146588),\n  vec3( 0.274751,  0.234544,  0.111212),\n  vec3( 2.098766,  2.112738,  1.652628)\n);\n\nvec3 calcIrradiance(vec3 nor) {\n    const SHCoefficients c = sph_arm2;\n    const float c1 = 0.429043;\n    const float c2 = 0.511664;\n    const float c3 = 0.743125;\n    const float c4 = 0.886227;\n    const float c5 = 0.247708;\n    return (\n        c1 * c.l22 * (nor.x * nor.x - nor.y * nor.y) +\n        c3 * c.l20 * nor.z * nor.z +\n        c4 * c.l00 -\n        c5 * c.l20 +\n        2.0 * c1 * c.l2m2 * nor.x * nor.y +\n        2.0 * c1 * c.l21  * nor.x * nor.z +\n        2.0 * c1 * c.l2m1 * nor.y * nor.z +\n        2.0 * c2 * c.l11  * nor.x +\n        2.0 * c2 * c.l1m1 * nor.y +\n        2.0 * c2 * c.l10  * nor.z\n    );\n}\n\nfloat hitSphere(Sphere inSp, Ray r) {\n    vec3 oc = r.o - inSp.center;\n    float a = dot(r.d, r.d);\n    float b = 2.0 * dot(oc, r.d);\n    float c = dot(oc,oc) - inSp.radius*inSp.radius;\n    float discriminant = b*b - 4.0*a*c;\n    if (discriminant < 0.0) {\n        return -1.0;}\n    else {\n        return (-b - sqrt(discriminant)) / (2.0 * a);\n    }\n}\n\n// Camera definition\nvec3 lowerLeft = vec3(-2.0, -1.0, -1.0);\nvec3 origin = vec3(0.0, 0.0, 0.0);\nvec3 horizontal = vec3(4.0, 0.0, 0.0);\nvec3 vertical = vec3(0.0, 2.0, 0.0);\n\nSphere spheres[2];\n\nfloat checkShadow(Ray ray) {\n    float h = INFINITY;\n    for (int i = 0; i < 2; i++) {\n        float t = hitSphere(spheres[i], ray);\n\n        if (t > 1.0 && t < h) {\n            return 0.3;\n        }\n\n    }\n    return 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec3 accumulator = vec3(0.0);\n    \n    spheres[0] =  Sphere(vec3(-0.5,0,sin(iTime * 2.0) - 2.0), vec3(1.0, 0.0, 0.0), 0.5, vec3(0,0,0), vec3(0,0,0));\n    spheres[1] =  Sphere(vec3(0.5,0,cos(iTime * 2.0) - 2.0), vec3(0.0, 1.0, 0.0), 0.5, vec3(0,0,0), vec3(0,0,0));\n\n    vec2 times = vec2(0.1, 0.2);\n    float seed = iTime;\n    \n    #ifdef MB\n        spheres[0].center += vec3(0.0, 0.0, -( times.x + ( times.y - times.x ) * ( pseudorandom(seed*14.53+1.6) ) ) );\n        spheres[1].center += vec3(0.0, 0.0, -( times.x + ( times.y - times.x ) * ( pseudorandom(seed*14.53+1.6) ) ) );\n    #endif\n    \n    for (int s = 0; s < MAXSAMPLES; s++) {\n        seed += float (s); \n        float u = (fragCoord.x + random(seed) * 2.0) / iResolution.x;\n        float v = (fragCoord.y + random(seed+1.0) * 2.0) / iResolution.y;\n        float h = INFINITY;\n        \n        Ray ray = Ray(origin,lowerLeft + horizontal * u + vertical * v);\n        \n        vec3 hitCol = vec3(1.0);\n        #ifdef SA\n            hitCol *= calcIrradiance(normalize(ray.d));\n        #endif\n        \n        for (int i = 0; i < 2; i++) {\n            float t = hitSphere(spheres[i], ray);\n\n            if (t > 0.0 && t < h) {\n                h = t;\n                \n                spheres[i].pos = ray.o + t * ray.d;\n                spheres[i].normal = normalize(spheres[i].pos - spheres[i].center);\n                \n                float occ = 0.5 + 0.5 * spheres[i].normal.y;\n                hitCol = spheres[i].color * occ;\n                #ifdef SA\n                    hitCol *= calcIrradiance(spheres[i].normal);\n                #endif\n            }\n\n        }\n        \n        // Check shadow\n        //hitCol *= checkShadow(ray);\n        \n        accumulator += hitCol;\n\n    }\n    \n    fragColor = vec4(vec3(accumulator)/float(MAXSAMPLES),1.0);\n}","name":"Image","description":"","type":"image"}]}