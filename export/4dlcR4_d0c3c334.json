{"ver":"0.1","info":{"id":"4dlcR4","date":"1487277060","viewed":868,"name":"2D Weyl hash 32-bit XOR","username":"MBR","description":"a 2D equidistributed sequence based on Weyl generators, integer version","likes":17,"published":1,"flags":48,"usePreview":0,"tags":["hash","whitenoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// LICENSE: http://unlicense.org/\n\n// Math background: http://marc-b-reynolds.github.io/math/2016/02/24/weyl.html\n// Hash function:   http://marc-b-reynolds.github.io/math/2016/03/29/weyl_hash.html\n\n// requires 32-bit integer support, mods needed for 24-bit\n\n// WIP mods base on viz from: https://www.shadertoy.com/view/lt2yDm\n// * no problem with either input being zero (old version said diff..was thinking about non XOR version)\n// * \n\n\n// constant commments: popcnt | 3-lsb | integer factorization\n//#define W0 0x3504f333u  // 15 | | 3*2309*128413 <- original\n//#define W1 0xf1bbcdcbu  // 21 | | 7*349*1660097 <- original\n\n#define W0 0x3504f335u    // 15 | 101 | 41*79*274627\n//#define W1 0x6a09e663u  // 15 | 011 | 3*21963379\n//#define W1 0x1f83d9abu  // 18 | 011 | 5*11*13*389*1901\n//#define W1 0xbb67ae85u  // 19 | 101 | 3*349348253\n#define W1   0x8fc1ecd5u  // 18 | 101 | 5*482370193\n\n\n#define M  741103597u     // 15 | 13*83*686843\n\n\n// if defined output on [0,1) otherwise on [0,1]. Undefined saves a shift\n// as per hornet's comment.\n//#define EQUIDISTANT\n\n// basic version\nuint hash(uint x, uint y)\n{\n  x *= W0;   // x' = Fx(x)\n  y *= W1;   // y' = Fy(y)\n  x ^= y;    // combine\n  x *= M;    // MLCG constant\n  return x;\n}\n\n// increase low bit period version. This does signficantly\n// improve empirical stat testing...visually doesn't do\n// much of anything (watch near line).\nuint hash2(uint x, uint y)\n{\n  uint r = hash(x,y);\n    \n  // this can be replaced with a stronger\n  // bit finalizer to further increase stat quality\n  return r ^ (r >> 16);\n}\n\n\n//===============================================================\n// visualization stuff below here\n\n\n//======Start shared code for state\n#define pz_stateYOffset 0.0\n#define pz_stateBuf 0\n#define pz_stateSample(x) texture(iChannel0,x)\nvec2 pz_realBufferResolution;\nvec2 pz_originalBufferResolution;\n\nvoid pz_initializeState() {\n    pz_realBufferResolution     = iChannelResolution[pz_stateBuf].xy;\n    pz_originalBufferResolution = pz_stateSample(.5/pz_realBufferResolution).xy;\n}\n\nvec2 pz_nr2vec(float nr) {\n    return vec2(mod(nr, pz_originalBufferResolution.x)\n                      , pz_stateYOffset+floor(nr / pz_originalBufferResolution.x))+.5;\n}\n\nvec4 pz_readState(float nr) {\n    return pz_stateSample(pz_nr2vec(nr)/pz_realBufferResolution);\n}\n\nfloat pz_resetCount() { return pz_readState(1.).z;   }\nvec3 pz_position()    { return pz_readState(3.).xyz; }\n\nvec2 pz_initializeState(vec2 fragCoord) {\n    pz_initializeState();\n    \n    vec3 position = pz_position();\n    fragCoord -= 0.5*iResolution.xy;\n    fragCoord *= position.z;\n    fragCoord += (0.5 + position.xy) * iResolution.xy ;\n    return fragCoord;\n}\n//======End shared code for state\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  int   t = int(fragCoord.x) - int(0.5*iResolution.x);\n  fragCoord = pz_initializeState(fragCoord);\n    \n  uvec2 p = uvec2(ivec2(fragCoord.xy));\n  uint  h;\n  \n  if (t < 0)\n    h = hash(p.x,p.y);\n    else if (t > 1)\n    h = hash2(p.x,p.y);\n        \n#if defined(EQUIDISTANT)\n  float f = float(h>>8u)*(1.0/16777216.0);\n#else\n  float f = float(h)*(1.0/4294967296.0);\n#endif\n  \n  fragColor = vec4(f,f,f,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}","name":"Buf A","description":"","type":"buffer"}]}