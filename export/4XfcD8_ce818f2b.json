{"ver":"0.1","info":{"id":"4XfcD8","date":"1726099988","viewed":7,"name":"jnhieter-Capsule","username":"jhieter","description":"such cool","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["shape"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//https://iquilezles.org/articles/distfunctions/\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdSphere( vec3 p, float s){\n    return length(p) - s;\n}\n\n//https://www.shadertoy.com/view/4djSRW\nfloat hashOld12(vec2 p)\n{\n    // Two typical hashes...\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n    \n    // This one is better, but it still stretches out quite quickly...\n    // But it's really quite bad on my Mac(!)\n    //return fract(sin(dot(p, vec2(1.0,113.0)))*43758.5453123);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized y pixel coordinates (from 0 to 1)    \n    // apply same scale to x pixels\n    vec2 uv = fragCoord/iResolution.yy;\n    \n    //subtracting 0.5 moves origin to middle of window\n    //however x is at a different scale, so we need to scale\n    //based on aspect ratio\n    uv.x = uv.x - 0.5*(iResolution.x/iResolution.y);\n    uv.y = uv.y - 0.5;\n\n    //set background color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec3 col = vec3(4.0*sin(6.28*hashOld12(vec2(uv.x, uv.y))+iTime)-3.0);\n    \n    //distance along ray\n    float t = 0.0;\n    \n    \n    float xMove = 0.5*sin(iTime);\n    //position and size of the sdf cylinder\n    vec3 cylPos = vec3(xMove,0.0,40.0);\n    float cylRad = 0.25;\n    float cylHeight = 0.25;\n    \n    //position and size of the sdf cylinder\n    vec3 spherePos = vec3(xMove,0.25,40.0);\n    vec3 sphere2Pos = vec3(xMove,-0.25,40.0);\n    float sphereRad = 0.25;\n    \n    \n    //starting point of ray and the direction it follows\n    vec3 pt = vec3(uv.x, uv.y, 0.0);\n    vec3 dir = normalize(vec3(0.0, 0.0, 1.0));\n    \n    \n    //loop that allows us to keep moving along the ray \n    //until we hit the sphere or until we run out of \n    //loop iterations (and hit nothing)\n    for( int i = 0; i < 4000; i++){\n    \n        //calc positions from view rays\n        vec3 pos = pt + dir * t;\n            \n        \n        //get distance from position to sphere\n        //subtract spherePos from pos allows us to \"move\"\n        // the position of the sphere in the world\n        //otherwise it is stuck at the world origin\n        float dist = sdCappedCylinder(pos - cylPos, cylHeight, cylRad);\n        float dist2 = sdSphere(pos - spherePos, sphereRad);\n        float dist3 = sdSphere(pos - sphere2Pos, sphereRad);\n              \n        if(dist < 0.001 || dist2 < 0.001 || dist3 < 0.001){ //point on ray is close enough\n                        //we'll call this a \"hit\"\n                        \n            col = vec3(40.2-t);  //lets color this fragment\n                              // a \"sphere color\"\n                              \n            if(uv.x > 0.0){\n                col += vec3(uv.x/2.0, -uv.x/4.0, -uv.x/4.0);\n            } else {\n                col += vec3(uv.x/4.0, uv.x/4.0, -uv.x/2.0);\n            }\n                              \n            break;  //stop checking\n            \n        }\n        //update distance along ray if haven't hit yet\n        t += 0.01;//dist;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}