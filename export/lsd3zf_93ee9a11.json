{"ver":"0.1","info":{"id":"lsd3zf","date":"1451487188","viewed":728,"name":"Steampunk Turbine","username":"TambakoJaguar","description":"This is my second raymarching test. I had fun with the formulas for the shape, color and texture, but it was hard optimizing.\nI'm open to every help concerning optimization etc.\nLet it run at least 30 seconds! ;)","likes":19,"published":1,"flags":8,"usePreview":0,"tags":["raymarching","gear","metallic","steampunk","turbine"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"/*\n\"Steampunk Turbine\" by Emmanuel Keller aka Tambako - December 2015\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n*/\n\n#define pi 3.141593\n\nstruct Lamp\n{\n  vec3 position;\n  vec3 color;\n  float intensity;\n  float attenuation;\n};\n    \nLamp lamps[3];\n\n#define scrpos 0.42\n\nconst vec3 ambientColor = vec3(0.3, 0.52, 0.7);\nconst float ambientint = 0.15;\n\n#define specular\nconst float specint = 0.28;\nconst float specshin = 30.;\nconst float aoint = 0.4;\nconst float shi = 0.6;\nconst float shf = 0.02;\n\nconst float normdelta = 0.002;\nconst float maxdist = 8.;\n\n// Antialias. Change from 1 to 2 or more AT YOUR OWN RISK! It may CRASH your browser while compiling!\nconst float aawidth = 0.65;\nconst int aasamples = 1;\n\nvec3 campos = vec3(0);\nvec3 camdir = vec3(0);\nfloat fov = 2.9;\nfloat rot;\nfloat angle;\nfloat angle3;\nfloat vf2;\n\nvoid init()\n{ \n  float camspeed = 0.2;\n  campos = vec3(0., 3.*sin(camspeed*iTime), -5.5);\n  camdir = vec3(0., -0.57*sin(camspeed*iTime), 1.);\n  fov = 2.9-0.003*iTime;\n  rot = iTime*iTime*0.08;\n}\n\nvec2 rotateVec(vec2 vect, float angle)\n{\n    vec2 rv;\n    rv.x = vect.x*cos(angle) + vect.y*sin(angle);\n    rv.y = vect.x*sin(angle) - vect.y*cos(angle);\n    return rv;\n}\n\nfloat map(vec3 pos)\n{\n    float angle0 = atan(pos.x, pos.z);\n    angle = angle0 + rot;\n    float angle2 = angle + pos.y*1.1;\n    angle3 = fract(5.*angle/pi) - 0.3;\n    float angle4 = angle0*3. - iTime*2. - angle3 + 0.3;\n    \n    pos.xy = rotateVec(pos.xy, 0.15*smoothstep(40., 200., iTime)*cos(rot*2.));\n    pos.zy = rotateVec(pos.zy, 0.15*smoothstep(40., 200., iTime)*sin(rot*2.));\n    \n    //pos.z+= 0.3*pos.y*sin(angle);\n    return length(pos.xz)*0.9\n                 *(0.8 - (0.43 + 0.05*(smoothstep(-0.9, 0.9, sin(24.*angle))))\n                 *smoothstep(0.16, 0.08, abs(pos.y)))\n                 + 0.2*smoothstep(0.21, 0.25, abs(pos.y))\n                 - 0.5\n                 - 0.045*sin(angle4)\n                 *smoothstep(0.245, 0.19, length(vec2(angle3, 3.8*abs(pos.y - scrpos))))\n                 *(1. + 0.4*smoothstep(0.06, 0.072, abs(angle3 - 0.16 + 2.8*abs(pos.y - scrpos + 0.06))))\n                 - 0.8*smoothstep(0.58, 1.35, abs(pos.y))\n                 *smoothstep(1.45, 1.27, abs(pos.y))\n                 *abs(sin(angle2*6.5))\n                 - 0.04*smoothstep(0.58, 0.62, abs(pos.y))*smoothstep(1.46, 1.42, abs(pos.y))\n                 + 0.9*pow(abs(pos.y*0.36) + 1.*smoothstep(1.6, 2.3, abs(pos.y*1.01)), 2.6);\n}\n\nfloat map2(vec3 pos)\n{\n    pos.xy = rotateVec(pos.xy, 0.15*smoothstep(40., 200., iTime)*cos(rot*2.));\n    pos.zy = rotateVec(pos.zy, 0.15*smoothstep(40., 200., iTime)*sin(rot*2.));\n    return length(pos.xz)*0.72 - 0.55*smoothstep(0.2, 0.7, abs(pos.y - campos.y/17.))*smoothstep(1.4 - abs(campos.y)/24., 0.7, abs(pos.y - campos.y/17.));\n}\n\nfloat trace(vec3 cam, vec3 ray, float maxdist) \n{\n    float t = 3.0;\n  \tfor (int i = 0; i < 128; ++i)\n    {\n    \tvec3 pos = ray*t + cam;\n    \tfloat dist = map(pos);\n        if (dist>maxdist || abs(dist)<0.0015)\n            break;\n        float f1 = (length(pos.xz)>1.7?(0.2 + 0.25*smoothstep(1.45, 1.0, abs(campos.y))):0.2);\n        t+= dist*(abs(dist)>0.1?f1:0.33);\n        //t+= dist*f1;\n  \t}\n  \treturn t;\n}\n\nfloat trace2(vec3 cam, vec3 ray) \n{\n    float t = 3.0;\n  \tfor (int i = 0; i < 15; ++i)\n    {\n    \tvec3 pos = ray*t + cam*0.65;\n    \tfloat dist = map2(pos);\n        t+= dist*0.2;\n  \t}\n  \treturn t;\n}\n\n// From https://www.shadertoy.com/view/MstGDM\nvec3 getNormal(vec3 pos, float e)\n{\n    vec2 q = vec2(0, e);\n    return normalize(vec3(map(pos + q.yxx) - map(pos - q.yxx),\n                          map(pos + q.xyx) - map(pos - q.xyx),\n                          map(pos + q.xxy) - map(pos - q.xxy)));\n}\n\nvec3 obj_color(vec3 norm, vec3 pos)\n{\n    pos.xy = rotateVec(pos.xy, 0.15*smoothstep(40., 200., iTime)*cos(rot*2.));\n    pos.zy = rotateVec(pos.zy, 0.15*smoothstep(40., 200., iTime)*sin(rot*2.));\n    \n    float vf1 = smoothstep(0.15, 0.16, abs(pos.y));\n    vf2 = smoothstep(0.58, 0.59, abs(pos.y))*smoothstep(1.45, 1.42, abs(pos.y));\n    float vf3 = smoothstep(0.255, 0.23, length(vec2(angle3, 3.8*abs(pos.y - scrpos))));\n    \n    vec3 metalcolor = mix(vec3(0.2), vec3(.8, .65, .5), vf1);\n    metalcolor = mix(metalcolor, vec3(1.), vf2);\n    metalcolor = mix(metalcolor, vec3(0.85, 0.5, 0.4), vf3);\n    \n    vec3 diffcolor = mix(vec3(0.45, 0.44, 0.43), vec3(1., 0.63, 0.33), vf1);\n    diffcolor = mix(diffcolor, vec3(0.95), vf2);\n    diffcolor = mix(diffcolor, vec3(0.7, 0.4, 0.35), vf3);\n    \n    float mdmix = mix(0.85, 0.3, smoothstep(0.15, 0.16, abs(pos.y)));\n    mdmix = mix(mdmix, 0.1, vf2);\n    mdmix = mix(mdmix, 0.65, vf3);\n    \n    vec2 posr = rotateVec(pos.xz, rot) + 0.25*pos.yy;\n    vec3 ocol = mix(1.1*metalcolor*texture(iChannel0, reflect(campos, norm)).rgb, diffcolor, mdmix) + 0.03;\n    \n    // Texture\n    vec3 textcolor = mix(vec3(0.), vec3(0.6, 0.4, 0.4), smoothstep(0.155, 0.16, abs(pos.y))\n                     *smoothstep(0.19, 0.225, length(vec2(angle3, 3.2*abs(pos.y - scrpos)))));\n    ocol*= (1.05 - 0.8*textcolor*smoothstep(0.4, 0.7, texture(iChannel1, posr).rrr)\n          *(1.2 - 0.8*smoothstep(0.14, 0.4, texture(iChannel1, 2.4*posr).rrr)));\n    \n    return ocol;\n}\n\n// From https://www.shadertoy.com/view/Xds3zN;\nfloat calcAO(vec3 pos, vec3 nor)\n{\n\tfloat occ = 0.0;\n    float sca = 0.4;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        \n    \tfloat dd = map(aopos);\n        \n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.5*occ, 0.0, 1.0 );    \n}\n\n// From https://www.shadertoy.com/view/Xds3zN;\nfloat softshadow(vec3 ro, vec3 rd, float mint, float tmax)\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n    \tfloat h = map(ro + rd*t);\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.0001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 lampShading(Lamp lamp, vec3 norm, vec3 pos, vec3 ocol)\n{\n\tvec3 pl = normalize(lamp.position - pos);\n    float dlp = distance(lamp.position, pos);\n    vec3 pli = pl/pow(1. + lamp.attenuation*dlp, 2.);\n      \n    // Diffuse shading\n    vec3 col = ocol*normalize(lamp.color)*lamp.intensity*clamp(dot(norm, pli), 0., 1.);\n    \n    // Specular shading\n    #ifdef specular\n    if (dot(norm, lamp.position - pos) > 0.0)\n        col+= vec3(1., 0.7, 0.3)*normalize(lamp.color)*lamp.intensity*specint*pow(max(0.0, dot(reflect(pl, norm), normalize(pos - campos))), specshin);\n    #endif\n    \n    // Softshadow\n    col*= shi*softshadow(pos, normalize(lamp.position-pos), shf, 2.5) + 1. - shi;\n    \n    return col;\n}\n\nvec3 lampsShading(vec3 norm, vec3 pos, vec3 ocol)\n{\n    vec3 col = vec3(0.);\n    for (int l=0; l<3; l++) // lamps.length()\n        col+= lampShading(lamps[l], norm, pos, ocol);\n    \n    return col;\n}\n\n// From https://www.shadertoy.com/view/lsSXzD, modified\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\n{\n\tvec3 vForward = normalize(vCameraDir);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n    \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fov);\n\n\treturn vDir;\n}\n\nvec4 render(vec2 fragCoord)\n{\n  lamps[0] = Lamp(vec3(1., 3.5, -10.), vec3(1., 1., 1.), 4.2, .05);\n  lamps[1] = Lamp(vec3(8., 0.1, 5.), vec3(1.0, 0.45, 0.35), 1.4, 0.01);\n  lamps[2] = Lamp(vec3(-7., -2.4, -6.), vec3(1., 0.96, 0.7), 2.5, 0.05);\n    \n  vec2 uv = fragCoord.xy / iResolution.xy; \n  uv = uv*2.0 - 1.0;\n  uv.x*= iResolution.x / iResolution.y;\n\n  vec3 ray = GetCameraRayDir(uv, camdir, fov);\n    \n  float tx = trace(campos, ray, maxdist);\n  vec3 col;\n  vec3 glowc = 2.5*vec3(smoothstep(40., 100., iTime), smoothstep(50., 105., iTime), smoothstep(60., 110., iTime));   \n      \n  vec3 pos = campos + tx*ray;\n  if (tx<maxdist*0.97)\n  {\n      vec3 norm = getNormal(pos, normdelta);\n\n      // Coloring\n      col = obj_color(norm, pos);\n      \n      // Shading\n      col = glowc*smoothstep(0.58, 0.62, abs(pos.y))*smoothstep(1.46, 1.42, abs(pos.y)) + ambientColor*ambientint + lampsShading(norm, pos, col);\n      \n      // Ambient occlusion\n      col*= 1. - aoint + 1.25*aoint*vec3(calcAO(pos, norm));\n  }\n  else\n  {\n      // \"Sky\"\n      col = ambientColor;\n  }\n\n  // Glowing due to the high speed ;)\n  float tx2 = trace2(campos, ray);\n  col+= 7.*clamp(glowc, 0., 0.65)*(0.3*smoothstep(0.4, 0.2, tx2/11.) + 0.4*smoothstep(0.6, 0.2, (1.9 + 0.6*ray.y*clamp(campos.y, -1.8, 1.8))*tx2/11.));\n      \n  return vec4(col, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    init();\n    \n    // Antialiasing\n    vec4 vs = vec4(0.);\n    for (int j=0;j<aasamples ;j++)\n    {\n       float oy = float(j)*aawidth/max(float(aasamples-1), 1.);\n       for (int i=0;i<aasamples ;i++)\n       {\n          float ox = float(i)*aawidth/max(float(aasamples-1), 1.);\n          vs+= render(fragCoord + vec2(ox, oy));\n       }\n    }\n    fragColor = vs/vec4(aasamples*aasamples);       \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define SCS(N) smoothstep(0.9, 0.99, abs(sin(4.*time + N*0.31*3.141593)))\n\nvec2 mainSound( in int samp, float time )\n{\n    float freq = time*time*0.015;\n    \n    float rotsound = sin(time*freq)*sin(time*freq*1.58 + 2.*sin(time*freq*3.45))+sin(time*freq*2.67*(1. + 0.006*sin(time*freq*22.73)));\n    rotsound*= smoothstep(freq/3.5, 0., 1.);\n    float scrsound = sin(time*(12371. - 18.*freq) + sin((5354. + 35.*freq)*time*(1. + (SCS(1.) + SCS(3.) + 0.006)*0.09*sin(15346.*time))) + 2.*sin(12858.*time))*(SCS(0.)+SCS(1.)+SCS(2.)+SCS(3.));\n    float sound = 0.3*rotsound + (0.1 - 0.001*time)*scrsound;\n    \n    return vec2(sound);\n}","name":"Sound","description":"","type":"sound"}]}