{"ver":"0.1","info":{"id":"4cdcRr","date":"1730170638","viewed":34,"name":"light_sphere","username":"leon_521","description":"sphere_light","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define _R .3\n#define _SPEED 0.05\n#define _PI 3.1415925\n#define PRECISION 0.001\n#define MAX_DIST 200.\n#define MIN_DIST 0.\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\nvec2 getDist(vec3 p)\n{  \n    //vec3 core = vec3(0,0,0);\n    vec3 core = vec3(sin(iTime),0.,sin(iTime)*cos(iTime)*sin(iTime*2.)); \n    \n    \n    float d = length(p-core) - _R ;\n    //float d = length(p-core) - _R + 0.2*sin(p.x*14.) ;\n    \n    vec2 sphere = vec2(d,2.);\n    \n    vec2 box = vec2(sdBox(p + core,vec3(_R)),3. );\n\n    vec2 plane = vec2(p.y+_R ,1.);\n    \n    if (sphere.x<plane.x && sphere.x<box.x )\n    {\n        return sphere;\n    }else if(box.x <plane.x )\n    {\n        return box;\n    }else\n    {\n        return plane;\n    }\n\n}\n\nvec3 calcNormal( in vec3 p )\n{\n    const float h = 0.0001; \n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*getDist( p + k.xyy*h ).x + \n                      k.yyx*getDist( p + k.yyx*h ).x + \n                      k.yxy*getDist( p + k.yxy*h ).x + \n                      k.xxx*getDist( p + k.xxx*h ).x );\n}\n\nvec2 raymarch(vec3 ro,vec3 rd)\n{\n    vec3 p = ro; \n    vec2 go =vec2(MIN_DIST);\n    for(go.x;go.x<MAX_DIST;)\n    {\n        vec2 d = getDist(p);\n        if(d.x<PRECISION)\n        {\n           break;\n        }  \n        go.x += d.x; \n        p  = ro + go.x*rd; \n        go.y = d.y;\n    }\n    \n    return go;\n}\n\nmat3 setCamera(vec3 ro,vec3 ta,float d){\n\n     vec3 z = normalize(ta - ro);\n     vec3 cp = vec3(sin(d),cos(d),0.);\n     vec3 x = normalize(cross(z,cp));\n     vec3 y = cross(x,z);\n     \n     return mat3(x,y,z);\n\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd, float k) {\n    float res = 1.0;\n    for(float t = 0.; t < MAX_DIST;) {\n        float h = getDist(ro + rd * t).x;\n        if(h < PRECISION)\n            return 0.0;\n        res = min(res, k * h / t);\n        t += h;\n    }\n    return res;\n}\n\nfloat calcAO(vec3 p, vec3 n) {\n    float occ = 0.0;\n    float sca = 1.0;\n    for(float i = 0.; i < 5.; i += 1.) {\n        float h = 0.01 + 0.03 * i;\n        float d = getDist(p + n * h).x;\n        occ += (h - d) * sca;\n        sca *= 0.95;\n        if(occ > 0.35)\n            break;\n    }\n    return clamp(1. - 3. * occ, 0., 1.) * (.5 + .5 * n.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord - iResolution.xy) /iResolution.y;\n    vec3 col = vec3(0);\n    vec3 ro = vec3(0.,2.,7.);\n     if(iMouse.z>0.01){\n        float theta = iMouse.x/iResolution.x * 2. *_PI;\n        ro = vec3(4.*cos(theta),2.,4.*sin(theta)); \n    }   \n    vec3 viwUV = setCamera(ro,vec3(0.,0.,0.),0.) * vec3(uv,1.);\n    vec3 rd =  normalize(viwUV - ro ); \n    //vec3 rd =  normalize(vec3(uv,0.) - ro ); \n    vec2 go = raymarch(ro,rd); \n    if (go.x<100.){\n        vec3 p = ro + go.x*rd;\n        vec3 n =  calcNormal(p);\n        vec3 fixP = p  + 2.*PRECISION * n;\n        \n        //light\n        vec3 light = vec3(0.,1.5,1.);\n        vec3 lightDirection = normalize(light - p);\n\n        //diffuse\n        float k_d = 0.5;\n        vec3 i_d = vec3(1.,1.,1.);       \n        float dotLN= dot(lightDirection,n) ;\n        dotLN = clamp(dotLN,0.,1.);\n        vec3 diffuse = dotLN * k_d * i_d;\n        \n         //shadow\n        float shadow = softshadow(fixP, normalize(light - p), 10.);\n        diffuse =shadow*diffuse ;\n            \n   \n        //ambient\n        float k_a =0.6;\n        vec3  i_a = vec3(0.);\n        vec3 ambient = vec3(0.5);\n        if(go.y ==1.0)\n        {\n            i_a = vec3(0.2,0.5,0.3);\n            float gride= mod(floor(p.x*3.) + floor(p.z*3.),2.);\n            i_a *= gride;\n            \n        }else if(go.y==2.0)\n        {\n             i_a = vec3(2.,1.,0.);\n        }else if(go.y==3.0)\n        {\n             i_a = vec3(0.,1.,1.);\n        }\n        ambient= k_a * i_a ;\n   \n         // specular\n        float k_s = 0.2;\n        float dotRV = clamp(dot(reflect(lightDirection, n), rd), 0., 1.);\n        vec3 i_s = vec3(1, 1, 1);\n        float alpha = 10.;\n        vec3 specular = k_s * pow(dotRV, alpha) * i_s;\n        \n        //AO\n        float ao = calcAO(p, n);\n                \n        col = ambient * ao +  diffuse  + specular ;      \n        \n    } \n    fragColor = vec4(col,1);\n}","name":"Image","description":"","type":"image"}]}