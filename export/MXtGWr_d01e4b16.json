{"ver":"0.1","info":{"id":"MXtGWr","date":"1716403057","viewed":77,"name":"Cellular Wave Automata","username":"HaydenS","description":"Cellular wave. Cells activate due to nearby activation and have a cooldown.","likes":6,"published":1,"flags":48,"usePreview":0,"tags":["wave","automata","pathway","nueron"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//RENDERER\n\n// Fancy Color\n\nvec3 magma(float t) {\n\n    const vec3 c0 = vec3(-0.002136485053939582, -0.000749655052795221, -0.005386127855323933);\n    const vec3 c1 = vec3(0.2516605407371642, 0.6775232436837668, 2.494026599312351);\n    const vec3 c2 = vec3(8.353717279216625, -3.577719514958484, 0.3144679030132573);\n    const vec3 c3 = vec3(-27.66873308576866, 14.26473078096533, -13.64921318813922);\n    const vec3 c4 = vec3(52.17613981234068, -27.94360607168351, 12.94416944238394);\n    const vec3 c5 = vec3(-50.76852536473588, 29.04658282127291, 4.23415299384598);\n    const vec3 c6 = vec3(18.65570506591883, -11.48977351997711, -5.601961508734096);\n\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n\n}\n\nvec3 CMRmap(float t) {\n    const vec3 c0 = vec3(-0.046981,0.001239,0.005501);\n    const vec3 c1 = vec3(4.080583,1.192717,3.049337);\n    const vec3 c2 = vec3(-38.877409,1.524425,20.200215);\n    const vec3 c3 = vec3(189.038452,-32.746447,-140.774611);\n    const vec3 c4 = vec3(-382.197327,95.587531,270.024592);\n    const vec3 c5 = vec3(339.891791,-100.379096,-212.471161);\n    const vec3 c6 = vec3(-110.928480,35.828481,60.985694);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\nvec3 blue(float t) {\n    return vec3(sin(iTime)*t/3.0, 0.0, t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // get frame data from buffer A\n    \n    vec4 frameData = texture(iChannel0, uv);\n        \n    vec3 activation = vec3(frameData.r);\n    vec3 wave = CMRmap(frameData.g)*frameData.g;\n    vec3 myelin = blue(frameData.b) / 3.0;\n    \n    vec3 color = clamp(activation + wave + myelin, 0.0, 1.0);\n            \n    fragColor = vec4(color, 1.0);        \n            \n    //See original color:\n    //fragColor = vec4(frameData.rgb, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Engine\n\n// 2 Step Process\n// 1. Activation\n// 2. Cool down and Decay\n\n// Functions\n\nvec3 convolute(mat3 filterKernel, float divisionScalar , vec2 uvCoord){\n        \n    // Offset for the neighboring pixels\n    float Xoffset = 1.0 / iResolution.x;\n    float Yoffset = 1.0 / iResolution.y;\n    \n    vec3 colorSum = vec3(0.0);\n    \n    // Loop over the kernel\n    for (int i = -1; i <= 1; i++) {\n        for (int j = -1; j <= 1; j++) {\n            vec2 offsetCoord = uvCoord + vec2(float(i) * Xoffset, float(j) * Yoffset);\n            vec3 pixelColorAtCoord = texture(iChannel0, offsetCoord).rgb;\n            float scalar = float(filterKernel[i+1][j+1]);\n            \n            vec3 addend = pixelColorAtCoord*scalar;\n            colorSum += addend;  \n        }\n    }\n\n    // Average the sum\n    vec3 color = colorSum / divisionScalar;\n    \n    return color;\n}\n\n\nfloat calculateActivationEnergy(mat3 filterKernel, float divisionScalar, vec2 uvCoord){\n        \n    vec3 energy = convolute(filterKernel, divisionScalar, uvCoord);\n    \n    float activationEnergy = energy.r;\n    \n    return activationEnergy;\n    \n}\n\nbool myelinTestForActivation(float myelinValue, float activationEnergy, vec2 uvCoordinate, float seedForRandom){\n    \n    float randomValue = random(uvCoordinate, seedForRandom);\n    myelinValue *= 1.0 / activationEnergy;\n    \n    return (randomValue < myelinValue);\n\n}\n\n\nfloat activate(){\n    return 1.0;    \n}\n\nfloat unactivate(){\n    return 0.0;\n}\n\nfloat coolingDown(float coolDownValue){\n\n    coolDownValue = coolDownValue - coolReduceAmount;\n    coolDownValue = clamp(coolDownValue, 0.0, 1.0); \n    \n    return coolDownValue;\n}\n\nfloat competitionMyelin(float myelinValue, mat3 filterKernel, vec2 uvCoordinate){\n    \n    vec3 competitionVector = convolute(filterKernel, 8.0*inverseCompetition, uvCoordinate); \n    float competition = competitionVector.b;\n    \n    float difference = myelinValue - competition;\n    float randomValue = random(uvCoordinate, iTime);\n    \n    if (randomValue > difference + 1.0){\n        myelinValue -= myelinDecrease;\n    }\n    \n    return myelinValue;\n}\n\nfloat decayMyelin(float myelinValue){\n    \n    float newMyelin = myelinValue / 1.0001;\n    newMyelin = clamp(newMyelin, minimumProbability, maximumProbability);\n    \n    return newMyelin;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 color;\n    \n        \n    // Initial Condition\n    if( (iFrame == 0)  || (isKeyPressed(spaceBar, iChannel1)) ) {\n        \n        fragColor = initialize(uv, iResolution);\n        return;\n    }\n    \n    // get previousData\n    vec4 previousFrameData = texture(iChannel0,uv);\n    \n    float currentActivation = previousFrameData.r;\n    float currentCoolDown = previousFrameData.g;\n    float currentMyelin = previousFrameData.b;\n    \n    float activation;\n    float coolDown;\n    float myelin;\n    \n    // Step 1: Activation\n    \n    if (currentCoolDown == 0.0){\n        \n        float activationEnergy = calculateActivationEnergy(neighborKernel, divisionScalar, uv);\n        \n        if (activationEnergy >= 1.0){\n            \n            currentCoolDown = max(currentCoolDown, almostActivatedCoolDown);\n                        \n            bool activated = myelinTestForActivation(currentMyelin, activationEnergy, uv, iTime);\n            \n            if (activated){\n                activation = 1.0;\n                currentCoolDown = 1.0;\n                currentMyelin = min(1.0, currentMyelin + myelinIncrease);\n            }\n            \n        } \n        \n    } else {\n        // Cool Down is not zero. Unactivate\n            \n        activation = 0.0;\n  \n    }\n    \n    // Step 2: Cool Down and Decay\n    \n    coolDown = coolingDown(currentCoolDown);\n    \n    currentMyelin = competitionMyelin(currentMyelin, neighborKernel, uv);\n    myelin = decayMyelin(currentMyelin);\n\n\n    // Add Activated Cells at mouse hold\n\n    float mouseDistance = pow(iMouse.x - fragCoord.x, 2.0) + pow(iMouse.y - fragCoord.y, 2.0);\n\n    if( mouseDistance < 50.0 && iMouse.z > 0.0) {\n        activation = 1.0;\n        coolDown = 0.0;\n        myelin = 1.0;    \n    }\n\n    fragColor = vec4(activation, coolDown, myelin, 1.0);\n\n}\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n// Red Activation Energy 1.0 Activated\n// Green Cool Down 0.0 Ready to be Activated\n// Blue Myelin Probability of Activation\n\n// CONFIGURABLES\n\n// Cool Down Configurables\n\nfloat coolReduceAmount = 0.03;\nfloat almostActivatedCoolDown = 0.2;\n\n// Myelin Configurables\n\nfloat minimumProbability = 0.001;\nfloat maximumProbability = 0.96;\nfloat myelinIncrease = 0.5;\n\nfloat inverseCompetition = 0.7;\nfloat myelinDecrease = 0.01;\n\n\n// Initial Condition\n\nfloat initialActivationPercentage = 0.001;\nfloat activationSeed = 2.0;\n\nfloat initialMyelinMaximum = 1.0;\nfloat myelinSeed = 3.0;\nfloat myelinPerlinCells = 20.0;\n// Power Reduction > 1.0 makes more lower value squares \n// 1.0 is linear\n//Power Reduction < 1.0 makes more higher value squares\nfloat myelinPowerReduction = 0.9;\n\n// Functions\n\n//Random Number Generator\nfloat random(vec2 coordinate, float t){\n    return fract(sin(t + dot(coordinate, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n\n// PERLIN NOISE\n// Fork of \"Simple 2d perlin noise\" by SpectreSpect. https://shadertoy.com/view/DsK3W1\n// 2024-05-22 08:32:34\n// This is for the Perlin Noise only\n\nvec2 n22 (vec2 p)\n{\n    vec3 a = fract(p.xyx * vec3(123.34, 234.34, 345.65));\n    a += dot(a, a + 34.45);\n    return fract(vec2(a.x * a.y, a.y * a.z));\n}\n\nvec2 get_gradient(vec2 pos)\n{\n    float twoPi = 6.283185;\n    float angle = n22(pos).x * twoPi;\n    return vec2(cos(angle), sin(angle));\n}\n\nfloat perlin_noise(vec2 uv, float cells_count)\n{\n    vec2 pos_in_grid = uv * cells_count;\n    vec2 cell_pos_in_grid =  floor(pos_in_grid);\n    vec2 local_pos_in_cell = (pos_in_grid - cell_pos_in_grid);\n    vec2 blend = local_pos_in_cell * local_pos_in_cell * (3.0f - 2.0f * local_pos_in_cell);\n    \n    vec2 left_top = cell_pos_in_grid + vec2(0, 1);\n    vec2 right_top = cell_pos_in_grid + vec2(1, 1);\n    vec2 left_bottom = cell_pos_in_grid + vec2(0, 0);\n    vec2 right_bottom = cell_pos_in_grid + vec2(1, 0);\n    \n    float left_top_dot = dot(pos_in_grid - left_top, get_gradient(left_top));\n    float right_top_dot = dot(pos_in_grid - right_top,  get_gradient(right_top));\n    float left_bottom_dot = dot(pos_in_grid - left_bottom, get_gradient(left_bottom));\n    float right_bottom_dot = dot(pos_in_grid - right_bottom, get_gradient(right_bottom));\n    \n    float noise_value = mix(\n                            mix(left_bottom_dot, right_bottom_dot, blend.x), \n                            mix(left_top_dot, right_top_dot, blend.x), \n                            blend.y);\n   \n    \n    return (0.5 + 0.5 * (noise_value / 0.7));\n}\n\n// Neighbor Kernel\n\nmat3 neighborKernel = mat3(\n    1.0, 1.0, 1.0,\n    1.0, 0.0, 1.0,\n    1.0, 1.0, 1.0\n);\n\nfloat divisionScalar = 1.0;\n\n#define spaceBar 32\n\nbool isKeyPressed(int keyNumber, sampler2D channel)\n{\n\treturn texelFetch(channel, ivec2(keyNumber, 0), 0).r > 0.0;\n}\n\nvec4 initialize(in vec2 uvCoord, in vec3 resolution) {\n\n    // aspect ratio\n    uvCoord.x *= resolution.x / resolution.y;\n\n    vec4 fragColor;\n\n    // Red Activation Energy\n    \n    float randomValue = random(uvCoord, activationSeed);\n    \n    bool initialActivate = (0.01 < randomValue && 0.01 + initialActivationPercentage > randomValue);\n    \n    if (initialActivate){\n        fragColor.r = 1.0;\n    } else {\n        fragColor.r = 0.0;\n    }\n    \n    // Green Cool Down\n    \n    fragColor.g = 0.0;\n    \n    // Blue Myelin\n    \n    fragColor.b = pow(initialMyelinMaximum*perlin_noise(uvCoord, myelinPerlinCells), myelinPowerReduction);\n    \n    return fragColor;\n}\n\n\n","name":"Common","description":"","type":"common"}]}