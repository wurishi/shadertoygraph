{"ver":"0.1","info":{"id":"wlyyWt","date":"1612076746","viewed":103,"name":"differentiable ray casting","username":"shiinamiyuki","description":"differentiable ray casting against sphere sdf\nshowing gradient of sphere center ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 center = vec3(0,0,0);\nfloat sdf(vec3 p){\n    return length(p - center) - 1.0;\n}\n\n\nvec3 dsdfdc(vec3 p){\n    vec3 u = p - center;\n    return -normalize(u);\n}\n\nvec3 dsdfdp(vec3 p){\n    return normalize(p - center);\n}\n\nmat3 dpdc(vec3 o, vec3 d, float t){\n    vec3 p = o + t * d;\n    // p = o + td - d /  dot(dsdfdp, d)* sdf(o + td)\n    //                    k\n    // dpdc = \n    float k = dot(dsdfdp(p), d);\n    return mat3(d / k * dsdfdc(p).x,d / k * dsdfdc(p).y,d / k * dsdfdc(p).z);\n}\nvec3 tracep(vec3 o, vec3 d){\n    float t = 0.0;\n    for(int i=0;i<20;i++){\n        vec3 p = o + t * d;\n        float dt = sdf(p);\n        if(dt < 1e-3){\n            return p;\n        }\n        t += dt;\n    }\n    return vec3(0);\n}\nconst float eps_shading = 1e-6;\nconst float eps_edge = 1e-5;\nvec3 color(vec3 p){\n    if(sdf(p) < eps_shading){\n        return vec3(1);\n    }\n    return vec3(0);\n\n}\n\nvec3 trace(vec3 o, vec3 d){\n    float t = 0.0;\n    float min_t = 1e7;\n    float min_f = 1e7;\n    bool hit = false;\n    for(int i=0;i<20;i++){\n        vec3 p = o + t * d;\n        float dt = sdf(p);\n        if(dt < min_f){\n            min_f = dt;\n            min_t = t;\n        }\n        \n        if(dt < eps_shading){\n            //break;\n            return color(p);\n            //return dpdc(o, d, t);\n            //return vec3(1);\n        }\n        t += dt;\n        \n    }\n    if(min_f < eps_edge){\n        vec3 p = o + t * d;\n        vec3 n = dsdfdp(p);\n        vec3 col = color(p - n * eps_edge);\n       vec3 aa_col = vec3(clamp((1.0 - min_f / eps_edge), 0.0, 1.0));\n       return aa_col;\n    }\n    return vec3(0);\n}\n\n\nvec3 diff_trace(vec3 o, vec3 d){\n    float t = 0.0;\n    float min_t = 1e7;\n    float min_f = 1e7;\n    bool hit = false;\n    for(int i=0;i<20;i++){\n        vec3 p = o + t * d;\n        float dt = sdf(p);\n        if(dt < min_f){\n            min_f = dt;\n            min_t = t;\n        }\n        \n        if(dt < eps_shading){\n            //break;\n            return vec3(0);\n            //return dpdc(o, d, t);\n            //return vec3(1);\n        }\n        t += dt;\n        \n    }\n    if(min_f < eps_edge){\n        vec3 p = o + t * d;\n        vec3 n = dsdfdp(p);\n        vec3 dsdfdc = n *  dpdc(o, d, t);\n        vec3 col = color(p - n * eps_edge);\n        //vec3 aa_col = vec3(clamp((1.0 - min_f / eps_edge), 0.0, 1.0));\n        vec3 dcol = vec3(0);\n        if((1.0 - min_f / eps_edge) > 0.0 && (1.0 - min_f / eps_edge) < 1.0)\n        dcol = vec3(1.0 - dsdfdc / eps_edge);\n        return dcol;\n    }\n    return vec3(0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n\n    uv.x = 2.0f * uv.x -1.0f;\n    uv.y = 2.0f * (uv.y) - 1.0f;\n    uv.x *= iResolution.x / iResolution.y;\n#define MSAA 2\n    vec3 col;\n    vec2 offset = vec2(2) / iResolution.xy / float(MSAA);\n    for(int i =0;i< MSAA;i++){\n        for(int j =0 ;j<MSAA;j++){\n            vec3 o = vec3(0,0,-6);\n            vec3 d = vec3(uv + offset * vec2(i,j), 0) - vec3(0,0, -2);\n            d = normalize(d);\n            col += diff_trace(o, d) * 0.5 + 0.5;\n        }\n    }\n   \n\tcol /= float(MSAA) * float(MSAA);\n    //col = pow(col, vec3(1.0f/2.2f));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}