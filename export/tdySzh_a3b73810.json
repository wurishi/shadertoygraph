{"ver":"0.1","info":{"id":"tdySzh","date":"1573388073","viewed":112,"name":"march dat ray","username":"nff","description":"simplest raymarching, no lighting\ntodo: lighting LOL\nfind more SDFs here: http://iquilezles.org/articles/distfunctions/distfunctions.htm","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","simple","torus","sphere","dodecahedron","octahedron"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#version 410 core // for BONZO and KODELIFE only - comment in shadertoy\n//#extension GL_ARB_shading_language_include : require // comment in shadertoy\n//#include \"H:/shaderz/bao.h\"\n//#version 150 // once used for KODELIFE, but 410 core looks like it's working for both bonzo and KODELIFE :)\n//#define KODELIFE // https://hexler.net/products/kodelife\n#define SHADERTOY // https://www.shadertoy.com/\n//#define BONZOMATIC // https://github.com/Gargaj/Bonzomatic/releases (use the GLFW version)\n\n#ifdef BONZOMATIC\n  uniform float fGlobalTime; // in seconds\n  uniform vec2 v2Resolution; // viewport resolution (in pixels)\n  uniform sampler1D texFFT; // towards 0.0 is bass / lower freq, towards 1.0 is higher / treble freq\n  uniform sampler1D texFFTSmoothed; // this one has longer falloff and less harsh transients\n  uniform sampler1D texFFTIntegrated; // this is continually increasing\n  uniform sampler2D texChecker;\n  uniform sampler2D texNoise;\n  uniform sampler2D texTex1;\n  uniform sampler2D texTex2;\n  uniform sampler2D texTex3;\n  uniform sampler2D texTex4;\n  layout(location = 0) out vec4 out_color; // out_color must be written in order to see anything\n  #define MAIN void main(void){\\\n        vec2 uv = ((vec2(fragCoord.x / res.x, fragCoord.y / res.y))-.5) / vec2(res.y / res.x, 1) *2.;\n  #define tt fGlobalTime\n  #define res v2Resolution\n  #define fragCoord gl_FragCoord\n  #define fragColor out_color\n#endif // BONZOMATIC\n\n#ifdef KODELIFE\n    uniform float time;\n    uniform vec2 resolution;\n    uniform vec2 mouse;\n    uniform vec3 spectrum;\n    in VertexData {\n        vec4 v_position;\n        vec3 v_normal;\n        vec2 v_texcoord;\n    } inData;\n    out vec4 fragColor;\n    uniform sampler2D texture0;\n    uniform sampler2D texture1;\n    uniform sampler2D texture2;\n    uniform sampler2D texture3;\n    uniform sampler2D prevFrame;\n    uniform sampler2D prevPass;\n    #define MAIN void main(void){\\\n        vec2 uv = vec2((fragCoord.x -.5)*4., (fragCoord.y -.5)*(res.y / res.x)*4.);\n    #define tt time\n    #define res resolution\n    #define fragCoord inData.v_texcoord\n#endif // KODELIFE\n\n#ifdef SHADERTOY\n    #define MAIN void mainImage( out vec4 fragColor, in vec2 fragCoord ){\\\n        vec2 uv = vec2(((fragCoord.x / res.x)*2.0 -1.0)*(res.x / res.y), ((fragCoord.y / res.y)*2.0 -1.0));\n    #define tt iTime\n    #define res iResolution\n#endif // SHADERTOY\n\n#define PI 3.14159265359\n#define TAU 6.283185307179586\n#define PHI 1.618033988749895\n\n//////// SDF MODELS ////////\n// SDF = Signed Distance Function. Returns the distance between a given point (point of view in our case) and the surface of an object.\n// So it's basically the description of an object throught the distance of each of its surface points from a given, single point.\n\nfloat sphereSDF(vec3 p, float radius){\n    return length(p) - radius; \n}\n\nfloat boxSDF( vec3 p, vec3 sizes ){\n  vec3 q = abs(p) - sizes;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat torusSDF( vec3 p, float r, float thickness ){\n  vec2 q = vec2(length(p.xz)-r,p.y);\n  return length(q)- thickness;\n}\n\nfloat torusSDFx( vec3 p, float r, float thickness ){\n  vec2 q = abs(vec2(length(p.xz)-r,p.y)) - .2;\n  return abs(length(q))- thickness;\n}\n\nfloat torusSDF_melt( vec3 p, float r, float thickness ){\n  vec2 q = fract(.3 * vec2(length(p.xz)-r,p.y));\n  return length(q)- thickness;\n}\n\nfloat torusSDF_multi2( vec3 p, float r, float thickness ){\n  vec2 q = vec2(length(p.xz)-r,p.y);\n    vec2 qq = fract(q) * 2. - 1.;\n  return length(qq)- thickness;\n}\n\nfloat torusSDF_multi( vec3 p, float r, float thickness ){ // a torus inside a torus inside a torus inside a torus inside a torus inside a torus\n  vec2 q = fract(vec2(length(p.xz)-r,p.y) *.5);\n  return length(q)- thickness;\n}\n\nfloat octaSDF( vec3 center, float size){\n    center = abs(center);\n    return (center.x + center.y + center.z - size)*0.57735027;\n}\n\nfloat octaSDF_mult( vec3 p, float dim){ // an octahedron inside an octahedron inside an octahedron inside an octahedron inside an octahedron\n    p = abs(p);\n    return fract((p.x+p.y+p.z-dim)*0.57735027);\n}\n\nfloat dodeca(vec3 p, float r) { // quite messy uhm, I think one could do that muuuuuuuuch simpler\n    float d = 0.;\n    d = max(d, abs(dot(p, normalize(vec3(0, PHI, 1)))));\n    d = max(d, abs(dot(p, normalize(vec3(0, -PHI, 1)))));\n    d = max(d, abs(dot(p, normalize(vec3(1, 0, PHI)))));\n    d = max(d, abs(dot(p, normalize(vec3(-1, 0, PHI)))));\n    d = max(d, abs(dot(p, normalize(vec3(PHI, 1, 0)))));\n    d = max(d, abs(dot(p, normalize(vec3(-PHI, 1, 0)))));\n    return d - r;\n}\n\n/// Inigo Quilez's 4D Box, from https://www.shadertoy.com/view/WtB3Wt\n\nfloat box4d( in vec4 p, in vec4 b ){\n    vec4 d = abs(p) - b;\n    return min( max(max(d.x,d.y),max(d.z,d.w)),0.0) + length(max(d,0.0));\n    //return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sphere4d(vec4 p, float radius){\n    return length(p) - radius; \n}\n\nfloat torus4d( vec4 p, float r, float thickness ){\n  vec2 q = vec2(length(p.xz)-r,p.y);\n  return length(q)- thickness;\n}\n\nmat4 q2m( vec4 q ){\n    return mat4( q.x, -q.y, -q.z, -q.w,\n                   q.y,  q.x, -q.w,  q.z,\n                   q.z,  q.w,  q.x, -q.y,\n                   q.w, -q.z,  q.y, q.x );\n}\n\nfloat rotate4D( vec3 pos, float time ){\n    // take a 3D slice\n    vec4 p = vec4(pos,0.5*sin(time*0.513));\n    \n    // rotate 3D point into 4D\n    vec4 q1 = normalize( cos( 0.2*time*vec4(1.0,1.7,1.1,1.5) + vec4(0.0,1.0,5.0,4.0) ) );\n    vec4 q2 = normalize( cos( 0.2*time*vec4(1.9,1.7,1.4,1.3) + vec4(3.0,2.0,6.0,5.0) ) );\n    p = q2m(q2)*p*q2m(q1);\n    \n    // final 4D model SDF rendering\n    #define roundEdge 0.\n    return box4d( p, vec4(.8) ) - roundEdge;\n    //return sphere4d(p, 1.);\n    //return torus4d(p, .5, .01);\n}\n//////// END OF SDF MODELS ////////\n\nvec3 multiply(vec3 model){\n    return fract(model);\n}\n\nvec3 rotate(vec3 object, float rotXZspeed, float rotXYspeed){\n    float xz = tt * rotXZspeed;\n    float xy = tt * rotXYspeed;\n    object.xz *= mat2(cos(xz), -sin(xz), sin(xz), cos(xz));\n    object.xy *= mat2(cos(xy), -sin(xy), sin(xy), cos(xy));\n    return object;\n}\n\nvec3 twist(vec3 p, float twist){ // we are twisting by displacing each single point\n    float c = cos(twist*p.y);\n    float s = sin(twist*p.y);\n    mat2  m = mat2(c, -s ,s , c);\n    vec3  q = vec3((m * p.xz), p.y);\n    return q;\n}\n\nfloat trace(vec3 pov, vec3 ray){ // looking to bump into something, given a point of view and a ray shooting from it\n    float t = 0.0; // start from 0\n    const int maxSteps = 64; // how many tries along the ray (try lower values to blurrrr)\n    for (int i = 0; i < maxSteps; i++){ \n        vec3 p = pov + ray * t; // current position along the ray\n        \n        // choose a model to render here: (you can also add them together!)\n        // here we use an SDF to see if we bumped into something (the model of our object)\n        //float d = sphereSDF(vec3(p.x, p.y, p.z + (sin(tt * 2.))), 1.);\n        //float d = torusSDF(rotate(twist(p, .5), 1.,1.), 2., .05); \n        //float d = octaSDF(rotate(p, 1., 1.), 2.);\n        //float d = rotate4D(p, tt); //((mouse.y*2.)-1.));\n        //float d = boxSDF(rotate(p, 1. ,1.), vec3(1.,1.,1.));\n        //float d = min(sphereSDF(p, 1.3), boxSDF(rotate(p, 1. ,1.), vec3(1.,1.,1.)));\n        float d = sphereSDF(p, 1.);//simple sphere, no movement\n        \n        float stepLenght = 0.5; // lenght of a step along the ray. playing with this value can lead to a fuzzy feel\n        t += d * stepLenght; // take a step\n    }\n    return t;\n}\n\nfloat contrastBW( float colorIN, float c) {\n    return colorIN * c + (0.5 - c * 0.5);\n}\n\nfloat distanceFalloff(float dist, float maxBright, float falloff, float slope){ // Distance Falloff; given a distance, computes a brightness value; the farther it is, the darker it gets. it is needed to visualize the geometry\n    return (maxBright / (1.0 + pow(dist, slope) * falloff));\n}\n\n///////////////////////////////////////////////////////////////////////////////\nMAIN\n     \n    vec3 pov = vec3(0.0,0.0,-3.0); // position of the point of view\n    vec3 r = normalize(vec3(uv, 1.0)); // a ray shooting from the point of view\n    \n    float t = trace(pov,r); // shoot dat ray biaaaatch!\n    t = distanceFalloff(t, 1., 0.1, 2.); // compute the actual brightness\n    \n\n    //vec3 color = vec3(1.,.47,0.); // safety orange <3\n    vec3 color = vec3(1.,1.,1.);\n    #define mainContrast 1.\n    \n    fragColor = vec4(vec3(contrastBW(t, mainContrast) * color), 1.);\n}","name":"Image","description":"","type":"image"}]}