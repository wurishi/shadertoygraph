{"ver":"0.1","info":{"id":"NtjGWG","date":"1624612755","viewed":113,"name":"Ball of Saturation 3","username":"egon","description":"Color-wheel using oklab for the ball and outer circle.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["colorwheel"],"hasliked":0,"parentid":"flSGDy","parentname":"Ball of Saturation 2"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TAU (2.0*3.1415926538)\n\nvec2 rot(vec2 pos, float a) {\n\tfloat sn = sin(a);\n\tfloat cs = cos(a);\n\treturn mat2(cs, -sn, sn, cs) * pos;\n}\n\nfloat map(float p, float ss, float se, float ds, float de)\n{\n    return ds + (p-ss)*(de-ds)/(se-ss);\n}\n\nfloat shade(vec2 pos, float dir) {\n    pos = rot(pos, dir);\n    float h = cos(pos.x);\n    return map(pos.y, h, -h, 0.0, 1.0);\n}\n\n//http://gamedev.stackexchange.com/questions/59797/glsl-shader-change-hue-saturation-brightness\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvec3 hsv2rgb_subtractive( in vec3 c ) {\n    float frac = fract(c.x)*6.0;\n    vec3 col = smoothstep(vec3(3,0,3),vec3(2,2,4),vec3(frac));\n    col += smoothstep(vec3(4,3,4),vec3(6,4,6),vec3(frac)) * vec3(1, -1, -1);\n    return mix(vec3(1), col, c.y) * c.z;\n}\n\n#define cbrtf(x)  ( sign(x)*pow(abs(x),1./3.) )\n\n// linear_srgb_to_oklab\nvec3 rgb2oklab(vec3 c) \n{\n    float l = 0.4122214708f * c.r + 0.5363325363f * c.g + 0.0514459929f * c.b;\n\tfloat m = 0.2119034982f * c.r + 0.6806995451f * c.g + 0.1073969566f * c.b;\n\tfloat s = 0.0883024619f * c.r + 0.2817188376f * c.g + 0.6299787005f * c.b;\n\n    float l_ = cbrtf(l);\n    float m_ = cbrtf(m);\n    float s_ = cbrtf(s);\n\n    return vec3(\n        0.2104542553f*l_ + 0.7936177850f*m_ - 0.0040720468f*s_,\n        1.9779984951f*l_ - 2.4285922050f*m_ + 0.4505937099f*s_,\n        0.0259040371f*l_ + 0.7827717662f*m_ - 0.8086757660f*s_\n    );\n}\n\n// oklab_to_linear_srgb\nvec3 oklab2rgb(vec3 c) \n{\n    float l_ = c.x + 0.3963377774f * c.y + 0.2158037573f * c.z;\n    float m_ = c.x - 0.1055613458f * c.y - 0.0638541728f * c.z;\n    float s_ = c.x - 0.0894841775f * c.y - 1.2914855480f * c.z;\n\n    float l = l_*l_*l_;\n    float m = m_*m_*m_;\n    float s = s_*s_*s_;\n\n    return vec3(\n\t\t+4.0767416621f * l - 3.3077115913f * m + 0.2309699292f * s,\n\t\t-1.2684380046f * l + 2.6097574011f * m - 0.3413193965f * s,\n\t\t-0.0041960863f * l - 0.7034186147f * m + 1.7076147010f * s\n    );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord;\n    vec2 center = iResolution.xy * 0.5;\n    \n    float inside  = 0.3 * iResolution.y;\n    float mid     = 0.35 * iResolution.y;\n    float outside = 0.45 * iResolution.y;\n    \n    vec2 off = center - uv;\n\n    float h = mod(iTime*0.1, 1.0);\n    if(iMouse.z > 0.0){\n        vec2 p = normalize(center - iMouse.xy);\n        h = atan(-p.y, -p.x) / TAU;\n    }\n\n    float d = length(off);\n    if(d < inside){\n        off /= inside;\n\n        float v = shade(off, 0.0/3.0 * TAU);\n        float s = shade(off, -1.0/4.0 * TAU);\n\n        //fragColor = vec4(hsv2rgb(vec3(h, s, v)), 1.0);\n        fragColor = vec4(oklab2rgb(vec3(v, s, h)), 1.0);\n    } else if (mid < d && d < outside) {\n        off = normalize(off);\n        float h = atan(-off.y, -off.x) / TAU;\n        fragColor = vec4(hsv2rgb_subtractive(vec3(h, 0.9, 1.0)), 1.0);\n    } else {\n        fragColor = vec4(0.1, 0.13, 0.15, 1.0);\n    }\n}\n\n","name":"Image","description":"","type":"image"}]}