{"ver":"0.1","info":{"id":"NdXcRB","date":"1642536615","viewed":180,"name":"HashCorp","username":"shau","description":"another scene rendered using sparse grid marching from Nimitz","likes":17,"published":1,"flags":32,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by SHAU - 2022\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n/**\n * Lots of geometry initially inspired by Hashicorp animation on their homepage\n * ... then by hashing functions from Dave Hoskins so a subtle name change\n * Fast geometry rendering from \"Sparse grid marching\" by Nimitz   \n **/\n \nconst float GA =2.399; \n\n// simplified version of Dave Hoskins blur\nvec3 dof(sampler2D tex, vec2 uv, float rad) {\n\tvec3 acc = vec3(0);\n    vec2 pixel = vec2(.002*R.y/R.x, .002), angle = vec2(0, rad);;\n    rad = 1.;\n\tfor (int j = 0; j < 80; j++) {  \n        rad += 1. / rad;\n\t    angle *= rot(GA);\n        vec4 col=texture(tex,uv+pixel*(rad-1.)*angle);\n\t\tacc+=col.xyz;\n\t}\n\treturn acc/80.;\n}\n\nvoid mainImage(out vec4 C, vec2 U) {\n    vec2 uv = U/R;\n\tvec3 pc = vec4(dof(iChannel0, uv, texture(iChannel0, uv).w), 1.).xyz;\n    C = vec4(pc*smoothstep(0.5,5.0,T), 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by SHAU - 2022\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n#define EPS .002\n#define FAR 50.\n#define PHI 1.618033\n#define BOUNCES 2\n\n//Dave Hoskins\n//https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//Shane IQ\nfloat n3D(vec3 p) \n{    \n\tconst vec3 s = vec3(7.0,157.0,113.0);\n\tvec3 ip = floor(p); \n    p -= ip; \n    vec4 h = vec4(0.0,s.yz,s.y + s.z) + dot(ip,s);\n    p = p * p * (3.0 - 2.0 * p);\n    h = mix(fract(sin(h)*43758.5453),fract(sin(h + s.x)*43758.5453),p.x);\n    h.xy = mix(h.xz,h.yw,p.y);\n    return mix(h.x,h.y,p.z);\n}\n\nfloat fbm(vec3 x) \n{\n    float r = 0.0,\n          w = 1.0,\n          s = 1.0;\n    for (int i=ZERO; i<5; i++) \n    {\n        w *= 0.5;\n        s *= 2.0;\n        r += w * n3D(s*x);\n    }\n    return r;\n}\n\n//Nimitz\n//https://www.shadertoy.com/view/XlfGDs\nconst float c=1.0, ch=c*0.5, ch2=ch+0.01;\nfloat dBox(vec3 ro, vec3 rd) {\n    vec3 t = -1./rd*ro + abs(1./rd)*ch2;\n\treturn min(min(t.x, t.y), t.z);\n}\n\n//Shane - Perspex Web Lattice - one of my favourite shaders\n//https://www.shadertoy.com/view/Mld3Rn\n//Standard hue rotation formula... compacted down a bit.\nvec3 rotHue(vec3 p, float a)\n{\n    vec2 cs = sin(vec2(1.570796, 0) + a);\n\n    mat3 hr = mat3(0.299,  0.587,  0.114,  0.299,  0.587,  0.114,  0.299,  0.587,  0.114) +\n        \t  mat3(0.701, -0.587, -0.114, -0.299,  0.413, -0.114, -0.300, -0.588,  0.886) * cs.x +\n        \t  mat3(0.168,  0.330, -0.497, -0.328,  0.035,  0.292,  1.250, -1.050, -0.203) * cs.y;\n\t\t\t\t\t\t\t \n    return clamp(p*hr, 0., 1.);\n}\n\n//distance functions from IQ\n//https://iquilezles.org/articles/distfunctions\n//https://iquilezles.org/articles/distfunctions2d\n//...and Mercury\n//https://mercury.sexy/hg_sdf/\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nfloat opExtrussion( in vec3 p, in float sdf, in float h )\n{\n    vec2 w = vec2( sdf, abs(p.z) - h );\n  \treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nconst vec3 GDFVectors[19] = vec3[](\n\tnormalize(vec3(1, 0, 0)),\n\tnormalize(vec3(0, 1, 0)),\n\tnormalize(vec3(0, 0, 1)),\n\n\tnormalize(vec3(1, 1, 1 )),\n\tnormalize(vec3(-1, 1, 1)),\n\tnormalize(vec3(1, -1, 1)),\n\tnormalize(vec3(1, 1, -1)),\n\n\tnormalize(vec3(0, 1, PHI+1.)),\n\tnormalize(vec3(0, -1, PHI+1.)),\n\tnormalize(vec3(PHI+1., 0, 1)),\n\tnormalize(vec3(-PHI-1., 0, 1)),\n\tnormalize(vec3(1, PHI+1., 0)),\n\tnormalize(vec3(-1, PHI+1., 0)),\n\n\tnormalize(vec3(0, PHI, 1)),\n\tnormalize(vec3(0, -PHI, 1)),\n\tnormalize(vec3(1, 0, PHI)),\n\tnormalize(vec3(-1, 0, PHI)),\n\tnormalize(vec3(PHI, 1, 0)),\n\tnormalize(vec3(-PHI, 1, 0))\n);\n\n// Version with without exponent, creates objects with sharp edges and flat faces\nfloat fGDF(vec3 p, float r, int begin, int end) {\n\tfloat d = 0.;\n\tfor (int i = begin; i <= end; ++i)\n\t\td = max(d, abs(dot(p, GDFVectors[i])));\n\treturn d - r;\n}\n\nfloat fDodecahedron(vec3 p, float r) {\n\treturn fGDF(p, r, 13, 18);\n}\n\nfloat fIcosahedron(vec3 p, float r) {\n\treturn fGDF(p, r, 3, 12);\n}\n\nvec2 map(vec3 p, vec3 rd) \n{\n    float at = fract(T*0.05),\n          rt = smoothstep(0.0,0.1,at)*smoothstep(1.0,0.9,at),\n          h11 = hash11(floor(T*0.05)),\n          hit = 0.0;\n    p.z += sin(T*(hash12(floor(p.xy))-0.5))*4.0;\n    vec3 qd = fract(p/c)*c -ch, qid = floor(p/c);\n    float t = dBox(qd,rd); //Base distance is cell exit distance\n    vec2 h23 = hash23(qid);\n    \n    if (p.z>0.0&&p.z<1.0 && mod(floor(p.x)+floor(p.y),4.0)==0.0)\n    {\n        hit = 1.0;\n        qd.yz *= rot(T*0.3 + abs(h23.y) + abs(h23.x)*T);\n        qd.zx *= rot(T*0.2 + abs(h23.x) + abs(h23.y)*T);\n        if (h11>0.75) {\n            t = sdBox(qd,vec3(0.3*rt));\n        } else if (h11>0.5) {\n            t = sdOctahedron(qd,0.3*rt);\n        } else if (h11>0.25) {\n            t = fIcosahedron(qd,0.3*rt);\n        } else {\n            t = fDodecahedron(qd,0.3*rt);\n        }\n    }\n    \n    return vec2(t,hit);\n}\n\n//Shane\n//https://www.shadertoy.com/view/Mld3Rn\nvec3 normal(vec3 p, vec3 rd, inout float edge) { \n    vec2 e = vec2(EPS, 0);\n\tfloat d1 = map(p + e.xyy,rd).x, d2 = map(p - e.xyy,rd).x,\n\t      d3 = map(p + e.yxy,rd).x, d4 = map(p - e.yxy,rd).x,\n\t      d5 = map(p + e.yyx,rd).x, d6 = map(p - e.yyx,rd).x,\n\t      d = map(p,rd).x*2.;\n    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n    edge = smoothstep(0., 1.0, sqrt(edge/e.x*2.));\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\nfloat march(vec3 ro, vec3 rd) \n{\n    float t = 0.0;   \n    for (int i=ZERO; i<180; i++)\n    {\n        float ns = map(ro + rd*t,rd).x;\n        if (abs(ns)<EPS)\n        {\n            break;\n        }\n        t += ns;\n        if (t>FAR) \n        {\n            t = -1.0;\n            break;\n        }\n        \n    }\n    return t;\n}\n\nfloat wall(vec2 p, vec2 ws)\n{\n    p.y -= 3.0;\n    float lt = abs(fract((length(p- vec2(4.0,0.0))+fract(T*-0.2))) - 0.5);\n    lt = min(lt,abs(fract((length(p- vec2(-4.0,0.0))+fract(T*-0.2))) - 0.5));\n    lt = min(lt,abs(fract((length(p- vec2(0.0,-6.92))+fract(T*-0.2))) - 0.5));\n    lt = step(lt,0.1);\n    if (ws.y>0.) \n    {\n        lt = max(lt,step(ws.x,0.16));\n        lt *= step(0.12,ws.x);\n    }\n    return lt;\n}\n\n//Moody clouds from Patu\n//https://www.shadertoy.com/view/4tVXRV\nvec3 clouds(vec3 rd) {\n    vec2 uv = rd.xz / (rd.y + 0.0);\n    float nz = fbm(vec3(uv.yx * 1.4 + vec2(T/14., 0.0), T/14.)) * 1.5;\n    return clamp(pow(vec3(nz), vec3(4.0)) *abs(pow(rd.y,4.0)), 0.0, 1.0);\n}\n\nvec3 camera(vec2 U, vec3 ro, vec3 la, float fl) \n{\n    vec2 uv = (U - R*.5) / R.y;\n    vec3 fwd = normalize(la-ro),\n         rgt = normalize(vec3(fwd.z,0.0,-fwd.x));\n    return normalize(fwd + fl*uv.x*rgt + fl*uv.y*cross(fwd, rgt));\n}\n\nvoid mainImage(out vec4 C, vec2 U)\n{\n    vec3 pc = vec3(0.0),\n         mask = vec3(1.),\n         sc = rotHue(vec3(0.4,0.7,1.0),T*0.05),\n         la = vec3(0.0),\n         lp = vec3(3.0,10.0,-7.0),\n         ro = vec3(0.0,sin(T*0.073+1.7)*4.0,-4.0),\n         wo = vec3(0.0,0.0,0.5),\n         wn = vec3(0.0,0.0,-1.0);\n    \n    ro.xz *= rot(T*-0.1);\n    vec3 rd = camera(U,ro,la,1.4);\n    float dof = 0.0;\n    \n    //rendering isn't correct but I kind of like it, sort of\n    for (int i=ZERO; i<BOUNCES; i++)\n    {\n        vec3 p = vec3(0.0),\n             n = vec3(0.0),\n             col = vec3(0.0),\n             sky = sc*clouds(rd);\n        float s = march(ro,rd),\n              wt = dot(wo - ro,wn)/dot(rd,wn),\n              nr = FAR;\n        if (s>0.0)\n        {\n            //geometry\n            float edge = 0.0;\n            nr = s;\n            p = ro + rd*s;\n            n = normal(p,rd,edge);\n            edge = 1.0 - smoothstep(0.9,1.0,edge);\n            vec3 ld = normalize(lp-p);\n            col = mask*(vec3(0.0,0.7,0.4)*0.01*max(0.0,-n.y)\n                + sc*pow(max(dot(reflect(-ld,n),-rd),0.0),16.0))*edge;\n            col *= exp(-0.1*nr);; \n        }\n        \n        if(wt>0.0&&wt<nr)\n        {\n            //wall thing\n            p = ro + rd*wt;\n            vec3 ld = normalize(lp-p);\n            vec2 ws = map(p,rd);\n            if (wall(p.xy,ws)>0.0)\n            {\n                nr = wt;\n                n = vec3(wn.xy,-sign(rd.z)); \n                col = mask*sc*pow(max(dot(reflect(-ld,n),-rd),0.0),16.0);\n                col = mix(sky,col,exp(-0.02*nr));      \n            }    \n            col += ws.y*smoothstep(0.5,0.1,length(fract(p.xy)-vec2(0.5)))*\n                   mix(vec3(1,0,0),vec3(1,1,0),n3D(p*8.0+T*2.7))\n                   /(1.0 + ws.x*ws.x*40.0);\n        }\n        \n        if (nr==FAR)\n        {\n            //missed\n            pc += mask*sky;\n            break;\n        } else {\n            if (i==0) dof = length(p-la)/80.;\n            pc += col;\n            mask *= sc*0.7;\n            ro = p + n*EPS;\n            rd = reflect(rd,n);\n        }\n    }\n    \n    pc = pow(pc,vec3(0.3545));\n    \n    C = vec4(pc,dof);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Created by SHAU - 2022\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n#define R iResolution.xy\n#define T iTime\n\n//Fabrice - compact rotation\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\n\n","name":"Common","description":"","type":"common"}]}