{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"XdfGR8","filepath":"/media/previz/buffer03.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"#define PARTICLE_BUFFER iChannel1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    uv /= 1.6;\n    uv += 0.5;\n    \n    if (any(lessThan(uv, vec2(0))) || any(greaterThan(uv, vec2(1)))) {\n        fragColor = vec4(0,0,0,1);\n        return;\n    }\n\n    ivec4 nearest = ivec4(texture(iChannel0, uv));\n    \n    vec4 nearestParticle = sampleParticle(PARTICLE_BUFFER, nearest[0]);\n    \n    fragColor = vec4(particleSdf(nearestParticle, uv)<0.0? unpackHDR10(nearestParticle.w) : vec3(0.0), 1.0);\n}","name":"Image","description":"","type":"image"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// particle info buffer\n// particle data layout:\n// XY: position\n// Z: rotation (radians)\n// W: color packed as RGB8, reinhard is applied before packing for psuedo-HDR\n\n#define PARTICLE_BUFFER iChannel0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 size = textureSize(iChannel0, 0).xy;\n    ivec2 ifragCoord = ivec2(floor(fragCoord));\n    \n    int particleIdx = ifragCoord.x + ifragCoord.y * size.x;\n    \n    if (particleIdx > N_PARTICLES) {\n        discard;\n    }\n    \n    vec2 position;\n    if (iFrame < 2) {\n        position = hash21(float(particleIdx));\n    } else {\n        position = texelFetch(iChannel0, ifragCoord, 0).xy;\n    }\n\n        // this is dependent on framerate which is easy to fix but it's consistent this way\n        // (since voronoi tracking is also dependent on framerate)\n    position += (1.0/60.0) * 0.01 * iMouse.x*(hash21(float(particleIdx-2))-0.5);\n    position = mod(position, vec2(1));\n    vec3 color = hash31(float(particleIdx+1));\n    float rotation = hash13(color) * 2.0 * PI + (2.0*hash11(float(particleIdx-1))-1.0)*iTime;\n    \n    fragColor.xy = position;\n    fragColor.z = rotation;\n    fragColor.w = packHDR10(color);\n}","name":"Buffer A","description":"","type":"buffer"},{"outputs":[{"channel":0,"id":"XsXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"XdfGR8","filepath":"/media/previz/buffer03.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// voronoi particle tracking\n\n#define PARTICLE_BUFFER iChannel1\n\nivec4 fetchParticleList(ivec2 c) {\n    return ivec4(texelFetch(iChannel0, ivec2(c), 0));\n}\n\nint rPartId(vec2 c) {\n    return int(float(N_PARTICLES) * hash12(c));\n}\nint rPartId(int c) {\n    return int(float(N_PARTICLES) * hash11(float(c)));\n}\n\nfloat particleScore(int particleId, vec2 uv) {\n    vec4 particle = sampleParticle(iChannel1, particleId);\n    \n    \n    return particleSdf(particle, uv);\n}\n\nvoid sort(inout ivec4 particleIds, vec2 uv) {\n    for (int i = 1; i < 4; ++i) {\n        int key = particleIds[i];\n        float keyScore = particleScore(key, uv);\n        int j = i - 1;\n        while (j >= 0 && particleScore(particleIds[j], uv) < keyScore) {\n            particleIds[j + 1] = particleIds[j];\n            j--;\n        }\n        particleIds[j + 1] = key;\n    }\n}\n\nvoid mergeArrays(\n    out ivec4 result,          // Output sorted array\n    ivec4 a,                   // Input array 1 (sorted)\n    ivec4 b,                   // Input array 2 (sorted)\n    vec2 uv                    // Additional parameter for particleScore\n) {\n    int i = 0, j = 0, k = 0;\n\n    while (k < 4) {\n        // Get the score for particles in both arrays\n        float scoreA = (i < 4)? particleScore(a[i], uv) : 1e30;\n        float scoreB = (j < 4)? particleScore(b[j], uv) : 1e30;\n\n        // Compare and merge particles, skipping duplicates\n        if (scoreA < scoreB) {\n            if (a[i] != result[k-1]) {  // Check for duplicates\n                result[k++] = a[i];\n            }\n            i++;\n        } else {\n            if (b[j] != result[k-1]) {  // Check for duplicates\n                result[k++] = b[j];\n            }\n            j++;\n        }\n\n        // Stop merging when the result array is filled\n        if (i >= 4 || j >= 4) break;\n    }\n}\n\n\nivec4 mergeArrays(ivec4 a, ivec4 b, vec2 uv) {\n    ivec4 res;\n    mergeArrays(res, a, b, uv);\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    ivec2 ifragCoord = ivec2(fragCoord);\n\n    ivec4 old = fetchParticleList(ifragCoord + ivec2( 0,  0));\n    \n    ivec4 new;\n    if (iFrame < 2) {\n        new.x = rPartId(fragCoord);\n        new.y = rPartId(new.x);\n        new.z = rPartId(new.y);\n        new.w = rPartId(new.z);\n        \n        sort(new, uv);\n    } else {\n        ivec4 north = fetchParticleList(ifragCoord + ivec2( 0,  1));\n        ivec4 south = fetchParticleList(ifragCoord + ivec2( 0, -1));\n        ivec4 east  = fetchParticleList(ifragCoord + ivec2( 1,  0));\n        ivec4 west  = fetchParticleList(ifragCoord + ivec2(-1,  0));\n        \n        ivec4 rand = ivec4(float(N_PARTICLES) * hash43(vec3(fragCoord, iFrame)));\n        \n        new = old;\n        new = mergeArrays(new, north, uv);\n        new = mergeArrays(new, south, uv);\n        new = mergeArrays(new, east , uv);\n        new = mergeArrays(new, west , uv);\n        new = mergeArrays(new, rand , uv);\n    }\n    \n    fragColor = vec4(new);\n}","name":"Buffer B","description":"","type":"buffer"},{"outputs":[],"inputs":[],"code":"#define PI 3.14159265\n\n#define PARTICLE_BUFFER_SIZE (textureSize(PARTICLE_BUFFER, 0).xy)\n#define N_PARTICLES 1000\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdStar5(in vec2 p, in float r, in float rf)\n{\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0*max(dot(k1,p),0.0)*k1;\n    p -= 2.0*max(dot(k2,p),0.0)*k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n    float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n    return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n\nvec2 rotatePoint(vec2 point, float angle) {\n    return mat2(\n        cos(angle), -sin(angle),\n        sin(angle),  cos(angle)\n    ) * point;\n}\n\n\nfloat particleSdf(vec4 particle, vec2 position) {\n    position -= particle.xy;\n    position = rotatePoint(position, particle.z);\n    \n    return sdStar5(position, 1.0/60.0, .58);\n    \n}\n\nfloat packHDR10(vec3 rgb) {\n    vec3 tonemapped = clamp(rgb / (rgb + 1.0), 0.0, 1.0);\n    \n    uvec3 integer = uvec3(tonemapped * 1023.0);\n    uint packed = integer.x | integer.y << 10u | integer.z << 20u;\n    \n    return uintBitsToFloat(packed);\n}\n\nvec3 unpackHDR10(float packedFloat) {\n    uint packed = floatBitsToUint(packedFloat);\n    \n    uint r = packed & 0x3FFu;\n    uint g = (packed >> 10u) & 0x3FFu;\n    uint b = (packed >> 20u) & 0x3FFu;\n    \n    vec3 rgb = vec3(r, g, b) / 1023.0;\n\n    rgb = rgb / (1.0 - rgb);\n    \n    return rgb;\n}\n\nvec4 sampleParticle(sampler2D tex, int id) {\n    int w = textureSize(tex, 0).x;\n    \n    int x = id % w;\n    int y = id / w;\n    \n    return texelFetch(tex, ivec2(x, y), 0);\n}\n\n\n\n// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n//----------------------------------------------------------------------------------------\n// 1 out 4 in...\nfloat hash14(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.x + p4.y) * (p4.z + p4.w));\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}","name":"Common","description":"","type":"common"},{"outputs":[{"channel":0,"id":"4sXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// voronoi particle tracking\n\n#define PARTICLE_BUFFER iChannel1\n\nivec4 fetchParticleList(ivec2 c) {\n    return ivec4(texelFetch(iChannel0, ivec2(c), 0));\n}\n\nint rPartId(vec2 c) {\n    return int(float(N_PARTICLES) * hash12(c));\n}\nint rPartId(int c) {\n    return int(float(N_PARTICLES) * hash11(float(c)));\n}\n\nfloat particleScore(int particleId, vec2 uv) {\n    vec4 particle = sampleParticle(iChannel1, particleId);\n    \n    \n    return particleSdf(particle, uv);\n}\n\nvoid sort(inout ivec4 particleIds, vec2 uv) {\n    for (int i = 1; i < 4; ++i) {\n        int key = particleIds[i];\n        float keyScore = particleScore(key, uv);\n        int j = i - 1;\n        while (j >= 0 && particleScore(particleIds[j], uv) < keyScore) {\n            particleIds[j + 1] = particleIds[j];\n            j--;\n        }\n        particleIds[j + 1] = key;\n    }\n}\n\nvoid mergeArrays(\n    out ivec4 result,          // Output sorted array\n    ivec4 a,                   // Input array 1 (sorted)\n    ivec4 b,                   // Input array 2 (sorted)\n    vec2 uv                    // Additional parameter for particleScore\n) {\n    int i = 0, j = 0, k = 0;\n\n    while (k < 4) {\n        // Get the score for particles in both arrays\n        float scoreA = (i < 4)? particleScore(a[i], uv) : 1e30;\n        float scoreB = (j < 4)? particleScore(b[j], uv) : 1e30;\n\n        // Compare and merge particles, skipping duplicates\n        if (scoreA < scoreB) {\n            if (a[i] != result[k-1]) {  // Check for duplicates\n                result[k++] = a[i];\n            }\n            i++;\n        } else {\n            if (b[j] != result[k-1]) {  // Check for duplicates\n                result[k++] = b[j];\n            }\n            j++;\n        }\n\n        // Stop merging when the result array is filled\n        if (i >= 4 || j >= 4) break;\n    }\n}\n\n\nivec4 mergeArrays(ivec4 a, ivec4 b, vec2 uv) {\n    ivec4 res;\n    mergeArrays(res, a, b, uv);\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    ivec2 ifragCoord = ivec2(fragCoord);\n\n    ivec4 old = fetchParticleList(ifragCoord + ivec2( 0,  0));\n    \n    ivec4 new;\n    if (iFrame < 2) {\n        new.x = rPartId(fragCoord);\n        new.y = rPartId(new.x);\n        new.z = rPartId(new.y);\n        new.w = rPartId(new.z);\n        \n        sort(new, uv);\n    } else {\n        ivec4 north = fetchParticleList(ifragCoord + ivec2( 0,  1));\n        ivec4 south = fetchParticleList(ifragCoord + ivec2( 0, -1));\n        ivec4 east  = fetchParticleList(ifragCoord + ivec2( 1,  0));\n        ivec4 west  = fetchParticleList(ifragCoord + ivec2(-1,  0));\n        \n        ivec4 rand = ivec4(float(N_PARTICLES) * hash43(vec3(fragCoord, iFrame)));\n        \n        new = old;\n        new = mergeArrays(new, north, uv);\n        new = mergeArrays(new, south, uv);\n        new = mergeArrays(new, east , uv);\n        new = mergeArrays(new, west , uv);\n        new = mergeArrays(new, rand , uv);\n    }\n    \n    fragColor = vec4(new);\n}","name":"Buffer C","description":"","type":"buffer"},{"outputs":[{"channel":0,"id":"XdfGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4sXGR8","filepath":"/media/previz/buffer02.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// voronoi particle tracking\n\n#define PARTICLE_BUFFER iChannel1\n\nivec4 fetchParticleList(ivec2 c) {\n    return ivec4(texelFetch(iChannel0, ivec2(c), 0));\n}\n\nint rPartId(vec2 c) {\n    return int(float(N_PARTICLES) * hash12(c));\n}\nint rPartId(int c) {\n    return int(float(N_PARTICLES) * hash11(float(c)));\n}\n\nfloat particleScore(int particleId, vec2 uv) {\n    vec4 particle = sampleParticle(iChannel1, particleId);\n    \n    \n    return particleSdf(particle, uv);\n}\n\nvoid sort(inout ivec4 particleIds, vec2 uv) {\n    for (int i = 1; i < 4; ++i) {\n        int key = particleIds[i];\n        float keyScore = particleScore(key, uv);\n        int j = i - 1;\n        while (j >= 0 && particleScore(particleIds[j], uv) < keyScore) {\n            particleIds[j + 1] = particleIds[j];\n            j--;\n        }\n        particleIds[j + 1] = key;\n    }\n}\n\nvoid mergeArrays(\n    out ivec4 result,          // Output sorted array\n    ivec4 a,                   // Input array 1 (sorted)\n    ivec4 b,                   // Input array 2 (sorted)\n    vec2 uv                    // Additional parameter for particleScore\n) {\n    int i = 0, j = 0, k = 0;\n\n    while (k < 4) {\n        // Get the score for particles in both arrays\n        float scoreA = (i < 4)? particleScore(a[i], uv) : 1e30;\n        float scoreB = (j < 4)? particleScore(b[j], uv) : 1e30;\n\n        // Compare and merge particles, skipping duplicates\n        if (scoreA < scoreB) {\n            if (a[i] != result[k-1]) {  // Check for duplicates\n                result[k++] = a[i];\n            }\n            i++;\n        } else {\n            if (b[j] != result[k-1]) {  // Check for duplicates\n                result[k++] = b[j];\n            }\n            j++;\n        }\n\n        // Stop merging when the result array is filled\n        if (i >= 4 || j >= 4) break;\n    }\n}\n\n\nivec4 mergeArrays(ivec4 a, ivec4 b, vec2 uv) {\n    ivec4 res;\n    mergeArrays(res, a, b, uv);\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    ivec2 ifragCoord = ivec2(fragCoord);\n\n    ivec4 old = fetchParticleList(ifragCoord + ivec2( 0,  0));\n    \n    ivec4 new;\n    if (iFrame < 2) {\n        new.x = rPartId(fragCoord);\n        new.y = rPartId(new.x);\n        new.z = rPartId(new.y);\n        new.w = rPartId(new.z);\n        \n        sort(new, uv);\n    } else {\n        ivec4 north = fetchParticleList(ifragCoord + ivec2( 0,  1));\n        ivec4 south = fetchParticleList(ifragCoord + ivec2( 0, -1));\n        ivec4 east  = fetchParticleList(ifragCoord + ivec2( 1,  0));\n        ivec4 west  = fetchParticleList(ifragCoord + ivec2(-1,  0));\n        \n        ivec4 rand = ivec4(float(N_PARTICLES) * hash43(vec3(fragCoord, iFrame)));\n        \n        new = old;\n        new = mergeArrays(new, north, uv);\n        new = mergeArrays(new, south, uv);\n        new = mergeArrays(new, east , uv);\n        new = mergeArrays(new, west , uv);\n        new = mergeArrays(new, rand , uv);\n    }\n    \n    fragColor = vec4(new);\n}","name":"Buffer D","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"MfKBRR","date":"1733716745","viewed":125,"name":"Shaped Voronoi Tracking","username":"FrederickAmpsUp","description":"Experimenting with using voronoi tracking to render many SDFs.\nUsing 3 voronoi buffers as multiple passes to hopefully improve accuracy.\nMouse X controls move speed. Voronoi tracking breaks after a certain point, but gaussian sampling can improve this.","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["voronoi","sdf","particle"],"hasliked":0,"parentid":"","parentname":""}}