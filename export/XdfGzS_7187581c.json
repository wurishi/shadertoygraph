{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"/*by mu6k, Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n Long time no shadertoy :D . . . \n Well chrome had this huge rendering bug where it didn't render any webpage at all\n so I downloaded a different version of chrome. Whatever, I've been busy with life . . .\n\n So a few words about this before I leave:\n \n I wanted to make a better occlusion function than the one I've been using before.\n The new one I wrote has 3 parameters, position, light position and light size. It \n magically returns how much of the lightsource is visible from a given position.\n\n The occlusion is done by finding the minimum distance to geometry from a given\n line. The implementation is a two pass algorithm. First I try to find the minimum\n by taking fixed steps. I sample n points from the line to find the minimum. Secondly\n I try to find a better position by trying nearby positions on the line. It works well.\n\n Currenly there are 2 lightsource and for each lightsource the occlusion is run twice.\n One from the camera to determine how much the lightsource is visible and one from the\n shading function to determine how much the surface is shadowed.\n\n The geometry is generated using 4 boxes. They use domain repetition and are reflected\n vertically to give the impression that there is a lot more going on.\n\n There is also a floor and a ceiling.\n\n Lighting is your standard ambient + diffuse + specular. I scale down the diffuse and \n specular components depending on how much the lightsource is visible from the surface.\n\n Currently this barely compiles here. You can easily tweak framerate and quality below.\n I managed to compile it with 3 lightsources. If you remove flare occlusion you can get a \n decent framerate boost.\n\n One day I'll make this run faster, clean up the code and add comments. \n Suggestions are welcome :D\n\n 23/07/2013:\n - published\n\n 28/07/2013:\n - cleaned up the code a bit\n\n 05/09/2013:\n - fixed a bug in the specular component\n\n muuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuusk!*/\n\n#define occlusion_enabled\n#define occlusion_pass1_quality 15\n#define occlusion_pass2_quality 6\n\n#define noise_use_smoothstep\n\n#define background_color_0 vec3(.2,.4,.6)\n#define background_color_1 vec3(.32,.2,.1)*4.0\n\n#define object_color vec3(0.5,0.5,0.5)\n#define object_count 3\n#define object_speed_modifier 1.0\n\n#define light_count_ 2 \n#define light_speed_modifier 2.0\n#define flare_occlusion\n\n#define render_steps 30\n\nconst int light_count = light_count_;\nvec3 light_pos[light_count];\nvec3 light_color[light_count];\n\nfloat hash(float x)\n{\n\treturn fract(sin(x*.0127863)*17143.321); //decent hash for noise generation\n}\n\nfloat hash(vec2 x)\n{\n\treturn fract(cos(dot(x.xy,vec2(2.31,53.21))*124.123)*412.0); \n}\n\nfloat hashmix(float x0, float x1, float interp)\n{\n\tx0 = hash(x0);\n\tx1 = hash(x1);\n\t#ifdef noise_use_smoothstep\n\tinterp = smoothstep(0.0,1.0,interp);\n\t#endif\n\treturn mix(x0,x1,interp);\n}\n\nfloat hashmix(vec2 p0, vec2 p1, vec2 interp)\n{\n\tfloat v0 = hashmix(p0[0]+p0[1]*128.0,p1[0]+p0[1]*128.0,interp[0]);\n\tfloat v1 = hashmix(p0[0]+p1[1]*128.0,p1[0]+p1[1]*128.0,interp[0]);\n\t#ifdef noise_use_smoothstep\n\tinterp = smoothstep(vec2(0.0),vec2(1.0),interp);\n\t#endif\n\treturn mix(v0,v1,interp[1]);\n}\n\nfloat hashmix(vec3 p0, vec3 p1, vec3 interp)\n{\n\tfloat v0 = hashmix(p0.xy+vec2(p0.z*143.0,0.0),p1.xy+vec2(p0.z*143.0,0.0),interp.xy);\n\tfloat v1 = hashmix(p0.xy+vec2(p1.z*143.0,0.0),p1.xy+vec2(p1.z*143.0,0.0),interp.xy);\n\t#ifdef noise_use_smoothstep\n\tinterp = smoothstep(vec3(0.0),vec3(1.0),interp);\n\t#endif\n\treturn mix(v0,v1,interp[2]);\n}\n\nfloat noise(vec3 p) // 3D noise\n{\n\tvec3 pm = mod(p,1.0);\n\tvec3 pd = p-pm;\n\treturn hashmix(pd,(pd+vec3(1.0,1.0,1.0)), pm);\n}\n\nvec3 cc(vec3 color, float factor,float factor2) // color modifier\n{\n\tfloat w = color.x+color.y+color.z;\n\treturn mix(color,vec3(w)*factor,w*factor2);\n}\n\n\nvec3 rotate_z(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, -sa, +.0,\n\t\t+sa, +ca, +.0,\n\t\t+.0, +.0,+1.0);\n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\nfloat dist(vec3 p)//distance function\n{\n\t//float d=1.0-abs(p.y);\n\t\n\tfloat t = iTime*object_speed_modifier+5.0;\n\tp.x+=t;\t\n\tp.z+=t*.4;\n\n\t\tfloat s = length(p);\n\n\tp.y=abs(p.y);\n\t\n\tp.y-=5.0;\n\t\n\tfloat d = 0.5-p.y;\n\t\n\tfor (int i=0; i<10; i++)\n\t{\n\t\tfloat fi = float(i);\n\t\t\n\t\tp+=vec3(1.25-fi,0.0,1.75+fi);\n\t\tvec3 pm;\n\t\t\n\t\tfloat rep = 10.0+sin(fi*2.0+1.0)*4.0;\n\t\t\n\t\tpm.xz = mod(p.xz+vec2(rep*.5),vec2(rep))-vec2(rep*.5);\n\t\t\n\t\n\t\t\n\t\tfloat width = 1.0+sin(fi)*.8;\n\t\tfloat height = 2.0+cos(fi)*1.1;\n\t\tfloat offset = -0.5+cos(fi)*1.8;\n\n\t\tvec3 df = abs(vec3(pm.x,p.y+1.0/width,pm.z))-vec3(width,height,width);\n\t\tfloat box = max(max(df.x,df.y),df.z);\n\t\t//float box=length(vec3(pm.x,p.y,pm.z))-1.0;\n\t\n\t\td = min(d,box);\n\t}\n\n\treturn d;\n}\n\nfloat amb_occ(vec3 p)\n{\n\tfloat acc=0.0;\n\n\tacc+=dist(p+vec3(-0.5,-0.5,-0.5));\n\tacc+=dist(p+vec3(-0.5,-0.5,+0.5));\n\tacc+=dist(p+vec3(-0.5,+0.5,-0.5));\n\tacc+=dist(p+vec3(-0.5,+0.5,+0.5));\n\tacc+=dist(p+vec3(+0.5,-0.5,-0.5));\n\tacc+=dist(p+vec3(+0.5,-0.5,+0.5));\n\tacc+=dist(p+vec3(+0.5,+0.5,-0.5));\n\tacc+=dist(p+vec3(+0.5,+0.5,+0.5));\n\treturn acc*.05+.5;\n}\n\nfloat occ(vec3 start, vec3 dest, float size)\n{\n\tvec3 dir = dest-start;\n\tfloat total_dist = length(dir);\n\tdir = dir/total_dist;\n\t\n\tfloat travel = .1;\n\tfloat o = 1.0;\n\tvec3 p=start;\n\t\n\tfloat search_travel=.0;\n\tfloat search_o=1.0;\n\t\n\tfloat e = .5*total_dist/float(occlusion_pass1_quality);\n\t\n\t//pass 1 fixed step search\n\t\n\tfor (int i=0; i<occlusion_pass1_quality;i++)\n\t{\n\t\ttravel = (float(i)+0.5)*total_dist/float(occlusion_pass1_quality);\n\t\tfloat cd = dist(start+travel*dir);\n\t\tfloat co = cd/travel*total_dist*size;\n\t\tif (co<search_o)\n\t\t{\n\t\t\tsearch_o=co;\n\t\t\tsearch_travel=travel;\n\t\t\tif (co<.0)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\t//pass 2 tries to find a better match in close proximity to the result from the \n\t//previous pass\n\t\t\n\tfor (int i=0; i<occlusion_pass2_quality;i++)\n\t{\n\t\tfloat tr = search_travel+e;\n\t\tfloat oc = dist(start+tr*dir)/tr*total_dist*size;\n\t\tif (tr<.0||tr>total_dist)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tif (oc<search_o)\n\t\t{\n\t\t\tsearch_o = oc;\n\t\t\tsearch_travel = tr;\n\t\t}\n\t\te=e*-.75;\n\t}\n\t\n\to=max(search_o,.0);\n\n\treturn o;\n}\n\nvec3 normal(vec3 p,float e) //returns the normal, uses the distance function\n{\n\tfloat d=dist(p);\n\treturn normalize(vec3(dist(p+vec3(e,0,0))-d,dist(p+vec3(0,e,0))-d,dist(p+vec3(0,0,e))-d));\n}\n\nvec3 light; //global variable that holds light direction\n\nvec3 background(vec3 p,vec3 d)//render background\n{\n\treturn vec3(0.0);\n}\n\nvec3 object_material(vec3 p, vec3 d) //computes the material for the object\n{\n\tvec3 n = normal(p,.01); //normal vector\n\tvec3 r = reflect(d,n); //reflect vector\n\tfloat ao = amb_occ(p); //fake ambient occlusion\n\tvec3 color = vec3(.0,.0,.0); //variable to hold the color\n\t\n\tfor(int i=0;i<light_count; i++) //for each light source\n\t{\n\t\tvec3 light_dir = light_pos[i]-p; //light direction vector\n\n\t\tfloat d = dot(n,light_dir); //standard diffuse shading\n\t\tfloat o = .0;\n\t\tfloat s = .0;\n\t\tfloat ldist = length(light_dir);\n\t\t\n\t\tif (d<.0)\n\t\t{\n\t\t\td = .0; //backface, always 100% occluded\n\t\t}\n\t\telse\n\t\t{\n\t\t\to = occ(p,light_pos[i],1.0); //call the occlusion function\n\t\t\tfloat temp = 1.0/ldist;\n\t\t\td = d*temp*o; //proper diffuse with occlusion\n\t\t\ts = pow(dot(r,light_dir*temp)*.5+.5,20.0)*o; //specular with occlusion\n\t\t}\n\t\tfloat attenuation = 1.0/pow(ldist*.1+1.0,2.0);\n\t\t\n\t\tcolor +=  \n\t\t\t(.7*ao + //ambient\n\t\t\td + //diffuse\n\t\t\t.4*s) * //specular\n\t\t\tlight_color[i] * attenuation;//color\n\t\t\t\n\t}\n\t\n\treturn color;\n\t\n}\n\n#define offset1 4.5\n#define offset2 1.8\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - 0.5;\n\tuv.x *= iResolution.x/iResolution.y; //fix aspect ratio\n\tvec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\n\t\n\tfloat t = iTime*.5*object_speed_modifier + 10.0;\n\t\n\t//setup the camera\n\tvec3 p = vec3(.0,0.0,-4.0);\n\tp = rotate_x(p,mouse.y*9.0+offset1);\n\tp = rotate_y(p,mouse.x*9.0+offset2);\n\tp.y*.2;\n\tvec3 d = vec3(uv,1.0);\n\td.z -= length(d)*.7; //lens distort\n\td = normalize(d);\n\td = rotate_x(d,mouse.y*9.0+offset1);\n\td = rotate_y(d,mouse.x*9.0+offset2);\n\t\n\tvec3 sp = p;\n\tvec3 color;\n\tfloat dd;\n\t\n\t//raymarcing \n\tfor (int i=0; i<render_steps; i++)\n\t{\n\t\tdd = dist(p);\n\t\tp+=d*dd;\n\t\tif (dd<.001) break;\n\t}\n\t\n\tt*=light_speed_modifier;\n\t\n\t\n\t//setup light position and color\n\tfor(int i=0; i<light_count; i++)\n\t{\n\t\tfloat offs = float(i)*(3.14159*1.5/float(light_count));\n\t\tlight_pos[i] = 2.0*vec3(\n\t\t\tsin(t*.7+offs)*2.0,\n\t\t\tsin(t*.5+offs)*.3,\n\t\t\tsin(t*.3+offs)*2.0);\n\t\tlight_color[i] = .5 + .5*vec3(\n\t\t\tcos(t*.5+offs),\n\t\t\tsin(t*.3+offs),\n\t\t\tsin(t*.7+offs));\n\t\tlight_color[i] = normalize(light_color[i]);\n\t}\n\n\t//of ray is close enough to geometry, call the surface shading function\n\tif (dd<0.1) //close enough\n\t\tcolor = object_material(p,d);\n\telse\n\t\tcolor = background(sp,d);\n\t\n\t//render the flares\n\tfor(int i=0; i<light_count; i++)\n\t{\n\t\tfloat q = dot(d,normalize(light_pos[i]-sp))*.5+.5;\n\t\tfloat o = occ(sp,light_pos[i],1.0);\n\t\tcolor+=pow(q,500.0/o)*light_color[i]*3.0;\n\t}\n\t\n\t//post procesing\n\tcolor *=.85;\n\tcolor = mix(color,color*color,0.3);\n\tcolor -= hash(color.xy+uv.xy)*.015;\n\tcolor -= length(uv)*.06;\n\tcolor =cc(color,.7,.7);\n\tfragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XdfGzS","date":"1374577351","viewed":2024,"name":"Structure","username":"mu6k","description":"I wanted to make a better occlusion function than the one I've been using before. It has 3 parameters and magically returns how much of the light source is visible from a given position. Use mouse to look around.","likes":51,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","lens","shadows","flare","penumbra"],"hasliked":0,"parentid":"","parentname":""}}