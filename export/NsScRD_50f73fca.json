{"ver":"0.1","info":{"id":"NsScRD","date":"1643145162","viewed":249,"name":"Phase Differential Swipes","username":"GraphXDoses","description":"Simple atan rotation concept, with phase differentiation.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["rotation2d","arctan"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n    Updated version with the following features:\n        -> Anti-Alised circles\n        -> Gamma corrected colors\n        -> Working layout spacing\n        -> Easier to modify, motion behaviour via animation curve\n\n    I would like to thank Shane, as his rework paradigm gave me a lot of insight.\n\n*/\n\nconst float PI          = 3.14159265359;\n\n//////////////////// CONTROLS PANEL /////////////////////\n\n// PALETTE\nconst vec3  BG_COLOR    = vec3(0.1760, 0.0148, 0.1630);\nconst vec3  LIGHT_COLOR = vec3(0.8100, 0.8100, 0.0000);\nconst vec3  DARK_COLOR  = vec3(1.0000, 0.0059, 0.0480);\n\n// LAYOUT\nconst float SPACING     = 0.06; // Gap between each texel.\nconst float USE_RADIALS = 1.0;  // Switches the shape of texels between square and circle.\n\n// ANIMATION\n\n// Uncomment the following macro if you want a linear animation with respect to time.\n//#define CLOCKWORK_ANIMATION \n\n#ifdef CLOCKWORK_ANIMATION\n#define ANIM_CURVE(t) t\n#else\n#define ANIM_CURVE(t) \\\n( PI * sin( ( t - ( 3./4. * 2. * PI ) ) / PI ) + PI ) - t\n#endif\n\n/////////////////////////////////////////////////////////\n\n\n/////////////////////// FUNCTIONS ///////////////////////\n\nmat2 rotationMatrix(float angle) {\n\tfloat c = cos(angle), s = sin(angle);\n    return mat2(\n        c, -s,\n        s,  c\n    );\n}\n\nfloat Bitmap(in vec2 uv )\n{\n    vec2 map = vec2(3.);\n\n\t// Subtract from local UV position, to ensure results lay inside the bounding box.\n    uv -= 1./(map.x * 2.);\n\n    // Multiply the UV by the bitmap size so work can be done in\n    // bitmap space coordinates.\n    uv *= vec2(map);\n\n    // Compute bitmap texel coordinates.\n    vec2 muv = vec2(round(uv));\n\n\t// Bounding box check. With branches, so we avoid the maths and lookups .\n    if( muv.x<0. || muv.x>map.x-1. ||\n        muv.y<0. || muv.y>map.y-1. ) return 0.;\n\n    // Compute bit index.\n    float index = map.x*muv.y + muv.x;\n\n    // Get the appropriate bit and return it.\n    return index;\n\n}\n\nvec2 QuadBox(in vec2 target, in vec2 cs ) {\n    cs *= rotationMatrix(-(2.*PI)*(target.y/4.)) * target.x;\n\n    /////////////////// 3 x 3 TEXEL GRID ////////////////////\n\t// By further dividing the quadrant, we can focus on each\n\t// individual texel's orientation and appearence.\n\n    float mask = target.x - max(floor(cs).x, floor(cs).y); // Masking the space of the quadrant widget.\n\n    float index = Bitmap(cs); // Getting the index of each texel (bottom-right to top-left) from 0 to 8.\n\n    cs = fract(cs*vec2(3.));  // Division\n\n    float texel_mask = step(SPACING/2.,min(cs.x,cs.y)) - step(1.0-SPACING/2.,max(cs.x,cs.y));\n\n\t// Centering the UV of the texel, keeping it normalized.\n    cs -= 0.5;\n    cs *= 2.;\n\n    texel_mask = mix(\n        texel_mask,\n        ( 1. - smoothstep( 0.95, 1., length(cs) + SPACING ) ),\n        step(1., USE_RADIALS)\n    );\n\n    mask *= texel_mask;\n\n    /////////////////////// ANIMATION ///////////////////////\n\t// Were the effect takes place.\n\n    float start      = -PI / 2.;\n    float phase_diff =  PI / 10.;\n\n    cs *= rotationMatrix((phase_diff * mod(index, 3.)) - (start + phase_diff * floor(index/3.)) - ANIM_CURVE(iTime));\n\n\t//////////////////// ARCTAN POINTER /////////////////////\n\n    float atan_pointer = fract( atan(cs.x, cs.y)/(2.*PI)+0.5 );\n\n    // Smooth fractal wrap.\n    atan_pointer = min(atan_pointer, (1. - atan_pointer)/0.006 * length(cs));\n    \n    atan_pointer = (1. - atan_pointer) * mask;\n\n\n    return vec2(atan_pointer, mask);\n\n}\n\n/////////////////////////////////////////////////////////\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//////////// COORDINATE SPACE MODIFICATION ////////////\n\t// The idea is to create a square UV plane,\n    // despite the rectangular form of the screen and place it\n    // at the center.\n\n    vec2  uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    /*float ar = iResolution.y / iResolution.x;\n    uv      -= 0.5;\n    uv      *= vec2(PI, 1./ar); */\n\n    uv *= vec2(2.15);     // Size adjustment to create a gap between the following widget and top/bottom edges.\n\n    uv *= vec2(1., -1.); // Y flip. This step is mandatory.\n\n    ////////////////// QUADRANT WIDGETS /////////////////\n\t// By dividing the above UV plane into four equal squares,\n\t// we can isolate the individual spaces and easily achieve migration\n\t// of changes to the neighbouring squares via duplication/rotation.\n\n    vec2 quadrants = step(vec2(0.0), uv);\n\n\t// 2D Vector with:\n\t// X: Quadrant Space\n\t// Y: Index of Rotation\n    vec2 down_right = vec2(  step(1., quadrants.x) * step(1., quadrants.y),   4.);\n    vec2 down_left  = vec2( (step(1., quadrants.y) - down_right.x),           1.);\n    vec2 up_right   = vec2( (step(1., quadrants.x) - down_right.x),           3.);\n    vec2 up_left    = vec2( (1. - (down_right.x + down_left.x + up_right.x)), 2.);\n\n\t// 2D Vector with:\n\t// X: Arctan Pointer\n\t// Y: Texel Mask\n    vec2 BOX_ONE    = QuadBox(up_left,    uv);\n    vec2 BOX_TWO    = QuadBox(up_right,   uv);\n    vec2 BOX_THREE  = QuadBox(down_right, uv);\n    vec2 BOX_FOUR   = QuadBox(down_left,  uv);\n\n\t//////////////////// ASSEMBLY AREA ///////////////////\n\t// Putting everyting together.\n\n    float CENTER_BOX = max(max(max(BOX_ONE.x, BOX_TWO.x), BOX_THREE.x), BOX_FOUR.x);\n    float CENTER_BOX_TEXEL_MASK = max(max(max(BOX_ONE.y, BOX_TWO.y), BOX_THREE.y), BOX_FOUR.y);\n\n\t// Applying Colors..\n    vec3 col = mix(LIGHT_COLOR, DARK_COLOR, pow((1. - CENTER_BOX), 0.7));\n    col      = mix(col, BG_COLOR, 1. - CENTER_BOX_TEXEL_MASK);\n\n    //////////////// FINAL COLOR OUTPUT /////////////////\n    fragColor = vec4(sqrt(max(col, 0.)),1.0);\n}\n","name":"Image","description":"","type":"image"}]}