{"ver":"0.1","info":{"id":"XsKcDG","date":"1523176255","viewed":235,"name":"Try not to hit the walls","username":"hisojarvi","description":"A texture-mapped curving tunnel \nMy first Shadertoy effect.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","tunnel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float PI = 3.14159;\n\n// Defines how the tunnel curves\nvec2 tubeCenterOffset(float t)\n{\n\tfloat offx = 1.0*sin(t/3.0) + 2.0*cos(3.0/3.0*t) + 2.0*cos(t/17.0);\n    float offy = 2.0*sin(7.0/27.0*t)*sin(7.0/27.0*t) + 1.6 * cos(3.0/17.0*t) + 1.0*sin(t/1.07);\n    return 0.1 * vec2(offx, offy);\n}\n\nvec4 texMap(float angle, float depth)\n{\n\treturn texture(iChannel0, vec2(angle/(2.0*3.14159), depth));\n}\n\nvec4 getTexture(float angle, float depth) \n{\n\t//return stripe(angle, depth);\n    return texMap(angle, depth);\n}\n\nvec4 raymarch( vec2 uv, vec2 uvMax )\n{    \n    float speed = 2.0;\n    float currentDepth = iTime * speed;\n    \n    vec2 screenCenter = uvMax/2.0;\n\n    float tubeRadius = 0.3;    \n    vec2 cameraxy = tubeCenterOffset(currentDepth);\n\tvec2 rayDirection = uv-screenCenter-cameraxy;\n    \n    float step = 0.001; \n    float minDepth = 0.1;\n    float maxDepth = 4.0;            \n    float depth = minDepth;\n    while(depth <= maxDepth)    \n    {   \n        float rayDepth = currentDepth + depth;\n        vec2 tubeCenterInDepth = tubeCenterOffset(rayDepth);\n        vec2 xy = cameraxy + rayDirection*depth;        \n        if(distance(xy, tubeCenterInDepth) > tubeRadius)\n        {                        \n        \tif(depth == minDepth)\n            {                \n          \t\treturn vec4(0.02, 0.0, 0.1, 1.0);    \n            }\n            else {\n                vec2 directionInDepth = xy-tubeCenterInDepth;\n                float angle = 2.0*(PI/2.0 + atan(directionInDepth.y/directionInDepth.x));\n                float relativeDepth = depth/maxDepth;\n                float brightness = 1.0-relativeDepth;\n                brightness = pow(brightness, 1.6); // Make brightness decay faster\n                vec4 tex = getTexture(angle, rayDepth);\n                return tex * brightness;\n            }\n        }\n        depth += step;\n    }    \n    return vec4(0.0, 0.0, 0.0, 1.0);        \n}    \n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale = min(iResolution.x, iResolution.y);    \n    vec2 uv = fragCoord/scale;\n    vec2 uvMax = iResolution.xy/scale;\n\t    \n    fragColor = raymarch(uv, uvMax);\n}\n","name":"Image","description":"","type":"image"}]}