{"ver":"0.1","info":{"id":"fsVcWc","date":"1655737988","viewed":84,"name":"Newton z^6-1","username":"notfancy","description":"For Pride Month 2022, a sixth root of unity version of cppio's https://www.shadertoy.com/view/3lSXz1","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","fractal","newton","smooth","pride"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * Based on \"Smooth Newton Fractal\"\n * By cppio\n * https://www.shadertoy.com/view/3lSXz1\n */\n#define THRESHOLD 1e-5\n#define MAX_ITERATIONS 100\n#define ANTI_ALIASING 2\n#define N 6\n\n/* The colors of the Pride Rainbow */\nconst vec3 PALETTE[] = vec3[](\n    vec3(1.0, 0.0, 0.0),\n    vec3(1.0, 0.5, 0.0),\n    vec3(1.0, 1.0, 0.0),\n    vec3(0.0, 1.0, 0.0),\n    vec3(0.0, 0.0, 1.0),\n    vec3(0.7, 0.0, 0.7)\n);\n\n/*\n * Rotation angle\n */\nvec2 rot(float q) {\n    return vec2(cos(q), sin(q));\n}\n\n/*\n * K-th power w^k of the n-th root of unity w\n */\n#define TWOPI 6.28318530718\nvec2 nthRoot(int k, int n) {\n    return rot(TWOPI * float(k) / float(n));\n}\n\n/*\n * Complex exponentiation using De Moivre's Formula\n */\nvec2 cpow(vec2 z, float n) {\n    return pow(length(z), n) * rot(n * atan(z.y, z.x));\n}\n\n/*\n * Complex conjugate\n */\nvec2 ccnj(vec2 z) {\n    return vec2(z.x, -z.y);\n}\n\n/*\n * Square Euclidean norm\n */\nfloat nrm2(vec2 z) {\n    return dot(z, z);\n}\n\n/*\n * N-R step for z^N == 1\n *\n * In general, the N-R step for z^N - 1 == 0 is\n *\n * z := z - (z^N - 1)/(N*z^(N-1))\n *\n * Put under a common denominator and multiply and divide\n * by the conjugate power in the denominator to get:\n *\n * z := ((N-1)*z + (z* / |z|^2)^(N-1)) / N\n */\nvec2 newtonStep(vec2 z) {\n    vec2 w = cpow(ccnj(z) / nrm2(z), float(N-1)); // z* / |z|^2\n    return (1.0 / float(N)) * (float(N-1) * z + w);\n}\n\nvec3 drawFractal(vec2 z) {\n    for (int iter = 0; iter < MAX_ITERATIONS; ++iter) {\n        z = newtonStep(z);\n        // Find if converged to some root\n        for (int k = 0; k < N; ++k) {\n            vec2 root = nthRoot(k, N);\n            float d2 = nrm2(root - z);\n            if (d2 < THRESHOLD) {\n                // Fractional iteration\n                float e = float(iter) - log2(log(d2) / log(THRESHOLD));\n                return PALETTE[k] * (0.75 + 0.25 * cos(0.25 * e));\n            }\n        }\n    }\n}\n\nconst vec2 CENTER = 0.77*vec2(0.809017, 0.587785);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float zoom = exp(-3.0 * (0.9 - cos(iTime / 5.0)));\n    float scale = 2.0 / (float(ANTI_ALIASING) * iResolution.y);\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 color = vec3(0);\n    for (int x = 0; x < ANTI_ALIASING; ++x) {\n        for (int y = 0; y < ANTI_ALIASING; ++y) {\n            vec2 dv = scale * vec2(x, y);\n            color += drawFractal(mix(CENTER, uv + dv, zoom));\n        }\n    }\n    fragColor = vec4(color / float(ANTI_ALIASING * ANTI_ALIASING), 1.0);\n}","name":"Image","description":"","type":"image"}]}