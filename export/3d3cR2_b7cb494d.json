{"ver":"0.1","info":{"id":"3d3cR2","date":"1601243769","viewed":1821,"name":"Fantasy World Map","username":"mhnewman","description":"Let's go exploring!","likes":56,"published":1,"flags":0,"usePreview":1,"tags":["procedural","2d","map","mountains","paper","town","world","fantasy","forrest","worldbuilding"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define DRAW_TOWNS\n//#define GO_CRAZY\n\nconst float lineWidth = 0.5;\n\nconst float terrainScale = 80.0;\nconst vec3 landColor = vec3(0.9, 0.8, 0.7);\nconst vec3 shoreLineColor = vec3(0.0);\n\nconst float waterThreshold = -0.04;\nconst vec3 waterDeepColor = vec3(0.7, 0.8, 0.9);\nconst vec3 waterShallowColor = vec3(0.5, 0.6, 0.9);\nconst vec3 waterLineColor = vec3(0.0, 0.1, 0.3);\n\nconst float mountainWidth = 20.0;\nconst float mountainHeight = 16.0;\nconst float mountainThreshold = 0.23;\nconst vec3 mountainColor = vec3(0.5, 0.3, 0.1);\nconst vec3 mountainShadowColor = vec3(0.3, 0.2, 0.0);\nconst vec3 mountainLineColor = vec3(0.3, 0.1, 0.0);\n\nconst float treeScale = 3.5;\nconst float treeGrow = 1.5;\nconst float treeGrowthScale = 100.0;\nconst float treeGrowthThreshold = 0.08;\nconst float treeTerrainThresholdLow = 0.02;\nconst float treeTerrainThresholdHigh = 0.12;\nconst vec3 treeColor = vec3(0.3, 0.8, 0.4);\nconst vec3 treeShadowColor = vec3(0.0, 0.4, 0.2);\nconst vec3 treeLineColor = vec3(0.0, 0.3, 0.1);\n\nconst float townSpacing = 80.0;\nconst float buildingLineWidth = 0.3;\nconst float buildingSize = 5.0;\nconst float roofSize = 0.3;\nconst float urbanSprawl = 8.0;\nconst float townTerrainThresholdLow = 0.0;\nconst float townTerrainThresholdHigh = 0.18;\nconst float townTreeThreshold = 0.04;\n\nconst float paperTexture = 3.0;\nconst float dirt = 0.5;\nconst vec3 dirtColor = vec3(0.6, 0.3, 0.1);\n\nconst float vignetting = 0.4;\nconst vec3 vignettingColor = vec3(0.3, 0.2, 0.0);\n\n\nconst float pi = 3.14159265;\n\nconst float terrainScaleInv = 1.0 / terrainScale;\nconst float mountainWidthInv = 1.0 / mountainWidth;\nconst float mountainHeightInv = 1.0 / mountainHeight;\nconst float treeScaleInv = 1.0 / treeScale;\nconst float treeGrowthScaleInv = 1.0 / treeGrowthScale;\nconst float townSpacingInv = 1.0 / townSpacing;\nconst float buildingSizeInv = 1.0 / buildingSize;\n\nfloat aa;\nfloat lw;\nfloat blw;\nfloat bsdf;\n\n\nfloat hash1(vec2 p) {\n    vec3 p3  = fract(vec3(p.xyx) * 0.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash2(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * vec3(0.1031, 0.1030, 0.0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec3 hash3(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * vec3(0.1031, 0.1030, 0.0973));\n    p3 += dot(p3, p3.yxz + 33.33);\n    return fract((p3.xxy + p3.yzz) * p3.zyx);\n}\n\nfloat noise1(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(hash1(i + vec2(0.0, 0.0)), \n                   hash1(i + vec2(1.0, 0.0)), u.x),\n               mix(hash1(i + vec2(0.0, 1.0)), \n                   hash1(i + vec2(1.0, 1.0)), u.x), u.y);\n}\n\nconst mat2 m = mat2(1.616, 1.212, -1.212, 1.616);\n\nfloat fbm1(vec2 p) {\n    float f = noise1(p) - 0.5; p = m * p;\n    f += 0.5 * (noise1(p) - 0.5); p = m * p;\n    f += 0.25 * (noise1(p) - 0.5);\n    return f / 1.75;\n}\n\nfloat fbm1high(vec2 p) {\n    float f = noise1(p) - 0.5; p = m * p;\n    f += 0.5 * (noise1(p) - 0.5); p = m * p;\n    f += 0.25 * (noise1(p) - 0.5); p = m * p;\n    f += 0.125 * (noise1(p) - 0.5); p = m * p;\n    f += 0.0625 * (noise1(p) - 0.5);\n    return f / 1.9375;\n}\n\nfloat sdBox(vec2 p, vec2 b) {\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nfloat sdTriangleIsosceles(vec2 p, vec2 q) {\n    p.x = abs(p.x);\n    vec2 a = p - q * clamp(dot(p, q) / dot(q, q), 0.0, 1.0);\n    vec2 b = p - q * vec2(clamp(p.x / q.x, 0.0, 1.0 ), 1.0);\n    float s = -sign(q.y);\n    vec2 d = min(vec2(dot(a, a), s * (p.x * q.y - p.y * q.x)), vec2(dot(b, b), s * (p.y - q.y)));\n    return -sqrt(d.x) * sign(d.y);\n}\n\nvec3 water(vec3 color, vec2 pos) {\n    float terrain = fbm1high(terrainScaleInv * pos) - waterThreshold;\n\n    vec3 waterColor = mix(waterDeepColor, waterShallowColor, exp(20.0 * terrain));\n    color = mix(color, waterColor, step(terrain, 0.0));\n\n    float offset = waterThreshold + terrain;\n    float dx = fbm1high(terrainScaleInv * (pos + vec2(0.01, 0.0))) - offset;\n    float dy = fbm1high(terrainScaleInv * (pos + vec2(0.0, 0.01))) - offset;\n    float grad = 0.01 / length(vec2(dx, dy));\n    float t0 = terrain * grad;\n    float t1 = (terrain + 0.02) * grad;\n    float t2 = (terrain + 0.04) * grad;\n    float t3 = (terrain + 0.06) * grad;\n    float t4 = (terrain + 0.08) * grad;\n    float t5 = (terrain + 0.1) * grad;\n\n    color = mix(color, waterLineColor, 0.5 * clamp((lw - abs(t1)) * aa, 0.0, 1.0));\n    color = mix(color, waterLineColor, 0.4 * clamp((lw - abs(t2)) * aa, 0.0, 1.0));\n    color = mix(color, waterLineColor, 0.3 * clamp((lw - abs(t3)) * aa, 0.0, 1.0));\n    color = mix(color, waterLineColor, 0.2 * clamp((lw - abs(t4)) * aa, 0.0, 1.0));\n    color = mix(color, waterLineColor, 0.1 * clamp((lw - abs(t5)) * aa, 0.0, 1.0));\n\n    return mix(color, shoreLineColor, clamp((lw - abs(t0)) * aa, 0.0, 1.0));\n}\n\nfloat mountainContour(vec2 p, float y, float squash, float offset) {\n    float contour = -0.2;\n    contour -= 0.4 * (1.0 - pow(abs(cos((mountainWidthInv * p.x + offset) * pi)), 1.2));\n    contour += 0.5 * fbm1(vec2(0.15 * p.x, y));\n    contour *= squash;\n    return p.y - y + mountainHeight * (contour + 0.4);\n}\n\nvec3 mountains(vec3 color, vec2 pos, float offset) {\n    float x = mountainWidthInv * pos.x + offset;\n    float range = fract(x);\n    float antiRange = 1.0 - range;\n    x = mountainWidth * ((floor(x) - offset) + 0.5);\n    \n    float y = mountainHeightInv * pos.y + offset;\n    float altitude = fract(y);\n    float antiAltitude = 1.0 - altitude;\n   \ty = mountainHeight * ((floor(y) - offset) + 0.5);\n    \n    float draw = step(mountainThreshold, fbm1(terrainScaleInv * vec2(x, y)));\n    float drawLeft = step(mountainThreshold, fbm1(terrainScaleInv * vec2(x - mountainWidth, y)));\n    float drawRight = step(mountainThreshold, fbm1(terrainScaleInv * vec2(x + mountainWidth, y)));\n    \n    float squash = clamp(4.0 * range * antiRange + drawLeft * step(range, 0.5) + drawRight * step(0.5, range), 0.0, 1.0);\n    squash *= squash;\n    draw *= clamp(mountainWidth * range * aa + drawLeft, 0.0, 1.0);\n    draw *= clamp(mountainWidth * antiRange * aa + drawRight, 0.0, 1.0);\n    \n   \tfloat ter = mountainContour(pos, y, squash, offset);\n    float tdx = mountainContour(pos + vec2(0.01, 0.0), y, squash, offset) - ter;\n    float tdy = mountainContour(pos + vec2(0.0, 0.01), y, squash, offset) - ter;\n    float tgrad = 0.01 / length(vec2(tdx, tdy));\n    float t0 = ter * tgrad;\n\n    vec3 fillColor = mix(landColor, mountainColor, altitude);\n    fillColor = mix(fillColor, mountainLineColor, clamp(8.0 * (0.1 - abs(fbm1(0.25 * pos))), 0.0, 1.0));\n    fillColor = mix(color, fillColor, smoothstep(0.0, 0.3, altitude)); \n    color = mix(color, fillColor, step(ter, 0.0) * draw);\n    \n    float shadow = step(0.0, t0) * antiAltitude * antiAltitude * draw * squash;\n    color = mix(color, mountainShadowColor, shadow);\n    return mix(color, mountainLineColor, clamp((lw - abs(t0)) * aa, 0.0, 1.0) * draw);\n}\n\nfloat treeSDF(vec2 pos, vec2 trunk) {\n    vec3 h = hash3(trunk);\n    float r = treeScale * (0.9 + 0.35 * h.z);\n    trunk += treeScale * 0.5 * (h.xy - 0.5);\n    float terrain = fbm1(terrainScaleInv * trunk);\n    float plant = step(treeTerrainThresholdLow, terrain) * step(terrain, treeTerrainThresholdHigh);\n    plant *= step(treeGrowthThreshold, fbm1(treeGrowthScaleInv * trunk + 100.0));\n    return r - distance(pos, trunk) - 100.0 * (1.0 - plant);\n}\n\nvec3 trees(vec3 color, vec2 pos) {\n    vec2 center = treeScale * (floor(treeScaleInv * pos) + 0.5);\n    float shadow = treeSDF(pos, center);\n    shadow = max(shadow, treeSDF(pos, center + vec2(treeScale, 0.0)));\n    shadow = max(shadow, treeSDF(pos, center + vec2(treeScale, treeScale)));\n    shadow = max(shadow, treeSDF(pos, center + vec2(0.0, treeScale)));\n    shadow = max(shadow, treeSDF(pos, center + vec2(-treeScale, treeScale)));\n    shadow = max(shadow, treeSDF(pos, center + vec2(-treeScale, 0.0)));\n    \n    color = mix(color, treeShadowColor, step(0.0, shadow));\n    color = mix(color, treeLineColor, clamp((lw - abs(shadow)) * aa, 0.0, 1.0));\n    \n    pos.y -= treeGrow;\n    vec2 trunk = treeScale * (floor(treeScaleInv * pos) + 0.5);\n    float forrest = treeSDF(pos, trunk);\n    forrest = max(forrest, treeSDF(pos, trunk + vec2(treeScale, 0.0)));\n    forrest = max(forrest, treeSDF(pos, trunk + vec2(treeScale, treeScale)));\n    forrest = max(forrest, treeSDF(pos, trunk + vec2(0.0, treeScale)));\n    forrest = max(forrest, treeSDF(pos, trunk + vec2(-treeScale, treeScale)));\n    forrest = max(forrest, treeSDF(pos, trunk + vec2(-treeScale, 0.0)));\n    forrest = max(forrest, treeSDF(pos, trunk + vec2(-treeScale, -treeScale)));\n    forrest = max(forrest, treeSDF(pos, trunk + vec2(0.0, -treeScale)));\n    forrest = max(forrest, treeSDF(pos, trunk + vec2(treeScale, -treeScale)));\n\n    color = mix(color, treeColor * (1.0 - exp(-0.5 - clamp(forrest, 0.0, 10.0))), step(0.0, forrest));\n    return mix(color, treeLineColor, clamp((lw - abs(forrest)) * aa, 0.0, 1.0));\n}\n\n#ifdef DRAW_TOWNS\nvec3 building(vec3 color, vec2 pos, vec2 county, float population, vec3 roofColor, vec2 block) {\n    vec2 b = buildingSize * block;\n    float terrain = fbm1(terrainScaleInv * b);\n    float free = step(townTerrainThresholdLow, terrain) * step(terrain, townTerrainThresholdHigh);\n    free *= step(fbm1(treeGrowthScaleInv * b + 100.0), townTreeThreshold);\n    free *= step(hash1(block), 1.2 - distance(b, county) / ((1.0 + population) * urbanSprawl));\n    \n    vec3 buildingHash = hash3(block);\n    vec2 size = vec2(0.3, 0.1) + vec2(0.25, 0.25) * buildingHash.xy;\n    vec2 center = vec2(1.2 * (buildingHash.z - 0.5), size.y - 0.6);\n    vec2 p = pos - block - center;\n    \n    vec2 roofHash = hash2(block);\n    float roofWidth = size.x * (0.4 + 0.6 * roofHash.x);\n    float roofside = 1.0 - 2.0 * step(roofHash.y, 0.5);\n    float triangle = sdTriangleIsosceles(p - vec2(roofside * (roofWidth - size.x), 0.4 + size.y), vec2(roofWidth, -0.4));\n    float sdf = sdBox(p, size);\n    sdf = min(sdf, triangle);\n    sdf -= bsdf;\n    \n    float roofSdf = min(triangle, sdTriangleIsosceles(p - vec2(roofside * (size.x - roofWidth), 0.4 + size.y), vec2(roofWidth, -0.4)));\n    roofSdf = min(roofSdf, sdBox(p - vec2(0.0, 0.2 + size.y), vec2(size.x - roofWidth, 0.2)));\n    roofSdf -= roofSize;\n    roofSdf = max(roofSdf, size.y - p.y + bsdf);\n    color = mix(color, roofColor, step(roofSdf, 0.0) * free);\n    color = mix(color, vec3(0.0), clamp((blw - abs(buildingSize * roofSdf)) * aa, 0.0, 1.0) * free);\n    \n    vec3 sidingHash = hash3(block + 0.1);\n    vec3 siding = vec3(0.2 + 0.3 * sidingHash.x + 0.5 * noise1(vec2(6.0, 10.0) * pos)) + sidingHash.y * vec3(0.2, 0.1 + 0.1 * sidingHash.z, 0.0);\n    color = mix(color, siding, step(sdf, 0.0) * free);\n    \n    vec3 windowHash = hash3(block + 0.2);\n    vec2 windowSize = vec2(0.2 + 0.1 * windowHash.x, 0.4 + 0.4 * step(windowHash.y, 0.5));\n    vec2 windowCenter = vec2(0.8 * (0.5 - windowHash.z), 0.4 - windowSize.y);\n    float windowSdf = sdBox(p - size * windowCenter, size * windowSize);\n    color = mix(color, 0.5 * roofColor, 0.3 * step(windowSdf, 0.0) * free);\n    color = mix(color, vec3(0.0), clamp((blw - abs(buildingSize * windowSdf)) * aa, 0.0, 1.0) * free);\n    \n    return mix(color, vec3(0.0), clamp((blw - abs(buildingSize * sdf)) * aa, 0.0, 1.0) * free);\n}\n\nvec3 town(vec3 color, vec2 pos) {\n    vec2 county = townSpacing * (floor(townSpacingInv * pos) + 0.5);\n    vec3 h = hash3(county);\n    vec3 roofColor = 0.5 + 0.2 * cos(6.2831853 * (vec3(0.0, 0.33, 0.67) + h.x));\n    county += townSpacing * 0.6 * (h.xy - 0.5);\n    \n    vec2 grid = buildingSizeInv * pos;\n    vec2 block = floor(grid) + 0.5;\n    float offset = mod(block.x, 2.0) - 0.5;\n    block.y += offset * (step(0.5, fract(grid.y)) - 0.5);\n    \n    vec2 p = buildingSizeInv * pos;\n    color = building(color, p, county, h.z, roofColor, block + vec2(0.0, 1.0));\n    color = building(color, p, county, h.z, roofColor, block + vec2(-1.0, 0.5));\n    color = building(color, p, county, h.z, roofColor, block + vec2(1.0, 0.5));\n    color = building(color, p, county, h.z, roofColor, block);\n    color = building(color, p, county, h.z, roofColor, block + vec2(-1.0, -0.5));\n    color = building(color, p, county, h.z, roofColor, block + vec2(1.0, -0.5));\n    color = building(color, p, county, h.z, roofColor, block + vec2(0.0, -1.0));\n    \n    return color;\n}\n#endif\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 center = vec3(40.0 * iTime, 0.0, 0.0);\n    vec3 eye = center + vec3(0.0, -40.0 + 30.0 * cos(0.15 * iTime), 120.0 - 50.0 * cos(0.15 * iTime));\n\n#ifdef GO_CRAZY\n    center = vec3(250.0 * iTime, 0.0, 0.0);\n    eye = center + vec3(70.0 * sin(iTime), 70.0 * cos(iTime), 150.0 + 100.0 * cos(1.4 * iTime));\n#endif\n\n    float zoom = 2.0;\n    \n    vec3 forward = normalize(center - eye);\n    vec3 right = normalize(cross(forward, vec3(0.0, 0.0, 1.0)));\n    vec3 up = cross(right, forward);\n    vec2 xy = 2.0 * fragCoord - iResolution.xy;\n    vec3 ray = normalize(xy.x * right + xy.y * up + zoom * forward * iResolution.y);\n    \n    float t = -eye.z / ray.z;\n    vec2 pos = eye.xy + t * ray.xy;\n    \n    aa = iResolution.y / t;\n    lw = lineWidth + 0.5 / aa;\n    blw = buildingLineWidth + 0.5 / aa;\n    bsdf = blw * buildingSizeInv;\n    \n    vec3 color = water(landColor, pos);\n\n    float mountainRange = 0.5 * step(fract(mountainHeightInv * pos.y), 0.5);\n    color = mountains(color, pos, 0.5 - mountainRange);\n    color = mountains(color, pos, mountainRange);\n    \n    color = trees(color, pos);\n    \n#ifdef DRAW_TOWNS\n    color = town(color, pos);\n#endif\n    \n    color = mix(color, dirtColor, dirt * pow(clamp(fbm1(vec2(0.01, 0.02) * pos), 0.0, 1.0), 1.5));\n    \n    color *= 1.0 + paperTexture * (fbm1high(vec2(0.05, 0.1) * pos) - fbm1high(vec2(0.05, 0.1) * (pos + vec2(0.1, 0.1))));\n\n    vec2 uv = 2.0 * fragCoord / iResolution.xy - 1.0;\n    color = mix(vignettingColor, color, vignetting * pow((1.0 - uv.x * uv.x) * (1.0 - uv.y * uv.y), 0.3) + 1.0 - vignetting);\n    \n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}