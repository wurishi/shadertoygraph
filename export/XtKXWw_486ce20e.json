{"ver":"0.1","info":{"id":"XtKXWw","date":"1484593280","viewed":227,"name":"PaintShop","username":"tudordot","description":"Raytracing study. This implementation is based on cabbibio tutorial:\nhttps://www.shadertoy.com/view/Xl2XWt\n\nI'm open to any suggestion, especially related to performance.","likes":8,"published":1,"flags":64,"usePreview":0,"tags":["raytracing","ray","sdf","paint"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"ldB3zc","filepath":"https://soundcloud.com/joeypecoraro/partly-sunny","previewfilepath":"https://soundcloud.com/joeypecoraro/partly-sunny","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float MAX_TRACE_DIST = 8.0;\nconst float INTERSECTION_PRECISION = 0.001;\nconst int NUM_OF_TRACE_STEPS = 40;\n\nconst vec3 lightPos = vec3(1., 4., 3.);\nconst vec3 ambient = vec3(0.35, .126, .16);\n\nconst vec3 color1 = vec3(0.73, 0.65, 0.12);\nconst vec3 color2 = vec3(0.77, 0.156, 0.23);\nconst vec3 bg = vec3(0.28, 0.11, 0.14);\n\n\n\n\nmat3 computeTransform(vec3 ro, vec3 ta, float roll)\n{\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(sin(roll), cos(roll), 0.0)));\n    vec3 vv = normalize(cross(uu, ww));\n    return mat3(uu, vv, ww);\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n\treturn length(p) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b)\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat smin( float d1, float d2)\n{\n    float k = 0.6521;\n    float h = clamp( 0.5+0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat opBlend( float d1, float d2)\n{    \n    return smin( d1, d2 );\n}\n\nvec2 opU(vec2 d1, vec2 d2)\n{\n    return d1.x <= d2.x ? d1 : d2;\n}\n\nvec2 map(vec3 rayPos)\n{\n    vec2 res;\n    vec2 sphere = vec2(sdSphere(rayPos - vec3(.3, .3, -0.4), 1.1), 1.);    \n    res = sphere;\n    for(float i = 0.; i < 4.; i++)\n    {\n        float xPos = -6. + mod(float(iFrame) + i * 55., 220.0) * 0.05;\n        vec3 torusPos = vec3(xPos, 0.25, -.5);\n        vec2 torus = vec2(sdTorus(rayPos - torusPos, vec2( .5, .1)), 2.);\n        float blend = opBlend(res.x, torus.x);\n        res = opU(res, torus);\n        res.x = blend;\n    }\n    return res;\n}\n\nvec2 checkRayHit(vec3 eyePos, vec3 rayDir)\n{\n    float dist = INTERSECTION_PRECISION * 2.0;\n    float totDist = 0.;\n    float resDist = -1.;\n    float id = -1.;\n    \n    for( int i = 0; i < NUM_OF_TRACE_STEPS; i++){\n        if(dist < INTERSECTION_PRECISION || totDist > MAX_TRACE_DIST) break;\n        \n        vec3 ray = eyePos + rayDir * totDist;\n        vec2 m = map(ray);\n        \n        dist = m.x;\n        totDist += m.x;\n        id = m.y;\n    }\n    \n    if(totDist < MAX_TRACE_DIST) resDist = totDist;    \n    if(totDist > MAX_TRACE_DIST) id = -1.0;\n    \n    return vec2(resDist, id);\n}\n\nvec3 calcNormal(vec3 pos){\n    \n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\nvec3 render(vec2 hit, vec3 eye, vec3 ray)\n{\n    vec3 color = vec3(0.);\n    \n    if(hit.y > -.5)\n    {\n        vec3 hitPos = eye + hit.x * ray;\n        vec3 norm = calcNormal(hitPos);\n        \n        vec3 lightDir = normalize(lightPos - hitPos);\n        float match = max(0., dot(lightDir, norm));\n        \n        //sphere\n        if(hit.y == 1.)\n        \tcolor = color2 * match + ambient;\n        //torus\n        else if (hit.y == 2.)\n        {\n            float mask = step(hitPos.x, 0.3);\n            vec3 c = color2 * (1.- mask) + color1 * mask;\n            color = c * match + ambient;\n        }\n        \n    }\n    else\n    {\n        color = bg;\n    }\n    \n    return color;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = (-iResolution.xy + 2.0 * fragCoord.xy) / iResolution.y;\n    \n    vec3 eyeP = vec3(0.5, 2., 3.);    \n    vec3 lookAt = vec3(0., 0.3, 0.);\n    \n    mat3 transform = computeTransform( eyeP, lookAt, 0.);\n    vec3 ray = normalize(transform * vec3(p.xy, 2.));\n    \n    vec2 hit = checkRayHit(eyeP, ray);\n    vec3 color = render(hit, eyeP, ray);\n    \n    color *= 1.1 - 0.5*length(fragCoord/iResolution.xy-0.5);    \n    fragColor = vec4(color, 1.0);\n    \n}","name":"Image","description":"","type":"image"}]}