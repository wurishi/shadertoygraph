{"ver":"0.1","info":{"id":"Nd2fDG","date":"1647607987","viewed":69,"name":"JustSomeRaytracer v1.1","username":"JustBoredYo","description":"Just some idiotic stuff done in School","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct tri\n{\n    vec3 p1, p2, p3;\n    vec4 intersectionPlane;\n};\n\nstruct mesh\n{\n    tri[2] tris;\n};\n\nstruct Ray\n{\n    vec3 position;\n    vec3 direction;\n};\n\n//Calculate the normal of the Triangle as well as the k value\nvec4 calculateIntersection(tri _tri)\n{\n    vec3 line1 = _tri.p2 - _tri.p1;\n    vec3 line2 = _tri.p3 - _tri.p1;\n    \n    vec3 result = cross(line1, line2);\n    \n    return vec4(result.x, result.y, result.z, dot(-result, _tri.p1));\n}\n\n//Rotate the Camera based on the Y value from theta\nvec3 rotateY(vec3 m, float theta)\n{\n    return vec3(dot(m.x , cos(theta)) + dot(m.z , sin(theta)), m.y, -dot(m.x, sin(theta)) + dot(m.z, cos(theta)));\n}\n\n//Rotate the Camera based on the X value from theta\nvec3 rotateX(vec3 m, float theta)\n{\n    return vec3(m.x, dot(m.y, cos(theta)) - dot(m.z, sin(theta)), dot(m.y, sin(theta)) - dot(m.z, cos(theta)));\n}\n\n//Rotate the Camera based on the X and Y theta variable\nvec3 rotateM(vec3 m, vec2 rot, vec2 res, vec2 pCoord)\n{\n    float x = (res.x/res.y-1.0) / res.y* (pCoord.x - floor(res.x/2.0));\n    float y = 1.0/res.y * (pCoord.y - floor(res.y/2.0));\n    \n    vec3 _v0 = vec3(x, y, 1.0);\n    vec3 _v2 = rotateX(rotateY(vec3(0.1* (pCoord.x - 2.0), 0.1* (pCoord.y - 2.0), 1.0), rot.y), rot.x);\n    \n    return _v0;\n}\n\n//Sanity check if the intersection point lays in the Triangle\nbool sanityCheck(tri _tri, vec3 i)\n{\n    vec3 l = _tri.p2 - _tri.p3;\n    vec3 a = cross(l, (i - _tri.p3));\n    vec3 b = cross(l, _tri.p1 - _tri.p3);\n    \n    if(dot(a, b) < 0.0)\n        return false;\n        \n    l = _tri.p1 - _tri.p3;\n    a = cross(l, i - _tri.p3);\n    b = cross(l, _tri.p2 - _tri.p3);\n    \n    if(dot(a, b) < 0.0)\n        return false;\n        \n    l = _tri.p1 - _tri.p2;\n    a = cross(l, i - _tri.p2);\n    b = cross(l, _tri.p3 - _tri.p2);\n    \n    \n    if(dot(a, b) < 0.0)\n        return false;\n    \n    return true;\n}\n\n//Cast the Ray that will color the Pixel\nvec3 castRay(Ray ray, tri _tri, vec2 pCoord)\n{\n    vec3 m = vec3(0 ,0, 1.0);\n    \n    m = rotateM(m, vec2(sin(iTime) * -180.0, 180), iResolution.xy, pCoord);\n    \n    vec3 abc = vec3(_tri.intersectionPlane.x, _tri.intersectionPlane.y, _tri.intersectionPlane.z);\n    float lamda = -((dot(abc, ray.position) + _tri.intersectionPlane.w)/dot(abc, m));\n    \n    if(lamda < 0.0)\n    {\n        return vec3(0, 0, 0);\n    }\n    \n    vec3 i = vec3(lamda * m.x + ray.position.x, lamda * m.y + ray.position.y, lamda * m.z + ray.position.z);\n    \n    \n    //Check if the point lays in the bounding box of the triangle\n    if(i.x > min(_tri.p1.x, min(_tri.p2.x, _tri.p3.x)) && i.x < max(_tri.p1.x, min(_tri.p2.x, _tri.p3.x)) && \n        i.y > min(_tri.p1.y, min(_tri.p2.y, _tri.p3.y)) && i.y < max(_tri.p1.y, min(_tri.p2.y, _tri.p3.y)) && \n        i.x > min(_tri.p1.z, min(_tri.p2.z, _tri.p3.z)) && i.x < max(_tri.p1.z, min(_tri.p2.z, _tri.p3.z)))\n    {\n        return vec3(0, 0, 0);\n    }\n    \n    if(!sanityCheck(_tri, i))\n        return vec3(0, 0, 0);\n    \n    float b = sqrt((i.x - ray.position.x) * (i.x - ray.position.x) + (i.y - ray.position.y) * (i.y - ray.position.y) + (i.z - ray.position.z) * (i.z - ray.position.z));\n    \n    return vec3(1, 0, 0) * (1.0/sqrt(b));\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    tri _tri = tri(vec3(-1.0, 0.0, 2.0), vec3(-1, 1.0, 3), vec3(1, 0.0, 2), vec4(0, 0, 0, 0));\n    _tri.intersectionPlane = calculateIntersection(_tri);\n    \n    tri _tri1 = tri(vec3(-1, 1, 3), vec3(1.0, 1, 3.0), vec3(1, 0, 2), vec4(0, 0, 0, 0));\n    _tri1.intersectionPlane = calculateIntersection(_tri1);\n    \n    mesh _mesh;\n    _mesh.tris[0] = _tri;\n    _mesh.tris[1] = _tri1;\n    \n    vec3 cam = vec3(0.0, 1, -1.0);\n    Ray ray = Ray(cam, vec3(0, 0, 1));\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float x = floor(iResolution.x / 288.0);\n    float y = floor(iResolution.y / 288.0);\n    \n    vec3 col = vec3(0, 0, 0);\n    \n    for(int i = 0; i < 2; i++)\n    {\n        if(col == vec3(0, 0, 0))\n            col = castRay(ray, _mesh.tris[i], vec2(fragCoord.x , fragCoord.y));\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}