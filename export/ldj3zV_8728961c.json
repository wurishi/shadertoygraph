{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"\tconst float maxDepth = 64.0;\n    const int maxIterations = 256;\n    const float epsilon = 0.0001;\n\n    float plane( vec3 p )\n    {\n        return p.y;\n    }\n\n    float sphere(vec3 p, float s)\n    {\n        return (length(p)-s);\n    }\n\n    float wigglesphere(vec3 p, float s)\n    {\n        return 0.02*sin(35.0*p.y + 8.*iTime) + 0.1*cos(5.*p.z + 3.*iTime) + sphere(p, s);\n    }\n    \n    float wigglesphere1(vec3 p, float s)\n    {\n        return 0.1*cos(5.*p.z + 3.*iTime) + sphere(p, s);\n    }\n\n    vec2 opU(vec2 d1, vec2 d2)\n    {\n        return (d1.x < d2.x) ? d1 : d2;\n    }\n    \n    vec2 map(in vec3 p) \n    {\n        vec2 res = opU( vec2(plane(vec3(p.x, p.y + 0.6, p.z)), 1.0), \n                    vec2(max(wigglesphere(p, 0.55), - sphere(vec3(p.x + 0.2, p.y + 0.2*sin(iTime)-0.15, p.z+0.1*cos(2.*iTime)), 0.4)), 2.0)\n                   );\n        //res = opU(res, vec2(wigglesphere1(p, 0.55), 1.0)); // for debugging\n       return res;\n    }\n\n    vec2 castRay( in vec3 ro, in vec3 rd, in float maxd )\n    {\n        float h=epsilon*2.0; // step size\n        vec2 result;    // result of distance check\n        float t = 0.0;\t// distance travelled\n        float m = -1.0; // material\n        for( int i=0; i<maxIterations; i++ )\n        {\n            if( abs(h)<epsilon||t>maxd ) continue;//break;\n            t += h;\n            result = map(ro+rd*t);\n            h = result.x;\n            m = result.y;\n        }\n\n        return vec2(t,m);\n    }\n\n    vec3 calcNormal( in vec3 pos )\n    {\n        vec3 eps = vec3( 0.001, 0.0, 0.0 );\n        vec3 nor = vec3(\n            map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n            map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n            map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n        return normalize(nor);\n    }\n\n    float softshadow( in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k )\n    {\n        float res = 1.0;\n        float t = mint;\n        for( int i=0; i<30; i++ )\n        {\n            if( t<maxt )\n            {\n            float h = map( ro + rd*t ).x;\n            res = min( res, k*h/t );\n            t += 0.02;\n            }\n        }\n        return clamp( res, 0.0, 1.0 );\n\n    }\n\n    float calcAO( in vec3 pos, in vec3 nor )\n    {\n        float totao = 0.0;\n        float sca = 1.0;\n        for( int aoi=0; aoi<5; aoi++ )\n        {\n            float hr = 0.01 + 0.05*float(aoi);\n            vec3 aopos =  nor * hr + pos;\n            float dd = map( aopos ).x;\n            totao += -(dd-hr)*sca;\n            sca *= 0.75;\n        }\n        return clamp( 1.0 - 4.0*totao, 0.0, 1.0 );\n    }\n\n    vec3 render( in vec3 ro, in vec3 rd )\n    { \n        vec3 col = vec3(0.0);\n        vec2 result = castRay(ro,rd,maxDepth);\n        float t = result.x;\n        float m = result.y;\n        \n        if( t < maxDepth ) // raymarch converged after t steps\n        {\n            vec3 pos = ro + t*rd; // end position = ray origin + distance traveled in ray direction\n            vec3 normal = calcNormal( pos );\n            vec3 light = normalize( vec3(0.5, 2.2, 1.1) );\n            float ao = calcAO(pos, normal);\n            \n            if (m > 1.0)\n            {\n                float dif = sqrt(wigglesphere1(pos, 0.528) - wigglesphere(pos, 0.55));\n                float diffuse = (10.0*sin(2.*iTime)+20.0)*clamp(dot(normal, light), 0.0, 1.0);\n                //col = vec3(dif, dif, dif);\n                col = vec3(0.8*diffuse * dif, 0.4*dif*diffuse, 2.5*dif);\n            }\n            else\n            {\n                float amb = clamp( 0.5+0.5*normal.y, 0.0, 1.0 );\n                float diffuse = clamp(dot(normal, light) - (t / maxDepth), 0.0, 1.0);\n                float bac = clamp( dot( normal, normalize(vec3(-light.x,0.0,-light.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n                vec3 brdf = vec3(0.0);\n                float sh = softshadow( pos, light, 0.02, 10.0, 7.0 );\n                float pp = clamp( dot( reflect(rd,normal), light ), 0.0, 1.0 );\n                float spe = sh*pow(pp,16.0);\n\t\t\t\tvec3 tex = texture(iChannel0, vec2(pos.x, pos.z + iTime - max(0.0, 0.3*sin(3.*iTime + 3.)))).rgb;\n                diffuse *= sh;\n                brdf += amb*vec3(0.1, 0.11, 0.13) * ao;\n                brdf += 0.2*bac*vec3(0.15, 0.15, 0.15) * ao;\n                brdf += 1.2*diffuse*vec3(1.0, 0.9, 0.7);\n                col = vec3(diffuse) * brdf * tex + vec3(1.0)*col*spe;\n\n            }\n        }\n\n        return vec3( clamp(col,0.0,1.0) );\n    }\n\n    void mainImage( out vec4 fragColor, in vec2 fragCoord )\n    {\n        vec2 q = fragCoord.xy/iResolution.xy;\n        vec2 p = -1.0+2.0*q;\n        p.x *= iResolution.x/iResolution.y;\n        vec2 mo = iMouse.xy/iResolution.xy;\n             \n        // camera\t\n        vec3 rorigin = vec3(3.2*cos(6.0*mo.x), 2.0*mo.y, 3.2*sin(6.0*mo.x) );\n        vec3 ta = vec3( -0.5, -0.4, 0.5 );\n        // camera tx\n        vec3 cw = normalize( ta-rorigin );\n        vec3 cp = vec3( 0.0, 1.0, 0.0 );\n        vec3 cu = normalize( cross(cw,cp) );\n        vec3 cv = normalize( cross(cu,cw) );\n        vec3 rdir = normalize( p.x*cu + p.y*cv + 2.5*cw );\n\n        \n        vec3 color = render( rorigin, rdir );\n\n        fragColor=vec4( color, 1.0 );\n    }","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldj3zV","date":"1391306307","viewed":505,"name":"Inchworm","username":"bear","description":"Trying to get the hang of raymarching. HUGE thanks to iq for the helpful examples and articles (https://www.shadertoy.com/view/Xds3zN)!","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","distancefields"],"hasliked":0,"parentid":"","parentname":""}}