{"ver":"0.1","info":{"id":"XXlyR8","date":"1725829122","viewed":16,"name":"2D Line Vs Triangle Intersection","username":"Nimajamin","description":"Test Env for looking at basic operations.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d","test"],"hasliked":0,"parentid":"4cVGDm","parentname":"2D Test Scenarios"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI            (3.141592653589793)\n#define TAU           (2.0*PI)\n#define OO_SIXTEEN    (0.0625)\n#define GOLDENRATIO   (1.618033988749895)       // 1.0 + sqrt(5.0) / 2.0\n\nfloat saturate( in float n )\n{\n    return clamp( n, 0.0, 1.0 );\n}\n\nvec2 saturate( in vec2 n )\n{\n    return clamp( n, 0.0, 1.0 );\n}\n\nvec3 saturate( in vec3 n )\n{\n    return clamp( n, 0.0, 1.0 );\n}\n\nvec4 saturate( in vec4 n )\n{\n    return clamp( n, 0.0, 1.0 );\n}\n\nmat2 rot(in float a) \n{\t\n\treturn mat2( cos(a), -sin(a),\n                 sin(a),  cos(a) );\n}\n\nvec3 hue2rgb(in float hue) \n{\n    vec3 spectrum = clamp( abs( mod( (hue) * 6.0 + vec3( 0.0, 4.0, 2.0 ), 6.0 ) - 3.0 ) - 1.0, 0.0, 1.0 );\n    return saturate( mix( vec3(0.), spectrum, fract(1.0-clamp(hue,0.0,1.1)) ) );\n}\n\nstruct Line\n{\n    vec2 a;\n    vec2 b;\n};\n\nstruct Tri\n{\n    vec2 a;\n    vec2 b;\n    vec2 c;\n};\n\n#define NUM_LINES    (4)\nconst Line lines[ NUM_LINES ] = Line[]\n(\n    Line( vec2(0.883517146110535, 0.302430242300034), vec2(0.861210942268372, 0.285105794668198) ),\n    Line( vec2(0.857191383838654, 0.155643656849861), vec2(0.628011763095856, 0.952978432178497) ),\n    Line( vec2(0.790988683700562, 0.795943975448608), vec2(0.854366242885592, 0.832816898822784) ),\n    Line( vec2(0.457106143236167, 0.007989492267379), vec2(0.992491722106934, 0.190591320395479) )\n);\n\n#define NUM_TRIS    2//(4)\nTri tris[ NUM_TRIS ] = Tri[]\n(\n    Tri( vec2(0.642420589923859, 0.662252247333527), vec2(0.469089895486832, 0.377173054218292), vec2(0.333427011966705, 0.791534936428072) ),\n//    Tri( vec2(0.207281813025475, 0.848214209079742), vec2(0.378544777631761, 0.895550847053528), vec2(0.535539090633392, 0.840338528156281) ),\n    Tri( vec2(0.709322333335877, 0.691747829318047), vec2(0.663407504558563, 0.392839479446411), vec2(0.494178086519241, 0.224618446826935) )//,\n//    Tri( vec2(0.877945303916931, 0.351369470357895), vec2(0.680262088775635, 0.105957007408142), vec2(0.304347932338715, 0.071250772476196) )\n);\n\nfloat dLineSegment( in vec2 p, in vec2 a, in vec2 b, in float th )\n{\n    vec2 ba = b - a;\n    vec2 pa = p - a;\n    float h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n    return length( pa - h * ba ) - th;\n}\n\nfloat dPlane( in vec3 p, vec4 plane ) \n{\n    return dot( p, plane.xyz ) + plane.w;\n}\n\nfloat dTri( in vec2 p, in Tri t ) \n{\n    vec2 ab = t.b - t.a;\n    vec2 ac = t.c - t.a;\n    return ( dot( p, ab ) < 0.0 ? 1.0 : 0.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord / iResolution.xy) * vec2( iResolution.z, 1.0 );    \n    \n    // Zoom out a little..\n//  uv -= 0.5;\n//  uv *= 1.5;\n//  uv += 0.5;\n    \n    vec3 col = vec3(0.0);\n     \n    // ----- ---- --- -- -\n    // Test line..\n    // ----- ---- --- -- -\n    \n    const float tScale = 0.1331;\n    \n    Line testLine = Line( vec2( 0.5, 0.5 ), iMouse.xy / iResolution.xy );\n    testLine.a = vec2( sin( tScale * iTime * 3.2f ) * 0.485 + 0.5, cos( tScale * iTime * 7.123f ) * 0.485 + 0.5 );\n\n    float phase = tScale * iTime * 7.0 * 0.33334;\n    \n    // ----- ---- --- -- -\n    // Line Vs Triangle Testing..\n    // ----- ---- --- -- -\n    \n    vec3 intersectScale = vec3( 1.0, 1.0, 1.0 );\n    vec3 circleShade = vec3( 0.3334, 0.3334, 0.3334 );\n        \n    vec2 la = testLine.a;\n    vec2 lb = testLine.b;\n\n    for ( int tt = 0; tt < NUM_TRIS; tt++ )\n    {\n        tris[tt].a = vec2( 0.5, 0.5 ) + ( rot( phase ) * ( tris[tt].a - vec2( 0.5, 0.5 ) ) );\n        tris[tt].b = vec2( 0.5, 0.5 ) + ( rot( phase ) * ( tris[tt].b - vec2( 0.5, 0.5 ) ) );\n        tris[tt].c = vec2( 0.5, 0.5 ) + ( rot( phase ) * ( tris[tt].c - vec2( 0.5, 0.5 ) ) );\n        vec2 ta = tris[ tt ].a;\n        vec2 tb = tris[ tt ].b;\n        vec2 tc = tris[ tt ].c;\n        const float I3 = 1.0 / 3.0;\n        vec2 barry = ( ta + tb + tc ) * I3;\n        float br = max( max( length(ta-barry), length(tb-barry) ), length(tc-barry) ) + 0.0015;        \n        \n        vec2 ab = tb - ta;\n        vec2 bc = tc - tb;\n        vec2 ca = ta - tc;\n        vec2 at = ( uv - ta );\n        vec2 bt = ( uv - tb );\n        vec2 ct = ( uv - tc );\n        const float fNumTris = float( NUM_TRIS );\n        const float maxPlaneBrightness = 0.25 / fNumTris;\n        \n        float dat = dot( (ab.yx*vec2(1.,-1.)), at );        \n        circleShade.x += clamp( -sign(dat), 0.0, maxPlaneBrightness );\n        float dbt = dot( (bc.yx*vec2(1.,-1.)), bt );        \n        circleShade.y += clamp( -sign(dbt), 0.0, maxPlaneBrightness );\n        float dct = dot( (ca.yx*vec2(1.,-1.)), ct );        \n        circleShade.z += clamp( -sign(dct), 0.0, maxPlaneBrightness );\n        \n        float lineLen = length(la-lb);\n        \n        float intensity = 2.8 * (1.0 - saturate(lineLen));\n        const float th = 0.0005;\n        const float maxProjBrightness = 0.1 / fNumTris;\n        \n        float dmat = dot( ((la-ta).yx*vec2(1.,-1.)), at );   \n        vec3 bow0 = 0.0 + hue2rgb((exp(-length(uv-ta)*10.0))) + 1.5-saturate(exp(-length(uv-ta)*0.1));\n        circleShade.x += bow0.x * ((length(dmat*250.0) < 1.0) ? clamp( -sign(dmat), 0.0, maxProjBrightness ) * intensity + (exp(-length(uv-ta)*40.0)) : 0.0 );\n        circleShade.y += bow0.y * ((length(dmat*250.0) < 1.0) ? clamp( -sign(dmat), 0.0, maxProjBrightness ) * intensity + (exp(-length(uv-ta)*80.0)) : 0.0 );\n        circleShade.z += bow0.z * ((length(dmat*250.0) < 1.0) ? clamp( -sign(dmat), 0.0, maxProjBrightness ) * intensity + (exp(-length(uv-ta)*120.0)) : 0.0 );\n        \n        float dmbt = dot( ((la-tb).yx*vec2(1.,-1.)), bt );        \n        vec3 bow1 = 0.0 + hue2rgb((exp(-length(uv-tb)*10.0))) + 1.5-saturate(exp(-length(uv-tb)*0.1));\n        circleShade.x += bow1.x * ((length(dmbt*250.0) < 1.0) ? clamp( -sign(dmbt), 0.0, maxProjBrightness ) * intensity + (exp(-length(uv-tb)*120.0)) : 0.0 );\n        circleShade.y += bow1.y * ((length(dmbt*250.0) < 1.0) ? clamp( -sign(dmbt), 0.0, maxProjBrightness ) * intensity + (exp(-length(uv-tb)*40.0)) : 0.0 );\n        circleShade.z += bow1.z * ((length(dmbt*250.0) < 1.0) ? clamp( -sign(dmbt), 0.0, maxProjBrightness ) * intensity + (exp(-length(uv-tb)*80.0)) : 0.0 );\n        \n        float dmct = dot( ((la-tc).yx*vec2(1.,-1.)), ct );        \n        vec3 bow2 = 0.0 + hue2rgb((exp(-length(uv-tc)*10.0))) + 1.5-saturate(exp(-length(uv-tc)*0.1));\n        circleShade.x += bow2.x * ((length(dmct*250.0) < 1.0) ? clamp( -sign(dmct), 0.0, maxProjBrightness ) * intensity + (exp(-length(uv-tc)*120.0)) : 0.0 );\n        circleShade.y += bow2.y * ((length(dmct*250.0) < 1.0) ? clamp( -sign(dmct), 0.0, maxProjBrightness ) * intensity + (exp(-length(uv-tc)*80.0)) : 0.0 );\n        circleShade.z += bow2.z * ((length(dmct*250.0) < 1.0) ? clamp( -sign(dmct), 0.0, maxProjBrightness ) * intensity + (exp(-length(uv-tc)*40.0)) : 0.0 );\n        \n        float dmat2 = dot( ((lb-ta).yx*vec2(1.,-1.)), at );        \n        vec3 bow3 = 0.0 + hue2rgb((exp(-length(uv-ta)*10.0))) + 1.5-saturate(exp(-length(uv-ta)*0.1));\n        circleShade.x += bow3.x * ((length(dmat2*250.0) < 1.0) ? clamp( -sign(dmat2), 0.0, maxProjBrightness ) * intensity + (exp(-length(uv-ta)*40.0)) : 0.0 );\n        circleShade.y += bow3.y * ((length(dmat2*250.0) < 1.0) ? clamp( -sign(dmat2), 0.0, maxProjBrightness ) * intensity + (exp(-length(uv-ta)*80.0)) : 0.0 );\n        circleShade.z += bow3.z * ((length(dmat2*250.0) < 1.0) ? clamp( -sign(dmat2), 0.0, maxProjBrightness ) * intensity + (exp(-length(uv-ta)*120.0)) : 0.0 );\n        \n        float dmbt2 = dot( ((lb-tb).yx*vec2(1.,-1.)), bt );        \n        vec3 bow4 = 0.0 + hue2rgb((exp(-length(uv-tb)*10.0))) + 1.5-saturate(exp(-length(uv-tb)*0.1));\n        circleShade.x += bow4.x * ((length(dmbt2*250.0) < 1.0) ? clamp( -sign(dmbt2), 0.0, maxProjBrightness ) * intensity + (exp(-length(uv-tb)*120.0)) : 0.0 );\n        circleShade.y += bow4.y * ((length(dmbt2*250.0) < 1.0) ? clamp( -sign(dmbt2), 0.0, maxProjBrightness ) * intensity + (exp(-length(uv-tb)*40.0)) : 0.0 );\n        circleShade.z += bow4.z * ((length(dmbt2*250.0) < 1.0) ? clamp( -sign(dmbt2), 0.0, maxProjBrightness ) * intensity + (exp(-length(uv-tb)*80.0)) : 0.0 );\n        \n        float dmct2 = dot( ((lb-tc).yx*vec2(1.,-1.)), ct );        \n        vec3 bow5 = 0.0 + hue2rgb((exp(-length(uv-tc)*10.0))) + 1.5-saturate(exp(-length(uv-tc)*0.1));\n        circleShade.x += bow5.x * ((length(dmct2*250.0) < 1.0) ? clamp( -sign(dmct2), 0.0, maxProjBrightness ) * intensity + (exp(-length(uv-tc)*120.0)) : 0.0 );\n        circleShade.y += bow5.y * ((length(dmct2*250.0) < 1.0) ? clamp( -sign(dmct2), 0.0, maxProjBrightness ) * intensity + (exp(-length(uv-tc)*80.0)) : 0.0 );\n        circleShade.z += bow5.z * ((length(dmct2*250.0) < 1.0) ? clamp( -sign(dmct2), 0.0, maxProjBrightness ) * intensity + (exp(-length(uv-tc)*40.0)) : 0.0 );\n                \n        circleShade += ( length(uv-barry) < br ) ? 0.0512 : 0.0;\n        \n        // -- -\n        \n        float atab = dot(at.yx*vec2(1.,-1.),ab)/dot(ab,ab);\n        float btbc = dot(bt.yx*vec2(1.,-1.),bc)/dot(bc,bc);\n        float ctca = dot(ct.yx*vec2(1.,-1.),ca)/dot(ca,ca);\n               \n        if ( ( atab < 0.0 ) && ( btbc < 0.0 ) && ( ctca < 0.0 ) )\n        {\n           circleShade *= vec3( -10.0, -10.0, -10.0 );\n        }\n        \n        // -- -\n        \n        const float dr = 0.0125 * 0.84;\n        uint inCount = 0u;\n        bool inA = false;\n        bool inB = false;\n        bool inC = false;\n        bool inLA = false;\n        bool inLB = false;\n\n        float x3 = la.x;\n        float y3 = la.y;\n        float x4 = lb.x;\n        float y4 = lb.y; \n\n        {\n            float x1 = ta.x;\n            float y1 = ta.y;\n            float x2 = tb.x;\n            float y2 = tb.y;\n\n            float ooDivisor = 1.0 / (((x1-x2)*(y3-y4))-((y1-y2)*(x3-x4)));\n            float t = (((x1-x3)*(y3-y4))-((y1-y3)*(x3-x4))) * ooDivisor;\n            float u = (((x1-x2)*(y1-y3))-((y1-y2)*(x1-x3))) * ooDivisor;\n\n            if ( clamp(u,-1.,1.) == u )\n            {\n                if ( u < 0. && clamp(t,0.,1.) == t )\n                {\n                    inA = true;\n                    inCount++;\n                    \n                    float pxt = (x1 + t * (x2-x1));\n                    float pyt = (y1 + t * (y2-y1));\n\n                    if ( length( uv - vec2( pxt, pyt ) ) < dr )\n                        circleShade = vec3( 1.5, 0.44, 0.44 );\n                }\n            }\n        }\n\n        {\n            float x1 = tb.x;\n            float y1 = tb.y;\n            float x2 = tc.x;\n            float y2 = tc.y;\n\n            float ooDivisor = 1.0 / (((x1-x2)*(y3-y4))-((y1-y2)*(x3-x4)));\n            float t = (((x1-x3)*(y3-y4))-((y1-y3)*(x3-x4))) * ooDivisor;\n            float u = (((x1-x2)*(y1-y3))-((y1-y2)*(x1-x3))) * ooDivisor;\n\n            if ( clamp(u,-1.,1.) == u )\n            {\n                if ( u < 0. && clamp(t,0.,1.) == t )\n                {\n                    inB = true;\n                    inCount++;\n\n                    float pxt = (x1 + t * (x2-x1));\n                    float pyt = (y1 + t * (y2-y1));\n\n                    if ( length( uv - vec2( pxt, pyt ) ) < dr )\n                        circleShade = vec3( 0.44, 1.5, 0.44 );\n                }\n            }\n        }\n\n        {\n            float x1 = tc.x;\n            float y1 = tc.y;\n            float x2 = ta.x;\n            float y2 = ta.y;\n\n            float ooDivisor = 1.0 / (((x1-x2)*(y3-y4))-((y1-y2)*(x3-x4)));\n            float t = (((x1-x3)*(y3-y4))-((y1-y3)*(x3-x4))) * ooDivisor;\n            float u = (((x1-x2)*(y1-y3))-((y1-y2)*(x1-x3))) * ooDivisor;\n\n            if ( clamp(u,-1.,1.) == u )\n            {\n                if ( u < 0. && clamp(t,0.,1.) == t )\n                {\n                    inC = true;\n                    inCount++;\n\n                    float pxt = (x1 + t * (x2-x1));\n                    float pyt = (y1 + t * (y2-y1));\n\n                    if ( length( uv - vec2( pxt, pyt ) ) < dr )\n                        circleShade = vec3( 0.44, 0.44, 1.5 );\n                }\n            }\n        }\n        \n        // -- -\n        \n        if ( inCount == 0u )\n        {\n            vec2 laat = ( la - ta );\n            vec2 labt = ( la - tb );\n            vec2 lact = ( la - tc );\n            float laab = dot(laat.yx*vec2(1.,-1.),ab)/dot(ab,ab);\n            float labc = dot(labt.yx*vec2(1.,-1.),bc)/dot(bc,bc);\n            float laca = dot(lact.yx*vec2(1.,-1.),ca)/dot(ca,ca);\n\n            if ( ( laab < 0.0 ) && ( labc < 0.0 ) && ( laca < 0.0 ) )\n            {\n                inLA = true;\n                inCount++;\n            }\n\n            vec2 lbat = ( lb - ta );\n            vec2 lbbt = ( lb - tb );\n            vec2 lbct = ( lb - tc );\n            float lbab = dot(lbat.yx*vec2(1.,-1.),ab)/dot(ab,ab);\n            float lbbc = dot(lbbt.yx*vec2(1.,-1.),bc)/dot(bc,bc);\n            float lbca = dot(lbct.yx*vec2(1.,-1.),ca)/dot(ca,ca);\n\n            if ( ( lbab < 0.0 ) && ( lbbc < 0.0 ) && ( lbca < 0.0 ) )\n            {\n                inLB = true;\n                inCount++;\n            }\n        }\n        \n        if ( inA || inB || inC || inLA || inLB )\n        {\n            // Red line if interection with triangle..\n            intersectScale += vec3( 5.0, 1.0, 0.05 );\n        }\n                \n        if ( ( atab < 0.0 ) && ( btbc < 0.0 ) && ( ctca < 0.0 ) )\n        {\n           intersectScale = vec3( inA?60.0:10.0, inB?60.0:10.0, inC?60.0:10.0 ) * 0.1;           \n           intersectScale = max( intersectScale, vec3(0.0) );\n        }\n        \n        if (  inLA || inLB )\n        {\n            // Red line if interection with triangle..\n            intersectScale += vec3( 5.0, 1.0, 0.05 );\n        }\n              \n    } // tt\n\n    \n    // ----- ---- --- -- -\n    // Render Primitives..\n    // ----- ---- --- -- -\n        \n    float tri_d = 10000.0;\n    const float tri_th = 0.0001;\n    for ( int t = 0; t < NUM_TRIS; t++ )\n    {\n        tri_d = min( tri_d, dLineSegment( uv, tris[ t ].a, tris[ t ].b, tri_th ) );\n        tri_d = min( tri_d, dLineSegment( uv, tris[ t ].b, tris[ t ].c, tri_th ) );\n        tri_d = min( tri_d, dLineSegment( uv, tris[ t ].c, tris[ t ].a, tri_th ) );\n    }\n    tri_d = 1.0 - smoothstep( 1.0 - tri_d, 1.0, 0.999 );\n\n    const float mouse_th = 0.0001;\n    float dT = dLineSegment( uv, testLine.a, testLine.b, mouse_th );\n    dT = 1.0 - smoothstep( 1.0 - dT, 1.0, 0.999 );\n     \n    fragColor = vec4( max( max( tri_d, circleShade.x ), dT*intersectScale.x ),\n                      max( max(  tri_d, circleShade.y ), dT*intersectScale.y ), \n                           max( max( tri_d, circleShade.z ), dT*intersectScale.z ),\n                           1.0 ) * 1.0;\n\n    // ----- ---- --- -- -\n}\n","name":"Image","description":"","type":"image"}]}