{"ver":"0.1","info":{"id":"mlKyWV","date":"1700700287","viewed":21,"name":"Oblique cone in ray tracing","username":"tydrao_xalys","description":"Demonstration of a method to compute an oblique cone with a circular base. (It can also compute right cone, as a particular case of an oblique cone).\nFeel free to do anything with it. Just, credit me in your public projects, it will be appreciated ! :)","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","cone","oblique"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// -----\n// STRUCTURE DECLARATIONS\n\nstruct Camera {\n    vec3 position;\n    vec3 view_direction;\n    vec3 vertical_axis;\n    vec3 horizontal_axis;\n    float height;\n    float width;\n    float distance_from_screen;\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Light {\n    vec3 position;\n    vec3 color;\n};\n\nstruct Plane {\n    vec3 n;                // Plane is defined by its normal vector.\n    float offset;\n    vec3 color;\n};\n\nstruct Cone {\n    vec3 center;           // Center of the base\n    vec3 axis_direction;   // Normal vector to the plane that contains the base of the cone.\n    vec3 apex;             // Apex/vertex of the cone (= summit)\n    float radius;          // Radius of the base\n    float height;          // Height of the cone along axis_direction\n    vec3 color;            // Color of the cone\n};\n\n\n// -----\n// INIT FUNCTIONS FOR STRUCTURES THAT NEEDS INITIAL COMPUTATION\n\nCamera initCamera( in vec3 position, in vec3 look_at, in float aperture_angle ) {\n    /**\n      * Compute the parameters of the camera.\n      *\n      * @param vec3 position        : Position of the camera.\n      * @param vec3 look_at         : Point targeted by the camera, which is the central point displayed on screen.\n      * @param float aperture_angle : Aperture angle of the camera.\n      *\n      * @return Camera              : Instance of the camera.\n    */\n    \n    Camera C;\n    \n    vec3 z_unit_vector = vec3(0.0,0.0,1.0);\n\n    C.position             = position;\n    C.view_direction       = normalize(look_at - position);\n    C.horizontal_axis      = normalize(cross(z_unit_vector, C.view_direction));\n    C.vertical_axis        = normalize(cross(C.view_direction, C.horizontal_axis));\n    C.width                = iResolution.x;    // screen width\n    C.height               = iResolution.y;    // screen height\n    C.distance_from_screen = C.height/(2.0*tan(radians(aperture_angle)/2.0));\n    \n    return C;\n}\n\nRay launchRayFromCamera( in Camera C, in vec2 frag_coord ) {\n    /**\n      * Launch a ray to the screen.\n      *\n      * @param Camera C         : Camera that represent the origin of the ray.\n      * @param vec2 frag_coord  : Fragment coordinates.\n      *\n      * @return Ray             : Instance of a ray.\n    */\n    \n    Ray R;\n    \n    vec3 position_on_screen = C.position \n                              + C.distance_from_screen*C.view_direction \n                              + (frag_coord.x-C.width/2.0)*C.horizontal_axis \n                              + (frag_coord.y-C.height/2.0)*C.vertical_axis;\n    \n    R.origin    = C.position;\n    R.direction = position_on_screen - C.position;\n    \n    return R;\n}\n\nCone initCone( in vec3 center, in vec3 axis_direction, in vec3 apex, in float radius, in vec3 color ) {\n    /**\n      * Compute the height of a cone and instanciate one in the shader using the structure declaration.\n      *\n      * @param vec3 center         : Center of the base.\n      * @param vec3 axis_direction : Direction of the axis of the base. (=Normal vector to the plane that contains the base of the cone.)\n      * @param vec3 apex           : Apex/vertex of the cone.\n      * @param float radius        : Radius of the base.\n      * @param float color         : Color of the cone.\n      *\n      * @return Cone               : Instance of a cone.\n    */\n    \n    Cone C;\n    \n    C.center         = center;\n    C.axis_direction = axis_direction;\n    C.apex           = apex;\n    C.radius         = radius;\n    \n    /* Cone height is defined as the distance between the center C of the base and the projection of the apex on\n    the line directed by axis_direction and passing through C.*/\n    C.height         = dot(axis_direction, apex-center); \n    C.color          = color;\n    \n    return C;\n}\n\n\n// -----\n// Constants\n\nconst int nb_cones  = 2;\nconst int nb_lights = 2;\n\nCone cones[nb_cones];\nLight lights[nb_lights];\n\n\n// -----\n// OTHER FUNCTIONS\n\nbool intersectPlane( in Ray R, in Plane P, out float t ) {\n    /**\n      * Check if a ray intersect a plane.\n      * If true, compute the value of t that enable to get the coordinates of the intersection point with the following formula:\n      *      Ray.origin + t * Ray.direction\n      *\n      * @param Ray R     : Targeted ray.\n      * @param Plane P   : Targeted plane.\n      * @param float t   : Value used to compute intersection point coordinates.\n      *\n      * @return bool     : Check that tell if the given ray intersect the given plane.\n    */\n    \n    float denom = dot(P.n, R.direction);\n    if (abs(denom) < 1e-5) {\n        return false;\n    }\n    t = dot(P.n, -P.offset * P.n - R.origin) / denom;\n\n    if (t < 0.0) {\n        return false;\n    }\n\n    return true;\n}\n\nbool intersectCone( in Ray R, in Cone C, out float t ) {\n    /**\n      * Check if a ray intersect a cone.\n      * If true, compute the value of t that enable to get the coordinates of the intersection point with formula:\n      *      Ray.origin + t * Ray.direction\n      *\n      * @param Ray R     : Targeted ray.\n      * @param Cone C    : Targeted cone.\n      * @param float t   : Value used to compute intersection point coordinates.\n      *\n      * @return bool     : Check that tell if the given ray intersect the given cone.\n    */\n    \n    vec3 CO = R.origin - C.center;\n    vec3 AC = C.apex - C.center;\n    float u = dot(C.axis_direction, CO) / C.height;\n    float v = dot(C.axis_direction, R.direction) / C.height;\n    float r2 = pow(C.radius, 2.0);\n    \n    vec3 x = CO - u * AC;\n    vec3 y = R.direction - v * AC;\n\n    float a = dot(y,y) - r2 * pow(v,2.0);\n    float b = 2.0 * (dot(x,y) - r2 * v * (u - 1.0));\n    float c = dot(x,x) - r2 * (1.0 + u * (u - 2.0));\n    \n    float delta = pow(b,2.0) - 4.0*a*c;\n    if (delta<=0.0){\n        return false;\n    }\n    \n    t = (-b - sqrt(delta))/(2.0*a);\n    float l = dot(C.axis_direction,CO) + t * dot(C.axis_direction, R.direction);\n    if (l > 0.0 && l < C.height) {\n        return true;\n    }\n    \n    t = (-b + sqrt(delta))/(2.0*a);\n    l = dot(C.axis_direction,CO) + t * dot(C.axis_direction, R.direction);\n    if (l > 0.0 && l < C.height) {\n        return true;\n    }\n    \n    return false;\n}\n\nvec3 computeNormalVector( in vec3 M, in Cone C ) {\n    /**\n      * Compute the normal vector to the cone surface at the point M.\n      *\n      * @param vec3 M    : Targeted point.\n      * @param Cone C    : Targeted cone.\n      *\n      * @return vec3     : Normal vector.\n    */\n    \n    vec3 AC_unit = normalize(C.center - C.apex); // Unit vector of the center-apex axis\n    vec3 AM_unit = normalize(M - C.apex);\n    float AM_length = length(M - C.apex);\n    \n    // Computation of intersection point P between the line directed by the normal vector and AC.\n    // In that case, P is on AC line.\n    float AP_length = AM_length / dot(AC_unit, AM_unit);\n    vec3 P = C.apex + AP_length*AC_unit;\n    \n    return normalize(M-P);\n}\n\nfloat computeLight( in vec3 M, in vec3 n, in Light L ) {\n    /**\n      * Compute the light coefficient of a point, taking into account shadows of cones displayed on screen.\n      *\n      * @param vec3 M    : Targeted point.\n      * @param vec3 n    : Normal vector to the surface on which M is located.\n      * @param Light L   : Light object used for computation.\n      *\n      * @return vec3     : Light coefficient.\n    */\n    \n    float t;\n    float epsilon = 1e-5;\n    Ray light_ray = Ray(M, L.position-M); // Vector used to compute shadows\n    for (int i = 0 ; i < nb_cones ; i++) {\n        if (intersectCone(light_ray, cones[i], t) && t > epsilon && t < 1.0) return 0.0;\n    }\n    \n    float light_coeff = dot(n, normalize(light_ray.direction));\n    if (light_coeff < 0.0) {\n        return 0.0;\n    } else {\n        return light_coeff;\n    }            \n}\n\n// -----\n// MAIN FUNCTIONS\n\nvoid mainImage( out vec4 frag_color, in vec2 frag_coord ) {\n\n    // -----\n    // Some declarations used later\n    \n    mat3 rotation_along_z = mat3(\n        cos(iTime) , sin(iTime), 0, \n        -sin(iTime), cos(iTime), 0,\n        0          , 0         , 1\n    );\n    \n    vec2 uv = frag_coord / iResolution.xy;\n    \n    \n    // -----\n    // Background color\n    \n    vec3 color = vec3(0.0,0.0,0.0);\n    \n    \n    // -----\n    // Camera and ray declaration\n    \n    Camera camera = initCamera(\n        vec3(3.0, 0.0, 0.0),\n        vec3(0.0, 0.0, 0.0),\n        50.0\n    );\n    \n    Ray ray = launchRayFromCamera(camera, frag_coord);\n    \n    \n    // -----\n    // Lights declarations. If you want to add more lights, don't forget to change `nb_lights` in `Constants` section above.\n    \n    lights[0] = Light(\n        vec3(0.0, 3.0, 0.0), \n        vec3(1.0, 1.0, 1.0)\n    );\n    \n    lights[1] = Light(\n        vec3(3.0, 1.0, 1.5),\n        vec3(1.0, 1.0, 1.0)\n    );\n    \n    \n    // -----\n    // Cones declarations. If you want to add more cones, don't forget to change `nb_cones` in `Constants` section above.\n    \n    cones[0] = initCone(\n        rotation_along_z*vec3(0.0, -1.0, -0.5),\n        normalize(vec3(0.0, 0.0, 1.0)),\n        vec3(0.0, 0.0, 1.0),\n        0.2,\n        0.5+0.5*cos(iTime + uv.xyx + vec3(0.0,2.0,4.0))\n    );\n    \n    cones[1] = initCone(\n        vec3(0.0, -1.0, 0.5), \n        normalize(vec3(-0.5, 0.0, 1.0)), \n        vec3(-0.5, -1.0+0.5*cos(iTime), 1.5), \n        0.2, \n        vec3(1.0,0.0,0.0)\n    );\n    \n    \n    // -----\n    // Plane declaration to see shadows.\n    \n    Plane plane = Plane(\n        normalize(vec3(1.5,1.0,5.0)), \n        10.0, \n        vec3(1.0,1.0,1.0)\n    );\n    \n    \n    // -----\n    // Computations\n    \n    float t = 1e30;\n    float tbis = 1.0;\n    float light_coeff;\n    \n    if (intersectPlane(ray, plane, tbis) && tbis < t) {\n        t = tbis;\n        \n        vec3 M = ray.origin + t * ray.direction;\n        light_coeff = computeLight(M, plane.n, lights[1]);\n        color = light_coeff * plane.color * lights[1].color;\n    }\n    \n    for (int i = 0; i<nb_cones; i++) {\n        if (intersectCone(ray, cones[i], tbis) && tbis < t) {\n            t = tbis;\n            \n            vec3 M = ray.origin + t * ray.direction;\n            vec3 n = computeNormalVector(M, cones[i]);\n            light_coeff = computeLight(M, n, lights[0]);\n            color = light_coeff * cones[i].color * lights[0].color;\n        }\n    }\n  \n    \n    // -----\n    // Output to screen\n    frag_color = vec4(color,1.0);\n    \n    // -----\n}\n\n// -----","name":"Image","description":"","type":"image"}]}