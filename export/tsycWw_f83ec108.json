{"ver":"0.1","info":{"id":"tsycWw","date":"1603048839","viewed":75,"name":"Primitive SDF","username":"emedan","description":"Just bullshit, but nice colors and object mask stuff.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define gamma 2.2\n#define gammaInv 0.45\n\n// map from to, clamped\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return clamp(min2 + (value - min1) * (max2 - min2) / (max1 - min1), min2, max2);\n}\n\n\n// polynomial smooth min (k = 0.1);\nfloat sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\n\n// Return rotation matrix\nmat3 rotate3dx(float _angle){\n    float c = cos(_angle);\n    float s = sin(_angle);\n    return mat3(\n        1, 0,  0, \n        0, c, -s,\n        0, s,  c\n    );\n}\nmat3 rotate3dy(float _angle){\n\tfloat c = cos(_angle);\n    float s = sin(_angle);\n    return mat3(\n         c, 0, s,\n         0, 1, 0,  \n        -s, 0, c\n    );\n}\nmat3 rotate3dz(float _angle){\n\tfloat c = cos(_angle);\n    float s = sin(_angle);\n    return mat3(\n        c, -s, 0,\n        s,  c, 0,\n        0,  0, 1\n    );\n}\n\n// Return rotation matrix\nmat2 rotate2d(float _angle){\n    float c = cos(_angle);\n    float s = sin(_angle);\n    return mat2(\n        c, -s,\n        s,  c\n    );\n}\n\n\n// Signed, negative inside object\nfloat SDF_box(vec3 p, vec3 size, float rounding) {\n\tp = abs(p)-size;\n    return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0) - rounding;\n}\n\n\n// Signed, negative inside object\nvec2 SDF_Capsule2D(vec2 p, vec2 a, vec2 b, float r) {\n    \n    vec2 AB = b-a;\n    vec2 AP = p-a;\n    \n    float t = dot(AP, AB) / dot(AB,AB);\n    t = clamp(t, 0.0, 1.0);\n\n    float d; \n    d = length(p - (a + t*AB)) -r;\n    \n    \n    \n    return vec2(d, t);\n}\n\n\n// Returns also t with scale from A-cr .. A+cr along AB.\nvec3 SDF_CapTest(vec2 p, vec2 a, vec2 b, float r) {\n    \n    vec2 AB = b-a;\n    vec2 AP = p-a;\n    float t = dot(AP, AB) / dot(AB,AB);    \n    t = clamp(t, 0.0, 1.0);\n    \n    vec2 a0 = a-r*AB;\n    vec2 b0 = b+r*AB;\n    vec2 A0B0 = b0-a0;\n    vec2 A0P = p-a0;\n    float t0 = dot(A0P, A0B0) / dot(A0B0,A0B0);\n    t0 = clamp(t0, 0.0, 1.0);\n    \n    float d; \n    d = length(p - (a + t*AB)) -r;\n    \n    // Desmos is your friend.\n    //d = length(p - (a + t*AB)) -0.7*r -2.0*r*smoothstep(0.0, 1.0, pow(t-0.5, 2.0));\n    float y = pow(t-0.5, 2.0)*( 1.0-pow((t-0.5)*1.4, 2.0) );\n    y *= 3.0;\n    d = length(p - (a + t*AB)) -0.3*r -2.0*r*y;\n    \n    return vec3(d, t, t0);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n    \n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n \tcol = vec3(0.909, 0.388, 0.458);\n    col = normalize(vec3(175, 224, 211));\n    vec3 bgCol = vec3(175, 224, 211)/255.0;\n    \n\tvec2 cA = vec2(-0.3, 0);\n\tvec2 cB = vec2( 0.3, 0);\n    float cr = float(0.3);\n    vec3 cp = SDF_CapTest(uv, cA, cB, cr);\n    float cMask = cp.x;\n    // Mask out object as 0.\n    //cMask = step(0.0, cMask);\t\n    cMask = smoothstep(0.0, 0.01, cMask);\t\n\n    // Apply object color\n    vec3 cCol;\n    float tExt = 0.5+abs(cp.y-0.5);\n    float cpLen = length(cB-cA);\n    float cpTotLen = length(cB-cA)+2.0*cr;\n    float cpf = cpTotLen/cpLen;\n    tExt = cp.z;\n    //tExt = map(cp.y, -cr/cpLen, 1.0+cr/cpLen, 0.0, 1.0);\n    vec3 cc1 = pow(vec3(0.909, 0.388, 0.458), vec3(gamma));\t// Colors selected from screen, so invert gamma\n    vec3 cc2 = pow(vec3(0.878, 0.866, 0.223), vec3(gamma)); //  since it will be applied last.\n    cCol = mix(cc1, cc2, tExt);\n    cCol *= (1.0-cMask); \n\n    \n    // Draw capsule\n    col = bgCol*cMask + cCol;\n\n    \n    // Outline of original capsule\n    vec2 cp0 = SDF_Capsule2D(uv, cA, cB, cr);\t\t\t// \n    float cp0mask = smoothstep(0.0, 0.015, abs(cp0.x)); // Edge = 0 with distance function.\n    cp0mask = clamp(cp0mask+0.7, 0.0, 1.0);\t\t\t\t// Lighten the black outline for alpha.\n    col *= (cp0mask);\t\t\t\t\t\t\t\t\t// Multiply blend mode.\n\n    \n    // Edges (why is this to prefer from simple if-statement?)\n    float lm;\n    lm = step(0.75, uv.x);\n    col = col*(1.0-lm) + lm*cc2;\n    lm = step(uv.x, -0.75);\n    col = col*(1.0-lm) + lm*cc1;\n    \n    // Gamma\n    col = pow( clamp(col,0.0,1.0), vec3(gammaInv) );\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}