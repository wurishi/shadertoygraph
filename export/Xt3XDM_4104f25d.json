{"ver":"0.1","info":{"id":"Xt3XDM","date":"1482112037","viewed":237,"name":"NightShift","username":"Unix","description":"A new shadertro ;-p  - Approximate duration : 4 min... -\nenjoy !\nThe music called \"Hammer-3\" was released @ evoke 2016.","likes":6,"published":1,"flags":96,"usePreview":0,"tags":["terrain","raymarch","cloud","mountain","godray","unix"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float motionBlurAmp=0.4;\n\n\nfloat bit(float c1, float c2, float c3, float c4, float c5, vec2 p) {\n\tfloat chr=0.0;\n\tif (p.x==1.0) chr=c1;\n\telse if (p.x==2.0) chr=c2;\n\telse if (p.x==3.0) chr=c3;\n\telse if (p.x==4.0) chr=c4;\n\telse if (p.x==5.0) chr=c5;\n\treturn floor(fract(chr/pow(10.0,p.y))*10.0);\n}\n\nfloat writestr(vec2 p, vec2 fragCoord) {\n\n    p=floor(fragCoord.xy-p+1.0);\n    \n\tif (p.y<1.0 || p.y>7.0) return 0.0;\n\t    \n    //N\n\tfloat b;\n\tb=bit( 1111111.0, 0100000.0, 0011100.0, 0000010.0, 1111111.0, p );\t\t\t\n    //I\n\tp.x-=6.0;\n\tb+=bit( 1000001.0, 1111111.0, 1000001.0, 0000000.0, 0000000.0, p );\n\t//G\n\tp.x-=4.0;\n\tb+=bit( 1111111.0, \n                    1000001.0,\n                    1001001.0, \n                    1001111.0, \n                    1001000.0, p );\t\n\t\t\t//H\n\t \t\tp.x-=6.0;\n\t    \tb+=bit( 1111111.0, \n                    0001000.0, \n                    0001000.0, \n                    0001000.0, \n                    1111111.0, p );\n\t\t\t//T\n\t \t\tp.x-=5.0;\n            b+=bit( 1000000.0, 1000000.0, 1111111.0, 1000000.0, 1000000.0, p );\n\t    \t//S\n\t \t\tp.x-=5.0;\n\t    \tb+=bit( 1111001.0, \n                    1001001.0, \n                    1001001.0, \n                    1001001.0, \n                    1001111.0, p );\n\t\t\t//H\n\t \t\tp.x-=6.0;\n\t  \t\tb+=bit( 1111111.0, \n                    0001000.0, \n                    0001000.0, \n                    0001000.0, \n                    1111111.0, p );\n\t\t\t//I\n\t \t\tp.x-=6.0;\n\t    \tb+=bit( 1000001.0, \n                    1111111.0, \n                    1000001.0, \n                    0000000.0, \n                    0000000.0, p );\n\t\t\t\t\t\n    \t\t//F\n\t \t\tp.x-=4.0;\n\t    \tb+=bit( 1111111.0, \n                   \t1001000.0, \n                   \t1001000.0, \n                    1000000.0, \n                    0000000.0, p );\n\n    \t\t//T\n\t \t\tp.x-=4.0;\n\t    \tb+=bit( 1000000.0, 1000000.0, 1111111.0, 1000000.0, 1000000.0, p );\n\t\t\t//space\n\t\t\tp.x-=4.0;\n\t\t\t//B\n\t \t\tp.x-=6.0;\n\t    \tb+=bit( 1111111.0, 1001001.0, 1001001.0, 0111001.0, 0000110.0, p );\n            //Y\n\t \t\tp.x-=5.0;\t\t\t\t\t//rounding bug.. fract should be 0 but...\n\t    \tb+=bit( 1100000.0, 0010000.0, 0001111.1, 0010000.0, 1100000.0, p );\n\t\t\t//space\n\t\t\tp.x-=4.0;\t\n\t\t\t//U\n\t      \tp.x-=6.0;\n\t\t  \tb+=bit( 0111110.0, \n                    0000001.0, \n                   \t0000001.0, \n                    0000001.0, \n                    0111110.0, p );\n\t\t\t//N\n\t\t  \tp.x-=6.0;\n\t      \tb+=bit( 1111111.0, 0100000.0, 0011100.0, 0000010.0, 1111111.0, p );\t\n\t\t\t//I\n\t\t  \tp.x-=6.0;\n\t      \tb+=bit( 1000001.0, 1111111.0, 1000001.0, 0000000.0, 0000000.0, p );\n\t\t  \t//X\n\t\t  \tp.x-=4.0;\n\t      \tb+=bit( 1000001.0, 0100010.0, 0011100.0, 0100010.0, 1000001.0, p );\n\t\n\treturn b;\n}\n\n/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv=fragCoord.xy / iResolution.xy;\n\t\n\t\n\tvec2 strpos=vec2( iResolution.x/2.0-120.0, iResolution.y/2.0-50.);\n\t\n\tvec3 col=vec3( writestr( strpos, fragCoord*0.5 ) );\n\n\tif (col.x==0.0) {\n\t\tcol=vec3(uv, 0.5+0.5*sin(iTime));\n\t}\n\t\n\t\n\tfragColor = vec4( col, 1.0 );\n}*/\n\nvec2 uvToTex(vec2 uv){\n    uv.y-=0.05;\n\tuv *=iResolution.yy;\n    uv +=iResolution.xy*.5;\n    uv /=iResolution.xy;\n    return uv;\n}\n\n\nvec3 sampleColor(vec2 uv){\n    return texture(iChannel2, uvToTex(uv)).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uvo = fragCoord.xy / iResolution.xy;\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5) / iResolution.yy;\n    if (abs(uv.y)>.27) {\n        fragColor = vec4(0,0,0,1);\n        return;\n    }\n    if (iTime>48.) uv.y+=0.05;\n    else if (iTime>38.5) uv.y+=0.30;\n    else uv.y+=0.08;\n    vec4 fb = texture(iChannel2, uvToTex(uv));\n    float td = fb.w;\n        \n    vec3 acc = vec3(0);\n    \n    if (iTime>40.0) motionBlurAmp =0.04;\n    \n    vec4 noise = texture(iChannel1, (fragCoord+floor(iTime*vec2(12.0,56.0)))/64.0);    \n    acc += sampleColor(uv*((noise.x+2.0)/td*motionBlurAmp+1.0))*vec3(.4,.1,.1);\n    acc += sampleColor(uv*((noise.y+1.0)/td*motionBlurAmp+1.0))*vec3(.3,.3,.1);\n    acc += sampleColor(uv*((noise.z+0.0)/td*motionBlurAmp+1.0))*vec3(.2,.4,.2);\n    acc += sampleColor(uv*((noise.w-1.0)/td*motionBlurAmp+1.0))*vec3(.1,.3,.3);\n    acc += sampleColor(uv*((noise.x-2.0)/td*motionBlurAmp+1.0))*vec3(.1,.1,.4);\n    \n    \n    vec3 c = acc.xyz;\n    c*=3.0;\n    c-=0.04;\n    c = max(c,.0);\n    c=(vec3(1.3,1.3,1.3)*c)/(vec3(1)+c);\n    c=sqrt(max(c,.0));\n    c+=noise.xyz*0.01;    \n    vec2 offset = vec2(iTime*vec2(0.0,-1.0))/4096.0;    \n    \n    c *= texture(iChannel3, uvToTex(uv+offset)).xyz*1.9;        \n    c *= texture(iChannel0, uvToTex(uv+offset)).xyz*1.5;    \n    vec3 c2 = texture(iChannel0, uvToTex(uv+offset)).xyz*1.3;        \n    c = (c*0.9)*(c2*c2)*1.4;\n    if (iTime>10. && iTime<20. ) {\n    \tvec3 col=vec3( writestr( vec2(550.,150.), fragCoord*0.5));\n    \tc=c+col*(iTime-10.);\n    } else if (iTime>20. && iTime<30. ) {\n    \tvec3 col=vec3( writestr( vec2(550.,150.), fragCoord*0.5));\n    \tc=c+col*(30.-iTime);\n    }\n    if (iTime>79.0 && iTime<84.) {\n    \tif (td<2.9) c+=vec3(0.3,0.2,0.9)*0.4;\n    }\n    \n    fragColor = vec4(c, 1.0);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dBGD1","filepath":"https://soundcloud.com/imalogic/hammer-3","previewfilepath":"https://soundcloud.com/imalogic/hammer-3","type":"musicstream","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define LDIR normalize(vec3(9,-2,-6))\n#define ATMOS_COLOR vec3(.2,.5,0.6)\n#define SUN_COLOR vec3(.8,.7,.7)\n\nfloat df ( in vec3 p){\n    \n    float terra = p.y+0.92 + abs(sin(iTime/4.));    \n    terra+=-texture(iChannel0, p.xz*0.008).r;         \n\n    if (iTime>154.0) {\n    \tterra = 0.995 + p.y;    \t    \n    } else if (iTime>130.5) {//130.5\n    \tterra = 0.795 + p.y;\n    \tterra+=-texture(iChannel0, p.xz*0.2).r;                        \n    }\n    else if (iTime>124.5) {//124.5\n    \tterra = 0.695 + p.y*0.5;    \n    \tterra+=-texture(iChannel0, p.xz*0.02).g;         \n        //terra*= abs(cos((p.y)+iTime/100.));          \n    }\n    else if (iTime>84.0) terra *= abs(cos((p.x*p.x)*iTime/100.))+abs(sin(p.x*p.x+iTime/10.));    \n    else if (iTime>79.5) terra *= abs(cos((p.y*p.x)*iTime/100.))+abs(sin(p.x+iTime/80.)/10.);    \n    else if (iTime>74.5) terra *= abs(cos((p.y*p.x)*iTime/100.))+abs(sin(iTime/80.)/2.);\n    else if (iTime>72.) terra *= abs(cos((p.y*p.x)*iTime/100.))+abs(sin(iTime/40.)/5.);\n    else if (iTime>69.5) terra *= abs(cos((p.y*p.x)*iTime/100.))+abs(sin(iTime/10.)/10.);\n    else if (iTime>60.) terra *= abs(cos((p.x*10.)*iTime/100.))+abs(sin(p.z+iTime/10.)/10.);\n    return terra;\n}\n\nvec3 nf(in vec3 p, in float theta){\n    vec2 e = vec2(theta, 0.0+iTime/100.);\n    float c = df(p);\n    return normalize(vec3(c-df(p+e.xyy),c-df(p+e.yxy),c-df(p+e.yyx)));\n}\n\nvec3 skyColor(in vec3 d){\n    vec3 ldir = LDIR;\n    vec3 atmosColor = ATMOS_COLOR;\n    atmosColor = mix(atmosColor, vec3(.9,.5,.2), pow(dot(d,-ldir)*.5+.5,4.0));\n    atmosColor = mix(atmosColor, vec3(.9,.1,.1), pow(dot(d,-ldir)*.5+.5,16.0));\n    //vec3 sun = SUN_COLOR*pow(dot(d,-ldir)*.5+.501,6960.0)*.03;\n\treturn (pow((1.0-abs(d.y)),5.5-iTime/5.)*atmosColor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 noise = texture(iChannel1, (fragCoord+floor(vec2(12.0,56.0)))/64.0);\n\tvec2 uv = ((fragCoord.xy+noise.xy*0.5) - iResolution.xy*.5) / iResolution.yy;    \n    uv.y+=0.015;\n    \n    vec3 pos = vec3(0,0,-4.0+iTime);\n    \n    if (iTime>110. ) uv.x += 0.05*(31.);\n    else if (iTime>95. ) {\n        uv.x += 0.05*(iTime-95.);\n        pos = vec3(4.,0,-4.0+iTime);\n    }\n    if (iTime>79.0 && iTime<84.0) {\n        uv.x -= 0.05*(iTime-78.)/10.;\n        pos = vec3(0.,0.,-0.0);    \n    }\n    \n    vec3 dir = normalize(vec3(uv, 0.1));\n        \n    float d,td=.01;\n\tint it;\n    for(int i=0; i<50; i++){\n    \td = df(pos);\n        pos += d*dir;\n        td += d;\n        it = i;\n        if (d<0.001||d>100.0) break;\n    }\n    float sky = min(max(d*.5,.0),1.0);\n    vec3 ldir = LDIR;\n    vec3 atmosColor = ATMOS_COLOR;\n    atmosColor = mix(atmosColor, vec3(.9,.5,.2), pow(dot(dir,-ldir)*.5+.5,4.0));\n    atmosColor = mix(atmosColor, vec3(.9,.1,.1), pow(dot(dir,-ldir)*.5+.5,16.0));\n    vec3 sunColor = SUN_COLOR;\n    \n    float wf = (-df(pos-vec3(-1,0,0))+df(pos))*0.5;\n    wf=min(max(wf,0.0),1.0);\n    float w = (-df(pos-vec3(0,0,-1))+df(pos))*0.5;\n    w=min(max(w,0.0),1.0);\n    vec3 normal = normalize(nf(pos, 0.1)+nf(pos, 0.025));\n    float wfa = (df(pos)-df(pos+normal))*.5;\n    wfa=min(max(wfa,0.0),1.0);\n    float wfa2 = pow(wfa*1.5,8.0);\n    wfa2=min(max(wfa2,0.0),1.0);\n    \n    vec3 c;\n    float fog = min(max((pow(-1.0+pos.y,2.0)),.0)*0.004*td+td*0.005+0.001,1.0);\n    c=vec3(fog);\n    vec3 albedo = mix(mix(vec3(.2,.5,.3), vec3(.4,.6,.2), wf), vec3(.3,.3,.3),w);\n    albedo = mix(albedo, vec3(.9,.9,.4), wfa2);       \n    \n    float sunDiffuse = (max(dot(ldir,normal),.0));\n    sunDiffuse = min(sunDiffuse, df(pos-ldir*.5)*2.0);\n    sunDiffuse = min(sunDiffuse, df(pos-ldir));\n    sunDiffuse = max(.0,sunDiffuse);\n    float atmosDiffuse = (dot(vec3(0,-1,0),normal)*.5+.5);\n    atmosDiffuse *= wfa*0.125;\n    \n    c = sunDiffuse*albedo*sunColor + atmosDiffuse*albedo*atmosColor*wfa;\n    c = mix(c,atmosColor,fog);\n    c = mix(c, skyColor(dir),sky);\n   \n\tfragColor = vec4(c,td);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define MIN_HEIGHT 2.0\n#define MAX_HEIGHT 6.5\n#define WIND vec2(0.25, 0.1)\n\n#define sundir normalize(vec3(0.0+iTime/10.,1.45,0.0))\n\nfloat noise( in vec3 x )\n{\n    vec3 f = fract(x);\n    vec3 p = floor(x);\n    f = f * f * (3.0 - 2.0 * f);\n    \n    p.xz += WIND * iTime;\n    vec2 uv = (p.xz + vec2(37.0, 17.0) * p.y) + f.xz;\n    vec2 rg = texture(iChannel0, (uv + 0.5)/256.0, -100.0).yx;\n    return mix(rg.x, rg.y, f.y);\n}\n\nfloat fractal_noise(vec3 p)\n{\n    float f = 0.0;\n    // add animation\n    p = p + (vec3(0.5, 0.0, 0.3) * iTime/10.);\n    p = p * 2.0;\n    f += 0.50000 * noise(p); p = 2.0 * p;\n    f += 0.25000 * noise(p); p = 2.0 * p;\n\tf += 0.12500 * noise(p); p = 2.0 * p;\n\tf += 0.06250 * noise(p); p = 2.0 * p;\n    f += 0.03125 * noise(p);\n    \n    return f;\n}\n\nfloat density(vec3 pos)\n{    \n    float den = 3.0 * fractal_noise(pos * 0.5) - 2.0 + (pos.y - MIN_HEIGHT);\n    float edge = 1.0 - smoothstep(MIN_HEIGHT, MAX_HEIGHT, pos.y);\n    edge *= edge;\n    den *= edge;\n    den = clamp(den, 0.0, 1.0);\n    \n    return den;\n}\n\nvec3 raymarching(vec3 ro, vec3 rd, float t, vec3 backCol)\n{   \n    vec4 sum = vec4(0.0);\n    vec3 pos = ro + rd * t;\n    for (int i = 0; i < 80; i++) {\n        if (sum.a > 0.99 || \n            pos.y < (MIN_HEIGHT-1.0) || \n            pos.y > (MAX_HEIGHT+1.0)) break;\n        \n        float den = density(pos);\n        \n        if (den > 0.001) {\n            float dif = clamp((den - density(pos+0.3*sundir))/0.6, 0.0, 1.0);\n\n            vec3 lin = vec3(0.65,0.7,0.75)*1.5 + vec3(1.0, 0.6, 0.3)*dif;        \n            vec4 col = vec4( mix( vec3(1.0,0.95,0.8)*1.0, vec3(0.145,0.4,0.45), den), den);\n            if (iTime>180.) {//190\n                col = vec4( mix( vec3(1.0,0.95,0.8), vec3(0.405,0.45,0.24), den), den);                \n                vec4 col2 = vec4( mix( vec3(1.0,0.95,0.8), vec3(0.305,0.4,0.54), den), den);\n                col = mix(col,col2,(iTime-180.)/8.);\n            } \n            else if (iTime>170.) {//170\n\t\t\t\tcol = vec4( mix( vec3(1.0,0.95,0.8)*1.0, vec3(0.145,0.4,0.45), den), den);\n                vec4 col2 = vec4( mix( vec3(1.0,0.95,0.8), vec3(0.405,0.45,0.24), den), den);\n                col = mix(col,col2,(iTime-164.)/8.);\n            }\n\n            col.rgb *= lin;\n\n            // front to back blending    \n            col.a *= 0.55;\n            if (iTime<38.5) col.rgb += col.a;\n            else col.rgb *= col.a;\n\n            sum = sum + col*(1.0 - sum.a); \n        }\n        \n        t += max(0.05, 0.02 * t);\n        pos = ro + rd * t;\n    }\n    \n    sum = clamp(sum, 0.0, 1.0);\n    \n    float h = rd.y;\n    sum.rgb = mix(sum.rgb, backCol, exp(-20.*h*h) );\n    \n    return mix(backCol, sum.xyz, sum.a);\n}\n\nfloat planeIntersect( vec3 ro, vec3 rd, float plane)\n{\n    float h = plane - ro.y;\n    return h/rd.y;\n}\n\nmat3 setCamera(vec3 ro, vec3 ta, float cr)\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nfloat rand(vec3 p)\n{\n \treturn fract(abs(cos(dot(p,vec3(84.53,93.38,65.26)))*46.35));\n}\nfloat srand(vec3 p)\n{\n \tvec3 f = floor(p);\n    vec3 s = smoothstep(vec3(0.0),vec3(1.0),fract(p));\n    \n    return mix(mix(mix(rand(f),rand(f+vec3(1.0,0.0,0.0)),s.x),\n           mix(rand(f+vec3(0.0,1.0,0.0)),rand(f+vec3(1.0,1.0,0.0)),s.x),s.y),\n           mix(mix(rand(f+vec3(0.0,0.0,1.0)),rand(f+vec3(1.0,0.0,1.0)),s.x),\n           mix(rand(f+vec3(0.0,1.0,1.0)),rand(f+vec3(1.0,1.0,1.0)),s.x),s.y),s.z);\n}\nvec3 background(vec3 d)\n{\n    float stars = pow(srand(iTime+d+640.0)*srand(d*96.0)*srand(d*128.0)+0.2,8.0)*1.0;\n    return vec3(1.0)*stars;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.yy;\n    vec2 mo = vec2(0.0);       \n    vec3 ro = vec3(0.0, 1.0, -2.0);\n    \n    if (iTime>190.) {\n        ro = vec3(1.0+(iTime-190.), -7.5,-1.0);\n    \tmo=vec2(-1.,-.5);\n    } else if (iTime>170.) {\n        ro = vec3(1.0, -4.5,-1.0);\n    \tmo=vec2(1.,-.5);\n    }\n    else if (iTime>158.0) ro = vec3(-1.0, 2.5, 1.5);\n    else if (iTime>154.) ro = vec3(1.0, 2.0, 1.0);\n    else if (iTime>96.) ro = vec3(1.0, 0.0, -2.0);\n    // Rotate the camera\n    vec3 target = vec3(ro.x+10., 1.0+mo.y*3.0, ro.z);\n    \n    vec2 cossin = vec2(cos(mo.x), sin(mo.x));\n    \n    mat3 rot = mat3(cossin.x, 0.0, -cossin.y,\n                   \t0.0, 1.0, 0.0,\n                   \tcossin.y, 0.0, cossin.x);\n    target = rot * (target - ro) + ro;\n    \n    // Compute the ray\n    vec3 rd;\n    if (iTime>190.) rd = setCamera(ro, target, 0.2) * normalize(vec3(p.xy+0.2, 0.8));\n    else if (iTime>180.) rd = setCamera(ro, target, 0.1) * normalize(vec3(p.xy, 1.0));\n    else rd = setCamera(ro, target, 0.0) * normalize(vec3(p.xy, 1.5));\n    float dist = planeIntersect(ro, rd, MIN_HEIGHT);\n    \n    float sun = clamp(dot(sundir, rd), 0.0, 1.0);\n\tvec3 col = mix(vec3(0.78,0.78,0.7), vec3(0.3,0.4,0.5), p.y * 0.5 + 0.5);\n\tcol += 0.5*vec3(1.0,0.5,0.1)*pow(sun, 8.0);\n    \n    if (dist > 0.0) {\n        col = raymarching(ro, rd, dist, col);\n    }\n    rd.y+=0.8;\n    col += background(rd);\n\n    \n    float radius = iTime/10.;\n    if (iTime>207.) {        \n\t\tif (radius>0.) radius = 209.0-iTime;\n    }\n\n    float circle = step(length(p), radius);\n    \n    float ff = clamp(iTime/40.,0.0,1.0);\n    col.rgb = mix(vec3(1.0,0.,0.), col.rgb, ff)*circle;\n    \n    fragColor = vec4(col, 1.0);\n    fragColor = vec4(col, 1.0);\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"const float SAMPLES = 46.; \n\n// 2x1 hash. Used to jitter the samples.\nfloat hash( vec2 p ){ return fract(sin(dot(p, vec2(41, 289)))*45758.5453); }\n\n\n// Light offset.\nvec3 lOff(){    \n    \n    //vec2 u = sin(vec2(1.57, 0) - iTime/200.);\n    vec2 u = sin(vec2(1.27, -2.5));\n    //vec2 u = sin(vec2(-2.447+iTime/2., -0.161+iTime/5.));\n    //if (u.x<-1.0) u.x=-1.0;\n    mat2 a = mat2(u, -u.y, u.x);    \n    vec3 l = normalize(vec3(-1.3, 1.0, 0.5));\n    //vec3 l = normalize(vec3(-1.3+sin(iTime/500.)*5., 1.0+cos(iTime/5.)*5., 0.5+cos(iTime/400.)*5.));\n    l.xz = a * l.xz;\n    l.xy = a * l.xy;    \n    return l;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    // Screen coordinates.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // Radial blur factors.\n    // Falloff, as we radiate outwards.\n    float decay = 0.86; \n    // Controls the sample density, which in turn, controls the sample spread.\n    float density = 0.99; \n    // Sample weight. Decays as we radiate outwards.\n    float weight = 0.059; \n    \n    // Light offset. Kind of fake. See above.\n    vec3 l = lOff();\n    \n    // Offset texture position (uv - .5), offset again by the fake light movement.\n    // It's used to set the blur direction (a direction vector of sorts), and is used \n    // later to center the spotlight.\n    // The range is centered on zero, which allows the accumulation to spread out in\n    // all directions. Ie; It's radial.\n    vec2 tuv =  uv - vec2(0.5,0.1/*+iTime/100.*/) - l.xy*0.15;\n    \n    // Dividing the direction vector above by the sample number and a density factor\n    // which controls how far the blur spreads out. Higher density means a greater \n    // blur radius.\n    vec2 dTuv = tuv*density/SAMPLES;\n    \n    // Grabbing a portion of the initial texture sample. Higher numbers will make the\n    // scene a little clearer, but I'm going for a bit of abstraction.\n    vec4 col = texture(iChannel0, uv.xy)*0.25;\n    \n    // Jittering, to get rid of banding. Vitally important when accumulating discontinuous \n    // samples, especially when only a few layers are being used.\n    uv += dTuv*(hash(uv.xy + fract(iTime))*2. - 1.);\n    \n    // The radial blur loop. Take a texture sample, move a little in the direction of\n    // the radial direction vector (dTuv) then take another, slightly less weighted,\n    // sample, add it to the total, then repeat the process until done.\n    for(float i=0.; i < SAMPLES; i++){\n    \n        uv -= dTuv;\n        //uv.x-=0.5;\n        vec4 cola = texture(iChannel0, uv);\n        if (cola.r<1.5 && cola.r>0.1) col += ((cola*cola) *weight );\n        else col += ((cola*cola) * weight*2.0);\n        weight *= decay;\n        \n    }\n    \n    // Multiplying the final color with a spotlight centered on the focal point of the radial\n    // blur. It's a nice finishing touch... that Passion came up with. If it's a good idea,\n    // it didn't come from me. :)\n    col *= (1. - dot(tuv, tuv)*.95);\n    fragColor = col;\n    // Smoothstepping the final color, just to bring it out a bit.\n    fragColor = smoothstep(0., 0.9, col);\n        \n}\n\n","name":"Buf C","description":"","type":"buffer"}]}