{"ver":"0.1","info":{"id":"tdlfW4","date":"1588278982","viewed":161,"name":"Projet Shaders","username":"Ares13Nyx","description":"Traitement d'image d'étoiles filantes","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["project"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415\n\nmat2 rotation(float angle){\n    \n   float cosinus = cos(angle);\n   float sinus =sin(angle);\n    return mat2(cosinus, -sinus, sinus, cosinus);\n    \n}\n\nfloat etoile(vec2 gv, float flare) {\n\n    //dessiner une etoile\n      \n      //placer etoile au milieu\n      float dist = length(gv);\n      \n      //dessiner un cercle avec ses tailles\n      float cercle = .05/dist;\n    \n    \n      // rendre le cercle en etoile (ligne verticale et horizontale de etoile)\n        //le max afin deviter davoir 0 et avoir un rayonnement\n        float rayon =max(0., 1.-abs(gv.y*gv.x*1000.));\n        \n        //ajouter un rayonement\n        cercle += rayon*flare;\n    \n        //ajouter les autres rayons \n        gv *= rotation(PI/4.);\n    \n        rayon = max(0., 1.-abs(gv.x*gv.y*1000.));\n        cercle += rayon*.3*flare;\n        cercle *= smoothstep(1., .2, dist);\n      \n    return cercle;\n}\n\n//fonction de hashage\nfloat hash(vec2 p) {\n    p = fract(p*vec2(123.34, 456.21));\n    p += dot(p, p+45.32);\n    return fract(p.x*p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y;\n    \n    //clic et changement de la direction des etoiles\n\tvec2 clic = (iMouse.xy-iResolution.xy*.5)/iResolution.y;\n\n    //zoomer\n     uv *= 1.;\n    \n    vec3 col = vec3(0);\n    float t = iTime*.02;\n        \n    //definition de l'orientation des etoile\n    uv *= rotation(t);\n    \n    //changement de direction\n    uv += clic*4.;\n    \n    //les couches d'etoiles\n    for(float i=0.; i<1.; i+=1./2.){ \n        \n        vec3 col2 = vec3(0);\n        float scale = mix(20., .2, fract(i+t));\n        vec2 gv = fract(uv*scale-clic)-.5;\n        vec2 id = floor(uv*scale-clic);\n        float e;\n        \n       for(int y=-1;y<=1;y++) {\n          for(int x=-1;x<=1;x++) {\n              \n              //offs afin de ne pas avoir chaque etoile dans un box\n              vec2 offs = vec2(x, y);\n              float n = hash(id+offs);\n              float taille = fract(n*345.32);\n              \n              //à fin davoir plusieurs couleurs on applique cette combinaison de fonction\n              vec3 couleur = sin(vec3(.2, .3, .9)*fract(n*2345.2)*123.2)*.5+.5;\n              couleur = couleur*vec3(1,.25,1.+taille)+vec3(.2, .2, .1)*2.;\n              \n              //construction de etoile et son affichage \n              float e = etoile(gv-offs-vec2(n, fract(n*34.))+.5, smoothstep(.85, 1., taille));\n              col2+= e*taille*couleur;\n          }\n           \n        }\n        col += col2;\n   }\n    \n        \n       \n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}