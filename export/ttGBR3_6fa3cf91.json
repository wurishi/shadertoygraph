{"ver":"0.1","info":{"id":"ttGBR3","date":"1614747681","viewed":146,"name":"My first Shader and Ray Marcher","username":"playbyan1453","description":"My first raymarcher, just editing my old shader.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarcher","ao","softshadow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Long time ago I have no experience in glsl and learned from TheArtOfCode, you can check his profile\n// This is my first shader, i edited this because I dont like the function names and it hard to write.\n// Here : https://www.shadertoy.com/user/BigWIngs\n#define steps 1024\n#define tmax 1e2\n#define tmin 1e-4\n\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat cubeSDF(vec3 p, vec3 s) {\n    vec3 q = abs(p) - s;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat torusSDF(vec3 p, vec2 t) {\n    return length(vec2(length(p.xz) - t.x, p.y)) - t.y;\n}\n\nfloat mandelbulbSDF(vec3 p, float power) {\n    vec3 z = p;\n    float dr = 1.0;\n    float r = 0.0;\n    for(int i = 0; i < 4; i++) {\n        // convert to polar coordinates\n        float theta = acos(z.z / r);\n        float phi = atan(z.y, z.x);\n        dr = pow(sqrt(r), power - 1.0) * power * dr + 1.0;\n\n        // scale and rotate the point\n        float zr = pow(r, power);\n        theta = theta * power;\n        phi = phi * power;\n\n        // convert back to cartesian coordinates\n        z = zr*vec3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta));\n        z += p;\n\n        r = length(z);\n        if(r > 2.0) break;\n    }\n    return 0.5*log(r)*sqrt(r)/dr;\n}\n\nfloat map(vec3 p) {\n    float objectDist = sphereSDF(p, 1.0);\n    float groundDist = p.y + 1.0;\n    float d = min(objectDist, groundDist);\n    return d;\n}\n\nfloat raymarch(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    for(int i = 0; i < steps; i++) {\n        vec3 p = ro + rd * t;\n        float d = map(p);\n        t += d;\n        if(t > tmax || abs(d) < tmin) break;\n    }\n    return t;\n}\n\nvec3 normal(vec3 p) {\n    float d = map(p);\n    vec2 e = vec2(tmin, 0);\n\n    return normalize(d - \n        vec3(map(p-e.xyy),\n             map(p-e.yxy),\n             map(p-e.yyx)));\n}\n\nfloat shadow(vec3 ro, vec3 rd, float k) {\n    float res = 1.0;\n    float t = tmin;\n    for(int i = 0; i < steps; i++) {\n        float h = map(ro + rd * t);\n        res = min(res, k * h / t);\n        if(t > tmax || res < tmin) break;\n        t += h;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat ao(vec3 p) {\n    float occ = 0.0;\n    float sca = 1.0;\n    for(int i = 0; i < 5; i++) {\n        vec3 n = normal(p);\n        float h = tmin + 0.15 * float(i) / 5.0;\n        float d = map(p + h * n);\n        occ += (h - d) * sca;\n        sca *= 0.95;\n\t  }\n    return clamp(1.0 - 1.5*occ, 0.0, 1.0);\n}\n\nfloat calcLight(vec3 p, vec3 lPos) {\n    vec3 l = normalize(lPos - p); // Point light model\n    vec3 n = normal(p);\n\n    float dif = clamp(dot(n, l), 0.0, 1.0);\n    float s = shadow(p, l, 16.0);\n    dif *= s;\n\n    return dif;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2.0*fragCoord.xy-iResolution.xy)/max(iResolution.x, iResolution.y);\n    vec3 ro = vec3(0, 0,-6);\n    vec3 rd = normalize(vec3(uv, 1));\n    float d = raymarch(ro, rd);\n    vec3 p = ro + rd * d;\n\n    vec3 col = vec3(0.051);\n    if(d < tmax) {\n        vec3 lPos = vec3(3, 5, -6);\n        vec3 dir = vec3(calcLight(p, lPos)); // Diffuse\n        vec3 indir = col * ao(p); // calc indirect light, sky.\n        col = dir+indir;\n    }\n    col = pow(col, vec3(0.5));\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}