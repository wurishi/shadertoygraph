{"ver":"0.1","info":{"id":"4l23Dd","date":"1433715901","viewed":142,"name":"dsalume_sphere","username":"dsalume","description":"Basic sphere as a test\n","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define CHECKERED_SQUARE_SIZE 0.25\n#define MAX_DEPTH 2\n#define EPSILON 0.001\n\nstruct Ray\n{\n\tvec3 pos;\n    vec3 dir;\n};\n\nstruct Triangle\n{\n    vec3 a;\n    vec3 b;\n    vec3 c;\n};\n    \nstruct Sphere\n{\n \tvec3 pos;\n    float radius;\n    vec4 color;\n};\n    \nstruct Camera\n{\n\tvec3 pos;\n    vec3 forward;\n    vec3 up;\n    vec3 right;\n};\n    \nstruct DirectionalLight\n{\n  \tvec3 dir;\n    vec4 color;\n};\n    \nstruct IntersectionInfo\n{\n\tvec3 point;\n    vec3 normal;\n    vec4 color;\n};\n\nTriangle triangles[2];\nSphere sphere = Sphere(vec3(0,0,2), 0.7, vec4(1,0,0,0));\nCamera camera = Camera(vec3(0,2,-1), normalize(vec3(0,-1,1)), normalize(vec3(0,1,1)), vec3(1,0,0));\nvec4 background = vec4(0);\nDirectionalLight dirLight = DirectionalLight(vec3(0,0,1.0), vec4(1));\nvec4 ambientLight = vec4(0.2,0.2,0.2, 1.0);\n\nvoid InitTriangles()\n{\n    vec3 verts[4];\n    verts[0] = vec3(-2,-2,0);\n    verts[1] = vec3(2,-2,0);\n    verts[2] = vec3(-2,-2,4);\n    verts[3] = vec3(2,-2,4);\n    \n    triangles[0] = Triangle(verts[0], verts[1], verts[2]);\n    triangles[1] = Triangle(verts[3], verts[2], verts[1]);    \n}\n\nmat4 GetCameraTransform(Camera camera)\n{\n\tmat4 ret = mat4(\n        vec4(normalize(camera.right), 0),\n        vec4(normalize(camera.up), 0),\n        vec4(normalize(camera.forward), 0),\n        vec4(camera.pos, 1));\n    return ret;\n}\n\nvoid Lookat(in vec3 point)\n{\n    camera.forward = normalize(point - camera.pos);\n    \n    // TODO; subtract component along forward\n    //vec3\n    \n    camera.up = normalize(cross(camera.right, camera.forward));\n\tcamera.right = normalize(cross(camera.forward, camera.up));\n}\n\nfloat AngleBetween(vec3 a, vec3 b)\n{\n\tfloat angle = acos(dot(normalize(a), normalize(b)));\n    \n    return angle;\n}\n\nvoid SolveQuadratic(float a, float b, float c, out float sol1, out float sol2)\n{\n   \tfloat discriminant = pow(b,2.0) - 4.0 * a * c;\n    \n    if (discriminant < 0.0)\n    {\n    \tsol1 = sol2 = -1.0;\n        return;\n    }\n    \n \tsol1 = (-b + sqrt(discriminant))/(2.0*a);\n    sol2 = (-b + sqrt(discriminant))/(2.0*a);\n}\n\nvec4 GetSphereColor(vec3 intersectionPoint)\n{\n    vec3 distFromCenter = intersectionPoint - sphere.pos;\n \treturn\n        vec4(normalize(intersectionPoint.xy) /\n             (min(intersectionPoint.x, min(intersectionPoint.y, intersectionPoint.z))/1.0),\n             0.5+sin(intersectionPoint.x + intersectionPoint.y + intersectionPoint.z)    \n             , 1.0);\n\n/*\t\tvec4(\n             0.5+sin(distFromCenter.x + distFromCenter.y), \n             0.5+sin(distFromCenter.y * 2.0),   \n             0.8+sin(distFromCenter.x + distFromCenter.y + distFromCenter.z)    \n             , 1.0); \n*/\n}\n\nvoid RaycastBackground(Ray ray, out vec4 color)\n{\n    color = vec4(0);\n}\n\n// https://www.cs.princeton.edu/courses/archive/fall00/cs426/lectures/raycast/sld018.htm\nfloat RaycastTriangle(Ray ray, Triangle triangle, out IntersectionInfo intersection)\n{\n    vec3 ap = triangle.a - ray.pos;\n    vec3 bp = triangle.b - ray.pos;\n    vec3 cp = triangle.c - ray.pos;\n    vec3 normal = normalize(cross(triangle.b - triangle.a, triangle.c - triangle.a));\n    float d = -dot(triangle.a, normal);\n    float dist = -(dot(ray.pos, normal) + d) / dot(normal, ray.dir);\n        \n    if (dot(ray.dir, -normalize(cross(bp, ap))) < 0.0 ||\n        dot(ray.dir, -normalize(cross(cp, bp))) < 0.0 ||\n        dot(ray.dir, -normalize(cross(ap, cp))) < 0.0)\n    {\n        return -1.0;  \n    }\n    \n    intersection.normal = normal;\n    intersection.point = ray.pos + dist * ray.dir;\n    vec3 pa = intersection.point - triangle.a;\n    vec3 pc = intersection.point - triangle.c;\n    \n    float distab = dot(pa, normalize(triangle.b - triangle.a));\n    float distac = dot(pc, normalize(triangle.c - triangle.a));\n    \n    if ((mod(distab, CHECKERED_SQUARE_SIZE * 2.0) > CHECKERED_SQUARE_SIZE &&\n         mod(distac, CHECKERED_SQUARE_SIZE * 2.0) > CHECKERED_SQUARE_SIZE)\n        ||\n\t\t(mod(distab, CHECKERED_SQUARE_SIZE * 2.0) < CHECKERED_SQUARE_SIZE &&\n         mod(distac, CHECKERED_SQUARE_SIZE * 2.0) < CHECKERED_SQUARE_SIZE))\n    {\n    \tintersection.color = vec4(1);   \n    }\n    else\n    {\n    \tintersection.color = vec4(0);   \n    }\n    \n    return dist;\n}\n\nRay GetReflectedRay(Ray inRay, IntersectionInfo intersection)\n{\n\tvec3 reflectedDir = reflect(inRay.dir, intersection.normal);\n    return Ray(intersection.point + EPSILON * reflectedDir, reflectedDir);\n}\n\nfloat RaycastSphere(Ray ray, Sphere sphere, out IntersectionInfo intersection)\n{\n    vec3 sphereCenterToRayOrigin = ray.pos - sphere.pos;\n    float a = 1.0;\n    float b = 2.0*dot(sphereCenterToRayOrigin, ray.dir);\n    float c = dot(sphereCenterToRayOrigin,sphereCenterToRayOrigin) - pow(sphere.radius,2.0);\n    \n    float sol1, sol2, closeIntersection;\n    SolveQuadratic(a,b,c, sol1, sol2);\n    \n    closeIntersection = min(sol1, sol2);\n    \n    if (closeIntersection < 0.0)\n    {\n     \treturn -1.0;   \n    }\n    \n    intersection.point = ray.pos + closeIntersection * normalize(ray.dir);\n    sphere.color = GetSphereColor(intersection.point);\n    \n    intersection.normal = normalize(intersection.point-sphere.pos);\n    \n    float diffuse = clamp(dot(intersection.normal, normalize(dirLight.dir)), 0.0, 1.0);\n    float specular = pow(clamp(dot(reflect(dirLight.dir, intersection.normal), -ray.dir), 0.0, 1.0), 25.0);\n    vec4 result = sphere.color * diffuse + specular;\n    intersection.color = result + ambientLight * sphere.color;\n        \n    return closeIntersection;\n}\n\nbool RaycastSingle(Ray ray, out IntersectionInfo intersection)\n{\n    float dist = 0.0;\n    float minDist = 100.0;\n    IntersectionInfo currIntersection;\n    \n    dist = RaycastSphere(ray, sphere, currIntersection);\n    if (dist > 0.0)\n    {\n        minDist = dist;\n        intersection = currIntersection;\n    }\n   \n    for (int i = 0; i < 2; i++)\n    {\n        dist = RaycastTriangle(ray, triangles[i], currIntersection);\n        if (dist >= 0.0 && dist < minDist)\n        {\n            minDist = dist;\n            intersection = currIntersection;\n        }\n    }\n    \n    if (minDist == 100.0)\n    {\n    \treturn false;\n    }\n    \n\treturn true;\n}\n\nvec4 Raycast(Ray ray)\n{\n    Ray currentRay = ray;\n    IntersectionInfo intersection;\n    vec4 color;\n    if (RaycastSingle(ray, intersection))\n    {\n        color = intersection.color;\n    \tcurrentRay = GetReflectedRay(currentRay, intersection);\n\t\n    \tif (RaycastSingle(currentRay, intersection))\n        {\n    \t\tcolor = color + 0.1 * intersection.color;\n        }\n    }\n    else\n    {\n    \tRaycastBackground(ray, color);    \n    }\n    \n        vec4 reflectedColor;\n\tfor (int i = 0; i < MAX_DEPTH; i++)\n    {\n        //color = color + ;   \n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitTriangles();\n        \n    float animationDuration = 10.0;\n    float timeMod = mod(iTime,animationDuration);\n    float timeModPercent = timeMod / animationDuration;\n    //dirLight = DirectionalLight(normalize(vec3(timeMod-2.0, 1.0, 1.0)), vec4(1.0));\n    \n    float angleAroundSphere = timeModPercent * 2.0 * 3.14159;\n    camera.pos.x = sphere.pos.x + 4.0 * cos(angleAroundSphere);\n    camera.pos.z = sphere.pos.z + 4.0 * sin(angleAroundSphere);\n    \n//    Lookat(sphere.pos);\n    Lookat(vec3(0));\n    \n    float minResolution = min(iResolution.x, iResolution.y);\n    vec2 normalizedResolution = iResolution.xy/minResolution;\n    vec2 pixelSizeCamSpace = normalizedResolution / iResolution.xy;\n    vec3 imageCoordCamSpace = vec3(fragCoord/minResolution - (normalizedResolution / 2.0) + (pixelSizeCamSpace / 2.0), 1.0);\n\tvec3 imageCoordWorldSpace = (GetCameraTransform(camera) * vec4(imageCoordCamSpace, 1)).xyz;\n    Ray ray = Ray(camera.pos, normalize(imageCoordWorldSpace - camera.pos));\n    \n    //sphere.color = vec4(imageCoord.xy + 0.5,0.5+sin(imageCoord.x + imageCoord.y),1.0);    \n    \n    fragColor = Raycast(ray);\n}","name":"Image","description":"","type":"image"}]}