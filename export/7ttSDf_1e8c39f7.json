{"ver":"0.1","info":{"id":"7ttSDf","date":"1639933696","viewed":124,"name":"Ellipse approximated by arcs","username":"TheTurk","description":"Distance function for an ellipse where the ellipse is approximated by biarcs [url]https://www.shadertoy.com/view/sldXWl[/url].","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["distancefield","sdf","approximation","distance","curve","ellipse","arc","biarc"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float ellipse(vec2 position, float halfWidth, float halfHeight, int subdivisionLevel) {\n    position = abs(position);\n    vec2 size = vec2(halfWidth, halfHeight);\n    float startAngle = 0.0;\n    float endAngle = 3.141592 * 0.5;\n    vec2 point1 = vec2(halfWidth, 0.0);\n    vec2 point2 = vec2(0.0, halfHeight);\n    vec2 normal1 = vec2(1.0, 0.0);\n    vec2 normal2 = vec2(0.0, 1.0);\n    for (int i = 0; i < subdivisionLevel; i++) { // perform binary search to find closest segment\n        float angle = (startAngle + endAngle) * 0.5;\n        vec2 point = size * vec2(cos(angle), sin(angle)); \n        vec2 normal = point / (size * size);\n        if (dot(position - point, vec2(-normal.y, normal.x)) < 0.0) {\n            endAngle = angle;\n            point2 = point;\n            normal2 = normal;\n        } else {\n            startAngle = angle;\n            point1 = point;\n            normal1 = normal;\n        }\n    }\n    float t = dot(point2 - point1, normal2) / dot(vec2(-normal1.y, normal1.x), normal2);\n    vec2 point3 = point1 + vec2(-normal1.y, normal1.x) * t;\n    float a = length(point2 - point3);\n    float b = length(point3 - point1);\n    float c = length(point1 - point2);\n    vec2 incenter = (point1 * a + point2 * b + point3 * c) / (a + b + c);\n    vec2 midpoint1 = (point1 + incenter) * 0.5;\n    vec2 bisector1 = point1 - incenter;\n    bisector1 = vec2(-bisector1.y, bisector1.x);\n    float t1 = dot(point1 - midpoint1, vec2(-normal1.y, normal1.x)) / dot(bisector1, vec2(-normal1.y, normal1.x));\n    vec2 center1 = midpoint1 + bisector1 * t1;\n    vec2 normal3 = incenter - center1;\n    if (dot(position - center1, vec2(-normal3.y, normal3.x)) < 0.0) {\n        float radius1 = length(point1 - center1);\n        return length(position - center1) - radius1;  \n    }\n    vec2 midpoint2 = (point2 + incenter) * 0.5;\n    vec2 bisector2 = point2 - incenter;\n    bisector2 = vec2(-bisector2.y, bisector2.x);\n    float t2 = dot(point2 - midpoint2, vec2(-normal2.y, normal2.x)) / dot(bisector2, vec2(-normal2.y, normal2.x));\n    vec2 center2 = midpoint2 + bisector2 * t2;\n    float radius2 = length(point2 - center2);  \n    return length(position - center2) - radius2;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 position = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    float halfWidth = 0.6 + 0.25 * cos((iTime + 8.0) * 1.1);\n    float halfHeight = 0.26 + 0.25 * cos((iTime + 8.0) * 1.3 + 1.0); \n    int subdivisionLevel = 2;\n    float d = ellipse(position, halfWidth, halfHeight, subdivisionLevel);\n\n    // same colorization that Inigo Quilez uses in his shaders\n    vec3 color = vec3(1.0) - sign(d) * vec3(0.1, 0.4, 0.7);\n    color *= 1.0 - exp(-4.0 * abs(d));\n\tcolor *= 0.8 + 0.2 * cos(120.0 * d);\n    color = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 3.0, (abs(d) - 0.003) * iResolution.y));\n    if (iMouse.z > 0.0) {\n        vec2 mousePosition = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n        float d = ellipse(mousePosition, halfWidth, halfHeight, subdivisionLevel);\n        color = mix(color, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 3.0, abs(length(position - mousePosition) - abs(d)) * iResolution.y - 1.0));\n    }\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}