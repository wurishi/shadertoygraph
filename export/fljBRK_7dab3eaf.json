{"ver":"0.1","info":{"id":"fljBRK","date":"1652437584","viewed":133,"name":"Simple Bilateral Blur with Noise","username":"DrDesten","description":"A Simple Bilateral Blur\n\nBuffer A adds noise to the image. You can tune the noise amount using NOISE_AMOUNT.\nBilateral Blur happens in Image. Setting RADIUS to 0 will disable bilateral blur.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["blur"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define RADIUS 10\n#define SCALE 2.\n\n#define COLOR_SENSITIVITY 50.\n\nfloat sqmag(vec2 v) {\n    return dot(v,v);\n}\nfloat sqmag(vec3 v) {\n    return dot(v,v);\n}\n\nvec3 bilateralBlur(sampler2D sampler, vec2 coord) {\n    vec3 refcol = texture(sampler, coord).rgb;\n    vec3 col    = refcol;\n    \n    vec2 samplerSize = vec2(textureSize(sampler,0));\n    vec2 pixelSize   = 1. / samplerSize;\n    \n    float totalWeight = 1.;\n    for (int x = -RADIUS; x <= RADIUS; x++) {\n    for (int y = -RADIUS; y <= RADIUS; y++) {\n    \n        float gaussianWeight = exp(-sqmag(vec2(x,y)) * (1./float(RADIUS)) * 0.1);\n        vec2  offs = vec2(x,y) * pixelSize * SCALE;\n        \n        vec3 samplecol = texture(sampler, coord + offs).rgb;\n        \n        float bilateralWeight = exp(-sqmag(refcol-samplecol) * COLOR_SENSITIVITY);\n        \n        float weight = gaussianWeight * bilateralWeight;\n        col += samplecol * weight;\n        totalWeight += weight;\n\n    }\n    }\n    \n    return col / totalWeight;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 coord = fragCoord/iResolution.xy;\n    \n    vec3 col = bilateralBlur(iChannel0, coord);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float PHI     = 1.6180339887498948482045868343656381177203091798058;\n\nfloat rand(float x) {\n    return fract(sin(x * 12.9898) * 4375.5453123);\n}\nfloat rand(vec2 x) {\n    return fract(sin(x.x * 12.9898 + x.y * 78.233) * 4375.5453);\n}\n\n#define ANIMATE_NOISE\n#define COLOR_NOISE\n#define NOISE_AMOUNT 0.1\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 coord = fragCoord / iResolution.xy;\n    \n    #ifdef COLOR_NOISE\n    vec3 noise = vec3(rand(coord + 1e-3), rand(coord + vec2(0,1e-4)), rand(coord - 1e-3));\n    #else\n    vec3 noise = vec3(rand(coord * 10. - 5.));\n    #endif\n    #ifdef ANIMATE_NOISE\n    noise = fract(noise + float(iFrame) * PHI);\n    #endif\n    noise      = noise * 2. - 1.;\n    \n    \n    vec3 col = texture(iChannel0, coord).rgb;\n    col += noise * NOISE_AMOUNT;\n\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}