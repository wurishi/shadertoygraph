{"ver":"0.1","info":{"id":"csVXzz","date":"1680655119","viewed":128,"name":"Kuwahara Filter #01","username":"benjik42","description":"Here is an implementation of Kuwahara Filter !\nNext step will be to implement a directional Kuwahara Filter","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["postprocessfilterkuwahara"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // Normalized pixel coordinates (from 0 to 1)\n  \n  \n  int RADIUS = 5;\n  vec2 pos;\n  vec3 col;\n\n\n  vec3 mean[4] = vec3[4](vec3(0.,0.,0.),vec3(0.,0.,0.),vec3(0.,0.,0.),vec3(0.,0.,0.));\n  vec3 sigma[4] = vec3[4](vec3(0.,0.,0.),vec3(0.,0.,0.),vec3(0.,0.,0.),vec3(0.,0.,0.));\n\n  vec2 offsets[4] = vec2[4](vec2(-RADIUS,-RADIUS),vec2(-RADIUS,0.),vec2(0.,-RADIUS),vec2(0.,0.));\n  \n  \n  for(int i = 0;i<4;i++){\n      for(int j =0; j<= RADIUS; j++){\n          for(int k = 0;k<=RADIUS;k++){\n          \n          pos = vec2(j,k)+offsets[i];\n          vec2 uvpos = uv+pos/iResolution.xy;\n          col = vec3(texture(iChannel0, uvpos));\n          \n          mean[i] +=col;\n          sigma[i] += col*col;\n          \n          }\n      \n      }\n  \n  }\n  \n  float n = (float(RADIUS)+1.)*(float(RADIUS)+1.);\n  \n  float sigma_f;\n  \n  float min = 1.;\n  \n  \n  for(int i =0;i<4;i++){\n  \n      mean[i] /= n;\n      sigma[i] = abs(sigma[i]/n - mean[i] * mean[i]);\n      sigma_f = sigma[i].r+sigma[i].g+sigma[i].b;\n      \n      if(sigma_f< min){\n          \n          min = sigma_f;\n          col = mean[i];\n      \n      }\n      \n  \n  }\n  \n  float offset = (sin(iTime)+1.)/2.;\n  float side = floor(uv.r+offset);\n  col = mix(vec3(texture(iChannel0, uv)),col,side);\n  \n  fragColor = vec4(col,1.); // Output to screen\n}","name":"Image","description":"","type":"image"}]}