{"ver":"0.1","info":{"id":"NlGcWR","date":"1661202075","viewed":87,"name":"Fork Electromag 063","username":"Tomortiz25Shadertoy","description":"rainbow pattern\n","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["field","electromagnetic"],"hasliked":0,"parentid":"NlVyRm","parentname":"Electromagnetic Field"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Electromagnetic Field\n// I want to display the electromagnetic fields together, \n// with the colors representing the field directions.\n// ------------------------------------------\n// A coordinate system in three-dimensional space \n// consists of an origin plus three orientation axes \n// and three scaling components. \n// Corresponding to the three transformations of displacement, \n// rotation, and scaling, respectively.\n// ------------------------------------------\nstruct coord3\n{\n   vec3 ux,uy,uz; // three axial unit vectors\n};\nvec3 ccross(coord3 a,coord3 b)\n{\n    return vec3(\n        dot(a.uy,b.uz) - dot(a.uz,b.uy),\n        dot(a.uz,b.ux) - dot(a.ux,b.uz),\n        dot(a.ux,b.uy) - dot(a.uy,b.ux)\n    );\n}\n\n// ------------------------------------------\n// Dimension or Const\n// ------------------------------------------\n#define PI 3.1415926535\n#define met 1.0\n#define sec 50.0\n\n// ------------------------------------------\n// Electromagnetic Feild\n// Q = Fai + |A>\n// ------------------------------------------\nfloat Fai(vec3 p)\n{\n    float r = length(p);\n\treturn (1.0 / (r*r)); \n}\nvec3 DXYZ_Fai(vec3 p)\n{\n    float d = 0.001; \n    return vec3(\n        (Fai(p + vec3(d,0.0,0.0)) - Fai(p)) / d,\n        (Fai(p + vec3(0.0,d,0.0)) - Fai(p)) / d,\n        (Fai(p + vec3(0.0,0.0,d)) - Fai(p)) / d);\n}\nvec3 A(vec3 p, float t) {\n    float r = 0.001 + length(p.xz);\n    return vec3(0.0,1.0,0.0) * (1.0 / (r * r))*sin(t*0.5); \n}\ncoord3 DXYZ_A(vec3 p, float t){\n    coord3 c;\n    float d = 0.001;\n    c.ux = ((A(p + vec3(1.0,0.0,0.0) * d, t) - A(p, t)) / d);\n    c.uy = ((A(p + vec3(0.0,1.0,0.0) * d, t) - A(p, t)) / d);\n    c.uz = ((A(p + vec3(0.0,0.0,1.0) * d, t) - A(p, t)) / d);\n    return c;\n}\nvec3 DT_A(vec3 p, float t)\n{\n    float dt = 0.001;\n    return (A(p,t + dt) - A(p, t)) / dt; \n}\n\n// ------------------------------------------\n// Phase View\n// ------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pp = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    float eyer = 1.0;\n    float eyea = -((iMouse.x) / iResolution.x) * PI * 2.0;\n    float eyef = ((iMouse.y / iResolution.y)-0.24) * PI * 2.0;\n    \n\tvec3 cam = vec3(\n        eyer * cos(eyea) * sin(eyef),\n        eyer * cos(eyef),\n        eyer * sin(eyea) * sin(eyef));\n    \n\tvec3 front = normalize(- cam);\n\tvec3 left = normalize(cross(normalize(vec3(0.0,1,-0.01)), front));\n\tvec3 up = normalize(cross(front, left));\n\tvec3 v = normalize(front*1.5 + left*pp.x + up*pp.y);\n    \n    vec3 p = cam;\n    \n    coord3 c;\n    c.ux = vec3(1.0,0.0,0.0);\n    c.uy = vec3(0.0,1.0,0.0);\n    c.uz = vec3(0.0,0.0,1.0);\n    \n    float dt = 0.01;\n    vec3 cor1 = vec3(0.0);\n    vec3 cor2 = vec3(0.0);\n    float t = iTime;\n    for(int i = 0; i < 200; i ++)\n    {\n        float r = length(p);\n        {  \n            vec3 o = p;\n            vec3 B = ccross(c,DXYZ_A(o, t));\n            vec3 E = -(DXYZ_Fai(o)) - DT_A(o, t); \n            cor1 += (B)*0.0001;\n            cor2 += (E)*0.0001;\n        }\n        p += v * dt;\n    }\n    \n    fragColor = vec4((cos(cor1*5.0) * sin(cor2*5.0)),1.0);\n}","name":"Image","description":"","type":"image"}]}