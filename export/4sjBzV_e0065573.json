{"ver":"0.1","info":{"id":"4sjBzV","date":"1501250377","viewed":357,"name":"IrradianceMap","username":"afraidofdark","description":"Irradiance map calculator. For selected cube map calculates an irradiance map in Buf A. Then uses this map to lit the scene in Image.\nIf the render is flickering \"Reset Time\" by pressing this button |<","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["physicallybasedrendering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\tCopyRight afraidofdark\n\tLicense MIT\n*/\n\nconst float size = 128.0;\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nfloat cubeSDF(vec3 p) {\n    vec3 d = abs(p) - vec3(1.0, 1.0, 1.0);\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\nfloat sphereSDF(vec3 p) {\n    p += vec3(cos(iTime), 0.0, sin(iTime)) * 0.5;\n    return length(p / 1.4) - 1.0;\n}\n\nfloat sceneSDF(vec3 samplePoint) {\n    samplePoint += vec3(0.0, 1.0, 4.0);\n    samplePoint *= rotateX(iTime) * rotateY(iTime);\n    \n    float b = cubeSDF(samplePoint);\n    float s = sphereSDF(samplePoint);\n    return max(b, -s);\n}\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(8.0, 8.0, 7.0);  \n    \n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n\t\treturn;\n    }\n    \n    vec3 p = eye + dist * worldDir;\n    vec3 n = estimateNormal(p);\n    \n    // Map surface normal to irradiance map\n    vec2 inc = vec2(1.0 / iResolution.x, 1.0 / iResolution.y) * size;\n\tfloat dotp = dot(vec3(1.0, 0.0, 0.0), n); // x\n   \tvec3 cuben = n * 1.0 / dotp;\n    vec2 cubeCoord = (vec2(-cuben.z, cuben.y) + vec2(1.0, 1.0)) * inc * 0.5;\n    \n    float dotpt = dot(vec3(0.0, 1.0, 0.0), n); // y\n    if (dotpt > dotp)\n    {\n        dotp = dotpt;\n        \n        cuben = n * 1.0 / dotp;\n        cubeCoord = (vec2(cuben.x, -cuben.z) + vec2(1.0, 1.0)) * inc * 0.5;\n        cubeCoord.x += inc.x;\n    }\n    \n    dotpt = dot(vec3(0.0, 0.0, 1.0), n); // z\n    if (dotpt > dotp)\n    {\n        dotp = dotpt;\n                \n        cuben = n * 1.0 / dotp;\n        cubeCoord = (cuben.xy + vec2(1.0, 1.0)) * inc * 0.5;\n        cubeCoord.x += inc.x * 2.0;\n    }\n    \n    dotpt = dot(vec3(-1.0, 0.0, 0.0), n); // -x\n    if (dotpt > dotp)\n    {\n        dotp = dotpt;\n                \n        cuben = n * 1.0 / dotp;\n        cubeCoord = (cuben.zy + vec2(1.0, 1.0)) * inc * 0.5;\n        cubeCoord.y += inc.y;\n    }\n    \n    dotpt = dot(vec3(0.0, -1.0, 0.0), n); // -y\n    if (dotpt > dotp)\n    {\n        dotp = dotpt;\n                \n        cuben = n * 1.0 / dotp;\n        cubeCoord = (cuben.xz + vec2(1.0, 1.0)) * inc * 0.5;\n        cubeCoord += inc;\n    }\n    \n\tdotpt = dot(vec3(0.0, 0.0, -1.0), n); // -z\n    if (dotpt > dotp)\n    {\n        dotp = dotpt;\n                \n        cuben = n * 1.0 / dotp;\n        cubeCoord = (vec2(-cuben.x, cuben.y) + vec2(1.0, 1.0)) * inc * 0.5;\n        cubeCoord += vec2(inc.x * 2.0, inc.y);\n    }\n    \n    fragColor = texture(iChannel0, cubeCoord);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n\tCopyRight afraidofdark\n\tLicense MIT\n*/\n\n// Diffuse IRM\n\nconst float size = 128.0;\nconst float PI = 3.1415926535897932384626433832795;\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame > 1)\n       discard; // Only calculate it in first frame\n    \n    int i = int(fragCoord.x) / int(size);\n    int j = int(fragCoord.y) / int(size);\n    \n    if (i > 2 || j > 1) \n    {\n        fragColor = vec4(0.0, 0.0, 0.0, 0.1);\n        return;\n    }\n    \n    int face = i + 3 * j;\n    vec3 normal;\n    \n    vec2 vsize = vec2(size, size);\n    vec2 hsize = vsize * 0.5;\n    \n    vec2 cubeCoord = mod(fragCoord, vsize) - hsize;\n    vec2 uv = cubeCoord / hsize;\n    \n\tnormal = vec3(1.0, uv.y, -uv.x); // x\n    if (face == 1) // y\n    {\n        normal = vec3(uv.x, 1.0, -uv.y);\n    }\n    else if (face == 2) // z\n    {\n        normal = vec3(uv.x, uv.y, 1.0);\n    }\n    else if (face == 3) // -x\n    {\n        normal = vec3(-1.0, uv.y, uv.x);\n    }\n    else if (face == 4) // -y\n    {\n        normal = vec3(uv.x, -1.0, uv.y);\n    }\n    else if (face == 5) // -z\n    {\n        normal = vec3(-uv.x, uv.y, -1.0);\n    }\n    \n    normal = normalize(normal);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 right = normalize(cross(normal, up));\n    \n    int index = 0;\n    vec3 irradiance = vec3(0.0 ,0.0 ,0.0);\n    \n    for (float longi = 0.0; longi <= 90.0; longi += 3.0)\n    {\n     \tmat4 trl = rotationMatrix(right, radians(longi));\n        for (float azi = 0.0; azi <= 360.0; azi += 3.0)\n        {\n         \tmat4 tra = rotationMatrix(normal, radians(azi));\n            vec3 sampleVec = (tra * trl * vec4(normal, 1.0)).xyz;\n            irradiance += texture(iChannel0, sampleVec).rgb * cos(radians(longi)) * sin(radians(longi));\n            index++;\n        }\n    }\n\n    fragColor = vec4((PI * irradiance / float(index)), 1.0);\n    //fragColor = texture(iChannel0, normal);\n}","name":"Buffer A","description":"","type":"buffer"}]}