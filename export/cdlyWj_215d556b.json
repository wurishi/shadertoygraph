{"ver":"0.1","info":{"id":"cdlyWj","date":"1691518330","viewed":92,"name":"Raymarch Spiral [V 1.0]","username":"sagescherrytree","description":"Background is a bit blurry due to max iter = 75.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","math"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.1415;\nconst float AO_DIST = 0.5;\nconst int AO_SAMPLES = 256;\nconst float FIVETAP_K = 2.0;\nvec3 col = vec3(0.99, 0.1, 0.05) * 0.9;\n\nfloat SDF_Sphere(vec3 query, float radius ) {\n    return length(query) - radius;\n}\n\nfloat SDF_RoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat smooth_min( float a, float b, float k ) {\n    float h = max(k - abs(a - b), 0.0) / k;\n    return min(a, b) - h * h * k * 0.25;\n}\n\nfloat opUnion( float d1, float d2 ) { \n    return min(d1,d2);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}\n\nSmoothMinResult smooth_min_lerp( float a, float b, float k ) {\n    float h = max( k-abs(a-b), 0.0 )/k;\n    float m = h*h*0.5;\n    float s = m*k*0.5;\n    if(a < b) {\n        return SmoothMinResult(a-s,m);\n    }\n    return SmoothMinResult(b-s,1.0-m);\n}\n\nfloat sceneSDF(vec3 query) {\n    float d = 1000000.0;\n\n    float c = cos(-0.1 * query.z);\n    float s = sin(-0.1 * query.z);\n    // Make a rotation matrix with z direction\n    mat2 m = mat2(c, -s, s, c);\n    query = vec3(m * query.xy, query.z);\n\n    // mod 3 cell blocks\n    // Multiply by the offset\n    query = mod(query, 2.5) - 0.5 * 2.5;\n    d = smooth_min(d, SDF_Sphere(query - vec3(-0.5*cos(iTime) + 0.1, 0.0, 0.0), 0.2), 0.4);\n    d = smooth_min(d, SDF_Sphere(query - vec3(0.0, 0.0, 0.5*cos(iTime) - 0.1), 0.2), 0.4);\n    d = smooth_min(d, SDF_Sphere(query - vec3(0.0, 0.5*cos(iTime), 0.0), 0.2), 0.4);\n\n    return d;\n}\n\n\n// SDF_Based Ambient occlusion\nvoid coordinateSystem(const vec3 v1, out vec3 v2, out vec3 v3) {\n    \n    if (abs(v1.x) > abs(v1.y)) {\n        v2 = vec3(-v1.z, 0, v1.x) / length(v1.xz);\n    }\n    else {\n        v2 = vec3(0, v1.z, -v1.y) / length(v1.yz);\n    }\n    v3 = cross(v1, v2);\n}\n\nvec2 random2(vec3 p) {\n    return fract(sin(vec2(p.x, p.x + 1.0)) * vec2(43758.5453123, 22578.1459123));\n}\n\nfloat computeAO(vec3 p, vec3 n, float dist) {\n    float aoSum = 0.0;\n    // Sample a few points in the hemisphere around n at p\n    vec3 t, b;\n    // Make a tangent and bitangent vector\n    coordinateSystem(n, t, b);\n    for(int i = 0; i < AO_SAMPLES; ++i) {\n        // Generate a pair of random [0, 1] floats\n        vec2 xi = random2(p + float(i) * 203.1);\n        // Convert the xi pair to a vector in the hemisphere\n        float len = sqrt(xi.y);\n        float rx = len * cos(6.2831 * xi.x);\n        float ry = len * sin(6.2831 * xi.x);\n        float rz = sqrt(1.0 - xi.y); // z = sqrt(1 - x*x - y*y)\n        vec3 dir = vec3(rx * t + ry * b + rz * n);\n        aoSum += step(0.0, sceneSDF(p + dir * dist));\n    }\n    return aoSum / float(AO_SAMPLES);\n}\n\nfloat fiveTapAO(vec3 p, vec3 n, float k) {\n    float aoSum = 0.0;\n    for(float i = 0.0; i < 5.0; ++i) {\n        float coeff = 1.0 / pow(2.0, i);\n        aoSum += coeff * (i * AO_DIST - sceneSDF(p + n * i * AO_DIST));\n    }\n    return 1.0 - k * aoSum;\n}\n\n// Calculate normal colour\nvec3 SDF_Normal(vec3 query) {\n    vec2 epsilon = vec2(0.0, 0.001);\n    return normalize( vec3( sceneSDF(query + epsilon.yxx) - sceneSDF(query - epsilon.yxx),\n                            sceneSDF(query + epsilon.xyx) - sceneSDF(query - epsilon.xyx),\n                            sceneSDF(query + epsilon.xxy) - sceneSDF(query - epsilon.xxy)));\n}\n\n// Contains ray.origin (position in world space) + ray.direction \n// @return colour of position of intersection\n// Distance based raymarching\nvec3 raymarch(Ray ray) {\n    // Background colour\n    vec3 background = vec3(0.f);\n    vec3 colour = background;\n    vec3 query = ray.origin;\n    float totalDist = 0.0;\n    int iterations = 0;\n    float SDF;\n    for (float i = 0.0; i < MAX_ITERATIONS; i++) {\n        ++iterations;\n        SDF = sceneSDF(query) * 0.65;\n        //SDF *= fiveTapAO(query, SDF_Normal(query), AO_DIST);\n        query += ray.direction * SDF;\n        totalDist += SDF;\n        if (SDF < ISECT_EPSILON) {\n            // Inside shape\n             break;\n        }\n    }\n    if (SDF < ISECT_EPSILON) {\n        float iter_fract = float(iterations) / MAX_ITERATIONS;\n        colour = col * vec3(1.0 - iter_fract);\n        // TODO: What is meaning of divide 100?\n        float backgroundFactor = max(0.0, totalDist / 10.0);\n        colour = mix(background, colour, backgroundFactor);\n        colour = vec3(1.0) - colour * 18.0;\n    }\n    return colour;\n}\n\nvec3 camMoveOnXAxis(float t) {\n    return vec3(t, 0.0, 0.0);\n}\n\nvec3 camMoveOnYAxis(float t) {\n    return vec3(0.0, t, 0.0);\n}\n\nvec3 camMoveOnZAxis(float t)\n{\n\treturn vec3(0.0, 0.0, t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float aspect = iResolution.x / iResolution.y;\n    \n    // Make uv go [-0.5, 0.5] and scale uv.x according to aspect ratio\n    uv -= .5;\n    uv.x = aspect * uv.x;\n  \n    // Ray casting\n    \n    // 1.0 = camSpeed\n    vec3 camPos = camMoveOnZAxis(1.5 * iTime);\n    vec3 camTarget = camMoveOnZAxis(1.5 * iTime + 0.1);\n    vec3 camLook = normalize(camTarget - camPos);\n    vec3 camRight = normalize(cross(camLook, vec3(0.f, 1.f, 0.f)));\n    vec3 camUp = normalize(cross(camLook, camRight));\n    \n    // Update ray position\n    vec3 rayPos = camPos;\n    vec3 rayDir = normalize(camLook + uv.x * camRight + uv.y * camUp);\n    \n    // Can we update camPos\n    Ray ray = Ray(rayPos, rayDir);\n\n    // Time varying pixel color\n    vec3 col = raymarch(ray);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MAX_ITERATIONS 76.f\n#define T_MAX 200.f\n#define ISECT_EPSILON 0.0001\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct MarchResult {\n    // How far along the ray was our intersection found?\n    // -1 if found nothing\n    float t;\n    // How many march iterations did we take?\n    float iterations;\n};\n\nstruct SmoothMinResult {\n    float dist;\n    float material_t;\n};","name":"Common","description":"","type":"common"}]}