{"ver":"0.1","info":{"id":"3tG3WK","date":"1582406669","viewed":157,"name":"common","username":"monsterkodi","description":"experimenting with boolean operators and enjoying my new minimal modeling setup.","likes":12,"published":1,"flags":48,"usePreview":0,"tags":["sdf","boolean"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nHEADER\n\nMat[4] material = Mat[4]( \n    //  hue    sat   lum   shiny  glossy\n    Mat(HUE_G, 1.0,  0.4,  0.02,  1.0 ), \n    Mat(HUE_R, 1.0,  0.5,  0.02,  1.0 ), \n    Mat(HUE_B, 1.0,  0.6,  0.02,  1.0 ), \n    Mat(HUE_Y, 1.0,  0.5,  0.02,  1.0 )\n);\n\nfloat map(vec3 p)\n{\n    sdStart(p);\n    \n    sdFloor(vec3(0.02), -2.0);\n    \n    float rt = gl.time*30.0;\n    sdUni(4, iRange(0.0, 2.0, 1.0), sdCube(v0, iRange(2.0, 3.5, 0.5), iRange(0.1, 3.5, 0.5)));\n    sdDif(1, iRange(1.0, 0.3, 0.5), sdBox( vx*3.0, vx, rotAxisAngle(vy, vx,-rt),     vec3(1), iRange(1.0, 0.0, 0.5)));\n    sdUni(2, iRange(1.0, 0.1, 0.5), sdBox( vy*3.0,     rotAxisAngle(vx, vy,-rt), vy, vec3(1), iRange(1.0, 0.1, 0.5)));\n    sdEmb(3, iRange(0.2, 0.7, 0.5), sdBox( vz*3.0, vz, rotAxisAngle(vy, vz, rt),     vec3(1), iRange(1.0, 0.0, 0.5)));\n    sdInt(1, iRange(0.8, 0.0, 0.5), sdBox(-vx*3.0, vx, rotAxisAngle(vy, vx, rt),     vec3(1), iRange(1.0, 0.0, 0.5)));\n    sdExt(3, iRange(0.2, 0.5, 0.5), sdBox(-vz*3.0, vz, rotAxisAngle(vy, vz,-rt),     vec3(1), iRange(1.0, 0.0, 0.5)));\n    \n    sdAxes(0.1);\n    \n    return sdf.dist;\n} \n\nFOOTER","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\n 0000000   0000000   00     00  00     00   0000000   000   000    \n000       000   000  000   000  000   000  000   000  0000  000    \n000       000   000  000000000  000000000  000   000  000 0 000    \n000       000   000  000 0 000  000 0 000  000   000  000  0000    \n 0000000   0000000   000   000  000   000   0000000   000   000    \n*/\n\n#define KEYS \\\nvec4 keys(int x, int y) { return texelFetch(iChannel0, ivec2(x,y), 0); } \\\nbool keyState(int key)  { return keys(key, 2).x < 0.5; } \\\nbool keyDown(int key)   { return keys(key, 0).x > 0.5; }\n\n#define LOAD \\\nvec4 load(int x, int y) { return texelFetch(iChannel1, ivec2(x,y), 0); } \\\nvoid save(int x, int y, vec4 c) { if ((gl.ifrag.x==x) && (gl.ifrag.y==y)) gl.color=c; } \n\n// 000   000   0000000   00000000   00     00   0000000   000\n// 0000  000  000   000  000   000  000   000  000   000  000\n// 000 0 000  000   000  0000000    000000000  000000000  000\n// 000  0000  000   000  000   000  000 0 000  000   000  000\n// 000   000   0000000   000   000  000   000  000   000  0000000\n\n#define NORMAL \\\nvec3 getNormal(vec3 p)                                                   \\\n{                                                                        \\\n    gl.pass = PASS_NORMAL;                                               \\\n    vec3 n = v0;                                                         \\\n    for (int i=gl.zero; i<4; i++)                                        \\\n    {                                                                    \\\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0); \\\n        n += e*map(p+e*0.0001);                                          \\\n    }                                                                    \\\n    return normalize(n);                                                 \\\n}\n\n// 00     00   0000000   00000000    0000000  000   000\n// 000   000  000   000  000   000  000       000   000\n// 000000000  000000000  0000000    000       000000000\n// 000 0 000  000   000  000   000  000       000   000\n// 000   000  000   000  000   000   0000000  000   000\n\n#define MARCH \\\nvoid copyHit(float t, vec3 p)                          \\\n{                                                      \\\n    gl.hit.dist   = t;                                 \\\n    gl.hit.mat    = sdf.mat;                           \\\n    gl.hit.color  = sdf.color;                         \\\n    gl.hit.pos    = p;                                 \\\n    gl.hit.normal = getNormal(p);                      \\\n}                                                      \\\nvoid march(vec3 ro, vec2 uv)                           \\\n{                                                      \\\n    uv = (2.0*uv-gl.res)/gl.res.y;                     \\\n    vec3 rd = normalize(uv.x*cam.rgt + uv.y*cam.up + cam.fov*cam.dir); \\\n                                                       \\\n    gl.pass = PASS_MARCH;                              \\\n    float t = 0.0;                                     \\\n    for (int i = gl.zero; i < gl.maxSteps; i++)        \\\n    {                                                  \\\n        vec3 p = ro+t*rd;                              \\\n        float d = map(p);                              \\\n        t += d;                                        \\\n        if (d < gl.minDist) { copyHit(t, p); return; } \\\n        if (t > gl.maxDist) break;                     \\\n    }                                                  \\\n    gl.hit.mat  = NONE;                                \\\n    gl.hit.dist = gl.maxDist;                          \\\n}\n\n//  0000000  000   000   0000000   0000000     0000000   000   000\n// 000       000   000  000   000  000   000  000   000  000 0 000\n// 0000000   000000000  000000000  000   000  000   000  000000000\n//      000  000   000  000   000  000   000  000   000  000   000\n// 0000000   000   000  000   000  0000000     0000000   00     00\n\n#define SHADOW \\\nfloat shadowFade(float t, float shade)                                             \\\n{                                                                                  \\\n    shade = max(1.0-pow(1.0-t/gl.maxDist, gl.shadow.power*gl.shadow.soft), shade); \\\n    return gl.shadow.bright + shade * (1.0-gl.shadow.bright);                      \\\n}                                                                                  \\\nfloat shadow(vec3 ro, vec3 lp, vec3 n)                   \\\n{                                                        \\\n    gl.pass = PASS_SHADOW;                               \\\n                                                         \\\n    if (!opt.shadow) return 1.0;                         \\\n                                                         \\\n    ro += n*gl.minDist*2.0;                              \\\n    vec3 rd = lp-ro;                                     \\\n    float far = max(length(rd), gl.minDist);             \\\n    rd = normalize(rd);                                  \\\n                                                         \\\n    float shade = 1.0;                                   \\\n    float sd = 0.0;                                      \\\n    for (float t=float(gl.zero); t<far;)                 \\\n    {                                                    \\\n        float d = map(ro+rd*t);                          \\\n        if (d < gl.minDist) { shade = 0.0; break; }      \\\n                                                         \\\n        if (gl.shadow.soft > 0.01)                       \\\n        {                                                \\\n            float newShade = d/(t*gl.shadow.soft*0.1);   \\\n            if (newShade < shade)                        \\\n            {                                            \\\n                sd = t;                                  \\\n                shade = newShade;                        \\\n            }                                            \\\n            t += min(d, 0.1);                            \\\n        }                                                \\\n        else                                             \\\n        {                                                \\\n            t += d;                                      \\\n        }                                                \\\n    }                                                    \\\n    return shadowFade(sd, shade);                        \\\n}\n\n//  0000000    0000000   0000000  000      000   000   0000000  000   0000000   000   000  \n// 000   000  000       000       000      000   000  000       000  000   000  0000  000  \n// 000   000  000       000       000      000   000  0000000   000  000   000  000 0 000  \n// 000   000  000       000       000      000   000       000  000  000   000  000  0000  \n//  0000000    0000000   0000000  0000000   0000000   0000000   000   0000000   000   000  \n\n#define OCCLUSION \\\nfloat occlusion(vec3 p, vec3 n)                          \\\n{                                                        \\\n    if (!opt.occl) return 1.0;                           \\\n    float a = 0.0;                                       \\\n    float weight = 1.0;                                  \\\n    for (int i = gl.zero; i <= 6; i++)                   \\\n    {                                                    \\\n        float d = (float(i) / 6.0) * 0.3;                \\\n        a += weight * (d - map(p + n*d));                \\\n        weight *= 0.8;                                   \\\n    }                                                    \\\n    float f = clamp01(1.0-a);                            \\\n    return f*f;                                          \\\n}\n\n\n// 000      000   0000000   000   000  000000000\n// 000      000  000        000   000     000\n// 000      000  000  0000  000000000     000\n// 000      000  000   000  000   000     000\n// 0000000  000   0000000   000   000     000\n\n#define LIGHT \\\nvec3 calcLight(vec3 p, vec3 n)                    \\\n{                                                 \\\n    vec3 col;                                     \\\n    Mat  mat;                                     \\\n    switch (gl.hit.mat)                           \\\n    {                                             \\\n        case -2: col = gl.hit.color; break;       \\\n        case NONE:                                \\\n        {                                         \\\n           vec2   guv = gl.frag.xy - gl.res / 2.; \\\n           float  grid = dot(step(mod(guv.xyxy, vec4(10,10,100,100)), vec4(1)), vec4(.5, .5, 1, 1)); \\\n           return mix(vec3(.001), vec3(0.01,0.01,0.01), grid); \\\n        }                                                      \\\n        default:                                               \\\n        {                                                      \\\n            mat = material[gl.hit.mat-1];                      \\\n            col = hsl(mat.hue, mat.sat, mat.lum);              \\\n        }                                                      \\\n    }                                                          \\\n    col = (opt.colors) ? desat(col) : col;                     \\\n    if (opt.normal || opt.depthb)                              \\\n    {                                                          \\\n        vec3 nc = opt.normal ? gl.hit.dist >= gl.maxDist ? black : n : white;      \\\n        vec3 zc = opt.depthb ? vec3(pow(1.0-gl.hit.dist/gl.maxDist, 4.0)) : white; \\\n        col = nc*zc;                                           \\\n    }                                                          \\\n    else                                                       \\\n    {                                                          \\\n        float dl1 = dot(n,normalize(gl.light1-p));             \\\n        float dl2 = dot(n,normalize(gl.light2-p));             \\\n        float dnl = max(dl1,dl2*0.98);                         \\\n        float dif;                                             \\\n        dif  = clamp(dnl, 0.0, 1.0);                           \\\n        dif *= shadow(p, gl.light1, n);                        \\\n        dif *= occlusion(p, n);                                \\\n        dif *= pow(dnl, 1.0+mat.shiny*20.0);                   \\\n        dif  = clamp(dif, gl.ambient, 1.0);                    \\\n        col *= dif;                                            \\\n        col += pow(mat.glossy, 3.0)*vec3(pow(smoothstep(0.0+mat.glossy*0.9, 1.0, dnl), 1.0+40.0*mat.glossy)); \\\n    } \\\n    return col; \\\n}\n\n#define HEADER \\\n    KEYS       \\\n    LOAD       \\\n    PRINT\n\n#define PI   3.141592653589\n#define PI2  1.570796326795\n#define TAU  6.283185307178\n#define E    2.718281828459\n#define PHI  1.618033988750\n#define EPS  0.000000000001\n#define EPS1 1.00001\n\n#define KEY_LEFT  37\n#define KEY_UP    38\n#define KEY_RIGHT 39\n#define KEY_DOWN  40\n#define KEY_SPACE 32\n#define KEY_1     49\n#define KEY_2     50\n#define KEY_3     51\n#define KEY_4     52\n#define KEY_5     53\n#define KEY_6     54\n#define KEY_7     55\n#define KEY_8     56\n#define KEY_9     57\n#define KEY_0     58\n#define KEY_A     65\n#define KEY_B     66\n#define KEY_C     67\n#define KEY_D     68\n#define KEY_E     69\n#define KEY_F     70\n#define KEY_G     71\n#define KEY_H     72\n#define KEY_I     73\n#define KEY_J     74\n#define KEY_K     75\n#define KEY_L     76\n#define KEY_M     77\n#define KEY_N     78\n#define KEY_O     79\n#define KEY_P     80\n#define KEY_Q     81\n#define KEY_R     82\n#define KEY_S     83\n#define KEY_T     84\n#define KEY_U     85\n#define KEY_V     86\n#define KEY_W     87\n#define KEY_X     88\n#define KEY_Y     89\n#define KEY_Z     90\n#define KEY_MINUS 189\n#define KEY_EQUAL 187\n#define KEY_PGUP  33\n#define KEY_PGDN  34\n\n#define NONE         0\n\n#define PASS_MARCH   0\n#define PASS_NORMAL  1\n#define PASS_SHADOW  2\n#define PASS_AO      3\n\n#define HUE_R 0.0\n#define HUE_G 0.33\n#define HUE_B 0.67\n#define HUE_Y 0.16\n\nconst vec3 v0 = vec3(0,0,0);\nconst vec3 vx = vec3(1,0,0);\nconst vec3 vy = vec3(0,1,0);\nconst vec3 vz = vec3(0,0,1);\n\nconst vec3 red    = vec3(0.8,0.0,0.0);\nconst vec3 green  = vec3(0.0,0.5,0.0);\nconst vec3 blue   = vec3(0.2,0.2,1.0);\nconst vec3 yellow = vec3(1.0,1.0,0.0);\nconst vec3 orange = vec3(1.0,0.5,0.0);\nconst vec3 white  = vec3(1.0);\nconst vec3 gray   = vec3(0.1);\nconst vec3 black  = vec3(0.0);\n\n// 000000000  00000000  000   000  000000000\n//    000     000        000 000      000\n//    000     0000000     00000       000\n//    000     000        000 000      000\n//    000     00000000  000   000     000\n\nstruct Text {\n    ivec2 size;\n    ivec2 adv;\n} text;\n\n//  0000000   00000000   000000000\n// 000   000  000   000     000\n// 000   000  00000000      000\n// 000   000  000           000\n//  0000000   000           000\n\nstruct Opt {\n    bool axes;\n    bool info;\n    bool help;\n    bool space;\n    bool anim;\n    bool soft;\n    bool occl;\n    bool shadow;\n    bool colors;\n    bool dither;\n    bool gamma;\n    bool foggy;\n    bool rotate;\n    bool normal;\n    bool depthb;\n    bool vignette;\n} opt;\n\n#define OPTIONS \\\n    opt.rotate   =  keyState(KEY_R);      \\\n    opt.axes     =  keyState(KEY_X);      \\\n    opt.info     =  keyState(KEY_I);      \\\n    opt.help     =  keyState(KEY_H);      \\\n    opt.shadow   =  keyState(KEY_L);      \\\n    opt.occl     =  keyState(KEY_O);      \\\n    opt.dither   =  keyState(KEY_T);      \\\n    opt.gamma    =  keyState(KEY_G);      \\\n    opt.anim     =  keyState(KEY_P);      \\\n    opt.normal   = !keyState(KEY_N);      \\\n    opt.depthb   = !keyState(KEY_B);      \\\n    opt.colors   = !keyState(KEY_K);      \\\n    opt.space    = !keyState(KEY_SPACE);  \\\n    opt.foggy    =  keyState(KEY_F);      \\\n    opt.vignette =  keyState(KEY_V);\n\n//  0000000   0000000   00     00\n// 000       000   000  000   000\n// 000       000000000  000000000\n// 000       000   000  000 0 000\n//  0000000  000   000  000   000\n\nstruct Cam {\n    vec3  tgt;\n    vec3  pos;\n    vec3  pos2tgt;\n    vec3  dir;\n    vec3  up;\n    vec3  rgt;\n    float dist;\n    float fov;\n} cam;\n\n//  0000000  000   000   0000000   0000000     0000000   000   000\n// 000       000   000  000   000  000   000  000   000  000 0 000\n// 0000000   000000000  000000000  000   000  000   000  000000000\n//      000  000   000  000   000  000   000  000   000  000   000\n// 0000000   000   000  000   000  0000000     0000000   00     00\n\nstruct Shadow {\n    float soft;\n    float power;\n    float bright;\n};\n\nstruct Fog {\n    float near;\n    float far;\n    vec3  color;\n} fog;\n\n// 00     00   0000000   000000000\n// 000   000  000   000     000\n// 000000000  000000000     000\n// 000 0 000  000   000     000\n// 000   000  000   000     000\n\nstruct Mat {\n    float hue;\n    float sat;\n    float lum;\n    float shiny;\n    float glossy;\n};\n\n//  0000000  0000000    00000000\n// 000       000   000  000\n// 0000000   000   000  000000\n//      000  000   000  000\n// 0000000   0000000    000\n\nstruct SDF {\n    vec3  pos;\n    vec3  color;\n    vec3  normal;\n    float dist;\n    int   mat;\n} sdf;\n\n//  0000000   000       0000000   0000000     0000000   000\n// 000        000      000   000  000   000  000   000  000\n// 000  0000  000      000   000  0000000    000000000  000\n// 000   000  000      000   000  000   000  000   000  000\n//  0000000   0000000   0000000   0000000    000   000  0000000\n\nstruct Global {\n    vec2   uv;\n    vec3   tuv;\n    vec2   frag;\n    vec2   res;\n    vec2   mouse;\n    vec2   mp;\n    ivec2  ifrag;\n    ivec2  ires;\n    float  aspect;\n    vec4   color;\n    int    frame;\n    float  time;\n    vec3   light1;\n    vec3   light2;\n    vec3   light3;\n    vec3   rd;\n    float  ambient;\n    int    zero;\n    int    pass;\n    int    maxSteps;\n    float  minDist;\n    float  maxDist;\n    Shadow shadow;\n    SDF    hit;\n} gl;\n\n// 000  000   000  000  000000000\n// 000  0000  000  000     000\n// 000  000 0 000  000     000\n// 000  000  0000  000     000\n// 000  000   000  000     000\n\n#define INIT \\\n    OPTIONS \\\n    initGlobal(fragCoord, iResolution, iMouse, iTime, iFrame); \\\n    lookAtFrom(load(0,2).xyz, load(0,3).xyz); \\\n    gl.light2 = cam.pos-cam.rgt*5.0+cam.up*5.0;\n\nvoid initGlobal(vec2 fragCoord, vec3 resolution, vec4 mouse, float time, int frame)\n{\n    gl.maxSteps = 128;\n    gl.minDist  = 0.001;\n    gl.maxDist  = 100.0;\n\n    gl.ambient       = 0.03;\n    gl.shadow.bright = 0.6;\n    gl.shadow.power  = 4.0;\n    gl.shadow.soft   = 0.0;\n\n    gl.res    = resolution.xy;\n    gl.ires   = ivec2(gl.res);\n    gl.frag   = fragCoord;\n    gl.ifrag  = ivec2(fragCoord);\n    gl.aspect = gl.res.x / gl.res.y;\n    gl.frame  = frame;\n    gl.time   = time;\n    gl.uv     = (fragCoord+fragCoord-gl.res)/gl.res.y;\n    gl.zero   = min(frame,0);\n\n    mouse.xy = min(mouse.xy,resolution.xy);\n    if (mouse.z < 1.0)\n    {\n        if (mouse.z > -1.0)\n            gl.mouse = resolution.xy*0.5;\n        else\n            gl.mouse = mouse.xy;\n    }\n    else gl.mouse = mouse.xy;\n\n    gl.mp     = (2.0*abs(gl.mouse)-vec2(gl.res))/gl.res.y;\n\n    int tw    = clamp(gl.ires.y/64,4,64);\n    text.size = ivec2(tw,tw*2);\n    text.adv  = ivec2(text.size.x,0);\n\n    gl.light1 = (vy*2.0 + vx + vz)*10.0;\n\n    fog.color = vec3(0.002);\n    fog.near  = 0.5;\n    fog.far   = 1.0;\n\n    cam.fov = PI2;\n}\n\n#define FOOTER \\\n    NORMAL     \\\n    MARCH      \\\n    SHADOW     \\\n    OCCLUSION  \\\n    LIGHT      \\\n               \\\n    void mainImage(out vec4 fragColor, in vec2 fragCoord) \\\n    {          \\\n        INIT   \\\n        CALC   \\\n        INFO   \\\n        HELP   \\\n        POST   \\\n    }\n\nfloat iRange(float l, float h, float f) { return l+(h-l)*(opt.anim ? 1.0-(cos(gl.time*f)*0.5+0.5) : 0.0); }\nfloat iRange(float l, float h) { return iRange(l, h, 1.0); }\n\nvoid sdStart(vec3 p)\n{\n    sdf.dist  = gl.maxDist;\n    sdf.pos   = p;\n    sdf.mat   = -1;\n    sdf.color = black;\n}\n\nfloat powi(int a, int b) { return pow(float(a), float(b)); }\nfloat log10(float a) { return log(a)/log(10.0); }\nfloat clamp01(float v) { return clamp(v, 0.0, 1.0); }\nvec3  clamp01(vec3 v) { return clamp(v, 0.0, 1.0); }\n\n// 00000000   00000000   000  000   000  000000000\n// 000   000  000   000  000  0000  000     000\n// 00000000   0000000    000  000 0 000     000\n// 000        000   000  000  000  0000     000\n// 000        000   000  000  000   000     000\n\n#define PRINT \\\nfloat print(ivec2 pos, int ch)                                                  \\\n{                                                                               \\\n    pos *= text.size;                                                           \\\n    pos.y = gl.ires.y - pos.y - text.size.y;                                    \\\n    ivec2 r = gl.ifrag-pos;                                                     \\\n    bool i = r.y>0 && r.x>0 && r.x<=text.size.y && r.y<=text.size.y;            \\\n    return i ? texelFetch(iChannel2,                                            \\\n        ivec2((ch%16)*64,(1024-64-64*(ch/16)))+r*64/text.size.y,0).r : 0.0;     \\\n}                                                                               \\\n                                                                                \\\nfloat print(ivec2 pos, float v)                                                 \\\n{                                                                               \\\n    float c = 0.0;                                                              \\\n    float fv = fract(v);                                                        \\\n    v = (fv > 0.995 || fv < 0.005) ? round(v) : v;                              \\\n    float f = abs(v);                                                           \\\n    int i = (fv == 0.0) ? 1 : fract(v*10.0) == 0.0 ? -1 : -2;                   \\\n    int ch, u = max(1,int(log10(f))+1);                                         \\\n    pos.x += 6;                                                                 \\\n    for (; i <= u; i++) {                                                       \\\n        if (i == 0)     ch = 46;                                                \\\n        else if (i > 0) ch = 48+int(mod(f, powi(10,i))/powi(10,i-1));           \\\n        else            ch = 48+int(mod(f+0.005, powi(10,i+1))/powi(10,i));     \\\n        c = max(c, print(pos-ivec2(i,0), ch)); }                                \\\n    if (v < 0.0) c = max(c, print(pos-ivec2(i,0), 45));                         \\\n    return c;                                                                   \\\n}                                                                               \\\n                                                                                \\\nfloat print(ivec2 pos, vec4 v)                                                  \\\n{                                                                               \\\n    float c = 0.0;                                                              \\\n    for (int i = 0; i < 4; i++) { c = max(c, print(pos, v[i])); pos.x += 8; }   \\\n    return c;                                                                   \\\n}                                                                               \\\n                                                                                \\\nfloat print(ivec2 pos, vec3 v)                                                  \\\n{                                                                               \\\n    float c = 0.0;                                                              \\\n    for (int i = 0; i < 3; i++) { c = max(c, print(pos, v[i])); pos.x += 8; }   \\\n    return c;                                                                   \\\n}                                                                               \\\n                                                                                \\\nfloat print(ivec2 pos, vec2 v)                                                  \\\n{                                                                               \\\n    float c = 0.0;                                                              \\\n    for (int i = 0; i < 2; i++) { c = max(c, print(pos, v[i]));pos.x += 8; }    \\\n    return c;                                                                   \\\n}                                                                               \\\n                                                                                \\\nfloat print(int x, int y, float v) { return print(ivec2(x,y), v); }             \\\nfloat print(int x, int y, int v)   { return print(ivec2(x,y), float(v)); }      \\\nfloat print(int x, int y, vec4 v)  { return print(ivec2(x,y), v); }             \\\nfloat print(int x, int y, vec3 v)  { return print(ivec2(x,y), v); }             \\\nfloat print(int x, int y, vec2 v)  { return print(ivec2(x,y), v); }             \\\nfloat print(int x, int y, ivec3 v) { return print(ivec2(x,y), vec3(v)); }       \\\nfloat print(int x, int y, ivec2 v) { return print(ivec2(x,y), vec2(v)); }       \\\nfloat print(int x, int y, bool v)  { return print(ivec2(x,y), float(v)); }\n\n#define DBG(y,v) \\\n    col = mix(col, white, print(6, y, (v)));\n\n#define print4(c0,v0,c1,v1,c2,v2,c3,v3)  \\\n    vec3[4]  cs = vec3[4](c0,c1,c2,c3);  \\\n    float[4] vs = float[4](v0,v1,v2,v3); \\\n    for (int i = gl.zero; i<4; i++)      \\\n        {col = mix(col, cs[i], print(-2, y, vs[i] )); y++;}\n                \n// 000  000   000  00000000   0000000   \n// 000  0000  000  000       000   000  \n// 000  000 0 000  000000    000   000  \n// 000  000  0000  000       000   000  \n// 000  000   000  000        0000000   \n\n#define INFO \\\n    if (opt.info && gl.ifrag.x < 9*text.size.x && gl.ifrag.y > gl.ires.y-10*text.size.y) \\\n    {                                          \\\n        col *= 0.02;                           \\\n        int y = 0;                             \\\n                                               \\\n        print4(yellow, floor(iFrameRate),      \\\n               blue,   floor(iTime),           \\\n               red,    floor(iMouse.x),        \\\n               green,  floor(iMouse.y));       \\\n                                               \\\n        if (iMouse.z > 0.0)                    \\\n        {                                      \\\n            march(cam.pos, iMouse.xy);         \\\n                                               \\\n            if (gl.hit.dist < gl.maxDist)      \\\n            {                                  \\\n                y++;                           \\\n                print4(white, gl.hit.dist,     \\\n                       red,   gl.hit.pos.x,    \\\n                       green, gl.hit.pos.y,    \\\n                       blue,  gl.hit.pos.z);   \\\n            }                                  \\\n        }                                      \\\n    }                                          \n\n#define printOpt(o,k,c1,c2,c3,c4)                       \\\n    iv = int[6](k, 32, c1, c2+32, c3+32, c4+32);        \\\n    ct = o ? white : gray;                              \\\n    for (int i = gl.zero; i<6; i++)                     \\\n        col = mix(col, ct, print(ivec2(i+1,y), iv[i])); \\\n    y++\n    \n// 000   000  00000000  000      00000000   \n// 000   000  000       000      000   000  \n// 000000000  0000000   000      00000000   \n// 000   000  000       000      000        \n// 000   000  00000000  0000000  000        \n\n#define HELP \\\n    if (opt.help && gl.ifrag.x < 9*text.size.x && gl.ifrag.y <= gl.ires.y-10*text.size.y) \\\n    {                                                               \\\n        col *= 0.02;                                                \\\n        int y = 10;                                                 \\\n        vec3 ct;                                                    \\\n        int[6] iv;                                                  \\\n                                                                    \\\n        printOpt(opt.help,     KEY_H, KEY_H, KEY_E, KEY_L, KEY_P);  \\\n        printOpt(opt.info,     KEY_I, KEY_I, KEY_N, KEY_F, KEY_O);  \\\n        printOpt(opt.axes,     KEY_X, KEY_A, KEY_X, KEY_E, KEY_S);  \\\n        printOpt(opt.anim,     KEY_P, KEY_A, KEY_N, KEY_I, KEY_M);  \\\n        printOpt(opt.shadow,   KEY_L, KEY_S, KEY_H, KEY_A, KEY_D);  \\\n        printOpt(opt.occl,     KEY_O, KEY_O, KEY_C, KEY_C, KEY_L);  \\\n        printOpt(opt.dither,   KEY_T, KEY_D, KEY_I, KEY_T, KEY_H);  \\\n        printOpt(opt.gamma,    KEY_G, KEY_G, KEY_A, KEY_M, KEY_M);  \\\n        printOpt(opt.foggy,    KEY_F, KEY_F, KEY_O, KEY_G, 0);      \\\n        printOpt(opt.rotate,   KEY_R, KEY_R, KEY_O, KEY_T, 0);      \\\n        printOpt(opt.colors,   KEY_K, KEY_C, KEY_O, KEY_L, 0);      \\\n        printOpt(opt.depthb,   KEY_B, KEY_Z, KEY_B, KEY_U, KEY_F);  \\\n        printOpt(opt.normal,   KEY_N, KEY_N, KEY_O, KEY_R, KEY_M);  \\\n        printOpt(opt.vignette, KEY_V, KEY_V, KEY_I, KEY_G, KEY_N);  \\\n    }\n\n// 000   000   0000000    0000000  000   000\n// 000   000  000   000  000       000   000\n// 000000000  000000000  0000000   000000000\n// 000   000  000   000       000  000   000\n// 000   000  000   000  0000000   000   000\n\nfloat hash11(float p)\n{\n    p = fract(p * 0.1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec3 hash33(vec3 p3)\n{\n    p3 = fract(p3 * vec3(12.3,456.7,8912.3));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec3 hash31(float p)\n{\n   return hash33(vec3(p));\n}\n\nfloat hash12(vec2 p)\n{\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat gradientNoise(vec2 v)\n{\n    return fract(52.9829189 * fract(dot(v, vec2(0.06711056, 0.00583715))));\n}\n\n// 000   000   0000000  000\n// 000   000  000       000\n// 000000000  0000000   000\n// 000   000       000  000\n// 000   000  0000000   0000000\n\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvec3 hsl(float h, float s, float l) { return hsl2rgb(vec3(h,s,l)); }\n\nvec3 rgb2hsl(vec3 col)\n{\n    float minc = min( col.r, min(col.g, col.b) );\n    float maxc = max( col.r, max(col.g, col.b) );\n    vec3  mask = step(col.grr,col.rgb) * step(col.bbg,col.rgb);\n    vec3 h = mask * (vec3(0.0,2.0,4.0) + (col.gbr-col.brg)/(maxc-minc + EPS)) / 6.0;\n    return vec3( fract( 1.0 + h.x + h.y + h.z ),\n                 (maxc-minc)/(1.0-abs(minc+maxc-1.0) + EPS),\n                 (minc+maxc)*0.5);\n}\n\nvec3 setsat(vec3 col, float sat)\n{\n    vec3 h = rgb2hsl(col);\n    return hsl(h.x,sat,h.z);\n}\n\nvec3 desat(vec3 col)\n{\n    return setsat(col, 0.0);\n}\n\n// 00     00   0000000   000000000  00000000   000  000   000\n// 000   000  000   000     000     000   000  000   000 000\n// 000000000  000000000     000     0000000    000    00000\n// 000 0 000  000   000     000     000   000  000   000 000\n// 000   000  000   000     000     000   000  000  000   000\n\nmat3 alignMatrix(vec3 right, vec3 up)\n{\n    return mat3(right, up, cross(right,up));\n}\n\n// 00000000    0000000   000000000\n// 000   000  000   000     000\n// 0000000    000   000     000\n// 000   000  000   000     000\n// 000   000   0000000      000\n\nfloat rad2deg(float r) { return 180.0 * r / PI; }\nfloat deg2rad(float d) { return PI * d / 180.0; }\n\nvec3  rad2deg(vec3 v) { return 180.0 * v / PI; }\nvec3  deg2rad(vec3 v) { return PI * v / 180.0; }\n\nmat3  rotMat(vec3 u, float angle)\n{\n    float s = sin(deg2rad(angle));\n    float c = cos(deg2rad(angle));\n    float i = 1.0-c;\n\n    return mat3(\n        c+u.x*u.x*i, u.x*u.y*i-u.z*s, u.x*u.z*i+u.y*s,\n        u.y*u.x*i+u.z*s, c+u.y*u.y*i, u.y*u.z*i-u.x*s,\n        u.z*u.x*i-u.y*s, u.z*u.y*i+u.x*s, c+u.z*u.z*i\n        );\n}\n\nvec3 rotAxisAngle(vec3 position, vec3 axis, float angle)\n{\n    mat3 m = rotMat(axis, angle);\n    return m * position;\n}\n\n// 00000000    0000000   000       0000000   00000000\n// 000   000  000   000  000      000   000  000   000\n// 00000000   000   000  000      000000000  0000000\n// 000        000   000  000      000   000  000   000\n// 000         0000000   0000000  000   000  000   000\n\nvec3 polar(vec3 v)\n{\n    float radius = length(v);\n    float phi    = atan(v.y, v.x);\n    float rho    = acos(v.z/radius);\n    return vec3(phi, rho, radius);\n}\n\nvec3 unpolar(vec3 v)\n{\n    float s = sin(v.y);\n    float x = s * cos(v.x);\n    float y = s * sin(v.x);\n    float z =     cos(v.y);\n    return vec3(x, y, z)*v.z;\n}\n\nvec3 polar2(vec3 v)\n{\n    float radius = length(v);\n    float phi    = atan(v.z, v.x);\n    float rho    = acos(v.y/radius);\n    return vec3(phi, rho, radius);\n}\n\nvec3 unpolar2(vec3 v)\n{\n    float s = sin(v.y);\n    float x = s * cos(v.x);\n    float z = s * sin(v.x);\n    float y =     cos(v.y);\n    return vec3(x, y, z)*v.z;\n}\n\n//  0000000   000   000   0000000   000000000\n// 000   000  000   000  000   000     000\n// 000 00 00  000   000  000000000     000\n// 000 0000   000   000  000   000     000\n//  00000 00   0000000   000   000     000\n\nvec4 quatAxisAngle(vec3 axis, float angle)\n{\n    float half_angle = deg2rad(angle*0.5);\n    return vec4(axis*sin(half_angle), cos(half_angle));\n}\n\nvec4 quatConj(vec4 q)\n{\n    return vec4(-q.x, -q.y, -q.z, q.w);\n}\n\nvec4 quatMul(vec4 q1, vec4 q2)\n{\n    vec4 qr;\n    qr.x = (q1.w * q2.x) + (q1.x * q2.w) + (q1.y * q2.z) - (q1.z * q2.y);\n    qr.y = (q1.w * q2.y) - (q1.x * q2.z) + (q1.y * q2.w) + (q1.z * q2.x);\n    qr.z = (q1.w * q2.z) + (q1.x * q2.y) - (q1.y * q2.x) + (q1.z * q2.w);\n    qr.w = (q1.w * q2.w) - (q1.x * q2.x) - (q1.y * q2.y) - (q1.z * q2.z);\n    return qr;\n}\n\nvec3 rotAxisAngleQuat(vec3 p, vec3 axis, float angle)\n{\n    vec4 qr = quatAxisAngle(axis, angle);\n    return quatMul(quatMul(qr, vec4(p, 0)), quatConj(qr)).xyz;\n}\n\nvec3 rotRayAngle(vec3 p, vec3 ro, vec3 rd, float angle)\n{\n    return rotAxisAngle(p-ro, rd-ro, angle)+ro;\n}\n\nvec3 rotY(vec3 v, float d)\n{\n    float r = deg2rad(d);\n    float c = cos(r);\n    float s = sin(r);\n    return vec3(v.x*c+v.z*s, v.y, v.z*c+v.x*s);\n}\n\nvec3 rotX(vec3 v, float d)\n{\n    float r = deg2rad(d);\n    float c = cos(r);\n    float s = sin(r);\n    return vec3(v.x, v.y*c+v.z*s, v.z*c+v.y*s);\n}\n\nvec3 rotZ(vec3 v, float d)\n{\n    float r = deg2rad(d);\n    float c = cos(r);\n    float s = sin(r);\n    return vec3(v.x*c+v.y*s, v.y*c+v.x*s, v.z);\n}\n\n//  0000000   00000000   0000000   00     00\n// 000        000       000   000  000   000\n// 000  0000  0000000   000   000  000000000\n// 000   000  000       000   000  000 0 000\n//  0000000   00000000   0000000   000   000\n\nvec3 posOnPlane(vec3 p, vec3 a, vec3 n)\n{\n    return p-dot(p-a,n)*n;\n}\n\nvec3 posOnPlane(vec3 p, vec3 n)\n{\n    return p-dot(p,n)*n;\n}\n\nvec3 posOnRay(vec3 p, vec3 n)\n{\n    return max(0.0, dot(p, n) / dot(n, n)) * n;\n}\n\nvec3 posOnRay(vec3 ro, vec3 rd, vec3 p)\n{\n    return ro + max(0.0, dot(p - ro, rd) / dot(rd, rd)) * rd;\n}\n\nbool rayIntersectsSphere(vec3 ro, vec3 rd, vec3 ctr, float r)\n{\n    return length(posOnRay(ro, rd, ctr) - ctr) < r;\n}\n\n//  0000000   00000000\n// 000   000  000   000\n// 000   000  00000000\n// 000   000  000\n//  0000000   000\n\nfloat opUnion(float d1, float d2, float k)\n{\n    float h = clamp(0.5 + 0.5*(d2-d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) - k*h*(1.0-h);\n}\n\nfloat opDiff(float d1, float d2, float k)\n{\n    float h = clamp(0.5 - 0.5*(d2+d1)/k, 0.0, 1.0);\n    return mix(d1, -d2, h) + k*h*(1.0-h);\n}\n\nfloat opInter(float d1, float d2, float k)\n{\n\n    float h = clamp(0.5 - 0.5*(d2-d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) + k*h*(1.0-h);\n}\n\nfloat opDiff (float d1, float d2) { return opDiff (d1, d2, 0.0); }\nfloat opUnion(float d1, float d2) { return opUnion(d1, d2, 0.5); }\nfloat opInter(float d1, float d2) { return opInter(d1, d2, 0.2); }\n\nvoid sdMat(int m, float d) { if (d < sdf.dist) { sdf.dist = d; sdf.mat = m; } }\nvoid sdUni(int m, float d) { sdMat(m, opUnion(d, sdf.dist, 0.5)); }\nvoid sdDif(int m, float d) { sdMat(m, opDiff(d, sdf.dist, 0.5)); }\nvoid sdUni(int m, float f, float d) { sdMat(m, opUnion(d, sdf.dist, f)); }\nvoid sdInt(int m, float f, float d) { float md = opInter(d-f, sdf.dist, 0.0); if (md <= sdf.dist) { sdf.dist = md; sdf.mat = m; }}\nvoid sdDif(int m, float f, float d) { float md = opDiff(sdf.dist, d, f); if (md > sdf.dist) { sdf.dist = md; sdf.mat = m; }}\nvoid sdEmb(int m, float f, float d) { float md = opDiff(sdf.dist, d-f, 0.0); if (md > sdf.dist) { sdf.dist = md; sdf.mat = m; }}\nvoid sdExt(int m, float f, float d) { float md = opInter(d-f, sdf.dist-f, f); if (md <= sdf.dist) { sdf.dist = md; sdf.mat = m; }}\n\nvoid sdColor(vec3 c, float d) { if (d < sdf.dist) { sdf.dist = d; sdf.mat = -2; sdf.color = c; } }\n\n//  0000000  0000000\n// 000       000   000\n// 0000000   000   000\n//      000  000   000\n// 0000000   0000000\n\nfloat sdSphere(vec3 a, float r)\n{\n    return length(sdf.pos-a)-r;\n}\n\nfloat sdPill(vec3 a, float r, vec3 n)\n{\n    vec3 p = sdf.pos-a;\n    float d = abs(dot(normalize(n),normalize(p)));\n    float f = smoothstep(0.0, 1.3, d);\n    return length(p) - r + f * length(n);\n}\n\nfloat sdPlane(vec3 a, vec3 n)\n{\n    return dot(n, sdf.pos-a);\n}\n\nfloat sdPlane(vec3 n)\n{\n    return dot(n, sdf.pos);\n}\n\nfloat sdHalfSphere(vec3 a, vec3 n, float r, float k)\n{\n    return opInter(sdPlane(a, -n), sdSphere(a, r), k);\n}\n\nfloat sdBox(vec3 a, vec3 b, float r)\n{\n    vec3 q = abs(sdf.pos-a)-(b-r);\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdCube(vec3 a, float s, float r)\n{\n    return sdBox(a, vec3(s), r);\n}\n\nfloat sdBox(vec3 a, vec3 right, vec3 up, vec3 dim)\n{\n  vec3  q = sdf.pos-a;\n  float x = abs(dot(right, q))-dim.x;\n  float y = abs(dot(up,    q))-dim.y;\n  float z = abs(dot(cross(right,up), q))-dim.z;\n  return max(x,max(y,z));\n}\n\nfloat sdBox(vec3 a, vec3 right, vec3 up, vec3 dim, float r)\n{\n  vec3 p = sdf.pos;\n  sdf.pos -= a;\n  sdf.pos *= alignMatrix(right, up);\n  float d = sdBox(v0, dim, r);\n  sdf.pos = p;\n  return d;\n}\n\nfloat sdEllipsoid(vec3 a, vec3 r)\n{\n    vec3 p = sdf.pos-a;\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdCone(vec3 a, vec3 b, float r1, float r2)\n{\n    vec3 ab = b-a;\n    vec3 ap = sdf.pos-a;\n    float t = dot(ab,ap) / dot(ab,ab);\n    t = clamp(t, 0.0, 1.0);\n    vec3 c = a + t*ab;\n    return length(sdf.pos-c)-(t*r2+(1.0-t)*r1);\n}\n\nfloat sdLine(vec3 a, vec3 n, float r)\n{\n    vec3 p = sdf.pos-a;\n    return length(p-n*dot(p,n))-r;\n}\n\nfloat sdLine(vec2 p, vec2 a, vec2 b)\n{\n    vec2 n = b-a;\n    vec2 nc = n.yx; nc.x *= -1.0;\n    return dot(p-a,nc) <= 0.0 ? 0.0 : length((p-a)-n*dot(p-a,n)/dot(n,n));\n}\n\nfloat sdLine2(vec2 p, vec2 a, vec2 b)\n{\n    vec2 n = b-a;\n    return length((p-a)-n*dot(p-a,n)/dot(n,n));\n}\n\nfloat sdCapsule(vec3 a, vec3 b, float r)\n{\n    vec3 ab = b-a;\n    vec3 ap = sdf.pos-a;\n    float t = dot(ab,ap) / dot(ab,ab);\n    t = clamp(t, 0.0, 1.0);\n    vec3 c = a + t*ab;\n    return length(sdf.pos-c)-r;\n}\n\nfloat sdCylinder(vec3 a, vec3 b, float r, float cr)\n{\n  vec3  ba = b - a;\n  vec3  pa = sdf.pos - a;\n  float baba = dot(ba,ba);\n  float paba = dot(pa,ba);\n  float x = length(pa*baba-ba*paba) - r*baba;\n  float y = abs(paba-baba*0.5)-baba*0.5;\n  float x2 = x*x;\n  float y2 = y*y*baba;\n  float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n  return sign(d)*sqrt(abs(d))/baba - cr;\n}\n\nfloat sdHexagon(vec3 p, vec3 a, vec3 r) // r: (radius, height, bevel)\n{\n    vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p - a);\n    p.xz -= 2.0*min(dot(k.xy, p.xz), 0.0)*k.xy;\n    float hr = r.x-r.z;\n    float hh = r.y-r.z;\n    vec2 d = vec2(length(p.xz-vec2(clamp(p.x,-k.z*hr,k.z*hr), hr))*sign(p.z-hr), p.y-hh);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r.z;\n}\n\nfloat sdHexagon(vec3 a, vec3 r) // r: (radius, height, bevel)\n{\n    return sdHexagon(sdf.pos, a, r);\n}\n\nfloat sdTorus(vec3 p, vec3 a, vec3 n, float rl, float rs)\n{\n    vec3 q = p-a;\n    return length(vec2(length(posOnPlane(q, n))-rl,abs(dot(n, q))))-rs;\n}\n\nfloat sdLink(vec3 p, float le, float r1, float r2)\n{\n    vec3 q = vec3(p.x, max(abs(p.y)-le,0.0), p.z);\n    return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\nfloat sdLink(vec3 a, vec3 b, vec3 n, vec3 r, float uvz)\n{\n    vec3 ab = normalize(b-a);\n    float lab = length(ab);\n    vec3 p = sdf.pos - (b+a)*0.5; // center\n    p *= mat3(cross(n, ab), ab, n); // orientate\n    p -= vec3(0,0,clamp(p.z,-r.y, r.y)); // elongate\n    vec3 q = vec3(p.x, max(abs(p.y)-lab,0.0), p.z); // stretch up\n    float d = length(vec2(length(q.xy)-r.x,q.z)) - r.z;\n    if (d < sdf.dist && gl.pass == PASS_MARCH)\n    {\n        float uvy = abs(length(q.xy)-r.x)/r.z;\n        if (q.y == 0.0)\n            gl.tuv = vec3(fract(sign(p.x)*p.y/lab), uvy, uvz);\n        else\n            gl.tuv = vec3(fract(sign(p.x)*sign(p.y)*(1.0-acos(dot(normalize(q.xy), vec2(0,1)))/PI2)), uvy, uvz);\n    }\n    return d;\n}\n\nvoid sdAxes(float r)\n{\n    \n    if (gl.pass == PASS_SHADOW) return;\n    if (opt.axes) {\n    sdColor(red,   sdCapsule(v0, vx*gl.maxDist, r));\n    sdColor(green, sdCapsule(v0, vy*gl.maxDist, r));\n    sdColor(blue,  sdCapsule(v0, vz*gl.maxDist, r));\n    }\n}\n\nvoid sdFloor(vec3 color, float h)\n{\n    if (cam.pos.y > h) sdColor(color, sdPlane(vy*h, vy));\n}\n\n// 000   000   0000000   000   0000000  00000000\n// 0000  000  000   000  000  000       000\n// 000 0 000  000   000  000  0000000   0000000\n// 000  0000  000   000  000       000  000\n// 000   000   0000000   000  0000000   00000000\n\nfloat noise3D(in vec3 p)\n{\n    const vec3 s = vec3(7, 157, 113);\n    vec3 ip = floor(p); p -= ip;\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\n// 0000000    000   000  00     00  00000000\n// 000   000  000   000  000   000  000   000\n// 0000000    000   000  000000000  00000000\n// 000   000  000   000  000 0 000  000\n// 0000000     0000000   000   000  000\n\nfloat drawSphere(in vec3 p)\n{\n    p = fract(p)-.5; return dot(p, p);\n}\n\nfloat cellTile(in vec3 p)\n{\n    vec4 d;\n    d.x = drawSphere(p - vec3(.81, .62, .53)); p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    d.y = drawSphere(p - vec3(.39, .2,  .11)); p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n    d.z = drawSphere(p - vec3(.62, .24, .06)); p.xz = vec2(p.z-p.x, p.z + p.x)*.7071;\n    d.w = drawSphere(p - vec3(.2,  .82, .64));\n    d.xy = min(d.xz, d.yw);\n    return min(d.x, d.y)*2.66;\n}\n\nfloat bumpSurf(vec3 p, float factor)\n{\n    return 0.2*noise3D(p*15.0) - 0.05*noise3D(p*10.0/factor);\n}\n\nvec3 bumpMap(vec3 p, vec3 nor, float factor)\n{\n    const vec2 e = vec2(0.001, 0);\n    vec3 grad = (vec3(bumpSurf(p - e.xyy, factor),\n                      bumpSurf(p - e.yxy, factor),\n                      bumpSurf(p - e.yyx, factor))-bumpSurf(p, factor))/e.x;\n    grad -= nor*dot(nor, grad);\n    return normalize(nor - grad*factor * clamp01(1.0-length(cam.pos-p)/4.0));\n}\n\n//  0000000   0000000   00     00  00000000  00000000    0000000\n// 000       000   000  000   000  000       000   000  000   000\n// 000       000000000  000000000  0000000   0000000    000000000\n// 000       000   000  000 0 000  000       000   000  000   000\n//  0000000  000   000  000   000  00000000  000   000  000   000\n\nvoid lookAtFrom(vec3 tgt, vec3 pos)\n{\n    cam.tgt     = tgt;\n    cam.pos     = pos;\n    cam.pos2tgt = cam.tgt-cam.pos;\n    cam.dir     = normalize(cam.pos2tgt);\n    cam.rgt     = normalize(cross(cam.dir, vy));\n    cam.up      = normalize(cross(cam.rgt,cam.dir));\n    cam.dist    = length(cam.pos2tgt);\n}\n\nvoid lookAt  (vec3 tgt) { lookAtFrom(tgt, cam.pos); }\nvoid lookFrom(vec3 pos) { lookAtFrom(cam.tgt, pos); }\nvoid lookPan (vec3 pan) { lookAtFrom(cam.tgt+pan, cam.pos+pan); }\nvoid lookPitch(float ang) {\n    cam.pos2tgt = rotAxisAngle(cam.pos2tgt, cam.rgt, ang);\n    cam.tgt     = cam.pos + cam.pos2tgt;\n    cam.dir     = normalize(cam.pos2tgt);\n    cam.up      = normalize(cross(cam.rgt,cam.dir));\n}\n\nvoid lookZoom(float z) \n{ \n    if (z == 0.0)\n    {\n        cam.tgt = cam.pos + normalize(cam.pos2tgt)*1.0;\n        cam.pos2tgt = cam.tgt-cam.pos;\n    }\n    else\n    {\n        cam.pos2tgt -= z*normalize(cam.pos2tgt)*0.3;\n        cam.pos = cam.tgt-cam.pos2tgt;\n    }\n}\n\nvoid orbitPitch(float pitch)\n{\n    vec3 p2t = rotAxisAngle(cam.pos2tgt, cam.rgt, pitch);\n    if (abs(dot(normalize(p2t),vy)) > 0.998) return;\n    cam.pos2tgt = p2t;\n    cam.pos     = cam.tgt - cam.pos2tgt;\n    cam.dir     = normalize(cam.pos2tgt);\n    cam.up      = normalize(cross(cam.rgt,cam.dir));\n}\n\nvoid orbitYaw(float yaw)\n{\n    cam.pos2tgt = rotAxisAngle(cam.pos2tgt, vy, yaw);\n    cam.pos     = cam.tgt - cam.pos2tgt;\n    cam.dir     = normalize(cam.pos2tgt);\n    cam.rgt     = normalize(cross(cam.dir, vy));\n    cam.up      = normalize(cross(cam.rgt,cam.dir));\n}\n\nvoid orbit(float pitch, float yaw)\n{\n    orbitYaw(yaw);\n    orbitPitch(pitch);\n}\n\nvoid initCam(vec3 lookAt, float dist, float rotx, float roty)\n{\n    lookAtFrom(lookAt, rotAxisAngle(rotAxisAngle(vec3(0,0,-dist), vx, 89.0*roty), vy, 180.0*rotx));\n}\n\n// 00000000    0000000    0000000  000000000\n// 000   000  000   000  000          000\n// 00000000   000   000  0000000      000\n// 000        000   000       000     000\n// 000         0000000   0000000      000\n\nvec4 postProc(vec3 col, bool dither, bool gamma, bool vignette)\n{\n    if (dither)   col -= vec3(gradientNoise(gl.frag)/256.0);\n    if (gamma)    col  = pow(col, vec3(1.0/2.2));\n    if (vignette) col *= vec3(smoothstep(1.8, 0.5, length(gl.uv)/max(gl.aspect,1.0)));\n    return vec4(col, 1.0);\n}\n\n#define CALC \\\n    march(cam.pos, fragCoord); \\\n    vec3 col = calcLight(gl.hit.pos, gl.hit.normal); \\\n    if (opt.foggy) col = mix(col, fog.color, smoothstep(gl.maxDist*fog.near, gl.maxDist*fog.far, gl.hit.dist));\n\n#define POST \\\n    fragColor = postProc(col, opt.dither, opt.gamma && !opt.depthb, opt.vignette);\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n0000000    000   000  00000000  00000000  00000000  00000000     \n000   000  000   000  000       000       000       000   000    \n0000000    000   000  000000    000000    0000000   0000000      \n000   000  000   000  000       000       000       000   000    \n0000000     0000000   000       000       00000000  000   000    \n*/\n\nKEYS\nLOAD\n\n// 000  000   000  000  000000000  \n// 000  0000  000  000     000     \n// 000  000 0 000  000     000     \n// 000  000  0000  000     000     \n// 000  000   000  000     000     \n\nvoid initCamera()\n{    \n    initCam(v0, 12.0, 0.77, -0.3);\n    \n    save(0,2,vec4(cam.tgt,0));\n    save(0,3,vec4(cam.pos,0));\n}\n\n//  0000000   0000000   00     00  00000000  00000000    0000000   \n// 000       000   000  000   000  000       000   000  000   000  \n// 000       000000000  000000000  0000000   0000000    000000000  \n// 000       000   000  000 0 000  000       000   000  000   000  \n//  0000000  000   000  000   000  00000000  000   000  000   000  \n\nvoid calcCamera()\n{\n    vec4 d01 = load(0,1);\n    vec4 tgt = load(0,2);\n    vec4 pos = load(0,3);\n    \n    lookAtFrom(tgt.xyz,pos.xyz);\n    \n    orbit(-100.0*(d01.y), 100.0*(d01.x));\n    \n    if (opt.rotate) orbitYaw(-0.1);\n    \n    if (keyDown(KEY_LEFT))  orbitYaw(-1.0);\n    if (keyDown(KEY_RIGHT)) orbitYaw( 1.0);\n    if (keyDown(KEY_UP))    orbitPitch(-1.0);\n    if (keyDown(KEY_DOWN))  orbitPitch( 1.0);\n    \n    vec3 pan;\n    if (keyDown(KEY_W))  { if (length(cam.pos2tgt)>1.0) { lookZoom(1.0); } else { pan += 0.2*cam.dir; }}\n    if (keyDown(KEY_S))  { lookZoom(-1.0); }\n    if (keyDown(KEY_A))  { lookZoom(0.0); pan -= 0.1*cam.rgt; }\n    if (keyDown(KEY_D))  { lookZoom(0.0); pan += 0.1*cam.rgt; }\n    if (keyDown(KEY_Q))  { lookZoom(0.0); pan -= 0.1*cam.up;  }\n    if (keyDown(KEY_E))  { lookZoom(0.0); pan += 0.1*cam.up;  }\n    \n    lookPan(pan);\n    \n    if (keyDown(KEY_PGDN)) lookPan(-vy*0.1);\n    if (keyDown(KEY_PGUP)) lookPan( vy*0.1);\n    \n    save(0,2,vec4(cam.tgt, 0));\n    save(0,3,vec4(cam.pos, 0));\n}\n\n// 00     00   0000000   000  000   000  \n// 000   000  000   000  000  0000  000  \n// 000000000  000000000  000  000 0 000  \n// 000 0 000  000   000  000  000  0000  \n// 000   000  000   000  000  000   000  \n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    INIT\n\n    ivec2 mem = ivec2(fragCoord);\n    \n    if (mem.x == 0 && mem.y <= 1)\n    {\n        vec4 d00 = load(0,0);\n        \n        vec2 delta;\n        if (iMouse.z > 0.0 && d00.z > 0.0)\n        {\n            delta = gl.mp - d00.xy;\n        }\n        \n        save(0,0,vec4(gl.mp, iMouse.z, iMouse.w));\n        save(0,1,vec4(delta, 0,0));\n    }\n    else if (mem.x == 0 && mem.y <= 3)\n    {\n        if (iFrame < 1 || keyDown(KEY_C))\n        {\n            initCamera();\n        }\n        else\n        {\n            calcCamera();\n        }\n    }\n    \n    fragColor = gl.color;\n}\n","name":"Buffer A","description":"","type":"buffer"}]}