{"ver":"0.1","info":{"id":"3sVGWh","date":"1570111709","viewed":503,"name":"Paramed KIFS Fractals Example","username":"jdyerjdyer","description":"(Kaleidoscopic Iterated Function System Fractal)\nBased on Art of Code's Video (https://www.youtube.com/watch?v=il_Qg9AqQkE)\n\nFurther reading:\nhttps://en.wikipedia.org/wiki/Fractal\nhttps://en.wikibooks.org/wiki/Fractals/shadertoy","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["tutorial","fractals","kifs","practice","artofcode"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n        Copyright (c) 2019 Joshua Dyer\n\n\t\tSpecial thanks to The Art of Code (https://www.youtube.com/watch?v=il_Qg9AqQkE) for the basis of this shader.\n\n\t\tI modified it some for my own understanding and to add parameters for playing around with it.\n\t\tAny errors/bugs in the code (or comments) are my own.\n\t\tShader Variables (Params) are found at the top of mainImage. Feel free to play around with them.\n\t\tComments may or may not make 100% sense. Watch the video linked above for a better understanding of the shader.\n\n\t\tPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation\n\t\tfiles (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy,\n\t\tmodify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the\n\t\tSoftware is furnished to do so, subject to the following conditions:\n\n\t\tThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the \n\t\tSoftware.\n\n\n\t\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\n\t\tWARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n\t\tCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n\t\tARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n//Calculate normal vector.\nvec2 N(float angle) {\n    return vec2(sin(angle), cos(angle));\n}\n\n//Rotate around an arbitrary line by a given angle.\nvec2 rotate(vec2 uv, vec2 cp, float a, bool side) {\n    vec2 n = N(a * 3.14159);\n    float d = dot(uv - cp, n);\n    if (side) {\n\t    uv -= n * max(0.0, d) * 2.0;\n    } else {\n        uv -= n * min(0.0, d) * 2.0;\n    }\n    return uv;\n}\n\n//Used if needing the distance for showing the mirroring line.\nfloat dist(vec2 uv, vec2 cp, float a) {\n    vec2 n = N(a * 3.14159);\n    return dot(uv - cp, n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    /* Shader Variables */\n    int iterations = 5;//Number of fractal iterations.\n    float thickness = 2.0;//Thickness of the lines to be drawn.\n    bool mouseOn = false;//Should click dragging affect the rotation?\n    bool trippyInAndOut = true;//Should the image trip in and out over time?\n    bool trippyTexture = true;//Should the image use the texture in iChannel0, changing over time?\n    bool showUVFolding = false;//Use primary colors to show UV folding/mirroring?\n    /* End Shader Variables */\n    \n    if (iterations < 1) {\n        iterations = 1;\n    }\n    \n    if (thickness <= 0.0) {\n        thickness = 1.0;\n    }\n    \n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;//Center Origin, Remap to -0.5 to +0.5, and square using aspect ratio.\n    \n    vec2 mouse = iMouse.xy / iResolution.xy;//Useful for finding exact mirroring angles to use, just place mouse.x in place of angle\n    if (!mouseOn) {\n        mouse = vec2(1.0);//If not using mouse, lock to 1.0, 1.0 (because it is multiplied by a value below.)\n    }\n    \n\tuv *= 1.25; //Zoom out.\n    uv.y += tan((5.0 / 6.0) * 3.14159) * 0.5;// Re-Center\n    \n    vec3 col = vec3(0);//Set all black.\n    \n    uv.x = abs(uv.x);//Mirror on Y axis.\n    \n    uv = rotate(uv, vec2(0.5, 0.0), 5.0 / 6.0, true);//Rotate UV around a line passing through (0.5, 0.0) by (5.0 / 6.0) angle.\n\n    //col += smoothstep(0.01, 0.0, abs(dist(uv, vec2(0.5, 0.0), mouse.x)));//Show the mirroring line.\n   \n    float scale = 1.0;//Set initial scale.\n    uv.x += 0.5;//Shift right by 1 /2 unit.\n    for (int i = 0; i < iterations; i++) {//Loop through the number of iterations for the fractal.\n        uv *= 3.0;//Scale UV space by a factor of 3\n        scale *= 3.0;//Keep track of total scale change.\n        uv.x -= 1.5;//Shift left by 1.5 Units\n        \n        uv.x = abs(uv.x);//Mirror on Y axis\n        \n        uv.x -= 0.5;//Shift left by 1/2 Unit\n        uv = rotate(uv, vec2(0.0, 0.0), mouse.y * 2.0 / 3.0, false);//Fold to create mirrored rotated segments. (The ^ part.)\n    }\n    \n    if (trippyInAndOut) {\n        //For trippy effect.\n        uv *= cos(iTime * 0.5);\n        uv = rotate(uv, vec2(0.0, 0.0), cos(iTime), false);\n    }\n    \n    if (trippyTexture) {\n        //Very trippy effect!\n        uv /= scale;\n        col += texture(iChannel0, uv * 2.0 - iTime * 0.1).rgb;\n    } else {\n        //Calculate the color based on the distance from the line. Until now, just shifting, scaling, mirroring UV space.\n        //Remember uv space has been mirrored repeatedly to create the fractal outline. \n        //So we are only drwaing one line, but it is crumpled up.\n        float d = length(uv - vec2(clamp(uv.x, -1.0, 1.0), 0));\n        col += smoothstep(thickness / iResolution.y, 0.0, d / scale);//Smooth out and thicken the lines. and adjust based on scale.\n    }\n    \n    if (showUVFolding) {\n    \tcol.rg += uv;//Demonstrate UV space folding/mirroring.\n    }\n    \n    fragColor = vec4(col, 1.0);//Output the color.\n}","name":"Image","description":"","type":"image"}]}