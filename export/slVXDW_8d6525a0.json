{"ver":"0.1","info":{"id":"slVXDW","date":"1640942056","viewed":448,"name":"Lens flare and ghost","username":"kaki","description":"Sprite-based lens flare and ghost shader.","likes":16,"published":1,"flags":0,"usePreview":1,"tags":["2d","lens","flare","lensflare"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Using texture for noise generation\n#define USE_TEX 1\n\n#define time iTime\n\nconst float PI = 3.1415925358;\n\nfloat safety_sin( in float x ) { return sin( mod( x, PI ) ); }\n\nfloat saturate( in float x ) { return clamp( x, 0., 1. ); }\nvec3  saturate( in vec3  x ) { return clamp( x, 0., 1. ); }\n\nvec2 rotate( in vec2 p, float r )\n{\n\tfloat s = sin( r );\n\tfloat c = cos( r );\n\treturn mat2( c, -s, s, c ) * p;\n}\n\nfloat rand( in vec2 p ) { return fract( safety_sin( dot(p, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 ); }\nfloat rand( in vec2 p, in float t ) { return fract( safety_sin( dot(p, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 + t ); }\n\nfloat noise( in vec2 x )\n{\n#if USE_TEX == 0\n\tvec2 i = floor( x );\n\tvec2 f = fract( x );\n\tvec4 h;\n\t// Smooth Interpolation\n\tf = f * f * ( f * -2.0 + 3.0 );\n\t// Four corners in 2D of a tile\n\th.x = rand( i + vec2( 0., 0. ) );\n\th.y = rand( i + vec2( 1., 0. ) );\n\th.z = rand( i + vec2( 0., 1. ) );\n\th.w = rand( i + vec2( 1., 1. ) );\n\t// Mix 4 coorners percentages\n\treturn mix( mix( h.x, h.y, f.x ), mix( h.z, h.w, f.x ), f.y );\n#else\n    float tex_size = 128.0;\n    float n = texture( iChannel0, x / tex_size ).x;\n    n = saturate( pow( n, 1.5 ) * 1.2 );// modified color\n    return n;\n#endif\n}\n\nfloat noise( in vec2 x, in float t )\n{\n#if USE_TEX == 0\n\tvec2 i = floor( x );\n\tvec2 f = fract( x );\n\tvec4 h;\n\t// Smooth Interpolation\n\tf = f * f * ( f * -2.0 + 3.0 );\n\t// Four corners in 2D of a tile\n\th.x = rand( i + vec2( 0., 0. ), t );\n\th.y = rand( i + vec2( 1., 0. ), t );\n\th.z = rand( i + vec2( 0., 1. ), t );\n\th.w = rand( i + vec2( 1., 1. ), t );\n\t// Mix 4 coorners percentages\n\treturn mix( mix( h.x, h.y, f.x ), mix( h.z, h.w, f.x ), f.y );\n#else\n    vec4 seed = vec4( 12.3456, 2.3456, 3.4567, 45.6789 );\n    vec2 t2 = mod( vec2( t ) * vec2( 0.05, 30.0 ), 2.0*PI );\n    t2.x = sin( t2.x );\n    float n0 = noise( x + seed.xy - t2.x );\n    float n1 = noise( x + seed.zw + t2.x );\n    float w  = sin( noise( x ) * 2.0*PI + t2.y ) * 0.5 + 0.5;\n    float n  = mix( n0, n1, w );\n    return n;\n#endif\n}\n\nfloat sdCircle( in vec2 p, in float r )\n{\n    return length(p) - r;\n}\n\nfloat sdHexagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\nfloat star_burst( in vec2 p, in vec2 center )\n{\n    float c0 = 0.5;\n    float c1 = 2.0;\n    float c2 = 6.0;\n    float c3 = 12.0;\n    float c4 = 2.0;\n    float c5 = 6.2;\n    float c6 = 4.0;\n    float c7 = 0.1;\n    float c8 = 6.2;\n\n#if 0// test-code\n    float t  = time * 0.35;\n#else// transition by position\n    float t  = dot( center, vec2( 0.25 ) );\n#endif\n    float l  = length( p );\n    float l2 = pow( l, c0 );\n    float n0 = noise( vec2( atan(  p.y,  p.x ) * c1, l2 ) * c2, t );\n    float n1 = noise( vec2( atan( -p.y, -p.x ) * c1, l2 ) * c2, t );\n    float n  = pow( max( n0, n1 ), c3 ) * pow( saturate( 1.0 - l * c4 ), c5 );\n    n += pow( saturate( 1.0 - ( l * c6 - c7 ) ), c8 );// glare\n    return n;\n}\n\nvec3 star_burst3( in vec2 p, in vec2 center )\n{\n    p -= center;\n    vec3 col;\n    col.r = star_burst( p * 0.9, center );\n    col.g = star_burst( p * 1.0, center );\n    col.b = star_burst( p * 1.1, center );\n    return col * vec3( 2.0, 1.5, 1.0 );\n}\n\nfloat halo( in vec2 p, in vec2 center, in float r, in float offset )\n{\n    float c0 = 0.5;\n    float c1 = 32.0;\n    float c2 = 12.0;\n    float c3 = 2.0;\n    float c4 = 0.7;// 1.0 == blur\n    float c5 = 4.0;// 0.0 == like glare\n    float c6 = 5.2;\n    float c7 = 0.5;\n    float c8 = 1.5;\n    float c9 = 0.25;\n\n    float t  = dot( center, vec2( c9 ) );\n    float l  = length( p );\n    float l1 = abs( l - r );\n    float l2 = pow( l, c0 );\n    float n0 = noise( vec2( atan(  p.y,  p.x ) * c1, l2 ) * c2, t );\n    float n1 = noise( vec2( atan( -p.y, -p.x ) * c1, l2 ) * c2, t );\n    float n  = mix( pow( max( n0, n1 ), c3 ), 1.0, c4 ) * pow( saturate( 1.0 - l1 * c5 ), c6 );\n    return n * 0.2 * saturate( pow(\n        1.0 - saturate( pow( length( center ), c7 ) ),\n        ( length( p - center ) / r ) * c8\n    ) );\n}\n\nvec3 ghost3( in vec2 p, in vec2 center, float focus, in float r, in float offset )\n{\n    float shape_factor = 0.4;   // 0.0 == Circular aperture(like digital camera)\n                                // 1.0 == Six blades aperture(like old camera)\n    p -= center * offset;\n    vec2 p2 = rotate( p, 0.25 );\n    float d0 = mix( sdCircle( p2 * 0.85, r ), sdHexagon( p2 * 0.85, r ), shape_factor );\n    float d1 = mix( sdCircle( p2,        r ), sdHexagon( p2,        r ), shape_factor );\n    float d2 = mix( sdCircle( p2 * 1.15, r ), sdHexagon( p2 * 1.15, r ), shape_factor );\n    return mix(\n        vec3(\n            halo( p * 1.05, center, r, offset ),\n            halo( p * 1.0,  center, r, offset ),\n            halo( p * 0.95, center, r, offset )\n        ) * vec3( 2.0, 1.5, 1.0 ),\n        pow( saturate( 1.0 - vec3( d0, d1, d2 ) ), vec3( 200. ) ),\n        focus\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = fragCoord / iResolution.xy - 0.5;\n    p.x *= iResolution.x/iResolution.y; // fix aspect ratio\n    \n    // Light position\n    float t0 = mod( time * 1.5, 2.0*PI );\n    float t1 = mod( time * 0.4, 2.0*PI );\n    vec2 center = vec2( cos( t0 ), sin( t0 ) ) * 0.4 * ( sin( t1 ) * 0.5 + 0.5 );\n    if( iMouse.z >= .5 )\n\t{\n        vec2 mouse = iMouse.xy / iResolution.xy - 0.5;\n        mouse.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\t\tcenter = mouse.xy;\n\t}\n   \n    // Background\n#if 0// test-code\n    vec3 col = saturate( cos( vec3( 0.0, 0.5, 1.0 ) * PI + PI + time * 0.05 ) * 0.5 + 0.5 ) * 0.6;\n#else\n    vec3 col = vec3( 0.05, 0.2, 0.8 );\n#endif\n    \n    // Flare( glare + star burst )\n\tcol += star_burst3( p, center );\n    \n    // Ghost\n    col += ghost3( p, center, 0.0,  .15,   1.0  );// halo\n    col += ghost3( p, center, 0.0,  .5,   0.85/1.5 ) * 0.15;// halo\n    col += ghost3( p, center, 0.3,  .005, 0.5 /1.5 ) * vec3( 0.5, 0.1, -0.05 );\n    col += ghost3( p, center, 0.3,  .01,  0.4 /1.5 ) * vec3( 0.0, 0.5, -0.05 );\n    col += ghost3( p, center, 0.3,  .01,  0.3 /1.5 ) * vec3( 0.05, -0.05, 0.45 );\n    col += ghost3( p, center, 0.2,  .03,  -0.8 /3.5 ) * vec3( 0.5, 0.1, -0.05 );\n    col += ghost3( p, center, 0.05, .01,  -1.2 /3.5 ) * vec3( 0.0, 0.5, -0.05 );\n    col += ghost3( p, center, 0.2,  .07,  -2.0 /3.5 ) * vec3( 0.05, -0.05, 0.45 );\n    col += ghost3( p, center, 0.25, .04,  -3.15/3.5 ) * vec3( 0.0, 0.4, 0.2 );\n    col += ghost3( p, center, 0.15, .085, -3.75/3.5 ) * vec3( 0.0, 0.2, 0.05 );\n    col += ghost3( p, center, 0.05, .06,  -4.5 /3.5 ) * vec3( 0.05, -0.05, 0.45 );\n    col += ghost3( p, center, 0.20, .03,  -5.75/3.5 ) * vec3( 0.0, 0.3,  0.5 );\n    col += ghost3( p, center, 0.08, .02,  -5.95/3.5 ) * vec3( 0.05, 0.2, 0.05 );\n    col += ghost3( p, center, 0.04, .01, -6.15/3.5 ) * vec3( 0.1, -0.05, 0.65 );\n\n    // Streak\n    // (nothing)\n    \n    // Lens dust\n    // (nothing)\n\n    // Output to screen\n    col = pow( col, vec3( 1.0 / 2.2 ) );\n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}