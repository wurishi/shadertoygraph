{"ver":"0.1","info":{"id":"ssXcRs","date":"1642518827","viewed":107,"name":"Sin Wave function x vs f(x) plot","username":"bluebytes","description":"Here plot of x against f(x) & g(x)\nwhere f(x) is sin(x) g(x) is cos(x)\n\nUse this as a tool to compare function response.\n\n\n\n\n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["plotter","tool","functionsinwave"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//-----------------------------------------------------\n// Created by kapil bedarkar - 2022\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// A function plotter, with text printing support.\n// For future may be we can add support for numbers as well.\n\n/////////////////////////////////////////////////////////\n// [***] Use [PLACEHOLDER] equations for editing plot [***]  \n\n#define PI 3.1415926538\n\n    bool pixelFont2(lowp int alpha, lowp int x, lowp int y)\n    {\n        highp int Font2[] = int[](\n            0x00000000, 0x00000000, //  space\n            0x1517110e, 0x000f1017, //  0x40, @\n            0x11110a04, 0x0011111f, //  0x41, A\n            0x1e11111e, 0x001e1111, //  0x42, B\n            0x1010110e, 0x000e1110, //  0x43, C\n            0x0909091e, 0x001e0909, //  0x44, D\n            0x1c10101f, 0x001f1010, //  0x45, E\n            0x1f10101f, 0x00101010, //  0x46, F\n            0x1010110e, 0x000f1113, //  0x37, G\n            0x1f111111, 0x00111111, //  0x48, H\n            0x0404040e, 0x000e0404, //  0x49, I\n            0x0202021f, 0x000c1202, //  0x4a, J\n            0x18141211, 0x00111214, //  0x4b, K\n            0x10101010, 0x001f1010, //  0x4c, L\n            0x11151b11, 0x00111111, //  0x4d, M\n            0x15191111, 0x00111113, //  0x4e, N\n            0x1111110e, 0x000e1111, //  0x4f, O\n            0x1e11111e, 0x00101010, //  0x50, P\n            0x1111110e, 0x000d1215, //  0x51, Q\n            0x1e11111e, 0x00111214, //  0x52, R\n            0x0e10110e, 0x000e1101, //  0x53, S\n            0x0404041f, 0x00040404, //  0x54, T\n            0x11111111, 0x000e1111, //  0x55, U\n            0x11111111, 0x00040a11, //  0x56, V\n            0x15111111, 0x00111b15, //  0x57, W\n            0x040a1111, 0x0011110a, //  0x58, X\n            0x040a1111, 0x00040404, //  0x59, Y\n            0x0402011f, 0x001f1008, //  0x5a, Z\n            0x0808080e, 0x000e0808, //  0x5b, [\n            0x04081010, 0x00010102, //  0x5c, \\\n            0x0202020e, 0x000e0202, //  0x5d, ]\n            0x00110a04, 0x00000000, //  0x5e, ^\n            0x00000000, 0x001f0000  //  0x5f, _\n        );\n        y = 7 - y;\n        x = 7 - x;\n        return bool(Font2[alpha * 2 + y/4] & (1 << (x + (y * 8))));\n    }\n\n \n    // See Array Font2[]\n    // Returns true if pixel is modified\n    bool print_string(int stroffsetx, int stroffsety, int string[10], int fontSize, out vec4 oFragColor)\n    {\n        ivec2 xycoord = ivec2(gl_FragCoord.xy);\n\n        // Downscale coordinates for upscaling effect.\n        xycoord /= fontSize;\n        stroffsetx /= fontSize;\n        stroffsety /= fontSize;\n\n        if ((xycoord.x >= stroffsetx) &&\n            (xycoord.x < (stroffsetx + 10 * 8)) &&\n            (xycoord.y >= stroffsety) &&\n            (xycoord.y < (stroffsety + 8)))\n        {\n            int alpha = (xycoord.x - stroffsetx)/8;\n            int xpos = (xycoord.x - stroffsetx) % 8;\n            if (pixelFont2(string[alpha], xpos , xycoord.y - stroffsety))\n            {\n                oFragColor = vec4(255, 255, 255, 200)/ 255.;\n                return true;\n            }\n        }\n        return false;\n    }\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\tint string0[] = int[] (7, 22, 15, 4, 21,  10,  16,  15, 20, 0);\n        int string1[] = int[] (26,  0, 6,  18,  0, 20,  10, 15, 0, 25);\n        int string2[] = int[] (26,  0, 6,  18,  0, 4,  16, 20, 0, 25);\n\n        if (print_string(100, 400, string0, 2, fragColor))\n            return;\n        if (print_string(100, 380, string1, 2, fragColor))\n            return;\n        if (print_string(100, 360, string2, 2, fragColor))\n            return;\n            \n    // Normalized pixel coordinates (from 2 to -2) \n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n\n    uv *= 4.;\n\n    // Time varying pixel color\n    int a;\n    vec3 col;\n    float gridX = fract(uv.x);\n    float gridY = fract(uv.y);\n    \n    col = (abs(gridX) < 0.003 || abs(gridX) > 0.99)? vec3(.2) : vec3(0);\n    col = (abs(gridY) < 0.003 || abs(gridY) > 0.99)? vec3(.2) : col;\n    col = (abs(uv.x) < 0.005)? vec3(.8) : col;\n    col = (abs(uv.y) < 0.005)? vec3(.8) : col;\n    \n    \n    \n    \n    /////////////////////////////////////////////////////////////////////////\n    //  [PLACEHOLDER]  Equation to edit:\n    /////////////////////////////////////////////////////////////////////////\n    \n    float fX = log2(exp2(uv.x));  /// Green plot\n    float gX = exp2(uv.x);   /// Red plot\n    float hX = log2(uv.x);   /// Yellow plot\n    float kX = - exp2(log2(uv.x));  /// Pink plot\n    \n    \n    \n    \n    /////////////////////////////////////////////////////////////////////////\n    // Try few more\n\n    // float fX = smoothstep(1., 0., uv.x);\n    // float gX = smoothstep(0., 1., uv.x);\n    // float fX = smoothstep(2., 1., uv.x);\n    // float gX = smoothstep(1., 2., uv.x);\n    \n    \n    \n    \n    ////////////////////////////////////////////////////////////////////////\n\n    // Thanks to @elenzil -for this anti-aliazing magic\n    col = mix(col, vec3(0, 1, 0), smoothstep(4./iResolution.y, 0.0, abs(uv.y - fX) - 0.005));\n    col = mix(col, vec3(1, 0, 0), smoothstep(4./iResolution.y, 0.0, abs(uv.y - gX) - 0.005));\n    col = mix(col, vec3(1, 1, 0), smoothstep(4./iResolution.y, 0.0, abs(uv.y - hX) - 0.005));\n    col = mix(col, vec3(1, 0, 1), smoothstep(4./iResolution.y, 0.0, abs(uv.y - kX) - 0.005));\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}