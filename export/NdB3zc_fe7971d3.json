{"ver":"0.1","info":{"id":"NdB3zc","date":"1674504480","viewed":51,"name":"Додэкаэдр","username":"mishapankin","description":"raytracing","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 sun = normalize(vec3(3, 1, 1));\nvec3 cam_pos = vec3(-11, 0, 0.0);\nfloat refrKoeff = 0.9;\nfloat eps = 0.01;\nfloat floor_z = -4.1;\nfloat floor_rad = 2.0;\n\nfloat PI = acos(0.0);\n\nstruct Triag {\n  vec3 p1, p2, p3;\n};\n\nvec3[20] vert_list = vec3[20](\n  vec3(0.5, -1.30901694297790528, 0),\n  vec3(0.80901700258255008, -0.80901700258255008, 0.80901700258255008),\n  vec3(-0.5, -1.30901694297790528, 0),\n  vec3(0, -0.5, 1.30901694297790528),\n  vec3(-0.80901700258255008, -0.80901700258255008, 0.80901700258255008),\n  vec3(-0.80901700258255008, -0.80901700258255008, -0.80901700258255008),\n  vec3(0, -0.5, -1.30901694297790528),\n  vec3(0.80901700258255008, -0.80901700258255008, -0.80901700258255008),\n  vec3(1.30901694297790528, 0, -0.5),\n  vec3(1.30901694297790528, 0, 0.5),\n  vec3(0, 0.5, -1.30901694297790528),\n  vec3(0.80901700258255008, 0.80901700258255008, -0.80901700258255008),\n  vec3(0, 0.5, 1.30901694297790528),\n  vec3(0.80901700258255008, 0.80901700258255008, 0.80901700258255008),\n  vec3(-0.5, 1.30901694297790528, 0),\n  vec3(0.5, 1.30901694297790528, 0),\n  vec3(-0.80901700258255008, 0.80901700258255008, -0.80901700258255008),\n  vec3(-1.30901694297790528, 0, -0.5),\n  vec3(-1.30901694297790528, 0, 0.5),\n  vec3(-0.80901700258255008, 0.80901700258255008, 0.80901700258255008)\n);\n\nint[108] triag_list = int[](\n  1, 2, 3,\n  2, 4, 3,\n  4, 5, 3,\n  3, 6, 7,\n  7, 8, 1,\n  1, 3, 7,\n  8, 9, 1,\n  9, 10, 1,\n  10, 2, 1,\n  9, 8, 7,\n  7, 11, 9,\n  11, 12, 9,\n  13, 4, 2,\n  2, 10, 13,\n  10, 14, 13,\n  15, 16, 12,\n  12, 11, 15,\n  11, 17, 15,\n  18, 19, 15,\n  18, 15, 17,\n  19, 20, 15,\n  11, 7, 6,\n  6, 18, 11,\n  18, 17, 11,\n  3, 5, 19,\n  19, 18, 6,\n  6, 3, 19,\n  12, 16, 10,\n  12, 10, 9,\n  16, 14, 10,\n  13, 14, 16,\n  16, 15, 13,\n  15, 20, 13,\n  19, 5, 4,\n  4, 13, 19,\n  13, 20, 19\n);\n\nfloat noise(vec3 p) //Thx to Las^Mercury\n{\n\tvec3 i = floor(p);\n\tvec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\n\tvec3 f = cos((p-i)*acos(-1.))*(-.5)+.5;\n\ta = mix(sin(cos(a)*a),sin(cos(1.+a)*(1.+a)), f.x);\n\ta.xy = mix(a.xz, a.yw, f.y);\n\treturn mix(a.x, a.y, f.z);\n}\n\nfloat sphere(vec3 p, vec4 spr)\n{\n\treturn length(spr.xyz-p) - spr.w;\n}\n\nfloat flame(vec3 p)\n{\n\tfloat d = sphere(p*vec3(1.,.5,1.), vec4(0.0,0.0,0.0,1.));\n\treturn d + (noise(p+vec3(.0,iTime*2.,.0)) + noise(p*3.)*.5)*.25*(p.y) ;\n}\n\nfloat scene(vec3 p)\n{\n\treturn min(100.-length(p) , abs(flame(p)) );\n}\n\nvec3 raymarch(vec3 org, vec3 dir)\n{\n\tfloat d = 0.0, glow = 0.0, eps = 0.02;\n\tvec3  p = org;\n\tbool glowed = false;\n\t\n\tfor(int i=0; i<64; i++)\n\t{\n\t\td = scene(p) + eps;\n\t\tp += d * dir;\n\t\tif( d>eps )\n\t\t{\n\t\t\tif(flame(p) < .0)\n\t\t\t\tglowed=true;\n\t\t\tif(glowed)\n       \t\t\tglow = float(i)/64.;\n\t\t}\n\t}\n\t\n\tvec4 col = mix(vec4(1.,.5,.1,1.), vec4(0.1,.5,1.,1.), p.y*.02+.4);\n\t\n\treturn mix(vec4(0.), col, pow(glow*2.,4.)).xyz;\n}\n\nint seed = 0;\n\nfloat rand() {\n    seed = seed * 16807 % 2147483647;\n    return float(seed - 1) / 2147483646.0;\n}\n\n\nbool intersect(vec3 s, vec3 u, Triag t, out float a, out vec3 p, out vec3 n) {\n  mat3 m1, m2;\n  m1[0] = s - t.p1;\n  m1[1] = t.p2 - t.p1;\n  m1[2] = t.p3 - t.p1;\n\n  m2[0] = u;\n  m2[1] = t.p2 - t.p1;\n  m2[2] = t.p3 - t.p1;\n\n  float denom = determinant(m2);\n  if (abs(denom) < 0.0) { return true; }\n  a = -determinant(m1) / denom;\n\n  p = u * a + s;\n\n  if (a < 1e-4) {\n    return false;\n  }\n  \n  vec3 v1 = cross(p - t.p1, t.p2 - t.p1);\n  vec3 v2 = cross(p - t.p2, t.p3 - t.p2);\n  vec3 v3 = cross(p - t.p3, t.p1 - t.p3);\n\n  if (dot(v1, v2) < 0.0 || dot(v1, v3) < 0.0) {\n    return false;\n  }\n\n  n = normalize(cross(t.p2 - t.p1, t.p3 - t.p1));\n\n  return true;\n}\n\nbool intersectSphere(vec3 s, vec3 u, vec3 v, float r, out vec3 p, out vec3 n) {\n    float a = dot(u, u);\n    float b = 2.0 * dot(u, s - v);\n    float c = dot(s - v, s - v) - r * r;\n    float D = b * b - 4.0 * a * c;\n    \n    if (D >= 0.0) {\n        float t = (-b - sqrt(D)) / (2.0 * a);\n        if (t < 0.1) {\n            t = (-b + sqrt(D)) / (2.0 * a);\n        }\n        p = u * t + s;\n        n = normalize(p - v);\n        return true;\n    }\n    return false;\n}\n\nbool intersectFig(vec3 s, vec3 u, out float a, out vec3 p, out vec3 n) {\n  a = 1e9;\n  bool b = false;\n  for (int i = 0; i < 36; ++i) {\n    vec3 t1 = vert_list[triag_list[i * 3 + 0] - 1] * 3.0;\n    vec3 t2 = vert_list[triag_list[i * 3 + 1] - 1] * 3.0;\n    vec3 t3 = vert_list[triag_list[i * 3 + 2] - 1] * 3.0;\n    Triag t = Triag(t1, t2, t3);\n    vec3 p1, n1;\n    float a1;\n    if (intersect(s, u, t, a1, p1, n1) && a1 < a) {\n      a = a1;\n      p = p1;\n      n = n1;\n      b = true;\n    }\n  }\n\n  if (dot(p, n) < 0.0) {\n    n = -n;\n  }\n  return b;\n}\n\nbool intersectBase(vec3 s, vec3 u, out vec3 p, out vec3 n) {\n    float a = dot(u.xy, u.xy);\n    float b = 2.0 * dot(s.xy, u.xy);\n    float c = dot(s.xy, s.xy) - floor_rad * floor_rad;\n    \n    float D = b * b - 4.0 * a * c;\n    if (D >= 0.0) {\n        float t = (-b - sqrt(D)) / (2.0 * a);\n        p = s + u * t;\n        n = normalize(vec3(p.xy, 0));\n        if (p.z > floor_z) {\n            return false;\n        }\n        return true;\n    }\n    return false;\n}\n\nbool intersectBaseCircle(vec3 s, vec3 u, out vec3 p, out vec3 n) {\n    float t = (floor_z - s.z) / u.z;\n    p = s + u * t;\n    \n    if (distance(p, vec3(0, 0, floor_z)) <= floor_rad) {\n        return true;\n    }\n    return false;\n}\n\nbool getFloorColor(vec3 s, vec3 u, out float a, out vec3 p, out vec3 n, out vec3 color) {\n  a = -s.z / u.z;\n  if (a < 0.0) {\n    return false;\n  }\n  p = s + u * a;\n  n = vec3(0, 0, 1);\n  color = vec3(0.7, 0.7, 0.7);\n  if ((int(floor(p.x)) + int(floor(p.y))) % 2 == 0) {\n    color = vec3(1, 1, 1);\n  }\n  return true;\n}\n\nvec3 getEnvColor(vec3 s, vec3 u) {\n  float a;\n  vec3 n, p;\n  if (intersectBaseCircle(s, u, p, n)) {\n      return texture(iChannel2, p.xy).xyz;\n  }\n  if (intersectBase(s, u, p, n)) {\n      float y = (atan(p.y, p.x) + PI / 2.0) / PI;\n      return texture(iChannel1, 2.0 * vec2(p.z, y)).xyz;\n  }\n  if (intersectSphere(s, u, vec3(2.0, 0.0, 4.8), 0.7, p, n)) {\n      return vec3(1, 1, 1);\n  }\n  if (intersectSphere(s, u, vec3(1.0, 2.0, 4.8), 0.7, p, n)) {\n      return vec3(1, 1, 1);\n  }\n  return texture(iChannel0, u.xzy).xyz;\n}\n\nvec3 raytrace(vec3 s, vec3 u) {\n  float a;\n  vec3 p, n;\n\n  if (intersectFig(s, u, a, p, n)) {\n    s = p;\n    vec3 res = getEnvColor(s, reflect(u, n));\n    float R0 = ((1.0 - refrKoeff) / (1.0 + refrKoeff));\n    R0 *= R0;\n    float R = R0 + (1.0 - R0) * pow(1.0 + dot(normalize(u), n), 5.0);\n    u = refract(u, n, refrKoeff);\n\n    vec3 br = raymarch(p.yzx, u.yzx);\n\n    if (intersectFig(s, u, a, p, n)) {\n        float l = pow(0.93, distance(s, p));\n        \n        vec3 cl = vec3(1, 0.5, 0);\n        \n        s = p;\n        vec3 u1 = refract(u, -n, 1.0 / refrKoeff);\n        vec3 color = vec3(0, 0, 0);\n        if (dot(u1, n) > 0.0) {\n          color = getEnvColor(s, u1);\n        } else {\n            color = vec3(0, 0, 0);\n        }\n        res = R * res + (1.0 - R) * (color + br) * l;\n    }\n    return clamp(res, 0.0, 1.0);\n  }\n\n  return getEnvColor(s, u);\n}\n\nvec4 getColor(vec2 coords) {\n  vec3 col = vec3(0, 0, 0);\n\n  float alpha1 = iMouse.x / iResolution.x * acos(-1.0) * 1.5;\n  float alpha2 = mix(-0.3, 0.3, iMouse.y / iResolution.y) * acos(0.0);\n  \n  mat3 rot1 = mat3(\n    vec3(cos(alpha1), sin(alpha1), 0),\n    vec3(-sin(alpha1), cos(alpha1), 0),\n    vec3(0, 0, 1)\n  );\n  mat3 rot2 = mat3(\n    vec3(cos(alpha2), 0, sin(alpha2)),\n    vec3(0, 1, 0),\n    vec3(-sin(alpha2), 0, cos(alpha2))\n  );\n\n  mat3 rot = rot1 * rot2;\n\n  vec3 s = vec3(0, 0.09 * (rand() - 0.5), 0.09 * (rand() - 0.5));\n  float f = length(cam_pos) + 1.0;\n  vec3 u = normalize(vec3(f, coords * f * 0.6) - s);\n\n  s += rot * cam_pos;\n  u = rot * u;\n  col = raytrace(s, u);\n\n  col.x = pow(col.x, 2.2);\n  col.y = pow(col.y, 2.2);\n  col.z = pow(col.z, 2.2);\n  return vec4(col, 1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    float d = 1.0 / iResolution.y;\n    fragColor = vec4(0.0,0.0,0.0,0.0);\n\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            fragColor += getColor(uv + vec2(i, j) * d) / 9.0;\n        }\n    }\n    \n}","name":"Image","description":"","type":"image"}]}