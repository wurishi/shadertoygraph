{"ver":"0.1","info":{"id":"tsyBWD","date":"1607122449","viewed":1028,"name":"FMS_Cat @ Shader Royale #2","username":"FMS_Cat","description":"Twitch archive: https://www.twitch.tv/videos/825604155\nMy perspective (youtube): https://www.youtube.com/watch?v=qR1iq2bkvSU","likes":41,"published":1,"flags":0,"usePreview":1,"tags":["3d","livecoding"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// FMS_Cat!!\n// Since it's written in the shader royale compo,\n// the code is a total mess that is not intended to be read.\n// I heard the compo machine is not a beast enough\n// so I made this less intensive a bit.\n// I'm publishing this as-is (for now at least). I might add some comments later.\n\n// Shoutouts to tdhooper!\n// I've referenced the Geodesic shader a lot to put hexagon on the icosahedron nicely.\n// https://www.shadertoy.com/view/llVXRd\n\n// Hexagon tiling is based on My existing shader\n// https://www.shadertoy.com/view/WlG3R1\n\n#define PI 3.14159265\n#define saturate(x) clamp(x,0.,1.)\n#define linearstep(a,b,t) ( saturate( ( (t)-(a) ) / ( (b)-(a) ) ) )\n#define lofi(i,j) ( floor( (i) / (j) ) * (j) )\n\nfloat time;\nfloat seed;\n\nfloat fractSin(float t){\n  return fract(sin(t*114.514)*1919.810);\n}\n\nfloat random(){\n  seed=fractSin(seed);\n  return seed;\n}\n\nvec3 randomSphere(){\n  float a=2.*PI*random();\n  float b=acos(random()*2.-1.);\n  return vec3(cos(a)*sin(b),cos(b),sin(a)*sin(b));\n}\n\nvec3 randomHemisphere(vec3 n){\n  vec3 r=randomSphere();\n  return dot(r,n)<.0?-r:r;\n}\n\nmat2 r2d(float t){\n  return mat2(cos(t),sin(t),-sin(t),cos(t));\n}\n\nstruct Heck{\n  vec2 coord;\n  vec2 cell;\n  float len;\n};\n\nvec2 uv2heck(vec2 v){\n  v.y*=2./sqrt(3.);\n  v.x+=v.y*.5;\n  return v;\n}\n\nvec2 heck2uv(vec2 v){\n  v.y/=2./sqrt(3.);\n  v.x-=v.y*.5;\n  return v;\n}\n\nHeck doHeck(vec2 v,float scale){\n  Heck heck;\n  \n  v=uv2heck(v)*scale;\n  \n  heck.cell.x=lofi(v.x,1.);\n  heck.cell.y=lofi(v.y+heck.cell.x+2.0,3.)-heck.cell.x-2.0;\n  heck.coord=v-heck.cell-vec2(0,1);\n  \n  bool a=heck.coord.x<heck.coord.y;\n  heck.cell+=a?vec2(0,2):vec2(1,1);\n  heck.coord+=a?vec2(0,-1):vec2(-1,0);\n  \n  heck.cell=heck2uv(heck.cell/scale);\n  \n  heck.len=max(abs(heck.coord.x),abs(heck.coord.y));\n  heck.len=max(heck.len,abs(heck.coord.y-heck.coord.x));\n  \n  return heck;\n}\n\nconst float foldcos=cos(PI/5.0);\nconst float foldrem=sqrt(0.75-foldcos*foldcos);\nconst vec3 foldvec=vec3(-.5,-foldcos,foldrem);\nconst vec3 foldsurf=normalize(vec3(0,foldrem,foldcos));\nconst vec3 foldu=vec3(1,0,0);\nconst vec3 foldv=normalize(cross(foldu,foldsurf));\n\nvec3 fold(vec3 p){\n  for(int i=0;i<5;i++){\n    p.xy=abs(p.xy);\n    p-=2.*min(0.,dot(p,foldvec))*foldvec;\n  }\n  return p;\n}\n\nvec4 mapPlane(vec3 p){\n  float d=5.0-abs(p.y);\n  return vec4(d,1,0,0);\n}\n\nvec4 mapIcosa2(vec3 p){\n  float t=sin(time)+time;\n  p.zx=r2d(.1*t)*p.zx;\n  p=fold(p);\n  p-=foldsurf;\n  p.yz=r2d(2.+.17*t)*p.yz;\n  p=fold(p);\n  p-=0.41*foldsurf;\n  p.xy=r2d(5.+.07*t)*p.xy;\n  p=fold(p);\n  p-=0.26*foldsurf;\n  p.xy=r2d(3.+.12*t)*p.xy;\n  p=fold(p);\n  p-=0.07*foldsurf;\n  float d=dot(foldsurf,p)-.2;\n  return vec4(d,2,0,0);\n}\n\nvec4 mapIcosa(vec3 p){\n  p.zx=r2d(.1*time)*p.zx;\n  p=fold(p);\n  \n  vec3 isect=p/dot(foldsurf,p);\n  vec2 uv=vec2(dot(isect,foldu),dot(isect,foldv));\n  \n  float phase=time;\n  phase=floor(phase)+(.5+.5*cos(PI*exp(-5.0*fract(phase))));\n  float scale=5.0+4.0*sin(1.8*phase);\n  Heck heck=doHeck(uv,scale);\n  vec3 point=normalize(foldsurf+heck.cell.x*foldu+heck.cell.y*foldv);\n\n  phase+=4.7*length(heck.cell);\n  float height=2.0+.3*sin(4.9*phase);\n  \n  float dotPointP=dot(point,p);\n  float d=max(dotPointP-height,(heck.len-0.6/dotPointP)/scale*dotPointP*dotPointP);\n  vec4 ia=vec4(d,2,0,0);\n  \n  float width=0.6+0.3*sin(7.6*phase);\n  float haha=abs(dotPointP-height)-.1;\n  float haha2=(heck.len-width)/scale*dotPointP;\n  d=max(haha,haha2);\n  vec4 ib=vec4(d,3,step(-0.03,heck.len-width)*step(-haha,0.03),0);\n  \n  ia=ib.x<ia.x?ib:ia;\n  \n  return ia;\n}\n\nvec4 mapRings(vec3 p){\n  vec3 pInit=p;\n\n  p.zx=r2d(time)*p.zx;\n  p.xy=r2d(1.78*time)*p.xy;\n  p.zx=r2d(-lofi(atan(p.x,p.z)+PI/64.0,PI/32.0))*p.zx;\n  p.y=abs(p.y);\n  p.y=max(0.0,p.y-0.2);\n  float d=length(p-vec3(0,0,2.4))-.01;\n\n  p=pInit;\n  p.zx=r2d(-time)*p.zx;\n  p.yz=r2d(1.57*time)*p.yz;\n  p.zx=r2d(-lofi(atan(p.x,p.z)+PI/64.0,PI/32.0))*p.zx;\n  p.y=abs(p.y);\n  p.y=max(0.0,p.y-0.2);\n  d=min(d,length(p-vec3(0,0,2.6))-.01);\n  \n  return vec4(d,4,0,0);\n}\nvec4 mapHelp(vec3 p){\n  p.z+=20.0*mod(time+.8*sin(time),100.0); // forgive me\n\n  Heck heck=doHeck(p.zx,1.0/2.0);\n  \n  p.zx-=heck.cell;\n  p.y+=8.0*(fractSin(heck.cell.x)-.5);\n  p.y+=8.0*(fractSin(1.78*heck.cell.y)-.5);\n\n  p.z=abs(p.z);\n  p.z=max(0.0,p.z-(1.0*(1.0+1.0*cos(time))));\n  \n  float d=length(p)-0.01;\n  \n  return vec4(d,4,0,0);\n}\n\nvec4 map(vec3 p){\n  vec4 ia=vec4(9E9);\n  vec4 ib=mapIcosa(p);\n  ia=ib.x<ia.x?ib:ia;\n  ib=mapPlane(p);\n  ia=ib.x<ia.x?ib:ia;\n  ib=mapRings(p);\n  ia=ib.x<ia.x?ib:ia;\n  ib=mapHelp(p);\n  ia=ib.x<ia.x?ib:ia;\n  return ia;\n}\n\nvec3 normalIcosa(vec3 p,vec2 d){\n  return normalize(vec3(\n    mapIcosa(p+d.yxx).x-mapIcosa(p-d.yxx).x,\n    mapIcosa(p+d.xyx).x-mapIcosa(p-d.xyx).x,\n    mapIcosa(p+d.xxy).x-mapIcosa(p-d.xxy).x\n  ));\n}\n\nfloat aoFunc(vec3 p,vec3 n){\n  float accum=0.0;\n  for(int i=0;i<32;i++){\n    vec3 r=0.04*(1.+float(i))*randomHemisphere(n);\n    float d=map(p+r).x;\n    accum+=linearstep(0.04,0.0,d)/64.0;\n  }\n  return saturate(1.0-sqrt(accum*6.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 p = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y)*2.-1.;\n  p /= vec2(iResolution.y / iResolution.x, 1);\n  \n  time=iTime;\n  seed=texture(iChannel0,97.27*p).x+time;\n  time+=0.01*random();\n  \n  vec3 cp=mix(vec3(-.5,.7,3),vec3(0,0,7),.5+.5*sin(time));\n  cp.zx=r2d(.2*time)*cp.zx;\n  vec3 ct=vec3(0,1,-.8);\n  vec3 cd=normalize(ct-cp);\n  vec3 cx=normalize(cross(cd,vec3(0,1,0)));\n  vec3 cy=cross(cx,cd);\n  \n  vec3 ro=cp;\n  vec3 rd=normalize(cd*(1.-.4*length(p))+cx*p.x+cy*p.y);\n  float fl=mix(2., 6.,.5+.5*sin(time));\n  vec3 fp=ro+fl*rd;\n  ro+=.02*randomSphere();\n  rd=normalize(fp-ro);\n  \n  vec3 col=vec3(0.);\n  vec3 colRem=vec3(1);\n  \n  for(int is=0;is<2;is++){\n    float rl=0.04;\n    vec3 rp=ro+rd*rl;\n    vec4 isect;\n    \n    for(int i=0;i<69;i++){ // nice\n      isect=map(rp);\n      rl+=.5*isect.x;\n      rp=ro+rd*rl;\n    }\n    \n    if(.01<isect.x){\n      rl*=(sign(rd.y)*5.-ro.y)/(rp-ro).y;\n      rp=ro+rd*rl;\n      isect=vec4(0,1,0,0);\n    }\n    \n    float fog=exp(-0.01*rl);\n    colRem*=fog;\n  \n    if(isect.x<.01){\n      if(isect.y==1.){\n        vec3 n=vec3(0,-sign(rp.y),0);\n        Heck heck=doHeck(rp.xz+vec2(0,20.0*(time+.8*sin(time))),2.0);\n        float phase=time;\n        phase+=0.2*heck.cell.y;\n        phase+=4.0*texture(iChannel0,0.03*heck.cell).x;\n        phase+=1.0*fractSin(texture(iChannel0,30.03*heck.cell).x);\n        phase=mod(phase,5.0);\n        float width=0.9*(1.0-exp(-5.0*phase));\n        float shape=step(heck.len,width);\n        float shapewaku=step(heck.len,.9);\n        float dec=exp(-phase);\n        col+=colRem*dec*shape*vec3(0.9,0.02+0.002*rl,0.1);\n        colRem*=.6*shapewaku;\n        rd=normalize(reflect(rd,n)+.01*randomHemisphere(n));\n        ro=rp;\n      }else if(isect.y==2.){\n        vec3 n=normalIcosa(rp,vec2(0,1E-4));\n        vec3 n2=normalIcosa(rp,vec2(0,1E-2));\n        float edge=linearstep(.1,.2,length(n-n2));\n        float ao=aoFunc(rp,n);\n        float fresnel=1.0-abs(dot(rd,n));\n        fresnel=pow(fresnel,2.0);\n        col+=(1.0-edge)*colRem*vec3(0.9,0.02+0.002*rl,0.1)*ao;\n        colRem*=.2+.6*fresnel;\n        rd=reflect(rd,n);\n        ro=rp;\n      }else if(isect.y==3.){\n        vec3 n=normalIcosa(rp,vec2(0,1E-4));\n        float ao=aoFunc(rp,n);\n        float fresnel=1.0-abs(dot(rd,n));\n        fresnel=pow(fresnel,2.0);\n        col+=colRem*vec3(0.02)*ao;\n        col+=colRem*vec3(0.9,0.02+0.002*rl,0.1)*isect.z;\n        colRem*=.2+.6*fresnel;\n        rd=reflect(rd,n);\n        ro=rp;\n      }else if(isect.y==4.){\n        col+=colRem*2.0*vec3(0.9,0.02+0.002*rl,0.1);\n        colRem*=.0;\n      }\n    }\n  }\n  \n  col=pow(col,vec3(.4545));\n  col*=1.0-.2*length(p);\n  col*=1.+.2*sin(vec3(0,2,4)+2.*fragCoord.y);\n  col=vec3(\n    smoothstep(0.1,0.9,col.x),\n    smoothstep(-0.2,1.1,col.y),\n    smoothstep(-0.3,1.2,col.z)\n  );\n  \n  fragColor = vec4(col,1);\n}\n","name":"Image","description":"","type":"image"}]}