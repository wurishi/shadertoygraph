{"ver":"0.1","info":{"id":"ltG3WV","date":"1476794361","viewed":470,"name":"RGB Line Histogram","username":"ttoinou","description":"Upgraded from https://www.shadertoy.com/view/MlyGWK\nHistogram of a given line, not fast at all, should be optimized with a buffer.\nThere is no normalization, the histogram is slightly wrong depending on the number of samples.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["line","data","analysis","histogram","rvb","stat"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define lineSamples      (1024)\n#define histogramMargin  (0.05) \t\t// == 0. <=> black and white are perfectly at the left and the right\n#define histogramSmooth  (1./255.)\n#define histogramGain    (2.)\n#define histogramLineMin (-2.)\n#define histogramLineMax (2.)\n#define histogramLineSmooth  (3./255.)\n#define histogramLineBlack  (0.5)\n#define sourceGamma      (2.2) // 2.2 => histogram in linear color space\n#define point1           (vec2(.2,.2)) // (vec2(0.5,cos(iTime/8.*6.28)*.5+.5 ))\n#define point2           (iMouse.xy/iResolution.xy)\n#define pixelSize        (1./min(iResolution.x,iResolution.y))\n#define pointWidth       (3.*pixelSize)\n#define pointSmooth      (2.*pixelSize)\n#define lineSmooth       (4.*pixelSize)\n#define aspect \t\t     (vec2(1.,iResolution.y/iResolution.x))\n\n#define min3(a,b,c)     (min( (a) , min( (b) , (c) ) ))\n#define minvec3(x)     (min3( (x).r , (x).g , (x).b ))\n#define pow3(x,y)         (vec3( pow( (x).r , y ) , pow( (x).g , y ) , pow( (x).b , y ) ))\n\nvec4 showPoint(vec4 colorOut,vec3 color,vec2 coord,vec2 point){\n    return mix(colorOut,vec4(color,1.),\n    \t\t   clamp(1. - max( length( (coord - point)*aspect ) - pointWidth, 0. )/pointSmooth,0.,1.));\n}\n\nvec2 closestPointFromLine(vec2 p,vec2 a,vec2 b){\n    a -= p; b -= p;\n  \tvec3 k = vec3( dot(a,a) , dot(b,b) , dot(a,b) );\n  \tfloat t = (k.x - k.z)/( k.x + k.y - 2.*k.z );\n    return (a+p)*(1.-t) + (b+p)*t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = texture(iChannel0,uv);\n    float w = iChannelResolution[0].x;\n    float h = iChannelResolution[0].y;\n    \n    \n    // add points\n    fragColor = showPoint(fragColor,vec3(0.5,0.,0.),uv,point1);\n    fragColor = showPoint(fragColor,vec3(0.,0.,0.5),uv,point2);\n    \n    // add line\n    vec2 point12 = point2 - point1;\n    fragColor *= clamp(length(uv - closestPointFromLine(uv,point1,point2))/lineSmooth,0.,1.);\n    \n    // normalize line\n    vec2 a = point1;\n    vec2 ab = (point2 - point1)/length(point2 - point1);\n    \n    // histogram computing\n    \t// the value to look for\n    vec3 histogramValue = vec3(mix(-histogramMargin,1. + histogramMargin,uv.x));\n    \t// resulting value of computing\n    vec3 histogram = vec3(0.);\n    vec3 k;\n    vec2 coeff;\n    vec2 pos;\n    float H = iChannelResolution[0].y;\n    for( int i = 0 ; i < lineSamples ; i++ ){\n        // todo : compute intersection between line and source viewport\n        // and only sample interseting points + normalize\n        pos = mix(histogramLineMin,histogramLineMax,float(i)/float(lineSamples))*ab + a;\n        if( pos.x >= 0. && pos.y >= 0. && pos.x < 1. && pos.y < 1. ){\n            k = texture(iChannel0,vec2(pos.x,pos.y)).rgb;\n            k = pow3( k , sourceGamma ) - histogramValue;\n            histogram += exp(-k*k/(2.*histogramSmooth*histogramSmooth));\n        }\n    }\n    histogram *= histogramGain;\n    \n    // add histogram\n    \n    vec3 bars = histogram/(3.*H) - vec3(0.,-1./3.,-2./3.) + vec3(0.01);\n    bars = (1. - abs( (bars - uv.y) / histogramLineSmooth ));\n    fragColor.rgb += clamp(bars.rgb,0.,1.);\n    \n    float black = (1. - minvec3( abs(bars) )/histogramLineBlack);\n    fragColor *= 1. - clamp( black , 0. , 1. );\n\n}","name":"Image","description":"","type":"image"}]}