{"ver":"0.1","info":{"id":"3tfGDn","date":"1555978169","viewed":331,"name":"raising differences","username":"elenzil","description":"inspired by a demo from the pre-shader world by [url=https://en.wikipedia.org/wiki/Robert_Shaw_(physicist)]Rob Shaw[/url].\n\nleft: magnitude(delta(rgb)) right: delta(value of HSV)","likes":5,"published":1,"flags":34,"usePreview":0,"tags":["video","difference","buffers"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 RGBA, in vec2 XY) {\n    RGBA = texture(iChannel0, XY/iResolution.xy);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// from http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    \n    vec2 UV = vec2(iResolution.x - XY.x, XY.y) / iResolution.xy;\n        \n    vec3 rgb0 = texture(iChannel0, UV).rgb;\n    vec3 rgb1 = texture(iChannel1, UV).rgb;\n\n    float f;\n    \n    if (1.0 - UV.x < 0.5) {\n        // on the left:\n        // magnitude of RGB difference\n\t    vec3 drgb = rgb1 - rgb0;\n        f = length(drgb);\n    }\n    else {    \n        // on the right:\n        // saturation difference\n        vec3 hsv0 = rgb2hsv(rgb0);\n        vec3 hsv1 = rgb2hsv(rgb1);\n        f = abs(hsv0.z - hsv1.z);\n    }\n    \n    \n    f = smoothstep(0.15, 0.5, f);\n    \n    vec3 rgb = vec3(0.0);\n    rgb = mix(rgb, rgb1, f);\n\n    rgb += texture(iChannel2, vec2(1.0 - UV.x, UV.y - 1.0/iResolution.y)).rgb;\n    rgb = mix(rgb, rgb0, 0.02);\n\n    RGBA = vec4(rgb, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// buffer B's whole raison d'etre is just to store the previous frame.\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    RGBA = texture(iChannel0, XY/iResolution.xy);\n}\n","name":"Buffer B","description":"","type":"buffer"}]}