{"ver":"0.1","info":{"id":"XsVBDm","date":"1529245926","viewed":152,"name":"Walk Into the Desert ","username":"AxDragonxg","description":"going for a walk in the desert at sunset. first attempt at a 3D shader with procedurally generated terrain and lighting ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//--------------Ray marching----------------\n\n#define MAX_STEPS 90\n#define TERRAINSCALE 1.3\n#define TERRAINFREQ 0.13\n#define EPSILON 2.e-3\n#define time iTime * 0.5\n\nfloat GetMapHeight(in vec3 p)\n{\n    \n    float rn = Brownian(p.zx*TERRAINFREQ*0.5 + vec2(p.z,p.x*0.5)*TERRAINFREQ);\n\t \n    \n    rn *=TERRAINSCALE*0.25;\n    float h = noise(p.xz*TERRAINFREQ*1.0 + vec2(p.z,p.x*0.7)*TERRAINFREQ*1.5)*TERRAINSCALE*1.1  + rn;\n    h = pow(h,1.4); \n    return  h;  \n}\n\nfloat GetDist(in vec3 p)\n{\n \treturn p.y - GetMapHeight(p);  \n}\n\n\n\n\n//from https://www.shadertoy.com/view/lsKcDD\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.001 + 0.15*float(i)/4.0;\n        float d = GetDist( pos + h*nor );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 1.5*occ, 0.0, 1.0 );    \n}\n\n\n//from https://www.shadertoy.com/view/lsKcDD\n//https://iquilezles.org/articles/rmshadows\nfloat CalcSoftShadow(in vec3 ro, in vec3 rd, in float mint, in float tmax, int tech)\n{\n    float res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for( int i=0; i<20; i++ )\n    {\n\t\tfloat h = GetDist( ro + rd*t );\n\n        // traditional technique\n        if( tech==0 )\n        {\n        \tres = min( res, 10.0*h/t );\n        }\n        // improved technique\n        else\n        {\n            // use this if you are getting artifact on the first iteration, or unroll the\n            // first iteration out of the loop\n            //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \n\n            float y = h*h/(2.0*ph);\n            float d = sqrt(h*h-y*y);\n            res = min( res, 10.0*d/max(0.0,t-y) );\n            ph = h;\n        }\n        \n        t += h;\n        \n        if( res<0.001 || t>tmax ) break;\n        \n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat RayMarch(in vec3 origen, in vec3 dir, out vec3 p)\n{\n \tfloat t = 0.; \n    float cutoff = 0.1; \n    for(int i=0;i<MAX_STEPS; i++)\n    {\n        p = origen + t * dir; \n        float d = GetDist(p); //rays parallel to the surface are a problem\n        if(d < cutoff) return d; //but not sure how to deal with it  \n        float deltaT = d * 0.65; \n        deltaT = max(0.001*t*t,deltaT); //minimum deltaT? basing it off of how far away we already are \n        t += deltaT;   //don't need to be that accurate when far away \n    }\n    return t;         \n}\n\n\nvec3 getNormal(vec3 p) {\n    vec3 n;\n    n.y = GetMapHeight(p);    \n    n.x = GetMapHeight(vec3(p.x+EPSILON,p.y,p.z)) - n.y;\n    n.z = GetMapHeight(vec3(p.x,p.y,p.z+EPSILON)) - n.y;\n    n.y = EPSILON;\n    return normalize(n);\n}\n\n//------------Camera and environment---------------\n\nstruct Camera {\n  \tfloat zoom; \n    vec3 ro; \n    vec3 Lp; \n    vec3 F; \n    vec3 R; \n    vec3 U; \n    vec3 Center; \n} mainCamera; \n\nstruct Light {\n    vec3 rayDirection; \n    vec3 color; \n    float Il; \n} sun; \n    \nconst vec3 SunsetRed = vec3(253./255.,94./255.,83./255.);\nvoid SetUpCamera(vec2 uv)\n{\n    vec2 pos = uv + vec2(0.,time+2.); \n    vec3 ro = vec3(pos.x,0.,pos.y) + vec3(0.,0.5,0.); \n    float h = GetMapHeight(ro);\n    ro.y += h; \n    vec3 Lp = ro + vec3(1.*2.5*sin(0.05*time),-1.,8.+1.*2.5*cos(time*.05)); \n    mainCamera.ro = ro; \n    mainCamera.Lp = Lp; \n    mainCamera.zoom = 1.; \n    mainCamera.F = normalize(mainCamera.Lp - mainCamera.ro); \n    mainCamera.R = normalize(cross(vec3(0.,1.,0.),mainCamera.F)); \n    mainCamera.U = normalize(cross(mainCamera.F,mainCamera.R));\n    mainCamera.Center = mainCamera.ro + mainCamera.F * mainCamera.zoom; \n    \n    sun.rayDirection = normalize(vec3(0.,-0.5,-2.)); \n    sun.color = SunsetRed; \n    //sun.color = vec3(1.);\n    sun.Il =1.75; \n    \n    \n}\n\n//---------------COLOR----------------\n\nconst vec3 SandColor = vec3(1.,192./255.,106./255.); \nconst vec3 SandColor2 = vec3(217./255.,148./255.,96./255.); \nconst vec3 ShadeColor = vec3(145./255.,121./255.,110./255.); \nconst vec3 SkyBlue = vec3(235./255.,206./255.,235./255.); \nconst vec3 CoronaColor = vec3 (252./255.,236./255.,55./255.); \nconst vec3 OuterCoronaColor = vec3(1.,204./255.,35./255.);\nconst vec3 SunColor = vec3(250./255.,250./255.,116./255.); \nconst vec3 SkyColor = vec3(235./255.,80./255.,23./255.);\nconst vec3 DarkSkyColor = vec3(176./255.,12./255.,10./255.); \nconst vec3 CloudColor = vec3(0.8); \n\n//------makeing the sun \n\nvec3 MakeSun(in vec2 uv, vec3 rd, out float inSun)\n{\n    float cosa = dot(rd,normalize(-sun.rayDirection + vec3(0.,-0.2,0.))) + 2.; \n    cosa = cosa/4.; \n    \n    \n    float lv = 0.74;\n    float hv = 0.75; \n    float CoronMult = 0.002; \n     \n    float f = smoothstep(lv,hv,cosa); \n    \n        \n    float c = smoothstep(lv + lv*CoronMult*3.3, hv +hv*CoronMult*0.6,cosa*1.0); // smoothstep(0.12,.122,cosa); \n    c = clamp(f - c,0.,1.); \n    vec3 col =SunColor;  \n    //float oCoron = smoothstep(0.72,0.767,cosa); \n    \n    col = mix(col,CoronaColor,clamp(c-f,0.,1.));  \n   \t\n    float oCoron = smoothstep(lv - lv*CoronMult*40.0, hv - hv*CoronMult*0.7,cosa); \n                \n    float anyCir = clamp(f+c,0.,1.); \n    \n    oCoron = clamp(oCoron*1.2 - anyCir, 0.,1.); \n    oCoron = smoothstep(0.,0.8,oCoron); \n    inSun = clamp(anyCir, 0., 1.);\n    \n    col = col* anyCir + SkyColor * oCoron;  \n    \n    return col * anyCir; \n    //return vec3(oCoron); \n}\n\nvec3 GetSkyColor(in vec2 uv, vec3 rd, float phi, out float inSun)\n{\n    \n     \n    vec3 sunCol = MakeSun(uv,rd,inSun); \n        \n    phi = pow(phi,3.); \n    float orangeArea = smoothstep(0.3,0.4,phi); \n    \n    vec3 col = mix(DarkSkyColor,SkyColor,orangeArea); \n    col = mix(sunCol,col,inSun)*inSun + col; \n    \n    //inSun = smoothstep(0.6,0.8,inSun); \n    \n    inSun = smoothstep(0.6,0.8,pow(inSun,3.)); \n    return sunCol * inSun + col *(1.-inSun); \n}\n\nvec3 GetBaseTerrainColor(in vec3 p, in vec3 n)\n{\n    vec3 sand = SandColor; \n    \n    return sand; \n}\n\nvec3 GetTerrainColor(in vec3 p, in vec3 n, vec3 rd, in float dist)\n{\t\n    \n    vec3 lght = sun.rayDirection; \n    lght.y *= -1.;\n    lght.x *= -1.;\n    \n    \n    vec3 hal = normalize(lght - rd); \n    float dif = clamp(dot(n,lght),0.,1.); \n    dif *= CalcSoftShadow(p,lght,0.01,3.,1); //no idea what's causing the banding \n    \n    float spe = pow( clamp( dot( n, hal ), 0.0, 1.0 ),16.0);\n    \n    spe*=dif *(0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n    \n    \n    vec3 mat = GetBaseTerrainColor(p,n);\n    vec3 col = mat; \n    \n    col *= 4.*dif*mix(sun.color,mat,0.5); \n    col += 12.*spe*sun.color; \n    \n    //ambient\n    float occ = calcAO(p,n)*0.5; \n    float amb = clamp(0.5+0.5*n.y,1.,1.); \n    \n    \n    col += mat * amb * occ*vec3(0.08,0.08,0.1); \n\treturn col;  \n}\n\n\nvec3 GetBackgroundColor(in vec3 rd, in vec2 uv)\n{\n    \n    float cosa = dot(rd,normalize(-sun.rayDirection + vec3(0.,-0.2,0.))) + 2.; \n    cosa /=4.; \n    \n    //float inSky = smoothstep(0.496,0.499,cosa); \n    \n    vec2 seed = vec2(uv.x*0.2,uv.y*3.2); \n    float n = MultBrownian(seed*3.8+vec2(time*0.1,0.)); //some clouds \n    float CShift = n;//noise(rd.xy*5.); \n    n = smoothstep(0.45,1.,n*1.2) * 0.7; \n    \n    \n    CShift = (CShift - 0.5)  * n*cosa*0.7; \n    cosa += CShift; \n    \n    //get some clouds \n    \n    float inSun;\n    vec3 skyColor = GetSkyColor(uv,rd,cosa, inSun); \n    n += inSun*0.5*n; \n    skyColor = mix(skyColor,CloudColor,n*0.8); \n    \n    \n \treturn skyColor;// * (inSky) ; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;//center and square \n\tvec3 col = vec3(0.0); \n\n    \n    \n    SetUpCamera(uv); \n    vec3 i = mainCamera.Center + mainCamera.R * uv.x + mainCamera.U * uv.y;\n    vec3 rd = normalize(i - mainCamera.ro); \n    // Time varying pixel color\n\n    // Output to screen\n    vec3 p; \n    float t = RayMarch(mainCamera.ro, rd, p); \n    vec3 n = getNormal(p); \n    t = clamp(t,0.0,1.0); \n    float found = 1. / (1. + t * t*t*t) *1.5;\n    found = smoothstep(0.8,0.9,found); \n\n    float dist = length(p-mainCamera.ro); \n    float fog = 1./(dist*dist*0.02 + 1.); \n    \n    vec3 groundCol = GetTerrainColor(p,n,rd,length(mainCamera.ro-p));\n    groundCol *= fog; \n    \n    \n    vec3 backCol = GetBackgroundColor(rd,uv); \n    found = smoothstep(0.8,0.879,found);\n    \n    \n    vec3 Maincol = groundCol * found + backCol * (1. - found); \n    fragColor = vec4(Maincol,1.); \n\t//fragColor = vec4(n,1.) * found; \n\t//fragColor = vec4(found);     \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n\n//----------------Random Generators ------------\nfloat hash(in vec2 seed)\n{\n    return fract(abs(411548.*sin(52.*dot(seed+4.,vec2(2546.,758.))))); \n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) { //valley like \n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n\nfloat RidgeOctive(in vec2 seed, in float freq)\n{\n\treturn 2.*(0.5-abs(0.5-noise(seed*freq))); \n}\n\n#define OCTAVES 3\n//from book of shaders \n//https://thebookofshaders.com/13/\nfloat Brownian ( in vec2 _st) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.50));\n    for (int i = 0; i < OCTAVES; ++i) {\n        v += a * noise(_st);\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\n#define MBownian 1\n\nfloat MultBrownian(in vec2 seed) //cloud or fog like \n{\n\tvec2 q; \n    float s; \n    q.x = Brownian(seed - vec2(1.8,4.5)); \n    q.y = Brownian(seed + vec2(2.8,1.2)); \n    \n    for(int i=0; i<MBownian; i++)\n    {\n\t\ts = Brownian(q+seed+vec2(12.,7.));\n        vec2 z; \n        z.x = s; \n        z.y = Brownian(q+seed-vec2(17.,-6.));\n        \n        q = z; \n    }\n    return s; \n}\n       \t\nfloat MultiTBrownian(in vec2 seed, in float time)\n{\n    vec2 q; \n    float s = hash(seed); \n    q.x = Brownian(seed+ time);\n    q.y = Brownian(seed- time); \n    vec2 z; \n    \n    for(int i=0; i<MBownian; i++)\n    {\n\t\ts = Brownian(q+seed+vec2(2.,7.)+0.2*time);\n        vec2 z; \n        z.x = s; \n        z.y = Brownian(q+seed-vec2(7.,-6.) + 0.2*time);\n        \n        q = z; \n        s = Brownian(q); \n    }\n    return s; \n}\n\nfloat RidgeNoise(in vec2 seed) //canyons \n{\n\tfloat value = 0.; \n    float amplitude = 0.96; \n    float freq = 0.221; \n    for(int i=0; i<OCTAVES; i++)\n    {\n        value += amplitude * noise(seed*freq); \n        seed *= 2.7; \n        amplitude *= 0.5; \n        freq *= 2.3; \n    }\n    return pow(value,2.8); \n}\n    \n//--------------------Sinple Geometry \n\n\n float InCircle(in vec2 center, in float radius, in vec2 p, in float l)\n{\n    vec2 distv = p - center;\n    float d2 = distv.x * distv.x + distv.y * distv.y; \n    float r2 = radius * radius; \n    return 1.0 - smoothstep( r2 - l / 2.0, r2 + l / 2.0, d2); \n}\n\nfloat InCircle(in vec2 center, in float radius, in vec2 p)\n{\n    float l = 0.002; \n    vec2 distv = p - center;\n    float d2 = distv.x * distv.x + distv.y * distv.y; \n    float r2 = radius * radius; \n    return 1.0 - smoothstep( r2 - l / 2.0, r2 + l / 2.0, d2); \n}\n\n\n    \n    ","name":"Common","description":"","type":"common"}]}