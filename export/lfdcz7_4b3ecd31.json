{"ver":"0.1","info":{"id":"lfdcz7","date":"1730447545","viewed":139,"name":"Particle Sim v0","username":"8InfinityTaco8","description":"After playing around for a few days to a week i finally figured out how to simulate more than one singular particle lol \n","likes":8,"published":1,"flags":48,"usePreview":0,"tags":["bounce","physics","gravity"],"hasliked":0,"parentid":"MctyRn","parentname":"Persistent State Physics v0"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nPress R to reset & Left click to interact\n\n(WIP)\n\nstill figuring out how to iron out the particle interaction physics. \nalso higher framerates effect the physics interactions. Works better at 60fps thatn 144fps for right now\n\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 col = vec3(0.0);\n    \n    //draw particles\n    for (int i = 0; i < MAX_PARTICLES; i++) {\n        vec4 state = texelFetch(iChannel0, ivec2(i, 0), 0);\n        float d = length(uv - state.xy) - PARTICLE_RADIUS;\n        col = mix(col, vec3(1.0), 1.0 - smoothstep(-0.001, 0.001, d));\n    }\n    \n    //draw box\n    float boxDist = sdBox(uv, BOX_BOUND_MIN, BOX_BOUND_MAX);\n    col = mix(col, vec3(1.0, 0.0, 0.0), 1.0 - smoothstep(0.0, BOX_EDGE_THICKNESS, abs(boxDist)));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    int particleIndex = int(fragCoord.x);\n    \n    // Exit early if we're trying to process more particles than allowed\n    if (particleIndex >= MAX_PARTICLES) {\n        fragColor = vec4(0.0);\n        return;\n    }\n\n    // Check for reset key press (using 'R' key)\n    bool resetPressed = texelFetch(iChannel1, ivec2(82, 0), 0).x > 0.0;\n    \n    // Reset if it's frame 0 OR if reset key was pressed\nif (iFrame == 0 || resetPressed) {\n        fragColor = initializeParticlesInGrid(particleIndex, iTime);\n        return;\n    }\n\n    vec4 previousState = texelFetch(iChannel0, ivec2(particleIndex, 0), 0);\n    vec2 position = previousState.xy;\n    vec2 velocity = previousState.zw;\n    \n    // Convert mouse position to same coordinate space as particles\n    vec2 mousePos = iMouse.xy / iResolution.xy * 2.0 - 1.0;\n    mousePos.x *= iResolution.x / iResolution.y;\n     \n    \n    // Calculate distance and direction to mouse\n    vec2 toMouse = mousePos - position;\n    float distToMouse = length(toMouse);\n    \n    // Apply mouse forces if within radius\n    if (distToMouse < MOUSE_FORCE_RADIUS && distToMouse > 0.001) {\n        vec2 forceDir = normalize(toMouse);\n        float forceFalloff = 1.0 - (distToMouse / MOUSE_FORCE_RADIUS); // Force gets weaker with distance\n        \n        // Left mouse button (push)\n        if (iMouse.z > 0.0) {\n            velocity -= forceDir * MOUSE_FORCE_STRENGTH * forceFalloff * iTimeDelta;\n        }\n        // Right mouse button (pull)\n        else if (iMouse.w > 0.0) {\n            velocity += forceDir * MOUSE_FORCE_STRENGTH * forceFalloff * iTimeDelta;\n        }\n    }\n    \n    // Apply regular physics\n    velocity.y -= GRAVITY * iTimeDelta;\n    velocity *= FRICTION;\n    \n    // Clamp maximum velocity\n    float maxSpeed = 2.0;\n    float currentSpeed = length(velocity);\n    if (currentSpeed > maxSpeed) {\n        velocity = (velocity / currentSpeed) * maxSpeed;\n    }\n    \n    position += velocity * iTimeDelta;\n    \n        // Particle collisions (there are probably MUCH MUCH MUCH better ways of doing this)\n    // Loop through all particles to check for collisions\n    for (int i = 0; i < MAX_PARTICLES; i++) {\n        // Skip checking collision with itself\n        if (i == particleIndex) continue;\n    \n        // Get the state of the other particle we're checking against\n        vec4 otherState = texelFetch(iChannel0, ivec2(i, 0), 0);\n    \n        // Calculate vector between the two particles (direction and distance)\n        vec2 diff = position - otherState.xy;\n        float dist = length(diff);\n    \n        // Check if particles are overlapping (closer than their combined radii)\n        // The 0.0001 check prevents division by zero\n        if (dist < PARTICLE_RADIUS * 2.0 && dist > 0.0001) {\n            // Get the normalized direction vector between particles\n            vec2 normal = normalize(diff);\n        \n            // Calculate relative velocity between the particles\n            vec2 relativeVel = velocity - otherState.zw;\n        \n            // Project relative velocity onto the collision normal\n            // This tells us if particles are moving toward or away from each other\n            float velAlongNormal = dot(relativeVel, normal);\n        \n            // Only collide if particles are moving toward each other\n            if (velAlongNormal < 0.0) {\n                // Calculate collision impulse (how much the particles bounce)\n                // COLLISION_DAMPENING controls how \"bouncy\" the collision is\n                float j = -(1.0 + COLLISION_DAMPENING) * velAlongNormal * 0.5;\n            \n                // Apply the impulse force to change velocity\n                velocity += normal * j;\n            \n                // Push particles apart to prevent them from sticking together\n                float correction = (PARTICLE_RADIUS * 2.0 - dist) * 0.5;\n                position += normal * correction;\n            }\n        }\n    }\n    \n    // Handle box collisions\n    if (position.x < BOX_BOUND_MIN.x + PARTICLE_RADIUS) {\n        position.x = BOX_BOUND_MIN.x + PARTICLE_RADIUS;\n        //velocity.x = abs(velocity.x) * -COLLISION_DAMPENING;\n        velocity.x = -velocity.x * COLLISION_DAMPENING; // Reverse x velocity //Bounce off left wall\n\n    }\n    if (position.x > BOX_BOUND_MAX.x - PARTICLE_RADIUS) {\n        position.x = BOX_BOUND_MAX.x - PARTICLE_RADIUS;\n        //velocity.x = -abs(velocity.x) * COLLISION_DAMPENING;\n        velocity.x = -velocity.x * COLLISION_DAMPENING; // Reverse x velocity // Bounce off right wall\n\n    }\n    if (position.y < BOX_BOUND_MIN.y + PARTICLE_RADIUS) {\n        position.y = BOX_BOUND_MIN.y + PARTICLE_RADIUS;\n        //velocity.y = abs(velocity.y) * -COLLISION_DAMPENING;\n        velocity.y = -velocity.y * COLLISION_DAMPENING; // Reverse y velocity // Bounce off bottom wall\n\n    }\n    if (position.y > BOX_BOUND_MAX.y - PARTICLE_RADIUS) {\n        position.y = BOX_BOUND_MAX.y - PARTICLE_RADIUS;\n        //velocity.y = -abs(velocity.y) * COLLISION_DAMPENING;\n        velocity.y = -velocity.y * COLLISION_DAMPENING; // Reverse y velocity // Bounce of top wall\n\n    }\n    \n    // Store final position and velocity in output color\n    fragColor = vec4(position, velocity);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Physics Properties\n#define COLLISION_DAMPENING 0.3    \n#define ACCELERATION .9          \n#define FRICTION .995             \n#define GRAVITY 1.0               \n#define INITIAL_VELOCITY_BOOST 0.05 \n// Bounds Properties\n#define BOX_BOUND_MIN vec2(-0.88, -0.49)  \n#define BOX_BOUND_MAX vec2(0.88, 0.49)    \n#define BOX_EDGE_THICKNESS 0.003  \n// Particle Properties\n#define MAX_PARTICLES 500         // Reduced from 1000 for better performance\n#define PARTICLE_RADIUS 0.01      // Smaller particles for less crowding\n#define SPAWN_WIDTH 0.8           \n#define SPAWN_HEIGHT 0.4          \n\n//keyboard & mouse interactikons\n#define KEY_R 82\n\n#define MOUSE_FORCE_RADIUS 0.9\n#define MOUSE_FORCE_STRENGTH -3.0\n\n// Random function from https://thebookofshaders.com/\nfloat random(vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nfloat sdCircle(vec2 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdBox(vec2 p, vec2 bMin, vec2 bMax) {\n    vec2 bCenter = (bMax + bMin) * 0.5;\n    vec2 bSize = (bMax - bMin) * 0.5;\n    vec2 d = abs(p - bCenter) - bSize;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\n// Calculate grid position and initial state for a particle\nvec4 initializeParticlesInGrid(int particleIndex, float time) {\n    float aspectRatio = SPAWN_WIDTH / SPAWN_HEIGHT;\n    float rowsFloat = sqrt(float(MAX_PARTICLES) / aspectRatio);\n    float colsFloat = rowsFloat * aspectRatio;\n    \n    int rows = int(floor(rowsFloat));\n    int cols = int(floor(colsFloat));\n    \n    // Adjust grid size if needed\n    if (rows * cols < MAX_PARTICLES) {\n        cols += 1;\n        if (rows * cols < MAX_PARTICLES) {\n            rows += 1;\n        }\n    }\n    \n    // Calculate grid position\n    int gridX = particleIndex % cols;\n    int gridY = particleIndex / cols;\n    \n    // Convert to world coordinates\n    float x = mix(-SPAWN_WIDTH, SPAWN_WIDTH, (float(gridX) + 0.5) / float(cols));\n    float y = mix(-SPAWN_HEIGHT, SPAWN_HEIGHT, (float(gridY) + 0.5) / float(rows));\n    \n    // Add random offset\n    float offsetX = random(vec2(float(particleIndex), time)) * 0.02 - 0.01;\n    float offsetY = random(vec2(time, float(particleIndex))) * 0.02 - 0.01;\n    \n    x += offsetX;\n    y += offsetY;\n    \n    // Calculate initial velocity\n    float vx = (random(vec2(float(particleIndex), time + 1.0)) - 0.5) * INITIAL_VELOCITY_BOOST;\n    float vy = (random(vec2(time + 1.0, float(particleIndex))) - 0.5) * INITIAL_VELOCITY_BOOST;\n    \n    return vec4(x, y, vx, vy);\n}","name":"Common","description":"","type":"common"}]}