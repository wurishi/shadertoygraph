{"ver":"0.1","info":{"id":"4tsBW2","date":"1513375715","viewed":223,"name":"Slightly more efficient Cube ","username":"stduhpf","description":"A shorter version of [url=https://www.shadertoy.com/view/4llfWj]Inefficient Cube[/url] by MetCodeMass.\nI tried to keep the lighting exactly as the original one, that's why some parts are messy.\nI know it could be a lot shorter, but i am to lazy to golf it","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["cube","almostgolfing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 rotationAxis = vec3(0, 1, .25);\nconst float rotationSpeed = .5;\nvec3 lightDirection = normalize(-vec3(.5, .25, 1));\n\n#define maxp(a) max(max(a.x,a.y),a.z)\n#define minp(a) min(min(a.x,a.y),a.z)\nvec3 toNormal(vec3 p,float r)\n{\n    vec3 s = sign(p);\n    s.y*=-1.;\n    return  s*step(r-r/1e6,abs(p));\n    //    p=abs(p);         //more exact,but longer (also don't need the size of the cube)\n    //\t  return  s*step(p.yzx,p.xyz)*step(p.zxy,p.xyz);\n}\nconst float PI = acos(-1.);\n\nfloat intsc(vec3 ro,vec3 rd,float r,float dd)\n{\n    rd/=dd; //normalization of rd\n    vec3 a=-(ro-r)/rd;\n    vec3 b=-(ro+r)/rd;\n    vec3 aa=min(a,b);\n    vec3 bb= max(a,b);\n    float d = maxp(aa);\n    vec3 p = toNormal(ro+d*rd,r);\n    return d<=minp(bb)?(2.-sqrt(floor(d-dd)-1.)*.1)*(1.-acos(dot(lightDirection, p))/PI):0.; //the \"floor\" is not needed\n    \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//(in fact it's better without), but like this it's \n    \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//like the original lighting \n}\nmat3 rotationMatrix(vec3 axis, float angle)//just made it a mat3 instead of mat4\n{\n    axis = normalize(axis);\n    float s = sin(-angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\nvoid mainImage( out vec4 O, vec2 I )\n{\n\tI = (I.xy - iResolution.xy*.5);\n    mat3 m =rotationMatrix(rotationAxis,PI * .75 + sin(rotationSpeed * iTime) * .5);\n    vec3 ro= m*vec3(0,0,1000), //rotating the camera and the light is better than rotating the whole scene\n        rd=m*vec3(I,-800);\n    lightDirection*=m;\n\tO.x=intsc(ro,rd,100.,length(rd));\n\tO=O.xxxx;\n}","name":"Image","description":"","type":"image"}]}