{"ver":"0.1","info":{"id":"ssdyRS","date":"1653663750","viewed":83,"name":"Blossoming __","username":"Envy24","description":"BufferA - drawing spline\nBufferB - drawing control points\nBufferC - drawind dashed convex hull\nImage - mixing and coloroing\n\nFour passes used for better readability of code.","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["linear","cubic","quadratic","interpolation","blossming"],"hasliked":0,"parentid":"NlSBDc","parentname":"Template for interpolation"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 O, in vec2 SC )\n{\n    vec4 spline      = TEXF0(SC);\n    vec4 knot        = TEXF1(SC);\n    vec4 convex_hull = TEXF2(SC);\n    \n    float min = MIN3(spline.r, knot.r, convex_hull.r);\n    \n    O = \n        min == 1.0 ?\n            vec4(1) :                            // Background color\n            min == spline.r ?\n                vec4(0, spline.r, spline.r, 1) : // Spline color\n                min == knot.r ?\n                    vec4(0, knot.r, 0, 1) :      // Knot color\n                    vec4(convex_hull);           // Convex hull  color\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R                           iResolution\n#define TO_CENTERED_NDC(SC)       ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define INITIALLY_FAR               9e30\n#define TEXF0(SC)                 ( texelFetch(iChannel0, ivec2(SC), 0) )\n#define TEXF1(SC)                 ( texelFetch(iChannel1, ivec2(SC), 0) )\n#define TEXF2(SC)                 ( texelFetch(iChannel2, ivec2(SC), 0) )\n#define MIN3(a, b, c)             ( min(min((a), (b)), (c)) )\n#define NMY                       ( iMouse.y / R.y )                 // in range [0.0; 1.0]\n#define LMB_IS_HOLD               ( iMouse.z > 0.0 )\n#define TAU                         6.2831853071795862\n#define TO_RAD                      0.017453292519943295        // Convert degrees to radians\n\n\nconst int num_of_ctrls = max(3, 6);\nconst float theta = 180.0 / float(num_of_ctrls);\nvec2 ctrls[num_of_ctrls];\n\nfloat circleSQSDF(\n    in vec2 S,   // sample coordinates\n    in vec2 C,   // circle center\n    in float R,  // circle radius\n    in float SM) // AA parameter\n{\n    // Sample coordinates relative to circle center.\n    float x = S.x - C.x, y = S.y - C.y;\n    \n    // Signed distance of areas (squared distancies).\n    float sds = x * x + y *y - R * R;\n    \n    float ss = SM * SM;\n    \n    // Smoothstep interpolation.\n    return smoothstep(-ss, ss, sds);\n    //return smoothstep(-ss, ss, sds * sds); // outline\n}\n\n/* \n    Returns random vec2([-1.0; 1.0], [-1.0; 1.0]).\n*/\nvec2 vector2HashUI32(\n    const uint x,\n    const uint y)\n{\n    // Pick some enthropy source values.\n    // Try different values.\n    const uint entropy0 = 123u;\n    const uint entropy1 = 456u;\n    const uint entropy2 = 789u;\n\n    // Use linear offset method to mix coordinates.\n    uint value0 = y * entropy2 + x;\n    uint value1 = x * entropy2 + y;\n\n    // Calculate hash.\n\tvalue0 += entropy1; value0 *= 445593459u; value0 ^= entropy0;\n    value1 += entropy1; value1 *= 445593459u; value1 ^= entropy0;\n    \n    // 2.0f / 4294967295.0f = 4.6566128730773926e-10\n\n    return \n        vec2(\n            float(value0 * value0 * value0) * 4.6566128730773926e-10f - 1.0f,\n            float(value1 * value1 * value1) * 4.6566128730773926e-10f - 1.0f);\n}\n\nvoid generatePolygon(\n    inout vec2[num_of_ctrls] ctrls,\n    in float theta) // initial angular offset\n{\n    theta *= TO_RAD;\n    float dt = TAU / float(num_of_ctrls);\n    for (int p = 0; p < num_of_ctrls; ++p)\n    {\n        ctrls[p].x = cos(theta);\n        ctrls[p].y = sin(theta);\n        theta += dt;\n    }\n}\n\n// Sorry for that mess.\nvec2 lerp(vec2[2] ctrls, float t) { return ctrls[0] + (ctrls[1] - ctrls[0]) * t; }\nvec2 lerp2(vec2 S, vec2 E, float t) { return S + (E - S) * t; }\n\nvec2 quadraticInterpolation(in vec2[3] ctrls, float t)\n{\n    float tt = t * t;\n    float w0 = 2.0 * tt - 3.0 * t + 1.0;\n    float w1 = -4.0 * tt + 4.0 * t;\n    float w2 = 2.0 * tt - t;\n\n    return w0 * ctrls[0] + w1 * ctrls[1] + w2 * ctrls[2];\n}\n\nvec2 quadraticInterpolation2(vec2 P0, vec2 P1, vec2 P2, float t)\n{\n    float tt = t * t;\n    float w0 = 2.0 * tt - 3.0 * t + 1.0;\n    float w1 = -4.0 * tt + 4.0 * t;\n    float w2 = 2.0 * tt - t;\n\n    return w0 * P0 + w1 * P1 + w2 * P2;\n}\n\n\nvec2 cubicInterpolation(in vec2[4] ctrls, float t)\n{\n    float tt =  t * t;\n    float ttt = t * t * t;\n    float w0 =  -4.5 * ttt +  9.0 * tt - 5.5 * t + 1.0;\n    float w1 =  13.5 * ttt - 22.5 * tt + 9.0 * t;\n    float w2 = -13.5 * ttt + 18.0 * tt - 4.5 * t;\n    float w3 =   4.5 * ttt -  4.5 * tt +       t;\n\n    return w0 * ctrls[0] + w1 * ctrls[1] + w2 * ctrls[2] + w3 * ctrls[3];\n}\n\nvec2 cubicInterpolation2(vec2 P0, vec2 P1, vec2 P2, vec2 P3, float t)\n{\n    float tt =  t * t;\n    float ttt = t * t * t;\n    float w0 =  -4.5 * ttt +  9.0 * tt - 5.5 * t + 1.0;\n    float w1 =  13.5 * ttt - 22.5 * tt + 9.0 * t;\n    float w2 = -13.5 * ttt + 18.0 * tt - 4.5 * t;\n    float w3 =   4.5 * ttt -  4.5 * tt +       t;\n\n    return w0 * P0 + w1 * P1 + w2 * P2 + w3 * P3;\n}\n\nvec2 BezierQuadraticInterpolation(vec2[3] ctrls, float t)\n{\n    float f = 1.0 - t;\n\n    return f * f * ctrls[0] + t * (2.0 * f * ctrls[1] + t * ctrls[2]);\n}\n\nvec2 BezierCubicInterpolation(vec2[4] knots, float t)\n{\n    float oneMinusT = 1.0f - t;\n    return oneMinusT * (oneMinusT * oneMinusT * knots[0] + 3.0 * t * (oneMinusT * knots[1] + t * knots[2])) + t * t * t * knots[3];\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define IDX(i) ((i) % num_of_ctrls)\n\nvoid interpolations(\n    inout vec2[num_of_ctrls] storage,  \n    float t,\n    int count,\n    int per_count)\n{\n    vec2[num_of_ctrls] buffer;\n    \n    while (count > 0)\n    {  \n        for (int c = 0; c < per_count; ++c)\n        {\n            for (int s = 0; s < num_of_ctrls; ++s)\n            {\n                buffer[s] = lerp2(storage[s], storage[IDX(s + 1)], t);\n                //buffer[s] = quadraticInterpolation2(storage[s], storage[IDX(s + 1)], storage[IDX(s + 2)], t);\n                //buffer[s] = cubicInterpolation2(storage[s], storage[IDX(s + 1)], storage[IDX(s + 2)], storage[IDX(s + 3)], t);\n                // e.t.c.\n            }\n\n            for (int p = 0; p < num_of_ctrls; ++p)\n            {\n                storage[p] = buffer[p];\n            }\n        }\n        \n        --count;\n    }\n}\n\n\nvec2 find_closest_curve_point_to_pixel(\n    in vec2[num_of_ctrls] ctrls,\n    in vec2 NDC)\n{\n    vec2 closestP = vec2(0);\n    float minSqDist = INITIALLY_FAR;\n \n    float dt = 0.01;\n    \n    vec2[num_of_ctrls] buffer;\n\n    for (int l = 6; l >= 0; --l)\n    {\n        for (int b = 0; b < num_of_ctrls; ++b)\n        {\n            buffer[b] = ctrls[b];\n        }\n    \n        interpolations(buffer, mod(iTime * 0.15, 1.), l, 2);\n        \n        for (int s = 0; s < num_of_ctrls; ++s)\n        {\n            //vec2 _ctrls[2] = vec2[2](buffer[s], buffer[IDX(s+1)]);\n            vec2 _ctrls[3] = vec2[3](buffer[s], buffer[IDX(s+1)], buffer[IDX(s+2)]);\n            //vec2 _ctrls[4] = vec2[4](buffer[s], buffer[IDX(s+1)], buffer[IDX(s+2)], buffer[IDX(s+3)]);\n            // e.t.c.\n\n            for (float t = 0.; t <= 1.; t += dt)\n            {\n                //vec2 P = lerp(_ctrls, t);\n                //vec2 P = quadraticInterpolation(_ctrls, t);\n                //vec2 P = cubicInterpolation(_ctrls, t);\n                vec2 P = BezierQuadraticInterpolation(_ctrls, t);\n                //vec2 P = BezierCubicInterpolation(_ctrls, t);\n\n                vec2 diff = P - NDC;\n                float sqDist = dot(diff, diff);\n\n                minSqDist = min(minSqDist, sqDist);\n\n                closestP = \n                    minSqDist == sqDist ? \n                        P :\n                        closestP;\n            }\n        }\n    }\n\n    \n    return closestP;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = TO_CENTERED_NDC(SC);\n\n    generatePolygon(ctrls, theta);\n\n    O = vec4(circleSQSDF(\n        find_closest_curve_point_to_pixel(ctrls, NDC),\n        NDC,\n        0.01,\n        0.011));\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec2 find_closest_control_point_to_pixel(\n    in vec2[num_of_ctrls] ctrls,\n    in vec2 NDC)\n{\n    vec2 closestP = vec2(0);\n    float minSqDist = INITIALLY_FAR;\n\n    for (int k = 0; k < num_of_ctrls; ++k)\n    {\n        vec2 diff = ctrls[k] - NDC;\n        float sqDist = dot(diff, diff);\n       \n        minSqDist = min(minSqDist, sqDist);\n        \n        closestP = \n            minSqDist == sqDist ? \n                ctrls[k] :\n                closestP;\n    }\n    \n    return closestP;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = TO_CENTERED_NDC(SC);\n    \n    generatePolygon(ctrls, theta);\n\n    O = vec4(circleSQSDF(\n        find_closest_control_point_to_pixel(ctrls, NDC),\n        NDC,\n        0.02,\n        0.018));\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"4sXGR8","channel":0}],"code":"vec2 find_closest_convex_hull_point_to_pixel(\n    in vec2[num_of_ctrls] ctrls,\n    in vec2 NDC)\n{\n    vec2 closestP = vec2(0);\n    float minSqDist = INITIALLY_FAR;\n    \n    for (int l = 0; l < num_of_ctrls; ++l)\n    {\n        for (float t = 0.; t <= 1.; t += 0.1)\n        {\n            vec2 P = ctrls[l] * (1. - t) + ctrls[(l + 1) % num_of_ctrls] * t;\n\n            vec2 diff = P - NDC;\n            float sqDist = dot(diff, diff);\n\n            minSqDist = min(minSqDist, sqDist);\n\n            closestP = \n                minSqDist == sqDist ? \n                    P :\n                    closestP;\n        }\n    }\n    \n    return closestP;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = TO_CENTERED_NDC(SC);\n\n    generatePolygon(ctrls, theta);\n\n    O = vec4(circleSQSDF(\n        find_closest_convex_hull_point_to_pixel(ctrls, NDC),\n        NDC,\n        0.008,\n        0.0088));\n}","name":"Buffer C","description":"","type":"buffer"}]}