{"ver":"0.1","info":{"id":"ddyBDW","date":"1701808791","viewed":32,"name":"_Projet_CH","username":"Smouvie","description":"Le projet consiste à créé une scène dans Shadertoy.\n\nPetit Chalet avec feu de camp.","likes":0,"published":1,"flags":0,"usePreview":1,"tags":["projet3a"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int NB_OBJ = 23;\nconst int NB_LUM = 2;\n\n// Camera, Ray, Lights\n\nstruct Camera {\n    vec3 Obs;\n    vec3 View;\n    vec3 Up;\n    vec3 Horiz;\n    float H;\n    float W;\n    float z;\n};\n\nstruct Ray {\n    vec3 Origin;\n    vec3 Dir;\n};\n\nstruct Lum {\n   vec3 Center;\n   float R;\n   vec3 Color;\n   float Intensity;\n};\n\nCamera camera(in vec3 Obs, in vec3 LookAt, in float aperture) {\n   Camera C;\n   C.Obs = Obs;\n   C.View = normalize(LookAt-Obs);\n   C.Horiz = normalize(cross(vec3(0,1,0),C.View));\n   C.Up = normalize(cross(C.View,C.Horiz));\n   C.H = iResolution.y;\n   C.W = iResolution.x;\n   C.z = (C.H/2.)/tan(aperture/360.*3.144);\n   return C;\n}\n\nRay launch(in Camera C, in vec2 XY) {\n   Ray r;\n   r.Origin = C.Obs;\n   vec3 p = C.Obs + C.z*C.View + (XY.x - C.W/2.)*C.Horiz + (XY.y - C.H/2.)*C.Up;\n   r.Dir = p - C.Obs;\n   return r;\n}\n\nLum light(in Lum L,in vec3 Origin, in vec3 Color, in float R, in float Int) {\n   Lum l;\n   l.Center = Origin;\n   l.Color=Color;\n   l.R=R;\n   l.Intensity = Int;\n   return l;\n}\n\n// Objects\n\nstruct Obj {\n    vec3 Origin;\n    vec3 Vec1; vec3 Vec2; vec3 N;\n    float Length1; float Length2;\n    vec3 Color;\n    bool Is_Sph; bool Is_Cyl; bool Is_Pla; bool Is_Cone;\n    int P_nbSide;\n    int id; bool Is_Visible;\n};\n\n// Type of objects\n\nObj create_sphere (vec3 Center, float R, vec3 Color, int id) {\n    Obj O = Obj(Center,vec3(0.,0.,0.),vec3(0.,0.,0.),vec3(0.,0.,0.),R,0.,Color,true,false,false,false,0,id,true);\n    return O;\n}\n\nObj create_planInf (vec3 Origin, vec3 N, vec3 Color, int id) {\n    Obj O = Obj(Origin,vec3(0.,0.,0.),vec3(0.,0.,0.),normalize(N),0.,0.,Color,false,false,true,false,0,id,true);\n    return O;\n}\n\nObj create_planDef1 (vec3 Origin, vec3 N, float R, vec3 Color, int id) {\n    Obj O = Obj(Origin,vec3(0.,0.,0.),vec3(0.,0.,0.),normalize(N),R,0.,Color,false,false,true,false,1,id,true);\n    return O;\n}\n\nObj create_planDef4 (vec3 Origin, vec3 Vec1, vec3 Vec2, float Length1, float Length2, vec3 Color, int id) {\n    Obj O = Obj(Origin,normalize(Vec1),normalize(Vec2),normalize(cross(Vec1, Vec2)),Length1,Length2,Color,false,false,true,false,4,id,true);\n    return O;\n}\n\nObj create_planDef3 (vec3 Origin, vec3 Base, vec3 H, float BaseLength, float HLength, vec3 Color, int id) {\n    Obj O = Obj(Origin,normalize(Base),normalize(H),normalize(cross(Base, H)),BaseLength,HLength,Color,false,false,true,false,3,id,true);\n    return O;\n}\n\nObj create_cyl (vec3 Origin, vec3 Direction, float Height, float R, vec3 Color, int id) {\n    Obj O = Obj(Origin,normalize(Direction),vec3(0.,0.,0.),vec3(0.,0.,0.),Height,R,Color,false,true,false,false,0,id,true);\n    return O;\n}\n\nObj create_cone (vec3 Origin, vec3 Direction, float Hauteur, float Rbase, vec3 Color, int id) {\n    Obj O = Obj(Origin,normalize(Direction),vec3(0.,0.,0.),vec3(0.,0.,0.),Hauteur,Rbase,Color,false,false,false,true,0,id,true);\n    return O;\n}\n\n// Functions with Objects\n\nObj return_Obj (in int n, in float time) {\n    Obj O; vec3 icenter_feu;\n    \n    vec3 O_Maison = vec3(2.,0.,-0.5); vec3 V1= normalize(vec3(-0.3,0.,1.)); vec3 V2= normalize(vec3(1.,0.,0.3));\n    vec3 N = normalize(cross(V1,V2)); vec3 Color = vec3(0.8,0,0);\n    float L1 = 2.8; float L2 = 1.2; float H = 1.8; float Roof_H =0.6;\n    vec3 OriginBis = V1*L1 + V2*L2 + O_Maison + H*N;\n    vec3 O_Roof = O_Maison+N*H;\n    vec3 O_Roof2 = O_Roof+V2*L2+V1*L1;\n    \n    vec3 RoofTop = O_Roof+V2*L2/2.+V1*L1/2.+N*Roof_H;\n    \n    \n    if (n==0) {O = create_planDef1 (vec3(0.,0.,0.),vec3(0.,-1.,0.),100.,vec3(0.6,0.8,0.19),n);}\n    else if (n==1) {O = create_sphere (vec3(-70.,30.,200.),30.,vec3(0.9,0.9,0.1),n);O.Is_Visible = false;}\n    else if (n==2) {O = create_sphere (vec3(0.,0.05,0.),.1,vec3(0.9,0.1,0.1),n); O.Is_Visible = false;}\n    for(int i=0;i<6;i++){\n        icenter_feu = vec3(cos(float(i)*2.0*3.14/6.)*0.3,0,sin(float(i)*2.0*3.14/6.)*0.3);\n        if (n==3+i){O = create_sphere (icenter_feu,.1,vec3(0.5,0.5,0.5),n);}\n    };\n    if (n==9) {O = create_cyl (vec3(-0.7,0.1,0.7), vec3(1,0,1), 1.5, 0.25, vec3(0.3, 0.22, 0.15),n);}\n    else if (n==10) {O = create_planDef4 (O_Maison,V2,N,L2,H,Color,n);} \n    else if (n==11) {O = create_planDef4 (O_Maison,N,V1,H,L1,Color,n);} \n    else if (n==12) {O = create_planDef4 (OriginBis,-V2,-N,L2,H,Color,n);} \n    else if (n==13) {O = create_planDef4 (OriginBis,-N,-V1,H,L1,Color,n);}\n    for(int j=0;j<3;j++){\n        if (n==14+j) {O = create_sphere (vec3(0.,0.05+1.1*mod((time+float(j)*10./3.)*0.2,2.),0.),0.2*mod((time+float(j)*10./3.)*0.2,2.),vec3(1.,1.,1.),n); O.Is_Visible = false;}\n    };\n    if (n==17) {O = create_planDef3 (O_Roof, V2, (RoofTop-(O_Roof+V2*L2/2.)), L2, length(RoofTop-(O_Roof+V2*L2/2.)), vec3(0,0,1), n);}\n    else if (n==18) {O = create_planDef3 (O_Roof, V1, (RoofTop-(O_Roof+V1*L1/2.)), L1, length(RoofTop-(O_Roof+V1*L1/2.)), vec3(0,0,1), n);}\n    else if (n==19) {O = create_planDef3 (O_Roof+V2*L2+V1*L1, -V2, (RoofTop-(O_Roof2-V2*L2/2.)), L2, length(RoofTop-(O_Roof+V2*L2/2.)), vec3(0,0,1), n);}\n    else if (n==20) {O = create_planDef3 (O_Roof+V2*L2+V1*L1, -V1, (RoofTop-(O_Roof2-V1*L1/2.)), L1, length(RoofTop-(O_Roof+V1*L1/2.)), vec3(0,0,1), n);}\n    else if (n==21) {O = create_cyl (vec3(0.3,0.0,-1.05), vec3(0,1,0), 1., 0.05, vec3(0.3, 0.22, 0.15),n);}\n    else if (n==22) {O = create_cone (vec3(0.3,2.3,-1.05), vec3(0,1,0), 1.8, 0.4, vec3(0.1, 0.8, 0.15),n);}\n    ;  \n    return O;\n}\n\nbool intersect_Obj(in Ray R, in Obj O, out float t1, out float t2) {\n    if (O.Is_Sph) {\n        float a = pow(length(R.Dir),2.);\n        float b = 2.*dot(R.Dir,(R.Origin-O.Origin));\n        float c = pow(length(R.Origin-O.Origin),2.)-pow(O.Length1,2.);\n        float delta = pow(b,2.)-4.*a*c;\n        if(delta>=0.){\n            t1=(-b-sqrt(delta))/(2.*a);\n            if(t1<=0.){return false;};\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    \n    else if (O.Is_Cyl) {\n        vec3 x = R.Dir-dot(O.Vec1,R.Dir)*O.Vec1; vec3 y = R.Origin-O.Origin-(dot((R.Origin-O.Origin),O.Vec1)*O.Vec1);\n        float a = dot(x,x); float b = 2.*dot(x,y); float c = dot(y,y)- pow(O.Length2,2.);\n\n        float delta = pow(b,2.)-4.*a*c; bool result = false;\n    \n        if(delta>=0.){\n            t1 = (-b-sqrt(delta))/(2.*a);\n            t2 = (-b+sqrt(delta))/(2.*a);\n            if(t1>=0.){\n                vec3 M = R.Origin + R.Dir*t1;\n                vec3 Mproj = O.Origin + O.Vec1*dot(O.Vec1,M-O.Origin);\n                if (length(Mproj-O.Origin)<O.Length1/2.){result = true;}\n                else {t1 = 0.;};\n            }\n            if(t2>=0.){\n                vec3 M = R.Origin + R.Dir*t2;\n                vec3 Mproj = O.Origin + O.Vec1*dot(O.Vec1,M-O.Origin);\n                if (length(Mproj-O.Origin)<O.Length1/2.){result = true;}  \n                else {t2 = 0.;};\n            }\n        }\n        return result;\n    }\n    \n    else if (O.Is_Pla) {\n        if (dot(R.Dir,O.N)==0.) {return false;}\n        else {\n            float a = dot(O.N,R.Origin) -dot(O.N,O.Origin) ;\n            float b = dot(R.Dir,O.N);\n            t1 = -a/b; vec3 M = R.Origin +R.Dir*t1;\n            if (t1<=0.){return false;}\n            else {\n                if (O.P_nbSide == 0) {return true;}\n                else if (O.P_nbSide == 1) {\n                    if (length(M-O.Origin)<=O.Length1) {return true;}\n                    else {return false;};\n                }\n                else if (O.P_nbSide == 4) {\n                    vec3 P2 = O.Origin + normalize(O.Vec1)*O.Length1;\n                    vec3 P3 = O.Origin + normalize(O.Vec2)*O.Length2;\n        \n                    float alpha = dot(M-O.Origin,P2-O.Origin)/dot(P2-O.Origin,P2-O.Origin);\n                    float beta = dot(M-O.Origin,P3-O.Origin)/dot(P3-O.Origin,P3-O.Origin);\n        \n                    if (0.<=alpha && alpha<=1. && 0.<=beta && beta<=1.) {return true;}\n                    else {return false;};\n                }             \n                else if (O.P_nbSide == 3) {\n                    vec3 P1 = O.Origin; vec3 P2 = O.Origin + normalize(O.Vec1)*O.Length1;\n                    vec3 P3 = O.Origin + normalize(O.Vec2)*O.Length2+ normalize(O.Vec1)*O.Length1/2.;\n\n                    float dot1 = dot(cross(P2-P1,M-P1),cross(M-P1,P3-P1));\n                    float dot2 = dot(cross(P1-P2,M-P2),cross(M-P2,P3-P2));\n                    float dot3 = dot(cross(P1-P3,M-P3),cross(M-P3,P2-P3));\n        \n                    if (0.<dot1 && 0.<dot2 && 0.<dot3) {return true;}\n                    else {return false;};\n                }\n            }\n        }    \n    }\n    \n    else if (O.Is_Cone) {\n        float ConeAngle = tan(O.Length2/O.Length1);\n        float alpha = dot(R.Origin-O.Origin,O.Vec1); float beta = dot(R.Dir,O.Vec1);\n        float coef = pow(tan(ConeAngle),2.);\n        vec3 Vec = R.Origin - O.Origin; float epsilon= 0.0001;\n\n        float a = -pow(dot(O.Vec1,R.Dir),2.) +pow(length(R.Dir),2.) - coef * pow(beta,2.);\n        float b = 2.*(-dot(Vec,O.Vec1)*dot(R.Dir,O.Vec1)+dot(Vec,R.Dir)) - 2. * coef*alpha*beta;\n        float c = pow(length(Vec),2.)- pow(dot(O.Vec1,Vec),2.) - coef * pow(alpha,2.);\n        float delta = pow(b,2.)-4.*a*c;\n        if (delta < 0.) {return false;};\n\n        t1 = (-b - sqrt(delta))/(2.*a); t2 = (-b + sqrt(delta))/(2.*a);\n        if (t1 < 0.+epsilon){ if (t2 < 0.+epsilon) {return false;}; t1 = t2; t2=0.;};\n\n        vec3 M = R.Origin + R.Dir * t1;\n        vec3 Mproj = O.Origin + O.Vec1*dot(M-O.Origin,O.Vec1);\n        if (dot(Mproj-O.Origin,O.Vec1)>0.) return(false);\n\n        if (length(Mproj-O.Origin)>O.Length1) {return(false);};\n        return(true);  \n    };\n} \n\nint firstObj (in Ray R, in float Time) {\n    float t=9999999999999999999.9; float t1; float t2; Obj O; int result = NB_OBJ;\n    for (int i=0; i<NB_OBJ; i++){\n        O = return_Obj (i, Time);\n        t1=0.; t2=0.;\n        if (intersect_Obj(R, O, t1, t2)) {\n            if (t1>0. && t1<t) {t=t1; result = i;}\n            else if (t2>0. && t2<t) {t=t2; result = i;}\n        }\n      \n    }\n    return result;\n}\n\nint firstObj_Visible (in Ray R, in float Time) {\n    float t=9999999999999999999.9; float t1; float t2; Obj O; int result = NB_OBJ;\n    for (int i=0; i<NB_OBJ; i++){\n        O = return_Obj (i, Time);\n        t1=0.; t2=0.;\n        if (intersect_Obj(R, O, t1, t2)) {\n            if (O.Is_Visible) {\n                if (t1>0. && t1<t) {t=t1; result = i;}\n                else if (t2>0. && t2<t) {t=t2; result = i;}\n            }\n        }\n      \n    }\n    return result;\n}\n\nvec3 interact_Lum(in Lum L, in Obj O, in vec3 M, in bool Inside) {\n    vec3 col; int i;\n    \n    if (O.Is_Pla) {\n        vec3 d = normalize(L.Center - M);\n        vec3 n = normalize(-O.N);\n        float cosTheta = dot(n,d);\n        if (cosTheta<0.) {cosTheta=0.;};\n        col = col + O.Color*L.Color*cosTheta;\n    }\n    \n    else if (O.Is_Sph) {\n        vec3 d = normalize(L.Center - M);\n        vec3 n = normalize(M - O.Origin);\n        float cosTheta = dot(n,d);\n        if (cosTheta<0.) {cosTheta=0.;};\n        col = col + O.Color*L.Color*cosTheta;\n    }\n    \n    else if (O.Is_Cyl) {\n        if (Inside) {\n            vec3 Mproj = O.Origin + O.Vec1*dot(O.Vec1,M-O.Origin);\n            vec3 d = normalize(L.Center - M);\n            vec3 n = -normalize(M - Mproj);\n\n            Ray R; R.Origin = L.Center; R.Dir = -d;\n            float t1; float t2;\n            float cosTheta = dot(n,d);\n        \n            bool doublinter = intersect_Obj (R, O, t1, t2);\n            if (t1>0. && t2>0.) {cosTheta=0.;};\n            if (cosTheta<0.) {cosTheta=0.;};\n            col = O.Color*L.Color*cosTheta;\n        \n        }\n        else {\n            vec3 Mproj = O.Origin + O.Vec1*dot(O.Vec1,M-O.Origin);\n            vec3 d = normalize(L.Center - M);\n            vec3 n = normalize(M - Mproj);\n            float cosTheta = dot(n,d);\n            if (cosTheta<0.) {cosTheta=0.;};\n            col = O.Color*L.Color*cosTheta;\n        }\n    }\n    \n    else if (O.Is_Cone) {\n        vec3 Mproj = O.Origin + O.Vec1*dot(M-O.Origin,O.Vec1); float ConeAngle = tan(O.Length2/O.Length1);\n        vec3 VecNormal = normalize(M-Mproj);\n        vec3 N = cos(ConeAngle)*VecNormal + sin(ConeAngle)*O.Vec1*(-sign(dot(Mproj-O.Origin,O.Vec1)));\n        vec3 d = normalize(L.Center - M);\n        float cosTheta = dot(N,d);\n        if (cosTheta<0.) {cosTheta=0.;};\n        col = col + O.Color*L.Color*cosTheta;\n    };\n    \n    return col;\n\n}\n\nvec3 return_Col (in Lum[NB_LUM] ListLum, in Obj O, in vec3 M, in bool Inside, in float time) {\n    Ray R; float t; int numObj; vec3 col;\n    for (int l=0;l<NB_LUM; l++) {\n        Lum L = ListLum[l];\n        R.Origin = L.Center; R.Dir = M - L.Center; //Def du Rayon\n        numObj = firstObj_Visible(R,time);\n        if(O.id == numObj) {col = col + interact_Lum(L,O,M,Inside);};\n    }\n    return col;\n}\n\n// Print Result\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){   \n    vec2 xy = fragCoord.xy / iResolution.xy;\n    vec3 col = mix(vec3(0.8,0.6,0), vec3(0.8,0.2,0.6), xy.y/1.5);\n    Camera C = camera(vec3(cos(0.1*iTime)*4., 0.8,sin(0.1*iTime)*4.), vec3(0., 0., 0.), 50.0);\n    \n    Ray R = launch(C,fragCoord);\n    \n    int n = firstObj (R, iTime); vec3 M; Lum ListLum[NB_LUM] = Lum[NB_LUM] (\n    Lum(vec3(0.,10.,0.),1.,vec3(1,1,1),1.),\n    Lum(vec3(0.,0.05,0.),1.,vec3(0.5+abs(cos(3.*iTime*3.14)/2.),0.1+abs(sin(iTime*3.14)/3.),0),1.)\n    );\n    \n    if (n != NB_OBJ) {\n        float t1; float t2;\n        if (intersect_Obj(R, return_Obj(n, iTime), t1, t2)) {\n        Obj O = return_Obj(n, iTime);\n            if (t1 > 0.) {\n                M = C.Obs +R.Dir*t1;\n                if (O.Is_Visible) {col = return_Col (ListLum, O, M, false, iTime);}\n                else if (n==2) {col=ListLum[1].Color;}\n                else {col=O.Color;};\n                if (n>=10 && n<=13) {if (mod(70.*M.y,10.)<1.) {col = col*0.9;};};\n                if (n >=14  && n <= 16) {\n                    float theta = atan(M.z - O.Origin.z, M.x - O.Origin.x);\n                    float phi = acos((M.y - O.Origin.y) / O.Length1);\n\n                    vec2 sphereCoor = vec2(theta / (2.0 * 3.14), phi / 3.14);\n                    vec3 textureColor = texture(iChannel0, sphereCoor).xyz;\n                    col = mix(textureColor, O.Color, 0.7);\n                }\n            }\n            else if (t2 > 0.) {\n                M = C.Obs +R.Dir*t2;\n                if (O.Is_Visible) {col = return_Col (ListLum, O, M, true, iTime);}\n                else {col=O.Color;};            \n            };\n\n        }\n    }\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}