{"ver":"0.1","info":{"id":"WsG3z1","date":"1572617293","viewed":285,"name":"Cellular Motion","username":"sgfx","description":"Living cells","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","cells"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision highp float;\nuniform float fft;\nuniform float fftLowerFrc;\nuniform float fftUpperFrc;\n\n// Return a pseudo-random 0-1 vec2 for each floored value of the input\nvec2 rand2(vec2 p) {\n\t// Turn the vector into a integer id\n    p = floor(p);\n    \n    // Pseudo-randomness...\n    // from https://www.shadertoy.com/view/4djSRW\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.01031, .01010, .00973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// Triple-frequency sine wave, for variation on a vec2\nvec2 sin3(vec2 j, vec3 freq) {\n    j.x = sin(freq.x * j.x) + sin(freq.y * j.x) + sin(freq.z * j.x);\n    j.y = sin(freq.x * j.y) + sin(freq.y * j.y) + sin(freq.z * j.y);\n    j /= 3.0;\n    return j;\n}\n\nfloat smoothmin(float a, float b, float s) {\n    float j = clamp((b - a) / s + 0.5, 0.0, 1.0);\n    float k = j * (1. - j);\n    return a * j + (1. - j) * b - k * s * 0.5;\n}\n\nfloat smootthreshold(float a, float x, float s) {\n    return mix(a, 1.0, smoothstep(x - s, x + s, a));\n}\n\n// Cellular motion, it's a voronoi with some fancy motion\n// Voronoi is pretty much a random collection of points that\n// shows the distance from each point to the next-closest point\nfloat vor_cells(vec2 uv, float tile, float speed, float s, float threshold,\n                float edge_smooth, float seed) {\n    // Time offset, so the motion doesn't start from a grid layout\n    float t_offset = 9999.0;\n\n    // Coordinates for a 'grid' of cells\n    uv *= tile;\n\n    // -0.5 to 0.5 uv coordinate per grid cell\n    vec2 cell_uv = fract(uv) - 0.5;\n\n\t// Find the distance from the current cells's random\n    // position to the next closest\n    float min_dist = 100.0;\n    // Loop through the surrounding grid cells, normally you'd just go\n    // one grid cell in each direction, but because the motion is larger\n    // than just the current grid cell, we go two grid cells in each direction\n    for(float x = -2.0; x <= 2.0; x++) {\n        for(float y = -2.0; y <= 2.0; y++){\n            // Offset from the current grid cell\n            vec2 offset = vec2(x, y);\n            // Get a noise value for random cell motion\n            vec2 noise = rand2(uv + offset);\n            // Motion frequency for our triple-sine\n            vec3 freq = vec3(1.0, 2.67, 3.3676);\n            // Animate the cell position\n            vec2 pos = offset + sin3((noise * (iTime * speed + t_offset)), freq);\n\n            // Find distance to the offset cell\n            float size = sin((noise.x * noise.y * 398.67) + (iTime * speed) + t_offset) * .45 - smoothstep(0.2,1.,fftLowerFrc) * 0.5;\n            float dist = distance(cell_uv, pos) - size;\n            //min_dist = clamp(min(dist, min_dist), 0.0, 1.0);\n            min_dist = clamp(smoothmin(dist, min_dist, s), 0.0, 1.0);\n        }\n    }\n\t// Keep the distance of the closest cell\n    float cells = min_dist / 1.2;\n\n    cells = smootthreshold(cells, threshold, edge_smooth);\n    cells = pow(cells, 7.0);\n    cells = 1.0 - pow(1.0 - cells, 24.0);\n\n    return cells;\n}\n\n// Circular gradient to look like a lens vignette\nfloat vignette(vec2 uv, vec2 pos, float radius, float falloff) {\n    float v = dot(uv - pos, uv - pos);\n    v /= radius;\n    v = pow(v, falloff);\n    return 1.0 - v / radius;\n}\n\n// Turn a grayscale input into a 3 color gradient\nvec3 mix3(vec3 a, vec3 b, vec3 c, float x) {\n    vec3 m = mix(a, b, clamp(x * 2.0, 0.0, 1.0));\n    m = mix(m, c, clamp(((x - 0.5) * 2.0), 0.0, 1.0));\n    return m;\n}\n\nfloat quantize(float i, float steps) {\n    return floor(i * steps) / steps;\n}\n\n// Film grain, basically a simplified version of cells, with random negative\n// cell values, time is quantized to film framerate\nfloat filmgrain(vec2 uv, float scale, float var, float strength) {\n    uv *= scale;\n    vec2 cell_uv = fract(uv) - 0.5;\n    float qtime = quantize(iTime, 24.);\n\n    float grain = 1.0;\n    for(float x = -1.; x <= 1.; x++) {\n        for(float y = -1.; y <= 1.; y++) {\n            vec2 offset = vec2(x, y);\n            vec2 noise = rand2(uv + offset);\n            vec2 pos = offset + sin(noise * qtime) * 0.5;\n            float size = sin((noise.x * noise.y * 654.387) + qtime) * var;\n            float d = 1.0 - clamp(distance(cell_uv, pos), 0.0, 1.0);\n            // randomize greyscale value\n            grain -= d * sin((noise.x * noise.y * 159.876) * qtime) * strength;\n        }\n    }\n    return grain;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    // Offset canvas UV by mouse position\n    vec2 mouse_uv = uv - iMouse.xy/iResolution.xy;\n\n    float fade = 0.0;\n    float tile = 4.5;\n    float speed = 0.1;\n\n    // Black canvas to start\n    vec3 color = vec3(0.0);\n\n    // Main cells\n    float cells = vor_cells(mouse_uv, tile, speed + smoothstep(0.,0.4,fftLowerFrc) * 0.0005, 0.2, 0.65, 0.02, 0.0);\n    // Second layer of cells for secondary motion and variation\n    float cells2 = vor_cells(mouse_uv * 0.666, tile, speed*1.5 + smoothstep(0.,0.5,fft) * 0.002, 0.75, 1.0, 0.5, 50.0);\n\t// Blend the cell layers together\n    //cells = mix(cells, cells2, 0.1);\n    cells += cells2 * 0.1 + smoothstep(0.1,0.5,fft)*0.075;\n    cells *= 1.0 - pow(uv.y,2.);\n\n    // Cell colorization\n    vec3 a = vec3(0.9, 0.8, 0.5);\n    vec3 b = vec3(0.7, 0.125, 0.13);\n    vec3 c = vec3(0.2, 0.1, 0.06);\n    color += mix3(a, b, c, 1.0 - cells);\n\n    // Apply vignette\n    float vig = vignette(uv, vec2(0.0), 2.25 - smoothstep(0.,1.,clamp(fftLowerFrc-.1,0.,1.)) * 0.1, 1.0);\n    color *= vig;\n\n    // Apply film grain\n    float grain = filmgrain(uv, 192., 24., 0.06 + fftUpperFrc*.1);\n    // Mask grain mostly to darker areas\n    grain = clamp((grain + cells * 0.75), 0.0, 1.0);\n    color *= grain;\n\n    // Flicker\n    float flicker = sin(iTime * 48.0);\n    flicker = 1.0 - (0.5 * flicker + 1.0) * 0.01;\n    color *= flicker;\n\n    // Output\n    fragColor = vec4( color, 1.0 );\n}","name":"Image","description":"","type":"image"}]}