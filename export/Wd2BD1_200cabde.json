{"ver":"0.1","info":{"id":"Wd2BD1","date":"1589963810","viewed":289,"name":"Tree bark texture","username":"jstrom2002","description":"Attempt to create a procedural tree bark texture using the fire palate and other voronoi patterns from 'Combustible Voronoi' by Shane: https://www.shadertoy.com/view/4tlSzl.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["texture","tree","bark"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//The following functions are from: \n//'Combustible Voronoi' https://www.shadertoy.com/view/4tlSzl\nvec3 firePalette(float i){\n\n    float T = 1400. + 2200.*i; // Temperature range (in Kelvin).\n    vec3 L = vec3(8.15, 6.6, 5.8); // Red, green, blue wavelengths (in hundreds of nanometers).\n    L = pow(L,vec3(4.0)) * (exp(1.43876719683e5/(T*L))-1.0);\n    return 1.0-exp(-5e6/L); // Exposure level. Set to \"50.\" For \"70,\" change the \"5\" to a \"7,\" etc.\n}\nvec3 hash33(vec3 p){ \n    \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152.011, 262144.984, 32768.115)*n); \n}\nfloat voronoi(vec3 p){\n\n\tvec3 b, r, g = floor(p);\n\tp = fract(p); // \"p -= g;\" works on some GPUs, but not all, for some annoying reason.\n\t\n\tfloat d = 0.5; \n\n    for(float j = -1.; j <= 1.; j++) {\n\t    for(float i = -1.; i <= 1.; i++) {\n    \t\t\n\t\t    b = vec3(i, j, -1.);\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n    \t\t\n\t\t    b.z = 0.0;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n    \t\t\n\t\t    b.z = 1.;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n    \t\t\t\n\t    }\n\t}\n\t\n\treturn d; // Range: [0, 1]\n}\n\nfloat noiseLayers(in vec3 p) {\n    vec3 t = vec3(0., 0., 0.);\n\n    const int iter = 5; // Just five layers is enough.\n    float tot = 0.08, sum = 0., amp = 0.5; // Total, sum, amplitude.\n\n    for (int i = 0; i < iter; i++) {\n        tot += voronoi(p + t) * amp; // Add the layer to the total.\n        p *= 2.0; // Position multiplied by two.\n        t *= 1.5; // Time multiplied by less than two.\n        sum += amp; // Sum of amplitudes.\n        amp *= 0.5; // Decrease successive layer amplitude, as normal.\n    }\n    \n    return tot/sum; // Range: [0, 1].\n}\n//=================================================================\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Use UV coordinates in range x = [-0.25, 0.25], y = [-0.025, 0.025].\n    vec2 uv = (vec2(fragCoord.x/iResolution.x, fragCoord.y/iResolution.y));\n    uv *= vec2(2.0, 0.20);//scale vertically to replicate tree bark\n    uv -= vec2(1.0, 0.1);\n    uv *= 0.25;\n    \n    // Constructing the unit ray. \n\tvec3 rd = normalize(vec3(uv.x, uv.y, 3.1415926535898/8.));\n\n    // Rotating the ray about the XY plane, to simulate a rolling camera.\n\tfloat cs = cos(-0.15), si = sin(0.25);\n    // Apparently \"r *= rM\" can break in some older browsers.\n\trd.xy = rd.xy*mat2(cs, -si, si, cs); \n\t\n\t// Passing a unit ray multiple into the Voronoi layer function, which \n\t// is nothing more than an fBm setup with some time dialation.\n\tfloat c = noiseLayers(rd*28.8);\n\t\n\t// Optional: Adding a bit of random noise for a subtle dust effect. \n\tc = max(c + dot(hash33(rd)*2.-1., vec3(0.015)), 0.);\n\n    // Adjust color output to match bark.\n    vec3 col =  (((vec3(0.5) - firePalette(c))*0.3) + vec3(0.120,0.055,0.40)) * vec3(7.3,1.65,0.85);   \n    col = vec3(dot(col.rgb, vec3(0.299, 0.587, 0.114)));//convert to grayscale\n    \n\t// Done.\n\tfragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}