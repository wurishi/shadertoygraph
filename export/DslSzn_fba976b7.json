{"ver":"0.1","info":{"id":"DslSzn","date":"1669999371","viewed":79,"name":"Newton's Fractal (JoeBiden Edit)","username":"Retard_Gaming","description":"Newtons fractal with given roots\nMove the cursor to see how a point moves\nShaded based on how fast it reaches a root","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["fractal","newton","newtonsmethod"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define showRoots 1\n// adds in the point controlled by the mouse\n#define mousePoint 1\n// set to 1 to remove shading\n#define flatShading 0\n// use textures (3 or more roots)\n#define useTextures 0\n\n// roots and colors are in Common\n\n// xy - bottom left, zw - top right\nvec4 screen = vec4(-2.2,-1.2,1.2,1.2);\n\nfloat seg(vec2 p, vec2 a, vec2 b, float r)  {\n    vec2 g = b - a;\n    vec2 h = p - a;\n    float d = Q_length(h - g * clamp(dot(g, h) / dot(g,g), 0.0, 1.0));\n\treturn smoothstep(r, 0.5*r, d);\n}\n\nfloat minDistToRoot(vec2 uv) {\n    float d = 1000000.;\n    for(int i = 0; i < root.length(); i++) {\n        d = min(d, Q_length(uv - root[i]));\n    }\n    return d;\n}\n\nvec2 fractal(vec2 p) {\n    vec2 uv = p;\n    for(int i = 0; i < 30; i++) {\n        uv -= cdiv(func(uv),der(uv));\n        // break early if close enough to root\n        if(minDistToRoot(uv) < 0.01) {\n            break;\n        }\n    }\n    return uv;\n}\n\nvec3 colFractal(vec2 p) {\n    vec2 uv = p;\n    float l = 0.;\n    for(int i = 0; i < 30; i++) {\n        vec2 temp = uv;\n        uv -= cdiv(func(uv),der(uv));\n        // break early if close enough to root\n        for(int i = 0; i < root.length(); i++) {\n            // add more zeros to make shading smoother\n            if (Q_length(uv - root[i]) < 0.001) {\n#if flatShading\n                return cols[i];\n#else\n                vec3 shadedCol = clamp(cols[i]/(log2(l + 2.)), 0., 1.); // the darker it is, the longer it takes to reach the root\n                return mix(shadedCol, cols[i], 0.1); // brighten the darkest areas\n#endif\n            }\n        }\n        l += Q_length(temp - uv);\n    }\n    return vec3(0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    //root[0] += vec2(cos(iTime), sin(iTime))/2.;\n    \n#if useTextures\n    cols[1] = texture(iChannel0, fragCoord/iResolution.xy).rgb;\n    cols[2] = texture(iChannel1, fragCoord/iResolution.xy).rgb;\n    cols[0] = texture(iChannel2, fragCoord/iResolution.xy).rgb;\n#endif\n    \n    vec2 uv = mix(screen.xy, screen.zw, fragCoord/iResolution.xy);\n    vec3 col = colFractal(uv);\n#if mousePoint\n    vec2 p = mix(screen.xy, screen.zw, iMouse.xy/iResolution.xy);\n  \n    for(int i = 0; i < 30; i++) {\n        bool b = false;\n        for(int i = 0; i < root.length(); i++) {\n            if(Q_length(p - root[i]) < 0.0001) {\n                b = true;\n            }\n        }\n        //credit to https://www.shadertoy.com/user/Envy24\n        col = mix( col, vec3(0), smoothstep(4./iResolution.y, 0., diskSDF_L2(uv, p, 0.03)) );\n        \n        vec2 temp = p;\n        p -= cdiv(func(p),der(p));\n        col += seg(uv, p, temp, 0.01);\n        if (b) break;\n    }\n#endif\n#if showRoots\n    for(int i = 0; i < root.length(); i++) {\n        //credit to https://www.shadertoy.com/user/Envy24\n        col = mix( col, vec3(1), smoothstep(4./iResolution.y, 0., diskSDF_L2(uv, root[i], 0.03)) );\n    }\n#endif\n    // Output to screen\n    fragColor = vec4(col ,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// make sure there are the same number of colors as there are roots\nvec2 root[3] = vec2[] (\n    vec2(0.5,0),\n    vec2(-1,0.86603),\n    vec2(-1,-0.86603)\n);\n\nvec3 cols[3] = vec3[] (\n    vec3(1, 0, 0),\n    vec3(0, 1, 0),\n    vec3(0, 0, 1)\n);\n\n// complex multiplication and division\nvec2 cmult(vec2 a, vec2 b) {\n    return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\nvec2 cdiv(vec2 a, vec2 b) {\n    vec2 o = vec2(a.x*b.x + a.y*b.y, a.y*b.x - a.x*b.y);\n    return o / dot(b, b);\n}\n\n// complex polynomial given roots\nvec2 func(vec2 uv) {\n    vec2 o = vec2(1,0);\n    for(int i = 0; i < root.length(); i++) {\n        o = cmult(o, (uv - root[i]));\n    }\n    return o;\n}\n\n// dirivative of previous function\nvec2 der(vec2 uv) {\n    vec2 o = vec2(0, 0);\n    for (int i = 0; i < root.length(); i++) {\n        vec2 p = vec2(1, 0);\n        for (int j = 0; j < root.length(); j++) {\n            if (i != j) {\n                p = cmult(p, uv - root[j]);\n            }\n        }\n        o += p;\n    }\n    return o;\n}\n\n// thanks https://www.shadertoy.com/user/Envy24\nfloat diskSDF_L2(in vec2 NDC, in vec2 C, in float r) { return length(C - NDC)-r; }\n\n// using these saved ~3 fps\nfloat Q_sqrt(float x) {\n    float o = uintBitsToFloat((floatBitsToUint(x) >> 1) + 0x1FBC0000u);\n    o = 0.5 * (o + x / o); // newton method\n    return o;\n}\n\nfloat Q_length(vec2 p) {\n    return Q_sqrt(dot(p, p));\n}\n","name":"Common","description":"","type":"common"}]}