{"ver":"0.1","info":{"id":"ttyczd","date":"1611576019","viewed":236,"name":"Oklab ACES Comparison","username":"shader_king","description":" Image    |Not Tonemapped|\n Image    |  oklab   |  aces   |\n\nTop - Not Tonemapped | Bottom left oklab | Bottom right aces|\n\nForked from afl_ext","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["tonemapping","tonemap","oklab"],"hasliked":0,"parentid":"3lGyRy","parentname":"Oklab-based tonemapper"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 positionTC = (fragCoord/iResolution.xy)* 2.0 - 1.0;\n    vec2 position = positionTC;\n    position.x += iTime * 0.2;\n\n\tvec3 color = pow(sin(position.x * 4.0 + vec3(0.0, 1.0, 2.0) * 3.1415 * 2.0 / 3.0) * 0.5 + 0.5, vec3(2.0)) * (exp(abs(position.y) * 4.0) - 1.0);;\n\n\tif(position.y < 0.0)\n    {\n\t\tcolor = tonemap(color, positionTC);   \n\t}\n    else\n    {\n        color = Srgb3(color);\n    }\n\n\tfragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define F1 float\n#define F3 vec3\n\nF1 Linear1(F1 c){return(c<=0.04045)?c/12.92:pow((c+0.055)/1.055,2.4);}\nF3 Linear3(F3 c){return F3(Linear1(c.r),Linear1(c.g),Linear1(c.b));}\nF1 Srgb1(F1 c){return(c<0.0031308?c*12.92:1.055*pow(c,0.41666)-0.055);}\nF3 Srgb3(F3 c){return F3(Srgb1(c.r),Srgb1(c.g),Srgb1(c.b));}\n\nvec3 rgb_to_oklab(vec3 c) \n{\n    float l = 0.4121656120f * c.r + 0.5362752080f * c.g + 0.0514575653f * c.b;\n    float m = 0.2118591070f * c.r + 0.6807189584f * c.g + 0.1074065790f * c.b;\n    float s = 0.0883097947f * c.r + 0.2818474174f * c.g + 0.6302613616f * c.b;\n\n    float l_ = pow(l, 1./3.);\n    float m_ = pow(m, 1./3.);\n    float s_ = pow(s, 1./3.);\n\n    vec3 labResult;\n    labResult.x = 0.2104542553f*l_ + 0.7936177850f*m_ - 0.0040720468f*s_;\n    labResult.y = 1.9779984951f*l_ - 2.4285922050f*m_ + 0.4505937099f*s_;\n    labResult.z = 0.0259040371f*l_ + 0.7827717662f*m_ - 0.8086757660f*s_;\n    return labResult;\n}\n\nvec3 oklab_to_rgb(vec3 c) \n{\n    float l_ = c.x + 0.3963377774f * c.y + 0.2158037573f * c.z;\n    float m_ = c.x - 0.1055613458f * c.y - 0.0638541728f * c.z;\n    float s_ = c.x - 0.0894841775f * c.y - 1.2914855480f * c.z;\n\n    float l = l_*l_*l_;\n    float m = m_*m_*m_;\n    float s = s_*s_*s_;\n\n    vec3 rgbResult;\n    rgbResult.r = + 4.0767245293f*l - 3.3072168827f*m + 0.2307590544f*s;\n    rgbResult.g = - 1.2681437731f*l + 2.6093323231f*m - 0.3411344290f*s;\n    rgbResult.b = - 0.0041119885f*l - 0.7034763098f*m + 1.7068625689f*s;\n    return rgbResult;\n}\n\n// original copy right\n//=================================================================================================\n//\n//  Baking Lab\n//  by MJP and David Neubelt\n//  http://mynameismjp.wordpress.com/\n//\n//  All code licensed under the MIT license\n//\n//=================================================================================================\n\n// sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT\nconst mat3 ACESInputMat = mat3(\n    0.59719, 0.35458, 0.04823,\n    0.07600, 0.90834, 0.01566,\n    0.02840, 0.13383, 0.83777\n);\n\n// ODT_SAT => XYZ => D60_2_D65 => sRGB\nconst mat3 ACESOutputMat = mat3(\n     1.60475, -0.53108, -0.07367,\n    -0.10208,  1.10813, -0.00605,\n    -0.00327, -0.07276,  1.07602\n);\n\nvec3 RRTAndODTFit(vec3 v)\n{\n    vec3 a = v * (v + 0.0245786f) - 0.000090537f;\n    vec3 b = v * (0.983729f * v + 0.4329510f) + 0.238081f;\n    return a / b;\n}\n\n\nvec3 rgb_to_aces(vec3 c) \n{\n    return ACESInputMat * c;\n}\n\n\nvec3 aces_to_rgb(vec3 c) \n{\n    return ACESOutputMat * c;\n}\n\nvec3 tonemap( vec3 linearRGB, vec2 position )\n{\n    const float limitHardness = 1.5;\n    \n    vec3 okl = vec3(0.0);\n    if(position.x < 0.0)\n    {\n        okl = rgb_to_oklab(linearRGB);\n    }\n    else\n    {\n        okl = rgb_to_aces(linearRGB);\n    }\n    \n    // Limit luminance.\n    /*okl.x = okl.x / pow(pow(okl.x, limitHardness) + 1., 1./limitHardness);\n    \n    // Limit magnitude of chrominance.\n    {\n        float mag = length(okl.yz);\n        float magAfter = mag;\n        magAfter *= 4.;\n        magAfter = magAfter / pow(pow(magAfter, limitHardness) + 1., 1./limitHardness);\n        magAfter /= 4.;\n        okl.yz *= magAfter/mag;\n    }*/\n    \n    if(position.x < 0.0)\n    {\n        linearRGB = oklab_to_rgb(okl);\n    }\n    else\n    {\n        linearRGB = aces_to_rgb(okl);\n    }\n\n    // Try to keep the resulting value within the RGB gamut while\n    // preserving chrominance and compensating for negative clipping.\n    {\n\n        {\n            // Compensate for negative clipping.\n            float lumBefore = dot(linearRGB, vec3(0.2126, 0.7152, 0.0722));\n            linearRGB = max(vec3(0), linearRGB);\n            float lumAfter = dot(linearRGB, vec3(0.2126, 0.7152, 0.0722));\n            linearRGB *= lumBefore/lumAfter;\n            \n            // Keep the resulting value within the RGB gamut.\n            linearRGB = linearRGB / pow(pow(linearRGB, vec3(limitHardness)) + vec3(1), vec3(1./limitHardness));\n        }\n        \n\n    }\n        \n  \n    return Srgb3(linearRGB);\n}","name":"Common","description":"","type":"common"}]}