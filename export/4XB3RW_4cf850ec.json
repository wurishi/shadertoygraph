{"ver":"0.1","info":{"id":"4XB3RW","date":"1708237786","viewed":41,"name":"ASSIGNMENT YEAH WOO","username":"Meat_Sweats","description":"hi connor","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["movingballs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MIN_DIST 0.001\n#define MAX_DIST 100.0\n\nvec3 rotate(vec3 p, vec3 axis, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    mat3 rotationMatrix = mat3(\n        axis.x * axis.x * oc + c,\n        axis.x * axis.y * oc - axis.z * s,\n        axis.x * axis.z * oc + axis.y * s,\n        \n        axis.x * axis.y * oc + axis.z * s,\n        axis.y * axis.y * oc + c,\n        axis.y * axis.z * oc - axis.x * s,\n        \n        axis.x * axis.z * oc - axis.y * s,\n        axis.y * axis.z * oc + axis.x * s,\n        axis.z * axis.z * oc + c\n    );\n    \n    return rotationMatrix * p;\n}\n\nfloat sdSphere(vec3 p, float radius) {\n    return length(p) - radius;\n}\n\nfloat map(vec3 p) {\n    p = rotate(p, vec3(1.0, 1.0, 0.0), iTime); //rotate around the diagonal axis\n    \n    float d1 = sdSphere(p, 0.5); //1sphere\n    float d2 = sdSphere(p - vec3(0.5, 0.5, 0.5), 0.3); //2sphere\n    \n    return min(d1, d2);\n}\n\nvec3 calculateNormal(vec3 p) {\n    vec2 eps = vec2(0.001, 0.0);\n    return normalize(vec3(\n        map(p + eps.xyy) - map(p - eps.xyy),\n        map(p + eps.yxy) - map(p - eps.yxy),\n        map(p + eps.yyx) - map(p - eps.yyx)\n    ));\n}\n\nvec3 rayMarch(vec3 origin, vec3 direction) {\n    float totalDist = 1.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = origin + totalDist * direction;\n        float dist = map(p);\n        totalDist += dist;\n        if (dist < MIN_DIST || totalDist > MAX_DIST) \n            break;\n    }\n    \n    if (totalDist > MAX_DIST) \n        return vec3(0.0);\n    else \n        return origin + totalDist * direction;\n}\n\nvec3 getGradient(vec3 p) {\n    float eps = 0.01;\n    return normalize(vec3(\n        map(p + vec3(eps, 0.0, 0.0)) - map(p - vec3(eps, 0.0, 0.0)),\n        map(p + vec3(0.0, eps, 0.0)) - map(p - vec3(0.0, eps, 0.0)),\n        map(p + vec3(0.0, 0.0, eps)) - map(p - vec3(0.0, 0.0, eps))\n    ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 origin = vec3(0.0, 0.0, -2.0); //cam pos\n    \n    //from camera through pixel\n    vec3 direction = normalize(vec3(uv - 0.5, 1.0));\n    \n    vec3 hitPoint = rayMarch(origin, direction);\n    vec3 normal = calculateNormal(hitPoint);\n    \n    // ray didn't hit anything, set background color\n    if(hitPoint.x == 0.0 && hitPoint.y == 0.0 && hitPoint.z == 0.0) {\n        fragColor = vec4(1.0, 0.5, 0.0, 0.0) * sin(iTime) * 0.5 + 0.5;//bg color\n        return;\n    }\n    \n    //lighting\n    vec3 lightDir = normalize(vec3(1.0, 1.0, -1.0));\n    float diffuse = max(0.0, dot(normal, lightDir));\n    vec3 reflectedLight = reflect(-lightDir, normal);\n    float specular = pow(max(dot(reflectedLight, -direction), 0.0), 32.0);\n    \n    \n    //object color\n    vec3 color = vec3(0.7, 1.0, 0.7) * diffuse + vec3(1.0) * specular;\n    \n    fragColor = vec4(color, 0.5);\n}\n\n","name":"Image","description":"","type":"image"}]}