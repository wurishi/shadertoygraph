{"ver":"0.1","info":{"id":"wdBBWK","date":"1590807113","viewed":426,"name":"Multipass SDF Rendering","username":"sdfgeoff","description":"To render more SDF's, render first a low-resolution, high accuracy one, then do a final pass at full resolution but with a higher surface tolerance. The first pass is low resolution, and the second pass just \"refines\" the image and is quick to render.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["sdf","performance","multipass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// How can you draw a complex SDF? You have to evaluate the SDF function as\n// few times as possible, because it's by far the most expensive part\n// \n// This example evaluates the SDF at a low resolution to get a ballpark \"guess\"\n// for where the surface is. Then another pass refines the image.\n// Finally, the Image pass converts a distance field into a normal map allowing a\n// simple deferred rendering.\n//\n// Why is this fast?\n// 1) The low res SDF is at a low resolution, so it can have a tight surface tolance\n//    and a high max-step count without significantly affecting framerate. This means\n//    it can jump past nearby surfaces quickly\n// 2) The high res pass then just has to refine the distance a touch to \"smooth\" it\n//    meaning it can have a larger surface tolerance and a lower maximum steps to\n//    reduce rendertime\n//\n// On my laptop as currently configured, this achieves 60FPS\n// Disabling the low res buffer and tweaking the steps of the high res buffer to \n// achieve a similar result runs at closer to 20FPS.\n//\n// Have a play with the values defined in the Common buffer.\n//\n// Possible improvements:\n// 0) Fix the calculation of the normals in the final compositing\n// 1) The high res buffer should sample the normals rather than them being calculated\n//    in the image. This would avoid issues where there are distance discontinuities\n//    (ie around objects)\n\n#define BUFFER_STATE iChannel0\n#define BUFFER_LOW_RES_SDF iChannel1\n#define BUFFER_HIGH_RES_SDF iChannel2\n#define BUFFER_WORLD_MAP iChannel3\n\n\n\n//#define DRAW_STATE\n//#define DRAW_LOW_RES\n//#define DRAW_HIGH_RES\n\n\n\nconst vec3 surface_id_colors[4] = vec3[4](\n    vec3(0.0),// World Color\n    vec3(0.0, 0.0, 1.0),\n    vec3(0.0, 1.0, 0.0),\n    vec3(1.0, 0.0, 0.0)\n);\n\n\nvec4 ignore_world(vec4 sdf_result){\n    if (sdf_result.z >= SURFACE_THRESHOLD){\n        sdf_result.x = 9999.0; // distance from camera\n        sdf_result.y = 0.0; // surface ID\n        return sdf_result;\n    } \n    return sdf_result;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n#ifdef DRAW_STATE\n    fragColor = texture(BUFFER_STATE, uv);\n    return;\n#endif\n#ifdef DRAW_LOW_RES\n    fragColor = texture(BUFFER_LOW_RES_SDF, uv);\n    fragColor.g = fragColor.w; // Show the ray cost instead of the surface ID\n    return;\n#endif\n#ifdef DRAW_HIGH_RES\n    fragColor = texture(BUFFER_HIGH_RES_SDF, uv);\n    fragColor.g = fragColor.w; // Show the ray cost instead of the surface ID\n    return;\n#endif\n\n    \n    // Get data about the surface we're looking at\n    vec3 offset = vec3(MULTISAMPLE_WIDTH, MULTISAMPLE_WIDTH * iResolution.x / iResolution.y, 0.0);\n    \n    vec4 center_sdf_results = ignore_world(texture(BUFFER_HIGH_RES_SDF, uv));\n    vec4 left_sdf_results = ignore_world(texture(BUFFER_HIGH_RES_SDF, uv + offset.xz));\n    vec4 up_sdf_results = ignore_world(texture(BUFFER_HIGH_RES_SDF, uv + offset.zy));\n    \n    \n    //vec3 surface_color = surface_id_colors[int(surface_id)];\n    int surface_id = int(center_sdf_results.y);\n    float dist = center_sdf_results.x;\n    \n    \n    float dzdx = (dist - left_sdf_results.x) / MULTISAMPLE_WIDTH;\n    float dzdy = (dist - up_sdf_results.x) / MULTISAMPLE_WIDTH;\n    dzdx *= 0.02; // Ad-hoc convert from screen space to screen space\n    dzdy *= 0.02; \n    vec3 normal = vec3(\n        dzdx,\n        dzdy,                    // There's still something wrong here, I need to have a think about it.\n        MULTISAMPLE_WIDTH / 0.02 //sqrt(1.0 - dzdx*dzdx - dzdy*dzdy)\n    );\n    normal = normalize(normal);\n    \n    \n    // Edge outlines\n    bool edge = false;\n    edge = edge || surface_id != int(left_sdf_results.y);\n    edge = edge || surface_id != int(up_sdf_results.y);\n    \n    //vec3 surface_output = mix(surface_output, vec3(0.0), float(edge));\n    \n    \n    // Get the surface under the mouse\n    vec2 mouse_pos = iMouse.xy / iResolution.xy;\n    vec4 data_under_mouse = texture(iChannel0, mouse_pos);\n    bool clicked = int(data_under_mouse.y) == surface_id;\n\tvec3 surface_color = surface_id_colors[surface_id];\n    \n    // Render the surface that we're looking at\n    vec3 lighting = vec3(dot(normal, vec3(0.0,0.0,1.0)));\n    if (clicked) {\n    \tlighting += 2.0 * pow(1.0 - lighting.x, 3.0);\n    }\n    vec4 environment = texture(BUFFER_WORLD_MAP, normal);\n    lighting += environment.rgb * 0.3;\n\n    vec3 surface_output = surface_color;\n    surface_output = mix(surface_output, lighting.rgb, 0.7);\n    surface_output *= 1.0 - float(edge);\n\n    \n    \n    fragColor = vec4(vec3(surface_output), 0.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Handles program state\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Draws a low-res SDF user to speed up next buffer\n// Output image has the red channel being the depth and the blue channel being the surface IDvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n#ifdef USE_LOW_RES_BUFFER\n    vec2 uv = fragCoord/iResolution.xy;\n    if (max(uv.x, uv.y) > LOW_RES_BUFFER_SCALE) {\n        // If we aren't in the low-res area, don't bother to evaluate the SDF\n        fragColor = vec4(0.0);\n        return;\n    }\n    uv /= LOW_RES_BUFFER_SCALE;\n    \n    vec2 cam_coords = (uv - vec2(0.5)) * 2.0;\n    cam_coords.x *= iResolution.x / iResolution.y;\n    \n    vec3 start_point = vec3(cam_coords, 0.0);\n    vec3 direction = vec3(0.0, 0.0, 1.0);\n    \n    fragColor = render_scene(start_point, direction, LOW_RES_BUFFER_MAX_STEPS, LOW_RES_BUFFER_STOP_DISTANCE);\n    fragColor.x -= LOW_PASS_DIST_OFFSET;\n#endif\n    \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Draws a high res SDF using only the surface notated in Buffer B\n// Same output as buffer B: red channel is the depth, blue channel is the surface ID\n\n\n#define BUFFER_STATE iChannel0\n#define BUFFER_LOW_RES_SDF iChannel1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n   \n    \n    vec2 cam_coords = (uv - vec2(0.5)) * 2.0;\n    cam_coords.x *= iResolution.x / iResolution.y;\n    \n    vec3 start_point = vec3(cam_coords, 0);\n    vec3 direction = vec3(0.0, 0.0, 1.0);\n\n#ifdef USE_LOW_RES_BUFFER    \n    vec2 low_uv = uv * LOW_RES_BUFFER_SCALE;\n    vec4 prev_sdf_results = texture(BUFFER_LOW_RES_SDF, low_uv);\n    float prev_dist = prev_sdf_results.x;\n    float prev_surface_id = prev_sdf_results.y;\n    float prev_sdf = prev_sdf_results.z;\n    \n    start_point += direction * prev_dist;\n#endif\n    \n    fragColor = render_scene(start_point, direction, HIGH_RES_BUFFER_MAX_STEPS, HIGH_RES_BUFFER_STOP_DISTANCE);\n\n#ifdef USE_LOW_RES_BUFFER  \n    fragColor.x += prev_dist;\n#endif\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define USE_LOW_RES_BUFFER\n\n// The low res buffer can have high per-pixel costs without\n// much affecting performance.\n#define LOW_RES_BUFFER_SCALE 0.25\n#define LOW_RES_BUFFER_MAX_STEPS 25\n#define LOW_RES_BUFFER_STOP_DISTANCE 0.001\n\n// Offset the distance reported from the low res buffer. This removes aliasing artifacts\n// caused by the low res buffer pushing the start position through thin walls.\n// In my experience, this should be greater thanthe HIGH_RES_BUFFER_STOP_DISTANCE otherwise\n// the high res SDF may stop evaluating instantly resulting in pixelated results.\n// There may be some nice relationship between this value and the low res buffer resolution\n// but I haven't bothered to figure it out\n#define LOW_PASS_DIST_OFFSET 0.05\n\n// The high res pass\n#define HIGH_RES_BUFFER_MAX_STEPS 5\n#define HIGH_RES_BUFFER_STOP_DISTANCE 0.05\n\n// Distance from SDF at which SDF stops evaluating\n#define BAIL_DISTANCE 99.9 \n\n// The final image uses this to determine if a ray hit the surface.\n// There is no point having this different to HIGH_RES_BUFFER_STOP_DISTANCE\n#define SURFACE_THRESHOLD 0.05\n\n// Used for edge detection and normal calculation. Should be larger than 1.0/iResolution.x\n#define MULTISAMPLE_WIDTH 0.005 \n\n\nstruct surface_t {\n    float surface_id;\n    float sdf;\n};\n\nsurface_t sphere_sdf(vec3 query_point, float id, float sphere_radius) {\n    return surface_t(\n        id,\n        length(query_point)  - sphere_radius\n    );\n}\n\n\nsurface_t surface_union(surface_t surface_1, surface_t surface_2) {\n    // Join surface_1 to surface_2\n    if (surface_1.sdf < surface_2.sdf){\n        return surface_1;\n    } else {\n     \treturn surface_2;   \n    }\n}\n\nsurface_t surface_intersect(surface_t surface_1, surface_t surface_2) {\n    // Find the volume both surface occupy\n    if (surface_1.sdf > surface_2.sdf){\n        return surface_1;\n    } else {\n     \treturn surface_2;   \n    }\n}\n\nsurface_t surface_difference(surface_t surface_1, surface_t surface_2) {\n    // subtract surface_2 from surface_1\n    // invert surface 2:\n    surface_2.sdf = -surface_2.sdf;\n    return surface_intersect(surface_1, surface_2);\n}\n\n\nvec3 transform(vec3 inp, mat4 offset) {\n    return (offset * vec4(inp, 1.0)).xyz;\n}\n\nmat4 translation(vec3 trans) {\n    // Construct a translation matrix\n    return mat4 (\n        vec4(1.0, 0.0, 0.0, 0.0), \n        vec4(0.0, 1.0, 0.0, 0.0), \n        vec4(0.0, 0.0, 1.0, 0.0), \n        vec4(trans.x, trans.y, trans.z, 1.0)\n    );\n    \n}\n\n\nsurface_t world(vec3 world_position) {\n    surface_t sphere1 = sphere_sdf(transform(world_position, translation(-vec3(0.0, 0.0, 5.0))), 1.0, 1.0);\n    surface_t sphere2 = sphere_sdf(transform(world_position, translation(-vec3(0.0, 1.0, 4.0))), 2.0, 1.0);\n    surface_t sphere3 = sphere_sdf(transform(world_position, translation(-vec3(1.0, 0.0, 5.0))), 3.0, 1.0);\n    \n    surface_t body = sphere1;\n    body = surface_union(body, sphere3);\n    body = surface_difference(body, sphere2);\n    \n    for (int i; i<100; i++) {\n     \tsurface_t new_sphere = sphere_sdf(transform(world_position, translation(-vec3(sin(float(i)), float(i) / 100.0, 10.0))), float(i+4), 1.0);\n    \tbody = surface_union(body, new_sphere);\n    }\n    return body;\n}\n\n\n\nvec4 render_scene(vec3 start_point, vec3 direction, int max_steps, float conv_distance) {\n    vec3 sample_point = start_point;\n    surface_t results = world(sample_point);\n    float dist = 0.0;\n    \n    int i=0;\n    for (i=0; i<max_steps; i += 1) {\n        dist += results.sdf;\n        sample_point += direction * results.sdf;\n        results = world(sample_point);\n        if (results.sdf < conv_distance || results.sdf > BAIL_DISTANCE) {\n            break;\n        }\n    }\n    \n    return vec4(\n        dist,\n        results.surface_id,\n        results.sdf,\n        float(i) / float(max_steps)\n    );\n}","name":"Common","description":"","type":"common"}]}