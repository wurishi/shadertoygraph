{"ver":"0.1","info":{"id":"3lBfDc","date":"1599969689","viewed":57,"name":"TestBalls","username":"cha5m","description":"Testing stuff","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int NUM_STEPS = 200;\nconst float PI\t \t= 3.1415;\nconst float START_FOG_DIST = 0.;\nconst float END_FOG_DIST = 17.;\nconst vec3 FOG_COLOR = vec3(.55,.6,.6);\nconst float EPSILON\t= 1e-3;\n#define SHADOW_EPSILON EPSILON*100.\n#define ZERO min(iFrame,0)\n    struct Material {\n        vec3 color;\n    };\nstruct Object\n{\n    float dist;\n    Material mat;\n};\nstruct MarchResult\n{\n    bool hit;\n    vec3 pos;\n    vec3 normal;\n    Material mat;\n};   \n    \nvec3 whiteify(vec3 col){\n    float m = max(max(col.x,col.y),col.z);\n    return col/m;\n}\n    vec3 powv(vec3 col,float p){return vec3(pow(col.x,p),pow(col.y,p),pow(col.z,p));}\n    vec3 linToGamma(vec3 col){return powv(col, 1.0 / 2.2);}\n    vec3 gammaToLin(vec3 col){return powv(col, 2.2);}\nObject su( Object o1, Object o2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(o2.dist-o1.dist)/k, 0.0, 1.0 );\n    float newDist =mix( o2.dist, o1.dist, h ) - k*h*(1.0-h);\n    vec3 newColor =mix( gammaToLin(o2.mat.color), gammaToLin(o1.mat.color), h ) - k*h*(1.0-h);\n    return Object(newDist,Material(linToGamma((newColor))));\n}\nfloat smin( float a, float b, float c, float k )\n{\n    float res = exp2( -k*a ) + exp2( -k*b )+exp2(-k*c);\n    return -log2( res )/k;\n}\nObject su( Object o1, Object o2, Object o3, float k ) \n{\n    vec3 newColor = gammaToLin(o1.mat.color)*exp2( -k*o1.dist )+gammaToLin(o2.mat.color)*exp2( -k*o2.dist )+gammaToLin(o3.mat.color)*exp2( -k*o3.dist );\n    newColor = whiteify(newColor);\n    float newDist = smin(o1.dist,o2.dist,o3.dist,k);\n    return Object(newDist,Material(linToGamma(newColor)));\n}\nObject mi(Object o1, Object o2){\n \tif (o1.dist<o2.dist)\n        return o1;\n    return o2;\n}\n\nObject mixx(Object o1, Object o2, float f){\n \treturn su(o1,o2,f);   \n}\nObject sphere(vec3 pos,vec3 spherePos,float radius,vec3 color){\n return Object(distance(spherePos,pos)-radius,Material(color));\n}\nint gmod(int a, int b) {\n  return (((a % b) + b) % b);\n}\n\nObject DistEst(vec3 pos){\n    float planeHeight=0.;\n    float planeDist = abs(pos.y-planeHeight);\n    vec3 red = vec3(1.,0.,0.);\n    vec3 green = vec3(0.,1.,0.);\n    vec3 blue= vec3(0.,0.,1.);\n    vec3 grey = vec3(.8,.8,.8);\n    vec3 darkGrey = vec3(.2,.2,.2);\n    vec3 groundCol = darkGrey;\n    bool xOdd = gmod(int(floor(pos.x)),2)==1;\n    bool zOdd = gmod(int(floor(pos.z)),2)==1;\n        if ((xOdd &&!zOdd)||(zOdd && !xOdd)){\n        groundCol=grey;\n            }\n            Object plane = Object(planeDist,Material(groundCol));\n    float leftShift = 1.;\n    Object redSphere = sphere(pos,vec3(leftShift/2.,2.,6.0),1.0,red);\n    Object greenSphere = sphere(pos,vec3(0.,1.,6.0),1.0,green);\n    Object blueSphere = sphere(pos,vec3(leftShift,1.,6.0),1.0,blue);\n    float mixLerp= 50.*clamp((sin(iTime*2.)+1.)/2.,0.,1.)+3.;\n    return mi(su(greenSphere,redSphere,blueSphere,mixLerp),plane);\n}\n\n    vec3 calcNorm(vec3 pos){\n        vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 1.*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*DistEst(pos+0.00005*e).dist;\n    }\n    return normalize(n);\n}\n//Returns a rotation matrix for the given angles around the X,Y,Z axes.\nmat3 Rotate(vec3 angles)\n{angles=angles.yxz;\n    vec3 c = cos(angles);\n    vec3 s = sin(angles);\n    \n    mat3 rotX = mat3( 1.0, 0.0, 0.0, 0.0,c.x,s.x, 0.0,-s.x, c.x);\n    mat3 rotY = mat3( c.y, 0.0,-s.y, 0.0,1.0,0.0, s.y, 0.0, c.y);\n    mat3 rotZ = mat3( c.z, s.z, 0.0,-s.z,c.z,0.0, 0.0, 0.0, 1.0);\n        return rotX*rotY*rotZ;\n    }\n\nmat3 Rotate(float a1,float a2,float a3){\n return Rotate(vec3(a1,a2,a3));   \n}\nvec3 Lerp(vec3 v1, vec3 v2, float t){\n \tt=clamp(t,0.,1.);\n        return vec3(mix(v1.x,v2.x,t),mix(v1.y,v2.y,t),mix(v1.z,v2.z,t));\n}\nMarchResult March(vec3 ori, vec3 dir){\n    float distSoFar = 0.;\n\tvec3 pos = ori;\n    for (int i=0;i<NUM_STEPS;i++){\n     \tObject obj = DistEst(pos);\n        distSoFar+=obj.dist;\n        if (obj.dist<=EPSILON){\n            vec3 normal =calcNorm(pos);\n            return MarchResult(true,pos,normal,obj.mat);\n        }\n        pos+=dir*obj.dist;\n    }\n    return MarchResult(false,vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),Material(vec3(0.0,0.0,0.0)));\n}\nvec3 Fog(vec3 col,float dist){\n    return Lerp(col,FOG_COLOR,(dist-START_FOG_DIST)/(END_FOG_DIST-START_FOG_DIST));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.*(fragCoord.xy / iResolution.xy-.5);\n    uv.x *= iResolution.x / iResolution.y; // bteitler: Aspect ratio correction - if you don't do this your rays will be distorted\n\tvec3 camPos = vec3(0.0,1.5+sin(iTime),0.0);\n    vec3 dir = normalize(vec3(uv.xy,2.0));\n    MarchResult march = March(camPos,dir);\n    vec3 finalCol;\n    if (march.hit){\n        vec3 lightDir = normalize(vec3(-1.0,1.0,-1.0));\n        vec3 reflDir = normalize(march.normal)*2.+dir;\n        MarchResult reflMarch = March(march.pos+reflDir*SHADOW_EPSILON,reflDir);\n        MarchResult shadowMarch = March(march.pos+lightDir*SHADOW_EPSILON,lightDir);\n        float shadow = 1.;\n        if (shadowMarch.hit){\n        \tshadow =.5;\n        }\n        float light = .5*(1.+dot(march.normal,lightDir));\n        vec3 diffuse = shadow*march.mat.color*light;\n        vec3 refl = FOG_COLOR;\n        if (reflMarch.hit){\n            refl= Fog(reflMarch.mat.color,distance(reflMarch.pos,march.pos));\n                }\n        finalCol = Fog(Lerp(diffuse,refl,.1),distance(march.pos,camPos));  \n    } else {\n        finalCol = FOG_COLOR;\n    }\n    fragColor = vec4(finalCol,1);\n}","name":"Image","description":"","type":"image"}]}