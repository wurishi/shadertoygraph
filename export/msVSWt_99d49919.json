{"ver":"0.1","info":{"id":"msVSWt","date":"1681816556","viewed":54,"name":"Karl the alien","username":"tdabin","description":"Karl is coming to rule the world","likes":6,"published":1,"flags":0,"usePreview":1,"tags":["3d","alien","character"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// School project\n// Just modeling over Original IQ Raymarching example https://www.shadertoy.com/view/Xds3zN\n\n#if HW_PERFORMANCE==0\n#define AA 0\n#else\n#define AA 1   // make this 2 or 3 for antialiasing\n#endif\n\n//------------------------------------------------------------------\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n  // sampling independent computations (only depend on shape)\n  vec3  ba = b - a;\n  float l2 = dot(ba,ba);\n  float rr = r1 - r2;\n  float a2 = l2 - rr*rr;\n  float il2 = 1.0/l2;\n    \n  // sampling dependant computations\n  vec3 pa = p - a;\n  float y = dot(pa,ba);\n  float z = y - l2;\n  float x2 = dot2( pa*l2 - ba*y );\n  float y2 = y*y*l2;\n  float z2 = z*z*l2;\n\n  // single square root!\n  float k = sign(rr)*rr*rr*x2;\n  if( sign(z)*a2*z2>k ) return  sqrt(x2 + z2)        *il2 - r2;\n  if( sign(y)*a2*y2<k ) return  sqrt(x2 + y2)        *il2 - r1;\n                        return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n  float rba  = rb-ra;\n  float baba = dot(b-a,b-a);\n  float papa = dot(p-a,p-a);\n  float paba = dot(p-a,b-a)/baba;\n  float x = sqrt( papa - paba*paba*baba );\n  float cax = max(0.0,x-((paba<0.5)?ra:rb));\n  float cay = abs(paba-0.5)-0.5;\n  float k = rba*rba + baba;\n  float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n  float cbx = x-ra - f*rba;\n  float cby = paba - f;\n  float s = (cbx<0.0 && cay<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(cax*cax + cay*cay*baba,\n                     cbx*cbx + cby*cby*baba) );\n}\n\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n//------------------------------------------------------------------\n\n// Union\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\n// Smooth Union\nvec2 opSU( vec2 d1, vec2 d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2.x-d1.x)/k, 0.0, 1.0 );\n    float y = (d1.x < d2.x) ? d1.y : d2.y;\n    return vec2(mix( d2.x, d1.x, h ) - k*h*(1.0-h), y);\n}\n\n// Substraction\nvec2 opS( vec2 d1, vec2 d2 )\n{\n    d1.x *= -1.0;\n    return (d1.x > d2.x) ? d1 : d2;\n}\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2( pos.y, 0.0 );\n    float skinColor = 4.0;\n    float hornColor = 3.0;\n    float toothColor = 3.0;\n    float laserColor = 11.0;\n    \n    // BODY ---------------------------------------------------------------------------------------------------------------------------\n        // Body\n        res = opU( vec2( sdRoundCone( pos-vec3( 0.0, 1.2, 0.0), 0.52, 0.3, 0.4 ), skinColor), res );\n        // Horns\n        res = opU( vec2( sdRoundCone( pos-vec3( -0.23, 1.78, 0.0), vec3( 0.1, 0.0, 0.0 ), vec3( 0.0, 0.1, 0.0 ), 0.07, 0.02 ), hornColor ), res );\n        res = opU( vec2( sdRoundCone( pos-vec3( 0.0, 1.85, 0.0), vec3( 0.0, 0.0, 0.0 ), vec3( 0.0, 0.1, 0.0 ), 0.07, 0.02 ), hornColor ), res );\n        res = opU( vec2( sdRoundCone( pos-vec3( 0.22, 1.77, 0.0), vec3( -0.1, 0.0, 0.0 ), vec3( 0.0, 0.1, 0.0 ), 0.07, 0.02 ), hornColor ), res );\n        res = opU( vec2( sdRoundCone( pos-vec3( 0.35, 1.6, 0.0), vec3( -0.15, 0.0, 0.0 ), vec3( 0.0, 0.1, 0.0 ), 0.07, 0.02 ), hornColor ), res );\n        res = opU( vec2( sdRoundCone( pos-vec3( 0.44, 1.42, 0.0), vec3( -0.18, 0.0, 0.0 ), vec3( 0.0, 0.1, 0.0 ), 0.075, 0.02 ), hornColor ), res );\n        res = opU( vec2( sdRoundCone( pos-vec3( 0.51, 1.25, 0.0), vec3( -0.5, 0.0, 0.0 ), vec3( 0.0, 0.1, 0.0 ), 0.2, 0.015 ), hornColor ), res );\n    \n    // MOUTH --------------------------------------------------------------------------------------------------------------------------\n        // Mouth\n        res = opS( vec2( sdEllipsoid( pos-vec3( -0.4, 1.1, 0.0), vec3(0.3, 0.15, 0.3) ), 5.0 ), res );\n        // Tongue\n        res = opU( vec2( sdEllipsoid( pos-vec3( -0.17, 1.0, 0.0), vec3(0.1, 0.2, 0.2) ), 6.0 ), res );\n        // Teeth\n        res = opU( vec2( sdEllipsoid( pos-vec3( -0.39, 0.94, 0.05), vec3(0.03, 0.06, 0.05) ), toothColor ), res );\n        res = opU( vec2( sdEllipsoid( pos-vec3( -0.39, 0.94, -0.05), vec3(0.03, 0.06, 0.05) ), toothColor ), res );\n        res = opU( vec2( sdEllipsoid( pos-vec3( -0.37, 0.96, 0.15), vec3(0.03, 0.06, 0.05) ), toothColor ), res );\n        res = opU( vec2( sdEllipsoid( pos-vec3( -0.37, 0.96, -0.15), vec3(0.03, 0.06, 0.05) ), toothColor ), res );\n    \n    // NOSE ---------------------------------------------------------------------------------------------------------------------------\n        res = opS( vec2( sdEllipsoid( pos-vec3( -0.43, 1.5, 0.03), vec3(0.03, 0.05, 0.02) ), 2.0 ), res );\n        res = opS( vec2( sdEllipsoid( pos-vec3( -0.43, 1.5, -0.03), vec3(0.03, 0.05, 0.02) ), 2.0 ), res );\n    \n    // EYES ---------------------------------------------------------------------------------------------------------------------------\n        // Eyes\n        res = opU( vec2( sdSphere( pos-vec3( -0.3, 1.5, 0.3), 0.2 ), 3.0 ), res );\n        res = opU( vec2( sdSphere( pos-vec3( -0.3, 1.5, -0.3), 0.2 ), 3.0 ), res );\n        // Pupils\n        res = opSU( vec2( sdSphere( pos-vec3( -0.41, 1.5, 0.35), 0.1 ), 2.0 ), res, 0.03 );\n        res = opSU( vec2( sdSphere( pos-vec3( -0.41, 1.5, -0.35), 0.1 ), 2.0 ), res, 0.03 );\n    \n    // LEGS ---------------------------------------------------------------------------------------------------------------------------\n        // Thighs\n        res = opSU( vec2( sdRoundCone( pos-vec3( 0.0, 0.4, 0.3), vec3( -0.1, 0.0, 0.0 ), vec3( 0.0, 0.4, -0.15 ), 0.05, 0.15 ), skinColor ), res, 0.07 );\n        res = opSU( vec2( sdRoundCone( pos-vec3( 0.0, 0.4, -0.3), vec3( -0.1, 0.0, 0.0 ), vec3( 0.0, 0.4, 0.15 ), 0.05, 0.15 ), skinColor ), res, 0.07 );\n        // Calves\n        res = opU( vec2( sdRoundCone( pos-vec3( -0.1, 0.0, 0.3), 0.04, 0.05, 0.4 ), skinColor ), res );\n        res = opU( vec2( sdRoundCone( pos-vec3( -0.1, 0.0, -0.3), 0.04, 0.05, 0.4 ), skinColor ), res );\n        // Knees\n        res = opSU( vec2( sdSphere( pos-vec3( -0.1, 0.4, 0.3), 0.07 ), skinColor ), res, 0.04 );\n        res = opSU( vec2( sdSphere( pos-vec3( -0.1, 0.4, -0.3), 0.07 ), skinColor ), res, 0.04 );\n        // Ass\n        res = opSU( vec2( sdCapsule( pos-vec3( 0.08, 0.79, 0.1), vec3( 0.0, 0.0, 0.0 ), vec3( 0.2, 0.1, 0.0 ), 0.15), skinColor ), res, 0.04 );\n        res = opSU( vec2( sdCapsule( pos-vec3( 0.08, 0.79, -0.1), vec3( 0.0, 0.0, 0.0 ), vec3( 0.2, 0.1, 0.0 ), 0.15), skinColor ), res, 0.04 );\n        // Left foot\n        res = opSU( vec2( sdRoundCone( pos-vec3( -0.3, 0.0, 0.3), vec3( 0.0, 0.04, -0.07 ), vec3( 0.2, 0.0, 0.0 ), 0.02, 0.04 ), skinColor ), res, 0.02 );\n        res = opSU( vec2( sdRoundCone( pos-vec3( -0.3, 0.0, 0.3), vec3( 0.0, 0.04, 0.07 ), vec3( 0.2, 0.0, 0.0 ), 0.02, 0.04 ), skinColor ), res, 0.02 );\n        res = opSU( vec2( sdRoundCone( pos-vec3( -0.4, 0.035, 0.37), vec3( 0.0, -0.015, -0.01 ), vec3( 0.09, 0.0, 0.0 ), 0.012, 0.02 ), skinColor ), res, 0.02 );\n        res = opSU( vec2( sdRoundCone( pos-vec3( -0.4, 0.035, 0.23), vec3( 0.0, -0.015, 0.01 ), vec3( 0.09, 0.0, 0.0 ), 0.012, 0.02 ), skinColor ), res, 0.02 );\n        // Right foot\n        res = opSU( vec2( sdRoundCone( pos-vec3( -0.3, 0.0, -0.3), vec3( 0.0, 0.04, -0.07 ), vec3( 0.2, 0.0, 0.0 ), 0.02, 0.04 ), skinColor ), res, 0.02 );\n        res = opSU( vec2( sdRoundCone( pos-vec3( -0.3, 0.0, -0.3), vec3( 0.0, 0.04, 0.07 ), vec3( 0.2, 0.0, 0.0 ), 0.02, 0.04 ), skinColor ), res, 0.02 );\n        res = opSU( vec2( sdRoundCone( pos-vec3( -0.4, 0.035, -0.37), vec3( 0.0, -0.015, 0.01 ), vec3( 0.09, 0.0, 0.0 ), 0.012, 0.02 ), skinColor ), res, 0.02 );\n        res = opSU( vec2( sdRoundCone( pos-vec3( -0.4, 0.035, -0.23), vec3( 0.0, -0.015, -0.01 ), vec3( 0.09, 0.0, 0.0 ), 0.012, 0.02 ), skinColor ), res, 0.02 );\n    \n    // ARMS ---------------------------------------------------------------------------------------------------------------------------\n        // Arms\n        res = opSU( vec2( sdRoundCone( pos-vec3( 0.1, 1.1, 0.6), vec3( 0.0, 0.0, 0.0 ), vec3( 0.0, 0.3, -0.3 ), 0.07, 0.12 ), skinColor ), res, 0.03 );\n        res = opSU( vec2( sdRoundCone( pos-vec3( 0.1, 1.1, -0.6), vec3( -0.2, 0.0, 0.0 ), vec3( 0.0, 0.3, 0.3 ), 0.07, 0.12 ), skinColor ), res, 0.03 );\n        // Elbows\n        res = opSU( vec2( sdSphere( pos-vec3( 0.1, 1.1, 0.6), 0.085 ), skinColor ), res, 0.03 );\n        res = opSU( vec2( sdSphere( pos-vec3( -0.1, 1.1, -0.6), 0.085 ), skinColor ), res, 0.03 );\n        // Forearms\n        res = opSU( vec2( sdCappedCone( pos-vec3( 0.1, 0.8, 0.6), 0.3, 0.03, 0.07 ), skinColor ), res, 0.03 );\n        res = opSU( vec2( sdCappedCone( pos-vec3( -0.7, 1.1, -0.6), vec3( 0.0, 0.0, 0.0 ), vec3( 0.6, 0.0, 0.0 ), 0.03, 0.07 ), skinColor ), res, 0.03 );\n        // Left hand\n        res = opSU( vec2( sdRoundCone( pos-vec3( 0.05, 0.4, 0.6), vec3( 0.0, 0.0, -0.07 ), vec3( 0.05, 0.1, 0.0 ), 0.02, 0.05 ), skinColor ), res, 0.02 );\n        res = opSU( vec2( sdRoundCone( pos-vec3( 0.05, 0.4, 0.6), vec3( 0.0, 0.0, 0.07 ), vec3( 0.05, 0.1, 0.0 ), 0.02, 0.05 ), skinColor ), res, 0.02 );\n        res = opSU( vec2( sdRoundCone( pos-vec3( 0.07, 0.25, 0.53), vec3( 0.0, 0.0, 0.03 ), vec3( -0.03, 0.15, 0.0 ), 0.012, 0.02 ), skinColor ), res, 0.02 );\n        res = opSU( vec2( sdRoundCone( pos-vec3( 0.07, 0.25, 0.67), vec3( 0.0, 0.0, -0.03 ), vec3( -0.03, 0.15, 0.0 ), 0.012, 0.02 ), skinColor ), res, 0.02 );\n        // Right hand\n        res = opSU( vec2( sdRoundCone( pos-vec3( -0.8, 1.1, -0.65), vec3( 0.0, -0.05, 0.0 ), vec3( 0.1, 0.0, 0.05 ), 0.02, 0.05 ), skinColor ), res, 0.02 );\n        res = opSU( vec2( sdRoundCone( pos-vec3( -0.8, 1.1, -0.65), vec3( 0.0, 0.05, 0.0 ), vec3( 0.1, 0.0, 0.05 ), 0.02, 0.05 ), skinColor ), res, 0.02 );\n        res = opSU( vec2( sdRoundCone( pos-vec3( -0.88, 1.15, -0.53), vec3( 0.0, -0.03, 0.0 ), vec3( 0.06, 0.0, -0.12 ), 0.012, 0.02 ), skinColor ), res, 0.02 );\n        res = opSU( vec2( sdRoundCone( pos-vec3( -0.88, 1.05, -0.53), vec3( 0.0, 0.03, 0.0 ), vec3( 0.06, 0.0, -0.12 ), 0.012, 0.02 ), skinColor ), res, 0.02 );\n    \n    // GUN -----------------------------------------------------------------------------------------------------------------------------\n        // Gun\n        res = opU( vec2( sdCappedCone( pos-vec3( -0.8, 1.1, -0.57), 0.13, 0.05, 0.03 ), 7.0 ), res );\n        res = opU( vec2( sdEllipsoid( pos-vec3( -0.9, 1.26, -0.57), vec3(0.3, 0.11, 0.11) ), 9.0 ), res );\n        res = opU( vec2( sdEllipsoid( pos-vec3( -1.03, 1.26, -0.57), vec3(0.045, 0.135, 0.135) ), 8.0 ), res );\n        res = opU( vec2( sdEllipsoid( pos-vec3( -0.95, 1.26, -0.57), vec3(0.02, 0.115, 0.115) ), 10.0 ), res );\n        res = opU( vec2( sdCapsule( pos-vec3( -1.26, 1.26, -0.57), vec3( 0.0, 0.0, 0.0 ), vec3( 0.1, 0.0, 0.0 ), 0.005), 2.0 ), res );\n        res = opU( vec2( sdSphere( pos-vec3( -1.26, 1.26, -0.57), 0.02 ), 8.0 ), res );\n        res = opU( vec2( sdSphere( pos-vec3( -1.18, 1.26, -0.57), 0.03 ), 10.0 ), res );\n        res = opU( vec2( sdSphere( pos-vec3( -0.63, 1.26, -0.57), 0.03 ), 10.0 ), res );\n        res = opU( vec2( sdEllipsoid( pos-vec3( -0.77, 1.35, -0.57), vec3(0.08, 0.03, 0.02) ), 8.0 ), res );\n        // Laser\n        float posGunShot1 = -1.4-mod(iTime, 2.0)*3.0;\n        float posGunShot2 = -1.55-mod(iTime, 2.0)*3.0;\n        float posGunShot3 = -1.7-mod(iTime, 2.0)*3.0;\n        float posGunShotCapsule = -1.79-mod(iTime, 2.0)*3.0;\n        res = opU( vec2( sdTorus( (pos-vec3( posGunShot1, 1.26, -0.57)).zxy, vec2(0.08, 0.02) ), laserColor ), res );\n        res = opU( vec2( sdTorus( (pos-vec3( posGunShot2, 1.26, -0.57)).zxy, vec2(0.08, 0.02) ), laserColor ), res );\n        res = opU( vec2( sdTorus( (pos-vec3( posGunShot3, 1.26, -0.57)).zxy, vec2(0.08, 0.02) ), laserColor ), res );\n        res = opU( vec2( sdCapsule( pos-vec3( posGunShotCapsule, 1.26, -0.57), vec3( 0.0, 0.0, 0.0 ), vec3( 0.48, 0.0, 0.0 ), 0.005), laserColor ), res );\n\n\n    return res;\n}\n\n// https://iquilezles.org/articles/boxfunctions\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nvec2 raycast( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    // raytrace floor plane\n    float tp1 = (0.0-ro.y)/rd.y;\n    if( tp1>0.0 )\n    {\n        tmax = min( tmax, tp1 );\n        res = vec2( tp1, 1.0 );\n    }\n    //else return res;\n    \n    // raymarch primitives   \n    vec2 tb = iBox( ro-vec3(0.0,0.4,-0.5), rd, vec3(10.,2.,2.) );\n    if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)\n    {\n        //return vec2(tb.x,2.0);\n        tmin = max(tb.x,tmin);\n        tmax = min(tb.y,tmax);\n\n        float t = tmin;\n        for( int i=0; i<70 && t<tmax; i++ )\n        {\n            vec2 h = map( ro+rd*t );\n            if( abs(h.x)<(0.0001*t) )\n            { \n                res = vec2(t,h.y); \n                break;\n            }\n            t += h.x;\n        }\n    }\n    \n    return res;\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<24; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s );\n        t += clamp( h, 0.01, 0.2 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n#endif    \n}\n\n// https://iquilezles.org/articles/nvscene2008/rwwtt.pdf\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// https://iquilezles.org/articles/checkerfiltering\nfloat checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy )\n{\n    // filter kernel\n    vec2 w = abs(dpdx)+abs(dpdy) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 3.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 calcColor(float m, vec3 pos, vec3 nor, vec3 ro, vec3 rd, in vec3 rdx, in vec3 rdy)\n{\n\tif( m < 1.5 )\n\t{ \t// project pixel footprint into the plane\n\t    vec3 dpdx = ro.y*(rd/rd.y-rdx/rdx.y);\n\t    vec3 dpdy = ro.y*(rd/rd.y-rdy/rdy.y);\n\t    float f = checkersGradBox( 3.0*pos.xz, 3.0*dpdx.xz, 3.0*dpdy.xz );\n\t    return 0.15 + f*vec3(0.05);\n\t}\n    else if(m < 2.5)\n    { \t// Black\n    \treturn vec3(0.0, 0.0, 0.0);\n    }\n    else if(m < 3.5)\n    { \t// White\n        return vec3(1.0, 1.0, 1.0);\n    }\n    else if(m < 4.5)\n    { \t// Skin\n        return vec3(0.1, 0.4, 0.8) * 0.4;\n    }\n    else if(m < 5.5)\n    { \t// Mouth\n        return vec3(0.7, 0.3, 0.7) * 0.4;\n    }\n    else if(m < 6.5)\n    { \t// Red\n        return vec3(0.9, 0.1, 0.1) * 0.4;\n    }\n    else if(m < 7.5)\n    {\t// Metal\n        return vec3(0.33, 0.33, 0.33);\n    }\n    else if(m < 8.5)\n    {\t// Gold\n        return vec3(1.0, 0.8, 0.05) * 0.7;\n    }\n    else if(m < 9.5)\n    {\t// Metal Red\n        return vec3(0.8, 0.1, 0.1) * 0.65;\n    }\n    else if(m < 10.5)\n    {\t// Dark Metal\n        return vec3(0.16, 0.16, 0.16);\n    }\n    else if(m < 11.5)\n    {\t// Laser\n        return vec3(0.2, 1.0, 0.0) * 0.4;\n    }\n    \n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy )\n{ \n    // background\n    vec3 col = vec3(0.7, 0.7, 0.9) - max(rd.y,0.0)*0.3;\n    \n    // raycast scene\n    vec2 res = raycast(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material\n        col = calcColor(m, pos, nor, ro, rd, rdx, rdy);\n\n        // lighting\n        float occ = calcAO( pos, nor );\n        \n\t\tvec3 lin = vec3(0.0);\n\n        // sun\n        float ks = 1.0;\n        {\n            vec3  lig = normalize( vec3(-0.5, 0.4, -0.6) );\n            vec3  hal = normalize( lig-rd );\n            float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n          //if( dif>0.0001 )\n        \t      dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n\t\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0);\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0-dot(hal,lig),0.0,1.0),5.0);\n                //spe *= 0.04+0.96*pow(clamp(1.0-sqrt(0.5*(1.0-dot(rd,lig))),0.0,1.0),5.0);\n            lin += col*2.20*dif*vec3(1.30,1.00,0.70);\n            lin +=     5.00*spe*vec3(1.30,1.00,0.70)*ks;\n        }\n        // sky\n        {\n            float dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n                  dif *= occ;\n            float spe = smoothstep( -0.2, 0.2, ref.y );\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0+dot(nor,rd),0.0,1.0), 5.0 );\n          //if( spe>0.001 )\n                  spe *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n            lin += col*0.60*dif*vec3(0.40,0.60,1.15);\n            lin +=     2.00*spe*vec3(0.40,0.60,1.30)*ks;\n        }\n        // back\n        {\n        \tfloat dif = clamp( dot( nor, normalize(vec3(0.5,0.0,0.6))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n                  dif *= occ;\n        \tlin += col*0.55*dif*vec3(0.25,0.25,0.25);\n        }\n        // sss\n        {\n            float dif = pow(clamp(1.0+dot(nor,rd),0.0,1.0),2.0);\n                  dif *= occ;\n        \tlin += col*0.25*dif*vec3(1.00,1.00,1.00);\n        }\n        \n\t\tcol = lin;\n\n        col = mix( col, vec3(0.7,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 32.0 + iTime*1.5;\n\n    // camera\t\n    vec3 ta = vec3( 0., 0.7, 0. );\n    vec3 ro = ta + vec3( 4.5*cos(0.1*time + 7.0*mo.x), 2.2, 4.5*sin(0.1*time + 7.0*mo.x) );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else\n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n\n        // focal length\n        const float fl = 3.;\n        \n        // ray direction\n        vec3 rd = ca * normalize( vec3(p,fl) );\n\n         // ray differentials\n        vec2 px = (2.0*(fragCoord+vec2(1.0,0.0))-iResolution.xy)/iResolution.y;\n        vec2 py = (2.0*(fragCoord+vec2(0.0,1.0))-iResolution.xy)/iResolution.y;\n        vec3 rdx = ca * normalize( vec3(px,fl) );\n        vec3 rdy = ca * normalize( vec3(py,fl) );\n        \n        // render\n        vec3 col = render( ro, rd, rdx, rdy );\n\n        // gain\n        // col = col*3.0/(2.5+col);\n        \n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    \n    fragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"}]}