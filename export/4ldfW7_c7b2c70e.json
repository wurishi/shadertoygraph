{"ver":"0.1","info":{"id":"4ldfW7","date":"1539997423","viewed":79,"name":"Character Project- Alien Squid","username":"rlarp","description":"An Alien Squid","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["alien","school","project","squid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926535897932384626433832795\n\nstruct Shape{ // Basic Shape Constructor\n  float dist;\n  vec4 color;\n};\n    \n// Utility Functions\n   \nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\nvec2 getPolarUV(in vec2 uv)\n{\n    float angle = atan(uv.y, uv.x);\n    angle += PI;\n    angle /= (2.*PI);\n    \n    float dist = distance(vec2(0.), uv);\n    \n    return vec2(angle, dist);\n}\n\n\nfloat fOpUnionColumns(float a, float b, float r, float n) {\n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n\t\tpR45(p);\n\t\tp.x -= sqrt(2.)/2.*r;\n\t\tp.x += columnradius*sqrt(2.);\n\t\tif (mod(n,2.) == 1.) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\t// At this point, we have turned 45 degrees and moved at a point on the\n\t\t// diagonal that we want to place the columns on.\n\t\t// Now, repeat the domain along this direction and place a circle.\n\t\tpMod1(p.y, columnradius*2.);\n\t\tfloat result = length(p) - columnradius;\n\t\tresult = min(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn min(result, b);\n\t} else {\n\t\treturn min(a, b);\n\t}\n}\n\nfloat pModPolar(inout vec2 v, float r){\n  float f = 6.28318/r;\n  float z = atan(v.y, v.x)+f*0.5;\n  float m = floor(z/f);\n  z = mod(z, f)-f*0.5;\n  v = vec2(cos(z), sin(z))*length(v);\n  return m;\n}\n\nmat2 rot(float a){\n  float r = cos(a);\n  float f = sin(a);\n  return mat2(r, f, -f, r);\n}\n\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat fCone(vec3 p, float radius, float height) {\n\tvec2 q = vec2(length(p.xz), p.y);\n\tvec2 tip = q - vec2(0, height);\n\tvec2 mantleDir = normalize(vec2(height, radius));\n\tfloat mantle = dot(tip, mantleDir);\n\tfloat d = max(mantle, -q.y);\n\tfloat projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n\t\n\t// distance to tip\n\tif ((q.y > height) && (projected < 0.)) {\n\t\td = max(d, length(tip));\n\t}\n\t\n\t// distance to base ring\n\tif ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n\t\td = max(d, length(q - vec2(radius, 0)));\n\t}\n\treturn d;\n}\n\n// Main Character (The Squid) \n\nShape character(vec3 c){\n  Shape shape;\n  shape.dist = 1000.; // Draw Distance\n  shape.color = vec4(1.); // Initial Color\n //  vec4 color = vec4(0.5, cos(iTime), cos(iTime), 0.); \n    \n  vec3 p = c; // Base\n  vec3 b = c; // Body\n  vec3 a1 = c; // Arm 1 Sect 1\n  vec3 a12 = c; // Arm 1 Sect 2 \n  vec3 a2 = c; // Arm 2 Sect 1 \n  vec3 a22 = c; // Arm 2 Sect 2 \n  vec3 a3 = c; // Arm 3 Sect 1\n  vec3 a32 = c; // Arm 3 Sect 2 \n  vec3 a4 = c; // Arm 4 Sect 1\n  vec3 a42 = c; // Arm 4 Sect 2 \n  vec3 e1 = c; // Eye 1 \n  vec3 e2 = c; // Pupil\n  vec3 w1 = c; // Wheel inside \n  vec3 w2 = c; // Wheel outside \n  vec3 l1 = c;\n  vec3 h = c; // Hat \n  vec3 t = c; // Tentacles\n    \n    \n  // Body\n  float body = fBox(b+vec3(0.0, -1.5, 0.0), vec3(0.8, 1.2, 0.75)); // Makes a box (called body) at point p of size = 1.\n    \n  // Base\n  float base = fBox(p+vec3(0.0, 0.3, 0.0), vec3(0.55, 0.65, 0.75)); // Makes a box for the base\n    \n  // Eye Outside \n   float eye1 = sdEllipsoid(e1+vec3(0.0,-1.0, 0.4), vec3(.5, abs(sin(iTime))*.5, .6));\n   \n  // Eye Inside\n  float eye2 = fSphere(e2+vec3((sin(iTime)*0.2), -1.0, 0.5), 0.15); \n   \n  // Note: I intiially had wheels hence the wheels here; I might still implement them later.   \n    \n  // Wheel Outside\n  //float wheel1 = fSphere(w1+vec3(0.0,2.,0.0), 1.0); \n \n  // Wheel Inside\n  //float wheel2 = fSphere(w2+vec3(0.0,sin(iTime)+2.,sin(iTime*0.1)+0.5), 0.4);  \n  \n  // Arm 1\n  float arm1 = fBox(a1+vec3(1.2,-0.3,0.0), vec3(1.,0.3,0.0)); \n  a12.xy *= rot(radians(45.)); \n  float arm12 = fBox(a12+vec3(1.8,-1.7,0.0), vec3(.7,0.3,0.0));\n    \n  // Arm 2\n  float arm2 = fBox(a2+vec3(1.2,-1.5,0.0), vec3(1.,0.3,0.0)); \n  a22.xy *= rot(radians(45.)); \n  float arm22 = fBox(a22+vec3(1.0,-2.5,0.0), vec3(.7,0.3,0.0)); \n    \n  // Arm 3\n  float arm3 = fBox(a3+vec3(-1.2,-0.3,0.0), vec3(1.,0.3,0.0)); \n  a32.xy *= rot(radians(-45.)); \n  float arm32 = fBox(a32+vec3(-1.8,-1.7,0.0), vec3(.7,0.3,0.0));\n    \n  // Arm 4\n  float arm4 = fBox(a4+vec3(-1.2,-1.5,0.0), vec3(1.,0.3,0.0)); \n  a42.xy *= rot(radians(-45.)); \n  float arm42 = fBox(a42+vec3(-1.0,-2.5,0.0), vec3(.7,0.3,0.0)); \n    \n  // Hat\n  float hat = fSphere(h-vec3(0.,2.7,0.0), 0.55); \n    \n  // Tentacles\n  t.x = abs(t.x)-.15; // Mirror\n  t.x = abs(t.x)-0.15; // Mirror again\n  t.xy *= rot(radians(180.)); // Rotates it to face the other way\n  t.x += sin(t.y * 10. - iTime * 4.) * (1. - t.y) * .03; // Animates the tentacles\n  float tentacles = fCone(t+vec3(0., 0.5, 0.), 0.4, 3.); // Animates the tentacles\n      \n    \n  shape.dist = max(body, -eye1); // Adds the box and eye (difference)\n  shape.dist = min(shape.dist, eye2); // Use shape.dist after two shapes \n  shape.dist = min(shape.dist, base); \n  //shape.dist = min(shape.dist, wheel1); \n  //shape.dist = max(shape.dist, -wheel2); \n  shape.dist = min(shape.dist, arm1); \n  shape.dist = min(shape.dist, arm12); \n  shape.dist = min(shape.dist, arm2); \n  shape.dist = min(shape.dist, arm22); \n  shape.dist = min(shape.dist, arm3);\n  shape.dist = min(shape.dist, arm32);\n  shape.dist = min(shape.dist, arm4);\n  shape.dist = min(shape.dist, arm42);\n  shape.dist = min(shape.dist, tentacles); \n  shape.dist = fOpUnionColumns(shape.dist,hat, 1., 5.); // Creates the hat ilke effect\n  \n // shape.color = color; \n  return shape;\n}\n\nShape background(vec3 b){ // Creates the background (circle and box) \n   Shape shape;\n   shape.dist = 1000.;\n   shape.color = vec4(1.0); \n  //  vec4 color = vec4(0.5, cos(iTime), cos(iTime), 0.);  \n   vec3 g = b; // Ground\n   vec3 g1 = b; // Ground 1\n    \n   g.xz *= rot(b.y*0.2+iTime);\n   float ground = fSphere(g-vec3(0.,-12.75, 0.0), 10.); \n   float holder = fBox(g1-vec3(.0, -5., .0), vec3(100., .5, 0.));\n    \n   shape.dist = min(ground, holder);\n  //  shape.color = color; \n    \n    return shape; \n  \n}\n\n\nShape map(vec3 c){ // Maps everything together (the Background and Character) \n  Shape face = character(c);\n  Shape ground = background(c);\n  face.dist = min(face.dist, ground.dist); \n  return face;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) { // Camera, dimensions, etc \n  vec2 v = (fragCoord.xy-0.5 * iResolution.xy) / iResolution.y;\n\n  \n  vec3 cam = vec3(0., 0., -10.5);\n   // vec3 cam = vec3(-sin(iTime)*0.3-0.5, sin(iTime)+2., sin(iTime)-10.); \n  vec3 f = normalize(vec3(v, 1.));\n  vec3 scene = cam;\n    scene.yx *= rot(iTime);\n  fragColor = vec4(0.);\n\n  // Ray Marcher\n  for(float z = 0.1 ; z <= 1.; z += 0.03){\n    Shape c = map(scene); // Calc SDF\n    if(c.dist < 0.0001){\n      fragColor = c.color*(1.-z); // Hit  - invert pixels\n      break;\n    }\n    scene += f * c.dist;\n\n\n  }\n}","name":"Image","description":"","type":"image"}]}