{"ver":"0.1","info":{"id":"wdBfRG","date":"1590258797","viewed":48,"name":"lr94/lens","username":"lucasrumney94","description":"Gravitational lens look-dev example for a friend of mine. ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["lens"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAGNIFICATION 44.99999999\nconst float MAX_RAYMARCH_DISTANCE = 100.;\nconst int MAX_RAYMARCH_STEPS = 100;\nconst float EPSILON = 0.01;\nconst float VERTICAL_FOV = 45.;\n\nfloat circle(vec2 uv, vec2 position, float radius) {\n    return (distance(position, uv) - radius);\n}\n\nfloat sphere(vec3 uv, vec3 position, float radius){\n    return (distance(position, uv) - radius);\n}\n\n// Defines the surfaces \n// returns the nearest distance from the provided position to the scene's surfaces\nfloat sceneSDF(vec3 position){\n    float mySphere = sphere(position, vec3(0.,0.,0.), .5);\n    return mySphere;\n}\n\nfloat rayMarch(vec3 cameraPoint, vec3 cameraRay){\n\tvec3 samplePoint = cameraPoint;\n    float depth = 0.;\n\n    for (int i = 0; i < MAX_RAYMARCH_STEPS; i++){\n        float closestDistance = sceneSDF(samplePoint);\n        // If we are close enough\n        if (closestDistance < EPSILON){\n        \tbreak;\n        }\n        depth += closestDistance;\n        // If we have exhausted the raymarching\n        if (depth > MAX_RAYMARCH_DISTANCE) {\n            depth = 0.;\n            break;\n        }\n        // March the Sample Point forward by the closestDistance\n        samplePoint += (closestDistance)*cameraRay;  \n    }\n            \n    // 0. cameraPoint INSIDE the SDF\n    // +f distance to the surface\n    return depth; // pointOnShape\n}\n\nvec3 getNormal(vec3 position){\n\tvec3 normal = vec3(0.);\n    \n    vec3 x1Sample = position+vec3(EPSILON, 0.,0.);\n    vec3 x2Sample = position-vec3(EPSILON, 0.,0.);\n    float x1SampleDistance = sceneSDF(x1Sample);\n    float x2SampleDistance = sceneSDF(x2Sample);\n    normal.x = x1SampleDistance-x2SampleDistance;\n    \n    vec3 y1Sample = position+vec3(0.,EPSILON,0.);\n    vec3 y2Sample = position-vec3(0.,EPSILON,0.);\n    float y1SampleDistance = sceneSDF(y1Sample);\n    float y2SampleDistance = sceneSDF(y2Sample);\n    normal.y = y1SampleDistance-y2SampleDistance;\n    \n    vec3 z1Sample = position+vec3(0.,0.,EPSILON);\n    vec3 z2Sample = position-vec3(0.,0.,EPSILON);\n    float z1SampleDistance = sceneSDF(z1Sample);\n    float z2SampleDistance = sceneSDF(z2Sample);\n    normal.z = z1SampleDistance-z2SampleDistance;\n    \n    return normalize(normal);\n}\n\nvec3 cameraRayFromFrag(float vFoVDegrees, vec2 fragCoord, vec2 uv){\n\t\n    // Remap coordinate (0,0) to center of screen\n    fragCoord = fragCoord-iResolution.xy/2.;\n    \n    float z = iResolution.y / tan(radians(vFoVDegrees) / 2.);\n\n    vec2 mouseUV = iMouse.xy/iResolution.xy;\n    mouseUV.x *= iResolution.x/iResolution.y;\n    \n   \tif(circle(uv, mouseUV, 0.4)<0.)\n    {\n        float circleFOVFactor = ((1./.4)*(circle(uv, mouseUV, 0.4)))*MAGNIFICATION;\n        z = iResolution.y / tan(radians(vFoVDegrees+circleFOVFactor) / 2.);\n        //z /= circle(uv, mouseUV, 0.0)*5.; \n    }\n    \n    vec3 cameraRay = vec3(fragCoord.x, fragCoord.y, -z);\n    return normalize(cameraRay);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n\n    // Grey Background\n    vec3 col = vec3(0.2);\n    \n    // White Circle\n    vec2 mouseUV = iMouse.xy/iResolution.xy;\n    mouseUV.x *= iResolution.x/iResolution.y;\n    float myCircle = circle(uv,mouseUV, 0.4);\n    col = mix(col, vec3(.3), step(0., -myCircle));\n\t\n    vec3 cameraPoint = vec3(0.,0.,5.);\n    vec3 cameraRay = cameraRayFromFrag(VERTICAL_FOV, fragCoord, uv);\n    float rayMarchDistance = rayMarch(cameraPoint, cameraRay);\n    vec3 pointOnSurface = cameraPoint+cameraRay*rayMarchDistance;\n    vec3 normal = getNormal(pointOnSurface);\n    vec3 lightPoint = vec3(-2.,2.,2.); \n    \n    col = mix(col, normal, clamp(rayMarchDistance, 0., 1.));\n    \n    //phong(pointOnSurface, normal, cameraPoint, lightPoint);\n    \n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}