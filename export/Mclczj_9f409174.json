{"ver":"0.1","info":{"id":"Mclczj","date":"1721343986","viewed":35,"name":"Interactive SA Imaging","username":"EdgarDorausch","description":"Interactive Synthetic Aperture Imaging\n(You may need to stop the timer)\n- Use the mouse to draw scatter points.\n- toggle scatt. visibility by left arrow key\n- right arrow: toggle brush\n- toggle between log power mode and linear phase mode with space bar","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["phase","beamformer","syntheticaperture"],"hasliked":0,"parentid":"Mclyzj","parentname":"SA Beamformer"},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define product(a, b) vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x)\n#define conjugate(a) vec2(a.x,-a.y)\n#define divide(a, b) vec2(((a.x*b.x+a.y*b.y)/(b.x*b.x+b.y*b.y)),((a.y*b.x-a.x*b.y)/(b.x*b.x+b.y*b.y)))\n#define cexp(p) vec2(cos(p), sin(p))\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_SPACE  = 32;\n\nvec3 rbcolormap(float val) {\n\n    return vec3(clamp(val, 0.0, 1.0), 0.0, clamp(-val, 0.0, 1.0));\n}\n\nvec3 gscolormap(float val) {\n\n    return vec3(clamp(val, 0.0, 1.0));\n}\n\nvec2 mid_pos = vec2(-0.5, 0.0);\nvec2 array_dir = vec2(0.0, 0.1);\n\nfloat PI = 3.14159265359;\n\nfloat circle(vec2 uv, vec2 center, float radius) {\n    float rad = length(uv-center);\n    float val = clamp(radius-rad, 0.0, 1.3/iResolution.x)*iResolution.x/1.3;\n    \n    return val;\n}\n\n\nvec2 getElemPos(int m, int M) {\n    float s = float(m)/float(M-1)*2.0-1.0;\n    return mid_pos + array_dir * s;\n}\n\nbool isKeyToggled(int keycode) {\n    return texelFetch( iChannel1, ivec2(keycode,2),0 ).x == 0.0;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    float time = iTime * 1.0;\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = gl_FragCoord.xy/iResolution.x - vec2(0.5, iResolution.y/iResolution.x/2.0);\n\n    vec2 focus_point = iMouse.xy/iResolution.x - vec2(0.5, iResolution.y/iResolution.x/2.0);\n\n    int mode;\n    if(isKeyToggled(KEY_UP)) {\n        mode = 0;\n    } else {\n        mode = 4;\n    }\n\n\n    vec3 color; \n\n\n    \n    \n    \n    \n    vec4 buffer_color = texture(iChannel0, fragCoord/iResolution.xy).rgba;\n    color.g = 0.0;\n    \n    if(isKeyToggled(KEY_SPACE)) {\n        color = gscolormap(20.0*log(length(buffer_color.rg/3.0))/80.0+1.0);\n    } else {\n        color = rbcolormap(buffer_color.r);\n    }\n    \n    if(isKeyToggled(KEY_LEFT)){\n        color = mix(color, vec3(0.0, 0.0, 1.0), buffer_color.b);\n    }\n    \n    \n\n    float circ_alpha = circle(uv, focus_point, 0.006);\n    color = mix(color, vec3(0.0,1.,0.), circ_alpha);\n\n\n    color = mix(color, vec3(1.0), buffer_color.a);\n    \n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define product(a, b) vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x)\n#define conjugate(a) vec2(a.x,-a.y)\n#define divide(a, b) vec2(((a.x*b.x+a.y*b.y)/(b.x*b.x+b.y*b.y)),((a.y*b.x-a.x*b.y)/(b.x*b.x+b.y*b.y)))\n#define cexp(p) vec2(cos(p), sin(p))\n\n// Keyboard key alias\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_SPACE  = 32;\n\n// General (physical) units\nconst float cm_per_unit = 20.0;\nconst float m_per_unit = cm_per_unit/100.0;\nconst float c = 1540.0;\nfloat PI = 3.14159265359;\nconst float mega = 1000000.0;\n\nconst float brush_size = 0.05;\n\n// Define signal\nconst float pulse_std = 1.0 / 1000.0 / c; // unit=[s]\nconst float f = 1.0*mega;  // unit=[Hz]\n\n\n// Define the array\nconst int M = 20;\nconst vec2 mid_pos = vec2(-0.48, 0.0);\nconst vec2 array_dir = vec2(0.0, 5.0/2.0/cm_per_unit); // 5cm long array\nconst vec2 array_normal = normalize(vec2(-array_dir.y, array_dir.x));\n\n// ==== Helper functions ====\n\n\nfloat vonHannWindow(int n, int M) {\n    return 0.5*(1.0+cos(2.0*PI*float(n)/float(M-1)));\n}\n\n/* Red-Blue color map for values from -1 to 1*/\nvec3 rbcolormap(float val) {\n\n    return vec3(clamp(val, 0.0, 1.0), 0.0, clamp(-val, 0.0, 1.0));\n}\n\n/* Gray-scale color map for values from 0 to 1*/\nvec3 gscolormap(float val) {\n\n    return vec3(clamp(val, 0.0, 1.0));\n}\n\n// Get 2d coordinate of array element\nvec2 getElemPos(int m, int M) {\n    float s = float(m)/float(M-1)*2.0-1.0;\n    return mid_pos + array_dir * s;\n}\n\n// Check if keyboard key is set\nbool isKeyToggled(int keycode) {\n    return texelFetch( iChannel1, ivec2(keycode,2),0 ).x == 0.0;\n}\n\n// Alpha value of a circle with defiend midpoint and radius and query point\nfloat circle(vec2 uv, vec2 center, float radius) {\n    float rad = length((uv-center)*iResolution.xy/iResolution.x);\n    float val = clamp(radius-rad, 0.0, 1.3/iResolution.x)*iResolution.x/1.3;\n    \n    return val;\n}\n\nvec2 coord_to_uv(vec2 coord) {\n    return (coord + vec2(0.5, iResolution.y/iResolution.x/2.0))*iResolution.x/iResolution.xy;\n}\n\n// Spatial point response + scatter map\nvec3 compute_spr(vec2 uv, vec2 texuv, vec2 mouse_texuv, vec2 focus_point) {\n    vec2 value = vec2(0.0);\n    \n    for(int txi=0;txi<M;txi++) {\n        for(int rxi=0;rxi<M;rxi++) {\n            vec2 tx_pos = getElemPos(txi, M);\n            vec2 rx_pos = getElemPos(rxi, M);\n            \n            float px_roundtrip = length(uv - tx_pos) + length(uv - rx_pos); // pixel roundtrip distance (tx -> px -> rx)\n            float scat_roundtrip = length(focus_point - tx_pos) + length(focus_point - rx_pos); // scatter roundtrip distance (tx -> scat -> rx)\n\n            float delay = (scat_roundtrip-px_roundtrip)*m_per_unit/c;\n            value += cexp(2.0*PI*f*delay)*exp(-delay*delay/(pulse_std*pulse_std))*vonHannWindow(txi,M)*vonHannWindow(rxi,M);\n        }\n    }\n    value = value/float(M*M);\n    \n    float circle_alpha = circle(texuv, coord_to_uv(focus_point), 0.002);\n    \n    return vec3(value*0.5*f/mega, circle_alpha);\n}\n\n\n// === Main drawing function ====\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec2 mouse_texuv = iMouse.xy/iResolution.xy;\n    vec2 texuv = fragCoord/iResolution.xy;\n    \n    \n    vec2 px_coord = gl_FragCoord.xy/iResolution.x - vec2(0.5, iResolution.y/iResolution.x/2.0);\n    vec2 mouse_coord = iMouse.xy/iResolution.x - vec2(0.5, iResolution.y/iResolution.x/2.0);\n    \n    \n    \n    vec3 color = texture(iChannel0, texuv).rgb;\n    float array_indicator = 0.0;\n    for(int m=0;m<M;m++) {\n        vec2 elem_pos = getElemPos(m, M);\n        float circ_alpha = circle(px_coord, elem_pos, 0.002);\n        array_indicator = clamp(array_indicator+circ_alpha, 0.0, 1.0);\n    }\n    \n    int BRUSH_NUM = 1;\n    \n    if(isKeyToggled(KEY_RIGHT)) {\n        BRUSH_NUM = 8;\n    }\n    \n    if(BRUSH_NUM == 1) {\n        vec2 focus_point = mouse_coord;\n        vec3 spr_res = compute_spr(px_coord, texuv, mouse_texuv, focus_point);\n        color += vec3(spr_res.rg, spr_res.b);\n    } else {\n        for(int i=0; i<BRUSH_NUM; i++){\n            float angle = texelFetch(iChannel2, ivec2((i+int(iMouse.y*1000.))%64, (int(iMouse.x*1000.))%64), 0).r*2.0*PI*3.0;\n            float scale = texelFetch(iChannel2, ivec2(i, 1), 0).r*brush_size;\n            vec2 brush_point = cexp(angle)*scale;\n            vec2 focus_point = brush_point + mouse_coord;\n            vec3 spr_res = compute_spr(px_coord, texuv, mouse_texuv, focus_point)/sqrt(float(BRUSH_NUM))*1.5;\n            color += vec3(spr_res.rg, spr_res.b);\n        }\n    }\n    \n    fragColor = vec4(color, array_indicator);\n}","name":"Buffer A","description":"","type":"buffer"}]}