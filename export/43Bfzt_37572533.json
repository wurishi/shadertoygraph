{"ver":"0.1","info":{"id":"43Bfzt","date":"1729796475","viewed":85,"name":"z^3","username":"pb","description":"this would make a very inefficient gearbox","likes":13,"published":1,"flags":32,"usePreview":0,"tags":["2d","fractal"],"hasliked":0,"parentid":"X3SfR3","parentname":"zz six^n"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//philip.bertani@gmail.com\n//see buffer A please\n\nvoid mainImage(out vec4 O, vec2 u) {\n\n    vec2 R = iResolution.xy,\n        uv = u/R;\n\n    O *= 0.;\n\n    float[] gk1s = float[](\n        0.003765, 0.015019, 0.023792, 0.015019, 0.003765,\n        0.015019, 0.059912, 0.094907, 0.059912, 0.015019,\n        0.023792, 0.094907, 0.150342, 0.094907, 0.023792,\n        0.015019, 0.059912, 0.094907, 0.059912, 0.015019,\n        0.003765, 0.015019, 0.023792, 0.015019, 0.003765\n    );\n\n    //golfed by fabriceneyret2\n    for (int k; k < 25; k++)      \n        O += gk1s[k] * texture(iChannel0, uv + ( vec2(k%5,k/5) - 2. ) / R );\n          \n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// philip.bertani@gmail.com\nvoid mainImage0( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;          \n    vec2 center = vec2(0), width=vec2(mod(iTime,30.));\n    vec2 z = uv * width + center ; \n    float max_iter=10., mix_factor=.00001, infinity=1e6;\n    vec2 wgt=vec2(mix_factor, 1.-mix_factor);\n    float r=.055,an=iTime/3.;  //the Julia set params, play with it\n    vec2 jc = vec2(r*cos(an),r*sin(an));\n    float escape_value = 0.;\n    for ( float i=0.; i<max_iter; i++ ) {\n        vec2 tmp = vec2(z.x*z.x*z.x - 3.*z.x*z.y*z.y,\n                       -z.y*z.y*z.y + 3.*z.x*z.x*z.y);               \n        float div = max(tmp.x*tmp.x+tmp.y*tmp.y,1e-6);      \n        z = wgt.x*tmp + wgt.y*vec2(tmp.x,-tmp.y)/div+jc;\n        float distance = z.x*z.x + z.y*z.y;\n        if ( distance > infinity ) {\n            escape_value = i;\n            break;\n        }     \n    }\n    fragColor = vec4( min(escape_value,1.) );\n\n}\n\n//FabriceNeyret2 antialiasing trick\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    if ( fwidth(length(O)) > .01 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { mainImage0(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n        //O.b++;                        // uncomment to see where the oversampling occurs\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}