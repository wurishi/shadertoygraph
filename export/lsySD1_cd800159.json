{"ver":"0.1","info":{"id":"lsySD1","date":"1464061619","viewed":145,"name":"Colorful Flowing Thing","username":"sillsm","description":"It's a colorful flowing thing.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Copyright Max Sills 2016, licensed under the MIT license.\n//\n// Quaternion rotation around axis, of angle, centered at center.\nvec3 qRotate(vec3 axis, float angle, vec3 center, vec3 point)\n{\naxis = normalize(axis);\nfloat x = axis.x * sin(angle / 2.);\nfloat y = axis.y * sin(angle / 2.);\nfloat z = axis.z * sin(angle / 2.);\nfloat w = cos(angle / 2.);\n\nmat3 rotation = mat3(1. - 2.*y*y - 2.*z*z, 2.*(x*y+w*z), 2.*(x*z-w*y),\n                     2.*(x*y-w*z), 1. - 2.*x*x - 2.*z*z, 2.*(y*z +w*x),\n                     2.*(x*z + w*y), 2.*(y*z-w*x),1. - 2.*x*x - 2.*y*y);\n     \nreturn center + (rotation * (point-center));\n}\n\n// Rounded box minus a sphere with oscilating radius.\nfloat udBox( vec3 p, vec3 b )\n{\n  p = qRotate(vec3(0,1.,1.),10.,vec3(0.), p);\n  float dist = max(length(max(abs(p)-b,0.0)) - 1., -1.*(length(p)));\n  dist += 5.*sin(iTime+ p.x)*cos(p.y);\n    return dist;\n}\n\n\nvec4 trace(vec3 ray, vec3 viewportxy)\t\t\t\t\n{\n    vec3 p = vec3(0);\n    float t = 0.0;\n    for (int i = 0; i < 64; ++i)\t\t\t\t\n    {\t\n        //   the amount t must be to get to it\n        p = viewportxy + (t* ray);\t\t\t\t\n        float dist = udBox(p, vec3(1,1,1));\n        t += dist * .9;\n    }\n    return vec4(p,t);\t\t\t\t\t\t\t\n}\n\n// Compute the camera to world transform.\n// Rotates then translates.\nmat4 LookAtRH( vec3 eye, vec3 target, vec3 up )\n{\n    vec3 zaxis = normalize(target-eye);      // The \"forward\" vector.\n    vec3 xaxis = normalize(cross(up, zaxis));// The \"right\" vector.\n    vec3 yaxis = cross(zaxis, xaxis);        // The \"up\" vector.\n\n    return  mat4(\n        vec4(      xaxis,       0 ),\n        vec4(      yaxis,       0 ),\n        vec4(      zaxis,       0 ),\n        vec4(      eye,         1 )\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\t// Scale pixel coords to 0..1 range instead\n    uv = uv * 2.0 - 1.0;\t\t\t\t\t\t// Now to the -1 to +1 range\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 eye = vec3(0, 0, -7);\n    vec3 screen = vec3(0,0,-5);\n    vec4 pixel = vec4(uv, 0, 1);\n    \n    eye = qRotate(vec3(0,1.,0.),iTime,vec3(0.), eye);\n    vec3 newScreen = qRotate(vec3(0,1.,0.),iTime,vec3(0.), screen);\n    \n    mat4 mat = LookAtRH(newScreen, vec3(0), vec3(0,1,0));\n    vec3 pt = (mat*pixel).xyz;\n    vec3 ray = normalize(pt - eye);\n    \n    vec4 tr     = trace(ray, pt);\n    vec3 ref    = vec3(0.,0.,1.);\n    float t     = tr.w;\n\n    vec3 x = dFdx(tr.xyz);\n    vec3 y = dFdy(tr.xyz);\n    vec3 normal = normalize(cross(x,y));\n    \n    normal = abs(normal);\n\n    vec3 col = 5.*(1./t)*vec3(normal);\n    col *= .8; // Gamma correction.\n\n    fragColor = vec4(col, 0);\n}","name":"Image","description":"","type":"image"}]}