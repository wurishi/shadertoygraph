{"ver":"0.1","info":{"id":"lldSD4","date":"1480870370","viewed":128,"name":"BlobImplicite","username":"Idarn","description":"Apprentissage de création de forme implicite","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3dimplicitelearning"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Blobs\n//Eric Galin\n\nconst int Steps = 1000;\nconst float Epsilon = 0.05; //Pas de déplacement sur le rayon\n\nconst float factor = 10.0;\n\n//Distance min et max du rayon\nconst float rA=10.0; \nconst float rB=40.0; \n\n//Définition de différents vecteurs de couleur\nconst vec3 red=vec3(1.0,0.0,0.0);\nconst vec3 blue=vec3(0,0.0,1.0);\nconst vec3 green=vec3(0.0,1.0,0.0);\nconst vec3 grey = vec3(0.5,0.5,0.5);\nconst vec3 grey2 = vec3(0.2,0.2,0.2);\nconst vec3 jaune = vec3(1.0,0.9,0.3);\nconst vec3 orange = vec3(0.958,0.3,0.0);\nconst vec3 noir = vec3(0.0,0.0,0.0);\n\n\nvec3 warp(in vec3 p)\n{\n\tfloat b = 1.0;\n    vec3 pprime = p;\n    pprime.x += b;\n    pprime.y += cos(b)*b;\n    pprime.z += sin(b)*b;\n    return pprime;\n}\n\n//Transformation\nvec3 rotateX(vec3 p, float a)\n{\n  return vec3(p.x, cos(a)*p.y - sin(a)*p.z, sin(a)*p.y + cos(a)*p.z);\n}\n\nvec3 rotateY(vec3 p, float a)\n{\n  return vec3(cos(a)*p.x + sin(a)*p.z, p.y, -sin(a)*p.x + cos(a)*p.z);\n}\n\nvec3 rotateZ(vec3 p, float a)\n{\n  return vec3(cos(a)*p.x + sin(a)*p.y, -sin(a)*p.x + cos(a)*p.y, p.z);\n}\n\n\nfloat falloff( float r, float R )\n{\n  float x = clamp(r/R,0.0,1.0);\n  float y = (1.0-x*x);\n  return y*y*y;\n}\n\n//Primitive functions\n\n//Base d'un point\n//p : Point\n//c : Centre du squelette\n//e : Energy du squelette\n//R : Rayon du point (pour sphere)\nfloat point(vec3 p, vec3 c, float e,float R)\n{\n  return e*falloff(length(p-c),R);\n}\n\n//Base d'un segment\n//p : Point\n//a : Premier point du segment\n//b : Second point du segment\n//e : Energy du squelette\n//R : Distance du squelette à la forme\nfloat segment(vec3 p, vec3 a, vec3 b, float e, float R)\n{\n    vec3 dir = normalize(b-a);\n    float dist = length(a-b);\n    float n = dot(p-a,dir);\n    float d = 0.0;\n    if(n <= 0.0) {\n        d = length(p-a);\n    }\n    else {\n        if(n >= dist) {\n            d = length(p-b);\n        }\n        else {\n            d = length(p-(a+dir*n));\n        }\n    }\n    return e*falloff(d, R);   \n}\n\n//Base d'une boite\n//p : Point\n//a : Point de la boite en bas à gauche au premier plan\n//b : Point de la boite en haut à droite au second plan\nfloat boite(vec3 p, vec3 a, vec3 b, float e, float R)\n{\n\tfloat d = 0.0;\n    \n    if(p.x < a.x) \n        d += (a.x-p.x)*(a.x-p.x);\n    else if(p.x > b.x)\n        d += (b.x-p.x)*(b.x-p.x);\n\n        \n    if(p.y < a.y) \n        d += (a.y-p.y)*(a.y-p.y);\n    else if(p.y > b.y)\n        d += (b.y-p.y)*(b.y-p.y);\n\n    \n    if(p.z < a.z) \n        d += (a.z-p.z)*(a.z-p.z);\n    else if(p.z > b.z)\n        d += (b.z-p.z)*(b.z-p.z);\n\n    return e*falloff(d,R);\n}\n\n//Base d'un disque\n//p : Point\n//c : Centre du disque\n//n : Normale du plan du disque\n//r : Rayon du disque\n//e : Energie du squelette\n//E : Epaisseur du disque\nfloat disque(vec3 p, vec3 c, vec3 n, float r, float e, float E)\n{\n\tn = normalize(n);\n    vec3 pc = p-c;\n    float proj = dot(pc,n);\n    vec3 cn = c + proj*n;\n    vec3 cnp = normalize(p-cn);\n    vec3 h = c + r*cnp;\n    float projhc = dot(pc, cnp);\n    vec3 pprime = c + projhc * cnp;\n    float d = 0.0;\n    if(length(c-pprime) > r)\n    {\n    \td = length(p-h);   \n    }\n    else\n    {\n        d = length(p - pprime);\n        \n    }\n    return e*falloff(d, E);\n    \n}\n\nfloat cylindre(vec3 p, vec3 a, vec3 b, float r, float e, float R)\n{\n    vec3 dir = normalize(b-a);\n    float dist = dot(p-a, dir);\n    if(dist < 0.0)\n        return disque(p, a, dir, r, e, R);\n    else\n        if (dist > length(b-a))\n            return disque(p, b, dir, r, e, R);\n        else\n            return disque(p, a+dist*dir, dir, r, e, R);\n}\n\n//Base d'un cercle\n//p : Point\n//c : Centre du cercle\n//n : Normale du plan du cercle\n//e : Energie du squelette\n//r : Rayon du cercle\n//E : Epaisseur du cercle\nfloat cercle(vec3 p, vec3 c, vec3 n, float r, float e, float E)\n{\n\tn = normalize(n);\n    vec3 pc = p-c;\n    float proj = dot(pc,n);\n    vec3 cn = c + proj*n;\n    vec3 cnp = normalize(p-cn);\n    vec3 h = c + r*cnp;\n    return e*falloff(length(p-h), E);\n    \n}\n\n\nfloat Intersection(float a, float b, in vec3 color1, in vec3 color2, out vec3 colorOut)\n{\n    if(a < b)\n        colorOut = color1;\n    else\n        colorOut = color2;\n \treturn min(a,b);   \n}\n\n\nfloat Diff(float a,float b, in vec3 color1, in vec3 color2, out vec3 colorOut)\n{\n    colorOut = color1;\n    return a-b;\n}\n\n\nfloat Union(float a,float b, in vec3 color1, in vec3 color2, out vec3 colorOut)\n{\n    if( a > b)\n        colorOut = color1;\n    else\n        colorOut = color2;\n    return max(a,b);\n}\n\n\nfloat Blend(float a,float b, in vec3 color1, in vec3 color2, out vec3 colorOut)\n{\n    colorOut = (a*color1 + b*color2) / (a+b);\n    return a+b;\n}\n\n\nfloat Cut(float a, float b, float t, in vec3 color1, out vec3 colorOut)\n{\n    colorOut = color1;\n \treturn min(a, 2.0*t-b);   \n}\n\n\nfloat Lamp(vec3 p, out vec3 colorOut)\n{\n\t//Création d'une première boule\n    vec3 pointBoule1 = vec3(((1.3+cos(iTime*0.35))/2.0)*3.5-1.75, 0.2*sin(iTime), 0.2*cos(iTime));\n \tfloat boule1 = point(warp(p), pointBoule1, 1.5, 1.5);\n\t\n\t//Création d'une seconde boule\n    vec3 pointBoule2 = vec3(((1.0+cos(iTime*0.35))/2.0)*3.5-1.75, 0.35*sin(iTime), 0.35*cos(iTime));\n \tfloat boule2 = point(warp(p), pointBoule2, 1.5, 1.5);\n\t\n\t//Création d'une troisième boule\n    vec3 pointBoule3 = vec3(1.0+cos(iTime*3.0), (1.0+cos(iTime*3.0))*3.0-3.0, 1.0+sin(iTime*3.0));\n \tfloat boule3 = point(warp(p), pointBoule3, 1.75, 2.25);\n\t\n\t//Pour d'un segment\n\tfloat seg = segment(p, vec3(0.0,-5.5,0.0), vec3(0.0, 5.5, 0.0), 1.0, 0.5);\n\t//On blend la troisième au segment\n    float v1 = Blend(boule3, seg, red, jaune, colorOut);\n\t\n\t//Initialisation de la forme implicite\n\t//On intersect les deux premières boules\n    float v = Intersection(boule1, boule2, blue, green, colorOut);\n\t\n    //Puis on Blend v à v1\n    v = Blend(v, v1, colorOut, red, colorOut);\n    \n    vec3 colorLamp;\n\t//On initialise une quatrième sphère statique\n    float rsphere = point(p, vec3(0.0, 5.5, 0.0), 4.,4.);\n\t//Puis on vient l'extruder à partir d'un cylindre\n    rsphere = Cut(rsphere, cylindre(p, vec3(0.,0.,0.), vec3(0.0,3.5,0.), 1., 4.0, 2.0), 0.5, mix(grey, grey2, 0.5), colorLamp);\n\t//On l'ajoute à la scène\n    v = Union(v, rsphere, colorOut, orange, colorOut);\n\t\n\t//On crée ensuite un disque\n\tfloat ldisque = disque(p, vec3(0.0, -5.5, 0.0), vec3(0.0, 1.0, 0.0), 1.5, 2.5, 0.1);\n\t//On Blend le disque\n    v = Blend(v, ldisque, colorOut, grey, colorOut);\n    \n    return v;\n}\n\n//Potential field of the object\n//p : point\n//color : color of the point\nfloat object(vec3 p, out vec3 color)\n{\n\tp.z=-p.z;\n\n\tfloat v = Lamp(p, color);\n\n\treturn v-0.5;\n}\n\n//Calculate object normal\n//p : point\nvec3 ObjectNormal(in vec3 p )\n{\n  float eps = 0.0001;\n  vec3 n;\n    vec3 color;\n  float v = object(p, color);\n  n.x = object( vec3(p.x+eps, p.y, p.z) , color) - v;\n  n.y = object( vec3(p.x, p.y+eps, p.z) , color) - v;\n  n.z = object( vec3(p.x, p.y, p.z+eps) , color) - v;\n  return normalize(n);\n}\n\n//Trace ray using ray marching\n//o : ray origin\n//u : ray direction\n//h : hit\n//s : Number of steps\n//color : color of the point\nfloat Trace(vec3 o, vec3 u, out bool h,out int s, out vec3 color)\n{\n  h = false;\n\n    //Don't start at the origin, instead move a little bit forward\n    float t=rA;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = object(p, color);\n    //Hit object\n      if (v > 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      //Move along ray\n      t += Epsilon;\n      //Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n//Trace ray using ray marching\n//o : ray origin\n//u : ray direction\n//h : hit\n//s : Number of steps\n//color : color of the point\nfloat SphereTrace(vec3 o, vec3 u, out bool h,out int s, out vec3 color)\n{\n  h = false;\n\n    //Don't start at the origin, instead move a little bit forward\n    float t=rA;\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = object(p, color);\n    //Hit object\n      if (v > 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      //Move along ray\n      t += max(Epsilon,abs(v)/factor);\n      //Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n\n//Background color\nvec3 background(vec3 rd)\n{\n  return mix(vec3(0.4, 0.3, 0.0), vec3(0.7, 0.8, 1.0), rd.y*0.5+0.5);\n}\n\n//Shading and lighting\n//p : point,\n//n : normal at point\n//color : color of the point\nvec3 Shade(vec3 p, vec3 n, in vec3 color)\n{\n  //point light\n  const vec3 lightPos = vec3(5.0, 5.0, 5.0);\n  const vec3 lightColor = vec3(0.5, 0.5, 0.5);\n\n  vec3 c = 0.5*color;\n  vec3 l = normalize(lightPos - p);\n\n  //Not even Phong shading, use weighted cosine instead for smooth transitions\n  float diff = 0.5*(1.0+dot(n, l));\n\n  c += diff*lightColor;\n\n  return c;\n}\n\n//Shading with number of steps\nvec3 ShadeSteps(int n)\n{\n   float t=float(n)/(float(Steps-1));\n   return vec3(t,0.25+0.75*t,0.5-0.5*t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 pixel = (gl_FragCoord.xy / iResolution.xy)*2.0-1.0;\n\n  //compute ray origin and direction\n  float asp = iResolution.x / iResolution.y;\n  vec3 rd = normalize(vec3(asp*pixel.x, pixel.y, -2.0));\n  vec3 ro = vec3(0.0, 0.0, 20.0);\n\n  float a=iTime;\n  //ro = rotateY(ro, 0.2);\n  //rd = rotateY(rd, 0.2);\n  //Trace ray\n  bool hit;\n\n  //Number of steps\n  int s;\n\tvec3 color;\n  float t = SphereTrace(ro, rd, hit,s, color);\n  vec3 pos=ro+t*rd;\n  //Shade background\n  vec3 rgb = background(rd);\n\n  if (hit)\n  {\n    //Compute normal\n    vec3 n = ObjectNormal(pos);\n\n    //Shade object with light\n    rgb = Shade(pos, n, color);\n  }\n\n  //Uncomment this line to shade image with false colors representing the number of steps\n\t//rgb = ShadeSteps(s);\n\n  fragColor=vec4(rgb, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}