{"ver":"0.1","info":{"id":"lftXz7","date":"1713757319","viewed":43,"name":"im hungry","username":"hamsterisnotcute","description":"pls help","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["dk"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\n\nfloat sdSphere(vec3 p, float r )\n{\n  return length(p) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,1.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdBox2( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,-1.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdScene(vec3 p) {\n  return sdSphere(p, 1.);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    float d = sdScene(p);\n    depth += d;\n    if (d < PRECISION || depth > MAX_DIST) break;\n  }\n\n  return depth;\n}\n\nvec3 normal(vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005;\n    return normalize(\n      e.xyy * sdScene(p + e.xyy) +\n      e.yyx * sdScene(p + e.yyx) +\n      e.yxy * sdScene(p + e.yxy) +\n      e.xxx * sdScene(p + e.xxx));\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n    vec3 cd = normalize(lookAtPoint - cameraPos);\n    vec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n    vec3 cu = normalize(cross(cd, cr));\n    return mat3(-cr, cu, -cd);\n}\nvec3 phong(vec3 lightDir, vec3 normal, vec3 rd) {\n  float k_a = 0.6;\n  vec3 i_a = vec3(0.7, 0.7, 0);\n  vec3 ambient = k_a * i_a;\n  float k_d = 0.5;\n  float dotLN = clamp(dot(lightDir, normal), 0., 1.);\n  vec3 i_d = vec3(0.7, 0.5, 0);\n  vec3 diffuse = k_d * dotLN * i_d;\n  float k_s = 0.6;\n  float dotRV = clamp(dot(reflect(lightDir, normal), -rd), 0., 1.);\n  vec3 i_s = vec3(1, 1, 1);\n  float alpha = 10.;\n  vec3 specular = k_s * pow(dotRV, alpha) * i_s;\n  return ambient + diffuse + specular;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec3 backgroundColor = vec3(0.835, 1, 1);\n  vec3 col = vec3(0);\n  \n  float timeOffset = iTime * 0.5f;\n  uv.x += sin(uv.y * 10.0 + timeOffset) * 0.05;\n  uv.y += cos(uv.x * 10.0 + timeOffset) * 0.05;\n\n  vec3 lp = vec3(0); // lookat point (aka camera target)\n  vec3 ro = vec3(0, 0, 3);\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n  float d = rayMarch(ro, rd);\n\n  if (d > MAX_DIST) {\n    col = backgroundColor;\n  } else {\n      vec3 p = ro + rd * d; // point on surface found by ray marching\n      vec3 normal = normal(p); // surface normal\n      vec3 lightPos1 = vec3(-8, -6, -5);\n      vec3 lightDir1 = normalize(lightPos1 - p);\n      float lightInt1 = 0.6;\n      col = lightInt1 * phong(lightDir1, normal, rd);\n  }\n\n  fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}