{"ver":"0.1","info":{"id":"4X2BRy","date":"1729615353","viewed":131,"name":"stop war","username":"nayk","description":"originals","likes":0,"published":3,"flags":0,"usePreview":0,"tags":["fractal","flag","cosmos","words"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define size 125.\n\nvec2 Hash12(float t)\n{\n    float x = fract(sin(t * 1674.3) * 453.2);\n    float y = fract(sin(t * 2674.3) * 453.2);\n    \n    return vec2(x,y);\n}\nvec3 rgbToYuv(vec3 rgb) {\n    float luma = rgb.g;\n    float blueness = rgb.b - luma;\n    float redness = rgb.r - luma;\n    return vec3(luma, redness, blueness);\n}\nvec3 palette( float t ) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 0.5);\n    vec3 d = vec3(0.263,0.416,0.557);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nvec3 yuvToRgb(vec3 yuv) {\n    float green = yuv.x;\n    float red = yuv.y + green;\n    float blue = yuv.z + green;\n    return vec3(red, green, blue);\n}\n \nvec4 mod289(vec4 x)\n{\n    return x - floor(x * (1.0 / 29.0)) * 28.0;\n}\n \nvec4 permute(vec4 x)\n{\n    return mod289(((x*34.0)+1.0)*x);\n}\n \nvec4 taylorInvSqrt(vec4 r)\n{\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n \nvec2 fade(vec2 t) {\n    return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\nfloat cnoise(vec2 P)\n{\n    vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n    vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n    Pi = mod289(Pi); // To avoid truncation effects in permutation\n    vec4 ix = Pi.xzxz;\n    vec4 iy = Pi.yyww;\n    vec4 fx = Pf.xzxz;\n    vec4 fy = Pf.yyww;\n     \n    vec4 i = permute(permute(ix) + iy);\n     \n    vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n    vec4 gy = abs(gx) - 0.5 ;\n    vec4 tx = floor(gx + 0.5);\n    gx = gx - tx;\n     \n    vec2 g00 = vec2(gx.x,gy.x);\n    vec2 g10 = vec2(gx.y,gy.y);\n    vec2 g01 = vec2(gx.z,gy.z);\n    vec2 g11 = vec2(gx.w,gy.w);\n     \n    vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n    g00 *= norm.x;  \n    g01 *= norm.y;  \n    g10 *= norm.z;  \n    g11 *= norm.w;  \n     \n    float n00 = dot(g00, vec2(fx.x, fy.x));\n    float n10 = dot(g10, vec2(fx.y, fy.y));\n    float n01 = dot(g01, vec2(fx.z, fy.z));\n    float n11 = dot(g11, vec2(fx.w, fy.w));\n     \n    vec2 fade_xy = fade(Pf.xy);\n    vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n    float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n    return 2.3 * n_xy;\n}\n\nfloat fbm(vec2 P, float lacunarity, float gain)\n{\n    float sum = 0.0;\n    float amp = 1.0;\n    vec2 pp = P;\n     \n    for(int i = 0; i < 4; i+=1)\n    {\n        amp *= gain; \n        sum += amp * cnoise(pp);\n        pp *= lacunarity;\n    }\n    return sum;\n \n}\n#define time iTime\n\nvec2 uv3;\n\n\nconst vec2 ch_size  = vec2(1.0, 2.0);              // character size (X,Y)\nconst vec2 ch_space = ch_size + vec2(1.0, 1.0);    // character distance Vector(X,Y)\nconst vec2 ch_start = vec2 (ch_space.x * -6., 2.); // start position\n      vec2 ch_pos   = vec2 (0.0, 0.0);             // character position(X,Y)\n      vec3 ch_color = vec3 (0.1, 0.15, 0.1);        // character color (R,G,B)\nconst vec3 bg_color = vec3 (0.0, 0.0, 0.0);        // background color (R,G,B)\n\n#define REPEAT_SIGN false // True/False; True=Multiple, False=Single\n\n/* 16 segment display...Akin to LED Display.\n\nSegment bit positions:\n  __2__ __1__\n |\\    |    /|\n | \\   |   / |\n 3  11 10 9  0\n |   \\ | /   |\n |    \\|/    |\n  _12__ __8__\n |           |\n |    /|\\    |\n 4   / | \\   7\n | 13 14  15 |\n | /   |   \\ |\n  __5__|__6__\n\n15 12 11 8 7  4 3  0\n |  | |  | |  | |  |\n 0000 0000 0000 0000\n\nexample: letter B\n\n   12    8 7  4 3210\n    |    | |  | ||||\n 0001 0001 1001 1111\n\n binary to hex -> 0x119F\n*/\n\n#define n1 ddigit(0x22FF);\n#define n9 ddigit(0x0281);\n#define n0 ddigit(0x1177);\n#define n0 ddigit(0x1177);\n#define n1 ddigit(0x22FF);\n#define n6 ddigit(0x11EE);\n#define n3 ddigit(0x11FE);\n#define n8 ddigit(0x2206);\n\n#define A ddigit(0x119F);\n#define B ddigit(0x927E);\n#define C ddigit(0x007E);\n#define D ddigit(0x44E7);\n#define E ddigit(0x107E);\n#define F ddigit(0x101E);\n#define G ddigit(0x807E);\n#define H ddigit(0x1199);\n#define I ddigit(0x4466);\n#define J ddigit(0x4436);\n#define K ddigit(0x9218);\n#define L ddigit(0x0078);\n#define M ddigit(0x0A99);\n#define N ddigit(0x8899);\n#define O ddigit(0x00FF);\n#define P ddigit(0x111F);\n#define Q ddigit(0x80FF);\n#define R ddigit(0x911F);\n#define S ddigit(0x8866);\n#define T ddigit(0x4406);\n#define U ddigit(0x00F9);\n#define V ddigit(0x2218);\n#define W ddigit(0xA099);\n#define X ddigit(0xAA00);\n#define Y ddigit(0x4A00);\n#define Z ddigit(0x2266);\n#define _ ch_pos.x += ch_space.x;\n#define s_dot     ddigit(0);\n#define s_minus   ddigit(0x1100);\n#define s_plus    ddigit(0x5500);\n#define s_greater ddigit(0x2800);\n#define s_less    ddigit(0x8200);\n#define s_sqrt    ddigit(0x0C02);\n#define nl1 ch_pos = ch_start;  ch_pos.y -= 3.0;\n#define nl2 ch_pos = ch_start;  ch_pos.y -= 6.0;\n#define nl3 ch_pos = ch_start;\tch_pos.y -= 9.0;\n#define resolution iResolution.xy\n#define time iTime\nfloat dseg(vec2 p0, vec2 p1)\n{\n\tvec2 dir = normalize(p1 - p0);\n\tvec2 cp = (uv3 - ch_pos - p0) * mat2(dir.x, dir.y,-dir.y, dir.x);\n\treturn distance(cp, clamp(cp, vec2(0), vec2(distance(p0, p1), 0)));   \n}\n\nbool bit(int n, int b)\n{\n\treturn (n/b)*2!=n/(b/2); \n\t//return mod(floor(float(n) / exp2(floor(float(b)))), 2.0) != 0.0;\n}\n\nfloat d = 1e6;\n\nvoid ddigit(int n)\n{\n\tfloat v = 1e6;\t\n    float tt = mod(iTime, 10.);\n    if(tt<5.5){\n\tvec2 cp = uv3 - ch_pos;\n\tif (n == 0)         v = min(v, dseg(vec2(-0.405+cos(iTime), -1.000), vec2(-0.500+sin(iTime), -1.000)));\n\tif (bit(n,  2))     v = min(v, dseg(vec2( 0.500+cos(iTime),  0.063), vec2( 0.500,  0.937)));\n\tif (bit(n,  4))     v = min(v, dseg(vec2( 0.438,  1.000), vec2( 0.063,  1.000)));\n\tif (bit(n,  8))     v = min(v, dseg(vec2(-0.063+sin(iTime),  1.000), vec2(-0.438+cos(iTime),  1.000)));\n\tif (bit(n,  16))    v = min(v, dseg(vec2(-0.500,  0.937), vec2(-0.500,  0.062)));\n\tif (bit(n,  32))    v = min(v, dseg(vec2(-0.500+cos(iTime), -0.063), vec2(-0.500, -0.938)));\n\tif (bit(n,  64))    v = min(v, dseg(vec2(-0.438, -1.000), vec2(-0.063, -1.000)));\n\tif (bit(n,  128))   v = min(v, dseg(vec2( 0.063+sin(iTime), -1.000), vec2( 0.438, -1.000)));\n\tif (bit(n,  256))   v = min(v, dseg(vec2( 0.500, -0.938), vec2( 0.500+cos(iTime), -0.063)));\n\tif (bit(n,  512))   v = min(v, dseg(vec2( 0.063,  0.000), vec2( 0.438+sin(iTime), -0.000)));\n\tif (bit(n,  1024))  v = min(v, dseg(vec2( 0.063+cos(iTime),  0.063), vec2( 0.438,  0.938)));\n\tif (bit(n,  2048))  v = min(v, dseg(vec2( 0.0,  0.063), vec2( 0.000,  0.937)));\n\tif (bit(n,  4096))  v = min(v, dseg(vec2(-0.063+sin(iTime),  0.063), vec2(-0.438,  0.938)));\n\tif (bit(n,  8192))  v = min(v, dseg(vec2(-0.438,  0.000), vec2(-0.063+cos(iTime), -0.000)));\n\tif (bit(n,  16384)) v = min(v, dseg(vec2(-0.063+cos(iTime), -0.063), vec2(-0.438+sin(iTime), -0.938)));\n\tif (bit(n,  32768)) v = min(v, dseg(vec2( 0.000, -0.938), vec2( 0.000, -0.063)));\n\tif (bit(n,  65536)) v = min(v, dseg(vec2( 0.063+sin(iTime), -0.063), vec2( 0.438+cos(iTime), -0.938)));\n\tch_pos.x += ch_space.x;\n    }\n    if(tt>5.5){\n\tvec2 cp = uv3 - ch_pos;\n\tif (n == 0)         v = min(v, dseg(vec2(-0.405, -1.000), vec2(-0.500, -1.000)));\n\tif (bit(n,  2))     v = min(v, dseg(vec2( 0.500,  0.063), vec2( 0.500,  0.937)));\n\tif (bit(n,  4))     v = min(v, dseg(vec2( 0.438,  1.000), vec2( 0.063,  1.000)));\n\tif (bit(n,  8))     v = min(v, dseg(vec2(-0.063,  1.000), vec2(-0.438,  1.000)));\n\tif (bit(n,  16))    v = min(v, dseg(vec2(-0.500,  0.937), vec2(-0.500,  0.062)));\n\tif (bit(n,  32))    v = min(v, dseg(vec2(-0.500, -0.063), vec2(-0.500, -0.938)));\n\tif (bit(n,  64))    v = min(v, dseg(vec2(-0.438, -1.000), vec2(-0.063, -1.000)));\n\tif (bit(n,  128))   v = min(v, dseg(vec2( 0.063, -1.000), vec2( 0.438, -1.000)));\n\tif (bit(n,  256))   v = min(v, dseg(vec2( 0.500, -0.938), vec2( 0.500, -0.063)));\n\tif (bit(n,  512))   v = min(v, dseg(vec2( 0.063,  0.000), vec2( 0.438, -0.000)));\n\tif (bit(n,  1024))  v = min(v, dseg(vec2( 0.063,  0.063), vec2( 0.438,  0.938)));\n\tif (bit(n,  2048))  v = min(v, dseg(vec2( 0.0,  0.063), vec2( 0.000,  0.937)));\n\tif (bit(n,  4096))  v = min(v, dseg(vec2(-0.063,  0.063), vec2(-0.438,  0.938)));\n\tif (bit(n,  8192))  v = min(v, dseg(vec2(-0.438,  0.000), vec2(-0.063, -0.000)));\n\tif (bit(n,  16384)) v = min(v, dseg(vec2(-0.063, -0.063), vec2(-0.438, -0.938)));\n\tif (bit(n,  32768)) v = min(v, dseg(vec2( 0.000, -0.938), vec2( 0.000, -0.063)));\n\tif (bit(n,  65536)) v = min(v, dseg(vec2( 0.063, -0.063), vec2( 0.438, -0.938)));\n\tch_pos.x += ch_space.x;\n    }\n\td = min(d, v);\n}\n#define iterations 13\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.000 \n\n#define brightness3 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord-.5 * iResolution.xy)/iResolution.y;\n      vec2 uv2 = (fragCoord-.5 * iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.0);\n    \n    float t = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(uv.xy) + .007)) * 1.2;\n\tfloat si = sin(t);\n\tfloat co = cos(t);\n\tmat2 ma = mat2(co, si, -si, co);\n   \n    col*= rgbToYuv(vec3(0., 0.5,0.5)*length(uv*.06))*5.01; \n      col+= palette(length(uv) + .4 - iTime*.04)*0.7;\nfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n    vec3 dir=vec3(uv*zoom,1.);\nvec3 from=vec3(1.,.5,0.5);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n        \n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam;\n            p.xy*=mat2(cos(iTime*0.05),sin(iTime*0.05), -sin(iTime*0.05),cos(iTime*0.05));// the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.2-dm; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness3*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\nvec2 pos = uv2;\n\tpos.y += (0.6 + pos.x) * sin(pos.x * 6.0 - time * 4.0) * 0.04;\n\tfloat shade = 0.8 + (0.6 + pos.x) * cos(pos.x * 6.0 - time * 4.0) * 0.2;\n\n\tvec3 color = vec3(0.0);\n\tif(abs(pos.x) < 0.5 && abs(pos.y) < 0.4) {\n\t\tif(pos.y < -0.15) color = vec3(0.8, 0.18, 0.22);\n\t\telse if(pos.y > 0.15) color = vec3(1.0);\n\t\telse color = vec3(0.0, 0.1, 0.57);\n\t\tcolor = mix(color, vec3(0.2, 0.1, 0.), smoothstep(-0.2, 0.3, 0.));\n\t}\n    for(float i = 0.; i < size; i++)\n    {\n        vec2 dir= Hash12(i) -.5; \n   \n   \n   \n        float d = length(uv-dir);\n \n        float brightness = 0.0005;\n        col += vec3(brightness / d);\n        \n    \n    }   \n    \n    \n    vec2 aspect = resolution.xy / resolution.y;\n\tuv3 = ( gl_FragCoord.xy / resolution.y ) - aspect / 2.0;\n\tuv3 *= 20.0 + sin(time);     //  set zoom size\n\tif (REPEAT_SIGN)\n\t  uv3 = -14.0 + mod(1.8*(uv3-1.0),ch_space*vec2(16.,7.5));     //  set zoom size 4\n\n\tch_pos = ch_start + vec2(sin(251.*time)/10.,sin(322.*time)/10.);  // set start position  3\n\n        _ _ S T O P  \n       _  W A R nl1  W I T H _ R U S S I A nl2\n\n\t\t\n\tvec3 color2 = mix(ch_color*v*0.01, bg_color, 1.0- (0.38 / d));  // shading\n    fragColor= vec4(vec3(col)+color2,1.0);\n   fragColor+= vec4(color * shade, 1.0);\n}","name":"Image","description":"","type":"image"}]}