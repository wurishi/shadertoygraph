{"ver":"0.1","info":{"id":"lXlGzX","date":"1708030968","viewed":137,"name":"Contours of Noise","username":"incre_ment","description":"Experiment using looping 4D (Perlin) noise and contour generation.\n4D Perlin Noise by Sprocket:\nhttps://www.shadertoy.com/view/7sd3DS","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["noise","perlin","contours"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Experiment using looping 4D (Perlin) noise.  \n// Uses 4D Perlin Noise by Sprocket\n// https://www.shadertoy.com/view/7sd3DS\n\nfloat PI = 3.14159256;\nfloat TAU = 2.0*3.14159256;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = ( fragCoord - .5* iResolution.xy ) /iResolution.y; \n  vec3 col = vec3(0.); \n  \n  // How many contour layers \n  float layerVal = 3.;\n  \n  // Calculate the noise at the uv coordinate in a circular looping path (through noise space)\n  // which is a function of time.\n  float noiseFactor = 2.;\n  float nRad = .3;\n  float nVal = perlin_noise(vec4(uv.x*noiseFactor, uv.y*noiseFactor, nRad*sin(iTime), nRad*cos(iTime)));\n  \n  // Create an ID for the contour\n  float nID = floor(layerVal*nVal);\n  \n  // Check neighbors to see if same contour (nID) or not to determine if edge   \n  int edge = 0;\n  float distanceCheck = .007;\n  for(int j = -1; j <= 1; j += 2)\n  for(int i = -1; i <= 1; i += 2){ \n    float ii = float(i) * distanceCheck;\n    float jj = float(j) * distanceCheck;\n    float nVal_Neighbor = perlin_noise(vec4((uv.x + ii)*noiseFactor, (uv.y + jj)*noiseFactor, nRad*sin(iTime), nRad*cos(iTime)));\n    float neighborID = floor(layerVal*nVal_Neighbor);\n    if(nID != neighborID){\n      edge = 1;\n    }\n  }\n  \n  // Draw edge\n  col += float(edge);\n  fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// 4D Perlin Noise by Sprocket\n// https://www.shadertoy.com/view/7sd3DS\n\n\n\n// ------- From https://www.shadertoy.com/view/4djSRW -------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n    p4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvec4 random_gradient(vec4 vector)\n{\n    return hash44(vector) * 2.0 - 1.0;\n}\n\nfloat perlin_noise(vec4 point)\n{\n    vec4 gridCell = floor(point);\n    vec4 local = point - gridCell;\n\n    vec4 weight = local * local * (3.0 - 2.0 * local);\n\n    return mix(//W\n        mix(//w0 z\n            mix(//w0 z0 y\n                mix(//w0 z0 y0 x\n                    dot(\n                        local - vec4(0,0,0,0),\n                        random_gradient(gridCell + vec4(0,0,0,0))),\n                    dot(\n                        local - vec4(1,0,0,0),\n                        random_gradient(gridCell + vec4(1,0,0,0))),\n                    weight.x),\n                mix(//w0 z0 y1 x\n                    dot(\n                        local - vec4(0,1,0,0),\n                        random_gradient(gridCell + vec4(0,1,0,0))),\n                    dot(\n                        local - vec4(1,1,0,0),\n                        random_gradient(gridCell + vec4(1,1,0,0))),\n                    weight.x),\n                weight.y),\n            mix(//w0 z1 y\n                mix(//w0 z1 y0 x\n                    dot(\n                        local - vec4(0,0,1,0),\n                        random_gradient(gridCell + vec4(0,0,1,0))),\n                    dot(\n                        local - vec4(1,0,1,0),\n                        random_gradient(gridCell + vec4(1,0,1,0))),\n                    weight.x),\n                mix(//w0 z1 y1 x\n                    dot(\n                        local - vec4(0,1,1,0),\n                        random_gradient(gridCell + vec4(0,1,1,0))),\n                    dot(\n                        local - vec4(1,1,1,0),\n                        random_gradient(gridCell + vec4(1,1,1,0))),\n                    weight.x),\n                weight.y),\n            weight.z),\n        mix(//w1 z\n            mix(//w1 z0 y\n                mix(//w1 z0 y0 x\n                    dot(\n                        local - vec4(0,0,0,1),\n                        random_gradient(gridCell + vec4(0,0,0,1))),\n                    dot(\n                        local - vec4(1,0,0,1),\n                        random_gradient(gridCell + vec4(1,0,0,1))),\n                    weight.x),\n                mix(//w1 z0 y1 x\n                    dot(\n                        local - vec4(0,1,0,1),\n                        random_gradient(gridCell + vec4(0,1,0,1))),\n                    dot(\n                        local - vec4(1,1,0,1),\n                        random_gradient(gridCell + vec4(1,1,0,1))),\n                    weight.x),\n                weight.y),\n            mix(//w1 z1 y\n                mix(//w1 z1 y0 x\n                    dot(\n                        local - vec4(0,0,1,1),\n                        random_gradient(gridCell + vec4(0,0,1,1))),\n                    dot(\n                        local - vec4(1,0,1,1),\n                        random_gradient(gridCell + vec4(1,0,1,1))),\n                    weight.x),\n                mix(//w1 z1 y1 x\n                    dot(\n                        local - vec4(0,1,1,1),\n                        random_gradient(gridCell + vec4(0,1,1,1))),\n                    dot(\n                        local - vec4(1,1,1,1),\n                        random_gradient(gridCell + vec4(1,1,1,1))),\n                    weight.x),\n                weight.y),\n            weight.z),\n        weight.w);\n}\n\n","name":"Common","description":"","type":"common"}]}