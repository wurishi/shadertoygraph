{"ver":"0.1","info":{"id":"MdXfzl","date":"1515610952","viewed":1149,"name":"Simple Audio Visualizer","username":"Qendolin","description":"Not Finished!\nScale with Mouse x position.\nHave a made any mistakes? (Probably)","likes":4,"published":1,"flags":96,"usePreview":0,"tags":["2d","visualization","audio"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n\tThis buffer combines data and background\n\tSelect audio in Buffer B\n*/\n\n#define BARS 80\n#define SMOOTHING 5\n\nfloat getWave(in float x){\n    float freq = x;\n        \n    freq=pow(10.0, freq*2.0-1.0)/10.0; //Logarithmic scale\n    \n    return texture(iChannel1, vec2(freq, 1.0)).x;   \n}\n\nfloat getVolume(in float x)\n{\n    float bar = floor(x * float(BARS));\n    float freq = bar * (1./float(BARS));\n        \n    freq=pow(10.0, freq*2.0-1.0)/10.0; //Logarithmic scale\n    \n    return texture(iChannel1, vec2(freq, 0.0)).x;\n}\n\nfloat smoothVolume(in float x, in float volume)\n{\n    int samples = 1;\n    for(int i = -1 * (SMOOTHING / 2); i <= SMOOTHING / 2; i++)\n    {\n        if(i == 0)\n            continue;\n        float barX = x + (1./float(BARS)) * float(i);\n        if(barX < 0. || barX > 1.)\n        {\n        \tcontinue;\n        }\n    \tvolume += getVolume(barX);\n        samples++;\n    }\n    return clamp(volume / float(samples), 0.0, 1.0);\n}\n\nfloat correctVolume(in float volume, in float x) //K.A......\n{\n    float bar = floor(x * float(BARS));\n    x = bar * (1./float(BARS));\n    float correction = 1.0 + pow(10.0, x*2.0-1.0)/10.0;\n    return volume * correction;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nfragColor.rgb = vec3(0.);\n    vec2 texelSize = vec2(1.) / iResolution.xy;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float volume = getVolume(uv.x);\n    volume = smoothVolume(uv.x, volume);\n    \n    float waveForm = getWave(uv.x);\n    \n    volume = correctVolume(volume, uv.x); //K.A....\n    \n\tfragColor=texture(iChannel0, uv);\n    \n    if(uv.y == 0.15)\n        fragColor = vec4(0.8);\n    else if(uv.y * (1.0/(1.0-0.15)) <= volume + 0.15 && uv.y >= 0.15)\n    {\n        volume /= (1.0/(1.0-0.15)); //Color correction\n        if(volume > 2.0/3.0)\n        \tfragColor = mix(vec4(1.0,1.0,0.0,1.0), vec4(1.0,0.0,0.0,1.0), (volume - (2.0 / 3.0)) / (1.0 / 3.0));\n        else if(volume > 1.0/3.0)\n            fragColor = mix(vec4(0.0,1.0,0.0,1.0), vec4(1.0,1.0,0.0,1.0), (volume - (1.0 / 3.0)) / (1.0 / 3.0));\n        else\n            fragColor = mix(vec4(0.0,0.0,1.0,1.0), vec4(0.0,1.0,0.0,1.0), volume / (1.0 / 3.0));\n        float h = (uv.y-0.15) / (1.-0.15);\n        fragColor*= (pow(h * (1.0 / volume), 2.0) * h) / volume * 1.25;\n    } else if (uv.y <= volume + 0.2 && uv.y > 0.15) {\n        \n        vec4 color = vec4(0.9,0.9,1.0,1.0);\n        color *= 1.0 * (pow(uv.y+0.2, 2.0) - (volume));\n        color -= vec4(0.1, 0.1, 0.1, 0.0);\n        fragColor+=color;\n        \n    } else if(uv.y <= 0.15 && uv.y * (1.0/0.15) >= 1.-volume) {\n        vec4 reflection = vec4(0.0);\n        if(volume > 2.0/3.0)\n        \treflection = mix(vec4(1.0,1.0,0.0,1.0), vec4(1.0,0.0,0.0,0.75), (volume - (2.0 / 3.0)) / (1.0 / 3.0));\n        else if(volume > 1.0/3.0)\n            reflection = mix(vec4(0.0,1.0,0.0,1.0), vec4(1.0,1.0,0.0,0.75), (volume - (1.0 / 3.0)) / (1.0 / 3.0));\n        else\n            reflection = mix(vec4(0.0,0.0,1.0,1.0), vec4(0.0,1.0,0.0,0.75), volume / (1.0 / 3.0));\n        float h = (0.15-uv.y) / 0.15;\n        reflection*= (pow(h * (1.0 / volume), 2.0) * h) / volume * 1.25;\n        fragColor = fragColor *(1.0-reflection.a) + reflection * reflection.a;\n    }\n    \n    fragColor += smoothstep(0.15, texelSize.y*2. + 0.15,uv.y-waveForm/5.) * (1.0-smoothstep(0.15, texelSize.y*2.+0.15, uv.y-waveForm/5.));\n}\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/**\n\tThis buffer provides the background\n*/\n\n#define PI 3.14159265359\n\nvec3 bars(in float x) {\n    vec3 barColor = vec3(pow(max(sin(radians(x*360. * 10.)) + sin(radians(x*360. + sin(iTime*0.7) * 160. + 160.)) ,0.0), 1./5.));\n    barColor.rg -= vec2(0.05);\n    barColor *= barColor * barColor * barColor;\n    barColor /= 5.;\n    return barColor;\n}\n\nfloat laser(in float posX, in float x, in float y, in float width, in float angleOffset, in float angleRange, in float coneAngle, in float startAngle) {\n    return smoothstep(posX-(width/2.), posX+(width/2.), x+ y*(sin(iTime*2.0+radians(startAngle)) - angleOffset + coneAngle)*angleRange)\n        * (1.0-smoothstep(posX-(width/2.), posX+(width/2.), x+ y*(sin(iTime*2.0+radians(startAngle)) - angleOffset)*angleRange )) * 2.;\n}\n\nvec3 lasers(in float x, in float y) {\n\treturn vec3(pow( \n            laser(0.15, x, y, 0.1, 0.0, 0.2, 0.2, 0.0)\n            + laser(0.85, x, y, 0.1, -0.0, 0.2, 0.2, 180.0)\n        , 2.0) / 1.75\n    ) * vec3(hsv2rgb(vec3(mod(iTime*0.2, 360.0), 1.0, 0.4)))\n    + vec3(pow( \n            laser(0.3, x, y, 0.1, -0.0, 0.15, 0.2, 20.0)*0.75\n            + laser(0.70, x, y, 0.1, -0.0, 0.15, 0.2, 200.0)*0.75\n        , 2.0) / 1.75\n    ) * vec3(hsv2rgb(vec3(mod(iTime*0.2+0.12, 360.0), 1.0, 0.3)));\n}\n        \nfloat circle(in vec2 center, in float outerRadius, in float innerRadius, in vec2 point) {\n    float width = outerRadius - innerRadius;\n    return 1.0 - (\n        \tsmoothstep( outerRadius-width, outerRadius+width, length(point-center))\n        \t- smoothstep( innerRadius-width, innerRadius+width, length(point-center))\n        ) - 1.0;\n}\n\nvec2 circlePos(in float speedX, in float speedY) {\n    float x = rand(vec2(speedX/speedY+floor((iTime * speedY)/2.5)));\n    x = x*2.0-1.0;\n    x += rand(vec2(speedX)) < 0.5 ? sin(iTime * speedX) : -sin(iTime * speedX);\n    float y = mod(iTime * speedY, 2.5) - 1.0;\n    return vec2(x,y);\n}\n\nvec3 circles(in vec2 point, int nr) {\n    vec3 circles = vec3(0.0);\n    int j = 0;\n    for(int i = 0; i < nr; i++) {\n        float innerR = (rand(vec2(i+j++)) + 0.05) / 5.0;\n        float outerR = innerR + rand(vec2(i+j++) + 0.05) / 25.0;\n        float speedX = rand(vec2(i+j++));\n        float speedY = (rand(vec2(i+j++)) + 0.2) / 1.2;\n    \tcircles+=circle(circlePos(speedX, speedY), outerR, innerR, point);\n    }\n    return circles * vec3(0.9, 0.9, 1.0);\n}\n\nvec3 backdrop(in float x, in float y) {\n\tfloat color = 0.0;\n    float x1 = (x*2.-1.);\n    color += clamp(x1-y*( 1.0-abs(sin(x1*20.-iTime)*0.5)+0.7 )*1.5, 0.0, 1.0);\n    color += clamp((0.-x1)-y*( 1.0-abs(sin(x1*20.+iTime)*0.5)+0.7 )*1.5, 0.0, 1.0);\n    color += 0.15;\n    return vec3(color) * vec3(0.47,0.66,0.7); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nfragColor.rgb = vec3(0.);\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 point =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n    \n    //fragColor.rgb+=bars(uv.x);\n    fragColor.rgb+=lasers(uv.x, uv.y);\n    fragColor.rgb+=circles(point, 20);\n    fragColor.rgb+=backdrop(uv.x, uv.y);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"MsSSW3","filepath":"https://soundcloud.com/sweety-879874364/nightcore-ievan-polkka-vsns-remix","previewfilepath":"https://soundcloud.com/sweety-879874364/nightcore-ievan-polkka-vsns-remix","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/**\n\tThis buffer provides the data\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nfragColor.rgb = vec3(0.);\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n    if(uv.y <= 0.5) {\n        fragColor.rgb *= clamp((iMouse.x / iResolution.x) * 2.0 - 0.25, 0.33, 1.0);\n    } else {\n        fragColor.rgb -= vec3(0.5);\n        fragColor.rgb *= vec3(2.0);\n        fragColor *= clamp((iMouse.x / iResolution.x) * 2.0 - 0.25, 0.33, 1.0);\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"float rand(vec2 seed){\n    return fract(sin(dot(seed,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}","name":"Common","description":"","type":"common"}]}