{"ver":"0.1","info":{"id":"tdKfWh","date":"1614541416","viewed":126,"name":"Pathtrace experiment","username":"sadf","description":"This is an experiment in pathtracing, mostly going off of\n\nhttps://blog.demofox.org/2020/05/25/casual-shadertoy-path-tracing-1-basic-camera-diffuse-emissive/\n\nBut I'm trying to see whether I can't get MIS to work.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec3 col = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n\n    fragColor = vec4(lin2S(ACESFilm(col)),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float c_pi = 3.141592653589793;\nconst float c_twopi = 6.28318530718;\nconst float c_twopisquared = 19.739208802178716;\nconst float c_far = 1e4;\nconst float c_nudge = 1e-3;\nconst float c_mindist = 1e-3;\n\nconst bool C_DIRECTLIGHTING = false;\n\nconst int c_nbounces = 4;\nconst int c_nsamples = C_DIRECTLIGHTING ? 8 : 16;\nconst int c_directsamples = 1;\n\nfloat norm(vec3 v)\n{\n    return dot(v, v);\n}\n\nvec3 project(vec3 v, vec3 onto)\n{\n    float c = dot(v, onto) / dot(onto, onto);\n    return c * onto;\n}\n\nfloat solveQuadratic(float a, float b, float c)\n{\n    float D2 = b*b - 4.*a*c;\n\n    if (D2 < 0.) {\n        return c_far;\n    }\n\n    float D = sqrt(D2);\n    float r2a = 0.5 / a;\n    float x1 = (-b - D) * r2a;\n    \n    if (x1 > 0.) {\n        return x1;\n    }\n    \n    float x2 = (-b + D) * r2a;\n    \n    if (x2 > 0.) {\n        return x2;\n    }\n    return c_far;\n}\n\nfloat iPlane(vec3 ori, vec3 dir, vec3 pos, vec3 norm)\n{\n    float dist = dot(pos - ori, norm) / dot(dir, norm);\n    return dist > 0. ? dist : c_far;\n}\n\nfloat iSphere(vec3 ori, vec3 dir, vec3 pos, float r2)\n{\n    float a = norm(dir);\n    float b = 2.*(dot(ori, dir) - dot(pos, dir));\n    float c = norm(ori) + norm(pos) - 2.*dot(ori, pos) - r2;\n    \n    return solveQuadratic(a, b, c);\n}\n\nfloat iCyl(vec3 ori, vec3 dir, vec3 pos, vec3 axle, float r2)\n{\n    vec3 o = ori - pos;\n    vec3 d = dir;\n    vec3 Po = project(o, axle);\n    vec3 Pd = project(dir, axle);\n\n    float a = norm(d) - 2.*dot(Pd, d) + norm(Pd);\n    float b = 2.*(dot(d, o) - dot(Pd, o) - dot(d, Po) + dot(Pd, Po));\n    float c = norm(o) - 2.*dot(Po, o) + norm(Po) - r2;\n    \n    return solveQuadratic(a, b, c);\n}\n\nvec3 nSphere(vec3 ori, vec3 dir, float dist, vec3 pos)\n{\n    vec3 isec = ori + dist*dir;\n    return normalize(isec - pos);\n}\n\nvec3 nCyl(vec3 ori, vec3 dir, float dist, vec3 pos, vec3 axle)\n{\n    vec3 isec = ori + dist*dir;\n    vec3 i = isec - pos;\n    vec3 Pi = project(i, axle);\n    return normalize(i - Pi);\n}\n\nconst int c_nshapes = 9;\nconst mat3 shapes[c_nshapes] = mat3[](\n    // floor\n    mat3(0., 0., 1.,\n         vec3(0., -1., 4.),\n         normalize(vec3(0., 1., 0.))),\n    // sphere\n    mat3(1., 0., 1.,\n      \t vec3(0., 0., 2.),\n         0.5, 0., 0.),\n    // cylinder\n    mat3(2., 0.01, 1.,//2., 0.3, 1.,\n         vec3(0., 0., 2.),//vec3(2., -.7, 3.),\n         vec3(1., -1., -2.)),//normalize(vec3(1., 1., 5.))),\n    // lightsource\n    mat3(1, 0., -1.,\n         vec3(.7, 0., 1.),\n         0.05, 0., 0.),\n    // ceiling\n    mat3(0., 0., 1.,\n         vec3(0., 1., 4.),\n         normalize(vec3(0., -1., 0.))),\n    // front wall\n    mat3(0., 0., 1.,\n         vec3(0., 0., 2.5),\n         normalize(vec3(0., 0., -1.))),\n    // back wall\n    mat3(0., 0., 1.,\n         vec3(0., 0., -.1),\n         normalize(vec3(0., 0., 1.))),\n    //left wall\n    mat3(0., 0., 1.,\n         vec3(-1.5, 0., 0.),\n         normalize(vec3(1., 0., 0.))),\n    //right wall\n    mat3(0., 0., 1.,\n         vec3(1.5, 0., 0.),\n         normalize(vec3(-1., 0., 0.)))\n);\n\nvec4 scene(vec3 ori, vec3 dir)\n{\n    float dist = c_far;\n    float tDist;\n    float notEmissive;\n    vec3 norm;\n    \n    for (int i = 0; i< c_nshapes; i++) {\n        mat3 shape = shapes[i];\n        \n        if (shape[0][0] == 0.) {\n            vec3 pos = shape[1];\n            vec3 tNorm = shape[2];\n            tDist = iPlane(ori, dir, pos, tNorm);\n\n            if (tDist > c_mindist && tDist < dist) {\n                dist = tDist;\n                norm = tNorm;\n                notEmissive = shape[0][2];\n            }\n        } else if (shape[0][0] == 1.) {\n            vec3 pos = shape[1];\n            float radius = shape[2][0];\n            tDist = iSphere(ori, dir, pos, radius);\n            \n            if (tDist > c_mindist && tDist < dist) {\n                dist = tDist;\n                norm = nSphere(ori, dir, dist, pos);\n                notEmissive = shape[0][2];\n            }\n        } else if (shape[0][0] == 2.) {\n            float r2 = shape[0][1];\n            vec3 pos = shape[1];\n            vec3 axle = shape[2];\n            tDist = iCyl(ori, dir, pos, axle, r2);\n            \n            if (tDist > c_mindist && tDist < dist) {\n                dist = tDist;\n                norm = nCyl(ori, dir, dist, pos, axle);\n                notEmissive = shape[0][2];\n            }\n        }\n    }\n\n    return vec4(notEmissive*dist, norm);\n}\n\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat RandomFloat01(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n\nvec2 RandomUnitCirc(inout uint state)\n{\n    float r = sqrt(RandomFloat01(state));\n    float theta = c_twopi * RandomFloat01(state);\n    \n    return vec2(r*cos(theta), r*sin(theta));\n}\n\nvec3 RandomUnitVector(inout uint state)\n{\n    /*float z = RandomFloat01(state) * 2.0f - 1.0f;\n    float a = RandomFloat01(state) * c_twopi;\n    float r = sqrt(1.0f - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);*/\n    float theta = c_twopi * RandomFloat01(state);\n    float phi = acos(1. - 2. * RandomFloat01(state));\n    float x = sin(phi) * cos(theta);\n    float y = sin(phi) * sin(theta);\n    float z = cos(phi);\n    return vec3(x, y, z);\n}\n\nfloat testVisible(vec3 ori, vec3 tgt)\n{\n    vec3 dir = normalize(tgt - ori);\n    vec4 hitInfo = scene(ori, dir);\n    float dist = hitInfo.x;\n\n    return dist >= 0. ? 0. : 1.;\n}\n\nvec2 directLight(vec3 pos, vec3 norm, vec3 lightPos, float radius, inout uint rngState)\n{\n    vec3 relLight = lightPos - pos;\n    vec3 lightDir = normalize(relLight);\n    float scaledRadius = radius / length(relLight);\n\n    float hitWeight = 0.5 * radius*radius / dot(relLight, relLight);\n\n    vec3 x = cross(relLight, norm);\n    vec3 y = cross(relLight, x);\n    \n    mat3 m = mat3(x, y, vec3(0.));\n    vec3 s = scaledRadius*vec3(RandomUnitCirc(rngState), 0.);\n    vec3 ss = m*s;\n\n    vec3 testDir = normalize(ss + lightDir);\n    vec3 testTgt = testDir + pos;\n    float e = dot(norm, testDir)*testVisible(pos, testTgt);\n    \n    return vec2(e, hitWeight);\n\n    /*for (float ydist=-radius; ydist <= radius; ydist += s) {\n        for (float xdist=-radius; xdist <= radius; xdist += s) {\n\n            vec3 target = lightPos + ydist*norm + xdist*x;\n            vec3 ray = target - pos;\n            vec3 rayDir = normalize(ray);\n\n            v += dot(norm, rayDir)*testVisible(pos, target);\n        }\n    }*/\n    //v /= float(c_directsamples*c_directsamples);\n\n    //return 1.;//v*area;\n}\n\n\nvec3 scatter[c_nbounces];\nvec3 direct[c_nbounces];\n\n\nvec3 computeCol(vec3 ori, vec3 dir, inout uint rngState)\n{\n    vec3 throughput = vec3(1.);\n    vec3 col = vec3(0.);\n\n    const float luminosity = 5e-1;//5e-1;//5e-4;\n    const vec3 lightPos = shapes[3][1];\n    const float lightRadius = shapes[3][2][0];\n    const float fluxdensity = luminosity/(4.*c_pi*lightRadius*lightRadius);\n    const vec3 lightCol = vec3(fluxdensity);\n\n    const float shininess = .75;\n\n    int i;\n    for (i=0; i<c_nbounces; ++i) {\n    \tvec4 hit = scene(ori, dir);\n    \tfloat dist = hit.x;\n    \tvec3 norm = hit.yzw;\n        \n        scatter[i] = vec3(0.);\n        direct[i] = vec3(0.);\n\n        if (dist >= c_far) {\n            break;\n        } else if (dist > 0.) {\n            ori += dist*dir + c_nudge*norm;\n        \tdir = normalize(RandomUnitVector(rngState) + norm);\n\n            if (C_DIRECTLIGHTING) {\n\t            /*vec2 direct = directLight(ori, norm, lightPos, lightRadius*1.1);\n    \t        float direct_exposure = direct.x;\n        \t    float direct_area = direct.y;*/\n\n\t\t\t\tvec2 direct_exposure = directLight(ori, norm, lightPos, lightRadius, rngState);\n\t            col += throughput*lightCol*direct_exposure.x * direct_exposure.y / (direct_exposure.y + dot(dir, dir));\n                throughput *= shininess*(dot(dir, dir) / (direct_exposure.y + dot(dir, dir))) / c_twopisquared;//.75;\n                \n                //break;\n            } else {\n                throughput *= shininess/c_pi;//.75;\n            }\n        } else {\n            col += throughput*lightCol;\n            break;\n        }\n    }\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n\n    float resMax = max(iResolution.x, iResolution.y);\n\n    const vec3 focal = vec3(0.);\n    const float fDist = .67;\n\n    vec3 oldCol = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    vec3 newCol = vec3(0.);\n\n    for (int i=0; i<c_nsamples; ++i) {\n        vec2 jitter = vec2(RandomFloat01(rngState), RandomFloat01(rngState)) - 0.5f;\n        vec2 uv = (2.*(fragCoord + jitter) - iResolution.xy)/resMax;\n\n    \tvec3 pixelLoc = vec3(uv, fDist) + focal;\n    \tvec3 ray = normalize(pixelLoc);\n\n        newCol += computeCol(focal, ray, rngState);\n    }\n    vec3 col = mix(oldCol, newCol/float(c_nsamples), 1.0f / float(iFrame+1));\n\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"float lin2S(float c)\n{\n    if (c > 0.0031308) {\n\t    return 1.055 * (pow(c, (1.0 / 2.4))) - 0.055;\n\t}\n\treturn 12.92 * c;\n}\n\nvec3 lin2S(vec3 c)\n{\n    vec3 result;\n    for (int i = 0; i<3; i++) {\n        result[i] = lin2S(c[i]);\n    }\n    return result;\n}\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0., 1.);\n}","name":"Common","description":"","type":"common"}]}