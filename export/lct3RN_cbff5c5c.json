{"ver":"0.1","info":{"id":"lct3RN","date":"1711465839","viewed":75,"name":"Simple perlin lines","username":"Gira","description":"randomized lines using billow ridge perlin noise, inspired by Suboptimal Engineer:\nhttps://www.youtube.com/watch?v=7fd331zsie0\n\nUV distortion inspired by indivisual: https://www.shadertoy.com/view/4ddXR8","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["noise","perlinnoise","texture","lines","perlin","random","quantization","seed","posterization","binarization","billow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Perlin Noise generator from Suboptimal Engineer: https://www.youtube.com/watch?v=7fd331zsie0\n\nfloat seed = 714.434;\n\n// limit values can also be interpreted as value thresholds in order to draw color on a fragment\nfloat lineValueLimit = 0.005; // larger values = wider lines\nfloat glowValueLimit = 0.02; // larger values = broader glow\n\nvec3 lineColor = vec3(0.6);\nvec3 glowColor = vec3(0.2);\n\n// creates a wobbly effect by distorting the UV based on iTime\nvec2 distortUv(vec2 uv) {\n    float x = uv.x * 10.0 + iTime;\n    float y = uv.y * 10.0 + iTime;\n    uv.x += sin(x - y) * 0.01 * cos(y);\n    uv.y += cos(x + y) * 0.01* sin(y);\n    return uv;\n}\n\nvec2 randomGradient(vec2 corner) {\n    float x = dot(corner, vec2(123.4, 567.8));\n    float y = dot(corner, vec2(321.321, 654.654));\n    vec2 gradient = vec2(x,y);\n    gradient = sin(gradient);\n    gradient *= seed + iTime*0.1;\n    gradient = sin(gradient);\n    return gradient;\n}\n\n// for noise interpolation. I have no idea how it works, but it works\nvec2 quintic(vec2 p) {\n    return p * p * p * (10.0 + p * (-15.0 + p * 6.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // UV distortion\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv = distortUv(uv);\n    uv += vec2(0.12, 0.12); // constant UV offset to combat weird grid corner patterns\n\n    // grid setup\n    float gridDivision = 3.0;\n    uv *= gridDivision;\n    vec2 gridId = floor(uv);\n    vec2 gridUv = fract(uv);\n\n    // find current grid's corner UVs\n    vec2 tl = gridId;\n    vec2 tr = (gridId + vec2(1.0, 0.0));\n    vec2 bl = (gridId + vec2(0.0, 1.0));\n    vec2 br = (gridId + vec2(1.0, 1.0));\n\n    // generate perlin vectors\n    vec2 gradTl = randomGradient(tl);\n    vec2 gradTr = randomGradient(tr);\n    vec2 gradBl = randomGradient(bl);\n    vec2 gradBr = randomGradient(br);\n\n    // find distance from fragCoord to each corner\n    vec2 fragToTl = gridUv;\n    vec2 fragToTr = gridUv - vec2(1.0, 0.0);\n    vec2 fragToBl = gridUv - vec2(0.0, 1.0);\n    vec2 fragToBr = gridUv - vec2(1.0, 1.0);\n\n    // find dot product of gradient + distance\n    float dotTl = dot(gradTl, fragToTl);\n    float dotTr = dot(gradTr, fragToTr);\n    float dotBl = dot(gradBl, fragToBl);\n    float dotBr = dot(gradBr, fragToBr);\n\n    //smoothstep alternative for noise interpolation\n    gridUv = quintic(gridUv);\n\n    // linear interpolation between the 4 dot products\n    float t = mix(dotTl, dotTr, gridUv.x);\n    float b = mix(dotBl, dotBr, gridUv.x);\n    float perlin = mix(t, b, gridUv.y);\n\n    // apply perlin noise (absolute value for billow ridge noise variant; looks cooler by drawing lines on the edges of noise blobs)\n    float billow = abs(perlin);\n    vec3 color;\n\n    // divide noise into cells\n    if(billow < lineValueLimit) {\n        color = lineColor;\n    }\n    else if(billow < glowValueLimit) {\n        color = glowColor;\n    }\n    else {\n        color = vec3(0.1);\n    }\n\n    // draw color\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}