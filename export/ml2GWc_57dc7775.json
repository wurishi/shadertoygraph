{"ver":"0.1","info":{"id":"ml2GWc","date":"1674148555","viewed":321,"name":"a starship in the sand storm","username":"Poisson","description":"A simple but physically based fog rendering, with god rays and volumetric lighting. Move the mouse to rotate the camera.","likes":33,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","fractal","noise","ray","volume","cloud","light","volumetric","fog","raymarcher","godrays","scattering","ao","occlusion","scatter","haze","sand"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// A simple but physically based fog rendering, \n// with god rays and volumetric lighting.\n// Move the mouse to rotate the camera.\n// It's reminds me dune\n\n// quality settings\n#define AA 1 // antialiasing, set it to 2 if you have a fast computer\n#define NUM_STEPS 32 // marching steps, higher -> better quality\n#define DITHERING // dithering on the distance\n\n// lighing settings\n#define LIGHT_POS vec3(1.5)*rot(vec3(.5*iTime)) // position of the light\n#define LIGHT_COLOR (3.*vec3(1,.65,.35)) // color of the light\n#define VOLUME_ABSORBTION 1. // light absorbtion trough volume\n#define VOLUME_DENSITY .6 // density of the volume\n#define VOLUMETRIC_LIGHTING // enable god rays\n#define SHADOWS_QUALITY 1.5 // quality of the shadows, higher -> lower quality but faster\n\n#define PI 3.141592\n\n// ACES tonemapping\nvec3 ACES(vec3 x) { \n    float a = 2.51;\n    float b =  .03;\n    float c = 2.43;\n    float d =  .59;\n    float e =  .14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\n// 2d rotation function\nmat2 rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// 3d rotation function\nmat3 rot(vec3 a){\n    float c = cos(a.x), s = sin(a.x);\n    mat3 rx = mat3(1,0,0,0,c,-s,0,s,c);\n    c = cos(a.y), s = sin(a.y);\n    mat3 ry = mat3(c,0,-s,0,1,0,s,0,c);\n    c = cos(a.z), s = sin(a.z);\n    mat3 rz = mat3(c,-s,0,s,c,0,0,0,1);\n    \n    return rz * rx * ry;\n}\n\n// float random number\nfloat hash(float n) {return fract(sin(n)*43758.5453123);}\n\n// noise function by iq\nfloat noise(vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.-2.*f);\n\n    float n = p.x + p.y*157. + 113.*p.z;\n\n    return mix(mix(mix(hash(n+  0.), hash(n+  1.),f.x),\n                   mix(hash(n+157.), hash(n+158.),f.x),f.y),\n               mix(mix(hash(n+113.), hash(n+114.),f.x),\n                   mix(hash(n+270.), hash(n+271.),f.x),f.y),f.z);\n}\n\n// fractal noise\nfloat fbm(vec3 p) {\n    float f = 0.;\n    f += .5*noise(p);\n    f += .25*noise(2.*p);\n    f += .125*noise(4.*p);\n    f += .0625*noise(8.*p);\n    return f;\n}\n\n// scene sdf (fractal)\n// inspired by the mandelbox of loicvdb\n// https://www.shadertoy.com/view/3t3GWH\nfloat map(vec3 p) {\n    mat3 r = rot(vec3(1.57)); // rotation\n   \n    p *= 6.;\n    vec3 q = p;\n    float m = 1.;\n    \n\tfor (int i=0; i<3; i++) {\n    \tp = clamp(p,-1.,1.) * 2. - p;\n        float h = clamp(.25/dot(p, p), .25, 1.);\n    \tp *= h;\n        m *= h;\n        if(i<2) p *= r;\n    \tp = p*9. + q;\n        m = m*9.+1.;\n\t}\n    q = abs(p);\n\treturn (max(q.x,max(q.y,q.z))-3.) / (m*6.);\n}\n\n// raymarching function\nfloat intersect(vec3 ro, vec3 rd) {\n    float t = 0.; // distance travelled\n    for (int i=0; i<128 && t<8.; i++) {\n        vec3 p = ro + rd*t; // current point\n        \n        float h = map(p); // distance to the scene\n        if (h<.001) break; // we hit the surface\n        \n        t += h; // march\n    }\n    // return distance\n    return t;\n}\n\n// normal estimation\nvec3 calcNormal(vec3 p) {\n    float h = map(p);\n    const vec2 e = vec2(.0001,0); // epsilon\n    \n    return normalize(h - vec3(map(p-e.xyy),\n                              map(p-e.yxy),\n                              map(p-e.yyx)));\n}\n\n// shadow function\nfloat shadow(vec3 ro, vec3 rd, float tmax) {\n    for (float t=0.; t<tmax;) {\n        vec3 p = ro + rd*t;\n        float h = map(p)*SHADOWS_QUALITY;\n        if (h<.001) return 0.;\n        t += h;\n    }\n    return 1.;\n}\n\n// light function\n// return the direction and the length of the light vector\nvec4 getLight(vec3 ce, vec3 p) {\n    vec3 lig = ce - p; // light vector\n    float l = length(lig); // length of the light vector\n    lig = normalize(lig); // normalize it\n    return vec4(lig,l);\n}\n\n// volume rendering\n// depth is the depth buffer (distance to the fractal)\nvec4 renderVolume(vec3 ro, vec3 rd, float depth) {\n    float tmax = min(8.,depth); // max distance\n    \n    vec4 sum = vec4(0,0,0,1); // color and opacity\n    \n    float s = tmax / float(NUM_STEPS); // step size\n    float t = 0.; // distance travelled\n    #ifdef DITHERING\n    // dithering\n    t += s*hash(gl_FragCoord.x*8315.9213/iResolution.x+gl_FragCoord.y*2942.5192/iResolution.y);\n    #endif\n    \n    for (int i=0; i<NUM_STEPS; i++) { // raymarching loop\n        vec3 p = ro + rd*t; // current point\n        float h = VOLUME_DENSITY*fbm(4.*p); // density of the fog\n        \n        // ligthing\n        vec4 lig = getLight(LIGHT_POS, p); // light direction + length of the light vector\n        \n        #ifdef VOLUMETRIC_LIGHTING\n        float sha = shadow(p,lig.xyz,lig.w); // shadow of the fractal (god rays)\n        #else\n        float sha = 1.; // no shadow\n        #endif\n                  \n        // coloring\n        vec3 col = LIGHT_COLOR*sha / (lig.w*lig.w); // inverse square law\n            \n        sum.rgb += h*s*sum.a*col; // add the color to the final result\n        sum.a *= exp(-h*s*VOLUME_ABSORBTION); // beer's law\n        \n        if (sum.a<.01) break; // optimization\n        t += s; // march\n    }\n    \n    // output\n    return sum;\n}\n\n// ambient occlusion function by me\nfloat calcAO(vec3 p, vec3 n) { // point and normal\n    float res = 1.; // result\n    for (int i=0; i<5; i++) { // sampling 5 times\n        float h = .1*float(i)/5.;\n        res *= clamp(.5+.5*map(p + n*h)/h,0.,1.);\n    }    \n    return res;\n}\n\n// rendering\nvec3 render(vec3 ro, vec3 rd) {\n    vec3 col = vec3(0); // background\n    \n    float t = intersect(ro, rd); // distance\n    if (t<8.) { // we hit the surface\n        vec3 p = ro + rd*t; // hit point\n        vec3 n = calcNormal(p); // normal of the surface\n                \n        vec4 lig = getLight(LIGHT_POS, p); // light direction + length of the light vector\n                \n        float dif = clamp(dot(n, lig.xyz),0.,1.); // diffuse light\n        float sha = shadow(p+n*.002, lig.xyz, lig.w*.5); // shadow\n        float bac = clamp(dot(n, -lig.xyz),0.,1.); // back/bounce light\n        float occ = calcAO(p, n); // ambient occlusion\n        \n        // light surface interaction\n        float lin = 0.;\n        lin += dif*sha; // direct light\n        lin += .1*occ*(1.+bac); // ambient light\n        lin /= lig.w*lig.w; // inverse square law\n        \n        col = LIGHT_COLOR*lin;\n    }\n    \n    // fog\n    vec4 res = renderVolume(ro, rd, t);\n    col = col*res.a + res.rgb; // mix the color with the fog color\n    \n    // output\n    return col;\n}\n\n// camera function\nmat3 setCamera(vec3 ro, vec3 ta) {\n    vec3 w = normalize(ta - ro);\n    vec3 u = normalize(cross(w, vec3(0,1,0)));\n    vec3 v = cross(u, w);\n    return mat3(u, v, w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0);\n    \n    // antialiasing loops\n    for (int m=0; m<AA; m++)\n    for (int n=0; n<AA; n++) {\n        vec2 off = vec2(m,n)/float(AA) - .5; // AA offset\n        // pixel coordinates centered at the origin\n        vec2 p = (fragCoord+off - .5*iResolution.xy) / iResolution.y;\n        // normalized mouse coordinates\n        vec2 m = (iMouse.xy - .5*iResolution.xy) / iResolution.y;\n\n        vec3 ro = vec3(0,m.y*3.,3); // ray origin\n        ro.xz *= rot(m.x*PI+.3*iTime); // camera rotation\n        vec3 ta = vec3(0); // target\n        mat3 ca = setCamera(ro, ta); // camera matrix\n\n        vec3 rd = ca * normalize(vec3(p,1.5)); // ray direction\n\n        // render\n        vec3 col = render(ro, rd);\n        tot += col;\n    }\n    tot /= float(AA*AA);\n    \n    // post processing\n    tot = ACES(tot); // tonemapping\n    tot = pow(tot, vec3(.4545)); // gamma correction\n    tot = tot*.2+.8*tot*tot*(3.-2.*tot); // contrast\n    \n    // vignette\n    vec2 q = fragCoord/iResolution.xy;\n    tot *= .5+.5*pow(16. * q.x*q.y*(1.-q.x)*(1.-q.y), .1);\n    \n    fragColor = vec4(tot,1.0);\n}","name":"Image","description":"","type":"image"}]}