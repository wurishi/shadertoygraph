{"ver":"0.1","info":{"id":"3lVfRy","date":"1614598441","viewed":312,"name":"Naive Shaded Helix","username":"sylvain69780","description":"I can't stop watching at it. :)\nA coil inside a coil, you can play with the parameters.\nStill some artifacts sorry for this","likes":26,"published":1,"flags":0,"usePreview":0,"tags":["helix","coil"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Naive Shaded Helix\n    ------------------\n    \n    A try to get a decent SDF and domain repetition for an helix.\n    And very cool paradoxical speed effect (Thanks Fabrice)\n    \n    Related references\n    \n    RayMarching starting point - BigWIngs\n    https://shadertoy.com/view/WtGXDD\n\n    Quick Lighting Tech - blackle \n    https://www.shadertoy.com/view/ttGfz1\n    \n    soft shadows in raymarched SDFs - IQ\n    https://iquilezles.org/articles/rmshadows\n\n*/\n\n// Play with this !\n#define CYLINDER_RAD      2.3+sin(T)\n#define CYLINDER_SPACING  0.1\n#define CORE_SIZE         vec2(.1,.3)\n#define CYLINDER2_RAD     .4\n#define CYLINDER2_SPACING 0.0\n#define CORE2_SIZE        vec2(.1,.25)\n#define SPEED             3.14\n\n\n// Classical \n#define MAX_STEPS 200\n#define MAX_DIST 10.\n#define SURF_DIST .001\n#define S smoothstep\n#define T iTime*.3\n#define TAU 6.283185\n \n// a flat band of 1 unit wide, wound around an infinite cylinder of radius r\n// with UV parameters\nvec3 wrappedCylinder(vec3 p, float r) \n{\n    p.y-=-.5; // center the starting point at y=zero\n    float tpr = atan(p.z, p.x);\n    float tp = tpr/TAU;\n    float turn = p.y-tp;      // counting the turns\n    float count=floor(turn);\n    float delta=fract(turn);\n    float ts=tp+count;\n    float u=ts*r*TAU;\n    float v=delta-.5; // from -.5 to .5\n    // fix orientation regarding the slope\n     float slope = 1.0/(TAU*r);\n     u+=v*slope/sqrt(1.0+slope*slope); // sin(atan(x)) = x/sqrt(x2+1)\n     // distance calculation\n    float d = length(p.xz) - r;\n    return vec3(d,u,v);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvec4 ribbon(vec3 p, float r, float spacing, vec2 thickness, float rounding)\n{\n    float scale=spacing+1.0;\n    vec3 duv = scale*wrappedCylinder(p/scale,r/scale); // I wonder how well distances are preserved\n    float w=duv.x;\n    vec2 uv=duv.yz;\n    vec2 q=duv.xz;\n    float d=sdBox(q,thickness*.5)-rounding;\n    return vec4(d,uv,w);\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat GetDist(vec3 p) {  \t\n    vec4 duvw =  ribbon(p,CYLINDER_RAD,CYLINDER_SPACING,CORE_SIZE,.03);\n    vec3 p2=duvw.zyw;\n    p2.y+=T*SPEED;\n    vec4 duvw2 = ribbon(p2,CYLINDER2_RAD,CYLINDER2_SPACING,CORE2_SIZE,.05);\n    float d=min(duvw.x,duvw2.x);\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p), // forward vector\n        r = normalize(cross(f,vec3(0,1,0) )),   // right vector\n        u = cross(r,f),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n// Inigo\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.33*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = GetDist( opos );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = vec2(0);\n    \n    vec3 ro = vec3(0, 1, 5);\n    vec3 ta = vec3(0,0,0);\n    if ( iMouse.x > 0.0 ) {\n        m=2.0*iMouse.xy/iResolution.xy-1.0;\n        ro.yz *= Rot(-m.y*3.14);\n        ro.xz *= Rot(-m.x*6.2831);\n    }\n    vec3 rd = GetRayDir(uv, ro, ta, 1.);\n    float d = RayMarch(ro, rd);\n    \n    vec3 col,bg = vec3(.1)/(1.0+3.0*abs(rd.y)); \n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \tvec3 n = GetNormal(p);\n        float occ = calcOcclusion(p,n);\n        // Blackle https://www.shadertoy.com/view/ttGfz1\n        float dif= pow(length(sin(n*3.)*.5+.5)/sqrt(3.), 4.);\n    \tfloat lin = dif*occ;\n        col = vec3(1.2) * lin;\n        // fog\n        float fogAmount = 1.0 - exp( -max(0.0,d-3.0)*.3 );\n        col = mix(col, bg,fogAmount);\n    } else {\n        col = bg;\n    }\n    col = sqrt(col);\t// gamma correction\n    fragColor = vec4(col,1.0);\n}\n// disabled because it impacts the performances more than expected\n// Please enable by renaming mainImage to mainImage0 and mainImagne0 to mainImage\n// to test the improvement \n// === easy adaptive sampling. === https://shadertoyunofficial.wordpress.com/2021/03/09/advanced-tricks/\n//                           more: https://www.shadertoy.com/results?query=easy+adaptive+sampling\nvoid mainImage0(out vec4 O, vec2 U) {\n    mainImage(O,U);\n    if ( fwidth(length(O)) > .04 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { mainImage(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n      // O.r++;                        // uncomment to see where the oversampling occurs\n    }\n}\n","name":"Image","description":"","type":"image"}]}