{"ver":"0.1","info":{"id":"fdtyzM","date":"1653191114","viewed":126,"name":"Haru86_Ray_220522-03","username":"Haru86_","description":"Haru86_Ray_220522","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision mediump float;\n#define time iTime\n#define resolution iResolution\n\nuniform float _cameraPositionIndex;\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define PI 3.14159265\n\nstruct DBuffer{\n  float d1;\n  float d2;\n  float d3;\n  float mainD;\n};\n\nstruct AccBuffer{\n  float acc1;\n  float acc2;\n  float acc3;\n};\n\nfloat rand(vec2 seeds){\n  return fract(sin(dot(seeds, vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 random2(vec2 seeds)\n{\n seeds = vec2(dot(seeds, vec2(127.1, 311.7)),\n dot(seeds, vec2(269.5, 183.3)));\n return fract(sin(seeds) * 43758.5453123);\n}\n\nfloat perlinNoise(vec2 seeds)\n{\nvec2 i = floor(seeds);\nvec2 f = fract(seeds);\nvec2 i00 = i + vec2(0, 0);\nvec2 i10 = i + vec2(1, 0);\nvec2 i01 = i + vec2(0, 1);\nvec2 i11 = i + vec2(1, 1);\nvec2 f00 = f - vec2(0, 0);\nvec2 f10 = f - vec2(1, 0);\nvec2 f01 = f - vec2(0, 1);\nvec2 f11 = f - vec2(1, 1);\nvec2 g00 = normalize(-1.0 + 2.0 * random2(i00));\nvec2 g10 = normalize(-1.0 + 2.0 * random2(i10));\nvec2 g01 = normalize(-1.0 + 2.0* random2(i01));\nvec2 g11 = normalize(-1.0 + 2.0* random2(i11));\nfloat v00 = dot(g00, f00);\nfloat v10 = dot(g10, f10);\nfloat v01 = dot(g01, f01);\nfloat v11 = dot(g11, f11);\nvec2 p = smoothstep(0.0, 1.0, f);\nfloat v00v10 = mix(v00, v10, p.x);\nfloat v01v11 = mix(v01, v11, p.x);\nreturn mix(v00v10, v01v11, p.y) * 0.5 + 0.5;\n}\n\nvec2 fmod(vec2 p,float r){\n  float a=atan(p.x,p.y)+PI/r;\n  float n=(2.*PI)/r;\n  a=floor(a/n)*n;\n  return rot(a)*p;\n}\n\n\nfloat Plane(vec3 p){\n  return p.y;\n}\n\nfloat Cube(vec3 p,vec3 s){\n  return length(max(abs(p)-s,0.));\n}\n\nfloat CubeTerrain(vec3 p,vec3 offset,float k,vec3 scale,float A,float startVal){\n   vec3 pos=p;\n   pos+=offset;\n   float xid=floor(pos.x/k);\n   float yid=floor(pos.y/k);\n   float zid=floor(pos.z/k);\n\n   pos.xz=mod(pos.xz,k)-0.5*k;\n  float d=Cube(pos,scale+vec3(0.,min(rand(vec2((xid+zid)*A))*startVal+startVal,k)*exp(abs(xid)*0.5)*0.5,0.));\n  return d;\n}\n\nfloat d1(vec3 p){\n  p.z-=time*2.;\n  float d0=CubeTerrain(p,vec3(0.,0.,0.),.8,vec3(0.25,0.25,0.25),10.0,0.25);\n  float d1=CubeTerrain(p,vec3(1.,0.,1.),.8,vec3(0.25,0.25,0.25),20.0,0.2);\n  d0=min(d0,d1);\n  float d2=CubeTerrain(p,vec3(-1.,-.0,-1.),.8,vec3(0.2,0.2,0.2),40.0,0.2);\n  d0=min(d0,d2);\n  float d3=CubeTerrain(p,vec3(-.5,-.0,-.5),1.2,vec3(0.2,0.2,0.2),20.0,0.5);\n  d0=min(d0,d3);\n\n  /*float k=.75;\n  p=mod(p,k)-k*.5;\n  float d0=Cube(p,vec3(.25,.25,.25));*/\n\n      return d0;\n}\n\nfloat d1_edge(vec3 p){\n  float d=d1(p);\n  d=max(d,d1(p*1.1));\n  return d;\n}\n\nfloat particle(vec3 p,float k,vec3 offset){\n  vec3 pos0=p;\n  pos0+=offset;\n  vec3 id=floor(pos0/k);\n  pos0.y+=sin(pos0.z*2.+time*sign(sin(time+pos0.z)))*0.5;\n  pos0.xy*=rot(pos0.z);\n  pos0=mod(pos0,k)-k*0.5;\n  float d=Cube(pos0,vec3(0.005,0.005,2.));\n\n  return d;\n}\n\nfloat d2(vec3 p){\n  p.z-=time;\n  float d=particle(p,1.5,vec3(0.));\n  float d1=particle(p,1.,vec3(-1.));\n  d=min(d,d1);\n  float d2=particle(p,1.,vec3(1.,-1.,1.));\n  d=min(d,d2);\n\n  return d;\n}\n\nfloat d3(vec3 p){\n//p*=7.;\n\n  float d=length(p)-.2;\n//p.xyz*=7.;\n//p.x+=1.5;\n\n  p.xy*=rot(time);\n  p.xz*=rot(time);\n  p.yz*=rot(time);\n  for(int i=0;i<3;i++){\n    p=abs(p)-.075;\n    if(p.x<p.y)p.xy=p.yx;\n    if(p.x<p.z)p.xz=p.zx;\n    if(p.y<p.z)p.yz=p.zy;\n\n    p.xy*=rot(1.2);\n    p.xz*=rot(.25);\n    p.yz*=rot(.25);\n\n}\n\nd=min(d,Cube(p,vec3(.2,.2,.2)*.2));\n\n  return d;\n}\n\nDBuffer map(vec3 p){\n  DBuffer d;\n  d.d1=d1_edge(p);\n  //d.d2=d1(p*1.1);\n  //d.d1=2000.0;\n  d.d2=d2(p);\n  //d.d2=2000.0;\n  d.d3=d3(p+vec3(0.,-1.5,0.));\n  //d.d3=2000.0;\n  d.mainD=min(min(d.d1,d.d2),d.d3);\n  return d;\n}\n\nvec3 gn(vec3 p){\n  vec2 e=vec2(0.001,0.);\n  return normalize(\n    vec3(\n      map(p+e.xyy).mainD-map(p-e.xyy).mainD,\n      map(p+e.yxy).mainD-map(p-e.yxy).mainD,\n      map(p+e.yyx).mainD-map(p-e.yyx).mainD\n      )\n    );\n}\n\nvec3 hsv2rgb2(vec3 c, float k) {\n    return smoothstep(0. + k, 1. - k,\n        .5 + .5 * cos((vec3(c.x, c.x, c.x) + vec3(3., 2., 1.) / 3.) * radians(360.)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 st = (fragCoord.xy*2.0-resolution.xy) / min(resolution.x,resolution.y);\n  //vec2 st=uv*2.0-1.0;\n  //st.x*=(resolution.x/resolution.y);\n\n  vec3 col=vec3((st.y+1.0)*0.5*0.25);\n  float radius=15.;\nfloat speed=-.25;\n vec3 ta=vec3(0.,1.,0.);\n //vec3 ro=vec3(0.,2.,2.);\nvec3 ro=vec3(cos(time),1.,sin(time));\n\nif(_cameraPositionIndex==0.0){\n    ta=vec3(0.,1.,0.);\n    ro=vec3(0.,2.,2.);\n}else if(_cameraPositionIndex==1.0){\n    ta=vec3(0.,1.,0.);\n    ro=vec3(cos(time),1.,sin(time));\n}else if(_cameraPositionIndex==2.0){\n    //float radius=1.0*(perlinNoise(vec2(0.123,-time*5.0))+1.0)*.8;\n    ta=vec3(0.,1.,0.);\n    //ro=vec3(cos(-time)*radius,sin(-time)*radius*0.1+1.0,sin(time)*radius);\n    ro=vec3(-1.,1.5,-2.0);\n}\n\n\n float adjustAcc=0.5;\n\n vec3 cDir=normalize(ta-ro);\n vec3 cSide=cross(cDir,vec3(0.,-1.,0.));\n vec3 cUp=cross(cDir,cSide);\n float depth=1.;\n vec3 rd=normalize(vec3(st.x*cSide+st.y*cUp+cDir*depth));\n\n  DBuffer d;\n  AccBuffer acc;\n  float t=0.0,pi=0.0;\n  for(int i=0;i<100;i++){\n    d=map(ro+rd*t);\n    //d.d3=min(d.d3*0.,.1);\n    pi=float(i);\n    if(abs(d.d1)<0.001||d.d2<0.001||d.d3<0.001||t>1000.0)break;\n\n    //if(d.mainD<2.){\n    //  t+=d.mainD*.25;\n    //}else{\n      t+=d.mainD*.5;\n    //}\n\n    acc.acc1+=exp(-50.0*(d.d1));\n    acc.acc2+=exp(-50.0*d.d2);\n    acc.acc3+=exp(-50.0*d.d3);\n  }\n\n    if(d.d1<0.001){\n      vec3 refro=ro+rd*t;\n      vec3 n=gn(refro);\n      rd=reflect(rd,n);\n      ro=refro;\n      t=0.1;\n      float acc2;\n\n      for(int i=0;i<11;i++){\n        d=map(ro+rd*t);\n        if(d.mainD<0.001)break;\n        t+=d.mainD;\n        float H = mod(time*0.5, 1.0);\n        acc2+=exp(-3.*d.mainD);\n      }\n\n      vec3 pos=ro+rd*t;\n      float flash=1.0-abs(sin(pos.z*.5+time*4.0));\n      flash+=.1;\n      float H = mod(time*0.5, 1.0);\n      col+=flash*adjustAcc*vec3(0.,0.25,1.0)*20./pi;\n    }\n\n    if(d.d2<0.001){\n      col+=vec3(exp(-.01*t))*vec3(0.,0.25,1.0)*acc.acc2*0.05;\n    }\n\n    if(d.d3<0.001){\n      col+=vec3(exp(-1.*t))*acc.acc3*0.05*vec3(0.,0.25,1.0);\n    }\n\n\n  fragColor = vec4(col, 1.0);\n}\n\n\n/*void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}*/","name":"Image","description":"","type":"image"}]}