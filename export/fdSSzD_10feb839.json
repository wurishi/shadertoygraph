{"ver":"0.1","info":{"id":"fdSSzD","date":"1619714221","viewed":97,"name":"iraiter2-Metaball","username":"iraiter2","description":"WIP","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf"],"hasliked":0,"parentid":"XdBBzR","parentname":"Ray-marching metaballs"},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision mediump float;\n\nconst int MAX_MARCHING_STEPS = 64;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.001;\n\n/**\n * Rotation matrix around the Y axis.\n */\nmat3 rotateY(float theta) {\n  float c = cos(theta);\n  float s = sin(theta);\n  return mat3(\n    vec3(c, 0, s),\n    vec3(0, 1, 0),\n    vec3(-s, 0, c)\n  );\n}\n\n/**\n * Signed distance function for a sphere centered at the origin with radius r.\n */\nfloat sphereSDF(vec3 p, float r) {\n  return length(p) - r;\n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n/**\n * Signed distance function describing the scene.\n */\nfloat sceneSDF(vec3 samplePoint) {\n  float ballRadius = 0.2;\n  float balls = MAX_DIST;\n  int n = 10;\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < n; ++j) {\n      float x_c = (float(i) + 0.5) / float(n) - 0.5;\n      float z_c = (float(j) + 0.5) / float(n) - 0.5;\n      x_c *= 6.0;\n      z_c *= 6.0;\n      float r = x_c * x_c + z_c * z_c;\n      balls = smin(balls, sphereSDF(samplePoint - vec3(x_c, 0.6*sin(-iTime + r) / max(r, 0.5), z_c), ballRadius), 0.7);\n    }\n  }\n\n  return balls;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n *\n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n  float depth = start;\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    float dist = sceneSDF(eye + depth * marchingDirection);\n    if (dist < EPSILON) {\n      return depth;\n    }\n    depth += dist;\n    if (depth >= end) {\n      return end;\n    }\n  }\n  return end;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n  vec2 xy = fragCoord - size / 2.0;\n  float z = size.y / tan(radians(fieldOfView) / 2.0);\n  return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n  return normalize(vec3(\n    sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n    sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n    sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n  ));\n}\n\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n  // Based on gluLookAt man page\n  vec3 f = normalize(center - eye);\n  vec3 s = normalize(cross(f, up));\n  vec3 u = cross(s, f);\n  return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec3 viewDir = rayDirection(90.0, iResolution.xy, gl_FragCoord.xy);\n  vec3 eye = rotateY(iTime / 12.0) * vec3(0.0, 3.0, 6.0);\n  mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n  vec3 worldDir = viewToWorld * viewDir;\n  float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n\n  if (dist > MAX_DIST - EPSILON) {\n    fragColor = texture(iChannel0, worldDir, 0.0);\n    return;\n  }\n\n  vec3 p = eye + dist * worldDir;\n  vec3 normal = estimateNormal(p);\n  vec4 tex = mix(texture(iChannel0, refract(worldDir,normal,1.0/1.3), 0.0), texture(iChannel0, reflect(worldDir, normal), 0.0), 0.4);\n\nfragColor = mix(tex, vec4(0.1, 0.6, 0.8, 1.0), 0.2);\n}","name":"Image","description":"","type":"image"}]}