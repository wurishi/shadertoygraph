{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"//Music toolbox\n//by nimitz (stormoid.com) (twitter: @stormoid)\n\n/*\n\tTaking a different approach than sequencing all the notes one by one.\n\tInstead using a basic \"sequencer\" to create and combine/chain patterns\n\tthis allows for a more tracker-like experience.\n\n\tThe \"sequencer\" itself could be improved, a proper ADSR\n\tenvelope comes to mind.\n\n\tPlease let me know if you find stuff that can be fixed/improved.\n\t\n\tAlso included are defines for the chromatic scale, a few simple\n\twaveforms/instruments with note and octave input, a few synths,\n\tsome simple drums using the sequencer envelopes, \n\ta 3 input arpeggiator and a very basic mix/pan function.\n*/\n\n//THE CODE HERE IS THE VISUALS ONLY, CLICK ON THE SOUND TAB TO SEE THE SOUND CODE\n\nfloat noise( float x ){return fract(sin(1371.1*x)*43758.5453);}\nfloat noise( in vec2 x ){return texture(iChannel0, x*.01).x;}\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\n\n#define PI 3.14159265358979323846\n#define TAU PI*2.\n\n#define C  32.703\n#define CS 34.648\n#define D  36.708\n#define DS 38.891\n#define E  41.203\n#define F  43.654\n#define FS 46.249\n#define G  48.999\n#define GS 51.913\n#define A  55.0\n#define AS 58.270\n#define B  61.735\n\n//-------------------------------------------------------------------\n//----------------------Modulating/Sequencing------------------------\n//-------------------------------------------------------------------\n\n//3 input arpeggiator, with smoothing\nfloat arp(float a, float b, float c, float t, float smoothv)\n{\t\n\tfloat ra = mix(0., a, smoothstep(0.333-smoothv, .333+smoothv, sin(t*TAU)));\n\tfloat rb = mix(0., b, smoothstep(0.333-smoothv, .333+smoothv, sin(t*TAU-.333*TAU)));\n\tfloat rc = mix(0., c, smoothstep(0.333-smoothv, .333+smoothv, sin(t*TAU-.666*TAU)));\n\treturn ra+rb+rc;\n}\n\n//BPM define is only used by the sequencer\n#define BPM 112.\n\n/* Input:\n\tgate = how long the note is on [-1...1]\n\tsmooth = symmetric attack/release smoothing (a real ADSR would be better)\n\toffset = time offset, [-1...1] 1 is one period\n*/\nfloat seq(float t, float gate, float smoothv, float ofst)\n{\n\treturn smoothstep( gate-smoothv, gate+smoothv,\n                      cos( (t*PI*BPM/120.) - ofst*TAU - PI*0.5 + gate ) );\n}\n\n//same idea but with an AR envelope\nfloat seqAR(float t, float gate, float atk, float rel, float ofst)\n{\n    float p = ((t*PI*BPM/120.)-ofst*TAU-PI*0.5+gate );\n    float tp = fract(p/PI*.5);\n    \n    //The envelopes have to be scaled based on the gate length\n    gate = clamp(gate,-1.,1.);\n    float scl = (1.-abs(gate));\n    atk *= scl;\n    rel *= scl;\n    \n    //Attack envelope\n\tif (tp > 0.5)\n\t\treturn smoothstep( gate-atk, gate+atk, cos(p));\n    //Release envelope\n\telse\n\t\treturn smoothstep( gate-rel, gate+rel, cos(p));\n}\n\n//-------------------------------------------------------------------\n//---------------------------Instruments-----------------------------\n//-------------------------------------------------------------------\n\n//Basic waveforms with note and octave input\nfloat sn(float t, float note, float octave)\n{\n\treturn sin(t*note*exp2(octave)*PI);\n}\n\nfloat saw(float t, float note, float octave)\n{\n\treturn fract(t*note*exp2(octave-1.))-0.5;\n}\n\nfloat tri(float t, float note, float octave)\n{\n\treturn (abs(fract(t*note*exp2(octave-1.))-0.5)*2.-0.5)*2.;\n}\n\nfloat sqr(float t, float note, float octave)\n{\n\treturn step(fract(t*note*exp2(octave-1.)), 0.5)-0.5;\n}\n\n//simple frequency modulation (3->1)\nfloat fmsq(float t, float note, float octave)\n{\n\tfloat fm = sn(t,note,octave-1.)*0.0008;\n\tfloat fm2 = sn(t,note,octave+1.)*0.0007;\n\tfloat fm3 = sn(t,note,octave+2.)*0.00055;\n\treturn sqr(t+fm+fm2+fm3,note,octave);\n}\n\n//very fake filtered saw (not used)\nfloat filterSaw(float t, float note, float octave, float cutoff, float q)\n{\n    float saw = fract(t*note*exp2(octave-1.))-0.5;\n    float sn = cos((t*note*exp2(octave)*PI)+PI*0.5);\n    float filt = smoothstep(cutoff-q,cutoff+q,abs(saw)*2.);\n    return mix(saw,sn,filt);\n}\n\n//a slightly more complex intrument using the sequencer for harmonic envelopes\n//freq is how often the note is triggered\nfloat additive(float t, float note, float octave, float freq)\n{\n    float x = t*freq;\n    float rz = 0.;\n    float atk = 0.01;\n    float rel = 1.;\n    float h = 1.;\n    float pw = 1.;\n    float dcy = .0;\n    \n    for(int i=0;i<6;i++)\n    {\n        rz += sn(t*h, note, octave)*seqAR(x, dcy ,atk, rel, 0.)*pw;\n        dcy += .1;\n        pw  -= .1;\n        h = float(i)+1.001;\n    }\n    rz = saw(rz*0.002,note,octave)*seqAR(x, .0 ,atk, rel, 0.);\n    \n    return rz;\n}\n\n//-------------------------------------------------------------------\n//----------------------------Mixing---------------------------------\n//-------------------------------------------------------------------\n\n//Simple mixing function with balance control  (balance range 0..1)\nvec2 mixb(float x, float bal)\n{\n\tbal = clamp(bal,0.,1.);\n\treturn vec2(x * bal, x*(1.-bal));\n}\n\n//-------------------------------------------------------------------\n//-----------------------------Main----------------------------------\n//-------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy*2.-1.;\n\tp.x *= iResolution.x/iResolution.y;\n    float time = iTime-0.1;\n    vec2 q = p;\n    //shake on the kicks (idea shamelessly stolen from srtuss)\n    float beat = seqAR(time*4.,.9,1.,1.,0.);\n    beat *= seq(time/8., -.75, 0.01, 0.);\n    p.x += (noise(time*80.)-0.5)*0.15*beat;\n    p.y += (noise(time*50.)-0.5)*0.15*beat;\n    p *= mm2((noise(time*1.)-0.5)*0.1*beat);\n\tfloat t = p.x*.005+time;\n\t\n    vec2 bp = p;\n    p = fract(p*.9)-0.5;\n    p.y *= 1.5;\n    float v = 0.;\n    vec3 col = vec3(0.);\n    if (bp.x< 0. && bp.y > 0.)\n    {   \n        //--------------first voice: pad---------------\n\t\t//the sequencer can be used to xfade\n\t\tv = fmsq(t,A,2.)*seq(time/4., 0.0, 0.9, 0./2.);\n\t\tv+= fmsq(t,A,3.)*seq(time/4., 0.0, 0.9, 1./2.)*0.75;\n    \t//two gate patterns and a mix between them\n    \tfloat seq1 = seqAR(time*16.,.25, .1,1., 0.25);\n    \tfloat seq2 = seqAR(time*8., .0, .001,1., 0.25);\n\t\tv *= mix(seq1, seq2, seq(time,0.,2.,0.));\n        \n        float rz = smoothstep(0.,.1,abs(p.y*2.+v));\n    \tcol = vec3(0.12,0.075,0.35)*-log(rz+0.01);\n    }\n    else if (bp.x< 0.)\n    {\n        //-------------second voice: drums--------------\n    \t//the AR envelope version of the sequencer can be used for basic \"drums\"\n    \n    \t//kick: low frequency sin with sharp attack and slow release\n    \t//in this care i'm also modulating the frequency for extra oomph\n    \tfloat frq = seqAR(time*4.,.9,1.,1.,0.)*0.05;\n    \tv = sn(t+frq,A,1.)*seqAR(time*4.,.9,.005,1.,0.);\n    \t//break\n    \tv *= seq(time/8., -.75, 0.01, 0.);\n    \t//closed hihat is pretty much the same but noise instead of a sine\n    \tv += noise(t)*seqAR(time*8.,0.99,.0001,70.,0.)*0.5;\n        \n        float rz = smoothstep(0.,.1,abs(p.y*2.+v));\n    \tcol = vec3(0.1,0.35,0.05)*-log(rz+0.01);    \n    }\n    else if (bp.y > 0.)\n    {\n        //----------third voice: chord-------------\n        v += additive(t, A, 4., 8.);\n        v += additive(t, C, 4., 8.);\n        v += additive(t, E, 4., 8.);\n        v *= seq(t/2.,7./8.,0.5,0.);\n        \n        float rz = smoothstep(0.,.15,abs(p.y*3.+v));\n   \t\tcol = vec3(0.3,0.03,0.19)*-log(rz+0.01);\n    }\n\telse\n    {\n    \t//---------fourth vbice: arp melody-------------\n        //Using this as a demo of the versatility of the sequencer\n\n        //some base notes for the arp\n        float nG = sqr(t,G,4.);\n        float nA = saw(t,A,4.);\n        float nB = sqr(t,B,4.);\n        float nC = saw(t,C,5.);\n        float nD = sqr(t,D,5.);\n        float nE = sqr(t,E,5.);\n\n        //some arp chords\n        float arpspeed = t*16.;\n        float arpgate = 0.5;\n        float ACE = arp(nA,nC,nE, arpspeed, arpgate);\n        float ABE = arp(nA,nB,nE, arpspeed, arpgate);\n        float GCE = arp(nG,nC,nE, arpspeed, arpgate);\n        float GBE = arp(nG,nB,nE, arpspeed, arpgate);\n        float GBD = arp(nG,nB,nD, arpspeed, arpgate);\n\n        //some patterns with those chords\n        float t12 = t/2.;\n        const float gat = 0.7;\n        const float sm = 0.05;\n        float pat1 = 0., pat2 = 0.;\n        pat1 += ACE*seq(t12, gat, sm, 0./4.);\n        pat1 += GBE*seq(t12, gat, sm, 2./4.);\n        pat1 += GBD*seq(t12, gat, sm, 3./4.);\n        pat2 = pat1; //only the second chord changes\n        pat1 += GCE*seq(t12, gat, sm, 1./4.);\n        pat2 += ABE*seq(t12, gat, sm, 1./4.);\n\n        //use the sequencer again to chain patterns\n        float chn= 0.;\n        chn += pat1*seq(t/4., 0., 0.1, 0./2.);\n        chn += pat2*seq(t/4., 0., 0.1, 1./2.);\n\n        //use the sequencer once more to gate the channel\n        float gt1 = chn*seq(t*8., -0.4, .5, 0.);\n        float gt2 = chn*seq(t*24.,-0.9, 0.3, 0.);\n        //a more complex gate sequence\n        float gt3 = 0.;\n        float t2 = t*2.;\n        gt3 += chn*seq(t2, 0.9, 0.05, 0./8.);\n        gt3 += chn*seq(t2, 0.9, 0.05, 2./8.);\n        gt3 += chn*seq(t2, 0.9, 0.05, 3./8.);\n        gt3 += chn*seq(t2, 0.9, 0.05, 5./8.);\n        gt3 += chn*seq(t2, 0.9, 0.05, 6./8.);\n\n        //use the sequencer once more to chain the gated sequences\n        v += gt1*seq(t/8., 0.72, 0.05, 1./2.);\n        v += gt2*seq(t/8., 0.72, 0.05, 0./2.);\n        v += gt3*seq(t/4.,-0.05 ,0.05, 1./2.);\n        \n        float rz = smoothstep(0.,.15,abs(p.y*3.+v));\n    \tcol = vec3(0.17,0.075,0.35)*-log(rz+0.01);\n    }\n    \n    //separators\n    p = bp;\n\tcol = max(col,vec3(.3,0.,1.)*(1.-abs((p.x)*100.)));\n\tcol = max(col,vec3(1.,0.,.5)*(1.-abs((p.y)*100.)));\n    \n    //post (grain)\n    col *= 1.-.4*texture(iChannel0,q*0.12+time*0.05).rgb;\n    \n    //background\n    bp *= mm2(time*.3);\n\tbp.x *= 22.;\n\tfloat rz = noise(bp+time*3.);\n\trz *= sin(bp.x*.9)*0.05+0.15;\n\tvec3 col2 = rz*vec3(5.+p.y*10.*(bp.x*1.), 0., 60.)*.15;\n    col = col2*(smoothstep(0.,.5,rz))+col;\n    \n    col *= 1.-beat*0.5;\n    \n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"outputs":[{"channel":0,"id":"XsfGRr"}],"inputs":[],"code":"//Music toolbox\n//by nimitz (stormoid.com) (twitter: @stormoid)\n\n/*\n\tTaking a different approach than sequencing all the notes one by one.\n\tInstead using a basic \"sequencer\" to create and combine/chain patterns\n\tthis allows for a more tracker-like experience.\n\n\tThe \"sequencer\" itself could be improved, a proper ADSR\n\tenvelope comes to mind.\n\n\tPlease let me know if you find stuff that can be fixed/improved.\n\t\n\tAlso included are defines for the chromatic scale, a few simple\n\twaveforms/instruments with note and octave input, a fm synth,\n\ta very fake filtered saw, some simple drums using the sequencer\n\tenvelopes, a 3 input arpeggiator and a very basic mix/pan function.\n*/\n\n#define PI 3.14159265358979323846\n#define TAU PI*2.\n\n#define C  32.703\n#define CS 34.648\n#define D  36.708\n#define DS 38.891\n#define E  41.203\n#define F  43.654\n#define FS 46.249\n#define G  48.999\n#define GS 51.913\n#define A  55.0\n#define AS 58.270\n#define B  61.735\n\nfloat noise( float x ){return fract(sin(1371.1*x)*43758.5453);}\n\n//-------------------------------------------------------------------\n//----------------------Modulating/Sequencing------------------------\n//-------------------------------------------------------------------\n\n//3 input arpeggiator, with smoothing\nfloat arp(float a, float b, float c, float t, float smoothv)\n{\t\n\tfloat ra = mix(0., a, smoothstep(0.333-smoothv, .333+smoothv, sin(t*TAU)));\n\tfloat rb = mix(0., b, smoothstep(0.333-smoothv, .333+smoothv, sin(t*TAU-.333*TAU)));\n\tfloat rc = mix(0., c, smoothstep(0.333-smoothv, .333+smoothv, sin(t*TAU-.666*TAU)));\n\treturn ra+rb+rc;\n}\n\n//BPM define is only used by the sequencer\n#define BPM 112.\n\n/* Input:\n\tgate = how long the note is on [-1...1]\n\tsmooth = symmetric attack/release smoothing (a real ADSR would be better)\noffset = time offset, [-1...1] 1 is one period\n*/\nfloat seq(float t, float gate, float smoothv, float ofst)\n{\n\treturn smoothstep( gate-smoothv, gate+smoothv,\n                      cos( (t*PI*BPM/120.) - ofst*TAU - PI*0.5 + gate ) );\n}\n\n//same idea but with an AR envelope\nfloat seqAR(float t, float gate, float atk, float rel, float ofst)\n{\n    float p = ((t*PI*BPM/120.)-ofst*TAU-PI*0.5+gate );\n    float tp = fract(p/PI*.5);\n    \n    //The envelopes have to be scaled based on the gate length\n    gate = clamp(gate,-1.,1.);\n    float scl = (1.-abs(gate));\n    atk *= scl;\n    rel *= scl;\n    \n    //Attack envelope\n\tif (tp > 0.5)\n\t\treturn smoothstep( gate-atk, gate+atk, cos(p));\n    //Release envelope\n\telse\n\t\treturn smoothstep( gate-rel, gate+rel, cos(p));\n}\n\n//-------------------------------------------------------------------\n//---------------------------Instruments-----------------------------\n//-------------------------------------------------------------------\n\n//Basic waveforms with note and octave input\nfloat sn(float t, float note, float octave)\n{\n\treturn sin(t*note*exp2(octave)*PI);\n}\n\nfloat saw(float t, float note, float octave)\n{\n\treturn fract(t*note*exp2(octave-1.))-0.5;\n}\n\nfloat tri(float t, float note, float octave)\n{\n\treturn (abs(fract(t*note*exp2(octave-1.))-0.5)*2.-0.5)*2.;\n}\n\nfloat sqr(float t, float note, float octave)\n{\n\treturn step(fract(t*note*exp2(octave-1.)), 0.5)-0.5;\n}\n\n//simple frequency modulation (3->1)\nfloat fmsq(float t, float note, float octave)\n{\n\tfloat fm = sn(t,note,octave-1.)*0.0008;\n\tfloat fm2 = sn(t,note,octave+1.)*0.0007;\n\tfloat fm3 = sn(t,note,octave+2.)*0.00055;\n\treturn sqr(t+fm+fm2+fm3,note,octave);\n}\n\n//very fake filtered saw (not used)\nfloat filterSaw(float t, float note, float octave, float cutoff, float q)\n{\n    float saw = fract(t*note*exp2(octave-1.))-0.5;\n    float sn = cos((t*note*exp2(octave)*PI)+PI*0.5);\n    float filt = smoothstep(cutoff-q,cutoff+q,abs(saw)*2.);\n    return mix(saw,sn,filt);\n}\n\n//a slightly more complex intrument using the sequencer for harmonic envelopes\n//freq is how often the note is triggered\nfloat additive(float t, float note, float octave, float freq)\n{\n    float x = t*freq;\n    float rz = 0.;\n    float atk = 0.01;\n    float rel = 1.;\n    float h = 1.;\n    float pw = 1.;\n    float dcy = .0;\n    \n    for(int i=0;i<6;i++)\n    {\n        rz += sn(t*h, note, octave)*seqAR(x, dcy ,atk, rel, 0.)*pw;\n        dcy += .1;\n        pw  -= .1;\n        h = float(i)+1.001;\n    }\n    rz = saw(rz*0.002,note,octave)*seqAR(x, .0 ,atk, rel, 0.);\n    \n    return rz;\n}\n\n//-------------------------------------------------------------------\n//----------------------------Mixing---------------------------------\n//-------------------------------------------------------------------\n\n//Simple mixing function with balance control  (balance range 0..1)\nvec2 mixb(float x, float bal)\n{\n\tbal = clamp(bal,0.,1.);\n\treturn vec2(x * bal, x*(1.-bal));\n}\n\n\n//----------------------------Main---------------------------------\nvec2 mainSound( in int samp,float time)\n{\n\tfloat t = time;\n    \n\t//--------------first voice: fm bass---------------\n\t\n\t//the sequencer can be used to xfade\n\tfloat v1 = fmsq(t,A,2.)*seq(t/4., 0.0, 0.9, 0./2.);\n\t\t  v1+= fmsq(t,A,3.)*seq(t/4., 0.0, 0.9, 1./2.)*0.75;\n    //two gate patterns and a mix between them\n    float seq1 = seqAR(t*16.,.25, .1,1., 0.25);\n    float seq2 = seqAR(t*8., .0, .001,1., 0.25);\n\tv1 *= mix(seq1, seq2, seq(t,0.,2.,0.));\n   \n    \n    //-------------second voice: drums--------------\n    //the AR envelope version of the sequencer can be used for basic \"drums\"\n    \n    //kick: low frequency sin with sharp attack and slow release\n    //in this care i'm also modulating the frequency for extra oomph\n    float frq = seqAR(t*4.,.9,1.,1.,0.)*0.05;\n    float v2 = sn(t+frq,A,1.)*seqAR(t*4.,.9,.005,1.,0.);\n    //break\n    v2 *= seq(t/8., -.75, 0.01, 0.);\n    //closed hihat is pretty much the same but noise instead of a sine\n    v2 += noise(t)*seqAR(t*8.,0.99,.0001,70.,0.)*0.5;\n    \n    \n\t//----------third voice: chord-------------\n    float v3 = 0.;\n    v3 += additive(t, A, 4., 8.);\n    v3 += additive(t, C, 4., 8.);\n    v3 += additive(t, E, 4., 8.);\n    v3 *= seq(t/2.,7./8.,0.5,0.);\n\t\n    \n    \n    //---------fourth voice: arp melody-------------\n    //Using this as a demo of the versatility of the sequencer\n    \n    //some base notes for the arp\n    float nG = sqr(t,G,4.);\n    float nA = saw(t,A,4.);\n    float nB = sqr(t,B,4.);\n    float nC = saw(t,C,5.);\n    float nD = sqr(t,D,5.);\n    float nE = sqr(t,E,5.);\n    \n    //some arp chords\n    float arpspeed = t*16.;\n    float arpgate = 0.5;\n    float ACE = arp(nA,nC,nE, arpspeed, arpgate);\n    float ABE = arp(nA,nB,nE, arpspeed, arpgate);\n    float GCE = arp(nG,nC,nE, arpspeed, arpgate);\n    float GBE = arp(nG,nB,nE, arpspeed, arpgate);\n    float GBD = arp(nG,nB,nD, arpspeed, arpgate);\n    \n    //some patterns with those chords\n    float t12 = t/2.;\n    const float gat = 0.7;\n    const float sm = 0.05;\n    float pat1 = 0., pat2 = 0.;\n    pat1 += ACE*seq(t12, gat, sm, 0./4.);\n    pat1 += GBE*seq(t12, gat, sm, 2./4.);\n    pat1 += GBD*seq(t12, gat, sm, 3./4.);\n    pat2 = pat1; //only the second chord changes\n    pat1 += GCE*seq(t12, gat, sm, 1./4.);\n   \tpat2 += ABE*seq(t12, gat, sm, 1./4.);\n    \n    //use the sequencer again to chain patterns\n    float chn= 0.;\n    chn += pat1*seq(t/4., 0., 0.1, 0./2.);\n    chn += pat2*seq(t/4., 0., 0.1, 1./2.);\n    \n    //use the sequencer once more to gate the channel\n    float gt1 = chn*seq(t*8., -0.4, .5, 0.);\n    float gt2 = chn*seq(t*24.,-0.9, 0.3, 0.);\n    //a more complex gate sequence\n    float gt3 = 0.;\n    float t2 = t*2.;\n    gt3 += chn*seq(t2, 0.9, 0.05, 0./8.);\n    gt3 += chn*seq(t2, 0.9, 0.05, 2./8.);\n    gt3 += chn*seq(t2, 0.9, 0.05, 3./8.);\n    gt3 += chn*seq(t2, 0.9, 0.05, 5./8.);\n    gt3 += chn*seq(t2, 0.9, 0.05, 6./8.);\n    \n\t//use the sequencer once more to chain the gated sequences\n\tfloat v4 = 0.;\n\tv4 += gt1*seq(t/8., 0.72, 0.05, 1./2.);\n\tv4 += gt2*seq(t/8., 0.72, 0.05, 0./2.);\n\tv4 += gt3*seq(t/4.,-0.05 ,0.05, 1./2.);\n    \n\t//Mixing\n\tvec2 v = vec2(0.);\n\tv += mixb(v1*0.25,0.4);\n    v += mixb(v2*1.5,0.5);\n\tv += mixb(v3*0.2,cos(t*1.7)*0.25+0.5);\n\tv += mixb(v4*0.3,sin(t*1.7)*0.25+0.5);\n\treturn v;\n}","name":"Sound","description":"","type":"sound"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":true,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MdfXW2","date":"1406927716","viewed":3830,"name":"Music toolbox","username":"nimitz","description":"Playing with the new audio feature (make sure to turn your speakers on :) ).\n\nTrying to make composing straight in the shader more intuitive. Mostly based around the idea of a versatile sequencer which can be used for both modulating and sequencing.","likes":102,"published":1,"flags":8,"usePreview":0,"tags":["music","audio","utility"],"hasliked":0,"parentid":"","parentname":""}}