{"ver":"0.1","info":{"id":"Wst3WH","date":"1568564272","viewed":112,"name":"Little Eyeball Dude","username":"AlexWalley","description":"Creating my first creature/object with raymarching. ","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","eye","practice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 150.\n#define SURF_DIST 0.001\n#define MAX_DIST 100.\n\nfloat SN31(vec3 p){\n    return fract(sin(p.x*3482.87+p.y*3427.21+p.z*43726.43)*5843.)*2.-1.;\n}\n\nvec3 opRepLim(vec3 p, float s, vec3 lima, vec3 limb){\n \treturn p-s*clamp(round(p/s), lima, limb);   \n}\n\nfloat smoothNoise(vec3 p){\n    vec3 id = floor(p);\n    vec3 gv = fract(p);\n    \n    gv = gv*gv*(3.-2.*gv);\n    \n    float bl = SN31(id);\n    float br = SN31(id+vec3(1., 0., 0.));\n    float b = mix(bl, br, gv.x);\n    \n    float tl = SN31(id+vec3(0.,1., 0.));\n    float tr = SN31(id+vec3(1.,1., 0.));\n    float t = mix(tl, tr, gv.x);\n    \n    float fl = SN31(id+vec3(0., 0., 1.));\n    float fr = SN31(id+vec3(0., 1., 1.));\n    float f = mix(fl, fr, gv.x);\n    return mix(mix(b, t, gv.y), f, gv.z);\n\n}\n\n#define OCTAVES 6\nfloat fbm (in vec3 p) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        float n = abs(smoothNoise(p));\n        n = 1.0 - n;\n        n *= n;\n        value += amplitude * n;\n        p *= 2.;\n        amplitude *= .5;\n    }\n    \n    return value;\n}\n\n// Smooth Union and Subtraction\n\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    \n  return mix(a, b, h) - k*h*(1.0-h);\n}\n\nfloat ssub( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n// Signed Distance Functions\n\nfloat sdSphere(vec3 pos, float rad){\n\treturn length(pos)-rad;   \n}\n\nfloat sdEllipsoid(vec3 pos, vec3 rad){\n    float k0 = length(pos/rad);\n    float k1 = length(pos/rad/rad);\n    return k0*(k0-1.0)/k1;\n}\n\nvec2 ballsSDF(vec3 p){\n    \n    vec3 id = 10.*clamp(round(p/10.), vec3(2.), vec3(-3.)); //wrong\n    \n    p = opRepLim(p, 10., vec3(2.), vec3(-3.));\n    \n    \n    float t = fract(iTime);\n\n    float y = 6.0*t*(1.0-t);\n    float dy = 6.0*(1.0-2.*t);\n    \n    vec2 u = vec2(1.0, dy);\n    vec2 v = vec2(-dy, 1.0);\n    \n    vec3 cen = vec3(0.,1.0+y,0.);\n    \n    float sy = 0.8 + 0.2*y;\n    float sz = 1.0/sy;\n    \n    \n    vec3 rad = vec3(1.0*sz, 1.0*sy, 1.0*sz);\n\t//rad = vec3(1.0);\n    vec3 q = p-cen;\n    \n    float sphDist = sdEllipsoid(q, rad);\n    \n    //Eye\n    float blinkTime = mod(iTime, 200.); \n    \n    float blink = pow((sin(blinkTime)*0.5+0.5), 40.);\n    vec3 eyeSockCen = cen-vec3(0.5, 0., 0.);\n    vec3 eyeSockRad = rad - vec3(0.25, 0.35+blink*(1.-0.4), 0.25);\n    float eyeSockDist = sdEllipsoid(p-eyeSockCen, eyeSockRad);\n    \n    vec3 eyeCen = eyeSockCen+vec3(0.3, 0., 0.);\n    vec3 eyeRad = rad-(1.0-vec3(0.8, 0.8, 0.75));\n    float eyeDist = sdEllipsoid(p-eyeCen, eyeRad);\n    \n    vec3 pupilCen = eyeSockCen-vec3(eyeSockRad.x-0.35, 0.0, 0.0);\n    vec3 pupilRad = vec3(0.15, 0.2, 0.2);\n    float pupilDist = sdEllipsoid(p-pupilCen, pupilRad);\n    \n    vec2 res = vec2(sphDist, 2.);\n    \n    res.x = ssub(eyeSockDist, sphDist, 0.05);\n    if(eyeDist < res.x) res.y = 3.0; //Skin\n    \n    res.x = smin(res.x, eyeDist, 0.2);\n    \n    if(pupilDist < res.x) res = vec2(pupilDist, 4.0);//Pupil\n    \n    \n    return res;\n}\n\n\nvec2 map(vec3 p){\n    \n    float k = 0.7;\n    float mat = 1.0;\n    \n    vec2 balls = ballsSDF(p);\n    float planeDist = p.y;\n    \n    float a = min(balls.x, planeDist);\n    \n    float num = 10.;\n    \n    vec2 ret = vec2(a, mat);\n    \n    //return ret;\n    \n    return (balls.x < planeDist) ? vec2(a,balls.y) : vec2(a, mat);\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd){\n    float dO = 0.;\n    \n    float i;\n    for(i = 0.; i < MAX_STEPS; i++){\n        vec3 p = ro+rd*dO;\n        \n    \tfloat d = map(p).x;\n        if(d < SURF_DIST || dO > MAX_DIST) break;\n        dO += d;\n    }\n    if(dO > MAX_DIST) dO = -1.;\n    float mat = map(ro+rd*dO).y*sign(dO);\n    return vec2(dO, mat); \n}\n\nvec3 getNormal(vec3 p){\n\tvec2 e = vec2(0.01, 0.);\n    float d = map(p).x;\n    return normalize(d - vec3(map(p-e.xyy).x,\n                    map(p-e.yxy).x,\n                    map(p-e.yyx).x));\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float mint, float maxt, float k){\n \n    float res = 1.0;\n    for(float t = mint; t < maxt;){\n        float h = map(ro + rd*t).x;\n        if(h < SURF_DIST) return 0.0;\n        res = min(res, k*h/t);\n        t += h;\n    }\n    return res;\n}\n\nvec3 getLight(vec3 p, vec3 ro){\n    vec3 lightPos = vec3(-30, 7., 3.);\n    vec3 cam = normalize(ro-p);\n    \n    vec3 l = normalize(lightPos-p);\n    vec3 n = getNormal(p);\n    \n    vec3 mate = vec3(0.2);\n    \n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float sky_dif = clamp(0.3+0.5*dot(n, vec3(0.,1.,0.)), 0., 1.);\n    float bou_dif = clamp(dot(n, vec3(0.,-1.,0.)), 0., 1.);\n    float distStep = 0.5;\n    float ambientOcc = clamp(pow(distStep + map(p+n*distStep).x, 0.4), 0., 1.);\n    float shadow = step(rayMarch(p+n*SURF_DIST*2., l).x, 0.);\n\tshadow = softShadow(p+n*SURF_DIST*2., l, 1., MAX_DIST, 32.);\n    vec3 reflection = - (l + 2.*dot(n, -l)*n);\n    float specAmt = pow( max( dot(reflection, cam), 0.), 16.);\n    vec3 specular = 0.25 * specAmt * vec3(1., 0.5, 0.1);  \n    \n    vec3 col = vec3(0.);\n    col += mate*dif*shadow*vec3(8.0, 5.0, 3.0);\n    col += mate*sky_dif*vec3(0.5, 0.8, 0.9)*2.;\n    col += mate*bou_dif*vec3(0.7, 0.4, 0.3);\n    col += specular;\n    col *= ambientOcc*vec3(1.0);\n    //col = vec3(shadow);\n    return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n   \n    \n    //Ray marching\n    float a = 10.*iMouse.x/iResolution.x;\n    vec3 ro = vec3(4.*sin(a), 2.5, 4.*cos(a));\n    //CAMERA \n    float zoom = 0.5;\t\n    vec3 lookat = vec3(0.,2.,0.);\n    \n    vec3 F = normalize(lookat-ro);\n    vec3 R = cross(vec3(0,1,0), F);\n    vec3 U = cross(F, R);\n    \n    \n    vec3 C = ro + F*zoom;\n    vec3 I = C + uv.x*R + uv.y*U;\n    \n    vec3 rd = I-ro;\n    \n    //SKY\n    vec3 col = vec3(0.4, 0.65, 0.8) -0.7*rd.y;\n    col = mix(col, vec3(0.7, 0.75, 0.8), exp(-rd.y*10.));\n    \n   \tvec2 march = rayMarch(ro, rd);\n    vec3 p = ro+rd*march.x;\n    vec3 light = getLight(p, ro);\n\n    \n    if(march.y > 0.){ // Ground\n    \n\t\tcol = vec3(0.3, 0.7, 0.1)*vec3(light);\n    }\n    if(march.y > 1.5){//Skin\n        col = (vec3(0.8, 0.8, 0.7))*light;\n    }\n    if(march.y > 2.5){ // Eyeball\n        \n        float red = smoothstep(0.4, 0.9, fbm((uv.xyx)*2.)); // Tried to do red veins\n        red = 0.;\n        \n    \tcol = light*((vec3(1.3, 1.3, 1.2)*(1.-red))+vec3(1.0, 0., 0.)*red); \n       \n    }\n    if(march.y > 3.0){ // Pupil\n        col = vec3(0.05)*light;\n    }\n    \n    col = pow(col, vec3(1./2.2)); // Gamma correction\n\n    \n    //col = vec3(fbm(uv*5.));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}