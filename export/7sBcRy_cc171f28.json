{"ver":"0.1","info":{"id":"7sBcRy","date":"1643714681","viewed":169,"name":"VolumeSpotlight","username":"soma_arc","description":"This spotlight is based on Learn OpenGL.\nhttps://learnopengl.com/Lighting/Light-casters","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct SpotLight {\n    vec3 position;\n    vec3 direction;\n    float cutOff;\n    float outerCutOff;\n  \n    float constant;\n    float linear;\n    float quadratic;\n  \n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    \n    vec3 power;\n};\n\nSpotLight spotLight;\n\n// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(vec2 co, float sampleIndex) {\n\tvec2 seed = co * (sampleIndex + 1.0);\n\tseed+=vec2(-1,1);\n\t// implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n\treturn vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nconst float DISPLAY_GAMMA_COEFF = 1. / 2.2;\nvec3 gammaCorrect(vec3 rgb) {\n\treturn vec3((min(pow(rgb.r, DISPLAY_GAMMA_COEFF), 1.)),\n                (min(pow(rgb.g, DISPLAY_GAMMA_COEFF), 1.)),\n                (min(pow(rgb.b, DISPLAY_GAMMA_COEFF), 1.)));\n}\n\nvec3 deGamma(vec3 rgb){\n  return vec3((min(pow(rgb.r, 2.2), 1.)),\n              (min(pow(rgb.g, 2.2), 1.)),\n              (min(pow(rgb.b, 2.2), 1.)));\n}\n\nconst float k_isotropic = 1. / 12.566368;\n// PVR p297\nvec3 lightIntensity(vec3 lightPos, vec3 lightPower, vec3 p){\n\tvec3 dir = lightPos - p;\n    return lightPower * (1. / dot(dir, dir));\n}\n\n// PVR p301\nfloat phaseFunction(vec3 w, vec3 w_light){\n\t// isotropic phase function 1/(4 * PI)\n    return k_isotropic;\n}\n\nfloat lightVisibility(vec3 org, vec3 target){\n    vec3 v = normalize(target - org);\n    float theta = dot(-v, normalize(-spotLight.direction));\n    if(theta <= spotLight.outerCutOff) return 0.;\n\treturn 1.;\n}\n\n// PVR p186 Code 10.2\nvec3 integrateScattering(vec3 p, vec3 w, float rayLength){\n    const float current = 0.;\n    const float end = 100.;\n    const float stepSize = .1;\n    // Integration variables\n    vec3 T = vec3(1.);\n    vec3 L = vec3(0.);\n\t// Integration loop\n    for(float current = 0. ; current < end ; current += stepSize){\n\t\tif(current > rayLength) break;\n    \t// Determine sample position\n        vec3 p_i = p + w * current;\n        // Sample volume properties (This is constant volume)\n        //vec3 sigma_s = vec3(1. * (1. + sin(iTime)), 1., 1.);\n        vec3 sigma_s = vec3(.1 , .1, .1);\n        \n        // Compute change in transmittance\n        vec3 T_i = vec3(exp(-sigma_s.x * stepSize),\n                         exp(-sigma_s.y * stepSize),\n                         exp(-sigma_s.z * stepSize));\n        // Update accumulated transmittance\n        T *= T_i;\n        \n        //Sample light source\n        \n        vec3 w_light = spotLight.position - p_i;\n        vec3 L_light = lightIntensity(spotLight.position, spotLight.power, p_i);\n        L_light *= lightVisibility(spotLight.position, p_i);\n        // Accumulate reflected light\n        L += T * sigma_s * phaseFunction(w, w_light) * L_light;\n        /*\n        w_light = lightPos2 - p_i;\n        L_light = lightIntensity(lightPos2, lightPower2, p_i);\n        L_light *= lightVisibility(lightPos2, p_i);\n        L += T * sigma_s * phaseFunction(w, w_light) * L_light;\n    */\n    }\n    return L;\n}\n\nbool intersectPlane(vec3 p, vec3 n, \n                    vec3 rayOrigin, vec3 rayDir, inout vec4 isect){\n    float d = -dot(p, n);\n    float v = dot(n, rayDir);\n    float t = -(dot(n, rayOrigin) + d) / v;\n    if(0.000001 < t && t < isect.x){\n        isect = vec4(t, n);\n    \treturn true;\n    }\n    return false;\n}\n\nfloat distPlane(vec3 p, vec4 n) {\n    return dot(p, n.xyz) + n.w;\n}\n\nfloat distSphere(vec3 p, vec4 sphere){\n\treturn distance(p, sphere.xyz) - sphere.w;\n}\n\n// This mandelbulb implementation is shown in Syntopia\n//http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/\nfloat distMandelbulb(vec3 pos) {\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n    float power = 8.;\n\tfor (int i = 0; i < 20 ; i++) {\n\t\tr = length(z);\n\t\tif (r>2.) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, power-1.0)*power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,power);\n\t\ttheta = theta*power;\n\t\tphi = phi*power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\nvec2 opUnion(vec2 d1, vec2 d2) {\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\nconst int OBJ_PLANE = 0;\nconst int OBJ_SPHERE = 1;\nvec2 distFunc(vec3 p) {\n\tvec2 d = vec2(distPlane(p, vec4(0, 1, 0, 0)), OBJ_PLANE);\n    d = opUnion(d, vec2(distMandelbulb(p*.4 - vec3(0, 1.5, 0)), OBJ_SPHERE));\n    return d;\n}\n\nconst vec2 NORMAL_COEFF = vec2(.1, 0.);\nvec3 computeNormal(const vec3 p){\n  return normalize(vec3(distFunc(p + NORMAL_COEFF.xyy).x - distFunc(p - NORMAL_COEFF.xyy).x,\n                        distFunc(p + NORMAL_COEFF.yxy).x - distFunc(p - NORMAL_COEFF.yxy).x,\n                        distFunc(p + NORMAL_COEFF.yyx).x - distFunc(p - NORMAL_COEFF.yyx).x));\n}\n\nconst int MAX_MARCH = 800;\nconst float EPSILON = 0.01;\n\nfloat computeShadowFactor (vec3 rayOrg, vec3 rayDir,\n                           float mint, float maxt, float k) {\n    float shadowFactor = 1.0;\n    for(float t = mint ; t < maxt ;){\n        float d = distFunc(rayOrg + rayDir * t).x;\n        if(d < EPSILON) break;\n\n        shadowFactor = min(shadowFactor, k * d / t);\n        t += d;\n    }\n    return clamp(shadowFactor, 0.0, 1.0);\n}\n\nint march (vec3 rayOrg, vec3 rayDir, inout float minDist,\n           float maxDist,\n           inout vec3 intersection, inout vec3 normal) {\n    vec3 rayPos = rayOrg + minDist * rayDir;\n    vec2 dist = vec2(-1);\n    float rayLength = 0.;\n    for(int i = 0 ; i < MAX_MARCH ; i++){\n        if(rayLength > maxDist) return -1;\n        dist = distFunc(rayPos);\n        rayLength += dist.x;\n        rayPos = rayOrg + rayDir * rayLength;\n        if(dist.x < EPSILON){\n            int objId = int(dist.y);\n            intersection = rayPos;\n            normal = computeNormal(intersection);\n            minDist = rayLength;\n            return objId;\n        }\n    }\n    return -1;\n}\n// calculates the color when using a spot light.\nvec3 CalcSpotLight(SpotLight light, vec3 normal, vec3 fragPos, vec3 viewDir,\n                   int objId)\n{\n    vec3 lightDir = normalize(light.position - fragPos);\n    // diffuse shading\n    float diff = max(dot(normal, lightDir), 0.0);\n    // specular shading\n    vec3 reflectDir = reflect(-lightDir, normal);\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.);\n    // attenuation\n    float dist = length(light.position - fragPos);\n    float attenuation = 1.0 / (light.constant + light.linear * dist + light.quadratic * (dist * dist));    \n    // spotlight intensity\n    float theta = dot(lightDir, normalize(-light.direction)); \n    float epsilon = light.cutOff - light.outerCutOff;\n    float intensity = clamp((theta - light.outerCutOff) / epsilon, 0.0, 1.0);\n    // combine results\n    vec2 p = fract(fragPos.xz*100. / iChannelResolution[0].xy);\n    vec3 ambient, diffuse;\n    if(objId == OBJ_PLANE) {\n        ambient = light.ambient * deGamma(texture(iChannel0, p).rgb);\n        diffuse = light.diffuse * diff * deGamma(texture(iChannel0, p).rgb);\n    } else {\n        ambient = light.ambient * deGamma(texture(iChannel1, p).rgb);\n        diffuse = light.diffuse * diff * deGamma(texture(iChannel1, p).rgb);\n    }\n    vec3 specular = light.specular * spec * vec3(0.3);\n    ambient *= attenuation * intensity;\n    diffuse *= attenuation * intensity;\n    specular *= attenuation * intensity;\n    return (ambient + diffuse + specular);\n}\n\nvec3 calcColor(vec3 eye, vec3 ray){\n  \tvec3 l = vec3(0);\n  \tfloat coeff = 1.;\n  \t//vec4 result = intersectSphere(spherePos, sphereR, eye, ray, vec4(99999.));\n    //vec4 result = vec4(9999999.);\n    //bool hit = intersectPlane(vec3(0, 0, 0), vec3(0, 1, 0), eye, ray, result);\n    vec3 intersection, normal;\n    int objId = -1;\n    float t0 = 0.0001;\n    float t1 = 99999.;\n    objId = march(eye, ray, t0, t1,\n                  intersection, normal);\n  \tif(objId != -1){\n        //vec3 intersection = eye + ray * result.x;\n        float k = computeShadowFactor(intersection + normal * 0.1, \n                                      normalize(spotLight.position - intersection),\n                                      0., 100., 5.);\n        l += integrateScattering(eye, ray, t0);\n        l += k * CalcSpotLight(spotLight, normal, intersection, -ray, objId);\n\n    } else {\n        l += integrateScattering(eye, ray, 2. * length(eye - spotLight.position));\n    }\n  \treturn l;\n}\n\nvec3 calcRay (const vec3 eye, const vec3 target, const vec3 up, const float fov,\n              const float width, const float height, const vec2 coord){\n\tfloat imagePlane = (height * .5) / tan(fov * .5);\n  \tvec3 v = normalize(target - eye);\n \tvec3 xaxis = normalize(cross(v, up));\n  \tvec3 yaxis =  normalize(cross(v, xaxis));\n  \tvec3 center = v * imagePlane;\n  \tvec3 origin = center - (xaxis * (width  *.5)) - (yaxis * (height * .5));\n  \treturn normalize(origin + (xaxis * coord.x) + (yaxis * (height - coord.y)));\n}\n\nconst vec3 target = vec3(0., 3., 0);\nconst vec3 up = vec3(0, 1, 0);\nfloat fov = radians(60.);\n\nconst float SAMPLE_NUM = 2.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    spotLight.position = vec3(0, 11, 0);\n    spotLight.direction = vec3(0, -1, 0);\n    spotLight.cutOff = 0.8;\n    spotLight.outerCutOff = 0.7;\n    spotLight.ambient = vec3(0.3);\n    spotLight.diffuse = vec3(1.);\n    spotLight.specular = vec3(0.1);\n    spotLight.constant = 1.;\n    spotLight.linear = .09;\n    spotLight.quadratic = 0.007;\n    spotLight.power = vec3(10);\n\n    vec3 sum = vec3(0);\n    vec3 eye = vec3(10. * cos(iTime * .5), 5, 10. * sin(iTime * .5));\n    for(float i = 0. ; i < SAMPLE_NUM ; i++){\n        vec2 coordOffset = rand2n(gl_FragCoord.xy, i);\n        vec3 ray = calcRay(eye, target, up, fov,\n                           iResolution.x, iResolution.y,\n                           gl_FragCoord.xy + coordOffset);\n\n        sum += calcColor(eye, ray);\n    }\n    vec3 col = (sum/SAMPLE_NUM);\n\tfragColor = vec4(gammaCorrect(col), 1.);\n}","name":"Image","description":"","type":"image"}]}