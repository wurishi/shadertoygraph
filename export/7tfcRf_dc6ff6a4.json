{"ver":"0.1","info":{"id":"7tfcRf","date":"1648422264","viewed":146,"name":"Ghostlight Orb","username":"Hyeve","description":"More \"true\" volumetric rendering, and some reflectivity.\n\nNow with added spacetime warping!","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","transparency","volumetric","fog"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define DTR 0.01745329\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\nvec2 uv;\nvec3 cp,cn,cr,ro,rd,ss,oc,cc,gl,vb;\nvec4 fc;\nfloat tt,cd,sd,io,oa,td,tc;\nint es=0,ec;\n\nfloat bx(vec3 p,vec3 s){vec3 q=abs(p)-s;return min(max(q.x,max(q.y,q.z)),0.)+length(max(q,0.));}\nfloat tor(vec3 p,vec2 t){return length(vec2(length(p.xz)-t.x,p.y))-t.y;}\n\nvec3 lattice(vec3 p, int iter, float an)\n{\n\t\tfor(int i = 0; i < iter; i++)\n\t\t{\n\t\t\tp.xy *= rot(an*DTR);\n\t\t\tp = abs(p) - 0.4;\n\t\t\tp.xy *= rot(-an*DTR);\n\t\t\tp.xz *= rot(an*DTR);\n\t\t}\n\t\treturn p;\n}\n\nfloat mp(vec3 p)\n{\n\t\tvec3 pp=p;\n\n\t\tp.xz*=rot(tt*0.1);\n\t\tp.xy*=rot(tt*0.1);\n\t\n\t\tp = lattice(p, 5, 45. + sin(tt) * 5.);\n\t\tsd=abs(bx(p,vec3(0.5))-1.)-0.001;\n\t\tp=pp;\n\t\tp.yz*=rot(-tt*0.85);\n\t\tp.xz*=rot(tt*0.35);\n\t\tp.yx *= rot(tt*0.1*sin(tt*0.7)*0.1 + 1.5);\n\t\tfloat sh=abs(tor(p,vec2(6,0.2)))-0.001;\n\t\tsd=min(sd,sh);sd=abs(sd)-0.001;\n\t\tpp/=10.;\n\t\tpp.xz *= rot(-tt*0.45);\n\t\tpp.yz *= rot(tt*0.9);\n\t\t\n\t\tpp.xy += cos(tt)*2.;\n\t\tpp.yz += sin(tt)*2.;\n\t\n\t\n\t\tif(sd<0.001)\n\t\t{\n\t\t\tio=sh-0.01<sd?-1.:1.;\n\t\t\toc=io<0.?vec3(0.1):normalize(pp*pp)*vec3(0.8,0.,0.5)+vec3(0.1,0.,0.5);\n\t\t\toa=io<0.?0.3:0.;\n\t\t\tss=vec3(0);\n\t\t  vb=vec3(io<0.?0.:1.,8.,1.5);\n\t\t\tec=1;\t\n\t\t}\n\t\treturn sd;\n}\n\nvoid tr(){vb.x=0.;cd=0.;for(tc=0.;tc<512.;tc++){mp(ro+rd*cd);cd+=sd;td+=sd;if(sd<0.0001||cd>128.)break;}}\nvoid nm(){mat3 k=mat3(cp,cp,cp)-mat3(.001);cn=normalize(mp(cp)-vec3(mp(k[0]),mp(k[1]),mp(k[2])));}\n\nvoid px()\n{\n  cc=vec3(0.1,0.1,0.3)+length(pow(abs(rd+vec3(0,0.5,0)),vec3(3)))*0.3+gl/tc;\n  vec3 l=vec3(0.9,0.7,0.5);\n  if(cd>128.){oa=1.;return;}\n  float df=clamp(length(cn*l),0.,1.);\n  vec3 fr=pow(1.-df,3.)*mix(cc,vec3(0.4),0.5);\n\tfloat sp=(1.-length(cross(cr,cn*l)))*0.2;\n\tfloat ao=min(mp(cp+cn*0.3)-0.3,0.3)*0.4;\n  cc=mix((oc*(df+fr+ss)+fr+sp+ao+gl/tc),oc,vb.x);\n}\n\nvoid render(vec2 frag, vec2 res, float time, out vec4 col)\n{\n\t\n  uv=vec2(frag.x/res.x,frag.y/res.y);\n  uv-=0.5;uv/=vec2(res.y/res.x,1);\n  ro=vec3(0,0,-12);rd=normalize(vec3(uv,1));\n\ttt=mod(time, 260.)+length(uv)*0.3;\n  \n\tfor(int i=0;i<25;i++)\n  {\n\t\ttr();cp=ro+rd*cd;nm();ro=cp-cn*(io<0.?-0.01:0.01);\n\t\tcr=refract(rd,cn,i%2==0?1./io:io);i=io<0.?i+1:i;\n    if((length(cr)==0.&&es<=0)||io<0.){cr=reflect(rd,cn);es=(io<0.?es:ec);}\n    if(max(es,0)%3==0&&cd<128.)rd=cr;es--;\n\t\tif(vb.x>0.&&i%2==1)oa=pow(clamp(cd/vb.y,0.,1.),vb.z);\n\t\tpx();fc=fc+vec4(cc*oa,oa)*(1.-fc.a);if((fc.a>=1.||cd>128.))break;\n  }\n  col = fc/fc.a;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    render(fragCoord.xy,iResolution.xy,iTime,fragColor);\n} ","name":"Image","description":"","type":"image"}]}