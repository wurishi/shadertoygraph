{"ver":"0.1","info":{"id":"MlSfzV","date":"1516489161","viewed":117,"name":"my basic raymarcher","username":"unnick","description":"my first raymarcher.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define raymul 0.5\n#define posmul 0.5\n\n#define lightcolor 1.0, 1.0, 1.0\n\n#define specpower 50.0\n\nfloat dist(vec3 pos){\n    float dist = 0.0;\n    //sphere\n    pos -= vec3(\n        iMouse.z<0.5?sin(iTime):0.0,\n        iMouse.z<0.5?sin(iTime*3.0)*0.2:0.0,\n        iMouse.z<0.5?cos(iTime):0.0\n    );\n    dist = length(pos)-1.0;\n    //distort\n    dist += (cos(pos.x*10.0)+cos(pos.y*10.0)+cos(pos.z*10.0))*0.1;\n    //return distance\n    return dist;\n}\n\nvec3 getnormal(vec3 pos){\n    //basically computes the gradient and then normalizes it.\n    float d = 0.00001;\n    float dx = (dist(pos+vec3(d, 0.0, 0.0)) - dist(pos)) / d;\n    float dy = (dist(pos+vec3(0.0, d, 0.0)) - dist(pos)) / d;\n    float dz = (dist(pos+vec3(0.0, 0.0, d)) - dist(pos)) / d;\n    return normalize(vec3(dx, dy, dz));\n}\n\nvec3 material(vec3 pos){\n    vec2 mpos = (iMouse.xy - iResolution.xy / 2.0) / min(iResolution.x, iResolution.y) * 2.0;\n    \n    //get stuff for computing the color\n    //get normal\n    vec3 normal = getnormal(pos);\n    //get light direction\n    vec3 lightdir = normalize(vec3(mpos.x, 3.0, mpos.y)-pos);\n\n    //compute color\n    vec3 color;\n    \n    //dot product the normal and light direction\n    float reflectance = max(dot(normal, lightdir), 0.0);\n    //diffuse reflection\n    color = vec3(reflectance) * (cos(pos*6.283)*0.5+0.5) * vec3(lightcolor);\n    //specular highlights\n    color = mix(color, vec3(lightcolor), pow(reflectance, specpower));\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 pos = (fragCoord.xy - iResolution.xy / 2.0) / min(iResolution.x, iResolution.y) * 2.0;\n    vec3 ray = normalize(vec3(pos.x * posmul, -1.0, pos.y * posmul));\n    vec3 rpos = vec3(0.0, 5.0, 0.0);\n    for(int i = 0; i < 256; i++){\n        \n        float cdist = dist(rpos);\n        \n        //raymarch\n        rpos += ray * cdist * raymul;\n        \n        //checks if the ray position is near the object\n        if(cdist < 0.001){\n            \n            fragColor = vec4(material(rpos), 1.0);\n            return;\n            \n        }\n        \n        //check if ray position is far away from the object\n        //not needed but it speeds up the rendering of the sky a lot.\n        if(cdist > 5.0){\n\t        fragColor = vec4(0.0, 0.5, 1.0, 1.0);\n            return;\n        }\n        \n    }\n    //if the ray isnt near enough the object and isnt far away from the object,\n    //it probably needs more iterations.\n\tfragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}","name":"Image","description":"","type":"image"}]}