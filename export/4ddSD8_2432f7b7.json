{"ver":"0.1","info":{"id":"4ddSD8","date":"1497208317","viewed":254,"name":"Noise CLT Scan","username":"mplanck","description":"A sliding scan of a noise signal while doing CLT analysis (noise is Buffer A). Key '+' to increase samples, '-' to decrease samples. Yellow is mean. Purple is std deviation. Graph lines represent expected mean and std deviation.","likes":15,"published":1,"flags":48,"usePreview":0,"tags":["noise","clt"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat g_expected_mean;\nfloat g_expected_std_deviation;\nfloat g_scan_speed;\nfloat g_number_of_samples;\n\n//-----------------------------------------------------------------\n// Digit drawing function by P_Malin (https://www.shadertoy.com/view/4sf3RN)\n\nfloat sample_digit(const in float n, const in vec2 vUV)\n{       \n    if(vUV.x < 0.0) return 0.0;\n    if(vUV.y < 0.0) return 0.0;\n    if(vUV.x >= 1.0) return 0.0;\n    if(vUV.y >= 1.0) return 0.0;\n    \n    float data = 0.0;\n    \n         if(n < 0.5) data = 7.0 + 5.0*16.0 + 5.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n    else if(n < 1.5) data = 2.0 + 2.0*16.0 + 2.0*256.0 + 2.0*4096.0 + 2.0*65536.0;\n    else if(n < 2.5) data = 7.0 + 1.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n    else if(n < 3.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n    else if(n < 4.5) data = 4.0 + 7.0*16.0 + 5.0*256.0 + 1.0*4096.0 + 1.0*65536.0;\n    else if(n < 5.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n    else if(n < 6.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n    else if(n < 7.5) data = 4.0 + 4.0*16.0 + 4.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n    else if(n < 8.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n    else if(n < 9.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n    \n    vec2 vPixel = floor(vUV * vec2(4.0, 5.0));\n    float fIndex = vPixel.x + (vPixel.y * 4.0);\n    \n    return mod(floor(data / pow(2.0, fIndex)), 2.0);\n}\n\nfloat print_int(const in vec2 uv, const in float value )\n{\n    float res = 0.0;\n    float maxDigits = 4.;\n    float digitID = floor(uv.x);\n    if( digitID>0.0 && digitID<=maxDigits )\n    {\n        float digitVa = mod( floor( value/pow(10.0,maxDigits-digitID) ), 10.0 );\n        res = sample_digit( digitVa, vec2(fract(uv.x), uv.y) );\n    }\n\n    return res; \n}\n\n//-----------------------------------------------------------------\n\nfloat in_box_range(vec2 value, vec2 bottom, vec2 top)\n{\n    return step(value.x, top.x) * step(bottom.x, value.x) * step(value.y, top.y) * step(bottom.y, value.y);    \n}\n                   \nfloat in_pixel_range(vec2 value, vec2 pixel)\n{\n    return in_box_range(value, pixel, pixel + vec2(1.));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    g_expected_mean = .5;\n\tg_expected_std_deviation = .2886751345948;\n    g_scan_speed = 20.; // update in buffer B and Image. messy!\n    float s = texture(iChannel1, vec2(.5, 0.), -100.).b;\n    g_number_of_samples = 4.*s*s;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float invap = iResolution.y/iResolution.x;\n    vec3 fcol = vec3(.21);\n    \n    // shared logic in buffer B and image. messy!\n    float sqrtNumSamples = floor(sqrt(g_number_of_samples));\n    float r = floor(.5 * sqrtNumSamples);    \n    vec2 sampleCenter = floor(iChannelResolution[1].xy * vec2(.6, .1));\n    float step = floor(iTime * g_scan_speed);\n    vec2 sample_uv = vec2(mod(step, 60.), mod(floor(step/60.), 60.));\n    sampleCenter.x += sample_uv.x * 2.;\n    sampleCenter.y += sample_uv.y * 4.;\n    \n    float queueHead = mod(step, .25 * iChannelResolution[1].x);\n\n    vec2 sampleLookup = 5.55 * sqrtNumSamples * (vec2(1., invap) * uv - vec2(.1, .105) );\n    \n\n    vec2 sample_uv_dims = 60./iChannelResolution[1].xy;    \n    if (in_box_range(sampleLookup, vec2(-r), vec2(r)) > .5)\n    {\n        vec2 lookup = sampleCenter + sampleLookup;\n        vec3 scol = texture(iChannel0, lookup/iChannelResolution[0].xy, -100.).rgb;\n        fcol = pow(scol, vec3(2.2));\n    }                             \n    else if (in_box_range(uv, vec2(.005, .02), vec2(.194, .355)) > .5)\n    {\n        // red border around scanning texture\n        fcol = vec3(1.,.2,.2);\n    } \n    else if (in_box_range(uv, vec2(.21, .03), vec2(.21+sample_uv_dims.x, .03+sample_uv_dims.y)) > .5)\n    {\n        // show the accumulated mean\n        fcol = vec3(texture(iChannel1, vec2((uv.x-.21) + .25,\n                                       (uv.y-.03)), -100.).r);\n    }\n    else if (in_box_range(uv, vec2(.208, .024), vec2(.212+sample_uv_dims.x, .034+sample_uv_dims.y)) > .5)\n    {\n        // yellow border around accumulated mean\n        fcol = vec3(1., 1., 0.);\n    }\n    \n    else if (in_box_range(uv, vec2(.34, .03), vec2(.34+sample_uv_dims.x, .03+sample_uv_dims.y)) > .5)\n    {\n        // show the accumulated standard deviation\n        fcol = vec3(sqrt(texture(iChannel1, vec2((uv.x-.34) + .25,\n                                       (uv.y-.03)), -100.).g));\n    }\n    else if (in_box_range(uv, vec2(.338, .024), vec2(.342+sample_uv_dims.x, .034+sample_uv_dims.y)) > .5)\n    {\n        // purple border around accumulated standard deviation\n        fcol = vec3(1., 0., 1.);\n    }\n    \n    if (uv.x > .5)\n    {\n        // show the noise texture\n        fcol = pow(texture(iChannel0, uv, -100.).rgb, vec3(2.2));\n        // show where it's being scanned\n        fcol += vec3(.5, .0, .0) * in_box_range(fragCoord.xy, \n                                                sampleCenter - vec2(r+1.), \n                                                sampleCenter + vec2(r)); \n        // add some drop shadow just because :)\n        fcol *= .7 + .3 * smoothstep(.5, .52, uv.x);\n    }\n    else if (uv.y > .2)\n    {\n        // display the mean and deviation as numbers\n        vec3 results = texture(iChannel1, vec2(queueHead, 0.)/iResolution.xy, -100.).rgb;\n        float average = results.r;\n        float stdDeviation = sqrt(results.g);\n        vec2 puv = uv;\n        puv *= 25.;\n        puv.x += .4;\n        puv.y += -22.2;\n        float p = smoothstep(.55,.6, puv.x) * smoothstep(.8,.75,puv.x) * smoothstep(-.05,0., puv.y) * smoothstep(.3,.25,puv.y); //period\n        fcol += vec3(1., 1., 0.) * (vec3(print_int(puv, 10000. * average)) + p);\n        puv.y += 11.5;\n        p = smoothstep(.55,.6, puv.x) * smoothstep(.8,.75,puv.x) * smoothstep(-.05,0., puv.y) * smoothstep(.3,.25,puv.y); //period\n        fcol += vec3(1., 0., 1.) * vec3(print_int(puv, 10000. * stdDeviation) + p);\n    }\n    \n    if (uv.x < .5)\n    {\n        // graph\n        vec2 graphUV = (fragCoord * vec2(.5,1.))/iChannelResolution[1].xy;\n        vec2 avgvar = texture(iChannel1, graphUV, -100.).rg;\n        avgvar.y = sqrt(avgvar.y);\n        \n        vec2 drawUV = vec2(1.,1.8) * (uv - vec2(0., .4)); \n        float avgGraph = smoothstep(avgvar.x-.01, avgvar.x, drawUV.y) * smoothstep(avgvar.x+.01, avgvar.x, drawUV.y);\n        float stdDevGraph = smoothstep(avgvar.y-.01, avgvar.y, drawUV.y) * smoothstep(avgvar.y+.01, avgvar.y, drawUV.y);\n                   \n        fcol += vec3(1., 1., 0.) * vec3(avgGraph);\n        fcol += vec3(1., 0., 1.) * vec3(stdDevGraph);\n        \n        vec3 lines = vec3(1.) * smoothstep(0.-.01, 0., drawUV.y) * smoothstep(0. + .01, 0., drawUV.y); // bottom\n        lines += vec3(1.) * smoothstep(1.-.01, 1., drawUV.y) * smoothstep(1. + .01, 1., drawUV.y); // top\n        lines += vec3(.3, .3, .0) * smoothstep(g_expected_mean-.005, g_expected_mean, drawUV.y) * smoothstep(g_expected_mean + .005, g_expected_mean, drawUV.y); // expected mean\n        lines += vec3(.3, .0, .3) * smoothstep(g_expected_std_deviation-.005, g_expected_std_deviation, drawUV.y) * smoothstep(g_expected_std_deviation + .005, g_expected_std_deviation, drawUV.y); // expected standard deviation\n        fcol += lines;\n    }  \n    \n    \n    //fcol = texture(iChannel1, uv, -100.).rgb;\n    fragColor = vec4(fcol,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// common uniformly distributed noise function used on shadertoy\nfloat nrand( vec2 n )\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\nfloat n1rand( vec2 n, float seed )\n{\n\tfloat nrnd0 = nrand( n + seed );\n\treturn nrnd0;\n}\n\n// --------------------------------------\n// from dave hoskins: https://www.shadertoy.com/view/4djSRW\n\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\nvec2 hash21(float p)\n{\n    vec3 p3 = fract(vec3(p) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n#define HASHSCALE1 .1031\nfloat hash12(vec2 p)\n{\n    vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n// --------------------------------------\n\nvoid mainImage( out vec4 fragColor, \n               \tin vec2 fragCoord )\n{\n \tvec2 uv = fragCoord.xy / iResolution.xy;\n    float invap = iResolution.y/iResolution.x;\n   \n    vec3 acol = vec3(n1rand(uv, 0.));\n    //acol = vec3(hash12(1000. * uv));\n    //acol = texture(iChannel1, 5. * vec2(1.,invap) * uv).rgb;\n    fragColor = vec4(acol,1.0);\n}\n","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"float g_scan_speed;\nfloat g_number_of_samples;\n\nconst float KEY_PLUS = 187.5/256.0;\nconst float KEY_MINUS = 189.5/256.0;\n\nfloat in_box_range(vec2 value, vec2 bottom, vec2 top)\n{\n    return step(value.x, top.x) * step(bottom.x, value.x) * step(value.y, top.y) * step(bottom.y, value.y);    \n}\n\nfloat in_pixel_range(vec2 value, vec2 pixel)\n{\n    return in_box_range(value, pixel, pixel + vec2(1.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    g_scan_speed = 20.; // update in buffer B and Image. messy!\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float invap = iResolution.y/iResolution.x;\n    \n    float s = texture(iChannel1, vec2(.5, 0.), -100.).b;\n    if (s < 1.) { s = 4.;}\n    if (texture( iChannel2, vec2(KEY_PLUS,0.0) ).x > .1) { s += 1.; }\n\tif (texture( iChannel2, vec2(KEY_MINUS,0.0) ).x > .1) { s -= 1.; }\n\n    s = clamp(s, 1., 12.);\n    \n    g_number_of_samples = 4.*s*s;    \n\n    vec3 bcol = vec3(0.);\n    \n    // shared logic in buffer B and image. messy!        \n    float sqrtNumSamples = floor(sqrt(g_number_of_samples)); \n    float r = floor(.5 * sqrtNumSamples);            \n    vec2 sampleCenter = floor(iChannelResolution[1].xy * vec2(.6, .1));\n    float step = floor(iTime * g_scan_speed);\n    vec2 sample_uv = vec2(mod(step, 60.), mod(floor(step/60.), 60.));\n    sampleCenter.x += sample_uv.x * 2.;\n    sampleCenter.y += sample_uv.y * 4.;\n    \n    float queueHead = mod(step, .25 * iChannelResolution[1].x);\n\n    float average = 0.;\n    float variance = 0.;\n\n    float currPixelIsSamplePixel = 0.;\n    \n    // find mean across 64 samples\n    for (float i = - r; i < r; i += 1.)\n    {\n        for (float j = - r; j < r; j += 1.)\n        {\n            vec2 currSample = sampleCenter + vec2(i, j) + .5;\n            vec2 currUV = currSample/iResolution.xy;\n            vec3 scol = texture(iChannel0, currUV, -100.).rgb;\n\n            average += scol.r;\n            if (in_pixel_range(fragCoord - vec2(r), vec2(i,j)) > .5)\n            {\n                bcol = scol;\n                currPixelIsSamplePixel = 1.;\n            }\n        }\n    }\n    \n    average /= g_number_of_samples;\n    \n    // based on that mean, take the variance\n    for (float i = - r; i < r; i += 1.)\n    {\n        for (float j = - r; j < r; j += 1.)\n        {\n            vec2 currSample = sampleCenter + vec2(i, j) + .5;\n            vec2 currUV = currSample/iResolution.xy;\n            vec3 scol = texture(iChannel0, currUV, -100.).rgb;\n\n            variance += (scol.r - average) * (scol.r - average);\n        }\n    }\n    variance /= g_number_of_samples;\n    \n    // store the results in buffer B\n    \n    bcol = texture(iChannel1, uv, -100.).rgb;\n        // blue channel saves s in number_of_samples = (2*s) * (2*s)\n    bcol.b = s;\n    if (in_pixel_range(fragCoord, vec2(queueHead,fragCoord.y)) > .5)\n    {\n        // save the recently scanned results in the first quarter of the buffer's\n        // x coordinate\n        bcol.r = average; \n        bcol.g = variance;\n    }   \n\n    if (in_pixel_range(fragCoord, vec2(sample_uv.x + .25 * iChannelResolution[1].x,\n                                       sample_uv.y)) > .5)\n    {\n        // save the accumulated scan across all 60 x 60 blocks in the buffer\n        // after the .25 * width pixels.\n        bcol.r = average; \n        bcol.g = variance;\n    }\n\n    fragColor = vec4(bcol,1.0);\n}","name":"Buf B","description":"","type":"buffer"}]}