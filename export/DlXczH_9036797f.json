{"ver":"0.1","info":{"id":"DlXczH","date":"1690392913","viewed":66,"name":"Numeric Cubic Solver Test","username":"Envy24","description":"Checking new root finding routines form:\nhttps://www.shadertoy.com/view/clfyRH\nhttps://www.shadertoy.com/view/dlsyzn\nBetter use deflation as in Cubic Solvers shader.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["approximation","solver","cubic","newton","raphson","halley","numeric","secant","regulafalsi"],"hasliked":0,"parentid":"ssKBRD","parentname":"Cubic Solvers"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                           iResolution\n#define AR                        ( R.x / R.y )                      // Aspect ratio (AR > 1.0).\n#define TO_CENTERED_NDC(SC)       ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define UNIT                      (  6.0 / R.y  )\n#define SM(x)                     ( smoothstep(UNIT, 0., x) )\n#define LMB_IS_HOLD               ( iMouse.z > 0.0 )\n\nfloat diskSDF_L2(vec2 NDC, vec2 C, float R)\n{\n    return length(C - NDC)-R;\n}\n\nfloat x_axis(vec2 NDC) { return SM(abs(NDC.x)); }\nfloat y_axis(vec2 NDC) { return SM(abs(NDC.y)); }\nfloat cubic(vec2 NDC, float a, float b, float c, float d)\n{\n    float df   = NDC.y - (((a * NDC.x  + b) * NDC.x + c) * NDC.x + d),\n          dfdx = (3.0 * a * NDC.x + 2.0 * b) * NDC.x + c;\n    return SM(abs(df) / sqrt(1.0 + dfdx * dfdx));\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = \n        //LMB_IS_HOLD ?\n            //2.*TO_CENTERED_NDC(SC-(iMouse.xy-R.xy*0.5)) :\n            2.*TO_CENTERED_NDC(SC);\n\n    //float a = 0.8, b = 1.4, c = 0.8, d = 0.1;\n    float Time = iTime;\n    /* Cubic */\n    float a = sinOSC(-1.25, 1.25, Time * 0.15), b = sinOSC( -2.0,  2.0, Time * 0.6), \n          c = sinOSC( -1.0,  1.0, Time * 0.45), d = sinOSC( -1.0,  1.0, Time * 0.25);\n    /* Quadratic *\n    float a =                               0.0, b = sinOSC( -2.0,  2.0, iTime * 0.6), \n          c = sinOSC( -1.0,  1.0, iTime * 0.45), d = sinOSC( -1.0,  1.0, iTime * 0.25);\n    /* Linear *\n    float a =                               0.0, b =                               0.0,\n          c = sinOSC( -1.0,  1.0, iTime * 0.45), d = sinOSC( -1.0,  1.0, iTime * 0.25);\n    /* Identity 0 == 0 *\n    float a =                               0.0, b =                              0.0,\n          c =                               0.0, d =                              0.0;\n    /**/\n\n    // Cauchy's roots bounds.\n    float upper_bound = max(0.0, 1.0 + max(-a/a, max(-b/a, max(-c/a, -d/a))));\n    float lower_bound = max(0.0, 1.0 + max( a/a, max( b/a, max( c/a,  d/a))));\n\n    vec3 color = (NDC.x <= upper_bound && NDC.x >= -lower_bound) ? vec3(.9,.9,.9) : vec3(1.);\n         color -= cubic(NDC, a, b, c, d);\n         color -= x_axis(NDC); color -= y_axis(NDC);\n\n    vec2 roots[3];\n      \n    // Numeric solvers.\n    int num = solve3n(roots, -lower_bound, upper_bound, a, b, c, d);\n\n    for (int r=0; r < num; ++r) \n    {\n        float x = roots[r].x;\n        color = mix(color, vec3(1, 0, 0), SM(diskSDF_L2(NDC, vec2(x, 0.0), 0.03)));\n    }\n\n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\n// source: https://www.youtube.com/watch?v=ok0EZ0fBCMA\nint solveQuadraticForReal(\n    inout vec2[2] roots,\n    float a, float b, float c)\n{\n    float discriminant = b * b - 4.0 * a * c;\n    float sqrt_D = sqrt(discriminant);\n    float sign_b = b >= 0.? 1. : -1.;\n    roots[1].x = -(b + sign_b*sqrt_D) / (2.*a);\n    roots[0].x = -(2.*c) / (b+sign_b*sqrt_D);\n    \n    return \n        discriminant < 0.0 ? // No real roots?\n        0 : 2;\n}\n\nfloat gs(float x) { return x >= 0. ? 1. : -1.; } // get_sign\nfloat findCubicRootNRB2(\n    float x_min,\n    float x_max,\n    float a,\n    float b,\n    float c,\n    float d)\n{\n    /* If you have troubles try to decrease tolerance */\n    const float tolerance = 1e-6; /* Desired precision. */\n    \n    // Data to track.\n    float x = x_min + (x_max - x_min) * 0.5,\n          y0 = ((a * x_min + b) * x_min + c) * x_min + d,\n          deriv = (3. * a * x + 2. * b) * x + c,\n          y = 9e5;\n\n    const int max_num_of_steps = 32;\n    for (int i = 0; i < max_num_of_steps; i++)\n    {                    \n        // Close enough?\n        if (abs(y) <= tolerance) { break; }\n        \n        // Make Newton-Raphson step.\n        x -= y / deriv;\n        \n        // Failed Newton-Raphson step?\n        if (x < x_min || x > x_max) // x step outside search range?\n        {\n            // Make bisection step.\n            x = x_min + (x_max - x_min) * 0.5;\n            \n            // Eval polynomial at new guess.\n            y = ((a * x + b) * x + c) * x + d;\n            \n            // Update bounds\n            if (gs(y0) == gs(y)) { x_min = x; }\n            else { x_max = x; }\n            \n            // Choose middle of new interval as new root guess.\n            x = x_min + (x_max - x_min) * 0.5;\n        }\n        else\n        {\n            // Eval polynomial and derivative at new guess.\n            y = ((a * x + b) * x + c) * x + d;\n            deriv = (3. * a * x + 2. * b) * x + c;\n            \n            // Update bounds.\n            if (gs(y0) == gs(y)) { x_min = x; }\n            else { x_max = x; }\n        }\n    }\n    \n    return x;\n}\nfloat findCubicRootNRB(\n    float x_min,\n    float x_max,\n    float a,\n    float b,\n    float c,\n    float d)\n{\n    /* If you have troubles try to decrease tolerance */\n    const float tolerance = 1e-5; /* Desired precision. */\n    const float EPSILON = 1e-9;  /* Treshold for infinitly small values. */\n    \n    // Data to track.\n    float x = x_min + (x_max - x_min) * 0.5,\n          prev_x = x,\n          y0 = ((a * x_min + b) * x_min + c) * x_min + d,\n          y1 = ((a * x + b) * x + c) * x + d,\n          y2 = ((a * x_max + b) * x_max + c) * x_max + d,\n          deriv = (3. * a * x + 2. * b) * x + c,\n          y = 9e5;\n\n    const int max_num_of_steps = 32;\n    for (int i = 0; i < max_num_of_steps; i++)\n    {            \n        y = ((a * x + b) * x + c) * x + d;\n             \n        if ((abs(y) <= tolerance) || // Close enough?\n            (abs(deriv) <= EPSILON)) { break; }\n\n        // Make Newton-Raphson step.\n        x -= y / deriv;  \n        \n        // Failed Newton-Raphson step?\n        if (x < x_min || x > x_max || // x step otside search range?\n            gs(y1) != gs(y) ||        // x now from other side of curve?\n            prev_x > x)               // step back?\n        {\n            // Make bisection step.\n            x = x_min + (x_max - x_min) * 0.5;\n            y = ((a * x + b) * x + c) * x + d;\n            \n            // Update bounds\n            if (gs(y0) == gs(y)) { x_min = x; }\n            else { x_max = x; }      \n        }  \n        deriv = (3. * a * x + 2. * b) * x + c;\n        prev_x = x;\n    }\n    \n    // Not neccerealy needed (and can cause problems).\n    x = x >= x_min && x <= x_max ? x : 9e5;\n    x = abs(y) < tolerance ? x : 9e5;\n    \n    return x;\n}\n\nbool is_valid_interval(float yl, float yr)\n{\n    return gs(yl) != gs(yr);\n}\n\n/* \n    Returns number of real roots.       \n*/\nint solve3n(\n    inout vec2[3] roots,\n    float lb, float ub, // lower and upper bounds\n    float a, float b, float c, float d)\n{\n    // Cubic equation?\n    if (a != 0.0)\n    {\n        // Find roots of derivatives.\n        vec2 droots[2];\n        int n = solveQuadraticForReal(droots, 3.*a, 2.*b, c);\n        \n        // If no real roots than function have only one root.\n        if (n == 0) \n        { \n            // Try to find root over all bound interval.\n            float x = findCubicRootNRB(lb, ub, a, b, c, d),\n                  y = ((a * x + b) * x + c) * x + d;\n            \n            // Valid root found?\n            if (abs(y) <= 1e-5)\n            {\n                roots[0].x = x;\n                return 1;\n            }\n            \n            return 0;\n        }\n        // Need to sort roots?\n        if (droots[0].x > droots[1].x) \n        { \n            float t= droots[0].x;\n            droots[0].x = droots[1].x;\n            droots[1].x = t;\n        }\n        // We have 1 or 3 roots, so let's isolate them.\n        float ys[4], xs[4];\n              xs[0] = lb; xs[1] = droots[0].x; xs[2] = droots[1].x; xs[3] = ub;\n              ys[0] = ((a * xs[0] + b) * xs[0] + c) * xs[0] + d,\n              ys[1] = ((a * xs[1] + b) * xs[1] + c) * xs[1] + d,\n              ys[2] = ((a * xs[2] + b) * xs[2] + c) * xs[2] + d,\n              ys[3] = ((a * xs[3] + b) * xs[3] + c) * xs[3] + d;        \n        // Check each intervals.\n        int num = 0;\n        for (int i = 0; i < 3; ++i)\n        {\n            // Can find root at interval?\n            if (is_valid_interval(ys[i], ys[i+1]) == true)\n            {\n                roots[num].x = findCubicRootNRB2(xs[i], xs[i+1], a, b, c, d);         \n                ++num;\n            }\n        }\n\n        return num;\n    }\n    \n    // Quadratic equation?\n    if (b != 0.0)\n    {\n        vec2 roots_[2];\n\n        int num = solveQuadraticForReal(roots_, b, c, d);\n\n        roots[0] = roots_[0]; roots[1] = roots_[1];\n        \n        return num;\n    }\n\n    // Linear equation?\n    if (c != 0.0)\n    {\n        // Solve linear equation.\n        roots[0].x = -d/c; roots[0].y = 0.0;\n\n        return 1;\n    }\n\n    // Identity 0 == 0? Infinitely many roots?\n    if (d == 0.0) \n    { \n        // Pick zero root.\n        roots[0].x = 0.0; roots[0].y = 0.0;\n\n        return 1;\n    }\n    \n    return 0;\n}","name":"Common","description":"","type":"common"}]}