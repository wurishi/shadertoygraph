{"ver":"0.1","info":{"id":"43cGW7","date":"1716532977","viewed":32,"name":"phone light","username":"pozhu15","description":"phone light","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["phonelight"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n\nfloat sphereSDF(vec3 samplePoint) {\n    return length(samplePoint) - 1.0;\n}\n\nfloat cubeSDF(vec3 p) {\n    vec3 d = abs(p) - vec3(1.0, 1.0, 1.0);\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    float outsideDistance = length(max(d, 0.0));\n    return insideDistance + outsideDistance;\n}\n\nfloat sceneSDF(vec3 samplePoint) {\n\n    float sphereDist = sphereSDF(samplePoint *0.8) ;\n    float cubeDist = cubeSDF(samplePoint);\n    float a= intersectSDF(cubeDist, sphereDist);\n    float b= unionSDF(cubeDist, sphereDist);\n    float c= differenceSDF(cubeDist, sphereDist);\n    float k= sin(iTime);\n    float m= c-a+b;\n    float result=m;\n    if(k<0.e-6){\n        result= -k*m+(1.0+k)*sphereDist;\n    }else{\n        result= k*sphereDist+(1.0-k)*m;\n    }\n    return result;\n}\n\n\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n\nvec3 phongLight(vec3 fragPos,\n        vec3 normal,\n        vec3 ambientColor,\n        vec3 diffuseColor,\n        vec3 specularColor,\n        float specularPower,\n        vec3 lightColor,\n        vec3 lightPos,\n        vec3 cameraPos){\n    vec3 ambientC = ambientColor*0.5*diffuseColor;\n\n    vec3 diffuseC = lightColor*dot(normalize(lightPos-fragPos),normal);\n    //Phong\n    vec3 specularC = specularColor*pow(max(0.,dot(reflect(normalize(fragPos-lightPos),normal),normal)),specularPower);\n    //Blinn-Phong\n    specularC = diffuseColor*pow(max(0.,dot(normalize(normalize(lightPos-fragPos)+normalize(cameraPos-fragPos)),normal)),specularPower);\n    \n    return (ambientC+diffuseC+specularC)*diffuseColor;\n}\n// speed of ROTATION\n#define ROTATION_SPEED 0.8999\n#define tshift 53.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);  \n    vec3 eye = vec3(8.0, 5.0, 7.0);     \n\n    ////mouse control Camera\n    float mouseY = 1.0 * 0.5 * PI;\n\n    mouseY = (1.0 - 1.15 * iMouse.y / iResolution.y) * 0.5 * PI;\n    if(iMouse.y < 1.)\n        mouseY = PI*0.49 - smoothstep(0.,8.5,mod((iTime+tshift)*0.33,25.))*(1.-smoothstep(14.,24.0,mod((iTime+tshift)*0.33,25.))) * 0.55 * PI;\n\n    float mouseX = -2.*PI-0.25*(iTime*ROTATION_SPEED+tshift);\n    mouseX+=-(iMouse.x / iResolution.x) * 2. * PI;\n    \n    vec3 eye2 = 4. * vec3(cos(mouseX) * cos(mouseY), sin(mouseX) * cos(mouseY), sin(mouseY));\n\n    vec3 w = normalize(-eye2);\n    vec3 up = vec3(0., 0., 1.);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = cross(u, w);\n    /////\n\n    mat4 viewToWorld = viewMatrix2(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0)); \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;     \n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);  \n\n    vec3 position = eye+worldDir*dist;\n    vec3 normal = estimateNormal(position);\n    \n\n    //skybox\n    vec2 uv=(fragCoord-0.5*iResolution.xy)/iResolution.y; \n    vec4 s=vec4(0.,0.,2.,1.);  \n    float t=iTime*.5;\n    vec3 cam_pos=s.xyz+vec3(sin(t),0.,cos(t))*5.;\n    vec3 cam_dir=normalize(s.xyz-cam_pos);\n    vec3 cam_r=-cross(cam_dir,vec3(0,1,0));\n    vec3 cam_u=-cross(cam_r,cam_dir);\n    vec3 r=normalize(uv.x*cam_r+uv.y*cam_u+1.*cam_dir);\n\n    // r= normalize();\n\n    if (dist > MAX_DIST - EPSILON) {    \n        // Didn't hit anything\n        fragColor =texture(iChannel0,r);\n\t\treturn;\n    }\n    \n    vec3 K_a = vec3(0.2, 0.2, 0.2);\n    vec3 K_d = vec3(0.7, 0.7, 0.2);\n    vec3 K_s = vec3(0.0, 1.0, 1.0);\n    float shininess = 10.0;\n    vec3 lightPosition = vec3(2.0 ,2.0, 7.0);\n    vec3 lightColor = vec3(1., 1.0, 1.0);\n    \n    vec3 phoneColor = phongLight(position,\n        normal,\n        K_a,            //ambientColor\n        K_d,            //diffuseColor\n        K_s,            //specularColor\n        shininess,      //specularPower\n        lightColor,         //lightColor\n        lightPosition,      //lightDir\n        eye);    //cameraPos\n    fragColor = vec4(phoneColor, 1.0);\n\n    \n\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = 3.14159;\n\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;  //\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat4 viewMatrix2(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n","name":"Common","description":"","type":"common"}]}