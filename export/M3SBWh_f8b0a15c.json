{"ver":"0.1","info":{"id":"M3SBWh","date":"1731271679","viewed":41,"name":"table avec un échiquier","username":"lindoush","description":"parie sur la modélisation avancée pour faire une image complexe. ","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["tp"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Modeling - 2024.09.15\n// Eric Galin\n\nstruct Ray{\n    vec3 o;// Origin\n    vec3 d;// Direction\n};\n\nstruct Val {\n  float v; // Signed distance\n  int c; // Cost\n  int type; // Type of object: 0 = Sphere, 1 = plane\n};\n\n// Compute point on ray\n// ray : The ray\n//   t : Distance\nvec3 Point(Ray ray,float t)\n{\n    return ray.o+t*ray.d;\n}\n\n// Random direction in a hemisphere\n// seed : Integer seed, from 0 to N\n//    n : Direction of the hemisphere\nvec3 Hemisphere(int seed,vec3 n)\n{\n    float a=fract(sin(176.19*float(seed)));// Uniform randoms\n    float b=fract(sin(164.19*float(seed)));\n    \n    float u=2.*3.1415*a;// Random angle\n    float v=acos(2.*b-1.);// Arccosine distribution to compensate at poles\n    \n    vec3 d=vec3(cos(u)*cos(v),sin(u)*cos(v),sin(v));// Direction\n    if(dot(d,n)<0.){d=-d;}// Hemisphere\n    \n    return d;\n}\n\n// Camera -------------------------------------------------------------------------------\n\n// Rotation matrix around z axis\n// a : Angle\nmat3 Rz(float a)\n{\n  float sa=sin(a);float ca=cos(a);\n  return mat3(ca,sa,0.,-sa,ca,0.,0.,0.,1.);\n}\n\n\n// Translate a point\n// p : the point to translate\n// t : translation vector\nvec3 Translate(vec3 p, vec3 t) {\n    return p - t;\n}\n\n// Scale (Homothety)\n// p : the point to scale\n// s : scaling factor (can be a vector for non-uniform scaling)\nvec3 Scale(vec3 p, vec3 s) {\n    return p / s;\n}\n\n// Rotate around X axis\n// p : the point to rotate\n// a : angle (in radians) to rotate around the X-axis\nvec3 RotateX(vec3 p, float a) {\n    float sa = sin(a); \n    float ca = cos(a);\n    return vec3(p.x, ca * p.y - sa * p.z, sa * p.y + ca * p.z);\n}\n\n// Rotate around Y axis\n// p : the point to rotate\n// a : angle (in radians) to rotate around the Y-axis\nvec3 RotateY(vec3 p, float a) {\n    float sa = sin(a); \n    float ca = cos(a);\n    return vec3(ca * p.x + sa * p.z, p.y, -sa * p.x + ca * p.z);\n}\n\n// Rotate around Z axis\n// p : the point to rotate\n// a : angle (in radians) to rotate around the Z-axis\nvec3 RotateZ(vec3 p, float a) {\n    float sa = sin(a); \n    float ca = cos(a);\n    return vec3(ca * p.x - sa * p.y, sa * p.x + ca * p.y, p.z);\n}\n\n// Transform a point with translation, scaling (homothety), and rotation\n// p : the point to transform\n// t : translation vector\n// s : scaling vector (non-uniform scaling possible)\n// r : rotation angles for X, Y, and Z axes (in radians)\nvec3 Transform(vec3 p, vec3 t, vec3 s, vec3 r) {\n    p = Translate(p, t);\n    p = Scale(p, s);\n    p = RotateX(p, r.x);\n    p = RotateY(p, r.y);\n    p = RotateZ(p, r.z);\n    return p;\n}\n\n// Compute the ray\n//      m : Mouse position\n//      p : Pixel\nRay CreateRay(vec2 m,vec2 p)\n{\n  float a=3.*3.14*m.x;\n  float le=3.5;\n  \n  // Origin\n  vec3 ro=vec3(37.,0.,15.);\n  ro*=Rz(a);\n  \n  // Target point\n  vec3 ta=vec3(0.,0.,1.);\n  \n  // Orthonormal frame\n  vec3 w=normalize(ta-ro);\n  vec3 u=normalize(cross(w,vec3(0.,0.,1.)));\n  vec3 v=normalize(cross(u,w));\n  vec3 rd=normalize(p.x*u+p.y*v+le*w);\n  return Ray(ro,rd);\n}\n\n\n// Texture --------------------------------------------------------------------------------------\n\n// Hashing function\n// Returns a random number in [-1,1]\n// p : Vector in space\nfloat Hash(in vec3 p)  \n{\n    p  = fract( p*0.3199+0.152 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\n// Procedural value noise with cubic interpolation\n// p : Point \nfloat Noise(in vec3 p)\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n  \n    f = f*f*(3.0-2.0*f);\n    // Could use quintic interpolation instead of cubic\n    // f = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    return mix(mix(mix( Hash(i+vec3(0,0,0)), \n                        Hash(i+vec3(1,0,0)),f.x),\n                   mix( Hash(i+vec3(0,1,0)), \n                        Hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( Hash(i+vec3(0,0,1)), \n                        Hash(i+vec3(1,0,1)),f.x),\n                   mix( Hash(i+vec3(0,1,1)), \n                        Hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\n// turbulence (somme de fonctions de bruit) pour perturber la surface\n// p : Point \nfloat Turbulence(vec3 p)\n{\n    float deformation = 0.0;\n    \n    deformation += 1.0 * Noise(p / 2.0);   \n    deformation += 0.5 * Noise(p / 1.0);  \n    deformation += 0.25 * Noise(p / 0.5);  \n\n    deformation /= 12.6;  // pour lisser un peu \n    \n    return deformation;\n}\n\n// Wood\n// p : point\nvec3 Wood(vec3 p) {\n    vec3 q = p + 0.2 * Turbulence(p);\n    float r = 0.5 * (1.0 + sin(length(q.xy) * 8.0)); \n    return mix(vec3(0.4, 0.2, 0.1), vec3(0.8, 0.6, 0.3), r); \n}\n\n// Checker\n// p : point\nint Checker(vec3 p) {\n    float size = 1.5;  \n    float checkerPattern = mod(floor(p.x / size) + floor(p.y / size) + floor(p.z / size), 2.0);\n    return int(checkerPattern); \n}\n\n\n// Primitives -------------------------------------------------------------------------------\n\n// Operators\n\n// Union\n// a,b : field function of left and right sub-trees\nVal Union(Val a, Val b) {\n    if (a.v < b.v) {\n        return Val(a.v, a.c + b.c + 1, a.type); \n    } else {\n        return Val(b.v, a.c + b.c + 1, b.type); \n    }\n}\n\n\n// Sphere\n// p : point\n// c : center of skeleton\n// r : radius\nVal Sphere(vec3 p,vec3 c,float r)\n{\n  return Val(length(p-c)-r,1,0);\n}\n\n// Plane \n// p : point\n// n : Normal of plane\n// o : Point on plane\nVal Plane(vec3 p, vec3 n, vec3 o)\n{\n    return Val(dot((p-o),n),1,1);\n}\n\n// Box\n// p : point to test\n// c : center of the box\n// r : half-extents (size in each direction from the center) of the box\nVal Box(vec3 p, vec3 c, vec3 r) {\n    vec3 d = abs(p - c) - r;\n    return Val(length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0), 1, 2);\n}\n\n// BoundingBox\n// p : point à tester\n// minCorner : coin minimum de la boîte englobante\n// maxCorner : coin maximum de la boîte englobante\nVal BoundingBox(vec3 p, vec3 minCorner, vec3 maxCorner) {\n    vec3 d = max(minCorner - p, p - maxCorner);  \n    float dist = length(max(d, 0.0));  \n    return Val(dist, 1, 3);  \n}\n\n\n// Cylinder\n// p : point to test\n// c : center of the base of the cylinder (position)\n// r : radius of the cylinder\n// h : height of the cylinder (along the Y axis)\nVal Cylinder(vec3 p, vec3 c, float r, float h) {\n    vec2 d = abs(vec2(length(p.xz - c.xz), p.y - c.y)) - vec2(r, h);  \n    return Val(min(max(d.x, d.y), 0.0) + length(max(d, 0.0)), 7, 4); \n}\n\n// Rook\n// p : point to test\n// c : position of the rook\nVal Rook(vec3 p, vec3 position)\n{\n    Val base = Cylinder(p, position, 0.3, 0.25);  \n    Val middle = Cylinder(p - vec3(0.0, 0.0, 0.5), position, 0.3, 0.11);  \n    Val top = Cylinder(p - vec3(0.0, 0.0, 0.9), position, 0.2, 0.1); \n\n    Val rook = Union(base, middle);\n    rook = Union(rook, top);\n\n    return rook;\n}\n\n\n\n// Potential field of the object\n// p : point\nVal object(vec3 p)\n{\n    vec3 centerChessboard = vec3(0.0, 0.0, 4.0);\n    vec3 halfSizeChessboard = vec3(6.0, 6.0, 0.1); \n    Val chessboard = Box(p, centerChessboard, halfSizeChessboard);\n\n    vec3 rotatedTable = RotateX(p - vec3(0.0, 0.0, 3.7), radians(90.0)); \n    Val table = Cylinder(rotatedTable, vec3(0.0, 0.0, 0.0), 10.0, 0.3); \n\n   \n    vec3 rotatedFootPos1 = RotateX(p - vec3(-5.0, -5.0, -6.0), radians(90.0));\n    Val foot1 = Cylinder(rotatedFootPos1, vec3(0.0), 1.3, 9.); \n\n    vec3 rotatedFootPos2 = RotateX(p - vec3(5.0, -5.0, -6.0), radians(90.0));\n    Val foot2 = Cylinder(rotatedFootPos2, vec3(0.0), 1.3, 9.); \n\n    vec3 rotatedFootPos3 = RotateX(p - vec3(-5.0, 5.0, -6.0), radians(90.0));\n    Val foot3 = Cylinder(rotatedFootPos3, vec3(0.0), 1.3, 9.); \n\n    vec3 rotatedFootPos4 = RotateX(p - vec3(5.0, 5.0, -6.0), radians(90.0));\n    Val foot4 = Cylinder(rotatedFootPos4, vec3(0.0), 1.3, 9.);  \n\n\n    Val v = Union(table, foot1);\n    v = Union(v, foot2);\n    v = Union(v, foot3);\n    v = Union(v, foot4);\n    \n    Val rook = Rook(p, vec3(-1.0, -5.4, 4.4)); \n    v = Union(v, rook);\n    \n    Val rook2 = Rook(p, vec3(-2.0, -1.0, 4.4)); \n    v = Union(v, rook2);\n    \n    Val rook3 = Rook(p, vec3(2.0, -1.0, 4.4)); \n    v = Union(v, rook3);\n    \n    Val rook4 = Rook(p, vec3(5.0, 2.0, 4.4)); \n    v = Union(v, rook4);\n    \n    Val rook5 = Rook(p, vec3(-5.0, 4.0, 4.4)); \n    v = Union(v, rook5);\n    \n    Val rook6 = Rook(p, vec3(-0.8, 5.0, 4.4)); \n    v = Union(v, rook6);\n\n    v = Union(v, chessboard);\n\n    return v;\n}\n\n\n\n\n// Analysis of the scalar field -----------------------------------------------------------------\n\nconst int Steps=200;// Number of steps\nconst float Epsilon=.01;// Marching epsilon\n\n// Object normal\n// p : point\nvec3 ObjectNormal(vec3 p)\n{\n  const float eps=.001;\n  vec3 n;\n  Val val=object(p);\n  float v=val.v;\n  n.x=object(vec3(p.x+eps,p.y,p.z)).v-v;\n  n.y=object(vec3(p.x,p.y+eps,p.z)).v-v;\n  n.z=object(vec3(p.x,p.y,p.z+eps)).v-v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// ray : The ray\n//   e : Maximum distance\n//   h : hit\n//   s : Number of steps\n//   c : cost\nbool SphereTrace(Ray ray,float e,out float t,out int s,out int c)\n{\n  bool h=false;\n  \n  // Start at the origin\n  t=0.0;\n  c=0;\n  \n  for(int i=0;i<Steps;i++)\n  {\n    s=i;\n    vec3 p=Point(ray,t);\n    Val val=object(p);\n    float v=val.v;\n    c+=val.c;\n    // Hit object\n    if(v<0.)\n    {\n      h=true;\n      break;\n    }\n    // Move along ray\n    t+=max(Epsilon,v);\n    // Escape marched too far away\n    if(t>e)\n    {\n      break;\n    }\n  }\n  return h;\n}\n\n// Lighting -------------------------------------------------------------------------------\n\n// Background color\n// ray : Ray \nvec3 background(Ray ray)\n{\n  return mix(vec3(0.9, 0.8, 0.95), vec3(0.6, 0.85, 0.9), ray.d.z * 0.5 + 0.5);\n}\n\n\n// Shadowing\n// p : Point\n// n : Normal\n// l : Light direction\nfloat Shadow(vec3 p,vec3 n,vec3 l)\n{\n  float t;\n  int s;\n  int c;\n  bool hit=SphereTrace(Ray(p+Epsilon*n,l),100.,t,s,c);\n  if(!hit)\n  {\n    return 1.;\n  }\n  return 0.;\n}\n\n\n// Shading and lighting\n//   p : Point\n//   n : Normal at point\n// eye : Eye direction\n// Shade function with less light impact on the checkerboard\nvec3 Shade(vec3 p, vec3 n, Ray eye, int type)\n{\n    // Point light\n    const vec3 lp = vec3(5., 10., 25.);\n\n    // Light direction to point light\n    vec3 l = normalize(lp - p);\n\n    // Ambient color\n    vec3 ambient = .25 + .25 * background(Ray(p, n));\n\n    // Shadow computation\n    float shadow = Shadow(p, n, l);\n\n    vec3 surfaceColor;\n\n    if (type == 2) { \n        if (Checker(p) == 0) {\n            surfaceColor = vec3(1.0, 1.0, 1.0);  \n        } else {\n            surfaceColor = vec3(0.0, 0.0, 0.0); \n        }\n        return surfaceColor;  \n    } else if (type == 4) { \n        surfaceColor = Wood(p);      \n    }\n    \n    // Phong diffuse\n    vec3 diffuse = .35 * clamp(dot(n, l), 0., 1.) * surfaceColor;\n\n    // Specular\n    vec3 r = reflect(eye.d, n);\n    vec3 specular = .15 * pow(clamp(dot(r, l), 0., 1.), 35.) * vec3(1., 1., 1.);\n\n    return ambient + shadow * (diffuse + specular);\n}\n\n\n\n// Shading according to the number of steps in sphere tracing\n// n : Number of steps\nvec3 ShadeSteps(int n,int m)\n{\n  float t=float(n)/(float(m));\n  return.5+mix(vec3(.05,.05,.5),vec3(.65,.39,.65),t);\n}\n\n\nvoid mainImage(out vec4 color,in vec2 pxy)\n{  \n  // Convert pixel coordinates\n    vec2 pixel=(-iResolution.xy+2.*pxy)/iResolution.y;\n\n  // Mouse\n  vec2 m=iMouse.xy/iResolution.xy;\n  \n  // Camera\n  Ray ray=CreateRay(m,pixel);\n  \n  // Trace ray\n  \n  // Hit and number of steps\n  float t=0.0;\n  int s=0;\n  int c;\n  bool hit=SphereTrace(ray,100.,t,s,c);\n  \n  // Shade background\n  vec3 rgb=background(ray);\n  \n  if(hit)\n  {\n    // Position\n    vec3 p=Point(ray,t);\n    \n    // Compute normal\n    vec3 n=ObjectNormal(p);\n    \n    Val val = object(p);\n        \n    // Shade object with light\n    rgb=Shade(p,n,ray,val.type);\n    \n    \n     // Check if the type of an object\n     if (val.type == 4) {  \n            rgb = Wood(p); \n     } \n   }\n\n  color=vec4(rgb,1.);\n}\n\n","name":"Image","description":"","type":"image"}]}