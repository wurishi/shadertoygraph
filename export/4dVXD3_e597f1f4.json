{"ver":"0.1","info":{"id":"4dVXD3","date":"1469326191","viewed":247,"name":"Tilt Lens Demo","username":"soma_arc","description":"Tilt lens effect demo.\nFocal plane is perpendicular to floor.\nIf you set tiltRad = radians(41.2), focal plane is parallel to floor.\nReference: Simulating Depth of Field Effects Taken by a Camera with a Tilt-Shift Lens","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","tiltlens"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nCreated by soma_arc - 2016\nThis work is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported.\n*/\n\n\n// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(vec2 co, float sampleIndex) {\n    vec2 seed = co * (sampleIndex + 1.0);\n\tseed+=vec2(-1,1);\n    // implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n    return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nvec3 rotate(vec3 p, float angle, vec3 axis){\n  vec3 a = normalize(axis);\n  float s = sin(angle);\n  float c = cos(angle);\n  float r = 1.0 - c;\n  mat3 m = mat3(\n      a.x * a.x * r + c,\n      a.y * a.x * r + a.z * s,\n      a.z * a.x * r - a.y * s,\n      a.x * a.y * r - a.z * s,\n      a.y * a.y * r + c,\n      a.z * a.y * r + a.x * s,\n      a.x * a.z * r + a.y * s,\n      a.y * a.z * r - a.x * s,\n      a.z * a.z * r + c\n  );\n  return m * p;\n}\n\nconst float PI = 3.14159265359;\nconst float PI_2 = PI/2.;\nconst float EPSILON = 0.001;\nconst int MTL_SPHERE = 1;\nconst int MTL_PLANE = 2;\nint g_mtl = -1;\n\nvec4 intersectSphere(vec3 sphereCenter, float radius, \n                      vec3 rayOrigin, vec3 rayDir, vec4 isect){\n\tvec3 v = rayOrigin - sphereCenter;\n    float b = dot(rayDir, v);\n    float c = dot(v, v) - radius * radius;\n    float d = b * b - c;\n    if(d >= 0.){\n        float s = sqrt(d);\n        float t = -b - s;\n        if(t <= EPSILON) t = -b + s;\n        if(EPSILON < t && t < isect.x){\n            vec3 p = (rayOrigin + t * rayDir);\n            g_mtl = MTL_SPHERE;\n            return vec4(t, normalize(p - sphereCenter));\n        }\n    }\n    return isect;\n}\n\nvec4 intersectPlane(vec3 p, vec3 n, \n                    vec3 rayOrigin, vec3 rayDir, vec4 isect){\n    float d = -dot(p, n);\n    float v = dot(n, rayDir);\n    float t = -(dot(n, rayOrigin) + d) / v;\n    if(EPSILON < t && t < isect.x){\n        g_mtl = MTL_PLANE;\n    \treturn vec4(t, n);\n    }\n    return isect;\n}\n\nvec4 intersectXYRect (vec2 p1, vec2 p2, float z,\n                      vec3 rayOrigin, vec3 rayDir, vec4 isect){\n\tfloat t = (z - rayOrigin.z) / rayDir.z;\n    if(EPSILON < t && t < isect.x){\n    \tvec3 p = rayOrigin + t * rayDir;\n        if(p1.x < p.x && p.x < p2.x &&\n           p1.y < p.y && p.y < p2.y ){\n\n        \treturn vec4(t, vec3(0, 0, 1));\n        }\n    }\n    return isect;\n}\n\nconst vec3 BLACK = vec3(0);\nvec3 spherePos = vec3(0, .5, 0);\nvec3 spherePos2 = vec3(5, .5, 0);\nvec3 spherePos3 = vec3(-5, .5, 0);\n\nfloat sphereR = .5;\nvec3 planeP = vec3(0, 0, 0);\nvec3 planeN = normalize(vec3(0, 1, 0));\n\nfloat lightVisibility(vec3 org, vec3 target){\n    vec3 v = target - org;\n    vec4 result = vec4(length(v));\n    for(int i = 0 ; i < 5 ; i++){\n        result = intersectSphere(spherePos + vec3(0, i * 1, 0), sphereR, org, normalize(v), result);\n        if(result.x < length(v)) return 0.;\n        result = intersectSphere(spherePos2 + vec3(0, i * 1, 0), sphereR, org, normalize(v), result);\n        if(result.x < length(v)) return 0.;\n        result = intersectSphere(spherePos3 + vec3(0, i * 1, 0), sphereR, org, normalize(v), result);\n        if(result.x < length(v)) return 0.;\n    }\n    result = intersectPlane(planeP, planeN, org, normalize(v), result);\n    if(result.x < length(v)) return 0.;\n\treturn 1.;\n}\n\nconst float PI_4 = 12.566368;\nconst vec3 LIGHTING_FACT = vec3(0.1);\nvec3 diffuseLighting(const vec3 p, const vec3 n, const vec3 diffuseColor,\n                     const vec3 lightPos, const vec3 lightPower){\n  \tvec3 v = lightPos - p;\n  \tfloat d = dot(n, normalize(v));\n  \tfloat r = length(v);\n  \treturn (d > 0. \n//            && lightVisibility(p, lightPos) == 1.\n           ) ?\n    \t(lightPower * (d / (PI_4 * r * r))) * diffuseColor\n    \t: vec3(0.);\n}\n\n\n\nconst vec3 lightPos = vec3(0, 6, 5);\nconst vec3 lightPower = vec3(100.);\n\nvec3 calcColor(vec3 eye, vec3 ray){\n  \tvec3 l = BLACK;\n  \tfloat coeff = 1.;\n    vec4 result = vec4(99999.);\n    for(int i = 0 ; i < 5 ; i++){\n        result = intersectSphere(spherePos + vec3(0, i * 1 , 0), sphereR, eye, ray, result);\n        result = intersectSphere(spherePos2+ vec3(0, i * 1, 0), sphereR, eye, ray, result);\n        result = intersectSphere(spherePos3+ vec3(0, i * 1, 0), sphereR, eye, ray, result);\n    }\n    result = intersectPlane(planeP, planeN, eye, ray, result);\n    \n    vec3 matColor = vec3(1.);\n  \t\n  \tif(result.x > 0.){\n    \tvec3 intersection = eye + ray * result.x;\n        if(g_mtl == MTL_PLANE){\n            float uu = 1.0 - floor(mod(intersection.x * 1./2., 2.0));\n\t\t\tfloat vv = 1.0 - floor(mod(intersection.z * 1./2., 2.0));\n\t\t\tif((uu == 1.0 && vv < 1.0) || (uu < 1.0 && vv == 1.0)){\n                    matColor = vec3(1, 0, 0);\n\t\t\t}\n        }\n        vec3 normal = result.yzw;\n   \t\tl += diffuseLighting(intersection, normal, matColor, lightPos, lightPower);\n    }\n  \treturn l;\n}\n\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nconst float DISPLAY_GAMMA_COEFF = 1. / 2.2;\nvec3 gammaCorrect(vec3 rgb) {\n\treturn vec3((min(pow(rgb.r, DISPLAY_GAMMA_COEFF), 1.)),\n                (min(pow(rgb.g, DISPLAY_GAMMA_COEFF), 1.)),\n                (min(pow(rgb.b, DISPLAY_GAMMA_COEFF), 1.)));\n}\n\nvec3 eye = vec3(1, 0.5, 1);\nconst vec3 up = vec3(0, 1, 0);\nfloat fov = radians(60.);\n\nvec3 calcRay (const vec3 eye, const vec3 target, const vec3 up, const float fov,\n              const float width, const float height, const vec2 coord){\n\tfloat imagePlane = (height * .5) / tan(fov * .5);\n  \tvec3 v = normalize(target - eye);\n \tvec3 focalXAxis = normalize(cross(v, up));\n  \tvec3 focalYAxis =  normalize(cross(v, focalXAxis ));\n  \tvec3 center = v * imagePlane;\n  \tvec3 origin = center - (focalXAxis * (width  * .5)) - (focalYAxis * (height * .5));\n  \treturn normalize(origin + (focalXAxis * coord.x) + (focalYAxis * (height - coord.y)));\n}\n\nvec3 calcRayWithLens (vec3 camPos, const vec3 target, const vec3 up, const float fov,\n              \t\t  const float width, const float height, const vec2 coord,\n                      const float lensR, const float sampleNum){\n\tfloat imagePlane = (height * .5) / tan(fov * .5);\n  \tvec3 v = normalize(target - camPos);\n    float focalDist = distance(camPos, target);\n \tvec3 focalXAxis = normalize(cross(v, up));\n  \tvec3 focalYAxis =  normalize(cross(v, focalXAxis ));\n  \tvec3 center = v * imagePlane;\n    vec3 origin = center - (focalXAxis * (width  * .5)) - (focalYAxis * (height * .5));\n  \tvec3 ray = normalize(origin + (focalXAxis * coord.x) + (focalYAxis * (height - coord.y)));\n    \n    vec2 jitter = lensR * 2. * (rand2n(vec2(1,2), sampleNum)- vec2(.5));\n    vec3 focus = camPos + ray * focalDist / dot(ray, v);\n    eye = camPos + jitter.x * focalXAxis + jitter.y * focalYAxis;\n\n\tray = normalize(focus - eye);\n\n    return ray;\n}\n\nvec3 calcRayWithLensTilt (vec3 camPos, const vec3 target, const vec3 up, const float fov,\n              \t\t  const float width, const float height, const vec2 coord,\n                      const float lensR, const float tiltRad,\n                      const float sampleNum){\n    float imagePlane = (height * .5) / tan(fov * .5);\n  \tvec3 v = normalize(target - camPos);\n    float focalDist = distance(camPos, target);\n    float lensTilt = atan((imagePlane + focalDist) * tan(tiltRad), imagePlane);\n \tvec3 focalXAxis = normalize(cross(v, up));\n  \tvec3 focalYAxis =  normalize(cross(v, focalXAxis ));\n  \tvec3 center = v * imagePlane;\n    vec3 origin = center - (focalXAxis * (width  * .5)) - (focalYAxis * (height * .5));\n  \tvec3 ray = normalize(origin +(focalXAxis * coord.x) + (focalYAxis * (height - coord.y)));\n\n    float focalTilt = PI_2 - tiltRad;\n    mat3 focalRotate = mat3(1, 0, 0,\n       \t\t\t\t\t0, cos(focalTilt), -sin(focalTilt),\n                        0, sin(focalTilt), cos(focalTilt));\n    v = rotate(v, -focalTilt, focalXAxis);\n    vec3 focus = camPos + ray * (focalDist * cos(focalTilt)) / dot(ray, v);\n    \n    vec2 jitter = lensR * 2. * (rand2n(vec2(1,2), sampleNum)- vec2(.5));\n    vec3 jitDir = (jitter.x * focalXAxis + jitter.y * focalYAxis);\n    mat3 jitRotate = mat3(1, 0, 0,\n       \t\t\t\t\t0, cos(lensTilt), -sin(lensTilt),\n                       0, sin(lensTilt), cos(lensTilt));\n    eye = camPos + rotate(jitDir, lensTilt, focalXAxis);;\n\n\tray = normalize(focus - eye);\n\n    return ray;\n}\n\nconst vec3 target = vec3(0., 0., 0);\nconst float SAMPLE_NUM = 30.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec4 sum = vec4(0);\n    const float lensR = 1.;\n    for(float i = 0. ; i < SAMPLE_NUM ; i++){\n        eye = vec3(0 , 9.8 * sin(radians(41.2)), 9.8 * cos(radians(41.2)));\n/*        \n        eye = vec3(9.8 * cos(radians(41.2)) * cos(iTime/2.) ,\n                   9.8 * sin(radians(41.2)), \n                   9.8 * cos(radians(41.2)) * sin(iTime/2.) );\n*/\n\n        vec2 coordOffset = rand2n(gl_FragCoord.xy, i);\n/*\n        vec3 ray = calcRay(eye, target, up, fov,\n    \t\t               iResolution.x, iResolution.y,\n        \t\t           gl_FragCoord.xy + coordOffset);\n*/\n/*\n        vec3 ray = calcRayWithLens(eye, target, up, fov,\n    \t\t               \t\t   iResolution.x, iResolution.y,\n        \t\t           \t\t   gl_FragCoord.xy + coordOffset,\n                                  lensR, i);\n*/\n\t\t//float tiltRad = radians(41.2);\n        float tiltRad = radians(-48.8);\n\n        \n        vec3 ray = calcRayWithLensTilt(eye, target, up, fov,\n    \t\t               \t\t   \t   iResolution.x, iResolution.y,\n        \t\t           \t\t       gl_FragCoord.xy + coordOffset,\n                                  \t   lensR, tiltRad,\n                                       i);\n        \n        sum += vec4(gammaCorrect(calcColor(eye, ray)), 1.);\n    }\n    fragColor = vec4(sum/SAMPLE_NUM);\n\n}","name":"Image","description":"","type":"image"}]}