{"ver":"0.1","info":{"id":"ldd3DH","date":"1449527171","viewed":721,"name":"fwidth() curvature test","username":"kuvkar","description":"Testing finding curvature with fwidth function. Left side shows curvature, white areas are curvier ones. Funny valve model by accident. \"Rust\" on the model from curvature. Went overboard with shading, was supposed to only be a test. Oh well.","likes":23,"published":1,"flags":0,"usePreview":0,"tags":["shadows","bumpmapping","curvature"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"\nmat3 rotx(float a) { mat3 rot; rot[0] = vec3(1.0, 0.0, 0.0); rot[1] = vec3(0.0, cos(a), -sin(a)); rot[2] = vec3(0.0, sin(a), cos(a)); return rot; }\nmat3 roty(float a) { mat3 rot; rot[0] = vec3(cos(a), 0.0, sin(a)); rot[1] = vec3(0.0, 1.0, 0.0); rot[2] = vec3(-sin(a), 0.0, cos(a)); return rot; }\nmat3 rotz(float a) { mat3 rot; rot[0] = vec3(cos(a), -sin(a), 0.0); rot[1] = vec3(sin(a), cos(a), 0.0); rot[2] = vec3(0.0, 0.0, 1.0); return rot; }\n\nmat3 rotation;\n\nvec3 lightDir = normalize(vec3(1.0, 1.0, -3.0));\n\nfloat map(in vec3 rp)\n{\n    rp *= rotation;\n    float m = length(rp + sin(rp * 32.) * 0.042) - 0.5;\n    m += length(sin(rp * 80.0) * 0.0025);\n    return m;\n    \n}\n\nvec3 grad(in vec3 rp)\n{\n    vec2 off = vec2(0.001, 0.0);\n    vec3 g = vec3(map(rp + off.xyy) - map(rp - off.xyy),\n                  map(rp + off.yxy) - map(rp - off.yxy),\n                  map(rp + off.yyx) - map(rp - off.yyx));\n    return normalize(g);\n}\n\n\nvec4 tex3D( sampler2D tex, in vec3 p, in vec3 n )\n{\n    p *= 2.0;\n    p *= rotation;\n    n *= rotation;\n    vec4 c1 = texture(tex, p.xy);\n    vec4 c2 = texture(tex, p.yz);\n    vec4 c3 = texture(tex, p.xz);\n    \n    vec4 color = abs(dot(n, vec3(0.0, 0.0, 1.0))) * c1;\n    color += abs(dot(n, \tvec3(1.0, 0.0, 0.0))) * c2;\n    color += abs(dot(n, \tvec3(0.0, 1.0, 0.0))) * c3;\n    return clamp(color, 0.0, 1.0);\n}\n\n\nvec3 bump(in vec3 rp, in vec3 g)\n{\n    vec2 off = vec2(0.001, 0.0);\n    float xy = tex3D(iChannel0, rp + off.xyy, g).r - tex3D(iChannel0, rp - off.xyy, g).r;\n    float zy = tex3D(iChannel0, rp + off.yyx, g).r - tex3D(iChannel0, rp - off.yyx, g).r;\n    \n    mat3 bmat;\n    bmat[0] = cross(g, vec3(0.0, 1.0, 0.0));\n    bmat[1] = cross(bmat[0], g);\n    bmat[2] = g;\n    \n    vec3 bmg = -cross( normalize(vec3(.0, 1.0, xy)), normalize(vec3(1.0, .0, zy)) );\n    return bmat * bmg;\n}\n\nfloat shadow(in vec3 rp)\n{\n    \n    mat3 trn;\n    vec3 ld = lightDir;\n    float s = 1.0;\n    const float dst = 0.04;\n    rp = rp + ld * dst * 1.04;\n    \n    for (int i = 0; i < 15; ++i)\n    {\n    \tfloat d = map(rp);\n        s = min(s, d / dst);\n        rp += max(d * 0.75, 0.01) * ld;\n    }\n    return s;\n}\n\nvoid trace(in vec3 rp, in vec3 rd, inout vec4 color)\n{\n    \n    bool hit = false;\n    for (int i = 0; i < 450; ++i)\n    {\n        float dist = map(rp);\n        if(dist < 0.0)\n        {\n            rp += dist * rd;\n            hit = true;\n            break;\n        }\n        \n        if(rp.z > 2.0) break;\n        \n        rp += rd * max(dist * 0.25, 0.0002);\n    }\n    \n    if(hit)\n    {\n        color = vec4(.0);\n        vec3 g = grad(rp);\n        float d = dot(g, lightDir);\n        d = clamp(d, 0.0, 1.0);\n        //////////////////////\n        // Getting the curvature from 2 derivates : position and normal.\n        vec3 gw = fwidth(g);\n        vec3 pw = fwidth(rp);\n        \n        float wfcurvature = length(gw) / length(pw);\n        wfcurvature = smoothstep(0.0, 30., wfcurvature);\n        color = vec4(wfcurvature);\n        \n        //// shaded version\n        if(rp.x > 0.)\n        {\n            // diffuse \n        \tcolor = vec4(pow(d, 4.0)) * vec4(.5, .7, 0.95, 0.0);\n            color = mix(color, vec4(1.0), 0.15);\n            \n            // spec\n            vec3 H = normalize(-rd + lightDir);\n            color += pow(clamp(dot(H, g), 0.0, 1.0), 34.0) * .2;\n            \n            // rim\n            float R = 1.0 - clamp(dot(g, -rd), 0.0, 1.0);\n            R = pow(R, 2.4);\n            color += R * vec4(.0, 0.4, .6, 0.0) * .8;\n            \n            \n            // \"rust\" color from curvature\n            color += vec4(.6, .2, .0, 0.0) * pow(wfcurvature, 1.4) * 0.8;\n            \n\t\t\t//Bump mapping\n            color *= vec4( pow(dot(bump(rp, g), lightDir), 2.0));\n            color *= shadow(rp) * 0.7 + 0.3;\n        }\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= vec2(0.5);\n    uv.y /= iResolution.x / iResolution.y;\n\t\n    if(iMouse.z > 0.0)\n    {\n        rotation = rotx((iMouse.y - iResolution.y * 0.5) * 0.01);\n        rotation *= roty((iMouse.x - iResolution.x * 0.5) * 0.01);\n        \n    }else\n    {\n    \trotation = rotx(iTime * 0.1) * roty(iTime * 0.2);\n    }\n    \n    fragColor = mix(vec4(1.0), vec4(0.2, 0.5, 0.95, 0.0), (uv.y + 0.5));\n    vec3 rd = normalize(vec3(uv, 0.45));\n    vec3 rp = vec3(0.0, 0.0, -1.1);\n    trace(rp, rd, fragColor);\n    if(abs(uv.x) < 0.002) fragColor = vec4(0.8);\n}","name":"","description":"","type":"image"}]}