{"ver":"0.1","info":{"id":"NsVfRG","date":"1658404149","viewed":98,"name":"Ray Marching Soft Shadow","username":"857329210","description":"Generate soft shadows using SDF and ray marching.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["lcx"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// shader input\n// uniform vec3      iResolution;           // viewport resolution (in pixels)\n// uniform float     iTime;                 // shader playback time (in seconds)\n// uniform float     iTimeDelta;            // render time (in seconds)\n// uniform int       iFrame;                // shader playback frame\n// uniform float     iChannelTime[4];       // channel playback time (in seconds)\n// uniform vec3      iChannelResolution[4]; // channel resolution (in pixels)\n// uniform vec4      iMouse;                // mouse pixel coords. xy: current (if MLB down), zw: click\n// uniform samplerXX iChannel0..3;          // input channel. XX = 2D/Cube\n// uniform vec4      iDate;                 // (year, month, day, time in seconds)\n// uniform float     iSampleRate;           // sound sample rate (i.e., 44100)\n\n#define T_MIN 0.01\n#define T_MAX 100.\n#define MAX_MARCHING_TIME 128\n#define PRECISION 0.001\n#define AA 3\n#define PI 3.14159265359\n\n\nvec2 fixUV(in vec2 c)\n{\n    //x y 转变为[-1., 1.]\n    return (2.*c - iResolution.xy)/min(iResolution.x, iResolution.y);\n}\n\nfloat sdfSphere(in vec3 p, in float r)\n{\n    return length(p) - r;\n}\n\nfloat sdTorus(in vec3 p)\n{\n  vec2 t = vec2(0.32, 0.22);\n  vec2 q = vec2(length(p.xy)-t.x,p.z);\n  return length(q)-t.y;\n}\n\nfloat sdBox( vec3 p, vec3 b)\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - 0.1;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdPlane(in vec3 p)\n{\n\n    return p.y + 0.5;\n}\n\nfloat doorway(in vec3 p)\n{\n    float d = sdBox(p-vec3(0.0, 0.0, 0.0), vec3(1.5, 0.8, 0.35));\n\n    d= max(d,-1. * sdCappedCylinder(p.xzy - vec3(0.,0.,-0.5), 1.0, 1.2));\n\n    return d;\n}\n\nfloat map(in vec3 p)\n{\n    float d = sdPlane(p);\n\n    //d = min(d, sdfSphere(p-vec3(-1.,0.,0.), 0.5));\n    d = min(d, doorway(p));\n    return d;\n}\n\n\nfloat rayMarching(in vec3 o, in vec3 dir)\n{\n    float t = T_MIN;\n    vec3 p = o + t * dir;\n    for(int i=0;i<MAX_MARCHING_TIME && t < T_MAX;++i)\n    {\n        if(map(p) < PRECISION)\n        {\n            break;\n        }\n        t += map(p);\n        p += map(p)*dir;\n    }\n    \n    return t;\n}\n\nvec3 calcNormal( in vec3 p )\n{\n    const float h = 0.0001;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ) + \n                      k.yyx*map( p + k.yyx*h ) + \n                      k.yxy*map( p + k.yxy*h ) + \n                      k.xxx*map( p + k.xxx*h ) );\n}\n\nmat3 setCamera(vec3 origin, vec3 target)\n{\n    vec3 z = normalize(target - origin);\n    vec3 up = vec3(0., 1., 0.);\n    vec3 x = normalize(cross(z, up));\n    vec3 y = cross(x, z);\n\n    return mat3(x,y,z);\n}\n\nfloat shadow(in vec3 p, in vec3 dir, int k)\n{\n    float ans = 1.0;\n    float ph = 1e20;\n\n    for(float t = T_MIN;t<T_MAX;)\n    {\n        float h = map(p + dir*t);\n        if(h < PRECISION) return 0.0;\n\n        float y = h * h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        ans = min(ans, float(k)*d/max(0.,t-y));\n        ph = h;\n        t+=h;\n    }\n\n    // for(float t = T_MIN;t<T_MAX;)\n    // {\n    //     float h = map(p + dir*t);\n    //     if(h < PRECISION) return 0.0;\n    //     ans = min(ans, float(k)*h/t);\n    //     t+=h;\n    // }\n\n    return ans;\n}\n\nvec3 render(vec2 uv)\n{\n    float tt = (uv.y+1.)/2.;\n    vec3 color = (1.-tt)*vec3(1.) + tt*vec3(0.5,0.7,1.0);\n\n    vec3 light = 3.*vec3(0.5,1.,-2.);\n    vec3 camera = 2.*vec3(2.*cos(.3*iTime), 1., 2.*sin(.3*iTime));\n    //camera = vec3(0., 1.5, -3.);\n    vec3 target = vec3(0.,0.,0.);\n    mat3 cam = setCamera(camera, target);\n\n    vec3 dir = normalize(cam * vec3(uv, 1.));\n    float t = rayMarching(camera, dir);\n\n\n    if(t < T_MAX)\n    {\n        vec3 p = camera + t * dir;          //position of shading point.\n\n        vec3 normal = calcNormal(p);\n        vec3 lightdir = normalize(light - p);\n\n        float ambient = 0.5 + 0.5 * dot(normal, vec3(0., 1., 0.));\n        //ambient = 1.;\n\n        float diffuse = clamp(dot(normal, lightdir),0.,1.);\n\n        p += PRECISION*normal;\n\n        diffuse *= shadow(p, lightdir, 50);\n\n        color = ambient * vec3(0.05) + diffuse*vec3(1.);\n    } \n    \n    return sqrt(color);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fixUV(fragCoord);\n    vec3 color = vec3(0.);\n    for(int m = 0; m < AA; m++) \n    for(int n = 0; n < AA; n++) {\n        vec2 offset = 2. * (vec2(float(m), float(n)) / float(AA) - .5);\n        vec2 uv = fixUV(fragCoord + offset);\n        color += render(uv);\n    }\n    fragColor = vec4(color / float(AA * AA), 1.);\n}","name":"Image","description":"","type":"image"}]}