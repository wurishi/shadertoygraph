{"ver":"0.1","info":{"id":"mdGSDG","date":"1681527238","viewed":278,"name":"Space Needle","username":"Kali","description":"Made for Shining Monster. If music doesn't work press pause on iChannel1 and play again.","likes":31,"published":1,"flags":96,"usePreview":0,"tags":["city","gift","grunge","skyline","seattle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XscGz8","filepath":"https://soundcloud.com/nadia-block/nirvana-dumb","previewfilepath":"https://soundcloud.com/nadia-block/nirvana-dumb","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// HAPPY BIRTHDAY SHINING MONSTER!!! THANKS FOR YOUR FRIENDSHIP :)\n\n// If music doesn't work press pause on iChannel1 below and play again \n\nfloat det=.01;\nvec3 objcol;\n\nmat2 rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\nfloat hash(vec2 p)\n{\n    p*=1000.;\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise(float x) {\n    float fr=fract(x);\n    float fl=floor(x);\n    return mix(hash(vec2(fl)),hash(vec2(fl+1.)),smoothstep(0.,1.,fr));\n}\n\nfloat box(vec3 p, vec3 c) {\n    p=abs(p)-c;\n    return length(max(vec3(0.),p));\n}\n\nfloat cyl(vec3 p, float r, float h, float d, float e, float f) {\n    p.y*=f;\n    vec3 pp=p;\n    \n    pp.y+=h;\n    r+=pow(abs(pp.y),e)*d;\n    return max(abs(p.y)-h,length(p.xz)-r);\n}\n\nvoid radialCopy(inout vec2 p, float cant, float offset) \n{\n    float d = 3.1416 / cant * 2.;\n    float at = atan(p.y, p.x);\n    float a = mod(at, d) - d *.5;\n    p = vec2(cos(a), sin(a)) * length(p) - vec2(offset,0.);\n}\n\nfloat glass(vec3 p) {\n    vec3 p1=p, p2=p, p3=p;\n    p.y+=2.8;\n    p.xz*=1.-p.y*.03;\n    radialCopy(p.xz, 40., 8.5);\n    float d=box(p, vec3(.3,.88,.5));\n    p1.y+=5.;\n    p1.xz*=1.-p1.y*.05;\n    radialCopy(p1.xz, 30., 7.);\n    d=min(d, box(p1, vec3(.3,.8,.6)));\n    p2.y-=2.3;\n    return d*.5;\n}\n\nfloat head(vec3 p) {\n    p.y-=1.;\n    vec3 p1=p;\n    p1.y-=1.;\n    float d=cyl(p1, 3.7, .2, 1., 1.2, -1.);\n    d=min(d,cyl(p, 3., .8, .4, 2., 1.));\n    p.y+=1.5;\n    d=min(d,cyl(p, 3., 1.2, 2., 1.2, -1.));\n    vec3 p2=p;\n    p2.y+=3.;\n    p2.y=abs(p2.y);\n    d=min(d,cyl(p2, 8.3, .5, 5., 1., -1.));\n    vec3 p3=p;\n    p3.y+=5.7;\n    p3.y=abs(p3.y);\n    d=min(d,cyl(p3, 7., .5, 2., 1., -1.));\n    vec3 p4=p;\n    p4.y-=4.;\n    d=min(d,cyl(p4, .8, 1., 0.2, 1., -1.));\n    p.y+=3.;\n    d=min(d,cyl(p,7.,2.,0.,1.,1.));\n    return d*.5;\n}\n\nfloat tower(vec3 p) {\n    vec3 p1=p;\n    radialCopy(p.xz, 3., 2.);\n    p.xz*=rot(radians(90.));\n    p.y*=.8;\n    p.x*=1.2;\n    p.y+=25.;\n    float y=p.y-10.;\n    p.z+=y*(10.+y)*.007;\n    float r=y*(20.+y*2.)*.005*(.1+smoothstep(-10.,0.,y));\n    r*=1.+y*.02;\n    float d=box(p, vec3(1.5+r,20.,.2));\n    p.y-=24.;\n    float hue1=length(p.xy*vec2(5.,1.))-13.;\n    d=max(d,-hue1*.5);\n    p.y+=41.;\n    float hue2=length(p.xy*vec2(15.,1.))-19.;\n    d=max(d,-hue2*.1);\n    p1.xz*=rot(radians(60.));\n    radialCopy(p1.xz, 3., 2.);\n    p1.y+=36.;\n    d=min(d,box(p1,vec3(.2,.5,1.5)));\n    p.y=mod(p.y,3.)-1.5;\n    float esc=box(p, vec3(1.2,.2,.2));\n    esc=max(esc,y);\n    esc=max(esc,-y-30.);\n    d=min(d,esc);\n    return d*.8;\n}\n\nfloat center(vec3 p) {\n    float a=length(p.xz)-.6+p.y*.05;\n    a=max(a,-p.y);\n    vec3 p2=p, p3=p;\n    p2.y=mod(p2.y,1.5)-.75;\n    float d=max(abs(p.y+25.)-25.,box(p2,vec3(1.,.2,.2)));\n    p2.xz*=.9;\n    d=min(d,max(max(abs(p.y+30.)-25.,length(p2.xz)-.85-abs(.5-fract(atan(p.x,p.z)))),-length(p2.xz)+1.2));\n    d=min(d,a);\n    p3.y-=2.5;\n    p3.xz*=1.+p3.y*.1;\n    radialCopy(p3.xz, 21., 3.);\n    d=min(d, box(p3, vec3(.3,.8,.4)));\n    return d;\n}\n\nfloat de(vec3 p) {\n    p.xz*=rot(-.3);\n    objcol=vec3(.95,.85,.8)*.8;\n    p.y-=15.;\n    float hea=head(p);\n    float gla=glass(p);\n    float tow=tower(p)*.5;\n    float cen=center(p);\n    float d=min(tow,min(hea,gla));\n    if (d==gla) objcol=vec3(.8,.9,1.)*.65;\n    d=min(d,cen);\n    if (d==cen) objcol=vec3(.4,.35,.3);\n    return d;\n}\n\nvec3 normal(vec3 p) {\n    vec2 e=vec2(0.,det);\n    return normalize(vec3(de(p+e.yxx),de(p+e.xyx),de(p+e.xxy))-de(p));\n}\n\nvec2 line( in vec2 p, in vec2 a, in vec2 b )\n{  vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec2(length( pa - ba*h ),h);\n}\n\nvec3 background(vec2 uv) {\n  float so=texture(iChannel1,vec2(.3)).x;\n  vec2 p = (gl_FragCoord.xy-iResolution.xy*.5)/iResolution.y;\n  p=uv*5.;\n  vec2 p2=p;\n  float id1=floor(p.x*7.)*120.123;\n  float id2=floor(p.x*3.5);\n  float h=floor(hash(vec2(id1))*step(.12,hash(vec2(id2)))*14.*1.5)/(14.*1.5);\n  vec3 sky=vec3(.9,.8,.7)*(.7+mod(gl_FragCoord.y,5.)*.05);\n  sky-=smoothstep(-.38,-.4,p.y+noise(uv.x*30.)*.07)*.2*vec3(1.5,1.,0.5);\n  //h-=step(fract(p.x*7.),.05);\n  float skyline=step(-.75+h*.8,p.y);\n  vec3 col=mix(vec3(-p.y*.25)+.1,sky,skyline);\n  vec2 id=floor(p*14.*1.5);\n  vec2 v=fract(p*14.*1.5-.125);\n  skyline=step(-.77+h*.8,p.y);\n  col+=step(length(max(vec2(0.),abs(v)-.7)),0.)*\n      (1.-skyline)*.3*hash(id)*step(.6,hash(id))*step(-.9,p.y)*vec3(1.,.8,.7);\n  col.rb*=rot(clamp(-.5,.0,-p2.y*.15-.05)*2.);\n  col.b*=.95;\n  col*=.5+smoothstep(1.3,0.,p.y)*.5;\n  vec2 l=line(p,vec2(-.5,.03),vec2(.5,.6));\n  float tt=iTime-15.;\n  float tr=1.-l.y*2.-tt*4.+2.;\n  col=mix(col,vec3(.8),smoothstep(.01,.0,l.x)*smoothstep(0.,1.,fract(tr)*step(0.,tr)*step(tr,1.)));\n  float st=hash(floor(p*80.)/80.);\n  col+=step(.999,st)*clamp(p.y+.7,0.,1.)*.11*st*st;\n  return col*(1.1+so*.35);\n}\n\nvec3 march(vec3 from, vec3 dir) {\n    vec3 p, col=background(dir.xy);\n    float d, td=0., maxdist=150.;\n    float g=0.;\n    for (int i=0; i<150; i++) {\n        p=from+dir*td;\n        d=de(p);\n        if (d<det || td>maxdist) break;\n        td+=d;\n        g+=.1/(.1+d*10.);\n    }\n    if (d<det) {\n        p-=dir*det*2.;\n        vec3 n=normal(p);\n        vec3 ldir=normalize(vec3(.9,1.,-1.));\n        col=objcol*(smoothstep(.5,.55,max(0.,dot(ldir,n)))*.45+.85);\n    } else td=maxdist;\n    return col-g*.015;\n}\n\nvoid texto(inout vec3 col, vec2 offset) {\n    vec2 uv=gl_FragCoord.xy/iResolution.xy*2.;\n    vec4 tx = texture(iChannel0, uv+offset);\n    col = mix(col, tx.rgb, length(tx.rgb));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n  vec3 col=vec3(0.), dir;\n  for (float i=0.; i<4.; i++) {\n      uv+=vec2(mod(i,2.),floor(i/2.))/iResolution.xy*.8;\n      float a=smoothstep(-2.,2.,sin((iTime+14.)*.15));\n      vec3 from = vec3(-23.,4.+a*3.,-120.);\n      dir = normalize(vec3(uv,2.+a));\n      from.x+=a*a*20.;\n      from.xz*=rot(a*a);\n      dir.xz*=rot(a*a);\n      col += march(from, dir);\n  }\n  col/=4.;\n  col*=vec3(1.,.95,.9)*1.1-hash(uv+floor(mod(iTime,10.)*15.)*.2)*.15;\n  col=pow(col,vec3(1.4));\n  texto(col,vec2(.0,.35));\n  col*=smoothstep(0.,4.,iTime);\n  fragColor = vec4(col,1.);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// ↙\n//  ↙\n//   ↙\n// https://youtu.be/dQw4w9WgXcQ\n\n// compare algorithm performance, comment out line below to see previous performance:\n#define ANOTHER_ALGORITHM      // runs slower on ARM, so comment this out if mobile phone performance is priority\n\nvec2 uv;\n\n#define time iTime\n#define resolution iResolution\n\nconst vec2 ch_size  = vec2(1.0, 2.0) * 0.6;              // character size (X,Y)\nconst vec2 ch_space = ch_size + vec2(1.5, 1.0);    // character distance Vector(X,Y)\nconst vec2 ch_start = vec2 (ch_space.x * -5., 1.); // start position\n      vec2 ch_pos   = vec2 (0.0, 0.0);             // character position(X,Y)\n//      vec3 ch_color = vec3 (1.5, 0.75, 0.5);        // character color (R,G,B)\n//const vec3 bg_color = vec3 (0.2, 0.2, 0.2);        // background color (R,G,B)\n\n#define REPEAT_SIGN false // True/False; True=Multiple, False=Single\n\n/* 16 segment display...Akin to LED Display.\n\nSegment bit positions:\n  __2__ __1__\n |\\    |    /|\n | \\   |   / |\n 3  11 10 9  0\n |   \\ | /   |\n |    \\|/    |\n  _12__ __8__\n |           |\n |    /|\\    |\n 4   / | \\   7\n | 13 14  15 |\n | /   |   \\ |\n  __5__|__6__\n\n15 12 11 8 7  4 3  0\n |  | |  | |  | |  |\n 0000 0000 0000 0000\n\nexample: letter A\n\n   12    8 7  4 3210\n    |    | |  | ||||\n 0001 0001 1001 1111\n\n binary to hex -> 0x119F\n*/\n\n// split 16 Bit int into two 8 Bit int for mobile phones with ridiculous 1-byte int\n#define n0 ddigit(0x22,0xFF);\n#define n1 ddigit(0x02,0x81);\n#define n2 ddigit(0x11,0x77);\n#define n3 ddigit(0x11,0xE7);\n#define n4 ddigit(0x55,0x08);\n#define n5 ddigit(0x11,0xEE);\n#define n6 ddigit(0x11,0xFE);\n#define n7 ddigit(0x22,0x06);\n#define n8 ddigit(0x11,0xFF);\n#define n9 ddigit(0x11,0xEF);\n\n#define A ddigit(0x11,0x9F);\n#define B ddigit(0x92,0x7E);\n#define C ddigit(0x00,0x7E);\n#define D ddigit(0x44,0xE7);\n#define E ddigit(0x10,0x7E);\n#define F ddigit(0x10,0x1E);\n#define G ddigit(0x80,0x7E);\n#define H ddigit(0x11,0x99);\n#define I ddigit(0x44,0x66);\n#define J ddigit(0x44,0x36);\n#define K ddigit(0x92,0x18);\n#define L ddigit(0x00,0x78);\n#define M ddigit(0x0A,0x99);\n#define N ddigit(0x88,0x99);\n#define O ddigit(0x00,0xFF);\n#define P ddigit(0x11,0x1F);\n#define Q ddigit(0x80,0xFF);\n#define R ddigit(0x91,0x1F);\n#define S ddigit(0x88,0x66);\n#define T ddigit(0x44,0x06);\n#define U ddigit(0x00,0xF9);\n#define u ddigit(0x00,0xF0);\n#define V ddigit(0x22,0x18);\n#define W ddigit(0xA0,0x99);\n#define w ddigit(0xA0,0x90);\n#define X ddigit(0xAA,0x00);\n#define Y ddigit(0x4A,0x00);\n#define Z ddigit(0x22,0x66);\n#define _ ch_pos.x += ch_space.x;\n#define s_dot     ddigit(0,0);\n#define s_minus   ddigit(0x11,0x00);\n#define s_plus    ddigit(0x55,0x00);\n#define s_greater ddigit(0x28,0x00);\n#define s_less    ddigit(0x82,0x00);\n#define s_sqrt    ddigit(0x0C,0x02);\n#define s_sw      ddigit(0x55,0xAA);\n#define s_pow     ddigit(0x02,0x01);\n#define upper_u   ddigit(0x11,0x09);\n#define s_bra    ddigit(0x00,0x3C);\n#define s_ket    ddigit(0x00,0xC3);\n#define s_quotl    ddigit(0x04,0x01);\n#define s_quotr    ddigit(0x04,0x08);\n#define s_degrees    ddigit(0x05,0x03);\n#define s_ast    ddigit(0xFF,0x00);\n#define s_question ch_pos-=vec2(-.45,.4); ddigit(0,0); ch_pos+=vec2(-ch_space.x-.45,.4); ddigit(0x41,0x07);\n#define s_exclam   ch_pos-=vec2(-.45,.4); ddigit(0,0); ch_pos+=vec2(-ch_space.x-.45,.4); ddigit(0x44,0x00);\n#define s_comma   ch_pos-=vec2(.45); ddigit(0x20,0x00); ch_pos+=vec2(.45);\n#define nl1 ch_pos = ch_start;  ch_pos.y -= 3.0;\n#define nl2 ch_pos = ch_start;  ch_pos.y -= 6.0;\n#define nl3 ch_pos = ch_start;\tch_pos.y -= 9.0;\n\n#ifdef ANOTHER_ALGORITHM\nfloat dseg1(vec2 p0, vec2 p1)\n{\n\tvec2 cp = vec2(uv.x-(uv.y*.5-ch_pos.y*.5-p0.y), uv.y) - ch_pos - p0;\n\treturn distance(cp, vec2(0., clamp(cp.y, 0., p1.y-p0.y)) );\n}\nfloat dseg2(vec2 p0, vec2 p1)\n{\n\tvec2 cp = vec2(uv.x+(uv.y*.5-.9-ch_pos.y*.5-p0.y), uv.y) - ch_pos - p0;\n\treturn distance(cp, vec2(0., clamp(cp.y, 0., p1.y-p0.y)) );\n}\n#else\nfloat dseg(vec2 p0, vec2 p1)\n{\n\tvec2 dir = normalize(p1 - p0);\n\tvec2 cp = (uv - ch_pos - p0) * mat2(dir.x, dir.y,-dir.y, dir.x);\n\treturn distance(cp, clamp(cp, vec2(0), vec2(distance(p0, p1), 0)));\n}\n#endif\nfloat dsegH(vec2 p0, vec2 p1) // avoiding matric ops\n{\n\tvec2 cp = uv - ch_pos - p0;\n\t//return distance(cp, clamp(cp, vec2(0), vec2(distance(p0, p1), 0)));\n\treturn distance(cp, vec2(clamp(cp.x, 0., p1.x-p0.x), 0.) );\n}\nfloat dsegV(vec2 p0, vec2 p1) // avoiding matrix ops\n{\n\tvec2 cp = uv - ch_pos - p0;\n\t//return distance(cp, clamp(cp, vec2(0), vec2(0, distance(p0, p1))));\n\treturn distance(cp, vec2(0., clamp(cp.y, 0., p1.y-p0.y)) );\n}\n\nbool bit(int n)\n{\n\treturn (n/2)*2 != n;\n}\n\nfloat d = 1e6;\n\n#ifdef ANOTHER_ALGORITHM\t\t// Intel skylake GPU seems to prefer this\nvoid ddigit(int n, int nn)\n{\n\tfloat v = 1e6;\n\tvec2 cp = uv - ch_pos;\n\t// better performance in this order, on Intel Iris 550 skylake  (WHY does order matter??)\n\tif (n == 0 && nn==0)     v = min(v, dsegH(vec2(-0.405, -1.000), vec2(-0.500, -1.000)));\n\tif (bit(nn/4)) v = min(v, dsegH(vec2( -0.438,  1.000), vec2(-0.063, 1.000)));\n\tif (bit(nn/2)) v = min(v, dsegH(vec2(0.063,  1.000), vec2(0.438,  1.000)));\n\tif (bit(nn/32)) v = min(v, dsegH(vec2(-0.438, -1.000), vec2(-0.063, -1.000)));\n\tif (bit(nn/64)) v = min(v, dsegH(vec2( 0.063, -1.000), vec2( 0.438, -1.000)));\n\tif (bit(n/1)) v = min(v, dsegH(vec2( 0.063,  0.000), vec2( 0.438, -0.000)));\n\tif (bit(n/16)) v = min(v, dsegH(vec2(-0.438,  0.000), vec2(-0.063, -0.000)));\n\tif (bit(nn/1)) v = min(v, dsegV(vec2( 0.500,  0.063), vec2( 0.500,  0.937)));\n\tif (bit(nn/128)) v = min(v, dsegV(vec2( 0.500, -0.938), vec2( 0.500, -0.063)));\n\tif (bit(n/4)) v = min(v, dsegV(vec2( 0.000,  0.063), vec2( 0.000,  0.937)));\n\tif (bit(n/64)) v = min(v, dsegV(vec2( 0.000, -0.938), vec2( 0.000, -0.063)));\n\tif (bit(nn/8)) v = min(v, dsegV(vec2(-0.500,  0.063), vec2(-0.500,  0.937)));\n\tif (bit(nn/16)) v = min(v, dsegV(vec2(-0.500, -0.938), vec2(-0.500, -0.063)));\n\t// matrix ops last\n\tif (bit(n/2)) v = min(v, dseg1(vec2( 0.063,  0.063), vec2( 0.063,  0.938)));\n\tif (bit(n/8)) v = min(v, dseg2(vec2(-0.963,  0.063), vec2(-1.338,  0.938)));\n\tif (bit(n/32)) v = min(v, dseg1(vec2(-0.963, -0.938), vec2(-0.963, -0.063)));\n\tif (bit(n/128)) v = min(v, dseg2(vec2( 0.063, -0.938), vec2( 0.063, -0.063)));\n\tch_pos.x += ch_space.x;\n\td = min(d, v);\n}\n#else\t\t// some GPU's may run faster with this\nvoid ddigit(int n, int nn)\n{\n\tfloat v = 1e6;\n    vec2 cp = uv - ch_pos;\n    if (n == 0 && nn == 0)     v = min(v, dseg(vec2(-0.405, -1.000), vec2(-0.500, -1.000)));\n\tif (bit(nn/1)) v = min(v, dseg(vec2( 0.500,  0.063), vec2( 0.500,  0.937)));\n\tif (bit(nn/2)) v = min(v, dseg(vec2( 0.438,  1.000), vec2( 0.063,  1.000)));\n\tif (bit(nn/4)) v = min(v, dseg(vec2(-0.063,  1.000), vec2(-0.438,  1.000)));\n\tif (bit(nn/8)) v = min(v, dseg(vec2(-0.500,  0.937), vec2(-0.500,  0.062)));\n\tif (bit(nn/16)) v = min(v, dseg(vec2(-0.500, -0.063), vec2(-0.500, -0.938)));\n\tif (bit(nn/32)) v = min(v, dseg(vec2(-0.438, -1.000), vec2(-0.063, -1.000)));\n\tif (bit(nn/64)) v = min(v, dseg(vec2( 0.063, -1.000), vec2( 0.438, -1.000)));\n\tif (bit(nn/128)) v = min(v, dseg(vec2( 0.500, -0.938), vec2( 0.500, -0.063)));\n\tif (bit(n/1)) v = min(v, dseg(vec2( 0.063,  0.000), vec2( 0.438, -0.000)));\n\tif (bit(n/2)) v = min(v, dseg(vec2( 0.063,  0.063), vec2( 0.438,  0.938)));\n\tif (bit(n/4)) v = min(v, dseg(vec2( 0.000,  0.063), vec2( 0.000,  0.937)));\n\tif (bit(n/8)) v = min(v, dseg(vec2(-0.063,  0.063), vec2(-0.438,  0.938)));\n\tif (bit(n/16)) v = min(v, dseg(vec2(-0.438,  0.000), vec2(-0.063, -0.000)));\n\tif (bit(n/32)) v = min(v, dseg(vec2(-0.063, -0.063), vec2(-0.438, -0.938)));\n\tif (bit(n/64)) v = min(v, dseg(vec2( 0.000, -0.938), vec2( 0.000, -0.063)));\n\tif (bit(n/128)) v = min(v, dseg(vec2( 0.063, -0.063), vec2( 0.438, -0.938)));\n\tch_pos.x += ch_space.x;\n\td = min(d, v);\n}\n#endif\n\nmat2 rotate(float a)\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\n\tvec2 aspect = resolution.xy / resolution.y;\n\tuv = ( gl_FragCoord.xy / resolution.y ) - aspect / 2.0;\n\tfloat _d =  1.0-length(uv);\n\tuv *= 36.0 ;\n\t//uv -= vec2(-17., 4.);\n    //uv *= rotate(time+uv.x*0.05);\n\n\tuv.x+=20.;\n    //uv.y+=sin(uv.x*.3+time*3.)*.2;\n    uv.y+=2.;\n    float tt=mod(time*2.,15.);\n    uv.y-=tt;\n    if (uv.x<17.5) uv*=1.2,uv.x-=2.,uv.y+=1.3;\n    ch_pos = ch_start;\n\n\t\t\tnl2\n\t   \t\tH A P P Y _ B I R T H D A Y _ S H I N I N G _ M O N S T E R\n    float a = smoothstep(0.4,0.2,d)*smoothstep(15.,13.,tt);\n    float b = smoothstep(0.5,0.4,d) * .8;\n  \tvec3 ch_color = mix(vec3(2.,1.5,1.),vec3(.4),.2-uv.y*.1);\n    vec3 col=ch_color*a;\n    fragColor = vec4(col, max(a,b));\n}\n","name":"Buffer A","description":"","type":"buffer"}]}